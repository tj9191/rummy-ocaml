// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=runtime, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Assert_failure, Division_by_zero, End_of_file, Failure, Invalid_argument, Match_failure, Not_found, Out_of_memory, Stack_overflow, Sys_blocked_io, Sys_error, Undefined_recursive_module
//# unitInfo: Primitives: %caml_format_int_special, %direct_int_div, %direct_int_mod, %direct_int_mul, %direct_obj_tag, %identity, %int_add, %int_and, %int_asr, %int_div, %int_lsl, %int_lsr, %int_mod, %int_mul, %int_neg, %int_or, %int_sub, %int_xor, Base_am_testing, Base_caml_exn_is_most_recent_exn, Base_clear_caml_backtrace_pos, Base_hash_double, Base_hash_string, Base_int_math_int32_clz, Base_int_math_int32_ctz, Base_int_math_int64_clz, Base_int_math_int64_ctz, Base_int_math_int64_pow_stub, Base_int_math_int_clz, Base_int_math_int_ctz, Base_int_math_int_popcount, Base_int_math_int_pow_stub, Base_int_math_nativeint_clz, Base_int_math_nativeint_ctz, Base_internalhash_fold_float, Base_internalhash_fold_int, Base_internalhash_fold_int64, Base_internalhash_fold_string, Base_internalhash_get_hash_value, Base_unsafe_create_local_bytes, BigStringReader, MlBytes, MlFakeDevice, MlFakeFd, MlFakeFd_out, MlFakeFile, MlFile, MlInt64, MlMutex, MlNat, MlNodeDevice, MlNodeFd, MlObjectTable, MlStringReader, Ml_Bigarray, Ml_Bigarray_c_1_1, UInt8ArrayReader, add_nat, bigstring_alloc_v2, bigstring_blit_bigstring_bytes_stub, bigstring_blit_bytes_bigstring_stub, bigstring_blit_string_bigstring_stub, bigstring_blit_stub, bigstring_destroy_stub, bigstring_find, bigstring_is_mmapped_stub, bigstring_memcmp_bytes_stub, bigstring_memcmp_stub, bigstring_memmem_bytecode, bigstring_memset_stub, bigstring_of_array_buffer, bigstring_of_typed_array, bigstring_realloc, bigstring_to_array_buffer, bigstring_to_typed_array, bigstringaf_blit_from_bytes, bigstringaf_blit_to_bigstring, bigstringaf_blit_to_bytes, bigstringaf_memchr, bigstringaf_memcmp_bigstring, bigstringaf_memcmp_string, bin_prot_blit_buf_bytes_stub, bin_prot_blit_buf_float_array_stub, bin_prot_blit_buf_stub, bin_prot_blit_bytes_buf_stub, bin_prot_blit_float_array_buf_stub, bin_prot_blit_string_buf_stub, blit_nat, caml_MD5Final, caml_MD5Init, caml_MD5Transform, caml_MD5Update, caml_abs_float, caml_acos_float, caml_acosh_float, caml_add_float, caml_alloc_dummy, caml_alloc_dummy_float, caml_alloc_dummy_infix, caml_alloc_stack, caml_argv, caml_array_append, caml_array_blit, caml_array_bound_error, caml_array_concat, caml_array_fill, caml_array_get, caml_array_get_addr, caml_array_get_float, caml_array_of_bytes, caml_array_of_string, caml_array_set, caml_array_set_addr, caml_array_set_float, caml_array_sub, caml_array_unsafe_get, caml_array_unsafe_get_float, caml_array_unsafe_set, caml_array_unsafe_set_float, caml_asin_float, caml_asinh_float, caml_atan2_float, caml_atan_float, caml_atanh_float, caml_atomic_cas, caml_atomic_exchange, caml_atomic_fetch_add, caml_atomic_load, caml_atomic_make_contended, caml_ba_blit, caml_ba_change_layout, caml_ba_compare, caml_ba_create, caml_ba_create_buffer, caml_ba_create_from, caml_ba_create_unsafe, caml_ba_custom_name, caml_ba_deserialize, caml_ba_dim, caml_ba_dim_1, caml_ba_dim_2, caml_ba_dim_3, caml_ba_fill, caml_ba_from_typed_array, caml_ba_get_1, caml_ba_get_2, caml_ba_get_3, caml_ba_get_generic, caml_ba_get_size, caml_ba_get_size_per_element, caml_ba_hash, caml_ba_init, caml_ba_kind, caml_ba_kind_of_typed_array, caml_ba_layout, caml_ba_map_file, caml_ba_map_file_bytecode, caml_ba_num_dims, caml_ba_reshape, caml_ba_serialize, caml_ba_set_1, caml_ba_set_2, caml_ba_set_3, caml_ba_set_generic, caml_ba_slice, caml_ba_sub, caml_ba_to_typed_array, caml_ba_uint8_get16, caml_ba_uint8_get32, caml_ba_uint8_get64, caml_ba_uint8_set16, caml_ba_uint8_set32, caml_ba_uint8_set64, caml_backtrace_status, caml_bigstring_blit_ba_to_ba, caml_bigstring_blit_ba_to_bytes, caml_bigstring_blit_bytes_to_ba, caml_bigstring_blit_string_to_ba, caml_bigstring_memcmp, caml_blit_bytes, caml_blit_string, caml_bswap16, caml_build_symbols, caml_bytes_bound_error, caml_bytes_compare, caml_bytes_equal, caml_bytes_get, caml_bytes_get16, caml_bytes_get32, caml_bytes_get64, caml_bytes_greaterequal, caml_bytes_greaterthan, caml_bytes_lessequal, caml_bytes_lessthan, caml_bytes_notequal, caml_bytes_of_array, caml_bytes_of_jsbytes, caml_bytes_of_string, caml_bytes_of_utf16_jsstring, caml_bytes_set, caml_bytes_set16, caml_bytes_set32, caml_bytes_set64, caml_bytes_unsafe_get, caml_bytes_unsafe_set, caml_call_gen, caml_callback, caml_cbrt_float, caml_ceil_float, caml_channel_descriptor, caml_check_bound, caml_check_bound_bigstring, caml_classify_float, caml_compare, caml_compare_val, caml_compare_val_get_custom, caml_compare_val_number_custom, caml_compare_val_tag, caml_continuation_use_and_update_handler_noexc, caml_continuation_use_noexc, caml_convert_bytes_to_array, caml_convert_raw_backtrace, caml_convert_raw_backtrace_slot, caml_convert_string_to_bytes, caml_copysign_float, caml_cos_float, caml_cosh_float, caml_create_bytes, caml_create_file, caml_create_string, caml_csel_value, caml_current_dir, caml_custom_event_index, caml_custom_ops, caml_decompress_input, caml_div, caml_div_float, caml_domain_dls, caml_domain_dls_get, caml_domain_dls_set, caml_domain_id, caml_domain_spawn, caml_dummy_obj_is_stack, caml_ensure_stack_capacity, caml_ephe_blit_data, caml_ephe_blit_key, caml_ephe_check_data, caml_ephe_check_key, caml_ephe_create, caml_ephe_data_offset, caml_ephe_get_data, caml_ephe_get_data_copy, caml_ephe_get_key, caml_ephe_get_key_copy, caml_ephe_key_offset, caml_ephe_set_data, caml_ephe_set_key, caml_ephe_unset_data, caml_ephe_unset_key, caml_eq_float, caml_equal, caml_erf_float, caml_erfc_float, caml_eventlog_pause, caml_eventlog_resume, caml_executable_name, caml_exn_with_js_backtrace, caml_exp2_float, caml_exp_float, caml_expm1_float, caml_failwith, caml_fatal_uncaught_exception, caml_fill_bytes, caml_fill_string, caml_final_register, caml_final_register_called_without_value, caml_final_release, caml_finish_formatting, caml_float_compare, caml_float_of_bytes, caml_float_of_int, caml_float_of_string, caml_floatarray_blit, caml_floatarray_create, caml_floatarray_get, caml_floatarray_set, caml_floatarray_unsafe_get, caml_floatarray_unsafe_set, caml_floor_float, caml_fma_float, caml_fmod_float, caml_format_exception, caml_format_float, caml_format_int, caml_fresh_oo_id, caml_frexp_float, caml_fs_init, caml_gc_compaction, caml_gc_counters, caml_gc_full_major, caml_gc_get, caml_gc_huge_fallback_count, caml_gc_major, caml_gc_major_slice, caml_gc_minor, caml_gc_minor_words, caml_gc_quick_stat, caml_gc_set, caml_gc_stat, caml_ge_float, caml_get_continuation_callstack, caml_get_current_callstack, caml_get_exception_backtrace, caml_get_exception_raw_backtrace, caml_get_global_data, caml_get_major_bucket, caml_get_major_credit, caml_get_minor_free, caml_get_public_method, caml_get_root, caml_global_data, caml_gr_arc_aux, caml_gr_blit_image, caml_gr_clear_graph, caml_gr_close_graph, caml_gr_close_subwindow, caml_gr_create_image, caml_gr_current_x, caml_gr_current_y, caml_gr_display_mode, caml_gr_doc_of_state, caml_gr_draw_arc, caml_gr_draw_char, caml_gr_draw_image, caml_gr_draw_rect, caml_gr_draw_str, caml_gr_draw_string, caml_gr_dump_image, caml_gr_fill_arc, caml_gr_fill_poly, caml_gr_fill_rect, caml_gr_lineto, caml_gr_make_image, caml_gr_moveto, caml_gr_open_graph, caml_gr_open_subwindow, caml_gr_plot, caml_gr_point_color, caml_gr_remember_mode, caml_gr_resize_window, caml_gr_set_color, caml_gr_set_font, caml_gr_set_line_width, caml_gr_set_text_size, caml_gr_set_window_title, caml_gr_sigio_handler, caml_gr_sigio_signal, caml_gr_size_x, caml_gr_size_y, caml_gr_state, caml_gr_state_create, caml_gr_state_get, caml_gr_state_init, caml_gr_state_set, caml_gr_synchronize, caml_gr_text_size, caml_gr_wait_event, caml_gr_window_id, caml_greaterequal, caml_greaterthan, caml_gt_float, caml_hash, caml_hash_mix_bigstring, caml_hash_mix_bytes, caml_hash_mix_bytes_arr, caml_hash_mix_final, caml_hash_mix_float, caml_hash_mix_int, caml_hash_mix_int64, caml_hash_mix_jsbytes, caml_hash_mix_string, caml_hash_nat, caml_hexstring_of_float, caml_hypot_float, caml_input_value, caml_input_value_from_bytes, caml_input_value_from_reader, caml_input_value_from_string, caml_input_value_to_outside_heap, caml_install_signal_handler, caml_int32_add, caml_int32_and, caml_int32_bits_of_float, caml_int32_bswap, caml_int32_compare, caml_int32_div, caml_int32_float_of_bits, caml_int32_format, caml_int32_mod, caml_int32_mul, caml_int32_neg, caml_int32_of_float, caml_int32_of_int, caml_int32_of_string, caml_int32_or, caml_int32_shift_left, caml_int32_shift_right, caml_int32_shift_right_unsigned, caml_int32_sub, caml_int32_to_float, caml_int32_to_int, caml_int32_unmarshal, caml_int32_xor, caml_int64_add, caml_int64_and, caml_int64_bits_of_float, caml_int64_bswap, caml_int64_compare, caml_int64_create_lo_hi, caml_int64_create_lo_mi_hi, caml_int64_div, caml_int64_float_of_bits, caml_int64_format, caml_int64_hash, caml_int64_hi32, caml_int64_is_negative, caml_int64_is_zero, caml_int64_lo32, caml_int64_marshal, caml_int64_mod, caml_int64_mul, caml_int64_neg, caml_int64_of_bytes, caml_int64_of_float, caml_int64_of_int, caml_int64_of_int32, caml_int64_of_nativeint, caml_int64_of_string, caml_int64_offset, caml_int64_or, caml_int64_shift_left, caml_int64_shift_right, caml_int64_shift_right_unsigned, caml_int64_sub, caml_int64_to_bytes, caml_int64_to_float, caml_int64_to_int, caml_int64_to_int32, caml_int64_to_nativeint, caml_int64_ult, caml_int64_unmarshal, caml_int64_xor, caml_int_compare, caml_int_of_float, caml_int_of_string, caml_invalid_argument, caml_is_continuation_tag, caml_is_js, caml_is_ml_bytes, caml_is_ml_string, caml_is_printable, caml_is_special_exception, caml_js_call, caml_js_delete, caml_js_equals, caml_js_error_of_exception, caml_js_error_option_of_exception, caml_js_eval_string, caml_js_expr, caml_js_from_array, caml_js_from_bool, caml_js_from_float, caml_js_from_int32, caml_js_from_nativeint, caml_js_from_string, caml_js_fun_call, caml_js_function_arity, caml_js_get, caml_js_get_console, caml_js_html_entities, caml_js_html_escape, caml_js_instanceof, caml_js_meth_call, caml_js_new, caml_js_object, caml_js_on_ie, caml_js_pure_expr, caml_js_set, caml_js_strict_equals, caml_js_to_array, caml_js_to_bool, caml_js_to_byte_string, caml_js_to_float, caml_js_to_int32, caml_js_to_nativeint, caml_js_to_string, caml_js_typeof, caml_js_var, caml_js_wrap_callback, caml_js_wrap_callback_arguments, caml_js_wrap_callback_strict, caml_js_wrap_callback_unsafe, caml_js_wrap_meth_callback, caml_js_wrap_meth_callback_arguments, caml_js_wrap_meth_callback_strict, caml_js_wrap_meth_callback_unsafe, caml_jsbytes_of_string, caml_jsoo_flags_effects, caml_jsoo_flags_use_js_string, caml_jsstring_of_string, caml_lazy_make_forward, caml_lazy_read_result, caml_lazy_reset_to_lazy, caml_lazy_update_to_forcing, caml_lazy_update_to_forward, caml_ldexp_float, caml_le_float, caml_lessequal, caml_lessthan, caml_lex_array, caml_lex_engine, caml_list_mount_point, caml_list_of_js_array, caml_list_to_js_array, caml_log10_float, caml_log1p_float, caml_log2_float, caml_log_float, caml_lt_float, caml_lxm_next, caml_make_array, caml_make_float_vect, caml_make_local_vect, caml_make_path, caml_make_vect, caml_marshal_constants, caml_marshal_data_size, caml_marshal_header_size, caml_maybe_attach_backtrace, caml_maybe_print_stats, caml_md5_bytes, caml_md5_chan, caml_md5_string, caml_memprof_discard, caml_memprof_set, caml_memprof_start, caml_memprof_stop, caml_ml_bytes_content, caml_ml_bytes_length, caml_ml_channel_size, caml_ml_channel_size_64, caml_ml_channels, caml_ml_close_channel, caml_ml_condition_broadcast, caml_ml_condition_new, caml_ml_condition_signal, caml_ml_condition_wait, caml_ml_debug_info_status, caml_ml_domain_cpu_relax, caml_ml_domain_id, caml_ml_domain_set_name, caml_ml_domain_unique_token, caml_ml_enable_runtime_warnings, caml_ml_flush, caml_ml_input, caml_ml_input_bigarray, caml_ml_input_block, caml_ml_input_char, caml_ml_input_int, caml_ml_input_scan_line, caml_ml_is_buffered, caml_ml_mutex_lock, caml_ml_mutex_new, caml_ml_mutex_try_lock, caml_ml_mutex_unlock, caml_ml_open_descriptor_in, caml_ml_open_descriptor_in_with_flags, caml_ml_open_descriptor_out, caml_ml_open_descriptor_out_with_flags, caml_ml_out_channels_list, caml_ml_output, caml_ml_output_bigarray, caml_ml_output_bytes, caml_ml_output_char, caml_ml_output_int, caml_ml_output_ta, caml_ml_pos_in, caml_ml_pos_in_64, caml_ml_pos_out, caml_ml_pos_out_64, caml_ml_runtime_warnings_enabled, caml_ml_seek_in, caml_ml_seek_in_64, caml_ml_seek_out, caml_ml_seek_out_64, caml_ml_set_binary_mode, caml_ml_set_buffered, caml_ml_set_channel_name, caml_ml_set_channel_output, caml_ml_set_channel_refill, caml_ml_string_length, caml_mod, caml_modf_float, caml_mount_autoload, caml_mul, caml_mul_float, caml_named_value, caml_named_values, caml_nativeint_add, caml_nativeint_and, caml_nativeint_bswap, caml_nativeint_compare, caml_nativeint_div, caml_nativeint_format, caml_nativeint_mod, caml_nativeint_mul, caml_nativeint_neg, caml_nativeint_of_float, caml_nativeint_of_int, caml_nativeint_of_int32, caml_nativeint_of_string, caml_nativeint_or, caml_nativeint_shift_left, caml_nativeint_shift_right, caml_nativeint_shift_right_unsigned, caml_nativeint_sub, caml_nativeint_to_float, caml_nativeint_to_int, caml_nativeint_to_int32, caml_nativeint_unmarshal, caml_nativeint_xor, caml_neg_float, caml_neq_float, caml_new_lex_engine, caml_new_string, caml_nextafter_float, caml_notequal, caml_obj_add_offset, caml_obj_block, caml_obj_compare_and_swap, caml_obj_dup, caml_obj_is_block, caml_obj_is_shared, caml_obj_make_forward, caml_obj_raw_field, caml_obj_reachable_words, caml_obj_set_raw_field, caml_obj_set_tag, caml_obj_tag, caml_obj_truncate, caml_obj_update_tag, caml_obj_with_tag, caml_ojs_new_arr, caml_oo_last_id, caml_output_val, caml_output_value, caml_output_value_to_buffer, caml_output_value_to_bytes, caml_output_value_to_string, caml_parse_digit, caml_parse_engine, caml_parse_format, caml_parse_sign_and_base, caml_parser_trace, caml_pos_in, caml_pos_out, caml_power_float, caml_pure_js_expr, caml_raise_constant, caml_raise_end_of_file, caml_raise_no_such_file, caml_raise_not_a_dir, caml_raise_not_found, caml_raise_sys_error, caml_raise_with_arg, caml_raise_with_args, caml_raise_with_string, caml_raise_zero_divide, caml_raw_backtrace_length, caml_raw_backtrace_next_slot, caml_raw_backtrace_slot, caml_read_file_content, caml_recommended_domain_count, caml_record_backtrace, caml_record_backtrace_flag, caml_refill, caml_register_channel_for_spacetime, caml_register_global, caml_register_named_value, caml_restore_raw_backtrace, caml_root, caml_round_float, caml_runtime_events_create_cursor, caml_runtime_events_free_cursor, caml_runtime_events_pause, caml_runtime_events_read_poll, caml_runtime_events_resume, caml_runtime_events_start, caml_runtime_events_user_register, caml_runtime_events_user_resolve, caml_runtime_events_user_write, caml_runtime_parameters, caml_runtime_variant, caml_runtime_warnings, caml_seek_in, caml_seek_out, caml_set_oo_id, caml_set_parser_trace, caml_set_static_env, caml_signbit_float, caml_sin_float, caml_sinh_float, caml_spacetime_enabled, caml_spacetime_only_works_for_native_code, caml_sqrt_float, caml_sse2_float64_max_bytecode, caml_sse2_float64_min_bytecode, caml_str_initialize, caml_str_repeat, caml_string_bound_error, caml_string_compare, caml_string_equal, caml_string_get, caml_string_get16, caml_string_get32, caml_string_get64, caml_string_greaterequal, caml_string_greaterthan, caml_string_hash, caml_string_lessequal, caml_string_lessthan, caml_string_notequal, caml_string_of_array, caml_string_of_bytes, caml_string_of_jsbytes, caml_string_of_jsstring, caml_string_set, caml_string_set16, caml_string_set32, caml_string_set64, caml_string_unsafe_get, caml_string_unsafe_set, caml_sub_float, caml_subarray_to_jsbytes, caml_sys_argv, caml_sys_chdir, caml_sys_close, caml_sys_const_backend_type, caml_sys_const_big_endian, caml_sys_const_int_size, caml_sys_const_max_wosize, caml_sys_const_naked_pointers_checked, caml_sys_const_ostype_cygwin, caml_sys_const_ostype_unix, caml_sys_const_ostype_win32, caml_sys_const_word_size, caml_sys_executable_name, caml_sys_exit, caml_sys_fds, caml_sys_file_exists, caml_sys_get_argv, caml_sys_get_config, caml_sys_getcwd, caml_sys_getenv, caml_sys_is_directory, caml_sys_is_regular_file, caml_sys_isatty, caml_sys_mkdir, caml_sys_modify_argv, caml_sys_open, caml_sys_open_for_node, caml_sys_random_seed, caml_sys_read_directory, caml_sys_remove, caml_sys_rename, caml_sys_rmdir, caml_sys_system_command, caml_sys_time, caml_sys_time_include_children, caml_sys_unsafe_getenv, caml_tan_float, caml_tanh_float, caml_to_js_string, caml_trailing_slash, caml_trampoline, caml_trampoline_return, caml_trunc_float, caml_uint8_array_of_bytes, caml_uint8_array_of_string, caml_unix_cleanup, caml_unix_closedir, caml_unix_filedescr_of_fd, caml_unix_findclose, caml_unix_findfirst, caml_unix_findnext, caml_unix_getpwuid, caml_unix_gettimeofday, caml_unix_getuid, caml_unix_gmtime, caml_unix_has_symlink, caml_unix_inet_addr_of_string, caml_unix_isatty, caml_unix_localtime, caml_unix_lstat, caml_unix_lstat_64, caml_unix_mkdir, caml_unix_mktime, caml_unix_opendir, caml_unix_readdir, caml_unix_readlink, caml_unix_rewinddir, caml_unix_rmdir, caml_unix_startup, caml_unix_stat, caml_unix_stat_64, caml_unix_symlink, caml_unix_time, caml_unix_unlink, caml_unmount, caml_update_dummy, caml_utf16_of_utf8, caml_utf8_of_utf16, caml_weak_blit, caml_weak_check, caml_weak_create, caml_weak_get, caml_weak_get_copy, caml_weak_set, caml_wrap_exception, caml_xmlhttprequest_create, caml_zstd_initialize, compare_digits_nat, compare_nat, compare_nat_real, complement_nat, core_array_unsafe_float_blit, core_array_unsafe_int_blit, core_gc_compactions, core_gc_heap_chunks, core_gc_heap_words, core_gc_major_collections, core_gc_major_plus_minor_words, core_gc_major_words, core_gc_minor_collections, core_gc_minor_words, core_gc_promoted_words, core_gc_run_memprof_callbacks, core_gc_top_heap_words, core_heap_block_is_heap_block, core_md5_digest_subbigstring, core_md5_fd, core_time_ns_format, create_nat, decr_nat, deserialize_nat, div_digit_nat, div_helper, div_nat, fs_node_supported, incr_nat, initialize_nat, internalhash_fold_bigstring, is_digit_int, is_digit_odd, is_digit_zero, jsoo_create_file, jsoo_create_file_extern, jsoo_effect_not_supported, jsoo_floor_log2, jsoo_is_ascii, jsoo_mount_point, jsoo_sys_getenv, land_digit_nat, length_nat, lor_digit_nat, lxor_digit_nat, make_unix_err_args, ms_float_to_ns_int64, mult_digit_nat, mult_nat, nat_of_array, nth_digit_nat, nth_digit_nat_native, num_digits_nat, num_leading_zero_bits_in_digit, os_type, path_is_absolute, ppx_expect_runtime_after_test, ppx_expect_runtime_before_test, ppx_expect_runtime_flush_stubs_streams, ppx_expect_runtime_out_channel_position, ppx_expect_runtime_saved_stderr, ppx_expect_runtime_saved_stdout, re_match, re_partial_match, re_replacement_text, re_search_backward, re_search_forward, re_string_match, resolve_fs_device, serialize_nat, set_digit_nat, set_digit_nat_native, set_to_zero_nat, shift_left_nat, shift_right_nat, should_use_timezone_js_loader, square_nat, sub_nat, time_now_nanosecond_counter_for_timing, time_now_nanoseconds_since_unix_epoch_or_zero, timezone_js_loader_compare_instants, timezone_js_loader_create_zone, timezone_js_loader_disable_for_testing, timezone_js_loader_enable_for_testing, timezone_js_loader_epoch_seconds, timezone_js_loader_from_epoch_seconds, timezone_js_loader_get_next_transition_or_this_time_if_none, timezone_js_loader_get_offset_nanos_for, timezone_js_loader_instant_plus_hours, timezone_js_loader_now, unix_closedir, unix_getpwuid, unix_gettimeofday, unix_getuid, unix_gmtime, unix_has_symlink, unix_inet_addr_of_string, unix_isatty, unix_localtime, unix_lstat, unix_lstat_64, unix_mkdir, unix_mktime, unix_opendir, unix_readdir, unix_readlink, unix_rewinddir, unix_rmdir, unix_stat, unix_stat_64, unix_symlink, unix_time, unix_unlink, win_cleanup, win_filedescr_of_channel, win_findclose, win_findfirst, win_findnext, win_handle_fd, win_startup, zstd_decompress
//# unitInfo: Force_link: true
(function
  (Object){
   typeof globalThis !== "object"
   &&
    (this
      ? get()
      : (Object.defineProperty
         (Object.prototype, "_T_", {configurable: true, get: get}),
        _T_));
   function get(){
    var global = this || self;
    global.globalThis = global;
    delete Object.prototype._T_;
   }
  }
  (Object));
(function(globalThis){
   var joo_global_object = globalThis;
   (function(){
      var
       DefaultLocale =
         {days:
          ["Sunday",
           "Monday",
           "Tuesday",
           "Wednesday",
           "Thursday",
           "Friday",
           "Saturday"],
          shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          months:
          ["January",
           "February",
           "March",
           "April",
           "May",
           "June",
           "July",
           "August",
           "September",
           "October",
           "November",
           "December"],
          shortMonths:
          ["Jan",
           "Feb",
           "Mar",
           "Apr",
           "May",
           "Jun",
           "Jul",
           "Aug",
           "Sep",
           "Oct",
           "Nov",
           "Dec"],
          AM: "AM",
          PM: "PM",
          am: "am",
          pm: "pm",
          formats:
          {D: "%m/%d/%y",
           F: "%Y-%m-%d",
           R: "%H:%M",
           T: "%H:%M:%S",
           X: "%T",
           c: "%a %b %d %X %Y",
           r: "%I:%M:%S %p",
           v: "%e-%b-%Y",
           x: "%D"}},
       defaultStrftime = new Strftime(DefaultLocale, 0, false),
       isCommonJS = typeof module !== "undefined",
       namespace;
      if(isCommonJS){
       namespace = module.exports = adaptedStrftime;
       namespace.strftime = deprecatedStrftime;
       if(joo_global_object) joo_global_object.strftime = adaptedStrftime;
      }
      else{
       namespace =
        joo_global_object || function(){return this || (1, eval)("this");}();
       namespace.strftime = adaptedStrftime;
      }
      var
       _require = isCommonJS ? "require('strftime')" : "strftime",
       _deprecationWarnings = {};
      function deprecationWarning(name, instead){
       if(! _deprecationWarnings[name]){
        if
         (typeof console !== "undefined" && typeof console.warn == "function")
         console.warn
          ("[WARNING] " + name
           +
            " is deprecated and will be removed in version 1.0. Instead, use `"
           + instead
           + "`.");
        _deprecationWarnings[name] = true;
       }
      }
      namespace.strftimeTZ = deprecatedStrftimeTZ;
      namespace.strftimeUTC = deprecatedStrftimeUTC;
      namespace.localizedStrftime = deprecatedStrftimeLocalized;
      function adaptForwards(fn){
       fn.localize = defaultStrftime.localize.bind(defaultStrftime);
       fn.timezone = defaultStrftime.timezone.bind(defaultStrftime);
       fn.utc = defaultStrftime.utc.bind(defaultStrftime);
      }
      adaptForwards(adaptedStrftime);
      function adaptedStrftime(fmt, d, locale){
       if(d && d.days){locale = d; d = undefined;}
       if(locale)
        deprecationWarning
         ("`" + _require + "(format, [date], [locale])`",
          "var s = " + _require + ".localize(locale); s(format, [date])");
       var
        strftime = locale ? defaultStrftime.localize(locale) : defaultStrftime;
       return strftime(fmt, d);
      }
      adaptForwards(deprecatedStrftime);
      function deprecatedStrftime(fmt, d, locale){
       if(locale)
        deprecationWarning
         ("`" + _require + ".strftime(format, [date], [locale])`",
          "var s = " + _require + ".localize(locale); s(format, [date])");
       else
        deprecationWarning
         ("`" + _require + ".strftime(format, [date])`",
          _require + "(format, [date])");
       var
        strftime = locale ? defaultStrftime.localize(locale) : defaultStrftime;
       return strftime(fmt, d);
      }
      function deprecatedStrftimeTZ(fmt, d, locale, timezone){
       if
        ((typeof locale == "number" || typeof locale == "string")
         && timezone == null){
        timezone = locale;
        locale = undefined;
       }
       if(locale)
        deprecationWarning
         ("`" + _require + ".strftimeTZ(format, date, locale, tz)`",
          "var s = " + _require
          + ".localize(locale).timezone(tz); s(format, [date])` or `var s = "
          + _require
          + ".localize(locale); s.timezone(tz)(format, [date])");
       else
        deprecationWarning
         ("`" + _require + ".strftimeTZ(format, date, tz)`",
          "var s = " + _require + ".timezone(tz); s(format, [date])` or `"
          + _require
          + ".timezone(tz)(format, [date])");
       var
        strftime =
          (locale ? defaultStrftime.localize(locale) : defaultStrftime).timezone
           (timezone);
       return strftime(fmt, d);
      }
      var utcStrftime = defaultStrftime.utc();
      function deprecatedStrftimeUTC(fmt, d, locale){
       if(locale)
        deprecationWarning
         ("`" + _require + ".strftimeUTC(format, date, locale)`",
          "var s = " + _require + ".localize(locale).utc(); s(format, [date])");
       else
        deprecationWarning
         ("`" + _require + ".strftimeUTC(format, [date])`",
          "var s = " + _require + ".utc(); s(format, [date])");
       var strftime = locale ? utcStrftime.localize(locale) : utcStrftime;
       return strftime(fmt, d);
      }
      function deprecatedStrftimeLocalized(locale){
       deprecationWarning
        ("`" + _require + ".localizedStrftime(locale)`",
         _require + ".localize(locale)");
       return defaultStrftime.localize(locale);
      }
      if(typeof Date.now !== "function")
       Date.now = function(){return + new Date();};
      function Strftime(locale, customTimezoneOffset, useUtcTimezone){
       var
        _locale = locale || DefaultLocale,
        _customTimezoneOffset = customTimezoneOffset || 0,
        _useUtcBasedDate = useUtcTimezone || false,
        _cachedDateTimestamp = 0,
        _cachedDate;
       function _strftime(format, date){
        var timestamp;
        if(! date){
         var currentTimestamp = Date.now();
         if(currentTimestamp > _cachedDateTimestamp){
          _cachedDateTimestamp = currentTimestamp;
          _cachedDate = new Date(_cachedDateTimestamp);
          timestamp = _cachedDateTimestamp;
          if(_useUtcBasedDate)
           _cachedDate =
            new
             Date
             (_cachedDateTimestamp + getTimestampToUtcOffsetFor(_cachedDate)
              + _customTimezoneOffset);
         }
         date = _cachedDate;
        }
        else{
         timestamp = date.getTime();
         if(_useUtcBasedDate)
          date =
           new
            Date
            (date.getTime() + getTimestampToUtcOffsetFor(date)
             + _customTimezoneOffset);
        }
        return _processFormat(format, date, _locale, timestamp);
       }
       function _processFormat(format, date, locale, timestamp){
        var
         resultString = "",
         padding = null,
         isInScope = false,
         length = format.length,
         extendedTZ = false;
        for(var i = 0; i < length; i++){
         var currentCharCode = format.charCodeAt(i);
         if(isInScope === true){
          if(currentCharCode === 45){padding = ""; continue;}
          else if(currentCharCode === 95){padding = " "; continue;}
          else if(currentCharCode === 48){padding = "0"; continue;}
          else if(currentCharCode === 58){
           if(extendedTZ)
            if
             (typeof console !== "undefined"
              && typeof console.warn == "function")
             console.warn
              ("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime");
           extendedTZ = true;
           continue;
          }
          switch(currentCharCode){
            case 65:
             resultString += locale.days[date.getDay()]; break;
            case 66:
             resultString += locale.months[date.getMonth()]; break;
            case 67:
             resultString +=
              padTill2(Math.floor(date.getFullYear() / 100), padding);
             break;
            case 68:
             resultString +=
              _processFormat(locale.formats.D, date, locale, timestamp);
             break;
            case 70:
             resultString +=
              _processFormat(locale.formats.F, date, locale, timestamp);
             break;
            case 72:
             resultString += padTill2(date.getHours(), padding); break;
            case 73:
             resultString += padTill2(hours12(date.getHours()), padding);
             break;
            case 76:
             resultString += padTill3(Math.floor(timestamp % 1000)); break;
            case 77:
             resultString += padTill2(date.getMinutes(), padding); break;
            case 80:
             resultString += date.getHours() < 12 ? locale.am : locale.pm;
             break;
            case 82:
             resultString +=
              _processFormat(locale.formats.R, date, locale, timestamp);
             break;
            case 83:
             resultString += padTill2(date.getSeconds(), padding); break;
            case 84:
             resultString +=
              _processFormat(locale.formats.T, date, locale, timestamp);
             break;
            case 85:
             resultString += padTill2(weekNumber(date, "sunday"), padding);
             break;
            case 87:
             resultString += padTill2(weekNumber(date, "monday"), padding);
             break;
            case 88:
             resultString +=
              _processFormat(locale.formats.X, date, locale, timestamp);
             break;
            case 89:
             resultString += date.getFullYear(); break;
            case 90:
             if(_useUtcBasedDate && _customTimezoneOffset === 0)
              resultString += "GMT";
             else{
              var tzString = date.toString().match(/\(([\w\s]+)\)/);
              resultString += tzString && tzString[1] || "";
             }
             break;
            case 97:
             resultString += locale.shortDays[date.getDay()]; break;
            case 98:
             resultString += locale.shortMonths[date.getMonth()]; break;
            case 99:
             resultString +=
              _processFormat(locale.formats.c, date, locale, timestamp);
             break;
            case 100:
             resultString += padTill2(date.getDate(), padding); break;
            case 101:
             resultString +=
              padTill2(date.getDate(), padding == null ? " " : padding);
             break;
            case 104:
             resultString += locale.shortMonths[date.getMonth()]; break;
            case 106:
             var
              y = new Date(date.getFullYear(), 0, 1),
              day =
                Math.ceil
                 ((date.getTime() - y.getTime()) / (1000 * 60 * 60 * 24));
             resultString += padTill3(day);
             break;
            case 107:
             resultString +=
              padTill2(date.getHours(), padding == null ? " " : padding);
             break;
            case 108:
             resultString +=
              padTill2
               (hours12(date.getHours()), padding == null ? " " : padding);
             break;
            case 109:
             resultString += padTill2(date.getMonth() + 1, padding); break;
            case 110:
             resultString += "\n"; break;
            case 111:
             resultString += String(date.getDate()) + ordinal(date.getDate());
             break;
            case 112:
             resultString += date.getHours() < 12 ? locale.AM : locale.PM;
             break;
            case 114:
             resultString +=
              _processFormat(locale.formats.r, date, locale, timestamp);
             break;
            case 115:
             resultString += Math.floor(timestamp / 1000); break;
            case 116:
             resultString += "\t"; break;
            case 117:
             var day = date.getDay();
             resultString += day === 0 ? 7 : day;
             break;
            case 118:
             resultString +=
              _processFormat(locale.formats.v, date, locale, timestamp);
             break;
            case 119:
             resultString += date.getDay(); break;
            case 120:
             resultString +=
              _processFormat(locale.formats.x, date, locale, timestamp);
             break;
            case 121:
             resultString += ("" + date.getFullYear()).slice(2); break;
            case 122:
             if(_useUtcBasedDate && _customTimezoneOffset === 0)
              resultString += extendedTZ ? "+00:00" : "+0000";
             else{
              var off;
              if(_customTimezoneOffset !== 0)
               off = _customTimezoneOffset / (60 * 1000);
              else
               off = - date.getTimezoneOffset();
              var
               sign = off < 0 ? "-" : "+",
               sep = extendedTZ ? ":" : "",
               hours = Math.floor(Math.abs(off / 60)),
               mins = Math.abs(off % 60);
              resultString += sign + padTill2(hours) + sep + padTill2(mins);
             }
             break;
            default: resultString += format[i]; break;
          }
          padding = null;
          isInScope = false;
          continue;
         }
         if(currentCharCode === 37){isInScope = true; continue;}
         resultString += format[i];
        }
        return resultString;
       }
       var strftime = _strftime;
       strftime.localize =
        function(locale){
         return new
                 Strftime
                 (locale || _locale, _customTimezoneOffset, _useUtcBasedDate);
        };
       strftime.timezone =
        function(timezone){
         var
          customTimezoneOffset = _customTimezoneOffset,
          useUtcBasedDate = _useUtcBasedDate,
          timezoneType = typeof timezone;
         if(timezoneType === "number" || timezoneType === "string"){
          useUtcBasedDate = true;
          if(timezoneType === "string"){
           var
            sign = timezone[0] === "-" ? - 1 : 1,
            hours = parseInt(timezone.slice(1, 3), 10),
            minutes = parseInt(timezone.slice(3, 5), 10);
           customTimezoneOffset = sign * (60 * hours + minutes) * 60 * 1000;
          }
          else if(timezoneType === "number")
           customTimezoneOffset = timezone * 60 * 1000;
         }
         return new Strftime(_locale, customTimezoneOffset, useUtcBasedDate);
        };
       strftime.utc =
        function(){return new Strftime(_locale, _customTimezoneOffset, true);};
       return strftime;
      }
      function padTill2(numberToPad, paddingChar){
       if(paddingChar === "" || numberToPad > 9) return numberToPad;
       if(paddingChar == null) paddingChar = "0";
       return paddingChar + numberToPad;
      }
      function padTill3(numberToPad){
       if(numberToPad > 99) return numberToPad;
       if(numberToPad > 9) return "0" + numberToPad;
       return "00" + numberToPad;
      }
      function hours12(hour){
       if(hour === 0) return 12; else if(hour > 12) return hour - 12;
       return hour;
      }
      function weekNumber(date, firstWeekday){
       firstWeekday = firstWeekday || "sunday";
       var weekday = date.getDay();
       if(firstWeekday === "monday")
        if(weekday === 0) weekday = 6; else weekday--;
       var
        firstDayOfYearUtc = Date.UTC(date.getFullYear(), 0, 1),
        dateUtc =
          Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),
        yday = Math.floor((dateUtc - firstDayOfYearUtc) / 86400000),
        weekNum = (yday + 7 - weekday) / 7;
       return Math.floor(weekNum);
      }
      function ordinal(number){
       var i = number % 10, ii = number % 100;
       if(ii >= 11 && ii <= 13 || i === 0 || i >= 4) return "th";
       switch(i){case 1: return "st";case 2: return "nd";case 3: return "rd";
       }
      }
      function getTimestampToUtcOffsetFor(date){
       return (date.getTimezoneOffset() || 0) * 60000;
      }
     }
     ());
  }
  (globalThis));
(function(globalThis){
   function _iterableToArrayLimit(r, l){
    var
     t =
       null == r
        ? null
        : "undefined"
         != typeof Symbol
         && r[Symbol.iterator]
         || r["@@iterator"];
    if(null != t){
     var e, n, i, u, a = [], f = ! 0, o = ! 1;
     try{
      if(i = (t = t.call(r)).next, 0 === l){if(Object(t) !== t) return; f = ! 1;
      }
      else
       for
       (;
        ! (f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l);
        f = ! 0)
        ;
     }
     catch(r){o = ! 0, n = r;}
     finally{
      try{
       if(! f && null != t.return && (u = t.return(), Object(u) !== u))
        return;
      }
      finally{if(o) throw n;}
     }
     return a;
    }
   }
   function ownKeys(e, r){
    var t = Object.keys(e);
    if(Object.getOwnPropertySymbols){
     var o = Object.getOwnPropertySymbols(e);
     r
     &&
      (o =
       o.filter
        (function(r){return Object.getOwnPropertyDescriptor(e, r).enumerable;})),
     t.push.apply(t, o);
    }
    return t;
   }
   function _objectSpread2(e){
    for(var r = 1; r < arguments.length; r++){
     var t = null != arguments[r] ? arguments[r] : {};
     r % 2
      ? ownKeys
         (Object(t), ! 0).forEach
        (function(r){_defineProperty(e, r, t[r]);})
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
        : ownKeys
           (Object(t)).forEach
          (function(r){
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
           });
    }
    return e;
   }
   function _toPrimitive(t, r){
    if("object" != typeof t || ! t) return t;
    var e = t[Symbol.toPrimitive];
    if(void 0 !== e){
     var i = e.call(t, r || "default");
     if("object" != typeof i) return i;
     throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
   }
   function _toPropertyKey(t){
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : String(i);
   }
   function _typeof(o){
    "@babel/helpers - typeof";
    return _typeof =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
             ? function(o){return typeof o;}
             : function
              (o){
               return o && "function" == typeof Symbol
                       && o.constructor === Symbol
                       && o !== Symbol.prototype
                       ? "symbol"
                       : typeof o;
              },
           _typeof(o);
   }
   function _classCallCheck(instance, Constructor){
    if(! (instance instanceof Constructor))
     throw new TypeError("Cannot call a class as a function");
   }
   function _defineProperties(target, props){
    for(var i = 0; i < props.length; i++){
     var descriptor = props[i];
     descriptor.enumerable = descriptor.enumerable || false;
     descriptor.configurable = true;
     if("value" in descriptor) descriptor.writable = true;
     Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
   }
   function _createClass(Constructor, protoProps, staticProps){
    if(protoProps) _defineProperties(Constructor.prototype, protoProps);
    if(staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {writable: false});
    return Constructor;
   }
   function _defineProperty(obj, key, value){
    key = _toPropertyKey(key);
    if(key in obj)
     Object.defineProperty
      (obj,
       key,
       {value: value, enumerable: true, configurable: true, writable: true});
    else
     obj[key] = value;
    return obj;
   }
   function _inherits(subClass, superClass){
    if(typeof superClass !== "function" && superClass !== null)
     throw new TypeError("Super expression must either be null or a function");
    subClass.prototype =
     Object.create
      (superClass && superClass.prototype,
       {constructor: {value: subClass, writable: true, configurable: true}});
    Object.defineProperty(subClass, "prototype", {writable: false});
    if(superClass) _setPrototypeOf(subClass, superClass);
   }
   function _getPrototypeOf(o){
    _getPrototypeOf =
     Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function(o){return o.__proto__ || Object.getPrototypeOf(o);};
    return _getPrototypeOf(o);
   }
   function _setPrototypeOf(o, p){
    _setPrototypeOf =
     Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function(o, p){o.__proto__ = p; return o;};
    return _setPrototypeOf(o, p);
   }
   function _isNativeReflectConstruct(){
    if(typeof Reflect === "undefined" || ! Reflect.construct) return false;
    if(Reflect.construct.sham) return false;
    if(typeof Proxy === "function") return true;
    try{
     Boolean.prototype.valueOf.call
      (Reflect.construct(Boolean, [], function(){}));
     return true;
    }
    catch(e){return false;}
   }
   function _assertThisInitialized(self){
    if(self === void 0)
     throw new
            ReferenceError
            ("this hasn't been initialised - super() hasn't been called");
    return self;
   }
   function _possibleConstructorReturn(self, call){
    if(call && (typeof call === "object" || typeof call === "function"))
     return call;
    else if(call !== void 0)
     throw new
            TypeError
            ("Derived constructors may only return object or undefined");
    return _assertThisInitialized(self);
   }
   function _createSuper(Derived){
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function(){
     var Super = _getPrototypeOf(Derived), result;
     if(hasNativeReflectConstruct){
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
     }
     else
      result = Super.apply(this, arguments);
     return _possibleConstructorReturn(this, result);};
   }
   function _superPropBase(object, property){
    while(! Object.prototype.hasOwnProperty.call(object, property)){object = _getPrototypeOf(object); if(object === null) break;}
    return object;
   }
   function _get(){
    if(typeof Reflect !== "undefined" && Reflect.get)
     _get = Reflect.get.bind();
    else
     _get =
      function(target, property, receiver){
       var base = _superPropBase(target, property);
       if(! base) return;
       var desc = Object.getOwnPropertyDescriptor(base, property);
       if(desc.get)
        return desc.get.call(arguments.length < 3 ? target : receiver);
       return desc.value;
      };
    return _get.apply(this, arguments);
   }
   function _slicedToArray(arr, i){
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i)
           || _unsupportedIterableToArray(arr, i)
           || _nonIterableRest();
   }
   function _toConsumableArray(arr){
    return _arrayWithoutHoles(arr) || _iterableToArray(arr)
           || _unsupportedIterableToArray(arr)
           || _nonIterableSpread();
   }
   function _arrayWithoutHoles(arr){
    if(Array.isArray(arr)) return _arrayLikeToArray(arr);
   }
   function _arrayWithHoles(arr){if(Array.isArray(arr)) return arr;}
   function _iterableToArray(iter){
    if
     (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null
      || iter["@@iterator"] != null)
     return Array.from(iter);
   }
   function _unsupportedIterableToArray(o, minLen){
    if(! o) return;
    if(typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, - 1);
    if(n === "Object" && o.constructor) n = o.constructor.name;
    if(n === "Map" || n === "Set") return Array.from(o);
    if
     (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
     return _arrayLikeToArray(o, minLen);
   }
   function _arrayLikeToArray(arr, len){
    if(len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
   }
   function _nonIterableSpread(){
    throw new
           TypeError
           ("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
   }
   function _nonIterableRest(){
    throw new
           TypeError
           ("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
   }
   function _createForOfIteratorHelper(o, allowArrayLike){
    var
     it =
       typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if(! it){
     if
      (Array.isArray(o) || (it = _unsupportedIterableToArray(o))
       || allowArrayLike && o && typeof o.length === "number"){
      if(it) o = it;
      var i = 0, F = function(){};
      return {s: F,
              n:
              function(){
               if(i >= o.length) return {done: true};
               return {done: false, value: o[i++]};
              },
              e: function(e){throw e;},
              f: F};
     }
     throw new
            TypeError
            ("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {s: function(){it = it.call(o);},
            n:
            function(){
             var step = it.next();
             normalCompletion = step.done;
             return step;
            },
            e: function(e){didErr = true; err = e;},
            f:
            function(){
             try{if(! normalCompletion && it.return != null) it.return();}
             finally{if(didErr) throw err;}
            }};
   }
   var t = {};
   function MakeIntrinsicClass(e, t){
    Object.defineProperty
     (e.prototype,
      Symbol.toStringTag,
      {value: t, writable: ! 1, enumerable: ! 1, configurable: ! 0});
    var
     _iterator = _createForOfIteratorHelper(Object.getOwnPropertyNames(e)),
     _step;
    try{
     for(_iterator.s(); ! (_step = _iterator.n()).done;){
      var _t = _step.value, _r = Object.getOwnPropertyDescriptor(e, _t);
      _r.configurable && _r.enumerable
      && (_r.enumerable = ! 1, Object.defineProperty(e, _t, _r));
     }
    }
    catch(err){_iterator.e(err);}
    finally{_iterator.f();}
    var
     _iterator2 =
       _createForOfIteratorHelper(Object.getOwnPropertyNames(e.prototype)),
     _step2;
    try{
     for(_iterator2.s(); ! (_step2 = _iterator2.n()).done;){
      var
       _t2 = _step2.value,
       _r2 = Object.getOwnPropertyDescriptor(e.prototype, _t2);
      _r2.configurable && _r2.enumerable
      && (_r2.enumerable = ! 1, Object.defineProperty(e.prototype, _t2, _r2));
     }
    }
    catch(err){_iterator2.e(err);}
    finally{_iterator2.f();}
    DefineIntrinsic(t, e),
    DefineIntrinsic("".concat(t, ".prototype"), e.prototype);
   }
   function DefineIntrinsic(e, r){
    var o = "%".concat(e, "%");
    if(void 0 !== t[o])
     throw new Error("intrinsic ".concat(e, " already exists"));
    t[o] = r;
   }
   function GetIntrinsic(e){return t[e];}
   var
    r,
    o,
    n = "slot-epochNanoSeconds",
    a = "slot-timezone-identifier",
    i = "slot-year",
    s = "slot-month",
    l = "slot-day",
    d = "slot-hour",
    m = "slot-minute",
    c = "slot-second",
    h = "slot-millisecond",
    u = "slot-microsecond",
    T = "slot-nanosecond",
    p = "slot-calendar",
    f = "slot-date-brand",
    y = "slot-year-month-brand",
    I = "slot-month-day-brand",
    S = "slot-cached-instant",
    g = "slot-time-zone",
    w = "slot-years",
    D = "slot-months",
    G = "slot-weeks",
    v = "slot-days",
    C = "slot-hours",
    O = "slot-minutes",
    b = "slot-seconds",
    E = "slot-milliseconds",
    M = "slot-microseconds",
    R = "slot-nanoseconds",
    F = "slot-calendar-identifier",
    Y = new WeakMap(),
    P = Symbol["for"]("@@Temporal__GetSlots");
   (r = globalThis)[P] || (r[P] = function(e){return Y.get(e);});
   var Z = globalThis[P], B = Symbol["for"]("@@Temporal__CreateSlots");
   (o = globalThis)[B] || (o[B] = function(e){Y.set(e, Object.create(null));});
   var N = globalThis[B];
   function HasSlot(e){
    if(! e || "object" != _typeof(e)) return ! 1;
    var r = Z(e);
    for
    (var
      _len = arguments.length,
      t = new Array(_len > 1 ? _len - 1 : 0),
      _key = 1;
     _key < _len;
     _key++)
     t[_key - 1] = arguments[_key];
    return ! ! r && t.every(function(e){return e in r;});
   }
   function GetSlot(e, t){
    var _Z, r = (_Z = Z(e)) === null || _Z === void 0 ? void 0 : _Z[t];
    if(void 0 === r) throw new TypeError("Missing internal slot ".concat(t));
    return r;
   }
   function SetSlot(e, t, r){
    var o = Z(e);
    if(void 0 === o)
     throw new TypeError("Missing slots for the given container");
    if(o[t]) throw new TypeError("".concat(t, " already has set"));
    o[t] = r;
   }
   var
    j =
      /\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/,
    $ =
      new
       RegExp
       ("(?:"
        +
         ["(?:".concat(j.source, ")(?:\\/(?:").concat(j.source, "))*"),
           "Etc/GMT(?:0|[-+]\\d{1,2})",
           "GMT[-+]?0",
           "EST5EDT",
           "CST6CDT",
           "MST7MDT",
           "PST8PDT",
           /(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source].join
          ("|")
        + ")"),
    k = /(?:[+\u2212-]\d{6}|\d{4})/,
    U = /(?:0[1-9]|1[0-2])/,
    A = /(?:0[1-9]|[12]\d|3[01])/,
    L =
      new
       RegExp
       ("(".concat(k.source, ")(?:-(").concat(U.source, ")-(").concat
           (A.source, ")|(").concat
          (U.source, ")(").concat
         (A.source, "))")),
    x =
      /(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/,
    W =
      /([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/,
    q = new RegExp("([zZ])|".concat(W.source, "?")),
    H = /\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\]/g,
    V =
      new
       RegExp
       (["^".concat(L.source),
          "(?:(?:T|\\s+)".concat(x.source, "(?:").concat(q.source, ")?)?"),
          "(?:\\[!?(".concat($.source, ")\\])?"),
          "((?:".concat(H.source, ")*)$")].join
         (""),
        "i"),
    z =
      new
       RegExp
       (["^T?".concat(x.source),
          "(?:".concat(q.source, ")?"),
          "(?:\\[!?".concat($.source, "\\])?"),
          "((?:".concat(H.source, ")*)$")].join
         (""),
        "i"),
    _ =
      new
       RegExp
       ("^(".concat(k.source, ")-?(").concat(U.source, ")(?:\\[!?").concat
          ($.source, "\\])?((?:").concat
         (H.source, ")*)$")),
    J =
      new
       RegExp
       ("^(?:--)?(".concat(U.source, ")-?(").concat(A.source, ")(?:\\[!?").concat
          ($.source, "\\])?((?:").concat
         (H.source, ")*)$")),
    K = /(\d+)(?:[.,](\d{1,9}))?/,
    X =
      new
       RegExp
       ("(?:".concat(K.source, "H)?(?:").concat(K.source, "M)?(?:").concat
         (K.source, "S)?")),
    Q =
      new
       RegExp
       ("^([+\u2212-])?P".concat
          (/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source, "(?:T(?!$)").concat
         (X.source, ")?$"),
        "i"),
    ee = Array.prototype.includes,
    te = Array.prototype.push,
    re = globalThis.Intl.DateTimeFormat,
    oe = Math.min,
    ne = Math.max,
    ae = Math.abs,
    ie = Math.floor,
    se = Math.sign,
    le = Math.trunc,
    de = Number.isNaN,
    me = Number.isFinite,
    ce = Number,
    he = String,
    ue = Number.MAX_SAFE_INTEGER,
    Te = Object.create,
    pe = Object.getOwnPropertyDescriptor,
    fe = Reflect.apply,
    ye = Reflect.ownKeys,
    Ie = 0n,
    Se = 1n,
    ge = 60n,
    we = 24n,
    De = 1000n,
    Ge = 1000000n,
    ve = 1000000000n,
    Ce = BigInt(- 1),
    Oe = 3600n * ve,
    be = ge * ve,
    Ee = Oe * we,
    Me = BigInt(- 86400) * 100000000000000000n,
    Re = 86400n * 100000000000000000n,
    Fe = - 271821,
    Ye = 275760,
    Pe = BigInt(- 388152) * 10000000000000n,
    Ze = Ee * 3660n,
    Be = Ee * 366n,
    Ne = Ee * 14n,
    je =
      ["iso8601",
       "hebrew",
       "islamic",
       "islamic-umalqura",
       "islamic-tbla",
       "islamic-civil",
       "islamic-rgsa",
       "islamicc",
       "persian",
       "ethiopic",
       "ethioaa",
       "coptic",
       "chinese",
       "dangi",
       "roc",
       "indian",
       "buddhist",
       "japanese",
       "gregory"];
   function isZero(t){return t === Ie;}
   function GetMethod(e, t){var r = e[t]; if(void 0 !== r) return r;}
   function Call(e, t, r){
    var o = arguments.length > 2 ? r : [];
    return fe(e, t, o);
   }
   function IsObject(e){
    return "object" == _typeof(e) && null !== e || "function" == typeof e;
   }
   function ToNumber(e){
    if("bigint" == typeof e)
     throw new TypeError("Cannot convert BigInt to number");
    return ce(e);
   }
   function ToIntegerOrInfinity(e){
    var t = ToNumber(e);
    if(de(t) || 0 === t) return 0;
    if(! me(t)) return t;
    var r = ie(ae(t));
    return 0 === r ? 0 : se(t) * r;
   }
   function IsIntegralNumber(e){
    if("number" != typeof e || de(e) || ! me(e)) return ! 1;
    var t = ae(e);
    return ie(t) === t;
   }
   function ToString(e){
    if("symbol" == _typeof(e))
     throw new TypeError("Cannot convert a Symbol value to a String");
    return he(e);
   }
   function ToIntegerWithTruncation(e){
    var t = ToNumber(e);
    if(0 === t) return 0;
    if(de(t) || ! me(t)) throw new RangeError("invalid number value");
    var r = le(t);
    return 0 === r ? 0 : r;
   }
   function ToPositiveIntegerWithTruncation(e, t){
    var r = ToIntegerWithTruncation(e);
    if(r <= 0){
     if(void 0 !== t)
      throw new
             RangeError
             ("property '".concat(t, "' cannot be a a number less than one"));
     throw new
            RangeError
            ("Cannot convert a number less than one to a positive integer");
    }
    return r;
   }
   function ToIntegerIfIntegral(e){
    var t = ToNumber(e);
    if(! me(t)) throw new RangeError("infinity is out of range");
    if(! IsIntegralNumber(t))
     throw new RangeError("unsupported fractional value ".concat(e));
    return 0 === t ? 0 : t;
   }
   function divmod(t, r){return {quotient: t / r, remainder: t % r};}
   function isNegativeJSBI(t){return t < Ie;}
   function signJSBI(e){return isZero(e) ? 0 : isNegativeJSBI(e) ? - 1 : 1;}
   function abs(t){return t < Ie ? t * Ce : t;}
   var
    $e =
      new
       Map
       ([["year", ToIntegerWithTruncation],
         ["month", ToPositiveIntegerWithTruncation],
         ["monthCode", ToString],
         ["day", ToPositiveIntegerWithTruncation],
         ["hour", ToIntegerWithTruncation],
         ["minute", ToIntegerWithTruncation],
         ["second", ToIntegerWithTruncation],
         ["millisecond", ToIntegerWithTruncation],
         ["microsecond", ToIntegerWithTruncation],
         ["nanosecond", ToIntegerWithTruncation],
         ["years", ToIntegerIfIntegral],
         ["months", ToIntegerIfIntegral],
         ["weeks", ToIntegerIfIntegral],
         ["days", ToIntegerIfIntegral],
         ["hours", ToIntegerIfIntegral],
         ["minutes", ToIntegerIfIntegral],
         ["seconds", ToIntegerIfIntegral],
         ["milliseconds", ToIntegerIfIntegral],
         ["microseconds", ToIntegerIfIntegral],
         ["nanoseconds", ToIntegerIfIntegral],
         ["era", ToString],
         ["eraYear", ToIntegerOrInfinity],
         ["offset", ToString]]),
    ke =
      new
       Map
       ([["hour", 0],
         ["minute", 0],
         ["second", 0],
         ["millisecond", 0],
         ["microsecond", 0],
         ["nanosecond", 0]]),
    Ue =
      [["years", "year", "date"],
       ["months", "month", "date"],
       ["weeks", "week", "date"],
       ["days", "day", "date"],
       ["hours", "hour", "time"],
       ["minutes", "minute", "time"],
       ["seconds", "second", "time"],
       ["milliseconds", "millisecond", "time"],
       ["microseconds", "microsecond", "time"],
       ["nanoseconds", "nanosecond", "time"]],
    Ae = new Map(Ue.map(function(e){return [e[0], e[1]];})),
    Le =
      new
       Map
       (Ue.map
         (function(_ref){
           var _ref2 = _slicedToArray(_ref, 2), e = _ref2[0], t = _ref2[1];
           return [t, e];
          })),
    xe =
      Ue.map
       (function(_ref3){
         var _ref4 = _slicedToArray(_ref3, 2), e = _ref4[1];
         return e;
        }),
    We = Array.from(Ae.keys()).sort(),
    qe = new Map();
   function getIntlDateTimeFormatEnUsForTimeZone(e){
    var t = qe.get(e);
    return void 0 === t
           &&
            (t =
              new
               re
               ("en-us",
                {timeZone: he(e),
                 hour12: ! 1,
                 era: "short",
                 year: "numeric",
                 month: "numeric",
                 day: "numeric",
                 hour: "numeric",
                 minute: "numeric",
                 second: "numeric"}),
             qe.set(e, t)),
           t;
   }
   function ToObject(e){
    if(null == e) throw new TypeError("Expected object not ".concat(e));
    return Object(e);
   }
   function CopyDataProperties(e, t, r, o){
    if(null == t) return;
    var n = ye(t), _iterator3 = _createForOfIteratorHelper(n), _step3;
    try{
     var
      _loop =
        function(){
         var a = _step3.value;
         if
          (!
           r.some(function(e){return Object.is(e, a);})
           && Object.prototype.propertyIsEnumerable.call(t, a)){
          var _r3 = t[a];
          if(o && o.some(function(e){return Object.is(e, _r3);})) return 1;
          e[a] = _r3;
         }
        };
     for(_iterator3.s(); ! (_step3 = _iterator3.n()).done;)
      if(_loop()) continue;
    }
    catch(err){_iterator3.e(err);}
    finally{_iterator3.f();}
   }
   function IsTemporalInstant(e){return HasSlot(e, n) && ! HasSlot(e, g, p);}
   function IsTemporalTimeZone(e){return HasSlot(e, a);}
   function IsTemporalCalendar(e){return HasSlot(e, F);}
   function IsTemporalDuration(e){
    return HasSlot(e, w, D, v, C, O, b, E, M, R);
   }
   function IsTemporalDate(e){return HasSlot(e, f);}
   function IsTemporalTime(e){
    return HasSlot(e, d, m, c, h, u, T) && ! HasSlot(e, i, s, l);
   }
   function IsTemporalDateTime(e){
    return HasSlot(e, i, s, l, d, m, c, h, u, T);
   }
   function IsTemporalYearMonth(e){return HasSlot(e, y);}
   function IsTemporalMonthDay(e){return HasSlot(e, I);}
   function IsTemporalZonedDateTime(e){return HasSlot(e, n, g, p);}
   function RejectTemporalLikeObject(e){
    if(HasSlot(e, p) || HasSlot(e, g))
     throw new
            TypeError
            ("with() does not support a calendar or timeZone property");
    if(IsTemporalTime(e))
     throw new
            TypeError
            ("with() does not accept Temporal.PlainTime, use withPlainTime() instead");
    if(void 0 !== e.calendar)
     throw new TypeError("with() does not support a calendar property");
    if(void 0 !== e.timeZone)
     throw new TypeError("with() does not support a timeZone property");
   }
   function ParseTemporalTimeZone(e){
    var
     _ParseTemporalTimeZon =
       function(e){
         if(new RegExp("^".concat($.source, "$"), "i").test(e))
          return {ianaName: e};
         try{
          var _t3 = ParseISODateTime(e);
          if(_t3.z || _t3.offset || _t3.ianaName) return _t3;
         }
         catch(_unused){}
         throw new RangeError("Invalid time zone: ".concat(e));
        }
        (e),
     t = _ParseTemporalTimeZon.ianaName,
     r = _ParseTemporalTimeZon.offset,
     o = _ParseTemporalTimeZon.z;
    if(t) return GetCanonicalTimeZoneIdentifier(t);
    if(o) return "UTC";
    return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(r));
   }
   function MaybeFormatCalendarAnnotation(e, t){
    return "never" === t
            ? ""
            : FormatCalendarAnnotation(ToTemporalCalendarIdentifier(e), t);
   }
   function FormatCalendarAnnotation(e, t){
    if("never" === t) return "";
    if("auto" === t && "iso8601" === e) return "";
    return "[".concat("critical" === t ? "!" : "", "u-ca=").concat(e, "]");
   }
   function ParseISODateTime(e){
    var t = V.exec(e);
    if(! t) throw new RangeError("invalid ISO 8601 string: ".concat(e));
    var r = t[1];
    if("" === r[0] && (r = "-".concat(r.slice(1))), "-000000" === r)
     throw new RangeError("invalid ISO 8601 string: ".concat(e));
    var
     o = ToIntegerOrInfinity(r),
     n = ToIntegerOrInfinity(t[2] || t[4]),
     a = ToIntegerOrInfinity(t[3] || t[5]),
     i = ToIntegerOrInfinity(t[6]),
     s = void 0 !== t[6],
     l = ToIntegerOrInfinity(t[7] || t[10]),
     d = ToIntegerOrInfinity(t[8] || t[11]);
    60 === d && (d = 59);
    var
     m = (t[9] || t[12]) + "000000000",
     c = ToIntegerOrInfinity(m.slice(0, 3)),
     h = ToIntegerOrInfinity(m.slice(3, 6)),
     u = ToIntegerOrInfinity(m.slice(6, 9)),
     T,
     p = ! 1;
    if(t[13])
     T = void 0, p = ! 0;
    else if(t[14] && t[15]){
     var
      _e2 = "-" === t[14] || "" === t[14] ? "-" : "+",
      _r4 = t[15] || "00",
      _o = t[16] || "00",
      _n = t[17] || "00",
      _a = t[18] || "0";
     if(T = "".concat(_e2).concat(_r4, ":").concat(_o), + _a){
      for(; _a.endsWith("0");) _a = _a.slice(0, - 1);
      T += ":".concat(_n, ".").concat(_a);
     }
     else
      + _n && (T += ":".concat(_n));
     "-00:00" === T && (T = "+00:00");
    }
    var
     f = t[19],
     y = t[20],
     I,
     _iterator4 = _createForOfIteratorHelper(y.matchAll(H)),
     _step4;
    try{
     for(_iterator4.s(); ! (_step4 = _iterator4.n()).done;){
      var
       _step4$value = _slicedToArray(_step4.value, 4),
       _e3 = _step4$value[1],
       _t4 = _step4$value[2],
       _r5 = _step4$value[3];
      if("u-ca" === _t4)
       void 0 === I && (I = _r5);
      else if("!" === _e3)
       throw new
              RangeError
              ("Unrecognized annotation: !".concat(_t4, "=").concat(_r5));
     }
    }
    catch(err){_iterator4.e(err);}
    finally{_iterator4.f();}
    return RejectDateTime(o, n, a, i, l, d, c, h, u),
           {year: o,
            month: n,
            day: a,
            hasTime: s,
            hour: i,
            minute: l,
            second: d,
            millisecond: c,
            microsecond: h,
            nanosecond: u,
            ianaName: f,
            offset: T,
            z: p,
            calendar: I};
   }
   function ParseTemporalYearMonthString(e){
    var t = _.exec(e), r, o, n, a;
    if(t){
     var _a2 = t[1];
     if
      ("" === _a2[0] && (_a2 = "-".concat(_a2.slice(1))),
       "-000000" === _a2)
      throw new RangeError("invalid ISO 8601 string: ".concat(e));
     r = ToIntegerOrInfinity(_a2), o = ToIntegerOrInfinity(t[2]);
     var
      _i = t[3],
      _iterator5 = _createForOfIteratorHelper(_i.matchAll(H)),
      _step5;
     try{
      for(_iterator5.s(); ! (_step5 = _iterator5.n()).done;){
       var
        _step5$value = _slicedToArray(_step5.value, 4),
        _e4 = _step5$value[1],
        _t5 = _step5$value[2],
        _r6 = _step5$value[3];
       if("u-ca" === _t5)
        void 0 === n && (n = _r6);
       else if("!" === _e4)
        throw new
               RangeError
               ("Unrecognized annotation: !".concat(_t5, "=").concat(_r6));
      }
     }
     catch(err){_iterator5.e(err);}
     finally{_iterator5.f();}
     if(void 0 !== n && "iso8601" !== n)
      throw new
             RangeError
             ("YYYY-MM format is only valid with iso8601 calendar");
    }
    else{
     var _ParseISODateTime, _t6;
     if
      (_ParseISODateTime = ParseISODateTime(e),
       r = _ParseISODateTime.year,
       o = _ParseISODateTime.month,
       n = _ParseISODateTime.calendar,
       a = _ParseISODateTime.day,
       _t6 = _ParseISODateTime.z,
       _t6)
      throw new RangeError("Z designator not supported for PlainYearMonth");
    }
    return {year: r, month: o, calendar: n, referenceISODay: a};
   }
   function ParseTemporalMonthDayString(e){
    var t = J.exec(e), r, o, n, a;
    if(t){
     r = ToIntegerOrInfinity(t[1]), o = ToIntegerOrInfinity(t[2]);
     var
      _e5 = t[3],
      _iterator6 = _createForOfIteratorHelper(_e5.matchAll(H)),
      _step6;
     try{
      for(_iterator6.s(); ! (_step6 = _iterator6.n()).done;){
       var
        _step6$value = _slicedToArray(_step6.value, 4),
        _t7 = _step6$value[1],
        _r7 = _step6$value[2],
        _o2 = _step6$value[3];
       if("u-ca" === _r7)
        void 0 === n && (n = _o2);
       else if("!" === _t7)
        throw new
               RangeError
               ("Unrecognized annotation: !".concat(_r7, "=").concat(_o2));
      }
     }
     catch(err){_iterator6.e(err);}
     finally{_iterator6.f();}
     if(void 0 !== n && "iso8601" !== n)
      throw new RangeError("MM-DD format is only valid with iso8601 calendar");
    }
    else{
     var _ParseISODateTime2, _t8;
     if
      (_ParseISODateTime2 = ParseISODateTime(e),
       r = _ParseISODateTime2.month,
       o = _ParseISODateTime2.day,
       n = _ParseISODateTime2.calendar,
       a = _ParseISODateTime2.year,
       _t8 = _ParseISODateTime2.z,
       _t8)
      throw new RangeError("Z designator not supported for PlainMonthDay");
    }
    return {month: r, day: o, calendar: n, referenceISOYear: a};
   }
   function ParseTemporalInstant(e){
    var
     _ParseTemporalInstant =
       function(e){
         var t = ParseISODateTime(e);
         if(! t.z && ! t.offset)
          throw new RangeError("Temporal.Instant requires a time zone offset");
         return t;
        }
        (e),
     t = _ParseTemporalInstant.year,
     r = _ParseTemporalInstant.month,
     o = _ParseTemporalInstant.day,
     n = _ParseTemporalInstant.hour,
     a = _ParseTemporalInstant.minute,
     i = _ParseTemporalInstant.second,
     s = _ParseTemporalInstant.millisecond,
     l = _ParseTemporalInstant.microsecond,
     d = _ParseTemporalInstant.nanosecond,
     m = _ParseTemporalInstant.offset,
     c = _ParseTemporalInstant.z;
    if(! c && ! m)
     throw new RangeError("Temporal.Instant requires a time zone offset");
    var
     h = c ? 0 : ParseTimeZoneOffsetString(m),
     _BalanceISODateTime = BalanceISODateTime(t, r, o, n, a, i, s, l, d - h);
    t = _BalanceISODateTime.year;
    r = _BalanceISODateTime.month;
    o = _BalanceISODateTime.day;
    n = _BalanceISODateTime.hour;
    a = _BalanceISODateTime.minute;
    i = _BalanceISODateTime.second;
    s = _BalanceISODateTime.millisecond;
    l = _BalanceISODateTime.microsecond;
    d = _BalanceISODateTime.nanosecond;
    var u = GetUTCEpochNanoseconds(t, r, o, n, a, i, s, l, d);
    if(null === u)
     throw new RangeError("DateTime outside of supported range");
    return u;
   }
   function RegulateISODate(e, t, r, o){
    var n = e, a = t, i = r;
    switch(o){
      case "reject":
       RejectISODate(n, a, i); break;
      case "constrain":
       var _ConstrainISODate = ConstrainISODate(n, a, i);
       n = _ConstrainISODate.year;
       a = _ConstrainISODate.month;
       i = _ConstrainISODate.day;
    }
    return {year: n, month: a, day: i};
   }
   function RegulateTime(e, t, r, o, n, a, i){
    var s = e, l = t, d = r, m = o, c = n, h = a;
    switch(i){
      case "reject":
       RejectTime(s, l, d, m, c, h); break;
      case "constrain":
       var
        _ConstrainTime =
          function(e, t, r, o, n, a){
            var
             i = ConstrainToRange(e, 0, 23),
             s = ConstrainToRange(t, 0, 59),
             l = ConstrainToRange(r, 0, 59),
             d = ConstrainToRange(o, 0, 999),
             m = ConstrainToRange(n, 0, 999),
             c = ConstrainToRange(a, 0, 999);
            return {hour: i,
                    minute: s,
                    second: l,
                    millisecond: d,
                    microsecond: m,
                    nanosecond: c};
           }
           (s, l, d, m, c, h);
       s = _ConstrainTime.hour;
       l = _ConstrainTime.minute;
       d = _ConstrainTime.second;
       m = _ConstrainTime.millisecond;
       c = _ConstrainTime.microsecond;
       h = _ConstrainTime.nanosecond;
    }
    return {hour: s,
            minute: l,
            second: d,
            millisecond: m,
            microsecond: c,
            nanosecond: h};
   }
   function ToTemporalDurationRecord(e){
    if(! IsObject(e))
     return function(e){
              var t = Q.exec(e);
              if(! t) throw new RangeError("invalid duration: ".concat(e));
              if(t.slice(2).every(function(e){return void 0 === e;}))
               throw new RangeError("invalid duration: ".concat(e));
              var
               r = "-" === t[1] || "" === t[1] ? - 1 : 1,
               o = void 0 === t[2] ? 0 : ToIntegerWithTruncation(t[2]) * r,
               n = void 0 === t[3] ? 0 : ToIntegerWithTruncation(t[3]) * r,
               a = void 0 === t[4] ? 0 : ToIntegerWithTruncation(t[4]) * r,
               i = void 0 === t[5] ? 0 : ToIntegerWithTruncation(t[5]) * r,
               s = void 0 === t[6] ? 0 : ToIntegerWithTruncation(t[6]) * r,
               l = t[7],
               d = t[8],
               m = t[9],
               c = t[10],
               h = t[11],
               u = 0,
               T = 0,
               p = 0;
              if(void 0 !== l){
               var _ref5, _ref6;
               if
                ((_ref5 =
                   (_ref6 = d !== null && d !== void 0 ? d : m) !== null
                    && _ref6 !== void 0
                    ? _ref6
                    : c)
                  !== null
                  && _ref5 !== void 0
                  ? _ref5
                  : h)
                throw new
                       RangeError
                       ("only the smallest unit can be fractional");
               p =
                3600 * ToIntegerOrInfinity((l + "000000000").slice(0, 9)) * r;
              }
              else if
               (u = void 0 === d ? 0 : ToIntegerWithTruncation(d) * r,
                void 0 !== m){
               if(c !== null && c !== void 0 ? c : h)
                throw new
                       RangeError
                       ("only the smallest unit can be fractional");
               p = 60 * ToIntegerOrInfinity((m + "000000000").slice(0, 9)) * r;
              }
              else
               T = void 0 === c ? 0 : ToIntegerWithTruncation(c) * r,
               void 0 !== h
               && (p = ToIntegerOrInfinity((h + "000000000").slice(0, 9)) * r);
              var f = p % 1e3, y = le(p / 1e3) % 1e3, I = le(p / 1e6) % 1e3;
              return T += le(p / 1e9) % 60,
                     u += le(p / 6e10),
                     RejectDuration(o, n, a, i, s, u, T, I, y, f),
                     {years: o,
                      months: n,
                      weeks: a,
                      days: i,
                      hours: s,
                      minutes: u,
                      seconds: T,
                      milliseconds: I,
                      microseconds: y,
                      nanoseconds: f};
             }
             (ToString(e));
    if(IsTemporalDuration(e))
     return {years: GetSlot(e, w),
             months: GetSlot(e, D),
             weeks: GetSlot(e, G),
             days: GetSlot(e, v),
             hours: GetSlot(e, C),
             minutes: GetSlot(e, O),
             seconds: GetSlot(e, b),
             milliseconds: GetSlot(e, E),
             microseconds: GetSlot(e, M),
             nanoseconds: GetSlot(e, R)};
    var
     t =
       {years: 0,
        months: 0,
        weeks: 0,
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        milliseconds: 0,
        microseconds: 0,
        nanoseconds: 0},
     r =
       function(e){
         if(! IsObject(e)) throw new TypeError("invalid duration-like");
         var
          t =
            {years: void 0,
             months: void 0,
             weeks: void 0,
             days: void 0,
             hours: void 0,
             minutes: void 0,
             seconds: void 0,
             milliseconds: void 0,
             microseconds: void 0,
             nanoseconds: void 0},
          r = ! 1,
          _iterator7 = _createForOfIteratorHelper(We),
          _step7;
         try{
          for(_iterator7.s(); ! (_step7 = _iterator7.n()).done;){
           var _o3 = _step7.value, _n2 = e[_o3];
           void 0 !== _n2 && (r = ! 0, t[_o3] = ToIntegerIfIntegral(_n2));
          }
         }
         catch(err){_iterator7.e(err);}
         finally{_iterator7.f();}
         if(! r) throw new TypeError("invalid duration-like");
         return t;
        }
        (e),
     _iterator8 = _createForOfIteratorHelper(We),
     _step8;
    try{
     for(_iterator8.s(); ! (_step8 = _iterator8.n()).done;){
      var _e6 = _step8.value, _o4 = r[_e6];
      void 0 !== _o4 && (t[_e6] = _o4);
     }
    }
    catch(err){_iterator8.e(err);}
    finally{_iterator8.f();}
    var
     o = t.years,
     n = t.months,
     a = t.weeks,
     i = t.days,
     s = t.hours,
     l = t.minutes,
     d = t.seconds,
     m = t.milliseconds,
     c = t.microseconds,
     h = t.nanoseconds;
    return RejectDuration(o, n, a, i, s, l, d, m, c, h),
           {years: o,
            months: n,
            weeks: a,
            days: i,
            hours: s,
            minutes: l,
            seconds: d,
            milliseconds: m,
            microseconds: c,
            nanoseconds: h};
   }
   function ToTemporalOverflow(e){
    return void 0 === e
            ? "constrain"
            : GetOption(e, "overflow", ["constrain", "reject"], "constrain");
   }
   function ToTemporalDisambiguation(e){
    return void 0 === e
            ? "compatible"
            : GetOption
              (e,
               "disambiguation",
               ["compatible", "earlier", "later", "reject"],
               "compatible");
   }
   function ToTemporalRoundingMode(e, t){
    return GetOption
            (e,
             "roundingMode",
             ["ceil",
              "floor",
              "expand",
              "trunc",
              "halfCeil",
              "halfFloor",
              "halfExpand",
              "halfTrunc",
              "halfEven"],
             t);
   }
   function ToTemporalOffset(e, t){
    return void 0 === e
            ? t
            : GetOption(e, "offset", ["prefer", "use", "ignore", "reject"], t);
   }
   function ToCalendarNameOption(e){
    return GetOption
            (e,
             "calendarName",
             ["auto", "always", "never", "critical"],
             "auto");
   }
   function ToTemporalRoundingIncrement(e){
    var t = e.roundingIncrement;
    if(void 0 === t) return 1;
    if(t = ToNumber(t), ! me(t))
     throw new RangeError("roundingIncrement must be finite");
    var r = le(t);
    if(r < 1 || r > 1e9)
     throw new
            RangeError
            ("roundingIncrement must be at least 1 and at most 1e9, not ".concat
              (t));
    return r;
   }
   function ValidateTemporalRoundingIncrement(e, t, r){
    var o = r ? t : t - 1;
    if(e > o)
     throw new
            RangeError
            ("roundingIncrement must be at least 1 and less than ".concat
               (o, ", not ").concat
              (e));
    if(t % e != 0)
     throw new
            RangeError
            ("Rounding increment must divide evenly into ".concat(t));
   }
   function ToFractionalSecondDigits(e){
    var t = e.fractionalSecondDigits;
    if(void 0 === t) return "auto";
    if("number" != typeof t){
     if("auto" !== ToString(t))
      throw new
             RangeError
             ("fractionalSecondDigits must be 'auto' or 0 through 9, not ".concat
               (t));
     return "auto";
    }
    var r = ie(t);
    if(! me(r) || r < 0 || r > 9)
     throw new
            RangeError
            ("fractionalSecondDigits must be 'auto' or 0 through 9, not ".concat
              (t));
    return r;
   }
   function ToSecondsStringPrecisionRecord(e, t){
    switch(e){
      case "minute":
       return {precision: "minute", unit: "minute", increment: 1};
      case "second":
       return {precision: 0, unit: "second", increment: 1};
      case "millisecond":
       return {precision: 3, unit: "millisecond", increment: 1};
      case "microsecond":
       return {precision: 6, unit: "microsecond", increment: 1};
      case "nanosecond":
       return {precision: 9, unit: "nanosecond", increment: 1};
    }
    switch(t){
      case "auto":
       return {precision: t, unit: "nanosecond", increment: 1};
      case 0:
       return {precision: t, unit: "second", increment: 1};
      case 1:
      case 2:
      case 3:
       return {precision: t,
               unit: "millisecond",
               increment: Math.pow(10, 3 - t)};
      case 4:
      case 5:
      case 6:
       return {precision: t,
               unit: "microsecond",
               increment: Math.pow(10, 6 - t)};
      case 7:
      case 8:
      case 9:
       return {precision: t,
               unit: "nanosecond",
               increment: Math.pow(10, 9 - t)};
      default:
       throw new
              RangeError
              ("fractionalSecondDigits must be 'auto' or 0 through 9, not ".concat
                (t));
    }
   }
   var He = Symbol("~required~");
   function GetTemporalUnit(e, t, r, o){
    var
     n =
       arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [],
     a = [];
    for(var _i2 = 0, _Ue = Ue; _i2 < _Ue.length; _i2++){
     var
      _Ue$_i = _slicedToArray(_Ue[_i2], 3),
      _e7 = _Ue$_i[1],
      _t9 = _Ue$_i[2];
     "datetime" !== r && r !== _t9 || a.push(_e7);
    }
    a.push.apply(a, _toConsumableArray(n));
    var i = o;
    i === He ? i = void 0 : void 0 !== i && a.push(i);
    var s = [].concat(a);
    for(var _i3 = 0, _a3 = a; _i3 < _a3.length; _i3++){
     var _e8 = _a3[_i3], _t10 = Le.get(_e8);
     void 0 !== _t10 && s.push(_t10);
    }
    var l = GetOption(e, t, s, i);
    if(void 0 === l && o === He)
     throw new RangeError("".concat(t, " is required"));
    return Ae.has(l) ? Ae.get(l) : l;
   }
   function ToRelativeTemporalObject(e){
    var t = e.relativeTo;
    if(void 0 === t) return t;
    var r, o, n, a, i, s, l, d, m, c, h, u, T = "option", p = ! 1;
    if(IsObject(t)){
     var _InterpretTemporalDat;
     if(IsTemporalZonedDateTime(t) || IsTemporalDate(t)) return t;
     if(IsTemporalDateTime(t)) return TemporalDateTimeToDate(t);
     c = GetTemporalCalendarSlotValueWithISODefault(t);
     var
      _e9 =
        CalendarFields
         (c,
          ["day",
           "hour",
           "microsecond",
           "millisecond",
           "minute",
           "month",
           "monthCode",
           "nanosecond",
           "second",
           "year"]);
     _e9.push("timeZone", "offset");
     var _p = PrepareTemporalFields(t, _e9, []), _f = Te(null);
     _f.overflow = "constrain",
     _InterpretTemporalDat = InterpretTemporalDateTimeFields(c, _p, _f),
     r = _InterpretTemporalDat.year,
     o = _InterpretTemporalDat.month,
     n = _InterpretTemporalDat.day,
     a = _InterpretTemporalDat.hour,
     i = _InterpretTemporalDat.minute,
     s = _InterpretTemporalDat.second,
     l = _InterpretTemporalDat.millisecond,
     d = _InterpretTemporalDat.microsecond,
     m = _InterpretTemporalDat.nanosecond,
     u = _p.offset,
     void 0 === u && (T = "wall"),
     h = _p.timeZone,
     void 0 !== h && (h = ToTemporalTimeZoneSlotValue(h));
    }
    else{
     var _ParseISODateTime3, _e10, _f2;
     if
      (_ParseISODateTime3 = ParseISODateTime(ToString(t)),
       r = _ParseISODateTime3.year,
       o = _ParseISODateTime3.month,
       n = _ParseISODateTime3.day,
       a = _ParseISODateTime3.hour,
       i = _ParseISODateTime3.minute,
       s = _ParseISODateTime3.second,
       l = _ParseISODateTime3.millisecond,
       d = _ParseISODateTime3.microsecond,
       m = _ParseISODateTime3.nanosecond,
       c = _ParseISODateTime3.calendar,
       _e10 = _ParseISODateTime3.ianaName,
       u = _ParseISODateTime3.offset,
       _f2 = _ParseISODateTime3.z,
       _e10)
      h = ToTemporalTimeZoneSlotValue(_e10),
      _f2 ? T = "exact" : u || (T = "wall"),
      p = ! 0;
     else if(_f2)
      throw new
             RangeError
             ("Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone");
     if(c || (c = "iso8601"), ! IsBuiltinCalendar(c))
      throw new RangeError("invalid calendar identifier ".concat(c));
     c = ASCIILowercase(c);
    }
    if(void 0 === h) return CreateTemporalDate(r, o, n, c);
    return CreateTemporalZonedDateTime
            (InterpretISODateTimeOffset
              (r,
               o,
               n,
               a,
               i,
               s,
               l,
               d,
               m,
               T,
               "option" === T ? ParseTimeZoneOffsetString(u) : 0,
               h,
               "compatible",
               "reject",
               p),
             h,
             c);
   }
   function DefaultTemporalLargestUnit(e, t, r, o, n, a, i, s, l, d){
    for
    (var
      _i4 = 0,
      _arr =
        [["years", e],
         ["months", t],
         ["weeks", r],
         ["days", o],
         ["hours", n],
         ["minutes", a],
         ["seconds", i],
         ["milliseconds", s],
         ["microseconds", l],
         ["nanoseconds", d]];
     _i4 < _arr.length;
     _i4++){
     var
      _arr$_i = _slicedToArray(_arr[_i4], 2),
      _m = _arr$_i[0],
      _c = _arr$_i[1];
     if(0 !== _c) return Ae.get(_m);
    }
    return "nanosecond";
   }
   function LargerOfTwoTemporalUnits(e, t){
    return xe.indexOf(e) > xe.indexOf(t) ? t : e;
   }
   function PrepareTemporalFields(e, t, r){
    var
     _ref7 =
       arguments.length > 3 && arguments[3] !== undefined
        ? arguments[3]
        : {emptySourceErrorMessage: "no supported properties found"},
     o = _ref7.emptySourceErrorMessage,
     n = Te(null),
     a = ! 1;
    t.sort();
    var _iterator9 = _createForOfIteratorHelper(t), _step9;
    try{
     for(_iterator9.s(); ! (_step9 = _iterator9.n()).done;){
      var _o5 = _step9.value, _t11 = e[_o5];
      if(void 0 !== _t11)
       a = ! 0, $e.has(_o5) && (_t11 = $e.get(_o5)(_t11)), n[_o5] = _t11;
      else if("partial" !== r){
       if(ee.call(r, _o5))
        throw new
               TypeError
               ("required property '".concat(_o5, "' missing or undefined"));
       _t11 = ke.get(_o5), n[_o5] = _t11;
      }
     }
    }
    catch(err){_iterator9.e(err);}
    finally{_iterator9.f();}
    if("partial" === r && ! a) throw new TypeError(o);
    return n;
   }
   function ToTemporalTimeRecord(e){
    var
     t =
       arguments.length > 1 && arguments[1] !== undefined
        ? arguments[1]
        : "complete",
     r =
       ["hour",
        "microsecond",
        "millisecond",
        "minute",
        "nanosecond",
        "second"],
     o =
       PrepareTemporalFields
        (e, r, "partial", {emptySourceErrorMessage: "invalid time-like"}),
     n = {};
    for(var _i5 = 0, _r8 = r; _i5 < _r8.length; _i5++){
     var _e11 = _r8[_i5], _r9 = pe(o, _e11);
     void 0 !== _r9 ? n[_e11] = _r9.value : "complete" === t && (n[_e11] = 0);
    }
    return n;
   }
   function ToTemporalDate(e, t){
    var r = e;
    if(IsObject(r)){
     if(IsTemporalDate(r)) return r;
     if
      (IsTemporalZonedDateTime(r)
       &&
        (ToTemporalOverflow(t),
         r = GetPlainDateTimeFor(GetSlot(r, g), GetSlot(r, S), GetSlot(r, p))),
       IsTemporalDateTime(r))
      return ToTemporalOverflow(t),
             CreateTemporalDate
              (GetSlot(r, i), GetSlot(r, s), GetSlot(r, l), GetSlot(r, p));
     var _e12 = GetTemporalCalendarSlotValueWithISODefault(r);
     return CalendarDateFromFields
             (_e12,
              PrepareTemporalFields
               (r,
                CalendarFields(_e12, ["day", "month", "monthCode", "year"]),
                []),
              t);
    }
    ToTemporalOverflow(t);
    var
     _ParseTemporalDateStr =
       function(e){return ParseISODateTime(e);}(ToString(r)),
     o = _ParseTemporalDateStr.year,
     n = _ParseTemporalDateStr.month,
     a = _ParseTemporalDateStr.day,
     d = _ParseTemporalDateStr.calendar,
     m = _ParseTemporalDateStr.z;
    if(m) throw new RangeError("Z designator not supported for PlainDate");
    if(d || (d = "iso8601"), ! IsBuiltinCalendar(d))
     throw new RangeError("invalid calendar identifier ".concat(d));
    return d = ASCIILowercase(d), CreateTemporalDate(o, n, a, d);
   }
   function InterpretTemporalDateTimeFields(e, t, r){
    var
     _RegulateTime,
     _ToTemporalTimeRecord = ToTemporalTimeRecord(t),
     o = _ToTemporalTimeRecord.hour,
     n = _ToTemporalTimeRecord.minute,
     a = _ToTemporalTimeRecord.second,
     d = _ToTemporalTimeRecord.millisecond,
     m = _ToTemporalTimeRecord.microsecond,
     c = _ToTemporalTimeRecord.nanosecond,
     h = ToTemporalOverflow(r),
     u = CalendarDateFromFields(e, t, r),
     T = GetSlot(u, i),
     p = GetSlot(u, s),
     f = GetSlot(u, l);
    return _RegulateTime = RegulateTime(o, n, a, d, m, c, h),
           o = _RegulateTime.hour,
           n = _RegulateTime.minute,
           a = _RegulateTime.second,
           d = _RegulateTime.millisecond,
           m = _RegulateTime.microsecond,
           c = _RegulateTime.nanosecond,
           {year: T,
            month: p,
            day: f,
            hour: o,
            minute: n,
            second: a,
            millisecond: d,
            microsecond: m,
            nanosecond: c};
   }
   function ToTemporalDateTime(e, t){
    var r, o, n, a, d, m, c, h, u, T;
    if(IsObject(e)){
     if(IsTemporalDateTime(e)) return e;
     if(IsTemporalZonedDateTime(e))
      return ToTemporalOverflow(t),
             GetPlainDateTimeFor(GetSlot(e, g), GetSlot(e, S), GetSlot(e, p));
     if(IsTemporalDate(e))
      return ToTemporalOverflow(t),
             CreateTemporalDateTime
              (GetSlot(e, i),
               GetSlot(e, s),
               GetSlot(e, l),
               0,
               0,
               0,
               0,
               0,
               0,
               GetSlot(e, p));
     T = GetTemporalCalendarSlotValueWithISODefault(e);
     var
      _f3 =
        PrepareTemporalFields
         (e,
          CalendarFields
           (T,
            ["day",
             "hour",
             "microsecond",
             "millisecond",
             "minute",
             "month",
             "monthCode",
             "nanosecond",
             "second",
             "year"]),
          []),
      _InterpretTemporalDat2 = InterpretTemporalDateTimeFields(T, _f3, t);
     r = _InterpretTemporalDat2.year;
     o = _InterpretTemporalDat2.month;
     n = _InterpretTemporalDat2.day;
     a = _InterpretTemporalDat2.hour;
     d = _InterpretTemporalDat2.minute;
     m = _InterpretTemporalDat2.second;
     c = _InterpretTemporalDat2.millisecond;
     h = _InterpretTemporalDat2.microsecond;
     u = _InterpretTemporalDat2.nanosecond;
    }
    else{
     var _ParseTemporalDateTim, _i6;
     if
      (ToTemporalOverflow(t),
       _ParseTemporalDateTim =
        function(e){return ParseISODateTime(e);}(ToString(e)),
       r = _ParseTemporalDateTim.year,
       o = _ParseTemporalDateTim.month,
       n = _ParseTemporalDateTim.day,
       a = _ParseTemporalDateTim.hour,
       d = _ParseTemporalDateTim.minute,
       m = _ParseTemporalDateTim.second,
       c = _ParseTemporalDateTim.millisecond,
       h = _ParseTemporalDateTim.microsecond,
       u = _ParseTemporalDateTim.nanosecond,
       T = _ParseTemporalDateTim.calendar,
       _i6 = _ParseTemporalDateTim.z,
       _i6)
      throw new RangeError("Z designator not supported for PlainDateTime");
     if
      (RejectDateTime(r, o, n, a, d, m, c, h, u),
       T || (T = "iso8601"),
       !
       IsBuiltinCalendar(T))
      throw new RangeError("invalid calendar identifier ".concat(T));
     T = ASCIILowercase(T);
    }
    return CreateTemporalDateTime(r, o, n, a, d, m, c, h, u, T);
   }
   function ToTemporalDuration(e){
    if(IsTemporalDuration(e)) return e;
    var
     _ToTemporalDurationRe = ToTemporalDurationRecord(e),
     t = _ToTemporalDurationRe.years,
     r = _ToTemporalDurationRe.months,
     o = _ToTemporalDurationRe.weeks,
     n = _ToTemporalDurationRe.days,
     a = _ToTemporalDurationRe.hours,
     i = _ToTemporalDurationRe.minutes,
     s = _ToTemporalDurationRe.seconds,
     l = _ToTemporalDurationRe.milliseconds,
     d = _ToTemporalDurationRe.microseconds,
     m = _ToTemporalDurationRe.nanoseconds;
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (t, r, o, n, a, i, s, l, d, m);
   }
   function ToTemporalInstant(e){
    if(IsTemporalInstant(e)) return e;
    if(IsTemporalZonedDateTime(e))
     return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e, n));
    var t = ParseTemporalInstant(ToString(e));
    return new (GetIntrinsic("%Temporal.Instant%"))(t);
   }
   function ToTemporalMonthDay(e, t){
    var r = e;
    if(IsObject(r)){
     if(IsTemporalMonthDay(r)) return r;
     var _e13, _o6;
     if(HasSlot(r, p))
      _e13 = GetSlot(r, p), _o6 = ! 1;
     else{
      var _t12 = r.calendar;
      _o6 = void 0 === _t12,
      void 0 === _t12 && (_t12 = "iso8601"),
      _e13 = ToTemporalCalendarSlotValue(_t12);
     }
     var
      _n3 =
        PrepareTemporalFields
         (r, CalendarFields(_e13, ["day", "month", "monthCode", "year"]), []);
     return _o6 && void 0 !== _n3.month && void 0 === _n3.monthCode
            && void 0 === _n3.year
            && (_n3.year = 1972),
            CalendarMonthDayFromFields(_e13, _n3, t);
    }
    ToTemporalOverflow(t);
    var
     _ParseTemporalMonthDa = ParseTemporalMonthDayString(ToString(r)),
     o = _ParseTemporalMonthDa.month,
     n = _ParseTemporalMonthDa.day,
     a = _ParseTemporalMonthDa.referenceISOYear,
     i = _ParseTemporalMonthDa.calendar;
    if(void 0 === i && (i = "iso8601"), ! IsBuiltinCalendar(i))
     throw new RangeError("invalid calendar identifier ".concat(i));
    if(i = ASCIILowercase(i), void 0 === a)
     return RejectISODate(1972, o, n), CreateTemporalMonthDay(o, n, i);
    return CalendarMonthDayFromFields(i, CreateTemporalMonthDay(o, n, i, a));
   }
   function ToTemporalTime(e){
    var
     _ParseTemporalTimeStr,
     t =
       arguments.length > 1 && arguments[1] !== undefined
        ? arguments[1]
        : "constrain",
     r,
     o,
     n,
     a,
     i,
     s,
     l = e;
    if(IsObject(l)){
     var _ToTemporalTimeRecord2, _RegulateTime2;
     if(IsTemporalTime(l)) return l;
     if
      (IsTemporalZonedDateTime(l)
       &&
        (l = GetPlainDateTimeFor(GetSlot(l, g), GetSlot(l, S), GetSlot(l, p))),
       IsTemporalDateTime(l))
      return new
              (GetIntrinsic("%Temporal.PlainTime%"))
              (GetSlot(l, d),
               GetSlot(l, m),
               GetSlot(l, c),
               GetSlot(l, h),
               GetSlot(l, u),
               GetSlot(l, T));
     _ToTemporalTimeRecord2 = ToTemporalTimeRecord(l),
     r = _ToTemporalTimeRecord2.hour,
     o = _ToTemporalTimeRecord2.minute,
     n = _ToTemporalTimeRecord2.second,
     a = _ToTemporalTimeRecord2.millisecond,
     i = _ToTemporalTimeRecord2.microsecond,
     s = _ToTemporalTimeRecord2.nanosecond,
     _RegulateTime2 = RegulateTime(r, o, n, a, i, s, t),
     r = _RegulateTime2.hour,
     o = _RegulateTime2.minute,
     n = _RegulateTime2.second,
     a = _RegulateTime2.millisecond,
     i = _RegulateTime2.microsecond,
     s = _RegulateTime2.nanosecond;
    }
    else
     _ParseTemporalTimeStr =
      function(e){
        var t = z.exec(e), r, o, n, a, i, s, l;
        if(t){
         r = ToIntegerOrInfinity(t[1]),
         o = ToIntegerOrInfinity(t[2] || t[5]),
         n = ToIntegerOrInfinity(t[3] || t[6]),
         60 === n && (n = 59);
         var _e14 = (t[4] || t[7]) + "000000000";
         a = ToIntegerOrInfinity(_e14.slice(0, 3)),
         i = ToIntegerOrInfinity(_e14.slice(3, 6)),
         s = ToIntegerOrInfinity(_e14.slice(6, 9)),
         l = t[14];
         var _iterator10 = _createForOfIteratorHelper(l.matchAll(H)), _step10;
         try{
          for(_iterator10.s(); ! (_step10 = _iterator10.n()).done;){
           var
            _step10$value = _slicedToArray(_step10.value, 4),
            _e15 = _step10$value[1],
            _t13 = _step10$value[2],
            _r10 = _step10$value[3];
           if("u-ca" !== _t13 && "!" === _e15)
            throw new
                   RangeError
                   ("Unrecognized annotation: !".concat(_t13, "=").concat(_r10));
          }
         }
         catch(err){_iterator10.e(err);}
         finally{_iterator10.f();}
         if(t[8])
          throw new RangeError("Z designator not supported for PlainTime");
        }
        else{
         var _ParseISODateTime4, _t14, _l;
         if
          (_ParseISODateTime4 = ParseISODateTime(e),
           _l = _ParseISODateTime4.hasTime,
           r = _ParseISODateTime4.hour,
           o = _ParseISODateTime4.minute,
           n = _ParseISODateTime4.second,
           a = _ParseISODateTime4.millisecond,
           i = _ParseISODateTime4.microsecond,
           s = _ParseISODateTime4.nanosecond,
           _t14 = _ParseISODateTime4.z,
           !
           _l)
          throw new RangeError("time is missing in string: ".concat(e));
         if(_t14)
          throw new RangeError("Z designator not supported for PlainTime");
        }
        if(/[tT ][0-9][0-9]/.test(e))
         return {hour: r,
                 minute: o,
                 second: n,
                 millisecond: a,
                 microsecond: i,
                 nanosecond: s};
        try{
         var
          _ParseTemporalMonthDa2 = ParseTemporalMonthDayString(e),
          _t15 = _ParseTemporalMonthDa2.month,
          _r11 = _ParseTemporalMonthDa2.day;
         RejectISODate(1972, _t15, _r11);
        }
        catch(_unused2){
         try{
          var
           _ParseTemporalYearMon = ParseTemporalYearMonthString(e),
           _t16 = _ParseTemporalYearMon.year,
           _r12 = _ParseTemporalYearMon.month;
          RejectISODate(_t16, _r12, 1);
         }
         catch(_unused3){
          return {hour: r,
                  minute: o,
                  second: n,
                  millisecond: a,
                  microsecond: i,
                  nanosecond: s};
         }
        }
        throw new
               RangeError
               ("invalid ISO 8601 time-only string ".concat
                 (e, "; may need a T prefix"));
       }
       (ToString(l)),
     r = _ParseTemporalTimeStr.hour,
     o = _ParseTemporalTimeStr.minute,
     n = _ParseTemporalTimeStr.second,
     a = _ParseTemporalTimeStr.millisecond,
     i = _ParseTemporalTimeStr.microsecond,
     s = _ParseTemporalTimeStr.nanosecond,
     RejectTime(r, o, n, a, i, s);
    return new (GetIntrinsic("%Temporal.PlainTime%"))(r, o, n, a, i, s);
   }
   function ToTemporalYearMonth(e, t){
    if(IsObject(e)){
     if(IsTemporalYearMonth(e)) return e;
     var _r13 = GetTemporalCalendarSlotValueWithISODefault(e);
     return CalendarYearMonthFromFields
             (_r13,
              PrepareTemporalFields
               (e, CalendarFields(_r13, ["month", "monthCode", "year"]), []),
              t);
    }
    ToTemporalOverflow(t);
    var
     _ParseTemporalYearMon2 = ParseTemporalYearMonthString(ToString(e)),
     r = _ParseTemporalYearMon2.year,
     o = _ParseTemporalYearMon2.month,
     n = _ParseTemporalYearMon2.referenceISODay,
     a = _ParseTemporalYearMon2.calendar;
    if(void 0 === a && (a = "iso8601"), ! IsBuiltinCalendar(a))
     throw new RangeError("invalid calendar identifier ".concat(a));
    if(a = ASCIILowercase(a), void 0 === n)
     return RejectISODate(r, o, 1), CreateTemporalYearMonth(r, o, a);
    return CalendarYearMonthFromFields(a, CreateTemporalYearMonth(r, o, a, n));
   }
   function InterpretISODateTimeOffset
   (t, r, o, i, s, l, d, m, c, h, u, T, p, f, y){
    var
     I =
       new
        (GetIntrinsic("%Temporal.PlainDateTime%"))
        (t, r, o, i, s, l, d, m, c);
    if("wall" === h || "ignore" === f)
     return GetSlot(GetInstantFor(T, I, p), n);
    if("exact" === h || "use" === f){
     var _n4 = GetUTCEpochNanoseconds(t, r, o, i, s, l, d, m, c);
     if(null === _n4)
      throw new RangeError("ZonedDateTime outside of supported range");
     return _n4 - BigInt(u);
    }
    var
     S = GetPossibleInstantsFor(T, I),
     _iterator11 = _createForOfIteratorHelper(S),
     _step11;
    try{
     for(_iterator11.s(); ! (_step11 = _iterator11.n()).done;){
      var
       _t18 = _step11.value,
       _r14 = GetOffsetNanosecondsFor(T, _t18),
       _o7 = Number(RoundNumberToIncrement(BigInt(_r14), be, "halfExpand"));
      if(_r14 === u || y && _o7 === u) return GetSlot(_t18, n);
     }
    }
    catch(err){_iterator11.e(err);}
    finally{_iterator11.f();}
    if("reject" === f){
     var
      _e16 = FormatTimeZoneOffsetString(u),
      _t17 = IsTemporalTimeZone(T) ? GetSlot(T, a) : "time zone";
     throw new
            RangeError
            ("Offset ".concat(_e16, " is invalid for ").concat
               (I.toString(), " in ").concat
              (_t17));
    }
    return GetSlot(DisambiguatePossibleInstants(S, T, I, p), n);
   }
   function ToTemporalZonedDateTime(e, t){
    var r, o, n, a, i, s, l, d, m, c, h, u, T, p, f = ! 1, y = "option";
    if(IsObject(e)){
     var _InterpretTemporalDat3;
     if(IsTemporalZonedDateTime(e)) return e;
     u = GetTemporalCalendarSlotValueWithISODefault(e);
     var
      _f4 =
        CalendarFields
         (u,
          ["day",
           "hour",
           "microsecond",
           "millisecond",
           "minute",
           "month",
           "monthCode",
           "nanosecond",
           "second",
           "year"]);
     _f4.push("timeZone", "offset");
     var _I = PrepareTemporalFields(e, _f4, ["timeZone"]);
     c = ToTemporalTimeZoneSlotValue(_I.timeZone),
     h = _I.offset,
     void 0 === h && (y = "wall"),
     T = ToTemporalDisambiguation(t),
     p = ToTemporalOffset(t, "reject"),
     _InterpretTemporalDat3 = InterpretTemporalDateTimeFields(u, _I, t),
     r = _InterpretTemporalDat3.year,
     o = _InterpretTemporalDat3.month,
     n = _InterpretTemporalDat3.day,
     a = _InterpretTemporalDat3.hour,
     i = _InterpretTemporalDat3.minute,
     s = _InterpretTemporalDat3.second,
     l = _InterpretTemporalDat3.millisecond,
     d = _InterpretTemporalDat3.microsecond,
     m = _InterpretTemporalDat3.nanosecond;
    }
    else{
     var _ParseTemporalZonedDa, _I2, _S;
     if
      (_ParseTemporalZonedDa =
        function(e){
          var t = ParseISODateTime(e);
          if(! t.ianaName)
           throw new
                  RangeError
                  ("Temporal.ZonedDateTime requires a time zone ID in brackets");
          return t;
         }
         (ToString(e)),
       r = _ParseTemporalZonedDa.year,
       o = _ParseTemporalZonedDa.month,
       n = _ParseTemporalZonedDa.day,
       a = _ParseTemporalZonedDa.hour,
       i = _ParseTemporalZonedDa.minute,
       s = _ParseTemporalZonedDa.second,
       l = _ParseTemporalZonedDa.millisecond,
       d = _ParseTemporalZonedDa.microsecond,
       m = _ParseTemporalZonedDa.nanosecond,
       _I2 = _ParseTemporalZonedDa.ianaName,
       h = _ParseTemporalZonedDa.offset,
       _S = _ParseTemporalZonedDa.z,
       u = _ParseTemporalZonedDa.calendar,
       c = ToTemporalTimeZoneSlotValue(_I2),
       _S ? y = "exact" : h || (y = "wall"),
       u || (u = "iso8601"),
       !
       IsBuiltinCalendar(u))
      throw new RangeError("invalid calendar identifier ".concat(u));
     u = ASCIILowercase(u),
     f = ! 0,
     T = ToTemporalDisambiguation(t),
     p = ToTemporalOffset(t, "reject"),
     ToTemporalOverflow(t);
    }
    var I = 0;
    "option" === y && (I = ParseTimeZoneOffsetString(h));
    return CreateTemporalZonedDateTime
            (InterpretISODateTimeOffset
              (r, o, n, a, i, s, l, d, m, y, I, c, T, p, f),
             c,
             u);
   }
   function CreateTemporalDateSlots(e, t, r, o, n){
    RejectISODate(t, r, o),
    RejectDateRange(t, r, o),
    N(e),
    SetSlot(e, i, t),
    SetSlot(e, s, r),
    SetSlot(e, l, o),
    SetSlot(e, p, n),
    SetSlot(e, f, ! 0);
   }
   function CreateTemporalDate(e, t, r){
    var
     o =
       arguments.length > 3 && arguments[3] !== undefined
        ? arguments[3]
        : "iso8601",
     n = GetIntrinsic("%Temporal.PlainDate%"),
     a = Te(n.prototype);
    return CreateTemporalDateSlots(a, e, t, r, o), a;
   }
   function CreateTemporalDateTimeSlots(e, t, r, o, n, a, f, y, I, S, g){
    RejectDateTime(t, r, o, n, a, f, y, I, S),
    RejectDateTimeRange(t, r, o, n, a, f, y, I, S),
    N(e),
    SetSlot(e, i, t),
    SetSlot(e, s, r),
    SetSlot(e, l, o),
    SetSlot(e, d, n),
    SetSlot(e, m, a),
    SetSlot(e, c, f),
    SetSlot(e, h, y),
    SetSlot(e, u, I),
    SetSlot(e, T, S),
    SetSlot(e, p, g);
   }
   function CreateTemporalDateTime(e, t, r, o, n, a, i, s, l){
    var
     d =
       arguments.length > 9 && arguments[9] !== undefined
        ? arguments[9]
        : "iso8601",
     m = GetIntrinsic("%Temporal.PlainDateTime%"),
     c = Te(m.prototype);
    return CreateTemporalDateTimeSlots(c, e, t, r, o, n, a, i, s, l, d), c;
   }
   function CreateTemporalMonthDaySlots(e, t, r, o, n){
    RejectISODate(n, t, r),
    RejectDateRange(n, t, r),
    N(e),
    SetSlot(e, s, t),
    SetSlot(e, l, r),
    SetSlot(e, i, n),
    SetSlot(e, p, o),
    SetSlot(e, I, ! 0);
   }
   function CreateTemporalMonthDay(e, t){
    var
     r =
       arguments.length > 2 && arguments[2] !== undefined
        ? arguments[2]
        : "iso8601",
     o =
       arguments.length > 3 && arguments[3] !== undefined
        ? arguments[3]
        : 1972,
     n = GetIntrinsic("%Temporal.PlainMonthDay%"),
     a = Te(n.prototype);
    return CreateTemporalMonthDaySlots(a, e, t, r, o), a;
   }
   function CreateTemporalYearMonthSlots(e, t, r, o, n){
    RejectISODate(t, r, n),
    function(e, t){
      RejectToRange(e, Fe, Ye),
      e === Fe ? RejectToRange(t, 4, 12) : e === Ye && RejectToRange(t, 1, 9);
     }
     (t, r),
    N(e),
    SetSlot(e, i, t),
    SetSlot(e, s, r),
    SetSlot(e, l, n),
    SetSlot(e, p, o),
    SetSlot(e, y, ! 0);
   }
   function CreateTemporalYearMonth(e, t){
    var
     r =
       arguments.length > 2 && arguments[2] !== undefined
        ? arguments[2]
        : "iso8601",
     o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1,
     n = GetIntrinsic("%Temporal.PlainYearMonth%"),
     a = Te(n.prototype);
    return CreateTemporalYearMonthSlots(a, e, t, r, o), a;
   }
   function CreateTemporalZonedDateTimeSlots(e, t, r, o){
    ValidateEpochNanoseconds(t),
    N(e),
    SetSlot(e, n, t),
    SetSlot(e, g, r),
    SetSlot(e, p, o);
    var a = new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e, n));
    SetSlot(e, S, a);
   }
   function CreateTemporalZonedDateTime(e, t){
    var
     r =
       arguments.length > 2 && arguments[2] !== undefined
        ? arguments[2]
        : "iso8601",
     o = GetIntrinsic("%Temporal.ZonedDateTime%"),
     n = Te(o.prototype);
    return CreateTemporalZonedDateTimeSlots(n, e, t, r), n;
   }
   function CalendarFields(e, t){
    if("string" == typeof e){
     var _r15 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.fields%"), _r15, [t]);
    }
    var
     r = Call(GetMethod(e, "fields"), e, [t]),
     o = [],
     _iterator12 = _createForOfIteratorHelper(r),
     _step12;
    try{
     for(_iterator12.s(); ! (_step12 = _iterator12.n()).done;){
      var _e17 = _step12.value;
      if("string" != typeof _e17)
       throw new TypeError("bad return from calendar.fields()");
      te.call(o, _e17);
     }
    }
    catch(err){_iterator12.e(err);}
    finally{_iterator12.f();}
    return o;
   }
   function CalendarMergeFields(e, t, r){
    if("string" == typeof e){
     var _o8 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.mergeFields%"),
              _o8,
              [t, r]);
    }
    var o = Call(GetMethod(e, "mergeFields"), e, [t, r]);
    if(! IsObject(o))
     throw new TypeError("bad return from calendar.mergeFields()");
    return o;
   }
   function CalendarDateAdd(e, t, r, o, n){
    var a = n;
    if("string" == typeof e){
     var _n5 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.dateAdd%"),
              _n5,
              [t, r, o]);
    }
    void 0 === a && (a = GetMethod(e, "dateAdd"));
    var i = fe(a, e, [t, r, o]);
    if(! IsTemporalDate(i)) throw new TypeError("invalid result");
    return i;
   }
   function CalendarDateUntil(e, t, r, o, n){
    var a = n;
    if("string" == typeof e){
     var _n6 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.dateUntil%"),
              _n6,
              [t, r, o]);
    }
    void 0 === a && (a = GetMethod(e, "dateUntil"));
    var i = fe(a, e, [t, r, o]);
    if(! IsTemporalDuration(i)) throw new TypeError("invalid result");
    return i;
   }
   function CalendarYear(e, t){
    if("string" == typeof e){
     var _r16 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.year%"), _r16, [t]);
    }
    var r = Call(GetMethod(e, "year"), e, [t]);
    if("number" != typeof r)
     throw new TypeError("calendar year result must be an integer");
    if(! IsIntegralNumber(r))
     throw new RangeError("calendar year result must be an integer");
    return r;
   }
   function CalendarMonth(e, t){
    if("string" == typeof e){
     var _r17 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.month%"), _r17, [t]);
    }
    var r = Call(GetMethod(e, "month"), e, [t]);
    if("number" != typeof r)
     throw new TypeError("calendar month result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new RangeError("calendar month result must be a positive integer");
    return r;
   }
   function CalendarMonthCode(e, t){
    if("string" == typeof e){
     var _r18 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.monthCode%"),
              _r18,
              [t]);
    }
    var r = Call(GetMethod(e, "monthCode"), e, [t]);
    if("string" != typeof r)
     throw new TypeError("calendar monthCode result must be a string");
    return r;
   }
   function CalendarDay(e, t){
    if("string" == typeof e){
     var _r19 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call(GetIntrinsic("%Temporal.Calendar.prototype.day%"), _r19, [t]);
    }
    var r = Call(GetMethod(e, "day"), e, [t]);
    if("number" != typeof r)
     throw new TypeError("calendar day result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new RangeError("calendar day result must be a positive integer");
    return r;
   }
   function CalendarEra(e, t){
    if("string" == typeof e){
     var _r20 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call(GetIntrinsic("%Temporal.Calendar.prototype.era%"), _r20, [t]);
    }
    var r = Call(GetMethod(e, "era"), e, [t]);
    if(void 0 === r) return r;
    if("string" != typeof r)
     throw new TypeError("calendar era result must be a string or undefined");
    return r;
   }
   function CalendarEraYear(e, t){
    if("string" == typeof e){
     var _r21 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.eraYear%"),
              _r21,
              [t]);
    }
    var r = Call(GetMethod(e, "eraYear"), e, [t]);
    if(void 0 === r) return r;
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar eraYear result must be an integer or undefined");
    if(! IsIntegralNumber(r))
     throw new
            RangeError
            ("calendar eraYear result must be an integer or undefined");
    return r;
   }
   function CalendarDayOfWeek(e, t){
    if("string" == typeof e){
     var _r22 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.dayOfWeek%"),
              _r22,
              [t]);
    }
    var r = Call(GetMethod(e, "dayOfWeek"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar dayOfWeek result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar dayOfWeek result must be a positive integer");
    return r;
   }
   function CalendarDayOfYear(e, t){
    if("string" == typeof e){
     var _r23 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.dayOfYear%"),
              _r23,
              [t]);
    }
    var r = Call(GetMethod(e, "dayOfYear"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar dayOfYear result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar dayOfYear result must be a positive integer");
    return r;
   }
   function CalendarWeekOfYear(e, t){
    if("string" == typeof e){
     var _r24 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.weekOfYear%"),
              _r24,
              [t]);
    }
    var r = Call(GetMethod(e, "weekOfYear"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar weekOfYear result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar weekOfYear result must be a positive integer");
    return r;
   }
   function CalendarYearOfWeek(e, t){
    if("string" == typeof e){
     var _r25 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.yearOfWeek%"),
              _r25,
              [t]);
    }
    var r = Call(GetMethod(e, "yearOfWeek"), e, [t]);
    if("number" != typeof r)
     throw new TypeError("calendar yearOfWeek result must be an integer");
    if(! IsIntegralNumber(r))
     throw new RangeError("calendar yearOfWeek result must be an integer");
    return r;
   }
   function CalendarDaysInWeek(e, t){
    if("string" == typeof e){
     var _r26 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.daysInWeek%"),
              _r26,
              [t]);
    }
    var r = Call(GetMethod(e, "daysInWeek"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar daysInWeek result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar daysInWeek result must be a positive integer");
    return r;
   }
   function CalendarDaysInMonth(e, t){
    if("string" == typeof e){
     var _r27 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.daysInMonth%"),
              _r27,
              [t]);
    }
    var r = Call(GetMethod(e, "daysInMonth"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar daysInMonth result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar daysInMonth result must be a positive integer");
    return r;
   }
   function CalendarDaysInYear(e, t){
    if("string" == typeof e){
     var _r28 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.daysInYear%"),
              _r28,
              [t]);
    }
    var r = Call(GetMethod(e, "daysInYear"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar daysInYear result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar daysInYear result must be a positive integer");
    return r;
   }
   function CalendarMonthsInYear(e, t){
    if("string" == typeof e){
     var _r29 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.monthsInYear%"),
              _r29,
              [t]);
    }
    var r = Call(GetMethod(e, "monthsInYear"), e, [t]);
    if("number" != typeof r)
     throw new
            TypeError
            ("calendar monthsInYear result must be a positive integer");
    if(! IsIntegralNumber(r) || r < 1)
     throw new
            RangeError
            ("calendar monthsInYear result must be a positive integer");
    return r;
   }
   function CalendarInLeapYear(e, t){
    if("string" == typeof e){
     var _r30 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.inLeapYear%"),
              _r30,
              [t]);
    }
    var r = Call(GetMethod(e, "inLeapYear"), e, [t]);
    if("boolean" != typeof r)
     throw new TypeError("calendar inLeapYear result must be a boolean");
    return r;
   }
   function ToTemporalCalendarSlotValue(e){
    if(IsObject(e)){
     if(HasSlot(e, p)) return GetSlot(e, p);
     if
      (!
       function(e){
         return !
                !
                IsTemporalCalendar(e)
                ||
                 "dateAdd" in e && "dateFromFields" in e && "dateUntil" in e
                 && "day" in e
                 && "dayOfWeek" in e
                 && "dayOfYear" in e
                 && "daysInMonth" in e
                 && "daysInWeek" in e
                 && "daysInYear" in e
                 && "fields" in e
                 && "id" in e
                 && "inLeapYear" in e
                 && "mergeFields" in e
                 && "month" in e
                 && "monthCode" in e
                 && "monthDayFromFields" in e
                 && "monthsInYear" in e
                 && "weekOfYear" in e
                 && "year" in e
                 && "yearMonthFromFields" in e
                 && "yearOfWeek" in e;
        }
        (e))
      throw new
             TypeError
             ("expected a Temporal.Calendar or object implementing the Temporal.Calendar protocol");
     return e;
    }
    var t = ToString(e);
    if(IsBuiltinCalendar(t)) return ASCIILowercase(t);
    var r;
    try{
     var _ParseISODateTime5 = ParseISODateTime(t);
     r = _ParseISODateTime5.calendar;
    }
    catch(_unused4){
     try{
      var _ParseTemporalYearMon3 = ParseTemporalYearMonthString(t);
      r = _ParseTemporalYearMon3.calendar;
     }
     catch(_unused5){
      var _ParseTemporalMonthDa3 = ParseTemporalMonthDayString(t);
      r = _ParseTemporalMonthDa3.calendar;
     }
    }
    if(r || (r = "iso8601"), ! IsBuiltinCalendar(r))
     throw new RangeError("invalid calendar identifier ".concat(r));
    return ASCIILowercase(r);
   }
   function GetTemporalCalendarSlotValueWithISODefault(e){
    if(HasSlot(e, p)) return GetSlot(e, p);
    var t = e.calendar;
    return void 0 === t ? "iso8601" : ToTemporalCalendarSlotValue(t);
   }
   function ToTemporalCalendarIdentifier(e){
    if("string" == typeof e) return e;
    var t = e.id;
    if("string" != typeof t)
     throw new TypeError("calendar.id should be a string");
    return t;
   }
   function ToTemporalCalendarObject(e){
    if(IsObject(e)) return e;
    return new (GetIntrinsic("%Temporal.Calendar%"))(e);
   }
   function CalendarEquals(e, t){
    if(e === t) return ! 0;
    return ToTemporalCalendarIdentifier(e) === ToTemporalCalendarIdentifier(t);
   }
   function ThrowIfCalendarsNotEqual(e, t, r){
    if(e === t) return;
    var
     o = ToTemporalCalendarIdentifier(e),
     n = ToTemporalCalendarIdentifier(t);
    if(o !== n)
     throw new
            RangeError
            ("cannot ".concat(r, " of ").concat(o, " and ").concat
              (n, " calendars"));
   }
   function ConsolidateCalendars(e, t){
    if(e === t) return t;
    var
     r = ToTemporalCalendarIdentifier(e),
     o = ToTemporalCalendarIdentifier(t);
    if(r === o || "iso8601" === r) return t;
    if("iso8601" === o) return e;
    throw new RangeError("irreconcilable calendars");
   }
   function CalendarDateFromFields(e, t, r, o){
    if("string" == typeof e){
     var _o9 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.dateFromFields%"),
              _o9,
              [t, r]);
    }
    var
     n =
       Call
        (o !== null && o !== void 0 ? o : GetMethod(e, "dateFromFields"),
         e,
         [t, r]);
    if(! IsTemporalDate(n)) throw new TypeError("invalid result");
    return n;
   }
   function CalendarYearMonthFromFields(e, t, r){
    if("string" == typeof e){
     var _o10 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic
               ("%Temporal.Calendar.prototype.yearMonthFromFields%"),
              _o10,
              [t, r]);
    }
    var o = Call(GetMethod(e, "yearMonthFromFields"), e, [t, r]);
    if(! IsTemporalYearMonth(o)) throw new TypeError("invalid result");
    return o;
   }
   function CalendarMonthDayFromFields(e, t, r){
    if("string" == typeof e){
     var _o11 = new (GetIntrinsic("%Temporal.Calendar%"))(e);
     return Call
             (GetIntrinsic("%Temporal.Calendar.prototype.monthDayFromFields%"),
              _o11,
              [t, r]);
    }
    var o = Call(GetMethod(e, "monthDayFromFields"), e, [t, r]);
    if(! IsTemporalMonthDay(o)) throw new TypeError("invalid result");
    return o;
   }
   function ToTemporalTimeZoneSlotValue(e){
    if(IsObject(e)){
     if(IsTemporalZonedDateTime(e)) return GetSlot(e, g);
     if
      (!
       function(e){
         return !
                !
                IsTemporalTimeZone(e)
                ||
                 "getOffsetNanosecondsFor" in e
                 && "getPossibleInstantsFor" in e
                 && "id" in e;
        }
        (e))
      throw new
             TypeError
             ("expected a Temporal.TimeZone or object implementing the Temporal.TimeZone protocol");
     return e;
    }
    return ParseTemporalTimeZone(ToString(e));
   }
   function ToTemporalTimeZoneIdentifier(e){
    if("string" == typeof e) return e;
    var t = e.id;
    if("string" != typeof t)
     throw new TypeError("timeZone.id should be a string");
    return t;
   }
   function ToTemporalTimeZoneObject(e){
    if(IsObject(e)) return e;
    return new (GetIntrinsic("%Temporal.TimeZone%"))(e);
   }
   function TimeZoneEquals(e, t){
    if(e === t) return ! 0;
    return ToTemporalTimeZoneIdentifier(e) === ToTemporalTimeZoneIdentifier(t);
   }
   function TemporalDateTimeToDate(e){
    return CreateTemporalDate
            (GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(e, p));
   }
   function TemporalDateTimeToTime(e){
    return new
            (GetIntrinsic("%Temporal.PlainTime%"))
            (GetSlot(e, d),
             GetSlot(e, m),
             GetSlot(e, c),
             GetSlot(e, h),
             GetSlot(e, u),
             GetSlot(e, T));
   }
   function GetOffsetNanosecondsFor(e, t, r){
    if("string" == typeof e){
     var _r31 = new (GetIntrinsic("%Temporal.TimeZone%"))(e);
     return Call
             (GetIntrinsic
               ("%Temporal.TimeZone.prototype.getOffsetNanosecondsFor%"),
              _r31,
              [t]);
    }
    var
     o =
       Call
        (r !== null && r !== void 0
          ? r
          : GetMethod(e, "getOffsetNanosecondsFor"),
         e,
         [t]);
    if("number" != typeof o)
     throw new TypeError("bad return from getOffsetNanosecondsFor");
    if(! IsIntegralNumber(o) || ae(o) >= 864e11)
     throw new RangeError("out-of-range return from getOffsetNanosecondsFor");
    return o;
   }
   function GetOffsetStringFor(e, t){
    return FormatTimeZoneOffsetString(GetOffsetNanosecondsFor(e, t));
   }
   function GetPlainDateTimeFor(e, t, r){
    var
     _BalanceISODateTime2,
     o = GetSlot(t, n),
     a = GetOffsetNanosecondsFor(e, t),
     _GetISOPartsFromEpoch = GetISOPartsFromEpoch(o),
     i = _GetISOPartsFromEpoch.year,
     s = _GetISOPartsFromEpoch.month,
     l = _GetISOPartsFromEpoch.day,
     d = _GetISOPartsFromEpoch.hour,
     m = _GetISOPartsFromEpoch.minute,
     c = _GetISOPartsFromEpoch.second,
     h = _GetISOPartsFromEpoch.millisecond,
     u = _GetISOPartsFromEpoch.microsecond,
     T = _GetISOPartsFromEpoch.nanosecond;
    return _BalanceISODateTime2 =
            BalanceISODateTime(i, s, l, d, m, c, h, u, T + a),
           i = _BalanceISODateTime2.year,
           s = _BalanceISODateTime2.month,
           l = _BalanceISODateTime2.day,
           d = _BalanceISODateTime2.hour,
           m = _BalanceISODateTime2.minute,
           c = _BalanceISODateTime2.second,
           h = _BalanceISODateTime2.millisecond,
           u = _BalanceISODateTime2.microsecond,
           T = _BalanceISODateTime2.nanosecond,
           CreateTemporalDateTime(i, s, l, d, m, c, h, u, T, r);
   }
   function GetInstantFor(e, t, r){
    return DisambiguatePossibleInstants(GetPossibleInstantsFor(e, t), e, t, r);
   }
   function DisambiguatePossibleInstants(t, r, o, n){
    var a = GetIntrinsic("%Temporal.Instant%"), f = t.length;
    if(1 === f) return t[0];
    if(f)
     switch(n){
       case "compatible":
       case "earlier": return t[0];
       case "later":
        return t[f - 1];
       case "reject":
        throw new RangeError("multiple instants found");
     }
    var
     y = GetSlot(o, i),
     I = GetSlot(o, s),
     S = GetSlot(o, l),
     g = GetSlot(o, d),
     w = GetSlot(o, m),
     D = GetSlot(o, c),
     G = GetSlot(o, h),
     v = GetSlot(o, u),
     C = GetSlot(o, T),
     O = GetUTCEpochNanoseconds(y, I, S, g, w, D, G, v, C);
    if(null === O)
     throw new RangeError("DateTime outside of supported range");
    var
     b = new a(O - Ee),
     E = new a(O + Ee),
     M = GetOffsetNanosecondsFor(r, b),
     R = GetOffsetNanosecondsFor(r, E) - M;
    switch(n){
      case "earlier":
       {
        var
         _e18 = GetSlot(o, p),
         _t19 = GetIntrinsic("%Temporal.PlainDateTime%"),
         _n7 =
           AddDateTime
            (y,
             I,
             S,
             g,
             w,
             D,
             G,
             v,
             C,
             _e18,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             - R,
             void 0);
        return GetPossibleInstantsFor
                 (r,
                  new
                   _t19
                   (_n7.year,
                    _n7.month,
                    _n7.day,
                    _n7.hour,
                    _n7.minute,
                    _n7.second,
                    _n7.millisecond,
                    _n7.microsecond,
                    _n7.nanosecond,
                    _e18))
                [0];
       }
      case "compatible":
      case "later":
       {
        var
         _e19 = GetSlot(o, p),
         _t20 = GetIntrinsic("%Temporal.PlainDateTime%"),
         _n8 =
           AddDateTime
            (y,
             I,
             S,
             g,
             w,
             D,
             G,
             v,
             C,
             _e19,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             R,
             void 0),
         _a4 =
           GetPossibleInstantsFor
            (r,
             new
              _t20
              (_n8.year,
               _n8.month,
               _n8.day,
               _n8.hour,
               _n8.minute,
               _n8.second,
               _n8.millisecond,
               _n8.microsecond,
               _n8.nanosecond,
               _e19));
        return _a4[_a4.length - 1];
       }
      case "reject":
       throw new RangeError("no such instant found");
    }
   }
   function GetPossibleInstantsFor(e, t, r){
    if("string" == typeof e){
     var _r32 = new (GetIntrinsic("%Temporal.TimeZone%"))(e);
     return Call
             (GetIntrinsic
               ("%Temporal.TimeZone.prototype.getPossibleInstantsFor%"),
              _r32,
              [t]);
    }
    var
     o =
       Call
        (r !== null && r !== void 0
          ? r
          : GetMethod(e, "getPossibleInstantsFor"),
         e,
         [t]),
     n = [],
     _iterator13 = _createForOfIteratorHelper(o),
     _step13;
    try{
     for(_iterator13.s(); ! (_step13 = _iterator13.n()).done;){
      var _e20 = _step13.value;
      if(! IsTemporalInstant(_e20))
       throw new TypeError("bad return from getPossibleInstantsFor");
      te.call(n, _e20);
     }
    }
    catch(err){_iterator13.e(err);}
    finally{_iterator13.f();}
    return n;
   }
   function ISOYearString(e){
    var t;
    if(e < 0 || e > 9999)
     t = (e < 0 ? "-" : "+") + "000000".concat(ae(e)).slice(- 6);
    else
     t = "0000".concat(e).slice(- 4);
    return t;
   }
   function ISODateTimePartString(e){return "00".concat(e).slice(- 2);}
   function FormatSecondsStringPart(e, t, r, o, n){
    if("minute" === n) return "";
    var
     a = ":".concat(ISODateTimePartString(e)),
     i,
     s = 1e6 * t + 1e3 * r + o;
    if("auto" === n){
     if(0 === s) return a;
     for(i = "".concat(s).padStart(9, "0"); "0" === i[i.length - 1];)
      i = i.slice(0, - 1);
    }
    else{if(0 === n) return a; i = "".concat(s).padStart(9, "0").slice(0, n);}
    return "".concat(a, ".").concat(i);
   }
   function TemporalInstantToString(e, t, r){
    var o = t;
    void 0 === o && (o = "UTC");
    var
     n = GetPlainDateTimeFor(o, e, "iso8601"),
     a = ISOYearString(GetSlot(n, i)),
     p = ISODateTimePartString(GetSlot(n, s)),
     f = ISODateTimePartString(GetSlot(n, l)),
     y = ISODateTimePartString(GetSlot(n, d)),
     I = ISODateTimePartString(GetSlot(n, m)),
     S =
       FormatSecondsStringPart
        (GetSlot(n, c), GetSlot(n, h), GetSlot(n, u), GetSlot(n, T), r),
     g = "Z";
    if(void 0 !== t)
     g = FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(o, e));
    return "".concat(a, "-").concat(p, "-").concat(f, "T").concat(y, ":").concat
              (I).concat
             (S).concat
            (g);
   }
   function TemporalDurationToString(t){
    var
     _divmod,
     _divmod2,
     _divmod3,
     r =
       arguments.length > 1 && arguments[1] !== undefined
        ? arguments[1]
        : "auto",
     o = arguments.length > 2 ? arguments[2] : undefined;
    function formatNumber(t){
     return t <= ue ? t.toString(10) : BigInt(t).toString(10);
    }
    var
     n = GetSlot(t, w),
     a = GetSlot(t, D),
     i = GetSlot(t, G),
     s = GetSlot(t, v),
     l = GetSlot(t, C),
     d = GetSlot(t, O),
     m = GetSlot(t, b),
     c = GetSlot(t, E),
     h = GetSlot(t, M),
     u = GetSlot(t, R),
     T = DurationSign(n, a, i, s, l, d, m, c, h, u);
    if(o){
     var
      _e21 = o.unit,
      _t21 = o.increment,
      _r33 = o.roundingMode,
      _RoundDuration =
        RoundDuration(0, 0, 0, 0, 0, 0, m, c, h, u, _t21, _e21, _r33);
     m = _RoundDuration.seconds;
     c = _RoundDuration.milliseconds;
     h = _RoundDuration.microseconds;
     u = _RoundDuration.nanoseconds;
    }
    var p = [];
    n && p.push("".concat(formatNumber(ae(n)), "Y")),
    a && p.push("".concat(formatNumber(ae(a)), "M")),
    i && p.push("".concat(formatNumber(ae(i)), "W")),
    s && p.push("".concat(formatNumber(ae(s)), "D"));
    var f = [];
    l && f.push("".concat(formatNumber(ae(l)), "H")),
    d && f.push("".concat(formatNumber(ae(d)), "M"));
    var
     y = [],
     I,
     S,
     g,
     F,
     Y = TotalDurationNanoseconds(0, 0, 0, m, c, h, u, 0);
    _divmod = divmod(Y, De),
    Y = _divmod.quotient,
    I = _divmod.remainder,
    _divmod2 = divmod(Y, De),
    Y = _divmod2.quotient,
    S = _divmod2.remainder,
    _divmod3 = divmod(Y, De),
    F = _divmod3.quotient,
    g = _divmod3.remainder;
    var P = 1e6 * ae(Number(g)) + 1e3 * ae(Number(S)) + ae(Number(I)), Z;
    if("auto" === r){
     if(0 !== P)
      for(Z = "".concat(P).padStart(9, "0"); "0" === Z[Z.length - 1];)
       Z = Z.slice(0, - 1);
    }
    else
     0 !== r && (Z = "".concat(P).padStart(9, "0").slice(0, r));
    return Z && y.unshift(".", Z),
           F === Ie && ! y.length && "auto" === r
           || y.unshift(abs(F).toString()),
           y.length && f.push("".concat(y.join(""), "S")),
           f.length && f.unshift("T"),
           p.length || f.length
            ? "".concat
                (T < 0 ? "-" : "", "P").concat
               (p.join("")).concat
              (f.join(""))
            : "PT0S";
   }
   function TemporalDateToString(e){
    var
     t =
       arguments.length > 1 && arguments[1] !== undefined
        ? arguments[1]
        : "auto";
    return "".concat(ISOYearString(GetSlot(e, i)), "-").concat
              (ISODateTimePartString(GetSlot(e, s)), "-").concat
             (ISODateTimePartString(GetSlot(e, l))).concat
            (MaybeFormatCalendarAnnotation(GetSlot(e, p), t));
   }
   function TemporalDateTimeToString(e, t){
    var
     r =
       arguments.length > 2 && arguments[2] !== undefined
        ? arguments[2]
        : "auto",
     o = arguments.length > 3 ? arguments[3] : undefined,
     n = GetSlot(e, i),
     a = GetSlot(e, s),
     f = GetSlot(e, l),
     y = GetSlot(e, d),
     I = GetSlot(e, m),
     S = GetSlot(e, c),
     g = GetSlot(e, h),
     w = GetSlot(e, u),
     D = GetSlot(e, T);
    if(o){
     var
      _e22 = o.unit,
      _t22 = o.increment,
      _r34 = o.roundingMode,
      _RoundISODateTime =
        RoundISODateTime(n, a, f, y, I, S, g, w, D, _t22, _e22, _r34);
     n = _RoundISODateTime.year;
     a = _RoundISODateTime.month;
     f = _RoundISODateTime.day;
     y = _RoundISODateTime.hour;
     I = _RoundISODateTime.minute;
     S = _RoundISODateTime.second;
     g = _RoundISODateTime.millisecond;
     w = _RoundISODateTime.microsecond;
     D = _RoundISODateTime.nanosecond;
    }
    return "".concat(ISOYearString(n), "-").concat
                 (ISODateTimePartString(a), "-").concat
                (ISODateTimePartString(f), "T").concat
               (ISODateTimePartString(y), ":").concat
              (ISODateTimePartString(I)).concat
             (FormatSecondsStringPart(S, g, w, D, t)).concat
            (MaybeFormatCalendarAnnotation(GetSlot(e, p), r));
   }
   function TemporalMonthDayToString(e){
    var
     t =
       arguments.length > 1 && arguments[1] !== undefined
        ? arguments[1]
        : "auto",
     r =
       "".concat(ISODateTimePartString(GetSlot(e, s)), "-").concat
        (ISODateTimePartString(GetSlot(e, l))),
     o = ToTemporalCalendarIdentifier(GetSlot(e, p));
    if("always" === t || "critical" === t || "iso8601" !== o)
     r = "".concat(ISOYearString(GetSlot(e, i)), "-").concat(r);
    var n = FormatCalendarAnnotation(o, t);
    return n && (r += n), r;
   }
   function TemporalYearMonthToString(e){
    var
     t =
       arguments.length > 1 && arguments[1] !== undefined
        ? arguments[1]
        : "auto",
     r =
       "".concat(ISOYearString(GetSlot(e, i)), "-").concat
        (ISODateTimePartString(GetSlot(e, s))),
     o = ToTemporalCalendarIdentifier(GetSlot(e, p));
    if("always" === t || "critical" === t || "iso8601" !== o)
     r += "-".concat(ISODateTimePartString(GetSlot(e, l)));
    var n = FormatCalendarAnnotation(o, t);
    return n && (r += n), r;
   }
   function TemporalZonedDateTimeToString(e, t){
    var
     r =
       arguments.length > 2 && arguments[2] !== undefined
        ? arguments[2]
        : "auto",
     o =
       arguments.length > 3 && arguments[3] !== undefined
        ? arguments[3]
        : "auto",
     a =
       arguments.length > 4 && arguments[4] !== undefined
        ? arguments[4]
        : "auto",
     f = arguments.length > 5 ? arguments[5] : undefined,
     y = GetSlot(e, S);
    if(f){
     var
      _t23 = f.unit,
      _r35 = f.increment,
      _o12 = f.roundingMode,
      _a5 = RoundInstant(GetSlot(e, n), _r35, _t23, _o12);
     y = new (GetIntrinsic("%Temporal.Instant%"))(_a5);
    }
    var
     I = GetSlot(e, g),
     w = GetPlainDateTimeFor(I, y, "iso8601"),
     D =
       "".concat(ISOYearString(GetSlot(w, i)), "-").concat
            (ISODateTimePartString(GetSlot(w, s)), "-").concat
           (ISODateTimePartString(GetSlot(w, l)), "T").concat
          (ISODateTimePartString(GetSlot(w, d)), ":").concat
         (ISODateTimePartString(GetSlot(w, m))).concat
        (FormatSecondsStringPart
          (GetSlot(w, c), GetSlot(w, h), GetSlot(w, u), GetSlot(w, T), t));
    if("never" !== a)
     D += FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(I, y));
    if("never" !== o)
     D +=
      "[".concat("critical" === o ? "!" : "").concat
       (ToTemporalTimeZoneIdentifier(I), "]");
    return D += MaybeFormatCalendarAnnotation(GetSlot(e, p), r), D;
   }
   function IsTimeZoneOffsetString(e){return ze.test(he(e));}
   function ParseTimeZoneOffsetString(e){
    var t = ze.exec(he(e));
    if(! t) throw new RangeError("invalid time zone offset: ".concat(e));
    return ("-" === t[1] || "" === t[1] ? - 1 : 1)
           *
            (1e9 * (60 * (60 * + t[2] + + (t[3] || 0)) + + (t[4] || 0))
            + + ((t[5] || 0) + "000000000").slice(0, 9));
   }
   function GetCanonicalTimeZoneIdentifier(e){
    if(IsTimeZoneOffsetString(e))
     return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(e));
    return getIntlDateTimeFormatEnUsForTimeZone(he(e)).resolvedOptions().timeZone;
   }
   function GetNamedTimeZoneOffsetNanoseconds(t, r){
    var
     _GetNamedTimeZoneDate = GetNamedTimeZoneDateTimeParts(t, r),
     o = _GetNamedTimeZoneDate.year,
     n = _GetNamedTimeZoneDate.month,
     a = _GetNamedTimeZoneDate.day,
     i = _GetNamedTimeZoneDate.hour,
     s = _GetNamedTimeZoneDate.minute,
     l = _GetNamedTimeZoneDate.second,
     d = _GetNamedTimeZoneDate.millisecond,
     m = _GetNamedTimeZoneDate.microsecond,
     c = _GetNamedTimeZoneDate.nanosecond,
     h = o % 400,
     u = (o - h) / 400,
     T = 146097n * Ee,
     p = GetUTCEpochNanoseconds(h, n, a, i, s, l, d, m, c),
     f = p + T * BigInt(u);
    return Number(f - r);
   }
   function FormatTimeZoneOffsetString(e){
    var
     t = e < 0 ? "-" : "+",
     r = ae(e),
     o = r % 1e9,
     n = ie(r / 1e9) % 60,
     a = ie(r / 6e10) % 60,
     i = ISODateTimePartString(ie(r / 36e11)),
     s = ISODateTimePartString(a),
     l = ISODateTimePartString(n),
     d = "";
    if(o){
     var _e23 = "".concat(o).padStart(9, "0");
     for(; "0" === _e23[_e23.length - 1];) _e23 = _e23.slice(0, - 1);
     d = ":".concat(l, ".").concat(_e23);
    }
    else
     n && (d = ":".concat(l));
    return "".concat(t).concat(i, ":").concat(s).concat(d);
   }
   function FormatISOTimeZoneOffsetString(t){
    var
     r = Number(RoundNumberToIncrement(BigInt(t), be, "halfExpand")),
     o = r < 0 ? "-" : "+";
    r = ae(r);
    var n = r / 6e10 % 60;
    return "".concat(o).concat(ISODateTimePartString(ie(r / 36e11)), ":").concat
            (ISODateTimePartString(n));
   }
   function GetUTCEpochNanoseconds(t, r, o, n, a, i, s, l, d){
    var m = new Date();
    m.setUTCHours(n, a, i, s), m.setUTCFullYear(t, r - 1, o);
    var c = m.getTime();
    if(de(c)) return null;
    var h = BigInt(c) * Ge;
    return h = h + BigInt(l) * De,
           h = h + BigInt(d),
           h < Me || h > Re ? null : h;
   }
   function GetISOPartsFromEpoch(t){
    var
     _divmod4 = divmod(t, Ge),
     r = _divmod4.quotient,
     o = _divmod4.remainder,
     n = Number(r),
     a = Number(o);
    a < 0 && (a += 1e6, n -= 1);
    var i = ie(a / 1e3) % 1e3, s = a % 1e3, l = new Date(n);
    return {epochMilliseconds: n,
            year: l.getUTCFullYear(),
            month: l.getUTCMonth() + 1,
            day: l.getUTCDate(),
            hour: l.getUTCHours(),
            minute: l.getUTCMinutes(),
            second: l.getUTCSeconds(),
            millisecond: l.getUTCMilliseconds(),
            microsecond: i,
            nanosecond: s};
   }
   function GetNamedTimeZoneDateTimeParts(e, t){
    var
     _GetISOPartsFromEpoch2 = GetISOPartsFromEpoch(t),
     r = _GetISOPartsFromEpoch2.epochMilliseconds,
     o = _GetISOPartsFromEpoch2.millisecond,
     n = _GetISOPartsFromEpoch2.microsecond,
     a = _GetISOPartsFromEpoch2.nanosecond,
     _GetFormatterParts =
       function(e, t){
         var r = getIntlDateTimeFormatEnUsForTimeZone(e).format(new Date(t));
         return function(e){
                  var t = e.split(/[^\w]+/);
                  if(7 !== t.length)
                   throw new RangeError('expected 7 parts in "'.concat(e));
                  var
                   r = + t[0],
                   o = + t[1],
                   n = + t[2],
                   a = t[3].toUpperCase();
                  if("B" === a || "BC" === a)
                   n = 1 - n;
                  else if("A" !== a && "AD" !== a)
                   throw new
                          RangeError
                          ("Unknown era ".concat(a, ' in "').concat(e));
                  var i = + t[4];
                  24 === i && (i = 0);
                  var s = + t[5], l = + t[6];
                  if(! (me(n) && me(r) && me(o) && me(i) && me(s) && me(l)))
                   throw new RangeError('Invalid number in "'.concat(e));
                  return {year: n,
                          month: r,
                          day: o,
                          hour: i,
                          minute: s,
                          second: l};
                 }
                 (r);
        }
        (e, r),
     i = _GetFormatterParts.year,
     s = _GetFormatterParts.month,
     l = _GetFormatterParts.day,
     d = _GetFormatterParts.hour,
     m = _GetFormatterParts.minute,
     c = _GetFormatterParts.second;
    return BalanceISODateTime(i, s, l, d, m, c, o, n, a);
   }
   function maxJSBI(t, r){return t < r ? r : t;}
   function afterLatestPossibleTzdbRuleChange(){return Ve() + Ze;}
   function GetNamedTimeZoneNextTransition(t, r){
    if(r < Pe) return GetNamedTimeZoneNextTransition(t, Pe);
    var
     o = r + Be,
     n = maxJSBI(afterLatestPossibleTzdbRuleChange(), o),
     a = maxJSBI(Pe, r),
     i = GetNamedTimeZoneOffsetNanoseconds(t, a),
     s = a,
     l = i;
    for(; i === l && BigInt(a) < n;){
     if(s = a + Ne, s > Re) return null;
     l = GetNamedTimeZoneOffsetNanoseconds(t, s), i === l && (a = s);
    }
    if(i === l) return null;
    return bisect
            (function(e){return GetNamedTimeZoneOffsetNanoseconds(t, e);},
             a,
             s,
             i,
             l);
   }
   function GetNamedTimeZonePreviousTransition(t, r){
    var
     o = afterLatestPossibleTzdbRuleChange(),
     a = r > o,
     i = a ? r - Be : Pe;
    if("Africa/Casablanca" === t || "Africa/El_Aaiun" === t){
     var _o13 = GetSlot(ToTemporalInstant("2088-01-01T00Z"), n);
     if(_o13 < r) return GetNamedTimeZonePreviousTransition(t, _o13);
    }
    var s = r - Se;
    if(s < Pe) return null;
    var l = GetNamedTimeZoneOffsetNanoseconds(t, s), d = s, m = l;
    for(; l === m && s > i;){
     if(d = s - Ne, d < Pe) return null;
     m = GetNamedTimeZoneOffsetNanoseconds(t, d), l === m && (s = d);
    }
    if(l === m){
     if(a){
      var _r36 = o - Ee;
      return GetNamedTimeZonePreviousTransition(t, _r36);
     }
     return null;
    }
    return bisect
            (function(e){return GetNamedTimeZoneOffsetNanoseconds(t, e);},
             d,
             s,
             m,
             l);
   }
   function LeapYear(e){
    if(void 0 === e) return ! 1;
    return e % 4 == 0 && (! (e % 100 == 0) || e % 400 == 0);
   }
   function ISODaysInMonth(e, t){
    return {standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
              leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]}
             [LeapYear(e) ? "leapyear" : "standard"]
            [t - 1];
   }
   function DayOfWeek(e, t, r){
    var
     o = t + (t < 3 ? 10 : - 2),
     n = e - (t < 3 ? 1 : 0),
     a = ie(n / 100),
     i = n - 100 * a,
     s = (r + ie(2.6 * o - .2) + (i + ie(i / 4)) + (ie(a / 4) - 2 * a)) % 7;
    return s + (s <= 0 ? 7 : 0);
   }
   function DayOfYear(e, t, r){
    var o = r;
    for(var _r37 = t - 1; _r37 > 0; _r37--) o += ISODaysInMonth(e, _r37);
    return o;
   }
   function WeekOfYear(e, t, r){
    var
     o = DayOfYear(e, t, r),
     n = DayOfWeek(e, t, r) || 7,
     a = DayOfWeek(e, 1, 1),
     i = ie((o - n + 10) / 7);
    return i < 1
            ? 5
              === a
              || 6 === a && LeapYear(e - 1)
              ? {week: 53, year: e - 1}
              : {week: 52, year: e - 1}
            : 53
              === i
              && (LeapYear(e) ? 366 : 365) - o < 4 - n
              ? {week: 1, year: e + 1}
              : {week: i, year: e};
   }
   function DurationSign(e, t, r, o, n, a, i, s, l, d){
    for
    (var _i7 = 0, _arr2 = [e, t, r, o, n, a, i, s, l, d];
     _i7 < _arr2.length;
     _i7++){var _m2 = _arr2[_i7]; if(0 !== _m2) return _m2 < 0 ? - 1 : 1;}
    return 0;
   }
   function BalanceISOYearMonth(e, t){
    var r = e, o = t;
    if(! me(r) || ! me(o)) throw new RangeError("infinity is out of range");
    return o -= 1,
           r += ie(o / 12),
           o %= 12,
           o < 0 && (o += 12),
           o += 1,
           {year: r, month: o};
   }
   function BalanceISODate(e, t, r){
    var o = e, n = t, a = r;
    if(! me(a)) throw new RangeError("infinity is out of range");
    var _BalanceISOYearMonth = BalanceISOYearMonth(o, n);
    o = _BalanceISOYearMonth.year;
    n = _BalanceISOYearMonth.month;
    var i = 146097;
    if(ae(a) > i){var _e24 = le(a / i); o += 400 * _e24, a -= _e24 * i;}
    var s = 0, l = n > 2 ? o : o - 1;
    for(; s = LeapYear(l) ? 366 : 365, a < - s;) o -= 1, l -= 1, a += s;
    for(l += 1; s = LeapYear(l) ? 366 : 365, a > s;) o += 1, l += 1, a -= s;
    for(; a < 1;){
     var _BalanceISOYearMonth2;
     _BalanceISOYearMonth2 = BalanceISOYearMonth(o, n - 1),
     o = _BalanceISOYearMonth2.year,
     n = _BalanceISOYearMonth2.month,
     a += ISODaysInMonth(o, n);
    }
    for(; a > ISODaysInMonth(o, n);){
     var _BalanceISOYearMonth3;
     a -= ISODaysInMonth(o, n),
     _BalanceISOYearMonth3 = BalanceISOYearMonth(o, n + 1),
     o = _BalanceISOYearMonth3.year,
     n = _BalanceISOYearMonth3.month;
    }
    return {year: o, month: n, day: a};
   }
   function BalanceISODateTime(e, t, r, o, n, a, i, s, l){
    var
     _BalanceTime = BalanceTime(o, n, a, i, s, l),
     d = _BalanceTime.deltaDays,
     m = _BalanceTime.hour,
     c = _BalanceTime.minute,
     h = _BalanceTime.second,
     u = _BalanceTime.millisecond,
     T = _BalanceTime.microsecond,
     p = _BalanceTime.nanosecond,
     _BalanceISODate = BalanceISODate(e, t, r + d),
     f = _BalanceISODate.year,
     y = _BalanceISODate.month,
     I = _BalanceISODate.day;
    return {year: f,
            month: y,
            day: I,
            hour: m,
            minute: c,
            second: h,
            millisecond: u,
            microsecond: T,
            nanosecond: p};
   }
   function BalanceTime(t, r, o, n, a, i){
    var
     _NonNegativeBigIntDiv,
     _NonNegativeBigIntDiv2,
     _NonNegativeBigIntDiv3,
     _NonNegativeBigIntDiv4,
     _NonNegativeBigIntDiv5,
     _NonNegativeBigIntDiv6,
     s,
     l = BigInt(t),
     d = BigInt(r),
     m = BigInt(o),
     c = BigInt(n),
     h = BigInt(a),
     u = BigInt(i);
    return _NonNegativeBigIntDiv = NonNegativeBigIntDivmod(u, De),
           s = _NonNegativeBigIntDiv.quotient,
           u = _NonNegativeBigIntDiv.remainder,
           h = h + s,
           _NonNegativeBigIntDiv2 = NonNegativeBigIntDivmod(h, De),
           s = _NonNegativeBigIntDiv2.quotient,
           h = _NonNegativeBigIntDiv2.remainder,
           c = c + s,
           _NonNegativeBigIntDiv3 = NonNegativeBigIntDivmod(c, De),
           s = _NonNegativeBigIntDiv3.quotient,
           c = _NonNegativeBigIntDiv3.remainder,
           m = m + s,
           _NonNegativeBigIntDiv4 = NonNegativeBigIntDivmod(m, ge),
           s = _NonNegativeBigIntDiv4.quotient,
           m = _NonNegativeBigIntDiv4.remainder,
           d = d + s,
           _NonNegativeBigIntDiv5 = NonNegativeBigIntDivmod(d, ge),
           s = _NonNegativeBigIntDiv5.quotient,
           d = _NonNegativeBigIntDiv5.remainder,
           l = l + s,
           _NonNegativeBigIntDiv6 = NonNegativeBigIntDivmod(l, we),
           s = _NonNegativeBigIntDiv6.quotient,
           l = _NonNegativeBigIntDiv6.remainder,
           {deltaDays: Number(s),
            hour: Number(l),
            minute: Number(d),
            second: Number(m),
            millisecond: Number(c),
            microsecond: Number(h),
            nanosecond: Number(u)};
   }
   function TotalDurationNanoseconds(t, r, o, n, a, i, s, l){
    var d = BigInt(t), m = BigInt(s);
    0 !== t && (m = BigInt(s) - BigInt(l));
    var
     c = BigInt(r) + d * 24n,
     h = BigInt(o) + c * ge,
     u = BigInt(n) + h * ge,
     T = BigInt(a) + u * De,
     p = BigInt(i) + T * De;
    return BigInt(m) + p * De;
   }
   function NanosecondsToDays(t, r){
    var
     o = GetIntrinsic("%Temporal.Instant%"),
     a = se(Number(t)),
     f = BigInt(t),
     y = 864e11;
    if(0 === a) return {days: 0, nanoseconds: Ie, dayLengthNs: y};
    if(! IsTemporalZonedDateTime(r)){
     var _divmod5, _t24;
     return _divmod5 = divmod(f, BigInt(y)),
            _t24 = _divmod5.quotient,
            f = _divmod5.remainder,
            {days: Number(_t24), nanoseconds: f, dayLengthNs: y};
    }
    var
     I = GetSlot(r, n),
     w = GetSlot(r, S),
     D = I + f,
     G = new o(D),
     v = GetSlot(r, g),
     C = GetSlot(r, p),
     O = GetPlainDateTimeFor(v, w, C),
     b = GetPlainDateTimeFor(v, G, C),
     _DifferenceISODateTim =
       DifferenceISODateTime
        (GetSlot(O, i),
         GetSlot(O, s),
         GetSlot(O, l),
         GetSlot(O, d),
         GetSlot(O, m),
         GetSlot(O, c),
         GetSlot(O, h),
         GetSlot(O, u),
         GetSlot(O, T),
         GetSlot(b, i),
         GetSlot(b, s),
         GetSlot(b, l),
         GetSlot(b, d),
         GetSlot(b, m),
         GetSlot(b, c),
         GetSlot(b, h),
         GetSlot(b, u),
         GetSlot(b, T),
         C,
         "day",
         Te(null)),
     E = _DifferenceISODateTim.days,
     M = AddZonedDateTime(w, v, C, 0, 0, 0, E, 0, 0, 0, 0, 0, 0),
     R = BigInt(E);
    if(1 === a)
     for(; R > Ie && M > D;)
      R = R - Se,
      M = AddZonedDateTime(w, v, C, 0, 0, 0, Number(R), 0, 0, 0, 0, 0, 0);
    f = D - M;
    var F = ! 1, Y = new o(M);
    do{
     var
      _t25 = AddZonedDateTime(Y, v, C, 0, 0, 0, a, 0, 0, 0, 0, 0, 0),
      _r38 = GetSlot(Y, n);
     y = Number(_t25 - _r38),
     F = (f - BigInt(y)) * BigInt(a) >= Ie,
     F && (f = f - BigInt(y), Y = new o(_t25), R = R + BigInt(a));
    }
    while
     (F);
    if(! isZero(R) && signJSBI(R) !== a)
     throw new
            RangeError
            ("Time zone or calendar converted nanoseconds into a number of days with the opposite sign");
    if(! isZero(f) && signJSBI(f) !== a){
     if(isNegativeJSBI(f) && 1 === a) throw new Error("assert not reached");
     throw new
            RangeError
            ("Time zone or calendar ended up with a remainder of nanoseconds with the opposite sign");
    }
    if(abs(f) >= abs(BigInt(y))) throw new Error("assert not reached");
    return {days: Number(R), nanoseconds: f, dayLengthNs: ae(y)};
   }
   function BalanceDuration(e, t, r, o, n, a, i, s, l){
    var d = BalancePossiblyInfiniteDuration(e, t, r, o, n, a, i, s, l);
    if("positive overflow" === d || "negative overflow" === d)
     throw new RangeError("Duration out of range");
    return d;
   }
   function BalancePossiblyInfiniteDuration(t, r, o, a, i, s, l, d, m){
    var
     _NanosecondsToDays,
     _divmod6,
     _divmod7,
     _divmod8,
     _divmod9,
     _divmod10,
     _divmod11,
     _divmod12,
     _divmod13,
     _divmod14,
     _divmod15,
     _divmod16,
     _divmod17,
     _divmod18,
     _divmod19,
     c,
     h,
     u,
     T,
     f,
     y,
     I = t;
    if(IsTemporalZonedDateTime(m)){
     var
      _t26 =
        AddZonedDateTime
         (GetSlot(m, S),
          GetSlot(m, g),
          GetSlot(m, p),
          0,
          0,
          0,
          I,
          r,
          o,
          a,
          i,
          s,
          l),
      _d = GetSlot(m, n);
     c = _t26 - _d;
    }
    else
     c = TotalDurationNanoseconds(I, r, o, a, i, s, l, 0);
    "year" === d || "month" === d || "week" === d || "day" === d
     ? (_NanosecondsToDays
       = NanosecondsToDays(c, m),
       I = _NanosecondsToDays.days,
       c = _NanosecondsToDays.nanoseconds,
       _NanosecondsToDays)
     : I = 0;
    var w = c < Ie ? - 1 : 1;
    switch(c = abs(c), h = u = T = f = y = Ie, d){
      case "year":
      case "month":
      case "week":
      case "day":
      case "hour":
       _divmod6 = divmod(c, De),
       h = _divmod6.quotient,
       c = _divmod6.remainder,
       _divmod7 = divmod(h, De),
       u = _divmod7.quotient,
       h = _divmod7.remainder,
       _divmod8 = divmod(u, De),
       T = _divmod8.quotient,
       u = _divmod8.remainder,
       _divmod9 = divmod(T, ge),
       f = _divmod9.quotient,
       T = _divmod9.remainder,
       _divmod10 = divmod(f, ge),
       y = _divmod10.quotient,
       f = _divmod10.remainder;
       break;
      case "minute":
       _divmod11 = divmod(c, De),
       h = _divmod11.quotient,
       c = _divmod11.remainder,
       _divmod12 = divmod(h, De),
       u = _divmod12.quotient,
       h = _divmod12.remainder,
       _divmod13 = divmod(u, De),
       T = _divmod13.quotient,
       u = _divmod13.remainder,
       _divmod14 = divmod(T, ge),
       f = _divmod14.quotient,
       T = _divmod14.remainder;
       break;
      case "second":
       _divmod15 = divmod(c, De),
       h = _divmod15.quotient,
       c = _divmod15.remainder,
       _divmod16 = divmod(h, De),
       u = _divmod16.quotient,
       h = _divmod16.remainder,
       _divmod17 = divmod(u, De),
       T = _divmod17.quotient,
       u = _divmod17.remainder;
       break;
      case "millisecond":
       _divmod18 = divmod(c, De),
       h = _divmod18.quotient,
       c = _divmod18.remainder,
       _divmod19 = divmod(h, De),
       u = _divmod19.quotient,
       h = _divmod19.remainder;
       break;
      case "microsecond":
       var _divmod20 = divmod(c, De);
       h = _divmod20.quotient;
       c = _divmod20.remainder;
       break;
      case "nanosecond": break;
      default: throw new Error("assert not reached");
    }
    var
     D = Number(y) * w,
     G = Number(f) * w,
     v = Number(T) * w,
     C = Number(u) * w,
     O = Number(h) * w,
     b = Number(c) * w;
    for(var _i8 = 0, _arr3 = [I, D, G, v, C, O, b]; _i8 < _arr3.length; _i8++){
     var _e25 = _arr3[_i8];
     if(! me(_e25))
      return 1 === w ? "positive overflow" : "negative overflow";
    }
    return {days: I,
            hours: D,
            minutes: G,
            seconds: v,
            milliseconds: C,
            microseconds: O,
            nanoseconds: b};
   }
   function UnbalanceDurationRelative(t, r, o, n, a, i){
    var
     s = GetIntrinsic("%Temporal.Duration%"),
     l = DurationSign(t, r, o, n, 0, 0, 0, 0, 0, 0);
    if(0 === l) return {years: t, months: r, weeks: o, days: n};
    var
     d = BigInt(l),
     m,
     c,
     h = BigInt(t),
     u = BigInt(r),
     T = BigInt(o),
     f = BigInt(n);
    i && (c = ToTemporalDate(i), m = GetSlot(c, p));
    var y = new s(l), I = new s(0, l), S = new s(0, 0, l);
    switch(a){
      case "year": break;
      case "month":
       {
        if(! m)
         throw new
                RangeError
                ("a starting point is required for months balancing");
        var _t27, _r39;
        for
        ("string" != typeof m
         && (_t27 = GetMethod(m, "dateAdd"), _r39 = GetMethod(m, "dateUntil"));
         !
         isZero(h);){
         var _o14 = CalendarDateAdd(m, c, y, void 0, _t27), _n9 = Te(null);
         _n9.largestUnit = "month";
         var
          _a6 = CalendarDateUntil(m, c, _o14, _n9, _r39),
          _i9 = BigInt(GetSlot(_a6, D));
         c = _o14, u = u + _i9, h = h - d;
        }
       }
       break;
      case "week":
       {
        if(! m)
         throw new
                RangeError
                ("a starting point is required for weeks balancing");
        var _t28 = "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
        for(; ! isZero(h);){
         var _MoveRelativeDate, _r40 = void 0;
         _MoveRelativeDate = MoveRelativeDate(m, c, y, _t28),
         c = _MoveRelativeDate.relativeTo,
         _r40 = _MoveRelativeDate.days,
         f = f + BigInt(_r40),
         h = h - d;
        }
        for(; ! isZero(u);){
         var _MoveRelativeDate2, _r41 = void 0;
         _MoveRelativeDate2 = MoveRelativeDate(m, c, I, _t28),
         c = _MoveRelativeDate2.relativeTo,
         _r41 = _MoveRelativeDate2.days,
         f = f + BigInt(_r41),
         u = u - d;
        }
        break;
       }
      default:
       {
        if(isZero(h) && isZero(u) && isZero(T)) break;
        if(! m)
         throw new
                RangeError
                ("a starting point is required for balancing calendar units");
        var _t29 = "string" != typeof m ? GetMethod(m, "dateAdd") : void 0;
        for(; ! isZero(h);){
         var _MoveRelativeDate3, _r42 = void 0;
         _MoveRelativeDate3 = MoveRelativeDate(m, c, y, _t29),
         c = _MoveRelativeDate3.relativeTo,
         _r42 = _MoveRelativeDate3.days,
         f = f + BigInt(_r42),
         h = h - d;
        }
        for(; ! isZero(u);){
         var _MoveRelativeDate4, _r43 = void 0;
         _MoveRelativeDate4 = MoveRelativeDate(m, c, I, _t29),
         c = _MoveRelativeDate4.relativeTo,
         _r43 = _MoveRelativeDate4.days,
         f = f + BigInt(_r43),
         u = u - d;
        }
        for(; ! isZero(T);){
         var _MoveRelativeDate5, _r44 = void 0;
         _MoveRelativeDate5 = MoveRelativeDate(m, c, S, _t29),
         c = _MoveRelativeDate5.relativeTo,
         _r44 = _MoveRelativeDate5.days,
         f = f + BigInt(_r44),
         T = T - d;
        }
        break;
       }
    }
    return {years: Number(h),
            months: Number(u),
            weeks: Number(T),
            days: Number(f)};
   }
   function CalculateOffsetShift(e, t, r, o, n){
    if(IsTemporalZonedDateTime(e)){
     var
      _a7 = GetSlot(e, S),
      _i10 = GetSlot(e, g),
      _s = GetSlot(e, p),
      _l2 = GetOffsetNanosecondsFor(_i10, _a7),
      _d2 = AddZonedDateTime(_a7, _i10, _s, t, r, o, n, 0, 0, 0, 0, 0, 0);
     return GetOffsetNanosecondsFor
             (_i10, new (GetIntrinsic("%Temporal.Instant%"))(_d2))
            - _l2;
    }
    return 0;
   }
   function CreateNegatedTemporalDuration(e){
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (- GetSlot(e, w),
             - GetSlot(e, D),
             - GetSlot(e, G),
             - GetSlot(e, v),
             - GetSlot(e, C),
             - GetSlot(e, O),
             - GetSlot(e, b),
             - GetSlot(e, E),
             - GetSlot(e, M),
             - GetSlot(e, R));
   }
   function ConstrainToRange(e, t, r){return oe(r, ne(t, e));}
   function ConstrainISODate(e, t, r){
    var o = ConstrainToRange(t, 1, 12);
    return {year: e,
            month: o,
            day: ConstrainToRange(r, 1, ISODaysInMonth(e, o))};
   }
   function RejectToRange(e, t, r){
    if(e < t || e > r)
     throw new
            RangeError
            ("value out of range: ".concat(t, " <= ").concat(e, " <= ").concat
              (r));
   }
   function RejectISODate(e, t, r){
    RejectToRange(t, 1, 12), RejectToRange(r, 1, ISODaysInMonth(e, t));
   }
   function RejectDateRange(e, t, r){
    RejectDateTimeRange(e, t, r, 12, 0, 0, 0, 0, 0);
   }
   function RejectTime(e, t, r, o, n, a){
    RejectToRange(e, 0, 23),
    RejectToRange(t, 0, 59),
    RejectToRange(r, 0, 59),
    RejectToRange(o, 0, 999),
    RejectToRange(n, 0, 999),
    RejectToRange(a, 0, 999);
   }
   function RejectDateTime(e, t, r, o, n, a, i, s, l){
    RejectISODate(e, t, r), RejectTime(o, n, a, i, s, l);
   }
   function RejectDateTimeRange(e, t, r, o, n, a, i, s, l){
    if
     (RejectToRange(e, Fe, Ye),
      e === Fe
      && null == GetUTCEpochNanoseconds(e, t, r + 1, o, n, a, i, s, l - 1)
      ||
       e === Ye
       && null == GetUTCEpochNanoseconds(e, t, r - 1, o, n, a, i, s, l + 1))
     throw new RangeError("DateTime outside of supported range");
   }
   function ValidateEpochNanoseconds(t){
    if(t < Me || t > Re)
     throw new RangeError("Instant outside of supported range");
   }
   function RejectDuration(e, t, r, o, n, a, i, s, l, d){
    var m = DurationSign(e, t, r, o, n, a, i, s, l, d);
    for
    (var _i11 = 0, _arr4 = [e, t, r, o, n, a, i, s, l, d];
     _i11 < _arr4.length;
     _i11++){
     var _c2 = _arr4[_i11];
     if(! me(_c2))
      throw new RangeError("infinite values not allowed as duration fields");
     var _e26 = se(_c2);
     if(0 !== _e26 && _e26 !== m)
      throw new RangeError("mixed-sign values not allowed as duration fields");
    }
   }
   function DifferenceISODate(e, t, r, o, n, a, i){
    switch(i){
      case "year":
      case "month":
       {
        var _s2 = - CompareISODate(e, t, r, o, n, a);
        if(0 === _s2) return {years: 0, months: 0, weeks: 0, days: 0};
        var
         _l3 = {year: e, month: t, day: r},
         _d3 = {year: o, month: n, day: a},
         _m3 = _d3.year - _l3.year,
         _c3 = AddISODate(e, t, r, _m3, 0, 0, 0, "constrain"),
         _h = - CompareISODate(_c3.year, _c3.month, _c3.day, o, n, a);
        if(0 === _h)
         return "year" === i
                 ? {years: _m3, months: 0, weeks: 0, days: 0}
                 : {years: 0, months: 12 * _m3, weeks: 0, days: 0};
        var _u = _d3.month - _l3.month;
        if
         (_h !== _s2 && (_m3 -= _s2, _u += 12 * _s2),
          _c3 = AddISODate(e, t, r, _m3, _u, 0, 0, "constrain"),
          _h = - CompareISODate(_c3.year, _c3.month, _c3.day, o, n, a),
          0 === _h)
         return "year" === i
                 ? {years: _m3, months: _u, weeks: 0, days: 0}
                 : {years: 0, months: _u + 12 * _m3, weeks: 0, days: 0};
        _h !== _s2
        &&
         (_u -= _s2,
          _u === - _s2 && (_m3 -= _s2, _u = 11 * _s2),
          _c3 = AddISODate(e, t, r, _m3, _u, 0, 0, "constrain"));
        var _T = 0;
        return _T =
                _c3.month === _d3.month
                 ? _d3.day - _c3.day
                 : _s2
                   < 0
                   ? -
                    _c3.day
                    - (ISODaysInMonth(_d3.year, _d3.month) - _d3.day)
                   : _d3.day + (ISODaysInMonth(_c3.year, _c3.month) - _c3.day),
               "month" === i && (_u += 12 * _m3, _m3 = 0),
               {years: _m3, months: _u, weeks: 0, days: _T};
       }
      case "week":
      case "day":
       {
        var _s3, _l4, _d4;
        CompareISODate(e, t, r, o, n, a) < 0
         ? (_l4
           = {year: e, month: t, day: r},
           _s3 = {year: o, month: n, day: a},
           _d4 = 1)
         : (_l4
           = {year: o, month: n, day: a},
           _s3 = {year: e, month: t, day: r},
           _d4 = - 1);
        var
         _m4 =
           DayOfYear(_s3.year, _s3.month, _s3.day)
           - DayOfYear(_l4.year, _l4.month, _l4.day);
        for(var _e27 = _l4.year; _e27 < _s3.year; ++_e27)
         _m4 += LeapYear(_e27) ? 366 : 365;
        var _c4 = 0;
        return "week" === i && (_c4 = ie(_m4 / 7), _m4 %= 7),
               _c4 *= _d4,
               _m4 *= _d4,
               {years: 0, months: 0, weeks: _c4, days: _m4};
       }
      default: throw new Error("assert not reached");
    }
   }
   function DifferenceTime(e, t, r, o, n, a, i, s, l, d, m, c){
    var
     _BalanceTime2,
     h = i - e,
     u = s - t,
     T = l - r,
     p = d - o,
     f = m - n,
     y = c - a,
     I = DurationSign(0, 0, 0, 0, h, u, T, p, f, y);
    h *= I, u *= I, T *= I, p *= I, f *= I, y *= I;
    var S = 0;
    if
     (_BalanceTime2 = BalanceTime(h, u, T, p, f, y),
      S = _BalanceTime2.deltaDays,
      h = _BalanceTime2.hour,
      u = _BalanceTime2.minute,
      T = _BalanceTime2.second,
      p = _BalanceTime2.millisecond,
      f = _BalanceTime2.microsecond,
      y = _BalanceTime2.nanosecond,
      0 != S)
     throw new
            Error
            ("assertion failure in DifferenceTime: _bt_.[[Days]] should be 0");
    return h *= I,
           u *= I,
           T *= I,
           p *= I,
           f *= I,
           y *= I,
           {hours: h,
            minutes: u,
            seconds: T,
            milliseconds: p,
            microseconds: f,
            nanoseconds: y};
   }
   function DifferenceInstant(t, r, o, n, a, i){
    var
     _RoundDuration2,
     s = r - t,
     l = 0,
     d = 0,
     m = Number(s % De),
     c = Number(s / De % De),
     h = Number(s / Ge % De),
     u = Number(s / ve);
    return _RoundDuration2 =
            RoundDuration(0, 0, 0, 0, 0, 0, u, h, c, m, o, n, i),
           l = _RoundDuration2.hours,
           d = _RoundDuration2.minutes,
           u = _RoundDuration2.seconds,
           h = _RoundDuration2.milliseconds,
           c = _RoundDuration2.microseconds,
           m = _RoundDuration2.nanoseconds,
           BalanceDuration(0, l, d, u, h, c, m, a);
   }
   function DifferenceISODateTime
   (e, t, r, o, n, a, i, s, l, d, m, c, h, u, T, p, f, y, I, S, g){
    var
     _BalanceISODate2,
     _BalanceDuration,
     _BalanceDuration2,
     w = e,
     D = t,
     G = r,
     _DifferenceTime = DifferenceTime(o, n, a, i, s, l, h, u, T, p, f, y),
     v = _DifferenceTime.hours,
     C = _DifferenceTime.minutes,
     O = _DifferenceTime.seconds,
     b = _DifferenceTime.milliseconds,
     E = _DifferenceTime.microseconds,
     M = _DifferenceTime.nanoseconds,
     R = DurationSign(0, 0, 0, 0, v, C, O, b, E, M);
    CompareISODate(d, m, c, w, D, G) === - R
    &&
     (_BalanceISODate2 = BalanceISODate(w, D, G - R),
      w = _BalanceISODate2.year,
      D = _BalanceISODate2.month,
      G = _BalanceISODate2.day,
      _BalanceDuration = BalanceDuration(- R, v, C, O, b, E, M, S),
      v = _BalanceDuration.hours,
      C = _BalanceDuration.minutes,
      O = _BalanceDuration.seconds,
      b = _BalanceDuration.milliseconds,
      E = _BalanceDuration.microseconds,
      M = _BalanceDuration.nanoseconds);
    var
     F = CreateTemporalDate(w, D, G, I),
     Y = CreateTemporalDate(d, m, c, I),
     P = LargerOfTwoTemporalUnits("day", S),
     Z = CopyOptions(g);
    Z.largestUnit = P;
    var
     _CalendarDateUntil = CalendarDateUntil(I, F, Y, Z),
     B = _CalendarDateUntil.years,
     N = _CalendarDateUntil.months,
     j = _CalendarDateUntil.weeks,
     $ = _CalendarDateUntil.days;
    return _BalanceDuration2 = BalanceDuration($, v, C, O, b, E, M, S),
           $ = _BalanceDuration2.days,
           v = _BalanceDuration2.hours,
           C = _BalanceDuration2.minutes,
           O = _BalanceDuration2.seconds,
           b = _BalanceDuration2.milliseconds,
           E = _BalanceDuration2.microseconds,
           M = _BalanceDuration2.nanoseconds,
           {years: B,
            months: N,
            weeks: j,
            days: $,
            hours: v,
            minutes: C,
            seconds: O,
            milliseconds: b,
            microseconds: E,
            nanoseconds: M};
   }
   function DifferenceZonedDateTime(t, r, o, n, a, p){
    var f = r - t;
    if(f === Ie)
     return {years: 0,
             months: 0,
             weeks: 0,
             days: 0,
             hours: 0,
             minutes: 0,
             seconds: 0,
             milliseconds: 0,
             microseconds: 0,
             nanoseconds: 0};
    var
     y = GetIntrinsic("%Temporal.Instant%"),
     I = new y(t),
     S = new y(r),
     g = GetPlainDateTimeFor(o, I, n),
     w = GetPlainDateTimeFor(o, S, n),
     _DifferenceISODateTim2 =
       DifferenceISODateTime
        (GetSlot(g, i),
         GetSlot(g, s),
         GetSlot(g, l),
         GetSlot(g, d),
         GetSlot(g, m),
         GetSlot(g, c),
         GetSlot(g, h),
         GetSlot(g, u),
         GetSlot(g, T),
         GetSlot(w, i),
         GetSlot(w, s),
         GetSlot(w, l),
         GetSlot(w, d),
         GetSlot(w, m),
         GetSlot(w, c),
         GetSlot(w, h),
         GetSlot(w, u),
         GetSlot(w, T),
         n,
         a,
         p),
     D = _DifferenceISODateTim2.years,
     G = _DifferenceISODateTim2.months,
     v = _DifferenceISODateTim2.weeks,
     C = _DifferenceISODateTim2.days,
     O = AddZonedDateTime(I, o, n, D, G, v, 0, 0, 0, 0, 0, 0, 0),
     b = r - O,
     E = CreateTemporalZonedDateTime(O, o, n),
     _NanosecondsToDays2 = NanosecondsToDays(b, E);
    b = _NanosecondsToDays2.nanoseconds;
    C = _NanosecondsToDays2.days;
    var
     _BalanceDuration3 = BalanceDuration(0, 0, 0, 0, 0, 0, Number(b), "hour"),
     M = _BalanceDuration3.hours,
     R = _BalanceDuration3.minutes,
     F = _BalanceDuration3.seconds,
     Y = _BalanceDuration3.milliseconds,
     P = _BalanceDuration3.microseconds,
     Z = _BalanceDuration3.nanoseconds;
    return {years: D,
            months: G,
            weeks: v,
            days: C,
            hours: M,
            minutes: R,
            seconds: F,
            milliseconds: Y,
            microseconds: P,
            nanoseconds: Z};
   }
   function GetDifferenceSettings(e, t, r, o, n, a){
    var
     i =
       Ue.reduce
        (function(e, t){
          var n = t[0], a = t[1], i = t[2];
          return "datetime" !== r && i !== r || o.includes(a) || e.push(a, n),
                 e;
         },
         []),
     s = GetTemporalUnit(t, "largestUnit", r, "auto");
    if(o.includes(s))
     throw new
            RangeError
            ("largestUnit must be one of ".concat(i.join(", "), ", not ").concat
              (s));
    var
     l = ToTemporalRoundingIncrement(t),
     d = ToTemporalRoundingMode(t, "trunc");
    "since" === e
    &&
     (d =
      function(e){
        switch(e){
          case "ceil":
           return "floor";
          case "floor":
           return "ceil";
          case "halfCeil":
           return "halfFloor";
          case "halfFloor":
           return "halfCeil";
          default: return e;
        }
       }
       (d));
    var m = GetTemporalUnit(t, "smallestUnit", r, n);
    if(o.includes(m))
     throw new
            RangeError
            ("smallestUnit must be one of ".concat(i.join(", "), ", not ").concat
              (m));
    var c = LargerOfTwoTemporalUnits(a, m);
    if("auto" === s && (s = c), LargerOfTwoTemporalUnits(s, m) !== s)
     throw new
            RangeError
            ("largestUnit ".concat(s, " cannot be smaller than smallestUnit ").concat
              (m));
    var
     h =
       {hour: 24,
         minute: 60,
         second: 60,
         millisecond: 1e3,
         microsecond: 1e3,
         nanosecond: 1e3}
        [m];
    return void 0 !== h && ValidateTemporalRoundingIncrement(l, h, ! 1),
           {largestUnit: s,
            roundingIncrement: l,
            roundingMode: d,
            smallestUnit: m};
   }
   function DifferenceTemporalInstant(e, t, r, o){
    var
     a = "since" === e ? - 1 : 1,
     i = ToTemporalInstant(r),
     s =
       GetDifferenceSettings
        (e, CopyOptions(o), "time", [], "nanosecond", "second"),
     l = GetSlot(t, n),
     d = GetSlot(i, n),
     _DifferenceInstant =
       DifferenceInstant
        (l,
         d,
         s.roundingIncrement,
         s.smallestUnit,
         s.largestUnit,
         s.roundingMode),
     m = _DifferenceInstant.hours,
     c = _DifferenceInstant.minutes,
     h = _DifferenceInstant.seconds,
     u = _DifferenceInstant.milliseconds,
     T = _DifferenceInstant.microseconds,
     p = _DifferenceInstant.nanoseconds;
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (0, 0, 0, 0, a * m, a * c, a * h, a * u, a * T, a * p);
   }
   function DifferenceTemporalPlainDate(e, t, r, o){
    var
     _RoundDuration3,
     n = "since" === e ? - 1 : 1,
     a = ToTemporalDate(r),
     i = GetSlot(t, p);
    ThrowIfCalendarsNotEqual
     (i, GetSlot(a, p), "compute difference between dates");
    var
     s = CopyOptions(o),
     l = GetDifferenceSettings(e, s, "date", [], "day", "day");
    s.largestUnit = l.largestUnit;
    var
     _CalendarDateUntil2 = CalendarDateUntil(i, t, a, s),
     d = _CalendarDateUntil2.years,
     m = _CalendarDateUntil2.months,
     c = _CalendarDateUntil2.weeks,
     h = _CalendarDateUntil2.days;
    "day" === l.smallestUnit && 1 === l.roundingIncrement
    ||
     (_RoundDuration3 =
       RoundDuration
        (d,
         m,
         c,
         h,
         0,
         0,
         0,
         0,
         0,
         0,
         l.roundingIncrement,
         l.smallestUnit,
         l.roundingMode,
         t),
      d = _RoundDuration3.years,
      m = _RoundDuration3.months,
      c = _RoundDuration3.weeks,
      h = _RoundDuration3.days,
      _RoundDuration3);
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (n * d, n * m, n * c, n * h, 0, 0, 0, 0, 0, 0);
   }
   function DifferenceTemporalPlainDateTime(e, t, r, o){
    var
     _RoundDuration4,
     _BalanceDuration4,
     n = "since" === e ? - 1 : 1,
     a = ToTemporalDateTime(r),
     f = GetSlot(t, p);
    ThrowIfCalendarsNotEqual
     (f, GetSlot(a, p), "compute difference between dates");
    var
     y = CopyOptions(o),
     I = GetDifferenceSettings(e, y, "datetime", [], "nanosecond", "day"),
     _DifferenceISODateTim3 =
       DifferenceISODateTime
        (GetSlot(t, i),
         GetSlot(t, s),
         GetSlot(t, l),
         GetSlot(t, d),
         GetSlot(t, m),
         GetSlot(t, c),
         GetSlot(t, h),
         GetSlot(t, u),
         GetSlot(t, T),
         GetSlot(a, i),
         GetSlot(a, s),
         GetSlot(a, l),
         GetSlot(a, d),
         GetSlot(a, m),
         GetSlot(a, c),
         GetSlot(a, h),
         GetSlot(a, u),
         GetSlot(a, T),
         f,
         I.largestUnit,
         y),
     S = _DifferenceISODateTim3.years,
     g = _DifferenceISODateTim3.months,
     w = _DifferenceISODateTim3.weeks,
     D = _DifferenceISODateTim3.days,
     G = _DifferenceISODateTim3.hours,
     v = _DifferenceISODateTim3.minutes,
     C = _DifferenceISODateTim3.seconds,
     O = _DifferenceISODateTim3.milliseconds,
     b = _DifferenceISODateTim3.microseconds,
     E = _DifferenceISODateTim3.nanoseconds,
     M = TemporalDateTimeToDate(t);
    _RoundDuration4 =
     RoundDuration
      (S,
       g,
       w,
       D,
       G,
       v,
       C,
       O,
       b,
       E,
       I.roundingIncrement,
       I.smallestUnit,
       I.roundingMode,
       M),
    S = _RoundDuration4.years,
    g = _RoundDuration4.months,
    w = _RoundDuration4.weeks,
    D = _RoundDuration4.days,
    G = _RoundDuration4.hours,
    v = _RoundDuration4.minutes,
    C = _RoundDuration4.seconds,
    O = _RoundDuration4.milliseconds,
    b = _RoundDuration4.microseconds,
    E = _RoundDuration4.nanoseconds,
    _BalanceDuration4 = BalanceDuration(D, G, v, C, O, b, E, I.largestUnit),
    D = _BalanceDuration4.days,
    G = _BalanceDuration4.hours,
    v = _BalanceDuration4.minutes,
    C = _BalanceDuration4.seconds,
    O = _BalanceDuration4.milliseconds,
    b = _BalanceDuration4.microseconds,
    E = _BalanceDuration4.nanoseconds;
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (n * S,
             n * g,
             n * w,
             n * D,
             n * G,
             n * v,
             n * C,
             n * O,
             n * b,
             n * E);
   }
   function DifferenceTemporalPlainTime(e, t, r, o){
    var
     _RoundDuration5,
     _BalanceDuration5,
     n = "since" === e ? - 1 : 1,
     a = ToTemporalTime(r),
     i =
       GetDifferenceSettings
        (e, CopyOptions(o), "time", [], "nanosecond", "hour"),
     _DifferenceTime2 =
       DifferenceTime
        (GetSlot(t, d),
         GetSlot(t, m),
         GetSlot(t, c),
         GetSlot(t, h),
         GetSlot(t, u),
         GetSlot(t, T),
         GetSlot(a, d),
         GetSlot(a, m),
         GetSlot(a, c),
         GetSlot(a, h),
         GetSlot(a, u),
         GetSlot(a, T)),
     s = _DifferenceTime2.hours,
     l = _DifferenceTime2.minutes,
     p = _DifferenceTime2.seconds,
     f = _DifferenceTime2.milliseconds,
     y = _DifferenceTime2.microseconds,
     I = _DifferenceTime2.nanoseconds;
    _RoundDuration5 =
     RoundDuration
      (0,
       0,
       0,
       0,
       s,
       l,
       p,
       f,
       y,
       I,
       i.roundingIncrement,
       i.smallestUnit,
       i.roundingMode),
    s = _RoundDuration5.hours,
    l = _RoundDuration5.minutes,
    p = _RoundDuration5.seconds,
    f = _RoundDuration5.milliseconds,
    y = _RoundDuration5.microseconds,
    I = _RoundDuration5.nanoseconds,
    _BalanceDuration5 = BalanceDuration(0, s, l, p, f, y, I, i.largestUnit),
    s = _BalanceDuration5.hours,
    l = _BalanceDuration5.minutes,
    p = _BalanceDuration5.seconds,
    f = _BalanceDuration5.milliseconds,
    y = _BalanceDuration5.microseconds,
    I = _BalanceDuration5.nanoseconds;
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (0, 0, 0, 0, n * s, n * l, n * p, n * f, n * y, n * I);
   }
   function DifferenceTemporalPlainYearMonth(e, t, r, o){
    var
     _RoundDuration6,
     n = "since" === e ? - 1 : 1,
     a = ToTemporalYearMonth(r),
     i = GetSlot(t, p);
    ThrowIfCalendarsNotEqual
     (i, GetSlot(a, p), "compute difference between months");
    var
     s = CopyOptions(o),
     l = GetDifferenceSettings(e, s, "date", ["week", "day"], "month", "year");
    s.largestUnit = l.largestUnit;
    var
     d = CalendarFields(i, ["monthCode", "year"]),
     m = PrepareTemporalFields(t, d, []);
    m.day = 1;
    var c = CalendarDateFromFields(i, m), h = PrepareTemporalFields(a, d, []);
    h.day = 1;
    var
     u = CalendarDateFromFields(i, h),
     _CalendarDateUntil3 = CalendarDateUntil(i, c, u, s),
     T = _CalendarDateUntil3.years,
     f = _CalendarDateUntil3.months;
    "month" === l.smallestUnit && 1 === l.roundingIncrement
    ||
     (_RoundDuration6 =
       RoundDuration
        (T,
         f,
         0,
         0,
         0,
         0,
         0,
         0,
         0,
         0,
         l.roundingIncrement,
         l.smallestUnit,
         l.roundingMode,
         c),
      T = _RoundDuration6.years,
      f = _RoundDuration6.months,
      _RoundDuration6);
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (n * T, n * f, 0, 0, 0, 0, 0, 0, 0, 0);
   }
   function DifferenceTemporalZonedDateTime(e, t, r, o){
    var
     _DifferenceInstant2,
     a = "since" === e ? - 1 : 1,
     i = ToTemporalZonedDateTime(r),
     s = GetSlot(t, p);
    ThrowIfCalendarsNotEqual
     (s, GetSlot(i, p), "compute difference between dates");
    var
     l = CopyOptions(o),
     d = GetDifferenceSettings(e, l, "datetime", [], "nanosecond", "hour");
    l.largestUnit = d.largestUnit;
    var m = GetSlot(t, n), c = GetSlot(i, n), h, u, T, f, y, I, S, w, D, G;
    if
     ("year" !== d.largestUnit && "month" !== d.largestUnit
      && "week" !== d.largestUnit
      && "day" !== d.largestUnit)
     h = 0,
     u = 0,
     T = 0,
     f = 0,
     _DifferenceInstant2 =
      DifferenceInstant
       (m,
        c,
        d.roundingIncrement,
        d.smallestUnit,
        d.largestUnit,
        d.roundingMode),
     y = _DifferenceInstant2.hours,
     I = _DifferenceInstant2.minutes,
     S = _DifferenceInstant2.seconds,
     w = _DifferenceInstant2.milliseconds,
     D = _DifferenceInstant2.microseconds,
     G = _DifferenceInstant2.nanoseconds;
    else{
     var
      _DifferenceZonedDateT,
      _RoundDuration7,
      _AdjustRoundedDuratio,
      _e28 = GetSlot(t, g);
     if(! TimeZoneEquals(_e28, GetSlot(i, g)))
      throw new
             RangeError
             ("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");
     _DifferenceZonedDateT =
      DifferenceZonedDateTime(m, c, _e28, s, d.largestUnit, l),
     h = _DifferenceZonedDateT.years,
     u = _DifferenceZonedDateT.months,
     T = _DifferenceZonedDateT.weeks,
     f = _DifferenceZonedDateT.days,
     y = _DifferenceZonedDateT.hours,
     I = _DifferenceZonedDateT.minutes,
     S = _DifferenceZonedDateT.seconds,
     w = _DifferenceZonedDateT.milliseconds,
     D = _DifferenceZonedDateT.microseconds,
     G = _DifferenceZonedDateT.nanoseconds,
     _RoundDuration7 =
      RoundDuration
       (h,
        u,
        T,
        f,
        y,
        I,
        S,
        w,
        D,
        G,
        d.roundingIncrement,
        d.smallestUnit,
        d.roundingMode,
        t),
     h = _RoundDuration7.years,
     u = _RoundDuration7.months,
     T = _RoundDuration7.weeks,
     f = _RoundDuration7.days,
     y = _RoundDuration7.hours,
     I = _RoundDuration7.minutes,
     S = _RoundDuration7.seconds,
     w = _RoundDuration7.milliseconds,
     D = _RoundDuration7.microseconds,
     G = _RoundDuration7.nanoseconds,
     _AdjustRoundedDuratio =
      AdjustRoundedDurationDays
       (h,
        u,
        T,
        f,
        y,
        I,
        S,
        w,
        D,
        G,
        d.roundingIncrement,
        d.smallestUnit,
        d.roundingMode,
        t),
     h = _AdjustRoundedDuratio.years,
     u = _AdjustRoundedDuratio.months,
     T = _AdjustRoundedDuratio.weeks,
     f = _AdjustRoundedDuratio.days,
     y = _AdjustRoundedDuratio.hours,
     I = _AdjustRoundedDuratio.minutes,
     S = _AdjustRoundedDuratio.seconds,
     w = _AdjustRoundedDuratio.milliseconds,
     D = _AdjustRoundedDuratio.microseconds,
     G = _AdjustRoundedDuratio.nanoseconds;
    }
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (a * h,
             a * u,
             a * T,
             a * f,
             a * y,
             a * I,
             a * S,
             a * w,
             a * D,
             a * G);
   }
   function AddISODate(e, t, r, o, n, a, i, s){
    var
     _BalanceISOYearMonth4,
     _RegulateISODate,
     _BalanceISODate3,
     l = e,
     d = t,
     m = r,
     c = a,
     h = i;
    return l += o,
           d += n,
           _BalanceISOYearMonth4 = BalanceISOYearMonth(l, d),
           l = _BalanceISOYearMonth4.year,
           d = _BalanceISOYearMonth4.month,
           _RegulateISODate = RegulateISODate(l, d, m, s),
           l = _RegulateISODate.year,
           d = _RegulateISODate.month,
           m = _RegulateISODate.day,
           h += 7 * c,
           m += h,
           _BalanceISODate3 = BalanceISODate(l, d, m),
           l = _BalanceISODate3.year,
           d = _BalanceISODate3.month,
           m = _BalanceISODate3.day,
           {year: l, month: d, day: m};
   }
   function AddTime(e, t, r, o, n, a, i, s, l, d, m, c){
    var _BalanceTime3, h = e, u = t, T = r, p = o, f = n, y = a;
    h += i, u += s, T += l, p += d, f += m, y += c;
    var I = 0;
    return _BalanceTime3 = BalanceTime(h, u, T, p, f, y),
           I = _BalanceTime3.deltaDays,
           h = _BalanceTime3.hour,
           u = _BalanceTime3.minute,
           T = _BalanceTime3.second,
           p = _BalanceTime3.millisecond,
           f = _BalanceTime3.microsecond,
           y = _BalanceTime3.nanosecond,
           {deltaDays: I,
            hour: h,
            minute: u,
            second: T,
            millisecond: p,
            microsecond: f,
            nanosecond: y};
   }
   function AddDuration
   (t, r, o, a, i, s, l, d, m, c, h, u, T, f, y, I, w, D, G, v, C){
    var
     O =
       LargerOfTwoTemporalUnits
        (DefaultTemporalLargestUnit(t, r, o, a, i, s, l, d, m, c),
         DefaultTemporalLargestUnit(h, u, T, f, y, I, w, D, G, v)),
     b,
     E,
     M,
     R,
     F,
     Y,
     P,
     Z,
     B,
     N;
    if(C)
     if(IsTemporalDate(C)){
      var
       _CalendarDateUntil4,
       _BalanceDuration6,
       _n10 = GetIntrinsic("%Temporal.Duration%"),
       _S2 = GetSlot(C, p),
       _g = new _n10(t, r, o, a, 0, 0, 0, 0, 0, 0),
       _j = new _n10(h, u, T, f, 0, 0, 0, 0, 0, 0),
       _$ = "string" != typeof _S2 ? GetMethod(_S2, "dateAdd") : void 0,
       _k = CalendarDateAdd(_S2, C, _g, void 0, _$),
       _U = CalendarDateAdd(_S2, _k, _j, void 0, _$),
       _A = LargerOfTwoTemporalUnits("day", O),
       _L = Te(null);
      _L.largestUnit = _A,
      _CalendarDateUntil4 = CalendarDateUntil(_S2, C, _U, _L),
      b = _CalendarDateUntil4.years,
      E = _CalendarDateUntil4.months,
      M = _CalendarDateUntil4.weeks,
      R = _CalendarDateUntil4.days,
      _BalanceDuration6 =
       BalanceDuration
        (R,
         BigInt(i) + BigInt(y),
         BigInt(s) + BigInt(I),
         BigInt(l) + BigInt(w),
         BigInt(d) + BigInt(D),
         BigInt(m) + BigInt(G),
         BigInt(c) + BigInt(v),
         O),
      R = _BalanceDuration6.days,
      F = _BalanceDuration6.hours,
      Y = _BalanceDuration6.minutes,
      P = _BalanceDuration6.seconds,
      Z = _BalanceDuration6.milliseconds,
      B = _BalanceDuration6.microseconds,
      N = _BalanceDuration6.nanoseconds;
     }
     else{
      var
       _DifferenceInstant3,
       _DifferenceZonedDateT2,
       _e29 = GetIntrinsic("%Temporal.Instant%"),
       _j2 = GetSlot(C, g),
       _$2 = GetSlot(C, p),
       _k2 =
         AddZonedDateTime
          (GetSlot(C, S), _j2, _$2, t, r, o, a, i, s, l, d, m, c),
       _U2 =
         AddZonedDateTime
          (new _e29(_k2), _j2, _$2, h, u, T, f, y, I, w, D, G, v);
      "year" !== O && "month" !== O && "week" !== O && "day" !== O
       ? (b
         = 0,
         E = 0,
         M = 0,
         R = 0,
         _DifferenceInstant3 =
          DifferenceInstant
           (GetSlot(C, n), _U2, 1, "nanosecond", O, "halfExpand"),
         F = _DifferenceInstant3.hours,
         Y = _DifferenceInstant3.minutes,
         P = _DifferenceInstant3.seconds,
         Z = _DifferenceInstant3.milliseconds,
         B = _DifferenceInstant3.microseconds,
         N = _DifferenceInstant3.nanoseconds)
       : (_DifferenceZonedDateT2
         = DifferenceZonedDateTime(GetSlot(C, n), _U2, _j2, _$2, O, Te(null)),
         b = _DifferenceZonedDateT2.years,
         E = _DifferenceZonedDateT2.months,
         M = _DifferenceZonedDateT2.weeks,
         R = _DifferenceZonedDateT2.days,
         F = _DifferenceZonedDateT2.hours,
         Y = _DifferenceZonedDateT2.minutes,
         P = _DifferenceZonedDateT2.seconds,
         Z = _DifferenceZonedDateT2.milliseconds,
         B = _DifferenceZonedDateT2.microseconds,
         N = _DifferenceZonedDateT2.nanoseconds,
         _DifferenceZonedDateT2);
     }
    else{
     var _BalanceDuration7;
     if("year" === O || "month" === O || "week" === O)
      throw new
             RangeError
             ("relativeTo is required for years, months, or weeks arithmetic");
     b = E = M = 0,
     _BalanceDuration7 =
      BalanceDuration
       (a + f,
        BigInt(i) + BigInt(y),
        BigInt(s) + BigInt(I),
        BigInt(l) + BigInt(w),
        BigInt(d) + BigInt(D),
        BigInt(m) + BigInt(G),
        BigInt(c) + BigInt(v),
        O),
     R = _BalanceDuration7.days,
     F = _BalanceDuration7.hours,
     Y = _BalanceDuration7.minutes,
     P = _BalanceDuration7.seconds,
     Z = _BalanceDuration7.milliseconds,
     B = _BalanceDuration7.microseconds,
     N = _BalanceDuration7.nanoseconds;
    }
    return RejectDuration(b, E, M, R, F, Y, P, Z, B, N),
           {years: b,
            months: E,
            weeks: M,
            days: R,
            hours: F,
            minutes: Y,
            seconds: P,
            milliseconds: Z,
            microseconds: B,
            nanoseconds: N};
   }
   function AddInstant(t, r, o, n, a, i, s){
    var l = Ie;
    l = l + BigInt(s),
    l = l + BigInt(i) * De,
    l = l + BigInt(a) * Ge,
    l = l + BigInt(n) * ve,
    l = l + BigInt(o) * 60000000000n,
    l = l + BigInt(r) * 3600000000000n;
    var d = t + l;
    return ValidateEpochNanoseconds(d), d;
   }
   function AddDateTime
   (e, t, r, o, n, a, d, m, c, h, u, T, p, f, y, I, S, g, w, D, G){
    var
     v = f,
     _AddTime = AddTime(o, n, a, d, m, c, y, I, S, g, w, D),
     C = _AddTime.deltaDays,
     O = _AddTime.hour,
     b = _AddTime.minute,
     E = _AddTime.second,
     M = _AddTime.millisecond,
     R = _AddTime.microsecond,
     F = _AddTime.nanosecond;
    v += C;
    var
     Y = GetIntrinsic("%Temporal.Duration%"),
     P =
       CalendarDateAdd
        (h,
         CreateTemporalDate(e, t, r, h),
         new Y(u, T, p, v, 0, 0, 0, 0, 0, 0),
         G);
    return {year: GetSlot(P, i),
            month: GetSlot(P, s),
            day: GetSlot(P, l),
            hour: O,
            minute: b,
            second: E,
            millisecond: M,
            microsecond: R,
            nanosecond: F};
   }
   function AddZonedDateTime(e, t, r, o, a, p, f, y, I, S, g, w, D, G){
    var v = GetIntrinsic("%Temporal.Duration%");
    if(0 === DurationSign(o, a, p, f, 0, 0, 0, 0, 0, 0))
     return AddInstant(GetSlot(e, n), y, I, S, g, w, D);
    var
     C = GetPlainDateTimeFor(t, e, r),
     O =
       CalendarDateAdd
        (r,
         CreateTemporalDate(GetSlot(C, i), GetSlot(C, s), GetSlot(C, l), r),
         new v(o, a, p, f, 0, 0, 0, 0, 0, 0),
         G),
     b =
       CreateTemporalDateTime
        (GetSlot(O, i),
         GetSlot(O, s),
         GetSlot(O, l),
         GetSlot(C, d),
         GetSlot(C, m),
         GetSlot(C, c),
         GetSlot(C, h),
         GetSlot(C, u),
         GetSlot(C, T),
         r);
    return AddInstant
            (GetSlot(GetInstantFor(t, b, "compatible"), n), y, I, S, g, w, D);
   }
   function AddDurationToOrSubtractDurationFromDuration(e, t, r, o){
    var
     n = "subtract" === e ? - 1 : 1,
     _ToTemporalDurationRe2 = ToTemporalDurationRecord(r),
     a = _ToTemporalDurationRe2.years,
     i = _ToTemporalDurationRe2.months,
     s = _ToTemporalDurationRe2.weeks,
     l = _ToTemporalDurationRe2.days,
     d = _ToTemporalDurationRe2.hours,
     m = _ToTemporalDurationRe2.minutes,
     c = _ToTemporalDurationRe2.seconds,
     h = _ToTemporalDurationRe2.milliseconds,
     u = _ToTemporalDurationRe2.microseconds,
     T = _ToTemporalDurationRe2.nanoseconds,
     p = ToRelativeTemporalObject(GetOptionsObject(o)),
     _AddDuration =
       AddDuration
        (GetSlot(t, w),
         GetSlot(t, D),
         GetSlot(t, G),
         GetSlot(t, v),
         GetSlot(t, C),
         GetSlot(t, O),
         GetSlot(t, b),
         GetSlot(t, E),
         GetSlot(t, M),
         GetSlot(t, R),
         n * a,
         n * i,
         n * s,
         n * l,
         n * d,
         n * m,
         n * c,
         n * h,
         n * u,
         n * T,
         p);
    a = _AddDuration.years;
    i = _AddDuration.months;
    s = _AddDuration.weeks;
    l = _AddDuration.days;
    d = _AddDuration.hours;
    m = _AddDuration.minutes;
    c = _AddDuration.seconds;
    h = _AddDuration.milliseconds;
    u = _AddDuration.microseconds;
    T = _AddDuration.nanoseconds;
    return new
            (GetIntrinsic("%Temporal.Duration%"))
            (a, i, s, l, d, m, c, h, u, T);
   }
   function AddDurationToOrSubtractDurationFromInstant(e, t, r){
    var
     o = "subtract" === e ? - 1 : 1,
     _ToLimitedTemporalDur =
       function(e, t){
         var
          r = ToTemporalDurationRecord(e),
          _iterator14 = _createForOfIteratorHelper(t),
          _step14;
         try{
          for(_iterator14.s(); ! (_step14 = _iterator14.n()).done;){
           var _e30 = _step14.value;
           if(0 !== r[_e30])
            throw new
                   RangeError
                   ("Duration field ".concat
                     (_e30,
                      " not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead."));
          }
         }
         catch(err){_iterator14.e(err);}
         finally{_iterator14.f();}
         return r;
        }
        (r, ["years", "months", "weeks", "days"]),
     a = _ToLimitedTemporalDur.hours,
     i = _ToLimitedTemporalDur.minutes,
     s = _ToLimitedTemporalDur.seconds,
     l = _ToLimitedTemporalDur.milliseconds,
     d = _ToLimitedTemporalDur.microseconds,
     m = _ToLimitedTemporalDur.nanoseconds,
     c = AddInstant(GetSlot(t, n), o * a, o * i, o * s, o * l, o * d, o * m);
    return new (GetIntrinsic("%Temporal.Instant%"))(c);
   }
   function AddDurationToOrSubtractDurationFromPlainDateTime(e, t, r, o){
    var
     n = "subtract" === e ? - 1 : 1,
     _ToTemporalDurationRe3 = ToTemporalDurationRecord(r),
     a = _ToTemporalDurationRe3.years,
     f = _ToTemporalDurationRe3.months,
     y = _ToTemporalDurationRe3.weeks,
     I = _ToTemporalDurationRe3.days,
     S = _ToTemporalDurationRe3.hours,
     g = _ToTemporalDurationRe3.minutes,
     w = _ToTemporalDurationRe3.seconds,
     D = _ToTemporalDurationRe3.milliseconds,
     G = _ToTemporalDurationRe3.microseconds,
     v = _ToTemporalDurationRe3.nanoseconds,
     C = GetOptionsObject(o),
     O = GetSlot(t, p),
     _AddDateTime =
       AddDateTime
        (GetSlot(t, i),
         GetSlot(t, s),
         GetSlot(t, l),
         GetSlot(t, d),
         GetSlot(t, m),
         GetSlot(t, c),
         GetSlot(t, h),
         GetSlot(t, u),
         GetSlot(t, T),
         O,
         n * a,
         n * f,
         n * y,
         n * I,
         n * S,
         n * g,
         n * w,
         n * D,
         n * G,
         n * v,
         C),
     b = _AddDateTime.year,
     E = _AddDateTime.month,
     M = _AddDateTime.day,
     R = _AddDateTime.hour,
     F = _AddDateTime.minute,
     Y = _AddDateTime.second,
     P = _AddDateTime.millisecond,
     Z = _AddDateTime.microsecond,
     B = _AddDateTime.nanosecond;
    return CreateTemporalDateTime(b, E, M, R, F, Y, P, Z, B, O);
   }
   function AddDurationToOrSubtractDurationFromPlainTime(e, t, r){
    var
     o = "subtract" === e ? - 1 : 1,
     _ToTemporalDurationRe4 = ToTemporalDurationRecord(r),
     n = _ToTemporalDurationRe4.hours,
     a = _ToTemporalDurationRe4.minutes,
     i = _ToTemporalDurationRe4.seconds,
     s = _ToTemporalDurationRe4.milliseconds,
     l = _ToTemporalDurationRe4.microseconds,
     p = _ToTemporalDurationRe4.nanoseconds,
     _AddTime2 =
       AddTime
        (GetSlot(t, d),
         GetSlot(t, m),
         GetSlot(t, c),
         GetSlot(t, h),
         GetSlot(t, u),
         GetSlot(t, T),
         o * n,
         o * a,
         o * i,
         o * s,
         o * l,
         o * p),
     f = _AddTime2.hour,
     y = _AddTime2.minute,
     I = _AddTime2.second,
     S = _AddTime2.millisecond,
     g = _AddTime2.microsecond,
     w = _AddTime2.nanosecond,
     _RegulateTime3 = RegulateTime(f, y, I, S, g, w, "reject");
    f = _RegulateTime3.hour;
    y = _RegulateTime3.minute;
    I = _RegulateTime3.second;
    S = _RegulateTime3.millisecond;
    g = _RegulateTime3.microsecond;
    w = _RegulateTime3.nanosecond;
    return new (GetIntrinsic("%Temporal.PlainTime%"))(f, y, I, S, g, w);
   }
   function AddDurationToOrSubtractDurationFromPlainYearMonth(e, t, r, o){
    var n = ToTemporalDurationRecord(r);
    "subtract" === e
    &&
     (n =
      {years: - n.years,
       months: - n.months,
       weeks: - n.weeks,
       days: - n.days,
       hours: - n.hours,
       minutes: - n.minutes,
       seconds: - n.seconds,
       milliseconds: - n.milliseconds,
       microseconds: - n.microseconds,
       nanoseconds: - n.nanoseconds});
    var
     _n11 = n,
     a = _n11.years,
     i = _n11.months,
     s = _n11.weeks,
     l = _n11.days,
     d = _n11.hours,
     m = _n11.minutes,
     c = _n11.seconds,
     h = _n11.milliseconds,
     u = _n11.microseconds,
     T = _n11.nanoseconds,
     _BalanceDuration8 = BalanceDuration(l, d, m, c, h, u, T, "day");
    l = _BalanceDuration8.days;
    var
     f = GetOptionsObject(o),
     y = GetSlot(t, p),
     I = CalendarFields(y, ["monthCode", "year"]),
     S = PrepareTemporalFields(t, I, []),
     g = Te(null);
    CopyDataProperties(g, S, []), S.day = 1;
    var
     w = CalendarDateFromFields(y, S),
     D = DurationSign(a, i, s, l, 0, 0, 0, 0, 0, 0),
     G = GetMethod(y, "dateAdd"),
     v = GetIntrinsic("%Temporal.Duration%");
    if(D < 0){
     var
      _e31 =
        CalendarDateAdd(y, w, new v(0, 1, 0, 0, 0, 0, 0, 0, 0, 0), void 0, G),
      _t30 =
        CalendarDateAdd
         (y, _e31, new v(0, 0, 0, - 1, 0, 0, 0, 0, 0, 0), void 0, G);
     g.day = CalendarDay(y, _t30), w = CalendarDateFromFields(y, g);
    }
    var C = new v(a, i, s, l, 0, 0, 0, 0, 0, 0), O = CopyOptions(f);
    return CalendarYearMonthFromFields
            (y,
             PrepareTemporalFields(CalendarDateAdd(y, w, C, f, G), I, []),
             O);
   }
   function AddDurationToOrSubtractDurationFromZonedDateTime(e, t, r, o){
    var
     n = "subtract" === e ? - 1 : 1,
     _ToTemporalDurationRe5 = ToTemporalDurationRecord(r),
     a = _ToTemporalDurationRe5.years,
     i = _ToTemporalDurationRe5.months,
     s = _ToTemporalDurationRe5.weeks,
     l = _ToTemporalDurationRe5.days,
     d = _ToTemporalDurationRe5.hours,
     m = _ToTemporalDurationRe5.minutes,
     c = _ToTemporalDurationRe5.seconds,
     h = _ToTemporalDurationRe5.milliseconds,
     u = _ToTemporalDurationRe5.microseconds,
     T = _ToTemporalDurationRe5.nanoseconds,
     f = GetOptionsObject(o),
     y = GetSlot(t, g),
     I = GetSlot(t, p);
    return CreateTemporalZonedDateTime
            (AddZonedDateTime
              (GetSlot(t, S),
               y,
               I,
               n * a,
               n * i,
               n * s,
               n * l,
               n * d,
               n * m,
               n * c,
               n * h,
               n * u,
               n * T,
               f),
             y,
             I);
   }
   function RoundNumberToIncrement(t, r, o){
    if(r === Se) return t;
    var
     _divmod21 = divmod(t, r),
     n = _divmod21.quotient,
     a = _divmod21.remainder;
    if(a === Ie) return t;
    var i = a < Ie ? - 1 : 1, s = abs(a * 2n), l = s === r, d = s > r;
    switch(o){
      case "ceil":
       i > 0 && (n = n + BigInt(i)); break;
      case "floor":
       i < 0 && (n = n + BigInt(i)); break;
      case "expand":
       n = n + BigInt(i); break;
      case "trunc": break;
      case "halfCeil":
       (d || l && i > 0) && (n = n + BigInt(i)); break;
      case "halfFloor":
       (d || l && i < 0) && (n = n + BigInt(i)); break;
      case "halfExpand":
       (d || l) && (n = n + BigInt(i)); break;
      case "halfTrunc":
       d && (n = n + BigInt(i)); break;
      case "halfEven":
       (d || l && 1 === Number(abs(n) % 2n)) && (n = n + BigInt(i));
    }
    return n * r;
   }
   function RoundInstant(t, r, o, n){
    var
     _NonNegativeBigIntDiv7 = NonNegativeBigIntDivmod(t, Ee),
     a = _NonNegativeBigIntDiv7.remainder,
     i = t - a,
     s = RoundNumberToIncrement(a, BigInt(_e[o] * r), n);
    return i + s;
   }
   function RoundISODateTime(e, t, r, o, n, a, i, s, l, d, m, c){
    var
     h =
       arguments.length > 12 && arguments[12] !== undefined
        ? arguments[12]
        : 864e11,
     _RoundTime = RoundTime(o, n, a, i, s, l, d, m, c, h),
     u = _RoundTime.deltaDays,
     T = _RoundTime.hour,
     p = _RoundTime.minute,
     f = _RoundTime.second,
     y = _RoundTime.millisecond,
     I = _RoundTime.microsecond,
     S = _RoundTime.nanosecond,
     _BalanceISODate4 = BalanceISODate(e, t, r + u),
     g = _BalanceISODate4.year,
     w = _BalanceISODate4.month,
     D = _BalanceISODate4.day;
    return {year: g,
            month: w,
            day: D,
            hour: T,
            minute: p,
            second: f,
            millisecond: y,
            microsecond: I,
            nanosecond: S};
   }
   function RoundTime(t, r, o, n, a, i, s, l, d){
    var
     m =
       arguments.length > 9 && arguments[9] !== undefined
        ? arguments[9]
        : 864e11,
     c = Ie;
    switch(l){
      case "day":
      case "hour":
       c = BigInt(t);
      case "minute":
       c = c * ge + BigInt(r);
      case "second":
       c = c * ge + BigInt(o);
      case "millisecond":
       c = c * De + BigInt(n);
      case "microsecond":
       c = c * De + BigInt(a);
      case "nanosecond":
       c = c * De + BigInt(i);
    }
    var
     h = "day" === l ? m : _e[l],
     u = RoundNumberToIncrement(c, BigInt(h * s), d),
     T = Number(u / BigInt(h));
    switch(l){
      case "day":
       return {deltaDays: T,
               hour: 0,
               minute: 0,
               second: 0,
               millisecond: 0,
               microsecond: 0,
               nanosecond: 0};
      case "hour":
       return BalanceTime(T, 0, 0, 0, 0, 0);
      case "minute":
       return BalanceTime(t, T, 0, 0, 0, 0);
      case "second":
       return BalanceTime(t, r, T, 0, 0, 0);
      case "millisecond":
       return BalanceTime(t, r, o, T, 0, 0);
      case "microsecond":
       return BalanceTime(t, r, o, n, T, 0);
      case "nanosecond":
       return BalanceTime(t, r, o, n, a, T);
      default: throw new Error("Invalid unit ".concat(l));
    }
   }
   function DaysUntil(e, t){
    return DifferenceISODate
            (GetSlot(e, i),
             GetSlot(e, s),
             GetSlot(e, l),
             GetSlot(t, i),
             GetSlot(t, s),
             GetSlot(t, l),
             "day").days;
   }
   function MoveRelativeDate(e, t, r, o){
    var n = CalendarDateAdd(e, t, r, void 0, o);
    return {relativeTo: n, days: DaysUntil(t, n)};
   }
   function MoveRelativeZonedDateTime(e, t, r, o, n){
    var a = GetSlot(e, g), i = GetSlot(e, p);
    return CreateTemporalZonedDateTime
            (AddZonedDateTime
              (GetSlot(e, S), a, i, t, r, o, n, 0, 0, 0, 0, 0, 0),
             a,
             i);
   }
   function AdjustRoundedDurationDays
   (t, r, o, n, a, i, s, l, d, m, c, h, u, T){
    var
     _AddDuration2,
     _BalanceDuration9,
     f = t,
     y = r,
     I = o,
     w = n,
     D = a,
     G = i,
     v = s,
     C = l,
     O = d,
     b = m;
    if
     (! IsTemporalZonedDateTime(T) || "year" === h || "month" === h
      || "week" === h
      || "day" === h
      || "nanosecond" === h && 1 === c)
     return {years: f,
             months: y,
             weeks: I,
             days: w,
             hours: D,
             minutes: G,
             seconds: v,
             milliseconds: C,
             microseconds: O,
             nanoseconds: b};
    var
     E = TotalDurationNanoseconds(0, D, G, v, C, O, b, 0),
     M = se(Number(E)),
     R = GetSlot(T, g),
     F = GetSlot(T, p),
     Y = AddZonedDateTime(GetSlot(T, S), R, F, f, y, I, w, 0, 0, 0, 0, 0, 0),
     P =
       AddZonedDateTime
        (new (GetIntrinsic("%Temporal.Instant%"))(Y),
         R,
         F,
         0,
         0,
         0,
         M,
         0,
         0,
         0,
         0,
         0,
         0),
     Z = P - Y;
    return (E - Z) * BigInt(M) >= Ie
           &&
            (_AddDuration2 =
              AddDuration
               (f, y, I, w, 0, 0, 0, 0, 0, 0, 0, 0, 0, M, 0, 0, 0, 0, 0, 0, T),
             f = _AddDuration2.years,
             y = _AddDuration2.months,
             I = _AddDuration2.weeks,
             w = _AddDuration2.days,
             E = RoundInstant(E - Z, c, h, u),
             _BalanceDuration9 =
              BalanceDuration(0, 0, 0, 0, 0, 0, Number(E), "hour"),
             D = _BalanceDuration9.hours,
             G = _BalanceDuration9.minutes,
             v = _BalanceDuration9.seconds,
             C = _BalanceDuration9.milliseconds,
             O = _BalanceDuration9.microseconds,
             b = _BalanceDuration9.nanoseconds),
           {years: f,
            months: y,
            weeks: I,
            days: w,
            hours: D,
            minutes: G,
            seconds: v,
            milliseconds: C,
            microseconds: O,
            nanoseconds: b};
   }
   function RoundDuration(t, r, o, n, a, i, s, l, d, m, c, h, u, T){
    var
     f = t,
     y = r,
     I = o,
     S = n,
     g = a,
     w = i,
     D = s,
     G = l,
     v = d,
     C = BigInt(m),
     O = GetIntrinsic("%Temporal.Duration%"),
     b,
     E,
     M,
     R,
     F = T;
    if(F){
     if(IsTemporalZonedDateTime(F))
      E = F, F = ToTemporalDate(F);
     else if(! IsTemporalDate(F))
      throw new TypeError("starting point must be PlainDate or ZonedDateTime");
     b = GetSlot(F, p);
    }
    if("year" === h || "month" === h || "week" === h || "day" === h){
     var _NanosecondsToDays3, _t31, _r45, _o15;
     C = TotalDurationNanoseconds(0, g, w, D, G, v, m, 0),
     E && (_t31 = MoveRelativeZonedDateTime(E, f, y, I, S)),
     _NanosecondsToDays3 = NanosecondsToDays(C, _t31),
     _r45 = _NanosecondsToDays3.days,
     C = _NanosecondsToDays3.nanoseconds,
     _o15 = _NanosecondsToDays3.dayLengthNs,
     M = BigInt(_o15),
     S += _r45,
     g = w = D = G = v = 0;
    }
    switch(h){
      case "year":
       {
        if(! b)
         throw new
                RangeError
                ("A starting point is required for years rounding");
        var
         _t32 = new O(f),
         _r46 = "string" != typeof b ? GetMethod(b, "dateAdd") : void 0,
         _o16 = CalendarDateAdd(b, F, _t32, void 0, _r46),
         _n12 = CalendarDateAdd(b, F, new O(f, y, I), void 0, _r46);
        F = _o16, S += DaysUntil(_o16, _n12);
        var
         _a8 = CalendarDateAdd(b, F, new O(0, 0, 0, S), void 0, _r46),
         _i12 = Te(null);
        _i12.largestUnit = "year";
        var _s4 = CalendarDateUntil(b, F, _a8, _i12).years;
        f += _s4;
        var _l5 = F;
        F = CalendarDateAdd(b, F, new O(_s4), void 0, _r46);
        S -= DaysUntil(_l5, F);
        var
         _d5 = new O(S < 0 ? - 1 : 1),
         _MoveRelativeDate6 = MoveRelativeDate(b, F, _d5, _r46),
         _m5 = _MoveRelativeDate6.days;
        _m5 = ae(_m5);
        var _h2 = BigInt(_m5) * M;
        C = _h2 * BigInt(f) + BigInt(S) * M + C;
        var _T2 = RoundNumberToIncrement(C, _h2 * BigInt(c), u);
        R = BigIntDivideToNumber(C, _h2),
        f = Number(_T2 / _h2),
        C = Ie,
        y = I = S = 0;
        break;
       }
      case "month":
       {
        if(! b)
         throw new
                RangeError
                ("A starting point is required for months rounding");
        var
         _t33 = new O(f, y),
         _r47 = "string" != typeof b ? GetMethod(b, "dateAdd") : void 0,
         _o17 = CalendarDateAdd(b, F, _t33, void 0, _r47),
         _n13 = CalendarDateAdd(b, F, new O(f, y, I), void 0, _r47);
        F = _o17, S += DaysUntil(_o17, _n13);
        var _a9 = se(S), _i13 = new O(0, S < 0 ? - 1 : 1), _s5;
        for
        (_MoveRelativeDate7 = MoveRelativeDate(b, F, _i13, _r47),
         F = _MoveRelativeDate7.relativeTo,
         _s5 = _MoveRelativeDate7.days,
         _MoveRelativeDate7;
         ae(S) >= ae(_s5);){
         var _MoveRelativeDate7, _MoveRelativeDate8;
         y += _a9,
         S -= _s5,
         _MoveRelativeDate8 = MoveRelativeDate(b, F, _i13, _r47),
         F = _MoveRelativeDate8.relativeTo,
         _s5 = _MoveRelativeDate8.days;
        }
        _s5 = ae(_s5);
        var _l6 = BigInt(_s5) * M;
        C = _l6 * BigInt(y) + BigInt(S) * M + C;
        var _d6 = RoundNumberToIncrement(C, _l6 * BigInt(c), u);
        R = BigIntDivideToNumber(C, _l6),
        y = Number(_d6 / _l6),
        C = Ie,
        I = S = 0;
        break;
       }
      case "week":
       {
        if(! b)
         throw new
                RangeError
                ("A starting point is required for weeks rounding");
        var
         _t34 = se(S),
         _r48 = new O(0, 0, S < 0 ? - 1 : 1),
         _o18 = "string" != typeof b ? GetMethod(b, "dateAdd") : void 0,
         _n14;
        for
        (_MoveRelativeDate9 = MoveRelativeDate(b, F, _r48, _o18),
         F = _MoveRelativeDate9.relativeTo,
         _n14 = _MoveRelativeDate9.days,
         _MoveRelativeDate9;
         ae(S) >= ae(_n14);){
         var _MoveRelativeDate9, _MoveRelativeDate10;
         I += _t34,
         S -= _n14,
         _MoveRelativeDate10 = MoveRelativeDate(b, F, _r48, _o18),
         F = _MoveRelativeDate10.relativeTo,
         _n14 = _MoveRelativeDate10.days;
        }
        _n14 = ae(_n14);
        var _a10 = BigInt(_n14) * M;
        C = _a10 * BigInt(I) + BigInt(S) * M + C;
        var _i14 = RoundNumberToIncrement(C, _a10 * BigInt(c), u);
        R = BigIntDivideToNumber(C, _a10),
        I = Number(_i14 / _a10),
        C = Ie,
        S = 0;
        break;
       }
      case "day":
       {
        var _t35 = M;
        C = _t35 * BigInt(S) + C;
        var _r49 = RoundNumberToIncrement(C, _t35 * BigInt(c), u);
        R = BigIntDivideToNumber(C, _t35), S = Number(_r49 / _t35), C = Ie;
        break;
       }
      case "hour":
       {
        var _t36 = 36e11, _r50 = BigInt(g) * 3600000000000n;
        _r50 = _r50 + BigInt(w) * 60000000000n,
        _r50 = _r50 + BigInt(D) * ve,
        _r50 = _r50 + BigInt(G) * Ge,
        _r50 = _r50 + BigInt(v) * De,
        _r50 = _r50 + C,
        R = BigIntDivideToNumber(_r50, BigInt(_t36));
        var _o19 = RoundNumberToIncrement(_r50, BigInt(_t36 * c), u);
        g = Number(_o19 / BigInt(_t36)), C = Ie, w = D = G = v = 0;
        break;
       }
      case "minute":
       {
        var _t37 = 6e10, _r51 = BigInt(w) * 60000000000n;
        _r51 = _r51 + BigInt(D) * ve,
        _r51 = _r51 + BigInt(G) * Ge,
        _r51 = _r51 + BigInt(v) * De,
        _r51 = _r51 + C,
        R = BigIntDivideToNumber(_r51, BigInt(_t37));
        var _o20 = RoundNumberToIncrement(_r51, BigInt(_t37 * c), u);
        w = Number(_o20 / BigInt(_t37)), C = Ie, D = G = v = 0;
        break;
       }
      case "second":
       {
        var _t38 = 1e9, _r52 = BigInt(D) * ve;
        _r52 = _r52 + BigInt(G) * Ge,
        _r52 = _r52 + BigInt(v) * De,
        _r52 = _r52 + C,
        R = BigIntDivideToNumber(_r52, BigInt(_t38));
        var _o21 = RoundNumberToIncrement(_r52, BigInt(_t38 * c), u);
        D = Number(_o21 / BigInt(_t38)), C = Ie, G = v = 0;
        break;
       }
      case "millisecond":
       {
        var _t39 = 1e6, _r53 = BigInt(G) * Ge;
        _r53 = _r53 + BigInt(v) * De,
        _r53 = _r53 + C,
        R = BigIntDivideToNumber(_r53, BigInt(_t39));
        var _o22 = RoundNumberToIncrement(_r53, BigInt(_t39 * c), u);
        G = Number(_o22 / BigInt(_t39)), C = Ie, v = 0;
        break;
       }
      case "microsecond":
       {
        var _t40 = 1e3, _r54 = BigInt(v) * De;
        _r54 = _r54 + C, R = BigIntDivideToNumber(_r54, BigInt(_t40));
        var _o23 = RoundNumberToIncrement(_r54, BigInt(_t40 * c), u);
        v = Number(_o23 / BigInt(_t40)), C = Ie;
        break;
       }
      case "nanosecond":
       R = Number(C), C = RoundNumberToIncrement(BigInt(C), BigInt(c), u);
    }
    return {years: f,
            months: y,
            weeks: I,
            days: S,
            hours: g,
            minutes: w,
            seconds: D,
            milliseconds: G,
            microseconds: v,
            nanoseconds: Number(C),
            total: R};
   }
   function CompareISODate(e, t, r, o, n, a){
    for
    (var _i15 = 0, _arr5 = [[e, o], [t, n], [r, a]];
     _i15 < _arr5.length;
     _i15++){
     var
      _arr5$_i = _slicedToArray(_arr5[_i15], 2),
      _i16 = _arr5$_i[0],
      _s6 = _arr5$_i[1];
     if(_i16 !== _s6) return ComparisonResult(_i16 - _s6);
    }
    return 0;
   }
   function NonNegativeBigIntDivmod(t, r){
    var
     _divmod22 = divmod(t, r),
     o = _divmod22.quotient,
     n = _divmod22.remainder;
    return n < Ie && (o = o - Se, n = n + r), {quotient: o, remainder: n};
   }
   function BigIntFloorDiv(t, r){
    var
     _divmod23 = divmod(t, r),
     o = _divmod23.quotient,
     n = _divmod23.remainder;
    return isZero(n) || ! isNegativeJSBI(t) == ! isNegativeJSBI(r)
            ? o
            : o - Se;
   }
   function BigIntDivideToNumber(t, r){
    var
     _divmod24 = divmod(t, r),
     o = _divmod24.quotient,
     n = _divmod24.remainder;
    return Number(o) + Number(n) / Number(r);
   }
   function ToBigIntExternal(e){
    var t = ToBigInt(e);
    return void 0 !== globalThis.BigInt
            ? globalThis.BigInt(t.toString(10))
            : t;
   }
   function ToBigInt(t){
    var r = t;
    if("object" == _typeof(t)){
     var _e32 = t[Symbol.toPrimitive];
     _e32 && "function" == typeof _e32 && (r = fe(_e32, t, ["number"]));
    }
    if("number" == typeof r)
     throw new TypeError("cannot convert number to bigint");
    return "bigint" == typeof r ? BigInt(r.toString(10)) : BigInt(r);
   }
   var
    Ve =
      function(){
        var t = BigInt(Date.now() % 1e6);
        return function(){
         var r = BigInt(Date.now()), o = r * Ge + t;
         return t = r % Ge, o > Re ? Re : o < Me ? Me : o;};
       }
       ();
   function DefaultTimeZone(){return new re().resolvedOptions().timeZone;}
   function ComparisonResult(e){return e < 0 ? - 1 : e > 0 ? 1 : e;}
   function GetOptionsObject(e){
    if(void 0 === e) return Te(null);
    if(IsObject(e) && null !== e) return e;
    throw new
           TypeError
           ("Options parameter must be an object, not "
            + (null === e ? "null" : "" + _typeof(e)));
   }
   function CreateOnePropObject(e, t){var r = Te(null); return r[e] = t, r;}
   function CopyOptions(e){
    var t = Te(null);
    return CopyDataProperties(t, GetOptionsObject(e), []), t;
   }
   function GetOption(e, t, r, o){
    var n = e[t];
    if(void 0 !== n){
     if(n = ToString(n), ! r.includes(n))
      throw new
             RangeError
             ("".concat(t, " must be one of ").concat(r.join(", "), ", not ").concat
               (n));
     return n;
    }
    return o;
   }
   function IsBuiltinCalendar(e){return je.includes(ASCIILowercase(e));}
   function ASCIILowercase(e){
    return e.replace
            (/[A-Z]/g,
             function(e){
              var t = e.charCodeAt(0);
              return String.fromCharCode(t + 32);
             });
   }
   var ze = new RegExp("^".concat(W.source, "$"));
   function bisect(t, r, o){
    var
     n =
       arguments.length > 3 && arguments[3] !== undefined
        ? arguments[3]
        : t(r),
     a =
       arguments.length > 4 && arguments[4] !== undefined
        ? arguments[4]
        : t(o),
     i = BigInt(r),
     s = BigInt(o),
     l = n,
     d = a;
    for(; s - i > Se;){
     var _r55 = (i + s) / 2n, _o24 = t(_r55);
     if(_o24 === l)
      i = _r55, l = _o24;
     else{
      if(_o24 !== d)
       throw new
              Error
              ("invalid state in bisection ".concat(l, " - ").concat
                 (_o24, " - ").concat
                (d));
      s = _r55, d = _o24;
     }
    }
    return s;
   }
   var
    _e =
      {hour: 36e11,
       minute: 6e10,
       second: 1e9,
       millisecond: 1e6,
       microsecond: 1e3,
       nanosecond: 1},
    Je = Symbol("date"),
    Ke = Symbol("ym"),
    Xe = Symbol("md"),
    Qe = Symbol("time"),
    et = Symbol("datetime"),
    tt = Symbol("instant"),
    rt = Symbol("original"),
    ot = Symbol("timezone"),
    nt = Symbol("calendar-id"),
    at = Symbol("locale"),
    it = Symbol("options"),
    descriptor =
      function(e){
       return {value: e, enumerable: ! 0, writable: ! 1, configurable: ! 0};
      },
    st = globalThis.Intl.DateTimeFormat,
    lt = Object.assign,
    dt = Object.prototype.hasOwnProperty,
    mt = Reflect.apply;
   function getPropLazy(e, t){
    var r = e[t];
    return "function" == typeof r && (r = new st(e[at], r(e[it])), e[t] = r),
           r;
   }
   function DateTimeFormatImpl(e){
    var
     t =
       arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if(! (this instanceof DateTimeFormatImpl))
     return new DateTimeFormatImpl(e, t);
    var
     r = void 0 !== t,
     o = r ? lt({}, t) : {},
     n = new st(e, o),
     a = n.resolvedOptions();
    if(r){
     var _e33 = lt({}, a);
     for(var _t41 in _e33) mt(dt, o, [_t41]) || delete _e33[_t41];
     this[it] = _e33;
    }
    else
     this[it] = o;
    this[at] = a.locale,
    this[rt] = n,
    this[ot] = a.timeZone,
    this[nt] = a.calendar,
    this[Je] = dateAmend,
    this[Ke] = yearMonthAmend,
    this[Xe] = monthDayAmend,
    this[Qe] = timeAmend,
    this[et] = datetimeAmend,
    this[tt] = instantAmend;
   }
   Object.defineProperty
    (DateTimeFormatImpl, "name", {writable: ! 0, value: "DateTimeFormat"}),
   DateTimeFormatImpl.supportedLocalesOf =
    function(e, t){return st.supportedLocalesOf(e, t);};
   var
    ct =
      {resolvedOptions:
       descriptor(function(){return this[rt].resolvedOptions();}),
       format:
       descriptor
        (function(e){
          var
           _this$rt,
           _extractOverrides = extractOverrides(e, this),
           r = _extractOverrides.instant,
           o = _extractOverrides.formatter;
          if(r && o) return o.format(r.epochMilliseconds);
          for
          (var
            _len2 = arguments.length,
            t = new Array(_len2 > 1 ? _len2 - 1 : 0),
            _key2 = 1;
           _key2 < _len2;
           _key2++)
           t[_key2 - 1] = arguments[_key2];
          return (_this$rt = this[rt]).format.apply(_this$rt, [e].concat(t));
         }),
       formatRange:
       descriptor
        (function(e, t){
          if(isTemporalObject(e) || isTemporalObject(t)){
           if(! sameTemporalType(e, t))
            throw new
                   TypeError
                   ("Intl.DateTimeFormat.formatRange accepts two values of the same type");
           var
            _extractOverrides2 = extractOverrides(e, this),
            _r56 = _extractOverrides2.instant,
            _o25 = _extractOverrides2.formatter,
            _extractOverrides3 = extractOverrides(t, this),
            _n15 = _extractOverrides3.instant,
            _a11 = _extractOverrides3.formatter;
           if(_r56 && _n15 && _o25 && _a11 && _o25 === _a11)
            return _o25.formatRange
                    (_r56.epochMilliseconds, _n15.epochMilliseconds);
          }
          return this[rt].formatRange(e, t);
         })};
   "formatToParts" in st.prototype
   &&
    (ct.formatToParts =
     descriptor
      (function(e){
        var
         _this$rt2,
         _extractOverrides4 = extractOverrides(e, this),
         r = _extractOverrides4.instant,
         o = _extractOverrides4.formatter;
        if(r && o) return o.formatToParts(r.epochMilliseconds);
        for
        (var
          _len3 = arguments.length,
          t = new Array(_len3 > 1 ? _len3 - 1 : 0),
          _key3 = 1;
         _key3 < _len3;
         _key3++)
         t[_key3 - 1] = arguments[_key3];
        return (_this$rt2 = this[rt]).formatToParts.apply
                (_this$rt2, [e].concat(t));
       })),
   "formatRangeToParts" in st.prototype
   &&
    (ct.formatRangeToParts =
     descriptor
      (function(e, t){
        if(isTemporalObject(e) || isTemporalObject(t)){
         if(! sameTemporalType(e, t))
          throw new
                 TypeError
                 ("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");
         var
          _extractOverrides5 = extractOverrides(e, this),
          _r57 = _extractOverrides5.instant,
          _o26 = _extractOverrides5.formatter,
          _extractOverrides6 = extractOverrides(t, this),
          _n16 = _extractOverrides6.instant,
          _a12 = _extractOverrides6.formatter;
         if(_r57 && _n16 && _o26 && _a12 && _o26 === _a12)
          return _o26.formatRangeToParts
                  (_r57.epochMilliseconds, _n16.epochMilliseconds);
        }
        return this[rt].formatRangeToParts(e, t);
       })),
   DateTimeFormatImpl.prototype = Object.create(st.prototype, ct),
   Object.defineProperty
    (DateTimeFormatImpl,
     "prototype",
     {writable: ! 1, enumerable: ! 1, configurable: ! 1});
   var ht = DateTimeFormatImpl;
   function amend(){
    var
     e =
       arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
     t =
       arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
     r = lt({}, e);
    for
    (var
      _i17 = 0,
      _arr6 =
        ["year",
         "month",
         "day",
         "hour",
         "minute",
         "second",
         "weekday",
         "dayPeriod",
         "timeZoneName",
         "dateStyle",
         "timeStyle"];
     _i17 < _arr6.length;
     _i17++){
     var _e34 = _arr6[_i17];
     r[_e34] = _e34 in t ? t[_e34] : r[_e34],
     ! 1 !== r[_e34] && void 0 !== r[_e34] || delete r[_e34];
    }
    return r;
   }
   function timeAmend(e){
    var
     t =
       amend
        (e,
         {year: ! 1,
          month: ! 1,
          day: ! 1,
          weekday: ! 1,
          timeZoneName: ! 1,
          dateStyle: ! 1});
    return hasTimeOptions(t)
           ||
            (t =
             lt
              ({}, t, {hour: "numeric", minute: "numeric", second: "numeric"})),
           t;
   }
   function yearMonthAmend(e){
    var
     t =
       amend
        (e,
         {day: ! 1,
          hour: ! 1,
          minute: ! 1,
          second: ! 1,
          weekday: ! 1,
          dayPeriod: ! 1,
          timeZoneName: ! 1,
          dateStyle: ! 1,
          timeStyle: ! 1});
    return "year" in t || "month" in t
           || (t = lt(t, {year: "numeric", month: "numeric"})),
           t;
   }
   function monthDayAmend(e){
    var
     t =
       amend
        (e,
         {year: ! 1,
          hour: ! 1,
          minute: ! 1,
          second: ! 1,
          weekday: ! 1,
          dayPeriod: ! 1,
          timeZoneName: ! 1,
          dateStyle: ! 1,
          timeStyle: ! 1});
    return "month" in t || "day" in t
           || (t = lt({}, t, {month: "numeric", day: "numeric"})),
           t;
   }
   function dateAmend(e){
    var
     t =
       amend
        (e,
         {hour: ! 1,
          minute: ! 1,
          second: ! 1,
          dayPeriod: ! 1,
          timeZoneName: ! 1,
          timeStyle: ! 1});
    return hasDateOptions(t)
           ||
            (t =
             lt({}, t, {year: "numeric", month: "numeric", day: "numeric"})),
           t;
   }
   function datetimeAmend(e){
    var t = amend(e, {timeZoneName: ! 1});
    return hasTimeOptions(t) || hasDateOptions(t)
           ||
            (t =
             lt
              ({},
               t,
               {year: "numeric",
                month: "numeric",
                day: "numeric",
                hour: "numeric",
                minute: "numeric",
                second: "numeric"})),
           t;
   }
   function instantAmend(e){
    var t = e;
    return hasTimeOptions(t) || hasDateOptions(t)
           ||
            (t =
             lt
              ({},
               t,
               {year: "numeric",
                month: "numeric",
                day: "numeric",
                hour: "numeric",
                minute: "numeric",
                second: "numeric"})),
           t;
   }
   function hasDateOptions(e){
    return "year" in e || "month" in e || "day" in e || "weekday" in e
           || "dateStyle" in e;
   }
   function hasTimeOptions(e){
    return "hour" in e || "minute" in e || "second" in e || "timeStyle" in e
           || "dayPeriod" in e;
   }
   function isTemporalObject(e){
    return IsTemporalDate(e) || IsTemporalTime(e) || IsTemporalDateTime(e)
           || IsTemporalZonedDateTime(e)
           || IsTemporalYearMonth(e)
           || IsTemporalMonthDay(e)
           || IsTemporalInstant(e);
   }
   function sameTemporalType(e, t){
    return !
           (! isTemporalObject(e) || ! isTemporalObject(t))
           && ! (IsTemporalTime(e) && ! IsTemporalTime(t))
           && ! (IsTemporalDate(e) && ! IsTemporalDate(t))
           && ! (IsTemporalDateTime(e) && ! IsTemporalDateTime(t))
           && ! (IsTemporalZonedDateTime(e) && ! IsTemporalZonedDateTime(t))
           && ! (IsTemporalYearMonth(e) && ! IsTemporalYearMonth(t))
           && ! (IsTemporalMonthDay(e) && ! IsTemporalMonthDay(t))
           && ! (IsTemporalInstant(e) && ! IsTemporalInstant(t));
   }
   function extractOverrides(e, t){
    var r = GetIntrinsic("%Temporal.PlainDateTime%");
    if(IsTemporalTime(e)){
     var
      _o27 =
        new
         r
         (1970,
          1,
          1,
          GetSlot(e, d),
          GetSlot(e, m),
          GetSlot(e, c),
          GetSlot(e, h),
          GetSlot(e, u),
          GetSlot(e, T),
          t[nt]);
     return {instant: GetInstantFor(t[ot], _o27, "compatible"),
             formatter: getPropLazy(t, Qe)};
    }
    if(IsTemporalYearMonth(e)){
     var
      _o28 = GetSlot(e, i),
      _n17 = GetSlot(e, s),
      _a13 = GetSlot(e, l),
      _d7 = ToTemporalCalendarIdentifier(GetSlot(e, p));
     if(_d7 !== t[nt])
      throw new
             RangeError
             ("cannot format PlainYearMonth with calendar ".concat
                (_d7, " in locale with calendar ").concat
               (t[nt]));
     var _m6 = new r(_o28, _n17, _a13, 12, 0, 0, 0, 0, 0, _d7);
     return {instant: GetInstantFor(t[ot], _m6, "compatible"),
             formatter: getPropLazy(t, Ke)};
    }
    if(IsTemporalMonthDay(e)){
     var
      _o29 = GetSlot(e, i),
      _n18 = GetSlot(e, s),
      _a14 = GetSlot(e, l),
      _d8 = ToTemporalCalendarIdentifier(GetSlot(e, p));
     if(_d8 !== t[nt])
      throw new
             RangeError
             ("cannot format PlainMonthDay with calendar ".concat
                (_d8, " in locale with calendar ").concat
               (t[nt]));
     var _m7 = new r(_o29, _n18, _a14, 12, 0, 0, 0, 0, 0, _d8);
     return {instant: GetInstantFor(t[ot], _m7, "compatible"),
             formatter: getPropLazy(t, Xe)};
    }
    if(IsTemporalDate(e)){
     var
      _o30 = GetSlot(e, i),
      _n19 = GetSlot(e, s),
      _a15 = GetSlot(e, l),
      _d9 = ToTemporalCalendarIdentifier(GetSlot(e, p));
     if("iso8601" !== _d9 && _d9 !== t[nt])
      throw new
             RangeError
             ("cannot format PlainDate with calendar ".concat
                (_d9, " in locale with calendar ").concat
               (t[nt]));
     var _m8 = new r(_o30, _n19, _a15, 12, 0, 0, 0, 0, 0, t[nt]);
     return {instant: GetInstantFor(t[ot], _m8, "compatible"),
             formatter: getPropLazy(t, Je)};
    }
    if(IsTemporalDateTime(e)){
     var
      _o31 = GetSlot(e, i),
      _n20 = GetSlot(e, s),
      _a16 = GetSlot(e, l),
      _f5 = GetSlot(e, d),
      _y = GetSlot(e, m),
      _I3 = GetSlot(e, c),
      _S3 = GetSlot(e, h),
      _g2 = GetSlot(e, u),
      _w = GetSlot(e, T),
      _D = ToTemporalCalendarIdentifier(GetSlot(e, p));
     if("iso8601" !== _D && _D !== t[nt])
      throw new
             RangeError
             ("cannot format PlainDateTime with calendar ".concat
                (_D, " in locale with calendar ").concat
               (t[nt]));
     var _G = e;
     return "iso8601" === _D
            &&
             (_G = new r(_o31, _n20, _a16, _f5, _y, _I3, _S3, _g2, _w, t[nt])),
            {instant: GetInstantFor(t[ot], _G, "compatible"),
             formatter: getPropLazy(t, et)};
    }
    if(IsTemporalZonedDateTime(e))
     throw new
            TypeError
            ("Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.");
    return IsTemporalInstant(e)
            ? {instant: e, formatter: getPropLazy(t, tt)}
            : {};
   }
   var
    ut = Object.freeze({__proto__: null, DateTimeFormat: ht}),
    Instant =
      function(){
        function Instant(e){
         _classCallCheck(this, Instant);
         if(arguments.length < 1)
          throw new
                 TypeError
                 ("missing argument: epochNanoseconds is required");
         var t = ToBigInt(e);
         ValidateEpochNanoseconds(t), N(this), SetSlot(this, n, t);
        }
        _createClass
         (Instant,
          [{key: "epochSeconds",
            get:
            function(){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             var t = GetSlot(this, n);
             return Number(BigIntFloorDiv(t, ve));
            }},
           {key: "epochMilliseconds",
            get:
            function(){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             var t = BigInt(GetSlot(this, n));
             return Number(BigIntFloorDiv(t, Ge));
            }},
           {key: "epochMicroseconds",
            get:
            function(){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return ToBigIntExternal
                     (BigIntFloorDiv(BigInt(GetSlot(this, n)), De));
            }},
           {key: "epochNanoseconds",
            get:
            function(){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return ToBigIntExternal(BigInt(GetSlot(this, n)));
            }},
           {key: "add",
            value:
            function(e){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromInstant("add", this, e);
            }},
           {key: "subtract",
            value:
            function(e){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromInstant
                     ("subtract", this, e);
            }},
           {key: "until",
            value:
            function(e, t){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalInstant("until", this, e, t);
            }},
           {key: "since",
            value:
            function(e, t){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalInstant("since", this, e, t);
            }},
           {key: "round",
            value:
            function(e){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             if(void 0 === e)
              throw new TypeError("options parameter is required");
             var
              t =
                "string" == typeof e
                 ? CreateOnePropObject("smallestUnit", e)
                 : GetOptionsObject(e),
              r = ToTemporalRoundingIncrement(t),
              o = ToTemporalRoundingMode(t, "halfExpand"),
              a = GetTemporalUnit(t, "smallestUnit", "time", He);
             ValidateTemporalRoundingIncrement
              (r,
               {hour: 24,
                 minute: 1440,
                 second: 86400,
                 millisecond: 864e5,
                 microsecond: 864e8,
                 nanosecond: 864e11}
                [a],
               ! 0);
             var i = RoundInstant(GetSlot(this, n), r, a, o);
             return new Instant(i);
            }},
           {key: "equals",
            value:
            function(t){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             var
              r = ToTemporalInstant(t),
              o = GetSlot(this, n),
              a = GetSlot(r, n);
             return BigInt(o) === BigInt(a);
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             var
              t = GetOptionsObject(e),
              r = ToFractionalSecondDigits(t),
              o = ToTemporalRoundingMode(t, "trunc"),
              a = GetTemporalUnit(t, "smallestUnit", "time", void 0);
             if("hour" === a)
              throw new
                     RangeError
                     ('smallestUnit must be a time unit other than "hour"');
             var i = t.timeZone;
             void 0 !== i && (i = ToTemporalTimeZoneSlotValue(i));
             var
              _ToSecondsStringPreci = ToSecondsStringPrecisionRecord(a, r),
              s = _ToSecondsStringPreci.precision,
              l = _ToSecondsStringPreci.unit,
              d = _ToSecondsStringPreci.increment,
              m = RoundInstant(GetSlot(this, n), d, l, o);
             return TemporalInstantToString(new Instant(m), i, s);
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return TemporalInstantToString(this, void 0, "auto");
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             return new ht(e, t).format(this);
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use compare() or equals() to compare Temporal.Instant");
            }},
           {key: "toZonedDateTime",
            value:
            function(e){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e))
              throw new TypeError("invalid argument in toZonedDateTime");
             var t = e.calendar;
             if(void 0 === t)
              throw new
                     TypeError
                     ("missing calendar property in toZonedDateTime");
             var r = ToTemporalCalendarSlotValue(t), o = e.timeZone;
             if(void 0 === o)
              throw new
                     TypeError
                     ("missing timeZone property in toZonedDateTime");
             var a = ToTemporalTimeZoneSlotValue(o);
             return CreateTemporalZonedDateTime(GetSlot(this, n), a, r);
            }},
           {key: "toZonedDateTimeISO",
            value:
            function(e){
             if(! IsTemporalInstant(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalTimeZoneSlotValue(e);
             return CreateTemporalZonedDateTime
                     (GetSlot(this, n), t, "iso8601");
            }}],
          [{key: "fromEpochSeconds",
            value:
            function(t){
             var r = ToNumber(t), o = BigInt(r) * ve;
             return ValidateEpochNanoseconds(o), new Instant(o);
            }},
           {key: "fromEpochMilliseconds",
            value:
            function(t){
             var r = ToNumber(t), o = BigInt(r) * Ge;
             return ValidateEpochNanoseconds(o), new Instant(o);
            }},
           {key: "fromEpochMicroseconds",
            value:
            function(t){
             var r = ToBigInt(t), o = r * De;
             return ValidateEpochNanoseconds(o), new Instant(o);
            }},
           {key: "fromEpochNanoseconds",
            value:
            function(e){
             var t = ToBigInt(e);
             return ValidateEpochNanoseconds(t), new Instant(t);
            }},
           {key: "from",
            value:
            function(e){
             return IsTemporalInstant(e)
                     ? new Instant(GetSlot(e, n))
                     : ToTemporalInstant(e);
            }},
           {key: "compare",
            value:
            function(t, r){
             var
              o = ToTemporalInstant(t),
              a = ToTemporalInstant(r),
              i = GetSlot(o, n),
              s = GetSlot(a, n);
             return i < s ? - 1 : i > s ? 1 : 0;
            }}]);
        return Instant;
       }
       ();
   MakeIntrinsicClass(Instant, "Temporal.Instant");
   var
    Tt = Array.prototype.includes,
    pt = Array.prototype.push,
    ft = globalThis.Intl.DateTimeFormat,
    yt = Array.prototype.sort,
    It = Math.abs,
    St = Math.floor,
    gt = Object.create,
    wt = Object.entries,
    Dt = Set,
    Gt = Reflect.ownKeys,
    vt = Set.prototype.add,
    Ct = Set.prototype.values,
    Ot = {},
    Calendar =
      function(){
        function Calendar(e){
         _classCallCheck(this, Calendar);
         if(arguments.length < 1)
          throw new RangeError("missing argument: id is required");
         var t = ToString(e);
         if(! IsBuiltinCalendar(t))
          throw new RangeError("invalid calendar identifier ".concat(t));
         N(this), SetSlot(this, F, ASCIILowercase(t));
        }
        _createClass
         (Calendar,
          [{key: "id",
            get:
            function(){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, F);
            }},
           {key: "dateFromFields",
            value:
            function(e, t){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid fields");
             var r = GetOptionsObject(t), o = GetSlot(this, F);
             return Ot[o].dateFromFields(e, r, o);
            }},
           {key: "yearMonthFromFields",
            value:
            function(e, t){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid fields");
             var r = GetOptionsObject(t), o = GetSlot(this, F);
             return Ot[o].yearMonthFromFields(e, r, o);
            }},
           {key: "monthDayFromFields",
            value:
            function(e, t){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid fields");
             var r = GetOptionsObject(t), o = GetSlot(this, F);
             return Ot[o].monthDayFromFields(e, r, o);
            }},
           {key: "fields",
            value:
            function(e){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var
              t = [],
              r =
                new
                 Set
                 (["year",
                   "month",
                   "monthCode",
                   "day",
                   "hour",
                   "minute",
                   "second",
                   "millisecond",
                   "microsecond",
                   "nanosecond"]),
              _iterator15 = _createForOfIteratorHelper(e),
              _step15;
             try{
              for(_iterator15.s(); ! (_step15 = _iterator15.n()).done;){
               var _o32 = _step15.value;
               if("string" != typeof _o32)
                throw new TypeError("invalid fields");
               if(! r.has(_o32))
                throw new RangeError("invalid field name ".concat(_o32));
               r["delete"](_o32), pt.call(t, _o32);
              }
             }
             catch(err){_iterator15.e(err);}
             finally{_iterator15.f();}
             return Ot[GetSlot(this, F)].fields(t);
            }},
           {key: "mergeFields",
            value:
            function(e, t){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var r = ToObject(e), o = gt(null);
             CopyDataProperties(o, r, [], [void 0]);
             var n = ToObject(t), a = gt(null);
             CopyDataProperties(a, n, [], [void 0]);
             var
              i = Gt(a),
              s = Ot[GetSlot(this, F)].fieldKeysToIgnore(i),
              l = gt(null),
              d = Gt(o),
              _iterator16 = _createForOfIteratorHelper(d),
              _step16;
             try{
              for(_iterator16.s(); ! (_step16 = _iterator16.n()).done;){
               var _e35 = _step16.value, _t42 = void 0;
               _t42 = Call(Tt, s, [_e35]) ? a[_e35] : o[_e35],
               void 0 !== _t42 && (l[_e35] = _t42);
              }
             }
             catch(err){_iterator16.e(err);}
             finally{_iterator16.f();}
             return CopyDataProperties(l, a, []), l;
            }},
           {key: "dateAdd",
            value:
            function(e, t, r){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var
              o = ToTemporalDate(e),
              n = ToTemporalDuration(t),
              a = ToTemporalOverflow(GetOptionsObject(r)),
              _BalanceDuration10 =
                BalanceDuration
                 (GetSlot(n, v),
                  GetSlot(n, C),
                  GetSlot(n, O),
                  GetSlot(n, b),
                  GetSlot(n, E),
                  GetSlot(n, M),
                  GetSlot(n, R),
                  "day"),
              i = _BalanceDuration10.days,
              s = GetSlot(this, F);
             return Ot[s].dateAdd
                     (o, GetSlot(n, w), GetSlot(n, D), GetSlot(n, G), i, a, s);
            }},
           {key: "dateUntil",
            value:
            function(e, t, r){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var
              o = ToTemporalDate(e),
              n = ToTemporalDate(t),
              a =
                GetTemporalUnit
                 (GetOptionsObject(r), "largestUnit", "date", "auto");
             "auto" === a && (a = "day");
             var
              _Ot$GetSlot$dateUntil = Ot[GetSlot(this, F)].dateUntil(o, n, a),
              i = _Ot$GetSlot$dateUntil.years,
              s = _Ot$GetSlot$dateUntil.months,
              l = _Ot$GetSlot$dateUntil.weeks,
              d = _Ot$GetSlot$dateUntil.days;
             return new
                     (GetIntrinsic("%Temporal.Duration%"))
                     (i, s, l, d, 0, 0, 0, 0, 0, 0);
            }},
           {key: "year",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].year(t);
            }},
           {key: "month",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             if(IsTemporalMonthDay(t))
              throw new TypeError("use monthCode on PlainMonthDay instead");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].month(t);
            }},
           {key: "monthCode",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || IsTemporalMonthDay(t)
                    || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].monthCode(t);
            }},
           {key: "day",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalMonthDay(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].day(t);
            }},
           {key: "era",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].era(t);
            }},
           {key: "eraYear",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].eraYear(t);
            }},
           {key: "dayOfWeek",
            value:
            function(e){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDate(e);
             return Ot[GetSlot(this, F)].dayOfWeek(t);
            }},
           {key: "dayOfYear",
            value:
            function(e){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDate(e);
             return Ot[GetSlot(this, F)].dayOfYear(t);
            }},
           {key: "weekOfYear",
            value:
            function(e){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDate(e);
             return Ot[GetSlot(this, F)].weekOfYear(t);
            }},
           {key: "yearOfWeek",
            value:
            function(e){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDate(e);
             return Ot[GetSlot(this, F)].yearOfWeek(t);
            }},
           {key: "daysInWeek",
            value:
            function(e){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDate(e);
             return Ot[GetSlot(this, F)].daysInWeek(t);
            }},
           {key: "daysInMonth",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].daysInMonth(t);
            }},
           {key: "daysInYear",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].daysInYear(t);
            }},
           {key: "monthsInYear",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].monthsInYear(t);
            }},
           {key: "inLeapYear",
            value:
            function(e){
             var t = e;
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return IsTemporalYearMonth(t) || (t = ToTemporalDate(t)),
                    Ot[GetSlot(this, F)].inLeapYear(t);
            }},
           {key: "toString",
            value:
            function(){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, F);
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalCalendar(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, F);
            }}],
          [{key: "from",
            value:
            function(e){
             return ToTemporalCalendarObject(ToTemporalCalendarSlotValue(e));
            }}]);
        return Calendar;
       }
       ();
   function monthCodeNumberPart(e){
    if(! e.startsWith("M"))
     throw new
            RangeError
            ("Invalid month code: ".concat
              (e, ".  Month codes must start with M."));
    var t = + e.slice(1);
    if(isNaN(t)) throw new RangeError("Invalid month code: ".concat(e));
    return t;
   }
   function buildMonthCode(e){
    var
     t =
       arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ! 1;
    return "M".concat(e.toString().padStart(2, "0")).concat(t ? "L" : "");
   }
   function resolveNonLunisolarMonth(e, t){
    var
     r =
       arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 12,
     o = e.month,
     n = e.monthCode;
    if(void 0 === n){
     if(void 0 === o)
      throw new TypeError("Either month or monthCode are required");
     "reject" === t && RejectToRange(o, 1, r),
     "constrain" === t && (o = ConstrainToRange(o, 1, r)),
     n = buildMonthCode(o);
    }
    else{
     var _e36 = monthCodeNumberPart(n);
     if(void 0 !== o && o !== _e36)
      throw new
             RangeError
             ("monthCode ".concat(n, " and month ").concat
               (o, " must match if both are present"));
     if(n !== buildMonthCode(_e36))
      throw new RangeError("Invalid month code: ".concat(n));
     if(o = _e36, o < 1 || o > r)
      throw new RangeError("Invalid monthCode: ".concat(n));
    }
    return _objectSpread2(_objectSpread2({}, e), {}, {month: o, monthCode: n});
   }
   MakeIntrinsicClass(Calendar, "Temporal.Calendar"),
   DefineIntrinsic("Temporal.Calendar.from", Calendar.from),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.dateAdd", Calendar.prototype.dateAdd),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.dateFromFields",
     Calendar.prototype.dateFromFields),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.dateUntil", Calendar.prototype.dateUntil),
   DefineIntrinsic("Temporal.Calendar.prototype.day", Calendar.prototype.day),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.dayOfWeek", Calendar.prototype.dayOfWeek),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.dayOfYear", Calendar.prototype.dayOfYear),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.daysInMonth",
     Calendar.prototype.daysInMonth),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.daysInWeek", Calendar.prototype.daysInWeek),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.daysInYear", Calendar.prototype.daysInYear),
   DefineIntrinsic("Temporal.Calendar.prototype.era", Calendar.prototype.era),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.eraYear", Calendar.prototype.eraYear),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.fields", Calendar.prototype.fields),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.inLeapYear", Calendar.prototype.inLeapYear),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.mergeFields",
     Calendar.prototype.mergeFields),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.month", Calendar.prototype.month),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.monthCode", Calendar.prototype.monthCode),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.monthDayFromFields",
     Calendar.prototype.monthDayFromFields),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.monthsInYear",
     Calendar.prototype.monthsInYear),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.weekOfYear", Calendar.prototype.weekOfYear),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.year", Calendar.prototype.year),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.yearMonthFromFields",
     Calendar.prototype.yearMonthFromFields),
   DefineIntrinsic
    ("Temporal.Calendar.prototype.yearOfWeek", Calendar.prototype.yearOfWeek),
   Ot.iso8601 =
    {dateFromFields:
     function(e, t, r){
      var
       _RegulateISODate2,
       o =
         PrepareTemporalFields
          (e, ["day", "month", "monthCode", "year"], ["year", "day"]),
       n = ToTemporalOverflow(t);
      o = resolveNonLunisolarMonth(o);
      var _o33 = o, a = _o33.year, i = _o33.month, s = _o33.day;
      return _RegulateISODate2 = RegulateISODate(a, i, s, n),
             a = _RegulateISODate2.year,
             i = _RegulateISODate2.month,
             s = _RegulateISODate2.day,
             CreateTemporalDate(a, i, s, r);
     },
     yearMonthFromFields:
     function(e, t, r){
      var
       _RegulateISOYearMonth,
       o = PrepareTemporalFields(e, ["month", "monthCode", "year"], ["year"]),
       n = ToTemporalOverflow(t);
      o = resolveNonLunisolarMonth(o);
      var _o34 = o, a = _o34.year, i = _o34.month;
      return _RegulateISOYearMonth =
              function(e, t, r){
                var o = e, n = t;
                switch(r){
                  case "reject":
                   RejectISODate(o, n, 1); break;
                  case "constrain":
                   var _ConstrainISODate2 = ConstrainISODate(o, n);
                   o = _ConstrainISODate2.year;
                   n = _ConstrainISODate2.month;
                }
                return {year: o, month: n};
               }
               (a, i, n),
             a = _RegulateISOYearMonth.year,
             i = _RegulateISOYearMonth.month,
             CreateTemporalYearMonth(a, i, r, 1);
     },
     monthDayFromFields:
     function(e, t, r){
      var
       _RegulateISODate3,
       o =
         PrepareTemporalFields
          (e, ["day", "month", "monthCode", "year"], ["day"]),
       n = ToTemporalOverflow(t);
      if(void 0 !== o.month && void 0 === o.year && void 0 === o.monthCode)
       throw new TypeError("either year or monthCode required with month");
      var a = void 0 === o.monthCode;
      o = resolveNonLunisolarMonth(o);
      var _o35 = o, i = _o35.month, s = _o35.day, l = _o35.year;
      return _RegulateISODate3 = RegulateISODate(a ? l : 1972, i, s, n),
             i = _RegulateISODate3.month,
             s = _RegulateISODate3.day,
             CreateTemporalMonthDay(i, s, r, 1972);
     },
     fields: function(e){return e;},
     fieldKeysToIgnore:
     function(e){
      var t = new Dt();
      for(var _r58 = 0; _r58 < e.length; _r58++){
       var _o36 = e[_r58];
       Call(vt, t, [_o36]),
       "month" === _o36
        ? Call(vt, t, ["monthCode"])
        : "monthCode" === _o36 && Call(vt, t, ["month"]);
      }
      return _toConsumableArray(Call(Ct, t, []));
     },
     dateAdd:
     function(e, t, r, o, n, a, d){
      var
       _AddISODate,
       m = GetSlot(e, i),
       c = GetSlot(e, s),
       h = GetSlot(e, l);
      return _AddISODate = AddISODate(m, c, h, t, r, o, n, a),
             m = _AddISODate.year,
             c = _AddISODate.month,
             h = _AddISODate.day,
             CreateTemporalDate(m, c, h, d);
     },
     dateUntil:
     function(e, t, r){
      return DifferenceISODate
              (GetSlot(e, i),
               GetSlot(e, s),
               GetSlot(e, l),
               GetSlot(t, i),
               GetSlot(t, s),
               GetSlot(t, l),
               r);
     },
     year: function(e){return GetSlot(e, i);},
     era: function(){},
     eraYear: function(){},
     month: function(e){return GetSlot(e, s);},
     monthCode: function(e){return buildMonthCode(GetSlot(e, s));},
     day: function(e){return GetSlot(e, l);},
     dayOfWeek:
     function(e){
      return DayOfWeek(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l));
     },
     dayOfYear:
     function(e){
      return DayOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l));
     },
     weekOfYear:
     function(e){
      return WeekOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l)).week;
     },
     yearOfWeek:
     function(e){
      return WeekOfYear(GetSlot(e, i), GetSlot(e, s), GetSlot(e, l)).year;
     },
     daysInWeek: function(){return 7;},
     daysInMonth:
     function(e){return ISODaysInMonth(GetSlot(e, i), GetSlot(e, s));},
     daysInYear:
     function(e){
      var t = e;
      return HasSlot(t, i) || (t = ToTemporalDate(t)),
             LeapYear(GetSlot(t, i)) ? 366 : 365;
     },
     monthsInYear: function(){return 12;},
     inLeapYear:
     function(e){
      var t = e;
      return HasSlot(t, i) || (t = ToTemporalDate(t)),
             LeapYear(GetSlot(t, i));
     }};
   var
    OneObjectCache =
      function(){
        function OneObjectCache(e){
         _classCallCheck(this, OneObjectCache);
         if
          (this.map = new Map(),
           this.calls = 0,
           this.hits = 0,
           this.misses = 0,
           this.now =
            globalThis.performance ? globalThis.performance.now() : Date.now(),
           void 0 !== e){
          var
           _t43 = 0,
           _iterator17 = _createForOfIteratorHelper(e.map.entries()),
           _step17;
          try{
           for(_iterator17.s(); ! (_step17 = _iterator17.n()).done;){
            var _this$map, _r59 = _step17.value;
            if(++_t43 > OneObjectCache.MAX_CACHE_ENTRIES) break;
            (_this$map = this.map).set.apply
             (_this$map, _toConsumableArray(_r59));
           }
          }
          catch(err){_iterator17.e(err);}
          finally{_iterator17.f();}
         }
        }
        _createClass
         (OneObjectCache,
          [{key: "get",
            value:
            function(e){
             var t = this.map.get(e);
             return t && (this.hits++, this.report()), this.calls++, t;
            }},
           {key: "set",
            value:
            function(e, t){this.map.set(e, t), this.misses++, this.report();}},
           {key: "report", value: function(){}},
           {key: "setObject",
            value:
            function(e){
             if(OneObjectCache.objectMap.get(e))
              throw new RangeError("object already cached");
             OneObjectCache.objectMap.set(e, this), this.report();
            }}],
          [{key: "getCacheForObject",
            value:
            function(e){
             var t = OneObjectCache.objectMap.get(e);
             return t
                    ||
                     (t = new OneObjectCache(),
                      OneObjectCache.objectMap.set(e, t)),
                    t;
            }}]);
        return OneObjectCache;
       }
       ();
   function toUtcIsoDateString(_ref8){
    var e = _ref8.isoYear, t = _ref8.isoMonth, r = _ref8.isoDay;
    return "".concat(ISOYearString(e), "-").concat
             (ISODateTimePartString(t), "-").concat
            (ISODateTimePartString(r), "T00:00Z");
   }
   function simpleDateDiff(e, t){
    return {years: e.year - t.year,
            months: e.month - t.month,
            days: e.day - t.day};
   }
   OneObjectCache.objectMap = new WeakMap(),
   OneObjectCache.MAX_CACHE_ENTRIES = 1e3;
   var
    HelperBase =
      function(){
        function HelperBase(){
         _classCallCheck(this, HelperBase);
         this.eraLength = "short",
         this.hasEra = ! 0,
         this.erasBeginMidYear = ! 1;
        }
        _createClass
         (HelperBase,
          [{key: "getFormatter",
            value:
            function(){
             return void 0 === this.formatter
                    &&
                     (this.formatter =
                      new
                       ft
                       ("en-US-u-ca-".concat(this.id),
                        {day: "numeric",
                         month: "numeric",
                         year: "numeric",
                         era: this.eraLength,
                         timeZone: "UTC"})),
                    this.formatter;
            }},
           {key: "isoToCalendarDate",
            value:
            function(e, t){
             var
              _this = this,
              r = e.year,
              o = e.month,
              n = e.day,
              a =
                JSON.stringify
                 ({func: "isoToCalendarDate",
                   isoYear: r,
                   isoMonth: o,
                   isoDay: n,
                   id: this.id}),
              i = t.get(a);
             if(i) return i;
             var s = this.getFormatter(), l, d;
             try{
              d = toUtcIsoDateString({isoYear: r, isoMonth: o, isoDay: n}),
              l = s.formatToParts(new Date(d));
             }
             catch(e){
              throw new
                     RangeError
                     ("Invalid ISO date: ".concat
                       (JSON.stringify({isoYear: r, isoMonth: o, isoDay: n})));
             }
             var m = {}, _iterator18 = _createForOfIteratorHelper(l), _step18;
             try{
              for(_iterator18.s(); ! (_step18 = _iterator18.n()).done;){
               var
                _step18$value = _step18.value,
                _e37 = _step18$value.type,
                _t45 = _step18$value.value;
               if
                ("year" === _e37 && (m.eraYear = + _t45),
                 "relatedYear" === _e37 && (m.eraYear = + _t45),
                 "month" === _e37){
                var _e38 = /^([0-9]*)(.*?)$/.exec(_t45);
                if(! _e38 || 3 != _e38.length || ! _e38[1] && ! _e38[2])
                 throw new RangeError("Unexpected month: ".concat(_t45));
                if(m.month = _e38[1] ? + _e38[1] : 1, m.month < 1)
                 throw new
                        RangeError
                        ("Invalid month ".concat(_t45, " from ").concat(d, "[u-ca-").concat
                          (this.id,
                           "] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)"));
                if(m.month > 13)
                 throw new
                        RangeError
                        ("Invalid month ".concat(_t45, " from ").concat(d, "[u-ca-").concat
                          (this.id,
                           "] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)"));
                _e38[2] && (m.monthExtra = _e38[2]);
               }
               "day" === _e37 && (m.day = + _t45),
               this.hasEra && "era" === _e37 && null != _t45 && "" !== _t45
               &&
                (_t45 = _t45.split(" (")[0],
                 m.era =
                  _t45.normalize("NFD").replace
                     (/(?:[\0-\x1F!-,\.\/:-@\[-`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u036F\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482-\u0489\u0530\u0557\u0558\u055A-\u055F\u0589-\u05CF\u05EB-\u05EE\u05F3-\u061F\u064B-\u066D\u0670\u06D4\u06D6-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u06FD\u06FE\u0700-\u070F\u0711\u0730-\u074C\u07A6-\u07B0\u07B2-\u07C9\u07EB-\u07F3\u07F6-\u07F9\u07FB-\u07FF\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u083F\u0859-\u085F\u086B-\u086F\u0888\u088F-\u089F\u08CA-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962-\u0970\u0981-\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA-\u09BC\u09BE-\u09CD\u09CF-\u09DB\u09DE\u09E2-\u09EF\u09F2-\u09FB\u09FD-\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A-\u0A58\u0A5D\u0A5F-\u0A71\u0A75-\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA-\u0ABC\u0ABE-\u0ACF\u0AD1-\u0ADF\u0AE2-\u0AF8\u0AFA-\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A-\u0B3C\u0B3E-\u0B5B\u0B5E\u0B62-\u0B70\u0B72-\u0B82\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BCF\u0BD1-\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C3E-\u0C57\u0C5B\u0C5C\u0C5E\u0C5F\u0C62-\u0C7F\u0C81-\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA-\u0CBC\u0CBE-\u0CDC\u0CDF\u0CE2-\u0CF0\u0CF3-\u0D03\u0D0D\u0D11\u0D3B\u0D3C\u0D3E-\u0D4D\u0D4F-\u0D53\u0D57-\u0D5E\u0D62-\u0D79\u0D80-\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0E00\u0E31\u0E34-\u0E3F\u0E47-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EB1\u0EB4-\u0EBC\u0EBE\u0EBF\u0EC5\u0EC7-\u0EDB\u0EE0-\u0EFF\u0F01-\u0F3F\u0F48\u0F6D-\u0F87\u0F8D-\u0FFF\u102B-\u103E\u1040-\u104F\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16F0\u16F9-\u16FF\u1712-\u171E\u1732-\u173F\u1752-\u175F\u176D\u1771-\u177F\u17B4-\u17D6\u17D8-\u17DB\u17DD-\u181F\u1879-\u187F\u1885\u1886\u18A9\u18AB-\u18AF\u18F6-\u18FF\u191F-\u194F\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19FF\u1A17-\u1A1F\u1A55-\u1AA6\u1AA8-\u1B04\u1B34-\u1B44\u1B4D-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BFF\u1C24-\u1C4C\u1C50-\u1C59\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1CFB-\u1CFF\u1DC0-\u1DFF\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u2182\u2185-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7F\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF-\u2E2E\u2E30-\u3004\u3007-\u3030\u3036-\u303A\u303D-\u3040\u3097-\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA620-\uA629\uA62C-\uA63F\uA66F-\uA67E\uA69E\uA69F\uA6E6-\uA716\uA720\uA721\uA789\uA78A\uA7CB-\uA7CF\uA7D2\uA7D4\uA7DA-\uA7F1\uA802\uA806\uA80B\uA823-\uA83F\uA874-\uA881\uA8B4-\uA8F1\uA8F8-\uA8FA\uA8FC\uA8FF-\uA909\uA926-\uA92F\uA947-\uA95F\uA97D-\uA983\uA9B3-\uA9CE\uA9D0-\uA9DF\uA9E5\uA9F0-\uA9F9\uA9FF\uAA29-\uAA3F\uAA43\uAA4C-\uAA5F\uAA77-\uAA79\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAC3-\uAADA\uAADE\uAADF\uAAEB-\uAAF1\uAAF5-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABE3-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB1E\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFE6F\uFE75\uFEFD-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEFF\uDF20-\uDF2C\uDF41\uDF4A-\uDF4F\uDF76-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0-\uDFFF]|\uD801[\uDC9E-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6F\uDD7B\uDD8B\uDD93\uDD96\uDDA2\uDDB2\uDDBA\uDDBD-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDF7F\uDF86\uDFB1\uDFBB-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE01-\uDE0F\uDE14\uDE18\uDE36-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE5-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD24-\uDE7F\uDEAA-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF46-\uDF6F\uDF82-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC00-\uDC02\uDC38-\uDC70\uDC73\uDC74\uDC76-\uDC82\uDCB0-\uDCCF\uDCE9-\uDD02\uDD27-\uDD43\uDD45\uDD46\uDD48-\uDD4F\uDD73-\uDD75\uDD77-\uDD82\uDDB3-\uDDC0\uDDC5-\uDDD9\uDDDB\uDDDD-\uDDFF\uDE12\uDE2C-\uDE3E\uDE41-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEDF-\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A-\uDF3C\uDF3E-\uDF4F\uDF51-\uDF5C\uDF62-\uDFFF]|\uD805[\uDC35-\uDC46\uDC4B-\uDC5E\uDC62-\uDC7F\uDCB0-\uDCC3\uDCC6\uDCC8-\uDD7F\uDDAF-\uDDD7\uDDDC-\uDDFF\uDE30-\uDE43\uDE45-\uDE7F\uDEAB-\uDEB7\uDEB9-\uDEFF\uDF1B-\uDF3F\uDF47-\uDFFF]|\uD806[\uDC2C-\uDC9F\uDCE0-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD30-\uDD3E\uDD40\uDD42-\uDD9F\uDDA8\uDDA9\uDDD1-\uDDE0\uDDE2\uDDE4-\uDDFF\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE4F\uDE51-\uDE5B\uDE8A-\uDE9C\uDE9E-\uDEAF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC2F-\uDC3F\uDC41-\uDC71\uDC90-\uDCFF\uDD07\uDD0A\uDD31-\uDD45\uDD47-\uDD5F\uDD66\uDD69\uDD8A-\uDD97\uDD99-\uDEDF\uDEF3-\uDF01\uDF03\uDF11\uDF34-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC00-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80E-\uD810\uD812-\uD819\uD824-\uD82A\uD82D\uD82E\uD830-\uD834\uD836\uD83C-\uD83F\uD87C\uD87D\uD87F\uD889-\uDBFF][\uDC00-\uDFFF]|\uD80B[\uDC00-\uDF8F\uDFF1-\uDFFF]|\uD80D[\uDC30-\uDC40\uDC47-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F-\uDE6F\uDEBF-\uDECF\uDEEE-\uDEFF\uDF30-\uDF3F\uDF44-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4F\uDF51-\uDF92\uDFA0-\uDFDF\uDFE2\uDFE4-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82B[\uDC00-\uDFEF\uDFF4\uDFFC\uDFFF]|\uD82C[\uDD23-\uDD31\uDD33-\uDD4F\uDD53\uDD54\uDD56-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC-\uDFFF]|\uD837[\uDC00-\uDEFF\uDF1F-\uDF24\uDF2B-\uDFFF]|\uD838[\uDC00-\uDC2F\uDC6E-\uDCFF\uDD2D-\uDD36\uDD3E-\uDD4D\uDD4F-\uDE8F\uDEAE-\uDEBF\uDEEC-\uDFFF]|\uD839[\uDC00-\uDCCF\uDCEC-\uDFDF\uDFE7\uDFEC\uDFEF\uDFFF]|\uD83A[\uDCC5-\uDCFF\uDD44-\uDD4A\uDD4C-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD869[\uDEE0-\uDEFF]|\uD86D[\uDF3A-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFEF]|\uD87B[\uDE5E-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDF4F]|\uD888[\uDFB0-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
                      "").replace
                    (" ", "-").toLowerCase
                   ());
              }
             }
             catch(err){_iterator18.e(err);}
             finally{_iterator18.f();}
             if(void 0 === m.eraYear)
              throw new
                     RangeError
                     ("Intl.DateTimeFormat.formatToParts lacks relatedYear in ".concat
                       (this.id, " calendar. Try Node 14+ or modern browsers."));
             if(this.reviseIntlEra){
              var
               _this$reviseIntlEra = this.reviseIntlEra(m, e),
               _t44 = _this$reviseIntlEra.era,
               _r60 = _this$reviseIntlEra.eraYear;
              m.era = _t44, m.eraYear = _r60;
             }
             this.checkIcuBugs && this.checkIcuBugs(e);
             var c = this.adjustCalendarDate(m, t, "constrain", ! 0);
             if(void 0 === c.year)
              throw new
                     RangeError
                     ("Missing year converting ".concat(JSON.stringify(e)));
             if(void 0 === c.month)
              throw new
                     RangeError
                     ("Missing month converting ".concat(JSON.stringify(e)));
             if(void 0 === c.day)
              throw new
                     RangeError
                     ("Missing day converting ".concat(JSON.stringify(e)));
             return t.set(a, c),
                    ["constrain", "reject"].forEach
                     (function(r){
                       var
                        o =
                          JSON.stringify
                           ({func: "calendarToIsoDate",
                             year: c.year,
                             month: c.month,
                             day: c.day,
                             overflow: r,
                             id: _this.id});
                       t.set(o, e);
                      }),
                    c;
            }},
           {key: "validateCalendarDate",
            value:
            function(e){
             var
              t = e.era,
              r = e.month,
              o = e.year,
              n = e.day,
              a = e.eraYear,
              i = e.monthCode,
              s = e.monthExtra;
             if(void 0 !== s)
              throw new RangeError("Unexpected `monthExtra` value");
             if(void 0 === o && void 0 === a)
              throw new TypeError("year or eraYear is required");
             if(void 0 === r && void 0 === i)
              throw new TypeError("month or monthCode is required");
             if(void 0 === n) throw new RangeError("Missing day");
             if(void 0 !== i){
              if("string" != typeof i)
               throw new
                      RangeError
                      ("monthCode must be a string, not " + _typeof(i));
              if(! /^M([01]?\d)(L?)$/.test(i))
               throw new RangeError("Invalid monthCode: ".concat(i));
             }
             if(this.constantEra){
              if(void 0 !== t && t !== this.constantEra)
               throw new
                      RangeError
                      ("era must be ".concat(this.constantEra, ", not ").concat(t));
              if(void 0 !== a && void 0 !== o && a !== o)
               throw new
                      RangeError
                      ("eraYear ".concat(a, " does not match year ").concat(o));
             }
             if(this.hasEra && void 0 === e.era != (void 0 === e.eraYear))
              throw new
                     RangeError
                     ("properties 'era' and 'eraYear' must be provided together");
            }},
           {key: "adjustCalendarDate",
            value:
            function(e, t){
             var
              _resolveNonLunisolarM,
              r =
                arguments.length > 2 && arguments[2] !== undefined
                 ? arguments[2]
                 : "constrain";
             if("lunisolar" === this.calendarType)
              throw new
                     RangeError
                     ("Override required for lunisolar calendars");
             var n = e;
             if(this.validateCalendarDate(n), this.constantEra){
              var _n21 = n, _e39 = _n21.year, _t46 = _n21.eraYear;
              n =
               _objectSpread2
                (_objectSpread2({}, n),
                 {},
                 {era: this.constantEra,
                  year: void 0 !== _e39 ? _e39 : _t46,
                  eraYear: void 0 !== _t46 ? _t46 : _e39});
             }
             var
              a = this.monthsInYear(n, t),
              _n22 = n,
              i = _n22.month,
              s = _n22.monthCode;
             return _resolveNonLunisolarM = resolveNonLunisolarMonth(n, r, a),
                    i = _resolveNonLunisolarM.month,
                    s = _resolveNonLunisolarM.monthCode,
                    _objectSpread2
                     (_objectSpread2({}, n), {}, {month: i, monthCode: s});
            }},
           {key: "regulateMonthDayNaive",
            value:
            function(e, t, r){
             var o = this.monthsInYear(e, r), n = e.month, a = e.day;
             return "reject" === t
                     ? (RejectToRange
                        (n, 1, o),
                       RejectToRange(a, 1, this.maximumMonthLength(e)))
                     : (n
                       = ConstrainToRange(n, 1, o),
                       a =
                        ConstrainToRange
                         (a,
                          1,
                          this.maximumMonthLength
                           (_objectSpread2(_objectSpread2({}, e), {}, {month: n})))),
                    _objectSpread2
                     (_objectSpread2({}, e), {}, {month: n, day: a});
            }},
           {key: "calendarToIsoDate",
            value:
            function(e){
             var
              _this2 = this,
              t =
                arguments.length > 1 && arguments[1] !== undefined
                 ? arguments[1]
                 : "constrain",
              r = arguments.length > 2 ? arguments[2] : undefined,
              o = e,
              n = this.adjustCalendarDate(e, r, t, ! 1);
             n = this.regulateMonthDayNaive(n, t, r);
             var
              _n23 = n,
              a = _n23.year,
              i = _n23.month,
              s = _n23.day,
              l =
                JSON.stringify
                 ({func: "calendarToIsoDate",
                   year: a,
                   month: i,
                   day: s,
                   overflow: t,
                   id: this.id}),
              d,
              m = r.get(l);
             if(m) return m;
             if
              (void 0 !== o.year && void 0 !== o.month && void 0 !== o.day
               &&
                (o.year !== n.year || o.month !== n.month || o.day !== n.day)
               &&
                (d =
                  JSON.stringify
                   ({func: "calendarToIsoDate",
                     year: o.year,
                     month: o.month,
                     day: o.day,
                     overflow: t,
                     id: this.id}),
                 m = r.get(d),
                 m))
              return m;
             var
              c = this.estimateIsoDate({year: a, month: i, day: s}),
              calculateSameMonthResult =
                function(e){
                 var o = _this2.addDaysIso(c, e);
                 if(n.day > _this2.minimumMonthLength(n)){
                  var _e40 = _this2.isoToCalendarDate(o, r);
                  for(; _e40.month !== i || _e40.year !== a;){
                   if("reject" === t)
                    throw new
                           RangeError
                           ("day ".concat(s, " does not exist in month ").concat
                              (i, " of year ").concat
                             (a));
                   o = _this2.addDaysIso(o, - 1),
                   _e40 = _this2.isoToCalendarDate(o, r);
                  }
                 }
                 return o;
                },
              h = 0,
              u = this.isoToCalendarDate(c, r),
              T = simpleDateDiff(n, u);
             if(0 !== T.years || 0 !== T.months || 0 !== T.days){
              var _e41 = 365 * T.years + 30 * T.months + T.days;
              c = this.addDaysIso(c, _e41),
              u = this.isoToCalendarDate(c, r),
              T = simpleDateDiff(n, u),
              0 === T.years && 0 === T.months
               ? c = calculateSameMonthResult(T.days)
               : h = this.compareCalendarDates(n, u);
             }
             var p = 8;
             for(; h;){
              c = this.addDaysIso(c, h * p);
              var _e42 = u;
              u = this.isoToCalendarDate(c, r);
              var _a17 = h;
              if(h = this.compareCalendarDates(n, u), h)
               if(T = simpleDateDiff(n, u), 0 === T.years && 0 === T.months)
                c = calculateSameMonthResult(T.days), h = 0;
               else if(_a17 && h !== _a17)
                if(p > 1)
                 p /= 2;
                else{
                 if("reject" === t)
                  throw new
                         RangeError
                         ("Can't find ISO date from calendar date: ".concat
                           (JSON.stringify(_objectSpread2({}, o))));
                 this.compareCalendarDates(u, _e42) > 0
                 && (c = this.addDaysIso(c, - 1)),
                 h = 0;
                }
             }
             if
              (r.set(l, c),
               d && r.set(d, c),
               void 0 === n.year || void 0 === n.month || void 0 === n.day
               || void 0 === n.monthCode
               || this.hasEra && (void 0 === n.era || void 0 === n.eraYear))
              throw new RangeError("Unexpected missing property");
             return c;
            }},
           {key: "temporalToCalendarDate",
            value:
            function(e, t){
             var
              r =
                {year: GetSlot(e, i),
                 month: GetSlot(e, s),
                 day: GetSlot(e, l)};
             return this.isoToCalendarDate(r, t);
            }},
           {key: "compareCalendarDates",
            value:
            function(e, t){
             var
              r =
                PrepareTemporalFields
                 (e, ["day", "month", "year"], ["day", "month", "year"]),
              o =
                PrepareTemporalFields
                 (t, ["day", "month", "year"], ["day", "month", "year"]);
             return r.year !== o.year
                     ? ComparisonResult(r.year - o.year)
                     : r.month
                       !== o.month
                       ? ComparisonResult(r.month - o.month)
                       : r.day !== o.day ? ComparisonResult(r.day - o.day) : 0;
            }},
           {key: "regulateDate",
            value:
            function(e){
             var
              t =
                arguments.length > 1 && arguments[1] !== undefined
                 ? arguments[1]
                 : "constrain",
              r = arguments.length > 2 ? arguments[2] : undefined,
              o = this.calendarToIsoDate(e, t, r);
             return this.isoToCalendarDate(o, r);
            }},
           {key: "addDaysIso",
            value:
            function(e, t){
             return AddISODate
                     (e.year, e.month, e.day, 0, 0, 0, t, "constrain");
            }},
           {key: "addDaysCalendar",
            value:
            function(e, t, r){
             var
              o = this.calendarToIsoDate(e, "constrain", r),
              n = this.addDaysIso(o, t);
             return this.isoToCalendarDate(n, r);
            }},
           {key: "addMonthsCalendar",
            value:
            function(e, t, r, o){
             var n = e, _n24 = n, a = _n24.day;
             for(var _e43 = 0, _r61 = It(t); _e43 < _r61; _e43++){
              var
               _n25 = n,
               _e44 = _n25.month,
               _r62 = n,
               _i18 =
                 t < 0
                  ? - Math.max(a, this.daysInPreviousMonth(n, o))
                  : this.daysInMonth(n, o),
               _s7 = this.calendarToIsoDate(n, "constrain", o),
               _l7 = this.addDaysIso(_s7, _i18);
              if(n = this.isoToCalendarDate(_l7, o), t > 0){
               var _t47 = this.monthsInYear(_r62, o);
               for(; n.month - 1 != _e44 % _t47;)
                _l7 = this.addDaysIso(_l7, - 1),
                n = this.isoToCalendarDate(_l7, o);
              }
              n.day !== a
              &&
               (n =
                this.regulateDate
                 (_objectSpread2(_objectSpread2({}, n), {}, {day: a}),
                  "constrain",
                  o));
             }
             if("reject" === r && n.day !== a)
              throw new
                     RangeError
                     ("Day ".concat
                       (a, " does not exist in resulting calendar month"));
             return n;
            }},
           {key: "addCalendar",
            value:
            function(e, _ref9, a, i){
             var
              _ref9$years = _ref9.years,
              t = _ref9$years === void 0 ? 0 : _ref9$years,
              _ref9$months = _ref9.months,
              r = _ref9$months === void 0 ? 0 : _ref9$months,
              _ref9$weeks = _ref9.weeks,
              o = _ref9$weeks === void 0 ? 0 : _ref9$weeks,
              _ref9$days = _ref9.days,
              n = _ref9$days === void 0 ? 0 : _ref9$days,
              s = e.year,
              l = e.day,
              d = e.monthCode,
              m =
                this.adjustCalendarDate
                 ({year: s + t, monthCode: d, day: l}, i),
              c = this.addMonthsCalendar(m, r, a, i),
              h = n + 7 * o;
             return this.addDaysCalendar(c, h, i);
            }},
           {key: "untilCalendar",
            value:
            function(e, t, r, o){
             var n = 0, a = 0, i = 0, s = 0;
             switch(r){
               case "day":
                n = this.calendarDaysUntil(e, t, o); break;
               case "week":
                {
                 var _r63 = this.calendarDaysUntil(e, t, o);
                 n = _r63 % 7, a = (_r63 - n) / 7;
                 break;
                }
               case "month":
               case "year":
                {
                 var _a18 = this.compareCalendarDates(t, e);
                 if(! _a18) return {years: 0, months: 0, weeks: 0, days: 0};
                 var _l8 = t.year - e.year, _d10 = t.day - e.day;
                 if("year" === r && _l8){
                  var _r64 = 0;
                  t.monthCode > e.monthCode && (_r64 = 1),
                  t.monthCode < e.monthCode && (_r64 = - 1),
                  _r64 || (_r64 = Math.sign(_d10));
                  s = _r64 * _a18 < 0 ? _l8 - _a18 : _l8;
                 }
                 var
                  _m9,
                  _c5 =
                    s ? this.addCalendar(e, {years: s}, "constrain", o) : e;
                 do
                  i += _a18,
                  _m9 = _c5,
                  _c5 = this.addMonthsCalendar(_m9, _a18, "constrain", o),
                  _c5.day !== e.day
                  &&
                   (_c5 =
                    this.regulateDate
                     (_objectSpread2(_objectSpread2({}, _c5), {}, {day: e.day}),
                      "constrain",
                      o));
                 while
                  (this.compareCalendarDates(t, _c5) * _a18 >= 0);
                 i -= _a18;
                 n = this.calendarDaysUntil(_m9, t, o);
                 break;
                }
             }
             return {years: s, months: i, weeks: a, days: n};
            }},
           {key: "daysInMonth",
            value:
            function(e, t){
             var
              r = e.day,
              o = this.maximumMonthLength(e),
              n = this.minimumMonthLength(e);
             if(n === o) return n;
             var
              a = r <= o - n ? o : n,
              i = this.calendarToIsoDate(e, "constrain", t),
              s = this.addDaysIso(i, a),
              l = this.isoToCalendarDate(s, t),
              d = this.addDaysIso(s, - l.day);
             return this.isoToCalendarDate(d, t).day;
            }},
           {key: "daysInPreviousMonth",
            value:
            function(e, t){
             var
              r = e.day,
              o = e.month,
              n = e.year,
              a = {year: o > 1 ? n : n - 1, month: o, day: 1},
              i = o > 1 ? o - 1 : this.monthsInYear(a, t);
             a = _objectSpread2(_objectSpread2({}, a), {}, {month: i});
             var
              s = this.minimumMonthLength(a),
              l = this.maximumMonthLength(a);
             if(s === l) return l;
             var
              d = this.calendarToIsoDate(e, "constrain", t),
              m = this.addDaysIso(d, - r);
             return this.isoToCalendarDate(m, t).day;
            }},
           {key: "startOfCalendarYear",
            value:
            function(e){
             return {year: e.year, month: 1, monthCode: "M01", day: 1};
            }},
           {key: "startOfCalendarMonth",
            value: function(e){return {year: e.year, month: e.month, day: 1};}},
           {key: "calendarDaysUntil",
            value:
            function(e, t, r){
             var
              o = this.calendarToIsoDate(e, "constrain", r),
              n = this.calendarToIsoDate(t, "constrain", r);
             return this.isoDaysUntil(o, n);
            }},
           {key: "isoDaysUntil",
            value:
            function(e, t){
             return DifferenceISODate
                     (e.year, e.month, e.day, t.year, t.month, t.day, "day").days;
            }},
           {key: "monthDayFromFields",
            value:
            function(e, t, r){
             var o, n, a, i, s, l = e.monthCode, d = e.day;
             if(void 0 === l){
              var _o37 = e.year, _n26 = e.era, _a19 = e.eraYear;
              if(void 0 === _o37 && (void 0 === _n26 || void 0 === _a19))
               throw new
                      TypeError
                      ("when `monthCode` is omitted, `year` (or `era` and `eraYear`) and `month` are required");
              var
               _this$isoToCalendarDa =
                 this.isoToCalendarDate(this.calendarToIsoDate(e, t, r), r);
              l = _this$isoToCalendarDa.monthCode;
              d = _this$isoToCalendarDa.day;
             }
             var
              m = this.isoToCalendarDate({year: 1972, month: 12, day: 31}, r),
              c =
                m.monthCode > l || m.monthCode === l && m.day >= d
                 ? m.year
                 : m.year - 1;
             for(var _e45 = 0; _e45 < 100; _e45++){
              var
               _m10 =
                 this.adjustCalendarDate
                  ({day: d, monthCode: l, year: c - _e45}, r),
               _h3 = this.calendarToIsoDate(_m10, "constrain", r),
               _u2 = this.isoToCalendarDate(_h3, r);
              if
               (o = _h3.year,
                n = _h3.month,
                a = _h3.day,
                _u2.monthCode === l && _u2.day === d)
               return {month: n, day: a, year: o};
              "constrain" === t
              &&
               (void 0 === i
               || _u2.monthCode === i.monthCode && _u2.day > i.day)
              && (i = _u2, s = _h3);
             }
             if("constrain" === t && void 0 !== s) return s;
             throw new
                    RangeError
                    ("No recent ".concat(this.id, " year with monthCode ").concat
                       (l, " and day ").concat
                      (d));
            }}]);
        return HelperBase;
       }
       (),
    HebrewHelper =
      function(_HelperBase){
        _inherits(HebrewHelper, _HelperBase);
        var _super = _createSuper(HebrewHelper);
        function HebrewHelper(){
         var _this3;
         _classCallCheck(this, HebrewHelper);
         _this3 = _super.apply(this, arguments),
         _this3.id = "hebrew",
         _this3.calendarType = "lunisolar",
         _this3.months =
          {Tishri: {leap: 1, regular: 1, monthCode: "M01", days: 30},
           Heshvan:
           {leap: 2, regular: 2, monthCode: "M02", days: {min: 29, max: 30}},
           Kislev:
           {leap: 3, regular: 3, monthCode: "M03", days: {min: 29, max: 30}},
           Tevet: {leap: 4, regular: 4, monthCode: "M04", days: 29},
           Shevat: {leap: 5, regular: 5, monthCode: "M05", days: 30},
           Adar: {leap: void 0, regular: 6, monthCode: "M06", days: 29},
           "Adar I": {leap: 6, regular: void 0, monthCode: "M05L", days: 30},
           "Adar II": {leap: 7, regular: void 0, monthCode: "M06", days: 29},
           Nisan: {leap: 8, regular: 7, monthCode: "M07", days: 30},
           Iyar: {leap: 9, regular: 8, monthCode: "M08", days: 29},
           Sivan: {leap: 10, regular: 9, monthCode: "M09", days: 30},
           Tamuz: {leap: 11, regular: 10, monthCode: "M10", days: 29},
           Av: {leap: 12, regular: 11, monthCode: "M11", days: 30},
           Elul: {leap: 13, regular: 12, monthCode: "M12", days: 29}},
         _this3.hasEra = ! 1;
         return _this3;
        }
        _createClass
         (HebrewHelper,
          [{key: "inLeapYear",
            value: function(e){var t = e.year; return (7 * t + 1) % 19 < 7;}},
           {key: "monthsInYear",
            value: function(e){return this.inLeapYear(e) ? 13 : 12;}},
           {key: "minimumMonthLength",
            value: function(e){return this.minMaxMonthLength(e, "min");}},
           {key: "maximumMonthLength",
            value: function(e){return this.minMaxMonthLength(e, "max");}},
           {key: "minMaxMonthLength",
            value:
            function(e, t){
             var
              r = e.month,
              o = e.year,
              n = this.getMonthCode(o, r),
              a =
                wt(this.months).find
                 (function(e){return e[1].monthCode === n;});
             if(void 0 === a)
              throw new RangeError("unmatched Hebrew month: ".concat(r));
             var i = a[1].days;
             return "number" == typeof i ? i : i[t];
            }},
           {key: "estimateIsoDate",
            value:
            function(e){
             var t = e.year;
             return {year: t - 3760, month: 1, day: 1};
            }},
           {key: "getMonthCode",
            value:
            function(e, t){
             return this.inLeapYear({year: e})
                     ? 6
                       === t
                       ? buildMonthCode(5, ! 0)
                       : buildMonthCode(t < 6 ? t : t - 1)
                     : buildMonthCode(t);
            }},
           {key: "adjustCalendarDate",
            value:
            function(e, t){
             var
              r =
                arguments.length > 2 && arguments[2] !== undefined
                 ? arguments[2]
                 : "constrain",
              o =
                arguments.length > 3 && arguments[3] !== undefined
                 ? arguments[3]
                 : ! 1,
              n = e.year,
              a = e.eraYear,
              i = e.month,
              s = e.monthCode,
              l = e.day,
              d = e.monthExtra;
             if
              (void 0 === n && void 0 !== a && (n = a),
               void 0 === a && void 0 !== n && (a = n),
               o){
              if(d){
               var _e46 = this.months[d];
               if(! _e46)
                throw new
                       RangeError
                       ("Unrecognized month from formatToParts: ".concat(d));
               i = this.inLeapYear({year: n}) ? _e46.leap : _e46.regular;
              }
              s = this.getMonthCode(n, i);
              return {year: n,
                      month: i,
                      day: l,
                      era: void 0,
                      eraYear: a,
                      monthCode: s};
             }
             if(this.validateCalendarDate(e), void 0 === i)
              if(s.endsWith("L")){
               if("M05L" !== s)
                throw new
                       RangeError
                       ("Hebrew leap month must have monthCode M05L, not ".concat
                         (s));
               if(i = 6, ! this.inLeapYear({year: n})){
                if("reject" === r)
                 throw new
                        RangeError
                        ("Hebrew monthCode M05L is invalid in year ".concat
                          (n, " which is not a leap year"));
                i = 6, s = "M06";
               }
              }
              else{
               i = monthCodeNumberPart(s),
               this.inLeapYear({year: n}) && i >= 6 && i++;
               var _e47 = this.monthsInYear({year: n});
               if(i < 1 || i > _e47)
                throw new RangeError("Invalid monthCode: ".concat(s));
              }
             else if
              ("reject" === r
                ? (RejectToRange
                   (i, 1, this.monthsInYear({year: n})),
                  RejectToRange
                   (l, 1, this.maximumMonthLength({year: n, month: i})))
                : (i
                  = ConstrainToRange(i, 1, this.monthsInYear({year: n})),
                  l =
                   ConstrainToRange
                    (l, 1, this.maximumMonthLength({year: n, month: i}))),
               void 0 === s)
              s = this.getMonthCode(n, i);
             else if(this.getMonthCode(n, i) !== s)
              throw new
                     RangeError
                     ("monthCode ".concat(s, " doesn't correspond to month ").concat
                        (i, " in Hebrew year ").concat
                       (n));
             return _objectSpread2
                     (_objectSpread2({}, e),
                      {},
                      {day: l, month: i, monthCode: s, year: n, eraYear: a});
            }}]);
        return HebrewHelper;
       }
       (HelperBase),
    IslamicBaseHelper =
      function(_HelperBase2){
        _inherits(IslamicBaseHelper, _HelperBase2);
        var _super2 = _createSuper(IslamicBaseHelper);
        function IslamicBaseHelper(){
         var _this4;
         _classCallCheck(this, IslamicBaseHelper);
         _this4 = _super2.apply(this, arguments),
         _this4.calendarType = "lunar",
         _this4.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30,
         _this4.DAYS_PER_ISO_YEAR = 365.2425,
         _this4.constantEra = "ah";
         return _this4;
        }
        _createClass
         (IslamicBaseHelper,
          [{key: "inLeapYear",
            value:
            function(e, t){
             return 30
                    === this.daysInMonth({year: e.year, month: 12, day: 1}, t);
            }},
           {key: "monthsInYear", value: function(){return 12;}},
           {key: "minimumMonthLength", value: function(){return 29;}},
           {key: "maximumMonthLength", value: function(){return 30;}},
           {key: "estimateIsoDate",
            value:
            function(e){
             var
              _this$adjustCalendarD = this.adjustCalendarDate(e),
              t = _this$adjustCalendarD.year;
             return {year:
                     St(t * this.DAYS_PER_ISLAMIC_YEAR / this.DAYS_PER_ISO_YEAR)
                     + 622,
                     month: 1,
                     day: 1};
            }}]);
        return IslamicBaseHelper;
       }
       (HelperBase),
    IslamicHelper =
      function(_IslamicBaseHelper){
        _inherits(IslamicHelper, _IslamicBaseHelper);
        var _super3 = _createSuper(IslamicHelper);
        function IslamicHelper(){
         var _this5;
         _classCallCheck(this, IslamicHelper);
         _this5 = _super3.apply(this, arguments), _this5.id = "islamic";
         return _this5;
        }
        return _createClass(IslamicHelper);
       }
       (IslamicBaseHelper),
    IslamicUmalquraHelper =
      function(_IslamicBaseHelper2){
        _inherits(IslamicUmalquraHelper, _IslamicBaseHelper2);
        var _super4 = _createSuper(IslamicUmalquraHelper);
        function IslamicUmalquraHelper(){
         var _this6;
         _classCallCheck(this, IslamicUmalquraHelper);
         _this6 = _super4.apply(this, arguments),
         _this6.id = "islamic-umalqura";
         return _this6;
        }
        return _createClass(IslamicUmalquraHelper);
       }
       (IslamicBaseHelper),
    IslamicTblaHelper =
      function(_IslamicBaseHelper3){
        _inherits(IslamicTblaHelper, _IslamicBaseHelper3);
        var _super5 = _createSuper(IslamicTblaHelper);
        function IslamicTblaHelper(){
         var _this7;
         _classCallCheck(this, IslamicTblaHelper);
         _this7 = _super5.apply(this, arguments), _this7.id = "islamic-tbla";
         return _this7;
        }
        return _createClass(IslamicTblaHelper);
       }
       (IslamicBaseHelper),
    IslamicCivilHelper =
      function(_IslamicBaseHelper4){
        _inherits(IslamicCivilHelper, _IslamicBaseHelper4);
        var _super6 = _createSuper(IslamicCivilHelper);
        function IslamicCivilHelper(){
         var _this8;
         _classCallCheck(this, IslamicCivilHelper);
         _this8 = _super6.apply(this, arguments), _this8.id = "islamic-civil";
         return _this8;
        }
        return _createClass(IslamicCivilHelper);
       }
       (IslamicBaseHelper),
    IslamicRgsaHelper =
      function(_IslamicBaseHelper5){
        _inherits(IslamicRgsaHelper, _IslamicBaseHelper5);
        var _super7 = _createSuper(IslamicRgsaHelper);
        function IslamicRgsaHelper(){
         var _this9;
         _classCallCheck(this, IslamicRgsaHelper);
         _this9 = _super7.apply(this, arguments), _this9.id = "islamic-rgsa";
         return _this9;
        }
        return _createClass(IslamicRgsaHelper);
       }
       (IslamicBaseHelper),
    IslamicCcHelper =
      function(_IslamicBaseHelper6){
        _inherits(IslamicCcHelper, _IslamicBaseHelper6);
        var _super8 = _createSuper(IslamicCcHelper);
        function IslamicCcHelper(){
         var _this10;
         _classCallCheck(this, IslamicCcHelper);
         _this10 = _super8.apply(this, arguments), _this10.id = "islamicc";
         return _this10;
        }
        return _createClass(IslamicCcHelper);
       }
       (IslamicBaseHelper),
    PersianHelper =
      function(_HelperBase3){
        _inherits(PersianHelper, _HelperBase3);
        var _super9 = _createSuper(PersianHelper);
        function PersianHelper(){
         var _this11;
         _classCallCheck(this, PersianHelper);
         _this11 = _super9.apply(this, arguments),
         _this11.id = "persian",
         _this11.calendarType = "solar",
         _this11.constantEra = "ap";
         return _this11;
        }
        _createClass
         (PersianHelper,
          [{key: "inLeapYear",
            value:
            function(e, t){
             return IslamicHelper.prototype.inLeapYear.call(this, e, t);
            }},
           {key: "monthsInYear", value: function(){return 12;}},
           {key: "minimumMonthLength",
            value:
            function(e){
             var t = e.month;
             return 12 === t ? 29 : t <= 6 ? 31 : 30;
            }},
           {key: "maximumMonthLength",
            value:
            function(e){
             var t = e.month;
             return 12 === t ? 30 : t <= 6 ? 31 : 30;
            }},
           {key: "estimateIsoDate",
            value:
            function(e){
             var
              _this$adjustCalendarD2 = this.adjustCalendarDate(e),
              t = _this$adjustCalendarD2.year;
             return {year: t + 621, month: 1, day: 1};
            }}]);
        return PersianHelper;
       }
       (HelperBase),
    IndianHelper =
      function(_HelperBase4){
        _inherits(IndianHelper, _HelperBase4);
        var _super10 = _createSuper(IndianHelper);
        function IndianHelper(){
         var _this12;
         _classCallCheck(this, IndianHelper);
         _this12 = _super10.apply(this, arguments),
         _this12.id = "indian",
         _this12.calendarType = "solar",
         _this12.constantEra = "saka",
         _this12.months =
          {1:
           {length: 30,
            month: 3,
            day: 22,
            leap: {length: 31, month: 3, day: 21}},
           2: {length: 31, month: 4, day: 21},
           3: {length: 31, month: 5, day: 22},
           4: {length: 31, month: 6, day: 22},
           5: {length: 31, month: 7, day: 23},
           6: {length: 31, month: 8, day: 23},
           7: {length: 30, month: 9, day: 23},
           8: {length: 30, month: 10, day: 23},
           9: {length: 30, month: 11, day: 22},
           10: {length: 30, month: 12, day: 22},
           11: {length: 30, month: 1, nextYear: ! 0, day: 21},
           12: {length: 30, month: 2, nextYear: ! 0, day: 20}},
         _this12.vulnerableToBceBug =
          "10/11/-79 Saka"
          !==
           new Date("0000-01-01T00:00Z").toLocaleDateString
            ("en-US-u-ca-indian", {timeZone: "UTC"});
         return _this12;
        }
        _createClass
         (IndianHelper,
          [{key: "inLeapYear",
            value: function(e){return isGregorianLeapYear(e.year + 78);}},
           {key: "monthsInYear", value: function(){return 12;}},
           {key: "minimumMonthLength",
            value: function(e){return this.getMonthInfo(e).length;}},
           {key: "maximumMonthLength",
            value: function(e){return this.getMonthInfo(e).length;}},
           {key: "getMonthInfo",
            value:
            function(e){
             var t = e.month, r = this.months[t];
             if(void 0 === r)
              throw new RangeError("Invalid month: ".concat(t));
             return this.inLeapYear(e) && r.leap && (r = r.leap), r;
            }},
           {key: "estimateIsoDate",
            value:
            function(e){
             var t = this.adjustCalendarDate(e), r = this.getMonthInfo(t);
             return AddISODate
                     (t.year + 78 + (r.nextYear ? 1 : 0),
                      r.month,
                      r.day,
                      0,
                      0,
                      0,
                      t.day - 1,
                      "constrain");
            }},
           {key: "checkIcuBugs",
            value:
            function(e){
             if(this.vulnerableToBceBug && e.year < 1)
              throw new
                     RangeError
                     ("calendar '".concat
                       (this.id,
                        "' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)"));
            }}]);
        return IndianHelper;
       }
       (HelperBase);
   function isGregorianLeapYear(e){
    return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0);
   }
   var
    GregorianBaseHelper =
      function(_HelperBase5){
        _inherits(GregorianBaseHelper, _HelperBase5);
        var _super11 = _createSuper(GregorianBaseHelper);
        function GregorianBaseHelper(e, t){
         var _this13;
         _classCallCheck(this, GregorianBaseHelper);
         _this13 = _super11.call(this),
         _this13.calendarType = "solar",
         _this13.v8IsVulnerableToJulianBug =
          new Date("+001001-01-01T00:00Z").toLocaleDateString
            ("en-US-u-ca-japanese", {timeZone: "UTC"}).startsWith
           ("12"),
         _this13.calendarIsVulnerableToJulianBug = ! 1,
         _this13.id = e;
         var
          _adjustEras =
            function(e){
              var t, r = e;
              if(0 === r.length)
               throw new RangeError("Invalid era data: eras are required");
              if(1 === r.length && r[0].reverseOf)
               throw new
                      RangeError
                      ("Invalid era data: anchor era cannot count years backwards");
              if(1 === r.length && ! r[0].name)
               throw new
                      RangeError
                      ("Invalid era data: at least one named era is required");
              if
               (r.filter(function(e){return null != e.reverseOf;}).length > 1)
               throw new
                      RangeError
                      ("Invalid era data: only one era can count years backwards");
              r.forEach
               (function(e){
                 if(e.isAnchor || ! e.anchorEpoch && ! e.reverseOf){
                  if(t)
                   throw new
                          RangeError
                          ("Invalid era data: cannot have multiple anchor eras");
                  t = e, e.anchorEpoch = {year: e.hasYearZero ? 0 : 1};
                 }
                 else if(! e.name)
                  throw new
                         RangeError
                         ("If era name is blank, it must be the anchor era");
                }),
              r = r.filter(function(e){return e.name;}),
              r.forEach
               (function(e){
                 var t = e.reverseOf;
                 if(t){
                  var _o38 = r.find(function(e){return e.name === t;});
                  if(void 0 === _o38)
                   throw new
                          RangeError
                          ("Invalid era data: unmatched reverseOf era: ".concat(t));
                  e.reverseOf = _o38,
                  e.anchorEpoch = _o38.anchorEpoch,
                  e.isoEpoch = _o38.isoEpoch;
                 }
                 void 0 === e.anchorEpoch.month && (e.anchorEpoch.month = 1),
                 void 0 === e.anchorEpoch.day && (e.anchorEpoch.day = 1);
                }),
              yt.call
               (r,
                function(e, t){
                 if(e.reverseOf) return 1;
                 if(t.reverseOf) return - 1;
                 if(! e.isoEpoch || ! t.isoEpoch)
                  throw new RangeError("Invalid era data: missing ISO epoch");
                 return t.isoEpoch.year - e.isoEpoch.year;
                });
              var o = r[r.length - 1].reverseOf;
              if(o && o !== r[r.length - 2])
               throw new
                      RangeError
                      ("Invalid era data: invalid reverse-sign era");
              return r.forEach
                      (function(e, t){e.genericName = "era" + (r.length - 1 - t);}),
                     {eras: r, anchorEra: t || r[0]};
             }
             (t),
          r = _adjustEras.eras,
          o = _adjustEras.anchorEra;
         _this13.anchorEra = o, _this13.eras = r;
         return _this13;
        }
        _createClass
         (GregorianBaseHelper,
          [{key: "inLeapYear",
            value:
            function(e){
             var
              _this$estimateIsoDate =
                this.estimateIsoDate({month: 1, day: 1, year: e.year}),
              t = _this$estimateIsoDate.year;
             return isGregorianLeapYear(t);
            }},
           {key: "monthsInYear", value: function(){return 12;}},
           {key: "minimumMonthLength",
            value:
            function(e){
             var t = e.month;
             return 2 === t
                     ? this.inLeapYear(e) ? 29 : 28
                     : [4, 6, 9, 11].indexOf(t) >= 0 ? 30 : 31;
            }},
           {key: "maximumMonthLength",
            value: function(e){return this.minimumMonthLength(e);}},
           {key: "completeEraYear",
            value:
            function(e){
             var
              _this14 = this,
              _eraFromYear,
              checkField =
                function(t, r){
                 var o = e[t];
                 if(null != o && o != r)
                  throw new
                         RangeError
                         ("Input ".concat(t, " ").concat
                            (o, " doesn't match calculated value ").concat
                           (r));
                },
              eraFromYear =
                function(t){
                 var
                  r,
                  o = _objectSpread2(_objectSpread2({}, e), {}, {year: t}),
                  n =
                    _this14.eras.find
                     (function(e, n){
                       if(n === _this14.eras.length - 1){
                        if(e.reverseOf){
                         if(t > 0)
                          throw new
                                 RangeError
                                 ("Signed year ".concat(t, " is invalid for era ").concat
                                   (e.name));
                         return r = e.anchorEpoch.year - t, ! 0;
                        }
                        return r = t - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1),
                               !
                               0;
                       }
                       return _this14.compareCalendarDates(o, e.anchorEpoch) >= 0
                              &&
                               (r = t - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1), ! 0);
                      });
                 if(! n)
                  throw new
                         RangeError
                         ("Year ".concat(t, " was not matched by any era"));
                 return {eraYear: r, era: n.name};
                },
              t = e.year,
              r = e.eraYear,
              o = e.era;
             if(null != t)
              _eraFromYear = eraFromYear(t),
              r = _eraFromYear.eraYear,
              o = _eraFromYear.era,
              checkField("era", o),
              checkField("eraYear", r);
             else{
              if(null == r)
               throw new
                      RangeError
                      ("Either `year` or `eraYear` and `era` are required");
              {
               var
                _eraFromYear2,
                _e48 =
                  void 0 === o
                   ? void 0
                   : this.eras.find
                     (function(e){return e.name === o || e.genericName === o;});
               if(! _e48)
                throw new
                       RangeError
                       ("Era ".concat(o, " (ISO year ").concat
                         (r, ") was not matched by any era"));
               if(r < 1 && _e48.reverseOf)
                throw new
                       RangeError
                       ("Years in ".concat(o, " era must be positive, not ").concat
                         (t));
               t =
                _e48.reverseOf
                 ? _e48.anchorEpoch.year - r
                 : r + _e48.anchorEpoch.year - (_e48.hasYearZero ? 0 : 1),
               checkField("year", t),
               _eraFromYear2 = eraFromYear(t),
               r = _eraFromYear2.eraYear,
               o = _eraFromYear2.era;
              }
             }
             return _objectSpread2
                     (_objectSpread2({}, e), {}, {year: t, eraYear: r, era: o});
            }},
           {key: "adjustCalendarDate",
            value:
            function(e, t){
             var
              r =
                arguments.length > 2 && arguments[2] !== undefined
                 ? arguments[2]
                 : "constrain",
              o = e,
              _o39 = o,
              n = _o39.month,
              a = _o39.monthCode;
             return void 0 === n
                    &&
                     (o =
                      _objectSpread2
                       (_objectSpread2({}, o), {}, {month: monthCodeNumberPart(a)})),
                    this.validateCalendarDate(o),
                    o = this.completeEraYear(o),
                    _get
                      (_getPrototypeOf(GregorianBaseHelper.prototype),
                       "adjustCalendarDate",
                       this).call
                     (this, o, t, r);
            }},
           {key: "estimateIsoDate",
            value:
            function(e){
             var
              t = this.adjustCalendarDate(e),
              r = t.year,
              o = t.month,
              n = t.day,
              a = this.anchorEra;
             return RegulateISODate
                     (r + a.isoEpoch.year - (a.hasYearZero ? 0 : 1),
                      o,
                      n,
                      "constrain");
            }},
           {key: "checkIcuBugs",
            value:
            function(e){
             if
              (this.calendarIsVulnerableToJulianBug
               && this.v8IsVulnerableToJulianBug)
              if(CompareISODate(e.year, e.month, e.day, 1582, 10, 15) < 0)
               throw new
                      RangeError
                      ("calendar '".concat
                        (this.id,
                         "' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)"));
            }}]);
        return GregorianBaseHelper;
       }
       (HelperBase),
    OrthodoxBaseHelper =
      function(_GregorianBaseHelper){
        _inherits(OrthodoxBaseHelper, _GregorianBaseHelper);
        var _super12 = _createSuper(OrthodoxBaseHelper);
        function OrthodoxBaseHelper(e, t){
         _classCallCheck(this, OrthodoxBaseHelper);
         return _super12.call(this, e, t);
        }
        _createClass
         (OrthodoxBaseHelper,
          [{key: "inLeapYear",
            value: function(e){var t = e.year; return (t + 1) % 4 == 0;}},
           {key: "monthsInYear", value: function(){return 13;}},
           {key: "minimumMonthLength",
            value:
            function(e){
             var t = e.month;
             return 13 === t ? this.inLeapYear(e) ? 6 : 5 : 30;
            }},
           {key: "maximumMonthLength",
            value: function(e){return this.minimumMonthLength(e);}}]);
        return OrthodoxBaseHelper;
       }
       (GregorianBaseHelper),
    EthioaaHelper =
      function(_OrthodoxBaseHelper){
        _inherits(EthioaaHelper, _OrthodoxBaseHelper);
        var _super13 = _createSuper(EthioaaHelper);
        function EthioaaHelper(){
         _classCallCheck(this, EthioaaHelper);
         return _super13.call
                 (this,
                  "ethioaa",
                  [{name: "era0", isoEpoch: {year: - 5492, month: 7, day: 17}}]);
        }
        return _createClass(EthioaaHelper);
       }
       (OrthodoxBaseHelper),
    CopticHelper =
      function(_OrthodoxBaseHelper2){
        _inherits(CopticHelper, _OrthodoxBaseHelper2);
        var _super14 = _createSuper(CopticHelper);
        function CopticHelper(){
         _classCallCheck(this, CopticHelper);
         return _super14.call
                 (this,
                  "coptic",
                  [{name: "era1", isoEpoch: {year: 284, month: 8, day: 29}},
                   {name: "era0", reverseOf: "era1"}]);
        }
        return _createClass(CopticHelper);
       }
       (OrthodoxBaseHelper),
    EthiopicHelper =
      function(_OrthodoxBaseHelper3){
        _inherits(EthiopicHelper, _OrthodoxBaseHelper3);
        var _super15 = _createSuper(EthiopicHelper);
        function EthiopicHelper(){
         _classCallCheck(this, EthiopicHelper);
         return _super15.call
                 (this,
                  "ethiopic",
                  [{name: "era0", isoEpoch: {year: - 5492, month: 7, day: 17}},
                   {name: "era1",
                    isoEpoch: {year: 8, month: 8, day: 27},
                    anchorEpoch: {year: 5501}}]);
        }
        return _createClass(EthiopicHelper);
       }
       (OrthodoxBaseHelper),
    RocHelper =
      function(_GregorianBaseHelper2){
        _inherits(RocHelper, _GregorianBaseHelper2);
        var _super16 = _createSuper(RocHelper);
        function RocHelper(){
         var _this15;
         _classCallCheck(this, RocHelper);
         _this15 =
          _super16.call
           (this,
            "roc",
            [{name: "minguo", isoEpoch: {year: 1912, month: 1, day: 1}},
             {name: "before-roc", reverseOf: "minguo"}]),
         _this15.calendarIsVulnerableToJulianBug = ! 0;
         return _this15;
        }
        return _createClass(RocHelper);
       }
       (GregorianBaseHelper),
    BuddhistHelper =
      function(_GregorianBaseHelper3){
        _inherits(BuddhistHelper, _GregorianBaseHelper3);
        var _super17 = _createSuper(BuddhistHelper);
        function BuddhistHelper(){
         var _this16;
         _classCallCheck(this, BuddhistHelper);
         _this16 =
          _super17.call
           (this,
            "buddhist",
            [{name: "be",
              hasYearZero: ! 0,
              isoEpoch: {year: - 543, month: 1, day: 1}}]),
         _this16.calendarIsVulnerableToJulianBug = ! 0;
         return _this16;
        }
        return _createClass(BuddhistHelper);
       }
       (GregorianBaseHelper),
    GregoryHelper =
      function(_GregorianBaseHelper4){
        _inherits(GregoryHelper, _GregorianBaseHelper4);
        var _super18 = _createSuper(GregoryHelper);
        function GregoryHelper(){
         _classCallCheck(this, GregoryHelper);
         return _super18.call
                 (this,
                  "gregory",
                  [{name: "ce", isoEpoch: {year: 1, month: 1, day: 1}},
                   {name: "bce", reverseOf: "ce"}]);
        }
        _createClass
         (GregoryHelper,
          [{key: "reviseIntlEra",
            value:
            function(e){
             var t = e.era, r = e.eraYear;
             return "bc" !== t && "b" !== t || (t = "bce"),
                    "ad" !== t && "a" !== t || (t = "ce"),
                    {era: t, eraYear: r};
            }}]);
        return GregoryHelper;
       }
       (GregorianBaseHelper),
    JapaneseHelper =
      function(_GregorianBaseHelper5){
        _inherits(JapaneseHelper, _GregorianBaseHelper5);
        var _super19 = _createSuper(JapaneseHelper);
        function JapaneseHelper(){
         var _this17;
         _classCallCheck(this, JapaneseHelper);
         _this17 =
          _super19.call
           (this,
            "japanese",
            [{name: "reiwa",
              isoEpoch: {year: 2019, month: 5, day: 1},
              anchorEpoch: {year: 2019, month: 5, day: 1}},
             {name: "heisei",
              isoEpoch: {year: 1989, month: 1, day: 8},
              anchorEpoch: {year: 1989, month: 1, day: 8}},
             {name: "showa",
              isoEpoch: {year: 1926, month: 12, day: 25},
              anchorEpoch: {year: 1926, month: 12, day: 25}},
             {name: "taisho",
              isoEpoch: {year: 1912, month: 7, day: 30},
              anchorEpoch: {year: 1912, month: 7, day: 30}},
             {name: "meiji",
              isoEpoch: {year: 1868, month: 9, day: 8},
              anchorEpoch: {year: 1868, month: 9, day: 8}},
             {name: "ce", isoEpoch: {year: 1, month: 1, day: 1}},
             {name: "bce", reverseOf: "ce"}]),
         _this17.calendarIsVulnerableToJulianBug = ! 0,
         _this17.eraLength = "long",
         _this17.erasBeginMidYear = ! 0;
         return _this17;
        }
        _createClass
         (JapaneseHelper,
          [{key: "reviseIntlEra",
            value:
            function(e, t){
             var r = e.era, o = e.eraYear, n = t.year;
             return this.eras.find(function(e){return e.name === r;})
                     ? {era: r, eraYear: o}
                     : n
                       < 1
                       ? {era: "bce", eraYear: 1 - n}
                       : {era: "ce", eraYear: n};
            }}]);
        return JapaneseHelper;
       }
       (GregorianBaseHelper),
    ChineseBaseHelper =
      function(_HelperBase6){
        _inherits(ChineseBaseHelper, _HelperBase6);
        var _super20 = _createSuper(ChineseBaseHelper);
        function ChineseBaseHelper(){
         var _this18;
         _classCallCheck(this, ChineseBaseHelper);
         _this18 = _super20.apply(this, arguments),
         _this18.calendarType = "lunisolar",
         _this18.hasEra = ! 1;
         return _this18;
        }
        _createClass
         (ChineseBaseHelper,
          [{key: "inLeapYear",
            value:
            function(e, t){
             var r = this.getMonthList(e.year, t);
             return 13 === wt(r).length;
            }},
           {key: "monthsInYear",
            value: function(e, t){return this.inLeapYear(e, t) ? 13 : 12;}},
           {key: "minimumMonthLength", value: function(){return 29;}},
           {key: "maximumMonthLength", value: function(){return 30;}},
           {key: "getMonthList",
            value:
            function(e, t){
             var _this19 = this, _getCalendarDate2;
             if(void 0 === e) throw new TypeError("Missing year");
             var
              r =
                JSON.stringify
                 ({func: "getMonthList", calendarYear: e, id: this.id}),
              o = t.get(r);
             if(o) return o;
             var
              n = this.getFormatter(),
              getCalendarDate =
                function(e, t){
                 var
                  r = toUtcIsoDateString({isoYear: e, isoMonth: 2, isoDay: 1}),
                  o = new Date(r);
                 o.setUTCDate(t + 1);
                 var
                  a = n.formatToParts(o),
                  i = a.find(function(e){return "month" === e.type;}).value,
                  s = + a.find(function(e){return "day" === e.type;}).value,
                  l = a.find(function(e){return "relatedYear" === e.type;});
                 if(void 0 === l)
                  throw new
                         RangeError
                         ("Intl.DateTimeFormat.formatToParts lacks relatedYear in ".concat
                           (_this19.id, " calendar. Try Node 14+ or modern browsers."));
                 return l = + l.value,
                        {calendarMonthString: i,
                         calendarDay: s,
                         calendarYearToVerify: l};
                },
              a = 17,
              _getCalendarDate = getCalendarDate(e, a),
              i = _getCalendarDate.calendarMonthString,
              s = _getCalendarDate.calendarDay,
              l = _getCalendarDate.calendarYearToVerify;
             "1" !== i
             &&
              (a += 29,
               _getCalendarDate2 = getCalendarDate(e, a),
               i = _getCalendarDate2.calendarMonthString,
               s = _getCalendarDate2.calendarDay),
             a -= s - 5;
             var d = {}, m, c, h = 1, u = ! 1;
             do{
              var _getCalendarDate3;
              _getCalendarDate3 = getCalendarDate(e, a),
              i = _getCalendarDate3.calendarMonthString,
              s = _getCalendarDate3.calendarDay,
              l = _getCalendarDate3.calendarYearToVerify,
              m && (d[c].daysInMonth = m + 30 - s),
              l !== e ? u = ! 0 : (d[i] = {monthIndex: h++}, a += 30),
              m = s,
              c = i;
             }
             while
              (! u);
             return d[c].daysInMonth = m + 30 - s, t.set(r, d), d;
            }},
           {key: "estimateIsoDate",
            value:
            function(e){
             var t = e.year, r = e.month;
             return {year: t, month: r >= 12 ? 12 : r + 1, day: 1};
            }},
           {key: "adjustCalendarDate",
            value:
            function(e, t){
             var
              r =
                arguments.length > 2 && arguments[2] !== undefined
                 ? arguments[2]
                 : "constrain",
              o =
                arguments.length > 3 && arguments[3] !== undefined
                 ? arguments[3]
                 : ! 1,
              n = e.year,
              a = e.month,
              i = e.monthExtra,
              s = e.day,
              l = e.monthCode,
              d = e.eraYear;
             if(o){
              if(n = d, i && "bis" !== i)
               throw new
                      RangeError
                      ("Unexpected leap month suffix: ".concat(i));
              var
               _e49 = buildMonthCode(a, void 0 !== i),
               _r65 = "".concat(a).concat(i || ""),
               _o40 = this.getMonthList(n, t)[_r65];
              if(void 0 === _o40)
               throw new
                      RangeError
                      ("Unmatched month ".concat(_r65, " in Chinese year ").concat
                        (n));
              return a = _o40.monthIndex,
                     {year: n,
                      month: a,
                      day: s,
                      era: void 0,
                      eraYear: d,
                      monthCode: _e49};
             }
             if
              (this.validateCalendarDate(e),
               void 0 === n && (n = d),
               void 0 === d && (d = n),
               void 0 === a){
              var
               _e50 = this.getMonthList(n, t),
               _o41 = l.replace("L", "bis").slice(1);
              "0" === _o41[0] && (_o41 = _o41.slice(1));
              var _i19 = _e50[_o41];
              if
               (a = _i19 && _i19.monthIndex,
                void 0 === a && l.endsWith("L") && "M13L" != l
                && "constrain" === r){
               var _t48 = l.slice(1, - 1);
               "0" === _t48[0] && (_t48 = _t48.slice(1)),
               _i19 = _e50[_t48],
               _i19 && (a = _i19.monthIndex, l = buildMonthCode(_t48));
              }
              if(void 0 === a)
               throw new
                      RangeError
                      ("Unmatched month ".concat(l, " in Chinese year ").concat(n));
             }
             else if(void 0 === l){
              var
               _e51 = this.getMonthList(n, t),
               _o42 = wt(_e51),
               _i20 = _o42.length;
              "reject" === r
               ? (RejectToRange
                  (a, 1, _i20),
                 RejectToRange(s, 1, this.maximumMonthLength()))
               : (a
                 = ConstrainToRange(a, 1, _i20),
                 s = ConstrainToRange(s, 1, this.maximumMonthLength()));
              var
               _d11 =
                 _o42.find
                  (function(_ref10){
                    var _ref11 = _slicedToArray(_ref10, 2), e = _ref11[1];
                    return e.monthIndex === a;
                   });
              if(void 0 === _d11)
               throw new
                      RangeError
                      ("Invalid month ".concat(a, " in Chinese year ").concat(n));
              l =
               buildMonthCode
                (_d11[0].replace("bis", ""), - 1 !== _d11[0].indexOf("bis"));
             }
             else{
              var
               _e52 = this.getMonthList(n, t),
               _r66 = l.replace("L", "bis").slice(1);
              "0" === _r66[0] && (_r66 = _r66.slice(1));
              var _o43 = _e52[_r66];
              if(! _o43)
               throw new
                      RangeError
                      ("Unmatched monthCode ".concat(l, " in Chinese year ").concat
                        (n));
              if(a !== _o43.monthIndex)
               throw new
                      RangeError
                      ("monthCode ".concat(l, " doesn't correspond to month ").concat
                         (a, " in Chinese year ").concat
                        (n));
             }
             return _objectSpread2
                     (_objectSpread2({}, e),
                      {},
                      {year: n, eraYear: d, month: a, monthCode: l, day: s});
            }}]);
        return ChineseBaseHelper;
       }
       (HelperBase),
    ChineseHelper =
      function(_ChineseBaseHelper){
        _inherits(ChineseHelper, _ChineseBaseHelper);
        var _super21 = _createSuper(ChineseHelper);
        function ChineseHelper(){
         var _this20;
         _classCallCheck(this, ChineseHelper);
         _this20 = _super21.apply(this, arguments), _this20.id = "chinese";
         return _this20;
        }
        return _createClass(ChineseHelper);
       }
       (ChineseBaseHelper),
    DangiHelper =
      function(_ChineseBaseHelper2){
        _inherits(DangiHelper, _ChineseBaseHelper2);
        var _super22 = _createSuper(DangiHelper);
        function DangiHelper(){
         var _this21;
         _classCallCheck(this, DangiHelper);
         _this21 = _super22.apply(this, arguments), _this21.id = "dangi";
         return _this21;
        }
        return _createClass(DangiHelper);
       }
       (ChineseBaseHelper),
    NonIsoCalendar =
      function(){
        function NonIsoCalendar(e){
         _classCallCheck(this, NonIsoCalendar);
         this.helper = e;
        }
        _createClass
         (NonIsoCalendar,
          [{key: "dateFromFields",
            value:
            function(e, t, r){
             var
              o = new OneObjectCache(),
              n =
                PrepareTemporalFields
                 (e, this.fields(["day", "month", "monthCode", "year"]), []),
              a = ToTemporalOverflow(t),
              _this$helper$calendar = this.helper.calendarToIsoDate(n, a, o),
              i = _this$helper$calendar.year,
              s = _this$helper$calendar.month,
              l = _this$helper$calendar.day,
              d = CreateTemporalDate(i, s, l, r);
             return o.setObject(d), d;
            }},
           {key: "yearMonthFromFields",
            value:
            function(e, t, r){
             var
              o = new OneObjectCache(),
              n =
                PrepareTemporalFields
                 (e, this.fields(["month", "monthCode", "year"]), []),
              a = ToTemporalOverflow(t),
              _this$helper$calendar2 =
                this.helper.calendarToIsoDate
                 (_objectSpread2(_objectSpread2({}, n), {}, {day: 1}), a, o),
              i = _this$helper$calendar2.year,
              s = _this$helper$calendar2.month,
              l = _this$helper$calendar2.day,
              d = CreateTemporalYearMonth(i, s, r, l);
             return o.setObject(d), d;
            }},
           {key: "monthDayFromFields",
            value:
            function(e, t, r){
             var
              o = new OneObjectCache(),
              n =
                PrepareTemporalFields
                 (e, this.fields(["day", "month", "monthCode", "year"]), []),
              a = ToTemporalOverflow(t),
              _this$helper$monthDay = this.helper.monthDayFromFields(n, a, o),
              i = _this$helper$monthDay.year,
              s = _this$helper$monthDay.month,
              l = _this$helper$monthDay.day,
              d = CreateTemporalMonthDay(s, l, r, i);
             return o.setObject(d), d;
            }},
           {key: "fields",
            value:
            function(e){
             var t = e;
             return Tt.call(t, "year")
                    &&
                     (t = [].concat(_toConsumableArray(t), ["era", "eraYear"])),
                    t;
            }},
           {key: "fieldKeysToIgnore",
            value:
            function(e){
             var t = new Dt();
             for(var _r67 = 0; _r67 < e.length; _r67++){
              var _o44 = e[_r67];
              switch(Call(vt, t, [_o44]), _o44){
                case "era":
                 Call(vt, t, ["eraYear"]), Call(vt, t, ["year"]); break;
                case "eraYear":
                 Call(vt, t, ["era"]), Call(vt, t, ["year"]); break;
                case "year":
                 Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]); break;
                case "month":
                 Call(vt, t, ["monthCode"]),
                 this.helper.erasBeginMidYear
                 && (Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]));
                 break;
                case "monthCode":
                 Call(vt, t, ["month"]),
                 this.helper.erasBeginMidYear
                 && (Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]));
                 break;
                case "day":
                 this.helper.erasBeginMidYear
                 && (Call(vt, t, ["era"]), Call(vt, t, ["eraYear"]));
              }
             }
             return _toConsumableArray(Call(Ct, t, []));
            }},
           {key: "dateAdd",
            value:
            function(e, t, r, o, n, a, i){
             var
              s = OneObjectCache.getCacheForObject(e),
              l = this.helper.temporalToCalendarDate(e, s),
              d =
                this.helper.addCalendar
                 (l, {years: t, months: r, weeks: o, days: n}, a, s),
              m = this.helper.calendarToIsoDate(d, "constrain", s),
              c = m.year,
              h = m.month,
              u = m.day,
              T = CreateTemporalDate(c, h, u, i);
             return new OneObjectCache(s).setObject(T), T;
            }},
           {key: "dateUntil",
            value:
            function(e, t, r){
             var
              o = OneObjectCache.getCacheForObject(e),
              n = OneObjectCache.getCacheForObject(t),
              a = this.helper.temporalToCalendarDate(e, o),
              i = this.helper.temporalToCalendarDate(t, n);
             return this.helper.untilCalendar(a, i, r, o);
            }},
           {key: "year",
            value:
            function(e){
             var t = OneObjectCache.getCacheForObject(e);
             return this.helper.temporalToCalendarDate(e, t).year;
            }},
           {key: "month",
            value:
            function(e){
             var t = OneObjectCache.getCacheForObject(e);
             return this.helper.temporalToCalendarDate(e, t).month;
            }},
           {key: "day",
            value:
            function(e){
             var t = OneObjectCache.getCacheForObject(e);
             return this.helper.temporalToCalendarDate(e, t).day;
            }},
           {key: "era",
            value:
            function(e){
             if(! this.helper.hasEra) return;
             var t = OneObjectCache.getCacheForObject(e);
             return this.helper.temporalToCalendarDate(e, t).era;
            }},
           {key: "eraYear",
            value:
            function(e){
             if(! this.helper.hasEra) return;
             var t = OneObjectCache.getCacheForObject(e);
             return this.helper.temporalToCalendarDate(e, t).eraYear;
            }},
           {key: "monthCode",
            value:
            function(e){
             var t = OneObjectCache.getCacheForObject(e);
             return this.helper.temporalToCalendarDate(e, t).monthCode;
            }},
           {key: "dayOfWeek",
            value: function(e){return Ot.iso8601.dayOfWeek(e);}},
           {key: "dayOfYear",
            value:
            function(e){
             var
              t = OneObjectCache.getCacheForObject(e),
              r = this.helper.isoToCalendarDate(e, t),
              o = this.helper.startOfCalendarYear(r);
             return this.helper.calendarDaysUntil(o, r, t) + 1;
            }},
           {key: "weekOfYear",
            value: function(e){return Ot.iso8601.weekOfYear(e);}},
           {key: "yearOfWeek",
            value: function(e){return Ot.iso8601.yearOfWeek(e);}},
           {key: "daysInWeek",
            value: function(e){return Ot.iso8601.daysInWeek(e);}},
           {key: "daysInMonth",
            value:
            function(e){
             var
              t = OneObjectCache.getCacheForObject(e),
              r = this.helper.temporalToCalendarDate(e, t),
              o = this.helper.maximumMonthLength(r);
             if(o === this.helper.minimumMonthLength(r)) return o;
             var
              n = this.helper.startOfCalendarMonth(r),
              a = this.helper.addMonthsCalendar(n, 1, "constrain", t);
             return this.helper.calendarDaysUntil(n, a, t);
            }},
           {key: "daysInYear",
            value:
            function(e){
             var t = e;
             HasSlot(t, i) || (t = ToTemporalDate(t));
             var
              r = OneObjectCache.getCacheForObject(t),
              o = this.helper.temporalToCalendarDate(t, r),
              n = this.helper.startOfCalendarYear(o),
              a = this.helper.addCalendar(n, {years: 1}, "constrain", r);
             return this.helper.calendarDaysUntil(n, a, r);
            }},
           {key: "monthsInYear",
            value:
            function(e){
             var
              t = OneObjectCache.getCacheForObject(e),
              r = this.helper.temporalToCalendarDate(e, t);
             return this.helper.monthsInYear(r, t);
            }},
           {key: "inLeapYear",
            value:
            function(e){
             var t = e;
             HasSlot(t, i) || (t = ToTemporalDate(t));
             var
              r = OneObjectCache.getCacheForObject(t),
              o = this.helper.temporalToCalendarDate(t, r);
             return this.helper.inLeapYear(o, r);
            }}]);
        return NonIsoCalendar;
       }
       ();
   for
   (var
     _i21 = 0,
     _arr7 =
       [HebrewHelper,
        PersianHelper,
        EthiopicHelper,
        EthioaaHelper,
        CopticHelper,
        ChineseHelper,
        DangiHelper,
        RocHelper,
        IndianHelper,
        BuddhistHelper,
        GregoryHelper,
        JapaneseHelper,
        IslamicHelper,
        IslamicUmalquraHelper,
        IslamicTblaHelper,
        IslamicCivilHelper,
        IslamicRgsaHelper,
        IslamicCcHelper];
    _i21 < _arr7.length;
    _i21++){
    var _e53 = _arr7[_i21], _t49 = new _e53();
    Ot[_t49.id] = new NonIsoCalendar(_t49);
   }
   var
    PlainDate =
      function(){
        function PlainDate(e, t, r){
         var
          o =
            arguments.length > 3 && arguments[3] !== undefined
             ? arguments[3]
             : "iso8601";
         _classCallCheck(this, PlainDate);
         CreateTemporalDateSlots
          (this,
           ToIntegerWithTruncation(e),
           ToIntegerWithTruncation(t),
           ToIntegerWithTruncation(r),
           ToTemporalCalendarSlotValue(o));
        }
        _createClass
         (PlainDate,
          [{key: "calendarId",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarIdentifier(GetSlot(this, p));
            }},
           {key: "era",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarEra(GetSlot(this, p), this);
            }},
           {key: "eraYear",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarEraYear(GetSlot(this, p), this);
            }},
           {key: "year",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarYear(GetSlot(this, p), this);
            }},
           {key: "month",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarMonth(GetSlot(this, p), this);
            }},
           {key: "monthCode",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthCode(GetSlot(this, p), this);
            }},
           {key: "day",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarDay(GetSlot(this, p), this);
            }},
           {key: "dayOfWeek",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarDayOfWeek(GetSlot(this, p), this);
            }},
           {key: "dayOfYear",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarDayOfYear(GetSlot(this, p), this);
            }},
           {key: "weekOfYear",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarWeekOfYear(GetSlot(this, p), this);
            }},
           {key: "yearOfWeek",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarYearOfWeek(GetSlot(this, p), this);
            }},
           {key: "daysInWeek",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInWeek(GetSlot(this, p), this);
            }},
           {key: "daysInMonth",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInMonth(GetSlot(this, p), this);
            }},
           {key: "daysInYear",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInYear(GetSlot(this, p), this);
            }},
           {key: "monthsInYear",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthsInYear(GetSlot(this, p), this);
            }},
           {key: "inLeapYear",
            get:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return CalendarInLeapYear(GetSlot(this, p), this);
            }},
           {key: "with",
            value:
            function(e, t){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid argument");
             RejectTemporalLikeObject(e);
             var
              r = GetOptionsObject(t),
              o = GetSlot(this, p),
              n = CalendarFields(o, ["day", "month", "monthCode", "year"]),
              a = PrepareTemporalFields(this, n, []);
             return a =
                     CalendarMergeFields
                      (o, a, PrepareTemporalFields(e, n, "partial")),
                    a = PrepareTemporalFields(a, n, []),
                    CalendarDateFromFields(o, a, r);
            }},
           {key: "withCalendar",
            value:
            function(e){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalCalendarSlotValue(e);
             return new
                     PlainDate
                     (GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), t);
            }},
           {key: "add",
            value:
            function(e, t){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var r = ToTemporalDuration(e), o = GetOptionsObject(t);
             return CalendarDateAdd(GetSlot(this, p), this, r, o);
            }},
           {key: "subtract",
            value:
            function(e, t){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var
              r = CreateNegatedTemporalDuration(ToTemporalDuration(e)),
              o = GetOptionsObject(t);
             return CalendarDateAdd(GetSlot(this, p), this, r, o);
            }},
           {key: "until",
            value:
            function(e, t){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainDate("until", this, e, t);
            }},
           {key: "since",
            value:
            function(e, t){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainDate("since", this, e, t);
            }},
           {key: "equals",
            value:
            function(e){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDate(e);
             for(var _i22 = 0, _arr8 = [i, s, l]; _i22 < _arr8.length; _i22++){
              var _e54 = _arr8[_i22];
              if(GetSlot(this, _e54) !== GetSlot(t, _e54)) return ! 1;
             }
             return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return TemporalDateToString
                     (this, ToCalendarNameOption(GetOptionsObject(e)));
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return TemporalDateToString(this);
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return new ht(e, t).format(this);
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use compare() or equals() to compare Temporal.PlainDate");
            }},
           {key: "toPlainDateTime",
            value:
            function(e){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var
              t = GetSlot(this, i),
              r = GetSlot(this, s),
              o = GetSlot(this, l),
              n = GetSlot(this, p);
             if(void 0 === e)
              return CreateTemporalDateTime(t, r, o, 0, 0, 0, 0, 0, 0, n);
             var a = ToTemporalTime(e);
             return CreateTemporalDateTime
                     (t,
                      r,
                      o,
                      GetSlot(a, d),
                      GetSlot(a, m),
                      GetSlot(a, c),
                      GetSlot(a, h),
                      GetSlot(a, u),
                      GetSlot(a, T),
                      n);
            }},
           {key: "toZonedDateTime",
            value:
            function(e){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var t, r;
             if(IsObject(e))
              if(IsTemporalTimeZone(e))
               t = e;
              else{
               var _o45 = e.timeZone;
               void 0 === _o45
                ? t = ToTemporalTimeZoneSlotValue(e)
                : (t = ToTemporalTimeZoneSlotValue(_o45), r = e.plainTime);
              }
             else
              t = ToTemporalTimeZoneSlotValue(e);
             var
              o = GetSlot(this, i),
              a = GetSlot(this, s),
              f = GetSlot(this, l),
              y = GetSlot(this, p),
              I = 0,
              S = 0,
              g = 0,
              w = 0,
              D = 0,
              G = 0;
             void 0 !== r
             &&
              (r = ToTemporalTime(r),
               I = GetSlot(r, d),
               S = GetSlot(r, m),
               g = GetSlot(r, c),
               w = GetSlot(r, h),
               D = GetSlot(r, u),
               G = GetSlot(r, T));
             return CreateTemporalZonedDateTime
                     (GetSlot
                       (GetInstantFor
                         (t,
                          CreateTemporalDateTime(o, a, f, I, S, g, w, D, G, y),
                          "compatible"),
                        n),
                      t,
                      y);
            }},
           {key: "toPlainYearMonth",
            value:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var e = GetSlot(this, p);
             return CalendarYearMonthFromFields
                     (e,
                      PrepareTemporalFields
                       (this, CalendarFields(e, ["monthCode", "year"]), []));
            }},
           {key: "toPlainMonthDay",
            value:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             var e = GetSlot(this, p);
             return CalendarMonthDayFromFields
                     (e,
                      PrepareTemporalFields
                       (this, CalendarFields(e, ["day", "monthCode"]), []));
            }},
           {key: "getISOFields",
            value:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return {calendar: GetSlot(this, p),
                     isoDay: GetSlot(this, l),
                     isoMonth: GetSlot(this, s),
                     isoYear: GetSlot(this, i)};
            }},
           {key: "getCalendar",
            value:
            function(){
             if(! IsTemporalDate(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarObject(GetSlot(this, p));
            }}],
          [{key: "from",
            value:
            function(e, t){
             var r = GetOptionsObject(t);
             return IsTemporalDate(e)
                     ? (ToTemporalOverflow
                        (r),
                       CreateTemporalDate
                        (GetSlot(e, i), GetSlot(e, s), GetSlot(e, l), GetSlot(e, p)))
                     : ToTemporalDate(e, r);
            }},
           {key: "compare",
            value:
            function(e, t){
             var r = ToTemporalDate(e), o = ToTemporalDate(t);
             return CompareISODate
                     (GetSlot(r, i),
                      GetSlot(r, s),
                      GetSlot(r, l),
                      GetSlot(o, i),
                      GetSlot(o, s),
                      GetSlot(o, l));
            }}]);
        return PlainDate;
       }
       ();
   MakeIntrinsicClass(PlainDate, "Temporal.PlainDate");
   var
    PlainDateTime =
      function(){
        function PlainDateTime(e, t, r){
         var
          o =
            arguments.length > 3 && arguments[3] !== undefined
             ? arguments[3]
             : 0,
          n =
            arguments.length > 4 && arguments[4] !== undefined
             ? arguments[4]
             : 0,
          a =
            arguments.length > 5 && arguments[5] !== undefined
             ? arguments[5]
             : 0,
          i =
            arguments.length > 6 && arguments[6] !== undefined
             ? arguments[6]
             : 0,
          s =
            arguments.length > 7 && arguments[7] !== undefined
             ? arguments[7]
             : 0,
          l =
            arguments.length > 8 && arguments[8] !== undefined
             ? arguments[8]
             : 0,
          d =
            arguments.length > 9 && arguments[9] !== undefined
             ? arguments[9]
             : "iso8601";
         _classCallCheck(this, PlainDateTime);
         CreateTemporalDateTimeSlots
          (this,
           ToIntegerWithTruncation(e),
           ToIntegerWithTruncation(t),
           ToIntegerWithTruncation(r),
           void 0 === o ? 0 : ToIntegerWithTruncation(o),
           void 0 === n ? 0 : ToIntegerWithTruncation(n),
           void 0 === a ? 0 : ToIntegerWithTruncation(a),
           void 0 === i ? 0 : ToIntegerWithTruncation(i),
           void 0 === s ? 0 : ToIntegerWithTruncation(s),
           void 0 === l ? 0 : ToIntegerWithTruncation(l),
           ToTemporalCalendarSlotValue(d));
        }
        _createClass
         (PlainDateTime,
          [{key: "calendarId",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarIdentifier(GetSlot(this, p));
            }},
           {key: "year",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarYear(GetSlot(this, p), this);
            }},
           {key: "month",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarMonth(GetSlot(this, p), this);
            }},
           {key: "monthCode",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthCode(GetSlot(this, p), this);
            }},
           {key: "day",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDay(GetSlot(this, p), this);
            }},
           {key: "hour",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, d);
            }},
           {key: "minute",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, m);
            }},
           {key: "second",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, c);
            }},
           {key: "millisecond",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, h);
            }},
           {key: "microsecond",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, u);
            }},
           {key: "nanosecond",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, T);
            }},
           {key: "era",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarEra(GetSlot(this, p), this);
            }},
           {key: "eraYear",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarEraYear(GetSlot(this, p), this);
            }},
           {key: "dayOfWeek",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDayOfWeek(GetSlot(this, p), this);
            }},
           {key: "dayOfYear",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDayOfYear(GetSlot(this, p), this);
            }},
           {key: "weekOfYear",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarWeekOfYear(GetSlot(this, p), this);
            }},
           {key: "yearOfWeek",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarYearOfWeek(GetSlot(this, p), this);
            }},
           {key: "daysInWeek",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInWeek(GetSlot(this, p), this);
            }},
           {key: "daysInYear",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInYear(GetSlot(this, p), this);
            }},
           {key: "daysInMonth",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInMonth(GetSlot(this, p), this);
            }},
           {key: "monthsInYear",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthsInYear(GetSlot(this, p), this);
            }},
           {key: "inLeapYear",
            get:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarInLeapYear(GetSlot(this, p), this);
            }},
           {key: "with",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid argument");
             RejectTemporalLikeObject(e);
             var
              r = GetOptionsObject(t),
              o = GetSlot(this, p),
              n =
                CalendarFields
                 (o,
                  ["day",
                   "hour",
                   "microsecond",
                   "millisecond",
                   "minute",
                   "month",
                   "monthCode",
                   "nanosecond",
                   "second",
                   "year"]),
              a = PrepareTemporalFields(this, n, []);
             a =
              CalendarMergeFields
               (o, a, PrepareTemporalFields(e, n, "partial")),
             a = PrepareTemporalFields(a, n, []);
             var
              _InterpretTemporalDat4 =
                InterpretTemporalDateTimeFields(o, a, r),
              i = _InterpretTemporalDat4.year,
              s = _InterpretTemporalDat4.month,
              l = _InterpretTemporalDat4.day,
              d = _InterpretTemporalDat4.hour,
              m = _InterpretTemporalDat4.minute,
              c = _InterpretTemporalDat4.second,
              h = _InterpretTemporalDat4.millisecond,
              u = _InterpretTemporalDat4.microsecond,
              T = _InterpretTemporalDat4.nanosecond;
             return CreateTemporalDateTime(i, s, l, d, m, c, h, u, T, o);
            }},
           {key: "withPlainTime",
            value:
            function(e){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = GetSlot(this, i),
              r = GetSlot(this, s),
              o = GetSlot(this, l),
              n = GetSlot(this, p);
             if(void 0 === e)
              return CreateTemporalDateTime(t, r, o, 0, 0, 0, 0, 0, 0, n);
             var a = ToTemporalTime(e);
             return CreateTemporalDateTime
                     (t,
                      r,
                      o,
                      GetSlot(a, d),
                      GetSlot(a, m),
                      GetSlot(a, c),
                      GetSlot(a, h),
                      GetSlot(a, u),
                      GetSlot(a, T),
                      n);
            }},
           {key: "withPlainDate",
            value:
            function(e){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = ToTemporalDate(e),
              r = GetSlot(t, i),
              o = GetSlot(t, s),
              n = GetSlot(t, l),
              a = GetSlot(t, p),
              f = GetSlot(this, d),
              y = GetSlot(this, m),
              I = GetSlot(this, c),
              S = GetSlot(this, h),
              g = GetSlot(this, u),
              w = GetSlot(this, T);
             return a = ConsolidateCalendars(GetSlot(this, p), a),
                    CreateTemporalDateTime(r, o, n, f, y, I, S, g, w, a);
            }},
           {key: "withCalendar",
            value:
            function(e){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalCalendarSlotValue(e);
             return new
                     PlainDateTime
                     (GetSlot(this, i),
                      GetSlot(this, s),
                      GetSlot(this, l),
                      GetSlot(this, d),
                      GetSlot(this, m),
                      GetSlot(this, c),
                      GetSlot(this, h),
                      GetSlot(this, u),
                      GetSlot(this, T),
                      t);
            }},
           {key: "add",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromPlainDateTime
                     ("add", this, e, t);
            }},
           {key: "subtract",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromPlainDateTime
                     ("subtract", this, e, t);
            }},
           {key: "until",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainDateTime("until", this, e, t);
            }},
           {key: "since",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainDateTime("since", this, e, t);
            }},
           {key: "round",
            value:
            function(e){
             var _RoundISODateTime2;
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             if(void 0 === e)
              throw new TypeError("options parameter is required");
             var
              t =
                "string" == typeof e
                 ? CreateOnePropObject("smallestUnit", e)
                 : GetOptionsObject(e),
              r = ToTemporalRoundingIncrement(t),
              o = ToTemporalRoundingMode(t, "halfExpand"),
              n = GetTemporalUnit(t, "smallestUnit", "time", He, ["day"]),
              a =
                {day: 1,
                  hour: 24,
                  minute: 60,
                  second: 60,
                  millisecond: 1e3,
                  microsecond: 1e3,
                  nanosecond: 1e3}
                 [n];
             ValidateTemporalRoundingIncrement(r, a, 1 === a);
             var
              f = GetSlot(this, i),
              y = GetSlot(this, s),
              I = GetSlot(this, l),
              S = GetSlot(this, d),
              g = GetSlot(this, m),
              w = GetSlot(this, c),
              D = GetSlot(this, h),
              G = GetSlot(this, u),
              v = GetSlot(this, T);
             return _RoundISODateTime2 =
                     RoundISODateTime(f, y, I, S, g, w, D, G, v, r, n, o),
                    f = _RoundISODateTime2.year,
                    y = _RoundISODateTime2.month,
                    I = _RoundISODateTime2.day,
                    S = _RoundISODateTime2.hour,
                    g = _RoundISODateTime2.minute,
                    w = _RoundISODateTime2.second,
                    D = _RoundISODateTime2.millisecond,
                    G = _RoundISODateTime2.microsecond,
                    v = _RoundISODateTime2.nanosecond,
                    CreateTemporalDateTime
                     (f, y, I, S, g, w, D, G, v, GetSlot(this, p));
            }},
           {key: "equals",
            value:
            function(e){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalDateTime(e);
             for
             (var _i23 = 0, _arr9 = [i, s, l, d, m, c, h, u, T];
              _i23 < _arr9.length;
              _i23++){
              var _e55 = _arr9[_i23];
              if(GetSlot(this, _e55) !== GetSlot(t, _e55)) return ! 1;
             }
             return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = GetOptionsObject(e),
              r = ToCalendarNameOption(t),
              o = ToFractionalSecondDigits(t),
              n = ToTemporalRoundingMode(t, "trunc"),
              a = GetTemporalUnit(t, "smallestUnit", "time", void 0);
             if("hour" === a)
              throw new
                     RangeError
                     ('smallestUnit must be a time unit other than "hour"');
             var
              _ToSecondsStringPreci2 = ToSecondsStringPrecisionRecord(a, o),
              i = _ToSecondsStringPreci2.precision,
              s = _ToSecondsStringPreci2.unit,
              l = _ToSecondsStringPreci2.increment;
             return TemporalDateTimeToString
                     (this, i, r, {unit: s, increment: l, roundingMode: n});
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return TemporalDateTimeToString(this, "auto");
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return new ht(e, t).format(this);
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use compare() or equals() to compare Temporal.PlainDateTime");
            }},
           {key: "toZonedDateTime",
            value:
            function(e, t){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var r = ToTemporalTimeZoneSlotValue(e);
             return CreateTemporalZonedDateTime
                     (GetSlot
                       (GetInstantFor
                         (r, this, ToTemporalDisambiguation(GetOptionsObject(t))),
                        n),
                      r,
                      GetSlot(this, p));
            }},
           {key: "toPlainDate",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return TemporalDateTimeToDate(this);
            }},
           {key: "toPlainYearMonth",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var e = GetSlot(this, p);
             return CalendarYearMonthFromFields
                     (e,
                      PrepareTemporalFields
                       (this, CalendarFields(e, ["monthCode", "year"]), []));
            }},
           {key: "toPlainMonthDay",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             var e = GetSlot(this, p);
             return CalendarMonthDayFromFields
                     (e,
                      PrepareTemporalFields
                       (this, CalendarFields(e, ["day", "monthCode"]), []));
            }},
           {key: "toPlainTime",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return TemporalDateTimeToTime(this);
            }},
           {key: "getISOFields",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return {calendar: GetSlot(this, p),
                     isoDay: GetSlot(this, l),
                     isoHour: GetSlot(this, d),
                     isoMicrosecond: GetSlot(this, u),
                     isoMillisecond: GetSlot(this, h),
                     isoMinute: GetSlot(this, m),
                     isoMonth: GetSlot(this, s),
                     isoNanosecond: GetSlot(this, T),
                     isoSecond: GetSlot(this, c),
                     isoYear: GetSlot(this, i)};
            }},
           {key: "getCalendar",
            value:
            function(){
             if(! IsTemporalDateTime(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarObject(GetSlot(this, p));
            }}],
          [{key: "from",
            value:
            function(e, t){
             var r = GetOptionsObject(t);
             return IsTemporalDateTime(e)
                     ? (ToTemporalOverflow
                        (r),
                       CreateTemporalDateTime
                        (GetSlot(e, i),
                         GetSlot(e, s),
                         GetSlot(e, l),
                         GetSlot(e, d),
                         GetSlot(e, m),
                         GetSlot(e, c),
                         GetSlot(e, h),
                         GetSlot(e, u),
                         GetSlot(e, T),
                         GetSlot(e, p)))
                     : ToTemporalDateTime(e, r);
            }},
           {key: "compare",
            value:
            function(e, t){
             var r = ToTemporalDateTime(e), o = ToTemporalDateTime(t);
             for
             (var _i24 = 0, _arr10 = [i, s, l, d, m, c, h, u, T];
              _i24 < _arr10.length;
              _i24++){
              var
               _e56 = _arr10[_i24],
               _t50 = GetSlot(r, _e56),
               _n27 = GetSlot(o, _e56);
              if(_t50 !== _n27) return ComparisonResult(_t50 - _n27);
             }
             return 0;
            }}]);
        return PlainDateTime;
       }
       ();
   MakeIntrinsicClass(PlainDateTime, "Temporal.PlainDateTime");
   var
    Duration =
      function(){
        function Duration(){
         var
          e =
            arguments.length > 0 && arguments[0] !== undefined
             ? arguments[0]
             : 0,
          t =
            arguments.length > 1 && arguments[1] !== undefined
             ? arguments[1]
             : 0,
          r =
            arguments.length > 2 && arguments[2] !== undefined
             ? arguments[2]
             : 0,
          o =
            arguments.length > 3 && arguments[3] !== undefined
             ? arguments[3]
             : 0,
          n =
            arguments.length > 4 && arguments[4] !== undefined
             ? arguments[4]
             : 0,
          a =
            arguments.length > 5 && arguments[5] !== undefined
             ? arguments[5]
             : 0,
          i =
            arguments.length > 6 && arguments[6] !== undefined
             ? arguments[6]
             : 0,
          s =
            arguments.length > 7 && arguments[7] !== undefined
             ? arguments[7]
             : 0,
          l =
            arguments.length > 8 && arguments[8] !== undefined
             ? arguments[8]
             : 0,
          d =
            arguments.length > 9 && arguments[9] !== undefined
             ? arguments[9]
             : 0;
         _classCallCheck(this, Duration);
         var
          m = void 0 === e ? 0 : ToIntegerIfIntegral(e),
          c = void 0 === t ? 0 : ToIntegerIfIntegral(t),
          h = void 0 === r ? 0 : ToIntegerIfIntegral(r),
          u = void 0 === o ? 0 : ToIntegerIfIntegral(o),
          T = void 0 === n ? 0 : ToIntegerIfIntegral(n),
          p = void 0 === a ? 0 : ToIntegerIfIntegral(a),
          f = void 0 === i ? 0 : ToIntegerIfIntegral(i),
          y = void 0 === s ? 0 : ToIntegerIfIntegral(s),
          I = void 0 === l ? 0 : ToIntegerIfIntegral(l),
          S = void 0 === d ? 0 : ToIntegerIfIntegral(d);
         RejectDuration(m, c, h, u, T, p, f, y, I, S),
         N(this),
         SetSlot(this, w, m),
         SetSlot(this, D, c),
         SetSlot(this, G, h),
         SetSlot(this, v, u),
         SetSlot(this, C, T),
         SetSlot(this, O, p),
         SetSlot(this, b, f),
         SetSlot(this, E, y),
         SetSlot(this, M, I),
         SetSlot(this, R, S);
        }
        _createClass
         (Duration,
          [{key: "years",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, w);
            }},
           {key: "months",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, D);
            }},
           {key: "weeks",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, G);
            }},
           {key: "days",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, v);
            }},
           {key: "hours",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, C);
            }},
           {key: "minutes",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, O);
            }},
           {key: "seconds",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, b);
            }},
           {key: "milliseconds",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, E);
            }},
           {key: "microseconds",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, M);
            }},
           {key: "nanoseconds",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, R);
            }},
           {key: "sign",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return DurationSign
                     (GetSlot(this, w),
                      GetSlot(this, D),
                      GetSlot(this, G),
                      GetSlot(this, v),
                      GetSlot(this, C),
                      GetSlot(this, O),
                      GetSlot(this, b),
                      GetSlot(this, E),
                      GetSlot(this, M),
                      GetSlot(this, R));
            }},
           {key: "blank",
            get:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return 0
                    ===
                     DurationSign
                      (GetSlot(this, w),
                       GetSlot(this, D),
                       GetSlot(this, G),
                       GetSlot(this, v),
                       GetSlot(this, C),
                       GetSlot(this, O),
                       GetSlot(this, b),
                       GetSlot(this, E),
                       GetSlot(this, M),
                       GetSlot(this, R));
            }},
           {key: "with",
            value:
            function(e){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             var
              t =
                PrepareTemporalFields
                 (e,
                  ["days",
                   "hours",
                   "microseconds",
                   "milliseconds",
                   "minutes",
                   "months",
                   "nanoseconds",
                   "seconds",
                   "weeks",
                   "years"],
                  "partial"),
              _t$years = t.years,
              r = _t$years === void 0 ? GetSlot(this, w) : _t$years,
              _t$months = t.months,
              o = _t$months === void 0 ? GetSlot(this, D) : _t$months,
              _t$weeks = t.weeks,
              n = _t$weeks === void 0 ? GetSlot(this, G) : _t$weeks,
              _t$days = t.days,
              a = _t$days === void 0 ? GetSlot(this, v) : _t$days,
              _t$hours = t.hours,
              i = _t$hours === void 0 ? GetSlot(this, C) : _t$hours,
              _t$minutes = t.minutes,
              s = _t$minutes === void 0 ? GetSlot(this, O) : _t$minutes,
              _t$seconds = t.seconds,
              l = _t$seconds === void 0 ? GetSlot(this, b) : _t$seconds,
              _t$milliseconds = t.milliseconds,
              d =
                _t$milliseconds === void 0
                 ? GetSlot(this, E)
                 : _t$milliseconds,
              _t$microseconds = t.microseconds,
              m =
                _t$microseconds === void 0
                 ? GetSlot(this, M)
                 : _t$microseconds,
              _t$nanoseconds = t.nanoseconds,
              c =
                _t$nanoseconds === void 0 ? GetSlot(this, R) : _t$nanoseconds;
             return new Duration(r, o, n, a, i, s, l, d, m, c);
            }},
           {key: "negated",
            value:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return CreateNegatedTemporalDuration(this);
            }},
           {key: "abs",
            value:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return new
                     Duration
                     (Math.abs(GetSlot(this, w)),
                      Math.abs(GetSlot(this, D)),
                      Math.abs(GetSlot(this, G)),
                      Math.abs(GetSlot(this, v)),
                      Math.abs(GetSlot(this, C)),
                      Math.abs(GetSlot(this, O)),
                      Math.abs(GetSlot(this, b)),
                      Math.abs(GetSlot(this, E)),
                      Math.abs(GetSlot(this, M)),
                      Math.abs(GetSlot(this, R)));
            }},
           {key: "add",
            value:
            function(e, t){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromDuration
                     ("add", this, e, t);
            }},
           {key: "subtract",
            value:
            function(e, t){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromDuration
                     ("subtract", this, e, t);
            }},
           {key: "round",
            value:
            function(t){
             var
              _UnbalanceDurationRel,
              _RoundDuration8,
              _AdjustRoundedDuratio2,
              _BalanceDuration11,
              _BalanceDurationRelat;
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             if(void 0 === t)
              throw new TypeError("options parameter is required");
             var
              r = GetSlot(this, w),
              o = GetSlot(this, D),
              n = GetSlot(this, G),
              a = GetSlot(this, v),
              i = GetSlot(this, C),
              s = GetSlot(this, O),
              l = GetSlot(this, b),
              d = GetSlot(this, E),
              m = GetSlot(this, M),
              c = GetSlot(this, R),
              h = DefaultTemporalLargestUnit(r, o, n, a, i, s, l, d, m, c),
              u =
                "string" == typeof t
                 ? CreateOnePropObject("smallestUnit", t)
                 : GetOptionsObject(t),
              T =
                GetTemporalUnit
                 (u, "largestUnit", "datetime", void 0, ["auto"]),
              f = ToRelativeTemporalObject(u),
              y = ToTemporalRoundingIncrement(u),
              I = ToTemporalRoundingMode(u, "halfExpand"),
              S = GetTemporalUnit(u, "smallestUnit", "datetime", void 0),
              g = ! 0;
             S || (g = ! 1, S = "nanosecond"),
             h = LargerOfTwoTemporalUnits(h, S);
             var F = ! 0;
             if(T || (F = ! 1, T = h), "auto" === T && (T = h), ! g && ! F)
              throw new
                     RangeError
                     ("at least one of smallestUnit or largestUnit is required");
             if(LargerOfTwoTemporalUnits(T, S) !== T)
              throw new
                     RangeError
                     ("largestUnit ".concat
                        (T, " cannot be smaller than smallestUnit ").concat
                       (S));
             var
              Y =
                {hour: 24,
                  minute: 60,
                  second: 60,
                  millisecond: 1e3,
                  microsecond: 1e3,
                  nanosecond: 1e3}
                 [S];
             return void 0 !== Y
                    && ValidateTemporalRoundingIncrement(y, Y, ! 1),
                    _UnbalanceDurationRel =
                     UnbalanceDurationRelative(r, o, n, a, T, f),
                    r = _UnbalanceDurationRel.years,
                    o = _UnbalanceDurationRel.months,
                    n = _UnbalanceDurationRel.weeks,
                    a = _UnbalanceDurationRel.days,
                    _RoundDuration8 =
                     RoundDuration(r, o, n, a, i, s, l, d, m, c, y, S, I, f),
                    r = _RoundDuration8.years,
                    o = _RoundDuration8.months,
                    n = _RoundDuration8.weeks,
                    a = _RoundDuration8.days,
                    i = _RoundDuration8.hours,
                    s = _RoundDuration8.minutes,
                    l = _RoundDuration8.seconds,
                    d = _RoundDuration8.milliseconds,
                    m = _RoundDuration8.microseconds,
                    c = _RoundDuration8.nanoseconds,
                    _AdjustRoundedDuratio2 =
                     AdjustRoundedDurationDays
                      (r, o, n, a, i, s, l, d, m, c, y, S, I, f),
                    r = _AdjustRoundedDuratio2.years,
                    o = _AdjustRoundedDuratio2.months,
                    n = _AdjustRoundedDuratio2.weeks,
                    a = _AdjustRoundedDuratio2.days,
                    i = _AdjustRoundedDuratio2.hours,
                    s = _AdjustRoundedDuratio2.minutes,
                    l = _AdjustRoundedDuratio2.seconds,
                    d = _AdjustRoundedDuratio2.milliseconds,
                    m = _AdjustRoundedDuratio2.microseconds,
                    c = _AdjustRoundedDuratio2.nanoseconds,
                    _BalanceDuration11 =
                     BalanceDuration(a, i, s, l, d, m, c, T, f),
                    a = _BalanceDuration11.days,
                    i = _BalanceDuration11.hours,
                    s = _BalanceDuration11.minutes,
                    l = _BalanceDuration11.seconds,
                    d = _BalanceDuration11.milliseconds,
                    m = _BalanceDuration11.microseconds,
                    c = _BalanceDuration11.nanoseconds,
                    _BalanceDurationRelat =
                     function(t, r, o, n, a, i){
                       var
                        s = GetIntrinsic("%Temporal.Duration%"),
                        l = DurationSign(t, r, o, n, 0, 0, 0, 0, 0, 0);
                       if(0 === l) return {years: t, months: r, weeks: o, days: n};
                       var
                        d = BigInt(l),
                        m,
                        c,
                        h = BigInt(t),
                        u = BigInt(r),
                        T = BigInt(o),
                        f = BigInt(n);
                       i && (c = ToTemporalDate(i), m = GetSlot(c, p));
                       var y = new s(l), I = new s(0, l), S = new s(0, 0, l);
                       switch(a){
                         case "year":
                          {
                           if(! m)
                            throw new
                                   RangeError
                                   ("a starting point is required for years balancing");
                           var
                            _t51 =
                              "string" != typeof m ? GetMethod(m, "dateAdd") : void 0,
                            _r68,
                            _o46,
                            _n28;
                           for
                           (_MoveRelativeDate11 = MoveRelativeDate(m, c, y, _t51),
                            _r68 = _MoveRelativeDate11.relativeTo,
                            _o46 = _MoveRelativeDate11.days,
                            _MoveRelativeDate11;
                            abs(f) >= BigInt(ae(_o46));){
                            var _MoveRelativeDate11, _MoveRelativeDate12;
                            f = f - BigInt(_o46),
                            h = h + d,
                            c = _r68,
                            _MoveRelativeDate12 = MoveRelativeDate(m, c, y, _t51),
                            _r68 = _MoveRelativeDate12.relativeTo,
                            _o46 = _MoveRelativeDate12.days;
                           }
                           for
                           (_MoveRelativeDate13 = MoveRelativeDate(m, c, I, _t51),
                            _r68 = _MoveRelativeDate13.relativeTo,
                            _n28 = _MoveRelativeDate13.days,
                            _MoveRelativeDate13;
                            abs(f) >= BigInt(ae(_n28));){
                            var _MoveRelativeDate13, _MoveRelativeDate14;
                            f = f - BigInt(_n28),
                            u = u + d,
                            c = _r68,
                            _MoveRelativeDate14 = MoveRelativeDate(m, c, I, _t51),
                            _r68 = _MoveRelativeDate14.relativeTo,
                            _n28 = _MoveRelativeDate14.days;
                           }
                           _r68 = CalendarDateAdd(m, c, y, void 0, _t51);
                           var
                            _a20 =
                              "string" != typeof m ? GetMethod(m, "dateUntil") : void 0,
                            _i25 = Te(null);
                           _i25.largestUnit = "month";
                           var
                            _s8 = CalendarDateUntil(m, c, _r68, _i25, _a20),
                            _l9 = GetSlot(_s8, D);
                           for(; abs(u) >= BigInt(ae(_l9));){
                            u = u - BigInt(_l9),
                            h = h + d,
                            c = _r68,
                            _r68 = CalendarDateAdd(m, c, y, void 0, _t51);
                            var _o47 = Te(null);
                            _o47.largestUnit = "month",
                            _s8 = CalendarDateUntil(m, c, _r68, _o47, _a20),
                            _l9 = GetSlot(_s8, D);
                           }
                           break;
                          }
                         case "month":
                          {
                           if(! m)
                            throw new
                                   RangeError
                                   ("a starting point is required for months balancing");
                           var
                            _t52 =
                              "string" != typeof m ? GetMethod(m, "dateAdd") : void 0,
                            _r69,
                            _o48;
                           for
                           (_MoveRelativeDate15 = MoveRelativeDate(m, c, I, _t52),
                            _r69 = _MoveRelativeDate15.relativeTo,
                            _o48 = _MoveRelativeDate15.days,
                            _MoveRelativeDate15;
                            abs(f) >= BigInt(ae(_o48));){
                            var _MoveRelativeDate15, _MoveRelativeDate16;
                            f = f - BigInt(_o48),
                            u = u + d,
                            c = _r69,
                            _MoveRelativeDate16 = MoveRelativeDate(m, c, I, _t52),
                            _r69 = _MoveRelativeDate16.relativeTo,
                            _o48 = _MoveRelativeDate16.days;
                           }
                           break;
                          }
                         case "week":
                          {
                           if(! m)
                            throw new
                                   RangeError
                                   ("a starting point is required for weeks balancing");
                           var
                            _t53 =
                              "string" != typeof m ? GetMethod(m, "dateAdd") : void 0,
                            _r70,
                            _o49;
                           for
                           (_MoveRelativeDate17 = MoveRelativeDate(m, c, S, _t53),
                            _r70 = _MoveRelativeDate17.relativeTo,
                            _o49 = _MoveRelativeDate17.days,
                            _MoveRelativeDate17;
                            abs(f) >= BigInt(ae(_o49));){
                            var _MoveRelativeDate17, _MoveRelativeDate18;
                            f = f - BigInt(_o49),
                            T = T + d,
                            c = _r70,
                            _MoveRelativeDate18 = MoveRelativeDate(m, c, S, _t53),
                            _r70 = _MoveRelativeDate18.relativeTo,
                            _o49 = _MoveRelativeDate18.days;
                           }
                           break;
                          }
                       }
                       return {years: Number(h),
                               months: Number(u),
                               weeks: Number(T),
                               days: Number(f)};
                      }
                      (r, o, n, a, T, f),
                    r = _BalanceDurationRelat.years,
                    o = _BalanceDurationRelat.months,
                    n = _BalanceDurationRelat.weeks,
                    a = _BalanceDurationRelat.days,
                    new Duration(r, o, n, a, i, s, l, d, m, c);
            }},
           {key: "total",
            value:
            function(e){
             var _UnbalanceDurationRel2;
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             var
              t = GetSlot(this, w),
              r = GetSlot(this, D),
              o = GetSlot(this, G),
              n = GetSlot(this, v),
              a = GetSlot(this, C),
              i = GetSlot(this, O),
              s = GetSlot(this, b),
              l = GetSlot(this, E),
              d = GetSlot(this, M),
              m = GetSlot(this, R);
             if(void 0 === e)
              throw new TypeError("options argument is required");
             var
              c =
                "string" == typeof e
                 ? CreateOnePropObject("unit", e)
                 : GetOptionsObject(e),
              h = ToRelativeTemporalObject(c),
              u = GetTemporalUnit(c, "unit", "datetime", He),
              T;
             _UnbalanceDurationRel2 =
              UnbalanceDurationRelative(t, r, o, n, u, h),
             t = _UnbalanceDurationRel2.years,
             r = _UnbalanceDurationRel2.months,
             o = _UnbalanceDurationRel2.weeks,
             n = _UnbalanceDurationRel2.days,
             IsTemporalZonedDateTime(h)
             && (T = MoveRelativeZonedDateTime(h, t, r, o, 0));
             var
              p = BalancePossiblyInfiniteDuration(n, a, i, s, l, d, m, u, T);
             if("positive overflow" === p) return 1 / 0;
             if("negative overflow" === p) return - (1 / 0);
             n = p.days;
             a = p.hours;
             i = p.minutes;
             s = p.seconds;
             l = p.milliseconds;
             d = p.microseconds;
             m = p.nanoseconds;
             var
              _RoundDuration9 =
                RoundDuration(t, r, o, n, a, i, s, l, d, m, 1, u, "trunc", h),
              f = _RoundDuration9.total;
             return f;
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             var
              t = GetOptionsObject(e),
              r = ToFractionalSecondDigits(t),
              o = ToTemporalRoundingMode(t, "trunc"),
              n = GetTemporalUnit(t, "smallestUnit", "time", void 0);
             if("hour" === n || "minute" === n)
              throw new
                     RangeError
                     ('smallestUnit must be a time unit other than "hours" or "minutes"');
             var
              _ToSecondsStringPreci3 = ToSecondsStringPrecisionRecord(n, r),
              a = _ToSecondsStringPreci3.precision,
              i = _ToSecondsStringPreci3.unit,
              s = _ToSecondsStringPreci3.increment;
             return TemporalDurationToString
                     (this, a, {unit: i, increment: s, roundingMode: o});
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return TemporalDurationToString(this);
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalDuration(this))
              throw new TypeError("invalid receiver");
             return "undefined" != typeof Intl
                     && void 0 !== Intl.DurationFormat
                     ? new Intl.DurationFormat(e, t).format(this)
                     : (console.warn
                        ("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat."),
                       TemporalDurationToString(this));
            }},
           {key: "valueOf",
            value:
            function(){
             throw new TypeError("use compare() to compare Temporal.Duration");
            }}],
          [{key: "from",
            value:
            function(e){
             return IsTemporalDuration(e)
                     ? new
                       Duration
                       (GetSlot(e, w),
                        GetSlot(e, D),
                        GetSlot(e, G),
                        GetSlot(e, v),
                        GetSlot(e, C),
                        GetSlot(e, O),
                        GetSlot(e, b),
                        GetSlot(e, E),
                        GetSlot(e, M),
                        GetSlot(e, R))
                     : ToTemporalDuration(e);
            }},
           {key: "compare",
            value:
            function(t, r, o){
             var
              _UnbalanceDurationRel3,
              _UnbalanceDurationRel4,
              n = ToTemporalDuration(t),
              a = ToTemporalDuration(r),
              i = ToRelativeTemporalObject(GetOptionsObject(o)),
              s = GetSlot(n, w),
              l = GetSlot(n, D),
              d = GetSlot(n, G),
              m = GetSlot(n, v),
              c = GetSlot(n, C),
              h = GetSlot(n, O),
              u = GetSlot(n, b),
              T = GetSlot(n, E),
              p = GetSlot(n, M),
              f = GetSlot(n, R),
              y = GetSlot(a, w),
              I = GetSlot(a, D),
              S = GetSlot(a, G),
              g = GetSlot(a, v),
              F = GetSlot(a, C),
              Y = GetSlot(a, O),
              P = GetSlot(a, b),
              Z = GetSlot(a, E),
              B = GetSlot(a, M),
              N = GetSlot(a, R),
              j = CalculateOffsetShift(i, s, l, d, m),
              $ = CalculateOffsetShift(i, y, I, S, g);
             0 === s && 0 === y && 0 === l && 0 === I && 0 === d && 0 === S
             ||
              (_UnbalanceDurationRel3 =
                UnbalanceDurationRelative(s, l, d, m, "day", i),
               m = _UnbalanceDurationRel3.days,
               _UnbalanceDurationRel4 =
                UnbalanceDurationRelative(y, I, S, g, "day", i),
               g = _UnbalanceDurationRel4.days);
             var
              k = TotalDurationNanoseconds(m, c, h, u, T, p, f, j),
              U = TotalDurationNanoseconds(g, F, Y, P, Z, B, N, $);
             return ComparisonResult(Number(k - U));
            }}]);
        return Duration;
       }
       ();
   MakeIntrinsicClass(Duration, "Temporal.Duration");
   var
    bt = Object.create,
    PlainMonthDay =
      function(){
        function PlainMonthDay(e, t){
         var
          r =
            arguments.length > 2 && arguments[2] !== undefined
             ? arguments[2]
             : "iso8601",
          o =
            arguments.length > 3 && arguments[3] !== undefined
             ? arguments[3]
             : 1972;
         _classCallCheck(this, PlainMonthDay);
         CreateTemporalMonthDaySlots
          (this,
           ToIntegerWithTruncation(e),
           ToIntegerWithTruncation(t),
           ToTemporalCalendarSlotValue(r),
           ToIntegerWithTruncation(o));
        }
        _createClass
         (PlainMonthDay,
          [{key: "monthCode",
            get:
            function(){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthCode(GetSlot(this, p), this);
            }},
           {key: "day",
            get:
            function(){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return CalendarDay(GetSlot(this, p), this);
            }},
           {key: "calendarId",
            get:
            function(){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarIdentifier(GetSlot(this, p));
            }},
           {key: "with",
            value:
            function(e, t){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid argument");
             RejectTemporalLikeObject(e);
             var
              r = GetOptionsObject(t),
              o = GetSlot(this, p),
              n = CalendarFields(o, ["day", "month", "monthCode", "year"]),
              a = PrepareTemporalFields(this, n, []);
             return a =
                     CalendarMergeFields
                      (o, a, PrepareTemporalFields(e, n, "partial")),
                    a = PrepareTemporalFields(a, n, []),
                    CalendarMonthDayFromFields(o, a, r);
            }},
           {key: "equals",
            value:
            function(e){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalMonthDay(e);
             for
             (var _i26 = 0, _arr11 = [s, l, i]; _i26 < _arr11.length; _i26++){
              var _e57 = _arr11[_i26];
              if(GetSlot(this, _e57) !== GetSlot(t, _e57)) return ! 1;
             }
             return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return TemporalMonthDayToString
                     (this, ToCalendarNameOption(GetOptionsObject(e)));
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return TemporalMonthDayToString(this);
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return new ht(e, t).format(this);
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use equals() to compare Temporal.PlainMonthDay");
            }},
           {key: "toPlainDate",
            value:
            function(e){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e))
              throw new TypeError("argument should be an object");
             var
              t = GetSlot(this, p),
              r = CalendarFields(t, ["day", "monthCode"]),
              o = PrepareTemporalFields(this, r, []),
              n = CalendarFields(t, ["year"]),
              a = CalendarMergeFields(t, o, PrepareTemporalFields(e, n, []));
             a =
              PrepareTemporalFields
               (a,
                _toConsumableArray
                 (new
                   Set
                   ([].concat(_toConsumableArray(r), _toConsumableArray(n)))),
                []);
             var i = bt(null);
             return i.overflow = "reject", CalendarDateFromFields(t, a, i);
            }},
           {key: "getISOFields",
            value:
            function(){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return {calendar: GetSlot(this, p),
                     isoDay: GetSlot(this, l),
                     isoMonth: GetSlot(this, s),
                     isoYear: GetSlot(this, i)};
            }},
           {key: "getCalendar",
            value:
            function(){
             if(! IsTemporalMonthDay(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarObject(GetSlot(this, p));
            }}],
          [{key: "from",
            value:
            function(e, t){
             var r = GetOptionsObject(t);
             return IsTemporalMonthDay(e)
                     ? (ToTemporalOverflow
                        (r),
                       CreateTemporalMonthDay
                        (GetSlot(e, s), GetSlot(e, l), GetSlot(e, p), GetSlot(e, i)))
                     : ToTemporalMonthDay(e, r);
            }}]);
        return PlainMonthDay;
       }
       ();
   MakeIntrinsicClass(PlainMonthDay, "Temporal.PlainMonthDay");
   var
    instant =
      function(){return new (GetIntrinsic("%Temporal.Instant%"))(Ve());},
    plainDateTime =
      function(e){
       var
        t =
          arguments.length > 1 && arguments[1] !== undefined
           ? arguments[1]
           : DefaultTimeZone(),
        r = ToTemporalTimeZoneSlotValue(t),
        o = ToTemporalCalendarSlotValue(e);
       return GetPlainDateTimeFor(r, instant(), o);
      },
    plainDateTimeISO =
      function(){
       var
        e =
          arguments.length > 0 && arguments[0] !== undefined
           ? arguments[0]
           : DefaultTimeZone();
       return GetPlainDateTimeFor
               (ToTemporalTimeZoneSlotValue(e), instant(), "iso8601");
      },
    zonedDateTime =
      function(e){
       var
        t =
          arguments.length > 1 && arguments[1] !== undefined
           ? arguments[1]
           : DefaultTimeZone(),
        r = ToTemporalTimeZoneSlotValue(t),
        o = ToTemporalCalendarSlotValue(e);
       return CreateTemporalZonedDateTime(Ve(), r, o);
      },
    Et =
      _defineProperty
       ({instant: instant,
         plainDateTime: plainDateTime,
         plainDateTimeISO: plainDateTimeISO,
         plainDate:
         function(e){
          var
           t =
             arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : DefaultTimeZone();
          return TemporalDateTimeToDate(plainDateTime(e, t));
         },
         plainDateISO:
         function(){
          var
           e =
             arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : DefaultTimeZone();
          return TemporalDateTimeToDate(plainDateTimeISO(e));
         },
         plainTimeISO:
         function(){
          var
           e =
             arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : DefaultTimeZone();
          return TemporalDateTimeToTime(plainDateTimeISO(e));
         },
         timeZoneId: function(){return DefaultTimeZone();},
         zonedDateTime: zonedDateTime,
         zonedDateTimeISO:
         function(){
          var
           e =
             arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : DefaultTimeZone();
          return zonedDateTime("iso8601", e);
         }},
        Symbol.toStringTag,
        "Temporal.Now");
   Object.defineProperty
    (Et,
     Symbol.toStringTag,
     {value: "Temporal.Now",
      writable: ! 1,
      enumerable: ! 1,
      configurable: ! 0});
   var Mt = Object.assign;
   function TemporalTimeToString(e, t, r){
    var
     o = GetSlot(e, d),
     n = GetSlot(e, m),
     a = GetSlot(e, c),
     i = GetSlot(e, h),
     s = GetSlot(e, u),
     l = GetSlot(e, T);
    if(r){
     var
      _e58 = r.unit,
      _t54 = r.increment,
      _d12 = r.roundingMode,
      _RoundTime2 = RoundTime(o, n, a, i, s, l, _t54, _e58, _d12);
     o = _RoundTime2.hour;
     n = _RoundTime2.minute;
     a = _RoundTime2.second;
     i = _RoundTime2.millisecond;
     s = _RoundTime2.microsecond;
     l = _RoundTime2.nanosecond;
    }
    return "".concat(ISODateTimePartString(o), ":").concat
             (ISODateTimePartString(n)).concat
            (FormatSecondsStringPart(a, i, s, l, t));
   }
   var
    PlainTime =
      function(){
        function PlainTime(){
         var
          e =
            arguments.length > 0 && arguments[0] !== undefined
             ? arguments[0]
             : 0,
          t =
            arguments.length > 1 && arguments[1] !== undefined
             ? arguments[1]
             : 0,
          r =
            arguments.length > 2 && arguments[2] !== undefined
             ? arguments[2]
             : 0,
          o =
            arguments.length > 3 && arguments[3] !== undefined
             ? arguments[3]
             : 0,
          n =
            arguments.length > 4 && arguments[4] !== undefined
             ? arguments[4]
             : 0,
          a =
            arguments.length > 5 && arguments[5] !== undefined
             ? arguments[5]
             : 0;
         _classCallCheck(this, PlainTime);
         var
          i = void 0 === e ? 0 : ToIntegerWithTruncation(e),
          s = void 0 === t ? 0 : ToIntegerWithTruncation(t),
          l = void 0 === r ? 0 : ToIntegerWithTruncation(r),
          p = void 0 === o ? 0 : ToIntegerWithTruncation(o),
          f = void 0 === n ? 0 : ToIntegerWithTruncation(n),
          y = void 0 === a ? 0 : ToIntegerWithTruncation(a);
         RejectTime(i, s, l, p, f, y),
         N(this),
         SetSlot(this, d, i),
         SetSlot(this, m, s),
         SetSlot(this, c, l),
         SetSlot(this, h, p),
         SetSlot(this, u, f),
         SetSlot(this, T, y);
        }
        _createClass
         (PlainTime,
          [{key: "hour",
            get:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, d);
            }},
           {key: "minute",
            get:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, m);
            }},
           {key: "second",
            get:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, c);
            }},
           {key: "millisecond",
            get:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, h);
            }},
           {key: "microsecond",
            get:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, u);
            }},
           {key: "nanosecond",
            get:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, T);
            }},
           {key: "with",
            value:
            function(e, t){
             var _RegulateTime4;
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid argument");
             RejectTemporalLikeObject(e);
             var
              r = ToTemporalOverflow(GetOptionsObject(t)),
              o = ToTemporalTimeRecord(e, "partial"),
              n = ToTemporalTimeRecord(this),
              _Mt = Mt(n, o),
              a = _Mt.hour,
              i = _Mt.minute,
              s = _Mt.second,
              l = _Mt.millisecond,
              d = _Mt.microsecond,
              m = _Mt.nanosecond;
             return _RegulateTime4 = RegulateTime(a, i, s, l, d, m, r),
                    a = _RegulateTime4.hour,
                    i = _RegulateTime4.minute,
                    s = _RegulateTime4.second,
                    l = _RegulateTime4.millisecond,
                    d = _RegulateTime4.microsecond,
                    m = _RegulateTime4.nanosecond,
                    new PlainTime(a, i, s, l, d, m);
            }},
           {key: "add",
            value:
            function(e){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromPlainTime
                     ("add", this, e);
            }},
           {key: "subtract",
            value:
            function(e){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromPlainTime
                     ("subtract", this, e);
            }},
           {key: "until",
            value:
            function(e, t){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainTime("until", this, e, t);
            }},
           {key: "since",
            value:
            function(e, t){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainTime("since", this, e, t);
            }},
           {key: "round",
            value:
            function(e){
             var _RoundTime3;
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             if(void 0 === e)
              throw new TypeError("options parameter is required");
             var
              t =
                "string" == typeof e
                 ? CreateOnePropObject("smallestUnit", e)
                 : GetOptionsObject(e),
              r = ToTemporalRoundingIncrement(t),
              o = ToTemporalRoundingMode(t, "halfExpand"),
              n = GetTemporalUnit(t, "smallestUnit", "time", He);
             ValidateTemporalRoundingIncrement
              (r,
               {hour: 24,
                 minute: 60,
                 second: 60,
                 millisecond: 1e3,
                 microsecond: 1e3,
                 nanosecond: 1e3}
                [n],
               ! 1);
             var
              a = GetSlot(this, d),
              i = GetSlot(this, m),
              s = GetSlot(this, c),
              l = GetSlot(this, h),
              p = GetSlot(this, u),
              f = GetSlot(this, T);
             return _RoundTime3 = RoundTime(a, i, s, l, p, f, r, n, o),
                    a = _RoundTime3.hour,
                    i = _RoundTime3.minute,
                    s = _RoundTime3.second,
                    l = _RoundTime3.millisecond,
                    p = _RoundTime3.microsecond,
                    f = _RoundTime3.nanosecond,
                    new PlainTime(a, i, s, l, p, f);
            }},
           {key: "equals",
            value:
            function(e){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalTime(e);
             for
             (var _i27 = 0, _arr12 = [d, m, c, h, u, T];
              _i27 < _arr12.length;
              _i27++){
              var _e59 = _arr12[_i27];
              if(GetSlot(this, _e59) !== GetSlot(t, _e59)) return ! 1;
             }
             return ! 0;
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             var
              t = GetOptionsObject(e),
              r = ToFractionalSecondDigits(t),
              o = ToTemporalRoundingMode(t, "trunc"),
              n = GetTemporalUnit(t, "smallestUnit", "time", void 0);
             if("hour" === n)
              throw new
                     RangeError
                     ('smallestUnit must be a time unit other than "hour"');
             var
              _ToSecondsStringPreci4 = ToSecondsStringPrecisionRecord(n, r),
              a = _ToSecondsStringPreci4.precision,
              i = _ToSecondsStringPreci4.unit,
              s = _ToSecondsStringPreci4.increment;
             return TemporalTimeToString
                     (this, a, {unit: i, increment: s, roundingMode: o});
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return TemporalTimeToString(this, "auto");
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return new ht(e, t).format(this);
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use compare() or equals() to compare Temporal.PlainTime");
            }},
           {key: "toPlainDateTime",
            value:
            function(e){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             var
              t = ToTemporalDate(e),
              r = GetSlot(t, i),
              o = GetSlot(t, s),
              n = GetSlot(t, l),
              a = GetSlot(t, p);
             return CreateTemporalDateTime
                     (r,
                      o,
                      n,
                      GetSlot(this, d),
                      GetSlot(this, m),
                      GetSlot(this, c),
                      GetSlot(this, h),
                      GetSlot(this, u),
                      GetSlot(this, T),
                      a);
            }},
           {key: "toZonedDateTime",
            value:
            function(e){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid argument");
             var t = e.plainDate;
             if(void 0 === t) throw new TypeError("missing date property");
             var r = ToTemporalDate(t), o = e.timeZone;
             if(void 0 === o)
              throw new TypeError("missing timeZone property");
             var
              a = ToTemporalTimeZoneSlotValue(o),
              f = GetSlot(r, i),
              y = GetSlot(r, s),
              I = GetSlot(r, l),
              S = GetSlot(r, p),
              g = GetSlot(this, d),
              w = GetSlot(this, m),
              D = GetSlot(this, c),
              G = GetSlot(this, h),
              v = GetSlot(this, u),
              C = GetSlot(this, T);
             return CreateTemporalZonedDateTime
                     (GetSlot
                       (GetInstantFor
                         (a,
                          new
                           (GetIntrinsic("%Temporal.PlainDateTime%"))
                           (f, y, I, g, w, D, G, v, C, S),
                          "compatible"),
                        n),
                      a,
                      S);
            }},
           {key: "getISOFields",
            value:
            function(){
             if(! IsTemporalTime(this))
              throw new TypeError("invalid receiver");
             return {isoHour: GetSlot(this, d),
                     isoMicrosecond: GetSlot(this, u),
                     isoMillisecond: GetSlot(this, h),
                     isoMinute: GetSlot(this, m),
                     isoNanosecond: GetSlot(this, T),
                     isoSecond: GetSlot(this, c)};
            }}],
          [{key: "from",
            value:
            function(e, t){
             var r = ToTemporalOverflow(GetOptionsObject(t));
             return IsTemporalTime(e)
                     ? new
                       PlainTime
                       (GetSlot(e, d),
                        GetSlot(e, m),
                        GetSlot(e, c),
                        GetSlot(e, h),
                        GetSlot(e, u),
                        GetSlot(e, T))
                     : ToTemporalTime(e, r);
            }},
           {key: "compare",
            value:
            function(e, t){
             var r = ToTemporalTime(e), o = ToTemporalTime(t);
             for
             (var _i28 = 0, _arr13 = [d, m, c, h, u, T];
              _i28 < _arr13.length;
              _i28++){
              var
               _e60 = _arr13[_i28],
               _t55 = GetSlot(r, _e60),
               _n29 = GetSlot(o, _e60);
              if(_t55 !== _n29) return ComparisonResult(_t55 - _n29);
             }
             return 0;
            }}]);
        return PlainTime;
       }
       ();
   MakeIntrinsicClass(PlainTime, "Temporal.PlainTime");
   var
    TimeZone =
      function(){
        function TimeZone(e){
         _classCallCheck(this, TimeZone);
         if(arguments.length < 1)
          throw new RangeError("missing argument: identifier is required");
         var t = GetCanonicalTimeZoneIdentifier(e);
         N(this), SetSlot(this, a, t);
        }
        _createClass
         (TimeZone,
          [{key: "id",
            get:
            function(){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, a);
            }},
           {key: "getOffsetNanosecondsFor",
            value:
            function(e){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalInstant(e), r = GetSlot(this, a);
             return IsTimeZoneOffsetString(r)
                     ? ParseTimeZoneOffsetString(r)
                     : GetNamedTimeZoneOffsetNanoseconds(r, GetSlot(t, n));
            }},
           {key: "getOffsetStringFor",
            value:
            function(e){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             return GetOffsetStringFor(this, ToTemporalInstant(e));
            }},
           {key: "getPlainDateTimeFor",
            value:
            function(e){
             var
              t =
                arguments.length > 1 && arguments[1] !== undefined
                 ? arguments[1]
                 : "iso8601";
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             return GetPlainDateTimeFor
                     (this, ToTemporalInstant(e), ToTemporalCalendarSlotValue(t));
            }},
           {key: "getInstantFor",
            value:
            function(e, t){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             return GetInstantFor
                     (this,
                      ToTemporalDateTime(e),
                      ToTemporalDisambiguation(GetOptionsObject(t)));
            }},
           {key: "getPossibleInstantsFor",
            value:
            function(t){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             var
              r = ToTemporalDateTime(t),
              o = GetIntrinsic("%Temporal.Instant%"),
              n = GetSlot(this, a);
             if(IsTimeZoneOffsetString(n)){
              var
               _t56 =
                 GetUTCEpochNanoseconds
                  (GetSlot(r, i),
                   GetSlot(r, s),
                   GetSlot(r, l),
                   GetSlot(r, d),
                   GetSlot(r, m),
                   GetSlot(r, c),
                   GetSlot(r, h),
                   GetSlot(r, u),
                   GetSlot(r, T));
              if(null === _t56)
               throw new RangeError("DateTime outside of supported range");
              var _a21 = ParseTimeZoneOffsetString(n);
              return [new o(_t56 - BigInt(_a21))];
             }
             var
              p =
                function(t, r, o, n, a, i, s, l, d, m){
                  var c = GetUTCEpochNanoseconds(r, o, n, a, i, s, l, d, m);
                  if(null === c)
                   throw new RangeError("DateTime outside of supported range");
                  var h = c - Ee;
                  h < Me && (h = c);
                  var u = c + Ee;
                  u > Re && (u = c);
                  var
                   T = GetNamedTimeZoneOffsetNanoseconds(t, h),
                   p = GetNamedTimeZoneOffsetNanoseconds(t, u);
                  return (T === p ? [T] : [T, p]).map
                           (function(h){
                             var
                              u = c - BigInt(h),
                              T = GetNamedTimeZoneDateTimeParts(t, u);
                             if
                              (r === T.year && o === T.month && n === T.day
                               && a === T.hour
                               && i === T.minute
                               && s === T.second
                               && l === T.millisecond
                               && d === T.microsecond
                               && m === T.nanosecond)
                              return u;
                            }).filter
                          (function(e){return void 0 !== e;});
                 }
                 (n,
                  GetSlot(r, i),
                  GetSlot(r, s),
                  GetSlot(r, l),
                  GetSlot(r, d),
                  GetSlot(r, m),
                  GetSlot(r, c),
                  GetSlot(r, h),
                  GetSlot(r, u),
                  GetSlot(r, T));
             return p.map(function(e){return new o(e);});
            }},
           {key: "getNextTransition",
            value:
            function(e){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalInstant(e), r = GetSlot(this, a);
             if(IsTimeZoneOffsetString(r) || "UTC" === r) return null;
             var o = GetSlot(t, n), i = GetIntrinsic("%Temporal.Instant%");
             return o = GetNamedTimeZoneNextTransition(r, o),
                    null === o ? null : new i(o);
            }},
           {key: "getPreviousTransition",
            value:
            function(e){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalInstant(e), r = GetSlot(this, a);
             if(IsTimeZoneOffsetString(r) || "UTC" === r) return null;
             var o = GetSlot(t, n), i = GetIntrinsic("%Temporal.Instant%");
             return o = GetNamedTimeZonePreviousTransition(r, o),
                    null === o ? null : new i(o);
            }},
           {key: "toString",
            value:
            function(){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, a);
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalTimeZone(this))
              throw new TypeError("invalid receiver");
             return GetSlot(this, a);
            }}],
          [{key: "from",
            value:
            function(e){
             return ToTemporalTimeZoneObject(ToTemporalTimeZoneSlotValue(e));
            }}]);
        return TimeZone;
       }
       ();
   MakeIntrinsicClass(TimeZone, "Temporal.TimeZone"),
   DefineIntrinsic
    ("Temporal.TimeZone.prototype.getOffsetNanosecondsFor",
     TimeZone.prototype.getOffsetNanosecondsFor),
   DefineIntrinsic
    ("Temporal.TimeZone.prototype.getPossibleInstantsFor",
     TimeZone.prototype.getPossibleInstantsFor);
   var
    Rt = Object.create,
    PlainYearMonth =
      function(){
        function PlainYearMonth(e, t){
         var
          r =
            arguments.length > 2 && arguments[2] !== undefined
             ? arguments[2]
             : "iso8601",
          o =
            arguments.length > 3 && arguments[3] !== undefined
             ? arguments[3]
             : 1;
         _classCallCheck(this, PlainYearMonth);
         CreateTemporalYearMonthSlots
          (this,
           ToIntegerWithTruncation(e),
           ToIntegerWithTruncation(t),
           ToTemporalCalendarSlotValue(r),
           ToIntegerWithTruncation(o));
        }
        _createClass
         (PlainYearMonth,
          [{key: "year",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarYear(GetSlot(this, p), this);
            }},
           {key: "month",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarMonth(GetSlot(this, p), this);
            }},
           {key: "monthCode",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthCode(GetSlot(this, p), this);
            }},
           {key: "calendarId",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarIdentifier(GetSlot(this, p));
            }},
           {key: "era",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarEra(GetSlot(this, p), this);
            }},
           {key: "eraYear",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarEraYear(GetSlot(this, p), this);
            }},
           {key: "daysInMonth",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInMonth(GetSlot(this, p), this);
            }},
           {key: "daysInYear",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInYear(GetSlot(this, p), this);
            }},
           {key: "monthsInYear",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthsInYear(GetSlot(this, p), this);
            }},
           {key: "inLeapYear",
            get:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return CalendarInLeapYear(GetSlot(this, p), this);
            }},
           {key: "with",
            value:
            function(e, t){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e)) throw new TypeError("invalid argument");
             RejectTemporalLikeObject(e);
             var
              r = GetOptionsObject(t),
              o = GetSlot(this, p),
              n = CalendarFields(o, ["month", "monthCode", "year"]),
              a = PrepareTemporalFields(this, n, []);
             return a =
                     CalendarMergeFields
                      (o, a, PrepareTemporalFields(e, n, "partial")),
                    a = PrepareTemporalFields(a, n, []),
                    CalendarYearMonthFromFields(o, a, r);
            }},
           {key: "add",
            value:
            function(e, t){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromPlainYearMonth
                     ("add", this, e, t);
            }},
           {key: "subtract",
            value:
            function(e, t){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromPlainYearMonth
                     ("subtract", this, e, t);
            }},
           {key: "until",
            value:
            function(e, t){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainYearMonth("until", this, e, t);
            }},
           {key: "since",
            value:
            function(e, t){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalPlainYearMonth("since", this, e, t);
            }},
           {key: "equals",
            value:
            function(e){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalYearMonth(e);
             for
             (var _i29 = 0, _arr14 = [i, s, l]; _i29 < _arr14.length; _i29++){
              var _e61 = _arr14[_i29];
              if(GetSlot(this, _e61) !== GetSlot(t, _e61)) return ! 1;
             }
             return CalendarEquals(GetSlot(this, p), GetSlot(t, p));
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return TemporalYearMonthToString
                     (this, ToCalendarNameOption(GetOptionsObject(e)));
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return TemporalYearMonthToString(this);
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return new ht(e, t).format(this);
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use compare() or equals() to compare Temporal.PlainYearMonth");
            }},
           {key: "toPlainDate",
            value:
            function(e){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e))
              throw new TypeError("argument should be an object");
             var
              t = GetSlot(this, p),
              r = CalendarFields(t, ["monthCode", "year"]),
              o = PrepareTemporalFields(this, r, []),
              n = CalendarFields(t, ["day"]),
              a = CalendarMergeFields(t, o, PrepareTemporalFields(e, n, []));
             a =
              PrepareTemporalFields
               (a,
                _toConsumableArray
                 (new
                   Set
                   ([].concat(_toConsumableArray(r), _toConsumableArray(n)))),
                []);
             var i = Rt(null);
             return i.overflow = "reject", CalendarDateFromFields(t, a, i);
            }},
           {key: "getISOFields",
            value:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return {calendar: GetSlot(this, p),
                     isoDay: GetSlot(this, l),
                     isoMonth: GetSlot(this, s),
                     isoYear: GetSlot(this, i)};
            }},
           {key: "getCalendar",
            value:
            function(){
             if(! IsTemporalYearMonth(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarObject(GetSlot(this, p));
            }}],
          [{key: "from",
            value:
            function(e, t){
             var r = GetOptionsObject(t);
             return IsTemporalYearMonth(e)
                     ? (ToTemporalOverflow
                        (r),
                       CreateTemporalYearMonth
                        (GetSlot(e, i), GetSlot(e, s), GetSlot(e, p), GetSlot(e, l)))
                     : ToTemporalYearMonth(e, r);
            }},
           {key: "compare",
            value:
            function(e, t){
             var r = ToTemporalYearMonth(e), o = ToTemporalYearMonth(t);
             return CompareISODate
                     (GetSlot(r, i),
                      GetSlot(r, s),
                      GetSlot(r, l),
                      GetSlot(o, i),
                      GetSlot(o, s),
                      GetSlot(o, l));
            }}]);
        return PlainYearMonth;
       }
       ();
   MakeIntrinsicClass(PlainYearMonth, "Temporal.PlainYearMonth");
   var
    Ft = ht.prototype.resolvedOptions,
    Yt = Object.create,
    ZonedDateTime =
      function(){
        function ZonedDateTime(e, t){
         var
          r =
            arguments.length > 2 && arguments[2] !== undefined
             ? arguments[2]
             : "iso8601";
         _classCallCheck(this, ZonedDateTime);
         if(arguments.length < 1)
          throw new
                 TypeError
                 ("missing argument: epochNanoseconds is required");
         CreateTemporalZonedDateTimeSlots
          (this,
           ToBigInt(e),
           ToTemporalTimeZoneSlotValue(t),
           ToTemporalCalendarSlotValue(r));
        }
        _createClass
         (ZonedDateTime,
          [{key: "calendarId",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarIdentifier(GetSlot(this, p));
            }},
           {key: "timeZoneId",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return ToTemporalTimeZoneIdentifier(GetSlot(this, g));
            }},
           {key: "year",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "month",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarMonth(GetSlot(this, p), dateTime(this));
            }},
           {key: "monthCode",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthCode(GetSlot(this, p), dateTime(this));
            }},
           {key: "day",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDay(GetSlot(this, p), dateTime(this));
            }},
           {key: "hour",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(dateTime(this), d);
            }},
           {key: "minute",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(dateTime(this), m);
            }},
           {key: "second",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(dateTime(this), c);
            }},
           {key: "millisecond",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(dateTime(this), h);
            }},
           {key: "microsecond",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(dateTime(this), u);
            }},
           {key: "nanosecond",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetSlot(dateTime(this), T);
            }},
           {key: "era",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarEra(GetSlot(this, p), dateTime(this));
            }},
           {key: "eraYear",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarEraYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "epochSeconds",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var t = GetSlot(this, n);
             return Number(BigIntFloorDiv(t, ve));
            }},
           {key: "epochMilliseconds",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var t = GetSlot(this, n);
             return Number(BigIntFloorDiv(t, Ge));
            }},
           {key: "epochMicroseconds",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return ToBigIntExternal(BigIntFloorDiv(GetSlot(this, n), De));
            }},
           {key: "epochNanoseconds",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return ToBigIntExternal(GetSlot(this, n));
            }},
           {key: "dayOfWeek",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDayOfWeek(GetSlot(this, p), dateTime(this));
            }},
           {key: "dayOfYear",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDayOfYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "weekOfYear",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarWeekOfYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "yearOfWeek",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarYearOfWeek(GetSlot(this, p), dateTime(this));
            }},
           {key: "hoursInDay",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = dateTime(this),
              r = GetIntrinsic("%Temporal.PlainDateTime%"),
              o = GetSlot(t, i),
              a = GetSlot(t, s),
              d = GetSlot(t, l),
              m = new r(o, a, d, 0, 0, 0, 0, 0, 0),
              c = AddISODate(o, a, d, 0, 0, 0, 1, "reject"),
              h = new r(c.year, c.month, c.day, 0, 0, 0, 0, 0, 0),
              u = GetSlot(this, g),
              T = GetSlot(GetInstantFor(u, m, "compatible"), n),
              p = GetSlot(GetInstantFor(u, h, "compatible"), n);
             return BigIntDivideToNumber(p - T, Oe);
            }},
           {key: "daysInWeek",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInWeek(GetSlot(this, p), dateTime(this));
            }},
           {key: "daysInMonth",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInMonth(GetSlot(this, p), dateTime(this));
            }},
           {key: "daysInYear",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarDaysInYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "monthsInYear",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarMonthsInYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "inLeapYear",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return CalendarInLeapYear(GetSlot(this, p), dateTime(this));
            }},
           {key: "offset",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetOffsetStringFor(GetSlot(this, g), GetSlot(this, S));
            }},
           {key: "offsetNanoseconds",
            get:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return GetOffsetNanosecondsFor
                     (GetSlot(this, g), GetSlot(this, S));
            }},
           {key: "with",
            value:
            function(e, t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             if(! IsObject(e))
              throw new TypeError("invalid zoned-date-time-like");
             RejectTemporalLikeObject(e);
             var
              r = GetOptionsObject(t),
              o = GetSlot(this, p),
              n =
                CalendarFields
                 (o,
                  ["day",
                   "hour",
                   "microsecond",
                   "millisecond",
                   "minute",
                   "month",
                   "monthCode",
                   "nanosecond",
                   "second",
                   "year"]);
             n.push("offset");
             var a = PrepareTemporalFields(this, n, ["offset"]);
             a =
              CalendarMergeFields
               (o, a, PrepareTemporalFields(e, n, "partial")),
             a = PrepareTemporalFields(a, n, ["offset"]);
             var
              i = ToTemporalDisambiguation(r),
              s = ToTemporalOffset(r, "prefer"),
              _InterpretTemporalDat5 =
                InterpretTemporalDateTimeFields(o, a, r),
              l = _InterpretTemporalDat5.year,
              d = _InterpretTemporalDat5.month,
              m = _InterpretTemporalDat5.day,
              c = _InterpretTemporalDat5.hour,
              h = _InterpretTemporalDat5.minute,
              u = _InterpretTemporalDat5.second,
              T = _InterpretTemporalDat5.millisecond,
              f = _InterpretTemporalDat5.microsecond,
              y = _InterpretTemporalDat5.nanosecond,
              I = ParseTimeZoneOffsetString(a.offset),
              S = GetSlot(this, g);
             return CreateTemporalZonedDateTime
                     (InterpretISODateTimeOffset
                       (l, d, m, c, h, u, T, f, y, "option", I, S, i, s, ! 1),
                      S,
                      o);
            }},
           {key: "withPlainDate",
            value:
            function(e){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = ToTemporalDate(e),
              r = GetSlot(t, i),
              o = GetSlot(t, s),
              a = GetSlot(t, l),
              f = GetSlot(t, p),
              y = dateTime(this),
              I = GetSlot(y, d),
              S = GetSlot(y, m),
              w = GetSlot(y, c),
              D = GetSlot(y, h),
              G = GetSlot(y, u),
              v = GetSlot(y, T);
             f = ConsolidateCalendars(GetSlot(this, p), f);
             var C = GetSlot(this, g);
             return CreateTemporalZonedDateTime
                     (GetSlot
                       (GetInstantFor
                         (C,
                          new
                           (GetIntrinsic("%Temporal.PlainDateTime%"))
                           (r, o, a, I, S, w, D, G, v, f),
                          "compatible"),
                        n),
                      C,
                      f);
            }},
           {key: "withPlainTime",
            value:
            function(e){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = GetIntrinsic("%Temporal.PlainTime%"),
              r = void 0 === e ? new t() : ToTemporalTime(e),
              o = dateTime(this),
              a = GetSlot(o, i),
              f = GetSlot(o, s),
              y = GetSlot(o, l),
              I = GetSlot(this, p),
              S = GetSlot(r, d),
              w = GetSlot(r, m),
              D = GetSlot(r, c),
              G = GetSlot(r, h),
              v = GetSlot(r, u),
              C = GetSlot(r, T),
              O = GetSlot(this, g);
             return CreateTemporalZonedDateTime
                     (GetSlot
                       (GetInstantFor
                         (O,
                          new
                           (GetIntrinsic("%Temporal.PlainDateTime%"))
                           (a, f, y, S, w, D, G, v, C, I),
                          "compatible"),
                        n),
                      O,
                      I);
            }},
           {key: "withTimeZone",
            value:
            function(e){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalTimeZoneSlotValue(e);
             return CreateTemporalZonedDateTime
                     (GetSlot(this, n), t, GetSlot(this, p));
            }},
           {key: "withCalendar",
            value:
            function(e){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var t = ToTemporalCalendarSlotValue(e);
             return CreateTemporalZonedDateTime
                     (GetSlot(this, n), GetSlot(this, g), t);
            }},
           {key: "add",
            value:
            function(e, t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromZonedDateTime
                     ("add", this, e, t);
            }},
           {key: "subtract",
            value:
            function(e, t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return AddDurationToOrSubtractDurationFromZonedDateTime
                     ("subtract", this, e, t);
            }},
           {key: "until",
            value:
            function(e, t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalZonedDateTime("until", this, e, t);
            }},
           {key: "since",
            value:
            function(e, t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return DifferenceTemporalZonedDateTime("since", this, e, t);
            }},
           {key: "round",
            value:
            function(t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             if(void 0 === t)
              throw new TypeError("options parameter is required");
             var
              r =
                "string" == typeof t
                 ? CreateOnePropObject("smallestUnit", t)
                 : GetOptionsObject(t),
              o = ToTemporalRoundingIncrement(r),
              a = ToTemporalRoundingMode(r, "halfExpand"),
              f = GetTemporalUnit(r, "smallestUnit", "time", He, ["day"]),
              y =
                {day: 1,
                  hour: 24,
                  minute: 60,
                  second: 60,
                  millisecond: 1e3,
                  microsecond: 1e3,
                  nanosecond: 1e3}
                 [f];
             ValidateTemporalRoundingIncrement(o, y, 1 === y);
             var
              I = dateTime(this),
              w = GetSlot(I, i),
              D = GetSlot(I, s),
              G = GetSlot(I, l),
              v = GetSlot(I, d),
              C = GetSlot(I, m),
              O = GetSlot(I, c),
              b = GetSlot(I, h),
              E = GetSlot(I, u),
              M = GetSlot(I, T),
              R = GetIntrinsic("%Temporal.PlainDateTime%"),
              F = GetSlot(this, g),
              Y = GetSlot(this, p),
              P =
                GetInstantFor
                 (F,
                  new
                   R
                   (GetSlot(I, i),
                    GetSlot(I, s),
                    GetSlot(I, l),
                    0,
                    0,
                    0,
                    0,
                    0,
                    0),
                  "compatible"),
              Z = AddZonedDateTime(P, F, Y, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0),
              B = Z - BigInt(GetSlot(P, n));
             if(B <= Ie)
              throw new
                     RangeError
                     ("cannot round a ZonedDateTime in a calendar with zero or negative length days");
             var
              _RoundISODateTime3 =
                RoundISODateTime
                 (w, D, G, v, C, O, b, E, M, o, f, a, Number(B));
             w = _RoundISODateTime3.year;
             D = _RoundISODateTime3.month;
             G = _RoundISODateTime3.day;
             v = _RoundISODateTime3.hour;
             C = _RoundISODateTime3.minute;
             O = _RoundISODateTime3.second;
             b = _RoundISODateTime3.millisecond;
             E = _RoundISODateTime3.microsecond;
             M = _RoundISODateTime3.nanosecond;
             return CreateTemporalZonedDateTime
                     (InterpretISODateTimeOffset
                       (w,
                        D,
                        G,
                        v,
                        C,
                        O,
                        b,
                        E,
                        M,
                        "option",
                        GetOffsetNanosecondsFor(F, GetSlot(this, S)),
                        F,
                        "compatible",
                        "prefer",
                        ! 1),
                      F,
                      GetSlot(this, p));
            }},
           {key: "equals",
            value:
            function(t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var
              r = ToTemporalZonedDateTime(t),
              o = GetSlot(this, n),
              a = GetSlot(r, n);
             return !
                    !
                    (BigInt(o) === BigInt(a))
                    && ! ! TimeZoneEquals(GetSlot(this, g), GetSlot(r, g))
                    && CalendarEquals(GetSlot(this, p), GetSlot(r, p));
            }},
           {key: "toString",
            value:
            function(e){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var
              t = GetOptionsObject(e),
              r = ToCalendarNameOption(t),
              o = ToFractionalSecondDigits(t),
              n =
                function(e){
                  return GetOption(e, "offset", ["auto", "never"], "auto");
                 }
                 (t),
              a = ToTemporalRoundingMode(t, "trunc"),
              i = GetTemporalUnit(t, "smallestUnit", "time", void 0);
             if("hour" === i)
              throw new
                     RangeError
                     ('smallestUnit must be a time unit other than "hour"');
             var
              s =
                function(e){
                  return GetOption
                          (e, "timeZoneName", ["auto", "never", "critical"], "auto");
                 }
                 (t),
              _ToSecondsStringPreci5 = ToSecondsStringPrecisionRecord(i, o),
              l = _ToSecondsStringPreci5.precision,
              d = _ToSecondsStringPreci5.unit,
              m = _ToSecondsStringPreci5.increment;
             return TemporalZonedDateTimeToString
                     (this, l, r, s, n, {unit: d, increment: m, roundingMode: a});
            }},
           {key: "toLocaleString",
            value:
            function(e, t){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var r = GetOptionsObject(t), o = Yt(null);
             if(CopyDataProperties(o, r, ["timeZone"]), void 0 !== r.timeZone)
              throw new
                     TypeError
                     ("ZonedDateTime toLocaleString does not accept a timeZone option");
             void 0 === o.year && void 0 === o.month && void 0 === o.day
             && void 0 === o.weekday
             && void 0 === o.dateStyle
             && void 0 === o.hour
             && void 0 === o.minute
             && void 0 === o.second
             && void 0 === o.timeStyle
             && void 0 === o.dayPeriod
             && void 0 === o.timeZoneName
             && (o.timeZoneName = "short");
             var n = ToTemporalTimeZoneIdentifier(GetSlot(this, g));
             if(IsTimeZoneOffsetString(n))
              throw new
                     RangeError
                     ("toLocaleString does not support offset string time zones");
             n = GetCanonicalTimeZoneIdentifier(n), o.timeZone = n;
             var
              a = new ht(e, o),
              i = Call(Ft, a, []).calendar,
              s = ToTemporalCalendarIdentifier(GetSlot(this, p));
             if("iso8601" !== s && "iso8601" !== i && i !== s)
              throw new
                     RangeError
                     ("cannot format ZonedDateTime with calendar ".concat
                        (s, " in locale with calendar ").concat
                       (i));
             return a.format(GetSlot(this, S));
            }},
           {key: "toJSON",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return TemporalZonedDateTimeToString(this, "auto");
            }},
           {key: "valueOf",
            value:
            function(){
             throw new
                    TypeError
                    ("use compare() or equals() to compare Temporal.ZonedDateTime");
            }},
           {key: "startOfDay",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var
              e = dateTime(this),
              t = GetIntrinsic("%Temporal.PlainDateTime%"),
              r = GetSlot(this, p),
              o =
                new
                 t
                 (GetSlot(e, i),
                  GetSlot(e, s),
                  GetSlot(e, l),
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  r),
              a = GetSlot(this, g);
             return CreateTemporalZonedDateTime
                     (GetSlot(GetInstantFor(a, o, "compatible"), n), a, r);
            }},
           {key: "toInstant",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(this, n));
            }},
           {key: "toPlainDate",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return TemporalDateTimeToDate(dateTime(this));
            }},
           {key: "toPlainTime",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return TemporalDateTimeToTime(dateTime(this));
            }},
           {key: "toPlainDateTime",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return dateTime(this);
            }},
           {key: "toPlainYearMonth",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var e = GetSlot(this, p);
             return CalendarYearMonthFromFields
                     (e,
                      PrepareTemporalFields
                       (this, CalendarFields(e, ["monthCode", "year"]), []));
            }},
           {key: "toPlainMonthDay",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var e = GetSlot(this, p);
             return CalendarMonthDayFromFields
                     (e,
                      PrepareTemporalFields
                       (this, CalendarFields(e, ["day", "monthCode"]), []));
            }},
           {key: "getISOFields",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             var e = dateTime(this), t = GetSlot(this, g);
             return {calendar: GetSlot(this, p),
                     isoDay: GetSlot(e, l),
                     isoHour: GetSlot(e, d),
                     isoMicrosecond: GetSlot(e, u),
                     isoMillisecond: GetSlot(e, h),
                     isoMinute: GetSlot(e, m),
                     isoMonth: GetSlot(e, s),
                     isoNanosecond: GetSlot(e, T),
                     isoSecond: GetSlot(e, c),
                     isoYear: GetSlot(e, i),
                     offset: GetOffsetStringFor(t, GetSlot(this, S)),
                     timeZone: t};
            }},
           {key: "getCalendar",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return ToTemporalCalendarObject(GetSlot(this, p));
            }},
           {key: "getTimeZone",
            value:
            function(){
             if(! IsTemporalZonedDateTime(this))
              throw new TypeError("invalid receiver");
             return ToTemporalTimeZoneObject(GetSlot(this, g));
            }}],
          [{key: "from",
            value:
            function(e, t){
             var r = GetOptionsObject(t);
             return IsTemporalZonedDateTime(e)
                     ? (ToTemporalDisambiguation
                        (r),
                       ToTemporalOffset(r, "reject"),
                       ToTemporalOverflow(r),
                       CreateTemporalZonedDateTime
                        (GetSlot(e, n), GetSlot(e, g), GetSlot(e, p)))
                     : ToTemporalZonedDateTime(e, r);
            }},
           {key: "compare",
            value:
            function(t, r){
             var
              o = ToTemporalZonedDateTime(t),
              a = ToTemporalZonedDateTime(r),
              i = GetSlot(o, n),
              s = GetSlot(a, n);
             return BigInt(i) < BigInt(s)
                     ? - 1
                     : BigInt(i) > BigInt(s) ? 1 : 0;
            }}]);
        return ZonedDateTime;
       }
       ();
   function dateTime(e){
    return GetPlainDateTimeFor(GetSlot(e, g), GetSlot(e, S), GetSlot(e, p));
   }
   MakeIntrinsicClass(ZonedDateTime, "Temporal.ZonedDateTime");
   var
    Pt =
      Object.freeze
       ({__proto__: null,
         Calendar: Calendar,
         Duration: Duration,
         Instant: Instant,
         Now: Et,
         PlainDate: PlainDate,
         PlainDateTime: PlainDateTime,
         PlainMonthDay: PlainMonthDay,
         PlainTime: PlainTime,
         PlainYearMonth: PlainYearMonth,
         TimeZone: TimeZone,
         ZonedDateTime: ZonedDateTime});
   function toTemporalInstant(){
    var t = BigInt(+ this) * Ge;
    return new Instant(t);
   }
   var
    Zt =
      [Instant,
       Calendar,
       PlainDate,
       PlainDateTime,
       Duration,
       PlainMonthDay,
       PlainTime,
       TimeZone,
       PlainYearMonth,
       ZonedDateTime];
   for(var _i30 = 0, _Zt = Zt; _i30 < _Zt.length; _i30++){
    var
     _e62 = _Zt[_i30],
     _t57 = Object.getOwnPropertyDescriptor(_e62, "prototype");
    (_t57.configurable || _t57.enumerable || _t57.writable)
    &&
     (_t57.configurable = ! 1,
      _t57.enumerable = ! 1,
      _t57.writable = ! 1,
      Object.defineProperty(_e62, "prototype", _t57));
   }
   var
    TemporalPolyfill =
      Object.freeze
       ({__proto__: null,
         Intl: ut,
         Temporal: Pt,
         toTemporalInstant: toTemporalInstant});
   globalThis.TemporalPolyfill = TemporalPolyfill;
  }
  (globalThis));
(function(globalThis){
   (function(f){
      if(typeof exports === "object" && typeof module !== "undefined")
       module.exports = f();
      else if(typeof define === "function" && define.amd)
       define([], f);
      else{
       var g;
       if(typeof window !== "undefined")
        g = window;
       else if(typeof global !== "undefined")
        g = global;
       else if(typeof self !== "undefined") g = self; else g = this;
       g.VirtualDom = f();
      }
     }
     (function(){
       var define, module, exports;
       return function(){
                  function r(e, n, t){
                   function o(i, f){
                    if(! n[i]){
                     if(! e[i]){
                      var c = "function" == typeof require && require;
                      if(! f && c) return c(i, ! 0);
                      if(u) return u(i, ! 0);
                      var a = new Error("Cannot find module '" + i + "'");
                      throw a.code = "MODULE_NOT_FOUND", a;
                     }
                     var p = n[i] = {exports: {}};
                     e[i][0].call
                      (p.exports,
                       function(r){var n = e[i][1][r]; return o(n || r);},
                       p,
                       p.exports,
                       r,
                       e,
                       n,
                       t);
                    }
                    return n[i].exports;
                   }
                   for
                   (var u = "function" == typeof require && require, i = 0;
                    i < t.length;
                    i++)
                    o(t[i]);
                   return o;
                  }
                  return r;
                 }
                 ()
                ({1: [function(require, module, exports){}, {}],
                  2:
                  [function(require, module, exports){
                    module.exports =
                     function(undef){
                       var
                        nativeSplit = String.prototype.split,
                        compliantExecNpcg = /()??/.exec("")[1] === undef,
                        self;
                       self =
                        function(str, separator, limit){
                         if
                          (Object.prototype.toString.call(separator)
                           !== "[object RegExp]")
                          return nativeSplit.call(str, separator, limit);
                         var
                          output = [],
                          flags =
                            (separator.ignoreCase ? "i" : "")
                            + (separator.multiline ? "m" : "")
                            + (separator.extended ? "x" : "")
                            + (separator.sticky ? "y" : ""),
                          lastLastIndex = 0,
                          separator = new RegExp(separator.source, flags + "g"),
                          separator2,
                          match,
                          lastIndex,
                          lastLength;
                         str += "";
                         if(! compliantExecNpcg)
                          separator2 =
                           new RegExp("^" + separator.source + "$(?!\\s)", flags);
                         limit = limit === undef ? - 1 >>> 0 : limit >>> 0;
                         while(match = separator.exec(str)){
                          lastIndex = match.index + match[0].length;
                          if(lastIndex > lastLastIndex){
                           output.push(str.slice(lastLastIndex, match.index));
                           if(! compliantExecNpcg && match.length > 1)
                            match[0].replace
                             (separator2,
                              function(){
                               for(var i = 1; i < arguments.length - 2; i++)
                                if(arguments[i] === undef) match[i] = undef;
                              });
                           if(match.length > 1 && match.index < str.length)
                            Array.prototype.push.apply(output, match.slice(1));
                           lastLength = match[0].length;
                           lastLastIndex = lastIndex;
                           if(output.length >= limit) break;
                          }
                          if(separator.lastIndex === match.index)
                           separator.lastIndex++;
                         }
                         if(lastLastIndex === str.length){
                          if(lastLength || ! separator.test("")) output.push("");
                         }
                         else
                          output.push(str.slice(lastLastIndex));
                         return output.length > limit
                                 ? output.slice(0, limit)
                                 : output;
                        };
                       return self;
                      }
                      ();
                   },
                   {}],
                  3:
                  [function(require, module, exports){
                    "use strict";
                    var
                     OneVersionConstraint = require("individual/one-version"),
                     MY_VERSION = "7";
                    OneVersionConstraint("ev-store", MY_VERSION);
                    var hashKey = "__EV_STORE_KEY@" + MY_VERSION;
                    module.exports = EvStore;
                    function EvStore(elem){
                     var hash = elem[hashKey];
                     if(! hash) hash = elem[hashKey] = {};
                     return hash;
                    }
                   },
                   {"individual/one-version": 6}],
                  4:
                  [function(require, module, exports){
                    (function(global){
                       (function(){
                          var
                           topLevel =
                             typeof global !== "undefined"
                              ? global
                              : typeof window !== "undefined" ? window : {},
                           minDoc = require("min-document"),
                           doccy;
                          if(typeof document !== "undefined")
                           doccy = document;
                          else{
                           doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
                           if(! doccy)
                            doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
                          }
                          module.exports = doccy;
                         }.call
                         (this));
                      }.call
                      (this,
                       typeof global !== "undefined"
                        ? global
                        : typeof
                          self
                          !== "undefined"
                          ? self
                          : typeof window !== "undefined" ? window : {}));
                   },
                   {"min-document": 1}],
                  5:
                  [function(require, module, exports){
                    (function(global){
                       (function(){
                          "use strict";
                          var
                           root =
                             typeof window !== "undefined"
                              ? window
                              : typeof global !== "undefined" ? global : {};
                          module.exports = Individual;
                          function Individual(key, value){
                           if(key in root) return root[key];
                           root[key] = value;
                           return value;
                          }
                         }.call
                         (this));
                      }.call
                      (this,
                       typeof global !== "undefined"
                        ? global
                        : typeof
                          self
                          !== "undefined"
                          ? self
                          : typeof window !== "undefined" ? window : {}));
                   },
                   {}],
                  6:
                  [function(require, module, exports){
                    "use strict";
                    var Individual = require("./index.js");
                    module.exports = OneVersion;
                    function OneVersion(moduleName, version, defaultValue){
                     var
                      key = "__INDIVIDUAL_ONE_VERSION_" + moduleName,
                      enforceKey = key + "_ENFORCE_SINGLETON",
                      versionValue = Individual(enforceKey, version);
                     if(versionValue !== version)
                      throw new
                             Error
                             ("Can only have one copy of " + moduleName + ".\n"
                              + "You already have version "
                              + versionValue
                              + " installed.\n"
                              + "This means you cannot install version "
                              + version);
                     return Individual(key, defaultValue);
                    }
                   },
                   {"./index.js": 5}],
                  7:
                  [function(require, module, exports){
                    "use strict";
                    module.exports =
                     function(x){return typeof x === "object" && x !== null;};
                   },
                   {}],
                  8:
                  [function(require, module, exports){
                    var
                     nativeIsArray = Array.isArray,
                     toString = Object.prototype.toString;
                    module.exports = nativeIsArray || isArray;
                    function isArray(obj){
                     return toString.call(obj) === "[object Array]";
                    }
                   },
                   {}],
                  9:
                  [function(require, module, exports){
                    var createElement = require("./vdom/create-element.js");
                    module.exports = createElement;
                   },
                   {"./vdom/create-element.js": 13}],
                  10:
                  [function(require, module, exports){
                    var diff = require("./vtree/diff.js");
                    module.exports = diff;
                   },
                   {"./vtree/diff.js": 36}],
                  11:
                  [function(require, module, exports){
                    var patch = require("./vdom/patch.js");
                    module.exports = patch;
                   },
                   {"./vdom/patch.js": 16}],
                  12:
                  [function(require, module, exports){
                    var
                     isObject = require("is-object"),
                     isHook = require("../vnode/is-vhook.js");
                    module.exports = applyProperties;
                    function applyProperties(node, props, previous){
                     for(var propName in props){
                      var propValue = props[propName];
                      if(propValue === undefined)
                       removeProperty(node, propName, propValue, previous);
                      else if(isHook(propValue)){
                       removeProperty(node, propName, propValue, previous);
                       if(propValue.hook)
                        propValue.hook
                         (node, propName, previous ? previous[propName] : undefined);
                      }
                      else if(isObject(propValue))
                       patchObject(node, props, previous, propName, propValue);
                      else
                       node[propName] = propValue;
                     }
                    }
                    function removeProperty(node, propName, propValue, previous){
                     if(previous){
                      var previousValue = previous[propName];
                      if(! isHook(previousValue))
                       if(propName === "attributes")
                        for(var attrName in previousValue)
                         node.removeAttribute(attrName);
                       else if(propName === "style")
                        for(var i in previousValue) node.style[i] = "";
                       else if(typeof previousValue === "string")
                        node[propName] = "";
                       else
                        node[propName] = null;
                      else if(previousValue.unhook)
                       previousValue.unhook(node, propName, propValue);
                     }
                    }
                    function patchObject
                    (node, props, previous, propName, propValue){
                     var
                      previousValue = previous ? previous[propName] : undefined;
                     if(propName === "attributes"){
                      for(var attrName in propValue){
                       var attrValue = propValue[attrName];
                       if(attrValue === undefined)
                        node.removeAttribute(attrName);
                       else
                        node.setAttribute(attrName, attrValue);
                      }
                      return;
                     }
                     if
                      (previousValue && isObject(previousValue)
                       && getPrototype(previousValue) !== getPrototype(propValue)){node[propName] = propValue; return;}
                     if(! isObject(node[propName])) node[propName] = {};
                     var replacer = propName === "style" ? "" : undefined;
                     for(var k in propValue){
                      var value = propValue[k];
                      node[propName][k] = value === undefined ? replacer : value;
                     }
                    }
                    function getPrototype(value){
                     if(Object.getPrototypeOf)
                      return Object.getPrototypeOf(value);
                     else if(value.__proto__)
                      return value.__proto__;
                     else if(value.constructor)
                      return value.constructor.prototype;
                    }
                   },
                   {"../vnode/is-vhook.js": 27, "is-object": 7}],
                  13:
                  [function(require, module, exports){
                    var
                     document = require("global/document"),
                     applyProperties = require("./apply-properties"),
                     isVNode = require("../vnode/is-vnode.js"),
                     isVText = require("../vnode/is-vtext.js"),
                     isWidget = require("../vnode/is-widget.js"),
                     handleThunk = require("../vnode/handle-thunk.js");
                    module.exports = createElement;
                    function createElement(vnode, opts){
                     var
                      doc = opts ? opts.document || document : document,
                      warn = opts ? opts.warn : null;
                     vnode = handleThunk(vnode).a;
                     if(isWidget(vnode))
                      return vnode.init();
                     else if(isVText(vnode))
                      return doc.createTextNode(vnode.text);
                     else if(! isVNode(vnode)){
                      if(warn)
                       warn("Item is not a valid virtual dom node", vnode);
                      return null;
                     }
                     var
                      node =
                        vnode.namespace === null
                         ? doc.createElement(vnode.tagName)
                         : doc.createElementNS(vnode.namespace, vnode.tagName),
                      props = vnode.properties;
                     applyProperties(node, props);
                     var children = vnode.children;
                     for(var i = 0; i < children.length; i++){
                      var childNode = createElement(children[i], opts);
                      if(childNode) node.appendChild(childNode);
                     }
                     return node;
                    }
                   },
                   {"../vnode/handle-thunk.js": 25,
                    "../vnode/is-vnode.js": 28,
                    "../vnode/is-vtext.js": 29,
                    "../vnode/is-widget.js": 30,
                    "./apply-properties": 12,
                    "global/document": 4}],
                  14:
                  [function(require, module, exports){
                    var noChild = {};
                    module.exports = domIndex;
                    function domIndex(rootNode, tree, indices, nodes){
                     if(! indices || indices.length === 0)
                      return {};
                     else{
                      indices.sort(ascending);
                      return recurse(rootNode, tree, indices, nodes, 0);
                     }
                    }
                    function recurse(rootNode, tree, indices, nodes, rootIndex){
                     nodes = nodes || {};
                     if(rootNode){
                      if(indexInRange(indices, rootIndex, rootIndex))
                       nodes[rootIndex] = rootNode;
                      var vChildren = tree.children;
                      if(vChildren){
                       var childNodes = rootNode.childNodes;
                       for(var i = 0; i < tree.children.length; i++){
                        rootIndex += 1;
                        var
                         vChild = vChildren[i] || noChild,
                         nextIndex = rootIndex + (vChild.count || 0);
                        if(indexInRange(indices, rootIndex, nextIndex))
                         recurse(childNodes[i], vChild, indices, nodes, rootIndex);
                        rootIndex = nextIndex;
                       }
                      }
                     }
                     return nodes;
                    }
                    function indexInRange(indices, left, right){
                     if(indices.length === 0) return false;
                     var
                      minIndex = 0,
                      maxIndex = indices.length - 1,
                      currentIndex,
                      currentItem;
                     while(minIndex <= maxIndex){
                      currentIndex = (maxIndex + minIndex) / 2 >> 0;
                      currentItem = indices[currentIndex];
                      if(minIndex === maxIndex)
                       return currentItem >= left && currentItem <= right;
                      else if(currentItem < left)
                       minIndex = currentIndex + 1;
                      else if(currentItem > right)
                       maxIndex = currentIndex - 1;
                      else
                       return true;
                     }
                     return false;
                    }
                    function ascending(a, b){return a > b ? 1 : - 1;}
                   },
                   {}],
                  15:
                  [function(require, module, exports){
                    var
                     applyProperties = require("./apply-properties"),
                     isWidget = require("../vnode/is-widget.js"),
                     VPatch = require("../vnode/vpatch.js"),
                     updateWidget = require("./update-widget");
                    module.exports = applyPatch;
                    function applyPatch(vpatch, domNode, renderOptions){
                     var
                      type = vpatch.type,
                      vNode = vpatch.vNode,
                      patch = vpatch.patch;
                     switch(type){
                       case VPatch.REMOVE:
                        return removeNode(domNode, vNode);
                       case VPatch.INSERT:
                        return insertNode(domNode, patch, renderOptions);
                       case VPatch.VTEXT:
                        return stringPatch(domNode, vNode, patch, renderOptions);
                       case VPatch.WIDGET:
                        return widgetPatch(domNode, vNode, patch, renderOptions);
                       case VPatch.VNODE:
                        return vNodePatch(domNode, vNode, patch, renderOptions);
                       case VPatch.ORDER:
                        reorderChildren(domNode, patch); return domNode;
                       case VPatch.PROPS:
                        applyProperties(domNode, patch, vNode.properties);
                        return domNode;
                       case VPatch.THUNK:
                        return replaceRoot
                                (domNode,
                                 renderOptions.patch(domNode, patch, renderOptions));
                       default: return domNode;
                     }
                    }
                    function removeNode(domNode, vNode){
                     var parentNode = domNode.parentNode;
                     if(parentNode) parentNode.removeChild(domNode);
                     destroyWidget(domNode, vNode);
                     return null;
                    }
                    function insertNode(parentNode, vNode, renderOptions){
                     var newNode = renderOptions.render(vNode, renderOptions);
                     if(parentNode) parentNode.appendChild(newNode);
                     return parentNode;
                    }
                    function stringPatch
                    (domNode, leftVNode, vText, renderOptions){
                     var newNode;
                     if(domNode.nodeType === 3){
                      domNode.nodeValue = vText.text;
                      newNode = domNode;
                     }
                     else{
                      var parentNode = domNode.parentNode;
                      newNode = renderOptions.render(vText, renderOptions);
                      if(parentNode && newNode !== domNode)
                       parentNode.replaceChild(newNode, domNode);
                     }
                     return newNode;
                    }
                    function widgetPatch
                    (domNode, leftVNode, widget, renderOptions){
                     var updating = updateWidget(leftVNode, widget), newNode;
                     if(updating)
                      newNode = widget.update(leftVNode, domNode) || domNode;
                     else
                      newNode = renderOptions.render(widget, renderOptions);
                     var parentNode = domNode.parentNode;
                     if(parentNode && newNode !== domNode)
                      parentNode.replaceChild(newNode, domNode);
                     if(! updating) destroyWidget(domNode, leftVNode);
                     return newNode;
                    }
                    function vNodePatch
                    (domNode, leftVNode, vNode, renderOptions){
                     var
                      parentNode = domNode.parentNode,
                      newNode = renderOptions.render(vNode, renderOptions);
                     if(parentNode && newNode !== domNode)
                      parentNode.replaceChild(newNode, domNode);
                     return newNode;
                    }
                    function destroyWidget(domNode, w){
                     if(typeof w.destroy === "function" && isWidget(w))
                      w.destroy(domNode);
                    }
                    function reorderChildren(domNode, moves){
                     var
                      childNodes = domNode.childNodes,
                      keyMap = {},
                      node,
                      remove,
                      insert;
                     for(var i = 0; i < moves.removes.length; i++){
                      remove = moves.removes[i];
                      node = childNodes[remove.from];
                      if(remove.key) keyMap[remove.key] = node;
                      domNode.removeChild(node);
                     }
                     var length = childNodes.length;
                     for(var j = 0; j < moves.inserts.length; j++){
                      insert = moves.inserts[j];
                      node = keyMap[insert.key];
                      domNode.insertBefore
                       (node, insert.to >= length++ ? null : childNodes[insert.to]);
                     }
                    }
                    function replaceRoot(oldRoot, newRoot){
                     if
                      (oldRoot && newRoot && oldRoot !== newRoot
                       && oldRoot.parentNode)
                      oldRoot.parentNode.replaceChild(newRoot, oldRoot);
                     return newRoot;
                    }
                   },
                   {"../vnode/is-widget.js": 30,
                    "../vnode/vpatch.js": 33,
                    "./apply-properties": 12,
                    "./update-widget": 17}],
                  16:
                  [function(require, module, exports){
                    var
                     document = require("global/document"),
                     isArray = require("x-is-array"),
                     render = require("./create-element"),
                     domIndex = require("./dom-index"),
                     patchOp = require("./patch-op");
                    module.exports = patch;
                    function patch(rootNode, patches, renderOptions){
                     renderOptions = renderOptions || {};
                     renderOptions.patch =
                      renderOptions.patch && renderOptions.patch !== patch
                       ? renderOptions.patch
                       : patchRecursive;
                     renderOptions.render = renderOptions.render || render;
                     return renderOptions.patch(rootNode, patches, renderOptions);
                    }
                    function patchRecursive(rootNode, patches, renderOptions){
                     var indices = patchIndices(patches);
                     if(indices.length === 0) return rootNode;
                     var
                      index = domIndex(rootNode, patches.a, indices),
                      ownerDocument = rootNode.ownerDocument;
                     if(! renderOptions.document && ownerDocument !== document)
                      renderOptions.document = ownerDocument;
                     for(var i = 0; i < indices.length; i++){
                      var nodeIndex = indices[i];
                      rootNode =
                       applyPatch
                        (rootNode,
                         index[nodeIndex],
                         patches[nodeIndex],
                         renderOptions);
                     }
                     return rootNode;
                    }
                    function applyPatch
                    (rootNode, domNode, patchList, renderOptions){
                     if(! domNode) return rootNode;
                     var newNode;
                     if(isArray(patchList))
                      for(var i = 0; i < patchList.length; i++){
                       newNode = patchOp(patchList[i], domNode, renderOptions);
                       if(domNode === rootNode) rootNode = newNode;
                      }
                     else{
                      newNode = patchOp(patchList, domNode, renderOptions);
                      if(domNode === rootNode) rootNode = newNode;
                     }
                     return rootNode;
                    }
                    function patchIndices(patches){
                     var indices = [];
                     for(var key in patches)
                      if(key !== "a") indices.push(Number(key));
                     return indices;
                    }
                   },
                   {"./create-element": 13,
                    "./dom-index": 14,
                    "./patch-op": 15,
                    "global/document": 4,
                    "x-is-array": 8}],
                  17:
                  [function(require, module, exports){
                    var isWidget = require("../vnode/is-widget.js");
                    module.exports = updateWidget;
                    function updateWidget(a, b){
                     if(isWidget(a) && isWidget(b))
                      return "name" in a && "name" in b
                              ? a.id === b.id
                              : a.init === b.init;
                     return false;
                    }
                   },
                   {"../vnode/is-widget.js": 30}],
                  18:
                  [function(require, module, exports){
                    "use strict";
                    module.exports = AttributeHook;
                    function AttributeHook(namespace, value){
                     if(! (this instanceof AttributeHook))
                      return new AttributeHook(namespace, value);
                     this.namespace = namespace;
                     this.value = value;
                    }
                    AttributeHook.prototype.hook =
                     function(node, prop, prev){
                      if
                       (prev && prev.type === "AttributeHook"
                        && prev.value === this.value
                        && prev.namespace === this.namespace)
                       return;
                      node.setAttributeNS(this.namespace, prop, this.value);
                     };
                    AttributeHook.prototype.unhook =
                     function(node, prop, next){
                      if
                       (next && next.type === "AttributeHook"
                        && next.namespace === this.namespace)
                       return;
                      var
                       colonPosition = prop.indexOf(":"),
                       localName =
                         colonPosition > - 1 ? prop.substr(colonPosition + 1) : prop;
                      node.removeAttributeNS(this.namespace, localName);
                     };
                    AttributeHook.prototype.type = "AttributeHook";
                   },
                   {}],
                  19:
                  [function(require, module, exports){
                    "use strict";
                    var EvStore = require("ev-store");
                    module.exports = EvHook;
                    function EvHook(value){
                     if(! (this instanceof EvHook)) return new EvHook(value);
                     this.value = value;
                    }
                    EvHook.prototype.hook =
                     function(node, propertyName){
                      var es = EvStore(node), propName = propertyName.substr(3);
                      es[propName] = this.value;
                     };
                    EvHook.prototype.unhook =
                     function(node, propertyName){
                      var es = EvStore(node), propName = propertyName.substr(3);
                      es[propName] = undefined;
                     };
                   },
                   {"ev-store": 3}],
                  20:
                  [function(require, module, exports){
                    "use strict";
                    module.exports = SoftSetHook;
                    function SoftSetHook(value){
                     if(! (this instanceof SoftSetHook))
                      return new SoftSetHook(value);
                     this.value = value;
                    }
                    SoftSetHook.prototype.hook =
                     function(node, propertyName){
                      if(node[propertyName] !== this.value)
                       node[propertyName] = this.value;
                     };
                   },
                   {}],
                  21:
                  [function(require, module, exports){
                    "use strict";
                    var
                     isArray = require("x-is-array"),
                     VNode = require("../vnode/vnode.js"),
                     VText = require("../vnode/vtext.js"),
                     isVNode = require("../vnode/is-vnode"),
                     isVText = require("../vnode/is-vtext"),
                     isWidget = require("../vnode/is-widget"),
                     isHook = require("../vnode/is-vhook"),
                     isVThunk = require("../vnode/is-thunk"),
                     parseTag = require("./parse-tag.js"),
                     softSetHook = require("./hooks/soft-set-hook.js"),
                     evHook = require("./hooks/ev-hook.js");
                    module.exports = h;
                    function h(tagName, properties, children){
                     var childNodes = [], tag, props, key, namespace;
                     if(! children && isChildren(properties)){children = properties; props = {};}
                     props = props || properties || {};
                     tag = parseTag(tagName, props);
                     if(props.hasOwnProperty("key")){
                      key = props.key;
                      props.key = undefined;
                     }
                     if(props.hasOwnProperty("namespace")){
                      namespace = props.namespace;
                      props.namespace = undefined;
                     }
                     if
                      (tag === "INPUT" && ! namespace
                       && props.hasOwnProperty("value")
                       && props.value !== undefined
                       && ! isHook(props.value))
                      props.value = softSetHook(props.value);
                     transformProperties(props);
                     if(children !== undefined && children !== null)
                      addChild(children, childNodes, tag, props);
                     return new VNode(tag, props, childNodes, key, namespace);
                    }
                    function addChild(c, childNodes, tag, props){
                     if(typeof c === "string")
                      childNodes.push(new VText(c));
                     else if(typeof c === "number")
                      childNodes.push(new VText(String(c)));
                     else if(isChild(c))
                      childNodes.push(c);
                     else if(isArray(c))
                      for(var i = 0; i < c.length; i++)
                       addChild(c[i], childNodes, tag, props);
                     else if(c === null || c === undefined)
                      return;
                     else
                      throw UnexpectedVirtualElement
                             ({foreignObject: c,
                               parentVnode: {tagName: tag, properties: props}});
                    }
                    function transformProperties(props){
                     for(var propName in props)
                      if(props.hasOwnProperty(propName)){
                       var value = props[propName];
                       if(isHook(value)) continue;
                       if(propName.substr(0, 3) === "ev-")
                        props[propName] = evHook(value);
                      }
                    }
                    function isChild(x){
                     return isVNode(x) || isVText(x) || isWidget(x)
                            || isVThunk(x);
                    }
                    function isChildren(x){
                     return typeof x === "string" || isArray(x) || isChild(x);
                    }
                    function UnexpectedVirtualElement(data){
                     var err = new Error();
                     err.type = "virtual-hyperscript.unexpected.virtual-element";
                     err.message =
                      "Unexpected virtual child passed to h().\n"
                      + "Expected a VNode / Vthunk / VWidget / string but:\n"
                      + "got:\n"
                      + errorString(data.foreignObject)
                      + ".\n"
                      + "The parent vnode is:\n"
                      + errorString(data.parentVnode);
                     "\n"
                     + "Suggested fix: change your `h(..., [ ... ])` callsite.";
                     err.foreignObject = data.foreignObject;
                     err.parentVnode = data.parentVnode;
                     return err;
                    }
                    function UnsupportedValueType(data){
                     var err = new Error();
                     err.type = "virtual-hyperscript.unsupported.value-type";
                     err.message =
                      "Unexpected value type for input passed to h().\n"
                      + "Expected a "
                      + errorString(data.expected)
                      + " but got:\n"
                      + errorString(data.received)
                      + ".\n"
                      + "The vnode is:\n"
                      + errorString(data.Vnode);
                     "\n"
                     +
                      "Suggested fix: Cast the value passed to h() to a string using String(value).";
                     err.Vnode = data.Vnode;
                     return err;
                    }
                    function errorString(obj){
                     try{return JSON.stringify(obj, null, "    ");}
                     catch(e){return String(obj);}
                    }
                   },
                   {"../vnode/is-thunk": 26,
                    "../vnode/is-vhook": 27,
                    "../vnode/is-vnode": 28,
                    "../vnode/is-vtext": 29,
                    "../vnode/is-widget": 30,
                    "../vnode/vnode.js": 32,
                    "../vnode/vtext.js": 34,
                    "./hooks/ev-hook.js": 19,
                    "./hooks/soft-set-hook.js": 20,
                    "./parse-tag.js": 22,
                    "x-is-array": 8}],
                  22:
                  [function(require, module, exports){
                    "use strict";
                    var
                     split = require("browser-split"),
                     classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/,
                     notClassId = /^\.|#/;
                    module.exports = parseTag;
                    function parseTag(tag, props){
                     if(! tag) return "DIV";
                     var
                      noId = ! props.hasOwnProperty("id"),
                      tagParts = split(tag, classIdSplit),
                      tagName = null;
                     if(notClassId.test(tagParts[1])) tagName = "DIV";
                     var classes, part, type, i;
                     for(i = 0; i < tagParts.length; i++){
                      part = tagParts[i];
                      if(! part) continue;
                      type = part.charAt(0);
                      if(! tagName)
                       tagName = part;
                      else if(type === "."){
                       classes = classes || [];
                       classes.push(part.substring(1, part.length));
                      }
                      else if(type === "#" && noId)
                       props.id = part.substring(1, part.length);
                     }
                     if(classes){
                      if(props.className) classes.push(props.className);
                      props.className = classes.join(" ");
                     }
                     return props.namespace ? tagName : tagName.toUpperCase();
                    }
                   },
                   {"browser-split": 2}],
                  23:
                  [function(require, module, exports){
                    "use strict";
                    var
                     DEFAULT_NAMESPACE = null,
                     EV_NAMESPACE = "http://www.w3.org/2001/xml-events",
                     XLINK_NAMESPACE = "http://www.w3.org/1999/xlink",
                     XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace",
                     SVG_PROPERTIES =
                       {about: DEFAULT_NAMESPACE,
                        "accent-height": DEFAULT_NAMESPACE,
                        accumulate: DEFAULT_NAMESPACE,
                        additive: DEFAULT_NAMESPACE,
                        "alignment-baseline": DEFAULT_NAMESPACE,
                        alphabetic: DEFAULT_NAMESPACE,
                        amplitude: DEFAULT_NAMESPACE,
                        "arabic-form": DEFAULT_NAMESPACE,
                        ascent: DEFAULT_NAMESPACE,
                        attributeName: DEFAULT_NAMESPACE,
                        attributeType: DEFAULT_NAMESPACE,
                        azimuth: DEFAULT_NAMESPACE,
                        bandwidth: DEFAULT_NAMESPACE,
                        baseFrequency: DEFAULT_NAMESPACE,
                        baseProfile: DEFAULT_NAMESPACE,
                        "baseline-shift": DEFAULT_NAMESPACE,
                        bbox: DEFAULT_NAMESPACE,
                        begin: DEFAULT_NAMESPACE,
                        bias: DEFAULT_NAMESPACE,
                        by: DEFAULT_NAMESPACE,
                        calcMode: DEFAULT_NAMESPACE,
                        "cap-height": DEFAULT_NAMESPACE,
                        class: DEFAULT_NAMESPACE,
                        clip: DEFAULT_NAMESPACE,
                        "clip-path": DEFAULT_NAMESPACE,
                        "clip-rule": DEFAULT_NAMESPACE,
                        clipPathUnits: DEFAULT_NAMESPACE,
                        color: DEFAULT_NAMESPACE,
                        "color-interpolation": DEFAULT_NAMESPACE,
                        "color-interpolation-filters": DEFAULT_NAMESPACE,
                        "color-profile": DEFAULT_NAMESPACE,
                        "color-rendering": DEFAULT_NAMESPACE,
                        content: DEFAULT_NAMESPACE,
                        contentScriptType: DEFAULT_NAMESPACE,
                        contentStyleType: DEFAULT_NAMESPACE,
                        cursor: DEFAULT_NAMESPACE,
                        cx: DEFAULT_NAMESPACE,
                        cy: DEFAULT_NAMESPACE,
                        d: DEFAULT_NAMESPACE,
                        datatype: DEFAULT_NAMESPACE,
                        defaultAction: DEFAULT_NAMESPACE,
                        descent: DEFAULT_NAMESPACE,
                        diffuseConstant: DEFAULT_NAMESPACE,
                        direction: DEFAULT_NAMESPACE,
                        display: DEFAULT_NAMESPACE,
                        divisor: DEFAULT_NAMESPACE,
                        "dominant-baseline": DEFAULT_NAMESPACE,
                        dur: DEFAULT_NAMESPACE,
                        dx: DEFAULT_NAMESPACE,
                        dy: DEFAULT_NAMESPACE,
                        edgeMode: DEFAULT_NAMESPACE,
                        editable: DEFAULT_NAMESPACE,
                        elevation: DEFAULT_NAMESPACE,
                        "enable-background": DEFAULT_NAMESPACE,
                        end: DEFAULT_NAMESPACE,
                        "ev:event": EV_NAMESPACE,
                        event: DEFAULT_NAMESPACE,
                        exponent: DEFAULT_NAMESPACE,
                        externalResourcesRequired: DEFAULT_NAMESPACE,
                        fill: DEFAULT_NAMESPACE,
                        "fill-opacity": DEFAULT_NAMESPACE,
                        "fill-rule": DEFAULT_NAMESPACE,
                        filter: DEFAULT_NAMESPACE,
                        filterRes: DEFAULT_NAMESPACE,
                        filterUnits: DEFAULT_NAMESPACE,
                        "flood-color": DEFAULT_NAMESPACE,
                        "flood-opacity": DEFAULT_NAMESPACE,
                        focusHighlight: DEFAULT_NAMESPACE,
                        focusable: DEFAULT_NAMESPACE,
                        "font-family": DEFAULT_NAMESPACE,
                        "font-size": DEFAULT_NAMESPACE,
                        "font-size-adjust": DEFAULT_NAMESPACE,
                        "font-stretch": DEFAULT_NAMESPACE,
                        "font-style": DEFAULT_NAMESPACE,
                        "font-variant": DEFAULT_NAMESPACE,
                        "font-weight": DEFAULT_NAMESPACE,
                        format: DEFAULT_NAMESPACE,
                        from: DEFAULT_NAMESPACE,
                        fx: DEFAULT_NAMESPACE,
                        fy: DEFAULT_NAMESPACE,
                        g1: DEFAULT_NAMESPACE,
                        g2: DEFAULT_NAMESPACE,
                        "glyph-name": DEFAULT_NAMESPACE,
                        "glyph-orientation-horizontal": DEFAULT_NAMESPACE,
                        "glyph-orientation-vertical": DEFAULT_NAMESPACE,
                        glyphRef: DEFAULT_NAMESPACE,
                        gradientTransform: DEFAULT_NAMESPACE,
                        gradientUnits: DEFAULT_NAMESPACE,
                        handler: DEFAULT_NAMESPACE,
                        hanging: DEFAULT_NAMESPACE,
                        height: DEFAULT_NAMESPACE,
                        "horiz-adv-x": DEFAULT_NAMESPACE,
                        "horiz-origin-x": DEFAULT_NAMESPACE,
                        "horiz-origin-y": DEFAULT_NAMESPACE,
                        id: DEFAULT_NAMESPACE,
                        ideographic: DEFAULT_NAMESPACE,
                        "image-rendering": DEFAULT_NAMESPACE,
                        in: DEFAULT_NAMESPACE,
                        in2: DEFAULT_NAMESPACE,
                        initialVisibility: DEFAULT_NAMESPACE,
                        intercept: DEFAULT_NAMESPACE,
                        k: DEFAULT_NAMESPACE,
                        k1: DEFAULT_NAMESPACE,
                        k2: DEFAULT_NAMESPACE,
                        k3: DEFAULT_NAMESPACE,
                        k4: DEFAULT_NAMESPACE,
                        kernelMatrix: DEFAULT_NAMESPACE,
                        kernelUnitLength: DEFAULT_NAMESPACE,
                        kerning: DEFAULT_NAMESPACE,
                        keyPoints: DEFAULT_NAMESPACE,
                        keySplines: DEFAULT_NAMESPACE,
                        keyTimes: DEFAULT_NAMESPACE,
                        lang: DEFAULT_NAMESPACE,
                        lengthAdjust: DEFAULT_NAMESPACE,
                        "letter-spacing": DEFAULT_NAMESPACE,
                        "lighting-color": DEFAULT_NAMESPACE,
                        limitingConeAngle: DEFAULT_NAMESPACE,
                        local: DEFAULT_NAMESPACE,
                        "marker-end": DEFAULT_NAMESPACE,
                        "marker-mid": DEFAULT_NAMESPACE,
                        "marker-start": DEFAULT_NAMESPACE,
                        markerHeight: DEFAULT_NAMESPACE,
                        markerUnits: DEFAULT_NAMESPACE,
                        markerWidth: DEFAULT_NAMESPACE,
                        mask: DEFAULT_NAMESPACE,
                        maskContentUnits: DEFAULT_NAMESPACE,
                        maskUnits: DEFAULT_NAMESPACE,
                        mathematical: DEFAULT_NAMESPACE,
                        max: DEFAULT_NAMESPACE,
                        media: DEFAULT_NAMESPACE,
                        mediaCharacterEncoding: DEFAULT_NAMESPACE,
                        mediaContentEncodings: DEFAULT_NAMESPACE,
                        mediaSize: DEFAULT_NAMESPACE,
                        mediaTime: DEFAULT_NAMESPACE,
                        method: DEFAULT_NAMESPACE,
                        min: DEFAULT_NAMESPACE,
                        mode: DEFAULT_NAMESPACE,
                        name: DEFAULT_NAMESPACE,
                        "nav-down": DEFAULT_NAMESPACE,
                        "nav-down-left": DEFAULT_NAMESPACE,
                        "nav-down-right": DEFAULT_NAMESPACE,
                        "nav-left": DEFAULT_NAMESPACE,
                        "nav-next": DEFAULT_NAMESPACE,
                        "nav-prev": DEFAULT_NAMESPACE,
                        "nav-right": DEFAULT_NAMESPACE,
                        "nav-up": DEFAULT_NAMESPACE,
                        "nav-up-left": DEFAULT_NAMESPACE,
                        "nav-up-right": DEFAULT_NAMESPACE,
                        numOctaves: DEFAULT_NAMESPACE,
                        observer: DEFAULT_NAMESPACE,
                        offset: DEFAULT_NAMESPACE,
                        opacity: DEFAULT_NAMESPACE,
                        operator: DEFAULT_NAMESPACE,
                        order: DEFAULT_NAMESPACE,
                        orient: DEFAULT_NAMESPACE,
                        orientation: DEFAULT_NAMESPACE,
                        origin: DEFAULT_NAMESPACE,
                        overflow: DEFAULT_NAMESPACE,
                        overlay: DEFAULT_NAMESPACE,
                        "overline-position": DEFAULT_NAMESPACE,
                        "overline-thickness": DEFAULT_NAMESPACE,
                        "panose-1": DEFAULT_NAMESPACE,
                        path: DEFAULT_NAMESPACE,
                        pathLength: DEFAULT_NAMESPACE,
                        patternContentUnits: DEFAULT_NAMESPACE,
                        patternTransform: DEFAULT_NAMESPACE,
                        patternUnits: DEFAULT_NAMESPACE,
                        phase: DEFAULT_NAMESPACE,
                        playbackOrder: DEFAULT_NAMESPACE,
                        "pointer-events": DEFAULT_NAMESPACE,
                        points: DEFAULT_NAMESPACE,
                        pointsAtX: DEFAULT_NAMESPACE,
                        pointsAtY: DEFAULT_NAMESPACE,
                        pointsAtZ: DEFAULT_NAMESPACE,
                        preserveAlpha: DEFAULT_NAMESPACE,
                        preserveAspectRatio: DEFAULT_NAMESPACE,
                        primitiveUnits: DEFAULT_NAMESPACE,
                        propagate: DEFAULT_NAMESPACE,
                        property: DEFAULT_NAMESPACE,
                        r: DEFAULT_NAMESPACE,
                        radius: DEFAULT_NAMESPACE,
                        refX: DEFAULT_NAMESPACE,
                        refY: DEFAULT_NAMESPACE,
                        rel: DEFAULT_NAMESPACE,
                        "rendering-intent": DEFAULT_NAMESPACE,
                        repeatCount: DEFAULT_NAMESPACE,
                        repeatDur: DEFAULT_NAMESPACE,
                        requiredExtensions: DEFAULT_NAMESPACE,
                        requiredFeatures: DEFAULT_NAMESPACE,
                        requiredFonts: DEFAULT_NAMESPACE,
                        requiredFormats: DEFAULT_NAMESPACE,
                        resource: DEFAULT_NAMESPACE,
                        restart: DEFAULT_NAMESPACE,
                        result: DEFAULT_NAMESPACE,
                        rev: DEFAULT_NAMESPACE,
                        role: DEFAULT_NAMESPACE,
                        rotate: DEFAULT_NAMESPACE,
                        rx: DEFAULT_NAMESPACE,
                        ry: DEFAULT_NAMESPACE,
                        scale: DEFAULT_NAMESPACE,
                        seed: DEFAULT_NAMESPACE,
                        "shape-rendering": DEFAULT_NAMESPACE,
                        slope: DEFAULT_NAMESPACE,
                        snapshotTime: DEFAULT_NAMESPACE,
                        spacing: DEFAULT_NAMESPACE,
                        specularConstant: DEFAULT_NAMESPACE,
                        specularExponent: DEFAULT_NAMESPACE,
                        spreadMethod: DEFAULT_NAMESPACE,
                        startOffset: DEFAULT_NAMESPACE,
                        stdDeviation: DEFAULT_NAMESPACE,
                        stemh: DEFAULT_NAMESPACE,
                        stemv: DEFAULT_NAMESPACE,
                        stitchTiles: DEFAULT_NAMESPACE,
                        "stop-color": DEFAULT_NAMESPACE,
                        "stop-opacity": DEFAULT_NAMESPACE,
                        "strikethrough-position": DEFAULT_NAMESPACE,
                        "strikethrough-thickness": DEFAULT_NAMESPACE,
                        string: DEFAULT_NAMESPACE,
                        stroke: DEFAULT_NAMESPACE,
                        "stroke-dasharray": DEFAULT_NAMESPACE,
                        "stroke-dashoffset": DEFAULT_NAMESPACE,
                        "stroke-linecap": DEFAULT_NAMESPACE,
                        "stroke-linejoin": DEFAULT_NAMESPACE,
                        "stroke-miterlimit": DEFAULT_NAMESPACE,
                        "stroke-opacity": DEFAULT_NAMESPACE,
                        "stroke-width": DEFAULT_NAMESPACE,
                        surfaceScale: DEFAULT_NAMESPACE,
                        syncBehavior: DEFAULT_NAMESPACE,
                        syncBehaviorDefault: DEFAULT_NAMESPACE,
                        syncMaster: DEFAULT_NAMESPACE,
                        syncTolerance: DEFAULT_NAMESPACE,
                        syncToleranceDefault: DEFAULT_NAMESPACE,
                        systemLanguage: DEFAULT_NAMESPACE,
                        tableValues: DEFAULT_NAMESPACE,
                        target: DEFAULT_NAMESPACE,
                        targetX: DEFAULT_NAMESPACE,
                        targetY: DEFAULT_NAMESPACE,
                        "text-anchor": DEFAULT_NAMESPACE,
                        "text-decoration": DEFAULT_NAMESPACE,
                        "text-rendering": DEFAULT_NAMESPACE,
                        textLength: DEFAULT_NAMESPACE,
                        timelineBegin: DEFAULT_NAMESPACE,
                        title: DEFAULT_NAMESPACE,
                        to: DEFAULT_NAMESPACE,
                        transform: DEFAULT_NAMESPACE,
                        transformBehavior: DEFAULT_NAMESPACE,
                        type: DEFAULT_NAMESPACE,
                        typeof: DEFAULT_NAMESPACE,
                        u1: DEFAULT_NAMESPACE,
                        u2: DEFAULT_NAMESPACE,
                        "underline-position": DEFAULT_NAMESPACE,
                        "underline-thickness": DEFAULT_NAMESPACE,
                        unicode: DEFAULT_NAMESPACE,
                        "unicode-bidi": DEFAULT_NAMESPACE,
                        "unicode-range": DEFAULT_NAMESPACE,
                        "units-per-em": DEFAULT_NAMESPACE,
                        "v-alphabetic": DEFAULT_NAMESPACE,
                        "v-hanging": DEFAULT_NAMESPACE,
                        "v-ideographic": DEFAULT_NAMESPACE,
                        "v-mathematical": DEFAULT_NAMESPACE,
                        values: DEFAULT_NAMESPACE,
                        version: DEFAULT_NAMESPACE,
                        "vert-adv-y": DEFAULT_NAMESPACE,
                        "vert-origin-x": DEFAULT_NAMESPACE,
                        "vert-origin-y": DEFAULT_NAMESPACE,
                        viewBox: DEFAULT_NAMESPACE,
                        viewTarget: DEFAULT_NAMESPACE,
                        visibility: DEFAULT_NAMESPACE,
                        width: DEFAULT_NAMESPACE,
                        widths: DEFAULT_NAMESPACE,
                        "word-spacing": DEFAULT_NAMESPACE,
                        "writing-mode": DEFAULT_NAMESPACE,
                        x: DEFAULT_NAMESPACE,
                        "x-height": DEFAULT_NAMESPACE,
                        x1: DEFAULT_NAMESPACE,
                        x2: DEFAULT_NAMESPACE,
                        xChannelSelector: DEFAULT_NAMESPACE,
                        "xlink:actuate": XLINK_NAMESPACE,
                        "xlink:arcrole": XLINK_NAMESPACE,
                        "xlink:href": XLINK_NAMESPACE,
                        "xlink:role": XLINK_NAMESPACE,
                        "xlink:show": XLINK_NAMESPACE,
                        "xlink:title": XLINK_NAMESPACE,
                        "xlink:type": XLINK_NAMESPACE,
                        "xml:base": XML_NAMESPACE,
                        "xml:id": XML_NAMESPACE,
                        "xml:lang": XML_NAMESPACE,
                        "xml:space": XML_NAMESPACE,
                        y: DEFAULT_NAMESPACE,
                        y1: DEFAULT_NAMESPACE,
                        y2: DEFAULT_NAMESPACE,
                        yChannelSelector: DEFAULT_NAMESPACE,
                        z: DEFAULT_NAMESPACE,
                        zoomAndPan: DEFAULT_NAMESPACE};
                    module.exports = SVGAttributeNamespace;
                    function SVGAttributeNamespace(value){
                     if(SVG_PROPERTIES.hasOwnProperty(value))
                      return SVG_PROPERTIES[value];
                    }
                   },
                   {}],
                  24:
                  [function(require, module, exports){
                    "use strict";
                    var
                     isArray = require("x-is-array"),
                     h = require("./index.js"),
                     SVGAttributeNamespace = require("./svg-attribute-namespace"),
                     attributeHook = require("./hooks/attribute-hook"),
                     SVG_NAMESPACE = "http://www.w3.org/2000/svg";
                    module.exports = svg;
                    function svg(tagName, properties, children){
                     if(! children && isChildren(properties)){children = properties; properties = {};
                     }
                     properties = properties || {};
                     properties.namespace = SVG_NAMESPACE;
                     var
                      attributes =
                        properties.attributes || (properties.attributes = {});
                     for(var key in properties){
                      if(! properties.hasOwnProperty(key)) continue;
                      var namespace = SVGAttributeNamespace(key);
                      if(namespace === undefined) continue;
                      var value = properties[key];
                      if
                       (typeof value !== "string" && typeof value !== "number"
                        && typeof value !== "boolean")
                       continue;
                      if(namespace !== null){
                       properties[key] = attributeHook(namespace, value);
                       continue;
                      }
                      attributes[key] = value;
                      properties[key] = undefined;
                     }
                     return h(tagName, properties, children);
                    }
                    function isChildren(x){
                     return typeof x === "string" || isArray(x);
                    }
                   },
                   {"./hooks/attribute-hook": 18,
                    "./index.js": 21,
                    "./svg-attribute-namespace": 23,
                    "x-is-array": 8}],
                  25:
                  [function(require, module, exports){
                    var
                     isVNode = require("./is-vnode"),
                     isVText = require("./is-vtext"),
                     isWidget = require("./is-widget"),
                     isThunk = require("./is-thunk");
                    module.exports = handleThunk;
                    function handleThunk(a, b){
                     var renderedA = a, renderedB = b;
                     if(isThunk(b)) renderedB = renderThunk(b, a);
                     if(isThunk(a)) renderedA = renderThunk(a, null);
                     return {a: renderedA, b: renderedB};
                    }
                    function renderThunk(thunk, previous){
                     var renderedThunk = thunk.vnode;
                     if(! renderedThunk)
                      renderedThunk = thunk.vnode = thunk.render(previous);
                     if
                      (!
                       (isVNode(renderedThunk) || isVText(renderedThunk)
                       || isWidget(renderedThunk)))
                      throw new Error("thunk did not return a valid node");
                     return renderedThunk;
                    }
                   },
                   {"./is-thunk": 26,
                    "./is-vnode": 28,
                    "./is-vtext": 29,
                    "./is-widget": 30}],
                  26:
                  [function(require, module, exports){
                    module.exports = isThunk;
                    function isThunk(t){return t && t.type === "Thunk";}
                   },
                   {}],
                  27:
                  [function(require, module, exports){
                    module.exports = isHook;
                    function isHook(hook){
                     return hook
                            &&
                             (typeof hook.hook === "function"
                             && ! hook.hasOwnProperty("hook")
                             ||
                              typeof hook.unhook === "function"
                              && ! hook.hasOwnProperty("unhook"));
                    }
                   },
                   {}],
                  28:
                  [function(require, module, exports){
                    var version = require("./version");
                    module.exports = isVirtualNode;
                    function isVirtualNode(x){
                     return x && x.type === "VirtualNode"
                            && x.version === version;
                    }
                   },
                   {"./version": 31}],
                  29:
                  [function(require, module, exports){
                    var version = require("./version");
                    module.exports = isVirtualText;
                    function isVirtualText(x){
                     return x && x.type === "VirtualText"
                            && x.version === version;
                    }
                   },
                   {"./version": 31}],
                  30:
                  [function(require, module, exports){
                    module.exports = isWidget;
                    function isWidget(w){return w && w.type === "Widget";}
                   },
                   {}],
                  31:
                  [function(require, module, exports){module.exports = "2";},
                   {}],
                  32:
                  [function(require, module, exports){
                    var
                     version = require("./version"),
                     isVNode = require("./is-vnode"),
                     isWidget = require("./is-widget"),
                     isThunk = require("./is-thunk"),
                     isVHook = require("./is-vhook");
                    module.exports = VirtualNode;
                    var noProperties = {}, noChildren = [];
                    function VirtualNode
                    (tagName, properties, children, key, namespace){
                     this.tagName = tagName;
                     this.properties = properties || noProperties;
                     this.children = children || noChildren;
                     this.key = key != null ? String(key) : undefined;
                     this.namespace =
                      typeof namespace === "string" ? namespace : null;
                     var
                      count = children && children.length || 0,
                      descendants = 0,
                      hasWidgets = false,
                      hasThunks = false,
                      descendantHooks = false,
                      hooks;
                     for(var propName in properties)
                      if(properties.hasOwnProperty(propName)){
                       var property = properties[propName];
                       if(isVHook(property) && property.unhook){
                        if(! hooks) hooks = {};
                        hooks[propName] = property;
                       }
                      }
                     for(var i = 0; i < count; i++){
                      var child = children[i];
                      if(isVNode(child)){
                       descendants += child.count || 0;
                       if(! hasWidgets && child.hasWidgets) hasWidgets = true;
                       if(! hasThunks && child.hasThunks) hasThunks = true;
                       if
                        (! descendantHooks && (child.hooks || child.descendantHooks))
                        descendantHooks = true;
                      }
                      else
                       if(! hasWidgets && isWidget(child)){
                        if(typeof child.destroy === "function") hasWidgets = true;
                       }
                       else if(! hasThunks && isThunk(child)) hasThunks = true;
                     }
                     this.count = count + descendants;
                     this.hasWidgets = hasWidgets;
                     this.hasThunks = hasThunks;
                     this.hooks = hooks;
                     this.descendantHooks = descendantHooks;
                    }
                    VirtualNode.prototype.version = version;
                    VirtualNode.prototype.type = "VirtualNode";
                   },
                   {"./is-thunk": 26,
                    "./is-vhook": 27,
                    "./is-vnode": 28,
                    "./is-widget": 30,
                    "./version": 31}],
                  33:
                  [function(require, module, exports){
                    var version = require("./version");
                    VirtualPatch.NONE = 0;
                    VirtualPatch.VTEXT = 1;
                    VirtualPatch.VNODE = 2;
                    VirtualPatch.WIDGET = 3;
                    VirtualPatch.PROPS = 4;
                    VirtualPatch.ORDER = 5;
                    VirtualPatch.INSERT = 6;
                    VirtualPatch.REMOVE = 7;
                    VirtualPatch.THUNK = 8;
                    module.exports = VirtualPatch;
                    function VirtualPatch(type, vNode, patch){
                     this.type = Number(type);
                     this.vNode = vNode;
                     this.patch = patch;
                    }
                    VirtualPatch.prototype.version = version;
                    VirtualPatch.prototype.type = "VirtualPatch";
                   },
                   {"./version": 31}],
                  34:
                  [function(require, module, exports){
                    var version = require("./version");
                    module.exports = VirtualText;
                    function VirtualText(text){this.text = String(text);}
                    VirtualText.prototype.version = version;
                    VirtualText.prototype.type = "VirtualText";
                   },
                   {"./version": 31}],
                  35:
                  [function(require, module, exports){
                    var
                     isObject = require("is-object"),
                     isHook = require("../vnode/is-vhook");
                    module.exports = diffProps;
                    function diffProps(a, b){
                     var diff;
                     for(var aKey in a){
                      if(! (aKey in b)){
                       diff = diff || {};
                       diff[aKey] = undefined;
                      }
                      var aValue = a[aKey], bValue = b[aKey];
                      if(aValue === bValue)
                       continue;
                      else if(isObject(aValue) && isObject(bValue))
                       if(getPrototype(bValue) !== getPrototype(aValue)){diff = diff || {}; diff[aKey] = bValue;}
                       else if(isHook(bValue)){
                        diff = diff || {};
                        diff[aKey] = bValue;
                       }
                       else{
                        var objectDiff = diffProps(aValue, bValue);
                        if(objectDiff){diff = diff || {}; diff[aKey] = objectDiff;}
                       }
                      else{diff = diff || {}; diff[aKey] = bValue;}
                     }
                     for(var bKey in b)
                      if(! (bKey in a)){diff = diff || {}; diff[bKey] = b[bKey];}
                     return diff;
                    }
                    function getPrototype(value){
                     if(Object.getPrototypeOf)
                      return Object.getPrototypeOf(value);
                     else if(value.__proto__)
                      return value.__proto__;
                     else if(value.constructor)
                      return value.constructor.prototype;
                    }
                   },
                   {"../vnode/is-vhook": 27, "is-object": 7}],
                  36:
                  [function(require, module, exports){
                    var
                     isArray = require("x-is-array"),
                     VPatch = require("../vnode/vpatch"),
                     isVNode = require("../vnode/is-vnode"),
                     isVText = require("../vnode/is-vtext"),
                     isWidget = require("../vnode/is-widget"),
                     isThunk = require("../vnode/is-thunk"),
                     handleThunk = require("../vnode/handle-thunk"),
                     diffProps = require("./diff-props");
                    module.exports = diff;
                    function diff(a, b){
                     var patch = {a: a};
                     walk(a, b, patch, 0);
                     return patch;
                    }
                    function walk(a, b, patch, index){
                     if(a === b) return;
                     var apply = patch[index], applyClear = false;
                     if(isThunk(a) || isThunk(b))
                      thunks(a, b, patch, index);
                     else if(b == null){
                      if(! isWidget(a)){
                       clearState(a, patch, index);
                       apply = patch[index];
                      }
                      apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b));
                     }
                     else if(isVNode(b))
                      if(isVNode(a))
                       if
                        (a.tagName === b.tagName && a.namespace === b.namespace
                         && a.key === b.key){
                        var propsPatch = diffProps(a.properties, b.properties);
                        if(propsPatch)
                         apply =
                          appendPatch(apply, new VPatch(VPatch.PROPS, a, propsPatch));
                        apply = diffChildren(a, b, patch, apply, index);
                       }
                       else{
                        apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
                        applyClear = true;
                       }
                      else{
                       apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
                       applyClear = true;
                      }
                     else
                      if(isVText(b)){
                       if(! isVText(a)){
                        apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
                        applyClear = true;
                       }
                       else if(a.text !== b.text)
                        apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
                      }
                      else if(isWidget(b)){
                       if(! isWidget(a)) applyClear = true;
                       apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b));
                      }
                     if(apply) patch[index] = apply;
                     if(applyClear) clearState(a, patch, index);
                    }
                    function diffChildren(a, b, patch, apply, index){
                     var
                      aChildren = a.children,
                      orderedSet = reorder(aChildren, b.children),
                      bChildren = orderedSet.children,
                      aLen = aChildren.length,
                      bLen = bChildren.length,
                      len = aLen > bLen ? aLen : bLen;
                     for(var i = 0; i < len; i++){
                      var leftNode = aChildren[i], rightNode = bChildren[i];
                      index += 1;
                      if(! leftNode){
                       if(rightNode)
                        apply =
                         appendPatch
                          (apply, new VPatch(VPatch.INSERT, null, rightNode));
                      }
                      else
                       walk(leftNode, rightNode, patch, index);
                      if(isVNode(leftNode) && leftNode.count)
                       index += leftNode.count;
                     }
                     if(orderedSet.moves)
                      apply =
                       appendPatch
                        (apply, new VPatch(VPatch.ORDER, a, orderedSet.moves));
                     return apply;
                    }
                    function clearState(vNode, patch, index){
                     unhook(vNode, patch, index);
                     destroyWidgets(vNode, patch, index);
                    }
                    function destroyWidgets(vNode, patch, index){
                     if(isWidget(vNode)){
                      if(typeof vNode.destroy === "function")
                       patch[index] =
                        appendPatch
                         (patch[index], new VPatch(VPatch.REMOVE, vNode, null));
                     }
                     else if
                      (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)){
                      var children = vNode.children, len = children.length;
                      for(var i = 0; i < len; i++){
                       var child = children[i];
                       index += 1;
                       destroyWidgets(child, patch, index);
                       if(isVNode(child) && child.count) index += child.count;
                      }
                     }
                     else if(isThunk(vNode)) thunks(vNode, null, patch, index);
                    }
                    function thunks(a, b, patch, index){
                     var
                      nodes = handleThunk(a, b),
                      thunkPatch = diff(nodes.a, nodes.b);
                     if(hasPatches(thunkPatch))
                      patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch);
                    }
                    function hasPatches(patch){
                     for(var index in patch) if(index !== "a") return true;
                     return false;
                    }
                    function unhook(vNode, patch, index){
                     if(isVNode(vNode)){
                      if(vNode.hooks)
                       patch[index] =
                        appendPatch
                         (patch[index],
                          new VPatch(VPatch.PROPS, vNode, undefinedKeys(vNode.hooks)));
                      if(vNode.descendantHooks || vNode.hasThunks){
                       var children = vNode.children, len = children.length;
                       for(var i = 0; i < len; i++){
                        var child = children[i];
                        index += 1;
                        unhook(child, patch, index);
                        if(isVNode(child) && child.count) index += child.count;
                       }
                      }
                     }
                     else if(isThunk(vNode)) thunks(vNode, null, patch, index);
                    }
                    function undefinedKeys(obj){
                     var result = {};
                     for(var key in obj) result[key] = undefined;
                     return result;
                    }
                    function reorder(aChildren, bChildren){
                     var
                      bChildIndex = keyIndex(bChildren),
                      bKeys = bChildIndex.keys,
                      bFree = bChildIndex.free;
                     if(bFree.length === bChildren.length)
                      return {children: bChildren, moves: null};
                     var
                      aChildIndex = keyIndex(aChildren),
                      aKeys = aChildIndex.keys,
                      aFree = aChildIndex.free;
                     if(aFree.length === aChildren.length)
                      return {children: bChildren, moves: null};
                     var
                      newChildren = [],
                      freeIndex = 0,
                      freeCount = bFree.length,
                      deletedItems = 0;
                     for(var i = 0; i < aChildren.length; i++){
                      var aItem = aChildren[i], itemIndex;
                      if(aItem.key)
                       if(bKeys.hasOwnProperty(aItem.key)){
                        itemIndex = bKeys[aItem.key];
                        newChildren.push(bChildren[itemIndex]);
                       }
                       else{itemIndex = i - deletedItems++; newChildren.push(null);
                       }
                      else if(freeIndex < freeCount){
                       itemIndex = bFree[freeIndex++];
                       newChildren.push(bChildren[itemIndex]);
                      }
                      else{itemIndex = i - deletedItems++; newChildren.push(null);
                      }
                     }
                     var
                      lastFreeIndex =
                        freeIndex >= bFree.length
                         ? bChildren.length
                         : bFree[freeIndex];
                     for(var j = 0; j < bChildren.length; j++){
                      var newItem = bChildren[j];
                      if(newItem.key){
                       if(! aKeys.hasOwnProperty(newItem.key))
                        newChildren.push(newItem);
                      }
                      else if(j >= lastFreeIndex) newChildren.push(newItem);
                     }
                     var
                      simulate = newChildren.slice(),
                      simulateIndex = 0,
                      removes = [],
                      inserts = [],
                      simulateItem;
                     for(var k = 0; k < bChildren.length;){
                      var wantedItem = bChildren[k];
                      simulateItem = simulate[simulateIndex];
                      while(simulateItem === null && simulate.length){
                       removes.push(remove(simulate, simulateIndex, null));
                       simulateItem = simulate[simulateIndex];
                      }
                      if(! simulateItem || simulateItem.key !== wantedItem.key){
                       if(wantedItem.key){
                        if(simulateItem && simulateItem.key)
                         if(bKeys[simulateItem.key] !== k + 1){
                          removes.push
                           (remove(simulate, simulateIndex, simulateItem.key));
                          simulateItem = simulate[simulateIndex];
                          if(! simulateItem || simulateItem.key !== wantedItem.key)
                           inserts.push({key: wantedItem.key, to: k});
                          else
                           simulateIndex++;
                         }
                         else
                          inserts.push({key: wantedItem.key, to: k});
                        else
                         inserts.push({key: wantedItem.key, to: k});
                        k++;
                       }
                       else if(simulateItem && simulateItem.key)
                        removes.push
                         (remove(simulate, simulateIndex, simulateItem.key));
                      }
                      else{simulateIndex++; k++;}
                     }
                     while(simulateIndex < simulate.length){
                      simulateItem = simulate[simulateIndex];
                      removes.push
                       (remove
                         (simulate, simulateIndex, simulateItem && simulateItem.key));
                     }
                     if(removes.length === deletedItems && ! inserts.length)
                      return {children: newChildren, moves: null};
                     return {children: newChildren,
                             moves: {removes: removes, inserts: inserts}};
                    }
                    function remove(arr, index, key){
                     arr.splice(index, 1);
                     return {from: index, key: key};
                    }
                    function keyIndex(children){
                     var keys = {}, free = [], length = children.length;
                     for(var i = 0; i < length; i++){
                      var child = children[i];
                      if(child.key) keys[child.key] = i; else free.push(i);
                     }
                     return {keys: keys, free: free};
                    }
                    function appendPatch(apply, patch){
                     if(apply){
                      if(isArray(apply))
                       apply.push(patch);
                      else
                       apply = [apply, patch];
                      return apply;
                     }
                     else
                      return patch;
                    }
                   },
                   {"../vnode/handle-thunk": 25,
                    "../vnode/is-thunk": 26,
                    "../vnode/is-vnode": 28,
                    "../vnode/is-vtext": 29,
                    "../vnode/is-widget": 30,
                    "../vnode/vpatch": 33,
                    "./diff-props": 35,
                    "x-is-array": 8}],
                  37:
                  [function(require, module, exports){
                    (function(global){
                       (function(){
                          var
                           vdom =
                             {VNode: require("./vendor/vnode/vnode.js"),
                              VText: require("./vendor/vnode/vtext.js"),
                              diff: require("./vendor/diff.js"),
                              patch: require("./vendor/patch.js"),
                              createElement: require("./vendor/create-element.js"),
                              svg: require("./vendor/virtual-hyperscript/svg.js")};
                          global.VirtualDom = vdom;
                          module.exports = vdom;
                         }.call
                         (this));
                      }.call
                      (this,
                       typeof global !== "undefined"
                        ? global
                        : typeof
                          self
                          !== "undefined"
                          ? self
                          : typeof window !== "undefined" ? window : {}));
                   },
                   {"./vendor/create-element.js": 9,
                    "./vendor/diff.js": 10,
                    "./vendor/patch.js": 11,
                    "./vendor/virtual-hyperscript/svg.js": 24,
                    "./vendor/vnode/vnode.js": 32,
                    "./vendor/vnode/vtext.js": 34}]},
                 {},
                 [37])
               (37);
      }));
  }
  (globalThis));
(function(globalThis){
   var joo_global_object = globalThis;
   function VdomThunk(fn, args, key){
    if(! (this instanceof VdomThunk)) return new VdomThunk(fn, args, key);
    if(key) this.key = key;
    this.fn = fn;
    this.args = args;
   }
   joo_global_object.VdomThunk = VdomThunk;
   VdomThunk.prototype.type = "Thunk";
   VdomThunk.prototype.render =
    function(prev){
     if(prev && this.args === prev.args && this.fn === prev.fn)
      return prev.vnode;
     return this.fn(this.args);
    };
  }
  (globalThis));
(function(globalThis){
   var joo_global_object = globalThis;
   joo_global_object.SoftSetHook =
    function(value){
     if(! (this instanceof SoftSetHook)) return new SoftSetHook(value);
     this.value = value;
    };
   joo_global_object.SoftSetHook.prototype.hook =
    function(node, propertyName){
     if(node[propertyName] !== this.value) node[propertyName] = this.value;
    };
   function GenericHook(init, update, destroy, id, extra){
    if(! (this instanceof GenericHook))
     return new GenericHook(init, update, destroy, id, extra);
    this.init = init;
    this.update = update;
    this.destroy = destroy;
    this.id = id;
    this.extra = extra;
   }
   var hook_state_key = "vdom_hook_state_key";
   if(this.Symbol) hook_state_key = Symbol(hook_state_key);
   GenericHook.write_state =
    function(node, propName, state){
     if(! node[hook_state_key]) node[hook_state_key] = {};
     node[hook_state_key][propName] = state;
    };
   GenericHook.read_state =
    function(node, propName){return node[hook_state_key][propName];};
   GenericHook.remove_state =
    function(node, propName){delete node[hook_state_key][propName];};
   GenericHook.canTransition =
    function(from, to){
     return from instanceof this && to instanceof this && from.id === to.id
            && to.update;
    };
   GenericHook.prototype.hook =
    function(node, propName, prev){
     if(GenericHook.canTransition(prev, this)){
      var state = GenericHook.read_state(node, propName);
      state = this.update(state, node);
      GenericHook.write_state(node, propName, state);
     }
     else{
      var state = this.init(node);
      GenericHook.write_state(node, propName, state);
     }
    };
   GenericHook.prototype.unhook =
    function(node, propName, next){
     if(GenericHook.canTransition(this, next))
      ;
     else{
      var state = GenericHook.read_state(node, propName);
      this.destroy(state, node);
      GenericHook.remove_state(node, propName);
     }
    };
   joo_global_object.GenericHook = GenericHook;
  }
  (globalThis));
(function(globalThis){
   "use strict";
   var joo_global_object = globalThis;
   function caml_int64_is_zero(x){return + x.isZero();}
   function caml_str_repeat(n, s){
    if(n == 0) return "";
    if(s.repeat) return s.repeat(n);
    var r = "", l = 0;
    for(;;){
     if(n & 1) r += s;
     n >>= 1;
     if(n == 0) return r;
     s += s;
     l++;
     if(l == 9) s.slice(0, 1);
    }
   }
   var caml_int64_offset = Math.pow(2, - 24);
   function caml_raise_constant(tag){throw tag;}
   var caml_global_data = [0];
   function caml_raise_zero_divide(){
    caml_raise_constant(caml_global_data.Division_by_zero);
   }
   function MlInt64(lo, mi, hi){
    this.lo = lo & 0xffffff;
    this.mi = mi & 0xffffff;
    this.hi = hi & 0xffff;
   }
   MlInt64.prototype.caml_custom = "_j";
   MlInt64.prototype.copy =
    function(){return new MlInt64(this.lo, this.mi, this.hi);};
   MlInt64.prototype.ucompare =
    function(x){
     if(this.hi > x.hi) return 1;
     if(this.hi < x.hi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.compare =
    function(x){
     var hi = this.hi << 16, xhi = x.hi << 16;
     if(hi > xhi) return 1;
     if(hi < xhi) return - 1;
     if(this.mi > x.mi) return 1;
     if(this.mi < x.mi) return - 1;
     if(this.lo > x.lo) return 1;
     if(this.lo < x.lo) return - 1;
     return 0;
    };
   MlInt64.prototype.neg =
    function(){
     var
      lo = - this.lo,
      mi = - this.mi + (lo >> 24),
      hi = - this.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.add =
    function(x){
     var
      lo = this.lo + x.lo,
      mi = this.mi + x.mi + (lo >> 24),
      hi = this.hi + x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.sub =
    function(x){
     var
      lo = this.lo - x.lo,
      mi = this.mi - x.mi + (lo >> 24),
      hi = this.hi - x.hi + (mi >> 24);
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.mul =
    function(x){
     var
      lo = this.lo * x.lo,
      mi = (lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
      hi =
        (mi * caml_int64_offset | 0) + this.hi * x.lo + this.mi * x.mi
        + this.lo * x.hi;
     return new MlInt64(lo, mi, hi);
    };
   MlInt64.prototype.isZero =
    function(){return (this.lo | this.mi | this.hi) == 0;};
   MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0;};
   MlInt64.prototype.and =
    function(x){
     return new MlInt64(this.lo & x.lo, this.mi & x.mi, this.hi & x.hi);
    };
   MlInt64.prototype.or =
    function(x){
     return new MlInt64(this.lo | x.lo, this.mi | x.mi, this.hi | x.hi);
    };
   MlInt64.prototype.xor =
    function(x){
     return new MlInt64(this.lo ^ x.lo, this.mi ^ x.mi, this.hi ^ x.hi);
    };
   MlInt64.prototype.shift_left =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo << s,
               this.mi << s | this.lo >> 24 - s,
               this.hi << s | this.mi >> 24 - s);
     if(s < 48)
      return new
              MlInt64
              (0, this.lo << s - 24, this.mi << s - 24 | this.lo >> 48 - s);
     return new MlInt64(0, 0, this.lo << s - 48);
    };
   MlInt64.prototype.shift_right_unsigned =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | this.hi << 24 - s,
               this.hi >> s);
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s, this.hi >> s - 24, 0);
     return new MlInt64(this.hi >> s - 48, 0, 0);
    };
   MlInt64.prototype.shift_right =
    function(s){
     s = s & 63;
     if(s == 0) return this;
     var h = this.hi << 16 >> 16;
     if(s < 24)
      return new
              MlInt64
              (this.lo >> s | this.mi << 24 - s,
               this.mi >> s | h << 24 - s,
               this.hi << 16 >> s >>> 16);
     var sign = this.hi << 16 >> 31;
     if(s < 48)
      return new
              MlInt64
              (this.mi >> s - 24 | this.hi << 48 - s,
               this.hi << 16 >> s - 24 >> 16,
               sign & 0xffff);
     return new MlInt64(this.hi << 16 >> s - 32, sign, sign);
    };
   MlInt64.prototype.lsl1 =
    function(){
     this.hi = this.hi << 1 | this.mi >> 23;
     this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
     this.lo = this.lo << 1 & 0xffffff;
    };
   MlInt64.prototype.lsr1 =
    function(){
     this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
     this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
     this.hi = this.hi >>> 1;
    };
   MlInt64.prototype.udivmod =
    function(x){
     var
      offset = 0,
      modulus = this.copy(),
      divisor = x.copy(),
      quotient = new MlInt64(0, 0, 0);
     while(modulus.ucompare(divisor) > 0){offset++; divisor.lsl1();}
     while(offset >= 0){
      offset--;
      quotient.lsl1();
      if(modulus.ucompare(divisor) >= 0){
       quotient.lo++;
       modulus = modulus.sub(divisor);
      }
      divisor.lsr1();
     }
     return {quotient: quotient, modulus: modulus};
    };
   MlInt64.prototype.div =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi ^ y.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var q = x.udivmod(y).quotient;
     if(sign & 0x8000) q = q.neg();
     return q;
    };
   MlInt64.prototype.mod =
    function(y){
     var x = this;
     if(y.isZero()) caml_raise_zero_divide();
     var sign = x.hi;
     if(x.hi & 0x8000) x = x.neg();
     if(y.hi & 0x8000) y = y.neg();
     var r = x.udivmod(y).modulus;
     if(sign & 0x8000) r = r.neg();
     return r;
    };
   MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24;};
   MlInt64.prototype.toFloat =
    function(){
     return (this.hi << 16) * Math.pow(2, 32) + this.mi * Math.pow(2, 24)
            + this.lo;
    };
   MlInt64.prototype.toArray =
    function(){
     return [this.hi >> 8,
             this.hi & 0xff,
             this.mi >> 16,
             this.mi >> 8 & 0xff,
             this.mi & 0xff,
             this.lo >> 16,
             this.lo >> 8 & 0xff,
             this.lo & 0xff];
    };
   MlInt64.prototype.lo32 =
    function(){return this.lo | (this.mi & 0xff) << 24;};
   MlInt64.prototype.hi32 =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16;};
   function caml_int64_of_int32(x){
    return new MlInt64(x & 0xffffff, x >> 24 & 0xffffff, x >> 31 & 0xffff);
   }
   function caml_int64_to_int32(x){return x.toInt();}
   function caml_int64_is_negative(x){return + x.isNeg();}
   function caml_int64_neg(x){return x.neg();}
   function caml_jsbytes_of_string(x){return x;}
   function jsoo_sys_getenv(n){
    var process = globalThis.process;
    if(process && process.env && process.env[n] != undefined)
     return process.env[n];
    if(globalThis.jsoo_static_env && globalThis.jsoo_static_env[n])
     return globalThis.jsoo_static_env[n];
   }
   var caml_record_backtrace_flag = 0;
   (function(){
      var r = jsoo_sys_getenv("OCAMLRUNPARAM");
      if(r !== undefined){
       var l = r.split(",");
       for(var i = 0; i < l.length; i++)
        if(l[i] == "b"){
         caml_record_backtrace_flag = 1;
         break;
        }
        else if(l[i].startsWith("b="))
         caml_record_backtrace_flag = + l[i].slice(2);
        else
         continue;
      }
     }
     ());
   function caml_exn_with_js_backtrace(exn, force){
    if(! exn.js_error || force || exn[0] == 248)
     exn.js_error = new globalThis.Error("Js exception containing backtrace");
    return exn;
   }
   function caml_maybe_attach_backtrace(exn, force){
    return caml_record_backtrace_flag
            ? caml_exn_with_js_backtrace(exn, force)
            : exn;
   }
   function caml_raise_with_arg(tag, arg){
    throw caml_maybe_attach_backtrace([0, tag, arg]);
   }
   function caml_string_of_jsbytes(x){return x;}
   function caml_raise_with_string(tag, msg){
    caml_raise_with_arg(tag, caml_string_of_jsbytes(msg));
   }
   function caml_invalid_argument(msg){
    caml_raise_with_string(caml_global_data.Invalid_argument, msg);
   }
   function caml_parse_format(fmt){
    fmt = caml_jsbytes_of_string(fmt);
    var len = fmt.length;
    if(len > 31) caml_invalid_argument("format_int: format too long");
    var
     f =
       {justify: "+",
        signstyle: "-",
        filler: " ",
        alternate: false,
        base: 0,
        signedconv: false,
        width: 0,
        uppercase: false,
        sign: 1,
        prec: - 1,
        conv: "f"};
    for(var i = 0; i < len; i++){
     var c = fmt.charAt(i);
     switch(c){
       case "-":
        f.justify = "-"; break;
       case "+":
       case " ":
        f.signstyle = c; break;
       case "0":
        f.filler = "0"; break;
       case "#":
        f.alternate = true; break;
       case "1":
       case "2":
       case "3":
       case "4":
       case "5":
       case "6":
       case "7":
       case "8":
       case "9":
        f.width = 0;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.width = f.width * 10 + c; i++;}
        i--;
        break;
       case ".":
        f.prec = 0;
        i++;
        while(c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9){f.prec = f.prec * 10 + c; i++;}
        i--;
       case "d":
       case "i":
        f.signedconv = true;
       case "u":
        f.base = 10; break;
       case "x":
        f.base = 16; break;
       case "X":
        f.base = 16; f.uppercase = true; break;
       case "o":
        f.base = 8; break;
       case "e":
       case "f":
       case "g":
        f.signedconv = true; f.conv = c; break;
       case "E":
       case "F":
       case "G":
        f.signedconv = true;
        f.uppercase = true;
        f.conv = c.toLowerCase();
        break;
     }
    }
    return f;
   }
   function caml_finish_formatting(f, rawbuffer){
    if(f.uppercase) rawbuffer = rawbuffer.toUpperCase();
    var len = rawbuffer.length;
    if(f.signedconv && (f.sign < 0 || f.signstyle != "-")) len++;
    if(f.alternate){if(f.base == 8) len += 1; if(f.base == 16) len += 2;}
    var buffer = "";
    if(f.justify == "+" && f.filler == " ")
     for(var i = len; i < f.width; i++) buffer += " ";
    if(f.signedconv)
     if(f.sign < 0)
      buffer += "-";
     else if(f.signstyle != "-") buffer += f.signstyle;
    if(f.alternate && f.base == 8) buffer += "0";
    if(f.alternate && f.base == 16) buffer += f.uppercase ? "0X" : "0x";
    if(f.justify == "+" && f.filler == "0")
     for(var i = len; i < f.width; i++) buffer += "0";
    buffer += rawbuffer;
    if(f.justify == "-") for(var i = len; i < f.width; i++) buffer += " ";
    return caml_string_of_jsbytes(buffer);
   }
   function caml_int64_format(fmt, x){
    var f = caml_parse_format(fmt);
    if(f.signedconv && caml_int64_is_negative(x)){f.sign = - 1; x = caml_int64_neg(x);}
    var
     buffer = "",
     wbase = caml_int64_of_int32(f.base),
     cvtbl = "0123456789abcdef";
    do{
     var p = x.udivmod(wbase);
     x = p.quotient;
     buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer;
    }
    while
     (! caml_int64_is_zero(x));
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - buffer.length;
     if(n > 0) buffer = caml_str_repeat(n, "0") + buffer;
    }
    return caml_finish_formatting(f, buffer);
   }
   function caml_expm1_float(x){return Math.expm1(x);}
   function caml_ml_condition_broadcast(t){return 0;}
   function jsoo_is_ascii(s){
    if(s.length < 24){
     for(var i = 0; i < s.length; i++) if(s.charCodeAt(i) > 127) return false;
     return true;
    }
    else
     return ! /[^\x00-\x7f]/.test(s);
   }
   function caml_utf16_of_utf8(s){
    for(var b = "", t = "", c, c1, c2, v, i = 0, l = s.length; i < l; i++){
     c1 = s.charCodeAt(i);
     if(c1 < 0x80){
      for(var j = i + 1; j < l && (c1 = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.substr(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j == l) break;
      i = j;
     }
     v = 1;
     if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128){
      c = c2 + (c1 << 6);
      if(c1 < 0xe0){
       v = c - 0x3080;
       if(v < 0x80) v = 1;
      }
      else{
       v = 2;
       if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128){
        c = c2 + (c << 6);
        if(c1 < 0xf0){
         v = c - 0xe2080;
         if(v < 0x800 || v >= 0xd7ff && v < 0xe000) v = 2;
        }
        else{
         v = 3;
         if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128 && c1 < 0xf5){
          v = c2 - 0x3c82080 + (c << 6);
          if(v < 0x10000 || v > 0x10ffff) v = 3;
         }
        }
       }
      }
     }
     if(v < 4){
      i -= v;
      t += "\ufffd";
     }
     else if(v > 0xffff)
      t += String.fromCharCode(0xd7c0 + (v >> 10), 0xdc00 + (v & 0x3FF));
     else
      t += String.fromCharCode(v);
     if(t.length > 1024){t.substr(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function caml_jsstring_of_string(s){
    if(jsoo_is_ascii(s)) return s;
    return caml_utf16_of_utf8(s);
   }
   function fs_node_supported(){
    return typeof globalThis.process !== "undefined"
           && typeof globalThis.process.versions !== "undefined"
           && typeof globalThis.process.versions.node !== "undefined";
   }
   function make_path_is_absolute(){
    function posix(path){
     if(path.charAt(0) === "/") return ["", path.substring(1)];
     return;
    }
    function win32(path){
     var
      splitDeviceRe =
        /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
      result = splitDeviceRe.exec(path),
      device = result[1] || "",
      isUnc = Boolean(device && device.charAt(1) !== ":");
     if(Boolean(result[2] || isUnc)){
      var root = result[1] || "", sep = result[2] || "";
      return [root, path.substring(root.length + sep.length)];
     }
     return;
    }
    return fs_node_supported() && globalThis.process
            && globalThis.process.platform
            ? globalThis.process.platform === "win32" ? win32 : posix
            : posix;
   }
   var path_is_absolute = make_path_is_absolute();
   function caml_trailing_slash(name){
    return name.slice(- 1) !== "/" ? name + "/" : name;
   }
   if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
    var caml_current_dir = globalThis.process.cwd().replace(/\\/g, "/");
   else
    var caml_current_dir = "/static";
   caml_current_dir = caml_trailing_slash(caml_current_dir);
   function caml_make_path(name){
    name = caml_jsstring_of_string(name);
    if(! path_is_absolute(name)) name = caml_current_dir + name;
    var
     comp0 = path_is_absolute(name),
     comp = comp0[1].split("/"),
     ncomp = [];
    for(var i = 0; i < comp.length; i++)
     switch(comp[i]){
       case "..":
        if(ncomp.length > 1) ncomp.pop(); break;
       case ".": break;
       case "": break;
       default: ncomp.push(comp[i]); break;
     }
    ncomp.unshift(comp0[0]);
    ncomp.orig = name;
    return ncomp;
   }
   function caml_utf8_of_utf16(s){
    for(var b = "", t = b, c, d, i = 0, l = s.length; i < l; i++){
     c = s.charCodeAt(i);
     if(c < 0x80){
      for(var j = i + 1; j < l && (c = s.charCodeAt(j)) < 0x80; j++) ;
      if(j - i > 512){
       t.substr(0, 1);
       b += t;
       t = "";
       b += s.slice(i, j);
      }
      else
       t += s.slice(i, j);
      if(j == l) break;
      i = j;
     }
     if(c < 0x800){
      t += String.fromCharCode(0xc0 | c >> 6);
      t += String.fromCharCode(0x80 | c & 0x3f);
     }
     else if(c < 0xd800 || c >= 0xdfff)
      t +=
       String.fromCharCode
        (0xe0 | c >> 12, 0x80 | c >> 6 & 0x3f, 0x80 | c & 0x3f);
     else if
      (c >= 0xdbff || i + 1 == l || (d = s.charCodeAt(i + 1)) < 0xdc00
       || d > 0xdfff)
      t += "\xef\xbf\xbd";
     else{
      i++;
      c = (c << 10) + d - 0x35fdc00;
      t +=
       String.fromCharCode
        (0xf0 | c >> 18,
         0x80 | c >> 12 & 0x3f,
         0x80 | c >> 6 & 0x3f,
         0x80 | c & 0x3f);
     }
     if(t.length > 1024){t.substr(0, 1); b += t; t = "";}
    }
    return b + t;
   }
   function caml_string_of_jsstring(s){
    return jsoo_is_ascii(s)
            ? caml_string_of_jsbytes(s)
            : caml_string_of_jsbytes(caml_utf8_of_utf16(s));
   }
   var
    unix_error =
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
   function make_unix_err_args(code, syscall, path, errno){
    var variant = unix_error.indexOf(code);
    if(variant < 0){if(errno == null) errno = - 9999; variant = [0, errno];}
    var
     args =
       [variant,
        caml_string_of_jsstring(syscall || ""),
        caml_string_of_jsstring(path || "")];
    return args;
   }
   var caml_named_values = {};
   function caml_named_value(nm){return caml_named_values[nm];}
   function caml_raise_with_args(tag, args){
    throw caml_maybe_attach_backtrace([0, tag].concat(args));
   }
   function caml_subarray_to_jsbytes(a, i, len){
    var f = String.fromCharCode;
    if(i == 0 && len <= 4096 && len == a.length) return f.apply(null, a);
    var s = "";
    for(; 0 < len; i += 1024, len -= 1024)
     s += f.apply(null, a.slice(i, i + Math.min(len, 1024)));
    return s;
   }
   function caml_convert_string_to_bytes(s){
    if(s.t == 2)
     s.c += caml_str_repeat(s.l - s.c.length, "\0");
    else
     s.c = caml_subarray_to_jsbytes(s.c, 0, s.c.length);
    s.t = 0;
   }
   function MlBytes(tag, contents, length){
    this.t = tag;
    this.c = contents;
    this.l = length;
   }
   MlBytes.prototype.toString =
    function(){
     switch(this.t){
       case 9:
        return this.c;
       default: caml_convert_string_to_bytes(this);
       case 0:
        if(jsoo_is_ascii(this.c)){this.t = 9; return this.c;} this.t = 8;
       case 8:
        return this.c;
     }
    };
   MlBytes.prototype.toUtf16 =
    function(){
     var r = this.toString();
     if(this.t == 9) return r;
     return caml_utf16_of_utf8(r);
    };
   MlBytes.prototype.slice =
    function(){
     var content = this.t == 4 ? this.c.slice() : this.c;
     return new MlBytes(this.t, content, this.l);
    };
   function caml_is_ml_bytes(s){return s instanceof MlBytes;}
   function caml_is_ml_string(s){
    return typeof s === "string" && ! /[^\x00-\xff]/.test(s);
   }
   function caml_bytes_of_array(a){
    if(! (a instanceof Uint8Array)) a = new Uint8Array(a);
    return new MlBytes(4, a, a.length);
   }
   function caml_bytes_of_jsbytes(s){return new MlBytes(0, s, s.length);}
   function caml_bytes_of_string(s){
    return caml_bytes_of_jsbytes(caml_jsbytes_of_string(s));
   }
   function caml_raise_sys_error(msg){
    caml_raise_with_string(caml_global_data.Sys_error, msg);
   }
   function caml_raise_no_such_file(name){
    caml_raise_sys_error(name + ": No such file or directory");
   }
   function caml_convert_bytes_to_array(s){
    var a = new Uint8Array(s.l), b = s.c, l = b.length, i = 0;
    for(; i < l; i++) a[i] = b.charCodeAt(i);
    for(l = s.l; i < l; i++) a[i] = 0;
    s.c = a;
    s.t = 4;
    return a;
   }
   function caml_uint8_array_of_bytes(s){
    if(s.t != 4) caml_convert_bytes_to_array(s);
    return s.c;
   }
   function caml_create_bytes(len){
    if(len < 0) caml_invalid_argument("Bytes.create");
    return new MlBytes(len ? 2 : 9, "", len);
   }
   function caml_ml_bytes_length(s){return s.l;}
   function caml_blit_bytes(s1, i1, s2, i2, len){
    if(len == 0) return 0;
    if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length)){
     s2.c =
      s1.t == 4
       ? caml_subarray_to_jsbytes(s1.c, i1, len)
       : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
     s2.t = s2.c.length == s2.l ? 0 : 2;
    }
    else if(s2.t == 2 && i2 == s2.c.length){
     s2.c +=
      s1.t == 4
       ? caml_subarray_to_jsbytes(s1.c, i1, len)
       : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
     s2.t = s2.c.length == s2.l ? 0 : 2;
    }
    else{
     if(s2.t != 4) caml_convert_bytes_to_array(s2);
     var c1 = s1.c, c2 = s2.c;
     if(s1.t == 4)
      if(i2 <= i1)
       for(var i = 0; i < len; i++) c2[i2 + i] = c1[i1 + i];
      else
       for(var i = len - 1; i >= 0; i--) c2[i2 + i] = c1[i1 + i];
     else{
      var l = Math.min(len, c1.length - i1);
      for(var i = 0; i < l; i++) c2[i2 + i] = c1.charCodeAt(i1 + i);
      for(; i < len; i++) c2[i2 + i] = 0;
     }
    }
    return 0;
   }
   function MlFile(){}
   function MlFakeFile(content){this.data = content;}
   MlFakeFile.prototype = new MlFile();
   MlFakeFile.prototype.constructor = MlFakeFile;
   MlFakeFile.prototype.truncate =
    function(len){
     var old = this.data;
     this.data = caml_create_bytes(len | 0);
     caml_blit_bytes(old, 0, this.data, 0, len);
    };
   MlFakeFile.prototype.length =
    function(){return caml_ml_bytes_length(this.data);};
   MlFakeFile.prototype.write =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen){
      var new_str = caml_create_bytes(offset + len), old_data = this.data;
      this.data = new_str;
      caml_blit_bytes(old_data, 0, this.data, 0, clen);
     }
     caml_blit_bytes(caml_bytes_of_array(buf), pos, this.data, offset, len);
     return 0;
    };
   MlFakeFile.prototype.read =
    function(offset, buf, pos, len){
     var clen = this.length();
     if(offset + len >= clen) len = clen - offset;
     if(len){
      var data = caml_create_bytes(len | 0);
      caml_blit_bytes(this.data, offset, data, 0, len);
      buf.set(caml_uint8_array_of_bytes(data), pos);
     }
     return len;
    };
   function MlFakeFd(name, file, flags){
    this.file = file;
    this.name = name;
    this.flags = flags;
   }
   MlFakeFd.prototype.err_closed =
    function(){
     caml_raise_sys_error(this.name + ": file descriptor already closed");
    };
   MlFakeFd.prototype.length =
    function(){if(this.file) return this.file.length(); this.err_closed();};
   MlFakeFd.prototype.write =
    function(offset, buf, pos, len){
     if(this.file) return this.file.write(offset, buf, pos, len);
     this.err_closed();
    };
   MlFakeFd.prototype.read =
    function(offset, buf, pos, len){
     if(this.file) return this.file.read(offset, buf, pos, len);
     this.err_closed();
    };
   MlFakeFd.prototype.close = function(){this.file = undefined;};
   function MlFakeDevice(root, f){
    this.content = {};
    this.root = root;
    this.lookupFun = f;
   }
   MlFakeDevice.prototype.nm = function(name){return this.root + name;};
   MlFakeDevice.prototype.create_dir_if_needed =
    function(name){
     var comp = name.split("/"), res = "";
     for(var i = 0; i < comp.length - 1; i++){
      res += comp[i] + "/";
      if(this.content[res]) continue;
      this.content[res] = Symbol("directory");
     }
    };
   MlFakeDevice.prototype.slash =
    function(name){return /\/$/.test(name) ? name : name + "/";};
   MlFakeDevice.prototype.lookup =
    function(name){
     if(! this.content[name] && this.lookupFun){
      var
       res =
         this.lookupFun
          (caml_string_of_jsbytes(this.root), caml_string_of_jsbytes(name));
      if(res !== 0){
       this.create_dir_if_needed(name);
       this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]));
      }
     }
    };
   MlFakeDevice.prototype.exists =
    function(name){
     if(name == "") return 1;
     var name_slash = this.slash(name);
     if(this.content[name_slash]) return 1;
     this.lookup(name);
     return this.content[name] ? 1 : 0;
    };
   MlFakeDevice.prototype.isFile =
    function(name){return this.exists(name) && ! this.is_dir(name) ? 1 : 0;};
   MlFakeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     var unix_error = raise_unix && caml_named_value("Unix.Unix_error");
     if(this.exists(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("EEXIST", "mkdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": File exists");
     var parent = /^(.*)\/[^/]+/.exec(name);
     parent = parent && parent[1] || "";
     if(! this.exists(parent))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOENT", "mkdir", this.nm(parent)));
      else
       caml_raise_sys_error(parent + ": No such file or directory");
     if(! this.is_dir(parent))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOTDIR", "mkdir", this.nm(parent)));
      else
       caml_raise_sys_error(parent + ": Not a directory");
     this.create_dir_if_needed(this.slash(name));
    };
   MlFakeDevice.prototype.rmdir =
    function(name, raise_unix){
     var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      name_slash = name == "" ? "" : this.slash(name),
      r = new RegExp("^" + name_slash + "([^/]+)");
     if(! this.exists(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOENT", "rmdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": No such file or directory");
     if(! this.is_dir(name))
      if(unix_error)
       caml_raise_with_args
        (unix_error, make_unix_err_args("ENOTDIR", "rmdir", this.nm(name)));
      else
       caml_raise_sys_error(name + ": Not a directory");
     for(var n in this.content)
      if(n.match(r))
       if(unix_error)
        caml_raise_with_args
         (unix_error, make_unix_err_args("ENOTEMPTY", "rmdir", this.nm(name)));
       else
        caml_raise_sys_error(this.nm(name) + ": Directory not empty");
     delete this.content[name_slash];
    };
   MlFakeDevice.prototype.readdir =
    function(name){
     var name_slash = name == "" ? "" : this.slash(name);
     if(! this.exists(name))
      caml_raise_sys_error(name + ": No such file or directory");
     if(! this.is_dir(name)) caml_raise_sys_error(name + ": Not a directory");
     var r = new RegExp("^" + name_slash + "([^/]+)"), seen = {}, a = [];
     for(var n in this.content){
      var m = n.match(r);
      if(m && ! seen[m[1]]){seen[m[1]] = true; a.push(m[1]);}
     }
     return a;
    };
   MlFakeDevice.prototype.opendir =
    function(name, raise_unix){
     var
      unix_error = raise_unix && caml_named_value("Unix.Unix_error"),
      a = this.readdir(name),
      c = false,
      i = 0;
     return {readSync:
             function(){
              if(c)
               if(unix_error)
                caml_raise_with_args
                 (unix_error,
                  make_unix_err_args("EBADF", "closedir", this.nm(name)));
               else
                caml_raise_sys_error(name + ": closedir failed");
              if(i == a.length) return null;
              var entry = a[i];
              i++;
              return {name: entry};
             },
             closeSync:
             function(){
              if(c)
               if(unix_error)
                caml_raise_with_args
                 (unix_error,
                  make_unix_err_args("EBADF", "closedir", this.nm(name)));
               else
                caml_raise_sys_error(name + ": closedir failed");
              c = true;
              a = [];
             }};
    };
   MlFakeDevice.prototype.is_dir =
    function(name){
     if(name == "") return true;
     var name_slash = this.slash(name);
     return this.content[name_slash] ? 1 : 0;
    };
   MlFakeDevice.prototype.unlink =
    function(name){
     var ok = this.content[name] ? true : false;
     delete this.content[name];
     return ok;
    };
   MlFakeDevice.prototype.open =
    function(name, f){
     var file;
     if(f.rdonly && f.wronly)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_rdonly and Open_wronly are not compatible");
     if(f.text && f.binary)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_text and Open_binary are not compatible");
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_sys_error(this.nm(name) + " : is a directory");
      if(f.create && f.excl)
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      file = this.content[name];
      if(f.truncate) file.truncate();
     }
     else if(f.create){
      this.create_dir_if_needed(name);
      this.content[name] = new MlFakeFile(caml_create_bytes(0));
      file = this.content[name];
     }
     else
      caml_raise_no_such_file(this.nm(name));
     return new MlFakeFd(this.nm(name), file, f);
    };
   MlFakeDevice.prototype.open =
    function(name, f){
     var file;
     if(f.rdonly && f.wronly)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_rdonly and Open_wronly are not compatible");
     if(f.text && f.binary)
      caml_raise_sys_error
       (this.nm(name)
        + " : flags Open_text and Open_binary are not compatible");
     this.lookup(name);
     if(this.content[name]){
      if(this.is_dir(name))
       caml_raise_sys_error(this.nm(name) + " : is a directory");
      if(f.create && f.excl)
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      file = this.content[name];
      if(f.truncate) file.truncate();
     }
     else if(f.create){
      this.create_dir_if_needed(name);
      this.content[name] = new MlFakeFile(caml_create_bytes(0));
      file = this.content[name];
     }
     else
      caml_raise_no_such_file(this.nm(name));
     return new MlFakeFd(this.nm(name), file, f);
    };
   MlFakeDevice.prototype.register =
    function(name, content){
     var file;
     if(this.content[name])
      caml_raise_sys_error(this.nm(name) + " : file already exists");
     if(caml_is_ml_bytes(content)) file = new MlFakeFile(content);
     if(caml_is_ml_string(content))
      file = new MlFakeFile(caml_bytes_of_string(content));
     else if(content instanceof Array)
      file = new MlFakeFile(caml_bytes_of_array(content));
     else if(typeof content === "string")
      file = new MlFakeFile(caml_bytes_of_jsbytes(content));
     else if(content.toString){
      var
       bytes =
         caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
      file = new MlFakeFile(bytes);
     }
     if(file){
      this.create_dir_if_needed(name);
      this.content[name] = file;
     }
     else
      caml_raise_sys_error
       (this.nm(name) + " : registering file with invalid content type");
    };
   MlFakeDevice.prototype.constructor = MlFakeDevice;
   function caml_ml_string_length(s){return s.length;}
   function caml_string_unsafe_get(s, i){return s.charCodeAt(i);}
   function caml_uint8_array_of_string(s){
    var l = caml_ml_string_length(s), a = new Array(l), i = 0;
    for(; i < l; i++) a[i] = caml_string_unsafe_get(s, i);
    return a;
   }
   function caml_bytes_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_bytes_unsafe_set(s, i, c){
    c &= 0xff;
    if(s.t != 4){
     if(i == s.c.length){
      s.c += String.fromCharCode(c);
      if(i + 1 == s.l) s.t = 0;
      return 0;
     }
     caml_convert_bytes_to_array(s);
    }
    s.c[i] = c;
    return 0;
   }
   function caml_bytes_set(s, i, c){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_set(s, i, c);
   }
   function MlNodeFd(fd, flags){
    this.fs = require("fs");
    this.fd = fd;
    this.flags = flags;
   }
   MlNodeFd.prototype = new MlFile();
   MlNodeFd.prototype.constructor = MlNodeFd;
   MlNodeFd.prototype.truncate =
    function(len){
     try{this.fs.ftruncateSync(this.fd, len | 0);}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.length =
    function(){
     try{return this.fs.fstatSync(this.fd).size;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.write =
    function(offset, buf, buf_offset, len){
     try{
      if(this.flags.isCharacterDevice)
       this.fs.writeSync(this.fd, buf, buf_offset, len);
      else
       this.fs.writeSync(this.fd, buf, buf_offset, len, offset);
     }
     catch(err){caml_raise_sys_error(err.toString());}
     return 0;
    };
   MlNodeFd.prototype.read =
    function(offset, a, buf_offset, len){
     try{
      if(this.flags.isCharacterDevice)
       var read = this.fs.readSync(this.fd, a, buf_offset, len);
      else
       var read = this.fs.readSync(this.fd, a, buf_offset, len, offset);
      return read;
     }
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeFd.prototype.close =
    function(){
     try{this.fs.closeSync(this.fd); return 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   function MlNodeDevice(root){this.fs = require("fs"); this.root = root;}
   MlNodeDevice.prototype.nm = function(name){return this.root + name;};
   MlNodeDevice.prototype.exists =
    function(name){
     try{return this.fs.existsSync(this.nm(name)) ? 1 : 0;}
     catch(err){return 0;}
    };
   MlNodeDevice.prototype.isFile =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isFile() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.mkdir =
    function(name, mode, raise_unix){
     try{this.fs.mkdirSync(this.nm(name), {mode: mode}); return 0;}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.rmdir =
    function(name, raise_unix){
     try{this.fs.rmdirSync(this.nm(name)); return 0;}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readdir =
    function(name, raise_unix){
     try{return this.fs.readdirSync(this.nm(name));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.is_dir =
    function(name){
     try{return this.fs.statSync(this.nm(name)).isDirectory() ? 1 : 0;}
     catch(err){caml_raise_sys_error(err.toString());}
    };
   MlNodeDevice.prototype.unlink =
    function(name, raise_unix){
     try{
      var b = this.fs.existsSync(this.nm(name)) ? 1 : 0;
      this.fs.unlinkSync(this.nm(name));
      return b;
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.open =
    function(name, f, raise_unix){
     var consts = require("constants"), res = 0;
     for(var key in f)
      switch(key){
        case "rdonly":
         res |= consts.O_RDONLY; break;
        case "wronly":
         res |= consts.O_WRONLY; break;
        case "append":
         res |= consts.O_WRONLY | consts.O_APPEND; break;
        case "create":
         res |= consts.O_CREAT; break;
        case "truncate":
         res |= consts.O_TRUNC; break;
        case "excl":
         res |= consts.O_EXCL; break;
        case "binary":
         res |= consts.O_BINARY; break;
        case "text":
         res |= consts.O_TEXT; break;
        case "nonblock":
         res |= consts.O_NONBLOCK; break;
      }
     try{
      var
       fd = this.fs.openSync(this.nm(name), res),
       isCharacterDevice =
         this.fs.lstatSync(this.nm(name)).isCharacterDevice();
      f.isCharacterDevice = isCharacterDevice;
      return new MlNodeFd(fd, f);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.rename =
    function(o, n, raise_unix){
     try{this.fs.renameSync(this.nm(o), this.nm(n));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.stat =
    function(name, raise_unix){
     try{
      var js_stats = this.fs.statSync(this.nm(name));
      return this.stats_from_js(js_stats);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.lstat =
    function(name, raise_unix){
     try{
      var js_stats = this.fs.lstatSync(this.nm(name));
      return this.stats_from_js(js_stats);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.symlink =
    function(to_dir, target, path, raise_unix){
     try{
      this.fs.symlinkSync
       (this.nm(target), this.nm(path), to_dir ? "dir" : "file");
      return 0;
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.readlink =
    function(name, raise_unix){
     try{
      var link = this.fs.readlinkSync(this.nm(name), "utf8");
      return caml_string_of_jsstring(link);
     }
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.opendir =
    function(name, raise_unix){
     try{return this.fs.opendirSync(this.nm(name));}
     catch(err){this.raise_nodejs_error(err, raise_unix);}
    };
   MlNodeDevice.prototype.raise_nodejs_error =
    function(err, raise_unix){
     var unix_error = caml_named_value("Unix.Unix_error");
     if(raise_unix && unix_error){
      var
       args = make_unix_err_args(err.code, err.syscall, err.path, err.errno);
      caml_raise_with_args(unix_error, args);
     }
     else
      caml_raise_sys_error(err.toString());
    };
   MlNodeDevice.prototype.stats_from_js =
    function(js_stats){
     var file_kind;
     if(js_stats.isFile())
      file_kind = 0;
     else if(js_stats.isDirectory())
      file_kind = 1;
     else if(js_stats.isCharacterDevice())
      file_kind = 2;
     else if(js_stats.isBlockDevice())
      file_kind = 3;
     else if(js_stats.isSymbolicLink())
      file_kind = 4;
     else if(js_stats.isFIFO())
      file_kind = 5;
     else if(js_stats.isSocket()) file_kind = 6;
     return [0,
             js_stats.dev,
             js_stats.ino,
             file_kind,
             js_stats.mode,
             js_stats.nlink,
             js_stats.uid,
             js_stats.gid,
             js_stats.rdev,
             js_stats.size,
             js_stats.atimeMs,
             js_stats.mtimeMs,
             js_stats.ctimeMs];
    };
   MlNodeDevice.prototype.constructor = MlNodeDevice;
   function caml_get_root(path){
    var x = path_is_absolute(path);
    if(! x) return;
    return x[0] + "/";
   }
   function caml_failwith(msg){
    if(! caml_global_data.Failure)
     caml_global_data.Failure = [248, caml_string_of_jsbytes("Failure"), - 3];
    caml_raise_with_string(caml_global_data.Failure, msg);
   }
   var
    caml_root =
      caml_get_root(caml_current_dir)
      || caml_failwith("unable to compute caml_root"),
    jsoo_mount_point = [];
   if(fs_node_supported())
    jsoo_mount_point.push
     ({path: caml_root, device: new MlNodeDevice(caml_root)});
   else
    jsoo_mount_point.push
     ({path: caml_root, device: new MlFakeDevice(caml_root)});
   jsoo_mount_point.push
    ({path: "/static/", device: new MlFakeDevice("/static/")});
   function resolve_fs_device(name){
    var
     path = caml_make_path(name),
     name = path.join("/"),
     name_slash = caml_trailing_slash(name),
     res;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var m = jsoo_mount_point[i];
     if
      (name_slash.search(m.path) == 0
       && (! res || res.path.length < m.path.length))
      res =
       {path: m.path,
        device: m.device,
        rest: name.substring(m.path.length, name.length)};
    }
    if(! res && fs_node_supported()){
     var root = caml_get_root(name);
     if(root && root.match(/^[a-zA-Z]:\/$/)){
      var m = {path: root, device: new MlNodeDevice(root)};
      jsoo_mount_point.push(m);
      res =
       {path: m.path,
        device: m.device,
        rest: name.substring(m.path.length, name.length)};
     }
    }
    if(res) return res;
    caml_raise_sys_error("no device found for " + name_slash);
   }
   function caml_sys_is_directory(name){
    var root = resolve_fs_device(name), a = root.device.is_dir(root.rest);
    return a ? 1 : 0;
   }
   function caml_raise_not_found(){
    caml_raise_constant(caml_global_data.Not_found);
   }
   function caml_sys_getenv(name){
    var r = jsoo_sys_getenv(caml_jsstring_of_string(name));
    if(r === undefined) caml_raise_not_found();
    return caml_string_of_jsstring(r);
   }
   function shift_right_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits == 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = len1 - 1; i >= 0; i--){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a >>> nbits | wrap;
     wrap = a << 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   var caml_gr_state;
   function caml_gr_state_get(){
    if(caml_gr_state) return caml_gr_state;
    throw caml_maybe_attach_backtrace
           ([0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]);
   }
   function caml_gr_point_color(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.getImageData(x, s.height - y, 1, 1),
     d = im.data;
    return (d[0] << 16) + (d[1] << 8) + d[2];
   }
   function caml_runtime_events_user_resolve(){return 0;}
   var MlObjectTable;
   if(typeof globalThis.Map === "undefined")
    MlObjectTable =
     function(){
       function NaiveLookup(objs){this.objs = objs;}
       NaiveLookup.prototype.get =
        function(v){
         for(var i = 0; i < this.objs.length; i++)
          if(this.objs[i] === v) return i;
        };
       NaiveLookup.prototype.set = function(){};
       return function(){
        this.objs = [];
        this.lookup = new NaiveLookup(this.objs);};
      }
      ();
   else
    MlObjectTable =
     function(){this.objs = []; this.lookup = new globalThis.Map();};
   MlObjectTable.prototype.store =
    function(v){this.lookup.set(v, this.objs.length); this.objs.push(v);};
   MlObjectTable.prototype.recall =
    function(v){
     var i = this.lookup.get(v);
     return i === undefined ? undefined : this.objs.length - i;
    };
   function caml_sys_rename(o, n){
    var o_root = resolve_fs_device(o), n_root = resolve_fs_device(n);
    if(o_root.device != n_root.device)
     caml_failwith("caml_sys_rename: cannot move file between two filesystem");
    if(! o_root.device.rename)
     caml_failwith("caml_sys_rename: no implemented");
    o_root.device.rename(o_root.rest, n_root.rest);
   }
   function caml_log10_float(x){return Math.log10(x);}
   var caml_runtime_warnings = 0;
   function caml_ml_enable_runtime_warnings(bool){caml_runtime_warnings = bool; return 0;
   }
   function caml_classify_float(x){
    if(isFinite(x)){
     if(Math.abs(x) >= 2.2250738585072014e-308) return 0;
     if(x != 0) return 1;
     return 2;
    }
    return isNaN(x) ? 4 : 3;
   }
   var caml_ml_channels = new Array();
   function caml_refill(chan){
    if(chan.refill != null){
     var str = chan.refill(), str_a = caml_uint8_array_of_string(str);
     if(str_a.length == 0)
      chan.refill = null;
     else{
      if(chan.buffer.length < chan.buffer_max + str_a.length){
       var b = new Uint8Array(chan.buffer_max + str_a.length);
       b.set(chan.buffer);
       chan.buffer = b;
      }
      chan.buffer.set(str_a, chan.buffer_max);
      chan.offset += str_a.length;
      chan.buffer_max += str_a.length;
     }
    }
    else{
     var
      nread =
        chan.file.read
         (chan.offset,
          chan.buffer,
          chan.buffer_max,
          chan.buffer.length - chan.buffer_max);
     chan.offset += nread;
     chan.buffer_max += nread;
    }
   }
   function caml_array_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_ml_input_scan_line(chanid){
    var chan = caml_ml_channels[chanid], p = chan.buffer_curr;
    do
     if(p >= chan.buffer_max){
      if(chan.buffer_curr > 0){
       chan.buffer.set(chan.buffer.subarray(chan.buffer_curr), 0);
       p -= chan.buffer_curr;
       chan.buffer_max -= chan.buffer_curr;
       chan.buffer_curr = 0;
      }
      if(chan.buffer_max >= chan.buffer.length) return - chan.buffer_max | 0;
      var prev_max = chan.buffer_max;
      caml_refill(chan);
      if(prev_max == chan.buffer_max) return - chan.buffer_max | 0;
     }
    while
     (chan.buffer[p++] != 10);
    return p - chan.buffer_curr | 0;
   }
   function caml_gc_minor(unit){
    if(typeof globalThis.gc == "function") globalThis.gc(true);
    return 0;
   }
   function core_gc_heap_chunks(){return 0;}
   function caml_sse2_float64_max_bytecode(x, y){return x > y ? x : y;}
   function caml_ml_condition_new(unit){return {condition: 1};}
   function caml_ba_to_typed_array(ba){return ba.data;}
   function caml_ml_input_block(chanid, ba, i, l){
    var
     chan = caml_ml_channels[chanid],
     n = l,
     avail = chan.buffer_max - chan.buffer_curr;
    if(l <= avail){
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + l), i);
     chan.buffer_curr += l;
    }
    else if(avail > 0){
     ba.set
      (chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + avail), i);
     chan.buffer_curr += avail;
     n = avail;
    }
    else{
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
     var avail = chan.buffer_max - chan.buffer_curr;
     if(n > avail) n = avail;
     ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + n), i);
     chan.buffer_curr += n;
    }
    return n | 0;
   }
   function caml_ml_input_bigarray(chanid, b, i, l){
    var ba = caml_ba_to_typed_array(b);
    return caml_ml_input_block(chanid, ba, i, l);
   }
   function caml_int64_of_bytes(a){
    return new
            MlInt64
            (a[7] << 0 | a[6] << 8 | a[5] << 16,
             a[4] << 0 | a[3] << 8 | a[2] << 16,
             a[1] << 0 | a[0] << 8);
   }
   function caml_ba_uint8_get64(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3),
     b5 = ba.get(ofs + 4),
     b6 = ba.get(ofs + 5),
     b7 = ba.get(ofs + 6),
     b8 = ba.get(ofs + 7);
    return caml_int64_of_bytes([b8, b7, b6, b5, b4, b3, b2, b1]);
   }
   function caml_int64_to_bytes(x){return x.toArray();}
   function caml_int64_marshal(writer, v, sizes){
    var b = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) writer.write(8, b[i]);
    sizes[0] = 8;
    sizes[1] = 8;
   }
   function caml_ba_num_dims(ba){return ba.dims.length;}
   function caml_ba_get_1(ba, i0){return ba.get(ba.offset(i0));}
   function caml_int_compare(a, b){
    if(a < b) return - 1;
    if(a == b) return 0;
    return 1;
   }
   function bigstringaf_memcmp_bigstring(ba1, ba1_off, ba2, ba2_off, len){
    for(var i = 0; i < len; i++){
     var
      c =
        caml_int_compare
         (caml_ba_get_1(ba1, ba1_off + i), caml_ba_get_1(ba2, ba2_off + i));
     if(c != 0) return c;
    }
    return 0;
   }
   function caml_bigstring_blit_ba_to_bytes(ba1, pos1, bytes2, pos2, len){
    if(12 != ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs1 = ba1.offset(pos1);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(pos2 + len > caml_ml_bytes_length(bytes2)) caml_array_bound_error();
    var slice = ba1.data.slice(ofs1, ofs1 + len);
    caml_blit_bytes(caml_bytes_of_array(slice), 0, bytes2, pos2, len);
    return 0;
   }
   function bigstring_blit_bigstring_bytes_stub
   (src, src_pos, dst, dst_pos, len){
    return caml_bigstring_blit_ba_to_bytes(src, src_pos, dst, dst_pos, len);
   }
   function caml_wrap_exception(e){
    {
     if(e instanceof Array) return e;
     var exn;
     if
      (globalThis.RangeError && e instanceof globalThis.RangeError
       && e.message
       && e.message.match(/maximum call stack/i))
      exn = caml_global_data.Stack_overflow;
     else if
      (globalThis.InternalError && e instanceof globalThis.InternalError
       && e.message
       && e.message.match(/too much recursion/i))
      exn = caml_global_data.Stack_overflow;
     else if(e instanceof globalThis.Error && caml_named_value("jsError"))
      exn = [0, caml_named_value("jsError"), e];
     else
      exn = [0, caml_global_data.Failure, caml_string_of_jsstring(String(e))];
     if(e instanceof globalThis.Error) exn.js_error = e;
     return exn;
    }
   }
   function caml_create_file(name, content){
    var root = resolve_fs_device(name);
    if(! root.device.register) caml_failwith("cannot register file");
    root.device.register(root.rest, content);
    return 0;
   }
   function jsoo_create_file(name, content){
    var
     name = caml_string_of_jsbytes(name),
     content = caml_string_of_jsbytes(content);
    return caml_create_file(name, content);
   }
   function caml_fs_init(){
    var tmp = globalThis.caml_fs_tmp;
    if(tmp)
     for(var i = 0; i < tmp.length; i++)
      jsoo_create_file(tmp[i].name, tmp[i].content);
    globalThis.jsoo_create_file = jsoo_create_file;
    globalThis.caml_fs_tmp = [];
    return 0;
   }
   function caml_mul(a, b){return Math.imul(a, b);}
   function caml_hash_mix_int(h, d){
    d = caml_mul(d, 0xcc9e2d51 | 0);
    d = d << 15 | d >>> 32 - 15;
    d = caml_mul(d, 0x1b873593);
    h ^= d;
    h = h << 13 | h >>> 32 - 13;
    return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0;
   }
   function caml_hash_mix_jsbytes(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w =
      s.charCodeAt(i) | s.charCodeAt(i + 1) << 8 | s.charCodeAt(i + 2) << 16
      | s.charCodeAt(i + 3) << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s.charCodeAt(i + 2) << 16;
      case 2:
       w |= s.charCodeAt(i + 1) << 8;
      case 1:
       w |= s.charCodeAt(i); h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_hash_mix_string(h, v){
    return caml_hash_mix_jsbytes(h, caml_jsbytes_of_string(v));
   }
   var Base_internalhash_fold_string = caml_hash_mix_string;
   function caml_get_continuation_callstack(){return [0];}
   var caml_parser_trace = 0;
   function caml_set_parser_trace(bool){
    var oldflag = caml_parser_trace;
    caml_parser_trace = bool;
    return oldflag;
   }
   function caml_list_of_js_array(a){
    var l = 0;
    for(var i = a.length - 1; i >= 0; i--){var e = a[i]; l = [0, e, l];}
    return l;
   }
   function caml_int64_of_float(x){
    if(x < 0) x = Math.ceil(x);
    return new
            MlInt64
            (x & 0xffffff,
             Math.floor(x * caml_int64_offset) & 0xffffff,
             Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff);
   }
   function timezone_js_loader_get_offset_nanos_for(zone, instant){
    return caml_int64_of_float(zone.getOffsetNanosecondsFor(instant));
   }
   function num_digits_nat(nat, ofs, len){
    for(var i = len - 1; i >= 0; i--) if(nat.data[ofs + i] != 0) return i + 1;
    return 1;
   }
   function caml_hash_nat(x){
    var len = num_digits_nat(x, 0, x.data.length), h = 0;
    for(var i = 0; i < len; i++) h = caml_hash_mix_int(h, x.data[i]);
    return h;
   }
   function caml_call_gen(f, args){
    var
     n = f.l >= 0 ? f.l : f.l = f.length,
     argsLen = args.length,
     d = n - argsLen;
    if(d == 0)
     return f.apply(null, args);
    else if(d < 0){
     var g = f.apply(null, args.slice(0, n));
     if(typeof g !== "function") return g;
     return caml_call_gen(g, args.slice(n));
    }
    else{
     switch(d){
       case 1:
        {
         var
          g =
            function(x){
             var nargs = new Array(argsLen + 1);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             return f.apply(null, nargs);
            };
         break;
        }
       case 2:
        {
         var
          g =
            function(x, y){
             var nargs = new Array(argsLen + 2);
             for(var i = 0; i < argsLen; i++) nargs[i] = args[i];
             nargs[argsLen] = x;
             nargs[argsLen + 1] = y;
             return f.apply(null, nargs);
            };
         break;
        }
       default:
        var
         g =
           function(){
            var
             extra_args = arguments.length == 0 ? 1 : arguments.length,
             nargs = new Array(args.length + extra_args);
            for(var i = 0; i < args.length; i++) nargs[i] = args[i];
            for(var i = 0; i < arguments.length; i++)
             nargs[args.length + i] = arguments[i];
            return caml_call_gen(f, nargs);
           };
     }
     g.l = d;
     return g;
    }
   }
   var caml_callback = caml_call_gen;
   function caml_js_wrap_callback_arguments(f){
    return function(){
     var len = arguments.length, args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, [args]);};
   }
   function caml_sys_chdir(dir){
    var root = resolve_fs_device(dir);
    if(root.device.exists(root.rest)){
     if(root.rest)
      caml_current_dir = caml_trailing_slash(root.path + root.rest);
     else
      caml_current_dir = root.path;
     return 0;
    }
    else
     caml_raise_no_such_file(caml_jsbytes_of_string(dir));
   }
   function caml_obj_update_tag(b, o, n){
    if(b[0] == o){b[0] = n; return 1;}
    return 0;
   }
   function caml_lazy_update_to_forcing(o){
    return o instanceof Array && o[0] == o[0] >>> 0
            && caml_obj_update_tag(o, 246, 244)
            ? 0
            : 1;
   }
   function caml_gc_counters(){return [254, 0, 0, 0];}
   function caml_gr_synchronize(){
    caml_failwith("caml_gr_synchronize not Implemented");
   }
   function caml_bigstring_blit_string_to_ba(str1, pos1, ba2, pos2, len){
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_string_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_string(str1).slice(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   function bigstringaf_blit_from_bytes(src, src_off, dst, dst_off, len){
    return caml_bigstring_blit_string_to_ba(src, src_off, dst, dst_off, len);
   }
   function caml_unix_closedir(dir_handle){
    try{dir_handle.pointer.closeSync();}
    catch(e){
     var unix_error = caml_named_value("Unix.Unix_error");
     caml_raise_with_args
      (unix_error, make_unix_err_args("EBADF", "closedir", dir_handle.path));
    }
   }
   function caml_unix_opendir(path){
    var root = resolve_fs_device(path);
    if(! root.device.opendir)
     caml_failwith("caml_unix_opendir: not implemented");
    var dir_handle = root.device.opendir(root.rest, true);
    return {pointer: dir_handle, path: path};
   }
   function caml_unix_rewinddir(dir_handle){
    caml_unix_closedir(dir_handle);
    var new_dir_handle = caml_unix_opendir(dir_handle.path);
    dir_handle.pointer = new_dir_handle.pointer;
    return 0;
   }
   function caml_raise_end_of_file(){
    caml_raise_constant(caml_global_data.End_of_file);
   }
   function caml_unix_readdir(dir_handle){
    var entry;
    try{entry = dir_handle.pointer.readSync();}
    catch(e){
     var unix_error = caml_named_value("Unix.Unix_error");
     caml_raise_with_args
      (unix_error, make_unix_err_args("EBADF", "readdir", dir_handle.path));
    }
    if(entry === null)
     caml_raise_end_of_file();
    else
     return caml_string_of_jsstring(entry.name);
   }
   function caml_unix_findfirst(path){
    var path_js = caml_jsstring_of_string(path);
    path_js = path_js.replace(/(^|[\\\/])\*\.\*$/, "");
    path = caml_string_of_jsstring(path_js);
    var
     dir_handle = caml_unix_opendir(path),
     first_entry = caml_unix_readdir(dir_handle);
    return [0, first_entry, dir_handle];
   }
   function caml_is_continuation_tag(t){return t == 245 ? 1 : 0;}
   var log2_ok = Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
   function jsoo_floor_log2(x){
    if(log2_ok) return Math.floor(Math.log2(x));
    var i = 0;
    if(x == 0) return - Infinity;
    if(x >= 1) while(x >= 2){x /= 2; i++;} else while(x < 1){x *= 2; i--;}
    return i;
   }
   function caml_int32_bits_of_float(x){
    var float32a = new Float32Array(1);
    float32a[0] = x;
    var int32a = new Int32Array(float32a.buffer);
    return int32a[0] | 0;
   }
   function caml_int64_create_lo_mi_hi(lo, mi, hi){return new MlInt64(lo, mi, hi);
   }
   function caml_int64_bits_of_float(x){
    if(! isFinite(x)){
     if(isNaN(x)) return caml_int64_create_lo_mi_hi(1, 0, 0x7ff0);
     return x > 0
             ? caml_int64_create_lo_mi_hi(0, 0, 0x7ff0)
             : caml_int64_create_lo_mi_hi(0, 0, 0xfff0);
    }
    var sign = x == 0 && 1 / x == - Infinity ? 0x8000 : x >= 0 ? 0 : 0x8000;
    if(sign) x = - x;
    var exp = jsoo_floor_log2(x) + 1023;
    if(exp <= 0){
     exp = 0;
     x /= Math.pow(2, - 1026);
    }
    else{
     x /= Math.pow(2, exp - 1027);
     if(x < 16){x *= 2; exp -= 1;}
     if(exp == 0) x /= 2;
    }
    var k = Math.pow(2, 24), r3 = x | 0;
    x = (x - r3) * k;
    var r2 = x | 0;
    x = (x - r2) * k;
    var r1 = x | 0;
    r3 = r3 & 0xf | sign | exp << 4;
    return caml_int64_create_lo_mi_hi(r1, r2, r3);
   }
   function caml_ba_serialize(writer, ba, sz){
    writer.write(32, ba.dims.length);
    writer.write(32, ba.kind | ba.layout << 8);
    if(ba.caml_custom == "_bigarr02")
     for(var i = 0; i < ba.dims.length; i++)
      if(ba.dims[i] < 0xffff)
       writer.write(16, ba.dims[i]);
      else{
       writer.write(16, 0xffff);
       writer.write(32, 0);
       writer.write(32, ba.dims[i]);
      }
    else
     for(var i = 0; i < ba.dims.length; i++) writer.write(32, ba.dims[i]);
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       for(var i = 0; i < ba.data.length; i++) writer.write(8, ba.data[i]);
       break;
      case 4:
      case 5:
       for(var i = 0; i < ba.data.length; i++) writer.write(16, ba.data[i]);
       break;
      case 6:
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 8:
      case 9:
       writer.write(8, 0);
       for(var i = 0; i < ba.data.length; i++) writer.write(32, ba.data[i]);
       break;
      case 7:
       for(var i = 0; i < ba.data.length / 2; i++){
        var b = caml_int64_to_bytes(ba.get(i));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 1:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
      case 0:
       for(var i = 0; i < ba.data.length; i++){
        var b = caml_int32_bits_of_float(ba.get(i));
        writer.write(32, b);
       }
       break;
      case 10:
       for(var i = 0; i < ba.data.length / 2; i++){
        var j = ba.get(i);
        writer.write(32, caml_int32_bits_of_float(j[1]));
        writer.write(32, caml_int32_bits_of_float(j[2]));
       }
       break;
      case 11:
       for(var i = 0; i < ba.data.length / 2; i++){
        var
         complex = ba.get(i),
         b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
        var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
        for(var j = 0; j < 8; j++) writer.write(8, b[j]);
       }
       break;
    }
    sz[0] = (4 + ba.dims.length) * 4;
    sz[1] = (4 + ba.dims.length) * 8;
   }
   function caml_ba_get_size_per_element(kind){
    switch(kind){case 7:case 10:case 11: return 2;default: return 1;
    }
   }
   function caml_ba_create_buffer(kind, size){
    var view;
    switch(kind){
      case 0:
       view = Float32Array; break;
      case 1:
       view = Float64Array; break;
      case 2:
       view = Int8Array; break;
      case 3:
       view = Uint8Array; break;
      case 4:
       view = Int16Array; break;
      case 5:
       view = Uint16Array; break;
      case 6:
       view = Int32Array; break;
      case 7:
       view = Int32Array; break;
      case 8:
       view = Int32Array; break;
      case 9:
       view = Int32Array; break;
      case 10:
       view = Float32Array; break;
      case 11:
       view = Float64Array; break;
      case 12:
       view = Uint8Array; break;
    }
    if(! view) caml_invalid_argument("Bigarray.create: unsupported kind");
    var data = new view(size * caml_ba_get_size_per_element(kind));
    return data;
   }
   function caml_int32_float_of_bits(x){
    var int32a = new Int32Array(1);
    int32a[0] = x;
    var float32a = new Float32Array(int32a.buffer);
    return float32a[0];
   }
   function caml_int64_float_of_bits(x){
    var lo = x.lo, mi = x.mi, hi = x.hi, exp = (hi & 0x7fff) >> 4;
    if(exp == 2047)
     return (lo | mi | hi & 0xf) == 0
             ? hi & 0x8000 ? - Infinity : Infinity
             : NaN;
    var k = Math.pow(2, - 24), res = (lo * k + mi) * k + (hi & 0xf);
    if(exp > 0){
     res += 16;
     res *= Math.pow(2, exp - 1027);
    }
    else
     res *= Math.pow(2, - 1026);
    if(hi & 0x8000) res = - res;
    return res;
   }
   function caml_ba_get_size(dims){
    var n_dims = dims.length, size = 1;
    for(var i = 0; i < n_dims; i++){
     if(dims[i] < 0)
      caml_invalid_argument("Bigarray.create: negative dimension");
     size = size * dims[i];
    }
    return size;
   }
   function caml_int64_create_lo_hi(lo, hi){
    return new
            MlInt64
            (lo & 0xffffff,
             lo >>> 24 & 0xff | (hi & 0xffff) << 8,
             hi >>> 16 & 0xffff);
   }
   function caml_int64_hi32(v){return v.hi32();}
   function caml_int64_lo32(v){return v.lo32();}
   var caml_ba_custom_name = "_bigarr02";
   function Ml_Bigarray(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
   Ml_Bigarray.prototype.offset =
    function(arg){
     var ofs = 0;
     if(typeof arg === "number") arg = [arg];
     if(! (arg instanceof Array))
      caml_invalid_argument("bigarray.js: invalid offset");
     if(this.dims.length != arg.length)
      caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
     if(this.layout == 0)
      for(var i = 0; i < this.dims.length; i++){
       if(arg[i] < 0 || arg[i] >= this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + arg[i];
      }
     else
      for(var i = this.dims.length - 1; i >= 0; i--){
       if(arg[i] < 1 || arg[i] > this.dims[i]) caml_array_bound_error();
       ofs = ofs * this.dims[i] + (arg[i] - 1);
      }
     return ofs;
    };
   Ml_Bigarray.prototype.get =
    function(ofs){
     switch(this.kind){
       case 7:
        var l = this.data[ofs * 2 + 0], h = this.data[ofs * 2 + 1];
        return caml_int64_create_lo_hi(l, h);
       case 10:
       case 11:
        var r = this.data[ofs * 2 + 0], i = this.data[ofs * 2 + 1];
        return [254, r, i];
       default: return this.data[ofs];
     }
    };
   Ml_Bigarray.prototype.set =
    function(ofs, v){
     switch(this.kind){
       case 7:
        this.data[ofs * 2 + 0] = caml_int64_lo32(v);
        this.data[ofs * 2 + 1] = caml_int64_hi32(v);
        break;
       case 10:
       case 11:
        this.data[ofs * 2 + 0] = v[1]; this.data[ofs * 2 + 1] = v[2]; break;
       default: this.data[ofs] = v; break;
     }
     return 0;
    };
   Ml_Bigarray.prototype.fill =
    function(v){
     switch(this.kind){
       case 7:
        var a = caml_int64_lo32(v), b = caml_int64_hi32(v);
        if(a == b)
         this.data.fill(a);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 == 0 ? a : b;
        break;
       case 10:
       case 11:
        var im = v[1], re = v[2];
        if(im == re)
         this.data.fill(im);
        else
         for(var i = 0; i < this.data.length; i++)
          this.data[i] = i % 2 == 0 ? im : re;
        break;
       default: this.data.fill(v); break;
     }
    };
   Ml_Bigarray.prototype.compare =
    function(b, total){
     if(this.layout != b.layout || this.kind != b.kind){
      var k1 = this.kind | this.layout << 8, k2 = b.kind | b.layout << 8;
      return k2 - k1;
     }
     if(this.dims.length != b.dims.length)
      return b.dims.length - this.dims.length;
     for(var i = 0; i < this.dims.length; i++)
      if(this.dims[i] != b.dims[i]) return this.dims[i] < b.dims[i] ? - 1 : 1;
     switch(this.kind){
       case 0:
       case 1:
       case 10:
       case 11:
        var x, y;
        for(var i = 0; i < this.data.length; i++){
         x = this.data[i];
         y = b.data[i];
         if(x < y) return - 1;
         if(x > y) return 1;
         if(x != y){
          if(! total) return NaN;
          if(x == x) return 1;
          if(y == y) return - 1;
         }
        }
        break;
       case 7:
        for(var i = 0; i < this.data.length; i += 2){
         if(this.data[i + 1] < b.data[i + 1]) return - 1;
         if(this.data[i + 1] > b.data[i + 1]) return 1;
         if(this.data[i] >>> 0 < b.data[i] >>> 0) return - 1;
         if(this.data[i] >>> 0 > b.data[i] >>> 0) return 1;
        }
        break;
       case 2:
       case 3:
       case 4:
       case 5:
       case 6:
       case 8:
       case 9:
       case 12:
        for(var i = 0; i < this.data.length; i++){
         if(this.data[i] < b.data[i]) return - 1;
         if(this.data[i] > b.data[i]) return 1;
        }
        break;
     }
     return 0;
    };
   function Ml_Bigarray_c_1_1(kind, layout, dims, buffer){
    this.kind = kind;
    this.layout = layout;
    this.dims = dims;
    this.data = buffer;
   }
   Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
   Ml_Bigarray_c_1_1.prototype.offset =
    function(arg){
     if(typeof arg !== "number")
      if(arg instanceof Array && arg.length == 1)
       arg = arg[0];
      else
       caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
     if(arg < 0 || arg >= this.dims[0]) caml_array_bound_error();
     return arg;
    };
   Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs];};
   Ml_Bigarray_c_1_1.prototype.set =
    function(ofs, v){this.data[ofs] = v; return 0;};
   Ml_Bigarray_c_1_1.prototype.fill =
    function(v){this.data.fill(v); return 0;};
   function caml_ba_create_unsafe(kind, layout, dims, data){
    var size_per_element = caml_ba_get_size_per_element(kind);
    if(caml_ba_get_size(dims) * size_per_element != data.length)
     caml_invalid_argument("length doesn't match dims");
    if(layout == 0 && dims.length == 1 && size_per_element == 1)
     return new Ml_Bigarray_c_1_1(kind, layout, dims, data);
    return new Ml_Bigarray(kind, layout, dims, data);
   }
   function caml_ba_deserialize(reader, sz, name){
    var num_dims = reader.read32s();
    if(num_dims < 0 || num_dims > 16)
     caml_failwith("input_value: wrong number of bigarray dimensions");
    var
     tag = reader.read32s(),
     kind = tag & 0xff,
     layout = tag >> 8 & 1,
     dims = [];
    if(name == "_bigarr02")
     for(var i = 0; i < num_dims; i++){
      var size_dim = reader.read16u();
      if(size_dim == 0xffff){
       var size_dim_hi = reader.read32u(), size_dim_lo = reader.read32u();
       if(size_dim_hi != 0)
        caml_failwith("input_value: bigarray dimension overflow in 32bit");
       size_dim = size_dim_lo;
      }
      dims.push(size_dim);
     }
    else
     for(var i = 0; i < num_dims; i++) dims.push(reader.read32u());
    var
     size = caml_ba_get_size(dims),
     data = caml_ba_create_buffer(kind, size),
     ba = caml_ba_create_unsafe(kind, layout, dims, data);
    switch(kind){
      case 2:
       for(var i = 0; i < size; i++) data[i] = reader.read8s(); break;
      case 3:
      case 12:
       for(var i = 0; i < size; i++) data[i] = reader.read8u(); break;
      case 4:
       for(var i = 0; i < size; i++) data[i] = reader.read16s(); break;
      case 5:
       for(var i = 0; i < size; i++) data[i] = reader.read16u(); break;
      case 6:
       for(var i = 0; i < size; i++) data[i] = reader.read32s(); break;
      case 8:
      case 9:
       var sixty = reader.read8u();
       if(sixty)
        caml_failwith
         ("input_value: cannot read bigarray with 64-bit OCaml ints");
       for(var i = 0; i < size; i++) data[i] = reader.read32s();
       break;
      case 7:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var int64 = caml_int64_of_bytes(t);
        ba.set(i, int64);
       }
       break;
      case 1:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var f = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, f);
       }
       break;
      case 0:
       for(var i = 0; i < size; i++){
        var f = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, f);
       }
       break;
      case 10:
       for(var i = 0; i < size; i++){
        var
         re = caml_int32_float_of_bits(reader.read32s()),
         im = caml_int32_float_of_bits(reader.read32s());
        ba.set(i, [254, re, im]);
       }
       break;
      case 11:
       var t = new Array(8);
       for(var i = 0; i < size; i++){
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var re = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        for(var j = 0; j < 8; j++) t[j] = reader.read8u();
        var im = caml_int64_float_of_bits(caml_int64_of_bytes(t));
        ba.set(i, [254, re, im]);
       }
       break;
    }
    sz[0] = (4 + num_dims) * 4;
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_ba_compare(a, b, total){return a.compare(b, total);}
   function caml_hash_mix_int64(h, v){
    h = caml_hash_mix_int(h, caml_int64_lo32(v));
    h = caml_hash_mix_int(h, caml_int64_hi32(v));
    return h;
   }
   function caml_hash_mix_float(h, v0){
    return caml_hash_mix_int64(h, caml_int64_bits_of_float(v0));
   }
   function caml_ba_hash(ba){
    var num_elts = caml_ba_get_size(ba.dims), h = 0;
    switch(ba.kind){
      case 2:
      case 3:
      case 12:
       if(num_elts > 256) num_elts = 256;
       var w = 0, i = 0;
       for(i = 0; i + 4 <= ba.data.length; i += 4){
        w =
         ba.data[i + 0] | ba.data[i + 1] << 8 | ba.data[i + 2] << 16
         | ba.data[i + 3] << 24;
        h = caml_hash_mix_int(h, w);
       }
       w = 0;
       switch(num_elts & 3){
         case 3:
          w = ba.data[i + 2] << 16;
         case 2:
          w |= ba.data[i + 1] << 8;
         case 1:
          w |= ba.data[i + 0]; h = caml_hash_mix_int(h, w);
       }
       break;
      case 4:
      case 5:
       if(num_elts > 128) num_elts = 128;
       var w = 0, i = 0;
       for(i = 0; i + 2 <= ba.data.length; i += 2){
        w = ba.data[i + 0] | ba.data[i + 1] << 16;
        h = caml_hash_mix_int(h, w);
       }
       if((num_elts & 1) != 0) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 6:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 8:
      case 9:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 7:
       if(num_elts > 32) num_elts = 32;
       num_elts *= 2;
       for(var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);
       break;
      case 10:
       num_elts *= 2;
      case 0:
       if(num_elts > 64) num_elts = 64;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
      case 11:
       num_elts *= 2;
      case 1:
       if(num_elts > 32) num_elts = 32;
       for(var i = 0; i < num_elts; i++)
        h = caml_hash_mix_float(h, ba.data[i]);
       break;
    }
    return h;
   }
   function caml_int32_unmarshal(reader, size){size[0] = 4; return reader.read32s();
   }
   function caml_nativeint_unmarshal(reader, size){
    switch(reader.read8u()){
      case 1:
       size[0] = 4; return reader.read32s();
      case 2:
       caml_failwith("input_value: native integer value too large");
      default: caml_failwith("input_value: ill-formed native integer");
    }
   }
   function caml_int64_unmarshal(reader, size){
    var t = new Array(8);
    for(var j = 0; j < 8; j++) t[j] = reader.read8u();
    size[0] = 8;
    return caml_int64_of_bytes(t);
   }
   function caml_int64_compare(x, y, total){return x.compare(y);}
   function caml_int64_hash(v){return v.lo32() ^ v.hi32();}
   var
    caml_custom_ops =
      {"_j":
       {deserialize: caml_int64_unmarshal,
        serialize: caml_int64_marshal,
        fixed_length: 8,
        compare: caml_int64_compare,
        hash: caml_int64_hash},
       "_i": {deserialize: caml_int32_unmarshal, fixed_length: 4},
       "_n": {deserialize: caml_nativeint_unmarshal, fixed_length: 4},
       "_bigarray":
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarray");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader, sz){
         return caml_ba_deserialize(reader, sz, "_bigarr02");
        },
        serialize: caml_ba_serialize,
        compare: caml_ba_compare,
        hash: caml_ba_hash}};
   function caml_compare_val_get_custom(a){
    return caml_custom_ops[a.caml_custom]
           && caml_custom_ops[a.caml_custom].compare;
   }
   function caml_compare_val_number_custom(num, custom, swap, total){
    var comp = caml_compare_val_get_custom(custom);
    if(comp){
     var x = swap > 0 ? comp(custom, num, total) : comp(num, custom, total);
     if(total && x != x) return swap;
     if(+ x != + x) return + x;
     if((x | 0) != 0) return x | 0;
    }
    return swap;
   }
   function caml_compare_val_tag(a){
    if(typeof a === "number")
     return 1000;
    else if(caml_is_ml_bytes(a))
     return 252;
    else if(caml_is_ml_string(a))
     return 1252;
    else if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255){var tag = a[0] | 0; return tag == 254 ? 0 : tag;}
    else if(a instanceof String)
     return 12520;
    else if(typeof a == "string")
     return 12520;
    else if(a instanceof Number)
     return 1000;
    else if(a && a.caml_custom)
     return 1255;
    else if(a && a.compare)
     return 1256;
    else if(typeof a == "function")
     return 1247;
    else if(typeof a == "symbol") return 1251;
    return 1001;
   }
   function caml_string_compare(s1, s2){
    return s1 < s2 ? - 1 : s1 > s2 ? 1 : 0;
   }
   function caml_bytes_compare(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? - 1 : s1.c > s2.c ? 1 : 0;
   }
   function caml_compare_val(a, b, total){
    var stack = [];
    for(;;){
     if(! (total && a === b)){
      var tag_a = caml_compare_val_tag(a);
      if(tag_a == 250){a = a[1]; continue;}
      var tag_b = caml_compare_val_tag(b);
      if(tag_b == 250){b = b[1]; continue;}
      if(tag_a !== tag_b){
       if(tag_a == 1000){
        if(tag_b == 1255)
         return caml_compare_val_number_custom(a, b, - 1, total);
        return - 1;
       }
       if(tag_b == 1000){
        if(tag_a == 1255)
         return caml_compare_val_number_custom(b, a, 1, total);
        return 1;
       }
       return tag_a < tag_b ? - 1 : 1;
      }
      switch(tag_a){
        case 247:
         caml_invalid_argument("compare: functional value"); break;
        case 248:
         var x = caml_int_compare(a[2], b[2]); if(x != 0) return x | 0; break;
        case 249:
         caml_invalid_argument("compare: functional value"); break;
        case 250:
         caml_invalid_argument("equal: got Forward_tag, should not happen");
         break;
        case 251:
         caml_invalid_argument("equal: abstract value"); break;
        case 252:
         if(a !== b){
          var x = caml_bytes_compare(a, b);
          if(x != 0) return x | 0;
         }
         break;
        case 253:
         caml_invalid_argument("equal: got Double_tag, should not happen");
         break;
        case 254:
         caml_invalid_argument
          ("equal: got Double_array_tag, should not happen");
         break;
        case 255:
         caml_invalid_argument("equal: got Custom_tag, should not happen");
         break;
        case 1247:
         caml_invalid_argument("compare: functional value"); break;
        case 1255:
         var comp = caml_compare_val_get_custom(a);
         if(comp != caml_compare_val_get_custom(b))
          return a.caml_custom < b.caml_custom ? - 1 : 1;
         if(! comp) caml_invalid_argument("compare: abstract value");
         var x = comp(a, b, total);
         if(x != x) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x != 0) return x | 0;
         break;
        case 1256:
         var x = a.compare(b, total);
         if(x != x) return total ? - 1 : x;
         if(x !== (x | 0)) return - 1;
         if(x != 0) return x | 0;
         break;
        case 1000:
         a = + a;
         b = + b;
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a != b){
          if(! total) return NaN;
          if(a == a) return 1;
          if(b == b) return - 1;
         }
         break;
        case 1001:
         if(a < b) return - 1;
         if(a > b) return 1;
         if(a != b){
          if(! total) return NaN;
          if(a == a) return 1;
          if(b == b) return - 1;
         }
         break;
        case 1251:
         if(a !== b){if(! total) return NaN; return 1;} break;
        case 1252:
         var a = caml_jsbytes_of_string(a), b = caml_jsbytes_of_string(b);
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        case 12520:
         var a = a.toString(), b = b.toString();
         if(a !== b){if(a < b) return - 1; if(a > b) return 1;}
         break;
        case 246:
        case 254:
        default:
         if(caml_is_continuation_tag(tag_a)){
          caml_invalid_argument("compare: continuation value");
          break;
         }
         if(a.length != b.length) return a.length < b.length ? - 1 : 1;
         if(a.length > 1) stack.push(a, b, 1);
         break;
      }
     }
     if(stack.length == 0) return 0;
     var i = stack.pop();
     b = stack.pop();
     a = stack.pop();
     if(i + 1 < a.length) stack.push(a, b, i + 1);
     a = a[i];
     b = b[i];
    }
   }
   function caml_greaterthan(x, y){
    return + (caml_compare_val(x, y, false) > 0);
   }
   function div_helper(a, b, c){
    var
     x = a * 65536 + (b >>> 16),
     y = Math.floor(x / c) * 65536,
     z = x % c * 65536,
     w = z + (b & 0x0000FFFF);
    return [y + Math.floor(w / c), w % c];
   }
   function div_digit_nat(natq, ofsq, natr, ofsr, nat1, ofs1, len, nat2, ofs2){
    var rem = nat1.data[ofs1 + len - 1] >>> 0;
    for(var i = len - 2; i >= 0; i--){
     var
      x = div_helper(rem, nat1.data[ofs1 + i] >>> 0, nat2.data[ofs2] >>> 0);
     natq.data[ofsq + i] = x[0];
     rem = x[1];
    }
    natr.data[ofsr] = rem;
    return 0;
   }
   function num_leading_zero_bits_in_digit(nat, ofs){
    var a = nat.data[ofs], b = 0;
    if(a & 0xFFFF0000){b += 16; a >>>= 16;}
    if(a & 0xFF00){b += 8; a >>>= 8;}
    if(a & 0xF0){b += 4; a >>>= 4;}
    if(a & 12){b += 2; a >>>= 2;}
    if(a & 2){b += 1; a >>>= 1;}
    if(a & 1) b += 1;
    return 32 - b;
   }
   function shift_left_nat(nat1, ofs1, len1, nat2, ofs2, nbits){
    if(nbits == 0){nat2.data[ofs2] = 0; return 0;}
    var wrap = 0;
    for(var i = 0; i < len1; i++){
     var a = nat1.data[ofs1 + i] >>> 0;
     nat1.data[ofs1 + i] = a << nbits | wrap;
     wrap = a >>> 32 - nbits;
    }
    nat2.data[ofs2] = wrap;
    return 0;
   }
   function MlNat(x){
    this.data = new Int32Array(x);
    this.length = this.data.length + 2;
   }
   MlNat.prototype.caml_custom = "_nat";
   function create_nat(size){
    var arr = new MlNat(size);
    for(var i = 0; i < size; i++) arr.data[i] = - 1;
    return arr;
   }
   function set_to_zero_nat(nat, ofs, len){
    for(var i = 0; i < len; i++) nat.data[ofs + i] = 0;
    return 0;
   }
   function incr_nat(nat, ofs, len, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) + carry;
     nat.data[ofs + i] = x | 0;
     if(x == x >>> 0){carry = 0; break;} else carry = 1;
    }
    return carry;
   }
   function add_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var carry = carry_in;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
     nat1.data[ofs1 + i] = x;
     if(x == x >>> 0) carry = 0; else carry = 1;
    }
    return incr_nat(nat1, ofs1 + len2, len1 - len2, carry);
   }
   function nat_of_array(l){return new MlNat(l);}
   function mult_digit_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3){
    var carry = 0, a = nat3.data[ofs3] >>> 0;
    for(var i = 0; i < len2; i++){
     var
      x1 =
        (nat1.data[ofs1 + i] >>> 0)
        + (nat2.data[ofs2 + i] >>> 0) * (a & 0x0000FFFF)
        + carry,
      x2 = (nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
     carry = Math.floor(x2 / 65536);
     var x3 = x1 + x2 % 65536 * 65536;
     nat1.data[ofs1 + i] = x3;
     carry += Math.floor(x3 / 4294967296);
    }
    return len2 < len1 && carry
            ? add_nat
              (nat1, ofs1 + len2, len1 - len2, nat_of_array([carry]), 0, 1, 0)
            : carry;
   }
   function decr_nat(nat, ofs, len, carry_in){
    var borrow = carry_in == 1 ? 0 : 1;
    for(var i = 0; i < len; i++){
     var x = (nat.data[ofs + i] >>> 0) - borrow;
     nat.data[ofs + i] = x;
     if(x >= 0){borrow = 0; break;} else borrow = 1;
    }
    return borrow == 1 ? 0 : 1;
   }
   function sub_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in){
    var borrow = carry_in == 1 ? 0 : 1;
    for(var i = 0; i < len2; i++){
     var
      x = (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
     nat1.data[ofs1 + i] = x;
     if(x >= 0) borrow = 0; else borrow = 1;
    }
    return decr_nat(nat1, ofs1 + len2, len1 - len2, borrow == 1 ? 0 : 1);
   }
   function compare_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var
     a = num_digits_nat(nat1, ofs1, len1),
     b = num_digits_nat(nat2, ofs2, len2);
    if(a > b) return 1;
    if(a < b) return - 1;
    for(var i = len1 - 1; i >= 0; i--){
     if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0) return 1;
     if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0) return - 1;
    }
    return 0;
   }
   function div_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    if(len2 == 1){
     div_digit_nat(nat1, ofs1 + 1, nat1, ofs1, nat1, ofs1, len1, nat2, ofs2);
     return 0;
    }
    var s = num_leading_zero_bits_in_digit(nat2, ofs2 + len2 - 1);
    shift_left_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    shift_left_nat(nat1, ofs1, len1, nat_of_array([0]), 0, s);
    var d = (nat2.data[ofs2 + len2 - 1] >>> 0) + 1, a = create_nat(len2 + 1);
    for(var i = len1 - 1; i >= len2; i--){
     var
      quo =
        d == 4294967296
         ? nat1.data[ofs1 + i] >>> 0
         : div_helper
            (nat1.data[ofs1 + i] >>> 0, nat1.data[ofs1 + i - 1] >>> 0, d)
           [0];
     set_to_zero_nat(a, 0, len2 + 1);
     mult_digit_nat(a, 0, len2 + 1, nat2, ofs2, len2, nat_of_array([quo]), 0);
     sub_nat(nat1, ofs1 + i - len2, len2 + 1, a, 0, len2 + 1, 1);
     while
     (nat1.data[ofs1 + i] != 0
      || compare_nat(nat1, ofs1 + i - len2, len2, nat2, ofs2, len2) >= 0){
      quo = quo + 1;
      sub_nat(nat1, ofs1 + i - len2, len2 + 1, nat2, ofs2, len2, 1);
     }
     nat1.data[ofs1 + i] = quo;
    }
    shift_right_nat(nat1, ofs1, len2, nat_of_array([0]), 0, s);
    shift_right_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s);
    return 0;
   }
   function caml_ba_blit(src, dst){
    if(dst.dims.length != src.dims.length)
     caml_invalid_argument("Bigarray.blit: dimension mismatch");
    for(var i = 0; i < dst.dims.length; i++)
     if(dst.dims[i] != src.dims[i])
      caml_invalid_argument("Bigarray.blit: dimension mismatch");
    dst.data.set(src.data);
    return 0;
   }
   function is_digit_int(nat, ofs){if(nat.data[ofs] >= 0) return 1; return 0;}
   function caml_int64_div(x, y){return x.div(y);}
   function bigstring_find(bs, chr, pos, len){
    while(len > 0){
     if(caml_ba_get_1(bs, pos) == chr) return pos;
     pos++;
     len--;
    }
    return - 1;
   }
   function caml_js_html_entities(s){
    var entity = /^&#?[0-9a-zA-Z]+;$/;
    if(s.match(entity)){
     var str, temp = document.createElement("p");
     temp.innerHTML = s;
     str = temp.textContent || temp.innerText;
     temp = null;
     return str;
    }
    else
     caml_failwith("Invalid entity " + s);
   }
   function caml_string_unsafe_set(s, i, c){
    caml_failwith("caml_string_unsafe_set");
   }
   function caml_ml_channel_size_64(chanid){
    var chan = caml_ml_channels[chanid];
    return caml_int64_of_float(chan.file.length());
   }
   function caml_ba_set_2(ba, i0, i1, v){
    ba.set(ba.offset([i0, i1]), v);
    return 0;
   }
   var
    caml_argv =
      function(){
        var process = globalThis.process, main = "a.out", args = [];
        if(process && process.argv && process.argv.length > 1){
         var argv = process.argv;
         main = argv[1];
         args = argv.slice(2);
        }
        var p = caml_string_of_jsstring(main), args2 = [0, p];
        for(var i = 0; i < args.length; i++)
         args2.push(caml_string_of_jsstring(args[i]));
        return args2;
       }
       (),
    caml_executable_name = caml_argv[1];
   function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s));}
   function serialize_nat(writer, nat, sz){
    var len = nat.data.length;
    writer.write(32, len);
    for(var i = 0; i < len; i++) writer.write(32, nat.data[i]);
    sz[0] = len * 4;
    sz[1] = len * 8;
   }
   function caml_memprof_set(_control){return 0;}
   function caml_sys_exit(code){
    if(globalThis.quit) globalThis.quit(code);
    if(globalThis.process && globalThis.process.exit)
     globalThis.process.exit(code);
    caml_invalid_argument("Function 'exit' not implemented");
   }
   function caml_channel_descriptor(chanid){
    var chan = caml_ml_channels[chanid];
    return chan.fd;
   }
   function caml_js_from_array(a){return a.slice(1);}
   function caml_ba_reshape(ba, vind){
    vind = caml_js_from_array(vind);
    var new_dim = [], num_dims = vind.length;
    if(num_dims < 0 || num_dims > 16)
     caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
    var num_elts = 1;
    for(var i = 0; i < num_dims; i++){
     new_dim[i] = vind[i];
     if(new_dim[i] < 0)
      caml_invalid_argument("Bigarray.reshape: negative dimension");
     num_elts = num_elts * new_dim[i];
    }
    var size = caml_ba_get_size(ba.dims);
    if(num_elts != size)
     caml_invalid_argument("Bigarray.reshape: size mismatch");
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dim, ba.data);
   }
   var caml_oo_last_id = 0;
   function caml_set_oo_id(b){b[2] = caml_oo_last_id++; return b;}
   function caml_gr_fill_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.fillRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_gr_set_window_title(name){
    var s = caml_gr_state_get();
    s.title = name;
    var jsname = caml_jsstring_of_string(name);
    if(s.set_title) s.set_title(jsname);
    return 0;
   }
   function caml_get_global_data(){return caml_global_data;}
   function caml_int64_shift_right_unsigned(x, s){return x.shift_right_unsigned(s);
   }
   function caml_ba_uint8_get16(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    var b1 = ba.get(ofs), b2 = ba.get(ofs + 1);
    return b1 | b2 << 8;
   }
   function bigstring_is_mmapped_stub(x){return 0;}
   function caml_check_bound(array, index){
    if(index >>> 0 >= array.length - 1) caml_array_bound_error();
    return array;
   }
   function caml_check_bound_bigstring(bigstring, i){
    if(i >>> 0 >= bigstring.data.length) caml_array_bound_error();
   }
   function bin_prot_blit_buf_float_array_stub
   (src_pos, src, dst_pos, dst, len){
    if(len == 0) return 0;
    caml_check_bound(dst, dst_pos);
    caml_check_bound(dst, dst_pos + len - 1);
    caml_check_bound_bigstring(src, src_pos);
    caml_check_bound_bigstring(src, src_pos + len * 8 - 1);
    var
     view = new joo_global_object.Float64Array(len),
     buffer = new joo_global_object.Uint8Array(view.buffer);
    buffer.set(src.data.subarray(src_pos, src_pos + len * 8));
    for(var i = 0; i < len; i++) dst[dst_pos + i + 1] = view[i];
    return 0;
   }
   function caml_compare(a, b){return caml_compare_val(a, b, true);}
   var
    caml_MD5Transform =
      function(){
        function add(x, y){return x + y | 0;}
        function xx(q, a, b, x, s, t){
         a = add(add(a, q), add(x, t));
         return add(a << s | a >>> 32 - s, b);
        }
        function ff(a, b, c, d, x, s, t){
         return xx(b & c | ~ b & d, a, b, x, s, t);
        }
        function gg(a, b, c, d, x, s, t){
         return xx(b & d | c & ~ d, a, b, x, s, t);
        }
        function hh(a, b, c, d, x, s, t){return xx(b ^ c ^ d, a, b, x, s, t);}
        function ii(a, b, c, d, x, s, t){
         return xx(c ^ (b | ~ d), a, b, x, s, t);
        }
        return function(w, buffer){
         var a = w[0], b = w[1], c = w[2], d = w[3];
         a = ff(a, b, c, d, buffer[0], 7, 0xD76AA478);
         d = ff(d, a, b, c, buffer[1], 12, 0xE8C7B756);
         c = ff(c, d, a, b, buffer[2], 17, 0x242070DB);
         b = ff(b, c, d, a, buffer[3], 22, 0xC1BDCEEE);
         a = ff(a, b, c, d, buffer[4], 7, 0xF57C0FAF);
         d = ff(d, a, b, c, buffer[5], 12, 0x4787C62A);
         c = ff(c, d, a, b, buffer[6], 17, 0xA8304613);
         b = ff(b, c, d, a, buffer[7], 22, 0xFD469501);
         a = ff(a, b, c, d, buffer[8], 7, 0x698098D8);
         d = ff(d, a, b, c, buffer[9], 12, 0x8B44F7AF);
         c = ff(c, d, a, b, buffer[10], 17, 0xFFFF5BB1);
         b = ff(b, c, d, a, buffer[11], 22, 0x895CD7BE);
         a = ff(a, b, c, d, buffer[12], 7, 0x6B901122);
         d = ff(d, a, b, c, buffer[13], 12, 0xFD987193);
         c = ff(c, d, a, b, buffer[14], 17, 0xA679438E);
         b = ff(b, c, d, a, buffer[15], 22, 0x49B40821);
         a = gg(a, b, c, d, buffer[1], 5, 0xF61E2562);
         d = gg(d, a, b, c, buffer[6], 9, 0xC040B340);
         c = gg(c, d, a, b, buffer[11], 14, 0x265E5A51);
         b = gg(b, c, d, a, buffer[0], 20, 0xE9B6C7AA);
         a = gg(a, b, c, d, buffer[5], 5, 0xD62F105D);
         d = gg(d, a, b, c, buffer[10], 9, 0x02441453);
         c = gg(c, d, a, b, buffer[15], 14, 0xD8A1E681);
         b = gg(b, c, d, a, buffer[4], 20, 0xE7D3FBC8);
         a = gg(a, b, c, d, buffer[9], 5, 0x21E1CDE6);
         d = gg(d, a, b, c, buffer[14], 9, 0xC33707D6);
         c = gg(c, d, a, b, buffer[3], 14, 0xF4D50D87);
         b = gg(b, c, d, a, buffer[8], 20, 0x455A14ED);
         a = gg(a, b, c, d, buffer[13], 5, 0xA9E3E905);
         d = gg(d, a, b, c, buffer[2], 9, 0xFCEFA3F8);
         c = gg(c, d, a, b, buffer[7], 14, 0x676F02D9);
         b = gg(b, c, d, a, buffer[12], 20, 0x8D2A4C8A);
         a = hh(a, b, c, d, buffer[5], 4, 0xFFFA3942);
         d = hh(d, a, b, c, buffer[8], 11, 0x8771F681);
         c = hh(c, d, a, b, buffer[11], 16, 0x6D9D6122);
         b = hh(b, c, d, a, buffer[14], 23, 0xFDE5380C);
         a = hh(a, b, c, d, buffer[1], 4, 0xA4BEEA44);
         d = hh(d, a, b, c, buffer[4], 11, 0x4BDECFA9);
         c = hh(c, d, a, b, buffer[7], 16, 0xF6BB4B60);
         b = hh(b, c, d, a, buffer[10], 23, 0xBEBFBC70);
         a = hh(a, b, c, d, buffer[13], 4, 0x289B7EC6);
         d = hh(d, a, b, c, buffer[0], 11, 0xEAA127FA);
         c = hh(c, d, a, b, buffer[3], 16, 0xD4EF3085);
         b = hh(b, c, d, a, buffer[6], 23, 0x04881D05);
         a = hh(a, b, c, d, buffer[9], 4, 0xD9D4D039);
         d = hh(d, a, b, c, buffer[12], 11, 0xE6DB99E5);
         c = hh(c, d, a, b, buffer[15], 16, 0x1FA27CF8);
         b = hh(b, c, d, a, buffer[2], 23, 0xC4AC5665);
         a = ii(a, b, c, d, buffer[0], 6, 0xF4292244);
         d = ii(d, a, b, c, buffer[7], 10, 0x432AFF97);
         c = ii(c, d, a, b, buffer[14], 15, 0xAB9423A7);
         b = ii(b, c, d, a, buffer[5], 21, 0xFC93A039);
         a = ii(a, b, c, d, buffer[12], 6, 0x655B59C3);
         d = ii(d, a, b, c, buffer[3], 10, 0x8F0CCC92);
         c = ii(c, d, a, b, buffer[10], 15, 0xFFEFF47D);
         b = ii(b, c, d, a, buffer[1], 21, 0x85845DD1);
         a = ii(a, b, c, d, buffer[8], 6, 0x6FA87E4F);
         d = ii(d, a, b, c, buffer[15], 10, 0xFE2CE6E0);
         c = ii(c, d, a, b, buffer[6], 15, 0xA3014314);
         b = ii(b, c, d, a, buffer[13], 21, 0x4E0811A1);
         a = ii(a, b, c, d, buffer[4], 6, 0xF7537E82);
         d = ii(d, a, b, c, buffer[11], 10, 0xBD3AF235);
         c = ii(c, d, a, b, buffer[2], 15, 0x2AD7D2BB);
         b = ii(b, c, d, a, buffer[9], 21, 0xEB86D391);
         w[0] = add(a, w[0]);
         w[1] = add(b, w[1]);
         w[2] = add(c, w[2]);
         w[3] = add(d, w[3]);};
       }
       ();
   function caml_MD5Update(ctx, input, input_len){
    var in_buf = ctx.len & 0x3f, input_pos = 0;
    ctx.len += input_len;
    if(in_buf){
     var missing = 64 - in_buf;
     if(input_len < missing){
      ctx.b8.set(input.subarray(0, input_len), in_buf);
      return;
     }
     ctx.b8.set(input.subarray(0, missing), in_buf);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= missing;
     input_pos += missing;
    }
    while(input_len >= 64){
     ctx.b8.set(input.subarray(input_pos, input_pos + 64), 0);
     caml_MD5Transform(ctx.w, ctx.b32);
     input_len -= 64;
     input_pos += 64;
    }
    if(input_len)
     ctx.b8.set(input.subarray(input_pos, input_pos + input_len), 0);
   }
   function caml_runtime_events_read_poll(cursor, callbacks, num){return 0;}
   function caml_fresh_oo_id(){return caml_oo_last_id++;}
   function caml_int64_to_float(x){return x.toFloat();}
   var ppx_expect_runtime_saved_stderr, ppx_expect_runtime_saved_stdout;
   function ppx_expect_runtime_before_test(voutput, vstdout, vstderr){
    ppx_expect_runtime_saved_stderr = caml_ml_channels[vstderr];
    ppx_expect_runtime_saved_stdout = caml_ml_channels[vstdout];
    var output = caml_ml_channels[voutput];
    caml_ml_channels[vstdout] = output;
    caml_ml_channels[vstderr] = output;
    return 0;
   }
   function caml_bigstring_memcmp(s1, pos1, s2, pos2, len){
    for(var i = 0; i < len; i++){
     var a = caml_ba_get_1(s1, pos1 + i), b = caml_ba_get_1(s2, pos2 + i);
     if(a < b) return - 1;
     if(a > b) return 1;
    }
    return 0;
   }
   function caml_new_string(s){return caml_string_of_jsbytes(s);}
   function caml_erf_float(x){
    var
     a1 = 0.254829592,
     a2 = - 0.284496736,
     a3 = 1.421413741,
     a4 = - 1.453152027,
     a5 = 1.061405429,
     p = 0.3275911,
     sign = 1;
    if(x < 0) sign = - 1;
    x = Math.abs(x);
    var
     t = 1.0 / (1.0 + p * x),
     y =
       1.0
       -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t
        * Math.exp(- (x * x));
    return sign * y;
   }
   function caml_ba_uint8_get32(ba, i0){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    var
     b1 = ba.get(ofs + 0),
     b2 = ba.get(ofs + 1),
     b3 = ba.get(ofs + 2),
     b4 = ba.get(ofs + 3);
    return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24;
   }
   function caml_raw_backtrace_length(){return 0;}
   function caml_str_initialize(unit){return 0;}
   function caml_obj_block(tag, size){
    var o = new Array(size + 1);
    o[0] = tag;
    for(var i = 1; i <= size; i++) o[i] = 0;
    return o;
   }
   function caml_gr_clear_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = s.width;
    s.canvas.height = s.height;
    return 0;
   }
   function bigstring_to_array_buffer(bs){return bs.data.buffer;}
   function caml_sys_const_naked_pointers_checked(_unit){return 0;}
   function lxor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] ^= nat2.data[ofs2]; return 0;
   }
   function caml_obj_add_offset(v, offset){
    caml_failwith("Obj.add_offset is not supported");
   }
   function caml_final_release(){return 0;}
   var caml_marshal_header_size = 16;
   function caml_js_to_array(a){
    var len = a.length, b = new Array(len + 1);
    b[0] = 0;
    for(var i = 0; i < len; i++) b[i + 1] = a[i];
    return b;
   }
   function caml_sys_is_regular_file(name){
    var root = resolve_fs_device(name);
    return root.device.isFile(root.rest);
   }
   function caml_gr_plot(x, y){
    var
     s = caml_gr_state_get(),
     im = s.context.createImageData(1, 1),
     d = im.data,
     color = s.color;
    d[0] = color >> 16 & 0xff;
    d[1] = color >> 8 & 0xff, d[2] = color >> 0 & 0xff;
    d[3] = 0xFF;
    s.x = x;
    s.y = y;
    s.context.putImageData(im, x, s.height - y);
    return 0;
   }
   function caml_bytes_set64(s, i, i64){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = caml_int64_to_bytes(i64);
    for(var j = 0; j < 8; j++) caml_bytes_unsafe_set(s, i + 7 - j, a[j]);
    return 0;
   }
   function caml_string_set16(s, i, i16){caml_failwith("caml_string_set16");}
   function caml_int64_bswap(x){
    var y = caml_int64_to_bytes(x);
    return caml_int64_of_bytes
            ([y[7], y[6], y[5], y[4], y[3], y[2], y[1], y[0]]);
   }
   function caml_gc_major(unit){
    if(typeof globalThis.gc == "function") globalThis.gc();
    return 0;
   }
   function caml_lex_array(s){
    s = caml_jsbytes_of_string(s);
    var l = s.length / 2, a = new Array(l);
    for(var i = 0; i < l; i++)
     a[i] = (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8) << 16 >> 16;
    return a;
   }
   function caml_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    var
     c,
     state = start_state,
     buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0) return - base - 1;
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] == 0) return - state - 1; else c = 256;
     else{c = buffer[lexbuf[lex_curr_pos]]; lexbuf[lex_curr_pos]++;}
     if(tbl.lex_check[base + c] == state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] == - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else if(c == 256) lexbuf[lex_eof_reached] = 0;
    }
   }
   function caml_sys_file_exists(name){
    var root = resolve_fs_device(name);
    return root.device.exists(root.rest);
   }
   function caml_convert_raw_backtrace_slot(){
    caml_failwith("caml_convert_raw_backtrace_slot");
   }
   function caml_array_sub(a, i, len){
    var a2 = new Array(len + 1);
    a2[0] = 0;
    for(var i2 = 1, i1 = i + 1; i2 <= len; i2++, i1++) a2[i2] = a[i1];
    return a2;
   }
   function caml_bytes_equal(s1, s2){
    if(s1 === s2) return 1;
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c == s2.c ? 1 : 0;
   }
   function caml_gr_size_x(){var s = caml_gr_state_get(); return s.width;}
   function Base_int_math_int32_clz(x){
    var n = 32, y;
    y = x >> 16;
    if(y != 0){n = n - 16; x = y;}
    y = x >> 8;
    if(y != 0){n = n - 8; x = y;}
    y = x >> 4;
    if(y != 0){n = n - 4; x = y;}
    y = x >> 2;
    if(y != 0){n = n - 2; x = y;}
    y = x >> 1;
    if(y != 0) return n - 2;
    return n - x;
   }
   function caml_ml_debug_info_status(){return 0;}
   function should_use_timezone_js_loader
   (yes, _platform_not_supported, disabled){
    return globalThis.DISABLE_TIMEZONE_JS_LOADER === undefined
            ? yes
            : disabled;
   }
   function caml_atomic_fetch_add(ref, i){
    var old = ref[1];
    ref[1] += i;
    return old;
   }
   var
    os_type =
      globalThis.process && globalThis.process.platform
       && globalThis.process.platform == "win32"
       ? "Cygwin"
       : "Unix";
   function caml_sys_const_ostype_cygwin(){return os_type == "Cygwin" ? 1 : 0;
   }
   function caml_cosh_float(x){return Math.cosh(x);}
   function MlMutex(){this.locked = false;}
   function caml_ml_mutex_new(unit){return new MlMutex();}
   var caml_ephe_key_offset = 3;
   function caml_ephe_check_key(x, i){
    var weak = x[caml_ephe_key_offset + i];
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
     weak = weak.deref();
    return weak === undefined ? 0 : 1;
   }
   function caml_hash_mix_final(h){
    h ^= h >>> 16;
    h = caml_mul(h, 0x85ebca6b | 0);
    h ^= h >>> 13;
    h = caml_mul(h, 0xc2b2ae35 | 0);
    h ^= h >>> 16;
    return h;
   }
   function caml_gr_text_size(txt){
    var
     s = caml_gr_state_get(),
     w = s.context.measureText(caml_jsstring_of_string(txt)).width;
    return [0, w, s.text_size];
   }
   function caml_lex_run_mem(s, i, mem, curr_pos){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst == 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src == 0xff)
      mem[dst + 1] = curr_pos;
     else
      mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_lex_run_tag(s, i, mem){
    for(;;){
     var dst = s.charCodeAt(i);
     i++;
     if(dst == 0xff) return;
     var src = s.charCodeAt(i);
     i++;
     if(src == 0xff) mem[dst + 1] = - 1; else mem[dst + 1] = mem[src + 1];
    }
   }
   function caml_new_lex_engine(tbl, start_state, lexbuf){
    var
     lex_buffer = 2,
     lex_buffer_len = 3,
     lex_start_pos = 5,
     lex_curr_pos = 6,
     lex_last_pos = 7,
     lex_last_action = 8,
     lex_eof_reached = 9,
     lex_mem = 10,
     lex_base = 1,
     lex_backtrk = 2,
     lex_default = 3,
     lex_trans = 4,
     lex_check = 5,
     lex_base_code = 6,
     lex_backtrk_code = 7,
     lex_default_code = 8,
     lex_trans_code = 9,
     lex_check_code = 10,
     lex_code = 11;
    if(! tbl.lex_default){
     tbl.lex_base = caml_lex_array(tbl[lex_base]);
     tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
     tbl.lex_check = caml_lex_array(tbl[lex_check]);
     tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
     tbl.lex_default = caml_lex_array(tbl[lex_default]);
    }
    if(! tbl.lex_default_code){
     tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
     tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
     tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
     tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
     tbl.lex_default_code = caml_lex_array(tbl[lex_default_code]);
    }
    if(tbl.lex_code == null)
     tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
    var
     c,
     state = start_state,
     buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
    if(state >= 0){
     lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
     lexbuf[lex_last_action] = - 1;
    }
    else
     state = - state - 1;
    for(;;){
     var base = tbl.lex_base[state];
     if(base < 0){
      var pc_off = tbl.lex_base_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      return - base - 1;
     }
     var backtrk = tbl.lex_backtrk[state];
     if(backtrk >= 0){
      var pc_off = tbl.lex_backtrk_code[state];
      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
      lexbuf[lex_last_action] = backtrk;
     }
     if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
      if(lexbuf[lex_eof_reached] == 0) return - state - 1; else c = 256;
     else{c = buffer[lexbuf[lex_curr_pos]]; lexbuf[lex_curr_pos]++;}
     var pstate = state;
     if(tbl.lex_check[base + c] == state)
      state = tbl.lex_trans[base + c];
     else
      state = tbl.lex_default[state];
     if(state < 0){
      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
      if(lexbuf[lex_last_action] == - 1)
       caml_failwith("lexing: empty token");
      else
       return lexbuf[lex_last_action];
     }
     else{
      var base_code = tbl.lex_base_code[pstate], pc_off;
      if(tbl.lex_check_code[base_code + c] == pstate)
       pc_off = tbl.lex_trans_code[base_code + c];
      else
       pc_off = tbl.lex_default_code[pstate];
      if(pc_off > 0)
       caml_lex_run_mem
        (tbl.lex_code, pc_off, lexbuf[lex_mem], lexbuf[lex_curr_pos]);
      if(c == 256) lexbuf[lex_eof_reached] = 0;
     }
    }
   }
   function caml_ba_uint8_set64(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 7 >= ba.data.length) caml_array_bound_error();
    var v = caml_int64_to_bytes(v);
    for(var i = 0; i < 8; i++) ba.set(ofs + i, v[7 - i]);
    return 0;
   }
   function caml_sys_executable_name(a){return caml_executable_name;}
   function caml_lessequal(x, y){
    return + (caml_compare_val(x, y, false) <= 0);
   }
   function caml_acosh_float(x){return Math.acosh(x);}
   function caml_MD5Init(){
    var
     buffer = new ArrayBuffer(64),
     b32 = new Uint32Array(buffer),
     b8 = new Uint8Array(buffer);
    return {len: 0,
            w:
            new Uint32Array([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476]),
            b32: b32,
            b8: b8};
   }
   function caml_ml_flush(chanid){
    var chan = caml_ml_channels[chanid];
    if(! chan.opened) caml_raise_sys_error("Cannot flush a closed channel");
    if(! chan.buffer || chan.buffer_curr == 0) return 0;
    if(chan.output)
     chan.output(caml_subarray_to_jsbytes(chan.buffer, 0, chan.buffer_curr));
    else
     chan.file.write(chan.offset, chan.buffer, 0, chan.buffer_curr);
    chan.offset += chan.buffer_curr;
    chan.buffer_curr = 0;
    return 0;
   }
   function caml_seek_out(chanid, pos){
    caml_ml_flush(chanid);
    var chan = caml_ml_channels[chanid];
    chan.offset = pos;
    return 0;
   }
   function caml_ml_seek_out_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_out(chanid, pos);
   }
   function compare_nat_real(nat1, nat2){
    return compare_nat(nat1, 0, nat1.data.length, nat2, 0, nat2.data.length);
   }
   function caml_gc_set(_control){return 0;}
   function caml_js_get(o, f){return o[f];}
   function caml_unix_isatty(fileDescriptor){
    if(fs_node_supported()){
     var tty = require("tty");
     return tty.isatty(fileDescriptor) ? 1 : 0;
    }
    else
     return 0;
   }
   function caml_ml_set_buffered(chanid, v){
    caml_ml_channels[chanid].buffered = v;
    if(! v) caml_ml_flush(chanid);
    return 0;
   }
   function caml_hash_mix_bytes_arr(h, s){
    var len = s.length, i, w;
    for(i = 0; i + 4 <= len; i += 4){
     w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
     h = caml_hash_mix_int(h, w);
    }
    w = 0;
    switch(len & 3){
      case 3:
       w = s[i + 2] << 16;
      case 2:
       w |= s[i + 1] << 8;
      case 1:
       w |= s[i]; h = caml_hash_mix_int(h, w);
    }
    h ^= len;
    return h;
   }
   function caml_ml_bytes_content(s){
    switch(s.t & 6){
      default: caml_convert_string_to_bytes(s);
      case 0:
       return s.c;
      case 4:
       return s.c;
    }
   }
   function caml_hash_mix_bytes(h, v){
    var content = caml_ml_bytes_content(v);
    return typeof content === "string"
            ? caml_hash_mix_jsbytes(h, content)
            : caml_hash_mix_bytes_arr(h, content);
   }
   function caml_hash(count, limit, seed, obj){
    var queue, rd, wr, sz, num, h, v, i, len;
    sz = limit;
    if(sz < 0 || sz > 256) sz = 256;
    num = count;
    h = seed;
    queue = [obj];
    rd = 0;
    wr = 1;
    while(rd < wr && num > 0){
     v = queue[rd++];
     if(v && v.caml_custom){
      if
       (caml_custom_ops[v.caml_custom] && caml_custom_ops[v.caml_custom].hash){
       var hh = caml_custom_ops[v.caml_custom].hash(v);
       h = caml_hash_mix_int(h, hh);
       num--;
      }
     }
     else if(v instanceof Array && v[0] === (v[0] | 0))
      switch(v[0]){
        case 248:
         h = caml_hash_mix_int(h, v[2]); num--; break;
        case 250:
         queue[--rd] = v[1]; break;
        default:
         if(caml_is_continuation_tag(v[0])) break;
         var tag = v.length - 1 << 10 | v[0];
         h = caml_hash_mix_int(h, tag);
         for(i = 1, len = v.length; i < len; i++){if(wr >= sz) break; queue[wr++] = v[i];
         }
         break;
      }
     else if(caml_is_ml_bytes(v)){
      h = caml_hash_mix_bytes(h, v);
      num--;
     }
     else if(caml_is_ml_string(v)){
      h = caml_hash_mix_string(h, v);
      num--;
     }
     else if(typeof v === "string"){
      h = caml_hash_mix_jsbytes(h, v);
      num--;
     }
     else if(v === (v | 0)){
      h = caml_hash_mix_int(h, v + v + 1);
      num--;
     }
     else if(typeof v === "number"){h = caml_hash_mix_float(h, v); num--;}
    }
    h = caml_hash_mix_final(h);
    return h & 0x3FFFFFFF;
   }
   function Base_hash_string(s){return caml_hash(1, 1, 0, s);}
   function caml_gc_compaction(){return 0;}
   function bin_prot_blit_float_array_buf_stub
   (src_pos, src, dst_pos, dst, len){
    if(len == 0) return 0;
    caml_check_bound(src, src_pos);
    caml_check_bound(src, src_pos + len - 1);
    caml_check_bound_bigstring(dst, dst_pos);
    caml_check_bound_bigstring(dst, dst_pos + len * 8 - 1);
    src_pos = src_pos + 1;
    var
     float64 =
       new joo_global_object.Float64Array(src.slice(src_pos, src_pos + len)),
     float64_uint8 = new joo_global_object.Uint8Array(float64.buffer),
     view = dst.data.subarray(dst_pos, dst_pos + len * 8);
    view.set(float64_uint8);
    return 0;
   }
   function caml_sys_open_for_node(fd, flags){
    if(flags.name)
     try{
      var fs = require("fs"), fd2 = fs.openSync(flags.name, "rs");
      return new MlNodeFd(fd2, flags);
     }
     catch(e){}
    return new MlNodeFd(fd, flags);
   }
   var caml_sys_fds = new Array(3);
   function MlFakeFd_out(fd, flags){
    MlFakeFile.call(this, caml_create_bytes(0));
    this.log = function(s){return 0;};
    if(fd == 1 && typeof console.log == "function")
     this.log = console.log;
    else if(fd == 2 && typeof console.error == "function")
     this.log = console.error;
    else if(typeof console.log == "function") this.log = console.log;
    this.flags = flags;
   }
   MlFakeFd_out.prototype.length = function(){return 0;};
   MlFakeFd_out.prototype.write =
    function(offset, buf, pos, len){
     if(this.log){
      if
       (len > 0 && pos >= 0 && pos + len <= buf.length
        && buf[pos + len - 1] == 10)
       len--;
      var src = caml_create_bytes(len);
      caml_blit_bytes(caml_bytes_of_array(buf), pos, src, 0, len);
      this.log(src.toUtf16());
      return 0;
     }
     caml_raise_sys_error(this.fd + ": file descriptor already closed");
    };
   MlFakeFd_out.prototype.read =
    function(offset, buf, pos, len){
     caml_raise_sys_error(this.fd + ": file descriptor is write only");
    };
   MlFakeFd_out.prototype.close = function(){this.log = undefined;};
   function caml_sys_open_internal(file, idx){
    if(idx == undefined) idx = caml_sys_fds.length;
    caml_sys_fds[idx] = file;
    return idx | 0;
   }
   function caml_sys_open(name, flags, _perms){
    var f = {};
    while(flags){
     switch(flags[1]){
       case 0:
        f.rdonly = 1; break;
       case 1:
        f.wronly = 1; break;
       case 2:
        f.append = 1; break;
       case 3:
        f.create = 1; break;
       case 4:
        f.truncate = 1; break;
       case 5:
        f.excl = 1; break;
       case 6:
        f.binary = 1; break;
       case 7:
        f.text = 1; break;
       case 8:
        f.nonblock = 1; break;
     }
     flags = flags[2];
    }
    if(f.rdonly && f.wronly)
     caml_raise_sys_error
      (caml_jsbytes_of_string(name)
       + " : flags Open_rdonly and Open_wronly are not compatible");
    if(f.text && f.binary)
     caml_raise_sys_error
      (caml_jsbytes_of_string(name)
       + " : flags Open_text and Open_binary are not compatible");
    var root = resolve_fs_device(name), file = root.device.open(root.rest, f);
    return caml_sys_open_internal(file, undefined);
   }
   (function(){
      function file(fd, flags){
       return fs_node_supported()
               ? caml_sys_open_for_node(fd, flags)
               : new MlFakeFd_out(fd, flags);
      }
      caml_sys_open_internal
       (file(0, {rdonly: 1, altname: "/dev/stdin", isCharacterDevice: true}),
        0);
      caml_sys_open_internal
       (file(1, {buffered: 2, wronly: 1, isCharacterDevice: true}), 1);
      caml_sys_open_internal
       (file(2, {buffered: 2, wronly: 1, isCharacterDevice: true}), 2);
     }
     ());
   function caml_ml_open_descriptor_in(fd){
    var file = caml_sys_fds[fd];
    if(file.flags.wronly) caml_raise_sys_error("fd " + fd + " is writeonly");
    var
     refill = null,
     channel =
       {file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: false,
        buffer_curr: 0,
        buffer_max: 0,
        buffer: new Uint8Array(65536),
        refill: refill};
    caml_ml_channels[channel.fd] = channel;
    return channel.fd;
   }
   function caml_MD5Final(ctx){
    var in_buf = ctx.len & 0x3f;
    ctx.b8[in_buf] = 0x80;
    in_buf++;
    if(in_buf > 56){
     for(var j = in_buf; j < 64; j++) ctx.b8[j] = 0;
     caml_MD5Transform(ctx.w, ctx.b32);
     for(var j = 0; j < 56; j++) ctx.b8[j] = 0;
    }
    else
     for(var j = in_buf; j < 56; j++) ctx.b8[j] = 0;
    ctx.b32[14] = ctx.len << 3;
    ctx.b32[15] = ctx.len >> 29 & 0x1FFFFFFF;
    caml_MD5Transform(ctx.w, ctx.b32);
    var t = new Uint8Array(16);
    for(var i = 0; i < 4; i++)
     for(var j = 0; j < 4; j++) t[i * 4 + j] = ctx.w[i] >> 8 * j & 0xFF;
    return t;
   }
   function caml_string_of_array(a){
    return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a, 0, a.length));
   }
   function caml_md5_chan(chanid, toread){
    var ctx = caml_MD5Init(), buffer = new Uint8Array(4096);
    if(toread < 0)
     while(true){
      var read = caml_ml_input_block(chanid, buffer, 0, buffer.length);
      if(read == 0) break;
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
     }
    else
     while(toread > 0){
      var
       read =
         caml_ml_input_block
          (chanid, buffer, 0, toread > buffer.length ? buffer.length : toread);
      if(read == 0) caml_raise_end_of_file();
      caml_MD5Update(ctx, buffer.subarray(0, read), read);
      toread -= read;
     }
    return caml_string_of_array(caml_MD5Final(ctx));
   }
   function caml_sys_close(fd){
    var file = caml_sys_fds[fd];
    if(file) file.close();
    delete caml_sys_fds[fd];
    return 0;
   }
   function caml_ml_close_channel(chanid){
    var chan = caml_ml_channels[chanid];
    chan.opened = false;
    caml_sys_close(chan.fd);
    return 0;
   }
   function core_md5_fd(fd){
    var ic = caml_ml_open_descriptor_in(fd);
    try{return caml_md5_chan(ic, - 1);}finally{caml_ml_close_channel(ic);}
   }
   function caml_ephe_get_key(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.get_key");
    var weak = x[caml_ephe_key_offset + i];
    if(globalThis.WeakRef && weak instanceof globalThis.WeakRef)
     weak = weak.deref();
    return weak === undefined ? 0 : [0, weak];
   }
   function caml_unix_localtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(d.getFullYear(), 0, 1).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000),
     jan = new Date(d.getFullYear(), 0, 1),
     jul = new Date(d.getFullYear(), 6, 1),
     stdTimezoneOffset =
       Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    return [0,
            d.getSeconds(),
            d.getMinutes(),
            d.getHours(),
            d.getDate(),
            d.getMonth(),
            d.getFullYear() - 1900,
            d.getDay(),
            doy,
            d.getTimezoneOffset() < stdTimezoneOffset | 0];
   }
   function caml_unix_mktime(tm){
    var
     d = new Date(tm[6] + 1900, tm[5], tm[4], tm[3], tm[2], tm[1]).getTime(),
     t = Math.floor(d / 1000),
     tm2 = caml_unix_localtime(t);
    return [0, t, tm2];
   }
   function ppx_expect_runtime_out_channel_position(chan){
    var info = caml_ml_channels[chan];
    return info.offset;
   }
   function caml_bigstring_blit_bytes_to_ba(str1, pos1, ba2, pos2, len){
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs2 = ba2.offset(pos2);
    if(pos1 + len > caml_ml_bytes_length(str1)) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = caml_uint8_array_of_bytes(str1).slice(pos1, pos1 + len);
    ba2.data.set(slice, ofs2);
    return 0;
   }
   function Base_int_math_int_pow_stub(base, exponent){
    var one = 1, mul = [one, base, one, one], res = one;
    while(! exponent == 0){
     mul[1] = mul[1] * mul[3] | 0;
     mul[2] = mul[1] * mul[1] | 0;
     mul[3] = mul[2] * mul[1] | 0;
     res = res * mul[exponent & 3] | 0;
     exponent = exponent >> 2;
    }
    return res;
   }
   function caml_atomic_exchange(ref, v){
    var r = ref[1];
    ref[1] = v;
    return r;
   }
   function caml_sys_isatty(_chan){return 0;}
   function is_digit_zero(nat, ofs){
    if(nat.data[ofs] == 0) return 1;
    return 0;
   }
   function caml_unix_lstat(name){
    var root = resolve_fs_device(name);
    if(! root.device.lstat) caml_failwith("caml_unix_lstat: not implemented");
    return root.device.lstat(root.rest, true);
   }
   function caml_unix_lstat_64(name){
    var r = caml_unix_lstat(name);
    r[9] = caml_int64_of_int32(r[9]);
    return r;
   }
   function caml_js_set(o, f, v){o[f] = v; return 0;}
   function caml_array_get(array, index){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    return array[index + 1];
   }
   function caml_continuation_use_noexc(cont){
    var stack = cont[1];
    cont[1] = 0;
    return stack;
   }
   function caml_unix_rmdir(name){
    var root = resolve_fs_device(name);
    if(! root.device.rmdir) caml_failwith("caml_unix_rmdir: not implemented");
    return root.device.rmdir(root.rest, true);
   }
   function caml_log2_float(x){return Math.log2(x);}
   function caml_gc_huge_fallback_count(unit){return 0;}
   function caml_runtime_events_resume(){return 0;}
   function bin_prot_blit_bytes_buf_stub(src_pos, src, dst_pos, dst, len){
    return caml_bigstring_blit_string_to_ba(src, src_pos, dst, dst_pos, len);
   }
   function caml_spacetime_only_works_for_native_code(){
    caml_failwith("Spacetime profiling only works for native code");
   }
   function caml_int64_sub(x, y){return x.sub(y);}
   function caml_bigstring_blit_ba_to_ba(ba1, pos1, ba2, pos2, len){
    if(12 != ba1.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(12 != ba2.kind)
     caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
    if(len == 0) return 0;
    var ofs1 = ba1.offset(pos1), ofs2 = ba2.offset(pos2);
    if(ofs1 + len > ba1.data.length) caml_array_bound_error();
    if(ofs2 + len > ba2.data.length) caml_array_bound_error();
    var slice = ba1.data.subarray(ofs1, ofs1 + len);
    ba2.data.set(slice, pos2);
    return 0;
   }
   function bigstring_of_typed_array(ba){
    var
     ta =
       new
        Uint8Array
        (ba.buffer, ba.byteOffset, ba.length * ba.BYTES_PER_ELEMENT);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function bin_prot_blit_buf_stub(src_pos, src, dst_pos, dst, len){
    if(src.kind != 12) src = bigstring_of_typed_array(src.data);
    if(dst.kind != 12) dst = bigstring_of_typed_array(dst.data);
    return caml_bigstring_blit_ba_to_ba(src, src_pos, dst, dst_pos, len);
   }
   function caml_seek_in(chanid, pos){
    var chan = caml_ml_channels[chanid];
    if(chan.refill != null) caml_raise_sys_error("Illegal seek");
    if
     (pos >= chan.offset - chan.buffer_max && pos <= chan.offset
      && chan.file.flags.binary)
     chan.buffer_curr = chan.buffer_max - (chan.offset - pos);
    else{chan.offset = pos; chan.buffer_curr = 0; chan.buffer_max = 0;}
    return 0;
   }
   function caml_ml_seek_in_64(chanid, pos){
    var pos = caml_int64_to_float(pos);
    return caml_seek_in(chanid, pos);
   }
   var caml_domain_id = 0;
   function caml_ml_mutex_unlock(t){t.locked = false; return 0;}
   var caml_domain_latest_idx = 1;
   function caml_domain_spawn(f, mutex){
    var id = caml_domain_latest_idx++, old = caml_domain_id;
    caml_domain_id = id;
    var res = caml_callback(f, [0]);
    caml_domain_id = old;
    caml_ml_mutex_unlock(mutex);
    return id;
   }
   function caml_unix_mkdir(name, perm){
    var root = resolve_fs_device(name);
    if(! root.device.mkdir) caml_failwith("caml_unix_mkdir: not implemented");
    return root.device.mkdir(root.rest, perm, true);
   }
   function caml_int64_shift_left(x, s){return x.shift_left(s);}
   function caml_notequal(x, y){
    return + (caml_compare_val(x, y, false) != 0);
   }
   function caml_sys_const_int_size(){return 32;}
   function caml_js_wrap_callback(f){
    return function(){
     var len = arguments.length;
     if(len > 0){
      var args = new Array(len);
      for(var i = 0; i < len; i++) args[i] = arguments[i];
     }
     else
      args = [undefined];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_js_wrap_meth_callback(f){
    return function(){
     var len = arguments.length, args = new Array(len + 1);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     var res = caml_callback(f, args);
     return res instanceof Function ? caml_js_wrap_callback(res) : res;};
   }
   function caml_is_js(){return 1;}
   function caml_sse2_float64_min_bytecode(x, y){return x < y ? x : y;}
   var Base_internalhash_fold_float = caml_hash_mix_float;
   function caml_lazy_update_to_forward(o){
    caml_obj_update_tag(o, 244, 250);
    return 0;
   }
   function caml_ba_dim(ba, i){
    if(i < 0 || i >= ba.dims.length) caml_invalid_argument("Bigarray.dim");
    return ba.dims[i];
   }
   function caml_ba_dim_1(ba){return caml_ba_dim(ba, 0);}
   function caml_js_meth_call(o, f, args){
    return o[caml_jsstring_of_string(f)].apply(o, caml_js_from_array(args));
   }
   var caml_ephe_data_offset = 2;
   function caml_weak_create(n){
    if(n < 0) caml_invalid_argument("Weak.create");
    var x = [251, "caml_ephe_list_head"];
    x.length = caml_ephe_key_offset + n;
    return x;
   }
   function caml_ephe_create(n){var x = caml_weak_create(n); return x;}
   function bigstring_destroy_stub(v_bstr){
    if(v_bstr.hasOwnProperty("__is_deallocated"))
     caml_invalid_argument
      ("bigstring_destroy: bigstring is already deallocated");
    v_bstr.__is_deallocated = true;
    v_bstr.data = new v_bstr.data.__proto__.constructor(0);
    v_bstr.dims = [0];
    return 0;
   }
   function bigstring_realloc(bigstring, size){
    if(bigstring.hasOwnProperty("__is_deallocated"))
     caml_invalid_argument
      ("bigstring_realloc: bigstring is already deallocated");
    var new_data = new bigstring.data.__proto__.constructor(size);
    new_data.set(bigstring.data.slice(0, size));
    var
     new_bigstring =
       caml_ba_create_unsafe
        (bigstring.kind, bigstring.layout, [size], new_data);
    bigstring_destroy_stub(bigstring);
    return new_bigstring;
   }
   function ppx_expect_runtime_flush_stubs_streams(vunit){return 0;}
   function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s);}
   function Base_unsafe_create_local_bytes(v_len){return caml_create_bytes(v_len);
   }
   function caml_trampoline(res){
    var c = 1;
    while(res && res.joo_tramp){
     res = res.joo_tramp.apply(null, res.joo_args);
     c++;
    }
    return res;
   }
   function caml_maybe_print_stats(unit){return 0;}
   function caml_bytes_unsafe_get(s, i){
    switch(s.t & 6){
      default: if(i >= s.c.length) return 0;
      case 0:
       return s.c.charCodeAt(i);
      case 4:
       return s.c[i];
    }
   }
   function caml_bytes_get64(s, i){
    if(i >>> 0 >= s.l - 7) caml_bytes_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_bytes_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   var caml_custom_event_index = 0;
   function caml_runtime_events_user_register
   (event_name, event_tag, event_type){
    caml_custom_event_index += 1;
    return [0, caml_custom_event_index, event_name, event_type, event_tag];
   }
   function caml_unix_has_symlink(unit){return fs_node_supported() ? 1 : 0;}
   function caml_ephe_set_key(x, i, v){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.set");
    if(v instanceof Object && globalThis.WeakRef){
     if(x[1].register) x[1].register(v, undefined, v);
     x[caml_ephe_key_offset + i] = new globalThis.WeakRef(v);
    }
    else
     x[caml_ephe_key_offset + i] = v;
    return 0;
   }
   function caml_ephe_unset_key(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.set");
    if
     (globalThis.WeakRef
      && x[caml_ephe_key_offset + i] instanceof globalThis.WeakRef
      && x[1].unregister){
     var old = x[caml_ephe_key_offset + i].deref();
     if(old !== undefined){
      var count = 0;
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key === old) count++;
       }
      }
      if(count == 1) x[1].unregister(old);
     }
    }
    x[caml_ephe_key_offset + i] = undefined;
    return 0;
   }
   function caml_weak_set(x, i, v){
    if(v == 0) caml_ephe_unset_key(x, i); else caml_ephe_set_key(x, i, v[1]);
    return 0;
   }
   function caml_sys_remove(name){
    var root = resolve_fs_device(name), ok = root.device.unlink(root.rest);
    if(ok == 0) caml_raise_no_such_file(caml_jsbytes_of_string(name));
    return 0;
   }
   function caml_string_bound_error(){
    caml_invalid_argument("index out of bounds");
   }
   function caml_string_get32(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 3) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1),
     b3 = caml_string_unsafe_get(s, i + 2),
     b4 = caml_string_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_bytes_get(s, i){
    if(i >>> 0 >= s.l) caml_bytes_bound_error();
    return caml_bytes_unsafe_get(s, i);
   }
   function caml_hypot_float(x, y){return Math.hypot(x, y);}
   function caml_js_call(f, o, args){
    return f.apply(o, caml_js_from_array(args));
   }
   function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0;}
   function caml_unix_inet_addr_of_string(){return 0;}
   function ms_float_to_ns_int64(ms){
    return caml_int64_of_float(ms * (1000.0 * 1000.0));
   }
   function Base_am_testing(x){return 0;}
   function caml_bytes_lessthan(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c < s2.c ? 1 : 0;
   }
   function bigstringaf_blit_to_bytes(src, src_off, dst, dst_off, len){
    return caml_bigstring_blit_ba_to_bytes(src, src_off, dst, dst_off, len);
   }
   function caml_erfc_float(x){return 1 - caml_erf_float(x);}
   function caml_gr_fill_poly(ar){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(ar[1][1], s.height - ar[1][2]);
    for(var i = 2; i < ar.length; i++)
     s.context.lineTo(ar[i][1], s.height - ar[i][2]);
    s.context.lineTo(ar[1][1], s.height - ar[1][2]);
    s.context.fill();
    return 0;
   }
   function caml_gc_quick_stat(){
    return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
   }
   function caml_ml_input_char(chanid){
    var chan = caml_ml_channels[chanid];
    if(chan.buffer_curr >= chan.buffer_max){
     chan.buffer_curr = 0;
     chan.buffer_max = 0;
     caml_refill(chan);
    }
    if(chan.buffer_curr >= chan.buffer_max) caml_raise_end_of_file();
    var res = chan.buffer[chan.buffer_curr];
    chan.buffer_curr++;
    return res;
   }
   function caml_ml_input_int(chanid){
    var chan = caml_ml_channels[chanid], res = 0;
    for(var i = 0; i < 4; i++)
     res = (res << 8) + caml_ml_input_char(chanid) | 0;
    return res | 0;
   }
   function caml_gr_display_mode(){
    caml_failwith("caml_gr_display_mode not Implemented");
   }
   function caml_obj_reachable_words(o){return 0;}
   function nth_digit_nat(nat, ofs){return nat.data[ofs];}
   function caml_array_blit(a1, i1, a2, i2, len){
    if(i2 <= i1)
     for(var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];
    else
     for(var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];
    return 0;
   }
   function caml_float_of_string(s){
    var res;
    s = caml_jsbytes_of_string(s);
    res = + s;
    if(s.length > 0 && res === res) return res;
    s = s.replace(/_/g, "");
    res = + s;
    if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s)) return res;
    var m = /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s);
    if(m){
     var
      m3 = m[3].replace(/0+$/, ""),
      mantissa = parseInt(m[1] + m[2] + m3, 16),
      exponent = (m[5] | 0) - 4 * m3.length;
     res = mantissa * Math.pow(2, exponent);
     return res;
    }
    if(/^\+?inf(inity)?$/i.test(s)) return Infinity;
    if(/^-inf(inity)?$/i.test(s)) return - Infinity;
    caml_failwith("float_of_string");
   }
   function caml_sys_getcwd(){
    return caml_string_of_jsbytes(caml_current_dir);
   }
   function caml_int64_add(x, y){return x.add(y);}
   function caml_int64_mul(x, y){return x.mul(y);}
   function caml_int64_ult(x, y){return x.ucompare(y) < 0;}
   function caml_parse_sign_and_base(s){
    var i = 0, len = caml_ml_string_length(s), base = 10, sign = 1;
    if(len > 0)
     switch(caml_string_unsafe_get(s, i)){
       case 45:
        i++; sign = - 1; break;
       case 43:
        i++; sign = 1; break;
     }
    if(i + 1 < len && caml_string_unsafe_get(s, i) == 48)
     switch(caml_string_unsafe_get(s, i + 1)){
       case 120:
       case 88:
        base = 16; i += 2; break;
       case 111:
       case 79:
        base = 8; i += 2; break;
       case 98:
       case 66:
        base = 2; i += 2; break;
       case 117:
       case 85:
        i += 2; break;
     }
    return [i, sign, base];
   }
   function caml_parse_digit(c){
    if(c >= 48 && c <= 57) return c - 48;
    if(c >= 65 && c <= 90) return c - 55;
    if(c >= 97 && c <= 122) return c - 87;
    return - 1;
   }
   function caml_int64_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     base64 = caml_int64_of_int32(base),
     threshold =
       new MlInt64(0xffffff, 0xfffffff, 0xffff).udivmod(base64).quotient,
     c = caml_string_unsafe_get(s, i),
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = caml_int64_of_int32(d);
    for(;;){
     i++;
     c = caml_string_unsafe_get(s, i);
     if(c == 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     if(caml_int64_ult(threshold, res)) caml_failwith("int_of_string");
     d = caml_int64_of_int32(d);
     res = caml_int64_add(caml_int64_mul(base64, res), d);
     if(caml_int64_ult(res, d)) caml_failwith("int_of_string");
    }
    if(i != caml_ml_string_length(s)) caml_failwith("int_of_string");
    if(base == 10 && caml_int64_ult(new MlInt64(0, 0, 0x8000), res))
     caml_failwith("int_of_string");
    if(sign < 0) res = caml_int64_neg(res);
    return res;
   }
   function caml_ba_set_1(ba, i0, v){ba.set(ba.offset(i0), v); return 0;}
   function caml_int64_xor(x, y){return x.xor(y);}
   function caml_int64_or(x, y){return x.or(y);}
   function caml_lxm_next(v){
    function shift_l(x, k){return caml_int64_shift_left(x, k);}
    function shift_r(x, k){return caml_int64_shift_right_unsigned(x, k);}
    function or(a, b){return caml_int64_or(a, b);}
    function xor(a, b){return caml_int64_xor(a, b);}
    function add(a, b){return caml_int64_add(a, b);}
    function mul(a, b){return caml_int64_mul(a, b);}
    function rotl(x, k){return or(shift_l(x, k), shift_r(x, 64 - k));}
    function get(a, i){return caml_ba_get_1(a, i);}
    function set(a, i, x){return caml_ba_set_1(a, i, x);}
    var
     M = caml_int64_of_string(caml_new_string("0xd1342543de82ef95")),
     daba = caml_int64_of_string(caml_new_string("0xdaba0b6eb09322e3")),
     z,
     q0,
     q1,
     st = v,
     a = get(st, 0),
     s = get(st, 1),
     x0 = get(st, 2),
     x1 = get(st, 3);
    z = add(s, x0);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = mul(xor(z, shift_r(z, 32)), daba);
    z = xor(z, shift_r(z, 32));
    set(st, 1, add(mul(s, M), a));
    var q0 = x0, q1 = x1;
    q1 = xor(q1, q0);
    q0 = rotl(q0, 24);
    q0 = xor(xor(q0, q1), shift_l(q1, 16));
    q1 = rotl(q1, 37);
    set(st, 2, q0);
    set(st, 3, q1);
    return z;
   }
   function caml_sys_const_big_endian(){return 0;}
   function caml_list_to_js_array(l){
    var a = [];
    for(; l !== 0; l = l[2]) a.push(l[1]);
    return a;
   }
   var
    caml_output_val =
      function(){
        function Writer(){this.chunk = [];}
        Writer.prototype =
         {chunk_idx: 20,
          block_len: 0,
          obj_counter: 0,
          size_32: 0,
          size_64: 0,
          write:
          function(size, value){
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[this.chunk_idx++] = value >> i & 0xFF;
          },
          write_at:
          function(pos, size, value){
           var pos = pos;
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[pos++] = value >> i & 0xFF;
          },
          write_code:
          function(size, code, value){
           this.chunk[this.chunk_idx++] = code;
           for(var i = size - 8; i >= 0; i -= 8)
            this.chunk[this.chunk_idx++] = value >> i & 0xFF;
          },
          write_shared:
          function(offset){
           if(offset < 1 << 8)
            this.write_code(8, 0x04, offset);
           else if(offset < 1 << 16)
            this.write_code(16, 0x05, offset);
           else
            this.write_code(32, 0x06, offset);
          },
          pos: function(){return this.chunk_idx;},
          finalize:
          function(){
           this.block_len = this.chunk_idx - 20;
           this.chunk_idx = 0;
           this.write(32, 0x8495A6BE);
           this.write(32, this.block_len);
           this.write(32, this.obj_counter);
           this.write(32, this.size_32);
           this.write(32, this.size_64);
           return this.chunk;
          }};
        return function(v, flags){
         flags = caml_list_to_js_array(flags);
         var
          no_sharing = flags.indexOf(0) !== - 1,
          closures = flags.indexOf(1) !== - 1;
         if(closures)
          console.warn
           ("in caml_output_val: flag Marshal.Closures is not supported.");
         var
          writer = new Writer(),
          stack = [],
          intern_obj_table = no_sharing ? null : new MlObjectTable();
         function memo(v){
          if(no_sharing) return false;
          var existing_offset = intern_obj_table.recall(v);
          if(existing_offset){
           writer.write_shared(existing_offset);
           return true;
          }
          else{intern_obj_table.store(v); return false;}
         }
         function extern_rec(v){
          if(v.caml_custom){
           if(memo(v)) return;
           var
            name = v.caml_custom,
            ops = caml_custom_ops[name],
            sz_32_64 = [0, 0];
           if(! ops.serialize)
            caml_invalid_argument("output_value: abstract value (Custom)");
           if(ops.fixed_length == undefined){
            writer.write(8, 0x18);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            var header_pos = writer.pos();
            for(var i = 0; i < 12; i++) writer.write(8, 0);
            ops.serialize(writer, v, sz_32_64);
            writer.write_at(header_pos, 32, sz_32_64[0]);
            writer.write_at(header_pos + 4, 32, 0);
            writer.write_at(header_pos + 8, 32, sz_32_64[1]);
           }
           else{
            writer.write(8, 0x19);
            for(var i = 0; i < name.length; i++)
             writer.write(8, name.charCodeAt(i));
            writer.write(8, 0);
            var old_pos = writer.pos();
            ops.serialize(writer, v, sz_32_64);
            if(ops.fixed_length != writer.pos() - old_pos)
             caml_failwith
              ("output_value: incorrect fixed sizes specified by " + name);
           }
           writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
           writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3);
          }
          else if(v instanceof Array && v[0] === (v[0] | 0)){
           if(v[0] == 251)
            caml_failwith("output_value: abstract value (Abstract)");
           if(caml_is_continuation_tag(v[0]))
            caml_invalid_argument("output_value: continuation value");
           if(v.length > 1 && memo(v)) return;
           if(v[0] < 16 && v.length - 1 < 8)
            writer.write(8, 0x80 + v[0] + (v.length - 1 << 4));
           else
            writer.write_code(32, 0x08, v.length - 1 << 10 | v[0]);
           writer.size_32 += v.length;
           writer.size_64 += v.length;
           if(v.length > 1) stack.push(v, 1);
          }
          else if(caml_is_ml_bytes(v)){
           if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
            caml_failwith
             ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
           if(memo(v)) return;
           var len = caml_ml_bytes_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0A, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_bytes_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(caml_is_ml_string(v)){
           if(memo(v)) return;
           var len = caml_ml_string_length(v);
           if(len < 0x20)
            writer.write(8, 0x20 + len);
           else if(len < 0x100)
            writer.write_code(8, 0x09, len);
           else
            writer.write_code(32, 0x0A, len);
           for(var i = 0; i < len; i++)
            writer.write(8, caml_string_unsafe_get(v, i));
           writer.size_32 += 1 + ((len + 4) / 4 | 0);
           writer.size_64 += 1 + ((len + 8) / 8 | 0);
          }
          else if(v != (v | 0)){
           var type_of_v = typeof v;
           caml_failwith("output_value: abstract value (" + type_of_v + ")");
          }
          else if(v >= 0 && v < 0x40)
           writer.write(8, 0X40 + v);
          else if(v >= - (1 << 7) && v < 1 << 7)
           writer.write_code(8, 0x00, v);
          else if(v >= - (1 << 15) && v < 1 << 15)
           writer.write_code(16, 0x01, v);
          else
           writer.write_code(32, 0x02, v);
         }
         extern_rec(v);
         while(stack.length > 0){
          var i = stack.pop(), v = stack.pop();
          if(i + 1 < v.length) stack.push(v, i + 1);
          extern_rec(v[i]);
         }
         if(intern_obj_table)
          writer.obj_counter = intern_obj_table.objs.length;
         writer.finalize();
         return writer.chunk;};
       }
       ();
   function caml_output_value_to_string(v, flags){
    return caml_string_of_array(caml_output_val(v, flags));
   }
   function caml_raise_not_a_dir(name){
    caml_raise_sys_error(name + ": Not a directory");
   }
   function caml_sys_system_command(cmd){
    var cmd = caml_jsstring_of_string(cmd);
    if(typeof require != "undefined"){
     var child_process = require("child_process");
     if(child_process && child_process.execSync)
      try{child_process.execSync(cmd, {stdio: "inherit"}); return 0;}
      catch(e){return 1;}
    }
    else
     return 127;
   }
   function caml_js_error_of_exception(exn){
    if(exn.js_error) return exn.js_error;
    return null;
   }
   function caml_unix_getuid(unit){
    if(globalThis.process && globalThis.process.getuid)
     return globalThis.process.getuid();
    caml_raise_not_found();
   }
   function deserialize_nat(reader, sz){
    var len = reader.read32s(), nat = new MlNat(len);
    for(var i = 0; i < len; i++) nat.data[i] = reader.read32s();
    sz[0] = len * 4;
    return nat;
   }
   function initialize_nat(){
    caml_custom_ops["_nat"] =
     {deserialize: deserialize_nat,
      serialize: serialize_nat,
      hash: caml_hash_nat};
   }
   function caml_bytes_of_utf16_jsstring(s){
    var tag = 9;
    if(! jsoo_is_ascii(s)) tag = 8, s = caml_utf8_of_utf16(s);
    return new MlBytes(tag, s, s.length);
   }
   function bigstring_memcmp_stub(v_s1, v_s1_pos, v_s2, v_s2_pos, v_len){
    for(var i = 0; i < v_len; i++){
     var
      a = caml_ba_get_1(v_s1, v_s1_pos + i),
      b = caml_ba_get_1(v_s2, v_s2_pos + i);
     if(a < b) return - 1;
     if(a > b) return 1;
    }
    return 0;
   }
   function caml_gr_open_subwindow(a, b, c, d){
    caml_failwith("caml_gr_open_subwindow not Implemented");
   }
   function UInt8ArrayReader(s, i){this.s = s; this.i = i;}
   UInt8ArrayReader.prototype =
    {read8u: function(){return this.s[this.i++];},
     read8s: function(){return this.s[this.i++] << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s[i] << 8 | s[i + 1];
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s[i] << 24 >> 16 | s[i + 1];
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3]) >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return s[i] << 24 | s[i + 1] << 16 | s[i + 2] << 8 | s[i + 3];
     },
     readstr:
     function(len){
      var i = this.i;
      this.i = i + len;
      return caml_string_of_array(this.s.subarray(i, i + len));
     },
     readuint8array:
     function(len){
      var i = this.i;
      this.i = i + len;
      return this.s.subarray(i, i + len);
     }};
   function caml_marshal_data_size(s, ofs){
    var r = new UInt8ArrayReader(caml_uint8_array_of_bytes(s), ofs);
    function readvlq(overflow){
     var c = r.read8u(), n = c & 0x7F;
     while((c & 0x80) != 0){
      c = r.read8u();
      var n7 = n << 7;
      if(n != n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7F;
     }
     return n;
    }
    switch(r.read32u()){
      case 0x8495A6BE:
       var header_len = 20, data_len = r.read32u(); break;
      case 0x8495A6BD:
       var
        header_len = r.read8u() & 0x3F,
        overflow = [false],
        data_len = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("Marshal.data_size: object too large to be read back on this platform");
       break;
      case 0x8495A6BF:
      default: caml_failwith("Marshal.data_size: bad object"); break;
    }
    return header_len - caml_marshal_header_size + data_len;
   }
   function MlStringReader(s, i){
    this.s = caml_jsbytes_of_string(s);
    this.i = i;
   }
   MlStringReader.prototype =
    {read8u: function(){return this.s.charCodeAt(this.i++);},
     read8s: function(){return this.s.charCodeAt(this.i++) << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1);
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1);
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
             | s.charCodeAt(i + 2) << 8
             | s.charCodeAt(i + 3))
             >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return s.charCodeAt(i) << 24 | s.charCodeAt(i + 1) << 16
             | s.charCodeAt(i + 2) << 8
             | s.charCodeAt(i + 3);
     },
     readstr:
     function(len){
      var i = this.i;
      this.i = i + len;
      return caml_string_of_jsbytes(this.s.substring(i, i + len));
     },
     readuint8array:
     function(len){
      var b = new Uint8Array(len), s = this.s, i = this.i;
      for(var j = 0; j < len; j++) b[j] = s.charCodeAt(i + j);
      this.i = i + len;
      return b;
     }};
   var caml_decompress_input = null;
   function caml_float_of_bytes(a){
    return caml_int64_float_of_bits(caml_int64_of_bytes(a));
   }
   function caml_input_value_from_reader(reader, ofs){
    function readvlq(overflow){
     var c = reader.read8u(), n = c & 0x7F;
     while((c & 0x80) != 0){
      c = reader.read8u();
      var n7 = n << 7;
      if(n != n7 >> 7) overflow[0] = true;
      n = n7 | c & 0x7F;
     }
     return n;
    }
    var magic = reader.read32u();
    switch(magic){
      case 0x8495A6BE:
       var
        header_len = 20,
        compressed = 0,
        data_len = reader.read32u(),
        uncompressed_data_len = data_len,
        num_objects = reader.read32u(),
        _size_32 = reader.read32u(),
        _size_64 = reader.read32u();
       break;
      case 0x8495A6BD:
       var
        header_len = reader.read8u() & 0x3F,
        compressed = 1,
        overflow = [false],
        data_len = readvlq(overflow),
        uncompressed_data_len = readvlq(overflow),
        num_objects = readvlq(overflow),
        _size_32 = readvlq(overflow),
        _size_64 = readvlq(overflow);
       if(overflow[0])
        caml_failwith
         ("caml_input_value_from_reader: object too large to be read back on this platform");
       break;
      case 0x8495A6BF:
       caml_failwith
        ("caml_input_value_from_reader: object too large to be read back on a 32-bit platform");
       break;
      default:
       caml_failwith("caml_input_value_from_reader: bad object"); break;
    }
    var
     stack = [],
     intern_obj_table = num_objects > 0 ? [] : null,
     obj_counter = 0;
    function intern_rec(reader){
     var code = reader.read8u();
     if(code >= 0x40)
      if(code >= 0x80){
       var tag = code & 0xF, size = code >> 4 & 0x7, v = [tag];
       if(size == 0) return v;
       if(intern_obj_table) intern_obj_table[obj_counter++] = v;
       stack.push(v, size);
       return v;
      }
      else
       return code & 0x3F;
     else if(code >= 0x20){
      var len = code & 0x1F, v = reader.readstr(len);
      if(intern_obj_table) intern_obj_table[obj_counter++] = v;
      return v;
     }
     else
      switch(code){
        case 0x00:
         return reader.read8s();
        case 0x01:
         return reader.read16s();
        case 0x02:
         return reader.read32s();
        case 0x03:
         caml_failwith("input_value: integer too large"); break;
        case 0x04:
         var offset = reader.read8u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x05:
         var offset = reader.read16u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x06:
         var offset = reader.read32u();
         if(compressed == 0) offset = obj_counter - offset;
         return intern_obj_table[offset];
        case 0x08:
         var
          header = reader.read32u(),
          tag = header & 0xFF,
          size = header >> 10,
          v = [tag];
         if(size == 0) return v;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         stack.push(v, size);
         return v;
        case 0x13:
         caml_failwith("input_value: data block too large"); break;
        case 0x09:
         var len = reader.read8u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0A:
         var len = reader.read32u(), v = reader.readstr(len);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0C:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[7 - i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0B:
         var t = new Array(8);
         for(var i = 0; i < 8; i++) t[i] = reader.read8u();
         var v = caml_float_of_bytes(t);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        case 0x0E:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0D:
         var len = reader.read8u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x07:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[7 - j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x0F:
         var len = reader.read32u(), v = new Array(len + 1);
         v[0] = 254;
         var t = new Array(8);
         for(var i = 1; i <= len; i++){
          for(var j = 0; j < 8; j++) t[j] = reader.read8u();
          v[i] = caml_float_of_bytes(t);
         }
         return v;
        case 0x10:
        case 0x11:
         caml_failwith("input_value: code pointer"); break;
        case 0x12:
        case 0x18:
        case 0x19:
         var c, s = "";
         while((c = reader.read8u()) != 0) s += String.fromCharCode(c);
         var ops = caml_custom_ops[s], expected_size;
         if(! ops)
          caml_failwith("input_value: unknown custom block identifier");
         switch(code){
           case 0x12: break;
           case 0x19:
            if(! ops.fixed_length)
             caml_failwith("input_value: expected a fixed-size custom block");
            expected_size = ops.fixed_length;
            break;
           case 0x18:
            expected_size = reader.read32u();
            reader.read32s();
            reader.read32s();
            break;
         }
         var
          old_pos = reader.i,
          size = [0],
          v = ops.deserialize(reader, size);
         if(expected_size != undefined)
          if(expected_size != size[0])
           caml_failwith
            ("input_value: incorrect length of serialized custom block");
         if(intern_obj_table) intern_obj_table[obj_counter++] = v;
         return v;
        default: caml_failwith("input_value: ill-formed message");
      }
    }
    if(compressed)
     if(caml_decompress_input)
      var
       data = reader.readuint8array(data_len),
       res = new Uint8Array(uncompressed_data_len),
       res = caml_decompress_input(data, res),
       reader = new UInt8ArrayReader(res, 0);
     else
      caml_failwith("input_value: compressed object, cannot decompress");
    var res = intern_rec(reader);
    while(stack.length > 0){
     var size = stack.pop(), v = stack.pop(), d = v.length;
     if(d < size) stack.push(v, size);
     v[d] = intern_rec(reader);
    }
    if(typeof ofs != "number") ofs[0] = reader.i;
    return res;
   }
   function caml_string_of_bytes(s){
    s.t & 6 && caml_convert_string_to_bytes(s);
    return caml_string_of_jsbytes(s.c);
   }
   function caml_input_value_from_bytes(s, ofs){
    var
     reader =
       new
        MlStringReader
        (caml_string_of_bytes(s), typeof ofs == "number" ? ofs : ofs[0]);
    return caml_input_value_from_reader(reader, ofs);
   }
   function caml_input_value(chanid){
    var
     chan = caml_ml_channels[chanid],
     header = new Uint8Array(caml_marshal_header_size);
    function block(buffer, offset, n){
     var r = 0;
     while(r < n){
      if(chan.buffer_curr >= chan.buffer_max){
       chan.buffer_curr = 0;
       chan.buffer_max = 0;
       caml_refill(chan);
      }
      if(chan.buffer_curr >= chan.buffer_max) break;
      buffer[offset + r] = chan.buffer[chan.buffer_curr];
      chan.buffer_curr++;
      r++;
     }
     return r;
    }
    var r = block(header, 0, caml_marshal_header_size);
    if(r == 0)
     caml_raise_end_of_file();
    else if(r < caml_marshal_header_size)
     caml_failwith("input_value: truncated object");
    var
     len = caml_marshal_data_size(caml_bytes_of_array(header), 0),
     buf = new Uint8Array(len + caml_marshal_header_size);
    buf.set(header, 0);
    var r = block(buf, caml_marshal_header_size, len);
    if(r < len)
     caml_failwith("input_value: truncated object " + r + "  " + len);
    var
     offset = [0],
     res = caml_input_value_from_bytes(caml_bytes_of_array(buf), offset);
    chan.offset = chan.offset + offset[0];
    return res;
   }
   function caml_input_value_to_outside_heap(c){return caml_input_value(c);}
   function caml_atomic_cas(ref, o, n){
    if(ref[1] === o){ref[1] = n; return 1;}
    return 0;
   }
   function caml_copysign_float(x, y){
    if(y == 0) y = 1 / y;
    x = Math.abs(x);
    return y < 0 ? - x : x;
   }
   function caml_gr_set_text_size(size){
    var s = caml_gr_state_get();
    s.text_size = size;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_atomic_load(ref){return ref[1];}
   function caml_md5_bytes(s, ofs, len){
    var ctx = caml_MD5Init(), a = caml_uint8_array_of_bytes(s);
    caml_MD5Update(ctx, a.subarray(ofs, ofs + len), len);
    return caml_string_of_array(caml_MD5Final(ctx));
   }
   function caml_ba_set_generic(ba, i, v){
    ba.set(ba.offset(caml_js_from_array(i)), v);
    return 0;
   }
   function caml_ml_condition_wait(t, mutext){return 0;}
   function caml_string_lessequal(s1, s2){return s1 <= s2 ? 1 : 0;}
   function caml_string_greaterequal(s1, s2){return caml_string_lessequal(s2, s1);
   }
   function caml_nextafter_float(x, y){
    if(isNaN(x) || isNaN(y)) return NaN;
    if(x == y) return y;
    if(x == 0) return y < 0 ? - Math.pow(2, - 1074) : Math.pow(2, - 1074);
    var bits = caml_int64_bits_of_float(x), one = caml_int64_of_int32(1);
    if(x < y == x > 0)
     bits = caml_int64_add(bits, one);
    else
     bits = caml_int64_sub(bits, one);
    return caml_int64_float_of_bits(bits);
   }
   function caml_gr_size_y(){var s = caml_gr_state_get(); return s.height;}
   function core_gc_minor_collections(){return 0;}
   function caml_pos_in(chanid){
    var chan = caml_ml_channels[chanid];
    return chan.offset - (chan.buffer_max - chan.buffer_curr) | 0;
   }
   function caml_ml_pos_in(chanid){return caml_pos_in(chanid);}
   function caml_int64_and(x, y){return x.and(y);}
   function Base_int_math_int64_pow_stub(base, exponent){
    var
     one = caml_int64_create_lo_hi(1, 0),
     mul = [one, base, one, one],
     res = one;
    while(! caml_int64_is_zero(exponent)){
     mul[1] = caml_int64_mul(mul[1], mul[3]);
     mul[2] = caml_int64_mul(mul[1], mul[1]);
     mul[3] = caml_int64_mul(mul[2], mul[1]);
     res = caml_int64_mul(res, mul[caml_int64_lo32(exponent) & 3]);
     exponent = caml_int64_shift_right_unsigned(exponent, 2);
    }
    return res;
   }
   function caml_sys_const_word_size(){return 32;}
   function caml_runtime_events_pause(){return 0;}
   function caml_unix_unlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.unlink)
     caml_failwith("caml_unix_unlink: not implemented");
    return root.device.unlink(root.rest, true);
   }
   function caml_string_get(s, i){
    if(i >>> 0 >= caml_ml_string_length(s)) caml_string_bound_error();
    return caml_string_unsafe_get(s, i);
   }
   var
    re_match =
      function(){
        var
         re_word_letters =
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
         opcodes =
           {CHAR: 0,
            CHARNORM: 1,
            STRING: 2,
            STRINGNORM: 3,
            CHARCLASS: 4,
            BOL: 5,
            EOL: 6,
            WORDBOUNDARY: 7,
            BEGGROUP: 8,
            ENDGROUP: 9,
            REFGROUP: 10,
            ACCEPT: 11,
            SIMPLEOPT: 12,
            SIMPLESTAR: 13,
            SIMPLEPLUS: 14,
            GOTO: 15,
            PUSHBACK: 16,
            SETMARK: 17,
            CHECKPROGRESS: 18};
        function is_word_letter(c){
         return re_word_letters[c >> 3] >> (c & 7) & 1;
        }
        function in_bitset(s, i){
         return caml_string_get(s, i >> 3) >> (i & 7) & 1;
        }
        function re_match_impl(re, s, pos, partial){
         var
          prog = caml_js_from_array(re[1]),
          cpool = caml_js_from_array(re[2]),
          normtable = caml_jsbytes_of_string(re[3]),
          numgroups = re[4] | 0,
          numregisters = re[5] | 0,
          startchars = re[6] | 0,
          s = caml_uint8_array_of_string(s),
          pc = 0,
          quit = false,
          stack = [],
          groups = new Array(numgroups),
          re_register = new Array(numregisters);
         for(var i = 0; i < groups.length; i++)
          groups[i] = {start: - 1, end: - 1};
         groups[0].start = pos;
         function backtrack(){
          while(stack.length){
           var item = stack.pop();
           if(item.undo)
            item.undo.obj[item.undo.prop] = item.undo.value;
           else if(item.pos){pc = item.pos.pc; pos = item.pos.txt; return;}
          }
          quit = true;
         }
         function push(item){stack.push(item);}
         function accept(){
          groups[0].end = pos;
          var result = new Array(1 + groups.length * 2);
          result[0] = 0;
          for(var i = 0; i < groups.length; i++){
           var g = groups[i];
           if(g.start < 0 || g.end < 0) g.start = g.end = - 1;
           result[2 * i + 1] = g.start;
           result[2 * i + 1 + 1] = g.end;
          }
          return result;
         }
         function prefix_match(){
          if(partial) return accept(); else backtrack();
         }
         while(! quit){
          var
           op = prog[pc] & 0xff,
           sarg = prog[pc] >> 8,
           uarg = sarg & 0xff,
           c = s[pos],
           group;
          pc++;
          switch(op){
            case opcodes.CHAR:
             if(pos === s.length){prefix_match(); break;}
             if(c === uarg) pos++; else backtrack();
             break;
            case opcodes.CHARNORM:
             if(pos === s.length){prefix_match(); break;}
             if(normtable.charCodeAt(c) === uarg) pos++; else backtrack();
             break;
            case opcodes.STRING:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(c === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.STRINGNORM:
             for
             (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0;
              i < arg.length;
              i++){
              if(pos === s.length){prefix_match(); break;}
              if(normtable.charCodeAt(c) === arg.charCodeAt(i))
               c = s[++pos];
              else{backtrack(); break;}
             }
             break;
            case opcodes.CHARCLASS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c)) pos++; else backtrack();
             break;
            case opcodes.BOL:
             if(pos > 0 && s[pos - 1] != 10) backtrack(); break;
            case opcodes.EOL:
             if(pos < s.length && s[pos] != 10) backtrack(); break;
            case opcodes.WORDBOUNDARY:
             if(pos == 0){
              if(pos === s.length){prefix_match(); break;}
              if(is_word_letter(s[0])) break;
              backtrack();
             }
             else if(pos === s.length){
              if(is_word_letter(s[pos - 1])) break;
              backtrack();
             }
             else{
              if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos])) break;
              backtrack();
             }
             break;
            case opcodes.BEGGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "start", value: group.start}});
             group.start = pos;
             break;
            case opcodes.ENDGROUP:
             group = groups[uarg];
             push({undo: {obj: group, prop: "end", value: group.end}});
             group.end = pos;
             break;
            case opcodes.REFGROUP:
             group = groups[uarg];
             if(group.start < 0 || group.end < 0){backtrack(); break;}
             for(var i = group.start; i < group.end; i++){
              if(pos === s.length){prefix_match(); break;}
              if(s[i] != s[pos]){backtrack(); break;}
              pos++;
             }
             break;
            case opcodes.SIMPLEOPT:
             if(in_bitset(cpool[uarg], c)) pos++; break;
            case opcodes.SIMPLESTAR:
             while(in_bitset(cpool[uarg], c)) c = s[++pos]; break;
            case opcodes.SIMPLEPLUS:
             if(pos === s.length){prefix_match(); break;}
             if(in_bitset(cpool[uarg], c))
              do c = s[++pos];while(in_bitset(cpool[uarg], c));
             else
              backtrack();
             break;
            case opcodes.ACCEPT: return accept();
            case opcodes.GOTO:
             pc = pc + sarg; break;
            case opcodes.PUSHBACK:
             push({pos: {pc: pc + sarg, txt: pos}}); break;
            case opcodes.SETMARK:
             push
              ({undo: {obj: re_register, prop: uarg, value: re_register[uarg]}});
             re_register[uarg] = pos;
             break;
            case opcodes.CHECKPROGRESS:
             if(re_register[uarg] === pos) backtrack(); break;
            default: throw new Error("Invalid bytecode");
          }
         }
         return 0;
        }
        return re_match_impl;
       }
       ();
   function re_search_backward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_backward");
    while(pos >= 0){
     var res = re_match(re, s, pos, 0);
     if(res) return res;
     pos--;
    }
    return [0];
   }
   function caml_js_from_string(s){return caml_jsstring_of_string(s);}
   function caml_ml_output_ta(chanid, buffer, offset, len){
    var chan = caml_ml_channels[chanid];
    if(! chan.opened)
     caml_raise_sys_error("Cannot output to a closed channel");
    buffer = buffer.subarray(offset, offset + len);
    if(chan.buffer_curr + buffer.length > chan.buffer.length){
     var b = new Uint8Array(chan.buffer_curr + buffer.length);
     b.set(chan.buffer);
     chan.buffer = b;
    }
    switch(chan.buffered){
      case 0:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       caml_ml_flush(chanid);
       break;
      case 1:
       chan.buffer.set(buffer, chan.buffer_curr);
       chan.buffer_curr += buffer.length;
       if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       break;
      case 2:
       var id = buffer.lastIndexOf(10);
       if(id < 0){
        chan.buffer.set(buffer, chan.buffer_curr);
        chan.buffer_curr += buffer.length;
        if(chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);
       }
       else{
        chan.buffer.set(buffer.subarray(0, id + 1), chan.buffer_curr);
        chan.buffer_curr += id + 1;
        caml_ml_flush(chanid);
        chan.buffer.set(buffer.subarray(id + 1), chan.buffer_curr);
        chan.buffer_curr += buffer.length - id - 1;
       }
       break;
    }
    return 0;
   }
   function caml_ba_sub(ba, ofs, len){
    var changed_dim, mul = 1;
    if(ba.layout == 0){
     for(var i = 1; i < ba.dims.length; i++) mul = mul * ba.dims[i];
     changed_dim = 0;
    }
    else{
     for(var i = 0; i < ba.dims.length - 1; i++) mul = mul * ba.dims[i];
     changed_dim = ba.dims.length - 1;
     ofs = ofs - 1;
    }
    if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
     caml_invalid_argument("Bigarray.sub: bad sub-array");
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++) new_dims[i] = ba.dims[i];
    new_dims[changed_dim] = len;
    mul *= caml_ba_get_size_per_element(ba.kind);
    var new_data = ba.data.subarray(ofs * mul, (ofs + len) * mul);
    return caml_ba_create_unsafe(ba.kind, ba.layout, new_dims, new_data);
   }
   function core_gc_compactions(){return 0;}
   function caml_gc_full_major(unit){
    if(typeof globalThis.gc == "function") globalThis.gc();
    return 0;
   }
   function caml_ml_mutex_try_lock(t){
    if(! t.locked){t.locked = true; return 1;}
    return 0;
   }
   function caml_bytes_set32(s, i, i32){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b4 = 0xFF & i32 >> 24,
     b3 = 0xFF & i32 >> 16,
     b2 = 0xFF & i32 >> 8,
     b1 = 0xFF & i32;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    caml_bytes_unsafe_set(s, i + 2, b3);
    caml_bytes_unsafe_set(s, i + 3, b4);
    return 0;
   }
   function caml_gr_sigio_signal(){return 0;}
   function caml_ba_uint8_set32(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 3 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    ba.set(ofs + 2, v >>> 16 & 0xff);
    ba.set(ofs + 3, v >>> 24 & 0xff);
    return 0;
   }
   function caml_sys_const_ostype_unix(){return os_type == "Unix" ? 1 : 0;}
   function caml_unix_gmtime(t){
    var
     d = new Date(t * 1000),
     d_num = d.getTime(),
     januaryfirst = new Date(Date.UTC(d.getUTCFullYear(), 0, 1)).getTime(),
     doy = Math.floor((d_num - januaryfirst) / 86400000);
    return [0,
            d.getUTCSeconds(),
            d.getUTCMinutes(),
            d.getUTCHours(),
            d.getUTCDate(),
            d.getUTCMonth(),
            d.getUTCFullYear() - 1900,
            d.getUTCDay(),
            doy,
            false | 0];
   }
   function caml_signbit_float(x){if(x == 0) x = 1 / x; return x < 0 ? 1 : 0;}
   function caml_gr_current_x(){var s = caml_gr_state_get(); return s.x;}
   function caml_gr_set_line_width(w){
    var s = caml_gr_state_get();
    s.line_width = w;
    s.context.lineWidth = w;
    return 0;
   }
   function caml_gr_set_font(f){
    var s = caml_gr_state_get();
    s.font = f;
    s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
    return 0;
   }
   function caml_gr_set_color(color){
    var s = caml_gr_state_get();
    function convert(number){
     var str = "" + number.toString(16);
     while(str.length < 2) str = "0" + str;
     return str;
    }
    var r = color >> 16 & 0xff, g = color >> 8 & 0xff, b = color >> 0 & 0xff;
    s.color = color;
    var c_str = "#" + convert(r) + convert(g) + convert(b);
    s.context.fillStyle = c_str;
    s.context.strokeStyle = c_str;
    return 0;
   }
   function caml_gr_moveto(x, y){
    var s = caml_gr_state_get();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_gr_resize_window(w, h){
    var s = caml_gr_state_get();
    s.width = w;
    s.height = h;
    s.canvas.width = w;
    s.canvas.height = h;
    return 0;
   }
   function caml_gr_state_init(){
    caml_gr_moveto(caml_gr_state.x, caml_gr_state.y);
    caml_gr_resize_window(caml_gr_state.width, caml_gr_state.height);
    caml_gr_set_line_width(caml_gr_state.line_width);
    caml_gr_set_text_size(caml_gr_state.text_size);
    caml_gr_set_font(caml_gr_state.font);
    caml_gr_set_color(caml_gr_state.color);
    caml_gr_set_window_title(caml_gr_state.title);
    caml_gr_state.context.textBaseline = "bottom";
   }
   function caml_ba_kind_of_typed_array(ta){
    var kind;
    if(ta instanceof Float32Array)
     kind = 0;
    else if(ta instanceof Float64Array)
     kind = 1;
    else if(ta instanceof Int8Array)
     kind = 2;
    else if(ta instanceof Uint8Array)
     kind = 3;
    else if(ta instanceof Uint8ClampedArray)
     kind = 3;
    else if(ta instanceof Int16Array)
     kind = 4;
    else if(ta instanceof Uint16Array)
     kind = 5;
    else if(ta instanceof Int32Array)
     kind = 6;
    else if(ta instanceof Uint32Array)
     kind = 6;
    else
     caml_invalid_argument("caml_ba_kind_of_typed_array: unsupported kind");
    return kind;
   }
   function caml_ba_from_typed_array(ta){
    var
     kind = caml_ba_kind_of_typed_array(ta),
     ta =
       ta instanceof Uint32Array
        ? new Int32Array(ta.buffer, ta.byteOffset, ta.length)
        : ta;
    return caml_ba_create_unsafe(kind, 0, [ta.length], ta);
   }
   function time_now_nanosecond_counter_for_timing(){
    var
     ms_since_program_started = performance.now(),
     ns_since_program_started = ms_float_to_ns_int64(ms_since_program_started);
    return caml_int64_shift_left(ns_since_program_started, 1);
   }
   function caml_ml_seek_out(chanid, pos){return caml_seek_out(chanid, pos);}
   function caml_js_typeof(o){return typeof o;}
   function caml_string_hash(h, v){
    var h = caml_hash_mix_string(h, v), h = caml_hash_mix_final(h);
    return h & 0x3FFFFFFF;
   }
   function caml_restore_raw_backtrace(exn, bt){return 0;}
   function Base_int_math_int32_ctz(x){
    if(x === 0) return 32;
    var n = 1;
    if((x & 0x0000FFFF) === 0){n = n + 16; x = x >> 16;}
    if((x & 0x000000FF) === 0){n = n + 8; x = x >> 8;}
    if((x & 0x0000000F) === 0){n = n + 4; x = x >> 4;}
    if((x & 0x00000003) === 0){n = n + 2; x = x >> 2;}
    return n - (x & 1);
   }
   function Base_int_math_nativeint_ctz(x){return Base_int_math_int32_ctz(x);}
   function caml_gr_lineto(x, y){
    var s = caml_gr_state_get();
    s.context.beginPath();
    s.context.moveTo(s.x, s.height - s.y);
    s.context.lineTo(x, s.height - y);
    s.context.stroke();
    s.x = x;
    s.y = y;
    return 0;
   }
   function caml_js_function_arity(f){return f.l >= 0 ? f.l : f.l = f.length;}
   function caml_js_wrap_meth_callback_unsafe(f){
    return function(){
     var len = caml_js_function_arity(f) - 1, args = new Array(len + 1);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_ba_dim_3(ba){return caml_ba_dim(ba, 2);}
   function ppx_expect_runtime_after_test(vstdout, vstderr){
    caml_ml_channels[vstdout] = ppx_expect_runtime_saved_stdout;
    caml_ml_channels[vstderr] = ppx_expect_runtime_saved_stderr;
    return 0;
   }
   function caml_is_special_exception(exn){
    switch(exn[2]){case - 8:case - 11:case - 12: return 1;default: return 0;
    }
   }
   function caml_format_exception(exn){
    var r = "";
    if(exn[0] == 0){
     r += exn[1][1];
     if
      (exn.length == 3 && exn[2][0] == 0 && caml_is_special_exception(exn[1]))
      var bucket = exn[2], start = 1;
     else
      var start = 2, bucket = exn;
     r += "(";
     for(var i = start; i < bucket.length; i++){
      if(i > start) r += ", ";
      var v = bucket[i];
      if(typeof v == "number")
       r += v.toString();
      else if(v instanceof MlBytes)
       r += '"' + v.toString() + '"';
      else if(typeof v == "string")
       r += '"' + v.toString() + '"';
      else
       r += "_";
     }
     r += ")";
    }
    else if(exn[0] == 248) r += exn[1];
    return r;
   }
   function caml_fatal_uncaught_exception(err){
    if(err instanceof Array && (err[0] == 0 || err[0] == 248)){
     var handler = caml_named_value("Printexc.handle_uncaught_exception");
     if(handler)
      caml_callback(handler, [err, false]);
     else{
      var
       msg = caml_format_exception(err),
       at_exit = caml_named_value("Pervasives.do_at_exit");
      if(at_exit) caml_callback(at_exit, [0]);
      console.error("Fatal error: exception " + msg);
      if(err.js_error) throw err.js_error;
     }
    }
    else
     throw err;
   }
   function caml_ephe_check_data(x){
    return x[caml_ephe_data_offset] === undefined ? 0 : 1;
   }
   function caml_bytes_get16(s, i){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function caml_obj_make_forward(b, v){b[0] = 250; b[1] = v; return 0;}
   function caml_js_from_bool(x){return ! ! x;}
   function caml_ml_set_channel_name(chanid, name){
    var chan = caml_ml_channels[chanid];
    chan.name = name;
    return 0;
   }
   function caml_exp2_float(x){return Math.pow(2, x);}
   function caml_gr_close_graph(){
    var s = caml_gr_state_get();
    s.canvas.width = 0;
    s.canvas.height = 0;
    return 0;
   }
   function bigstring_memcmp_bytes_stub(v_s1, v_s1_pos, v_s2, v_s2_pos, v_len){
    for(var i = 0; i < v_len; i++){
     var
      a = caml_ba_get_1(v_s1, v_s1_pos + i),
      b = caml_bytes_get(v_s2, v_s2_pos + i);
     if(a < b) return - 1;
     if(a > b) return 1;
    }
    return 0;
   }
   var Base_internalhash_fold_int = caml_hash_mix_int;
   function caml_ml_domain_cpu_relax(unit){return 0;}
   function caml_create_string(len){caml_invalid_argument("String.create");}
   function Base_int_math_nativeint_clz(x){return Base_int_math_int32_clz(x);}
   function bigstring_memset_stub(bigstring, v_pos, v_len, v_char){
    for(var i = 0; i < v_len; i++)
     caml_ba_set_1(bigstring, v_pos + i, v_char);
   }
   function caml_atanh_float(x){return Math.atanh(x);}
   function caml_ml_condition_signal(t){return 0;}
   function caml_unix_findnext(dir_handle){return caml_unix_readdir(dir_handle);
   }
   function caml_ml_output_bytes(chanid, buffer, offset, len){
    var buffer = caml_uint8_array_of_bytes(buffer);
    return caml_ml_output_ta(chanid, buffer, offset, len);
   }
   function caml_ml_output(chanid, buffer, offset, len){
    return caml_ml_output_bytes
            (chanid, caml_bytes_of_string(buffer), offset, len);
   }
   function caml_ml_domain_id(unit){return caml_domain_id;}
   function caml_ephe_get_data(x){
    return x[caml_ephe_data_offset] === undefined
            ? 0
            : [0, x[caml_ephe_data_offset]];
   }
   function caml_xmlhttprequest_create(unit){
    if(typeof globalThis.XMLHttpRequest !== "undefined")
     try{return new globalThis.XMLHttpRequest;}catch(e){}
    if(typeof globalThis.activeXObject !== "undefined"){
     try{return new globalThis.activeXObject("Msxml2.XMLHTTP");}catch(e){}
     try{return new globalThis.activeXObject("Msxml3.XMLHTTP");}catch(e){}
     try{return new globalThis.activeXObject("Microsoft.XMLHTTP");}catch(e){}
    }
    caml_failwith("Cannot create a XMLHttpRequest");
   }
   function caml_trampoline_return(f, args){return {joo_tramp: f, joo_args: args};
   }
   function caml_ml_is_buffered(chanid){
    return caml_ml_channels[chanid].buffered ? 1 : 0;
   }
   function caml_hash_mix_bigstring(h, bs){
    return caml_hash_mix_bytes_arr(h, bs.data);
   }
   var internalhash_fold_bigstring = caml_hash_mix_bigstring;
   function Base_int_math_int64_clz(x){
    var n = 64, y;
    y = caml_int64_shift_right_unsigned(x, 32);
    if(! caml_int64_is_zero(y)){n = n - 32; x = y;}
    y = caml_int64_shift_right_unsigned(x, 16);
    if(! caml_int64_is_zero(y)){n = n - 16; x = y;}
    y = caml_int64_shift_right_unsigned(x, 8);
    if(! caml_int64_is_zero(y)){n = n - 8; x = y;}
    y = caml_int64_shift_right_unsigned(x, 4);
    if(! caml_int64_is_zero(y)){n = n - 4; x = y;}
    y = caml_int64_shift_right_unsigned(x, 2);
    if(! caml_int64_is_zero(y)){n = n - 2; x = y;}
    y = caml_int64_shift_right_unsigned(x, 1);
    if(! caml_int64_is_zero(y)) return n - 2;
    return n - caml_int64_to_int32(x);
   }
   function caml_array_append(a1, a2){
    var l1 = a1.length, l2 = a2.length, l = l1 + l2 - 1, a = new Array(l);
    a[0] = 0;
    var i = 1, j = 1;
    for(; i < l1; i++) a[i] = a1[i];
    for(; i < l; i++, j++) a[i] = a2[j];
    return a;
   }
   function caml_unix_gettimeofday(){return new Date().getTime() / 1000;}
   function caml_unix_time(){return Math.floor(caml_unix_gettimeofday());}
   function timezone_js_loader_get_next_transition_or_this_time_if_none
   (zone, instant){
    var ret = zone.getNextTransition(instant);
    return ret ? ret : instant;
   }
   function caml_ml_set_channel_refill(chanid, f){
    caml_ml_channels[chanid].refill = f;
    return 0;
   }
   function caml_runtime_events_create_cursor(target){return {};}
   function caml_fill_bytes(s, i, l, c){
    if(l > 0)
     if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
      if(c == 0){
       s.c = "";
       s.t = 2;
      }
      else{
       s.c = caml_str_repeat(l, String.fromCharCode(c));
       s.t = l == s.l ? 0 : 2;
      }
     else{
      if(s.t != 4) caml_convert_bytes_to_array(s);
      for(l += i; i < l; i++) s.c[i] = c;
     }
    return 0;
   }
   function caml_js_expr(s){
    console.error("caml_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_ml_runtime_warnings_enabled(_unit){return caml_runtime_warnings;
   }
   function core_gc_run_memprof_callbacks(){return 0;}
   function caml_output_value_to_bytes(v, flags){
    return caml_bytes_of_array(caml_output_val(v, flags));
   }
   function caml_eventlog_resume(unit){return 0;}
   function caml_md5_string(s, ofs, len){
    return caml_md5_bytes(caml_bytes_of_string(s), ofs, len);
   }
   function caml_array_of_string(x){return caml_uint8_array_of_string(x);}
   function caml_string_equal(s1, s2){if(s1 === s2) return 1; return 0;}
   function caml_jsoo_flags_use_js_string(unit){return 1;}
   var
    zstd_decompress =
      function(){
        "use strict";
        var
         ab = ArrayBuffer,
         u8 = Uint8Array,
         u16 = Uint16Array,
         i16 = Int16Array,
         u32 = Uint32Array,
         i32 = Int32Array;
        function slc(v, s, e){
         if(u8.prototype.slice) return u8.prototype.slice.call(v, s, e);
         if(s == null || s < 0) s = 0;
         if(e == null || e > v.length) e = v.length;
         var n = new u8(e - s);
         n.set(v.subarray(s, e));
         return n;
        }
        function fill(v, n, s, e){
         if(u8.prototype.fill) return u8.prototype.fill.call(v, n, s, e);
         if(s == null || s < 0) s = 0;
         if(e == null || e > v.length) e = v.length;
         for(; s < e; ++s) v[s] = n;
         return v;
        }
        function cpw(v, t, s, e){
         if(u8.prototype.copyWithin)
          return u8.prototype.copyWithin.call(v, t, s, e);
         if(s == null || s < 0) s = 0;
         if(e == null || e > v.length) e = v.length;
         while(s < e) v[t++] = v[s++];
        }
        var
         ec =
           ["invalid zstd data",
            "window size too large (>2046MB)",
            "invalid block type",
            "FSE accuracy too high",
            "match distance too far back",
            "unexpected EOF"];
        function err(ind, msg, nt){
         var e = new Error(msg || ec[ind]);
         e.code = ind;
         if(! nt) throw e;
         return e;
        }
        function rb(d, b, n){
         var i = 0, o = 0;
         for(; i < n; ++i) o |= d[b++] << (i << 3);
         return o;
        }
        function b4(d, b){
         return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
        }
        function rzfh(dat, w){
         var n3 = dat[0] | dat[1] << 8 | dat[2] << 16;
         if(n3 == 0x2FB528 && dat[3] == 253){
          var
           flg = dat[4],
           ss = flg >> 5 & 1,
           cc = flg >> 2 & 1,
           df = flg & 3,
           fcf = flg >> 6;
          if(flg & 8) err(0);
          var bt = 6 - ss, db = df == 3 ? 4 : df, di = rb(dat, bt, db);
          bt += db;
          var
           fsb = fcf ? 1 << fcf : ss,
           fss = rb(dat, bt, fsb) + (fcf == 1 && 256),
           ws = fss;
          if(! ss){
           var wb = 1 << 10 + (dat[5] >> 3);
           ws = wb + (wb >> 3) * (dat[5] & 7);
          }
          if(ws > 2145386496) err(1);
          var buf = new u8((w == 1 ? fss || ws : w ? 0 : ws) + 12);
          buf[0] = 1, buf[4] = 4, buf[8] = 8;
          return {b: bt + fsb,
                  y: 0,
                  l: 0,
                  d: di,
                  w: w && w != 1 ? w : buf.subarray(12),
                  e: ws,
                  o: new i32(buf.buffer, 0, 3),
                  u: fss,
                  c: cc,
                  m: Math.min(131072, ws)};
         }
         else if((n3 >> 4 | dat[3] << 20) == 0x184D2A5) return b4(dat, 4) + 8;
         err(0);
        }
        function msb(val){
         var bits = 0;
         for(; 1 << bits <= val; ++bits) ;
         return bits - 1;
        }
        function rfse(dat, bt, mal){
         var tpos = (bt << 3) + 4, al = (dat[bt] & 15) + 5;
         if(al > mal) err(3);
         var
          sz = 1 << al,
          probs = sz,
          sym = - 1,
          re = - 1,
          i = - 1,
          ht = sz,
          buf = new ab(512 + (sz << 2)),
          freq = new i16(buf, 0, 256),
          dstate = new u16(buf, 0, 256),
          nstate = new u16(buf, 512, sz),
          bb1 = 512 + (sz << 1),
          syms = new u8(buf, bb1, sz),
          nbits = new u8(buf, bb1 + sz);
         while(sym < 255 && probs > 0){
          var
           bits = msb(probs + 1),
           cbt = tpos >> 3,
           msk = (1 << bits + 1) - 1,
           val =
             (dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (tpos & 7)
             & msk,
           msk1fb = (1 << bits) - 1,
           msv = msk - probs - 1,
           sval = val & msk1fb;
          if(sval < msv)
           tpos += bits, val = sval;
          else{tpos += bits + 1; if(val > msk1fb) val -= msv;}
          freq[++sym] = --val;
          if(val == - 1){probs += val; syms[--ht] = sym;} else probs -= val;
          if(! val)
           do{
            var rbt = tpos >> 3;
            re = (dat[rbt] | dat[rbt + 1] << 8) >> (tpos & 7) & 3;
            tpos += 2;
            sym += re;
           }
           while
            (re == 3);
         }
         if(sym > 255 || probs) err(0);
         var sympos = 0, sstep = (sz >> 1) + (sz >> 3) + 3, smask = sz - 1;
         for(var s = 0; s <= sym; ++s){
          var sf = freq[s];
          if(sf < 1){dstate[s] = - sf; continue;}
          for(i = 0; i < sf; ++i){
           syms[sympos] = s;
           do sympos = sympos + sstep & smask;while(sympos >= ht);
          }
         }
         if(sympos) err(0);
         for(i = 0; i < sz; ++i){
          var ns = dstate[syms[i]]++, nb = nbits[i] = al - msb(ns);
          nstate[i] = (ns << nb) - sz;
         }
         return [tpos + 7 >> 3, {b: al, s: syms, n: nbits, t: nstate}];
        }
        function rhu(dat, bt){
         var
          i = 0,
          wc = - 1,
          buf = new u8(292),
          hb = dat[bt],
          hw = buf.subarray(0, 256),
          rc = buf.subarray(256, 268),
          ri = new u16(buf.buffer, 268);
         if(hb < 128){
          var _a = rfse(dat, bt + 1, 6), ebt = _a[0], fdt = _a[1];
          bt += hb;
          var epos = ebt << 3, lb = dat[bt];
          if(! lb) err(0);
          var
           st1 = 0,
           st2 = 0,
           btr1 = fdt.b,
           btr2 = btr1,
           fpos = (++bt << 3) - 8 + msb(lb);
          for(;;){
           fpos -= btr1;
           if(fpos < epos) break;
           var cbt = fpos >> 3;
           st1 +=
            (dat[cbt] | dat[cbt + 1] << 8) >> (fpos & 7) & (1 << btr1) - 1;
           hw[++wc] = fdt.s[st1];
           fpos -= btr2;
           if(fpos < epos) break;
           cbt = fpos >> 3;
           st2 +=
            (dat[cbt] | dat[cbt + 1] << 8) >> (fpos & 7) & (1 << btr2) - 1;
           hw[++wc] = fdt.s[st2];
           btr1 = fdt.n[st1];
           st1 = fdt.t[st1];
           btr2 = fdt.n[st2];
           st2 = fdt.t[st2];
          }
          if(++wc > 255) err(0);
         }
         else{
          wc = hb - 127;
          for(; i < wc; i += 2){
           var byte = dat[++bt];
           hw[i] = byte >> 4;
           hw[i + 1] = byte & 15;
          }
          ++bt;
         }
         var wes = 0;
         for(i = 0; i < wc; ++i){
          var wt = hw[i];
          if(wt > 11) err(0);
          wes += wt && 1 << wt - 1;
         }
         var mb = msb(wes) + 1, ts = 1 << mb, rem = ts - wes;
         if(rem & rem - 1) err(0);
         hw[wc++] = msb(rem) + 1;
         for(i = 0; i < wc; ++i){
          var wt = hw[i];
          ++rc[hw[i] = wt && mb + 1 - wt];
         }
         var
          hbuf = new u8(ts << 1),
          syms = hbuf.subarray(0, ts),
          nb = hbuf.subarray(ts);
         ri[mb] = 0;
         for(i = mb; i > 0; --i){
          var pv = ri[i];
          fill(nb, i, pv, ri[i - 1] = pv + rc[i] * (1 << mb - i));
         }
         if(ri[0] != ts) err(0);
         for(i = 0; i < wc; ++i){
          var bits = hw[i];
          if(bits){
           var code = ri[bits];
           fill(syms, i, code, ri[bits] = code + (1 << mb - bits));
          }
         }
         return [bt, {n: nb, b: mb, s: syms}];
        }
        var
         dllt =
           rfse
             (new
               u8
               ([81,
                 16,
                 99,
                 140,
                 49,
                 198,
                 24,
                 99,
                 12,
                 33,
                 196,
                 24,
                 99,
                 102,
                 102,
                 134,
                 70,
                 146,
                 4]),
              0,
              6)
            [1],
         dmlt =
           rfse
             (new
               u8
               ([33,
                 20,
                 196,
                 24,
                 99,
                 140,
                 33,
                 132,
                 16,
                 66,
                 8,
                 33,
                 132,
                 16,
                 66,
                 8,
                 33,
                 68,
                 68,
                 68,
                 68,
                 68,
                 68,
                 68,
                 68,
                 36,
                 9]),
              0,
              6)
            [1],
         doct =
           rfse
             (new u8([32, 132, 16, 66, 102, 70, 68, 68, 68, 68, 36, 73, 2]),
              0,
              5)
            [1];
        function b2bl(b, s){
         var len = b.length, bl = new i32(len);
         for(var i = 0; i < len; ++i){bl[i] = s; s += 1 << b[i];}
         return bl;
        }
        var
         llb =
           new
            u8
            (new
              i32
              ([0,
                0,
                0,
                0,
                16843009,
                50528770,
                134678020,
                202050057,
                269422093]).buffer,
             0,
             36),
         llbl = b2bl(llb, 0),
         mlb =
           new
            u8
            (new
              i32
              ([0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                16843009,
                50528770,
                117769220,
                185207048,
                252579084,
                16]).buffer,
             0,
             53),
         mlbl = b2bl(mlb, 3);
        function dhu(dat, out, hu){
         var
          len = dat.length,
          ss = out.length,
          lb = dat[len - 1],
          msk = (1 << hu.b) - 1,
          eb = - hu.b;
         if(! lb) err(0);
         var
          st = 0,
          btr = hu.b,
          pos = (len << 3) - 8 + msb(lb) - btr,
          i = - 1;
         for(; pos > eb && i < ss;){
          var
           cbt = pos >> 3,
           val =
             (dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (pos & 7);
          st = (st << btr | val) & msk;
          out[++i] = hu.s[st];
          pos -= btr = hu.n[st];
         }
         if(pos != eb || i + 1 != ss) err(0);
        }
        function dhu4(dat, out, hu){
         var
          bt = 6,
          ss = out.length,
          sz1 = ss + 3 >> 2,
          sz2 = sz1 << 1,
          sz3 = sz1 + sz2;
         dhu
          (dat.subarray(bt, bt += dat[0] | dat[1] << 8),
           out.subarray(0, sz1),
           hu);
         dhu
          (dat.subarray(bt, bt += dat[2] | dat[3] << 8),
           out.subarray(sz1, sz2),
           hu);
         dhu
          (dat.subarray(bt, bt += dat[4] | dat[5] << 8),
           out.subarray(sz2, sz3),
           hu);
         dhu(dat.subarray(bt), out.subarray(sz3), hu);
        }
        function rzb(dat, st, out){
         var _a, bt = st.b, b0 = dat[bt], btype = b0 >> 1 & 3;
         st.l = b0 & 1;
         var
          sz = b0 >> 3 | dat[bt + 1] << 5 | dat[bt + 2] << 13,
          ebt = (bt += 3) + sz;
         if(btype == 1){
          if(bt >= dat.length) return;
          st.b = bt + 1;
          if(out){fill(out, dat[bt], st.y, st.y += sz); return out;}
          return fill(new u8(sz), dat[bt]);
         }
         if(ebt > dat.length) return;
         if(btype == 0){
          st.b = ebt;
          if(out){
           out.set(dat.subarray(bt, ebt), st.y);
           st.y += sz;
           return out;
          }
          return slc(dat, bt, ebt);
         }
         if(btype == 2){
          var
           b3 = dat[bt],
           lbt = b3 & 3,
           sf = b3 >> 2 & 3,
           lss = b3 >> 4,
           lcs = 0,
           s4 = 0;
          if(lbt < 2)
           if(sf & 1)
            lss |= dat[++bt] << 4 | (sf & 2 && dat[++bt] << 12);
           else
            lss = b3 >> 3;
          else{
           s4 = sf;
           if(sf < 2)
            lss |= (dat[++bt] & 63) << 4, lcs = dat[bt] >> 6 | dat[++bt] << 2;
           else if(sf == 2)
            lss |= dat[++bt] << 4 | (dat[++bt] & 3) << 12,
            lcs = dat[bt] >> 2 | dat[++bt] << 6;
           else
            lss |= dat[++bt] << 4 | (dat[++bt] & 63) << 12,
            lcs = dat[bt] >> 6 | dat[++bt] << 2 | dat[++bt] << 10;
          }
          ++bt;
          var
           buf = out ? out.subarray(st.y, st.y + st.m) : new u8(st.m),
           spl = buf.length - lss;
          if(lbt == 0)
           buf.set(dat.subarray(bt, bt += lss), spl);
          else if(lbt == 1)
           fill(buf, dat[bt++], spl);
          else{
           var hu = st.h;
           if(lbt == 2){
            var hud = rhu(dat, bt);
            lcs += bt - (bt = hud[0]);
            st.h = hu = hud[1];
           }
           else if(! hu) err(0);
           (s4 ? dhu4 : dhu)
            (dat.subarray(bt, bt += lcs), buf.subarray(spl), hu);
          }
          var ns = dat[bt++];
          if(ns){
           if(ns == 255)
            ns = (dat[bt++] | dat[bt++] << 8) + 0x7F00;
           else if(ns > 127) ns = ns - 128 << 8 | dat[bt++];
           var scm = dat[bt++];
           if(scm & 3) err(0);
           var dts = [dmlt, doct, dllt];
           for(var i = 2; i > - 1; --i){
            var md = scm >> (i << 1) + 2 & 3;
            if(md == 1){
             var rbuf = new u8([0, 0, dat[bt++]]);
             dts[i] =
              {s: rbuf.subarray(2, 3),
               n: rbuf.subarray(0, 1),
               t: new u16(rbuf.buffer, 0, 1),
               b: 0};
            }
            else if(md == 2)
             _a = rfse(dat, bt, 9 - (i & 1)), bt = _a[0], dts[i] = _a[1];
            else if(md == 3){if(! st.t) err(0); dts[i] = st.t[i];}
           }
           var
            _b = st.t = dts,
            mlt = _b[0],
            oct = _b[1],
            llt = _b[2],
            lb = dat[ebt - 1];
           if(! lb) err(0);
           var
            spos = (ebt << 3) - 8 + msb(lb) - llt.b,
            cbt = spos >> 3,
            oubt = 0,
            lst =
              (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << llt.b) - 1;
           cbt = (spos -= oct.b) >> 3;
           var
            ost =
              (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << oct.b) - 1;
           cbt = (spos -= mlt.b) >> 3;
           var
            mst =
              (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << mlt.b) - 1;
           for(++ns; --ns;){
            var
             llc = llt.s[lst],
             lbtr = llt.n[lst],
             mlc = mlt.s[mst],
             mbtr = mlt.n[mst],
             ofc = oct.s[ost],
             obtr = oct.n[ost];
            cbt = (spos -= ofc) >> 3;
            var
             ofp = 1 << ofc,
             off =
               ofp
               +
                ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16
                | dat[cbt + 3] << 24)
                >>> (spos & 7)
                & ofp - 1);
            cbt = (spos -= mlb[mlc]) >> 3;
            var
             ml =
               mlbl[mlc]
               +
                ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16)
                >> (spos & 7)
                & (1 << mlb[mlc]) - 1);
            cbt = (spos -= llb[llc]) >> 3;
            var
             ll =
               llbl[llc]
               +
                ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16)
                >> (spos & 7)
                & (1 << llb[llc]) - 1);
            cbt = (spos -= lbtr) >> 3;
            lst =
             llt.t[lst]
             +
              ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << lbtr) - 1);
            cbt = (spos -= mbtr) >> 3;
            mst =
             mlt.t[mst]
             +
              ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << mbtr) - 1);
            cbt = (spos -= obtr) >> 3;
            ost =
             oct.t[ost]
             +
              ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << obtr) - 1);
            if(off > 3){
             st.o[2] = st.o[1];
             st.o[1] = st.o[0];
             st.o[0] = off -= 3;
            }
            else{
             var idx = off - (ll != 0);
             if(idx){
              off = idx == 3 ? st.o[0] - 1 : st.o[idx];
              if(idx > 1) st.o[2] = st.o[1];
              st.o[1] = st.o[0];
              st.o[0] = off;
             }
             else
              off = st.o[0];
            }
            for(var i = 0; i < ll; ++i) buf[oubt + i] = buf[spl + i];
            oubt += ll, spl += ll;
            var stin = oubt - off;
            if(stin < 0){
             var len = - stin, bs = st.e + stin;
             if(len > ml) len = ml;
             for(var i = 0; i < len; ++i) buf[oubt + i] = st.w[bs + i];
             oubt += len, ml -= len, stin = 0;
            }
            for(var i = 0; i < ml; ++i) buf[oubt + i] = buf[stin + i];
            oubt += ml;
           }
           if(oubt != spl)
            while(spl < buf.length) buf[oubt++] = buf[spl++];
           else
            oubt = buf.length;
           if(out) st.y += oubt; else buf = slc(buf, 0, oubt);
          }
          else if(out){
           st.y += lss;
           if(spl) for(var i = 0; i < lss; ++i) buf[i] = buf[spl + i];
          }
          else if(spl) buf = slc(buf, spl);
          st.b = ebt;
          return buf;
         }
         err(2);
        }
        function cct(bufs, ol){
         if(bufs.length == 1) return bufs[0];
         var buf = new u8(ol);
         for(var i = 0, b = 0; i < bufs.length; ++i){
          var chk = bufs[i];
          buf.set(chk, b);
          b += chk.length;
         }
         return buf;
        }
        return function(dat, buf){
         var bt = 0, bufs = [], nb = + ! buf, ol = 0;
         for(; dat.length;){
          var st = rzfh(dat, nb || buf);
          if(typeof st == "object"){
           if(nb){
            buf = null;
            if(st.w.length == st.u){bufs.push(buf = st.w); ol += st.u;}
           }
           else{bufs.push(buf); st.e = 0;}
           for(; ! st.l;){
            var blk = rzb(dat, st, buf);
            if(! blk) err(5);
            if(buf)
             st.e = st.y;
            else{
             bufs.push(blk);
             ol += blk.length;
             cpw(st.w, 0, blk.length);
             st.w.set(blk, st.w.length - blk.length);
            }
           }
           bt = st.b + st.c * 4;
          }
          else
           bt = st;
          dat = dat.subarray(bt);
         }
         return cct(bufs, ol);};
       }
       ();
   function caml_zstd_initialize(unit){
    caml_decompress_input = zstd_decompress;
    return 1;
   }
   function caml_output_value_to_buffer(s, ofs, len, v, flags){
    var t = caml_output_val(v, flags);
    if(t.length > len) caml_failwith("Marshal.to_buffer: buffer overflow");
    caml_blit_bytes(t, 0, s, ofs, t.length);
    return 0;
   }
   function re_replacement_text(repl, groups, orig){
    var
     repl = caml_jsbytes_of_string(repl),
     len = repl.length,
     orig = caml_jsbytes_of_string(orig),
     res = "",
     n = 0,
     cur,
     start,
     end,
     c;
    while(n < len){
     cur = repl.charAt(n++);
     if(cur != "\\")
      res += cur;
     else{
      if(n == len) caml_failwith("Str.replace: illegal backslash sequence");
      cur = repl.charAt(n++);
      switch(cur){
        case "\\":
         res += cur; break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
         c = + cur;
         if(c * 2 >= groups.length - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         start = caml_array_get(groups, c * 2);
         end = caml_array_get(groups, c * 2 + 1);
         if(start == - 1)
          caml_failwith("Str.replace: reference to unmatched group");
         res += orig.slice(start, end);
         break;
        default: res += "\\" + cur;
      }
     }
    }
    return caml_string_of_jsbytes(res);
   }
   function caml_pure_js_expr(s){
    console.error("caml_pure_js_expr: fallback to runtime evaluation\n");
    return eval(caml_jsstring_of_string(s));
   }
   function caml_blit_string(a, b, c, d, e){
    caml_blit_bytes(caml_bytes_of_string(a), b, c, d, e);
    return 0;
   }
   function blit_nat(nat1, ofs1, nat2, ofs2, len){
    for(var i = 0; i < len; i++) nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
    return 0;
   }
   function core_gc_top_heap_words(){return 0;}
   function caml_unix_stat(name){
    var root = resolve_fs_device(name);
    if(! root.device.stat) caml_failwith("caml_unix_stat: not implemented");
    return root.device.stat(root.rest, true);
   }
   function caml_register_named_value(nm, v){
    caml_named_values[caml_jsbytes_of_string(nm)] = v;
    return 0;
   }
   function jsoo_create_file_extern(name, content){
    if(globalThis.jsoo_create_file)
     globalThis.jsoo_create_file(name, content);
    else{
     if(! globalThis.caml_fs_tmp) globalThis.caml_fs_tmp = [];
     globalThis.caml_fs_tmp.push({name: name, content: content});
    }
    return 0;
   }
   function caml_unix_stat_64(name){
    var r = caml_unix_stat(name);
    r[9] = caml_int64_of_int32(r[9]);
    return r;
   }
   function caml_to_js_string(s){return caml_jsstring_of_string(s);}
   function caml_ml_mutex_lock(t){
    if(t.locked)
     caml_failwith("Mutex.lock: mutex already locked. Cannot wait.");
    else
     t.locked = true;
    return 0;
   }
   function re_search_forward(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.search_forward");
    while(pos <= caml_ml_string_length(s)){
     var res = re_match(re, s, pos, 0);
     if(res) return res;
     pos++;
    }
    return [0];
   }
   function caml_make_vect(len, init){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 0;
    for(var i = 1; i < len; i++) b[i] = init;
    return b;
   }
   function caml_ml_seek_in(chanid, pos){return caml_seek_in(chanid, pos);}
   function caml_sys_read_directory(name){
    var
     root = resolve_fs_device(name),
     a = root.device.readdir(root.rest),
     l = new Array(a.length + 1);
    l[0] = 0;
    for(var i = 0; i < a.length; i++) l[i + 1] = caml_string_of_jsbytes(a[i]);
    return l;
   }
   function caml_ml_output_char(chanid, c){
    var s = caml_string_of_jsbytes(String.fromCharCode(c));
    caml_ml_output(chanid, s, 0, 1);
    return 0;
   }
   function caml_sys_const_ostype_win32(){return os_type == "Win32" ? 1 : 0;}
   function caml_obj_is_block(x){return + (x instanceof Array);}
   function caml_obj_set_raw_field(o, i, v){return o[i + 1] = v;}
   function caml_js_var(x){
    var x = caml_jsstring_of_string(x);
    if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
     console.error
      ('caml_js_var: "' + x
       + '" is not a valid JavaScript variable. continuing ..');
    return eval(x);
   }
   function caml_trunc_float(x){return Math.trunc(x);}
   function caml_ephe_unset_data(x){
    if(globalThis.FinalizationRegistry && globalThis.WeakRef)
     if(x[1] instanceof globalThis.FinalizationRegistry)
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key) x[1].unregister(key);
       }
      }
    x[caml_ephe_data_offset] = undefined;
    return 0;
   }
   function caml_ephe_set_data(x, data){
    if(globalThis.FinalizationRegistry && globalThis.WeakRef)
     if(! (x[1] instanceof globalThis.FinalizationRegistry)){
      x[1] =
       new
        globalThis.FinalizationRegistry
        (function(){caml_ephe_unset_data(x);});
      for(var j = caml_ephe_key_offset; j < x.length; j++){
       var key = x[j];
       if(key instanceof globalThis.WeakRef){
        key = key.deref();
        if(key) x[1].register(key, undefined, key);
       }
      }
     }
    x[caml_ephe_data_offset] = data;
    return 0;
   }
   function caml_ephe_blit_data(src, dst){
    var n = src[caml_ephe_data_offset];
    if(n === undefined)
     caml_ephe_unset_data(dst);
    else
     caml_ephe_set_data(dst, n);
    return 0;
   }
   function timezone_js_loader_instant_plus_hours(instant, hours){
    hours = caml_int64_to_float(hours);
    var
     duration =
       globalThis.TemporalPolyfill.Temporal.Duration.from({hours: hours});
    return instant.add(duration);
   }
   function length_nat(x){return x.data.length;}
   var Base_internalhash_fold_int64 = caml_hash_mix_int64;
   function caml_is_printable(c){return + (c > 31 && c < 127);}
   function caml_bytes_lessequal(s1, s2){
    s1.t & 6 && caml_convert_string_to_bytes(s1);
    s2.t & 6 && caml_convert_string_to_bytes(s2);
    return s1.c <= s2.c ? 1 : 0;
   }
   function caml_array_of_bytes(x){return caml_uint8_array_of_bytes(x);}
   function caml_equal(x, y){return + (caml_compare_val(x, y, false) == 0);}
   function re_partial_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.partial_match");
    var res = re_match(re, s, pos, 1);
    return res ? res : [0];
   }
   function caml_sys_random_seed(){
    if(globalThis.crypto)
     if(globalThis.crypto.getRandomValues){
      var a = globalThis.crypto.getRandomValues(new Int32Array(4));
      return [0, a[0], a[1], a[2], a[3]];
     }
     else if(globalThis.crypto.randomBytes){
      var a = new Int32Array(globalThis.crypto.randomBytes(16).buffer);
      return [0, a[0], a[1], a[2], a[3]];
     }
    var now = new Date().getTime(), x = now ^ 0xffffffff * Math.random();
    return [0, x];
   }
   var all_finalizers = new globalThis.Set();
   function caml_final_register_called_without_value(cb, a){
    if(globalThis.FinalizationRegistry && a instanceof Object){
     var
      x =
        new
         globalThis.FinalizationRegistry
         (function(x){all_finalizers.delete(x); cb(0); return;});
     x.register(a, x);
     all_finalizers.add(x);
    }
    return 0;
   }
   function caml_csel_value(v_cond, v_true, v_false){return v_cond ? v_true : v_false;
   }
   function caml_ba_get_2(ba, i0, i1){return ba.get(ba.offset([i0, i1]));}
   function caml_ba_uint8_set16(ba, i0, v){
    var ofs = ba.offset(i0);
    if(ofs + 1 >= ba.data.length) caml_array_bound_error();
    ba.set(ofs + 0, v & 0xff);
    ba.set(ofs + 1, v >>> 8 & 0xff);
    return 0;
   }
   function caml_lazy_reset_to_lazy(o){
    caml_obj_update_tag(o, 244, 246);
    return 0;
   }
   function timezone_js_loader_enable_for_testing(){
    globalThis.DISABLE_TIMEZONE_JS_LOADER = undefined;
   }
   function caml_js_delete(o, f){delete o[f]; return 0;}
   function caml_int_of_string(s){
    var
     r = caml_parse_sign_and_base(s),
     i = r[0],
     sign = r[1],
     base = r[2],
     len = caml_ml_string_length(s),
     threshold = - 1 >>> 0,
     c = i < len ? caml_string_unsafe_get(s, i) : 0,
     d = caml_parse_digit(c);
    if(d < 0 || d >= base) caml_failwith("int_of_string");
    var res = d;
    for(i++; i < len; i++){
     c = caml_string_unsafe_get(s, i);
     if(c == 95) continue;
     d = caml_parse_digit(c);
     if(d < 0 || d >= base) break;
     res = base * res + d;
     if(res > threshold) caml_failwith("int_of_string");
    }
    if(i != len) caml_failwith("int_of_string");
    res = sign * res;
    if(base == 10 && (res | 0) != res) caml_failwith("int_of_string");
    return res | 0;
   }
   function caml_list_mount_point(){
    var prev = 0;
    for(var i = 0; i < jsoo_mount_point.length; i++){
     var old = prev;
     prev = [0, caml_string_of_jsbytes(jsoo_mount_point[i].path), old];
    }
    return prev;
   }
   var
    caml_marshal_constants =
      {PREFIX_SMALL_BLOCK: 0x80,
       PREFIX_SMALL_INT: 0x40,
       PREFIX_SMALL_STRING: 0x20,
       CODE_INT8: 0x00,
       CODE_INT16: 0x01,
       CODE_INT32: 0x02,
       CODE_INT64: 0x03,
       CODE_SHARED8: 0x04,
       CODE_SHARED16: 0x05,
       CODE_SHARED32: 0x06,
       CODE_BLOCK32: 0x08,
       CODE_BLOCK64: 0x13,
       CODE_STRING8: 0x09,
       CODE_STRING32: 0x0A,
       CODE_DOUBLE_BIG: 0x0B,
       CODE_DOUBLE_LITTLE: 0x0C,
       CODE_DOUBLE_ARRAY8_BIG: 0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE: 0x0E,
       CODE_DOUBLE_ARRAY32_BIG: 0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE: 0x07,
       CODE_CODEPOINTER: 0x10,
       CODE_INFIXPOINTER: 0x11,
       CODE_CUSTOM: 0x12,
       CODE_CUSTOM_LEN: 0x18,
       CODE_CUSTOM_FIXED: 0x19};
   function caml_obj_raw_field(o, i){return o[i + 1];}
   function caml_js_equals(x, y){return + (x == y);}
   function caml_obj_compare_and_swap(x, i, old, n){
    if(x[i + 1] == old){x[i + 1] = n; return 1;}
    return 0;
   }
   function bigstring_to_typed_array(bs){return bs.data;}
   function caml_gr_arc_aux(ctx, cx, cy, ry, rx, a1, a2){
    while(a1 > a2) a2 += 360;
    a1 /= 180;
    a2 /= 180;
    var
     rot = 0,
     xPos,
     yPos,
     xPos_prev,
     yPos_prev,
     space = 2,
     num = (a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
     delta = (a2 - a1) * Math.PI / num,
     i = a1 * Math.PI;
    for(var j = 0; j <= num; j++){
     xPos =
      cx - rx * Math.sin(i) * Math.sin(rot * Math.PI)
      + ry * Math.cos(i) * Math.cos(rot * Math.PI);
     xPos = xPos.toFixed(2);
     yPos =
      cy + ry * Math.cos(i) * Math.sin(rot * Math.PI)
      + rx * Math.sin(i) * Math.cos(rot * Math.PI);
     yPos = yPos.toFixed(2);
     if(j == 0)
      ctx.moveTo(xPos, yPos);
     else if(xPos_prev != xPos || yPos_prev != yPos) ctx.lineTo(xPos, yPos);
     xPos_prev = xPos;
     yPos_prev = yPos;
     i -= delta;
    }
    return 0;
   }
   function caml_gr_fill_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.fill();
    return 0;
   }
   function caml_ba_slice(ba, vind){
    vind = caml_js_from_array(vind);
    var num_inds = vind.length, index = [], sub_dims = [], ofs;
    if(num_inds > ba.dims.length)
     caml_invalid_argument("Bigarray.slice: too many indices");
    if(ba.layout == 0){
     for(var i = 0; i < num_inds; i++) index[i] = vind[i];
     for(; i < ba.dims.length; i++) index[i] = 0;
     sub_dims = ba.dims.slice(num_inds);
    }
    else{
     for(var i = 0; i < num_inds; i++)
      index[ba.dims.length - num_inds + i] = vind[i];
     for(var i = 0; i < ba.dims.length - num_inds; i++) index[i] = 1;
     sub_dims = ba.dims.slice(0, ba.dims.length - num_inds);
    }
    ofs = ba.offset(index);
    var
     size = caml_ba_get_size(sub_dims),
     size_per_element = caml_ba_get_size_per_element(ba.kind),
     new_data =
       ba.data.subarray
        (ofs * size_per_element, (ofs + size) * size_per_element);
    return caml_ba_create_unsafe(ba.kind, ba.layout, sub_dims, new_data);
   }
   function caml_js_wrap_callback_unsafe(f){
    return function(){
     var len = caml_js_function_arity(f), args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_ba_kind(ba){return ba.kind;}
   function timezone_js_loader_disable_for_testing(){globalThis.DISABLE_TIMEZONE_JS_LOADER = true;
   }
   function caml_alloc_dummy_infix(){
    return function f(x){return caml_call_gen(f.fun, [x]);};
   }
   function caml_js_strict_equals(x, y){return + (x === y);}
   function caml_js_fun_call(f, a){
    switch(a.length){
      case 1:
       return f();
      case 2:
       return f(a[1]);
      case 3:
       return f(a[1], a[2]);
      case 4:
       return f(a[1], a[2], a[3]);
      case 5:
       return f(a[1], a[2], a[3], a[4]);
      case 6:
       return f(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return f(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return f(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    return f.apply(null, caml_js_from_array(a));
   }
   function caml_gc_major_slice(work){return 0;}
   function caml_js_pure_expr(f){return caml_callback(f, [0]);}
   var core_array_unsafe_int_blit = caml_array_blit;
   function compare_digits_nat(nat1, ofs1, nat2, ofs2){
    if(nat1.data[ofs1] > nat2.data[ofs2]) return 1;
    if(nat1.data[ofs1] < nat2.data[ofs2]) return - 1;
    return 0;
   }
   function caml_ml_input(chanid, b, i, l){
    var ba = caml_uint8_array_of_bytes(b);
    return caml_ml_input_block(chanid, ba, i, l);
   }
   function caml_gr_wait_event(_evl){
    caml_failwith
     ("caml_gr_wait_event not Implemented: use Graphics_js instead");
   }
   function caml_gr_sigio_handler(){return 0;}
   function caml_memprof_discard(t){return 0;}
   function caml_record_backtrace(b){
    caml_record_backtrace_flag = b;
    return 0;
   }
   function caml_unix_cleanup(){}
   function caml_sys_get_config(){
    return [0, caml_string_of_jsbytes(os_type), 32, 0];
   }
   function caml_sys_const_backend_type(){
    return [0, caml_string_of_jsbytes("js_of_ocaml")];
   }
   function core_heap_block_is_heap_block(x){return + (x instanceof Array);}
   function caml_obj_is_shared(x){return 1;}
   function core_gc_promoted_words(){return 0;}
   function caml_dummy_obj_is_stack(x){
    throw new
           Error
           (`BUG: this function should be unreachable; please report to compiler or base devs.`);
   }
   function caml_ml_out_channels_list(){
    var l = 0;
    for(var c = 0; c < caml_ml_channels.length; c++)
     if
      (caml_ml_channels[c] && caml_ml_channels[c].opened
       && caml_ml_channels[c].out)
      l = [0, caml_ml_channels[c].fd, l];
    return l;
   }
   function caml_asinh_float(x){return Math.asinh(x);}
   function caml_pos_out(chanid){
    var chan = caml_ml_channels[chanid];
    return chan.offset + chan.buffer_curr;
   }
   function bigstring_of_array_buffer(ab){
    var ta = new Uint8Array(ab);
    return caml_ba_create_unsafe(12, 0, [ta.length], ta);
   }
   function caml_mod(x, y){if(y == 0) caml_raise_zero_divide(); return x % y;}
   function caml_ba_init(){return 0;}
   function caml_unix_filedescr_of_fd(x){return x;}
   function re_string_match(re, s, pos){
    if(pos < 0 || pos > caml_ml_string_length(s))
     caml_invalid_argument("Str.string_match");
    var res = re_match(re, s, pos, 0);
    return res ? res : [0];
   }
   function BigStringReader(bs, i){this.s = bs; this.i = i;}
   BigStringReader.prototype =
    {read8u: function(){return caml_ba_get_1(this.s, this.i++);},
     read8s: function(){return caml_ba_get_1(this.s, this.i++) << 24 >> 24;},
     read16u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return caml_ba_get_1(s, i) << 8 | caml_ba_get_1(s, i + 1);
     },
     read16s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 2;
      return caml_ba_get_1(s, i) << 24 >> 16 | caml_ba_get_1(s, i + 1);
     },
     read32u:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return (caml_ba_get_1(s, i) << 24 | caml_ba_get_1(s, i + 1) << 16
             | caml_ba_get_1(s, i + 2) << 8
             | caml_ba_get_1(s, i + 3))
             >>> 0;
     },
     read32s:
     function(){
      var s = this.s, i = this.i;
      this.i = i + 4;
      return caml_ba_get_1(s, i) << 24 | caml_ba_get_1(s, i + 1) << 16
             | caml_ba_get_1(s, i + 2) << 8
             | caml_ba_get_1(s, i + 3);
     },
     readstr:
     function(len){
      var i = this.i, arr = new Array(len);
      for(var j = 0; j < len; j++) arr[j] = caml_ba_get_1(this.s, i + j);
      this.i = i + len;
      return caml_string_of_array(arr);
     },
     readuint8array:
     function(len){
      var i = this.i, offset = this.offset(i);
      this.i = i + len;
      return this.s.data.subarray(offset, offset + len);
     }};
   function caml_gr_dump_image(im){
    var data = [0];
    for(var i = 0; i < im.height; i++){
     data[i + 1] = [0];
     for(var j = 0; j < im.width; j++){
      var
       o = i * (im.width * 4) + j * 4,
       r = im.data[o + 0],
       g = im.data[o + 1],
       b = im.data[o + 2];
      data[i + 1][j + 1] = (r << 16) + (g << 8) + b;
     }
    }
    return data;
   }
   function caml_ba_get_generic(ba, i){
    var ofs = ba.offset(caml_js_from_array(i));
    return ba.get(ofs);
   }
   function caml_unix_startup(){}
   function caml_get_exception_backtrace(){return 0;}
   function caml_format_float(fmt, x){
    function toFixed(x, dp){
     if(Math.abs(x) < 1.0)
      return x.toFixed(dp);
     else{
      var e = parseInt(x.toString().split("+")[1]);
      if(e > 20){
       e -= 20;
       x /= Math.pow(10, e);
       x += new Array(e + 1).join("0");
       if(dp > 0) x = x + "." + new Array(dp + 1).join("0");
       return x;
      }
      else
       return x.toFixed(dp);
     }
    }
    var s, f = caml_parse_format(fmt), prec = f.prec < 0 ? 6 : f.prec;
    if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1; x = - x;}
    if(isNaN(x)){
     s = "nan";
     f.filler = " ";
    }
    else if(! isFinite(x)){
     s = "inf";
     f.filler = " ";
    }
    else
     switch(f.conv){
       case "e":
        var s = x.toExponential(prec), i = s.length;
        if(s.charAt(i - 3) == "e")
         s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
        break;
       case "f":
        s = toFixed(x, prec); break;
       case "g":
        prec = prec ? prec : 1;
        s = x.toExponential(prec - 1);
        var j = s.indexOf("e"), exp = + s.slice(j + 1);
        if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec){
         var i = j - 1;
         while(s.charAt(i) == "0") i--;
         if(s.charAt(i) == ".") i--;
         s = s.slice(0, i + 1) + s.slice(j);
         i = s.length;
         if(s.charAt(i - 3) == "e")
          s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
         break;
        }
        else{
         var p = prec;
         if(exp < 0){
          p -= exp + 1;
          s = x.toFixed(p);
         }
         else
          while(s = x.toFixed(p), s.length > prec + 1) p--;
         if(p){
          var i = s.length - 1;
          while(s.charAt(i) == "0") i--;
          if(s.charAt(i) == ".") i--;
          s = s.slice(0, i + 1);
         }
        }
        break;
     }
    return caml_finish_formatting(f, s);
   }
   function caml_mount_autoload(name, f){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/"));
    jsoo_mount_point.push({path: name, device: new MlFakeDevice(name, f)});
    return 0;
   }
   function Base_int_math_int_clz(x){return Base_int_math_int32_clz(x);}
   function caml_string_lessthan(s1, s2){return s1 < s2 ? 1 : 0;}
   function caml_string_greaterthan(s1, s2){return caml_string_lessthan(s2, s1);
   }
   function caml_div(x, y){
    if(y == 0) caml_raise_zero_divide();
    return x / y | 0;
   }
   function caml_obj_dup(x){
    var l = x.length, a = new Array(l);
    for(var i = 0; i < l; i++) a[i] = x[i];
    return a;
   }
   function caml_ephe_get_data_copy(x){
    return x[caml_ephe_data_offset] === undefined
            ? 0
            : [0, caml_obj_dup(x[caml_ephe_data_offset])];
   }
   function caml_memprof_start(rate, stack_size, tracker){return 0;}
   function caml_sys_get_argv(a){return [0, caml_argv[1], caml_argv];}
   function caml_ml_domain_set_name(_name){return 0;}
   function caml_js_to_bool(x){return + x;}
   function caml_gr_create_image(x, y){
    var s = caml_gr_state_get();
    return s.context.createImageData(x, y);
   }
   function caml_ephe_get_key_copy(x, i){
    if(i < 0 || caml_ephe_key_offset + i >= x.length)
     caml_invalid_argument("Weak.get_copy");
    var y = caml_ephe_get_key(x, i);
    if(y === 0) return y;
    var z = y[1];
    if(z instanceof Array) return [0, caml_obj_dup(z)];
    return y;
   }
   function caml_lessthan(x, y){return + (caml_compare_val(x, y, false) < 0);}
   function caml_raw_backtrace_next_slot(){return 0;}
   function bigstringaf_memcmp_string(ba, ba_off, str, str_off, len){
    for(var i = 0; i < len; i++){
     var
      c =
        caml_int_compare
         (caml_ba_get_1(ba, ba_off + i),
          caml_string_unsafe_get(str, str_off + i));
     if(c != 0) return c;
    }
    return 0;
   }
   function timezone_js_loader_compare_instants(a, b){
    return globalThis.TemporalPolyfill.Temporal.Instant.compare(a, b);
   }
   function caml_build_symbols(toc){
    var symb;
    while(toc)
     if(caml_jsstring_of_string(toc[1][1]) == "SYJS"){symb = toc[1][2]; break;}
     else
      toc = toc[2];
    var r = {};
    if(symb)
     for(var i = 1; i < symb.length; i++)
      r[caml_jsstring_of_string(symb[i][1])] = symb[i][2];
    return r;
   }
   function caml_register_global(n, v, name_opt){
    if(name_opt){
     var name = name_opt;
     if(globalThis.toplevelReloc)
      n = caml_callback(globalThis.toplevelReloc, [name]);
     else if(caml_global_data.toc){
      if(! caml_global_data.symbols)
       caml_global_data.symbols = caml_build_symbols(caml_global_data.toc);
      var nid = caml_global_data.symbols[name];
      if(nid >= 0)
       n = nid;
      else
       caml_failwith("caml_register_global: cannot locate " + name);
     }
    }
    caml_global_data[n + 1] = v;
    if(name_opt) caml_global_data[name_opt] = v;
   }
   function mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3, len3){
    var carry = 0;
    for(var i = 0; i < len3; i++)
     carry +=
      mult_digit_nat
       (nat1, ofs1 + i, len1 - i, nat2, ofs2, len2, nat3, ofs3 + i);
    return carry;
   }
   function square_nat(nat1, ofs1, len1, nat2, ofs2, len2){
    var carry = 0;
    carry += add_nat(nat1, ofs1, len1, nat1, ofs1, len1, 0);
    carry += mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat2, ofs2, len2);
    return carry;
   }
   function core_md5_digest_subbigstring(buf, ofs, len, res){
    var bytes = caml_create_bytes(len);
    bigstring_blit_bigstring_bytes_stub(buf, ofs, bytes, 0, len);
    var res2 = caml_md5_string(caml_string_of_bytes(bytes), 0, len);
    caml_blit_string(res2, 0, res, 0, 16);
    return 0;
   }
   function bigstring_memmem_bytecode
   (haystack, needle, haystack_pos, haystack_len, needle_pos, needle_len){
    var i = 0, lim = haystack_len - needle_len;
    for(var i = 0; i <= lim; ++i){
     var matches = true;
     for(var j = 0; j < needle_len; ++j)
      if
       (caml_ba_get_1(haystack, haystack_pos + i + j)
        != caml_ba_get_1(needle, needle_pos + j)){matches = false; break;}
     if(matches) return haystack_pos + i;
    }
    return - 1;
   }
   function caml_js_from_float(x){return x;}
   function caml_floatarray_create(len){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_gc_stat(){
    return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
   }
   function caml_get_major_credit(n){return 0;}
   function caml_ml_open_descriptor_in_with_flags(fd, flags){return caml_ml_open_descriptor_in(fd);
   }
   function bigstringaf_memchr(ba, ba_off, chr, len){
    for(var i = 0; i < len; i++)
     if(caml_ba_get_1(ba, ba_off + i) == chr) return ba_off + i;
    return - 1;
   }
   function caml_sys_modify_argv(arg){caml_argv = arg; return 0;}
   var caml_method_cache = [];
   function caml_get_public_method(obj, tag, cacheid){
    var meths = obj[1], ofs = caml_method_cache[cacheid];
    if(ofs === undefined)
     for(var i = caml_method_cache.length; i < cacheid; i++)
      caml_method_cache[i] = 0;
    else if(meths[ofs] === tag) return meths[ofs - 1];
    var li = 3, hi = meths[1] * 2 + 1, mi;
    while(li < hi){
     mi = li + hi >> 1 | 1;
     if(tag < meths[mi + 1]) hi = mi - 2; else li = mi;
    }
    caml_method_cache[cacheid] = li + 1;
    return tag == meths[li + 1] ? meths[li] : 0;
   }
   function bin_prot_blit_buf_bytes_stub(src_pos, src, dst_pos, dst, len){
    return caml_bigstring_blit_ba_to_bytes(src, src_pos, dst, dst_pos, len);
   }
   function caml_js_get_console(){
    var
     c = console,
     m =
       ["log",
        "debug",
        "info",
        "warn",
        "error",
        "assert",
        "dir",
        "dirxml",
        "trace",
        "group",
        "groupCollapsed",
        "groupEnd",
        "time",
        "timeEnd"];
    function f(){}
    for(var i = 0; i < m.length; i++) if(! c[m[i]]) c[m[i]] = f;
    return c;
   }
   function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name);}
   function caml_round_float(x){
    if(x >= 0){
     var y = Math.floor(x);
     return x - y >= 0.5 ? y + 1 : y;
    }
    else{var y = Math.ceil(x); return y - x >= 0.5 ? y - 1 : y;}
   }
   function caml_ojs_new_arr(c, a){
    switch(a.length){
      case 0:
       return new c;
      case 1:
       return new c(a[0]);
      case 2:
       return new c(a[0], a[1]);
      case 3:
       return new c(a[0], a[1], a[2]);
      case 4:
       return new c(a[0], a[1], a[2], a[3]);
      case 5:
       return new c(a[0], a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);
    }
    function F(){return c.apply(this, a);}
    F.prototype = c.prototype;
    return new F;
   }
   function complement_nat(nat, ofs, len){
    for(var i = 0; i < len; i++)
     nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0);
   }
   var caml_domain_dls = [0];
   function caml_domain_dls_set(a){caml_domain_dls = a;}
   function caml_obj_tag(x){
    if(x instanceof Array && x[0] == x[0] >>> 0)
     return x[0];
    else if(caml_is_ml_bytes(x))
     return 252;
    else if(caml_is_ml_string(x))
     return 252;
    else if(x instanceof Function || typeof x == "function")
     return 247;
    else if(x && x.caml_custom) return 255; else return 1000;
   }
   function caml_lazy_read_result(o){
    return caml_obj_tag(o) == 250 ? o[1] : o;
   }
   var caml_js_regexps = {amp: /&/g, lt: /</g, quot: /\"/g, all: /[&<\"]/};
   function caml_js_html_escape(s){
    if(! caml_js_regexps.all.test(s)) return s;
    return s.replace(caml_js_regexps.amp, "&amp;").replace
             (caml_js_regexps.lt, "&lt;").replace
            (caml_js_regexps.quot, "&quot;");
   }
   function caml_ba_dim_2(ba){return caml_ba_dim(ba, 1);}
   function caml_js_wrap_meth_callback_arguments(f){
    return function(){
     var len = arguments.length, args = new Array(len);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, [this, args]);};
   }
   function caml_sinh_float(x){return Math.sinh(x);}
   function core_gc_major_plus_minor_words(){return 0;}
   function caml_ldexp_float(x, exp){
    exp |= 0;
    if(exp > 1023){
     exp -= 1023;
     x *= Math.pow(2, 1023);
     if(exp > 1023){exp -= 1023; x *= Math.pow(2, 1023);}
    }
    if(exp < - 1023){exp += 1023; x *= Math.pow(2, - 1023);}
    x *= Math.pow(2, exp);
    return x;
   }
   function caml_gr_state_set(ctx){
    caml_gr_state = ctx;
    caml_gr_state_init();
    return 0;
   }
   function caml_js_wrap_callback_strict(arity, f){
    return function(){
     var
      n = arguments.length,
      args = new Array(arity),
      len = Math.min(arguments.length, arity);
     for(var i = 0; i < len; i++) args[i] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_gc_minor_words(unit){return 0;}
   function caml_get_current_callstack(){return [0];}
   function land_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] &= nat2.data[ofs2]; return 0;
   }
   function caml_int64_mod(x, y){return x.mod(y);}
   function caml_obj_set_tag(x, tag){x[0] = tag; return 0;}
   function caml_int32_bswap(x){
    return (x & 0x000000FF) << 24 | (x & 0x0000FF00) << 8
           | (x & 0x00FF0000) >>> 8
           | (x & 0xFF000000) >>> 24;
   }
   function caml_ba_set_3(ba, i0, i1, i2, v){
    ba.set(ba.offset([i0, i1, i2]), v);
    return 0;
   }
   function caml_js_instanceof(o, c){return o instanceof c ? 1 : 0;}
   function caml_get_major_bucket(n){return 0;}
   function nth_digit_nat_native(nat, ofs){return nat.data[ofs];}
   function set_digit_nat_native(nat, ofs, digit){nat.data[ofs] = digit; return 0;
   }
   function caml_string_set64(s, i, i64){caml_failwith("caml_string_set64");}
   function caml_gr_state_create(canvas, w, h){
    var context = canvas.getContext("2d");
    return {context: context,
            canvas: canvas,
            x: 0,
            y: 0,
            width: w,
            height: h,
            line_width: 1,
            font: caml_string_of_jsbytes("fixed"),
            text_size: 26,
            color: 0x000000,
            title: caml_string_of_jsbytes("")};
   }
   function caml_gr_draw_arc(x, y, rx, ry, a1, a2){
    var s = caml_gr_state_get();
    s.context.beginPath();
    caml_gr_arc_aux(s.context, x, s.height - y, rx, ry, a1, a2);
    s.context.stroke();
    return 0;
   }
   function caml_ba_map_file(vfd, kind, layout, shared, dims, pos){caml_failwith("caml_ba_map_file not implemented");
   }
   function caml_ba_map_file_bytecode(argv, argn){
    return caml_ba_map_file
            (argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
   }
   function caml_ba_create_from(data1, data2, jstyp, kind, layout, dims){
    if(data2 || caml_ba_get_size_per_element(kind) == 2)
     caml_invalid_argument
      ("caml_ba_create_from: use return caml_ba_create_unsafe");
    return caml_ba_create_unsafe(kind, layout, dims, data1);
   }
   function caml_tanh_float(x){return Math.tanh(x);}
   function Base_int_math_int_ctz(x){return Base_int_math_int32_ctz(x);}
   function bigstring_blit_string_bigstring_stub
   (src, src_pos, dst, dst_pos, len){
    return caml_bigstring_blit_string_to_ba(src, src_pos, dst, dst_pos, len);
   }
   function caml_runtime_events_start(){return 0;}
   function caml_gr_draw_str(str){
    var s = caml_gr_state_get(), m = s.context.measureText(str), dx = m.width;
    s.context.fillText(str, s.x, s.height - s.y);
    s.x += dx | 0;
    return 0;
   }
   function caml_gr_draw_string(str){
    caml_gr_draw_str(caml_jsstring_of_string(str));
    return 0;
   }
   function caml_gr_draw_char(c){
    caml_gr_draw_str(String.fromCharCode(c));
    return 0;
   }
   function caml_unmount(name){
    var
     path = caml_make_path(name),
     name = caml_trailing_slash(path.join("/")),
     idx = - 1;
    for(var i = 0; i < jsoo_mount_point.length; i++)
     if(jsoo_mount_point[i].path == name) idx = i;
    if(idx > - 1) jsoo_mount_point.splice(idx, 1);
    return 0;
   }
   function caml_input_value_from_string(s, ofs){
    var reader = new MlStringReader(s, typeof ofs == "number" ? ofs : ofs[0]);
    return caml_input_value_from_reader(reader, ofs);
   }
   function caml_ml_pos_in_64(chanid){
    return caml_int64_of_float(caml_pos_in(chanid));
   }
   function caml_gr_draw_image(im, x, y){
    var s = caml_gr_state_get();
    if(! im.image){
     var canvas = document.createElement("canvas");
     canvas.width = s.width;
     canvas.height = s.height;
     canvas.getContext("2d").putImageData(im, 0, 0);
     var image = new globalThis.Image();
     image.onload =
      function(){
       s.context.drawImage(image, x, s.height - im.height - y);
       im.image = image;
      };
     image.src = canvas.toDataURL("image/png");
    }
    else
     s.context.drawImage(im.image, x, s.height - im.height - y);
    return 0;
   }
   function caml_register_channel_for_spacetime(_channel){return 0;}
   function caml_string_set(s, i, c){caml_failwith("caml_string_set");}
   function caml_sys_rmdir(name){
    var root = resolve_fs_device(name);
    root.device.rmdir(root.rest);
    return 0;
   }
   function timezone_js_loader_from_epoch_seconds(seconds){
    return globalThis.TemporalPolyfill.Temporal.Instant.fromEpochSeconds
            (caml_int64_to_float(seconds));
   }
   function caml_unix_symlink(to_dir, src, dst){
    var src_root = resolve_fs_device(src), dst_root = resolve_fs_device(dst);
    if(src_root.device != dst_root.device)
     caml_failwith
      ("caml_unix_symlink: cannot symlink between two filesystems");
    if(! src_root.device.symlink)
     caml_failwith("caml_unix_symlink: not implemented");
    return src_root.device.symlink(to_dir, src_root.rest, dst_root.rest, true);
   }
   function Base_int_math_int64_ctz(x){
    if(caml_int64_is_zero(x)) return 64;
    var n = 1;
    function is_zero(x){return caml_int64_is_zero(x);}
    function land(x, y){return caml_int64_and(x, y);}
    function small_int64(x){return caml_int64_create_lo_mi_hi(x, 0, 0);}
    if
     (is_zero(land(x, caml_int64_create_lo_mi_hi(0xFFFFFF, 0x0000FF, 0x0000)))){n = n + 32; x = caml_int64_shift_right_unsigned(x, 32);}
    if(is_zero(land(x, small_int64(0x00FFFF)))){
     n = n + 16;
     x = caml_int64_shift_right_unsigned(x, 16);
    }
    if(is_zero(land(x, small_int64(0x0000FF)))){
     n = n + 8;
     x = caml_int64_shift_right_unsigned(x, 8);
    }
    if(is_zero(land(x, small_int64(0x00000F)))){
     n = n + 4;
     x = caml_int64_shift_right_unsigned(x, 4);
    }
    if(is_zero(land(x, small_int64(0x000003)))){
     n = n + 2;
     x = caml_int64_shift_right_unsigned(x, 2);
    }
    return n - caml_int64_to_int32(caml_int64_and(x, small_int64(0x000001)));
   }
   function caml_ml_pos_out(chanid){return caml_pos_out(chanid);}
   var core_array_unsafe_float_blit = caml_array_blit;
   function Base_caml_exn_is_most_recent_exn(x){return 1;}
   function caml_spacetime_enabled(_unit){return 0;}
   function caml_bytes_notequal(s1, s2){return 1 - caml_bytes_equal(s1, s2);}
   function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("");}
   function caml_js_object(a){
    var o = {};
    for(var i = 1; i < a.length; i++){
     var p = a[i];
     o[caml_jsstring_of_string(p[1])] = p[2];
    }
    return o;
   }
   function caml_ba_create(kind, layout, dims_ml){
    var
     dims = caml_js_from_array(dims_ml),
     data = caml_ba_create_buffer(kind, caml_ba_get_size(dims));
    return caml_ba_create_unsafe(kind, layout, dims, data);
   }
   function caml_gr_remember_mode(){
    caml_failwith("caml_gr_remember_mode not Implemented");
   }
   function Base_internalhash_get_hash_value(seed){
    var h = caml_hash_mix_final(seed);
    return h & 0x3FFFFFFF;
   }
   function caml_fma_float(x, y, z){
    var
     SPLIT = Math.pow(2, 27) + 1,
     MIN_VALUE = Math.pow(2, - 1022),
     EPSILON = Math.pow(2, - 52),
     C = 416,
     A = Math.pow(2, + C),
     B = Math.pow(2, - C);
    function multiply(a, b){
     var
      at = SPLIT * a,
      ahi = at - (at - a),
      alo = a - ahi,
      bt = SPLIT * b,
      bhi = bt - (bt - b),
      blo = b - bhi,
      p = a * b,
      e = ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
     return {p: p, e: e};
    }
    function add(a, b){
     var s = a + b, v = s - a, e = a - (s - v) + (b - v);
     return {s: s, e: e};
    }
    function adjust(x, y){
     return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
             ? x * (1 + (x < 0 ? - 1 : + 1) * (y < 0 ? - 1 : + 1) * EPSILON)
             : x;
    }
    if
     (x === 0 || x !== x || x === + (1 / 0) || x === - (1 / 0) || y === 0
      || y !== y
      || y === + (1 / 0)
      || y === - (1 / 0))
     return x * y + z;
    if(z === 0) return x * y;
    if(z !== z || z === + (1 / 0) || z === - (1 / 0)) return z;
    var scale = 1;
    while(Math.abs(x) > A){scale *= A; x *= B;}
    while(Math.abs(y) > A){scale *= A; y *= B;}
    if(scale === 1 / 0) return x * y * scale;
    while(Math.abs(x) < B){scale *= B; x *= A;}
    while(Math.abs(y) < B){scale *= B; y *= A;}
    if(scale === 0) return z;
    var xs = x, ys = y, zs = z / scale;
    if(Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON) return z;
    if(Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
     zs = (z < 0 ? - 1 : + 1) * MIN_VALUE;
    var
     xy = multiply(xs, ys),
     s = add(xy.p, zs),
     u = add(xy.e, s.e),
     i = add(s.s, u.s),
     f = i.s + adjust(i.e, u.e);
    if(f === 0) return f;
    var fs = f * scale;
    if(Math.abs(fs) > MIN_VALUE) return fs;
    return fs + adjust(f - fs / scale, i.e) * scale;
   }
   function caml_recommended_domain_count(unit){return 1;}
   function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8;}
   function caml_ml_set_binary_mode(chanid, mode){
    var chan = caml_ml_channels[chanid];
    chan.file.flags.text = ! mode;
    chan.file.flags.binary = mode;
    return 0;
   }
   function caml_final_register(){return 0;}
   function caml_gr_draw_rect(x, y, w, h){
    var s = caml_gr_state_get();
    s.context.strokeRect(x, s.height - y, w, - h);
    return 0;
   }
   function caml_string_get16(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 1) caml_string_bound_error();
    var
     b1 = caml_string_unsafe_get(s, i),
     b2 = caml_string_unsafe_get(s, i + 1);
    return b2 << 8 | b1;
   }
   function timezone_js_loader_now(){
    return globalThis.TemporalPolyfill.Temporal.Now.instant();
   }
   function core_gc_major_collections(){return 0;}
   function caml_js_to_int32(x){return x | 0;}
   function caml_output_value(chanid, v, flags){
    var s = caml_output_value_to_string(v, flags);
    caml_ml_output(chanid, s, 0, caml_ml_string_length(s));
    return 0;
   }
   function caml_ml_output_bigarray(chanid, buffer, offset, len){
    var buffer = caml_ba_to_typed_array(buffer);
    return caml_ml_output_ta(chanid, buffer, offset, len);
   }
   function caml_ba_get_3(ba, i0, i1, i2){
    return ba.get(ba.offset([i0, i1, i2]));
   }
   function caml_ephe_blit_key(a1, i1, a2, i2, len){
    caml_array_blit
     (a1,
      caml_ephe_key_offset + i1 - 1,
      a2,
      caml_ephe_key_offset + i2 - 1,
      len);
    return 0;
   }
   var caml_initial_time = new Date().getTime() * 0.001;
   function caml_sys_time(){
    var now = new Date().getTime();
    return now * 0.001 - caml_initial_time;
   }
   function caml_sys_time_include_children(b){return caml_sys_time();}
   function Base_clear_caml_backtrace_pos(x){return 0;}
   function caml_unix_getpwuid(unit){caml_raise_not_found();}
   function timezone_js_loader_epoch_seconds(instant){return caml_int64_of_float(instant.epochSeconds);
   }
   function caml_domain_dls_get(unit){return caml_domain_dls;}
   function caml_bytes_get32(s, i){
    if(i >>> 0 >= s.l - 3) caml_bytes_bound_error();
    var
     b1 = caml_bytes_unsafe_get(s, i),
     b2 = caml_bytes_unsafe_get(s, i + 1),
     b3 = caml_bytes_unsafe_get(s, i + 2),
     b4 = caml_bytes_unsafe_get(s, i + 3);
    return b4 << 24 | b3 << 16 | b2 << 8 | b1;
   }
   function caml_frexp_float(x){
    if(x == 0 || ! isFinite(x)) return [0, x, 0];
    var neg = x < 0;
    if(neg) x = - x;
    var exp = Math.max(- 1023, jsoo_floor_log2(x) + 1);
    x *= Math.pow(2, - exp);
    while(x < 0.5){x *= 2; exp--;}
    while(x >= 1){x *= 0.5; exp++;}
    if(neg) x = - x;
    return [0, x, exp];
   }
   function bigstring_blit_bytes_bigstring_stub
   (src, src_pos, dst, dst_pos, len){
    return caml_bigstring_blit_bytes_to_ba(src, src_pos, dst, dst_pos, len);
   }
   function core_time_ns_format(time, format){
    var
     d = new Date(time * 1000),
     formatjs = caml_jsbytes_of_string(format),
     jstring = joo_global_object.strftime(formatjs, d);
    return caml_string_of_jsbytes(jstring);
   }
   function caml_string_get64(s, i){
    if(i >>> 0 >= caml_ml_string_length(s) - 7) caml_string_bound_error();
    var a = new Array(8);
    for(var j = 0; j < 8; j++) a[7 - j] = caml_string_unsafe_get(s, i + j);
    return caml_int64_of_bytes(a);
   }
   function caml_js_error_option_of_exception(exn){
    if(exn.js_error) return [0, exn.js_error];
    return 0;
   }
   function caml_ml_pos_out_64(chanid){
    return caml_int64_of_float(caml_pos_out(chanid));
   }
   function caml_unix_findclose(dir_handle){return caml_unix_closedir(dir_handle);
   }
   function caml_gr_close_subwindow(a){
    caml_failwith("caml_gr_close_subwindow not Implemented");
   }
   function caml_floatarray_blit(a1, i1, a2, i2, len){
    if(i2 <= i1)
     for(var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];
    else
     for(var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];
    return 0;
   }
   function caml_get_minor_free(unit){return 0;}
   function caml_set_static_env(k, v){
    if(! globalThis.jsoo_static_env) globalThis.jsoo_static_env = {};
    globalThis.jsoo_static_env[k] = v;
    return 0;
   }
   function caml_ba_change_layout(ba, layout){
    if(ba.layout == layout) return ba;
    var new_dims = [];
    for(var i = 0; i < ba.dims.length; i++)
     new_dims[i] = ba.dims[ba.dims.length - i - 1];
    return caml_ba_create_unsafe(ba.kind, layout, new_dims, ba.data);
   }
   function Base_hash_double(d){return caml_hash(1, 1, 0, d);}
   function caml_js_new(c, a){
    switch(a.length){
      case 1:
       return new c;
      case 2:
       return new c(a[1]);
      case 3:
       return new c(a[1], a[2]);
      case 4:
       return new c(a[1], a[2], a[3]);
      case 5:
       return new c(a[1], a[2], a[3], a[4]);
      case 6:
       return new c(a[1], a[2], a[3], a[4], a[5]);
      case 7:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6]);
      case 8:
       return new c(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    }
    function F(){return c.apply(this, caml_js_from_array(a));}
    F.prototype = c.prototype;
    return new F;
   }
   function caml_ml_open_descriptor_out(fd){
    var file = caml_sys_fds[fd];
    if(file.flags.rdonly) caml_raise_sys_error("fd " + fd + " is readonly");
    var
     buffered = file.flags.buffered !== undefined ? file.flags.buffered : 1,
     channel =
       {file: file,
        offset: file.flags.append ? file.length() : 0,
        fd: fd,
        opened: true,
        out: true,
        buffer_curr: 0,
        buffer: new Uint8Array(65536),
        buffered: buffered};
    caml_ml_channels[channel.fd] = channel;
    return channel.fd;
   }
   function caml_ml_open_descriptor_out_with_flags(fd, flags){return caml_ml_open_descriptor_out(fd);
   }
   function bigstring_alloc_v2(size){return caml_ba_create(12, 0, [0, size]);}
   function caml_gr_current_y(){var s = caml_gr_state_get(); return s.y;}
   function caml_format_int(fmt, i){
    if(caml_jsbytes_of_string(fmt) == "%d")
     return caml_string_of_jsbytes("" + i);
    var f = caml_parse_format(fmt);
    if(i < 0) if(f.signedconv){f.sign = - 1; i = - i;} else i >>>= 0;
    var s = i.toString(f.base);
    if(f.prec >= 0){
     f.filler = " ";
     var n = f.prec - s.length;
     if(n > 0) s = caml_str_repeat(n, "0") + s;
    }
    return caml_finish_formatting(f, s);
   }
   function core_gc_heap_words(){return 0;}
   function jsoo_effect_not_supported(){
    caml_failwith("Effect handlers are not supported");
   }
   var caml_ml_domain_unique_token_ = [0];
   function caml_ml_domain_unique_token(unit){return caml_ml_domain_unique_token_;
   }
   function caml_continuation_use_and_update_handler_noexc
   (cont, hval, hexn, heff){
    var stack = caml_continuation_use_noexc(cont);
    stack[3] = [0, hval, hexn, heff];
    return stack;
   }
   function caml_obj_truncate(x, s){
    if(s <= 0 || s + 1 > x.length) caml_invalid_argument("Obj.truncate");
    if(x.length != s + 1) x.length = s + 1;
    return 0;
   }
   function caml_js_to_string(s){return caml_string_of_jsstring(s);}
   function core_gc_minor_words(){return 0;}
   function is_digit_odd(nat, ofs){if(nat.data[ofs] & 1) return 1; return 0;}
   function caml_runtime_variant(_unit){return caml_string_of_jsbytes("");}
   function caml_array_concat(l){
    var a = [0];
    while(l !== 0){
     var b = l[1];
     for(var i = 1; i < b.length; i++) a.push(b[i]);
     l = l[2];
    }
    return a;
   }
   function caml_gr_open_graph(info){
    var info = caml_jsstring_of_string(info);
    function get(name){
     var res = info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
     if(res) return res[2];
    }
    var specs = [];
    if(! (info == "")) specs.push(info);
    var target = get("target");
    if(! target) target = "";
    var status = get("status");
    if(! status) specs.push("status=1");
    var w = get("width");
    w = w ? parseInt(w) : 200;
    specs.push("width=" + w);
    var h = get("height");
    h = h ? parseInt(h) : 200;
    specs.push("height=" + h);
    var win = globalThis.open("about:blank", target, specs.join(","));
    if(! win) caml_failwith("Graphics.open_graph: cannot open the window");
    var doc = win.document, canvas = doc.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    var ctx = caml_gr_state_create(canvas, w, h);
    ctx.set_title = function(title){doc.title = title;};
    caml_gr_state_set(ctx);
    var body = doc.body;
    body.style.margin = "0px";
    body.appendChild(canvas);
    return 0;
   }
   function caml_make_float_vect(len){
    if(len < 0) caml_array_bound_error();
    var len = len + 1 | 0, b = new Array(len);
    b[0] = 254;
    for(var i = 1; i < len; i++) b[i] = 0;
    return b;
   }
   function caml_cbrt_float(x){return Math.cbrt(x);}
   function caml_eventlog_pause(unit){return 0;}
   function caml_memprof_stop(unit){return 0;}
   function caml_greaterequal(x, y){
    return + (caml_compare_val(x, y, false) >= 0);
   }
   function caml_make_local_vect(v_len, v_elt){return caml_make_vect(v_len, v_elt);
   }
   function caml_get_exception_raw_backtrace(){return [0];}
   function caml_log1p_float(x){return Math.log1p(x);}
   function bigstringaf_blit_to_bigstring(src, src_off, dst, dst_off, len){return caml_bigstring_blit_ba_to_ba(src, src_off, dst, dst_off, len);
   }
   var ms_to_nano = caml_int64_of_int32(1000 * 1000);
   function time_now_nanoseconds_since_unix_epoch_or_zero(){
    var ms = Date.now(), ms_i63 = caml_int64_of_float(ms * 2);
    return caml_int64_mul(ms_i63, ms_to_nano);
   }
   function caml_runtime_events_free_cursor(cursor){return 0;}
   function caml_lazy_make_forward(v){return [250, v];}
   function lor_digit_nat(nat1, ofs1, nat2, ofs2){nat1.data[ofs1] |= nat2.data[ofs2]; return 0;
   }
   function caml_gr_blit_image(im, x, y){
    var
     s = caml_gr_state_get(),
     im2 =
       s.context.getImageData
        (x, s.height - im.height - y, im.width, im.height);
    for(var i = 0; i < im2.data.length; i += 4){
     im.data[i] = im2.data[i];
     im.data[i + 1] = im2.data[i + 1];
     im.data[i + 2] = im2.data[i + 2];
     im.data[i + 3] = im2.data[i + 3];
    }
    return 0;
   }
   function caml_gr_window_id(a){
    caml_failwith("caml_gr_window_id not Implemented");
   }
   function caml_atomic_make_contended(a){return [0, a];}
   function caml_js_on_ie(){
    var
     ua =
       globalThis.navigator && globalThis.navigator.userAgent
        ? globalThis.navigator.userAgent
        : "";
    return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0;
   }
   function caml_int64_shift_right(x, s){return x.shift_right(s);}
   function caml_ba_layout(ba){return ba.layout;}
   function caml_convert_raw_backtrace(){return [0];}
   function caml_array_set(array, index, newval){
    if(index < 0 || index >= array.length - 1) caml_array_bound_error();
    array[index + 1] = newval;
    return 0;
   }
   function caml_alloc_stack(hv, hx, hf){return 0;}
   function caml_bytes_greaterequal(s1, s2){return caml_bytes_lessequal(s2, s1);
   }
   function set_digit_nat(nat, ofs, digit){nat.data[ofs] = digit; return 0;}
   function caml_bytes_set16(s, i, i16){
    if(i >>> 0 >= s.l - 1) caml_bytes_bound_error();
    var b2 = 0xFF & i16 >> 8, b1 = 0xFF & i16;
    caml_bytes_unsafe_set(s, i + 0, b1);
    caml_bytes_unsafe_set(s, i + 1, b2);
    return 0;
   }
   function caml_gr_doc_of_state(state){
    if(state.canvas.ownerDocument) return state.canvas.ownerDocument;
   }
   function caml_ml_output_int(chanid, i){
    var
     arr = [i >> 24 & 0xFF, i >> 16 & 0xFF, i >> 8 & 0xFF, i & 0xFF],
     s = caml_string_of_array(arr);
    caml_ml_output(chanid, s, 0, 4);
    return 0;
   }
   function caml_obj_with_tag(tag, x){
    var l = x.length, a = new Array(l);
    a[0] = tag;
    for(var i = 1; i < l; i++) a[i] = x[i];
    return a;
   }
   function caml_ml_channel_size(chanid){
    var chan = caml_ml_channels[chanid];
    return chan.file.length();
   }
   function bin_prot_blit_string_buf_stub(src_pos, src, dst_pos, dst, len){
    return caml_bigstring_blit_string_to_ba(src, src_pos, dst, dst_pos, len);
   }
   function caml_raw_backtrace_slot(){
    caml_invalid_argument
     ("Printexc.get_raw_backtrace_slot: index out of bounds");
   }
   function caml_hexstring_of_float(x, prec, style){
    if(! isFinite(x)){
     if(isNaN(x)) return caml_string_of_jsstring("nan");
     return caml_string_of_jsstring(x > 0 ? "infinity" : "-infinity");
    }
    var sign = x == 0 && 1 / x == - Infinity ? 1 : x >= 0 ? 0 : 1;
    if(sign) x = - x;
    var exp = 0;
    if(x == 0)
     ;
    else if(x < 1)
     while(x < 1 && exp > - 1022){x *= 2; exp--;}
    else
     while(x >= 2){x /= 2; exp++;}
    var exp_sign = exp < 0 ? "" : "+", sign_str = "";
    if(sign)
     sign_str = "-";
    else
     switch(style){
       case 43:
        sign_str = "+"; break;
       case 32:
        sign_str = " "; break;
       default: break;
     }
    if(prec >= 0 && prec < 13){
     var cst = Math.pow(2, prec * 4);
     x = Math.round(x * cst) / cst;
    }
    var x_str = x.toString(16);
    if(prec >= 0){
     var idx = x_str.indexOf(".");
     if(idx < 0)
      x_str += "." + caml_str_repeat(prec, "0");
     else{
      var size = idx + 1 + prec;
      if(x_str.length < size)
       x_str += caml_str_repeat(size - x_str.length, "0");
      else
       x_str = x_str.substr(0, size);
     }
    }
    return caml_string_of_jsstring
            (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10));
   }
   function caml_runtime_events_user_write(event, event_content){return 0;}
   function caml_js_wrap_meth_callback_strict(arity, f){
    return function(){
     var args = new Array(arity + 1), len = Math.min(arguments.length, arity);
     args[0] = this;
     for(var i = 0; i < len; i++) args[i + 1] = arguments[i];
     return caml_callback(f, args);};
   }
   function caml_unix_readlink(name){
    var root = resolve_fs_device(name);
    if(! root.device.readlink)
     caml_failwith("caml_unix_readlink: not implemented");
    return root.device.readlink(root.rest, true);
   }
   function caml_backtrace_status(_unit){
    return caml_record_backtrace_flag ? 1 : 0;
   }
   function caml_install_signal_handler(){return 0;}
   function caml_sys_argv(a){return caml_argv;}
   function caml_ba_fill(ba, v){ba.fill(v); return 0;}
   function caml_modf_float(x){
    if(isFinite(x)){
     var neg = 1 / x < 0;
     x = Math.abs(x);
     var i = Math.floor(x), f = x - i;
     if(neg){i = - i; f = - f;}
     return [0, f, i];
    }
    if(isNaN(x)) return [0, NaN, NaN];
    return [0, 1 / x, x];
   }
   function caml_gc_get(){return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];}
   function caml_float_compare(x, y){
    if(x === y) return 0;
    if(x < y) return - 1;
    if(x > y) return 1;
    if(x === x) return 1;
    if(y === y) return - 1;
    return 0;
   }
   function caml_string_set32(s, i, i32){caml_failwith("caml_string_set32");}
   function caml_parse_engine(tables, env, cmd, arg){
    var
     ERRCODE = 256,
     loop = 6,
     testshift = 7,
     shift = 8,
     shift_recover = 9,
     reduce = 10,
     READ_TOKEN = 0,
     RAISE_PARSE_ERROR = 1,
     GROW_STACKS_1 = 2,
     GROW_STACKS_2 = 3,
     COMPUTE_SEMANTIC_ACTION = 4,
     CALL_ERROR_FUNCTION = 5,
     env_s_stack = 1,
     env_v_stack = 2,
     env_symb_start_stack = 3,
     env_symb_end_stack = 4,
     env_stacksize = 5,
     env_stackbase = 6,
     env_curr_char = 7,
     env_lval = 8,
     env_symb_start = 9,
     env_symb_end = 10,
     env_asp = 11,
     env_rule_len = 12,
     env_rule_number = 13,
     env_sp = 14,
     env_state = 15,
     env_errflag = 16,
     tbl_transl_const = 2,
     tbl_transl_block = 3,
     tbl_lhs = 4,
     tbl_len = 5,
     tbl_defred = 6,
     tbl_dgoto = 7,
     tbl_sindex = 8,
     tbl_rindex = 9,
     tbl_gindex = 10,
     tbl_tablesize = 11,
     tbl_table = 12,
     tbl_check = 13,
     tbl_names_const = 15,
     tbl_names_block = 16;
    function log(x){
     var s = caml_string_of_jsbytes(x + "\n");
     caml_ml_output(2, s, 0, caml_ml_string_length(s));
    }
    function token_name(names, number){
     var str = caml_jsstring_of_string(names);
     if(str[0] == "\x00") return "<unknown token>";
     return str.split("\x00")[number];
    }
    function print_token(state, tok){
     var token, kind;
     if(tok instanceof Array){
      token = token_name(tables[tbl_names_block], tok[0]);
      if(typeof tok[1] == "number")
       kind = "" + tok[1];
      else if(typeof tok[1] == "string")
       kind = tok[1];
      else if(tok[1] instanceof MlBytes)
       kind = caml_jsbytes_of_string(tok[1]);
      else
       kind = "_";
      log("State " + state + ": read token " + token + "(" + kind + ")");
     }
     else{
      token = token_name(tables[tbl_names_const], tok);
      log("State " + state + ": read token " + token);
     }
    }
    if(! tables.dgoto){
     tables.defred = caml_lex_array(tables[tbl_defred]);
     tables.sindex = caml_lex_array(tables[tbl_sindex]);
     tables.check = caml_lex_array(tables[tbl_check]);
     tables.rindex = caml_lex_array(tables[tbl_rindex]);
     tables.table = caml_lex_array(tables[tbl_table]);
     tables.len = caml_lex_array(tables[tbl_len]);
     tables.lhs = caml_lex_array(tables[tbl_lhs]);
     tables.gindex = caml_lex_array(tables[tbl_gindex]);
     tables.dgoto = caml_lex_array(tables[tbl_dgoto]);
    }
    var
     res = 0,
     n,
     n1,
     n2,
     state1,
     sp = env[env_sp],
     state = env[env_state],
     errflag = env[env_errflag];
    exit:
    for(;;)
     next:
     switch(cmd){
       case 0:
        state = 0; errflag = 0;
       case 6:
        n = tables.defred[state];
        if(n != 0){cmd = reduce; break;}
        if(env[env_curr_char] >= 0){cmd = testshift; break;}
        res = READ_TOKEN;
        break exit;
       case 1:
        if(arg instanceof Array){
         env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
         env[env_lval] = arg[1];
        }
        else{
         env[env_curr_char] = tables[tbl_transl_const][arg + 1];
         env[env_lval] = 0;
        }
        if(caml_parser_trace) print_token(state, arg);
       case 7:
        n1 = tables.sindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == env[env_curr_char]){cmd = shift; break;}
        n1 = tables.rindex[state];
        n2 = n1 + env[env_curr_char];
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == env[env_curr_char]){
         n = tables.table[n2];
         cmd = reduce;
         break;
        }
        if(errflag <= 0){res = CALL_ERROR_FUNCTION; break exit;}
       case 5:
        if(errflag < 3){
         errflag = 3;
         for(;;){
          state1 = env[env_s_stack][sp + 1];
          n1 = tables.sindex[state1];
          n2 = n1 + ERRCODE;
          if
           (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
            && tables.check[n2] == ERRCODE){
           if(caml_parser_trace) log("Recovering in state " + state1);
           cmd = shift_recover;
           break next;
          }
          else{
           if(caml_parser_trace) log("Discarding state " + state1);
           if(sp <= env[env_stackbase]){
            if(caml_parser_trace) log("No more states to discard");
            return RAISE_PARSE_ERROR;
           }
           sp--;
          }
         }
        }
        else{
         if(env[env_curr_char] == 0) return RAISE_PARSE_ERROR;
         if(caml_parser_trace) log("Discarding last token read");
         env[env_curr_char] = - 1;
         cmd = loop;
         break;
        }
       case 8:
        env[env_curr_char] = - 1; if(errflag > 0) errflag--;
       case 9:
        if(caml_parser_trace)
         log("State " + state + ": shift to state " + tables.table[n2]);
        state = tables.table[n2];
        sp++;
        if(sp >= env[env_stacksize]){res = GROW_STACKS_1; break exit;}
       case 2:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = env[env_lval];
        env[env_symb_start_stack][sp + 1] = env[env_symb_start];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end];
        cmd = loop;
        break;
       case 10:
        if(caml_parser_trace) log("State " + state + ": reduce by rule " + n);
        var m = tables.len[n];
        env[env_asp] = sp;
        env[env_rule_number] = n;
        env[env_rule_len] = m;
        sp = sp - m + 1;
        m = tables.lhs[n];
        state1 = env[env_s_stack][sp];
        n1 = tables.gindex[m];
        n2 = n1 + state1;
        if
         (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize]
          && tables.check[n2] == state1)
         state = tables.table[n2];
        else
         state = tables.dgoto[m];
        if(sp >= env[env_stacksize]){res = GROW_STACKS_2; break exit;}
       case 3:
        res = COMPUTE_SEMANTIC_ACTION; break exit;
       case 4:
        env[env_s_stack][sp + 1] = state;
        env[env_v_stack][sp + 1] = arg;
        var asp = env[env_asp];
        env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        if(sp > asp)
         env[env_symb_start_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
        cmd = loop;
        break;
       default: return RAISE_PARSE_ERROR;
     }
    env[env_sp] = sp;
    env[env_state] = state;
    env[env_errflag] = errflag;
    return res;
   }
   function caml_jsoo_flags_effects(unit){return 0;}
   function core_gc_major_words(){return 0;}
   function caml_update_dummy(x, y){
    if(y.fun){x.fun = y.fun; return 0;}
    if(typeof y === "function"){x.fun = y; return 0;}
    var i = y.length;
    while(i--) x[i] = y[i];
    return 0;
   }
   function caml_array_fill(array, ofs, len, v){
    for(var i = 0; i < len; i++) array[ofs + i + 1] = v;
    return 0;
   }
   function timezone_js_loader_create_zone(zone_name){
    zone_name = caml_jsstring_of_string(zone_name);
    return new globalThis.TemporalPolyfill.Temporal.TimeZone(zone_name);
   }
   function caml_sys_mkdir(name, perm){
    var root = resolve_fs_device(name);
    root.device.mkdir(root.rest, perm);
    return 0;
   }
   function bigstring_blit_stub(s1, i1, s2, i2, len){
    return caml_bigstring_blit_ba_to_ba(s1, i1, s2, i2, len);
   }
   function caml_string_notequal(s1, s2){
    return 1 - caml_string_equal(s1, s2);
   }
   function caml_bytes_greaterthan(s1, s2){return caml_bytes_lessthan(s2, s1);
   }
   function caml_gr_make_image(arr){
    var
     s = caml_gr_state_get(),
     h = arr.length - 1,
     w = arr[1].length - 1,
     im = s.context.createImageData(w, h);
    for(var i = 0; i < h; i++)
     for(var j = 0; j < w; j++){
      var c = arr[i + 1][j + 1], o = i * (w * 4) + j * 4;
      if(c == - 1){
       im.data[o + 0] = 0;
       im.data[o + 1] = 0;
       im.data[o + 2] = 0;
       im.data[o + 3] = 0;
      }
      else{
       im.data[o + 0] = c >> 16 & 0xff;
       im.data[o + 1] = c >> 8 & 0xff;
       im.data[o + 2] = c >> 0 & 0Xff;
       im.data[o + 3] = 0xff;
      }
     }
    return im;
   }
   function Base_int_math_int_popcount(v){
    v = v - (v >>> 1 & 0x55555555);
    v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
    return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
   }
   function caml_ml_set_channel_output(chanid, f){
    var chan = caml_ml_channels[chanid];
    chan.output = function(s){f(s);};
    return 0;
   }
   function caml_read_file_content(name){
    var
     name = typeof name == "string" ? caml_string_of_jsbytes(name) : name,
     root = resolve_fs_device(name);
    if(root.device.exists(root.rest)){
     var
      file = root.device.open(root.rest, {rdonly: 1}),
      len = file.length(),
      buf = new Uint8Array(len);
     file.read(0, buf, 0, len);
     return caml_string_of_array(buf);
    }
    caml_raise_no_such_file(caml_jsbytes_of_string(name));
   }
   function caml_js_to_float(x){return x;}
   function caml_setup_uncaught_exception_handler(){
    var process = globalThis.process;
    if(process && process.on)
     process.on
      ("uncaughtException",
       function(err, origin){
        caml_fatal_uncaught_exception(err);
        process.exit(2);
       });
    else if(globalThis.addEventListener)
     globalThis.addEventListener
      ("error",
       function(event){
        if(event.error) caml_fatal_uncaught_exception(event.error);
       });
   }
   caml_setup_uncaught_exception_handler();
   globalThis.jsoo_runtime =
    {bigstringaf_memchr: bigstringaf_memchr,
     bigstringaf_memcmp_string: bigstringaf_memcmp_string,
     bigstringaf_memcmp_bigstring: bigstringaf_memcmp_bigstring,
     bigstringaf_blit_from_bytes: bigstringaf_blit_from_bytes,
     bigstringaf_blit_to_bigstring: bigstringaf_blit_to_bigstring,
     bigstringaf_blit_to_bytes: bigstringaf_blit_to_bytes,
     timezone_js_loader_get_offset_nanos_for:
     timezone_js_loader_get_offset_nanos_for,
     timezone_js_loader_instant_plus_hours:
     timezone_js_loader_instant_plus_hours,
     timezone_js_loader_now: timezone_js_loader_now,
     timezone_js_loader_epoch_seconds: timezone_js_loader_epoch_seconds,
     timezone_js_loader_compare_instants: timezone_js_loader_compare_instants,
     timezone_js_loader_from_epoch_seconds:
     timezone_js_loader_from_epoch_seconds,
     timezone_js_loader_get_next_transition_or_this_time_if_none:
     timezone_js_loader_get_next_transition_or_this_time_if_none,
     timezone_js_loader_create_zone: timezone_js_loader_create_zone,
     timezone_js_loader_enable_for_testing:
     timezone_js_loader_enable_for_testing,
     timezone_js_loader_disable_for_testing:
     timezone_js_loader_disable_for_testing,
     should_use_timezone_js_loader: should_use_timezone_js_loader,
     bigstring_realloc: bigstring_realloc,
     bigstring_destroy_stub: bigstring_destroy_stub,
     core_md5_digest_subbigstring: core_md5_digest_subbigstring,
     core_md5_fd: core_md5_fd,
     core_gc_run_memprof_callbacks: core_gc_run_memprof_callbacks,
     core_gc_top_heap_words: core_gc_top_heap_words,
     core_gc_promoted_words: core_gc_promoted_words,
     core_gc_minor_words: core_gc_minor_words,
     core_gc_minor_collections: core_gc_minor_collections,
     core_gc_major_words: core_gc_major_words,
     core_gc_major_plus_minor_words: core_gc_major_plus_minor_words,
     core_gc_major_collections: core_gc_major_collections,
     core_gc_heap_words: core_gc_heap_words,
     core_gc_heap_chunks: core_gc_heap_chunks,
     core_gc_compactions: core_gc_compactions,
     core_time_ns_format: core_time_ns_format,
     core_array_unsafe_float_blit: core_array_unsafe_float_blit,
     core_array_unsafe_int_blit: core_array_unsafe_int_blit,
     core_heap_block_is_heap_block: core_heap_block_is_heap_block,
     bigstring_memmem_bytecode: bigstring_memmem_bytecode,
     bigstring_find: bigstring_find,
     internalhash_fold_bigstring: internalhash_fold_bigstring,
     bigstring_memcmp_bytes_stub: bigstring_memcmp_bytes_stub,
     bigstring_memcmp_stub: bigstring_memcmp_stub,
     bigstring_memset_stub: bigstring_memset_stub,
     bigstring_blit_string_bigstring_stub:
     bigstring_blit_string_bigstring_stub,
     bigstring_blit_bigstring_bytes_stub: bigstring_blit_bigstring_bytes_stub,
     bigstring_blit_bytes_bigstring_stub: bigstring_blit_bytes_bigstring_stub,
     bigstring_blit_stub: bigstring_blit_stub,
     bigstring_is_mmapped_stub: bigstring_is_mmapped_stub,
     bigstring_alloc_v2: bigstring_alloc_v2,
     ppx_expect_runtime_flush_stubs_streams:
     ppx_expect_runtime_flush_stubs_streams,
     ppx_expect_runtime_out_channel_position:
     ppx_expect_runtime_out_channel_position,
     ppx_expect_runtime_after_test: ppx_expect_runtime_after_test,
     ppx_expect_runtime_before_test: ppx_expect_runtime_before_test,
     ppx_expect_runtime_saved_stderr: ppx_expect_runtime_saved_stderr,
     ppx_expect_runtime_saved_stdout: ppx_expect_runtime_saved_stdout,
     time_now_nanosecond_counter_for_timing:
     time_now_nanosecond_counter_for_timing,
     ms_float_to_ns_int64: ms_float_to_ns_int64,
     time_now_nanoseconds_since_unix_epoch_or_zero:
     time_now_nanoseconds_since_unix_epoch_or_zero,
     bin_prot_blit_buf_stub: bin_prot_blit_buf_stub,
     bin_prot_blit_bytes_buf_stub: bin_prot_blit_bytes_buf_stub,
     bin_prot_blit_string_buf_stub: bin_prot_blit_string_buf_stub,
     bin_prot_blit_float_array_buf_stub: bin_prot_blit_float_array_buf_stub,
     bin_prot_blit_buf_bytes_stub: bin_prot_blit_buf_bytes_stub,
     bin_prot_blit_buf_float_array_stub: bin_prot_blit_buf_float_array_stub,
     caml_check_bound_bigstring: caml_check_bound_bigstring,
     caml_dummy_obj_is_stack: caml_dummy_obj_is_stack,
     caml_make_local_vect: caml_make_local_vect,
     Base_unsafe_create_local_bytes: Base_unsafe_create_local_bytes,
     Base_am_testing: Base_am_testing,
     Base_hash_double: Base_hash_double,
     Base_hash_string: Base_hash_string,
     Base_int_math_int64_pow_stub: Base_int_math_int64_pow_stub,
     Base_int_math_int_pow_stub: Base_int_math_int_pow_stub,
     Base_int_math_int64_ctz: Base_int_math_int64_ctz,
     Base_int_math_nativeint_ctz: Base_int_math_nativeint_ctz,
     Base_int_math_int_ctz: Base_int_math_int_ctz,
     Base_int_math_int32_ctz: Base_int_math_int32_ctz,
     Base_int_math_int64_clz: Base_int_math_int64_clz,
     Base_int_math_nativeint_clz: Base_int_math_nativeint_clz,
     Base_int_math_int_clz: Base_int_math_int_clz,
     Base_int_math_int32_clz: Base_int_math_int32_clz,
     Base_caml_exn_is_most_recent_exn: Base_caml_exn_is_most_recent_exn,
     Base_clear_caml_backtrace_pos: Base_clear_caml_backtrace_pos,
     Base_int_math_int_popcount: Base_int_math_int_popcount,
     caml_sse2_float64_max_bytecode: caml_sse2_float64_max_bytecode,
     caml_sse2_float64_min_bytecode: caml_sse2_float64_min_bytecode,
     caml_csel_value: caml_csel_value,
     Base_internalhash_get_hash_value: Base_internalhash_get_hash_value,
     Base_internalhash_fold_string: Base_internalhash_fold_string,
     Base_internalhash_fold_float: Base_internalhash_fold_float,
     Base_internalhash_fold_int: Base_internalhash_fold_int,
     Base_internalhash_fold_int64: Base_internalhash_fold_int64,
     caml_runtime_events_read_poll: caml_runtime_events_read_poll,
     caml_runtime_events_free_cursor: caml_runtime_events_free_cursor,
     caml_runtime_events_create_cursor: caml_runtime_events_create_cursor,
     caml_runtime_events_resume: caml_runtime_events_resume,
     caml_runtime_events_pause: caml_runtime_events_pause,
     caml_runtime_events_start: caml_runtime_events_start,
     caml_runtime_events_user_resolve: caml_runtime_events_user_resolve,
     caml_runtime_events_user_write: caml_runtime_events_user_write,
     caml_runtime_events_user_register: caml_runtime_events_user_register,
     caml_custom_event_index: caml_custom_event_index,
     caml_zstd_initialize: caml_zstd_initialize,
     caml_decompress_input: caml_decompress_input,
     zstd_decompress: zstd_decompress,
     jsoo_effect_not_supported: jsoo_effect_not_supported,
     caml_ml_condition_signal: caml_ml_condition_signal,
     caml_ml_condition_broadcast: caml_ml_condition_broadcast,
     caml_ml_condition_wait: caml_ml_condition_wait,
     caml_ml_condition_new: caml_ml_condition_new,
     caml_get_continuation_callstack: caml_get_continuation_callstack,
     caml_continuation_use_and_update_handler_noexc:
     caml_continuation_use_and_update_handler_noexc,
     caml_continuation_use_noexc: caml_continuation_use_noexc,
     caml_alloc_stack: caml_alloc_stack,
     caml_ml_mutex_unlock: caml_ml_mutex_unlock,
     caml_ml_mutex_try_lock: caml_ml_mutex_try_lock,
     caml_ml_mutex_lock: caml_ml_mutex_lock,
     caml_ml_mutex_new: caml_ml_mutex_new,
     MlMutex: MlMutex,
     caml_lxm_next: caml_lxm_next,
     caml_ml_domain_cpu_relax: caml_ml_domain_cpu_relax,
     caml_ml_domain_id: caml_ml_domain_id,
     caml_domain_spawn: caml_domain_spawn,
     caml_domain_id: caml_domain_id,
     caml_recommended_domain_count: caml_recommended_domain_count,
     caml_ml_domain_set_name: caml_ml_domain_set_name,
     caml_ml_domain_unique_token: caml_ml_domain_unique_token,
     caml_atomic_make_contended: caml_atomic_make_contended,
     caml_atomic_exchange: caml_atomic_exchange,
     caml_atomic_fetch_add: caml_atomic_fetch_add,
     caml_atomic_cas: caml_atomic_cas,
     caml_atomic_load: caml_atomic_load,
     caml_domain_dls_get: caml_domain_dls_get,
     caml_domain_dls_set: caml_domain_dls_set,
     caml_domain_dls: caml_domain_dls,
     caml_ephe_check_data: caml_ephe_check_data,
     caml_ephe_unset_data: caml_ephe_unset_data,
     caml_ephe_set_data: caml_ephe_set_data,
     caml_ephe_get_data_copy: caml_ephe_get_data_copy,
     caml_ephe_get_data: caml_ephe_get_data,
     caml_ephe_blit_data: caml_ephe_blit_data,
     caml_ephe_blit_key: caml_ephe_blit_key,
     caml_ephe_check_key: caml_ephe_check_key,
     caml_ephe_get_key_copy: caml_ephe_get_key_copy,
     caml_ephe_get_key: caml_ephe_get_key,
     caml_weak_set: caml_weak_set,
     caml_weak_create: caml_weak_create,
     caml_ephe_create: caml_ephe_create,
     caml_ephe_unset_key: caml_ephe_unset_key,
     caml_ephe_set_key: caml_ephe_set_key,
     caml_ephe_data_offset: caml_ephe_data_offset,
     caml_ephe_key_offset: caml_ephe_key_offset,
     caml_unix_inet_addr_of_string: caml_unix_inet_addr_of_string,
     caml_unix_findclose: caml_unix_findclose,
     caml_unix_findnext: caml_unix_findnext,
     caml_unix_findfirst: caml_unix_findfirst,
     caml_unix_rewinddir: caml_unix_rewinddir,
     caml_unix_closedir: caml_unix_closedir,
     caml_unix_readdir: caml_unix_readdir,
     caml_unix_opendir: caml_unix_opendir,
     caml_unix_has_symlink: caml_unix_has_symlink,
     caml_unix_getpwuid: caml_unix_getpwuid,
     caml_unix_getuid: caml_unix_getuid,
     caml_unix_unlink: caml_unix_unlink,
     caml_unix_readlink: caml_unix_readlink,
     caml_unix_symlink: caml_unix_symlink,
     caml_unix_rmdir: caml_unix_rmdir,
     caml_unix_mkdir: caml_unix_mkdir,
     caml_unix_lstat_64: caml_unix_lstat_64,
     caml_unix_lstat: caml_unix_lstat,
     caml_unix_stat_64: caml_unix_stat_64,
     caml_unix_stat: caml_unix_stat,
     make_unix_err_args: make_unix_err_args,
     caml_unix_isatty: caml_unix_isatty,
     caml_unix_filedescr_of_fd: caml_unix_filedescr_of_fd,
     caml_unix_cleanup: caml_unix_cleanup,
     caml_unix_startup: caml_unix_startup,
     caml_unix_mktime: caml_unix_mktime,
     caml_unix_localtime: caml_unix_localtime,
     caml_unix_gmtime: caml_unix_gmtime,
     caml_unix_time: caml_unix_time,
     caml_unix_gettimeofday: caml_unix_gettimeofday,
     caml_str_initialize: caml_str_initialize,
     re_replacement_text: re_replacement_text,
     re_partial_match: re_partial_match,
     re_string_match: re_string_match,
     re_search_backward: re_search_backward,
     re_search_forward: re_search_forward,
     re_match: re_match,
     caml_sys_is_regular_file: caml_sys_is_regular_file,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime: caml_register_channel_for_spacetime,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_spacetime_enabled: caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled: caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings: caml_ml_enable_runtime_warnings,
     caml_runtime_warnings: caml_runtime_warnings,
     caml_install_signal_handler: caml_install_signal_handler,
     caml_runtime_parameters: caml_runtime_parameters,
     caml_runtime_variant: caml_runtime_variant,
     caml_sys_isatty: caml_sys_isatty,
     caml_sys_get_config: caml_sys_get_config,
     os_type: os_type,
     caml_sys_const_backend_type: caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin: caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32: caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix: caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize: caml_sys_const_max_wosize,
     caml_sys_const_int_size: caml_sys_const_int_size,
     caml_sys_const_word_size: caml_sys_const_word_size,
     caml_sys_const_big_endian: caml_sys_const_big_endian,
     caml_sys_random_seed: caml_sys_random_seed,
     caml_sys_time_include_children: caml_sys_time_include_children,
     caml_sys_time: caml_sys_time,
     caml_sys_system_command: caml_sys_system_command,
     caml_sys_executable_name: caml_sys_executable_name,
     caml_sys_modify_argv: caml_sys_modify_argv,
     caml_sys_argv: caml_sys_argv,
     caml_sys_get_argv: caml_sys_get_argv,
     caml_executable_name: caml_executable_name,
     caml_argv: caml_argv,
     caml_sys_unsafe_getenv: caml_sys_unsafe_getenv,
     caml_sys_getenv: caml_sys_getenv,
     jsoo_sys_getenv: jsoo_sys_getenv,
     caml_set_static_env: caml_set_static_env,
     caml_fatal_uncaught_exception: caml_fatal_uncaught_exception,
     caml_format_exception: caml_format_exception,
     caml_is_special_exception: caml_is_special_exception,
     caml_sys_exit: caml_sys_exit,
     caml_raise_sys_error: caml_raise_sys_error,
     caml_maybe_print_stats: caml_maybe_print_stats,
     caml_is_printable: caml_is_printable,
     caml_get_global_data: caml_get_global_data,
     caml_register_global: caml_register_global,
     caml_build_symbols: caml_build_symbols,
     caml_global_data: caml_global_data,
     caml_named_value: caml_named_value,
     caml_register_named_value: caml_register_named_value,
     caml_named_values: caml_named_values,
     caml_call_gen: caml_call_gen,
     caml_set_parser_trace: caml_set_parser_trace,
     caml_parse_engine: caml_parse_engine,
     caml_parser_trace: caml_parser_trace,
     caml_is_continuation_tag: caml_is_continuation_tag,
     caml_lazy_read_result: caml_lazy_read_result,
     caml_lazy_reset_to_lazy: caml_lazy_reset_to_lazy,
     caml_lazy_update_to_forward: caml_lazy_update_to_forward,
     caml_lazy_update_to_forcing: caml_lazy_update_to_forcing,
     caml_obj_update_tag: caml_obj_update_tag,
     caml_obj_add_offset: caml_obj_add_offset,
     caml_obj_reachable_words: caml_obj_reachable_words,
     caml_obj_set_raw_field: caml_obj_set_raw_field,
     caml_obj_raw_field: caml_obj_raw_field,
     caml_fresh_oo_id: caml_fresh_oo_id,
     caml_set_oo_id: caml_set_oo_id,
     caml_oo_last_id: caml_oo_last_id,
     caml_get_public_method: caml_get_public_method,
     caml_lazy_make_forward: caml_lazy_make_forward,
     caml_obj_is_shared: caml_obj_is_shared,
     caml_obj_compare_and_swap: caml_obj_compare_and_swap,
     caml_obj_make_forward: caml_obj_make_forward,
     caml_obj_truncate: caml_obj_truncate,
     caml_obj_dup: caml_obj_dup,
     caml_obj_with_tag: caml_obj_with_tag,
     caml_obj_block: caml_obj_block,
     caml_obj_set_tag: caml_obj_set_tag,
     caml_obj_tag: caml_obj_tag,
     caml_obj_is_block: caml_obj_is_block,
     caml_alloc_dummy_infix: caml_alloc_dummy_infix,
     caml_update_dummy: caml_update_dummy,
     deserialize_nat: deserialize_nat,
     serialize_nat: serialize_nat,
     lxor_digit_nat: lxor_digit_nat,
     lor_digit_nat: lor_digit_nat,
     land_digit_nat: land_digit_nat,
     compare_nat_real: compare_nat_real,
     compare_nat: compare_nat,
     compare_digits_nat: compare_digits_nat,
     shift_right_nat: shift_right_nat,
     div_nat: div_nat,
     div_digit_nat: div_digit_nat,
     div_helper: div_helper,
     shift_left_nat: shift_left_nat,
     square_nat: square_nat,
     mult_nat: mult_nat,
     mult_digit_nat: mult_digit_nat,
     sub_nat: sub_nat,
     decr_nat: decr_nat,
     complement_nat: complement_nat,
     add_nat: add_nat,
     incr_nat: incr_nat,
     is_digit_odd: is_digit_odd,
     is_digit_zero: is_digit_zero,
     is_digit_int: is_digit_int,
     num_leading_zero_bits_in_digit: num_leading_zero_bits_in_digit,
     num_digits_nat: num_digits_nat,
     nth_digit_nat_native: nth_digit_nat_native,
     set_digit_nat_native: set_digit_nat_native,
     nth_digit_nat: nth_digit_nat,
     set_digit_nat: set_digit_nat,
     blit_nat: blit_nat,
     set_to_zero_nat: set_to_zero_nat,
     create_nat: create_nat,
     nat_of_array: nat_of_array,
     length_nat: length_nat,
     caml_hash_nat: caml_hash_nat,
     MlNat: MlNat,
     initialize_nat: initialize_nat,
     caml_array_of_bytes: caml_array_of_bytes,
     caml_array_of_string: caml_array_of_string,
     caml_js_to_string: caml_js_to_string,
     caml_to_js_string: caml_to_js_string,
     caml_js_from_string: caml_js_from_string,
     caml_new_string: caml_new_string,
     caml_js_to_byte_string: caml_js_to_byte_string,
     caml_is_ml_string: caml_is_ml_string,
     caml_ml_bytes_content: caml_ml_bytes_content,
     caml_is_ml_bytes: caml_is_ml_bytes,
     caml_bytes_of_jsbytes: caml_bytes_of_jsbytes,
     caml_string_of_jsstring: caml_string_of_jsstring,
     caml_jsstring_of_string: caml_jsstring_of_string,
     caml_jsbytes_of_string: caml_jsbytes_of_string,
     caml_string_of_jsbytes: caml_string_of_jsbytes,
     caml_bytes_of_string: caml_bytes_of_string,
     caml_string_of_bytes: caml_string_of_bytes,
     caml_string_lessthan: caml_string_lessthan,
     caml_string_lessequal: caml_string_lessequal,
     caml_string_equal: caml_string_equal,
     caml_string_compare: caml_string_compare,
     caml_ml_string_length: caml_ml_string_length,
     caml_string_unsafe_set: caml_string_unsafe_set,
     caml_string_unsafe_get: caml_string_unsafe_get,
     caml_ml_bytes_length: caml_ml_bytes_length,
     caml_blit_string: caml_blit_string,
     caml_blit_bytes: caml_blit_bytes,
     caml_fill_bytes: caml_fill_bytes,
     caml_bytes_greaterthan: caml_bytes_greaterthan,
     caml_string_greaterthan: caml_string_greaterthan,
     caml_bytes_greaterequal: caml_bytes_greaterequal,
     caml_string_greaterequal: caml_string_greaterequal,
     caml_bytes_lessthan: caml_bytes_lessthan,
     caml_bytes_lessequal: caml_bytes_lessequal,
     caml_bytes_notequal: caml_bytes_notequal,
     caml_string_notequal: caml_string_notequal,
     caml_bytes_equal: caml_bytes_equal,
     caml_bytes_compare: caml_bytes_compare,
     caml_bytes_of_array: caml_bytes_of_array,
     caml_string_of_array: caml_string_of_array,
     caml_create_bytes: caml_create_bytes,
     caml_create_string: caml_create_string,
     caml_uint8_array_of_string: caml_uint8_array_of_string,
     caml_uint8_array_of_bytes: caml_uint8_array_of_bytes,
     caml_convert_bytes_to_array: caml_convert_bytes_to_array,
     caml_convert_string_to_bytes: caml_convert_string_to_bytes,
     MlBytes: MlBytes,
     caml_bytes_of_utf16_jsstring: caml_bytes_of_utf16_jsstring,
     caml_bytes_set: caml_bytes_set,
     caml_string_set64: caml_string_set64,
     caml_bytes_set64: caml_bytes_set64,
     caml_string_set32: caml_string_set32,
     caml_bytes_set32: caml_bytes_set32,
     caml_string_set16: caml_string_set16,
     caml_bytes_set16: caml_bytes_set16,
     caml_string_set: caml_string_set,
     caml_bytes_get: caml_bytes_get,
     caml_bytes_get64: caml_bytes_get64,
     caml_string_get64: caml_string_get64,
     caml_bytes_get32: caml_bytes_get32,
     caml_string_get32: caml_string_get32,
     caml_bytes_get16: caml_bytes_get16,
     caml_string_get16: caml_string_get16,
     caml_string_get: caml_string_get,
     caml_bytes_bound_error: caml_bytes_bound_error,
     caml_string_bound_error: caml_string_bound_error,
     caml_bytes_unsafe_set: caml_bytes_unsafe_set,
     caml_bytes_unsafe_get: caml_bytes_unsafe_get,
     jsoo_is_ascii: jsoo_is_ascii,
     caml_utf16_of_utf8: caml_utf16_of_utf8,
     caml_utf8_of_utf16: caml_utf8_of_utf16,
     caml_subarray_to_jsbytes: caml_subarray_to_jsbytes,
     caml_str_repeat: caml_str_repeat,
     caml_md5_bytes: caml_md5_bytes,
     caml_MD5Final: caml_MD5Final,
     caml_MD5Update: caml_MD5Update,
     caml_MD5Init: caml_MD5Init,
     caml_MD5Transform: caml_MD5Transform,
     caml_md5_string: caml_md5_string,
     caml_md5_chan: caml_md5_chan,
     caml_output_value_to_buffer: caml_output_value_to_buffer,
     caml_output_value_to_bytes: caml_output_value_to_bytes,
     caml_output_value_to_string: caml_output_value_to_string,
     caml_output_val: caml_output_val,
     MlObjectTable: MlObjectTable,
     caml_marshal_data_size: caml_marshal_data_size,
     caml_marshal_header_size: caml_marshal_header_size,
     caml_input_value_from_reader: caml_input_value_from_reader,
     caml_custom_ops: caml_custom_ops,
     caml_nativeint_unmarshal: caml_nativeint_unmarshal,
     caml_int32_unmarshal: caml_int32_unmarshal,
     caml_int64_marshal: caml_int64_marshal,
     caml_int64_unmarshal: caml_int64_unmarshal,
     caml_input_value_from_bytes: caml_input_value_from_bytes,
     caml_input_value_from_string: caml_input_value_from_string,
     caml_float_of_bytes: caml_float_of_bytes,
     BigStringReader: BigStringReader,
     MlStringReader: MlStringReader,
     UInt8ArrayReader: UInt8ArrayReader,
     caml_marshal_constants: caml_marshal_constants,
     caml_new_lex_engine: caml_new_lex_engine,
     caml_lex_engine: caml_lex_engine,
     caml_lex_array: caml_lex_array,
     caml_js_error_of_exception: caml_js_error_of_exception,
     caml_xmlhttprequest_create: caml_xmlhttprequest_create,
     caml_js_get_console: caml_js_get_console,
     caml_js_html_entities: caml_js_html_entities,
     caml_js_html_escape: caml_js_html_escape,
     caml_js_on_ie: caml_js_on_ie,
     caml_js_object: caml_js_object,
     caml_pure_js_expr: caml_pure_js_expr,
     caml_js_expr: caml_js_expr,
     caml_js_eval_string: caml_js_eval_string,
     caml_js_strict_equals: caml_js_strict_equals,
     caml_js_equals: caml_js_equals,
     caml_js_function_arity: caml_js_function_arity,
     caml_js_wrap_meth_callback_unsafe: caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict: caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:
     caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback: caml_js_wrap_meth_callback,
     caml_js_wrap_callback_unsafe: caml_js_wrap_callback_unsafe,
     caml_js_wrap_callback_strict: caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments: caml_js_wrap_callback_arguments,
     caml_js_wrap_callback: caml_js_wrap_callback,
     caml_ojs_new_arr: caml_ojs_new_arr,
     caml_js_new: caml_js_new,
     caml_js_meth_call: caml_js_meth_call,
     caml_js_fun_call: caml_js_fun_call,
     caml_js_call: caml_js_call,
     caml_js_var: caml_js_var,
     caml_list_to_js_array: caml_list_to_js_array,
     caml_list_of_js_array: caml_list_of_js_array,
     caml_js_to_array: caml_js_to_array,
     caml_js_from_array: caml_js_from_array,
     caml_js_to_int32: caml_js_to_int32,
     caml_js_to_float: caml_js_to_float,
     caml_js_from_float: caml_js_from_float,
     caml_js_to_bool: caml_js_to_bool,
     caml_js_from_bool: caml_js_from_bool,
     caml_js_error_option_of_exception: caml_js_error_option_of_exception,
     caml_exn_with_js_backtrace: caml_exn_with_js_backtrace,
     caml_maybe_attach_backtrace: caml_maybe_attach_backtrace,
     caml_wrap_exception: caml_wrap_exception,
     caml_jsoo_flags_effects: caml_jsoo_flags_effects,
     caml_jsoo_flags_use_js_string: caml_jsoo_flags_use_js_string,
     caml_is_js: caml_is_js,
     caml_callback: caml_callback,
     caml_trampoline_return: caml_trampoline_return,
     caml_trampoline: caml_trampoline,
     caml_js_typeof: caml_js_typeof,
     caml_js_instanceof: caml_js_instanceof,
     caml_js_delete: caml_js_delete,
     caml_js_get: caml_js_get,
     caml_js_set: caml_js_set,
     caml_js_pure_expr: caml_js_pure_expr,
     caml_ml_set_buffered: caml_ml_set_buffered,
     caml_ml_is_buffered: caml_ml_is_buffered,
     caml_ml_output_int: caml_ml_output_int,
     caml_ml_pos_out_64: caml_ml_pos_out_64,
     caml_ml_pos_out: caml_ml_pos_out,
     caml_pos_out: caml_pos_out,
     caml_ml_seek_out_64: caml_ml_seek_out_64,
     caml_ml_seek_out: caml_ml_seek_out,
     caml_seek_out: caml_seek_out,
     caml_output_value: caml_output_value,
     caml_ml_output_char: caml_ml_output_char,
     caml_ml_output: caml_ml_output,
     caml_ml_output_bigarray: caml_ml_output_bigarray,
     caml_ml_output_bytes: caml_ml_output_bytes,
     caml_ml_output_ta: caml_ml_output_ta,
     caml_ml_flush: caml_ml_flush,
     caml_ml_input_scan_line: caml_ml_input_scan_line,
     caml_ml_pos_in_64: caml_ml_pos_in_64,
     caml_ml_pos_in: caml_ml_pos_in,
     caml_pos_in: caml_pos_in,
     caml_ml_seek_in_64: caml_ml_seek_in_64,
     caml_ml_seek_in: caml_ml_seek_in,
     caml_seek_in: caml_seek_in,
     caml_ml_input_int: caml_ml_input_int,
     caml_ml_input_char: caml_ml_input_char,
     caml_input_value_to_outside_heap: caml_input_value_to_outside_heap,
     caml_input_value: caml_input_value,
     caml_ml_input_block: caml_ml_input_block,
     caml_ml_input_bigarray: caml_ml_input_bigarray,
     caml_ml_input: caml_ml_input,
     caml_refill: caml_refill,
     caml_ml_set_channel_refill: caml_ml_set_channel_refill,
     caml_ml_set_channel_output: caml_ml_set_channel_output,
     caml_ml_channel_size_64: caml_ml_channel_size_64,
     caml_ml_channel_size: caml_ml_channel_size,
     caml_ml_close_channel: caml_ml_close_channel,
     caml_ml_set_binary_mode: caml_ml_set_binary_mode,
     caml_channel_descriptor: caml_channel_descriptor,
     caml_ml_open_descriptor_out_with_flags:
     caml_ml_open_descriptor_out_with_flags,
     caml_ml_open_descriptor_in_with_flags:
     caml_ml_open_descriptor_in_with_flags,
     caml_ml_open_descriptor_in: caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out: caml_ml_open_descriptor_out,
     caml_ml_out_channels_list: caml_ml_out_channels_list,
     caml_ml_channels: caml_ml_channels,
     caml_ml_set_channel_name: caml_ml_set_channel_name,
     caml_sys_open: caml_sys_open,
     caml_sys_close: caml_sys_close,
     caml_sys_fds: caml_sys_fds,
     caml_int64_bswap: caml_int64_bswap,
     caml_int32_bswap: caml_int32_bswap,
     caml_bswap16: caml_bswap16,
     caml_mod: caml_mod,
     caml_div: caml_div,
     caml_mul: caml_mul,
     caml_int_of_string: caml_int_of_string,
     caml_parse_digit: caml_parse_digit,
     caml_parse_sign_and_base: caml_parse_sign_and_base,
     caml_format_int: caml_format_int,
     caml_int64_hash: caml_int64_hash,
     caml_int64_to_bytes: caml_int64_to_bytes,
     caml_int64_of_bytes: caml_int64_of_bytes,
     caml_int64_hi32: caml_int64_hi32,
     caml_int64_lo32: caml_int64_lo32,
     caml_int64_create_lo_hi: caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi: caml_int64_create_lo_mi_hi,
     caml_int64_of_string: caml_int64_of_string,
     caml_int64_format: caml_int64_format,
     caml_int64_of_float: caml_int64_of_float,
     caml_int64_to_float: caml_int64_to_float,
     caml_int64_to_int32: caml_int64_to_int32,
     caml_int64_of_int32: caml_int64_of_int32,
     caml_int64_mod: caml_int64_mod,
     caml_int64_div: caml_int64_div,
     caml_int64_shift_right: caml_int64_shift_right,
     caml_int64_shift_right_unsigned: caml_int64_shift_right_unsigned,
     caml_int64_shift_left: caml_int64_shift_left,
     caml_int64_xor: caml_int64_xor,
     caml_int64_or: caml_int64_or,
     caml_int64_and: caml_int64_and,
     caml_int64_is_negative: caml_int64_is_negative,
     caml_int64_is_zero: caml_int64_is_zero,
     caml_int64_mul: caml_int64_mul,
     caml_int64_sub: caml_int64_sub,
     caml_int64_add: caml_int64_add,
     caml_int64_neg: caml_int64_neg,
     caml_int64_compare: caml_int64_compare,
     caml_int64_ult: caml_int64_ult,
     MlInt64: MlInt64,
     caml_int64_offset: caml_int64_offset,
     caml_float_of_string: caml_float_of_string,
     caml_format_float: caml_format_float,
     caml_fma_float: caml_fma_float,
     caml_erfc_float: caml_erfc_float,
     caml_erf_float: caml_erf_float,
     caml_cbrt_float: caml_cbrt_float,
     caml_round_float: caml_round_float,
     caml_atanh_float: caml_atanh_float,
     caml_tanh_float: caml_tanh_float,
     caml_asinh_float: caml_asinh_float,
     caml_sinh_float: caml_sinh_float,
     caml_acosh_float: caml_acosh_float,
     caml_cosh_float: caml_cosh_float,
     caml_log10_float: caml_log10_float,
     caml_hypot_float: caml_hypot_float,
     caml_log2_float: caml_log2_float,
     caml_log1p_float: caml_log1p_float,
     caml_exp2_float: caml_exp2_float,
     caml_expm1_float: caml_expm1_float,
     caml_signbit_float: caml_signbit_float,
     caml_copysign_float: caml_copysign_float,
     caml_float_compare: caml_float_compare,
     caml_frexp_float: caml_frexp_float,
     caml_ldexp_float: caml_ldexp_float,
     caml_modf_float: caml_modf_float,
     caml_classify_float: caml_classify_float,
     caml_int32_float_of_bits: caml_int32_float_of_bits,
     caml_trunc_float: caml_trunc_float,
     caml_nextafter_float: caml_nextafter_float,
     caml_int64_float_of_bits: caml_int64_float_of_bits,
     caml_hexstring_of_float: caml_hexstring_of_float,
     caml_int32_bits_of_float: caml_int32_bits_of_float,
     caml_int64_bits_of_float: caml_int64_bits_of_float,
     jsoo_floor_log2: jsoo_floor_log2,
     caml_string_hash: caml_string_hash,
     caml_hash: caml_hash,
     caml_hash_mix_string: caml_hash_mix_string,
     caml_hash_mix_bytes: caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr: caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes: caml_hash_mix_jsbytes,
     caml_hash_mix_int64: caml_hash_mix_int64,
     caml_hash_mix_float: caml_hash_mix_float,
     caml_hash_mix_final: caml_hash_mix_final,
     caml_hash_mix_int: caml_hash_mix_int,
     caml_gr_close_subwindow: caml_gr_close_subwindow,
     caml_gr_open_subwindow: caml_gr_open_subwindow,
     caml_gr_window_id: caml_gr_window_id,
     caml_gr_display_mode: caml_gr_display_mode,
     caml_gr_remember_mode: caml_gr_remember_mode,
     caml_gr_synchronize: caml_gr_synchronize,
     caml_gr_wait_event: caml_gr_wait_event,
     caml_gr_sigio_signal: caml_gr_sigio_signal,
     caml_gr_sigio_handler: caml_gr_sigio_handler,
     caml_gr_blit_image: caml_gr_blit_image,
     caml_gr_create_image: caml_gr_create_image,
     caml_gr_draw_image: caml_gr_draw_image,
     caml_gr_dump_image: caml_gr_dump_image,
     caml_gr_make_image: caml_gr_make_image,
     caml_gr_text_size: caml_gr_text_size,
     caml_gr_set_text_size: caml_gr_set_text_size,
     caml_gr_set_font: caml_gr_set_font,
     caml_gr_draw_string: caml_gr_draw_string,
     caml_gr_draw_char: caml_gr_draw_char,
     caml_gr_draw_str: caml_gr_draw_str,
     caml_gr_fill_arc: caml_gr_fill_arc,
     caml_gr_fill_poly: caml_gr_fill_poly,
     caml_gr_fill_rect: caml_gr_fill_rect,
     caml_gr_set_line_width: caml_gr_set_line_width,
     caml_gr_draw_arc: caml_gr_draw_arc,
     caml_gr_arc_aux: caml_gr_arc_aux,
     caml_gr_draw_rect: caml_gr_draw_rect,
     caml_gr_lineto: caml_gr_lineto,
     caml_gr_current_y: caml_gr_current_y,
     caml_gr_current_x: caml_gr_current_x,
     caml_gr_moveto: caml_gr_moveto,
     caml_gr_point_color: caml_gr_point_color,
     caml_gr_plot: caml_gr_plot,
     caml_gr_set_color: caml_gr_set_color,
     caml_gr_size_y: caml_gr_size_y,
     caml_gr_size_x: caml_gr_size_x,
     caml_gr_clear_graph: caml_gr_clear_graph,
     caml_gr_resize_window: caml_gr_resize_window,
     caml_gr_set_window_title: caml_gr_set_window_title,
     caml_gr_close_graph: caml_gr_close_graph,
     caml_gr_doc_of_state: caml_gr_doc_of_state,
     caml_gr_state_create: caml_gr_state_create,
     caml_gr_state_init: caml_gr_state_init,
     caml_gr_open_graph: caml_gr_open_graph,
     caml_gr_state_set: caml_gr_state_set,
     caml_gr_state_get: caml_gr_state_get,
     caml_gr_state: caml_gr_state,
     caml_get_major_credit: caml_get_major_credit,
     caml_get_major_bucket: caml_get_major_bucket,
     caml_get_minor_free: caml_get_minor_free,
     caml_gc_minor_words: caml_gc_minor_words,
     caml_gc_major_slice: caml_gc_major_slice,
     caml_gc_huge_fallback_count: caml_gc_huge_fallback_count,
     caml_eventlog_pause: caml_eventlog_pause,
     caml_eventlog_resume: caml_eventlog_resume,
     caml_memprof_discard: caml_memprof_discard,
     caml_memprof_stop: caml_memprof_stop,
     caml_memprof_start: caml_memprof_start,
     caml_final_release: caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register: caml_final_register,
     caml_memprof_set: caml_memprof_set,
     caml_gc_get: caml_gc_get,
     caml_gc_set: caml_gc_set,
     caml_gc_stat: caml_gc_stat,
     caml_gc_quick_stat: caml_gc_quick_stat,
     caml_gc_counters: caml_gc_counters,
     caml_gc_compaction: caml_gc_compaction,
     caml_gc_full_major: caml_gc_full_major,
     caml_gc_major: caml_gc_major,
     caml_gc_minor: caml_gc_minor,
     caml_sys_open_for_node: caml_sys_open_for_node,
     MlNodeFd: MlNodeFd,
     MlNodeDevice: MlNodeDevice,
     fs_node_supported: fs_node_supported,
     MlFakeFd: MlFakeFd,
     MlFakeFd_out: MlFakeFd_out,
     MlFakeFile: MlFakeFile,
     MlFakeDevice: MlFakeDevice,
     caml_read_file_content: caml_read_file_content,
     jsoo_create_file: jsoo_create_file,
     caml_create_file: caml_create_file,
     caml_fs_init: caml_fs_init,
     jsoo_create_file_extern: jsoo_create_file_extern,
     caml_ba_map_file_bytecode: caml_ba_map_file_bytecode,
     caml_ba_map_file: caml_ba_map_file,
     caml_sys_rmdir: caml_sys_rmdir,
     caml_sys_mkdir: caml_sys_mkdir,
     caml_sys_rename: caml_sys_rename,
     caml_sys_is_directory: caml_sys_is_directory,
     caml_sys_remove: caml_sys_remove,
     caml_sys_read_directory: caml_sys_read_directory,
     caml_sys_file_exists: caml_sys_file_exists,
     caml_raise_not_a_dir: caml_raise_not_a_dir,
     caml_raise_no_such_file: caml_raise_no_such_file,
     caml_sys_chdir: caml_sys_chdir,
     caml_sys_getcwd: caml_sys_getcwd,
     caml_unmount: caml_unmount,
     caml_mount_autoload: caml_mount_autoload,
     resolve_fs_device: resolve_fs_device,
     caml_list_mount_point: caml_list_mount_point,
     jsoo_mount_point: jsoo_mount_point,
     caml_make_path: caml_make_path,
     path_is_absolute: path_is_absolute,
     MlFile: MlFile,
     caml_root: caml_root,
     caml_get_root: caml_get_root,
     caml_current_dir: caml_current_dir,
     caml_trailing_slash: caml_trailing_slash,
     caml_finish_formatting: caml_finish_formatting,
     caml_parse_format: caml_parse_format,
     caml_array_bound_error: caml_array_bound_error,
     caml_raise_not_found: caml_raise_not_found,
     caml_raise_zero_divide: caml_raise_zero_divide,
     caml_raise_end_of_file: caml_raise_end_of_file,
     caml_invalid_argument: caml_invalid_argument,
     caml_failwith: caml_failwith,
     caml_raise_with_string: caml_raise_with_string,
     caml_raise_with_args: caml_raise_with_args,
     caml_raise_with_arg: caml_raise_with_arg,
     caml_raise_constant: caml_raise_constant,
     caml_lessthan: caml_lessthan,
     caml_lessequal: caml_lessequal,
     caml_greaterthan: caml_greaterthan,
     caml_greaterequal: caml_greaterequal,
     caml_notequal: caml_notequal,
     caml_equal: caml_equal,
     caml_int_compare: caml_int_compare,
     caml_compare: caml_compare,
     caml_compare_val: caml_compare_val,
     caml_compare_val_number_custom: caml_compare_val_number_custom,
     caml_compare_val_get_custom: caml_compare_val_get_custom,
     caml_compare_val_tag: caml_compare_val_tag,
     caml_bigstring_blit_ba_to_bytes: caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba: caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba: caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba: caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp: caml_bigstring_memcmp,
     bigstring_of_typed_array: bigstring_of_typed_array,
     bigstring_of_array_buffer: bigstring_of_array_buffer,
     bigstring_to_typed_array: bigstring_to_typed_array,
     bigstring_to_array_buffer: bigstring_to_array_buffer,
     caml_hash_mix_bigstring: caml_hash_mix_bigstring,
     caml_ba_from_typed_array: caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array: caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array: caml_ba_to_typed_array,
     caml_ba_hash: caml_ba_hash,
     caml_ba_create_from: caml_ba_create_from,
     caml_ba_deserialize: caml_ba_deserialize,
     caml_ba_serialize: caml_ba_serialize,
     caml_ba_reshape: caml_ba_reshape,
     caml_ba_slice: caml_ba_slice,
     caml_ba_sub: caml_ba_sub,
     caml_ba_blit: caml_ba_blit,
     caml_ba_fill: caml_ba_fill,
     caml_ba_set_3: caml_ba_set_3,
     caml_ba_set_2: caml_ba_set_2,
     caml_ba_set_1: caml_ba_set_1,
     caml_ba_uint8_set64: caml_ba_uint8_set64,
     caml_ba_uint8_set32: caml_ba_uint8_set32,
     caml_ba_uint8_set16: caml_ba_uint8_set16,
     caml_ba_set_generic: caml_ba_set_generic,
     caml_ba_get_3: caml_ba_get_3,
     caml_ba_get_2: caml_ba_get_2,
     caml_ba_get_1: caml_ba_get_1,
     caml_ba_uint8_get64: caml_ba_uint8_get64,
     caml_ba_uint8_get32: caml_ba_uint8_get32,
     caml_ba_uint8_get16: caml_ba_uint8_get16,
     caml_ba_get_generic: caml_ba_get_generic,
     caml_ba_dim_3: caml_ba_dim_3,
     caml_ba_dim_2: caml_ba_dim_2,
     caml_ba_dim_1: caml_ba_dim_1,
     caml_ba_dim: caml_ba_dim,
     caml_ba_num_dims: caml_ba_num_dims,
     caml_ba_layout: caml_ba_layout,
     caml_ba_kind: caml_ba_kind,
     caml_ba_change_layout: caml_ba_change_layout,
     caml_ba_create: caml_ba_create,
     caml_ba_create_unsafe: caml_ba_create_unsafe,
     caml_ba_compare: caml_ba_compare,
     Ml_Bigarray_c_1_1: Ml_Bigarray_c_1_1,
     Ml_Bigarray: Ml_Bigarray,
     caml_ba_custom_name: caml_ba_custom_name,
     caml_ba_create_buffer: caml_ba_create_buffer,
     caml_ba_get_size_per_element: caml_ba_get_size_per_element,
     caml_ba_get_size: caml_ba_get_size,
     caml_ba_init: caml_ba_init,
     caml_convert_raw_backtrace_slot: caml_convert_raw_backtrace_slot,
     caml_get_current_callstack: caml_get_current_callstack,
     caml_restore_raw_backtrace: caml_restore_raw_backtrace,
     caml_raw_backtrace_slot: caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot: caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length: caml_raw_backtrace_length,
     caml_convert_raw_backtrace: caml_convert_raw_backtrace,
     caml_record_backtrace: caml_record_backtrace,
     caml_get_exception_raw_backtrace: caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace: caml_get_exception_backtrace,
     caml_backtrace_status: caml_backtrace_status,
     caml_ml_debug_info_status: caml_ml_debug_info_status,
     caml_record_backtrace_flag: caml_record_backtrace_flag,
     caml_floatarray_create: caml_floatarray_create,
     caml_make_float_vect: caml_make_float_vect,
     caml_make_vect: caml_make_vect,
     caml_check_bound: caml_check_bound,
     caml_array_fill: caml_array_fill,
     caml_array_get: caml_array_get,
     caml_array_set: caml_array_set,
     caml_floatarray_blit: caml_floatarray_blit,
     caml_array_blit: caml_array_blit,
     caml_array_concat: caml_array_concat,
     caml_array_append: caml_array_append,
     caml_array_sub: caml_array_sub};
   var
    cst_Assert_failure = "Assert_failure",
    cst_Division_by_zero = "Division_by_zero",
    cst_End_of_file = "End_of_file",
    cst_Failure = "Failure",
    cst_Invalid_argument = "Invalid_argument",
    cst_Match_failure = "Match_failure",
    cst_Not_found = "Not_found",
    cst_Out_of_memory = "Out_of_memory",
    cst_Stack_overflow = "Stack_overflow",
    cst_Sys_blocked_io = "Sys_blocked_io",
    cst_Sys_error = "Sys_error",
    cst_Undefined_recursive_module = "Undefined_recursive_module";
   caml_fs_init();
   caml_register_global(0, [248, cst_Out_of_memory, -1], cst_Out_of_memory);
   caml_register_global(1, [248, cst_Sys_error, -2], cst_Sys_error);
   caml_register_global(2, [248, cst_Failure, -3], cst_Failure);
   caml_register_global
    (3, [248, cst_Invalid_argument, -4], cst_Invalid_argument);
   caml_register_global(4, [248, cst_End_of_file, -5], cst_End_of_file);
   caml_register_global
    (5, [248, cst_Division_by_zero, -6], cst_Division_by_zero);
   caml_register_global(6, [248, cst_Not_found, -7], cst_Not_found);
   caml_register_global(7, [248, cst_Match_failure, -8], cst_Match_failure);
   caml_register_global(8, [248, cst_Stack_overflow, -9], cst_Stack_overflow);
   caml_register_global(9, [248, cst_Sys_blocked_io, -10], cst_Sys_blocked_io);
   caml_register_global
    (10, [248, cst_Assert_failure, -11], cst_Assert_failure);
   caml_register_global
    (11,
     [248, cst_Undefined_recursive_module, -12],
     cst_Undefined_recursive_module);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiIuYXBwLmVvYmpzL2pzb28vYXBwLmJjLnJ1bnRpbWUuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiRGVmYXVsdExvY2FsZSIsImRlZmF1bHRTdHJmdGltZSIsIlN0cmZ0aW1lIiwiaXNDb21tb25KUyIsIm1vZHVsZSIsIm5hbWVzcGFjZSIsImFkYXB0ZWRTdHJmdGltZSIsImRlcHJlY2F0ZWRTdHJmdGltZSIsImpvb19nbG9iYWxfb2JqZWN0IiwidGhpcyIsImV2YWwiLCJfcmVxdWlyZSIsIl9kZXByZWNhdGlvbldhcm5pbmdzIiwiZGVwcmVjYXRpb25XYXJuaW5nIiwibmFtZSIsImluc3RlYWQiLCJjb25zb2xlIiwiZGVwcmVjYXRlZFN0cmZ0aW1lVFoiLCJkZXByZWNhdGVkU3RyZnRpbWVVVEMiLCJkZXByZWNhdGVkU3RyZnRpbWVMb2NhbGl6ZWQiLCJhZGFwdEZvcndhcmRzIiwiZm4iLCJmbXQiLCJkIiwibG9jYWxlIiwidW5kZWZpbmVkIiwic3RyZnRpbWUiLCJ0aW1lem9uZSIsIm51bGwiLCJ1dGNTdHJmdGltZSIsIkRhdGUiLCJjdXN0b21UaW1lem9uZU9mZnNldCIsInVzZVV0Y1RpbWV6b25lIiwiX2xvY2FsZSIsIl9jdXN0b21UaW1lem9uZU9mZnNldCIsIl91c2VVdGNCYXNlZERhdGUiLCJfY2FjaGVkRGF0ZVRpbWVzdGFtcCIsIl9jYWNoZWREYXRlIiwiX3N0cmZ0aW1lIiwiZm9ybWF0IiwiZGF0ZSIsInRpbWVzdGFtcCIsImN1cnJlbnRUaW1lc3RhbXAiLCJnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvciIsIl9wcm9jZXNzRm9ybWF0IiwicmVzdWx0U3RyaW5nIiwicGFkZGluZyIsImlzSW5TY29wZSIsImxlbmd0aCIsImV4dGVuZGVkVFoiLCJpIiwiY3VycmVudENoYXJDb2RlIiwicGFkVGlsbDIiLCJNYXRoIiwiaG91cnMxMiIsInBhZFRpbGwzIiwid2Vla051bWJlciIsInR6U3RyaW5nIiwieSIsImRheSIsIlN0cmluZyIsIm9yZGluYWwiLCJvZmYiLCJzaWduIiwic2VwIiwiaG91cnMiLCJtaW5zIiwidXNlVXRjQmFzZWREYXRlIiwidGltZXpvbmVUeXBlIiwicGFyc2VJbnQiLCJtaW51dGVzIiwibnVtYmVyVG9QYWQiLCJwYWRkaW5nQ2hhciIsImhvdXIiLCJmaXJzdFdlZWtkYXkiLCJ3ZWVrZGF5IiwiZmlyc3REYXlPZlllYXJVdGMiLCJkYXRlVXRjIiwieWRheSIsIndlZWtOdW0iLCJudW1iZXIiLCJpaSIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsInIiLCJsIiwidCIsIlN5bWJvbCIsImUiLCJuIiwidSIsImEiLCJmIiwibyIsIk9iamVjdCIsIm93bktleXMiLCJfb2JqZWN0U3ByZWFkMiIsImFyZ3VtZW50cyIsIl9kZWZpbmVQcm9wZXJ0eSIsIl90b1ByaW1pdGl2ZSIsIlR5cGVFcnJvciIsIk51bWJlciIsIl90b1Byb3BlcnR5S2V5IiwiX3R5cGVvZiIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiZGVzY3JpcHRvciIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIm9iaiIsImtleSIsInZhbHVlIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiX3NldFByb3RvdHlwZU9mIiwiX2dldFByb3RvdHlwZU9mIiwicCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiUHJveHkiLCJCb29sZWFuIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiY2FsbCIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiU3VwZXIiLCJyZXN1bHQiLCJOZXdUYXJnZXQiLCJfc3VwZXJQcm9wQmFzZSIsIm9iamVjdCIsInByb3BlcnR5IiwiX2dldCIsInJlY2VpdmVyIiwiYmFzZSIsImRlc2MiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiQXJyYXkiLCJfYXJyYXlMaWtlVG9BcnJheSIsIml0ZXIiLCJtaW5MZW4iLCJsZW4iLCJhcnIyIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJhbGxvd0FycmF5TGlrZSIsIml0IiwiRiIsIm5vcm1hbENvbXBsZXRpb24iLCJkaWRFcnIiLCJlcnIiLCJzdGVwIiwiTWFrZUludHJpbnNpY0NsYXNzIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJfdCIsIl9yIiwiX2l0ZXJhdG9yMiIsIl9zdGVwMiIsIl90MiIsIl9yMiIsIkRlZmluZUludHJpbnNpYyIsIkVycm9yIiwiR2V0SW50cmluc2ljIiwicyIsIm0iLCJjIiwiaCIsIlQiLCJJIiwiUyIsImciLCJ3IiwiRCIsIkciLCJ2IiwiQyIsIk8iLCJiIiwiRSIsIk0iLCJSIiwiWSIsIldlYWtNYXAiLCJQIiwiZ2xvYmFsVGhpcyIsIloiLCJCIiwiTiIsIkhhc1Nsb3QiLCJfbGVuIiwiX2tleSIsIkdldFNsb3QiLCJfWiIsIlNldFNsb3QiLCJqIiwiJCIsIlJlZ0V4cCIsImsiLCJVIiwiQSIsIkwiLCJ4IiwiVyIsInEiLCJIIiwiViIsInoiLCJfIiwiSiIsIksiLCJYIiwiUSIsImVlIiwidGUiLCJyZSIsIm9lIiwibmUiLCJhZSIsImllIiwic2UiLCJsZSIsImRlIiwibWUiLCJjZSIsImhlIiwidWUiLCJUZSIsInBlIiwiZmUiLCJ5ZSIsIkllIiwiU2UiLCJnZSIsIndlIiwiRGUiLCJHZSIsInZlIiwiQ2UiLCJCaWdJbnQiLCJPZSIsImJlIiwiRWUiLCJNZSIsIlJlIiwiRmUiLCJZZSIsIlBlIiwiWmUiLCJCZSIsIk5lIiwiamUiLCJpc1plcm8iLCJHZXRNZXRob2QiLCJDYWxsIiwiSXNPYmplY3QiLCJUb051bWJlciIsIlRvSW50ZWdlck9ySW5maW5pdHkiLCJJc0ludGVncmFsTnVtYmVyIiwiVG9TdHJpbmciLCJUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbiIsIlJhbmdlRXJyb3IiLCJUb1Bvc2l0aXZlSW50ZWdlcldpdGhUcnVuY2F0aW9uIiwiVG9JbnRlZ2VySWZJbnRlZ3JhbCIsImRpdm1vZCIsImlzTmVnYXRpdmVKU0JJIiwic2lnbkpTQkkiLCJhYnMiLCIkZSIsIk1hcCIsImtlIiwiVWUiLCJBZSIsIkxlIiwiX3JlZiIsIl9yZWYyIiwieGUiLCJfcmVmMyIsIl9yZWY0IiwiV2UiLCJxZSIsImdldEludGxEYXRlVGltZUZvcm1hdEVuVXNGb3JUaW1lWm9uZSIsIlRvT2JqZWN0IiwiQ29weURhdGFQcm9wZXJ0aWVzIiwiX2l0ZXJhdG9yMyIsIl9zdGVwMyIsIl9sb29wIiwiX3IzIiwiSXNUZW1wb3JhbEluc3RhbnQiLCJJc1RlbXBvcmFsVGltZVpvbmUiLCJJc1RlbXBvcmFsQ2FsZW5kYXIiLCJJc1RlbXBvcmFsRHVyYXRpb24iLCJJc1RlbXBvcmFsRGF0ZSIsIklzVGVtcG9yYWxUaW1lIiwiSXNUZW1wb3JhbERhdGVUaW1lIiwiSXNUZW1wb3JhbFllYXJNb250aCIsIklzVGVtcG9yYWxNb250aERheSIsIklzVGVtcG9yYWxab25lZERhdGVUaW1lIiwiUmVqZWN0VGVtcG9yYWxMaWtlT2JqZWN0IiwiUGFyc2VUZW1wb3JhbFRpbWVab25lIiwiX1BhcnNlVGVtcG9yYWxUaW1lWm9uIiwiX3QzIiwiUGFyc2VJU09EYXRlVGltZSIsIl91bnVzZWQiLCJHZXRDYW5vbmljYWxUaW1lWm9uZUlkZW50aWZpZXIiLCJGb3JtYXRUaW1lWm9uZU9mZnNldFN0cmluZyIsIlBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmciLCJNYXliZUZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbiIsIkZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbiIsIlRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIiLCJfZTIiLCJfcjQiLCJfbyIsIl9uIiwiX2EiLCJfaXRlcmF0b3I0IiwiX3N0ZXA0IiwiX3N0ZXA0JHZhbHVlIiwiX2UzIiwiX3Q0IiwiX3I1IiwiUmVqZWN0RGF0ZVRpbWUiLCJQYXJzZVRlbXBvcmFsWWVhck1vbnRoU3RyaW5nIiwiX2EyIiwiX2kiLCJfaXRlcmF0b3I1IiwiX3N0ZXA1IiwiX3N0ZXA1JHZhbHVlIiwiX2U0IiwiX3Q1IiwiX3I2IiwiX1BhcnNlSVNPRGF0ZVRpbWUiLCJfdDYiLCJQYXJzZVRlbXBvcmFsTW9udGhEYXlTdHJpbmciLCJfZTUiLCJfaXRlcmF0b3I2IiwiX3N0ZXA2IiwiX3N0ZXA2JHZhbHVlIiwiX3Q3IiwiX3I3IiwiX28yIiwiX1BhcnNlSVNPRGF0ZVRpbWUyIiwiX3Q4IiwiUGFyc2VUZW1wb3JhbEluc3RhbnQiLCJfUGFyc2VUZW1wb3JhbEluc3RhbnQiLCJfQmFsYW5jZUlTT0RhdGVUaW1lIiwiQmFsYW5jZUlTT0RhdGVUaW1lIiwiR2V0VVRDRXBvY2hOYW5vc2Vjb25kcyIsIlJlZ3VsYXRlSVNPRGF0ZSIsIlJlamVjdElTT0RhdGUiLCJfQ29uc3RyYWluSVNPRGF0ZSIsIkNvbnN0cmFpbklTT0RhdGUiLCJSZWd1bGF0ZVRpbWUiLCJSZWplY3RUaW1lIiwiX0NvbnN0cmFpblRpbWUiLCJDb25zdHJhaW5Ub1JhbmdlIiwiVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkIiwiX3JlZjUiLCJfcmVmNiIsIlJlamVjdER1cmF0aW9uIiwiX2l0ZXJhdG9yNyIsIl9zdGVwNyIsIl9vMyIsIl9uMiIsIl9pdGVyYXRvcjgiLCJfc3RlcDgiLCJfZTYiLCJfbzQiLCJUb1RlbXBvcmFsT3ZlcmZsb3ciLCJHZXRPcHRpb24iLCJUb1RlbXBvcmFsRGlzYW1iaWd1YXRpb24iLCJUb1RlbXBvcmFsUm91bmRpbmdNb2RlIiwiVG9UZW1wb3JhbE9mZnNldCIsIlRvQ2FsZW5kYXJOYW1lT3B0aW9uIiwiVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50IiwiVmFsaWRhdGVUZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50IiwiVG9GcmFjdGlvbmFsU2Vjb25kRGlnaXRzIiwiVG9TZWNvbmRzU3RyaW5nUHJlY2lzaW9uUmVjb3JkIiwiSGUiLCJHZXRUZW1wb3JhbFVuaXQiLCJfaTIiLCJfVWUiLCJfVWUkX2kiLCJfZTciLCJfdDkiLCJfaTMiLCJfYTMiLCJfZTgiLCJfdDEwIiwiVG9SZWxhdGl2ZVRlbXBvcmFsT2JqZWN0IiwiX0ludGVycHJldFRlbXBvcmFsRGF0IiwiVGVtcG9yYWxEYXRlVGltZVRvRGF0ZSIsIkdldFRlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWVXaXRoSVNPRGVmYXVsdCIsIl9lOSIsIkNhbGVuZGFyRmllbGRzIiwiX3AiLCJQcmVwYXJlVGVtcG9yYWxGaWVsZHMiLCJfZiIsIkludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMiLCJUb1RlbXBvcmFsVGltZVpvbmVTbG90VmFsdWUiLCJfUGFyc2VJU09EYXRlVGltZTMiLCJfZTEwIiwiX2YyIiwiSXNCdWlsdGluQ2FsZW5kYXIiLCJBU0NJSUxvd2VyY2FzZSIsIkNyZWF0ZVRlbXBvcmFsRGF0ZSIsIkNyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZSIsIkludGVycHJldElTT0RhdGVUaW1lT2Zmc2V0IiwiRGVmYXVsdFRlbXBvcmFsTGFyZ2VzdFVuaXQiLCJfaTQiLCJfYXJyIiwiX2FyciRfaSIsIl9tIiwiX2MiLCJMYXJnZXJPZlR3b1RlbXBvcmFsVW5pdHMiLCJfcmVmNyIsIl9pdGVyYXRvcjkiLCJfc3RlcDkiLCJfbzUiLCJfdDExIiwiVG9UZW1wb3JhbFRpbWVSZWNvcmQiLCJfaTUiLCJfcjgiLCJfZTExIiwiX3I5IiwiVG9UZW1wb3JhbERhdGUiLCJHZXRQbGFpbkRhdGVUaW1lRm9yIiwiX2UxMiIsIkNhbGVuZGFyRGF0ZUZyb21GaWVsZHMiLCJfUGFyc2VUZW1wb3JhbERhdGVTdHIiLCJfUmVndWxhdGVUaW1lIiwiX1RvVGVtcG9yYWxUaW1lUmVjb3JkIiwiVG9UZW1wb3JhbERhdGVUaW1lIiwiQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSIsIl9mMyIsIl9JbnRlcnByZXRUZW1wb3JhbERhdDIiLCJfUGFyc2VUZW1wb3JhbERhdGVUaW0iLCJfaTYiLCJUb1RlbXBvcmFsRHVyYXRpb24iLCJfVG9UZW1wb3JhbER1cmF0aW9uUmUiLCJUb1RlbXBvcmFsSW5zdGFudCIsIlRvVGVtcG9yYWxNb250aERheSIsIl9lMTMiLCJfbzYiLCJfdDEyIiwiVG9UZW1wb3JhbENhbGVuZGFyU2xvdFZhbHVlIiwiX24zIiwiQ2FsZW5kYXJNb250aERheUZyb21GaWVsZHMiLCJfUGFyc2VUZW1wb3JhbE1vbnRoRGEiLCJDcmVhdGVUZW1wb3JhbE1vbnRoRGF5IiwiVG9UZW1wb3JhbFRpbWUiLCJfUGFyc2VUZW1wb3JhbFRpbWVTdHIiLCJfVG9UZW1wb3JhbFRpbWVSZWNvcmQyIiwiX1JlZ3VsYXRlVGltZTIiLCJfZTE0IiwiX2l0ZXJhdG9yMTAiLCJfc3RlcDEwIiwiX3N0ZXAxMCR2YWx1ZSIsIl9lMTUiLCJfdDEzIiwiX3IxMCIsIl9QYXJzZUlTT0RhdGVUaW1lNCIsIl90MTQiLCJfbCIsIl9QYXJzZVRlbXBvcmFsTW9udGhEYTIiLCJfdDE1IiwiX3IxMSIsIl91bnVzZWQyIiwiX1BhcnNlVGVtcG9yYWxZZWFyTW9uIiwiX3QxNiIsIl9yMTIiLCJfdW51c2VkMyIsIlRvVGVtcG9yYWxZZWFyTW9udGgiLCJfcjEzIiwiQ2FsZW5kYXJZZWFyTW9udGhGcm9tRmllbGRzIiwiX1BhcnNlVGVtcG9yYWxZZWFyTW9uMiIsIkNyZWF0ZVRlbXBvcmFsWWVhck1vbnRoIiwiR2V0SW5zdGFudEZvciIsIl9uNCIsIkdldFBvc3NpYmxlSW5zdGFudHNGb3IiLCJfaXRlcmF0b3IxMSIsIl9zdGVwMTEiLCJfdDE4IiwiX3IxNCIsIkdldE9mZnNldE5hbm9zZWNvbmRzRm9yIiwiX283IiwiUm91bmROdW1iZXJUb0luY3JlbWVudCIsIl9lMTYiLCJfdDE3IiwiRGlzYW1iaWd1YXRlUG9zc2libGVJbnN0YW50cyIsIlRvVGVtcG9yYWxab25lZERhdGVUaW1lIiwiX0ludGVycHJldFRlbXBvcmFsRGF0MyIsIl9mNCIsIl9JIiwiX1BhcnNlVGVtcG9yYWxab25lZERhIiwiX0kyIiwiX1MiLCJDcmVhdGVUZW1wb3JhbERhdGVTbG90cyIsIlJlamVjdERhdGVSYW5nZSIsIkNyZWF0ZVRlbXBvcmFsRGF0ZVRpbWVTbG90cyIsIlJlamVjdERhdGVUaW1lUmFuZ2UiLCJDcmVhdGVUZW1wb3JhbE1vbnRoRGF5U2xvdHMiLCJDcmVhdGVUZW1wb3JhbFllYXJNb250aFNsb3RzIiwiUmVqZWN0VG9SYW5nZSIsIkNyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZVNsb3RzIiwiVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzIiwiX3IxNSIsIl9pdGVyYXRvcjEyIiwiX3N0ZXAxMiIsIl9lMTciLCJDYWxlbmRhck1lcmdlRmllbGRzIiwiX284IiwiQ2FsZW5kYXJEYXRlQWRkIiwiX241IiwiQ2FsZW5kYXJEYXRlVW50aWwiLCJfbjYiLCJDYWxlbmRhclllYXIiLCJfcjE2IiwiQ2FsZW5kYXJNb250aCIsIl9yMTciLCJDYWxlbmRhck1vbnRoQ29kZSIsIl9yMTgiLCJDYWxlbmRhckRheSIsIl9yMTkiLCJDYWxlbmRhckVyYSIsIl9yMjAiLCJDYWxlbmRhckVyYVllYXIiLCJfcjIxIiwiQ2FsZW5kYXJEYXlPZldlZWsiLCJfcjIyIiwiQ2FsZW5kYXJEYXlPZlllYXIiLCJfcjIzIiwiQ2FsZW5kYXJXZWVrT2ZZZWFyIiwiX3IyNCIsIkNhbGVuZGFyWWVhck9mV2VlayIsIl9yMjUiLCJDYWxlbmRhckRheXNJbldlZWsiLCJfcjI2IiwiQ2FsZW5kYXJEYXlzSW5Nb250aCIsIl9yMjciLCJDYWxlbmRhckRheXNJblllYXIiLCJfcjI4IiwiQ2FsZW5kYXJNb250aHNJblllYXIiLCJfcjI5IiwiQ2FsZW5kYXJJbkxlYXBZZWFyIiwiX3IzMCIsIl9QYXJzZUlTT0RhdGVUaW1lNSIsIl91bnVzZWQ0IiwiX1BhcnNlVGVtcG9yYWxZZWFyTW9uMyIsIl91bnVzZWQ1IiwiX1BhcnNlVGVtcG9yYWxNb250aERhMyIsIlRvVGVtcG9yYWxDYWxlbmRhck9iamVjdCIsIkNhbGVuZGFyRXF1YWxzIiwiVGhyb3dJZkNhbGVuZGFyc05vdEVxdWFsIiwiQ29uc29saWRhdGVDYWxlbmRhcnMiLCJfbzkiLCJfbzEwIiwiX28xMSIsIlRvVGVtcG9yYWxUaW1lWm9uZUlkZW50aWZpZXIiLCJUb1RlbXBvcmFsVGltZVpvbmVPYmplY3QiLCJUaW1lWm9uZUVxdWFscyIsIlRlbXBvcmFsRGF0ZVRpbWVUb1RpbWUiLCJfcjMxIiwiR2V0T2Zmc2V0U3RyaW5nRm9yIiwiX0JhbGFuY2VJU09EYXRlVGltZTIiLCJfR2V0SVNPUGFydHNGcm9tRXBvY2giLCJHZXRJU09QYXJ0c0Zyb21FcG9jaCIsIl9lMTgiLCJfdDE5IiwiX243IiwiQWRkRGF0ZVRpbWUiLCJfZTE5IiwiX3QyMCIsIl9uOCIsIl9hNCIsIl9yMzIiLCJfaXRlcmF0b3IxMyIsIl9zdGVwMTMiLCJfZTIwIiwiSVNPWWVhclN0cmluZyIsIklTT0RhdGVUaW1lUGFydFN0cmluZyIsIkZvcm1hdFNlY29uZHNTdHJpbmdQYXJ0IiwiVGVtcG9yYWxJbnN0YW50VG9TdHJpbmciLCJGb3JtYXRJU09UaW1lWm9uZU9mZnNldFN0cmluZyIsIlRlbXBvcmFsRHVyYXRpb25Ub1N0cmluZyIsIl9kaXZtb2QiLCJfZGl2bW9kMiIsIl9kaXZtb2QzIiwiZm9ybWF0TnVtYmVyIiwiRHVyYXRpb25TaWduIiwiX2UyMSIsIl90MjEiLCJfcjMzIiwiX1JvdW5kRHVyYXRpb24iLCJSb3VuZER1cmF0aW9uIiwiVG90YWxEdXJhdGlvbk5hbm9zZWNvbmRzIiwiVGVtcG9yYWxEYXRlVG9TdHJpbmciLCJUZW1wb3JhbERhdGVUaW1lVG9TdHJpbmciLCJfZTIyIiwiX3QyMiIsIl9yMzQiLCJfUm91bmRJU09EYXRlVGltZSIsIlJvdW5kSVNPRGF0ZVRpbWUiLCJUZW1wb3JhbE1vbnRoRGF5VG9TdHJpbmciLCJUZW1wb3JhbFllYXJNb250aFRvU3RyaW5nIiwiVGVtcG9yYWxab25lZERhdGVUaW1lVG9TdHJpbmciLCJfdDIzIiwiX3IzNSIsIl9vMTIiLCJfYTUiLCJSb3VuZEluc3RhbnQiLCJJc1RpbWVab25lT2Zmc2V0U3RyaW5nIiwiemUiLCJHZXROYW1lZFRpbWVab25lT2Zmc2V0TmFub3NlY29uZHMiLCJfR2V0TmFtZWRUaW1lWm9uZURhdGUiLCJHZXROYW1lZFRpbWVab25lRGF0ZVRpbWVQYXJ0cyIsIl9lMjMiLCJfZGl2bW9kNCIsIl9HZXRJU09QYXJ0c0Zyb21FcG9jaDIiLCJfR2V0Rm9ybWF0dGVyUGFydHMiLCJtYXhKU0JJIiwiYWZ0ZXJMYXRlc3RQb3NzaWJsZVR6ZGJSdWxlQ2hhbmdlIiwiVmUiLCJHZXROYW1lZFRpbWVab25lTmV4dFRyYW5zaXRpb24iLCJiaXNlY3QiLCJHZXROYW1lZFRpbWVab25lUHJldmlvdXNUcmFuc2l0aW9uIiwiX28xMyIsIl9yMzYiLCJMZWFwWWVhciIsIklTT0RheXNJbk1vbnRoIiwiRGF5T2ZXZWVrIiwiRGF5T2ZZZWFyIiwiX3IzNyIsIldlZWtPZlllYXIiLCJfaTciLCJfYXJyMiIsIl9tMiIsIkJhbGFuY2VJU09ZZWFyTW9udGgiLCJCYWxhbmNlSVNPRGF0ZSIsIl9CYWxhbmNlSVNPWWVhck1vbnRoIiwiX2UyNCIsIl9CYWxhbmNlSVNPWWVhck1vbnRoMiIsIl9CYWxhbmNlSVNPWWVhck1vbnRoMyIsIl9CYWxhbmNlVGltZSIsIkJhbGFuY2VUaW1lIiwiX0JhbGFuY2VJU09EYXRlIiwiX05vbk5lZ2F0aXZlQmlnSW50RGl2IiwiX05vbk5lZ2F0aXZlQmlnSW50RGl2MiIsIl9Ob25OZWdhdGl2ZUJpZ0ludERpdjMiLCJfTm9uTmVnYXRpdmVCaWdJbnREaXY0IiwiX05vbk5lZ2F0aXZlQmlnSW50RGl2NSIsIl9Ob25OZWdhdGl2ZUJpZ0ludERpdjYiLCJOb25OZWdhdGl2ZUJpZ0ludERpdm1vZCIsIk5hbm9zZWNvbmRzVG9EYXlzIiwiX2Rpdm1vZDUiLCJfdDI0IiwiX0RpZmZlcmVuY2VJU09EYXRlVGltIiwiRGlmZmVyZW5jZUlTT0RhdGVUaW1lIiwiQWRkWm9uZWREYXRlVGltZSIsIl90MjUiLCJfcjM4IiwiQmFsYW5jZUR1cmF0aW9uIiwiQmFsYW5jZVBvc3NpYmx5SW5maW5pdGVEdXJhdGlvbiIsIl9OYW5vc2Vjb25kc1RvRGF5cyIsIl9kaXZtb2Q2IiwiX2Rpdm1vZDciLCJfZGl2bW9kOCIsIl9kaXZtb2Q5IiwiX2Rpdm1vZDEwIiwiX2Rpdm1vZDExIiwiX2Rpdm1vZDEyIiwiX2Rpdm1vZDEzIiwiX2Rpdm1vZDE0IiwiX2Rpdm1vZDE1IiwiX2Rpdm1vZDE2IiwiX2Rpdm1vZDE3IiwiX2Rpdm1vZDE4IiwiX2Rpdm1vZDE5IiwiX3QyNiIsIl9kIiwiX2Rpdm1vZDIwIiwiX2k4IiwiX2FycjMiLCJfZTI1IiwiVW5iYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSIsIl90MjciLCJfcjM5IiwiX28xNCIsIl9uOSIsIl9hNiIsIl9pOSIsIl90MjgiLCJfTW92ZVJlbGF0aXZlRGF0ZSIsIl9yNDAiLCJNb3ZlUmVsYXRpdmVEYXRlIiwiX01vdmVSZWxhdGl2ZURhdGUyIiwiX3I0MSIsIl90MjkiLCJfTW92ZVJlbGF0aXZlRGF0ZTMiLCJfcjQyIiwiX01vdmVSZWxhdGl2ZURhdGU0IiwiX3I0MyIsIl9Nb3ZlUmVsYXRpdmVEYXRlNSIsIl9yNDQiLCJDYWxjdWxhdGVPZmZzZXRTaGlmdCIsIl9hNyIsIl9pMTAiLCJfcyIsIl9sMiIsIl9kMiIsIkNyZWF0ZU5lZ2F0ZWRUZW1wb3JhbER1cmF0aW9uIiwiX2kxMSIsIl9hcnI0IiwiX2MyIiwiX2UyNiIsIkRpZmZlcmVuY2VJU09EYXRlIiwiX3MyIiwiQ29tcGFyZUlTT0RhdGUiLCJfbDMiLCJfZDMiLCJfbTMiLCJfYzMiLCJBZGRJU09EYXRlIiwiX2giLCJfdSIsIl9UIiwiX3MzIiwiX2w0IiwiX2Q0IiwiX200IiwiX2UyNyIsIl9jNCIsIkRpZmZlcmVuY2VUaW1lIiwiX0JhbGFuY2VUaW1lMiIsIkRpZmZlcmVuY2VJbnN0YW50IiwiX1JvdW5kRHVyYXRpb24yIiwiX0JhbGFuY2VJU09EYXRlMiIsIl9CYWxhbmNlRHVyYXRpb24iLCJfQmFsYW5jZUR1cmF0aW9uMiIsIl9EaWZmZXJlbmNlVGltZSIsIkNvcHlPcHRpb25zIiwiX0NhbGVuZGFyRGF0ZVVudGlsIiwiRGlmZmVyZW5jZVpvbmVkRGF0ZVRpbWUiLCJfRGlmZmVyZW5jZUlTT0RhdGVUaW0yIiwiX05hbm9zZWNvbmRzVG9EYXlzMiIsIl9CYWxhbmNlRHVyYXRpb24zIiwiR2V0RGlmZmVyZW5jZVNldHRpbmdzIiwiRGlmZmVyZW5jZVRlbXBvcmFsSW5zdGFudCIsIl9EaWZmZXJlbmNlSW5zdGFudCIsIkRpZmZlcmVuY2VUZW1wb3JhbFBsYWluRGF0ZSIsIl9Sb3VuZER1cmF0aW9uMyIsIl9DYWxlbmRhckRhdGVVbnRpbDIiLCJEaWZmZXJlbmNlVGVtcG9yYWxQbGFpbkRhdGVUaW1lIiwiX1JvdW5kRHVyYXRpb240IiwiX0JhbGFuY2VEdXJhdGlvbjQiLCJfRGlmZmVyZW5jZUlTT0RhdGVUaW0zIiwiRGlmZmVyZW5jZVRlbXBvcmFsUGxhaW5UaW1lIiwiX1JvdW5kRHVyYXRpb241IiwiX0JhbGFuY2VEdXJhdGlvbjUiLCJfRGlmZmVyZW5jZVRpbWUyIiwiRGlmZmVyZW5jZVRlbXBvcmFsUGxhaW5ZZWFyTW9udGgiLCJfUm91bmREdXJhdGlvbjYiLCJfQ2FsZW5kYXJEYXRlVW50aWwzIiwiRGlmZmVyZW5jZVRlbXBvcmFsWm9uZWREYXRlVGltZSIsIl9EaWZmZXJlbmNlSW5zdGFudDIiLCJfRGlmZmVyZW5jZVpvbmVkRGF0ZVQiLCJfUm91bmREdXJhdGlvbjciLCJfQWRqdXN0Um91bmRlZER1cmF0aW8iLCJfZTI4IiwiQWRqdXN0Um91bmRlZER1cmF0aW9uRGF5cyIsIl9CYWxhbmNlSVNPWWVhck1vbnRoNCIsIl9SZWd1bGF0ZUlTT0RhdGUiLCJfQmFsYW5jZUlTT0RhdGUzIiwiQWRkVGltZSIsIl9CYWxhbmNlVGltZTMiLCJBZGREdXJhdGlvbiIsIl9DYWxlbmRhckRhdGVVbnRpbDQiLCJfQmFsYW5jZUR1cmF0aW9uNiIsIl9uMTAiLCJfUzIiLCJfZyIsIl9qIiwiXyQiLCJfayIsIl9VIiwiX0EiLCJfTCIsIl9EaWZmZXJlbmNlSW5zdGFudDMiLCJfRGlmZmVyZW5jZVpvbmVkRGF0ZVQyIiwiX2UyOSIsIl9qMiIsIl8kMiIsIl9rMiIsIl9VMiIsIl9CYWxhbmNlRHVyYXRpb243IiwiQWRkSW5zdGFudCIsIl9BZGRUaW1lIiwiQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21EdXJhdGlvbiIsIl9Ub1RlbXBvcmFsRHVyYXRpb25SZTIiLCJHZXRPcHRpb25zT2JqZWN0IiwiX0FkZER1cmF0aW9uIiwiQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21JbnN0YW50IiwiX1RvTGltaXRlZFRlbXBvcmFsRHVyIiwiX2l0ZXJhdG9yMTQiLCJfc3RlcDE0IiwiX2UzMCIsIkFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tUGxhaW5EYXRlVGltZSIsIl9Ub1RlbXBvcmFsRHVyYXRpb25SZTMiLCJfQWRkRGF0ZVRpbWUiLCJBZGREdXJhdGlvblRvT3JTdWJ0cmFjdER1cmF0aW9uRnJvbVBsYWluVGltZSIsIl9Ub1RlbXBvcmFsRHVyYXRpb25SZTQiLCJfQWRkVGltZTIiLCJfUmVndWxhdGVUaW1lMyIsIkFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tUGxhaW5ZZWFyTW9udGgiLCJfbjExIiwiX0JhbGFuY2VEdXJhdGlvbjgiLCJfZTMxIiwiX3QzMCIsIkFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tWm9uZWREYXRlVGltZSIsIl9Ub1RlbXBvcmFsRHVyYXRpb25SZTUiLCJfZGl2bW9kMjEiLCJfTm9uTmVnYXRpdmVCaWdJbnREaXY3IiwiX2UiLCJfUm91bmRUaW1lIiwiUm91bmRUaW1lIiwiX0JhbGFuY2VJU09EYXRlNCIsIkRheXNVbnRpbCIsIk1vdmVSZWxhdGl2ZVpvbmVkRGF0ZVRpbWUiLCJfQWRkRHVyYXRpb24yIiwiX0JhbGFuY2VEdXJhdGlvbjkiLCJfTmFub3NlY29uZHNUb0RheXMzIiwiX3QzMSIsIl9yNDUiLCJfbzE1IiwiX3QzMiIsIl9yNDYiLCJfbzE2IiwiX24xMiIsIl9hOCIsIl9pMTIiLCJfczQiLCJfbDUiLCJfZDUiLCJfTW92ZVJlbGF0aXZlRGF0ZTYiLCJfbTUiLCJfaDIiLCJfVDIiLCJCaWdJbnREaXZpZGVUb051bWJlciIsIl90MzMiLCJfcjQ3IiwiX28xNyIsIl9uMTMiLCJfYTkiLCJfaTEzIiwiX3M1IiwiX01vdmVSZWxhdGl2ZURhdGU3IiwiX01vdmVSZWxhdGl2ZURhdGU4IiwiX2w2IiwiX2Q2IiwiX3QzNCIsIl9yNDgiLCJfbzE4IiwiX24xNCIsIl9Nb3ZlUmVsYXRpdmVEYXRlOSIsIl9Nb3ZlUmVsYXRpdmVEYXRlMTAiLCJfYTEwIiwiX2kxNCIsIl90MzUiLCJfcjQ5IiwiX3QzNiIsIl9yNTAiLCJfbzE5IiwiX3QzNyIsIl9yNTEiLCJfbzIwIiwiX3QzOCIsIl9yNTIiLCJfbzIxIiwiX3QzOSIsIl9yNTMiLCJfbzIyIiwiX3Q0MCIsIl9yNTQiLCJfbzIzIiwiX2kxNSIsIl9hcnI1IiwiX2FycjUkX2kiLCJfaTE2IiwiX3M2IiwiQ29tcGFyaXNvblJlc3VsdCIsIl9kaXZtb2QyMiIsIkJpZ0ludEZsb29yRGl2IiwiX2Rpdm1vZDIzIiwiX2Rpdm1vZDI0IiwiVG9CaWdJbnRFeHRlcm5hbCIsIlRvQmlnSW50IiwiX2UzMiIsIkRlZmF1bHRUaW1lWm9uZSIsIkNyZWF0ZU9uZVByb3BPYmplY3QiLCJfcjU1IiwiX28yNCIsIkplIiwiS2UiLCJYZSIsIlFlIiwiZXQiLCJ0dCIsInJ0Iiwib3QiLCJudCIsImF0Iiwic3QiLCJsdCIsImR0IiwibXQiLCJnZXRQcm9wTGF6eSIsIkRhdGVUaW1lRm9ybWF0SW1wbCIsIl9lMzMiLCJfdDQxIiwiZGF0ZUFtZW5kIiwieWVhck1vbnRoQW1lbmQiLCJtb250aERheUFtZW5kIiwidGltZUFtZW5kIiwiZGF0ZXRpbWVBbWVuZCIsImluc3RhbnRBbWVuZCIsImN0IiwiX3RoaXMkcnQiLCJfZXh0cmFjdE92ZXJyaWRlcyIsImV4dHJhY3RPdmVycmlkZXMiLCJfbGVuMiIsIl9rZXkyIiwiaXNUZW1wb3JhbE9iamVjdCIsInNhbWVUZW1wb3JhbFR5cGUiLCJfZXh0cmFjdE92ZXJyaWRlczIiLCJfcjU2IiwiX28yNSIsIl9leHRyYWN0T3ZlcnJpZGVzMyIsIl9uMTUiLCJfYTExIiwiX3RoaXMkcnQyIiwiX2V4dHJhY3RPdmVycmlkZXM0IiwiX2xlbjMiLCJfa2V5MyIsIl9leHRyYWN0T3ZlcnJpZGVzNSIsIl9yNTciLCJfbzI2IiwiX2V4dHJhY3RPdmVycmlkZXM2IiwiX24xNiIsIl9hMTIiLCJodCIsImFtZW5kIiwiX2kxNyIsIl9hcnI2IiwiX2UzNCIsImhhc1RpbWVPcHRpb25zIiwiaGFzRGF0ZU9wdGlvbnMiLCJfbzI3IiwiX28yOCIsIl9uMTciLCJfYTEzIiwiX2Q3IiwiX202IiwiX28yOSIsIl9uMTgiLCJfYTE0IiwiX2Q4IiwiX203IiwiX28zMCIsIl9uMTkiLCJfYTE1IiwiX2Q5IiwiX204IiwiX28zMSIsIl9uMjAiLCJfYTE2IiwiX2Y1IiwiX3kiLCJfSTMiLCJfUzMiLCJfZzIiLCJfdyIsIl9EIiwiX0ciLCJ1dCIsIkluc3RhbnQiLCJfVG9TZWNvbmRzU3RyaW5nUHJlY2kiLCJUdCIsInB0IiwiZnQiLCJ5dCIsIkl0IiwiU3QiLCJndCIsInd0IiwiRHQiLCJTZXQiLCJHdCIsInZ0IiwiQ3QiLCJPdCIsIkNhbGVuZGFyIiwiX2l0ZXJhdG9yMTUiLCJfc3RlcDE1IiwiX28zMiIsIl9pdGVyYXRvcjE2IiwiX3N0ZXAxNiIsIl9lMzUiLCJfdDQyIiwiX0JhbGFuY2VEdXJhdGlvbjEwIiwiX090JEdldFNsb3QkZGF0ZVVudGlsIiwibW9udGhDb2RlTnVtYmVyUGFydCIsImlzTmFOIiwiYnVpbGRNb250aENvZGUiLCJyZXNvbHZlTm9uTHVuaXNvbGFyTW9udGgiLCJfZTM2IiwiX1JlZ3VsYXRlSVNPRGF0ZTIiLCJfbzMzIiwiX1JlZ3VsYXRlSVNPWWVhck1vbnRoIiwiX28zNCIsIl9Db25zdHJhaW5JU09EYXRlMiIsIl9SZWd1bGF0ZUlTT0RhdGUzIiwiX28zNSIsIl9yNTgiLCJfbzM2IiwiX0FkZElTT0RhdGUiLCJPbmVPYmplY3RDYWNoZSIsIl90NDMiLCJfaXRlcmF0b3IxNyIsIl9zdGVwMTciLCJfdGhpcyRtYXAiLCJfcjU5IiwidG9VdGNJc29EYXRlU3RyaW5nIiwiX3JlZjgiLCJzaW1wbGVEYXRlRGlmZiIsIkhlbHBlckJhc2UiLCJfdGhpcyIsIkpTT04iLCJfaXRlcmF0b3IxOCIsIl9zdGVwMTgiLCJfc3RlcDE4JHZhbHVlIiwiX2UzNyIsIl90NDUiLCJfZTM4IiwiX3RoaXMkcmV2aXNlSW50bEVyYSIsIl90NDQiLCJfcjYwIiwiX3Jlc29sdmVOb25MdW5pc29sYXJNIiwiX24yMSIsIl9lMzkiLCJfdDQ2IiwiX24yMiIsIl90aGlzMiIsIl9uMjMiLCJjYWxjdWxhdGVTYW1lTW9udGhSZXN1bHQiLCJfZTQwIiwiX2U0MSIsIl9lNDIiLCJfYTE3IiwiX24yNCIsIl9lNDMiLCJfcjYxIiwiX24yNSIsIl9lNDQiLCJfcjYyIiwiX2kxOCIsIl9zNyIsIl9sNyIsIl90NDciLCJfcmVmOSIsIl9yZWY5JHllYXJzIiwiX3JlZjkkbW9udGhzIiwiX3JlZjkkd2Vla3MiLCJfcmVmOSRkYXlzIiwiX3I2MyIsIl9hMTgiLCJfbDgiLCJfZDEwIiwiX3I2NCIsIl9tOSIsIl9jNSIsIl9vMzciLCJfbjI2IiwiX2ExOSIsIl90aGlzJGlzb1RvQ2FsZW5kYXJEYSIsIl9lNDUiLCJfbTEwIiwiX2gzIiwiX3UyIiwiSGVicmV3SGVscGVyIiwiX0hlbHBlckJhc2UiLCJfc3VwZXIiLCJfdGhpczMiLCJfZTQ2IiwiX2U0NyIsIklzbGFtaWNCYXNlSGVscGVyIiwiX0hlbHBlckJhc2UyIiwiX3N1cGVyMiIsIl90aGlzNCIsIl90aGlzJGFkanVzdENhbGVuZGFyRCIsIklzbGFtaWNIZWxwZXIiLCJfSXNsYW1pY0Jhc2VIZWxwZXIiLCJfc3VwZXIzIiwiX3RoaXM1IiwiSXNsYW1pY1VtYWxxdXJhSGVscGVyIiwiX0lzbGFtaWNCYXNlSGVscGVyMiIsIl9zdXBlcjQiLCJfdGhpczYiLCJJc2xhbWljVGJsYUhlbHBlciIsIl9Jc2xhbWljQmFzZUhlbHBlcjMiLCJfc3VwZXI1IiwiX3RoaXM3IiwiSXNsYW1pY0NpdmlsSGVscGVyIiwiX0lzbGFtaWNCYXNlSGVscGVyNCIsIl9zdXBlcjYiLCJfdGhpczgiLCJJc2xhbWljUmdzYUhlbHBlciIsIl9Jc2xhbWljQmFzZUhlbHBlcjUiLCJfc3VwZXI3IiwiX3RoaXM5IiwiSXNsYW1pY0NjSGVscGVyIiwiX0lzbGFtaWNCYXNlSGVscGVyNiIsIl9zdXBlcjgiLCJfdGhpczEwIiwiUGVyc2lhbkhlbHBlciIsIl9IZWxwZXJCYXNlMyIsIl9zdXBlcjkiLCJfdGhpczExIiwiX3RoaXMkYWRqdXN0Q2FsZW5kYXJEMiIsIkluZGlhbkhlbHBlciIsIl9IZWxwZXJCYXNlNCIsIl9zdXBlcjEwIiwiX3RoaXMxMiIsImlzR3JlZ29yaWFuTGVhcFllYXIiLCJHcmVnb3JpYW5CYXNlSGVscGVyIiwiX0hlbHBlckJhc2U1IiwiX3N1cGVyMTEiLCJfdGhpczEzIiwiX2FkanVzdEVyYXMiLCJfbzM4IiwiX3RoaXMkZXN0aW1hdGVJc29EYXRlIiwiX3RoaXMxNCIsIl9lcmFGcm9tWWVhciIsImNoZWNrRmllbGQiLCJlcmFGcm9tWWVhciIsIl9lcmFGcm9tWWVhcjIiLCJfZTQ4IiwiX28zOSIsIk9ydGhvZG94QmFzZUhlbHBlciIsIl9HcmVnb3JpYW5CYXNlSGVscGVyIiwiX3N1cGVyMTIiLCJFdGhpb2FhSGVscGVyIiwiX09ydGhvZG94QmFzZUhlbHBlciIsIl9zdXBlcjEzIiwiQ29wdGljSGVscGVyIiwiX09ydGhvZG94QmFzZUhlbHBlcjIiLCJfc3VwZXIxNCIsIkV0aGlvcGljSGVscGVyIiwiX09ydGhvZG94QmFzZUhlbHBlcjMiLCJfc3VwZXIxNSIsIlJvY0hlbHBlciIsIl9HcmVnb3JpYW5CYXNlSGVscGVyMiIsIl9zdXBlcjE2IiwiX3RoaXMxNSIsIkJ1ZGRoaXN0SGVscGVyIiwiX0dyZWdvcmlhbkJhc2VIZWxwZXIzIiwiX3N1cGVyMTciLCJfdGhpczE2IiwiR3JlZ29yeUhlbHBlciIsIl9HcmVnb3JpYW5CYXNlSGVscGVyNCIsIl9zdXBlcjE4IiwiSmFwYW5lc2VIZWxwZXIiLCJfR3JlZ29yaWFuQmFzZUhlbHBlcjUiLCJfc3VwZXIxOSIsIl90aGlzMTciLCJDaGluZXNlQmFzZUhlbHBlciIsIl9IZWxwZXJCYXNlNiIsIl9zdXBlcjIwIiwiX3RoaXMxOCIsIl90aGlzMTkiLCJfZ2V0Q2FsZW5kYXJEYXRlMiIsImdldENhbGVuZGFyRGF0ZSIsIl9nZXRDYWxlbmRhckRhdGUiLCJfZ2V0Q2FsZW5kYXJEYXRlMyIsIl9lNDkiLCJfcjY1IiwiX280MCIsIl9lNTAiLCJfbzQxIiwiX2kxOSIsIl90NDgiLCJfZTUxIiwiX280MiIsIl9pMjAiLCJfZDExIiwiX3JlZjEwIiwiX3JlZjExIiwiX2U1MiIsIl9yNjYiLCJfbzQzIiwiQ2hpbmVzZUhlbHBlciIsIl9DaGluZXNlQmFzZUhlbHBlciIsIl9zdXBlcjIxIiwiX3RoaXMyMCIsIkRhbmdpSGVscGVyIiwiX0NoaW5lc2VCYXNlSGVscGVyMiIsIl9zdXBlcjIyIiwiX3RoaXMyMSIsIk5vbklzb0NhbGVuZGFyIiwiX3RoaXMkaGVscGVyJGNhbGVuZGFyIiwiX3RoaXMkaGVscGVyJGNhbGVuZGFyMiIsIl90aGlzJGhlbHBlciRtb250aERheSIsIl9yNjciLCJfbzQ0IiwiX2kyMSIsIl9hcnI3IiwiX2U1MyIsIl90NDkiLCJQbGFpbkRhdGUiLCJfaTIyIiwiX2FycjgiLCJfZTU0IiwiX280NSIsIlBsYWluRGF0ZVRpbWUiLCJfSW50ZXJwcmV0VGVtcG9yYWxEYXQ0IiwiX1JvdW5kSVNPRGF0ZVRpbWUyIiwiX2kyMyIsIl9hcnI5IiwiX2U1NSIsIl9Ub1NlY29uZHNTdHJpbmdQcmVjaTIiLCJfaTI0IiwiX2FycjEwIiwiX2U1NiIsIl90NTAiLCJfbjI3IiwiRHVyYXRpb24iLCJfdCR5ZWFycyIsIl90JG1vbnRocyIsIl90JHdlZWtzIiwiX3QkZGF5cyIsIl90JGhvdXJzIiwiX3QkbWludXRlcyIsIl90JHNlY29uZHMiLCJfdCRtaWxsaXNlY29uZHMiLCJfdCRtaWNyb3NlY29uZHMiLCJfdCRuYW5vc2Vjb25kcyIsIl9VbmJhbGFuY2VEdXJhdGlvblJlbCIsIl9Sb3VuZER1cmF0aW9uOCIsIl9BZGp1c3RSb3VuZGVkRHVyYXRpbzIiLCJfQmFsYW5jZUR1cmF0aW9uMTEiLCJfQmFsYW5jZUR1cmF0aW9uUmVsYXQiLCJfdDUxIiwiX3I2OCIsIl9vNDYiLCJfbjI4IiwiX01vdmVSZWxhdGl2ZURhdGUxMSIsIl9Nb3ZlUmVsYXRpdmVEYXRlMTIiLCJfTW92ZVJlbGF0aXZlRGF0ZTEzIiwiX01vdmVSZWxhdGl2ZURhdGUxNCIsIl9hMjAiLCJfaTI1IiwiX3M4IiwiX2w5IiwiX280NyIsIl90NTIiLCJfcjY5IiwiX280OCIsIl9Nb3ZlUmVsYXRpdmVEYXRlMTUiLCJfTW92ZVJlbGF0aXZlRGF0ZTE2IiwiX3Q1MyIsIl9yNzAiLCJfbzQ5IiwiX01vdmVSZWxhdGl2ZURhdGUxNyIsIl9Nb3ZlUmVsYXRpdmVEYXRlMTgiLCJfVW5iYWxhbmNlRHVyYXRpb25SZWwyIiwiX1JvdW5kRHVyYXRpb245IiwiX1RvU2Vjb25kc1N0cmluZ1ByZWNpMyIsIkludGwiLCJfVW5iYWxhbmNlRHVyYXRpb25SZWwzIiwiX1VuYmFsYW5jZUR1cmF0aW9uUmVsNCIsImJ0IiwiUGxhaW5Nb250aERheSIsIl9pMjYiLCJfYXJyMTEiLCJfZTU3IiwiaW5zdGFudCIsInBsYWluRGF0ZVRpbWUiLCJwbGFpbkRhdGVUaW1lSVNPIiwiem9uZWREYXRlVGltZSIsIkV0IiwiTXQiLCJUZW1wb3JhbFRpbWVUb1N0cmluZyIsIl9lNTgiLCJfdDU0IiwiX2QxMiIsIl9Sb3VuZFRpbWUyIiwiUGxhaW5UaW1lIiwiX1JlZ3VsYXRlVGltZTQiLCJfTXQiLCJfUm91bmRUaW1lMyIsIl9pMjciLCJfYXJyMTIiLCJfZTU5IiwiX1RvU2Vjb25kc1N0cmluZ1ByZWNpNCIsIl9pMjgiLCJfYXJyMTMiLCJfZTYwIiwiX3Q1NSIsIl9uMjkiLCJUaW1lWm9uZSIsIl90NTYiLCJfYTIxIiwiUnQiLCJQbGFpblllYXJNb250aCIsIl9pMjkiLCJfYXJyMTQiLCJfZTYxIiwiRnQiLCJZdCIsIlpvbmVkRGF0ZVRpbWUiLCJkYXRlVGltZSIsIl9JbnRlcnByZXRUZW1wb3JhbERhdDUiLCJfUm91bmRJU09EYXRlVGltZTMiLCJfVG9TZWNvbmRzU3RyaW5nUHJlY2k1IiwiUHQiLCJ0b1RlbXBvcmFsSW5zdGFudCIsIlp0IiwiX2kzMCIsIl9adCIsIl9lNjIiLCJfdDU3IiwiVGVtcG9yYWxQb2x5ZmlsbCIsImV4cG9ydHMiLCJkZWZpbmUiLCJ3aW5kb3ciLCJnbG9iYWwiLCJyZXF1aXJlIiwidW5kZWYiLCJuYXRpdmVTcGxpdCIsImNvbXBsaWFudEV4ZWNOcGNnIiwic3RyIiwic2VwYXJhdG9yIiwibGltaXQiLCJvdXRwdXQiLCJmbGFncyIsImxhc3RMYXN0SW5kZXgiLCJzZXBhcmF0b3IyIiwibWF0Y2giLCJsYXN0SW5kZXgiLCJsYXN0TGVuZ3RoIiwiT25lVmVyc2lvbkNvbnN0cmFpbnQiLCJNWV9WRVJTSU9OIiwiaGFzaEtleSIsIkV2U3RvcmUiLCJlbGVtIiwiaGFzaCIsInRvcExldmVsIiwibWluRG9jIiwiZG9jY3kiLCJkb2N1bWVudCIsInJvb3QiLCJJbmRpdmlkdWFsIiwiT25lVmVyc2lvbiIsIm1vZHVsZU5hbWUiLCJ2ZXJzaW9uIiwiZGVmYXVsdFZhbHVlIiwiZW5mb3JjZUtleSIsInZlcnNpb25WYWx1ZSIsIm5hdGl2ZUlzQXJyYXkiLCJ0b1N0cmluZyIsImlzQXJyYXkiLCJjcmVhdGVFbGVtZW50IiwiZGlmZiIsInBhdGNoIiwiaXNPYmplY3QiLCJpc0hvb2siLCJhcHBseVByb3BlcnRpZXMiLCJub2RlIiwicHJldmlvdXMiLCJwcm9wTmFtZSIsInByb3BWYWx1ZSIsInJlbW92ZVByb3BlcnR5IiwicGF0Y2hPYmplY3QiLCJwcmV2aW91c1ZhbHVlIiwiYXR0ck5hbWUiLCJhdHRyVmFsdWUiLCJnZXRQcm90b3R5cGUiLCJyZXBsYWNlciIsImlzVk5vZGUiLCJpc1ZUZXh0IiwiaXNXaWRnZXQiLCJoYW5kbGVUaHVuayIsInZub2RlIiwib3B0cyIsImRvYyIsIndhcm4iLCJjaGlsZHJlbiIsImNoaWxkTm9kZSIsIm5vQ2hpbGQiLCJkb21JbmRleCIsInJvb3ROb2RlIiwidHJlZSIsImluZGljZXMiLCJub2RlcyIsImFzY2VuZGluZyIsInJlY3Vyc2UiLCJyb290SW5kZXgiLCJpbmRleEluUmFuZ2UiLCJ2Q2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwidkNoaWxkIiwibmV4dEluZGV4IiwibGVmdCIsInJpZ2h0IiwibWluSW5kZXgiLCJtYXhJbmRleCIsImN1cnJlbnRJbmRleCIsImN1cnJlbnRJdGVtIiwiVlBhdGNoIiwidXBkYXRlV2lkZ2V0IiwiYXBwbHlQYXRjaCIsInZwYXRjaCIsImRvbU5vZGUiLCJyZW5kZXJPcHRpb25zIiwidHlwZSIsInZOb2RlIiwicmVtb3ZlTm9kZSIsImluc2VydE5vZGUiLCJzdHJpbmdQYXRjaCIsIndpZGdldFBhdGNoIiwidk5vZGVQYXRjaCIsInJlb3JkZXJDaGlsZHJlbiIsInJlcGxhY2VSb290IiwicGFyZW50Tm9kZSIsImRlc3Ryb3lXaWRnZXQiLCJuZXdOb2RlIiwibGVmdFZOb2RlIiwidlRleHQiLCJ3aWRnZXQiLCJ1cGRhdGluZyIsIm1vdmVzIiwia2V5TWFwIiwicmVtb3ZlIiwiaW5zZXJ0Iiwib2xkUm9vdCIsIm5ld1Jvb3QiLCJyZW5kZXIiLCJwYXRjaE9wIiwicGF0Y2hlcyIsInBhdGNoUmVjdXJzaXZlIiwicGF0Y2hJbmRpY2VzIiwiaW5kZXgiLCJvd25lckRvY3VtZW50Iiwibm9kZUluZGV4IiwicGF0Y2hMaXN0IiwiQXR0cmlidXRlSG9vayIsInByb3AiLCJwcmV2IiwibmV4dCIsImNvbG9uUG9zaXRpb24iLCJsb2NhbE5hbWUiLCJFdkhvb2siLCJwcm9wZXJ0eU5hbWUiLCJlcyIsIlNvZnRTZXRIb29rIiwiVk5vZGUiLCJWVGV4dCIsImlzVlRodW5rIiwicGFyc2VUYWciLCJzb2Z0U2V0SG9vayIsImV2SG9vayIsInRhZ05hbWUiLCJwcm9wZXJ0aWVzIiwidGFnIiwiaXNDaGlsZHJlbiIsInRyYW5zZm9ybVByb3BlcnRpZXMiLCJhZGRDaGlsZCIsImlzQ2hpbGQiLCJVbmV4cGVjdGVkVmlydHVhbEVsZW1lbnQiLCJkYXRhIiwiZXJyb3JTdHJpbmciLCJVbnN1cHBvcnRlZFZhbHVlVHlwZSIsInNwbGl0IiwiY2xhc3NJZFNwbGl0Iiwibm90Q2xhc3NJZCIsIm5vSWQiLCJ0YWdQYXJ0cyIsImNsYXNzZXMiLCJwYXJ0IiwiREVGQVVMVF9OQU1FU1BBQ0UiLCJFVl9OQU1FU1BBQ0UiLCJYTElOS19OQU1FU1BBQ0UiLCJYTUxfTkFNRVNQQUNFIiwiU1ZHX1BST1BFUlRJRVMiLCJTVkdBdHRyaWJ1dGVOYW1lc3BhY2UiLCJhdHRyaWJ1dGVIb29rIiwiU1ZHX05BTUVTUEFDRSIsInN2ZyIsImF0dHJpYnV0ZXMiLCJpc1RodW5rIiwicmVuZGVyZWRBIiwicmVuZGVyZWRCIiwicmVuZGVyVGh1bmsiLCJ0aHVuayIsInJlbmRlcmVkVGh1bmsiLCJob29rIiwiaXNWaXJ0dWFsTm9kZSIsImlzVmlydHVhbFRleHQiLCJpc1ZIb29rIiwiVmlydHVhbE5vZGUiLCJub1Byb3BlcnRpZXMiLCJub0NoaWxkcmVuIiwiY291bnQiLCJkZXNjZW5kYW50cyIsImhhc1dpZGdldHMiLCJoYXNUaHVua3MiLCJkZXNjZW5kYW50SG9va3MiLCJob29rcyIsImNoaWxkIiwiVmlydHVhbFBhdGNoIiwiVmlydHVhbFRleHQiLCJ0ZXh0IiwiZGlmZlByb3BzIiwiYUtleSIsImFWYWx1ZSIsImJWYWx1ZSIsIm9iamVjdERpZmYiLCJiS2V5Iiwid2FsayIsImFwcGx5IiwiYXBwbHlDbGVhciIsInRodW5rcyIsImNsZWFyU3RhdGUiLCJhcHBlbmRQYXRjaCIsInByb3BzUGF0Y2giLCJkaWZmQ2hpbGRyZW4iLCJhQ2hpbGRyZW4iLCJvcmRlcmVkU2V0IiwicmVvcmRlciIsImJDaGlsZHJlbiIsImFMZW4iLCJiTGVuIiwibGVmdE5vZGUiLCJyaWdodE5vZGUiLCJ1bmhvb2siLCJkZXN0cm95V2lkZ2V0cyIsInRodW5rUGF0Y2giLCJoYXNQYXRjaGVzIiwidW5kZWZpbmVkS2V5cyIsImJDaGlsZEluZGV4Iiwia2V5SW5kZXgiLCJiS2V5cyIsImJGcmVlIiwiYUNoaWxkSW5kZXgiLCJhS2V5cyIsImFGcmVlIiwibmV3Q2hpbGRyZW4iLCJmcmVlSW5kZXgiLCJmcmVlQ291bnQiLCJkZWxldGVkSXRlbXMiLCJhSXRlbSIsIml0ZW1JbmRleCIsImxhc3RGcmVlSW5kZXgiLCJuZXdJdGVtIiwic2ltdWxhdGUiLCJzaW11bGF0ZUluZGV4IiwicmVtb3ZlcyIsImluc2VydHMiLCJzaW11bGF0ZUl0ZW0iLCJ3YW50ZWRJdGVtIiwia2V5cyIsImZyZWUiLCJ2ZG9tIiwiVmRvbVRodW5rIiwiYXJncyIsIkdlbmVyaWNIb29rIiwiaW5pdCIsInVwZGF0ZSIsImRlc3Ryb3kiLCJpZCIsImV4dHJhIiwiaG9va19zdGF0ZV9rZXkiLCJzdGF0ZSIsImZyb20iLCJ0byIsImNhbWxfaW50NjRfaXNfemVybyIsImNhbWxfc3RyX3JlcGVhdCIsImNhbWxfaW50NjRfb2Zmc2V0IiwiY2FtbF9yYWlzZV9jb25zdGFudCIsImNhbWxfZ2xvYmFsX2RhdGEiLCJjYW1sX3JhaXNlX3plcm9fZGl2aWRlIiwiTWxJbnQ2NCIsImxvIiwibWkiLCJoaSIsInhoaSIsIm9mZnNldCIsIm1vZHVsdXMiLCJkaXZpc29yIiwicXVvdGllbnQiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsImNhbWxfaW50NjRfaXNfbmVnYXRpdmUiLCJjYW1sX2ludDY0X25lZyIsImNhbWxfanNieXRlc19vZl9zdHJpbmciLCJqc29vX3N5c19nZXRlbnYiLCJwcm9jZXNzIiwiY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWciLCJjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZSIsImV4biIsImZvcmNlIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9yYWlzZV93aXRoX2FyZyIsImFyZyIsImNhbWxfc3RyaW5nX29mX2pzYnl0ZXMiLCJjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIiwibXNnIiwiY2FtbF9pbnZhbGlkX2FyZ3VtZW50IiwiY2FtbF9wYXJzZV9mb3JtYXQiLCJjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nIiwicmF3YnVmZmVyIiwiYnVmZmVyIiwiY2FtbF9pbnQ2NF9mb3JtYXQiLCJ3YmFzZSIsImN2dGJsIiwiY2FtbF9leHBtMV9mbG9hdCIsImNhbWxfbWxfY29uZGl0aW9uX2Jyb2FkY2FzdCIsImpzb29faXNfYXNjaWkiLCJjYW1sX3V0ZjE2X29mX3V0ZjgiLCJjMSIsImMyIiwiY2FtbF9qc3N0cmluZ19vZl9zdHJpbmciLCJmc19ub2RlX3N1cHBvcnRlZCIsIm1ha2VfcGF0aF9pc19hYnNvbHV0ZSIsInBvc2l4IiwicGF0aCIsIndpbjMyIiwic3BsaXREZXZpY2VSZSIsImRldmljZSIsImlzVW5jIiwicGF0aF9pc19hYnNvbHV0ZSIsImNhbWxfdHJhaWxpbmdfc2xhc2giLCJjYW1sX2N1cnJlbnRfZGlyIiwiY2FtbF9tYWtlX3BhdGgiLCJjb21wMCIsImNvbXAiLCJuY29tcCIsImNhbWxfdXRmOF9vZl91dGYxNiIsImNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIiwidW5peF9lcnJvciIsIm1ha2VfdW5peF9lcnJfYXJncyIsImNvZGUiLCJzeXNjYWxsIiwiZXJybm8iLCJ2YXJpYW50IiwiY2FtbF9uYW1lZF92YWx1ZXMiLCJjYW1sX25hbWVkX3ZhbHVlIiwibm0iLCJjYW1sX3JhaXNlX3dpdGhfYXJncyIsImNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyIsImNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMiLCJNbEJ5dGVzIiwiY29udGVudHMiLCJjb250ZW50IiwiY2FtbF9pc19tbF9ieXRlcyIsImNhbWxfaXNfbWxfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9hcnJheSIsIlVpbnQ4QXJyYXkiLCJjYW1sX2J5dGVzX29mX2pzYnl0ZXMiLCJjYW1sX2J5dGVzX29mX3N0cmluZyIsImNhbWxfcmFpc2Vfc3lzX2Vycm9yIiwiY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUiLCJjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkiLCJjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzIiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfYmxpdF9ieXRlcyIsInMxIiwiaTEiLCJzMiIsImkyIiwiTWxGaWxlIiwiTWxGYWtlRmlsZSIsIm9sZCIsImJ1ZiIsInBvcyIsImNsZW4iLCJuZXdfc3RyIiwib2xkX2RhdGEiLCJNbEZha2VGZCIsImZpbGUiLCJNbEZha2VEZXZpY2UiLCJyZXMiLCJuYW1lX3NsYXNoIiwibW9kZSIsInJhaXNlX3VuaXgiLCJwYXJlbnQiLCJzZWVuIiwiZW50cnkiLCJvayIsImJ5dGVzIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nIiwiY2FtbF9ieXRlc19ib3VuZF9lcnJvciIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfYnl0ZXNfc2V0IiwiTWxOb2RlRmQiLCJmZCIsImJ1Zl9vZmZzZXQiLCJyZWFkIiwiTWxOb2RlRGV2aWNlIiwiY29uc3RzIiwiaXNDaGFyYWN0ZXJEZXZpY2UiLCJqc19zdGF0cyIsInRvX2RpciIsImxpbmsiLCJmaWxlX2tpbmQiLCJjYW1sX2dldF9yb290IiwiY2FtbF9mYWlsd2l0aCIsImNhbWxfcm9vdCIsImpzb29fbW91bnRfcG9pbnQiLCJyZXNvbHZlX2ZzX2RldmljZSIsImNhbWxfc3lzX2lzX2RpcmVjdG9yeSIsImNhbWxfcmFpc2Vfbm90X2ZvdW5kIiwiY2FtbF9zeXNfZ2V0ZW52Iiwic2hpZnRfcmlnaHRfbmF0IiwibmF0MSIsIm9mczEiLCJsZW4xIiwibmF0MiIsIm9mczIiLCJuYml0cyIsIndyYXAiLCJjYW1sX2dyX3N0YXRlIiwiY2FtbF9ncl9zdGF0ZV9nZXQiLCJjYW1sX2dyX3BvaW50X2NvbG9yIiwiaW0iLCJjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfcmVzb2x2ZSIsIk1sT2JqZWN0VGFibGUiLCJOYWl2ZUxvb2t1cCIsIm9ianMiLCJjYW1sX3N5c19yZW5hbWUiLCJvX3Jvb3QiLCJuX3Jvb3QiLCJjYW1sX2xvZzEwX2Zsb2F0IiwiY2FtbF9ydW50aW1lX3dhcm5pbmdzIiwiY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyIsImJvb2wiLCJjYW1sX2NsYXNzaWZ5X2Zsb2F0IiwiaXNGaW5pdGUiLCJjYW1sX21sX2NoYW5uZWxzIiwiY2FtbF9yZWZpbGwiLCJjaGFuIiwic3RyX2EiLCJucmVhZCIsImNhbWxfYXJyYXlfYm91bmRfZXJyb3IiLCJjYW1sX21sX2lucHV0X3NjYW5fbGluZSIsImNoYW5pZCIsInByZXZfbWF4IiwiY2FtbF9nY19taW5vciIsInVuaXQiLCJjb3JlX2djX2hlYXBfY2h1bmtzIiwiY2FtbF9zc2UyX2Zsb2F0NjRfbWF4X2J5dGVjb2RlIiwiY2FtbF9tbF9jb25kaXRpb25fbmV3IiwiY2FtbF9iYV90b190eXBlZF9hcnJheSIsImJhIiwiY2FtbF9tbF9pbnB1dF9ibG9jayIsImF2YWlsIiwiY2FtbF9tbF9pbnB1dF9iaWdhcnJheSIsImNhbWxfaW50NjRfb2ZfYnl0ZXMiLCJjYW1sX2JhX3VpbnQ4X2dldDY0IiwiaTAiLCJvZnMiLCJiMSIsImIyIiwiYjMiLCJiNCIsImI1IiwiYjYiLCJiNyIsImI4IiwiY2FtbF9pbnQ2NF90b19ieXRlcyIsImNhbWxfaW50NjRfbWFyc2hhbCIsIndyaXRlciIsInNpemVzIiwiY2FtbF9iYV9udW1fZGltcyIsImNhbWxfYmFfZ2V0XzEiLCJjYW1sX2ludF9jb21wYXJlIiwiYmlnc3RyaW5nYWZfbWVtY21wX2JpZ3N0cmluZyIsImJhMSIsImJhMV9vZmYiLCJiYTIiLCJiYTJfb2ZmIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyIsInBvczEiLCJieXRlczIiLCJwb3MyIiwic2xpY2UiLCJiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YiIsInNyYyIsInNyY19wb3MiLCJkc3QiLCJkc3RfcG9zIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY3JlYXRlX2ZpbGUiLCJqc29vX2NyZWF0ZV9maWxlIiwiY2FtbF9mc19pbml0IiwidG1wIiwiY2FtbF9tdWwiLCJjYW1sX2hhc2hfbWl4X2ludCIsImNhbWxfaGFzaF9taXhfanNieXRlcyIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmciLCJjYW1sX2dldF9jb250aW51YXRpb25fY2FsbHN0YWNrIiwiY2FtbF9wYXJzZXJfdHJhY2UiLCJjYW1sX3NldF9wYXJzZXJfdHJhY2UiLCJvbGRmbGFnIiwiY2FtbF9saXN0X29mX2pzX2FycmF5IiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsInRpbWV6b25lX2pzX2xvYWRlcl9nZXRfb2Zmc2V0X25hbm9zX2ZvciIsInpvbmUiLCJudW1fZGlnaXRzX25hdCIsIm5hdCIsImNhbWxfaGFzaF9uYXQiLCJjYW1sX2NhbGxfZ2VuIiwiYXJnc0xlbiIsIm5hcmdzIiwiZXh0cmFfYXJncyIsImNhbWxfY2FsbGJhY2siLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzIiwiY2FtbF9zeXNfY2hkaXIiLCJkaXIiLCJjYW1sX29ial91cGRhdGVfdGFnIiwiY2FtbF9sYXp5X3VwZGF0ZV90b19mb3JjaW5nIiwiY2FtbF9nY19jb3VudGVycyIsImNhbWxfZ3Jfc3luY2hyb25pemUiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYSIsInN0cjEiLCJiaWdzdHJpbmdhZl9ibGl0X2Zyb21fYnl0ZXMiLCJzcmNfb2ZmIiwiZHN0X29mZiIsImNhbWxfdW5peF9jbG9zZWRpciIsImRpcl9oYW5kbGUiLCJjYW1sX3VuaXhfb3BlbmRpciIsImNhbWxfdW5peF9yZXdpbmRkaXIiLCJuZXdfZGlyX2hhbmRsZSIsImNhbWxfcmFpc2VfZW5kX29mX2ZpbGUiLCJjYW1sX3VuaXhfcmVhZGRpciIsImNhbWxfdW5peF9maW5kZmlyc3QiLCJwYXRoX2pzIiwiZmlyc3RfZW50cnkiLCJjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWciLCJsb2cyX29rIiwianNvb19mbG9vcl9sb2cyIiwiSW5maW5pdHkiLCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQiLCJmbG9hdDMyYSIsIkZsb2F0MzJBcnJheSIsImludDMyYSIsIkludDMyQXJyYXkiLCJjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSIsImNhbWxfaW50NjRfYml0c19vZl9mbG9hdCIsImV4cCIsInIzIiwicjIiLCJyMSIsImNhbWxfYmFfc2VyaWFsaXplIiwic3oiLCJjb21wbGV4IiwiY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudCIsImtpbmQiLCJjYW1sX2JhX2NyZWF0ZV9idWZmZXIiLCJzaXplIiwidmlldyIsIkZsb2F0NjRBcnJheSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MTZBcnJheSIsImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyIsImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyIsIk5hTiIsImNhbWxfYmFfZ2V0X3NpemUiLCJkaW1zIiwibl9kaW1zIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkiLCJjYW1sX2ludDY0X2hpMzIiLCJjYW1sX2ludDY0X2xvMzIiLCJjYW1sX2JhX2N1c3RvbV9uYW1lIiwiTWxfQmlnYXJyYXkiLCJsYXlvdXQiLCJ0b3RhbCIsImsxIiwiazIiLCJNbF9CaWdhcnJheV9jXzFfMSIsImNhbWxfYmFfY3JlYXRlX3Vuc2FmZSIsInNpemVfcGVyX2VsZW1lbnQiLCJjYW1sX2JhX2Rlc2VyaWFsaXplIiwicmVhZGVyIiwibnVtX2RpbXMiLCJzaXplX2RpbSIsInNpemVfZGltX2hpIiwic2l6ZV9kaW1fbG8iLCJzaXh0eSIsImludDY0IiwiY2FtbF9iYV9jb21wYXJlIiwiY2FtbF9oYXNoX21peF9pbnQ2NCIsImNhbWxfaGFzaF9taXhfZmxvYXQiLCJ2MCIsImNhbWxfYmFfaGFzaCIsIm51bV9lbHRzIiwiY2FtbF9pbnQzMl91bm1hcnNoYWwiLCJjYW1sX25hdGl2ZWludF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X3VubWFyc2hhbCIsImNhbWxfaW50NjRfY29tcGFyZSIsImNhbWxfaW50NjRfaGFzaCIsImNhbWxfY3VzdG9tX29wcyIsImNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSIsImNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbSIsIm51bSIsImN1c3RvbSIsInN3YXAiLCJjYW1sX2NvbXBhcmVfdmFsX3RhZyIsImNhbWxfc3RyaW5nX2NvbXBhcmUiLCJjYW1sX2J5dGVzX2NvbXBhcmUiLCJjYW1sX2NvbXBhcmVfdmFsIiwic3RhY2siLCJ0YWdfYSIsInRhZ19iIiwiY2FtbF9ncmVhdGVydGhhbiIsImRpdl9oZWxwZXIiLCJkaXZfZGlnaXRfbmF0IiwibmF0cSIsIm9mc3EiLCJuYXRyIiwib2ZzciIsInJlbSIsIm51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCIsInNoaWZ0X2xlZnRfbmF0IiwiTWxOYXQiLCJjcmVhdGVfbmF0Iiwic2V0X3RvX3plcm9fbmF0IiwiaW5jcl9uYXQiLCJjYXJyeV9pbiIsImNhcnJ5IiwiYWRkX25hdCIsImxlbjIiLCJuYXRfb2ZfYXJyYXkiLCJtdWx0X2RpZ2l0X25hdCIsIm5hdDMiLCJvZnMzIiwieDEiLCJ4MiIsIngzIiwiZGVjcl9uYXQiLCJib3Jyb3ciLCJzdWJfbmF0IiwiY29tcGFyZV9uYXQiLCJkaXZfbmF0IiwicXVvIiwiY2FtbF9iYV9ibGl0IiwiaXNfZGlnaXRfaW50IiwiY2FtbF9pbnQ2NF9kaXYiLCJiaWdzdHJpbmdfZmluZCIsImJzIiwiY2hyIiwiY2FtbF9qc19odG1sX2VudGl0aWVzIiwiZW50aXR5IiwidGVtcCIsImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQiLCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NCIsImNhbWxfYmFfc2V0XzIiLCJjYW1sX2FyZ3YiLCJtYWluIiwiYXJndiIsImFyZ3MyIiwiY2FtbF9leGVjdXRhYmxlX25hbWUiLCJjYW1sX2pzX2V2YWxfc3RyaW5nIiwic2VyaWFsaXplX25hdCIsImNhbWxfbWVtcHJvZl9zZXQiLCJfY29udHJvbCIsImNhbWxfc3lzX2V4aXQiLCJjYW1sX2NoYW5uZWxfZGVzY3JpcHRvciIsImNhbWxfanNfZnJvbV9hcnJheSIsImNhbWxfYmFfcmVzaGFwZSIsInZpbmQiLCJuZXdfZGltIiwiY2FtbF9vb19sYXN0X2lkIiwiY2FtbF9zZXRfb29faWQiLCJjYW1sX2dyX2ZpbGxfcmVjdCIsImNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZSIsImpzbmFtZSIsImNhbWxfZ2V0X2dsb2JhbF9kYXRhIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCIsImNhbWxfYmFfdWludDhfZ2V0MTYiLCJiaWdzdHJpbmdfaXNfbW1hcHBlZF9zdHViIiwiY2FtbF9jaGVja19ib3VuZCIsImFycmF5IiwiY2FtbF9jaGVja19ib3VuZF9iaWdzdHJpbmciLCJiaWdzdHJpbmciLCJiaW5fcHJvdF9ibGl0X2J1Zl9mbG9hdF9hcnJheV9zdHViIiwiY2FtbF9jb21wYXJlIiwiY2FtbF9NRDVUcmFuc2Zvcm0iLCJhZGQiLCJ4eCIsImZmIiwiZ2ciLCJoaCIsImNhbWxfTUQ1VXBkYXRlIiwiY3R4IiwiaW5wdXQiLCJpbnB1dF9sZW4iLCJpbl9idWYiLCJpbnB1dF9wb3MiLCJtaXNzaW5nIiwiY2FtbF9ydW50aW1lX2V2ZW50c19yZWFkX3BvbGwiLCJjdXJzb3IiLCJjYWxsYmFja3MiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9pbnQ2NF90b19mbG9hdCIsInBweF9leHBlY3RfcnVudGltZV9zYXZlZF9zdGRlcnIiLCJwcHhfZXhwZWN0X3J1bnRpbWVfc2F2ZWRfc3Rkb3V0IiwicHB4X2V4cGVjdF9ydW50aW1lX2JlZm9yZV90ZXN0Iiwidm91dHB1dCIsInZzdGRvdXQiLCJ2c3RkZXJyIiwiY2FtbF9iaWdzdHJpbmdfbWVtY21wIiwiY2FtbF9uZXdfc3RyaW5nIiwiY2FtbF9lcmZfZmxvYXQiLCJhMSIsImEyIiwiYTMiLCJhNCIsImE1IiwiY2FtbF9iYV91aW50OF9nZXQzMiIsImNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgiLCJjYW1sX3N0cl9pbml0aWFsaXplIiwiY2FtbF9vYmpfYmxvY2siLCJjYW1sX2dyX2NsZWFyX2dyYXBoIiwiYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciIsImNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQiLCJfdW5pdCIsImx4b3JfZGlnaXRfbmF0IiwiY2FtbF9vYmpfYWRkX29mZnNldCIsImNhbWxfZmluYWxfcmVsZWFzZSIsImNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSIsImNhbWxfanNfdG9fYXJyYXkiLCJjYW1sX3N5c19pc19yZWd1bGFyX2ZpbGUiLCJjYW1sX2dyX3Bsb3QiLCJjb2xvciIsImNhbWxfYnl0ZXNfc2V0NjQiLCJpNjQiLCJjYW1sX3N0cmluZ19zZXQxNiIsImkxNiIsImNhbWxfaW50NjRfYnN3YXAiLCJjYW1sX2djX21ham9yIiwiY2FtbF9sZXhfYXJyYXkiLCJjYW1sX2xleF9lbmdpbmUiLCJ0YmwiLCJzdGFydF9zdGF0ZSIsImxleGJ1ZiIsImxleF9idWZmZXIiLCJsZXhfYnVmZmVyX2xlbiIsImxleF9zdGFydF9wb3MiLCJsZXhfY3Vycl9wb3MiLCJsZXhfbGFzdF9wb3MiLCJsZXhfbGFzdF9hY3Rpb24iLCJsZXhfZW9mX3JlYWNoZWQiLCJsZXhfYmFzZSIsImxleF9iYWNrdHJrIiwibGV4X2RlZmF1bHQiLCJsZXhfdHJhbnMiLCJsZXhfY2hlY2siLCJiYWNrdHJrIiwiY2FtbF9zeXNfZmlsZV9leGlzdHMiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9hcnJheV9zdWIiLCJjYW1sX2J5dGVzX2VxdWFsIiwiY2FtbF9ncl9zaXplX3giLCJCYXNlX2ludF9tYXRoX2ludDMyX2NseiIsImNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMiLCJzaG91bGRfdXNlX3RpbWV6b25lX2pzX2xvYWRlciIsInllcyIsIl9wbGF0Zm9ybV9ub3Rfc3VwcG9ydGVkIiwiZGlzYWJsZWQiLCJjYW1sX2F0b21pY19mZXRjaF9hZGQiLCJyZWYiLCJvc190eXBlIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiIsImNhbWxfY29zaF9mbG9hdCIsIk1sTXV0ZXgiLCJjYW1sX21sX211dGV4X25ldyIsImNhbWxfZXBoZV9rZXlfb2Zmc2V0IiwiY2FtbF9lcGhlX2NoZWNrX2tleSIsIndlYWsiLCJjYW1sX2hhc2hfbWl4X2ZpbmFsIiwiY2FtbF9ncl90ZXh0X3NpemUiLCJ0eHQiLCJjYW1sX2xleF9ydW5fbWVtIiwibWVtIiwiY3Vycl9wb3MiLCJjYW1sX2xleF9ydW5fdGFnIiwiY2FtbF9uZXdfbGV4X2VuZ2luZSIsImxleF9tZW0iLCJsZXhfYmFzZV9jb2RlIiwibGV4X2JhY2t0cmtfY29kZSIsImxleF9kZWZhdWx0X2NvZGUiLCJsZXhfdHJhbnNfY29kZSIsImxleF9jaGVja19jb2RlIiwibGV4X2NvZGUiLCJwY19vZmYiLCJwc3RhdGUiLCJiYXNlX2NvZGUiLCJjYW1sX2JhX3VpbnQ4X3NldDY0IiwiY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9sZXNzZXF1YWwiLCJjYW1sX2Fjb3NoX2Zsb2F0IiwiY2FtbF9NRDVJbml0IiwiQXJyYXlCdWZmZXIiLCJiMzIiLCJVaW50MzJBcnJheSIsImNhbWxfbWxfZmx1c2giLCJjYW1sX3NlZWtfb3V0IiwiY2FtbF9tbF9zZWVrX291dF82NCIsImNvbXBhcmVfbmF0X3JlYWwiLCJjYW1sX2djX3NldCIsImNhbWxfanNfZ2V0IiwiY2FtbF91bml4X2lzYXR0eSIsImZpbGVEZXNjcmlwdG9yIiwidHR5IiwiY2FtbF9tbF9zZXRfYnVmZmVyZWQiLCJjYW1sX2hhc2hfbWl4X2J5dGVzX2FyciIsImNhbWxfbWxfYnl0ZXNfY29udGVudCIsImNhbWxfaGFzaF9taXhfYnl0ZXMiLCJjYW1sX2hhc2giLCJzZWVkIiwicXVldWUiLCJyZCIsIndyIiwiQmFzZV9oYXNoX3N0cmluZyIsImNhbWxfZ2NfY29tcGFjdGlvbiIsImJpbl9wcm90X2JsaXRfZmxvYXRfYXJyYXlfYnVmX3N0dWIiLCJmbG9hdDY0IiwiZmxvYXQ2NF91aW50OCIsImNhbWxfc3lzX29wZW5fZm9yX25vZGUiLCJmcyIsImZkMiIsImNhbWxfc3lzX2ZkcyIsIk1sRmFrZUZkX291dCIsImNhbWxfc3lzX29wZW5faW50ZXJuYWwiLCJpZHgiLCJjYW1sX3N5c19vcGVuIiwiX3Blcm1zIiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4iLCJyZWZpbGwiLCJjaGFubmVsIiwiY2FtbF9NRDVGaW5hbCIsImNhbWxfc3RyaW5nX29mX2FycmF5IiwiY2FtbF9tZDVfY2hhbiIsInRvcmVhZCIsImNhbWxfc3lzX2Nsb3NlIiwiY2FtbF9tbF9jbG9zZV9jaGFubmVsIiwiY29yZV9tZDVfZmQiLCJpYyIsImNhbWxfZXBoZV9nZXRfa2V5IiwiY2FtbF91bml4X2xvY2FsdGltZSIsImRfbnVtIiwiamFudWFyeWZpcnN0IiwiZG95IiwiamFuIiwianVsIiwic3RkVGltZXpvbmVPZmZzZXQiLCJjYW1sX3VuaXhfbWt0aW1lIiwidG0iLCJ0bTIiLCJwcHhfZXhwZWN0X3J1bnRpbWVfb3V0X2NoYW5uZWxfcG9zaXRpb24iLCJpbmZvIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYSIsIkJhc2VfaW50X21hdGhfaW50X3Bvd19zdHViIiwiZXhwb25lbnQiLCJvbmUiLCJtdWwiLCJjYW1sX2F0b21pY19leGNoYW5nZSIsImNhbWxfc3lzX2lzYXR0eSIsIl9jaGFuIiwiaXNfZGlnaXRfemVybyIsImNhbWxfdW5peF9sc3RhdCIsImNhbWxfdW5peF9sc3RhdF82NCIsImNhbWxfanNfc2V0IiwiY2FtbF9hcnJheV9nZXQiLCJjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGMiLCJjb250IiwiY2FtbF91bml4X3JtZGlyIiwiY2FtbF9sb2cyX2Zsb2F0IiwiY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50IiwiY2FtbF9ydW50aW1lX2V2ZW50c19yZXN1bWUiLCJiaW5fcHJvdF9ibGl0X2J5dGVzX2J1Zl9zdHViIiwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUiLCJjYW1sX2ludDY0X3N1YiIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEiLCJiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkiLCJ0YSIsImJpbl9wcm90X2JsaXRfYnVmX3N0dWIiLCJjYW1sX3NlZWtfaW4iLCJjYW1sX21sX3NlZWtfaW5fNjQiLCJjYW1sX2RvbWFpbl9pZCIsImNhbWxfbWxfbXV0ZXhfdW5sb2NrIiwiY2FtbF9kb21haW5fbGF0ZXN0X2lkeCIsImNhbWxfZG9tYWluX3NwYXduIiwibXV0ZXgiLCJjYW1sX3VuaXhfbWtkaXIiLCJwZXJtIiwiY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IiwiY2FtbF9ub3RlcXVhbCIsImNhbWxfc3lzX2NvbnN0X2ludF9zaXplIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrIiwiRnVuY3Rpb24iLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayIsImNhbWxfaXNfanMiLCJjYW1sX3NzZTJfZmxvYXQ2NF9taW5fYnl0ZWNvZGUiLCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2Zsb2F0IiwiY2FtbF9sYXp5X3VwZGF0ZV90b19mb3J3YXJkIiwiY2FtbF9iYV9kaW0iLCJjYW1sX2JhX2RpbV8xIiwiY2FtbF9qc19tZXRoX2NhbGwiLCJjYW1sX2VwaGVfZGF0YV9vZmZzZXQiLCJjYW1sX3dlYWtfY3JlYXRlIiwiY2FtbF9lcGhlX2NyZWF0ZSIsImJpZ3N0cmluZ19kZXN0cm95X3N0dWIiLCJ2X2JzdHIiLCJiaWdzdHJpbmdfcmVhbGxvYyIsIm5ld19kYXRhIiwibmV3X2JpZ3N0cmluZyIsInBweF9leHBlY3RfcnVudGltZV9mbHVzaF9zdHVic19zdHJlYW1zIiwidnVuaXQiLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwiQmFzZV91bnNhZmVfY3JlYXRlX2xvY2FsX2J5dGVzIiwidl9sZW4iLCJjYW1sX3RyYW1wb2xpbmUiLCJjYW1sX21heWJlX3ByaW50X3N0YXRzIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc19nZXQ2NCIsImNhbWxfY3VzdG9tX2V2ZW50X2luZGV4IiwiY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3JlZ2lzdGVyIiwiZXZlbnRfbmFtZSIsImV2ZW50X3RhZyIsImV2ZW50X3R5cGUiLCJjYW1sX3VuaXhfaGFzX3N5bWxpbmsiLCJjYW1sX2VwaGVfc2V0X2tleSIsImNhbWxfZXBoZV91bnNldF9rZXkiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IiLCJjYW1sX3N0cmluZ19nZXQzMiIsImNhbWxfYnl0ZXNfZ2V0IiwiY2FtbF9oeXBvdF9mbG9hdCIsImNhbWxfanNfY2FsbCIsImNhbWxfc3lzX2NvbnN0X21heF93b3NpemUiLCJjYW1sX3VuaXhfaW5ldF9hZGRyX29mX3N0cmluZyIsIm1zX2Zsb2F0X3RvX25zX2ludDY0IiwibXMiLCJCYXNlX2FtX3Rlc3RpbmciLCJjYW1sX2J5dGVzX2xlc3N0aGFuIiwiYmlnc3RyaW5nYWZfYmxpdF90b19ieXRlcyIsImNhbWxfZXJmY19mbG9hdCIsImNhbWxfZ3JfZmlsbF9wb2x5IiwiYXIiLCJjYW1sX2djX3F1aWNrX3N0YXQiLCJjYW1sX21sX2lucHV0X2NoYXIiLCJjYW1sX21sX2lucHV0X2ludCIsImNhbWxfZ3JfZGlzcGxheV9tb2RlIiwiY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzIiwibnRoX2RpZ2l0X25hdCIsImNhbWxfYXJyYXlfYmxpdCIsImNhbWxfZmxvYXRfb2Zfc3RyaW5nIiwibTMiLCJtYW50aXNzYSIsImNhbWxfc3lzX2dldGN3ZCIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9pbnQ2NF9tdWwiLCJjYW1sX2ludDY0X3VsdCIsImNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSIsImNhbWxfcGFyc2VfZGlnaXQiLCJjYW1sX2ludDY0X29mX3N0cmluZyIsImJhc2U2NCIsInRocmVzaG9sZCIsImNhbWxfYmFfc2V0XzEiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfaW50NjRfb3IiLCJjYW1sX2x4bV9uZXh0Iiwic2hpZnRfbCIsInNoaWZ0X3IiLCJvciIsInhvciIsInJvdGwiLCJnZXQiLCJzZXQiLCJkYWJhIiwicTAiLCJxMSIsIngwIiwiY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiIsImNhbWxfbGlzdF90b19qc19hcnJheSIsImNhbWxfb3V0cHV0X3ZhbCIsIldyaXRlciIsIm5vX3NoYXJpbmciLCJjbG9zdXJlcyIsImludGVybl9vYmpfdGFibGUiLCJtZW1vIiwiZXhpc3Rpbmdfb2Zmc2V0IiwiZXh0ZXJuX3JlYyIsIm9wcyIsInN6XzMyXzY0IiwiaGVhZGVyX3BvcyIsIm9sZF9wb3MiLCJ0eXBlX29mX3YiLCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmciLCJjYW1sX3JhaXNlX25vdF9hX2RpciIsImNhbWxfc3lzX3N5c3RlbV9jb21tYW5kIiwiY21kIiwiY2hpbGRfcHJvY2VzcyIsImNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uIiwiY2FtbF91bml4X2dldHVpZCIsImRlc2VyaWFsaXplX25hdCIsImluaXRpYWxpemVfbmF0IiwiY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyIsImJpZ3N0cmluZ19tZW1jbXBfc3R1YiIsInZfczEiLCJ2X3MxX3BvcyIsInZfczIiLCJ2X3MyX3BvcyIsImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3ciLCJVSW50OEFycmF5UmVhZGVyIiwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSIsInJlYWR2bHEiLCJvdmVyZmxvdyIsIm43IiwiaGVhZGVyX2xlbiIsImRhdGFfbGVuIiwiTWxTdHJpbmdSZWFkZXIiLCJjYW1sX2RlY29tcHJlc3NfaW5wdXQiLCJjYW1sX2Zsb2F0X29mX2J5dGVzIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciIsIm1hZ2ljIiwiY29tcHJlc3NlZCIsInVuY29tcHJlc3NlZF9kYXRhX2xlbiIsIm51bV9vYmplY3RzIiwiX3NpemVfMzIiLCJfc2l6ZV82NCIsIm9ial9jb3VudGVyIiwiaW50ZXJuX3JlYyIsImhlYWRlciIsImV4cGVjdGVkX3NpemUiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWUiLCJibG9jayIsImNhbWxfaW5wdXRfdmFsdWVfdG9fb3V0c2lkZV9oZWFwIiwiY2FtbF9hdG9taWNfY2FzIiwiY2FtbF9jb3B5c2lnbl9mbG9hdCIsImNhbWxfZ3Jfc2V0X3RleHRfc2l6ZSIsImNhbWxfYXRvbWljX2xvYWQiLCJjYW1sX21kNV9ieXRlcyIsImNhbWxfYmFfc2V0X2dlbmVyaWMiLCJjYW1sX21sX2NvbmRpdGlvbl93YWl0IiwibXV0ZXh0IiwiY2FtbF9zdHJpbmdfbGVzc2VxdWFsIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsIiwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXQiLCJiaXRzIiwiY2FtbF9ncl9zaXplX3kiLCJjb3JlX2djX21pbm9yX2NvbGxlY3Rpb25zIiwiY2FtbF9wb3NfaW4iLCJjYW1sX21sX3Bvc19pbiIsImNhbWxfaW50NjRfYW5kIiwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9wb3dfc3R1YiIsImNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSIsImNhbWxfcnVudGltZV9ldmVudHNfcGF1c2UiLCJjYW1sX3VuaXhfdW5saW5rIiwiY2FtbF9zdHJpbmdfZ2V0IiwicmVfbWF0Y2giLCJyZV93b3JkX2xldHRlcnMiLCJvcGNvZGVzIiwiaXNfd29yZF9sZXR0ZXIiLCJpbl9iaXRzZXQiLCJyZV9tYXRjaF9pbXBsIiwicGFydGlhbCIsInByb2ciLCJjcG9vbCIsIm5vcm10YWJsZSIsIm51bWdyb3VwcyIsIm51bXJlZ2lzdGVycyIsInN0YXJ0Y2hhcnMiLCJwYyIsInF1aXQiLCJncm91cHMiLCJyZV9yZWdpc3RlciIsImJhY2t0cmFjayIsIml0ZW0iLCJwdXNoIiwiYWNjZXB0IiwicHJlZml4X21hdGNoIiwib3AiLCJzYXJnIiwidWFyZyIsImdyb3VwIiwicmVfc2VhcmNoX2JhY2t3YXJkIiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfbWxfb3V0cHV0X3RhIiwiY2FtbF9iYV9zdWIiLCJjaGFuZ2VkX2RpbSIsIm5ld19kaW1zIiwiY29yZV9nY19jb21wYWN0aW9ucyIsImNhbWxfZ2NfZnVsbF9tYWpvciIsImNhbWxfbWxfbXV0ZXhfdHJ5X2xvY2siLCJjYW1sX2J5dGVzX3NldDMyIiwiaTMyIiwiY2FtbF9ncl9zaWdpb19zaWduYWwiLCJjYW1sX2JhX3VpbnQ4X3NldDMyIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXgiLCJjYW1sX3VuaXhfZ210aW1lIiwiY2FtbF9zaWduYml0X2Zsb2F0IiwiY2FtbF9ncl9jdXJyZW50X3giLCJjYW1sX2dyX3NldF9saW5lX3dpZHRoIiwiY2FtbF9ncl9zZXRfZm9udCIsImNhbWxfZ3Jfc2V0X2NvbG9yIiwiY29udmVydCIsImNfc3RyIiwiY2FtbF9ncl9tb3ZldG8iLCJjYW1sX2dyX3Jlc2l6ZV93aW5kb3ciLCJjYW1sX2dyX3N0YXRlX2luaXQiLCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkiLCJVaW50OENsYW1wZWRBcnJheSIsImNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSIsInRpbWVfbm93X25hbm9zZWNvbmRfY291bnRlcl9mb3JfdGltaW5nIiwibXNfc2luY2VfcHJvZ3JhbV9zdGFydGVkIiwicGVyZm9ybWFuY2UiLCJuc19zaW5jZV9wcm9ncmFtX3N0YXJ0ZWQiLCJjYW1sX21sX3NlZWtfb3V0IiwiY2FtbF9qc190eXBlb2YiLCJjYW1sX3N0cmluZ19oYXNoIiwiY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UiLCJCYXNlX2ludF9tYXRoX2ludDMyX2N0eiIsIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0eiIsImNhbWxfZ3JfbGluZXRvIiwiY2FtbF9qc19mdW5jdGlvbl9hcml0eSIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSIsImNhbWxfYmFfZGltXzMiLCJwcHhfZXhwZWN0X3J1bnRpbWVfYWZ0ZXJfdGVzdCIsImNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24iLCJjYW1sX2Zvcm1hdF9leGNlcHRpb24iLCJidWNrZXQiLCJzdGFydCIsImNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uIiwiaGFuZGxlciIsImF0X2V4aXQiLCJjYW1sX2VwaGVfY2hlY2tfZGF0YSIsImNhbWxfYnl0ZXNfZ2V0MTYiLCJjYW1sX29ial9tYWtlX2ZvcndhcmQiLCJjYW1sX2pzX2Zyb21fYm9vbCIsImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSIsImNhbWxfZXhwMl9mbG9hdCIsImNhbWxfZ3JfY2xvc2VfZ3JhcGgiLCJiaWdzdHJpbmdfbWVtY21wX2J5dGVzX3N0dWIiLCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludCIsImNhbWxfbWxfZG9tYWluX2NwdV9yZWxheCIsImNhbWxfY3JlYXRlX3N0cmluZyIsIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2NseiIsImJpZ3N0cmluZ19tZW1zZXRfc3R1YiIsInZfcG9zIiwidl9jaGFyIiwiY2FtbF9hdGFuaF9mbG9hdCIsImNhbWxfbWxfY29uZGl0aW9uX3NpZ25hbCIsImNhbWxfdW5peF9maW5kbmV4dCIsImNhbWxfbWxfb3V0cHV0X2J5dGVzIiwiY2FtbF9tbF9vdXRwdXQiLCJjYW1sX21sX2RvbWFpbl9pZCIsImNhbWxfZXBoZV9nZXRfZGF0YSIsImNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlIiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImNhbWxfbWxfaXNfYnVmZmVyZWQiLCJjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyIsImludGVybmFsaGFzaF9mb2xkX2JpZ3N0cmluZyIsIkJhc2VfaW50X21hdGhfaW50NjRfY2x6IiwiY2FtbF9hcnJheV9hcHBlbmQiLCJsMSIsImwyIiwiY2FtbF91bml4X2dldHRpbWVvZmRheSIsImNhbWxfdW5peF90aW1lIiwidGltZXpvbmVfanNfbG9hZGVyX2dldF9uZXh0X3RyYW5zaXRpb25fb3JfdGhpc190aW1lX2lmX25vbmUiLCJyZXQiLCJjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbCIsImNhbWxfcnVudGltZV9ldmVudHNfY3JlYXRlX2N1cnNvciIsImNhbWxfZmlsbF9ieXRlcyIsImNhbWxfanNfZXhwciIsImNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIiwiY29yZV9nY19ydW5fbWVtcHJvZl9jYWxsYmFja3MiLCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyIsImNhbWxfZXZlbnRsb2dfcmVzdW1lIiwiY2FtbF9tZDVfc3RyaW5nIiwiY2FtbF9hcnJheV9vZl9zdHJpbmciLCJjYW1sX3N0cmluZ19lcXVhbCIsImNhbWxfanNvb19mbGFnc191c2VfanNfc3RyaW5nIiwienN0ZF9kZWNvbXByZXNzIiwiYWIiLCJ1OCIsInUxNiIsInUzMiIsInNsYyIsImZpbGwiLCJjcHciLCJlYyIsImluZCIsInJiIiwicnpmaCIsImRhdCIsIm4zIiwiZmxnIiwic3MiLCJjYyIsImRmIiwiZmNmIiwiZGIiLCJkaSIsImZzYiIsImZzcyIsIndzIiwid2IiLCJtc2IiLCJ2YWwiLCJyZnNlIiwibWFsIiwidHBvcyIsImFsIiwicHJvYnMiLCJzeW0iLCJmcmVxIiwiZHN0YXRlIiwibnN0YXRlIiwiYmIxIiwic3ltcyIsImNidCIsIm1zayIsIm1zazFmYiIsIm1zdiIsInN2YWwiLCJyYnQiLCJzeW1wb3MiLCJzc3RlcCIsInNtYXNrIiwic2YiLCJucyIsIm5iIiwicmh1Iiwid2MiLCJoYiIsImh3IiwicmMiLCJyaSIsImVidCIsImZkdCIsImVwb3MiLCJsYiIsInN0MSIsInN0MiIsImJ0cjEiLCJidHIyIiwiZnBvcyIsImJ5dGUiLCJ3ZXMiLCJtYiIsInRzIiwiaGJ1ZiIsInB2IiwiZGxsdCIsImRtbHQiLCJkb2N0IiwiYjJibCIsImJsIiwibGxiIiwibGxibCIsIm1sYiIsIm1sYmwiLCJkaHUiLCJvdXQiLCJodSIsImViIiwiYnRyIiwiZGh1NCIsInN6MSIsInN6MiIsInN6MyIsInJ6YiIsImIwIiwiYnR5cGUiLCJsYnQiLCJsc3MiLCJsY3MiLCJzNCIsInNwbCIsImh1ZCIsInNjbSIsImR0cyIsIm1kIiwicmJ1ZiIsIl9iIiwibWx0Iiwib2N0IiwibGx0Iiwic3BvcyIsIm91YnQiLCJsc3QiLCJvc3QiLCJtc3QiLCJsbGMiLCJsYnRyIiwibWxjIiwibWJ0ciIsIm9mYyIsIm9idHIiLCJvZnAiLCJtbCIsImxsIiwic3RpbiIsImNjdCIsImJ1ZnMiLCJvbCIsImNoayIsImJsayIsImNhbWxfenN0ZF9pbml0aWFsaXplIiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIiwicmVfcmVwbGFjZW1lbnRfdGV4dCIsInJlcGwiLCJvcmlnIiwiY3VyIiwiZW5kIiwiY2FtbF9wdXJlX2pzX2V4cHIiLCJjYW1sX2JsaXRfc3RyaW5nIiwiYmxpdF9uYXQiLCJjb3JlX2djX3RvcF9oZWFwX3dvcmRzIiwiY2FtbF91bml4X3N0YXQiLCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIiwianNvb19jcmVhdGVfZmlsZV9leHRlcm4iLCJjYW1sX3VuaXhfc3RhdF82NCIsImNhbWxfdG9fanNfc3RyaW5nIiwiY2FtbF9tbF9tdXRleF9sb2NrIiwicmVfc2VhcmNoX2ZvcndhcmQiLCJjYW1sX21ha2VfdmVjdCIsImNhbWxfbWxfc2Vla19pbiIsImNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5IiwiY2FtbF9tbF9vdXRwdXRfY2hhciIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiIsImNhbWxfb2JqX2lzX2Jsb2NrIiwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZCIsImNhbWxfanNfdmFyIiwiY2FtbF90cnVuY19mbG9hdCIsImNhbWxfZXBoZV91bnNldF9kYXRhIiwiY2FtbF9lcGhlX3NldF9kYXRhIiwiY2FtbF9lcGhlX2JsaXRfZGF0YSIsInRpbWV6b25lX2pzX2xvYWRlcl9pbnN0YW50X3BsdXNfaG91cnMiLCJkdXJhdGlvbiIsImxlbmd0aF9uYXQiLCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludDY0IiwiY2FtbF9pc19wcmludGFibGUiLCJjYW1sX2J5dGVzX2xlc3NlcXVhbCIsImNhbWxfYXJyYXlfb2ZfYnl0ZXMiLCJjYW1sX2VxdWFsIiwicmVfcGFydGlhbF9tYXRjaCIsImNhbWxfc3lzX3JhbmRvbV9zZWVkIiwibm93IiwiYWxsX2ZpbmFsaXplcnMiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIiwiY2IiLCJjYW1sX2NzZWxfdmFsdWUiLCJ2X2NvbmQiLCJ2X3RydWUiLCJ2X2ZhbHNlIiwiY2FtbF9iYV9nZXRfMiIsImNhbWxfYmFfdWludDhfc2V0MTYiLCJjYW1sX2xhenlfcmVzZXRfdG9fbGF6eSIsInRpbWV6b25lX2pzX2xvYWRlcl9lbmFibGVfZm9yX3Rlc3RpbmciLCJjYW1sX2pzX2RlbGV0ZSIsImNhbWxfaW50X29mX3N0cmluZyIsImNhbWxfbGlzdF9tb3VudF9wb2ludCIsImNhbWxfbWFyc2hhbF9jb25zdGFudHMiLCJjYW1sX29ial9yYXdfZmllbGQiLCJjYW1sX2pzX2VxdWFscyIsImNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXAiLCJiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2dyX2FyY19hdXgiLCJjeCIsImN5IiwicnkiLCJyeCIsInJvdCIsInhQb3MiLCJ5UG9zIiwieFBvc19wcmV2IiwieVBvc19wcmV2Iiwic3BhY2UiLCJkZWx0YSIsImNhbWxfZ3JfZmlsbF9hcmMiLCJjYW1sX2JhX3NsaWNlIiwibnVtX2luZHMiLCJzdWJfZGltcyIsImNhbWxfanNfd3JhcF9jYWxsYmFja191bnNhZmUiLCJjYW1sX2JhX2tpbmQiLCJ0aW1lem9uZV9qc19sb2FkZXJfZGlzYWJsZV9mb3JfdGVzdGluZyIsImNhbWxfYWxsb2NfZHVtbXlfaW5maXgiLCJjYW1sX2pzX3N0cmljdF9lcXVhbHMiLCJjYW1sX2pzX2Z1bl9jYWxsIiwiY2FtbF9nY19tYWpvcl9zbGljZSIsIndvcmsiLCJjYW1sX2pzX3B1cmVfZXhwciIsImNvcmVfYXJyYXlfdW5zYWZlX2ludF9ibGl0IiwiY29tcGFyZV9kaWdpdHNfbmF0IiwiY2FtbF9tbF9pbnB1dCIsImNhbWxfZ3Jfd2FpdF9ldmVudCIsIl9ldmwiLCJjYW1sX2dyX3NpZ2lvX2hhbmRsZXIiLCJjYW1sX21lbXByb2ZfZGlzY2FyZCIsImNhbWxfcmVjb3JkX2JhY2t0cmFjZSIsImNhbWxfdW5peF9jbGVhbnVwIiwiY2FtbF9zeXNfZ2V0X2NvbmZpZyIsImNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSIsImNvcmVfaGVhcF9ibG9ja19pc19oZWFwX2Jsb2NrIiwiY2FtbF9vYmpfaXNfc2hhcmVkIiwiY29yZV9nY19wcm9tb3RlZF93b3JkcyIsImNhbWxfZHVtbXlfb2JqX2lzX3N0YWNrIiwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCIsImNhbWxfYXNpbmhfZmxvYXQiLCJjYW1sX3Bvc19vdXQiLCJiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIiwiY2FtbF9tb2QiLCJjYW1sX2JhX2luaXQiLCJjYW1sX3VuaXhfZmlsZWRlc2NyX29mX2ZkIiwicmVfc3RyaW5nX21hdGNoIiwiQmlnU3RyaW5nUmVhZGVyIiwiY2FtbF9ncl9kdW1wX2ltYWdlIiwiY2FtbF9iYV9nZXRfZ2VuZXJpYyIsImNhbWxfdW5peF9zdGFydHVwIiwiY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSIsImNhbWxfZm9ybWF0X2Zsb2F0IiwidG9GaXhlZCIsImRwIiwicHJlYyIsImNhbWxfbW91bnRfYXV0b2xvYWQiLCJCYXNlX2ludF9tYXRoX2ludF9jbHoiLCJjYW1sX3N0cmluZ19sZXNzdGhhbiIsImNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuIiwiY2FtbF9kaXYiLCJjYW1sX29ial9kdXAiLCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSIsImNhbWxfbWVtcHJvZl9zdGFydCIsInJhdGUiLCJzdGFja19zaXplIiwidHJhY2tlciIsImNhbWxfc3lzX2dldF9hcmd2IiwiY2FtbF9tbF9kb21haW5fc2V0X25hbWUiLCJfbmFtZSIsImNhbWxfanNfdG9fYm9vbCIsImNhbWxfZ3JfY3JlYXRlX2ltYWdlIiwiY2FtbF9lcGhlX2dldF9rZXlfY29weSIsImNhbWxfbGVzc3RoYW4iLCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IiwiYmlnc3RyaW5nYWZfbWVtY21wX3N0cmluZyIsImJhX29mZiIsInN0cl9vZmYiLCJ0aW1lem9uZV9qc19sb2FkZXJfY29tcGFyZV9pbnN0YW50cyIsImNhbWxfYnVpbGRfc3ltYm9scyIsInRvYyIsInN5bWIiLCJjYW1sX3JlZ2lzdGVyX2dsb2JhbCIsIm5hbWVfb3B0IiwibmlkIiwibXVsdF9uYXQiLCJsZW4zIiwic3F1YXJlX25hdCIsImNvcmVfbWQ1X2RpZ2VzdF9zdWJiaWdzdHJpbmciLCJyZXMyIiwiYmlnc3RyaW5nX21lbW1lbV9ieXRlY29kZSIsImhheXN0YWNrIiwibmVlZGxlIiwiaGF5c3RhY2tfcG9zIiwiaGF5c3RhY2tfbGVuIiwibmVlZGxlX3BvcyIsIm5lZWRsZV9sZW4iLCJsaW0iLCJtYXRjaGVzIiwiY2FtbF9qc19mcm9tX2Zsb2F0IiwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSIsImNhbWxfZ2Nfc3RhdCIsImNhbWxfZ2V0X21ham9yX2NyZWRpdCIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luX3dpdGhfZmxhZ3MiLCJiaWdzdHJpbmdhZl9tZW1jaHIiLCJjYW1sX3N5c19tb2RpZnlfYXJndiIsImNhbWxfbWV0aG9kX2NhY2hlIiwiY2FtbF9nZXRfcHVibGljX21ldGhvZCIsImNhY2hlaWQiLCJtZXRocyIsImxpIiwiYmluX3Byb3RfYmxpdF9idWZfYnl0ZXNfc3R1YiIsImNhbWxfanNfZ2V0X2NvbnNvbGUiLCJjYW1sX3N5c191bnNhZmVfZ2V0ZW52IiwiY2FtbF9yb3VuZF9mbG9hdCIsImNhbWxfb2pzX25ld19hcnIiLCJjb21wbGVtZW50X25hdCIsImNhbWxfZG9tYWluX2RscyIsImNhbWxfZG9tYWluX2Rsc19zZXQiLCJjYW1sX29ial90YWciLCJjYW1sX2xhenlfcmVhZF9yZXN1bHQiLCJjYW1sX2pzX3JlZ2V4cHMiLCJjYW1sX2pzX2h0bWxfZXNjYXBlIiwiY2FtbF9iYV9kaW1fMiIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc2luaF9mbG9hdCIsImNvcmVfZ2NfbWFqb3JfcGx1c19taW5vcl93b3JkcyIsImNhbWxfbGRleHBfZmxvYXQiLCJjYW1sX2dyX3N0YXRlX3NldCIsImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QiLCJhcml0eSIsImNhbWxfZ2NfbWlub3Jfd29yZHMiLCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayIsImxhbmRfZGlnaXRfbmF0IiwiY2FtbF9pbnQ2NF9tb2QiLCJjYW1sX29ial9zZXRfdGFnIiwiY2FtbF9pbnQzMl9ic3dhcCIsImNhbWxfYmFfc2V0XzMiLCJjYW1sX2pzX2luc3RhbmNlb2YiLCJjYW1sX2dldF9tYWpvcl9idWNrZXQiLCJudGhfZGlnaXRfbmF0X25hdGl2ZSIsInNldF9kaWdpdF9uYXRfbmF0aXZlIiwiZGlnaXQiLCJjYW1sX3N0cmluZ19zZXQ2NCIsImNhbWxfZ3Jfc3RhdGVfY3JlYXRlIiwiY2FudmFzIiwiY29udGV4dCIsImNhbWxfZ3JfZHJhd19hcmMiLCJjYW1sX2JhX21hcF9maWxlIiwidmZkIiwic2hhcmVkIiwiY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZSIsImFyZ24iLCJjYW1sX2JhX2NyZWF0ZV9mcm9tIiwiZGF0YTEiLCJkYXRhMiIsImpzdHlwIiwiY2FtbF90YW5oX2Zsb2F0IiwiQmFzZV9pbnRfbWF0aF9pbnRfY3R6IiwiYmlnc3RyaW5nX2JsaXRfc3RyaW5nX2JpZ3N0cmluZ19zdHViIiwiY2FtbF9ydW50aW1lX2V2ZW50c19zdGFydCIsImNhbWxfZ3JfZHJhd19zdHIiLCJkeCIsImNhbWxfZ3JfZHJhd19zdHJpbmciLCJjYW1sX2dyX2RyYXdfY2hhciIsImNhbWxfdW5tb3VudCIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmciLCJjYW1sX21sX3Bvc19pbl82NCIsImNhbWxfZ3JfZHJhd19pbWFnZSIsImltYWdlIiwiY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUiLCJfY2hhbm5lbCIsImNhbWxfc3RyaW5nX3NldCIsImNhbWxfc3lzX3JtZGlyIiwidGltZXpvbmVfanNfbG9hZGVyX2Zyb21fZXBvY2hfc2Vjb25kcyIsInNlY29uZHMiLCJjYW1sX3VuaXhfc3ltbGluayIsInNyY19yb290IiwiZHN0X3Jvb3QiLCJCYXNlX2ludF9tYXRoX2ludDY0X2N0eiIsImlzX3plcm8iLCJsYW5kIiwic21hbGxfaW50NjQiLCJjYW1sX21sX3Bvc19vdXQiLCJjb3JlX2FycmF5X3Vuc2FmZV9mbG9hdF9ibGl0IiwiQmFzZV9jYW1sX2V4bl9pc19tb3N0X3JlY2VudF9leG4iLCJjYW1sX3NwYWNldGltZV9lbmFibGVkIiwiY2FtbF9ieXRlc19ub3RlcXVhbCIsImNhbWxfcnVudGltZV9wYXJhbWV0ZXJzIiwiY2FtbF9qc19vYmplY3QiLCJjYW1sX2JhX2NyZWF0ZSIsImRpbXNfbWwiLCJjYW1sX2dyX3JlbWVtYmVyX21vZGUiLCJCYXNlX2ludGVybmFsaGFzaF9nZXRfaGFzaF92YWx1ZSIsImNhbWxfZm1hX2Zsb2F0IiwiU1BMSVQiLCJNSU5fVkFMVUUiLCJFUFNJTE9OIiwibXVsdGlwbHkiLCJhaGkiLCJhbG8iLCJiaGkiLCJibG8iLCJhZGp1c3QiLCJzY2FsZSIsInhzIiwieXMiLCJ6cyIsInh5IiwiY2FtbF9yZWNvbW1lbmRlZF9kb21haW5fY291bnQiLCJjYW1sX2Jzd2FwMTYiLCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZSIsImNhbWxfZmluYWxfcmVnaXN0ZXIiLCJjYW1sX2dyX2RyYXdfcmVjdCIsImNhbWxfc3RyaW5nX2dldDE2IiwidGltZXpvbmVfanNfbG9hZGVyX25vdyIsImNvcmVfZ2NfbWFqb3JfY29sbGVjdGlvbnMiLCJjYW1sX2pzX3RvX2ludDMyIiwiY2FtbF9vdXRwdXRfdmFsdWUiLCJjYW1sX21sX291dHB1dF9iaWdhcnJheSIsImNhbWxfYmFfZ2V0XzMiLCJjYW1sX2VwaGVfYmxpdF9rZXkiLCJjYW1sX2luaXRpYWxfdGltZSIsImNhbWxfc3lzX3RpbWUiLCJjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4iLCJCYXNlX2NsZWFyX2NhbWxfYmFja3RyYWNlX3BvcyIsImNhbWxfdW5peF9nZXRwd3VpZCIsInRpbWV6b25lX2pzX2xvYWRlcl9lcG9jaF9zZWNvbmRzIiwiY2FtbF9kb21haW5fZGxzX2dldCIsImNhbWxfYnl0ZXNfZ2V0MzIiLCJjYW1sX2ZyZXhwX2Zsb2F0IiwibmVnIiwiYmlnc3RyaW5nX2JsaXRfYnl0ZXNfYmlnc3RyaW5nX3N0dWIiLCJjb3JlX3RpbWVfbnNfZm9ybWF0IiwidGltZSIsImZvcm1hdGpzIiwianN0cmluZyIsImNhbWxfc3RyaW5nX2dldDY0IiwiY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uIiwiY2FtbF9tbF9wb3Nfb3V0XzY0IiwiY2FtbF91bml4X2ZpbmRjbG9zZSIsImNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93IiwiY2FtbF9mbG9hdGFycmF5X2JsaXQiLCJjYW1sX2dldF9taW5vcl9mcmVlIiwiY2FtbF9zZXRfc3RhdGljX2VudiIsImNhbWxfYmFfY2hhbmdlX2xheW91dCIsIkJhc2VfaGFzaF9kb3VibGUiLCJjYW1sX2pzX25ldyIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCIsImJ1ZmZlcmVkIiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0X3dpdGhfZmxhZ3MiLCJiaWdzdHJpbmdfYWxsb2NfdjIiLCJjYW1sX2dyX2N1cnJlbnRfeSIsImNhbWxfZm9ybWF0X2ludCIsImNvcmVfZ2NfaGVhcF93b3JkcyIsImpzb29fZWZmZWN0X25vdF9zdXBwb3J0ZWQiLCJjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW5fIiwiY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuIiwiY2FtbF9jb250aW51YXRpb25fdXNlX2FuZF91cGRhdGVfaGFuZGxlcl9ub2V4YyIsImh2YWwiLCJoZXhuIiwiaGVmZiIsImNhbWxfb2JqX3RydW5jYXRlIiwiY2FtbF9qc190b19zdHJpbmciLCJjb3JlX2djX21pbm9yX3dvcmRzIiwiaXNfZGlnaXRfb2RkIiwiY2FtbF9ydW50aW1lX3ZhcmlhbnQiLCJjYW1sX2FycmF5X2NvbmNhdCIsImNhbWxfZ3Jfb3Blbl9ncmFwaCIsInNwZWNzIiwic3RhdHVzIiwid2luIiwidGl0bGUiLCJib2R5IiwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3QiLCJjYW1sX2NicnRfZmxvYXQiLCJjYW1sX2V2ZW50bG9nX3BhdXNlIiwiY2FtbF9tZW1wcm9mX3N0b3AiLCJjYW1sX2dyZWF0ZXJlcXVhbCIsImNhbWxfbWFrZV9sb2NhbF92ZWN0Iiwidl9lbHQiLCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSIsImNhbWxfbG9nMXBfZmxvYXQiLCJiaWdzdHJpbmdhZl9ibGl0X3RvX2JpZ3N0cmluZyIsIm1zX3RvX25hbm8iLCJ0aW1lX25vd19uYW5vc2Vjb25kc19zaW5jZV91bml4X2Vwb2NoX29yX3plcm8iLCJtc19pNjMiLCJjYW1sX3J1bnRpbWVfZXZlbnRzX2ZyZWVfY3Vyc29yIiwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZCIsImxvcl9kaWdpdF9uYXQiLCJjYW1sX2dyX2JsaXRfaW1hZ2UiLCJpbTIiLCJjYW1sX2dyX3dpbmRvd19pZCIsImNhbWxfYXRvbWljX21ha2VfY29udGVuZGVkIiwiY2FtbF9qc19vbl9pZSIsInVhIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCIsImNhbWxfYmFfbGF5b3V0IiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJjYW1sX2FycmF5X3NldCIsIm5ld3ZhbCIsImNhbWxfYWxsb2Nfc3RhY2siLCJodiIsImh4IiwiaGYiLCJjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbCIsInNldF9kaWdpdF9uYXQiLCJjYW1sX2J5dGVzX3NldDE2IiwiY2FtbF9ncl9kb2Nfb2Zfc3RhdGUiLCJjYW1sX21sX291dHB1dF9pbnQiLCJjYW1sX29ial93aXRoX3RhZyIsImNhbWxfbWxfY2hhbm5lbF9zaXplIiwiYmluX3Byb3RfYmxpdF9zdHJpbmdfYnVmX3N0dWIiLCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0Iiwic3R5bGUiLCJleHBfc2lnbiIsInNpZ25fc3RyIiwiY3N0IiwieF9zdHIiLCJjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfd3JpdGUiLCJldmVudCIsImV2ZW50X2NvbnRlbnQiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QiLCJjYW1sX3VuaXhfcmVhZGxpbmsiLCJjYW1sX2JhY2t0cmFjZV9zdGF0dXMiLCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIiLCJjYW1sX3N5c19hcmd2IiwiY2FtbF9iYV9maWxsIiwiY2FtbF9tb2RmX2Zsb2F0IiwiY2FtbF9nY19nZXQiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX3N0cmluZ19zZXQzMiIsImNhbWxfcGFyc2VfZW5naW5lIiwidGFibGVzIiwiZW52IiwiRVJSQ09ERSIsImxvb3AiLCJ0ZXN0c2hpZnQiLCJzaGlmdCIsInNoaWZ0X3JlY292ZXIiLCJyZWR1Y2UiLCJSRUFEX1RPS0VOIiwiUkFJU0VfUEFSU0VfRVJST1IiLCJHUk9XX1NUQUNLU18xIiwiR1JPV19TVEFDS1NfMiIsIkNPTVBVVEVfU0VNQU5USUNfQUNUSU9OIiwiQ0FMTF9FUlJPUl9GVU5DVElPTiIsImVudl9zX3N0YWNrIiwiZW52X3Zfc3RhY2siLCJlbnZfc3ltYl9zdGFydF9zdGFjayIsImVudl9zeW1iX2VuZF9zdGFjayIsImVudl9zdGFja3NpemUiLCJlbnZfc3RhY2tiYXNlIiwiZW52X2N1cnJfY2hhciIsImVudl9sdmFsIiwiZW52X3N5bWJfc3RhcnQiLCJlbnZfc3ltYl9lbmQiLCJlbnZfYXNwIiwiZW52X3J1bGVfbGVuIiwiZW52X3J1bGVfbnVtYmVyIiwiZW52X3NwIiwiZW52X3N0YXRlIiwiZW52X2VycmZsYWciLCJ0YmxfdHJhbnNsX2NvbnN0IiwidGJsX3RyYW5zbF9ibG9jayIsInRibF9saHMiLCJ0YmxfbGVuIiwidGJsX2RlZnJlZCIsInRibF9kZ290byIsInRibF9zaW5kZXgiLCJ0YmxfcmluZGV4IiwidGJsX2dpbmRleCIsInRibF90YWJsZXNpemUiLCJ0YmxfdGFibGUiLCJ0YmxfY2hlY2siLCJ0YmxfbmFtZXNfY29uc3QiLCJ0YmxfbmFtZXNfYmxvY2siLCJsb2ciLCJ0b2tlbl9uYW1lIiwibmFtZXMiLCJwcmludF90b2tlbiIsInRvayIsInRva2VuIiwibjEiLCJuMiIsInN0YXRlMSIsInNwIiwiZXJyZmxhZyIsImFzcCIsImNhbWxfanNvb19mbGFnc19lZmZlY3RzIiwiY29yZV9nY19tYWpvcl93b3JkcyIsImNhbWxfdXBkYXRlX2R1bW15IiwiY2FtbF9hcnJheV9maWxsIiwidGltZXpvbmVfanNfbG9hZGVyX2NyZWF0ZV96b25lIiwiem9uZV9uYW1lIiwiY2FtbF9zeXNfbWtkaXIiLCJiaWdzdHJpbmdfYmxpdF9zdHViIiwiY2FtbF9zdHJpbmdfbm90ZXF1YWwiLCJjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuIiwiY2FtbF9ncl9tYWtlX2ltYWdlIiwiQmFzZV9pbnRfbWF0aF9pbnRfcG9wY291bnQiLCJjYW1sX21sX3NldF9jaGFubmVsX291dHB1dCIsImNhbWxfcmVhZF9maWxlX2NvbnRlbnQiLCJjYW1sX2pzX3RvX2Zsb2F0IiwiY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsIm9yaWdpbiJdLCJzb3VyY2VzIjpbIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9jb3JlL3N0cmZ0aW1lLmpzIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2NvcmUvdGVtcG9yYWwtcG9seWZpbGwuanMiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvdmlydHVhbF9kb20vdmlydHVhbGRvbS5jb21waWxlZC5wcmV0dHkuanMiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvdmlydHVhbF9kb20vdGh1bmsuanMiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvdmlydHVhbF9kb20vaG9va3MuanMiLCIvYnVpbHRpbi8raW50NjQuanMiLCIvYnVpbHRpbi8rbWxCeXRlcy5qcyIsIi9idWlsdGluLytmYWlsLmpzIiwiL2J1aWx0aW4vK3N0ZGxpYi5qcyIsIi9idWlsdGluLytzeXMuanMiLCIvYnVpbHRpbi8rYmFja3RyYWNlLmpzIiwiL2J1aWx0aW4vK2pzbGliLmpzIiwiL2J1aWx0aW4vK2Zvcm1hdC5qcyIsIi9idWlsdGluLytpZWVlXzc1NC5qcyIsIi9idWlsdGluLytlZmZlY3QuanMiLCIvYnVpbHRpbi8rZnNfbm9kZS5qcyIsIi9idWlsdGluLytmcy5qcyIsIi9idWlsdGluLyt1bml4LmpzIiwiL2J1aWx0aW4vK2ZzX2Zha2UuanMiLCIvYnVpbHRpbi8rbmF0LmpzIiwiL2J1aWx0aW4vK2dyYXBoaWNzLmpzIiwiL2J1aWx0aW4vK3J1bnRpbWVfZXZlbnRzLmpzIiwiL2J1aWx0aW4vK21hcnNoYWwuanMiLCIvYnVpbHRpbi8raW8uanMiLCIvYnVpbHRpbi8rZ2MuanMiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvY29yZS9ydW50aW1lLmpzIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL29jYW1sX2ludHJpbnNpY3Nfa2VybmVsL3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rYmlnYXJyYXkuanMiLCIvYnVpbHRpbi8rY29tcGFyZS5qcyIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iaWdzdHJpbmdhZi9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK2JpZ3N0cmluZy5qcyIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlX2JpZ3N0cmluZy9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK2ludHMuanMiLCIvYnVpbHRpbi8raGFzaC5qcyIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2Jhc2VfaW50ZXJuYWxoYXNoX3R5cGVzL3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rcGFyc2luZy5qcyIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9jb3JlL3RpbWV6b25lX2pzX2xvYWRlcl9zdHVicy5qcyIsIi9idWlsdGluLytvYmouanMiLCIvYnVpbHRpbi8ranNsaWJfanNfb2Zfb2NhbWwuanMiLCIvYnVpbHRpbi8rYXJyYXkuanMiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmluX3Byb3QvcnVudGltZS5qcyIsIi9idWlsdGluLyttZDUuanMiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvcHB4X2V4cGVjdC9ydW50aW1lL3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rc3RyLmpzIiwiL2J1aWx0aW4vK2xleGluZy5qcyIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL3J1bnRpbWUuanMiLCIvYnVpbHRpbi8rZG9tYWluLmpzIiwiL2J1aWx0aW4vK3N5bmMuanMiLCIvYnVpbHRpbi8rd2Vhay5qcyIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi90aW1lX25vdy9ydW50aW1lLmpzIiwiL2J1aWx0aW4vK3BybmcuanMiLCIvYnVpbHRpbi8renN0ZC5qcyIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9jb3JlL2hlYXBfYmxvY2svcnVudGltZS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0EsQzs7Rzs7O1E7Uzs7O0c7STtJO0k7RztFOzs7O0dBV0MsQ0FBQztNQUVFO09BQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXFCQUMsc0JBQXNCQyxTQUFTRjtPQUMvQkcsb0JBQW9CQztPQUNw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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy8gc3RyZnRpbWVcbi8vIGdpdGh1Yi5jb20vc2Ftc29uanMvc3RyZnRpbWVcbi8vIEBfc2pzXG4vL1xuLy8gQ29weXJpZ2h0IDIwMTAgLSAyMDE1IFNhbWkgU2FtaHVyaSA8c2FtaUBzYW1odXJpLm5ldD5cbi8vXG4vLyBNSVQgTGljZW5zZVxuLy8gaHR0cDovL3Nqcy5taXQtbGljZW5zZS5vcmdcbi8vXG5cbjsoZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgRGVmYXVsdExvY2FsZSA9IHtcbiAgICAgICAgICAgIGRheXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcbiAgICAgICAgICAgIHNob3J0RGF5czogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgICAgICAgICAgIG1vbnRoczogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG4gICAgICAgICAgICBzaG9ydE1vbnRoczogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICAgICAgICAgICAgQU06ICdBTScsXG4gICAgICAgICAgICBQTTogJ1BNJyxcbiAgICAgICAgICAgIGFtOiAnYW0nLFxuICAgICAgICAgICAgcG06ICdwbScsXG4gICAgICAgICAgICBmb3JtYXRzOiB7XG4gICAgICAgICAgICAgICAgRDogJyVtLyVkLyV5JyxcbiAgICAgICAgICAgICAgICBGOiAnJVktJW0tJWQnLFxuICAgICAgICAgICAgICAgIFI6ICclSDolTScsXG4gICAgICAgICAgICAgICAgVDogJyVIOiVNOiVTJyxcbiAgICAgICAgICAgICAgICBYOiAnJVQnLFxuICAgICAgICAgICAgICAgIGM6ICclYSAlYiAlZCAlWCAlWScsXG4gICAgICAgICAgICAgICAgcjogJyVJOiVNOiVTICVwJyxcbiAgICAgICAgICAgICAgICB2OiAnJWUtJWItJVknLFxuICAgICAgICAgICAgICAgIHg6ICclRCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFN0cmZ0aW1lID0gbmV3IFN0cmZ0aW1lKERlZmF1bHRMb2NhbGUsIDAsIGZhbHNlKSxcbiAgICAgICAgaXNDb21tb25KUyA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnLFxuICAgICAgICBuYW1lc3BhY2U7XG5cbiAgICAvLyBDb21tb25KUyAvIE5vZGUgbW9kdWxlXG4gICAgaWYgKGlzQ29tbW9uSlMpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gbW9kdWxlLmV4cG9ydHMgPSBhZGFwdGVkU3RyZnRpbWU7XG4gICAgICAgIG5hbWVzcGFjZS5zdHJmdGltZSA9IGRlcHJlY2F0ZWRTdHJmdGltZTtcbiAgICAgICAgaWYoam9vX2dsb2JhbF9vYmplY3QpIGpvb19nbG9iYWxfb2JqZWN0LnN0cmZ0aW1lID0gYWRhcHRlZFN0cmZ0aW1lO1xuICAgIH1cbiAgICAvLyBCcm93c2VycyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEdldCB0aGUgZ2xvYmFsIG9iamVjdC4gV29ya3MgaW4gRVMzLCBFUzUsIGFuZCBFUzUgc3RyaWN0IG1vZGUuXG4gICAgICAgIG5hbWVzcGFjZSA9IGpvb19nbG9iYWxfb2JqZWN0IHx8IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfHwgKDEsZXZhbCkoJ3RoaXMnKTsgfSgpKTtcbiAgICAgICAgbmFtZXNwYWNlLnN0cmZ0aW1lID0gYWRhcHRlZFN0cmZ0aW1lO1xuICAgIH1cblxuICAgIC8vIERlcHJlY2F0ZWQgQVBJLCB0byBiZSByZW1vdmVkIGluIHYxLjBcbiAgICB2YXIgX3JlcXVpcmUgPSBpc0NvbW1vbkpTID8gXCJyZXF1aXJlKCdzdHJmdGltZScpXCIgOiBcInN0cmZ0aW1lXCI7XG4gICAgdmFyIF9kZXByZWNhdGlvbldhcm5pbmdzID0ge307XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRpb25XYXJuaW5nKG5hbWUsIGluc3RlYWQpIHtcbiAgICAgICAgaWYgKCFfZGVwcmVjYXRpb25XYXJuaW5nc1tuYW1lXSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS53YXJuID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR10gXCIgKyBuYW1lICsgXCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMS4wLiBJbnN0ZWFkLCB1c2UgYFwiICsgaW5zdGVhZCArIFwiYC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZGVwcmVjYXRpb25XYXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lc3BhY2Uuc3RyZnRpbWVUWiA9IGRlcHJlY2F0ZWRTdHJmdGltZVRaO1xuICAgIG5hbWVzcGFjZS5zdHJmdGltZVVUQyA9IGRlcHJlY2F0ZWRTdHJmdGltZVVUQztcbiAgICBuYW1lc3BhY2UubG9jYWxpemVkU3RyZnRpbWUgPSBkZXByZWNhdGVkU3RyZnRpbWVMb2NhbGl6ZWQ7XG5cbiAgICAvLyBBZGFwdCB0aGUgb2xkIEFQSSB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBuZXcgQVBJLlxuICAgIGZ1bmN0aW9uIGFkYXB0Rm9yd2FyZHMoZm4pIHtcbiAgICAgICAgZm4ubG9jYWxpemUgPSBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUuYmluZChkZWZhdWx0U3RyZnRpbWUpO1xuICAgICAgICBmbi50aW1lem9uZSA9IGRlZmF1bHRTdHJmdGltZS50aW1lem9uZS5iaW5kKGRlZmF1bHRTdHJmdGltZSk7XG4gICAgICAgIGZuLnV0YyA9IGRlZmF1bHRTdHJmdGltZS51dGMuYmluZChkZWZhdWx0U3RyZnRpbWUpO1xuICAgIH1cblxuICAgIGFkYXB0Rm9yd2FyZHMoYWRhcHRlZFN0cmZ0aW1lKTtcbiAgICBmdW5jdGlvbiBhZGFwdGVkU3RyZnRpbWUoZm10LCBkLCBsb2NhbGUpIHtcbiAgICAgICAgLy8gZCBhbmQgbG9jYWxlIGFyZSBvcHRpb25hbCwgY2hlY2sgaWYgdGhpcyBpcyAoZm9ybWF0LCBsb2NhbGUpXG4gICAgICAgIGlmIChkICYmIGQuZGF5cykge1xuICAgICAgICAgICAgbG9jYWxlID0gZDtcbiAgICAgICAgICAgIGQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIihmb3JtYXQsIFtkYXRlXSwgW2xvY2FsZV0pYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJmdGltZSA9IGxvY2FsZSA/IGRlZmF1bHRTdHJmdGltZS5sb2NhbGl6ZShsb2NhbGUpIDogZGVmYXVsdFN0cmZ0aW1lO1xuICAgICAgICByZXR1cm4gc3RyZnRpbWUoZm10LCBkKTtcbiAgICB9XG5cbiAgICBhZGFwdEZvcndhcmRzKGRlcHJlY2F0ZWRTdHJmdGltZSk7XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lKGZtdCwgZCwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWUoZm9ybWF0LCBbZGF0ZV0sIFtsb2NhbGVdKWBcIiwgXCJ2YXIgcyA9IFwiICsgX3JlcXVpcmUgKyBcIi5sb2NhbGl6ZShsb2NhbGUpOyBzKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWUoZm9ybWF0LCBbZGF0ZV0pYFwiLCBfcmVxdWlyZSArIFwiKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZnRpbWUgPSBsb2NhbGUgPyBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUobG9jYWxlKSA6IGRlZmF1bHRTdHJmdGltZTtcbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lKGZtdCwgZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lVFooZm10LCBkLCBsb2NhbGUsIHRpbWV6b25lKSB7XG4gICAgICAgIC8vIGxvY2FsZSBpcyBvcHRpb25hbCwgY2hlY2sgaWYgdGhpcyBpcyAoZm9ybWF0LCBkYXRlLCB0aW1lem9uZSlcbiAgICAgICAgaWYgKCh0eXBlb2YgbG9jYWxlID09ICdudW1iZXInIHx8IHR5cGVvZiBsb2NhbGUgPT0gJ3N0cmluZycpICYmIHRpbWV6b25lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRpbWV6b25lID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVRaKGZvcm1hdCwgZGF0ZSwgbG9jYWxlLCB0eilgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKS50aW1lem9uZSh0eik7IHMoZm9ybWF0LCBbZGF0ZV0pYCBvciBgdmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKTsgcy50aW1lem9uZSh0eikoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVRaKGZvcm1hdCwgZGF0ZSwgdHopYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLnRpbWV6b25lKHR6KTsgcyhmb3JtYXQsIFtkYXRlXSlgIG9yIGBcIiArIF9yZXF1aXJlICsgXCIudGltZXpvbmUodHopKGZvcm1hdCwgW2RhdGVdKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJmdGltZSA9IChsb2NhbGUgPyBkZWZhdWx0U3RyZnRpbWUubG9jYWxpemUobG9jYWxlKSA6IGRlZmF1bHRTdHJmdGltZSkudGltZXpvbmUodGltZXpvbmUpO1xuICAgICAgICByZXR1cm4gc3RyZnRpbWUoZm10LCBkKTtcbiAgICB9XG5cbiAgICB2YXIgdXRjU3RyZnRpbWUgPSBkZWZhdWx0U3RyZnRpbWUudXRjKCk7XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lVVRDKGZtdCwgZCwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uV2FybmluZyhcImBcIiArIF9yZXF1aXJlICsgXCIuc3RyZnRpbWVVVEMoZm9ybWF0LCBkYXRlLCBsb2NhbGUpYFwiLCBcInZhciBzID0gXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplKGxvY2FsZSkudXRjKCk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYFwiICsgX3JlcXVpcmUgKyBcIi5zdHJmdGltZVVUQyhmb3JtYXQsIFtkYXRlXSlgXCIsIFwidmFyIHMgPSBcIiArIF9yZXF1aXJlICsgXCIudXRjKCk7IHMoZm9ybWF0LCBbZGF0ZV0pXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJmdGltZSA9IGxvY2FsZSA/IHV0Y1N0cmZ0aW1lLmxvY2FsaXplKGxvY2FsZSkgOiB1dGNTdHJmdGltZTtcbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lKGZtdCwgZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZFN0cmZ0aW1lTG9jYWxpemVkKGxvY2FsZSkge1xuICAgICAgICBkZXByZWNhdGlvbldhcm5pbmcoXCJgXCIgKyBfcmVxdWlyZSArIFwiLmxvY2FsaXplZFN0cmZ0aW1lKGxvY2FsZSlgXCIsIF9yZXF1aXJlICsgXCIubG9jYWxpemUobG9jYWxlKVwiKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHJmdGltZS5sb2NhbGl6ZShsb2NhbGUpO1xuICAgIH1cbiAgICAvLyBFbmQgb2YgZGVwcmVjYXRlZCBBUElcblxuICAgIC8vIFBvbHlmaWxsIERhdGUubm93IGZvciBvbGQgYnJvd3NlcnMuXG4gICAgaWYgKHR5cGVvZiBEYXRlLm5vdyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiArbmV3IERhdGUoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTdHJmdGltZShsb2NhbGUsIGN1c3RvbVRpbWV6b25lT2Zmc2V0LCB1c2VVdGNUaW1lem9uZSkge1xuICAgICAgICB2YXIgX2xvY2FsZSA9IGxvY2FsZSB8fCBEZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgX2N1c3RvbVRpbWV6b25lT2Zmc2V0ID0gY3VzdG9tVGltZXpvbmVPZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIF91c2VVdGNCYXNlZERhdGUgPSB1c2VVdGNUaW1lem9uZSB8fCBmYWxzZSxcblxuICAgICAgICAgICAgLy8gd2Ugc3RvcmUgdW5peCB0aW1lc3RhbXAgdmFsdWUgaGVyZSB0byBub3QgY3JlYXRlIG5ldyBEYXRlKCkgZWFjaCBpdGVyYXRpb24gKGVhY2ggbWlsbGlzZWNvbmQpXG4gICAgICAgICAgICAvLyBEYXRlLm5vdygpIGlzIDIgdGltZXMgZmFzdGVyIHRoYW4gbmV3IERhdGUoKVxuICAgICAgICAgICAgLy8gd2hpbGUgbWlsbGlzZWNvbmQgcHJlY2lzZSBpcyBlbm91Z2ggaGVyZVxuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSB2ZXJ5IGhlbHBmdWwgd2hlbiBzdHJmdGltZSB0cmlnZ2VyZWQgYSBsb3Qgb2YgdGltZXMgb25lIGJ5IG9uZVxuICAgICAgICAgICAgX2NhY2hlZERhdGVUaW1lc3RhbXAgPSAwLFxuICAgICAgICAgICAgX2NhY2hlZERhdGU7XG5cbiAgICAgICAgZnVuY3Rpb24gX3N0cmZ0aW1lKGZvcm1hdCwgZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcDtcblxuICAgICAgICAgICAgaWYgKCFkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGltZXN0YW1wID4gX2NhY2hlZERhdGVUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhY2hlZERhdGVUaW1lc3RhbXAgPSBjdXJyZW50VGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgICBfY2FjaGVkRGF0ZSA9IG5ldyBEYXRlKF9jYWNoZWREYXRlVGltZXN0YW1wKTtcblxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBfY2FjaGVkRGF0ZVRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX3VzZVV0Y0Jhc2VkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaG93IHRvIGF2b2lkIGR1cGxpY2F0aW9uIG9mIGRhdGUgaW5zdGFudGlhdGlvbiBmb3IgdXRjIGhlcmU/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB0aWVkIHRvIGdldFRpbWV6b25lT2Zmc2V0IG9mIHRoZSBjdXJyZW50IGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jYWNoZWREYXRlID0gbmV3IERhdGUoX2NhY2hlZERhdGVUaW1lc3RhbXAgKyBnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvcihfY2FjaGVkRGF0ZSkgKyBfY3VzdG9tVGltZXpvbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGUgPSBfY2FjaGVkRGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF91c2VVdGNCYXNlZERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpICsgZ2V0VGltZXN0YW1wVG9VdGNPZmZzZXRGb3IoZGF0ZSkgKyBfY3VzdG9tVGltZXpvbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9wcm9jZXNzRm9ybWF0KGZvcm1hdCwgZGF0ZSwgX2xvY2FsZSwgdGltZXN0YW1wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9wcm9jZXNzRm9ybWF0KGZvcm1hdCwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRTdHJpbmcgPSAnJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpc0luU2NvcGUgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBmb3JtYXQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGV4dGVuZGVkVFogPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFyQ29kZSA9IGZvcm1hdC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5TY29wZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAnLSdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICdfJ1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gJzAnXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAnOidcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudENoYXJDb2RlID09PSA1OCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZFRaKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR10gZGV0ZWN0ZWQgdXNlIG9mIHVuc3VwcG9ydGVkICU6OiBvciAlOjo6IG1vZGlmaWVycyB0byBzdHJmdGltZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRUWiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDaGFyQ29kZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGFtcGxlcyBmb3IgbmV3IERhdGUoMCkgaW4gR01UXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdUaHVyc2RheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2NTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gbG9jYWxlLmRheXNbZGF0ZS5nZXREYXkoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdKYW51YXJ5J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnQic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUubW9udGhzW2RhdGUuZ2V0TW9udGgoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2NzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoTWF0aC5mbG9vcihkYXRlLmdldEZ1bGxZZWFyKCkgLyAxMDApLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAxLzAxLzcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5ELCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOTcwLTAxLTAxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnRic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDcwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5GLCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3MjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIoZGF0ZS5nZXRIb3VycygpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnSSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDczOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihob3VyczEyKGRhdGUuZ2V0SG91cnMoKSksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMyhNYXRoLmZsb29yKHRpbWVzdGFtcCAlIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldE1pbnV0ZXMoKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdhbSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4MDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZGF0ZS5nZXRIb3VycygpIDwgMTIgPyBsb2NhbGUuYW0gOiBsb2NhbGUucG07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMDowMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4MjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuUiwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0U2Vjb25kcygpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzAwOjAwOjAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5ULCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ1UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4NTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gcGFkVGlsbDIod2Vla051bWJlcihkYXRlLCAnc3VuZGF5JyksIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdXJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKHdlZWtOdW1iZXIoZGF0ZSwgJ21vbmRheScpLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzE2OjAwOjAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnWCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy5YLCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcxOTcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnWSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdHTVQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF91c2VVdGNCYXNlZERhdGUgJiYgX2N1c3RvbVRpbWV6b25lT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBcIkdNVFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4bWUgb3B0aW1pemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR6U3RyaW5nID0gZGF0ZS50b1N0cmluZygpLm1hdGNoKC9cXCgoW1xcd1xcc10rKVxcKS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gdHpTdHJpbmcgJiYgdHpTdHJpbmdbMV0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnVGh1J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUuc2hvcnREYXlzW2RhdGUuZ2V0RGF5KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnSmFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBsb2NhbGUuc2hvcnRNb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuYywgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldERhdGUoKSwgcGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICcgMSdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IHBhZFRpbGwyKGRhdGUuZ2V0RGF0ZSgpLCBwYWRkaW5nID09IG51bGwgPyAnICcgOiBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ0phbidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IGxvY2FsZS5zaG9ydE1vbnRoc1tkYXRlLmdldE1vbnRoKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnaic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRheSA9IE1hdGguY2VpbCgoZGF0ZS5nZXRUaW1lKCkgLSB5LmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMyhkYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnIDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldEhvdXJzKCksIHBhZGRpbmcgPT0gbnVsbCA/ICcgJyA6IHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMTInXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihob3VyczEyKGRhdGUuZ2V0SG91cnMoKSksIHBhZGRpbmcgPT0gbnVsbCA/ICcgJyA6IHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBwYWRUaWxsMihkYXRlLmdldE1vbnRoKCkgKyAxLCBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ1xcbidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMXN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAnbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nKGRhdGUuZ2V0RGF0ZSgpKSArIG9yZGluYWwoZGF0ZS5nZXREYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnQU0nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXRlLmdldEhvdXJzKCkgPCAxMiA/IGxvY2FsZS5BTSA6IGxvY2FsZS5QTTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyOjAwOjAwIEFNJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMuciwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IE1hdGguZmxvb3IodGltZXN0YW1wIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdcXHQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzQnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBkYXkgPT09IDAgPyA3IDogZGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxIC0gNywgTW9uZGF5IGlzIGZpcnN0IGRheSBvZiB0aGUgd2Vla1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnIDEtSmFuLTE5NzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBfcHJvY2Vzc0Zvcm1hdChsb2NhbGUuZm9ybWF0cy52LCBkYXRlLCBsb2NhbGUsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICc0J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gMCAtIDYsIFN1bmRheSBpcyBmaXJzdCBkYXkgb2YgdGhlIHdlZWtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJzEyLzMxLzY5J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gX3Byb2Nlc3NGb3JtYXQobG9jYWxlLmZvcm1hdHMueCwgZGF0ZSwgbG9jYWxlLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnNzAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTIxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSAoJycgKyBkYXRlLmdldEZ1bGxZZWFyKCkpLnNsaWNlKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnKzAwMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdXNlVXRjQmFzZWREYXRlICYmIF9jdXN0b21UaW1lem9uZU9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZXh0ZW5kZWRUWiA/IFwiKzAwOjAwXCIgOiBcIiswMDAwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2N1c3RvbVRpbWV6b25lT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmYgPSBfY3VzdG9tVGltZXpvbmVPZmZzZXQgLyAoNjAgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZiA9IC1kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBvZmYgPCAwID8gJy0nIDogJysnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VwID0gZXh0ZW5kZWRUWiA/ICc6JyA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKE1hdGguYWJzKG9mZiAvIDYwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5zID0gTWF0aC5hYnMob2ZmICUgNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gc2lnbiArIHBhZFRpbGwyKGhvdXJzKSArIHNlcCArIHBhZFRpbGwyKG1pbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlzSW5TY29wZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAnJSdcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSAzNykge1xuICAgICAgICAgICAgICAgICAgICBpc0luU2NvcGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0U3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cmZ0aW1lID0gX3N0cmZ0aW1lO1xuXG4gICAgICAgIHN0cmZ0aW1lLmxvY2FsaXplID0gZnVuY3Rpb24obG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmZ0aW1lKGxvY2FsZSB8fCBfbG9jYWxlLCBfY3VzdG9tVGltZXpvbmVPZmZzZXQsIF91c2VVdGNCYXNlZERhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0cmZ0aW1lLnRpbWV6b25lID0gZnVuY3Rpb24odGltZXpvbmUpIHtcbiAgICAgICAgICAgIHZhciBjdXN0b21UaW1lem9uZU9mZnNldCA9IF9jdXN0b21UaW1lem9uZU9mZnNldDtcbiAgICAgICAgICAgIHZhciB1c2VVdGNCYXNlZERhdGUgPSBfdXNlVXRjQmFzZWREYXRlO1xuXG4gICAgICAgICAgICB2YXIgdGltZXpvbmVUeXBlID0gdHlwZW9mIHRpbWV6b25lO1xuICAgICAgICAgICAgaWYgKHRpbWV6b25lVHlwZSA9PT0gJ251bWJlcicgfHwgdGltZXpvbmVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHVzZVV0Y0Jhc2VkRGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBJU08gODYwMSBmb3JtYXQgdGltZXpvbmUgc3RyaW5nLCBbLStdSEhNTVxuICAgICAgICAgICAgICAgIGlmICh0aW1lem9uZVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gdGltZXpvbmVbMF0gPT09ICctJyA/IC0xIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdXJzID0gcGFyc2VJbnQodGltZXpvbmUuc2xpY2UoMSwgMyksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBwYXJzZUludCh0aW1lem9uZS5zbGljZSgzLCA1KSwgMTApO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVRpbWV6b25lT2Zmc2V0ID0gc2lnbiAqICgoNjAgKiBob3VycykgKyBtaW51dGVzKSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gbWludXRlczogNDIwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWV6b25lVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tVGltZXpvbmVPZmZzZXQgPSB0aW1lem9uZSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyZnRpbWUoX2xvY2FsZSwgY3VzdG9tVGltZXpvbmVPZmZzZXQsIHVzZVV0Y0Jhc2VkRGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3RyZnRpbWUudXRjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmZ0aW1lKF9sb2NhbGUsIF9jdXN0b21UaW1lem9uZU9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0cmZ0aW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhZFRpbGwyKG51bWJlclRvUGFkLCBwYWRkaW5nQ2hhcikge1xuICAgICAgICBpZiAocGFkZGluZ0NoYXIgPT09ICcnIHx8IG51bWJlclRvUGFkID4gOSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclRvUGFkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkaW5nQ2hhciA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYWRkaW5nQ2hhciA9ICcwJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZ0NoYXIgKyBudW1iZXJUb1BhZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWRUaWxsMyhudW1iZXJUb1BhZCkge1xuICAgICAgICBpZiAobnVtYmVyVG9QYWQgPiA5OSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclRvUGFkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1iZXJUb1BhZCA+IDkpIHtcbiAgICAgICAgICAgIHJldHVybiAnMCcgKyBudW1iZXJUb1BhZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzAwJyArIG51bWJlclRvUGFkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhvdXJzMTIoaG91cikge1xuICAgICAgICBpZiAoaG91ciA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDEyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhvdXIgPiAxMikge1xuICAgICAgICAgICAgcmV0dXJuIGhvdXIgLSAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG5cbiAgICAvLyBmaXJzdFdlZWtkYXk6ICdzdW5kYXknIG9yICdtb25kYXknLCBkZWZhdWx0IGlzICdzdW5kYXknXG4gICAgLy9cbiAgICAvLyBQaWxmZXJlZCAmIHBvcnRlZCBmcm9tIFJ1YnkncyBzdHJmdGltZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBmdW5jdGlvbiB3ZWVrTnVtYmVyKGRhdGUsIGZpcnN0V2Vla2RheSkge1xuICAgICAgICBmaXJzdFdlZWtkYXkgPSBmaXJzdFdlZWtkYXkgfHwgJ3N1bmRheSc7XG5cbiAgICAgICAgLy8gVGhpcyB3b3JrcyBieSBzaGlmdGluZyB0aGUgd2Vla2RheSBiYWNrIGJ5IG9uZSBkYXkgaWYgd2VcbiAgICAgICAgLy8gYXJlIHRyZWF0aW5nIE1vbmRheSBhcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICB2YXIgd2Vla2RheSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChmaXJzdFdlZWtkYXkgPT09ICdtb25kYXknKSB7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA9PT0gMCkgLy8gU3VuZGF5XG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IDY7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgd2Vla2RheS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0RGF5T2ZZZWFyVXRjID0gRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKSxcbiAgICAgICAgICAgIGRhdGVVdGMgPSBEYXRlLlVUQyhkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpLFxuICAgICAgICAgICAgeWRheSA9IE1hdGguZmxvb3IoKGRhdGVVdGMgLSBmaXJzdERheU9mWWVhclV0YykgLyA4NjQwMDAwMCksXG4gICAgICAgICAgICB3ZWVrTnVtID0gKHlkYXkgKyA3IC0gd2Vla2RheSkgLyA3O1xuXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHdlZWtOdW0pO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgb3JkaW5hbCBzdWZmaXggZm9yIGEgbnVtYmVyOiBzdCwgbmQsIHJkLCBvciB0aFxuICAgIGZ1bmN0aW9uIG9yZGluYWwobnVtYmVyKSB7XG4gICAgICAgIHZhciBpID0gbnVtYmVyICUgMTA7XG4gICAgICAgIHZhciBpaSA9IG51bWJlciAlIDEwMDtcblxuICAgICAgICBpZiAoKGlpID49IDExICYmIGlpIDw9IDEzKSB8fCBpID09PSAwIHx8IGkgPj0gNCkge1xuICAgICAgICAgICAgcmV0dXJuICd0aCc7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiAnc3QnO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gJ25kJztcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuICdyZCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUaW1lc3RhbXBUb1V0Y09mZnNldEZvcihkYXRlKSB7XG4gICAgICAgIHJldHVybiAoZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIHx8IDApICogNjAwMDA7XG4gICAgfVxuXG59KCkpO1xuIiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IFN0cmluZyhpKTtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgcmVzdWx0O1xuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIF9nZXQoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIF9nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07XG4gIGlmICghaXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgIGRpZEVyciA9IGZhbHNlLFxuICAgIGVycjtcbiAgcmV0dXJuIHtcbiAgICBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpdCA9IGl0LmNhbGwobyk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gZTtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgdCA9IHt9O1xuZnVuY3Rpb24gTWFrZUludHJpbnNpY0NsYXNzKGUsIHQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogdCxcbiAgICB3cml0YWJsZTogITEsXG4gICAgZW51bWVyYWJsZTogITEsXG4gICAgY29uZmlndXJhYmxlOiAhMFxuICB9KTtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpKSxcbiAgICBfc3RlcDtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIF90ID0gX3N0ZXAudmFsdWU7XG4gICAgICB2YXIgX3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIF90KTtcbiAgICAgIF9yLmNvbmZpZ3VyYWJsZSAmJiBfci5lbnVtZXJhYmxlICYmIChfci5lbnVtZXJhYmxlID0gITEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdCwgX3IpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUucHJvdG90eXBlKSksXG4gICAgX3N0ZXAyO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3QyID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgdmFyIF9yMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZS5wcm90b3R5cGUsIF90Mik7XG4gICAgICBfcjIuY29uZmlndXJhYmxlICYmIF9yMi5lbnVtZXJhYmxlICYmIChfcjIuZW51bWVyYWJsZSA9ICExLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsIF90MiwgX3IyKSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IyLmYoKTtcbiAgfVxuICBEZWZpbmVJbnRyaW5zaWModCwgZSksIERlZmluZUludHJpbnNpYyhcIlwiLmNvbmNhdCh0LCBcIi5wcm90b3R5cGVcIiksIGUucHJvdG90eXBlKTtcbn1cbmZ1bmN0aW9uIERlZmluZUludHJpbnNpYyhlLCByKSB7XG4gIHZhciBvID0gXCIlXCIuY29uY2F0KGUsIFwiJVwiKTtcbiAgaWYgKHZvaWQgMCAhPT0gdFtvXSkgdGhyb3cgbmV3IEVycm9yKFwiaW50cmluc2ljIFwiLmNvbmNhdChlLCBcIiBhbHJlYWR5IGV4aXN0c1wiKSk7XG4gIHRbb10gPSByO1xufVxuZnVuY3Rpb24gR2V0SW50cmluc2ljKGUpIHtcbiAgcmV0dXJuIHRbZV07XG59XG52YXIgciwgbztcbnZhciBuID0gXCJzbG90LWVwb2NoTmFub1NlY29uZHNcIixcbiAgYSA9IFwic2xvdC10aW1lem9uZS1pZGVudGlmaWVyXCIsXG4gIGkgPSBcInNsb3QteWVhclwiLFxuICBzID0gXCJzbG90LW1vbnRoXCIsXG4gIGwgPSBcInNsb3QtZGF5XCIsXG4gIGQgPSBcInNsb3QtaG91clwiLFxuICBtID0gXCJzbG90LW1pbnV0ZVwiLFxuICBjID0gXCJzbG90LXNlY29uZFwiLFxuICBoID0gXCJzbG90LW1pbGxpc2Vjb25kXCIsXG4gIHUgPSBcInNsb3QtbWljcm9zZWNvbmRcIixcbiAgVCA9IFwic2xvdC1uYW5vc2Vjb25kXCIsXG4gIHAgPSBcInNsb3QtY2FsZW5kYXJcIixcbiAgZiA9IFwic2xvdC1kYXRlLWJyYW5kXCIsXG4gIHkgPSBcInNsb3QteWVhci1tb250aC1icmFuZFwiLFxuICBJID0gXCJzbG90LW1vbnRoLWRheS1icmFuZFwiLFxuICBTID0gXCJzbG90LWNhY2hlZC1pbnN0YW50XCIsXG4gIGcgPSBcInNsb3QtdGltZS16b25lXCIsXG4gIHcgPSBcInNsb3QteWVhcnNcIixcbiAgRCA9IFwic2xvdC1tb250aHNcIixcbiAgRyA9IFwic2xvdC13ZWVrc1wiLFxuICB2ID0gXCJzbG90LWRheXNcIixcbiAgQyA9IFwic2xvdC1ob3Vyc1wiLFxuICBPID0gXCJzbG90LW1pbnV0ZXNcIixcbiAgYiA9IFwic2xvdC1zZWNvbmRzXCIsXG4gIEUgPSBcInNsb3QtbWlsbGlzZWNvbmRzXCIsXG4gIE0gPSBcInNsb3QtbWljcm9zZWNvbmRzXCIsXG4gIFIgPSBcInNsb3QtbmFub3NlY29uZHNcIixcbiAgRiA9IFwic2xvdC1jYWxlbmRhci1pZGVudGlmaWVyXCIsXG4gIFkgPSBuZXcgV2Vha01hcCgpO1xudmFyIFAgPSBTeW1ib2xbXCJmb3JcIl0oXCJAQFRlbXBvcmFsX19HZXRTbG90c1wiKTtcbihyID0gZ2xvYmFsVGhpcylbUF0gfHwgKHJbUF0gPSBmdW5jdGlvbiBfR2V0U2xvdHMoZSkge1xuICByZXR1cm4gWS5nZXQoZSk7XG59KTtcbnZhciBaID0gZ2xvYmFsVGhpc1tQXTtcbnZhciBCID0gU3ltYm9sW1wiZm9yXCJdKFwiQEBUZW1wb3JhbF9fQ3JlYXRlU2xvdHNcIik7XG4obyA9IGdsb2JhbFRoaXMpW0JdIHx8IChvW0JdID0gZnVuY3Rpb24gX0NyZWF0ZVNsb3RzKGUpIHtcbiAgWS5zZXQoZSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG59KTtcbnZhciBOID0gZ2xvYmFsVGhpc1tCXTtcbmZ1bmN0aW9uIEhhc1Nsb3QoZSkge1xuICBpZiAoIWUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpKSByZXR1cm4gITE7XG4gIHZhciByID0gWihlKTtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHRbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiAhIXIgJiYgdC5ldmVyeShmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlIGluIHI7XG4gIH0pO1xufVxuZnVuY3Rpb24gR2V0U2xvdChlLCB0KSB7XG4gIHZhciBfWjtcbiAgdmFyIHIgPSAoX1ogPSBaKGUpKSA9PT0gbnVsbCB8fCBfWiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX1pbdF07XG4gIGlmICh2b2lkIDAgPT09IHIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaXNzaW5nIGludGVybmFsIHNsb3QgXCIuY29uY2F0KHQpKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBTZXRTbG90KGUsIHQsIHIpIHtcbiAgdmFyIG8gPSBaKGUpO1xuICBpZiAodm9pZCAwID09PSBvKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBzbG90cyBmb3IgdGhlIGdpdmVuIGNvbnRhaW5lclwiKTtcbiAgaWYgKG9bdF0pIHRocm93IG5ldyBUeXBlRXJyb3IoXCJcIi5jb25jYXQodCwgXCIgYWxyZWFkeSBoYXMgc2V0XCIpKTtcbiAgb1t0XSA9IHI7XG59XG52YXIgaiA9IC9cXC5bLUEtWmEtel9dfFxcLlxcLlstQS1aYS16Ll9dezEsMTJ9fFxcLlstQS1aYS16X11bLUEtWmEtei5fXXswLDEyfXxbQS1aYS16X11bLUEtWmEtei5fXXswLDEzfS8sXG4gICQgPSBuZXcgUmVnRXhwKFwiKD86XCIgKyBbXCIoPzpcIi5jb25jYXQoai5zb3VyY2UsIFwiKSg/OlxcXFwvKD86XCIpLmNvbmNhdChqLnNvdXJjZSwgXCIpKSpcIiksIFwiRXRjL0dNVCg/OjB8Wy0rXVxcXFxkezEsMn0pXCIsIFwiR01UWy0rXT8wXCIsIFwiRVNUNUVEVFwiLCBcIkNTVDZDRFRcIiwgXCJNU1Q3TURUXCIsIFwiUFNUOFBEVFwiLCAvKD86WytcXHUyMjEyLV1bMC0yXVswLTldKD86Oj9bMC01XVswLTldKD86Oj9bMC01XVswLTldKD86Wy4sXVxcZHsxLDl9KT8pPyk/KS8uc291cmNlXS5qb2luKFwifFwiKSArIFwiKVwiKSxcbiAgayA9IC8oPzpbK1xcdTIyMTItXVxcZHs2fXxcXGR7NH0pLyxcbiAgVSA9IC8oPzowWzEtOV18MVswLTJdKS8sXG4gIEEgPSAvKD86MFsxLTldfFsxMl1cXGR8M1swMV0pLyxcbiAgTCA9IG5ldyBSZWdFeHAoXCIoXCIuY29uY2F0KGsuc291cmNlLCBcIikoPzotKFwiKS5jb25jYXQoVS5zb3VyY2UsIFwiKS0oXCIpLmNvbmNhdChBLnNvdXJjZSwgXCIpfChcIikuY29uY2F0KFUuc291cmNlLCBcIikoXCIpLmNvbmNhdChBLnNvdXJjZSwgXCIpKVwiKSksXG4gIHggPSAvKFxcZHsyfSkoPzo6KFxcZHsyfSkoPzo6KFxcZHsyfSkoPzpbLixdKFxcZHsxLDl9KSk/KT98KFxcZHsyfSkoPzooXFxkezJ9KSg/OlsuLF0oXFxkezEsOX0pKT8pPyk/LyxcbiAgVyA9IC8oWytcXHUyMjEyLV0pKFswMV1bMC05XXwyWzAtM10pKD86Oj8oWzAtNV1bMC05XSkoPzo6PyhbMC01XVswLTldKSg/OlsuLF0oXFxkezEsOX0pKT8pPyk/LyxcbiAgcSA9IG5ldyBSZWdFeHAoXCIoW3paXSl8XCIuY29uY2F0KFcuc291cmNlLCBcIj9cIikpLFxuICBIID0gL1xcWyghKT8oW2Etel9dW2EtejAtOV8tXSopPShbQS1aYS16MC05XSsoPzotW0EtWmEtejAtOV0rKSopXFxdL2csXG4gIFYgPSBuZXcgUmVnRXhwKFtcIl5cIi5jb25jYXQoTC5zb3VyY2UpLCBcIig/Oig/OlR8XFxcXHMrKVwiLmNvbmNhdCh4LnNvdXJjZSwgXCIoPzpcIikuY29uY2F0KHEuc291cmNlLCBcIik/KT9cIiksIFwiKD86XFxcXFshPyhcIi5jb25jYXQoJC5zb3VyY2UsIFwiKVxcXFxdKT9cIiksIFwiKCg/OlwiLmNvbmNhdChILnNvdXJjZSwgXCIpKikkXCIpXS5qb2luKFwiXCIpLCBcImlcIiksXG4gIHogPSBuZXcgUmVnRXhwKFtcIl5UP1wiLmNvbmNhdCh4LnNvdXJjZSksIFwiKD86XCIuY29uY2F0KHEuc291cmNlLCBcIik/XCIpLCBcIig/OlxcXFxbIT9cIi5jb25jYXQoJC5zb3VyY2UsIFwiXFxcXF0pP1wiKSwgXCIoKD86XCIuY29uY2F0KEguc291cmNlLCBcIikqKSRcIildLmpvaW4oXCJcIiksIFwiaVwiKSxcbiAgXyA9IG5ldyBSZWdFeHAoXCJeKFwiLmNvbmNhdChrLnNvdXJjZSwgXCIpLT8oXCIpLmNvbmNhdChVLnNvdXJjZSwgXCIpKD86XFxcXFshP1wiKS5jb25jYXQoJC5zb3VyY2UsIFwiXFxcXF0pPygoPzpcIikuY29uY2F0KEguc291cmNlLCBcIikqKSRcIikpLFxuICBKID0gbmV3IFJlZ0V4cChcIl4oPzotLSk/KFwiLmNvbmNhdChVLnNvdXJjZSwgXCIpLT8oXCIpLmNvbmNhdChBLnNvdXJjZSwgXCIpKD86XFxcXFshP1wiKS5jb25jYXQoJC5zb3VyY2UsIFwiXFxcXF0pPygoPzpcIikuY29uY2F0KEguc291cmNlLCBcIikqKSRcIikpLFxuICBLID0gLyhcXGQrKSg/OlsuLF0oXFxkezEsOX0pKT8vLFxuICBYID0gbmV3IFJlZ0V4cChcIig/OlwiLmNvbmNhdChLLnNvdXJjZSwgXCJIKT8oPzpcIikuY29uY2F0KEsuc291cmNlLCBcIk0pPyg/OlwiKS5jb25jYXQoSy5zb3VyY2UsIFwiUyk/XCIpKSxcbiAgUSA9IG5ldyBSZWdFeHAoXCJeKFsrXFx1MjIxMi1dKT9QXCIuY29uY2F0KC8oPzooXFxkKylZKT8oPzooXFxkKylNKT8oPzooXFxkKylXKT8oPzooXFxkKylEKT8vLnNvdXJjZSwgXCIoPzpUKD8hJClcIikuY29uY2F0KFguc291cmNlLCBcIik/JFwiKSwgXCJpXCIpLFxuICBlZSA9IEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcyxcbiAgdGUgPSBBcnJheS5wcm90b3R5cGUucHVzaCxcbiAgcmUgPSBnbG9iYWxUaGlzLkludGwuRGF0ZVRpbWVGb3JtYXQsXG4gIG9lID0gTWF0aC5taW4sXG4gIG5lID0gTWF0aC5tYXgsXG4gIGFlID0gTWF0aC5hYnMsXG4gIGllID0gTWF0aC5mbG9vcixcbiAgc2UgPSBNYXRoLnNpZ24sXG4gIGxlID0gTWF0aC50cnVuYyxcbiAgZGUgPSBOdW1iZXIuaXNOYU4sXG4gIG1lID0gTnVtYmVyLmlzRmluaXRlLFxuICBjZSA9IE51bWJlcixcbiAgaGUgPSBTdHJpbmcsXG4gIHVlID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gIFRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgcGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBmZSA9IFJlZmxlY3QuYXBwbHksXG4gIHllID0gUmVmbGVjdC5vd25LZXlzLFxuICBJZSA9IDBuLFxuICBTZSA9IDFuLFxuICBnZSA9IDYwbixcbiAgd2UgPSAyNG4sXG4gIERlID0gMTAwMG4sXG4gIEdlID0gMTAwMDAwMG4sXG4gIHZlID0gMTAwMDAwMDAwMG4sXG4gIENlID0gQmlnSW50KC0xKSxcbiAgT2UgPSAzNjAwbiAqIHZlLFxuICBiZSA9IGdlICogdmUsXG4gIEVlID0gT2UgKiB3ZSxcbiAgTWUgPSBCaWdJbnQoLTg2NDAwKSAqIDEwMDAwMDAwMDAwMDAwMDAwMG4sXG4gIFJlID0gODY0MDBuICogMTAwMDAwMDAwMDAwMDAwMDAwbixcbiAgRmUgPSAtMjcxODIxLFxuICBZZSA9IDI3NTc2MCxcbiAgUGUgPSBCaWdJbnQoLTM4ODE1MikgKiAxMDAwMDAwMDAwMDAwMG4sXG4gIFplID0gRWUgKiAzNjYwbixcbiAgQmUgPSBFZSAqIDM2Nm4sXG4gIE5lID0gRWUgKiAxNG4sXG4gIGplID0gW1wiaXNvODYwMVwiLCBcImhlYnJld1wiLCBcImlzbGFtaWNcIiwgXCJpc2xhbWljLXVtYWxxdXJhXCIsIFwiaXNsYW1pYy10YmxhXCIsIFwiaXNsYW1pYy1jaXZpbFwiLCBcImlzbGFtaWMtcmdzYVwiLCBcImlzbGFtaWNjXCIsIFwicGVyc2lhblwiLCBcImV0aGlvcGljXCIsIFwiZXRoaW9hYVwiLCBcImNvcHRpY1wiLCBcImNoaW5lc2VcIiwgXCJkYW5naVwiLCBcInJvY1wiLCBcImluZGlhblwiLCBcImJ1ZGRoaXN0XCIsIFwiamFwYW5lc2VcIiwgXCJncmVnb3J5XCJdO1xuZnVuY3Rpb24gaXNaZXJvKHQpIHtcbiAgcmV0dXJuIHQgPT09IEllO1xufVxuZnVuY3Rpb24gR2V0TWV0aG9kKGUsIHQpIHtcbiAgdmFyIHIgPSBlW3RdO1xuICBpZiAodm9pZCAwICE9PSByKSByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGwoZSwgdCwgcikge1xuICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gciA6IFtdO1xuICByZXR1cm4gZmUoZSwgdCwgbyk7XG59XG5mdW5jdGlvbiBJc09iamVjdChlKSB7XG4gIHJldHVybiBcIm9iamVjdFwiID09IF90eXBlb2YoZSkgJiYgbnVsbCAhPT0gZSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGU7XG59XG5mdW5jdGlvbiBUb051bWJlcihlKSB7XG4gIGlmIChcImJpZ2ludFwiID09IHR5cGVvZiBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgQmlnSW50IHRvIG51bWJlclwiKTtcbiAgcmV0dXJuIGNlKGUpO1xufVxuZnVuY3Rpb24gVG9JbnRlZ2VyT3JJbmZpbml0eShlKSB7XG4gIHZhciB0ID0gVG9OdW1iZXIoZSk7XG4gIGlmIChkZSh0KSB8fCAwID09PSB0KSByZXR1cm4gMDtcbiAgaWYgKCFtZSh0KSkgcmV0dXJuIHQ7XG4gIHZhciByID0gaWUoYWUodCkpO1xuICByZXR1cm4gMCA9PT0gciA/IDAgOiBzZSh0KSAqIHI7XG59XG5mdW5jdGlvbiBJc0ludGVncmFsTnVtYmVyKGUpIHtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIGUgfHwgZGUoZSkgfHwgIW1lKGUpKSByZXR1cm4gITE7XG4gIHZhciB0ID0gYWUoZSk7XG4gIHJldHVybiBpZSh0KSA9PT0gdDtcbn1cbmZ1bmN0aW9uIFRvU3RyaW5nKGUpIHtcbiAgaWYgKFwic3ltYm9sXCIgPT0gX3R5cGVvZihlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgU3RyaW5nXCIpO1xuICByZXR1cm4gaGUoZSk7XG59XG5mdW5jdGlvbiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihlKSB7XG4gIHZhciB0ID0gVG9OdW1iZXIoZSk7XG4gIGlmICgwID09PSB0KSByZXR1cm4gMDtcbiAgaWYgKGRlKHQpIHx8ICFtZSh0KSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIG51bWJlciB2YWx1ZVwiKTtcbiAgdmFyIHIgPSBsZSh0KTtcbiAgcmV0dXJuIDAgPT09IHIgPyAwIDogcjtcbn1cbmZ1bmN0aW9uIFRvUG9zaXRpdmVJbnRlZ2VyV2l0aFRydW5jYXRpb24oZSwgdCkge1xuICB2YXIgciA9IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKGUpO1xuICBpZiAociA8PSAwKSB7XG4gICAgaWYgKHZvaWQgMCAhPT0gdCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJwcm9wZXJ0eSAnXCIuY29uY2F0KHQsIFwiJyBjYW5ub3QgYmUgYSBhIG51bWJlciBsZXNzIHRoYW4gb25lXCIpKTtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbm5vdCBjb252ZXJ0IGEgbnVtYmVyIGxlc3MgdGhhbiBvbmUgdG8gYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gVG9JbnRlZ2VySWZJbnRlZ3JhbChlKSB7XG4gIHZhciB0ID0gVG9OdW1iZXIoZSk7XG4gIGlmICghbWUodCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5maW5pdHkgaXMgb3V0IG9mIHJhbmdlXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIodCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwidW5zdXBwb3J0ZWQgZnJhY3Rpb25hbCB2YWx1ZSBcIi5jb25jYXQoZSkpO1xuICByZXR1cm4gMCA9PT0gdCA/IDAgOiB0O1xufVxuZnVuY3Rpb24gZGl2bW9kKHQsIHIpIHtcbiAgcmV0dXJuIHtcbiAgICBxdW90aWVudDogdCAvIHIsXG4gICAgcmVtYWluZGVyOiB0ICUgclxuICB9O1xufVxuZnVuY3Rpb24gaXNOZWdhdGl2ZUpTQkkodCkge1xuICByZXR1cm4gdCA8IEllO1xufVxuZnVuY3Rpb24gc2lnbkpTQkkoZSkge1xuICByZXR1cm4gaXNaZXJvKGUpID8gMCA6IGlzTmVnYXRpdmVKU0JJKGUpID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gYWJzKHQpIHtcbiAgcmV0dXJuIHQgPCBJZSA/IHQgKiBDZSA6IHQ7XG59XG52YXIgJGUgPSBuZXcgTWFwKFtbXCJ5ZWFyXCIsIFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uXSwgW1wibW9udGhcIiwgVG9Qb3NpdGl2ZUludGVnZXJXaXRoVHJ1bmNhdGlvbl0sIFtcIm1vbnRoQ29kZVwiLCBUb1N0cmluZ10sIFtcImRheVwiLCBUb1Bvc2l0aXZlSW50ZWdlcldpdGhUcnVuY2F0aW9uXSwgW1wiaG91clwiLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbl0sIFtcIm1pbnV0ZVwiLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbl0sIFtcInNlY29uZFwiLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbl0sIFtcIm1pbGxpc2Vjb25kXCIsIFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uXSwgW1wibWljcm9zZWNvbmRcIiwgVG9JbnRlZ2VyV2l0aFRydW5jYXRpb25dLCBbXCJuYW5vc2Vjb25kXCIsIFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uXSwgW1wieWVhcnNcIiwgVG9JbnRlZ2VySWZJbnRlZ3JhbF0sIFtcIm1vbnRoc1wiLCBUb0ludGVnZXJJZkludGVncmFsXSwgW1wid2Vla3NcIiwgVG9JbnRlZ2VySWZJbnRlZ3JhbF0sIFtcImRheXNcIiwgVG9JbnRlZ2VySWZJbnRlZ3JhbF0sIFtcImhvdXJzXCIsIFRvSW50ZWdlcklmSW50ZWdyYWxdLCBbXCJtaW51dGVzXCIsIFRvSW50ZWdlcklmSW50ZWdyYWxdLCBbXCJzZWNvbmRzXCIsIFRvSW50ZWdlcklmSW50ZWdyYWxdLCBbXCJtaWxsaXNlY29uZHNcIiwgVG9JbnRlZ2VySWZJbnRlZ3JhbF0sIFtcIm1pY3Jvc2Vjb25kc1wiLCBUb0ludGVnZXJJZkludGVncmFsXSwgW1wibmFub3NlY29uZHNcIiwgVG9JbnRlZ2VySWZJbnRlZ3JhbF0sIFtcImVyYVwiLCBUb1N0cmluZ10sIFtcImVyYVllYXJcIiwgVG9JbnRlZ2VyT3JJbmZpbml0eV0sIFtcIm9mZnNldFwiLCBUb1N0cmluZ11dKSxcbiAga2UgPSBuZXcgTWFwKFtbXCJob3VyXCIsIDBdLCBbXCJtaW51dGVcIiwgMF0sIFtcInNlY29uZFwiLCAwXSwgW1wibWlsbGlzZWNvbmRcIiwgMF0sIFtcIm1pY3Jvc2Vjb25kXCIsIDBdLCBbXCJuYW5vc2Vjb25kXCIsIDBdXSksXG4gIFVlID0gW1tcInllYXJzXCIsIFwieWVhclwiLCBcImRhdGVcIl0sIFtcIm1vbnRoc1wiLCBcIm1vbnRoXCIsIFwiZGF0ZVwiXSwgW1wid2Vla3NcIiwgXCJ3ZWVrXCIsIFwiZGF0ZVwiXSwgW1wiZGF5c1wiLCBcImRheVwiLCBcImRhdGVcIl0sIFtcImhvdXJzXCIsIFwiaG91clwiLCBcInRpbWVcIl0sIFtcIm1pbnV0ZXNcIiwgXCJtaW51dGVcIiwgXCJ0aW1lXCJdLCBbXCJzZWNvbmRzXCIsIFwic2Vjb25kXCIsIFwidGltZVwiXSwgW1wibWlsbGlzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRcIiwgXCJ0aW1lXCJdLCBbXCJtaWNyb3NlY29uZHNcIiwgXCJtaWNyb3NlY29uZFwiLCBcInRpbWVcIl0sIFtcIm5hbm9zZWNvbmRzXCIsIFwibmFub3NlY29uZFwiLCBcInRpbWVcIl1dLFxuICBBZSA9IG5ldyBNYXAoVWUubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIFtlWzBdLCBlWzFdXTtcbiAgfSkpLFxuICBMZSA9IG5ldyBNYXAoVWUubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICBlID0gX3JlZjJbMF0sXG4gICAgICB0ID0gX3JlZjJbMV07XG4gICAgcmV0dXJuIFt0LCBlXTtcbiAgfSkpLFxuICB4ZSA9IFVlLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICBlID0gX3JlZjRbMV07XG4gICAgcmV0dXJuIGU7XG4gIH0pLFxuICBXZSA9IEFycmF5LmZyb20oQWUua2V5cygpKS5zb3J0KCksXG4gIHFlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0SW50bERhdGVUaW1lRm9ybWF0RW5Vc0ZvclRpbWVab25lKGUpIHtcbiAgdmFyIHQgPSBxZS5nZXQoZSk7XG4gIHJldHVybiB2b2lkIDAgPT09IHQgJiYgKHQgPSBuZXcgcmUoXCJlbi11c1wiLCB7XG4gICAgdGltZVpvbmU6IGhlKGUpLFxuICAgIGhvdXIxMjogITEsXG4gICAgZXJhOiBcInNob3J0XCIsXG4gICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgbW9udGg6IFwibnVtZXJpY1wiLFxuICAgIGRheTogXCJudW1lcmljXCIsXG4gICAgaG91cjogXCJudW1lcmljXCIsXG4gICAgbWludXRlOiBcIm51bWVyaWNcIixcbiAgICBzZWNvbmQ6IFwibnVtZXJpY1wiXG4gIH0pLCBxZS5zZXQoZSwgdCkpLCB0O1xufVxuZnVuY3Rpb24gVG9PYmplY3QoZSkge1xuICBpZiAobnVsbCA9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgb2JqZWN0IG5vdCBcIi5jb25jYXQoZSkpO1xuICByZXR1cm4gT2JqZWN0KGUpO1xufVxuZnVuY3Rpb24gQ29weURhdGFQcm9wZXJ0aWVzKGUsIHQsIHIsIG8pIHtcbiAgaWYgKG51bGwgPT0gdCkgcmV0dXJuO1xuICB2YXIgbiA9IHllKHQpO1xuICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG4pLFxuICAgIF9zdGVwMztcbiAgdHJ5IHtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBhID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgaWYgKCFyLnNvbWUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5pcyhlLCBhKTtcbiAgICAgIH0pICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0LCBhKSkge1xuICAgICAgICB2YXIgX3IzID0gdFthXTtcbiAgICAgICAgaWYgKG8gJiYgby5zb21lKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5pcyhlLCBfcjMpO1xuICAgICAgICB9KSkgcmV0dXJuIDE7IC8vIGNvbnRpbnVlXG4gICAgICAgIGVbYV0gPSBfcjM7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgaWYgKF9sb29wKCkpIGNvbnRpbnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMy5mKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxJbnN0YW50KGUpIHtcbiAgcmV0dXJuIEhhc1Nsb3QoZSwgbikgJiYgIUhhc1Nsb3QoZSwgZywgcCk7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsVGltZVpvbmUoZSkge1xuICByZXR1cm4gSGFzU2xvdChlLCBhKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxDYWxlbmRhcihlKSB7XG4gIHJldHVybiBIYXNTbG90KGUsIEYpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbER1cmF0aW9uKGUpIHtcbiAgcmV0dXJuIEhhc1Nsb3QoZSwgdywgRCwgdiwgQywgTywgYiwgRSwgTSwgUik7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsRGF0ZShlKSB7XG4gIHJldHVybiBIYXNTbG90KGUsIGYpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbFRpbWUoZSkge1xuICByZXR1cm4gSGFzU2xvdChlLCBkLCBtLCBjLCBoLCB1LCBUKSAmJiAhSGFzU2xvdChlLCBpLCBzLCBsKTtcbn1cbmZ1bmN0aW9uIElzVGVtcG9yYWxEYXRlVGltZShlKSB7XG4gIHJldHVybiBIYXNTbG90KGUsIGksIHMsIGwsIGQsIG0sIGMsIGgsIHUsIFQpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbFllYXJNb250aChlKSB7XG4gIHJldHVybiBIYXNTbG90KGUsIHkpO1xufVxuZnVuY3Rpb24gSXNUZW1wb3JhbE1vbnRoRGF5KGUpIHtcbiAgcmV0dXJuIEhhc1Nsb3QoZSwgSSk7XG59XG5mdW5jdGlvbiBJc1RlbXBvcmFsWm9uZWREYXRlVGltZShlKSB7XG4gIHJldHVybiBIYXNTbG90KGUsIG4sIGcsIHApO1xufVxuZnVuY3Rpb24gUmVqZWN0VGVtcG9yYWxMaWtlT2JqZWN0KGUpIHtcbiAgaWYgKEhhc1Nsb3QoZSwgcCkgfHwgSGFzU2xvdChlLCBnKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIndpdGgoKSBkb2VzIG5vdCBzdXBwb3J0IGEgY2FsZW5kYXIgb3IgdGltZVpvbmUgcHJvcGVydHlcIik7XG4gIGlmIChJc1RlbXBvcmFsVGltZShlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIndpdGgoKSBkb2VzIG5vdCBhY2NlcHQgVGVtcG9yYWwuUGxhaW5UaW1lLCB1c2Ugd2l0aFBsYWluVGltZSgpIGluc3RlYWRcIik7XG4gIGlmICh2b2lkIDAgIT09IGUuY2FsZW5kYXIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ3aXRoKCkgZG9lcyBub3Qgc3VwcG9ydCBhIGNhbGVuZGFyIHByb3BlcnR5XCIpO1xuICBpZiAodm9pZCAwICE9PSBlLnRpbWVab25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwid2l0aCgpIGRvZXMgbm90IHN1cHBvcnQgYSB0aW1lWm9uZSBwcm9wZXJ0eVwiKTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxUaW1lWm9uZShlKSB7XG4gIHZhciBfUGFyc2VUZW1wb3JhbFRpbWVab24gPSBmdW5jdGlvbiBQYXJzZVRlbXBvcmFsVGltZVpvbmVTdHJpbmcoZSkge1xuICAgICAgaWYgKG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KCQuc291cmNlLCBcIiRcIiksIFwiaVwiKS50ZXN0KGUpKSByZXR1cm4ge1xuICAgICAgICBpYW5hTmFtZTogZVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfdDMgPSBQYXJzZUlTT0RhdGVUaW1lKGUpO1xuICAgICAgICBpZiAoX3QzLnogfHwgX3QzLm9mZnNldCB8fCBfdDMuaWFuYU5hbWUpIHJldHVybiBfdDM7XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRpbWUgem9uZTogXCIuY29uY2F0KGUpKTtcbiAgICB9KGUpLFxuICAgIHQgPSBfUGFyc2VUZW1wb3JhbFRpbWVab24uaWFuYU5hbWUsXG4gICAgciA9IF9QYXJzZVRlbXBvcmFsVGltZVpvbi5vZmZzZXQsXG4gICAgbyA9IF9QYXJzZVRlbXBvcmFsVGltZVpvbi56O1xuICBpZiAodCkgcmV0dXJuIEdldENhbm9uaWNhbFRpbWVab25lSWRlbnRpZmllcih0KTtcbiAgaWYgKG8pIHJldHVybiBcIlVUQ1wiO1xuICByZXR1cm4gRm9ybWF0VGltZVpvbmVPZmZzZXRTdHJpbmcoUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhyKSk7XG59XG5mdW5jdGlvbiBNYXliZUZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbihlLCB0KSB7XG4gIHJldHVybiBcIm5ldmVyXCIgPT09IHQgPyBcIlwiIDogRm9ybWF0Q2FsZW5kYXJBbm5vdGF0aW9uKFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoZSksIHQpO1xufVxuZnVuY3Rpb24gRm9ybWF0Q2FsZW5kYXJBbm5vdGF0aW9uKGUsIHQpIHtcbiAgaWYgKFwibmV2ZXJcIiA9PT0gdCkgcmV0dXJuIFwiXCI7XG4gIGlmIChcImF1dG9cIiA9PT0gdCAmJiBcImlzbzg2MDFcIiA9PT0gZSkgcmV0dXJuIFwiXCI7XG4gIHJldHVybiBcIltcIi5jb25jYXQoXCJjcml0aWNhbFwiID09PSB0ID8gXCIhXCIgOiBcIlwiLCBcInUtY2E9XCIpLmNvbmNhdChlLCBcIl1cIik7XG59XG5mdW5jdGlvbiBQYXJzZUlTT0RhdGVUaW1lKGUpIHtcbiAgdmFyIHQgPSBWLmV4ZWMoZSk7XG4gIGlmICghdCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIElTTyA4NjAxIHN0cmluZzogXCIuY29uY2F0KGUpKTtcbiAgdmFyIHIgPSB0WzFdO1xuICBpZiAoXCLiiJJcIiA9PT0gclswXSAmJiAociA9IFwiLVwiLmNvbmNhdChyLnNsaWNlKDEpKSksIFwiLTAwMDAwMFwiID09PSByKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgSVNPIDg2MDEgc3RyaW5nOiBcIi5jb25jYXQoZSkpO1xuICB2YXIgbyA9IFRvSW50ZWdlck9ySW5maW5pdHkociksXG4gICAgbiA9IFRvSW50ZWdlck9ySW5maW5pdHkodFsyXSB8fCB0WzRdKSxcbiAgICBhID0gVG9JbnRlZ2VyT3JJbmZpbml0eSh0WzNdIHx8IHRbNV0pLFxuICAgIGkgPSBUb0ludGVnZXJPckluZmluaXR5KHRbNl0pLFxuICAgIHMgPSB2b2lkIDAgIT09IHRbNl0sXG4gICAgbCA9IFRvSW50ZWdlck9ySW5maW5pdHkodFs3XSB8fCB0WzEwXSk7XG4gIHZhciBkID0gVG9JbnRlZ2VyT3JJbmZpbml0eSh0WzhdIHx8IHRbMTFdKTtcbiAgNjAgPT09IGQgJiYgKGQgPSA1OSk7XG4gIHZhciBtID0gKHRbOV0gfHwgdFsxMl0pICsgXCIwMDAwMDAwMDBcIixcbiAgICBjID0gVG9JbnRlZ2VyT3JJbmZpbml0eShtLnNsaWNlKDAsIDMpKSxcbiAgICBoID0gVG9JbnRlZ2VyT3JJbmZpbml0eShtLnNsaWNlKDMsIDYpKSxcbiAgICB1ID0gVG9JbnRlZ2VyT3JJbmZpbml0eShtLnNsaWNlKDYsIDkpKTtcbiAgdmFyIFQsXG4gICAgcCA9ICExO1xuICBpZiAodFsxM10pIFQgPSB2b2lkIDAsIHAgPSAhMDtlbHNlIGlmICh0WzE0XSAmJiB0WzE1XSkge1xuICAgIHZhciBfZTIgPSBcIi1cIiA9PT0gdFsxNF0gfHwgXCLiiJJcIiA9PT0gdFsxNF0gPyBcIi1cIiA6IFwiK1wiLFxuICAgICAgX3I0ID0gdFsxNV0gfHwgXCIwMFwiLFxuICAgICAgX28gPSB0WzE2XSB8fCBcIjAwXCIsXG4gICAgICBfbiA9IHRbMTddIHx8IFwiMDBcIjtcbiAgICB2YXIgX2EgPSB0WzE4XSB8fCBcIjBcIjtcbiAgICBpZiAoVCA9IFwiXCIuY29uY2F0KF9lMikuY29uY2F0KF9yNCwgXCI6XCIpLmNvbmNhdChfbyksICtfYSkge1xuICAgICAgZm9yICg7IF9hLmVuZHNXaXRoKFwiMFwiKTspIF9hID0gX2Euc2xpY2UoMCwgLTEpO1xuICAgICAgVCArPSBcIjpcIi5jb25jYXQoX24sIFwiLlwiKS5jb25jYXQoX2EpO1xuICAgIH0gZWxzZSArX24gJiYgKFQgKz0gXCI6XCIuY29uY2F0KF9uKSk7XG4gICAgXCItMDA6MDBcIiA9PT0gVCAmJiAoVCA9IFwiKzAwOjAwXCIpO1xuICB9XG4gIHZhciBmID0gdFsxOV0sXG4gICAgeSA9IHRbMjBdO1xuICB2YXIgSTtcbiAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih5Lm1hdGNoQWxsKEgpKSxcbiAgICBfc3RlcDQ7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfc3RlcDQkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDQudmFsdWUsIDQpLFxuICAgICAgICBfZTMgPSBfc3RlcDQkdmFsdWVbMV0sXG4gICAgICAgIF90NCA9IF9zdGVwNCR2YWx1ZVsyXSxcbiAgICAgICAgX3I1ID0gX3N0ZXA0JHZhbHVlWzNdO1xuICAgICAgaWYgKFwidS1jYVwiID09PSBfdDQpIHZvaWQgMCA9PT0gSSAmJiAoSSA9IF9yNSk7ZWxzZSBpZiAoXCIhXCIgPT09IF9lMykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbnJlY29nbml6ZWQgYW5ub3RhdGlvbjogIVwiLmNvbmNhdChfdDQsIFwiPVwiKS5jb25jYXQoX3I1KSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3I0LmYoKTtcbiAgfVxuICByZXR1cm4gUmVqZWN0RGF0ZVRpbWUobywgbiwgYSwgaSwgbCwgZCwgYywgaCwgdSksIHtcbiAgICB5ZWFyOiBvLFxuICAgIG1vbnRoOiBuLFxuICAgIGRheTogYSxcbiAgICBoYXNUaW1lOiBzLFxuICAgIGhvdXI6IGksXG4gICAgbWludXRlOiBsLFxuICAgIHNlY29uZDogZCxcbiAgICBtaWxsaXNlY29uZDogYyxcbiAgICBtaWNyb3NlY29uZDogaCxcbiAgICBuYW5vc2Vjb25kOiB1LFxuICAgIGlhbmFOYW1lOiBmLFxuICAgIG9mZnNldDogVCxcbiAgICB6OiBwLFxuICAgIGNhbGVuZGFyOiBJXG4gIH07XG59XG5mdW5jdGlvbiBQYXJzZVRlbXBvcmFsWWVhck1vbnRoU3RyaW5nKGUpIHtcbiAgdmFyIHQgPSBfLmV4ZWMoZSk7XG4gIHZhciByLCBvLCBuLCBhO1xuICBpZiAodCkge1xuICAgIHZhciBfYTIgPSB0WzFdO1xuICAgIGlmIChcIuKIklwiID09PSBfYTJbMF0gJiYgKF9hMiA9IFwiLVwiLmNvbmNhdChfYTIuc2xpY2UoMSkpKSwgXCItMDAwMDAwXCIgPT09IF9hMikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIElTTyA4NjAxIHN0cmluZzogXCIuY29uY2F0KGUpKTtcbiAgICByID0gVG9JbnRlZ2VyT3JJbmZpbml0eShfYTIpLCBvID0gVG9JbnRlZ2VyT3JJbmZpbml0eSh0WzJdKTtcbiAgICB2YXIgX2kgPSB0WzNdO1xuICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoX2kubWF0Y2hBbGwoSCkpLFxuICAgICAgX3N0ZXA1O1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXA1JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA1LnZhbHVlLCA0KSxcbiAgICAgICAgICBfZTQgPSBfc3RlcDUkdmFsdWVbMV0sXG4gICAgICAgICAgX3Q1ID0gX3N0ZXA1JHZhbHVlWzJdLFxuICAgICAgICAgIF9yNiA9IF9zdGVwNSR2YWx1ZVszXTtcbiAgICAgICAgaWYgKFwidS1jYVwiID09PSBfdDUpIHZvaWQgMCA9PT0gbiAmJiAobiA9IF9yNik7ZWxzZSBpZiAoXCIhXCIgPT09IF9lNCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbnJlY29nbml6ZWQgYW5ub3RhdGlvbjogIVwiLmNvbmNhdChfdDUsIFwiPVwiKS5jb25jYXQoX3I2KSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgfVxuICAgIGlmICh2b2lkIDAgIT09IG4gJiYgXCJpc284NjAxXCIgIT09IG4pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiWVlZWS1NTSBmb3JtYXQgaXMgb25seSB2YWxpZCB3aXRoIGlzbzg2MDEgY2FsZW5kYXJcIik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9QYXJzZUlTT0RhdGVUaW1lO1xuICAgIHZhciBfdDY7XG4gICAgaWYgKChfUGFyc2VJU09EYXRlVGltZSA9IFBhcnNlSVNPRGF0ZVRpbWUoZSksIHIgPSBfUGFyc2VJU09EYXRlVGltZS55ZWFyLCBvID0gX1BhcnNlSVNPRGF0ZVRpbWUubW9udGgsIG4gPSBfUGFyc2VJU09EYXRlVGltZS5jYWxlbmRhciwgYSA9IF9QYXJzZUlTT0RhdGVUaW1lLmRheSwgX3Q2ID0gX1BhcnNlSVNPRGF0ZVRpbWUueiksIF90NikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJaIGRlc2lnbmF0b3Igbm90IHN1cHBvcnRlZCBmb3IgUGxhaW5ZZWFyTW9udGhcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiByLFxuICAgIG1vbnRoOiBvLFxuICAgIGNhbGVuZGFyOiBuLFxuICAgIHJlZmVyZW5jZUlTT0RheTogYVxuICB9O1xufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbE1vbnRoRGF5U3RyaW5nKGUpIHtcbiAgdmFyIHQgPSBKLmV4ZWMoZSk7XG4gIHZhciByLCBvLCBuLCBhO1xuICBpZiAodCkge1xuICAgIHIgPSBUb0ludGVnZXJPckluZmluaXR5KHRbMV0pLCBvID0gVG9JbnRlZ2VyT3JJbmZpbml0eSh0WzJdKTtcbiAgICB2YXIgX2U1ID0gdFszXTtcbiAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKF9lNS5tYXRjaEFsbChIKSksXG4gICAgICBfc3RlcDY7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDYkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDYudmFsdWUsIDQpLFxuICAgICAgICAgIF90NyA9IF9zdGVwNiR2YWx1ZVsxXSxcbiAgICAgICAgICBfcjcgPSBfc3RlcDYkdmFsdWVbMl0sXG4gICAgICAgICAgX28yID0gX3N0ZXA2JHZhbHVlWzNdO1xuICAgICAgICBpZiAoXCJ1LWNhXCIgPT09IF9yNykgdm9pZCAwID09PSBuICYmIChuID0gX28yKTtlbHNlIGlmIChcIiFcIiA9PT0gX3Q3KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVucmVjb2duaXplZCBhbm5vdGF0aW9uOiAhXCIuY29uY2F0KF9yNywgXCI9XCIpLmNvbmNhdChfbzIpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICB9XG4gICAgaWYgKHZvaWQgMCAhPT0gbiAmJiBcImlzbzg2MDFcIiAhPT0gbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNTS1ERCBmb3JtYXQgaXMgb25seSB2YWxpZCB3aXRoIGlzbzg2MDEgY2FsZW5kYXJcIik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9QYXJzZUlTT0RhdGVUaW1lMjtcbiAgICB2YXIgX3Q4O1xuICAgIGlmICgoX1BhcnNlSVNPRGF0ZVRpbWUyID0gUGFyc2VJU09EYXRlVGltZShlKSwgciA9IF9QYXJzZUlTT0RhdGVUaW1lMi5tb250aCwgbyA9IF9QYXJzZUlTT0RhdGVUaW1lMi5kYXksIG4gPSBfUGFyc2VJU09EYXRlVGltZTIuY2FsZW5kYXIsIGEgPSBfUGFyc2VJU09EYXRlVGltZTIueWVhciwgX3Q4ID0gX1BhcnNlSVNPRGF0ZVRpbWUyLnopLCBfdDgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiWiBkZXNpZ25hdG9yIG5vdCBzdXBwb3J0ZWQgZm9yIFBsYWluTW9udGhEYXlcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtb250aDogcixcbiAgICBkYXk6IG8sXG4gICAgY2FsZW5kYXI6IG4sXG4gICAgcmVmZXJlbmNlSVNPWWVhcjogYVxuICB9O1xufVxuZnVuY3Rpb24gUGFyc2VUZW1wb3JhbEluc3RhbnQoZSkge1xuICB2YXIgX1BhcnNlVGVtcG9yYWxJbnN0YW50ID0gZnVuY3Rpb24gUGFyc2VUZW1wb3JhbEluc3RhbnRTdHJpbmcoZSkge1xuICAgICAgdmFyIHQgPSBQYXJzZUlTT0RhdGVUaW1lKGUpO1xuICAgICAgaWYgKCF0LnogJiYgIXQub2Zmc2V0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRlbXBvcmFsLkluc3RhbnQgcmVxdWlyZXMgYSB0aW1lIHpvbmUgb2Zmc2V0XCIpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfShlKSxcbiAgICB0ID0gX1BhcnNlVGVtcG9yYWxJbnN0YW50LnllYXIsXG4gICAgciA9IF9QYXJzZVRlbXBvcmFsSW5zdGFudC5tb250aCxcbiAgICBvID0gX1BhcnNlVGVtcG9yYWxJbnN0YW50LmRheSxcbiAgICBuID0gX1BhcnNlVGVtcG9yYWxJbnN0YW50LmhvdXIsXG4gICAgYSA9IF9QYXJzZVRlbXBvcmFsSW5zdGFudC5taW51dGUsXG4gICAgaSA9IF9QYXJzZVRlbXBvcmFsSW5zdGFudC5zZWNvbmQsXG4gICAgcyA9IF9QYXJzZVRlbXBvcmFsSW5zdGFudC5taWxsaXNlY29uZCxcbiAgICBsID0gX1BhcnNlVGVtcG9yYWxJbnN0YW50Lm1pY3Jvc2Vjb25kLFxuICAgIGQgPSBfUGFyc2VUZW1wb3JhbEluc3RhbnQubmFub3NlY29uZCxcbiAgICBtID0gX1BhcnNlVGVtcG9yYWxJbnN0YW50Lm9mZnNldCxcbiAgICBjID0gX1BhcnNlVGVtcG9yYWxJbnN0YW50Lno7XG4gIGlmICghYyAmJiAhbSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZW1wb3JhbC5JbnN0YW50IHJlcXVpcmVzIGEgdGltZSB6b25lIG9mZnNldFwiKTtcbiAgdmFyIGggPSBjID8gMCA6IFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcobSk7XG4gIHZhciBfQmFsYW5jZUlTT0RhdGVUaW1lID0gQmFsYW5jZUlTT0RhdGVUaW1lKHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQgLSBoKTtcbiAgdCA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUueWVhcjtcbiAgciA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUubW9udGg7XG4gIG8gPSBfQmFsYW5jZUlTT0RhdGVUaW1lLmRheTtcbiAgbiA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUuaG91cjtcbiAgYSA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUubWludXRlO1xuICBpID0gX0JhbGFuY2VJU09EYXRlVGltZS5zZWNvbmQ7XG4gIHMgPSBfQmFsYW5jZUlTT0RhdGVUaW1lLm1pbGxpc2Vjb25kO1xuICBsID0gX0JhbGFuY2VJU09EYXRlVGltZS5taWNyb3NlY29uZDtcbiAgZCA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUubmFub3NlY29uZDtcbiAgdmFyIHUgPSBHZXRVVENFcG9jaE5hbm9zZWNvbmRzKHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQpO1xuICBpZiAobnVsbCA9PT0gdSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEYXRlVGltZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZVwiKTtcbiAgcmV0dXJuIHU7XG59XG5mdW5jdGlvbiBSZWd1bGF0ZUlTT0RhdGUoZSwgdCwgciwgbykge1xuICB2YXIgbiA9IGUsXG4gICAgYSA9IHQsXG4gICAgaSA9IHI7XG4gIHN3aXRjaCAobykge1xuICAgIGNhc2UgXCJyZWplY3RcIjpcbiAgICAgIFJlamVjdElTT0RhdGUobiwgYSwgaSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29uc3RyYWluXCI6XG4gICAgICB2YXIgX0NvbnN0cmFpbklTT0RhdGUgPSBDb25zdHJhaW5JU09EYXRlKG4sIGEsIGkpO1xuICAgICAgbiA9IF9Db25zdHJhaW5JU09EYXRlLnllYXI7XG4gICAgICBhID0gX0NvbnN0cmFpbklTT0RhdGUubW9udGg7XG4gICAgICBpID0gX0NvbnN0cmFpbklTT0RhdGUuZGF5O1xuICB9XG4gIHJldHVybiB7XG4gICAgeWVhcjogbixcbiAgICBtb250aDogYSxcbiAgICBkYXk6IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIFJlZ3VsYXRlVGltZShlLCB0LCByLCBvLCBuLCBhLCBpKSB7XG4gIHZhciBzID0gZSxcbiAgICBsID0gdCxcbiAgICBkID0gcixcbiAgICBtID0gbyxcbiAgICBjID0gbixcbiAgICBoID0gYTtcbiAgc3dpdGNoIChpKSB7XG4gICAgY2FzZSBcInJlamVjdFwiOlxuICAgICAgUmVqZWN0VGltZShzLCBsLCBkLCBtLCBjLCBoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb25zdHJhaW5cIjpcbiAgICAgIHZhciBfQ29uc3RyYWluVGltZSA9IGZ1bmN0aW9uIENvbnN0cmFpblRpbWUoZSwgdCwgciwgbywgbiwgYSkge1xuICAgICAgICB2YXIgaSA9IENvbnN0cmFpblRvUmFuZ2UoZSwgMCwgMjMpLFxuICAgICAgICAgIHMgPSBDb25zdHJhaW5Ub1JhbmdlKHQsIDAsIDU5KSxcbiAgICAgICAgICBsID0gQ29uc3RyYWluVG9SYW5nZShyLCAwLCA1OSksXG4gICAgICAgICAgZCA9IENvbnN0cmFpblRvUmFuZ2UobywgMCwgOTk5KSxcbiAgICAgICAgICBtID0gQ29uc3RyYWluVG9SYW5nZShuLCAwLCA5OTkpLFxuICAgICAgICAgIGMgPSBDb25zdHJhaW5Ub1JhbmdlKGEsIDAsIDk5OSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaG91cjogaSxcbiAgICAgICAgICBtaW51dGU6IHMsXG4gICAgICAgICAgc2Vjb25kOiBsLFxuICAgICAgICAgIG1pbGxpc2Vjb25kOiBkLFxuICAgICAgICAgIG1pY3Jvc2Vjb25kOiBtLFxuICAgICAgICAgIG5hbm9zZWNvbmQ6IGNcbiAgICAgICAgfTtcbiAgICAgIH0ocywgbCwgZCwgbSwgYywgaCk7XG4gICAgICBzID0gX0NvbnN0cmFpblRpbWUuaG91cjtcbiAgICAgIGwgPSBfQ29uc3RyYWluVGltZS5taW51dGU7XG4gICAgICBkID0gX0NvbnN0cmFpblRpbWUuc2Vjb25kO1xuICAgICAgbSA9IF9Db25zdHJhaW5UaW1lLm1pbGxpc2Vjb25kO1xuICAgICAgYyA9IF9Db25zdHJhaW5UaW1lLm1pY3Jvc2Vjb25kO1xuICAgICAgaCA9IF9Db25zdHJhaW5UaW1lLm5hbm9zZWNvbmQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBob3VyOiBzLFxuICAgIG1pbnV0ZTogbCxcbiAgICBzZWNvbmQ6IGQsXG4gICAgbWlsbGlzZWNvbmQ6IG0sXG4gICAgbWljcm9zZWNvbmQ6IGMsXG4gICAgbmFub3NlY29uZDogaFxuICB9O1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkKGUpIHtcbiAgaWYgKCFJc09iamVjdChlKSkgcmV0dXJuIGZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxEdXJhdGlvblN0cmluZyhlKSB7XG4gICAgdmFyIHQgPSBRLmV4ZWMoZSk7XG4gICAgaWYgKCF0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgZHVyYXRpb246IFwiLmNvbmNhdChlKSk7XG4gICAgaWYgKHQuc2xpY2UoMikuZXZlcnkoZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IGU7XG4gICAgfSkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCBkdXJhdGlvbjogXCIuY29uY2F0KGUpKTtcbiAgICB2YXIgciA9IFwiLVwiID09PSB0WzFdIHx8IFwi4oiSXCIgPT09IHRbMV0gPyAtMSA6IDEsXG4gICAgICBvID0gdm9pZCAwID09PSB0WzJdID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKHRbMl0pICogcixcbiAgICAgIG4gPSB2b2lkIDAgPT09IHRbM10gPyAwIDogVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24odFszXSkgKiByLFxuICAgICAgYSA9IHZvaWQgMCA9PT0gdFs0XSA/IDAgOiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbih0WzRdKSAqIHIsXG4gICAgICBpID0gdm9pZCAwID09PSB0WzVdID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKHRbNV0pICogcixcbiAgICAgIHMgPSB2b2lkIDAgPT09IHRbNl0gPyAwIDogVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24odFs2XSkgKiByLFxuICAgICAgbCA9IHRbN10sXG4gICAgICBkID0gdFs4XSxcbiAgICAgIG0gPSB0WzldLFxuICAgICAgYyA9IHRbMTBdLFxuICAgICAgaCA9IHRbMTFdO1xuICAgIHZhciB1ID0gMCxcbiAgICAgIFQgPSAwLFxuICAgICAgcCA9IDA7XG4gICAgaWYgKHZvaWQgMCAhPT0gbCkge1xuICAgICAgdmFyIF9yZWY1LCBfcmVmNjtcbiAgICAgIGlmICgoX3JlZjUgPSAoX3JlZjYgPSBkICE9PSBudWxsICYmIGQgIT09IHZvaWQgMCA/IGQgOiBtKSAhPT0gbnVsbCAmJiBfcmVmNiAhPT0gdm9pZCAwID8gX3JlZjYgOiBjKSAhPT0gbnVsbCAmJiBfcmVmNSAhPT0gdm9pZCAwID8gX3JlZjUgOiBoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9ubHkgdGhlIHNtYWxsZXN0IHVuaXQgY2FuIGJlIGZyYWN0aW9uYWxcIik7XG4gICAgICBwID0gMzYwMCAqIFRvSW50ZWdlck9ySW5maW5pdHkoKGwgKyBcIjAwMDAwMDAwMFwiKS5zbGljZSgwLCA5KSkgKiByO1xuICAgIH0gZWxzZSBpZiAodSA9IHZvaWQgMCA9PT0gZCA/IDAgOiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihkKSAqIHIsIHZvaWQgMCAhPT0gbSkge1xuICAgICAgaWYgKGMgIT09IG51bGwgJiYgYyAhPT0gdm9pZCAwID8gYyA6IGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwib25seSB0aGUgc21hbGxlc3QgdW5pdCBjYW4gYmUgZnJhY3Rpb25hbFwiKTtcbiAgICAgIHAgPSA2MCAqIFRvSW50ZWdlck9ySW5maW5pdHkoKG0gKyBcIjAwMDAwMDAwMFwiKS5zbGljZSgwLCA5KSkgKiByO1xuICAgIH0gZWxzZSBUID0gdm9pZCAwID09PSBjID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKGMpICogciwgdm9pZCAwICE9PSBoICYmIChwID0gVG9JbnRlZ2VyT3JJbmZpbml0eSgoaCArIFwiMDAwMDAwMDAwXCIpLnNsaWNlKDAsIDkpKSAqIHIpO1xuICAgIHZhciBmID0gcCAlIDFlMyxcbiAgICAgIHkgPSBsZShwIC8gMWUzKSAlIDFlMyxcbiAgICAgIEkgPSBsZShwIC8gMWU2KSAlIDFlMztcbiAgICByZXR1cm4gVCArPSBsZShwIC8gMWU5KSAlIDYwLCB1ICs9IGxlKHAgLyA2ZTEwKSwgUmVqZWN0RHVyYXRpb24obywgbiwgYSwgaSwgcywgdSwgVCwgSSwgeSwgZiksIHtcbiAgICAgIHllYXJzOiBvLFxuICAgICAgbW9udGhzOiBuLFxuICAgICAgd2Vla3M6IGEsXG4gICAgICBkYXlzOiBpLFxuICAgICAgaG91cnM6IHMsXG4gICAgICBtaW51dGVzOiB1LFxuICAgICAgc2Vjb25kczogVCxcbiAgICAgIG1pbGxpc2Vjb25kczogSSxcbiAgICAgIG1pY3Jvc2Vjb25kczogeSxcbiAgICAgIG5hbm9zZWNvbmRzOiBmXG4gICAgfTtcbiAgfShUb1N0cmluZyhlKSk7XG4gIGlmIChJc1RlbXBvcmFsRHVyYXRpb24oZSkpIHJldHVybiB7XG4gICAgeWVhcnM6IEdldFNsb3QoZSwgdyksXG4gICAgbW9udGhzOiBHZXRTbG90KGUsIEQpLFxuICAgIHdlZWtzOiBHZXRTbG90KGUsIEcpLFxuICAgIGRheXM6IEdldFNsb3QoZSwgdiksXG4gICAgaG91cnM6IEdldFNsb3QoZSwgQyksXG4gICAgbWludXRlczogR2V0U2xvdChlLCBPKSxcbiAgICBzZWNvbmRzOiBHZXRTbG90KGUsIGIpLFxuICAgIG1pbGxpc2Vjb25kczogR2V0U2xvdChlLCBFKSxcbiAgICBtaWNyb3NlY29uZHM6IEdldFNsb3QoZSwgTSksXG4gICAgbmFub3NlY29uZHM6IEdldFNsb3QoZSwgUilcbiAgfTtcbiAgdmFyIHQgPSB7XG4gICAgeWVhcnM6IDAsXG4gICAgbW9udGhzOiAwLFxuICAgIHdlZWtzOiAwLFxuICAgIGRheXM6IDAsXG4gICAgaG91cnM6IDAsXG4gICAgbWludXRlczogMCxcbiAgICBzZWNvbmRzOiAwLFxuICAgIG1pbGxpc2Vjb25kczogMCxcbiAgICBtaWNyb3NlY29uZHM6IDAsXG4gICAgbmFub3NlY29uZHM6IDBcbiAgfTtcbiAgdmFyIHIgPSBmdW5jdGlvbiBUb1RlbXBvcmFsUGFydGlhbER1cmF0aW9uUmVjb3JkKGUpIHtcbiAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBkdXJhdGlvbi1saWtlXCIpO1xuICAgIHZhciB0ID0ge1xuICAgICAgeWVhcnM6IHZvaWQgMCxcbiAgICAgIG1vbnRoczogdm9pZCAwLFxuICAgICAgd2Vla3M6IHZvaWQgMCxcbiAgICAgIGRheXM6IHZvaWQgMCxcbiAgICAgIGhvdXJzOiB2b2lkIDAsXG4gICAgICBtaW51dGVzOiB2b2lkIDAsXG4gICAgICBzZWNvbmRzOiB2b2lkIDAsXG4gICAgICBtaWxsaXNlY29uZHM6IHZvaWQgMCxcbiAgICAgIG1pY3Jvc2Vjb25kczogdm9pZCAwLFxuICAgICAgbmFub3NlY29uZHM6IHZvaWQgMFxuICAgIH07XG4gICAgdmFyIHIgPSAhMTtcbiAgICB2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKFdlKSxcbiAgICAgIF9zdGVwNztcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9vMyA9IF9zdGVwNy52YWx1ZTtcbiAgICAgICAgdmFyIF9uMiA9IGVbX28zXTtcbiAgICAgICAgdm9pZCAwICE9PSBfbjIgJiYgKHIgPSAhMCwgdFtfbzNdID0gVG9JbnRlZ2VySWZJbnRlZ3JhbChfbjIpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjcuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I3LmYoKTtcbiAgICB9XG4gICAgaWYgKCFyKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBkdXJhdGlvbi1saWtlXCIpO1xuICAgIHJldHVybiB0O1xuICB9KGUpO1xuICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKFdlKSxcbiAgICBfc3RlcDg7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfZTYgPSBfc3RlcDgudmFsdWU7XG4gICAgICB2YXIgX280ID0gcltfZTZdO1xuICAgICAgdm9pZCAwICE9PSBfbzQgJiYgKHRbX2U2XSA9IF9vNCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3I4LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3I4LmYoKTtcbiAgfVxuICB2YXIgbyA9IHQueWVhcnMsXG4gICAgbiA9IHQubW9udGhzLFxuICAgIGEgPSB0LndlZWtzLFxuICAgIGkgPSB0LmRheXMsXG4gICAgcyA9IHQuaG91cnMsXG4gICAgbCA9IHQubWludXRlcyxcbiAgICBkID0gdC5zZWNvbmRzLFxuICAgIG0gPSB0Lm1pbGxpc2Vjb25kcyxcbiAgICBjID0gdC5taWNyb3NlY29uZHMsXG4gICAgaCA9IHQubmFub3NlY29uZHM7XG4gIHJldHVybiBSZWplY3REdXJhdGlvbihvLCBuLCBhLCBpLCBzLCBsLCBkLCBtLCBjLCBoKSwge1xuICAgIHllYXJzOiBvLFxuICAgIG1vbnRoczogbixcbiAgICB3ZWVrczogYSxcbiAgICBkYXlzOiBpLFxuICAgIGhvdXJzOiBzLFxuICAgIG1pbnV0ZXM6IGwsXG4gICAgc2Vjb25kczogZCxcbiAgICBtaWxsaXNlY29uZHM6IG0sXG4gICAgbWljcm9zZWNvbmRzOiBjLFxuICAgIG5hbm9zZWNvbmRzOiBoXG4gIH07XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsT3ZlcmZsb3coZSkge1xuICByZXR1cm4gdm9pZCAwID09PSBlID8gXCJjb25zdHJhaW5cIiA6IEdldE9wdGlvbihlLCBcIm92ZXJmbG93XCIsIFtcImNvbnN0cmFpblwiLCBcInJlamVjdFwiXSwgXCJjb25zdHJhaW5cIik7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRGlzYW1iaWd1YXRpb24oZSkge1xuICByZXR1cm4gdm9pZCAwID09PSBlID8gXCJjb21wYXRpYmxlXCIgOiBHZXRPcHRpb24oZSwgXCJkaXNhbWJpZ3VhdGlvblwiLCBbXCJjb21wYXRpYmxlXCIsIFwiZWFybGllclwiLCBcImxhdGVyXCIsIFwicmVqZWN0XCJdLCBcImNvbXBhdGlibGVcIik7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKGUsIHQpIHtcbiAgcmV0dXJuIEdldE9wdGlvbihlLCBcInJvdW5kaW5nTW9kZVwiLCBbXCJjZWlsXCIsIFwiZmxvb3JcIiwgXCJleHBhbmRcIiwgXCJ0cnVuY1wiLCBcImhhbGZDZWlsXCIsIFwiaGFsZkZsb29yXCIsIFwiaGFsZkV4cGFuZFwiLCBcImhhbGZUcnVuY1wiLCBcImhhbGZFdmVuXCJdLCB0KTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxPZmZzZXQoZSwgdCkge1xuICByZXR1cm4gdm9pZCAwID09PSBlID8gdCA6IEdldE9wdGlvbihlLCBcIm9mZnNldFwiLCBbXCJwcmVmZXJcIiwgXCJ1c2VcIiwgXCJpZ25vcmVcIiwgXCJyZWplY3RcIl0sIHQpO1xufVxuZnVuY3Rpb24gVG9DYWxlbmRhck5hbWVPcHRpb24oZSkge1xuICByZXR1cm4gR2V0T3B0aW9uKGUsIFwiY2FsZW5kYXJOYW1lXCIsIFtcImF1dG9cIiwgXCJhbHdheXNcIiwgXCJuZXZlclwiLCBcImNyaXRpY2FsXCJdLCBcImF1dG9cIik7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQoZSkge1xuICB2YXIgdCA9IGUucm91bmRpbmdJbmNyZW1lbnQ7XG4gIGlmICh2b2lkIDAgPT09IHQpIHJldHVybiAxO1xuICBpZiAodCA9IFRvTnVtYmVyKHQpLCAhbWUodCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwicm91bmRpbmdJbmNyZW1lbnQgbXVzdCBiZSBmaW5pdGVcIik7XG4gIHZhciByID0gbGUodCk7XG4gIGlmIChyIDwgMSB8fCByID4gMWU5KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInJvdW5kaW5nSW5jcmVtZW50IG11c3QgYmUgYXQgbGVhc3QgMSBhbmQgYXQgbW9zdCAxZTksIG5vdCBcIi5jb25jYXQodCkpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIFZhbGlkYXRlVGVtcG9yYWxSb3VuZGluZ0luY3JlbWVudChlLCB0LCByKSB7XG4gIHZhciBvID0gciA/IHQgOiB0IC0gMTtcbiAgaWYgKGUgPiBvKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInJvdW5kaW5nSW5jcmVtZW50IG11c3QgYmUgYXQgbGVhc3QgMSBhbmQgbGVzcyB0aGFuIFwiLmNvbmNhdChvLCBcIiwgbm90IFwiKS5jb25jYXQoZSkpO1xuICBpZiAodCAlIGUgIT0gMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSb3VuZGluZyBpbmNyZW1lbnQgbXVzdCBkaXZpZGUgZXZlbmx5IGludG8gXCIuY29uY2F0KHQpKTtcbn1cbmZ1bmN0aW9uIFRvRnJhY3Rpb25hbFNlY29uZERpZ2l0cyhlKSB7XG4gIHZhciB0ID0gZS5mcmFjdGlvbmFsU2Vjb25kRGlnaXRzO1xuICBpZiAodm9pZCAwID09PSB0KSByZXR1cm4gXCJhdXRvXCI7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB0KSB7XG4gICAgaWYgKFwiYXV0b1wiICE9PSBUb1N0cmluZyh0KSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJmcmFjdGlvbmFsU2Vjb25kRGlnaXRzIG11c3QgYmUgJ2F1dG8nIG9yIDAgdGhyb3VnaCA5LCBub3QgXCIuY29uY2F0KHQpKTtcbiAgICByZXR1cm4gXCJhdXRvXCI7XG4gIH1cbiAgdmFyIHIgPSBpZSh0KTtcbiAgaWYgKCFtZShyKSB8fCByIDwgMCB8fCByID4gOSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJmcmFjdGlvbmFsU2Vjb25kRGlnaXRzIG11c3QgYmUgJ2F1dG8nIG9yIDAgdGhyb3VnaCA5LCBub3QgXCIuY29uY2F0KHQpKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBUb1NlY29uZHNTdHJpbmdQcmVjaXNpb25SZWNvcmQoZSwgdCkge1xuICBzd2l0Y2ggKGUpIHtcbiAgICBjYXNlIFwibWludXRlXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVjaXNpb246IFwibWludXRlXCIsXG4gICAgICAgIHVuaXQ6IFwibWludXRlXCIsXG4gICAgICAgIGluY3JlbWVudDogMVxuICAgICAgfTtcbiAgICBjYXNlIFwic2Vjb25kXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVjaXNpb246IDAsXG4gICAgICAgIHVuaXQ6IFwic2Vjb25kXCIsXG4gICAgICAgIGluY3JlbWVudDogMVxuICAgICAgfTtcbiAgICBjYXNlIFwibWlsbGlzZWNvbmRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZWNpc2lvbjogMyxcbiAgICAgICAgdW5pdDogXCJtaWxsaXNlY29uZFwiLFxuICAgICAgICBpbmNyZW1lbnQ6IDFcbiAgICAgIH07XG4gICAgY2FzZSBcIm1pY3Jvc2Vjb25kXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVjaXNpb246IDYsXG4gICAgICAgIHVuaXQ6IFwibWljcm9zZWNvbmRcIixcbiAgICAgICAgaW5jcmVtZW50OiAxXG4gICAgICB9O1xuICAgIGNhc2UgXCJuYW5vc2Vjb25kXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVjaXNpb246IDksXG4gICAgICAgIHVuaXQ6IFwibmFub3NlY29uZFwiLFxuICAgICAgICBpbmNyZW1lbnQ6IDFcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcImF1dG9cIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZWNpc2lvbjogdCxcbiAgICAgICAgdW5pdDogXCJuYW5vc2Vjb25kXCIsXG4gICAgICAgIGluY3JlbWVudDogMVxuICAgICAgfTtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVjaXNpb246IHQsXG4gICAgICAgIHVuaXQ6IFwic2Vjb25kXCIsXG4gICAgICAgIGluY3JlbWVudDogMVxuICAgICAgfTtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSAyOlxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZWNpc2lvbjogdCxcbiAgICAgICAgdW5pdDogXCJtaWxsaXNlY29uZFwiLFxuICAgICAgICBpbmNyZW1lbnQ6IE1hdGgucG93KDEwLCAzIC0gdClcbiAgICAgIH07XG4gICAgY2FzZSA0OlxuICAgIGNhc2UgNTpcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVjaXNpb246IHQsXG4gICAgICAgIHVuaXQ6IFwibWljcm9zZWNvbmRcIixcbiAgICAgICAgaW5jcmVtZW50OiBNYXRoLnBvdygxMCwgNiAtIHQpXG4gICAgICB9O1xuICAgIGNhc2UgNzpcbiAgICBjYXNlIDg6XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJlY2lzaW9uOiB0LFxuICAgICAgICB1bml0OiBcIm5hbm9zZWNvbmRcIixcbiAgICAgICAgaW5jcmVtZW50OiBNYXRoLnBvdygxMCwgOSAtIHQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImZyYWN0aW9uYWxTZWNvbmREaWdpdHMgbXVzdCBiZSAnYXV0bycgb3IgMCB0aHJvdWdoIDksIG5vdCBcIi5jb25jYXQodCkpO1xuICB9XG59XG52YXIgSGUgPSBTeW1ib2woXCJ+cmVxdWlyZWR+XCIpO1xuZnVuY3Rpb24gR2V0VGVtcG9yYWxVbml0KGUsIHQsIHIsIG8pIHtcbiAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFtdO1xuICB2YXIgYSA9IFtdO1xuICBmb3IgKHZhciBfaTIgPSAwLCBfVWUgPSBVZTsgX2kyIDwgX1VlLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX1VlJF9pID0gX3NsaWNlZFRvQXJyYXkoX1VlW19pMl0sIDMpLFxuICAgICAgX2U3ID0gX1VlJF9pWzFdLFxuICAgICAgX3Q5ID0gX1VlJF9pWzJdO1xuICAgIFwiZGF0ZXRpbWVcIiAhPT0gciAmJiByICE9PSBfdDkgfHwgYS5wdXNoKF9lNyk7XG4gIH1cbiAgYS5wdXNoLmFwcGx5KGEsIF90b0NvbnN1bWFibGVBcnJheShuKSk7XG4gIHZhciBpID0gbztcbiAgaSA9PT0gSGUgPyBpID0gdm9pZCAwIDogdm9pZCAwICE9PSBpICYmIGEucHVzaChpKTtcbiAgdmFyIHMgPSBbXS5jb25jYXQoYSk7XG4gIGZvciAodmFyIF9pMyA9IDAsIF9hMyA9IGE7IF9pMyA8IF9hMy5sZW5ndGg7IF9pMysrKSB7XG4gICAgdmFyIF9lOCA9IF9hM1tfaTNdO1xuICAgIHZhciBfdDEwID0gTGUuZ2V0KF9lOCk7XG4gICAgdm9pZCAwICE9PSBfdDEwICYmIHMucHVzaChfdDEwKTtcbiAgfVxuICB2YXIgbCA9IEdldE9wdGlvbihlLCB0LCBzLCBpKTtcbiAgaWYgKHZvaWQgMCA9PT0gbCAmJiBvID09PSBIZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJcIi5jb25jYXQodCwgXCIgaXMgcmVxdWlyZWRcIikpO1xuICByZXR1cm4gQWUuaGFzKGwpID8gQWUuZ2V0KGwpIDogbDtcbn1cbmZ1bmN0aW9uIFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChlKSB7XG4gIHZhciB0ID0gZS5yZWxhdGl2ZVRvO1xuICBpZiAodm9pZCAwID09PSB0KSByZXR1cm4gdDtcbiAgdmFyIHIsXG4gICAgbyxcbiAgICBuLFxuICAgIGEsXG4gICAgaSxcbiAgICBzLFxuICAgIGwsXG4gICAgZCxcbiAgICBtLFxuICAgIGMsXG4gICAgaCxcbiAgICB1LFxuICAgIFQgPSBcIm9wdGlvblwiLFxuICAgIHAgPSAhMTtcbiAgaWYgKElzT2JqZWN0KHQpKSB7XG4gICAgdmFyIF9JbnRlcnByZXRUZW1wb3JhbERhdDtcbiAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodCkgfHwgSXNUZW1wb3JhbERhdGUodCkpIHJldHVybiB0O1xuICAgIGlmIChJc1RlbXBvcmFsRGF0ZVRpbWUodCkpIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKHQpO1xuICAgIGMgPSBHZXRUZW1wb3JhbENhbGVuZGFyU2xvdFZhbHVlV2l0aElTT0RlZmF1bHQodCk7XG4gICAgdmFyIF9lOSA9IENhbGVuZGFyRmllbGRzKGMsIFtcImRheVwiLCBcImhvdXJcIiwgXCJtaWNyb3NlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCIsIFwibWludXRlXCIsIFwibW9udGhcIiwgXCJtb250aENvZGVcIiwgXCJuYW5vc2Vjb25kXCIsIFwic2Vjb25kXCIsIFwieWVhclwiXSk7XG4gICAgX2U5LnB1c2goXCJ0aW1lWm9uZVwiLCBcIm9mZnNldFwiKTtcbiAgICB2YXIgX3AgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModCwgX2U5LCBbXSksXG4gICAgICBfZiA9IFRlKG51bGwpO1xuICAgIF9mLm92ZXJmbG93ID0gXCJjb25zdHJhaW5cIiwgKF9JbnRlcnByZXRUZW1wb3JhbERhdCA9IEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMoYywgX3AsIF9mKSwgciA9IF9JbnRlcnByZXRUZW1wb3JhbERhdC55ZWFyLCBvID0gX0ludGVycHJldFRlbXBvcmFsRGF0Lm1vbnRoLCBuID0gX0ludGVycHJldFRlbXBvcmFsRGF0LmRheSwgYSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdC5ob3VyLCBpID0gX0ludGVycHJldFRlbXBvcmFsRGF0Lm1pbnV0ZSwgcyA9IF9JbnRlcnByZXRUZW1wb3JhbERhdC5zZWNvbmQsIGwgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQubWlsbGlzZWNvbmQsIGQgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQubWljcm9zZWNvbmQsIG0gPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQubmFub3NlY29uZCksIHUgPSBfcC5vZmZzZXQsIHZvaWQgMCA9PT0gdSAmJiAoVCA9IFwid2FsbFwiKSwgaCA9IF9wLnRpbWVab25lLCB2b2lkIDAgIT09IGggJiYgKGggPSBUb1RlbXBvcmFsVGltZVpvbmVTbG90VmFsdWUoaCkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfUGFyc2VJU09EYXRlVGltZTM7XG4gICAgdmFyIF9lMTAsIF9mMjtcbiAgICBpZiAoKF9QYXJzZUlTT0RhdGVUaW1lMyA9IFBhcnNlSVNPRGF0ZVRpbWUoVG9TdHJpbmcodCkpLCByID0gX1BhcnNlSVNPRGF0ZVRpbWUzLnllYXIsIG8gPSBfUGFyc2VJU09EYXRlVGltZTMubW9udGgsIG4gPSBfUGFyc2VJU09EYXRlVGltZTMuZGF5LCBhID0gX1BhcnNlSVNPRGF0ZVRpbWUzLmhvdXIsIGkgPSBfUGFyc2VJU09EYXRlVGltZTMubWludXRlLCBzID0gX1BhcnNlSVNPRGF0ZVRpbWUzLnNlY29uZCwgbCA9IF9QYXJzZUlTT0RhdGVUaW1lMy5taWxsaXNlY29uZCwgZCA9IF9QYXJzZUlTT0RhdGVUaW1lMy5taWNyb3NlY29uZCwgbSA9IF9QYXJzZUlTT0RhdGVUaW1lMy5uYW5vc2Vjb25kLCBjID0gX1BhcnNlSVNPRGF0ZVRpbWUzLmNhbGVuZGFyLCBfZTEwID0gX1BhcnNlSVNPRGF0ZVRpbWUzLmlhbmFOYW1lLCB1ID0gX1BhcnNlSVNPRGF0ZVRpbWUzLm9mZnNldCwgX2YyID0gX1BhcnNlSVNPRGF0ZVRpbWUzLnopLCBfZTEwKSBoID0gVG9UZW1wb3JhbFRpbWVab25lU2xvdFZhbHVlKF9lMTApLCBfZjIgPyBUID0gXCJleGFjdFwiIDogdSB8fCAoVCA9IFwid2FsbFwiKSwgcCA9ICEwO2Vsc2UgaWYgKF9mMikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJaIGRlc2lnbmF0b3Igbm90IHN1cHBvcnRlZCBmb3IgUGxhaW5EYXRlIHJlbGF0aXZlVG87IGVpdGhlciByZW1vdmUgdGhlIFogb3IgYWRkIGEgYnJhY2tldGVkIHRpbWUgem9uZVwiKTtcbiAgICBpZiAoYyB8fCAoYyA9IFwiaXNvODYwMVwiKSwgIUlzQnVpbHRpbkNhbGVuZGFyKGMpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgY2FsZW5kYXIgaWRlbnRpZmllciBcIi5jb25jYXQoYykpO1xuICAgIGMgPSBBU0NJSUxvd2VyY2FzZShjKTtcbiAgfVxuICBpZiAodm9pZCAwID09PSBoKSByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlKHIsIG8sIG4sIGMpO1xuICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEludGVycHJldElTT0RhdGVUaW1lT2Zmc2V0KHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIFQsIFwib3B0aW9uXCIgPT09IFQgPyBQYXJzZVRpbWVab25lT2Zmc2V0U3RyaW5nKHUpIDogMCwgaCwgXCJjb21wYXRpYmxlXCIsIFwicmVqZWN0XCIsIHApLCBoLCBjKTtcbn1cbmZ1bmN0aW9uIERlZmF1bHRUZW1wb3JhbExhcmdlc3RVbml0KGUsIHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQpIHtcbiAgZm9yICh2YXIgX2k0ID0gMCwgX2FyciA9IFtbXCJ5ZWFyc1wiLCBlXSwgW1wibW9udGhzXCIsIHRdLCBbXCJ3ZWVrc1wiLCByXSwgW1wiZGF5c1wiLCBvXSwgW1wiaG91cnNcIiwgbl0sIFtcIm1pbnV0ZXNcIiwgYV0sIFtcInNlY29uZHNcIiwgaV0sIFtcIm1pbGxpc2Vjb25kc1wiLCBzXSwgW1wibWljcm9zZWNvbmRzXCIsIGxdLCBbXCJuYW5vc2Vjb25kc1wiLCBkXV07IF9pNCA8IF9hcnIubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciBfYXJyJF9pID0gX3NsaWNlZFRvQXJyYXkoX2FycltfaTRdLCAyKSxcbiAgICAgIF9tID0gX2FyciRfaVswXSxcbiAgICAgIF9jID0gX2FyciRfaVsxXTtcbiAgICBpZiAoMCAhPT0gX2MpIHJldHVybiBBZS5nZXQoX20pO1xuICB9XG4gIHJldHVybiBcIm5hbm9zZWNvbmRcIjtcbn1cbmZ1bmN0aW9uIExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhlLCB0KSB7XG4gIHJldHVybiB4ZS5pbmRleE9mKGUpID4geGUuaW5kZXhPZih0KSA/IHQgOiBlO1xufVxuZnVuY3Rpb24gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIHQsIHIpIHtcbiAgdmFyIF9yZWY3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7XG4gICAgICBlbXB0eVNvdXJjZUVycm9yTWVzc2FnZTogXCJubyBzdXBwb3J0ZWQgcHJvcGVydGllcyBmb3VuZFwiXG4gICAgfSxcbiAgICBvID0gX3JlZjcuZW1wdHlTb3VyY2VFcnJvck1lc3NhZ2U7XG4gIHZhciBuID0gVGUobnVsbCk7XG4gIHZhciBhID0gITE7XG4gIHQuc29ydCgpO1xuICB2YXIgX2l0ZXJhdG9yOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHQpLFxuICAgIF9zdGVwOTtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjkucygpOyAhKF9zdGVwOSA9IF9pdGVyYXRvcjkubigpKS5kb25lOykge1xuICAgICAgdmFyIF9vNSA9IF9zdGVwOS52YWx1ZTtcbiAgICAgIHZhciBfdDExID0gZVtfbzVdO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gX3QxMSkgYSA9ICEwLCAkZS5oYXMoX281KSAmJiAoX3QxMSA9ICRlLmdldChfbzUpKF90MTEpKSwgbltfbzVdID0gX3QxMTtlbHNlIGlmIChcInBhcnRpYWxcIiAhPT0gcikge1xuICAgICAgICBpZiAoZWUuY2FsbChyLCBfbzUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVxdWlyZWQgcHJvcGVydHkgJ1wiLmNvbmNhdChfbzUsIFwiJyBtaXNzaW5nIG9yIHVuZGVmaW5lZFwiKSk7XG4gICAgICAgIF90MTEgPSBrZS5nZXQoX281KSwgbltfbzVdID0gX3QxMTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjkuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjkuZigpO1xuICB9XG4gIGlmIChcInBhcnRpYWxcIiA9PT0gciAmJiAhYSkgdGhyb3cgbmV3IFR5cGVFcnJvcihvKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsVGltZVJlY29yZChlKSB7XG4gIHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcImNvbXBsZXRlXCI7XG4gIHZhciByID0gW1wiaG91clwiLCBcIm1pY3Jvc2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIiwgXCJtaW51dGVcIiwgXCJuYW5vc2Vjb25kXCIsIFwic2Vjb25kXCJdLFxuICAgIG8gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZSwgciwgXCJwYXJ0aWFsXCIsIHtcbiAgICAgIGVtcHR5U291cmNlRXJyb3JNZXNzYWdlOiBcImludmFsaWQgdGltZS1saWtlXCJcbiAgICB9KSxcbiAgICBuID0ge307XG4gIGZvciAodmFyIF9pNSA9IDAsIF9yOCA9IHI7IF9pNSA8IF9yOC5sZW5ndGg7IF9pNSsrKSB7XG4gICAgdmFyIF9lMTEgPSBfcjhbX2k1XTtcbiAgICB2YXIgX3I5ID0gcGUobywgX2UxMSk7XG4gICAgdm9pZCAwICE9PSBfcjkgPyBuW19lMTFdID0gX3I5LnZhbHVlIDogXCJjb21wbGV0ZVwiID09PSB0ICYmIChuW19lMTFdID0gMCk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsRGF0ZShlLCB0KSB7XG4gIHZhciByID0gZTtcbiAgaWYgKElzT2JqZWN0KHIpKSB7XG4gICAgaWYgKElzVGVtcG9yYWxEYXRlKHIpKSByZXR1cm4gcjtcbiAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUocikgJiYgKFRvVGVtcG9yYWxPdmVyZmxvdyh0KSwgciA9IEdldFBsYWluRGF0ZVRpbWVGb3IoR2V0U2xvdChyLCBnKSwgR2V0U2xvdChyLCBTKSwgR2V0U2xvdChyLCBwKSkpLCBJc1RlbXBvcmFsRGF0ZVRpbWUocikpIHJldHVybiBUb1RlbXBvcmFsT3ZlcmZsb3codCksIENyZWF0ZVRlbXBvcmFsRGF0ZShHZXRTbG90KHIsIGkpLCBHZXRTbG90KHIsIHMpLCBHZXRTbG90KHIsIGwpLCBHZXRTbG90KHIsIHApKTtcbiAgICB2YXIgX2UxMiA9IEdldFRlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWVXaXRoSVNPRGVmYXVsdChyKTtcbiAgICByZXR1cm4gQ2FsZW5kYXJEYXRlRnJvbUZpZWxkcyhfZTEyLCBQcmVwYXJlVGVtcG9yYWxGaWVsZHMociwgQ2FsZW5kYXJGaWVsZHMoX2UxMiwgW1wiZGF5XCIsIFwibW9udGhcIiwgXCJtb250aENvZGVcIiwgXCJ5ZWFyXCJdKSwgW10pLCB0KTtcbiAgfVxuICBUb1RlbXBvcmFsT3ZlcmZsb3codCk7XG4gIHZhciBfUGFyc2VUZW1wb3JhbERhdGVTdHIgPSBmdW5jdGlvbiBQYXJzZVRlbXBvcmFsRGF0ZVN0cmluZyhlKSB7XG4gICAgICByZXR1cm4gUGFyc2VJU09EYXRlVGltZShlKTtcbiAgICB9KFRvU3RyaW5nKHIpKSxcbiAgICBvID0gX1BhcnNlVGVtcG9yYWxEYXRlU3RyLnllYXIsXG4gICAgbiA9IF9QYXJzZVRlbXBvcmFsRGF0ZVN0ci5tb250aCxcbiAgICBhID0gX1BhcnNlVGVtcG9yYWxEYXRlU3RyLmRheSxcbiAgICBkID0gX1BhcnNlVGVtcG9yYWxEYXRlU3RyLmNhbGVuZGFyLFxuICAgIG0gPSBfUGFyc2VUZW1wb3JhbERhdGVTdHIuejtcbiAgaWYgKG0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiWiBkZXNpZ25hdG9yIG5vdCBzdXBwb3J0ZWQgZm9yIFBsYWluRGF0ZVwiKTtcbiAgaWYgKGQgfHwgKGQgPSBcImlzbzg2MDFcIiksICFJc0J1aWx0aW5DYWxlbmRhcihkKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIGNhbGVuZGFyIGlkZW50aWZpZXIgXCIuY29uY2F0KGQpKTtcbiAgcmV0dXJuIGQgPSBBU0NJSUxvd2VyY2FzZShkKSwgQ3JlYXRlVGVtcG9yYWxEYXRlKG8sIG4sIGEsIGQpO1xufVxuZnVuY3Rpb24gSW50ZXJwcmV0VGVtcG9yYWxEYXRlVGltZUZpZWxkcyhlLCB0LCByKSB7XG4gIHZhciBfUmVndWxhdGVUaW1lO1xuICB2YXIgX1RvVGVtcG9yYWxUaW1lUmVjb3JkID0gVG9UZW1wb3JhbFRpbWVSZWNvcmQodCksXG4gICAgbyA9IF9Ub1RlbXBvcmFsVGltZVJlY29yZC5ob3VyLFxuICAgIG4gPSBfVG9UZW1wb3JhbFRpbWVSZWNvcmQubWludXRlLFxuICAgIGEgPSBfVG9UZW1wb3JhbFRpbWVSZWNvcmQuc2Vjb25kLFxuICAgIGQgPSBfVG9UZW1wb3JhbFRpbWVSZWNvcmQubWlsbGlzZWNvbmQsXG4gICAgbSA9IF9Ub1RlbXBvcmFsVGltZVJlY29yZC5taWNyb3NlY29uZCxcbiAgICBjID0gX1RvVGVtcG9yYWxUaW1lUmVjb3JkLm5hbm9zZWNvbmQ7XG4gIHZhciBoID0gVG9UZW1wb3JhbE92ZXJmbG93KHIpLFxuICAgIHUgPSBDYWxlbmRhckRhdGVGcm9tRmllbGRzKGUsIHQsIHIpLFxuICAgIFQgPSBHZXRTbG90KHUsIGkpLFxuICAgIHAgPSBHZXRTbG90KHUsIHMpLFxuICAgIGYgPSBHZXRTbG90KHUsIGwpO1xuICByZXR1cm4gKF9SZWd1bGF0ZVRpbWUgPSBSZWd1bGF0ZVRpbWUobywgbiwgYSwgZCwgbSwgYywgaCksIG8gPSBfUmVndWxhdGVUaW1lLmhvdXIsIG4gPSBfUmVndWxhdGVUaW1lLm1pbnV0ZSwgYSA9IF9SZWd1bGF0ZVRpbWUuc2Vjb25kLCBkID0gX1JlZ3VsYXRlVGltZS5taWxsaXNlY29uZCwgbSA9IF9SZWd1bGF0ZVRpbWUubWljcm9zZWNvbmQsIGMgPSBfUmVndWxhdGVUaW1lLm5hbm9zZWNvbmQpLCB7XG4gICAgeWVhcjogVCxcbiAgICBtb250aDogcCxcbiAgICBkYXk6IGYsXG4gICAgaG91cjogbyxcbiAgICBtaW51dGU6IG4sXG4gICAgc2Vjb25kOiBhLFxuICAgIG1pbGxpc2Vjb25kOiBkLFxuICAgIG1pY3Jvc2Vjb25kOiBtLFxuICAgIG5hbm9zZWNvbmQ6IGNcbiAgfTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxEYXRlVGltZShlLCB0KSB7XG4gIHZhciByLCBvLCBuLCBhLCBkLCBtLCBjLCBoLCB1LCBUO1xuICBpZiAoSXNPYmplY3QoZSkpIHtcbiAgICBpZiAoSXNUZW1wb3JhbERhdGVUaW1lKGUpKSByZXR1cm4gZTtcbiAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZSkpIHJldHVybiBUb1RlbXBvcmFsT3ZlcmZsb3codCksIEdldFBsYWluRGF0ZVRpbWVGb3IoR2V0U2xvdChlLCBnKSwgR2V0U2xvdChlLCBTKSwgR2V0U2xvdChlLCBwKSk7XG4gICAgaWYgKElzVGVtcG9yYWxEYXRlKGUpKSByZXR1cm4gVG9UZW1wb3JhbE92ZXJmbG93KHQpLCBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKEdldFNsb3QoZSwgaSksIEdldFNsb3QoZSwgcyksIEdldFNsb3QoZSwgbCksIDAsIDAsIDAsIDAsIDAsIDAsIEdldFNsb3QoZSwgcCkpO1xuICAgIFQgPSBHZXRUZW1wb3JhbENhbGVuZGFyU2xvdFZhbHVlV2l0aElTT0RlZmF1bHQoZSk7XG4gICAgdmFyIF9mMyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhlLCBDYWxlbmRhckZpZWxkcyhULCBbXCJkYXlcIiwgXCJob3VyXCIsIFwibWljcm9zZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiLCBcIm1pbnV0ZVwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwibmFub3NlY29uZFwiLCBcInNlY29uZFwiLCBcInllYXJcIl0pLCBbXSk7XG4gICAgdmFyIF9JbnRlcnByZXRUZW1wb3JhbERhdDIgPSBJbnRlcnByZXRUZW1wb3JhbERhdGVUaW1lRmllbGRzKFQsIF9mMywgdCk7XG4gICAgciA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDIueWVhcjtcbiAgICBvID0gX0ludGVycHJldFRlbXBvcmFsRGF0Mi5tb250aDtcbiAgICBuID0gX0ludGVycHJldFRlbXBvcmFsRGF0Mi5kYXk7XG4gICAgYSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDIuaG91cjtcbiAgICBkID0gX0ludGVycHJldFRlbXBvcmFsRGF0Mi5taW51dGU7XG4gICAgbSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDIuc2Vjb25kO1xuICAgIGMgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQyLm1pbGxpc2Vjb25kO1xuICAgIGggPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQyLm1pY3Jvc2Vjb25kO1xuICAgIHUgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQyLm5hbm9zZWNvbmQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9QYXJzZVRlbXBvcmFsRGF0ZVRpbTtcbiAgICB2YXIgX2k2O1xuICAgIGlmIChUb1RlbXBvcmFsT3ZlcmZsb3codCksIChfUGFyc2VUZW1wb3JhbERhdGVUaW0gPSBmdW5jdGlvbiBQYXJzZVRlbXBvcmFsRGF0ZVRpbWVTdHJpbmcoZSkge1xuICAgICAgcmV0dXJuIFBhcnNlSVNPRGF0ZVRpbWUoZSk7XG4gICAgfShUb1N0cmluZyhlKSksIHIgPSBfUGFyc2VUZW1wb3JhbERhdGVUaW0ueWVhciwgbyA9IF9QYXJzZVRlbXBvcmFsRGF0ZVRpbS5tb250aCwgbiA9IF9QYXJzZVRlbXBvcmFsRGF0ZVRpbS5kYXksIGEgPSBfUGFyc2VUZW1wb3JhbERhdGVUaW0uaG91ciwgZCA9IF9QYXJzZVRlbXBvcmFsRGF0ZVRpbS5taW51dGUsIG0gPSBfUGFyc2VUZW1wb3JhbERhdGVUaW0uc2Vjb25kLCBjID0gX1BhcnNlVGVtcG9yYWxEYXRlVGltLm1pbGxpc2Vjb25kLCBoID0gX1BhcnNlVGVtcG9yYWxEYXRlVGltLm1pY3Jvc2Vjb25kLCB1ID0gX1BhcnNlVGVtcG9yYWxEYXRlVGltLm5hbm9zZWNvbmQsIFQgPSBfUGFyc2VUZW1wb3JhbERhdGVUaW0uY2FsZW5kYXIsIF9pNiA9IF9QYXJzZVRlbXBvcmFsRGF0ZVRpbS56KSwgX2k2KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlogZGVzaWduYXRvciBub3Qgc3VwcG9ydGVkIGZvciBQbGFpbkRhdGVUaW1lXCIpO1xuICAgIGlmIChSZWplY3REYXRlVGltZShyLCBvLCBuLCBhLCBkLCBtLCBjLCBoLCB1KSwgVCB8fCAoVCA9IFwiaXNvODYwMVwiKSwgIUlzQnVpbHRpbkNhbGVuZGFyKFQpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgY2FsZW5kYXIgaWRlbnRpZmllciBcIi5jb25jYXQoVCkpO1xuICAgIFQgPSBBU0NJSUxvd2VyY2FzZShUKTtcbiAgfVxuICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZShyLCBvLCBuLCBhLCBkLCBtLCBjLCBoLCB1LCBUKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxEdXJhdGlvbihlKSB7XG4gIGlmIChJc1RlbXBvcmFsRHVyYXRpb24oZSkpIHJldHVybiBlO1xuICB2YXIgX1RvVGVtcG9yYWxEdXJhdGlvblJlID0gVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkKGUpLFxuICAgIHQgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUueWVhcnMsXG4gICAgciA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZS5tb250aHMsXG4gICAgbyA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZS53ZWVrcyxcbiAgICBuID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlLmRheXMsXG4gICAgYSA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZS5ob3VycyxcbiAgICBpID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlLm1pbnV0ZXMsXG4gICAgcyA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZS5zZWNvbmRzLFxuICAgIGwgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUubWlsbGlzZWNvbmRzLFxuICAgIGQgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUubWljcm9zZWNvbmRzLFxuICAgIG0gPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUubmFub3NlY29uZHM7XG4gIHJldHVybiBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIikpKHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0pO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbEluc3RhbnQoZSkge1xuICBpZiAoSXNUZW1wb3JhbEluc3RhbnQoZSkpIHJldHVybiBlO1xuICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZSkpIHtcbiAgICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIikpKEdldFNsb3QoZSwgbikpO1xuICB9XG4gIHZhciB0ID0gUGFyc2VUZW1wb3JhbEluc3RhbnQoVG9TdHJpbmcoZSkpO1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIikpKHQpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbE1vbnRoRGF5KGUsIHQpIHtcbiAgdmFyIHIgPSBlO1xuICBpZiAoSXNPYmplY3QocikpIHtcbiAgICBpZiAoSXNUZW1wb3JhbE1vbnRoRGF5KHIpKSByZXR1cm4gcjtcbiAgICB2YXIgX2UxMywgX282O1xuICAgIGlmIChIYXNTbG90KHIsIHApKSBfZTEzID0gR2V0U2xvdChyLCBwKSwgX282ID0gITE7ZWxzZSB7XG4gICAgICB2YXIgX3QxMiA9IHIuY2FsZW5kYXI7XG4gICAgICBfbzYgPSB2b2lkIDAgPT09IF90MTIsIHZvaWQgMCA9PT0gX3QxMiAmJiAoX3QxMiA9IFwiaXNvODYwMVwiKSwgX2UxMyA9IFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShfdDEyKTtcbiAgICB9XG4gICAgdmFyIF9uMyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhyLCBDYWxlbmRhckZpZWxkcyhfZTEzLCBbXCJkYXlcIiwgXCJtb250aFwiLCBcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0pLCBbXSk7XG4gICAgcmV0dXJuIF9vNiAmJiB2b2lkIDAgIT09IF9uMy5tb250aCAmJiB2b2lkIDAgPT09IF9uMy5tb250aENvZGUgJiYgdm9pZCAwID09PSBfbjMueWVhciAmJiAoX24zLnllYXIgPSAxOTcyKSwgQ2FsZW5kYXJNb250aERheUZyb21GaWVsZHMoX2UxMywgX24zLCB0KTtcbiAgfVxuICBUb1RlbXBvcmFsT3ZlcmZsb3codCk7XG4gIHZhciBfUGFyc2VUZW1wb3JhbE1vbnRoRGEgPSBQYXJzZVRlbXBvcmFsTW9udGhEYXlTdHJpbmcoVG9TdHJpbmcocikpLFxuICAgIG8gPSBfUGFyc2VUZW1wb3JhbE1vbnRoRGEubW9udGgsXG4gICAgbiA9IF9QYXJzZVRlbXBvcmFsTW9udGhEYS5kYXksXG4gICAgYSA9IF9QYXJzZVRlbXBvcmFsTW9udGhEYS5yZWZlcmVuY2VJU09ZZWFyLFxuICAgIGkgPSBfUGFyc2VUZW1wb3JhbE1vbnRoRGEuY2FsZW5kYXI7XG4gIGlmICh2b2lkIDAgPT09IGkgJiYgKGkgPSBcImlzbzg2MDFcIiksICFJc0J1aWx0aW5DYWxlbmRhcihpKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIGNhbGVuZGFyIGlkZW50aWZpZXIgXCIuY29uY2F0KGkpKTtcbiAgaWYgKGkgPSBBU0NJSUxvd2VyY2FzZShpKSwgdm9pZCAwID09PSBhKSByZXR1cm4gUmVqZWN0SVNPRGF0ZSgxOTcyLCBvLCBuKSwgQ3JlYXRlVGVtcG9yYWxNb250aERheShvLCBuLCBpKTtcbiAgcmV0dXJuIENhbGVuZGFyTW9udGhEYXlGcm9tRmllbGRzKGksIENyZWF0ZVRlbXBvcmFsTW9udGhEYXkobywgbiwgaSwgYSkpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbFRpbWUoZSkge1xuICB2YXIgX1BhcnNlVGVtcG9yYWxUaW1lU3RyO1xuICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJjb25zdHJhaW5cIjtcbiAgdmFyIHIsXG4gICAgbyxcbiAgICBuLFxuICAgIGEsXG4gICAgaSxcbiAgICBzLFxuICAgIGwgPSBlO1xuICBpZiAoSXNPYmplY3QobCkpIHtcbiAgICB2YXIgX1RvVGVtcG9yYWxUaW1lUmVjb3JkMiwgX1JlZ3VsYXRlVGltZTI7XG4gICAgaWYgKElzVGVtcG9yYWxUaW1lKGwpKSByZXR1cm4gbDtcbiAgICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUobCkgJiYgKGwgPSBHZXRQbGFpbkRhdGVUaW1lRm9yKEdldFNsb3QobCwgZyksIEdldFNsb3QobCwgUyksIEdldFNsb3QobCwgcCkpKSwgSXNUZW1wb3JhbERhdGVUaW1lKGwpKSB7XG4gICAgICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuUGxhaW5UaW1lJVwiKSkoR2V0U2xvdChsLCBkKSwgR2V0U2xvdChsLCBtKSwgR2V0U2xvdChsLCBjKSwgR2V0U2xvdChsLCBoKSwgR2V0U2xvdChsLCB1KSwgR2V0U2xvdChsLCBUKSk7XG4gICAgfVxuICAgIChfVG9UZW1wb3JhbFRpbWVSZWNvcmQyID0gVG9UZW1wb3JhbFRpbWVSZWNvcmQobCksIHIgPSBfVG9UZW1wb3JhbFRpbWVSZWNvcmQyLmhvdXIsIG8gPSBfVG9UZW1wb3JhbFRpbWVSZWNvcmQyLm1pbnV0ZSwgbiA9IF9Ub1RlbXBvcmFsVGltZVJlY29yZDIuc2Vjb25kLCBhID0gX1RvVGVtcG9yYWxUaW1lUmVjb3JkMi5taWxsaXNlY29uZCwgaSA9IF9Ub1RlbXBvcmFsVGltZVJlY29yZDIubWljcm9zZWNvbmQsIHMgPSBfVG9UZW1wb3JhbFRpbWVSZWNvcmQyLm5hbm9zZWNvbmQpLCAoX1JlZ3VsYXRlVGltZTIgPSBSZWd1bGF0ZVRpbWUociwgbywgbiwgYSwgaSwgcywgdCksIHIgPSBfUmVndWxhdGVUaW1lMi5ob3VyLCBvID0gX1JlZ3VsYXRlVGltZTIubWludXRlLCBuID0gX1JlZ3VsYXRlVGltZTIuc2Vjb25kLCBhID0gX1JlZ3VsYXRlVGltZTIubWlsbGlzZWNvbmQsIGkgPSBfUmVndWxhdGVUaW1lMi5taWNyb3NlY29uZCwgcyA9IF9SZWd1bGF0ZVRpbWUyLm5hbm9zZWNvbmQpO1xuICB9IGVsc2UgKF9QYXJzZVRlbXBvcmFsVGltZVN0ciA9IGZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxUaW1lU3RyaW5nKGUpIHtcbiAgICB2YXIgdCA9IHouZXhlYyhlKTtcbiAgICB2YXIgciwgbywgbiwgYSwgaSwgcywgbDtcbiAgICBpZiAodCkge1xuICAgICAgciA9IFRvSW50ZWdlck9ySW5maW5pdHkodFsxXSksIG8gPSBUb0ludGVnZXJPckluZmluaXR5KHRbMl0gfHwgdFs1XSksIG4gPSBUb0ludGVnZXJPckluZmluaXR5KHRbM10gfHwgdFs2XSksIDYwID09PSBuICYmIChuID0gNTkpO1xuICAgICAgdmFyIF9lMTQgPSAodFs0XSB8fCB0WzddKSArIFwiMDAwMDAwMDAwXCI7XG4gICAgICBhID0gVG9JbnRlZ2VyT3JJbmZpbml0eShfZTE0LnNsaWNlKDAsIDMpKSwgaSA9IFRvSW50ZWdlck9ySW5maW5pdHkoX2UxNC5zbGljZSgzLCA2KSksIHMgPSBUb0ludGVnZXJPckluZmluaXR5KF9lMTQuc2xpY2UoNiwgOSkpLCBsID0gdFsxNF07XG4gICAgICB2YXIgX2l0ZXJhdG9yMTAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsLm1hdGNoQWxsKEgpKSxcbiAgICAgICAgX3N0ZXAxMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTAucygpOyAhKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMTAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDEwLnZhbHVlLCA0KSxcbiAgICAgICAgICAgIF9lMTUgPSBfc3RlcDEwJHZhbHVlWzFdLFxuICAgICAgICAgICAgX3QxMyA9IF9zdGVwMTAkdmFsdWVbMl0sXG4gICAgICAgICAgICBfcjEwID0gX3N0ZXAxMCR2YWx1ZVszXTtcbiAgICAgICAgICBpZiAoXCJ1LWNhXCIgIT09IF90MTMgJiYgXCIhXCIgPT09IF9lMTUpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5yZWNvZ25pemVkIGFubm90YXRpb246ICFcIi5jb25jYXQoX3QxMywgXCI9XCIpLmNvbmNhdChfcjEwKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxMC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxMC5mKCk7XG4gICAgICB9XG4gICAgICBpZiAodFs4XSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJaIGRlc2lnbmF0b3Igbm90IHN1cHBvcnRlZCBmb3IgUGxhaW5UaW1lXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX1BhcnNlSVNPRGF0ZVRpbWU0O1xuICAgICAgdmFyIF90MTQsIF9sO1xuICAgICAgaWYgKChfUGFyc2VJU09EYXRlVGltZTQgPSBQYXJzZUlTT0RhdGVUaW1lKGUpLCBfbCA9IF9QYXJzZUlTT0RhdGVUaW1lNC5oYXNUaW1lLCByID0gX1BhcnNlSVNPRGF0ZVRpbWU0LmhvdXIsIG8gPSBfUGFyc2VJU09EYXRlVGltZTQubWludXRlLCBuID0gX1BhcnNlSVNPRGF0ZVRpbWU0LnNlY29uZCwgYSA9IF9QYXJzZUlTT0RhdGVUaW1lNC5taWxsaXNlY29uZCwgaSA9IF9QYXJzZUlTT0RhdGVUaW1lNC5taWNyb3NlY29uZCwgcyA9IF9QYXJzZUlTT0RhdGVUaW1lNC5uYW5vc2Vjb25kLCBfdDE0ID0gX1BhcnNlSVNPRGF0ZVRpbWU0LnopLCAhX2wpIHRocm93IG5ldyBSYW5nZUVycm9yKFwidGltZSBpcyBtaXNzaW5nIGluIHN0cmluZzogXCIuY29uY2F0KGUpKTtcbiAgICAgIGlmIChfdDE0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlogZGVzaWduYXRvciBub3Qgc3VwcG9ydGVkIGZvciBQbGFpblRpbWVcIik7XG4gICAgfVxuICAgIGlmICgvW3RUIF1bMC05XVswLTldLy50ZXN0KGUpKSByZXR1cm4ge1xuICAgICAgaG91cjogcixcbiAgICAgIG1pbnV0ZTogbyxcbiAgICAgIHNlY29uZDogbixcbiAgICAgIG1pbGxpc2Vjb25kOiBhLFxuICAgICAgbWljcm9zZWNvbmQ6IGksXG4gICAgICBuYW5vc2Vjb25kOiBzXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgdmFyIF9QYXJzZVRlbXBvcmFsTW9udGhEYTIgPSBQYXJzZVRlbXBvcmFsTW9udGhEYXlTdHJpbmcoZSksXG4gICAgICAgIF90MTUgPSBfUGFyc2VUZW1wb3JhbE1vbnRoRGEyLm1vbnRoLFxuICAgICAgICBfcjExID0gX1BhcnNlVGVtcG9yYWxNb250aERhMi5kYXk7XG4gICAgICBSZWplY3RJU09EYXRlKDE5NzIsIF90MTUsIF9yMTEpO1xuICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgX1BhcnNlVGVtcG9yYWxZZWFyTW9uID0gUGFyc2VUZW1wb3JhbFllYXJNb250aFN0cmluZyhlKSxcbiAgICAgICAgICBfdDE2ID0gX1BhcnNlVGVtcG9yYWxZZWFyTW9uLnllYXIsXG4gICAgICAgICAgX3IxMiA9IF9QYXJzZVRlbXBvcmFsWWVhck1vbi5tb250aDtcbiAgICAgICAgUmVqZWN0SVNPRGF0ZShfdDE2LCBfcjEyLCAxKTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaG91cjogcixcbiAgICAgICAgICBtaW51dGU6IG8sXG4gICAgICAgICAgc2Vjb25kOiBuLFxuICAgICAgICAgIG1pbGxpc2Vjb25kOiBhLFxuICAgICAgICAgIG1pY3Jvc2Vjb25kOiBpLFxuICAgICAgICAgIG5hbm9zZWNvbmQ6IHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIElTTyA4NjAxIHRpbWUtb25seSBzdHJpbmcgXCIuY29uY2F0KGUsIFwiOyBtYXkgbmVlZCBhIFQgcHJlZml4XCIpKTtcbiAgfShUb1N0cmluZyhsKSksIHIgPSBfUGFyc2VUZW1wb3JhbFRpbWVTdHIuaG91ciwgbyA9IF9QYXJzZVRlbXBvcmFsVGltZVN0ci5taW51dGUsIG4gPSBfUGFyc2VUZW1wb3JhbFRpbWVTdHIuc2Vjb25kLCBhID0gX1BhcnNlVGVtcG9yYWxUaW1lU3RyLm1pbGxpc2Vjb25kLCBpID0gX1BhcnNlVGVtcG9yYWxUaW1lU3RyLm1pY3Jvc2Vjb25kLCBzID0gX1BhcnNlVGVtcG9yYWxUaW1lU3RyLm5hbm9zZWNvbmQpLCBSZWplY3RUaW1lKHIsIG8sIG4sIGEsIGksIHMpO1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuUGxhaW5UaW1lJVwiKSkociwgbywgbiwgYSwgaSwgcyk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsWWVhck1vbnRoKGUsIHQpIHtcbiAgaWYgKElzT2JqZWN0KGUpKSB7XG4gICAgaWYgKElzVGVtcG9yYWxZZWFyTW9udGgoZSkpIHJldHVybiBlO1xuICAgIHZhciBfcjEzID0gR2V0VGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZVdpdGhJU09EZWZhdWx0KGUpO1xuICAgIHJldHVybiBDYWxlbmRhclllYXJNb250aEZyb21GaWVsZHMoX3IxMywgUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIENhbGVuZGFyRmllbGRzKF9yMTMsIFtcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwieWVhclwiXSksIFtdKSwgdCk7XG4gIH1cbiAgVG9UZW1wb3JhbE92ZXJmbG93KHQpO1xuICB2YXIgX1BhcnNlVGVtcG9yYWxZZWFyTW9uMiA9IFBhcnNlVGVtcG9yYWxZZWFyTW9udGhTdHJpbmcoVG9TdHJpbmcoZSkpLFxuICAgIHIgPSBfUGFyc2VUZW1wb3JhbFllYXJNb24yLnllYXIsXG4gICAgbyA9IF9QYXJzZVRlbXBvcmFsWWVhck1vbjIubW9udGgsXG4gICAgbiA9IF9QYXJzZVRlbXBvcmFsWWVhck1vbjIucmVmZXJlbmNlSVNPRGF5LFxuICAgIGEgPSBfUGFyc2VUZW1wb3JhbFllYXJNb24yLmNhbGVuZGFyO1xuICBpZiAodm9pZCAwID09PSBhICYmIChhID0gXCJpc284NjAxXCIpLCAhSXNCdWlsdGluQ2FsZW5kYXIoYSkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCBjYWxlbmRhciBpZGVudGlmaWVyIFwiLmNvbmNhdChhKSk7XG4gIGlmIChhID0gQVNDSUlMb3dlcmNhc2UoYSksIHZvaWQgMCA9PT0gbikgcmV0dXJuIFJlamVjdElTT0RhdGUociwgbywgMSksIENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKHIsIG8sIGEpO1xuICByZXR1cm4gQ2FsZW5kYXJZZWFyTW9udGhGcm9tRmllbGRzKGEsIENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKHIsIG8sIGEsIG4pKTtcbn1cbmZ1bmN0aW9uIEludGVycHJldElTT0RhdGVUaW1lT2Zmc2V0KHQsIHIsIG8sIGksIHMsIGwsIGQsIG0sIGMsIGgsIHUsIFQsIHAsIGYsIHkpIHtcbiAgdmFyIEkgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKSkodCwgciwgbywgaSwgcywgbCwgZCwgbSwgYyk7XG4gIGlmIChcIndhbGxcIiA9PT0gaCB8fCBcImlnbm9yZVwiID09PSBmKSB7XG4gICAgcmV0dXJuIEdldFNsb3QoR2V0SW5zdGFudEZvcihULCBJLCBwKSwgbik7XG4gIH1cbiAgaWYgKFwiZXhhY3RcIiA9PT0gaCB8fCBcInVzZVwiID09PSBmKSB7XG4gICAgdmFyIF9uNCA9IEdldFVUQ0Vwb2NoTmFub3NlY29uZHModCwgciwgbywgaSwgcywgbCwgZCwgbSwgYyk7XG4gICAgaWYgKG51bGwgPT09IF9uNCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJab25lZERhdGVUaW1lIG91dHNpZGUgb2Ygc3VwcG9ydGVkIHJhbmdlXCIpO1xuICAgIHJldHVybiBfbjQgLSBCaWdJbnQodSk7XG4gIH1cbiAgdmFyIFMgPSBHZXRQb3NzaWJsZUluc3RhbnRzRm9yKFQsIEkpO1xuICB2YXIgX2l0ZXJhdG9yMTEgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihTKSxcbiAgICBfc3RlcDExO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMTEucygpOyAhKF9zdGVwMTEgPSBfaXRlcmF0b3IxMS5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3QxOCA9IF9zdGVwMTEudmFsdWU7XG4gICAgICB2YXIgX3IxNCA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKFQsIF90MTgpLFxuICAgICAgICBfbzcgPSBOdW1iZXIoUm91bmROdW1iZXJUb0luY3JlbWVudChCaWdJbnQoX3IxNCksIGJlLCBcImhhbGZFeHBhbmRcIikpO1xuICAgICAgaWYgKF9yMTQgPT09IHUgfHwgeSAmJiBfbzcgPT09IHUpIHJldHVybiBHZXRTbG90KF90MTgsIG4pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMTEuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjExLmYoKTtcbiAgfVxuICBpZiAoXCJyZWplY3RcIiA9PT0gZikge1xuICAgIHZhciBfZTE2ID0gRm9ybWF0VGltZVpvbmVPZmZzZXRTdHJpbmcodSksXG4gICAgICBfdDE3ID0gSXNUZW1wb3JhbFRpbWVab25lKFQpID8gR2V0U2xvdChULCBhKSA6IFwidGltZSB6b25lXCI7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPZmZzZXQgXCIuY29uY2F0KF9lMTYsIFwiIGlzIGludmFsaWQgZm9yIFwiKS5jb25jYXQoSS50b1N0cmluZygpLCBcIiBpbiBcIikuY29uY2F0KF90MTcpKTtcbiAgfVxuICByZXR1cm4gR2V0U2xvdChEaXNhbWJpZ3VhdGVQb3NzaWJsZUluc3RhbnRzKFMsIFQsIEksIHApLCBuKTtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxab25lZERhdGVUaW1lKGUsIHQpIHtcbiAgdmFyIHIsXG4gICAgbyxcbiAgICBuLFxuICAgIGEsXG4gICAgaSxcbiAgICBzLFxuICAgIGwsXG4gICAgZCxcbiAgICBtLFxuICAgIGMsXG4gICAgaCxcbiAgICB1LFxuICAgIFQsXG4gICAgcCxcbiAgICBmID0gITEsXG4gICAgeSA9IFwib3B0aW9uXCI7XG4gIGlmIChJc09iamVjdChlKSkge1xuICAgIHZhciBfSW50ZXJwcmV0VGVtcG9yYWxEYXQzO1xuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShlKSkgcmV0dXJuIGU7XG4gICAgdSA9IEdldFRlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWVXaXRoSVNPRGVmYXVsdChlKTtcbiAgICB2YXIgX2Y0ID0gQ2FsZW5kYXJGaWVsZHModSwgW1wiZGF5XCIsIFwiaG91clwiLCBcIm1pY3Jvc2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIiwgXCJtaW51dGVcIiwgXCJtb250aFwiLCBcIm1vbnRoQ29kZVwiLCBcIm5hbm9zZWNvbmRcIiwgXCJzZWNvbmRcIiwgXCJ5ZWFyXCJdKTtcbiAgICBfZjQucHVzaChcInRpbWVab25lXCIsIFwib2Zmc2V0XCIpO1xuICAgIHZhciBfSSA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhlLCBfZjQsIFtcInRpbWVab25lXCJdKTtcbiAgICBjID0gVG9UZW1wb3JhbFRpbWVab25lU2xvdFZhbHVlKF9JLnRpbWVab25lKSwgaCA9IF9JLm9mZnNldCwgdm9pZCAwID09PSBoICYmICh5ID0gXCJ3YWxsXCIpLCBUID0gVG9UZW1wb3JhbERpc2FtYmlndWF0aW9uKHQpLCBwID0gVG9UZW1wb3JhbE9mZnNldCh0LCBcInJlamVjdFwiKSwgKF9JbnRlcnByZXRUZW1wb3JhbERhdDMgPSBJbnRlcnByZXRUZW1wb3JhbERhdGVUaW1lRmllbGRzKHUsIF9JLCB0KSwgciA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDMueWVhciwgbyA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDMubW9udGgsIG4gPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQzLmRheSwgYSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDMuaG91ciwgaSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDMubWludXRlLCBzID0gX0ludGVycHJldFRlbXBvcmFsRGF0My5zZWNvbmQsIGwgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQzLm1pbGxpc2Vjb25kLCBkID0gX0ludGVycHJldFRlbXBvcmFsRGF0My5taWNyb3NlY29uZCwgbSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDMubmFub3NlY29uZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9QYXJzZVRlbXBvcmFsWm9uZWREYTtcbiAgICB2YXIgX0kyLCBfUztcbiAgICBpZiAoKF9QYXJzZVRlbXBvcmFsWm9uZWREYSA9IGZ1bmN0aW9uIFBhcnNlVGVtcG9yYWxab25lZERhdGVUaW1lU3RyaW5nKGUpIHtcbiAgICAgIHZhciB0ID0gUGFyc2VJU09EYXRlVGltZShlKTtcbiAgICAgIGlmICghdC5pYW5hTmFtZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZW1wb3JhbC5ab25lZERhdGVUaW1lIHJlcXVpcmVzIGEgdGltZSB6b25lIElEIGluIGJyYWNrZXRzXCIpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfShUb1N0cmluZyhlKSksIHIgPSBfUGFyc2VUZW1wb3JhbFpvbmVkRGEueWVhciwgbyA9IF9QYXJzZVRlbXBvcmFsWm9uZWREYS5tb250aCwgbiA9IF9QYXJzZVRlbXBvcmFsWm9uZWREYS5kYXksIGEgPSBfUGFyc2VUZW1wb3JhbFpvbmVkRGEuaG91ciwgaSA9IF9QYXJzZVRlbXBvcmFsWm9uZWREYS5taW51dGUsIHMgPSBfUGFyc2VUZW1wb3JhbFpvbmVkRGEuc2Vjb25kLCBsID0gX1BhcnNlVGVtcG9yYWxab25lZERhLm1pbGxpc2Vjb25kLCBkID0gX1BhcnNlVGVtcG9yYWxab25lZERhLm1pY3Jvc2Vjb25kLCBtID0gX1BhcnNlVGVtcG9yYWxab25lZERhLm5hbm9zZWNvbmQsIF9JMiA9IF9QYXJzZVRlbXBvcmFsWm9uZWREYS5pYW5hTmFtZSwgaCA9IF9QYXJzZVRlbXBvcmFsWm9uZWREYS5vZmZzZXQsIF9TID0gX1BhcnNlVGVtcG9yYWxab25lZERhLnosIHUgPSBfUGFyc2VUZW1wb3JhbFpvbmVkRGEuY2FsZW5kYXIpLCBjID0gVG9UZW1wb3JhbFRpbWVab25lU2xvdFZhbHVlKF9JMiksIF9TID8geSA9IFwiZXhhY3RcIiA6IGggfHwgKHkgPSBcIndhbGxcIiksIHUgfHwgKHUgPSBcImlzbzg2MDFcIiksICFJc0J1aWx0aW5DYWxlbmRhcih1KSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbnZhbGlkIGNhbGVuZGFyIGlkZW50aWZpZXIgXCIuY29uY2F0KHUpKTtcbiAgICB1ID0gQVNDSUlMb3dlcmNhc2UodSksIGYgPSAhMCwgVCA9IFRvVGVtcG9yYWxEaXNhbWJpZ3VhdGlvbih0KSwgcCA9IFRvVGVtcG9yYWxPZmZzZXQodCwgXCJyZWplY3RcIiksIFRvVGVtcG9yYWxPdmVyZmxvdyh0KTtcbiAgfVxuICB2YXIgSSA9IDA7XG4gIFwib3B0aW9uXCIgPT09IHkgJiYgKEkgPSBQYXJzZVRpbWVab25lT2Zmc2V0U3RyaW5nKGgpKTtcbiAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShJbnRlcnByZXRJU09EYXRlVGltZU9mZnNldChyLCBvLCBuLCBhLCBpLCBzLCBsLCBkLCBtLCB5LCBJLCBjLCBULCBwLCBmKSwgYywgdSk7XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbERhdGVTbG90cyhlLCB0LCByLCBvLCBuKSB7XG4gIFJlamVjdElTT0RhdGUodCwgciwgbyksIFJlamVjdERhdGVSYW5nZSh0LCByLCBvKSwgTihlKSwgU2V0U2xvdChlLCBpLCB0KSwgU2V0U2xvdChlLCBzLCByKSwgU2V0U2xvdChlLCBsLCBvKSwgU2V0U2xvdChlLCBwLCBuKSwgU2V0U2xvdChlLCBmLCAhMCk7XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbERhdGUoZSwgdCwgcikge1xuICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJpc284NjAxXCI7XG4gIHZhciBuID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlBsYWluRGF0ZSVcIiksXG4gICAgYSA9IFRlKG4ucHJvdG90eXBlKTtcbiAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVNsb3RzKGEsIGUsIHQsIHIsIG8pLCBhO1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZVNsb3RzKGUsIHQsIHIsIG8sIG4sIGEsIGYsIHksIEksIFMsIGcpIHtcbiAgUmVqZWN0RGF0ZVRpbWUodCwgciwgbywgbiwgYSwgZiwgeSwgSSwgUyksIFJlamVjdERhdGVUaW1lUmFuZ2UodCwgciwgbywgbiwgYSwgZiwgeSwgSSwgUyksIE4oZSksIFNldFNsb3QoZSwgaSwgdCksIFNldFNsb3QoZSwgcywgciksIFNldFNsb3QoZSwgbCwgbyksIFNldFNsb3QoZSwgZCwgbiksIFNldFNsb3QoZSwgbSwgYSksIFNldFNsb3QoZSwgYywgZiksIFNldFNsb3QoZSwgaCwgeSksIFNldFNsb3QoZSwgdSwgSSksIFNldFNsb3QoZSwgVCwgUyksIFNldFNsb3QoZSwgcCwgZyk7XG59XG5mdW5jdGlvbiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKGUsIHQsIHIsIG8sIG4sIGEsIGksIHMsIGwpIHtcbiAgdmFyIGQgPSBhcmd1bWVudHMubGVuZ3RoID4gOSAmJiBhcmd1bWVudHNbOV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s5XSA6IFwiaXNvODYwMVwiO1xuICB2YXIgbSA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKSxcbiAgICBjID0gVGUobS5wcm90b3R5cGUpO1xuICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZVNsb3RzKGMsIGUsIHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQpLCBjO1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxNb250aERheVNsb3RzKGUsIHQsIHIsIG8sIG4pIHtcbiAgUmVqZWN0SVNPRGF0ZShuLCB0LCByKSwgUmVqZWN0RGF0ZVJhbmdlKG4sIHQsIHIpLCBOKGUpLCBTZXRTbG90KGUsIHMsIHQpLCBTZXRTbG90KGUsIGwsIHIpLCBTZXRTbG90KGUsIGksIG4pLCBTZXRTbG90KGUsIHAsIG8pLCBTZXRTbG90KGUsIEksICEwKTtcbn1cbmZ1bmN0aW9uIENyZWF0ZVRlbXBvcmFsTW9udGhEYXkoZSwgdCkge1xuICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJpc284NjAxXCI7XG4gIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxOTcyO1xuICB2YXIgbiA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbk1vbnRoRGF5JVwiKSxcbiAgICBhID0gVGUobi5wcm90b3R5cGUpO1xuICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxNb250aERheVNsb3RzKGEsIGUsIHQsIHIsIG8pLCBhO1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxZZWFyTW9udGhTbG90cyhlLCB0LCByLCBvLCBuKSB7XG4gIFJlamVjdElTT0RhdGUodCwgciwgbiksIGZ1bmN0aW9uIFJlamVjdFllYXJNb250aFJhbmdlKGUsIHQpIHtcbiAgICBSZWplY3RUb1JhbmdlKGUsIEZlLCBZZSksIGUgPT09IEZlID8gUmVqZWN0VG9SYW5nZSh0LCA0LCAxMikgOiBlID09PSBZZSAmJiBSZWplY3RUb1JhbmdlKHQsIDEsIDkpO1xuICB9KHQsIHIpLCBOKGUpLCBTZXRTbG90KGUsIGksIHQpLCBTZXRTbG90KGUsIHMsIHIpLCBTZXRTbG90KGUsIGwsIG4pLCBTZXRTbG90KGUsIHAsIG8pLCBTZXRTbG90KGUsIHksICEwKTtcbn1cbmZ1bmN0aW9uIENyZWF0ZVRlbXBvcmFsWWVhck1vbnRoKGUsIHQpIHtcbiAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiaXNvODYwMVwiO1xuICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTtcbiAgdmFyIG4gPSBHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuUGxhaW5ZZWFyTW9udGglXCIpLFxuICAgIGEgPSBUZShuLnByb3RvdHlwZSk7XG4gIHJldHVybiBDcmVhdGVUZW1wb3JhbFllYXJNb250aFNsb3RzKGEsIGUsIHQsIHIsIG8pLCBhO1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lU2xvdHMoZSwgdCwgciwgbykge1xuICBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHModCksIE4oZSksIFNldFNsb3QoZSwgbiwgdCksIFNldFNsb3QoZSwgZywgciksIFNldFNsb3QoZSwgcCwgbyk7XG4gIHZhciBhID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIikpKEdldFNsb3QoZSwgbikpO1xuICBTZXRTbG90KGUsIFMsIGEpO1xufVxuZnVuY3Rpb24gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKGUsIHQpIHtcbiAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiaXNvODYwMVwiO1xuICB2YXIgbyA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5ab25lZERhdGVUaW1lJVwiKSxcbiAgICBuID0gVGUoby5wcm90b3R5cGUpO1xuICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lU2xvdHMobiwgZSwgdCwgciksIG47XG59XG5mdW5jdGlvbiBDYWxlbmRhckZpZWxkcyhlLCB0KSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9yMTUgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZmllbGRzJVwiKSwgX3IxNSwgW3RdKTtcbiAgfVxuICB2YXIgciA9IENhbGwoR2V0TWV0aG9kKGUsIFwiZmllbGRzXCIpLCBlLCBbdF0pLFxuICAgIG8gPSBbXTtcbiAgdmFyIF9pdGVyYXRvcjEyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIociksXG4gICAgX3N0ZXAxMjtcbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjEyLnMoKTsgIShfc3RlcDEyID0gX2l0ZXJhdG9yMTIubigpKS5kb25lOykge1xuICAgICAgdmFyIF9lMTcgPSBfc3RlcDEyLnZhbHVlO1xuICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIF9lMTcpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJiYWQgcmV0dXJuIGZyb20gY2FsZW5kYXIuZmllbGRzKClcIik7XG4gICAgICB0ZS5jYWxsKG8sIF9lMTcpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMTIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjEyLmYoKTtcbiAgfVxuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIENhbGVuZGFyTWVyZ2VGaWVsZHMoZSwgdCwgcikge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfbzggPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUubWVyZ2VGaWVsZHMlXCIpLCBfbzgsIFt0LCByXSk7XG4gIH1cbiAgdmFyIG8gPSBDYWxsKEdldE1ldGhvZChlLCBcIm1lcmdlRmllbGRzXCIpLCBlLCBbdCwgcl0pO1xuICBpZiAoIUlzT2JqZWN0KG8pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYmFkIHJldHVybiBmcm9tIGNhbGVuZGFyLm1lcmdlRmllbGRzKClcIik7XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXRlQWRkKGUsIHQsIHIsIG8sIG4pIHtcbiAgdmFyIGEgPSBuO1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfbjUgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZGF0ZUFkZCVcIiksIF9uNSwgW3QsIHIsIG9dKTtcbiAgfVxuICB2b2lkIDAgPT09IGEgJiYgKGEgPSBHZXRNZXRob2QoZSwgXCJkYXRlQWRkXCIpKTtcbiAgdmFyIGkgPSBmZShhLCBlLCBbdCwgciwgb10pO1xuICBpZiAoIUlzVGVtcG9yYWxEYXRlKGkpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZXN1bHRcIik7XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXRlVW50aWwoZSwgdCwgciwgbywgbikge1xuICB2YXIgYSA9IG47XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9uNiA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5kYXRlVW50aWwlXCIpLCBfbjYsIFt0LCByLCBvXSk7XG4gIH1cbiAgdm9pZCAwID09PSBhICYmIChhID0gR2V0TWV0aG9kKGUsIFwiZGF0ZVVudGlsXCIpKTtcbiAgdmFyIGkgPSBmZShhLCBlLCBbdCwgciwgb10pO1xuICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbihpKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVzdWx0XCIpO1xuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyWWVhcihlLCB0KSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9yMTYgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUueWVhciVcIiksIF9yMTYsIFt0XSk7XG4gIH1cbiAgdmFyIHIgPSBDYWxsKEdldE1ldGhvZChlLCBcInllYXJcIiksIGUsIFt0XSk7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgeWVhciByZXN1bHQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIocikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2FsZW5kYXIgeWVhciByZXN1bHQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyTW9udGgoZSwgdCkge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfcjE3ID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLm1vbnRoJVwiKSwgX3IxNywgW3RdKTtcbiAgfVxuICB2YXIgciA9IENhbGwoR2V0TWV0aG9kKGUsIFwibW9udGhcIiksIGUsIFt0XSk7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgbW9udGggcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIocikgfHwgciA8IDEpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2FsZW5kYXIgbW9udGggcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyTW9udGhDb2RlKGUsIHQpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICB2YXIgX3IxOCA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5tb250aENvZGUlXCIpLCBfcjE4LCBbdF0pO1xuICB9XG4gIHZhciByID0gQ2FsbChHZXRNZXRob2QoZSwgXCJtb250aENvZGVcIiksIGUsIFt0XSk7XG4gIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgbW9udGhDb2RlIHJlc3VsdCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5KGUsIHQpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICB2YXIgX3IxOSA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5kYXklXCIpLCBfcjE5LCBbdF0pO1xuICB9XG4gIHZhciByID0gQ2FsbChHZXRNZXRob2QoZSwgXCJkYXlcIiksIGUsIFt0XSk7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgZGF5IHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgaWYgKCFJc0ludGVncmFsTnVtYmVyKHIpIHx8IHIgPCAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbGVuZGFyIGRheSByZXN1bHQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJFcmEoZSwgdCkge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfcjIwID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmVyYSVcIiksIF9yMjAsIFt0XSk7XG4gIH1cbiAgdmFyIHIgPSBDYWxsKEdldE1ldGhvZChlLCBcImVyYVwiKSwgZSwgW3RdKTtcbiAgaWYgKHZvaWQgMCA9PT0gcikgcmV0dXJuIHI7XG4gIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgZXJhIHJlc3VsdCBtdXN0IGJlIGEgc3RyaW5nIG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDYWxlbmRhckVyYVllYXIoZSwgdCkge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfcjIxID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmVyYVllYXIlXCIpLCBfcjIxLCBbdF0pO1xuICB9XG4gIHZhciByID0gQ2FsbChHZXRNZXRob2QoZSwgXCJlcmFZZWFyXCIpLCBlLCBbdF0pO1xuICBpZiAodm9pZCAwID09PSByKSByZXR1cm4gcjtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxlbmRhciBlcmFZZWFyIHJlc3VsdCBtdXN0IGJlIGFuIGludGVnZXIgb3IgdW5kZWZpbmVkXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIocikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2FsZW5kYXIgZXJhWWVhciByZXN1bHQgbXVzdCBiZSBhbiBpbnRlZ2VyIG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDYWxlbmRhckRheU9mV2VlayhlLCB0KSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9yMjIgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZGF5T2ZXZWVrJVwiKSwgX3IyMiwgW3RdKTtcbiAgfVxuICB2YXIgciA9IENhbGwoR2V0TWV0aG9kKGUsIFwiZGF5T2ZXZWVrXCIpLCBlLCBbdF0pO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGVuZGFyIGRheU9mV2VlayByZXN1bHQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIGlmICghSXNJbnRlZ3JhbE51bWJlcihyKSB8fCByIDwgMSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJjYWxlbmRhciBkYXlPZldlZWsgcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5T2ZZZWFyKGUsIHQpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICB2YXIgX3IyMyA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5kYXlPZlllYXIlXCIpLCBfcjIzLCBbdF0pO1xuICB9XG4gIHZhciByID0gQ2FsbChHZXRNZXRob2QoZSwgXCJkYXlPZlllYXJcIiksIGUsIFt0XSk7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgZGF5T2ZZZWFyIHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgaWYgKCFJc0ludGVncmFsTnVtYmVyKHIpIHx8IHIgPCAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbGVuZGFyIGRheU9mWWVhciByZXN1bHQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJXZWVrT2ZZZWFyKGUsIHQpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICB2YXIgX3IyNCA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS53ZWVrT2ZZZWFyJVwiKSwgX3IyNCwgW3RdKTtcbiAgfVxuICB2YXIgciA9IENhbGwoR2V0TWV0aG9kKGUsIFwid2Vla09mWWVhclwiKSwgZSwgW3RdKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxlbmRhciB3ZWVrT2ZZZWFyIHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgaWYgKCFJc0ludGVncmFsTnVtYmVyKHIpIHx8IHIgPCAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbGVuZGFyIHdlZWtPZlllYXIgcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyWWVhck9mV2VlayhlLCB0KSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9yMjUgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUueWVhck9mV2VlayVcIiksIF9yMjUsIFt0XSk7XG4gIH1cbiAgdmFyIHIgPSBDYWxsKEdldE1ldGhvZChlLCBcInllYXJPZldlZWtcIiksIGUsIFt0XSk7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgeWVhck9mV2VlayByZXN1bHQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIocikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2FsZW5kYXIgeWVhck9mV2VlayByZXN1bHQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIENhbGVuZGFyRGF5c0luV2VlayhlLCB0KSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9yMjYgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZGF5c0luV2VlayVcIiksIF9yMjYsIFt0XSk7XG4gIH1cbiAgdmFyIHIgPSBDYWxsKEdldE1ldGhvZChlLCBcImRheXNJbldlZWtcIiksIGUsIFt0XSk7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIgZGF5c0luV2VlayByZXN1bHQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIGlmICghSXNJbnRlZ3JhbE51bWJlcihyKSB8fCByIDwgMSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJjYWxlbmRhciBkYXlzSW5XZWVrIHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDYWxlbmRhckRheXNJbk1vbnRoKGUsIHQpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICB2YXIgX3IyNyA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5kYXlzSW5Nb250aCVcIiksIF9yMjcsIFt0XSk7XG4gIH1cbiAgdmFyIHIgPSBDYWxsKEdldE1ldGhvZChlLCBcImRheXNJbk1vbnRoXCIpLCBlLCBbdF0pO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGVuZGFyIGRheXNJbk1vbnRoIHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgaWYgKCFJc0ludGVncmFsTnVtYmVyKHIpIHx8IHIgPCAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbGVuZGFyIGRheXNJbk1vbnRoIHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDYWxlbmRhckRheXNJblllYXIoZSwgdCkge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfcjI4ID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRheXNJblllYXIlXCIpLCBfcjI4LCBbdF0pO1xuICB9XG4gIHZhciByID0gQ2FsbChHZXRNZXRob2QoZSwgXCJkYXlzSW5ZZWFyXCIpLCBlLCBbdF0pO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGVuZGFyIGRheXNJblllYXIgcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIocikgfHwgciA8IDEpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2FsZW5kYXIgZGF5c0luWWVhciByZXN1bHQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJNb250aHNJblllYXIoZSwgdCkge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfcjI5ID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLm1vbnRoc0luWWVhciVcIiksIF9yMjksIFt0XSk7XG4gIH1cbiAgdmFyIHIgPSBDYWxsKEdldE1ldGhvZChlLCBcIm1vbnRoc0luWWVhclwiKSwgZSwgW3RdKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxlbmRhciBtb250aHNJblllYXIgcmVzdWx0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICBpZiAoIUlzSW50ZWdyYWxOdW1iZXIocikgfHwgciA8IDEpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2FsZW5kYXIgbW9udGhzSW5ZZWFyIHJlc3VsdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDYWxlbmRhckluTGVhcFllYXIoZSwgdCkge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfcjMwID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmluTGVhcFllYXIlXCIpLCBfcjMwLCBbdF0pO1xuICB9XG4gIHZhciByID0gQ2FsbChHZXRNZXRob2QoZSwgXCJpbkxlYXBZZWFyXCIpLCBlLCBbdF0pO1xuICBpZiAoXCJib29sZWFuXCIgIT0gdHlwZW9mIHIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxlbmRhciBpbkxlYXBZZWFyIHJlc3VsdCBtdXN0IGJlIGEgYm9vbGVhblwiKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWUoZSkge1xuICBpZiAoSXNPYmplY3QoZSkpIHtcbiAgICBpZiAoSGFzU2xvdChlLCBwKSkgcmV0dXJuIEdldFNsb3QoZSwgcCk7XG4gICAgaWYgKCFmdW5jdGlvbiBPYmplY3RJbXBsZW1lbnRzVGVtcG9yYWxDYWxlbmRhclByb3RvY29sKGUpIHtcbiAgICAgIHJldHVybiAhIUlzVGVtcG9yYWxDYWxlbmRhcihlKSB8fCBcImRhdGVBZGRcIiBpbiBlICYmIFwiZGF0ZUZyb21GaWVsZHNcIiBpbiBlICYmIFwiZGF0ZVVudGlsXCIgaW4gZSAmJiBcImRheVwiIGluIGUgJiYgXCJkYXlPZldlZWtcIiBpbiBlICYmIFwiZGF5T2ZZZWFyXCIgaW4gZSAmJiBcImRheXNJbk1vbnRoXCIgaW4gZSAmJiBcImRheXNJbldlZWtcIiBpbiBlICYmIFwiZGF5c0luWWVhclwiIGluIGUgJiYgXCJmaWVsZHNcIiBpbiBlICYmIFwiaWRcIiBpbiBlICYmIFwiaW5MZWFwWWVhclwiIGluIGUgJiYgXCJtZXJnZUZpZWxkc1wiIGluIGUgJiYgXCJtb250aFwiIGluIGUgJiYgXCJtb250aENvZGVcIiBpbiBlICYmIFwibW9udGhEYXlGcm9tRmllbGRzXCIgaW4gZSAmJiBcIm1vbnRoc0luWWVhclwiIGluIGUgJiYgXCJ3ZWVrT2ZZZWFyXCIgaW4gZSAmJiBcInllYXJcIiBpbiBlICYmIFwieWVhck1vbnRoRnJvbUZpZWxkc1wiIGluIGUgJiYgXCJ5ZWFyT2ZXZWVrXCIgaW4gZTtcbiAgICB9KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0ZWQgYSBUZW1wb3JhbC5DYWxlbmRhciBvciBvYmplY3QgaW1wbGVtZW50aW5nIHRoZSBUZW1wb3JhbC5DYWxlbmRhciBwcm90b2NvbFwiKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICB2YXIgdCA9IFRvU3RyaW5nKGUpO1xuICBpZiAoSXNCdWlsdGluQ2FsZW5kYXIodCkpIHJldHVybiBBU0NJSUxvd2VyY2FzZSh0KTtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgdmFyIF9QYXJzZUlTT0RhdGVUaW1lNSA9IFBhcnNlSVNPRGF0ZVRpbWUodCk7XG4gICAgciA9IF9QYXJzZUlTT0RhdGVUaW1lNS5jYWxlbmRhcjtcbiAgfSBjYXRjaCAoX3VudXNlZDQpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF9QYXJzZVRlbXBvcmFsWWVhck1vbjMgPSBQYXJzZVRlbXBvcmFsWWVhck1vbnRoU3RyaW5nKHQpO1xuICAgICAgciA9IF9QYXJzZVRlbXBvcmFsWWVhck1vbjMuY2FsZW5kYXI7XG4gICAgfSBjYXRjaCAoX3VudXNlZDUpIHtcbiAgICAgIHZhciBfUGFyc2VUZW1wb3JhbE1vbnRoRGEzID0gUGFyc2VUZW1wb3JhbE1vbnRoRGF5U3RyaW5nKHQpO1xuICAgICAgciA9IF9QYXJzZVRlbXBvcmFsTW9udGhEYTMuY2FsZW5kYXI7XG4gICAgfVxuICB9XG4gIGlmIChyIHx8IChyID0gXCJpc284NjAxXCIpLCAhSXNCdWlsdGluQ2FsZW5kYXIocikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCBjYWxlbmRhciBpZGVudGlmaWVyIFwiLmNvbmNhdChyKSk7XG4gIHJldHVybiBBU0NJSUxvd2VyY2FzZShyKTtcbn1cbmZ1bmN0aW9uIEdldFRlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWVXaXRoSVNPRGVmYXVsdChlKSB7XG4gIGlmIChIYXNTbG90KGUsIHApKSByZXR1cm4gR2V0U2xvdChlLCBwKTtcbiAgdmFyIHQgPSBlLmNhbGVuZGFyO1xuICByZXR1cm4gdm9pZCAwID09PSB0ID8gXCJpc284NjAxXCIgOiBUb1RlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWUodCk7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKGUpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHJldHVybiBlO1xuICB2YXIgdCA9IGUuaWQ7XG4gIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsZW5kYXIuaWQgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxDYWxlbmRhck9iamVjdChlKSB7XG4gIGlmIChJc09iamVjdChlKSkgcmV0dXJuIGU7XG4gIHJldHVybiBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJFcXVhbHMoZSwgdCkge1xuICBpZiAoZSA9PT0gdCkgcmV0dXJuICEwO1xuICByZXR1cm4gVG9UZW1wb3JhbENhbGVuZGFySWRlbnRpZmllcihlKSA9PT0gVG9UZW1wb3JhbENhbGVuZGFySWRlbnRpZmllcih0KTtcbn1cbmZ1bmN0aW9uIFRocm93SWZDYWxlbmRhcnNOb3RFcXVhbChlLCB0LCByKSB7XG4gIGlmIChlID09PSB0KSByZXR1cm47XG4gIHZhciBvID0gVG9UZW1wb3JhbENhbGVuZGFySWRlbnRpZmllcihlKSxcbiAgICBuID0gVG9UZW1wb3JhbENhbGVuZGFySWRlbnRpZmllcih0KTtcbiAgaWYgKG8gIT09IG4pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2Fubm90IFwiLmNvbmNhdChyLCBcIiBvZiBcIikuY29uY2F0KG8sIFwiIGFuZCBcIikuY29uY2F0KG4sIFwiIGNhbGVuZGFyc1wiKSk7XG59XG5mdW5jdGlvbiBDb25zb2xpZGF0ZUNhbGVuZGFycyhlLCB0KSB7XG4gIGlmIChlID09PSB0KSByZXR1cm4gdDtcbiAgdmFyIHIgPSBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKGUpLFxuICAgIG8gPSBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKHQpO1xuICBpZiAociA9PT0gbyB8fCBcImlzbzg2MDFcIiA9PT0gcikgcmV0dXJuIHQ7XG4gIGlmIChcImlzbzg2MDFcIiA9PT0gbykgcmV0dXJuIGU7XG4gIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaXJyZWNvbmNpbGFibGUgY2FsZW5kYXJzXCIpO1xufVxuZnVuY3Rpb24gQ2FsZW5kYXJEYXRlRnJvbUZpZWxkcyhlLCB0LCByLCBvKSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9vOSA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5kYXRlRnJvbUZpZWxkcyVcIiksIF9vOSwgW3QsIHJdKTtcbiAgfVxuICB2YXIgbiA9IENhbGwobyAhPT0gbnVsbCAmJiBvICE9PSB2b2lkIDAgPyBvIDogR2V0TWV0aG9kKGUsIFwiZGF0ZUZyb21GaWVsZHNcIiksIGUsIFt0LCByXSk7XG4gIGlmICghSXNUZW1wb3JhbERhdGUobikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlc3VsdFwiKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBDYWxlbmRhclllYXJNb250aEZyb21GaWVsZHMoZSwgdCwgcikge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xuICAgIHZhciBfbzEwID0gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIlXCIpKShlKTtcbiAgICByZXR1cm4gQ2FsbChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLnllYXJNb250aEZyb21GaWVsZHMlXCIpLCBfbzEwLCBbdCwgcl0pO1xuICB9XG4gIHZhciBvID0gQ2FsbChHZXRNZXRob2QoZSwgXCJ5ZWFyTW9udGhGcm9tRmllbGRzXCIpLCBlLCBbdCwgcl0pO1xuICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgobykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlc3VsdFwiKTtcbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBDYWxlbmRhck1vbnRoRGF5RnJvbUZpZWxkcyhlLCB0LCByKSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9vMTEgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhciVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUubW9udGhEYXlGcm9tRmllbGRzJVwiKSwgX28xMSwgW3QsIHJdKTtcbiAgfVxuICB2YXIgbyA9IENhbGwoR2V0TWV0aG9kKGUsIFwibW9udGhEYXlGcm9tRmllbGRzXCIpLCBlLCBbdCwgcl0pO1xuICBpZiAoIUlzVGVtcG9yYWxNb250aERheShvKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVzdWx0XCIpO1xuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZShlKSB7XG4gIGlmIChJc09iamVjdChlKSkge1xuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShlKSkgcmV0dXJuIEdldFNsb3QoZSwgZyk7XG4gICAgaWYgKCFmdW5jdGlvbiBPYmplY3RJbXBsZW1lbnRzVGVtcG9yYWxUaW1lWm9uZVByb3RvY29sKGUpIHtcbiAgICAgIHJldHVybiAhIUlzVGVtcG9yYWxUaW1lWm9uZShlKSB8fCBcImdldE9mZnNldE5hbm9zZWNvbmRzRm9yXCIgaW4gZSAmJiBcImdldFBvc3NpYmxlSW5zdGFudHNGb3JcIiBpbiBlICYmIFwiaWRcIiBpbiBlO1xuICAgIH0oZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RlZCBhIFRlbXBvcmFsLlRpbWVab25lIG9yIG9iamVjdCBpbXBsZW1lbnRpbmcgdGhlIFRlbXBvcmFsLlRpbWVab25lIHByb3RvY29sXCIpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIHJldHVybiBQYXJzZVRlbXBvcmFsVGltZVpvbmUoVG9TdHJpbmcoZSkpO1xufVxuZnVuY3Rpb24gVG9UZW1wb3JhbFRpbWVab25lSWRlbnRpZmllcihlKSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSByZXR1cm4gZTtcbiAgdmFyIHQgPSBlLmlkO1xuICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRpbWVab25lLmlkIHNob3VsZCBiZSBhIHN0cmluZ1wiKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBUb1RlbXBvcmFsVGltZVpvbmVPYmplY3QoZSkge1xuICBpZiAoSXNPYmplY3QoZSkpIHJldHVybiBlO1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuVGltZVpvbmUlXCIpKShlKTtcbn1cbmZ1bmN0aW9uIFRpbWVab25lRXF1YWxzKGUsIHQpIHtcbiAgaWYgKGUgPT09IHQpIHJldHVybiAhMDtcbiAgcmV0dXJuIFRvVGVtcG9yYWxUaW1lWm9uZUlkZW50aWZpZXIoZSkgPT09IFRvVGVtcG9yYWxUaW1lWm9uZUlkZW50aWZpZXIodCk7XG59XG5mdW5jdGlvbiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKGUpIHtcbiAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZShHZXRTbG90KGUsIGkpLCBHZXRTbG90KGUsIHMpLCBHZXRTbG90KGUsIGwpLCBHZXRTbG90KGUsIHApKTtcbn1cbmZ1bmN0aW9uIFRlbXBvcmFsRGF0ZVRpbWVUb1RpbWUoZSkge1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuUGxhaW5UaW1lJVwiKSkoR2V0U2xvdChlLCBkKSwgR2V0U2xvdChlLCBtKSwgR2V0U2xvdChlLCBjKSwgR2V0U2xvdChlLCBoKSwgR2V0U2xvdChlLCB1KSwgR2V0U2xvdChlLCBUKSk7XG59XG5mdW5jdGlvbiBHZXRPZmZzZXROYW5vc2Vjb25kc0ZvcihlLCB0LCByKSB7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgdmFyIF9yMzEgPSBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5UaW1lWm9uZSVcIikpKGUpO1xuICAgIHJldHVybiBDYWxsKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5UaW1lWm9uZS5wcm90b3R5cGUuZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3IlXCIpLCBfcjMxLCBbdF0pO1xuICB9XG4gIHZhciBvID0gQ2FsbChyICE9PSBudWxsICYmIHIgIT09IHZvaWQgMCA/IHIgOiBHZXRNZXRob2QoZSwgXCJnZXRPZmZzZXROYW5vc2Vjb25kc0ZvclwiKSwgZSwgW3RdKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIG8pIHRocm93IG5ldyBUeXBlRXJyb3IoXCJiYWQgcmV0dXJuIGZyb20gZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3JcIik7XG4gIGlmICghSXNJbnRlZ3JhbE51bWJlcihvKSB8fCBhZShvKSA+PSA4NjRlMTEpIHRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0LW9mLXJhbmdlIHJldHVybiBmcm9tIGdldE9mZnNldE5hbm9zZWNvbmRzRm9yXCIpO1xuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIEdldE9mZnNldFN0cmluZ0ZvcihlLCB0KSB7XG4gIHJldHVybiBGb3JtYXRUaW1lWm9uZU9mZnNldFN0cmluZyhHZXRPZmZzZXROYW5vc2Vjb25kc0ZvcihlLCB0KSk7XG59XG5mdW5jdGlvbiBHZXRQbGFpbkRhdGVUaW1lRm9yKGUsIHQsIHIpIHtcbiAgdmFyIF9CYWxhbmNlSVNPRGF0ZVRpbWUyO1xuICB2YXIgbyA9IEdldFNsb3QodCwgbiksXG4gICAgYSA9IEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKGUsIHQpO1xuICB2YXIgX0dldElTT1BhcnRzRnJvbUVwb2NoID0gR2V0SVNPUGFydHNGcm9tRXBvY2gobyksXG4gICAgaSA9IF9HZXRJU09QYXJ0c0Zyb21FcG9jaC55ZWFyLFxuICAgIHMgPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gubW9udGgsXG4gICAgbCA9IF9HZXRJU09QYXJ0c0Zyb21FcG9jaC5kYXksXG4gICAgZCA9IF9HZXRJU09QYXJ0c0Zyb21FcG9jaC5ob3VyLFxuICAgIG0gPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gubWludXRlLFxuICAgIGMgPSBfR2V0SVNPUGFydHNGcm9tRXBvY2guc2Vjb25kLFxuICAgIGggPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gubWlsbGlzZWNvbmQsXG4gICAgdSA9IF9HZXRJU09QYXJ0c0Zyb21FcG9jaC5taWNyb3NlY29uZCxcbiAgICBUID0gX0dldElTT1BhcnRzRnJvbUVwb2NoLm5hbm9zZWNvbmQ7XG4gIHJldHVybiAoX0JhbGFuY2VJU09EYXRlVGltZTIgPSBCYWxhbmNlSVNPRGF0ZVRpbWUoaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVCArIGEpLCBpID0gX0JhbGFuY2VJU09EYXRlVGltZTIueWVhciwgcyA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUyLm1vbnRoLCBsID0gX0JhbGFuY2VJU09EYXRlVGltZTIuZGF5LCBkID0gX0JhbGFuY2VJU09EYXRlVGltZTIuaG91ciwgbSA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUyLm1pbnV0ZSwgYyA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUyLnNlY29uZCwgaCA9IF9CYWxhbmNlSVNPRGF0ZVRpbWUyLm1pbGxpc2Vjb25kLCB1ID0gX0JhbGFuY2VJU09EYXRlVGltZTIubWljcm9zZWNvbmQsIFQgPSBfQmFsYW5jZUlTT0RhdGVUaW1lMi5uYW5vc2Vjb25kKSwgQ3JlYXRlVGVtcG9yYWxEYXRlVGltZShpLCBzLCBsLCBkLCBtLCBjLCBoLCB1LCBULCByKTtcbn1cbmZ1bmN0aW9uIEdldEluc3RhbnRGb3IoZSwgdCwgcikge1xuICByZXR1cm4gRGlzYW1iaWd1YXRlUG9zc2libGVJbnN0YW50cyhHZXRQb3NzaWJsZUluc3RhbnRzRm9yKGUsIHQpLCBlLCB0LCByKTtcbn1cbmZ1bmN0aW9uIERpc2FtYmlndWF0ZVBvc3NpYmxlSW5zdGFudHModCwgciwgbywgbikge1xuICB2YXIgYSA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5JbnN0YW50JVwiKSxcbiAgICBmID0gdC5sZW5ndGg7XG4gIGlmICgxID09PSBmKSByZXR1cm4gdFswXTtcbiAgaWYgKGYpIHN3aXRjaCAobikge1xuICAgIGNhc2UgXCJjb21wYXRpYmxlXCI6XG4gICAgY2FzZSBcImVhcmxpZXJcIjpcbiAgICAgIHJldHVybiB0WzBdO1xuICAgIGNhc2UgXCJsYXRlclwiOlxuICAgICAgcmV0dXJuIHRbZiAtIDFdO1xuICAgIGNhc2UgXCJyZWplY3RcIjpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwibXVsdGlwbGUgaW5zdGFudHMgZm91bmRcIik7XG4gIH1cbiAgdmFyIHkgPSBHZXRTbG90KG8sIGkpLFxuICAgIEkgPSBHZXRTbG90KG8sIHMpLFxuICAgIFMgPSBHZXRTbG90KG8sIGwpLFxuICAgIGcgPSBHZXRTbG90KG8sIGQpLFxuICAgIHcgPSBHZXRTbG90KG8sIG0pLFxuICAgIEQgPSBHZXRTbG90KG8sIGMpLFxuICAgIEcgPSBHZXRTbG90KG8sIGgpLFxuICAgIHYgPSBHZXRTbG90KG8sIHUpLFxuICAgIEMgPSBHZXRTbG90KG8sIFQpLFxuICAgIE8gPSBHZXRVVENFcG9jaE5hbm9zZWNvbmRzKHksIEksIFMsIGcsIHcsIEQsIEcsIHYsIEMpO1xuICBpZiAobnVsbCA9PT0gTykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEYXRlVGltZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZVwiKTtcbiAgdmFyIGIgPSBuZXcgYShPIC0gRWUpLFxuICAgIEUgPSBuZXcgYShPICsgRWUpLFxuICAgIE0gPSBHZXRPZmZzZXROYW5vc2Vjb25kc0ZvcihyLCBiKSxcbiAgICBSID0gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IociwgRSkgLSBNO1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIFwiZWFybGllclwiOlxuICAgICAge1xuICAgICAgICB2YXIgX2UxOCA9IEdldFNsb3QobywgcCksXG4gICAgICAgICAgX3QxOSA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKSxcbiAgICAgICAgICBfbjcgPSBBZGREYXRlVGltZSh5LCBJLCBTLCBnLCB3LCBELCBHLCB2LCBDLCBfZTE4LCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAtUiwgdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuIEdldFBvc3NpYmxlSW5zdGFudHNGb3IociwgbmV3IF90MTkoX243LnllYXIsIF9uNy5tb250aCwgX243LmRheSwgX243LmhvdXIsIF9uNy5taW51dGUsIF9uNy5zZWNvbmQsIF9uNy5taWxsaXNlY29uZCwgX243Lm1pY3Jvc2Vjb25kLCBfbjcubmFub3NlY29uZCwgX2UxOCkpWzBdO1xuICAgICAgfVxuICAgIGNhc2UgXCJjb21wYXRpYmxlXCI6XG4gICAgY2FzZSBcImxhdGVyXCI6XG4gICAgICB7XG4gICAgICAgIHZhciBfZTE5ID0gR2V0U2xvdChvLCBwKSxcbiAgICAgICAgICBfdDIwID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlXCIpLFxuICAgICAgICAgIF9uOCA9IEFkZERhdGVUaW1lKHksIEksIFMsIGcsIHcsIEQsIEcsIHYsIEMsIF9lMTksIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIFIsIHZvaWQgMCksXG4gICAgICAgICAgX2E0ID0gR2V0UG9zc2libGVJbnN0YW50c0ZvcihyLCBuZXcgX3QyMChfbjgueWVhciwgX244Lm1vbnRoLCBfbjguZGF5LCBfbjguaG91ciwgX244Lm1pbnV0ZSwgX244LnNlY29uZCwgX244Lm1pbGxpc2Vjb25kLCBfbjgubWljcm9zZWNvbmQsIF9uOC5uYW5vc2Vjb25kLCBfZTE5KSk7XG4gICAgICAgIHJldHVybiBfYTRbX2E0Lmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIGNhc2UgXCJyZWplY3RcIjpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwibm8gc3VjaCBpbnN0YW50IGZvdW5kXCIpO1xuICB9XG59XG5mdW5jdGlvbiBHZXRQb3NzaWJsZUluc3RhbnRzRm9yKGUsIHQsIHIpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICB2YXIgX3IzMiA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlRpbWVab25lJVwiKSkoZSk7XG4gICAgcmV0dXJuIENhbGwoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlRpbWVab25lLnByb3RvdHlwZS5nZXRQb3NzaWJsZUluc3RhbnRzRm9yJVwiKSwgX3IzMiwgW3RdKTtcbiAgfVxuICB2YXIgbyA9IENhbGwociAhPT0gbnVsbCAmJiByICE9PSB2b2lkIDAgPyByIDogR2V0TWV0aG9kKGUsIFwiZ2V0UG9zc2libGVJbnN0YW50c0ZvclwiKSwgZSwgW3RdKSxcbiAgICBuID0gW107XG4gIHZhciBfaXRlcmF0b3IxMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8pLFxuICAgIF9zdGVwMTM7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IxMy5zKCk7ICEoX3N0ZXAxMyA9IF9pdGVyYXRvcjEzLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfZTIwID0gX3N0ZXAxMy52YWx1ZTtcbiAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQoX2UyMCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJiYWQgcmV0dXJuIGZyb20gZ2V0UG9zc2libGVJbnN0YW50c0ZvclwiKTtcbiAgICAgIHRlLmNhbGwobiwgX2UyMCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IxMy5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMTMuZigpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gSVNPWWVhclN0cmluZyhlKSB7XG4gIHZhciB0O1xuICBpZiAoZSA8IDAgfHwgZSA+IDk5OTkpIHtcbiAgICB0ID0gKGUgPCAwID8gXCItXCIgOiBcIitcIikgKyBcIjAwMDAwMFwiLmNvbmNhdChhZShlKSkuc2xpY2UoLTYpO1xuICB9IGVsc2UgdCA9IFwiMDAwMFwiLmNvbmNhdChlKS5zbGljZSgtNCk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKGUpIHtcbiAgcmV0dXJuIFwiMDBcIi5jb25jYXQoZSkuc2xpY2UoLTIpO1xufVxuZnVuY3Rpb24gRm9ybWF0U2Vjb25kc1N0cmluZ1BhcnQoZSwgdCwgciwgbywgbikge1xuICBpZiAoXCJtaW51dGVcIiA9PT0gbikgcmV0dXJuIFwiXCI7XG4gIHZhciBhID0gXCI6XCIuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhlKSk7XG4gIHZhciBpLFxuICAgIHMgPSAxZTYgKiB0ICsgMWUzICogciArIG87XG4gIGlmIChcImF1dG9cIiA9PT0gbikge1xuICAgIGlmICgwID09PSBzKSByZXR1cm4gYTtcbiAgICBmb3IgKGkgPSBcIlwiLmNvbmNhdChzKS5wYWRTdGFydCg5LCBcIjBcIik7IFwiMFwiID09PSBpW2kubGVuZ3RoIC0gMV07KSBpID0gaS5zbGljZSgwLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKDAgPT09IG4pIHJldHVybiBhO1xuICAgIGkgPSBcIlwiLmNvbmNhdChzKS5wYWRTdGFydCg5LCBcIjBcIikuc2xpY2UoMCwgbik7XG4gIH1cbiAgcmV0dXJuIFwiXCIuY29uY2F0KGEsIFwiLlwiKS5jb25jYXQoaSk7XG59XG5mdW5jdGlvbiBUZW1wb3JhbEluc3RhbnRUb1N0cmluZyhlLCB0LCByKSB7XG4gIHZhciBvID0gdDtcbiAgdm9pZCAwID09PSBvICYmIChvID0gXCJVVENcIik7XG4gIHZhciBuID0gR2V0UGxhaW5EYXRlVGltZUZvcihvLCBlLCBcImlzbzg2MDFcIiksXG4gICAgYSA9IElTT1llYXJTdHJpbmcoR2V0U2xvdChuLCBpKSksXG4gICAgcCA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KG4sIHMpKSxcbiAgICBmID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QobiwgbCkpLFxuICAgIHkgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChuLCBkKSksXG4gICAgSSA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KG4sIG0pKSxcbiAgICBTID0gRm9ybWF0U2Vjb25kc1N0cmluZ1BhcnQoR2V0U2xvdChuLCBjKSwgR2V0U2xvdChuLCBoKSwgR2V0U2xvdChuLCB1KSwgR2V0U2xvdChuLCBUKSwgcik7XG4gIHZhciBnID0gXCJaXCI7XG4gIGlmICh2b2lkIDAgIT09IHQpIHtcbiAgICBnID0gRm9ybWF0SVNPVGltZVpvbmVPZmZzZXRTdHJpbmcoR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IobywgZSkpO1xuICB9XG4gIHJldHVybiBcIlwiLmNvbmNhdChhLCBcIi1cIikuY29uY2F0KHAsIFwiLVwiKS5jb25jYXQoZiwgXCJUXCIpLmNvbmNhdCh5LCBcIjpcIikuY29uY2F0KEkpLmNvbmNhdChTKS5jb25jYXQoZyk7XG59XG5mdW5jdGlvbiBUZW1wb3JhbER1cmF0aW9uVG9TdHJpbmcodCkge1xuICB2YXIgX2Rpdm1vZCwgX2Rpdm1vZDIsIF9kaXZtb2QzO1xuICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJhdXRvXCI7XG4gIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIGZvcm1hdE51bWJlcih0KSB7XG4gICAgcmV0dXJuIHQgPD0gdWUgPyB0LnRvU3RyaW5nKDEwKSA6IEJpZ0ludCh0KS50b1N0cmluZygxMCk7XG4gIH1cbiAgdmFyIG4gPSBHZXRTbG90KHQsIHcpLFxuICAgIGEgPSBHZXRTbG90KHQsIEQpLFxuICAgIGkgPSBHZXRTbG90KHQsIEcpLFxuICAgIHMgPSBHZXRTbG90KHQsIHYpLFxuICAgIGwgPSBHZXRTbG90KHQsIEMpLFxuICAgIGQgPSBHZXRTbG90KHQsIE8pO1xuICB2YXIgbSA9IEdldFNsb3QodCwgYiksXG4gICAgYyA9IEdldFNsb3QodCwgRSksXG4gICAgaCA9IEdldFNsb3QodCwgTSksXG4gICAgdSA9IEdldFNsb3QodCwgUik7XG4gIHZhciBUID0gRHVyYXRpb25TaWduKG4sIGEsIGksIHMsIGwsIGQsIG0sIGMsIGgsIHUpO1xuICBpZiAobykge1xuICAgIHZhciBfZTIxID0gby51bml0LFxuICAgICAgX3QyMSA9IG8uaW5jcmVtZW50LFxuICAgICAgX3IzMyA9IG8ucm91bmRpbmdNb2RlO1xuICAgIHZhciBfUm91bmREdXJhdGlvbiA9IFJvdW5kRHVyYXRpb24oMCwgMCwgMCwgMCwgMCwgMCwgbSwgYywgaCwgdSwgX3QyMSwgX2UyMSwgX3IzMyk7XG4gICAgbSA9IF9Sb3VuZER1cmF0aW9uLnNlY29uZHM7XG4gICAgYyA9IF9Sb3VuZER1cmF0aW9uLm1pbGxpc2Vjb25kcztcbiAgICBoID0gX1JvdW5kRHVyYXRpb24ubWljcm9zZWNvbmRzO1xuICAgIHUgPSBfUm91bmREdXJhdGlvbi5uYW5vc2Vjb25kcztcbiAgfVxuICB2YXIgcCA9IFtdO1xuICBuICYmIHAucHVzaChcIlwiLmNvbmNhdChmb3JtYXROdW1iZXIoYWUobikpLCBcIllcIikpLCBhICYmIHAucHVzaChcIlwiLmNvbmNhdChmb3JtYXROdW1iZXIoYWUoYSkpLCBcIk1cIikpLCBpICYmIHAucHVzaChcIlwiLmNvbmNhdChmb3JtYXROdW1iZXIoYWUoaSkpLCBcIldcIikpLCBzICYmIHAucHVzaChcIlwiLmNvbmNhdChmb3JtYXROdW1iZXIoYWUocykpLCBcIkRcIikpO1xuICB2YXIgZiA9IFtdO1xuICBsICYmIGYucHVzaChcIlwiLmNvbmNhdChmb3JtYXROdW1iZXIoYWUobCkpLCBcIkhcIikpLCBkICYmIGYucHVzaChcIlwiLmNvbmNhdChmb3JtYXROdW1iZXIoYWUoZCkpLCBcIk1cIikpO1xuICB2YXIgeSA9IFtdO1xuICB2YXIgSSxcbiAgICBTLFxuICAgIGcsXG4gICAgRixcbiAgICBZID0gVG90YWxEdXJhdGlvbk5hbm9zZWNvbmRzKDAsIDAsIDAsIG0sIGMsIGgsIHUsIDApO1xuICAoX2Rpdm1vZCA9IGRpdm1vZChZLCBEZSksIFkgPSBfZGl2bW9kLnF1b3RpZW50LCBJID0gX2Rpdm1vZC5yZW1haW5kZXIpLCAoX2Rpdm1vZDIgPSBkaXZtb2QoWSwgRGUpLCBZID0gX2Rpdm1vZDIucXVvdGllbnQsIFMgPSBfZGl2bW9kMi5yZW1haW5kZXIpLCAoX2Rpdm1vZDMgPSBkaXZtb2QoWSwgRGUpLCBGID0gX2Rpdm1vZDMucXVvdGllbnQsIGcgPSBfZGl2bW9kMy5yZW1haW5kZXIpO1xuICB2YXIgUCA9IDFlNiAqIGFlKE51bWJlcihnKSkgKyAxZTMgKiBhZShOdW1iZXIoUykpICsgYWUoTnVtYmVyKEkpKTtcbiAgdmFyIFo7XG4gIGlmIChcImF1dG9cIiA9PT0gcikge1xuICAgIGlmICgwICE9PSBQKSBmb3IgKFogPSBcIlwiLmNvbmNhdChQKS5wYWRTdGFydCg5LCBcIjBcIik7IFwiMFwiID09PSBaW1oubGVuZ3RoIC0gMV07KSBaID0gWi5zbGljZSgwLCAtMSk7XG4gIH0gZWxzZSAwICE9PSByICYmIChaID0gXCJcIi5jb25jYXQoUCkucGFkU3RhcnQoOSwgXCIwXCIpLnNsaWNlKDAsIHIpKTtcbiAgcmV0dXJuIFogJiYgeS51bnNoaWZ0KFwiLlwiLCBaKSwgRiA9PT0gSWUgJiYgIXkubGVuZ3RoICYmIFwiYXV0b1wiID09PSByIHx8IHkudW5zaGlmdChhYnMoRikudG9TdHJpbmcoKSksIHkubGVuZ3RoICYmIGYucHVzaChcIlwiLmNvbmNhdCh5LmpvaW4oXCJcIiksIFwiU1wiKSksIGYubGVuZ3RoICYmIGYudW5zaGlmdChcIlRcIiksIHAubGVuZ3RoIHx8IGYubGVuZ3RoID8gXCJcIi5jb25jYXQoVCA8IDAgPyBcIi1cIiA6IFwiXCIsIFwiUFwiKS5jb25jYXQocC5qb2luKFwiXCIpKS5jb25jYXQoZi5qb2luKFwiXCIpKSA6IFwiUFQwU1wiO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxEYXRlVG9TdHJpbmcoZSkge1xuICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJhdXRvXCI7XG4gIHJldHVybiBcIlwiLmNvbmNhdChJU09ZZWFyU3RyaW5nKEdldFNsb3QoZSwgaSkpLCBcIi1cIikuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KGUsIHMpKSwgXCItXCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChlLCBsKSkpLmNvbmNhdChNYXliZUZvcm1hdENhbGVuZGFyQW5ub3RhdGlvbihHZXRTbG90KGUsIHApLCB0KSk7XG59XG5mdW5jdGlvbiBUZW1wb3JhbERhdGVUaW1lVG9TdHJpbmcoZSwgdCkge1xuICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJhdXRvXCI7XG4gIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gIHZhciBuID0gR2V0U2xvdChlLCBpKSxcbiAgICBhID0gR2V0U2xvdChlLCBzKSxcbiAgICBmID0gR2V0U2xvdChlLCBsKSxcbiAgICB5ID0gR2V0U2xvdChlLCBkKSxcbiAgICBJID0gR2V0U2xvdChlLCBtKSxcbiAgICBTID0gR2V0U2xvdChlLCBjKSxcbiAgICBnID0gR2V0U2xvdChlLCBoKSxcbiAgICB3ID0gR2V0U2xvdChlLCB1KSxcbiAgICBEID0gR2V0U2xvdChlLCBUKTtcbiAgaWYgKG8pIHtcbiAgICB2YXIgX2UyMiA9IG8udW5pdCxcbiAgICAgIF90MjIgPSBvLmluY3JlbWVudCxcbiAgICAgIF9yMzQgPSBvLnJvdW5kaW5nTW9kZTtcbiAgICB2YXIgX1JvdW5kSVNPRGF0ZVRpbWUgPSBSb3VuZElTT0RhdGVUaW1lKG4sIGEsIGYsIHksIEksIFMsIGcsIHcsIEQsIF90MjIsIF9lMjIsIF9yMzQpO1xuICAgIG4gPSBfUm91bmRJU09EYXRlVGltZS55ZWFyO1xuICAgIGEgPSBfUm91bmRJU09EYXRlVGltZS5tb250aDtcbiAgICBmID0gX1JvdW5kSVNPRGF0ZVRpbWUuZGF5O1xuICAgIHkgPSBfUm91bmRJU09EYXRlVGltZS5ob3VyO1xuICAgIEkgPSBfUm91bmRJU09EYXRlVGltZS5taW51dGU7XG4gICAgUyA9IF9Sb3VuZElTT0RhdGVUaW1lLnNlY29uZDtcbiAgICBnID0gX1JvdW5kSVNPRGF0ZVRpbWUubWlsbGlzZWNvbmQ7XG4gICAgdyA9IF9Sb3VuZElTT0RhdGVUaW1lLm1pY3Jvc2Vjb25kO1xuICAgIEQgPSBfUm91bmRJU09EYXRlVGltZS5uYW5vc2Vjb25kO1xuICB9XG4gIHJldHVybiBcIlwiLmNvbmNhdChJU09ZZWFyU3RyaW5nKG4pLCBcIi1cIikuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhhKSwgXCItXCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcoZiksIFwiVFwiKS5jb25jYXQoSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKHkpLCBcIjpcIikuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhJKSkuY29uY2F0KEZvcm1hdFNlY29uZHNTdHJpbmdQYXJ0KFMsIGcsIHcsIEQsIHQpKS5jb25jYXQoTWF5YmVGb3JtYXRDYWxlbmRhckFubm90YXRpb24oR2V0U2xvdChlLCBwKSwgcikpO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxNb250aERheVRvU3RyaW5nKGUpIHtcbiAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiYXV0b1wiO1xuICB2YXIgciA9IFwiXCIuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KGUsIHMpKSwgXCItXCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChlLCBsKSkpO1xuICB2YXIgbyA9IFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoR2V0U2xvdChlLCBwKSk7XG4gIGlmIChcImFsd2F5c1wiID09PSB0IHx8IFwiY3JpdGljYWxcIiA9PT0gdCB8fCBcImlzbzg2MDFcIiAhPT0gbykge1xuICAgIHIgPSBcIlwiLmNvbmNhdChJU09ZZWFyU3RyaW5nKEdldFNsb3QoZSwgaSkpLCBcIi1cIikuY29uY2F0KHIpO1xuICB9XG4gIHZhciBuID0gRm9ybWF0Q2FsZW5kYXJBbm5vdGF0aW9uKG8sIHQpO1xuICByZXR1cm4gbiAmJiAociArPSBuKSwgcjtcbn1cbmZ1bmN0aW9uIFRlbXBvcmFsWWVhck1vbnRoVG9TdHJpbmcoZSkge1xuICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJhdXRvXCI7XG4gIHZhciByID0gXCJcIi5jb25jYXQoSVNPWWVhclN0cmluZyhHZXRTbG90KGUsIGkpKSwgXCItXCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdChlLCBzKSkpO1xuICB2YXIgbyA9IFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoR2V0U2xvdChlLCBwKSk7XG4gIGlmIChcImFsd2F5c1wiID09PSB0IHx8IFwiY3JpdGljYWxcIiA9PT0gdCB8fCBcImlzbzg2MDFcIiAhPT0gbykge1xuICAgIHIgKz0gXCItXCIuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KGUsIGwpKSk7XG4gIH1cbiAgdmFyIG4gPSBGb3JtYXRDYWxlbmRhckFubm90YXRpb24obywgdCk7XG4gIHJldHVybiBuICYmIChyICs9IG4pLCByO1xufVxuZnVuY3Rpb24gVGVtcG9yYWxab25lZERhdGVUaW1lVG9TdHJpbmcoZSwgdCkge1xuICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJhdXRvXCI7XG4gIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcImF1dG9cIjtcbiAgdmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFwiYXV0b1wiO1xuICB2YXIgZiA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ID8gYXJndW1lbnRzWzVdIDogdW5kZWZpbmVkO1xuICB2YXIgeSA9IEdldFNsb3QoZSwgUyk7XG4gIGlmIChmKSB7XG4gICAgdmFyIF90MjMgPSBmLnVuaXQsXG4gICAgICBfcjM1ID0gZi5pbmNyZW1lbnQsXG4gICAgICBfbzEyID0gZi5yb3VuZGluZ01vZGUsXG4gICAgICBfYTUgPSBSb3VuZEluc3RhbnQoR2V0U2xvdChlLCBuKSwgX3IzNSwgX3QyMywgX28xMik7XG4gICAgeSA9IG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpKShfYTUpO1xuICB9XG4gIHZhciBJID0gR2V0U2xvdChlLCBnKSxcbiAgICB3ID0gR2V0UGxhaW5EYXRlVGltZUZvcihJLCB5LCBcImlzbzg2MDFcIik7XG4gIHZhciBEID0gXCJcIi5jb25jYXQoSVNPWWVhclN0cmluZyhHZXRTbG90KHcsIGkpKSwgXCItXCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdCh3LCBzKSksIFwiLVwiKS5jb25jYXQoSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKEdldFNsb3QodywgbCkpLCBcIlRcIikuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhHZXRTbG90KHcsIGQpKSwgXCI6XCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcoR2V0U2xvdCh3LCBtKSkpLmNvbmNhdChGb3JtYXRTZWNvbmRzU3RyaW5nUGFydChHZXRTbG90KHcsIGMpLCBHZXRTbG90KHcsIGgpLCBHZXRTbG90KHcsIHUpLCBHZXRTbG90KHcsIFQpLCB0KSk7XG4gIGlmIChcIm5ldmVyXCIgIT09IGEpIHtcbiAgICBEICs9IEZvcm1hdElTT1RpbWVab25lT2Zmc2V0U3RyaW5nKEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKEksIHkpKTtcbiAgfVxuICBpZiAoXCJuZXZlclwiICE9PSBvKSB7XG4gICAgRCArPSBcIltcIi5jb25jYXQoXCJjcml0aWNhbFwiID09PSBvID8gXCIhXCIgOiBcIlwiKS5jb25jYXQoVG9UZW1wb3JhbFRpbWVab25lSWRlbnRpZmllcihJKSwgXCJdXCIpO1xuICB9XG4gIHJldHVybiBEICs9IE1heWJlRm9ybWF0Q2FsZW5kYXJBbm5vdGF0aW9uKEdldFNsb3QoZSwgcCksIHIpLCBEO1xufVxuZnVuY3Rpb24gSXNUaW1lWm9uZU9mZnNldFN0cmluZyhlKSB7XG4gIHJldHVybiB6ZS50ZXN0KGhlKGUpKTtcbn1cbmZ1bmN0aW9uIFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcoZSkge1xuICB2YXIgdCA9IHplLmV4ZWMoaGUoZSkpO1xuICBpZiAoIXQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCB0aW1lIHpvbmUgb2Zmc2V0OiBcIi5jb25jYXQoZSkpO1xuICByZXR1cm4gKFwiLVwiID09PSB0WzFdIHx8IFwi4oiSXCIgPT09IHRbMV0gPyAtMSA6IDEpICogKDFlOSAqICg2MCAqICg2MCAqICt0WzJdICsgKyh0WzNdIHx8IDApKSArICsodFs0XSB8fCAwKSkgKyArKCh0WzVdIHx8IDApICsgXCIwMDAwMDAwMDBcIikuc2xpY2UoMCwgOSkpO1xufVxuZnVuY3Rpb24gR2V0Q2Fub25pY2FsVGltZVpvbmVJZGVudGlmaWVyKGUpIHtcbiAgaWYgKElzVGltZVpvbmVPZmZzZXRTdHJpbmcoZSkpIHtcbiAgICByZXR1cm4gRm9ybWF0VGltZVpvbmVPZmZzZXRTdHJpbmcoUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhlKSk7XG4gIH1cbiAgcmV0dXJuIGdldEludGxEYXRlVGltZUZvcm1hdEVuVXNGb3JUaW1lWm9uZShoZShlKSkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XG59XG5mdW5jdGlvbiBHZXROYW1lZFRpbWVab25lT2Zmc2V0TmFub3NlY29uZHModCwgcikge1xuICB2YXIgX0dldE5hbWVkVGltZVpvbmVEYXRlID0gR2V0TmFtZWRUaW1lWm9uZURhdGVUaW1lUGFydHModCwgciksXG4gICAgbyA9IF9HZXROYW1lZFRpbWVab25lRGF0ZS55ZWFyLFxuICAgIG4gPSBfR2V0TmFtZWRUaW1lWm9uZURhdGUubW9udGgsXG4gICAgYSA9IF9HZXROYW1lZFRpbWVab25lRGF0ZS5kYXksXG4gICAgaSA9IF9HZXROYW1lZFRpbWVab25lRGF0ZS5ob3VyLFxuICAgIHMgPSBfR2V0TmFtZWRUaW1lWm9uZURhdGUubWludXRlLFxuICAgIGwgPSBfR2V0TmFtZWRUaW1lWm9uZURhdGUuc2Vjb25kLFxuICAgIGQgPSBfR2V0TmFtZWRUaW1lWm9uZURhdGUubWlsbGlzZWNvbmQsXG4gICAgbSA9IF9HZXROYW1lZFRpbWVab25lRGF0ZS5taWNyb3NlY29uZCxcbiAgICBjID0gX0dldE5hbWVkVGltZVpvbmVEYXRlLm5hbm9zZWNvbmQsXG4gICAgaCA9IG8gJSA0MDAsXG4gICAgdSA9IChvIC0gaCkgLyA0MDAsXG4gICAgVCA9IDE0NjA5N24gKiBFZSxcbiAgICBwID0gR2V0VVRDRXBvY2hOYW5vc2Vjb25kcyhoLCBuLCBhLCBpLCBzLCBsLCBkLCBtLCBjKSxcbiAgICBmID0gcCArIFQgKiBCaWdJbnQodSk7XG4gIHJldHVybiBOdW1iZXIoZiAtIHIpO1xufVxuZnVuY3Rpb24gRm9ybWF0VGltZVpvbmVPZmZzZXRTdHJpbmcoZSkge1xuICB2YXIgdCA9IGUgPCAwID8gXCItXCIgOiBcIitcIixcbiAgICByID0gYWUoZSksXG4gICAgbyA9IHIgJSAxZTksXG4gICAgbiA9IGllKHIgLyAxZTkpICUgNjAsXG4gICAgYSA9IGllKHIgLyA2ZTEwKSAlIDYwLFxuICAgIGkgPSBJU09EYXRlVGltZVBhcnRTdHJpbmcoaWUociAvIDM2ZTExKSksXG4gICAgcyA9IElTT0RhdGVUaW1lUGFydFN0cmluZyhhKSxcbiAgICBsID0gSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKG4pO1xuICB2YXIgZCA9IFwiXCI7XG4gIGlmIChvKSB7XG4gICAgdmFyIF9lMjMgPSBcIlwiLmNvbmNhdChvKS5wYWRTdGFydCg5LCBcIjBcIik7XG4gICAgZm9yICg7IFwiMFwiID09PSBfZTIzW19lMjMubGVuZ3RoIC0gMV07KSBfZTIzID0gX2UyMy5zbGljZSgwLCAtMSk7XG4gICAgZCA9IFwiOlwiLmNvbmNhdChsLCBcIi5cIikuY29uY2F0KF9lMjMpO1xuICB9IGVsc2UgbiAmJiAoZCA9IFwiOlwiLmNvbmNhdChsKSk7XG4gIHJldHVybiBcIlwiLmNvbmNhdCh0KS5jb25jYXQoaSwgXCI6XCIpLmNvbmNhdChzKS5jb25jYXQoZCk7XG59XG5mdW5jdGlvbiBGb3JtYXRJU09UaW1lWm9uZU9mZnNldFN0cmluZyh0KSB7XG4gIHZhciByID0gTnVtYmVyKFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoQmlnSW50KHQpLCBiZSwgXCJoYWxmRXhwYW5kXCIpKTtcbiAgdmFyIG8gPSByIDwgMCA/IFwiLVwiIDogXCIrXCI7XG4gIHIgPSBhZShyKTtcbiAgdmFyIG4gPSByIC8gNmUxMCAlIDYwO1xuICByZXR1cm4gXCJcIi5jb25jYXQobykuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhpZShyIC8gMzZlMTEpKSwgXCI6XCIpLmNvbmNhdChJU09EYXRlVGltZVBhcnRTdHJpbmcobikpO1xufVxuZnVuY3Rpb24gR2V0VVRDRXBvY2hOYW5vc2Vjb25kcyh0LCByLCBvLCBuLCBhLCBpLCBzLCBsLCBkKSB7XG4gIHZhciBtID0gbmV3IERhdGUoKTtcbiAgbS5zZXRVVENIb3VycyhuLCBhLCBpLCBzKSwgbS5zZXRVVENGdWxsWWVhcih0LCByIC0gMSwgbyk7XG4gIHZhciBjID0gbS5nZXRUaW1lKCk7XG4gIGlmIChkZShjKSkgcmV0dXJuIG51bGw7XG4gIHZhciBoID0gQmlnSW50KGMpICogR2U7XG4gIHJldHVybiBoID0gaCArIEJpZ0ludChsKSAqIERlLCBoID0gaCArIEJpZ0ludChkKSwgaCA8IE1lIHx8IGggPiBSZSA/IG51bGwgOiBoO1xufVxuZnVuY3Rpb24gR2V0SVNPUGFydHNGcm9tRXBvY2godCkge1xuICB2YXIgX2Rpdm1vZDQgPSBkaXZtb2QodCwgR2UpLFxuICAgIHIgPSBfZGl2bW9kNC5xdW90aWVudCxcbiAgICBvID0gX2Rpdm1vZDQucmVtYWluZGVyO1xuICB2YXIgbiA9IE51bWJlcihyKSxcbiAgICBhID0gTnVtYmVyKG8pO1xuICBhIDwgMCAmJiAoYSArPSAxZTYsIG4gLT0gMSk7XG4gIHZhciBpID0gaWUoYSAvIDFlMykgJSAxZTMsXG4gICAgcyA9IGEgJSAxZTMsXG4gICAgbCA9IG5ldyBEYXRlKG4pO1xuICByZXR1cm4ge1xuICAgIGVwb2NoTWlsbGlzZWNvbmRzOiBuLFxuICAgIHllYXI6IGwuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtb250aDogbC5nZXRVVENNb250aCgpICsgMSxcbiAgICBkYXk6IGwuZ2V0VVRDRGF0ZSgpLFxuICAgIGhvdXI6IGwuZ2V0VVRDSG91cnMoKSxcbiAgICBtaW51dGU6IGwuZ2V0VVRDTWludXRlcygpLFxuICAgIHNlY29uZDogbC5nZXRVVENTZWNvbmRzKCksXG4gICAgbWlsbGlzZWNvbmQ6IGwuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gICAgbWljcm9zZWNvbmQ6IGksXG4gICAgbmFub3NlY29uZDogc1xuICB9O1xufVxuZnVuY3Rpb24gR2V0TmFtZWRUaW1lWm9uZURhdGVUaW1lUGFydHMoZSwgdCkge1xuICB2YXIgX0dldElTT1BhcnRzRnJvbUVwb2NoMiA9IEdldElTT1BhcnRzRnJvbUVwb2NoKHQpLFxuICAgIHIgPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gyLmVwb2NoTWlsbGlzZWNvbmRzLFxuICAgIG8gPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gyLm1pbGxpc2Vjb25kLFxuICAgIG4gPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gyLm1pY3Jvc2Vjb25kLFxuICAgIGEgPSBfR2V0SVNPUGFydHNGcm9tRXBvY2gyLm5hbm9zZWNvbmQsXG4gICAgX0dldEZvcm1hdHRlclBhcnRzID0gZnVuY3Rpb24gR2V0Rm9ybWF0dGVyUGFydHMoZSwgdCkge1xuICAgICAgdmFyIHIgPSBnZXRJbnRsRGF0ZVRpbWVGb3JtYXRFblVzRm9yVGltZVpvbmUoZSkuZm9ybWF0KG5ldyBEYXRlKHQpKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZUZyb21FblVzRm9ybWF0KGUpIHtcbiAgICAgICAgdmFyIHQgPSBlLnNwbGl0KC9bXlxcd10rLyk7XG4gICAgICAgIGlmICg3ICE9PSB0Lmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJleHBlY3RlZCA3IHBhcnRzIGluIFxcXCJcIi5jb25jYXQoZSkpO1xuICAgICAgICB2YXIgciA9ICt0WzBdLFxuICAgICAgICAgIG8gPSArdFsxXTtcbiAgICAgICAgdmFyIG4gPSArdFsyXTtcbiAgICAgICAgdmFyIGEgPSB0WzNdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChcIkJcIiA9PT0gYSB8fCBcIkJDXCIgPT09IGEpIG4gPSAxIC0gbjtlbHNlIGlmIChcIkFcIiAhPT0gYSAmJiBcIkFEXCIgIT09IGEpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5rbm93biBlcmEgXCIuY29uY2F0KGEsIFwiIGluIFxcXCJcIikuY29uY2F0KGUpKTtcbiAgICAgICAgdmFyIGkgPSArdFs0XTtcbiAgICAgICAgMjQgPT09IGkgJiYgKGkgPSAwKTtcbiAgICAgICAgdmFyIHMgPSArdFs1XSxcbiAgICAgICAgICBsID0gK3RbNl07XG4gICAgICAgIGlmICghKG1lKG4pICYmIG1lKHIpICYmIG1lKG8pICYmIG1lKGkpICYmIG1lKHMpICYmIG1lKGwpKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlciBpbiBcXFwiXCIuY29uY2F0KGUpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB5ZWFyOiBuLFxuICAgICAgICAgIG1vbnRoOiByLFxuICAgICAgICAgIGRheTogbyxcbiAgICAgICAgICBob3VyOiBpLFxuICAgICAgICAgIG1pbnV0ZTogcyxcbiAgICAgICAgICBzZWNvbmQ6IGxcbiAgICAgICAgfTtcbiAgICAgIH0ocik7XG4gICAgfShlLCByKSxcbiAgICBpID0gX0dldEZvcm1hdHRlclBhcnRzLnllYXIsXG4gICAgcyA9IF9HZXRGb3JtYXR0ZXJQYXJ0cy5tb250aCxcbiAgICBsID0gX0dldEZvcm1hdHRlclBhcnRzLmRheSxcbiAgICBkID0gX0dldEZvcm1hdHRlclBhcnRzLmhvdXIsXG4gICAgbSA9IF9HZXRGb3JtYXR0ZXJQYXJ0cy5taW51dGUsXG4gICAgYyA9IF9HZXRGb3JtYXR0ZXJQYXJ0cy5zZWNvbmQ7XG4gIHJldHVybiBCYWxhbmNlSVNPRGF0ZVRpbWUoaSwgcywgbCwgZCwgbSwgYywgbywgbiwgYSk7XG59XG5mdW5jdGlvbiBtYXhKU0JJKHQsIHIpIHtcbiAgcmV0dXJuIHQgPCByID8gciA6IHQ7XG59XG5mdW5jdGlvbiBhZnRlckxhdGVzdFBvc3NpYmxlVHpkYlJ1bGVDaGFuZ2UoKSB7XG4gIHJldHVybiBWZSgpICsgWmU7XG59XG5mdW5jdGlvbiBHZXROYW1lZFRpbWVab25lTmV4dFRyYW5zaXRpb24odCwgcikge1xuICBpZiAociA8IFBlKSByZXR1cm4gR2V0TmFtZWRUaW1lWm9uZU5leHRUcmFuc2l0aW9uKHQsIFBlKTtcbiAgdmFyIG8gPSByICsgQmUsXG4gICAgbiA9IG1heEpTQkkoYWZ0ZXJMYXRlc3RQb3NzaWJsZVR6ZGJSdWxlQ2hhbmdlKCksIG8pO1xuICB2YXIgYSA9IG1heEpTQkkoUGUsIHIpO1xuICB2YXIgaSA9IEdldE5hbWVkVGltZVpvbmVPZmZzZXROYW5vc2Vjb25kcyh0LCBhKTtcbiAgdmFyIHMgPSBhLFxuICAgIGwgPSBpO1xuICBmb3IgKDsgaSA9PT0gbCAmJiBCaWdJbnQoYSkgPCBuOykge1xuICAgIGlmIChzID0gYSArIE5lLCBzID4gUmUpIHJldHVybiBudWxsO1xuICAgIGwgPSBHZXROYW1lZFRpbWVab25lT2Zmc2V0TmFub3NlY29uZHModCwgcyksIGkgPT09IGwgJiYgKGEgPSBzKTtcbiAgfVxuICBpZiAoaSA9PT0gbCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBiaXNlY3QoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gR2V0TmFtZWRUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKHQsIGUpO1xuICB9LCBhLCBzLCBpLCBsKTtcbn1cbmZ1bmN0aW9uIEdldE5hbWVkVGltZVpvbmVQcmV2aW91c1RyYW5zaXRpb24odCwgcikge1xuICB2YXIgbyA9IGFmdGVyTGF0ZXN0UG9zc2libGVUemRiUnVsZUNoYW5nZSgpLFxuICAgIGEgPSByID4gbyxcbiAgICBpID0gYSA/IHIgLSBCZSA6IFBlO1xuICBpZiAoXCJBZnJpY2EvQ2FzYWJsYW5jYVwiID09PSB0IHx8IFwiQWZyaWNhL0VsX0FhaXVuXCIgPT09IHQpIHtcbiAgICB2YXIgX28xMyA9IEdldFNsb3QoVG9UZW1wb3JhbEluc3RhbnQoXCIyMDg4LTAxLTAxVDAwWlwiKSwgbik7XG4gICAgaWYgKF9vMTMgPCByKSByZXR1cm4gR2V0TmFtZWRUaW1lWm9uZVByZXZpb3VzVHJhbnNpdGlvbih0LCBfbzEzKTtcbiAgfVxuICB2YXIgcyA9IHIgLSBTZTtcbiAgaWYgKHMgPCBQZSkgcmV0dXJuIG51bGw7XG4gIHZhciBsID0gR2V0TmFtZWRUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKHQsIHMpO1xuICB2YXIgZCA9IHMsXG4gICAgbSA9IGw7XG4gIGZvciAoOyBsID09PSBtICYmIHMgPiBpOykge1xuICAgIGlmIChkID0gcyAtIE5lLCBkIDwgUGUpIHJldHVybiBudWxsO1xuICAgIG0gPSBHZXROYW1lZFRpbWVab25lT2Zmc2V0TmFub3NlY29uZHModCwgZCksIGwgPT09IG0gJiYgKHMgPSBkKTtcbiAgfVxuICBpZiAobCA9PT0gbSkge1xuICAgIGlmIChhKSB7XG4gICAgICB2YXIgX3IzNiA9IG8gLSBFZTtcbiAgICAgIHJldHVybiBHZXROYW1lZFRpbWVab25lUHJldmlvdXNUcmFuc2l0aW9uKHQsIF9yMzYpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gYmlzZWN0KGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIEdldE5hbWVkVGltZVpvbmVPZmZzZXROYW5vc2Vjb25kcyh0LCBlKTtcbiAgfSwgZCwgcywgbSwgbCk7XG59XG5mdW5jdGlvbiBMZWFwWWVhcihlKSB7XG4gIGlmICh2b2lkIDAgPT09IGUpIHJldHVybiAhMTtcbiAgcmV0dXJuIGUgJSA0ID09IDAgJiYgKCEoZSAlIDEwMCA9PSAwKSB8fCBlICUgNDAwID09IDApO1xufVxuZnVuY3Rpb24gSVNPRGF5c0luTW9udGgoZSwgdCkge1xuICByZXR1cm4ge1xuICAgIHN0YW5kYXJkOiBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV0sXG4gICAgbGVhcHllYXI6IFszMSwgMjksIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVxuICB9W0xlYXBZZWFyKGUpID8gXCJsZWFweWVhclwiIDogXCJzdGFuZGFyZFwiXVt0IC0gMV07XG59XG5mdW5jdGlvbiBEYXlPZldlZWsoZSwgdCwgcikge1xuICB2YXIgbyA9IHQgKyAodCA8IDMgPyAxMCA6IC0yKSxcbiAgICBuID0gZSAtICh0IDwgMyA/IDEgOiAwKSxcbiAgICBhID0gaWUobiAvIDEwMCksXG4gICAgaSA9IG4gLSAxMDAgKiBhLFxuICAgIHMgPSAociArIGllKDIuNiAqIG8gLSAuMikgKyAoaSArIGllKGkgLyA0KSkgKyAoaWUoYSAvIDQpIC0gMiAqIGEpKSAlIDc7XG4gIHJldHVybiBzICsgKHMgPD0gMCA/IDcgOiAwKTtcbn1cbmZ1bmN0aW9uIERheU9mWWVhcihlLCB0LCByKSB7XG4gIHZhciBvID0gcjtcbiAgZm9yICh2YXIgX3IzNyA9IHQgLSAxOyBfcjM3ID4gMDsgX3IzNy0tKSBvICs9IElTT0RheXNJbk1vbnRoKGUsIF9yMzcpO1xuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIFdlZWtPZlllYXIoZSwgdCwgcikge1xuICB2YXIgbyA9IERheU9mWWVhcihlLCB0LCByKSxcbiAgICBuID0gRGF5T2ZXZWVrKGUsIHQsIHIpIHx8IDcsXG4gICAgYSA9IERheU9mV2VlayhlLCAxLCAxKSxcbiAgICBpID0gaWUoKG8gLSBuICsgMTApIC8gNyk7XG4gIHJldHVybiBpIDwgMSA/IDUgPT09IGEgfHwgNiA9PT0gYSAmJiBMZWFwWWVhcihlIC0gMSkgPyB7XG4gICAgd2VlazogNTMsXG4gICAgeWVhcjogZSAtIDFcbiAgfSA6IHtcbiAgICB3ZWVrOiA1MixcbiAgICB5ZWFyOiBlIC0gMVxuICB9IDogNTMgPT09IGkgJiYgKExlYXBZZWFyKGUpID8gMzY2IDogMzY1KSAtIG8gPCA0IC0gbiA/IHtcbiAgICB3ZWVrOiAxLFxuICAgIHllYXI6IGUgKyAxXG4gIH0gOiB7XG4gICAgd2VlazogaSxcbiAgICB5ZWFyOiBlXG4gIH07XG59XG5mdW5jdGlvbiBEdXJhdGlvblNpZ24oZSwgdCwgciwgbywgbiwgYSwgaSwgcywgbCwgZCkge1xuICBmb3IgKHZhciBfaTcgPSAwLCBfYXJyMiA9IFtlLCB0LCByLCBvLCBuLCBhLCBpLCBzLCBsLCBkXTsgX2k3IDwgX2FycjIubGVuZ3RoOyBfaTcrKykge1xuICAgIHZhciBfbTIgPSBfYXJyMltfaTddO1xuICAgIGlmICgwICE9PSBfbTIpIHJldHVybiBfbTIgPCAwID8gLTEgOiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gQmFsYW5jZUlTT1llYXJNb250aChlLCB0KSB7XG4gIHZhciByID0gZSxcbiAgICBvID0gdDtcbiAgaWYgKCFtZShyKSB8fCAhbWUobykpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5maW5pdHkgaXMgb3V0IG9mIHJhbmdlXCIpO1xuICByZXR1cm4gbyAtPSAxLCByICs9IGllKG8gLyAxMiksIG8gJT0gMTIsIG8gPCAwICYmIChvICs9IDEyKSwgbyArPSAxLCB7XG4gICAgeWVhcjogcixcbiAgICBtb250aDogb1xuICB9O1xufVxuZnVuY3Rpb24gQmFsYW5jZUlTT0RhdGUoZSwgdCwgcikge1xuICB2YXIgbyA9IGUsXG4gICAgbiA9IHQsXG4gICAgYSA9IHI7XG4gIGlmICghbWUoYSkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5maW5pdHkgaXMgb3V0IG9mIHJhbmdlXCIpO1xuICB2YXIgX0JhbGFuY2VJU09ZZWFyTW9udGggPSBCYWxhbmNlSVNPWWVhck1vbnRoKG8sIG4pO1xuICBvID0gX0JhbGFuY2VJU09ZZWFyTW9udGgueWVhcjtcbiAgbiA9IF9CYWxhbmNlSVNPWWVhck1vbnRoLm1vbnRoO1xuICB2YXIgaSA9IDE0NjA5NztcbiAgaWYgKGFlKGEpID4gaSkge1xuICAgIHZhciBfZTI0ID0gbGUoYSAvIGkpO1xuICAgIG8gKz0gNDAwICogX2UyNCwgYSAtPSBfZTI0ICogaTtcbiAgfVxuICB2YXIgcyA9IDAsXG4gICAgbCA9IG4gPiAyID8gbyA6IG8gLSAxO1xuICBmb3IgKDsgcyA9IExlYXBZZWFyKGwpID8gMzY2IDogMzY1LCBhIDwgLXM7KSBvIC09IDEsIGwgLT0gMSwgYSArPSBzO1xuICBmb3IgKGwgKz0gMTsgcyA9IExlYXBZZWFyKGwpID8gMzY2IDogMzY1LCBhID4gczspIG8gKz0gMSwgbCArPSAxLCBhIC09IHM7XG4gIGZvciAoOyBhIDwgMTspIHtcbiAgICB2YXIgX0JhbGFuY2VJU09ZZWFyTW9udGgyO1xuICAgIChfQmFsYW5jZUlTT1llYXJNb250aDIgPSBCYWxhbmNlSVNPWWVhck1vbnRoKG8sIG4gLSAxKSwgbyA9IF9CYWxhbmNlSVNPWWVhck1vbnRoMi55ZWFyLCBuID0gX0JhbGFuY2VJU09ZZWFyTW9udGgyLm1vbnRoKSwgYSArPSBJU09EYXlzSW5Nb250aChvLCBuKTtcbiAgfVxuICBmb3IgKDsgYSA+IElTT0RheXNJbk1vbnRoKG8sIG4pOykge1xuICAgIHZhciBfQmFsYW5jZUlTT1llYXJNb250aDM7XG4gICAgYSAtPSBJU09EYXlzSW5Nb250aChvLCBuKSwgKF9CYWxhbmNlSVNPWWVhck1vbnRoMyA9IEJhbGFuY2VJU09ZZWFyTW9udGgobywgbiArIDEpLCBvID0gX0JhbGFuY2VJU09ZZWFyTW9udGgzLnllYXIsIG4gPSBfQmFsYW5jZUlTT1llYXJNb250aDMubW9udGgpO1xuICB9XG4gIHJldHVybiB7XG4gICAgeWVhcjogbyxcbiAgICBtb250aDogbixcbiAgICBkYXk6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIEJhbGFuY2VJU09EYXRlVGltZShlLCB0LCByLCBvLCBuLCBhLCBpLCBzLCBsKSB7XG4gIHZhciBfQmFsYW5jZVRpbWUgPSBCYWxhbmNlVGltZShvLCBuLCBhLCBpLCBzLCBsKSxcbiAgICBkID0gX0JhbGFuY2VUaW1lLmRlbHRhRGF5cyxcbiAgICBtID0gX0JhbGFuY2VUaW1lLmhvdXIsXG4gICAgYyA9IF9CYWxhbmNlVGltZS5taW51dGUsXG4gICAgaCA9IF9CYWxhbmNlVGltZS5zZWNvbmQsXG4gICAgdSA9IF9CYWxhbmNlVGltZS5taWxsaXNlY29uZCxcbiAgICBUID0gX0JhbGFuY2VUaW1lLm1pY3Jvc2Vjb25kLFxuICAgIHAgPSBfQmFsYW5jZVRpbWUubmFub3NlY29uZCxcbiAgICBfQmFsYW5jZUlTT0RhdGUgPSBCYWxhbmNlSVNPRGF0ZShlLCB0LCByICsgZCksXG4gICAgZiA9IF9CYWxhbmNlSVNPRGF0ZS55ZWFyLFxuICAgIHkgPSBfQmFsYW5jZUlTT0RhdGUubW9udGgsXG4gICAgSSA9IF9CYWxhbmNlSVNPRGF0ZS5kYXk7XG4gIHJldHVybiB7XG4gICAgeWVhcjogZixcbiAgICBtb250aDogeSxcbiAgICBkYXk6IEksXG4gICAgaG91cjogbSxcbiAgICBtaW51dGU6IGMsXG4gICAgc2Vjb25kOiBoLFxuICAgIG1pbGxpc2Vjb25kOiB1LFxuICAgIG1pY3Jvc2Vjb25kOiBULFxuICAgIG5hbm9zZWNvbmQ6IHBcbiAgfTtcbn1cbmZ1bmN0aW9uIEJhbGFuY2VUaW1lKHQsIHIsIG8sIG4sIGEsIGkpIHtcbiAgdmFyIF9Ob25OZWdhdGl2ZUJpZ0ludERpdiwgX05vbk5lZ2F0aXZlQmlnSW50RGl2MiwgX05vbk5lZ2F0aXZlQmlnSW50RGl2MywgX05vbk5lZ2F0aXZlQmlnSW50RGl2NCwgX05vbk5lZ2F0aXZlQmlnSW50RGl2NSwgX05vbk5lZ2F0aXZlQmlnSW50RGl2NjtcbiAgdmFyIHMsXG4gICAgbCA9IEJpZ0ludCh0KSxcbiAgICBkID0gQmlnSW50KHIpLFxuICAgIG0gPSBCaWdJbnQobyksXG4gICAgYyA9IEJpZ0ludChuKSxcbiAgICBoID0gQmlnSW50KGEpLFxuICAgIHUgPSBCaWdJbnQoaSk7XG4gIHJldHVybiAoX05vbk5lZ2F0aXZlQmlnSW50RGl2ID0gTm9uTmVnYXRpdmVCaWdJbnREaXZtb2QodSwgRGUpLCBzID0gX05vbk5lZ2F0aXZlQmlnSW50RGl2LnF1b3RpZW50LCB1ID0gX05vbk5lZ2F0aXZlQmlnSW50RGl2LnJlbWFpbmRlciksIGggPSBoICsgcywgKF9Ob25OZWdhdGl2ZUJpZ0ludERpdjIgPSBOb25OZWdhdGl2ZUJpZ0ludERpdm1vZChoLCBEZSksIHMgPSBfTm9uTmVnYXRpdmVCaWdJbnREaXYyLnF1b3RpZW50LCBoID0gX05vbk5lZ2F0aXZlQmlnSW50RGl2Mi5yZW1haW5kZXIpLCBjID0gYyArIHMsIChfTm9uTmVnYXRpdmVCaWdJbnREaXYzID0gTm9uTmVnYXRpdmVCaWdJbnREaXZtb2QoYywgRGUpLCBzID0gX05vbk5lZ2F0aXZlQmlnSW50RGl2My5xdW90aWVudCwgYyA9IF9Ob25OZWdhdGl2ZUJpZ0ludERpdjMucmVtYWluZGVyKSwgbSA9IG0gKyBzLCAoX05vbk5lZ2F0aXZlQmlnSW50RGl2NCA9IE5vbk5lZ2F0aXZlQmlnSW50RGl2bW9kKG0sIGdlKSwgcyA9IF9Ob25OZWdhdGl2ZUJpZ0ludERpdjQucXVvdGllbnQsIG0gPSBfTm9uTmVnYXRpdmVCaWdJbnREaXY0LnJlbWFpbmRlciksIGQgPSBkICsgcywgKF9Ob25OZWdhdGl2ZUJpZ0ludERpdjUgPSBOb25OZWdhdGl2ZUJpZ0ludERpdm1vZChkLCBnZSksIHMgPSBfTm9uTmVnYXRpdmVCaWdJbnREaXY1LnF1b3RpZW50LCBkID0gX05vbk5lZ2F0aXZlQmlnSW50RGl2NS5yZW1haW5kZXIpLCBsID0gbCArIHMsIChfTm9uTmVnYXRpdmVCaWdJbnREaXY2ID0gTm9uTmVnYXRpdmVCaWdJbnREaXZtb2QobCwgd2UpLCBzID0gX05vbk5lZ2F0aXZlQmlnSW50RGl2Ni5xdW90aWVudCwgbCA9IF9Ob25OZWdhdGl2ZUJpZ0ludERpdjYucmVtYWluZGVyKSwge1xuICAgIGRlbHRhRGF5czogTnVtYmVyKHMpLFxuICAgIGhvdXI6IE51bWJlcihsKSxcbiAgICBtaW51dGU6IE51bWJlcihkKSxcbiAgICBzZWNvbmQ6IE51bWJlcihtKSxcbiAgICBtaWxsaXNlY29uZDogTnVtYmVyKGMpLFxuICAgIG1pY3Jvc2Vjb25kOiBOdW1iZXIoaCksXG4gICAgbmFub3NlY29uZDogTnVtYmVyKHUpXG4gIH07XG59XG5mdW5jdGlvbiBUb3RhbER1cmF0aW9uTmFub3NlY29uZHModCwgciwgbywgbiwgYSwgaSwgcywgbCkge1xuICB2YXIgZCA9IEJpZ0ludCh0KTtcbiAgdmFyIG0gPSBCaWdJbnQocyk7XG4gIDAgIT09IHQgJiYgKG0gPSBCaWdJbnQocykgLSBCaWdJbnQobCkpO1xuICB2YXIgYyA9IEJpZ0ludChyKSArIGQgKiAyNG4sXG4gICAgaCA9IEJpZ0ludChvKSArIGMgKiBnZSxcbiAgICB1ID0gQmlnSW50KG4pICsgaCAqIGdlLFxuICAgIFQgPSBCaWdJbnQoYSkgKyB1ICogRGUsXG4gICAgcCA9IEJpZ0ludChpKSArIFQgKiBEZTtcbiAgcmV0dXJuIEJpZ0ludChtKSArIHAgKiBEZTtcbn1cbmZ1bmN0aW9uIE5hbm9zZWNvbmRzVG9EYXlzKHQsIHIpIHtcbiAgdmFyIG8gPSBHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIiksXG4gICAgYSA9IHNlKE51bWJlcih0KSk7XG4gIHZhciBmID0gQmlnSW50KHQpLFxuICAgIHkgPSA4NjRlMTE7XG4gIGlmICgwID09PSBhKSByZXR1cm4ge1xuICAgIGRheXM6IDAsXG4gICAgbmFub3NlY29uZHM6IEllLFxuICAgIGRheUxlbmd0aE5zOiB5XG4gIH07XG4gIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUocikpIHtcbiAgICB2YXIgX2Rpdm1vZDU7XG4gICAgdmFyIF90MjQ7XG4gICAgcmV0dXJuIChfZGl2bW9kNSA9IGRpdm1vZChmLCBCaWdJbnQoeSkpLCBfdDI0ID0gX2Rpdm1vZDUucXVvdGllbnQsIGYgPSBfZGl2bW9kNS5yZW1haW5kZXIpLCB7XG4gICAgICBkYXlzOiBOdW1iZXIoX3QyNCksXG4gICAgICBuYW5vc2Vjb25kczogZixcbiAgICAgIGRheUxlbmd0aE5zOiB5XG4gICAgfTtcbiAgfVxuICB2YXIgSSA9IEdldFNsb3QociwgbiksXG4gICAgdyA9IEdldFNsb3QociwgUyksXG4gICAgRCA9IEkgKyBmLFxuICAgIEcgPSBuZXcgbyhEKSxcbiAgICB2ID0gR2V0U2xvdChyLCBnKSxcbiAgICBDID0gR2V0U2xvdChyLCBwKSxcbiAgICBPID0gR2V0UGxhaW5EYXRlVGltZUZvcih2LCB3LCBDKSxcbiAgICBiID0gR2V0UGxhaW5EYXRlVGltZUZvcih2LCBHLCBDKTtcbiAgdmFyIF9EaWZmZXJlbmNlSVNPRGF0ZVRpbSA9IERpZmZlcmVuY2VJU09EYXRlVGltZShHZXRTbG90KE8sIGkpLCBHZXRTbG90KE8sIHMpLCBHZXRTbG90KE8sIGwpLCBHZXRTbG90KE8sIGQpLCBHZXRTbG90KE8sIG0pLCBHZXRTbG90KE8sIGMpLCBHZXRTbG90KE8sIGgpLCBHZXRTbG90KE8sIHUpLCBHZXRTbG90KE8sIFQpLCBHZXRTbG90KGIsIGkpLCBHZXRTbG90KGIsIHMpLCBHZXRTbG90KGIsIGwpLCBHZXRTbG90KGIsIGQpLCBHZXRTbG90KGIsIG0pLCBHZXRTbG90KGIsIGMpLCBHZXRTbG90KGIsIGgpLCBHZXRTbG90KGIsIHUpLCBHZXRTbG90KGIsIFQpLCBDLCBcImRheVwiLCBUZShudWxsKSksXG4gICAgRSA9IF9EaWZmZXJlbmNlSVNPRGF0ZVRpbS5kYXlzLFxuICAgIE0gPSBBZGRab25lZERhdGVUaW1lKHcsIHYsIEMsIDAsIDAsIDAsIEUsIDAsIDAsIDAsIDAsIDAsIDApLFxuICAgIFIgPSBCaWdJbnQoRSk7XG4gIGlmICgxID09PSBhKSBmb3IgKDsgUiA+IEllICYmIE0gPiBEOykgUiA9IFIgLSBTZSwgTSA9IEFkZFpvbmVkRGF0ZVRpbWUodywgdiwgQywgMCwgMCwgMCwgTnVtYmVyKFIpLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgZiA9IEQgLSBNO1xuICB2YXIgRiA9ICExLFxuICAgIFkgPSBuZXcgbyhNKTtcbiAgZG8ge1xuICAgIHZhciBfdDI1ID0gQWRkWm9uZWREYXRlVGltZShZLCB2LCBDLCAwLCAwLCAwLCBhLCAwLCAwLCAwLCAwLCAwLCAwKSxcbiAgICAgIF9yMzggPSBHZXRTbG90KFksIG4pO1xuICAgIHkgPSBOdW1iZXIoX3QyNSAtIF9yMzgpLCBGID0gKGYgLSBCaWdJbnQoeSkpICogQmlnSW50KGEpID49IEllLCBGICYmIChmID0gZiAtIEJpZ0ludCh5KSwgWSA9IG5ldyBvKF90MjUpLCBSID0gUiArIEJpZ0ludChhKSk7XG4gIH0gd2hpbGUgKEYpO1xuICBpZiAoIWlzWmVybyhSKSAmJiBzaWduSlNCSShSKSAhPT0gYSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaW1lIHpvbmUgb3IgY2FsZW5kYXIgY29udmVydGVkIG5hbm9zZWNvbmRzIGludG8gYSBudW1iZXIgb2YgZGF5cyB3aXRoIHRoZSBvcHBvc2l0ZSBzaWduXCIpO1xuICBpZiAoIWlzWmVybyhmKSAmJiBzaWduSlNCSShmKSAhPT0gYSkge1xuICAgIGlmIChpc05lZ2F0aXZlSlNCSShmKSAmJiAxID09PSBhKSB0aHJvdyBuZXcgRXJyb3IoXCJhc3NlcnQgbm90IHJlYWNoZWRcIik7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaW1lIHpvbmUgb3IgY2FsZW5kYXIgZW5kZWQgdXAgd2l0aCBhIHJlbWFpbmRlciBvZiBuYW5vc2Vjb25kcyB3aXRoIHRoZSBvcHBvc2l0ZSBzaWduXCIpO1xuICB9XG4gIGlmIChhYnMoZikgPj0gYWJzKEJpZ0ludCh5KSkpIHRocm93IG5ldyBFcnJvcihcImFzc2VydCBub3QgcmVhY2hlZFwiKTtcbiAgcmV0dXJuIHtcbiAgICBkYXlzOiBOdW1iZXIoUiksXG4gICAgbmFub3NlY29uZHM6IGYsXG4gICAgZGF5TGVuZ3RoTnM6IGFlKHkpXG4gIH07XG59XG5mdW5jdGlvbiBCYWxhbmNlRHVyYXRpb24oZSwgdCwgciwgbywgbiwgYSwgaSwgcywgbCkge1xuICB2YXIgZCA9IEJhbGFuY2VQb3NzaWJseUluZmluaXRlRHVyYXRpb24oZSwgdCwgciwgbywgbiwgYSwgaSwgcywgbCk7XG4gIGlmIChcInBvc2l0aXZlIG92ZXJmbG93XCIgPT09IGQgfHwgXCJuZWdhdGl2ZSBvdmVyZmxvd1wiID09PSBkKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cmF0aW9uIG91dCBvZiByYW5nZVwiKTtcbiAgcmV0dXJuIGQ7XG59XG5mdW5jdGlvbiBCYWxhbmNlUG9zc2libHlJbmZpbml0ZUR1cmF0aW9uKHQsIHIsIG8sIGEsIGksIHMsIGwsIGQsIG0pIHtcbiAgdmFyIF9OYW5vc2Vjb25kc1RvRGF5cywgX2Rpdm1vZDYsIF9kaXZtb2Q3LCBfZGl2bW9kOCwgX2Rpdm1vZDksIF9kaXZtb2QxMCwgX2Rpdm1vZDExLCBfZGl2bW9kMTIsIF9kaXZtb2QxMywgX2Rpdm1vZDE0LCBfZGl2bW9kMTUsIF9kaXZtb2QxNiwgX2Rpdm1vZDE3LCBfZGl2bW9kMTgsIF9kaXZtb2QxOTtcbiAgdmFyIGMsXG4gICAgaCxcbiAgICB1LFxuICAgIFQsXG4gICAgZixcbiAgICB5LFxuICAgIEkgPSB0O1xuICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUobSkpIHtcbiAgICB2YXIgX3QyNiA9IEFkZFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChtLCBTKSwgR2V0U2xvdChtLCBnKSwgR2V0U2xvdChtLCBwKSwgMCwgMCwgMCwgSSwgciwgbywgYSwgaSwgcywgbCksXG4gICAgICBfZCA9IEdldFNsb3QobSwgbik7XG4gICAgYyA9IF90MjYgLSBfZDtcbiAgfSBlbHNlIGMgPSBUb3RhbER1cmF0aW9uTmFub3NlY29uZHMoSSwgciwgbywgYSwgaSwgcywgbCwgMCk7XG4gIFwieWVhclwiID09PSBkIHx8IFwibW9udGhcIiA9PT0gZCB8fCBcIndlZWtcIiA9PT0gZCB8fCBcImRheVwiID09PSBkID8gKF9OYW5vc2Vjb25kc1RvRGF5cyA9IE5hbm9zZWNvbmRzVG9EYXlzKGMsIG0pLCBJID0gX05hbm9zZWNvbmRzVG9EYXlzLmRheXMsIGMgPSBfTmFub3NlY29uZHNUb0RheXMubmFub3NlY29uZHMsIF9OYW5vc2Vjb25kc1RvRGF5cykgOiBJID0gMDtcbiAgdmFyIHcgPSBjIDwgSWUgPyAtMSA6IDE7XG4gIHN3aXRjaCAoYyA9IGFicyhjKSwgaCA9IHUgPSBUID0gZiA9IHkgPSBJZSwgZCkge1xuICAgIGNhc2UgXCJ5ZWFyXCI6XG4gICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgY2FzZSBcIndlZWtcIjpcbiAgICBjYXNlIFwiZGF5XCI6XG4gICAgY2FzZSBcImhvdXJcIjpcbiAgICAgIChfZGl2bW9kNiA9IGRpdm1vZChjLCBEZSksIGggPSBfZGl2bW9kNi5xdW90aWVudCwgYyA9IF9kaXZtb2Q2LnJlbWFpbmRlciksIChfZGl2bW9kNyA9IGRpdm1vZChoLCBEZSksIHUgPSBfZGl2bW9kNy5xdW90aWVudCwgaCA9IF9kaXZtb2Q3LnJlbWFpbmRlciksIChfZGl2bW9kOCA9IGRpdm1vZCh1LCBEZSksIFQgPSBfZGl2bW9kOC5xdW90aWVudCwgdSA9IF9kaXZtb2Q4LnJlbWFpbmRlciksIChfZGl2bW9kOSA9IGRpdm1vZChULCBnZSksIGYgPSBfZGl2bW9kOS5xdW90aWVudCwgVCA9IF9kaXZtb2Q5LnJlbWFpbmRlciksIChfZGl2bW9kMTAgPSBkaXZtb2QoZiwgZ2UpLCB5ID0gX2Rpdm1vZDEwLnF1b3RpZW50LCBmID0gX2Rpdm1vZDEwLnJlbWFpbmRlcik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibWludXRlXCI6XG4gICAgICAoX2Rpdm1vZDExID0gZGl2bW9kKGMsIERlKSwgaCA9IF9kaXZtb2QxMS5xdW90aWVudCwgYyA9IF9kaXZtb2QxMS5yZW1haW5kZXIpLCAoX2Rpdm1vZDEyID0gZGl2bW9kKGgsIERlKSwgdSA9IF9kaXZtb2QxMi5xdW90aWVudCwgaCA9IF9kaXZtb2QxMi5yZW1haW5kZXIpLCAoX2Rpdm1vZDEzID0gZGl2bW9kKHUsIERlKSwgVCA9IF9kaXZtb2QxMy5xdW90aWVudCwgdSA9IF9kaXZtb2QxMy5yZW1haW5kZXIpLCAoX2Rpdm1vZDE0ID0gZGl2bW9kKFQsIGdlKSwgZiA9IF9kaXZtb2QxNC5xdW90aWVudCwgVCA9IF9kaXZtb2QxNC5yZW1haW5kZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInNlY29uZFwiOlxuICAgICAgKF9kaXZtb2QxNSA9IGRpdm1vZChjLCBEZSksIGggPSBfZGl2bW9kMTUucXVvdGllbnQsIGMgPSBfZGl2bW9kMTUucmVtYWluZGVyKSwgKF9kaXZtb2QxNiA9IGRpdm1vZChoLCBEZSksIHUgPSBfZGl2bW9kMTYucXVvdGllbnQsIGggPSBfZGl2bW9kMTYucmVtYWluZGVyKSwgKF9kaXZtb2QxNyA9IGRpdm1vZCh1LCBEZSksIFQgPSBfZGl2bW9kMTcucXVvdGllbnQsIHUgPSBfZGl2bW9kMTcucmVtYWluZGVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtaWxsaXNlY29uZFwiOlxuICAgICAgKF9kaXZtb2QxOCA9IGRpdm1vZChjLCBEZSksIGggPSBfZGl2bW9kMTgucXVvdGllbnQsIGMgPSBfZGl2bW9kMTgucmVtYWluZGVyKSwgKF9kaXZtb2QxOSA9IGRpdm1vZChoLCBEZSksIHUgPSBfZGl2bW9kMTkucXVvdGllbnQsIGggPSBfZGl2bW9kMTkucmVtYWluZGVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtaWNyb3NlY29uZFwiOlxuICAgICAgdmFyIF9kaXZtb2QyMCA9IGRpdm1vZChjLCBEZSk7XG4gICAgICBoID0gX2Rpdm1vZDIwLnF1b3RpZW50O1xuICAgICAgYyA9IF9kaXZtb2QyMC5yZW1haW5kZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibmFub3NlY29uZFwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFzc2VydCBub3QgcmVhY2hlZFwiKTtcbiAgfVxuICB2YXIgRCA9IE51bWJlcih5KSAqIHcsXG4gICAgRyA9IE51bWJlcihmKSAqIHcsXG4gICAgdiA9IE51bWJlcihUKSAqIHcsXG4gICAgQyA9IE51bWJlcih1KSAqIHcsXG4gICAgTyA9IE51bWJlcihoKSAqIHcsXG4gICAgYiA9IE51bWJlcihjKSAqIHc7XG4gIGZvciAodmFyIF9pOCA9IDAsIF9hcnIzID0gW0ksIEQsIEcsIHYsIEMsIE8sIGJdOyBfaTggPCBfYXJyMy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgdmFyIF9lMjUgPSBfYXJyM1tfaThdO1xuICAgIGlmICghbWUoX2UyNSkpIHJldHVybiAxID09PSB3ID8gXCJwb3NpdGl2ZSBvdmVyZmxvd1wiIDogXCJuZWdhdGl2ZSBvdmVyZmxvd1wiO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF5czogSSxcbiAgICBob3VyczogRCxcbiAgICBtaW51dGVzOiBHLFxuICAgIHNlY29uZHM6IHYsXG4gICAgbWlsbGlzZWNvbmRzOiBDLFxuICAgIG1pY3Jvc2Vjb25kczogTyxcbiAgICBuYW5vc2Vjb25kczogYlxuICB9O1xufVxuZnVuY3Rpb24gVW5iYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh0LCByLCBvLCBuLCBhLCBpKSB7XG4gIHZhciBzID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKSxcbiAgICBsID0gRHVyYXRpb25TaWduKHQsIHIsIG8sIG4sIDAsIDAsIDAsIDAsIDAsIDApO1xuICBpZiAoMCA9PT0gbCkgcmV0dXJuIHtcbiAgICB5ZWFyczogdCxcbiAgICBtb250aHM6IHIsXG4gICAgd2Vla3M6IG8sXG4gICAgZGF5czogblxuICB9O1xuICB2YXIgZCA9IEJpZ0ludChsKTtcbiAgdmFyIG0sXG4gICAgYyxcbiAgICBoID0gQmlnSW50KHQpLFxuICAgIHUgPSBCaWdJbnQociksXG4gICAgVCA9IEJpZ0ludChvKSxcbiAgICBmID0gQmlnSW50KG4pO1xuICBpICYmIChjID0gVG9UZW1wb3JhbERhdGUoaSksIG0gPSBHZXRTbG90KGMsIHApKTtcbiAgdmFyIHkgPSBuZXcgcyhsKSxcbiAgICBJID0gbmV3IHMoMCwgbCksXG4gICAgUyA9IG5ldyBzKDAsIDAsIGwpO1xuICBzd2l0Y2ggKGEpIHtcbiAgICBjYXNlIFwieWVhclwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgICB7XG4gICAgICAgIGlmICghbSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJhIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciBtb250aHMgYmFsYW5jaW5nXCIpO1xuICAgICAgICB2YXIgX3QyNywgX3IzOTtcbiAgICAgICAgZm9yIChcInN0cmluZ1wiICE9IHR5cGVvZiBtICYmIChfdDI3ID0gR2V0TWV0aG9kKG0sIFwiZGF0ZUFkZFwiKSwgX3IzOSA9IEdldE1ldGhvZChtLCBcImRhdGVVbnRpbFwiKSk7ICFpc1plcm8oaCk7KSB7XG4gICAgICAgICAgdmFyIF9vMTQgPSBDYWxlbmRhckRhdGVBZGQobSwgYywgeSwgdm9pZCAwLCBfdDI3KSxcbiAgICAgICAgICAgIF9uOSA9IFRlKG51bGwpO1xuICAgICAgICAgIF9uOS5sYXJnZXN0VW5pdCA9IFwibW9udGhcIjtcbiAgICAgICAgICB2YXIgX2E2ID0gQ2FsZW5kYXJEYXRlVW50aWwobSwgYywgX28xNCwgX245LCBfcjM5KSxcbiAgICAgICAgICAgIF9pOSA9IEJpZ0ludChHZXRTbG90KF9hNiwgRCkpO1xuICAgICAgICAgIGMgPSBfbzE0LCB1ID0gdSArIF9pOSwgaCA9IGggLSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwid2Vla1wiOlxuICAgICAge1xuICAgICAgICBpZiAoIW0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3Igd2Vla3MgYmFsYW5jaW5nXCIpO1xuICAgICAgICB2YXIgX3QyOCA9IFwic3RyaW5nXCIgIT0gdHlwZW9mIG0gPyBHZXRNZXRob2QobSwgXCJkYXRlQWRkXCIpIDogdm9pZCAwO1xuICAgICAgICBmb3IgKDsgIWlzWmVybyhoKTspIHtcbiAgICAgICAgICB2YXIgX01vdmVSZWxhdGl2ZURhdGU7XG4gICAgICAgICAgdmFyIF9yNDAgPSB2b2lkIDA7XG4gICAgICAgICAgKF9Nb3ZlUmVsYXRpdmVEYXRlID0gTW92ZVJlbGF0aXZlRGF0ZShtLCBjLCB5LCBfdDI4KSwgYyA9IF9Nb3ZlUmVsYXRpdmVEYXRlLnJlbGF0aXZlVG8sIF9yNDAgPSBfTW92ZVJlbGF0aXZlRGF0ZS5kYXlzKSwgZiA9IGYgKyBCaWdJbnQoX3I0MCksIGggPSBoIC0gZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgIWlzWmVybyh1KTspIHtcbiAgICAgICAgICB2YXIgX01vdmVSZWxhdGl2ZURhdGUyO1xuICAgICAgICAgIHZhciBfcjQxID0gdm9pZCAwO1xuICAgICAgICAgIChfTW92ZVJlbGF0aXZlRGF0ZTIgPSBNb3ZlUmVsYXRpdmVEYXRlKG0sIGMsIEksIF90MjgpLCBjID0gX01vdmVSZWxhdGl2ZURhdGUyLnJlbGF0aXZlVG8sIF9yNDEgPSBfTW92ZVJlbGF0aXZlRGF0ZTIuZGF5cyksIGYgPSBmICsgQmlnSW50KF9yNDEpLCB1ID0gdSAtIGQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKGlzWmVybyhoKSAmJiBpc1plcm8odSkgJiYgaXNaZXJvKFQpKSBicmVhaztcbiAgICAgICAgaWYgKCFtKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImEgc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIGJhbGFuY2luZyBjYWxlbmRhciB1bml0c1wiKTtcbiAgICAgICAgdmFyIF90MjkgPSBcInN0cmluZ1wiICE9IHR5cGVvZiBtID8gR2V0TWV0aG9kKG0sIFwiZGF0ZUFkZFwiKSA6IHZvaWQgMDtcbiAgICAgICAgZm9yICg7ICFpc1plcm8oaCk7KSB7XG4gICAgICAgICAgdmFyIF9Nb3ZlUmVsYXRpdmVEYXRlMztcbiAgICAgICAgICB2YXIgX3I0MiA9IHZvaWQgMDtcbiAgICAgICAgICAoX01vdmVSZWxhdGl2ZURhdGUzID0gTW92ZVJlbGF0aXZlRGF0ZShtLCBjLCB5LCBfdDI5KSwgYyA9IF9Nb3ZlUmVsYXRpdmVEYXRlMy5yZWxhdGl2ZVRvLCBfcjQyID0gX01vdmVSZWxhdGl2ZURhdGUzLmRheXMpLCBmID0gZiArIEJpZ0ludChfcjQyKSwgaCA9IGggLSBkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyAhaXNaZXJvKHUpOykge1xuICAgICAgICAgIHZhciBfTW92ZVJlbGF0aXZlRGF0ZTQ7XG4gICAgICAgICAgdmFyIF9yNDMgPSB2b2lkIDA7XG4gICAgICAgICAgKF9Nb3ZlUmVsYXRpdmVEYXRlNCA9IE1vdmVSZWxhdGl2ZURhdGUobSwgYywgSSwgX3QyOSksIGMgPSBfTW92ZVJlbGF0aXZlRGF0ZTQucmVsYXRpdmVUbywgX3I0MyA9IF9Nb3ZlUmVsYXRpdmVEYXRlNC5kYXlzKSwgZiA9IGYgKyBCaWdJbnQoX3I0MyksIHUgPSB1IC0gZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgIWlzWmVybyhUKTspIHtcbiAgICAgICAgICB2YXIgX01vdmVSZWxhdGl2ZURhdGU1O1xuICAgICAgICAgIHZhciBfcjQ0ID0gdm9pZCAwO1xuICAgICAgICAgIChfTW92ZVJlbGF0aXZlRGF0ZTUgPSBNb3ZlUmVsYXRpdmVEYXRlKG0sIGMsIFMsIF90MjkpLCBjID0gX01vdmVSZWxhdGl2ZURhdGU1LnJlbGF0aXZlVG8sIF9yNDQgPSBfTW92ZVJlbGF0aXZlRGF0ZTUuZGF5cyksIGYgPSBmICsgQmlnSW50KF9yNDQpLCBUID0gVCAtIGQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB5ZWFyczogTnVtYmVyKGgpLFxuICAgIG1vbnRoczogTnVtYmVyKHUpLFxuICAgIHdlZWtzOiBOdW1iZXIoVCksXG4gICAgZGF5czogTnVtYmVyKGYpXG4gIH07XG59XG5mdW5jdGlvbiBDYWxjdWxhdGVPZmZzZXRTaGlmdChlLCB0LCByLCBvLCBuKSB7XG4gIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShlKSkge1xuICAgIHZhciBfYTcgPSBHZXRTbG90KGUsIFMpLFxuICAgICAgX2kxMCA9IEdldFNsb3QoZSwgZyksXG4gICAgICBfcyA9IEdldFNsb3QoZSwgcCksXG4gICAgICBfbDIgPSBHZXRPZmZzZXROYW5vc2Vjb25kc0ZvcihfaTEwLCBfYTcpLFxuICAgICAgX2QyID0gQWRkWm9uZWREYXRlVGltZShfYTcsIF9pMTAsIF9zLCB0LCByLCBvLCBuLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICByZXR1cm4gR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IoX2kxMCwgbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIikpKF9kMikpIC0gX2wyO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gQ3JlYXRlTmVnYXRlZFRlbXBvcmFsRHVyYXRpb24oZSkge1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuRHVyYXRpb24lXCIpKSgtR2V0U2xvdChlLCB3KSwgLUdldFNsb3QoZSwgRCksIC1HZXRTbG90KGUsIEcpLCAtR2V0U2xvdChlLCB2KSwgLUdldFNsb3QoZSwgQyksIC1HZXRTbG90KGUsIE8pLCAtR2V0U2xvdChlLCBiKSwgLUdldFNsb3QoZSwgRSksIC1HZXRTbG90KGUsIE0pLCAtR2V0U2xvdChlLCBSKSk7XG59XG5mdW5jdGlvbiBDb25zdHJhaW5Ub1JhbmdlKGUsIHQsIHIpIHtcbiAgcmV0dXJuIG9lKHIsIG5lKHQsIGUpKTtcbn1cbmZ1bmN0aW9uIENvbnN0cmFpbklTT0RhdGUoZSwgdCwgcikge1xuICB2YXIgbyA9IENvbnN0cmFpblRvUmFuZ2UodCwgMSwgMTIpO1xuICByZXR1cm4ge1xuICAgIHllYXI6IGUsXG4gICAgbW9udGg6IG8sXG4gICAgZGF5OiBDb25zdHJhaW5Ub1JhbmdlKHIsIDEsIElTT0RheXNJbk1vbnRoKGUsIG8pKVxuICB9O1xufVxuZnVuY3Rpb24gUmVqZWN0VG9SYW5nZShlLCB0LCByKSB7XG4gIGlmIChlIDwgdCB8fCBlID4gcikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ2YWx1ZSBvdXQgb2YgcmFuZ2U6IFwiLmNvbmNhdCh0LCBcIiA8PSBcIikuY29uY2F0KGUsIFwiIDw9IFwiKS5jb25jYXQocikpO1xufVxuZnVuY3Rpb24gUmVqZWN0SVNPRGF0ZShlLCB0LCByKSB7XG4gIFJlamVjdFRvUmFuZ2UodCwgMSwgMTIpLCBSZWplY3RUb1JhbmdlKHIsIDEsIElTT0RheXNJbk1vbnRoKGUsIHQpKTtcbn1cbmZ1bmN0aW9uIFJlamVjdERhdGVSYW5nZShlLCB0LCByKSB7XG4gIFJlamVjdERhdGVUaW1lUmFuZ2UoZSwgdCwgciwgMTIsIDAsIDAsIDAsIDAsIDApO1xufVxuZnVuY3Rpb24gUmVqZWN0VGltZShlLCB0LCByLCBvLCBuLCBhKSB7XG4gIFJlamVjdFRvUmFuZ2UoZSwgMCwgMjMpLCBSZWplY3RUb1JhbmdlKHQsIDAsIDU5KSwgUmVqZWN0VG9SYW5nZShyLCAwLCA1OSksIFJlamVjdFRvUmFuZ2UobywgMCwgOTk5KSwgUmVqZWN0VG9SYW5nZShuLCAwLCA5OTkpLCBSZWplY3RUb1JhbmdlKGEsIDAsIDk5OSk7XG59XG5mdW5jdGlvbiBSZWplY3REYXRlVGltZShlLCB0LCByLCBvLCBuLCBhLCBpLCBzLCBsKSB7XG4gIFJlamVjdElTT0RhdGUoZSwgdCwgciksIFJlamVjdFRpbWUobywgbiwgYSwgaSwgcywgbCk7XG59XG5mdW5jdGlvbiBSZWplY3REYXRlVGltZVJhbmdlKGUsIHQsIHIsIG8sIG4sIGEsIGksIHMsIGwpIHtcbiAgaWYgKFJlamVjdFRvUmFuZ2UoZSwgRmUsIFllKSwgZSA9PT0gRmUgJiYgbnVsbCA9PSBHZXRVVENFcG9jaE5hbm9zZWNvbmRzKGUsIHQsIHIgKyAxLCBvLCBuLCBhLCBpLCBzLCBsIC0gMSkgfHwgZSA9PT0gWWUgJiYgbnVsbCA9PSBHZXRVVENFcG9jaE5hbm9zZWNvbmRzKGUsIHQsIHIgLSAxLCBvLCBuLCBhLCBpLCBzLCBsICsgMSkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRGF0ZVRpbWUgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2VcIik7XG59XG5mdW5jdGlvbiBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHModCkge1xuICBpZiAodCA8IE1lIHx8IHQgPiBSZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnN0YW50IG91dHNpZGUgb2Ygc3VwcG9ydGVkIHJhbmdlXCIpO1xufVxuZnVuY3Rpb24gUmVqZWN0RHVyYXRpb24oZSwgdCwgciwgbywgbiwgYSwgaSwgcywgbCwgZCkge1xuICB2YXIgbSA9IER1cmF0aW9uU2lnbihlLCB0LCByLCBvLCBuLCBhLCBpLCBzLCBsLCBkKTtcbiAgZm9yICh2YXIgX2kxMSA9IDAsIF9hcnI0ID0gW2UsIHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGRdOyBfaTExIDwgX2FycjQubGVuZ3RoOyBfaTExKyspIHtcbiAgICB2YXIgX2MyID0gX2FycjRbX2kxMV07XG4gICAgaWYgKCFtZShfYzIpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImluZmluaXRlIHZhbHVlcyBub3QgYWxsb3dlZCBhcyBkdXJhdGlvbiBmaWVsZHNcIik7XG4gICAgdmFyIF9lMjYgPSBzZShfYzIpO1xuICAgIGlmICgwICE9PSBfZTI2ICYmIF9lMjYgIT09IG0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwibWl4ZWQtc2lnbiB2YWx1ZXMgbm90IGFsbG93ZWQgYXMgZHVyYXRpb24gZmllbGRzXCIpO1xuICB9XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlSVNPRGF0ZShlLCB0LCByLCBvLCBuLCBhLCBpKSB7XG4gIHN3aXRjaCAoaSkge1xuICAgIGNhc2UgXCJ5ZWFyXCI6XG4gICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgICB7XG4gICAgICAgIHZhciBfczIgPSAtQ29tcGFyZUlTT0RhdGUoZSwgdCwgciwgbywgbiwgYSk7XG4gICAgICAgIGlmICgwID09PSBfczIpIHJldHVybiB7XG4gICAgICAgICAgeWVhcnM6IDAsXG4gICAgICAgICAgbW9udGhzOiAwLFxuICAgICAgICAgIHdlZWtzOiAwLFxuICAgICAgICAgIGRheXM6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9sMyA9IHtcbiAgICAgICAgICAgIHllYXI6IGUsXG4gICAgICAgICAgICBtb250aDogdCxcbiAgICAgICAgICAgIGRheTogclxuICAgICAgICAgIH0sXG4gICAgICAgICAgX2QzID0ge1xuICAgICAgICAgICAgeWVhcjogbyxcbiAgICAgICAgICAgIG1vbnRoOiBuLFxuICAgICAgICAgICAgZGF5OiBhXG4gICAgICAgICAgfTtcbiAgICAgICAgdmFyIF9tMyA9IF9kMy55ZWFyIC0gX2wzLnllYXIsXG4gICAgICAgICAgX2MzID0gQWRkSVNPRGF0ZShlLCB0LCByLCBfbTMsIDAsIDAsIDAsIFwiY29uc3RyYWluXCIpLFxuICAgICAgICAgIF9oID0gLUNvbXBhcmVJU09EYXRlKF9jMy55ZWFyLCBfYzMubW9udGgsIF9jMy5kYXksIG8sIG4sIGEpO1xuICAgICAgICBpZiAoMCA9PT0gX2gpIHJldHVybiBcInllYXJcIiA9PT0gaSA/IHtcbiAgICAgICAgICB5ZWFyczogX20zLFxuICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICB3ZWVrczogMCxcbiAgICAgICAgICBkYXlzOiAwXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgeWVhcnM6IDAsXG4gICAgICAgICAgbW9udGhzOiAxMiAqIF9tMyxcbiAgICAgICAgICB3ZWVrczogMCxcbiAgICAgICAgICBkYXlzOiAwXG4gICAgICAgIH07XG4gICAgICAgIHZhciBfdSA9IF9kMy5tb250aCAtIF9sMy5tb250aDtcbiAgICAgICAgaWYgKF9oICE9PSBfczIgJiYgKF9tMyAtPSBfczIsIF91ICs9IDEyICogX3MyKSwgX2MzID0gQWRkSVNPRGF0ZShlLCB0LCByLCBfbTMsIF91LCAwLCAwLCBcImNvbnN0cmFpblwiKSwgX2ggPSAtQ29tcGFyZUlTT0RhdGUoX2MzLnllYXIsIF9jMy5tb250aCwgX2MzLmRheSwgbywgbiwgYSksIDAgPT09IF9oKSByZXR1cm4gXCJ5ZWFyXCIgPT09IGkgPyB7XG4gICAgICAgICAgeWVhcnM6IF9tMyxcbiAgICAgICAgICBtb250aHM6IF91LFxuICAgICAgICAgIHdlZWtzOiAwLFxuICAgICAgICAgIGRheXM6IDBcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICBtb250aHM6IF91ICsgMTIgKiBfbTMsXG4gICAgICAgICAgd2Vla3M6IDAsXG4gICAgICAgICAgZGF5czogMFxuICAgICAgICB9O1xuICAgICAgICBfaCAhPT0gX3MyICYmIChfdSAtPSBfczIsIF91ID09PSAtX3MyICYmIChfbTMgLT0gX3MyLCBfdSA9IDExICogX3MyKSwgX2MzID0gQWRkSVNPRGF0ZShlLCB0LCByLCBfbTMsIF91LCAwLCAwLCBcImNvbnN0cmFpblwiKSk7XG4gICAgICAgIHZhciBfVCA9IDA7XG4gICAgICAgIHJldHVybiBfVCA9IF9jMy5tb250aCA9PT0gX2QzLm1vbnRoID8gX2QzLmRheSAtIF9jMy5kYXkgOiBfczIgPCAwID8gLV9jMy5kYXkgLSAoSVNPRGF5c0luTW9udGgoX2QzLnllYXIsIF9kMy5tb250aCkgLSBfZDMuZGF5KSA6IF9kMy5kYXkgKyAoSVNPRGF5c0luTW9udGgoX2MzLnllYXIsIF9jMy5tb250aCkgLSBfYzMuZGF5KSwgXCJtb250aFwiID09PSBpICYmIChfdSArPSAxMiAqIF9tMywgX20zID0gMCksIHtcbiAgICAgICAgICB5ZWFyczogX20zLFxuICAgICAgICAgIG1vbnRoczogX3UsXG4gICAgICAgICAgd2Vla3M6IDAsXG4gICAgICAgICAgZGF5czogX1RcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlIFwid2Vla1wiOlxuICAgIGNhc2UgXCJkYXlcIjpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9zMywgX2w0LCBfZDQ7XG4gICAgICAgIENvbXBhcmVJU09EYXRlKGUsIHQsIHIsIG8sIG4sIGEpIDwgMCA/IChfbDQgPSB7XG4gICAgICAgICAgeWVhcjogZSxcbiAgICAgICAgICBtb250aDogdCxcbiAgICAgICAgICBkYXk6IHJcbiAgICAgICAgfSwgX3MzID0ge1xuICAgICAgICAgIHllYXI6IG8sXG4gICAgICAgICAgbW9udGg6IG4sXG4gICAgICAgICAgZGF5OiBhXG4gICAgICAgIH0sIF9kNCA9IDEpIDogKF9sNCA9IHtcbiAgICAgICAgICB5ZWFyOiBvLFxuICAgICAgICAgIG1vbnRoOiBuLFxuICAgICAgICAgIGRheTogYVxuICAgICAgICB9LCBfczMgPSB7XG4gICAgICAgICAgeWVhcjogZSxcbiAgICAgICAgICBtb250aDogdCxcbiAgICAgICAgICBkYXk6IHJcbiAgICAgICAgfSwgX2Q0ID0gLTEpO1xuICAgICAgICB2YXIgX200ID0gRGF5T2ZZZWFyKF9zMy55ZWFyLCBfczMubW9udGgsIF9zMy5kYXkpIC0gRGF5T2ZZZWFyKF9sNC55ZWFyLCBfbDQubW9udGgsIF9sNC5kYXkpO1xuICAgICAgICBmb3IgKHZhciBfZTI3ID0gX2w0LnllYXI7IF9lMjcgPCBfczMueWVhcjsgKytfZTI3KSBfbTQgKz0gTGVhcFllYXIoX2UyNykgPyAzNjYgOiAzNjU7XG4gICAgICAgIHZhciBfYzQgPSAwO1xuICAgICAgICByZXR1cm4gXCJ3ZWVrXCIgPT09IGkgJiYgKF9jNCA9IGllKF9tNCAvIDcpLCBfbTQgJT0gNyksIF9jNCAqPSBfZDQsIF9tNCAqPSBfZDQsIHtcbiAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICBtb250aHM6IDAsXG4gICAgICAgICAgd2Vla3M6IF9jNCxcbiAgICAgICAgICBkYXlzOiBfbTRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXNzZXJ0IG5vdCByZWFjaGVkXCIpO1xuICB9XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlVGltZShlLCB0LCByLCBvLCBuLCBhLCBpLCBzLCBsLCBkLCBtLCBjKSB7XG4gIHZhciBfQmFsYW5jZVRpbWUyO1xuICB2YXIgaCA9IGkgLSBlLFxuICAgIHUgPSBzIC0gdCxcbiAgICBUID0gbCAtIHIsXG4gICAgcCA9IGQgLSBvLFxuICAgIGYgPSBtIC0gbixcbiAgICB5ID0gYyAtIGE7XG4gIHZhciBJID0gRHVyYXRpb25TaWduKDAsIDAsIDAsIDAsIGgsIHUsIFQsIHAsIGYsIHkpO1xuICBoICo9IEksIHUgKj0gSSwgVCAqPSBJLCBwICo9IEksIGYgKj0gSSwgeSAqPSBJO1xuICB2YXIgUyA9IDA7XG4gIGlmICgoX0JhbGFuY2VUaW1lMiA9IEJhbGFuY2VUaW1lKGgsIHUsIFQsIHAsIGYsIHkpLCBTID0gX0JhbGFuY2VUaW1lMi5kZWx0YURheXMsIGggPSBfQmFsYW5jZVRpbWUyLmhvdXIsIHUgPSBfQmFsYW5jZVRpbWUyLm1pbnV0ZSwgVCA9IF9CYWxhbmNlVGltZTIuc2Vjb25kLCBwID0gX0JhbGFuY2VUaW1lMi5taWxsaXNlY29uZCwgZiA9IF9CYWxhbmNlVGltZTIubWljcm9zZWNvbmQsIHkgPSBfQmFsYW5jZVRpbWUyLm5hbm9zZWNvbmQpLCAwICE9IFMpIHRocm93IG5ldyBFcnJvcihcImFzc2VydGlvbiBmYWlsdXJlIGluIERpZmZlcmVuY2VUaW1lOiBfYnRfLltbRGF5c11dIHNob3VsZCBiZSAwXCIpO1xuICByZXR1cm4gaCAqPSBJLCB1ICo9IEksIFQgKj0gSSwgcCAqPSBJLCBmICo9IEksIHkgKj0gSSwge1xuICAgIGhvdXJzOiBoLFxuICAgIG1pbnV0ZXM6IHUsXG4gICAgc2Vjb25kczogVCxcbiAgICBtaWxsaXNlY29uZHM6IHAsXG4gICAgbWljcm9zZWNvbmRzOiBmLFxuICAgIG5hbm9zZWNvbmRzOiB5XG4gIH07XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlSW5zdGFudCh0LCByLCBvLCBuLCBhLCBpKSB7XG4gIHZhciBfUm91bmREdXJhdGlvbjI7XG4gIHZhciBzID0gciAtIHQ7XG4gIHZhciBsID0gMCxcbiAgICBkID0gMCxcbiAgICBtID0gTnVtYmVyKHMgJSBEZSksXG4gICAgYyA9IE51bWJlcihzIC8gRGUgJSBEZSksXG4gICAgaCA9IE51bWJlcihzIC8gR2UgJSBEZSksXG4gICAgdSA9IE51bWJlcihzIC8gdmUpO1xuICByZXR1cm4gKF9Sb3VuZER1cmF0aW9uMiA9IFJvdW5kRHVyYXRpb24oMCwgMCwgMCwgMCwgMCwgMCwgdSwgaCwgYywgbSwgbywgbiwgaSksIGwgPSBfUm91bmREdXJhdGlvbjIuaG91cnMsIGQgPSBfUm91bmREdXJhdGlvbjIubWludXRlcywgdSA9IF9Sb3VuZER1cmF0aW9uMi5zZWNvbmRzLCBoID0gX1JvdW5kRHVyYXRpb24yLm1pbGxpc2Vjb25kcywgYyA9IF9Sb3VuZER1cmF0aW9uMi5taWNyb3NlY29uZHMsIG0gPSBfUm91bmREdXJhdGlvbjIubmFub3NlY29uZHMpLCBCYWxhbmNlRHVyYXRpb24oMCwgbCwgZCwgdSwgaCwgYywgbSwgYSk7XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlSVNPRGF0ZVRpbWUoZSwgdCwgciwgbywgbiwgYSwgaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVCwgcCwgZiwgeSwgSSwgUywgZykge1xuICB2YXIgX0JhbGFuY2VJU09EYXRlMiwgX0JhbGFuY2VEdXJhdGlvbiwgX0JhbGFuY2VEdXJhdGlvbjI7XG4gIHZhciB3ID0gZSxcbiAgICBEID0gdCxcbiAgICBHID0gcixcbiAgICBfRGlmZmVyZW5jZVRpbWUgPSBEaWZmZXJlbmNlVGltZShvLCBuLCBhLCBpLCBzLCBsLCBoLCB1LCBULCBwLCBmLCB5KSxcbiAgICB2ID0gX0RpZmZlcmVuY2VUaW1lLmhvdXJzLFxuICAgIEMgPSBfRGlmZmVyZW5jZVRpbWUubWludXRlcyxcbiAgICBPID0gX0RpZmZlcmVuY2VUaW1lLnNlY29uZHMsXG4gICAgYiA9IF9EaWZmZXJlbmNlVGltZS5taWxsaXNlY29uZHMsXG4gICAgRSA9IF9EaWZmZXJlbmNlVGltZS5taWNyb3NlY29uZHMsXG4gICAgTSA9IF9EaWZmZXJlbmNlVGltZS5uYW5vc2Vjb25kcztcbiAgdmFyIFIgPSBEdXJhdGlvblNpZ24oMCwgMCwgMCwgMCwgdiwgQywgTywgYiwgRSwgTSk7XG4gIENvbXBhcmVJU09EYXRlKGQsIG0sIGMsIHcsIEQsIEcpID09PSAtUiAmJiAoKF9CYWxhbmNlSVNPRGF0ZTIgPSBCYWxhbmNlSVNPRGF0ZSh3LCBELCBHIC0gUiksIHcgPSBfQmFsYW5jZUlTT0RhdGUyLnllYXIsIEQgPSBfQmFsYW5jZUlTT0RhdGUyLm1vbnRoLCBHID0gX0JhbGFuY2VJU09EYXRlMi5kYXkpLCAoX0JhbGFuY2VEdXJhdGlvbiA9IEJhbGFuY2VEdXJhdGlvbigtUiwgdiwgQywgTywgYiwgRSwgTSwgUyksIHYgPSBfQmFsYW5jZUR1cmF0aW9uLmhvdXJzLCBDID0gX0JhbGFuY2VEdXJhdGlvbi5taW51dGVzLCBPID0gX0JhbGFuY2VEdXJhdGlvbi5zZWNvbmRzLCBiID0gX0JhbGFuY2VEdXJhdGlvbi5taWxsaXNlY29uZHMsIEUgPSBfQmFsYW5jZUR1cmF0aW9uLm1pY3Jvc2Vjb25kcywgTSA9IF9CYWxhbmNlRHVyYXRpb24ubmFub3NlY29uZHMpKTtcbiAgdmFyIEYgPSBDcmVhdGVUZW1wb3JhbERhdGUodywgRCwgRywgSSksXG4gICAgWSA9IENyZWF0ZVRlbXBvcmFsRGF0ZShkLCBtLCBjLCBJKSxcbiAgICBQID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKFwiZGF5XCIsIFMpLFxuICAgIFogPSBDb3B5T3B0aW9ucyhnKTtcbiAgWi5sYXJnZXN0VW5pdCA9IFA7XG4gIHZhciBfQ2FsZW5kYXJEYXRlVW50aWwgPSBDYWxlbmRhckRhdGVVbnRpbChJLCBGLCBZLCBaKSxcbiAgICBCID0gX0NhbGVuZGFyRGF0ZVVudGlsLnllYXJzLFxuICAgIE4gPSBfQ2FsZW5kYXJEYXRlVW50aWwubW9udGhzLFxuICAgIGogPSBfQ2FsZW5kYXJEYXRlVW50aWwud2Vla3MsXG4gICAgJCA9IF9DYWxlbmRhckRhdGVVbnRpbC5kYXlzO1xuICByZXR1cm4gKF9CYWxhbmNlRHVyYXRpb24yID0gQmFsYW5jZUR1cmF0aW9uKCQsIHYsIEMsIE8sIGIsIEUsIE0sIFMpLCAkID0gX0JhbGFuY2VEdXJhdGlvbjIuZGF5cywgdiA9IF9CYWxhbmNlRHVyYXRpb24yLmhvdXJzLCBDID0gX0JhbGFuY2VEdXJhdGlvbjIubWludXRlcywgTyA9IF9CYWxhbmNlRHVyYXRpb24yLnNlY29uZHMsIGIgPSBfQmFsYW5jZUR1cmF0aW9uMi5taWxsaXNlY29uZHMsIEUgPSBfQmFsYW5jZUR1cmF0aW9uMi5taWNyb3NlY29uZHMsIE0gPSBfQmFsYW5jZUR1cmF0aW9uMi5uYW5vc2Vjb25kcyksIHtcbiAgICB5ZWFyczogQixcbiAgICBtb250aHM6IE4sXG4gICAgd2Vla3M6IGosXG4gICAgZGF5czogJCxcbiAgICBob3VyczogdixcbiAgICBtaW51dGVzOiBDLFxuICAgIHNlY29uZHM6IE8sXG4gICAgbWlsbGlzZWNvbmRzOiBiLFxuICAgIG1pY3Jvc2Vjb25kczogRSxcbiAgICBuYW5vc2Vjb25kczogTVxuICB9O1xufVxuZnVuY3Rpb24gRGlmZmVyZW5jZVpvbmVkRGF0ZVRpbWUodCwgciwgbywgbiwgYSwgcCkge1xuICB2YXIgZiA9IHIgLSB0O1xuICBpZiAoZiA9PT0gSWUpIHJldHVybiB7XG4gICAgeWVhcnM6IDAsXG4gICAgbW9udGhzOiAwLFxuICAgIHdlZWtzOiAwLFxuICAgIGRheXM6IDAsXG4gICAgaG91cnM6IDAsXG4gICAgbWludXRlczogMCxcbiAgICBzZWNvbmRzOiAwLFxuICAgIG1pbGxpc2Vjb25kczogMCxcbiAgICBtaWNyb3NlY29uZHM6IDAsXG4gICAgbmFub3NlY29uZHM6IDBcbiAgfTtcbiAgdmFyIHkgPSBHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIiksXG4gICAgSSA9IG5ldyB5KHQpLFxuICAgIFMgPSBuZXcgeShyKSxcbiAgICBnID0gR2V0UGxhaW5EYXRlVGltZUZvcihvLCBJLCBuKSxcbiAgICB3ID0gR2V0UGxhaW5EYXRlVGltZUZvcihvLCBTLCBuKTtcbiAgdmFyIF9EaWZmZXJlbmNlSVNPRGF0ZVRpbTIgPSBEaWZmZXJlbmNlSVNPRGF0ZVRpbWUoR2V0U2xvdChnLCBpKSwgR2V0U2xvdChnLCBzKSwgR2V0U2xvdChnLCBsKSwgR2V0U2xvdChnLCBkKSwgR2V0U2xvdChnLCBtKSwgR2V0U2xvdChnLCBjKSwgR2V0U2xvdChnLCBoKSwgR2V0U2xvdChnLCB1KSwgR2V0U2xvdChnLCBUKSwgR2V0U2xvdCh3LCBpKSwgR2V0U2xvdCh3LCBzKSwgR2V0U2xvdCh3LCBsKSwgR2V0U2xvdCh3LCBkKSwgR2V0U2xvdCh3LCBtKSwgR2V0U2xvdCh3LCBjKSwgR2V0U2xvdCh3LCBoKSwgR2V0U2xvdCh3LCB1KSwgR2V0U2xvdCh3LCBUKSwgbiwgYSwgcCksXG4gICAgRCA9IF9EaWZmZXJlbmNlSVNPRGF0ZVRpbTIueWVhcnMsXG4gICAgRyA9IF9EaWZmZXJlbmNlSVNPRGF0ZVRpbTIubW9udGhzLFxuICAgIHYgPSBfRGlmZmVyZW5jZUlTT0RhdGVUaW0yLndlZWtzLFxuICAgIEMgPSBfRGlmZmVyZW5jZUlTT0RhdGVUaW0yLmRheXM7XG4gIHZhciBPID0gQWRkWm9uZWREYXRlVGltZShJLCBvLCBuLCBELCBHLCB2LCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgdmFyIGIgPSByIC0gTztcbiAgdmFyIEUgPSBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoTywgbywgbik7XG4gIHZhciBfTmFub3NlY29uZHNUb0RheXMyID0gTmFub3NlY29uZHNUb0RheXMoYiwgRSk7XG4gIGIgPSBfTmFub3NlY29uZHNUb0RheXMyLm5hbm9zZWNvbmRzO1xuICBDID0gX05hbm9zZWNvbmRzVG9EYXlzMi5kYXlzO1xuICB2YXIgX0JhbGFuY2VEdXJhdGlvbjMgPSBCYWxhbmNlRHVyYXRpb24oMCwgMCwgMCwgMCwgMCwgMCwgTnVtYmVyKGIpLCBcImhvdXJcIiksXG4gICAgTSA9IF9CYWxhbmNlRHVyYXRpb24zLmhvdXJzLFxuICAgIFIgPSBfQmFsYW5jZUR1cmF0aW9uMy5taW51dGVzLFxuICAgIEYgPSBfQmFsYW5jZUR1cmF0aW9uMy5zZWNvbmRzLFxuICAgIFkgPSBfQmFsYW5jZUR1cmF0aW9uMy5taWxsaXNlY29uZHMsXG4gICAgUCA9IF9CYWxhbmNlRHVyYXRpb24zLm1pY3Jvc2Vjb25kcyxcbiAgICBaID0gX0JhbGFuY2VEdXJhdGlvbjMubmFub3NlY29uZHM7XG4gIHJldHVybiB7XG4gICAgeWVhcnM6IEQsXG4gICAgbW9udGhzOiBHLFxuICAgIHdlZWtzOiB2LFxuICAgIGRheXM6IEMsXG4gICAgaG91cnM6IE0sXG4gICAgbWludXRlczogUixcbiAgICBzZWNvbmRzOiBGLFxuICAgIG1pbGxpc2Vjb25kczogWSxcbiAgICBtaWNyb3NlY29uZHM6IFAsXG4gICAgbmFub3NlY29uZHM6IFpcbiAgfTtcbn1cbmZ1bmN0aW9uIEdldERpZmZlcmVuY2VTZXR0aW5ncyhlLCB0LCByLCBvLCBuLCBhKSB7XG4gIHZhciBpID0gVWUucmVkdWNlKGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgdmFyIG4gPSB0WzBdLFxuICAgICAgYSA9IHRbMV0sXG4gICAgICBpID0gdFsyXTtcbiAgICByZXR1cm4gXCJkYXRldGltZVwiICE9PSByICYmIGkgIT09IHIgfHwgby5pbmNsdWRlcyhhKSB8fCBlLnB1c2goYSwgbiksIGU7XG4gIH0sIFtdKTtcbiAgdmFyIHMgPSBHZXRUZW1wb3JhbFVuaXQodCwgXCJsYXJnZXN0VW5pdFwiLCByLCBcImF1dG9cIik7XG4gIGlmIChvLmluY2x1ZGVzKHMpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImxhcmdlc3RVbml0IG11c3QgYmUgb25lIG9mIFwiLmNvbmNhdChpLmpvaW4oXCIsIFwiKSwgXCIsIG5vdCBcIikuY29uY2F0KHMpKTtcbiAgdmFyIGwgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQodCk7XG4gIHZhciBkID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZSh0LCBcInRydW5jXCIpO1xuICBcInNpbmNlXCIgPT09IGUgJiYgKGQgPSBmdW5jdGlvbiBOZWdhdGVUZW1wb3JhbFJvdW5kaW5nTW9kZShlKSB7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIFwiY2VpbFwiOlxuICAgICAgICByZXR1cm4gXCJmbG9vclwiO1xuICAgICAgY2FzZSBcImZsb29yXCI6XG4gICAgICAgIHJldHVybiBcImNlaWxcIjtcbiAgICAgIGNhc2UgXCJoYWxmQ2VpbFwiOlxuICAgICAgICByZXR1cm4gXCJoYWxmRmxvb3JcIjtcbiAgICAgIGNhc2UgXCJoYWxmRmxvb3JcIjpcbiAgICAgICAgcmV0dXJuIFwiaGFsZkNlaWxcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgfShkKSk7XG4gIHZhciBtID0gR2V0VGVtcG9yYWxVbml0KHQsIFwic21hbGxlc3RVbml0XCIsIHIsIG4pO1xuICBpZiAoby5pbmNsdWRlcyhtKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzbWFsbGVzdFVuaXQgbXVzdCBiZSBvbmUgb2YgXCIuY29uY2F0KGkuam9pbihcIiwgXCIpLCBcIiwgbm90IFwiKS5jb25jYXQobSkpO1xuICB2YXIgYyA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhhLCBtKTtcbiAgaWYgKFwiYXV0b1wiID09PSBzICYmIChzID0gYyksIExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhzLCBtKSAhPT0gcykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJsYXJnZXN0VW5pdCBcIi5jb25jYXQocywgXCIgY2Fubm90IGJlIHNtYWxsZXIgdGhhbiBzbWFsbGVzdFVuaXQgXCIpLmNvbmNhdChtKSk7XG4gIHZhciBoID0ge1xuICAgIGhvdXI6IDI0LFxuICAgIG1pbnV0ZTogNjAsXG4gICAgc2Vjb25kOiA2MCxcbiAgICBtaWxsaXNlY29uZDogMWUzLFxuICAgIG1pY3Jvc2Vjb25kOiAxZTMsXG4gICAgbmFub3NlY29uZDogMWUzXG4gIH1bbV07XG4gIHJldHVybiB2b2lkIDAgIT09IGggJiYgVmFsaWRhdGVUZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KGwsIGgsICExKSwge1xuICAgIGxhcmdlc3RVbml0OiBzLFxuICAgIHJvdW5kaW5nSW5jcmVtZW50OiBsLFxuICAgIHJvdW5kaW5nTW9kZTogZCxcbiAgICBzbWFsbGVzdFVuaXQ6IG1cbiAgfTtcbn1cbmZ1bmN0aW9uIERpZmZlcmVuY2VUZW1wb3JhbEluc3RhbnQoZSwgdCwgciwgbykge1xuICB2YXIgYSA9IFwic2luY2VcIiA9PT0gZSA/IC0xIDogMSxcbiAgICBpID0gVG9UZW1wb3JhbEluc3RhbnQociksXG4gICAgcyA9IEdldERpZmZlcmVuY2VTZXR0aW5ncyhlLCBDb3B5T3B0aW9ucyhvKSwgXCJ0aW1lXCIsIFtdLCBcIm5hbm9zZWNvbmRcIiwgXCJzZWNvbmRcIiksXG4gICAgbCA9IEdldFNsb3QodCwgbiksXG4gICAgZCA9IEdldFNsb3QoaSwgbik7XG4gIHZhciBfRGlmZmVyZW5jZUluc3RhbnQgPSBEaWZmZXJlbmNlSW5zdGFudChsLCBkLCBzLnJvdW5kaW5nSW5jcmVtZW50LCBzLnNtYWxsZXN0VW5pdCwgcy5sYXJnZXN0VW5pdCwgcy5yb3VuZGluZ01vZGUpLFxuICAgIG0gPSBfRGlmZmVyZW5jZUluc3RhbnQuaG91cnMsXG4gICAgYyA9IF9EaWZmZXJlbmNlSW5zdGFudC5taW51dGVzLFxuICAgIGggPSBfRGlmZmVyZW5jZUluc3RhbnQuc2Vjb25kcyxcbiAgICB1ID0gX0RpZmZlcmVuY2VJbnN0YW50Lm1pbGxpc2Vjb25kcyxcbiAgICBUID0gX0RpZmZlcmVuY2VJbnN0YW50Lm1pY3Jvc2Vjb25kcyxcbiAgICBwID0gX0RpZmZlcmVuY2VJbnN0YW50Lm5hbm9zZWNvbmRzO1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuRHVyYXRpb24lXCIpKSgwLCAwLCAwLCAwLCBhICogbSwgYSAqIGMsIGEgKiBoLCBhICogdSwgYSAqIFQsIGEgKiBwKTtcbn1cbmZ1bmN0aW9uIERpZmZlcmVuY2VUZW1wb3JhbFBsYWluRGF0ZShlLCB0LCByLCBvKSB7XG4gIHZhciBfUm91bmREdXJhdGlvbjM7XG4gIHZhciBuID0gXCJzaW5jZVwiID09PSBlID8gLTEgOiAxLFxuICAgIGEgPSBUb1RlbXBvcmFsRGF0ZShyKSxcbiAgICBpID0gR2V0U2xvdCh0LCBwKTtcbiAgVGhyb3dJZkNhbGVuZGFyc05vdEVxdWFsKGksIEdldFNsb3QoYSwgcCksIFwiY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gZGF0ZXNcIik7XG4gIHZhciBzID0gQ29weU9wdGlvbnMobyksXG4gICAgbCA9IEdldERpZmZlcmVuY2VTZXR0aW5ncyhlLCBzLCBcImRhdGVcIiwgW10sIFwiZGF5XCIsIFwiZGF5XCIpO1xuICBzLmxhcmdlc3RVbml0ID0gbC5sYXJnZXN0VW5pdDtcbiAgdmFyIF9DYWxlbmRhckRhdGVVbnRpbDIgPSBDYWxlbmRhckRhdGVVbnRpbChpLCB0LCBhLCBzKSxcbiAgICBkID0gX0NhbGVuZGFyRGF0ZVVudGlsMi55ZWFycyxcbiAgICBtID0gX0NhbGVuZGFyRGF0ZVVudGlsMi5tb250aHMsXG4gICAgYyA9IF9DYWxlbmRhckRhdGVVbnRpbDIud2Vla3MsXG4gICAgaCA9IF9DYWxlbmRhckRhdGVVbnRpbDIuZGF5cztcbiAgXCJkYXlcIiA9PT0gbC5zbWFsbGVzdFVuaXQgJiYgMSA9PT0gbC5yb3VuZGluZ0luY3JlbWVudCB8fCAoX1JvdW5kRHVyYXRpb24zID0gUm91bmREdXJhdGlvbihkLCBtLCBjLCBoLCAwLCAwLCAwLCAwLCAwLCAwLCBsLnJvdW5kaW5nSW5jcmVtZW50LCBsLnNtYWxsZXN0VW5pdCwgbC5yb3VuZGluZ01vZGUsIHQpLCBkID0gX1JvdW5kRHVyYXRpb24zLnllYXJzLCBtID0gX1JvdW5kRHVyYXRpb24zLm1vbnRocywgYyA9IF9Sb3VuZER1cmF0aW9uMy53ZWVrcywgaCA9IF9Sb3VuZER1cmF0aW9uMy5kYXlzLCBfUm91bmREdXJhdGlvbjMpO1xuICByZXR1cm4gbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuRHVyYXRpb24lXCIpKShuICogZCwgbiAqIG0sIG4gKiBjLCBuICogaCwgMCwgMCwgMCwgMCwgMCwgMCk7XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlVGVtcG9yYWxQbGFpbkRhdGVUaW1lKGUsIHQsIHIsIG8pIHtcbiAgdmFyIF9Sb3VuZER1cmF0aW9uNCwgX0JhbGFuY2VEdXJhdGlvbjQ7XG4gIHZhciBuID0gXCJzaW5jZVwiID09PSBlID8gLTEgOiAxLFxuICAgIGEgPSBUb1RlbXBvcmFsRGF0ZVRpbWUociksXG4gICAgZiA9IEdldFNsb3QodCwgcCk7XG4gIFRocm93SWZDYWxlbmRhcnNOb3RFcXVhbChmLCBHZXRTbG90KGEsIHApLCBcImNvbXB1dGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGRhdGVzXCIpO1xuICB2YXIgeSA9IENvcHlPcHRpb25zKG8pLFxuICAgIEkgPSBHZXREaWZmZXJlbmNlU2V0dGluZ3MoZSwgeSwgXCJkYXRldGltZVwiLCBbXSwgXCJuYW5vc2Vjb25kXCIsIFwiZGF5XCIpO1xuICB2YXIgX0RpZmZlcmVuY2VJU09EYXRlVGltMyA9IERpZmZlcmVuY2VJU09EYXRlVGltZShHZXRTbG90KHQsIGkpLCBHZXRTbG90KHQsIHMpLCBHZXRTbG90KHQsIGwpLCBHZXRTbG90KHQsIGQpLCBHZXRTbG90KHQsIG0pLCBHZXRTbG90KHQsIGMpLCBHZXRTbG90KHQsIGgpLCBHZXRTbG90KHQsIHUpLCBHZXRTbG90KHQsIFQpLCBHZXRTbG90KGEsIGkpLCBHZXRTbG90KGEsIHMpLCBHZXRTbG90KGEsIGwpLCBHZXRTbG90KGEsIGQpLCBHZXRTbG90KGEsIG0pLCBHZXRTbG90KGEsIGMpLCBHZXRTbG90KGEsIGgpLCBHZXRTbG90KGEsIHUpLCBHZXRTbG90KGEsIFQpLCBmLCBJLmxhcmdlc3RVbml0LCB5KSxcbiAgICBTID0gX0RpZmZlcmVuY2VJU09EYXRlVGltMy55ZWFycyxcbiAgICBnID0gX0RpZmZlcmVuY2VJU09EYXRlVGltMy5tb250aHMsXG4gICAgdyA9IF9EaWZmZXJlbmNlSVNPRGF0ZVRpbTMud2Vla3MsXG4gICAgRCA9IF9EaWZmZXJlbmNlSVNPRGF0ZVRpbTMuZGF5cyxcbiAgICBHID0gX0RpZmZlcmVuY2VJU09EYXRlVGltMy5ob3VycyxcbiAgICB2ID0gX0RpZmZlcmVuY2VJU09EYXRlVGltMy5taW51dGVzLFxuICAgIEMgPSBfRGlmZmVyZW5jZUlTT0RhdGVUaW0zLnNlY29uZHMsXG4gICAgTyA9IF9EaWZmZXJlbmNlSVNPRGF0ZVRpbTMubWlsbGlzZWNvbmRzLFxuICAgIGIgPSBfRGlmZmVyZW5jZUlTT0RhdGVUaW0zLm1pY3Jvc2Vjb25kcyxcbiAgICBFID0gX0RpZmZlcmVuY2VJU09EYXRlVGltMy5uYW5vc2Vjb25kcztcbiAgdmFyIE0gPSBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKHQpO1xuICAoX1JvdW5kRHVyYXRpb240ID0gUm91bmREdXJhdGlvbihTLCBnLCB3LCBELCBHLCB2LCBDLCBPLCBiLCBFLCBJLnJvdW5kaW5nSW5jcmVtZW50LCBJLnNtYWxsZXN0VW5pdCwgSS5yb3VuZGluZ01vZGUsIE0pLCBTID0gX1JvdW5kRHVyYXRpb240LnllYXJzLCBnID0gX1JvdW5kRHVyYXRpb240Lm1vbnRocywgdyA9IF9Sb3VuZER1cmF0aW9uNC53ZWVrcywgRCA9IF9Sb3VuZER1cmF0aW9uNC5kYXlzLCBHID0gX1JvdW5kRHVyYXRpb240LmhvdXJzLCB2ID0gX1JvdW5kRHVyYXRpb240Lm1pbnV0ZXMsIEMgPSBfUm91bmREdXJhdGlvbjQuc2Vjb25kcywgTyA9IF9Sb3VuZER1cmF0aW9uNC5taWxsaXNlY29uZHMsIGIgPSBfUm91bmREdXJhdGlvbjQubWljcm9zZWNvbmRzLCBFID0gX1JvdW5kRHVyYXRpb240Lm5hbm9zZWNvbmRzKSwgKF9CYWxhbmNlRHVyYXRpb240ID0gQmFsYW5jZUR1cmF0aW9uKEQsIEcsIHYsIEMsIE8sIGIsIEUsIEkubGFyZ2VzdFVuaXQpLCBEID0gX0JhbGFuY2VEdXJhdGlvbjQuZGF5cywgRyA9IF9CYWxhbmNlRHVyYXRpb240LmhvdXJzLCB2ID0gX0JhbGFuY2VEdXJhdGlvbjQubWludXRlcywgQyA9IF9CYWxhbmNlRHVyYXRpb240LnNlY29uZHMsIE8gPSBfQmFsYW5jZUR1cmF0aW9uNC5taWxsaXNlY29uZHMsIGIgPSBfQmFsYW5jZUR1cmF0aW9uNC5taWNyb3NlY29uZHMsIEUgPSBfQmFsYW5jZUR1cmF0aW9uNC5uYW5vc2Vjb25kcyk7XG4gIHJldHVybiBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIikpKG4gKiBTLCBuICogZywgbiAqIHcsIG4gKiBELCBuICogRywgbiAqIHYsIG4gKiBDLCBuICogTywgbiAqIGIsIG4gKiBFKTtcbn1cbmZ1bmN0aW9uIERpZmZlcmVuY2VUZW1wb3JhbFBsYWluVGltZShlLCB0LCByLCBvKSB7XG4gIHZhciBfUm91bmREdXJhdGlvbjUsIF9CYWxhbmNlRHVyYXRpb241O1xuICB2YXIgbiA9IFwic2luY2VcIiA9PT0gZSA/IC0xIDogMSxcbiAgICBhID0gVG9UZW1wb3JhbFRpbWUociksXG4gICAgaSA9IEdldERpZmZlcmVuY2VTZXR0aW5ncyhlLCBDb3B5T3B0aW9ucyhvKSwgXCJ0aW1lXCIsIFtdLCBcIm5hbm9zZWNvbmRcIiwgXCJob3VyXCIpO1xuICB2YXIgX0RpZmZlcmVuY2VUaW1lMiA9IERpZmZlcmVuY2VUaW1lKEdldFNsb3QodCwgZCksIEdldFNsb3QodCwgbSksIEdldFNsb3QodCwgYyksIEdldFNsb3QodCwgaCksIEdldFNsb3QodCwgdSksIEdldFNsb3QodCwgVCksIEdldFNsb3QoYSwgZCksIEdldFNsb3QoYSwgbSksIEdldFNsb3QoYSwgYyksIEdldFNsb3QoYSwgaCksIEdldFNsb3QoYSwgdSksIEdldFNsb3QoYSwgVCkpLFxuICAgIHMgPSBfRGlmZmVyZW5jZVRpbWUyLmhvdXJzLFxuICAgIGwgPSBfRGlmZmVyZW5jZVRpbWUyLm1pbnV0ZXMsXG4gICAgcCA9IF9EaWZmZXJlbmNlVGltZTIuc2Vjb25kcyxcbiAgICBmID0gX0RpZmZlcmVuY2VUaW1lMi5taWxsaXNlY29uZHMsXG4gICAgeSA9IF9EaWZmZXJlbmNlVGltZTIubWljcm9zZWNvbmRzLFxuICAgIEkgPSBfRGlmZmVyZW5jZVRpbWUyLm5hbm9zZWNvbmRzO1xuICAoX1JvdW5kRHVyYXRpb241ID0gUm91bmREdXJhdGlvbigwLCAwLCAwLCAwLCBzLCBsLCBwLCBmLCB5LCBJLCBpLnJvdW5kaW5nSW5jcmVtZW50LCBpLnNtYWxsZXN0VW5pdCwgaS5yb3VuZGluZ01vZGUpLCBzID0gX1JvdW5kRHVyYXRpb241LmhvdXJzLCBsID0gX1JvdW5kRHVyYXRpb241Lm1pbnV0ZXMsIHAgPSBfUm91bmREdXJhdGlvbjUuc2Vjb25kcywgZiA9IF9Sb3VuZER1cmF0aW9uNS5taWxsaXNlY29uZHMsIHkgPSBfUm91bmREdXJhdGlvbjUubWljcm9zZWNvbmRzLCBJID0gX1JvdW5kRHVyYXRpb241Lm5hbm9zZWNvbmRzKSwgKF9CYWxhbmNlRHVyYXRpb241ID0gQmFsYW5jZUR1cmF0aW9uKDAsIHMsIGwsIHAsIGYsIHksIEksIGkubGFyZ2VzdFVuaXQpLCBzID0gX0JhbGFuY2VEdXJhdGlvbjUuaG91cnMsIGwgPSBfQmFsYW5jZUR1cmF0aW9uNS5taW51dGVzLCBwID0gX0JhbGFuY2VEdXJhdGlvbjUuc2Vjb25kcywgZiA9IF9CYWxhbmNlRHVyYXRpb241Lm1pbGxpc2Vjb25kcywgeSA9IF9CYWxhbmNlRHVyYXRpb241Lm1pY3Jvc2Vjb25kcywgSSA9IF9CYWxhbmNlRHVyYXRpb241Lm5hbm9zZWNvbmRzKTtcbiAgcmV0dXJuIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKSkoMCwgMCwgMCwgMCwgbiAqIHMsIG4gKiBsLCBuICogcCwgbiAqIGYsIG4gKiB5LCBuICogSSk7XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlVGVtcG9yYWxQbGFpblllYXJNb250aChlLCB0LCByLCBvKSB7XG4gIHZhciBfUm91bmREdXJhdGlvbjY7XG4gIHZhciBuID0gXCJzaW5jZVwiID09PSBlID8gLTEgOiAxLFxuICAgIGEgPSBUb1RlbXBvcmFsWWVhck1vbnRoKHIpLFxuICAgIGkgPSBHZXRTbG90KHQsIHApO1xuICBUaHJvd0lmQ2FsZW5kYXJzTm90RXF1YWwoaSwgR2V0U2xvdChhLCBwKSwgXCJjb21wdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiBtb250aHNcIik7XG4gIHZhciBzID0gQ29weU9wdGlvbnMobyksXG4gICAgbCA9IEdldERpZmZlcmVuY2VTZXR0aW5ncyhlLCBzLCBcImRhdGVcIiwgW1wid2Vla1wiLCBcImRheVwiXSwgXCJtb250aFwiLCBcInllYXJcIik7XG4gIHMubGFyZ2VzdFVuaXQgPSBsLmxhcmdlc3RVbml0O1xuICB2YXIgZCA9IENhbGVuZGFyRmllbGRzKGksIFtcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0pLFxuICAgIG0gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModCwgZCwgW10pO1xuICBtLmRheSA9IDE7XG4gIHZhciBjID0gQ2FsZW5kYXJEYXRlRnJvbUZpZWxkcyhpLCBtKSxcbiAgICBoID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGEsIGQsIFtdKTtcbiAgaC5kYXkgPSAxO1xuICB2YXIgdSA9IENhbGVuZGFyRGF0ZUZyb21GaWVsZHMoaSwgaCk7XG4gIHZhciBfQ2FsZW5kYXJEYXRlVW50aWwzID0gQ2FsZW5kYXJEYXRlVW50aWwoaSwgYywgdSwgcyksXG4gICAgVCA9IF9DYWxlbmRhckRhdGVVbnRpbDMueWVhcnMsXG4gICAgZiA9IF9DYWxlbmRhckRhdGVVbnRpbDMubW9udGhzO1xuICBcIm1vbnRoXCIgPT09IGwuc21hbGxlc3RVbml0ICYmIDEgPT09IGwucm91bmRpbmdJbmNyZW1lbnQgfHwgKF9Sb3VuZER1cmF0aW9uNiA9IFJvdW5kRHVyYXRpb24oVCwgZiwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgbC5yb3VuZGluZ0luY3JlbWVudCwgbC5zbWFsbGVzdFVuaXQsIGwucm91bmRpbmdNb2RlLCBjKSwgVCA9IF9Sb3VuZER1cmF0aW9uNi55ZWFycywgZiA9IF9Sb3VuZER1cmF0aW9uNi5tb250aHMsIF9Sb3VuZER1cmF0aW9uNik7XG4gIHJldHVybiBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIikpKG4gKiBULCBuICogZiwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG59XG5mdW5jdGlvbiBEaWZmZXJlbmNlVGVtcG9yYWxab25lZERhdGVUaW1lKGUsIHQsIHIsIG8pIHtcbiAgdmFyIF9EaWZmZXJlbmNlSW5zdGFudDI7XG4gIHZhciBhID0gXCJzaW5jZVwiID09PSBlID8gLTEgOiAxLFxuICAgIGkgPSBUb1RlbXBvcmFsWm9uZWREYXRlVGltZShyKSxcbiAgICBzID0gR2V0U2xvdCh0LCBwKTtcbiAgVGhyb3dJZkNhbGVuZGFyc05vdEVxdWFsKHMsIEdldFNsb3QoaSwgcCksIFwiY29tcHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gZGF0ZXNcIik7XG4gIHZhciBsID0gQ29weU9wdGlvbnMobyksXG4gICAgZCA9IEdldERpZmZlcmVuY2VTZXR0aW5ncyhlLCBsLCBcImRhdGV0aW1lXCIsIFtdLCBcIm5hbm9zZWNvbmRcIiwgXCJob3VyXCIpO1xuICBsLmxhcmdlc3RVbml0ID0gZC5sYXJnZXN0VW5pdDtcbiAgdmFyIG0gPSBHZXRTbG90KHQsIG4pLFxuICAgIGMgPSBHZXRTbG90KGksIG4pO1xuICB2YXIgaCwgdSwgVCwgZiwgeSwgSSwgUywgdywgRCwgRztcbiAgaWYgKFwieWVhclwiICE9PSBkLmxhcmdlc3RVbml0ICYmIFwibW9udGhcIiAhPT0gZC5sYXJnZXN0VW5pdCAmJiBcIndlZWtcIiAhPT0gZC5sYXJnZXN0VW5pdCAmJiBcImRheVwiICE9PSBkLmxhcmdlc3RVbml0KSBoID0gMCwgdSA9IDAsIFQgPSAwLCBmID0gMCwgKF9EaWZmZXJlbmNlSW5zdGFudDIgPSBEaWZmZXJlbmNlSW5zdGFudChtLCBjLCBkLnJvdW5kaW5nSW5jcmVtZW50LCBkLnNtYWxsZXN0VW5pdCwgZC5sYXJnZXN0VW5pdCwgZC5yb3VuZGluZ01vZGUpLCB5ID0gX0RpZmZlcmVuY2VJbnN0YW50Mi5ob3VycywgSSA9IF9EaWZmZXJlbmNlSW5zdGFudDIubWludXRlcywgUyA9IF9EaWZmZXJlbmNlSW5zdGFudDIuc2Vjb25kcywgdyA9IF9EaWZmZXJlbmNlSW5zdGFudDIubWlsbGlzZWNvbmRzLCBEID0gX0RpZmZlcmVuY2VJbnN0YW50Mi5taWNyb3NlY29uZHMsIEcgPSBfRGlmZmVyZW5jZUluc3RhbnQyLm5hbm9zZWNvbmRzKTtlbHNlIHtcbiAgICB2YXIgX0RpZmZlcmVuY2Vab25lZERhdGVULCBfUm91bmREdXJhdGlvbjcsIF9BZGp1c3RSb3VuZGVkRHVyYXRpbztcbiAgICB2YXIgX2UyOCA9IEdldFNsb3QodCwgZyk7XG4gICAgaWYgKCFUaW1lWm9uZUVxdWFscyhfZTI4LCBHZXRTbG90KGksIGcpKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXaGVuIGNhbGN1bGF0aW5nIGRpZmZlcmVuY2UgYmV0d2VlbiB0aW1lIHpvbmVzLCBsYXJnZXN0VW5pdCBtdXN0IGJlICdob3Vycycgb3Igc21hbGxlciBiZWNhdXNlIGRheSBsZW5ndGhzIGNhbiB2YXJ5IGJldHdlZW4gdGltZSB6b25lcyBkdWUgdG8gRFNUIG9yIHRpbWUgem9uZSBvZmZzZXQgY2hhbmdlcy5cIik7XG4gICAgKF9EaWZmZXJlbmNlWm9uZWREYXRlVCA9IERpZmZlcmVuY2Vab25lZERhdGVUaW1lKG0sIGMsIF9lMjgsIHMsIGQubGFyZ2VzdFVuaXQsIGwpLCBoID0gX0RpZmZlcmVuY2Vab25lZERhdGVULnllYXJzLCB1ID0gX0RpZmZlcmVuY2Vab25lZERhdGVULm1vbnRocywgVCA9IF9EaWZmZXJlbmNlWm9uZWREYXRlVC53ZWVrcywgZiA9IF9EaWZmZXJlbmNlWm9uZWREYXRlVC5kYXlzLCB5ID0gX0RpZmZlcmVuY2Vab25lZERhdGVULmhvdXJzLCBJID0gX0RpZmZlcmVuY2Vab25lZERhdGVULm1pbnV0ZXMsIFMgPSBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQuc2Vjb25kcywgdyA9IF9EaWZmZXJlbmNlWm9uZWREYXRlVC5taWxsaXNlY29uZHMsIEQgPSBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQubWljcm9zZWNvbmRzLCBHID0gX0RpZmZlcmVuY2Vab25lZERhdGVULm5hbm9zZWNvbmRzKSwgKF9Sb3VuZER1cmF0aW9uNyA9IFJvdW5kRHVyYXRpb24oaCwgdSwgVCwgZiwgeSwgSSwgUywgdywgRCwgRywgZC5yb3VuZGluZ0luY3JlbWVudCwgZC5zbWFsbGVzdFVuaXQsIGQucm91bmRpbmdNb2RlLCB0KSwgaCA9IF9Sb3VuZER1cmF0aW9uNy55ZWFycywgdSA9IF9Sb3VuZER1cmF0aW9uNy5tb250aHMsIFQgPSBfUm91bmREdXJhdGlvbjcud2Vla3MsIGYgPSBfUm91bmREdXJhdGlvbjcuZGF5cywgeSA9IF9Sb3VuZER1cmF0aW9uNy5ob3VycywgSSA9IF9Sb3VuZER1cmF0aW9uNy5taW51dGVzLCBTID0gX1JvdW5kRHVyYXRpb243LnNlY29uZHMsIHcgPSBfUm91bmREdXJhdGlvbjcubWlsbGlzZWNvbmRzLCBEID0gX1JvdW5kRHVyYXRpb243Lm1pY3Jvc2Vjb25kcywgRyA9IF9Sb3VuZER1cmF0aW9uNy5uYW5vc2Vjb25kcyksIChfQWRqdXN0Um91bmRlZER1cmF0aW8gPSBBZGp1c3RSb3VuZGVkRHVyYXRpb25EYXlzKGgsIHUsIFQsIGYsIHksIEksIFMsIHcsIEQsIEcsIGQucm91bmRpbmdJbmNyZW1lbnQsIGQuc21hbGxlc3RVbml0LCBkLnJvdW5kaW5nTW9kZSwgdCksIGggPSBfQWRqdXN0Um91bmRlZER1cmF0aW8ueWVhcnMsIHUgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8ubW9udGhzLCBUID0gX0FkanVzdFJvdW5kZWREdXJhdGlvLndlZWtzLCBmID0gX0FkanVzdFJvdW5kZWREdXJhdGlvLmRheXMsIHkgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8uaG91cnMsIEkgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8ubWludXRlcywgUyA9IF9BZGp1c3RSb3VuZGVkRHVyYXRpby5zZWNvbmRzLCB3ID0gX0FkanVzdFJvdW5kZWREdXJhdGlvLm1pbGxpc2Vjb25kcywgRCA9IF9BZGp1c3RSb3VuZGVkRHVyYXRpby5taWNyb3NlY29uZHMsIEcgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8ubmFub3NlY29uZHMpO1xuICB9XG4gIHJldHVybiBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIikpKGEgKiBoLCBhICogdSwgYSAqIFQsIGEgKiBmLCBhICogeSwgYSAqIEksIGEgKiBTLCBhICogdywgYSAqIEQsIGEgKiBHKTtcbn1cbmZ1bmN0aW9uIEFkZElTT0RhdGUoZSwgdCwgciwgbywgbiwgYSwgaSwgcykge1xuICB2YXIgX0JhbGFuY2VJU09ZZWFyTW9udGg0LCBfUmVndWxhdGVJU09EYXRlLCBfQmFsYW5jZUlTT0RhdGUzO1xuICB2YXIgbCA9IGUsXG4gICAgZCA9IHQsXG4gICAgbSA9IHIsXG4gICAgYyA9IGEsXG4gICAgaCA9IGk7XG4gIHJldHVybiBsICs9IG8sIGQgKz0gbiwgKF9CYWxhbmNlSVNPWWVhck1vbnRoNCA9IEJhbGFuY2VJU09ZZWFyTW9udGgobCwgZCksIGwgPSBfQmFsYW5jZUlTT1llYXJNb250aDQueWVhciwgZCA9IF9CYWxhbmNlSVNPWWVhck1vbnRoNC5tb250aCksIChfUmVndWxhdGVJU09EYXRlID0gUmVndWxhdGVJU09EYXRlKGwsIGQsIG0sIHMpLCBsID0gX1JlZ3VsYXRlSVNPRGF0ZS55ZWFyLCBkID0gX1JlZ3VsYXRlSVNPRGF0ZS5tb250aCwgbSA9IF9SZWd1bGF0ZUlTT0RhdGUuZGF5KSwgaCArPSA3ICogYywgbSArPSBoLCAoX0JhbGFuY2VJU09EYXRlMyA9IEJhbGFuY2VJU09EYXRlKGwsIGQsIG0pLCBsID0gX0JhbGFuY2VJU09EYXRlMy55ZWFyLCBkID0gX0JhbGFuY2VJU09EYXRlMy5tb250aCwgbSA9IF9CYWxhbmNlSVNPRGF0ZTMuZGF5KSwge1xuICAgIHllYXI6IGwsXG4gICAgbW9udGg6IGQsXG4gICAgZGF5OiBtXG4gIH07XG59XG5mdW5jdGlvbiBBZGRUaW1lKGUsIHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMpIHtcbiAgdmFyIF9CYWxhbmNlVGltZTM7XG4gIHZhciBoID0gZSxcbiAgICB1ID0gdCxcbiAgICBUID0gcixcbiAgICBwID0gbyxcbiAgICBmID0gbixcbiAgICB5ID0gYTtcbiAgaCArPSBpLCB1ICs9IHMsIFQgKz0gbCwgcCArPSBkLCBmICs9IG0sIHkgKz0gYztcbiAgdmFyIEkgPSAwO1xuICByZXR1cm4gKF9CYWxhbmNlVGltZTMgPSBCYWxhbmNlVGltZShoLCB1LCBULCBwLCBmLCB5KSwgSSA9IF9CYWxhbmNlVGltZTMuZGVsdGFEYXlzLCBoID0gX0JhbGFuY2VUaW1lMy5ob3VyLCB1ID0gX0JhbGFuY2VUaW1lMy5taW51dGUsIFQgPSBfQmFsYW5jZVRpbWUzLnNlY29uZCwgcCA9IF9CYWxhbmNlVGltZTMubWlsbGlzZWNvbmQsIGYgPSBfQmFsYW5jZVRpbWUzLm1pY3Jvc2Vjb25kLCB5ID0gX0JhbGFuY2VUaW1lMy5uYW5vc2Vjb25kKSwge1xuICAgIGRlbHRhRGF5czogSSxcbiAgICBob3VyOiBoLFxuICAgIG1pbnV0ZTogdSxcbiAgICBzZWNvbmQ6IFQsXG4gICAgbWlsbGlzZWNvbmQ6IHAsXG4gICAgbWljcm9zZWNvbmQ6IGYsXG4gICAgbmFub3NlY29uZDogeVxuICB9O1xufVxuZnVuY3Rpb24gQWRkRHVyYXRpb24odCwgciwgbywgYSwgaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVCwgZiwgeSwgSSwgdywgRCwgRywgdiwgQykge1xuICB2YXIgTyA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhEZWZhdWx0VGVtcG9yYWxMYXJnZXN0VW5pdCh0LCByLCBvLCBhLCBpLCBzLCBsLCBkLCBtLCBjKSwgRGVmYXVsdFRlbXBvcmFsTGFyZ2VzdFVuaXQoaCwgdSwgVCwgZiwgeSwgSSwgdywgRCwgRywgdikpO1xuICB2YXIgYiwgRSwgTSwgUiwgRiwgWSwgUCwgWiwgQiwgTjtcbiAgaWYgKEMpIHtcbiAgICBpZiAoSXNUZW1wb3JhbERhdGUoQykpIHtcbiAgICAgIHZhciBfQ2FsZW5kYXJEYXRlVW50aWw0LCBfQmFsYW5jZUR1cmF0aW9uNjtcbiAgICAgIHZhciBfbjEwID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKSxcbiAgICAgICAgX1MyID0gR2V0U2xvdChDLCBwKSxcbiAgICAgICAgX2cgPSBuZXcgX24xMCh0LCByLCBvLCBhLCAwLCAwLCAwLCAwLCAwLCAwKSxcbiAgICAgICAgX2ogPSBuZXcgX24xMChoLCB1LCBULCBmLCAwLCAwLCAwLCAwLCAwLCAwKSxcbiAgICAgICAgXyQgPSBcInN0cmluZ1wiICE9IHR5cGVvZiBfUzIgPyBHZXRNZXRob2QoX1MyLCBcImRhdGVBZGRcIikgOiB2b2lkIDAsXG4gICAgICAgIF9rID0gQ2FsZW5kYXJEYXRlQWRkKF9TMiwgQywgX2csIHZvaWQgMCwgXyQpLFxuICAgICAgICBfVSA9IENhbGVuZGFyRGF0ZUFkZChfUzIsIF9rLCBfaiwgdm9pZCAwLCBfJCksXG4gICAgICAgIF9BID0gTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKFwiZGF5XCIsIE8pLFxuICAgICAgICBfTCA9IFRlKG51bGwpO1xuICAgICAgX0wubGFyZ2VzdFVuaXQgPSBfQSwgKF9DYWxlbmRhckRhdGVVbnRpbDQgPSBDYWxlbmRhckRhdGVVbnRpbChfUzIsIEMsIF9VLCBfTCksIGIgPSBfQ2FsZW5kYXJEYXRlVW50aWw0LnllYXJzLCBFID0gX0NhbGVuZGFyRGF0ZVVudGlsNC5tb250aHMsIE0gPSBfQ2FsZW5kYXJEYXRlVW50aWw0LndlZWtzLCBSID0gX0NhbGVuZGFyRGF0ZVVudGlsNC5kYXlzKSwgKF9CYWxhbmNlRHVyYXRpb242ID0gQmFsYW5jZUR1cmF0aW9uKFIsIEJpZ0ludChpKSArIEJpZ0ludCh5KSwgQmlnSW50KHMpICsgQmlnSW50KEkpLCBCaWdJbnQobCkgKyBCaWdJbnQodyksIEJpZ0ludChkKSArIEJpZ0ludChEKSwgQmlnSW50KG0pICsgQmlnSW50KEcpLCBCaWdJbnQoYykgKyBCaWdJbnQodiksIE8pLCBSID0gX0JhbGFuY2VEdXJhdGlvbjYuZGF5cywgRiA9IF9CYWxhbmNlRHVyYXRpb242LmhvdXJzLCBZID0gX0JhbGFuY2VEdXJhdGlvbjYubWludXRlcywgUCA9IF9CYWxhbmNlRHVyYXRpb242LnNlY29uZHMsIFogPSBfQmFsYW5jZUR1cmF0aW9uNi5taWxsaXNlY29uZHMsIEIgPSBfQmFsYW5jZUR1cmF0aW9uNi5taWNyb3NlY29uZHMsIE4gPSBfQmFsYW5jZUR1cmF0aW9uNi5uYW5vc2Vjb25kcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfRGlmZmVyZW5jZUluc3RhbnQzLCBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQyO1xuICAgICAgdmFyIF9lMjkgPSBHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuSW5zdGFudCVcIiksXG4gICAgICAgIF9qMiA9IEdldFNsb3QoQywgZyksXG4gICAgICAgIF8kMiA9IEdldFNsb3QoQywgcCksXG4gICAgICAgIF9rMiA9IEFkZFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChDLCBTKSwgX2oyLCBfJDIsIHQsIHIsIG8sIGEsIGksIHMsIGwsIGQsIG0sIGMpLFxuICAgICAgICBfVTIgPSBBZGRab25lZERhdGVUaW1lKG5ldyBfZTI5KF9rMiksIF9qMiwgXyQyLCBoLCB1LCBULCBmLCB5LCBJLCB3LCBELCBHLCB2KTtcbiAgICAgIFwieWVhclwiICE9PSBPICYmIFwibW9udGhcIiAhPT0gTyAmJiBcIndlZWtcIiAhPT0gTyAmJiBcImRheVwiICE9PSBPID8gKGIgPSAwLCBFID0gMCwgTSA9IDAsIFIgPSAwLCAoX0RpZmZlcmVuY2VJbnN0YW50MyA9IERpZmZlcmVuY2VJbnN0YW50KEdldFNsb3QoQywgbiksIF9VMiwgMSwgXCJuYW5vc2Vjb25kXCIsIE8sIFwiaGFsZkV4cGFuZFwiKSwgRiA9IF9EaWZmZXJlbmNlSW5zdGFudDMuaG91cnMsIFkgPSBfRGlmZmVyZW5jZUluc3RhbnQzLm1pbnV0ZXMsIFAgPSBfRGlmZmVyZW5jZUluc3RhbnQzLnNlY29uZHMsIFogPSBfRGlmZmVyZW5jZUluc3RhbnQzLm1pbGxpc2Vjb25kcywgQiA9IF9EaWZmZXJlbmNlSW5zdGFudDMubWljcm9zZWNvbmRzLCBOID0gX0RpZmZlcmVuY2VJbnN0YW50My5uYW5vc2Vjb25kcykpIDogKF9EaWZmZXJlbmNlWm9uZWREYXRlVDIgPSBEaWZmZXJlbmNlWm9uZWREYXRlVGltZShHZXRTbG90KEMsIG4pLCBfVTIsIF9qMiwgXyQyLCBPLCBUZShudWxsKSksIGIgPSBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQyLnllYXJzLCBFID0gX0RpZmZlcmVuY2Vab25lZERhdGVUMi5tb250aHMsIE0gPSBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQyLndlZWtzLCBSID0gX0RpZmZlcmVuY2Vab25lZERhdGVUMi5kYXlzLCBGID0gX0RpZmZlcmVuY2Vab25lZERhdGVUMi5ob3VycywgWSA9IF9EaWZmZXJlbmNlWm9uZWREYXRlVDIubWludXRlcywgUCA9IF9EaWZmZXJlbmNlWm9uZWREYXRlVDIuc2Vjb25kcywgWiA9IF9EaWZmZXJlbmNlWm9uZWREYXRlVDIubWlsbGlzZWNvbmRzLCBCID0gX0RpZmZlcmVuY2Vab25lZERhdGVUMi5taWNyb3NlY29uZHMsIE4gPSBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQyLm5hbm9zZWNvbmRzLCBfRGlmZmVyZW5jZVpvbmVkRGF0ZVQyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9CYWxhbmNlRHVyYXRpb243O1xuICAgIGlmIChcInllYXJcIiA9PT0gTyB8fCBcIm1vbnRoXCIgPT09IE8gfHwgXCJ3ZWVrXCIgPT09IE8pIHRocm93IG5ldyBSYW5nZUVycm9yKFwicmVsYXRpdmVUbyBpcyByZXF1aXJlZCBmb3IgeWVhcnMsIG1vbnRocywgb3Igd2Vla3MgYXJpdGhtZXRpY1wiKTtcbiAgICBiID0gRSA9IE0gPSAwLCAoX0JhbGFuY2VEdXJhdGlvbjcgPSBCYWxhbmNlRHVyYXRpb24oYSArIGYsIEJpZ0ludChpKSArIEJpZ0ludCh5KSwgQmlnSW50KHMpICsgQmlnSW50KEkpLCBCaWdJbnQobCkgKyBCaWdJbnQodyksIEJpZ0ludChkKSArIEJpZ0ludChEKSwgQmlnSW50KG0pICsgQmlnSW50KEcpLCBCaWdJbnQoYykgKyBCaWdJbnQodiksIE8pLCBSID0gX0JhbGFuY2VEdXJhdGlvbjcuZGF5cywgRiA9IF9CYWxhbmNlRHVyYXRpb243LmhvdXJzLCBZID0gX0JhbGFuY2VEdXJhdGlvbjcubWludXRlcywgUCA9IF9CYWxhbmNlRHVyYXRpb243LnNlY29uZHMsIFogPSBfQmFsYW5jZUR1cmF0aW9uNy5taWxsaXNlY29uZHMsIEIgPSBfQmFsYW5jZUR1cmF0aW9uNy5taWNyb3NlY29uZHMsIE4gPSBfQmFsYW5jZUR1cmF0aW9uNy5uYW5vc2Vjb25kcyk7XG4gIH1cbiAgcmV0dXJuIFJlamVjdER1cmF0aW9uKGIsIEUsIE0sIFIsIEYsIFksIFAsIFosIEIsIE4pLCB7XG4gICAgeWVhcnM6IGIsXG4gICAgbW9udGhzOiBFLFxuICAgIHdlZWtzOiBNLFxuICAgIGRheXM6IFIsXG4gICAgaG91cnM6IEYsXG4gICAgbWludXRlczogWSxcbiAgICBzZWNvbmRzOiBQLFxuICAgIG1pbGxpc2Vjb25kczogWixcbiAgICBtaWNyb3NlY29uZHM6IEIsXG4gICAgbmFub3NlY29uZHM6IE5cbiAgfTtcbn1cbmZ1bmN0aW9uIEFkZEluc3RhbnQodCwgciwgbywgbiwgYSwgaSwgcykge1xuICB2YXIgbCA9IEllO1xuICBsID0gbCArIEJpZ0ludChzKSwgbCA9IGwgKyBCaWdJbnQoaSkgKiBEZSwgbCA9IGwgKyBCaWdJbnQoYSkgKiBHZSwgbCA9IGwgKyBCaWdJbnQobikgKiB2ZSwgbCA9IGwgKyBCaWdJbnQobykgKiA2MDAwMDAwMDAwMG4sIGwgPSBsICsgQmlnSW50KHIpICogMzYwMDAwMDAwMDAwMG47XG4gIHZhciBkID0gdCArIGw7XG4gIHJldHVybiBWYWxpZGF0ZUVwb2NoTmFub3NlY29uZHMoZCksIGQ7XG59XG5mdW5jdGlvbiBBZGREYXRlVGltZShlLCB0LCByLCBvLCBuLCBhLCBkLCBtLCBjLCBoLCB1LCBULCBwLCBmLCB5LCBJLCBTLCBnLCB3LCBELCBHKSB7XG4gIHZhciB2ID0gZixcbiAgICBfQWRkVGltZSA9IEFkZFRpbWUobywgbiwgYSwgZCwgbSwgYywgeSwgSSwgUywgZywgdywgRCksXG4gICAgQyA9IF9BZGRUaW1lLmRlbHRhRGF5cyxcbiAgICBPID0gX0FkZFRpbWUuaG91cixcbiAgICBiID0gX0FkZFRpbWUubWludXRlLFxuICAgIEUgPSBfQWRkVGltZS5zZWNvbmQsXG4gICAgTSA9IF9BZGRUaW1lLm1pbGxpc2Vjb25kLFxuICAgIFIgPSBfQWRkVGltZS5taWNyb3NlY29uZCxcbiAgICBGID0gX0FkZFRpbWUubmFub3NlY29uZDtcbiAgdiArPSBDO1xuICB2YXIgWSA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIiksXG4gICAgUCA9IENhbGVuZGFyRGF0ZUFkZChoLCBDcmVhdGVUZW1wb3JhbERhdGUoZSwgdCwgciwgaCksIG5ldyBZKHUsIFQsIHAsIHYsIDAsIDAsIDAsIDAsIDAsIDApLCBHKTtcbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiBHZXRTbG90KFAsIGkpLFxuICAgIG1vbnRoOiBHZXRTbG90KFAsIHMpLFxuICAgIGRheTogR2V0U2xvdChQLCBsKSxcbiAgICBob3VyOiBPLFxuICAgIG1pbnV0ZTogYixcbiAgICBzZWNvbmQ6IEUsXG4gICAgbWlsbGlzZWNvbmQ6IE0sXG4gICAgbWljcm9zZWNvbmQ6IFIsXG4gICAgbmFub3NlY29uZDogRlxuICB9O1xufVxuZnVuY3Rpb24gQWRkWm9uZWREYXRlVGltZShlLCB0LCByLCBvLCBhLCBwLCBmLCB5LCBJLCBTLCBnLCB3LCBELCBHKSB7XG4gIHZhciB2ID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKTtcbiAgaWYgKDAgPT09IER1cmF0aW9uU2lnbihvLCBhLCBwLCBmLCAwLCAwLCAwLCAwLCAwLCAwKSkgcmV0dXJuIEFkZEluc3RhbnQoR2V0U2xvdChlLCBuKSwgeSwgSSwgUywgZywgdywgRCk7XG4gIHZhciBDID0gR2V0UGxhaW5EYXRlVGltZUZvcih0LCBlLCByKSxcbiAgICBPID0gQ2FsZW5kYXJEYXRlQWRkKHIsIENyZWF0ZVRlbXBvcmFsRGF0ZShHZXRTbG90KEMsIGkpLCBHZXRTbG90KEMsIHMpLCBHZXRTbG90KEMsIGwpLCByKSwgbmV3IHYobywgYSwgcCwgZiwgMCwgMCwgMCwgMCwgMCwgMCksIEcpLFxuICAgIGIgPSBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKEdldFNsb3QoTywgaSksIEdldFNsb3QoTywgcyksIEdldFNsb3QoTywgbCksIEdldFNsb3QoQywgZCksIEdldFNsb3QoQywgbSksIEdldFNsb3QoQywgYyksIEdldFNsb3QoQywgaCksIEdldFNsb3QoQywgdSksIEdldFNsb3QoQywgVCksIHIpO1xuICByZXR1cm4gQWRkSW5zdGFudChHZXRTbG90KEdldEluc3RhbnRGb3IodCwgYiwgXCJjb21wYXRpYmxlXCIpLCBuKSwgeSwgSSwgUywgZywgdywgRCk7XG59XG5mdW5jdGlvbiBBZGREdXJhdGlvblRvT3JTdWJ0cmFjdER1cmF0aW9uRnJvbUR1cmF0aW9uKGUsIHQsIHIsIG8pIHtcbiAgdmFyIG4gPSBcInN1YnRyYWN0XCIgPT09IGUgPyAtMSA6IDE7XG4gIHZhciBfVG9UZW1wb3JhbER1cmF0aW9uUmUyID0gVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkKHIpLFxuICAgIGEgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUyLnllYXJzLFxuICAgIGkgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUyLm1vbnRocyxcbiAgICBzID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlMi53ZWVrcyxcbiAgICBsID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlMi5kYXlzLFxuICAgIGQgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUyLmhvdXJzLFxuICAgIG0gPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUyLm1pbnV0ZXMsXG4gICAgYyA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTIuc2Vjb25kcyxcbiAgICBoID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlMi5taWxsaXNlY29uZHMsXG4gICAgdSA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTIubWljcm9zZWNvbmRzLFxuICAgIFQgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUyLm5hbm9zZWNvbmRzO1xuICB2YXIgcCA9IFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChHZXRPcHRpb25zT2JqZWN0KG8pKTtcbiAgdmFyIF9BZGREdXJhdGlvbiA9IEFkZER1cmF0aW9uKEdldFNsb3QodCwgdyksIEdldFNsb3QodCwgRCksIEdldFNsb3QodCwgRyksIEdldFNsb3QodCwgdiksIEdldFNsb3QodCwgQyksIEdldFNsb3QodCwgTyksIEdldFNsb3QodCwgYiksIEdldFNsb3QodCwgRSksIEdldFNsb3QodCwgTSksIEdldFNsb3QodCwgUiksIG4gKiBhLCBuICogaSwgbiAqIHMsIG4gKiBsLCBuICogZCwgbiAqIG0sIG4gKiBjLCBuICogaCwgbiAqIHUsIG4gKiBULCBwKTtcbiAgYSA9IF9BZGREdXJhdGlvbi55ZWFycztcbiAgaSA9IF9BZGREdXJhdGlvbi5tb250aHM7XG4gIHMgPSBfQWRkRHVyYXRpb24ud2Vla3M7XG4gIGwgPSBfQWRkRHVyYXRpb24uZGF5cztcbiAgZCA9IF9BZGREdXJhdGlvbi5ob3VycztcbiAgbSA9IF9BZGREdXJhdGlvbi5taW51dGVzO1xuICBjID0gX0FkZER1cmF0aW9uLnNlY29uZHM7XG4gIGggPSBfQWRkRHVyYXRpb24ubWlsbGlzZWNvbmRzO1xuICB1ID0gX0FkZER1cmF0aW9uLm1pY3Jvc2Vjb25kcztcbiAgVCA9IF9BZGREdXJhdGlvbi5uYW5vc2Vjb25kcztcbiAgcmV0dXJuIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKSkoYSwgaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVCk7XG59XG5mdW5jdGlvbiBBZGREdXJhdGlvblRvT3JTdWJ0cmFjdER1cmF0aW9uRnJvbUluc3RhbnQoZSwgdCwgcikge1xuICB2YXIgbyA9IFwic3VidHJhY3RcIiA9PT0gZSA/IC0xIDogMSxcbiAgICBfVG9MaW1pdGVkVGVtcG9yYWxEdXIgPSBmdW5jdGlvbiBUb0xpbWl0ZWRUZW1wb3JhbER1cmF0aW9uKGUsIHQpIHtcbiAgICAgIHZhciByID0gVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkKGUpO1xuICAgICAgdmFyIF9pdGVyYXRvcjE0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodCksXG4gICAgICAgIF9zdGVwMTQ7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjE0LnMoKTsgIShfc3RlcDE0ID0gX2l0ZXJhdG9yMTQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfZTMwID0gX3N0ZXAxNC52YWx1ZTtcbiAgICAgICAgICBpZiAoMCAhPT0gcltfZTMwXSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXJhdGlvbiBmaWVsZCBcIi5jb25jYXQoX2UzMCwgXCIgbm90IHN1cHBvcnRlZCBieSBUZW1wb3JhbC5JbnN0YW50LiBUcnkgVGVtcG9yYWwuWm9uZWREYXRlVGltZSBpbnN0ZWFkLlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxNC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxNC5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9KHIsIFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgXCJkYXlzXCJdKSxcbiAgICBhID0gX1RvTGltaXRlZFRlbXBvcmFsRHVyLmhvdXJzLFxuICAgIGkgPSBfVG9MaW1pdGVkVGVtcG9yYWxEdXIubWludXRlcyxcbiAgICBzID0gX1RvTGltaXRlZFRlbXBvcmFsRHVyLnNlY29uZHMsXG4gICAgbCA9IF9Ub0xpbWl0ZWRUZW1wb3JhbER1ci5taWxsaXNlY29uZHMsXG4gICAgZCA9IF9Ub0xpbWl0ZWRUZW1wb3JhbER1ci5taWNyb3NlY29uZHMsXG4gICAgbSA9IF9Ub0xpbWl0ZWRUZW1wb3JhbER1ci5uYW5vc2Vjb25kcyxcbiAgICBjID0gQWRkSW5zdGFudChHZXRTbG90KHQsIG4pLCBvICogYSwgbyAqIGksIG8gKiBzLCBvICogbCwgbyAqIGQsIG8gKiBtKTtcbiAgcmV0dXJuIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpKShjKTtcbn1cbmZ1bmN0aW9uIEFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tUGxhaW5EYXRlVGltZShlLCB0LCByLCBvKSB7XG4gIHZhciBuID0gXCJzdWJ0cmFjdFwiID09PSBlID8gLTEgOiAxLFxuICAgIF9Ub1RlbXBvcmFsRHVyYXRpb25SZTMgPSBUb1RlbXBvcmFsRHVyYXRpb25SZWNvcmQociksXG4gICAgYSA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTMueWVhcnMsXG4gICAgZiA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTMubW9udGhzLFxuICAgIHkgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUzLndlZWtzLFxuICAgIEkgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUzLmRheXMsXG4gICAgUyA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTMuaG91cnMsXG4gICAgZyA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTMubWludXRlcyxcbiAgICB3ID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlMy5zZWNvbmRzLFxuICAgIEQgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmUzLm1pbGxpc2Vjb25kcyxcbiAgICBHID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlMy5taWNyb3NlY29uZHMsXG4gICAgdiA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTMubmFub3NlY29uZHMsXG4gICAgQyA9IEdldE9wdGlvbnNPYmplY3QobyksXG4gICAgTyA9IEdldFNsb3QodCwgcCksXG4gICAgX0FkZERhdGVUaW1lID0gQWRkRGF0ZVRpbWUoR2V0U2xvdCh0LCBpKSwgR2V0U2xvdCh0LCBzKSwgR2V0U2xvdCh0LCBsKSwgR2V0U2xvdCh0LCBkKSwgR2V0U2xvdCh0LCBtKSwgR2V0U2xvdCh0LCBjKSwgR2V0U2xvdCh0LCBoKSwgR2V0U2xvdCh0LCB1KSwgR2V0U2xvdCh0LCBUKSwgTywgbiAqIGEsIG4gKiBmLCBuICogeSwgbiAqIEksIG4gKiBTLCBuICogZywgbiAqIHcsIG4gKiBELCBuICogRywgbiAqIHYsIEMpLFxuICAgIGIgPSBfQWRkRGF0ZVRpbWUueWVhcixcbiAgICBFID0gX0FkZERhdGVUaW1lLm1vbnRoLFxuICAgIE0gPSBfQWRkRGF0ZVRpbWUuZGF5LFxuICAgIFIgPSBfQWRkRGF0ZVRpbWUuaG91cixcbiAgICBGID0gX0FkZERhdGVUaW1lLm1pbnV0ZSxcbiAgICBZID0gX0FkZERhdGVUaW1lLnNlY29uZCxcbiAgICBQID0gX0FkZERhdGVUaW1lLm1pbGxpc2Vjb25kLFxuICAgIFogPSBfQWRkRGF0ZVRpbWUubWljcm9zZWNvbmQsXG4gICAgQiA9IF9BZGREYXRlVGltZS5uYW5vc2Vjb25kO1xuICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZShiLCBFLCBNLCBSLCBGLCBZLCBQLCBaLCBCLCBPKTtcbn1cbmZ1bmN0aW9uIEFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tUGxhaW5UaW1lKGUsIHQsIHIpIHtcbiAgdmFyIG8gPSBcInN1YnRyYWN0XCIgPT09IGUgPyAtMSA6IDEsXG4gICAgX1RvVGVtcG9yYWxEdXJhdGlvblJlNCA9IFRvVGVtcG9yYWxEdXJhdGlvblJlY29yZChyKSxcbiAgICBuID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlNC5ob3VycyxcbiAgICBhID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlNC5taW51dGVzLFxuICAgIGkgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmU0LnNlY29uZHMsXG4gICAgcyA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTQubWlsbGlzZWNvbmRzLFxuICAgIGwgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmU0Lm1pY3Jvc2Vjb25kcyxcbiAgICBwID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlNC5uYW5vc2Vjb25kcztcbiAgdmFyIF9BZGRUaW1lMiA9IEFkZFRpbWUoR2V0U2xvdCh0LCBkKSwgR2V0U2xvdCh0LCBtKSwgR2V0U2xvdCh0LCBjKSwgR2V0U2xvdCh0LCBoKSwgR2V0U2xvdCh0LCB1KSwgR2V0U2xvdCh0LCBUKSwgbyAqIG4sIG8gKiBhLCBvICogaSwgbyAqIHMsIG8gKiBsLCBvICogcCksXG4gICAgZiA9IF9BZGRUaW1lMi5ob3VyLFxuICAgIHkgPSBfQWRkVGltZTIubWludXRlLFxuICAgIEkgPSBfQWRkVGltZTIuc2Vjb25kLFxuICAgIFMgPSBfQWRkVGltZTIubWlsbGlzZWNvbmQsXG4gICAgZyA9IF9BZGRUaW1lMi5taWNyb3NlY29uZCxcbiAgICB3ID0gX0FkZFRpbWUyLm5hbm9zZWNvbmQ7XG4gIHZhciBfUmVndWxhdGVUaW1lMyA9IFJlZ3VsYXRlVGltZShmLCB5LCBJLCBTLCBnLCB3LCBcInJlamVjdFwiKTtcbiAgZiA9IF9SZWd1bGF0ZVRpbWUzLmhvdXI7XG4gIHkgPSBfUmVndWxhdGVUaW1lMy5taW51dGU7XG4gIEkgPSBfUmVndWxhdGVUaW1lMy5zZWNvbmQ7XG4gIFMgPSBfUmVndWxhdGVUaW1lMy5taWxsaXNlY29uZDtcbiAgZyA9IF9SZWd1bGF0ZVRpbWUzLm1pY3Jvc2Vjb25kO1xuICB3ID0gX1JlZ3VsYXRlVGltZTMubmFub3NlY29uZDtcbiAgcmV0dXJuIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlBsYWluVGltZSVcIikpKGYsIHksIEksIFMsIGcsIHcpO1xufVxuZnVuY3Rpb24gQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21QbGFpblllYXJNb250aChlLCB0LCByLCBvKSB7XG4gIHZhciBuID0gVG9UZW1wb3JhbER1cmF0aW9uUmVjb3JkKHIpO1xuICBcInN1YnRyYWN0XCIgPT09IGUgJiYgKG4gPSB7XG4gICAgeWVhcnM6IC1uLnllYXJzLFxuICAgIG1vbnRoczogLW4ubW9udGhzLFxuICAgIHdlZWtzOiAtbi53ZWVrcyxcbiAgICBkYXlzOiAtbi5kYXlzLFxuICAgIGhvdXJzOiAtbi5ob3VycyxcbiAgICBtaW51dGVzOiAtbi5taW51dGVzLFxuICAgIHNlY29uZHM6IC1uLnNlY29uZHMsXG4gICAgbWlsbGlzZWNvbmRzOiAtbi5taWxsaXNlY29uZHMsXG4gICAgbWljcm9zZWNvbmRzOiAtbi5taWNyb3NlY29uZHMsXG4gICAgbmFub3NlY29uZHM6IC1uLm5hbm9zZWNvbmRzXG4gIH0pO1xuICB2YXIgX24xMSA9IG4sXG4gICAgYSA9IF9uMTEueWVhcnMsXG4gICAgaSA9IF9uMTEubW9udGhzLFxuICAgIHMgPSBfbjExLndlZWtzLFxuICAgIGwgPSBfbjExLmRheXMsXG4gICAgZCA9IF9uMTEuaG91cnMsXG4gICAgbSA9IF9uMTEubWludXRlcyxcbiAgICBjID0gX24xMS5zZWNvbmRzLFxuICAgIGggPSBfbjExLm1pbGxpc2Vjb25kcyxcbiAgICB1ID0gX24xMS5taWNyb3NlY29uZHMsXG4gICAgVCA9IF9uMTEubmFub3NlY29uZHM7XG4gIHZhciBfQmFsYW5jZUR1cmF0aW9uOCA9IEJhbGFuY2VEdXJhdGlvbihsLCBkLCBtLCBjLCBoLCB1LCBULCBcImRheVwiKTtcbiAgbCA9IF9CYWxhbmNlRHVyYXRpb244LmRheXM7XG4gIHZhciBmID0gR2V0T3B0aW9uc09iamVjdChvKSxcbiAgICB5ID0gR2V0U2xvdCh0LCBwKSxcbiAgICBJID0gQ2FsZW5kYXJGaWVsZHMoeSwgW1wibW9udGhDb2RlXCIsIFwieWVhclwiXSksXG4gICAgUyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyh0LCBJLCBbXSksXG4gICAgZyA9IFRlKG51bGwpO1xuICBDb3B5RGF0YVByb3BlcnRpZXMoZywgUywgW10pLCBTLmRheSA9IDE7XG4gIHZhciB3ID0gQ2FsZW5kYXJEYXRlRnJvbUZpZWxkcyh5LCBTKTtcbiAgdmFyIEQgPSBEdXJhdGlvblNpZ24oYSwgaSwgcywgbCwgMCwgMCwgMCwgMCwgMCwgMCksXG4gICAgRyA9IEdldE1ldGhvZCh5LCBcImRhdGVBZGRcIiksXG4gICAgdiA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIik7XG4gIGlmIChEIDwgMCkge1xuICAgIHZhciBfZTMxID0gQ2FsZW5kYXJEYXRlQWRkKHksIHcsIG5ldyB2KDAsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApLCB2b2lkIDAsIEcpLFxuICAgICAgX3QzMCA9IENhbGVuZGFyRGF0ZUFkZCh5LCBfZTMxLCBuZXcgdigwLCAwLCAwLCAtMSwgMCwgMCwgMCwgMCwgMCwgMCksIHZvaWQgMCwgRyk7XG4gICAgZy5kYXkgPSBDYWxlbmRhckRheSh5LCBfdDMwKSwgdyA9IENhbGVuZGFyRGF0ZUZyb21GaWVsZHMoeSwgZyk7XG4gIH1cbiAgdmFyIEMgPSBuZXcgdihhLCBpLCBzLCBsLCAwLCAwLCAwLCAwLCAwLCAwKSxcbiAgICBPID0gQ29weU9wdGlvbnMoZik7XG4gIHJldHVybiBDYWxlbmRhclllYXJNb250aEZyb21GaWVsZHMoeSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKENhbGVuZGFyRGF0ZUFkZCh5LCB3LCBDLCBmLCBHKSwgSSwgW10pLCBPKTtcbn1cbmZ1bmN0aW9uIEFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tWm9uZWREYXRlVGltZShlLCB0LCByLCBvKSB7XG4gIHZhciBuID0gXCJzdWJ0cmFjdFwiID09PSBlID8gLTEgOiAxLFxuICAgIF9Ub1RlbXBvcmFsRHVyYXRpb25SZTUgPSBUb1RlbXBvcmFsRHVyYXRpb25SZWNvcmQociksXG4gICAgYSA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTUueWVhcnMsXG4gICAgaSA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTUubW9udGhzLFxuICAgIHMgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmU1LndlZWtzLFxuICAgIGwgPSBfVG9UZW1wb3JhbER1cmF0aW9uUmU1LmRheXMsXG4gICAgZCA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTUuaG91cnMsXG4gICAgbSA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTUubWludXRlcyxcbiAgICBjID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlNS5zZWNvbmRzLFxuICAgIGggPSBfVG9UZW1wb3JhbER1cmF0aW9uUmU1Lm1pbGxpc2Vjb25kcyxcbiAgICB1ID0gX1RvVGVtcG9yYWxEdXJhdGlvblJlNS5taWNyb3NlY29uZHMsXG4gICAgVCA9IF9Ub1RlbXBvcmFsRHVyYXRpb25SZTUubmFub3NlY29uZHMsXG4gICAgZiA9IEdldE9wdGlvbnNPYmplY3QobyksXG4gICAgeSA9IEdldFNsb3QodCwgZyksXG4gICAgSSA9IEdldFNsb3QodCwgcCk7XG4gIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoQWRkWm9uZWREYXRlVGltZShHZXRTbG90KHQsIFMpLCB5LCBJLCBuICogYSwgbiAqIGksIG4gKiBzLCBuICogbCwgbiAqIGQsIG4gKiBtLCBuICogYywgbiAqIGgsIG4gKiB1LCBuICogVCwgZiksIHksIEkpO1xufVxuZnVuY3Rpb24gUm91bmROdW1iZXJUb0luY3JlbWVudCh0LCByLCBvKSB7XG4gIGlmIChyID09PSBTZSkgcmV0dXJuIHQ7XG4gIHZhciBfZGl2bW9kMjEgPSBkaXZtb2QodCwgciksXG4gICAgbiA9IF9kaXZtb2QyMS5xdW90aWVudCxcbiAgICBhID0gX2Rpdm1vZDIxLnJlbWFpbmRlcjtcbiAgaWYgKGEgPT09IEllKSByZXR1cm4gdDtcbiAgdmFyIGkgPSBhIDwgSWUgPyAtMSA6IDEsXG4gICAgcyA9IGFicyhhICogMm4pLFxuICAgIGwgPSBzID09PSByLFxuICAgIGQgPSBzID4gcjtcbiAgc3dpdGNoIChvKSB7XG4gICAgY2FzZSBcImNlaWxcIjpcbiAgICAgIGkgPiAwICYmIChuID0gbiArIEJpZ0ludChpKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZmxvb3JcIjpcbiAgICAgIGkgPCAwICYmIChuID0gbiArIEJpZ0ludChpKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZXhwYW5kXCI6XG4gICAgICBuID0gbiArIEJpZ0ludChpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cnVuY1wiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImhhbGZDZWlsXCI6XG4gICAgICAoZCB8fCBsICYmIGkgPiAwKSAmJiAobiA9IG4gKyBCaWdJbnQoaSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImhhbGZGbG9vclwiOlxuICAgICAgKGQgfHwgbCAmJiBpIDwgMCkgJiYgKG4gPSBuICsgQmlnSW50KGkpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJoYWxmRXhwYW5kXCI6XG4gICAgICAoZCB8fCBsKSAmJiAobiA9IG4gKyBCaWdJbnQoaSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImhhbGZUcnVuY1wiOlxuICAgICAgZCAmJiAobiA9IG4gKyBCaWdJbnQoaSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImhhbGZFdmVuXCI6XG4gICAgICAoZCB8fCBsICYmIDEgPT09IE51bWJlcihhYnMobikgJSAybikpICYmIChuID0gbiArIEJpZ0ludChpKSk7XG4gIH1cbiAgcmV0dXJuIG4gKiByO1xufVxuZnVuY3Rpb24gUm91bmRJbnN0YW50KHQsIHIsIG8sIG4pIHtcbiAgdmFyIF9Ob25OZWdhdGl2ZUJpZ0ludERpdjcgPSBOb25OZWdhdGl2ZUJpZ0ludERpdm1vZCh0LCBFZSksXG4gICAgYSA9IF9Ob25OZWdhdGl2ZUJpZ0ludERpdjcucmVtYWluZGVyO1xuICB2YXIgaSA9IHQgLSBhLFxuICAgIHMgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KGEsIEJpZ0ludChfZVtvXSAqIHIpLCBuKTtcbiAgcmV0dXJuIGkgKyBzO1xufVxuZnVuY3Rpb24gUm91bmRJU09EYXRlVGltZShlLCB0LCByLCBvLCBuLCBhLCBpLCBzLCBsLCBkLCBtLCBjKSB7XG4gIHZhciBoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEyICYmIGFyZ3VtZW50c1sxMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxMl0gOiA4NjRlMTE7XG4gIHZhciBfUm91bmRUaW1lID0gUm91bmRUaW1lKG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMsIGgpLFxuICAgIHUgPSBfUm91bmRUaW1lLmRlbHRhRGF5cyxcbiAgICBUID0gX1JvdW5kVGltZS5ob3VyLFxuICAgIHAgPSBfUm91bmRUaW1lLm1pbnV0ZSxcbiAgICBmID0gX1JvdW5kVGltZS5zZWNvbmQsXG4gICAgeSA9IF9Sb3VuZFRpbWUubWlsbGlzZWNvbmQsXG4gICAgSSA9IF9Sb3VuZFRpbWUubWljcm9zZWNvbmQsXG4gICAgUyA9IF9Sb3VuZFRpbWUubmFub3NlY29uZCxcbiAgICBfQmFsYW5jZUlTT0RhdGU0ID0gQmFsYW5jZUlTT0RhdGUoZSwgdCwgciArIHUpLFxuICAgIGcgPSBfQmFsYW5jZUlTT0RhdGU0LnllYXIsXG4gICAgdyA9IF9CYWxhbmNlSVNPRGF0ZTQubW9udGgsXG4gICAgRCA9IF9CYWxhbmNlSVNPRGF0ZTQuZGF5O1xuICByZXR1cm4ge1xuICAgIHllYXI6IGcsXG4gICAgbW9udGg6IHcsXG4gICAgZGF5OiBELFxuICAgIGhvdXI6IFQsXG4gICAgbWludXRlOiBwLFxuICAgIHNlY29uZDogZixcbiAgICBtaWxsaXNlY29uZDogeSxcbiAgICBtaWNyb3NlY29uZDogSSxcbiAgICBuYW5vc2Vjb25kOiBTXG4gIH07XG59XG5mdW5jdGlvbiBSb3VuZFRpbWUodCwgciwgbywgbiwgYSwgaSwgcywgbCwgZCkge1xuICB2YXIgbSA9IGFyZ3VtZW50cy5sZW5ndGggPiA5ICYmIGFyZ3VtZW50c1s5XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzldIDogODY0ZTExO1xuICB2YXIgYyA9IEllO1xuICBzd2l0Y2ggKGwpIHtcbiAgICBjYXNlIFwiZGF5XCI6XG4gICAgY2FzZSBcImhvdXJcIjpcbiAgICAgIGMgPSBCaWdJbnQodCk7XG4gICAgY2FzZSBcIm1pbnV0ZVwiOlxuICAgICAgYyA9IGMgKiBnZSArIEJpZ0ludChyKTtcbiAgICBjYXNlIFwic2Vjb25kXCI6XG4gICAgICBjID0gYyAqIGdlICsgQmlnSW50KG8pO1xuICAgIGNhc2UgXCJtaWxsaXNlY29uZFwiOlxuICAgICAgYyA9IGMgKiBEZSArIEJpZ0ludChuKTtcbiAgICBjYXNlIFwibWljcm9zZWNvbmRcIjpcbiAgICAgIGMgPSBjICogRGUgKyBCaWdJbnQoYSk7XG4gICAgY2FzZSBcIm5hbm9zZWNvbmRcIjpcbiAgICAgIGMgPSBjICogRGUgKyBCaWdJbnQoaSk7XG4gIH1cbiAgdmFyIGggPSBcImRheVwiID09PSBsID8gbSA6IF9lW2xdLFxuICAgIHUgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KGMsIEJpZ0ludChoICogcyksIGQpLFxuICAgIFQgPSBOdW1iZXIodSAvIEJpZ0ludChoKSk7XG4gIHN3aXRjaCAobCkge1xuICAgIGNhc2UgXCJkYXlcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlbHRhRGF5czogVCxcbiAgICAgICAgaG91cjogMCxcbiAgICAgICAgbWludXRlOiAwLFxuICAgICAgICBzZWNvbmQ6IDAsXG4gICAgICAgIG1pbGxpc2Vjb25kOiAwLFxuICAgICAgICBtaWNyb3NlY29uZDogMCxcbiAgICAgICAgbmFub3NlY29uZDogMFxuICAgICAgfTtcbiAgICBjYXNlIFwiaG91clwiOlxuICAgICAgcmV0dXJuIEJhbGFuY2VUaW1lKFQsIDAsIDAsIDAsIDAsIDApO1xuICAgIGNhc2UgXCJtaW51dGVcIjpcbiAgICAgIHJldHVybiBCYWxhbmNlVGltZSh0LCBULCAwLCAwLCAwLCAwKTtcbiAgICBjYXNlIFwic2Vjb25kXCI6XG4gICAgICByZXR1cm4gQmFsYW5jZVRpbWUodCwgciwgVCwgMCwgMCwgMCk7XG4gICAgY2FzZSBcIm1pbGxpc2Vjb25kXCI6XG4gICAgICByZXR1cm4gQmFsYW5jZVRpbWUodCwgciwgbywgVCwgMCwgMCk7XG4gICAgY2FzZSBcIm1pY3Jvc2Vjb25kXCI6XG4gICAgICByZXR1cm4gQmFsYW5jZVRpbWUodCwgciwgbywgbiwgVCwgMCk7XG4gICAgY2FzZSBcIm5hbm9zZWNvbmRcIjpcbiAgICAgIHJldHVybiBCYWxhbmNlVGltZSh0LCByLCBvLCBuLCBhLCBUKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB1bml0IFwiLmNvbmNhdChsKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIERheXNVbnRpbChlLCB0KSB7XG4gIHJldHVybiBEaWZmZXJlbmNlSVNPRGF0ZShHZXRTbG90KGUsIGkpLCBHZXRTbG90KGUsIHMpLCBHZXRTbG90KGUsIGwpLCBHZXRTbG90KHQsIGkpLCBHZXRTbG90KHQsIHMpLCBHZXRTbG90KHQsIGwpLCBcImRheVwiKS5kYXlzO1xufVxuZnVuY3Rpb24gTW92ZVJlbGF0aXZlRGF0ZShlLCB0LCByLCBvKSB7XG4gIHZhciBuID0gQ2FsZW5kYXJEYXRlQWRkKGUsIHQsIHIsIHZvaWQgMCwgbyk7XG4gIHJldHVybiB7XG4gICAgcmVsYXRpdmVUbzogbixcbiAgICBkYXlzOiBEYXlzVW50aWwodCwgbilcbiAgfTtcbn1cbmZ1bmN0aW9uIE1vdmVSZWxhdGl2ZVpvbmVkRGF0ZVRpbWUoZSwgdCwgciwgbywgbikge1xuICB2YXIgYSA9IEdldFNsb3QoZSwgZyksXG4gICAgaSA9IEdldFNsb3QoZSwgcCk7XG4gIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoQWRkWm9uZWREYXRlVGltZShHZXRTbG90KGUsIFMpLCBhLCBpLCB0LCByLCBvLCBuLCAwLCAwLCAwLCAwLCAwLCAwKSwgYSwgaSk7XG59XG5mdW5jdGlvbiBBZGp1c3RSb3VuZGVkRHVyYXRpb25EYXlzKHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMsIGgsIHUsIFQpIHtcbiAgdmFyIF9BZGREdXJhdGlvbjIsIF9CYWxhbmNlRHVyYXRpb245O1xuICB2YXIgZiA9IHQsXG4gICAgeSA9IHIsXG4gICAgSSA9IG8sXG4gICAgdyA9IG4sXG4gICAgRCA9IGEsXG4gICAgRyA9IGksXG4gICAgdiA9IHMsXG4gICAgQyA9IGwsXG4gICAgTyA9IGQsXG4gICAgYiA9IG07XG4gIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoVCkgfHwgXCJ5ZWFyXCIgPT09IGggfHwgXCJtb250aFwiID09PSBoIHx8IFwid2Vla1wiID09PSBoIHx8IFwiZGF5XCIgPT09IGggfHwgXCJuYW5vc2Vjb25kXCIgPT09IGggJiYgMSA9PT0gYykgcmV0dXJuIHtcbiAgICB5ZWFyczogZixcbiAgICBtb250aHM6IHksXG4gICAgd2Vla3M6IEksXG4gICAgZGF5czogdyxcbiAgICBob3VyczogRCxcbiAgICBtaW51dGVzOiBHLFxuICAgIHNlY29uZHM6IHYsXG4gICAgbWlsbGlzZWNvbmRzOiBDLFxuICAgIG1pY3Jvc2Vjb25kczogTyxcbiAgICBuYW5vc2Vjb25kczogYlxuICB9O1xuICB2YXIgRSA9IFRvdGFsRHVyYXRpb25OYW5vc2Vjb25kcygwLCBELCBHLCB2LCBDLCBPLCBiLCAwKTtcbiAgdmFyIE0gPSBzZShOdW1iZXIoRSkpLFxuICAgIFIgPSBHZXRTbG90KFQsIGcpLFxuICAgIEYgPSBHZXRTbG90KFQsIHApLFxuICAgIFkgPSBBZGRab25lZERhdGVUaW1lKEdldFNsb3QoVCwgUyksIFIsIEYsIGYsIHksIEksIHcsIDAsIDAsIDAsIDAsIDAsIDApLFxuICAgIFAgPSBBZGRab25lZERhdGVUaW1lKG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpKShZKSwgUiwgRiwgMCwgMCwgMCwgTSwgMCwgMCwgMCwgMCwgMCwgMCksXG4gICAgWiA9IFAgLSBZO1xuICByZXR1cm4gKEUgLSBaKSAqIEJpZ0ludChNKSA+PSBJZSAmJiAoKF9BZGREdXJhdGlvbjIgPSBBZGREdXJhdGlvbihmLCB5LCBJLCB3LCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCBNLCAwLCAwLCAwLCAwLCAwLCAwLCBUKSwgZiA9IF9BZGREdXJhdGlvbjIueWVhcnMsIHkgPSBfQWRkRHVyYXRpb24yLm1vbnRocywgSSA9IF9BZGREdXJhdGlvbjIud2Vla3MsIHcgPSBfQWRkRHVyYXRpb24yLmRheXMpLCBFID0gUm91bmRJbnN0YW50KEUgLSBaLCBjLCBoLCB1KSwgKF9CYWxhbmNlRHVyYXRpb245ID0gQmFsYW5jZUR1cmF0aW9uKDAsIDAsIDAsIDAsIDAsIDAsIE51bWJlcihFKSwgXCJob3VyXCIpLCBEID0gX0JhbGFuY2VEdXJhdGlvbjkuaG91cnMsIEcgPSBfQmFsYW5jZUR1cmF0aW9uOS5taW51dGVzLCB2ID0gX0JhbGFuY2VEdXJhdGlvbjkuc2Vjb25kcywgQyA9IF9CYWxhbmNlRHVyYXRpb245Lm1pbGxpc2Vjb25kcywgTyA9IF9CYWxhbmNlRHVyYXRpb245Lm1pY3Jvc2Vjb25kcywgYiA9IF9CYWxhbmNlRHVyYXRpb245Lm5hbm9zZWNvbmRzKSksIHtcbiAgICB5ZWFyczogZixcbiAgICBtb250aHM6IHksXG4gICAgd2Vla3M6IEksXG4gICAgZGF5czogdyxcbiAgICBob3VyczogRCxcbiAgICBtaW51dGVzOiBHLFxuICAgIHNlY29uZHM6IHYsXG4gICAgbWlsbGlzZWNvbmRzOiBDLFxuICAgIG1pY3Jvc2Vjb25kczogTyxcbiAgICBuYW5vc2Vjb25kczogYlxuICB9O1xufVxuZnVuY3Rpb24gUm91bmREdXJhdGlvbih0LCByLCBvLCBuLCBhLCBpLCBzLCBsLCBkLCBtLCBjLCBoLCB1LCBUKSB7XG4gIHZhciBmID0gdCxcbiAgICB5ID0gcixcbiAgICBJID0gbyxcbiAgICBTID0gbixcbiAgICBnID0gYSxcbiAgICB3ID0gaSxcbiAgICBEID0gcyxcbiAgICBHID0gbCxcbiAgICB2ID0gZCxcbiAgICBDID0gQmlnSW50KG0pO1xuICB2YXIgTyA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5EdXJhdGlvbiVcIik7XG4gIHZhciBiLFxuICAgIEUsXG4gICAgTSxcbiAgICBSLFxuICAgIEYgPSBUO1xuICBpZiAoRikge1xuICAgIGlmIChJc1RlbXBvcmFsWm9uZWREYXRlVGltZShGKSkgRSA9IEYsIEYgPSBUb1RlbXBvcmFsRGF0ZShGKTtlbHNlIGlmICghSXNUZW1wb3JhbERhdGUoRikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzdGFydGluZyBwb2ludCBtdXN0IGJlIFBsYWluRGF0ZSBvciBab25lZERhdGVUaW1lXCIpO1xuICAgIGIgPSBHZXRTbG90KEYsIHApO1xuICB9XG4gIGlmIChcInllYXJcIiA9PT0gaCB8fCBcIm1vbnRoXCIgPT09IGggfHwgXCJ3ZWVrXCIgPT09IGggfHwgXCJkYXlcIiA9PT0gaCkge1xuICAgIHZhciBfTmFub3NlY29uZHNUb0RheXMzO1xuICAgIHZhciBfdDMxLCBfcjQ1LCBfbzE1O1xuICAgIEMgPSBUb3RhbER1cmF0aW9uTmFub3NlY29uZHMoMCwgZywgdywgRCwgRywgdiwgbSwgMCksIEUgJiYgKF90MzEgPSBNb3ZlUmVsYXRpdmVab25lZERhdGVUaW1lKEUsIGYsIHksIEksIFMpKSwgKF9OYW5vc2Vjb25kc1RvRGF5czMgPSBOYW5vc2Vjb25kc1RvRGF5cyhDLCBfdDMxKSwgX3I0NSA9IF9OYW5vc2Vjb25kc1RvRGF5czMuZGF5cywgQyA9IF9OYW5vc2Vjb25kc1RvRGF5czMubmFub3NlY29uZHMsIF9vMTUgPSBfTmFub3NlY29uZHNUb0RheXMzLmRheUxlbmd0aE5zKSwgTSA9IEJpZ0ludChfbzE1KSwgUyArPSBfcjQ1LCBnID0gdyA9IEQgPSBHID0gdiA9IDA7XG4gIH1cbiAgc3dpdGNoIChoKSB7XG4gICAgY2FzZSBcInllYXJcIjpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFiKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIHllYXJzIHJvdW5kaW5nXCIpO1xuICAgICAgICB2YXIgX3QzMiA9IG5ldyBPKGYpLFxuICAgICAgICAgIF9yNDYgPSBcInN0cmluZ1wiICE9IHR5cGVvZiBiID8gR2V0TWV0aG9kKGIsIFwiZGF0ZUFkZFwiKSA6IHZvaWQgMCxcbiAgICAgICAgICBfbzE2ID0gQ2FsZW5kYXJEYXRlQWRkKGIsIEYsIF90MzIsIHZvaWQgMCwgX3I0NiksXG4gICAgICAgICAgX24xMiA9IENhbGVuZGFyRGF0ZUFkZChiLCBGLCBuZXcgTyhmLCB5LCBJKSwgdm9pZCAwLCBfcjQ2KTtcbiAgICAgICAgRiA9IF9vMTYsIFMgKz0gRGF5c1VudGlsKF9vMTYsIF9uMTIpO1xuICAgICAgICB2YXIgX2E4ID0gQ2FsZW5kYXJEYXRlQWRkKGIsIEYsIG5ldyBPKDAsIDAsIDAsIFMpLCB2b2lkIDAsIF9yNDYpLFxuICAgICAgICAgIF9pMTIgPSBUZShudWxsKTtcbiAgICAgICAgX2kxMi5sYXJnZXN0VW5pdCA9IFwieWVhclwiO1xuICAgICAgICB2YXIgX3M0ID0gQ2FsZW5kYXJEYXRlVW50aWwoYiwgRiwgX2E4LCBfaTEyKS55ZWFycztcbiAgICAgICAgZiArPSBfczQ7XG4gICAgICAgIHZhciBfbDUgPSBGO1xuICAgICAgICBGID0gQ2FsZW5kYXJEYXRlQWRkKGIsIEYsIG5ldyBPKF9zNCksIHZvaWQgMCwgX3I0Nik7XG4gICAgICAgIFMgLT0gRGF5c1VudGlsKF9sNSwgRik7XG4gICAgICAgIHZhciBfZDUgPSBuZXcgTyhTIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHZhciBfTW92ZVJlbGF0aXZlRGF0ZTYgPSBNb3ZlUmVsYXRpdmVEYXRlKGIsIEYsIF9kNSwgX3I0NiksXG4gICAgICAgICAgX201ID0gX01vdmVSZWxhdGl2ZURhdGU2LmRheXM7XG4gICAgICAgIF9tNSA9IGFlKF9tNSk7XG4gICAgICAgIHZhciBfaDIgPSBCaWdJbnQoX201KSAqIE07XG4gICAgICAgIEMgPSBfaDIgKiBCaWdJbnQoZikgKyBCaWdJbnQoUykgKiBNICsgQztcbiAgICAgICAgdmFyIF9UMiA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoQywgX2gyICogQmlnSW50KGMpLCB1KTtcbiAgICAgICAgUiA9IEJpZ0ludERpdmlkZVRvTnVtYmVyKEMsIF9oMiksIGYgPSBOdW1iZXIoX1QyIC8gX2gyKSwgQyA9IEllLCB5ID0gSSA9IFMgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFiKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgc3RhcnRpbmcgcG9pbnQgaXMgcmVxdWlyZWQgZm9yIG1vbnRocyByb3VuZGluZ1wiKTtcbiAgICAgICAgdmFyIF90MzMgPSBuZXcgTyhmLCB5KSxcbiAgICAgICAgICBfcjQ3ID0gXCJzdHJpbmdcIiAhPSB0eXBlb2YgYiA/IEdldE1ldGhvZChiLCBcImRhdGVBZGRcIikgOiB2b2lkIDAsXG4gICAgICAgICAgX28xNyA9IENhbGVuZGFyRGF0ZUFkZChiLCBGLCBfdDMzLCB2b2lkIDAsIF9yNDcpLFxuICAgICAgICAgIF9uMTMgPSBDYWxlbmRhckRhdGVBZGQoYiwgRiwgbmV3IE8oZiwgeSwgSSksIHZvaWQgMCwgX3I0Nyk7XG4gICAgICAgIEYgPSBfbzE3LCBTICs9IERheXNVbnRpbChfbzE3LCBfbjEzKTtcbiAgICAgICAgdmFyIF9hOSA9IHNlKFMpLFxuICAgICAgICAgIF9pMTMgPSBuZXcgTygwLCBTIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHZhciBfczU7XG4gICAgICAgIGZvciAoX01vdmVSZWxhdGl2ZURhdGU3ID0gTW92ZVJlbGF0aXZlRGF0ZShiLCBGLCBfaTEzLCBfcjQ3KSwgRiA9IF9Nb3ZlUmVsYXRpdmVEYXRlNy5yZWxhdGl2ZVRvLCBfczUgPSBfTW92ZVJlbGF0aXZlRGF0ZTcuZGF5cywgX01vdmVSZWxhdGl2ZURhdGU3OyBhZShTKSA+PSBhZShfczUpOykge1xuICAgICAgICAgIHZhciBfTW92ZVJlbGF0aXZlRGF0ZTcsIF9Nb3ZlUmVsYXRpdmVEYXRlODtcbiAgICAgICAgICB5ICs9IF9hOSwgUyAtPSBfczUsIChfTW92ZVJlbGF0aXZlRGF0ZTggPSBNb3ZlUmVsYXRpdmVEYXRlKGIsIEYsIF9pMTMsIF9yNDcpLCBGID0gX01vdmVSZWxhdGl2ZURhdGU4LnJlbGF0aXZlVG8sIF9zNSA9IF9Nb3ZlUmVsYXRpdmVEYXRlOC5kYXlzKTtcbiAgICAgICAgfVxuICAgICAgICBfczUgPSBhZShfczUpO1xuICAgICAgICB2YXIgX2w2ID0gQmlnSW50KF9zNSkgKiBNO1xuICAgICAgICBDID0gX2w2ICogQmlnSW50KHkpICsgQmlnSW50KFMpICogTSArIEM7XG4gICAgICAgIHZhciBfZDYgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KEMsIF9sNiAqIEJpZ0ludChjKSwgdSk7XG4gICAgICAgIFIgPSBCaWdJbnREaXZpZGVUb051bWJlcihDLCBfbDYpLCB5ID0gTnVtYmVyKF9kNiAvIF9sNiksIEMgPSBJZSwgSSA9IFMgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwid2Vla1wiOlxuICAgICAge1xuICAgICAgICBpZiAoIWIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3Igd2Vla3Mgcm91bmRpbmdcIik7XG4gICAgICAgIHZhciBfdDM0ID0gc2UoUyksXG4gICAgICAgICAgX3I0OCA9IG5ldyBPKDAsIDAsIFMgPCAwID8gLTEgOiAxKSxcbiAgICAgICAgICBfbzE4ID0gXCJzdHJpbmdcIiAhPSB0eXBlb2YgYiA/IEdldE1ldGhvZChiLCBcImRhdGVBZGRcIikgOiB2b2lkIDA7XG4gICAgICAgIHZhciBfbjE0O1xuICAgICAgICBmb3IgKF9Nb3ZlUmVsYXRpdmVEYXRlOSA9IE1vdmVSZWxhdGl2ZURhdGUoYiwgRiwgX3I0OCwgX28xOCksIEYgPSBfTW92ZVJlbGF0aXZlRGF0ZTkucmVsYXRpdmVUbywgX24xNCA9IF9Nb3ZlUmVsYXRpdmVEYXRlOS5kYXlzLCBfTW92ZVJlbGF0aXZlRGF0ZTk7IGFlKFMpID49IGFlKF9uMTQpOykge1xuICAgICAgICAgIHZhciBfTW92ZVJlbGF0aXZlRGF0ZTksIF9Nb3ZlUmVsYXRpdmVEYXRlMTA7XG4gICAgICAgICAgSSArPSBfdDM0LCBTIC09IF9uMTQsIChfTW92ZVJlbGF0aXZlRGF0ZTEwID0gTW92ZVJlbGF0aXZlRGF0ZShiLCBGLCBfcjQ4LCBfbzE4KSwgRiA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTAucmVsYXRpdmVUbywgX24xNCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTAuZGF5cyk7XG4gICAgICAgIH1cbiAgICAgICAgX24xNCA9IGFlKF9uMTQpO1xuICAgICAgICB2YXIgX2ExMCA9IEJpZ0ludChfbjE0KSAqIE07XG4gICAgICAgIEMgPSBfYTEwICogQmlnSW50KEkpICsgQmlnSW50KFMpICogTSArIEM7XG4gICAgICAgIHZhciBfaTE0ID0gUm91bmROdW1iZXJUb0luY3JlbWVudChDLCBfYTEwICogQmlnSW50KGMpLCB1KTtcbiAgICAgICAgUiA9IEJpZ0ludERpdmlkZVRvTnVtYmVyKEMsIF9hMTApLCBJID0gTnVtYmVyKF9pMTQgLyBfYTEwKSwgQyA9IEllLCBTID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBcImRheVwiOlxuICAgICAge1xuICAgICAgICB2YXIgX3QzNSA9IE07XG4gICAgICAgIEMgPSBfdDM1ICogQmlnSW50KFMpICsgQztcbiAgICAgICAgdmFyIF9yNDkgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KEMsIF90MzUgKiBCaWdJbnQoYyksIHUpO1xuICAgICAgICBSID0gQmlnSW50RGl2aWRlVG9OdW1iZXIoQywgX3QzNSksIFMgPSBOdW1iZXIoX3I0OSAvIF90MzUpLCBDID0gSWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJob3VyXCI6XG4gICAgICB7XG4gICAgICAgIHZhciBfdDM2ID0gMzZlMTE7XG4gICAgICAgIHZhciBfcjUwID0gQmlnSW50KGcpICogMzYwMDAwMDAwMDAwMG47XG4gICAgICAgIF9yNTAgPSBfcjUwICsgQmlnSW50KHcpICogNjAwMDAwMDAwMDBuLCBfcjUwID0gX3I1MCArIEJpZ0ludChEKSAqIHZlLCBfcjUwID0gX3I1MCArIEJpZ0ludChHKSAqIEdlLCBfcjUwID0gX3I1MCArIEJpZ0ludCh2KSAqIERlLCBfcjUwID0gX3I1MCArIEMsIFIgPSBCaWdJbnREaXZpZGVUb051bWJlcihfcjUwLCBCaWdJbnQoX3QzNikpO1xuICAgICAgICB2YXIgX28xOSA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoX3I1MCwgQmlnSW50KF90MzYgKiBjKSwgdSk7XG4gICAgICAgIGcgPSBOdW1iZXIoX28xOSAvIEJpZ0ludChfdDM2KSksIEMgPSBJZSwgdyA9IEQgPSBHID0gdiA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJtaW51dGVcIjpcbiAgICAgIHtcbiAgICAgICAgdmFyIF90MzcgPSA2ZTEwO1xuICAgICAgICB2YXIgX3I1MSA9IEJpZ0ludCh3KSAqIDYwMDAwMDAwMDAwbjtcbiAgICAgICAgX3I1MSA9IF9yNTEgKyBCaWdJbnQoRCkgKiB2ZSwgX3I1MSA9IF9yNTEgKyBCaWdJbnQoRykgKiBHZSwgX3I1MSA9IF9yNTEgKyBCaWdJbnQodikgKiBEZSwgX3I1MSA9IF9yNTEgKyBDLCBSID0gQmlnSW50RGl2aWRlVG9OdW1iZXIoX3I1MSwgQmlnSW50KF90MzcpKTtcbiAgICAgICAgdmFyIF9vMjAgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KF9yNTEsIEJpZ0ludChfdDM3ICogYyksIHUpO1xuICAgICAgICB3ID0gTnVtYmVyKF9vMjAgLyBCaWdJbnQoX3QzNykpLCBDID0gSWUsIEQgPSBHID0gdiA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJzZWNvbmRcIjpcbiAgICAgIHtcbiAgICAgICAgdmFyIF90MzggPSAxZTk7XG4gICAgICAgIHZhciBfcjUyID0gQmlnSW50KEQpICogdmU7XG4gICAgICAgIF9yNTIgPSBfcjUyICsgQmlnSW50KEcpICogR2UsIF9yNTIgPSBfcjUyICsgQmlnSW50KHYpICogRGUsIF9yNTIgPSBfcjUyICsgQywgUiA9IEJpZ0ludERpdmlkZVRvTnVtYmVyKF9yNTIsIEJpZ0ludChfdDM4KSk7XG4gICAgICAgIHZhciBfbzIxID0gUm91bmROdW1iZXJUb0luY3JlbWVudChfcjUyLCBCaWdJbnQoX3QzOCAqIGMpLCB1KTtcbiAgICAgICAgRCA9IE51bWJlcihfbzIxIC8gQmlnSW50KF90MzgpKSwgQyA9IEllLCBHID0gdiA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJtaWxsaXNlY29uZFwiOlxuICAgICAge1xuICAgICAgICB2YXIgX3QzOSA9IDFlNjtcbiAgICAgICAgdmFyIF9yNTMgPSBCaWdJbnQoRykgKiBHZTtcbiAgICAgICAgX3I1MyA9IF9yNTMgKyBCaWdJbnQodikgKiBEZSwgX3I1MyA9IF9yNTMgKyBDLCBSID0gQmlnSW50RGl2aWRlVG9OdW1iZXIoX3I1MywgQmlnSW50KF90MzkpKTtcbiAgICAgICAgdmFyIF9vMjIgPSBSb3VuZE51bWJlclRvSW5jcmVtZW50KF9yNTMsIEJpZ0ludChfdDM5ICogYyksIHUpO1xuICAgICAgICBHID0gTnVtYmVyKF9vMjIgLyBCaWdJbnQoX3QzOSkpLCBDID0gSWUsIHYgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwibWljcm9zZWNvbmRcIjpcbiAgICAgIHtcbiAgICAgICAgdmFyIF90NDAgPSAxZTM7XG4gICAgICAgIHZhciBfcjU0ID0gQmlnSW50KHYpICogRGU7XG4gICAgICAgIF9yNTQgPSBfcjU0ICsgQywgUiA9IEJpZ0ludERpdmlkZVRvTnVtYmVyKF9yNTQsIEJpZ0ludChfdDQwKSk7XG4gICAgICAgIHZhciBfbzIzID0gUm91bmROdW1iZXJUb0luY3JlbWVudChfcjU0LCBCaWdJbnQoX3Q0MCAqIGMpLCB1KTtcbiAgICAgICAgdiA9IE51bWJlcihfbzIzIC8gQmlnSW50KF90NDApKSwgQyA9IEllO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwibmFub3NlY29uZFwiOlxuICAgICAgUiA9IE51bWJlcihDKSwgQyA9IFJvdW5kTnVtYmVyVG9JbmNyZW1lbnQoQmlnSW50KEMpLCBCaWdJbnQoYyksIHUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgeWVhcnM6IGYsXG4gICAgbW9udGhzOiB5LFxuICAgIHdlZWtzOiBJLFxuICAgIGRheXM6IFMsXG4gICAgaG91cnM6IGcsXG4gICAgbWludXRlczogdyxcbiAgICBzZWNvbmRzOiBELFxuICAgIG1pbGxpc2Vjb25kczogRyxcbiAgICBtaWNyb3NlY29uZHM6IHYsXG4gICAgbmFub3NlY29uZHM6IE51bWJlcihDKSxcbiAgICB0b3RhbDogUlxuICB9O1xufVxuZnVuY3Rpb24gQ29tcGFyZUlTT0RhdGUoZSwgdCwgciwgbywgbiwgYSkge1xuICBmb3IgKHZhciBfaTE1ID0gMCwgX2FycjUgPSBbW2UsIG9dLCBbdCwgbl0sIFtyLCBhXV07IF9pMTUgPCBfYXJyNS5sZW5ndGg7IF9pMTUrKykge1xuICAgIHZhciBfYXJyNSRfaSA9IF9zbGljZWRUb0FycmF5KF9hcnI1W19pMTVdLCAyKSxcbiAgICAgIF9pMTYgPSBfYXJyNSRfaVswXSxcbiAgICAgIF9zNiA9IF9hcnI1JF9pWzFdO1xuICAgIGlmIChfaTE2ICE9PSBfczYpIHJldHVybiBDb21wYXJpc29uUmVzdWx0KF9pMTYgLSBfczYpO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gTm9uTmVnYXRpdmVCaWdJbnREaXZtb2QodCwgcikge1xuICB2YXIgX2Rpdm1vZDIyID0gZGl2bW9kKHQsIHIpLFxuICAgIG8gPSBfZGl2bW9kMjIucXVvdGllbnQsXG4gICAgbiA9IF9kaXZtb2QyMi5yZW1haW5kZXI7XG4gIHJldHVybiBuIDwgSWUgJiYgKG8gPSBvIC0gU2UsIG4gPSBuICsgciksIHtcbiAgICBxdW90aWVudDogbyxcbiAgICByZW1haW5kZXI6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIEJpZ0ludEZsb29yRGl2KHQsIHIpIHtcbiAgdmFyIF9kaXZtb2QyMyA9IGRpdm1vZCh0LCByKSxcbiAgICBvID0gX2Rpdm1vZDIzLnF1b3RpZW50LFxuICAgIG4gPSBfZGl2bW9kMjMucmVtYWluZGVyO1xuICByZXR1cm4gaXNaZXJvKG4pIHx8ICFpc05lZ2F0aXZlSlNCSSh0KSA9PSAhaXNOZWdhdGl2ZUpTQkkocikgPyBvIDogbyAtIFNlO1xufVxuZnVuY3Rpb24gQmlnSW50RGl2aWRlVG9OdW1iZXIodCwgcikge1xuICB2YXIgX2Rpdm1vZDI0ID0gZGl2bW9kKHQsIHIpLFxuICAgIG8gPSBfZGl2bW9kMjQucXVvdGllbnQsXG4gICAgbiA9IF9kaXZtb2QyNC5yZW1haW5kZXI7XG4gIHJldHVybiBOdW1iZXIobykgKyBOdW1iZXIobikgLyBOdW1iZXIocik7XG59XG5mdW5jdGlvbiBUb0JpZ0ludEV4dGVybmFsKGUpIHtcbiAgdmFyIHQgPSBUb0JpZ0ludChlKTtcbiAgcmV0dXJuIHZvaWQgMCAhPT0gZ2xvYmFsVGhpcy5CaWdJbnQgPyBnbG9iYWxUaGlzLkJpZ0ludCh0LnRvU3RyaW5nKDEwKSkgOiB0O1xufVxuZnVuY3Rpb24gVG9CaWdJbnQodCkge1xuICB2YXIgciA9IHQ7XG4gIGlmIChcIm9iamVjdFwiID09IF90eXBlb2YodCkpIHtcbiAgICB2YXIgX2UzMiA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgICBfZTMyICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgX2UzMiAmJiAociA9IGZlKF9lMzIsIHQsIFtcIm51bWJlclwiXSkpO1xuICB9XG4gIGlmIChcIm51bWJlclwiID09IHR5cGVvZiByKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGNvbnZlcnQgbnVtYmVyIHRvIGJpZ2ludFwiKTtcbiAgcmV0dXJuIFwiYmlnaW50XCIgPT0gdHlwZW9mIHIgPyBCaWdJbnQoci50b1N0cmluZygxMCkpIDogQmlnSW50KHIpO1xufVxudmFyIFZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdCA9IEJpZ0ludChEYXRlLm5vdygpICUgMWU2KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgciA9IEJpZ0ludChEYXRlLm5vdygpKSxcbiAgICAgIG8gPSByICogR2UgKyB0O1xuICAgIHJldHVybiB0ID0gciAlIEdlLCBvID4gUmUgPyBSZSA6IG8gPCBNZSA/IE1lIDogbztcbiAgfTtcbn0oKTtcbmZ1bmN0aW9uIERlZmF1bHRUaW1lWm9uZSgpIHtcbiAgcmV0dXJuIG5ldyByZSgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xufVxuZnVuY3Rpb24gQ29tcGFyaXNvblJlc3VsdChlKSB7XG4gIHJldHVybiBlIDwgMCA/IC0xIDogZSA+IDAgPyAxIDogZTtcbn1cbmZ1bmN0aW9uIEdldE9wdGlvbnNPYmplY3QoZSkge1xuICBpZiAodm9pZCAwID09PSBlKSByZXR1cm4gVGUobnVsbCk7XG4gIGlmIChJc09iamVjdChlKSAmJiBudWxsICE9PSBlKSByZXR1cm4gZTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9wdGlvbnMgcGFyYW1ldGVyIG11c3QgYmUgYW4gb2JqZWN0LCBub3QgXCIgKyAobnVsbCA9PT0gZSA/IFwibnVsbFwiIDogXCJcIiArIF90eXBlb2YoZSkpKTtcbn1cbmZ1bmN0aW9uIENyZWF0ZU9uZVByb3BPYmplY3QoZSwgdCkge1xuICB2YXIgciA9IFRlKG51bGwpO1xuICByZXR1cm4gcltlXSA9IHQsIHI7XG59XG5mdW5jdGlvbiBDb3B5T3B0aW9ucyhlKSB7XG4gIHZhciB0ID0gVGUobnVsbCk7XG4gIHJldHVybiBDb3B5RGF0YVByb3BlcnRpZXModCwgR2V0T3B0aW9uc09iamVjdChlKSwgW10pLCB0O1xufVxuZnVuY3Rpb24gR2V0T3B0aW9uKGUsIHQsIHIsIG8pIHtcbiAgdmFyIG4gPSBlW3RdO1xuICBpZiAodm9pZCAwICE9PSBuKSB7XG4gICAgaWYgKG4gPSBUb1N0cmluZyhuKSwgIXIuaW5jbHVkZXMobikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiXCIuY29uY2F0KHQsIFwiIG11c3QgYmUgb25lIG9mIFwiKS5jb25jYXQoci5qb2luKFwiLCBcIiksIFwiLCBub3QgXCIpLmNvbmNhdChuKSk7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBJc0J1aWx0aW5DYWxlbmRhcihlKSB7XG4gIHJldHVybiBqZS5pbmNsdWRlcyhBU0NJSUxvd2VyY2FzZShlKSk7XG59XG5mdW5jdGlvbiBBU0NJSUxvd2VyY2FzZShlKSB7XG4gIHJldHVybiBlLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHQgPSBlLmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodCArIDMyKTtcbiAgfSk7XG59XG52YXIgemUgPSBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChXLnNvdXJjZSwgXCIkXCIpKTtcbmZ1bmN0aW9uIGJpc2VjdCh0LCByLCBvKSB7XG4gIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0KHIpO1xuICB2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdChvKTtcbiAgdmFyIGkgPSBCaWdJbnQociksXG4gICAgcyA9IEJpZ0ludChvKSxcbiAgICBsID0gbixcbiAgICBkID0gYTtcbiAgZm9yICg7IHMgLSBpID4gU2U7KSB7XG4gICAgdmFyIF9yNTUgPSAoaSArIHMpIC8gMm4sXG4gICAgICBfbzI0ID0gdChfcjU1KTtcbiAgICBpZiAoX28yNCA9PT0gbCkgaSA9IF9yNTUsIGwgPSBfbzI0O2Vsc2Uge1xuICAgICAgaWYgKF9vMjQgIT09IGQpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc3RhdGUgaW4gYmlzZWN0aW9uIFwiLmNvbmNhdChsLCBcIiAtIFwiKS5jb25jYXQoX28yNCwgXCIgLSBcIikuY29uY2F0KGQpKTtcbiAgICAgIHMgPSBfcjU1LCBkID0gX28yNDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59XG52YXIgX2UgPSB7XG4gICAgaG91cjogMzZlMTEsXG4gICAgbWludXRlOiA2ZTEwLFxuICAgIHNlY29uZDogMWU5LFxuICAgIG1pbGxpc2Vjb25kOiAxZTYsXG4gICAgbWljcm9zZWNvbmQ6IDFlMyxcbiAgICBuYW5vc2Vjb25kOiAxXG4gIH0sXG4gIEplID0gU3ltYm9sKFwiZGF0ZVwiKSxcbiAgS2UgPSBTeW1ib2woXCJ5bVwiKSxcbiAgWGUgPSBTeW1ib2woXCJtZFwiKSxcbiAgUWUgPSBTeW1ib2woXCJ0aW1lXCIpLFxuICBldCA9IFN5bWJvbChcImRhdGV0aW1lXCIpLFxuICB0dCA9IFN5bWJvbChcImluc3RhbnRcIiksXG4gIHJ0ID0gU3ltYm9sKFwib3JpZ2luYWxcIiksXG4gIG90ID0gU3ltYm9sKFwidGltZXpvbmVcIiksXG4gIG50ID0gU3ltYm9sKFwiY2FsZW5kYXItaWRcIiksXG4gIGF0ID0gU3ltYm9sKFwibG9jYWxlXCIpLFxuICBpdCA9IFN5bWJvbChcIm9wdGlvbnNcIiksXG4gIGRlc2NyaXB0b3IgPSBmdW5jdGlvbiBkZXNjcmlwdG9yKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGUsXG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICB9O1xuICB9LFxuICBzdCA9IGdsb2JhbFRoaXMuSW50bC5EYXRlVGltZUZvcm1hdCxcbiAgbHQgPSBPYmplY3QuYXNzaWduLFxuICBkdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gIG10ID0gUmVmbGVjdC5hcHBseTtcbmZ1bmN0aW9uIGdldFByb3BMYXp5KGUsIHQpIHtcbiAgdmFyIHIgPSBlW3RdO1xuICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiByICYmIChyID0gbmV3IHN0KGVbYXRdLCByKGVbaXRdKSksIGVbdF0gPSByKSwgcjtcbn1cbmZ1bmN0aW9uIERhdGVUaW1lRm9ybWF0SW1wbChlKSB7XG4gIHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERhdGVUaW1lRm9ybWF0SW1wbCkpIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXRJbXBsKGUsIHQpO1xuICB2YXIgciA9IHZvaWQgMCAhPT0gdCxcbiAgICBvID0gciA/IGx0KHt9LCB0KSA6IHt9LFxuICAgIG4gPSBuZXcgc3QoZSwgbyksXG4gICAgYSA9IG4ucmVzb2x2ZWRPcHRpb25zKCk7XG4gIGlmIChyKSB7XG4gICAgdmFyIF9lMzMgPSBsdCh7fSwgYSk7XG4gICAgZm9yICh2YXIgX3Q0MSBpbiBfZTMzKSBtdChkdCwgbywgW190NDFdKSB8fCBkZWxldGUgX2UzM1tfdDQxXTtcbiAgICB0aGlzW2l0XSA9IF9lMzM7XG4gIH0gZWxzZSB0aGlzW2l0XSA9IG87XG4gIHRoaXNbYXRdID0gYS5sb2NhbGUsIHRoaXNbcnRdID0gbiwgdGhpc1tvdF0gPSBhLnRpbWVab25lLCB0aGlzW250XSA9IGEuY2FsZW5kYXIsIHRoaXNbSmVdID0gZGF0ZUFtZW5kLCB0aGlzW0tlXSA9IHllYXJNb250aEFtZW5kLCB0aGlzW1hlXSA9IG1vbnRoRGF5QW1lbmQsIHRoaXNbUWVdID0gdGltZUFtZW5kLCB0aGlzW2V0XSA9IGRhdGV0aW1lQW1lbmQsIHRoaXNbdHRdID0gaW5zdGFudEFtZW5kO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGVUaW1lRm9ybWF0SW1wbCwgXCJuYW1lXCIsIHtcbiAgd3JpdGFibGU6ICEwLFxuICB2YWx1ZTogXCJEYXRlVGltZUZvcm1hdFwiXG59KSwgRGF0ZVRpbWVGb3JtYXRJbXBsLnN1cHBvcnRlZExvY2FsZXNPZiA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gIHJldHVybiBzdC5zdXBwb3J0ZWRMb2NhbGVzT2YoZSwgdCk7XG59O1xudmFyIGN0ID0ge1xuICByZXNvbHZlZE9wdGlvbnM6IGRlc2NyaXB0b3IoZnVuY3Rpb24gcmVzb2x2ZWRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzW3J0XS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfSksXG4gIGZvcm1hdDogZGVzY3JpcHRvcihmdW5jdGlvbiBmb3JtYXQoZSkge1xuICAgIHZhciBfdGhpcyRydDtcbiAgICB2YXIgX2V4dHJhY3RPdmVycmlkZXMgPSBleHRyYWN0T3ZlcnJpZGVzKGUsIHRoaXMpLFxuICAgICAgciA9IF9leHRyYWN0T3ZlcnJpZGVzLmluc3RhbnQsXG4gICAgICBvID0gX2V4dHJhY3RPdmVycmlkZXMuZm9ybWF0dGVyO1xuICAgIGlmIChyICYmIG8pIHJldHVybiBvLmZvcm1hdChyLmVwb2NoTWlsbGlzZWNvbmRzKTtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgdFtfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgcmV0dXJuIChfdGhpcyRydCA9IHRoaXNbcnRdKS5mb3JtYXQuYXBwbHkoX3RoaXMkcnQsIFtlXS5jb25jYXQodCkpO1xuICB9KSxcbiAgZm9ybWF0UmFuZ2U6IGRlc2NyaXB0b3IoZnVuY3Rpb24gZm9ybWF0UmFuZ2UoZSwgdCkge1xuICAgIGlmIChpc1RlbXBvcmFsT2JqZWN0KGUpIHx8IGlzVGVtcG9yYWxPYmplY3QodCkpIHtcbiAgICAgIGlmICghc2FtZVRlbXBvcmFsVHlwZShlLCB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0UmFuZ2UgYWNjZXB0cyB0d28gdmFsdWVzIG9mIHRoZSBzYW1lIHR5cGVcIik7XG4gICAgICB2YXIgX2V4dHJhY3RPdmVycmlkZXMyID0gZXh0cmFjdE92ZXJyaWRlcyhlLCB0aGlzKSxcbiAgICAgICAgX3I1NiA9IF9leHRyYWN0T3ZlcnJpZGVzMi5pbnN0YW50LFxuICAgICAgICBfbzI1ID0gX2V4dHJhY3RPdmVycmlkZXMyLmZvcm1hdHRlcixcbiAgICAgICAgX2V4dHJhY3RPdmVycmlkZXMzID0gZXh0cmFjdE92ZXJyaWRlcyh0LCB0aGlzKSxcbiAgICAgICAgX24xNSA9IF9leHRyYWN0T3ZlcnJpZGVzMy5pbnN0YW50LFxuICAgICAgICBfYTExID0gX2V4dHJhY3RPdmVycmlkZXMzLmZvcm1hdHRlcjtcbiAgICAgIGlmIChfcjU2ICYmIF9uMTUgJiYgX28yNSAmJiBfYTExICYmIF9vMjUgPT09IF9hMTEpIHJldHVybiBfbzI1LmZvcm1hdFJhbmdlKF9yNTYuZXBvY2hNaWxsaXNlY29uZHMsIF9uMTUuZXBvY2hNaWxsaXNlY29uZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1tydF0uZm9ybWF0UmFuZ2UoZSwgdCk7XG4gIH0pXG59O1xuXCJmb3JtYXRUb1BhcnRzXCIgaW4gc3QucHJvdG90eXBlICYmIChjdC5mb3JtYXRUb1BhcnRzID0gZGVzY3JpcHRvcihmdW5jdGlvbiBmb3JtYXRUb1BhcnRzKGUpIHtcbiAgdmFyIF90aGlzJHJ0MjtcbiAgdmFyIF9leHRyYWN0T3ZlcnJpZGVzNCA9IGV4dHJhY3RPdmVycmlkZXMoZSwgdGhpcyksXG4gICAgciA9IF9leHRyYWN0T3ZlcnJpZGVzNC5pbnN0YW50LFxuICAgIG8gPSBfZXh0cmFjdE92ZXJyaWRlczQuZm9ybWF0dGVyO1xuICBpZiAociAmJiBvKSByZXR1cm4gby5mb3JtYXRUb1BhcnRzKHIuZXBvY2hNaWxsaXNlY29uZHMpO1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIHRbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cbiAgcmV0dXJuIChfdGhpcyRydDIgPSB0aGlzW3J0XSkuZm9ybWF0VG9QYXJ0cy5hcHBseShfdGhpcyRydDIsIFtlXS5jb25jYXQodCkpO1xufSkpLCBcImZvcm1hdFJhbmdlVG9QYXJ0c1wiIGluIHN0LnByb3RvdHlwZSAmJiAoY3QuZm9ybWF0UmFuZ2VUb1BhcnRzID0gZGVzY3JpcHRvcihmdW5jdGlvbiBmb3JtYXRSYW5nZVRvUGFydHMoZSwgdCkge1xuICBpZiAoaXNUZW1wb3JhbE9iamVjdChlKSB8fCBpc1RlbXBvcmFsT2JqZWN0KHQpKSB7XG4gICAgaWYgKCFzYW1lVGVtcG9yYWxUeXBlKGUsIHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW50bC5EYXRlVGltZUZvcm1hdC5mb3JtYXRSYW5nZVRvUGFydHMgYWNjZXB0cyB0d28gdmFsdWVzIG9mIHRoZSBzYW1lIHR5cGVcIik7XG4gICAgdmFyIF9leHRyYWN0T3ZlcnJpZGVzNSA9IGV4dHJhY3RPdmVycmlkZXMoZSwgdGhpcyksXG4gICAgICBfcjU3ID0gX2V4dHJhY3RPdmVycmlkZXM1Lmluc3RhbnQsXG4gICAgICBfbzI2ID0gX2V4dHJhY3RPdmVycmlkZXM1LmZvcm1hdHRlcixcbiAgICAgIF9leHRyYWN0T3ZlcnJpZGVzNiA9IGV4dHJhY3RPdmVycmlkZXModCwgdGhpcyksXG4gICAgICBfbjE2ID0gX2V4dHJhY3RPdmVycmlkZXM2Lmluc3RhbnQsXG4gICAgICBfYTEyID0gX2V4dHJhY3RPdmVycmlkZXM2LmZvcm1hdHRlcjtcbiAgICBpZiAoX3I1NyAmJiBfbjE2ICYmIF9vMjYgJiYgX2ExMiAmJiBfbzI2ID09PSBfYTEyKSByZXR1cm4gX28yNi5mb3JtYXRSYW5nZVRvUGFydHMoX3I1Ny5lcG9jaE1pbGxpc2Vjb25kcywgX24xNi5lcG9jaE1pbGxpc2Vjb25kcyk7XG4gIH1cbiAgcmV0dXJuIHRoaXNbcnRdLmZvcm1hdFJhbmdlVG9QYXJ0cyhlLCB0KTtcbn0pKSwgRGF0ZVRpbWVGb3JtYXRJbXBsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3QucHJvdG90eXBlLCBjdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlVGltZUZvcm1hdEltcGwsIFwicHJvdG90eXBlXCIsIHtcbiAgd3JpdGFibGU6ICExLFxuICBlbnVtZXJhYmxlOiAhMSxcbiAgY29uZmlndXJhYmxlOiAhMVxufSk7XG52YXIgaHQgPSBEYXRlVGltZUZvcm1hdEltcGw7XG5mdW5jdGlvbiBhbWVuZCgpIHtcbiAgdmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciByID0gbHQoe30sIGUpO1xuICBmb3IgKHZhciBfaTE3ID0gMCwgX2FycjYgPSBbXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwid2Vla2RheVwiLCBcImRheVBlcmlvZFwiLCBcInRpbWVab25lTmFtZVwiLCBcImRhdGVTdHlsZVwiLCBcInRpbWVTdHlsZVwiXTsgX2kxNyA8IF9hcnI2Lmxlbmd0aDsgX2kxNysrKSB7XG4gICAgdmFyIF9lMzQgPSBfYXJyNltfaTE3XTtcbiAgICByW19lMzRdID0gX2UzNCBpbiB0ID8gdFtfZTM0XSA6IHJbX2UzNF0sICExICE9PSByW19lMzRdICYmIHZvaWQgMCAhPT0gcltfZTM0XSB8fCBkZWxldGUgcltfZTM0XTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHRpbWVBbWVuZChlKSB7XG4gIHZhciB0ID0gYW1lbmQoZSwge1xuICAgIHllYXI6ICExLFxuICAgIG1vbnRoOiAhMSxcbiAgICBkYXk6ICExLFxuICAgIHdlZWtkYXk6ICExLFxuICAgIHRpbWVab25lTmFtZTogITEsXG4gICAgZGF0ZVN0eWxlOiAhMVxuICB9KTtcbiAgcmV0dXJuIGhhc1RpbWVPcHRpb25zKHQpIHx8ICh0ID0gbHQoe30sIHQsIHtcbiAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICBtaW51dGU6IFwibnVtZXJpY1wiLFxuICAgIHNlY29uZDogXCJudW1lcmljXCJcbiAgfSkpLCB0O1xufVxuZnVuY3Rpb24geWVhck1vbnRoQW1lbmQoZSkge1xuICB2YXIgdCA9IGFtZW5kKGUsIHtcbiAgICBkYXk6ICExLFxuICAgIGhvdXI6ICExLFxuICAgIG1pbnV0ZTogITEsXG4gICAgc2Vjb25kOiAhMSxcbiAgICB3ZWVrZGF5OiAhMSxcbiAgICBkYXlQZXJpb2Q6ICExLFxuICAgIHRpbWVab25lTmFtZTogITEsXG4gICAgZGF0ZVN0eWxlOiAhMSxcbiAgICB0aW1lU3R5bGU6ICExXG4gIH0pO1xuICByZXR1cm4gXCJ5ZWFyXCIgaW4gdCB8fCBcIm1vbnRoXCIgaW4gdCB8fCAodCA9IGx0KHQsIHtcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCJudW1lcmljXCJcbiAgfSkpLCB0O1xufVxuZnVuY3Rpb24gbW9udGhEYXlBbWVuZChlKSB7XG4gIHZhciB0ID0gYW1lbmQoZSwge1xuICAgIHllYXI6ICExLFxuICAgIGhvdXI6ICExLFxuICAgIG1pbnV0ZTogITEsXG4gICAgc2Vjb25kOiAhMSxcbiAgICB3ZWVrZGF5OiAhMSxcbiAgICBkYXlQZXJpb2Q6ICExLFxuICAgIHRpbWVab25lTmFtZTogITEsXG4gICAgZGF0ZVN0eWxlOiAhMSxcbiAgICB0aW1lU3R5bGU6ICExXG4gIH0pO1xuICByZXR1cm4gXCJtb250aFwiIGluIHQgfHwgXCJkYXlcIiBpbiB0IHx8ICh0ID0gbHQoe30sIHQsIHtcbiAgICBtb250aDogXCJudW1lcmljXCIsXG4gICAgZGF5OiBcIm51bWVyaWNcIlxuICB9KSksIHQ7XG59XG5mdW5jdGlvbiBkYXRlQW1lbmQoZSkge1xuICB2YXIgdCA9IGFtZW5kKGUsIHtcbiAgICBob3VyOiAhMSxcbiAgICBtaW51dGU6ICExLFxuICAgIHNlY29uZDogITEsXG4gICAgZGF5UGVyaW9kOiAhMSxcbiAgICB0aW1lWm9uZU5hbWU6ICExLFxuICAgIHRpbWVTdHlsZTogITFcbiAgfSk7XG4gIHJldHVybiBoYXNEYXRlT3B0aW9ucyh0KSB8fCAodCA9IGx0KHt9LCB0LCB7XG4gICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgbW9udGg6IFwibnVtZXJpY1wiLFxuICAgIGRheTogXCJudW1lcmljXCJcbiAgfSkpLCB0O1xufVxuZnVuY3Rpb24gZGF0ZXRpbWVBbWVuZChlKSB7XG4gIHZhciB0ID0gYW1lbmQoZSwge1xuICAgIHRpbWVab25lTmFtZTogITFcbiAgfSk7XG4gIHJldHVybiBoYXNUaW1lT3B0aW9ucyh0KSB8fCBoYXNEYXRlT3B0aW9ucyh0KSB8fCAodCA9IGx0KHt9LCB0LCB7XG4gICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgbW9udGg6IFwibnVtZXJpY1wiLFxuICAgIGRheTogXCJudW1lcmljXCIsXG4gICAgaG91cjogXCJudW1lcmljXCIsXG4gICAgbWludXRlOiBcIm51bWVyaWNcIixcbiAgICBzZWNvbmQ6IFwibnVtZXJpY1wiXG4gIH0pKSwgdDtcbn1cbmZ1bmN0aW9uIGluc3RhbnRBbWVuZChlKSB7XG4gIHZhciB0ID0gZTtcbiAgcmV0dXJuIGhhc1RpbWVPcHRpb25zKHQpIHx8IGhhc0RhdGVPcHRpb25zKHQpIHx8ICh0ID0gbHQoe30sIHQsIHtcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCJudW1lcmljXCIsXG4gICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICBtaW51dGU6IFwibnVtZXJpY1wiLFxuICAgIHNlY29uZDogXCJudW1lcmljXCJcbiAgfSkpLCB0O1xufVxuZnVuY3Rpb24gaGFzRGF0ZU9wdGlvbnMoZSkge1xuICByZXR1cm4gXCJ5ZWFyXCIgaW4gZSB8fCBcIm1vbnRoXCIgaW4gZSB8fCBcImRheVwiIGluIGUgfHwgXCJ3ZWVrZGF5XCIgaW4gZSB8fCBcImRhdGVTdHlsZVwiIGluIGU7XG59XG5mdW5jdGlvbiBoYXNUaW1lT3B0aW9ucyhlKSB7XG4gIHJldHVybiBcImhvdXJcIiBpbiBlIHx8IFwibWludXRlXCIgaW4gZSB8fCBcInNlY29uZFwiIGluIGUgfHwgXCJ0aW1lU3R5bGVcIiBpbiBlIHx8IFwiZGF5UGVyaW9kXCIgaW4gZTtcbn1cbmZ1bmN0aW9uIGlzVGVtcG9yYWxPYmplY3QoZSkge1xuICByZXR1cm4gSXNUZW1wb3JhbERhdGUoZSkgfHwgSXNUZW1wb3JhbFRpbWUoZSkgfHwgSXNUZW1wb3JhbERhdGVUaW1lKGUpIHx8IElzVGVtcG9yYWxab25lZERhdGVUaW1lKGUpIHx8IElzVGVtcG9yYWxZZWFyTW9udGgoZSkgfHwgSXNUZW1wb3JhbE1vbnRoRGF5KGUpIHx8IElzVGVtcG9yYWxJbnN0YW50KGUpO1xufVxuZnVuY3Rpb24gc2FtZVRlbXBvcmFsVHlwZShlLCB0KSB7XG4gIHJldHVybiAhKCFpc1RlbXBvcmFsT2JqZWN0KGUpIHx8ICFpc1RlbXBvcmFsT2JqZWN0KHQpKSAmJiAhKElzVGVtcG9yYWxUaW1lKGUpICYmICFJc1RlbXBvcmFsVGltZSh0KSkgJiYgIShJc1RlbXBvcmFsRGF0ZShlKSAmJiAhSXNUZW1wb3JhbERhdGUodCkpICYmICEoSXNUZW1wb3JhbERhdGVUaW1lKGUpICYmICFJc1RlbXBvcmFsRGF0ZVRpbWUodCkpICYmICEoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZSkgJiYgIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHQpKSAmJiAhKElzVGVtcG9yYWxZZWFyTW9udGgoZSkgJiYgIUlzVGVtcG9yYWxZZWFyTW9udGgodCkpICYmICEoSXNUZW1wb3JhbE1vbnRoRGF5KGUpICYmICFJc1RlbXBvcmFsTW9udGhEYXkodCkpICYmICEoSXNUZW1wb3JhbEluc3RhbnQoZSkgJiYgIUlzVGVtcG9yYWxJbnN0YW50KHQpKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RPdmVycmlkZXMoZSwgdCkge1xuICB2YXIgciA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKTtcbiAgaWYgKElzVGVtcG9yYWxUaW1lKGUpKSB7XG4gICAgdmFyIF9vMjcgPSBuZXcgcigxOTcwLCAxLCAxLCBHZXRTbG90KGUsIGQpLCBHZXRTbG90KGUsIG0pLCBHZXRTbG90KGUsIGMpLCBHZXRTbG90KGUsIGgpLCBHZXRTbG90KGUsIHUpLCBHZXRTbG90KGUsIFQpLCB0W250XSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluc3RhbnQ6IEdldEluc3RhbnRGb3IodFtvdF0sIF9vMjcsIFwiY29tcGF0aWJsZVwiKSxcbiAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkodCwgUWUpXG4gICAgfTtcbiAgfVxuICBpZiAoSXNUZW1wb3JhbFllYXJNb250aChlKSkge1xuICAgIHZhciBfbzI4ID0gR2V0U2xvdChlLCBpKSxcbiAgICAgIF9uMTcgPSBHZXRTbG90KGUsIHMpLFxuICAgICAgX2ExMyA9IEdldFNsb3QoZSwgbCksXG4gICAgICBfZDcgPSBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKEdldFNsb3QoZSwgcCkpO1xuICAgIGlmIChfZDcgIT09IHRbbnRdKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbm5vdCBmb3JtYXQgUGxhaW5ZZWFyTW9udGggd2l0aCBjYWxlbmRhciBcIi5jb25jYXQoX2Q3LCBcIiBpbiBsb2NhbGUgd2l0aCBjYWxlbmRhciBcIikuY29uY2F0KHRbbnRdKSk7XG4gICAgdmFyIF9tNiA9IG5ldyByKF9vMjgsIF9uMTcsIF9hMTMsIDEyLCAwLCAwLCAwLCAwLCAwLCBfZDcpO1xuICAgIHJldHVybiB7XG4gICAgICBpbnN0YW50OiBHZXRJbnN0YW50Rm9yKHRbb3RdLCBfbTYsIFwiY29tcGF0aWJsZVwiKSxcbiAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkodCwgS2UpXG4gICAgfTtcbiAgfVxuICBpZiAoSXNUZW1wb3JhbE1vbnRoRGF5KGUpKSB7XG4gICAgdmFyIF9vMjkgPSBHZXRTbG90KGUsIGkpLFxuICAgICAgX24xOCA9IEdldFNsb3QoZSwgcyksXG4gICAgICBfYTE0ID0gR2V0U2xvdChlLCBsKSxcbiAgICAgIF9kOCA9IFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoR2V0U2xvdChlLCBwKSk7XG4gICAgaWYgKF9kOCAhPT0gdFtudF0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2Fubm90IGZvcm1hdCBQbGFpbk1vbnRoRGF5IHdpdGggY2FsZW5kYXIgXCIuY29uY2F0KF9kOCwgXCIgaW4gbG9jYWxlIHdpdGggY2FsZW5kYXIgXCIpLmNvbmNhdCh0W250XSkpO1xuICAgIHZhciBfbTcgPSBuZXcgcihfbzI5LCBfbjE4LCBfYTE0LCAxMiwgMCwgMCwgMCwgMCwgMCwgX2Q4KTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5zdGFudDogR2V0SW5zdGFudEZvcih0W290XSwgX203LCBcImNvbXBhdGlibGVcIiksXG4gICAgICBmb3JtYXR0ZXI6IGdldFByb3BMYXp5KHQsIFhlKVxuICAgIH07XG4gIH1cbiAgaWYgKElzVGVtcG9yYWxEYXRlKGUpKSB7XG4gICAgdmFyIF9vMzAgPSBHZXRTbG90KGUsIGkpLFxuICAgICAgX24xOSA9IEdldFNsb3QoZSwgcyksXG4gICAgICBfYTE1ID0gR2V0U2xvdChlLCBsKSxcbiAgICAgIF9kOSA9IFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoR2V0U2xvdChlLCBwKSk7XG4gICAgaWYgKFwiaXNvODYwMVwiICE9PSBfZDkgJiYgX2Q5ICE9PSB0W250XSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJjYW5ub3QgZm9ybWF0IFBsYWluRGF0ZSB3aXRoIGNhbGVuZGFyIFwiLmNvbmNhdChfZDksIFwiIGluIGxvY2FsZSB3aXRoIGNhbGVuZGFyIFwiKS5jb25jYXQodFtudF0pKTtcbiAgICB2YXIgX204ID0gbmV3IHIoX28zMCwgX24xOSwgX2ExNSwgMTIsIDAsIDAsIDAsIDAsIDAsIHRbbnRdKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5zdGFudDogR2V0SW5zdGFudEZvcih0W290XSwgX204LCBcImNvbXBhdGlibGVcIiksXG4gICAgICBmb3JtYXR0ZXI6IGdldFByb3BMYXp5KHQsIEplKVxuICAgIH07XG4gIH1cbiAgaWYgKElzVGVtcG9yYWxEYXRlVGltZShlKSkge1xuICAgIHZhciBfbzMxID0gR2V0U2xvdChlLCBpKSxcbiAgICAgIF9uMjAgPSBHZXRTbG90KGUsIHMpLFxuICAgICAgX2ExNiA9IEdldFNsb3QoZSwgbCksXG4gICAgICBfZjUgPSBHZXRTbG90KGUsIGQpLFxuICAgICAgX3kgPSBHZXRTbG90KGUsIG0pLFxuICAgICAgX0kzID0gR2V0U2xvdChlLCBjKSxcbiAgICAgIF9TMyA9IEdldFNsb3QoZSwgaCksXG4gICAgICBfZzIgPSBHZXRTbG90KGUsIHUpLFxuICAgICAgX3cgPSBHZXRTbG90KGUsIFQpLFxuICAgICAgX0QgPSBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKEdldFNsb3QoZSwgcCkpO1xuICAgIGlmIChcImlzbzg2MDFcIiAhPT0gX0QgJiYgX0QgIT09IHRbbnRdKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImNhbm5vdCBmb3JtYXQgUGxhaW5EYXRlVGltZSB3aXRoIGNhbGVuZGFyIFwiLmNvbmNhdChfRCwgXCIgaW4gbG9jYWxlIHdpdGggY2FsZW5kYXIgXCIpLmNvbmNhdCh0W250XSkpO1xuICAgIHZhciBfRyA9IGU7XG4gICAgcmV0dXJuIFwiaXNvODYwMVwiID09PSBfRCAmJiAoX0cgPSBuZXcgcihfbzMxLCBfbjIwLCBfYTE2LCBfZjUsIF95LCBfSTMsIF9TMywgX2cyLCBfdywgdFtudF0pKSwge1xuICAgICAgaW5zdGFudDogR2V0SW5zdGFudEZvcih0W290XSwgX0csIFwiY29tcGF0aWJsZVwiKSxcbiAgICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkodCwgZXQpXG4gICAgfTtcbiAgfVxuICBpZiAoSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUZW1wb3JhbC5ab25lZERhdGVUaW1lIG5vdCBzdXBwb3J0ZWQgaW4gRGF0ZVRpbWVGb3JtYXQgbWV0aG9kcy4gVXNlIHRvTG9jYWxlU3RyaW5nKCkgaW5zdGVhZC5cIik7XG4gIHJldHVybiBJc1RlbXBvcmFsSW5zdGFudChlKSA/IHtcbiAgICBpbnN0YW50OiBlLFxuICAgIGZvcm1hdHRlcjogZ2V0UHJvcExhenkodCwgdHQpXG4gIH0gOiB7fTtcbn1cbnZhciB1dCA9IE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIERhdGVUaW1lRm9ybWF0OiBodFxufSk7XG52YXIgSW5zdGFudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEluc3RhbnQoZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnN0YW50KTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtaXNzaW5nIGFyZ3VtZW50OiBlcG9jaE5hbm9zZWNvbmRzIGlzIHJlcXVpcmVkXCIpO1xuICAgIHZhciB0ID0gVG9CaWdJbnQoZSk7XG4gICAgVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzKHQpLCBOKHRoaXMpLCBTZXRTbG90KHRoaXMsIG4sIHQpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhJbnN0YW50LCBbe1xuICAgIGtleTogXCJlcG9jaFNlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBHZXRTbG90KHRoaXMsIG4pO1xuICAgICAgcmV0dXJuIE51bWJlcihCaWdJbnRGbG9vckRpdih0LCB2ZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcG9jaE1pbGxpc2Vjb25kc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEJpZ0ludChHZXRTbG90KHRoaXMsIG4pKTtcbiAgICAgIHJldHVybiBOdW1iZXIoQmlnSW50Rmxvb3JEaXYodCwgR2UpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXBvY2hNaWNyb3NlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRvQmlnSW50RXh0ZXJuYWwoQmlnSW50Rmxvb3JEaXYoQmlnSW50KEdldFNsb3QodGhpcywgbikpLCBEZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcG9jaE5hbm9zZWNvbmRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUb0JpZ0ludEV4dGVybmFsKEJpZ0ludChHZXRTbG90KHRoaXMsIG4pKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21JbnN0YW50KFwiYWRkXCIsIHRoaXMsIGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0cmFjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJ0cmFjdChlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBBZGREdXJhdGlvblRvT3JTdWJ0cmFjdER1cmF0aW9uRnJvbUluc3RhbnQoXCJzdWJ0cmFjdFwiLCB0aGlzLCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW50aWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW50aWwoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsSW5zdGFudChcInVudGlsXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaW5jZShlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBEaWZmZXJlbmNlVGVtcG9yYWxJbnN0YW50KFwic2luY2VcIiwgdGhpcywgZSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdW5kKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbnMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgdmFyIHQgPSBcInN0cmluZ1wiID09IHR5cGVvZiBlID8gQ3JlYXRlT25lUHJvcE9iamVjdChcInNtYWxsZXN0VW5pdFwiLCBlKSA6IEdldE9wdGlvbnNPYmplY3QoZSksXG4gICAgICAgIHIgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQodCksXG4gICAgICAgIG8gPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKHQsIFwiaGFsZkV4cGFuZFwiKSxcbiAgICAgICAgYSA9IEdldFRlbXBvcmFsVW5pdCh0LCBcInNtYWxsZXN0VW5pdFwiLCBcInRpbWVcIiwgSGUpO1xuICAgICAgVmFsaWRhdGVUZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KHIsIHtcbiAgICAgICAgaG91cjogMjQsXG4gICAgICAgIG1pbnV0ZTogMTQ0MCxcbiAgICAgICAgc2Vjb25kOiA4NjQwMCxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IDg2NGU1LFxuICAgICAgICBtaWNyb3NlY29uZDogODY0ZTgsXG4gICAgICAgIG5hbm9zZWNvbmQ6IDg2NGUxMVxuICAgICAgfVthXSwgITApO1xuICAgICAgdmFyIGkgPSBSb3VuZEluc3RhbnQoR2V0U2xvdCh0aGlzLCBuKSwgciwgYSwgbyk7XG4gICAgICByZXR1cm4gbmV3IEluc3RhbnQoaSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxdWFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHModCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgciA9IFRvVGVtcG9yYWxJbnN0YW50KHQpLFxuICAgICAgICBvID0gR2V0U2xvdCh0aGlzLCBuKSxcbiAgICAgICAgYSA9IEdldFNsb3Qociwgbik7XG4gICAgICByZXR1cm4gQmlnSW50KG8pID09PSBCaWdJbnQoYSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBHZXRPcHRpb25zT2JqZWN0KGUpLFxuICAgICAgICByID0gVG9GcmFjdGlvbmFsU2Vjb25kRGlnaXRzKHQpLFxuICAgICAgICBvID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZSh0LCBcInRydW5jXCIpLFxuICAgICAgICBhID0gR2V0VGVtcG9yYWxVbml0KHQsIFwic21hbGxlc3RVbml0XCIsIFwidGltZVwiLCB2b2lkIDApO1xuICAgICAgaWYgKFwiaG91clwiID09PSBhKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc21hbGxlc3RVbml0IG11c3QgYmUgYSB0aW1lIHVuaXQgb3RoZXIgdGhhbiBcImhvdXJcIicpO1xuICAgICAgdmFyIGkgPSB0LnRpbWVab25lO1xuICAgICAgdm9pZCAwICE9PSBpICYmIChpID0gVG9UZW1wb3JhbFRpbWVab25lU2xvdFZhbHVlKGkpKTtcbiAgICAgIHZhciBfVG9TZWNvbmRzU3RyaW5nUHJlY2kgPSBUb1NlY29uZHNTdHJpbmdQcmVjaXNpb25SZWNvcmQoYSwgciksXG4gICAgICAgIHMgPSBfVG9TZWNvbmRzU3RyaW5nUHJlY2kucHJlY2lzaW9uLFxuICAgICAgICBsID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpLnVuaXQsXG4gICAgICAgIGQgPSBfVG9TZWNvbmRzU3RyaW5nUHJlY2kuaW5jcmVtZW50LFxuICAgICAgICBtID0gUm91bmRJbnN0YW50KEdldFNsb3QodGhpcywgbiksIGQsIGwsIG8pO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsSW5zdGFudFRvU3RyaW5nKG5ldyBJbnN0YW50KG0pLCBpLCBzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbEluc3RhbnQodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsSW5zdGFudFRvU3RyaW5nKHRoaXMsIHZvaWQgMCwgXCJhdXRvXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0xvY2FsZVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZyhlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxJbnN0YW50KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBuZXcgaHQoZSwgdCkuZm9ybWF0KHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZU9mXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidXNlIGNvbXBhcmUoKSBvciBlcXVhbHMoKSB0byBjb21wYXJlIFRlbXBvcmFsLkluc3RhbnRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvWm9uZWREYXRlVGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1pvbmVkRGF0ZVRpbWUoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBhcmd1bWVudCBpbiB0b1pvbmVkRGF0ZVRpbWVcIik7XG4gICAgICB2YXIgdCA9IGUuY2FsZW5kYXI7XG4gICAgICBpZiAodm9pZCAwID09PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwibWlzc2luZyBjYWxlbmRhciBwcm9wZXJ0eSBpbiB0b1pvbmVkRGF0ZVRpbWVcIik7XG4gICAgICB2YXIgciA9IFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZSh0KSxcbiAgICAgICAgbyA9IGUudGltZVpvbmU7XG4gICAgICBpZiAodm9pZCAwID09PSBvKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwibWlzc2luZyB0aW1lWm9uZSBwcm9wZXJ0eSBpbiB0b1pvbmVkRGF0ZVRpbWVcIik7XG4gICAgICB2YXIgYSA9IFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZShvKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBuKSwgYSwgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvWm9uZWREYXRlVGltZUlTT1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1pvbmVkRGF0ZVRpbWVJU08oZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsSW5zdGFudCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZShlKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBuKSwgdCwgXCJpc284NjAxXCIpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21FcG9jaFNlY29uZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUVwb2NoU2Vjb25kcyh0KSB7XG4gICAgICB2YXIgciA9IFRvTnVtYmVyKHQpLFxuICAgICAgICBvID0gQmlnSW50KHIpICogdmU7XG4gICAgICByZXR1cm4gVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzKG8pLCBuZXcgSW5zdGFudChvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUVwb2NoTWlsbGlzZWNvbmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21FcG9jaE1pbGxpc2Vjb25kcyh0KSB7XG4gICAgICB2YXIgciA9IFRvTnVtYmVyKHQpLFxuICAgICAgICBvID0gQmlnSW50KHIpICogR2U7XG4gICAgICByZXR1cm4gVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzKG8pLCBuZXcgSW5zdGFudChvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUVwb2NoTWljcm9zZWNvbmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21FcG9jaE1pY3Jvc2Vjb25kcyh0KSB7XG4gICAgICB2YXIgciA9IFRvQmlnSW50KHQpLFxuICAgICAgICBvID0gciAqIERlO1xuICAgICAgcmV0dXJuIFZhbGlkYXRlRXBvY2hOYW5vc2Vjb25kcyhvKSwgbmV3IEluc3RhbnQobyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21FcG9jaE5hbm9zZWNvbmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21FcG9jaE5hbm9zZWNvbmRzKGUpIHtcbiAgICAgIHZhciB0ID0gVG9CaWdJbnQoZSk7XG4gICAgICByZXR1cm4gVmFsaWRhdGVFcG9jaE5hbm9zZWNvbmRzKHQpLCBuZXcgSW5zdGFudCh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKGUpIHtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsSW5zdGFudChlKSA/IG5ldyBJbnN0YW50KEdldFNsb3QoZSwgbikpIDogVG9UZW1wb3JhbEluc3RhbnQoZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBhcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZSh0LCByKSB7XG4gICAgICB2YXIgbyA9IFRvVGVtcG9yYWxJbnN0YW50KHQpLFxuICAgICAgICBhID0gVG9UZW1wb3JhbEluc3RhbnQociksXG4gICAgICAgIGkgPSBHZXRTbG90KG8sIG4pLFxuICAgICAgICBzID0gR2V0U2xvdChhLCBuKTtcbiAgICAgIHJldHVybiBpIDwgcyA/IC0xIDogaSA+IHMgPyAxIDogMDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEluc3RhbnQ7XG59KCk7XG5NYWtlSW50cmluc2ljQ2xhc3MoSW5zdGFudCwgXCJUZW1wb3JhbC5JbnN0YW50XCIpO1xudmFyIFR0ID0gQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzLFxuICBwdCA9IEFycmF5LnByb3RvdHlwZS5wdXNoLFxuICBmdCA9IGdsb2JhbFRoaXMuSW50bC5EYXRlVGltZUZvcm1hdCxcbiAgeXQgPSBBcnJheS5wcm90b3R5cGUuc29ydCxcbiAgSXQgPSBNYXRoLmFicyxcbiAgU3QgPSBNYXRoLmZsb29yLFxuICBndCA9IE9iamVjdC5jcmVhdGUsXG4gIHd0ID0gT2JqZWN0LmVudHJpZXMsXG4gIER0ID0gU2V0LFxuICBHdCA9IFJlZmxlY3Qub3duS2V5cyxcbiAgdnQgPSBTZXQucHJvdG90eXBlLmFkZCxcbiAgQ3QgPSBTZXQucHJvdG90eXBlLnZhbHVlcyxcbiAgT3QgPSB7fTtcbnZhciBDYWxlbmRhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhbGVuZGFyKGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FsZW5kYXIpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJtaXNzaW5nIGFyZ3VtZW50OiBpZCBpcyByZXF1aXJlZFwiKTtcbiAgICB2YXIgdCA9IFRvU3RyaW5nKGUpO1xuICAgIGlmICghSXNCdWlsdGluQ2FsZW5kYXIodCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCBjYWxlbmRhciBpZGVudGlmaWVyIFwiLmNvbmNhdCh0KSk7XG4gICAgTih0aGlzKSwgU2V0U2xvdCh0aGlzLCBGLCBBU0NJSUxvd2VyY2FzZSh0KSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKENhbGVuZGFyLCBbe1xuICAgIGtleTogXCJpZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgRik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGVGcm9tRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGVGcm9tRmllbGRzKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIGlmICghSXNPYmplY3QoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGZpZWxkc1wiKTtcbiAgICAgIHZhciByID0gR2V0T3B0aW9uc09iamVjdCh0KSxcbiAgICAgICAgbyA9IEdldFNsb3QodGhpcywgRik7XG4gICAgICByZXR1cm4gT3Rbb10uZGF0ZUZyb21GaWVsZHMoZSwgciwgbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInllYXJNb250aEZyb21GaWVsZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geWVhck1vbnRoRnJvbUZpZWxkcyhlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBmaWVsZHNcIik7XG4gICAgICB2YXIgciA9IEdldE9wdGlvbnNPYmplY3QodCksXG4gICAgICAgIG8gPSBHZXRTbG90KHRoaXMsIEYpO1xuICAgICAgcmV0dXJuIE90W29dLnllYXJNb250aEZyb21GaWVsZHMoZSwgciwgbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoRGF5RnJvbUZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aERheUZyb21GaWVsZHMoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKCFJc09iamVjdChlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgZmllbGRzXCIpO1xuICAgICAgdmFyIHIgPSBHZXRPcHRpb25zT2JqZWN0KHQpLFxuICAgICAgICBvID0gR2V0U2xvdCh0aGlzLCBGKTtcbiAgICAgIHJldHVybiBPdFtvXS5tb250aERheUZyb21GaWVsZHMoZSwgciwgbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWVsZHMoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBbXSxcbiAgICAgICAgciA9IG5ldyBTZXQoW1wieWVhclwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwiZGF5XCIsIFwiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCIsIFwibWljcm9zZWNvbmRcIiwgXCJuYW5vc2Vjb25kXCJdKTtcbiAgICAgIHZhciBfaXRlcmF0b3IxNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGUpLFxuICAgICAgICBfc3RlcDE1O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxNS5zKCk7ICEoX3N0ZXAxNSA9IF9pdGVyYXRvcjE1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX28zMiA9IF9zdGVwMTUudmFsdWU7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIF9vMzIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGZpZWxkc1wiKTtcbiAgICAgICAgICBpZiAoIXIuaGFzKF9vMzIpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgZmllbGQgbmFtZSBcIi5jb25jYXQoX28zMikpO1xuICAgICAgICAgIHJbXCJkZWxldGVcIl0oX28zMiksIHB0LmNhbGwodCwgX28zMik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxNS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxNS5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT3RbR2V0U2xvdCh0aGlzLCBGKV0uZmllbGRzKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZUZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZUZpZWxkcyhlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgciA9IFRvT2JqZWN0KGUpLFxuICAgICAgICBvID0gZ3QobnVsbCk7XG4gICAgICBDb3B5RGF0YVByb3BlcnRpZXMobywgciwgW10sIFt2b2lkIDBdKTtcbiAgICAgIHZhciBuID0gVG9PYmplY3QodCksXG4gICAgICAgIGEgPSBndChudWxsKTtcbiAgICAgIENvcHlEYXRhUHJvcGVydGllcyhhLCBuLCBbXSwgW3ZvaWQgMF0pO1xuICAgICAgdmFyIGkgPSBHdChhKSxcbiAgICAgICAgcyA9IE90W0dldFNsb3QodGhpcywgRildLmZpZWxkS2V5c1RvSWdub3JlKGkpLFxuICAgICAgICBsID0gZ3QobnVsbCksXG4gICAgICAgIGQgPSBHdChvKTtcbiAgICAgIHZhciBfaXRlcmF0b3IxNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGQpLFxuICAgICAgICBfc3RlcDE2O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxNi5zKCk7ICEoX3N0ZXAxNiA9IF9pdGVyYXRvcjE2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX2UzNSA9IF9zdGVwMTYudmFsdWU7XG4gICAgICAgICAgdmFyIF90NDIgPSB2b2lkIDA7XG4gICAgICAgICAgX3Q0MiA9IENhbGwoVHQsIHMsIFtfZTM1XSkgPyBhW19lMzVdIDogb1tfZTM1XSwgdm9pZCAwICE9PSBfdDQyICYmIChsW19lMzVdID0gX3Q0Mik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxNi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxNi5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29weURhdGFQcm9wZXJ0aWVzKGwsIGEsIFtdKSwgbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0ZUFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRlQWRkKGUsIHQsIHIpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciBvID0gVG9UZW1wb3JhbERhdGUoZSksXG4gICAgICAgIG4gPSBUb1RlbXBvcmFsRHVyYXRpb24odCksXG4gICAgICAgIGEgPSBUb1RlbXBvcmFsT3ZlcmZsb3coR2V0T3B0aW9uc09iamVjdChyKSksXG4gICAgICAgIF9CYWxhbmNlRHVyYXRpb24xMCA9IEJhbGFuY2VEdXJhdGlvbihHZXRTbG90KG4sIHYpLCBHZXRTbG90KG4sIEMpLCBHZXRTbG90KG4sIE8pLCBHZXRTbG90KG4sIGIpLCBHZXRTbG90KG4sIEUpLCBHZXRTbG90KG4sIE0pLCBHZXRTbG90KG4sIFIpLCBcImRheVwiKSxcbiAgICAgICAgaSA9IF9CYWxhbmNlRHVyYXRpb24xMC5kYXlzLFxuICAgICAgICBzID0gR2V0U2xvdCh0aGlzLCBGKTtcbiAgICAgIHJldHVybiBPdFtzXS5kYXRlQWRkKG8sIEdldFNsb3QobiwgdyksIEdldFNsb3QobiwgRCksIEdldFNsb3QobiwgRyksIGksIGEsIHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXRlVW50aWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0ZVVudGlsKGUsIHQsIHIpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciBvID0gVG9UZW1wb3JhbERhdGUoZSksXG4gICAgICAgIG4gPSBUb1RlbXBvcmFsRGF0ZSh0KTtcbiAgICAgIHZhciBhID0gR2V0VGVtcG9yYWxVbml0KEdldE9wdGlvbnNPYmplY3QociksIFwibGFyZ2VzdFVuaXRcIiwgXCJkYXRlXCIsIFwiYXV0b1wiKTtcbiAgICAgIFwiYXV0b1wiID09PSBhICYmIChhID0gXCJkYXlcIik7XG4gICAgICB2YXIgX090JEdldFNsb3QkZGF0ZVVudGlsID0gT3RbR2V0U2xvdCh0aGlzLCBGKV0uZGF0ZVVudGlsKG8sIG4sIGEpLFxuICAgICAgICBpID0gX090JEdldFNsb3QkZGF0ZVVudGlsLnllYXJzLFxuICAgICAgICBzID0gX090JEdldFNsb3QkZGF0ZVVudGlsLm1vbnRocyxcbiAgICAgICAgbCA9IF9PdCRHZXRTbG90JGRhdGVVbnRpbC53ZWVrcyxcbiAgICAgICAgZCA9IF9PdCRHZXRTbG90JGRhdGVVbnRpbC5kYXlzO1xuICAgICAgcmV0dXJuIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKSkoaSwgcywgbCwgZCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geWVhcihlKSB7XG4gICAgICB2YXIgdCA9IGU7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbFllYXJNb250aCh0KSB8fCAodCA9IFRvVGVtcG9yYWxEYXRlKHQpKSwgT3RbR2V0U2xvdCh0aGlzLCBGKV0ueWVhcih0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9udGgoZSkge1xuICAgICAgdmFyIHQgPSBlO1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKElzVGVtcG9yYWxNb250aERheSh0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcInVzZSBtb250aENvZGUgb24gUGxhaW5Nb250aERheSBpbnN0ZWFkXCIpO1xuICAgICAgcmV0dXJuIElzVGVtcG9yYWxZZWFyTW9udGgodCkgfHwgKHQgPSBUb1RlbXBvcmFsRGF0ZSh0KSksIE90W0dldFNsb3QodGhpcywgRildLm1vbnRoKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aENvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9udGhDb2RlKGUpIHtcbiAgICAgIHZhciB0ID0gZTtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsWWVhck1vbnRoKHQpIHx8IElzVGVtcG9yYWxNb250aERheSh0KSB8fCAodCA9IFRvVGVtcG9yYWxEYXRlKHQpKSwgT3RbR2V0U2xvdCh0aGlzLCBGKV0ubW9udGhDb2RlKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF5KGUpIHtcbiAgICAgIHZhciB0ID0gZTtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsTW9udGhEYXkodCkgfHwgKHQgPSBUb1RlbXBvcmFsRGF0ZSh0KSksIE90W0dldFNsb3QodGhpcywgRildLmRheSh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVyYShlKSB7XG4gICAgICB2YXIgdCA9IGU7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbFllYXJNb250aCh0KSB8fCAodCA9IFRvVGVtcG9yYWxEYXRlKHQpKSwgT3RbR2V0U2xvdCh0aGlzLCBGKV0uZXJhKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcmFZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVyYVllYXIoZSkge1xuICAgICAgdmFyIHQgPSBlO1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIElzVGVtcG9yYWxZZWFyTW9udGgodCkgfHwgKHQgPSBUb1RlbXBvcmFsRGF0ZSh0KSksIE90W0dldFNsb3QodGhpcywgRildLmVyYVllYXIodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheU9mV2Vla1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXlPZldlZWsoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsRGF0ZShlKTtcbiAgICAgIHJldHVybiBPdFtHZXRTbG90KHRoaXMsIEYpXS5kYXlPZldlZWsodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheU9mWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXlPZlllYXIoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsQ2FsZW5kYXIodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsRGF0ZShlKTtcbiAgICAgIHJldHVybiBPdFtHZXRTbG90KHRoaXMsIEYpXS5kYXlPZlllYXIodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndlZWtPZlllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2Vla09mWWVhcihlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxEYXRlKGUpO1xuICAgICAgcmV0dXJuIE90W0dldFNsb3QodGhpcywgRildLndlZWtPZlllYXIodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInllYXJPZldlZWtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geWVhck9mV2VlayhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxEYXRlKGUpO1xuICAgICAgcmV0dXJuIE90W0dldFNsb3QodGhpcywgRildLnllYXJPZldlZWsodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJbldlZWtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF5c0luV2VlayhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxEYXRlKGUpO1xuICAgICAgcmV0dXJuIE90W0dldFNsb3QodGhpcywgRildLmRheXNJbldlZWsodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJbk1vbnRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRheXNJbk1vbnRoKGUpIHtcbiAgICAgIHZhciB0ID0gZTtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsWWVhck1vbnRoKHQpIHx8ICh0ID0gVG9UZW1wb3JhbERhdGUodCkpLCBPdFtHZXRTbG90KHRoaXMsIEYpXS5kYXlzSW5Nb250aCh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXlzSW5ZZWFyKGUpIHtcbiAgICAgIHZhciB0ID0gZTtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsWWVhck1vbnRoKHQpIHx8ICh0ID0gVG9UZW1wb3JhbERhdGUodCkpLCBPdFtHZXRTbG90KHRoaXMsIEYpXS5kYXlzSW5ZZWFyKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aHNJblllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9udGhzSW5ZZWFyKGUpIHtcbiAgICAgIHZhciB0ID0gZTtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsWWVhck1vbnRoKHQpIHx8ICh0ID0gVG9UZW1wb3JhbERhdGUodCkpLCBPdFtHZXRTbG90KHRoaXMsIEYpXS5tb250aHNJblllYXIodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluTGVhcFllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5MZWFwWWVhcihlKSB7XG4gICAgICB2YXIgdCA9IGU7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbFllYXJNb250aCh0KSB8fCAodCA9IFRvVGVtcG9yYWxEYXRlKHQpKSwgT3RbR2V0U2xvdCh0aGlzLCBGKV0uaW5MZWFwWWVhcih0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxDYWxlbmRhcih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBGKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbENhbGVuZGFyKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIEYpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbShlKSB7XG4gICAgICByZXR1cm4gVG9UZW1wb3JhbENhbGVuZGFyT2JqZWN0KFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShlKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDYWxlbmRhcjtcbn0oKTtcbmZ1bmN0aW9uIG1vbnRoQ29kZU51bWJlclBhcnQoZSkge1xuICBpZiAoIWUuc3RhcnRzV2l0aChcIk1cIikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtb250aCBjb2RlOiBcIi5jb25jYXQoZSwgXCIuICBNb250aCBjb2RlcyBtdXN0IHN0YXJ0IHdpdGggTS5cIikpO1xuICB2YXIgdCA9ICtlLnNsaWNlKDEpO1xuICBpZiAoaXNOYU4odCkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtb250aCBjb2RlOiBcIi5jb25jYXQoZSkpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGJ1aWxkTW9udGhDb2RlKGUpIHtcbiAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICExO1xuICByZXR1cm4gXCJNXCIuY29uY2F0KGUudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIikpLmNvbmNhdCh0ID8gXCJMXCIgOiBcIlwiKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVOb25MdW5pc29sYXJNb250aChlLCB0KSB7XG4gIHZhciByID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMjtcbiAgdmFyIG8gPSBlLm1vbnRoLFxuICAgIG4gPSBlLm1vbnRoQ29kZTtcbiAgaWYgKHZvaWQgMCA9PT0gbikge1xuICAgIGlmICh2b2lkIDAgPT09IG8pIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFaXRoZXIgbW9udGggb3IgbW9udGhDb2RlIGFyZSByZXF1aXJlZFwiKTtcbiAgICBcInJlamVjdFwiID09PSB0ICYmIFJlamVjdFRvUmFuZ2UobywgMSwgciksIFwiY29uc3RyYWluXCIgPT09IHQgJiYgKG8gPSBDb25zdHJhaW5Ub1JhbmdlKG8sIDEsIHIpKSwgbiA9IGJ1aWxkTW9udGhDb2RlKG8pO1xuICB9IGVsc2Uge1xuICAgIHZhciBfZTM2ID0gbW9udGhDb2RlTnVtYmVyUGFydChuKTtcbiAgICBpZiAodm9pZCAwICE9PSBvICYmIG8gIT09IF9lMzYpIHRocm93IG5ldyBSYW5nZUVycm9yKFwibW9udGhDb2RlIFwiLmNvbmNhdChuLCBcIiBhbmQgbW9udGggXCIpLmNvbmNhdChvLCBcIiBtdXN0IG1hdGNoIGlmIGJvdGggYXJlIHByZXNlbnRcIikpO1xuICAgIGlmIChuICE9PSBidWlsZE1vbnRoQ29kZShfZTM2KSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1vbnRoIGNvZGU6IFwiLmNvbmNhdChuKSk7XG4gICAgaWYgKG8gPSBfZTM2LCBvIDwgMSB8fCBvID4gcikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1vbnRoQ29kZTogXCIuY29uY2F0KG4pKTtcbiAgfVxuICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGUpLCB7fSwge1xuICAgIG1vbnRoOiBvLFxuICAgIG1vbnRoQ29kZTogblxuICB9KTtcbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhDYWxlbmRhciwgXCJUZW1wb3JhbC5DYWxlbmRhclwiKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIuZnJvbVwiLCBDYWxlbmRhci5mcm9tKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRhdGVBZGRcIiwgQ2FsZW5kYXIucHJvdG90eXBlLmRhdGVBZGQpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZGF0ZUZyb21GaWVsZHNcIiwgQ2FsZW5kYXIucHJvdG90eXBlLmRhdGVGcm9tRmllbGRzKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRhdGVVbnRpbFwiLCBDYWxlbmRhci5wcm90b3R5cGUuZGF0ZVVudGlsKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRheVwiLCBDYWxlbmRhci5wcm90b3R5cGUuZGF5KSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRheU9mV2Vla1wiLCBDYWxlbmRhci5wcm90b3R5cGUuZGF5T2ZXZWVrKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRheU9mWWVhclwiLCBDYWxlbmRhci5wcm90b3R5cGUuZGF5T2ZZZWFyKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRheXNJbk1vbnRoXCIsIENhbGVuZGFyLnByb3RvdHlwZS5kYXlzSW5Nb250aCksIERlZmluZUludHJpbnNpYyhcIlRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5kYXlzSW5XZWVrXCIsIENhbGVuZGFyLnByb3RvdHlwZS5kYXlzSW5XZWVrKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLmRheXNJblllYXJcIiwgQ2FsZW5kYXIucHJvdG90eXBlLmRheXNJblllYXIpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZXJhXCIsIENhbGVuZGFyLnByb3RvdHlwZS5lcmEpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUuZXJhWWVhclwiLCBDYWxlbmRhci5wcm90b3R5cGUuZXJhWWVhciksIERlZmluZUludHJpbnNpYyhcIlRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5maWVsZHNcIiwgQ2FsZW5kYXIucHJvdG90eXBlLmZpZWxkcyksIERlZmluZUludHJpbnNpYyhcIlRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5pbkxlYXBZZWFyXCIsIENhbGVuZGFyLnByb3RvdHlwZS5pbkxlYXBZZWFyKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLm1lcmdlRmllbGRzXCIsIENhbGVuZGFyLnByb3RvdHlwZS5tZXJnZUZpZWxkcyksIERlZmluZUludHJpbnNpYyhcIlRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS5tb250aFwiLCBDYWxlbmRhci5wcm90b3R5cGUubW9udGgpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUubW9udGhDb2RlXCIsIENhbGVuZGFyLnByb3RvdHlwZS5tb250aENvZGUpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUubW9udGhEYXlGcm9tRmllbGRzXCIsIENhbGVuZGFyLnByb3RvdHlwZS5tb250aERheUZyb21GaWVsZHMpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUubW9udGhzSW5ZZWFyXCIsIENhbGVuZGFyLnByb3RvdHlwZS5tb250aHNJblllYXIpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUud2Vla09mWWVhclwiLCBDYWxlbmRhci5wcm90b3R5cGUud2Vla09mWWVhciksIERlZmluZUludHJpbnNpYyhcIlRlbXBvcmFsLkNhbGVuZGFyLnByb3RvdHlwZS55ZWFyXCIsIENhbGVuZGFyLnByb3RvdHlwZS55ZWFyKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuQ2FsZW5kYXIucHJvdG90eXBlLnllYXJNb250aEZyb21GaWVsZHNcIiwgQ2FsZW5kYXIucHJvdG90eXBlLnllYXJNb250aEZyb21GaWVsZHMpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5DYWxlbmRhci5wcm90b3R5cGUueWVhck9mV2Vla1wiLCBDYWxlbmRhci5wcm90b3R5cGUueWVhck9mV2VlayksIE90Lmlzbzg2MDEgPSB7XG4gIGRhdGVGcm9tRmllbGRzOiBmdW5jdGlvbiBkYXRlRnJvbUZpZWxkcyhlLCB0LCByKSB7XG4gICAgdmFyIF9SZWd1bGF0ZUlTT0RhdGUyO1xuICAgIHZhciBvID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIFtcImRheVwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwieWVhclwiXSwgW1wieWVhclwiLCBcImRheVwiXSk7XG4gICAgdmFyIG4gPSBUb1RlbXBvcmFsT3ZlcmZsb3codCk7XG4gICAgbyA9IHJlc29sdmVOb25MdW5pc29sYXJNb250aChvKTtcbiAgICB2YXIgX28zMyA9IG8sXG4gICAgICBhID0gX28zMy55ZWFyLFxuICAgICAgaSA9IF9vMzMubW9udGgsXG4gICAgICBzID0gX28zMy5kYXk7XG4gICAgcmV0dXJuIChfUmVndWxhdGVJU09EYXRlMiA9IFJlZ3VsYXRlSVNPRGF0ZShhLCBpLCBzLCBuKSwgYSA9IF9SZWd1bGF0ZUlTT0RhdGUyLnllYXIsIGkgPSBfUmVndWxhdGVJU09EYXRlMi5tb250aCwgcyA9IF9SZWd1bGF0ZUlTT0RhdGUyLmRheSksIENyZWF0ZVRlbXBvcmFsRGF0ZShhLCBpLCBzLCByKTtcbiAgfSxcbiAgeWVhck1vbnRoRnJvbUZpZWxkczogZnVuY3Rpb24geWVhck1vbnRoRnJvbUZpZWxkcyhlLCB0LCByKSB7XG4gICAgdmFyIF9SZWd1bGF0ZUlTT1llYXJNb250aDtcbiAgICB2YXIgbyA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhlLCBbXCJtb250aFwiLCBcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0sIFtcInllYXJcIl0pO1xuICAgIHZhciBuID0gVG9UZW1wb3JhbE92ZXJmbG93KHQpO1xuICAgIG8gPSByZXNvbHZlTm9uTHVuaXNvbGFyTW9udGgobyk7XG4gICAgdmFyIF9vMzQgPSBvLFxuICAgICAgYSA9IF9vMzQueWVhcixcbiAgICAgIGkgPSBfbzM0Lm1vbnRoO1xuICAgIHJldHVybiAoX1JlZ3VsYXRlSVNPWWVhck1vbnRoID0gZnVuY3Rpb24gUmVndWxhdGVJU09ZZWFyTW9udGgoZSwgdCwgcikge1xuICAgICAgdmFyIG8gPSBlLFxuICAgICAgICBuID0gdDtcbiAgICAgIHN3aXRjaCAocikge1xuICAgICAgICBjYXNlIFwicmVqZWN0XCI6XG4gICAgICAgICAgUmVqZWN0SVNPRGF0ZShvLCBuLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNvbnN0cmFpblwiOlxuICAgICAgICAgIHZhciBfQ29uc3RyYWluSVNPRGF0ZTIgPSBDb25zdHJhaW5JU09EYXRlKG8sIG4pO1xuICAgICAgICAgIG8gPSBfQ29uc3RyYWluSVNPRGF0ZTIueWVhcjtcbiAgICAgICAgICBuID0gX0NvbnN0cmFpbklTT0RhdGUyLm1vbnRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogbyxcbiAgICAgICAgbW9udGg6IG5cbiAgICAgIH07XG4gICAgfShhLCBpLCBuKSwgYSA9IF9SZWd1bGF0ZUlTT1llYXJNb250aC55ZWFyLCBpID0gX1JlZ3VsYXRlSVNPWWVhck1vbnRoLm1vbnRoKSwgQ3JlYXRlVGVtcG9yYWxZZWFyTW9udGgoYSwgaSwgciwgMSk7XG4gIH0sXG4gIG1vbnRoRGF5RnJvbUZpZWxkczogZnVuY3Rpb24gbW9udGhEYXlGcm9tRmllbGRzKGUsIHQsIHIpIHtcbiAgICB2YXIgX1JlZ3VsYXRlSVNPRGF0ZTM7XG4gICAgdmFyIG8gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZSwgW1wiZGF5XCIsIFwibW9udGhcIiwgXCJtb250aENvZGVcIiwgXCJ5ZWFyXCJdLCBbXCJkYXlcIl0pO1xuICAgIHZhciBuID0gVG9UZW1wb3JhbE92ZXJmbG93KHQpO1xuICAgIGlmICh2b2lkIDAgIT09IG8ubW9udGggJiYgdm9pZCAwID09PSBvLnllYXIgJiYgdm9pZCAwID09PSBvLm1vbnRoQ29kZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImVpdGhlciB5ZWFyIG9yIG1vbnRoQ29kZSByZXF1aXJlZCB3aXRoIG1vbnRoXCIpO1xuICAgIHZhciBhID0gdm9pZCAwID09PSBvLm1vbnRoQ29kZTtcbiAgICBvID0gcmVzb2x2ZU5vbkx1bmlzb2xhck1vbnRoKG8pO1xuICAgIHZhciBfbzM1ID0gbyxcbiAgICAgIGkgPSBfbzM1Lm1vbnRoLFxuICAgICAgcyA9IF9vMzUuZGF5LFxuICAgICAgbCA9IF9vMzUueWVhcjtcbiAgICByZXR1cm4gKF9SZWd1bGF0ZUlTT0RhdGUzID0gUmVndWxhdGVJU09EYXRlKGEgPyBsIDogMTk3MiwgaSwgcywgbiksIGkgPSBfUmVndWxhdGVJU09EYXRlMy5tb250aCwgcyA9IF9SZWd1bGF0ZUlTT0RhdGUzLmRheSksIENyZWF0ZVRlbXBvcmFsTW9udGhEYXkoaSwgcywgciwgMTk3Mik7XG4gIH0sXG4gIGZpZWxkczogZnVuY3Rpb24gZmllbGRzKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfSxcbiAgZmllbGRLZXlzVG9JZ25vcmU6IGZ1bmN0aW9uIGZpZWxkS2V5c1RvSWdub3JlKGUpIHtcbiAgICB2YXIgdCA9IG5ldyBEdCgpO1xuICAgIGZvciAodmFyIF9yNTggPSAwOyBfcjU4IDwgZS5sZW5ndGg7IF9yNTgrKykge1xuICAgICAgdmFyIF9vMzYgPSBlW19yNThdO1xuICAgICAgQ2FsbCh2dCwgdCwgW19vMzZdKSwgXCJtb250aFwiID09PSBfbzM2ID8gQ2FsbCh2dCwgdCwgW1wibW9udGhDb2RlXCJdKSA6IFwibW9udGhDb2RlXCIgPT09IF9vMzYgJiYgQ2FsbCh2dCwgdCwgW1wibW9udGhcIl0pO1xuICAgIH1cbiAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KENhbGwoQ3QsIHQsIFtdKSk7XG4gIH0sXG4gIGRhdGVBZGQ6IGZ1bmN0aW9uIGRhdGVBZGQoZSwgdCwgciwgbywgbiwgYSwgZCkge1xuICAgIHZhciBfQWRkSVNPRGF0ZTtcbiAgICB2YXIgbSA9IEdldFNsb3QoZSwgaSksXG4gICAgICBjID0gR2V0U2xvdChlLCBzKSxcbiAgICAgIGggPSBHZXRTbG90KGUsIGwpO1xuICAgIHJldHVybiAoX0FkZElTT0RhdGUgPSBBZGRJU09EYXRlKG0sIGMsIGgsIHQsIHIsIG8sIG4sIGEpLCBtID0gX0FkZElTT0RhdGUueWVhciwgYyA9IF9BZGRJU09EYXRlLm1vbnRoLCBoID0gX0FkZElTT0RhdGUuZGF5KSwgQ3JlYXRlVGVtcG9yYWxEYXRlKG0sIGMsIGgsIGQpO1xuICB9LFxuICBkYXRlVW50aWw6IGZ1bmN0aW9uIGRhdGVVbnRpbChlLCB0LCByKSB7XG4gICAgcmV0dXJuIERpZmZlcmVuY2VJU09EYXRlKEdldFNsb3QoZSwgaSksIEdldFNsb3QoZSwgcyksIEdldFNsb3QoZSwgbCksIEdldFNsb3QodCwgaSksIEdldFNsb3QodCwgcyksIEdldFNsb3QodCwgbCksIHIpO1xuICB9LFxuICB5ZWFyOiBmdW5jdGlvbiB5ZWFyKGUpIHtcbiAgICByZXR1cm4gR2V0U2xvdChlLCBpKTtcbiAgfSxcbiAgZXJhOiBmdW5jdGlvbiBlcmEoKSB7fSxcbiAgZXJhWWVhcjogZnVuY3Rpb24gZXJhWWVhcigpIHt9LFxuICBtb250aDogZnVuY3Rpb24gbW9udGgoZSkge1xuICAgIHJldHVybiBHZXRTbG90KGUsIHMpO1xuICB9LFxuICBtb250aENvZGU6IGZ1bmN0aW9uIG1vbnRoQ29kZShlKSB7XG4gICAgcmV0dXJuIGJ1aWxkTW9udGhDb2RlKEdldFNsb3QoZSwgcykpO1xuICB9LFxuICBkYXk6IGZ1bmN0aW9uIGRheShlKSB7XG4gICAgcmV0dXJuIEdldFNsb3QoZSwgbCk7XG4gIH0sXG4gIGRheU9mV2VlazogZnVuY3Rpb24gZGF5T2ZXZWVrKGUpIHtcbiAgICByZXR1cm4gRGF5T2ZXZWVrKEdldFNsb3QoZSwgaSksIEdldFNsb3QoZSwgcyksIEdldFNsb3QoZSwgbCkpO1xuICB9LFxuICBkYXlPZlllYXI6IGZ1bmN0aW9uIGRheU9mWWVhcihlKSB7XG4gICAgcmV0dXJuIERheU9mWWVhcihHZXRTbG90KGUsIGkpLCBHZXRTbG90KGUsIHMpLCBHZXRTbG90KGUsIGwpKTtcbiAgfSxcbiAgd2Vla09mWWVhcjogZnVuY3Rpb24gd2Vla09mWWVhcihlKSB7XG4gICAgcmV0dXJuIFdlZWtPZlllYXIoR2V0U2xvdChlLCBpKSwgR2V0U2xvdChlLCBzKSwgR2V0U2xvdChlLCBsKSkud2VlaztcbiAgfSxcbiAgeWVhck9mV2VlazogZnVuY3Rpb24geWVhck9mV2VlayhlKSB7XG4gICAgcmV0dXJuIFdlZWtPZlllYXIoR2V0U2xvdChlLCBpKSwgR2V0U2xvdChlLCBzKSwgR2V0U2xvdChlLCBsKSkueWVhcjtcbiAgfSxcbiAgZGF5c0luV2VlazogZnVuY3Rpb24gZGF5c0luV2VlaygpIHtcbiAgICByZXR1cm4gNztcbiAgfSxcbiAgZGF5c0luTW9udGg6IGZ1bmN0aW9uIGRheXNJbk1vbnRoKGUpIHtcbiAgICByZXR1cm4gSVNPRGF5c0luTW9udGgoR2V0U2xvdChlLCBpKSwgR2V0U2xvdChlLCBzKSk7XG4gIH0sXG4gIGRheXNJblllYXI6IGZ1bmN0aW9uIGRheXNJblllYXIoZSkge1xuICAgIHZhciB0ID0gZTtcbiAgICByZXR1cm4gSGFzU2xvdCh0LCBpKSB8fCAodCA9IFRvVGVtcG9yYWxEYXRlKHQpKSwgTGVhcFllYXIoR2V0U2xvdCh0LCBpKSkgPyAzNjYgOiAzNjU7XG4gIH0sXG4gIG1vbnRoc0luWWVhcjogZnVuY3Rpb24gbW9udGhzSW5ZZWFyKCkge1xuICAgIHJldHVybiAxMjtcbiAgfSxcbiAgaW5MZWFwWWVhcjogZnVuY3Rpb24gaW5MZWFwWWVhcihlKSB7XG4gICAgdmFyIHQgPSBlO1xuICAgIHJldHVybiBIYXNTbG90KHQsIGkpIHx8ICh0ID0gVG9UZW1wb3JhbERhdGUodCkpLCBMZWFwWWVhcihHZXRTbG90KHQsIGkpKTtcbiAgfVxufTtcbnZhciBPbmVPYmplY3RDYWNoZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9uZU9iamVjdENhY2hlKGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT25lT2JqZWN0Q2FjaGUpO1xuICAgIGlmICh0aGlzLm1hcCA9IG5ldyBNYXAoKSwgdGhpcy5jYWxscyA9IDAsIHRoaXMuaGl0cyA9IDAsIHRoaXMubWlzc2VzID0gMCwgdGhpcy5ub3cgPSBnbG9iYWxUaGlzLnBlcmZvcm1hbmNlID8gZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZS5ub3coKSA6IERhdGUubm93KCksIHZvaWQgMCAhPT0gZSkge1xuICAgICAgdmFyIF90NDMgPSAwO1xuICAgICAgdmFyIF9pdGVyYXRvcjE3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZS5tYXAuZW50cmllcygpKSxcbiAgICAgICAgX3N0ZXAxNztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTcucygpOyAhKF9zdGVwMTcgPSBfaXRlcmF0b3IxNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF90aGlzJG1hcDtcbiAgICAgICAgICB2YXIgX3I1OSA9IF9zdGVwMTcudmFsdWU7XG4gICAgICAgICAgaWYgKCsrX3Q0MyA+IE9uZU9iamVjdENhY2hlLk1BWF9DQUNIRV9FTlRSSUVTKSBicmVhaztcbiAgICAgICAgICAoX3RoaXMkbWFwID0gdGhpcy5tYXApLnNldC5hcHBseShfdGhpcyRtYXAsIF90b0NvbnN1bWFibGVBcnJheShfcjU5KSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxNy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxNy5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jcmVhdGVDbGFzcyhPbmVPYmplY3RDYWNoZSwgW3tcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChlKSB7XG4gICAgICB2YXIgdCA9IHRoaXMubWFwLmdldChlKTtcbiAgICAgIHJldHVybiB0ICYmICh0aGlzLmhpdHMrKywgdGhpcy5yZXBvcnQoKSksIHRoaXMuY2FsbHMrKywgdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChlLCB0KSB7XG4gICAgICB0aGlzLm1hcC5zZXQoZSwgdCksIHRoaXMubWlzc2VzKyssIHRoaXMucmVwb3J0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcG9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBvcnQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInNldE9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPYmplY3QoZSkge1xuICAgICAgaWYgKE9uZU9iamVjdENhY2hlLm9iamVjdE1hcC5nZXQoZSkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwib2JqZWN0IGFscmVhZHkgY2FjaGVkXCIpO1xuICAgICAgT25lT2JqZWN0Q2FjaGUub2JqZWN0TWFwLnNldChlLCB0aGlzKSwgdGhpcy5yZXBvcnQoKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXRDYWNoZUZvck9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWNoZUZvck9iamVjdChlKSB7XG4gICAgICB2YXIgdCA9IE9uZU9iamVjdENhY2hlLm9iamVjdE1hcC5nZXQoZSk7XG4gICAgICByZXR1cm4gdCB8fCAodCA9IG5ldyBPbmVPYmplY3RDYWNoZSgpLCBPbmVPYmplY3RDYWNoZS5vYmplY3RNYXAuc2V0KGUsIHQpKSwgdDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE9uZU9iamVjdENhY2hlO1xufSgpO1xuZnVuY3Rpb24gdG9VdGNJc29EYXRlU3RyaW5nKF9yZWY4KSB7XG4gIHZhciBlID0gX3JlZjguaXNvWWVhcixcbiAgICB0ID0gX3JlZjguaXNvTW9udGgsXG4gICAgciA9IF9yZWY4Lmlzb0RheTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KElTT1llYXJTdHJpbmcoZSksIFwiLVwiKS5jb25jYXQoSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKHQpLCBcIi1cIikuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhyKSwgXCJUMDA6MDBaXCIpO1xufVxuZnVuY3Rpb24gc2ltcGxlRGF0ZURpZmYoZSwgdCkge1xuICByZXR1cm4ge1xuICAgIHllYXJzOiBlLnllYXIgLSB0LnllYXIsXG4gICAgbW9udGhzOiBlLm1vbnRoIC0gdC5tb250aCxcbiAgICBkYXlzOiBlLmRheSAtIHQuZGF5XG4gIH07XG59XG5PbmVPYmplY3RDYWNoZS5vYmplY3RNYXAgPSBuZXcgV2Vha01hcCgpLCBPbmVPYmplY3RDYWNoZS5NQVhfQ0FDSEVfRU5UUklFUyA9IDFlMztcbnZhciBIZWxwZXJCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSGVscGVyQmFzZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGVscGVyQmFzZSk7XG4gICAgdGhpcy5lcmFMZW5ndGggPSBcInNob3J0XCIsIHRoaXMuaGFzRXJhID0gITAsIHRoaXMuZXJhc0JlZ2luTWlkWWVhciA9ICExO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhIZWxwZXJCYXNlLCBbe1xuICAgIGtleTogXCJnZXRGb3JtYXR0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0dGVyKCkge1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdGhpcy5mb3JtYXR0ZXIgJiYgKHRoaXMuZm9ybWF0dGVyID0gbmV3IGZ0KFwiZW4tVVMtdS1jYS1cIi5jb25jYXQodGhpcy5pZCksIHtcbiAgICAgICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICAgICAgbW9udGg6IFwibnVtZXJpY1wiLFxuICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgICAgZXJhOiB0aGlzLmVyYUxlbmd0aCxcbiAgICAgICAgdGltZVpvbmU6IFwiVVRDXCJcbiAgICAgIH0pKSwgdGhpcy5mb3JtYXR0ZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzb1RvQ2FsZW5kYXJEYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzb1RvQ2FsZW5kYXJEYXRlKGUsIHQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgciA9IGUueWVhcixcbiAgICAgICAgbyA9IGUubW9udGgsXG4gICAgICAgIG4gPSBlLmRheSxcbiAgICAgICAgYSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBmdW5jOiBcImlzb1RvQ2FsZW5kYXJEYXRlXCIsXG4gICAgICAgICAgaXNvWWVhcjogcixcbiAgICAgICAgICBpc29Nb250aDogbyxcbiAgICAgICAgICBpc29EYXk6IG4sXG4gICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgfSksXG4gICAgICAgIGkgPSB0LmdldChhKTtcbiAgICAgIGlmIChpKSByZXR1cm4gaTtcbiAgICAgIHZhciBzID0gdGhpcy5nZXRGb3JtYXR0ZXIoKTtcbiAgICAgIHZhciBsLCBkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZCA9IHRvVXRjSXNvRGF0ZVN0cmluZyh7XG4gICAgICAgICAgaXNvWWVhcjogcixcbiAgICAgICAgICBpc29Nb250aDogbyxcbiAgICAgICAgICBpc29EYXk6IG5cbiAgICAgICAgfSksIGwgPSBzLmZvcm1hdFRvUGFydHMobmV3IERhdGUoZCkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSVNPIGRhdGU6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaXNvWWVhcjogcixcbiAgICAgICAgICBpc29Nb250aDogbyxcbiAgICAgICAgICBpc29EYXk6IG5cbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIHZhciBtID0ge307XG4gICAgICB2YXIgX2l0ZXJhdG9yMTggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsKSxcbiAgICAgICAgX3N0ZXAxODtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTgucygpOyAhKF9zdGVwMTggPSBfaXRlcmF0b3IxOC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMTgkdmFsdWUgPSBfc3RlcDE4LnZhbHVlLFxuICAgICAgICAgICAgX2UzNyA9IF9zdGVwMTgkdmFsdWUudHlwZSxcbiAgICAgICAgICAgIF90NDUgPSBfc3RlcDE4JHZhbHVlLnZhbHVlO1xuICAgICAgICAgIGlmIChcInllYXJcIiA9PT0gX2UzNyAmJiAobS5lcmFZZWFyID0gK190NDUpLCBcInJlbGF0ZWRZZWFyXCIgPT09IF9lMzcgJiYgKG0uZXJhWWVhciA9ICtfdDQ1KSwgXCJtb250aFwiID09PSBfZTM3KSB7XG4gICAgICAgICAgICB2YXIgX2UzOCA9IC9eKFswLTldKikoLio/KSQvLmV4ZWMoX3Q0NSk7XG4gICAgICAgICAgICBpZiAoIV9lMzggfHwgMyAhPSBfZTM4Lmxlbmd0aCB8fCAhX2UzOFsxXSAmJiAhX2UzOFsyXSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbmV4cGVjdGVkIG1vbnRoOiBcIi5jb25jYXQoX3Q0NSkpO1xuICAgICAgICAgICAgaWYgKG0ubW9udGggPSBfZTM4WzFdID8gK19lMzhbMV0gOiAxLCBtLm1vbnRoIDwgMSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1vbnRoIFwiLmNvbmNhdChfdDQ1LCBcIiBmcm9tIFwiKS5jb25jYXQoZCwgXCJbdS1jYS1cIikuY29uY2F0KHRoaXMuaWQsIFwiXSAocHJvYmFibHkgZHVlIHRvIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEwNTI3KVwiKSk7XG4gICAgICAgICAgICBpZiAobS5tb250aCA+IDEzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbW9udGggXCIuY29uY2F0KF90NDUsIFwiIGZyb20gXCIpLmNvbmNhdChkLCBcIlt1LWNhLVwiKS5jb25jYXQodGhpcy5pZCwgXCJdIChwcm9iYWJseSBkdWUgdG8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MTA1MjkpXCIpKTtcbiAgICAgICAgICAgIF9lMzhbMl0gJiYgKG0ubW9udGhFeHRyYSA9IF9lMzhbMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcImRheVwiID09PSBfZTM3ICYmIChtLmRheSA9ICtfdDQ1KSwgdGhpcy5oYXNFcmEgJiYgXCJlcmFcIiA9PT0gX2UzNyAmJiBudWxsICE9IF90NDUgJiYgXCJcIiAhPT0gX3Q0NSAmJiAoX3Q0NSA9IF90NDUuc3BsaXQoXCIgKFwiKVswXSwgbS5lcmEgPSBfdDQ1Lm5vcm1hbGl6ZShcIk5GRFwiKS5yZXBsYWNlKC8oPzpbXFwwLVxceDFGIS0sXFwuXFwvOi1AXFxbLWBcXHstXFx4QTlcXHhBQi1cXHhCNFxceEI2LVxceEI5XFx4QkItXFx4QkZcXHhEN1xceEY3XFx1MDJDMi1cXHUwMkM1XFx1MDJEMi1cXHUwMkRGXFx1MDJFNS1cXHUwMkVCXFx1MDJFRFxcdTAyRUYtXFx1MDM2RlxcdTAzNzVcXHUwMzc4XFx1MDM3OVxcdTAzN0VcXHUwMzgwLVxcdTAzODVcXHUwMzg3XFx1MDM4QlxcdTAzOERcXHUwM0EyXFx1MDNGNlxcdTA0ODItXFx1MDQ4OVxcdTA1MzBcXHUwNTU3XFx1MDU1OFxcdTA1NUEtXFx1MDU1RlxcdTA1ODktXFx1MDVDRlxcdTA1RUItXFx1MDVFRVxcdTA1RjMtXFx1MDYxRlxcdTA2NEItXFx1MDY2RFxcdTA2NzBcXHUwNkQ0XFx1MDZENi1cXHUwNkU0XFx1MDZFNy1cXHUwNkVEXFx1MDZGMC1cXHUwNkY5XFx1MDZGRFxcdTA2RkVcXHUwNzAwLVxcdTA3MEZcXHUwNzExXFx1MDczMC1cXHUwNzRDXFx1MDdBNi1cXHUwN0IwXFx1MDdCMi1cXHUwN0M5XFx1MDdFQi1cXHUwN0YzXFx1MDdGNi1cXHUwN0Y5XFx1MDdGQi1cXHUwN0ZGXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODNGXFx1MDg1OS1cXHUwODVGXFx1MDg2Qi1cXHUwODZGXFx1MDg4OFxcdTA4OEYtXFx1MDg5RlxcdTA4Q0EtXFx1MDkwM1xcdTA5M0EtXFx1MDkzQ1xcdTA5M0UtXFx1MDk0RlxcdTA5NTEtXFx1MDk1N1xcdTA5NjItXFx1MDk3MFxcdTA5ODEtXFx1MDk4NFxcdTA5OERcXHUwOThFXFx1MDk5MVxcdTA5OTJcXHUwOUE5XFx1MDlCMVxcdTA5QjMtXFx1MDlCNVxcdTA5QkEtXFx1MDlCQ1xcdTA5QkUtXFx1MDlDRFxcdTA5Q0YtXFx1MDlEQlxcdTA5REVcXHUwOUUyLVxcdTA5RUZcXHUwOUYyLVxcdTA5RkJcXHUwOUZELVxcdTBBMDRcXHUwQTBCLVxcdTBBMEVcXHUwQTExXFx1MEExMlxcdTBBMjlcXHUwQTMxXFx1MEEzNFxcdTBBMzdcXHUwQTNBLVxcdTBBNThcXHUwQTVEXFx1MEE1Ri1cXHUwQTcxXFx1MEE3NS1cXHUwQTg0XFx1MEE4RVxcdTBBOTJcXHUwQUE5XFx1MEFCMVxcdTBBQjRcXHUwQUJBLVxcdTBBQkNcXHUwQUJFLVxcdTBBQ0ZcXHUwQUQxLVxcdTBBREZcXHUwQUUyLVxcdTBBRjhcXHUwQUZBLVxcdTBCMDRcXHUwQjBEXFx1MEIwRVxcdTBCMTFcXHUwQjEyXFx1MEIyOVxcdTBCMzFcXHUwQjM0XFx1MEIzQS1cXHUwQjNDXFx1MEIzRS1cXHUwQjVCXFx1MEI1RVxcdTBCNjItXFx1MEI3MFxcdTBCNzItXFx1MEI4MlxcdTBCODRcXHUwQjhCLVxcdTBCOERcXHUwQjkxXFx1MEI5Ni1cXHUwQjk4XFx1MEI5QlxcdTBCOURcXHUwQkEwLVxcdTBCQTJcXHUwQkE1LVxcdTBCQTdcXHUwQkFCLVxcdTBCQURcXHUwQkJBLVxcdTBCQ0ZcXHUwQkQxLVxcdTBDMDRcXHUwQzBEXFx1MEMxMVxcdTBDMjlcXHUwQzNBLVxcdTBDM0NcXHUwQzNFLVxcdTBDNTdcXHUwQzVCXFx1MEM1Q1xcdTBDNUVcXHUwQzVGXFx1MEM2Mi1cXHUwQzdGXFx1MEM4MS1cXHUwQzg0XFx1MEM4RFxcdTBDOTFcXHUwQ0E5XFx1MENCNFxcdTBDQkEtXFx1MENCQ1xcdTBDQkUtXFx1MENEQ1xcdTBDREZcXHUwQ0UyLVxcdTBDRjBcXHUwQ0YzLVxcdTBEMDNcXHUwRDBEXFx1MEQxMVxcdTBEM0JcXHUwRDNDXFx1MEQzRS1cXHUwRDREXFx1MEQ0Ri1cXHUwRDUzXFx1MEQ1Ny1cXHUwRDVFXFx1MEQ2Mi1cXHUwRDc5XFx1MEQ4MC1cXHUwRDg0XFx1MEQ5Ny1cXHUwRDk5XFx1MERCMlxcdTBEQkNcXHUwREJFXFx1MERCRlxcdTBEQzctXFx1MEUwMFxcdTBFMzFcXHUwRTM0LVxcdTBFM0ZcXHUwRTQ3LVxcdTBFODBcXHUwRTgzXFx1MEU4NVxcdTBFOEJcXHUwRUE0XFx1MEVBNlxcdTBFQjFcXHUwRUI0LVxcdTBFQkNcXHUwRUJFXFx1MEVCRlxcdTBFQzVcXHUwRUM3LVxcdTBFREJcXHUwRUUwLVxcdTBFRkZcXHUwRjAxLVxcdTBGM0ZcXHUwRjQ4XFx1MEY2RC1cXHUwRjg3XFx1MEY4RC1cXHUwRkZGXFx1MTAyQi1cXHUxMDNFXFx1MTA0MC1cXHUxMDRGXFx1MTA1Ni1cXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZEXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhEXFx1MTA4Ri1cXHUxMDlGXFx1MTBDNlxcdTEwQzgtXFx1MTBDQ1xcdTEwQ0VcXHUxMENGXFx1MTBGQlxcdTEyNDlcXHUxMjRFXFx1MTI0RlxcdTEyNTdcXHUxMjU5XFx1MTI1RVxcdTEyNUZcXHUxMjg5XFx1MTI4RVxcdTEyOEZcXHUxMkIxXFx1MTJCNlxcdTEyQjdcXHUxMkJGXFx1MTJDMVxcdTEyQzZcXHUxMkM3XFx1MTJEN1xcdTEzMTFcXHUxMzE2XFx1MTMxN1xcdTEzNUItXFx1MTM3RlxcdTEzOTAtXFx1MTM5RlxcdTEzRjZcXHUxM0Y3XFx1MTNGRS1cXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjgwXFx1MTY5Qi1cXHUxNjlGXFx1MTZFQi1cXHUxNkYwXFx1MTZGOS1cXHUxNkZGXFx1MTcxMi1cXHUxNzFFXFx1MTczMi1cXHUxNzNGXFx1MTc1Mi1cXHUxNzVGXFx1MTc2RFxcdTE3NzEtXFx1MTc3RlxcdTE3QjQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQlxcdTE3REQtXFx1MTgxRlxcdTE4NzktXFx1MTg3RlxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE4QUItXFx1MThBRlxcdTE4RjYtXFx1MThGRlxcdTE5MUYtXFx1MTk0RlxcdTE5NkVcXHUxOTZGXFx1MTk3NS1cXHUxOTdGXFx1MTlBQy1cXHUxOUFGXFx1MTlDQS1cXHUxOUZGXFx1MUExNy1cXHUxQTFGXFx1MUE1NS1cXHUxQUE2XFx1MUFBOC1cXHUxQjA0XFx1MUIzNC1cXHUxQjQ0XFx1MUI0RC1cXHUxQjgyXFx1MUJBMS1cXHUxQkFEXFx1MUJCMC1cXHUxQkI5XFx1MUJFNi1cXHUxQkZGXFx1MUMyNC1cXHUxQzRDXFx1MUM1MC1cXHUxQzU5XFx1MUM3RVxcdTFDN0ZcXHUxQzg5LVxcdTFDOEZcXHUxQ0JCXFx1MUNCQ1xcdTFDQzAtXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGNy1cXHUxQ0Y5XFx1MUNGQi1cXHUxQ0ZGXFx1MURDMC1cXHUxREZGXFx1MUYxNlxcdTFGMTdcXHUxRjFFXFx1MUYxRlxcdTFGNDZcXHUxRjQ3XFx1MUY0RVxcdTFGNEZcXHUxRjU4XFx1MUY1QVxcdTFGNUNcXHUxRjVFXFx1MUY3RVxcdTFGN0ZcXHUxRkI1XFx1MUZCRFxcdTFGQkYtXFx1MUZDMVxcdTFGQzVcXHUxRkNELVxcdTFGQ0ZcXHUxRkQ0XFx1MUZENVxcdTFGREMtXFx1MUZERlxcdTFGRUQtXFx1MUZGMVxcdTFGRjVcXHUxRkZELVxcdTIwNzBcXHUyMDcyLVxcdTIwN0VcXHUyMDgwLVxcdTIwOEZcXHUyMDlELVxcdTIxMDFcXHUyMTAzLVxcdTIxMDZcXHUyMTA4XFx1MjEwOVxcdTIxMTRcXHUyMTE2LVxcdTIxMThcXHUyMTFFLVxcdTIxMjNcXHUyMTI1XFx1MjEyN1xcdTIxMjlcXHUyMTJFXFx1MjEzQVxcdTIxM0JcXHUyMTQwLVxcdTIxNDRcXHUyMTRBLVxcdTIxNERcXHUyMTRGLVxcdTIxODJcXHUyMTg1LVxcdTJCRkZcXHUyQ0U1LVxcdTJDRUFcXHUyQ0VGLVxcdTJDRjFcXHUyQ0Y0LVxcdTJDRkZcXHUyRDI2XFx1MkQyOC1cXHUyRDJDXFx1MkQyRVxcdTJEMkZcXHUyRDY4LVxcdTJENkVcXHUyRDcwLVxcdTJEN0ZcXHUyRDk3LVxcdTJEOUZcXHUyREE3XFx1MkRBRlxcdTJEQjdcXHUyREJGXFx1MkRDN1xcdTJEQ0ZcXHUyREQ3XFx1MkRERi1cXHUyRTJFXFx1MkUzMC1cXHUzMDA0XFx1MzAwNy1cXHUzMDMwXFx1MzAzNi1cXHUzMDNBXFx1MzAzRC1cXHUzMDQwXFx1MzA5Ny1cXHUzMDlDXFx1MzBBMFxcdTMwRkJcXHUzMTAwLVxcdTMxMDRcXHUzMTMwXFx1MzE4Ri1cXHUzMTlGXFx1MzFDMC1cXHUzMUVGXFx1MzIwMC1cXHUzM0ZGXFx1NERDMC1cXHU0REZGXFx1QTQ4RC1cXHVBNENGXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjIwLVxcdUE2MjlcXHVBNjJDLVxcdUE2M0ZcXHVBNjZGLVxcdUE2N0VcXHVBNjlFXFx1QTY5RlxcdUE2RTYtXFx1QTcxNlxcdUE3MjBcXHVBNzIxXFx1QTc4OVxcdUE3OEFcXHVBN0NCLVxcdUE3Q0ZcXHVBN0QyXFx1QTdENFxcdUE3REEtXFx1QTdGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjMtXFx1QTgzRlxcdUE4NzQtXFx1QTg4MVxcdUE4QjQtXFx1QThGMVxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOEZGLVxcdUE5MDlcXHVBOTI2LVxcdUE5MkZcXHVBOTQ3LVxcdUE5NUZcXHVBOTdELVxcdUE5ODNcXHVBOUIzLVxcdUE5Q0VcXHVBOUQwLVxcdUE5REZcXHVBOUU1XFx1QTlGMC1cXHVBOUY5XFx1QTlGRlxcdUFBMjktXFx1QUEzRlxcdUFBNDNcXHVBQTRDLVxcdUFBNUZcXHVBQTc3LVxcdUFBNzlcXHVBQTdCLVxcdUFBN0RcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUMzLVxcdUFBREFcXHVBQURFXFx1QUFERlxcdUFBRUItXFx1QUFGMVxcdUFBRjUtXFx1QUIwMFxcdUFCMDdcXHVBQjA4XFx1QUIwRlxcdUFCMTBcXHVBQjE3LVxcdUFCMUZcXHVBQjI3XFx1QUIyRlxcdUFCNUJcXHVBQjZBLVxcdUFCNkZcXHVBQkUzLVxcdUFCRkZcXHVEN0E0LVxcdUQ3QUZcXHVEN0M3LVxcdUQ3Q0FcXHVEN0ZDLVxcdUQ3RkZcXHVFMDAwLVxcdUY4RkZcXHVGQTZFXFx1RkE2RlxcdUZBREEtXFx1RkFGRlxcdUZCMDctXFx1RkIxMlxcdUZCMTgtXFx1RkIxQ1xcdUZCMUVcXHVGQjI5XFx1RkIzN1xcdUZCM0RcXHVGQjNGXFx1RkI0MlxcdUZCNDVcXHVGQkIyLVxcdUZCRDJcXHVGRDNFLVxcdUZENEZcXHVGRDkwXFx1RkQ5MVxcdUZEQzgtXFx1RkRFRlxcdUZERkMtXFx1RkU2RlxcdUZFNzVcXHVGRUZELVxcdUZGMjBcXHVGRjNCLVxcdUZGNDBcXHVGRjVCLVxcdUZGNjVcXHVGRkJGLVxcdUZGQzFcXHVGRkM4XFx1RkZDOVxcdUZGRDBcXHVGRkQxXFx1RkZEOFxcdUZGRDlcXHVGRkRELVxcdUZGRkZdfFxcdUQ4MDBbXFx1REMwQ1xcdURDMjdcXHVEQzNCXFx1REMzRVxcdURDNEVcXHVEQzRGXFx1REM1RS1cXHVEQzdGXFx1RENGQi1cXHVERTdGXFx1REU5RC1cXHVERTlGXFx1REVEMS1cXHVERUZGXFx1REYyMC1cXHVERjJDXFx1REY0MVxcdURGNEEtXFx1REY0RlxcdURGNzYtXFx1REY3RlxcdURGOUVcXHVERjlGXFx1REZDNC1cXHVERkM3XFx1REZEMC1cXHVERkZGXXxcXHVEODAxW1xcdURDOUUtXFx1RENBRlxcdURDRDQtXFx1RENEN1xcdURDRkMtXFx1RENGRlxcdUREMjgtXFx1REQyRlxcdURENjQtXFx1REQ2RlxcdUREN0JcXHVERDhCXFx1REQ5M1xcdUREOTZcXHVEREEyXFx1RERCMlxcdUREQkFcXHVEREJELVxcdURERkZcXHVERjM3LVxcdURGM0ZcXHVERjU2LVxcdURGNUZcXHVERjY4LVxcdURGN0ZcXHVERjg2XFx1REZCMVxcdURGQkItXFx1REZGRl18XFx1RDgwMltcXHVEQzA2XFx1REMwN1xcdURDMDlcXHVEQzM2XFx1REMzOS1cXHVEQzNCXFx1REMzRFxcdURDM0VcXHVEQzU2LVxcdURDNUZcXHVEQzc3LVxcdURDN0ZcXHVEQzlGLVxcdURDREZcXHVEQ0YzXFx1RENGNi1cXHVEQ0ZGXFx1REQxNi1cXHVERDFGXFx1REQzQS1cXHVERDdGXFx1RERCOC1cXHVEREJEXFx1RERDMC1cXHVEREZGXFx1REUwMS1cXHVERTBGXFx1REUxNFxcdURFMThcXHVERTM2LVxcdURFNUZcXHVERTdELVxcdURFN0ZcXHVERTlELVxcdURFQkZcXHVERUM4XFx1REVFNS1cXHVERUZGXFx1REYzNi1cXHVERjNGXFx1REY1Ni1cXHVERjVGXFx1REY3My1cXHVERjdGXFx1REY5Mi1cXHVERkZGXXxcXHVEODAzW1xcdURDNDktXFx1REM3RlxcdURDQjMtXFx1RENCRlxcdURDRjMtXFx1RENGRlxcdUREMjQtXFx1REU3RlxcdURFQUEtXFx1REVBRlxcdURFQjItXFx1REVGRlxcdURGMUQtXFx1REYyNlxcdURGMjgtXFx1REYyRlxcdURGNDYtXFx1REY2RlxcdURGODItXFx1REZBRlxcdURGQzUtXFx1REZERlxcdURGRjctXFx1REZGRl18XFx1RDgwNFtcXHVEQzAwLVxcdURDMDJcXHVEQzM4LVxcdURDNzBcXHVEQzczXFx1REM3NFxcdURDNzYtXFx1REM4MlxcdURDQjAtXFx1RENDRlxcdURDRTktXFx1REQwMlxcdUREMjctXFx1REQ0M1xcdURENDVcXHVERDQ2XFx1REQ0OC1cXHVERDRGXFx1REQ3My1cXHVERDc1XFx1REQ3Ny1cXHVERDgyXFx1RERCMy1cXHVEREMwXFx1RERDNS1cXHVEREQ5XFx1REREQlxcdUREREQtXFx1RERGRlxcdURFMTJcXHVERTJDLVxcdURFM0VcXHVERTQxLVxcdURFN0ZcXHVERTg3XFx1REU4OVxcdURFOEVcXHVERTlFXFx1REVBOS1cXHVERUFGXFx1REVERi1cXHVERjA0XFx1REYwRFxcdURGMEVcXHVERjExXFx1REYxMlxcdURGMjlcXHVERjMxXFx1REYzNFxcdURGM0EtXFx1REYzQ1xcdURGM0UtXFx1REY0RlxcdURGNTEtXFx1REY1Q1xcdURGNjItXFx1REZGRl18XFx1RDgwNVtcXHVEQzM1LVxcdURDNDZcXHVEQzRCLVxcdURDNUVcXHVEQzYyLVxcdURDN0ZcXHVEQ0IwLVxcdURDQzNcXHVEQ0M2XFx1RENDOC1cXHVERDdGXFx1RERBRi1cXHVEREQ3XFx1REREQy1cXHVEREZGXFx1REUzMC1cXHVERTQzXFx1REU0NS1cXHVERTdGXFx1REVBQi1cXHVERUI3XFx1REVCOS1cXHVERUZGXFx1REYxQi1cXHVERjNGXFx1REY0Ny1cXHVERkZGXXxcXHVEODA2W1xcdURDMkMtXFx1REM5RlxcdURDRTAtXFx1RENGRVxcdUREMDdcXHVERDA4XFx1REQwQVxcdUREMEJcXHVERDE0XFx1REQxN1xcdUREMzAtXFx1REQzRVxcdURENDBcXHVERDQyLVxcdUREOUZcXHVEREE4XFx1RERBOVxcdURERDEtXFx1RERFMFxcdURERTJcXHVEREU0LVxcdURERkZcXHVERTAxLVxcdURFMEFcXHVERTMzLVxcdURFMzlcXHVERTNCLVxcdURFNEZcXHVERTUxLVxcdURFNUJcXHVERThBLVxcdURFOUNcXHVERTlFLVxcdURFQUZcXHVERUY5LVxcdURGRkZdfFxcdUQ4MDdbXFx1REMwOVxcdURDMkYtXFx1REMzRlxcdURDNDEtXFx1REM3MVxcdURDOTAtXFx1RENGRlxcdUREMDdcXHVERDBBXFx1REQzMS1cXHVERDQ1XFx1REQ0Ny1cXHVERDVGXFx1REQ2NlxcdURENjlcXHVERDhBLVxcdUREOTdcXHVERDk5LVxcdURFREZcXHVERUYzLVxcdURGMDFcXHVERjAzXFx1REYxMVxcdURGMzQtXFx1REZBRlxcdURGQjEtXFx1REZGRl18XFx1RDgwOFtcXHVERjlBLVxcdURGRkZdfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzdGXFx1REQ0NC1cXHVERkZGXXxbXFx1RDgwQVxcdUQ4MEUtXFx1RDgxMFxcdUQ4MTItXFx1RDgxOVxcdUQ4MjQtXFx1RDgyQVxcdUQ4MkRcXHVEODJFXFx1RDgzMC1cXHVEODM0XFx1RDgzNlxcdUQ4M0MtXFx1RDgzRlxcdUQ4N0NcXHVEODdEXFx1RDg3RlxcdUQ4ODktXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBCW1xcdURDMDAtXFx1REY4RlxcdURGRjEtXFx1REZGRl18XFx1RDgwRFtcXHVEQzMwLVxcdURDNDBcXHVEQzQ3LVxcdURGRkZdfFxcdUQ4MTFbXFx1REU0Ny1cXHVERkZGXXxcXHVEODFBW1xcdURFMzktXFx1REUzRlxcdURFNUYtXFx1REU2RlxcdURFQkYtXFx1REVDRlxcdURFRUUtXFx1REVGRlxcdURGMzAtXFx1REYzRlxcdURGNDQtXFx1REY2MlxcdURGNzgtXFx1REY3Q1xcdURGOTAtXFx1REZGRl18XFx1RDgxQltcXHVEQzAwLVxcdURFM0ZcXHVERTgwLVxcdURFRkZcXHVERjRCLVxcdURGNEZcXHVERjUxLVxcdURGOTJcXHVERkEwLVxcdURGREZcXHVERkUyXFx1REZFNC1cXHVERkZGXXxcXHVEODIxW1xcdURGRjgtXFx1REZGRl18XFx1RDgyM1tcXHVEQ0Q2LVxcdURDRkZcXHVERDA5LVxcdURGRkZdfFxcdUQ4MkJbXFx1REMwMC1cXHVERkVGXFx1REZGNFxcdURGRkNcXHVERkZGXXxcXHVEODJDW1xcdUREMjMtXFx1REQzMVxcdUREMzMtXFx1REQ0RlxcdURENTNcXHVERDU0XFx1REQ1Ni1cXHVERDYzXFx1REQ2OC1cXHVERDZGXFx1REVGQy1cXHVERkZGXXxcXHVEODJGW1xcdURDNkItXFx1REM2RlxcdURDN0QtXFx1REM3RlxcdURDODktXFx1REM4RlxcdURDOUEtXFx1REZGRl18XFx1RDgzNVtcXHVEQzU1XFx1REM5RFxcdURDQTBcXHVEQ0ExXFx1RENBM1xcdURDQTRcXHVEQ0E3XFx1RENBOFxcdURDQURcXHVEQ0JBXFx1RENCQ1xcdURDQzRcXHVERDA2XFx1REQwQlxcdUREMENcXHVERDE1XFx1REQxRFxcdUREM0FcXHVERDNGXFx1REQ0NVxcdURENDctXFx1REQ0OVxcdURENTFcXHVERUE2XFx1REVBN1xcdURFQzFcXHVERURCXFx1REVGQlxcdURGMTVcXHVERjM1XFx1REY0RlxcdURGNkZcXHVERjg5XFx1REZBOVxcdURGQzNcXHVERkNDLVxcdURGRkZdfFxcdUQ4MzdbXFx1REMwMC1cXHVERUZGXFx1REYxRi1cXHVERjI0XFx1REYyQi1cXHVERkZGXXxcXHVEODM4W1xcdURDMDAtXFx1REMyRlxcdURDNkUtXFx1RENGRlxcdUREMkQtXFx1REQzNlxcdUREM0UtXFx1REQ0RFxcdURENEYtXFx1REU4RlxcdURFQUUtXFx1REVCRlxcdURFRUMtXFx1REZGRl18XFx1RDgzOVtcXHVEQzAwLVxcdURDQ0ZcXHVEQ0VDLVxcdURGREZcXHVERkU3XFx1REZFQ1xcdURGRUZcXHVERkZGXXxcXHVEODNBW1xcdURDQzUtXFx1RENGRlxcdURENDQtXFx1REQ0QVxcdURENEMtXFx1REZGRl18XFx1RDgzQltcXHVEQzAwLVxcdURERkZcXHVERTA0XFx1REUyMFxcdURFMjNcXHVERTI1XFx1REUyNlxcdURFMjhcXHVERTMzXFx1REUzOFxcdURFM0FcXHVERTNDLVxcdURFNDFcXHVERTQzLVxcdURFNDZcXHVERTQ4XFx1REU0QVxcdURFNENcXHVERTUwXFx1REU1M1xcdURFNTVcXHVERTU2XFx1REU1OFxcdURFNUFcXHVERTVDXFx1REU1RVxcdURFNjBcXHVERTYzXFx1REU2NVxcdURFNjZcXHVERTZCXFx1REU3M1xcdURFNzhcXHVERTdEXFx1REU3RlxcdURFOEFcXHVERTlDLVxcdURFQTBcXHVERUE0XFx1REVBQVxcdURFQkMtXFx1REZGRl18XFx1RDg2OVtcXHVERUUwLVxcdURFRkZdfFxcdUQ4NkRbXFx1REYzQS1cXHVERjNGXXxcXHVEODZFW1xcdURDMUVcXHVEQzFGXXxcXHVEODczW1xcdURFQTItXFx1REVBRl18XFx1RDg3QVtcXHVERkUxLVxcdURGRUZdfFxcdUQ4N0JbXFx1REU1RS1cXHVERkZGXXxcXHVEODdFW1xcdURFMUUtXFx1REZGRl18XFx1RDg4NFtcXHVERjRCLVxcdURGNEZdfFxcdUQ4ODhbXFx1REZCMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkvZywgXCJcIikucmVwbGFjZShcIiBcIiwgXCItXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMTguZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMTguZigpO1xuICAgICAgfVxuICAgICAgaWYgKHZvaWQgMCA9PT0gbS5lcmFZZWFyKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0VG9QYXJ0cyBsYWNrcyByZWxhdGVkWWVhciBpbiBcIi5jb25jYXQodGhpcy5pZCwgXCIgY2FsZW5kYXIuIFRyeSBOb2RlIDE0KyBvciBtb2Rlcm4gYnJvd3NlcnMuXCIpKTtcbiAgICAgIGlmICh0aGlzLnJldmlzZUludGxFcmEpIHtcbiAgICAgICAgdmFyIF90aGlzJHJldmlzZUludGxFcmEgPSB0aGlzLnJldmlzZUludGxFcmEobSwgZSksXG4gICAgICAgICAgX3Q0NCA9IF90aGlzJHJldmlzZUludGxFcmEuZXJhLFxuICAgICAgICAgIF9yNjAgPSBfdGhpcyRyZXZpc2VJbnRsRXJhLmVyYVllYXI7XG4gICAgICAgIG0uZXJhID0gX3Q0NCwgbS5lcmFZZWFyID0gX3I2MDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tJY3VCdWdzICYmIHRoaXMuY2hlY2tJY3VCdWdzKGUpO1xuICAgICAgdmFyIGMgPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZShtLCB0LCBcImNvbnN0cmFpblwiLCAhMCk7XG4gICAgICBpZiAodm9pZCAwID09PSBjLnllYXIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTWlzc2luZyB5ZWFyIGNvbnZlcnRpbmcgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGUpKSk7XG4gICAgICBpZiAodm9pZCAwID09PSBjLm1vbnRoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1pc3NpbmcgbW9udGggY29udmVydGluZyBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoZSkpKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IGMuZGF5KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1pc3NpbmcgZGF5IGNvbnZlcnRpbmcgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGUpKSk7XG4gICAgICByZXR1cm4gdC5zZXQoYSwgYyksIFtcImNvbnN0cmFpblwiLCBcInJlamVjdFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHZhciBvID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGZ1bmM6IFwiY2FsZW5kYXJUb0lzb0RhdGVcIixcbiAgICAgICAgICB5ZWFyOiBjLnllYXIsXG4gICAgICAgICAgbW9udGg6IGMubW9udGgsXG4gICAgICAgICAgZGF5OiBjLmRheSxcbiAgICAgICAgICBvdmVyZmxvdzogcixcbiAgICAgICAgICBpZDogX3RoaXMuaWRcbiAgICAgICAgfSk7XG4gICAgICAgIHQuc2V0KG8sIGUpO1xuICAgICAgfSksIGM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRlQ2FsZW5kYXJEYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlQ2FsZW5kYXJEYXRlKGUpIHtcbiAgICAgIHZhciB0ID0gZS5lcmEsXG4gICAgICAgIHIgPSBlLm1vbnRoLFxuICAgICAgICBvID0gZS55ZWFyLFxuICAgICAgICBuID0gZS5kYXksXG4gICAgICAgIGEgPSBlLmVyYVllYXIsXG4gICAgICAgIGkgPSBlLm1vbnRoQ29kZSxcbiAgICAgICAgcyA9IGUubW9udGhFeHRyYTtcbiAgICAgIGlmICh2b2lkIDAgIT09IHMpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5leHBlY3RlZCBgbW9udGhFeHRyYWAgdmFsdWVcIik7XG4gICAgICBpZiAodm9pZCAwID09PSBvICYmIHZvaWQgMCA9PT0gYSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcInllYXIgb3IgZXJhWWVhciBpcyByZXF1aXJlZFwiKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHIgJiYgdm9pZCAwID09PSBpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwibW9udGggb3IgbW9udGhDb2RlIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNaXNzaW5nIGRheVwiKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGkpIHtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwibW9udGhDb2RlIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIF90eXBlb2YoaSkpO1xuICAgICAgICBpZiAoIS9eTShbMDFdP1xcZCkoTD8pJC8udGVzdChpKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1vbnRoQ29kZTogXCIuY29uY2F0KGkpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnN0YW50RXJhKSB7XG4gICAgICAgIGlmICh2b2lkIDAgIT09IHQgJiYgdCAhPT0gdGhpcy5jb25zdGFudEVyYSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJlcmEgbXVzdCBiZSBcIi5jb25jYXQodGhpcy5jb25zdGFudEVyYSwgXCIsIG5vdCBcIikuY29uY2F0KHQpKTtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gYSAmJiB2b2lkIDAgIT09IG8gJiYgYSAhPT0gbykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJlcmFZZWFyIFwiLmNvbmNhdChhLCBcIiBkb2VzIG5vdCBtYXRjaCB5ZWFyIFwiKS5jb25jYXQobykpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzRXJhICYmIHZvaWQgMCA9PT0gZS5lcmEgIT0gKHZvaWQgMCA9PT0gZS5lcmFZZWFyKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJwcm9wZXJ0aWVzICdlcmEnIGFuZCAnZXJhWWVhcicgbXVzdCBiZSBwcm92aWRlZCB0b2dldGhlclwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRqdXN0Q2FsZW5kYXJEYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkanVzdENhbGVuZGFyRGF0ZShlLCB0KSB7XG4gICAgICB2YXIgX3Jlc29sdmVOb25MdW5pc29sYXJNO1xuICAgICAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiY29uc3RyYWluXCI7XG4gICAgICBpZiAoXCJsdW5pc29sYXJcIiA9PT0gdGhpcy5jYWxlbmRhclR5cGUpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiT3ZlcnJpZGUgcmVxdWlyZWQgZm9yIGx1bmlzb2xhciBjYWxlbmRhcnNcIik7XG4gICAgICB2YXIgbiA9IGU7XG4gICAgICBpZiAodGhpcy52YWxpZGF0ZUNhbGVuZGFyRGF0ZShuKSwgdGhpcy5jb25zdGFudEVyYSkge1xuICAgICAgICB2YXIgX24yMSA9IG4sXG4gICAgICAgICAgX2UzOSA9IF9uMjEueWVhcixcbiAgICAgICAgICBfdDQ2ID0gX24yMS5lcmFZZWFyO1xuICAgICAgICBuID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG4pLCB7fSwge1xuICAgICAgICAgIGVyYTogdGhpcy5jb25zdGFudEVyYSxcbiAgICAgICAgICB5ZWFyOiB2b2lkIDAgIT09IF9lMzkgPyBfZTM5IDogX3Q0NixcbiAgICAgICAgICBlcmFZZWFyOiB2b2lkIDAgIT09IF90NDYgPyBfdDQ2IDogX2UzOVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gdGhpcy5tb250aHNJblllYXIobiwgdCk7XG4gICAgICB2YXIgX24yMiA9IG4sXG4gICAgICAgIGkgPSBfbjIyLm1vbnRoLFxuICAgICAgICBzID0gX24yMi5tb250aENvZGU7XG4gICAgICByZXR1cm4gKF9yZXNvbHZlTm9uTHVuaXNvbGFyTSA9IHJlc29sdmVOb25MdW5pc29sYXJNb250aChuLCByLCBhKSwgaSA9IF9yZXNvbHZlTm9uTHVuaXNvbGFyTS5tb250aCwgcyA9IF9yZXNvbHZlTm9uTHVuaXNvbGFyTS5tb250aENvZGUpLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgbiksIHt9LCB7XG4gICAgICAgIG1vbnRoOiBpLFxuICAgICAgICBtb250aENvZGU6IHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWd1bGF0ZU1vbnRoRGF5TmFpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVndWxhdGVNb250aERheU5haXZlKGUsIHQsIHIpIHtcbiAgICAgIHZhciBvID0gdGhpcy5tb250aHNJblllYXIoZSwgcik7XG4gICAgICB2YXIgbiA9IGUubW9udGgsXG4gICAgICAgIGEgPSBlLmRheTtcbiAgICAgIHJldHVybiBcInJlamVjdFwiID09PSB0ID8gKFJlamVjdFRvUmFuZ2UobiwgMSwgbyksIFJlamVjdFRvUmFuZ2UoYSwgMSwgdGhpcy5tYXhpbXVtTW9udGhMZW5ndGgoZSkpKSA6IChuID0gQ29uc3RyYWluVG9SYW5nZShuLCAxLCBvKSwgYSA9IENvbnN0cmFpblRvUmFuZ2UoYSwgMSwgdGhpcy5tYXhpbXVtTW9udGhMZW5ndGgoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGUpLCB7fSwge1xuICAgICAgICBtb250aDogblxuICAgICAgfSkpKSksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBlKSwge30sIHtcbiAgICAgICAgbW9udGg6IG4sXG4gICAgICAgIGRheTogYVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGVuZGFyVG9Jc29EYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGVuZGFyVG9Jc29EYXRlKGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiY29uc3RyYWluXCI7XG4gICAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG8gPSBlO1xuICAgICAgdmFyIG4gPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZShlLCByLCB0LCAhMSk7XG4gICAgICBuID0gdGhpcy5yZWd1bGF0ZU1vbnRoRGF5TmFpdmUobiwgdCwgcik7XG4gICAgICB2YXIgX24yMyA9IG4sXG4gICAgICAgIGEgPSBfbjIzLnllYXIsXG4gICAgICAgIGkgPSBfbjIzLm1vbnRoLFxuICAgICAgICBzID0gX24yMy5kYXksXG4gICAgICAgIGwgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZnVuYzogXCJjYWxlbmRhclRvSXNvRGF0ZVwiLFxuICAgICAgICAgIHllYXI6IGEsXG4gICAgICAgICAgbW9udGg6IGksXG4gICAgICAgICAgZGF5OiBzLFxuICAgICAgICAgIG92ZXJmbG93OiB0LFxuICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgIH0pO1xuICAgICAgdmFyIGQsXG4gICAgICAgIG0gPSByLmdldChsKTtcbiAgICAgIGlmIChtKSByZXR1cm4gbTtcbiAgICAgIGlmICh2b2lkIDAgIT09IG8ueWVhciAmJiB2b2lkIDAgIT09IG8ubW9udGggJiYgdm9pZCAwICE9PSBvLmRheSAmJiAoby55ZWFyICE9PSBuLnllYXIgfHwgby5tb250aCAhPT0gbi5tb250aCB8fCBvLmRheSAhPT0gbi5kYXkpICYmIChkID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBmdW5jOiBcImNhbGVuZGFyVG9Jc29EYXRlXCIsXG4gICAgICAgIHllYXI6IG8ueWVhcixcbiAgICAgICAgbW9udGg6IG8ubW9udGgsXG4gICAgICAgIGRheTogby5kYXksXG4gICAgICAgIG92ZXJmbG93OiB0LFxuICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgfSksIG0gPSByLmdldChkKSwgbSkpIHJldHVybiBtO1xuICAgICAgdmFyIGMgPSB0aGlzLmVzdGltYXRlSXNvRGF0ZSh7XG4gICAgICAgIHllYXI6IGEsXG4gICAgICAgIG1vbnRoOiBpLFxuICAgICAgICBkYXk6IHNcbiAgICAgIH0pO1xuICAgICAgdmFyIGNhbGN1bGF0ZVNhbWVNb250aFJlc3VsdCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVNhbWVNb250aFJlc3VsdChlKSB7XG4gICAgICAgIHZhciBvID0gX3RoaXMyLmFkZERheXNJc28oYywgZSk7XG4gICAgICAgIGlmIChuLmRheSA+IF90aGlzMi5taW5pbXVtTW9udGhMZW5ndGgobikpIHtcbiAgICAgICAgICB2YXIgX2U0MCA9IF90aGlzMi5pc29Ub0NhbGVuZGFyRGF0ZShvLCByKTtcbiAgICAgICAgICBmb3IgKDsgX2U0MC5tb250aCAhPT0gaSB8fCBfZTQwLnllYXIgIT09IGE7KSB7XG4gICAgICAgICAgICBpZiAoXCJyZWplY3RcIiA9PT0gdCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJkYXkgXCIuY29uY2F0KHMsIFwiIGRvZXMgbm90IGV4aXN0IGluIG1vbnRoIFwiKS5jb25jYXQoaSwgXCIgb2YgeWVhciBcIikuY29uY2F0KGEpKTtcbiAgICAgICAgICAgIG8gPSBfdGhpczIuYWRkRGF5c0lzbyhvLCAtMSksIF9lNDAgPSBfdGhpczIuaXNvVG9DYWxlbmRhckRhdGUobywgcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfTtcbiAgICAgIHZhciBoID0gMCxcbiAgICAgICAgdSA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoYywgciksXG4gICAgICAgIFQgPSBzaW1wbGVEYXRlRGlmZihuLCB1KTtcbiAgICAgIGlmICgwICE9PSBULnllYXJzIHx8IDAgIT09IFQubW9udGhzIHx8IDAgIT09IFQuZGF5cykge1xuICAgICAgICB2YXIgX2U0MSA9IDM2NSAqIFQueWVhcnMgKyAzMCAqIFQubW9udGhzICsgVC5kYXlzO1xuICAgICAgICBjID0gdGhpcy5hZGREYXlzSXNvKGMsIF9lNDEpLCB1ID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShjLCByKSwgVCA9IHNpbXBsZURhdGVEaWZmKG4sIHUpLCAwID09PSBULnllYXJzICYmIDAgPT09IFQubW9udGhzID8gYyA9IGNhbGN1bGF0ZVNhbWVNb250aFJlc3VsdChULmRheXMpIDogaCA9IHRoaXMuY29tcGFyZUNhbGVuZGFyRGF0ZXMobiwgdSk7XG4gICAgICB9XG4gICAgICB2YXIgcCA9IDg7XG4gICAgICBmb3IgKDsgaDspIHtcbiAgICAgICAgYyA9IHRoaXMuYWRkRGF5c0lzbyhjLCBoICogcCk7XG4gICAgICAgIHZhciBfZTQyID0gdTtcbiAgICAgICAgdSA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoYywgcik7XG4gICAgICAgIHZhciBfYTE3ID0gaDtcbiAgICAgICAgaWYgKGggPSB0aGlzLmNvbXBhcmVDYWxlbmRhckRhdGVzKG4sIHUpLCBoKSBpZiAoVCA9IHNpbXBsZURhdGVEaWZmKG4sIHUpLCAwID09PSBULnllYXJzICYmIDAgPT09IFQubW9udGhzKSBjID0gY2FsY3VsYXRlU2FtZU1vbnRoUmVzdWx0KFQuZGF5cyksIGggPSAwO2Vsc2UgaWYgKF9hMTcgJiYgaCAhPT0gX2ExNykgaWYgKHAgPiAxKSBwIC89IDI7ZWxzZSB7XG4gICAgICAgICAgaWYgKFwicmVqZWN0XCIgPT09IHQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgZmluZCBJU08gZGF0ZSBmcm9tIGNhbGVuZGFyIGRhdGU6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShfb2JqZWN0U3ByZWFkMih7fSwgbykpKSk7XG4gICAgICAgICAgdGhpcy5jb21wYXJlQ2FsZW5kYXJEYXRlcyh1LCBfZTQyKSA+IDAgJiYgKGMgPSB0aGlzLmFkZERheXNJc28oYywgLTEpKSwgaCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyLnNldChsLCBjKSwgZCAmJiByLnNldChkLCBjKSwgdm9pZCAwID09PSBuLnllYXIgfHwgdm9pZCAwID09PSBuLm1vbnRoIHx8IHZvaWQgMCA9PT0gbi5kYXkgfHwgdm9pZCAwID09PSBuLm1vbnRoQ29kZSB8fCB0aGlzLmhhc0VyYSAmJiAodm9pZCAwID09PSBuLmVyYSB8fCB2b2lkIDAgPT09IG4uZXJhWWVhcikpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5leHBlY3RlZCBtaXNzaW5nIHByb3BlcnR5XCIpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRlbXBvcmFsVG9DYWxlbmRhckRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShlLCB0KSB7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgeWVhcjogR2V0U2xvdChlLCBpKSxcbiAgICAgICAgbW9udGg6IEdldFNsb3QoZSwgcyksXG4gICAgICAgIGRheTogR2V0U2xvdChlLCBsKVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLmlzb1RvQ2FsZW5kYXJEYXRlKHIsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXJlQ2FsZW5kYXJEYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlQ2FsZW5kYXJEYXRlcyhlLCB0KSB7XG4gICAgICB2YXIgciA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhlLCBbXCJkYXlcIiwgXCJtb250aFwiLCBcInllYXJcIl0sIFtcImRheVwiLCBcIm1vbnRoXCIsIFwieWVhclwiXSksXG4gICAgICAgIG8gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModCwgW1wiZGF5XCIsIFwibW9udGhcIiwgXCJ5ZWFyXCJdLCBbXCJkYXlcIiwgXCJtb250aFwiLCBcInllYXJcIl0pO1xuICAgICAgcmV0dXJuIHIueWVhciAhPT0gby55ZWFyID8gQ29tcGFyaXNvblJlc3VsdChyLnllYXIgLSBvLnllYXIpIDogci5tb250aCAhPT0gby5tb250aCA/IENvbXBhcmlzb25SZXN1bHQoci5tb250aCAtIG8ubW9udGgpIDogci5kYXkgIT09IG8uZGF5ID8gQ29tcGFyaXNvblJlc3VsdChyLmRheSAtIG8uZGF5KSA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZ3VsYXRlRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWd1bGF0ZURhdGUoZSkge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiY29uc3RyYWluXCI7XG4gICAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG8gPSB0aGlzLmNhbGVuZGFyVG9Jc29EYXRlKGUsIHQsIHIpO1xuICAgICAgcmV0dXJuIHRoaXMuaXNvVG9DYWxlbmRhckRhdGUobywgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZERheXNJc29cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRGF5c0lzbyhlLCB0KSB7XG4gICAgICByZXR1cm4gQWRkSVNPRGF0ZShlLnllYXIsIGUubW9udGgsIGUuZGF5LCAwLCAwLCAwLCB0LCBcImNvbnN0cmFpblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRGF5c0NhbGVuZGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZERheXNDYWxlbmRhcihlLCB0LCByKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUoZSwgXCJjb25zdHJhaW5cIiwgciksXG4gICAgICAgIG4gPSB0aGlzLmFkZERheXNJc28obywgdCk7XG4gICAgICByZXR1cm4gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShuLCByKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTW9udGhzQ2FsZW5kYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTW9udGhzQ2FsZW5kYXIoZSwgdCwgciwgbykge1xuICAgICAgdmFyIG4gPSBlO1xuICAgICAgdmFyIF9uMjQgPSBuLFxuICAgICAgICBhID0gX24yNC5kYXk7XG4gICAgICBmb3IgKHZhciBfZTQzID0gMCwgX3I2MSA9IEl0KHQpOyBfZTQzIDwgX3I2MTsgX2U0MysrKSB7XG4gICAgICAgIHZhciBfbjI1ID0gbixcbiAgICAgICAgICBfZTQ0ID0gX24yNS5tb250aCxcbiAgICAgICAgICBfcjYyID0gbixcbiAgICAgICAgICBfaTE4ID0gdCA8IDAgPyAtTWF0aC5tYXgoYSwgdGhpcy5kYXlzSW5QcmV2aW91c01vbnRoKG4sIG8pKSA6IHRoaXMuZGF5c0luTW9udGgobiwgbyksXG4gICAgICAgICAgX3M3ID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZShuLCBcImNvbnN0cmFpblwiLCBvKTtcbiAgICAgICAgdmFyIF9sNyA9IHRoaXMuYWRkRGF5c0lzbyhfczcsIF9pMTgpO1xuICAgICAgICBpZiAobiA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoX2w3LCBvKSwgdCA+IDApIHtcbiAgICAgICAgICB2YXIgX3Q0NyA9IHRoaXMubW9udGhzSW5ZZWFyKF9yNjIsIG8pO1xuICAgICAgICAgIGZvciAoOyBuLm1vbnRoIC0gMSAhPSBfZTQ0ICUgX3Q0NzspIF9sNyA9IHRoaXMuYWRkRGF5c0lzbyhfbDcsIC0xKSwgbiA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoX2w3LCBvKTtcbiAgICAgICAgfVxuICAgICAgICBuLmRheSAhPT0gYSAmJiAobiA9IHRoaXMucmVndWxhdGVEYXRlKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBuKSwge30sIHtcbiAgICAgICAgICBkYXk6IGFcbiAgICAgICAgfSksIFwiY29uc3RyYWluXCIsIG8pKTtcbiAgICAgIH1cbiAgICAgIGlmIChcInJlamVjdFwiID09PSByICYmIG4uZGF5ICE9PSBhKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRheSBcIi5jb25jYXQoYSwgXCIgZG9lcyBub3QgZXhpc3QgaW4gcmVzdWx0aW5nIGNhbGVuZGFyIG1vbnRoXCIpKTtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRDYWxlbmRhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDYWxlbmRhcihlLCBfcmVmOSwgYSwgaSkge1xuICAgICAgdmFyIF9yZWY5JHllYXJzID0gX3JlZjkueWVhcnMsXG4gICAgICAgIHQgPSBfcmVmOSR5ZWFycyA9PT0gdm9pZCAwID8gMCA6IF9yZWY5JHllYXJzLFxuICAgICAgICBfcmVmOSRtb250aHMgPSBfcmVmOS5tb250aHMsXG4gICAgICAgIHIgPSBfcmVmOSRtb250aHMgPT09IHZvaWQgMCA/IDAgOiBfcmVmOSRtb250aHMsXG4gICAgICAgIF9yZWY5JHdlZWtzID0gX3JlZjkud2Vla3MsXG4gICAgICAgIG8gPSBfcmVmOSR3ZWVrcyA9PT0gdm9pZCAwID8gMCA6IF9yZWY5JHdlZWtzLFxuICAgICAgICBfcmVmOSRkYXlzID0gX3JlZjkuZGF5cyxcbiAgICAgICAgbiA9IF9yZWY5JGRheXMgPT09IHZvaWQgMCA/IDAgOiBfcmVmOSRkYXlzO1xuICAgICAgdmFyIHMgPSBlLnllYXIsXG4gICAgICAgIGwgPSBlLmRheSxcbiAgICAgICAgZCA9IGUubW9udGhDb2RlLFxuICAgICAgICBtID0gdGhpcy5hZGp1c3RDYWxlbmRhckRhdGUoe1xuICAgICAgICAgIHllYXI6IHMgKyB0LFxuICAgICAgICAgIG1vbnRoQ29kZTogZCxcbiAgICAgICAgICBkYXk6IGxcbiAgICAgICAgfSwgaSksXG4gICAgICAgIGMgPSB0aGlzLmFkZE1vbnRoc0NhbGVuZGFyKG0sIHIsIGEsIGkpLFxuICAgICAgICBoID0gbiArIDcgKiBvO1xuICAgICAgcmV0dXJuIHRoaXMuYWRkRGF5c0NhbGVuZGFyKGMsIGgsIGkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnRpbENhbGVuZGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVudGlsQ2FsZW5kYXIoZSwgdCwgciwgbykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICBhID0gMCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIHMgPSAwO1xuICAgICAgc3dpdGNoIChyKSB7XG4gICAgICAgIGNhc2UgXCJkYXlcIjpcbiAgICAgICAgICBuID0gdGhpcy5jYWxlbmRhckRheXNVbnRpbChlLCB0LCBvKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndlZWtcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3I2MyA9IHRoaXMuY2FsZW5kYXJEYXlzVW50aWwoZSwgdCwgbyk7XG4gICAgICAgICAgICBuID0gX3I2MyAlIDcsIGEgPSAoX3I2MyAtIG4pIC8gNztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgICAgIGNhc2UgXCJ5ZWFyXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9hMTggPSB0aGlzLmNvbXBhcmVDYWxlbmRhckRhdGVzKHQsIGUpO1xuICAgICAgICAgICAgaWYgKCFfYTE4KSByZXR1cm4ge1xuICAgICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgICAgbW9udGhzOiAwLFxuICAgICAgICAgICAgICB3ZWVrczogMCxcbiAgICAgICAgICAgICAgZGF5czogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfbDggPSB0LnllYXIgLSBlLnllYXIsXG4gICAgICAgICAgICAgIF9kMTAgPSB0LmRheSAtIGUuZGF5O1xuICAgICAgICAgICAgaWYgKFwieWVhclwiID09PSByICYmIF9sOCkge1xuICAgICAgICAgICAgICB2YXIgX3I2NCA9IDA7XG4gICAgICAgICAgICAgIHQubW9udGhDb2RlID4gZS5tb250aENvZGUgJiYgKF9yNjQgPSAxKSwgdC5tb250aENvZGUgPCBlLm1vbnRoQ29kZSAmJiAoX3I2NCA9IC0xKSwgX3I2NCB8fCAoX3I2NCA9IE1hdGguc2lnbihfZDEwKSk7XG4gICAgICAgICAgICAgIHMgPSBfcjY0ICogX2ExOCA8IDAgPyBfbDggLSBfYTE4IDogX2w4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9tOSxcbiAgICAgICAgICAgICAgX2M1ID0gcyA/IHRoaXMuYWRkQ2FsZW5kYXIoZSwge1xuICAgICAgICAgICAgICAgIHllYXJzOiBzXG4gICAgICAgICAgICAgIH0sIFwiY29uc3RyYWluXCIsIG8pIDogZTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgaSArPSBfYTE4LCBfbTkgPSBfYzUsIF9jNSA9IHRoaXMuYWRkTW9udGhzQ2FsZW5kYXIoX205LCBfYTE4LCBcImNvbnN0cmFpblwiLCBvKSwgX2M1LmRheSAhPT0gZS5kYXkgJiYgKF9jNSA9IHRoaXMucmVndWxhdGVEYXRlKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfYzUpLCB7fSwge1xuICAgICAgICAgICAgICAgIGRheTogZS5kYXlcbiAgICAgICAgICAgICAgfSksIFwiY29uc3RyYWluXCIsIG8pKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuY29tcGFyZUNhbGVuZGFyRGF0ZXModCwgX2M1KSAqIF9hMTggPj0gMCk7XG4gICAgICAgICAgICBpIC09IF9hMTg7XG4gICAgICAgICAgICBuID0gdGhpcy5jYWxlbmRhckRheXNVbnRpbChfbTksIHQsIG8pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IHMsXG4gICAgICAgIG1vbnRoczogaSxcbiAgICAgICAgd2Vla3M6IGEsXG4gICAgICAgIGRheXM6IG5cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJbk1vbnRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRheXNJbk1vbnRoKGUsIHQpIHtcbiAgICAgIHZhciByID0gZS5kYXksXG4gICAgICAgIG8gPSB0aGlzLm1heGltdW1Nb250aExlbmd0aChlKSxcbiAgICAgICAgbiA9IHRoaXMubWluaW11bU1vbnRoTGVuZ3RoKGUpO1xuICAgICAgaWYgKG4gPT09IG8pIHJldHVybiBuO1xuICAgICAgdmFyIGEgPSByIDw9IG8gLSBuID8gbyA6IG4sXG4gICAgICAgIGkgPSB0aGlzLmNhbGVuZGFyVG9Jc29EYXRlKGUsIFwiY29uc3RyYWluXCIsIHQpLFxuICAgICAgICBzID0gdGhpcy5hZGREYXlzSXNvKGksIGEpLFxuICAgICAgICBsID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShzLCB0KSxcbiAgICAgICAgZCA9IHRoaXMuYWRkRGF5c0lzbyhzLCAtbC5kYXkpO1xuICAgICAgcmV0dXJuIHRoaXMuaXNvVG9DYWxlbmRhckRhdGUoZCwgdCkuZGF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlzSW5QcmV2aW91c01vbnRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRheXNJblByZXZpb3VzTW9udGgoZSwgdCkge1xuICAgICAgdmFyIHIgPSBlLmRheSxcbiAgICAgICAgbyA9IGUubW9udGgsXG4gICAgICAgIG4gPSBlLnllYXI7XG4gICAgICB2YXIgYSA9IHtcbiAgICAgICAgeWVhcjogbyA+IDEgPyBuIDogbiAtIDEsXG4gICAgICAgIG1vbnRoOiBvLFxuICAgICAgICBkYXk6IDFcbiAgICAgIH07XG4gICAgICB2YXIgaSA9IG8gPiAxID8gbyAtIDEgOiB0aGlzLm1vbnRoc0luWWVhcihhLCB0KTtcbiAgICAgIGEgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYSksIHt9LCB7XG4gICAgICAgIG1vbnRoOiBpXG4gICAgICB9KTtcbiAgICAgIHZhciBzID0gdGhpcy5taW5pbXVtTW9udGhMZW5ndGgoYSksXG4gICAgICAgIGwgPSB0aGlzLm1heGltdW1Nb250aExlbmd0aChhKTtcbiAgICAgIGlmIChzID09PSBsKSByZXR1cm4gbDtcbiAgICAgIHZhciBkID0gdGhpcy5jYWxlbmRhclRvSXNvRGF0ZShlLCBcImNvbnN0cmFpblwiLCB0KSxcbiAgICAgICAgbSA9IHRoaXMuYWRkRGF5c0lzbyhkLCAtcik7XG4gICAgICByZXR1cm4gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShtLCB0KS5kYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0T2ZDYWxlbmRhclllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRPZkNhbGVuZGFyWWVhcihlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyOiBlLnllYXIsXG4gICAgICAgIG1vbnRoOiAxLFxuICAgICAgICBtb250aENvZGU6IFwiTTAxXCIsXG4gICAgICAgIGRheTogMVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRPZkNhbGVuZGFyTW9udGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRPZkNhbGVuZGFyTW9udGgoZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogZS55ZWFyLFxuICAgICAgICBtb250aDogZS5tb250aCxcbiAgICAgICAgZGF5OiAxXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxlbmRhckRheXNVbnRpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxlbmRhckRheXNVbnRpbChlLCB0LCByKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUoZSwgXCJjb25zdHJhaW5cIiwgciksXG4gICAgICAgIG4gPSB0aGlzLmNhbGVuZGFyVG9Jc29EYXRlKHQsIFwiY29uc3RyYWluXCIsIHIpO1xuICAgICAgcmV0dXJuIHRoaXMuaXNvRGF5c1VudGlsKG8sIG4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc29EYXlzVW50aWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNvRGF5c1VudGlsKGUsIHQpIHtcbiAgICAgIHJldHVybiBEaWZmZXJlbmNlSVNPRGF0ZShlLnllYXIsIGUubW9udGgsIGUuZGF5LCB0LnllYXIsIHQubW9udGgsIHQuZGF5LCBcImRheVwiKS5kYXlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aERheUZyb21GaWVsZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9udGhEYXlGcm9tRmllbGRzKGUsIHQsIHIpIHtcbiAgICAgIHZhciBvLFxuICAgICAgICBuLFxuICAgICAgICBhLFxuICAgICAgICBpLFxuICAgICAgICBzLFxuICAgICAgICBsID0gZS5tb250aENvZGUsXG4gICAgICAgIGQgPSBlLmRheTtcbiAgICAgIGlmICh2b2lkIDAgPT09IGwpIHtcbiAgICAgICAgdmFyIF9vMzcgPSBlLnllYXIsXG4gICAgICAgICAgX24yNiA9IGUuZXJhLFxuICAgICAgICAgIF9hMTkgPSBlLmVyYVllYXI7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IF9vMzcgJiYgKHZvaWQgMCA9PT0gX24yNiB8fCB2b2lkIDAgPT09IF9hMTkpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwid2hlbiBgbW9udGhDb2RlYCBpcyBvbWl0dGVkLCBgeWVhcmAgKG9yIGBlcmFgIGFuZCBgZXJhWWVhcmApIGFuZCBgbW9udGhgIGFyZSByZXF1aXJlZFwiKTtcbiAgICAgICAgdmFyIF90aGlzJGlzb1RvQ2FsZW5kYXJEYSA9IHRoaXMuaXNvVG9DYWxlbmRhckRhdGUodGhpcy5jYWxlbmRhclRvSXNvRGF0ZShlLCB0LCByKSwgcik7XG4gICAgICAgIGwgPSBfdGhpcyRpc29Ub0NhbGVuZGFyRGEubW9udGhDb2RlO1xuICAgICAgICBkID0gX3RoaXMkaXNvVG9DYWxlbmRhckRhLmRheTtcbiAgICAgIH1cbiAgICAgIHZhciBtID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZSh7XG4gICAgICAgICAgeWVhcjogMTk3MixcbiAgICAgICAgICBtb250aDogMTIsXG4gICAgICAgICAgZGF5OiAzMVxuICAgICAgICB9LCByKSxcbiAgICAgICAgYyA9IG0ubW9udGhDb2RlID4gbCB8fCBtLm1vbnRoQ29kZSA9PT0gbCAmJiBtLmRheSA+PSBkID8gbS55ZWFyIDogbS55ZWFyIC0gMTtcbiAgICAgIGZvciAodmFyIF9lNDUgPSAwOyBfZTQ1IDwgMTAwOyBfZTQ1KyspIHtcbiAgICAgICAgdmFyIF9tMTAgPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZSh7XG4gICAgICAgICAgICBkYXk6IGQsXG4gICAgICAgICAgICBtb250aENvZGU6IGwsXG4gICAgICAgICAgICB5ZWFyOiBjIC0gX2U0NVxuICAgICAgICAgIH0sIHIpLFxuICAgICAgICAgIF9oMyA9IHRoaXMuY2FsZW5kYXJUb0lzb0RhdGUoX20xMCwgXCJjb25zdHJhaW5cIiwgciksXG4gICAgICAgICAgX3UyID0gdGhpcy5pc29Ub0NhbGVuZGFyRGF0ZShfaDMsIHIpO1xuICAgICAgICBpZiAoKG8gPSBfaDMueWVhciwgbiA9IF9oMy5tb250aCwgYSA9IF9oMy5kYXkpLCBfdTIubW9udGhDb2RlID09PSBsICYmIF91Mi5kYXkgPT09IGQpIHJldHVybiB7XG4gICAgICAgICAgbW9udGg6IG4sXG4gICAgICAgICAgZGF5OiBhLFxuICAgICAgICAgIHllYXI6IG9cbiAgICAgICAgfTtcbiAgICAgICAgXCJjb25zdHJhaW5cIiA9PT0gdCAmJiAodm9pZCAwID09PSBpIHx8IF91Mi5tb250aENvZGUgPT09IGkubW9udGhDb2RlICYmIF91Mi5kYXkgPiBpLmRheSkgJiYgKGkgPSBfdTIsIHMgPSBfaDMpO1xuICAgICAgfVxuICAgICAgaWYgKFwiY29uc3RyYWluXCIgPT09IHQgJiYgdm9pZCAwICE9PSBzKSByZXR1cm4gcztcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gcmVjZW50IFwiLmNvbmNhdCh0aGlzLmlkLCBcIiB5ZWFyIHdpdGggbW9udGhDb2RlIFwiKS5jb25jYXQobCwgXCIgYW5kIGRheSBcIikuY29uY2F0KGQpKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhlbHBlckJhc2U7XG59KCk7XG52YXIgSGVicmV3SGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSGVscGVyQmFzZSkge1xuICBfaW5oZXJpdHMoSGVicmV3SGVscGVyLCBfSGVscGVyQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSGVicmV3SGVscGVyKTtcbiAgZnVuY3Rpb24gSGVicmV3SGVscGVyKCkge1xuICAgIHZhciBfdGhpczM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlYnJld0hlbHBlcik7XG4gICAgX3RoaXMzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzMy5pZCA9IFwiaGVicmV3XCIsIF90aGlzMy5jYWxlbmRhclR5cGUgPSBcImx1bmlzb2xhclwiLCBfdGhpczMubW9udGhzID0ge1xuICAgICAgVGlzaHJpOiB7XG4gICAgICAgIGxlYXA6IDEsXG4gICAgICAgIHJlZ3VsYXI6IDEsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMDFcIixcbiAgICAgICAgZGF5czogMzBcbiAgICAgIH0sXG4gICAgICBIZXNodmFuOiB7XG4gICAgICAgIGxlYXA6IDIsXG4gICAgICAgIHJlZ3VsYXI6IDIsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMDJcIixcbiAgICAgICAgZGF5czoge1xuICAgICAgICAgIG1pbjogMjksXG4gICAgICAgICAgbWF4OiAzMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgS2lzbGV2OiB7XG4gICAgICAgIGxlYXA6IDMsXG4gICAgICAgIHJlZ3VsYXI6IDMsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMDNcIixcbiAgICAgICAgZGF5czoge1xuICAgICAgICAgIG1pbjogMjksXG4gICAgICAgICAgbWF4OiAzMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgVGV2ZXQ6IHtcbiAgICAgICAgbGVhcDogNCxcbiAgICAgICAgcmVndWxhcjogNCxcbiAgICAgICAgbW9udGhDb2RlOiBcIk0wNFwiLFxuICAgICAgICBkYXlzOiAyOVxuICAgICAgfSxcbiAgICAgIFNoZXZhdDoge1xuICAgICAgICBsZWFwOiA1LFxuICAgICAgICByZWd1bGFyOiA1LFxuICAgICAgICBtb250aENvZGU6IFwiTTA1XCIsXG4gICAgICAgIGRheXM6IDMwXG4gICAgICB9LFxuICAgICAgQWRhcjoge1xuICAgICAgICBsZWFwOiB2b2lkIDAsXG4gICAgICAgIHJlZ3VsYXI6IDYsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMDZcIixcbiAgICAgICAgZGF5czogMjlcbiAgICAgIH0sXG4gICAgICBcIkFkYXIgSVwiOiB7XG4gICAgICAgIGxlYXA6IDYsXG4gICAgICAgIHJlZ3VsYXI6IHZvaWQgMCxcbiAgICAgICAgbW9udGhDb2RlOiBcIk0wNUxcIixcbiAgICAgICAgZGF5czogMzBcbiAgICAgIH0sXG4gICAgICBcIkFkYXIgSUlcIjoge1xuICAgICAgICBsZWFwOiA3LFxuICAgICAgICByZWd1bGFyOiB2b2lkIDAsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMDZcIixcbiAgICAgICAgZGF5czogMjlcbiAgICAgIH0sXG4gICAgICBOaXNhbjoge1xuICAgICAgICBsZWFwOiA4LFxuICAgICAgICByZWd1bGFyOiA3LFxuICAgICAgICBtb250aENvZGU6IFwiTTA3XCIsXG4gICAgICAgIGRheXM6IDMwXG4gICAgICB9LFxuICAgICAgSXlhcjoge1xuICAgICAgICBsZWFwOiA5LFxuICAgICAgICByZWd1bGFyOiA4LFxuICAgICAgICBtb250aENvZGU6IFwiTTA4XCIsXG4gICAgICAgIGRheXM6IDI5XG4gICAgICB9LFxuICAgICAgU2l2YW46IHtcbiAgICAgICAgbGVhcDogMTAsXG4gICAgICAgIHJlZ3VsYXI6IDksXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMDlcIixcbiAgICAgICAgZGF5czogMzBcbiAgICAgIH0sXG4gICAgICBUYW11ejoge1xuICAgICAgICBsZWFwOiAxMSxcbiAgICAgICAgcmVndWxhcjogMTAsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMTBcIixcbiAgICAgICAgZGF5czogMjlcbiAgICAgIH0sXG4gICAgICBBdjoge1xuICAgICAgICBsZWFwOiAxMixcbiAgICAgICAgcmVndWxhcjogMTEsXG4gICAgICAgIG1vbnRoQ29kZTogXCJNMTFcIixcbiAgICAgICAgZGF5czogMzBcbiAgICAgIH0sXG4gICAgICBFbHVsOiB7XG4gICAgICAgIGxlYXA6IDEzLFxuICAgICAgICByZWd1bGFyOiAxMixcbiAgICAgICAgbW9udGhDb2RlOiBcIk0xMlwiLFxuICAgICAgICBkYXlzOiAyOVxuICAgICAgfVxuICAgIH0sIF90aGlzMy5oYXNFcmEgPSAhMTtcbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhIZWJyZXdIZWxwZXIsIFt7XG4gICAga2V5OiBcImluTGVhcFllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5MZWFwWWVhcihlKSB7XG4gICAgICB2YXIgdCA9IGUueWVhcjtcbiAgICAgIHJldHVybiAoNyAqIHQgKyAxKSAlIDE5IDwgNztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhzSW5ZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vbnRoc0luWWVhcihlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbkxlYXBZZWFyKGUpID8gMTMgOiAxMjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWluaW11bU1vbnRoTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pbmltdW1Nb250aExlbmd0aChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5taW5NYXhNb250aExlbmd0aChlLCBcIm1pblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF4aW11bU1vbnRoTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heGltdW1Nb250aExlbmd0aChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5taW5NYXhNb250aExlbmd0aChlLCBcIm1heFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWluTWF4TW9udGhMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluTWF4TW9udGhMZW5ndGgoZSwgdCkge1xuICAgICAgdmFyIHIgPSBlLm1vbnRoLFxuICAgICAgICBvID0gZS55ZWFyLFxuICAgICAgICBuID0gdGhpcy5nZXRNb250aENvZGUobywgciksXG4gICAgICAgIGEgPSB3dCh0aGlzLm1vbnRocykuZmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlWzFdLm1vbnRoQ29kZSA9PT0gbjtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodm9pZCAwID09PSBhKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInVubWF0Y2hlZCBIZWJyZXcgbW9udGg6IFwiLmNvbmNhdChyKSk7XG4gICAgICB2YXIgaSA9IGFbMV0uZGF5cztcbiAgICAgIHJldHVybiBcIm51bWJlclwiID09IHR5cGVvZiBpID8gaSA6IGlbdF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVzdGltYXRlSXNvRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc3RpbWF0ZUlzb0RhdGUoZSkge1xuICAgICAgdmFyIHQgPSBlLnllYXI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyOiB0IC0gMzc2MCxcbiAgICAgICAgbW9udGg6IDEsXG4gICAgICAgIGRheTogMVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TW9udGhDb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vbnRoQ29kZShlLCB0KSB7XG4gICAgICByZXR1cm4gdGhpcy5pbkxlYXBZZWFyKHtcbiAgICAgICAgeWVhcjogZVxuICAgICAgfSkgPyA2ID09PSB0ID8gYnVpbGRNb250aENvZGUoNSwgITApIDogYnVpbGRNb250aENvZGUodCA8IDYgPyB0IDogdCAtIDEpIDogYnVpbGRNb250aENvZGUodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkanVzdENhbGVuZGFyRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RDYWxlbmRhckRhdGUoZSwgdCkge1xuICAgICAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiY29uc3RyYWluXCI7XG4gICAgICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogITE7XG4gICAgICB2YXIgbiA9IGUueWVhcixcbiAgICAgICAgYSA9IGUuZXJhWWVhcixcbiAgICAgICAgaSA9IGUubW9udGgsXG4gICAgICAgIHMgPSBlLm1vbnRoQ29kZSxcbiAgICAgICAgbCA9IGUuZGF5LFxuICAgICAgICBkID0gZS5tb250aEV4dHJhO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gbiAmJiB2b2lkIDAgIT09IGEgJiYgKG4gPSBhKSwgdm9pZCAwID09PSBhICYmIHZvaWQgMCAhPT0gbiAmJiAoYSA9IG4pLCBvKSB7XG4gICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgdmFyIF9lNDYgPSB0aGlzLm1vbnRoc1tkXTtcbiAgICAgICAgICBpZiAoIV9lNDYpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5yZWNvZ25pemVkIG1vbnRoIGZyb20gZm9ybWF0VG9QYXJ0czogXCIuY29uY2F0KGQpKTtcbiAgICAgICAgICBpID0gdGhpcy5pbkxlYXBZZWFyKHtcbiAgICAgICAgICAgIHllYXI6IG5cbiAgICAgICAgICB9KSA/IF9lNDYubGVhcCA6IF9lNDYucmVndWxhcjtcbiAgICAgICAgfVxuICAgICAgICBzID0gdGhpcy5nZXRNb250aENvZGUobiwgaSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeWVhcjogbixcbiAgICAgICAgICBtb250aDogaSxcbiAgICAgICAgICBkYXk6IGwsXG4gICAgICAgICAgZXJhOiB2b2lkIDAsXG4gICAgICAgICAgZXJhWWVhcjogYSxcbiAgICAgICAgICBtb250aENvZGU6IHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnZhbGlkYXRlQ2FsZW5kYXJEYXRlKGUpLCB2b2lkIDAgPT09IGkpIHtcbiAgICAgICAgaWYgKHMuZW5kc1dpdGgoXCJMXCIpKSB7XG4gICAgICAgICAgaWYgKFwiTTA1TFwiICE9PSBzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkhlYnJldyBsZWFwIG1vbnRoIG11c3QgaGF2ZSBtb250aENvZGUgTTA1TCwgbm90IFwiLmNvbmNhdChzKSk7XG4gICAgICAgICAgaWYgKGkgPSA2LCAhdGhpcy5pbkxlYXBZZWFyKHtcbiAgICAgICAgICAgIHllYXI6IG5cbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgaWYgKFwicmVqZWN0XCIgPT09IHIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSGVicmV3IG1vbnRoQ29kZSBNMDVMIGlzIGludmFsaWQgaW4geWVhciBcIi5jb25jYXQobiwgXCIgd2hpY2ggaXMgbm90IGEgbGVhcCB5ZWFyXCIpKTtcbiAgICAgICAgICAgIGkgPSA2LCBzID0gXCJNMDZcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSA9IG1vbnRoQ29kZU51bWJlclBhcnQocyksIHRoaXMuaW5MZWFwWWVhcih7XG4gICAgICAgICAgICB5ZWFyOiBuXG4gICAgICAgICAgfSkgJiYgaSA+PSA2ICYmIGkrKztcbiAgICAgICAgICB2YXIgX2U0NyA9IHRoaXMubW9udGhzSW5ZZWFyKHtcbiAgICAgICAgICAgIHllYXI6IG5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaSA8IDEgfHwgaSA+IF9lNDcpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtb250aENvZGU6IFwiLmNvbmNhdChzKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXCJyZWplY3RcIiA9PT0gciA/IChSZWplY3RUb1JhbmdlKGksIDEsIHRoaXMubW9udGhzSW5ZZWFyKHtcbiAgICAgICAgeWVhcjogblxuICAgICAgfSkpLCBSZWplY3RUb1JhbmdlKGwsIDEsIHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKHtcbiAgICAgICAgeWVhcjogbixcbiAgICAgICAgbW9udGg6IGlcbiAgICAgIH0pKSkgOiAoaSA9IENvbnN0cmFpblRvUmFuZ2UoaSwgMSwgdGhpcy5tb250aHNJblllYXIoe1xuICAgICAgICB5ZWFyOiBuXG4gICAgICB9KSksIGwgPSBDb25zdHJhaW5Ub1JhbmdlKGwsIDEsIHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKHtcbiAgICAgICAgeWVhcjogbixcbiAgICAgICAgbW9udGg6IGlcbiAgICAgIH0pKSksIHZvaWQgMCA9PT0gcykgcyA9IHRoaXMuZ2V0TW9udGhDb2RlKG4sIGkpO2Vsc2Uge1xuICAgICAgICBpZiAodGhpcy5nZXRNb250aENvZGUobiwgaSkgIT09IHMpIHRocm93IG5ldyBSYW5nZUVycm9yKFwibW9udGhDb2RlIFwiLmNvbmNhdChzLCBcIiBkb2Vzbid0IGNvcnJlc3BvbmQgdG8gbW9udGggXCIpLmNvbmNhdChpLCBcIiBpbiBIZWJyZXcgeWVhciBcIikuY29uY2F0KG4pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZSksIHt9LCB7XG4gICAgICAgIGRheTogbCxcbiAgICAgICAgbW9udGg6IGksXG4gICAgICAgIG1vbnRoQ29kZTogcyxcbiAgICAgICAgeWVhcjogbixcbiAgICAgICAgZXJhWWVhcjogYVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBIZWJyZXdIZWxwZXI7XG59KEhlbHBlckJhc2UpO1xudmFyIElzbGFtaWNCYXNlSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSGVscGVyQmFzZTIpIHtcbiAgX2luaGVyaXRzKElzbGFtaWNCYXNlSGVscGVyLCBfSGVscGVyQmFzZTIpO1xuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihJc2xhbWljQmFzZUhlbHBlcik7XG4gIGZ1bmN0aW9uIElzbGFtaWNCYXNlSGVscGVyKCkge1xuICAgIHZhciBfdGhpczQ7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElzbGFtaWNCYXNlSGVscGVyKTtcbiAgICBfdGhpczQgPSBfc3VwZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzNC5jYWxlbmRhclR5cGUgPSBcImx1bmFyXCIsIF90aGlzNC5EQVlTX1BFUl9JU0xBTUlDX1lFQVIgPSAzNTQgKyAxMSAvIDMwLCBfdGhpczQuREFZU19QRVJfSVNPX1lFQVIgPSAzNjUuMjQyNSwgX3RoaXM0LmNvbnN0YW50RXJhID0gXCJhaFwiO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKElzbGFtaWNCYXNlSGVscGVyLCBbe1xuICAgIGtleTogXCJpbkxlYXBZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluTGVhcFllYXIoZSwgdCkge1xuICAgICAgcmV0dXJuIDMwID09PSB0aGlzLmRheXNJbk1vbnRoKHtcbiAgICAgICAgeWVhcjogZS55ZWFyLFxuICAgICAgICBtb250aDogMTIsXG4gICAgICAgIGRheTogMVxuICAgICAgfSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoc0luWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aHNJblllYXIoKSB7XG4gICAgICByZXR1cm4gMTI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pbmltdW1Nb250aExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW5pbXVtTW9udGhMZW5ndGgoKSB7XG4gICAgICByZXR1cm4gMjk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heGltdW1Nb250aExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXhpbXVtTW9udGhMZW5ndGgoKSB7XG4gICAgICByZXR1cm4gMzA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVzdGltYXRlSXNvRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc3RpbWF0ZUlzb0RhdGUoZSkge1xuICAgICAgdmFyIF90aGlzJGFkanVzdENhbGVuZGFyRCA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKGUpLFxuICAgICAgICB0ID0gX3RoaXMkYWRqdXN0Q2FsZW5kYXJELnllYXI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyOiBTdCh0ICogdGhpcy5EQVlTX1BFUl9JU0xBTUlDX1lFQVIgLyB0aGlzLkRBWVNfUEVSX0lTT19ZRUFSKSArIDYyMixcbiAgICAgICAgbW9udGg6IDEsXG4gICAgICAgIGRheTogMVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIElzbGFtaWNCYXNlSGVscGVyO1xufShIZWxwZXJCYXNlKTtcbnZhciBJc2xhbWljSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSXNsYW1pY0Jhc2VIZWxwZXIpIHtcbiAgX2luaGVyaXRzKElzbGFtaWNIZWxwZXIsIF9Jc2xhbWljQmFzZUhlbHBlcik7XG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKElzbGFtaWNIZWxwZXIpO1xuICBmdW5jdGlvbiBJc2xhbWljSGVscGVyKCkge1xuICAgIHZhciBfdGhpczU7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElzbGFtaWNIZWxwZXIpO1xuICAgIF90aGlzNSA9IF9zdXBlcjMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgX3RoaXM1LmlkID0gXCJpc2xhbWljXCI7XG4gICAgcmV0dXJuIF90aGlzNTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKElzbGFtaWNIZWxwZXIpO1xufShJc2xhbWljQmFzZUhlbHBlcik7XG52YXIgSXNsYW1pY1VtYWxxdXJhSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSXNsYW1pY0Jhc2VIZWxwZXIyKSB7XG4gIF9pbmhlcml0cyhJc2xhbWljVW1hbHF1cmFIZWxwZXIsIF9Jc2xhbWljQmFzZUhlbHBlcjIpO1xuICB2YXIgX3N1cGVyNCA9IF9jcmVhdGVTdXBlcihJc2xhbWljVW1hbHF1cmFIZWxwZXIpO1xuICBmdW5jdGlvbiBJc2xhbWljVW1hbHF1cmFIZWxwZXIoKSB7XG4gICAgdmFyIF90aGlzNjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSXNsYW1pY1VtYWxxdXJhSGVscGVyKTtcbiAgICBfdGhpczYgPSBfc3VwZXI0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzNi5pZCA9IFwiaXNsYW1pYy11bWFscXVyYVwiO1xuICAgIHJldHVybiBfdGhpczY7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhJc2xhbWljVW1hbHF1cmFIZWxwZXIpO1xufShJc2xhbWljQmFzZUhlbHBlcik7XG52YXIgSXNsYW1pY1RibGFIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Jc2xhbWljQmFzZUhlbHBlcjMpIHtcbiAgX2luaGVyaXRzKElzbGFtaWNUYmxhSGVscGVyLCBfSXNsYW1pY0Jhc2VIZWxwZXIzKTtcbiAgdmFyIF9zdXBlcjUgPSBfY3JlYXRlU3VwZXIoSXNsYW1pY1RibGFIZWxwZXIpO1xuICBmdW5jdGlvbiBJc2xhbWljVGJsYUhlbHBlcigpIHtcbiAgICB2YXIgX3RoaXM3O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJc2xhbWljVGJsYUhlbHBlcik7XG4gICAgX3RoaXM3ID0gX3N1cGVyNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBfdGhpczcuaWQgPSBcImlzbGFtaWMtdGJsYVwiO1xuICAgIHJldHVybiBfdGhpczc7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhJc2xhbWljVGJsYUhlbHBlcik7XG59KElzbGFtaWNCYXNlSGVscGVyKTtcbnZhciBJc2xhbWljQ2l2aWxIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Jc2xhbWljQmFzZUhlbHBlcjQpIHtcbiAgX2luaGVyaXRzKElzbGFtaWNDaXZpbEhlbHBlciwgX0lzbGFtaWNCYXNlSGVscGVyNCk7XG4gIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKElzbGFtaWNDaXZpbEhlbHBlcik7XG4gIGZ1bmN0aW9uIElzbGFtaWNDaXZpbEhlbHBlcigpIHtcbiAgICB2YXIgX3RoaXM4O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJc2xhbWljQ2l2aWxIZWxwZXIpO1xuICAgIF90aGlzOCA9IF9zdXBlcjYuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgX3RoaXM4LmlkID0gXCJpc2xhbWljLWNpdmlsXCI7XG4gICAgcmV0dXJuIF90aGlzODtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKElzbGFtaWNDaXZpbEhlbHBlcik7XG59KElzbGFtaWNCYXNlSGVscGVyKTtcbnZhciBJc2xhbWljUmdzYUhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lzbGFtaWNCYXNlSGVscGVyNSkge1xuICBfaW5oZXJpdHMoSXNsYW1pY1Jnc2FIZWxwZXIsIF9Jc2xhbWljQmFzZUhlbHBlcjUpO1xuICB2YXIgX3N1cGVyNyA9IF9jcmVhdGVTdXBlcihJc2xhbWljUmdzYUhlbHBlcik7XG4gIGZ1bmN0aW9uIElzbGFtaWNSZ3NhSGVscGVyKCkge1xuICAgIHZhciBfdGhpczk7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElzbGFtaWNSZ3NhSGVscGVyKTtcbiAgICBfdGhpczkgPSBfc3VwZXI3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzOS5pZCA9IFwiaXNsYW1pYy1yZ3NhXCI7XG4gICAgcmV0dXJuIF90aGlzOTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKElzbGFtaWNSZ3NhSGVscGVyKTtcbn0oSXNsYW1pY0Jhc2VIZWxwZXIpO1xudmFyIElzbGFtaWNDY0hlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lzbGFtaWNCYXNlSGVscGVyNikge1xuICBfaW5oZXJpdHMoSXNsYW1pY0NjSGVscGVyLCBfSXNsYW1pY0Jhc2VIZWxwZXI2KTtcbiAgdmFyIF9zdXBlcjggPSBfY3JlYXRlU3VwZXIoSXNsYW1pY0NjSGVscGVyKTtcbiAgZnVuY3Rpb24gSXNsYW1pY0NjSGVscGVyKCkge1xuICAgIHZhciBfdGhpczEwO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJc2xhbWljQ2NIZWxwZXIpO1xuICAgIF90aGlzMTAgPSBfc3VwZXI4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzMTAuaWQgPSBcImlzbGFtaWNjXCI7XG4gICAgcmV0dXJuIF90aGlzMTA7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhJc2xhbWljQ2NIZWxwZXIpO1xufShJc2xhbWljQmFzZUhlbHBlcik7XG52YXIgUGVyc2lhbkhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0hlbHBlckJhc2UzKSB7XG4gIF9pbmhlcml0cyhQZXJzaWFuSGVscGVyLCBfSGVscGVyQmFzZTMpO1xuICB2YXIgX3N1cGVyOSA9IF9jcmVhdGVTdXBlcihQZXJzaWFuSGVscGVyKTtcbiAgZnVuY3Rpb24gUGVyc2lhbkhlbHBlcigpIHtcbiAgICB2YXIgX3RoaXMxMTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGVyc2lhbkhlbHBlcik7XG4gICAgX3RoaXMxMSA9IF9zdXBlcjkuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgX3RoaXMxMS5pZCA9IFwicGVyc2lhblwiLCBfdGhpczExLmNhbGVuZGFyVHlwZSA9IFwic29sYXJcIiwgX3RoaXMxMS5jb25zdGFudEVyYSA9IFwiYXBcIjtcbiAgICByZXR1cm4gX3RoaXMxMTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoUGVyc2lhbkhlbHBlciwgW3tcbiAgICBrZXk6IFwiaW5MZWFwWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbkxlYXBZZWFyKGUsIHQpIHtcbiAgICAgIHJldHVybiBJc2xhbWljSGVscGVyLnByb3RvdHlwZS5pbkxlYXBZZWFyLmNhbGwodGhpcywgZSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoc0luWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aHNJblllYXIoKSB7XG4gICAgICByZXR1cm4gMTI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pbmltdW1Nb250aExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW5pbXVtTW9udGhMZW5ndGgoZSkge1xuICAgICAgdmFyIHQgPSBlLm1vbnRoO1xuICAgICAgcmV0dXJuIDEyID09PSB0ID8gMjkgOiB0IDw9IDYgPyAzMSA6IDMwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhpbXVtTW9udGhMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4aW11bU1vbnRoTGVuZ3RoKGUpIHtcbiAgICAgIHZhciB0ID0gZS5tb250aDtcbiAgICAgIHJldHVybiAxMiA9PT0gdCA/IDMwIDogdCA8PSA2ID8gMzEgOiAzMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXN0aW1hdGVJc29EYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVzdGltYXRlSXNvRGF0ZShlKSB7XG4gICAgICB2YXIgX3RoaXMkYWRqdXN0Q2FsZW5kYXJEMiA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKGUpLFxuICAgICAgICB0ID0gX3RoaXMkYWRqdXN0Q2FsZW5kYXJEMi55ZWFyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogdCArIDYyMSxcbiAgICAgICAgbW9udGg6IDEsXG4gICAgICAgIGRheTogMVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBlcnNpYW5IZWxwZXI7XG59KEhlbHBlckJhc2UpO1xudmFyIEluZGlhbkhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0hlbHBlckJhc2U0KSB7XG4gIF9pbmhlcml0cyhJbmRpYW5IZWxwZXIsIF9IZWxwZXJCYXNlNCk7XG4gIHZhciBfc3VwZXIxMCA9IF9jcmVhdGVTdXBlcihJbmRpYW5IZWxwZXIpO1xuICBmdW5jdGlvbiBJbmRpYW5IZWxwZXIoKSB7XG4gICAgdmFyIF90aGlzMTI7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZGlhbkhlbHBlcik7XG4gICAgX3RoaXMxMiA9IF9zdXBlcjEwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzMTIuaWQgPSBcImluZGlhblwiLCBfdGhpczEyLmNhbGVuZGFyVHlwZSA9IFwic29sYXJcIiwgX3RoaXMxMi5jb25zdGFudEVyYSA9IFwic2FrYVwiLCBfdGhpczEyLm1vbnRocyA9IHtcbiAgICAgIDE6IHtcbiAgICAgICAgbGVuZ3RoOiAzMCxcbiAgICAgICAgbW9udGg6IDMsXG4gICAgICAgIGRheTogMjIsXG4gICAgICAgIGxlYXA6IHtcbiAgICAgICAgICBsZW5ndGg6IDMxLFxuICAgICAgICAgIG1vbnRoOiAzLFxuICAgICAgICAgIGRheTogMjFcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIDI6IHtcbiAgICAgICAgbGVuZ3RoOiAzMSxcbiAgICAgICAgbW9udGg6IDQsXG4gICAgICAgIGRheTogMjFcbiAgICAgIH0sXG4gICAgICAzOiB7XG4gICAgICAgIGxlbmd0aDogMzEsXG4gICAgICAgIG1vbnRoOiA1LFxuICAgICAgICBkYXk6IDIyXG4gICAgICB9LFxuICAgICAgNDoge1xuICAgICAgICBsZW5ndGg6IDMxLFxuICAgICAgICBtb250aDogNixcbiAgICAgICAgZGF5OiAyMlxuICAgICAgfSxcbiAgICAgIDU6IHtcbiAgICAgICAgbGVuZ3RoOiAzMSxcbiAgICAgICAgbW9udGg6IDcsXG4gICAgICAgIGRheTogMjNcbiAgICAgIH0sXG4gICAgICA2OiB7XG4gICAgICAgIGxlbmd0aDogMzEsXG4gICAgICAgIG1vbnRoOiA4LFxuICAgICAgICBkYXk6IDIzXG4gICAgICB9LFxuICAgICAgNzoge1xuICAgICAgICBsZW5ndGg6IDMwLFxuICAgICAgICBtb250aDogOSxcbiAgICAgICAgZGF5OiAyM1xuICAgICAgfSxcbiAgICAgIDg6IHtcbiAgICAgICAgbGVuZ3RoOiAzMCxcbiAgICAgICAgbW9udGg6IDEwLFxuICAgICAgICBkYXk6IDIzXG4gICAgICB9LFxuICAgICAgOToge1xuICAgICAgICBsZW5ndGg6IDMwLFxuICAgICAgICBtb250aDogMTEsXG4gICAgICAgIGRheTogMjJcbiAgICAgIH0sXG4gICAgICAxMDoge1xuICAgICAgICBsZW5ndGg6IDMwLFxuICAgICAgICBtb250aDogMTIsXG4gICAgICAgIGRheTogMjJcbiAgICAgIH0sXG4gICAgICAxMToge1xuICAgICAgICBsZW5ndGg6IDMwLFxuICAgICAgICBtb250aDogMSxcbiAgICAgICAgbmV4dFllYXI6ICEwLFxuICAgICAgICBkYXk6IDIxXG4gICAgICB9LFxuICAgICAgMTI6IHtcbiAgICAgICAgbGVuZ3RoOiAzMCxcbiAgICAgICAgbW9udGg6IDIsXG4gICAgICAgIG5leHRZZWFyOiAhMCxcbiAgICAgICAgZGF5OiAyMFxuICAgICAgfVxuICAgIH0sIF90aGlzMTIudnVsbmVyYWJsZVRvQmNlQnVnID0gXCIxMC8xMS8tNzkgU2FrYVwiICE9PSBuZXcgRGF0ZShcIjAwMDAtMDEtMDFUMDA6MDBaXCIpLnRvTG9jYWxlRGF0ZVN0cmluZyhcImVuLVVTLXUtY2EtaW5kaWFuXCIsIHtcbiAgICAgIHRpbWVab25lOiBcIlVUQ1wiXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzMTI7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEluZGlhbkhlbHBlciwgW3tcbiAgICBrZXk6IFwiaW5MZWFwWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbkxlYXBZZWFyKGUpIHtcbiAgICAgIHJldHVybiBpc0dyZWdvcmlhbkxlYXBZZWFyKGUueWVhciArIDc4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhzSW5ZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vbnRoc0luWWVhcigpIHtcbiAgICAgIHJldHVybiAxMjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWluaW11bU1vbnRoTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pbmltdW1Nb250aExlbmd0aChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRNb250aEluZm8oZSkubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhpbXVtTW9udGhMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4aW11bU1vbnRoTGVuZ3RoKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1vbnRoSW5mbyhlKS5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1vbnRoSW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb250aEluZm8oZSkge1xuICAgICAgdmFyIHQgPSBlLm1vbnRoO1xuICAgICAgdmFyIHIgPSB0aGlzLm1vbnRoc1t0XTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtb250aDogXCIuY29uY2F0KHQpKTtcbiAgICAgIHJldHVybiB0aGlzLmluTGVhcFllYXIoZSkgJiYgci5sZWFwICYmIChyID0gci5sZWFwKSwgcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXN0aW1hdGVJc29EYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVzdGltYXRlSXNvRGF0ZShlKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuYWRqdXN0Q2FsZW5kYXJEYXRlKGUpLFxuICAgICAgICByID0gdGhpcy5nZXRNb250aEluZm8odCk7XG4gICAgICByZXR1cm4gQWRkSVNPRGF0ZSh0LnllYXIgKyA3OCArIChyLm5leHRZZWFyID8gMSA6IDApLCByLm1vbnRoLCByLmRheSwgMCwgMCwgMCwgdC5kYXkgLSAxLCBcImNvbnN0cmFpblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tJY3VCdWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrSWN1QnVncyhlKSB7XG4gICAgICBpZiAodGhpcy52dWxuZXJhYmxlVG9CY2VCdWcgJiYgZS55ZWFyIDwgMSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJjYWxlbmRhciAnXCIuY29uY2F0KHRoaXMuaWQsIFwiJyBpcyBicm9rZW4gZm9yIElTTyBkYXRlcyBiZWZvcmUgMDAwMS0wMS0wMSAoc2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEwNTI5KVwiKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBJbmRpYW5IZWxwZXI7XG59KEhlbHBlckJhc2UpO1xuZnVuY3Rpb24gaXNHcmVnb3JpYW5MZWFwWWVhcihlKSB7XG4gIHJldHVybiBlICUgNCA9PSAwICYmIChlICUgMTAwICE9IDAgfHwgZSAlIDQwMCA9PSAwKTtcbn1cbnZhciBHcmVnb3JpYW5CYXNlSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSGVscGVyQmFzZTUpIHtcbiAgX2luaGVyaXRzKEdyZWdvcmlhbkJhc2VIZWxwZXIsIF9IZWxwZXJCYXNlNSk7XG4gIHZhciBfc3VwZXIxMSA9IF9jcmVhdGVTdXBlcihHcmVnb3JpYW5CYXNlSGVscGVyKTtcbiAgZnVuY3Rpb24gR3JlZ29yaWFuQmFzZUhlbHBlcihlLCB0KSB7XG4gICAgdmFyIF90aGlzMTM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyZWdvcmlhbkJhc2VIZWxwZXIpO1xuICAgIF90aGlzMTMgPSBfc3VwZXIxMS5jYWxsKHRoaXMpLCBfdGhpczEzLmNhbGVuZGFyVHlwZSA9IFwic29sYXJcIiwgX3RoaXMxMy52OElzVnVsbmVyYWJsZVRvSnVsaWFuQnVnID0gbmV3IERhdGUoXCIrMDAxMDAxLTAxLTAxVDAwOjAwWlwiKS50b0xvY2FsZURhdGVTdHJpbmcoXCJlbi1VUy11LWNhLWphcGFuZXNlXCIsIHtcbiAgICAgIHRpbWVab25lOiBcIlVUQ1wiXG4gICAgfSkuc3RhcnRzV2l0aChcIjEyXCIpLCBfdGhpczEzLmNhbGVuZGFySXNWdWxuZXJhYmxlVG9KdWxpYW5CdWcgPSAhMSwgX3RoaXMxMy5pZCA9IGU7XG4gICAgdmFyIF9hZGp1c3RFcmFzID0gZnVuY3Rpb24gYWRqdXN0RXJhcyhlKSB7XG4gICAgICAgIHZhciB0LFxuICAgICAgICAgIHIgPSBlO1xuICAgICAgICBpZiAoMCA9PT0gci5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBlcmEgZGF0YTogZXJhcyBhcmUgcmVxdWlyZWRcIik7XG4gICAgICAgIGlmICgxID09PSByLmxlbmd0aCAmJiByWzBdLnJldmVyc2VPZikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGVyYSBkYXRhOiBhbmNob3IgZXJhIGNhbm5vdCBjb3VudCB5ZWFycyBiYWNrd2FyZHNcIik7XG4gICAgICAgIGlmICgxID09PSByLmxlbmd0aCAmJiAhclswXS5uYW1lKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgZXJhIGRhdGE6IGF0IGxlYXN0IG9uZSBuYW1lZCBlcmEgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIGlmIChyLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBudWxsICE9IGUucmV2ZXJzZU9mO1xuICAgICAgICB9KS5sZW5ndGggPiAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgZXJhIGRhdGE6IG9ubHkgb25lIGVyYSBjYW4gY291bnQgeWVhcnMgYmFja3dhcmRzXCIpO1xuICAgICAgICByLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoZS5pc0FuY2hvciB8fCAhZS5hbmNob3JFcG9jaCAmJiAhZS5yZXZlcnNlT2YpIHtcbiAgICAgICAgICAgIGlmICh0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgZXJhIGRhdGE6IGNhbm5vdCBoYXZlIG11bHRpcGxlIGFuY2hvciBlcmFzXCIpO1xuICAgICAgICAgICAgdCA9IGUsIGUuYW5jaG9yRXBvY2ggPSB7XG4gICAgICAgICAgICAgIHllYXI6IGUuaGFzWWVhclplcm8gPyAwIDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFlLm5hbWUpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSWYgZXJhIG5hbWUgaXMgYmxhbmssIGl0IG11c3QgYmUgdGhlIGFuY2hvciBlcmFcIik7XG4gICAgICAgIH0pLCByID0gci5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5uYW1lO1xuICAgICAgICB9KSwgci5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIHQgPSBlLnJldmVyc2VPZjtcbiAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgdmFyIF9vMzggPSByLmZpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGUubmFtZSA9PT0gdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gX28zOCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGVyYSBkYXRhOiB1bm1hdGNoZWQgcmV2ZXJzZU9mIGVyYTogXCIuY29uY2F0KHQpKTtcbiAgICAgICAgICAgIGUucmV2ZXJzZU9mID0gX28zOCwgZS5hbmNob3JFcG9jaCA9IF9vMzguYW5jaG9yRXBvY2gsIGUuaXNvRXBvY2ggPSBfbzM4Lmlzb0Vwb2NoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2b2lkIDAgPT09IGUuYW5jaG9yRXBvY2gubW9udGggJiYgKGUuYW5jaG9yRXBvY2gubW9udGggPSAxKSwgdm9pZCAwID09PSBlLmFuY2hvckVwb2NoLmRheSAmJiAoZS5hbmNob3JFcG9jaC5kYXkgPSAxKTtcbiAgICAgICAgfSksIHl0LmNhbGwociwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICBpZiAoZS5yZXZlcnNlT2YpIHJldHVybiAxO1xuICAgICAgICAgIGlmICh0LnJldmVyc2VPZikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmICghZS5pc29FcG9jaCB8fCAhdC5pc29FcG9jaCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGVyYSBkYXRhOiBtaXNzaW5nIElTTyBlcG9jaFwiKTtcbiAgICAgICAgICByZXR1cm4gdC5pc29FcG9jaC55ZWFyIC0gZS5pc29FcG9jaC55ZWFyO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG8gPSByW3IubGVuZ3RoIC0gMV0ucmV2ZXJzZU9mO1xuICAgICAgICBpZiAobyAmJiBvICE9PSByW3IubGVuZ3RoIC0gMl0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBlcmEgZGF0YTogaW52YWxpZCByZXZlcnNlLXNpZ24gZXJhXCIpO1xuICAgICAgICByZXR1cm4gci5mb3JFYWNoKGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgZS5nZW5lcmljTmFtZSA9IFwiZXJhXCIgKyAoci5sZW5ndGggLSAxIC0gdCk7XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgZXJhczogcixcbiAgICAgICAgICBhbmNob3JFcmE6IHQgfHwgclswXVxuICAgICAgICB9O1xuICAgICAgfSh0KSxcbiAgICAgIHIgPSBfYWRqdXN0RXJhcy5lcmFzLFxuICAgICAgbyA9IF9hZGp1c3RFcmFzLmFuY2hvckVyYTtcbiAgICBfdGhpczEzLmFuY2hvckVyYSA9IG8sIF90aGlzMTMuZXJhcyA9IHI7XG4gICAgcmV0dXJuIF90aGlzMTM7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEdyZWdvcmlhbkJhc2VIZWxwZXIsIFt7XG4gICAga2V5OiBcImluTGVhcFllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5MZWFwWWVhcihlKSB7XG4gICAgICB2YXIgX3RoaXMkZXN0aW1hdGVJc29EYXRlID0gdGhpcy5lc3RpbWF0ZUlzb0RhdGUoe1xuICAgICAgICAgIG1vbnRoOiAxLFxuICAgICAgICAgIGRheTogMSxcbiAgICAgICAgICB5ZWFyOiBlLnllYXJcbiAgICAgICAgfSksXG4gICAgICAgIHQgPSBfdGhpcyRlc3RpbWF0ZUlzb0RhdGUueWVhcjtcbiAgICAgIHJldHVybiBpc0dyZWdvcmlhbkxlYXBZZWFyKHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aHNJblllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW9udGhzSW5ZZWFyKCkge1xuICAgICAgcmV0dXJuIDEyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaW5pbXVtTW9udGhMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluaW11bU1vbnRoTGVuZ3RoKGUpIHtcbiAgICAgIHZhciB0ID0gZS5tb250aDtcbiAgICAgIHJldHVybiAyID09PSB0ID8gdGhpcy5pbkxlYXBZZWFyKGUpID8gMjkgOiAyOCA6IFs0LCA2LCA5LCAxMV0uaW5kZXhPZih0KSA+PSAwID8gMzAgOiAzMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF4aW11bU1vbnRoTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heGltdW1Nb250aExlbmd0aChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5taW5pbXVtTW9udGhMZW5ndGgoZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBsZXRlRXJhWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wbGV0ZUVyYVllYXIoZSkge1xuICAgICAgdmFyIF90aGlzMTQgPSB0aGlzLFxuICAgICAgICBfZXJhRnJvbVllYXI7XG4gICAgICB2YXIgY2hlY2tGaWVsZCA9IGZ1bmN0aW9uIGNoZWNrRmllbGQodCwgcikge1xuICAgICAgICAgIHZhciBvID0gZVt0XTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBvICYmIG8gIT0gcikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnB1dCBcIi5jb25jYXQodCwgXCIgXCIpLmNvbmNhdChvLCBcIiBkb2Vzbid0IG1hdGNoIGNhbGN1bGF0ZWQgdmFsdWUgXCIpLmNvbmNhdChyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVyYUZyb21ZZWFyID0gZnVuY3Rpb24gZXJhRnJvbVllYXIodCkge1xuICAgICAgICAgIHZhciByO1xuICAgICAgICAgIHZhciBvID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGUpLCB7fSwge1xuICAgICAgICAgICAgICB5ZWFyOiB0XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG4gPSBfdGhpczE0LmVyYXMuZmluZChmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgICBpZiAobiA9PT0gX3RoaXMxNC5lcmFzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5yZXZlcnNlT2YpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0ID4gMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTaWduZWQgeWVhciBcIi5jb25jYXQodCwgXCIgaXMgaW52YWxpZCBmb3IgZXJhIFwiKS5jb25jYXQoZS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gciA9IGUuYW5jaG9yRXBvY2gueWVhciAtIHQsICEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gciA9IHQgLSBlLmFuY2hvckVwb2NoLnllYXIgKyAoZS5oYXNZZWFyWmVybyA/IDAgOiAxKSwgITA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTQuY29tcGFyZUNhbGVuZGFyRGF0ZXMobywgZS5hbmNob3JFcG9jaCkgPj0gMCAmJiAociA9IHQgLSBlLmFuY2hvckVwb2NoLnllYXIgKyAoZS5oYXNZZWFyWmVybyA/IDAgOiAxKSwgITApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFuKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlllYXIgXCIuY29uY2F0KHQsIFwiIHdhcyBub3QgbWF0Y2hlZCBieSBhbnkgZXJhXCIpKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJhWWVhcjogcixcbiAgICAgICAgICAgIGVyYTogbi5uYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIHZhciB0ID0gZS55ZWFyLFxuICAgICAgICByID0gZS5lcmFZZWFyLFxuICAgICAgICBvID0gZS5lcmE7XG4gICAgICBpZiAobnVsbCAhPSB0KSAoX2VyYUZyb21ZZWFyID0gZXJhRnJvbVllYXIodCksIHIgPSBfZXJhRnJvbVllYXIuZXJhWWVhciwgbyA9IF9lcmFGcm9tWWVhci5lcmEpLCBjaGVja0ZpZWxkKFwiZXJhXCIsIG8pLCBjaGVja0ZpZWxkKFwiZXJhWWVhclwiLCByKTtlbHNlIHtcbiAgICAgICAgaWYgKG51bGwgPT0gcikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFaXRoZXIgYHllYXJgIG9yIGBlcmFZZWFyYCBhbmQgYGVyYWAgYXJlIHJlcXVpcmVkXCIpO1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9lcmFGcm9tWWVhcjI7XG4gICAgICAgICAgdmFyIF9lNDggPSB2b2lkIDAgPT09IG8gPyB2b2lkIDAgOiB0aGlzLmVyYXMuZmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUubmFtZSA9PT0gbyB8fCBlLmdlbmVyaWNOYW1lID09PSBvO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghX2U0OCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFcmEgXCIuY29uY2F0KG8sIFwiIChJU08geWVhciBcIikuY29uY2F0KHIsIFwiKSB3YXMgbm90IG1hdGNoZWQgYnkgYW55IGVyYVwiKSk7XG4gICAgICAgICAgaWYgKHIgPCAxICYmIF9lNDgucmV2ZXJzZU9mKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlllYXJzIGluIFwiLmNvbmNhdChvLCBcIiBlcmEgbXVzdCBiZSBwb3NpdGl2ZSwgbm90IFwiKS5jb25jYXQodCkpO1xuICAgICAgICAgIHQgPSBfZTQ4LnJldmVyc2VPZiA/IF9lNDguYW5jaG9yRXBvY2gueWVhciAtIHIgOiByICsgX2U0OC5hbmNob3JFcG9jaC55ZWFyIC0gKF9lNDguaGFzWWVhclplcm8gPyAwIDogMSksIGNoZWNrRmllbGQoXCJ5ZWFyXCIsIHQpLCAoX2VyYUZyb21ZZWFyMiA9IGVyYUZyb21ZZWFyKHQpLCByID0gX2VyYUZyb21ZZWFyMi5lcmFZZWFyLCBvID0gX2VyYUZyb21ZZWFyMi5lcmEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGUpLCB7fSwge1xuICAgICAgICB5ZWFyOiB0LFxuICAgICAgICBlcmFZZWFyOiByLFxuICAgICAgICBlcmE6IG9cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGp1c3RDYWxlbmRhckRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRqdXN0Q2FsZW5kYXJEYXRlKGUsIHQpIHtcbiAgICAgIHZhciByID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcImNvbnN0cmFpblwiO1xuICAgICAgdmFyIG8gPSBlO1xuICAgICAgdmFyIF9vMzkgPSBvLFxuICAgICAgICBuID0gX28zOS5tb250aCxcbiAgICAgICAgYSA9IF9vMzkubW9udGhDb2RlO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gbiAmJiAobyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvKSwge30sIHtcbiAgICAgICAgbW9udGg6IG1vbnRoQ29kZU51bWJlclBhcnQoYSlcbiAgICAgIH0pKSwgdGhpcy52YWxpZGF0ZUNhbGVuZGFyRGF0ZShvKSwgbyA9IHRoaXMuY29tcGxldGVFcmFZZWFyKG8pLCBfZ2V0KF9nZXRQcm90b3R5cGVPZihHcmVnb3JpYW5CYXNlSGVscGVyLnByb3RvdHlwZSksIFwiYWRqdXN0Q2FsZW5kYXJEYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgbywgdCwgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVzdGltYXRlSXNvRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc3RpbWF0ZUlzb0RhdGUoZSkge1xuICAgICAgdmFyIHQgPSB0aGlzLmFkanVzdENhbGVuZGFyRGF0ZShlKSxcbiAgICAgICAgciA9IHQueWVhcixcbiAgICAgICAgbyA9IHQubW9udGgsXG4gICAgICAgIG4gPSB0LmRheSxcbiAgICAgICAgYSA9IHRoaXMuYW5jaG9yRXJhO1xuICAgICAgcmV0dXJuIFJlZ3VsYXRlSVNPRGF0ZShyICsgYS5pc29FcG9jaC55ZWFyIC0gKGEuaGFzWWVhclplcm8gPyAwIDogMSksIG8sIG4sIFwiY29uc3RyYWluXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0ljdUJ1Z3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tJY3VCdWdzKGUpIHtcbiAgICAgIGlmICh0aGlzLmNhbGVuZGFySXNWdWxuZXJhYmxlVG9KdWxpYW5CdWcgJiYgdGhpcy52OElzVnVsbmVyYWJsZVRvSnVsaWFuQnVnKSB7XG4gICAgICAgIGlmIChDb21wYXJlSVNPRGF0ZShlLnllYXIsIGUubW9udGgsIGUuZGF5LCAxNTgyLCAxMCwgMTUpIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJjYWxlbmRhciAnXCIuY29uY2F0KHRoaXMuaWQsIFwiJyBpcyBicm9rZW4gZm9yIElTTyBkYXRlcyBiZWZvcmUgMTU4Mi0xMC0xNSAoc2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTExNzMxNTgpXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEdyZWdvcmlhbkJhc2VIZWxwZXI7XG59KEhlbHBlckJhc2UpO1xudmFyIE9ydGhvZG94QmFzZUhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0dyZWdvcmlhbkJhc2VIZWxwZXIpIHtcbiAgX2luaGVyaXRzKE9ydGhvZG94QmFzZUhlbHBlciwgX0dyZWdvcmlhbkJhc2VIZWxwZXIpO1xuICB2YXIgX3N1cGVyMTIgPSBfY3JlYXRlU3VwZXIoT3J0aG9kb3hCYXNlSGVscGVyKTtcbiAgZnVuY3Rpb24gT3J0aG9kb3hCYXNlSGVscGVyKGUsIHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3J0aG9kb3hCYXNlSGVscGVyKTtcbiAgICByZXR1cm4gX3N1cGVyMTIuY2FsbCh0aGlzLCBlLCB0KTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoT3J0aG9kb3hCYXNlSGVscGVyLCBbe1xuICAgIGtleTogXCJpbkxlYXBZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluTGVhcFllYXIoZSkge1xuICAgICAgdmFyIHQgPSBlLnllYXI7XG4gICAgICByZXR1cm4gKHQgKyAxKSAlIDQgPT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhzSW5ZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vbnRoc0luWWVhcigpIHtcbiAgICAgIHJldHVybiAxMztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWluaW11bU1vbnRoTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pbmltdW1Nb250aExlbmd0aChlKSB7XG4gICAgICB2YXIgdCA9IGUubW9udGg7XG4gICAgICByZXR1cm4gMTMgPT09IHQgPyB0aGlzLmluTGVhcFllYXIoZSkgPyA2IDogNSA6IDMwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhpbXVtTW9udGhMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4aW11bU1vbnRoTGVuZ3RoKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1pbmltdW1Nb250aExlbmd0aChlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE9ydGhvZG94QmFzZUhlbHBlcjtcbn0oR3JlZ29yaWFuQmFzZUhlbHBlcik7XG52YXIgRXRoaW9hYUhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09ydGhvZG94QmFzZUhlbHBlcikge1xuICBfaW5oZXJpdHMoRXRoaW9hYUhlbHBlciwgX09ydGhvZG94QmFzZUhlbHBlcik7XG4gIHZhciBfc3VwZXIxMyA9IF9jcmVhdGVTdXBlcihFdGhpb2FhSGVscGVyKTtcbiAgZnVuY3Rpb24gRXRoaW9hYUhlbHBlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXRoaW9hYUhlbHBlcik7XG4gICAgcmV0dXJuIF9zdXBlcjEzLmNhbGwodGhpcywgXCJldGhpb2FhXCIsIFt7XG4gICAgICBuYW1lOiBcImVyYTBcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IC01NDkyLFxuICAgICAgICBtb250aDogNyxcbiAgICAgICAgZGF5OiAxN1xuICAgICAgfVxuICAgIH1dKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEV0aGlvYWFIZWxwZXIpO1xufShPcnRob2RveEJhc2VIZWxwZXIpO1xudmFyIENvcHRpY0hlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09ydGhvZG94QmFzZUhlbHBlcjIpIHtcbiAgX2luaGVyaXRzKENvcHRpY0hlbHBlciwgX09ydGhvZG94QmFzZUhlbHBlcjIpO1xuICB2YXIgX3N1cGVyMTQgPSBfY3JlYXRlU3VwZXIoQ29wdGljSGVscGVyKTtcbiAgZnVuY3Rpb24gQ29wdGljSGVscGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb3B0aWNIZWxwZXIpO1xuICAgIHJldHVybiBfc3VwZXIxNC5jYWxsKHRoaXMsIFwiY29wdGljXCIsIFt7XG4gICAgICBuYW1lOiBcImVyYTFcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IDI4NCxcbiAgICAgICAgbW9udGg6IDgsXG4gICAgICAgIGRheTogMjlcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImVyYTBcIixcbiAgICAgIHJldmVyc2VPZjogXCJlcmExXCJcbiAgICB9XSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDb3B0aWNIZWxwZXIpO1xufShPcnRob2RveEJhc2VIZWxwZXIpO1xudmFyIEV0aGlvcGljSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfT3J0aG9kb3hCYXNlSGVscGVyMykge1xuICBfaW5oZXJpdHMoRXRoaW9waWNIZWxwZXIsIF9PcnRob2RveEJhc2VIZWxwZXIzKTtcbiAgdmFyIF9zdXBlcjE1ID0gX2NyZWF0ZVN1cGVyKEV0aGlvcGljSGVscGVyKTtcbiAgZnVuY3Rpb24gRXRoaW9waWNIZWxwZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV0aGlvcGljSGVscGVyKTtcbiAgICByZXR1cm4gX3N1cGVyMTUuY2FsbCh0aGlzLCBcImV0aGlvcGljXCIsIFt7XG4gICAgICBuYW1lOiBcImVyYTBcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IC01NDkyLFxuICAgICAgICBtb250aDogNyxcbiAgICAgICAgZGF5OiAxN1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiZXJhMVwiLFxuICAgICAgaXNvRXBvY2g6IHtcbiAgICAgICAgeWVhcjogOCxcbiAgICAgICAgbW9udGg6IDgsXG4gICAgICAgIGRheTogMjdcbiAgICAgIH0sXG4gICAgICBhbmNob3JFcG9jaDoge1xuICAgICAgICB5ZWFyOiA1NTAxXG4gICAgICB9XG4gICAgfV0pO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRXRoaW9waWNIZWxwZXIpO1xufShPcnRob2RveEJhc2VIZWxwZXIpO1xudmFyIFJvY0hlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0dyZWdvcmlhbkJhc2VIZWxwZXIyKSB7XG4gIF9pbmhlcml0cyhSb2NIZWxwZXIsIF9HcmVnb3JpYW5CYXNlSGVscGVyMik7XG4gIHZhciBfc3VwZXIxNiA9IF9jcmVhdGVTdXBlcihSb2NIZWxwZXIpO1xuICBmdW5jdGlvbiBSb2NIZWxwZXIoKSB7XG4gICAgdmFyIF90aGlzMTU7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvY0hlbHBlcik7XG4gICAgX3RoaXMxNSA9IF9zdXBlcjE2LmNhbGwodGhpcywgXCJyb2NcIiwgW3tcbiAgICAgIG5hbWU6IFwibWluZ3VvXCIsXG4gICAgICBpc29FcG9jaDoge1xuICAgICAgICB5ZWFyOiAxOTEyLFxuICAgICAgICBtb250aDogMSxcbiAgICAgICAgZGF5OiAxXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogXCJiZWZvcmUtcm9jXCIsXG4gICAgICByZXZlcnNlT2Y6IFwibWluZ3VvXCJcbiAgICB9XSksIF90aGlzMTUuY2FsZW5kYXJJc1Z1bG5lcmFibGVUb0p1bGlhbkJ1ZyA9ICEwO1xuICAgIHJldHVybiBfdGhpczE1O1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUm9jSGVscGVyKTtcbn0oR3JlZ29yaWFuQmFzZUhlbHBlcik7XG52YXIgQnVkZGhpc3RIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9HcmVnb3JpYW5CYXNlSGVscGVyMykge1xuICBfaW5oZXJpdHMoQnVkZGhpc3RIZWxwZXIsIF9HcmVnb3JpYW5CYXNlSGVscGVyMyk7XG4gIHZhciBfc3VwZXIxNyA9IF9jcmVhdGVTdXBlcihCdWRkaGlzdEhlbHBlcik7XG4gIGZ1bmN0aW9uIEJ1ZGRoaXN0SGVscGVyKCkge1xuICAgIHZhciBfdGhpczE2O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWRkaGlzdEhlbHBlcik7XG4gICAgX3RoaXMxNiA9IF9zdXBlcjE3LmNhbGwodGhpcywgXCJidWRkaGlzdFwiLCBbe1xuICAgICAgbmFtZTogXCJiZVwiLFxuICAgICAgaGFzWWVhclplcm86ICEwLFxuICAgICAgaXNvRXBvY2g6IHtcbiAgICAgICAgeWVhcjogLTU0MyxcbiAgICAgICAgbW9udGg6IDEsXG4gICAgICAgIGRheTogMVxuICAgICAgfVxuICAgIH1dKSwgX3RoaXMxNi5jYWxlbmRhcklzVnVsbmVyYWJsZVRvSnVsaWFuQnVnID0gITA7XG4gICAgcmV0dXJuIF90aGlzMTY7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhCdWRkaGlzdEhlbHBlcik7XG59KEdyZWdvcmlhbkJhc2VIZWxwZXIpO1xudmFyIEdyZWdvcnlIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9HcmVnb3JpYW5CYXNlSGVscGVyNCkge1xuICBfaW5oZXJpdHMoR3JlZ29yeUhlbHBlciwgX0dyZWdvcmlhbkJhc2VIZWxwZXI0KTtcbiAgdmFyIF9zdXBlcjE4ID0gX2NyZWF0ZVN1cGVyKEdyZWdvcnlIZWxwZXIpO1xuICBmdW5jdGlvbiBHcmVnb3J5SGVscGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmVnb3J5SGVscGVyKTtcbiAgICByZXR1cm4gX3N1cGVyMTguY2FsbCh0aGlzLCBcImdyZWdvcnlcIiwgW3tcbiAgICAgIG5hbWU6IFwiY2VcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IDEsXG4gICAgICAgIG1vbnRoOiAxLFxuICAgICAgICBkYXk6IDFcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImJjZVwiLFxuICAgICAgcmV2ZXJzZU9mOiBcImNlXCJcbiAgICB9XSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEdyZWdvcnlIZWxwZXIsIFt7XG4gICAga2V5OiBcInJldmlzZUludGxFcmFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2aXNlSW50bEVyYShlKSB7XG4gICAgICB2YXIgdCA9IGUuZXJhLFxuICAgICAgICByID0gZS5lcmFZZWFyO1xuICAgICAgcmV0dXJuIFwiYmNcIiAhPT0gdCAmJiBcImJcIiAhPT0gdCB8fCAodCA9IFwiYmNlXCIpLCBcImFkXCIgIT09IHQgJiYgXCJhXCIgIT09IHQgfHwgKHQgPSBcImNlXCIpLCB7XG4gICAgICAgIGVyYTogdCxcbiAgICAgICAgZXJhWWVhcjogclxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEdyZWdvcnlIZWxwZXI7XG59KEdyZWdvcmlhbkJhc2VIZWxwZXIpO1xudmFyIEphcGFuZXNlSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfR3JlZ29yaWFuQmFzZUhlbHBlcjUpIHtcbiAgX2luaGVyaXRzKEphcGFuZXNlSGVscGVyLCBfR3JlZ29yaWFuQmFzZUhlbHBlcjUpO1xuICB2YXIgX3N1cGVyMTkgPSBfY3JlYXRlU3VwZXIoSmFwYW5lc2VIZWxwZXIpO1xuICBmdW5jdGlvbiBKYXBhbmVzZUhlbHBlcigpIHtcbiAgICB2YXIgX3RoaXMxNztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSmFwYW5lc2VIZWxwZXIpO1xuICAgIF90aGlzMTcgPSBfc3VwZXIxOS5jYWxsKHRoaXMsIFwiamFwYW5lc2VcIiwgW3tcbiAgICAgIG5hbWU6IFwicmVpd2FcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IDIwMTksXG4gICAgICAgIG1vbnRoOiA1LFxuICAgICAgICBkYXk6IDFcbiAgICAgIH0sXG4gICAgICBhbmNob3JFcG9jaDoge1xuICAgICAgICB5ZWFyOiAyMDE5LFxuICAgICAgICBtb250aDogNSxcbiAgICAgICAgZGF5OiAxXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogXCJoZWlzZWlcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IDE5ODksXG4gICAgICAgIG1vbnRoOiAxLFxuICAgICAgICBkYXk6IDhcbiAgICAgIH0sXG4gICAgICBhbmNob3JFcG9jaDoge1xuICAgICAgICB5ZWFyOiAxOTg5LFxuICAgICAgICBtb250aDogMSxcbiAgICAgICAgZGF5OiA4XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogXCJzaG93YVwiLFxuICAgICAgaXNvRXBvY2g6IHtcbiAgICAgICAgeWVhcjogMTkyNixcbiAgICAgICAgbW9udGg6IDEyLFxuICAgICAgICBkYXk6IDI1XG4gICAgICB9LFxuICAgICAgYW5jaG9yRXBvY2g6IHtcbiAgICAgICAgeWVhcjogMTkyNixcbiAgICAgICAgbW9udGg6IDEyLFxuICAgICAgICBkYXk6IDI1XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogXCJ0YWlzaG9cIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IDE5MTIsXG4gICAgICAgIG1vbnRoOiA3LFxuICAgICAgICBkYXk6IDMwXG4gICAgICB9LFxuICAgICAgYW5jaG9yRXBvY2g6IHtcbiAgICAgICAgeWVhcjogMTkxMixcbiAgICAgICAgbW9udGg6IDcsXG4gICAgICAgIGRheTogMzBcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiBcIm1laWppXCIsXG4gICAgICBpc29FcG9jaDoge1xuICAgICAgICB5ZWFyOiAxODY4LFxuICAgICAgICBtb250aDogOSxcbiAgICAgICAgZGF5OiA4XG4gICAgICB9LFxuICAgICAgYW5jaG9yRXBvY2g6IHtcbiAgICAgICAgeWVhcjogMTg2OCxcbiAgICAgICAgbW9udGg6IDksXG4gICAgICAgIGRheTogOFxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiY2VcIixcbiAgICAgIGlzb0Vwb2NoOiB7XG4gICAgICAgIHllYXI6IDEsXG4gICAgICAgIG1vbnRoOiAxLFxuICAgICAgICBkYXk6IDFcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImJjZVwiLFxuICAgICAgcmV2ZXJzZU9mOiBcImNlXCJcbiAgICB9XSksIF90aGlzMTcuY2FsZW5kYXJJc1Z1bG5lcmFibGVUb0p1bGlhbkJ1ZyA9ICEwLCBfdGhpczE3LmVyYUxlbmd0aCA9IFwibG9uZ1wiLCBfdGhpczE3LmVyYXNCZWdpbk1pZFllYXIgPSAhMDtcbiAgICByZXR1cm4gX3RoaXMxNztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoSmFwYW5lc2VIZWxwZXIsIFt7XG4gICAga2V5OiBcInJldmlzZUludGxFcmFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2aXNlSW50bEVyYShlLCB0KSB7XG4gICAgICB2YXIgciA9IGUuZXJhLFxuICAgICAgICBvID0gZS5lcmFZZWFyLFxuICAgICAgICBuID0gdC55ZWFyO1xuICAgICAgcmV0dXJuIHRoaXMuZXJhcy5maW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLm5hbWUgPT09IHI7XG4gICAgICB9KSA/IHtcbiAgICAgICAgZXJhOiByLFxuICAgICAgICBlcmFZZWFyOiBvXG4gICAgICB9IDogbiA8IDEgPyB7XG4gICAgICAgIGVyYTogXCJiY2VcIixcbiAgICAgICAgZXJhWWVhcjogMSAtIG5cbiAgICAgIH0gOiB7XG4gICAgICAgIGVyYTogXCJjZVwiLFxuICAgICAgICBlcmFZZWFyOiBuXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSmFwYW5lc2VIZWxwZXI7XG59KEdyZWdvcmlhbkJhc2VIZWxwZXIpO1xudmFyIENoaW5lc2VCYXNlSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSGVscGVyQmFzZTYpIHtcbiAgX2luaGVyaXRzKENoaW5lc2VCYXNlSGVscGVyLCBfSGVscGVyQmFzZTYpO1xuICB2YXIgX3N1cGVyMjAgPSBfY3JlYXRlU3VwZXIoQ2hpbmVzZUJhc2VIZWxwZXIpO1xuICBmdW5jdGlvbiBDaGluZXNlQmFzZUhlbHBlcigpIHtcbiAgICB2YXIgX3RoaXMxODtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hpbmVzZUJhc2VIZWxwZXIpO1xuICAgIF90aGlzMTggPSBfc3VwZXIyMC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBfdGhpczE4LmNhbGVuZGFyVHlwZSA9IFwibHVuaXNvbGFyXCIsIF90aGlzMTguaGFzRXJhID0gITE7XG4gICAgcmV0dXJuIF90aGlzMTg7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKENoaW5lc2VCYXNlSGVscGVyLCBbe1xuICAgIGtleTogXCJpbkxlYXBZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluTGVhcFllYXIoZSwgdCkge1xuICAgICAgdmFyIHIgPSB0aGlzLmdldE1vbnRoTGlzdChlLnllYXIsIHQpO1xuICAgICAgcmV0dXJuIDEzID09PSB3dChyKS5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoc0luWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aHNJblllYXIoZSwgdCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5MZWFwWWVhcihlLCB0KSA/IDEzIDogMTI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pbmltdW1Nb250aExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW5pbXVtTW9udGhMZW5ndGgoKSB7XG4gICAgICByZXR1cm4gMjk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heGltdW1Nb250aExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXhpbXVtTW9udGhMZW5ndGgoKSB7XG4gICAgICByZXR1cm4gMzA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1vbnRoTGlzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb250aExpc3QoZSwgdCkge1xuICAgICAgdmFyIF90aGlzMTkgPSB0aGlzLFxuICAgICAgICBfZ2V0Q2FsZW5kYXJEYXRlMjtcbiAgICAgIGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaXNzaW5nIHllYXJcIik7XG4gICAgICB2YXIgciA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBmdW5jOiBcImdldE1vbnRoTGlzdFwiLFxuICAgICAgICAgIGNhbGVuZGFyWWVhcjogZSxcbiAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICB9KSxcbiAgICAgICAgbyA9IHQuZ2V0KHIpO1xuICAgICAgaWYgKG8pIHJldHVybiBvO1xuICAgICAgdmFyIG4gPSB0aGlzLmdldEZvcm1hdHRlcigpLFxuICAgICAgICBnZXRDYWxlbmRhckRhdGUgPSBmdW5jdGlvbiBnZXRDYWxlbmRhckRhdGUoZSwgdCkge1xuICAgICAgICAgIHZhciByID0gdG9VdGNJc29EYXRlU3RyaW5nKHtcbiAgICAgICAgICAgICAgaXNvWWVhcjogZSxcbiAgICAgICAgICAgICAgaXNvTW9udGg6IDIsXG4gICAgICAgICAgICAgIGlzb0RheTogMVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvID0gbmV3IERhdGUocik7XG4gICAgICAgICAgby5zZXRVVENEYXRlKHQgKyAxKTtcbiAgICAgICAgICB2YXIgYSA9IG4uZm9ybWF0VG9QYXJ0cyhvKSxcbiAgICAgICAgICAgIGkgPSBhLmZpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwibW9udGhcIiA9PT0gZS50eXBlO1xuICAgICAgICAgICAgfSkudmFsdWUsXG4gICAgICAgICAgICBzID0gK2EuZmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJkYXlcIiA9PT0gZS50eXBlO1xuICAgICAgICAgICAgfSkudmFsdWU7XG4gICAgICAgICAgdmFyIGwgPSBhLmZpbmQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBcInJlbGF0ZWRZZWFyXCIgPT09IGUudHlwZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodm9pZCAwID09PSBsKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludGwuRGF0ZVRpbWVGb3JtYXQuZm9ybWF0VG9QYXJ0cyBsYWNrcyByZWxhdGVkWWVhciBpbiBcIi5jb25jYXQoX3RoaXMxOS5pZCwgXCIgY2FsZW5kYXIuIFRyeSBOb2RlIDE0KyBvciBtb2Rlcm4gYnJvd3NlcnMuXCIpKTtcbiAgICAgICAgICByZXR1cm4gbCA9ICtsLnZhbHVlLCB7XG4gICAgICAgICAgICBjYWxlbmRhck1vbnRoU3RyaW5nOiBpLFxuICAgICAgICAgICAgY2FsZW5kYXJEYXk6IHMsXG4gICAgICAgICAgICBjYWxlbmRhclllYXJUb1ZlcmlmeTogbFxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB2YXIgYSA9IDE3LFxuICAgICAgICBfZ2V0Q2FsZW5kYXJEYXRlID0gZ2V0Q2FsZW5kYXJEYXRlKGUsIGEpLFxuICAgICAgICBpID0gX2dldENhbGVuZGFyRGF0ZS5jYWxlbmRhck1vbnRoU3RyaW5nLFxuICAgICAgICBzID0gX2dldENhbGVuZGFyRGF0ZS5jYWxlbmRhckRheSxcbiAgICAgICAgbCA9IF9nZXRDYWxlbmRhckRhdGUuY2FsZW5kYXJZZWFyVG9WZXJpZnk7XG4gICAgICBcIjFcIiAhPT0gaSAmJiAoYSArPSAyOSwgKF9nZXRDYWxlbmRhckRhdGUyID0gZ2V0Q2FsZW5kYXJEYXRlKGUsIGEpLCBpID0gX2dldENhbGVuZGFyRGF0ZTIuY2FsZW5kYXJNb250aFN0cmluZywgcyA9IF9nZXRDYWxlbmRhckRhdGUyLmNhbGVuZGFyRGF5KSksIGEgLT0gcyAtIDU7XG4gICAgICB2YXIgZCA9IHt9O1xuICAgICAgdmFyIG0sXG4gICAgICAgIGMsXG4gICAgICAgIGggPSAxLFxuICAgICAgICB1ID0gITE7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBfZ2V0Q2FsZW5kYXJEYXRlMztcbiAgICAgICAgKF9nZXRDYWxlbmRhckRhdGUzID0gZ2V0Q2FsZW5kYXJEYXRlKGUsIGEpLCBpID0gX2dldENhbGVuZGFyRGF0ZTMuY2FsZW5kYXJNb250aFN0cmluZywgcyA9IF9nZXRDYWxlbmRhckRhdGUzLmNhbGVuZGFyRGF5LCBsID0gX2dldENhbGVuZGFyRGF0ZTMuY2FsZW5kYXJZZWFyVG9WZXJpZnkpLCBtICYmIChkW2NdLmRheXNJbk1vbnRoID0gbSArIDMwIC0gcyksIGwgIT09IGUgPyB1ID0gITAgOiAoZFtpXSA9IHtcbiAgICAgICAgICBtb250aEluZGV4OiBoKytcbiAgICAgICAgfSwgYSArPSAzMCksIG0gPSBzLCBjID0gaTtcbiAgICAgIH0gd2hpbGUgKCF1KTtcbiAgICAgIHJldHVybiBkW2NdLmRheXNJbk1vbnRoID0gbSArIDMwIC0gcywgdC5zZXQociwgZCksIGQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVzdGltYXRlSXNvRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc3RpbWF0ZUlzb0RhdGUoZSkge1xuICAgICAgdmFyIHQgPSBlLnllYXIsXG4gICAgICAgIHIgPSBlLm1vbnRoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogdCxcbiAgICAgICAgbW9udGg6IHIgPj0gMTIgPyAxMiA6IHIgKyAxLFxuICAgICAgICBkYXk6IDFcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkanVzdENhbGVuZGFyRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RDYWxlbmRhckRhdGUoZSwgdCkge1xuICAgICAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiY29uc3RyYWluXCI7XG4gICAgICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogITE7XG4gICAgICB2YXIgbiA9IGUueWVhcixcbiAgICAgICAgYSA9IGUubW9udGgsXG4gICAgICAgIGkgPSBlLm1vbnRoRXh0cmEsXG4gICAgICAgIHMgPSBlLmRheSxcbiAgICAgICAgbCA9IGUubW9udGhDb2RlLFxuICAgICAgICBkID0gZS5lcmFZZWFyO1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgaWYgKG4gPSBkLCBpICYmIFwiYmlzXCIgIT09IGkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5leHBlY3RlZCBsZWFwIG1vbnRoIHN1ZmZpeDogXCIuY29uY2F0KGkpKTtcbiAgICAgICAgdmFyIF9lNDkgPSBidWlsZE1vbnRoQ29kZShhLCB2b2lkIDAgIT09IGkpLFxuICAgICAgICAgIF9yNjUgPSBcIlwiLmNvbmNhdChhKS5jb25jYXQoaSB8fCBcIlwiKSxcbiAgICAgICAgICBfbzQwID0gdGhpcy5nZXRNb250aExpc3QobiwgdClbX3I2NV07XG4gICAgICAgIGlmICh2b2lkIDAgPT09IF9vNDApIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5tYXRjaGVkIG1vbnRoIFwiLmNvbmNhdChfcjY1LCBcIiBpbiBDaGluZXNlIHllYXIgXCIpLmNvbmNhdChuKSk7XG4gICAgICAgIHJldHVybiBhID0gX280MC5tb250aEluZGV4LCB7XG4gICAgICAgICAgeWVhcjogbixcbiAgICAgICAgICBtb250aDogYSxcbiAgICAgICAgICBkYXk6IHMsXG4gICAgICAgICAgZXJhOiB2b2lkIDAsXG4gICAgICAgICAgZXJhWWVhcjogZCxcbiAgICAgICAgICBtb250aENvZGU6IF9lNDlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnZhbGlkYXRlQ2FsZW5kYXJEYXRlKGUpLCB2b2lkIDAgPT09IG4gJiYgKG4gPSBkKSwgdm9pZCAwID09PSBkICYmIChkID0gbiksIHZvaWQgMCA9PT0gYSkge1xuICAgICAgICB2YXIgX2U1MCA9IHRoaXMuZ2V0TW9udGhMaXN0KG4sIHQpO1xuICAgICAgICB2YXIgX280MSA9IGwucmVwbGFjZShcIkxcIiwgXCJiaXNcIikuc2xpY2UoMSk7XG4gICAgICAgIFwiMFwiID09PSBfbzQxWzBdICYmIChfbzQxID0gX280MS5zbGljZSgxKSk7XG4gICAgICAgIHZhciBfaTE5ID0gX2U1MFtfbzQxXTtcbiAgICAgICAgaWYgKGEgPSBfaTE5ICYmIF9pMTkubW9udGhJbmRleCwgdm9pZCAwID09PSBhICYmIGwuZW5kc1dpdGgoXCJMXCIpICYmIFwiTTEzTFwiICE9IGwgJiYgXCJjb25zdHJhaW5cIiA9PT0gcikge1xuICAgICAgICAgIHZhciBfdDQ4ID0gbC5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgXCIwXCIgPT09IF90NDhbMF0gJiYgKF90NDggPSBfdDQ4LnNsaWNlKDEpKSwgX2kxOSA9IF9lNTBbX3Q0OF0sIF9pMTkgJiYgKGEgPSBfaTE5Lm1vbnRoSW5kZXgsIGwgPSBidWlsZE1vbnRoQ29kZShfdDQ4KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gYSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbm1hdGNoZWQgbW9udGggXCIuY29uY2F0KGwsIFwiIGluIENoaW5lc2UgeWVhciBcIikuY29uY2F0KG4pKTtcbiAgICAgIH0gZWxzZSBpZiAodm9pZCAwID09PSBsKSB7XG4gICAgICAgIHZhciBfZTUxID0gdGhpcy5nZXRNb250aExpc3QobiwgdCksXG4gICAgICAgICAgX280MiA9IHd0KF9lNTEpLFxuICAgICAgICAgIF9pMjAgPSBfbzQyLmxlbmd0aDtcbiAgICAgICAgXCJyZWplY3RcIiA9PT0gciA/IChSZWplY3RUb1JhbmdlKGEsIDEsIF9pMjApLCBSZWplY3RUb1JhbmdlKHMsIDEsIHRoaXMubWF4aW11bU1vbnRoTGVuZ3RoKCkpKSA6IChhID0gQ29uc3RyYWluVG9SYW5nZShhLCAxLCBfaTIwKSwgcyA9IENvbnN0cmFpblRvUmFuZ2UocywgMSwgdGhpcy5tYXhpbXVtTW9udGhMZW5ndGgoKSkpO1xuICAgICAgICB2YXIgX2QxMSA9IF9vNDIuZmluZChmdW5jdGlvbiAoX3JlZjEwKSB7XG4gICAgICAgICAgdmFyIF9yZWYxMSA9IF9zbGljZWRUb0FycmF5KF9yZWYxMCwgMiksXG4gICAgICAgICAgICBlID0gX3JlZjExWzFdO1xuICAgICAgICAgIHJldHVybiBlLm1vbnRoSW5kZXggPT09IGE7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodm9pZCAwID09PSBfZDExKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbW9udGggXCIuY29uY2F0KGEsIFwiIGluIENoaW5lc2UgeWVhciBcIikuY29uY2F0KG4pKTtcbiAgICAgICAgbCA9IGJ1aWxkTW9udGhDb2RlKF9kMTFbMF0ucmVwbGFjZShcImJpc1wiLCBcIlwiKSwgLTEgIT09IF9kMTFbMF0uaW5kZXhPZihcImJpc1wiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2U1MiA9IHRoaXMuZ2V0TW9udGhMaXN0KG4sIHQpO1xuICAgICAgICB2YXIgX3I2NiA9IGwucmVwbGFjZShcIkxcIiwgXCJiaXNcIikuc2xpY2UoMSk7XG4gICAgICAgIFwiMFwiID09PSBfcjY2WzBdICYmIChfcjY2ID0gX3I2Ni5zbGljZSgxKSk7XG4gICAgICAgIHZhciBfbzQzID0gX2U1MltfcjY2XTtcbiAgICAgICAgaWYgKCFfbzQzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVubWF0Y2hlZCBtb250aENvZGUgXCIuY29uY2F0KGwsIFwiIGluIENoaW5lc2UgeWVhciBcIikuY29uY2F0KG4pKTtcbiAgICAgICAgaWYgKGEgIT09IF9vNDMubW9udGhJbmRleCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJtb250aENvZGUgXCIuY29uY2F0KGwsIFwiIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBtb250aCBcIikuY29uY2F0KGEsIFwiIGluIENoaW5lc2UgeWVhciBcIikuY29uY2F0KG4pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZSksIHt9LCB7XG4gICAgICAgIHllYXI6IG4sXG4gICAgICAgIGVyYVllYXI6IGQsXG4gICAgICAgIG1vbnRoOiBhLFxuICAgICAgICBtb250aENvZGU6IGwsXG4gICAgICAgIGRheTogc1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDaGluZXNlQmFzZUhlbHBlcjtcbn0oSGVscGVyQmFzZSk7XG52YXIgQ2hpbmVzZUhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NoaW5lc2VCYXNlSGVscGVyKSB7XG4gIF9pbmhlcml0cyhDaGluZXNlSGVscGVyLCBfQ2hpbmVzZUJhc2VIZWxwZXIpO1xuICB2YXIgX3N1cGVyMjEgPSBfY3JlYXRlU3VwZXIoQ2hpbmVzZUhlbHBlcik7XG4gIGZ1bmN0aW9uIENoaW5lc2VIZWxwZXIoKSB7XG4gICAgdmFyIF90aGlzMjA7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoaW5lc2VIZWxwZXIpO1xuICAgIF90aGlzMjAgPSBfc3VwZXIyMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBfdGhpczIwLmlkID0gXCJjaGluZXNlXCI7XG4gICAgcmV0dXJuIF90aGlzMjA7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDaGluZXNlSGVscGVyKTtcbn0oQ2hpbmVzZUJhc2VIZWxwZXIpO1xudmFyIERhbmdpSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2hpbmVzZUJhc2VIZWxwZXIyKSB7XG4gIF9pbmhlcml0cyhEYW5naUhlbHBlciwgX0NoaW5lc2VCYXNlSGVscGVyMik7XG4gIHZhciBfc3VwZXIyMiA9IF9jcmVhdGVTdXBlcihEYW5naUhlbHBlcik7XG4gIGZ1bmN0aW9uIERhbmdpSGVscGVyKCkge1xuICAgIHZhciBfdGhpczIxO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYW5naUhlbHBlcik7XG4gICAgX3RoaXMyMSA9IF9zdXBlcjIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIF90aGlzMjEuaWQgPSBcImRhbmdpXCI7XG4gICAgcmV0dXJuIF90aGlzMjE7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhEYW5naUhlbHBlcik7XG59KENoaW5lc2VCYXNlSGVscGVyKTtcbnZhciBOb25Jc29DYWxlbmRhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vbklzb0NhbGVuZGFyKGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9uSXNvQ2FsZW5kYXIpO1xuICAgIHRoaXMuaGVscGVyID0gZTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoTm9uSXNvQ2FsZW5kYXIsIFt7XG4gICAga2V5OiBcImRhdGVGcm9tRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGVGcm9tRmllbGRzKGUsIHQsIHIpIHtcbiAgICAgIHZhciBvID0gbmV3IE9uZU9iamVjdENhY2hlKCksXG4gICAgICAgIG4gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZSwgdGhpcy5maWVsZHMoW1wiZGF5XCIsIFwibW9udGhcIiwgXCJtb250aENvZGVcIiwgXCJ5ZWFyXCJdKSwgW10pLFxuICAgICAgICBhID0gVG9UZW1wb3JhbE92ZXJmbG93KHQpLFxuICAgICAgICBfdGhpcyRoZWxwZXIkY2FsZW5kYXIgPSB0aGlzLmhlbHBlci5jYWxlbmRhclRvSXNvRGF0ZShuLCBhLCBvKSxcbiAgICAgICAgaSA9IF90aGlzJGhlbHBlciRjYWxlbmRhci55ZWFyLFxuICAgICAgICBzID0gX3RoaXMkaGVscGVyJGNhbGVuZGFyLm1vbnRoLFxuICAgICAgICBsID0gX3RoaXMkaGVscGVyJGNhbGVuZGFyLmRheSxcbiAgICAgICAgZCA9IENyZWF0ZVRlbXBvcmFsRGF0ZShpLCBzLCBsLCByKTtcbiAgICAgIHJldHVybiBvLnNldE9iamVjdChkKSwgZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieWVhck1vbnRoRnJvbUZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB5ZWFyTW9udGhGcm9tRmllbGRzKGUsIHQsIHIpIHtcbiAgICAgIHZhciBvID0gbmV3IE9uZU9iamVjdENhY2hlKCksXG4gICAgICAgIG4gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZSwgdGhpcy5maWVsZHMoW1wibW9udGhcIiwgXCJtb250aENvZGVcIiwgXCJ5ZWFyXCJdKSwgW10pLFxuICAgICAgICBhID0gVG9UZW1wb3JhbE92ZXJmbG93KHQpLFxuICAgICAgICBfdGhpcyRoZWxwZXIkY2FsZW5kYXIyID0gdGhpcy5oZWxwZXIuY2FsZW5kYXJUb0lzb0RhdGUoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG4pLCB7fSwge1xuICAgICAgICAgIGRheTogMVxuICAgICAgICB9KSwgYSwgbyksXG4gICAgICAgIGkgPSBfdGhpcyRoZWxwZXIkY2FsZW5kYXIyLnllYXIsXG4gICAgICAgIHMgPSBfdGhpcyRoZWxwZXIkY2FsZW5kYXIyLm1vbnRoLFxuICAgICAgICBsID0gX3RoaXMkaGVscGVyJGNhbGVuZGFyMi5kYXksXG4gICAgICAgIGQgPSBDcmVhdGVUZW1wb3JhbFllYXJNb250aChpLCBzLCByLCBsKTtcbiAgICAgIHJldHVybiBvLnNldE9iamVjdChkKSwgZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhEYXlGcm9tRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vbnRoRGF5RnJvbUZpZWxkcyhlLCB0LCByKSB7XG4gICAgICB2YXIgbyA9IG5ldyBPbmVPYmplY3RDYWNoZSgpLFxuICAgICAgICBuID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIHRoaXMuZmllbGRzKFtcImRheVwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwieWVhclwiXSksIFtdKSxcbiAgICAgICAgYSA9IFRvVGVtcG9yYWxPdmVyZmxvdyh0KSxcbiAgICAgICAgX3RoaXMkaGVscGVyJG1vbnRoRGF5ID0gdGhpcy5oZWxwZXIubW9udGhEYXlGcm9tRmllbGRzKG4sIGEsIG8pLFxuICAgICAgICBpID0gX3RoaXMkaGVscGVyJG1vbnRoRGF5LnllYXIsXG4gICAgICAgIHMgPSBfdGhpcyRoZWxwZXIkbW9udGhEYXkubW9udGgsXG4gICAgICAgIGwgPSBfdGhpcyRoZWxwZXIkbW9udGhEYXkuZGF5LFxuICAgICAgICBkID0gQ3JlYXRlVGVtcG9yYWxNb250aERheShzLCBsLCByLCBpKTtcbiAgICAgIHJldHVybiBvLnNldE9iamVjdChkKSwgZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpZWxkcyhlKSB7XG4gICAgICB2YXIgdCA9IGU7XG4gICAgICByZXR1cm4gVHQuY2FsbCh0LCBcInllYXJcIikgJiYgKHQgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHQpLCBbXCJlcmFcIiwgXCJlcmFZZWFyXCJdKSksIHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpZWxkS2V5c1RvSWdub3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpZWxkS2V5c1RvSWdub3JlKGUpIHtcbiAgICAgIHZhciB0ID0gbmV3IER0KCk7XG4gICAgICBmb3IgKHZhciBfcjY3ID0gMDsgX3I2NyA8IGUubGVuZ3RoOyBfcjY3KyspIHtcbiAgICAgICAgdmFyIF9vNDQgPSBlW19yNjddO1xuICAgICAgICBzd2l0Y2ggKENhbGwodnQsIHQsIFtfbzQ0XSksIF9vNDQpIHtcbiAgICAgICAgICBjYXNlIFwiZXJhXCI6XG4gICAgICAgICAgICBDYWxsKHZ0LCB0LCBbXCJlcmFZZWFyXCJdKSwgQ2FsbCh2dCwgdCwgW1wieWVhclwiXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZXJhWWVhclwiOlxuICAgICAgICAgICAgQ2FsbCh2dCwgdCwgW1wiZXJhXCJdKSwgQ2FsbCh2dCwgdCwgW1wieWVhclwiXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwieWVhclwiOlxuICAgICAgICAgICAgQ2FsbCh2dCwgdCwgW1wiZXJhXCJdKSwgQ2FsbCh2dCwgdCwgW1wiZXJhWWVhclwiXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgICAgIENhbGwodnQsIHQsIFtcIm1vbnRoQ29kZVwiXSksIHRoaXMuaGVscGVyLmVyYXNCZWdpbk1pZFllYXIgJiYgKENhbGwodnQsIHQsIFtcImVyYVwiXSksIENhbGwodnQsIHQsIFtcImVyYVllYXJcIl0pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtb250aENvZGVcIjpcbiAgICAgICAgICAgIENhbGwodnQsIHQsIFtcIm1vbnRoXCJdKSwgdGhpcy5oZWxwZXIuZXJhc0JlZ2luTWlkWWVhciAmJiAoQ2FsbCh2dCwgdCwgW1wiZXJhXCJdKSwgQ2FsbCh2dCwgdCwgW1wiZXJhWWVhclwiXSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImRheVwiOlxuICAgICAgICAgICAgdGhpcy5oZWxwZXIuZXJhc0JlZ2luTWlkWWVhciAmJiAoQ2FsbCh2dCwgdCwgW1wiZXJhXCJdKSwgQ2FsbCh2dCwgdCwgW1wiZXJhWWVhclwiXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KENhbGwoQ3QsIHQsIFtdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGVBZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0ZUFkZChlLCB0LCByLCBvLCBuLCBhLCBpKSB7XG4gICAgICB2YXIgcyA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGUpLFxuICAgICAgICBsID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShlLCBzKSxcbiAgICAgICAgZCA9IHRoaXMuaGVscGVyLmFkZENhbGVuZGFyKGwsIHtcbiAgICAgICAgICB5ZWFyczogdCxcbiAgICAgICAgICBtb250aHM6IHIsXG4gICAgICAgICAgd2Vla3M6IG8sXG4gICAgICAgICAgZGF5czogblxuICAgICAgICB9LCBhLCBzKSxcbiAgICAgICAgbSA9IHRoaXMuaGVscGVyLmNhbGVuZGFyVG9Jc29EYXRlKGQsIFwiY29uc3RyYWluXCIsIHMpLFxuICAgICAgICBjID0gbS55ZWFyLFxuICAgICAgICBoID0gbS5tb250aCxcbiAgICAgICAgdSA9IG0uZGF5LFxuICAgICAgICBUID0gQ3JlYXRlVGVtcG9yYWxEYXRlKGMsIGgsIHUsIGkpO1xuICAgICAgcmV0dXJuIG5ldyBPbmVPYmplY3RDYWNoZShzKS5zZXRPYmplY3QoVCksIFQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGVVbnRpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRlVW50aWwoZSwgdCwgcikge1xuICAgICAgdmFyIG8gPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChlKSxcbiAgICAgICAgbiA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KHQpLFxuICAgICAgICBhID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShlLCBvKSxcbiAgICAgICAgaSA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUodCwgbik7XG4gICAgICByZXR1cm4gdGhpcy5oZWxwZXIudW50aWxDYWxlbmRhcihhLCBpLCByLCBvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB5ZWFyKGUpIHtcbiAgICAgIHZhciB0ID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QoZSk7XG4gICAgICByZXR1cm4gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZShlLCB0KS55ZWFyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aChlKSB7XG4gICAgICB2YXIgdCA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGUpO1xuICAgICAgcmV0dXJuIHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZSwgdCkubW9udGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXkoZSkge1xuICAgICAgdmFyIHQgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChlKTtcbiAgICAgIHJldHVybiB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGUsIHQpLmRheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVyYShlKSB7XG4gICAgICBpZiAoIXRoaXMuaGVscGVyLmhhc0VyYSkgcmV0dXJuO1xuICAgICAgdmFyIHQgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChlKTtcbiAgICAgIHJldHVybiB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKGUsIHQpLmVyYTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJhWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcmFZZWFyKGUpIHtcbiAgICAgIGlmICghdGhpcy5oZWxwZXIuaGFzRXJhKSByZXR1cm47XG4gICAgICB2YXIgdCA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGUpO1xuICAgICAgcmV0dXJuIHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZSwgdCkuZXJhWWVhcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhDb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vbnRoQ29kZShlKSB7XG4gICAgICB2YXIgdCA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGUpO1xuICAgICAgcmV0dXJuIHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZSwgdCkubW9udGhDb2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlPZldlZWtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF5T2ZXZWVrKGUpIHtcbiAgICAgIHJldHVybiBPdC5pc284NjAxLmRheU9mV2VlayhlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5T2ZZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRheU9mWWVhcihlKSB7XG4gICAgICB2YXIgdCA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KGUpLFxuICAgICAgICByID0gdGhpcy5oZWxwZXIuaXNvVG9DYWxlbmRhckRhdGUoZSwgdCksXG4gICAgICAgIG8gPSB0aGlzLmhlbHBlci5zdGFydE9mQ2FsZW5kYXJZZWFyKHIpO1xuICAgICAgcmV0dXJuIHRoaXMuaGVscGVyLmNhbGVuZGFyRGF5c1VudGlsKG8sIHIsIHQpICsgMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla09mWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3ZWVrT2ZZZWFyKGUpIHtcbiAgICAgIHJldHVybiBPdC5pc284NjAxLndlZWtPZlllYXIoZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInllYXJPZldlZWtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geWVhck9mV2VlayhlKSB7XG4gICAgICByZXR1cm4gT3QuaXNvODYwMS55ZWFyT2ZXZWVrKGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlzSW5XZWVrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRheXNJbldlZWsoZSkge1xuICAgICAgcmV0dXJuIE90Lmlzbzg2MDEuZGF5c0luV2VlayhlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luTW9udGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF5c0luTW9udGgoZSkge1xuICAgICAgdmFyIHQgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChlKSxcbiAgICAgICAgciA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZSwgdCksXG4gICAgICAgIG8gPSB0aGlzLmhlbHBlci5tYXhpbXVtTW9udGhMZW5ndGgocik7XG4gICAgICBpZiAobyA9PT0gdGhpcy5oZWxwZXIubWluaW11bU1vbnRoTGVuZ3RoKHIpKSByZXR1cm4gbztcbiAgICAgIHZhciBuID0gdGhpcy5oZWxwZXIuc3RhcnRPZkNhbGVuZGFyTW9udGgociksXG4gICAgICAgIGEgPSB0aGlzLmhlbHBlci5hZGRNb250aHNDYWxlbmRhcihuLCAxLCBcImNvbnN0cmFpblwiLCB0KTtcbiAgICAgIHJldHVybiB0aGlzLmhlbHBlci5jYWxlbmRhckRheXNVbnRpbChuLCBhLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXlzSW5ZZWFyKGUpIHtcbiAgICAgIHZhciB0ID0gZTtcbiAgICAgIEhhc1Nsb3QodCwgaSkgfHwgKHQgPSBUb1RlbXBvcmFsRGF0ZSh0KSk7XG4gICAgICB2YXIgciA9IE9uZU9iamVjdENhY2hlLmdldENhY2hlRm9yT2JqZWN0KHQpLFxuICAgICAgICBvID0gdGhpcy5oZWxwZXIudGVtcG9yYWxUb0NhbGVuZGFyRGF0ZSh0LCByKSxcbiAgICAgICAgbiA9IHRoaXMuaGVscGVyLnN0YXJ0T2ZDYWxlbmRhclllYXIobyksXG4gICAgICAgIGEgPSB0aGlzLmhlbHBlci5hZGRDYWxlbmRhcihuLCB7XG4gICAgICAgICAgeWVhcnM6IDFcbiAgICAgICAgfSwgXCJjb25zdHJhaW5cIiwgcik7XG4gICAgICByZXR1cm4gdGhpcy5oZWxwZXIuY2FsZW5kYXJEYXlzVW50aWwobiwgYSwgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoc0luWWVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aHNJblllYXIoZSkge1xuICAgICAgdmFyIHQgPSBPbmVPYmplY3RDYWNoZS5nZXRDYWNoZUZvck9iamVjdChlKSxcbiAgICAgICAgciA9IHRoaXMuaGVscGVyLnRlbXBvcmFsVG9DYWxlbmRhckRhdGUoZSwgdCk7XG4gICAgICByZXR1cm4gdGhpcy5oZWxwZXIubW9udGhzSW5ZZWFyKHIsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbkxlYXBZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluTGVhcFllYXIoZSkge1xuICAgICAgdmFyIHQgPSBlO1xuICAgICAgSGFzU2xvdCh0LCBpKSB8fCAodCA9IFRvVGVtcG9yYWxEYXRlKHQpKTtcbiAgICAgIHZhciByID0gT25lT2JqZWN0Q2FjaGUuZ2V0Q2FjaGVGb3JPYmplY3QodCksXG4gICAgICAgIG8gPSB0aGlzLmhlbHBlci50ZW1wb3JhbFRvQ2FsZW5kYXJEYXRlKHQsIHIpO1xuICAgICAgcmV0dXJuIHRoaXMuaGVscGVyLmluTGVhcFllYXIobywgcik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOb25Jc29DYWxlbmRhcjtcbn0oKTtcbmZvciAodmFyIF9pMjEgPSAwLCBfYXJyNyA9IFtIZWJyZXdIZWxwZXIsIFBlcnNpYW5IZWxwZXIsIEV0aGlvcGljSGVscGVyLCBFdGhpb2FhSGVscGVyLCBDb3B0aWNIZWxwZXIsIENoaW5lc2VIZWxwZXIsIERhbmdpSGVscGVyLCBSb2NIZWxwZXIsIEluZGlhbkhlbHBlciwgQnVkZGhpc3RIZWxwZXIsIEdyZWdvcnlIZWxwZXIsIEphcGFuZXNlSGVscGVyLCBJc2xhbWljSGVscGVyLCBJc2xhbWljVW1hbHF1cmFIZWxwZXIsIElzbGFtaWNUYmxhSGVscGVyLCBJc2xhbWljQ2l2aWxIZWxwZXIsIElzbGFtaWNSZ3NhSGVscGVyLCBJc2xhbWljQ2NIZWxwZXJdOyBfaTIxIDwgX2FycjcubGVuZ3RoOyBfaTIxKyspIHtcbiAgdmFyIF9lNTMgPSBfYXJyN1tfaTIxXTtcbiAgdmFyIF90NDkgPSBuZXcgX2U1MygpO1xuICBPdFtfdDQ5LmlkXSA9IG5ldyBOb25Jc29DYWxlbmRhcihfdDQ5KTtcbn1cbnZhciBQbGFpbkRhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbGFpbkRhdGUoZSwgdCwgcikge1xuICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcImlzbzg2MDFcIjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxhaW5EYXRlKTtcbiAgICBDcmVhdGVUZW1wb3JhbERhdGVTbG90cyh0aGlzLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihlKSwgVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24odCksIFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKHIpLCBUb1RlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWUobykpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhQbGFpbkRhdGUsIFt7XG4gICAga2V5OiBcImNhbGVuZGFySWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoR2V0U2xvdCh0aGlzLCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVyYVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJFcmEoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVyYVllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRXJhWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJZZWFyKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aChHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhDb2RlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoQ29kZShHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheShHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5T2ZXZWVrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheU9mV2VlayhHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5T2ZZZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheU9mWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla09mWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJXZWVrT2ZZZWFyKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ5ZWFyT2ZXZWVrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhclllYXJPZldlZWsoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJbldlZWtcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luV2VlayhHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luTW9udGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luTW9udGgoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJblllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhzSW5ZZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoc0luWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5MZWFwWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJJbkxlYXBZZWFyKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF93aXRoKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKCFJc09iamVjdChlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgYXJndW1lbnRcIik7XG4gICAgICBSZWplY3RUZW1wb3JhbExpa2VPYmplY3QoZSk7XG4gICAgICB2YXIgciA9IEdldE9wdGlvbnNPYmplY3QodCksXG4gICAgICAgIG8gPSBHZXRTbG90KHRoaXMsIHApLFxuICAgICAgICBuID0gQ2FsZW5kYXJGaWVsZHMobywgW1wiZGF5XCIsIFwibW9udGhcIiwgXCJtb250aENvZGVcIiwgXCJ5ZWFyXCJdKTtcbiAgICAgIHZhciBhID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIG4sIFtdKTtcbiAgICAgIHJldHVybiBhID0gQ2FsZW5kYXJNZXJnZUZpZWxkcyhvLCBhLCBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoZSwgbiwgXCJwYXJ0aWFsXCIpKSwgYSA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyhhLCBuLCBbXSksIENhbGVuZGFyRGF0ZUZyb21GaWVsZHMobywgYSwgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhDYWxlbmRhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQ2FsZW5kYXIoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShlKTtcbiAgICAgIHJldHVybiBuZXcgUGxhaW5EYXRlKEdldFNsb3QodGhpcywgaSksIEdldFNsb3QodGhpcywgcyksIEdldFNsb3QodGhpcywgbCksIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHIgPSBUb1RlbXBvcmFsRHVyYXRpb24oZSksXG4gICAgICAgIG8gPSBHZXRPcHRpb25zT2JqZWN0KHQpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF0ZUFkZChHZXRTbG90KHRoaXMsIHApLCB0aGlzLCByLCBvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3VidHJhY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgciA9IENyZWF0ZU5lZ2F0ZWRUZW1wb3JhbER1cmF0aW9uKFRvVGVtcG9yYWxEdXJhdGlvbihlKSksXG4gICAgICAgIG8gPSBHZXRPcHRpb25zT2JqZWN0KHQpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF0ZUFkZChHZXRTbG90KHRoaXMsIHApLCB0aGlzLCByLCBvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW50aWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW50aWwoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsUGxhaW5EYXRlKFwidW50aWxcIiwgdGhpcywgZSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpbmNlKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIERpZmZlcmVuY2VUZW1wb3JhbFBsYWluRGF0ZShcInNpbmNlXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsRGF0ZShlKTtcbiAgICAgIGZvciAodmFyIF9pMjIgPSAwLCBfYXJyOCA9IFtpLCBzLCBsXTsgX2kyMiA8IF9hcnI4Lmxlbmd0aDsgX2kyMisrKSB7XG4gICAgICAgIHZhciBfZTU0ID0gX2FycjhbX2kyMl07XG4gICAgICAgIGlmIChHZXRTbG90KHRoaXMsIF9lNTQpICE9PSBHZXRTbG90KHQsIF9lNTQpKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ2FsZW5kYXJFcXVhbHMoR2V0U2xvdCh0aGlzLCBwKSwgR2V0U2xvdCh0LCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRvU3RyaW5nKHRoaXMsIFRvQ2FsZW5kYXJOYW1lT3B0aW9uKEdldE9wdGlvbnNPYmplY3QoZSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0xvY2FsZVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZyhlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBuZXcgaHQoZSwgdCkuZm9ybWF0KHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZU9mXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidXNlIGNvbXBhcmUoKSBvciBlcXVhbHMoKSB0byBjb21wYXJlIFRlbXBvcmFsLlBsYWluRGF0ZVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9QbGFpbkRhdGVUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUGxhaW5EYXRlVGltZShlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciB0ID0gR2V0U2xvdCh0aGlzLCBpKSxcbiAgICAgICAgciA9IEdldFNsb3QodGhpcywgcyksXG4gICAgICAgIG8gPSBHZXRTbG90KHRoaXMsIGwpLFxuICAgICAgICBuID0gR2V0U2xvdCh0aGlzLCBwKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IGUpIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHQsIHIsIG8sIDAsIDAsIDAsIDAsIDAsIDAsIG4pO1xuICAgICAgdmFyIGEgPSBUb1RlbXBvcmFsVGltZShlKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbERhdGVUaW1lKHQsIHIsIG8sIEdldFNsb3QoYSwgZCksIEdldFNsb3QoYSwgbSksIEdldFNsb3QoYSwgYyksIEdldFNsb3QoYSwgaCksIEdldFNsb3QoYSwgdSksIEdldFNsb3QoYSwgVCksIG4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1pvbmVkRGF0ZVRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9ab25lZERhdGVUaW1lKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQsIHI7XG4gICAgICBpZiAoSXNPYmplY3QoZSkpIHtcbiAgICAgICAgaWYgKElzVGVtcG9yYWxUaW1lWm9uZShlKSkgdCA9IGU7ZWxzZSB7XG4gICAgICAgICAgdmFyIF9vNDUgPSBlLnRpbWVab25lO1xuICAgICAgICAgIHZvaWQgMCA9PT0gX280NSA/IHQgPSBUb1RlbXBvcmFsVGltZVpvbmVTbG90VmFsdWUoZSkgOiAodCA9IFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZShfbzQ1KSwgciA9IGUucGxhaW5UaW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHQgPSBUb1RlbXBvcmFsVGltZVpvbmVTbG90VmFsdWUoZSk7XG4gICAgICB2YXIgbyA9IEdldFNsb3QodGhpcywgaSksXG4gICAgICAgIGEgPSBHZXRTbG90KHRoaXMsIHMpLFxuICAgICAgICBmID0gR2V0U2xvdCh0aGlzLCBsKSxcbiAgICAgICAgeSA9IEdldFNsb3QodGhpcywgcCk7XG4gICAgICB2YXIgSSA9IDAsXG4gICAgICAgIFMgPSAwLFxuICAgICAgICBnID0gMCxcbiAgICAgICAgdyA9IDAsXG4gICAgICAgIEQgPSAwLFxuICAgICAgICBHID0gMDtcbiAgICAgIHZvaWQgMCAhPT0gciAmJiAociA9IFRvVGVtcG9yYWxUaW1lKHIpLCBJID0gR2V0U2xvdChyLCBkKSwgUyA9IEdldFNsb3QociwgbSksIGcgPSBHZXRTbG90KHIsIGMpLCB3ID0gR2V0U2xvdChyLCBoKSwgRCA9IEdldFNsb3QociwgdSksIEcgPSBHZXRTbG90KHIsIFQpKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChHZXRJbnN0YW50Rm9yKHQsIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUobywgYSwgZiwgSSwgUywgZywgdywgRCwgRywgeSksIFwiY29tcGF0aWJsZVwiKSwgbiksIHQsIHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1BsYWluWWVhck1vbnRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUGxhaW5ZZWFyTW9udGgoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciBlID0gR2V0U2xvdCh0aGlzLCBwKTtcbiAgICAgIHJldHVybiBDYWxlbmRhclllYXJNb250aEZyb21GaWVsZHMoZSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIENhbGVuZGFyRmllbGRzKGUsIFtcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0pLCBbXSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1BsYWluTW9udGhEYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9QbGFpbk1vbnRoRGF5KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgZSA9IEdldFNsb3QodGhpcywgcCk7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aERheUZyb21GaWVsZHMoZSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIENhbGVuZGFyRmllbGRzKGUsIFtcImRheVwiLCBcIm1vbnRoQ29kZVwiXSksIFtdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldElTT0ZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJU09GaWVsZHMoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGVuZGFyOiBHZXRTbG90KHRoaXMsIHApLFxuICAgICAgICBpc29EYXk6IEdldFNsb3QodGhpcywgbCksXG4gICAgICAgIGlzb01vbnRoOiBHZXRTbG90KHRoaXMsIHMpLFxuICAgICAgICBpc29ZZWFyOiBHZXRTbG90KHRoaXMsIGkpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWxlbmRhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWxlbmRhcigpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRvVGVtcG9yYWxDYWxlbmRhck9iamVjdChHZXRTbG90KHRoaXMsIHApKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20oZSwgdCkge1xuICAgICAgdmFyIHIgPSBHZXRPcHRpb25zT2JqZWN0KHQpO1xuICAgICAgcmV0dXJuIElzVGVtcG9yYWxEYXRlKGUpID8gKFRvVGVtcG9yYWxPdmVyZmxvdyhyKSwgQ3JlYXRlVGVtcG9yYWxEYXRlKEdldFNsb3QoZSwgaSksIEdldFNsb3QoZSwgcyksIEdldFNsb3QoZSwgbCksIEdldFNsb3QoZSwgcCkpKSA6IFRvVGVtcG9yYWxEYXRlKGUsIHIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmUoZSwgdCkge1xuICAgICAgdmFyIHIgPSBUb1RlbXBvcmFsRGF0ZShlKSxcbiAgICAgICAgbyA9IFRvVGVtcG9yYWxEYXRlKHQpO1xuICAgICAgcmV0dXJuIENvbXBhcmVJU09EYXRlKEdldFNsb3QociwgaSksIEdldFNsb3QociwgcyksIEdldFNsb3QociwgbCksIEdldFNsb3QobywgaSksIEdldFNsb3QobywgcyksIEdldFNsb3QobywgbCkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUGxhaW5EYXRlO1xufSgpO1xuTWFrZUludHJpbnNpY0NsYXNzKFBsYWluRGF0ZSwgXCJUZW1wb3JhbC5QbGFpbkRhdGVcIik7XG52YXIgUGxhaW5EYXRlVGltZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBsYWluRGF0ZVRpbWUoZSwgdCwgcikge1xuICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAwO1xuICAgIHZhciBhID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiAwO1xuICAgIHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiAwO1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aCA+IDggJiYgYXJndW1lbnRzWzhdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbOF0gOiAwO1xuICAgIHZhciBkID0gYXJndW1lbnRzLmxlbmd0aCA+IDkgJiYgYXJndW1lbnRzWzldICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbOV0gOiBcImlzbzg2MDFcIjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxhaW5EYXRlVGltZSk7XG4gICAgQ3JlYXRlVGVtcG9yYWxEYXRlVGltZVNsb3RzKHRoaXMsIFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKGUpLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbih0KSwgVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24ociksIHZvaWQgMCA9PT0gbyA/IDAgOiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihvKSwgdm9pZCAwID09PSBuID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKG4pLCB2b2lkIDAgPT09IGEgPyAwIDogVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24oYSksIHZvaWQgMCA9PT0gaSA/IDAgOiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihpKSwgdm9pZCAwID09PSBzID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKHMpLCB2b2lkIDAgPT09IGwgPyAwIDogVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24obCksIFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShkKSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFBsYWluRGF0ZVRpbWUsIFt7XG4gICAga2V5OiBcImNhbGVuZGFySWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKEdldFNsb3QodGhpcywgcCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ5ZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJZZWFyKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGgoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoQ29kZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheShHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaG91clwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pbnV0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgbSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlY29uZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgYyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWljcm9zZWNvbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIHUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuYW5vc2Vjb25kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBUKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJhXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJFcmEoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVyYVllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckVyYVllYXIoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheU9mV2Vla1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5T2ZXZWVrKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlPZlllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheU9mWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla09mWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyV2Vla09mWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieWVhck9mV2Vla1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyWWVhck9mV2VlayhHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luV2Vla1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luV2VlayhHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c0luTW9udGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheXNJbk1vbnRoKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aHNJblllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoc0luWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5MZWFwWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFySW5MZWFwWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfd2l0aChlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICAgIFJlamVjdFRlbXBvcmFsTGlrZU9iamVjdChlKTtcbiAgICAgIHZhciByID0gR2V0T3B0aW9uc09iamVjdCh0KSxcbiAgICAgICAgbyA9IEdldFNsb3QodGhpcywgcCksXG4gICAgICAgIG4gPSBDYWxlbmRhckZpZWxkcyhvLCBbXCJkYXlcIiwgXCJob3VyXCIsIFwibWljcm9zZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiLCBcIm1pbnV0ZVwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwibmFub3NlY29uZFwiLCBcInNlY29uZFwiLCBcInllYXJcIl0pO1xuICAgICAgdmFyIGEgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModGhpcywgbiwgW10pO1xuICAgICAgYSA9IENhbGVuZGFyTWVyZ2VGaWVsZHMobywgYSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIG4sIFwicGFydGlhbFwiKSksIGEgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoYSwgbiwgW10pO1xuICAgICAgdmFyIF9JbnRlcnByZXRUZW1wb3JhbERhdDQgPSBJbnRlcnByZXRUZW1wb3JhbERhdGVUaW1lRmllbGRzKG8sIGEsIHIpLFxuICAgICAgICBpID0gX0ludGVycHJldFRlbXBvcmFsRGF0NC55ZWFyLFxuICAgICAgICBzID0gX0ludGVycHJldFRlbXBvcmFsRGF0NC5tb250aCxcbiAgICAgICAgbCA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDQuZGF5LFxuICAgICAgICBkID0gX0ludGVycHJldFRlbXBvcmFsRGF0NC5ob3VyLFxuICAgICAgICBtID0gX0ludGVycHJldFRlbXBvcmFsRGF0NC5taW51dGUsXG4gICAgICAgIGMgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ0LnNlY29uZCxcbiAgICAgICAgaCA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDQubWlsbGlzZWNvbmQsXG4gICAgICAgIHUgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ0Lm1pY3Jvc2Vjb25kLFxuICAgICAgICBUID0gX0ludGVycHJldFRlbXBvcmFsRGF0NC5uYW5vc2Vjb25kO1xuICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVCwgbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhQbGFpblRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aFBsYWluVGltZShlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEdldFNsb3QodGhpcywgaSksXG4gICAgICAgIHIgPSBHZXRTbG90KHRoaXMsIHMpLFxuICAgICAgICBvID0gR2V0U2xvdCh0aGlzLCBsKSxcbiAgICAgICAgbiA9IEdldFNsb3QodGhpcywgcCk7XG4gICAgICBpZiAodm9pZCAwID09PSBlKSByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh0LCByLCBvLCAwLCAwLCAwLCAwLCAwLCAwLCBuKTtcbiAgICAgIHZhciBhID0gVG9UZW1wb3JhbFRpbWUoZSk7XG4gICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZSh0LCByLCBvLCBHZXRTbG90KGEsIGQpLCBHZXRTbG90KGEsIG0pLCBHZXRTbG90KGEsIGMpLCBHZXRTbG90KGEsIGgpLCBHZXRTbG90KGEsIHUpLCBHZXRTbG90KGEsIFQpLCBuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFBsYWluRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoUGxhaW5EYXRlKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciB0ID0gVG9UZW1wb3JhbERhdGUoZSksXG4gICAgICAgIHIgPSBHZXRTbG90KHQsIGkpLFxuICAgICAgICBvID0gR2V0U2xvdCh0LCBzKSxcbiAgICAgICAgbiA9IEdldFNsb3QodCwgbCk7XG4gICAgICB2YXIgYSA9IEdldFNsb3QodCwgcCk7XG4gICAgICB2YXIgZiA9IEdldFNsb3QodGhpcywgZCksXG4gICAgICAgIHkgPSBHZXRTbG90KHRoaXMsIG0pLFxuICAgICAgICBJID0gR2V0U2xvdCh0aGlzLCBjKSxcbiAgICAgICAgUyA9IEdldFNsb3QodGhpcywgaCksXG4gICAgICAgIGcgPSBHZXRTbG90KHRoaXMsIHUpLFxuICAgICAgICB3ID0gR2V0U2xvdCh0aGlzLCBUKTtcbiAgICAgIHJldHVybiBhID0gQ29uc29saWRhdGVDYWxlbmRhcnMoR2V0U2xvdCh0aGlzLCBwKSwgYSksIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUociwgbywgbiwgZiwgeSwgSSwgUywgZywgdywgYSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhDYWxlbmRhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQ2FsZW5kYXIoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsQ2FsZW5kYXJTbG90VmFsdWUoZSk7XG4gICAgICByZXR1cm4gbmV3IFBsYWluRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBpKSwgR2V0U2xvdCh0aGlzLCBzKSwgR2V0U2xvdCh0aGlzLCBsKSwgR2V0U2xvdCh0aGlzLCBkKSwgR2V0U2xvdCh0aGlzLCBtKSwgR2V0U2xvdCh0aGlzLCBjKSwgR2V0U2xvdCh0aGlzLCBoKSwgR2V0U2xvdCh0aGlzLCB1KSwgR2V0U2xvdCh0aGlzLCBUKSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tUGxhaW5EYXRlVGltZShcImFkZFwiLCB0aGlzLCBlLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3VidHJhY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tUGxhaW5EYXRlVGltZShcInN1YnRyYWN0XCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnRpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnRpbChlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsUGxhaW5EYXRlVGltZShcInVudGlsXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaW5jZShlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsUGxhaW5EYXRlVGltZShcInNpbmNlXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3VuZChlKSB7XG4gICAgICB2YXIgX1JvdW5kSVNPRGF0ZVRpbWUyO1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbnMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgdmFyIHQgPSBcInN0cmluZ1wiID09IHR5cGVvZiBlID8gQ3JlYXRlT25lUHJvcE9iamVjdChcInNtYWxsZXN0VW5pdFwiLCBlKSA6IEdldE9wdGlvbnNPYmplY3QoZSksXG4gICAgICAgIHIgPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQodCksXG4gICAgICAgIG8gPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKHQsIFwiaGFsZkV4cGFuZFwiKSxcbiAgICAgICAgbiA9IEdldFRlbXBvcmFsVW5pdCh0LCBcInNtYWxsZXN0VW5pdFwiLCBcInRpbWVcIiwgSGUsIFtcImRheVwiXSksXG4gICAgICAgIGEgPSB7XG4gICAgICAgICAgZGF5OiAxLFxuICAgICAgICAgIGhvdXI6IDI0LFxuICAgICAgICAgIG1pbnV0ZTogNjAsXG4gICAgICAgICAgc2Vjb25kOiA2MCxcbiAgICAgICAgICBtaWxsaXNlY29uZDogMWUzLFxuICAgICAgICAgIG1pY3Jvc2Vjb25kOiAxZTMsXG4gICAgICAgICAgbmFub3NlY29uZDogMWUzXG4gICAgICAgIH1bbl07XG4gICAgICBWYWxpZGF0ZVRlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQociwgYSwgMSA9PT0gYSk7XG4gICAgICB2YXIgZiA9IEdldFNsb3QodGhpcywgaSksXG4gICAgICAgIHkgPSBHZXRTbG90KHRoaXMsIHMpLFxuICAgICAgICBJID0gR2V0U2xvdCh0aGlzLCBsKSxcbiAgICAgICAgUyA9IEdldFNsb3QodGhpcywgZCksXG4gICAgICAgIGcgPSBHZXRTbG90KHRoaXMsIG0pLFxuICAgICAgICB3ID0gR2V0U2xvdCh0aGlzLCBjKSxcbiAgICAgICAgRCA9IEdldFNsb3QodGhpcywgaCksXG4gICAgICAgIEcgPSBHZXRTbG90KHRoaXMsIHUpLFxuICAgICAgICB2ID0gR2V0U2xvdCh0aGlzLCBUKTtcbiAgICAgIHJldHVybiAoX1JvdW5kSVNPRGF0ZVRpbWUyID0gUm91bmRJU09EYXRlVGltZShmLCB5LCBJLCBTLCBnLCB3LCBELCBHLCB2LCByLCBuLCBvKSwgZiA9IF9Sb3VuZElTT0RhdGVUaW1lMi55ZWFyLCB5ID0gX1JvdW5kSVNPRGF0ZVRpbWUyLm1vbnRoLCBJID0gX1JvdW5kSVNPRGF0ZVRpbWUyLmRheSwgUyA9IF9Sb3VuZElTT0RhdGVUaW1lMi5ob3VyLCBnID0gX1JvdW5kSVNPRGF0ZVRpbWUyLm1pbnV0ZSwgdyA9IF9Sb3VuZElTT0RhdGVUaW1lMi5zZWNvbmQsIEQgPSBfUm91bmRJU09EYXRlVGltZTIubWlsbGlzZWNvbmQsIEcgPSBfUm91bmRJU09EYXRlVGltZTIubWljcm9zZWNvbmQsIHYgPSBfUm91bmRJU09EYXRlVGltZTIubmFub3NlY29uZCksIENyZWF0ZVRlbXBvcmFsRGF0ZVRpbWUoZiwgeSwgSSwgUywgZywgdywgRCwgRywgdiwgR2V0U2xvdCh0aGlzLCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxdWFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHMoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsRGF0ZVRpbWUoZSk7XG4gICAgICBmb3IgKHZhciBfaTIzID0gMCwgX2FycjkgPSBbaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVF07IF9pMjMgPCBfYXJyOS5sZW5ndGg7IF9pMjMrKykge1xuICAgICAgICB2YXIgX2U1NSA9IF9hcnI5W19pMjNdO1xuICAgICAgICBpZiAoR2V0U2xvdCh0aGlzLCBfZTU1KSAhPT0gR2V0U2xvdCh0LCBfZTU1KSkgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENhbGVuZGFyRXF1YWxzKEdldFNsb3QodGhpcywgcCksIEdldFNsb3QodCwgcCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEdldE9wdGlvbnNPYmplY3QoZSksXG4gICAgICAgIHIgPSBUb0NhbGVuZGFyTmFtZU9wdGlvbih0KSxcbiAgICAgICAgbyA9IFRvRnJhY3Rpb25hbFNlY29uZERpZ2l0cyh0KSxcbiAgICAgICAgbiA9IFRvVGVtcG9yYWxSb3VuZGluZ01vZGUodCwgXCJ0cnVuY1wiKSxcbiAgICAgICAgYSA9IEdldFRlbXBvcmFsVW5pdCh0LCBcInNtYWxsZXN0VW5pdFwiLCBcInRpbWVcIiwgdm9pZCAwKTtcbiAgICAgIGlmIChcImhvdXJcIiA9PT0gYSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NtYWxsZXN0VW5pdCBtdXN0IGJlIGEgdGltZSB1bml0IG90aGVyIHRoYW4gXCJob3VyXCInKTtcbiAgICAgIHZhciBfVG9TZWNvbmRzU3RyaW5nUHJlY2kyID0gVG9TZWNvbmRzU3RyaW5nUHJlY2lzaW9uUmVjb3JkKGEsIG8pLFxuICAgICAgICBpID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpMi5wcmVjaXNpb24sXG4gICAgICAgIHMgPSBfVG9TZWNvbmRzU3RyaW5nUHJlY2kyLnVuaXQsXG4gICAgICAgIGwgPSBfVG9TZWNvbmRzU3RyaW5nUHJlY2kyLmluY3JlbWVudDtcbiAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9TdHJpbmcodGhpcywgaSwgciwge1xuICAgICAgICB1bml0OiBzLFxuICAgICAgICBpbmNyZW1lbnQ6IGwsXG4gICAgICAgIHJvdW5kaW5nTW9kZTogblxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVGVtcG9yYWxEYXRlVGltZVRvU3RyaW5nKHRoaXMsIFwiYXV0b1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9Mb2NhbGVTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIG5ldyBodChlLCB0KS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlT2ZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1c2UgY29tcGFyZSgpIG9yIGVxdWFscygpIHRvIGNvbXBhcmUgVGVtcG9yYWwuUGxhaW5EYXRlVGltZVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9ab25lZERhdGVUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvWm9uZWREYXRlVGltZShlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgciA9IFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZShlKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChHZXRJbnN0YW50Rm9yKHIsIHRoaXMsIFRvVGVtcG9yYWxEaXNhbWJpZ3VhdGlvbihHZXRPcHRpb25zT2JqZWN0KHQpKSksIG4pLCByLCBHZXRTbG90KHRoaXMsIHApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9QbGFpbkRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9QbGFpbkRhdGUoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVGVtcG9yYWxEYXRlVGltZVRvRGF0ZSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9QbGFpblllYXJNb250aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1BsYWluWWVhck1vbnRoKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIGUgPSBHZXRTbG90KHRoaXMsIHApO1xuICAgICAgcmV0dXJuIENhbGVuZGFyWWVhck1vbnRoRnJvbUZpZWxkcyhlLCBQcmVwYXJlVGVtcG9yYWxGaWVsZHModGhpcywgQ2FsZW5kYXJGaWVsZHMoZSwgW1wibW9udGhDb2RlXCIsIFwieWVhclwiXSksIFtdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvUGxhaW5Nb250aERheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1BsYWluTW9udGhEYXkoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgZSA9IEdldFNsb3QodGhpcywgcCk7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aERheUZyb21GaWVsZHMoZSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIENhbGVuZGFyRmllbGRzKGUsIFtcImRheVwiLCBcIm1vbnRoQ29kZVwiXSksIFtdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvUGxhaW5UaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUGxhaW5UaW1lKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb1RpbWUodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldElTT0ZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJU09GaWVsZHMoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWxlbmRhcjogR2V0U2xvdCh0aGlzLCBwKSxcbiAgICAgICAgaXNvRGF5OiBHZXRTbG90KHRoaXMsIGwpLFxuICAgICAgICBpc29Ib3VyOiBHZXRTbG90KHRoaXMsIGQpLFxuICAgICAgICBpc29NaWNyb3NlY29uZDogR2V0U2xvdCh0aGlzLCB1KSxcbiAgICAgICAgaXNvTWlsbGlzZWNvbmQ6IEdldFNsb3QodGhpcywgaCksXG4gICAgICAgIGlzb01pbnV0ZTogR2V0U2xvdCh0aGlzLCBtKSxcbiAgICAgICAgaXNvTW9udGg6IEdldFNsb3QodGhpcywgcyksXG4gICAgICAgIGlzb05hbm9zZWNvbmQ6IEdldFNsb3QodGhpcywgVCksXG4gICAgICAgIGlzb1NlY29uZDogR2V0U2xvdCh0aGlzLCBjKSxcbiAgICAgICAgaXNvWWVhcjogR2V0U2xvdCh0aGlzLCBpKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FsZW5kYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FsZW5kYXIoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVG9UZW1wb3JhbENhbGVuZGFyT2JqZWN0KEdldFNsb3QodGhpcywgcCkpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbShlLCB0KSB7XG4gICAgICB2YXIgciA9IEdldE9wdGlvbnNPYmplY3QodCk7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbERhdGVUaW1lKGUpID8gKFRvVGVtcG9yYWxPdmVyZmxvdyhyKSwgQ3JlYXRlVGVtcG9yYWxEYXRlVGltZShHZXRTbG90KGUsIGkpLCBHZXRTbG90KGUsIHMpLCBHZXRTbG90KGUsIGwpLCBHZXRTbG90KGUsIGQpLCBHZXRTbG90KGUsIG0pLCBHZXRTbG90KGUsIGMpLCBHZXRTbG90KGUsIGgpLCBHZXRTbG90KGUsIHUpLCBHZXRTbG90KGUsIFQpLCBHZXRTbG90KGUsIHApKSkgOiBUb1RlbXBvcmFsRGF0ZVRpbWUoZSwgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBhcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZShlLCB0KSB7XG4gICAgICB2YXIgciA9IFRvVGVtcG9yYWxEYXRlVGltZShlKSxcbiAgICAgICAgbyA9IFRvVGVtcG9yYWxEYXRlVGltZSh0KTtcbiAgICAgIGZvciAodmFyIF9pMjQgPSAwLCBfYXJyMTAgPSBbaSwgcywgbCwgZCwgbSwgYywgaCwgdSwgVF07IF9pMjQgPCBfYXJyMTAubGVuZ3RoOyBfaTI0KyspIHtcbiAgICAgICAgdmFyIF9lNTYgPSBfYXJyMTBbX2kyNF07XG4gICAgICAgIHZhciBfdDUwID0gR2V0U2xvdChyLCBfZTU2KSxcbiAgICAgICAgICBfbjI3ID0gR2V0U2xvdChvLCBfZTU2KTtcbiAgICAgICAgaWYgKF90NTAgIT09IF9uMjcpIHJldHVybiBDb21wYXJpc29uUmVzdWx0KF90NTAgLSBfbjI3KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUGxhaW5EYXRlVGltZTtcbn0oKTtcbk1ha2VJbnRyaW5zaWNDbGFzcyhQbGFpbkRhdGVUaW1lLCBcIlRlbXBvcmFsLlBsYWluRGF0ZVRpbWVcIik7XG52YXIgRHVyYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEdXJhdGlvbigpIHtcbiAgICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgICB2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogMDtcbiAgICB2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogMDtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGggPiA4ICYmIGFyZ3VtZW50c1s4XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzhdIDogMDtcbiAgICB2YXIgZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA5ICYmIGFyZ3VtZW50c1s5XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzldIDogMDtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHVyYXRpb24pO1xuICAgIHZhciBtID0gdm9pZCAwID09PSBlID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwoZSksXG4gICAgICBjID0gdm9pZCAwID09PSB0ID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwodCksXG4gICAgICBoID0gdm9pZCAwID09PSByID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwociksXG4gICAgICB1ID0gdm9pZCAwID09PSBvID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwobyksXG4gICAgICBUID0gdm9pZCAwID09PSBuID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwobiksXG4gICAgICBwID0gdm9pZCAwID09PSBhID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwoYSksXG4gICAgICBmID0gdm9pZCAwID09PSBpID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwoaSksXG4gICAgICB5ID0gdm9pZCAwID09PSBzID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwocyksXG4gICAgICBJID0gdm9pZCAwID09PSBsID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwobCksXG4gICAgICBTID0gdm9pZCAwID09PSBkID8gMCA6IFRvSW50ZWdlcklmSW50ZWdyYWwoZCk7XG4gICAgUmVqZWN0RHVyYXRpb24obSwgYywgaCwgdSwgVCwgcCwgZiwgeSwgSSwgUyksIE4odGhpcyksIFNldFNsb3QodGhpcywgdywgbSksIFNldFNsb3QodGhpcywgRCwgYyksIFNldFNsb3QodGhpcywgRywgaCksIFNldFNsb3QodGhpcywgdiwgdSksIFNldFNsb3QodGhpcywgQywgVCksIFNldFNsb3QodGhpcywgTywgcCksIFNldFNsb3QodGhpcywgYiwgZiksIFNldFNsb3QodGhpcywgRSwgeSksIFNldFNsb3QodGhpcywgTSwgSSksIFNldFNsb3QodGhpcywgUiwgUyk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKER1cmF0aW9uLCBbe1xuICAgIGtleTogXCJ5ZWFyc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgdyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndlZWtzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBHKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5c1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgdik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhvdXJzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBDKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWludXRlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgTyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIGIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaWxsaXNlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIEUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaWNyb3NlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIE0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuYW5vc2Vjb25kc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgUik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpZ25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBEdXJhdGlvblNpZ24oR2V0U2xvdCh0aGlzLCB3KSwgR2V0U2xvdCh0aGlzLCBEKSwgR2V0U2xvdCh0aGlzLCBHKSwgR2V0U2xvdCh0aGlzLCB2KSwgR2V0U2xvdCh0aGlzLCBDKSwgR2V0U2xvdCh0aGlzLCBPKSwgR2V0U2xvdCh0aGlzLCBiKSwgR2V0U2xvdCh0aGlzLCBFKSwgR2V0U2xvdCh0aGlzLCBNKSwgR2V0U2xvdCh0aGlzLCBSKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJsYW5rXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gMCA9PT0gRHVyYXRpb25TaWduKEdldFNsb3QodGhpcywgdyksIEdldFNsb3QodGhpcywgRCksIEdldFNsb3QodGhpcywgRyksIEdldFNsb3QodGhpcywgdiksIEdldFNsb3QodGhpcywgQyksIEdldFNsb3QodGhpcywgTyksIEdldFNsb3QodGhpcywgYiksIEdldFNsb3QodGhpcywgRSksIEdldFNsb3QodGhpcywgTSksIEdldFNsb3QodGhpcywgUikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF93aXRoKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciB0ID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIFtcImRheXNcIiwgXCJob3Vyc1wiLCBcIm1pY3Jvc2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiLCBcIm1pbnV0ZXNcIiwgXCJtb250aHNcIiwgXCJuYW5vc2Vjb25kc1wiLCBcInNlY29uZHNcIiwgXCJ3ZWVrc1wiLCBcInllYXJzXCJdLCBcInBhcnRpYWxcIiksXG4gICAgICAgIF90JHllYXJzID0gdC55ZWFycyxcbiAgICAgICAgciA9IF90JHllYXJzID09PSB2b2lkIDAgPyBHZXRTbG90KHRoaXMsIHcpIDogX3QkeWVhcnMsXG4gICAgICAgIF90JG1vbnRocyA9IHQubW9udGhzLFxuICAgICAgICBvID0gX3QkbW9udGhzID09PSB2b2lkIDAgPyBHZXRTbG90KHRoaXMsIEQpIDogX3QkbW9udGhzLFxuICAgICAgICBfdCR3ZWVrcyA9IHQud2Vla3MsXG4gICAgICAgIG4gPSBfdCR3ZWVrcyA9PT0gdm9pZCAwID8gR2V0U2xvdCh0aGlzLCBHKSA6IF90JHdlZWtzLFxuICAgICAgICBfdCRkYXlzID0gdC5kYXlzLFxuICAgICAgICBhID0gX3QkZGF5cyA9PT0gdm9pZCAwID8gR2V0U2xvdCh0aGlzLCB2KSA6IF90JGRheXMsXG4gICAgICAgIF90JGhvdXJzID0gdC5ob3VycyxcbiAgICAgICAgaSA9IF90JGhvdXJzID09PSB2b2lkIDAgPyBHZXRTbG90KHRoaXMsIEMpIDogX3QkaG91cnMsXG4gICAgICAgIF90JG1pbnV0ZXMgPSB0Lm1pbnV0ZXMsXG4gICAgICAgIHMgPSBfdCRtaW51dGVzID09PSB2b2lkIDAgPyBHZXRTbG90KHRoaXMsIE8pIDogX3QkbWludXRlcyxcbiAgICAgICAgX3Qkc2Vjb25kcyA9IHQuc2Vjb25kcyxcbiAgICAgICAgbCA9IF90JHNlY29uZHMgPT09IHZvaWQgMCA/IEdldFNsb3QodGhpcywgYikgOiBfdCRzZWNvbmRzLFxuICAgICAgICBfdCRtaWxsaXNlY29uZHMgPSB0Lm1pbGxpc2Vjb25kcyxcbiAgICAgICAgZCA9IF90JG1pbGxpc2Vjb25kcyA9PT0gdm9pZCAwID8gR2V0U2xvdCh0aGlzLCBFKSA6IF90JG1pbGxpc2Vjb25kcyxcbiAgICAgICAgX3QkbWljcm9zZWNvbmRzID0gdC5taWNyb3NlY29uZHMsXG4gICAgICAgIG0gPSBfdCRtaWNyb3NlY29uZHMgPT09IHZvaWQgMCA/IEdldFNsb3QodGhpcywgTSkgOiBfdCRtaWNyb3NlY29uZHMsXG4gICAgICAgIF90JG5hbm9zZWNvbmRzID0gdC5uYW5vc2Vjb25kcyxcbiAgICAgICAgYyA9IF90JG5hbm9zZWNvbmRzID09PSB2b2lkIDAgPyBHZXRTbG90KHRoaXMsIFIpIDogX3QkbmFub3NlY29uZHM7XG4gICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZWdhdGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZ2F0ZWQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ3JlYXRlTmVnYXRlZFRlbXBvcmFsRHVyYXRpb24odGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFic1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYnMoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gbmV3IER1cmF0aW9uKE1hdGguYWJzKEdldFNsb3QodGhpcywgdykpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIEQpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBHKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgdikpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIEMpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBPKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgYikpLCBNYXRoLmFicyhHZXRTbG90KHRoaXMsIEUpKSwgTWF0aC5hYnMoR2V0U2xvdCh0aGlzLCBNKSksIE1hdGguYWJzKEdldFNsb3QodGhpcywgUikpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21EdXJhdGlvbihcImFkZFwiLCB0aGlzLCBlLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3VidHJhY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEFkZER1cmF0aW9uVG9PclN1YnRyYWN0RHVyYXRpb25Gcm9tRHVyYXRpb24oXCJzdWJ0cmFjdFwiLCB0aGlzLCBlLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm91bmQodCkge1xuICAgICAgdmFyIF9VbmJhbGFuY2VEdXJhdGlvblJlbCwgX1JvdW5kRHVyYXRpb244LCBfQWRqdXN0Um91bmRlZER1cmF0aW8yLCBfQmFsYW5jZUR1cmF0aW9uMTEsIF9CYWxhbmNlRHVyYXRpb25SZWxhdDtcbiAgICAgIGlmICghSXNUZW1wb3JhbER1cmF0aW9uKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zIHBhcmFtZXRlciBpcyByZXF1aXJlZFwiKTtcbiAgICAgIHZhciByID0gR2V0U2xvdCh0aGlzLCB3KSxcbiAgICAgICAgbyA9IEdldFNsb3QodGhpcywgRCksXG4gICAgICAgIG4gPSBHZXRTbG90KHRoaXMsIEcpLFxuICAgICAgICBhID0gR2V0U2xvdCh0aGlzLCB2KSxcbiAgICAgICAgaSA9IEdldFNsb3QodGhpcywgQyksXG4gICAgICAgIHMgPSBHZXRTbG90KHRoaXMsIE8pLFxuICAgICAgICBsID0gR2V0U2xvdCh0aGlzLCBiKSxcbiAgICAgICAgZCA9IEdldFNsb3QodGhpcywgRSksXG4gICAgICAgIG0gPSBHZXRTbG90KHRoaXMsIE0pLFxuICAgICAgICBjID0gR2V0U2xvdCh0aGlzLCBSKSxcbiAgICAgICAgaCA9IERlZmF1bHRUZW1wb3JhbExhcmdlc3RVbml0KHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMpO1xuICAgICAgdmFyIHUgPSBcInN0cmluZ1wiID09IHR5cGVvZiB0ID8gQ3JlYXRlT25lUHJvcE9iamVjdChcInNtYWxsZXN0VW5pdFwiLCB0KSA6IEdldE9wdGlvbnNPYmplY3QodCk7XG4gICAgICB2YXIgVCA9IEdldFRlbXBvcmFsVW5pdCh1LCBcImxhcmdlc3RVbml0XCIsIFwiZGF0ZXRpbWVcIiwgdm9pZCAwLCBbXCJhdXRvXCJdKSxcbiAgICAgICAgZiA9IFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdCh1KTtcbiAgICAgIHZhciB5ID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KHUpLFxuICAgICAgICBJID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZSh1LCBcImhhbGZFeHBhbmRcIik7XG4gICAgICB2YXIgUyA9IEdldFRlbXBvcmFsVW5pdCh1LCBcInNtYWxsZXN0VW5pdFwiLCBcImRhdGV0aW1lXCIsIHZvaWQgMCksXG4gICAgICAgIGcgPSAhMDtcbiAgICAgIFMgfHwgKGcgPSAhMSwgUyA9IFwibmFub3NlY29uZFwiKSwgaCA9IExhcmdlck9mVHdvVGVtcG9yYWxVbml0cyhoLCBTKTtcbiAgICAgIHZhciBGID0gITA7XG4gICAgICBpZiAoVCB8fCAoRiA9ICExLCBUID0gaCksIFwiYXV0b1wiID09PSBUICYmIChUID0gaCksICFnICYmICFGKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImF0IGxlYXN0IG9uZSBvZiBzbWFsbGVzdFVuaXQgb3IgbGFyZ2VzdFVuaXQgaXMgcmVxdWlyZWRcIik7XG4gICAgICBpZiAoTGFyZ2VyT2ZUd29UZW1wb3JhbFVuaXRzKFQsIFMpICE9PSBUKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImxhcmdlc3RVbml0IFwiLmNvbmNhdChULCBcIiBjYW5ub3QgYmUgc21hbGxlciB0aGFuIHNtYWxsZXN0VW5pdCBcIikuY29uY2F0KFMpKTtcbiAgICAgIHZhciBZID0ge1xuICAgICAgICBob3VyOiAyNCxcbiAgICAgICAgbWludXRlOiA2MCxcbiAgICAgICAgc2Vjb25kOiA2MCxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IDFlMyxcbiAgICAgICAgbWljcm9zZWNvbmQ6IDFlMyxcbiAgICAgICAgbmFub3NlY29uZDogMWUzXG4gICAgICB9W1NdO1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gWSAmJiBWYWxpZGF0ZVRlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQoeSwgWSwgITEpLCAoX1VuYmFsYW5jZUR1cmF0aW9uUmVsID0gVW5iYWxhbmNlRHVyYXRpb25SZWxhdGl2ZShyLCBvLCBuLCBhLCBULCBmKSwgciA9IF9VbmJhbGFuY2VEdXJhdGlvblJlbC55ZWFycywgbyA9IF9VbmJhbGFuY2VEdXJhdGlvblJlbC5tb250aHMsIG4gPSBfVW5iYWxhbmNlRHVyYXRpb25SZWwud2Vla3MsIGEgPSBfVW5iYWxhbmNlRHVyYXRpb25SZWwuZGF5cyksIChfUm91bmREdXJhdGlvbjggPSBSb3VuZER1cmF0aW9uKHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMsIHksIFMsIEksIGYpLCByID0gX1JvdW5kRHVyYXRpb244LnllYXJzLCBvID0gX1JvdW5kRHVyYXRpb244Lm1vbnRocywgbiA9IF9Sb3VuZER1cmF0aW9uOC53ZWVrcywgYSA9IF9Sb3VuZER1cmF0aW9uOC5kYXlzLCBpID0gX1JvdW5kRHVyYXRpb244LmhvdXJzLCBzID0gX1JvdW5kRHVyYXRpb244Lm1pbnV0ZXMsIGwgPSBfUm91bmREdXJhdGlvbjguc2Vjb25kcywgZCA9IF9Sb3VuZER1cmF0aW9uOC5taWxsaXNlY29uZHMsIG0gPSBfUm91bmREdXJhdGlvbjgubWljcm9zZWNvbmRzLCBjID0gX1JvdW5kRHVyYXRpb244Lm5hbm9zZWNvbmRzKSwgKF9BZGp1c3RSb3VuZGVkRHVyYXRpbzIgPSBBZGp1c3RSb3VuZGVkRHVyYXRpb25EYXlzKHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0sIGMsIHksIFMsIEksIGYpLCByID0gX0FkanVzdFJvdW5kZWREdXJhdGlvMi55ZWFycywgbyA9IF9BZGp1c3RSb3VuZGVkRHVyYXRpbzIubW9udGhzLCBuID0gX0FkanVzdFJvdW5kZWREdXJhdGlvMi53ZWVrcywgYSA9IF9BZGp1c3RSb3VuZGVkRHVyYXRpbzIuZGF5cywgaSA9IF9BZGp1c3RSb3VuZGVkRHVyYXRpbzIuaG91cnMsIHMgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8yLm1pbnV0ZXMsIGwgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8yLnNlY29uZHMsIGQgPSBfQWRqdXN0Um91bmRlZER1cmF0aW8yLm1pbGxpc2Vjb25kcywgbSA9IF9BZGp1c3RSb3VuZGVkRHVyYXRpbzIubWljcm9zZWNvbmRzLCBjID0gX0FkanVzdFJvdW5kZWREdXJhdGlvMi5uYW5vc2Vjb25kcyksIChfQmFsYW5jZUR1cmF0aW9uMTEgPSBCYWxhbmNlRHVyYXRpb24oYSwgaSwgcywgbCwgZCwgbSwgYywgVCwgZiksIGEgPSBfQmFsYW5jZUR1cmF0aW9uMTEuZGF5cywgaSA9IF9CYWxhbmNlRHVyYXRpb24xMS5ob3VycywgcyA9IF9CYWxhbmNlRHVyYXRpb24xMS5taW51dGVzLCBsID0gX0JhbGFuY2VEdXJhdGlvbjExLnNlY29uZHMsIGQgPSBfQmFsYW5jZUR1cmF0aW9uMTEubWlsbGlzZWNvbmRzLCBtID0gX0JhbGFuY2VEdXJhdGlvbjExLm1pY3Jvc2Vjb25kcywgYyA9IF9CYWxhbmNlRHVyYXRpb24xMS5uYW5vc2Vjb25kcyksIChfQmFsYW5jZUR1cmF0aW9uUmVsYXQgPSBmdW5jdGlvbiBCYWxhbmNlRHVyYXRpb25SZWxhdGl2ZSh0LCByLCBvLCBuLCBhLCBpKSB7XG4gICAgICAgIHZhciBzID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkR1cmF0aW9uJVwiKSxcbiAgICAgICAgICBsID0gRHVyYXRpb25TaWduKHQsIHIsIG8sIG4sIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBpZiAoMCA9PT0gbCkgcmV0dXJuIHtcbiAgICAgICAgICB5ZWFyczogdCxcbiAgICAgICAgICBtb250aHM6IHIsXG4gICAgICAgICAgd2Vla3M6IG8sXG4gICAgICAgICAgZGF5czogblxuICAgICAgICB9O1xuICAgICAgICB2YXIgZCA9IEJpZ0ludChsKTtcbiAgICAgICAgdmFyIG0sXG4gICAgICAgICAgYyxcbiAgICAgICAgICBoID0gQmlnSW50KHQpLFxuICAgICAgICAgIHUgPSBCaWdJbnQociksXG4gICAgICAgICAgVCA9IEJpZ0ludChvKSxcbiAgICAgICAgICBmID0gQmlnSW50KG4pO1xuICAgICAgICBpICYmIChjID0gVG9UZW1wb3JhbERhdGUoaSksIG0gPSBHZXRTbG90KGMsIHApKTtcbiAgICAgICAgdmFyIHkgPSBuZXcgcyhsKSxcbiAgICAgICAgICBJID0gbmV3IHMoMCwgbCksXG4gICAgICAgICAgUyA9IG5ldyBzKDAsIDAsIGwpO1xuICAgICAgICBzd2l0Y2ggKGEpIHtcbiAgICAgICAgICBjYXNlIFwieWVhclwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoIW0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3IgeWVhcnMgYmFsYW5jaW5nXCIpO1xuICAgICAgICAgICAgICB2YXIgX3Q1MSA9IFwic3RyaW5nXCIgIT0gdHlwZW9mIG0gPyBHZXRNZXRob2QobSwgXCJkYXRlQWRkXCIpIDogdm9pZCAwO1xuICAgICAgICAgICAgICB2YXIgX3I2OCwgX280NiwgX24yODtcbiAgICAgICAgICAgICAgZm9yIChfTW92ZVJlbGF0aXZlRGF0ZTExID0gTW92ZVJlbGF0aXZlRGF0ZShtLCBjLCB5LCBfdDUxKSwgX3I2OCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTEucmVsYXRpdmVUbywgX280NiA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTEuZGF5cywgX01vdmVSZWxhdGl2ZURhdGUxMTsgYWJzKGYpID49IEJpZ0ludChhZShfbzQ2KSk7KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9Nb3ZlUmVsYXRpdmVEYXRlMTEsIF9Nb3ZlUmVsYXRpdmVEYXRlMTI7XG4gICAgICAgICAgICAgICAgZiA9IGYgLSBCaWdJbnQoX280NiksIGggPSBoICsgZCwgYyA9IF9yNjgsIChfTW92ZVJlbGF0aXZlRGF0ZTEyID0gTW92ZVJlbGF0aXZlRGF0ZShtLCBjLCB5LCBfdDUxKSwgX3I2OCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTIucmVsYXRpdmVUbywgX280NiA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTIuZGF5cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChfTW92ZVJlbGF0aXZlRGF0ZTEzID0gTW92ZVJlbGF0aXZlRGF0ZShtLCBjLCBJLCBfdDUxKSwgX3I2OCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTMucmVsYXRpdmVUbywgX24yOCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTMuZGF5cywgX01vdmVSZWxhdGl2ZURhdGUxMzsgYWJzKGYpID49IEJpZ0ludChhZShfbjI4KSk7KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9Nb3ZlUmVsYXRpdmVEYXRlMTMsIF9Nb3ZlUmVsYXRpdmVEYXRlMTQ7XG4gICAgICAgICAgICAgICAgZiA9IGYgLSBCaWdJbnQoX24yOCksIHUgPSB1ICsgZCwgYyA9IF9yNjgsIChfTW92ZVJlbGF0aXZlRGF0ZTE0ID0gTW92ZVJlbGF0aXZlRGF0ZShtLCBjLCBJLCBfdDUxKSwgX3I2OCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTQucmVsYXRpdmVUbywgX24yOCA9IF9Nb3ZlUmVsYXRpdmVEYXRlMTQuZGF5cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3I2OCA9IENhbGVuZGFyRGF0ZUFkZChtLCBjLCB5LCB2b2lkIDAsIF90NTEpO1xuICAgICAgICAgICAgICB2YXIgX2EyMCA9IFwic3RyaW5nXCIgIT0gdHlwZW9mIG0gPyBHZXRNZXRob2QobSwgXCJkYXRlVW50aWxcIikgOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgX2kyNSA9IFRlKG51bGwpO1xuICAgICAgICAgICAgICBfaTI1Lmxhcmdlc3RVbml0ID0gXCJtb250aFwiO1xuICAgICAgICAgICAgICB2YXIgX3M4ID0gQ2FsZW5kYXJEYXRlVW50aWwobSwgYywgX3I2OCwgX2kyNSwgX2EyMCksXG4gICAgICAgICAgICAgICAgX2w5ID0gR2V0U2xvdChfczgsIEQpO1xuICAgICAgICAgICAgICBmb3IgKDsgYWJzKHUpID49IEJpZ0ludChhZShfbDkpKTspIHtcbiAgICAgICAgICAgICAgICB1ID0gdSAtIEJpZ0ludChfbDkpLCBoID0gaCArIGQsIGMgPSBfcjY4LCBfcjY4ID0gQ2FsZW5kYXJEYXRlQWRkKG0sIGMsIHksIHZvaWQgMCwgX3Q1MSk7XG4gICAgICAgICAgICAgICAgdmFyIF9vNDcgPSBUZShudWxsKTtcbiAgICAgICAgICAgICAgICBfbzQ3Lmxhcmdlc3RVbml0ID0gXCJtb250aFwiLCBfczggPSBDYWxlbmRhckRhdGVVbnRpbChtLCBjLCBfcjY4LCBfbzQ3LCBfYTIwKSwgX2w5ID0gR2V0U2xvdChfczgsIEQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJtb250aFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoIW0pIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYSBzdGFydGluZyBwb2ludCBpcyByZXF1aXJlZCBmb3IgbW9udGhzIGJhbGFuY2luZ1wiKTtcbiAgICAgICAgICAgICAgdmFyIF90NTIgPSBcInN0cmluZ1wiICE9IHR5cGVvZiBtID8gR2V0TWV0aG9kKG0sIFwiZGF0ZUFkZFwiKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgdmFyIF9yNjksIF9vNDg7XG4gICAgICAgICAgICAgIGZvciAoX01vdmVSZWxhdGl2ZURhdGUxNSA9IE1vdmVSZWxhdGl2ZURhdGUobSwgYywgSSwgX3Q1MiksIF9yNjkgPSBfTW92ZVJlbGF0aXZlRGF0ZTE1LnJlbGF0aXZlVG8sIF9vNDggPSBfTW92ZVJlbGF0aXZlRGF0ZTE1LmRheXMsIF9Nb3ZlUmVsYXRpdmVEYXRlMTU7IGFicyhmKSA+PSBCaWdJbnQoYWUoX280OCkpOykge1xuICAgICAgICAgICAgICAgIHZhciBfTW92ZVJlbGF0aXZlRGF0ZTE1LCBfTW92ZVJlbGF0aXZlRGF0ZTE2O1xuICAgICAgICAgICAgICAgIGYgPSBmIC0gQmlnSW50KF9vNDgpLCB1ID0gdSArIGQsIGMgPSBfcjY5LCAoX01vdmVSZWxhdGl2ZURhdGUxNiA9IE1vdmVSZWxhdGl2ZURhdGUobSwgYywgSSwgX3Q1MiksIF9yNjkgPSBfTW92ZVJlbGF0aXZlRGF0ZTE2LnJlbGF0aXZlVG8sIF9vNDggPSBfTW92ZVJlbGF0aXZlRGF0ZTE2LmRheXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ3ZWVrXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICghbSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJhIHN0YXJ0aW5nIHBvaW50IGlzIHJlcXVpcmVkIGZvciB3ZWVrcyBiYWxhbmNpbmdcIik7XG4gICAgICAgICAgICAgIHZhciBfdDUzID0gXCJzdHJpbmdcIiAhPSB0eXBlb2YgbSA/IEdldE1ldGhvZChtLCBcImRhdGVBZGRcIikgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIHZhciBfcjcwLCBfbzQ5O1xuICAgICAgICAgICAgICBmb3IgKF9Nb3ZlUmVsYXRpdmVEYXRlMTcgPSBNb3ZlUmVsYXRpdmVEYXRlKG0sIGMsIFMsIF90NTMpLCBfcjcwID0gX01vdmVSZWxhdGl2ZURhdGUxNy5yZWxhdGl2ZVRvLCBfbzQ5ID0gX01vdmVSZWxhdGl2ZURhdGUxNy5kYXlzLCBfTW92ZVJlbGF0aXZlRGF0ZTE3OyBhYnMoZikgPj0gQmlnSW50KGFlKF9vNDkpKTspIHtcbiAgICAgICAgICAgICAgICB2YXIgX01vdmVSZWxhdGl2ZURhdGUxNywgX01vdmVSZWxhdGl2ZURhdGUxODtcbiAgICAgICAgICAgICAgICBmID0gZiAtIEJpZ0ludChfbzQ5KSwgVCA9IFQgKyBkLCBjID0gX3I3MCwgKF9Nb3ZlUmVsYXRpdmVEYXRlMTggPSBNb3ZlUmVsYXRpdmVEYXRlKG0sIGMsIFMsIF90NTMpLCBfcjcwID0gX01vdmVSZWxhdGl2ZURhdGUxOC5yZWxhdGl2ZVRvLCBfbzQ5ID0gX01vdmVSZWxhdGl2ZURhdGUxOC5kYXlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHllYXJzOiBOdW1iZXIoaCksXG4gICAgICAgICAgbW9udGhzOiBOdW1iZXIodSksXG4gICAgICAgICAgd2Vla3M6IE51bWJlcihUKSxcbiAgICAgICAgICBkYXlzOiBOdW1iZXIoZilcbiAgICAgICAgfTtcbiAgICAgIH0ociwgbywgbiwgYSwgVCwgZiksIHIgPSBfQmFsYW5jZUR1cmF0aW9uUmVsYXQueWVhcnMsIG8gPSBfQmFsYW5jZUR1cmF0aW9uUmVsYXQubW9udGhzLCBuID0gX0JhbGFuY2VEdXJhdGlvblJlbGF0LndlZWtzLCBhID0gX0JhbGFuY2VEdXJhdGlvblJlbGF0LmRheXMpLCBuZXcgRHVyYXRpb24ociwgbywgbiwgYSwgaSwgcywgbCwgZCwgbSwgYyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvdGFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvdGFsKGUpIHtcbiAgICAgIHZhciBfVW5iYWxhbmNlRHVyYXRpb25SZWwyO1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBHZXRTbG90KHRoaXMsIHcpLFxuICAgICAgICByID0gR2V0U2xvdCh0aGlzLCBEKSxcbiAgICAgICAgbyA9IEdldFNsb3QodGhpcywgRyksXG4gICAgICAgIG4gPSBHZXRTbG90KHRoaXMsIHYpLFxuICAgICAgICBhID0gR2V0U2xvdCh0aGlzLCBDKSxcbiAgICAgICAgaSA9IEdldFNsb3QodGhpcywgTyksXG4gICAgICAgIHMgPSBHZXRTbG90KHRoaXMsIGIpLFxuICAgICAgICBsID0gR2V0U2xvdCh0aGlzLCBFKSxcbiAgICAgICAgZCA9IEdldFNsb3QodGhpcywgTSksXG4gICAgICAgIG0gPSBHZXRTbG90KHRoaXMsIFIpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbnMgYXJndW1lbnQgaXMgcmVxdWlyZWRcIik7XG4gICAgICB2YXIgYyA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBDcmVhdGVPbmVQcm9wT2JqZWN0KFwidW5pdFwiLCBlKSA6IEdldE9wdGlvbnNPYmplY3QoZSksXG4gICAgICAgIGggPSBUb1JlbGF0aXZlVGVtcG9yYWxPYmplY3QoYyksXG4gICAgICAgIHUgPSBHZXRUZW1wb3JhbFVuaXQoYywgXCJ1bml0XCIsIFwiZGF0ZXRpbWVcIiwgSGUpO1xuICAgICAgdmFyIFQ7XG4gICAgICAoX1VuYmFsYW5jZUR1cmF0aW9uUmVsMiA9IFVuYmFsYW5jZUR1cmF0aW9uUmVsYXRpdmUodCwgciwgbywgbiwgdSwgaCksIHQgPSBfVW5iYWxhbmNlRHVyYXRpb25SZWwyLnllYXJzLCByID0gX1VuYmFsYW5jZUR1cmF0aW9uUmVsMi5tb250aHMsIG8gPSBfVW5iYWxhbmNlRHVyYXRpb25SZWwyLndlZWtzLCBuID0gX1VuYmFsYW5jZUR1cmF0aW9uUmVsMi5kYXlzKSwgSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoaCkgJiYgKFQgPSBNb3ZlUmVsYXRpdmVab25lZERhdGVUaW1lKGgsIHQsIHIsIG8sIDApKTtcbiAgICAgIHZhciBwID0gQmFsYW5jZVBvc3NpYmx5SW5maW5pdGVEdXJhdGlvbihuLCBhLCBpLCBzLCBsLCBkLCBtLCB1LCBUKTtcbiAgICAgIGlmIChcInBvc2l0aXZlIG92ZXJmbG93XCIgPT09IHApIHJldHVybiAxIC8gMDtcbiAgICAgIGlmIChcIm5lZ2F0aXZlIG92ZXJmbG93XCIgPT09IHApIHJldHVybiAtMSAvIDA7XG4gICAgICBuID0gcC5kYXlzO1xuICAgICAgYSA9IHAuaG91cnM7XG4gICAgICBpID0gcC5taW51dGVzO1xuICAgICAgcyA9IHAuc2Vjb25kcztcbiAgICAgIGwgPSBwLm1pbGxpc2Vjb25kcztcbiAgICAgIGQgPSBwLm1pY3Jvc2Vjb25kcztcbiAgICAgIG0gPSBwLm5hbm9zZWNvbmRzO1xuICAgICAgdmFyIF9Sb3VuZER1cmF0aW9uOSA9IFJvdW5kRHVyYXRpb24odCwgciwgbywgbiwgYSwgaSwgcywgbCwgZCwgbSwgMSwgdSwgXCJ0cnVuY1wiLCBoKSxcbiAgICAgICAgZiA9IF9Sb3VuZER1cmF0aW9uOS50b3RhbDtcbiAgICAgIHJldHVybiBmO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxEdXJhdGlvbih0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEdldE9wdGlvbnNPYmplY3QoZSksXG4gICAgICAgIHIgPSBUb0ZyYWN0aW9uYWxTZWNvbmREaWdpdHModCksXG4gICAgICAgIG8gPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKHQsIFwidHJ1bmNcIiksXG4gICAgICAgIG4gPSBHZXRUZW1wb3JhbFVuaXQodCwgXCJzbWFsbGVzdFVuaXRcIiwgXCJ0aW1lXCIsIHZvaWQgMCk7XG4gICAgICBpZiAoXCJob3VyXCIgPT09IG4gfHwgXCJtaW51dGVcIiA9PT0gbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NtYWxsZXN0VW5pdCBtdXN0IGJlIGEgdGltZSB1bml0IG90aGVyIHRoYW4gXCJob3Vyc1wiIG9yIFwibWludXRlc1wiJyk7XG4gICAgICB2YXIgX1RvU2Vjb25kc1N0cmluZ1ByZWNpMyA9IFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvblJlY29yZChuLCByKSxcbiAgICAgICAgYSA9IF9Ub1NlY29uZHNTdHJpbmdQcmVjaTMucHJlY2lzaW9uLFxuICAgICAgICBpID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpMy51bml0LFxuICAgICAgICBzID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpMy5pbmNyZW1lbnQ7XG4gICAgICByZXR1cm4gVGVtcG9yYWxEdXJhdGlvblRvU3RyaW5nKHRoaXMsIGEsIHtcbiAgICAgICAgdW5pdDogaSxcbiAgICAgICAgaW5jcmVtZW50OiBzLFxuICAgICAgICByb3VuZGluZ01vZGU6IG9cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsRHVyYXRpb25Ub1N0cmluZyh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9Mb2NhbGVTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsRHVyYXRpb24odGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIEludGwgJiYgdm9pZCAwICE9PSBJbnRsLkR1cmF0aW9uRm9ybWF0ID8gbmV3IEludGwuRHVyYXRpb25Gb3JtYXQoZSwgdCkuZm9ybWF0KHRoaXMpIDogKGNvbnNvbGUud2FybihcIlRlbXBvcmFsLkR1cmF0aW9uLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZygpIHJlcXVpcmVzIEludGwuRHVyYXRpb25Gb3JtYXQuXCIpLCBUZW1wb3JhbER1cmF0aW9uVG9TdHJpbmcodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZU9mXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidXNlIGNvbXBhcmUoKSB0byBjb21wYXJlIFRlbXBvcmFsLkR1cmF0aW9uXCIpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbShlKSB7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbER1cmF0aW9uKGUpID8gbmV3IER1cmF0aW9uKEdldFNsb3QoZSwgdyksIEdldFNsb3QoZSwgRCksIEdldFNsb3QoZSwgRyksIEdldFNsb3QoZSwgdiksIEdldFNsb3QoZSwgQyksIEdldFNsb3QoZSwgTyksIEdldFNsb3QoZSwgYiksIEdldFNsb3QoZSwgRSksIEdldFNsb3QoZSwgTSksIEdldFNsb3QoZSwgUikpIDogVG9UZW1wb3JhbER1cmF0aW9uKGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmUodCwgciwgbykge1xuICAgICAgdmFyIF9VbmJhbGFuY2VEdXJhdGlvblJlbDMsIF9VbmJhbGFuY2VEdXJhdGlvblJlbDQ7XG4gICAgICB2YXIgbiA9IFRvVGVtcG9yYWxEdXJhdGlvbih0KSxcbiAgICAgICAgYSA9IFRvVGVtcG9yYWxEdXJhdGlvbihyKSxcbiAgICAgICAgaSA9IFRvUmVsYXRpdmVUZW1wb3JhbE9iamVjdChHZXRPcHRpb25zT2JqZWN0KG8pKSxcbiAgICAgICAgcyA9IEdldFNsb3QobiwgdyksXG4gICAgICAgIGwgPSBHZXRTbG90KG4sIEQpLFxuICAgICAgICBkID0gR2V0U2xvdChuLCBHKTtcbiAgICAgIHZhciBtID0gR2V0U2xvdChuLCB2KTtcbiAgICAgIHZhciBjID0gR2V0U2xvdChuLCBDKSxcbiAgICAgICAgaCA9IEdldFNsb3QobiwgTyksXG4gICAgICAgIHUgPSBHZXRTbG90KG4sIGIpLFxuICAgICAgICBUID0gR2V0U2xvdChuLCBFKSxcbiAgICAgICAgcCA9IEdldFNsb3QobiwgTSk7XG4gICAgICB2YXIgZiA9IEdldFNsb3QobiwgUik7XG4gICAgICB2YXIgeSA9IEdldFNsb3QoYSwgdyksXG4gICAgICAgIEkgPSBHZXRTbG90KGEsIEQpLFxuICAgICAgICBTID0gR2V0U2xvdChhLCBHKTtcbiAgICAgIHZhciBnID0gR2V0U2xvdChhLCB2KTtcbiAgICAgIHZhciBGID0gR2V0U2xvdChhLCBDKSxcbiAgICAgICAgWSA9IEdldFNsb3QoYSwgTyksXG4gICAgICAgIFAgPSBHZXRTbG90KGEsIGIpLFxuICAgICAgICBaID0gR2V0U2xvdChhLCBFKSxcbiAgICAgICAgQiA9IEdldFNsb3QoYSwgTSk7XG4gICAgICB2YXIgTiA9IEdldFNsb3QoYSwgUik7XG4gICAgICB2YXIgaiA9IENhbGN1bGF0ZU9mZnNldFNoaWZ0KGksIHMsIGwsIGQsIG0pLFxuICAgICAgICAkID0gQ2FsY3VsYXRlT2Zmc2V0U2hpZnQoaSwgeSwgSSwgUywgZyk7XG4gICAgICAwID09PSBzICYmIDAgPT09IHkgJiYgMCA9PT0gbCAmJiAwID09PSBJICYmIDAgPT09IGQgJiYgMCA9PT0gUyB8fCAoKF9VbmJhbGFuY2VEdXJhdGlvblJlbDMgPSBVbmJhbGFuY2VEdXJhdGlvblJlbGF0aXZlKHMsIGwsIGQsIG0sIFwiZGF5XCIsIGkpLCBtID0gX1VuYmFsYW5jZUR1cmF0aW9uUmVsMy5kYXlzKSwgKF9VbmJhbGFuY2VEdXJhdGlvblJlbDQgPSBVbmJhbGFuY2VEdXJhdGlvblJlbGF0aXZlKHksIEksIFMsIGcsIFwiZGF5XCIsIGkpLCBnID0gX1VuYmFsYW5jZUR1cmF0aW9uUmVsNC5kYXlzKSk7XG4gICAgICB2YXIgayA9IFRvdGFsRHVyYXRpb25OYW5vc2Vjb25kcyhtLCBjLCBoLCB1LCBULCBwLCBmLCBqKSxcbiAgICAgICAgVSA9IFRvdGFsRHVyYXRpb25OYW5vc2Vjb25kcyhnLCBGLCBZLCBQLCBaLCBCLCBOLCAkKTtcbiAgICAgIHJldHVybiBDb21wYXJpc29uUmVzdWx0KE51bWJlcihrIC0gVSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRHVyYXRpb247XG59KCk7XG5NYWtlSW50cmluc2ljQ2xhc3MoRHVyYXRpb24sIFwiVGVtcG9yYWwuRHVyYXRpb25cIik7XG52YXIgYnQgPSBPYmplY3QuY3JlYXRlO1xudmFyIFBsYWluTW9udGhEYXkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbGFpbk1vbnRoRGF5KGUsIHQpIHtcbiAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJpc284NjAxXCI7XG4gICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE5NzI7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYWluTW9udGhEYXkpO1xuICAgIENyZWF0ZVRlbXBvcmFsTW9udGhEYXlTbG90cyh0aGlzLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihlKSwgVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24odCksIFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShyKSwgVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24obykpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhQbGFpbk1vbnRoRGF5LCBbe1xuICAgIGtleTogXCJtb250aENvZGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhck1vbnRoQ29kZShHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJEYXkoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGVuZGFySWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKEdldFNsb3QodGhpcywgcCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF93aXRoKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIGlmICghSXNPYmplY3QoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgICAgUmVqZWN0VGVtcG9yYWxMaWtlT2JqZWN0KGUpO1xuICAgICAgdmFyIHIgPSBHZXRPcHRpb25zT2JqZWN0KHQpLFxuICAgICAgICBvID0gR2V0U2xvdCh0aGlzLCBwKSxcbiAgICAgICAgbiA9IENhbGVuZGFyRmllbGRzKG8sIFtcImRheVwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwieWVhclwiXSk7XG4gICAgICB2YXIgYSA9IFByZXBhcmVUZW1wb3JhbEZpZWxkcyh0aGlzLCBuLCBbXSk7XG4gICAgICByZXR1cm4gYSA9IENhbGVuZGFyTWVyZ2VGaWVsZHMobywgYSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIG4sIFwicGFydGlhbFwiKSksIGEgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHMoYSwgbiwgW10pLCBDYWxlbmRhck1vbnRoRGF5RnJvbUZpZWxkcyhvLCBhLCByKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXF1YWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxNb250aERheShlKTtcbiAgICAgIGZvciAodmFyIF9pMjYgPSAwLCBfYXJyMTEgPSBbcywgbCwgaV07IF9pMjYgPCBfYXJyMTEubGVuZ3RoOyBfaTI2KyspIHtcbiAgICAgICAgdmFyIF9lNTcgPSBfYXJyMTFbX2kyNl07XG4gICAgICAgIGlmIChHZXRTbG90KHRoaXMsIF9lNTcpICE9PSBHZXRTbG90KHQsIF9lNTcpKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ2FsZW5kYXJFcXVhbHMoR2V0U2xvdCh0aGlzLCBwKSwgR2V0U2xvdCh0LCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUZW1wb3JhbE1vbnRoRGF5VG9TdHJpbmcodGhpcywgVG9DYWxlbmRhck5hbWVPcHRpb24oR2V0T3B0aW9uc09iamVjdChlKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsTW9udGhEYXlUb1N0cmluZyh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9Mb2NhbGVTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsTW9udGhEYXkodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIG5ldyBodChlLCB0KS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlT2ZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1c2UgZXF1YWxzKCkgdG8gY29tcGFyZSBUZW1wb3JhbC5QbGFpbk1vbnRoRGF5XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1BsYWluRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1BsYWluRGF0ZShlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxNb250aERheSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc2hvdWxkIGJlIGFuIG9iamVjdFwiKTtcbiAgICAgIHZhciB0ID0gR2V0U2xvdCh0aGlzLCBwKSxcbiAgICAgICAgciA9IENhbGVuZGFyRmllbGRzKHQsIFtcImRheVwiLCBcIm1vbnRoQ29kZVwiXSksXG4gICAgICAgIG8gPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModGhpcywgciwgW10pLFxuICAgICAgICBuID0gQ2FsZW5kYXJGaWVsZHModCwgW1wieWVhclwiXSk7XG4gICAgICB2YXIgYSA9IENhbGVuZGFyTWVyZ2VGaWVsZHModCwgbywgUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIG4sIFtdKSk7XG4gICAgICBhID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGEsIF90b0NvbnN1bWFibGVBcnJheShuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkociksIF90b0NvbnN1bWFibGVBcnJheShuKSkpKSwgW10pO1xuICAgICAgdmFyIGkgPSBidChudWxsKTtcbiAgICAgIHJldHVybiBpLm92ZXJmbG93ID0gXCJyZWplY3RcIiwgQ2FsZW5kYXJEYXRlRnJvbUZpZWxkcyh0LCBhLCBpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SVNPRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElTT0ZpZWxkcygpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGVuZGFyOiBHZXRTbG90KHRoaXMsIHApLFxuICAgICAgICBpc29EYXk6IEdldFNsb3QodGhpcywgbCksXG4gICAgICAgIGlzb01vbnRoOiBHZXRTbG90KHRoaXMsIHMpLFxuICAgICAgICBpc29ZZWFyOiBHZXRTbG90KHRoaXMsIGkpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWxlbmRhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWxlbmRhcigpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbE1vbnRoRGF5KHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUb1RlbXBvcmFsQ2FsZW5kYXJPYmplY3QoR2V0U2xvdCh0aGlzLCBwKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKGUsIHQpIHtcbiAgICAgIHZhciByID0gR2V0T3B0aW9uc09iamVjdCh0KTtcbiAgICAgIHJldHVybiBJc1RlbXBvcmFsTW9udGhEYXkoZSkgPyAoVG9UZW1wb3JhbE92ZXJmbG93KHIpLCBDcmVhdGVUZW1wb3JhbE1vbnRoRGF5KEdldFNsb3QoZSwgcyksIEdldFNsb3QoZSwgbCksIEdldFNsb3QoZSwgcCksIEdldFNsb3QoZSwgaSkpKSA6IFRvVGVtcG9yYWxNb250aERheShlLCByKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBsYWluTW9udGhEYXk7XG59KCk7XG5NYWtlSW50cmluc2ljQ2xhc3MoUGxhaW5Nb250aERheSwgXCJUZW1wb3JhbC5QbGFpbk1vbnRoRGF5XCIpO1xudmFyIGluc3RhbnQgPSBmdW5jdGlvbiBpbnN0YW50KCkge1xuICAgIHJldHVybiBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5JbnN0YW50JVwiKSkoVmUoKSk7XG4gIH0sXG4gIHBsYWluRGF0ZVRpbWUgPSBmdW5jdGlvbiBwbGFpbkRhdGVUaW1lKGUpIHtcbiAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogRGVmYXVsdFRpbWVab25lKCk7XG4gICAgdmFyIHIgPSBUb1RlbXBvcmFsVGltZVpvbmVTbG90VmFsdWUodCksXG4gICAgICBvID0gVG9UZW1wb3JhbENhbGVuZGFyU2xvdFZhbHVlKGUpO1xuICAgIHJldHVybiBHZXRQbGFpbkRhdGVUaW1lRm9yKHIsIGluc3RhbnQoKSwgbyk7XG4gIH0sXG4gIHBsYWluRGF0ZVRpbWVJU08gPSBmdW5jdGlvbiBwbGFpbkRhdGVUaW1lSVNPKCkge1xuICAgIHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBEZWZhdWx0VGltZVpvbmUoKTtcbiAgICByZXR1cm4gR2V0UGxhaW5EYXRlVGltZUZvcihUb1RlbXBvcmFsVGltZVpvbmVTbG90VmFsdWUoZSksIGluc3RhbnQoKSwgXCJpc284NjAxXCIpO1xuICB9LFxuICB6b25lZERhdGVUaW1lID0gZnVuY3Rpb24gem9uZWREYXRlVGltZShlKSB7XG4gICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERlZmF1bHRUaW1lWm9uZSgpO1xuICAgIHZhciByID0gVG9UZW1wb3JhbFRpbWVab25lU2xvdFZhbHVlKHQpLFxuICAgICAgbyA9IFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShlKTtcbiAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKFZlKCksIHIsIG8pO1xuICB9LFxuICBFdCA9IF9kZWZpbmVQcm9wZXJ0eSh7XG4gICAgaW5zdGFudDogaW5zdGFudCxcbiAgICBwbGFpbkRhdGVUaW1lOiBwbGFpbkRhdGVUaW1lLFxuICAgIHBsYWluRGF0ZVRpbWVJU086IHBsYWluRGF0ZVRpbWVJU08sXG4gICAgcGxhaW5EYXRlOiBmdW5jdGlvbiBwbGFpbkRhdGUoZSkge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERlZmF1bHRUaW1lWm9uZSgpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsRGF0ZVRpbWVUb0RhdGUocGxhaW5EYXRlVGltZShlLCB0KSk7XG4gICAgfSxcbiAgICBwbGFpbkRhdGVJU086IGZ1bmN0aW9uIHBsYWluRGF0ZUlTTygpIHtcbiAgICAgIHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBEZWZhdWx0VGltZVpvbmUoKTtcbiAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKHBsYWluRGF0ZVRpbWVJU08oZSkpO1xuICAgIH0sXG4gICAgcGxhaW5UaW1lSVNPOiBmdW5jdGlvbiBwbGFpblRpbWVJU08oKSB7XG4gICAgICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogRGVmYXVsdFRpbWVab25lKCk7XG4gICAgICByZXR1cm4gVGVtcG9yYWxEYXRlVGltZVRvVGltZShwbGFpbkRhdGVUaW1lSVNPKGUpKTtcbiAgICB9LFxuICAgIHRpbWVab25lSWQ6IGZ1bmN0aW9uIHRpbWVab25lSWQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFRpbWVab25lKCk7XG4gICAgfSxcbiAgICB6b25lZERhdGVUaW1lOiB6b25lZERhdGVUaW1lLFxuICAgIHpvbmVkRGF0ZVRpbWVJU086IGZ1bmN0aW9uIHpvbmVkRGF0ZVRpbWVJU08oKSB7XG4gICAgICB2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogRGVmYXVsdFRpbWVab25lKCk7XG4gICAgICByZXR1cm4gem9uZWREYXRlVGltZShcImlzbzg2MDFcIiwgZSk7XG4gICAgfVxuICB9LCBTeW1ib2wudG9TdHJpbmdUYWcsIFwiVGVtcG9yYWwuTm93XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV0LCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgdmFsdWU6IFwiVGVtcG9yYWwuTm93XCIsXG4gIHdyaXRhYmxlOiAhMSxcbiAgZW51bWVyYWJsZTogITEsXG4gIGNvbmZpZ3VyYWJsZTogITBcbn0pO1xudmFyIE10ID0gT2JqZWN0LmFzc2lnbjtcbmZ1bmN0aW9uIFRlbXBvcmFsVGltZVRvU3RyaW5nKGUsIHQsIHIpIHtcbiAgdmFyIG8gPSBHZXRTbG90KGUsIGQpLFxuICAgIG4gPSBHZXRTbG90KGUsIG0pLFxuICAgIGEgPSBHZXRTbG90KGUsIGMpLFxuICAgIGkgPSBHZXRTbG90KGUsIGgpLFxuICAgIHMgPSBHZXRTbG90KGUsIHUpLFxuICAgIGwgPSBHZXRTbG90KGUsIFQpO1xuICBpZiAocikge1xuICAgIHZhciBfZTU4ID0gci51bml0LFxuICAgICAgX3Q1NCA9IHIuaW5jcmVtZW50LFxuICAgICAgX2QxMiA9IHIucm91bmRpbmdNb2RlO1xuICAgIHZhciBfUm91bmRUaW1lMiA9IFJvdW5kVGltZShvLCBuLCBhLCBpLCBzLCBsLCBfdDU0LCBfZTU4LCBfZDEyKTtcbiAgICBvID0gX1JvdW5kVGltZTIuaG91cjtcbiAgICBuID0gX1JvdW5kVGltZTIubWludXRlO1xuICAgIGEgPSBfUm91bmRUaW1lMi5zZWNvbmQ7XG4gICAgaSA9IF9Sb3VuZFRpbWUyLm1pbGxpc2Vjb25kO1xuICAgIHMgPSBfUm91bmRUaW1lMi5taWNyb3NlY29uZDtcbiAgICBsID0gX1JvdW5kVGltZTIubmFub3NlY29uZDtcbiAgfVxuICByZXR1cm4gXCJcIi5jb25jYXQoSVNPRGF0ZVRpbWVQYXJ0U3RyaW5nKG8pLCBcIjpcIikuY29uY2F0KElTT0RhdGVUaW1lUGFydFN0cmluZyhuKSkuY29uY2F0KEZvcm1hdFNlY29uZHNTdHJpbmdQYXJ0KGEsIGksIHMsIGwsIHQpKTtcbn1cbnZhciBQbGFpblRpbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbGFpblRpbWUoKSB7XG4gICAgdmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgdmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgdmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYWluVGltZSk7XG4gICAgdmFyIGkgPSB2b2lkIDAgPT09IGUgPyAwIDogVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24oZSksXG4gICAgICBzID0gdm9pZCAwID09PSB0ID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKHQpLFxuICAgICAgbCA9IHZvaWQgMCA9PT0gciA/IDAgOiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihyKSxcbiAgICAgIHAgPSB2b2lkIDAgPT09IG8gPyAwIDogVG9JbnRlZ2VyV2l0aFRydW5jYXRpb24obyksXG4gICAgICBmID0gdm9pZCAwID09PSBuID8gMCA6IFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKG4pLFxuICAgICAgeSA9IHZvaWQgMCA9PT0gYSA/IDAgOiBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihhKTtcbiAgICBSZWplY3RUaW1lKGksIHMsIGwsIHAsIGYsIHkpLCBOKHRoaXMpLCBTZXRTbG90KHRoaXMsIGQsIGkpLCBTZXRTbG90KHRoaXMsIG0sIHMpLCBTZXRTbG90KHRoaXMsIGMsIGwpLCBTZXRTbG90KHRoaXMsIGgsIHApLCBTZXRTbG90KHRoaXMsIHUsIGYpLCBTZXRTbG90KHRoaXMsIFQsIHkpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhQbGFpblRpbWUsIFt7XG4gICAga2V5OiBcImhvdXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pbnV0ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2Vjb25kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIGMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaWxsaXNlY29uZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWljcm9zZWNvbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgdSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5hbm9zZWNvbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgVCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3dpdGgoZSwgdCkge1xuICAgICAgdmFyIF9SZWd1bGF0ZVRpbWU0O1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICAgIFJlamVjdFRlbXBvcmFsTGlrZU9iamVjdChlKTtcbiAgICAgIHZhciByID0gVG9UZW1wb3JhbE92ZXJmbG93KEdldE9wdGlvbnNPYmplY3QodCkpLFxuICAgICAgICBvID0gVG9UZW1wb3JhbFRpbWVSZWNvcmQoZSwgXCJwYXJ0aWFsXCIpLFxuICAgICAgICBuID0gVG9UZW1wb3JhbFRpbWVSZWNvcmQodGhpcyk7XG4gICAgICB2YXIgX010ID0gTXQobiwgbyksXG4gICAgICAgIGEgPSBfTXQuaG91cixcbiAgICAgICAgaSA9IF9NdC5taW51dGUsXG4gICAgICAgIHMgPSBfTXQuc2Vjb25kLFxuICAgICAgICBsID0gX010Lm1pbGxpc2Vjb25kLFxuICAgICAgICBkID0gX010Lm1pY3Jvc2Vjb25kLFxuICAgICAgICBtID0gX010Lm5hbm9zZWNvbmQ7XG4gICAgICByZXR1cm4gKF9SZWd1bGF0ZVRpbWU0ID0gUmVndWxhdGVUaW1lKGEsIGksIHMsIGwsIGQsIG0sIHIpLCBhID0gX1JlZ3VsYXRlVGltZTQuaG91ciwgaSA9IF9SZWd1bGF0ZVRpbWU0Lm1pbnV0ZSwgcyA9IF9SZWd1bGF0ZVRpbWU0LnNlY29uZCwgbCA9IF9SZWd1bGF0ZVRpbWU0Lm1pbGxpc2Vjb25kLCBkID0gX1JlZ3VsYXRlVGltZTQubWljcm9zZWNvbmQsIG0gPSBfUmVndWxhdGVUaW1lNC5uYW5vc2Vjb25kKSwgbmV3IFBsYWluVGltZShhLCBpLCBzLCBsLCBkLCBtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBBZGREdXJhdGlvblRvT3JTdWJ0cmFjdER1cmF0aW9uRnJvbVBsYWluVGltZShcImFkZFwiLCB0aGlzLCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3VidHJhY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21QbGFpblRpbWUoXCJzdWJ0cmFjdFwiLCB0aGlzLCBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW50aWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW50aWwoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsUGxhaW5UaW1lKFwidW50aWxcIiwgdGhpcywgZSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpbmNlKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIERpZmZlcmVuY2VUZW1wb3JhbFBsYWluVGltZShcInNpbmNlXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3VuZChlKSB7XG4gICAgICB2YXIgX1JvdW5kVGltZTM7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zIHBhcmFtZXRlciBpcyByZXF1aXJlZFwiKTtcbiAgICAgIHZhciB0ID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IENyZWF0ZU9uZVByb3BPYmplY3QoXCJzbWFsbGVzdFVuaXRcIiwgZSkgOiBHZXRPcHRpb25zT2JqZWN0KGUpLFxuICAgICAgICByID0gVG9UZW1wb3JhbFJvdW5kaW5nSW5jcmVtZW50KHQpLFxuICAgICAgICBvID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZSh0LCBcImhhbGZFeHBhbmRcIiksXG4gICAgICAgIG4gPSBHZXRUZW1wb3JhbFVuaXQodCwgXCJzbWFsbGVzdFVuaXRcIiwgXCJ0aW1lXCIsIEhlKTtcbiAgICAgIFZhbGlkYXRlVGVtcG9yYWxSb3VuZGluZ0luY3JlbWVudChyLCB7XG4gICAgICAgIGhvdXI6IDI0LFxuICAgICAgICBtaW51dGU6IDYwLFxuICAgICAgICBzZWNvbmQ6IDYwLFxuICAgICAgICBtaWxsaXNlY29uZDogMWUzLFxuICAgICAgICBtaWNyb3NlY29uZDogMWUzLFxuICAgICAgICBuYW5vc2Vjb25kOiAxZTNcbiAgICAgIH1bbl0sICExKTtcbiAgICAgIHZhciBhID0gR2V0U2xvdCh0aGlzLCBkKSxcbiAgICAgICAgaSA9IEdldFNsb3QodGhpcywgbSksXG4gICAgICAgIHMgPSBHZXRTbG90KHRoaXMsIGMpLFxuICAgICAgICBsID0gR2V0U2xvdCh0aGlzLCBoKSxcbiAgICAgICAgcCA9IEdldFNsb3QodGhpcywgdSksXG4gICAgICAgIGYgPSBHZXRTbG90KHRoaXMsIFQpO1xuICAgICAgcmV0dXJuIChfUm91bmRUaW1lMyA9IFJvdW5kVGltZShhLCBpLCBzLCBsLCBwLCBmLCByLCBuLCBvKSwgYSA9IF9Sb3VuZFRpbWUzLmhvdXIsIGkgPSBfUm91bmRUaW1lMy5taW51dGUsIHMgPSBfUm91bmRUaW1lMy5zZWNvbmQsIGwgPSBfUm91bmRUaW1lMy5taWxsaXNlY29uZCwgcCA9IF9Sb3VuZFRpbWUzLm1pY3Jvc2Vjb25kLCBmID0gX1JvdW5kVGltZTMubmFub3NlY29uZCksIG5ldyBQbGFpblRpbWUoYSwgaSwgcywgbCwgcCwgZik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxdWFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHMoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxUaW1lKGUpO1xuICAgICAgZm9yICh2YXIgX2kyNyA9IDAsIF9hcnIxMiA9IFtkLCBtLCBjLCBoLCB1LCBUXTsgX2kyNyA8IF9hcnIxMi5sZW5ndGg7IF9pMjcrKykge1xuICAgICAgICB2YXIgX2U1OSA9IF9hcnIxMltfaTI3XTtcbiAgICAgICAgaWYgKEdldFNsb3QodGhpcywgX2U1OSkgIT09IEdldFNsb3QodCwgX2U1OSkpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEdldE9wdGlvbnNPYmplY3QoZSksXG4gICAgICAgIHIgPSBUb0ZyYWN0aW9uYWxTZWNvbmREaWdpdHModCksXG4gICAgICAgIG8gPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKHQsIFwidHJ1bmNcIiksXG4gICAgICAgIG4gPSBHZXRUZW1wb3JhbFVuaXQodCwgXCJzbWFsbGVzdFVuaXRcIiwgXCJ0aW1lXCIsIHZvaWQgMCk7XG4gICAgICBpZiAoXCJob3VyXCIgPT09IG4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdzbWFsbGVzdFVuaXQgbXVzdCBiZSBhIHRpbWUgdW5pdCBvdGhlciB0aGFuIFwiaG91clwiJyk7XG4gICAgICB2YXIgX1RvU2Vjb25kc1N0cmluZ1ByZWNpNCA9IFRvU2Vjb25kc1N0cmluZ1ByZWNpc2lvblJlY29yZChuLCByKSxcbiAgICAgICAgYSA9IF9Ub1NlY29uZHNTdHJpbmdQcmVjaTQucHJlY2lzaW9uLFxuICAgICAgICBpID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpNC51bml0LFxuICAgICAgICBzID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpNC5pbmNyZW1lbnQ7XG4gICAgICByZXR1cm4gVGVtcG9yYWxUaW1lVG9TdHJpbmcodGhpcywgYSwge1xuICAgICAgICB1bml0OiBpLFxuICAgICAgICBpbmNyZW1lbnQ6IHMsXG4gICAgICAgIHJvdW5kaW5nTW9kZTogb1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUZW1wb3JhbFRpbWVUb1N0cmluZyh0aGlzLCBcImF1dG9cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvTG9jYWxlU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIG5ldyBodChlLCB0KS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlT2ZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1c2UgY29tcGFyZSgpIG9yIGVxdWFscygpIHRvIGNvbXBhcmUgVGVtcG9yYWwuUGxhaW5UaW1lXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1BsYWluRGF0ZVRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9QbGFpbkRhdGVUaW1lKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsRGF0ZShlKSxcbiAgICAgICAgciA9IEdldFNsb3QodCwgaSksXG4gICAgICAgIG8gPSBHZXRTbG90KHQsIHMpLFxuICAgICAgICBuID0gR2V0U2xvdCh0LCBsKSxcbiAgICAgICAgYSA9IEdldFNsb3QodCwgcCk7XG4gICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxEYXRlVGltZShyLCBvLCBuLCBHZXRTbG90KHRoaXMsIGQpLCBHZXRTbG90KHRoaXMsIG0pLCBHZXRTbG90KHRoaXMsIGMpLCBHZXRTbG90KHRoaXMsIGgpLCBHZXRTbG90KHRoaXMsIHUpLCBHZXRTbG90KHRoaXMsIFQpLCBhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9ab25lZERhdGVUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvWm9uZWREYXRlVGltZShlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIGlmICghSXNPYmplY3QoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgICAgdmFyIHQgPSBlLnBsYWluRGF0ZTtcbiAgICAgIGlmICh2b2lkIDAgPT09IHQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtaXNzaW5nIGRhdGUgcHJvcGVydHlcIik7XG4gICAgICB2YXIgciA9IFRvVGVtcG9yYWxEYXRlKHQpLFxuICAgICAgICBvID0gZS50aW1lWm9uZTtcbiAgICAgIGlmICh2b2lkIDAgPT09IG8pIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtaXNzaW5nIHRpbWVab25lIHByb3BlcnR5XCIpO1xuICAgICAgdmFyIGEgPSBUb1RlbXBvcmFsVGltZVpvbmVTbG90VmFsdWUobyksXG4gICAgICAgIGYgPSBHZXRTbG90KHIsIGkpLFxuICAgICAgICB5ID0gR2V0U2xvdChyLCBzKSxcbiAgICAgICAgSSA9IEdldFNsb3QociwgbCksXG4gICAgICAgIFMgPSBHZXRTbG90KHIsIHApLFxuICAgICAgICBnID0gR2V0U2xvdCh0aGlzLCBkKSxcbiAgICAgICAgdyA9IEdldFNsb3QodGhpcywgbSksXG4gICAgICAgIEQgPSBHZXRTbG90KHRoaXMsIGMpLFxuICAgICAgICBHID0gR2V0U2xvdCh0aGlzLCBoKSxcbiAgICAgICAgdiA9IEdldFNsb3QodGhpcywgdSksXG4gICAgICAgIEMgPSBHZXRTbG90KHRoaXMsIFQpO1xuICAgICAgcmV0dXJuIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KEdldEluc3RhbnRGb3IoYSwgbmV3IChHZXRJbnRyaW5zaWMoXCIlVGVtcG9yYWwuUGxhaW5EYXRlVGltZSVcIikpKGYsIHksIEksIGcsIHcsIEQsIEcsIHYsIEMsIFMpLCBcImNvbXBhdGlibGVcIiksIG4pLCBhLCBTKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SVNPRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElTT0ZpZWxkcygpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNvSG91cjogR2V0U2xvdCh0aGlzLCBkKSxcbiAgICAgICAgaXNvTWljcm9zZWNvbmQ6IEdldFNsb3QodGhpcywgdSksXG4gICAgICAgIGlzb01pbGxpc2Vjb25kOiBHZXRTbG90KHRoaXMsIGgpLFxuICAgICAgICBpc29NaW51dGU6IEdldFNsb3QodGhpcywgbSksXG4gICAgICAgIGlzb05hbm9zZWNvbmQ6IEdldFNsb3QodGhpcywgVCksXG4gICAgICAgIGlzb1NlY29uZDogR2V0U2xvdCh0aGlzLCBjKVxuICAgICAgfTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20oZSwgdCkge1xuICAgICAgdmFyIHIgPSBUb1RlbXBvcmFsT3ZlcmZsb3coR2V0T3B0aW9uc09iamVjdCh0KSk7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbFRpbWUoZSkgPyBuZXcgUGxhaW5UaW1lKEdldFNsb3QoZSwgZCksIEdldFNsb3QoZSwgbSksIEdldFNsb3QoZSwgYyksIEdldFNsb3QoZSwgaCksIEdldFNsb3QoZSwgdSksIEdldFNsb3QoZSwgVCkpIDogVG9UZW1wb3JhbFRpbWUoZSwgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBhcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZShlLCB0KSB7XG4gICAgICB2YXIgciA9IFRvVGVtcG9yYWxUaW1lKGUpLFxuICAgICAgICBvID0gVG9UZW1wb3JhbFRpbWUodCk7XG4gICAgICBmb3IgKHZhciBfaTI4ID0gMCwgX2FycjEzID0gW2QsIG0sIGMsIGgsIHUsIFRdOyBfaTI4IDwgX2FycjEzLmxlbmd0aDsgX2kyOCsrKSB7XG4gICAgICAgIHZhciBfZTYwID0gX2FycjEzW19pMjhdO1xuICAgICAgICB2YXIgX3Q1NSA9IEdldFNsb3QociwgX2U2MCksXG4gICAgICAgICAgX24yOSA9IEdldFNsb3QobywgX2U2MCk7XG4gICAgICAgIGlmIChfdDU1ICE9PSBfbjI5KSByZXR1cm4gQ29tcGFyaXNvblJlc3VsdChfdDU1IC0gX24yOSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBsYWluVGltZTtcbn0oKTtcbk1ha2VJbnRyaW5zaWNDbGFzcyhQbGFpblRpbWUsIFwiVGVtcG9yYWwuUGxhaW5UaW1lXCIpO1xudmFyIFRpbWVab25lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGltZVpvbmUoZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lWm9uZSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm1pc3NpbmcgYXJndW1lbnQ6IGlkZW50aWZpZXIgaXMgcmVxdWlyZWRcIik7XG4gICAgdmFyIHQgPSBHZXRDYW5vbmljYWxUaW1lWm9uZUlkZW50aWZpZXIoZSk7XG4gICAgTih0aGlzKSwgU2V0U2xvdCh0aGlzLCBhLCB0KTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoVGltZVpvbmUsIFt7XG4gICAga2V5OiBcImlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdCh0aGlzLCBhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3IoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsSW5zdGFudChlKSxcbiAgICAgICAgciA9IEdldFNsb3QodGhpcywgYSk7XG4gICAgICByZXR1cm4gSXNUaW1lWm9uZU9mZnNldFN0cmluZyhyKSA/IFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcocikgOiBHZXROYW1lZFRpbWVab25lT2Zmc2V0TmFub3NlY29uZHMociwgR2V0U2xvdCh0LCBuKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9mZnNldFN0cmluZ0ZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPZmZzZXRTdHJpbmdGb3IoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldE9mZnNldFN0cmluZ0Zvcih0aGlzLCBUb1RlbXBvcmFsSW5zdGFudChlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBsYWluRGF0ZVRpbWVGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGxhaW5EYXRlVGltZUZvcihlKSB7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJpc284NjAxXCI7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxUaW1lWm9uZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0UGxhaW5EYXRlVGltZUZvcih0aGlzLCBUb1RlbXBvcmFsSW5zdGFudChlKSwgVG9UZW1wb3JhbENhbGVuZGFyU2xvdFZhbHVlKHQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW5zdGFudEZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW50Rm9yKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRJbnN0YW50Rm9yKHRoaXMsIFRvVGVtcG9yYWxEYXRlVGltZShlKSwgVG9UZW1wb3JhbERpc2FtYmlndWF0aW9uKEdldE9wdGlvbnNPYmplY3QodCkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zc2libGVJbnN0YW50c0ZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NzaWJsZUluc3RhbnRzRm9yKHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciByID0gVG9UZW1wb3JhbERhdGVUaW1lKHQpLFxuICAgICAgICBvID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpLFxuICAgICAgICBuID0gR2V0U2xvdCh0aGlzLCBhKTtcbiAgICAgIGlmIChJc1RpbWVab25lT2Zmc2V0U3RyaW5nKG4pKSB7XG4gICAgICAgIHZhciBfdDU2ID0gR2V0VVRDRXBvY2hOYW5vc2Vjb25kcyhHZXRTbG90KHIsIGkpLCBHZXRTbG90KHIsIHMpLCBHZXRTbG90KHIsIGwpLCBHZXRTbG90KHIsIGQpLCBHZXRTbG90KHIsIG0pLCBHZXRTbG90KHIsIGMpLCBHZXRTbG90KHIsIGgpLCBHZXRTbG90KHIsIHUpLCBHZXRTbG90KHIsIFQpKTtcbiAgICAgICAgaWYgKG51bGwgPT09IF90NTYpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRGF0ZVRpbWUgb3V0c2lkZSBvZiBzdXBwb3J0ZWQgcmFuZ2VcIik7XG4gICAgICAgIHZhciBfYTIxID0gUGFyc2VUaW1lWm9uZU9mZnNldFN0cmluZyhuKTtcbiAgICAgICAgcmV0dXJuIFtuZXcgbyhfdDU2IC0gQmlnSW50KF9hMjEpKV07XG4gICAgICB9XG4gICAgICB2YXIgcCA9IGZ1bmN0aW9uIEdldE5hbWVkVGltZVpvbmVFcG9jaE5hbm9zZWNvbmRzKHQsIHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0pIHtcbiAgICAgICAgdmFyIGMgPSBHZXRVVENFcG9jaE5hbm9zZWNvbmRzKHIsIG8sIG4sIGEsIGksIHMsIGwsIGQsIG0pO1xuICAgICAgICBpZiAobnVsbCA9PT0gYykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEYXRlVGltZSBvdXRzaWRlIG9mIHN1cHBvcnRlZCByYW5nZVwiKTtcbiAgICAgICAgdmFyIGggPSBjIC0gRWU7XG4gICAgICAgIGggPCBNZSAmJiAoaCA9IGMpO1xuICAgICAgICB2YXIgdSA9IGMgKyBFZTtcbiAgICAgICAgdSA+IFJlICYmICh1ID0gYyk7XG4gICAgICAgIHZhciBUID0gR2V0TmFtZWRUaW1lWm9uZU9mZnNldE5hbm9zZWNvbmRzKHQsIGgpLFxuICAgICAgICAgIHAgPSBHZXROYW1lZFRpbWVab25lT2Zmc2V0TmFub3NlY29uZHModCwgdSk7XG4gICAgICAgIHJldHVybiAoVCA9PT0gcCA/IFtUXSA6IFtULCBwXSkubWFwKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgdmFyIHUgPSBjIC0gQmlnSW50KGgpLFxuICAgICAgICAgICAgVCA9IEdldE5hbWVkVGltZVpvbmVEYXRlVGltZVBhcnRzKHQsIHUpO1xuICAgICAgICAgIGlmIChyID09PSBULnllYXIgJiYgbyA9PT0gVC5tb250aCAmJiBuID09PSBULmRheSAmJiBhID09PSBULmhvdXIgJiYgaSA9PT0gVC5taW51dGUgJiYgcyA9PT0gVC5zZWNvbmQgJiYgbCA9PT0gVC5taWxsaXNlY29uZCAmJiBkID09PSBULm1pY3Jvc2Vjb25kICYmIG0gPT09IFQubmFub3NlY29uZCkgcmV0dXJuIHU7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDAgIT09IGU7XG4gICAgICAgIH0pO1xuICAgICAgfShuLCBHZXRTbG90KHIsIGkpLCBHZXRTbG90KHIsIHMpLCBHZXRTbG90KHIsIGwpLCBHZXRTbG90KHIsIGQpLCBHZXRTbG90KHIsIG0pLCBHZXRTbG90KHIsIGMpLCBHZXRTbG90KHIsIGgpLCBHZXRTbG90KHIsIHUpLCBHZXRTbG90KHIsIFQpKTtcbiAgICAgIHJldHVybiBwLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gbmV3IG8oZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmV4dFRyYW5zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmV4dFRyYW5zaXRpb24oZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsSW5zdGFudChlKSxcbiAgICAgICAgciA9IEdldFNsb3QodGhpcywgYSk7XG4gICAgICBpZiAoSXNUaW1lWm9uZU9mZnNldFN0cmluZyhyKSB8fCBcIlVUQ1wiID09PSByKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBvID0gR2V0U2xvdCh0LCBuKTtcbiAgICAgIHZhciBpID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpO1xuICAgICAgcmV0dXJuIG8gPSBHZXROYW1lZFRpbWVab25lTmV4dFRyYW5zaXRpb24ociwgbyksIG51bGwgPT09IG8gPyBudWxsIDogbmV3IGkobyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFByZXZpb3VzVHJhbnNpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcmV2aW91c1RyYW5zaXRpb24oZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsSW5zdGFudChlKSxcbiAgICAgICAgciA9IEdldFNsb3QodGhpcywgYSk7XG4gICAgICBpZiAoSXNUaW1lWm9uZU9mZnNldFN0cmluZyhyKSB8fCBcIlVUQ1wiID09PSByKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBvID0gR2V0U2xvdCh0LCBuKTtcbiAgICAgIHZhciBpID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpO1xuICAgICAgcmV0dXJuIG8gPSBHZXROYW1lZFRpbWVab25lUHJldmlvdXNUcmFuc2l0aW9uKHIsIG8pLCBudWxsID09PSBvID8gbnVsbCA6IG5ldyBpKG8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFRpbWVab25lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KHRoaXMsIGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsVGltZVpvbmUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QodGhpcywgYSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKGUpIHtcbiAgICAgIHJldHVybiBUb1RlbXBvcmFsVGltZVpvbmVPYmplY3QoVG9UZW1wb3JhbFRpbWVab25lU2xvdFZhbHVlKGUpKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRpbWVab25lO1xufSgpO1xuTWFrZUludHJpbnNpY0NsYXNzKFRpbWVab25lLCBcIlRlbXBvcmFsLlRpbWVab25lXCIpLCBEZWZpbmVJbnRyaW5zaWMoXCJUZW1wb3JhbC5UaW1lWm9uZS5wcm90b3R5cGUuZ2V0T2Zmc2V0TmFub3NlY29uZHNGb3JcIiwgVGltZVpvbmUucHJvdG90eXBlLmdldE9mZnNldE5hbm9zZWNvbmRzRm9yKSwgRGVmaW5lSW50cmluc2ljKFwiVGVtcG9yYWwuVGltZVpvbmUucHJvdG90eXBlLmdldFBvc3NpYmxlSW5zdGFudHNGb3JcIiwgVGltZVpvbmUucHJvdG90eXBlLmdldFBvc3NpYmxlSW5zdGFudHNGb3IpO1xudmFyIFJ0ID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBQbGFpblllYXJNb250aCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBsYWluWWVhck1vbnRoKGUsIHQpIHtcbiAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJpc284NjAxXCI7XG4gICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYWluWWVhck1vbnRoKTtcbiAgICBDcmVhdGVUZW1wb3JhbFllYXJNb250aFNsb3RzKHRoaXMsIFRvSW50ZWdlcldpdGhUcnVuY2F0aW9uKGUpLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbih0KSwgVG9UZW1wb3JhbENhbGVuZGFyU2xvdFZhbHVlKHIpLCBUb0ludGVnZXJXaXRoVHJ1bmNhdGlvbihvKSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFBsYWluWWVhck1vbnRoLCBbe1xuICAgIGtleTogXCJ5ZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyWWVhcihHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aChHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhDb2RlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxlbmRhcklkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRvVGVtcG9yYWxDYWxlbmRhcklkZW50aWZpZXIoR2V0U2xvdCh0aGlzLCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVyYVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckVyYShHZXRTbG90KHRoaXMsIHApLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJhWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckVyYVllYXIoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJbk1vbnRoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luTW9udGgoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJblllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJEYXlzSW5ZZWFyKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aHNJblllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aHNJblllYXIoR2V0U2xvdCh0aGlzLCBwKSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluTGVhcFllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJJbkxlYXBZZWFyKEdldFNsb3QodGhpcywgcCksIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF93aXRoKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICAgIFJlamVjdFRlbXBvcmFsTGlrZU9iamVjdChlKTtcbiAgICAgIHZhciByID0gR2V0T3B0aW9uc09iamVjdCh0KSxcbiAgICAgICAgbyA9IEdldFNsb3QodGhpcywgcCksXG4gICAgICAgIG4gPSBDYWxlbmRhckZpZWxkcyhvLCBbXCJtb250aFwiLCBcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0pO1xuICAgICAgdmFyIGEgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModGhpcywgbiwgW10pO1xuICAgICAgcmV0dXJuIGEgPSBDYWxlbmRhck1lcmdlRmllbGRzKG8sIGEsIFByZXBhcmVUZW1wb3JhbEZpZWxkcyhlLCBuLCBcInBhcnRpYWxcIikpLCBhID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGEsIG4sIFtdKSwgQ2FsZW5kYXJZZWFyTW9udGhGcm9tRmllbGRzKG8sIGEsIHIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21QbGFpblllYXJNb250aChcImFkZFwiLCB0aGlzLCBlLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3VidHJhY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBBZGREdXJhdGlvblRvT3JTdWJ0cmFjdER1cmF0aW9uRnJvbVBsYWluWWVhck1vbnRoKFwic3VidHJhY3RcIiwgdGhpcywgZSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVudGlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVudGlsKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsUGxhaW5ZZWFyTW9udGgoXCJ1bnRpbFwiLCB0aGlzLCBlLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2luY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2luY2UoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBEaWZmZXJlbmNlVGVtcG9yYWxQbGFpblllYXJNb250aChcInNpbmNlXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxZZWFyTW9udGgoZSk7XG4gICAgICBmb3IgKHZhciBfaTI5ID0gMCwgX2FycjE0ID0gW2ksIHMsIGxdOyBfaTI5IDwgX2FycjE0Lmxlbmd0aDsgX2kyOSsrKSB7XG4gICAgICAgIHZhciBfZTYxID0gX2FycjE0W19pMjldO1xuICAgICAgICBpZiAoR2V0U2xvdCh0aGlzLCBfZTYxKSAhPT0gR2V0U2xvdCh0LCBfZTYxKSkgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENhbGVuZGFyRXF1YWxzKEdldFNsb3QodGhpcywgcCksIEdldFNsb3QodCwgcCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRlbXBvcmFsWWVhck1vbnRoVG9TdHJpbmcodGhpcywgVG9DYWxlbmRhck5hbWVPcHRpb24oR2V0T3B0aW9uc09iamVjdChlKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWWVhck1vbnRoKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUZW1wb3JhbFllYXJNb250aFRvU3RyaW5nKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0xvY2FsZVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZyhlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIG5ldyBodChlLCB0KS5mb3JtYXQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlT2ZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1c2UgY29tcGFyZSgpIG9yIGVxdWFscygpIHRvIGNvbXBhcmUgVGVtcG9yYWwuUGxhaW5ZZWFyTW9udGhcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvUGxhaW5EYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUGxhaW5EYXRlKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICBpZiAoIUlzT2JqZWN0KGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc2hvdWxkIGJlIGFuIG9iamVjdFwiKTtcbiAgICAgIHZhciB0ID0gR2V0U2xvdCh0aGlzLCBwKSxcbiAgICAgICAgciA9IENhbGVuZGFyRmllbGRzKHQsIFtcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0pLFxuICAgICAgICBvID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIHIsIFtdKSxcbiAgICAgICAgbiA9IENhbGVuZGFyRmllbGRzKHQsIFtcImRheVwiXSk7XG4gICAgICB2YXIgYSA9IENhbGVuZGFyTWVyZ2VGaWVsZHModCwgbywgUHJlcGFyZVRlbXBvcmFsRmllbGRzKGUsIG4sIFtdKSk7XG4gICAgICBhID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGEsIF90b0NvbnN1bWFibGVBcnJheShuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkociksIF90b0NvbnN1bWFibGVBcnJheShuKSkpKSwgW10pO1xuICAgICAgdmFyIGkgPSBSdChudWxsKTtcbiAgICAgIHJldHVybiBpLm92ZXJmbG93ID0gXCJyZWplY3RcIiwgQ2FsZW5kYXJEYXRlRnJvbUZpZWxkcyh0LCBhLCBpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SVNPRmllbGRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElTT0ZpZWxkcygpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFllYXJNb250aCh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWxlbmRhcjogR2V0U2xvdCh0aGlzLCBwKSxcbiAgICAgICAgaXNvRGF5OiBHZXRTbG90KHRoaXMsIGwpLFxuICAgICAgICBpc29Nb250aDogR2V0U2xvdCh0aGlzLCBzKSxcbiAgICAgICAgaXNvWWVhcjogR2V0U2xvdCh0aGlzLCBpKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FsZW5kYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FsZW5kYXIoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxZZWFyTW9udGgodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRvVGVtcG9yYWxDYWxlbmRhck9iamVjdChHZXRTbG90KHRoaXMsIHApKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20oZSwgdCkge1xuICAgICAgdmFyIHIgPSBHZXRPcHRpb25zT2JqZWN0KHQpO1xuICAgICAgcmV0dXJuIElzVGVtcG9yYWxZZWFyTW9udGgoZSkgPyAoVG9UZW1wb3JhbE92ZXJmbG93KHIpLCBDcmVhdGVUZW1wb3JhbFllYXJNb250aChHZXRTbG90KGUsIGkpLCBHZXRTbG90KGUsIHMpLCBHZXRTbG90KGUsIHApLCBHZXRTbG90KGUsIGwpKSkgOiBUb1RlbXBvcmFsWWVhck1vbnRoKGUsIHIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmUoZSwgdCkge1xuICAgICAgdmFyIHIgPSBUb1RlbXBvcmFsWWVhck1vbnRoKGUpLFxuICAgICAgICBvID0gVG9UZW1wb3JhbFllYXJNb250aCh0KTtcbiAgICAgIHJldHVybiBDb21wYXJlSVNPRGF0ZShHZXRTbG90KHIsIGkpLCBHZXRTbG90KHIsIHMpLCBHZXRTbG90KHIsIGwpLCBHZXRTbG90KG8sIGkpLCBHZXRTbG90KG8sIHMpLCBHZXRTbG90KG8sIGwpKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBsYWluWWVhck1vbnRoO1xufSgpO1xuTWFrZUludHJpbnNpY0NsYXNzKFBsYWluWWVhck1vbnRoLCBcIlRlbXBvcmFsLlBsYWluWWVhck1vbnRoXCIpO1xudmFyIEZ0ID0gaHQucHJvdG90eXBlLnJlc29sdmVkT3B0aW9ucyxcbiAgWXQgPSBPYmplY3QuY3JlYXRlO1xudmFyIFpvbmVkRGF0ZVRpbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBab25lZERhdGVUaW1lKGUsIHQpIHtcbiAgICB2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJpc284NjAxXCI7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFpvbmVkRGF0ZVRpbWUpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1pc3NpbmcgYXJndW1lbnQ6IGVwb2NoTmFub3NlY29uZHMgaXMgcmVxdWlyZWRcIik7XG4gICAgQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lU2xvdHModGhpcywgVG9CaWdJbnQoZSksIFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZSh0KSwgVG9UZW1wb3JhbENhbGVuZGFyU2xvdFZhbHVlKHIpKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoWm9uZWREYXRlVGltZSwgW3tcbiAgICBrZXk6IFwiY2FsZW5kYXJJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVG9UZW1wb3JhbENhbGVuZGFySWRlbnRpZmllcihHZXRTbG90KHRoaXMsIHApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZVpvbmVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVG9UZW1wb3JhbFRpbWVab25lSWRlbnRpZmllcihHZXRTbG90KHRoaXMsIGcpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJZZWFyKEdldFNsb3QodGhpcywgcCksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW9udGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGgoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb250aENvZGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyTW9udGhDb2RlKEdldFNsb3QodGhpcywgcCksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheShHZXRTbG90KHRoaXMsIHApLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhvdXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIGQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaW51dGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIG0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWNvbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldFNsb3QoZGF0ZVRpbWUodGhpcyksIGMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaWxsaXNlY29uZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdChkYXRlVGltZSh0aGlzKSwgaCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pY3Jvc2Vjb25kXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBHZXRTbG90KGRhdGVUaW1lKHRoaXMpLCB1KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmFub3NlY29uZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gR2V0U2xvdChkYXRlVGltZSh0aGlzKSwgVCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVyYVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJFcmEoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcmFZZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckVyYVllYXIoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcG9jaFNlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBHZXRTbG90KHRoaXMsIG4pO1xuICAgICAgcmV0dXJuIE51bWJlcihCaWdJbnRGbG9vckRpdih0LCB2ZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcG9jaE1pbGxpc2Vjb25kc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEdldFNsb3QodGhpcywgbik7XG4gICAgICByZXR1cm4gTnVtYmVyKEJpZ0ludEZsb29yRGl2KHQsIEdlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVwb2NoTWljcm9zZWNvbmRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUb0JpZ0ludEV4dGVybmFsKEJpZ0ludEZsb29yRGl2KEdldFNsb3QodGhpcywgbiksIERlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVwb2NoTmFub3NlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIFRvQmlnSW50RXh0ZXJuYWwoR2V0U2xvdCh0aGlzLCBuKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheU9mV2Vla1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJEYXlPZldlZWsoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlPZlllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5T2ZZZWFyKEdldFNsb3QodGhpcywgcCksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2Vla09mWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJXZWVrT2ZZZWFyKEdldFNsb3QodGhpcywgcCksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieWVhck9mV2Vla1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJZZWFyT2ZXZWVrKEdldFNsb3QodGhpcywgcCksIGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaG91cnNJbkRheVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IGRhdGVUaW1lKHRoaXMpLFxuICAgICAgICByID0gR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlXCIpLFxuICAgICAgICBvID0gR2V0U2xvdCh0LCBpKSxcbiAgICAgICAgYSA9IEdldFNsb3QodCwgcyksXG4gICAgICAgIGQgPSBHZXRTbG90KHQsIGwpLFxuICAgICAgICBtID0gbmV3IHIobywgYSwgZCwgMCwgMCwgMCwgMCwgMCwgMCksXG4gICAgICAgIGMgPSBBZGRJU09EYXRlKG8sIGEsIGQsIDAsIDAsIDAsIDEsIFwicmVqZWN0XCIpLFxuICAgICAgICBoID0gbmV3IHIoYy55ZWFyLCBjLm1vbnRoLCBjLmRheSwgMCwgMCwgMCwgMCwgMCwgMCksXG4gICAgICAgIHUgPSBHZXRTbG90KHRoaXMsIGcpLFxuICAgICAgICBUID0gR2V0U2xvdChHZXRJbnN0YW50Rm9yKHUsIG0sIFwiY29tcGF0aWJsZVwiKSwgbiksXG4gICAgICAgIHAgPSBHZXRTbG90KEdldEluc3RhbnRGb3IodSwgaCwgXCJjb21wYXRpYmxlXCIpLCBuKTtcbiAgICAgIHJldHVybiBCaWdJbnREaXZpZGVUb051bWJlcihwIC0gVCwgT2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlzSW5XZWVrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckRheXNJbldlZWsoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkYXlzSW5Nb250aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJEYXlzSW5Nb250aChHZXRTbG90KHRoaXMsIHApLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRheXNJblllYXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIENhbGVuZGFyRGF5c0luWWVhcihHZXRTbG90KHRoaXMsIHApLCBkYXRlVGltZSh0aGlzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vbnRoc0luWWVhclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aHNJblllYXIoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbkxlYXBZZWFyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBDYWxlbmRhckluTGVhcFllYXIoR2V0U2xvdCh0aGlzLCBwKSwgZGF0ZVRpbWUodGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZzZXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldE9mZnNldFN0cmluZ0ZvcihHZXRTbG90KHRoaXMsIGcpLCBHZXRTbG90KHRoaXMsIFMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2Zmc2V0TmFub3NlY29uZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIEdldE9mZnNldE5hbm9zZWNvbmRzRm9yKEdldFNsb3QodGhpcywgZyksIEdldFNsb3QodGhpcywgUykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF93aXRoKGUsIHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKCFJc09iamVjdChlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgem9uZWQtZGF0ZS10aW1lLWxpa2VcIik7XG4gICAgICBSZWplY3RUZW1wb3JhbExpa2VPYmplY3QoZSk7XG4gICAgICB2YXIgciA9IEdldE9wdGlvbnNPYmplY3QodCksXG4gICAgICAgIG8gPSBHZXRTbG90KHRoaXMsIHApO1xuICAgICAgdmFyIG4gPSBDYWxlbmRhckZpZWxkcyhvLCBbXCJkYXlcIiwgXCJob3VyXCIsIFwibWljcm9zZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiLCBcIm1pbnV0ZVwiLCBcIm1vbnRoXCIsIFwibW9udGhDb2RlXCIsIFwibmFub3NlY29uZFwiLCBcInNlY29uZFwiLCBcInllYXJcIl0pO1xuICAgICAgbi5wdXNoKFwib2Zmc2V0XCIpO1xuICAgICAgdmFyIGEgPSBQcmVwYXJlVGVtcG9yYWxGaWVsZHModGhpcywgbiwgW1wib2Zmc2V0XCJdKTtcbiAgICAgIGEgPSBDYWxlbmRhck1lcmdlRmllbGRzKG8sIGEsIFByZXBhcmVUZW1wb3JhbEZpZWxkcyhlLCBuLCBcInBhcnRpYWxcIikpLCBhID0gUHJlcGFyZVRlbXBvcmFsRmllbGRzKGEsIG4sIFtcIm9mZnNldFwiXSk7XG4gICAgICB2YXIgaSA9IFRvVGVtcG9yYWxEaXNhbWJpZ3VhdGlvbihyKSxcbiAgICAgICAgcyA9IFRvVGVtcG9yYWxPZmZzZXQociwgXCJwcmVmZXJcIik7XG4gICAgICB2YXIgX0ludGVycHJldFRlbXBvcmFsRGF0NSA9IEludGVycHJldFRlbXBvcmFsRGF0ZVRpbWVGaWVsZHMobywgYSwgciksXG4gICAgICAgIGwgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ1LnllYXIsXG4gICAgICAgIGQgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ1Lm1vbnRoLFxuICAgICAgICBtID0gX0ludGVycHJldFRlbXBvcmFsRGF0NS5kYXksXG4gICAgICAgIGMgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ1LmhvdXIsXG4gICAgICAgIGggPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ1Lm1pbnV0ZSxcbiAgICAgICAgdSA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDUuc2Vjb25kLFxuICAgICAgICBUID0gX0ludGVycHJldFRlbXBvcmFsRGF0NS5taWxsaXNlY29uZCxcbiAgICAgICAgZiA9IF9JbnRlcnByZXRUZW1wb3JhbERhdDUubWljcm9zZWNvbmQsXG4gICAgICAgIHkgPSBfSW50ZXJwcmV0VGVtcG9yYWxEYXQ1Lm5hbm9zZWNvbmQ7XG4gICAgICB2YXIgSSA9IFBhcnNlVGltZVpvbmVPZmZzZXRTdHJpbmcoYS5vZmZzZXQpLFxuICAgICAgICBTID0gR2V0U2xvdCh0aGlzLCBnKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoSW50ZXJwcmV0SVNPRGF0ZVRpbWVPZmZzZXQobCwgZCwgbSwgYywgaCwgdSwgVCwgZiwgeSwgXCJvcHRpb25cIiwgSSwgUywgaSwgcywgITEpLCBTLCBvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aFBsYWluRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoUGxhaW5EYXRlKGUpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHQgPSBUb1RlbXBvcmFsRGF0ZShlKSxcbiAgICAgICAgciA9IEdldFNsb3QodCwgaSksXG4gICAgICAgIG8gPSBHZXRTbG90KHQsIHMpLFxuICAgICAgICBhID0gR2V0U2xvdCh0LCBsKTtcbiAgICAgIHZhciBmID0gR2V0U2xvdCh0LCBwKTtcbiAgICAgIHZhciB5ID0gZGF0ZVRpbWUodGhpcyksXG4gICAgICAgIEkgPSBHZXRTbG90KHksIGQpLFxuICAgICAgICBTID0gR2V0U2xvdCh5LCBtKSxcbiAgICAgICAgdyA9IEdldFNsb3QoeSwgYyksXG4gICAgICAgIEQgPSBHZXRTbG90KHksIGgpLFxuICAgICAgICBHID0gR2V0U2xvdCh5LCB1KSxcbiAgICAgICAgdiA9IEdldFNsb3QoeSwgVCk7XG4gICAgICBmID0gQ29uc29saWRhdGVDYWxlbmRhcnMoR2V0U2xvdCh0aGlzLCBwKSwgZik7XG4gICAgICB2YXIgQyA9IEdldFNsb3QodGhpcywgZyk7XG4gICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEdldFNsb3QoR2V0SW5zdGFudEZvcihDLCBuZXcgKEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKSkociwgbywgYSwgSSwgUywgdywgRCwgRywgdiwgZiksIFwiY29tcGF0aWJsZVwiKSwgbiksIEMsIGYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoUGxhaW5UaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhQbGFpblRpbWUoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpblRpbWUlXCIpLFxuICAgICAgICByID0gdm9pZCAwID09PSBlID8gbmV3IHQoKSA6IFRvVGVtcG9yYWxUaW1lKGUpLFxuICAgICAgICBvID0gZGF0ZVRpbWUodGhpcyksXG4gICAgICAgIGEgPSBHZXRTbG90KG8sIGkpLFxuICAgICAgICBmID0gR2V0U2xvdChvLCBzKSxcbiAgICAgICAgeSA9IEdldFNsb3QobywgbCksXG4gICAgICAgIEkgPSBHZXRTbG90KHRoaXMsIHApLFxuICAgICAgICBTID0gR2V0U2xvdChyLCBkKSxcbiAgICAgICAgdyA9IEdldFNsb3QociwgbSksXG4gICAgICAgIEQgPSBHZXRTbG90KHIsIGMpLFxuICAgICAgICBHID0gR2V0U2xvdChyLCBoKSxcbiAgICAgICAgdiA9IEdldFNsb3QociwgdSksXG4gICAgICAgIEMgPSBHZXRTbG90KHIsIFQpLFxuICAgICAgICBPID0gR2V0U2xvdCh0aGlzLCBnKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdChHZXRJbnN0YW50Rm9yKE8sIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLlBsYWluRGF0ZVRpbWUlXCIpKShhLCBmLCB5LCBTLCB3LCBELCBHLCB2LCBDLCBJKSwgXCJjb21wYXRpYmxlXCIpLCBuKSwgTywgSSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhUaW1lWm9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoVGltZVpvbmUoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxUaW1lWm9uZVNsb3RWYWx1ZShlKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBuKSwgdCwgR2V0U2xvdCh0aGlzLCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhDYWxlbmRhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQ2FsZW5kYXIoZSkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgdCA9IFRvVGVtcG9yYWxDYWxlbmRhclNsb3RWYWx1ZShlKTtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoR2V0U2xvdCh0aGlzLCBuKSwgR2V0U2xvdCh0aGlzLCBnKSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gQWRkRHVyYXRpb25Ub09yU3VidHJhY3REdXJhdGlvbkZyb21ab25lZERhdGVUaW1lKFwiYWRkXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0cmFjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJ0cmFjdChlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBBZGREdXJhdGlvblRvT3JTdWJ0cmFjdER1cmF0aW9uRnJvbVpvbmVkRGF0ZVRpbWUoXCJzdWJ0cmFjdFwiLCB0aGlzLCBlLCB0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW50aWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW50aWwoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gRGlmZmVyZW5jZVRlbXBvcmFsWm9uZWREYXRlVGltZShcInVudGlsXCIsIHRoaXMsIGUsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaW5jZShlLCB0KSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBEaWZmZXJlbmNlVGVtcG9yYWxab25lZERhdGVUaW1lKFwic2luY2VcIiwgdGhpcywgZSwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdW5kKHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbnMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgdmFyIHIgPSBcInN0cmluZ1wiID09IHR5cGVvZiB0ID8gQ3JlYXRlT25lUHJvcE9iamVjdChcInNtYWxsZXN0VW5pdFwiLCB0KSA6IEdldE9wdGlvbnNPYmplY3QodCksXG4gICAgICAgIG8gPSBUb1RlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQociksXG4gICAgICAgIGEgPSBUb1RlbXBvcmFsUm91bmRpbmdNb2RlKHIsIFwiaGFsZkV4cGFuZFwiKSxcbiAgICAgICAgZiA9IEdldFRlbXBvcmFsVW5pdChyLCBcInNtYWxsZXN0VW5pdFwiLCBcInRpbWVcIiwgSGUsIFtcImRheVwiXSksXG4gICAgICAgIHkgPSB7XG4gICAgICAgICAgZGF5OiAxLFxuICAgICAgICAgIGhvdXI6IDI0LFxuICAgICAgICAgIG1pbnV0ZTogNjAsXG4gICAgICAgICAgc2Vjb25kOiA2MCxcbiAgICAgICAgICBtaWxsaXNlY29uZDogMWUzLFxuICAgICAgICAgIG1pY3Jvc2Vjb25kOiAxZTMsXG4gICAgICAgICAgbmFub3NlY29uZDogMWUzXG4gICAgICAgIH1bZl07XG4gICAgICBWYWxpZGF0ZVRlbXBvcmFsUm91bmRpbmdJbmNyZW1lbnQobywgeSwgMSA9PT0geSk7XG4gICAgICB2YXIgSSA9IGRhdGVUaW1lKHRoaXMpO1xuICAgICAgdmFyIHcgPSBHZXRTbG90KEksIGkpLFxuICAgICAgICBEID0gR2V0U2xvdChJLCBzKSxcbiAgICAgICAgRyA9IEdldFNsb3QoSSwgbCksXG4gICAgICAgIHYgPSBHZXRTbG90KEksIGQpLFxuICAgICAgICBDID0gR2V0U2xvdChJLCBtKSxcbiAgICAgICAgTyA9IEdldFNsb3QoSSwgYyksXG4gICAgICAgIGIgPSBHZXRTbG90KEksIGgpLFxuICAgICAgICBFID0gR2V0U2xvdChJLCB1KSxcbiAgICAgICAgTSA9IEdldFNsb3QoSSwgVCk7XG4gICAgICB2YXIgUiA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKSxcbiAgICAgICAgRiA9IEdldFNsb3QodGhpcywgZyksXG4gICAgICAgIFkgPSBHZXRTbG90KHRoaXMsIHApLFxuICAgICAgICBQID0gR2V0SW5zdGFudEZvcihGLCBuZXcgUihHZXRTbG90KEksIGkpLCBHZXRTbG90KEksIHMpLCBHZXRTbG90KEksIGwpLCAwLCAwLCAwLCAwLCAwLCAwKSwgXCJjb21wYXRpYmxlXCIpLFxuICAgICAgICBaID0gQWRkWm9uZWREYXRlVGltZShQLCBGLCBZLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAwKSxcbiAgICAgICAgQiA9IFogLSBCaWdJbnQoR2V0U2xvdChQLCBuKSk7XG4gICAgICBpZiAoQiA8PSBJZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJjYW5ub3Qgcm91bmQgYSBab25lZERhdGVUaW1lIGluIGEgY2FsZW5kYXIgd2l0aCB6ZXJvIG9yIG5lZ2F0aXZlIGxlbmd0aCBkYXlzXCIpO1xuICAgICAgdmFyIF9Sb3VuZElTT0RhdGVUaW1lMyA9IFJvdW5kSVNPRGF0ZVRpbWUodywgRCwgRywgdiwgQywgTywgYiwgRSwgTSwgbywgZiwgYSwgTnVtYmVyKEIpKTtcbiAgICAgIHcgPSBfUm91bmRJU09EYXRlVGltZTMueWVhcjtcbiAgICAgIEQgPSBfUm91bmRJU09EYXRlVGltZTMubW9udGg7XG4gICAgICBHID0gX1JvdW5kSVNPRGF0ZVRpbWUzLmRheTtcbiAgICAgIHYgPSBfUm91bmRJU09EYXRlVGltZTMuaG91cjtcbiAgICAgIEMgPSBfUm91bmRJU09EYXRlVGltZTMubWludXRlO1xuICAgICAgTyA9IF9Sb3VuZElTT0RhdGVUaW1lMy5zZWNvbmQ7XG4gICAgICBiID0gX1JvdW5kSVNPRGF0ZVRpbWUzLm1pbGxpc2Vjb25kO1xuICAgICAgRSA9IF9Sb3VuZElTT0RhdGVUaW1lMy5taWNyb3NlY29uZDtcbiAgICAgIE0gPSBfUm91bmRJU09EYXRlVGltZTMubmFub3NlY29uZDtcbiAgICAgIHJldHVybiBDcmVhdGVUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoSW50ZXJwcmV0SVNPRGF0ZVRpbWVPZmZzZXQodywgRCwgRywgdiwgQywgTywgYiwgRSwgTSwgXCJvcHRpb25cIiwgR2V0T2Zmc2V0TmFub3NlY29uZHNGb3IoRiwgR2V0U2xvdCh0aGlzLCBTKSksIEYsIFwiY29tcGF0aWJsZVwiLCBcInByZWZlclwiLCAhMSksIEYsIEdldFNsb3QodGhpcywgcCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKHQpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIHIgPSBUb1RlbXBvcmFsWm9uZWREYXRlVGltZSh0KSxcbiAgICAgICAgbyA9IEdldFNsb3QodGhpcywgbiksXG4gICAgICAgIGEgPSBHZXRTbG90KHIsIG4pO1xuICAgICAgcmV0dXJuICEhKEJpZ0ludChvKSA9PT0gQmlnSW50KGEpKSAmJiAhIVRpbWVab25lRXF1YWxzKEdldFNsb3QodGhpcywgZyksIEdldFNsb3QociwgZykpICYmIENhbGVuZGFyRXF1YWxzKEdldFNsb3QodGhpcywgcCksIEdldFNsb3QociwgcCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhlKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciB0ID0gR2V0T3B0aW9uc09iamVjdChlKSxcbiAgICAgICAgciA9IFRvQ2FsZW5kYXJOYW1lT3B0aW9uKHQpLFxuICAgICAgICBvID0gVG9GcmFjdGlvbmFsU2Vjb25kRGlnaXRzKHQpLFxuICAgICAgICBuID0gZnVuY3Rpb24gVG9TaG93T2Zmc2V0T3B0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gR2V0T3B0aW9uKGUsIFwib2Zmc2V0XCIsIFtcImF1dG9cIiwgXCJuZXZlclwiXSwgXCJhdXRvXCIpO1xuICAgICAgICB9KHQpLFxuICAgICAgICBhID0gVG9UZW1wb3JhbFJvdW5kaW5nTW9kZSh0LCBcInRydW5jXCIpLFxuICAgICAgICBpID0gR2V0VGVtcG9yYWxVbml0KHQsIFwic21hbGxlc3RVbml0XCIsIFwidGltZVwiLCB2b2lkIDApO1xuICAgICAgaWYgKFwiaG91clwiID09PSBpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc21hbGxlc3RVbml0IG11c3QgYmUgYSB0aW1lIHVuaXQgb3RoZXIgdGhhbiBcImhvdXJcIicpO1xuICAgICAgdmFyIHMgPSBmdW5jdGlvbiBUb1RpbWVab25lTmFtZU9wdGlvbihlKSB7XG4gICAgICAgICAgcmV0dXJuIEdldE9wdGlvbihlLCBcInRpbWVab25lTmFtZVwiLCBbXCJhdXRvXCIsIFwibmV2ZXJcIiwgXCJjcml0aWNhbFwiXSwgXCJhdXRvXCIpO1xuICAgICAgICB9KHQpLFxuICAgICAgICBfVG9TZWNvbmRzU3RyaW5nUHJlY2k1ID0gVG9TZWNvbmRzU3RyaW5nUHJlY2lzaW9uUmVjb3JkKGksIG8pLFxuICAgICAgICBsID0gX1RvU2Vjb25kc1N0cmluZ1ByZWNpNS5wcmVjaXNpb24sXG4gICAgICAgIGQgPSBfVG9TZWNvbmRzU3RyaW5nUHJlY2k1LnVuaXQsXG4gICAgICAgIG0gPSBfVG9TZWNvbmRzU3RyaW5nUHJlY2k1LmluY3JlbWVudDtcbiAgICAgIHJldHVybiBUZW1wb3JhbFpvbmVkRGF0ZVRpbWVUb1N0cmluZyh0aGlzLCBsLCByLCBzLCBuLCB7XG4gICAgICAgIHVuaXQ6IGQsXG4gICAgICAgIGluY3JlbWVudDogbSxcbiAgICAgICAgcm91bmRpbmdNb2RlOiBhXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9Mb2NhbGVTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoZSwgdCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgciA9IEdldE9wdGlvbnNPYmplY3QodCksXG4gICAgICAgIG8gPSBZdChudWxsKTtcbiAgICAgIGlmIChDb3B5RGF0YVByb3BlcnRpZXMobywgciwgW1widGltZVpvbmVcIl0pLCB2b2lkIDAgIT09IHIudGltZVpvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJab25lZERhdGVUaW1lIHRvTG9jYWxlU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBhIHRpbWVab25lIG9wdGlvblwiKTtcbiAgICAgIHZvaWQgMCA9PT0gby55ZWFyICYmIHZvaWQgMCA9PT0gby5tb250aCAmJiB2b2lkIDAgPT09IG8uZGF5ICYmIHZvaWQgMCA9PT0gby53ZWVrZGF5ICYmIHZvaWQgMCA9PT0gby5kYXRlU3R5bGUgJiYgdm9pZCAwID09PSBvLmhvdXIgJiYgdm9pZCAwID09PSBvLm1pbnV0ZSAmJiB2b2lkIDAgPT09IG8uc2Vjb25kICYmIHZvaWQgMCA9PT0gby50aW1lU3R5bGUgJiYgdm9pZCAwID09PSBvLmRheVBlcmlvZCAmJiB2b2lkIDAgPT09IG8udGltZVpvbmVOYW1lICYmIChvLnRpbWVab25lTmFtZSA9IFwic2hvcnRcIik7XG4gICAgICB2YXIgbiA9IFRvVGVtcG9yYWxUaW1lWm9uZUlkZW50aWZpZXIoR2V0U2xvdCh0aGlzLCBnKSk7XG4gICAgICBpZiAoSXNUaW1lWm9uZU9mZnNldFN0cmluZyhuKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0b0xvY2FsZVN0cmluZyBkb2VzIG5vdCBzdXBwb3J0IG9mZnNldCBzdHJpbmcgdGltZSB6b25lc1wiKTtcbiAgICAgIG4gPSBHZXRDYW5vbmljYWxUaW1lWm9uZUlkZW50aWZpZXIobiksIG8udGltZVpvbmUgPSBuO1xuICAgICAgdmFyIGEgPSBuZXcgaHQoZSwgbyksXG4gICAgICAgIGkgPSBDYWxsKEZ0LCBhLCBbXSkuY2FsZW5kYXIsXG4gICAgICAgIHMgPSBUb1RlbXBvcmFsQ2FsZW5kYXJJZGVudGlmaWVyKEdldFNsb3QodGhpcywgcCkpO1xuICAgICAgaWYgKFwiaXNvODYwMVwiICE9PSBzICYmIFwiaXNvODYwMVwiICE9PSBpICYmIGkgIT09IHMpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiY2Fubm90IGZvcm1hdCBab25lZERhdGVUaW1lIHdpdGggY2FsZW5kYXIgXCIuY29uY2F0KHMsIFwiIGluIGxvY2FsZSB3aXRoIGNhbGVuZGFyIFwiKS5jb25jYXQoaSkpO1xuICAgICAgcmV0dXJuIGEuZm9ybWF0KEdldFNsb3QodGhpcywgUykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVGVtcG9yYWxab25lZERhdGVUaW1lVG9TdHJpbmcodGhpcywgXCJhdXRvXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZU9mXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidXNlIGNvbXBhcmUoKSBvciBlcXVhbHMoKSB0byBjb21wYXJlIFRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0T2ZEYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRPZkRheSgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgdmFyIGUgPSBkYXRlVGltZSh0aGlzKSxcbiAgICAgICAgdCA9IEdldEludHJpbnNpYyhcIiVUZW1wb3JhbC5QbGFpbkRhdGVUaW1lJVwiKSxcbiAgICAgICAgciA9IEdldFNsb3QodGhpcywgcCksXG4gICAgICAgIG8gPSBuZXcgdChHZXRTbG90KGUsIGkpLCBHZXRTbG90KGUsIHMpLCBHZXRTbG90KGUsIGwpLCAwLCAwLCAwLCAwLCAwLCAwLCByKSxcbiAgICAgICAgYSA9IEdldFNsb3QodGhpcywgZyk7XG4gICAgICByZXR1cm4gQ3JlYXRlVGVtcG9yYWxab25lZERhdGVUaW1lKEdldFNsb3QoR2V0SW5zdGFudEZvcihhLCBvLCBcImNvbXBhdGlibGVcIiksIG4pLCBhLCByKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9JbnN0YW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSW5zdGFudCgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIG5ldyAoR2V0SW50cmluc2ljKFwiJVRlbXBvcmFsLkluc3RhbnQlXCIpKShHZXRTbG90KHRoaXMsIG4pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9QbGFpbkRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9QbGFpbkRhdGUoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9EYXRlKGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9QbGFpblRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9QbGFpblRpbWUoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUZW1wb3JhbERhdGVUaW1lVG9UaW1lKGRhdGVUaW1lKHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9QbGFpbkRhdGVUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUGxhaW5EYXRlVGltZSgpIHtcbiAgICAgIGlmICghSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUodGhpcykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHJlY2VpdmVyXCIpO1xuICAgICAgcmV0dXJuIGRhdGVUaW1lKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1BsYWluWWVhck1vbnRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvUGxhaW5ZZWFyTW9udGgoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciBlID0gR2V0U2xvdCh0aGlzLCBwKTtcbiAgICAgIHJldHVybiBDYWxlbmRhclllYXJNb250aEZyb21GaWVsZHMoZSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIENhbGVuZGFyRmllbGRzKGUsIFtcIm1vbnRoQ29kZVwiLCBcInllYXJcIl0pLCBbXSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1BsYWluTW9udGhEYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9QbGFpbk1vbnRoRGF5KCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICB2YXIgZSA9IEdldFNsb3QodGhpcywgcCk7XG4gICAgICByZXR1cm4gQ2FsZW5kYXJNb250aERheUZyb21GaWVsZHMoZSwgUHJlcGFyZVRlbXBvcmFsRmllbGRzKHRoaXMsIENhbGVuZGFyRmllbGRzKGUsIFtcImRheVwiLCBcIm1vbnRoQ29kZVwiXSksIFtdKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldElTT0ZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJU09GaWVsZHMoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHZhciBlID0gZGF0ZVRpbWUodGhpcyksXG4gICAgICAgIHQgPSBHZXRTbG90KHRoaXMsIGcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FsZW5kYXI6IEdldFNsb3QodGhpcywgcCksXG4gICAgICAgIGlzb0RheTogR2V0U2xvdChlLCBsKSxcbiAgICAgICAgaXNvSG91cjogR2V0U2xvdChlLCBkKSxcbiAgICAgICAgaXNvTWljcm9zZWNvbmQ6IEdldFNsb3QoZSwgdSksXG4gICAgICAgIGlzb01pbGxpc2Vjb25kOiBHZXRTbG90KGUsIGgpLFxuICAgICAgICBpc29NaW51dGU6IEdldFNsb3QoZSwgbSksXG4gICAgICAgIGlzb01vbnRoOiBHZXRTbG90KGUsIHMpLFxuICAgICAgICBpc29OYW5vc2Vjb25kOiBHZXRTbG90KGUsIFQpLFxuICAgICAgICBpc29TZWNvbmQ6IEdldFNsb3QoZSwgYyksXG4gICAgICAgIGlzb1llYXI6IEdldFNsb3QoZSwgaSksXG4gICAgICAgIG9mZnNldDogR2V0T2Zmc2V0U3RyaW5nRm9yKHQsIEdldFNsb3QodGhpcywgUykpLFxuICAgICAgICB0aW1lWm9uZTogdFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FsZW5kYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FsZW5kYXIoKSB7XG4gICAgICBpZiAoIUlzVGVtcG9yYWxab25lZERhdGVUaW1lKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCByZWNlaXZlclwiKTtcbiAgICAgIHJldHVybiBUb1RlbXBvcmFsQ2FsZW5kYXJPYmplY3QoR2V0U2xvdCh0aGlzLCBwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRpbWVab25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpbWVab25lKCkge1xuICAgICAgaWYgKCFJc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcmVjZWl2ZXJcIik7XG4gICAgICByZXR1cm4gVG9UZW1wb3JhbFRpbWVab25lT2JqZWN0KEdldFNsb3QodGhpcywgZykpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbShlLCB0KSB7XG4gICAgICB2YXIgciA9IEdldE9wdGlvbnNPYmplY3QodCk7XG4gICAgICByZXR1cm4gSXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUoZSkgPyAoVG9UZW1wb3JhbERpc2FtYmlndWF0aW9uKHIpLCBUb1RlbXBvcmFsT2Zmc2V0KHIsIFwicmVqZWN0XCIpLCBUb1RlbXBvcmFsT3ZlcmZsb3cociksIENyZWF0ZVRlbXBvcmFsWm9uZWREYXRlVGltZShHZXRTbG90KGUsIG4pLCBHZXRTbG90KGUsIGcpLCBHZXRTbG90KGUsIHApKSkgOiBUb1RlbXBvcmFsWm9uZWREYXRlVGltZShlLCByKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGFyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlKHQsIHIpIHtcbiAgICAgIHZhciBvID0gVG9UZW1wb3JhbFpvbmVkRGF0ZVRpbWUodCksXG4gICAgICAgIGEgPSBUb1RlbXBvcmFsWm9uZWREYXRlVGltZShyKSxcbiAgICAgICAgaSA9IEdldFNsb3QobywgbiksXG4gICAgICAgIHMgPSBHZXRTbG90KGEsIG4pO1xuICAgICAgcmV0dXJuIEJpZ0ludChpKSA8IEJpZ0ludChzKSA/IC0xIDogQmlnSW50KGkpID4gQmlnSW50KHMpID8gMSA6IDA7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBab25lZERhdGVUaW1lO1xufSgpO1xuZnVuY3Rpb24gZGF0ZVRpbWUoZSkge1xuICByZXR1cm4gR2V0UGxhaW5EYXRlVGltZUZvcihHZXRTbG90KGUsIGcpLCBHZXRTbG90KGUsIFMpLCBHZXRTbG90KGUsIHApKTtcbn1cbk1ha2VJbnRyaW5zaWNDbGFzcyhab25lZERhdGVUaW1lLCBcIlRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVcIik7XG52YXIgUHQgPSBPYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBDYWxlbmRhcjogQ2FsZW5kYXIsXG4gIER1cmF0aW9uOiBEdXJhdGlvbixcbiAgSW5zdGFudDogSW5zdGFudCxcbiAgTm93OiBFdCxcbiAgUGxhaW5EYXRlOiBQbGFpbkRhdGUsXG4gIFBsYWluRGF0ZVRpbWU6IFBsYWluRGF0ZVRpbWUsXG4gIFBsYWluTW9udGhEYXk6IFBsYWluTW9udGhEYXksXG4gIFBsYWluVGltZTogUGxhaW5UaW1lLFxuICBQbGFpblllYXJNb250aDogUGxhaW5ZZWFyTW9udGgsXG4gIFRpbWVab25lOiBUaW1lWm9uZSxcbiAgWm9uZWREYXRlVGltZTogWm9uZWREYXRlVGltZVxufSk7XG5mdW5jdGlvbiB0b1RlbXBvcmFsSW5zdGFudCgpIHtcbiAgdmFyIHQgPSBCaWdJbnQoK3RoaXMpICogR2U7XG4gIHJldHVybiBuZXcgSW5zdGFudCh0KTtcbn1cbnZhciBadCA9IFtJbnN0YW50LCBDYWxlbmRhciwgUGxhaW5EYXRlLCBQbGFpbkRhdGVUaW1lLCBEdXJhdGlvbiwgUGxhaW5Nb250aERheSwgUGxhaW5UaW1lLCBUaW1lWm9uZSwgUGxhaW5ZZWFyTW9udGgsIFpvbmVkRGF0ZVRpbWVdO1xuZm9yICh2YXIgX2kzMCA9IDAsIF9adCA9IFp0OyBfaTMwIDwgX1p0Lmxlbmd0aDsgX2kzMCsrKSB7XG4gIHZhciBfZTYyID0gX1p0W19pMzBdO1xuICB2YXIgX3Q1NyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2U2MiwgXCJwcm90b3R5cGVcIik7XG4gIChfdDU3LmNvbmZpZ3VyYWJsZSB8fCBfdDU3LmVudW1lcmFibGUgfHwgX3Q1Ny53cml0YWJsZSkgJiYgKF90NTcuY29uZmlndXJhYmxlID0gITEsIF90NTcuZW51bWVyYWJsZSA9ICExLCBfdDU3LndyaXRhYmxlID0gITEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZTYyLCBcInByb3RvdHlwZVwiLCBfdDU3KSk7XG59XG5cbnZhciBUZW1wb3JhbFBvbHlmaWxsID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEludGw6IHV0LFxuICBUZW1wb3JhbDogUHQsXG4gIHRvVGVtcG9yYWxJbnN0YW50OiB0b1RlbXBvcmFsSW5zdGFudFxufSk7XG5cbmdsb2JhbFRoaXMuVGVtcG9yYWxQb2x5ZmlsbCA9IFRlbXBvcmFsUG9seWZpbGw7XG4iLCIoZnVuY3Rpb24gKGYpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGc7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGcgPSB3aW5kb3c7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBnID0gZ2xvYmFsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGcgPSBzZWxmO1xuICAgIH0gZWxzZSB7XG4gICAgICBnID0gdGhpcztcbiAgICB9XG4gICAgZy5WaXJ0dWFsRG9tID0gZigpO1xuICB9XG59KShmdW5jdGlvbiAoKSB7XG4gIHZhciBkZWZpbmUsIG1vZHVsZSwgZXhwb3J0cztcbiAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gcihlLCBuLCB0KSB7XG4gICAgICBmdW5jdGlvbiBvKGksIGYpIHtcbiAgICAgICAgaWYgKCFuW2ldKSB7XG4gICAgICAgICAgaWYgKCFlW2ldKSB7XG4gICAgICAgICAgICB2YXIgYyA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcmVxdWlyZSAmJiByZXF1aXJlO1xuICAgICAgICAgICAgaWYgKCFmICYmIGMpIHJldHVybiBjKGksICEwKTtcbiAgICAgICAgICAgIGlmICh1KSByZXR1cm4gdShpLCAhMCk7XG4gICAgICAgICAgICB2YXIgYSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyBpICsgXCInXCIpO1xuICAgICAgICAgICAgdGhyb3cgKChhLmNvZGUgPSBcIk1PRFVMRV9OT1RfRk9VTkRcIiksIGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcCA9IChuW2ldID0geyBleHBvcnRzOiB7fSB9KTtcbiAgICAgICAgICBlW2ldWzBdLmNhbGwoXG4gICAgICAgICAgICBwLmV4cG9ydHMsXG4gICAgICAgICAgICBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICB2YXIgbiA9IGVbaV1bMV1bcl07XG4gICAgICAgICAgICAgIHJldHVybiBvKG4gfHwgcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIHAuZXhwb3J0cyxcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBlLFxuICAgICAgICAgICAgbixcbiAgICAgICAgICAgIHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuW2ldLmV4cG9ydHM7XG4gICAgICB9XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgdSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcmVxdWlyZSAmJiByZXF1aXJlLCBpID0gMDtcbiAgICAgICAgaSA8IHQubGVuZ3RoO1xuICAgICAgICBpKytcbiAgICAgIClcbiAgICAgICAgbyh0W2ldKTtcbiAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfSkoKShcbiAgICB7XG4gICAgICAxOiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge30sIHt9XSxcbiAgICAgIDI6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIC8qIVxuICAgICAgICAgICAqIENyb3NzLUJyb3dzZXIgU3BsaXQgMS4xLjFcbiAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAwNy0yMDEyIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPlxuICAgICAgICAgICAqIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAgICAgICAgICAgKiBFQ01BU2NyaXB0IGNvbXBsaWFudCwgdW5pZm9ybSBjcm9zcy1icm93c2VyIHNwbGl0IG1ldGhvZFxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogU3BsaXRzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncyB1c2luZyBhIHJlZ2V4IG9yIHN0cmluZyBzZXBhcmF0b3IuIE1hdGNoZXMgb2YgdGhlXG4gICAgICAgICAgICogc2VwYXJhdG9yIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBhcnJheS4gSG93ZXZlciwgaWYgYHNlcGFyYXRvcmAgaXMgYSByZWdleCB0aGF0IGNvbnRhaW5zXG4gICAgICAgICAgICogY2FwdHVyaW5nIGdyb3VwcywgYmFja3JlZmVyZW5jZXMgYXJlIHNwbGljZWQgaW50byB0aGUgcmVzdWx0IGVhY2ggdGltZSBgc2VwYXJhdG9yYCBpcyBtYXRjaGVkLlxuICAgICAgICAgICAqIEZpeGVzIGJyb3dzZXIgYnVncyBjb21wYXJlZCB0byB0aGUgbmF0aXZlIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBhbmQgY2FuIGJlIHVzZWQgcmVsaWFibHlcbiAgICAgICAgICAgKiBjcm9zcy1icm93c2VyLlxuICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNwbGl0LlxuICAgICAgICAgICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gc2VwYXJhdG9yIFJlZ2V4IG9yIHN0cmluZyB0byB1c2UgZm9yIHNlcGFyYXRpbmcgdGhlIHN0cmluZy5cbiAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0XSBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHQgYXJyYXkuXG4gICAgICAgICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBzdWJzdHJpbmdzLlxuICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAvLyBCYXNpYyB1c2VcbiAgICAgICAgICAgKiBzcGxpdCgnYSBiIGMgZCcsICcgJyk7XG4gICAgICAgICAgICogLy8gLT4gWydhJywgJ2InLCAnYycsICdkJ11cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIC8vIFdpdGggbGltaXRcbiAgICAgICAgICAgKiBzcGxpdCgnYSBiIGMgZCcsICcgJywgMik7XG4gICAgICAgICAgICogLy8gLT4gWydhJywgJ2InXVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogLy8gQmFja3JlZmVyZW5jZXMgaW4gcmVzdWx0IGFycmF5XG4gICAgICAgICAgICogc3BsaXQoJy4ud29yZDEgd29yZDIuLicsIC8oW2Etel0rKShcXGQrKS9pKTtcbiAgICAgICAgICAgKiAvLyAtPiBbJy4uJywgJ3dvcmQnLCAnMScsICcgJywgJ3dvcmQnLCAnMicsICcuLiddXG4gICAgICAgICAgICovXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gc3BsaXQodW5kZWYpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVTcGxpdCA9IFN0cmluZy5wcm90b3R5cGUuc3BsaXQsXG4gICAgICAgICAgICAgIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoXCJcIilbMV0gPT09IHVuZGVmLFxuICAgICAgICAgICAgICAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgICAgICAgICAgICBzZWxmO1xuXG4gICAgICAgICAgICBzZWxmID0gZnVuY3Rpb24gKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIGBuYXRpdmVTcGxpdGBcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzZXBhcmF0b3IpICE9PSBcIltvYmplY3QgUmVnRXhwXVwiXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVTcGxpdC5jYWxsKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgICAgICAgICAgIGZsYWdzID1cbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyBcIm1cIiA6IFwiXCIpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IuZXh0ZW5kZWQgPyBcInhcIiA6IFwiXCIpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyBcInlcIiA6IFwiXCIpLFxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMytcbiAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgICAgICAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyBcImdcIiksXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMixcbiAgICAgICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgbGFzdExlbmd0aDtcbiAgICAgICAgICAgICAgc3RyICs9IFwiXCI7IC8vIFR5cGUtY29udmVydFxuICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICBcIl5cIiArIHNlcGFyYXRvci5zb3VyY2UgKyBcIiQoPyFcXFxccylcIixcbiAgICAgICAgICAgICAgICAgIGZsYWdzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAgICAgICAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGxpbWl0ID1cbiAgICAgICAgICAgICAgICBsaW1pdCA9PT0gdW5kZWZcbiAgICAgICAgICAgICAgICAgID8gLTEgPj4+IDAgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICAgICAgOiBsaW1pdCA+Pj4gMDsgLy8gVG9VaW50MzIobGltaXQpXG4gICAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdHIpKSkge1xuICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHVuZGVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdChcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9LFxuICAgICAgICB7fSxcbiAgICAgIF0sXG4gICAgICAzOiBbXG4gICAgICAgIGZ1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBPbmVWZXJzaW9uQ29uc3RyYWludCA9IHJlcXVpcmUoXCJpbmRpdmlkdWFsL29uZS12ZXJzaW9uXCIpO1xuXG4gICAgICAgICAgdmFyIE1ZX1ZFUlNJT04gPSBcIjdcIjtcbiAgICAgICAgICBPbmVWZXJzaW9uQ29uc3RyYWludChcImV2LXN0b3JlXCIsIE1ZX1ZFUlNJT04pO1xuXG4gICAgICAgICAgdmFyIGhhc2hLZXkgPSBcIl9fRVZfU1RPUkVfS0VZQFwiICsgTVlfVkVSU0lPTjtcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gRXZTdG9yZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIEV2U3RvcmUoZWxlbSkge1xuICAgICAgICAgICAgdmFyIGhhc2ggPSBlbGVtW2hhc2hLZXldO1xuXG4gICAgICAgICAgICBpZiAoIWhhc2gpIHtcbiAgICAgICAgICAgICAgaGFzaCA9IGVsZW1baGFzaEtleV0gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IFwiaW5kaXZpZHVhbC9vbmUtdmVyc2lvblwiOiA2IH0sXG4gICAgICBdLFxuICAgICAgNDogW1xuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciB0b3BMZXZlbCA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgPyB3aW5kb3dcbiAgICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICAgIHZhciBtaW5Eb2MgPSByZXF1aXJlKFwibWluLWRvY3VtZW50XCIpO1xuXG4gICAgICAgICAgICAgIHZhciBkb2NjeTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgZG9jY3kgPSBkb2N1bWVudDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb2NjeSA9IHRvcExldmVsW1wiX19HTE9CQUxfRE9DVU1FTlRfQ0FDSEVANFwiXTtcblxuICAgICAgICAgICAgICAgIGlmICghZG9jY3kpIHtcbiAgICAgICAgICAgICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbXCJfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0XCJdID0gbWluRG9jO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZG9jY3k7XG4gICAgICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgICAgIH0pLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICA/IGdsb2JhbFxuICAgICAgICAgICAgICA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgID8gc2VsZlxuICAgICAgICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgPyB3aW5kb3dcbiAgICAgICAgICAgICAgOiB7fVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHsgXCJtaW4tZG9jdW1lbnRcIjogMSB9LFxuICAgICAgXSxcbiAgICAgIDU6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgICAgICAvKmdsb2JhbCB3aW5kb3csIGdsb2JhbCovXG5cbiAgICAgICAgICAgICAgdmFyIHJvb3QgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgID8gd2luZG93XG4gICAgICAgICAgICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgID8gZ2xvYmFsXG4gICAgICAgICAgICAgICAgICA6IHt9O1xuXG4gICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gSW5kaXZpZHVhbDtcblxuICAgICAgICAgICAgICBmdW5jdGlvbiBJbmRpdmlkdWFsKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHJvb3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByb290W2tleV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm9vdFtrZXldID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICAgICAgfSkuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgID8gZ2xvYmFsXG4gICAgICAgICAgICAgIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgPyBzZWxmXG4gICAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICA/IHdpbmRvd1xuICAgICAgICAgICAgICA6IHt9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAge30sXG4gICAgICBdLFxuICAgICAgNjogW1xuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgSW5kaXZpZHVhbCA9IHJlcXVpcmUoXCIuL2luZGV4LmpzXCIpO1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBPbmVWZXJzaW9uO1xuXG4gICAgICAgICAgZnVuY3Rpb24gT25lVmVyc2lvbihtb2R1bGVOYW1lLCB2ZXJzaW9uLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBcIl9fSU5ESVZJRFVBTF9PTkVfVkVSU0lPTl9cIiArIG1vZHVsZU5hbWU7XG4gICAgICAgICAgICB2YXIgZW5mb3JjZUtleSA9IGtleSArIFwiX0VORk9SQ0VfU0lOR0xFVE9OXCI7XG5cbiAgICAgICAgICAgIHZhciB2ZXJzaW9uVmFsdWUgPSBJbmRpdmlkdWFsKGVuZm9yY2VLZXksIHZlcnNpb24pO1xuXG4gICAgICAgICAgICBpZiAodmVyc2lvblZhbHVlICE9PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNhbiBvbmx5IGhhdmUgb25lIGNvcHkgb2YgXCIgK1xuICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZSArXG4gICAgICAgICAgICAgICAgICBcIi5cXG5cIiArXG4gICAgICAgICAgICAgICAgICBcIllvdSBhbHJlYWR5IGhhdmUgdmVyc2lvbiBcIiArXG4gICAgICAgICAgICAgICAgICB2ZXJzaW9uVmFsdWUgK1xuICAgICAgICAgICAgICAgICAgXCIgaW5zdGFsbGVkLlxcblwiICtcbiAgICAgICAgICAgICAgICAgIFwiVGhpcyBtZWFucyB5b3UgY2Fubm90IGluc3RhbGwgdmVyc2lvbiBcIiArXG4gICAgICAgICAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBJbmRpdmlkdWFsKGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgXCIuL2luZGV4LmpzXCI6IDUgfSxcbiAgICAgIF0sXG4gICAgICA3OiBbXG4gICAgICAgIGZ1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIHggIT09IG51bGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAge30sXG4gICAgICBdLFxuICAgICAgODogW1xuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgdmFyIG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgICAgICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUlzQXJyYXkgfHwgaXNBcnJheTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7fSxcbiAgICAgIF0sXG4gICAgICA5OiBbXG4gICAgICAgIGZ1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICB2YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoXCIuL3Zkb20vY3JlYXRlLWVsZW1lbnQuanNcIik7XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUVsZW1lbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHsgXCIuL3Zkb20vY3JlYXRlLWVsZW1lbnQuanNcIjogMTMgfSxcbiAgICAgIF0sXG4gICAgICAxMDogW1xuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgdmFyIGRpZmYgPSByZXF1aXJlKFwiLi92dHJlZS9kaWZmLmpzXCIpO1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkaWZmO1xuICAgICAgICB9LFxuICAgICAgICB7IFwiLi92dHJlZS9kaWZmLmpzXCI6IDM2IH0sXG4gICAgICBdLFxuICAgICAgMTE6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIHZhciBwYXRjaCA9IHJlcXVpcmUoXCIuL3Zkb20vcGF0Y2guanNcIik7XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHBhdGNoO1xuICAgICAgICB9LFxuICAgICAgICB7IFwiLi92ZG9tL3BhdGNoLmpzXCI6IDE2IH0sXG4gICAgICBdLFxuICAgICAgMTI6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIHZhciBpc09iamVjdCA9IHJlcXVpcmUoXCJpcy1vYmplY3RcIik7XG4gICAgICAgICAgdmFyIGlzSG9vayA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy12aG9vay5qc1wiKTtcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXBwbHlQcm9wZXJ0aWVzO1xuXG4gICAgICAgICAgZnVuY3Rpb24gYXBwbHlQcm9wZXJ0aWVzKG5vZGUsIHByb3BzLCBwcmV2aW91cykge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblxuICAgICAgICAgICAgICBpZiAocHJvcFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVQcm9wZXJ0eShub2RlLCBwcm9wTmFtZSwgcHJvcFZhbHVlLCBwcmV2aW91cyk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNIb29rKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVQcm9wZXJ0eShub2RlLCBwcm9wTmFtZSwgcHJvcFZhbHVlLCBwcmV2aW91cyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BWYWx1ZS5ob29rKSB7XG4gICAgICAgICAgICAgICAgICBwcm9wVmFsdWUuaG9vayhcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID8gcHJldmlvdXNbcHJvcE5hbWVdIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocHJvcFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgcGF0Y2hPYmplY3Qobm9kZSwgcHJvcHMsIHByZXZpb3VzLCBwcm9wTmFtZSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlUHJvcGVydHkobm9kZSwgcHJvcE5hbWUsIHByb3BWYWx1ZSwgcHJldmlvdXMpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzW3Byb3BOYW1lXTtcblxuICAgICAgICAgICAgICBpZiAoIWlzSG9vayhwcmV2aW91c1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGF0dHJOYW1lIGluIHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbaV0gPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByZXZpb3VzVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c1ZhbHVlLnVuaG9vaykge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUudW5ob29rKG5vZGUsIHByb3BOYW1lLCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcGF0Y2hPYmplY3Qobm9kZSwgcHJvcHMsIHByZXZpb3VzLCBwcm9wTmFtZSwgcHJvcFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzID8gcHJldmlvdXNbcHJvcE5hbWVdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAvLyBTZXQgYXR0cmlidXRlc1xuICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBhdHRyTmFtZSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gcHJvcFZhbHVlW2F0dHJOYW1lXTtcblxuICAgICAgICAgICAgICAgIGlmIChhdHRyVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSAmJlxuICAgICAgICAgICAgICBpc09iamVjdChwcmV2aW91c1ZhbHVlKSAmJlxuICAgICAgICAgICAgICBnZXRQcm90b3R5cGUocHJldmlvdXNWYWx1ZSkgIT09IGdldFByb3RvdHlwZShwcm9wVmFsdWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc09iamVjdChub2RlW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlcGxhY2VyID0gcHJvcE5hbWUgPT09IFwic3R5bGVcIiA/IFwiXCIgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BWYWx1ZVtrXTtcbiAgICAgICAgICAgICAgbm9kZVtwcm9wTmFtZV1ba10gPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gcmVwbGFjZXIgOiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRQcm90b3R5cGUodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLl9fcHJvdG9fXykge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuX19wcm90b19fO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeyBcIi4uL3Zub2RlL2lzLXZob29rLmpzXCI6IDI3LCBcImlzLW9iamVjdFwiOiA3IH0sXG4gICAgICBdLFxuICAgICAgMTM6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIHZhciBkb2N1bWVudCA9IHJlcXVpcmUoXCJnbG9iYWwvZG9jdW1lbnRcIik7XG5cbiAgICAgICAgICB2YXIgYXBwbHlQcm9wZXJ0aWVzID0gcmVxdWlyZShcIi4vYXBwbHktcHJvcGVydGllc1wiKTtcblxuICAgICAgICAgIHZhciBpc1ZOb2RlID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXZub2RlLmpzXCIpO1xuICAgICAgICAgIHZhciBpc1ZUZXh0ID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXZ0ZXh0LmpzXCIpO1xuICAgICAgICAgIHZhciBpc1dpZGdldCA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy13aWRnZXQuanNcIik7XG4gICAgICAgICAgdmFyIGhhbmRsZVRodW5rID0gcmVxdWlyZShcIi4uL3Zub2RlL2hhbmRsZS10aHVuay5qc1wiKTtcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRWxlbWVudDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodm5vZGUsIG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSBvcHRzID8gb3B0cy5kb2N1bWVudCB8fCBkb2N1bWVudCA6IGRvY3VtZW50O1xuICAgICAgICAgICAgdmFyIHdhcm4gPSBvcHRzID8gb3B0cy53YXJuIDogbnVsbDtcblxuICAgICAgICAgICAgdm5vZGUgPSBoYW5kbGVUaHVuayh2bm9kZSkuYTtcblxuICAgICAgICAgICAgaWYgKGlzV2lkZ2V0KHZub2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdm5vZGUuaW5pdCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1ZUZXh0KHZub2RlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNWTm9kZSh2bm9kZSkpIHtcbiAgICAgICAgICAgICAgaWYgKHdhcm4pIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwiSXRlbSBpcyBub3QgYSB2YWxpZCB2aXJ0dWFsIGRvbSBub2RlXCIsIHZub2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5vZGUgPVxuICAgICAgICAgICAgICB2bm9kZS5uYW1lc3BhY2UgPT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGRvYy5jcmVhdGVFbGVtZW50KHZub2RlLnRhZ05hbWUpXG4gICAgICAgICAgICAgICAgOiBkb2MuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5hbWVzcGFjZSwgdm5vZGUudGFnTmFtZSk7XG5cbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHZub2RlLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBhcHBseVByb3BlcnRpZXMobm9kZSwgcHJvcHMpO1xuXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gY3JlYXRlRWxlbWVudChjaGlsZHJlbltpXSwgb3B0cyk7XG4gICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCIuLi92bm9kZS9oYW5kbGUtdGh1bmsuanNcIjogMjUsXG4gICAgICAgICAgXCIuLi92bm9kZS9pcy12bm9kZS5qc1wiOiAyOCxcbiAgICAgICAgICBcIi4uL3Zub2RlL2lzLXZ0ZXh0LmpzXCI6IDI5LFxuICAgICAgICAgIFwiLi4vdm5vZGUvaXMtd2lkZ2V0LmpzXCI6IDMwLFxuICAgICAgICAgIFwiLi9hcHBseS1wcm9wZXJ0aWVzXCI6IDEyLFxuICAgICAgICAgIFwiZ2xvYmFsL2RvY3VtZW50XCI6IDQsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgMTQ6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIC8vIE1hcHMgYSB2aXJ0dWFsIERPTSB0cmVlIG9udG8gYSByZWFsIERPTSB0cmVlIGluIGFuIGVmZmljaWVudCBtYW5uZXIuXG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZWFkIGFsbCBvZiB0aGUgRE9NIG5vZGVzIGluIHRoZSB0cmVlIHNvIHdlIHVzZVxuICAgICAgICAgIC8vIHRoZSBpbi1vcmRlciB0cmVlIGluZGV4aW5nIHRvIGVsaW1pbmF0ZSByZWN1cnNpb24gZG93biBjZXJ0YWluIGJyYW5jaGVzLlxuICAgICAgICAgIC8vIFdlIG9ubHkgcmVjdXJzZSBpbnRvIGEgRE9NIG5vZGUgaWYgd2Uga25vdyB0aGF0IGl0IGNvbnRhaW5zIGEgY2hpbGQgb2ZcbiAgICAgICAgICAvLyBpbnRlcmVzdC5cblxuICAgICAgICAgIHZhciBub0NoaWxkID0ge307XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRvbUluZGV4O1xuXG4gICAgICAgICAgZnVuY3Rpb24gZG9tSW5kZXgocm9vdE5vZGUsIHRyZWUsIGluZGljZXMsIG5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoIWluZGljZXMgfHwgaW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5kaWNlcy5zb3J0KGFzY2VuZGluZyk7XG4gICAgICAgICAgICAgIHJldHVybiByZWN1cnNlKHJvb3ROb2RlLCB0cmVlLCBpbmRpY2VzLCBub2RlcywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcmVjdXJzZShyb290Tm9kZSwgdHJlZSwgaW5kaWNlcywgbm9kZXMsIHJvb3RJbmRleCkge1xuICAgICAgICAgICAgbm9kZXMgPSBub2RlcyB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKHJvb3ROb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChpbmRleEluUmFuZ2UoaW5kaWNlcywgcm9vdEluZGV4LCByb290SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbcm9vdEluZGV4XSA9IHJvb3ROb2RlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHZDaGlsZHJlbiA9IHRyZWUuY2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgaWYgKHZDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gcm9vdE5vZGUuY2hpbGROb2RlcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcm9vdEluZGV4ICs9IDE7XG5cbiAgICAgICAgICAgICAgICAgIHZhciB2Q2hpbGQgPSB2Q2hpbGRyZW5baV0gfHwgbm9DaGlsZDtcbiAgICAgICAgICAgICAgICAgIHZhciBuZXh0SW5kZXggPSByb290SW5kZXggKyAodkNoaWxkLmNvdW50IHx8IDApO1xuXG4gICAgICAgICAgICAgICAgICAvLyBza2lwIHJlY3Vyc2lvbiBkb3duIHRoZSB0cmVlIGlmIHRoZXJlIGFyZSBubyBub2RlcyBkb3duIGhlcmVcbiAgICAgICAgICAgICAgICAgIGlmIChpbmRleEluUmFuZ2UoaW5kaWNlcywgcm9vdEluZGV4LCBuZXh0SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2UoY2hpbGROb2Rlc1tpXSwgdkNoaWxkLCBpbmRpY2VzLCBub2Rlcywgcm9vdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcm9vdEluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQmluYXJ5IHNlYXJjaCBmb3IgYW4gaW5kZXggaW4gdGhlIGludGVydmFsIFtsZWZ0LCByaWdodF1cbiAgICAgICAgICBmdW5jdGlvbiBpbmRleEluUmFuZ2UoaW5kaWNlcywgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgbWF4SW5kZXggPSBpbmRpY2VzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2YXIgY3VycmVudEluZGV4O1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRJdGVtO1xuXG4gICAgICAgICAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgICAgY3VycmVudEluZGV4ID0gKChtYXhJbmRleCArIG1pbkluZGV4KSAvIDIpID4+IDA7XG4gICAgICAgICAgICAgIGN1cnJlbnRJdGVtID0gaW5kaWNlc1tjdXJyZW50SW5kZXhdO1xuXG4gICAgICAgICAgICAgIGlmIChtaW5JbmRleCA9PT0gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEl0ZW0gPj0gbGVmdCAmJiBjdXJyZW50SXRlbSA8PSByaWdodDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50SXRlbSA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEl0ZW0gPiByaWdodCkge1xuICAgICAgICAgICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhID4gYiA/IDEgOiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHt9LFxuICAgICAgXSxcbiAgICAgIDE1OiBbXG4gICAgICAgIGZ1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICB2YXIgYXBwbHlQcm9wZXJ0aWVzID0gcmVxdWlyZShcIi4vYXBwbHktcHJvcGVydGllc1wiKTtcblxuICAgICAgICAgIHZhciBpc1dpZGdldCA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy13aWRnZXQuanNcIik7XG4gICAgICAgICAgdmFyIFZQYXRjaCA9IHJlcXVpcmUoXCIuLi92bm9kZS92cGF0Y2guanNcIik7XG5cbiAgICAgICAgICB2YXIgdXBkYXRlV2lkZ2V0ID0gcmVxdWlyZShcIi4vdXBkYXRlLXdpZGdldFwiKTtcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXBwbHlQYXRjaDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGFwcGx5UGF0Y2godnBhdGNoLCBkb21Ob2RlLCByZW5kZXJPcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHZwYXRjaC50eXBlO1xuICAgICAgICAgICAgdmFyIHZOb2RlID0gdnBhdGNoLnZOb2RlO1xuICAgICAgICAgICAgdmFyIHBhdGNoID0gdnBhdGNoLnBhdGNoO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBWUGF0Y2guUkVNT1ZFOlxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVOb2RlKGRvbU5vZGUsIHZOb2RlKTtcbiAgICAgICAgICAgICAgY2FzZSBWUGF0Y2guSU5TRVJUOlxuICAgICAgICAgICAgICAgIHJldHVybiBpbnNlcnROb2RlKGRvbU5vZGUsIHBhdGNoLCByZW5kZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgY2FzZSBWUGF0Y2guVlRFWFQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1BhdGNoKGRvbU5vZGUsIHZOb2RlLCBwYXRjaCwgcmVuZGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgIGNhc2UgVlBhdGNoLldJREdFVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkZ2V0UGF0Y2goZG9tTm9kZSwgdk5vZGUsIHBhdGNoLCByZW5kZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgY2FzZSBWUGF0Y2guVk5PREU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZOb2RlUGF0Y2goZG9tTm9kZSwgdk5vZGUsIHBhdGNoLCByZW5kZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgY2FzZSBWUGF0Y2guT1JERVI6XG4gICAgICAgICAgICAgICAgcmVvcmRlckNoaWxkcmVuKGRvbU5vZGUsIHBhdGNoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tTm9kZTtcbiAgICAgICAgICAgICAgY2FzZSBWUGF0Y2guUFJPUFM6XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0aWVzKGRvbU5vZGUsIHBhdGNoLCB2Tm9kZS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tTm9kZTtcbiAgICAgICAgICAgICAgY2FzZSBWUGF0Y2guVEhVTks6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VSb290KFxuICAgICAgICAgICAgICAgICAgZG9tTm9kZSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlck9wdGlvbnMucGF0Y2goZG9tTm9kZSwgcGF0Y2gsIHJlbmRlck9wdGlvbnMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiByZW1vdmVOb2RlKGRvbU5vZGUsIHZOb2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGRvbU5vZGUucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb21Ob2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVzdHJveVdpZGdldChkb21Ob2RlLCB2Tm9kZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGluc2VydE5vZGUocGFyZW50Tm9kZSwgdk5vZGUsIHJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlID0gcmVuZGVyT3B0aW9ucy5yZW5kZXIodk5vZGUsIHJlbmRlck9wdGlvbnMpO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzdHJpbmdQYXRjaChkb21Ob2RlLCBsZWZ0Vk5vZGUsIHZUZXh0LCByZW5kZXJPcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZTtcblxuICAgICAgICAgICAgaWYgKGRvbU5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgZG9tTm9kZS5ub2RlVmFsdWUgPSB2VGV4dC50ZXh0O1xuICAgICAgICAgICAgICBuZXdOb2RlID0gZG9tTm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICBuZXdOb2RlID0gcmVuZGVyT3B0aW9ucy5yZW5kZXIodlRleHQsIHJlbmRlck9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIG5ld05vZGUgIT09IGRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBkb21Ob2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB3aWRnZXRQYXRjaChkb21Ob2RlLCBsZWZ0Vk5vZGUsIHdpZGdldCwgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHVwZGF0aW5nID0gdXBkYXRlV2lkZ2V0KGxlZnRWTm9kZSwgd2lkZ2V0KTtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlO1xuXG4gICAgICAgICAgICBpZiAodXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgbmV3Tm9kZSA9IHdpZGdldC51cGRhdGUobGVmdFZOb2RlLCBkb21Ob2RlKSB8fCBkb21Ob2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3Tm9kZSA9IHJlbmRlck9wdGlvbnMucmVuZGVyKHdpZGdldCwgcmVuZGVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSAmJiBuZXdOb2RlICE9PSBkb21Ob2RlKSB7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld05vZGUsIGRvbU5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgIGRlc3Ryb3lXaWRnZXQoZG9tTm9kZSwgbGVmdFZOb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gdk5vZGVQYXRjaChkb21Ob2RlLCBsZWZ0Vk5vZGUsIHZOb2RlLCByZW5kZXJPcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlID0gcmVuZGVyT3B0aW9ucy5yZW5kZXIodk5vZGUsIHJlbmRlck9wdGlvbnMpO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSAmJiBuZXdOb2RlICE9PSBkb21Ob2RlKSB7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld05vZGUsIGRvbU5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBkZXN0cm95V2lkZ2V0KGRvbU5vZGUsIHcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdy5kZXN0cm95ID09PSBcImZ1bmN0aW9uXCIgJiYgaXNXaWRnZXQodykpIHtcbiAgICAgICAgICAgICAgdy5kZXN0cm95KGRvbU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJlb3JkZXJDaGlsZHJlbihkb21Ob2RlLCBtb3Zlcykge1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBkb21Ob2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICB2YXIga2V5TWFwID0ge307XG4gICAgICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgICAgIHZhciByZW1vdmU7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vdmVzLnJlbW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcmVtb3ZlID0gbW92ZXMucmVtb3Zlc1tpXTtcbiAgICAgICAgICAgICAgbm9kZSA9IGNoaWxkTm9kZXNbcmVtb3ZlLmZyb21dO1xuICAgICAgICAgICAgICBpZiAocmVtb3ZlLmtleSkge1xuICAgICAgICAgICAgICAgIGtleU1hcFtyZW1vdmUua2V5XSA9IG5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZG9tTm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtb3Zlcy5pbnNlcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGluc2VydCA9IG1vdmVzLmluc2VydHNbal07XG4gICAgICAgICAgICAgIG5vZGUgPSBrZXlNYXBbaW5zZXJ0LmtleV07XG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHdlaXJkZXN0IGJ1ZyBpJ3ZlIGV2ZXIgc2VlbiBpbiB3ZWJraXRcbiAgICAgICAgICAgICAgZG9tTm9kZS5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBpbnNlcnQudG8gPj0gbGVuZ3RoKysgPyBudWxsIDogY2hpbGROb2Rlc1tpbnNlcnQudG9dXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcmVwbGFjZVJvb3Qob2xkUm9vdCwgbmV3Um9vdCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBvbGRSb290ICYmXG4gICAgICAgICAgICAgIG5ld1Jvb3QgJiZcbiAgICAgICAgICAgICAgb2xkUm9vdCAhPT0gbmV3Um9vdCAmJlxuICAgICAgICAgICAgICBvbGRSb290LnBhcmVudE5vZGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvbGRSb290LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld1Jvb3QsIG9sZFJvb3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3Um9vdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcIi4uL3Zub2RlL2lzLXdpZGdldC5qc1wiOiAzMCxcbiAgICAgICAgICBcIi4uL3Zub2RlL3ZwYXRjaC5qc1wiOiAzMyxcbiAgICAgICAgICBcIi4vYXBwbHktcHJvcGVydGllc1wiOiAxMixcbiAgICAgICAgICBcIi4vdXBkYXRlLXdpZGdldFwiOiAxNyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICAxNjogW1xuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgdmFyIGRvY3VtZW50ID0gcmVxdWlyZShcImdsb2JhbC9kb2N1bWVudFwiKTtcbiAgICAgICAgICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoXCJ4LWlzLWFycmF5XCIpO1xuXG4gICAgICAgICAgdmFyIHJlbmRlciA9IHJlcXVpcmUoXCIuL2NyZWF0ZS1lbGVtZW50XCIpO1xuICAgICAgICAgIHZhciBkb21JbmRleCA9IHJlcXVpcmUoXCIuL2RvbS1pbmRleFwiKTtcbiAgICAgICAgICB2YXIgcGF0Y2hPcCA9IHJlcXVpcmUoXCIuL3BhdGNoLW9wXCIpO1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcGF0Y2g7XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXRjaChyb290Tm9kZSwgcGF0Y2hlcywgcmVuZGVyT3B0aW9ucykge1xuICAgICAgICAgICAgcmVuZGVyT3B0aW9ucyA9IHJlbmRlck9wdGlvbnMgfHwge307XG4gICAgICAgICAgICByZW5kZXJPcHRpb25zLnBhdGNoID1cbiAgICAgICAgICAgICAgcmVuZGVyT3B0aW9ucy5wYXRjaCAmJiByZW5kZXJPcHRpb25zLnBhdGNoICE9PSBwYXRjaFxuICAgICAgICAgICAgICAgID8gcmVuZGVyT3B0aW9ucy5wYXRjaFxuICAgICAgICAgICAgICAgIDogcGF0Y2hSZWN1cnNpdmU7XG4gICAgICAgICAgICByZW5kZXJPcHRpb25zLnJlbmRlciA9IHJlbmRlck9wdGlvbnMucmVuZGVyIHx8IHJlbmRlcjtcblxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlck9wdGlvbnMucGF0Y2gocm9vdE5vZGUsIHBhdGNoZXMsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHBhdGNoUmVjdXJzaXZlKHJvb3ROb2RlLCBwYXRjaGVzLCByZW5kZXJPcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IHBhdGNoSW5kaWNlcyhwYXRjaGVzKTtcblxuICAgICAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiByb290Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZG9tSW5kZXgocm9vdE5vZGUsIHBhdGNoZXMuYSwgaW5kaWNlcyk7XG4gICAgICAgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IHJvb3ROb2RlLm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgICAgICAgIGlmICghcmVuZGVyT3B0aW9ucy5kb2N1bWVudCAmJiBvd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgICByZW5kZXJPcHRpb25zLmRvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSBpbmRpY2VzW2ldO1xuICAgICAgICAgICAgICByb290Tm9kZSA9IGFwcGx5UGF0Y2goXG4gICAgICAgICAgICAgICAgcm9vdE5vZGUsXG4gICAgICAgICAgICAgICAgaW5kZXhbbm9kZUluZGV4XSxcbiAgICAgICAgICAgICAgICBwYXRjaGVzW25vZGVJbmRleF0sXG4gICAgICAgICAgICAgICAgcmVuZGVyT3B0aW9uc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcm9vdE5vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYXBwbHlQYXRjaChyb290Tm9kZSwgZG9tTm9kZSwgcGF0Y2hMaXN0LCByZW5kZXJPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvb3ROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3Tm9kZTtcblxuICAgICAgICAgICAgaWYgKGlzQXJyYXkocGF0Y2hMaXN0KSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGNoTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5ld05vZGUgPSBwYXRjaE9wKHBhdGNoTGlzdFtpXSwgZG9tTm9kZSwgcmVuZGVyT3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZG9tTm9kZSA9PT0gcm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHJvb3ROb2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld05vZGUgPSBwYXRjaE9wKHBhdGNoTGlzdCwgZG9tTm9kZSwgcmVuZGVyT3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGUgPT09IHJvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgcm9vdE5vZGUgPSBuZXdOb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByb290Tm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXRjaEluZGljZXMocGF0Y2hlcykge1xuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHBhdGNoZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJhXCIpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goTnVtYmVyKGtleSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwiLi9jcmVhdGUtZWxlbWVudFwiOiAxMyxcbiAgICAgICAgICBcIi4vZG9tLWluZGV4XCI6IDE0LFxuICAgICAgICAgIFwiLi9wYXRjaC1vcFwiOiAxNSxcbiAgICAgICAgICBcImdsb2JhbC9kb2N1bWVudFwiOiA0LFxuICAgICAgICAgIFwieC1pcy1hcnJheVwiOiA4LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIDE3OiBbXG4gICAgICAgIGZ1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICB2YXIgaXNXaWRnZXQgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtd2lkZ2V0LmpzXCIpO1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB1cGRhdGVXaWRnZXQ7XG5cbiAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVXaWRnZXQoYSwgYikge1xuICAgICAgICAgICAgaWYgKGlzV2lkZ2V0KGEpICYmIGlzV2lkZ2V0KGIpKSB7XG4gICAgICAgICAgICAgIGlmIChcIm5hbWVcIiBpbiBhICYmIFwibmFtZVwiIGluIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pZCA9PT0gYi5pZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbml0ID09PSBiLmluaXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeyBcIi4uL3Zub2RlL2lzLXdpZGdldC5qc1wiOiAzMCB9LFxuICAgICAgXSxcbiAgICAgIDE4OiBbXG4gICAgICAgIGZ1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gQXR0cmlidXRlSG9vaztcblxuICAgICAgICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZUhvb2sobmFtZXNwYWNlLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEF0dHJpYnV0ZUhvb2spKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlSG9vayhuYW1lc3BhY2UsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQXR0cmlidXRlSG9vay5wcm90b3R5cGUuaG9vayA9IGZ1bmN0aW9uIChub2RlLCBwcm9wLCBwcmV2KSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHByZXYgJiZcbiAgICAgICAgICAgICAgcHJldi50eXBlID09PSBcIkF0dHJpYnV0ZUhvb2tcIiAmJlxuICAgICAgICAgICAgICBwcmV2LnZhbHVlID09PSB0aGlzLnZhbHVlICYmXG4gICAgICAgICAgICAgIHByZXYubmFtZXNwYWNlID09PSB0aGlzLm5hbWVzcGFjZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyh0aGlzLm5hbWVzcGFjZSwgcHJvcCwgdGhpcy52YWx1ZSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIEF0dHJpYnV0ZUhvb2sucHJvdG90eXBlLnVuaG9vayA9IGZ1bmN0aW9uIChub2RlLCBwcm9wLCBuZXh0KSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG5leHQgJiZcbiAgICAgICAgICAgICAgbmV4dC50eXBlID09PSBcIkF0dHJpYnV0ZUhvb2tcIiAmJlxuICAgICAgICAgICAgICBuZXh0Lm5hbWVzcGFjZSA9PT0gdGhpcy5uYW1lc3BhY2VcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb2xvblBvc2l0aW9uID0gcHJvcC5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgICAgIHZhciBsb2NhbE5hbWUgPVxuICAgICAgICAgICAgICBjb2xvblBvc2l0aW9uID4gLTEgPyBwcm9wLnN1YnN0cihjb2xvblBvc2l0aW9uICsgMSkgOiBwcm9wO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOUyh0aGlzLm5hbWVzcGFjZSwgbG9jYWxOYW1lKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgQXR0cmlidXRlSG9vay5wcm90b3R5cGUudHlwZSA9IFwiQXR0cmlidXRlSG9va1wiO1xuICAgICAgICB9LFxuICAgICAgICB7fSxcbiAgICAgIF0sXG4gICAgICAxOTogW1xuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgRXZTdG9yZSA9IHJlcXVpcmUoXCJldi1zdG9yZVwiKTtcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gRXZIb29rO1xuXG4gICAgICAgICAgZnVuY3Rpb24gRXZIb29rKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRXZIb29rKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2SG9vayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBFdkhvb2sucHJvdG90eXBlLmhvb2sgPSBmdW5jdGlvbiAobm9kZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICB2YXIgZXMgPSBFdlN0b3JlKG5vZGUpO1xuICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlOYW1lLnN1YnN0cigzKTtcblxuICAgICAgICAgICAgZXNbcHJvcE5hbWVdID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgRXZIb29rLnByb3RvdHlwZS51bmhvb2sgPSBmdW5jdGlvbiAobm9kZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICB2YXIgZXMgPSBFdlN0b3JlKG5vZGUpO1xuICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlOYW1lLnN1YnN0cigzKTtcblxuICAgICAgICAgICAgZXNbcHJvcE5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHsgXCJldi1zdG9yZVwiOiAzIH0sXG4gICAgICBdLFxuICAgICAgMjA6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBTb2Z0U2V0SG9vaztcblxuICAgICAgICAgIGZ1bmN0aW9uIFNvZnRTZXRIb29rKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29mdFNldEhvb2spKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgU29mdFNldEhvb2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgU29mdFNldEhvb2sucHJvdG90eXBlLmhvb2sgPSBmdW5jdGlvbiAobm9kZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICBpZiAobm9kZVtwcm9wZXJ0eU5hbWVdICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAge30sXG4gICAgICBdLFxuICAgICAgMjE6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKFwieC1pcy1hcnJheVwiKTtcblxuICAgICAgICAgIHZhciBWTm9kZSA9IHJlcXVpcmUoXCIuLi92bm9kZS92bm9kZS5qc1wiKTtcbiAgICAgICAgICB2YXIgVlRleHQgPSByZXF1aXJlKFwiLi4vdm5vZGUvdnRleHQuanNcIik7XG4gICAgICAgICAgdmFyIGlzVk5vZGUgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtdm5vZGVcIik7XG4gICAgICAgICAgdmFyIGlzVlRleHQgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtdnRleHRcIik7XG4gICAgICAgICAgdmFyIGlzV2lkZ2V0ID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXdpZGdldFwiKTtcbiAgICAgICAgICB2YXIgaXNIb29rID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXZob29rXCIpO1xuICAgICAgICAgIHZhciBpc1ZUaHVuayA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy10aHVua1wiKTtcblxuICAgICAgICAgIHZhciBwYXJzZVRhZyA9IHJlcXVpcmUoXCIuL3BhcnNlLXRhZy5qc1wiKTtcbiAgICAgICAgICB2YXIgc29mdFNldEhvb2sgPSByZXF1aXJlKFwiLi9ob29rcy9zb2Z0LXNldC1ob29rLmpzXCIpO1xuICAgICAgICAgIHZhciBldkhvb2sgPSByZXF1aXJlKFwiLi9ob29rcy9ldi1ob29rLmpzXCIpO1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBoO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaCh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBjaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciB0YWcsIHByb3BzLCBrZXksIG5hbWVzcGFjZTtcblxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbiAmJiBpc0NoaWxkcmVuKHByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuID0gcHJvcGVydGllcztcbiAgICAgICAgICAgICAgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyB8fCBwcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICAgICAgdGFnID0gcGFyc2VUYWcodGFnTmFtZSwgcHJvcHMpO1xuXG4gICAgICAgICAgICAvLyBzdXBwb3J0IGtleXNcbiAgICAgICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSkge1xuICAgICAgICAgICAgICBrZXkgPSBwcm9wcy5rZXk7XG4gICAgICAgICAgICAgIHByb3BzLmtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3VwcG9ydCBuYW1lc3BhY2VcbiAgICAgICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShcIm5hbWVzcGFjZVwiKSkge1xuICAgICAgICAgICAgICBuYW1lc3BhY2UgPSBwcm9wcy5uYW1lc3BhY2U7XG4gICAgICAgICAgICAgIHByb3BzLm5hbWVzcGFjZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZml4IGN1cnNvciBidWdcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdGFnID09PSBcIklOUFVUXCIgJiZcbiAgICAgICAgICAgICAgIW5hbWVzcGFjZSAmJlxuICAgICAgICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpICYmXG4gICAgICAgICAgICAgIHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgIWlzSG9vayhwcm9wcy52YWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBwcm9wcy52YWx1ZSA9IHNvZnRTZXRIb29rKHByb3BzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcGVydGllcyhwcm9wcyk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIGNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFkZENoaWxkKGNoaWxkcmVuLCBjaGlsZE5vZGVzLCB0YWcsIHByb3BzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWTm9kZSh0YWcsIHByb3BzLCBjaGlsZE5vZGVzLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYWRkQ2hpbGQoYywgY2hpbGROb2RlcywgdGFnLCBwcm9wcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIGNoaWxkTm9kZXMucHVzaChuZXcgVlRleHQoYykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICBjaGlsZE5vZGVzLnB1c2gobmV3IFZUZXh0KFN0cmluZyhjKSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NoaWxkKGMpKSB7XG4gICAgICAgICAgICAgIGNoaWxkTm9kZXMucHVzaChjKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShjKSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhZGRDaGlsZChjW2ldLCBjaGlsZE5vZGVzLCB0YWcsIHByb3BzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBudWxsIHx8IGMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBVbmV4cGVjdGVkVmlydHVhbEVsZW1lbnQoe1xuICAgICAgICAgICAgICAgIGZvcmVpZ25PYmplY3Q6IGMsXG4gICAgICAgICAgICAgICAgcGFyZW50Vm5vZGU6IHtcbiAgICAgICAgICAgICAgICAgIHRhZ05hbWU6IHRhZyxcbiAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHByb3BzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNIb29rKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BOYW1lLnN1YnN0cigwLCAzKSA9PT0gXCJldi1cIikge1xuICAgICAgICAgICAgICAgICAgLy8gYWRkIGV2LWZvbyBzdXBwb3J0XG4gICAgICAgICAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBldkhvb2sodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzQ2hpbGQoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzVk5vZGUoeCkgfHwgaXNWVGV4dCh4KSB8fCBpc1dpZGdldCh4KSB8fCBpc1ZUaHVuayh4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0NoaWxkcmVuKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIiB8fCBpc0FycmF5KHgpIHx8IGlzQ2hpbGQoeCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gVW5leHBlY3RlZFZpcnR1YWxFbGVtZW50KGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcblxuICAgICAgICAgICAgZXJyLnR5cGUgPSBcInZpcnR1YWwtaHlwZXJzY3JpcHQudW5leHBlY3RlZC52aXJ0dWFsLWVsZW1lbnRcIjtcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID1cbiAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIHZpcnR1YWwgY2hpbGQgcGFzc2VkIHRvIGgoKS5cXG5cIiArXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSBWTm9kZSAvIFZ0aHVuayAvIFZXaWRnZXQgLyBzdHJpbmcgYnV0OlxcblwiICtcbiAgICAgICAgICAgICAgXCJnb3Q6XFxuXCIgK1xuICAgICAgICAgICAgICBlcnJvclN0cmluZyhkYXRhLmZvcmVpZ25PYmplY3QpICtcbiAgICAgICAgICAgICAgXCIuXFxuXCIgK1xuICAgICAgICAgICAgICBcIlRoZSBwYXJlbnQgdm5vZGUgaXM6XFxuXCIgK1xuICAgICAgICAgICAgICBlcnJvclN0cmluZyhkYXRhLnBhcmVudFZub2RlKTtcbiAgICAgICAgICAgIFwiXFxuXCIgKyBcIlN1Z2dlc3RlZCBmaXg6IGNoYW5nZSB5b3VyIGBoKC4uLiwgWyAuLi4gXSlgIGNhbGxzaXRlLlwiO1xuICAgICAgICAgICAgZXJyLmZvcmVpZ25PYmplY3QgPSBkYXRhLmZvcmVpZ25PYmplY3Q7XG4gICAgICAgICAgICBlcnIucGFyZW50Vm5vZGUgPSBkYXRhLnBhcmVudFZub2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIFVuc3VwcG9ydGVkVmFsdWVUeXBlKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcblxuICAgICAgICAgICAgZXJyLnR5cGUgPSBcInZpcnR1YWwtaHlwZXJzY3JpcHQudW5zdXBwb3J0ZWQudmFsdWUtdHlwZVwiO1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPVxuICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgdmFsdWUgdHlwZSBmb3IgaW5wdXQgcGFzc2VkIHRvIGgoKS5cXG5cIiArXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSBcIiArXG4gICAgICAgICAgICAgIGVycm9yU3RyaW5nKGRhdGEuZXhwZWN0ZWQpICtcbiAgICAgICAgICAgICAgXCIgYnV0IGdvdDpcXG5cIiArXG4gICAgICAgICAgICAgIGVycm9yU3RyaW5nKGRhdGEucmVjZWl2ZWQpICtcbiAgICAgICAgICAgICAgXCIuXFxuXCIgK1xuICAgICAgICAgICAgICBcIlRoZSB2bm9kZSBpczpcXG5cIiArXG4gICAgICAgICAgICAgIGVycm9yU3RyaW5nKGRhdGEuVm5vZGUpO1xuICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgIFwiU3VnZ2VzdGVkIGZpeDogQ2FzdCB0aGUgdmFsdWUgcGFzc2VkIHRvIGgoKSB0byBhIHN0cmluZyB1c2luZyBTdHJpbmcodmFsdWUpLlwiO1xuICAgICAgICAgICAgZXJyLlZub2RlID0gZGF0YS5Wbm9kZTtcblxuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBlcnJvclN0cmluZyhvYmopIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIFwiICAgIFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwiLi4vdm5vZGUvaXMtdGh1bmtcIjogMjYsXG4gICAgICAgICAgXCIuLi92bm9kZS9pcy12aG9va1wiOiAyNyxcbiAgICAgICAgICBcIi4uL3Zub2RlL2lzLXZub2RlXCI6IDI4LFxuICAgICAgICAgIFwiLi4vdm5vZGUvaXMtdnRleHRcIjogMjksXG4gICAgICAgICAgXCIuLi92bm9kZS9pcy13aWRnZXRcIjogMzAsXG4gICAgICAgICAgXCIuLi92bm9kZS92bm9kZS5qc1wiOiAzMixcbiAgICAgICAgICBcIi4uL3Zub2RlL3Z0ZXh0LmpzXCI6IDM0LFxuICAgICAgICAgIFwiLi9ob29rcy9ldi1ob29rLmpzXCI6IDE5LFxuICAgICAgICAgIFwiLi9ob29rcy9zb2Z0LXNldC1ob29rLmpzXCI6IDIwLFxuICAgICAgICAgIFwiLi9wYXJzZS10YWcuanNcIjogMjIsXG4gICAgICAgICAgXCJ4LWlzLWFycmF5XCI6IDgsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgMjI6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIHNwbGl0ID0gcmVxdWlyZShcImJyb3dzZXItc3BsaXRcIik7XG5cbiAgICAgICAgICB2YXIgY2xhc3NJZFNwbGl0ID0gLyhbXFwuI10/W2EtekEtWjAtOVxcdTAwN0YtXFx1RkZGRl86LV0rKS87XG4gICAgICAgICAgdmFyIG5vdENsYXNzSWQgPSAvXlxcLnwjLztcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcGFyc2VUYWc7XG5cbiAgICAgICAgICBmdW5jdGlvbiBwYXJzZVRhZyh0YWcsIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIXRhZykge1xuICAgICAgICAgICAgICByZXR1cm4gXCJESVZcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5vSWQgPSAhcHJvcHMuaGFzT3duUHJvcGVydHkoXCJpZFwiKTtcblxuICAgICAgICAgICAgdmFyIHRhZ1BhcnRzID0gc3BsaXQodGFnLCBjbGFzc0lkU3BsaXQpO1xuICAgICAgICAgICAgdmFyIHRhZ05hbWUgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAobm90Q2xhc3NJZC50ZXN0KHRhZ1BhcnRzWzFdKSkge1xuICAgICAgICAgICAgICB0YWdOYW1lID0gXCJESVZcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNsYXNzZXMsIHBhcnQsIHR5cGUsIGk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0YWdQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBwYXJ0ID0gdGFnUGFydHNbaV07XG5cbiAgICAgICAgICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0eXBlID0gcGFydC5jaGFyQXQoMCk7XG5cbiAgICAgICAgICAgICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IHBhcnQ7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0gY2xhc3NlcyB8fCBbXTtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2gocGFydC5zdWJzdHJpbmcoMSwgcGFydC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIiNcIiAmJiBub0lkKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuaWQgPSBwYXJ0LnN1YnN0cmluZygxLCBwYXJ0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BzLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChwcm9wcy5jbGFzc05hbWUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcHJvcHMuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByb3BzLm5hbWVzcGFjZSA/IHRhZ05hbWUgOiB0YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IFwiYnJvd3Nlci1zcGxpdFwiOiAyIH0sXG4gICAgICBdLFxuICAgICAgMjM6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIERFRkFVTFRfTkFNRVNQQUNFID0gbnVsbDtcbiAgICAgICAgICB2YXIgRVZfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHNcIjtcbiAgICAgICAgICB2YXIgWExJTktfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI7XG4gICAgICAgICAgdmFyIFhNTF9OQU1FU1BBQ0UgPSBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiO1xuXG4gICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHVGlueTEyL2F0dHJpYnV0ZVRhYmxlLmh0bWxcbiAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvYXR0aW5kZXguaHRtbFxuICAgICAgICAgIHZhciBTVkdfUFJPUEVSVElFUyA9IHtcbiAgICAgICAgICAgIGFib3V0OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwiYWNjZW50LWhlaWdodFwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGFjY3VtdWxhdGU6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgYWRkaXRpdmU6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBhbHBoYWJldGljOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGFtcGxpdHVkZTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcImFyYWJpYy1mb3JtXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgYXNjZW50OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgYXR0cmlidXRlVHlwZTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBhemltdXRoOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGJhbmR3aWR0aDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBiYXNlRnJlcXVlbmN5OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGJhc2VQcm9maWxlOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwiYmFzZWxpbmUtc2hpZnRcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBiYm94OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGJlZ2luOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGJpYXM6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgYnk6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgY2FsY01vZGU6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJjYXAtaGVpZ2h0XCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgY2xhc3M6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgY2xpcDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcImNsaXAtcGF0aFwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwiY2xpcC1ydWxlXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgY2xpcFBhdGhVbml0czogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcImNvbG9yLWludGVycG9sYXRpb25cIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwiY29sb3ItcHJvZmlsZVwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwiY29sb3ItcmVuZGVyaW5nXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgY29udGVudDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBjb250ZW50U2NyaXB0VHlwZTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBjb250ZW50U3R5bGVUeXBlOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGN1cnNvcjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBjeDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBjeTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBkOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGRhdGF0eXBlOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGRlZmF1bHRBY3Rpb246IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZGVzY2VudDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBkaWZmdXNlQ29uc3RhbnQ6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGRpc3BsYXk6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZGl2aXNvcjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcImRvbWluYW50LWJhc2VsaW5lXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZHVyOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGR4OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGR5OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGVkZ2VNb2RlOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGVsZXZhdGlvbjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcImVuYWJsZS1iYWNrZ3JvdW5kXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZW5kOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwiZXY6ZXZlbnRcIjogRVZfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZXZlbnQ6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZXhwb25lbnQ6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBmaWxsOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJmaWxsLXJ1bGVcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBmaWx0ZXI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZmlsdGVyUmVzOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGZpbHRlclVuaXRzOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwiZmxvb2QtY29sb3JcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcImZsb29kLW9wYWNpdHlcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBmb2N1c0hpZ2hsaWdodDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBmb2N1c2FibGU6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJmb250LWZhbWlseVwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJmb250LXNpemUtYWRqdXN0XCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJmb250LXN0cmV0Y2hcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcImZvbnQtc3R5bGVcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcImZvbnQtdmFyaWFudFwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwiZm9udC13ZWlnaHRcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBmb3JtYXQ6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZnJvbTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBmeDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBmeTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBnMTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBnMjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcImdseXBoLW5hbWVcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcImdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWxcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcImdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZ2x5cGhSZWY6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgZ3JhZGllbnRVbml0czogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBoYW5kbGVyOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGhhbmdpbmc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgaGVpZ2h0OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwiaG9yaXotYWR2LXhcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcImhvcml6LW9yaWdpbi14XCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJob3Jpei1vcmlnaW4teVwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGlkOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGlkZW9ncmFwaGljOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwiaW1hZ2UtcmVuZGVyaW5nXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgaW46IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgaW4yOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGluaXRpYWxWaXNpYmlsaXR5OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGludGVyY2VwdDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBrOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGsxOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGsyOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGszOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGs0OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGtlcm5lbE1hdHJpeDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBrZXJuZWxVbml0TGVuZ3RoOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGtlcm5pbmc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAga2V5UG9pbnRzOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIGtleVNwbGluZXM6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAga2V5VGltZXM6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgbGFuZzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBsZW5ndGhBZGp1c3Q6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJsZXR0ZXItc3BhY2luZ1wiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwibGlnaHRpbmctY29sb3JcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBsaW1pdGluZ0NvbmVBbmdsZTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBsb2NhbDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcIm1hcmtlci1lbmRcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcIm1hcmtlci1taWRcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcIm1hcmtlci1zdGFydFwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIG1hcmtlckhlaWdodDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBtYXJrZXJVbml0czogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBtYXJrZXJXaWR0aDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBtYXNrOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIG1hc2tDb250ZW50VW5pdHM6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgbWFza1VuaXRzOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIG1hdGhlbWF0aWNhbDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBtYXg6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgbWVkaWE6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgbWVkaWFDaGFyYWN0ZXJFbmNvZGluZzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBtZWRpYUNvbnRlbnRFbmNvZGluZ3M6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgbWVkaWFTaXplOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIG1lZGlhVGltZTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBtZXRob2Q6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgbWluOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIG1vZGU6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgbmFtZTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcIm5hdi1kb3duXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJuYXYtZG93bi1sZWZ0XCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJuYXYtZG93bi1yaWdodFwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwibmF2LWxlZnRcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcIm5hdi1uZXh0XCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJuYXYtcHJldlwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwibmF2LXJpZ2h0XCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJuYXYtdXBcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcIm5hdi11cC1sZWZ0XCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJuYXYtdXAtcmlnaHRcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBudW1PY3RhdmVzOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIG9ic2VydmVyOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIG9mZnNldDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBvcGFjaXR5OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIG9wZXJhdG9yOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIG9yZGVyOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIG9yaWVudDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBvcmllbnRhdGlvbjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBvcmlnaW46IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgb3ZlcmZsb3c6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgb3ZlcmxheTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcIm92ZXJsaW5lLXBvc2l0aW9uXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJvdmVybGluZS10aGlja25lc3NcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInBhbm9zZS0xXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcGF0aDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBwYXRoTGVuZ3RoOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHBhdHRlcm5Db250ZW50VW5pdHM6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcGF0dGVyblRyYW5zZm9ybTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBwYXR0ZXJuVW5pdHM6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcGhhc2U6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcGxheWJhY2tPcmRlcjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInBvaW50ZXItZXZlbnRzXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcG9pbnRzOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHBvaW50c0F0WDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBwb2ludHNBdFk6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcG9pbnRzQXRaOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHByZXNlcnZlQWxwaGE6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBwcmltaXRpdmVVbml0czogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBwcm9wYWdhdGU6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcHJvcGVydHk6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICByYWRpdXM6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcmVmWDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICByZWZZOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHJlbDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInJlbmRlcmluZy1pbnRlbnRcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICByZXBlYXRDb3VudDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICByZXBlYXREdXI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcmVxdWlyZWRFeHRlbnNpb25zOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHJlcXVpcmVkRmVhdHVyZXM6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcmVxdWlyZWRGb250czogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICByZXF1aXJlZEZvcm1hdHM6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcmVzb3VyY2U6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcmVzdGFydDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICByZXN1bHQ6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcmV2OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHJvbGU6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgcm90YXRlOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHJ4OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHJ5OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHNjYWxlOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHNlZWQ6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJzaGFwZS1yZW5kZXJpbmdcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBzbG9wZTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBzbmFwc2hvdFRpbWU6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgc3BhY2luZzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBzcGVjdWxhckNvbnN0YW50OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHNwZWN1bGFyRXhwb25lbnQ6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgc3ByZWFkTWV0aG9kOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHN0ZERldmlhdGlvbjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBzdGVtaDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBzdGVtdjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBzdGl0Y2hUaWxlczogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInN0b3AtY29sb3JcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInN0b3Atb3BhY2l0eVwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwic3RyaWtldGhyb3VnaC1wb3NpdGlvblwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwic3RyaWtldGhyb3VnaC10aGlja25lc3NcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBzdHJpbmc6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgc3Ryb2tlOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwic3Ryb2tlLWRhc2hvZmZzZXRcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInN0cm9rZS1saW5lY2FwXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJzdHJva2UtbGluZWpvaW5cIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInN0cm9rZS1taXRlcmxpbWl0XCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgc3VyZmFjZVNjYWxlOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHN5bmNCZWhhdmlvcjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBzeW5jQmVoYXZpb3JEZWZhdWx0OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHN5bmNNYXN0ZXI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgc3luY1RvbGVyYW5jZTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBzeW5jVG9sZXJhbmNlRGVmYXVsdDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBzeXN0ZW1MYW5ndWFnZTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICB0YWJsZVZhbHVlczogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICB0YXJnZXQ6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgdGFyZ2V0WDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICB0YXJnZXRZOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwidGV4dC1hbmNob3JcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInRleHQtZGVjb3JhdGlvblwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwidGV4dC1yZW5kZXJpbmdcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICB0ZXh0TGVuZ3RoOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHRpbWVsaW5lQmVnaW46IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgdGl0bGU6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgdG86IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHRyYW5zZm9ybUJlaGF2aW9yOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHR5cGU6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgdHlwZW9mOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHUxOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHUyOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwidW5kZXJsaW5lLXBvc2l0aW9uXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJ1bmRlcmxpbmUtdGhpY2tuZXNzXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgdW5pY29kZTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInVuaWNvZGUtYmlkaVwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwidW5pY29kZS1yYW5nZVwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwidW5pdHMtcGVyLWVtXCI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJ2LWFscGhhYmV0aWNcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInYtaGFuZ2luZ1wiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwidi1pZGVvZ3JhcGhpY1wiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwidi1tYXRoZW1hdGljYWxcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICB2YWx1ZXM6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgdmVyc2lvbjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInZlcnQtYWR2LXlcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInZlcnQtb3JpZ2luLXhcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInZlcnQtb3JpZ2luLXlcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICB2aWV3Qm94OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHZpZXdUYXJnZXQ6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICB3aWR0aDogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICB3aWR0aHM6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJ3b3JkLXNwYWNpbmdcIjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcIndyaXRpbmctbW9kZVwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHg6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJ4LWhlaWdodFwiOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHgxOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHgyOiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHhDaGFubmVsU2VsZWN0b3I6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJ4bGluazphY3R1YXRlXCI6IFhMSU5LX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwieGxpbms6YXJjcm9sZVwiOiBYTElOS19OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInhsaW5rOmhyZWZcIjogWExJTktfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJ4bGluazpyb2xlXCI6IFhMSU5LX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwieGxpbms6c2hvd1wiOiBYTElOS19OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInhsaW5rOnRpdGxlXCI6IFhMSU5LX05BTUVTUEFDRSxcbiAgICAgICAgICAgIFwieGxpbms6dHlwZVwiOiBYTElOS19OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInhtbDpiYXNlXCI6IFhNTF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBcInhtbDppZFwiOiBYTUxfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJ4bWw6bGFuZ1wiOiBYTUxfTkFNRVNQQUNFLFxuICAgICAgICAgICAgXCJ4bWw6c3BhY2VcIjogWE1MX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHk6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgeTE6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgeTI6IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgICAgeUNoYW5uZWxTZWxlY3RvcjogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICB6OiBERUZBVUxUX05BTUVTUEFDRSxcbiAgICAgICAgICAgIHpvb21BbmRQYW46IERFRkFVTFRfTkFNRVNQQUNFLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFNWR0F0dHJpYnV0ZU5hbWVzcGFjZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIFNWR0F0dHJpYnV0ZU5hbWVzcGFjZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKFNWR19QUk9QRVJUSUVTLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gU1ZHX1BST1BFUlRJRVNbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge30sXG4gICAgICBdLFxuICAgICAgMjQ6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKFwieC1pcy1hcnJheVwiKTtcblxuICAgICAgICAgIHZhciBoID0gcmVxdWlyZShcIi4vaW5kZXguanNcIik7XG5cbiAgICAgICAgICB2YXIgU1ZHQXR0cmlidXRlTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vc3ZnLWF0dHJpYnV0ZS1uYW1lc3BhY2VcIik7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZUhvb2sgPSByZXF1aXJlKFwiLi9ob29rcy9hdHRyaWJ1dGUtaG9va1wiKTtcblxuICAgICAgICAgIHZhciBTVkdfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzdmc7XG5cbiAgICAgICAgICBmdW5jdGlvbiBzdmcodGFnTmFtZSwgcHJvcGVydGllcywgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4gJiYgaXNDaGlsZHJlbihwcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICBjaGlsZHJlbiA9IHByb3BlcnRpZXM7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG5cbiAgICAgICAgICAgIC8vIHNldCBuYW1lc3BhY2UgZm9yIHN2Z1xuICAgICAgICAgICAgcHJvcGVydGllcy5uYW1lc3BhY2UgPSBTVkdfTkFNRVNQQUNFO1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMuYXR0cmlidXRlcyB8fCAocHJvcGVydGllcy5hdHRyaWJ1dGVzID0ge30pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgICBpZiAoIXByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IFNWR0F0dHJpYnV0ZU5hbWVzcGFjZShrZXkpO1xuXG4gICAgICAgICAgICAgIGlmIChuYW1lc3BhY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhIHN2ZyBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BlcnRpZXNba2V5XTtcblxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSBcImJvb2xlYW5cIlxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChuYW1lc3BhY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBuYW1lc3BhY2VkIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNba2V5XSA9IGF0dHJpYnV0ZUhvb2sobmFtZXNwYWNlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgcHJvcGVydGllc1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaCh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNDaGlsZHJlbih4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3RyaW5nXCIgfHwgaXNBcnJheSh4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcIi4vaG9va3MvYXR0cmlidXRlLWhvb2tcIjogMTgsXG4gICAgICAgICAgXCIuL2luZGV4LmpzXCI6IDIxLFxuICAgICAgICAgIFwiLi9zdmctYXR0cmlidXRlLW5hbWVzcGFjZVwiOiAyMyxcbiAgICAgICAgICBcIngtaXMtYXJyYXlcIjogOCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICAyNTogW1xuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgdmFyIGlzVk5vZGUgPSByZXF1aXJlKFwiLi9pcy12bm9kZVwiKTtcbiAgICAgICAgICB2YXIgaXNWVGV4dCA9IHJlcXVpcmUoXCIuL2lzLXZ0ZXh0XCIpO1xuICAgICAgICAgIHZhciBpc1dpZGdldCA9IHJlcXVpcmUoXCIuL2lzLXdpZGdldFwiKTtcbiAgICAgICAgICB2YXIgaXNUaHVuayA9IHJlcXVpcmUoXCIuL2lzLXRodW5rXCIpO1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVUaHVuaztcblxuICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVRodW5rKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZEEgPSBhO1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkQiA9IGI7XG5cbiAgICAgICAgICAgIGlmIChpc1RodW5rKGIpKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmVkQiA9IHJlbmRlclRodW5rKGIsIGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNUaHVuayhhKSkge1xuICAgICAgICAgICAgICByZW5kZXJlZEEgPSByZW5kZXJUaHVuayhhLCBudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgYTogcmVuZGVyZWRBLFxuICAgICAgICAgICAgICBiOiByZW5kZXJlZEIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJlbmRlclRodW5rKHRodW5rLCBwcmV2aW91cykge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkVGh1bmsgPSB0aHVuay52bm9kZTtcblxuICAgICAgICAgICAgaWYgKCFyZW5kZXJlZFRodW5rKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmVkVGh1bmsgPSB0aHVuay52bm9kZSA9IHRodW5rLnJlbmRlcihwcmV2aW91cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICBpc1ZOb2RlKHJlbmRlcmVkVGh1bmspIHx8XG4gICAgICAgICAgICAgICAgaXNWVGV4dChyZW5kZXJlZFRodW5rKSB8fFxuICAgICAgICAgICAgICAgIGlzV2lkZ2V0KHJlbmRlcmVkVGh1bmspXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0aHVuayBkaWQgbm90IHJldHVybiBhIHZhbGlkIG5vZGVcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlZFRodW5rO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwiLi9pcy10aHVua1wiOiAyNixcbiAgICAgICAgICBcIi4vaXMtdm5vZGVcIjogMjgsXG4gICAgICAgICAgXCIuL2lzLXZ0ZXh0XCI6IDI5LFxuICAgICAgICAgIFwiLi9pcy13aWRnZXRcIjogMzAsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgMjY6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gaXNUaHVuaztcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzVGh1bmsodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQgJiYgdC50eXBlID09PSBcIlRodW5rXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7fSxcbiAgICAgIF0sXG4gICAgICAyNzogW1xuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBpc0hvb2s7XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0hvb2soaG9vaykge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgaG9vayAmJlxuICAgICAgICAgICAgICAoKHR5cGVvZiBob29rLmhvb2sgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICFob29rLmhhc093blByb3BlcnR5KFwiaG9va1wiKSkgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIGhvb2sudW5ob29rID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICFob29rLmhhc093blByb3BlcnR5KFwidW5ob29rXCIpKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7fSxcbiAgICAgIF0sXG4gICAgICAyODogW1xuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgdmFyIHZlcnNpb24gPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBpc1ZpcnR1YWxOb2RlO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaXNWaXJ0dWFsTm9kZSh4KSB7XG4gICAgICAgICAgICByZXR1cm4geCAmJiB4LnR5cGUgPT09IFwiVmlydHVhbE5vZGVcIiAmJiB4LnZlcnNpb24gPT09IHZlcnNpb247XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IFwiLi92ZXJzaW9uXCI6IDMxIH0sXG4gICAgICBdLFxuICAgICAgMjk6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIHZhciB2ZXJzaW9uID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gaXNWaXJ0dWFsVGV4dDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzVmlydHVhbFRleHQoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHggJiYgeC50eXBlID09PSBcIlZpcnR1YWxUZXh0XCIgJiYgeC52ZXJzaW9uID09PSB2ZXJzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeyBcIi4vdmVyc2lvblwiOiAzMSB9LFxuICAgICAgXSxcbiAgICAgIDMwOiBbXG4gICAgICAgIGZ1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGlzV2lkZ2V0O1xuXG4gICAgICAgICAgZnVuY3Rpb24gaXNXaWRnZXQodykge1xuICAgICAgICAgICAgcmV0dXJuIHcgJiYgdy50eXBlID09PSBcIldpZGdldFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge30sXG4gICAgICBdLFxuICAgICAgMzE6IFtcbiAgICAgICAgZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gXCIyXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHt9LFxuICAgICAgXSxcbiAgICAgIDMyOiBbXG4gICAgICAgIGZ1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICB2YXIgdmVyc2lvbiA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG4gICAgICAgICAgdmFyIGlzVk5vZGUgPSByZXF1aXJlKFwiLi9pcy12bm9kZVwiKTtcbiAgICAgICAgICB2YXIgaXNXaWRnZXQgPSByZXF1aXJlKFwiLi9pcy13aWRnZXRcIik7XG4gICAgICAgICAgdmFyIGlzVGh1bmsgPSByZXF1aXJlKFwiLi9pcy10aHVua1wiKTtcbiAgICAgICAgICB2YXIgaXNWSG9vayA9IHJlcXVpcmUoXCIuL2lzLXZob29rXCIpO1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBWaXJ0dWFsTm9kZTtcblxuICAgICAgICAgIHZhciBub1Byb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICB2YXIgbm9DaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgICAgZnVuY3Rpb24gVmlydHVhbE5vZGUodGFnTmFtZSwgcHJvcGVydGllcywgY2hpbGRyZW4sIGtleSwgbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBub1Byb3BlcnRpZXM7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgbm9DaGlsZHJlbjtcbiAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5ICE9IG51bGwgPyBTdHJpbmcoa2V5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubmFtZXNwYWNlID0gdHlwZW9mIG5hbWVzcGFjZSA9PT0gXCJzdHJpbmdcIiA/IG5hbWVzcGFjZSA6IG51bGw7XG5cbiAgICAgICAgICAgIHZhciBjb3VudCA9IChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHx8IDA7XG4gICAgICAgICAgICB2YXIgZGVzY2VuZGFudHMgPSAwO1xuICAgICAgICAgICAgdmFyIGhhc1dpZGdldHMgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBoYXNUaHVua3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBkZXNjZW5kYW50SG9va3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBob29rcztcblxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWSG9vayhwcm9wZXJ0eSkgJiYgcHJvcGVydHkudW5ob29rKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0ge307XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGhvb2tzW3Byb3BOYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIGRlc2NlbmRhbnRzICs9IGNoaWxkLmNvdW50IHx8IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWhhc1dpZGdldHMgJiYgY2hpbGQuaGFzV2lkZ2V0cykge1xuICAgICAgICAgICAgICAgICAgaGFzV2lkZ2V0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNUaHVua3MgJiYgY2hpbGQuaGFzVGh1bmtzKSB7XG4gICAgICAgICAgICAgICAgICBoYXNUaHVua3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICFkZXNjZW5kYW50SG9va3MgJiZcbiAgICAgICAgICAgICAgICAgIChjaGlsZC5ob29rcyB8fCBjaGlsZC5kZXNjZW5kYW50SG9va3MpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBkZXNjZW5kYW50SG9va3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaGFzV2lkZ2V0cyAmJiBpc1dpZGdldChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkLmRlc3Ryb3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgaGFzV2lkZ2V0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFoYXNUaHVua3MgJiYgaXNUaHVuayhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBoYXNUaHVua3MgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY291bnQgPSBjb3VudCArIGRlc2NlbmRhbnRzO1xuICAgICAgICAgICAgdGhpcy5oYXNXaWRnZXRzID0gaGFzV2lkZ2V0cztcbiAgICAgICAgICAgIHRoaXMuaGFzVGh1bmtzID0gaGFzVGh1bmtzO1xuICAgICAgICAgICAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgICAgICAgICAgdGhpcy5kZXNjZW5kYW50SG9va3MgPSBkZXNjZW5kYW50SG9va3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgVmlydHVhbE5vZGUucHJvdG90eXBlLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgIFZpcnR1YWxOb2RlLnByb3RvdHlwZS50eXBlID0gXCJWaXJ0dWFsTm9kZVwiO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCIuL2lzLXRodW5rXCI6IDI2LFxuICAgICAgICAgIFwiLi9pcy12aG9va1wiOiAyNyxcbiAgICAgICAgICBcIi4vaXMtdm5vZGVcIjogMjgsXG4gICAgICAgICAgXCIuL2lzLXdpZGdldFwiOiAzMCxcbiAgICAgICAgICBcIi4vdmVyc2lvblwiOiAzMSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICAzMzogW1xuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgdmFyIHZlcnNpb24gPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuXG4gICAgICAgICAgVmlydHVhbFBhdGNoLk5PTkUgPSAwO1xuICAgICAgICAgIFZpcnR1YWxQYXRjaC5WVEVYVCA9IDE7XG4gICAgICAgICAgVmlydHVhbFBhdGNoLlZOT0RFID0gMjtcbiAgICAgICAgICBWaXJ0dWFsUGF0Y2guV0lER0VUID0gMztcbiAgICAgICAgICBWaXJ0dWFsUGF0Y2guUFJPUFMgPSA0O1xuICAgICAgICAgIFZpcnR1YWxQYXRjaC5PUkRFUiA9IDU7XG4gICAgICAgICAgVmlydHVhbFBhdGNoLklOU0VSVCA9IDY7XG4gICAgICAgICAgVmlydHVhbFBhdGNoLlJFTU9WRSA9IDc7XG4gICAgICAgICAgVmlydHVhbFBhdGNoLlRIVU5LID0gODtcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gVmlydHVhbFBhdGNoO1xuXG4gICAgICAgICAgZnVuY3Rpb24gVmlydHVhbFBhdGNoKHR5cGUsIHZOb2RlLCBwYXRjaCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gTnVtYmVyKHR5cGUpO1xuICAgICAgICAgICAgdGhpcy52Tm9kZSA9IHZOb2RlO1xuICAgICAgICAgICAgdGhpcy5wYXRjaCA9IHBhdGNoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFZpcnR1YWxQYXRjaC5wcm90b3R5cGUudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgVmlydHVhbFBhdGNoLnByb3RvdHlwZS50eXBlID0gXCJWaXJ0dWFsUGF0Y2hcIjtcbiAgICAgICAgfSxcbiAgICAgICAgeyBcIi4vdmVyc2lvblwiOiAzMSB9LFxuICAgICAgXSxcbiAgICAgIDM0OiBbXG4gICAgICAgIGZ1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICB2YXIgdmVyc2lvbiA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFZpcnR1YWxUZXh0O1xuXG4gICAgICAgICAgZnVuY3Rpb24gVmlydHVhbFRleHQodGV4dCkge1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gU3RyaW5nKHRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFZpcnR1YWxUZXh0LnByb3RvdHlwZS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICBWaXJ0dWFsVGV4dC5wcm90b3R5cGUudHlwZSA9IFwiVmlydHVhbFRleHRcIjtcbiAgICAgICAgfSxcbiAgICAgICAgeyBcIi4vdmVyc2lvblwiOiAzMSB9LFxuICAgICAgXSxcbiAgICAgIDM1OiBbXG4gICAgICAgIGZ1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICB2YXIgaXNPYmplY3QgPSByZXF1aXJlKFwiaXMtb2JqZWN0XCIpO1xuICAgICAgICAgIHZhciBpc0hvb2sgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtdmhvb2tcIik7XG5cbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRpZmZQcm9wcztcblxuICAgICAgICAgIGZ1bmN0aW9uIGRpZmZQcm9wcyhhLCBiKSB7XG4gICAgICAgICAgICB2YXIgZGlmZjtcblxuICAgICAgICAgICAgZm9yICh2YXIgYUtleSBpbiBhKSB7XG4gICAgICAgICAgICAgIGlmICghKGFLZXkgaW4gYikpIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gZGlmZiB8fCB7fTtcbiAgICAgICAgICAgICAgICBkaWZmW2FLZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGFWYWx1ZSA9IGFbYUtleV07XG4gICAgICAgICAgICAgIHZhciBiVmFsdWUgPSBiW2FLZXldO1xuXG4gICAgICAgICAgICAgIGlmIChhVmFsdWUgPT09IGJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGFWYWx1ZSkgJiYgaXNPYmplY3QoYlZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChnZXRQcm90b3R5cGUoYlZhbHVlKSAhPT0gZ2V0UHJvdG90eXBlKGFWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGRpZmYgPSBkaWZmIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgZGlmZlthS2V5XSA9IGJWYWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzSG9vayhiVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICBkaWZmID0gZGlmZiB8fCB7fTtcbiAgICAgICAgICAgICAgICAgIGRpZmZbYUtleV0gPSBiVmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBvYmplY3REaWZmID0gZGlmZlByb3BzKGFWYWx1ZSwgYlZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChvYmplY3REaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPSBkaWZmIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBkaWZmW2FLZXldID0gb2JqZWN0RGlmZjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IGRpZmYgfHwge307XG4gICAgICAgICAgICAgICAgZGlmZlthS2V5XSA9IGJWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBiS2V5IGluIGIpIHtcbiAgICAgICAgICAgICAgaWYgKCEoYktleSBpbiBhKSkge1xuICAgICAgICAgICAgICAgIGRpZmYgPSBkaWZmIHx8IHt9O1xuICAgICAgICAgICAgICAgIGRpZmZbYktleV0gPSBiW2JLZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFByb3RvdHlwZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUuX19wcm90b19fKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5fX3Byb3RvX187XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IFwiLi4vdm5vZGUvaXMtdmhvb2tcIjogMjcsIFwiaXMtb2JqZWN0XCI6IDcgfSxcbiAgICAgIF0sXG4gICAgICAzNjogW1xuICAgICAgICBmdW5jdGlvbiAocmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgdmFyIGlzQXJyYXkgPSByZXF1aXJlKFwieC1pcy1hcnJheVwiKTtcblxuICAgICAgICAgIHZhciBWUGF0Y2ggPSByZXF1aXJlKFwiLi4vdm5vZGUvdnBhdGNoXCIpO1xuICAgICAgICAgIHZhciBpc1ZOb2RlID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXZub2RlXCIpO1xuICAgICAgICAgIHZhciBpc1ZUZXh0ID0gcmVxdWlyZShcIi4uL3Zub2RlL2lzLXZ0ZXh0XCIpO1xuICAgICAgICAgIHZhciBpc1dpZGdldCA9IHJlcXVpcmUoXCIuLi92bm9kZS9pcy13aWRnZXRcIik7XG4gICAgICAgICAgdmFyIGlzVGh1bmsgPSByZXF1aXJlKFwiLi4vdm5vZGUvaXMtdGh1bmtcIik7XG4gICAgICAgICAgdmFyIGhhbmRsZVRodW5rID0gcmVxdWlyZShcIi4uL3Zub2RlL2hhbmRsZS10aHVua1wiKTtcblxuICAgICAgICAgIHZhciBkaWZmUHJvcHMgPSByZXF1aXJlKFwiLi9kaWZmLXByb3BzXCIpO1xuXG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkaWZmO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZGlmZihhLCBiKSB7XG4gICAgICAgICAgICB2YXIgcGF0Y2ggPSB7IGE6IGEgfTtcbiAgICAgICAgICAgIHdhbGsoYSwgYiwgcGF0Y2gsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGNoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHdhbGsoYSwgYiwgcGF0Y2gsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhcHBseSA9IHBhdGNoW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBhcHBseUNsZWFyID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc1RodW5rKGEpIHx8IGlzVGh1bmsoYikpIHtcbiAgICAgICAgICAgICAgdGh1bmtzKGEsIGIsIHBhdGNoLCBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiBhIGlzIGEgd2lkZ2V0IHdlIHdpbGwgYWRkIGEgcmVtb3ZlIHBhdGNoIGZvciBpdFxuICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYW55IGNoaWxkIHdpZGdldHMvaG9va3MgbXVzdCBiZSBkZXN0cm95ZWQuXG4gICAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgYWRkaW5nIHR3byByZW1vdmUgcGF0Y2hlcyBmb3IgYSB3aWRnZXQuXG4gICAgICAgICAgICAgIGlmICghaXNXaWRnZXQoYSkpIHtcbiAgICAgICAgICAgICAgICBjbGVhclN0YXRlKGEsIHBhdGNoLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgYXBwbHkgPSBwYXRjaFtpbmRleF07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhcHBseSA9IGFwcGVuZFBhdGNoKGFwcGx5LCBuZXcgVlBhdGNoKFZQYXRjaC5SRU1PVkUsIGEsIGIpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNWTm9kZShiKSkge1xuICAgICAgICAgICAgICBpZiAoaXNWTm9kZShhKSkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIGEudGFnTmFtZSA9PT0gYi50YWdOYW1lICYmXG4gICAgICAgICAgICAgICAgICBhLm5hbWVzcGFjZSA9PT0gYi5uYW1lc3BhY2UgJiZcbiAgICAgICAgICAgICAgICAgIGEua2V5ID09PSBiLmtleVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgdmFyIHByb3BzUGF0Y2ggPSBkaWZmUHJvcHMoYS5wcm9wZXJ0aWVzLCBiLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgICAgaWYgKHByb3BzUGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICBhcHBseSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgVlBhdGNoKFZQYXRjaC5QUk9QUywgYSwgcHJvcHNQYXRjaClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGFwcGx5ID0gZGlmZkNoaWxkcmVuKGEsIGIsIHBhdGNoLCBhcHBseSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhcHBseSA9IGFwcGVuZFBhdGNoKGFwcGx5LCBuZXcgVlBhdGNoKFZQYXRjaC5WTk9ERSwgYSwgYikpO1xuICAgICAgICAgICAgICAgICAgYXBwbHlDbGVhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcGx5ID0gYXBwZW5kUGF0Y2goYXBwbHksIG5ldyBWUGF0Y2goVlBhdGNoLlZOT0RFLCBhLCBiKSk7XG4gICAgICAgICAgICAgICAgYXBwbHlDbGVhciA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNWVGV4dChiKSkge1xuICAgICAgICAgICAgICBpZiAoIWlzVlRleHQoYSkpIHtcbiAgICAgICAgICAgICAgICBhcHBseSA9IGFwcGVuZFBhdGNoKGFwcGx5LCBuZXcgVlBhdGNoKFZQYXRjaC5WVEVYVCwgYSwgYikpO1xuICAgICAgICAgICAgICAgIGFwcGx5Q2xlYXIgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGEudGV4dCAhPT0gYi50ZXh0KSB7XG4gICAgICAgICAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChhcHBseSwgbmV3IFZQYXRjaChWUGF0Y2guVlRFWFQsIGEsIGIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1dpZGdldChiKSkge1xuICAgICAgICAgICAgICBpZiAoIWlzV2lkZ2V0KGEpKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlDbGVhciA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhcHBseSA9IGFwcGVuZFBhdGNoKGFwcGx5LCBuZXcgVlBhdGNoKFZQYXRjaC5XSURHRVQsIGEsIGIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFwcGx5KSB7XG4gICAgICAgICAgICAgIHBhdGNoW2luZGV4XSA9IGFwcGx5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXBwbHlDbGVhcikge1xuICAgICAgICAgICAgICBjbGVhclN0YXRlKGEsIHBhdGNoLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZGlmZkNoaWxkcmVuKGEsIGIsIHBhdGNoLCBhcHBseSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBhQ2hpbGRyZW4gPSBhLmNoaWxkcmVuO1xuICAgICAgICAgICAgdmFyIG9yZGVyZWRTZXQgPSByZW9yZGVyKGFDaGlsZHJlbiwgYi5jaGlsZHJlbik7XG4gICAgICAgICAgICB2YXIgYkNoaWxkcmVuID0gb3JkZXJlZFNldC5jaGlsZHJlbjtcblxuICAgICAgICAgICAgdmFyIGFMZW4gPSBhQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGJMZW4gPSBiQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGFMZW4gPiBiTGVuID8gYUxlbiA6IGJMZW47XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGxlZnROb2RlID0gYUNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICB2YXIgcmlnaHROb2RlID0gYkNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICBpbmRleCArPSAxO1xuXG4gICAgICAgICAgICAgIGlmICghbGVmdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBFeGNlc3Mgbm9kZXMgaW4gYiBuZWVkIHRvIGJlIGFkZGVkXG4gICAgICAgICAgICAgICAgICBhcHBseSA9IGFwcGVuZFBhdGNoKFxuICAgICAgICAgICAgICAgICAgICBhcHBseSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFZQYXRjaChWUGF0Y2guSU5TRVJULCBudWxsLCByaWdodE5vZGUpXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YWxrKGxlZnROb2RlLCByaWdodE5vZGUsIHBhdGNoLCBpbmRleCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXNWTm9kZShsZWZ0Tm9kZSkgJiYgbGVmdE5vZGUuY291bnQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCArPSBsZWZ0Tm9kZS5jb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3JkZXJlZFNldC5tb3Zlcykge1xuICAgICAgICAgICAgICAvLyBSZW9yZGVyIG5vZGVzIGxhc3RcbiAgICAgICAgICAgICAgYXBwbHkgPSBhcHBlbmRQYXRjaChcbiAgICAgICAgICAgICAgICBhcHBseSxcbiAgICAgICAgICAgICAgICBuZXcgVlBhdGNoKFZQYXRjaC5PUkRFUiwgYSwgb3JkZXJlZFNldC5tb3ZlcylcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNsZWFyU3RhdGUodk5vZGUsIHBhdGNoLCBpbmRleCkge1xuICAgICAgICAgICAgLy8gVE9ETzogTWFrZSB0aGlzIGEgc2luZ2xlIHdhbGssIG5vdCB0d29cbiAgICAgICAgICAgIHVuaG9vayh2Tm9kZSwgcGF0Y2gsIGluZGV4KTtcbiAgICAgICAgICAgIGRlc3Ryb3lXaWRnZXRzKHZOb2RlLCBwYXRjaCwgaW5kZXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFBhdGNoIHJlY29yZHMgZm9yIGFsbCBkZXN0cm95ZWQgd2lkZ2V0cyBtdXN0IGJlIGFkZGVkIGJlY2F1c2Ugd2UgbmVlZFxuICAgICAgICAgIC8vIGEgRE9NIG5vZGUgcmVmZXJlbmNlIGZvciB0aGUgZGVzdHJveSBmdW5jdGlvblxuICAgICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3lXaWRnZXRzKHZOb2RlLCBwYXRjaCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpc1dpZGdldCh2Tm9kZSkpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2Tm9kZS5kZXN0cm95ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFtpbmRleF0gPSBhcHBlbmRQYXRjaChcbiAgICAgICAgICAgICAgICAgIHBhdGNoW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgIG5ldyBWUGF0Y2goVlBhdGNoLlJFTU9WRSwgdk5vZGUsIG51bGwpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgaXNWTm9kZSh2Tm9kZSkgJiZcbiAgICAgICAgICAgICAgKHZOb2RlLmhhc1dpZGdldHMgfHwgdk5vZGUuaGFzVGh1bmtzKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHZOb2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcblxuICAgICAgICAgICAgICAgIGRlc3Ryb3lXaWRnZXRzKGNoaWxkLCBwYXRjaCwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzVk5vZGUoY2hpbGQpICYmIGNoaWxkLmNvdW50KSB7XG4gICAgICAgICAgICAgICAgICBpbmRleCArPSBjaGlsZC5jb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNUaHVuayh2Tm9kZSkpIHtcbiAgICAgICAgICAgICAgdGh1bmtzKHZOb2RlLCBudWxsLCBwYXRjaCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBhIHN1Yi1wYXRjaCBmb3IgdGh1bmtzXG4gICAgICAgICAgZnVuY3Rpb24gdGh1bmtzKGEsIGIsIHBhdGNoLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gaGFuZGxlVGh1bmsoYSwgYik7XG4gICAgICAgICAgICB2YXIgdGh1bmtQYXRjaCA9IGRpZmYobm9kZXMuYSwgbm9kZXMuYik7XG4gICAgICAgICAgICBpZiAoaGFzUGF0Y2hlcyh0aHVua1BhdGNoKSkge1xuICAgICAgICAgICAgICBwYXRjaFtpbmRleF0gPSBuZXcgVlBhdGNoKFZQYXRjaC5USFVOSywgbnVsbCwgdGh1bmtQYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaGFzUGF0Y2hlcyhwYXRjaCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggaW4gcGF0Y2gpIHtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBcImFcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFeGVjdXRlIGhvb2tzIHdoZW4gdHdvIG5vZGVzIGFyZSBpZGVudGljYWxcbiAgICAgICAgICBmdW5jdGlvbiB1bmhvb2sodk5vZGUsIHBhdGNoLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGlzVk5vZGUodk5vZGUpKSB7XG4gICAgICAgICAgICAgIGlmICh2Tm9kZS5ob29rcykge1xuICAgICAgICAgICAgICAgIHBhdGNoW2luZGV4XSA9IGFwcGVuZFBhdGNoKFxuICAgICAgICAgICAgICAgICAgcGF0Y2hbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgbmV3IFZQYXRjaChWUGF0Y2guUFJPUFMsIHZOb2RlLCB1bmRlZmluZWRLZXlzKHZOb2RlLmhvb2tzKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHZOb2RlLmRlc2NlbmRhbnRIb29rcyB8fCB2Tm9kZS5oYXNUaHVua3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB2Tm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcblxuICAgICAgICAgICAgICAgICAgdW5ob29rKGNoaWxkLCBwYXRjaCwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaXNWTm9kZShjaGlsZCkgJiYgY2hpbGQuY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gY2hpbGQuY291bnQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzVGh1bmsodk5vZGUpKSB7XG4gICAgICAgICAgICAgIHRodW5rcyh2Tm9kZSwgbnVsbCwgcGF0Y2gsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB1bmRlZmluZWRLZXlzKG9iaikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIExpc3QgZGlmZiwgbmFpdmUgbGVmdCB0byByaWdodCByZW9yZGVyaW5nXG4gICAgICAgICAgZnVuY3Rpb24gcmVvcmRlcihhQ2hpbGRyZW4sIGJDaGlsZHJlbikge1xuICAgICAgICAgICAgLy8gTyhNKSB0aW1lLCBPKE0pIG1lbW9yeVxuICAgICAgICAgICAgdmFyIGJDaGlsZEluZGV4ID0ga2V5SW5kZXgoYkNoaWxkcmVuKTtcbiAgICAgICAgICAgIHZhciBiS2V5cyA9IGJDaGlsZEluZGV4LmtleXM7XG4gICAgICAgICAgICB2YXIgYkZyZWUgPSBiQ2hpbGRJbmRleC5mcmVlO1xuXG4gICAgICAgICAgICBpZiAoYkZyZWUubGVuZ3RoID09PSBiQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGJDaGlsZHJlbixcbiAgICAgICAgICAgICAgICBtb3ZlczogbnVsbCxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTyhOKSB0aW1lLCBPKE4pIG1lbW9yeVxuICAgICAgICAgICAgdmFyIGFDaGlsZEluZGV4ID0ga2V5SW5kZXgoYUNoaWxkcmVuKTtcbiAgICAgICAgICAgIHZhciBhS2V5cyA9IGFDaGlsZEluZGV4LmtleXM7XG4gICAgICAgICAgICB2YXIgYUZyZWUgPSBhQ2hpbGRJbmRleC5mcmVlO1xuXG4gICAgICAgICAgICBpZiAoYUZyZWUubGVuZ3RoID09PSBhQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGJDaGlsZHJlbixcbiAgICAgICAgICAgICAgICBtb3ZlczogbnVsbCxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTyhNQVgoTiwgTSkpIG1lbW9yeVxuICAgICAgICAgICAgdmFyIG5ld0NoaWxkcmVuID0gW107XG5cbiAgICAgICAgICAgIHZhciBmcmVlSW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIGZyZWVDb3VudCA9IGJGcmVlLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBkZWxldGVkSXRlbXMgPSAwO1xuXG4gICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggYSBhbmQgbWF0Y2ggYSBub2RlIGluIGJcbiAgICAgICAgICAgIC8vIE8oTikgdGltZSxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBhSXRlbSA9IGFDaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgdmFyIGl0ZW1JbmRleDtcblxuICAgICAgICAgICAgICBpZiAoYUl0ZW0ua2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGJLZXlzLmhhc093blByb3BlcnR5KGFJdGVtLmtleSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIHVwIHRoZSBvbGQga2V5c1xuICAgICAgICAgICAgICAgICAgaXRlbUluZGV4ID0gYktleXNbYUl0ZW0ua2V5XTtcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2goYkNoaWxkcmVuW2l0ZW1JbmRleF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb2xkIGtleWVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgICBpdGVtSW5kZXggPSBpIC0gZGVsZXRlZEl0ZW1zKys7XG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCB0aGUgaXRlbSBpbiBhIHdpdGggdGhlIG5leHQgZnJlZSBpdGVtIGluIGJcbiAgICAgICAgICAgICAgICBpZiAoZnJlZUluZGV4IDwgZnJlZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICBpdGVtSW5kZXggPSBiRnJlZVtmcmVlSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGJDaGlsZHJlbltpdGVtSW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIG5vIGZyZWUgaXRlbXMgaW4gYiB0byBtYXRjaCB3aXRoXG4gICAgICAgICAgICAgICAgICAvLyB0aGUgZnJlZSBpdGVtcyBpbiBhLCBzbyB0aGUgZXh0cmEgZnJlZSBub2Rlc1xuICAgICAgICAgICAgICAgICAgLy8gYXJlIGRlbGV0ZWQuXG4gICAgICAgICAgICAgICAgICBpdGVtSW5kZXggPSBpIC0gZGVsZXRlZEl0ZW1zKys7XG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGFzdEZyZWVJbmRleCA9XG4gICAgICAgICAgICAgIGZyZWVJbmRleCA+PSBiRnJlZS5sZW5ndGggPyBiQ2hpbGRyZW4ubGVuZ3RoIDogYkZyZWVbZnJlZUluZGV4XTtcblxuICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGIgYW5kIGFwcGVuZCBhbnkgbmV3IGtleXNcbiAgICAgICAgICAgIC8vIE8oTSkgdGltZVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiQ2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIG5ld0l0ZW0gPSBiQ2hpbGRyZW5bal07XG5cbiAgICAgICAgICAgICAgaWYgKG5ld0l0ZW0ua2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhS2V5cy5oYXNPd25Qcm9wZXJ0eShuZXdJdGVtLmtleSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkZCBhbnkgbmV3IGtleWVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgYWRkaW5nIG5ldyBpdGVtcyB0byB0aGUgZW5kIGFuZCB0aGVuIHNvcnRpbmcgdGhlbVxuICAgICAgICAgICAgICAgICAgLy8gaW4gcGxhY2UuIEluIGZ1dHVyZSB3ZSBzaG91bGQgaW5zZXJ0IG5ldyBpdGVtcyBpbiBwbGFjZS5cbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gobmV3SXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGogPj0gbGFzdEZyZWVJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhbnkgbGVmdG92ZXIgbm9uLWtleWVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChuZXdJdGVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2ltdWxhdGUgPSBuZXdDaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgdmFyIHNpbXVsYXRlSW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIHJlbW92ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBpbnNlcnRzID0gW107XG4gICAgICAgICAgICB2YXIgc2ltdWxhdGVJdGVtO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGJDaGlsZHJlbi5sZW5ndGg7ICkge1xuICAgICAgICAgICAgICB2YXIgd2FudGVkSXRlbSA9IGJDaGlsZHJlbltrXTtcbiAgICAgICAgICAgICAgc2ltdWxhdGVJdGVtID0gc2ltdWxhdGVbc2ltdWxhdGVJbmRleF07XG5cbiAgICAgICAgICAgICAgLy8gcmVtb3ZlIGl0ZW1zXG4gICAgICAgICAgICAgIHdoaWxlIChzaW11bGF0ZUl0ZW0gPT09IG51bGwgJiYgc2ltdWxhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVtb3Zlcy5wdXNoKHJlbW92ZShzaW11bGF0ZSwgc2ltdWxhdGVJbmRleCwgbnVsbCkpO1xuICAgICAgICAgICAgICAgIHNpbXVsYXRlSXRlbSA9IHNpbXVsYXRlW3NpbXVsYXRlSW5kZXhdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFzaW11bGF0ZUl0ZW0gfHwgc2ltdWxhdGVJdGVtLmtleSAhPT0gd2FudGVkSXRlbS5rZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBuZWVkIGEga2V5IGluIHRoaXMgcG9zaXRpb24uLi5cbiAgICAgICAgICAgICAgICBpZiAod2FudGVkSXRlbS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzaW11bGF0ZUl0ZW0gJiYgc2ltdWxhdGVJdGVtLmtleSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbiBpbnNlcnQgZG9lc24ndCBwdXQgdGhpcyBrZXkgaW4gcGxhY2UsIGl0IG5lZWRzIHRvIG1vdmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJLZXlzW3NpbXVsYXRlSXRlbS5rZXldICE9PSBrICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShzaW11bGF0ZSwgc2ltdWxhdGVJbmRleCwgc2ltdWxhdGVJdGVtLmtleSlcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIHNpbXVsYXRlSXRlbSA9IHNpbXVsYXRlW3NpbXVsYXRlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSByZW1vdmUgZGlkbid0IHB1dCB0aGUgd2FudGVkIGl0ZW0gaW4gcGxhY2UsIHdlIG5lZWQgdG8gaW5zZXJ0IGl0XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgIXNpbXVsYXRlSXRlbSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2ltdWxhdGVJdGVtLmtleSAhPT0gd2FudGVkSXRlbS5rZXlcbiAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydHMucHVzaCh7IGtleTogd2FudGVkSXRlbS5rZXksIHRvOiBrIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVtcyBhcmUgbWF0Y2hpbmcsIHNvIHNraXAgYWhlYWRcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbXVsYXRlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0cy5wdXNoKHsga2V5OiB3YW50ZWRJdGVtLmtleSwgdG86IGsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydHMucHVzaCh7IGtleTogd2FudGVkSXRlbS5rZXksIHRvOiBrIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhIGtleSBpbiBzaW11bGF0ZSBoYXMgbm8gbWF0Y2hpbmcgd2FudGVkIGtleSwgcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2ltdWxhdGVJdGVtICYmIHNpbXVsYXRlSXRlbS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgIHJlbW92ZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHNpbXVsYXRlLCBzaW11bGF0ZUluZGV4LCBzaW11bGF0ZUl0ZW0ua2V5KVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2ltdWxhdGVJbmRleCsrO1xuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIHRoZSByZW1haW5pbmcgbm9kZXMgZnJvbSBzaW11bGF0ZVxuICAgICAgICAgICAgd2hpbGUgKHNpbXVsYXRlSW5kZXggPCBzaW11bGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgc2ltdWxhdGVJdGVtID0gc2ltdWxhdGVbc2ltdWxhdGVJbmRleF07XG4gICAgICAgICAgICAgIHJlbW92ZXMucHVzaChcbiAgICAgICAgICAgICAgICByZW1vdmUoXG4gICAgICAgICAgICAgICAgICBzaW11bGF0ZSxcbiAgICAgICAgICAgICAgICAgIHNpbXVsYXRlSW5kZXgsXG4gICAgICAgICAgICAgICAgICBzaW11bGF0ZUl0ZW0gJiYgc2ltdWxhdGVJdGVtLmtleVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIG9ubHkgbW92ZXMgd2UgaGF2ZSBhcmUgZGVsZXRlcyB0aGVuIHdlIGNhbiBqdXN0XG4gICAgICAgICAgICAvLyBsZXQgdGhlIGRlbGV0ZSBwYXRjaCByZW1vdmUgdGhlc2UgaXRlbXMuXG4gICAgICAgICAgICBpZiAocmVtb3Zlcy5sZW5ndGggPT09IGRlbGV0ZWRJdGVtcyAmJiAhaW5zZXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogbmV3Q2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgbW92ZXM6IG51bGwsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBuZXdDaGlsZHJlbixcbiAgICAgICAgICAgICAgbW92ZXM6IHtcbiAgICAgICAgICAgICAgICByZW1vdmVzOiByZW1vdmVzLFxuICAgICAgICAgICAgICAgIGluc2VydHM6IGluc2VydHMsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZShhcnIsIGluZGV4LCBrZXkpIHtcbiAgICAgICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBmcm9tOiBpbmRleCxcbiAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGtleUluZGV4KGNoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IHt9O1xuICAgICAgICAgICAgdmFyIGZyZWUgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgICAgICAgaWYgKGNoaWxkLmtleSkge1xuICAgICAgICAgICAgICAgIGtleXNbY2hpbGQua2V5XSA9IGk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJlZS5wdXNoKGkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGtleXM6IGtleXMsIC8vIEEgaGFzaCBvZiBrZXkgbmFtZSB0byBpbmRleFxuICAgICAgICAgICAgICBmcmVlOiBmcmVlLCAvLyBBbiBhcnJheSBvZiB1bmtleWVkIGl0ZW0gaW5kaWNlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBhcHBlbmRQYXRjaChhcHBseSwgcGF0Y2gpIHtcbiAgICAgICAgICAgIGlmIChhcHBseSkge1xuICAgICAgICAgICAgICBpZiAoaXNBcnJheShhcHBseSkpIHtcbiAgICAgICAgICAgICAgICBhcHBseS5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcHBseSA9IFthcHBseSwgcGF0Y2hdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwiLi4vdm5vZGUvaGFuZGxlLXRodW5rXCI6IDI1LFxuICAgICAgICAgIFwiLi4vdm5vZGUvaXMtdGh1bmtcIjogMjYsXG4gICAgICAgICAgXCIuLi92bm9kZS9pcy12bm9kZVwiOiAyOCxcbiAgICAgICAgICBcIi4uL3Zub2RlL2lzLXZ0ZXh0XCI6IDI5LFxuICAgICAgICAgIFwiLi4vdm5vZGUvaXMtd2lkZ2V0XCI6IDMwLFxuICAgICAgICAgIFwiLi4vdm5vZGUvdnBhdGNoXCI6IDMzLFxuICAgICAgICAgIFwiLi9kaWZmLXByb3BzXCI6IDM1LFxuICAgICAgICAgIFwieC1pcy1hcnJheVwiOiA4LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIDM3OiBbXG4gICAgICAgIGZ1bmN0aW9uIChyZXF1aXJlLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHZkb20gPSB7XG4gICAgICAgICAgICAgICAgVk5vZGU6IHJlcXVpcmUoXCIuL3ZlbmRvci92bm9kZS92bm9kZS5qc1wiKSxcbiAgICAgICAgICAgICAgICBWVGV4dDogcmVxdWlyZShcIi4vdmVuZG9yL3Zub2RlL3Z0ZXh0LmpzXCIpLFxuICAgICAgICAgICAgICAgIGRpZmY6IHJlcXVpcmUoXCIuL3ZlbmRvci9kaWZmLmpzXCIpLFxuICAgICAgICAgICAgICAgIHBhdGNoOiByZXF1aXJlKFwiLi92ZW5kb3IvcGF0Y2guanNcIiksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudDogcmVxdWlyZShcIi4vdmVuZG9yL2NyZWF0ZS1lbGVtZW50LmpzXCIpLFxuICAgICAgICAgICAgICAgIHN2ZzogcmVxdWlyZShcIi4vdmVuZG9yL3ZpcnR1YWwtaHlwZXJzY3JpcHQvc3ZnLmpzXCIpLFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGdsb2JhbC5WaXJ0dWFsRG9tID0gdmRvbTtcbiAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB2ZG9tO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9KS5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgICAgICAgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICA/IHNlbGZcbiAgICAgICAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgID8gd2luZG93XG4gICAgICAgICAgICAgIDoge31cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCIuL3ZlbmRvci9jcmVhdGUtZWxlbWVudC5qc1wiOiA5LFxuICAgICAgICAgIFwiLi92ZW5kb3IvZGlmZi5qc1wiOiAxMCxcbiAgICAgICAgICBcIi4vdmVuZG9yL3BhdGNoLmpzXCI6IDExLFxuICAgICAgICAgIFwiLi92ZW5kb3IvdmlydHVhbC1oeXBlcnNjcmlwdC9zdmcuanNcIjogMjQsXG4gICAgICAgICAgXCIuL3ZlbmRvci92bm9kZS92bm9kZS5qc1wiOiAzMixcbiAgICAgICAgICBcIi4vdmVuZG9yL3Zub2RlL3Z0ZXh0LmpzXCI6IDM0LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9LFxuICAgIHt9LFxuICAgIFszN11cbiAgKSgzNyk7XG59KTtcbiIsImZ1bmN0aW9uIFZkb21UaHVuayhmbiwgYXJncywga2V5KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFZkb21UaHVuaykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZG9tVGh1bmsoZm4sIGFyZ3MsIGtleSk7XG4gICAgfVxuXG4gICAgaWYgKGtleSkge1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuXG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG59O1xuXG5qb29fZ2xvYmFsX29iamVjdC5WZG9tVGh1bmsgPSBWZG9tVGh1bms7XG5cblZkb21UaHVuay5wcm90b3R5cGUudHlwZSA9ICdUaHVuayc7XG5WZG9tVGh1bmsucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChwcmV2KSB7XG4gIGlmIChwcmV2ICYmIHRoaXMuYXJncyA9PT0gcHJldi5hcmdzICYmIHRoaXMuZm4gPT09IHByZXYuZm4pIHtcbiAgICByZXR1cm4gcHJldi52bm9kZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZuKHRoaXMuYXJncyk7XG59O1xuXG5cbiIsIi8vIFVzZWQgYnkgd29ya2Fyb3VuZCBmb3IgaW5wdXQgZWxlbWVudCB2YWx1ZSBmaWVsZFxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL01hdHQtRXNjaC92aXJ0dWFsLWRvbS9ibG9iLzk0N2VjZjkyYjY3ZDI1YmI2OTNhMGY2MjVmYThlOTBjMDk5ODg3ZDUvdmlydHVhbC1oeXBlcnNjcmlwdC9ob29rcy9zb2Z0LXNldC1ob29rLmpzXG5cbmpvb19nbG9iYWxfb2JqZWN0LlNvZnRTZXRIb29rID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29mdFNldEhvb2spKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29mdFNldEhvb2sodmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn07XG5cbmpvb19nbG9iYWxfb2JqZWN0LlNvZnRTZXRIb29rLnByb3RvdHlwZS5ob29rID0gZnVuY3Rpb24gKG5vZGUsIHByb3BlcnR5TmFtZSkge1xuICAgIGlmIChub2RlW3Byb3BlcnR5TmFtZV0gIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdGhpcy52YWx1ZTtcbiAgICB9XG59O1xuXG5cbnZhciBHZW5lcmljSG9vayA9IGZ1bmN0aW9uIChpbml0LCB1cGRhdGUsIGRlc3Ryb3ksIGlkLCBleHRyYSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHZW5lcmljSG9vaykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljSG9vayhpbml0LCB1cGRhdGUsIGRlc3Ryb3ksIGlkLCBleHRyYSk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0ID0gaW5pdDtcbiAgICB0aGlzLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICB0aGlzLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmV4dHJhID0gZXh0cmE7XG59O1xuXG52YXIgaG9va19zdGF0ZV9rZXkgPSBcInZkb21faG9va19zdGF0ZV9rZXlcIjtcblxuaWYgKHRoaXMuU3ltYm9sKSB7XG4gICAgaG9va19zdGF0ZV9rZXkgPSBTeW1ib2woaG9va19zdGF0ZV9rZXkpO1xufVxuXG5HZW5lcmljSG9vay53cml0ZV9zdGF0ZSA9IGZ1bmN0aW9uIChub2RlLCBwcm9wTmFtZSwgc3RhdGUpIHtcbiAgICBpZiAoIW5vZGVbaG9va19zdGF0ZV9rZXldKSB7XG4gICAgICAgIG5vZGVbaG9va19zdGF0ZV9rZXldID0ge307XG4gICAgfVxuICAgIG5vZGVbaG9va19zdGF0ZV9rZXldW3Byb3BOYW1lXSA9IHN0YXRlO1xufVxuXG5HZW5lcmljSG9vay5yZWFkX3N0YXRlID0gZnVuY3Rpb24gKG5vZGUsIHByb3BOYW1lKSB7XG4gICAgcmV0dXJuIG5vZGVbaG9va19zdGF0ZV9rZXldW3Byb3BOYW1lXTtcbn1cblxuR2VuZXJpY0hvb2sucmVtb3ZlX3N0YXRlID0gZnVuY3Rpb24gKG5vZGUsIHByb3BOYW1lKSB7XG4gICAgZGVsZXRlIG5vZGVbaG9va19zdGF0ZV9rZXldW3Byb3BOYW1lXTtcbn1cblxuR2VuZXJpY0hvb2suY2FuVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgIHJldHVybiBmcm9tIGluc3RhbmNlb2YgdGhpcyAmJiB0byBpbnN0YW5jZW9mIHRoaXMgJiYgZnJvbS5pZCA9PT0gdG8uaWQgJiYgdG8udXBkYXRlO1xufTtcblxuR2VuZXJpY0hvb2sucHJvdG90eXBlLmhvb2sgPSBmdW5jdGlvbiAobm9kZSwgcHJvcE5hbWUsIHByZXYpIHtcbiAgICBpZiAoR2VuZXJpY0hvb2suY2FuVHJhbnNpdGlvbihwcmV2LCB0aGlzKSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBHZW5lcmljSG9vay5yZWFkX3N0YXRlKG5vZGUsIHByb3BOYW1lKTtcbiAgICAgICAgc3RhdGUgPSB0aGlzLnVwZGF0ZShzdGF0ZSwgbm9kZSk7XG4gICAgICAgIEdlbmVyaWNIb29rLndyaXRlX3N0YXRlKG5vZGUsIHByb3BOYW1lLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5pbml0KG5vZGUpO1xuICAgICAgICBHZW5lcmljSG9vay53cml0ZV9zdGF0ZShub2RlLCBwcm9wTmFtZSwgc3RhdGUpO1xuICAgIH1cbn07XG5cbkdlbmVyaWNIb29rLnByb3RvdHlwZS51bmhvb2sgPSBmdW5jdGlvbiAobm9kZSwgcHJvcE5hbWUsIG5leHQpIHtcbiAgICBpZiAoR2VuZXJpY0hvb2suY2FuVHJhbnNpdGlvbih0aGlzLCBuZXh0KSkge1xuICAgICAgICAvLyBEbyBub3RoaW5nLCB0aGUgaW1wZW5kaW5nIFtob29rXSB3aWxsIGhhbmRsZSB0aGUgY2FsbCB0byB1cGRhdGUuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN0YXRlID0gR2VuZXJpY0hvb2sucmVhZF9zdGF0ZShub2RlLCBwcm9wTmFtZSk7XG4gICAgICAgIHRoaXMuZGVzdHJveShzdGF0ZSwgbm9kZSk7XG4gICAgICAgIEdlbmVyaWNIb29rLnJlbW92ZV9zdGF0ZShub2RlLCBwcm9wTmFtZSk7XG4gICAgfVxufTtcblxuam9vX2dsb2JhbF9vYmplY3QuR2VuZXJpY0hvb2sgPSBHZW5lcmljSG9vaztcbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mZnNldFxudmFyIGNhbWxfaW50NjRfb2Zmc2V0ID0gTWF0aC5wb3coMiwgLTI0KTtcblxuLy9Qcm92aWRlczogTWxJbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIE1sSW50NjQgKGxvLG1pLGhpKSB7XG4gIHRoaXMubG8gPSBsbyAmIDB4ZmZmZmZmO1xuICB0aGlzLm1pID0gbWkgJiAweGZmZmZmZjtcbiAgdGhpcy5oaSA9IGhpICYgMHhmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBcIl9qXCJcbk1sSW50NjQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvLHRoaXMubWksdGhpcy5oaSk7XG59XG5cbk1sSW50NjQucHJvdG90eXBlLnVjb21wYXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgaWYgKHRoaXMuaGkgPiB4LmhpKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMuaGkgPCB4LmhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGhpID0gdGhpcy5oaSA8PCAxNjtcbiAgdmFyIHhoaSA9IHguaGkgPDwgMTY7XG4gIGlmIChoaSA+IHhoaSkgcmV0dXJuIDE7XG4gIGlmIChoaSA8IHhoaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG8gPSAtIHRoaXMubG87XG4gIHZhciBtaSA9IC0gdGhpcy5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IC0gdGhpcy5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKyB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pICsgeC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgKyB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAtIHgubG87XG4gIHZhciBtaSA9IHRoaXMubWkgLSB4Lm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gdGhpcy5oaSAtIHguaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICogeC5sbztcbiAgdmFyIG1pID0gKChsbyAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgdGhpcy5taSAqIHgubG8gKyB0aGlzLmxvICogeC5taTtcbiAgdmFyIGhpID0gKChtaSAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgdGhpcy5oaSAqIHgubG8gKyB0aGlzLm1pICogeC5taSArIHRoaXMubG8gKiB4LmhpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5sb3x0aGlzLm1pfHRoaXMuaGkpID09IDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmhpIDw8IDE2KSA8IDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyAmIHgubG8sIHRoaXMubWkgJiB4Lm1pLCB0aGlzLmhpICYgeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvfHgubG8sIHRoaXMubWl8eC5taSwgdGhpcy5oaXx4LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvXngubG8sIHRoaXMubWleeC5taSwgdGhpcy5oaV54LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X2xlZnQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNCkge1xuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5sbyA8PCBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubWkgPDwgcykgfCAodGhpcy5sbyA+PiAoMjQgLSBzKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5oaSA8PCBzKSB8ICh0aGlzLm1pID4+ICgyNCAtIHMpKSk7XG4gIH1cbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvIDw8IChzIC0gMjQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubWkgPDwgKHMgLSAyNCkpIHwgKHRoaXMubG8gPj4gKDQ4IC0gcykpKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KDAsIDAsIHRoaXMubG8gPDwgKHMgLSA0OCkpXG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodF91bnNpZ25lZCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5sbyA+PiBzKSB8ICh0aGlzLm1pIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLm1pID4+IHMpIHwgKHRoaXMuaGkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gcykpO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAodGhpcy5oaSA+PiAocyAtIDI0KSksXG4gICAgICAwKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0ICh0aGlzLmhpID4+IChzIC0gNDgpLCAwLCAwKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIHZhciBoID0gKHRoaXMuaGkgPDwgMTYpID4+IDE2O1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5sbyA+PiBzKSB8ICh0aGlzLm1pIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLm1pID4+IHMpIHwgKGggPDwgKDI0IC0gcykpLFxuICAgICAgKCh0aGlzLmhpIDw8IDE2KSA+PiBzKSA+Pj4gMTYpO1xuICB2YXIgc2lnbiA9ICh0aGlzLmhpIDw8IDE2KSA+PiAzMTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPDwgMTYpID4+IChzIC0gMjQpID4+IDE2LFxuICAgICAgc2lnbiAmIDB4ZmZmZik7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAoKHRoaXMuaGkgPDwgMTYpID4+IChzIC0gMzIpLCBzaWduLCBzaWduKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxzbDEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGkgPSAodGhpcy5oaSA8PCAxKSB8ICh0aGlzLm1pID4+IDIzKTtcbiAgdGhpcy5taSA9ICgodGhpcy5taSA8PCAxKSB8ICh0aGlzLmxvID4+IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5sbyA9ICh0aGlzLmxvIDw8IDEpICYgMHhmZmZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc3IxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxvID0gKCh0aGlzLmxvID4+PiAxKSB8ICh0aGlzLm1pIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9ICgodGhpcy5taSA+Pj4gMSkgfCAodGhpcy5oaSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSB0aGlzLmhpID4+PiAxO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudWRpdm1vZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgbW9kdWx1cyA9IHRoaXMuY29weSgpO1xuICB2YXIgZGl2aXNvciA9IHguY29weSgpO1xuICB2YXIgcXVvdGllbnQgPSBuZXcgTWxJbnQ2NCgwLDAsMCk7XG4gIHdoaWxlIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID4gMCkge1xuICAgIG9mZnNldCsrO1xuICAgIGRpdmlzb3IubHNsMSgpO1xuICB9XG4gIHdoaWxlIChvZmZzZXQgPj0gMCkge1xuICAgIG9mZnNldCAtLTtcbiAgICBxdW90aWVudC5sc2wxKCk7XG4gICAgaWYgKG1vZHVsdXMudWNvbXBhcmUoZGl2aXNvcikgPj0gMCkge1xuICAgICAgcXVvdGllbnQubG8gKys7XG4gICAgICBtb2R1bHVzID0gbW9kdWx1cy5zdWIoZGl2aXNvcik7XG4gICAgfVxuICAgIGRpdmlzb3IubHNyMSgpO1xuICB9XG4gIHJldHVybiB7IHF1b3RpZW50IDogcXVvdGllbnQsIG1vZHVsdXMgOiBtb2R1bHVzIH07XG59XG5NbEludDY0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAoeSlcbntcbiAgdmFyIHggPSB0aGlzO1xuICBpZiAoeS5pc1plcm8oKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4LmhpIF4geS5oaTtcbiAgaWYgKHguaGkgJiAweDgwMDApIHggPSB4Lm5lZygpO1xuICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gIHZhciBxID0geC51ZGl2bW9kKHkpLnF1b3RpZW50O1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgcSA9IHEubmVnKCk7XG4gIHJldHVybiBxO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaTtcbiAgaWYgKHguaGkgJiAweDgwMDApIHggPSB4Lm5lZygpO1xuICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gIHZhciByID0geC51ZGl2bW9kKHkpLm1vZHVsdXM7XG4gIGlmIChzaWduICYgMHg4MDAwKSByID0gci5uZWcoKTtcbiAgcmV0dXJuIHI7XG59XG5NbEludDY0LnByb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubG8gfCAodGhpcy5taSA8PCAyNCk7XG59XG5NbEludDY0LnByb3RvdHlwZS50b0Zsb2F0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLmhpIDw8IDE2KSAqIE1hdGgucG93KDIsIDMyKSArIHRoaXMubWkgKiBNYXRoLnBvdygyLCAyNCkpICsgdGhpcy5sbztcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbdGhpcy5oaSA+PiA4LFxuICAgICAgICAgIHRoaXMuaGkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubWkgPj4gMTYsXG4gICAgICAgICAgKHRoaXMubWkgPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubWkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubG8gPj4gMTYsXG4gICAgICAgICAgKHRoaXMubG8gPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubG8gJiAweGZmXTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxvMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKCh0aGlzLm1pICYgMHhmZikgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaGkzMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5taSA+Pj4gOCkgJiAweGZmZmYpIHwgKHRoaXMuaGkgPDwgMTYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VsdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bHQoeCx5KSB7IHJldHVybiB4LnVjb21wYXJlKHkpIDwgMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY29tcGFyZSh4LHksIHRvdGFsKSB7IHJldHVybiB4LmNvbXBhcmUoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X25lZyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9uZWcgKHgpIHsgcmV0dXJuIHgubmVnKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FkZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hZGQgKHgsIHkpIHsgcmV0dXJuIHguYWRkKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zdWIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc3ViICh4LCB5KSB7IHJldHVybiB4LnN1Yih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbXVsIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tdWwoeCx5KSB7IHJldHVybiB4Lm11bCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfemVybyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc196ZXJvKHgpIHsgcmV0dXJuICt4LmlzWmVybygpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkgeyByZXR1cm4gK3guaXNOZWcoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FuZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hbmQgKHgsIHkpIHsgcmV0dXJuIHguYW5kKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb3IgKHgsIHkpIHsgcmV0dXJuIHgub3IoeSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF94b3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfeG9yICh4LCB5KSB7IHJldHVybiB4Lnhvcih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfbGVmdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0ICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X2xlZnQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZGl2IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2RpdiAoeCwgeSkgeyByZXR1cm4geC5kaXYoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21vZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tb2QgKHgsIHkpIHsgcmV0dXJuIHgubW9kKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9pbnQzMiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoeCAmIDB4ZmZmZmZmLCAoeCA+PiAyNCkgJiAweGZmZmZmZiwgKHggPj4gMzEpICYgMHhmZmZmKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2ludDMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2ludDMyICh4KSB7IHJldHVybiB4LnRvSW50KCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2Zsb2F0ICh4KSB7IHJldHVybiB4LnRvRmxvYXQgKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoeCkge1xuICBpZiAoeCA8IDApIHggPSBNYXRoLmNlaWwoeCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChcbiAgICB4ICYgMHhmZmZmZmYsXG4gICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmZmYsXG4gICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQgKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zvcm1hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mb3JtYXQgKGZtdCwgeCkge1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSkge1xuICAgIGYuc2lnbiA9IC0xOyB4ID0gY2FtbF9pbnQ2NF9uZWcoeCk7XG4gIH1cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIHZhciB3YmFzZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZi5iYXNlKTtcbiAgdmFyIGN2dGJsID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIGRvIHtcbiAgICB2YXIgcCA9IHgudWRpdm1vZCh3YmFzZSk7XG4gICAgeCA9IHAucXVvdGllbnQ7XG4gICAgYnVmZmVyID0gY3Z0YmwuY2hhckF0KGNhbWxfaW50NjRfdG9faW50MzIocC5tb2R1bHVzKSkgKyBidWZmZXI7XG4gIH0gd2hpbGUgKCEgY2FtbF9pbnQ2NF9pc196ZXJvKHgpKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBidWZmZXIubGVuZ3RoO1xuICAgIGlmIChuID4gMCkgYnVmZmVyID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgYnVmZmVyO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIGJ1ZmZlcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfZmFpbHdpdGgsIGNhbWxfcGFyc2VfZGlnaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdWx0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9zdHJpbmcocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgYmFzZTY0ID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihiYXNlKTtcbiAgdmFyIHRocmVzaG9sZCA9XG4gICAgICBuZXcgTWxJbnQ2NCgweGZmZmZmZiwgMHhmZmZmZmZmLCAweGZmZmYpLnVkaXZtb2QoYmFzZTY0KS5xdW90aWVudDtcbiAgdmFyIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB2YXIgcmVzID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgZm9yICg7Oykge1xuICAgIGkrKztcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIG11bHRpcGxpY2F0aW9uIGJhc2UgKiByZXMgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQodGhyZXNob2xkLCByZXMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgICBkID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgICByZXMgPSBjYW1sX2ludDY0X2FkZChjYW1sX2ludDY0X211bChiYXNlNjQsIHJlcyksIGQpO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBhZGRpdGlvbiAoYmFzZSAqIHJlcykgKyBkICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHJlcywgZCkpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChiYXNlID09IDEwICYmIGNhbWxfaW50NjRfdWx0KG5ldyBNbEludDY0KDAsIDAsIDB4ODAwMCksIHJlcykpXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChzaWduIDwgMCkgcmVzID0gY2FtbF9pbnQ2NF9uZWcocmVzKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKGxvLCBtaSwgaGkpe1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSlcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsbywgaGkpe1xuICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgIGxvICYgMHhmZmZmZmYsXG4gICAgKChsbyA+Pj4gMjQpICYgMHhmZikgfCAoKGhpICYgMHhmZmZmKSA8PCA4KSxcbiAgICAoaGkgPj4+IDE2KSAmIDB4ZmZmZik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2xvMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbG8zMih2KXsgcmV0dXJuIHYubG8zMigpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oaTMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hpMzIodil7IHJldHVybiB2LmhpMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoYVs3XSA8PCAwIHwgKGFbNl0gPDwgOCkgfCAoYVs1XSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzRdIDw8IDAgfCAoYVszXSA8PCA4KSB8IChhWzJdIDw8IDE2KSxcbiAgICAgICAgICAgICAgICAgICAgIGFbMV0gPDwgMCB8IChhWzBdIDw8IDgpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fYnl0ZXMoeCkgeyByZXR1cm4geC50b0FycmF5KCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hhc2ggY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGFzaCh2KXtcbiAgcmV0dXJuICh2LmxvMzIoKSkgXiAodi5oaTMyKCkpXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBBbiBPQ2FtbCBzdHJpbmcgaXMgYW4gb2JqZWN0IHdpdGggdGhyZWUgZmllbGRzOlxuLy8gLSB0YWcgJ3QnXG4vLyAtIGxlbmd0aCAnbCdcbi8vIC0gY29udGVudHMgJ2MnXG4vL1xuLy8gVGhlIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcgY2FuIGJlIGVpdGhlciBhIEphdmFTY3JpcHQgYXJyYXkgb3Jcbi8vIGEgSmF2YVNjcmlwdCBzdHJpbmcuIFRoZSBsZW5ndGggb2YgdGhpcyBzdHJpbmcgY2FuIGJlIGxlc3MgdGhhbiB0aGVcbi8vIGxlbmd0aCBvZiB0aGUgT0NhbWwgc3RyaW5nLiBJbiB0aGlzIGNhc2UsIHJlbWFpbmluZyBieXRlcyBhcmVcbi8vIGFzc3VtZWQgdG8gYmUgemVyb2VzLiBBcnJheXMgYXJlIG11dGFibGUgYnV0IGNvbnN1bWVzIG1vcmUgbWVtb3J5XG4vLyB0aGFuIHN0cmluZ3MuIEEgY29tbW9uIHBhdHRlcm4gaXMgdG8gc3RhcnQgZnJvbSBhbiBlbXB0eSBzdHJpbmcgYW5kXG4vLyBwcm9ncmVzc2l2ZWx5IGZpbGwgaXQgZnJvbSB0aGUgc3RhcnQuIFBhcnRpYWwgc3RyaW5ncyBtYWtlcyBpdFxuLy8gcG9zc2libGUgdG8gaW1wbGVtZW50IHRoaXMgZWZmaWNpZW50bHkuXG4vL1xuLy8gV2hlbiBjb252ZXJ0aW5nIHRvIGFuZCBmcm9tIFVURi0xNiwgd2Uga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZVxuLy8gc3RyaW5nIGlzIGNvbXBvc2VkIG9ubHkgb2YgQVNDSUkgY2hhcmFjdGVycyAoaW4gd2hpY2ggY2FzZSwgbm9cbi8vIGNvbnZlcnNpb24gbmVlZHMgdG8gYmUgcGVyZm9ybWVkKSBvciBub3QuXG4vL1xuLy8gVGhlIHN0cmluZyB0YWcgY2FuIHRodXMgdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczpcbi8vICAgZnVsbCBzdHJpbmcgICAgIEJZVEUgfCBVTktOT1dOOiAgICAgIDBcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBBU0NJSTogICAgICAgIDlcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBOT1RfQVNDSUk6ICAgIDhcbi8vICAgc3RyaW5nIHByZWZpeCAgIFBBUlRJQUw6ICAgICAgICAgICAgIDJcbi8vICAgYXJyYXkgICAgICAgICAgIEFSUkFZOiAgICAgICAgICAgICAgIDRcbi8vXG4vLyBPbmUgY2FuIHVzZSBiaXQgbWFza2luZyB0byBkaXNjcmltaW5hdGUgdGhlc2UgZGlmZmVyZW50IGNhc2VzOlxuLy8gICBrbm93bl9lbmNvZGluZyh4KSA9IHgmOFxuLy8gICBpc19hc2NpaSh4KSA9ICAgICAgIHgmMVxuLy8gICBraW5kKHgpID0gICAgICAgICAgIHgmNlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfc3RyX3JlcGVhdChuLCBzKSB7XG4gIGlmKG4gPT0gMCkgcmV0dXJuIFwiXCI7XG4gIGlmIChzLnJlcGVhdCkge3JldHVybiBzLnJlcGVhdChuKTt9IC8vIEVDTUFzY3JpcHQgNiBhbmQgRmlyZWZveCAyNCtcbiAgdmFyIHIgPSBcIlwiLCBsID0gMDtcbiAgZm9yKDs7KSB7XG4gICAgaWYgKG4gJiAxKSByICs9IHM7XG4gICAgbiA+Pj0gMTtcbiAgICBpZiAobiA9PSAwKSByZXR1cm4gcjtcbiAgICBzICs9IHM7XG4gICAgbCsrO1xuICAgIGlmIChsID09IDkpIHtcbiAgICAgIHMuc2xpY2UoMCwxKTsgLy8gZmxhdHRlbiB0aGUgc3RyaW5nXG4gICAgICAvLyB0aGVuLCB0aGUgZmxhdHRlbmluZyBvZiB0aGUgd2hvbGUgc3RyaW5nIHdpbGwgYmUgZmFzdGVyLFxuICAgICAgLy8gYXMgaXQgd2lsbCBiZSBjb21wb3NlZCBvZiBsYXJnZXIgcGllY2VzXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuLy9XZWFrZGVmXG4vLyBQcmUgRUNNQVNjcmlwdCA1LCBbYXBwbHldIHdvdWxkIG5vdCBzdXBwb3J0IGFycmF5LWxpa2Ugb2JqZWN0LlxuLy8gSW4gc3VjaCBzZXR1cCwgVHlwZWRfYXJyYXkgd291bGQgYmUgaW1wbGVtZW50ZWQgYXMgcG9seWZpbGwsIGFuZCBbZi5hcHBseV0gd291bGRcbi8vIGZhaWwgaGVyZS4gTWFyayB0aGUgcHJpbWl0aXZlIGFzIFdlYWtkZWYsIHNvIHRoYXQgcGVvcGxlIGNhbiBvdmVycmlkZSBpdCBlYXNpbHkuXG5mdW5jdGlvbiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKGEsIGksIGxlbikge1xuICB2YXIgZiA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIGlmIChpID09IDAgJiYgbGVuIDw9IDQwOTYgJiYgbGVuID09IGEubGVuZ3RoKSByZXR1cm4gZi5hcHBseSAobnVsbCwgYSk7XG4gIHZhciBzID0gXCJcIjtcbiAgZm9yICg7IDAgPCBsZW47IGkgKz0gMTAyNCxsZW4tPTEwMjQpXG4gICAgcyArPSBmLmFwcGx5IChudWxsLCBhLnNsaWNlKGksaSArIE1hdGgubWluKGxlbiwgMTAyNCkpKTtcbiAgcmV0dXJuIHM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmOF9vZl91dGYxNlxuZnVuY3Rpb24gY2FtbF91dGY4X29mX3V0ZjE2KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBiLCBjLCBkLCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYyA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhjMCB8IChjID4+IDYpKTtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhkZmZmKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlMCB8IChjID4+IDEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA+PSAweGRiZmYgfHwgaSArIDEgPT0gbCB8fFxuICAgICAgICAgICAgICAgKGQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBkID4gMHhkZmZmKSB7XG4gICAgICAvLyBVbm1hdGNoZWQgc3Vycm9nYXRlIHBhaXIsIHJlcGxhY2VkIGJ5IFxcdWZmZmQgKHJlcGxhY2VtZW50IGNoYXJhY3RlcilcbiAgICAgIHQgKz0gXCJcXHhlZlxceGJmXFx4YmRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgICAgYyA9IChjIDw8IDEwKSArIGQgLSAweDM1ZmRjMDA7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMCB8IChjID4+IDE4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDEyKSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfVxuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBjYW1sX3V0ZjE2X29mX3V0Zjgocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IFwiXCIsIGMsIGMxLCBjMiwgdiwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMxID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjMSA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYzEgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgdiA9IDE7XG4gICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgIGMgPSBjMiArIChjMSA8PCA2KTtcbiAgICAgIGlmIChjMSA8IDB4ZTApIHtcbiAgICAgICAgdiA9IGMgLSAweDMwODA7XG4gICAgICAgIGlmICh2IDwgMHg4MCkgdiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gMjtcbiAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgICAgICBjID0gYzIgKyAoYyA8PCA2KTtcbiAgICAgICAgICBpZiAoYzEgPCAweGYwKSB7XG4gICAgICAgICAgICB2ID0gYyAtIDB4ZTIwODA7XG4gICAgICAgICAgICBpZiAoKHYgPCAweDgwMCkgfHwgKCh2ID49IDB4ZDdmZikgJiYgKHYgPCAweGUwMDApKSkgdiA9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHYgPSAzO1xuICAgICAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoYzEgPCAweGY1KSkge1xuICAgICAgICAgICAgICB2ID0gYzIgLSAweDNjODIwODAgKyAoYyA8PCA2KTtcbiAgICAgICAgICAgICAgaWYgKHYgPCAweDEwMDAwIHx8IHYgPiAweDEwZmZmZikgdiA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2IDwgNCkgeyAvLyBJbnZhbGlkIHNlcXVlbmNlXG4gICAgICBpIC09IHY7XG4gICAgICB0ICs9IFwiXFx1ZmZmZFwiO1xuICAgIH0gZWxzZSBpZiAodiA+IDB4ZmZmZilcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ3YzAgKyAodiA+PiAxMCksIDB4ZGMwMCArICh2ICYgMHgzRkYpKVxuICAgIGVsc2VcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2KTtcbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29faXNfYXNjaWlcbmZ1bmN0aW9uIGpzb29faXNfYXNjaWkgKHMpIHtcbiAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBnZXRzIGJldHRlciBhdCBhcm91bmQgdGhpcyBwb2ludCBmb3IgYWxsIGJyb3dzZXJzXG4gIGlmIChzLmxlbmd0aCA8IDI0KSB7XG4gICAgLy8gU3BpZGVybW9ua2V5IGdldHMgbXVjaCBzbG93ZXIgd2hlbiBzLmxlbmd0aCA+PSAyNCAob24gNjQgYml0IGFyY2hzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykgaWYgKHMuY2hhckNvZGVBdChpKSA+IDEyNykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2VcbiAgICByZXR1cm4gIS9bXlxceDAwLVxceDdmXS8udGVzdChzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSkge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGlmIChpID49IHMuYy5sZW5ndGgpIHJldHVybiAwO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYy5jaGFyQ29kZUF0KGkpO1xuICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgcmV0dXJuIHMuY1tpXVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgLy8gVGhlIE9DYW1sIGNvbXBpbGVyIHVzZXMgQ2hhci51bnNhZmVfY2hyIG9uIGludGVnZXJzIGxhcmdlciB0aGFuIDI1NSFcbiAgYyAmPSAweGZmO1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIHtcbiAgICBpZiAoaSA9PSBzLmMubGVuZ3RoKSB7XG4gICAgICBzLmMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoYyk7XG4gICAgICBpZiAoaSArIDEgPT0gcy5sKSBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpO1xuICB9XG4gIHMuY1tpXSA9IGM7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAzKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gNykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjIgPSAweEZGICYgaTE2ID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMTY7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDE2XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQxNlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MTYocyxpLGkxNil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMil7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGI0ID0gMHhGRiAmIGkzMiA+PiAyNCxcbiAgICAgIGIzID0gMHhGRiAmIGkzMiA+PiAxNixcbiAgICAgIGIyID0gMHhGRiAmIGkzMiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTMyO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMiwgYjMpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAzLCBiNCk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDMyKHMsaSxpMzIpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MzJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoaTY0KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDcgLSBqLCBhW2pdKTtcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDY0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyAocykge1xuICB2YXIgdGFnID0gOSAvKiBCWVRFUyB8IEFTQ0lJICovO1xuICBpZiAoIWpzb29faXNfYXNjaWkocykpXG4gICAgdGFnID0gOCAvKiBCWVRFUyB8IE5PVF9BU0NJSSAqLywgcyA9IGNhbWxfdXRmOF9vZl91dGYxNihzKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRhZywgcywgcy5sZW5ndGgpO1xufVxuXG5cbi8vUHJvdmlkZXM6IE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gTWxCeXRlcyAodGFnLCBjb250ZW50cywgbGVuZ3RoKSB7XG4gIHRoaXMudD10YWc7IHRoaXMuYz1jb250ZW50czsgdGhpcy5sPWxlbmd0aDtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgc3dpdGNoICh0aGlzLnQpIHtcbiAgY2FzZSA5OiAvKkJZVEVTIHwgQVNDSUkqL1xuICAgIHJldHVybiB0aGlzLmM7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyh0aGlzKTtcbiAgY2FzZSAwOiAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICBpZiAoanNvb19pc19hc2NpaSh0aGlzLmMpKSB7XG4gICAgICB0aGlzLnQgPSA5OyAvKkJZVEVTIHwgQVNDSUkqL1xuICAgICAgcmV0dXJuIHRoaXMuYztcbiAgICB9XG4gICAgdGhpcy50ID0gODsgLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gIGNhc2UgODogLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgfVxufTtcbk1sQnl0ZXMucHJvdG90eXBlLnRvVXRmMTYgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIHIgPSB0aGlzLnRvU3RyaW5nKCk7XG4gIGlmKHRoaXMudCA9PSA5KSByZXR1cm4gclxuICByZXR1cm4gY2FtbF91dGYxNl9vZl91dGY4KHIpO1xufVxuTWxCeXRlcy5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIGNvbnRlbnQgPSB0aGlzLnQgPT0gNCA/IHRoaXMuYy5zbGljZSgpIDogdGhpcy5jO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGhpcy50LGNvbnRlbnQsdGhpcy5sKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQllURVMgKi9cbiAgaWYgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8pXG4gICAgcy5jICs9IGNhbWxfc3RyX3JlcGVhdChzLmwgLSBzLmMubGVuZ3RoLCAnXFwwJylcbiAgZWxzZVxuICAgIHMuYyA9IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAocy5jLCAwLCBzLmMubGVuZ3RoKTtcbiAgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEFSUkFZICovXG4gIHZhciBhID0gbmV3IFVpbnQ4QXJyYXkocy5sKTtcbiAgdmFyIGIgPSBzLmMsIGwgPSBiLmxlbmd0aCwgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gYi5jaGFyQ29kZUF0KGkpO1xuICBmb3IgKGwgPSBzLmw7IGkgPCBsOyBpKyspIGFbaV0gPSAwO1xuICBzLmMgPSBhO1xuICBzLnQgPSA0OyAvKiBBUlJBWSAqL1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMgKHMpIHtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkocyk7XG4gIHJldHVybiBzLmM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZyAocykge1xuICB2YXIgbCA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsaSk7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBpZihsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJ5dGVzLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9hcnJheSAoYSkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoYSwwLGEubGVuZ3RoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGEpIHtcbiAgaWYoISAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgYSA9IG5ldyBVaW50OEFycmF5KGEpO1xuICB9XG4gIHJldHVybiBuZXcgTWxCeXRlcyg0LGEsYS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2NvbXBhcmUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA9PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczIsczEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMyLHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vQWxpYXM6IGNhbWxfZmlsbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmlsbF9ieXRlcyhzLCBpLCBsLCBjKSB7XG4gIGlmIChsID4gMCkge1xuICAgIGlmIChpID09IDAgJiYgKGwgPj0gcy5sIHx8IChzLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGwgPj0gcy5jLmxlbmd0aCkpKSB7XG4gICAgICBpZiAoYyA9PSAwKSB7XG4gICAgICAgIHMuYyA9IFwiXCI7XG4gICAgICAgIHMudCA9IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuYyA9IGNhbWxfc3RyX3JlcGVhdCAobCwgU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgIHMudCA9IChsID09IHMubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSBzLmNbaV0gPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ibGl0X2J5dGVzKHMxLCBpMSwgczIsIGkyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgaWYgKChpMiA9PSAwKSAmJlxuICAgICAgKGxlbiA+PSBzMi5sIHx8IChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsZW4gPj0gczIuYy5sZW5ndGgpKSkge1xuICAgIHMyLmMgPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIGlmIChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBpMiA9PSBzMi5jLmxlbmd0aCkge1xuICAgIHMyLmMgKz0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSB7XG4gICAgaWYgKHMyLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMyKTtcbiAgICB2YXIgYzEgPSBzMS5jLCBjMiA9IHMyLmM7XG4gICAgaWYgKHMxLnQgPT0gNCAvKiBBUlJBWSAqLykge1xuICAgICAgaWYgKGkyIDw9IGkxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsID0gTWF0aC5taW4gKGxlbiwgYzEubGVuZ3RoIC0gaTEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGMyIFtpMiArIGldID0gYzEuY2hhckNvZGVBdChpMSArIGkpO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ibGl0X3N0cmluZyhhLGIsYyxkLGUpIHtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGEpLGIsYyxkLGUpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19sZW5ndGgocykgeyByZXR1cm4gcy5sIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBzLmNoYXJDb2RlQXQoaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfdW5zYWZlX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBzLmxlbmd0aFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/LTE6KHMxID4gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDw9IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykge1xuICAocy50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocy5jKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHgpIHsgcmV0dXJuIHggfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpIHtcbiAgaWYoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gcztcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIGlmIChqc29vX2lzX2FzY2lpKHMpKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpXG4gIGVsc2UgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF91dGY4X29mX3V0ZjE2KHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocykgeyByZXR1cm4gbmV3IE1sQnl0ZXMoMCxzLHMubGVuZ3RoKTsgfVxuXG5cbi8vIFRoZSBzZWN0aW9uIGJlbG93IHNob3VsZCBiZSB1c2VkIHdoZW4gdXNlLWpzLXN0cmluZz1mYWxzZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLGksYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2NvbXBhcmVcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZXF1YWwoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7IHJldHVybiBzIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgKHMudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBzLmMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpe1xuICByZXR1cm4gcy50b1V0ZjE2KClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nKHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2lzX21sX2J5dGVzKHMpIHtcbiAgcmV0dXJuIChzIGluc3RhbmNlb2YgTWxCeXRlcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19jb250ZW50KHMpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYztcbiAgY2FzZSA0OlxuICAgIHJldHVybiBzLmNcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaVxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgJiYgIS9bXlxceDAwLVxceGZmXS8udGVzdChzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2lzX21sX2J5dGVzKHMpO1xufVxuXG4vLyBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBkZXByZWNhdGVkXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9uZXdfc3RyaW5nIChzKSB7IHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdG9fanNfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfdG9fanNfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc190b19zdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHMpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9zdHJpbmcoeCkgeyByZXR1cm4gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoeCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX2J5dGVzKHgpIHsgcmV0dXJuIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoeCkgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9SYWlzZSBleGNlcHRpb25cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2NvbnN0YW50ICh0YWcpIHsgdGhyb3cgdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcgKGNvbnN0LCBtdXRhYmxlKVxuLy9SZXF1aXJlczogY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGFyZykgeyB0aHJvdyBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UoWzAsIHRhZywgYXJnXSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX2FyZ3MgKGNvbnN0LCBtdXRhYmxlKVxuLy9SZXF1aXJlczogY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJncyAodGFnLCBhcmdzKSB7IHRocm93IGNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZShbMCwgdGFnXS5jb25jYXQoYXJncykpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKHRhZywgbXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhtc2cpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYWlsd2l0aCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ZhaWx3aXRoIChtc2cpIHtcbiAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSlcbiAgICBjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmU9WzI0OCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiRmFpbHVyZVwiKSwtM107XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLCBtc2cpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuSW52YWxpZF9hcmd1bWVudCwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5FbmRfb2ZfZmlsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRGl2aXNpb25fYnlfemVybyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5Ob3RfZm91bmQpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuIChjb25zdCwgc2hhbGxvdylcbi8vSWY6ICFlZmZlY3RzXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfY2FsbF9nZW4oZiwgYXJncykge1xuICB2YXIgbiA9IChmLmwgPj0gMCk/Zi5sOihmLmwgPSBmLmxlbmd0aCk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW47XG4gIGlmIChkID09IDApXG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIGVsc2UgaWYgKGQgPCAwKSB7XG4gICAgdmFyIGcgPSBmLmFwcGx5KG51bGwsYXJncy5zbGljZSgwLG4pKTtcbiAgICBpZih0eXBlb2YgZyAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZztcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihnLGFyZ3Muc2xpY2UobikpO1xuICB9XG4gIGVsc2Uge1xuICAgIHN3aXRjaCAoZCkge1xuICAgIGNhc2UgMToge1xuICAgICAgdmFyIGcgPSBmdW5jdGlvbiAoeCl7XG4gICAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzTGVuICsgMSk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzTGVuOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgIG5hcmdzW2FyZ3NMZW5dID0geDtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgbmFyZ3MpXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgMjoge1xuICAgICAgdmFyIGcgPSBmdW5jdGlvbiAoeCwgeSl7XG4gICAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzTGVuICsgMik7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzTGVuOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgIG5hcmdzW2FyZ3NMZW5dID0geDtcbiAgICAgICAgbmFyZ3NbYXJnc0xlbiArIDFdID0geTtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgbmFyZ3MpXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHZhciBnID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHZhciBleHRyYV9hcmdzID0gKGFyZ3VtZW50cy5sZW5ndGggPT0gMCk/MTphcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgrZXh0cmFfYXJncyk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkgbmFyZ3NbYXJncy5sZW5ndGgraV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIG5hcmdzKVxuICAgICAgfTtcbiAgICB9fVxuICAgIGcubCA9IGQ7XG4gICAgcmV0dXJuIGc7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsX2dlbiAoY29uc3QsIHNoYWxsb3cpXG4vL0lmOiBlZmZlY3RzXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfY2FsbF9nZW4oZiwgYXJncykge1xuICB2YXIgbiA9IChmLmwgPj0gMCk/Zi5sOihmLmwgPSBmLmxlbmd0aCk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW47XG4gIGlmIChkID09IDApIHtcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgfSBlbHNlIGlmIChkIDwgMCkge1xuICAgIHZhciByZXN0ID0gYXJncy5zbGljZShuIC0gMSk7XG4gICAgdmFyIGsgPSBhcmdzIFthcmdzTGVuIC0gMV07XG4gICAgYXJncyA9IGFyZ3Muc2xpY2UoMCwgbik7XG4gICAgYXJnc1tuIC0gMV0gPSBmdW5jdGlvbiAoZykge1xuICAgICAgaWYgKHR5cGVvZiBnICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBrKGcpO1xuICAgICAgdmFyIGFyZ3MgPSByZXN0LnNsaWNlKCk7XG4gICAgICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSBrO1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZywgYXJncyk7IH07XG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgYXJnc0xlbi0tO1xuICAgIHZhciBrID0gYXJncyBbYXJnc0xlbl07XG4gICAgc3dpdGNoIChkKSB7XG4gICAgY2FzZSAxOiB7XG4gICAgICB2YXIgZyA9IGZ1bmN0aW9uICh4LCB5KXtcbiAgICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3NMZW4gKyAyKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgbmFyZ3NbYXJnc0xlbl0gPSB4O1xuICAgICAgICBuYXJnc1thcmdzTGVuICsgMV0gPSB5O1xuICAgICAgICByZXR1cm4gZi5hcHBseShudWxsLCBuYXJncylcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAyOiB7XG4gICAgICB2YXIgZyA9IGZ1bmN0aW9uICh4LCB5LCB6KXtcbiAgICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3NMZW4gKyAzKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgICAgbmFyZ3NbYXJnc0xlbl0gPSB4O1xuICAgICAgICBuYXJnc1thcmdzTGVuICsgMV0gPSB5O1xuICAgICAgICBuYXJnc1thcmdzTGVuICsgMl0gPSB6O1xuICAgICAgICByZXR1cm4gZi5hcHBseShudWxsLCBuYXJncylcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdmFyIGcgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgdmFyIGV4dHJhX2FyZ3MgPSAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKT8xOmFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzTGVuICsgZXh0cmFfYXJncyk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzTGVuOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKVxuICAgICAgICAgIG5hcmdzW2FyZ3NMZW4gKyBpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgbmFyZ3MpXG4gICAgICB9O1xuICAgIH19XG4gICAgZy5sID0gZCArIDE7XG4gICAgcmV0dXJuIGsoZyk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZXNcbnZhciBjYW1sX25hbWVkX3ZhbHVlcyA9IHt9O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIChjb25zdCxtdXRhYmxlKVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUobm0sdikge1xuICBjYW1sX25hbWVkX3ZhbHVlc1tjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5tKV0gPSB2O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZXNcbmZ1bmN0aW9uIGNhbWxfbmFtZWRfdmFsdWUobm0pIHtcbiAgcmV0dXJuIGNhbWxfbmFtZWRfdmFsdWVzW25tXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dsb2JhbF9kYXRhXG52YXIgY2FtbF9nbG9iYWxfZGF0YSA9IFswXTtcblxuLy9Qcm92aWRlczogY2FtbF9idWlsZF9zeW1ib2xzXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9idWlsZF9zeW1ib2xzKHRvYykge1xuICB2YXIgc3ltYjtcbiAgd2hpbGUodG9jKSB7XG4gICAgaWYoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcodG9jWzFdWzFdKSA9PSBcIlNZSlNcIikge1xuICAgICAgc3ltYiA9IHRvY1sxXVsyXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlbHNlIHRvYyA9IHRvY1syXVxuICB9XG4gIHZhciByID0ge307XG4gIGlmKHN5bWIpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgc3ltYi5sZW5ndGg7IGkrKyl7XG4gICAgICByW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHN5bWJbaV1bMV0pXSA9IHN5bWJbaV1bMl1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChjb25zdCwgc2hhbGxvdywgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX2NhbGxiYWNrLCBjYW1sX2J1aWxkX3N5bWJvbHNcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChuLCB2LCBuYW1lX29wdCkge1xuICBpZiAobmFtZV9vcHQpIHtcbiAgICB2YXIgbmFtZSA9IG5hbWVfb3B0O1xuICAgIGlmKGdsb2JhbFRoaXMudG9wbGV2ZWxSZWxvYykge1xuICAgICAgbiA9IGNhbWxfY2FsbGJhY2soZ2xvYmFsVGhpcy50b3BsZXZlbFJlbG9jLCBbbmFtZV0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYW1sX2dsb2JhbF9kYXRhLnRvYykge1xuICAgICAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuc3ltYm9scykge1xuICAgICAgICBjYW1sX2dsb2JhbF9kYXRhLnN5bWJvbHMgPSBjYW1sX2J1aWxkX3N5bWJvbHMoY2FtbF9nbG9iYWxfZGF0YS50b2MpXG4gICAgICB9XG4gICAgICB2YXIgbmlkID0gY2FtbF9nbG9iYWxfZGF0YS5zeW1ib2xzW25hbWVdXG4gICAgICBpZihuaWQgPj0gMClcbiAgICAgICAgbiA9IG5pZFxuICAgICAgZWxzZSB7XG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3JlZ2lzdGVyX2dsb2JhbDogY2Fubm90IGxvY2F0ZSBcIiArIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYW1sX2dsb2JhbF9kYXRhW24gKyAxXSA9IHY7XG4gIGlmKG5hbWVfb3B0KSBjYW1sX2dsb2JhbF9kYXRhW25hbWVfb3B0XSA9IHY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2dsb2JhbF9kYXRhIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZ2V0X2dsb2JhbF9kYXRhICgpIHsgcmV0dXJuIGNhbWxfZ2xvYmFsX2RhdGE7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pc19wcmludGFibGUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pc19wcmludGFibGUoYykgeyByZXR1cm4gKyhjID4gMzEgJiYgYyA8IDEyNyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9tYXliZV9wcmludF9zdGF0c1xuZnVuY3Rpb24gY2FtbF9tYXliZV9wcmludF9zdGF0cyh1bml0KSB7IHJldHVybiAwIH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gU3lzXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLlN5c19lcnJvciwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N5c19leGl0IChjb2RlKSB7XG4gIGlmKGdsb2JhbFRoaXMucXVpdCkgZ2xvYmFsVGhpcy5xdWl0KGNvZGUpO1xuICAvL25vZGVqc1xuICBpZihnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLmV4aXQpXG4gICAgZ2xvYmFsVGhpcy5wcm9jZXNzLmV4aXQoY29kZSk7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkZ1bmN0aW9uICdleGl0JyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuKXtcbiAgc3dpdGNoKGV4blsyXSkge1xuICBjYXNlIC04OiAvLyBNYXRjaF9mYWlsdXJlXG4gIGNhc2UgLTExOiAvLyBBc3NlcnRfZmFpbHVyZVxuICBjYXNlIC0xMjogLy8gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGVcbiAgICByZXR1cm4gMTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9leGNlcHRpb25cbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2V4Y2VwdGlvbihleG4pe1xuICB2YXIgciA9IFwiXCI7XG4gIGlmKGV4blswXSA9PSAwKSB7XG4gICAgciArPSBleG5bMV1bMV07XG4gICAgaWYoZXhuLmxlbmd0aCA9PSAzICYmIGV4blsyXVswXSA9PSAwICYmIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuWzFdKSkge1xuXG4gICAgICB2YXIgYnVja2V0ID0gZXhuWzJdO1xuICAgICAgdmFyIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gMlxuICAgICAgdmFyIGJ1Y2tldCA9IGV4bjtcbiAgICB9XG4gICAgciArPSBcIihcIjtcbiAgICBmb3IodmFyIGkgPSBzdGFydDsgaSA8IGJ1Y2tldC5sZW5ndGg7IGkgKyspe1xuICAgICAgaWYoaSA+IHN0YXJ0KSByKz1cIiwgXCI7XG4gICAgICB2YXIgdiA9IGJ1Y2tldFtpXVxuICAgICAgaWYodHlwZW9mIHYgPT0gXCJudW1iZXJcIilcbiAgICAgICAgcis9IHYudG9TdHJpbmcoKTtcbiAgICAgIGVsc2UgaWYodiBpbnN0YW5jZW9mIE1sQnl0ZXMpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHR5cGVvZiB2ID09IFwic3RyaW5nXCIpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIHIgKz0gXCJfXCI7XG4gICAgfVxuICAgIHIgKz0gXCIpXCJcbiAgfSBlbHNlIGlmIChleG5bMF0gPT0gMjQ4KXtcbiAgICByICs9IGV4blsxXVxuICB9XG4gIHJldHVybiByXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX2Zvcm1hdF9leGNlcHRpb24sIGNhbWxfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGVycil7XG4gIGlmKGVyciBpbnN0YW5jZW9mIEFycmF5ICYmIChlcnJbMF0gPT0gMCB8fCBlcnJbMF0gPT0gMjQ4KSkge1xuICAgIHZhciBoYW5kbGVyID0gY2FtbF9uYW1lZF92YWx1ZShcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIik7XG4gICAgaWYoaGFuZGxlcikgY2FtbF9jYWxsYmFjayhoYW5kbGVyLCBbZXJyLGZhbHNlXSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbXNnID0gY2FtbF9mb3JtYXRfZXhjZXB0aW9uKGVycik7XG4gICAgICB2YXIgYXRfZXhpdCA9IGNhbWxfbmFtZWRfdmFsdWUoXCJQZXJ2YXNpdmVzLmRvX2F0X2V4aXRcIik7XG4gICAgICBpZihhdF9leGl0KSBjYW1sX2NhbGxiYWNrKGF0X2V4aXQsIFswXSk7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiBcIiArIG1zZyk7XG4gICAgICBpZihlcnIuanNfZXJyb3IpIHRocm93IGVyci5qc19lcnJvcjtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfc3RhdGljX2VudlxuZnVuY3Rpb24gY2FtbF9zZXRfc3RhdGljX2VudihrLHYpe1xuICBpZighZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnYpXG4gICAgZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnYgPSB7fVxuICBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudltrXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX3N5c19nZXRlbnYgKGNvbnN0KVxuZnVuY3Rpb24ganNvb19zeXNfZ2V0ZW52KG4pIHtcbiAgdmFyIHByb2Nlc3MgPSBnbG9iYWxUaGlzLnByb2Nlc3M7XG4gIC8vbm9kZWpzIGVudlxuICBpZihwcm9jZXNzXG4gICAgICYmIHByb2Nlc3MuZW52XG4gICAgICYmIHByb2Nlc3MuZW52W25dICE9IHVuZGVmaW5lZClcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnZbbl07XG4gIGlmKGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52XG4gICAgICYmIGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W25dKVxuICAgIHJldHVybiBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudltuXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRlbnYgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19zeXNfZ2V0ZW52XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpIHtcbiAgdmFyIHIgPSBqc29vX3N5c19nZXRlbnYoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSkpO1xuICBpZihyID09PSB1bmRlZmluZWQpXG4gICAgY2FtbF9yYWlzZV9ub3RfZm91bmQgKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52XG4vL1JlcXVpcmVzOiBjYW1sX3N5c19nZXRlbnZcbmZ1bmN0aW9uIGNhbWxfc3lzX3Vuc2FmZV9nZXRlbnYobmFtZSl7XG4gIHJldHVybiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9hcmd2ID0gKChmdW5jdGlvbiAoKSB7XG4gIHZhciBwcm9jZXNzID0gZ2xvYmFsVGhpcy5wcm9jZXNzO1xuICB2YXIgbWFpbiA9IFwiYS5vdXRcIjtcbiAgdmFyIGFyZ3MgPSBbXVxuXG4gIGlmKHByb2Nlc3NcbiAgICAgJiYgcHJvY2Vzcy5hcmd2XG4gICAgICYmIHByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGFyZ3YgPSBwcm9jZXNzLmFyZ3ZcbiAgICAvL25vZGVqc1xuICAgIG1haW4gPSBhcmd2WzFdO1xuICAgIGFyZ3MgPSBhcmd2LnNsaWNlKDIpO1xuICB9XG5cbiAgdmFyIHAgPSBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhtYWluKTtcbiAgdmFyIGFyZ3MyID0gWzAsIHBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKylcbiAgICBhcmdzMi5wdXNoKGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGFyZ3NbaV0pKTtcbiAgcmV0dXJuIGFyZ3MyO1xufSkoKSlcblxuLy9Qcm92aWRlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxudmFyIGNhbWxfZXhlY3V0YWJsZV9uYW1lID0gY2FtbF9hcmd2WzFdXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldF9hcmd2IChhKSB7XG4gIHJldHVybiBbMCwgY2FtbF9hcmd2WzFdLCBjYW1sX2FyZ3ZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX2FyZ3YgKGEpIHtcbiAgcmV0dXJuIGNhbWxfYXJndjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfbW9kaWZ5X2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfbW9kaWZ5X2FyZ3YoYXJnKXtcbiAgY2FtbF9hcmd2ID0gYXJnO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuZnVuY3Rpb24gY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lKGEpe1xuICByZXR1cm4gY2FtbF9leGVjdXRhYmxlX25hbWVcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZChjbWQpe1xuICB2YXIgY21kID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoY21kKTtcbiAgaWYgKHR5cGVvZiByZXF1aXJlICE9IFwidW5kZWZpbmVkXCIpe1xuICAgIHZhciBjaGlsZF9wcm9jZXNzID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuICAgIGlmKGNoaWxkX3Byb2Nlc3MgJiYgY2hpbGRfcHJvY2Vzcy5leGVjU3luYylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNoaWxkX3Byb2Nlc3MuZXhlY1N5bmMoY21kLHtzdGRpbzogJ2luaGVyaXQnfSk7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gIH1cbiAgZWxzZSByZXR1cm4gMTI3O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kKGNtZCl7XG4gIHJldHVybiAxMjc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWUgbXV0YWJsZVxudmFyIGNhbWxfaW5pdGlhbF90aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAqIDAuMDAxO1xuZnVuY3Rpb24gY2FtbF9zeXNfdGltZSAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICByZXR1cm4gbm93ICogMC4wMDEgLSBjYW1sX2luaXRpYWxfdGltZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuXG4vL1JlcXVpcmVzOiBjYW1sX3N5c190aW1lXG5mdW5jdGlvbiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4oYikge1xuICByZXR1cm4gY2FtbF9zeXNfdGltZSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yYW5kb21fc2VlZCBtdXRhYmxlXG4vL1RoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gYW4gYXJyYXkgc2luY2UgT0NhbWwgNC4wLi4uXG5mdW5jdGlvbiBjYW1sX3N5c19yYW5kb21fc2VlZCAoKSB7XG4gIGlmIChnbG9iYWxUaGlzLmNyeXB0bykge1xuICAgICBpZiAoZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgdmFyIGEgPSBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IEludDMyQXJyYXkoNCkpO1xuICAgICAgIHJldHVybiBbMCwgYVswXSwgYVsxXSwgYVsyXSwgYVszXV07XG4gICAgIH0gZWxzZSBpZiAoZ2xvYmFsVGhpcy5jcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICAgICB2YXIgYSA9IG5ldyBJbnQzMkFycmF5KGdsb2JhbFRoaXMuY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS5idWZmZXIpO1xuICAgICAgIHJldHVybiBbMCwgYVswXSwgYVsxXSwgYVsyXSwgYVszXV07XG4gICAgIH1cbiAgfVxuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgdmFyIHggPSBub3deMHhmZmZmZmZmZipNYXRoLnJhbmRvbSgpO1xuICByZXR1cm4gWzAseF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfaW50X3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSBjb25zdFxuLy8gbWF4X2ludCAvIDQgc28gdGhhdCB0aGUgZm9sbG93aW5nIGRvZXMgbm90IG92ZXJmbG93XG4vL2xldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMTs7XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplICgpIHsgcmV0dXJuICgweDdGRkZGRkZGLzQpIHwgMDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCAoKSB7IHJldHVybiBvc190eXBlID09IFwiVW5peFwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyICgpIHsgcmV0dXJuIG9zX3R5cGUgPT0gXCJXaW4zMlwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gKCkgeyByZXR1cm4gb3NfdHlwZSA9PSBcIkN5Z3dpblwiID8gMSA6IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJqc19vZl9vY2FtbFwiKV07XG59XG5cbi8vUHJvdmlkZXM6IG9zX3R5cGVcbnZhciBvc190eXBlID0gKGdsb2JhbFRoaXMucHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtICYmXG4gICAgICAgICAgICAgICBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gPT0gXCJ3aW4zMlwiKSA/IFwiQ3lnd2luXCIgOiBcIlVuaXhcIjtcblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfY29uZmlnIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfY29uZmlnICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG9zX3R5cGUpLCAzMiwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzYXR0eVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNhdHR5KF9jaGFuKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfdmFyaWFudFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3ZhcmlhbnQoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyKCl7cmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xudmFyIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyAoYm9vbCkge1xuICBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSBib29sO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3J1bnRpbWVfd2FybmluZ3M7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9lbmFibGVkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lKF9jaGFubmVsKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJTcGFjZXRpbWUgcHJvZmlsaW5nIG9ubHkgd29ya3MgZm9yIG5hdGl2ZSBjb2RlXCIpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX3JlZ3VsYXJfZmlsZVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzX3JlZ3VsYXJfZmlsZShuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS5pc0ZpbGUocm9vdC5yZXN0KTtcbn1cbi8vQWx3YXlzXG4vL1JlcXVpcmVzOiBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlcigpIHtcbiAgdmFyIHByb2Nlc3MgPSBnbG9iYWxUaGlzLnByb2Nlc3M7XG4gIGlmKHByb2Nlc3MgJiYgcHJvY2Vzcy5vbikge1xuICAgIHByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gKGVyciwgb3JpZ2luKSB7XG4gICAgICBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihlcnIpO1xuICAgICAgcHJvY2Vzcy5leGl0ICgyKTtcbiAgICB9KVxuICB9XG4gIGVsc2UgaWYoZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKXtcbiAgICBnbG9iYWxUaGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgaWYoZXZlbnQuZXJyb3Ipe1xuICAgICAgICBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihldmVudC5lcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNhbWxfc2V0dXBfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIoKTtcbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cblxuLy9Qcm92aWRlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWdcbi8vUmVxdWlyZXM6IGpzb29fc3lzX2dldGVudlxudmFyIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnID0gRkxBRyhcIndpdGgtanMtZXJyb3JcIik7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciByID0ganNvb19zeXNfZ2V0ZW52KFwiT0NBTUxSVU5QQVJBTVwiKVxuICBpZihyICE9PSB1bmRlZmluZWQpe1xuICAgIHZhciBsID0gci5zcGxpdChcIixcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGwubGVuZ3RoOyBpKyspe1xuICAgICAgaWYobFtpXSA9PSBcImJcIikgeyBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZyA9IDE7IGJyZWFrIH1cbiAgICAgIGVsc2UgaWYgKGxbaV0uc3RhcnRzV2l0aChcImI9XCIpKSB7XG4gICAgICAgIGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnID0gKyhsW2ldLnNsaWNlKDIpKX1cbiAgICAgIGVsc2UgY29udGludWU7XG4gICAgfVxuICB9XG59KSAoKVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9iYWNrdHJhY2Vfc3RhdHVzXG4vL1JlcXVpcmVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZ1xuZnVuY3Rpb24gY2FtbF9iYWNrdHJhY2Vfc3RhdHVzIChfdW5pdCkgeyByZXR1cm4gY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWcgPyAxIDogMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZV9mbGFnXG5mdW5jdGlvbiBjYW1sX3JlY29yZF9iYWNrdHJhY2UgKGIpIHsgY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWcgPSBiOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90ICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdDogaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZShleG4sIGJ0KSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayAoKSB7IHJldHVybiBbMF07IH1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCgpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3B1cmVfZXhwciBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc19wdXJlX2V4cHIgKGYpIHsgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgWzBdKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3NldCAobXV0YWJsZSwgY29uc3QsIG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2pzX3NldChvLGYsdikgeyBvW2ZdPXY7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldCAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2dldChvLGYpIHsgcmV0dXJuIG9bZl07IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZGVsZXRlIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZGVsZXRlKG8sZikgeyBkZWxldGUgb1tmXTsgcmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaW5zdGFuY2VvZiAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19pbnN0YW5jZW9mKG8sYykgeyByZXR1cm4gKG8gaW5zdGFuY2VvZiBjKSA/IDEgOiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdHlwZW9mIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdHlwZW9mKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfc3RhY2tfZGVwdGhcbi8vSWY6IGVmZmVjdHNcbnZhciBjYW1sX3N0YWNrX2RlcHRoID0gMDtcblxuLy9Qcm92aWRlczpjYW1sX3N0YWNrX2NoZWNrX2RlcHRoXG4vL0lmOiBlZmZlY3RzXG4vL1JlcXVpcmVzOmNhbWxfc3RhY2tfZGVwdGhcbmZ1bmN0aW9uIGNhbWxfc3RhY2tfY2hlY2tfZGVwdGgoKSB7XG4gICAgcmV0dXJuIC0tY2FtbF9zdGFja19kZXB0aCA+IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbGJhY2tcbi8vSWY6ICFlZmZlY3RzXG4vL1JlcXVpcmVzOmNhbWxfY2FsbF9nZW5cbnZhciBjYW1sX2NhbGxiYWNrID0gY2FtbF9jYWxsX2dlbjtcblxuLy9Qcm92aWRlczogY2FtbF9jYWxsYmFja1xuLy9JZjogZWZmZWN0c1xuLy9SZXF1aXJlczpjYW1sX3N0YWNrX2RlcHRoLCBjYW1sX2NhbGxfZ2VuLCBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFjaywgY2FtbF93cmFwX2V4Y2VwdGlvbiwgY2FtbF9yZXN1bWVfc3RhY2ssIGNhbWxfZnJlc2hfb29faWQsIGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfY2FsbGJhY2soZixhcmdzKSB7XG4gIGZ1bmN0aW9uIHVuY2F1Z2h0X2VmZmVjdF9oYW5kbGVyKGVmZixrLG1zKSB7XG4gICAgLy8gUmVzdW1lcyB0aGUgY29udGludWF0aW9uIGsgYnkgcmFpc2luZyBleGNlcHRpb24gVW5oYW5kbGVkLlxuICAgIGNhbWxfcmVzdW1lX3N0YWNrKGtbMV0sbXMpO1xuICAgIHZhciBleG4gPSBjYW1sX25hbWVkX3ZhbHVlKFwiRWZmZWN0LlVuaGFuZGxlZFwiKTtcbiAgICBpZihleG4pIGNhbWxfcmFpc2Vfd2l0aF9hcmcoZXhuLCBlZmYpO1xuICAgIGVsc2Uge1xuICAgICAgZXhuID0gWzI0OCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiRWZmZWN0LlVuaGFuZGxlZFwiKSwgY2FtbF9mcmVzaF9vb19pZCgwKV07XG4gICAgICBjYW1sX3JhaXNlX2NvbnN0YW50KGV4bik7XG4gICAgfVxuICB9XG4gIHZhciBzYXZlZF9zdGFja19kZXB0aCA9IGNhbWxfc3RhY2tfZGVwdGg7XG4gIHZhciBzYXZlZF9leG5fc3RhY2sgPSBjYW1sX2V4bl9zdGFjaztcbiAgdmFyIHNhdmVkX2ZpYmVyX3N0YWNrID0gY2FtbF9maWJlcl9zdGFjaztcbiAgdHJ5IHtcbiAgICBjYW1sX2V4bl9zdGFjayA9IDA7XG4gICAgY2FtbF9maWJlcl9zdGFjayA9XG4gICAgICB7aDpbMCwgMCwgMCwgdW5jYXVnaHRfZWZmZWN0X2hhbmRsZXJdLCByOntrOjAsIHg6MCwgZTowfX07XG4gICAgdmFyIHJlcyA9IHtqb29fdHJhbXA6IGYsXG4gICAgICAgICAgICAgICBqb29fYXJnczogYXJncy5jb25jYXQoZnVuY3Rpb24gKHgpe3JldHVybiB4O30pfTtcbiAgICBkbyB7XG4gICAgICBjYW1sX3N0YWNrX2RlcHRoID0gNDA7XG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSBjYW1sX2NhbGxfZ2VuKHJlcy5qb29fdHJhbXAsIHJlcy5qb29fYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIEhhbmRsZSBleGNlcHRpb24gY29taW5nIGZyb20gSmF2YVNjcmlwdCBvciBmcm9tIHRoZSBydW50aW1lLiAqL1xuICAgICAgICBpZiAoIWNhbWxfZXhuX3N0YWNrKSB0aHJvdyBlO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGNhbWxfZXhuX3N0YWNrWzFdO1xuICAgICAgICBjYW1sX2V4bl9zdGFjayA9IGNhbWxfZXhuX3N0YWNrWzJdO1xuICAgICAgICByZXMgPSB7am9vX3RyYW1wOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgam9vX2FyZ3M6IFtjYW1sX3dyYXBfZXhjZXB0aW9uKGUpXX07XG4gICAgICB9XG4gICAgfSB3aGlsZShyZXMgJiYgcmVzLmpvb19hcmdzKVxuICB9IGZpbmFsbHkge1xuICAgIGNhbWxfc3RhY2tfZGVwdGggPSBzYXZlZF9zdGFja19kZXB0aDtcbiAgICBjYW1sX2V4bl9zdGFjayA9IHNhdmVkX2V4bl9zdGFjaztcbiAgICBjYW1sX2ZpYmVyX3N0YWNrID0gc2F2ZWRfZmliZXJfc3RhY2s7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19qc1xuZnVuY3Rpb24gY2FtbF9pc19qcygpIHtcbiAgcmV0dXJuIDE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNvb19mbGFnc191c2VfanNfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzb29fZmxhZ3NfdXNlX2pzX3N0cmluZyh1bml0KXtcbiAgcmV0dXJuIEZMQUcoXCJ1c2UtanMtc3RyaW5nXCIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNvb19mbGFnc19lZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2pzb29fZmxhZ3NfZWZmZWN0cyh1bml0KXtcbiAgcmV0dXJuIEZMQUcoXCJlZmZlY3RzXCIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd3JhcF9leGNlcHRpb24gY29uc3QgKG11dGFibGUpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLGNhbWxfbmFtZWRfdmFsdWVcbmZ1bmN0aW9uIGNhbWxfd3JhcF9leGNlcHRpb24oZSkge1xuICBpZiAoRkxBRyhcImV4Y3dyYXBcIikpIHtcbiAgICBpZihlIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBlO1xuICAgIHZhciBleG47XG4gICAgLy9TdGFja19vdmVyZmxvdzogY2hyb21lLCBzYWZhcmlcbiAgICBpZihnbG9iYWxUaGlzLlJhbmdlRXJyb3JcbiAgICAgICAmJiBlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5SYW5nZUVycm9yXG4gICAgICAgJiYgZS5tZXNzYWdlXG4gICAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC9tYXhpbXVtIGNhbGwgc3RhY2svaSkpXG4gICAgICBleG4gPSBjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93O1xuICAgIC8vU3RhY2tfb3ZlcmZsb3c6IGZpcmVmb3hcbiAgICBlbHNlIGlmKGdsb2JhbFRoaXMuSW50ZXJuYWxFcnJvclxuICAgICAgICYmIGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkludGVybmFsRXJyb3JcbiAgICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL3RvbyBtdWNoIHJlY3Vyc2lvbi9pKSlcbiAgICAgIGV4biA9IGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3c7XG4gICAgLy9XcmFwIEVycm9yIGluIEpzLkVycm9yIGV4Y2VwdGlvblxuICAgIGVsc2UgaWYoZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRXJyb3IgJiYgY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIikpXG4gICAgICBleG4gPSBbMCxjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSxlXTtcbiAgICBlbHNlXG4gICAgICAvL2ZhbGxiYWNrOiB3cmFwcGVkIGluIEZhaWx1cmVcbiAgICAgIGV4biA9IFswLGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoU3RyaW5nKGUpKV07XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yIGF0IGhhbmQsIGxldCdzIHVzZSBpdC5cbiAgICBpZiAoZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRXJyb3IpXG4gICAgICBleG4uanNfZXJyb3IgPSBlO1xuICAgIHJldHVybiBleG47XG4gIH0gZWxzZVxuICAgIHJldHVybiBlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VfZmxhZ1xuZnVuY3Rpb24gY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlKGV4biwgZm9yY2UpIHtcbiAgaWYoY2FtbF9yZWNvcmRfYmFja3RyYWNlX2ZsYWcpXG4gICAgcmV0dXJuIGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlKGV4biwgZm9yY2UpO1xuICBlbHNlIHJldHVybiBleG5cbn1cblxuLy8gRXhwZXJpbWVudGFsXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UoZXhuLCBmb3JjZSkge1xuICAvL25ldmVyIHJlcmFpc2UgZm9yIGNvbnN0YW50IGV4blxuICBpZighZXhuLmpzX2Vycm9yIHx8IGZvcmNlIHx8IGV4blswXSA9PSAyNDgpIGV4bi5qc19lcnJvciA9IG5ldyBnbG9iYWxUaGlzLkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb3B0aW9uX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZihleG4uanNfZXJyb3IpIHsgcmV0dXJuIFswLCBleG4uanNfZXJyb3JdOyB9XG4gIHJldHVybiAwO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Jvb2woeCkgeyByZXR1cm4gISF4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19ib29sKHgpIHsgcmV0dXJuICt4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fZmxvYXQgY29uc3QgKGNvbnN0KVxuLy9BbGlhczogY2FtbF9qc19mcm9tX2ludDMyXG4vL0FsaWFzOiBjYW1sX2pzX2Zyb21fbmF0aXZlaW50XG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9faW50MzIgY29uc3QgKGNvbnN0KVxuLy9BbGlhczogY2FtbF9qc190b19uYXRpdmVpbnRcbmZ1bmN0aW9uIGNhbWxfanNfdG9faW50MzIoeCkgeyByZXR1cm4geHwwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2FycmF5KGEpIHtcbiAgcmV0dXJuIGEuc2xpY2UoMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2FycmF5KGEpIHtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGJbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGxlbjtpKyspIGJbaSsxXSA9IGFbaV07XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkoYSl7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBpPWEubGVuZ3RoIC0gMTsgaT49MDsgaS0tKXtcbiAgICB2YXIgZSA9IGFbaV07XG4gICAgbCA9IFswLGUsbF07XG4gIH1cbiAgcmV0dXJuIGxcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X3RvX2pzX2FycmF5IGNvbnN0IChtdXRhYmxlKVxuZnVuY3Rpb24gY2FtbF9saXN0X3RvX2pzX2FycmF5KGwpe1xuICB2YXIgYSA9IFtdO1xuICBmb3IoOyBsICE9PSAwOyBsID0gbFsyXSkge1xuICAgIGEucHVzaChsWzFdKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc192YXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdmFyKHgpIHtcbiAgdmFyIHggPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh4KTtcbiAgLy9DaGVja3MgdGhhdCB4IGhhcyB0aGUgZm9ybSBpZGVudFsuaWRlbnRdKlxuICBpZigheC5tYXRjaCgvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKihcXC5bYS16QS1aXyRdW2EtekEtWl8kMC05XSopKiQvKSl7XG4gICAgY29uc29sZS5lcnJvcihcImNhbWxfanNfdmFyOiBcXFwiXCIgKyB4ICsgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIEphdmFTY3JpcHQgdmFyaWFibGUuIGNvbnRpbnVpbmcgLi5cIik7XG4gICAgLy9jb25zb2xlLmVycm9yKFwiSnMuVW5zYWZlLmV2YWxfc3RyaW5nXCIpXG4gIH1cbiAgcmV0dXJuIGV2YWwoeCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2NhbGwgKGNvbnN0LCBtdXRhYmxlLCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2NhbGwoZiwgbywgYXJncykgeyByZXR1cm4gZi5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bl9jYWxsIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19mdW5fY2FsbChmLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gZigpO1xuICBjYXNlIDI6IHJldHVybiBmIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gZiAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICByZXR1cm4gZi5hcHBseShudWxsLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19tZXRoX2NhbGwgKG11dGFibGUsIGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19tZXRoX2NhbGwobywgZiwgYXJncykge1xuICByZXR1cm4gb1tjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhmKV0uYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbmV3IChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19uZXcoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgY2FtbF9qc19mcm9tX2FycmF5KGEpKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX29qc19uZXdfYXJyIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9vanNfbmV3X2FycihjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAwOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjIChhWzBdKTtcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBhKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihsZW4gPiAwKXtcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzID0gW3VuZGVmaW5lZF07XG4gICAgfVxuICAgIHZhciByZXMgPSBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpO1xuICAgIHJldHVybiAocmVzIGluc3RhbmNlb2YgRnVuY3Rpb24pP2NhbWxfanNfd3JhcF9jYWxsYmFjayhyZXMpOnJlcztcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBbYXJnc10pO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyaXR5KTtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCwgYXJpdHkpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFjaywgY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX3Vuc2FmZShmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGNhbWxfanNfZnVuY3Rpb25fYXJpdHkoZik7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpOyB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrLCBjYW1sX2pzX3dyYXBfY2FsbGJhY2tcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgdmFyIHJlcyA9IGNhbWxfY2FsbGJhY2soZixhcmdzKTtcbiAgICByZXR1cm4gKHJlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uKT9jYW1sX2pzX3dyYXBfY2FsbGJhY2socmVzKTpyZXM7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsYmFjayhmLFt0aGlzLGFyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSArIDEpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbGJhY2soZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsYmFjaywgY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKSAtIDE7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxiYWNrKGYsIGFyZ3MpOyB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuY3Rpb25fYXJpdHlcbi8vSWY6ICFlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX2pzX2Z1bmN0aW9uX2FyaXR5KGYpIHtcbiAgcmV0dXJuIChmLmwgPj0gMCk/Zi5sOihmLmwgPSBmLmxlbmd0aClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5jdGlvbl9hcml0eVxuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9qc19mdW5jdGlvbl9hcml0eShmKSB7XG4gIC8vIEZ1bmN0aW9ucyBoYXZlIGFuIGFkZGl0aW9uYWwgY29udGludWF0aW9uIHBhcmFtZXRlci4gVGhpcyBzaG91bGRcbiAgLy8gbm90IGJlIHZpc2libGUgd2hlbiBjYWxsaW5nIHRoZW0gZnJvbSBKYXZhU2NyaXB0XG4gIHJldHVybiAoKGYubCA+PSAwKT9mLmw6KGYubCA9IGYubGVuZ3RoKSkgLSAxXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZXF1YWxzICh4LCB5KSB7IHJldHVybiArKHggPT0geSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zdHJpY3RfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc3RyaWN0X2VxdWFscyAoeCwgeSkgeyByZXR1cm4gKyh4ID09PSB5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V2YWxfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V2YWxfc3RyaW5nIChzKSB7cmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19leHByIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V4cHIocykge1xuICBjb25zb2xlLmVycm9yKFwiY2FtbF9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cXG5cIik7XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcHVyZV9qc19leHByIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3B1cmVfanNfZXhwciAocyl7XG4gIGNvbnNvbGUuZXJyb3IoXCJjYW1sX3B1cmVfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29iamVjdCAob2JqZWN0X2xpdGVyYWwpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19vYmplY3QgKGEpIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBhW2ldO1xuICAgIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocFsxXSldID0gcFsyXTtcbiAgfVxuICByZXR1cm4gbztcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRm9ybWF0XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZm9ybWF0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZm9ybWF0IChmbXQpIHtcbiAgZm10ID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpO1xuICB2YXIgbGVuID0gZm10Lmxlbmd0aDtcbiAgaWYgKGxlbiA+IDMxKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJmb3JtYXRfaW50OiBmb3JtYXQgdG9vIGxvbmdcIik7XG4gIHZhciBmID1cbiAgICAgIHsganVzdGlmeTonKycsIHNpZ25zdHlsZTonLScsIGZpbGxlcjonICcsIGFsdGVybmF0ZTpmYWxzZSxcbiAgICAgICAgYmFzZTowLCBzaWduZWRjb252OmZhbHNlLCB3aWR0aDowLCB1cHBlcmNhc2U6ZmFsc2UsXG4gICAgICAgIHNpZ246MSwgcHJlYzotMSwgY29udjonZicgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gZm10LmNoYXJBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlICctJzpcbiAgICAgIGYuanVzdGlmeSA9ICctJzsgYnJlYWs7XG4gICAgY2FzZSAnKyc6IGNhc2UgJyAnOlxuICAgICAgZi5zaWduc3R5bGUgPSBjOyBicmVhaztcbiAgICBjYXNlICcwJzpcbiAgICAgIGYuZmlsbGVyID0gJzAnOyBicmVhaztcbiAgICBjYXNlICcjJzpcbiAgICAgIGYuYWx0ZXJuYXRlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnMSc6IGNhc2UgJzInOiBjYXNlICczJzogY2FzZSAnNCc6IGNhc2UgJzUnOlxuICAgIGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgZi53aWR0aCA9IDA7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYud2lkdGggPSBmLndpZHRoICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJy4nOlxuICAgICAgZi5wcmVjID0gMDtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi5wcmVjID0gZi5wcmVjICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICBjYXNlICdkJzogY2FzZSAnaSc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3UnOlxuICAgICAgZi5iYXNlID0gMTA7IGJyZWFrO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgZi5iYXNlID0gMTY7IGJyZWFrO1xuICAgIGNhc2UgJ1gnOlxuICAgICAgZi5iYXNlID0gMTY7IGYudXBwZXJjYXNlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnbyc6XG4gICAgICBmLmJhc2UgPSA4OyBicmVhaztcbiAgICBjYXNlICdlJzogY2FzZSAnZic6IGNhc2UgJ2cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi5jb252ID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnRSc6IGNhc2UgJ0YnOiBjYXNlICdHJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYudXBwZXJjYXNlID0gdHJ1ZTtcbiAgICAgIGYuY29udiA9IGMudG9Mb3dlckNhc2UgKCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCByYXdidWZmZXIpIHtcbiAgaWYgKGYudXBwZXJjYXNlKSByYXdidWZmZXIgPSByYXdidWZmZXIudG9VcHBlckNhc2UoKTtcbiAgdmFyIGxlbiA9IHJhd2J1ZmZlci5sZW5ndGg7XG4gIC8qIEFkanVzdCBsZW4gdG8gcmVmbGVjdCBhZGRpdGlvbmFsIGNoYXJzIChzaWduLCBldGMpICovXG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgKGYuc2lnbiA8IDAgfHwgZi5zaWduc3R5bGUgIT0gJy0nKSkgbGVuKys7XG4gIGlmIChmLmFsdGVybmF0ZSkge1xuICAgIGlmIChmLmJhc2UgPT0gOCkgbGVuICs9IDE7XG4gICAgaWYgKGYuYmFzZSA9PSAxNikgbGVuICs9IDI7XG4gIH1cbiAgLyogRG8gdGhlIGZvcm1hdHRpbmcgKi9cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcgJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICBpZiAoZi5zaWduZWRjb252KSB7XG4gICAgaWYgKGYuc2lnbiA8IDApIGJ1ZmZlciArPSAnLSc7XG4gICAgZWxzZSBpZiAoZi5zaWduc3R5bGUgIT0gJy0nKSBidWZmZXIgKz0gZi5zaWduc3R5bGU7XG4gIH1cbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSA4KSBidWZmZXIgKz0gJzAnO1xuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDE2KSBidWZmZXIgKz0gZi51cHBlcmNhc2U/XCIwWFwiOlwiMHhcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJzAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnMCc7XG4gIGJ1ZmZlciArPSByYXdidWZmZXI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJy0nKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGJ1ZmZlcik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19mbG9vcl9sb2cyXG52YXIgbG9nMl9vayA9IE1hdGgubG9nMiAmJiBNYXRoLmxvZzIoMS4xMjM1NTgyMDkyODg5NDc0RSszMDcpID09IDEwMjBcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gIGlmKGxvZzJfb2spIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nMih4KSlcbiAgdmFyIGkgPSAwO1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLUluZmluaXR5O1xuICBpZih4Pj0xKSB7d2hpbGUgKHg+PTIpIHt4Lz0yOyBpKyt9IH1cbiAgZWxzZSB7d2hpbGUgKHggPCAxKSB7eCo9MjsgaS0tfSB9O1xuICByZXR1cm4gaTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSlcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgxLCAwLCAweDdmZjApO1xuICAgIGlmICh4ID4gMClcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweDdmZjApXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4ZmZmMClcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzB4ODAwMDooeD49MCk/MDoweDgwMDA7XG4gIGlmIChzaWduKSB4ID0gLXg7XG4gIC8vIEludDY0LmJpdHNfb2ZfZmxvYXQgMS4xMjM1NTgyMDkyODg5NDc0RSszMDcgPSAweDdmYjAwMDAwMDAwMDAwMDBMXG4gIC8vIHVzaW5nIE1hdGguTE9HMkUqTWF0aC5sb2coeCkgaW4gcGxhY2Ugb2YgTWF0aC5sb2cyIHJlc3VsdCBpbiBwcmVjaXNpb24gbG9zdFxuICB2YXIgZXhwID0ganNvb19mbG9vcl9sb2cyKHgpICsgMTAyMztcbiAgaWYgKGV4cCA8PSAwKSB7XG4gICAgZXhwID0gMDtcbiAgICB4IC89IE1hdGgucG93KDIsLTEwMjYpO1xuICB9IGVsc2Uge1xuICAgIHggLz0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gICAgaWYgKHggPCAxNikge1xuICAgICAgeCAqPSAyOyBleHAgLT0xOyB9XG4gICAgaWYgKGV4cCA9PSAwKSB7XG4gICAgICB4IC89IDI7IH1cbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsMjQpO1xuICB2YXIgcjMgPSB4fDA7XG4gIHggPSAoeCAtIHIzKSAqIGs7XG4gIHZhciByMiA9IHh8MDtcbiAgeCA9ICh4IC0gcjIpICogaztcbiAgdmFyIHIxID0geHwwO1xuICByMyA9IChyMyAmMHhmKSB8IHNpZ24gfCBleHAgPDwgNDtcbiAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHIxLCByMiwgcjMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG4gIGZsb2F0MzJhWzBdID0geDtcbiAgdmFyIGludDMyYSA9IG5ldyBJbnQzMkFycmF5KGZsb2F0MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBpbnQzMmFbMF0gfCAwO1xufVxuXG4vL0ZQIGxpdGVyYWxzIGNhbiBiZSB3cml0dGVuIHVzaW5nIHRoZSBoZXhhZGVjaW1hbFxuLy9ub3RhdGlvbiAweDxtYW50aXNzYSBpbiBoZXg+cDxleHBvbmVudD4gZnJvbSBJU08gQzk5LlxuLy9odHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtaGV4ZmxvYXQvYmxvYi9tYXN0ZXIvaGV4ZmxvYXQuanNcbi8vUHJvdmlkZXM6IGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCAoeCwgcHJlYywgc3R5bGUpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSkgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFwibmFuXCIpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoKHggPiAwKT9cImluZmluaXR5XCI6XCItaW5maW5pdHlcIik7XG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8xOih4Pj0wKT8wOjE7XG4gIGlmKHNpZ24pIHggPSAteDtcbiAgdmFyIGV4cCA9IDA7XG4gIGlmICh4ID09IDApIHsgfVxuICBlbHNlIGlmICh4IDwgMSkge1xuICAgIHdoaWxlICh4IDwgMSAmJiBleHAgPiAtMTAyMikgIHsgeCAqPSAyOyBleHAtLSB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHggPj0gMikgeyB4IC89IDI7IGV4cCsrIH1cbiAgfVxuICB2YXIgZXhwX3NpZ24gPSBleHAgPCAwID8gJycgOiAnKyc7XG4gIHZhciBzaWduX3N0ciA9ICcnO1xuICBpZiAoc2lnbikgc2lnbl9zdHIgPSAnLSdcbiAgZWxzZSB7XG4gICAgc3dpdGNoKHN0eWxlKXtcbiAgICBjYXNlIDQzIC8qICcrJyAqLzogc2lnbl9zdHIgPSAnKyc7IGJyZWFrO1xuICAgIGNhc2UgMzIgLyogJyAnICovOiBzaWduX3N0ciA9ICcgJzsgYnJlYWs7XG4gICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChwcmVjID49IDAgJiYgcHJlYyA8IDEzKSB7XG4gICAgLyogSWYgYSBwcmVjaXNpb24gaXMgZ2l2ZW4sIGFuZCBpcyBzbWFsbCwgcm91bmQgbWFudGlzc2EgYWNjb3JkaW5nbHkgKi9cbiAgICB2YXIgY3N0ID0gTWF0aC5wb3coMixwcmVjICogNCk7XG4gICAgeCA9IE1hdGgucm91bmQoeCAqIGNzdCkgLyBjc3Q7XG4gIH1cbiAgdmFyIHhfc3RyID0geC50b1N0cmluZygxNik7XG4gIGlmKHByZWMgPj0gMCl7XG4gICAgdmFyIGlkeCA9IHhfc3RyLmluZGV4T2YoJy4nKTtcbiAgICBpZihpZHg8MCkge1xuICAgICAgeF9zdHIgKz0gJy4nICsgY2FtbF9zdHJfcmVwZWF0KHByZWMsICcwJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpemUgPSBpZHgrMStwcmVjO1xuICAgICAgaWYoeF9zdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgeF9zdHIgKz0gY2FtbF9zdHJfcmVwZWF0KHNpemUgLSB4X3N0ci5sZW5ndGgsICcwJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHhfc3RyID0geF9zdHIuc3Vic3RyKDAsc2l6ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoc2lnbl9zdHIgKyAnMHgnICsgeF9zdHIgKyAncCcgKyBleHBfc2lnbiArIGV4cC50b1N0cmluZygxMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgbG8gPSB4LmxvO1xuICB2YXIgbWkgPSB4Lm1pO1xuICB2YXIgaGkgPSB4LmhpO1xuICB2YXIgZXhwID0gKGhpICYgMHg3ZmZmKSA+PiA0O1xuICBpZiAoZXhwID09IDIwNDcpIHtcbiAgICBpZiAoKGxvfG1pfChoaSYweGYpKSA9PSAwKVxuICAgICAgcmV0dXJuIChoaSAmIDB4ODAwMCk/KC1JbmZpbml0eSk6SW5maW5pdHk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE5hTjtcbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsLTI0KTtcbiAgdmFyIHJlcyA9IChsbyprK21pKSprKyhoaSYweGYpO1xuICBpZiAoZXhwID4gMCkge1xuICAgIHJlcyArPSAxNjtcbiAgICByZXMgKj0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gIH0gZWxzZVxuICAgIHJlcyAqPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgaWYgKGhpICYgMHg4MDAwKSByZXMgPSAtIHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9zdWIsY2FtbF9pbnQ2NF9vZl9pbnQzMlxuZnVuY3Rpb24gY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgKHgseSkge1xuICBpZihpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIE5hTjtcbiAgaWYoeD09eSkgcmV0dXJuIHk7XG4gIGlmKHg9PTApe1xuICAgIGlmKHkgPCAwKVxuICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAtMTA3NClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwNzQpXG4gIH1cbiAgdmFyIGJpdHMgPSBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoeCk7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X29mX2ludDMyKDEpO1xuICBpZiAoKHg8eSkgPT0gKHg+MCkpXG4gICAgYml0cyA9IGNhbWxfaW50NjRfYWRkKGJpdHMsIG9uZSlcbiAgZWxzZVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X3N1YihiaXRzLCBvbmUpXG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoYml0cyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJ1bmNfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdHJ1bmNfZmxvYXQoeCl7XG4gIHJldHVybiBNYXRoLnRydW5jKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgaW50MzJhID0gbmV3IEludDMyQXJyYXkoMSk7XG4gIGludDMyYVswXSA9IHg7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBGbG9hdDMyQXJyYXkoaW50MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBmbG9hdDMyYVswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jbGFzc2lmeV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jbGFzc2lmeV9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpID49IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSByZXR1cm4gMDtcbiAgICBpZiAoeCAhPSAwKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gaXNOYU4oeCk/NDozO1xufVxuLy9Qcm92aWRlczogY2FtbF9tb2RmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX21vZGZfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIHZhciBuZWcgPSAoMS94KSA8IDA7XG4gICAgeCA9IE1hdGguYWJzKHgpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vciAoeCk7XG4gICAgdmFyIGYgPSB4IC0gaTtcbiAgICBpZiAobmVnKSB7IGkgPSAtaTsgZiA9IC1mOyB9XG4gICAgcmV0dXJuIFswLCBmLCBpXTtcbiAgfVxuICBpZiAoaXNOYU4gKHgpKSByZXR1cm4gWzAsIE5hTiwgTmFOXTtcbiAgcmV0dXJuIFswLCAxL3gsIHhdO1xufVxuLy9Qcm92aWRlczogY2FtbF9sZGV4cF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sZGV4cF9mbG9hdCAoeCxleHApIHtcbiAgZXhwIHw9IDA7XG4gIGlmIChleHAgPiAxMDIzKSB7XG4gICAgZXhwIC09IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICBpZiAoZXhwID4gMTAyMykgeyAgLy8gaW4gY2FzZSB4IGlzIHN1Ym5vcm1hbFxuICAgICAgZXhwIC09IDEwMjM7XG4gICAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIH1cbiAgfVxuICBpZiAoZXhwIDwgLTEwMjMpIHtcbiAgICBleHAgKz0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIC0xMDIzKTtcbiAgfVxuICB4ICo9IE1hdGgucG93KDIsIGV4cCk7XG4gIHJldHVybiB4O1xufVxuLy9Qcm92aWRlczogY2FtbF9mcmV4cF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ZyZXhwX2Zsb2F0ICh4KSB7XG4gIGlmICgoeCA9PSAwKSB8fCAhaXNGaW5pdGUoeCkpIHJldHVybiBbMCwgeCwgMF07XG4gIHZhciBuZWcgPSB4IDwgMDtcbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgdmFyIGV4cCA9IE1hdGgubWF4KC0xMDIzLCBqc29vX2Zsb29yX2xvZzIoeCkgKyAxKTtcbiAgeCAqPSBNYXRoLnBvdygyLC1leHApO1xuICB3aGlsZSAoeCA8IDAuNSkge1xuICAgIHggKj0gMjtcbiAgICBleHAtLTtcbiAgfVxuICB3aGlsZSAoeCA+PSAxKSB7XG4gICAgeCAqPSAwLjU7XG4gICAgZXhwKys7XG4gIH1cbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSAoeCwgeSkge1xuICBpZiAoeCA9PT0geSkgcmV0dXJuIDA7XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICBpZiAoeCA+IHkpIHJldHVybiAxO1xuICBpZiAoeCA9PT0geCkgcmV0dXJuIDE7XG4gIGlmICh5ID09PSB5KSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvcHlzaWduX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvcHlzaWduX2Zsb2F0ICh4LCB5KSB7XG4gIGlmICh5ID09IDApIHkgPSAxIC8geTtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICByZXR1cm4gKHkgPCAwKT8oLXgpOng7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2lnbmJpdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaWduYml0X2Zsb2F0KHgpIHtcbiAgaWYgKHggPT0gMCkgeCA9IDEgLyB4O1xuICByZXR1cm4gKHggPCAwKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhwbTFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwbTFfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguZXhwbTEoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZXhwMl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9leHAyX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgucG93KDIsIHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzFwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzFwX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgubG9nMXAoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cyX2Zsb2F0KHgpIHsgcmV0dXJuIE1hdGgubG9nMih4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9oeXBvdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9oeXBvdF9mbG9hdCAoeCwgeSkgeyByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTsgfVxuLy9Qcm92aWRlczogY2FtbF9sb2cxMF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxMF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5sb2cxMCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9jb3NoX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Nvc2hfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguY29zaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hY29zaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hY29zaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9zaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguc2luaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hc2luaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hc2luaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hc2luaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF90YW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3RhbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgudGFuaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9hdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9hdGFuaF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5hdGFuaCh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9yb3VuZF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9yb3VuZF9mbG9hdCAoeCkge1xuICBpZiAoeCA+PSAwKSB7XG4gICAgdmFyIHkgPSBNYXRoLmZsb29yKHgpO1xuICAgIHJldHVybiAoeCAtIHkgPj0gMC41KT8oeSArIDEpOnlcbiAgfSBlbHNlIHtcbiAgICB2YXIgeSA9IE1hdGguY2VpbCh4KTtcbiAgICByZXR1cm4gKHkgLSB4ID49IDAuNSk/KHkgLSAxKTp5XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY2JydF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jYnJ0X2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmNicnQoeCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9lcmZfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXJmX2Zsb2F0KHgpIHtcbiAgdmFyIGExID0gMC4yNTQ4Mjk1OTI7XG4gIHZhciBhMiA9IC0wLjI4NDQ5NjczNjtcbiAgdmFyIGEzID0gMS40MjE0MTM3NDE7XG4gIHZhciBhNCA9IC0xLjQ1MzE1MjAyNztcbiAgdmFyIGE1ID0gMS4wNjE0MDU0Mjk7XG4gIHZhciBwID0gMC4zMjc1OTExO1xuXG4gIHZhciBzaWduID0gMTtcbiAgaWYgKHggPCAwKSB7XG4gICAgc2lnbiA9IC0xO1xuICB9XG4gIHggPSBNYXRoLmFicyh4KTtcbiAgdmFyIHQgPSAxLjAgLyAoMS4wICsgcCAqIHgpO1xuICB2YXIgeSA9IDEuMCAtICgoKChhNSAqIHQgKyBhNCkgKiB0ICsgYTMpICogdCArIGEyKSAqIHQgKyBhMSkgKiB0ICogTWF0aC5leHAoLXggKiB4KTtcblxuICByZXR1cm4gc2lnbiAqIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXJmY19mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9lcmZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfZXJmY19mbG9hdCh4KSB7XG4gIHJldHVybiAxIC0gY2FtbF9lcmZfZmxvYXQoeCk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9mbWFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZm1hX2Zsb2F0KHgsIHksIHopIHtcbiAgdmFyIFNQTElUID0gTWF0aC5wb3coMiwgMjcpICsgMTtcbiAgdmFyIE1JTl9WQUxVRSA9IE1hdGgucG93KDIsIC0xMDIyKTtcbiAgdmFyIEVQU0lMT04gPSBNYXRoLnBvdygyLCAtNTIpO1xuICB2YXIgQyA9IDQxNjtcbiAgdmFyIEEgPSBNYXRoLnBvdygyLCArQyk7XG4gIHZhciBCID0gTWF0aC5wb3coMiwgLUMpO1xuXG4gIGZ1bmN0aW9uIG11bHRpcGx5IChhLCBiKSB7XG4gICAgdmFyIGF0ID0gU1BMSVQgKiBhO1xuICAgIHZhciBhaGkgPSBhdCAtIChhdCAtIGEpO1xuICAgIHZhciBhbG8gPSBhIC0gYWhpO1xuICAgIHZhciBidCA9IFNQTElUICogYjtcbiAgICB2YXIgYmhpID0gYnQgLSAoYnQgLSBiKTtcbiAgICB2YXIgYmxvID0gYiAtIGJoaTtcbiAgICB2YXIgcCA9IGEgKiBiO1xuICAgIHZhciBlID0gKChhaGkgKiBiaGkgLSBwKSArIGFoaSAqIGJsbyArIGFsbyAqIGJoaSkgKyBhbG8gKiBibG87XG4gICAgcmV0dXJuIHtcbiAgICAgIHA6IHAsXG4gICAgICBlOiBlXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB2YXIgcyA9IGEgKyBiO1xuICAgIHZhciB2ID0gcyAtIGE7XG4gICAgdmFyIGUgPSAoYSAtIChzIC0gdikpICsgKGIgLSB2KTtcbiAgICByZXR1cm4ge1xuICAgICAgczogcyxcbiAgICAgIGU6IGVcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkanVzdCAoeCwgeSkge1xuICAgIHJldHVybiB4ICE9PSAwICYmIHkgIT09IDAgJiYgU1BMSVQgKiB4IC0gKFNQTElUICogeCAtIHgpID09PSB4ID8geCAqICgxICsgKHggPCAwID8gLTEgOiArMSkgKiAoeSA8IDAgPyAtMSA6ICsxKSAqIEVQU0lMT04pIDogeDtcbiAgfTtcblxuICBpZiAoeCA9PT0gMCB8fCB4ICE9PSB4IHx8IHggPT09ICsxIC8gMCB8fCB4ID09PSAtMSAvIDAgfHxcbiAgICAgIHkgPT09IDAgfHwgeSAhPT0geSB8fCB5ID09PSArMSAvIDAgfHwgeSA9PT0gLTEgLyAwKSB7XG4gICAgcmV0dXJuIHggKiB5ICsgejtcbiAgfVxuICBpZiAoeiA9PT0gMCkge1xuICAgIHJldHVybiB4ICogeTtcbiAgfVxuICBpZiAoeiAhPT0geiB8fCB6ID09PSArMSAvIDAgfHwgeiA9PT0gLTEgLyAwKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cblxuICB2YXIgc2NhbGUgPSAxO1xuICB3aGlsZSAoTWF0aC5hYnMoeCkgPiBBKSB7XG4gICAgc2NhbGUgKj0gQTtcbiAgICB4ICo9IEI7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHkpID4gQSkge1xuICAgIHNjYWxlICo9IEE7XG4gICAgeSAqPSBCO1xuICB9XG4gIGlmIChzY2FsZSA9PT0gMSAvIDApIHtcbiAgICByZXR1cm4geCAqIHkgKiBzY2FsZTtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeCkgPCBCKSB7XG4gICAgc2NhbGUgKj0gQjtcbiAgICB4ICo9IEE7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHkpIDwgQikge1xuICAgIHNjYWxlICo9IEI7XG4gICAgeSAqPSBBO1xuICB9XG4gIGlmIChzY2FsZSA9PT0gMCkge1xuICAgIHJldHVybiB6O1xuICB9XG5cbiAgdmFyIHhzID0geDtcbiAgdmFyIHlzID0geTtcbiAgdmFyIHpzID0geiAvIHNjYWxlO1xuXG4gIGlmIChNYXRoLmFicyh6cykgPiBNYXRoLmFicyh4cyAqIHlzKSAqIDQgLyBFUFNJTE9OKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cbiAgaWYgKE1hdGguYWJzKHpzKSA8IE1hdGguYWJzKHhzICogeXMpICogRVBTSUxPTiAvIDQgKiBFUFNJTE9OIC8gNCkge1xuICAgIHpzID0gKHogPCAwID8gLTEgOiArMSkgKiBNSU5fVkFMVUU7XG4gIH1cblxuICB2YXIgeHkgPSBtdWx0aXBseSh4cywgeXMpO1xuICB2YXIgcyA9IGFkZCh4eS5wLCB6cyk7XG4gIHZhciB1ID0gYWRkKHh5LmUsIHMuZSk7XG4gIHZhciBpID0gYWRkKHMucywgdS5zKTtcblxuICB2YXIgZiA9IGkucyArIGFkanVzdChpLmUsIHUuZSk7XG4gIGlmIChmID09PSAwKSB7XG4gICAgcmV0dXJuIGY7XG4gIH1cblxuICB2YXIgZnMgPSBmICogc2NhbGU7XG4gIGlmIChNYXRoLmFicyhmcykgPiBNSU5fVkFMVUUpIHtcbiAgICByZXR1cm4gZnM7XG4gIH1cblxuICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZXJlIHdhcyBleHRyYSByb3VuZGluZyBmb3IgYSBkZW5vcm1hbGl6ZWQgdmFsdWUuXG4gIHJldHVybiBmcyArIGFkanVzdChmIC0gZnMgLyBzY2FsZSwgaS5lKSAqIHNjYWxlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2Zsb2F0IChmbXQsIHgpIHtcbiAgZnVuY3Rpb24gdG9GaXhlZCh4LGRwKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpIDwgMS4wKSB7XG4gICAgICByZXR1cm4geC50b0ZpeGVkKGRwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGUgPSBwYXJzZUludCh4LnRvU3RyaW5nKCkuc3BsaXQoJysnKVsxXSk7XG4gICAgICBpZiAoZSA+IDIwKSB7XG4gICAgICAgIGUgLT0gMjA7XG4gICAgICAgIHggLz0gTWF0aC5wb3coMTAsZSk7XG4gICAgICAgIHggKz0gKG5ldyBBcnJheShlKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIGlmKGRwID4gMCkge1xuICAgICAgICAgIHggPSB4ICsgJy4nICsgKG5ldyBBcnJheShkcCsxKSkuam9pbignMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgICAgZWxzZSByZXR1cm4geC50b0ZpeGVkKGRwKVxuICAgIH1cbiAgfVxuICB2YXIgcywgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIHZhciBwcmVjID0gKGYucHJlYyA8IDApPzY6Zi5wcmVjO1xuICBpZiAoeCA8IDAgfHwgKHggPT0gMCAmJiAxL3ggPT0gLUluZmluaXR5KSkgeyBmLnNpZ24gPSAtMTsgeCA9IC14OyB9XG4gIGlmIChpc05hTih4KSkgeyBzID0gXCJuYW5cIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZSBpZiAoIWlzRmluaXRlKHgpKSB7IHMgPSBcImluZlwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlXG4gICAgc3dpdGNoIChmLmNvbnYpIHtcbiAgICBjYXNlICdlJzpcbiAgICAgIHZhciBzID0geC50b0V4cG9uZW50aWFsKHByZWMpO1xuICAgICAgLy8gZXhwb25lbnQgc2hvdWxkIGJlIGF0IGxlYXN0IHR3byBkaWdpdHNcbiAgICAgIHZhciBpID0gcy5sZW5ndGg7XG4gICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2YnOlxuICAgICAgcyA9IHRvRml4ZWQoeCwgcHJlYyk7IGJyZWFrO1xuICAgIGNhc2UgJ2cnOlxuICAgICAgcHJlYyA9IHByZWM/cHJlYzoxO1xuICAgICAgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjIC0gMSk7XG4gICAgICB2YXIgaiA9IHMuaW5kZXhPZignZScpO1xuICAgICAgdmFyIGV4cCA9ICtzLnNsaWNlKGogKyAxKTtcbiAgICAgIGlmIChleHAgPCAtNCB8fCB4ID49IDFlMjEgfHwgeC50b0ZpeGVkKDApLmxlbmd0aCA+IHByZWMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICB2YXIgaSA9IGogLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpICsgcy5zbGljZShqKTtcbiAgICAgICAgaSA9IHMubGVuZ3RoO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwID0gcHJlYztcbiAgICAgICAgaWYgKGV4cCA8IDApIHsgcCAtPSBleHAgKyAxOyBzID0geC50b0ZpeGVkKHApOyB9XG4gICAgICAgIGVsc2Ugd2hpbGUgKHMgPSB4LnRvRml4ZWQocCksIHMubGVuZ3RoID4gcHJlYyArIDEpIHAtLTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgICAgdmFyIGkgPSBzLmxlbmd0aCAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX3N0cmluZyhzKSB7XG4gIHZhciByZXM7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpXG4gIHJlcyA9ICtzO1xuICBpZiAoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgcmV0dXJuIHJlcztcbiAgcyA9IHMucmVwbGFjZSgvXy9nLFwiXCIpO1xuICByZXMgPSArcztcbiAgaWYgKCgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSB8fCAvXlsrLV0/bmFuJC9pLnRlc3QocykpIHJldHVybiByZXM7XG4gIHZhciBtID0gL14gKihbKy1dPykweChbMC05YS1mXSspXFwuPyhbMC05YS1mXSopKHAoWystXT9bMC05XSspKT8vaS5leGVjKHMpO1xuICAvLyAgICAgICAgICAxICAgICAgICAyICAgICAgICAgICAgIDMgICAgICAgICAgIDVcbiAgaWYobSl7XG4gICAgdmFyIG0zID0gbVszXS5yZXBsYWNlKC8wKyQvLCcnKTtcbiAgICB2YXIgbWFudGlzc2EgPSBwYXJzZUludChtWzFdICsgbVsyXSArIG0zLCAxNik7XG4gICAgdmFyIGV4cG9uZW50ID0gKG1bNV18MCkgLSA0Km0zLmxlbmd0aDtcbiAgICByZXMgPSBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmKC9eXFwrP2luZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiBJbmZpbml0eTtcbiAgaWYoL14taW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgY2FtbF9mYWlsd2l0aChcImZsb2F0X29mX3N0cmluZ1wiKTtcbn1cbiIsIi8qXG5UbyBkZWFsIHdpdGggZWZmZWN0cywgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IGlzIGludHVpdGl2ZWx5IGNvbXBvc2VkIG9mXG5hIHN0YWNrIG9mIGZpYmVycy4gRWFjaCBmaWJlciBoYXMgYSBjdXJyZW50IGxvdy1sZXZlbCBjb250aW51YXRpb25cbihvbmUtYXJndW1lbnQgSmF2YVNjcmlwdCBmdW5jdGlvbiksIGEgc3RhY2sgb2YgZXhjZXB0aW9uIGhhbmRsZXJzIGFuZFxuYSB0cmlwbGUgb2YgaGFuZGxlcnMsIHdoaWNoIGFyZSBpbnZva2VkIHdoZW4gdGhlIGZpYmVyIHRlcm1pbmF0ZXNcbihlaXRoZXIgd2l0aCBhIHZhbHVlIG9yIGFuIGV4Y2VwdGlvbikgb3Igd2hlbiBhbiBlZmZlY3QgaXMgcGVyZm9ybWVkLlxuVGhlIGxvdy1sZXZlbCBjb250aW51YXRpb24gb2YgdGhlIHRvcG1vc3QgZmliZXIgKHdoaWNoIGlzIGN1cnJlbnRseVxuZXhlY3V0aW5nKSBpcyBwYXNzZWQgZnJvbSBmdW5jdGlvbiB0byBmdW5jdGlvbiBhcyBhbiBhZGRpdGlvbmFsXG5hcmd1bWVudC4gSXRzIHN0YWNrIG9mIGV4Y2VwdGlvbiBoYW5kbGVycyBpcyBzdG9yZWQgaW5cbltjYW1sX2V4bl9zdGFja10uIEV4Y2VwdGlvbiBoYW5kbGVycyBhcmUgcHVzaGVkIGludG8gdGhpcyBzdGFjayB3aGVuXG5lbnRlcmluZyBhIFt0cnkgLi4uIHdpdGggLi4uXSBhbmQgcG9wcGVkIG9uIGV4aXQuIFRoZW4sIGhhbmRsZXJzIGFuZFxudGhlIHJlbWFpbmluZyBmaWJlcnMgYXJlIHN0b3JlZCBpbiBbY2FtbF9maWJlcl9zdGFja10uIFRvIGluc3RhbGwgYW5cbmVmZmVjdCBoYW5kbGVyLCB3ZSBwdXNoIGEgbmV3IGZpYmVyIGludG8gdGhlIGV4ZWN1dGlvbiBjb250ZXh0LlxuXG5XZSBoYXZlIGJhc2ljYWxseSB0aGUgZm9sbG93aW5nIHR5cGUgZm9yIHJlaWZpZWQgY29udGludWF0aW9ucyAodHlwZVxuW2NvbnRpbnVhdGlvbl0gaW4gbW9kdWxlIFtFZmZlY3RdIG9mIHRoZSBzdGFuZGFyZCBsaWJyYXJ5KTpcblxuICB0eXBlICgnYSwgJ2IpIGNvbnRpbnVhdGlvbiA9ICgnYSwgJ2IpIHN0YWNrIHJlZlxuXG4gIGFuZCAoXywgXykgc3RhY2sgPVxuICAgICAgQ29ucyA6ICgnYiAtPiB1bml0KSAqICAgICAgICAgICAgICgqIGxvdy1sZXZlbCBjb250aW51YXRpb24gKilcbiAgICAgICAgICAgICAoZXhuIC0+IHVuaXQpIGxpc3QgKiAgICAgICAoKiBleGNlcHRpb24gaGFuZGxlcnMgKilcbiAgICAgICAgICAgICAoJ2IsICdjKSBoYW5kbGVyICpcbiAgICAgICAgICAgICAoJ2EsICdiKSBzdGFja1xuICAgICAgICAgICAgIC0+ICgnYSwgJ2MpIHN0YWNrXG4gICAgfCBFbXB0eSA6ICgnYSwgJ2EpIHN0YWNrXG5cbiAgYW5kICgnYSwnYikgaGFuZGxlciA9ICAgKCogQXMgaW4gbW9kdWxlIEVmZmVjdCBmcm9tIHRoZSBzdGFuZGFyZCBsaWJyYXJ5ICopXG4gICAgeyByZXRjOiAnYSAtPiAnYjtcbiAgICAgIGV4bmM6IGV4biAtPiAnYjtcbiAgICAgIGVmZmM6ICdjLidjIEVmZmVjdC50IC0+ICgoJ2MsJ2IpIGNvbnRpbnVhdGlvbiAtPiAnYikgb3B0aW9uIH1cblxuQ29udGludWF0aW9ucyBhcmUgb25lLXNob3QuIEEgY29udGludWF0aW9uIFtyZWYgRW1wdHldIGhhcyBhbHJlYWR5XG5iZWVuIHJlc3VtZWQuXG5cbkEgY29udGludWF0aW9uIGlzIGJhc2ljYWxseSBjb21wb3NlZCBvZiBhIGxpc3Qgb2YgZmliZXJzLCB3aGljaCBlYWNoXG5oYXMgaXRzIGxvdy1sZXZlbCBjb250aW51YXRpb24sIGl0cyBzdGFjayBvZiBleGNlcHRpb24gaGFuZGxlcnMgYW5kIGFcbnRyaXBsZSBvZiBoYW5kbGVycyB0byBkZWFsIHdpdGggd2hlbiB0aGUgZmliZXIgdGVybWluYXRlcyBvciBhblxuZWZmZWN0IGlzIHBlcmZvcm1lZC4gV2hlbiByZXN1bWluZyBhIGNvbnRpbnVhdGlvbiwgdGhlIGlubmVybW9zdCBmaWJlclxuaXMgcmVzdW1lZCBmaXJzdC5cblxuVGhlIGhhbmRsZXJzIGFyZSBDUFMtdHJhbnNmb3JtZWQgZnVuY3Rpb25zOiB0aGV5IGFjdHVhbGx5IHRha2UgYW5cbmFkZGl0aW9uYWwgcGFyYW1ldGVyIHdoaWNoIGlzIHRoZSBjdXJyZW50IGxvdy1sZXZlbCBjb250aW51YXRpb24uXG4qL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl9zdGFja1xuLy9JZjogZWZmZWN0c1xuLy8gVGhpcyBpcyBhbiBPQ2FtbCBsaXN0IG9mIGV4Y2VwdGlvbiBoYW5kbGVyc1xudmFyIGNhbWxfZXhuX3N0YWNrID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9wdXNoX3RyYXBcbi8vUmVxdWlyZXM6IGNhbWxfZXhuX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX3B1c2hfdHJhcChoYW5kbGVyKSB7XG4gIGNhbWxfZXhuX3N0YWNrPVswLGhhbmRsZXIsY2FtbF9leG5fc3RhY2tdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BvcF90cmFwXG4vL1JlcXVpcmVzOiBjYW1sX2V4bl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9wb3BfdHJhcCgpIHtcbiAgaWYgKCFjYW1sX2V4bl9zdGFjaykgcmV0dXJuIGZ1bmN0aW9uKHgpe3Rocm93IHg7fVxuICB2YXIgaCA9IGNhbWxfZXhuX3N0YWNrWzFdO1xuICBjYW1sX2V4bl9zdGFjaz1jYW1sX2V4bl9zdGFja1syXTtcbiAgcmV0dXJuIGhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWJlcl9zdGFja1xuLy9JZjogZWZmZWN0c1xuLy8gVGhpcyBoYXMgdGhlIHNoYXBlIHtoLCByOntrLCB4LCBlfX0gd2hlcmUgaCBpcyBhIHRyaXBsZSBvZiBoYW5kbGVyc1xuLy8gKHNlZSBlZmZlY3QuanMpIGFuZCBrLCB4IGFuZCBlIGFyZSB0aGUgc2F2ZWQgY29udGludWF0aW9uLFxuLy8gZXhjZXB0aW9uIHN0YWNrIGFuZCBmaWJlciBzdGFjayBvZiB0aGUgcGFyZW50IGZpYmVyLlxudmFyIGNhbWxfZmliZXJfc3RhY2s7XG5cbi8vUHJvdmlkZXM6Y2FtbF9yZXN1bWVfc3RhY2tcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZXhuX3N0YWNrLCBjYW1sX2ZpYmVyX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX3Jlc3VtZV9zdGFjayhzdGFjaywgaykge1xuICBpZiAoIXN0YWNrKSBjYW1sX3JhaXNlX2NvbnN0YW50XG4gICAgICAgICAgICAgICAgIChjYW1sX25hbWVkX3ZhbHVlKFwiRWZmZWN0LkNvbnRpbnVhdGlvbl9hbHJlYWR5X3Jlc3VtZWRcIikpO1xuICAvLyBVcGRhdGUgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IHdpdGggdGhlIHN0YWNrIG9mIGZpYmVycyBpbiBbc3RhY2tdIGluXG4gIC8vIG9yZGVyIHRvIHJlc3VtZSB0aGUgY29udGludWF0aW9uXG4gIGRvIHtcbiAgICBjYW1sX2ZpYmVyX3N0YWNrID1cbiAgICAgIHtoOnN0YWNrWzNdLCByOntrOmssIHg6Y2FtbF9leG5fc3RhY2ssIGU6Y2FtbF9maWJlcl9zdGFja319O1xuICAgIGsgPSBzdGFja1sxXTtcbiAgICBjYW1sX2V4bl9zdGFjayA9IHN0YWNrWzJdO1xuICAgIHN0YWNrID0gc3RhY2tbNF07XG4gIH0gd2hpbGUgKHN0YWNrKVxuICByZXR1cm4gaztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3BfZmliZXJcbi8vUmVxdWlyZXM6IGNhbWxfZXhuX3N0YWNrLCBjYW1sX2ZpYmVyX3N0YWNrXG4vL0lmOiBlZmZlY3RzXG5mdW5jdGlvbiBjYW1sX3BvcF9maWJlcigpIHtcbiAgLy8gTW92ZSB0byB0aGUgcGFyZW50IGZpYmVyLCByZXR1cm5pbmcgdGhlIHBhcmVudCdzIGxvdy1sZXZlbCBjb250aW51YXRpb25cbiAgdmFyIHJlbSA9IGNhbWxfZmliZXJfc3RhY2sucjtcbiAgY2FtbF9leG5fc3RhY2sgPSByZW0ueDtcbiAgY2FtbF9maWJlcl9zdGFjayA9IHJlbS5lO1xuICByZXR1cm4gcmVtLms7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGVyZm9ybV9lZmZlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfcG9wX2ZpYmVyLCBjYW1sX3N0YWNrX2NoZWNrX2RlcHRoLCBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuLCBjYW1sX2V4bl9zdGFjaywgY2FtbF9maWJlcl9zdGFja1xuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9wZXJmb3JtX2VmZmVjdChlZmYsIGNvbnQsIGswKSB7XG4gIC8vIEFsbG9jYXRlIGEgY29udGludWF0aW9uIGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKCFjb250KSBjb250ID0gWzI0NSAvKmNvbnRpbnVhdGlvbiovLCAwXTtcbiAgLy8gR2V0IGN1cnJlbnQgZWZmZWN0IGhhbmRsZXJcbiAgdmFyIGhhbmRsZXIgPSBjYW1sX2ZpYmVyX3N0YWNrLmhbM107XG4gIC8vIENvbnMgdGhlIGN1cnJlbnQgZmliZXIgb250byB0aGUgY29udGludWF0aW9uOlxuICAvLyAgIGNvbnQgOj0gQ29ucyAoaywgZXhuX3N0YWNrLCBoYW5kbGVycywgIWNvbnQpXG4gIGNvbnRbMV0gPSBbMCxrMCxjYW1sX2V4bl9zdGFjayxjYW1sX2ZpYmVyX3N0YWNrLmgsY29udFsxXV07XG4gIC8vIE1vdmUgdG8gcGFyZW50IGZpYmVyIGFuZCBleGVjdXRlIHRoZSBlZmZlY3QgaGFuZGxlciB0aGVyZVxuICAvLyBUaGUgaGFuZGxlciBpcyBkZWZpbmVkIGluIFN0ZGxpYi5FZmZlY3QsIHNvIHdlIGtub3cgdGhhdCB0aGUgYXJpdHkgbWF0Y2hlc1xuICB2YXIgazEgPSBjYW1sX3BvcF9maWJlcigpO1xuICByZXR1cm4gY2FtbF9zdGFja19jaGVja19kZXB0aCgpP2hhbmRsZXIoZWZmLGNvbnQsazEsazEpXG4gICAgICAgICA6Y2FtbF90cmFtcG9saW5lX3JldHVybihoYW5kbGVyLFtlZmYsY29udCxrMSxrMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FsbG9jX3N0YWNrXG4vL1JlcXVpcmVzOiBjYW1sX3BvcF9maWJlciwgY2FtbF9maWJlcl9zdGFjaywgY2FtbF9jYWxsX2dlbiwgY2FtbF9zdGFja19jaGVja19kZXB0aCwgY2FtbF90cmFtcG9saW5lX3JldHVyblxuLy9JZjogZWZmZWN0c1xuZnVuY3Rpb24gY2FtbF9hbGxvY19zdGFjayhodiwgaHgsIGhmKSB7XG4gIGZ1bmN0aW9uIGNhbGwoaSwgeCkge1xuICAgIHZhciBmPWNhbWxfZmliZXJfc3RhY2suaFtpXTtcbiAgICB2YXIgYXJncyA9IFt4LCBjYW1sX3BvcF9maWJlcigpXTtcbiAgICByZXR1cm4gY2FtbF9zdGFja19jaGVja19kZXB0aCgpP2NhbWxfY2FsbF9nZW4oZixhcmdzKVxuICAgICAgICAgICA6Y2FtbF90cmFtcG9saW5lX3JldHVybihmLGFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGh2YWwoeCkge1xuICAgIC8vIENhbGwgW2h2XSBpbiB0aGUgcGFyZW50IGZpYmVyXG4gICAgcmV0dXJuIGNhbGwoMSwgeCk7XG4gIH1cbiAgZnVuY3Rpb24gaGV4bihlKSB7XG4gICAgLy8gQ2FsbCBbaHhdIGluIHRoZSBwYXJlbnQgZmliZXJcbiAgICByZXR1cm4gY2FsbCgyLCBlKTtcbiAgfVxuICByZXR1cm4gWzAsIGh2YWwsIFswLCBoZXhuLCAwXSwgWzAsIGh2LCBoeCwgaGZdLCAwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hbGxvY19zdGFja1xuLy9JZjogIWVmZmVjdHNcbmZ1bmN0aW9uIGNhbWxfYWxsb2Nfc3RhY2soaHYsIGh4LCBoZikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb250aW51YXRpb25fdXNlX25vZXhjXG5mdW5jdGlvbiBjYW1sX2NvbnRpbnVhdGlvbl91c2Vfbm9leGMoY29udCkge1xuICB2YXIgc3RhY2s9Y29udFsxXTtcbiAgY29udFsxXT0wO1xuICByZXR1cm4gc3RhY2s7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udGludWF0aW9uX3VzZV9hbmRfdXBkYXRlX2hhbmRsZXJfbm9leGNcbi8vUmVxdWlyZXM6IGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Y1xuZnVuY3Rpb24gY2FtbF9jb250aW51YXRpb25fdXNlX2FuZF91cGRhdGVfaGFuZGxlcl9ub2V4Yyhjb250LCBodmFsLCBoZXhuLCBoZWZmKSB7XG4gIHZhciBzdGFjayA9IGNhbWxfY29udGludWF0aW9uX3VzZV9ub2V4Yyhjb250KTtcbiAgc3RhY2tbM10gPSBbMCwgaHZhbCwgaGV4biwgaGVmZl07XG4gIHJldHVybiBzdGFjaztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfY29udGludWF0aW9uX2NhbGxzdGFja1xuZnVuY3Rpb24gY2FtbF9nZXRfY29udGludWF0aW9uX2NhbGxzdGFjayAoKSB7IHJldHVybiBbMF07IH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fbmV3XG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl9uZXcodW5pdCl7XG4gICAgcmV0dXJuIHtjb25kaXRpb246MX07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY29uZGl0aW9uX3dhaXRcbmZ1bmN0aW9uIGNhbWxfbWxfY29uZGl0aW9uX3dhaXQodCxtdXRleHQpe1xuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NvbmRpdGlvbl9icm9hZGNhc3RcbmZ1bmN0aW9uIGNhbWxfbWxfY29uZGl0aW9uX2Jyb2FkY2FzdCh0KXtcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jb25kaXRpb25fc2lnbmFsXG5mdW5jdGlvbiBjYW1sX21sX2NvbmRpdGlvbl9zaWduYWwodCl7XG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fZWZmZWN0X25vdF9zdXBwb3J0ZWRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIUlmOiBlZmZlY3RzXG5mdW5jdGlvbiBqc29vX2VmZmVjdF9ub3Rfc3VwcG9ydGVkKCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJFZmZlY3QgaGFuZGxlcnMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBnbG9iYWxUaGlzLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzLnZlcnNpb25zICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGdsb2JhbFRoaXMucHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJylcbn1cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL0lmOiBicm93c2VyXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCAoKSB7XG4gIHJldHVybiBmYWxzZVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9SZXF1aXJlczogTWxOb2RlRmQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX3dpdGhfYXJnc1xuLy9SZXF1aXJlczogbWFrZV91bml4X2Vycl9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKHJvb3QpIHtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmlzRmlsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5zdGF0U3luYyh0aGlzLm5tKG5hbWUpKS5pc0ZpbGUoKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ta2RpciA9IGZ1bmN0aW9uKG5hbWUsIG1vZGUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLm1rZGlyU3luYyh0aGlzLm5tKG5hbWUpLHttb2RlOm1vZGV9KTtcbiAgICByZXR1cm4gMFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMucm1kaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiAwXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5yZWFkZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5pc19kaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNEaXJlY3RvcnkoKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICAgIHRoaXMuZnMudW5saW5rU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gYjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZiwgcmFpc2VfdW5peCkge1xuICB2YXIgY29uc3RzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG4gIHZhciByZXMgPSAwO1xuICBmb3IodmFyIGtleSBpbiBmKXtcbiAgICBzd2l0Y2goa2V5KXtcbiAgICBjYXNlIFwicmRvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1JET05MWTsgYnJlYWs7XG4gICAgY2FzZSBcIndyb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19XUk9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJhcHBlbmRcIiAgOlxuICAgICAgcmVzIHw9IGNvbnN0cy5PX1dST05MWSB8IGNvbnN0cy5PX0FQUEVORDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjcmVhdGVcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0NSRUFUOyAgICBicmVhaztcbiAgICBjYXNlIFwidHJ1bmNhdGVcIiA6IHJlcyB8PSBjb25zdHMuT19UUlVOQzsgICAgYnJlYWs7XG4gICAgY2FzZSBcImV4Y2xcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fRVhDTDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiaW5hcnlcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0JJTkFSWTsgICBicmVhaztcbiAgICBjYXNlIFwidGV4dFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19URVhUOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vbmJsb2NrXCIgOiByZXMgfD0gY29uc3RzLk9fTk9OQkxPQ0s7IGJyZWFrO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHZhciBmZCA9IHRoaXMuZnMub3BlblN5bmModGhpcy5ubShuYW1lKSwgcmVzKTtcbiAgICB2YXIgaXNDaGFyYWN0ZXJEZXZpY2UgPSB0aGlzLmZzLmxzdGF0U3luYyh0aGlzLm5tKG5hbWUpKS5pc0NoYXJhY3RlckRldmljZSgpO1xuICAgIGYuaXNDaGFyYWN0ZXJEZXZpY2UgPSBpc0NoYXJhY3RlckRldmljZTtcbiAgICByZXR1cm4gbmV3IE1sTm9kZUZkKGZkLCBmKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKG8sIG4sIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlbmFtZVN5bmModGhpcy5ubShvKSwgdGhpcy5ubShuKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3RhdCA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIganNfc3RhdHMgPSB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiB0aGlzLnN0YXRzX2Zyb21fanMoanNfc3RhdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmxzdGF0ID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMubHN0YXRTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiB0aGlzLnN0YXRzX2Zyb21fanMoanNfc3RhdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnN5bWxpbmsgPSBmdW5jdGlvbih0b19kaXIsIHRhcmdldCwgcGF0aCwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMuc3ltbGlua1N5bmModGhpcy5ubSh0YXJnZXQpLCB0aGlzLm5tKHBhdGgpLCB0b19kaXIgPyAnZGlyJyA6ICdmaWxlJyk7XG4gICAgcmV0dXJuIDA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGxpbmsgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGxpbmsgPSB0aGlzLmZzLnJlYWRsaW5rU3luYyh0aGlzLm5tKG5hbWUpLCAndXRmOCcpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhsaW5rKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLm9wZW5kaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJhaXNlX25vZGVqc19lcnJvciA9IGZ1bmN0aW9uKGVyciwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IGNhbWxfbmFtZWRfdmFsdWUoXCJVbml4LlVuaXhfZXJyb3JcIik7XG4gIGlmIChyYWlzZV91bml4ICYmIHVuaXhfZXJyb3IpIHtcbiAgICB2YXIgYXJncyA9IG1ha2VfdW5peF9lcnJfYXJncyhlcnIuY29kZSwgZXJyLnN5c2NhbGwsIGVyci5wYXRoLCBlcnIuZXJybm8pO1xuICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5zdGF0c19mcm9tX2pzID0gZnVuY3Rpb24oanNfc3RhdHMpIHtcbiAgLyogPT09VW5peC5maWxlX2tpbmQ9PT1cbiAgICogdHlwZSBmaWxlX2tpbmQgPVxuICAgKiAgICAgU19SRUcgICAgICAgICAgICAgICAgICAgICAgICgqKiBSZWd1bGFyIGZpbGUgKilcbiAgICogICB8IFNfRElSICAgICAgICAgICAgICAgICAgICAgICAoKiogRGlyZWN0b3J5ICopXG4gICAqICAgfCBTX0NIUiAgICAgICAgICAgICAgICAgICAgICAgKCoqIENoYXJhY3RlciBkZXZpY2UgKilcbiAgICogICB8IFNfQkxLICAgICAgICAgICAgICAgICAgICAgICAoKiogQmxvY2sgZGV2aWNlICopXG4gICAqICAgfCBTX0xOSyAgICAgICAgICAgICAgICAgICAgICAgKCoqIFN5bWJvbGljIGxpbmsgKilcbiAgICogICB8IFNfRklGTyAgICAgICAgICAgICAgICAgICAgICAoKiogTmFtZWQgcGlwZSAqKVxuICAgKiAgIHwgU19TT0NLICAgICAgICAgICAgICAgICAgICAgICgqKiBTb2NrZXQgKilcbiAgICovXG4gIHZhciBmaWxlX2tpbmQ7XG4gIGlmIChqc19zdGF0cy5pc0ZpbGUoKSkge1xuICAgIGZpbGVfa2luZCA9IDA7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIGZpbGVfa2luZCA9IDE7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNDaGFyYWN0ZXJEZXZpY2UoKSkge1xuICAgIGZpbGVfa2luZCA9IDI7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNCbG9ja0RldmljZSgpKSB7XG4gICAgZmlsZV9raW5kID0gMztcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgZmlsZV9raW5kID0gNDtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc0ZJRk8oKSkge1xuICAgIGZpbGVfa2luZCA9IDU7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNTb2NrZXQoKSkge1xuICAgIGZpbGVfa2luZCA9IDY7XG4gIH1cbiAgLyogPT09VW5peC5zdGF0cz09PVxuICAgKiB0eXBlIHN0YXRzID1cbiAgICogIHsgc3RfZGV2IDogaW50OyAgICAgICAgICAgICAgICgqKiBEZXZpY2UgbnVtYmVyICopXG4gICAqICAgIHN0X2lubyA6IGludDsgICAgICAgICAgICAgICAoKiogSW5vZGUgbnVtYmVyICopXG4gICAqICAgIHN0X2tpbmQgOiBmaWxlX2tpbmQ7ICAgICAgICAoKiogS2luZCBvZiB0aGUgZmlsZSAqKVxuICAgKiAgICBzdF9wZXJtIDogZmlsZV9wZXJtOyAgICAgICAgKCoqIEFjY2VzcyByaWdodHMgKilcbiAgICogICAgc3RfbmxpbmsgOiBpbnQ7ICAgICAgICAgICAgICgqKiBOdW1iZXIgb2YgbGlua3MgKilcbiAgICogICAgc3RfdWlkIDogaW50OyAgICAgICAgICAgICAgICgqKiBVc2VyIGlkIG9mIHRoZSBvd25lciAqKVxuICAgKiAgICBzdF9naWQgOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIEdyb3VwIElEIG9mIHRoZSBmaWxlJ3MgZ3JvdXAgKilcbiAgICogICAgc3RfcmRldiA6IGludDsgICAgICAgICAgICAgICgqKiBEZXZpY2UgSUQgKGlmIHNwZWNpYWwgZmlsZSkgKilcbiAgICogICAgc3Rfc2l6ZSA6IGludDsgICAgICAgICAgICAgICgqKiBTaXplIGluIGJ5dGVzICopXG4gICAqICAgIHN0X2F0aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBhY2Nlc3MgdGltZSAqKVxuICAgKiAgICBzdF9tdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3QgbW9kaWZpY2F0aW9uIHRpbWUgKilcbiAgICogICAgc3RfY3RpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IHN0YXR1cyBjaGFuZ2UgdGltZSAqKVxuICAgKiAgfVxuICAgKi9cbiAgcmV0dXJuIEJMT0NLKFxuICAgIDAsXG4gICAganNfc3RhdHMuZGV2LFxuICAgIGpzX3N0YXRzLmlubyxcbiAgICBmaWxlX2tpbmQsXG4gICAganNfc3RhdHMubW9kZSxcbiAgICBqc19zdGF0cy5ubGluayxcbiAgICBqc19zdGF0cy51aWQsXG4gICAganNfc3RhdHMuZ2lkLFxuICAgIGpzX3N0YXRzLnJkZXYsXG4gICAganNfc3RhdHMuc2l6ZSxcbiAgICBqc19zdGF0cy5hdGltZU1zLFxuICAgIGpzX3N0YXRzLm10aW1lTXMsXG4gICAganNfc3RhdHMuY3RpbWVNc1xuICApO1xufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKCkge1xufVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVGZFxuLy9SZXF1aXJlczogTWxGaWxlLCBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZywgY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcywgY2FtbF9ieXRlc19zZXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBNbE5vZGVGZChmZCwgZmxhZ3Mpe1xuICB0aGlzLmZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdGhpcy5mZCA9IGZkO1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG59XG5NbE5vZGVGZC5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuTWxOb2RlRmQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRmQ7XG5cbk1sTm9kZUZkLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5mdHJ1bmNhdGVTeW5jKHRoaXMuZmQsbGVufDApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZkLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZnN0YXRTeW5jKHRoaXMuZmQpLnNpemU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1ZixidWZfb2Zmc2V0LGxlbil7XG4gIHRyeSB7XG4gICAgaWYodGhpcy5mbGFncy5pc0NoYXJhY3RlckRldmljZSlcbiAgICAgIHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZiwgYnVmX29mZnNldCwgbGVuKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLmZzLndyaXRlU3luYyh0aGlzLmZkLCBidWYsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuTWxOb2RlRmQucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYSxidWZfb2Zmc2V0LGxlbil7XG4gIHRyeSB7XG4gICAgaWYodGhpcy5mbGFncy5pc0NoYXJhY3RlckRldmljZSlcbiAgICAgIHZhciByZWFkID0gdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBhLCBidWZfb2Zmc2V0LCBsZW4pO1xuICAgIGVsc2VcbiAgICAgIHZhciByZWFkID0gdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBhLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gICAgcmV0dXJuIHJlYWQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmNsb3NlU3luYyh0aGlzLmZkKTtcbiAgICByZXR1cm4gMFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVGZFxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gTWxOb2RlRmQoKXtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlXG4vL1JlcXVpcmVzOiBNbE5vZGVGZFxuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZShmZCwgZmxhZ3Mpe1xuICBpZihmbGFncy5uYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICAgIHZhciBmZDIgPSBmcy5vcGVuU3luYyhmbGFncy5uYW1lLCBcInJzXCIpO1xuICAgICAgcmV0dXJuIG5ldyBNbE5vZGVGZChmZDIsIGZsYWdzKTtcbiAgICB9IGNhdGNoKGUpIHsgIH1cbiAgfVxuICByZXR1cm4gbmV3IE1sTm9kZUZkKGZkLCBmbGFncyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5fZm9yX25vZGVcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW5fZm9yX25vZGUoZmQsIGZsYWdzKXtcbiAgcmV0dXJuIG51bGw7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIER1bW15IGZpbGVzeXN0ZW1cblxuLy9Qcm92aWRlczogY2FtbF90cmFpbGluZ19zbGFzaFxuZnVuY3Rpb24gY2FtbF90cmFpbGluZ19zbGFzaChuYW1lKXtcbiAgcmV0dXJuIChuYW1lLnNsaWNlKC0xKSAhPT0gXCIvXCIpID8gKG5hbWUgKyBcIi9cIikgOiBuYW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3RyYWlsaW5nX3NsYXNoLCBmc19ub2RlX3N1cHBvcnRlZFxuaWYoZnNfbm9kZV9zdXBwb3J0ZWQgKCkgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5jd2QpXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gZ2xvYmFsVGhpcy5wcm9jZXNzLmN3ZCgpLnJlcGxhY2UoL1xcXFwvZywnLycpO1xuZWxzZVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9ICBcIi9zdGF0aWNcIjtcbmNhbWxfY3VycmVudF9kaXIgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKGNhbWxfY3VycmVudF9kaXIpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9yb290XG4vL1JlcXVpcmVzOiBwYXRoX2lzX2Fic29sdXRlXG5mdW5jdGlvbiBjYW1sX2dldF9yb290KHBhdGgpe1xuICB2YXIgeCA9IHBhdGhfaXNfYWJzb2x1dGUocGF0aCk7XG4gIGlmICgheCkgcmV0dXJuO1xuICByZXR1cm4geFswXSArIFwiL1wifVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Jvb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ2V0X3Jvb3QsIGNhbWxfY3VycmVudF9kaXIsIGNhbWxfZmFpbHdpdGhcbnZhciBjYW1sX3Jvb3QgPSBjYW1sX2dldF9yb290KGNhbWxfY3VycmVudF9kaXIpIHx8IGNhbWxfZmFpbHdpdGgoXCJ1bmFibGUgdG8gY29tcHV0ZSBjYW1sX3Jvb3RcIik7XG5cblxuLy9Qcm92aWRlczogTWxGaWxlXG5mdW5jdGlvbiBNbEZpbGUoKXsgIH1cblxuLy9Qcm92aWRlczogcGF0aF9pc19hYnNvbHV0ZVxuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIG1ha2VfcGF0aF9pc19hYnNvbHV0ZSgpIHtcbiAgZnVuY3Rpb24gcG9zaXgocGF0aCkge1xuICAgIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSByZXR1cm4gW1wiXCIsIHBhdGguc3Vic3RyaW5nKDEpXTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmdW5jdGlvbiB3aW4zMihwYXRoKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvYjNmY2MyNDVmYjI1NTM5OTA5ZWYxZDVlYWEwMWRiZjkyZTE2ODYzMy9saWIvcGF0aC5qcyNMNTZcbiAgICB2YXIgc3BsaXREZXZpY2VSZSA9IC9eKFthLXpBLVpdOnxbXFxcXC9dezJ9W15cXFxcL10rW1xcXFwvXStbXlxcXFwvXSspPyhbXFxcXC9dKT8oW1xcc1xcU10qPykkLztcbiAgICB2YXIgcmVzdWx0ID0gc3BsaXREZXZpY2VSZS5leGVjKHBhdGgpO1xuICAgIHZhciBkZXZpY2UgPSByZXN1bHRbMV0gfHwgJyc7XG4gICAgdmFyIGlzVW5jID0gQm9vbGVhbihkZXZpY2UgJiYgZGV2aWNlLmNoYXJBdCgxKSAhPT0gJzonKTtcblxuICAgIC8vIFVOQyBwYXRocyBhcmUgYWx3YXlzIGFic29sdXRlXG4gICAgaWYgKEJvb2xlYW4ocmVzdWx0WzJdIHx8IGlzVW5jKSkge1xuICAgICAgdmFyIHJvb3QgPSAocmVzdWx0WzFdIHx8ICcnKTtcbiAgICAgIHZhciBzZXAgPSAocmVzdWx0WzJdIHx8ICcnKTtcbiAgICAgIHJldHVybiBbcm9vdCwgcGF0aC5zdWJzdHJpbmcocm9vdC5sZW5ndGggKyBzZXAubGVuZ3RoKV1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmKGZzX25vZGVfc3VwcG9ydGVkICgpICYmIGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0pIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIgOiBwb3NpeDtcbiAgfVxuICBlbHNlIHJldHVybiBwb3NpeFxufVxudmFyIHBhdGhfaXNfYWJzb2x1dGUgPSBtYWtlX3BhdGhfaXNfYWJzb2x1dGUoKTtcblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3BhdGhcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nLCBwYXRoX2lzX2Fic29sdXRlXG5mdW5jdGlvbiBjYW1sX21ha2VfcGF0aCAobmFtZSkge1xuICBuYW1lPWNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICBpZiggIXBhdGhfaXNfYWJzb2x1dGUobmFtZSkgKVxuICAgIG5hbWUgPSBjYW1sX2N1cnJlbnRfZGlyICsgbmFtZTtcbiAgdmFyIGNvbXAwID0gcGF0aF9pc19hYnNvbHV0ZShuYW1lKTtcbiAgdmFyIGNvbXAgPSBjb21wMFsxXS5zcGxpdChcIi9cIik7XG4gIHZhciBuY29tcCA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGk8Y29tcC5sZW5ndGg7IGkrKyl7XG4gICAgc3dpdGNoKGNvbXBbaV0pe1xuICAgIGNhc2UgXCIuLlwiOiBpZihuY29tcC5sZW5ndGg+MSkgbmNvbXAucG9wKCk7IGJyZWFrO1xuICAgIGNhc2UgXCIuXCI6IGJyZWFrO1xuICAgIGNhc2UgXCJcIjogYnJlYWs7XG4gICAgZGVmYXVsdDogbmNvbXAucHVzaChjb21wW2ldKTticmVha1xuICAgIH1cbiAgfVxuICBuY29tcC51bnNoaWZ0KGNvbXAwWzBdKTtcbiAgbmNvbXAub3JpZyA9IG5hbWU7XG4gIHJldHVybiBuY29tcDtcbn1cblxuLy9Qcm92aWRlczpqc29vX21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIE1sTm9kZURldmljZSwgY2FtbF9yb290LCBmc19ub2RlX3N1cHBvcnRlZFxudmFyIGpzb29fbW91bnRfcG9pbnQgPSBbXVxuaWYgKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShjYW1sX3Jvb3QpfSk7XG59IGVsc2Uge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn1cbmpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpcIi9zdGF0aWMvXCIsIGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKFwiL3N0YXRpYy9cIil9KTtcblxuLy9Qcm92aWRlczpjYW1sX2xpc3RfbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGlzdF9tb3VudF9wb2ludCgpe1xuICB2YXIgcHJldiA9IDBcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspe1xuICAgIHZhciBvbGQgPSBwcmV2O1xuICAgIHByZXYgPSBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhqc29vX21vdW50X3BvaW50W2ldLnBhdGgpLCBvbGRdXG4gIH1cbiAgcmV0dXJuIHByZXY7XG59XG5cbi8vUHJvdmlkZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludCwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2V0X3Jvb3QsIE1sTm9kZURldmljZSwgY2FtbF90cmFpbGluZ19zbGFzaCwgZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIik7XG4gIHZhciBuYW1lX3NsYXNoID0gY2FtbF90cmFpbGluZ19zbGFzaChuYW1lKTtcbiAgdmFyIHJlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbSA9IGpzb29fbW91bnRfcG9pbnRbaV07XG4gICAgaWYobmFtZV9zbGFzaC5zZWFyY2gobS5wYXRoKSA9PSAwXG4gICAgICAgJiYgKCFyZXMgfHwgcmVzLnBhdGgubGVuZ3RoIDwgbS5wYXRoLmxlbmd0aCkpXG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICB9XG4gIGlmKCAhcmVzICYmIGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAgICB2YXIgcm9vdCA9IGNhbWxfZ2V0X3Jvb3QobmFtZSk7XG4gICAgaWYgKHJvb3QgJiYgcm9vdC5tYXRjaCgvXlthLXpBLVpdOlxcLyQvKSl7XG4gICAgICB2YXIgbSA9IHtwYXRoOnJvb3QsZGV2aWNlOm5ldyBNbE5vZGVEZXZpY2Uocm9vdCl9O1xuICAgICAganNvb19tb3VudF9wb2ludC5wdXNoKG0pO1xuICAgICAgcmVzID0ge3BhdGg6bS5wYXRoLGRldmljZTptLmRldmljZSxyZXN0Om5hbWUuc3Vic3RyaW5nKG0ucGF0aC5sZW5ndGgsbmFtZS5sZW5ndGgpfTtcbiAgICB9XG4gIH1cbiAgaWYoIHJlcyApIHJldHVybiByZXM7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwibm8gZGV2aWNlIGZvdW5kIGZvciBcIiArIG5hbWVfc2xhc2gpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vdW50X2F1dG9sb2FkXG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50LCBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX21vdW50X2F1dG9sb2FkKG5hbWUsZil7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gY2FtbF90cmFpbGluZ19zbGFzaChwYXRoLmpvaW4oXCIvXCIpKTtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOm5hbWUsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UobmFtZSxmKX0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VubW91bnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfbWFrZV9wYXRoLCBjYW1sX3RyYWlsaW5nX3NsYXNoXG5mdW5jdGlvbiBjYW1sX3VubW91bnQobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gY2FtbF90cmFpbGluZ19zbGFzaChwYXRoLmpvaW4oXCIvXCIpKTtcbiAgdmFyIGlkeCA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKylcbiAgICBpZihqc29vX21vdW50X3BvaW50W2ldLnBhdGggPT0gbmFtZSkgaWR4ID0gaTtcbiAgaWYoaWR4ID4gLTEpIGpzb29fbW91bnRfcG9pbnQuc3BsaWNlKGlkeCwxKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0Y3dkXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRjd2QoKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfY3VycmVudF9kaXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jaGRpclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19jaGRpcihkaXIpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkaXIpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIGlmKHJvb3QucmVzdCkgY2FtbF9jdXJyZW50X2RpciA9IGNhbWxfdHJhaWxpbmdfc2xhc2gocm9vdC5wYXRoICsgcm9vdC5yZXN0KTtcbiAgICBlbHNlIGNhbWxfY3VycmVudF9kaXIgPSByb290LnBhdGg7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhkaXIpKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpe1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9hX2RpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2FfZGlyKG5hbWUpe1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2ZpbGVfZXhpc3RzXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfZmlsZV9leGlzdHMgKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfYV9kaXIsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5yZWFkZGlyKHJvb3QucmVzdCk7XG4gIHZhciBsID0gbmV3IEFycmF5KGEubGVuZ3RoICsgMSk7XG4gIGxbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGEubGVuZ3RoO2krKylcbiAgICBsW2krMV0gPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGFbaV0pO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVtb3ZlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbW92ZShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIG9rID0gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCk7XG4gIGlmKG9rID09IDApIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLmlzX2Rpcihyb290LnJlc3QpO1xuICByZXR1cm4gYT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbmFtZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbmFtZShvLG4pe1xuICB2YXIgb19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobyk7XG4gIHZhciBuX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuKTtcbiAgaWYob19yb290LmRldmljZSAhPSBuX3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IGNhbm5vdCBtb3ZlIGZpbGUgYmV0d2VlbiB0d28gZmlsZXN5c3RlbVwiKTtcbiAgaWYoIW9fcm9vdC5kZXZpY2UucmVuYW1lKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IG5vIGltcGxlbWVudGVkXCIpO1xuICBvX3Jvb3QuZGV2aWNlLnJlbmFtZShvX3Jvb3QucmVzdCwgbl9yb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19ta2RpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3N5c19ta2RpcihuYW1lLCBwZXJtKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcm9vdC5kZXZpY2UubWtkaXIocm9vdC5yZXN0LHBlcm0pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcm1kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV9ub3RfYV9kaXJcbmZ1bmN0aW9uIGNhbWxfc3lzX3JtZGlyKG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByb290LmRldmljZS5ybWRpcihyb290LnJlc3QpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZSh2ZmQsIGtpbmQsIGxheW91dCwgc2hhcmVkLCBkaW1zLCBwb3MpIHtcbiAgLy8gdmFyIGRhdGEgPSBjYW1sX3N5c19mZHNbdmZkXTtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfYmFfbWFwX2ZpbGUgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX21hcF9maWxlXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlKGFyZ3YsYXJnbil7XG4gIHJldHVybiBjYW1sX2JhX21hcF9maWxlKGFyZ3ZbMF0sYXJndlsxXSxhcmd2WzJdLGFyZ3ZbM10sYXJndls0XSxhcmd2WzVdKTtcbn1cblxuLy9Qcm92aWRlczoganNvb19jcmVhdGVfZmlsZV9leHRlcm5cbmZ1bmN0aW9uIGpzb29fY3JlYXRlX2ZpbGVfZXh0ZXJuKG5hbWUsY29udGVudCl7XG4gIGlmKGdsb2JhbFRoaXMuanNvb19jcmVhdGVfZmlsZSlcbiAgICBnbG9iYWxUaGlzLmpzb29fY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KTtcbiAgZWxzZSB7XG4gICAgaWYoIWdsb2JhbFRoaXMuY2FtbF9mc190bXApIGdsb2JhbFRoaXMuY2FtbF9mc190bXAgPSBbXTtcbiAgICBnbG9iYWxUaGlzLmNhbWxfZnNfdG1wLnB1c2goe25hbWU6bmFtZSxjb250ZW50OmNvbnRlbnR9KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mc19pbml0XG4vL1JlcXVpcmVzOiBqc29vX2NyZWF0ZV9maWxlXG5mdW5jdGlvbiBjYW1sX2ZzX2luaXQgKCl7XG4gIHZhciB0bXA9Z2xvYmFsVGhpcy5jYW1sX2ZzX3RtcFxuICBpZih0bXApe1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpKyspe1xuICAgICAganNvb19jcmVhdGVfZmlsZSh0bXBbaV0ubmFtZSx0bXBbaV0uY29udGVudCk7XG4gICAgfVxuICB9XG4gIGdsb2JhbFRoaXMuanNvb19jcmVhdGVfZmlsZSA9IGpzb29fY3JlYXRlX2ZpbGU7XG4gIGdsb2JhbFRoaXMuY2FtbF9mc190bXAgPSBbXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZighIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKSBjYW1sX2ZhaWx3aXRoKFwiY2Fubm90IHJlZ2lzdGVyIGZpbGVcIik7XG4gIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKHJvb3QucmVzdCxjb250ZW50KTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczoganNvb19jcmVhdGVfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfZmlsZSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24ganNvb19jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpIHtcbiAgdmFyIG5hbWUgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpO1xuICB2YXIgY29udGVudCA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY29udGVudCk7XG4gIHJldHVybiBjYW1sX2NyZWF0ZV9maWxlKG5hbWUsIGNvbnRlbnQpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVhZF9maWxlX2NvbnRlbnRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmVhZF9maWxlX2NvbnRlbnQgKG5hbWUpIHtcbiAgdmFyIG5hbWUgPSAodHlwZW9mIG5hbWUgPT0gXCJzdHJpbmdcIik/Y2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKTpuYW1lO1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3Qse3Jkb25seToxfSk7XG4gICAgdmFyIGxlbiAgPSBmaWxlLmxlbmd0aCgpO1xuICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGZpbGUucmVhZCgwLGJ1ZiwwLGxlbik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGJ1ZilcbiAgfVxuICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpKTtcbn1cbiIsIi8vUHJvdmlkZXM6IGNhbWxfdW5peF9nZXR0aW1lb2ZkYXlcbi8vQWxpYXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiBjYW1sX3VuaXhfZ2V0dGltZW9mZGF5ICgpIHtcbiAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfdGltZVxuLy9SZXF1aXJlczogY2FtbF91bml4X2dldHRpbWVvZmRheVxuLy9BbGlhczogdW5peF90aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfdGltZSAoKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGNhbWxfdW5peF9nZXR0aW1lb2ZkYXkgKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZ210aW1lXG4vL0FsaWFzOiB1bml4X2dtdGltZVxuZnVuY3Rpb24gY2FtbF91bml4X2dtdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFVUQ1NlY29uZHMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgICAgICAgIGQuZ2V0VVRDRGF0ZSgpLCBkLmdldFVUQ01vbnRoKCksIGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgICAgICBkLmdldFVUQ0RheSgpLCBkb3ksXG4gICAgICAgICAgICAgICBmYWxzZSB8IDAgLyogZm9yIFVUQyBkYXlsaWdodCBzYXZpbmdzIHRpbWUgaXMgZmFsc2UgKi8pXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9sb2NhbHRpbWVcbi8vQWxpYXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiBjYW1sX3VuaXhfbG9jYWx0aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICB2YXIgamFuID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgdmFyIGp1bCA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XG4gIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KGphbi5nZXRUaW1lem9uZU9mZnNldCgpLCBqdWwuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFNlY29uZHMoKSwgZC5nZXRNaW51dGVzKCksIGQuZ2V0SG91cnMoKSxcbiAgICAgICAgICAgICAgIGQuZ2V0RGF0ZSgpLCBkLmdldE1vbnRoKCksIGQuZ2V0RnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgICAgICBkLmdldERheSgpLCBkb3ksXG4gICAgICAgICAgICAgICAoZC5nZXRUaW1lem9uZU9mZnNldCgpIDwgc3RkVGltZXpvbmVPZmZzZXQpIHwgMCAvKiBkYXlsaWdodCBzYXZpbmdzIHRpbWUgIGZpZWxkLiAqLylcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X21rdGltZVxuLy9SZXF1aXJlczogY2FtbF91bml4X2xvY2FsdGltZVxuLy9BbGlhczogdW5peF9ta3RpbWVcbmZ1bmN0aW9uIGNhbWxfdW5peF9ta3RpbWUodG0pe1xuICB2YXIgZCA9IChuZXcgRGF0ZSh0bVs2XSsxOTAwLHRtWzVdLHRtWzRdLHRtWzNdLHRtWzJdLHRtWzFdKSkuZ2V0VGltZSgpO1xuICB2YXIgdCA9IE1hdGguZmxvb3IoZCAvIDEwMDApO1xuICB2YXIgdG0yID0gY2FtbF91bml4X2xvY2FsdGltZSh0KTtcbiAgcmV0dXJuIEJMT0NLKDAsdCx0bTIpO1xufVxuLy9Qcm92aWRlczogY2FtbF91bml4X3N0YXJ0dXAgY29uc3Rcbi8vQWxpYXM6IHdpbl9zdGFydHVwXG5mdW5jdGlvbiBjYW1sX3VuaXhfc3RhcnR1cCgpIHt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9jbGVhbnVwIGNvbnN0XG4vL0FsaWFzOiB3aW5fY2xlYW51cFxuZnVuY3Rpb24gY2FtbF91bml4X2NsZWFudXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmlsZWRlc2NyX29mX2ZkIGNvbnN0XG4vL0FsaWFzOiB3aW5faGFuZGxlX2ZkXG5mdW5jdGlvbiBjYW1sX3VuaXhfZmlsZWRlc2NyX29mX2ZkKHgpIHtyZXR1cm4geDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9pc2F0dHlcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG4vL0FsaWFzOiB1bml4X2lzYXR0eVxuZnVuY3Rpb24gY2FtbF91bml4X2lzYXR0eShmaWxlRGVzY3JpcHRvcikge1xuICBpZihmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuICAgIHJldHVybiB0dHkuaXNhdHR5KGZpbGVEZXNjcmlwdG9yKT8xOjA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfaXNhdHR5XG4vL0FsaWFzOiB1bml4X2lzYXR0eVxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gY2FtbF91bml4X2lzYXR0eShmaWxlRGVzY3JpcHRvcikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbWFrZV91bml4X2Vycl9hcmdzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIHVuaXhfZXJyb3IgPSBbXG4gIC8qID09PVVuaXguZXJyb3I9PT1cbiAgICpcbiAgICogVGhpcyBhcnJheSBpcyBpbiBvcmRlciBvZiB0aGUgdmFyaWFudCBpbiBPQ2FtbFxuICAgKi9cbiAgXCJFMkJJR1wiLCBcIkVBQ0NFU1wiLCBcIkVBR0FJTlwiLCBcIkVCQURGXCIsIFwiRUJVU1lcIiwgXCJFQ0hJTERcIiwgXCJFREVBRExLXCIsIFwiRURPTVwiLFxuICBcIkVFWElTVFwiLCBcIkVGQVVMVFwiLCBcIkVGQklHXCIsIFwiRUlOVFJcIiwgXCJFSU5WQUxcIiwgXCJFSU9cIiwgXCJFSVNESVJcIiwgXCJFTUZJTEVcIixcbiAgXCJFTUxJTktcIiwgXCJFTkFNRVRPT0xPTkdcIiwgXCJFTkZJTEVcIiwgXCJFTk9ERVZcIiwgXCJFTk9FTlRcIiwgXCJFTk9FWEVDXCIsIFwiRU5PTENLXCIsXG4gIFwiRU5PTUVNXCIsIFwiRU5PU1BDXCIsIFwiRU5PU1lTXCIsIFwiRU5PVERJUlwiLCBcIkVOT1RFTVBUWVwiLCBcIkVOT1RUWVwiLCBcIkVOWElPXCIsXG4gIFwiRVBFUk1cIiwgXCJFUElQRVwiLCBcIkVSQU5HRVwiLCBcIkVST0ZTXCIsIFwiRVNQSVBFXCIsIFwiRVNSQ0hcIiwgXCJFWERFVlwiLCBcIkVXT1VMREJMT0NLXCIsXG4gIFwiRUlOUFJPR1JFU1NcIiwgXCJFQUxSRUFEWVwiLCBcIkVOT1RTT0NLXCIsIFwiRURFU1RBRERSUkVRXCIsIFwiRU1TR1NJWkVcIixcbiAgXCJFUFJPVE9UWVBFXCIsIFwiRU5PUFJPVE9PUFRcIiwgXCJFUFJPVE9OT1NVUFBPUlRcIiwgXCJFU09DS1ROT1NVUFBPUlRcIixcbiAgXCJFT1BOT1RTVVBQXCIsIFwiRVBGTk9TVVBQT1JUXCIsIFwiRUFGTk9TVVBQT1JUXCIsIFwiRUFERFJJTlVTRVwiLCBcIkVBRERSTk9UQVZBSUxcIixcbiAgXCJFTkVURE9XTlwiLCBcIkVORVRVTlJFQUNIXCIsIFwiRU5FVFJFU0VUXCIsIFwiRUNPTk5BQk9SVEVEXCIsIFwiRUNPTk5SRVNFVFwiLCBcIkVOT0JVRlNcIixcbiAgXCJFSVNDT05OXCIsIFwiRU5PVENPTk5cIiwgXCJFU0hVVERPV05cIiwgXCJFVE9PTUFOWVJFRlNcIiwgXCJFVElNRURPVVRcIiwgXCJFQ09OTlJFRlVTRURcIixcbiAgXCJFSE9TVERPV05cIiwgXCJFSE9TVFVOUkVBQ0hcIiwgXCJFTE9PUFwiLCBcIkVPVkVSRkxPV1wiXG5dO1xuZnVuY3Rpb24gbWFrZV91bml4X2Vycl9hcmdzKGNvZGUsIHN5c2NhbGwsIHBhdGgsIGVycm5vKSB7XG4gIHZhciB2YXJpYW50ID0gdW5peF9lcnJvci5pbmRleE9mKGNvZGUpO1xuICBpZiAodmFyaWFudCA8IDApIHtcbiAgICAvLyBEZWZhdWx0IGlmIHVuZGVmaW5lZFxuICAgIGlmIChlcnJubyA9PSBudWxsKSB7XG4gICAgICBlcnJubyA9IC05OTk5XG4gICAgfVxuICAgIC8vIElmIG5vbmUgb2YgdGhlIGFib3ZlIHZhcmlhbnRzLCBmYWxsYmFjayB0byBFVU5LTk9XTkVSUihpbnQpXG4gICAgdmFyaWFudCA9IEJMT0NLKDAsIGVycm5vKTtcbiAgfVxuICB2YXIgYXJncyA9IFtcbiAgICB2YXJpYW50LFxuICAgIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHN5c2NhbGwgfHwgXCJcIiksXG4gICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGF0aCB8fCBcIlwiKVxuICBdO1xuICByZXR1cm4gYXJncztcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3N0YXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3N0YXRcbmZ1bmN0aW9uIGNhbWxfdW5peF9zdGF0KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5zdGF0KSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9zdGF0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnN0YXQocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfc3RhdF82NFxuLy9SZXF1aXJlczogY2FtbF91bml4X3N0YXQsIGNhbWxfaW50NjRfb2ZfaW50MzJcbi8vQWxpYXM6IHVuaXhfc3RhdF82NFxuZnVuY3Rpb24gY2FtbF91bml4X3N0YXRfNjQobmFtZSkge1xuICB2YXIgciA9IGNhbWxfdW5peF9zdGF0KG5hbWUpO1xuICByWzldID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihyWzldKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9sc3RhdFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfbHN0YXRcbmZ1bmN0aW9uIGNhbWxfdW5peF9sc3RhdChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UubHN0YXQpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X2xzdGF0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmxzdGF0KHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2xzdGF0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfbHN0YXQsIGNhbWxfaW50NjRfb2ZfaW50MzJcbi8vQWxpYXM6IHVuaXhfbHN0YXRfNjRcbmZ1bmN0aW9uIGNhbWxfdW5peF9sc3RhdF82NChuYW1lKSB7XG4gIHZhciByID0gY2FtbF91bml4X2xzdGF0KG5hbWUpO1xuICByWzldID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihyWzldKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9ta2RpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfbWtkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9ta2RpcihuYW1lLCBwZXJtKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UubWtkaXIpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X21rZGlyOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLm1rZGlyKHJvb3QucmVzdCwgcGVybSwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JtZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9ybWRpclxuZnVuY3Rpb24gY2FtbF91bml4X3JtZGlyKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5ybWRpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfcm1kaXI6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2Uucm1kaXIocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfc3ltbGlua1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfZmFpbHdpdGhcbi8vQWxpYXM6IHVuaXhfc3ltbGlua1xuZnVuY3Rpb24gY2FtbF91bml4X3N5bWxpbmsodG9fZGlyLCBzcmMsIGRzdCkge1xuICB2YXIgc3JjX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShzcmMpO1xuICB2YXIgZHN0X3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkc3QpO1xuICBpZihzcmNfcm9vdC5kZXZpY2UgIT0gZHN0X3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfc3ltbGluazogY2Fubm90IHN5bWxpbmsgYmV0d2VlbiB0d28gZmlsZXN5c3RlbXNcIik7XG4gIGlmICghc3JjX3Jvb3QuZGV2aWNlLnN5bWxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF91bml4X3N5bWxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gc3JjX3Jvb3QuZGV2aWNlLnN5bWxpbmsodG9fZGlyLCBzcmNfcm9vdC5yZXN0LCBkc3Rfcm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfcmVhZGxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3JlYWRsaW5rXG5mdW5jdGlvbiBjYW1sX3VuaXhfcmVhZGxpbmsobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnJlYWRsaW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF9yZWFkbGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5yZWFkbGluayhyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF91bmxpbmtcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG4vL0FsaWFzOiB1bml4X3VubGlua1xuZnVuY3Rpb24gY2FtbF91bml4X3VubGluayhuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UudW5saW5rKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfdW5peF91bmxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2dldHVpZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vQWxpYXM6IHVuaXhfZ2V0dWlkXG5mdW5jdGlvbiBjYW1sX3VuaXhfZ2V0dWlkKHVuaXQpIHtcbiAgaWYoZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5nZXR1aWQpe1xuICAgIHJldHVybiBnbG9iYWxUaGlzLnByb2Nlc3MuZ2V0dWlkKCk7XG4gIH1cbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2dldHB3dWlkXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9BbGlhczogdW5peF9nZXRwd3VpZFxuZnVuY3Rpb24gY2FtbF91bml4X2dldHB3dWlkKHVuaXQpIHtcbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2hhc19zeW1saW5rXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9BbGlhczogdW5peF9oYXNfc3ltbGlua1xuZnVuY3Rpb24gY2FtbF91bml4X2hhc19zeW1saW5rKHVuaXQpIHtcbiAgcmV0dXJuIGZzX25vZGVfc3VwcG9ydGVkKCk/MTowXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9vcGVuZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuLy9BbGlhczogdW5peF9vcGVuZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfb3BlbmRpcihwYXRoKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UocGF0aCk7XG4gIGlmICghcm9vdC5kZXZpY2Uub3BlbmRpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3VuaXhfb3BlbmRpcjogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHZhciBkaXJfaGFuZGxlID0gcm9vdC5kZXZpY2Uub3BlbmRpcihyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG4gIHJldHVybiB7IHBvaW50ZXIgOiBkaXJfaGFuZGxlLCBwYXRoOiBwYXRoIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X3JlYWRkaXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBtYWtlX3VuaXhfZXJyX2FyZ3MsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlXG4vL0FsaWFzOiB1bml4X3JlYWRkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9yZWFkZGlyKGRpcl9oYW5kbGUpIHtcbiAgdmFyIGVudHJ5O1xuICB0cnkge1xuICAgICAgZW50cnkgPSBkaXJfaGFuZGxlLnBvaW50ZXIucmVhZFN5bmMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgICAgdmFyIHVuaXhfZXJyb3IgPSBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVCQURGXCIsIFwicmVhZGRpclwiLCBkaXJfaGFuZGxlLnBhdGgpKTtcbiAgfVxuICBpZiAoZW50cnkgPT09IG51bGwpIHtcbiAgICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhlbnRyeS5uYW1lKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfY2xvc2VkaXJcbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJncywgY2FtbF9yYWlzZV93aXRoX2FyZ3MsIGNhbWxfbmFtZWRfdmFsdWVcbi8vQWxpYXM6IHVuaXhfY2xvc2VkaXJcbmZ1bmN0aW9uIGNhbWxfdW5peF9jbG9zZWRpcihkaXJfaGFuZGxlKSB7XG4gIHRyeSB7XG4gICAgICBkaXJfaGFuZGxlLnBvaW50ZXIuY2xvc2VTeW5jKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHZhciB1bml4X2Vycm9yID0gY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFQkFERlwiLCBcImNsb3NlZGlyXCIsIGRpcl9oYW5kbGUucGF0aCkpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9yZXdpbmRkaXJcbi8vUmVxdWlyZXM6IGNhbWxfdW5peF9jbG9zZWRpciwgY2FtbF91bml4X29wZW5kaXJcbi8vQWxpYXM6IHVuaXhfcmV3aW5kZGlyXG5mdW5jdGlvbiBjYW1sX3VuaXhfcmV3aW5kZGlyKGRpcl9oYW5kbGUpIHtcbiAgY2FtbF91bml4X2Nsb3NlZGlyKGRpcl9oYW5kbGUpO1xuICB2YXIgbmV3X2Rpcl9oYW5kbGUgPSBjYW1sX3VuaXhfb3BlbmRpcihkaXJfaGFuZGxlLnBhdGgpO1xuICBkaXJfaGFuZGxlLnBvaW50ZXIgPSBuZXdfZGlyX2hhbmRsZS5wb2ludGVyO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bml4X2ZpbmRmaXJzdFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfb3BlbmRpciwgY2FtbF91bml4X3JlYWRkaXJcbi8vQWxpYXM6IHdpbl9maW5kZmlyc3RcbmZ1bmN0aW9uIGNhbWxfdW5peF9maW5kZmlyc3QocGF0aCkge1xuICAvLyBUaGUgV2luZG93cyBjb2RlIGFkZHMgdGhpcyBnbG9iIHRvIHRoZSBwYXRoLCBzbyB3ZSBuZWVkIHRvIHJlbW92ZSBpdFxuICB2YXIgcGF0aF9qcyA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBhdGgpO1xuICBwYXRoX2pzID0gcGF0aF9qcy5yZXBsYWNlKC8oXnxbXFxcXFxcL10pXFwqXFwuXFwqJC8sIFwiXCIpO1xuICBwYXRoID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGF0aF9qcyk7XG4gIC8vICouKiBpcyBub3cgc3RyaXBwZWRcbiAgdmFyIGRpcl9oYW5kbGUgPSBjYW1sX3VuaXhfb3BlbmRpcihwYXRoKTtcbiAgdmFyIGZpcnN0X2VudHJ5ID0gY2FtbF91bml4X3JlYWRkaXIoZGlyX2hhbmRsZSk7XG4gIC8vIFRoZSBXaW5kb3dzIGJpbmRpbmdzIHR5cGUgZGlyX2hhbmRsZSBhcyBhbiBgaW50YCBidXQgaXQncyBub3QgaW4gSlNcbiAgcmV0dXJuIFswLCBmaXJzdF9lbnRyeSwgZGlyX2hhbmRsZV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9maW5kbmV4dFxuLy9SZXF1aXJlczogY2FtbF91bml4X3JlYWRkaXJcbi8vQWxpYXM6IHdpbl9maW5kbmV4dFxuZnVuY3Rpb24gY2FtbF91bml4X2ZpbmRuZXh0KGRpcl9oYW5kbGUpIHtcbiAgcmV0dXJuIGNhbWxfdW5peF9yZWFkZGlyKGRpcl9oYW5kbGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VuaXhfZmluZGNsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX3VuaXhfY2xvc2VkaXJcbi8vQWxpYXM6IHdpbl9maW5kY2xvc2VcbmZ1bmN0aW9uIGNhbWxfdW5peF9maW5kY2xvc2UoZGlyX2hhbmRsZSkge1xuICByZXR1cm4gY2FtbF91bml4X2Nsb3NlZGlyKGRpcl9oYW5kbGUpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nIGNvbnN0XG4vL0FsaWFzOiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nICgpIHtyZXR1cm4gMDt9XG5cblxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogTWxGYWtlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBNbEZha2VGZCwgY2FtbF9jcmVhdGVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXksIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3JhaXNlX3dpdGhfYXJncywgY2FtbF9uYW1lZF92YWx1ZXNcbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJnc1xuZnVuY3Rpb24gTWxGYWtlRGV2aWNlIChyb290LCBmKSB7XG4gIHRoaXMuY29udGVudD17fTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5sb29rdXBGdW4gPSBmO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuY3JlYXRlX2Rpcl9pZl9uZWVkZWQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjb21wID0gbmFtZS5zcGxpdChcIi9cIik7XG4gIHZhciByZXMgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgY29tcC5sZW5ndGggLSAxOyBpKyspe1xuICAgIHJlcyArPSBjb21wW2ldICsgXCIvXCI7XG4gICAgaWYodGhpcy5jb250ZW50W3Jlc10pIGNvbnRpbnVlO1xuICAgIHRoaXMuY29udGVudFtyZXNdID0gU3ltYm9sKFwiZGlyZWN0b3J5XCIpO1xuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnNsYXNoID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiAvXFwvJC8udGVzdChuYW1lKT9uYW1lOihuYW1lICsgXCIvXCIpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKCF0aGlzLmNvbnRlbnRbbmFtZV0gJiYgdGhpcy5sb29rdXBGdW4pIHtcbiAgICB2YXIgcmVzID0gdGhpcy5sb29rdXBGdW4oY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnJvb3QpLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpKTtcbiAgICBpZihyZXMgIT09IDApIHtcbiAgICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgICB0aGlzLmNvbnRlbnRbbmFtZV09bmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcocmVzWzFdKSk7XG4gICAgfVxuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgLy8gVGhlIHJvb3Qgb2YgdGhlIGRldmljZSBleGlzdHNcbiAgaWYobmFtZSA9PSBcIlwiKSByZXR1cm4gMTtcbiAgLy8gQ2hlY2sgaWYgYSBkaXJlY3RvcnkgZXhpc3RzXG4gIHZhciBuYW1lX3NsYXNoID0gdGhpcy5zbGFzaChuYW1lKTtcbiAgaWYodGhpcy5jb250ZW50W25hbWVfc2xhc2hdKSByZXR1cm4gMTtcbiAgLy8gQ2hlY2sgaWYgYSBmaWxlIGV4aXN0c1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lXT8xOjA7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmlzRmlsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYodGhpcy5leGlzdHMobmFtZSkgJiYgIXRoaXMuaXNfZGlyKG5hbWUpKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gMFxuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm1rZGlyID0gZnVuY3Rpb24obmFtZSxtb2RlLCByYWlzZV91bml4KSB7XG4gIHZhciB1bml4X2Vycm9yID0gcmFpc2VfdW5peCAmJiBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcbiAgaWYodGhpcy5leGlzdHMobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRUVYSVNUXCIsIFwibWtkaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogRmlsZSBleGlzdHNcIik7XG4gICAgfVxuICB9XG4gIHZhciBwYXJlbnQgPSAvXiguKilcXC9bXi9dKy8uZXhlYyhuYW1lKTtcbiAgcGFyZW50ID0gKHBhcmVudCAmJiBwYXJlbnRbMV0pIHx8ICcnO1xuICBpZighdGhpcy5leGlzdHMocGFyZW50KSl7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT0VOVFwiLCBcIm1rZGlyXCIsIHRoaXMubm0ocGFyZW50KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHBhcmVudCArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICBpZighdGhpcy5pc19kaXIocGFyZW50KSl7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RESVJcIiwgXCJta2RpclwiLCB0aGlzLm5tKHBhcmVudCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihwYXJlbnQgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKHRoaXMuc2xhc2gobmFtZSkpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ybWRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSByYWlzZV91bml4ICYmIGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KHRoaXMuc2xhc2gobmFtZSkpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSspXCIpO1xuICBpZighdGhpcy5leGlzdHMobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PRU5UXCIsIFwicm1kaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgaWYoIXRoaXMuaXNfZGlyKG5hbWUpKSB7XG4gICAgaWYgKHVuaXhfZXJyb3IpIHtcbiAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RESVJcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICBpZihuLm1hdGNoKHIpKSB7XG4gICAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9URU1QVFlcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCI6IERpcmVjdG9yeSBub3QgZW1wdHlcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlbGV0ZSB0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF07XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoodGhpcy5zbGFzaChuYW1lKSk7XG4gIGlmKCF0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbiAgfVxuICBpZighdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgfVxuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSspXCIpO1xuICB2YXIgc2VlbiA9IHt9XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSAmJiAhc2VlblttWzFdXSkge3NlZW5bbVsxXV0gPSB0cnVlOyBhLnB1c2gobVsxXSl9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW5kaXIgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHZhciB1bml4X2Vycm9yID0gcmFpc2VfdW5peCAmJiBjYW1sX25hbWVkX3ZhbHVlKCdVbml4LlVuaXhfZXJyb3InKTtcblxuICB2YXIgYSA9IHRoaXMucmVhZGRpcihuYW1lKTtcbiAgdmFyIGMgPSBmYWxzZTtcbiAgdmFyIGkgPSAwO1xuICByZXR1cm4geyByZWFkU3luYyA6IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGMpIHtcbiAgICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVCQURGXCIsIFwiY2xvc2VkaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogY2xvc2VkaXIgZmFpbGVkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihpID09IGEubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgZW50cnkgPSBhW2ldO1xuICAgIGkrKztcbiAgICByZXR1cm4geyBuYW1lOiBlbnRyeSB9XG4gIH0pXG4gICAgLCBjbG9zZVN5bmM6IChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYykge1xuICAgICAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVCQURGXCIsIFwiY2xvc2VkaXJcIiwgdGhpcy5ubShuYW1lKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogY2xvc2VkaXIgZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjID0gdHJ1ZTtcbiAgICAgIGEgPSBbXTtcbiAgICB9KVxuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYobmFtZSA9PSBcIlwiKSAgcmV0dXJuIHRydWU7XG4gIHZhciBuYW1lX3NsYXNoID0gdGhpcy5zbGFzaChuYW1lKTtcbiAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lX3NsYXNoXT8xOjA7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG9rID0gdGhpcy5jb250ZW50W25hbWVdP3RydWU6ZmFsc2U7XG4gIGRlbGV0ZSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIHJldHVybiBvaztcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgdmFyIGZpbGU7XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGlzIGEgZGlyZWN0b3J5XCIpO1xuICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgICBpZihmLnRydW5jYXRlKSBmaWxlLnRydW5jYXRlKCk7XG4gIH0gZWxzZSBpZiAoZi5jcmVhdGUpIHtcbiAgICB0aGlzLmNyZWF0ZV9kaXJfaWZfbmVlZGVkKG5hbWUpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgICBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlICh0aGlzLm5tKG5hbWUpKTtcbiAgfVxuICByZXR1cm4gbmV3IE1sRmFrZUZkKHRoaXMubm0obmFtZSksIGZpbGUsIGYpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIHZhciBmaWxlO1xuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICBpZiAodGhpcy5jb250ZW50W25hbWVdKSB7XG4gICAgaWYgKHRoaXMuaXNfZGlyKG5hbWUpKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBpcyBhIGRpcmVjdG9yeVwiKTtcbiAgICBpZiAoZi5jcmVhdGUgJiYgZi5leGNsKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gICAgaWYoZi50cnVuY2F0ZSkgZmlsZS50cnVuY2F0ZSgpO1xuICB9IGVsc2UgaWYgKGYuY3JlYXRlKSB7XG4gICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gICAgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSAodGhpcy5ubShuYW1lKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBNbEZha2VGZCh0aGlzLm5tKG5hbWUpLCBmaWxlLCBmKTtcbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWdpc3Rlcj0gZnVuY3Rpb24gKG5hbWUsY29udGVudCl7XG4gIHZhciBmaWxlO1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV0pIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gIGlmKGNhbWxfaXNfbWxfYnl0ZXMoY29udGVudCkpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNvbnRlbnQpO1xuICBpZihjYW1sX2lzX21sX3N0cmluZyhjb250ZW50KSlcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheSlcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9hcnJheShjb250ZW50KSk7XG4gIGVsc2UgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudC50b1N0cmluZykge1xuICAgIHZhciBieXRlcyA9IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGNvbnRlbnQudG9TdHJpbmcoKSkpO1xuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShieXRlcyk7XG4gIH1cbiAgaWYoZmlsZSl7XG4gICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBmaWxlO1xuICB9XG4gIGVsc2UgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogcmVnaXN0ZXJpbmcgZmlsZSB3aXRoIGludmFsaWQgY29udGVudCB0eXBlXCIpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbmZ1bmN0aW9uIE1sRmFrZUZpbGUoY29udGVudCl7XG4gIHRoaXMuZGF0YSA9IGNvbnRlbnQ7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZUZpbGVcbk1sRmFrZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdmFyIG9sZCA9IHRoaXMuZGF0YTtcbiAgdGhpcy5kYXRhID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVufDApO1xuICBjYW1sX2JsaXRfYnl0ZXMob2xkLCAwLCB0aGlzLmRhdGEsIDAsIGxlbik7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aCh0aGlzLmRhdGEpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGlmKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgdmFyIG5ld19zdHIgPSBjYW1sX2NyZWF0ZV9ieXRlcyhvZmZzZXQgKyBsZW4pO1xuICAgIHZhciBvbGRfZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmRhdGEgPSBuZXdfc3RyO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhvbGRfZGF0YSwgMCwgdGhpcy5kYXRhLCAwLCBjbGVuKTtcbiAgfVxuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShidWYpLCBwb3MsIHRoaXMuZGF0YSwgb2Zmc2V0LCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYob2Zmc2V0ICsgbGVuID49IGNsZW4pIHtcbiAgICBsZW4gPSBjbGVuIC0gb2Zmc2V0O1xuICB9XG4gIGlmKGxlbikge1xuICAgIHZhciBkYXRhID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVufDApO1xuICAgIGNhbWxfYmxpdF9ieXRlcyh0aGlzLmRhdGEsIG9mZnNldCwgZGF0YSwgMCwgbGVuKTtcbiAgICBidWYuc2V0KGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMoZGF0YSksIHBvcyk7XG4gIH1cbiAgcmV0dXJuIGxlblxufVxuXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZkX291dFxuLy9SZXF1aXJlczogTWxGYWtlRmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sRmFrZUZkX291dChmZCxmbGFncykge1xuICBNbEZha2VGaWxlLmNhbGwodGhpcywgY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICB0aGlzLmxvZyA9IChmdW5jdGlvbiAocykgeyByZXR1cm4gMCB9KTtcbiAgaWYoZmQgPT0gMSAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT0gXCJmdW5jdGlvblwiKVxuICAgIHRoaXMubG9nID0gY29uc29sZS5sb2c7XG4gIGVsc2UgaWYoZmQgPT0gMiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhpcy5sb2cgPSBjb25zb2xlLmVycm9yO1xuICBlbHNlIGlmKHR5cGVvZiBjb25zb2xlLmxvZyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhpcy5sb2cgPSBjb25zb2xlLmxvZ1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG59XG5NbEZha2VGZF9vdXQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMCB9XG5NbEZha2VGZF9vdXQucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG9mZnNldCxidWYscG9zLGxlbikge1xuICBpZih0aGlzLmxvZykge1xuICAgIGlmKGxlbiA+IDBcbiAgICAgICAmJiBwb3MgPj0gMFxuICAgICAgICYmIHBvcytsZW4gPD0gYnVmLmxlbmd0aFxuICAgICAgICYmIGJ1Zltwb3MrbGVuLTFdID09IDEwKVxuICAgICAgbGVuIC0tO1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIHZhciBzcmMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KGJ1ZiksIHBvcywgc3JjLCAwLCBsZW4pO1xuICAgIHRoaXMubG9nKHNyYy50b1V0ZjE2KCkpO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMuZmQgICsgXCI6IGZpbGUgZGVzY3JpcHRvciBhbHJlYWR5IGNsb3NlZFwiKTtcbn1cbk1sRmFrZUZkX291dC5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pIHtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5mZCAgKyBcIjogZmlsZSBkZXNjcmlwdG9yIGlzIHdyaXRlIG9ubHlcIik7XG59XG5NbEZha2VGZF9vdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxvZyA9IHVuZGVmaW5lZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGZFxuLy9SZXF1aXJlczogTWxGYWtlRmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sRmFrZUZkKG5hbWUsIGZpbGUsZmxhZ3MpIHtcbiAgdGhpcy5maWxlID0gZmlsZTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xufVxuXG5NbEZha2VGZC5wcm90b3R5cGUuZXJyX2Nsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5uYW1lICArIFwiOiBmaWxlIGRlc2NyaXB0b3IgYWxyZWFkeSBjbG9zZWRcIik7XG59XG5NbEZha2VGZC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMuZmlsZSkgcmV0dXJuIHRoaXMuZmlsZS5sZW5ndGggKClcbiAgdGhpcy5lcnJfY2xvc2VkKCk7XG59XG5NbEZha2VGZC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAob2Zmc2V0LGJ1Zixwb3MsbGVuKSB7XG4gIGlmKHRoaXMuZmlsZSkgcmV0dXJuIHRoaXMuZmlsZS53cml0ZShvZmZzZXQsYnVmLHBvcyxsZW4pXG4gIHRoaXMuZXJyX2Nsb3NlZCgpO1xufVxuTWxGYWtlRmQucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAob2Zmc2V0LCBidWYsIHBvcywgbGVuKSB7XG4gIGlmKHRoaXMuZmlsZSkgcmV0dXJuIHRoaXMuZmlsZS5yZWFkKG9mZnNldCwgYnVmLCBwb3MsIGxlbilcbiAgdGhpcy5lcnJfY2xvc2VkKCk7XG59XG5NbEZha2VGZC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZmlsZSA9IHVuZGVmaW5lZDtcbn1cbiIsIi8vUHJvdmlkZXM6IGluaXRpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IHNlcmlhbGl6ZV9uYXQsIGRlc2VyaWFsaXplX25hdCwgY2FtbF9oYXNoX25hdFxuZnVuY3Rpb24gaW5pdGlhbGl6ZV9uYXQoKSB7XG4gIGNhbWxfY3VzdG9tX29wc1tcIl9uYXRcIl0gPVxuICAgIHsgZGVzZXJpYWxpemUgOiBkZXNlcmlhbGl6ZV9uYXQsXG4gICAgICBzZXJpYWxpemUgOiBzZXJpYWxpemVfbmF0LFxuICAgICAgaGFzaCA6IGNhbWxfaGFzaF9uYXRcbiAgICB9XG59XG5cbi8vUHJvdmlkZXM6IE1sTmF0XG5mdW5jdGlvbiBNbE5hdCh4KXtcbiAgdGhpcy5kYXRhID0gbmV3IEludDMyQXJyYXkoeCk7XG4gIC8vIEZvciBudW0gPCAxLjVcbiAgLy8gbGVuZ3RoX25hdCBpc24ndCBleHRlcm5hbCwgc28gd2UgaGF2ZSB0byBtYWtlIHRoZSBPYmouc2l6ZVxuICAvLyB3b3JrIG91dCByaWdodC5cbiAgLy8gV2UgYWRkICsyIHRvIHRoZSBhcnJheSBsZW5ndGg6XG4gIC8vIC0gKzEgZm9yIHRoZSB0YWdcbiAgLy8gLSArMSBmb3IgdGhlIGN1c3RvbV9vcHMgc2xvdFxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggKyAyXG59XG5cbk1sTmF0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX25hdFwiO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9uYXQoeCkge1xuICB2YXIgbGVuID0gbnVtX2RpZ2l0c19uYXQoeCwgMCwgeC5kYXRhLmxlbmd0aCk7XG4gIHZhciBoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB4LmRhdGFbaV0pO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBsZW5ndGhfbmF0XG5mdW5jdGlvbiBsZW5ndGhfbmF0KHgpIHtcbiAgcmV0dXJuIHguZGF0YS5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IG5hdF9vZl9hcnJheVxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIG5hdF9vZl9hcnJheShsKXtcbiAgcmV0dXJuIG5ldyBNbE5hdChsKTtcbn1cblxuLy9Qcm92aWRlczogY3JlYXRlX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGNyZWF0ZV9uYXQoc2l6ZSkge1xuICB2YXIgYXJyID0gbmV3IE1sTmF0KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgYXJyLmRhdGFbaV0gPSAtMTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfdG9femVyb19uYXRcbmZ1bmN0aW9uIHNldF90b196ZXJvX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJsaXRfbmF0XG5mdW5jdGlvbiBibGl0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBuYXQyLmRhdGFbb2ZzMitpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdFxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdChuYXQsIG9mcywgZGlnaXQpIHtcbiAgbmF0LmRhdGFbb2ZzXSA9IGRpZ2l0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbnRoX2RpZ2l0X25hdFxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdChuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdF9uYXRpdmVcbmZ1bmN0aW9uIHNldF9kaWdpdF9uYXRfbmF0aXZlKG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMpIHtcbiAgcmV0dXJuIG5hdC5kYXRhW29mc107XG59XG5cbi8vUHJvdmlkZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBudW1fZGlnaXRzX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYobmF0LmRhdGFbb2ZzK2ldICE9IDApIHJldHVybiBpKzE7XG4gIH1cbiAgcmV0dXJuIDE7IC8vIDAgY291bnRzIGFzIDEgZGlnaXRcbn1cblxuLy9Qcm92aWRlczogbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0XG5mdW5jdGlvbiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0LCBvZnMpIHtcbiAgdmFyIGEgPSBuYXQuZGF0YVtvZnNdO1xuICB2YXIgYiA9IDA7XG4gIGlmKGEgJiAweEZGRkYwMDAwKSB7IGIgKz0xNjsgYSA+Pj49MTY7IH1cbiAgaWYoYSAmIDB4RkYwMCkgICAgIHsgYiArPSA4OyBhID4+Pj0gODsgfVxuICBpZihhICYgMHhGMCkgICAgICAgeyBiICs9IDQ7IGEgPj4+PSA0OyB9XG4gIGlmKGEgJiAxMikgICAgICAgICB7IGIgKz0gMjsgYSA+Pj49IDI7IH1cbiAgaWYoYSAmIDIpICAgICAgICAgIHsgYiArPSAxOyBhID4+Pj0gMTsgfVxuICBpZihhICYgMSkgICAgICAgICAgeyBiICs9IDE7IH1cbiAgcmV0dXJuIDMyIC0gYjtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfaW50XG5mdW5jdGlvbiBpc19kaWdpdF9pbnQobmF0LCBvZnMpIHtcbiAgaWYgKG5hdC5kYXRhW29mc10gPj0gMCkgcmV0dXJuIDFcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X3plcm9cbmZ1bmN0aW9uIGlzX2RpZ2l0X3plcm8obmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSA9PSAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X29kZFxuZnVuY3Rpb24gaXNfZGlnaXRfb2RkKG5hdCwgb2ZzKSB7XG4gIGlmKG5hdC5kYXRhW29mc10gJiAxKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBpbmNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICh4IHwgMCk7XG4gICAgaWYoeCA9PSAoeCA+Pj4gMCkpIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBhZGRfbmF0XG4vL1JlcXVpcmVzOiBpbmNyX25hdFxuZnVuY3Rpb24gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHhcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmNyX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgY2FycnkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wbGVtZW50X25hdFxuZnVuY3Rpb24gY29tcGxlbWVudF9uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAoLTEgPj4+IDApIC0gKG5hdC5kYXRhW29mcytpXSA+Pj4gMCk7XG4gIH1cbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vUHJvdmlkZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBkZWNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcytpXSA+Pj4wKSAtIGJvcnJvdztcbiAgICBuYXQuZGF0YVtvZnMraV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChib3Jyb3cgPT0gMSkgPyAwIDogMTtcbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogc3ViX25hdFxuLy9SZXF1aXJlczogZGVjcl9uYXRcbmZ1bmN0aW9uIHN1Yl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IChjYXJyeV9pbiA9PSAxKSA/IDAgOiAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIC0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAtIGJvcnJvdztcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCAoYm9ycm93PT0xKT8wOjEpO1xufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzW29mczNdXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IG11bHRfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBhZGRfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGEgPSAobmF0My5kYXRhW29mczNdID4+PiAwKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4MSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICogKGEgJiAweDAwMDBGRkZGKSArIGNhcnJ5O1xuICAgIHZhciB4MiA9IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSA+Pj4gMTYpO1xuICAgIGNhcnJ5ID0gTWF0aC5mbG9vcih4Mi82NTUzNik7XG4gICAgdmFyIHgzID0geDEgKyAoeDIgJSA2NTUzNikgKiA2NTUzNjtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHgzO1xuICAgIGNhcnJ5ICs9IE1hdGguZmxvb3IoeDMvNDI5NDk2NzI5Nik7XG4gIH1cblxuICBpZihsZW4yIDwgbGVuMSAmJiBjYXJyeSkge1xuICAgIHJldHVybiBhZGRfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBuYXRfb2ZfYXJyYXkoW2NhcnJ5XSksIDAsIDEsIDApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYXJyeTtcbiAgfVxufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzXG4vLyBsZW4xID49IGxlbjIgKyBsZW4zLlxuLy9Qcm92aWRlczogbXVsdF9uYXRcbi8vUmVxdWlyZXM6IG11bHRfZGlnaXRfbmF0XG5mdW5jdGlvbiBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzLCBsZW4zKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4zOyBpKyspIHtcbiAgICBjYXJyeSArPSBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxK2ksIGxlbjEtaSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMytpKTtcbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIG5hdDEgPSAyICogbmF0MSArIG5hdDIgKiBuYXQyXG4vLyBsZW4xID49IDIgKiBsZW4yXG4vL1Byb3ZpZGVzOiBzcXVhcmVfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X25hdCwgYWRkX25hdFxuZnVuY3Rpb24gc3F1YXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGNhcnJ5ICs9IGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0MSwgb2ZzMSwgbGVuMSwgMCk7XG4gIGNhcnJ5ICs9IG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpO1xuICByZXR1cm4gY2Fycnk7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9sZWZ0X25hdFxuZnVuY3Rpb24gc2hpZnRfbGVmdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYobmJpdHMgPT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgdmFyIGEgPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPDwgbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA+Pj4gKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vLyBBc3N1bWluZyBjID4gYSwgcmV0dXJucyBbcXVvdGllbnQsIHJlbWFpbmRlcl0gb2YgKGE8PDMyICsgYikvY1xuLy9Qcm92aWRlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2hlbHBlcihhLCBiLCBjKSB7XG4gIHZhciB4ID0gYSAqIDY1NTM2ICsgKGI+Pj4xNik7XG4gIHZhciB5ID0gTWF0aC5mbG9vcih4L2MpICogNjU1MzY7XG4gIHZhciB6ID0gKHggJSBjKSAqIDY1NTM2O1xuICB2YXIgdyA9IHogKyAoYiAmIDB4MDAwMEZGRkYpO1xuICByZXR1cm4gW3kgKyBNYXRoLmZsb29yKHcvYyksIHcgJSBjXTtcbn1cblxuLy8gbmF0MVtvZnMxK2xlbl0gPCBuYXQyW29mczJdXG4vL1Byb3ZpZGVzOiBkaXZfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfZGlnaXRfbmF0KG5hdHEsIG9mc3EsIG5hdHIsIG9mc3IsIG5hdDEsIG9mczEsIGxlbiwgbmF0Miwgb2ZzMikge1xuICB2YXIgcmVtID0gKG5hdDEuZGF0YVtvZnMxK2xlbi0xXSA+Pj4wKTtcbiAgLy8gbmF0cVtvZnNxK2xlbi0xXSBpcyBndWFyYW50ZWVkIHRvIGJlIHplcm8gKGR1ZSB0byB0aGUgTVNEIHJlcXVpcmVtZW50KSxcbiAgLy8gYW5kIHNob3VsZCBub3QgYmUgd3JpdHRlbiB0by5cbiAgZm9yKHZhciBpID0gbGVuLTI7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHggPSBkaXZfaGVscGVyKHJlbSwgKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDIuZGF0YVtvZnMyXSA+Pj4gMCkpO1xuICAgIG5hdHEuZGF0YVtvZnNxK2ldID0geFswXTtcbiAgICByZW0gPSB4WzFdO1xuICB9XG4gIG5hdHIuZGF0YVtvZnNyXSA9IHJlbTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIG5hdDFbbmF0MjpdIDo9IG5hdDEgLyBuYXQyXG4vLyBuYXQxWzpuYXQyXSA6PSBuYXQxICUgbmF0MlxuLy8gbGVuMSA+IGxlbjIsIG5hdDJbb2ZzMitsZW4yLTFdID4gbmF0MVtvZnMxK2xlbjEtMV1cbi8vUHJvdmlkZXM6IGRpdl9uYXRcbi8vUmVxdWlyZXM6IGRpdl9kaWdpdF9uYXQsIGRpdl9oZWxwZXIsIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCwgc2hpZnRfbGVmdF9uYXQsIHNoaWZ0X3JpZ2h0X25hdCwgY3JlYXRlX25hdCwgc2V0X3RvX3plcm9fbmF0LCBtdWx0X2RpZ2l0X25hdCwgc3ViX25hdCwgY29tcGFyZV9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gZGl2X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIGlmKGxlbjIgPT0gMSkge1xuICAgIGRpdl9kaWdpdF9uYXQobmF0MSwgb2ZzMSsxLCBuYXQxLCBvZnMxLCBuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBzID0gbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0KG5hdDIsIG9mczIrbGVuMi0xKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG5cbiAgdmFyIGQgPSAobmF0Mi5kYXRhW29mczIrbGVuMi0xXSA+Pj4gMCkgKyAxO1xuICB2YXIgYSA9IGNyZWF0ZV9uYXQobGVuMisxKTtcbiAgZm9yICh2YXIgaSA9IGxlbjEgLSAxOyBpID49IGxlbjI7IGktLSkge1xuICAgIC8vIERlY2VudCBsb3dlciBib3VuZCBvbiBxdW9cbiAgICB2YXIgcXVvID0gZCA9PSA0Mjk0OTY3Mjk2ID8gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA6IGRpdl9oZWxwZXIoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDEuZGF0YVtvZnMxK2ktMV0gPj4+MCksIGQpWzBdO1xuICAgIHNldF90b196ZXJvX25hdChhLCAwLCBsZW4yKzEpO1xuICAgIG11bHRfZGlnaXRfbmF0KGEsIDAsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFtxdW9dKSwgMCk7XG4gICAgc3ViX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMisxLCBhLCAwLCBsZW4yKzEsIDEpO1xuXG4gICAgd2hpbGUgKG5hdDEuZGF0YVtvZnMxK2ldICE9IDAgfHwgY29tcGFyZV9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpID49IDApIHtcbiAgICAgIHF1byA9IHF1byArIDE7XG4gICAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIG5hdDIsIG9mczIsIGxlbjIsIDEpO1xuICAgIH1cblxuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gcXVvO1xuICB9XG5cbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gc2hpZnQgcmVtYWluZGVyXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHJlc3RvcmVcbiAgcmV0dXJuIDA7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9yaWdodF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IGxlbjEtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgYSA9IG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPj4+IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPDwgKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfZGlnaXRzX25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA+IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIDE7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA8IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRcbi8vUmVxdWlyZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBhID0gbnVtX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbGVuMSk7XG4gIHZhciBiID0gbnVtX2RpZ2l0c19uYXQobmF0Miwgb2ZzMiwgbGVuMik7XG4gIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgaWYoYSA8IGIpIHJldHVybiAtMTtcbiAgZm9yKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgPiAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApKSByZXR1cm4gMTtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA8IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRfcmVhbFxuLy9SZXF1aXJlczogY29tcGFyZV9uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0X3JlYWwobmF0MSxuYXQyKXtcbiAgcmV0dXJuIGNvbXBhcmVfbmF0KG5hdDEsMCxuYXQxLmRhdGEubGVuZ3RoLG5hdDIsMCxuYXQyLmRhdGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogbGFuZF9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxhbmRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdICY9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGxvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gfD0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbHhvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGx4b3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIF49IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogc2VyaWFsaXplX25hdFxuZnVuY3Rpb24gc2VyaWFsaXplX25hdCh3cml0ZXIsIG5hdCwgc3ope1xuICB2YXIgbGVuID0gbmF0LmRhdGEubGVuZ3RoO1xuICB3cml0ZXIud3JpdGUoMzIsIGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgd3JpdGVyLndyaXRlKDMyLCBuYXQuZGF0YVtpXSk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICBzelsxXSA9IGxlbiAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGRlc2VyaWFsaXplX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGRlc2VyaWFsaXplX25hdChyZWFkZXIsIHN6KXtcbiAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBuYXQgPSBuZXcgTWxOYXQobGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBuYXQuZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICByZXR1cm4gbmF0O1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IEh1Z28gSGV1emFyZFxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZVxudmFyIGNhbWxfZ3Jfc3RhdGU7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfZ2V0KCkge1xuICBpZihjYW1sX2dyX3N0YXRlKSB7XG4gICAgcmV0dXJuIGNhbWxfZ3Jfc3RhdGU7XG4gIH1cbiAgdGhyb3cgY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlKFswLGNhbWxfbmFtZWRfdmFsdWUoXCJHcmFwaGljcy5HcmFwaGljX2ZhaWx1cmVcIiksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJOb3QgaW5pdGlhbGl6ZWRcIildKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlLGNhbWxfZ3Jfc3RhdGVfaW5pdFxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KSB7XG4gIGNhbWxfZ3Jfc3RhdGU9Y3R4O1xuICBjYW1sX2dyX3N0YXRlX2luaXQoKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX29wZW5fZ3JhcGgoaW5mbyl7XG4gIHZhciBpbmZvID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoaW5mbyk7XG4gIGZ1bmN0aW9uIGdldChuYW1lKXtcbiAgICB2YXIgcmVzID0gaW5mby5tYXRjaChcIihefCwpICpcIituYW1lK1wiICo9ICooW2EtekEtWjAtOV9dKykgKigsfCQpXCIpO1xuICAgIGlmKHJlcykgcmV0dXJuIHJlc1syXTtcbiAgfVxuICB2YXIgc3BlY3MgPSBbXTtcbiAgaWYoIShpbmZvPT1cIlwiKSkgc3BlY3MucHVzaChpbmZvKTtcbiAgdmFyIHRhcmdldCA9IGdldChcInRhcmdldFwiKTtcbiAgaWYoIXRhcmdldCkgdGFyZ2V0PVwiXCI7XG4gIHZhciBzdGF0dXMgPSBnZXQoXCJzdGF0dXNcIik7XG4gIGlmKCFzdGF0dXMpIHNwZWNzLnB1c2goXCJzdGF0dXM9MVwiKVxuXG4gIHZhciB3ID0gZ2V0KFwid2lkdGhcIik7XG4gIHcgPSB3P3BhcnNlSW50KHcpOjIwMDtcbiAgc3BlY3MucHVzaChcIndpZHRoPVwiK3cpO1xuXG4gIHZhciBoID0gZ2V0KFwiaGVpZ2h0XCIpO1xuICBoID0gaD9wYXJzZUludChoKToyMDA7XG4gIHNwZWNzLnB1c2goXCJoZWlnaHQ9XCIraCk7XG5cbiAgdmFyIHdpbiA9IGdsb2JhbFRoaXMub3BlbihcImFib3V0OmJsYW5rXCIsdGFyZ2V0LHNwZWNzLmpvaW4oXCIsXCIpKTtcbiAgaWYoIXdpbikge2NhbWxfZmFpbHdpdGgoXCJHcmFwaGljcy5vcGVuX2dyYXBoOiBjYW5ub3Qgb3BlbiB0aGUgd2luZG93XCIpfVxuICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICB2YXIgY2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuICB2YXIgY3R4ID0gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLHcsaCk7XG4gIGN0eC5zZXRfdGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICBkb2MudGl0bGUgPSB0aXRsZTtcbiAgfTtcbiAgY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KTtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgYm9keS5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICBib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yLGNhbWxfZ3JfbW92ZXRvLGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aCxjYW1sX2dyX3NldF90ZXh0X3NpemUsY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2luaXQoKXtcbiAgY2FtbF9ncl9tb3ZldG8oY2FtbF9ncl9zdGF0ZS54LGNhbWxfZ3Jfc3RhdGUueSk7XG4gIGNhbWxfZ3JfcmVzaXplX3dpbmRvdyhjYW1sX2dyX3N0YXRlLndpZHRoLGNhbWxfZ3Jfc3RhdGUuaGVpZ2h0KTtcbiAgY2FtbF9ncl9zZXRfbGluZV93aWR0aChjYW1sX2dyX3N0YXRlLmxpbmVfd2lkdGgpO1xuICBjYW1sX2dyX3NldF90ZXh0X3NpemUoY2FtbF9ncl9zdGF0ZS50ZXh0X3NpemUpO1xuICBjYW1sX2dyX3NldF9mb250KGNhbWxfZ3Jfc3RhdGUuZm9udCk7XG4gIGNhbWxfZ3Jfc2V0X2NvbG9yKGNhbWxfZ3Jfc3RhdGUuY29sb3IpO1xuICBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUoY2FtbF9ncl9zdGF0ZS50aXRsZSk7XG4gIC8vY2FtbF9ncl9yZXNpemVfd2luZG93IG1pZ2h0IHJlc2V0IHNvbWUgY2FudmFzJyBwcm9wZXJ0aWVzXG4gIGNhbWxfZ3Jfc3RhdGUuY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpe1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHJldHVybiB7XG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBjYW52YXMgOiBjYW52YXMsXG4gICAgeCA6IDAsXG4gICAgeSA6IDAsXG4gICAgd2lkdGggOiB3LFxuICAgIGhlaWdodCA6IGgsXG4gICAgbGluZV93aWR0aCA6IDEsXG4gICAgZm9udCA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJmaXhlZFwiKSxcbiAgICB0ZXh0X3NpemUgOiAyNixcbiAgICBjb2xvciA6IDB4MDAwMDAwLFxuICAgIHRpdGxlIDogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKVxuICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RvY19vZl9zdGF0ZVxuZnVuY3Rpb24gY2FtbF9ncl9kb2Nfb2Zfc3RhdGUoc3RhdGUpIHtcbiAgaWYoc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQpXG4gICAgcmV0dXJuIHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gMDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUobmFtZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50aXRsZSA9IG5hbWU7XG4gIHZhciBqc25hbWUgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYocy5zZXRfdGl0bGUpIHMuc2V0X3RpdGxlKGpzbmFtZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3codyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpXG4gIHMud2lkdGggPSB3O1xuICBzLmhlaWdodCA9IGg7XG4gIHMuY2FudmFzLndpZHRoID0gdztcbiAgcy5jYW52YXMuaGVpZ2h0ID0gaDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xlYXJfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NsZWFyX2dyYXBoKCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSBzLndpZHRoO1xuICBzLmNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgLy8gIHMuY29udGV4dC5zdHJva2VSZWN0ICgwLiwgMC4sIHMud2lkdGgsIHMuaGVpZ2h0KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy53aWR0aDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy5oZWlnaHQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9jb2xvcihjb2xvcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgZnVuY3Rpb24gY29udmVydChudW1iZXIpIHtcbiAgICB2YXIgc3RyID0gJycgKyBudW1iZXIudG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgMikgc3RyID0gJzAnICsgc3RyO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyXG4gIHIgPSAoY29sb3IgPj4gMTYpICYgMHhmZixcbiAgZyA9IChjb2xvciA+PiA4KSAgJiAweGZmLFxuICBiID0gKGNvbG9yID4+IDApICAmIDB4ZmY7XG4gIHMuY29sb3I9Y29sb3I7XG4gIHZhciBjX3N0ciA9ICcjJyArIGNvbnZlcnQocikgKyBjb252ZXJ0KGcpICsgY29udmVydChiKTtcbiAgcy5jb250ZXh0LmZpbGxTdHlsZSA9ICAgY19zdHI7XG4gIHMuY29udGV4dC5zdHJva2VTdHlsZSA9IGNfc3RyO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcGxvdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcGxvdCh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbT1zLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKDEsMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgdmFyIGNvbG9yID0gcy5jb2xvcjtcbiAgZFswXSA9IChjb2xvciA+PiAxNikgJiAweGZmOyAvL3JcbiAgZFsxXSA9IChjb2xvciA+PiA4KSAgJiAweGZmLCAvL2dcbiAgZFsyXSA9IChjb2xvciA+PiAwKSAgJiAweGZmOyAvL2JcbiAgZFszXSA9IDB4RkY7IC8vYVxuICBzLng9eDtcbiAgcy55PXk7XG4gIHMuY29udGV4dC5wdXRJbWFnZURhdGEoaW0seCxzLmhlaWdodCAtIHkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9wb2ludF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcG9pbnRfY29sb3IoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0geSwxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHJldHVybiAoZFswXSA8PCAxNikgKyAoZFsxXSA8PCA4KSArIGRbMl07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21vdmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbW92ZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy54PXg7XG4gIHMueT15O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLnhcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy55XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2xpbmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbGluZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMuY29udGV4dC5saW5lVG8oeCxzLmhlaWdodCAtIHkpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5zdHJva2VSZWN0KHgscy5oZWlnaHQgLSB5LHcsLWgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2FyY19hdXgoY3R4LGN4LGN5LHJ5LHJ4LGExLGEyKXtcbiAgd2hpbGUoYTE+YTIpIGEyKz0zNjA7XG4gIGExIC89IDE4MDtcbiAgYTIgLz0gMTgwO1xuICB2YXIgcm90ID0gMCx4UG9zLHlQb3MseFBvc19wcmV2LHlQb3NfcHJldjtcbiAgdmFyIHNwYWNlID0gMjtcbiAgdmFyIG51bSA9ICgoKGEyIC0gYTEpICogTWF0aC5QSSAqICgocngrcnkpLzIpKSAvIHNwYWNlKSB8IDA7XG4gIHZhciBkZWx0YSA9IChhMiAtIGExKSAqIE1hdGguUEkgLyBudW07XG4gIHZhciBpID0gYTEgKiBNYXRoLlBJO1xuICBmb3IgKHZhciBqPTA7ajw9bnVtO2orKyl7XG4gICAgeFBvcyA9IGN4IC0gKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLmNvcyhyb3QgKiBNYXRoLlBJKTtcbiAgICB4UG9zID0geFBvcy50b0ZpeGVkKDIpO1xuICAgIHlQb3MgPSBjeSArIChyeSAqIE1hdGguY29zKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeVBvcyA9IHlQb3MudG9GaXhlZCgyKTtcbiAgICBpZiAoaj09MCkge1xuICAgICAgY3R4Lm1vdmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9IGVsc2UgaWYgKHhQb3NfcHJldiE9eFBvcyB8fCB5UG9zX3ByZXYhPXlQb3Mpe1xuICAgICAgY3R4LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9XG4gICAgeFBvc19wcmV2PXhQb3M7XG4gICAgeVBvc19wcmV2PXlQb3M7XG4gICAgaS09IGRlbHRhOy8vY2N3XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9saW5lX3dpZHRoKHcpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMubGluZV93aWR0aCA9IHc7XG4gIHMuY29udGV4dC5saW5lV2lkdGggPSB3XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5maWxsUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcG9seVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9wb2x5KGFyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8oYXJbMV1bMV0scy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIGZvcih2YXIgaSA9IDI7IGkgPCBhci5sZW5ndGg7IGkrKylcbiAgICBzLmNvbnRleHQubGluZVRvKGFyW2ldWzFdLHMuaGVpZ2h0IC0gYXJbaV1bMl0pO1xuICBzLmNvbnRleHQubGluZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cihzdHIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBtID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHN0cik7XG4gIHZhciBkeCA9IG0ud2lkdGg7XG4gIHMuY29udGV4dC5maWxsVGV4dChzdHIscy54LHMuaGVpZ2h0IC0gcy55KTtcbiAgcy54ICs9IGR4IHwgMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfY2hhcihjKXtcbiAgY2FtbF9ncl9kcmF3X3N0cihTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyaW5nKHN0cil7XG4gIGNhbWxfZ3JfZHJhd19zdHIoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoc3RyKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2ZvbnQoZil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5mb250ID0gZjtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShzaXplKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRleHRfc2l6ZSA9IHNpemU7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfdGV4dF9zaXplKHR4dCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIHcgPSBzLmNvbnRleHQubWVhc3VyZVRleHQoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcodHh0KSkud2lkdGg7XG4gIHJldHVybiBbMCx3LHMudGV4dF9zaXplXTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21ha2VfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21ha2VfaW1hZ2UoYXJyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaCA9IGFyci5sZW5ndGggLSAxIDtcbiAgdmFyIHcgPSBhcnJbMV0ubGVuZ3RoIC0gMTtcbiAgdmFyIGltID0gcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3LGgpO1xuICBmb3IodmFyIGk9MDtpPGg7aSsrKXtcbiAgICBmb3IodmFyIGo9MDtqPHc7aisrKXtcbiAgICAgIHZhciBjID0gYXJyW2krMV1baisxXTtcbiAgICAgIHZhciBvID0gaSoodyo0KSArIChqICogNCk7XG4gICAgICBpZihjID09IC0xKSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMV0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gYyA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gYyA+PiAgOCAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gYyA+PiAgMCAmIDBYZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMHhmZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGltXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2R1bXBfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2R1bXBfaW1hZ2UoaW0pe1xuICB2YXIgZGF0YSA9IFswXVxuICBmb3IodmFyIGk9MDsgaTxpbS5oZWlnaHQ7aSsrKXtcbiAgICBkYXRhW2krMV0gPSBbMF1cbiAgICBmb3IodmFyIGo9MDsgajxpbS53aWR0aDtqKyspe1xuICAgICAgdmFyIG8gPSBpKihpbS53aWR0aCo0KSArIChqICogNCksXG4gICAgICAgICAgciA9IGltLmRhdGFbbyswXSxcbiAgICAgICAgICBnID0gaW0uZGF0YVtvKzFdLFxuICAgICAgICAgIGIgPSBpbS5kYXRhW28rMl07XG4gICAgICBkYXRhW2krMV1baisxXSA9IChyIDw8IDE2KSArIChnIDw8IDgpICsgYlxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2ltYWdlKGltLHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgaWYoIWltLmltYWdlKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gICAgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5wdXRJbWFnZURhdGEoaW0sMCwwKTtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgZ2xvYmFsVGhpcy5JbWFnZSgpO1xuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHMuY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UseCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICAgICAgaW0uaW1hZ2UgPSBpbWFnZTtcbiAgICB9XG4gICAgaW1hZ2Uuc3JjID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgfSBlbHNlIHtcbiAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltLmltYWdlLHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3JlYXRlX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jcmVhdGVfaW1hZ2UoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh4LHkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9ibGl0X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9ibGl0X2ltYWdlKGltLHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltMiA9IHMuY29udGV4dC5nZXRJbWFnZURhdGEoeCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHksaW0ud2lkdGgsaW0uaGVpZ2h0KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbTIuZGF0YS5sZW5ndGg7IGkrPTQpe1xuICAgIGltLmRhdGFbaV0gPSBpbTIuZGF0YVtpXTtcbiAgICBpbS5kYXRhW2krMV0gPSBpbTIuZGF0YVtpKzFdO1xuICAgIGltLmRhdGFbaSsyXSA9IGltMi5kYXRhW2krMl07XG4gICAgaW0uZGF0YVtpKzNdID0gaW0yLmRhdGFbaSszXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2lnaW9faGFuZGxlclxuZnVuY3Rpb24gY2FtbF9ncl9zaWdpb19oYW5kbGVyKCl7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX3NpZ25hbFxuZnVuY3Rpb24gY2FtbF9ncl9zaWdpb19zaWduYWwoKXtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2FpdF9ldmVudFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl93YWl0X2V2ZW50KF9ldmwpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl93YWl0X2V2ZW50IG5vdCBJbXBsZW1lbnRlZDogdXNlIEdyYXBoaWNzX2pzIGluc3RlYWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3luY2hyb25pemVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3luY2hyb25pemUgKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9zeW5jaHJvbml6ZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3JlbWVtYmVyX21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfcmVtZW1iZXJfbW9kZSAoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3JlbWVtYmVyX21vZGUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kaXNwbGF5X21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfZGlzcGxheV9tb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9kaXNwbGF5X21vZGUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3dpbmRvd19pZFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl93aW5kb3dfaWQoYSkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl93aW5kb3dfaWQgbm90IEltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX29wZW5fc3Vid2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX29wZW5fc3Vid2luZG93KGEsYixjLGQpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3cgbm90IEltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3coYSkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3cgbm90IEltcGxlbWVudGVkXCIpO1xufVxuIiwiXG4vL1Byb3ZpZGVzOiBjYW1sX2N1c3RvbV9ldmVudF9pbmRleFxudmFyIGNhbWxfY3VzdG9tX2V2ZW50X2luZGV4ID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3JlZ2lzdGVyXG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9ldmVudF9pbmRleFxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3JlZ2lzdGVyKGV2ZW50X25hbWUsIGV2ZW50X3RhZywgZXZlbnRfdHlwZSkge1xuICBjYW1sX2N1c3RvbV9ldmVudF9pbmRleCArPSAxO1xuICByZXR1cm4gWzAsIGNhbWxfY3VzdG9tX2V2ZW50X2luZGV4LCBldmVudF9uYW1lLCBldmVudF90eXBlLCBldmVudF90YWddO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3VzZXJfd3JpdGVcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl93cml0ZShldmVudCwgZXZlbnRfY29udGVudCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c191c2VyX3Jlc29sdmVcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfdXNlcl9yZXNvbHZlKCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c19zdGFydFxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c19zdGFydCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9ldmVudHNfcGF1c2VcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfcGF1c2UoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX3Jlc3VtZVxuZnVuY3Rpb24gY2FtbF9ydW50aW1lX2V2ZW50c19yZXN1bWUoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX2NyZWF0ZV9jdXJzb3JcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfY3JlYXRlX2N1cnNvcih0YXJnZXQpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfZXZlbnRzX2ZyZWVfY3Vyc29yXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfZXZlbnRzX2ZyZWVfY3Vyc29yKGN1cnNvcikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX2V2ZW50c19yZWFkX3BvbGxcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9ldmVudHNfcmVhZF9wb2xsKGN1cnNvciwgY2FsbGJhY2tzLCBudW0pIHtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2NvbnN0YW50c1xudmFyIGNhbWxfbWFyc2hhbF9jb25zdGFudHMgPSB7XG4gIFBSRUZJWF9TTUFMTF9CTE9DSzogICAgICAgICAweDgwLFxuICBQUkVGSVhfU01BTExfSU5UOiAgICAgICAgICAgMHg0MCxcbiAgUFJFRklYX1NNQUxMX1NUUklORzogICAgICAgIDB4MjAsXG4gIENPREVfSU5UODogICAgICAgICAgICAgICAgICAweDAwLFxuICBDT0RFX0lOVDE2OiAgICAgICAgICAgICAgICAgMHgwMSxcbiAgQ09ERV9JTlQzMjogICAgICAgICAgICAgICAgIDB4MDIsXG4gIENPREVfSU5UNjQ6ICAgICAgICAgICAgICAgICAweDAzLFxuICBDT0RFX1NIQVJFRDg6ICAgICAgICAgICAgICAgMHgwNCxcbiAgQ09ERV9TSEFSRUQxNjogICAgICAgICAgICAgIDB4MDUsXG4gIENPREVfU0hBUkVEMzI6ICAgICAgICAgICAgICAweDA2LFxuICBDT0RFX0JMT0NLMzI6ICAgICAgICAgICAgICAgMHgwOCxcbiAgQ09ERV9CTE9DSzY0OiAgICAgICAgICAgICAgIDB4MTMsXG4gIENPREVfU1RSSU5HODogICAgICAgICAgICAgICAweDA5LFxuICBDT0RFX1NUUklORzMyOiAgICAgICAgICAgICAgMHgwQSxcbiAgQ09ERV9ET1VCTEVfQklHOiAgICAgICAgICAgIDB4MEIsXG4gIENPREVfRE9VQkxFX0xJVFRMRTogICAgICAgICAweDBDLFxuICBDT0RFX0RPVUJMRV9BUlJBWThfQklHOiAgICAgMHgwRCxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTogIDB4MEUsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfQklHOiAgICAweDBGLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTogMHgwNyxcbiAgQ09ERV9DT0RFUE9JTlRFUjogICAgICAgICAgIDB4MTAsXG4gIENPREVfSU5GSVhQT0lOVEVSOiAgICAgICAgICAweDExLFxuICBDT0RFX0NVU1RPTTogICAgICAgICAgICAgICAgMHgxMixcbiAgQ09ERV9DVVNUT01fTEVOOiAgICAgICAgICAgIDB4MTgsXG4gIENPREVfQ1VTVE9NX0ZJWEVEOiAgICAgICAgICAweDE5XG59XG5cblxuLy9Qcm92aWRlczogVUludDhBcnJheVJlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIFVJbnQ4QXJyYXlSZWFkZXIgKHMsIGkpIHsgdGhpcy5zID0gczsgdGhpcy5pID0gaTsgfVxuVUludDhBcnJheVJlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNbdGhpcy5pKytdOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zW3RoaXMuaSsrXSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzW2ldIDw8IDgpIHwgc1tpICsgMV1cbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzW2ldIDw8IDI0ID4+IDE2KSB8IHNbaSArIDFdO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChzW2ldIDw8IDI0KSB8IChzW2krMV0gPDwgMTYpIHxcbiAgICAgICAgICAgIChzW2krMl0gPDwgOCkgfCBzW2krM10pID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKHNbaV0gPDwgMjQpIHwgKHNbaSsxXSA8PCAxNikgfFxuICAgICAgKHNbaSsyXSA8PCA4KSB8IHNbaSszXTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkodGhpcy5zLnN1YmFycmF5KGksIGkgKyBsZW4pKTtcbiAgfSxcbiAgcmVhZHVpbnQ4YXJyYXk6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIHRoaXMucy5zdWJhcnJheShpLCBpICsgbGVuKTtcbiAgfVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sU3RyaW5nUmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBNbFN0cmluZ1JlYWRlciAocywgaSkgeyB0aGlzLnMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpOyB0aGlzLmkgPSBpOyB9XG5NbFN0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnMuY2hhckNvZGVBdCh0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnMuY2hhckNvZGVBdCh0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCA+PiAxNikgfCBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKSkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXModGhpcy5zLnN1YnN0cmluZyhpLCBpICsgbGVuKSk7XG4gIH0sXG4gIHJlYWR1aW50OGFycmF5OmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgdmFyIHMgPSB0aGlzLnM7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBiW2pdID0gcy5jaGFyQ29kZUF0KGkgKyBqKTtcbiAgICB9XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gYjtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBCaWdTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBCaWdTdHJpbmdSZWFkZXIgKGJzLCBpKSB7IHRoaXMucyA9IGJzOyB0aGlzLmkgPSBpOyB9XG5CaWdTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCA4KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgMjQgPj4gMTYpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMykgICAgICAgICApID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspe1xuICAgICAgYXJyW2pdID0gY2FtbF9iYV9nZXRfMSh0aGlzLnMsIGkraik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIH0sXG4gIHJlYWR1aW50OGFycmF5OmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoaSk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gdGhpcy5zLmRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICB9XG59XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKGEpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoY2FtbF9pbnQ2NF9vZl9ieXRlcyAoYSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sU3RyaW5nUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxTdHJpbmdSZWFkZXIgKHMsIHR5cGVvZiBvZnM9PVwibnVtYmVyXCI/b2ZzOm9mc1swXSk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAoY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocyksIHR5cGVvZiBvZnM9PVwibnVtYmVyXCI/b2ZzOm9mc1swXSk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gIHNpemVbMF0gPSA4O1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyAodCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tYXJzaGFsKHdyaXRlciwgdiwgc2l6ZXMpIHtcbiAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzICh2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHdyaXRlci53cml0ZSAoOCwgYltpXSk7XG4gIHNpemVzWzBdID0gODsgc2l6ZXNbMV0gPSA4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX3VubWFyc2hhbFxuZnVuY3Rpb24gY2FtbF9pbnQzMl91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgc2l6ZVswXSA9IDQ7XG4gIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgc3dpdGNoIChyZWFkZXIucmVhZDh1ICgpKSB7XG4gIGNhc2UgMTpcbiAgICBzaXplWzBdID0gNDtcbiAgICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG4gIGNhc2UgMjpcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IG5hdGl2ZSBpbnRlZ2VyIHZhbHVlIHRvbyBsYXJnZVwiKTtcbiAgZGVmYXVsdDogY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG5hdGl2ZSBpbnRlZ2VyXCIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF91bm1hcnNoYWwsIGNhbWxfaW50NjRfbWFyc2hhbCwgY2FtbF9pbnQ2NF9jb21wYXJlLCBjYW1sX2ludDY0X2hhc2hcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsLCBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfYmFfc2VyaWFsaXplLCBjYW1sX2JhX2Rlc2VyaWFsaXplLCBjYW1sX2JhX2NvbXBhcmUsIGNhbWxfYmFfaGFzaFxudmFyIGNhbWxfY3VzdG9tX29wcyA9XG4gICAge1wiX2pcIjoge1xuICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX2ludDY0X3VubWFyc2hhbCxcbiAgICAgIHNlcmlhbGl6ZSAgOiBjYW1sX2ludDY0X21hcnNoYWwsXG4gICAgICBmaXhlZF9sZW5ndGggOiA4LFxuICAgICAgY29tcGFyZSA6IGNhbWxfaW50NjRfY29tcGFyZSxcbiAgICAgIGhhc2ggOiBjYW1sX2ludDY0X2hhc2hcbiAgICB9LFxuICAgICBcIl9pXCI6IHtcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50MzJfdW5tYXJzaGFsLFxuICAgICAgIGZpeGVkX2xlbmd0aCA6IDQsXG4gICAgIH0sXG4gICAgIFwiX25cIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsLFxuICAgICAgIGZpeGVkX2xlbmd0aCA6IDQsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycmF5XCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnJheVwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9LFxuICAgICBcIl9iaWdhcnIwMlwiOntcbiAgICAgICBkZXNlcmlhbGl6ZSA6IChmdW5jdGlvbiAocmVhZGVyLCBzeikge3JldHVybiBjYW1sX2JhX2Rlc2VyaWFsaXplIChyZWFkZXIsc3osXCJfYmlnYXJyMDJcIil9KSxcbiAgICAgICBzZXJpYWxpemUgOiBjYW1sX2JhX3NlcmlhbGl6ZSxcbiAgICAgICBjb21wYXJlIDogY2FtbF9iYV9jb21wYXJlLFxuICAgICAgIGhhc2g6IGNhbWxfYmFfaGFzaCxcbiAgICAgfVxuICAgIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2Zsb2F0X29mX2J5dGVzLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IFVJbnQ4QXJyYXlSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfZGVjb21wcmVzc19pbnB1dFxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcykge1xuICBmdW5jdGlvbiByZWFkdmxxKG92ZXJmbG93KSB7XG4gICAgdmFyIGMgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgdmFyIG4gPSBjICYgMHg3RjtcbiAgICB3aGlsZSAoKGMgJiAweDgwKSAhPSAwKSB7XG4gICAgICBjID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIG43ID0gbiA8PCA3O1xuICAgICAgaWYgKG4gIT0gbjcgPj4gNykgb3ZlcmZsb3dbMF0gPSB0cnVlO1xuICAgICAgbiA9IG43IHwgKGMgJiAweDdGKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgdmFyIG1hZ2ljID0gcmVhZGVyLnJlYWQzMnUgKClcbiAgc3dpdGNoKG1hZ2ljKXtcbiAgY2FzZSAweDg0OTVBNkJFOiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX3NtYWxsICovXG4gICAgdmFyIGhlYWRlcl9sZW4gPSAyMDtcbiAgICB2YXIgY29tcHJlc3NlZCA9IDA7XG4gICAgdmFyIGRhdGFfbGVuID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgdmFyIHVuY29tcHJlc3NlZF9kYXRhX2xlbiA9IGRhdGFfbGVuO1xuICAgIHZhciBudW1fb2JqZWN0cyA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgIHZhciBfc2l6ZV8zMiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgIHZhciBfc2l6ZV82NCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgIGJyZWFrXG4gIGNhc2UgMHg4NDk1QTZCRDogLyogSW50ZXh0X21hZ2ljX251bWJlcl9jb21wcmVzc2VkICovXG4gICAgdmFyIGhlYWRlcl9sZW4gPSByZWFkZXIucmVhZDh1KCkgJiAweDNGO1xuICAgIHZhciBjb21wcmVzc2VkID0gMTtcbiAgICB2YXIgb3ZlcmZsb3cgPSBbZmFsc2VdO1xuICAgIHZhciBkYXRhX2xlbiA9IHJlYWR2bHEob3ZlcmZsb3cpO1xuICAgIHZhciB1bmNvbXByZXNzZWRfZGF0YV9sZW4gPSByZWFkdmxxKG92ZXJmbG93KTtcbiAgICB2YXIgbnVtX29iamVjdHMgPSByZWFkdmxxKG92ZXJmbG93KTtcbiAgICB2YXIgX3NpemVfMzIgPSByZWFkdmxxIChvdmVyZmxvdyk7XG4gICAgdmFyIF9zaXplXzY0ID0gcmVhZHZscSAob3ZlcmZsb3cpO1xuICAgIGlmKG92ZXJmbG93WzBdKXtcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXI6IG9iamVjdCB0b28gbGFyZ2UgdG8gYmUgcmVhZCBiYWNrIG9uIHRoaXMgcGxhdGZvcm1cIik7XG4gICAgfVxuICAgIGJyZWFrXG4gIGNhc2UgMHg4NDk1QTZCRjogLyogSW50ZXh0X21hZ2ljX251bWJlcl9iaWcgKi9cbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcjogb2JqZWN0IHRvbyBsYXJnZSB0byBiZSByZWFkIGJhY2sgb24gYSAzMi1iaXQgcGxhdGZvcm1cIik7XG4gICAgYnJlYWtcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcjogYmFkIG9iamVjdFwiKTtcbiAgICBicmVhaztcbiAgfVxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGludGVybl9vYmpfdGFibGUgPSAobnVtX29iamVjdHMgPiAwKT9bXTpudWxsO1xuICB2YXIgb2JqX2NvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBpbnRlcm5fcmVjIChyZWFkZXIpIHtcbiAgICB2YXIgY29kZSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgaWYgKGNvZGUgPj0gMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8pIHtcbiAgICAgIGlmIChjb2RlID49IDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8pIHtcbiAgICAgICAgdmFyIHRhZyA9IGNvZGUgJiAweEY7XG4gICAgICAgIHZhciBzaXplID0gKGNvZGUgPj4gNCkgJiAweDc7XG4gICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAoY29kZSAmIDB4M0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29kZSA+PSAweDIwLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyAqLykge1xuICAgICAgICB2YXIgbGVuID0gY29kZSAmIDB4MUY7XG4gICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlIDB4MDA6IC8vY3N0LkNPREVfSU5UODpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQ4cyAoKTtcbiAgICAgICAgY2FzZSAweDAxOiAvL2NzdC5DT0RFX0lOVDE2OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDE2cyAoKTtcbiAgICAgICAgY2FzZSAweDAyOiAvL2NzdC5DT0RFX0lOVDMyOlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgICAgICAgY2FzZSAweDAzOiAvL2NzdC5DT0RFX0lOVDY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW50ZWdlciB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwNDogLy9jc3QuQ09ERV9TSEFSRUQ4OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIGlmKGNvbXByZXNzZWQgPT0gMCkgb2Zmc2V0ID0gb2JqX2NvdW50ZXIgLSBvZmZzZXQ7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA1OiAvL2NzdC5DT0RFX1NIQVJFRDE2OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDE2dSAoKTtcbiAgICAgICAgICBpZihjb21wcmVzc2VkID09IDApIG9mZnNldCA9IG9ial9jb3VudGVyIC0gb2Zmc2V0O1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNjogLy9jc3QuQ09ERV9TSEFSRUQzMjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgaWYoY29tcHJlc3NlZCA9PSAwKSBvZmZzZXQgPSBvYmpfY291bnRlciAtIG9mZnNldDtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDg6IC8vY3N0LkNPREVfQkxPQ0szMjpcbiAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgdmFyIHRhZyA9IGhlYWRlciAmIDB4RkY7XG4gICAgICAgICAgdmFyIHNpemUgPSBoZWFkZXIgPj4gMTA7XG4gICAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEzOiAvL2NzdC5DT0RFX0JMT0NLNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogZGF0YSBibG9jayB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOTogLy9jc3QuQ09ERV9TVFJJTkc4OlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQTogLy9jc3QuQ09ERV9TVFJJTkczMjpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBDOiAvL2NzdC5DT0RFX0RPVUJMRV9MSVRUTEU6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFs3IC0gaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEI6IC8vY3N0LkNPREVfRE9VQkxFX0JJRzpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0W2ldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBFOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEQ6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwNzogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEY6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTA6IC8vY3N0LkNPREVfQ09ERVBPSU5URVI6XG4gICAgICAgIGNhc2UgMHgxMTogLy9jc3QuQ09ERV9JTkZJWFBPSU5URVI6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogY29kZSBwb2ludGVyXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTI6IC8vY3N0LkNPREVfQ1VTVE9NOlxuICAgICAgICBjYXNlIDB4MTg6IC8vY3N0LkNPREVfQ1VTVE9NX0xFTjpcbiAgICAgICAgY2FzZSAweDE5OiAvL2NzdC5DT0RFX0NVU1RPTV9GSVhFRDpcbiAgICAgICAgICB2YXIgYywgcyA9IFwiXCI7XG4gICAgICAgICAgd2hpbGUgKChjID0gcmVhZGVyLnJlYWQ4dSAoKSkgIT0gMCkgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW3NdO1xuICAgICAgICAgIHZhciBleHBlY3RlZF9zaXplO1xuICAgICAgICAgIGlmKCFvcHMpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHVua25vd24gY3VzdG9tIGJsb2NrIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgIGNhc2UgMHgxMjogLy8gY3N0LkNPREVfQ1VTVE9NIChkZXByZWNhdGVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE5OiAvLyBjc3QuQ09ERV9DVVNUT01fRklYRURcbiAgICAgICAgICAgIGlmKCFvcHMuZml4ZWRfbGVuZ3RoKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGV4cGVjdGVkIGEgZml4ZWQtc2l6ZSBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gb3BzLmZpeGVkX2xlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxODogLy8gY3N0LkNPREVfQ1VTVE9NX0xFTlxuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgICAgLy8gU2tpcCBzaXplNjRcbiAgICAgICAgICAgIHJlYWRlci5yZWFkMzJzKCk7IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSByZWFkZXIuaTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IFswXTtcbiAgICAgICAgICB2YXIgdiA9IG9wcy5kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpO1xuICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gc2l6ZVswXSlcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbmNvcnJlY3QgbGVuZ3RoIG9mIHNlcmlhbGl6ZWQgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBtZXNzYWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmKGNvbXByZXNzZWQpIHtcbiAgICBpZihjYW1sX2RlY29tcHJlc3NfaW5wdXQpIHtcbiAgICAgIHZhciBkYXRhID0gcmVhZGVyLnJlYWR1aW50OGFycmF5KGRhdGFfbGVuKTtcbiAgICAgIHZhciByZXMgPSBuZXcgVWludDhBcnJheSh1bmNvbXByZXNzZWRfZGF0YV9sZW4pO1xuICAgICAgdmFyIHJlcyA9IGNhbWxfZGVjb21wcmVzc19pbnB1dChkYXRhLCByZXMpO1xuICAgICAgdmFyIHJlYWRlciA9IG5ldyBVSW50OEFycmF5UmVhZGVyKHJlcywgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogY29tcHJlc3NlZCBvYmplY3QsIGNhbm5vdCBkZWNvbXByZXNzXCIpO1xuICAgIH1cbiAgfVxuICB2YXIgcmVzID0gaW50ZXJuX3JlYyAocmVhZGVyKTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgc2l6ZSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGQgPSB2Lmxlbmd0aDtcbiAgICBpZiAoZCA8IHNpemUpIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgdltkXSA9IGludGVybl9yZWMgKHJlYWRlcik7XG4gIH1cbiAgaWYgKHR5cGVvZiBvZnMhPVwibnVtYmVyXCIpIG9mc1swXSA9IHJlYWRlci5pO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemVcbi8vVmVyc2lvbjogPCA1LjEuMFxudmFyIGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSA9IDIwXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZVxuLy9WZXJzaW9uOiA+PSA1LjEuMFxudmFyIGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSA9IDE2XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuLy9SZXF1aXJlczogVUludDhBcnJheVJlYWRlclxuLy9SZXF1aXJlczogY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplXG5mdW5jdGlvbiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChzLCBvZnMpIHtcbiAgdmFyIHIgPSBuZXcgVUludDhBcnJheVJlYWRlcihjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKHMpLCBvZnMpO1xuICBmdW5jdGlvbiByZWFkdmxxKG92ZXJmbG93KSB7XG4gICAgdmFyIGMgPSByLnJlYWQ4dSgpO1xuICAgIHZhciBuID0gYyAmIDB4N0Y7XG4gICAgd2hpbGUgKChjICYgMHg4MCkgIT0gMCkge1xuICAgICAgYyA9IHIucmVhZDh1KCk7XG4gICAgICB2YXIgbjcgPSBuIDw8IDc7XG4gICAgICBpZiAobiAhPSBuNyA+PiA3KSBvdmVyZmxvd1swXSA9IHRydWU7XG4gICAgICBuID0gbjcgfCAoYyAmIDB4N0YpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIHN3aXRjaChyLnJlYWQzMnUoKSl7XG4gIGNhc2UgMHg4NDk1QTZCRTogLyogSW50ZXh0X21hZ2ljX251bWJlcl9zbWFsbCAqL1xuICAgIHZhciBoZWFkZXJfbGVuID0gMjA7XG4gICAgdmFyIGRhdGFfbGVuID0gci5yZWFkMzJ1KCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMHg4NDk1QTZCRDogLyogSW50ZXh0X21hZ2ljX251bWJlcl9jb21wcmVzc2VkICovXG4gICAgdmFyIGhlYWRlcl9sZW4gPSByLnJlYWQ4dSgpICYgMHgzRjtcbiAgICB2YXIgb3ZlcmZsb3cgPSBbZmFsc2VdO1xuICAgIHZhciBkYXRhX2xlbiA9IHJlYWR2bHEob3ZlcmZsb3cpO1xuICAgIGlmKG92ZXJmbG93WzBdKXtcbiAgICAgIGNhbWxfZmFpbHdpdGgoXCJNYXJzaGFsLmRhdGFfc2l6ZTogb2JqZWN0IHRvbyBsYXJnZSB0byBiZSByZWFkIGJhY2sgb24gdGhpcyBwbGF0Zm9ybVwiKTtcbiAgICB9XG4gICAgYnJlYWtcbiAgY2FzZSAweDg0OTVBNkJGOiAvKiBJbnRleHRfbWFnaWNfbnVtYmVyX2JpZyAqL1xuICBkZWZhdWx0OlxuICAgIGNhbWxfZmFpbHdpdGgoXCJNYXJzaGFsLmRhdGFfc2l6ZTogYmFkIG9iamVjdFwiKTtcbiAgICBicmVha1xuICB9XG4gIHJldHVybiBoZWFkZXJfbGVuIC0gY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplICsgZGF0YV9sZW47XG59XG5cbi8vUHJvdmlkZXM6IE1sT2JqZWN0VGFibGVcbnZhciBNbE9iamVjdFRhYmxlO1xuaWYgKHR5cGVvZiBnbG9iYWxUaGlzLk1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgTWxPYmplY3RUYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIHBvbHlmaWxsICh1c2luZyBsaW5lYXIgc2VhcmNoKSAqL1xuICAgIGZ1bmN0aW9uIE5haXZlTG9va3VwKG9ianMpIHsgdGhpcy5vYmpzID0gb2JqczsgfVxuICAgIE5haXZlTG9va3VwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih2KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub2Jqcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5vYmpzW2ldID09PSB2KSByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9O1xuICAgIE5haXZlTG9va3VwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgaGVyZS4gW01sT2JqZWN0VGFibGUuc3RvcmVdIHdpbGwgcHVzaCB0byBbdGhpcy5vYmpzXSBkaXJlY3RseS5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIE1sT2JqZWN0VGFibGUoKSB7XG4gICAgICB0aGlzLm9ianMgPSBbXTsgdGhpcy5sb29rdXAgPSBuZXcgTmFpdmVMb29rdXAodGhpcy5vYmpzKTtcbiAgICB9O1xuICB9KCk7XG59XG5lbHNlIHtcbiAgTWxPYmplY3RUYWJsZSA9IGZ1bmN0aW9uIE1sT2JqZWN0VGFibGUoKSB7XG4gICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IGdsb2JhbFRoaXMuTWFwKCk7XG4gIH07XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24odikge1xuICB0aGlzLmxvb2t1cC5zZXQodiwgdGhpcy5vYmpzLmxlbmd0aCk7XG4gIHRoaXMub2Jqcy5wdXNoKHYpO1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5yZWNhbGwgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBpID0gdGhpcy5sb29rdXAuZ2V0KHYpO1xuICByZXR1cm4gKGkgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZCA6IHRoaXMub2Jqcy5sZW5ndGggLSBpOyAgIC8qIGluZGV4IGlzIHJlbGF0aXZlICovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBNbE9iamVjdFRhYmxlLCBjYW1sX2xpc3RfdG9fanNfYXJyYXksIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xudmFyIGNhbWxfb3V0cHV0X3ZhbCA9IGZ1bmN0aW9uICgpe1xuICBmdW5jdGlvbiBXcml0ZXIgKCkgeyB0aGlzLmNodW5rID0gW107IH1cbiAgV3JpdGVyLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua19pZHg6MjAsIGJsb2NrX2xlbjowLCBvYmpfY291bnRlcjowLCBzaXplXzMyOjAsIHNpemVfNjQ6MCxcbiAgICB3cml0ZTpmdW5jdGlvbiAoc2l6ZSwgdmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2F0OmZ1bmN0aW9uIChwb3MsIHNpemUsIHZhbHVlKSB7XG4gICAgICB2YXIgcG9zID0gcG9zO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbcG9zKytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2NvZGU6ZnVuY3Rpb24gKHNpemUsIGNvZGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gY29kZTtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX3NoYXJlZDpmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICBpZiAob2Zmc2V0IDwgKDEgPDwgOCkpIHRoaXMud3JpdGVfY29kZSg4LCAweDA0IC8qY3N0LkNPREVfU0hBUkVEOCovLCBvZmZzZXQpO1xuICAgICAgZWxzZSBpZiAob2Zmc2V0IDwgKDEgPDwgMTYpKSB0aGlzLndyaXRlX2NvZGUoMTYsIDB4MDUgLypjc3QuQ09ERV9TSEFSRUQxNiovLCBvZmZzZXQpO1xuICAgICAgZWxzZSB0aGlzLndyaXRlX2NvZGUoMzIsIDB4MDYgLypjc3QuQ09ERV9TSEFSRUQzMiovLCBvZmZzZXQpO1xuICAgIH0sXG4gICAgcG9zOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY2h1bmtfaWR4IH0sXG4gICAgZmluYWxpemU6ZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ibG9ja19sZW4gPSB0aGlzLmNodW5rX2lkeCAtIDIwO1xuICAgICAgdGhpcy5jaHVua19pZHggPSAwO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIDB4ODQ5NUE2QkUpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuYmxvY2tfbGVuKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLm9ial9jb3VudGVyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfMzIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV82NCk7XG4gICAgICByZXR1cm4gdGhpcy5jaHVuaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICh2LCBmbGFncykge1xuICAgIGZsYWdzID0gY2FtbF9saXN0X3RvX2pzX2FycmF5KGZsYWdzKTtcblxuICAgIHZhciBub19zaGFyaW5nID0gKGZsYWdzLmluZGV4T2YoMCAvKk1hcnNoYWwuTm9fc2hhcmluZyovKSAhPT0gLTEpLFxuICAgICAgICBjbG9zdXJlcyA9ICAoZmxhZ3MuaW5kZXhPZigxIC8qTWFyc2hhbC5DbG9zdXJlcyovKSAhPT0gLTEpO1xuICAgIC8qIE1hcnNoYWwuQ29tcGF0XzMyIGlzIHJlZHVuZGFudCBzaW5jZSBpbnRlZ2VycyBhcmUgMzItYml0IGFueXdheSAqL1xuXG4gICAgaWYgKGNsb3N1cmVzKVxuICAgICAgY29uc29sZS53YXJuKFwiaW4gY2FtbF9vdXRwdXRfdmFsOiBmbGFnIE1hcnNoYWwuQ2xvc3VyZXMgaXMgbm90IHN1cHBvcnRlZC5cIik7XG5cbiAgICB2YXIgd3JpdGVyID0gbmV3IFdyaXRlciAoKTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgaW50ZXJuX29ial90YWJsZSA9IG5vX3NoYXJpbmcgPyBudWxsIDogbmV3IE1sT2JqZWN0VGFibGUoKTtcblxuICAgIGZ1bmN0aW9uIG1lbW8odikge1xuICAgICAgaWYgKG5vX3NoYXJpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBleGlzdGluZ19vZmZzZXQgPSBpbnRlcm5fb2JqX3RhYmxlLnJlY2FsbCh2KTtcbiAgICAgIGlmIChleGlzdGluZ19vZmZzZXQpIHsgd3JpdGVyLndyaXRlX3NoYXJlZChleGlzdGluZ19vZmZzZXQpOyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgZWxzZSB7IGludGVybl9vYmpfdGFibGUuc3RvcmUodik7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVybl9yZWMgKHYpIHtcbiAgICAgIGlmICh2LmNhbWxfY3VzdG9tKSB7XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBuYW1lID0gdi5jYW1sX2N1c3RvbTtcbiAgICAgICAgdmFyIG9wcyA9IGNhbWxfY3VzdG9tX29wc1tuYW1lXTtcbiAgICAgICAgdmFyIHN6XzMyXzY0ID0gWzAsMF07XG4gICAgICAgIGlmKCFvcHMuc2VyaWFsaXplKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKEN1c3RvbSlcIik7XG4gICAgICAgIGlmKG9wcy5maXhlZF9sZW5ndGggPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTggLypjc3QuQ09ERV9DVVNUT01fTEVOKi8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgbmFtZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgdmFyIGhlYWRlcl9wb3MgPSB3cml0ZXIucG9zICgpO1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MsIDMyLCBzel8zMl82NFswXSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA0LCAzMiwgMCk7IC8vIHplcm9cbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDgsIDMyLCBzel8zMl82NFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDE5IC8qY3N0LkNPREVfQ1VTVE9NX0ZJWEVEKi8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgbmFtZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSB3cml0ZXIucG9zKCk7XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICBpZiAob3BzLmZpeGVkX2xlbmd0aCAhPSB3cml0ZXIucG9zKCkgLSBvbGRfcG9zKVxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogaW5jb3JyZWN0IGZpeGVkIHNpemVzIHNwZWNpZmllZCBieSBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDIgKyAoKHN6XzMyXzY0WzBdICsgMykgPj4gMik7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDIgKyAoKHN6XzMyXzY0WzFdICsgNykgPj4gMyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgICAgaWYgKHZbMF0gPT0gMjUxKSB7XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKEFic3RyYWN0KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FtbF9pc19jb250aW51YXRpb25fdGFnKHZbMF0pKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIm91dHB1dF92YWx1ZTogY29udGludWF0aW9uIHZhbHVlXCIpO1xuICAgICAgICBpZiAodi5sZW5ndGggPiAxICYmIG1lbW8odikpIHJldHVybjtcbiAgICAgICAgaWYgKHZbMF0gPCAxNiAmJiB2Lmxlbmd0aCAtIDEgPCA4KVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLyArIHZbMF0gKyAoKHYubGVuZ3RoIC0gMSk8PDQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDMyLCAweDA4IC8qY3N0LkNPREVfQkxPQ0szMiovLCAoKHYubGVuZ3RoLTEpIDw8IDEwKSB8IHZbMF0pO1xuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSB2Lmxlbmd0aDtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gdi5sZW5ndGg7XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEpIHN0YWNrLnB1c2ggKHYsIDEpO1xuICAgICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHYpKSB7XG4gICAgICAgIGlmKCEoY2FtbF9pc19tbF9ieXRlcyhjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpKSkpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBbQnl0ZXMudF0gY2Fubm90IHNhZmVseSBiZSBtYXJzaGFsZWQgd2l0aCBbLS1lbmFibGUgdXNlLWpzLXN0cmluZ11cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0KHYsaSkpO1xuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAxICsgKCgobGVuICsgNCkgLyA0KXwwKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMSArICgoKGxlbiArIDgpIC8gOCl8MCk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHYpKSB7XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoOCwgMHgwOS8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDMyLCAweDBBIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxlbjtpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHYsaSkpO1xuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAxICsgKCgobGVuICsgNCkgLyA0KXwwKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMSArICgoKGxlbiArIDgpIC8gOCl8MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodiAhPSAodnwwKSl7XG4gICAgICAgICAgdmFyIHR5cGVfb2ZfdiA9IHR5cGVvZiB2O1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSWYgYSBmbG9hdCBoYXBwZW5zIHRvIGJlIGFuIGludGVnZXIgaXQgaXMgc2VyaWFsaXplZCBhcyBhbiBpbnRlZ2VyXG4gICAgICAgICAgLy8gKEpzX29mX29jYW1sIGNhbm5vdCB0ZWxsIHdoZXRoZXIgdGhlIHR5cGUgb2YgYW4gaW50ZWdlciBudW1iZXIgaXNcbiAgICAgICAgICAvLyBmbG9hdCBvciBpbnRlZ2VyLikgVGhpcyBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgY3Jhc2hlcyB3aGVuXG4gICAgICAgICAgLy8gdW5tYXJzaGFsbGluZyB1c2luZyB0aGUgc3RhbmRhcmQgcnVudGltZS4gSXQgc2VlbXMgYmV0dGVyIHRvXG4gICAgICAgICAgLy8gc3lzdGVtYXRpY2FsbHkgZmFpbCBvbiBtYXJzaGFsbGluZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vICAgICAgICAgIGlmKHR5cGVfb2ZfdiAhPSBcIm51bWJlclwiKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChcIit0eXBlX29mX3YrXCIpXCIpO1xuICAgICAgICAgIC8vICAgICAgICAgIHZhciB0ID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQodikpO1xuICAgICAgICAgIC8vICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgwQiAvKmNzdC5DT0RFX0RPVUJMRV9CSUcqLyk7XG4gICAgICAgICAgLy8gICAgICAgICAgZm9yKHZhciBpID0gMDsgaTw4OyBpKyspe3dyaXRlci53cml0ZSg4LHRbaV0pfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPj0gMCAmJiB2IDwgMHg0MCkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMFg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8gKyB2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodiA+PSAtKDEgPDwgNykgJiYgdiA8ICgxIDw8IDcpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoOCwgMHgwMCAvKmNzdC5DT0RFX0lOVDgqLywgdik7XG4gICAgICAgICAgZWxzZSBpZiAodiA+PSAtKDEgPDwgMTUpICYmIHYgPCAoMSA8PCAxNSkpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgxNiwgMHgwMSAvKmNzdC5DT0RFX0lOVDE2Ki8sIHYpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDMyLCAweDAyIC8qY3N0LkNPREVfSU5UMzIqLywgdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZXh0ZXJuX3JlYyAodik7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBpID0gc3RhY2sucG9wICgpO1xuICAgICAgdmFyIHYgPSBzdGFjay5wb3AgKCk7XG4gICAgICBpZiAoaSArIDEgPCB2Lmxlbmd0aCkgc3RhY2sucHVzaCAodiwgaSArIDEpO1xuICAgICAgZXh0ZXJuX3JlYyAodltpXSk7XG4gICAgfVxuICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSB3cml0ZXIub2JqX2NvdW50ZXIgPSBpbnRlcm5fb2JqX3RhYmxlLm9ianMubGVuZ3RoO1xuICAgIHdyaXRlci5maW5hbGl6ZSgpO1xuICAgIHJldHVybiB3cml0ZXIuY2h1bms7XG4gIH1cbn0gKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheSAoY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzICh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl9hcnJheSAoY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXJcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9mYWlsd2l0aCwgY2FtbF9ibGl0X2J5dGVzXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXIgKHMsIG9mcywgbGVuLCB2LCBmbGFncykge1xuICB2YXIgdCA9IGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpO1xuICBpZiAodC5sZW5ndGggPiBsZW4pIGNhbWxfZmFpbHdpdGggKFwiTWFyc2hhbC50b19idWZmZXI6IGJ1ZmZlciBvdmVyZmxvd1wiKTtcbiAgY2FtbF9ibGl0X2J5dGVzKHQsIDAsIHMsIG9mcywgdC5sZW5ndGgpO1xuICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSW9cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZmRzXG52YXIgY2FtbF9zeXNfZmRzID0gbmV3IEFycmF5KDMpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jbG9zZVxuLy9SZXF1aXJlczogY2FtbF9zeXNfZmRzXG5mdW5jdGlvbiBjYW1sX3N5c19jbG9zZShmZCkge1xuICB2YXIgZmlsZSA9IGNhbWxfc3lzX2Zkc1tmZF07XG4gIGlmKGZpbGUpIGZpbGUuY2xvc2UoKTtcbiAgZGVsZXRlIGNhbWxfc3lzX2Zkc1tmZF07XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBNbEZha2VGZF9vdXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuLy9SZXF1aXJlczogY2FtbF9zeXNfZmRzXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19vcGVuX2Zvcl9ub2RlXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2ludGVybmFsKGZpbGUsaWR4KSB7XG4gIGlmKGlkeCA9PSB1bmRlZmluZWQpe1xuICAgIGlkeCA9IGNhbWxfc3lzX2Zkcy5sZW5ndGg7XG4gIH1cbiAgY2FtbF9zeXNfZmRzW2lkeF0gPSBmaWxlO1xuICByZXR1cm4gaWR4IHwgMDtcbn1cbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW4gKG5hbWUsIGZsYWdzLCBfcGVybXMpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUoZmxhZ3Mpe1xuICAgIHN3aXRjaChmbGFnc1sxXSl7XG4gICAgY2FzZSAwOiBmLnJkb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAxOiBmLndyb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAyOiBmLmFwcGVuZCA9IDE7YnJlYWs7XG4gICAgY2FzZSAzOiBmLmNyZWF0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA0OiBmLnRydW5jYXRlID0gMTticmVhaztcbiAgICBjYXNlIDU6IGYuZXhjbCA9IDE7IGJyZWFrO1xuICAgIGNhc2UgNjogZi5iaW5hcnkgPSAxO2JyZWFrO1xuICAgIGNhc2UgNzogZi50ZXh0ID0gMTticmVhaztcbiAgICBjYXNlIDg6IGYubm9uYmxvY2sgPSAxO2JyZWFrO1xuICAgIH1cbiAgICBmbGFncz1mbGFnc1syXTtcbiAgfVxuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsZik7XG4gIHJldHVybiBjYW1sX3N5c19vcGVuX2ludGVybmFsIChmaWxlLCB1bmRlZmluZWQpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZmlsZShmZCwgZmxhZ3MpIHtcbiAgICBpZihmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgICByZXR1cm4gY2FtbF9zeXNfb3Blbl9mb3Jfbm9kZShmZCwgZmxhZ3MpO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICByZXR1cm4gbmV3IE1sRmFrZUZkX291dChmZCwgZmxhZ3MpXG4gIH1cbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlKDAse3Jkb25seToxLGFsdG5hbWU6XCIvZGV2L3N0ZGluXCIsaXNDaGFyYWN0ZXJEZXZpY2U6dHJ1ZX0pLCAwKTtcbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlKDEse2J1ZmZlcmVkOjIsd3Jvbmx5OjEsaXNDaGFyYWN0ZXJEZXZpY2U6dHJ1ZX0pLCAxKTtcbiAgY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChmaWxlKDIse2J1ZmZlcmVkOjIsd3Jvbmx5OjEsaXNDaGFyYWN0ZXJEZXZpY2U6dHJ1ZX0pLCAyKTtcbn0pKClcblxuXG4vLyBvY2FtbCBDaGFubmVsc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZShjaGFuaWQsIG5hbWUpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNoYW4ubmFtZSA9IG5hbWU7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxzXG52YXIgY2FtbF9tbF9jaGFubmVscyA9IG5ldyBBcnJheSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dF9jaGFubmVsc19saXN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX291dF9jaGFubmVsc19saXN0ICgpIHtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGMgPSAwOyBjIDwgY2FtbF9tbF9jaGFubmVscy5sZW5ndGg7IGMrKyl7XG4gICAgaWYoY2FtbF9tbF9jaGFubmVsc1tjXSAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm9wZW5lZCAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm91dClcbiAgICAgIGw9WzAsY2FtbF9tbF9jaGFubmVsc1tjXS5mZCxsXTtcbiAgfVxuICByZXR1cm4gbDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfc3lzX2Zkc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX29wZW5cbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCAoZmQpIHtcbiAgdmFyIGZpbGUgPSBjYW1sX3N5c19mZHNbZmRdO1xuICBpZihmaWxlLmZsYWdzLnJkb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyByZWFkb25seVwiKTtcbiAgdmFyIGJ1ZmZlcmVkID0gKGZpbGUuZmxhZ3MuYnVmZmVyZWQgIT09IHVuZGVmaW5lZCkgPyBmaWxlLmZsYWdzLmJ1ZmZlcmVkIDogMTtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpmaWxlLFxuICAgIG9mZnNldDpmaWxlLmZsYWdzLmFwcGVuZD9maWxlLmxlbmd0aCgpOjAsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OnRydWUsXG4gICAgYnVmZmVyX2N1cnI6MCxcbiAgICBidWZmZXI6bmV3IFVpbnQ4QXJyYXkoNjU1MzYpLFxuICAgIGJ1ZmZlcmVkOmJ1ZmZlcmVkXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3N5c19mZHNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19vcGVuXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiAoZmQpICB7XG4gIHZhciBmaWxlID0gY2FtbF9zeXNfZmRzW2ZkXTtcbiAgaWYoZmlsZS5mbGFncy53cm9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgd3JpdGVvbmx5XCIpO1xuICB2YXIgcmVmaWxsID0gbnVsbDtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpmaWxlLFxuICAgIG9mZnNldDpmaWxlLmZsYWdzLmFwcGVuZD9maWxlLmxlbmd0aCgpOjAsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OiBmYWxzZSxcbiAgICBidWZmZXJfY3VycjowLFxuICAgIGJ1ZmZlcl9tYXg6MCxcbiAgICBidWZmZXI6bmV3IFVpbnQ4QXJyYXkoNjU1MzYpLFxuICAgIHJlZmlsbDpyZWZpbGxcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbl93aXRoX2ZsYWdzXG4vL1JlcXVpcmVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblxuLy9WZXJzaW9uOiA+PSA1LjFcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luX3dpdGhfZmxhZ3MoZmQsIGZsYWdzKXtcbiAgcmV0dXJuIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luKGZkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0X3dpdGhfZmxhZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuLy9WZXJzaW9uOiA+PSA1LjFcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dF93aXRoX2ZsYWdzKGZkLCBmbGFncyl7XG4gIHJldHVybiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQoZmQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvclxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuLy9BbGlhczogd2luX2ZpbGVkZXNjcl9vZl9jaGFubmVsXG5mdW5jdGlvbiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvcihjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZShjaGFuaWQsbW9kZSl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjaGFuLmZpbGUuZmxhZ3MudGV4dCA9ICFtb2RlXG4gIGNoYW4uZmlsZS5mbGFncy5iaW5hcnkgPSBtb2RlXG4gIHJldHVybiAwO1xufVxuXG4vL0lucHV0IGZyb20gaW5fY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsIGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Nsb3NlXG5mdW5jdGlvbiBjYW1sX21sX2Nsb3NlX2NoYW5uZWwgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2hhbi5vcGVuZWQgPSBmYWxzZTtcbiAgY2FtbF9zeXNfY2xvc2UoY2hhbi5mZClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjaGFuLmZpbGUubGVuZ3RoKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0KGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2hhbi5maWxlLmxlbmd0aCAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dChjaGFuaWQsZikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2hhbi5vdXRwdXQgPSAoZnVuY3Rpb24gKHMpIHtmKHMpfSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwoY2hhbmlkLGYpIHtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLnJlZmlsbCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3VpbnQ4X2FycmF5X29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWZpbGwgKGNoYW4pIHtcbiAgaWYoY2hhbi5yZWZpbGwgIT0gbnVsbCl7XG4gICAgdmFyIHN0ciA9IGNoYW4ucmVmaWxsKCk7XG4gICAgdmFyIHN0cl9hID0gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoc3RyKTtcbiAgICBpZiAoc3RyX2EubGVuZ3RoID09IDApIHtcbiAgICAgIGNoYW4ucmVmaWxsID0gbnVsbFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKGNoYW4uYnVmZmVyLmxlbmd0aCA8IGNoYW4uYnVmZmVyX21heCArIHN0cl9hLmxlbmd0aCl7XG4gICAgICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkoY2hhbi5idWZmZXJfbWF4ICsgc3RyX2EubGVuZ3RoKTtcbiAgICAgICAgYi5zZXQoY2hhbi5idWZmZXIpO1xuICAgICAgICBjaGFuLmJ1ZmZlciA9IGI7XG4gICAgICB9XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoc3RyX2EsY2hhbi5idWZmZXJfbWF4KTtcbiAgICAgIGNoYW4ub2Zmc2V0ICs9IHN0cl9hLmxlbmd0aDtcbiAgICAgIGNoYW4uYnVmZmVyX21heCArPSBzdHJfYS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBucmVhZCA9IGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LCBjaGFuLmJ1ZmZlciwgY2hhbi5idWZmZXJfbWF4LCBjaGFuLmJ1ZmZlci5sZW5ndGggLSBjaGFuLmJ1ZmZlcl9tYXgpO1xuICAgIGNoYW4ub2Zmc2V0ICs9IG5yZWFkO1xuICAgIGNoYW4uYnVmZmVyX21heCArPSBucmVhZDtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2lucHV0X2Jsb2NrXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0IChjaGFuaWQsIGIsIGksIGwpIHtcbiAgdmFyIGJhID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhiKTtcbiAgcmV0dXJuIGNhbWxfbWxfaW5wdXRfYmxvY2soY2hhbmlkLCBiYSwgaSwgbClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9iaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9pbnB1dF9ibG9ja1xuLy9SZXF1aXJlczogY2FtbF9iYV90b190eXBlZF9hcnJheVxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9iaWdhcnJheSAoY2hhbmlkLCBiLCBpLCBsKSB7XG4gIHZhciBiYSA9IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoYik7XG4gIHJldHVybiBjYW1sX21sX2lucHV0X2Jsb2NrKGNoYW5pZCwgYmEsIGksIGwpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfYmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfcmVmaWxsLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2Jsb2NrIChjaGFuaWQsIGJhLCBpLCBsKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgbiA9IGw7XG4gIHZhciBhdmFpbCA9IGNoYW4uYnVmZmVyX21heCAtIGNoYW4uYnVmZmVyX2N1cnI7XG4gIGlmKGwgPD0gYXZhaWwpIHtcbiAgICBiYS5zZXQoY2hhbi5idWZmZXIuc3ViYXJyYXkoY2hhbi5idWZmZXJfY3VycixjaGFuLmJ1ZmZlcl9jdXJyICsgbCksIGkpO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gbDtcbiAgfVxuICBlbHNlIGlmKGF2YWlsID4gMCkge1xuICAgIGJhLnNldChjaGFuLmJ1ZmZlci5zdWJhcnJheShjaGFuLmJ1ZmZlcl9jdXJyLGNoYW4uYnVmZmVyX2N1cnIgKyBhdmFpbCksIGkpO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gYXZhaWw7XG4gICAgbiA9IGF2YWlsO1xuICB9IGVsc2Uge1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gICAgY2FtbF9yZWZpbGwoY2hhbik7XG4gICAgdmFyIGF2YWlsID0gY2hhbi5idWZmZXJfbWF4IC0gY2hhbi5idWZmZXJfY3VycjtcbiAgICBpZihuID4gYXZhaWwpIG4gPSBhdmFpbDtcbiAgICBiYS5zZXQoY2hhbi5idWZmZXIuc3ViYXJyYXkoY2hhbi5idWZmZXJfY3VycixjaGFuLmJ1ZmZlcl9jdXJyICsgbiksIGkpO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gbjtcbiAgfVxuICByZXR1cm4gbiB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcywgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfcmVmaWxsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemVcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWUgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGhlYWRlciA9IG5ldyBVaW50OEFycmF5KGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSk7XG4gIGZ1bmN0aW9uIGJsb2NrKGJ1ZmZlciwgb2Zmc2V0LCBuKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHdoaWxlKHIgPCBuKXtcbiAgICAgIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KXtcbiAgICAgICAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gICAgICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gICAgICAgIGNhbWxfcmVmaWxsKGNoYW4pO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KVxuICAgICAgICBicmVhaztcbiAgICAgIGJ1ZmZlcltvZmZzZXQrcl0gPSBjaGFuLmJ1ZmZlcltjaGFuLmJ1ZmZlcl9jdXJyXTtcbiAgICAgIGNoYW4uYnVmZmVyX2N1cnIrKztcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdmFyIHIgPSBibG9jayhoZWFkZXIsIDAsIGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSk7XG4gIGlmKHIgPT0gMClcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIGVsc2UgaWYgKHIgPCBjYW1sX21hcnNoYWxfaGVhZGVyX3NpemUpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB0cnVuY2F0ZWQgb2JqZWN0XCIpO1xuICB2YXIgbGVuID0gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAoY2FtbF9ieXRlc19vZl9hcnJheShoZWFkZXIpLCAwKTtcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbiArIGNhbWxfbWFyc2hhbF9oZWFkZXJfc2l6ZSk7XG4gIGJ1Zi5zZXQoaGVhZGVyLDApO1xuICB2YXIgciA9IGJsb2NrKGJ1ZiwgY2FtbF9tYXJzaGFsX2hlYWRlcl9zaXplLCBsZW4pXG4gIGlmKHIgPCBsZW4pXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB0cnVuY2F0ZWQgb2JqZWN0IFwiICsgciArIFwiICBcIiArIGxlbik7XG4gIHZhciBvZmZzZXQgPSBbMF07XG4gIHZhciByZXMgPSBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShidWYpLCBvZmZzZXQpO1xuICBjaGFuLm9mZnNldCA9IGNoYW4ub2Zmc2V0ICsgb2Zmc2V0WzBdO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX3RvX291dHNpZGVfaGVhcFxuLy9SZXF1aXJlczogY2FtbF9pbnB1dF92YWx1ZVxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV90b19vdXRzaWRlX2hlYXAoYykge1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZShjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3JlZmlsbFxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9jaGFyIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXJfbWF4KXtcbiAgICBjaGFuLmJ1ZmZlcl9jdXJyID0gMDtcbiAgICBjaGFuLmJ1ZmZlcl9tYXggPSAwO1xuICAgIGNhbWxfcmVmaWxsKGNoYW4pO1xuICB9XG4gIGlmIChjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyX21heClcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciByZXMgPSBjaGFuLmJ1ZmZlcltjaGFuLmJ1ZmZlcl9jdXJyXTtcbiAgY2hhbi5idWZmZXJfY3VycisrO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9tbF9pbnB1dF9jaGFyLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2ludCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgcmVzID0gKHJlcyA8PCA4KSArIGNhbWxfbWxfaW5wdXRfY2hhcihjaGFuaWQpIHwgMDtcbiAgfVxuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9zZWVrX2luKGNoYW5pZCwgcG9zKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGlmKHBvcyA+PSBjaGFuLm9mZnNldCAtIGNoYW4uYnVmZmVyX21heFxuICAgICAmJiBwb3MgPD0gY2hhbi5vZmZzZXRcbiAgICAgJiYgY2hhbi5maWxlLmZsYWdzLmJpbmFyeSkge1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSBjaGFuLmJ1ZmZlcl9tYXggLSAoY2hhbi5vZmZzZXQgLSBwb3MpO1xuICB9IGVsc2Uge1xuICAgIGNoYW4ub2Zmc2V0ID0gcG9zO1xuICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgIGNoYW4uYnVmZmVyX21heCA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pblxuLy9SZXF1aXJlczogY2FtbF9zZWVrX2luXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW4oY2hhbmlkLHBvcyl7XG4gIHJldHVybiBjYW1sX3NlZWtfaW4oY2hhbmlkLHBvcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9zZWVrX2luXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW5fNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBwb3MgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiBjYW1sX3NlZWtfaW4oY2hhbmlkLCBwb3MpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9wb3NfaW4oY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5vZmZzZXQgLSAoY2hhbi5idWZmZXJfbWF4IC0gY2hhbi5idWZmZXJfY3VycikgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9wb3NfaW5cbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luKGNoYW5pZCkge1xuICByZXR1cm4gY2FtbF9wb3NfaW4oY2hhbmlkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfcG9zX2luXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbl82NChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2FtbF9wb3NfaW4oY2hhbmlkKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3JlZmlsbFxuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBwID0gY2hhbi5idWZmZXJfY3VycjtcbiAgZG8ge1xuICAgIGlmKHAgPj0gY2hhbi5idWZmZXJfbWF4KSB7XG4gICAgICBpZihjaGFuLmJ1ZmZlcl9jdXJyID4gMCkge1xuICAgICAgICBjaGFuLmJ1ZmZlci5zZXQoY2hhbi5idWZmZXIuc3ViYXJyYXkoY2hhbi5idWZmZXJfY3VyciksMCk7XG4gICAgICAgIHAgLT0gY2hhbi5idWZmZXJfY3VycjtcbiAgICAgICAgY2hhbi5idWZmZXJfbWF4IC09IGNoYW4uYnVmZmVyX2N1cnI7XG4gICAgICAgIGNoYW4uYnVmZmVyX2N1cnIgPSAwO1xuICAgICAgfVxuICAgICAgaWYoY2hhbi5idWZmZXJfbWF4ID49IGNoYW4uYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLShjaGFuLmJ1ZmZlcl9tYXgpIHwgMDtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2X21heCA9IGNoYW4uYnVmZmVyX21heDtcbiAgICAgIGNhbWxfcmVmaWxsIChjaGFuKTtcbiAgICAgIGlmKHByZXZfbWF4ID09IGNoYW4uYnVmZmVyX21heCkge1xuICAgICAgICByZXR1cm4gLShjaGFuLmJ1ZmZlcl9tYXgpIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKGNoYW4uYnVmZmVyW3ArK10gIT0gMTApO1xuICByZXR1cm4gKHAgLSBjaGFuLmJ1ZmZlcl9jdXJyKSB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZmx1c2hcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3QgZmx1c2ggYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgaWYoIWNoYW4uYnVmZmVyIHx8IGNoYW4uYnVmZmVyX2N1cnIgPT0gMCkgcmV0dXJuIDA7XG4gIGlmKGNoYW4ub3V0cHV0KSB7XG4gICAgY2hhbi5vdXRwdXQoY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKGNoYW4uYnVmZmVyLCAwLCBjaGFuLmJ1ZmZlcl9jdXJyKSk7XG4gIH0gZWxzZSB7XG4gICAgY2hhbi5maWxlLndyaXRlKGNoYW4ub2Zmc2V0LCBjaGFuLmJ1ZmZlciwgMCwgY2hhbi5idWZmZXJfY3Vycik7XG4gIH1cbiAgY2hhbi5vZmZzZXQgKz0gY2hhbi5idWZmZXJfY3VycjtcbiAgY2hhbi5idWZmZXJfY3VyciA9IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL291dHB1dCB0byBvdXRfY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF90YVxuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCxjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X3RhKGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3Qgb3V0cHV0IHRvIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIGlmKGNoYW4uYnVmZmVyX2N1cnIgKyBidWZmZXIubGVuZ3RoID4gY2hhbi5idWZmZXIubGVuZ3RoKSB7XG4gICAgdmFyIGIgPSBuZXcgVWludDhBcnJheShjaGFuLmJ1ZmZlcl9jdXJyICsgYnVmZmVyLmxlbmd0aCk7XG4gICAgYi5zZXQoY2hhbi5idWZmZXIpO1xuICAgIGNoYW4uYnVmZmVyID0gYlxuICB9XG4gIHN3aXRjaChjaGFuLmJ1ZmZlcmVkKXtcbiAgY2FzZSAwOiAvLyBVbmJ1ZmZlcmVkXG4gICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlciwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoO1xuICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgYnJlYWtcbiAgY2FzZSAxOiAvLyBCdWZmZXJlZCAodGhlIGRlZmF1bHQpXG4gICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlciwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgY2hhbi5idWZmZXJfY3VyciArPSBidWZmZXIubGVuZ3RoO1xuICAgIGlmKGNoYW4uYnVmZmVyX2N1cnIgPj0gY2hhbi5idWZmZXIubGVuZ3RoKVxuICAgICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICBicmVhaztcbiAgY2FzZSAyOiAvLyBCdWZmZXJlZCAob25seSBmb3Igc3Rkb3V0IGFuZCBzdGRlcnIpXG4gICAgdmFyIGlkID0gYnVmZmVyLmxhc3RJbmRleE9mKDEwKVxuICAgIGlmKGlkIDwgMCkge1xuICAgICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlciwgY2hhbi5idWZmZXJfY3Vycik7XG4gICAgICBjaGFuLmJ1ZmZlcl9jdXJyICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICBpZihjaGFuLmJ1ZmZlcl9jdXJyID49IGNoYW4uYnVmZmVyLmxlbmd0aClcbiAgICAgICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjaGFuLmJ1ZmZlci5zZXQoYnVmZmVyLnN1YmFycmF5KDAsIGlkICsgMSksIGNoYW4uYnVmZmVyX2N1cnIpO1xuICAgICAgY2hhbi5idWZmZXJfY3VyciArPSBpZCArIDE7XG4gICAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgICAgY2hhbi5idWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheShpZCArIDEpLCBjaGFuLmJ1ZmZlcl9jdXJyKTtcbiAgICAgIGNoYW4uYnVmZmVyX2N1cnIgKz0gYnVmZmVyLmxlbmd0aCAtIGlkIC0gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzLCBjYW1sX21sX291dHB1dF90YVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBidWZmZXIgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKGJ1ZmZlcik7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF90YShjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5LCBjYW1sX21sX291dHB1dF90YVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYmlnYXJyYXkoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBidWZmZXIgPSBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJ1ZmZlcik7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF90YShjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXQoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKXtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxjYW1sX2J5dGVzX29mX3N0cmluZyhidWZmZXIpLG9mZnNldCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfY2hhciAoY2hhbmlkLGMpIHtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZywgY2FtbF9tbF9vdXRwdXQsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZSAoY2hhbmlkLHYsZmxhZ3MpIHtcbiAgdmFyIHMgPSBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcodiwgZmxhZ3MpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfc2Vla19vdXQoY2hhbmlkLCBwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjaGFuLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfc2Vla19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXQoY2hhbmlkLHBvcyl7XG4gIHJldHVybiBjYW1sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfc2Vla19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXRfNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBwb3MgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiBjYW1sX3NlZWtfb3V0KGNoYW5pZCwgcG9zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wb3Nfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5vZmZzZXQgKyBjaGFuLmJ1ZmZlcl9jdXJyXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dFxuLy9SZXF1aXJlczogY2FtbF9wb3Nfb3V0XG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIHJldHVybiBjYW1sX3Bvc19vdXQoY2hhbmlkKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX3Bvc19vdXRcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dF82NChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQgKGNhbWxfcG9zX291dChjaGFuaWQpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2ludCAoY2hhbmlkLGkpIHtcbiAgdmFyIGFyciA9IFsoaT4+MjQpICYgMHhGRiwoaT4+MTYpICYgMHhGRiwoaT4+OCkgJiAweEZGLGkgJiAweEZGIF07XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCw0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pc19idWZmZXJlZFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pc19idWZmZXJlZChjaGFuaWQpIHtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5idWZmZXJlZCA/IDEgOiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2J1ZmZlcmVkXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NldF9idWZmZXJlZChjaGFuaWQsdikge1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0uYnVmZmVyZWQgPSB2O1xuICBpZighdikgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gMFxufVxuIiwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWlub3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWlub3IodW5pdCl7XG4gIC8vYXZhaWxhYmxlIHdpdGggW25vZGUgLS1leHBvc2UtZ2NdXG4gIGlmKHR5cGVvZiBnbG9iYWxUaGlzLmdjID09ICdmdW5jdGlvbicpIGdsb2JhbFRoaXMuZ2ModHJ1ZSk7XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX21ham9yKHVuaXQpe1xuICAvL2F2YWlsYWJsZSB3aXRoIFtub2RlIC0tZXhwb3NlLWdjXVxuICBpZih0eXBlb2YgZ2xvYmFsVGhpcy5nYyA9PSAnZnVuY3Rpb24nKSBnbG9iYWxUaGlzLmdjKCk7XG4gIHJldHVybiAwXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2Z1bGxfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfZnVsbF9tYWpvcih1bml0KXtcbiAgLy9hdmFpbGFibGUgd2l0aCBbbm9kZSAtLWV4cG9zZS1nY11cbiAgaWYodHlwZW9mIGdsb2JhbFRoaXMuZ2MgPT0gJ2Z1bmN0aW9uJykgZ2xvYmFsVGhpcy5nYygpO1xuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogY2FtbF9nY19jb21wYWN0aW9uXG5mdW5jdGlvbiBjYW1sX2djX2NvbXBhY3Rpb24oKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvdW50ZXJzXG5mdW5jdGlvbiBjYW1sX2djX2NvdW50ZXJzKCkgeyByZXR1cm4gWzI1NCwwLDAsMF0gfVxuLy9Qcm92aWRlczogY2FtbF9nY19xdWlja19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3F1aWNrX3N0YXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19zdGF0KCkge1xuICAvLyBBIGZpZWxkIHdhcyBhZGRlZCBpbiBPQ2FtbCA0LjEyLiBJdCBpcyB1bmxpa2VseSB0byBiZSBhbiBpc3N1ZSB0b1xuICAvLyByZXR1cm4gdG9vIG1hbnkgZmllbGRzIGluIHByZXZpb3VzIHZlcnNpb25zIG9mIE9DYW1sLlxuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX3NldFxuZnVuY3Rpb24gY2FtbF9nY19zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZ2V0XG5mdW5jdGlvbiBjYW1sX2djX2dldCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc2V0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZVxudmFyIGFsbF9maW5hbGl6ZXJzID0gbmV3IGdsb2JhbFRoaXMuU2V0KClcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgKGNiLCBhKSB7XG4gIGlmKGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIHZhciB4ID0gbmV3IGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkoZnVuY3Rpb24gKHgpe2FsbF9maW5hbGl6ZXJzLmRlbGV0ZSh4KTsgY2IoMCk7IHJldHVybjt9KTtcbiAgICB4LnJlZ2lzdGVyKGEseCk7XG4gICAgYWxsX2ZpbmFsaXplcnMuYWRkKHgpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlbGVhc2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVsZWFzZSAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdGFydFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0YXJ0KHJhdGUsc3RhY2tfc2l6ZSx0cmFja2VyKXtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdG9wXG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RvcCh1bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2ZfZGlzY2FyZFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX2Rpc2NhcmQodCkgeyByZXR1cm4gMCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXZlbnRsb2dfcmVzdW1lXG5mdW5jdGlvbiBjYW1sX2V2ZW50bG9nX3Jlc3VtZSh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXZlbnRsb2dfcGF1c2VcbmZ1bmN0aW9uIGNhbWxfZXZlbnRsb2dfcGF1c2UodW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnRcbmZ1bmN0aW9uIGNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudCh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3Jfc2xpY2VcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3Jfc2xpY2Uod29yaykgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21pbm9yX3dvcmRzXG5mdW5jdGlvbiBjYW1sX2djX21pbm9yX3dvcmRzKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWlub3JfZnJlZVxuZnVuY3Rpb24gY2FtbF9nZXRfbWlub3JfZnJlZSh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X21ham9yX2J1Y2tldFxuZnVuY3Rpb24gY2FtbF9nZXRfbWFqb3JfYnVja2V0KG4pIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWFqb3JfY3JlZGl0XG5mdW5jdGlvbiBjYW1sX2dldF9tYWpvcl9jcmVkaXQobikgeyByZXR1cm4gMDsgfVxuIiwiLy8vLy8vLy8vIENPUkVcblxuLy9Qcm92aWRlczogY29yZV9hcnJheV91bnNhZmVfaW50X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxudmFyIGNvcmVfYXJyYXlfdW5zYWZlX2ludF9ibGl0ID0gY2FtbF9hcnJheV9ibGl0XG4vL1Byb3ZpZGVzOiBjb3JlX2FycmF5X3Vuc2FmZV9mbG9hdF9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbnZhciBjb3JlX2FycmF5X3Vuc2FmZV9mbG9hdF9ibGl0ID0gY2FtbF9hcnJheV9ibGl0XG5cbi8vUHJvdmlkZXM6IGNvcmVfdGltZV9uc19mb3JtYXRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNvcmVfdGltZV9uc19mb3JtYXQodGltZSxmb3JtYXQpe1xuICB2YXIgZCA9IG5ldyBEYXRlKHRpbWUgKiAxMDAwKTtcbiAgdmFyIGZvcm1hdGpzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmb3JtYXQpO1xuICB2YXIganN0cmluZyA9IGpvb19nbG9iYWxfb2JqZWN0LnN0cmZ0aW1lKGZvcm1hdGpzLCBkKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoanN0cmluZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNvcmVfZ2NfY29tcGFjdGlvbnNcbmZ1bmN0aW9uIGNvcmVfZ2NfY29tcGFjdGlvbnMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2djX2hlYXBfY2h1bmtzXG5mdW5jdGlvbiBjb3JlX2djX2hlYXBfY2h1bmtzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9nY19oZWFwX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2djX2hlYXBfd29yZHMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2djX21ham9yX2NvbGxlY3Rpb25zXG5mdW5jdGlvbiBjb3JlX2djX21ham9yX2NvbGxlY3Rpb25zICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9nY19tYWpvcl9wbHVzX21pbm9yX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2djX21ham9yX3BsdXNfbWlub3Jfd29yZHMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2djX21ham9yX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2djX21ham9yX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9nY19taW5vcl9jb2xsZWN0aW9uc1xuZnVuY3Rpb24gY29yZV9nY19taW5vcl9jb2xsZWN0aW9ucyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfZ2NfbWlub3Jfd29yZHNcbmZ1bmN0aW9uIGNvcmVfZ2NfbWlub3Jfd29yZHMgKCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjb3JlX2djX3Byb21vdGVkX3dvcmRzXG5mdW5jdGlvbiBjb3JlX2djX3Byb21vdGVkX3dvcmRzICgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY29yZV9nY190b3BfaGVhcF93b3Jkc1xuZnVuY3Rpb24gY29yZV9nY190b3BfaGVhcF93b3JkcyAoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNvcmVfZ2NfcnVuX21lbXByb2ZfY2FsbGJhY2tzXG5mdW5jdGlvbiBjb3JlX2djX3J1bl9tZW1wcm9mX2NhbGxiYWNrcyAoKSB7IHJldHVybiAwIH1cblxuLy9Qcm92aWRlczogY29yZV9tZDVfZmRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luLCBjYW1sX21kNV9jaGFuLCBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbmZ1bmN0aW9uIGNvcmVfbWQ1X2ZkKGZkKXtcbiAgICB2YXIgaWMgPSBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbihmZCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbWxfbWQ1X2NoYW4oaWMsIC0xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBjYW1sX21sX2Nsb3NlX2NoYW5uZWwoaWMpO1xuICAgIH1cbn1cblxuLy9Qcm92aWRlczogY29yZV9tZDVfZGlnZXN0X3N1YmJpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tZDVfc3RyaW5nLCBjYW1sX2JsaXRfc3RyaW5nLCBjYW1sX2NyZWF0ZV9ieXRlc1xuLy9SZXF1aXJlczogYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWIsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG5mdW5jdGlvbiBjb3JlX21kNV9kaWdlc3Rfc3ViYmlnc3RyaW5nKGJ1Ziwgb2ZzLCBsZW4sIHJlcyl7XG4gICAgdmFyIGJ5dGVzID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgICBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YihidWYsIG9mcywgYnl0ZXMsIDAsIGxlbik7XG4gICAgdmFyIHJlczIgPSBjYW1sX21kNV9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnl0ZXMpLCAwLCBsZW4pO1xuICAgIGNhbWxfYmxpdF9zdHJpbmcocmVzMiwgMCwgcmVzLCAwLCAxNik7XG4gICAgcmV0dXJuIDA7XG59XG5cbi8vQmlnc3RyaW5nXG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19kZXN0cm95X3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gYmlnc3RyaW5nX2Rlc3Ryb3lfc3R1Yih2X2JzdHIpIHtcbiAgaWYgKHZfYnN0ci5oYXNPd25Qcm9wZXJ0eSgnX19pc19kZWFsbG9jYXRlZCcpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnc3RyaW5nX2Rlc3Ryb3k6IGJpZ3N0cmluZyBpcyBhbHJlYWR5IGRlYWxsb2NhdGVkXCIpO1xuICB9XG4gIC8vIE11dGF0ZSB0aGUgb3JpZ2luYWwgYmlnc3RyaW5nIGluLXBsYWNlLCB0byBzaW11bGF0ZSB3aGF0IHRoZSBDIHZlcnNpb24gZG9lc1xuICB2X2JzdHIuX19pc19kZWFsbG9jYXRlZCA9IHRydWU7XG4gIHZfYnN0ci5kYXRhID0gbmV3IHZfYnN0ci5kYXRhLl9fcHJvdG9fXy5jb25zdHJ1Y3RvcigwKTtcbiAgdl9ic3RyLmRpbXMgPSBbIDAgXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19yZWFsbG9jXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgYmlnc3RyaW5nX2Rlc3Ryb3lfc3R1YlxuZnVuY3Rpb24gYmlnc3RyaW5nX3JlYWxsb2MoYmlnc3RyaW5nLCBzaXplKSB7XG4gICAgaWYgKGJpZ3N0cmluZy5oYXNPd25Qcm9wZXJ0eSgnX19pc19kZWFsbG9jYXRlZCcpKSB7XG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ3N0cmluZ19yZWFsbG9jOiBiaWdzdHJpbmcgaXMgYWxyZWFkeSBkZWFsbG9jYXRlZFwiKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3X2RhdGEgPSBuZXcgYmlnc3RyaW5nLmRhdGEuX19wcm90b19fLmNvbnN0cnVjdG9yKHNpemUpO1xuICAgIG5ld19kYXRhLnNldChiaWdzdHJpbmcuZGF0YS5zbGljZSgwLCBzaXplKSk7XG4gICAgdmFyIG5ld19iaWdzdHJpbmcgPSBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmlnc3RyaW5nLmtpbmQsIGJpZ3N0cmluZy5sYXlvdXQsIFtzaXplXSwgbmV3X2RhdGEpO1xuICAgIGJpZ3N0cmluZ19kZXN0cm95X3N0dWIoYmlnc3RyaW5nKTtcblxuICAgIHJldHVybiBuZXdfYmlnc3RyaW5nO1xufVxuIiwiLy9Qcm92aWRlczogY2FtbF9jc2VsX3ZhbHVlXG5mdW5jdGlvbiBjYW1sX2NzZWxfdmFsdWUodl9jb25kLCB2X3RydWUsIHZfZmFsc2UpIHtcbiAgaWYgKHZfY29uZClcbiAgICByZXR1cm4gdl90cnVlO1xuICBlbHNlXG4gICAgcmV0dXJuIHZfZmFsc2U7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3NlMl9mbG9hdDY0X21pbl9ieXRlY29kZVxuZnVuY3Rpb24gY2FtbF9zc2UyX2Zsb2F0NjRfbWluX2J5dGVjb2RlKHgsIHkpIHtcbiAgcmV0dXJuIHggPCB5ID8geCA6IHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3NlMl9mbG9hdDY0X21heF9ieXRlY29kZVxuZnVuY3Rpb24gY2FtbF9zc2UyX2Zsb2F0NjRfbWF4X2J5dGVjb2RlKHgsIHkpIHtcbiAgcmV0dXJuIHggPiB5ID8geCA6IHk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZCwgQW5keSBSYXlcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbi8vXG4vLyBCaWdhcnJheS5cbi8vXG4vLyAtIGFsbCBiaWdhcnJheSB0eXBlcyBpbmNsdWRpbmcgSW50NjQgYW5kIENvbXBsZXguXG4vLyAtIGZvcnRyYW4gKyBjIGxheW91dHNcbi8vIC0gc3ViL3NsaWNlL3Jlc2hhcGVcbi8vIC0gcmV0YWluIGZhc3QgcGF0aCBmb3IgMWQgYXJyYXkgYWNjZXNzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaW5pdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYV9pbml0KCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplKGRpbXMpIHtcbiAgdmFyIG5fZGltcyA9IGRpbXMubGVuZ3RoO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbl9kaW1zOyBpKyspIHtcbiAgICBpZiAoZGltc1tpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBzaXplID0gc2l6ZSAqIGRpbXNbaV07XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCl7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSA3OiBjYXNlIDEwOiBjYXNlIDExOiByZXR1cm4gMjtcbiAgZGVmYXVsdDogcmV0dXJuIDE7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKXtcbiAgdmFyIHZpZXc7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAwOiAgdmlldyA9IEZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTogIHZpZXcgPSBGbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDI6ICB2aWV3ID0gSW50OEFycmF5OyBicmVhaztcbiAgY2FzZSAzOiAgdmlldyA9IFVpbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDQ6ICB2aWV3ID0gSW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNTogIHZpZXcgPSBVaW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNjogIHZpZXcgPSBJbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA3OiAgdmlldyA9IEludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDg6ICB2aWV3ID0gSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgOTogIHZpZXcgPSBJbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMDogdmlldyA9IEZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTE6IHZpZXcgPSBGbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDEyOiB2aWV3ID0gVWludDhBcnJheTsgYnJlYWs7XG4gIH1cbiAgaWYgKCF2aWV3KSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHZhciBkYXRhID0gbmV3IHZpZXcoc2l6ZSAqIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9WZXJzaW9uOiA8IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyYXlcIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246ID49IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyMDJcIlxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSwgY2FtbF9pbnQ2NF9oaTMyLCBjYW1sX2ludDY0X2xvMzJcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5IChraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuXG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gY2FtbF9iYV9jdXN0b21fbmFtZTtcblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIG9mcyA9IDA7XG4gIGlmKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIGFyZyA9IFthcmddO1xuICBpZiAoISAoYXJnIGluc3RhbmNlb2YgQXJyYXkpKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdhcnJheS5qczogaW52YWxpZCBvZmZzZXRcIik7XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGFyZy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZ2V0L3NldDogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICBpZih0aGlzLmxheW91dCA9PSAwIC8qIGNfbGF5b3V0ICovKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcmdbaV0gPCAwIHx8IGFyZ1tpXSA+PSB0aGlzLmRpbXNbaV0pXG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgYXJnW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5kaW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMSB8fCBhcmdbaV0gPiB0aGlzLmRpbXNbaV0pe1xuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICB9XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIChhcmdbaV0gLSAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9mcztcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBsID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGwsaCk7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgciA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGkgPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBbMjU0LCByLCBpXTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdGhpcy5kYXRhW29mc11cbiAgfVxufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gdlsxXTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gdlsyXTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgYSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB2YXIgYiA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBpZihhID09IGIpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gYSA6IGI7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIGltID0gdlsxXTtcbiAgICB2YXIgcmUgPSB2WzJdO1xuICAgIGlmKGltID09IHJlKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGltKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBpbSA6IHJlO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIsIHRvdGFsKSB7XG4gIGlmICh0aGlzLmxheW91dCAhPSBiLmxheW91dCB8fCB0aGlzLmtpbmQgIT0gYi5raW5kKSB7XG4gICAgdmFyIGsxID0gdGhpcy5raW5kIHwgKHRoaXMubGF5b3V0IDw8IDgpO1xuICAgIHZhciBrMiA9ICAgIGIua2luZCB8IChiLmxheW91dCA8PCA4KTtcbiAgICByZXR1cm4gazIgLSBrMTtcbiAgfVxuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBiLmRpbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGIuZGltcy5sZW5ndGggLSB0aGlzLmRpbXMubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmICh0aGlzLmRpbXNbaV0gIT0gYi5kaW1zW2ldKVxuICAgICAgcmV0dXJuICh0aGlzLmRpbXNbaV0gPCBiLmRpbXNbaV0pID8gLTEgOiAxO1xuICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgY2FzZSAxMDpcbiAgY2FzZSAxMTpcbiAgICAvLyBGbG9hdHNcbiAgICB2YXIgeCwgeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgeCA9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHkgPSBiLmRhdGFbaV07XG4gICAgICBpZiAoeCA8IHkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh4ID4geSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoeCAhPSB5KSB7XG4gICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgIGlmICh4ID09IHgpIHJldHVybiAxO1xuICAgICAgICBpZiAoeSA9PSB5KSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrPTIpIHtcbiAgICAgIC8vIENoZWNrIGhpZ2hlc3QgYml0cyBmaXJzdFxuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdIDwgYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA+IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA8IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPiAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDI6XG4gIGNhc2UgMzpcbiAgY2FzZSA0OlxuICBjYXNlIDU6XG4gIGNhc2UgNjpcbiAgY2FzZSA4OlxuICBjYXNlIDk6XG4gIGNhc2UgMTI6XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPCBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPiBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlfY18xXzFcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSAgID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUgPSBuZXcgTWxfQmlnYXJyYXkoKVxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgaWYodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIil7XG4gICAgaWYoKGFyZyBpbnN0YW5jZW9mIEFycmF5KSAmJiBhcmcubGVuZ3RoID09IDEpXG4gICAgICBhcmcgPSBhcmdbMF07XG4gICAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJNbF9CaWdhcnJheV9jXzFfMS5vZmZzZXRcIik7XG4gIH1cbiAgaWYgKGFyZyA8IDAgfHwgYXJnID49IHRoaXMuZGltc1swXSlcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcmc7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHJldHVybiB0aGlzLmRhdGFbb2ZzXTtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gIHJldHVybiAwXG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5kYXRhLmZpbGwodik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY29tcGFyZVxuZnVuY3Rpb24gY2FtbF9iYV9jb21wYXJlKGEsYix0b3RhbCl7XG4gIHJldHVybiBhLmNvbXBhcmUoYix0b3RhbClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgTWxfQmlnYXJyYXlfY18xXzEsIGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSl7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKTtcbiAgaWYoY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSAqIHNpemVfcGVyX2VsZW1lbnQgIT0gZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJsZW5ndGggZG9lc24ndCBtYXRjaCBkaW1zXCIpO1xuICB9XG4gIGlmKGxheW91dCA9PSAwICYmIC8vIGNfbGF5b3V0XG4gICAgIGRpbXMubGVuZ3RoID09IDEgJiYgLy8gQXJyYXkxXG4gICAgIHNpemVfcGVyX2VsZW1lbnQgPT0gMSkgLy8gMS10by0xIG1hcHBpbmdcbiAgICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHJldHVybiBuZXcgTWxfQmlnYXJyYXkoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcblxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZShraW5kLCBsYXlvdXQsIGRpbXNfbWwpIHtcbiAgdmFyIGRpbXMgPSBjYW1sX2pzX2Zyb21fYXJyYXkoZGltc19tbCk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIGNhbWxfYmFfZ2V0X3NpemUoZGltcykpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY2hhbmdlX2xheW91dFxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2NoYW5nZV9sYXlvdXQoYmEsIGxheW91dCkge1xuICBpZihiYS5sYXlvdXQgPT0gbGF5b3V0KSByZXR1cm4gYmE7XG4gIHZhciBuZXdfZGltcyA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSBuZXdfZGltc1tpXSA9IGJhLmRpbXNbYmEuZGltcy5sZW5ndGggLSBpIC0gMV07XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgbGF5b3V0LCBuZXdfZGltcywgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kKGJhKSB7XG4gIHJldHVybiBiYS5raW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2xheW91dFxuZnVuY3Rpb24gY2FtbF9iYV9sYXlvdXQoYmEpIHtcbiAgcmV0dXJuIGJhLmxheW91dDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9udW1fZGltc1xuZnVuY3Rpb24gY2FtbF9iYV9udW1fZGltcyhiYSkge1xuICByZXR1cm4gYmEuZGltcy5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZGltKGJhLCBpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmRpbVwiKTtcbiAgcmV0dXJuIGJhLmRpbXNbaV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzFcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8xKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8yKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8zKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfZ2VuZXJpYyhiYSwgaSkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSk7XG4gIHJldHVybiBiYS5nZXQob2ZzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQxNihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMgKyAxKTtcbiAgcmV0dXJuIChiMSB8IChiMiA8PCA4KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MzIoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHJldHVybiAoIChiMSA8PCAwKSAgfFxuICAgICAgICAgICAoYjIgPDwgOCkgIHxcbiAgICAgICAgICAgKGIzIDw8IDE2KSB8XG4gICAgICAgICAgIChiNCA8PCAyNCkgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQ2NChiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgdmFyIGI1ID0gYmEuZ2V0KG9mcys0KTtcbiAgdmFyIGI2ID0gYmEuZ2V0KG9mcys1KTtcbiAgdmFyIGI3ID0gYmEuZ2V0KG9mcys2KTtcbiAgdmFyIGI4ID0gYmEuZ2V0KG9mcys3KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW2I4LGI3LGI2LGI1LGI0LGIzLGIyLGIxXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzEoYmEsIGkwKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KGkwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzIoYmEsIGkwLCBpMSkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTFdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzMoYmEsIGkwLCBpMSwgaTIpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxLGkyXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0X2dlbmVyaWMoYmEsIGksIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQxNihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MzIoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysyLCAodiA+Pj4gMTYpICYgMHhmZik7XG4gIGJhLnNldChvZnMrMywgKHYgPj4+IDI0KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQ2NChiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIHYgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBiYS5zZXQob2ZzK2ksIHZbNy1pXSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzEoYmEsIGkwLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoaTApLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMihiYSwgaTAsIGkxLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMyhiYSwgaTAsIGkxLCBpMiwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZmlsbFxuZnVuY3Rpb24gY2FtbF9iYV9maWxsKGJhLCB2KSB7XG4gIGJhLmZpbGwodik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9ibGl0KHNyYywgZHN0KSB7XG4gIGlmIChkc3QuZGltcy5sZW5ndGggIT0gc3JjLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkc3QuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAoZHN0LmRpbXNbaV0gIT0gc3JjLmRpbXNbaV0pXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGRzdC5kYXRhLnNldChzcmMuZGF0YSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3N1YlxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc3ViKGJhLCBvZnMsIGxlbikge1xuICB2YXIgY2hhbmdlZF9kaW07XG4gIHZhciBtdWwgPSAxO1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gMDtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IChiYS5kaW1zLmxlbmd0aCAtIDEpOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gYmEuZGltcy5sZW5ndGggLSAxO1xuICAgIG9mcyA9IG9mcyAtIDE7XG4gIH1cbiAgaWYgKG9mcyA8IDAgfHwgbGVuIDwgMCB8fCAob2ZzICsgbGVuKSA+IGJhLmRpbXNbY2hhbmdlZF9kaW1dKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zdWI6IGJhZCBzdWItYXJyYXlcIik7XG4gIH1cbiAgdmFyIG5ld19kaW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICBuZXdfZGltc1tpXSA9IGJhLmRpbXNbaV07XG4gIG5ld19kaW1zW2NoYW5nZWRfZGltXSA9IGxlbjtcbiAgbXVsICo9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogbXVsLCAob2ZzICsgbGVuKSAqIG11bCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NsaWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3NsaWNlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBudW1faW5kcyA9IHZpbmQubGVuZ3RoO1xuICB2YXIgaW5kZXggPSBbXTtcbiAgdmFyIHN1Yl9kaW1zID0gW107XG4gIHZhciBvZnM7XG5cbiAgaWYgKG51bV9pbmRzID4gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc2xpY2U6IHRvbyBtYW55IGluZGljZXNcIik7XG5cbiAgLy8gQ29tcHV0ZSBvZmZzZXQgYW5kIGNoZWNrIGJvdW5kc1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IHZpbmRbaV07XG4gICAgZm9yICg7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAwO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZShudW1faW5kcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyArIGldID0gdmluZFtpXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMTtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UoMCwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyk7XG4gIH1cbiAgb2ZzID0gYmEub2Zmc2V0KGluZGV4KTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKHN1Yl9kaW1zKTtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIHNpemVfcGVyX2VsZW1lbnQsIChvZnMgKyBzaXplKSAqIHNpemVfcGVyX2VsZW1lbnQpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgc3ViX2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9yZXNoYXBlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG5mdW5jdGlvbiBjYW1sX2JhX3Jlc2hhcGUoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG5ld19kaW0gPSBbXTtcbiAgdmFyIG51bV9kaW1zID0gdmluZC5sZW5ndGg7XG5cbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIH1cbiAgdmFyIG51bV9lbHRzID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgbmV3X2RpbVtpXSA9IHZpbmRbaV07XG4gICAgaWYgKG5ld19kaW1baV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIG51bV9lbHRzID0gbnVtX2VsdHMgKiBuZXdfZGltW2ldO1xuICB9XG5cbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICAvLyBDaGVjayB0aGF0IHNpemVzIGFncmVlXG4gIGlmIChudW1fZWx0cyAhPSBzaXplKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IHNpemUgbWlzbWF0Y2hcIik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX3NlcmlhbGl6ZSh3cml0ZXIsIGJhLCBzeikge1xuICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXMubGVuZ3RoKTtcbiAgd3JpdGVyLndyaXRlKDMyLCAoYmEua2luZCB8IChiYS5sYXlvdXQgPDwgOCkpKTtcbiAgaWYoYmEuY2FtbF9jdXN0b20gPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYoYmEuZGltc1tpXSA8IDB4ZmZmZilcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kaW1zW2ldKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIDB4ZmZmZik7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgMCk7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGltc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICBlbHNlXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHdyaXRlci53cml0ZSgzMixiYS5kaW1zW2ldKVxuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoOCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB3cml0ZXIud3JpdGUoOCwwKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhiYS5nZXQoaSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChiYS5nZXQoaSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgaiA9IGJhLmdldChpKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMV0pKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMl0pKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgY29tcGxleCA9IGJhLmdldChpKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsxXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMl0pKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICBzelswXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogNDtcbiAgc3pbMV0gPSAoNCArIGJhLmRpbXMubGVuZ3RoKSAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGVzZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlcywgY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9kZXNlcmlhbGl6ZShyZWFkZXIsIHN6LCBuYW1lKXtcbiAgdmFyIG51bV9kaW1zID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogd3JvbmcgbnVtYmVyIG9mIGJpZ2FycmF5IGRpbWVuc2lvbnNcIik7XG4gIHZhciB0YWcgPSByZWFkZXIucmVhZDMycygpO1xuICB2YXIga2luZCA9IHRhZyAmIDB4ZmZcbiAgdmFyIGxheW91dCA9ICh0YWcgPj4gOCkgJiAxO1xuICB2YXIgZGltcyA9IFtdXG4gIGlmKG5hbWUgPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICAgIHZhciBzaXplX2RpbSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgICBpZihzaXplX2RpbSA9PSAweGZmZmYpe1xuICAgICAgICB2YXIgc2l6ZV9kaW1faGkgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICB2YXIgc2l6ZV9kaW1fbG8gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICBpZihzaXplX2RpbV9oaSAhPSAwKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogYmlnYXJyYXkgZGltZW5zaW9uIG92ZXJmbG93IGluIDMyYml0XCIpO1xuICAgICAgICBzaXplX2RpbSA9IHNpemVfZGltX2xvO1xuICAgICAgfVxuICAgICAgZGltcy5wdXNoKHNpemVfZGltKTtcbiAgICB9XG4gIGVsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIGRpbXMucHVzaChyZWFkZXIucmVhZDMydSgpKTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGRpbXMpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKTtcbiAgdmFyIGJhID0gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDhzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgdmFyIHNpeHR5ID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIGlmKHNpeHR5KSBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGNhbm5vdCByZWFkIGJpZ2FycmF5IHdpdGggNjQtYml0IE9DYW1sIGludHNcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogLy8gKGludDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbnQ2NCA9IGNhbWxfaW50NjRfb2ZfYnl0ZXModCk7XG4gICAgICBiYS5zZXQoaSxpbnQ2NCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgc3pbMF0gPSAoNCArIG51bV9kaW1zKSAqIDQ7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9EZXByZWNhdGVkXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9mcm9tXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfZnJvbShkYXRhMSwgZGF0YTIsIGpzdHlwLCBraW5kLCBsYXlvdXQsIGRpbXMpe1xuICBpZihkYXRhMiB8fCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpID09IDIpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfY3JlYXRlX2Zyb206IHVzZSByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlXCIpO1xuICB9XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaGFzaCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfaGFzaChiYSl7XG4gIHZhciBudW1fZWx0cyA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIHZhciBoID0gMDtcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAyNTYpIG51bV9lbHRzID0gMjU2O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyA0IDw9IGJhLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDgpIHwgKGJhLmRhdGFbaSsyXSA8PCAxNikgfCAoYmEuZGF0YVtpKzNdIDw8IDI0KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICB3ID0gMDtcbiAgICBzd2l0Y2ggKG51bV9lbHRzICYgMykge1xuICAgIGNhc2UgMzogdyAgPSBiYS5kYXRhW2krMl0gPDwgMTY7ICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAyOiB3IHw9IGJhLmRhdGFbaSsxXSA8PCA4OyAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDE6IHcgfD0gYmEuZGF0YVtpKzBdO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMTI4KSBudW1fZWx0cyA9IDEyODtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgMiA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9Mil7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCAxNik7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgaWYgKChudW1fZWx0cyAmIDEpICE9IDApXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgbnVtX2VsdHMgKj0gMlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9iYV90b190eXBlZF9hcnJheShiYSl7XG4gIHJldHVybiBiYS5kYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpe1xuICB2YXIga2luZDtcbiAgaWYgICAgICAodGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIGtpbmQgPSAwO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkga2luZCA9IDE7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgSW50OEFycmF5KSBraW5kID0gMjtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSBraW5kID0gMztcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkga2luZCA9IDM7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgSW50MTZBcnJheSkga2luZCA9IDQ7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgVWludDE2QXJyYXkpIGtpbmQgPSA1O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIEludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSBraW5kID0gNjtcbiAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXk6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHJldHVybiBraW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSh0YSl7XG4gIHZhciBraW5kID0gY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5KHRhKTtcbiAgdmFyIHRhID1cbiAgICAgIC8qIE5lZWRlZCB0byBhdm9pZCB1bnNpZ25lZCBzZXR0ZXJzIG92ZXJmbG93aW5nXG4gICAgICAgICB0aGUgcmFuZ2Ugb2YgT0NhbWwgW2ludDMyXSB2YWx1ZXMuICovXG4gICAgICB0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ID9cbiAgICAgIG5ldyBJbnQzMkFycmF5KHRhLmJ1ZmZlciAsdGEuYnl0ZU9mZnNldCwgdGEubGVuZ3RoKSA6IHRhO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfdGFnKGEpe1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKGEpKSByZXR1cm4gMjUyOyAvLyBzdHJpbmdfdGFnXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKGEpKSByZXR1cm4gMTI1MjsgLy8gb2NhbWwgc3RyaW5nIChpZiBkaWZmZXJlbnQgZnJvbSBieXRlcylcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5ICYmIGFbMF0gPT09IChhWzBdPj4+MCkgJiYgYVswXSA8PSAyNTUpIHtcbiAgICAvLyBMb29rIGxpa2UgYW4gb2NhbWwgYmxvY2tcbiAgICB2YXIgdGFnID0gYVswXSB8IDA7XG4gICAgLy8gaWdub3JlIGRvdWJsZV9hcnJheV90YWcgYmVjYXVzZSB3ZSBjYW5ub3QgYWNjdXJhdGVseSBzZXRcbiAgICAvLyB0aGlzIHRhZyB3aGVuIHdlIGNyZWF0ZSBhbiBhcnJheSBvZiBmbG9hdC5cbiAgICByZXR1cm4gKHRhZyA9PSAyNTQpPzA6dGFnXG4gIH1cbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgTnVtYmVyKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoYSAmJiBhLmNhbWxfY3VzdG9tKSByZXR1cm4gMTI1NTsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKGEgJiYgYS5jb21wYXJlKSByZXR1cm4gMTI1NjsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIDEyNDc7IC8vIGxpa2UgY2xvc3VyZV90YWcgKDI0NylcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzeW1ib2xcIikgcmV0dXJuIDEyNTE7XG4gIHJldHVybiAxMDAxOyAvL291dF9vZl9oZWFwX3RhZ1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGEpe1xuICByZXR1cm4gY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXS5jb21wYXJlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKG51bSwgY3VzdG9tLCBzd2FwLCB0b3RhbCkge1xuICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShjdXN0b20pO1xuICBpZihjb21wKSB7XG4gICAgdmFyIHggPSAoc3dhcCA+IDApP2NvbXAoY3VzdG9tLG51bSx0b3RhbCk6Y29tcChudW0sY3VzdG9tLHRvdGFsKTtcbiAgICBpZih0b3RhbCAmJiB4ICE9IHgpIHJldHVybiBzd2FwOyAvLyB0b3RhbCAmJiBuYW5cbiAgICBpZigreCAhPSAreCkgcmV0dXJuICt4OyAvLyBuYW5cbiAgICBpZigoeCB8IDApICE9IDApIHJldHVybiAoeCB8IDApOyAvLyAhbmFuXG4gIH1cbiAgcmV0dXJuIHN3YXBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbCAoY29uc3QsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmUsIGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20sIGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICB2YXIgdGFnX2EgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19hID09IDI1MCkgeyBhID0gYVsxXTsgY29udGludWUgfVxuXG4gICAgICB2YXIgdGFnX2IgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhiKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19iID09IDI1MCkgeyBiID0gYlsxXTsgY29udGludWUgfVxuXG4gICAgICAvLyB0YWdzIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmKHRhZ19hICE9PSB0YWdfYikge1xuICAgICAgICBpZih0YWdfYSA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2IgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShhLCBiLCAtMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdfYiA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2EgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShiLCBhLCAxLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0YWdfYSA8IHRhZ19iKT8tMToxO1xuICAgICAgfVxuICAgICAgc3dpdGNoKHRhZ19hKXtcbiAgICAgICAgLy8gMjQ2OiBMYXp5X3RhZyBoYW5kbGVkIGJlbGxvd1xuICAgICAgY2FzZSAyNDc6IC8vIENsb3N1cmVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjQ4OiAvLyBPYmplY3RcbiAgICAgICAgdmFyIHggPSBjYW1sX2ludF9jb21wYXJlKGFbMl0sIGJbMl0pO1xuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OTogLy8gSW5maXhcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTA6IC8vIEZvcndhcmQgdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBGb3J3YXJkX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTE6IC8vQWJzdHJhY3RcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUyOiAvLyBPQ2FtbCBieXRlc1xuICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgIHZhciB4ID0gY2FtbF9ieXRlc19jb21wYXJlKGEsIGIpO1xuICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUzOiAvLyBEb3VibGVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5X3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX2FycmF5X3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1NTogLy8gQ3VzdG9tX3RhZ1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEN1c3RvbV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI0NzogLy8gRnVuY3Rpb25cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTU6IC8vIEN1c3RvbVxuICAgICAgICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKTtcbiAgICAgICAgaWYoY29tcCAhPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYikpe1xuICAgICAgICAgIHJldHVybiAoYS5jYW1sX2N1c3RvbTxiLmNhbWxfY3VzdG9tKT8tMToxO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFjb21wKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICB2YXIgeCA9IGNvbXAoYSxiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTY6IC8vIGNvbXBhcmUgZnVuY3Rpb25cbiAgICAgICAgdmFyIHggPSBhLmNvbXBhcmUoYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCkgeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMDogLy8gTnVtYmVyXG4gICAgICAgIGEgPSArYTtcbiAgICAgICAgYiA9ICtiO1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAxOiAvLyBUaGUgcmVzdFxuICAgICAgICAvLyBIZXJlIHdlIGNhbiBiZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBKYXZhU2NyaXB0IHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAyLiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAzLiBKYXZhU2NyaXB0IG9iamVjdCB0aGFuIGNhbm5vdCBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvL1xuICAgICAgICAvLyAoMykgd2lsbCByYWlzZSBhIFtUeXBlRXJyb3JdXG4gICAgICAgIC8vICgyKSB3aWxsIGNvZXJjZSB0byBwcmltaXRpdmUgdHlwZXMgdXNpbmcgW3ZhbHVlT2ZdIG9yIFt0b1N0cmluZ11cbiAgICAgICAgLy8gKDIpIGFuZCAoMyksIGFmdGVyIGV2ZW50dWFsIGNvZXJjaW9uXG4gICAgICAgIC8vIC0gaWYgYSBhbmQgYiBhcmUgc3RyaW5ncywgYXBwbHkgbGV4aWNvZ3JhcGhpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIC0gaWYgYSBvciBiIGFyZSBub3Qgc3RyaW5ncywgY29udmVydCBhIGFuZCBiIHRvIG51bWJlclxuICAgICAgICAvLyAgIGFuZCBhcHBseSBzdGFuZGFyZCBjb21wYXJpc29uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV4Y2VwdGlvbjogYCE9YCB3aWxsIG5vdCBjb2VyY2UvY29udmVydCBpZiBib3RoIGEgYW5kIGIgYXJlIG9iamVjdHNcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MTogLy8gSmF2YVNjcmlwdCBTeW1ib2wsIG5vIG9yZGVyaW5nLlxuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjogLy8gb2NhbWwgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYSk7XG4gICAgICAgIHZhciBiID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhiKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUyMDogLy8gamF2YXNjcmlwdCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gYS50b1N0cmluZygpO1xuICAgICAgICB2YXIgYiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDY6IC8vIExhenlfdGFnXG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5XG4gICAgICBkZWZhdWx0OiAvLyBCbG9jayB3aXRoIG90aGVyIHRhZ1xuICAgICAgICBpZihjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodGFnX2EpKSB7XG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogY29udGludWF0aW9uIHZhbHVlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIChhLmxlbmd0aCA8IGIubGVuZ3RoKT8tMToxO1xuICAgICAgICBpZiAoYS5sZW5ndGggPiAxKSBzdGFjay5wdXNoKGEsIGIsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcbiAgICB2YXIgaSA9IHN0YWNrLnBvcCgpO1xuICAgIGIgPSBzdGFjay5wb3AoKTtcbiAgICBhID0gc3RhY2sucG9wKCk7XG4gICAgaWYgKGkgKyAxIDwgYS5sZW5ndGgpIHN0YWNrLnB1c2goYSwgYiwgaSArIDEpO1xuICAgIGEgPSBhW2ldO1xuICAgIGIgPSBiW2ldO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZSAoYSwgYikgeyByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdHJ1ZSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaW50X2NvbXBhcmUgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pbnRfY29tcGFyZSAoYSwgYikge1xuICBpZiAoYSA8IGIpIHJldHVybiAoLTEpOyBpZiAoYSA9PSBiKSByZXR1cm4gMDsgcmV0dXJuIDE7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID09IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbm90ZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpICE9IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPj0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcnRoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVydGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPiAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpIDw9IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3N0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc3RoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpIDwgMCk7IH1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nYWZfYmxpdF90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuZnVuY3Rpb24gYmlnc3RyaW5nYWZfYmxpdF90b19ieXRlcyhzcmMsIHNyY19vZmYsIGRzdCwgZHN0X29mZiwgbGVuKSB7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzKHNyYyxzcmNfb2ZmLGRzdCxkc3Rfb2ZmLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ2FmX2JsaXRfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG5mdW5jdGlvbiBiaWdzdHJpbmdhZl9ibGl0X3RvX2JpZ3N0cmluZyhzcmMsIHNyY19vZmYsIGRzdCwgZHN0X29mZiwgbGVuKSB7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhKHNyYywgc3JjX29mZiwgZHN0LCBkc3Rfb2ZmLCBsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdhZl9ibGl0X2Zyb21fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG5mdW5jdGlvbiBiaWdzdHJpbmdhZl9ibGl0X2Zyb21fYnl0ZXMoc3JjLCBzcmNfb2ZmLCBkc3QsIGRzdF9vZmYsIGxlbikge1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEoc3JjLCBzcmNfb2ZmLCBkc3QsIGRzdF9vZmYsIGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ2FmX21lbWNtcF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzEsIGNhbWxfaW50X2NvbXBhcmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ2FmX21lbWNtcF9iaWdzdHJpbmcoYmExLCBiYTFfb2ZmLCBiYTIsIGJhMl9vZmYsIGxlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBjYW1sX2ludF9jb21wYXJlKGNhbWxfYmFfZ2V0XzEoYmExLCBiYTFfb2ZmICsgaSksIGNhbWxfYmFfZ2V0XzEoYmEyLCBiYTJfb2ZmICsgaSkpO1xuICAgIGlmIChjICE9IDApIHJldHVybiBjXG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ2FmX21lbWNtcF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzEsIGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGJpZ3N0cmluZ2FmX21lbWNtcF9zdHJpbmcoYmEsIGJhX29mZiwgc3RyLCBzdHJfb2ZmLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gY2FtbF9pbnRfY29tcGFyZShjYW1sX2JhX2dldF8xKGJhLCBiYV9vZmYgKyBpKSwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzdHIsIHN0cl9vZmYgKyBpKSk7XG4gICAgaWYgKGMgIT0gMCkgcmV0dXJuIGNcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nYWZfbWVtY2hyXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdhZl9tZW1jaHIoYmEsIGJhX29mZiwgY2hyLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChjYW1sX2JhX2dldF8xKGJhLCBiYV9vZmYgKyBpKSA9PSBjaHIpIHtcbiAgICAgIHJldHVybiAoYmFfb2ZmICsgaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8vLy8vLy8vLyBCSUdTVFJJTkdcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyhoLCBicykge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCxicy5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciBtdXRhYmxlXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyKGJzKSB7XG4gIHJldHVybiBicy5kYXRhLmJ1ZmZlclxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5KGJzKSB7XG4gIHJldHVybiBicy5kYXRhXG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyKGFiKSB7XG4gIHZhciB0YSA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5KGJhKSB7XG4gIHZhciB0YSA9IG5ldyBVaW50OEFycmF5KGJhLmJ1ZmZlciwgYmEuYnl0ZU9mZnNldCwgYmEubGVuZ3RoICogYmEuQllURVNfUEVSX0VMRU1FTlQpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDEyLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19tZW1jbXBcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX21lbWNtcChzMSwgcG9zMSwgczIsIHBvczIsIGxlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYSA9IGNhbWxfYmFfZ2V0XzEoczEscG9zMSArIGkpO1xuICAgIHZhciBiID0gY2FtbF9iYV9nZXRfMShzMixwb3MyICsgaSk7XG4gICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhKGJhMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTEua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMxID0gYmExLm9mZnNldChwb3MxKTtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGJhMS5kYXRhLnN1YmFycmF5KG9mczEsb2ZzMStsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2UscG9zMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfdWludDhfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHN0cjEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihwb3MxICsgbGVuID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcoc3RyMSkuc2xpY2UocG9zMSxwb3MxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLG9mczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhKHN0cjEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihwb3MxICsgbGVuID4gY2FtbF9tbF9ieXRlc19sZW5ndGgoc3RyMSkpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzKGJhMSwgcG9zMSwgYnl0ZXMyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTEua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIGlmKG9mczEgKyBsZW4gPiBiYTEuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihwb3MyICsgbGVuID4gY2FtbF9tbF9ieXRlc19sZW5ndGgoYnl0ZXMyKSl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGJhMS5kYXRhLnNsaWNlKG9mczEsIG9mczErbGVuKTtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoc2xpY2UpLCAwLCBieXRlczIsIHBvczIsIGxlbik7XG4gIHJldHVybiAwXG59XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19hbGxvY192MlxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19hbGxvY192MihzaXplKXtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlKDEyLCAwLCBbMCxzaXplXSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19pc19tbWFwcGVkX3N0dWJcbmZ1bmN0aW9uIGJpZ3N0cmluZ19pc19tbWFwcGVkX3N0dWIoeCl7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG5mdW5jdGlvbiBiaWdzdHJpbmdfYmxpdF9zdHViKHMxLCBpMSwgczIsIGkyLCBsZW4pe1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShzMSxpMSxzMixpMixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9ieXRlc19iaWdzdHJpbmdfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfYnl0ZXNfYmlnc3RyaW5nX3N0dWIoc3JjLCBzcmNfcG9zLCBkc3QsIGRzdF9wb3MsIGxlbil7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhKHNyYyxzcmNfcG9zLGRzdCxkc3RfcG9zLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG5mdW5jdGlvbiBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YihzcmMsIHNyY19wb3MsIGRzdCwgZHN0X3BvcywgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMoc3JjLHNyY19wb3MsZHN0LGRzdF9wb3MsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfc3RyaW5nX2JpZ3N0cmluZ19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfc3RyaW5nX2JpZ3N0cmluZ19zdHViKHNyYywgc3JjX3BvcywgZHN0LCBkc3RfcG9zLCBsZW4pe1xuICByZXR1cm4gY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEoc3JjLHNyY19wb3MsZHN0LGRzdF9wb3MsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX21lbXNldF9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdfbWVtc2V0X3N0dWIoYmlnc3RyaW5nLCB2X3Bvcywgdl9sZW4sIHZfY2hhcikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZfbGVuOyBpKyspIHtcbiAgICBjYW1sX2JhX3NldF8xKGJpZ3N0cmluZywgdl9wb3MgKyBpLCB2X2NoYXIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19tZW1jbXBfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX21lbWNtcF9zdHViKHZfczEsIHZfczFfcG9zLCB2X3MyLCB2X3MyX3Bvcywgdl9sZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZfbGVuOyBpKyspIHtcbiAgICB2YXIgYSA9IGNhbWxfYmFfZ2V0XzEodl9zMSx2X3MxX3BvcyArIGkpO1xuICAgIHZhciBiID0gY2FtbF9iYV9nZXRfMSh2X3MyLHZfczJfcG9zICsgaSk7XG4gICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX21lbWNtcF9ieXRlc19zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xLCBjYW1sX2J5dGVzX2dldFxuZnVuY3Rpb24gYmlnc3RyaW5nX21lbWNtcF9ieXRlc19zdHViKHZfczEsIHZfczFfcG9zLCB2X3MyLCB2X3MyX3Bvcywgdl9sZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2X2xlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHZfczEsIHZfczFfcG9zICsgaSk7XG4gICAgdmFyIGIgPSBjYW1sX2J5dGVzX2dldCh2X3MyLCB2X3MyX3BvcyArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW50ZXJuYWxoYXNoX2ZvbGRfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZ1xudmFyIGludGVybmFsaGFzaF9mb2xkX2JpZ3N0cmluZyA9IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19maW5kXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdfZmluZChicywgY2hyLCBwb3MsIGxlbil7XG4gIHdoaWxlKGxlbiA+IDApe1xuICAgIGlmKGNhbWxfYmFfZ2V0XzEoYnMscG9zKSA9PSBjaHIpIHJldHVybiBwb3M7XG4gICAgcG9zKys7XG4gICAgbGVuLS07XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfbWVtbWVtX2J5dGVjb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdfbWVtbWVtX2J5dGVjb2RlKGhheXN0YWNrLCBuZWVkbGUsIGhheXN0YWNrX3BvcywgaGF5c3RhY2tfbGVuLCBuZWVkbGVfcG9zLCBuZWVkbGVfbGVuKXtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGltID0gaGF5c3RhY2tfbGVuIC0gbmVlZGxlX2xlbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8PSBsaW07ICsraSkge1xuICAgIHZhciBtYXRjaGVzID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5lZWRsZV9sZW47ICsraikge1xuICAgICAgaWYgKGNhbWxfYmFfZ2V0XzEoaGF5c3RhY2ssIGhheXN0YWNrX3BvcyArIGkgKyBqKSAhPSBjYW1sX2JhX2dldF8xKG5lZWRsZSxuZWVkbGVfcG9zICsgaikpIHtcbiAgICAgICAgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoZXMpIHJldHVybiAoaGF5c3RhY2tfcG9zICsgaSk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfaW50IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZywgY2FtbF9zdHJfcmVwZWF0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9pbnQoZm10LCBpKSB7XG4gIGlmIChjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCkgPT0gXCIlZFwiKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiK2kpO1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChpIDwgMCkgeyBpZiAoZi5zaWduZWRjb252KSB7IGYuc2lnbiA9IC0xOyBpID0gLWk7IH0gZWxzZSBpID4+Pj0gMDsgfVxuICB2YXIgcyA9IGkudG9TdHJpbmcoZi5iYXNlKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBzLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIHMgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBzO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKSB7XG4gIHZhciBpID0gMCwgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLCBiYXNlID0gMTAsIHNpZ24gPSAxO1xuICBpZiAobGVuID4gMCkge1xuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpKSB7XG4gICAgY2FzZSA0NTogaSsrOyBzaWduID0gLTE7IGJyZWFrO1xuICAgIGNhc2UgNDM6IGkrKzsgc2lnbiA9IDE7IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaSArIDEgPCBsZW4gJiYgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSA9PSA0OClcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpKSB7XG4gICAgY2FzZSAxMjA6IGNhc2UgODg6IGJhc2UgPSAxNjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExMTogY2FzZSA3OTogYmFzZSA9ICA4OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgIDk4OiBjYXNlIDY2OiBiYXNlID0gIDI7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTc6IGNhc2UgODU6IGkgKz0gMjsgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gW2ksIHNpZ24sIGJhc2VdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2RpZ2l0XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2RpZ2l0KGMpIHtcbiAgaWYgKGMgPj0gNDggJiYgYyA8PSA1NykgIHJldHVybiBjIC0gNDg7XG4gIGlmIChjID49IDY1ICYmIGMgPD0gOTApICByZXR1cm4gYyAtIDU1O1xuICBpZiAoYyA+PSA5NyAmJiBjIDw9IDEyMikgcmV0dXJuIGMgLSA4NztcbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfcGFyc2VfZGlnaXQsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfaW50X29mX3N0cmluZyAocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgdGhyZXNob2xkID0gLTEgPj4+IDA7XG4gIHZhciBjID0gKGkgPCBsZW4pP2NhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk6MDtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGQ7XG4gIGZvciAoaSsrO2k8bGVuO2krKykge1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICByZXMgPSBiYXNlICogcmVzICsgZDtcbiAgICBpZiAocmVzID4gdGhyZXNob2xkKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAvLyBGb3IgYmFzZSBkaWZmZXJlbnQgZnJvbSAxMCwgd2UgZXhwZWN0IGFuIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLFxuICAvLyBoZW5jZSBhbnkgdmFsdWUgb2YgJ3JlcycgKGxlc3MgdGhhbiAndGhyZXNob2xkJykgaXMgYWNjZXB0YWJsZS5cbiAgLy8gQnV0IHdlIGhhdmUgdG8gY29udmVydCB0aGUgcmVzdWx0IGJhY2sgdG8gYSBzaWduZWQgaW50ZWdlci5cbiAgcmVzID0gc2lnbiAqIHJlcztcbiAgaWYgKChiYXNlID09IDEwKSAmJiAoKHJlcyB8IDApICE9IHJlcykpXG4gICAgLyogU2lnbmVkIHJlcHJlc2VudGF0aW9uIGV4cGVjdGVkLCBhbGxvdyAtMl4obmJpdHMtMSkgdG8gMl4obmJpdHMtMSkgLSAxICovXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHJldHVybiByZXMgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX211bCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tdWwoYSxiKXtcbiAgcmV0dXJuIE1hdGguaW11bChhLGIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RpdlxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9kaXYoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiAoeC95KXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9tb2QoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiB4JXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnN3YXAxNlxuZnVuY3Rpb24gY2FtbF9ic3dhcDE2KHgpIHtcbiAgcmV0dXJuICgoKCh4ICYgMHgwMEZGKSA8PCA4KSB8XG4gICAgICAgICAgICgoeCAmIDB4RkYwMCkgPj4gOCkpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYnN3YXBcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYnN3YXAoeCkge1xuICByZXR1cm4gKCgoeCAmIDB4MDAwMDAwRkYpIDw8IDI0KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMDAwRkYwMCkgPDwgOCkgfFxuICAgICAgICAgICgoeCAmIDB4MDBGRjAwMDApID4+PiA4KSB8XG4gICAgICAgICAgKCh4ICYgMHhGRjAwMDAwMCkgPj4+IDI0KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Jzd2FwXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X2Jzd2FwKHgpIHtcbiAgdmFyIHkgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHgpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbeVs3XSwgeVs2XSwgeVs1XSwgeVs0XSwgeVszXSwgeVsyXSwgeVsxXSwgeVswXV0pO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBIYXNodGJsXG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX3VuaXZfcGFyYW0gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL1ZlcnNpb246IDwgNC4xMlxuZnVuY3Rpb24gY2FtbF9oYXNoX3VuaXZfcGFyYW0gKGNvdW50LCBsaW1pdCwgb2JqKSB7XG4gIHZhciBoYXNoX2FjY3UgPSAwO1xuICBmdW5jdGlvbiBoYXNoX2F1eCAob2JqKSB7XG4gICAgbGltaXQgLS07XG4gICAgaWYgKGNvdW50IDwgMCB8fCBsaW1pdCA8IDApIHJldHVybjtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkgJiYgb2JqWzBdID09PSAob2JqWzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKG9ialswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqWzJdKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgbGltaXQrKzsgaGFzaF9hdXgob2JqKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgb2JqWzBdKSB8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBvYmoubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkgaGFzaF9hdXggKG9ialtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKG9iaikpIHtcbiAgICAgIGNvdW50IC0tO1xuICAgICAgdmFyIGNvbnRlbnQgPSBjYW1sX21sX2J5dGVzX2NvbnRlbnQob2JqKTtcbiAgICAgIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZvciAodmFyIGIgPSBjb250ZW50LCBsID0gYi5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgfSBlbHNlIHsgLyogQVJSQVkgKi9cbiAgICAgICAgZm9yICh2YXIgYSA9IGNvbnRlbnQsIGwgPSBhLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYVtpXSkgfCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcob2JqKSkge1xuICAgICAgdmFyIGpzYnl0ZXMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9iaik7XG4gICAgICBmb3IgKHZhciBiID0ganNieXRlcywgbCA9IGpzYnl0ZXMubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmb3IgKHZhciBiID0gb2JqLCBsID0gb2JqLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSAob2JqfDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBjb3VudCAtLTtcbiAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9iaikgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSArb2JqKSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgY291bnQtLTtcbiAgICAgIHZhciBwID0gY2FtbF9pbnQ2NF90b19ieXRlcyAoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IChvYmopKTtcbiAgICAgIGZvciAodmFyIGkgPSA3OyBpID49IDA7IGktLSkgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgcFtpXSkgfCAwO1xuICAgIH0gZWxzZSBpZihvYmogJiYgb2JqLmNhbWxfY3VzdG9tKSB7XG4gICAgICBpZihjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoID0gY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaChvYmopIHwgMDtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgaCkgfCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNoX2F1eCAob2JqKTtcbiAgcmV0dXJuIGhhc2hfYWNjdSAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vZnVuY3Rpb24gUk9UTDMyKHgsbikgeyByZXR1cm4gKCh4IDw8IG4pIHwgKHggPj4+ICgzMi1uKSkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50KGgsZCkge1xuICBkID0gY2FtbF9tdWwoZCwgMHhjYzllMmQ1MXwwKTtcbiAgZCA9ICgoZCA8PCAxNSkgfCAoZCA+Pj4gKDMyLTE1KSkpOyAvLyBST1RMMzIoZCwgMTUpO1xuICBkID0gY2FtbF9tdWwoZCwgMHgxYjg3MzU5Myk7XG4gIGggXj0gZDtcbiAgaCA9ICgoaCA8PCAxMykgfCAoaCA+Pj4gKDMyLTEzKSkpOyAgIC8vUk9UTDMyKGgsIDEzKTtcbiAgcmV0dXJuICgoKGggKyAoaCA8PCAyKSl8MCkgKyAoMHhlNjU0NmI2NHwwKSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmluYWwoaCkge1xuICBoIF49IGggPj4+IDE2O1xuICBoID0gY2FtbF9tdWwgKGgsIDB4ODVlYmNhNmJ8MCk7XG4gIGggXj0gaCA+Pj4gMTM7XG4gIGggPSBjYW1sX211bCAoaCwgMHhjMmIyYWUzNXwwKTtcbiAgaCBePSBoID4+PiAxNjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9oYXNoX21peF9pbnQ2NFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9mbG9hdCAoaCwgdjApIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfaW50NjQoaCwgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh2MCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbG8zMiwgY2FtbF9pbnQ2NF9oaTMyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludDY0IChoLCB2KSB7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2xvMzIodikpO1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9oaTMyKHYpKTtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gcy5jaGFyQ29kZUF0KGkpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCA4KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMikgPDwgMTYpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSszKSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHMuY2hhckNvZGVBdChpKzIpIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gcy5jaGFyQ29kZUF0KGkrMSkgPDwgODtcbiAgY2FzZSAxOlxuICAgIHcgfD0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHNbaV1cbiAgICAgIHwgKHNbaSsxXSA8PCA4KVxuICAgICAgfCAoc1tpKzJdIDw8IDE2KVxuICAgICAgfCAoc1tpKzNdIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gc1tpKzJdIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gc1tpKzFdIDw8IDg7XG4gIGNhc2UgMTogdyB8PSBzW2ldO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfY29udGVudFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlcyhoLCB2KSB7XG4gIHZhciBjb250ZW50ID0gY2FtbF9tbF9ieXRlc19jb250ZW50KHYpO1xuICBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIGNvbnRlbnQpXG4gIGVsc2UgLyogQVJSQVkgKi9cbiAgICByZXR1cm4gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgY29udGVudCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsIHYpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHYpKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2ggbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0LCBjYW1sX2hhc2hfbWl4X3N0cmluZywgY2FtbF9oYXNoX21peF9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfY29udGludWF0aW9uX3RhZ1xuZnVuY3Rpb24gY2FtbF9oYXNoIChjb3VudCwgbGltaXQsIHNlZWQsIG9iaikge1xuICB2YXIgcXVldWUsIHJkLCB3ciwgc3osIG51bSwgaCwgdiwgaSwgbGVuO1xuICBzeiA9IGxpbWl0O1xuICBpZiAoc3ogPCAwIHx8IHN6ID4gMjU2KSBzeiA9IDI1NjtcbiAgbnVtID0gY291bnQ7XG4gIGggPSBzZWVkO1xuICBxdWV1ZSA9IFtvYmpdOyByZCA9IDA7IHdyID0gMTtcbiAgd2hpbGUgKHJkIDwgd3IgJiYgbnVtID4gMCkge1xuICAgIHYgPSBxdWV1ZVtyZCsrXTtcbiAgICBpZiAodiAmJiB2LmNhbWxfY3VzdG9tKXtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaGggPSBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCh2KTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50IChoLCBoaCk7XG4gICAgICAgIG51bSAtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKHZbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHZbMl0pO1xuICAgICAgICBudW0tLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBxdWV1ZVstLXJkXSA9IHZbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYoY2FtbF9pc19jb250aW51YXRpb25fdGFnKHZbMF0pKSB7XG4gICAgICAgICAgLyogQWxsIGNvbnRpbnVhdGlvbnMgaGFzaCB0byB0aGUgc2FtZSB2YWx1ZSxcbiAgICAgICAgICAgICBzaW5jZSB3ZSBoYXZlIG5vIGlkZWEgaG93IHRvIGRpc3Rpbmd1aXNoIHRoZW0uICovXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhZyA9ICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdGFnKTtcbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh3ciA+PSBzeikgYnJlYWs7XG4gICAgICAgICAgcXVldWVbd3IrK10gPSB2W2ldO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSAodnwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHYrdisxKTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLHYpO1xuICAgICAgbnVtLS07XG4gICAgfVxuICB9XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICByZXR1cm4gaCAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2hhc2hcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmluYWwsIGNhbWxfaGFzaF9taXhfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19oYXNoKGgsIHYpe1xuICB2YXIgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdik7XG4gIHZhciBoID0gY2FtbF9oYXNoX21peF9maW5hbChoKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuIiwiLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQ2NFxudmFyIEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjQgPSBjYW1sX2hhc2hfbWl4X2ludDY0O1xuLy9Qcm92aWRlczogQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG52YXIgQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQgPSBjYW1sX2hhc2hfbWl4X2ludDtcbi8vUHJvdmlkZXM6IEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmxvYXRcbnZhciBCYXNlX2ludGVybmFsaGFzaF9mb2xkX2Zsb2F0ID0gY2FtbF9oYXNoX21peF9mbG9hdDtcbi8vUHJvdmlkZXM6IEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xudmFyIEJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nID0gY2FtbF9oYXNoX21peF9zdHJpbmc7XG4vL1Byb3ZpZGVzOiBCYXNlX2ludGVybmFsaGFzaF9nZXRfaGFzaF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9maW5hbFxuZnVuY3Rpb24gQmFzZV9pbnRlcm5hbGhhc2hfZ2V0X2hhc2hfdmFsdWUoc2VlZCkge1xuICB2YXIgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoc2VlZCk7XG4gIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBwYXJzaW5nLmMgODk4MyAyMDA4LTA4LTA2IDA5OjM4OjI1WiB4bGVyb3kgJCAqL1xuXG4vKiBUaGUgUERBIGF1dG9tYXRvbiBmb3IgcGFyc2VycyBnZW5lcmF0ZWQgYnkgY2FtbHlhY2MgKi9cblxuLyogVGhlIHB1c2hkb3duIGF1dG9tYXRhICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VyX3RyYWNlXG52YXIgY2FtbF9wYXJzZXJfdHJhY2UgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9sZXhfYXJyYXksIGNhbWxfcGFyc2VyX3RyYWNlLGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgdmFyIHRibF9uYW1lc19jb25zdCA9IDE1O1xuICB2YXIgdGJsX25hbWVzX2Jsb2NrID0gMTY7XG5cblxuICBmdW5jdGlvbiBsb2coeCkge1xuICAgIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4ICsgXCJcXG5cIik7XG4gICAgY2FtbF9tbF9vdXRwdXQoMiwgcywgMCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuX25hbWUobmFtZXMsIG51bWJlcilcbiAge1xuICAgIHZhciBzdHIgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lcyk7XG4gICAgaWYgKHN0clswXSA9PSAnXFx4MDAnKVxuICAgICAgcmV0dXJuIFwiPHVua25vd24gdG9rZW4+XCI7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFx4MDAnKVtudW1iZXJdO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRfdG9rZW4oc3RhdGUsIHRvaylcbiAge1xuICAgIHZhciB0b2tlbiwga2luZDtcbiAgICBpZiAodG9rIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRva2VuID0gdG9rZW5fbmFtZSh0YWJsZXNbdGJsX25hbWVzX2Jsb2NrXSwgdG9rWzBdKTtcbiAgICAgIGlmICh0eXBlb2YgdG9rWzFdID09IFwibnVtYmVyXCIpXG4gICAgICAgIGtpbmQgPSBcIlwiICsgdG9rWzFdO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIHRva1sxXSA9PSBcInN0cmluZ1wiKVxuICAgICAgICBraW5kID0gdG9rWzFdXG4gICAgICBlbHNlIGlmICh0b2tbMV0gaW5zdGFuY2VvZiBNbEJ5dGVzKVxuICAgICAgICBraW5kID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0b2tbMV0pXG4gICAgICBlbHNlXG4gICAgICAgIGtpbmQgPSBcIl9cIlxuICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiByZWFkIHRva2VuIFwiICsgdG9rZW4gKyBcIihcIiArIGtpbmQgKyBcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuID0gdG9rZW5fbmFtZSh0YWJsZXNbdGJsX25hbWVzX2NvbnN0XSwgdG9rKTtcbiAgICAgIGxvZyhcIlN0YXRlIFwiICsgc3RhdGUgKyBcIjogcmVhZCB0b2tlbiBcIiArIHRva2VuKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgbmV4dDpzd2l0Y2goY21kKSB7XG4gICAgY2FzZSAwOi8vU1RBUlQ6XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBlcnJmbGFnID0gMDtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA2Oi8vbG9vcDpcbiAgICAgIG4gPSB0YWJsZXMuZGVmcmVkW3N0YXRlXTtcbiAgICAgIGlmIChuICE9IDApIHsgY21kID0gcmVkdWNlOyBicmVhazsgfVxuICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA+PSAwKSB7IGNtZCA9IHRlc3RzaGlmdDsgYnJlYWs7IH1cbiAgICAgIHJlcyA9IFJFQURfVE9LRU47XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGxleGVyIGFuZCB1cGRhdGVzICovXG4gICAgICAvKiBzeW1iX3N0YXJ0IGFuZCBzeW1iX2VuZCAqL1xuICAgIGNhc2UgMTovL1RPS0VOX1JFQUQ6XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfYmxvY2tdW2FyZ1swXSArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gYXJnWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfY29uc3RdW2FyZyArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSkgcHJpbnRfdG9rZW4gKHN0YXRlLCBhcmcpO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDc6Ly90ZXN0c2hpZnQ6XG4gICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgY21kID0gc2hpZnQ7IGJyZWFrO1xuICAgICAgfVxuICAgICAgbjEgPSB0YWJsZXMucmluZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIG4gPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgICBjbWQgPSByZWR1Y2U7IGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGVycmZsYWcgPD0gMCkge1xuICAgICAgICByZXMgPSBDQUxMX0VSUk9SX0ZVTkNUSU9OO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgZXJyb3IgZnVuY3Rpb24gKi9cbiAgICBjYXNlIDU6Ly9FUlJPUl9ERVRFQ1RFRDpcbiAgICAgIGlmIChlcnJmbGFnIDwgMykge1xuICAgICAgICBlcnJmbGFnID0gMztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3AgKyAxXTtcbiAgICAgICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGUxXTtcbiAgICAgICAgICBuMiA9IG4xICsgRVJSQ09ERTtcbiAgICAgICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IEVSUkNPREUpIHtcbiAgICAgICAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgICAgICAgbG9nKFwiUmVjb3ZlcmluZyBpbiBzdGF0ZSBcIiArIHN0YXRlMSk7XG4gICAgICAgICAgICBjbWQgPSBzaGlmdF9yZWNvdmVyOyBicmVhayBuZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgICAgIGxvZyhcIkRpc2NhcmRpbmcgc3RhdGUgXCIgKyBzdGF0ZTEpO1xuICAgICAgICAgICAgaWYgKHNwIDw9IGVudltlbnZfc3RhY2tiYXNlXSkge1xuICAgICAgICAgICAgICBpZiAoY2FtbF9wYXJzZXJfdHJhY2UpXG4gICAgICAgICAgICAgICAgbG9nKFwiTm8gbW9yZSBzdGF0ZXMgdG8gZGlzY2FyZFwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgICAgICBzcC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA9PSAwKVxuICAgICAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjsgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgICBsb2coXCJEaXNjYXJkaW5nIGxhc3QgdG9rZW4gcmVhZFwiKTtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA4Oi8vc2hpZnQ6XG4gICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA5Oi8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiBzaGlmdCB0byBzdGF0ZSBcIiArIHRhYmxlcy50YWJsZVtuMl0pO1xuICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgc3ArKztcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMTtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAyOi8vU1RBQ0tTX0dST1dOXzE6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfbHZhbF07XG4gICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfc3RhcnRdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRdO1xuICAgICAgY21kID0gbG9vcDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxMDovL3JlZHVjZTpcbiAgICAgIGlmIChjYW1sX3BhcnNlcl90cmFjZSlcbiAgICAgICAgbG9nKFwiU3RhdGUgXCIgKyBzdGF0ZSArIFwiOiByZWR1Y2UgYnkgcnVsZSBcIiArIG4pO1xuICAgICAgdmFyIG0gPSB0YWJsZXMubGVuW25dO1xuICAgICAgZW52W2Vudl9hc3BdID0gc3A7XG4gICAgICBlbnZbZW52X3J1bGVfbnVtYmVyXSA9IG47XG4gICAgICBlbnZbZW52X3J1bGVfbGVuXSA9IG07XG4gICAgICBzcCA9IHNwIC0gbSArIDE7XG4gICAgICBtID0gdGFibGVzLmxoc1tuXTtcbiAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3BdO1xuICAgICAgbjEgPSB0YWJsZXMuZ2luZGV4W21dO1xuICAgICAgbjIgPSBuMSArIHN0YXRlMTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBzdGF0ZTEpXG4gICAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMuZGdvdG9bbV07XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzI7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMzovL1NUQUNLU19HUk9XTl8yOlxuICAgICAgcmVzID0gQ09NUFVURV9TRU1BTlRJQ19BQ1RJT047XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIHNlbWFudGljIGFjdGlvbiAqL1xuICAgIGNhc2UgNDovL1NFTUFOVElDX0FDVElPTl9DT01QVVRFRDpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gYXJnO1xuICAgICAgdmFyIGFzcCA9IGVudltlbnZfYXNwXTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIGlmIChzcCA+IGFzcCkge1xuICAgICAgICAvKiBUaGlzIGlzIGFuIGVwc2lsb24gcHJvZHVjdGlvbi4gVGFrZSBzeW1iX3N0YXJ0IGVxdWFsIHRvIHN5bWJfZW5kLiAqL1xuICAgICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIH1cbiAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgLyogU2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvLyBTQVZFXG4gIGVudltlbnZfc3BdID0gc3A7XG4gIGVudltlbnZfc3RhdGVdID0gc3RhdGU7XG4gIGVudltlbnZfZXJyZmxhZ10gPSBlcnJmbGFnO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9wYXJzZXJfdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VyX3RyYWNlXG5mdW5jdGlvbiBjYW1sX3NldF9wYXJzZXJfdHJhY2UoYm9vbCkge1xuICB2YXIgb2xkZmxhZyA9IGNhbWxfcGFyc2VyX3RyYWNlO1xuICBjYW1sX3BhcnNlcl90cmFjZSA9IGJvb2w7XG4gIHJldHVybiBvbGRmbGFnO1xufVxuIiwiLy9Qcm92aWRlczpzaG91bGRfdXNlX3RpbWV6b25lX2pzX2xvYWRlciBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBzaG91bGRfdXNlX3RpbWV6b25lX2pzX2xvYWRlcih5ZXMsIF9wbGF0Zm9ybV9ub3Rfc3VwcG9ydGVkLCBkaXNhYmxlZCkge1xuICBpZiAoZ2xvYmFsVGhpcy5ESVNBQkxFX1RJTUVaT05FX0pTX0xPQURFUiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHllcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGlzYWJsZWQ7XG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOnRpbWV6b25lX2pzX2xvYWRlcl9kaXNhYmxlX2Zvcl90ZXN0aW5nXG5mdW5jdGlvbiB0aW1lem9uZV9qc19sb2FkZXJfZGlzYWJsZV9mb3JfdGVzdGluZygpIHtcbiAgZ2xvYmFsVGhpcy5ESVNBQkxFX1RJTUVaT05FX0pTX0xPQURFUiA9IHRydWU7XG59XG5cbi8vUHJvdmlkZXM6dGltZXpvbmVfanNfbG9hZGVyX2VuYWJsZV9mb3JfdGVzdGluZ1xuZnVuY3Rpb24gdGltZXpvbmVfanNfbG9hZGVyX2VuYWJsZV9mb3JfdGVzdGluZygpIHtcbiAgZ2xvYmFsVGhpcy5ESVNBQkxFX1RJTUVaT05FX0pTX0xPQURFUiA9IHVuZGVmaW5lZDtcbn1cblxuLy9Qcm92aWRlczp0aW1lem9uZV9qc19sb2FkZXJfY3JlYXRlX3pvbmVcbi8vUmVxdWlyZXM6Y2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIHRpbWV6b25lX2pzX2xvYWRlcl9jcmVhdGVfem9uZSh6b25lX25hbWUpIHtcbiAgem9uZV9uYW1lID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoem9uZV9uYW1lKTtcbiAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLlRlbXBvcmFsUG9seWZpbGwuVGVtcG9yYWwuVGltZVpvbmUoem9uZV9uYW1lKTtcbn1cblxuLy9Qcm92aWRlczp0aW1lem9uZV9qc19sb2FkZXJfZ2V0X25leHRfdHJhbnNpdGlvbl9vcl90aGlzX3RpbWVfaWZfbm9uZVxuZnVuY3Rpb24gdGltZXpvbmVfanNfbG9hZGVyX2dldF9uZXh0X3RyYW5zaXRpb25fb3JfdGhpc190aW1lX2lmX25vbmUoem9uZSwgaW5zdGFudCkge1xuICB2YXIgcmV0ID0gem9uZS5nZXROZXh0VHJhbnNpdGlvbihpbnN0YW50KTtcbiAgaWYgKHJldCkge1xuICAgIHJldHVybiByZXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGluc3RhbnQ7XG4gIH1cbn1cblxuLy9Qcm92aWRlczp0aW1lem9uZV9qc19sb2FkZXJfZnJvbV9lcG9jaF9zZWNvbmRzXG4vL1JlcXVpcmVzOmNhbWxfaW50NjRfdG9fZmxvYXRcbmZ1bmN0aW9uIHRpbWV6b25lX2pzX2xvYWRlcl9mcm9tX2Vwb2NoX3NlY29uZHMoc2Vjb25kcykge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5UZW1wb3JhbFBvbHlmaWxsLlRlbXBvcmFsLkluc3RhbnQuZnJvbUVwb2NoU2Vjb25kcyhjYW1sX2ludDY0X3RvX2Zsb2F0KHNlY29uZHMpKTtcbn1cblxuLy9Qcm92aWRlczp0aW1lem9uZV9qc19sb2FkZXJfY29tcGFyZV9pbnN0YW50c1xuZnVuY3Rpb24gdGltZXpvbmVfanNfbG9hZGVyX2NvbXBhcmVfaW5zdGFudHMoYSwgYikge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5UZW1wb3JhbFBvbHlmaWxsLlRlbXBvcmFsLkluc3RhbnQuY29tcGFyZShhLCBiKTtcbn1cblxuLy9Qcm92aWRlczp0aW1lem9uZV9qc19sb2FkZXJfZXBvY2hfc2Vjb25kc1xuLy9SZXF1aXJlczpjYW1sX2ludDY0X29mX2Zsb2F0XG5mdW5jdGlvbiB0aW1lem9uZV9qc19sb2FkZXJfZXBvY2hfc2Vjb25kcyhpbnN0YW50KSB7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGluc3RhbnQuZXBvY2hTZWNvbmRzKTtcbn1cblxuLy9Qcm92aWRlczp0aW1lem9uZV9qc19sb2FkZXJfbm93XG5mdW5jdGlvbiB0aW1lem9uZV9qc19sb2FkZXJfbm93KCkge1xuICByZXR1cm4gZ2xvYmFsVGhpcy5UZW1wb3JhbFBvbHlmaWxsLlRlbXBvcmFsLk5vdy5pbnN0YW50KCk7XG59XG5cbi8vUHJvdmlkZXM6dGltZXpvbmVfanNfbG9hZGVyX2luc3RhbnRfcGx1c19ob3Vyc1xuLy9SZXF1aXJlczpjYW1sX2ludDY0X3RvX2Zsb2F0XG5mdW5jdGlvbiB0aW1lem9uZV9qc19sb2FkZXJfaW5zdGFudF9wbHVzX2hvdXJzKGluc3RhbnQsIGhvdXJzKSB7XG4gIGhvdXJzID0gY2FtbF9pbnQ2NF90b19mbG9hdChob3Vycyk7XG4gIHZhciBkdXJhdGlvbiA9IGdsb2JhbFRoaXMuVGVtcG9yYWxQb2x5ZmlsbC5UZW1wb3JhbC5EdXJhdGlvbi5mcm9tKHsgaG91cnM6IGhvdXJzIH0pO1xuICByZXR1cm4gaW5zdGFudC5hZGQoZHVyYXRpb24pO1xufVxuXG4vL1Byb3ZpZGVzOnRpbWV6b25lX2pzX2xvYWRlcl9nZXRfb2Zmc2V0X25hbm9zX2ZvclxuLy9SZXF1aXJlczpjYW1sX2ludDY0X29mX2Zsb2F0XG5mdW5jdGlvbiB0aW1lem9uZV9qc19sb2FkZXJfZ2V0X29mZnNldF9uYW5vc19mb3Ioem9uZSwgaW5zdGFudCkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdCh6b25lLmdldE9mZnNldE5hbm9zZWNvbmRzRm9yKGluc3RhbnQpKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX3VwZGF0ZV9kdW1teSAoeCwgeSkge1xuICBpZiggeS5mdW4gKSB7IHguZnVuID0geS5mdW47IHJldHVybiAwOyB9XG4gIGlmKCB0eXBlb2YgeT09PVwiZnVuY3Rpb25cIiApIHsgeC5mdW4gPSB5OyByZXR1cm4gMDsgfVxuICB2YXIgaSA9IHkubGVuZ3RoOyB3aGlsZSAoaS0tKSB4W2ldID0geVtpXTsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYWxsb2NfZHVtbXlfaW5maXhcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfYWxsb2NfZHVtbXlfaW5maXggKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZiAoeCkgeyByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmZ1biwgW3hdKSB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2lzX2Jsb2NrIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2lzX2Jsb2NrICh4KSB7IHJldHVybiArKHggaW5zdGFuY2VvZiBBcnJheSk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90YWdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX29ial90YWcgKHgpIHtcbiAgaWYgKCh4IGluc3RhbmNlb2YgQXJyYXkpICYmIHhbMF0gPT0gKHhbMF0gPj4+IDApKVxuICAgIHJldHVybiB4WzBdXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKCh4IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8IHR5cGVvZiB4ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gMjQ3XG4gIGVsc2UgaWYgKHggJiYgeC5jYW1sX2N1c3RvbSlcbiAgICByZXR1cm4gMjU1XG4gIGVsc2VcbiAgICByZXR1cm4gMTAwMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfdGFnIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF90YWcgKHgsIHRhZykgeyB4WzBdID0gdGFnOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9vYmpfYmxvY2sgY29uc3QgKGNvbnN0LGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfYmxvY2sgKHRhZywgc2l6ZSkge1xuICB2YXIgbyA9IG5ldyBBcnJheShzaXplKzEpO1xuICBvWzBdPXRhZztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc2l6ZTsgaSsrKSBvW2ldID0gMDtcbiAgcmV0dXJuIG87XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3dpdGhfdGFnXG5mdW5jdGlvbiBjYW1sX29ial93aXRoX3RhZyh0YWcseCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IHRhZztcbiAgZm9yKHZhciBpID0gMTsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfZHVwIG11dGFibGUgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX29ial9kdXAgKHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RydW5jYXRlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9vYmpfdHJ1bmNhdGUgKHgsIHMpIHtcbiAgaWYgKHM8PTAgfHwgcyArIDEgPiB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiT2JqLnRydW5jYXRlXCIpO1xuICBpZiAoeC5sZW5ndGggIT0gcyArIDEpIHgubGVuZ3RoID0gcyArIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9tYWtlX2ZvcndhcmRcbmZ1bmN0aW9uIGNhbWxfb2JqX21ha2VfZm9yd2FyZCAoYix2KSB7XG4gIGJbMF09MjUwO1xuICBiWzFdPXY7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXBcbmZ1bmN0aW9uIGNhbWxfb2JqX2NvbXBhcmVfYW5kX3N3YXAoeCxpLG9sZCxuKXtcbiAgaWYoeFtpKzFdID09IG9sZCkge1xuICAgIHhbaSsxXSA9IG47XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfc2hhcmVkXG5mdW5jdGlvbiBjYW1sX29ial9pc19zaGFyZWQoeCl7XG4gIHJldHVybiAxXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgY29uc3QgKG11dGFibGUpXG5mdW5jdGlvbiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkICh2KSB7IHJldHVybiBbMjUwLCB2XTsgfVxuXG4vLy8vLy8vLy8vLy8vIENhbWxpbnRlcm5hbE9PXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIGNvbnN0XG52YXIgY2FtbF9tZXRob2RfY2FjaGUgPSBbXTtcbmZ1bmN0aW9uIGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgKG9iaiwgdGFnLCBjYWNoZWlkKSB7XG4gIHZhciBtZXRocyA9IG9ialsxXTtcbiAgdmFyIG9mcyA9IGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdO1xuICBpZiAob2ZzID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycmF5IGlzIG5vdCBzcGFyc2VcbiAgICBmb3IgKHZhciBpID0gY2FtbF9tZXRob2RfY2FjaGUubGVuZ3RoOyBpIDwgY2FjaGVpZDsgaSsrKVxuICAgICAgY2FtbF9tZXRob2RfY2FjaGVbaV0gPSAwO1xuICB9IGVsc2UgaWYgKG1ldGhzW29mc10gPT09IHRhZykge1xuICAgIHJldHVybiBtZXRoc1tvZnMgLSAxXTtcbiAgfVxuICB2YXIgbGkgPSAzLCBoaSA9IG1ldGhzWzFdICogMiArIDEsIG1pO1xuICB3aGlsZSAobGkgPCBoaSkge1xuICAgIG1pID0gKChsaStoaSkgPj4gMSkgfCAxO1xuICAgIGlmICh0YWcgPCBtZXRoc1ttaSsxXSkgaGkgPSBtaS0yO1xuICAgIGVsc2UgbGkgPSBtaTtcbiAgfVxuICBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXSA9IGxpICsgMTtcbiAgLyogcmV0dXJuIDAgaWYgdGFnIGlzIG5vdCB0aGVyZSAqL1xuICByZXR1cm4gKHRhZyA9PSBtZXRoc1tsaSsxXSA/IG1ldGhzW2xpXSA6IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29vX2xhc3RfaWRcbnZhciBjYW1sX29vX2xhc3RfaWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX3NldF9vb19pZCAoYikge1xuICBiWzJdPWNhbWxfb29fbGFzdF9pZCsrO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mcmVzaF9vb19pZCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX2ZyZXNoX29vX2lkKCkge1xuICByZXR1cm4gY2FtbF9vb19sYXN0X2lkKys7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfcmF3X2ZpZWxkKG8saSkgeyByZXR1cm4gb1tpKzFdIH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3Jhd19maWVsZChvLGksdikgeyByZXR1cm4gb1tpKzFdID0gdiB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1xuZnVuY3Rpb24gY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzKG8pIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfYWRkX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9vYmpfYWRkX29mZnNldCh2LG9mZnNldCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiT2JqLmFkZF9vZmZzZXQgaXMgbm90IHN1cHBvcnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdXBkYXRlX3RhZ1xuZnVuY3Rpb24gY2FtbF9vYmpfdXBkYXRlX3RhZyhiLG8sbikge1xuICAgIGlmKGJbMF09PW8pIHsgYlswXSA9IG47IHJldHVybiAxIH1cbiAgICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcmNpbmdcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3VwZGF0ZV90YWdcbmZ1bmN0aW9uIGNhbWxfbGF6eV91cGRhdGVfdG9fZm9yY2luZyhvKSB7XG4gIGlmICgobyBpbnN0YW5jZW9mIEFycmF5KSAmJiBvWzBdID09IChvWzBdID4+PiAwKSAmJlxuICAgICAgY2FtbF9vYmpfdXBkYXRlX3RhZyhvLCAyNDYsIDI0NCkpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfdXBkYXRlX3RvX2ZvcndhcmRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX3VwZGF0ZV90YWdcbiAgZnVuY3Rpb24gY2FtbF9sYXp5X3VwZGF0ZV90b19mb3J3YXJkKG8pIHtcbiAgY2FtbF9vYmpfdXBkYXRlX3RhZyhvLDI0NCwyNTApO1xuICByZXR1cm4gMDsgLy8gdW5pdFxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9yZXNldF90b19sYXp5XG4vL1JlcXVpcmVzOiBjYW1sX29ial91cGRhdGVfdGFnXG5mdW5jdGlvbiBjYW1sX2xhenlfcmVzZXRfdG9fbGF6eShvKSB7XG4gIGNhbWxfb2JqX3VwZGF0ZV90YWcobywyNDQsMjQ2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9yZWFkX3Jlc3VsdFxuLy9SZXF1aXJlczogY2FtbF9vYmpfdGFnXG5mdW5jdGlvbiBjYW1sX2xhenlfcmVhZF9yZXN1bHQobykge1xuICByZXR1cm4gKGNhbWxfb2JqX3RhZyhvKSA9PSAyNTApP29bMV06bztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWdcbi8vVmVyc2lvbjogPCA1XG5mdW5jdGlvbiBjYW1sX2lzX2NvbnRpbnVhdGlvbl90YWcodCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19jb250aW51YXRpb25fdGFnXG4vL1ZlcnNpb246ID49IDVcbmZ1bmN0aW9uIGNhbWxfaXNfY29udGludWF0aW9uX3RhZyh0KSB7XG4gIHJldHVybiAodCA9PSAyNDUpID8gMSA6IDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWI6IGNvZGUgc3BlY2lmaWMgdG8gSnNfb2Zfb2NhbWxcblxuLy9Qcm92aWRlczogY2FtbF9qc19vbl9pZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19vbl9pZSAoKSB7XG4gIHZhciB1YSA9XG4gICAgICAoZ2xvYmFsVGhpcy5uYXZpZ2F0b3ImJmdsb2JhbFRoaXMubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgID9nbG9iYWxUaGlzLm5hdmlnYXRvci51c2VyQWdlbnQ6XCJcIjtcbiAgcmV0dXJuIHVhLmluZGV4T2YoXCJNU0lFXCIpICE9IC0xICYmIHVhLmluZGV4T2YoXCJPcGVyYVwiKSAhPSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZXNjYXBlIGNvbnN0IChjb25zdClcbnZhciBjYW1sX2pzX3JlZ2V4cHMgPSB7IGFtcDovJi9nLCBsdDovPC9nLCBxdW90Oi9cXFwiL2csIGFsbDovWyY8XFxcIl0vIH07XG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZXNjYXBlIChzKSB7XG4gIGlmICghY2FtbF9qc19yZWdleHBzLmFsbC50ZXN0KHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIHMucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMuYW1wLCBcIiZhbXA7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmx0LCBcIiZsdDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMucXVvdCwgXCImcXVvdDtcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lbnRpdGllc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VudGl0aWVzKHMpIHtcbiAgdmFyIGVudGl0eSA9IC9eJiM/WzAtOWEtekEtWl0rOyQvXG4gIGlmKHMubWF0Y2goZW50aXR5KSlcbiAge1xuICAgIHZhciBzdHIsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgdGVtcC5pbm5lckhUTUw9IHM7XG4gICAgc3RyPSB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0O1xuICAgIHRlbXA9bnVsbDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJJbnZhbGlkIGVudGl0eSBcIiArIHMpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0X2NvbnNvbGUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0X2NvbnNvbGUgKCkge1xuICB2YXIgYyA9IGNvbnNvbGU7XG4gIHZhciBtID0gW1wibG9nXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwiYXNzZXJ0XCIsIFwiZGlyXCIsIFwiZGlyeG1sXCIsXG4gICAgICAgICAgIFwidHJhY2VcIiwgXCJncm91cFwiLCBcImdyb3VwQ29sbGFwc2VkXCIsIFwiZ3JvdXBFbmRcIiwgXCJ0aW1lXCIsIFwidGltZUVuZFwiXTtcbiAgZnVuY3Rpb24gZiAoKSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIGlmICghY1ttW2ldXSkgY1ttW2ldXT1mO1xuICByZXR1cm4gYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGUodW5pdCl7XG4gIGlmKHR5cGVvZiBnbG9iYWxUaGlzLlhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZ2xvYmFsVGhpcy5YTUxIdHRwUmVxdWVzdCB9IGNhdGNoIChlKSB7IH07XG4gIH1cbiAgaWYodHlwZW9mIGdsb2JhbFRoaXMuYWN0aXZlWE9iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGdsb2JhbFRoaXMuYWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLmFjdGl2ZVhPYmplY3QoXCJNc3htbDMuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICAgIHRyeSB7IHJldHVybiBuZXcgZ2xvYmFsVGhpcy5hY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgfVxuICBjYW1sX2ZhaWx3aXRoKFwiQ2Fubm90IGNyZWF0ZSBhIFhNTEh0dHBSZXF1ZXN0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24oZXhuKSB7XG4gIGlmKGV4bi5qc19lcnJvcikgeyByZXR1cm4gZXhuLmpzX2Vycm9yOyB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBBcnJheVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3N1YiBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X3N1YiAoYSwgaSwgbGVuKSB7XG4gIHZhciBhMiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGEyWzBdPTA7XG4gIGZvcih2YXIgaTIgPSAxLCBpMT0gaSsxOyBpMiA8PSBsZW47IGkyKyssaTErKyApe1xuICAgIGEyW2kyXT1hW2kxXTtcbiAgfVxuICByZXR1cm4gYTI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYXBwZW5kIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMikge1xuICB2YXIgbDEgPSBhMS5sZW5ndGgsIGwyID0gYTIubGVuZ3RoO1xuICB2YXIgbCA9IGwxK2wyLTFcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSAwO1xuICB2YXIgaSA9IDEsaiA9IDE7XG4gIGZvcig7aTxsMTtpKyspIGFbaV09YTFbaV07XG4gIGZvcig7aTxsO2krKyxqKyspIGFbaV09YTJbal07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2NvbmNhdCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2NvbmNhdChsKSB7XG4gIHZhciBhID0gWzBdO1xuICB3aGlsZSAobCAhPT0gMCkge1xuICAgIHZhciBiID0gbFsxXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGIubGVuZ3RoOyBpKyspIGEucHVzaChiW2ldKTtcbiAgICBsID0gbFsyXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vLy8vLy8vLy8vLy8gUGVydmFzaXZlXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3NldCAobXV0YWJsZSwgY29uc3QsIG11dGFibGUpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X3NldCAoYXJyYXksIGluZGV4LCBuZXd2YWwpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBhcnJheVtpbmRleCsxXT1uZXd2YWw7IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2dldCBtdXRhYmxlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZ2V0IChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXlbaW5kZXgrMV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZmlsbFxuZnVuY3Rpb24gY2FtbF9hcnJheV9maWxsKGFycmF5LCBvZnMsIGxlbiwgdil7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgYXJyYXlbb2ZzK2krMV0gPSB2O1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoZWNrX2JvdW5kIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoaW5kZXggPj4+IDAgPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV92ZWN0IGNvbnN0IChjb25zdCwgbXV0YWJsZSlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV92ZWN0IChsZW4sIGluaXQpIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSBpbml0O1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX2Zsb2F0X3ZlY3QgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX2Zsb2F0X3ZlY3QobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9jcmVhdGUobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4iLCIvLy8vLy8vLy8gQklOX1BST1RcblxuLy9Qcm92aWRlczogY2FtbF9jaGVja19ib3VuZF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nKGJpZ3N0cmluZywgaSl7XG4gIGlmIChpID4+PiAwID49IGJpZ3N0cmluZy5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2J1Zl9mbG9hdF9hcnJheV9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2NoZWNrX2JvdW5kLCBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZ1xuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9idWZfZmxvYXRfYXJyYXlfc3R1YihzcmNfcG9zLCBzcmMsIGRzdF9wb3MsIGRzdCwgbGVuKXtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICBjYW1sX2NoZWNrX2JvdW5kKGRzdCxkc3RfcG9zKTsgLy8gZmlyc3QgcG9zXG4gIGNhbWxfY2hlY2tfYm91bmQoZHN0LGRzdF9wb3MrbGVuLTEpOyAvLyBsYXN0IHBvc1xuICBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZyhzcmMsIHNyY19wb3MpOyAgLyogZmlyc3QgcG9zICovXG4gIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nKHNyYywgc3JjX3BvcyArIGxlbiAqIDggLSAxKTsgLyogbGFzdCBwb3MgKi9cbiAgdmFyIHZpZXcgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQ2NEFycmF5KGxlbik7XG4gIHZhciBidWZmZXIgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSh2aWV3LmJ1ZmZlcik7XG4gIGJ1ZmZlci5zZXQoc3JjLmRhdGEuc3ViYXJyYXkoc3JjX3Bvcywgc3JjX3BvcyArIChsZW4gKiA4KSkpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIC8vIFsrIDFdIGJlY2F1c2UgdGhlIHRhZyBpcyBhdCBwb3MgMCBcbiAgICBkc3RbZHN0X3BvcytpKzFdID0gdmlld1tpXTtcbiAgfVxuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogYmluX3Byb3RfYmxpdF9idWZfYnl0ZXNfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9idWZfYnl0ZXNfc3R1YihzcmNfcG9zLCBzcmMsIGRzdF9wb3MsIGRzdCwgbGVuKXtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMoc3JjLCBzcmNfcG9zLCBkc3QsIGRzdF9wb3MsIGxlbik7XG59XG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2Zsb2F0X2FycmF5X2J1Zl9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2NoZWNrX2JvdW5kLCBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZ1xuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9mbG9hdF9hcnJheV9idWZfc3R1YihzcmNfcG9zLHNyYywgZHN0X3BvcywgZHN0LCBsZW4pe1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDAgXG4gIGNhbWxfY2hlY2tfYm91bmQgKHNyYywgc3JjX3Bvcyk7IC8vIGZpcnN0IHBvcyBcbiAgY2FtbF9jaGVja19ib3VuZCAoc3JjLCBzcmNfcG9zICsgbGVuIC0gMSk7IC8vIGxhc3QgcG9zXG4gIGNhbWxfY2hlY2tfYm91bmRfYmlnc3RyaW5nKGRzdCwgZHN0X3Bvcyk7IC8qIGZpcnN0IHBvcyAqL1xuICBjYW1sX2NoZWNrX2JvdW5kX2JpZ3N0cmluZyhkc3QsIGRzdF9wb3MgKyBsZW4gKiA4IC0gMSk7IC8qIGxhc3QgcG9zICovXG4gIC8vIFsrIDFdIGJlY2F1c2UgdGhlIHRhZyBpcyBhdCBwb3MgMFxuICBzcmNfcG9zID0gc3JjX3BvcyArIDFcbiAgdmFyIGZsb2F0NjQgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQ2NEFycmF5KHNyYy5zbGljZShzcmNfcG9zLHNyY19wb3MgKyBsZW4pKTtcbiAgdmFyIGZsb2F0NjRfdWludDggPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShmbG9hdDY0LmJ1ZmZlcik7XG4gIHZhciB2aWV3ID0gZHN0LmRhdGEuc3ViYXJyYXkoZHN0X3BvcywgZHN0X3BvcyArIChsZW4gKiA4KSk7XG4gIHZpZXcuc2V0KGZsb2F0NjRfdWludDgpO1xuICByZXR1cm4gMFxufVxuLy9Qcm92aWRlczogYmluX3Byb3RfYmxpdF9zdHJpbmdfYnVmX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG5mdW5jdGlvbiBiaW5fcHJvdF9ibGl0X3N0cmluZ19idWZfc3R1YiAoc3JjX3Bvcywgc3JjLCBkc3RfcG9zLCBkc3QsIGxlbil7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzcmMsc3JjX3BvcywgZHN0LCBkc3RfcG9zLGxlbik7XG59XG4vL1Byb3ZpZGVzOiBiaW5fcHJvdF9ibGl0X2J5dGVzX2J1Zl9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9ieXRlc19idWZfc3R1YiAoc3JjX3Bvcywgc3JjLCBkc3RfcG9zLCBkc3QsIGxlbil7XG4gIHJldHVybiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzcmMsc3JjX3BvcywgZHN0LCBkc3RfcG9zLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGJpbl9wcm90X2JsaXRfYnVmX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEsIGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheVxuZnVuY3Rpb24gYmluX3Byb3RfYmxpdF9idWZfc3R1YiAoc3JjX3Bvcywgc3JjLCBkc3RfcG9zLCBkc3QsIGxlbil7XG4gIC8vIFtiaW5fcHJvdF9ibGl0X2J1Zl9zdHViXSBpcyB1c2VkIHdpdGggbWl4ZWQgYmlnYXJyYXkga2luZHMuXG4gIC8vIENvbnZlcnRlciBldmVyeXRoaW5nIHRvIGJpZ2FycmF5IG9mIGNoYXIgYmVmb3JlIHRoZSBibGl0LlxuICBpZihzcmMua2luZCAhPSAxMikgLy8gMTIgaXMgdGhlIGNoYXIga2luZFxuICAgIHNyYyA9IGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheShzcmMuZGF0YSk7XG4gIGlmKGRzdC5raW5kICE9IDEyKSAvLyAxMiBpcyB0aGUgY2hhciBraW5kXG4gICAgZHN0ID0gYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5KGRzdC5kYXRhKTtcbiAgcmV0dXJuIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEoc3JjLHNyY19wb3MsZHN0LGRzdF9wb3MsbGVuKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9jaGFuXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9tbF9pbnB1dF9ibG9ja1xuLy9SZXF1aXJlczogY2FtbF9NRDVJbml0LCBjYW1sX01ENVVwZGF0ZSwgY2FtbF9NRDVGaW5hbFxuZnVuY3Rpb24gY2FtbF9tZDVfY2hhbihjaGFuaWQsdG9yZWFkKXtcbiAgdmFyIGN0eCA9IGNhbWxfTUQ1SW5pdCgpO1xuICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoNDA5Nik7XG4gIGlmKHRvcmVhZCA8IDApe1xuICAgIHdoaWxlKHRydWUpe1xuICAgICAgdmFyIHJlYWQgPSBjYW1sX21sX2lucHV0X2Jsb2NrKGNoYW5pZCxidWZmZXIsMCxidWZmZXIubGVuZ3RoKTtcbiAgICAgIGlmKHJlYWQgPT0gMCkgYnJlYWs7XG4gICAgICBjYW1sX01ENVVwZGF0ZShjdHgsYnVmZmVyLnN1YmFycmF5KDAsIHJlYWQpLCByZWFkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUodG9yZWFkID4gMCkge1xuICAgICAgdmFyIHJlYWQgPSBjYW1sX21sX2lucHV0X2Jsb2NrKGNoYW5pZCxidWZmZXIsMCwgKHRvcmVhZCA+IGJ1ZmZlci5sZW5ndGggPyBidWZmZXIubGVuZ3RoIDogdG9yZWFkKSk7XG4gICAgICBpZihyZWFkID09IDApIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgICAgIGNhbWxfTUQ1VXBkYXRlKGN0eCxidWZmZXIuc3ViYXJyYXkoMCwgcmVhZCksIHJlYWQpO1xuICAgICAgdG9yZWFkIC09IHJlYWRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGNhbWxfTUQ1RmluYWwoY3R4KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfbWQ1X2J5dGVzXG5mdW5jdGlvbiBjYW1sX21kNV9zdHJpbmcocywgb2ZzLCBsZW4pIHtcbiAgcmV0dXJuIGNhbWxfbWQ1X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpLG9mcyxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX01ENVRyYW5zZm9ybVxudmFyIGNhbWxfTUQ1VHJhbnNmb3JtID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYWRkICh4LCB5KSB7IHJldHVybiAoeCArIHkpIHwgMDsgfVxuICBmdW5jdGlvbiB4eChxLGEsYix4LHMsdCkge1xuICAgIGEgPSBhZGQoYWRkKGEsIHEpLCBhZGQoeCwgdCkpO1xuICAgIHJldHVybiBhZGQoKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBmZihhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBnZyhhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBoaChhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpOyB9XG4gIGZ1bmN0aW9uIGlpKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTsgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAodywgYnVmZmVyKSB7XG4gICAgdmFyIGEgPSB3WzBdLCBiID0gd1sxXSwgYyA9IHdbMl0sIGQgPSB3WzNdO1xuXG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlclsgMF0sIDcsIDB4RDc2QUE0NzgpO1xuICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbIDFdLCAxMiwgMHhFOEM3Qjc1Nik7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlclsgMl0sIDE3LCAweDI0MjA3MERCKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyWyAzXSwgMjIsIDB4QzFCRENFRUUpO1xuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbIDRdLCA3LCAweEY1N0MwRkFGKTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyWyA1XSwgMTIsIDB4NDc4N0M2MkEpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbIDZdLCAxNywgMHhBODMwNDYxMyk7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlclsgN10sIDIyLCAweEZENDY5NTAxKTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyWyA4XSwgNywgMHg2OTgwOThEOCk7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlclsgOV0sIDEyLCAweDhCNDRGN0FGKTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyWzEwXSwgMTcsIDB4RkZGRjVCQjEpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbMTFdLCAyMiwgMHg4OTVDRDdCRSk7XG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlclsxMl0sIDcsIDB4NkI5MDExMjIpO1xuICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbMTNdLCAxMiwgMHhGRDk4NzE5Myk7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlclsxNF0sIDE3LCAweEE2Nzk0MzhFKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyWzE1XSwgMjIsIDB4NDlCNDA4MjEpO1xuXG4gICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlclsgMV0sIDUsIDB4RjYxRTI1NjIpO1xuICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbIDZdLCA5LCAweEMwNDBCMzQwKTtcbiAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyWzExXSwgMTQsIDB4MjY1RTVBNTEpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbIDBdLCAyMCwgMHhFOUI2QzdBQSk7XG4gICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlclsgNV0sIDUsIDB4RDYyRjEwNUQpO1xuICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbMTBdLCA5LCAweDAyNDQxNDUzKTtcbiAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyWzE1XSwgMTQsIDB4RDhBMUU2ODEpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbIDRdLCAyMCwgMHhFN0QzRkJDOCk7XG4gICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlclsgOV0sIDUsIDB4MjFFMUNERTYpO1xuICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbMTRdLCA5LCAweEMzMzcwN0Q2KTtcbiAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyWyAzXSwgMTQsIDB4RjRENTBEODcpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbIDhdLCAyMCwgMHg0NTVBMTRFRCk7XG4gICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlclsxM10sIDUsIDB4QTlFM0U5MDUpO1xuICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbIDJdLCA5LCAweEZDRUZBM0Y4KTtcbiAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyWyA3XSwgMTQsIDB4Njc2RjAyRDkpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbMTJdLCAyMCwgMHg4RDJBNEM4QSk7XG5cbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyWyA1XSwgNCwgMHhGRkZBMzk0Mik7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlclsgOF0sIDExLCAweDg3NzFGNjgxKTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyWzExXSwgMTYsIDB4NkQ5RDYxMjIpO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbMTRdLCAyMywgMHhGREU1MzgwQyk7XG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlclsgMV0sIDQsIDB4QTRCRUVBNDQpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbIDRdLCAxMSwgMHg0QkRFQ0ZBOSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlclsgN10sIDE2LCAweEY2QkI0QjYwKTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyWzEwXSwgMjMsIDB4QkVCRkJDNzApO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbMTNdLCA0LCAweDI4OUI3RUM2KTtcbiAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyWyAwXSwgMTEsIDB4RUFBMTI3RkEpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbIDNdLCAxNiwgMHhENEVGMzA4NSk7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlclsgNl0sIDIzLCAweDA0ODgxRDA1KTtcbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyWyA5XSwgNCwgMHhEOUQ0RDAzOSk7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlclsxMl0sIDExLCAweEU2REI5OUU1KTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyWzE1XSwgMTYsIDB4MUZBMjdDRjgpO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbIDJdLCAyMywgMHhDNEFDNTY2NSk7XG5cbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyWyAwXSwgNiwgMHhGNDI5MjI0NCk7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlclsgN10sIDEwLCAweDQzMkFGRjk3KTtcbiAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyWzE0XSwgMTUsIDB4QUI5NDIzQTcpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbIDVdLCAyMSwgMHhGQzkzQTAzOSk7XG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlclsxMl0sIDYsIDB4NjU1QjU5QzMpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbIDNdLCAxMCwgMHg4RjBDQ0M5Mik7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlclsxMF0sIDE1LCAweEZGRUZGNDdEKTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyWyAxXSwgMjEsIDB4ODU4NDVERDEpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbIDhdLCA2LCAweDZGQTg3RTRGKTtcbiAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyWzE1XSwgMTAsIDB4RkUyQ0U2RTApO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbIDZdLCAxNSwgMHhBMzAxNDMxNCk7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlclsxM10sIDIxLCAweDRFMDgxMUExKTtcbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyWyA0XSwgNiwgMHhGNzUzN0U4Mik7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlclsxMV0sIDEwLCAweEJEM0FGMjM1KTtcbiAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyWyAyXSwgMTUsIDB4MkFEN0QyQkIpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbIDldLCAyMSwgMHhFQjg2RDM5MSk7XG5cbiAgICB3WzBdID0gYWRkKGEsIHdbMF0pO1xuICAgIHdbMV0gPSBhZGQoYiwgd1sxXSk7XG4gICAgd1syXSA9IGFkZChjLCB3WzJdKTtcbiAgICB3WzNdID0gYWRkKGQsIHdbM10pO1xuICB9fSkoKVxuXG4vL1Byb3ZpZGVzOiBjYW1sX01ENUluaXRcbmZ1bmN0aW9uIGNhbWxfTUQ1SW5pdCgpIHtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig2NCk7XG4gIHZhciBiMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgdmFyIGI4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgcmV0dXJuIHtsZW46MCxcbiAgICAgICAgICB3Om5ldyBVaW50MzJBcnJheShbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3Nl0pLFxuICAgICAgICAgIGIzMjpiMzIsXG4gICAgICAgICAgYjg6Yjh9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfTUQ1VXBkYXRlXG4vL1JlcXVpcmVzOiBjYW1sX01ENVRyYW5zZm9ybVxuZnVuY3Rpb24gY2FtbF9NRDVVcGRhdGUoY3R4LCBpbnB1dCwgaW5wdXRfbGVuKXtcbiAgdmFyIGluX2J1ZiA9IGN0eC5sZW4gJiAweDNmO1xuICB2YXIgaW5wdXRfcG9zID0gMDtcbiAgY3R4LmxlbiArPSBpbnB1dF9sZW47XG4gIGlmKGluX2J1Zil7XG4gICAgdmFyIG1pc3NpbmcgPSA2NCAtIGluX2J1ZjtcbiAgICBpZihpbnB1dF9sZW4gPCBtaXNzaW5nKSB7XG4gICAgICBjdHguYjguc2V0KGlucHV0LnN1YmFycmF5KDAsaW5wdXRfbGVuKSxpbl9idWYpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGN0eC5iOC5zZXQoaW5wdXQuc3ViYXJyYXkoMCxtaXNzaW5nKSxpbl9idWYpO1xuICAgIGNhbWxfTUQ1VHJhbnNmb3JtKGN0eC53LCBjdHguYjMyKTtcbiAgICBpbnB1dF9sZW4gLT0gbWlzc2luZztcbiAgICBpbnB1dF9wb3MgKz0gbWlzc2luZztcbiAgfVxuICB3aGlsZShpbnB1dF9sZW4gPj0gNjQpe1xuICAgIGN0eC5iOC5zZXQoaW5wdXQuc3ViYXJyYXkoaW5wdXRfcG9zLGlucHV0X3BvcyArIDY0KSwgMCk7XG4gICAgY2FtbF9NRDVUcmFuc2Zvcm0oY3R4LncsIGN0eC5iMzIpO1xuICAgIGlucHV0X2xlbiAtPSA2NDtcbiAgICBpbnB1dF9wb3MgKz0gNjQ7XG4gIH1cbiAgaWYoaW5wdXRfbGVuKVxuICAgIGN0eC5iOC5zZXQoaW5wdXQuc3ViYXJyYXkoaW5wdXRfcG9zLGlucHV0X3BvcyArIGlucHV0X2xlbiksIDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX01ENUZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX01ENVRyYW5zZm9ybVxuZnVuY3Rpb24gY2FtbF9NRDVGaW5hbChjdHgpe1xuICB2YXIgaW5fYnVmID0gY3R4LmxlbiAmIDB4M2Y7XG4gIGN0eC5iOFtpbl9idWZdID0gMHg4MDtcbiAgaW5fYnVmICsrO1xuICBpZihpbl9idWYgPiA1Nikge1xuICAgIGZvcih2YXIgaiA9IGluX2J1ZjsgaiA8IDY0OyBqKyspe1xuICAgICAgY3R4LmI4W2pdID0gMDtcbiAgICB9XG4gICAgY2FtbF9NRDVUcmFuc2Zvcm0oY3R4LncsIGN0eC5iMzIpO1xuICAgIGZvcih2YXIgaiA9IDA7IGogPCA1NjsgaisrKXtcbiAgICAgIGN0eC5iOFtqXSA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvcih2YXIgaiA9IGluX2J1ZjsgaiA8IDU2OyBqKyspe1xuICAgICAgY3R4LmI4W2pdID0gMDtcbiAgICB9XG4gIH1cbiAgY3R4LmIzMlsxNF0gPSBjdHgubGVuIDw8IDM7XG4gIGN0eC5iMzJbMTVdID0gKGN0eC5sZW4gPj4gMjkpICYgMHgxRkZGRkZGRjtcbiAgY2FtbF9NRDVUcmFuc2Zvcm0oY3R4LncsIGN0eC5iMzIpO1xuICB2YXIgdCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICB0W2kgKiA0ICsgal0gPSAoY3R4LndbaV0gPj4gKDggKiBqKSkgJiAweEZGO1xuICByZXR1cm4gdDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfTUQ1SW5pdCwgY2FtbF9NRDVVcGRhdGUsIGNhbWxfTUQ1RmluYWxcbmZ1bmN0aW9uIGNhbWxfbWQ1X2J5dGVzKHMsIG9mcywgbGVuKSB7XG4gIHZhciBjdHggPSBjYW1sX01ENUluaXQoKTtcbiAgdmFyIGEgPSBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzKHMpO1xuICBjYW1sX01ENVVwZGF0ZShjdHgsYS5zdWJhcnJheShvZnMsIG9mcyArIGxlbiksIGxlbik7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShjYW1sX01ENUZpbmFsKGN0eCkpO1xufVxuIiwiLy9Qcm92aWRlczogcHB4X2V4cGVjdF9ydW50aW1lX3NhdmVkX3N0ZG91dFxudmFyIHBweF9leHBlY3RfcnVudGltZV9zYXZlZF9zdGRvdXRcbi8vUHJvdmlkZXM6IHBweF9leHBlY3RfcnVudGltZV9zYXZlZF9zdGRlcnJcbnZhciBwcHhfZXhwZWN0X3J1bnRpbWVfc2F2ZWRfc3RkZXJyXG5cbi8vUHJvdmlkZXM6IHBweF9leHBlY3RfcnVudGltZV9iZWZvcmVfdGVzdFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogcHB4X2V4cGVjdF9ydW50aW1lX3NhdmVkX3N0ZGVyciwgcHB4X2V4cGVjdF9ydW50aW1lX3NhdmVkX3N0ZG91dFxuZnVuY3Rpb24gcHB4X2V4cGVjdF9ydW50aW1lX2JlZm9yZV90ZXN0ICh2b3V0cHV0LCB2c3Rkb3V0LCB2c3RkZXJyKXtcbiAgcHB4X2V4cGVjdF9ydW50aW1lX3NhdmVkX3N0ZGVyciA9IGNhbWxfbWxfY2hhbm5lbHNbdnN0ZGVycl07XG4gIHBweF9leHBlY3RfcnVudGltZV9zYXZlZF9zdGRvdXQgPSBjYW1sX21sX2NoYW5uZWxzW3ZzdGRvdXRdO1xuICB2YXIgb3V0cHV0ID0gY2FtbF9tbF9jaGFubmVsc1t2b3V0cHV0XTtcbiAgY2FtbF9tbF9jaGFubmVsc1t2c3Rkb3V0XSA9IG91dHB1dDtcbiAgY2FtbF9tbF9jaGFubmVsc1t2c3RkZXJyXSA9IG91dHB1dDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IHBweF9leHBlY3RfcnVudGltZV9hZnRlcl90ZXN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBwcHhfZXhwZWN0X3J1bnRpbWVfc2F2ZWRfc3RkZXJyLCBwcHhfZXhwZWN0X3J1bnRpbWVfc2F2ZWRfc3Rkb3V0XG5mdW5jdGlvbiBwcHhfZXhwZWN0X3J1bnRpbWVfYWZ0ZXJfdGVzdCAodnN0ZG91dCwgdnN0ZGVycil7XG4gIGNhbWxfbWxfY2hhbm5lbHNbdnN0ZG91dF0gPSBwcHhfZXhwZWN0X3J1bnRpbWVfc2F2ZWRfc3Rkb3V0O1xuICBjYW1sX21sX2NoYW5uZWxzW3ZzdGRlcnJdID0gcHB4X2V4cGVjdF9ydW50aW1lX3NhdmVkX3N0ZGVycjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IHBweF9leHBlY3RfcnVudGltZV9vdXRfY2hhbm5lbF9wb3NpdGlvblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gcHB4X2V4cGVjdF9ydW50aW1lX291dF9jaGFubmVsX3Bvc2l0aW9uKGNoYW4pe1xuICB2YXIgaW5mbyA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbl07XG4gIHJldHVybiBpbmZvLm9mZnNldFxufVxuXG4vL1Byb3ZpZGVzOiBwcHhfZXhwZWN0X3J1bnRpbWVfZmx1c2hfc3R1YnNfc3RyZWFtc1xuZnVuY3Rpb24gcHB4X2V4cGVjdF9ydW50aW1lX2ZsdXNoX3N0dWJzX3N0cmVhbXModnVuaXQpe1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gSHVnbyBIZXV6YXJkXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgLSBTaGFjaGFyIEl0emhha3lcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9vY2FtbC9ibG9iLzQuMDcvb3RoZXJsaWJzL3N0ci9zdHJzdHVicy5jXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanNjb3EvanNjb3EvYmxvYi92OC4xMS9jb3EtanMvanNfc3R1Yi9zdHIuanNcblxuLy9Qcm92aWRlczogcmVfbWF0Y2hcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2dldFxuXG52YXIgcmVfbWF0Y2ggPSBmdW5jdGlvbigpe1xuICB2YXIgcmVfd29yZF9sZXR0ZXJzID0gW1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4MDAtMHgxRjogbm9uZSAqL1xuICAgIDB4MDAsIDB4MDAsIDB4RkYsIDB4MDMsICAgICAgIC8qIDB4MjAtMHgzRjogZGlnaXRzIDAtOSAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4ODcsICAgICAgIC8qIDB4NDAtMHg1RjogQSB0byBaLCBfICovXG4gICAgMHhGRSwgMHhGRiwgMHhGRiwgMHgwNywgICAgICAgLyogMHg2MC0weDdGOiBhIHRvIHogKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDgwLTB4OUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweEEwLTB4QkY6IG5vbmUgKi9cbiAgICAweEZGLCAweEZGLCAweDdGLCAweEZGLCAgICAgICAvKiAweEMwLTB4REY6IExhdGluLTEgYWNjZW50ZWQgdXBwZXJjYXNlICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiAgICAgICAgLyogMHhFMC0weEZGOiBMYXRpbi0xIGFjY2VudGVkIGxvd2VyY2FzZSAqL1xuICBdO1xuXG4gIHZhciBvcGNvZGVzID0ge1xuICAgIENIQVI6IDAsIENIQVJOT1JNOiAxLCBTVFJJTkc6IDIsIFNUUklOR05PUk06IDMsIENIQVJDTEFTUzogNCxcbiAgICBCT0w6IDUsIEVPTDogNiwgV09SREJPVU5EQVJZOiA3LFxuICAgIEJFR0dST1VQOiA4LCBFTkRHUk9VUDogOSwgUkVGR1JPVVA6IDEwLFxuICAgIEFDQ0VQVDogMTEsXG4gICAgU0lNUExFT1BUOiAxMiwgU0lNUExFU1RBUjogMTMsIFNJTVBMRVBMVVM6IDE0LFxuICAgIEdPVE86IDE1LCBQVVNIQkFDSzogMTYsIFNFVE1BUks6IDE3LFxuICAgIENIRUNLUFJPR1JFU1M6IDE4XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfd29yZF9sZXR0ZXIoYykge1xuICAgIHJldHVybiAocmVfd29yZF9sZXR0ZXJzWyAgKGMgPj4gMyldID4+IChjICYgNykpICYgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX2JpdHNldChzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfc3RyaW5nX2dldChzLChpID4+IDMpKSA+PiAoaSAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiByZV9tYXRjaF9pbXBsKHJlLCBzLCBwb3MsIHBhcnRpYWwpIHtcblxuICAgIHZhciBwcm9nICAgICAgICAgID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzFdKSxcbiAgICAgICAgY3Bvb2wgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsyXSksXG4gICAgICAgIG5vcm10YWJsZSAgICAgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHJlWzNdKSxcbiAgICAgICAgbnVtZ3JvdXBzICAgICA9IHJlWzRdIHwgMCxcbiAgICAgICAgbnVtcmVnaXN0ZXJzICA9IHJlWzVdIHwgMCxcbiAgICAgICAgc3RhcnRjaGFycyAgICA9IHJlWzZdIHwgMDtcblxuICAgIHZhciBzID0gY2FtbF91aW50OF9hcnJheV9vZl9zdHJpbmcocyk7XG5cbiAgICB2YXIgcGMgPSAwLFxuICAgICAgICBxdWl0ID0gZmFsc2UsXG4gICAgICAgIHN0YWNrID0gW10sXG4gICAgICAgIGdyb3VwcyA9IG5ldyBBcnJheShudW1ncm91cHMpLFxuICAgICAgICByZV9yZWdpc3RlciA9IG5ldyBBcnJheShudW1yZWdpc3RlcnMpO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyl7XG4gICAgICBncm91cHNbaV0gPSB7c3RhcnQ6IC0xLCBlbmQ6LTF9XG4gICAgfVxuICAgIGdyb3Vwc1swXS5zdGFydCA9IHBvcztcblxuICAgIHZhciBiYWNrdHJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHZhciBpdGVtID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGlmIChpdGVtLnVuZG8pIHtcbiAgICAgICAgICBpdGVtLnVuZG8ub2JqW2l0ZW0udW5kby5wcm9wXSA9IGl0ZW0udW5kby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGl0ZW0ucG9zKSB7XG4gICAgICAgICAgcGMgPSBpdGVtLnBvcy5wYztcbiAgICAgICAgICBwb3MgPSBpdGVtLnBvcy50eHQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWl0ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHB1c2ggPSBmdW5jdGlvbihpdGVtKSB7IHN0YWNrLnB1c2goaXRlbSk7IH07XG5cbiAgICB2YXIgYWNjZXB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZ3JvdXBzWzBdLmVuZCA9IHBvcztcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoMSArIGdyb3Vwcy5sZW5ndGgqMik7XG4gICAgICByZXN1bHRbMF0gPSAwOyAvLyB0YWdcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZyA9IGdyb3Vwc1tpXTtcbiAgICAgICAgaWYoZy5zdGFydCA8IDAgfHwgZy5lbmQgPCAwKSB7XG4gICAgICAgICAgZy5zdGFydCA9IGcuZW5kID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0WzIqaSArIDEgXSA9IGcuc3RhcnQ7XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxICsgMSBdID0gZy5lbmQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICB2YXIgcHJlZml4X21hdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYocGFydGlhbCkgcmV0dXJuIGFjY2VwdCAoKTtcbiAgICAgIGVsc2UgYmFja3RyYWNrICgpO1xuICAgIH1cblxuICAgIC8qIE1haW4gREZBIGludGVycHJldGVyIGxvb3AgKi9cbiAgICB3aGlsZSAoIXF1aXQpIHtcbiAgICAgIHZhciBvcCA9IHByb2dbcGNdICYgMHhmZixcbiAgICAgICAgICBzYXJnID0gcHJvZ1twY10gPj4gOCxcbiAgICAgICAgICB1YXJnID0gc2FyZyAmIDB4ZmYsXG4gICAgICAgICAgYyA9IHNbcG9zXSxcbiAgICAgICAgICBncm91cDtcblxuICAgICAgcGMrKztcblxuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVI6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGMgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSTk9STTpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkc6XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAoYyA9PT0gYXJnLmNoYXJDb2RlQXQoaSkpXG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgZWxzZSB7IGJhY2t0cmFjaygpOyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNUUklOR05PUk06XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSQ0xBU1M6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CT0w6XG4gICAgICAgIGlmKHBvcyA+IDAgJiYgc1twb3MgLSAxXSAhPSAxMCAvKiBcXG4gKi8pIHtiYWNrdHJhY2soKX1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU9MOlxuICAgICAgICBpZihwb3MgPCBzLmxlbmd0aCAmJiBzW3Bvc10gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLldPUkRCT1VOREFSWTpcbiAgICAgICAgaWYocG9zID09IDApIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1swXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrICgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbcG9zIC0gMV0pICE9IGlzX3dvcmRfbGV0dGVyKHNbcG9zXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CRUdHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6Z3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOidzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuc3RhcnR9fSk7XG4gICAgICAgIGdyb3VwLnN0YXJ0ID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5FTkRHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBncm91cC5lbmR9fSk7XG4gICAgICAgIGdyb3VwLmVuZCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuUkVGR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBpZihncm91cC5zdGFydCA8IDAgfHwgZ3JvdXAuZW5kIDwgMCkge2JhY2t0cmFjayAoKTsgYnJlYWt9XG4gICAgICAgIGZvciAodmFyIGkgPSBncm91cC5zdGFydDsgaSA8IGdyb3VwLmVuZDsgaSsrKXtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoc1tpXSAhPSBzW3Bvc10pIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRU9QVDpcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVTVEFSOlxuICAgICAgICB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSlcbiAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVBMVVM6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgfSB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQUNDRVBUOlxuICAgICAgICByZXR1cm4gYWNjZXB0KCk7XG4gICAgICBjYXNlIG9wY29kZXMuR09UTzpcbiAgICAgICAgcGMgPSBwYyArIHNhcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlBVU0hCQUNLOlxuICAgICAgICBwdXNoKHtwb3M6IHtwYzogcGMgKyBzYXJnLCB0eHQ6IHBvc319KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0VUTUFSSzpcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajpyZV9yZWdpc3RlcixcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6IHVhcmcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVfcmVnaXN0ZXJbdWFyZ119fSk7XG4gICAgICAgIHJlX3JlZ2lzdGVyW3VhcmddID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEVDS1BST0dSRVNTOlxuICAgICAgICBpZiAocmVfcmVnaXN0ZXJbdWFyZ10gPT09IHBvcykgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlY29kZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gcmVfbWF0Y2hfaW1wbDtcbn0oKTtcblxuXG4vL1Byb3ZpZGVzOiByZV9zZWFyY2hfZm9yd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfZm9yd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfZm9yd2FyZFwiKVxuICB3aGlsZSAocG9zIDw9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2JhY2t3YXJkXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3NlYXJjaF9iYWNrd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfYmFja3dhcmRcIilcbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zLS07XG4gIH1cblxuICByZXR1cm4gWzBdOyAgLyogW3x8XSA6IGludCBhcnJheSAqL1xufVxuXG5cbi8vUHJvdmlkZXM6IHJlX3N0cmluZ19tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zdHJpbmdfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc3RyaW5nX21hdGNoXCIpXG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9wYXJ0aWFsX21hdGNoXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3BhcnRpYWxfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIucGFydGlhbF9tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMSk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcmVwbGFjZW1lbnRfdGV4dFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9hcnJheV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIGV4dGVybmFsIHJlX3JlcGxhY2VtZW50X3RleHQ6IHN0cmluZyAtPiBpbnQgYXJyYXkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuZnVuY3Rpb24gcmVfcmVwbGFjZW1lbnRfdGV4dChyZXBsLGdyb3VwcyxvcmlnKSB7XG4gIHZhciByZXBsID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZXBsKTtcbiAgdmFyIGxlbiA9IHJlcGwubGVuZ3RoO1xuICB2YXIgb3JpZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob3JpZyk7XG4gIHZhciByZXMgPSBcIlwiOyAvL3Jlc3VsdFxuICB2YXIgbiA9IDA7IC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgdmFyIGN1cjsgLy9jdXJyZW50IGNoYXJcbiAgdmFyIHN0YXJ0LCBlbmQsIGM7XG4gIHdoaWxlKG4gPCBsZW4pe1xuICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgaWYoY3VyICE9ICdcXFxcJyl7XG4gICAgICByZXMgKz0gY3VyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKG4gPT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IGlsbGVnYWwgYmFja3NsYXNoIHNlcXVlbmNlXCIpO1xuICAgICAgY3VyID0gcmVwbC5jaGFyQXQobisrKTtcbiAgICAgIHN3aXRjaChjdXIpe1xuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIHJlcyArPSBjdXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMCc6IGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOlxuICAgICAgY2FzZSAnNSc6IGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgICBjID0gK2N1cjtcbiAgICAgICAgaWYgKGMqMiA+PSBncm91cHMubGVuZ3RoIC0gMSApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIgKTtcbiAgICAgICAgc3RhcnQgPSBjYW1sX2FycmF5X2dldChncm91cHMsYyoyKTtcbiAgICAgICAgZW5kID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLCBjKjIgKzEpO1xuICAgICAgICBpZiAoc3RhcnQgPT0gLTEpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIpO1xuICAgICAgICByZXMrPW9yaWcuc2xpY2Uoc3RhcnQsZW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgKz0gKCdcXFxcJyAgKyBjdXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhyZXMpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9zdHJfaW5pdGlhbGl6ZVxuZnVuY3Rpb24gY2FtbF9zdHJfaW5pdGlhbGl6ZSh1bml0KSB7XG4gIHJldHVybiAwO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IGxleGluZy5jIDYwNDUgMjAwNC0wMS0wMSAxNjo0Mjo0M1ogZG9saWdleiAkICovXG5cbi8qIFRoZSB0YWJsZS1kcml2ZW4gYXV0b21hdG9uIGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXguICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9hcnJheShzKSB7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpO1xuICB2YXIgbCA9IHMubGVuZ3RoIC8gMjtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgIGFbaV0gPSAocy5jaGFyQ29kZUF0KDIgKiBpKSB8IChzLmNoYXJDb2RlQXQoMiAqIGkgKyAxKSA8PCA4KSkgPDwgMTYgPj4gMTY7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5LCBjYW1sX3VpbnQ4X2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfdWludDhfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHJldHVybiAtYmFzZS0xO1xuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogTmV3IGxleGVyIGVuZ2luZSwgd2l0aCBtZW1vcnkgb2YgcG9zaXRpb25zICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF91aW50OF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX21lbShzLCBpLCBtZW0sIGN1cnJfcG9zKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm47XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBjdXJyX3BvcztcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fdGFnKHMsIGksIG1lbSkge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuIDtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IC0xO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbmV3X2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9tZW0gPSAxMDtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuICB2YXIgbGV4X2Jhc2VfY29kZSA9IDY7XG4gIHZhciBsZXhfYmFja3Rya19jb2RlID0gNztcbiAgdmFyIGxleF9kZWZhdWx0X2NvZGUgPSA4O1xuICB2YXIgbGV4X3RyYW5zX2NvZGUgPSA5O1xuICB2YXIgbGV4X2NoZWNrX2NvZGUgPSAxMDtcbiAgdmFyIGxleF9jb2RlID0gMTE7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHRfY29kZSkge1xuICAgIHRibC5sZXhfYmFzZV9jb2RlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV9jb2RlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrX2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrX2NvZGVdKTtcbiAgICB0YmwubGV4X2NoZWNrX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrX2NvZGVdKTtcbiAgICB0YmwubGV4X3RyYW5zX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zX2NvZGVdKTtcbiAgICB0YmwubGV4X2RlZmF1bHRfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRfY29kZV0pO1xuICB9XG4gIGlmICh0YmwubGV4X2NvZGUgPT0gbnVsbCkgdGJsLmxleF9jb2RlID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0YmxbbGV4X2NvZGVdKTtcblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF91aW50OF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFzZV9jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICByZXR1cm4gLWJhc2UtMTtcbiAgICB9XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFja3Rya19jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIHZhciBwc3RhdGUgPSBzdGF0ZSA7XG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBJZiBzb21lIHRyYW5zaXRpb24sIGdldCBhbmQgcGVyZm9ybSBtZW1vcnkgbW92ZXMgKi9cbiAgICAgIHZhciBiYXNlX2NvZGUgPSB0YmwubGV4X2Jhc2VfY29kZVtwc3RhdGVdLCBwY19vZmY7XG4gICAgICBpZiAodGJsLmxleF9jaGVja19jb2RlW2Jhc2VfY29kZSArIGNdID09IHBzdGF0ZSlcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF90cmFuc19jb2RlW2Jhc2VfY29kZSArIGNdO1xuICAgICAgZWxzZVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X2RlZmF1bHRfY29kZVtwc3RhdGVdO1xuICAgICAgaWYgKHBjX29mZiA+IDApXG4gICAgICAgIGNhbWxfbGV4X3J1bl9tZW1cbiAgICAgICh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dLCBsZXhidWZbbGV4X2N1cnJfcG9zXSk7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cbiIsIi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50X3BvcGNvdW50IGNvbnN0XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudCh2KSB7XG4gIHYgPSB2IC0gKCh2ID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICB2ID0gKHYgJiAweDMzMzMzMzMzKSArICgodiA+Pj4gMikgJiAweDMzMzMzMzMzKTtcbiAgcmV0dXJuICgodiArICh2ID4+PiA0KSAmIDB4RjBGMEYwRikgKiAweDEwMTAxMDEpID4+PiAyNDtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9jbGVhcl9jYW1sX2JhY2t0cmFjZV9wb3MgY29uc3RcbmZ1bmN0aW9uIEJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zKHgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfY2FtbF9leG5faXNfbW9zdF9yZWNlbnRfZXhuIGNvbnN0XG5mdW5jdGlvbiBCYXNlX2NhbWxfZXhuX2lzX21vc3RfcmVjZW50X2V4bih4KSB7XG4gIHJldHVybiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludDMyX2NseiBjb25zdFxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHooeCkge1xuICB2YXIgbiA9IDMyO1xuICB2YXIgeTtcbiAgeSA9IHggPj4gMTY7IGlmICh5ICE9IDApIHsgbiA9IG4gLSAxNjsgeCA9IHk7IH1cbiAgeSA9IHggPj4gODsgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDg7IHggPSB5OyB9XG4gIHkgPSB4ID4+IDQ7IGlmICh5ICE9IDApIHsgbiA9IG4gLSA0OyB4ID0geTsgfVxuICB5ID0geCA+PiAyOyBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gMjsgeCA9IHk7IH1cbiAgeSA9IHggPj4gMTsgaWYgKHkgIT0gMCkgcmV0dXJuIG4gLSAyO1xuICByZXR1cm4gbiAtIHg7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50X2NseiBjb25zdFxuLy9SZXF1aXJlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHpcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50X2Nseih4KSB7IHJldHVybiBCYXNlX2ludF9tYXRoX2ludDMyX2Nseih4KTsgfVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHogY29uc3Rcbi8vUmVxdWlyZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY2x6XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHooeCkgeyByZXR1cm4gQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHooeCk7IH1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHogY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQsIGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9pbnQ2NF90b19pbnQzMlxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHooeCkge1xuICB2YXIgbiA9IDY0O1xuICB2YXIgeTtcbiAgeSA9IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQoeCwgMzIpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtIDMyOyB4ID0geTsgfVxuICB5ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAxNik7XG4gIGlmICghY2FtbF9pbnQ2NF9pc196ZXJvKHkpKSB7IG4gPSBuIC0gMTY7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDgpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtIDg7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDQpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtIDQ7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDIpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgeyBuID0gbiAtIDI7IHggPSB5OyB9XG4gIHkgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDEpO1xuICBpZiAoIWNhbWxfaW50NjRfaXNfemVybyh5KSkgcmV0dXJuIG4gLSAyO1xuICByZXR1cm4gbiAtIGNhbWxfaW50NjRfdG9faW50MzIoeCk7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfaW50MzJfY3R6IGNvbnN0XG5mdW5jdGlvbiBCYXNlX2ludF9tYXRoX2ludDMyX2N0eih4KSB7XG4gIGlmICh4ID09PSAwKSB7IHJldHVybiAzMjsgfVxuICB2YXIgbiA9IDE7XG4gIGlmICgoeCAmIDB4MDAwMEZGRkYpID09PSAwKSB7IG4gPSBuICsgMTY7IHggPSB4ID4+IDE2OyB9XG4gIGlmICgoeCAmIDB4MDAwMDAwRkYpID09PSAwKSB7IG4gPSBuICsgODsgeCA9IHggPj4gODsgfVxuICBpZiAoKHggJiAweDAwMDAwMDBGKSA9PT0gMCkgeyBuID0gbiArIDQ7IHggPSB4ID4+IDQ7IH1cbiAgaWYgKCh4ICYgMHgwMDAwMDAwMykgPT09IDApIHsgbiA9IG4gKyAyOyB4ID0geCA+PiAyOyB9XG4gIHJldHVybiBuIC0gKHggJiAxKTtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnRfY3R6IGNvbnN0XG4vL1JlcXVpcmVzOiBCYXNlX2ludF9tYXRoX2ludDMyX2N0elxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnRfY3R6KHgpIHsgcmV0dXJuIEJhc2VfaW50X21hdGhfaW50MzJfY3R6KHgpOyB9XG5cbi8vUHJvdmlkZXM6IEJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0eiBjb25zdFxuLy9SZXF1aXJlczogQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHpcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0eih4KSB7IHJldHVybiBCYXNlX2ludF9tYXRoX2ludDMyX2N0eih4KTsgfVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2ludF9tYXRoX2ludDY0X2N0eiBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCwgY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX2ludDY0X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FuZCwgY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGlcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50NjRfY3R6KHgpIHtcbiAgaWYgKGNhbWxfaW50NjRfaXNfemVybyh4KSkgeyByZXR1cm4gNjQ7IH1cbiAgdmFyIG4gPSAxO1xuICBmdW5jdGlvbiBpc196ZXJvKHgpIHsgcmV0dXJuIGNhbWxfaW50NjRfaXNfemVybyh4KTsgfVxuICBmdW5jdGlvbiBsYW5kKHgsIHkpIHsgcmV0dXJuIGNhbWxfaW50NjRfYW5kKHgsIHkpOyB9XG4gIGZ1bmN0aW9uIHNtYWxsX2ludDY0KHgpIHsgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHgsIDAsIDApOyB9XG4gIGlmIChpc196ZXJvKGxhbmQoeCwgY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMHhGRkZGRkYsIDB4MDAwMEZGLCAweDAwMDApKSkpIHtcbiAgICBuID0gbiArIDMyOyB4ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAzMik7XG4gIH1cbiAgaWYgKGlzX3plcm8obGFuZCh4LCBzbWFsbF9pbnQ2NCgweDAwRkZGRikpKSkge1xuICAgIG4gPSBuICsgMTY7IHggPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHgsIDE2KTtcbiAgfVxuICBpZiAoaXNfemVybyhsYW5kKHgsIHNtYWxsX2ludDY0KDB4MDAwMEZGKSkpKSB7XG4gICAgbiA9IG4gKyA4OyB4ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCA4KTtcbiAgfVxuICBpZiAoaXNfemVybyhsYW5kKHgsIHNtYWxsX2ludDY0KDB4MDAwMDBGKSkpKSB7XG4gICAgbiA9IG4gKyA0OyB4ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCA0KTtcbiAgfVxuICBpZiAoaXNfemVybyhsYW5kKHgsIHNtYWxsX2ludDY0KDB4MDAwMDAzKSkpKSB7XG4gICAgbiA9IG4gKyAyOyB4ID0gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LCAyKTtcbiAgfVxuICByZXR1cm4gbiAtIChjYW1sX2ludDY0X3RvX2ludDMyKGNhbWxfaW50NjRfYW5kKHgsIHNtYWxsX2ludDY0KDB4MDAwMDAxKSkpKTtcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnRfcG93X3N0dWIgY29uc3RcbmZ1bmN0aW9uIEJhc2VfaW50X21hdGhfaW50X3Bvd19zdHViKGJhc2UsIGV4cG9uZW50KSB7XG4gIHZhciBvbmUgPSAxO1xuICB2YXIgbXVsID0gW29uZSwgYmFzZSwgb25lLCBvbmVdO1xuICB2YXIgcmVzID0gb25lO1xuICB3aGlsZSAoIWV4cG9uZW50ID09IDApIHtcbiAgICBtdWxbMV0gPSAobXVsWzFdICogbXVsWzNdKSB8IDA7XG4gICAgbXVsWzJdID0gKG11bFsxXSAqIG11bFsxXSkgfCAwO1xuICAgIG11bFszXSA9IChtdWxbMl0gKiBtdWxbMV0pIHwgMDtcbiAgICByZXMgPSAocmVzICogbXVsW2V4cG9uZW50ICYgM10pIHwgMDtcbiAgICBleHBvbmVudCA9IGV4cG9uZW50ID4+IDI7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogQmFzZV9pbnRfbWF0aF9pbnQ2NF9wb3dfc3R1YiBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGksIGNhbWxfaW50NjRfbG8zMlxuZnVuY3Rpb24gQmFzZV9pbnRfbWF0aF9pbnQ2NF9wb3dfc3R1YihiYXNlLCBleHBvbmVudCkge1xuICB2YXIgb25lID0gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkoMSwgMCk7XG4gIHZhciBtdWwgPSBbb25lLCBiYXNlLCBvbmUsIG9uZV07XG4gIHZhciByZXMgPSBvbmU7XG4gIHdoaWxlICghY2FtbF9pbnQ2NF9pc196ZXJvKGV4cG9uZW50KSkge1xuICAgIG11bFsxXSA9IGNhbWxfaW50NjRfbXVsKG11bFsxXSwgbXVsWzNdKTtcbiAgICBtdWxbMl0gPSBjYW1sX2ludDY0X211bChtdWxbMV0sIG11bFsxXSk7XG4gICAgbXVsWzNdID0gY2FtbF9pbnQ2NF9tdWwobXVsWzJdLCBtdWxbMV0pO1xuICAgIHJlcyA9IGNhbWxfaW50NjRfbXVsKHJlcywgbXVsW2NhbWxfaW50NjRfbG8zMihleHBvbmVudCkgJiAzXSk7XG4gICAgZXhwb25lbnQgPSBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkKGV4cG9uZW50LCAyKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBCYXNlX2hhc2hfc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaFxuZnVuY3Rpb24gQmFzZV9oYXNoX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2hhc2goMSwgMSwgMCwgcylcbn1cbi8vUHJvdmlkZXM6IEJhc2VfaGFzaF9kb3VibGUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaFxuZnVuY3Rpb24gQmFzZV9oYXNoX2RvdWJsZShkKSB7XG4gIHJldHVybiBjYW1sX2hhc2goMSwgMSwgMCwgZCk7XG59XG5cbi8vUHJvdmlkZXM6IEJhc2VfYW1fdGVzdGluZyBjb25zdFxuLy9XZWFrZGVmXG5mdW5jdGlvbiBCYXNlX2FtX3Rlc3RpbmcoeCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogQmFzZV91bnNhZmVfY3JlYXRlX2xvY2FsX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlc1xuZnVuY3Rpb24gQmFzZV91bnNhZmVfY3JlYXRlX2xvY2FsX2J5dGVzKHZfbGVuKSB7XG4gIC8vIFRoaXMgZG9lcyBhIHJlZHVuZGFudCBib3VuZHMgY2hlY2sgYW5kIChzaW5jZSB0aGlzIGlzXG4gIC8vIGphdmFzY3JpcHQpIGRvZXNuJ3QgYWxsb2NhdGUgbG9jYWxseSwgYnV0IHRoYXQncyBmaW5lLlxuICByZXR1cm4gY2FtbF9jcmVhdGVfYnl0ZXModl9sZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfbG9jYWxfdmVjdFxuLy9SZXF1aXJlczogY2FtbF9tYWtlX3ZlY3RcbmZ1bmN0aW9uIGNhbWxfbWFrZV9sb2NhbF92ZWN0KHZfbGVuLCB2X2VsdCkge1xuICAvLyBJbiBqYXZhc2NyaXB0IHRoZXJlJ3Mgbm8gbG9jYWwgYWxsb2NhdGlvbi5cbiAgcmV0dXJuIGNhbWxfbWFrZV92ZWN0KHZfbGVuLCB2X2VsdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZHVtbXlfb2JqX2lzX3N0YWNrXG5mdW5jdGlvbiBjYW1sX2R1bW15X29ial9pc19zdGFjayh4KSB7XG4gIHRocm93IG5ldyBFcnJvcihgQlVHOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB1bnJlYWNoYWJsZTsgcGxlYXNlIHJlcG9ydCB0byBjb21waWxlciBvciBiYXNlIGRldnMuYCk7XG59XG4iLCIvL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9kbHNcbnZhciBjYW1sX2RvbWFpbl9kbHMgPSBbMF07XG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2Rsc19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2Rsc1xuZnVuY3Rpb24gY2FtbF9kb21haW5fZGxzX3NldChhKSB7XG4gIGNhbWxfZG9tYWluX2RscyA9IGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2Rsc19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2Rsc1xuZnVuY3Rpb24gY2FtbF9kb21haW5fZGxzX2dldCh1bml0KSB7XG4gIHJldHVybiBjYW1sX2RvbWFpbl9kbHM7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfbG9hZFxuZnVuY3Rpb24gY2FtbF9hdG9taWNfbG9hZChyZWYpe1xuICByZXR1cm4gcmVmWzFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2F0b21pY19jYXNcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX2NhcyhyZWYsbyxuKSB7XG4gIGlmKHJlZlsxXSA9PT0gbyl7XG4gICAgcmVmWzFdID0gbjtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfZmV0Y2hfYWRkXG5mdW5jdGlvbiBjYW1sX2F0b21pY19mZXRjaF9hZGQocmVmLCBpKSB7XG4gIHZhciBvbGQgPSByZWZbMV07XG4gIHJlZlsxXSArPSBpO1xuICByZXR1cm4gb2xkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2F0b21pY19leGNoYW5nZVxuZnVuY3Rpb24gY2FtbF9hdG9taWNfZXhjaGFuZ2UocmVmLCB2KSB7XG4gIHZhciByID0gcmVmWzFdO1xuICByZWZbMV0gPSB2O1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hdG9taWNfbWFrZV9jb250ZW5kZWRcbmZ1bmN0aW9uIGNhbWxfYXRvbWljX21ha2VfY29udGVuZGVkKGEpIHtcbiAgcmV0dXJuIFswLCBhXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW5cbnZhciBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW5fID0gWzBdXG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl91bmlxdWVfdG9rZW4odW5pdCkge1xuICByZXR1cm4gY2FtbF9tbF9kb21haW5fdW5pcXVlX3Rva2VuX1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZG9tYWluX3NldF9uYW1lXG5mdW5jdGlvbiBjYW1sX21sX2RvbWFpbl9zZXRfbmFtZShfbmFtZSkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWNvbW1lbmRlZF9kb21haW5fY291bnRcbmZ1bmN0aW9uIGNhbWxfcmVjb21tZW5kZWRfZG9tYWluX2NvdW50KHVuaXQpIHsgcmV0dXJuIDEgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX2lkXG52YXIgY2FtbF9kb21haW5faWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2RvbWFpbl9zcGF3blxuLy9SZXF1aXJlczogY2FtbF9tbF9tdXRleF91bmxvY2tcbi8vUmVxdWlyZXM6IGNhbWxfZG9tYWluX2lkXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxiYWNrXG4vL1ZlcnNpb246ID49IDUuMlxudmFyIGNhbWxfZG9tYWluX2xhdGVzdF9pZHggPSAxXG5mdW5jdGlvbiBjYW1sX2RvbWFpbl9zcGF3bihmLHRlcm1fc3luYyl7XG4gICAgdmFyIGlkID0gY2FtbF9kb21haW5fbGF0ZXN0X2lkeCsrO1xuICAgIHZhciBvbGQgPSBjYW1sX2RvbWFpbl9pZDtcbiAgICBjYW1sX2RvbWFpbl9pZCA9IGlkO1xuICAgIHZhciByZXMgPSBjYW1sX2NhbGxiYWNrKGYsWzBdKTtcbiAgICBjYW1sX2RvbWFpbl9pZCA9IG9sZDtcbiAgICBjYW1sX21sX211dGV4X3VubG9jayh0ZXJtX3N5bmNbMl0pO1xuICAgIC8vVE9ETzogZml4IGV4biBjYXNlXG4gICAgdGVybV9zeW5jWzFdID0gWzAsIFswLCByZXNdXTtcbiAgICByZXR1cm4gaWQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZG9tYWluX3NwYXduXG4vL1JlcXVpcmVzOiBjYW1sX21sX211dGV4X3VubG9ja1xuLy9SZXF1aXJlczogY2FtbF9kb21haW5faWRcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbGJhY2tcbi8vVmVyc2lvbjogPCA1LjJcbnZhciBjYW1sX2RvbWFpbl9sYXRlc3RfaWR4ID0gMVxuZnVuY3Rpb24gY2FtbF9kb21haW5fc3Bhd24oZixtdXRleCl7XG4gICAgdmFyIGlkID0gY2FtbF9kb21haW5fbGF0ZXN0X2lkeCsrO1xuICAgIHZhciBvbGQgPSBjYW1sX2RvbWFpbl9pZDtcbiAgICBjYW1sX2RvbWFpbl9pZCA9IGlkO1xuICAgIHZhciByZXMgPSBjYW1sX2NhbGxiYWNrKGYsWzBdKTtcbiAgICBjYW1sX2RvbWFpbl9pZCA9IG9sZDtcbiAgICBjYW1sX21sX211dGV4X3VubG9jayhtdXRleCk7XG4gICAgcmV0dXJuIGlkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZG9tYWluX2lkXG4vL1JlcXVpcmVzOiBjYW1sX2RvbWFpbl9pZFxuZnVuY3Rpb24gY2FtbF9tbF9kb21haW5faWQodW5pdCl7XG4gICAgcmV0dXJuIGNhbWxfZG9tYWluX2lkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZG9tYWluX2NwdV9yZWxheFxuZnVuY3Rpb24gY2FtbF9tbF9kb21haW5fY3B1X3JlbGF4KHVuaXQpe1xuICAgIHJldHVybiAwO1xufVxuIiwiXG4vL1Byb3ZpZGVzOiBNbE11dGV4XG5mdW5jdGlvbiBNbE11dGV4KCkge1xuICB0aGlzLmxvY2tlZCA9IGZhbHNlXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfbmV3XG4vL1JlcXVpcmVzOiBNbE11dGV4XG5mdW5jdGlvbiBjYW1sX21sX211dGV4X25ldyh1bml0KSB7XG4gIHJldHVybiBuZXcgTWxNdXRleCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX211dGV4X2xvY2tcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfbG9jayh0KSB7XG4gIGlmKHQubG9ja2VkKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJNdXRleC5sb2NrOiBtdXRleCBhbHJlYWR5IGxvY2tlZC4gQ2Fubm90IHdhaXQuXCIpO1xuICBlbHNlIHQubG9ja2VkID0gdHJ1ZTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfdHJ5X2xvY2tcbmZ1bmN0aW9uIGNhbWxfbWxfbXV0ZXhfdHJ5X2xvY2sodCkge1xuICBpZighdC5sb2NrZWQpIHtcbiAgICB0LmxvY2tlZCA9IHRydWU7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbXV0ZXhfdW5sb2NrXG5mdW5jdGlvbiBjYW1sX21sX211dGV4X3VubG9jayh0KSB7XG4gIHQubG9ja2VkID0gZmFsc2U7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIFdlYWsgQVBJXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxudmFyIGNhbWxfZXBoZV9kYXRhX29mZnNldCA9IDJcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHYpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgaWYgKHYgaW5zdGFuY2VvZiBPYmplY3QgJiYgZ2xvYmFsVGhpcy5XZWFrUmVmKSB7XG4gICAgaWYoeFsxXS5yZWdpc3RlcikgeFsxXS5yZWdpc3Rlcih2LCB1bmRlZmluZWQsIHYpO1xuICAgIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IG5ldyBnbG9iYWxUaGlzLldlYWtSZWYodik7XG4gIH1cbiAgZWxzZSB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB2O1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgaWYoZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZiAmJiB4WzFdLnVucmVnaXN0ZXIpIHtcbiAgICB2YXIgb2xkID0geFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldLmRlcmVmKCk7XG4gICAgaWYob2xkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb3VudCA9IDBcbiAgICAgIGZvcih2YXIgaiA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0OyBqIDwgeC5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBrZXkgPSB4W2pdO1xuICAgICAgICBpZihrZXkgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYWtSZWYpe1xuICAgICAgICAgIGtleSA9IGtleS5kZXJlZigpXG4gICAgICAgICAgaWYoa2V5ID09PSBvbGQpIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKGNvdW50ID09IDEpIHhbMV0udW5yZWdpc3RlcihvbGQpO1xuICAgIH1cbiAgfVxuICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB1bmRlZmluZWQ7XG4gIHJldHVybiAwXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NyZWF0ZSwgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfY3JlYXRlIChuKSB7XG4gIHZhciB4ID0gY2FtbF93ZWFrX2NyZWF0ZShuKTtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfY3JlYXRlIChuKSB7XG4gIGlmIChuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuY3JlYXRlXCIpO1xuICB2YXIgeCA9IFsyNTEsXCJjYW1sX2VwaGVfbGlzdF9oZWFkXCJdO1xuICB4Lmxlbmd0aCA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgbjtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX3NldF9rZXksIGNhbWxfZXBoZV91bnNldF9rZXlcbmZ1bmN0aW9uIGNhbWxfd2Vha19zZXQoeCwgaSwgdikge1xuICBpZih2ID09IDApIGNhbWxfZXBoZV91bnNldF9rZXkoeCxpKVxuICBlbHNlIGNhbWxfZXBoZV9zZXRfa2V5KHgsaSx2WzFdKVxuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0FsaWFzOiBjYW1sX3dlYWtfZ2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2tleSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfa2V5XCIpO1xuICB2YXIgd2VhayA9IHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpIF07XG4gIGlmKGdsb2JhbFRoaXMuV2Vha1JlZiAmJiB3ZWFrIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5XZWFrUmVmKSB3ZWFrID0gd2Vhay5kZXJlZigpO1xuICByZXR1cm4gKHdlYWs9PT11bmRlZmluZWQpPzA6WzAsIHdlYWtdO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2dldF9rZXksY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0FsaWFzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfa2V5X2NvcHkoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2NvcHlcIik7XG4gIHZhciB5ID0gY2FtbF9lcGhlX2dldF9rZXkoeCwgaSk7XG4gIGlmICh5ID09PSAwKSByZXR1cm4geTtcbiAgdmFyIHogPSB5WzFdO1xuICBpZiAoeiBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh6KV07XG4gIHJldHVybiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfa2V5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL0FsaWFzOiBjYW1sX3dlYWtfY2hlY2tcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19rZXkoeCwgaSkge1xuICB2YXIgd2VhayA9IHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXTtcbiAgaWYoZ2xvYmFsVGhpcy5XZWFrUmVmICYmIHdlYWsgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLldlYWtSZWYpIHdlYWsgPSB3ZWFrLmRlcmVmKCk7XG4gIGlmKHdlYWs9PT11bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL0FsaWFzOiBjYW1sX3dlYWtfYmxpdFxuZnVuY3Rpb24gY2FtbF9lcGhlX2JsaXRfa2V5KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgLy8gbWludXMgb25lIGJlY2F1c2UgY2FtbF9hcnJheV9ibGl0IHdvcmtzIG9uIG9jYW1sIGFycmF5XG4gIGNhbWxfYXJyYXlfYmxpdChhMSwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMSAtIDEsXG4gICAgICAgICAgICAgICAgICBhMiwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMiAtIDEsXG4gICAgICAgICAgICAgICAgICBsZW4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0LCBjYW1sX2VwaGVfc2V0X2RhdGEsIGNhbWxfZXBoZV91bnNldF9kYXRhXG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9kYXRhKHNyYywgZHN0KXtcbiAgdmFyIG4gPSBzcmNbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XTtcbiAgaWYobiA9PT0gdW5kZWZpbmVkKSBjYW1sX2VwaGVfdW5zZXRfZGF0YShkc3QpO1xuICBlbHNlIGNhbWxfZXBoZV9zZXRfZGF0YShkc3QsIG4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cFxuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0LCBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfZGF0YSh4LCBkYXRhKXtcbiAgaWYoZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeSAmJiBnbG9iYWxUaGlzLldlYWtSZWYpIHtcbiAgICBpZighICh4WzFdIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeSkpIHtcbiAgICAgIHhbMV0gPSBuZXcgZ2xvYmFsVGhpcy5GaW5hbGl6YXRpb25SZWdpc3RyeShmdW5jdGlvbiAoKSB7IGNhbWxfZXBoZV91bnNldF9kYXRhKHgpIH0pO1xuICAgICAgLy9yZWdpc3RlciBhbGwga2V5c1xuICAgICAgZm9yKHZhciBqID0gY2FtbF9lcGhlX2tleV9vZmZzZXQ7IGogPCB4Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGtleSA9IHhbal07XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgICAgICAgIGtleSA9IGtleS5kZXJlZigpO1xuICAgICAgICAgIGlmKGtleSkgeFsxXS5yZWdpc3RlcihrZXksIHVuZGVmaW5lZCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBkYXRhO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldCwgY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9kYXRhKHgpe1xuICBpZihnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgIGlmKHhbMV0gaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5KXtcbiAgICAgIC8vdW5yZWdpc3RlciBhbGwga2V5c1xuICAgICAgZm9yKHZhciBqID0gY2FtbF9lcGhlX2tleV9vZmZzZXQ7IGogPCB4Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGtleSA9IHhbal07XG4gICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuV2Vha1JlZikge1xuICAgICAgICAgIGtleSA9IGtleS5kZXJlZigpO1xuICAgICAgICAgIGlmKGtleSkgeFsxXS51bnJlZ2lzdGVyKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gdW5kZWZpbmVkO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIDE7XG59XG4iLCIvLy8vLy8vLy8gVElNRV9OT1dcblxuLy9Qcm92aWRlczogdGltZV9ub3dfbmFub3NlY29uZHNfc2luY2VfdW5peF9lcG9jaF9vcl96ZXJvXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9pbnQ2NF9vZl9pbnQzMlxudmFyIG1zX3RvX25hbm8gPSBjYW1sX2ludDY0X29mX2ludDMyKDEwMDAqMTAwMCk7XG5mdW5jdGlvbiB0aW1lX25vd19uYW5vc2Vjb25kc19zaW5jZV91bml4X2Vwb2NoX29yX3plcm8oKXtcbiAgICB2YXIgbXMgPSBEYXRlLm5vdygpO1xuICAgIC8vIG11bHRpcGxlIGJ5IHR3byAtIGludDYzIGludGVnZXJzIGFyZSBzaGlmdGVkIHRvIHRoZSBsZWZ0XG4gICAgdmFyIG1zX2k2MyA9IGNhbWxfaW50NjRfb2ZfZmxvYXQobXMqMik7XG4gICAgLy8gZG9pbmcgdGhlIG11bHRpcGxpY2F0aW9uIGluIGludDY0IHNwYWNlIHdvdWxkIGRyb3AgYWxsIHRoZSB2YWx1ZXNcbiAgICAvLyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgYnV0IGJlY2F1c2UgW0RhdGUubm93KCldIG9ubHkgcHJvdmlkZXNcbiAgICAvLyAxbXMgcmVzb2x1dGlvbiBhbnl3YXksIHRoZXJlJ3MgbmV2ZXIgYW55IHZhbHVlIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LlxuICAgIHJldHVybiBjYW1sX2ludDY0X211bChtc19pNjMsbXNfdG9fbmFubyk7XG59XG5cbi8vUHJvdmlkZXM6IG1zX2Zsb2F0X3RvX25zX2ludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0XG5mdW5jdGlvbiBtc19mbG9hdF90b19uc19pbnQ2NChtcykge1xuICAvLyBtdWx0aXBseSBieSAxXzAwMF8wMDAgd2hpbGUgc3RpbGwgYSBmbG9hdCBzbyB0aGF0IHN1Yi1taWxsaXNlY29uZFxuICAvLyB2YWx1ZXMgZG9uJ3QgZ2V0IHRydW5jYXRlZCBieSB0aGUgZmxvYXQtPmludCBjb252ZXJzaW9uLlxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChtcyAqICgxMDAwLjAgKiAxMDAwLjApKTtcbn1cblxuLyogVGhlIHJlYXNvbiB3ZSBjYW4ndCBzaGFyZSBhbGwgdGhlIGNvZGUgYmV0d2VlbiBbKl9jb3VudGVyX2Zvcl90aW1pbmddIGFuZFxuICogWypfdW5peF9lcG9jaF0gaXMgYmVjYXVzZSBbcGVyZm9ybWFuY2Uubm93KCldIGJyZWFrcyB3aGVuIHRoZSBjb21wdXRlciBnb2VzXG4gKiB0byBzbGVlcCwgYW5kIHdoZW4gYSB0YWIgaXMgYmFja2dyb3VuZGVkLlxuICogaHR0cHM6Ly9naXRodWIuY29tL3czYy9oci10aW1lL2lzc3Vlcy8xMTUgKi9cblxuLy9Qcm92aWRlczogdGltZV9ub3dfbmFub3NlY29uZF9jb3VudGVyX2Zvcl90aW1pbmdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYWRkLCBtc19mbG9hdF90b19uc19pbnQ2NCwgY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0XG5mdW5jdGlvbiB0aW1lX25vd19uYW5vc2Vjb25kX2NvdW50ZXJfZm9yX3RpbWluZygpe1xuICAgIHZhciBtc19zaW5jZV9wcm9ncmFtX3N0YXJ0ZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB2YXIgbnNfc2luY2VfcHJvZ3JhbV9zdGFydGVkID0gbXNfZmxvYXRfdG9fbnNfaW50NjQobXNfc2luY2VfcHJvZ3JhbV9zdGFydGVkKTtcbiAgICAvLyBzaGlmdCBsZWZ0IGJ5IDEgYmVjYXVzZSBpbiBqYXZhc2NyaXB0LCBhbiBpbnQ2MyBpcyBpbXBsZW1lbnRlZCBhcyBhblxuICAgIC8vIGludDY0IHdpdGggdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBzZXQgdG8gemVyb1xuICAgIHJldHVybiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQobnNfc2luY2VfcHJvZ3JhbV9zdGFydGVkLCAxKTtcbn1cbiIsIlxuLy9Qcm92aWRlczogY2FtbF9seG1fbmV4dFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3hvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbXVsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NldF8xXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2x4bV9uZXh0KHYpIHtcbiAgZnVuY3Rpb24gc2hpZnRfbCh4LCBrKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0KHgsayk7XG4gIH1cbiAgZnVuY3Rpb24gc2hpZnRfcih4LCBrKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCh4LGspO1xuICB9XG4gIGZ1bmN0aW9uIG9yKGEsIGIpe1xuICAgIHJldHVybiBjYW1sX2ludDY0X29yKGEsYik7XG4gIH1cbiAgZnVuY3Rpb24geG9yKGEsIGIpe1xuICAgIHJldHVybiBjYW1sX2ludDY0X3hvcihhLGIpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZChhLCBiKXtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9hZGQoYSxiKTtcbiAgfVxuICBmdW5jdGlvbiBtdWwoYSwgYil7XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfbXVsKGEsYik7XG4gIH1cbiAgZnVuY3Rpb24gcm90bCh4LCBrKSB7XG4gICAgcmV0dXJuIG9yKHNoaWZ0X2woeCxrKSxzaGlmdF9yICh4LCA2NCAtIGspKTtcbiAgfVxuICBmdW5jdGlvbiBnZXQoYSwgaSkge1xuICAgIHJldHVybiBjYW1sX2JhX2dldF8xKGEsIGkpO1xuICB9XG4gIGZ1bmN0aW9uIHNldChhLCBpLCB4KSB7XG4gICAgcmV0dXJuIGNhbWxfYmFfc2V0XzEoYSwgaSwgeCk7XG4gIH1cbiAgdmFyIE0gPSBjYW1sX2ludDY0X29mX3N0cmluZyhjYW1sX25ld19zdHJpbmcoXCIweGQxMzQyNTQzZGU4MmVmOTVcIikpO1xuICB2YXIgZGFiYSA9IGNhbWxfaW50NjRfb2Zfc3RyaW5nKGNhbWxfbmV3X3N0cmluZyhcIjB4ZGFiYTBiNmViMDkzMjJlM1wiKSk7XG4gIHZhciB6LCBxMCwgcTE7XG4gIHZhciBzdCA9IHY7XG4gIHZhciBhID0gZ2V0KHN0LDApO1xuICB2YXIgcyA9IGdldChzdCwxKTtcbiAgdmFyIHgwID0gZ2V0KHN0LDIpO1xuICB2YXIgeDEgPSBnZXQoc3QsMyk7XG4gIC8qIENvbWJpbmluZyBvcGVyYXRpb24gKi9cbiAgeiA9IGFkZChzLCB4MCk7XG4gIC8qIE1peGluZyBmdW5jdGlvbiAqL1xuICB6ID0gbXVsKHhvcih6LHNoaWZ0X3IoeiwzMikpLCBkYWJhKTtcbiAgeiA9IG11bCh4b3IoeixzaGlmdF9yKHosMzIpKSwgZGFiYSk7XG4gIHogPSB4b3IoeixzaGlmdF9yKHosMzIpKTtcbiAgLyogTENHIHVwZGF0ZSAqL1xuICBzZXQoc3QsIDEsIGFkZCAobXVsKHMsTSksIGEpKTtcbiAgLyogWEJHIHVwZGF0ZSAqL1xuICB2YXIgcTAgPSB4MFxuICB2YXIgcTEgPSB4MVxuICBxMSA9IHhvcihxMSxxMCk7XG4gIHEwID0gcm90bChxMCwgMjQpO1xuICBxMCA9IHhvcih4b3IocTAsIHExKSwgKHNoaWZ0X2wocTEsMTYpKSk7XG4gIHExID0gcm90bChxMSwgMzcpO1xuICBzZXQoc3QsIDIsIHEwKTtcbiAgc2V0KHN0LCAzLCBxMSk7XG4gIC8qIFJldHVybiByZXN1bHQgKi9cbiAgcmV0dXJuIHo7XG59XG4iLCJcbi8vUHJvdmlkZXM6IHpzdGRfZGVjb21wcmVzc1xuLy9WZXJzaW9uOiA+PSA1LjFcbnZhciB6c3RkX2RlY29tcHJlc3MgPSAoZnVuY3Rpb24gKCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxudmFyIGFiID0gQXJyYXlCdWZmZXIsIHU4ID0gVWludDhBcnJheSwgdTE2ID0gVWludDE2QXJyYXksIGkxNiA9IEludDE2QXJyYXksIHUzMiA9IFVpbnQzMkFycmF5LCBpMzIgPSBJbnQzMkFycmF5O1xudmFyIHNsYyA9IGZ1bmN0aW9uICh2LCBzLCBlKSB7XG4gICAgaWYgKHU4LnByb3RvdHlwZS5zbGljZSlcbiAgICAgICAgcmV0dXJuIHU4LnByb3RvdHlwZS5zbGljZS5jYWxsKHYsIHMsIGUpO1xuICAgIGlmIChzID09IG51bGwgfHwgcyA8IDApXG4gICAgICAgIHMgPSAwO1xuICAgIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKVxuICAgICAgICBlID0gdi5sZW5ndGg7XG4gICAgdmFyIG4gPSBuZXcgdTgoZSAtIHMpO1xuICAgIG4uc2V0KHYuc3ViYXJyYXkocywgZSkpO1xuICAgIHJldHVybiBuO1xufTtcbnZhciBmaWxsID0gZnVuY3Rpb24gKHYsIG4sIHMsIGUpIHtcbiAgICBpZiAodTgucHJvdG90eXBlLmZpbGwpXG4gICAgICAgIHJldHVybiB1OC5wcm90b3R5cGUuZmlsbC5jYWxsKHYsIG4sIHMsIGUpO1xuICAgIGlmIChzID09IG51bGwgfHwgcyA8IDApXG4gICAgICAgIHMgPSAwO1xuICAgIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKVxuICAgICAgICBlID0gdi5sZW5ndGg7XG4gICAgZm9yICg7IHMgPCBlOyArK3MpXG4gICAgICAgIHZbc10gPSBuO1xuICAgIHJldHVybiB2O1xufTtcbnZhciBjcHcgPSBmdW5jdGlvbiAodiwgdCwgcywgZSkge1xuICAgIGlmICh1OC5wcm90b3R5cGUuY29weVdpdGhpbilcbiAgICAgICAgcmV0dXJuIHU4LnByb3RvdHlwZS5jb3B5V2l0aGluLmNhbGwodiwgdCwgcywgZSk7XG4gICAgaWYgKHMgPT0gbnVsbCB8fCBzIDwgMClcbiAgICAgICAgcyA9IDA7XG4gICAgaWYgKGUgPT0gbnVsbCB8fCBlID4gdi5sZW5ndGgpXG4gICAgICAgIGUgPSB2Lmxlbmd0aDtcbiAgICB3aGlsZSAocyA8IGUpIHtcbiAgICAgICAgdlt0KytdID0gdltzKytdO1xuICAgIH1cbn07XG4vKipcbiAqIENvZGVzIGZvciBlcnJvcnMgZ2VuZXJhdGVkIHdpdGhpbiB0aGlzIGxpYnJhcnlcbiAqL1xuLy8gZXJyb3IgY29kZXNcbnZhciBlYyA9IFtcbiAgICAnaW52YWxpZCB6c3RkIGRhdGEnLFxuICAgICd3aW5kb3cgc2l6ZSB0b28gbGFyZ2UgKD4yMDQ2TUIpJyxcbiAgICAnaW52YWxpZCBibG9jayB0eXBlJyxcbiAgICAnRlNFIGFjY3VyYWN5IHRvbyBoaWdoJyxcbiAgICAnbWF0Y2ggZGlzdGFuY2UgdG9vIGZhciBiYWNrJyxcbiAgICAndW5leHBlY3RlZCBFT0YnXG5dO1xuO1xudmFyIGVyciA9IGZ1bmN0aW9uIChpbmQsIG1zZywgbnQpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtc2cgfHwgZWNbaW5kXSk7XG4gICAgZS5jb2RlID0gaW5kO1xuICAgIGlmICghbnQpXG4gICAgICAgIHRocm93IGU7XG4gICAgcmV0dXJuIGU7XG59O1xudmFyIHJiID0gZnVuY3Rpb24gKGQsIGIsIG4pIHtcbiAgICB2YXIgaSA9IDAsIG8gPSAwO1xuICAgIGZvciAoOyBpIDwgbjsgKytpKVxuICAgICAgICBvIHw9IGRbYisrXSA8PCAoaSA8PCAzKTtcbiAgICByZXR1cm4gbztcbn07XG52YXIgYjQgPSBmdW5jdGlvbiAoZCwgYikgeyByZXR1cm4gKGRbYl0gfCAoZFtiICsgMV0gPDwgOCkgfCAoZFtiICsgMl0gPDwgMTYpIHwgKGRbYiArIDNdIDw8IDI0KSkgPj4+IDA7IH07XG4vLyByZWFkIFpzdGFuZGFyZCBmcmFtZSBoZWFkZXJcbnZhciByemZoID0gZnVuY3Rpb24gKGRhdCwgdykge1xuICAgIHZhciBuMyA9IGRhdFswXSB8IChkYXRbMV0gPDwgOCkgfCAoZGF0WzJdIDw8IDE2KTtcbiAgICBpZiAobjMgPT0gMHgyRkI1MjggJiYgZGF0WzNdID09IDI1Mykge1xuICAgICAgICAvLyBac3RhbmRhcmRcbiAgICAgICAgdmFyIGZsZyA9IGRhdFs0XTtcbiAgICAgICAgLy8gICAgc2luZ2xlIHNlZ21lbnQgICAgICAgY2hlY2tzdW0gICAgICAgICAgICAgZGljdCBmbGFnICAgICBmcmFtZSBjb250ZW50IGZsYWdcbiAgICAgICAgdmFyIHNzID0gKGZsZyA+PiA1KSAmIDEsIGNjID0gKGZsZyA+PiAyKSAmIDEsIGRmID0gZmxnICYgMywgZmNmID0gZmxnID4+IDY7XG4gICAgICAgIGlmIChmbGcgJiA4KVxuICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAvLyBieXRlXG4gICAgICAgIHZhciBidCA9IDYgLSBzcztcbiAgICAgICAgLy8gZGljdCBieXRlc1xuICAgICAgICB2YXIgZGIgPSBkZiA9PSAzID8gNCA6IGRmO1xuICAgICAgICAvLyBkaWN0aW9uYXJ5IGlkXG4gICAgICAgIHZhciBkaSA9IHJiKGRhdCwgYnQsIGRiKTtcbiAgICAgICAgYnQgKz0gZGI7XG4gICAgICAgIC8vIGZyYW1lIHNpemUgYnl0ZXNcbiAgICAgICAgdmFyIGZzYiA9IGZjZiA/ICgxIDw8IGZjZikgOiBzcztcbiAgICAgICAgLy8gZnJhbWUgc291cmNlIHNpemVcbiAgICAgICAgdmFyIGZzcyA9IHJiKGRhdCwgYnQsIGZzYikgKyAoKGZjZiA9PSAxKSAmJiAyNTYpO1xuICAgICAgICAvLyB3aW5kb3cgc2l6ZVxuICAgICAgICB2YXIgd3MgPSBmc3M7XG4gICAgICAgIGlmICghc3MpIHtcbiAgICAgICAgICAgIC8vIHdpbmRvdyBkZXNjcmlwdG9yXG4gICAgICAgICAgICB2YXIgd2IgPSAxIDw8ICgxMCArIChkYXRbNV0gPj4gMykpO1xuICAgICAgICAgICAgd3MgPSB3YiArICh3YiA+PiAzKSAqIChkYXRbNV0gJiA3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3MgPiAyMTQ1Mzg2NDk2KVxuICAgICAgICAgICAgZXJyKDEpO1xuICAgICAgICB2YXIgYnVmID0gbmV3IHU4KCh3ID09IDEgPyAoZnNzIHx8IHdzKSA6IHcgPyAwIDogd3MpICsgMTIpO1xuICAgICAgICBidWZbMF0gPSAxLCBidWZbNF0gPSA0LCBidWZbOF0gPSA4O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYjogYnQgKyBmc2IsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgbDogMCxcbiAgICAgICAgICAgIGQ6IGRpLFxuICAgICAgICAgICAgdzogKHcgJiYgdyAhPSAxKSA/IHcgOiBidWYuc3ViYXJyYXkoMTIpLFxuICAgICAgICAgICAgZTogd3MsXG4gICAgICAgICAgICBvOiBuZXcgaTMyKGJ1Zi5idWZmZXIsIDAsIDMpLFxuICAgICAgICAgICAgdTogZnNzLFxuICAgICAgICAgICAgYzogY2MsXG4gICAgICAgICAgICBtOiBNYXRoLm1pbigxMzEwNzIsIHdzKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgoKG4zID4+IDQpIHwgKGRhdFszXSA8PCAyMCkpID09IDB4MTg0RDJBNSkge1xuICAgICAgICAvLyBza2lwcGFibGVcbiAgICAgICAgcmV0dXJuIGI0KGRhdCwgNCkgKyA4O1xuICAgIH1cbiAgICBlcnIoMCk7XG59O1xuLy8gbW9zdCBzaWduaWZpY2FudCBiaXQgZm9yIG5vbnplcm9cbnZhciBtc2IgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIGJpdHMgPSAwO1xuICAgIGZvciAoOyAoMSA8PCBiaXRzKSA8PSB2YWw7ICsrYml0cylcbiAgICAgICAgO1xuICAgIHJldHVybiBiaXRzIC0gMTtcbn07XG4vLyByZWFkIGZpbml0ZSBzdGF0ZSBlbnRyb3B5XG52YXIgcmZzZSA9IGZ1bmN0aW9uIChkYXQsIGJ0LCBtYWwpIHtcbiAgICAvLyB0YWJsZSBwb3NcbiAgICB2YXIgdHBvcyA9IChidCA8PCAzKSArIDQ7XG4gICAgLy8gYWNjdXJhY3kgbG9nXG4gICAgdmFyIGFsID0gKGRhdFtidF0gJiAxNSkgKyA1O1xuICAgIGlmIChhbCA+IG1hbClcbiAgICAgICAgZXJyKDMpO1xuICAgIC8vIHNpemVcbiAgICB2YXIgc3ogPSAxIDw8IGFsO1xuICAgIC8vIHByb2JhYmlsaXRpZXMgc3ltYm9scyAgcmVwZWF0ICAgaW5kZXggICBoaWdoIHRocmVzaG9sZFxuICAgIHZhciBwcm9icyA9IHN6LCBzeW0gPSAtMSwgcmUgPSAtMSwgaSA9IC0xLCBodCA9IHN6O1xuICAgIC8vIG9wdGltaXphdGlvbjogc2luZ2xlIGFsbG9jYXRpb24gaXMgbXVjaCBmYXN0ZXJcbiAgICB2YXIgYnVmID0gbmV3IGFiKDUxMiArIChzeiA8PCAyKSk7XG4gICAgdmFyIGZyZXEgPSBuZXcgaTE2KGJ1ZiwgMCwgMjU2KTtcbiAgICAvLyBzYW1lIHZpZXcgYXMgZnJlcVxuICAgIHZhciBkc3RhdGUgPSBuZXcgdTE2KGJ1ZiwgMCwgMjU2KTtcbiAgICB2YXIgbnN0YXRlID0gbmV3IHUxNihidWYsIDUxMiwgc3opO1xuICAgIHZhciBiYjEgPSA1MTIgKyAoc3ogPDwgMSk7XG4gICAgdmFyIHN5bXMgPSBuZXcgdTgoYnVmLCBiYjEsIHN6KTtcbiAgICB2YXIgbmJpdHMgPSBuZXcgdTgoYnVmLCBiYjEgKyBzeik7XG4gICAgd2hpbGUgKHN5bSA8IDI1NSAmJiBwcm9icyA+IDApIHtcbiAgICAgICAgdmFyIGJpdHMgPSBtc2IocHJvYnMgKyAxKTtcbiAgICAgICAgdmFyIGNidCA9IHRwb3MgPj4gMztcbiAgICAgICAgLy8gbWFza1xuICAgICAgICB2YXIgbXNrID0gKDEgPDwgKGJpdHMgKyAxKSkgLSAxO1xuICAgICAgICB2YXIgdmFsID0gKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkgfCAoZGF0W2NidCArIDJdIDw8IDE2KSkgPj4gKHRwb3MgJiA3KSkgJiBtc2s7XG4gICAgICAgIC8vIG1hc2sgKDEgZmV3ZXIgYml0KVxuICAgICAgICB2YXIgbXNrMWZiID0gKDEgPDwgYml0cykgLSAxO1xuICAgICAgICAvLyBtYXggc21hbGwgdmFsdWVcbiAgICAgICAgdmFyIG1zdiA9IG1zayAtIHByb2JzIC0gMTtcbiAgICAgICAgLy8gc21hbGwgdmFsdWVcbiAgICAgICAgdmFyIHN2YWwgPSB2YWwgJiBtc2sxZmI7XG4gICAgICAgIGlmIChzdmFsIDwgbXN2KVxuICAgICAgICAgICAgdHBvcyArPSBiaXRzLCB2YWwgPSBzdmFsO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRwb3MgKz0gYml0cyArIDE7XG4gICAgICAgICAgICBpZiAodmFsID4gbXNrMWZiKVxuICAgICAgICAgICAgICAgIHZhbCAtPSBtc3Y7XG4gICAgICAgIH1cbiAgICAgICAgZnJlcVsrK3N5bV0gPSAtLXZhbDtcbiAgICAgICAgaWYgKHZhbCA9PSAtMSkge1xuICAgICAgICAgICAgcHJvYnMgKz0gdmFsO1xuICAgICAgICAgICAgc3ltc1stLWh0XSA9IHN5bTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwcm9icyAtPSB2YWw7XG4gICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gcmVwZWF0IGJ5dGVcbiAgICAgICAgICAgICAgICB2YXIgcmJ0ID0gdHBvcyA+PiAzO1xuICAgICAgICAgICAgICAgIHJlID0gKChkYXRbcmJ0XSB8IChkYXRbcmJ0ICsgMV0gPDwgOCkpID4+ICh0cG9zICYgNykpICYgMztcbiAgICAgICAgICAgICAgICB0cG9zICs9IDI7XG4gICAgICAgICAgICAgICAgc3ltICs9IHJlO1xuICAgICAgICAgICAgfSB3aGlsZSAocmUgPT0gMyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN5bSA+IDI1NSB8fCBwcm9icylcbiAgICAgICAgZXJyKDApO1xuICAgIHZhciBzeW1wb3MgPSAwO1xuICAgIC8vIHN5bSBzdGVwIChjb3ByaW1lIHdpdGggc3ogLSBmb3JtdWxhIGZyb20genN0ZCBzb3VyY2UpXG4gICAgdmFyIHNzdGVwID0gKHN6ID4+IDEpICsgKHN6ID4+IDMpICsgMztcbiAgICAvLyBzeW0gbWFza1xuICAgIHZhciBzbWFzayA9IHN6IC0gMTtcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8PSBzeW07ICsrcykge1xuICAgICAgICB2YXIgc2YgPSBmcmVxW3NdO1xuICAgICAgICBpZiAoc2YgPCAxKSB7XG4gICAgICAgICAgICBkc3RhdGVbc10gPSAtc2Y7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIHNwbGl0IGludG8gdHdvIGxvb3BzIGluIHpzdGQgdG8gYXZvaWQgYnJhbmNoaW5nLCBidXQgYXMgSlMgaXMgaGlnaGVyLWxldmVsIHRoYXQgaXMgdW5uZWNlc3NhcnlcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNmOyArK2kpIHtcbiAgICAgICAgICAgIHN5bXNbc3ltcG9zXSA9IHM7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgc3ltcG9zID0gKHN5bXBvcyArIHNzdGVwKSAmIHNtYXNrO1xuICAgICAgICAgICAgfSB3aGlsZSAoc3ltcG9zID49IGh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZnRlciBzcHJlYWRpbmcgc3ltYm9scywgc2hvdWxkIGJlIHplcm8gYWdhaW5cbiAgICBpZiAoc3ltcG9zKVxuICAgICAgICBlcnIoMCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN6OyArK2kpIHtcbiAgICAgICAgLy8gbmV4dCBzdGF0ZVxuICAgICAgICB2YXIgbnMgPSBkc3RhdGVbc3ltc1tpXV0rKztcbiAgICAgICAgLy8gbnVtIGJpdHNcbiAgICAgICAgdmFyIG5iID0gbmJpdHNbaV0gPSBhbCAtIG1zYihucyk7XG4gICAgICAgIG5zdGF0ZVtpXSA9IChucyA8PCBuYikgLSBzejtcbiAgICB9XG4gICAgcmV0dXJuIFsodHBvcyArIDcpID4+IDMsIHtcbiAgICAgICAgICAgIGI6IGFsLFxuICAgICAgICAgICAgczogc3ltcyxcbiAgICAgICAgICAgIG46IG5iaXRzLFxuICAgICAgICAgICAgdDogbnN0YXRlXG4gICAgICAgIH1dO1xufTtcbi8vIHJlYWQgaHVmZm1hblxudmFyIHJodSA9IGZ1bmN0aW9uIChkYXQsIGJ0KSB7XG4gICAgLy8gIGluZGV4ICB3ZWlnaHQgY291bnRcbiAgICB2YXIgaSA9IDAsIHdjID0gLTE7XG4gICAgLy8gICAgYnVmZmVyICAgICAgICAgICAgIGhlYWRlciBieXRlXG4gICAgdmFyIGJ1ZiA9IG5ldyB1OCgyOTIpLCBoYiA9IGRhdFtidF07XG4gICAgLy8gaHVmZm1hbiB3ZWlnaHRzXG4gICAgdmFyIGh3ID0gYnVmLnN1YmFycmF5KDAsIDI1Nik7XG4gICAgLy8gcmFuayBjb3VudFxuICAgIHZhciByYyA9IGJ1Zi5zdWJhcnJheSgyNTYsIDI2OCk7XG4gICAgLy8gcmFuayBpbmRleFxuICAgIHZhciByaSA9IG5ldyB1MTYoYnVmLmJ1ZmZlciwgMjY4KTtcbiAgICAvLyBOT1RFOiBhdCB0aGlzIHBvaW50IGJ0IGlzIDEgbGVzcyB0aGFuIGV4cGVjdGVkXG4gICAgaWYgKGhiIDwgMTI4KSB7XG4gICAgICAgIC8vIGVuZCBieXRlLCBmc2UgZGVjb2RlIHRhYmxlXG4gICAgICAgIHZhciBfYSA9IHJmc2UoZGF0LCBidCArIDEsIDYpLCBlYnQgPSBfYVswXSwgZmR0ID0gX2FbMV07XG4gICAgICAgIGJ0ICs9IGhiO1xuICAgICAgICB2YXIgZXBvcyA9IGVidCA8PCAzO1xuICAgICAgICAvLyBsYXN0IGJ5dGVcbiAgICAgICAgdmFyIGxiID0gZGF0W2J0XTtcbiAgICAgICAgaWYgKCFsYilcbiAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgLy8gIHN0YXRlMSAgIHN0YXRlMiAgIHN0YXRlMSBiaXRzICAgc3RhdGUyIGJpdHNcbiAgICAgICAgdmFyIHN0MSA9IDAsIHN0MiA9IDAsIGJ0cjEgPSBmZHQuYiwgYnRyMiA9IGJ0cjE7XG4gICAgICAgIC8vIGZzZSBwb3NcbiAgICAgICAgLy8gcHJlLWluY3JlbWVudCB0byBhY2NvdW50IGZvciBvcmlnaW5hbCBkZWZpY2l0IG9mIDFcbiAgICAgICAgdmFyIGZwb3MgPSAoKytidCA8PCAzKSAtIDggKyBtc2IobGIpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBmcG9zIC09IGJ0cjE7XG4gICAgICAgICAgICBpZiAoZnBvcyA8IGVwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgY2J0ID0gZnBvcyA+PiAzO1xuICAgICAgICAgICAgc3QxICs9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoZnBvcyAmIDcpKSAmICgoMSA8PCBidHIxKSAtIDEpO1xuICAgICAgICAgICAgaHdbKyt3Y10gPSBmZHQuc1tzdDFdO1xuICAgICAgICAgICAgZnBvcyAtPSBidHIyO1xuICAgICAgICAgICAgaWYgKGZwb3MgPCBlcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2J0ID0gZnBvcyA+PiAzO1xuICAgICAgICAgICAgc3QyICs9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoZnBvcyAmIDcpKSAmICgoMSA8PCBidHIyKSAtIDEpO1xuICAgICAgICAgICAgaHdbKyt3Y10gPSBmZHQuc1tzdDJdO1xuICAgICAgICAgICAgYnRyMSA9IGZkdC5uW3N0MV07XG4gICAgICAgICAgICBzdDEgPSBmZHQudFtzdDFdO1xuICAgICAgICAgICAgYnRyMiA9IGZkdC5uW3N0Ml07XG4gICAgICAgICAgICBzdDIgPSBmZHQudFtzdDJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICgrK3djID4gMjU1KVxuICAgICAgICAgICAgZXJyKDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2MgPSBoYiAtIDEyNztcbiAgICAgICAgZm9yICg7IGkgPCB3YzsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZSA9IGRhdFsrK2J0XTtcbiAgICAgICAgICAgIGh3W2ldID0gYnl0ZSA+PiA0O1xuICAgICAgICAgICAgaHdbaSArIDFdID0gYnl0ZSAmIDE1O1xuICAgICAgICB9XG4gICAgICAgICsrYnQ7XG4gICAgfVxuICAgIC8vIHdlaWdodCBleHBvbmVudGlhbCBzdW1cbiAgICB2YXIgd2VzID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgICAgICB2YXIgd3QgPSBod1tpXTtcbiAgICAgICAgLy8gYml0cyBtdXN0IGJlIGF0IG1vc3QgMTEsIHNhbWUgYXMgd2VpZ2h0XG4gICAgICAgIGlmICh3dCA+IDExKVxuICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICB3ZXMgKz0gd3QgJiYgKDEgPDwgKHd0IC0gMSkpO1xuICAgIH1cbiAgICAvLyBtYXggYml0c1xuICAgIHZhciBtYiA9IG1zYih3ZXMpICsgMTtcbiAgICAvLyB0YWJsZSBzaXplXG4gICAgdmFyIHRzID0gMSA8PCBtYjtcbiAgICAvLyByZW1haW5pbmcgc3VtXG4gICAgdmFyIHJlbSA9IHRzIC0gd2VzO1xuICAgIC8vIG11c3QgYmUgcG93ZXIgb2YgMlxuICAgIGlmIChyZW0gJiAocmVtIC0gMSkpXG4gICAgICAgIGVycigwKTtcbiAgICBod1t3YysrXSA9IG1zYihyZW0pICsgMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgICAgICB2YXIgd3QgPSBod1tpXTtcbiAgICAgICAgKytyY1tod1tpXSA9IHd0ICYmIChtYiArIDEgLSB3dCldO1xuICAgIH1cbiAgICAvLyBodWYgYnVmXG4gICAgdmFyIGhidWYgPSBuZXcgdTgodHMgPDwgMSk7XG4gICAgLy8gICAgc3ltYm9scyAgICAgICAgICAgICAgICAgICAgICBudW0gYml0c1xuICAgIHZhciBzeW1zID0gaGJ1Zi5zdWJhcnJheSgwLCB0cyksIG5iID0gaGJ1Zi5zdWJhcnJheSh0cyk7XG4gICAgcmlbbWJdID0gMDtcbiAgICBmb3IgKGkgPSBtYjsgaSA+IDA7IC0taSkge1xuICAgICAgICB2YXIgcHYgPSByaVtpXTtcbiAgICAgICAgZmlsbChuYiwgaSwgcHYsIHJpW2kgLSAxXSA9IHB2ICsgcmNbaV0gKiAoMSA8PCAobWIgLSBpKSkpO1xuICAgIH1cbiAgICBpZiAocmlbMF0gIT0gdHMpXG4gICAgICAgIGVycigwKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgICAgICB2YXIgYml0cyA9IGh3W2ldO1xuICAgICAgICBpZiAoYml0cykge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByaVtiaXRzXTtcbiAgICAgICAgICAgIGZpbGwoc3ltcywgaSwgY29kZSwgcmlbYml0c10gPSBjb2RlICsgKDEgPDwgKG1iIC0gYml0cykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2J0LCB7XG4gICAgICAgICAgICBuOiBuYixcbiAgICAgICAgICAgIGI6IG1iLFxuICAgICAgICAgICAgczogc3ltc1xuICAgICAgICB9XTtcbn07XG4vLyBUYWJsZXMgZ2VuZXJhdGVkIHVzaW5nIHRoaXM6XG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDFhcnJvd3ovYTk3OTQ1MmQ0MzU1OTkyY2JmOGYyNTdjYmZmYzllZGRcbi8vIGRlZmF1bHQgbGl0ZXJhbCBsZW5ndGggdGFibGVcbnZhciBkbGx0ID0gLyojX19QVVJFX18qLyByZnNlKC8qI19fUFVSRV9fKi8gbmV3IHU4KFtcbiAgICA4MSwgMTYsIDk5LCAxNDAsIDQ5LCAxOTgsIDI0LCA5OSwgMTIsIDMzLCAxOTYsIDI0LCA5OSwgMTAyLCAxMDIsIDEzNCwgNzAsIDE0NiwgNFxuXSksIDAsIDYpWzFdO1xuLy8gZGVmYXVsdCBtYXRjaCBsZW5ndGggdGFibGVcbnZhciBkbWx0ID0gLyojX19QVVJFX18qLyByZnNlKC8qI19fUFVSRV9fKi8gbmV3IHU4KFtcbiAgICAzMywgMjAsIDE5NiwgMjQsIDk5LCAxNDAsIDMzLCAxMzIsIDE2LCA2NiwgOCwgMzMsIDEzMiwgMTYsIDY2LCA4LCAzMywgNjgsIDY4LCA2OCwgNjgsIDY4LCA2OCwgNjgsIDY4LCAzNiwgOVxuXSksIDAsIDYpWzFdO1xuLy8gZGVmYXVsdCBvZmZzZXQgY29kZSB0YWJsZVxudmFyIGRvY3QgPSAvKiNfX1BVUkVfXyAqLyByZnNlKC8qI19fUFVSRV9fKi8gbmV3IHU4KFtcbiAgICAzMiwgMTMyLCAxNiwgNjYsIDEwMiwgNzAsIDY4LCA2OCwgNjgsIDY4LCAzNiwgNzMsIDJcbl0pLCAwLCA1KVsxXTtcbi8vIGJpdHMgdG8gYmFzZWxpbmVcbnZhciBiMmJsID0gZnVuY3Rpb24gKGIsIHMpIHtcbiAgICB2YXIgbGVuID0gYi5sZW5ndGgsIGJsID0gbmV3IGkzMihsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgYmxbaV0gPSBzO1xuICAgICAgICBzICs9IDEgPDwgYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJsO1xufTtcbi8vIGxpdGVyYWwgbGVuZ3RoIGJpdHNcbnZhciBsbGIgPSAvKiNfX1BVUkVfXyAqLyBuZXcgdTgoKCAvKiNfX1BVUkVfXyAqL25ldyBpMzIoW1xuICAgIDAsIDAsIDAsIDAsIDE2ODQzMDA5LCA1MDUyODc3MCwgMTM0Njc4MDIwLCAyMDIwNTAwNTcsIDI2OTQyMjA5M1xuXSkpLmJ1ZmZlciwgMCwgMzYpO1xuLy8gbGl0ZXJhbCBsZW5ndGggYmFzZWxpbmVcbnZhciBsbGJsID0gLyojX19QVVJFX18gKi8gYjJibChsbGIsIDApO1xuLy8gbWF0Y2ggbGVuZ3RoIGJpdHNcbnZhciBtbGIgPSAvKiNfX1BVUkVfXyAqLyBuZXcgdTgoKCAvKiNfX1BVUkVfXyAqL25ldyBpMzIoW1xuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDE2ODQzMDA5LCA1MDUyODc3MCwgMTE3NzY5MjIwLCAxODUyMDcwNDgsIDI1MjU3OTA4NCwgMTZcbl0pKS5idWZmZXIsIDAsIDUzKTtcbi8vIG1hdGNoIGxlbmd0aCBiYXNlbGluZVxudmFyIG1sYmwgPSAvKiNfX1BVUkVfXyAqLyBiMmJsKG1sYiwgMyk7XG4vLyBkZWNvZGUgaHVmZm1hbiBzdHJlYW1cbnZhciBkaHUgPSBmdW5jdGlvbiAoZGF0LCBvdXQsIGh1KSB7XG4gICAgdmFyIGxlbiA9IGRhdC5sZW5ndGgsIHNzID0gb3V0Lmxlbmd0aCwgbGIgPSBkYXRbbGVuIC0gMV0sIG1zayA9ICgxIDw8IGh1LmIpIC0gMSwgZWIgPSAtaHUuYjtcbiAgICBpZiAoIWxiKVxuICAgICAgICBlcnIoMCk7XG4gICAgdmFyIHN0ID0gMCwgYnRyID0gaHUuYiwgcG9zID0gKGxlbiA8PCAzKSAtIDggKyBtc2IobGIpIC0gYnRyLCBpID0gLTE7XG4gICAgZm9yICg7IHBvcyA+IGViICYmIGkgPCBzczspIHtcbiAgICAgICAgdmFyIGNidCA9IHBvcyA+PiAzO1xuICAgICAgICB2YXIgdmFsID0gKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSB8IChkYXRbY2J0ICsgMl0gPDwgMTYpKSA+PiAocG9zICYgNyk7XG4gICAgICAgIHN0ID0gKChzdCA8PCBidHIpIHwgdmFsKSAmIG1zaztcbiAgICAgICAgb3V0WysraV0gPSBodS5zW3N0XTtcbiAgICAgICAgcG9zIC09IChidHIgPSBodS5uW3N0XSk7XG4gICAgfVxuICAgIGlmIChwb3MgIT0gZWIgfHwgaSArIDEgIT0gc3MpXG4gICAgICAgIGVycigwKTtcbn07XG4vLyBkZWNvZGUgaHVmZm1hbiBzdHJlYW0gNHhcbi8vIFRPRE86IHVzZSB3b3JrZXJzIHRvIHBhcmFsbGVsaXplXG52YXIgZGh1NCA9IGZ1bmN0aW9uIChkYXQsIG91dCwgaHUpIHtcbiAgICB2YXIgYnQgPSA2O1xuICAgIHZhciBzcyA9IG91dC5sZW5ndGgsIHN6MSA9IChzcyArIDMpID4+IDIsIHN6MiA9IHN6MSA8PCAxLCBzejMgPSBzejEgKyBzejI7XG4gICAgZGh1KGRhdC5zdWJhcnJheShidCwgYnQgKz0gZGF0WzBdIHwgKGRhdFsxXSA8PCA4KSksIG91dC5zdWJhcnJheSgwLCBzejEpLCBodSk7XG4gICAgZGh1KGRhdC5zdWJhcnJheShidCwgYnQgKz0gZGF0WzJdIHwgKGRhdFszXSA8PCA4KSksIG91dC5zdWJhcnJheShzejEsIHN6MiksIGh1KTtcbiAgICBkaHUoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBkYXRbNF0gfCAoZGF0WzVdIDw8IDgpKSwgb3V0LnN1YmFycmF5KHN6Miwgc3ozKSwgaHUpO1xuICAgIGRodShkYXQuc3ViYXJyYXkoYnQpLCBvdXQuc3ViYXJyYXkoc3ozKSwgaHUpO1xufTtcbi8vIHJlYWQgWnN0YW5kYXJkIGJsb2NrXG52YXIgcnpiID0gZnVuY3Rpb24gKGRhdCwgc3QsIG91dCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgYnQgPSBzdC5iO1xuICAgIC8vICAgIGJ5dGUgMCAgICAgICAgYmxvY2sgdHlwZVxuICAgIHZhciBiMCA9IGRhdFtidF0sIGJ0eXBlID0gKGIwID4+IDEpICYgMztcbiAgICBzdC5sID0gYjAgJiAxO1xuICAgIHZhciBzeiA9IChiMCA+PiAzKSB8IChkYXRbYnQgKyAxXSA8PCA1KSB8IChkYXRbYnQgKyAyXSA8PCAxMyk7XG4gICAgLy8gZW5kIGJ5dGUgZm9yIGJsb2NrXG4gICAgdmFyIGVidCA9IChidCArPSAzKSArIHN6O1xuICAgIGlmIChidHlwZSA9PSAxKSB7XG4gICAgICAgIGlmIChidCA+PSBkYXQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdC5iID0gYnQgKyAxO1xuICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICBmaWxsKG91dCwgZGF0W2J0XSwgc3QueSwgc3QueSArPSBzeik7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxsKG5ldyB1OChzeiksIGRhdFtidF0pO1xuICAgIH1cbiAgICBpZiAoZWJ0ID4gZGF0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChidHlwZSA9PSAwKSB7XG4gICAgICAgIHN0LmIgPSBlYnQ7XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIG91dC5zZXQoZGF0LnN1YmFycmF5KGJ0LCBlYnQpLCBzdC55KTtcbiAgICAgICAgICAgIHN0LnkgKz0gc3o7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzbGMoZGF0LCBidCwgZWJ0KTtcbiAgICB9XG4gICAgaWYgKGJ0eXBlID09IDIpIHtcbiAgICAgICAgLy8gICAgYnl0ZSAzICAgICAgICBsaXQgYnR5cGUgICAgIHNpemUgZm9ybWF0XG4gICAgICAgIHZhciBiMyA9IGRhdFtidF0sIGxidCA9IGIzICYgMywgc2YgPSAoYjMgPj4gMikgJiAzO1xuICAgICAgICAvLyBsaXQgc3JjIHNpemUgIGxpdCBjbXAgc3ogNCBzdHJlYW1zXG4gICAgICAgIHZhciBsc3MgPSBiMyA+PiA0LCBsY3MgPSAwLCBzNCA9IDA7XG4gICAgICAgIGlmIChsYnQgPCAyKSB7XG4gICAgICAgICAgICBpZiAoc2YgJiAxKVxuICAgICAgICAgICAgICAgIGxzcyB8PSAoZGF0WysrYnRdIDw8IDQpIHwgKChzZiAmIDIpICYmIChkYXRbKytidF0gPDwgMTIpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsc3MgPSBiMyA+PiAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgczQgPSBzZjtcbiAgICAgICAgICAgIGlmIChzZiA8IDIpXG4gICAgICAgICAgICAgICAgbHNzIHw9ICgoZGF0WysrYnRdICYgNjMpIDw8IDQpLCBsY3MgPSAoZGF0W2J0XSA+PiA2KSB8IChkYXRbKytidF0gPDwgMik7XG4gICAgICAgICAgICBlbHNlIGlmIChzZiA9PSAyKVxuICAgICAgICAgICAgICAgIGxzcyB8PSAoZGF0WysrYnRdIDw8IDQpIHwgKChkYXRbKytidF0gJiAzKSA8PCAxMiksIGxjcyA9IChkYXRbYnRdID4+IDIpIHwgKGRhdFsrK2J0XSA8PCA2KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsc3MgfD0gKGRhdFsrK2J0XSA8PCA0KSB8ICgoZGF0WysrYnRdICYgNjMpIDw8IDEyKSwgbGNzID0gKGRhdFtidF0gPj4gNikgfCAoZGF0WysrYnRdIDw8IDIpIHwgKGRhdFsrK2J0XSA8PCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgKytidDtcbiAgICAgICAgLy8gYWRkIGxpdGVyYWxzIHRvIGVuZCAtIGNhbiBuZXZlciBvdmVybGFwIHdpdGggYmFja3JlZmVyZW5jZXMgYmVjYXVzZSB1bnVzZWQgbGl0ZXJhbHMgYWx3YXlzIGFwcGVuZGVkXG4gICAgICAgIHZhciBidWYgPSBvdXQgPyBvdXQuc3ViYXJyYXkoc3QueSwgc3QueSArIHN0Lm0pIDogbmV3IHU4KHN0Lm0pO1xuICAgICAgICAvLyBzdGFydGluZyBwb2ludCBmb3IgbGl0ZXJhbHNcbiAgICAgICAgdmFyIHNwbCA9IGJ1Zi5sZW5ndGggLSBsc3M7XG4gICAgICAgIGlmIChsYnQgPT0gMClcbiAgICAgICAgICAgIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBsc3MpLCBzcGwpO1xuICAgICAgICBlbHNlIGlmIChsYnQgPT0gMSlcbiAgICAgICAgICAgIGZpbGwoYnVmLCBkYXRbYnQrK10sIHNwbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaHVmZm1hbiB0YWJsZVxuICAgICAgICAgICAgdmFyIGh1ID0gc3QuaDtcbiAgICAgICAgICAgIGlmIChsYnQgPT0gMikge1xuICAgICAgICAgICAgICAgIHZhciBodWQgPSByaHUoZGF0LCBidCk7XG4gICAgICAgICAgICAgICAgLy8gc3VidHJhY3QgZGVzY3JpcHRpb24gbGVuZ3RoXG4gICAgICAgICAgICAgICAgbGNzICs9IGJ0IC0gKGJ0ID0gaHVkWzBdKTtcbiAgICAgICAgICAgICAgICBzdC5oID0gaHUgPSBodWRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaHUpXG4gICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgKHM0ID8gZGh1NCA6IGRodSkoZGF0LnN1YmFycmF5KGJ0LCBidCArPSBsY3MpLCBidWYuc3ViYXJyYXkoc3BsKSwgaHUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG51bSBzZXF1ZW5jZXNcbiAgICAgICAgdmFyIG5zID0gZGF0W2J0KytdO1xuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIGlmIChucyA9PSAyNTUpXG4gICAgICAgICAgICAgICAgbnMgPSAoZGF0W2J0KytdIHwgKGRhdFtidCsrXSA8PCA4KSkgKyAweDdGMDA7XG4gICAgICAgICAgICBlbHNlIGlmIChucyA+IDEyNylcbiAgICAgICAgICAgICAgICBucyA9ICgobnMgLSAxMjgpIDw8IDgpIHwgZGF0W2J0KytdO1xuICAgICAgICAgICAgLy8gc3ltYm9sIGNvbXByZXNzaW9uIG1vZGVzXG4gICAgICAgICAgICB2YXIgc2NtID0gZGF0W2J0KytdO1xuICAgICAgICAgICAgaWYgKHNjbSAmIDMpXG4gICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgdmFyIGR0cyA9IFtkbWx0LCBkb2N0LCBkbGx0XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyOyBpID4gLTE7IC0taSkge1xuICAgICAgICAgICAgICAgIHZhciBtZCA9IChzY20gPj4gKChpIDw8IDEpICsgMikpICYgMztcbiAgICAgICAgICAgICAgICBpZiAobWQgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBybGUgYnVmXG4gICAgICAgICAgICAgICAgICAgIHZhciByYnVmID0gbmV3IHU4KFswLCAwLCBkYXRbYnQrK11dKTtcbiAgICAgICAgICAgICAgICAgICAgZHRzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgczogcmJ1Zi5zdWJhcnJheSgyLCAzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG46IHJidWYuc3ViYXJyYXkoMCwgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0OiBuZXcgdTE2KHJidWYuYnVmZmVyLCAwLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGI6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWQgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhY2N1cmFjeSBsb2cgOCBmb3Igb2Zmc2V0cywgOSBmb3Igb3RoZXJzXG4gICAgICAgICAgICAgICAgICAgIF9hID0gcmZzZShkYXQsIGJ0LCA5IC0gKGkgJiAxKSksIGJ0ID0gX2FbMF0sIGR0c1tpXSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3QudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycigwKTtcbiAgICAgICAgICAgICAgICAgICAgZHRzW2ldID0gc3QudFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBzdC50ID0gZHRzLCBtbHQgPSBfYlswXSwgb2N0ID0gX2JbMV0sIGxsdCA9IF9iWzJdO1xuICAgICAgICAgICAgdmFyIGxiID0gZGF0W2VidCAtIDFdO1xuICAgICAgICAgICAgaWYgKCFsYilcbiAgICAgICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgICAgICB2YXIgc3BvcyA9IChlYnQgPDwgMykgLSA4ICsgbXNiKGxiKSAtIGxsdC5iLCBjYnQgPSBzcG9zID4+IDMsIG91YnQgPSAwO1xuICAgICAgICAgICAgdmFyIGxzdCA9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBsbHQuYikgLSAxKTtcbiAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG9jdC5iKSA+PiAzO1xuICAgICAgICAgICAgdmFyIG9zdCA9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBvY3QuYikgLSAxKTtcbiAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG1sdC5iKSA+PiAzO1xuICAgICAgICAgICAgdmFyIG1zdCA9ICgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBtbHQuYikgLSAxKTtcbiAgICAgICAgICAgIGZvciAoKytuczsgLS1uczspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGxjID0gbGx0LnNbbHN0XTtcbiAgICAgICAgICAgICAgICB2YXIgbGJ0ciA9IGxsdC5uW2xzdF07XG4gICAgICAgICAgICAgICAgdmFyIG1sYyA9IG1sdC5zW21zdF07XG4gICAgICAgICAgICAgICAgdmFyIG1idHIgPSBtbHQublttc3RdO1xuICAgICAgICAgICAgICAgIHZhciBvZmMgPSBvY3Quc1tvc3RdO1xuICAgICAgICAgICAgICAgIHZhciBvYnRyID0gb2N0Lm5bb3N0XTtcbiAgICAgICAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBvZmMpID4+IDM7XG4gICAgICAgICAgICAgICAgdmFyIG9mcCA9IDEgPDwgb2ZjO1xuICAgICAgICAgICAgICAgIHZhciBvZmYgPSBvZnAgKyAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkgfCAoZGF0W2NidCArIDJdIDw8IDE2KSB8IChkYXRbY2J0ICsgM10gPDwgMjQpKSA+Pj4gKHNwb3MgJiA3KSkgJiAob2ZwIC0gMSkpO1xuICAgICAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG1sYlttbGNdKSA+PiAzO1xuICAgICAgICAgICAgICAgIHZhciBtbCA9IG1sYmxbbWxjXSArICgoKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSB8IChkYXRbY2J0ICsgMl0gPDwgMTYpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBtbGJbbWxjXSkgLSAxKSk7XG4gICAgICAgICAgICAgICAgY2J0ID0gKHNwb3MgLT0gbGxiW2xsY10pID4+IDM7XG4gICAgICAgICAgICAgICAgdmFyIGxsID0gbGxibFtsbGNdICsgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpIHwgKGRhdFtjYnQgKyAyXSA8PCAxNikpID4+IChzcG9zICYgNykpICYgKCgxIDw8IGxsYltsbGNdKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBjYnQgPSAoc3BvcyAtPSBsYnRyKSA+PiAzO1xuICAgICAgICAgICAgICAgIGxzdCA9IGxsdC50W2xzdF0gKyAoKChkYXRbY2J0XSB8IChkYXRbY2J0ICsgMV0gPDwgOCkpID4+IChzcG9zICYgNykpICYgKCgxIDw8IGxidHIpIC0gMSkpO1xuICAgICAgICAgICAgICAgIGNidCA9IChzcG9zIC09IG1idHIpID4+IDM7XG4gICAgICAgICAgICAgICAgbXN0ID0gbWx0LnRbbXN0XSArICgoKGRhdFtjYnRdIHwgKGRhdFtjYnQgKyAxXSA8PCA4KSkgPj4gKHNwb3MgJiA3KSkgJiAoKDEgPDwgbWJ0cikgLSAxKSk7XG4gICAgICAgICAgICAgICAgY2J0ID0gKHNwb3MgLT0gb2J0cikgPj4gMztcbiAgICAgICAgICAgICAgICBvc3QgPSBvY3QudFtvc3RdICsgKCgoZGF0W2NidF0gfCAoZGF0W2NidCArIDFdIDw8IDgpKSA+PiAoc3BvcyAmIDcpKSAmICgoMSA8PCBvYnRyKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBpZiAob2ZmID4gMykge1xuICAgICAgICAgICAgICAgICAgICBzdC5vWzJdID0gc3Qub1sxXTtcbiAgICAgICAgICAgICAgICAgICAgc3Qub1sxXSA9IHN0Lm9bMF07XG4gICAgICAgICAgICAgICAgICAgIHN0Lm9bMF0gPSBvZmYgLT0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBvZmYgLSAobGwgIT0gMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZiA9IGlkeCA9PSAzID8gc3Qub1swXSAtIDEgOiBzdC5vW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID4gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdC5vWzJdID0gc3Qub1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0Lm9bMV0gPSBzdC5vWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Qub1swXSA9IG9mZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmYgPSBzdC5vWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW291YnQgKyBpXSA9IGJ1ZltzcGwgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3VidCArPSBsbCwgc3BsICs9IGxsO1xuICAgICAgICAgICAgICAgIHZhciBzdGluID0gb3VidCAtIG9mZjtcbiAgICAgICAgICAgICAgICBpZiAoc3RpbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IC1zdGluO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnMgPSBzdC5lICsgc3RpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA+IG1sKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gbWw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltvdWJ0ICsgaV0gPSBzdC53W2JzICsgaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3VidCArPSBsZW4sIG1sIC09IGxlbiwgc3RpbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBidWZbb3VidCArIGldID0gYnVmW3N0aW4gKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3VidCArPSBtbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdWJ0ICE9IHNwbCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChzcGwgPCBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltvdWJ0KytdID0gYnVmW3NwbCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3VidCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob3V0KVxuICAgICAgICAgICAgICAgIHN0LnkgKz0gb3VidDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBidWYgPSBzbGMoYnVmLCAwLCBvdWJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgICAgICBzdC55ICs9IGxzcztcbiAgICAgICAgICAgICAgICBpZiAoc3BsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbHNzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltpXSA9IGJ1ZltzcGwgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNwbClcbiAgICAgICAgICAgICAgICBidWYgPSBzbGMoYnVmLCBzcGwpO1xuICAgICAgICB9XG4gICAgICAgIHN0LmIgPSBlYnQ7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIGVycigyKTtcbn07XG4vLyBjb25jYXRcbnZhciBjY3QgPSBmdW5jdGlvbiAoYnVmcywgb2wpIHtcbiAgICBpZiAoYnVmcy5sZW5ndGggPT0gMSlcbiAgICAgICAgcmV0dXJuIGJ1ZnNbMF07XG4gICAgdmFyIGJ1ZiA9IG5ldyB1OChvbCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGIgPSAwOyBpIDwgYnVmcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2hrID0gYnVmc1tpXTtcbiAgICAgICAgYnVmLnNldChjaGssIGIpO1xuICAgICAgICBiICs9IGNoay5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59O1xuLyoqXG4gKiBEZWNvbXByZXNzZXMgWnN0YW5kYXJkIGRhdGFcbiAqIEBwYXJhbSBkYXQgVGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSBidWYgVGhlIG91dHB1dCBidWZmZXIuIElmIHVuc3BlY2lmaWVkLCB0aGUgZnVuY3Rpb24gd2lsbCBhbGxvY2F0ZVxuICogICAgICAgICAgICBleGFjdGx5IGVub3VnaCBtZW1vcnkgdG8gZml0IHRoZSBkZWNvbXByZXNzZWQgZGF0YS4gSWYgeW91clxuICogICAgICAgICAgICBkYXRhIGhhcyBtdWx0aXBsZSBmcmFtZXMgYW5kIHlvdSBrbm93IHRoZSBvdXRwdXQgc2l6ZSwgc3BlY2lmeWluZ1xuICogICAgICAgICAgICBpdCB3aWxsIHlpZWxkIGJldHRlciBwZXJmb3JtYW5jZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgZGF0YVxuICovXG5yZXR1cm4gZnVuY3Rpb24gZGVjb21wcmVzcyhkYXQsIGJ1Zikge1xuICAgIHZhciBidCA9IDAsIGJ1ZnMgPSBbXSwgbmIgPSArIWJ1Ziwgb2wgPSAwO1xuICAgIGZvciAoOyBkYXQubGVuZ3RoOykge1xuICAgICAgICB2YXIgc3QgPSByemZoKGRhdCwgbmIgfHwgYnVmKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKG5iKSB7XG4gICAgICAgICAgICAgICAgYnVmID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc3Qudy5sZW5ndGggPT0gc3QudSkge1xuICAgICAgICAgICAgICAgICAgICBidWZzLnB1c2goYnVmID0gc3Qudyk7XG4gICAgICAgICAgICAgICAgICAgIG9sICs9IHN0LnU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmcy5wdXNoKGJ1Zik7XG4gICAgICAgICAgICAgICAgc3QuZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgIXN0Lmw7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsayA9IHJ6YihkYXQsIHN0LCBidWYpO1xuICAgICAgICAgICAgICAgIGlmICghYmxrKVxuICAgICAgICAgICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZilcbiAgICAgICAgICAgICAgICAgICAgc3QuZSA9IHN0Lnk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZnMucHVzaChibGspO1xuICAgICAgICAgICAgICAgICAgICBvbCArPSBibGsubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjcHcoc3QudywgMCwgYmxrLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHN0Lncuc2V0KGJsaywgc3Qudy5sZW5ndGggLSBibGsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidCA9IHN0LmIgKyAoc3QuYyAqIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJ0ID0gc3Q7XG4gICAgICAgIGRhdCA9IGRhdC5zdWJhcnJheShidCk7XG4gICAgfVxuICAgIHJldHVybiBjY3QoYnVmcywgb2wpO1xufVxufSkgKClcblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RlY29tcHJlc3NfaW5wdXRcbi8vVmVyc2lvbjogPCA1LjEuMFxudmFyIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IG51bGxcblxuLy9Qcm92aWRlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG4vL1ZlcnNpb246ID49IDUuMS4wXG4vL1ZlcnNpb246IDwgNS4xLjFcbi8vUmVxdWlyZXM6IHpzdGRfZGVjb21wcmVzc1xudmFyIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IHpzdGRfZGVjb21wcmVzcztcblxuLy9Qcm92aWRlczogY2FtbF9kZWNvbXByZXNzX2lucHV0XG4vL1ZlcnNpb246ID49IDUuMS4xXG4vL1ZlcnNpb246IDwgNS4yLjBcbnZhciBjYW1sX2RlY29tcHJlc3NfaW5wdXQgPSBudWxsXG5cbi8vUHJvdmlkZXM6IGNhbWxfZGVjb21wcmVzc19pbnB1dFxuLy9WZXJzaW9uOiA+PSA1LjJcbi8vUmVxdWlyZXM6IHpzdGRfZGVjb21wcmVzc1xudmFyIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IHpzdGRfZGVjb21wcmVzcztcblxuLy9Qcm92aWRlczogY2FtbF96c3RkX2luaXRpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfZGVjb21wcmVzc19pbnB1dFxuLy9SZXF1aXJlczogenN0ZF9kZWNvbXByZXNzXG4vL1ZlcnNpb246ID49IDUuMS4xXG5mdW5jdGlvbiBjYW1sX3pzdGRfaW5pdGlhbGl6ZSh1bml0KSB7XG4gIGNhbWxfZGVjb21wcmVzc19pbnB1dCA9IHpzdGRfZGVjb21wcmVzcztcbiAgcmV0dXJuIDFcbn1cblxuIiwiLy9Qcm92aWRlczogY29yZV9oZWFwX2Jsb2NrX2lzX2hlYXBfYmxvY2tcbmZ1bmN0aW9uIGNvcmVfaGVhcF9ibG9ja19pc19oZWFwX2Jsb2NrKHgpe1xuICByZXR1cm4gKyh4IGluc3RhbmNlb2YgQXJyYXkpO1xufVxuXG4iXX0=
