// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Timing_wheel__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Timing_wheel = [0],
    Timing_wheel$0 = [0, Timing_wheel];
   runtime.caml_register_global(0, Timing_wheel$0, "Timing_wheel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel__Import
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel_Import = "Timing_wheel__Import",
    cst_timing_wheel = "timing_wheel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1(Ppx_expect_runtime[1][1], "timing_wheel/src/import.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_timing_wheel, "import.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_timing_wheel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel_Import);
   var Timing_wheel_Import = [0];
   runtime.caml_register_global
    (11, Timing_wheel_Import, cst_Timing_wheel_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel__Timing_wheel_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel_Timing_wheel_ = "Timing_wheel__Timing_wheel_intf",
    cst_timing_wheel = "timing_wheel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel_Timing_wheel_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1
    (Ppx_expect_runtime[1][1], "timing_wheel/src/timing_wheel_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_timing_wheel, "timing_wheel_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_timing_wheel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel_Timing_wheel_);
   var Timing_wheel_Timing_wheel_intf = [0];
   runtime.caml_register_global
    (11, Timing_wheel_Timing_wheel_intf, cst_Timing_wheel_Timing_wheel_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel
//# unitInfo: Requires: Base__Invariant, Base__Sexpable, Core, Core__Array, Core__Binable, Core__Int, Core__Int63, Core__List, Core__Time_ns, Core__Time_ns_alternate_sexp, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_record, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel$0 = "Timing_wheel",
    cst_Timing_wheel_max_alarm_tim$1 =
      "Timing_wheel.max_alarm_time_in_min_interval_exn of empty timing wheel",
    cst = "_",
    cst_alarm_precision$0 = "alarm_precision",
    cst_at = "at",
    cst_bits$0 = "bits",
    cst_bits_per_slot$0 = "bits_per_slot",
    cst_capacity$0 = "capacity",
    cst_config$0 = "config",
    cst_diff_max_min_allowed_key$0 = "diff_max_min_allowed_key",
    cst_elt_key_lower_bound$0 = "elt_key_lower_bound",
    cst_index$0 = "index",
    cst_interval_num = "interval_num",
    cst_key = "key",
    cst_keys_per_slot$0 = "keys_per_slot",
    cst_length$1 = "length",
    cst_level_bits$1 = "level_bits",
    cst_levels$0 = "levels",
    cst_max_allowed_alarm_time$0 = "max_allowed_alarm_time",
    cst_max_allowed_key$0 = "max_allowed_key",
    cst_max_interval_num$0 = "max_interval_num",
    cst_min_allowed_key$0 = "min_allowed_key",
    cst_min_elt$0 = "min_elt",
    cst_min_key_in_same_slot_mask$0 = "min_key_in_same_slot_mask",
    cst_now$0 = "now",
    cst_now_interval_num_start$0 = "now_interval_num_start",
    cst_pool$0 = "pool",
    cst_priority_queue$0 = "priority_queue",
    cst_slots$0 = "slots",
    cst_slots_mask$0 = "slots_mask",
    cst_start$0 = "start",
    cst_timing_wheel$0 = "timing_wheel",
    cst_timing_wheel_src_timing_wh = "timing_wheel/src/timing_wheel.ml",
    cst_value = "value",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos$9 = "timing_wheel/src/timing_wheel.ml:1617:26",
    pos$8 = "timing_wheel/src/timing_wheel.ml:1614:26",
    pos$7 = "timing_wheel/src/timing_wheel.ml:1630:26",
    pos$6 = "timing_wheel/src/timing_wheel.ml:1635:26",
    arg_087 = [0, cst],
    pos$5 = "timing_wheel/src/timing_wheel.ml:993:32",
    pos$4 = "timing_wheel/src/timing_wheel.ml:990:32",
    pos$3 = "timing_wheel/src/timing_wheel.ml:900:31",
    pos$2 = "timing_wheel/src/timing_wheel.ml:907:30",
    pos$1 = "timing_wheel/src/timing_wheel.ml:918:31",
    pos$0 = "timing_wheel/src/timing_wheel.ml:936:32",
    pos = "timing_wheel/src/timing_wheel.ml:941:30",
    error_source_019 = "timing_wheel/src/timing_wheel.ml.Config.t",
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Core_Time_ns_alternate_sexp = global_data.Core__Time_ns_alternate_sexp,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_Time_ns = global_data.Core__Time_ns,
    Core_List = global_data.Core__List,
    Core_Int63 = global_data.Core__Int63,
    Core_Array = global_data.Core__Array,
    Tuple_pool = global_data.Tuple_pool,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Int = global_data.Core__Int,
    Core_Binable = global_data.Core__Binable,
    Base_Sexpable = global_data.Base__Sexpable;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_timing_wheel_src_timing_wh);
   caml_call2(Ppx_inline_test_lib[6], cst_timing_wheel$0, "timing_wheel.ml");
   var
    max_time = Core_Time_ns_alternate_sexp[37],
    min_time = Core_Time_ns_alternate_sexp[35],
    zero = Core_Int[59],
    to_int = Core_Int[65],
    t_of_sexp = Core_Int[76],
    sexp_of_t = Core_Int[77],
    symbol = Core_Int[81],
    symbol$0 = Core_Int[82],
    symbol$1 = Core_Int[84],
    equal = Core_Int[87],
    max_num_bits = Core_Int63[61] - 1 | 0,
    _b8_ = [0, cst],
    _b9_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_max_alarm_tim$0 = cst_Timing_wheel_max_alarm_tim$1,
    _b6_ = [0, cst],
    _b7_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_max_alarm_tim = cst_Timing_wheel_max_alarm_tim$1,
    _b4_ = [0, cst],
    _b5_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_min_alarm_int =
      "Timing_wheel.min_alarm_interval_num_exn of empty timing_wheel",
    cst_Timing_wheel_cannot_resche =
      "Timing_wheel cannot reschedule alarm not in timing wheel",
    _b2_ = [0, cst_now_interval_num_start$0],
    _b3_ = [0, cst_at],
    cst_Timing_wheel_cannot_schedu$0 =
      "Timing_wheel cannot schedule alarm before start of current interval",
    _b0_ = [0, cst_max_allowed_alarm_time$0],
    _b1_ = [0, cst_at],
    cst_Timing_wheel_cannot_schedu =
      "Timing_wheel cannot schedule alarm that far in the future",
    _bZ_ = [0, cst_timing_wheel_src_timing_wh, 1707, 53],
    _bY_ = [0, cst_start$0],
    cst_Timing_wheel_create_got_st =
      "Timing_wheel.create got start before the epoch",
    _bX_ = [0, cst_timing_wheel_src_timing_wh, 1680, 54],
    _bW_ = [0, cst_timing_wheel_src_timing_wh, 1674, 52],
    _bU_ = [0, cst],
    _bT_ = [0, cst_timing_wheel_src_timing_wh, 1640, 6],
    _bS_ = [0, cst_timing_wheel_src_timing_wh, 1644, 6],
    _bR_ = [0, cst_timing_wheel_src_timing_wh, 1646, 6],
    _bQ_ = [0, cst_timing_wheel_src_timing_wh, 1610, 11],
    _bP_ = [0, cst_timing_wheel_src_timing_wh, 1611, 11],
    _bO_ = [0, cst_timing_wheel_src_timing_wh, 1622, 11],
    _bN_ = [0, cst_timing_wheel_src_timing_wh, 1623, 11],
    _bM_ = [0, cst_timing_wheel_src_timing_wh, 1624, 11],
    _bV_ = [0, cst_timing_wheel_src_timing_wh, 1604, 57929, 57951],
    _bK_ = [0, "t.max_interval_num"],
    _bL_ = [0, cst_interval_num],
    cst_Timing_wheel_interval_num_$1 =
      "Timing_wheel.interval_num_start got too large interval_num",
    _bI_ = [0, "min_interval_num"],
    _bJ_ = [0, cst_interval_num],
    cst_Timing_wheel_interval_num_$0 =
      "Timing_wheel.interval_num_start got too small interval_num",
    _bH_ = [0, "time"],
    cst_Timing_wheel_interval_num_ =
      "Timing_wheel.interval_num got time too far in the past",
    _bF_ = [0, cst],
    _bG_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_next_alarm_fi$0 =
      "Timing_wheel.next_alarm_fires_at_exn with all alarms in max interval",
    _bD_ = [0, cst],
    _bE_ = [0, cst_timing_wheel$0],
    cst_Timing_wheel_next_alarm_fi =
      "Timing_wheel.next_alarm_fires_at_exn of empty timing wheel",
    _by_ = [0, "alarms"],
    _bz_ = [0, cst_now$0],
    _bA_ = [0, cst_max_interval_num$0],
    _bB_ = [0, cst_start$0],
    _bC_ = [0, cst_config$0],
    _bw_ = [0, cst_value],
    _bx_ = [0, cst_at],
    _be_ = [0, "max_allowed_alarm_interval_num"],
    _bf_ = [0, "min_allowed_alarm_interval_num"],
    _bg_ = [0, cst_interval_num],
    cst_Timing_wheel_add_at_interv =
      "Timing_wheel.add_at_interval_num got invalid interval num",
    _bb_ = [0, cst],
    _bc_ = [0, "level"],
    _bd_ = [0, cst_key],
    cst_Priority_queue_add_elt_key$0 =
      "Priority_queue.add_elt key out of level bounds",
    _a9_ = [0, cst_priority_queue$0],
    _a__ = [0, "max_allowed_key t"],
    _a$_ = [0, "min_allowed_key t"],
    _ba_ = [0, cst_key],
    cst_Priority_queue_add_elt_key =
      "Priority_queue.add_elt key out of bounds",
    _a7_ = [0, cst],
    _a4_ = [0, cst_timing_wheel_src_timing_wh, 965, 38],
    _a3_ = [0, cst_timing_wheel_src_timing_wh, 971, 15],
    _a2_ = [0, cst_timing_wheel_src_timing_wh, 972, 15],
    _a1_ = [0, cst_timing_wheel_src_timing_wh, 975, 13],
    _a0_ = [0, cst_timing_wheel_src_timing_wh, 976, 13],
    _aZ_ = [0, cst_timing_wheel_src_timing_wh, 979, 15],
    _aX_ = [0, cst_timing_wheel_src_timing_wh, 984, 15],
    _aY_ = [0, cst_timing_wheel_src_timing_wh, 982, 13],
    _a6_ = [0, cst_timing_wheel_src_timing_wh, 962, 6],
    _a5_ = [0, cst_timing_wheel_src_timing_wh, 963, 6],
    _aV_ = [0, cst],
    _aU_ = [0, cst_timing_wheel_src_timing_wh, 896, 38],
    _aT_ = [0, cst_timing_wheel_src_timing_wh, 897, 36],
    _aS_ = [0, cst_timing_wheel_src_timing_wh, 904, 15],
    _aR_ = [0, cst_timing_wheel_src_timing_wh, 912, 15],
    _aQ_ = [0, cst_timing_wheel_src_timing_wh, 925, 15],
    _aP_ = [0, cst_timing_wheel_src_timing_wh, 933, 15],
    _aO_ = [0, cst_timing_wheel_src_timing_wh, 954, 21],
    _aN_ = [0, cst_timing_wheel_src_timing_wh, 955, 21],
    _aM_ = [0, cst_timing_wheel_src_timing_wh, 956, 21],
    _aL_ = [0, cst_timing_wheel_src_timing_wh, 957, 21],
    _aW_ = [0, cst_timing_wheel_src_timing_wh, 893, 31661, 31687],
    _a8_ = [0, cst_timing_wheel_src_timing_wh, 960, 34764, 34788],
    _aI_ = [0, "elts"],
    _aJ_ = [0, cst_max_allowed_key$0],
    _aK_ = [0, cst_min_allowed_key$0],
    _aG_ = [0, cst_value],
    _aH_ = [0, cst_key],
    _aB_ = [0, cst_levels$0],
    _aC_ = [0, cst_elt_key_lower_bound$0],
    _aD_ = [0, cst_min_elt$0],
    _aE_ = [0, cst_pool$0],
    _aF_ = [0, cst_length$1],
    _ag_ = [0, cst_slots$0],
    _ah_ = [0, cst_max_allowed_key$0],
    _ai_ = [0, cst_min_allowed_key$0],
    _aj_ = [0, cst_length$1],
    _ak_ = [0, cst_diff_max_min_allowed_key$0],
    _al_ = [0, cst_min_key_in_same_slot_mask$0],
    _am_ = [0, cst_keys_per_slot$0],
    _an_ = [0, cst_bits_per_slot$0],
    _ao_ = [0, cst_slots_mask$0],
    _ap_ = [0, cst_bits$0],
    _aq_ = [0, cst_index$0],
    cst_Timing_wheel_got_invalid_a = "Timing_wheel got invalid alarm",
    _K_ = [0, cst],
    _J_ = [0, cst_timing_wheel_src_timing_wh, 646, 8],
    _I_ = [0, cst_timing_wheel_src_timing_wh, 649, 8],
    _H_ = [0, cst_timing_wheel_src_timing_wh, 651, 8],
    _L_ = [0, cst_timing_wheel_src_timing_wh, 645, 23075, 23101],
    _t_ = [0, 10, [0, 10, [0, 6, [0, 6, [0, 5, 0]]]]],
    _r_ = [0, cst_timing_wheel_src_timing_wh, 257, 6],
    _s_ = [0, cst_timing_wheel_src_timing_wh, 256, 8286, 8310],
    _o_ = [0, cst_capacity$0],
    _p_ = [0, cst_level_bits$1],
    _q_ = [0, cst_alarm_precision$0],
    cst_capacity = cst_capacity$0,
    cst_level_bits$0 = cst_level_bits$1,
    cst_alarm_precision = cst_alarm_precision$0,
    _h_ = [0, "span"],
    cst_Alarm_precision_of_span_fl =
      "[Alarm_precision.of_span_floor_pow2_ns] got non-positive span",
    cst_Alarm_precision_to_span_of =
      "[Alarm_precision.to_span] of negative power of two nanoseconds",
    _e_ = [0, "max_num_bits"],
    _f_ = [0, "got"],
    cst_Level_bits_create_exn_got_$0 =
      "Level_bits.create_exn got too many bits",
    cst_Level_bits_create_exn_got_ =
      "Level_bits.create_exn got nonpositive num bits",
    cst_Level_bits_create_exn_requ =
      "Level_bits.create_exn requires a nonempty list",
    _d_ = [0, cst_timing_wheel_src_timing_wh, 117, 6],
    _c_ = [0, cst_timing_wheel_src_timing_wh, 114, 4],
    _b_ = [0, cst_timing_wheel_src_timing_wh, 82, 4],
    _a_ = [0, cst_timing_wheel_src_timing_wh, 83, 4],
    _g_ = [0, 11, [0, 10, [0, 10, [0, 10, [0, 10, [0, 10, [0, 1, 0]]]]]]],
    cst_level_bits = cst_level_bits$1,
    cst_slots = cst_slots$0,
    cst_max_allowed_key = cst_max_allowed_key$0,
    cst_min_allowed_key = cst_min_allowed_key$0,
    cst_length = cst_length$1,
    cst_diff_max_min_allowed_key = cst_diff_max_min_allowed_key$0,
    cst_min_key_in_same_slot_mask = cst_min_key_in_same_slot_mask$0,
    cst_keys_per_slot = cst_keys_per_slot$0,
    cst_bits_per_slot = cst_bits_per_slot$0,
    cst_slots_mask = cst_slots_mask$0,
    cst_bits = cst_bits$0,
    cst_index = cst_index$0,
    cst_levels = cst_levels$0,
    cst_elt_key_lower_bound = cst_elt_key_lower_bound$0,
    cst_min_elt = cst_min_elt$0,
    cst_pool = cst_pool$0,
    cst_length$0 = cst_length$1,
    cst_priority_queue = cst_priority_queue$0,
    cst_max_allowed_alarm_time = cst_max_allowed_alarm_time$0,
    cst_now_interval_num_start = cst_now_interval_num_start$0,
    cst_now = cst_now$0,
    cst_max_interval_num = cst_max_interval_num$0,
    cst_start = cst_start$0,
    cst_config = cst_config$0,
    cst_timing_wheel = cst_timing_wheel$0,
    cst_Timing_wheel = cst_Timing_wheel$0,
    min_value = 0;
   function invariant(t){
    if(! caml_call2(symbol, t, min_value))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(caml_call2(symbol$0, t, max_num_bits)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function of_int(i){invariant(i); return i;}
   function symbol$2(t1, t2){var t = t1 + t2 | 0; invariant(t); return t;}
   function symbol$3(t1, t2){var t = t1 - t2 | 0; invariant(t); return t;}
   function pow2(t){return caml_call2(Core_Int63[50], Core_Int63[17], t);}
   function sexp_of_t$0(x_007){
    return caml_call2(Core[472], sexp_of_t, x_007);
   }
   function num_bits_internal(t){
    return caml_call3(Core_List[20], t, zero, symbol$2);
   }
   function num_bits(t){return num_bits_internal(t);}
   function invariant$0(t){
    if(caml_call1(Core_List[18], t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    function _fA_(num_key_bits){
     invariant(num_key_bits);
     if(caml_call2(symbol$1, num_key_bits, zero)) return 0;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
    caml_call2(Core_List[19], t, _fA_);
    return invariant(num_bits_internal(t));
   }
   function t_of_sexp$0(x_006){
    var t = caml_call2(Core[473], t_of_sexp, x_006);
    invariant$0(t);
    return t;
   }
   function create_exn(opt, x_008){
    if(opt)
     var sth = opt[1], extend_to_max_num_bits = sth;
    else
     var extend_to_max_num_bits = 0;
    if(caml_call1(Core_List[18], x_008))
     caml_call1(Core[6], cst_Level_bits_create_exn_requ);
    function _fo_(bits){return caml_call2(Core[89], bits, 0);}
    if(caml_call2(Core_List[23], x_008, _fo_)){
     var
      _fp_ = [0, caml_call2(Core[472], Core[389], x_008), 0],
      _fq_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Level_bits_create_exn_got_),
          _fp_]];
     caml_call1(Core[261], _fq_);
    }
    function _fr_(_fz_, _fy_){return _fz_ + _fy_ | 0;}
    var num_bits = caml_call3(Core_List[20], x_008, 0, _fr_);
    if(caml_call2(Core[91], num_bits, max_num_bits)){
     var
      _fs_ =
        [0, [1, [0, _e_, [0, caml_call1(Core[389], max_num_bits), 0]]], 0],
      _ft_ = [0, [1, [0, _f_, [0, caml_call1(Core[389], num_bits), 0]]], _fs_],
      _fu_ = [0, caml_call2(Core[472], Core[389], x_008), _ft_],
      _fv_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Level_bits_create_exn_got_$0),
          _fu_]];
     caml_call1(Core[261], _fv_);
    }
    if(extend_to_max_num_bits)
     var
      _fw_ = caml_call1(Core[242], 1),
      _fx_ = caml_call2(Core_List[40], max_num_bits - num_bits | 0, _fw_),
      ints = caml_call2(Core[156], x_008, _fx_);
    else
     var ints = x_008;
    return caml_call2(Core_List[51], ints, of_int);
   }
   var level_bits_default = create_exn(0, _g_), compare = Core[382];
   function equal$0(x_012, x_013){
    return 0 === caml_call2(compare, x_012, x_013) ? 1 : 0;
   }
   function num_key_bits(t){return of_int(t);}
   function to_sexpable(t){
    if(caml_call2(Core[92], t, 0)){
     var
      _fl_ = [0, caml_call1(Core[389], t), 0],
      _fm_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Alarm_precision_to_span_of),
          _fl_]];
     caml_call1(Core[261], _fm_);
    }
    var _fn_ = caml_call1(caml_call1(Core_Int63[50], Core_Int63[17]), t);
    return caml_call1(Core_Time_ns[1][137], _fn_);
   }
   function sexp_of_t$1(t){
    var _fk_ = to_sexpable(t);
    return caml_call1(Core_Time_ns[1][10], _fk_);
   }
   var
    one_nanosecond = 0,
    about_one_microsecond = 10,
    about_one_millisecond = 20,
    about_one_second = 30,
    about_one_day = 46;
   function mul(t, pow2){return t + pow2 | 0;}
   function div(t, pow2){return t - pow2 | 0;}
   function of_span_floor_pow2_ns(span){
    if(caml_call2(Core_Time_ns[1][16], span, Core_Time_ns[1][76])){
     var
      _fh_ =
        [0, [1, [0, _h_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]], 0],
      _fi_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Alarm_precision_of_span_fl),
          _fh_]];
     caml_call1(Core[261], _fi_);
    }
    var _fj_ = caml_call1(Core_Time_ns[1][136], span);
    return caml_call1(Core_Int63[89], _fj_);
   }
   var
    _i_ = Core_Time_ns[1],
    _j_ =
      caml_call1
       (caml_call1
         (Core_Binable[6], [0, _i_[5], _i_[1], _i_[2], _i_[3], _i_[4]]),
        [0, to_sexpable, of_span_floor_pow2_ns]),
    bin_size_t = _j_[1],
    bin_write_t = _j_[2],
    bin_read_t = _j_[3],
    bin_read_t$0 = _j_[4],
    bin_shape_t = _j_[5],
    bin_writer_t = _j_[6],
    bin_reader_t = _j_[7],
    bin_t = _j_[8],
    _k_ = Core_Time_ns[1],
    include =
      caml_call1
       (caml_call1(Base_Sexpable[1], [0, _k_[9], _k_[10]]),
        [0, to_sexpable, of_span_floor_pow2_ns]),
    t_of_sexp$1 = include[1],
    sexp_of_t$2 = include[2],
    _l_ =
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       compare,
       t_of_sexp$1,
       sexp_of_t$2];
   function level_bits(r){return r[2];}
   function _m_(r, v){return [0, r[1], v, r[3]];}
   var
    _n_ = 0,
    level_bits$0 =
      [0, function(param){return 0;}, cst_level_bits, _n_, level_bits, _m_];
   function t_of_sexp$2(x_021){
    function _fb_(param){
     var
      _fg_ = param[2],
      capacity = _fg_[2][1],
      level_bits = _fg_[1],
      alarm_precision = param[1];
     return [0, alarm_precision, level_bits, capacity];
    }
    var _fc_ = 0;
    function _fd_(param){
     return caml_string_notequal(param, cst_alarm_precision$0)
             ? caml_string_notequal
                (param, cst_capacity$0)
               ? caml_string_notequal(param, cst_level_bits$1) ? -1 : 1
               : 2
             : 0;
    }
    var
     _fe_ = [0, cst_capacity, 5, Core[390], 0],
     _ff_ =
       [0,
        cst_level_bits$0,
        [0, function(param){return level_bits_default;}],
        t_of_sexp$0,
        _fe_];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_019,
             [0, cst_alarm_precision, 1, _l_[10], _ff_],
             _fd_,
             _fc_,
             _fb_,
             x_021);
   }
   function sexp_of_t$3(param){
    var
     capacity_027 = param[3],
     level_bits_025 = param[2],
     alarm_precision_023 = param[1],
     bnds_022 = 0;
    if(capacity_027)
     var
      v_028 = capacity_027[1],
      arg_030 = caml_call1(Core[389], v_028),
      bnd_029 = [1, [0, _o_, [0, arg_030, 0]]],
      bnds_022$0 = [0, bnd_029, bnds_022];
    else
     var bnds_022$0 = bnds_022;
    var
     arg_026 = sexp_of_t$0(level_bits_025),
     bnds_022$1 = [0, [1, [0, _p_, [0, arg_026, 0]]], bnds_022$0],
     arg_024 = caml_call1(_l_[11], alarm_precision_023),
     bnds_022$2 = [0, [1, [0, _q_, [0, arg_024, 0]]], bnds_022$1];
    return [1, bnds_022$2];
   }
   function alarm_precision(t){return to_sexpable(t[1]);}
   function max_num_level_bits(alarm_precision){
    return symbol$3(max_num_bits, num_key_bits(alarm_precision));
   }
   function invariant$1(t){
    function _e$_(param){
     var _fa_ = max_num_level_bits(t[1]);
     if(! caml_call2(symbol$0, num_bits_internal(t[2]), _fa_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
     var level_bits_fun = caml_call2(Base_Invariant[2], t, invariant$0);
     caml_call1(level_bits_fun, level_bits$0);
     return 0;
    }
    return caml_call4(Base_Invariant[1], _s_, t, sexp_of_t$3, _e$_);
   }
   function create(capacity, opt, alarm_precision, param){
    if(opt)
     var sth = opt[1], level_bits = sth;
    else
     var level_bits = level_bits_default;
    var max_num_bits = max_num_level_bits(alarm_precision);
    if(caml_call2(symbol$0, num_bits_internal(level_bits), max_num_bits))
     var level_bits$0 = level_bits;
    else
     var
      loop =
        function(t, remaining){
         if(! t) return 0;
         var t$0 = t[2], b = t[1];
         return caml_call2(symbol, b, remaining)
                 ? [0, remaining, 0]
                 : [0, b, loop(t$0, symbol$3(remaining, b))];
        },
      level_bits$0 = loop(level_bits, max_num_bits);
    return [0, alarm_precision, level_bits$0, capacity];
   }
   function microsecond_precision(param){
    return create(0, [0, create_exn(0, _t_)], about_one_microsecond, 0);
   }
   function durations(t){
    function _e8_(num_bits_accum, level_num_bits){
     var
      num_bits_accum$0 =
        num_bits_accum + caml_call1(to_int, level_num_bits) | 0,
      _e__ =
        caml_call2(Core[90], num_bits_accum$0, Core_Int63[61] - 1 | 0)
         ? Core_Int63[62]
         : caml_call2(Core_Int63[50], Core_Int63[17], num_bits_accum$0),
      duration = caml_call1(Core_Time_ns[1][137], _e__);
     return [0, num_bits_accum$0, duration];
    }
    var _e9_ = caml_call1(to_int, num_key_bits(t[1]));
    return caml_call3(Core_List[90], t[2], _e9_, _e8_);
   }
   var compare$0 = Core_Int63[114], sexp_of_t$4 = Core_Int63[103];
   function create$0(level_bits){
    var _e6_ = Core_Int63[17], _e7_ = pow2(level_bits);
    return caml_call2(Core_Int63[20], _e7_, _e6_);
   }
   function num_keys(num_bits){return pow2(num_bits);}
   var
    one = Core_Int63[17],
    symbol$4 = Core_Int63[20],
    bit_not = Core_Int63[48],
    sexp_of_t$5 = Core_Int63[103],
    equal$1 = Core_Int63[113];
   function create$1(bits_per_slot){
    return caml_call1(bit_not, caml_call2(symbol$4, pow2(bits_per_slot), one));
   }
   var
    to_int_exn = Core_Int63[5],
    zero$0 = Core_Int63[16],
    one$0 = Core_Int63[17],
    symbol$5 = Core_Int63[19],
    symbol$6 = Core_Int63[21],
    succ = Core_Int63[42],
    pred = Core_Int63[43],
    max_value = Core_Int63[62],
    of_int$0 = Core_Int63[72],
    sexp_of_t$6 = Core_Int63[103],
    symbol$7 = Core_Int63[107],
    symbol$8 = Core_Int63[108],
    symbol$9 = Core_Int63[109],
    symbol$10 = Core_Int63[110],
    symbol$11 = Core_Int63[111],
    symbol$12 = Core_Int63[112],
    equal$2 = Core_Int63[113],
    compare$1 = Core_Int63[114],
    min = Core_Int63[115],
    max = Core_Int63[116],
    ascending = Core_Int63[117],
    descending = Core_Int63[118],
    between = Core_Int63[119],
    clamp_exn = Core_Int63[120],
    clamp = Core_Int63[121],
    Replace_polymorphic_compare = Core_Int63[122],
    comparator = Core_Int63[123],
    Map = Core_Int63[124],
    Set = Core_Int63[125],
    validate_lbound = Core_Int63[132],
    validate_ubound = Core_Int63[133],
    validate_bound = Core_Int63[134];
   function to_int63(t){return t;}
   function of_int63(i){return i;}
   function scale_int(t, i){
    return caml_call2(symbol$6, t, caml_call1(of_int$0, i));
   }
   var
    to_int_exn$0 = Core_Int63[5],
    zero$1 = Core_Int63[16],
    one$1 = Core_Int63[17],
    symbol$13 = Core_Int63[19],
    symbol$14 = Core_Int63[20],
    rem = Core_Int63[28],
    succ$0 = Core_Int63[42],
    pred$0 = Core_Int63[43],
    bit_and = Core_Int63[45],
    shift_right = Core_Int63[51],
    max_value$0 = Core_Int63[62],
    min_value$0 = Core_Int63[63],
    of_int$1 = Core_Int63[72],
    sexp_of_t$7 = Core_Int63[103],
    symbol$15 = Core_Int63[107],
    symbol$16 = Core_Int63[108],
    symbol$17 = Core_Int63[109],
    symbol$18 = Core_Int63[110],
    symbol$19 = Core_Int63[111],
    symbol$20 = Core_Int63[112],
    equal$3 = Core_Int63[113],
    compare$2 = Core_Int63[114],
    min$0 = Core_Int63[115],
    max$0 = Core_Int63[116],
    ascending$0 = Core_Int63[117],
    descending$0 = Core_Int63[118],
    between$0 = Core_Int63[119],
    clamp_exn$0 = Core_Int63[120],
    clamp$0 = Core_Int63[121],
    Replace_polymorphic_compare$0 = Core_Int63[122],
    comparator$0 = Core_Int63[123],
    Map$0 = Core_Int63[124],
    Set$0 = Core_Int63[125],
    hash_fold_t = Core_Int63[126],
    hash = Core_Int63[127],
    hashable = Core_Int63[128],
    Table = Core_Int63[129],
    Hash_set = Core_Int63[130],
    Hash_queue = Core_Int63[131],
    validate_lbound$0 = Core_Int63[132],
    validate_ubound$0 = Core_Int63[133],
    validate_bound$0 = Core_Int63[134];
   function of_int63$0(i){return i;}
   function to_int63$0(t){return t;}
   function add(t, i){return caml_call2(symbol$13, t, i);}
   function add_clamp_to_max(t, i){
    return caml_call2(symbol$18, t, caml_call2(symbol$14, max_value$0, i))
            ? max_value$0
            : caml_call2(symbol$13, t, i);
   }
   function sub(t, i){return caml_call2(symbol$14, t, i);}
   function diff(t1, t2){return caml_call2(symbol$14, t1, t2);}
   function min_key_in_same_slot(t, min_key_in_same_slot_mask){return caml_call2(bit_and, t, min_key_in_same_slot_mask);
   }
   var
    _w_ = Set$0[2],
    _x_ = Set$0[1],
    _z_ = Map$0[2],
    _A_ = Map$0[1],
    _C_ = Set[2],
    _D_ = Set[1],
    _E_ = Map[2],
    _F_ = Map[1],
    _G_ =
      [0,
       sexp_of_t$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       equal$2,
       compare$1,
       min,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       Replace_polymorphic_compare,
       [0,
        [0, _F_[9], _F_[10], _F_[11]],
        [0, _E_[9], _E_[10], _E_[11], _E_[12], _E_[13]],
        Map[3],
        Map[4],
        Map[5],
        Map[6],
        Map[7],
        Map[8],
        Map[9],
        Map[10],
        Map[11],
        Map[12],
        Map[13],
        Map[14],
        Map[15],
        Map[16],
        Map[17],
        Map[18],
        Map[19],
        Map[20],
        Map[21],
        Map[22],
        Map[23],
        Map[24],
        Map[25],
        Map[26],
        Map[27],
        Map[28],
        Map[29],
        Map[30],
        Map[31],
        Map[32],
        Map[33],
        Map[34],
        Map[35],
        Map[36],
        Map[37],
        Map[38],
        Map[39],
        Map[40],
        Map[41],
        Map[42],
        Map[43],
        Map[44],
        Map[45]],
       [0,
        [0, _D_[1], _D_[2], _D_[11]],
        [0, _C_[9], _C_[10], _C_[11], _C_[12], _C_[13]],
        Set[3],
        Set[4],
        Set[5],
        Set[6],
        Set[7],
        Set[8],
        Set[9],
        Set[10],
        Set[11],
        Set[12],
        Set[13],
        Set[14],
        Set[15],
        Set[16],
        Set[17],
        Set[18],
        Set[19],
        Set[20],
        Set[21],
        Set[22],
        Set[23],
        Set[24],
        Set[25],
        Set[26],
        Set[27],
        Set[28]],
       max,
       zero$0,
       one$0,
       max_value,
       of_int63,
       to_int63,
       of_int$0,
       to_int_exn,
       scale_int,
       pred,
       succ,
       symbol$5],
    _u_ =
      [0,
       Hash_set[1],
       Hash_set[2],
       Hash_set[3],
       Hash_set[4],
       Hash_set[5],
       Hash_set[6],
       Hash_set[7]],
    _v_ =
      [0,
       Table[1],
       Table[2],
       Table[3],
       Table[4],
       Table[5],
       Table[6],
       Table[7],
       Table[8],
       Table[9],
       Table[10],
       Table[11],
       Table[12],
       Table[13],
       Table[14],
       Table[15],
       Table[16],
       Table[17],
       Table[18]],
    _y_ =
      [0,
       [0, _x_[1], _x_[2], _x_[11]],
       [0, _w_[9], _w_[10], _w_[11], _w_[12], _w_[13]],
       Set$0[3],
       Set$0[4],
       Set$0[5],
       Set$0[6],
       Set$0[7],
       Set$0[8],
       Set$0[9],
       Set$0[10],
       Set$0[11],
       Set$0[12],
       Set$0[13],
       Set$0[14],
       Set$0[15],
       Set$0[16],
       Set$0[17],
       Set$0[18],
       Set$0[19],
       Set$0[20],
       Set$0[21],
       Set$0[22],
       Set$0[23],
       Set$0[24],
       Set$0[25],
       Set$0[26],
       Set$0[27],
       Set$0[28]],
    _B_ =
      [0,
       [0, _A_[9], _A_[10], _A_[11]],
       [0, _z_[9], _z_[10], _z_[11], _z_[12], _z_[13]],
       Map$0[3],
       Map$0[4],
       Map$0[5],
       Map$0[6],
       Map$0[7],
       Map$0[8],
       Map$0[9],
       Map$0[10],
       Map$0[11],
       Map$0[12],
       Map$0[13],
       Map$0[14],
       Map$0[15],
       Map$0[16],
       Map$0[17],
       Map$0[18],
       Map$0[19],
       Map$0[20],
       Map$0[21],
       Map$0[22],
       Map$0[23],
       Map$0[24],
       Map$0[25],
       Map$0[26],
       Map$0[27],
       Map$0[28],
       Map$0[29],
       Map$0[30],
       Map$0[31],
       Map$0[32],
       Map$0[33],
       Map$0[34],
       Map$0[35],
       Map$0[36],
       Map$0[37],
       Map$0[38],
       Map$0[39],
       Map$0[40],
       Map$0[41],
       Map$0[42],
       Map$0[43],
       Map$0[44],
       Map$0[45]];
   function sexp_of_pool_slots(of_a_033, x_034){
    function _e0_(_e5_){return sexp_of_pool_slots(of_a_033, _e5_);}
    var _e1_ = caml_call1(Tuple_pool[36][3][1], _e0_);
    function _e2_(_e4_){return sexp_of_pool_slots(of_a_033, _e4_);}
    var _e3_ = caml_call1(Tuple_pool[36][3][1], _e2_);
    return caml_call7
            (Tuple_pool[36][1][8],
             sexp_of_t$7,
             Core_Time_ns_alternate_sexp[98],
             of_a_033,
             Core[389],
             _e3_,
             _e1_,
             x_034);
   }
   function sexp_of_t$8(of_a_035, x_036){
    function _eY_(_eZ_){return sexp_of_pool_slots(of_a_035, _eZ_);}
    return caml_call2(Tuple_pool[36][3][1], _eY_, x_036);
   }
   var
    null$0 = Tuple_pool[36][3][4],
    null$1 = Tuple_pool[36][3][4],
    is_null = Tuple_pool[36][3][5],
    free = Tuple_pool[36][14];
   function key(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][3]);
   }
   function at(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][4]);
   }
   function value(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][5]);
   }
   function level_index(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][6]);
   }
   function prev(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][7]);
   }
   function set_prev(p, t, x){
    return caml_call4(Tuple_pool[36][33], p, t, Tuple_pool[36][2][7], x);
   }
   function next(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][8]);
   }
   function set_next(p, t, x){
    return caml_call4(Tuple_pool[36][33], p, t, Tuple_pool[36][2][8], x);
   }
   function is_valid(p, t){return caml_call2(Tuple_pool[36][6], p, t);}
   var grow = Tuple_pool[36][12], is_full = Tuple_pool[36][13];
   function of_external_exn(pool, t){
    if(is_valid(pool, t)) return t;
    var
     _eX_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_got_invalid_a);
    return caml_call1(Core[261], _eX_);
   }
   function link(pool, prev, next){
    set_next(pool, prev, next);
    return set_prev(pool, next, prev);
   }
   function iter(pool, first, f){
    var current = [0, first], continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return 0;
     var next$0 = next(pool, current[1]);
     caml_call1(f, current[1]);
     if(next$0 === first) continue$0[1] = 0; else current[1] = next$0;
    }
   }
   function min_alarm_time(pool, first, with_key){
    var
     min_alarm_time = [0, Core_Time_ns_alternate_sexp[37]],
     current = [0, first],
     continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return min_alarm_time[1];
     var next$0 = next(pool, current[1]);
     if(caml_call2(equal$3, key(pool, current[1]), with_key)){
      var _eV_ = min_alarm_time[1], _eW_ = at(pool, current[1]);
      min_alarm_time[1] =
       caml_call2(Core_Time_ns_alternate_sexp[108], _eW_, _eV_);
     }
     if(next$0 === first) continue$0[1] = 0; else current[1] = next$0;
    }
   }
   function slots(r){return r[11];}
   function max_allowed_key(r){return r[10];}
   function set_max_allowed_key(r, v){r[10] = v; return 0;}
   function min_allowed_key(r){return r[9];}
   function set_min_allowed_key(r, v){r[9] = v; return 0;}
   function length(r){return r[8];}
   function set_length(r, v){r[8] = v; return 0;}
   function diff_max_min_allowed_key(r){return r[7];}
   function min_key_in_same_slot_mask(r){return r[6];}
   function keys_per_slot(r){return r[5];}
   function bits_per_slot(r){return r[4];}
   function slots_mask(r){return r[3];}
   function bits(r){return r[2];}
   function index(r){return r[1];}
   function _M_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], v];
   }
   var
    _N_ = 0,
    slots$0 = [0, function(param){return 0;}, cst_slots, _N_, slots, _M_];
   function _O_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], v, r[11]];
   }
   var
    _P_ = [0, set_max_allowed_key],
    max_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_max_allowed_key,
       _P_,
       max_allowed_key,
       _O_];
   function _Q_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11]];
   }
   var
    _R_ = [0, set_min_allowed_key],
    min_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_min_allowed_key,
       _R_,
       min_allowed_key,
       _Q_];
   function _S_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11]];
   }
   var
    _T_ = [0, set_length],
    length$0 = [0, function(param){return 0;}, cst_length, _T_, length, _S_];
   function _U_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _V_ = 0,
    diff_max_min_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_diff_max_min_allowed_key,
       _V_,
       diff_max_min_allowed_key,
       _U_];
   function _W_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _X_ = 0,
    min_key_in_same_slot_mask$0 =
      [0,
       function(param){return 0;},
       cst_min_key_in_same_slot_mask,
       _X_,
       min_key_in_same_slot_mask,
       _W_];
   function _Y_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _Z_ = 0,
    keys_per_slot$0 =
      [0,
       function(param){return 0;},
       cst_keys_per_slot,
       _Z_,
       keys_per_slot,
       _Y_];
   function ___(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _$_ = 0,
    bits_per_slot$0 =
      [0,
       function(param){return 0;},
       cst_bits_per_slot,
       _$_,
       bits_per_slot,
       ___];
   function _aa_(r, v){
    return [0,
            r[1],
            r[2],
            v,
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _ab_ = 0,
    slots_mask$0 =
      [0, function(param){return 0;}, cst_slots_mask, _ab_, slots_mask, _aa_];
   function _ac_(r, v){
    return [0,
            r[1],
            v,
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _ad_ = 0,
    bits$0 = [0, function(param){return 0;}, cst_bits, _ad_, bits, _ac_];
   function _ae_(r, v){
    return [0,
            v,
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _af_ = 0,
    index$0 = [0, function(param){return 0;}, cst_index, _af_, index, _ae_];
   function sexp_of_t$9(of_a_044, param){
    var
     diff_max_min_allowed_key_058 = param[7],
     min_key_in_same_slot_mask_056 = param[6],
     keys_per_slot_054 = param[5],
     bits_per_slot_052 = param[4],
     slots_mask_050 = param[3],
     bits_048 = param[2],
     index_046 = param[1],
     length_060 = param[8],
     min_allowed_key_062 = param[9],
     max_allowed_key_064 = param[10],
     slots_066 = param[11],
     arg_067 = caml_call1(Sexplib0_Sexp_conv[23], slots_066),
     bnds_045 = [0, [1, [0, _ag_, [0, arg_067, 0]]], 0],
     arg_065 = caml_call1(sexp_of_t$7, max_allowed_key_064),
     bnds_045$0 = [0, [1, [0, _ah_, [0, arg_065, 0]]], bnds_045],
     arg_063 = caml_call1(sexp_of_t$7, min_allowed_key_062),
     bnds_045$1 = [0, [1, [0, _ai_, [0, arg_063, 0]]], bnds_045$0],
     arg_061 = caml_call1(Core[389], length_060),
     bnds_045$2 = [0, [1, [0, _aj_, [0, arg_061, 0]]], bnds_045$1],
     arg_059 = caml_call1(_G_[1], diff_max_min_allowed_key_058),
     bnds_045$3 = [0, [1, [0, _ak_, [0, arg_059, 0]]], bnds_045$2],
     arg_057 = caml_call1(sexp_of_t$5, min_key_in_same_slot_mask_056),
     bnds_045$4 = [0, [1, [0, _al_, [0, arg_057, 0]]], bnds_045$3],
     arg_055 = caml_call1(_G_[1], keys_per_slot_054),
     bnds_045$5 = [0, [1, [0, _am_, [0, arg_055, 0]]], bnds_045$4],
     arg_053 = caml_call1(sexp_of_t, bits_per_slot_052),
     bnds_045$6 = [0, [1, [0, _an_, [0, arg_053, 0]]], bnds_045$5],
     arg_051 = caml_call1(sexp_of_t$4, slots_mask_050),
     bnds_045$7 = [0, [1, [0, _ao_, [0, arg_051, 0]]], bnds_045$6],
     arg_049 = caml_call1(sexp_of_t, bits_048),
     bnds_045$8 = [0, [1, [0, _ap_, [0, arg_049, 0]]], bnds_045$7],
     arg_047 = caml_call1(Core[389], index_046),
     bnds_045$9 = [0, [1, [0, _aq_, [0, arg_047, 0]]], bnds_045$8];
    return [1, bnds_045$9];
   }
   function slot(t, key){
    var slots_mask = t[3], bits_per_slot = t[4];
    return caml_call1
            (to_int_exn$0,
             caml_call2
              (bit_and,
               caml_call2(shift_right, key, bits_per_slot),
               slots_mask));
   }
   function next_slot(t, slot){
    var t$0 = t[3];
    return (slot + 1 | 0) & caml_call1(Core_Int63[5], t$0);
   }
   function min_key_in_same_slot$0(t, key){
    return min_key_in_same_slot(key, t[6]);
   }
   function compute_min_allowed_key(t, prev_level_max_allowed_key){
    return caml_call2(equal$3, prev_level_max_allowed_key, max_value$0)
            ? max_value$0
            : min_key_in_same_slot$0
              (t, caml_call1(succ$0, prev_level_max_allowed_key));
   }
   function levels(r){return r[5];}
   function elt_key_lower_bound(r){return r[4];}
   function set_elt_key_lower_bound(r, v){r[4] = v; return 0;}
   function min_elt(r){return r[3];}
   function set_min_elt(r, v){r[3] = v; return 0;}
   function pool(r){return r[2];}
   function set_pool(r, v){r[2] = v; return 0;}
   function length$1(r){return r[1];}
   function set_length$0(r, v){r[1] = v; return 0;}
   function _ar_(r, v){return [0, r[1], r[2], r[3], r[4], v];}
   var
    _as_ = 0,
    levels$0 = [0, function(param){return 0;}, cst_levels, _as_, levels, _ar_];
   function _at_(r, v){return [0, r[1], r[2], r[3], v, r[5]];}
   var
    _au_ = [0, set_elt_key_lower_bound],
    elt_key_lower_bound$0 =
      [0,
       function(param){return 0;},
       cst_elt_key_lower_bound,
       _au_,
       elt_key_lower_bound,
       _at_];
   function _av_(r, v){return [0, r[1], r[2], v, r[4], r[5]];}
   var
    _aw_ = [0, set_min_elt],
    min_elt$0 =
      [0, function(param){return 0;}, cst_min_elt, _aw_, min_elt, _av_];
   function _ax_(r, v){return [0, r[1], v, r[3], r[4], r[5]];}
   var
    _ay_ = [0, set_pool],
    pool$0 = [0, function(param){return 0;}, cst_pool, _ay_, pool, _ax_];
   function _az_(r, v){return [0, v, r[2], r[3], r[4], r[5]];}
   var
    _aA_ = [0, set_length$0],
    length$2 =
      [0, function(param){return 0;}, cst_length$0, _aA_, length$1, _az_];
   function is_empty(t){return caml_call2(Core[90], t[1], 0);}
   function num_levels(t){return t[5].length - 1;}
   function min_allowed_key$1(t){return caml_check_bound(t[5], 0)[1][9];}
   function max_allowed_key$1(t){
    var _eU_ = num_levels(t) - 1 | 0;
    return caml_check_bound(t[5], _eU_)[1 + _eU_][10];
   }
   function internal_iter(t, f){
    var _eM_ = caml_call2(Core[91], t[1], 0);
    if(_eM_){
     var
      pool = t[2],
      levels = t[5],
      _eO_ = levels.length - 1 - 1 | 0,
      _eN_ = 0;
     if(_eO_ >= 0){
      var level_index = _eN_;
      for(;;){
       var level = caml_check_bound(levels, level_index)[1 + level_index];
       if(caml_call2(Core[91], level[8], 0)){
        var slots = level[11], _eR_ = slots.length - 1 - 1 | 0, _eQ_ = 0;
        if(_eR_ >= 0){
         var slot_index = _eQ_;
         for(;;){
          var elt = caml_check_bound(slots, slot_index)[1 + slot_index];
          if(1 - caml_call1(is_null, elt)) iter(pool, elt, f);
          var _eT_ = slot_index + 1 | 0;
          if(_eR_ === slot_index) break;
          var slot_index = _eT_;
         }
        }
       }
       var _eS_ = level_index + 1 | 0;
       if(_eO_ === level_index) break;
       var level_index = _eS_;
      }
     }
     var _eP_ = 0;
    }
    else
     var _eP_ = _eM_;
    return _eP_;
   }
   function compute_diff_max_min_allowed_k(level_bits, bits_per_slot){
    var bits = symbol$2(level_bits, bits_per_slot);
    if(caml_call2(equal, bits, max_num_bits)) return _G_[26];
    var _eL_ = num_keys(bits);
    return caml_call1(_G_[32], _eL_);
   }
   function min_elt$1(t){
    if(is_empty(t)) return caml_call1(null$1, 0);
    if(! caml_call1(is_null, t[3])) return t[3];
    var
     pool = t[2],
     min_elt_already_found = [0, caml_call1(null$1, 0)],
     min_key_already_found = [0, max_value$0],
     level_index = [0, 0],
     num_levels$0 = num_levels(t);
    for(;;){
     if(! caml_call2(Core[92], level_index[1], num_levels$0)){
      t[3] = min_elt_already_found[1];
      t[4] = min_key_already_found[1];
      return t[3];
     }
     var
      _eI_ = level_index[1],
      level = caml_check_bound(t[5], _eI_)[1 + _eI_];
     if(caml_call2(symbol$18, level[9], min_key_already_found[1]))
      level_index[1] = num_levels$0;
     else if(caml_call2(Core[90], level[8], 0))
      level_index[1]++;
     else{
      var
       slots = level[11],
       slot_min_key =
         [0, min_key_in_same_slot$0(level, caml_call2(max$0, level[9], t[4]))],
       slot$0 = [0, slot(level, slot_min_key[1])];
      for(;;){
       var _eJ_ = slot$0[1];
       if(! caml_call1(is_null, caml_check_bound(slots, _eJ_)[1 + _eJ_]))
        break;
       if(! caml_call2(symbol$19, slot_min_key[1], min_key_already_found[1]))
        break;
       slot$0[1] = next_slot(level, slot$0[1]);
       slot_min_key[1] = add(slot_min_key[1], level[5]);
      }
      var _eK_ = slot$0[1], first = caml_check_bound(slots, _eK_)[1 + _eK_];
      if(1 - caml_call1(is_null, first)){
       var continue$0 = [0, 1], current = [0, first];
       for(;;){
        if(! continue$0[1]) break;
        var current_key = key(pool, current[1]);
        if(caml_call2(symbol$16, current_key, min_key_already_found[1])){
         min_elt_already_found[1] = current[1];
         min_key_already_found[1] = current_key;
        }
        var next$0 = next(pool, current[1]);
        a:
        {
         if(next$0 !== first && ! caml_call2(Core[90], level_index[1], 0)){current[1] = next$0; break a;}
         continue$0[1] = 0;
        }
       }
      }
      level_index[1]++;
     }
    }
   }
   function add_elt(x_114, to_add){
    var
     pool$0 = x_114[2],
     key$0 = key(pool$0, to_add),
     _eB_ = caml_call2(symbol$15, key$0, min_allowed_key$1(x_114)),
     _eC_ =
       _eB_ ? caml_call2(symbol$16, key$0, max_allowed_key$1(x_114)) : _eB_;
    if(1 - _eC_){
     var pool = x_114[2], r = [0, 0], _eq_ = 0, _er_ = 0;
     internal_iter
      (x_114,
       function(elt){
        var _eG_ = r[1], _eH_ = value(pool, elt);
        r[1] = [0, [0, key(pool, elt), _eH_], _eG_];
        return 0;
       });
     var
      elts_094 = caml_call1(Core_List[59], r[1]),
      max_allowed_key_092 = max_allowed_key$1(x_114),
      min_allowed_key_090 = min_allowed_key$1(x_114),
      bnds_089 = 0,
      _ep_ =
        function(param){
         var
          key_084 = param[1],
          bnds_083 = [0, [1, [0, _aG_, [0, arg_087, 0]]], 0],
          arg_085 = caml_call1(sexp_of_t$7, key_084),
          bnds_083$0 = [0, [1, [0, _aH_, [0, arg_085, 0]]], bnds_083];
         return [1, bnds_083$0];
        },
      arg_095 = caml_call2(Core[472], _ep_, elts_094),
      bnds_089$0 = [0, [1, [0, _aI_, [0, arg_095, 0]]], bnds_089],
      arg_093 = caml_call1(sexp_of_t$7, max_allowed_key_092),
      bnds_089$1 = [0, [1, [0, _aJ_, [0, arg_093, 0]]], bnds_089$0],
      arg_091 = caml_call1(sexp_of_t$7, min_allowed_key_090),
      bnds_089$2 = [0, [1, [0, _aK_, [0, arg_091, 0]]], bnds_089$1],
      _es_ =
        [0,
         [1,
          [0, _a__, [0, caml_call1(sexp_of_t$7, max_allowed_key$1(x_114)), 0]]],
         [0, [1, [0, _a9_, [0, [1, bnds_089$2], _er_]]], _eq_]],
      _et_ =
        [0,
         [1,
          [0, _a$_, [0, caml_call1(sexp_of_t$7, min_allowed_key$1(x_114)), 0]]],
         _es_],
      _eu_ = [0, [1, [0, _ba_, [0, caml_call1(sexp_of_t$7, key$0), 0]]], _et_],
      _ev_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Priority_queue_add_elt_key),
          _eu_]];
     caml_call1(Core[261], _ev_);
    }
    var level_index = [0, 0];
    for(;;){
     var _eD_ = level_index[1];
     if
      (!
       caml_call2
        (symbol$18, key$0, caml_check_bound(x_114[5], _eD_)[1 + _eD_][10]))
      break;
     level_index[1]++;
    }
    var
     level_index$0 = level_index[1],
     level = caml_check_bound(x_114[5], level_index$0)[1 + level_index$0],
     _eE_ = caml_call2(symbol$15, key$0, level[9]),
     _eF_ = _eE_ ? caml_call2(symbol$16, key$0, level[10]) : _eE_;
    if(1 - _eF_){
     var
      _ew_ = 0,
      _ex_ = 0,
      _ey_ =
        [0,
         [1,
          [0,
           _bc_,
           [0, sexp_of_t$9(function(param){return _bb_;}, level), _ex_]]],
         _ew_],
      _ez_ = [0, [1, [0, _bd_, [0, caml_call1(sexp_of_t$7, key$0), 0]]], _ey_],
      _eA_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Priority_queue_add_elt_key$0),
          _ez_]];
     caml_call1(Core[261], _eA_);
    }
    level[8] = level[8] + 1 | 0;
    caml_call4
     (Tuple_pool[36][33], pool$0, to_add, Tuple_pool[36][2][6], level_index$0);
    var
     slot$0 = slot(level, key$0),
     slots = level[11],
     first = caml_check_bound(slots, slot$0)[1 + slot$0];
    if(caml_call1(is_null, first)){
     caml_check_bound(slots, slot$0)[1 + slot$0] = to_add;
     return link(pool$0, to_add, to_add);
    }
    var prev$0 = prev(pool$0, first);
    link(pool$0, prev$0, to_add);
    return link(pool$0, to_add, first);
   }
   function internal_add_elt(t, elt){
    var key$0 = key(t[2], elt);
    if(caml_call2(symbol$19, key$0, t[4])){t[3] = elt; t[4] = key$0;}
    add_elt(t, elt);
    t[1] = t[1] + 1 | 0;
    return 0;
   }
   function ensure_valid_key(t, key){
    var
     _en_ = caml_call2(symbol$19, key, min_allowed_key$1(t)),
     _eo_ = _en_ || caml_call2(symbol$18, key, max_allowed_key$1(t));
    if(! _eo_) return _eo_;
    var
     _ej_ =
       [0,
        [1, [0, _be_, [0, caml_call1(sexp_of_t$7, max_allowed_key$1(t)), 0]]],
        0],
     _ek_ =
       [0,
        [1, [0, _bf_, [0, caml_call1(sexp_of_t$7, min_allowed_key$1(t)), 0]]],
        _ej_],
     _el_ = [0, [1, [0, _bg_, [0, caml_call1(sexp_of_t$7, key), 0]]], _ek_],
     _em_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_add_at_interv),
         _el_]];
    return caml_call1(Core[261], _em_);
   }
   function internal_add(t, key, at, value){
    ensure_valid_key(t, key);
    if(caml_call1(is_full, t[2])) t[2] = caml_call2(grow, 0, t[2]);
    var
     pool = t[2],
     _eh_ = caml_call1(null$1, 0),
     _ei_ = caml_call1(null$1, 0),
     elt =
       caml_call7(Tuple_pool[36][21], pool, key, at, value, -1, _ei_, _eh_);
    internal_add_elt(t, elt);
    return elt;
   }
   function internal_remove(t, elt){
    var pool = t[2], t2 = t[3];
    if(caml_call2(Tuple_pool[36][3][7], elt, t2))
     t[3] = caml_call1(null$1, 0);
    t[1] = t[1] - 1 | 0;
    var
     _ee_ = level_index(pool, elt),
     level = caml_check_bound(t[5], _ee_)[1 + _ee_];
    level[8] = level[8] - 1 | 0;
    var
     slots = level[11],
     slot$0 = slot(level, key(pool, elt)),
     first = caml_check_bound(slots, slot$0)[1 + slot$0];
    if(elt === next(pool, elt)){
     var _ef_ = caml_call1(null$1, 0);
     caml_check_bound(slots, slot$0)[1 + slot$0] = _ef_;
     return;
    }
    if(elt === first){
     var _eg_ = next(pool, elt);
     caml_check_bound(slots, slot$0)[1 + slot$0] = _eg_;
    }
    var _ec_ = next(pool, elt);
    set_next(pool, prev(pool, elt), _ec_);
    var _ed_ = prev(pool, elt);
    return set_prev(pool, next(pool, elt), _ed_);
   }
   var
    _bh_ =
      [0,
       _G_,
       sexp_of_t$7,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       symbol$19,
       symbol$20,
       equal$3,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       validate_lbound$0,
       validate_ubound$0,
       validate_bound$0,
       Replace_polymorphic_compare$0,
       _B_,
       _y_,
       compare$2,
       hash_fold_t,
       hash,
       hashable,
       _v_,
       _u_,
       Hash_queue,
       max$0,
       min$0,
       zero$1,
       one$1,
       min_value$0,
       max_value$0,
       of_int63$0,
       to_int63$0,
       of_int$1,
       to_int_exn$0,
       add,
       sub,
       diff,
       succ$0,
       pred$0,
       rem],
    min_interval_num = _bh_[31];
   function priority_queue(r){return r[7];}
   function max_allowed_alarm_time(r){return r[6];}
   function set_max_allowed_alarm_time(r, v){r[6] = v; return 0;}
   function now_interval_num_start(r){return r[5];}
   function set_now_interval_num_start(r, v){r[5] = v; return 0;}
   function now(r){return r[4];}
   function set_now(r, v){r[4] = v; return 0;}
   function max_interval_num(r){return r[3];}
   function start(r){return r[2];}
   function config(r){return r[1];}
   function _bi_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], r[6], v];}
   var
    _bj_ = 0,
    priority_queue$0 =
      [0,
       function(param){return 0;},
       cst_priority_queue,
       _bj_,
       priority_queue,
       _bi_];
   function _bk_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v, r[7]];}
   var
    _bl_ = [0, set_max_allowed_alarm_time],
    max_allowed_alarm_time$0 =
      [0,
       function(param){return 0;},
       cst_max_allowed_alarm_time,
       _bl_,
       max_allowed_alarm_time,
       _bk_];
   function _bm_(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6], r[7]];}
   var
    _bn_ = [0, set_now_interval_num_start],
    now_interval_num_start$0 =
      [0,
       function(param){return 0;},
       cst_now_interval_num_start,
       _bn_,
       now_interval_num_start,
       _bm_];
   function _bo_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6], r[7]];}
   var
    _bp_ = [0, set_now],
    now$0 = [0, function(param){return 0;}, cst_now, _bp_, now, _bo_];
   function _bq_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6], r[7]];}
   var
    _br_ = 0,
    max_interval_num$0 =
      [0,
       function(param){return 0;},
       cst_max_interval_num,
       _br_,
       max_interval_num,
       _bq_];
   function _bs_(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6], r[7]];}
   var
    _bt_ = 0,
    start$0 = [0, function(param){return 0;}, cst_start, _bt_, start, _bs_];
   function _bu_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6], r[7]];}
   var
    _bv_ = 0,
    config$0 = [0, function(param){return 0;}, cst_config, _bv_, config, _bu_];
   function sexp_of_t_now(param, t){
    return caml_call1(Core_Time_ns_alternate_sexp[98], t[4]);
   }
   function alarm_precision$0(t){return alarm_precision(t[1]);}
   function at$0(tw, t){
    var p = tw[7], _eb_ = of_external_exn(p[2], t);
    return at(p[2], _eb_);
   }
   function value$0(tw, t){
    var p = tw[7], _ea_ = of_external_exn(p[2], t);
    return value(p[2], _ea_);
   }
   function interval_num(tw, t){
    var p = tw[7], _d$_ = of_external_exn(p[2], t);
    return key(p[2], _d$_);
   }
   function iter$0(t, f){var t$0 = t[7]; return internal_iter(t$0, f);}
   function compare$3(t1, t2){
    return caml_call2(Core_Time_ns_alternate_sexp[107], t1[1], t2[1]);
   }
   function sexp_of_t$10(sexp_of_a, t){
    var
     max_interval_num_146 = t[3],
     start_144 = t[2],
     config_142 = t[1],
     now_148 = t[4],
     r = [0, 0];
    iter$0
     (t,
      function(alarm){
       var _d__ = r[1], _d9_ = value$0(t, alarm);
       r[1] = [0, [0, at$0(t, alarm), _d9_], _d__];
       return 0;
      });
    var alarms_150 = caml_call2(Core_List[79], r[1], compare$3), bnds_141 = 0;
    function _d8_(param){
     var
      value_138 = param[2],
      at_136 = param[1],
      arg_139 = caml_call1(sexp_of_a, value_138),
      bnds_135 = [0, [1, [0, _bw_, [0, arg_139, 0]]], 0],
      arg_137 = caml_call1(Core_Time_ns_alternate_sexp[98], at_136),
      bnds_135$0 = [0, [1, [0, _bx_, [0, arg_137, 0]]], bnds_135];
     return [1, bnds_135$0];
    }
    var
     arg_151 = caml_call2(Core[472], _d8_, alarms_150),
     bnds_141$0 = [0, [1, [0, _by_, [0, arg_151, 0]]], bnds_141],
     arg_149 = caml_call1(Core_Time_ns_alternate_sexp[98], now_148),
     bnds_141$1 = [0, [1, [0, _bz_, [0, arg_149, 0]]], bnds_141$0],
     arg_147 = caml_call1(_bh_[2], max_interval_num_146),
     bnds_141$2 = [0, [1, [0, _bA_, [0, arg_147, 0]]], bnds_141$1],
     arg_145 = caml_call1(Core_Time_ns_alternate_sexp[98], start_144),
     bnds_141$3 = [0, [1, [0, _bB_, [0, arg_145, 0]]], bnds_141$2],
     arg_143 = sexp_of_t$3(config_142),
     bnds_141$4 = [0, [1, [0, _bC_, [0, arg_143, 0]]], bnds_141$3];
    return [1, bnds_141$4];
   }
   function length$3(t){return t[7][1];}
   function is_empty$0(t){
    var _d7_ = length$3(t);
    return caml_call2(Core[90], _d7_, 0);
   }
   function pool$1(t){return t[7][2];}
   function interval_num_internal(time, alarm_precision){
    var
     _d5_ = caml_call1(Core_Time_ns_alternate_sexp[53], time),
     _d6_ = caml_call2(Core_Int63[51], _d5_, alarm_precision);
    return caml_call1(_bh_[35], _d6_);
   }
   function interval_num_unchecked(t, time){
    return interval_num_internal(time, t[1][1]);
   }
   function interval_num$0(t, time){
    if(caml_call2(Core_Time_ns_alternate_sexp[104], time, min_time)){
     var
      _d3_ =
        [0,
         [1,
          [0, _bH_, [0, caml_call1(Core_Time_ns_alternate_sexp[98], time), 0]]],
         0],
      _d4_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_),
          _d3_]];
     caml_call1(Core[261], _d4_);
    }
    return interval_num_unchecked(t, time);
   }
   function interval_num_start_unchecked(t, interval_num){
    var
     interval_num$0 = caml_call1(_bh_[36], interval_num),
     t$0 = t[1][1],
     _d2_ = caml_call2(Core_Int63[50], interval_num$0, t$0);
    return caml_call1(Core_Time_ns_alternate_sexp[54], _d2_);
   }
   function interval_num_start(t, interval_num){
    if(caml_call2(_bh_[7], interval_num, min_interval_num)){
     var
      _dW_ =
        [0, [1, [0, _bI_, [0, caml_call1(_bh_[2], min_interval_num), 0]]], 0],
      _dX_ =
        [0, [1, [0, _bJ_, [0, caml_call1(_bh_[2], interval_num), 0]]], _dW_],
      _dY_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_$0),
          _dX_]];
     caml_call1(Core[261], _dY_);
    }
    if(caml_call2(_bh_[6], interval_num, t[3])){
     var
      _dZ_ = [0, [1, [0, _bK_, [0, caml_call1(_bh_[2], t[3]), 0]]], 0],
      _d0_ =
        [0, [1, [0, _bL_, [0, caml_call1(_bh_[2], interval_num), 0]]], _dZ_],
      _d1_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_$1),
          _d0_]];
     caml_call1(Core[261], _d1_);
    }
    return interval_num_start_unchecked(t, interval_num);
   }
   function next_alarm_fires_at_internal(t, key){
    return interval_num_start(t, caml_call1(_bh_[42], key));
   }
   function next_alarm_fires_at(t){
    var elt = min_elt$1(t[7]);
    if(caml_call1(is_null, elt)) return 0;
    var key$0 = key(pool$1(t), elt);
    return caml_call2(_bh_[9], key$0, t[3])
            ? 0
            : [0, next_alarm_fires_at_internal(t, key$0)];
   }
   function next_alarm_fires_at_exn(x_153){
    var elt = min_elt$1(x_153[7]);
    if(caml_call1(is_null, elt)){
     var
      _dO_ = 0,
      _dP_ = 0,
      _dQ_ =
        [0,
         [1,
          [0,
           _bE_,
           [0, sexp_of_t$10(function(param){return _bD_;}, x_153), _dP_]]],
         _dO_],
      _dR_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_next_alarm_fi),
          _dQ_]];
     caml_call1(Core[261], _dR_);
    }
    var key$0 = key(pool$1(x_153), elt);
    if(caml_call2(_bh_[9], key$0, x_153[3])){
     var
      _dS_ = 0,
      _dT_ = 0,
      _dU_ =
        [0,
         [1,
          [0,
           _bG_,
           [0, sexp_of_t$10(function(param){return _bF_;}, x_153), _dT_]]],
         _dS_],
      _dV_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_next_alarm_fi$0),
          _dU_]];
     caml_call1(Core[261], _dV_);
    }
    return next_alarm_fires_at_internal(x_153, key$0);
   }
   function compute_max_allowed_alarm_time(t){
    var max_allowed_key = max_allowed_key$1(t[7]);
    if(caml_call2(_bh_[3], max_allowed_key, t[3])) return max_time;
    var
     _dK_ = Core_Time_ns[1][68],
     _dL_ = alarm_precision$0(t),
     _dM_ = caml_call2(Core_Time_ns[1][102], _dL_, _dK_),
     _dN_ = interval_num_start_unchecked(t, max_allowed_key);
    return caml_call2(Core_Time_ns_alternate_sexp[43], _dN_, _dM_);
   }
   function now_interval_num(t){return min_allowed_key$1(t[7]);}
   function max_allowed_alarm_interval_num(t){return interval_num$0(t, t[6]);}
   function interval_start(t, time){
    return interval_num_start_unchecked(t, interval_num$0(t, time));
   }
   function invariant$2(invariant_a, t){
    function _c5_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      priority_queue_fun =
        check
         (function(t){
           var pool = t[2];
           function _de_(param){
            function check(f){return caml_call2(Base_Invariant[2], t, f);}
            if(! caml_call2(symbol$15, min_allowed_key$1(t), zero$1))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _a6_], 1);
            var _dk_ = min_allowed_key$1(t);
            if(! caml_call2(symbol$15, max_allowed_key$1(t), _dk_))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _a5_], 1);
            var
             levels_fun =
               check
                (function(levels){
                  var _dq_ = num_levels(t);
                  if(! caml_call2(Core[91], _dq_, 0))
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _aY_], 1);
                  function _dr_(level_index$0, level){
                   if(! caml_call2(Core[90], level_index$0, level[1]))
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _aX_], 1);
                   function _ds_(param){
                    function check(f){
                     return caml_call2(Base_Invariant[2], level, f);
                    }
                    var
                     slots_fun =
                       check
                        (function(slots){
                          function _dz_(elt){
                           var _dC_ = 1 - caml_call1(is_null, elt);
                           if(! _dC_) return _dC_;
                           function _dA_(param){
                            if(! is_valid(pool, elt))
                             throw caml_maybe_attach_backtrace
                                    ([0, Assert_failure, _J_], 1);
                            caml_call1(invariant_a, value(pool, elt));
                            var n = next(pool, elt);
                            if(! caml_call1(is_null, n)){
                             var _dJ_ = prev(pool, n);
                             if(! caml_call2(Tuple_pool[36][3][7], elt, _dJ_))
                              throw caml_maybe_attach_backtrace
                                     ([0, Assert_failure, _I_], 1);
                            }
                            var p = prev(pool, elt);
                            if(! caml_call1(is_null, p)){
                             var _dI_ = next(pool, p);
                             if(! caml_call2(Tuple_pool[36][3][7], elt, _dI_))
                              throw caml_maybe_attach_backtrace
                                     ([0, Assert_failure, _H_], 1);
                            }
                            return 0;
                           }
                           function _dB_(x_041){
                            return sexp_of_t$8(function(param){return _K_;}, x_041);
                           }
                           caml_call4(Base_Invariant[1], _L_, elt, _dB_, _dA_);
                           return iter
                                   (pool,
                                    elt,
                                    function(elt){
                                     var _dD_ = level[9];
                                     if(! caml_call2(symbol$15, key(pool, elt), _dD_))
                                      throw caml_maybe_attach_backtrace
                                             ([0, Assert_failure, _aO_], 1);
                                     var _dE_ = level[10];
                                     if(! caml_call2(symbol$16, key(pool, elt), _dE_))
                                      throw caml_maybe_attach_backtrace
                                             ([0, Assert_failure, _aN_], 1);
                                     var _dF_ = t[4];
                                     if(! caml_call2(symbol$15, key(pool, elt), _dF_))
                                      throw caml_maybe_attach_backtrace
                                             ([0, Assert_failure, _aM_], 1);
                                     var _dG_ = level[1], _dH_ = level_index(pool, elt);
                                     if(caml_call2(Core[90], _dH_, _dG_))
                                      return caml_call1(invariant_a, value(pool, elt));
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _aL_], 1);
                                    });
                          }
                          return caml_call2(Core_Array[35], slots, _dz_);
                         }),
                     max_allowed_key_fun =
                       check
                        (function(max_allowed_key){
                          var
                           expect = add_clamp_to_max(level[9], level[7]),
                           equal = 0,
                           message = 0,
                           here = 0;
                          function comparator(a_107, b_108){
                           return caml_call2(compare$2, a_107, b_108);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos,
                                   sexp_of_t$7,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect,
                                   max_allowed_key);
                         }),
                     min_allowed_key_fun =
                       check
                        (function(min_allowed_key){
                          if(! caml_call2(symbol$15, min_allowed_key, zero$1))
                           throw caml_maybe_attach_backtrace
                                  ([0, Assert_failure, _aP_], 1);
                          var
                           _dy_ = caml_call2(symbol$19, min_allowed_key, max_value$0);
                          if(! _dy_) return _dy_;
                          var
                           got = caml_call2(rem, min_allowed_key, level[5]),
                           expect = _G_[24],
                           sexpifier = _G_[1],
                           equal = 0,
                           message = 0,
                           here = 0;
                          function comparator(a_105, b_106){
                           return caml_call2(_G_[9], a_105, b_106);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos$0,
                                   sexpifier,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect,
                                   got);
                         }),
                     length_fun =
                       check
                        (function(length){
                          function _dw_(n, first){
                           if(caml_call1(is_null, first)) return n;
                           var r = [0, 0], current = [0, first], continue$0 = [0, 1];
                           for(;;){
                            if(! continue$0[1]) return n + r[1] | 0;
                            r[1]++;
                            var next$0 = next(pool, current[1]);
                            if(next$0 === first)
                             continue$0[1] = 0;
                            else
                             current[1] = next$0;
                           }
                          }
                          var _dx_ = caml_call3(Core_Array[36], level[11], 0, _dw_);
                          if(caml_call2(Core[90], length, _dx_)) return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aQ_], 1);
                         }),
                     expect = compute_diff_max_min_allowed_k(level[2], level[4]),
                     diff_max_min_allowed_key_fun =
                       check
                        (function(eta){
                          var sexpifier = _G_[1], equal = 0, message = 0, here = 0;
                          function comparator(a_103, b_104){
                           return caml_call2(_G_[9], a_103, b_104);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos$1,
                                   sexpifier,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect,
                                   eta);
                         }),
                     min_key_in_same_slot_mask_fun =
                       check
                        (function(min_key_in_same_slot_mask){
                          if
                           (caml_call2
                             (equal$1, min_key_in_same_slot_mask, create$1(level[4])))
                           return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aR_], 1);
                         }),
                     keys_per_slot_fun =
                       check
                        (function(keys_per_slot){
                          var
                           expect = num_keys(level[4]),
                           sexpifier = _G_[1],
                           equal = 0,
                           message = 0,
                           here = 0;
                          function comparator(a_101, b_102){
                           return caml_call2(_G_[9], a_101, b_102);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos$2,
                                   sexpifier,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect,
                                   keys_per_slot);
                         }),
                     bits_per_slot_fun =
                       check
                        (function(bits_per_slot){
                          if(caml_call2(symbol, bits_per_slot, zero)) return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aS_], 1);
                         }),
                     expect$0 = create$0(level[2]),
                     slots_mask_fun =
                       check
                        (function(eta){
                          var equal = 0, message = 0, here = 0;
                          function comparator(a_099, b_100){
                           return caml_call2(compare$0, a_099, b_100);
                          }
                          return caml_call8
                                  (Ppx_assert_lib_Runtime[3],
                                   pos$3,
                                   sexp_of_t$4,
                                   comparator,
                                   here,
                                   message,
                                   equal,
                                   expect$0,
                                   eta);
                         }),
                     bits_fun =
                       check
                        (function(bits){
                          if(caml_call2(symbol$1, bits, zero)) return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aT_], 1);
                         }),
                     index_fun =
                       check
                        (function(index){
                          if(caml_call2(Core[88], index, 0)) return 0;
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _aU_], 1);
                         });
                    caml_call1(index_fun, index$0);
                    caml_call1(bits_fun, bits$0);
                    caml_call1(slots_mask_fun, slots_mask$0);
                    caml_call1(bits_per_slot_fun, bits_per_slot$0);
                    caml_call1(keys_per_slot_fun, keys_per_slot$0);
                    caml_call1
                     (min_key_in_same_slot_mask_fun, min_key_in_same_slot_mask$0);
                    caml_call1
                     (diff_max_min_allowed_key_fun, diff_max_min_allowed_key$0);
                    caml_call1(length_fun, length$0);
                    caml_call1(min_allowed_key_fun, min_allowed_key$0);
                    caml_call1(max_allowed_key_fun, max_allowed_key$0);
                    return caml_call1(slots_fun, slots$0);
                   }
                   function _dt_(x_098){
                    return sexp_of_t$9(function(param){return _aV_;}, x_098);
                   }
                   caml_call4(Base_Invariant[1], _aW_, level, _dt_, _ds_);
                   var _du_ = caml_call2(Core[91], level_index$0, 0);
                   if(! _du_) return _du_;
                   var
                    _dv_ = level_index$0 - 1 | 0,
                    prev_level = caml_check_bound(levels, _dv_)[1 + _dv_],
                    got = level[5],
                    expect = caml_call1(_G_[33], prev_level[7]),
                    sexpifier = _G_[1],
                    equal = 0,
                    message = 0,
                    here = 0;
                   function comparator(a_110, b_111){
                    return caml_call2(_G_[9], a_110, b_111);
                   }
                   caml_call8
                    (Ppx_assert_lib_Runtime[3],
                     pos$4,
                     sexpifier,
                     comparator,
                     here,
                     message,
                     equal,
                     expect,
                     got);
                   var
                    got$0 = level[9],
                    expect$0 = compute_min_allowed_key(level, prev_level[10]),
                    equal$0 = 0,
                    message$0 = 0,
                    here$0 = 0;
                   function comparator$0(a_112, b_113){
                    return caml_call2(compare$2, a_112, b_113);
                   }
                   return caml_call8
                           (Ppx_assert_lib_Runtime[3],
                            pos$5,
                            sexp_of_t$7,
                            comparator$0,
                            here$0,
                            message$0,
                            equal$0,
                            expect$0,
                            got$0);
                  }
                  return caml_call2(Core_Array[50], levels, _dr_);
                 }),
             elt_key_lower_bound_fun =
               check
                (function(elt_key_lower_bound){
                  if
                   (!
                    caml_call2
                     (symbol$15, elt_key_lower_bound, min_allowed_key$1(t)))
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _a1_], 1);
                  if
                   (!
                    caml_call2
                     (symbol$16, elt_key_lower_bound, max_allowed_key$1(t)))
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _a0_], 1);
                  var _dp_ = 1 - caml_call1(is_null, t[3]);
                  if(! _dp_) return _dp_;
                  if
                   (caml_call2(equal$3, elt_key_lower_bound, key(t[2], t[3])))
                   return 0;
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _aZ_], 1);
                 }),
             min_elt_fun =
               check
                (function(elt){
                  var _dn_ = 1 - caml_call1(is_null, elt);
                  if(! _dn_) return _dn_;
                  if(! is_valid(t[2], elt))
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _a3_], 1);
                  var _do_ = key(t[2], elt);
                  if(caml_call2(equal$3, t[4], _do_)) return 0;
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _a2_], 1);
                 }),
             pool_fun =
               check
                (function(t){
                  function _dl_(_dm_){return 0;}
                  return caml_call2(Tuple_pool[36][5], _dl_, t);
                 }),
             length_fun =
               check
                (function(length){
                  if(caml_call2(Core[88], length, 0)) return 0;
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _a4_], 1);
                 });
            caml_call1(length_fun, length$2);
            caml_call1(pool_fun, pool$0);
            caml_call1(min_elt_fun, min_elt$0);
            caml_call1(elt_key_lower_bound_fun, elt_key_lower_bound$0);
            return caml_call1(levels_fun, levels$0);
           }
           function _df_(x_109){
            function of_a_068(param){return _a7_;}
            var
             length_070 = x_109[1],
             pool_072 = x_109[2],
             min_elt_074 = x_109[3],
             elt_key_lower_bound_076 = x_109[4],
             levels_078 = x_109[5],
             bnds_069 = 0;
            function _dh_(_dj_){return sexp_of_t$9(of_a_068, _dj_);}
            var
             arg_079 = caml_call2(Core[301], _dh_, levels_078),
             bnds_069$0 = [0, [1, [0, _aB_, [0, arg_079, 0]]], bnds_069],
             arg_077 = caml_call1(sexp_of_t$7, elt_key_lower_bound_076),
             bnds_069$1 = [0, [1, [0, _aC_, [0, arg_077, 0]]], bnds_069$0],
             arg_075 = sexp_of_t$8(of_a_068, min_elt_074),
             bnds_069$2 = [0, [1, [0, _aD_, [0, arg_075, 0]]], bnds_069$1];
            function _dg_(_di_){return sexp_of_pool_slots(of_a_068, _di_);}
            var
             arg_073 = caml_call2(Tuple_pool[36][4], _dg_, pool_072),
             bnds_069$3 = [0, [1, [0, _aE_, [0, arg_073, 0]]], bnds_069$2],
             arg_071 = caml_call1(Core[389], length_070),
             bnds_069$4 = [0, [1, [0, _aF_, [0, arg_071, 0]]], bnds_069$3];
            return [1, bnds_069$4];
           }
           return caml_call4(Base_Invariant[1], _a8_, t, _df_, _de_);
          }),
      max_allowed_alarm_time_fun =
        check
         (function(max_allowed_alarm_time){
           var
            expect = compute_max_allowed_alarm_time(t),
            sexpifier = Core_Time_ns_alternate_sexp[98],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_162, b_163){
            return caml_call2(Core_Time_ns_alternate_sexp[107], a_162, b_163);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$6,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    max_allowed_alarm_time);
          }),
      now_interval_num_start_fun =
        check
         (function(now_interval_num_start){
           var
            expect = interval_num_start(t, now_interval_num(t)),
            sexpifier = Core_Time_ns_alternate_sexp[98],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_160, b_161){
            return caml_call2(Core_Time_ns_alternate_sexp[107], a_160, b_161);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$7,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    now_interval_num_start);
          }),
      now_fun =
        check
         (function(now){
           if(! caml_call2(Core_Time_ns_alternate_sexp[100], now, t[2]))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bO_], 1);
           if(! caml_call2(Core_Time_ns_alternate_sexp[101], now, max_time))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bN_], 1);
           var _dc_ = min_allowed_key$1(t[7]), _dd_ = interval_num$0(t, t[4]);
           if(caml_call2(_bh_[9], _dd_, _dc_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bM_], 1);
          }),
      max_interval_num_fun =
        check
         (function(max_interval_num){
           var
            got = interval_num$0(t, max_time),
            sexpifier = _bh_[2],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_156, b_157){
            return caml_call2(_bh_[22], a_156, b_157);
           }
           caml_call8
            (Ppx_assert_lib_Runtime[3],
             pos$8,
             sexpifier,
             comparator,
             here,
             message,
             equal,
             max_interval_num,
             got);
           var
            got$0 = interval_num$0(t, interval_num_start(t, max_interval_num)),
            sexpifier$0 = _bh_[2],
            equal$0 = 0,
            message$0 = 0,
            here$0 = 0;
           function comparator$0(a_158, b_159){
            return caml_call2(_bh_[22], a_158, b_159);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$9,
                    sexpifier$0,
                    comparator$0,
                    here$0,
                    message$0,
                    equal$0,
                    max_interval_num,
                    got$0);
          }),
      start_fun =
        check
         (function(start){
           if(! caml_call2(Core_Time_ns_alternate_sexp[100], start, min_time))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bQ_], 1);
           if(caml_call2(Core_Time_ns_alternate_sexp[101], start, max_time))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bP_], 1);
          }),
      config_fun = check(invariant$1);
     caml_call1(config_fun, config$0);
     caml_call1(start_fun, start$0);
     caml_call1(max_interval_num_fun, max_interval_num$0);
     caml_call1(now_fun, now$0);
     caml_call1(now_interval_num_start_fun, now_interval_num_start$0);
     caml_call1(max_allowed_alarm_time_fun, max_allowed_alarm_time$0);
     caml_call1(priority_queue_fun, priority_queue$0);
     return iter$0
             (t,
              function(alarm){
               var
                _c7_ = interval_num$0(t, at$0(t, alarm)),
                _c8_ = interval_num(t, alarm);
               if(! caml_call2(_bh_[9], _c8_, _c7_))
                throw caml_maybe_attach_backtrace
                       ([0, Assert_failure, _bT_], 1);
               var
                _c9_ = interval_start(t, t[4]),
                _c__ = interval_start(t, at$0(t, alarm));
               if(! caml_call2(Core_Time_ns_alternate_sexp[100], _c__, _c9_))
                throw caml_maybe_attach_backtrace
                       ([0, Assert_failure, _bS_], 1);
               var
                _c$_ = alarm_precision$0(t),
                _da_ = caml_call2(Core_Time_ns_alternate_sexp[46], t[4], _c$_),
                _db_ = at$0(t, alarm);
               if(caml_call2(Core_Time_ns_alternate_sexp[103], _db_, _da_))
                return 0;
               throw caml_maybe_attach_backtrace([0, Assert_failure, _bR_], 1);
              });
    }
    function _c6_(x_155){
     return sexp_of_t$10(function(param){return _bU_;}, x_155);
    }
    return caml_call4(Base_Invariant[1], _bV_, t, _c6_, _c5_);
   }
   var debug = 0;
   function advance_clock(t, to, handle_removed){
    var _c3_ = caml_call2(Core_Time_ns_alternate_sexp[103], to, t[4]);
    if(_c3_){
     t[4] = to;
     var t_min_allowed_key = interval_num_unchecked(t, to);
     t[5] = interval_num_start_unchecked(t, t_min_allowed_key);
     var t$0 = t[7];
     if(caml_call2(symbol$16, t_min_allowed_key, min_allowed_key$1(t$0)))
      var match = 0;
     else{
      var
       level_index = [0, 0],
       result = [0, 1],
       prev_level_max_allowed_key = [0, caml_call1(pred$0, t_min_allowed_key)],
       levels = t$0[5],
       num_levels$0 = num_levels(t$0);
      for(;;){
       if(! caml_call2(Core[92], level_index[1], num_levels$0)){
        if(caml_call2(symbol$18, t_min_allowed_key, t$0[4])){
         t$0[3] = caml_call1(null$1, 0);
         t$0[4] = min_allowed_key$1(t$0);
        }
        var match = result[1];
        break;
       }
       var
        _c2_ = level_index[1],
        level = caml_check_bound(levels, _c2_)[1 + _c2_],
        min_allowed_key_before = level[9],
        prev_level_max_allowed_key$0 = prev_level_max_allowed_key[1],
        desired_min_allowed_key =
          compute_min_allowed_key(level, prev_level_max_allowed_key$0),
        level_min_allowed_key =
          min_key_in_same_slot$0
           (level,
            caml_call2
             (min$0,
              desired_min_allowed_key,
              caml_call2(max$0, level[9], t$0[4]))),
        level_min_allowed_key$0 = [0, level_min_allowed_key],
        slot$0 = [0, slot(level, level_min_allowed_key$0[1])],
        keys_per_slot = level[5],
        slots = level[11];
       for(;;){
        if
         (!
          caml_call2
           (symbol$19, level_min_allowed_key$0[1], desired_min_allowed_key))
         break;
        if(caml_call2(Core[90], level[8], 0))
         level_min_allowed_key$0[1] = desired_min_allowed_key;
        else{
         var
          _cZ_ = slot$0[1],
          first = caml_check_bound(slots, _cZ_)[1 + _cZ_];
         if(1 - caml_call1(is_null, first)){
          var _c0_ = caml_call1(null$1, 0), _c1_ = slot$0[1];
          caml_check_bound(slots, _c1_)[1 + _c1_] = _c0_;
          var pool = t$0[2], current = [0, first], continue$0 = [0, 1];
          for(;;){
           if(! continue$0[1]) break;
           var next$0 = next(pool, current[1]);
           level[8] = level[8] - 1 | 0;
           if(caml_call2(symbol$15, key(pool, current[1]), t_min_allowed_key))
            add_elt(t$0, current[1]);
           else{
            t$0[1] = t$0[1] - 1 | 0;
            caml_call1(handle_removed, current[1]);
            caml_call2(free, pool, current[1]);
           }
           if(next$0 === first) continue$0[1] = 0; else current[1] = next$0;
          }
         }
         slot$0[1] = next_slot(level, slot$0[1]);
         level_min_allowed_key$0[1] =
          add_clamp_to_max(level_min_allowed_key$0[1], keys_per_slot);
        }
       }
       level[9] = desired_min_allowed_key;
       level[10] = add_clamp_to_max(desired_min_allowed_key, level[7]);
       if(caml_call2(equal$3, level[9], min_allowed_key_before)){level_index[1] = num_levels$0; result[1] = 0;}
       else{
        level_index[1] = level_index[1] + 1 | 0;
        prev_level_max_allowed_key[1] = level[10];
       }
      }
     }
     if(match){t[6] = compute_max_allowed_alarm_time(t); return 0;}
     var _c4_ = debug;
    }
    else
     var _c4_ = _c3_;
    return _c4_;
   }
   function advance_clock_stop_at_next_ala(t, to, handle_fired){
    var min_elt = min_elt$1(t[7]);
    if(caml_call1(is_null, min_elt))
     return advance_clock
             (t,
              to,
              function(param){
               throw caml_maybe_attach_backtrace([0, Assert_failure, _bW_], 1);
              });
    var key$0 = key(pool$1(t), min_elt), _cX_ = interval_num_start(t, key$0);
    if(caml_call2(Core_Time_ns_alternate_sexp[104], to, _cX_))
     return advance_clock
             (t,
              to,
              function(param){
               throw caml_maybe_attach_backtrace([0, Assert_failure, _bX_], 1);
              });
    var
     _cY_ = min_alarm_time(pool$1(t), min_elt, key$0),
     to$0 = caml_call2(Core_Time_ns_alternate_sexp[108], to, _cY_);
    return advance_clock(t, to$0, handle_fired);
   }
   function create$2(config, start){
    if
     (caml_call2
       (Core_Time_ns_alternate_sexp[104],
        start,
        Core_Time_ns_alternate_sexp[35])){
     var
      _cN_ =
        [0,
         [1,
          [0,
           _bY_,
           [0, caml_call1(Core_Time_ns_alternate_sexp[98], start), 0]]],
         0],
      _cO_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_create_got_st),
          _cN_]];
     caml_call1(Core[261], _cO_);
    }
    var level_bits = config[2], capacity$0 = config[3];
    function _cJ_(index, param, level_bits){
     var
      levels = param[3],
      max_level_min_allowed_key = param[2],
      bits_per_slot = param[1],
      keys_per_slot = num_keys(bits_per_slot),
      diff_max_min_allowed_key =
        compute_diff_max_min_allowed_k(level_bits, bits_per_slot),
      min_key_in_same_slot_mask = create$1(bits_per_slot),
      min_allowed_key =
        min_key_in_same_slot
         (max_level_min_allowed_key, min_key_in_same_slot_mask),
      max_allowed_key =
        add_clamp_to_max(min_allowed_key, diff_max_min_allowed_key),
      _cR_ = caml_call1(null$1, 0),
      _cS_ = pow2(level_bits),
      _cT_ = caml_call1(Core_Int63[5], _cS_),
      _cU_ = caml_call2(Core_Array[63], _cT_, _cR_),
      level =
        [0,
         index,
         level_bits,
         create$0(level_bits),
         bits_per_slot,
         keys_per_slot,
         min_key_in_same_slot_mask,
         diff_max_min_allowed_key,
         0,
         min_allowed_key,
         max_allowed_key,
         _cU_],
      _cV_ = [0, level, levels],
      _cW_ =
        caml_call2(symbol$17, max_allowed_key, max_value$0)
         ? max_value$0
         : caml_call1(succ$0, max_allowed_key);
     return [0, symbol$2(level_bits, bits_per_slot), _cW_, _cV_];
    }
    var
     levels =
       caml_call3(Core_List[33], level_bits, [0, zero, zero$1, 0], _cJ_)[3],
     _cK_ = caml_call1(Core_Array[99], levels),
     _cL_ = caml_call1(null$1, 0);
    if(capacity$0)
     var sth = capacity$0[1], capacity = sth;
    else
     var capacity = 1;
    var
     _cM_ =
       [0,
        0,
        caml_call2(Tuple_pool[36][35], Tuple_pool[36][1][22], capacity),
        _cL_,
        zero$1,
        _cK_],
     _cP_ = Core_Time_ns_alternate_sexp[38],
     _cQ_ = Core_Time_ns_alternate_sexp[38],
     t =
       [0,
        config,
        start,
        interval_num_internal(max_time, config[1]),
        _cQ_,
        _cP_,
        max_time,
        _cM_];
    t[6] = compute_max_allowed_alarm_time(t);
    advance_clock
     (t,
      start,
      function(param){
       throw caml_maybe_attach_backtrace([0, Assert_failure, _bZ_], 1);
      });
    return t;
   }
   function add_at_interval_num(t, at, value){
    var _cI_ = interval_num_start(t, at);
    return internal_add(t[7], at, _cI_, value);
   }
   function ensure_can_schedule_alarm(t, at){
    if(caml_call2(Core_Time_ns_alternate_sexp[103], at, t[6])){
     var
      _cB_ =
        [0,
         [1,
          [0, _b0_, [0, caml_call1(Core_Time_ns_alternate_sexp[98], t[6]), 0]]],
         0],
      _cC_ =
        [0,
         [1,
          [0, _b1_, [0, caml_call1(Core_Time_ns_alternate_sexp[98], at), 0]]],
         _cB_],
      _cD_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_cannot_schedu),
          _cC_]];
     caml_call1(Core[261], _cD_);
    }
    var _cH_ = caml_call2(Core_Time_ns_alternate_sexp[104], at, t[5]);
    if(! _cH_) return _cH_;
    var
     _cE_ =
       [0,
        [1,
         [0, _b2_, [0, caml_call1(Core_Time_ns_alternate_sexp[98], t[5]), 0]]],
        0],
     _cF_ =
       [0,
        [1,
         [0, _b3_, [0, caml_call1(Core_Time_ns_alternate_sexp[98], at), 0]]],
        _cE_],
     _cG_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_cannot_schedu$0),
         _cF_]];
    return caml_call1(Core[261], _cG_);
   }
   function add$0(t, at, value){
    ensure_can_schedule_alarm(t, at);
    var _cA_ = interval_num_unchecked(t, at);
    return internal_add(t[7], _cA_, at, value);
   }
   function remove(t, alarm){
    var t$0 = t[7], pool = t$0[2], elt = of_external_exn(pool, alarm);
    internal_remove(t$0, elt);
    return caml_call2(free, pool, elt);
   }
   function clear(t){
    var t$0 = t[7], _cr_ = 1 - is_empty(t$0);
    if(_cr_){
     t$0[1] = 0;
     var
      pool = t$0[2],
      free_elt = function(elt){return caml_call2(free, pool, elt);},
      levels = t$0[5],
      _ct_ = levels.length - 1 - 1 | 0,
      _cs_ = 0;
     if(_ct_ >= 0){
      var level_index = _cs_;
      for(;;){
       var level = caml_check_bound(levels, level_index)[1 + level_index];
       if(caml_call2(Core[91], level[8], 0)){
        level[8] = 0;
        var slots = level[11], _cw_ = slots.length - 1 - 1 | 0, _cv_ = 0;
        if(_cw_ >= 0){
         var slot_index = _cv_;
         for(;;){
          var elt = caml_check_bound(slots, slot_index)[1 + slot_index];
          if(1 - caml_call1(is_null, elt)){
           iter(pool, elt, free_elt);
           var _cy_ = caml_call1(null$1, 0);
           caml_check_bound(slots, slot_index)[1 + slot_index] = _cy_;
          }
          var _cz_ = slot_index + 1 | 0;
          if(_cw_ === slot_index) break;
          var slot_index = _cz_;
         }
        }
       }
       var _cx_ = level_index + 1 | 0;
       if(_ct_ === level_index) break;
       var level_index = _cx_;
      }
     }
     var _cu_ = 0;
    }
    else
     var _cu_ = _cr_;
    return _cu_;
   }
   function mem(t, alarm){var t$0 = t[7]; return is_valid(t$0[2], alarm);}
   function reschedule_gen(t, alarm, key, at){
    if(1 - mem(t, alarm)) caml_call1(Core[6], cst_Timing_wheel_cannot_resche);
    ensure_can_schedule_alarm(t, at);
    var t$0 = t[7];
    ensure_valid_key(t$0, key);
    var pool = t$0[2], elt = of_external_exn(pool, alarm);
    internal_remove(t$0, elt);
    caml_call4(Tuple_pool[36][33], pool, elt, Tuple_pool[36][2][3], key);
    caml_call4(Tuple_pool[36][33], pool, elt, Tuple_pool[36][2][4], at);
    return internal_add_elt(t$0, elt);
   }
   function reschedule(t, alarm, at){
    return reschedule_gen(t, alarm, interval_num_unchecked(t, at), at);
   }
   function reschedule_at_interval_num(t, alarm, at){
    return reschedule_gen(t, alarm, at, interval_num_start(t, at));
   }
   function min_alarm_interval_num(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, key(pool$1(t), elt)];
   }
   function min_alarm_interval_num_exn(x_164){
    var elt = min_elt$1(x_164[7]);
    if(! caml_call1(is_null, elt)) return key(pool$1(x_164), elt);
    var
     _cn_ = 0,
     _co_ = 0,
     _cp_ =
       [0,
        [1,
         [0,
          _b5_,
          [0, sexp_of_t$10(function(param){return _b4_;}, x_164), _co_]]],
        _cn_],
     _cq_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_min_alarm_int),
         _cp_]];
    return caml_call1(Core[261], _cq_);
   }
   function max_alarm_time_in_list(t, first){
    var
     pool = pool$1(t),
     with_key = key(pool, first),
     max_alarm_time = [0, Core_Time_ns_alternate_sexp[35]],
     current = [0, first],
     continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return max_alarm_time[1];
     var next$0 = next(pool, current[1]);
     if(caml_call2(equal$3, key(pool, current[1]), with_key)){
      var _cl_ = max_alarm_time[1], _cm_ = at(pool, current[1]);
      max_alarm_time[1] =
       caml_call2(Core_Time_ns_alternate_sexp[109], _cm_, _cl_);
     }
     if(next$0 === first) continue$0[1] = 0; else current[1] = next$0;
    }
   }
   function min_alarm_time_in_list(t, elt){
    var pool = pool$1(t);
    return min_alarm_time(pool, elt, key(pool, elt));
   }
   function max_alarm_time_in_min_interval(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, max_alarm_time_in_list(t, elt)];
   }
   function min_alarm_time_in_min_interval(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, min_alarm_time_in_list(t, elt)];
   }
   function max_alarm_time_in_min_interval$0(x_165){
    var elt = min_elt$1(x_165[7]);
    if(caml_call1(is_null, elt)){
     var
      _ch_ = 0,
      _ci_ = 0,
      _cj_ =
        [0,
         [1,
          [0,
           _b7_,
           [0, sexp_of_t$10(function(param){return _b6_;}, x_165), _ci_]]],
         _ch_],
      _ck_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_max_alarm_tim),
          _cj_]];
     caml_call1(Core[261], _ck_);
    }
    return max_alarm_time_in_list(x_165, elt);
   }
   function min_alarm_time_in_min_interval$0(x_166){
    var elt = min_elt$1(x_166[7]);
    if(caml_call1(is_null, elt)){
     var
      _cd_ = 0,
      _ce_ = 0,
      _cf_ =
        [0,
         [1,
          [0,
           _b9_,
           [0, sexp_of_t$10(function(param){return _b8_;}, x_166), _ce_]]],
         _cd_],
      _cg_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_max_alarm_tim$0),
          _cf_]];
     caml_call1(Core[261], _cg_);
    }
    return min_alarm_time_in_list(x_166, elt);
   }
   function fire_past_alarms(t, handle_fired){
    var
     now = t[4],
     key = now_interval_num(t),
     t$0 = t[7],
     level = caml_check_bound(t$0[5], 0)[1],
     _b__ = caml_call2(Core[91], level[8], 0);
    if(_b__){
     var
      slot$0 = slot(level, key),
      slots = level[11],
      pool = t$0[2],
      first = [0, caml_check_bound(slots, slot$0)[1 + slot$0]],
      _b$_ = 1 - caml_call1(is_null, first[1]);
     if(_b$_){
      var current = [0, first[1]], continue$0 = [0, 1];
      for(;;){
       if(! continue$0[1]){var _cb_ = 0; break;}
       var elt = current[1], next$0 = next(pool, elt);
       if(next$0 === first[1]) continue$0[1] = 0; else current[1] = next$0;
       var _ca_ = at(pool, elt);
       if(caml_call2(Core_Time_ns_alternate_sexp[101], _ca_, now)){
        caml_call1(handle_fired, elt);
        internal_remove(t$0, elt);
        caml_call2(free, pool, elt);
        first[1] = caml_check_bound(slots, slot$0)[1 + slot$0];
       }
      }
     }
     else
      var _cb_ = _b$_;
     var _cc_ = _cb_;
    }
    else
     var _cc_ = _b__;
    return _cc_;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_timing_wheel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel);
   var
    Timing_wheel =
      [0,
       [0,
        compare,
        sexp_of_t$1,
        equal$0,
        of_span_floor_pow2_ns,
        of_span_floor_pow2_ns,
        to_sexpable,
        one_nanosecond,
        about_one_day,
        about_one_microsecond,
        about_one_millisecond,
        about_one_second,
        mul,
        div,
        _l_],
       sexp_of_t$10,
       sexp_of_t_now,
       _bh_,
       [0, sexp_of_t$8, null$0, at$0, interval_num, value$0],
       invariant$2,
       [0,
        t_of_sexp$0,
        sexp_of_t$0,
        invariant$0,
        max_num_bits,
        create_exn,
        level_bits_default,
        num_bits],
       [0,
        t_of_sexp$2,
        sexp_of_t$3,
        invariant$1,
        create,
        alarm_precision,
        level_bits,
        durations,
        microsecond_precision],
       create$2,
       alarm_precision$0,
       now,
       start,
       is_empty$0,
       length$3,
       iter$0,
       interval_num$0,
       now_interval_num,
       interval_num_start,
       interval_start,
       advance_clock,
       advance_clock_stop_at_next_ala,
       fire_past_alarms,
       max_allowed_alarm_time,
       now_interval_num,
       max_allowed_alarm_interval_num,
       add$0,
       add_at_interval_num,
       mem,
       remove,
       reschedule,
       reschedule_at_interval_num,
       clear,
       min_alarm_interval_num,
       min_alarm_interval_num_exn,
       max_alarm_time_in_min_interval,
       min_alarm_time_in_min_interval,
       max_alarm_time_in_min_interval$0,
       min_alarm_time_in_min_interval$0,
       next_alarm_fires_at,
       next_alarm_fires_at_exn,
       [0, max_time, interval_num_internal, [0, invariant, zero]]];
   runtime.caml_register_global(214, Timing_wheel, cst_Timing_wheel$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0aW1pbmdfd2hlZWwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInBvcyQ5IiwicG9zJDgiLCJwb3MkNyIsInBvcyQ2IiwiYXJnXzA4NyIsInBvcyQ1IiwicG9zJDQiLCJwb3MkMyIsInBvcyQyIiwicG9zJDEiLCJwb3MkMCIsInBvcyIsImVycm9yX3NvdXJjZV8wMTkiLCJtYXhfdGltZSIsIm1pbl90aW1lIiwibWF4X251bV9iaXRzIiwibWluX3ZhbHVlIiwiaW52YXJpYW50IiwidCIsIm9mX2ludCIsImkiLCJzeW1ib2wkMiIsInQxIiwidDIiLCJzeW1ib2wkMyIsInBvdzIiLCJzZXhwX29mX3QkMCIsInhfMDA3IiwibnVtX2JpdHNfaW50ZXJuYWwiLCJudW1fYml0cyIsImludmFyaWFudCQwIiwibnVtX2tleV9iaXRzIiwidF9vZl9zZXhwJDAiLCJ4XzAwNiIsImNyZWF0ZV9leG4iLCJvcHQiLCJ4XzAwOCIsInN0aCIsImV4dGVuZF90b19tYXhfbnVtX2JpdHMiLCJiaXRzIiwiaW50cyIsImxldmVsX2JpdHNfZGVmYXVsdCIsImNvbXBhcmUiLCJlcXVhbCQwIiwieF8wMTIiLCJ4XzAxMyIsInRvX3NleHBhYmxlIiwic2V4cF9vZl90JDEiLCJvbmVfbmFub3NlY29uZCIsImFib3V0X29uZV9taWNyb3NlY29uZCIsImFib3V0X29uZV9taWxsaXNlY29uZCIsImFib3V0X29uZV9zZWNvbmQiLCJhYm91dF9vbmVfZGF5IiwibXVsIiwiZGl2Iiwib2Zfc3Bhbl9mbG9vcl9wb3cyX25zIiwic3BhbiIsImxldmVsX2JpdHMiLCJyIiwidiIsImxldmVsX2JpdHMkMCIsInRfb2Zfc2V4cCQyIiwieF8wMjEiLCJjYXBhY2l0eSIsImFsYXJtX3ByZWNpc2lvbiIsInNleHBfb2ZfdCQzIiwiY2FwYWNpdHlfMDI3IiwibGV2ZWxfYml0c18wMjUiLCJhbGFybV9wcmVjaXNpb25fMDIzIiwiYm5kc18wMjIiLCJ2XzAyOCIsImFyZ18wMzAiLCJibmRfMDI5IiwiYm5kc18wMjIkMCIsImFyZ18wMjYiLCJibmRzXzAyMiQxIiwiYXJnXzAyNCIsImJuZHNfMDIyJDIiLCJtYXhfbnVtX2xldmVsX2JpdHMiLCJpbnZhcmlhbnQkMSIsImxldmVsX2JpdHNfZnVuIiwiY3JlYXRlIiwibG9vcCIsInJlbWFpbmluZyIsInQkMCIsImIiLCJtaWNyb3NlY29uZF9wcmVjaXNpb24iLCJkdXJhdGlvbnMiLCJudW1fYml0c19hY2N1bSIsImxldmVsX251bV9iaXRzIiwibnVtX2JpdHNfYWNjdW0kMCIsImR1cmF0aW9uIiwiY29tcGFyZSQwIiwic2V4cF9vZl90JDQiLCJjcmVhdGUkMCIsIm51bV9rZXlzIiwiY3JlYXRlJDEiLCJiaXRzX3Blcl9zbG90IiwidG9faW50NjMiLCJvZl9pbnQ2MyIsInNjYWxlX2ludCIsInNleHBfb2ZfdCQ3Iiwib2ZfaW50NjMkMCIsInRvX2ludDYzJDAiLCJhZGQiLCJhZGRfY2xhbXBfdG9fbWF4Iiwic3ViIiwiZGlmZiIsIm1pbl9rZXlfaW5fc2FtZV9zbG90IiwibWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayIsInNleHBfb2ZfcG9vbF9zbG90cyIsIm9mX2FfMDMzIiwieF8wMzQiLCJzZXhwX29mX3QkOCIsIm9mX2FfMDM1IiwieF8wMzYiLCJudWxsJDAiLCJudWxsJDEiLCJpc19udWxsIiwiZnJlZSIsImtleSIsInAiLCJhdCIsInZhbHVlIiwibGV2ZWxfaW5kZXgiLCJwcmV2Iiwic2V0X3ByZXYiLCJ4IiwibmV4dCIsInNldF9uZXh0IiwiaXNfdmFsaWQiLCJncm93IiwiaXNfZnVsbCIsIm9mX2V4dGVybmFsX2V4biIsInBvb2wiLCJsaW5rIiwiaXRlciIsImZpcnN0IiwiZiIsImN1cnJlbnQiLCJjb250aW51ZSQwIiwibmV4dCQwIiwibWluX2FsYXJtX3RpbWUiLCJ3aXRoX2tleSIsInNsb3RzIiwibWF4X2FsbG93ZWRfa2V5Iiwic2V0X21heF9hbGxvd2VkX2tleSIsIm1pbl9hbGxvd2VkX2tleSIsInNldF9taW5fYWxsb3dlZF9rZXkiLCJsZW5ndGgiLCJzZXRfbGVuZ3RoIiwiZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5Iiwia2V5c19wZXJfc2xvdCIsInNsb3RzX21hc2siLCJpbmRleCIsInNsb3RzJDAiLCJtYXhfYWxsb3dlZF9rZXkkMCIsIm1pbl9hbGxvd2VkX2tleSQwIiwibGVuZ3RoJDAiLCJkaWZmX21heF9taW5fYWxsb3dlZF9rZXkkMCIsIm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2skMCIsImtleXNfcGVyX3Nsb3QkMCIsImJpdHNfcGVyX3Nsb3QkMCIsInNsb3RzX21hc2skMCIsImJpdHMkMCIsImluZGV4JDAiLCJzZXhwX29mX3QkOSIsIm9mX2FfMDQ0IiwiZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5XzA1OCIsIm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tfMDU2Iiwia2V5c19wZXJfc2xvdF8wNTQiLCJiaXRzX3Blcl9zbG90XzA1MiIsInNsb3RzX21hc2tfMDUwIiwiYml0c18wNDgiLCJpbmRleF8wNDYiLCJsZW5ndGhfMDYwIiwibWluX2FsbG93ZWRfa2V5XzA2MiIsIm1heF9hbGxvd2VkX2tleV8wNjQiLCJzbG90c18wNjYiLCJhcmdfMDY3IiwiYm5kc18wNDUiLCJhcmdfMDY1IiwiYm5kc18wNDUkMCIsImFyZ18wNjMiLCJibmRzXzA0NSQxIiwiYXJnXzA2MSIsImJuZHNfMDQ1JDIiLCJhcmdfMDU5IiwiYm5kc18wNDUkMyIsImFyZ18wNTciLCJibmRzXzA0NSQ0IiwiYXJnXzA1NSIsImJuZHNfMDQ1JDUiLCJhcmdfMDUzIiwiYm5kc18wNDUkNiIsImFyZ18wNTEiLCJibmRzXzA0NSQ3IiwiYXJnXzA0OSIsImJuZHNfMDQ1JDgiLCJhcmdfMDQ3IiwiYm5kc18wNDUkOSIsInNsb3QiLCJuZXh0X3Nsb3QiLCJtaW5fa2V5X2luX3NhbWVfc2xvdCQwIiwiY29tcHV0ZV9taW5fYWxsb3dlZF9rZXkiLCJwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSIsImxldmVscyIsImVsdF9rZXlfbG93ZXJfYm91bmQiLCJzZXRfZWx0X2tleV9sb3dlcl9ib3VuZCIsIm1pbl9lbHQiLCJzZXRfbWluX2VsdCIsInNldF9wb29sIiwibGVuZ3RoJDEiLCJzZXRfbGVuZ3RoJDAiLCJsZXZlbHMkMCIsImVsdF9rZXlfbG93ZXJfYm91bmQkMCIsIm1pbl9lbHQkMCIsInBvb2wkMCIsImxlbmd0aCQyIiwiaXNfZW1wdHkiLCJudW1fbGV2ZWxzIiwibWluX2FsbG93ZWRfa2V5JDEiLCJtYXhfYWxsb3dlZF9rZXkkMSIsImludGVybmFsX2l0ZXIiLCJsZXZlbCIsInNsb3RfaW5kZXgiLCJlbHQiLCJjb21wdXRlX2RpZmZfbWF4X21pbl9hbGxvd2VkX2siLCJtaW5fZWx0JDEiLCJtaW5fZWx0X2FscmVhZHlfZm91bmQiLCJtaW5fa2V5X2FscmVhZHlfZm91bmQiLCJudW1fbGV2ZWxzJDAiLCJzbG90X21pbl9rZXkiLCJzbG90JDAiLCJjdXJyZW50X2tleSIsImFkZF9lbHQiLCJ4XzExNCIsInRvX2FkZCIsImtleSQwIiwiZWx0c18wOTQiLCJtYXhfYWxsb3dlZF9rZXlfMDkyIiwibWluX2FsbG93ZWRfa2V5XzA5MCIsImJuZHNfMDg5Iiwia2V5XzA4NCIsImJuZHNfMDgzIiwiYXJnXzA4NSIsImJuZHNfMDgzJDAiLCJhcmdfMDk1IiwiYm5kc18wODkkMCIsImFyZ18wOTMiLCJibmRzXzA4OSQxIiwiYXJnXzA5MSIsImJuZHNfMDg5JDIiLCJsZXZlbF9pbmRleCQwIiwicHJldiQwIiwiaW50ZXJuYWxfYWRkX2VsdCIsImVuc3VyZV92YWxpZF9rZXkiLCJpbnRlcm5hbF9hZGQiLCJpbnRlcm5hbF9yZW1vdmUiLCJtaW5faW50ZXJ2YWxfbnVtIiwicHJpb3JpdHlfcXVldWUiLCJtYXhfYWxsb3dlZF9hbGFybV90aW1lIiwic2V0X21heF9hbGxvd2VkX2FsYXJtX3RpbWUiLCJub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0Iiwic2V0X25vd19pbnRlcnZhbF9udW1fc3RhcnQiLCJub3ciLCJzZXRfbm93IiwibWF4X2ludGVydmFsX251bSIsInN0YXJ0IiwiY29uZmlnIiwicHJpb3JpdHlfcXVldWUkMCIsIm1heF9hbGxvd2VkX2FsYXJtX3RpbWUkMCIsIm5vd19pbnRlcnZhbF9udW1fc3RhcnQkMCIsIm5vdyQwIiwibWF4X2ludGVydmFsX251bSQwIiwic3RhcnQkMCIsImNvbmZpZyQwIiwic2V4cF9vZl90X25vdyIsImFsYXJtX3ByZWNpc2lvbiQwIiwiYXQkMCIsInR3IiwidmFsdWUkMCIsImludGVydmFsX251bSIsIml0ZXIkMCIsImNvbXBhcmUkMyIsInNleHBfb2ZfdCQxMCIsInNleHBfb2ZfYSIsIm1heF9pbnRlcnZhbF9udW1fMTQ2Iiwic3RhcnRfMTQ0IiwiY29uZmlnXzE0MiIsIm5vd18xNDgiLCJhbGFybSIsImFsYXJtc18xNTAiLCJibmRzXzE0MSIsInZhbHVlXzEzOCIsImF0XzEzNiIsImFyZ18xMzkiLCJibmRzXzEzNSIsImFyZ18xMzciLCJibmRzXzEzNSQwIiwiYXJnXzE1MSIsImJuZHNfMTQxJDAiLCJhcmdfMTQ5IiwiYm5kc18xNDEkMSIsImFyZ18xNDciLCJibmRzXzE0MSQyIiwiYXJnXzE0NSIsImJuZHNfMTQxJDMiLCJhcmdfMTQzIiwiYm5kc18xNDEkNCIsImxlbmd0aCQzIiwiaXNfZW1wdHkkMCIsInBvb2wkMSIsImludGVydmFsX251bV9pbnRlcm5hbCIsInRpbWUiLCJpbnRlcnZhbF9udW1fdW5jaGVja2VkIiwiaW50ZXJ2YWxfbnVtJDAiLCJpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIiwiaW50ZXJ2YWxfbnVtX3N0YXJ0IiwibmV4dF9hbGFybV9maXJlc19hdF9pbnRlcm5hbCIsIm5leHRfYWxhcm1fZmlyZXNfYXQiLCJuZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biIsInhfMTUzIiwiY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIiwibm93X2ludGVydmFsX251bSIsIm1heF9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bSIsImludGVydmFsX3N0YXJ0IiwiaW52YXJpYW50JDIiLCJpbnZhcmlhbnRfYSIsImNoZWNrIiwicHJpb3JpdHlfcXVldWVfZnVuIiwibGV2ZWxzX2Z1biIsInNsb3RzX2Z1biIsIm4iLCJ4XzA0MSIsIm1heF9hbGxvd2VkX2tleV9mdW4iLCJleHBlY3QiLCJlcXVhbCIsIm1lc3NhZ2UiLCJoZXJlIiwiY29tcGFyYXRvciIsImFfMTA3IiwiYl8xMDgiLCJtaW5fYWxsb3dlZF9rZXlfZnVuIiwiZ290Iiwic2V4cGlmaWVyIiwiYV8xMDUiLCJiXzEwNiIsImxlbmd0aF9mdW4iLCJkaWZmX21heF9taW5fYWxsb3dlZF9rZXlfZnVuIiwiZXRhIiwiYV8xMDMiLCJiXzEwNCIsIm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tfZnVuIiwia2V5c19wZXJfc2xvdF9mdW4iLCJhXzEwMSIsImJfMTAyIiwiYml0c19wZXJfc2xvdF9mdW4iLCJleHBlY3QkMCIsInNsb3RzX21hc2tfZnVuIiwiYV8wOTkiLCJiXzEwMCIsImJpdHNfZnVuIiwiaW5kZXhfZnVuIiwieF8wOTgiLCJwcmV2X2xldmVsIiwiYV8xMTAiLCJiXzExMSIsImdvdCQwIiwibWVzc2FnZSQwIiwiaGVyZSQwIiwiY29tcGFyYXRvciQwIiwiYV8xMTIiLCJiXzExMyIsImVsdF9rZXlfbG93ZXJfYm91bmRfZnVuIiwibWluX2VsdF9mdW4iLCJwb29sX2Z1biIsInhfMTA5Iiwib2ZfYV8wNjgiLCJsZW5ndGhfMDcwIiwicG9vbF8wNzIiLCJtaW5fZWx0XzA3NCIsImVsdF9rZXlfbG93ZXJfYm91bmRfMDc2IiwibGV2ZWxzXzA3OCIsImJuZHNfMDY5IiwiYXJnXzA3OSIsImJuZHNfMDY5JDAiLCJhcmdfMDc3IiwiYm5kc18wNjkkMSIsImFyZ18wNzUiLCJibmRzXzA2OSQyIiwiYXJnXzA3MyIsImJuZHNfMDY5JDMiLCJhcmdfMDcxIiwiYm5kc18wNjkkNCIsIm1heF9hbGxvd2VkX2FsYXJtX3RpbWVfZnVuIiwiYV8xNjIiLCJiXzE2MyIsIm5vd19pbnRlcnZhbF9udW1fc3RhcnRfZnVuIiwiYV8xNjAiLCJiXzE2MSIsIm5vd19mdW4iLCJtYXhfaW50ZXJ2YWxfbnVtX2Z1biIsImFfMTU2IiwiYl8xNTciLCJzZXhwaWZpZXIkMCIsImFfMTU4IiwiYl8xNTkiLCJzdGFydF9mdW4iLCJjb25maWdfZnVuIiwieF8xNTUiLCJkZWJ1ZyIsImFkdmFuY2VfY2xvY2siLCJ0byIsImhhbmRsZV9yZW1vdmVkIiwidF9taW5fYWxsb3dlZF9rZXkiLCJyZXN1bHQiLCJtaW5fYWxsb3dlZF9rZXlfYmVmb3JlIiwicHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkkMCIsImRlc2lyZWRfbWluX2FsbG93ZWRfa2V5IiwibGV2ZWxfbWluX2FsbG93ZWRfa2V5IiwibGV2ZWxfbWluX2FsbG93ZWRfa2V5JDAiLCJhZHZhbmNlX2Nsb2NrX3N0b3BfYXRfbmV4dF9hbGEiLCJoYW5kbGVfZmlyZWQiLCJ0byQwIiwiY3JlYXRlJDIiLCJjYXBhY2l0eSQwIiwibWF4X2xldmVsX21pbl9hbGxvd2VkX2tleSIsImFkZF9hdF9pbnRlcnZhbF9udW0iLCJlbnN1cmVfY2FuX3NjaGVkdWxlX2FsYXJtIiwiYWRkJDAiLCJyZW1vdmUiLCJjbGVhciIsImZyZWVfZWx0IiwibWVtIiwicmVzY2hlZHVsZV9nZW4iLCJyZXNjaGVkdWxlIiwicmVzY2hlZHVsZV9hdF9pbnRlcnZhbF9udW0iLCJtaW5fYWxhcm1faW50ZXJ2YWxfbnVtIiwibWluX2FsYXJtX2ludGVydmFsX251bV9leG4iLCJ4XzE2NCIsIm1heF9hbGFybV90aW1lX2luX2xpc3QiLCJtYXhfYWxhcm1fdGltZSIsIm1pbl9hbGFybV90aW1lX2luX2xpc3QiLCJtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwiLCJtaW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwiLCJtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwkMCIsInhfMTY1IiwibWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsJDAiLCJ4XzE2NiIsImZpcmVfcGFzdF9hbGFybXMiXSwic291cmNlcyI6WyIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvY29yZV9rZXJuZWwvdGltaW5nX3doZWVsL3RpbWluZ193aGVlbF9fLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2NvcmVfa2VybmVsL3RpbWluZ193aGVlbC90aW1pbmdfd2hlZWwubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0FRd0I7O0lBQUE7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lDd2tERUE7SUFIQUM7SUFnQkFDO0lBS0FDO0lBbnhCaEJDO0lBaUpzQkM7SUFIQUM7SUExRkRDO0lBT0RDO0lBV0NDO0lBa0JDQztJQUtGQztJQWxzQjVCQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXpMa0Q7SUFJaERDO0lBQ0FDOzs7Ozs7Ozs7SUFzREVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFqQ0FDO1lBS0FDLFVBQVVDO0lBQ1osS0FBTyxtQkFES0EsR0FMVkY7S0FNRixNQUFBO0lBQ08sR0FBQSxxQkFGS0UsR0E0QlZIO0lBMUJGLE1BQUE7R0FBdUI7WUFHckJJLE9BQU9DLEdBTFBILFVBS09HLElBQ1QsT0FEU0EsRUFFUjtZQUdDQyxTQUFNQyxJQUFHQyxJQUNYLElBQUlMLElBRElJLEtBQUdDLFFBVlROLFVBV0VDLElBQ0osT0FESUEsRUFFSDtZQUdDTSxTQUFNRixJQUFHQyxJQUNYLElBQUlMLElBRElJLEtBQUdDLFFBaEJUTixVQWlCRUMsSUFDSixPQURJQSxFQUVIO1lBR0NPLEtBQUtQLEdBQUksT0FBQSwyQ0FBSkEsR0FBZ0M7WUFJekNRLFlBQUFDO0lBQUEsT0FBQSxpQ0FBQUE7R0FBdUQ7WUFHbkRDLGtCQUFrQlY7SUFBSSxpQ0FBSkEsU0FuQmxCRztHQW1CK0U7WUFDL0VRLFNBQVNYLEdBQUssT0FEZFUsa0JBQ1NWLEdBQXdCO1lBc0p2QlksWUFwSkFaO0lBQ1osR0FBWSwwQkFEQUE7S0FDWixNQUFBO2tCQUNvQmE7S0FsQ2xCZCxVQWtDa0JjO0tBRVgsR0FBQSxxQkFGV0E7S0FFbEIsTUFBQTtJQUEwRDtJQUY1RCwwQkFGWWI7SUFLVyxPQXJDckJELFVBNkJBVyxrQkFHVVY7R0FLZ0M7WUFHMUNjLFlBQVVDO0lBZGQsSUFlTWYsSUFmTixpQ0FjY2U7SUE0SUFILFlBM0lSWjtJQUNKLE9BRElBO0dBRUg7WUFHQ2dCLFdBQWFDLEtBQWdDQztJQUMvQyxHQURlRDtTQUF5QkUsTUFBekJGLFFBQUFHLHlCQUF5QkQ7O1NBQXpCQztJQUNaLEdBQUEsMEJBRDRDRjtLQUNwQjtJQUFBLGNBQ0NHLE1BQVEsT0FBQSxxQkFBUkEsU0FBaUI7SUFBMUMsR0FBQSwwQkFGNENIOztrREFBQUE7Ozs7OztLQUk3Qzs7SUFBQSwwQjtJQUVhLElBQVhQLFdBQVcsMEJBTmdDTztJQU81QyxHQUFBLHFCQURDUCxVQXhCRmQ7OzttREFBQUE7d0RBd0JFYztrREFOMkNPOzs7Ozs7S0FTN0M7O09BVGFFO0tBaUJzQztNQUFBLE9BQUE7TUFBdkMsT0FBQSwwQkFuQ1p2QixlQXdCRWM7TUFTQVcsT0FFRyxzQkFqQndDSjs7U0FlM0NJLE9BZjJDSjtJQW9CL0MsT0FBQSwwQkFMSUksTUF4REZyQjtHQTZEa0M7R0FHeEIsSUFtRlZzQixxQkExR0FQLG9CQTJGQVE7WUF4Q0FDLFFBQXlCQyxPQUFBQztJLGFBQUEsV0F3Q3pCSCxTQXhDeUJFLE9BQUFDOztZQUN6QmQsYUFBYWIsR0FBSSxPQTdGakJDLE9BNkZhRCxHQUE0QjtZQTRDckM0QixZQTFDSTVCO0lBQ1YsR0FBRyxxQkFET0E7O3VDQUFBQTs7Ozs7O0tBR1I7O0lBR0YsV0FBQSxXQUFPLDRDQU5HQTtJQU1WLE9BQUE7R0FBb0Q7WUFHbEQ2QixZQUFVN0I7SUFBWSxXQWlDbEI0QixZQWpDTTVCO0lBQVksT0FBQTs7O0lBQ3RCOEI7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7WUFDQUMsSUFBSW5DLEdBQUdPLE1BQU8sT0FBVlAsSUFBR08sU0FBZTtZQUN0QjZCLElBQUlwQyxHQUFHTyxNQUFPLE9BQVZQLElBQUdPLFNBQWU7WUF5QmxCOEIsc0JBbEJrQkM7SUFDeEIsR0FBRyxnQ0FEcUJBOzs7NkRBQUFBOzs7Ozs7S0FHdEI7O0lBSUYsV0FBQSxpQ0FQd0JBO0lBT3hCLE9BQUE7R0FBb0Q7R0FyQ2xEOzs7Ozs7WUFpRElWLGFBREFTOzs7Ozs7Ozs7Ozs7O1lBQ0FULGFBREFTOzs7SUFoREo7Ozs7Ozs7Ozs7T0E0Q0FiOzs7WUFtQkFlLFdBQUFDLEdBQUEsT0FBQUEsS0FBVTtnQkFBVkEsR0FBQUMsR0FBQSxXQUFBRCxNQUFBQyxHQUFBRCxNQUFVO0dBQVY7O0lBQUFFOzBCQUFBLFNBQVUsd0JBQVZIO1lBRkpJLFlBQUFDOztLQUFBOztNQUdJQztNQURBTjtNQURBTztLQURKLFdBQ0lBLGlCQUNBUCxZQUNBTTtJQUU4QztJQUxsRDs7S0FBQTs7Ozs7O0lBS2tEO0lBTGxEO0tBQUE7S0FBQTs7OzRCQUFBLE9BRkl0QixtQkFPOEM7UUF2SDlDVDs7SUFrSEosT0FBQTs7YUFBQXBCOzs7OzthQUFBa0Q7R0FLa0Q7WUFMbERHO0lBQUE7S0FHSUM7S0FEQUM7S0FEQUM7S0FESkM7SUFHSSxHQUFBSDtLQUFBO01BQUFJLFFBQUFKO01BQUFLLFVBQUEsc0JBQUFEO01BQUFFLDJCQUFBRDtNQUhKRSxpQkFHSUQsU0FISkg7O1NBQUFJLGFBQUFKO0lBRUk7S0FBQUssVUFsSUpoRCxZQWtJSXlDO0tBRkpRLGtDQUVJRCxlQUZKRDtLQUNJRyxVQUFBLG9CQUFBUjtLQURKUyxrQ0FDSUQsZUFESkQ7SUFBQSxXQUFBRTtHQUtrRDtZQUU5Q2IsZ0JBQWdCOUMsR0FBSSxPQW5CaEI0QixZQW1CWTVCLE1BQTZDO1lBTzdENEQsbUJBQW1CZDtJQUNyQixPQXpKRXhDLFNBWUFULGNBc0VBZ0IsYUFzRW1CaUM7R0FHMkI7WUFHOUNlLFlBQVU3RDs7S0FLTixXQVhKNEQsbUJBTVU1RDtLQUVILEtBQUEscUJBbkpQVSxrQkFpSlVWO01BRVYsTUFBQTtLQUljLElBMUJiOEQsaUJBMEJhLDhCQU5KOUQsR0FNQVk7S0ExQlQsV0FBQWtELGdCQUVEcEI7S0FDQTtJQTJCMEM7SUFUQSxPQUFBLG1DQURoQzFDLEdBcEJkK0M7R0E4QitDO1lBRzNDZ0IsT0FBUWxCLFVBQVc1QixLQUFrQzZCO0lBQ3ZELEdBRHFCN0I7U0FBYUUsTUFBYkYsUUFwSGRzQixhQW9IMkJwQjs7U0FwSDNCb0IsYUFpRkxoQjtJQXFDeUMsSUF0SGpDMUIsZUFpR1IrRCxtQkFtQnFEZDtJQW5IcEQsR0FBQSxxQkEzQ0RwQyxrQkEwQ0s2QixhQUFHMUM7U0FxSE42QyxlQXJIR0g7OztNQUlHeUI7aUJBQUtoRSxHQUFHaUU7U0FDZCxLQURXakUsR0FFSDthQUNEa0UsTUFISWxFLE1BR1RtRSxJQUhTbkU7U0FJTixPQUFBLG1CQURIbUUsR0FIWUY7dUJBQUFBO3VCQUdaRSxHQUhJSCxLQUdDRSxLQTlEVDVELFNBMkRnQjJELFdBR1pFO1FBRzREO01BMkc5RHpCLGVBakhNc0IsS0FKSHpCLFlBQUcxQztJQXdIVixXQUp1RGlELGlCQUNuREosY0FETUc7R0FJK0I7WUFHdkN1QjtJQUNGLE9BUkVMLGNBN0lBL0MscUJBaUVBZTtHQXVGdUQ7WUFHdkRzQyxVQUFVckU7a0JBSUZzRSxnQkFBZUM7S0FDckI7TUFBSUM7UUFERUYsaUJBQ2dDLG1CQURqQkM7TUFJYjtRQUFBLHFCQUhKQzs7V0FLTSwyQ0FMTkE7TUFDQUMsV0FDRjtLQUtGLFdBUElELGtCQUNBQztJQU1vQjtJQVRwQixXQUFBLG1CQTFHTjVELGFBdUdVYjtJQUlQLE9BQUEsMEJBSk9BO0dBWWlCO0dBeUwzQixJQUFBMEUsNkJBcWF5QkM7WUFuYXJCQyxTQUFRckM7SUFBYSxJQUFBLHVCQUFZLE9BMVhyQ2hDLEtBMFhZZ0M7SUFBYSxPQUFBO0dBQW9EO1lBSTNFc0MsU0FBU2xFLFVBQVcsT0E5WHRCSixLQThYV0ksVUFBcUM7Ozs7Ozs7WUFLNUNtRSxTQUFRQztJQUFnQixPQUFRLG9CQUFBLHFCQW5ZcEN4RSxLQW1ZWXdFO0dBQStEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBTXZFQyxTQUFTaEYsR0FBSSxPQUFKQSxFQUFLO1lBQ2RpRixTQUFTL0UsR0FBSSxPQUFKQSxFQUFLO1lBQ2RnRixVQUFVbEYsR0FBRUU7SUFBSSxPQUFJLHFCQUFWRixHQUFVLHFCQUFSRTtHQUFnQjs7Ozs7Ozs7Ozs7Ozs7O0lBK2VOaUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBMWV4QkMsV0FBU2xGLEdBQUksT0FBSkEsRUFBSztZQUNkbUYsV0FBU3JGLEdBQUksT0FBSkEsRUFBSztZQUNkc0YsSUFBSXRGLEdBQUVFLEdBQUksT0FBQSxzQkFBTkYsR0FBRUUsR0FBUztZQUNmcUYsaUJBQWlCdkYsR0FBRUU7SUFBSSxPQUFHLHNCQUFURixHQUFhLG1DQUFYRTs7Y0FBNkMsc0JBQS9DRixHQUFFRTtHQUFrRDtZQUVyRXNGLElBQUl4RixHQUFFRSxHQUFJLE9BQUEsc0JBQU5GLEdBQUVFLEdBQVM7WUFDZnVGLEtBQUtyRixJQUFHQyxJQUFLLE9BQUEsc0JBQVJELElBQUdDLElBQVk7WUFNcEJxRixxQkFBcUIxRixHQUFFMkYsMkJBQ3pCLE9BQUEsb0JBRHVCM0YsR0FBRTJGO0dBQ1U7R0F2Q2pDOzs7Ozs7Ozs7SUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkVWO09BREFEOzs7T0FFQUU7Ozs7SUFyQkY7Ozs7Ozs7OztJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUE2SUpVLG1CQTVGS0MsVUFBTEM7d0IsT0E0RkFGLG1CQTVGS0M7O3dCLE9BNEZMRCxtQkE1RktDOztJQUFMLE9BQUE7O2FBbWQ0QlY7O2FBbmR2QlU7Ozs7YUFBTEM7R0FRb0I7WUF5NEJ0QkMsWUF2NEJPQyxVQUFMQzt3QixPQWtGQUwsbUJBbEZLSTtJQUFMLE9BQUEsdUNBQUFDO0dBQXdEOztJQXk0QnREQztJQXB6QkVDO0lBQ0FDO0lBT0FDO1lBQ0FDLElBQUlDLEdBQUV2RztJQUFJLHNDQUFOdUcsR0FBRXZHO0dBQTZCO1lBRW5Dd0csR0FBR0QsR0FBRXZHO0lBQUksc0NBQU51RyxHQUFFdkc7R0FBNkI7WUFFbEN5RyxNQUFNRixHQUFFdkc7SUFBSSxzQ0FBTnVHLEdBQUV2RztHQUE2QjtZQUNyQzBHLFlBQVlILEdBQUV2RztJQUFJLHNDQUFOdUcsR0FBRXZHO0dBQTZCO1lBRTNDMkcsS0FBS0osR0FBRXZHO0lBQUksc0NBQU51RyxHQUFFdkc7R0FBNkI7WUFDcEM0RyxTQUFTTCxHQUFFdkcsR0FBRTZHO0lBQUksT0FBQSwrQkFBUk4sR0FBRXZHLHlCQUFFNkc7R0FBK0I7WUFDNUNDLEtBQUtQLEdBQUV2RztJQUFJLHNDQUFOdUcsR0FBRXZHO0dBQTZCO1lBQ3BDK0csU0FBU1IsR0FBRXZHLEdBQUU2RztJQUFJLE9BQUEsK0JBQVJOLEdBQUV2Ryx5QkFBRTZHO0dBQStCO1lBQzVDRyxTQUFTVCxHQUFFdkcsR0FBSSxPQUFBLDhCQUFOdUcsR0FBRXZHLEdBQTZCO09Ba0J0Q2lILDJCQUNBQztZQUtGQyxnQkFBZ0JDLE1BQUtwSDtJQUN2QixHQXpCRWdILFNBd0JnQkksTUFBS3BILElBQ0MsT0FEREE7Ozs7R0FDMkQ7WUFRaEZxSCxLQUFLRCxNQUFLVCxNQUFLRztJQWxDZkMsU0FrQ0tLLE1BQUtULE1BQUtHO0lBQ2pCLE9BckNFRixTQW9DS1EsTUFBVU4sTUFBTEg7R0FFVztZQVdyQlcsS0FBS0YsTUFBS0csT0FBT0M7SUFDbkIsSUFBSUMsY0FEUUYsUUFFUkc7O1VBQUFBO0tBR1MsSUFBUEMsU0FyREpiLEtBZ0RLTSxNQUNISztLQUtGLFdBTmlCRCxHQUNmQztRQUlFRSxXQUxNSixPQUVSRyx3QkFEQUQsYUFJRUU7O0dBR0Y7WUE0QkZDLGVBQWVSLE1BQUtHLE9BQU9NO0lBQzdCO0tBQUlEO0tBQ0FILGNBRmtCRjtLQUdsQkc7O1VBQUFBLHNCQUZBRTtLQUlTLElBQVBELFNBekZKYixLQW9GZU0sTUFFYks7S0FjQyxHQUFBLG9CQTdHSG5CLElBNkZlYyxNQUViSyxhQUZ5Qkk7TUFpQlEsV0FoQmpDRCxtQkFnQmlDLE9BNUduQ3BCLEdBMkZlWSxNQUViSztNQURBRztPQWdCcUI7O1FBWm5CRCxXQUxnQkosT0FHbEJHLHdCQURBRCxhQUdFRTs7R0FlUztHQVlqQixTQXNCSUcsTUFBQXRGLEdBQUEsT0FBQUEsTUFBSztZQUhHdUYsZ0JBQUF2RixHQUFBLE9BQUFBLE1BQWU7WUFBZndGLG9CQUFBeEYsR0FBQUMsR0FBQUQsUUFBQUMsWUFBZTtZQURmd0YsZ0JBQUF6RixHQUFBLE9BQUFBLEtBQWU7WUFBZjBGLG9CQUFBMUYsR0FBQUMsR0FBQUQsT0FBQUMsWUFBZTtZQUhmMEYsT0FBQTNGLEdBQUEsT0FBQUEsS0FBTTtZQUFONEYsV0FBQTVGLEdBQUFDLEdBQUFELE9BQUFDLFlBQU07WUFGZDRGLHlCQUFBN0YsR0FBQSxPQUFBQSxLQUF3QjtZQUZ4Qm1ELDBCQUFBbkQsR0FBQSxPQUFBQSxLQUF5QjtZQUR6QjhGLGNBQUE5RixHQUFBLE9BQUFBLEtBQWE7WUFEYnVDLGNBQUF2QyxHQUFBLE9BQUFBLEtBQWE7WUFIYitGLFdBQUEvRixHQUFBLE9BQUFBLEtBQVU7WUFGVm5CLEtBQUFtQixHQUFBLE9BQUFBLEtBQUk7WUFGSmdHLE1BQUFoRyxHQUFBLE9BQUFBLEtBQUs7Z0JBb0JMQSxHQUFBQztJQUFBLFdBQUFELE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE9BQUFDO0dBQUs7R0FBTDs7SUFBQWdHLDhCQUFBLFNBQUssbUJBQUxYO2dCQUhRdEYsR0FBQUM7SUFBQSxXQUFBRCxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQyxHQUFBRDtHQUFlO0dBQWY7SUFBQSxVQUFBd0Y7SUFBQVU7O3VCQUFBLFNBQWU7OztPQUFmWDs7Z0JBREF2RixHQUFBQztJQUFBO1lBQUFEO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFDO1lBQUFEO1lBQUFBO0dBQWU7R0FBZjtJQUFBLFVBQUEwRjtJQUFBUzs7dUJBQUEsU0FBZTs7O09BQWZWOztnQkFIQXpGLEdBQUFDO0lBQUE7WUFBQUQ7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUE7WUFBQUM7WUFBQUQ7WUFBQUE7WUFBQUE7R0FBTTtHQUFOO0lBQUEsVUFBQTRGO0lBQUFRLCtCQUFBLFNBQU0sb0JBQU5UO2dCQUZSM0YsR0FBQUM7SUFBQTtZQUFBRDtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQztZQUFBRDtZQUFBQTtZQUFBQTtZQUFBQTtHQUF3QjtHQUF4Qjs7SUFBQXFHOzt1QkFBQSxTQUF3Qjs7O09BQXhCUjs7Z0JBRkE3RixHQUFBQztJQUFBO1lBQUFEO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFDO1lBQUFEO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO0dBQXlCO0dBQXpCOztJQUFBc0c7O3VCQUFBLFNBQXlCOzs7T0FBekJuRDs7Z0JBREFuRCxHQUFBQztJQUFBO1lBQUFEO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFDO1lBQUFEO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO0dBQWE7R0FBYjs7SUFBQXVHOzt1QkFBQSxTQUFhOzs7T0FBYlQ7O2dCQURBOUYsR0FBQUM7SUFBQTtZQUFBRDtZQUFBQTtZQUFBQTtZQUFBQztZQUFBRDtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtHQUFhO0dBQWI7O0lBQUF3Rzs7dUJBQUEsU0FBYTs7O09BQWJqRTs7aUJBSEF2QyxHQUFBQztJQUFBO1lBQUFEO1lBQUFBO1lBQUFDO1lBQUFEO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO0dBQVU7R0FBVjs7SUFBQXlHOzBCQUFBLFNBQVUseUJBQVZWO2lCQUZBL0YsR0FBQUM7SUFBQTtZQUFBRDtZQUFBQztZQUFBRDtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtHQUFJO0dBQUo7O0lBQUEwRyw2QkFBQSxTQUFJLG1CQUFKN0g7aUJBRkFtQixHQUFBQztJQUFBO1lBQUFBO1lBQUFEO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO1lBQUFBO0dBQUs7R0FBTDs7SUFBQTJHLDhCQUFBLFNBQUssb0JBQUxYO1lBRkpZLFlBQUtDO0lBc0JEO0tBVEFDO0tBRkFDO0tBREFDO0tBREFDO0tBSEFDO0tBRkFDO0tBRkFDO0tBYVFDO0tBR0FDO0tBQ0FDO0tBR1JDO0tBQUFDLFVBQUEsbUNBQUFEO0tBdEJKRSxpQ0FzQklEO0tBSFFFLFVBQUEsV0EyTmdCaEYsYUEzTmhCNEU7S0FuQlpLLG1DQW1CWUQsZUFuQlpEO0tBa0JZRyxVQUFBLFdBNE5nQmxGLGFBNU5oQjJFO0tBbEJaUSxtQ0FrQllELGVBbEJaRDtLQWVZRyxVQUFBLHNCQUFBVjtLQWZaVyxtQ0FlWUQsZUFmWkQ7S0FhSUcsVUFBQSxtQkFBQW5CO0tBYkpvQixtQ0FhSUQsZUFiSkQ7S0FXSUcsVUFBQSx3QkFBQXBCO0tBWEpxQixtQ0FXSUQsZUFYSkQ7S0FVSUcsVUFBQSxtQkFBQXJCO0tBVkpzQixtQ0FVSUQsZUFWSkQ7S0FTSUcsVUFBQSxzQkFBQXRCO0tBVEp1QixtQ0FTSUQsZUFUSkQ7S0FNSUcsVUFBQSxXQTJJdUJ0RyxhQTNJdkIrRTtLQU5Kd0IsbUNBTUlELGVBTkpEO0tBSUlHLFVBQUEsc0JBQUF4QjtLQUpKeUIsbUNBSUlELGVBSkpEO0tBRUlHLFVBQUEsc0JBQUF6QjtLQUZKMEIsbUNBRUlELGVBRkpEO0lBQUEsV0FBQUU7O1lBMEJJQyxLQUFLdkwsR0FBR3NHO0lBQU0sSUE5UTRCaUMsYUE4UXJDdkksTUE5UUkrRSxnQkE4UUovRTtJQTdRSSxPQUFBOzthQUFBOztlQUFTLHdCQTZRVnNHLEtBOVFDdkI7ZUFBaUN3RDtHQThRd0M7WUFDbEZpRCxVQUFVeEwsR0FBRXVMO0lBQU8sSUE1U1BySCxNQTRTRmxFO1lBQUV1TCxnQkE1U3lCLDBCQUF6QnJIO0dBNFM2QztZQUV6RHVILHVCQUFxQnpMLEdBQUdzRztJQUMxQixPQTlRRVoscUJBNlF3QlksS0FBSHRHO0dBQ2lDO1lBR3REMEwsd0JBQXdCMUwsR0FBRzJMO0lBRzdCLE9BQUcsb0JBSDBCQTs7Y0FKM0JGO2VBSXdCekwsR0FLTyxtQkFMSjJMO0dBS3lDO0dBSTFFLFNBT0lDLE9BQUFwSixHQUFBLE9BQUFBLEtBQU07WUFERXFKLG9CQUFBckosR0FBQSxPQUFBQSxLQUFtQjtZQUFuQnNKLHdCQUFBdEosR0FBQUMsR0FBQUQsT0FBQUMsWUFBbUI7WUFGbkJzSixRQUFBdkosR0FBQSxPQUFBQSxLQUFPO1lBQVB3SixZQUFBeEosR0FBQUMsR0FBQUQsT0FBQUMsWUFBTztZQUZQMkUsS0FBQTVFLEdBQUEsT0FBQUEsS0FBSTtZQUFKeUosU0FBQXpKLEdBQUFDLEdBQUFELE9BQUFDLFlBQUk7WUFESnlKLFNBQUExSixHQUFBLE9BQUFBLEtBQU07WUFBTjJKLGFBQUEzSixHQUFBQyxHQUFBRCxPQUFBQyxZQUFNO2lCQU1kRCxHQUFBQyxHQUFBLFdBQUFELE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFDLEdBQU07R0FBTjs7SUFBQTJKLCtCQUFBLFNBQU0scUJBQU5SO2lCQURRcEosR0FBQUMsR0FBQSxXQUFBRCxNQUFBQSxNQUFBQSxNQUFBQyxHQUFBRCxNQUFtQjtHQUFuQjtJQUFBLFdBQUFzSjtJQUFBTzs7dUJBQUEsU0FBbUI7OztPQUFuQlI7O2lCQUZBckosR0FBQUMsR0FBQSxXQUFBRCxNQUFBQSxNQUFBQyxHQUFBRCxNQUFBQSxNQUFPO0dBQVA7SUFBQSxXQUFBd0o7SUFBQU07MEJBQUEsU0FBTyxzQkFBUFA7aUJBRkF2SixHQUFBQyxHQUFBLFdBQUFELE1BQUFDLEdBQUFELE1BQUFBLE1BQUFBLE1BQUk7R0FBSjtJQUFBLFdBQUF5SjtJQUFBTSw2QkFBQSxTQUFJLG1CQUFKbkY7aUJBREE1RSxHQUFBQyxHQUFBLFdBQUFBLEdBQUFELE1BQUFBLE1BQUFBLE1BQUFBLE1BQU07R0FBTjtJQUFBLFdBQUEySjtJQUFBSzswQkFBQSxTQUFNLHVCQUFOTjtZQXNCUk8sU0FBU3pNLEdBQUksT0FBQSxxQkFBSkEsU0FBZ0I7WUFDekIwTSxXQUFXMU0sR0FBSSxPQUFKQSxnQkFBeUI7WUFDcEMyTSxrQkFBZ0IzTSxHQUFJLHdCQUFKQSxlQUFzQztZQUN0RDRNLGtCQUFnQjVNO0lBQW9DLFdBRnBEME0sV0FFZ0IxTTtJQUEwQix3QkFBMUJBO0dBQXFEO1lBRXJFNk0sY0FBYzdNLEdBQUd3SDtJQUNoQixXQUFBLHFCQURheEg7SUFDYjtLQUdEO01BRElvSCxPQUhVcEg7TUFJVjRMLFNBSlU1TDthQUlWNEw7OztVQUNKbEY7O09BQ2MsSUFBUm9HLHlCQUZGbEIsUUFDSmxGLGlCQUFBQTtPQUVLLEdBQUEscUJBRENvRztZQUdFaEYsUUFIRmdGLGtCQUdFaEY7O2FBQ0ppRjs7VUFDWSxJQUFOQyx1QkFGRmxGLE9BQ0ppRixnQkFBQUE7aUJBRVMsV0F2TlgzRyxTQXNOUTRHLE1BckpSMUYsS0E2SUVGLE1BUU00RixLQVhPeEY7VUFVYixXQUFBdUY7c0JBQUFBO2NBQUFBOzs7O09BTEosV0FBQXJHO21CQUFBQTtXQUFBQTs7Ozs7Ozs7R0FTSztZQTRDTHVHLCtCQUFrQzFLLFlBQVl3QztJQUNyQyxJQUFQMUQsT0F6eEJGbEIsU0F3eEJrQ29DLFlBQVl3QztJQUU3QyxHQUFBLGtCQURDMUQsTUF2d0JGeEI7SUEwd0JpQixXQWxaZmdGLFNBK1lBeEQ7SUFHZSxPQUFBO0dBQW1CO1lBb0hwQzZMLFVBQVNsTjtJQUNYLEdBeExFeU0sU0F1TFN6TSxJQUVOLE9BQUEsV0FoWURtRztJQWlZUSxLQUFBLFdBaFlSQyxTQTZYT3BHLGNBQUFBO0lBT21CO0tBRHhCb0gsT0FOS3BIO0tBT0xtTiw0QkFBNEIsV0FyWTlCaEg7S0FzWUVpSDtLQUNBMUc7S0FDQTJHLGVBaE1KWCxXQXNMUzFNOztLQVdILEtBQUEscUJBRkYwRyxnQkFDQTJHO01BVktyTixPQU9MbU47TUFQS25OLE9BUUxvTjthQVJLcE47O0tBWUs7YUFIVjBHO01BR0VvRyx5QkFaRzlNO0tBYUosR0FBQSxzQkFEQzhNLFVBSkZNO01BQ0ExRyxpQkFDQTJHO2FBT00scUJBTEpQO01BSEZwRzs7TUFjRTtPQUZFb0IsUUFURmdGO09BVUVRO2FBalBON0IsdUJBdU9JcUIsT0FjVSxrQkFkVkEsVUFaRzlNO09BNEJEdU4sYUExUE5oQyxLQTBPSXVCLE9BVUVROztrQkFNQUM7T0FHRixLQUFBLFdBNVpKbkgsMEJBa1pNMEI7O09BV0MsS0FBQSxzQkFWRHdGLGlCQWRKRjs7T0FvQklHLFlBelBOL0IsVUF5T0lzQixPQWdCRVM7T0FOQUQsa0JBeGdCTmhJLElBd2dCTWdJLGlCQVZGUjs7TUF5QlUsV0FUUlMsV0FTQWhHLHlCQWhCQU87YUFpQkcsV0FuYVQxQixTQWthTW1CO09BSWEsSUFBWEcscUJBQ0FELGNBTEZGOzthQUlFRztRQUdnQixJQUFkOEYsY0FqYVZsSCxJQTJYRWMsTUFvQ01LO1FBR0MsR0FBQSxzQkFEQytGLGFBcENSSjtTQURBRCwyQkFtQ00xRjtTQWxDTjJGLDJCQW9DUUk7O1FBS08sSUFBUDdGLFNBN1pWYixLQWtYRU0sTUFvQ01LOzs7U0FZMEIsR0FMeEJFLFdBWkpKLFdBaUI0QixxQkE3Q2hDYixvQkFpQ01lLGFBT0VFO1NBUkZEOzs7O01BaENOaEI7OztHQXNETTtZQW1CVitHLFFBQVFDLE9BcFpnQkM7SUFxWjFCO0tBclprQnBCLFNBb1pSbUI7S0FOcUNFLFFBamMzQ3RILElBbURjaUcsUUFBUW9CO0tBdVpsQixPQUFBLHNCQVR1Q0MsT0FqUTdDakIsa0JBdVFRZTtLQUdGO2NBQXNDLHNCQVRDRSxPQWhRN0NoQixrQkFzUVFjOztLQTNORyxJQUpUdEcsT0ErTk1zRyxVQTNORGxMO0tBekNQcUs7T0FvUVFhO2dCQTFObUJWO1FBQ3RCLFdBRkV4SyxNQUlhLE9BNU9sQmlFLE1Bb09BVyxNQUt5QjRGO1FBRHBCeEssZUE1T0w4RCxJQXdPQWMsTUFLeUI0Rjs7T0FLWjtLQUNaO01BakJEYSxXQWlCQywwQkFQSXJMO01BWExzTCxzQkFoQ0ZsQixrQkFzUVFjO01Bdk9OSyxzQkFoQ0ZwQixrQkF1UVFlO01BeE9WTTs7O1NBTE07VUFEQUM7VUFESkMsaUNBRUloUDtVQURBaVAsVUFBQSxXQWtKc0JoSixhQWxKdEI4STtVQURKRyxtQ0FDSUQsZUFESkQ7U0FBQSxXQUFBRTs7TUFVRUMsVUFBQSw0QkFBQVI7TUFISlMsbUNBR0lELGVBSEpMO01BRUlPLFVBQUEsV0EwSXdCcEosYUExSXhCMkk7TUFGSlUsbUNBRUlELGVBRkpEO01BQ0lHLFVBQUEsV0EySXdCdEosYUEzSXhCNEk7TUFESlcsbUNBQ0lELGVBREpEOzs7O21DQTRJNEJySixhQTFLMUJ5SCxrQkFzUVFjO21DQXhPVmdCOzs7O21DQTRJNEJ2SixhQTNLMUJ3SCxrQkF1UVFlOzs4Q0E1RmtCdkksYUFzRm1CeUk7Ozs7Ozs7O0lBYTNCLElBQWRsSDs7Z0JBQUFBO0tBQ0U7O09BQUE7b0JBZHVDa0gsd0JBTXJDRjs7S0FPSmhIOztJQU1NO0tBOWNZaUksZ0JBd2NsQmpJO0tBVnNFb0cseUJBR2xFWSxVQWpjY2lCLG1CQUFBQTtLQStjaEIsT0FBQSxzQkFwQnVDZixPQUc2QmQ7S0FpQnBFLGNBQXdDLHNCQXBCRGMsT0FHNkJkOzs7Ozs7Ozs7O2VBdlU1RTFELDRCLGVBdVU0RTBEOzs4Q0F6RmhEM0gsYUFzRm1CeUk7Ozs7Ozs7O0lBRzZCZCxXQUFBQTtJQTliaEQ7MEJBNkNWUCxRQUFRb0IsOEJBN0NGZ0I7SUFtZGI7S0FBUHBCLFNBbFVBaEMsS0E2U3dFdUIsT0FIN0JjO0tBeUIzQzlGLFFBdEJ3RWdGO0tBalpyRHZGLHlCQXVhbkJPLE9BREF5RixZQUFBQTtJQUdHLEdBQUEsV0FwZUhuSCxTQTJEbUJtQjtLQTRhckIsaUJBTEVPLE9BREF5RixZQUFBQSxVQXRhc0JJO0tBRkEsT0FMdEJ0RyxLQU9ja0YsUUFBUW9CLFFBQUFBOztJQUNiLElBQVBpQixTQTdDRmpJLEtBNENjNEYsUUFBS2hGO0lBUG5CRixLQU9ja0YsUUFDWnFDLFFBRG9CakI7SUFFeEIsT0FURXRHLEtBT2NrRixRQUFRb0IsUUFBSHBHO0dBNmFjO1lBR25Dc0gsaUJBQWlCN08sR0FBRWdOO0lBQ1gsSUFBTlksUUFwZUF0SCxJQW1lZXRHLE1BQUVnTjtJQUVsQixHQUFBLHNCQURDWSxPQURlNU4sT0FBQUEsT0FBRWdOLEtBQUZoTixPQUNmNE47SUE3QkZILFFBNEJpQnpOLEdBQUVnTjtJQUFGaE4sT0FBQUE7O0dBT0s7WUFZdEI4TyxpQkFBaUI5TyxHQUFHc0c7SUFDdEI7S0FBRyxPQUFBLHNCQURtQkEsS0F0VHBCcUcsa0JBc1RpQjNNO0tBQ2hCLGVBQXFDLHNCQURsQnNHLEtBclRwQnNHLGtCQXFUaUI1TTtJQUNxQixXQUFyQzs7OztxQ0E1SXlCbUYsYUExSzFCeUgsa0JBcVRpQjVNOzs7O3FDQTNJU21GLGFBM0sxQndILGtCQXNUaUIzTTs7NkNBM0lTbUYsYUEySU5tQjs7Ozs7OztHQUVVO1lBRzlCeUksYUFBYS9PLEdBaGdCRXNHLEtBQUtFLElBQUlDO0lBMmZ4QnFJLGlCQUthOU8sR0FoZ0JFc0c7SUFrZ0JkLEdBQUEsV0EvZEdZLFNBNmRTbEgsT0FBQUEsT0FFb0MsV0FoZTdDaUgsU0E4ZFNqSDtJQS9mcUM7S0FEekNvSCxPQWdnQklwSDtLQS9mcUMsT0FBQSxXQUxoRG1HO0tBS3NDLE9BQUEsV0FMdENBO0tBdWdCQTZHO09BbGdCZ0QsK0JBRHpDNUYsTUFBTWQsS0FBS0UsSUFBSUM7SUF3ZXhCb0ksaUJBd0JhN08sR0FHWGdOO0lBQ0osT0FESUE7R0FFRDtZQXFMRGdDLGdCQUFnQmhQLEdBOW9CRmdOO0lBK29CaEIsSUEvb0JXNUYsT0E4b0JPcEgsTUE1ckJMSyxLQTRyQktMO0lBRWYsR0E5ckJlLGlDQThDRmdOLEtBOUNIM007S0E0ckJLTCxPQUlILFdBbHNCWG1HO0lBOHJCY25HLE9BQUFBO0lBUUk7S0FBQSxPQXhyQmxCMEcsWUFrQ09VLE1BQUs0RjtLQXNwQlpGLHlCQVJjOU07SUFRZDhNLFdBQUFBO0lBR087S0FEUGhGLFFBRkFnRjtLQUdBUyxTQXppQkFoQyxLQXNpQkF1QixPQTdyQkF4RyxJQXVDT2MsTUFBSzRGO0tBMHBCWnpGLHlCQUZBTyxPQUNBeUYsWUFBQUE7T0F6cEJZUCxRQTlCWmxHLEtBOEJPTSxNQUFLNEY7S0E2cEJFLFdBQUEsV0E3c0JkN0c7S0E2c0JGLGlCQUxFMkIsT0FDQXlGLFlBQUFBO0tBSUY7O09BN3BCY1AsUUEwcEJaekY7S0FLMkMsV0E3ckIzQ1QsS0E4Qk9NLE1BQUs0RjtLQStwQmUsaUJBUDNCbEYsT0FDQXlGLFlBQUFBOztJQXhwQjBCLFdBL0IxQnpHLEtBOEJPTSxNQUFLNEY7SUE3QlpqRyxTQTZCT0ssTUFoQ1BULEtBZ0NPUyxNQUFLNEY7SUFFYyxXQWxDMUJyRyxLQWdDT1MsTUFBSzRGO0lBRWMsT0FqQzFCcEcsU0ErQk9RLE1BOUJQTixLQThCT00sTUFBSzRGO0dBZ3FCZTtHQW41QjdCO0lBQUE7OztPQXVqQjBCN0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTFleEJDO09BQ0FDOzs7T0FDQUM7T0FHQUU7T0FDQUM7Ozs7SUEwNEJKd0o7R0FLSixTQVFJQyxlQUFBMU0sR0FBQSxPQUFBQSxLQUFjO1lBRE4yTSx1QkFBQTNNLEdBQUEsT0FBQUEsS0FBc0I7WUFBdEI0TSwyQkFBQTVNLEdBQUFDLEdBQUFELE9BQUFDLFlBQXNCO1lBRHRCNE0sdUJBQUE3TSxHQUFBLE9BQUFBLEtBQXNCO1lBQXRCOE0sMkJBQUE5TSxHQUFBQyxHQUFBRCxPQUFBQyxZQUFzQjtZQUR0QjhNLElBQUEvTSxHQUFBLE9BQUFBLEtBQUc7WUFBSGdOLFFBQUFoTixHQUFBQyxHQUFBRCxPQUFBQyxZQUFHO1lBRFhnTixpQkFBQWpOLEdBQUEsT0FBQUEsS0FBZ0I7WUFGaEJrTixNQUFBbE4sR0FBQSxPQUFBQSxLQUFLO1lBRExtTixPQUFBbk4sR0FBQSxPQUFBQSxLQUFNO2lCQU9OQSxHQUFBQyxHQUFBLFdBQUFELE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFDLEdBQWM7R0FBZDs7SUFBQW1OOzt1QkFBQSxTQUFjOzs7T0FBZFY7O2lCQURRMU0sR0FBQUMsR0FBQSxXQUFBRCxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQyxHQUFBRCxNQUFzQjtHQUF0QjtJQUFBLFdBQUE0TTtJQUFBUzs7dUJBQUEsU0FBc0I7OztPQUF0QlY7O2lCQURBM00sR0FBQUMsR0FBQSxXQUFBRCxNQUFBQSxNQUFBQSxNQUFBQSxNQUFBQyxHQUFBRCxNQUFBQSxNQUFzQjtHQUF0QjtJQUFBLFdBQUE4TTtJQUFBUTs7dUJBQUEsU0FBc0I7OztPQUF0QlQ7O2lCQURBN00sR0FBQUMsR0FBQSxXQUFBRCxNQUFBQSxNQUFBQSxNQUFBQyxHQUFBRCxNQUFBQSxNQUFBQSxNQUFHO0dBQUg7SUFBQSxXQUFBZ047SUFBQU8sNEJBQUEsU0FBRyxrQkFBSFI7aUJBRFIvTSxHQUFBQyxHQUFBLFdBQUFELE1BQUFBLE1BQUFDLEdBQUFELE1BQUFBLE1BQUFBLE1BQUFBLE1BQWdCO0dBQWhCOztJQUFBd047O3VCQUFBLFNBQWdCOzs7T0FBaEJQOztpQkFGQWpOLEdBQUFDLEdBQUEsV0FBQUQsTUFBQUMsR0FBQUQsTUFBQUEsTUFBQUEsTUFBQUEsTUFBQUEsTUFBSztHQUFMOztJQUFBeU4sOEJBQUEsU0FBSyxvQkFBTFA7aUJBREFsTixHQUFBQyxHQUFBLFdBQUFBLEdBQUFELE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQUFBLE1BQU07R0FBTjs7SUFBQTBOLCtCQUFBLFNBQU0scUJBQU5QO1lBY0FRLHFCQUFnQm5RO0ksbURBQUFBOztZQUNoQm9RLGtCQUFnQnBRLEdBQUksT0ExcUNsQjhDLGdCQTBxQ2M5QyxNQUFtQztZQU1qRHFRLEtBQUdDLElBcG5CSXRRO0lBb25CRyxJQXBuQkx1RyxJQW9uQkYrSixPQXBuQitCLE9BckpoQ25KLGdCQXFKR1osTUFBRXZHO0lBQTJCLE9BdExoQ3dHLEdBc0xHRDtHQW9uQjhDO1lBQ25EZ0ssUUFBTUQsSUFubkJJdFE7SUFtbkJHLElBbm5CTHVHLElBbW5CRitKLE9Bbm5Ca0MsT0F2SnRDbkosZ0JBdUpNWixNQUFFdkc7SUFBOEIsT0F0THRDeUcsTUFzTE1GO0dBbW5CaUQ7WUFDekRpSyxhQUFhRixJQXJuQkx0UTtJQXFuQlksSUFybkJkdUcsSUFxbkJPK0osT0FybkJ1QixPQXRKbENuSixnQkFzSklaLE1BQUV2RztJQUE0QixPQXpMbENzRyxJQXlMSUM7R0FxbkJ3RDtZQUloRWtLLE9BQUt6USxHQUFHd0gsR0FBSSxJQTlsQkx0RCxNQThsQkZsRSxNQTlsQlMsT0FqQlo2TSxjQWlCSzNJLEtBOGxCQ3NELEdBQTJDO1lBVy9Da0osVUFBUXRRLElBQUdDO0lBQUssT0FBd0IsNkNBQWhDRCxPQUFHQztHQUFvQztZQTZCbkRzUSxhQUFVQyxXQUFVNVE7SUFDdEI7S0F4Qkk2USx1QkF1QmtCN1E7S0F4QmxCOFEsWUF3QmtCOVE7S0F6QmxCK1EsYUF5QmtCL1E7S0F0QmxCZ1IsVUFzQmtCaFI7S0FObEJ3QztJQWxDRmlPO01Bd0NvQnpRO2VBTFBpUjtPQUFLLFdBRGhCek8sTUF4Qm9ELE9BZnBEK04sUUE2Q2tCdlEsR0FMUGlSO09BRFh6TyxlQXhDQTZOLEtBOENrQnJRLEdBTFBpUjs7TUFBdUM7SUFDekMsSUFqQlRDLGFBaUJTLDBCQUZUMU8sTUF2QkVrTyxZQUdOUzs7S0FSTTtNQUFBQztNQURBQztNQUNBQyxVQUFBLFdBa0NNVixXQWxDTlE7TUFGSkcsaUNBRUlEO01BREFFLFVBQUEsNENBQUFIO01BREpJLG1DQUNJRCxlQURKRDtLQUFBLFdBQUFFOztJQWVFO0tBQUFDLFVBQUEsNEJBQUFSO0tBTEpTLG1DQUtJRCxlQUxKUDtLQUlJUyxVQUFBLDRDQUFBWjtLQUpKYSxtQ0FJSUQsZUFKSkQ7S0FHSUcsVUFBQSxvQkFBQWpCO0tBSEprQixtQ0FHSUQsZUFISkQ7S0FFSUcsVUFBQSw0Q0FBQWxCO0tBRkptQixtQ0FFSUQsZUFGSkQ7S0FDSUcsVUE1c0NKblAsWUE0c0NJZ087S0FESm9CLG1DQUNJRCxlQURKRDtJQUFBLFdBQUFFO0dBNkI0QztZQUcxQ0MsU0FBT3BTLEdBQUksT0FBSkEsUUFBMEM7WUFDakRxUyxXQUFTclM7SUFBSSxXQURib1MsU0FDU3BTO0lBQUksT0FBQTtHQUFZO1lBZXpCc1MsT0FBS3RTLEdBQUksT0FBSkEsUUFBd0M7WUFFN0N1UyxzQkFBdUJDLE1BQU0xUDtJQUMvQjtLQW55QzRDLE9BQUEsNENBa3lDbkIwUDtLQWx5Q0MsT0FBQSxpQ0FreUNLMVA7SUFDVCxPQUFBO0dBQW1EO1lBR3ZFMlAsdUJBQXVCelMsR0FBRXdTO0lBQzNCLE9BTEVELHNCQUl5QkMsTUFBRnhTO0dBQzRDO1lBR25FMFMsZUFBYTFTLEdBQUV3UztJQUNqQixHQUFHLDZDQURjQSxNQXo3Q2Y1Uzs7Ozs7b0VBeTdDZTRTOzs7Ozs7O0tBR2Y7O0lBQUEsT0FQQUMsdUJBSWF6UyxHQUFFd1M7R0FNWTtZQUczQkcsNkJBQTZCM1MsR0FBRXdRO0lBQ2pDO0tBbHpDeUJrQyxpQkFvekN2QixxQkFIK0JsQztLQWp6Q1Z0TSxNQWl6Q1FsRTtLQWh6QzdCLE9BQUEsMkJBRHVCMFMsZ0JBQUZ4TztJQUNyQixPQUFBO0dBbXpDdUM7WUFtQnZDME8sbUJBQW1CNVMsR0FBRXdRO0lBQ3ZCLEdBQUcsb0JBRG9CQSxjQXhJckJ2Qjs7O2tEQUFBQTs7a0RBd0lxQnVCOzs7Ozs7OztJQUdwQixHQUFBLG9CQUhvQkEsY0FBRnhROzt1REFBQUE7O2tEQUFFd1E7Ozs7Ozs7O0lBSWxCLE9BMUJIbUMsNkJBc0JtQjNTLEdBQUV3UTtHQUtvQjtZQUd6Q3FDLDZCQUE2QjdTLEdBQUVzRztJQU1qQyxPQWRFc00sbUJBUTZCNVMsR0FNVixxQkFOWXNHO0dBTUU7WUFHakN3TSxvQkFBb0I5UztJQUNaLElBQU5nTixNQXRqQkFFLFVBcWpCa0JsTjtJQUVuQixHQUFBLFdBcDdCR29HLFNBbTdCRjRHLE1BRUM7SUFFTyxJQUFOWSxRQS82QkF0SCxJQWczQkpnTSxPQTBEb0J0UyxJQUNsQmdOO0lBS0MsT0FBQSxvQkFEQ1ksT0FMZ0I1Tjs7a0JBVHBCNlMsNkJBU29CN1MsR0FLaEI0TjtHQUcyQztZQUcvQ21GLHdCQUF3QkM7SUFDaEIsSUFBTmhHLE1BamtCQUUsVUFna0JzQjhGO0lBRXZCLEdBQUEsV0EvN0JHNU0sU0E4N0JGNEc7Ozs7Ozs7OztlQTVGRjJELDZCLGVBMkZ3QnFDOzs7Ozs7Ozs7SUFHaEIsSUFBTnBGLFFBeDdCRXRILElBZzNCSmdNLE9BcUV3QlUsUUFDdEJoRztJQUdELEdBQUEsb0JBRENZLE9BSHNCb0Y7Ozs7Ozs7OztlQTNGeEJyQyw2QixlQTJGd0JxQzs7Ozs7Ozs7O0lBS3JCLE9BekJISCw2QkFvQndCRyxPQUd0QnBGO0dBRzhCO1lBR2hDcUYsK0JBQStCalQ7SUFDWCxJQUFsQitILGtCQTl2QkE2RSxrQkE2dkI2QjVNO0lBRTlCLEdBQUEsb0JBREMrSCxpQkFENkIvSCxPQWxnRGlCLE9BSWhETDtJQXFnRHNCOztLQUFBLE9BL0p0QnlRLGtCQXdKK0JwUTtLQU83QixPQUFBO0tBREEsT0FqRUYyUyw2QkEyRCtCM1MsR0FDN0IrSDtJQU1BLE9BQUE7R0FBZ0U7WUFHbEVtTCxpQkFBaUJsVCxHQUFJLE9BeHdCbkIyTSxrQkF3d0JlM00sTUFBbUQ7WUFFcEVtVCwrQkFBK0JuVCxHQUFJLE9BaEZuQzBTLGVBZ0YrQjFTLEdBQUFBLE1BQTZDO1lBQzVFb1QsZUFBZXBULEdBQUV3UztJQUFPLE9BeEV4QkcsNkJBd0VlM1MsR0FqRmYwUyxlQWlGZTFTLEdBQUV3UztHQUEyRDtZQUU1RWEsWUEvN0JtQkMsYUErN0JHdFQ7O2NBRWxCdVQsTUFBTS9MLEdBQUksT0FBQSw4QkFGUXhILEdBRVp3SCxHQUE2QjtLQWlDckI7TUExTmRnTTtRQXlMQUQ7bUJBM3NCb0J2VDtlQWhNYm9ILE9BZ01hcEg7O3FCQXVFbEJ1VCxNQUFNL0wsR0FBSSxPQUFBLDhCQXZFUXhILEdBdUVad0gsR0FBNkI7WUFDaEMsS0FBQSxzQkE1SVBtRixrQkFvRXNCM007YUF3RXRCLE1BQUE7WUFDdUMsV0E3SXZDMk0sa0JBb0VzQjNNO1lBeUVmLEtBQUEsc0JBNUlQNE0sa0JBbUVzQjVNO2FBeUV0QixNQUFBO1lBa0JJO2FBeExBeVQ7ZUFvS0FGOzBCQW9CWTNIO2tCQUNELFdBaktmYyxXQXFFc0IxTTtrQkE0RlIsS0FBQTttQkFBUCxNQUFBOztnQ0FDMkIyTyxlQUFZN0I7bUJBQ3JDLEtBQU8scUJBRGtCNkIsZUFBWTdCO29CQUNyQyxNQUFBOzs7NkJBMUZIeUcsTUFBTS9MO3FCQUFJLE9BQUEsOEJBeUY4QnNGLE9BekZsQ3RGO29CQUFpQztvQkFzRHZDO3FCQWpNQWtNO3VCQTJJQUg7a0NBc0RZekw7d0NBaFRXa0Y7MkJBa1RYLGVBQUEsV0F4VWhCNUcsU0FzQjJCNEc7c0NBa1RYOzs0QkFoVGhCLEtBTEFoRyxTQXlET0ksTUF0RG9CNEY7NkJBRTNCLE1BQUE7OzRCQUNBLFdBSGVzRyxhQVZmN00sTUFnRU9XLE1BdERvQjRGOzRCQUluQixJQUFKMkcsSUFUSjdNLEtBMkRPTSxNQXREb0I0Rjs0QkFLbkIsS0FBQSxXQTNCUjVHLFNBMEJJdU47NkJBQ3NDLFdBWjFDaE4sS0E2RE9TLE1BbERIdU07NkJBQ2lCLEtBQUEsaUNBTE0zRzs4QkFLM0IsTUFBQTs7OzRCQUNRLElBQUp6RyxJQWJKSSxLQTZET1MsTUF0RG9CNEY7NEJBT25CLEtBQUEsV0E3QlI1RyxTQTRCSUc7NkJBQ3NDLFdBWjFDTyxLQTJET00sTUFoREhiOzZCQUNpQixLQUFBLGlDQVBNeUc7OEJBTzNCLE1BQUE7Ozs7MkJBQXdEO3lDQU5qQjRHOzRCLE9BMHhCN0M3Tiw0QixjQTF4QjZDNk47OzJCQUFLLG1DQURqQjVHOzJCQXFUYyxPQTFRekMxRjtvQ0FXT0Y7b0NBdERvQjRGOzZDQXFUbUJBO3FDQUNqQyxXQTZCK0JGO3FDQTdCeEIsS0FBQSxzQkFwVXBCeEcsSUFvRU9jLE1BK1B1QzRGO3NDQUNqQyxNQUFBOztnREE2QitCRjtxQ0E1QnhCLEtBQUEsc0JBclVwQnhHLElBb0VPYyxNQStQdUM0RjtzQ0FFakMsTUFBQTs7Z0RBakVPaE47cUNBa0VBLEtBQUEsc0JBdFVwQnNHLElBb0VPYyxNQStQdUM0RjtzQ0FHakMsTUFBQTs7cUNBQ1EsV0EwQnVCRixVQTFCdkIsT0FsVXJCcEcsWUErRE9VLE1BK1B1QzRGO3FDQUkxQixHQUFBO3NDQUNLLE9BQUEsV0ExVFZzRyxhQVZmN00sTUFnRU9XLE1BK1B1QzRGO3FDQUlqQyxNQUFBOztvQ0FDeUM7MEJBQUU7MEJBVDdCLE9BQUEsMkJBRFhsRjt5QkFVeUM7cUJBM01yRCtMO3VCQTJJQU47a0NBK0NrQnhMOzBCQUFmOzJCQUFlK0wsU0FuYnRCdk8saUJBNmQ0Q3VILFVBQUFBOzJCQTFDdEJpSDsyQkFBQUM7MkJBQUFDO21DQUFBQyxXQUFBQyxPQUFBQzsyQkFBQSxPQUFBLHNCQUFBRCxPQUFBQzswQkFBSzs7O21DQUFMM1U7bUNBb0RFMEY7bUNBcERGK087bUNBQUFEO21DQUFBRDttQ0FBQUQ7bUNBQUFEO21DQUFBL0w7eUJBS3VCO3FCQS9MekNzTTt1QkEySUFkO2tDQXNDWXRMOzBCQUNULEtBQU8sc0JBREVBOzJCQUNULE1BQUE7OzBCQUNHO2tDQUFBLHNCQUZNQTswQkFFTixXQUFBOzBCQUdDOzJCQURhcU0sTUFDYixnQkFMS3JNLGlCQW1ENEI2RTsyQkEvQ3BCZ0g7MkJBQUFTOzJCQUFBUjsyQkFBQUM7MkJBQUFDO21DQUFBQyxXQUFBTSxPQUFBQzsyQkFBQSxPQUFBLG1CQUFBRCxPQUFBQzswQkFBVTs7O21DQUFWalY7bUNBQUErVTttQ0FBQUw7bUNBQUFEO21DQUFBRDttQ0FBQUQ7bUNBQUFEO21DQUFBUTt5QkFFUTtxQkF2TDVCSTt1QkEySUFuQjtrQ0E4QllwTDt3Q0FHa0N3TCxHQXJPdENwTTsyQkFzT0MsR0FBRyxXQWxUaEJuQixTQTRFWW1CLFFBdU9NLE9BRmdDb007MkJBcE81QyxJQUFKblIsWUFDQWlGLGNBRlVGLFFBR1ZHOztpQ0FBQUEsc0JBa09nRGlNLElBcE9oRG5SOzRCQUFBQTs0QkFLUyxJQUFQbUYsU0FqRUpiLEtBMkRPTSxNQUVMSzsrQkFJRUUsV0FOUUo7NkJBR1ZHOzs2QkFEQUQsYUFJRUU7OzBCQWtPOEM7MEJBSHZDLFdBQUEsMkJBd0RpQ21GOzBCQTFEOUIsR0FBQSxxQkFERTNFOzBCQUNULE1BQUE7O3lCQUs2QztxQkFaN0IyTCxTQW5DekI3RywrQkFvRzhDSCxVQUFBQTtxQkFwT3hDNkg7dUJBMklBcEI7a0NBd0JtQnFCOzhCQUFBTCxvQkFBQVIsV0FBQUMsYUFBQUM7bUNBQUFDLFdBQUFXLE9BQUFDOzJCQUFBLE9BQUEsbUJBQUFELE9BQUFDOzBCQUFVOzs7bUNBQVZ2VjttQ0FBQWdWO21DQUFBTDttQ0FBQUQ7bUNBQUFEO21DQUFBRDttQ0FBQUQ7bUNBQUFjOztxQkFuS25CRzt1QkEySUF4QjtrQ0FpQlk1TjswQkFDVDs0QkFBTzt1Q0FERUEsMkJBcmFkYixTQTZlMENnSTs7MEJBdkVyQyxNQUFBOzt5QkFHMEU7cUJBaEs3RWtJO3VCQTJJQXpCO2tDQWFrQmpMOzBCQUFmOzJCQUFld0wsU0F0YXRCalAsU0FrZjRDaUk7MkJBNUV0QnlIOzJCQUFBUjsyQkFBQUM7MkJBQUFDO21DQUFBQyxXQUFBZSxPQUFBQzsyQkFBQSxPQUFBLG1CQUFBRCxPQUFBQzswQkFBVTs7O21DQUFWNVY7bUNBQUFpVjttQ0FBQUw7bUNBQUFEO21DQUFBRDttQ0FBQUQ7bUNBQUFEO21DQUFBeEw7eUJBRTZCO3FCQTFKL0M2TTt1QkEySUE1QjtrQ0FTWXhPOzBCQUNULEdBQU8sbUJBREVBOzBCQUNULE1BQUE7O3lCQUE0RDtxQkFKNUNxUSxXQW5hckJ4USxTQXNmMENrSTtxQkFwT3hDdUk7dUJBMklBOUI7a0NBTW1CcUI7OEJBQUFiLFdBQUFDLGFBQUFDO21DQUFBQyxXQUFBb0IsT0FBQUM7MkJBQUEsT0FBQSxXQXJhekI3USxXQXFheUI0USxPQUFBQzswQkFBWTs7O21DQUFabFc7bUNBQUFzRjttQ0FBQXVQO21DQUFBRDttQ0FBQUQ7bUNBQUFEO21DQUFBcUI7bUNBQUFSOztxQkFqSm5CWTt1QkEySUFqQztrQ0FHZ0JsUzswQkFBUSxHQUFPLHFCQUFmQTswQkFBUSxNQUFBOzt5QkFBa0Q7cUJBOUkxRW9VO3VCQTJJQWxDO2tDQUVpQi9LOzBCQUFTLEdBQU8scUJBQWhCQTswQkFBUyxNQUFBOzt5QkFBbUI7b0JBN0k3QyxXQUFBaU4sV0FFSnRNO29CQUZJLFdBQUFxTSxVQUlKdE07b0JBSkksV0FBQW1NLGdCQU1KcE07b0JBTkksV0FBQWtNLG1CQVNKbk07b0JBVEksV0FBQWdNLG1CQVVKak07b0JBVkk7c0JBQUFnTSwrQkFXSmpNO29CQVhJO3NCQUFBNkwsOEJBYUo5TDtvQkFiSSxXQUFBNkwsWUFlSTlMO29CQWZKLFdBQUF5TCxxQkFrQkkxTDtvQkFsQkosV0FBQWtMLHFCQW1CSW5MO29CQUdSLE9BQUEsV0F0QklnTCxXQXNCSmpMO21CQXFMMkQ7aUNBakVoQmlOO29CLE9BMUkvQ3RNLDRCLGVBMEkrQ3NNOzttQkFBVyxvQ0EwRlY1STttQkFHbEMsV0FBQSxxQkFIc0I2QjttQkFHdEIsV0FBQTttQkFDRTtvQkFBQSxPQUpvQkE7b0JBS25CZ0gsOEJBUEMvSjtvQkFTVTBJLE1BUG9CeEg7b0JBT3BCZ0gsU0FFTCxvQkFKTjZCO29CQUVXcEI7b0JBQUFSO29CQUFBQztvQkFBQUM7NEJBQUFDLFdBQUEwQixPQUFBQztvQkFBQSxPQUFBLG1CQUFBRCxPQUFBQzttQkFBVTs7O3FCQUFWelc7cUJBQUFtVjtxQkFBQUw7cUJBQUFEO3FCQUFBRDtxQkFBQUQ7cUJBQUFEO3FCQUFBUTttQkFNWDtvQkFIV3dCLFFBVm9CaEo7b0JBVXBCc0ksV0E3TXhCMUosd0JBbU00Q29CLE9BSy9CNkk7b0JBS1dsVTtvQkFBQXNVO29CQUFBQzs0QkFBQUMsYUFBQUMsT0FBQUM7b0JBQUEsT0FBQSxzQkFBQUQsT0FBQUM7bUJBQUs7Ozs0QkFBTGhYOzRCQUFBZ0c7NEJBQUE4UTs0QkFBQUQ7NEJBQUFEOzRCQUFBdFU7NEJBQUEyVDs0QkFBQVU7a0JBS2dEO2tCQWY3QyxPQUFBLDJCQUZibEs7aUJBaUIyRDthQXpNdkV3SztlQW9LQTdDOzBCQWFZMUg7a0JBQ1Q7O29CQUFPO2lDQURFQSxxQkF4SmhCYyxrQkFvRXNCM007bUJBcUZmLE1BQUE7O2tCQUNPOztvQkFBQTtpQ0FGRTZMLHFCQXZKaEJlLGtCQW1Fc0I1TTttQkFzRmYsTUFBQTs7a0JBQ08sZUFBQSxXQW5XWm9HLFNBNFFvQnBHOzZCQXVGUjtrQkFFRTtvQkFBQSxvQkFMQTZMLHFCQXhWZHZGLElBb1FvQnRHLE1BQUFBOztrQkF5RmIsTUFBQTs7aUJBQTBFO2FBdEwvRXFXO2VBb0tBOUM7MEJBT1l2RztrQkFDRixlQUFBLFdBM1ZaNUcsU0EwVmM0Rzs2QkFDRjtrQkFFRSxLQTFVZGhHLFNBeVBvQmhILE1BOEVOZ047bUJBR1AsTUFBQTs7a0JBQ3dDLFdBdFYvQzFHLElBb1FvQnRHLE1BOEVOZ047a0JBSUEsR0FBQSxvQkFsRk1oTjtrQkFrRmIsTUFBQTs7aUJBQXdFO2FBL0s3RXNXO2VBb0tBL0M7MEJBaFR1QnZUO3NDO2tCQUFJLE9BQUEsb0NBQUpBOzthQTRJdkIwVTtlQW9LQW5COzBCQUlrQnBMO2tCQUFVLEdBQU8scUJBQWpCQTtrQkFBVSxNQUFBOztpQkFBb0I7WUF4S2hELFdBQUF1TSxZQUNJbEk7WUFESixXQUFBOEosVUFFSS9KO1lBRkosV0FBQThKLGFBSUkvSjtZQUpKLFdBQUE4Six5QkFNSS9KO1lBQ1IsT0FBQSxXQVBJb0gsWUFPSnJIO1dBa002RTt5QkF0Q3RDbUs7cUJBalRsQ0MsZ0I7O2FBK0lHQyxhQWtLK0JGO2FBalR2Q0csV0FpVHVDSDthQS9KL0JJLGNBK0orQko7YUE3Si9CSywwQkE2SitCTDthQTVKdkNNLGFBNEp1Q047YUFuSzNDTztnQyxPQTFDRTFOLFlBcEdPb047WUFxSkw7YUFBQU8sVUFBQSw0QkFBQUY7YUFQSkcsbUNBT0lELGVBUEpEO2FBTVlHLFVBQUEsV0E4TGtCOVIsYUE5TGxCeVI7YUFOWk0sbUNBTVlELGVBTlpEO2FBSVlHLFVBOG5CWnBSLFlBaHhCU3lRLFVBa0pHRzthQUpaUyxtQ0FJWUQsZUFKWkQ7Z0MsT0FuTEV0UixtQkFxQ080UTtZQUFMO2FBZ0pRYSxVQWhKUixvQ0FBQVg7YUE4SUpZLG1DQUVZRCxlQUZaRDthQUNZRyxVQUFBLHNCQUFBZDthQURaZSxtQ0FDWUQsZUFEWkQ7WUFBQSxXQUFBRTs7V0FtS3lELE9BQUEsb0NBdEUvQnhYOztNQWtoQnBCeVg7UUF5TEFsRTttQkE4QmtCcEU7V0FBZjtZQUFlMkUsU0EvQ3RCYiwrQkFlc0JqVDtZQWdDQXVVO1lBQUFSO1lBQUFDO1lBQUFDO29CQUFBQyxXQUFBd0QsT0FBQUM7WUFBQSxPQUFBLDZDQUFBRCxPQUFBQztXQUFTOzs7b0JBQVQxWTtvQkFBQXNWO29CQUFBTDtvQkFBQUQ7b0JBQUFEO29CQUFBRDtvQkFBQUQ7b0JBQUEzRTtVQUU2QjtNQXpOL0N5STtRQXlMQXJFO21CQXlCa0JsRTtXQUFmO1lBQWV5RSxTQS9FdEJsQixtQkFvRHNCNVMsR0FMdEJrVCxpQkFLc0JsVDtZQTJCQXVVO1lBQUFSO1lBQUFDO1lBQUFDO29CQUFBQyxXQUFBMkQsT0FBQUM7WUFBQSxPQUFBLDZDQUFBRCxPQUFBQztXQUFTOzs7b0JBQVQ5WTtvQkFBQXVWO29CQUFBTDtvQkFBQUQ7b0JBQUFEO29CQUFBRDtvQkFBQUQ7b0JBQUF6RTtVQUVzQztNQXBOeEQwSTtRQXlMQXhFO21CQWdCWWhFO1dBQ1QsS0FBTyw2Q0FERUEsS0FsQk12UDtZQW1CZixNQUFBO1dBQ08sS0FBQSw2Q0FGRXVQLEtBL2hEaEI1UDtZQWlpRE8sTUFBQTtXQUlJLElBQUEsT0FyeUJUZ04sa0JBNndCb0IzTSxPQXVCWCxPQTFHWDBTLGVBbUZzQjFTLEdBQUFBO1dBcUJSLEdBQUE7V0FBUCxNQUFBO1VBR3NEO01BL016RGdZO1FBeUxBekU7bUJBWWtCOUQ7V0FIZjtZQUFlNkUsTUE5RnRCNUIsZUFtRnNCMVMsR0E3Z0R0Qkw7WUF3aERzQjRVO1lBQUFSO1lBQUFDO1lBQUFDO29CQUFBQyxXQUFBK0QsT0FBQUM7WUFBQSxPQUFBLHFCQUFBRCxPQUFBQztXQUFjOzs7YUFBZG5aO2FBQUF3VjthQUFBTDthQUFBRDthQUFBRDthQUFBRDthQUdBdEU7YUFIQTZFO1dBS2I7WUFGYXdCLFFBakd0QnBELGVBbUZzQjFTLEdBcER0QjRTLG1CQW9Ec0I1UyxHQWNBeVA7WUFBQTBJO1lBQUExVztZQUFBc1U7WUFBQUM7b0JBQUFDLGFBQUFtQyxPQUFBQztZQUFBLE9BQUEscUJBQUFELE9BQUFDO1dBQWM7OztvQkFBZHZaO29CQUFBcVo7b0JBQUFsQztvQkFBQUQ7b0JBQUFEO29CQUFBdFU7b0JBQUFnTztvQkFBQXFHO1VBRTJDO01Bdk03RHdDO1FBeUxBL0U7bUJBSVk3RDtXQUNULEtBQU8sNkNBREVBLE9BbGhEaEI5UDtZQW1oRE8sTUFBQTtXQUNPLEdBQUEsNkNBRkU4UCxPQW5oRGhCL1A7O1dBcWhETyxNQUFBO1VBQXNDO01BL0x6QzRZLGFBeUxBaEYsTUF0MENGMVA7S0E2b0NFLFdBQUEwVSxZQUNKckk7S0FESSxXQUFBb0ksV0FFSnJJO0tBRkksV0FBQStILHNCQUlKaEk7S0FKSSxXQUFBK0gsU0FLSWhJO0tBTEosV0FBQTZILDRCQU1JOUg7S0FOSixXQUFBMkgsNEJBT0k1SDtLQUNSLFdBUkkyRCxvQkFRSjVEO0tBbU5VLE9BL0xWYTtjQTJKc0J6UTt1QkFvQ1BpUjtlQUNiO2dCQUdJLE9BM0hOeUIsZUFtRnNCMVMsR0FqS3BCcVEsS0FpS29CclEsR0FvQ1BpUjtnQkFHVCxPQXRNSlQsYUErSm9CeFEsR0FvQ1BpUjtlQUNOLEtBQUE7Z0JBQVAsTUFBQTs7ZUFLdUQ7Z0JBQUEsT0E1Q3pEbUMsZUFFc0JwVCxHQUFBQTtnQkEwQ0gsT0E1Q25Cb1QsZUFFc0JwVCxHQWpLcEJxUSxLQWlLb0JyUSxHQW9DUGlSO2VBS04sS0FBQTtnQkFBUCxNQUFBOztlQUU4RDtnQkFBQSxPQWxOaEViLGtCQXVLc0JwUTtnQkEyQ3FCLE9BQUEsNENBM0NyQkE7Z0JBMkNFLE9BNU10QnFRLEtBaUtvQnJRLEdBb0NQaVI7ZUFPTixHQUFBOztlQUFQLE1BQUE7Y0FBbUY7SUFBQztrQkExQy9DdUg7SyxPQXBIdkM3SCw2QixlQW9IdUM2SDs7SUFBSyxPQUFBLG9DQUR0QnhZO0dBMkNpRTtPQUd2RnlZO1lBRUFDLGNBQWMxWSxHQUFHMlksSUFBS0M7SUFDckIsV0FBQSw2Q0FEZ0JELElBQUgzWTtJQUNiO0tBRGFBLE9BQUcyWTtLQUlQLElBOWFvQkUsb0JBbVM5QnBHLHVCQXVJY3pTLEdBQUcyWTtLQUFIM1ksT0ExSGQyUyw2QkEwSGMzUyxHQTFhZ0I2WTtTQUFIM1UsTUEwYWJsRTtLQXphWCxHQUFBLHNCQUQyQjZZLG1CQW5aNUJsTSxrQkFtWnlCekk7OztNQU9QO09BQWR3QztPQUNBb1M7T0FDQW5OLGlDQUFpQyxtQkFUVGtOO09BVXhCak4sU0FWcUIxSDtPQVdyQm1KLGVBL1pKWCxXQW9aeUJ4STs7T0FZbkIsS0FBQSxxQkFMRndDLGdCQUlBMkc7UUFvQkQsR0FBQSxzQkEvQnlCd0wsbUJBQUgzVTtTQUFBQSxTQW1DVixXQS9uQmJpQztTQTRsQnVCakMsU0FuWnpCeUksa0JBbVp5QnpJOztvQkFRckI0VTs7O09BS1U7ZUFOVnBTO1FBeERMb0cseUJBMkRLbEI7UUFJRW1OLHlCQS9EUGpNO1FBQ0FrTSwrQkF5REtyTjtRQXJERnNOO1VBellBdk4sd0JBb1lIb0IsT0FDQWtNO1FBVUdFO1VBblpBek47WUF3WUhxQjtZQWVLOztjQVZGbU07Y0FZSyxrQkFqQlJuTSxVQWlEMEI1STtRQTlCdkJpViw4QkFSQUQ7UUFTQTNMLGFBL1pBaEMsS0EyWUh1QixPQW1CR3FNO1FBRUE3USxnQkFyQkh3RTtRQXNCR2hGLFFBdEJIZ0Y7O1FBdUJLOztVQUFBO3VCQUpGcU0sNEJBZEFGOztRQW1CQyxHQUFBLHFCQXhCSm5NO1NBbUJHcU0sNkJBZEFGOztTQXlCWTtpQkFWWjFMO1VBL0MwQ2hHLHlCQWlEMUNPO2dCQVNPLFdBemtCUDFCLFNBK2dCMENtQjtVQTREdkIsSUFBQSxPQUFBLFdBNWtCbkJwQixtQkErakJBb0g7VUFhRSxpQkFYRnpGO1VBOUNVLElBRFZWLE9BMEV1QmxELFFBekV2QnVELGNBSDBDRixRQUkxQ0c7O2dCQUFBQTtXQUlTLElBQVBDLFNBdGdCRmIsS0FnZ0JBTSxNQUNBSztXQXdCSHFGLFdBQUFBO1dBakJJLEdBQUEsc0JBamhCRHhHLElBeWdCQWMsTUFDQUssYUF5RTBCb1I7WUE1STVCcEwsUUE0SXlCdkosS0F6RXZCdUQ7O1lBeUV1QnZELFNBQUFBO1lBOUR2QixXQXdla0IwVSxnQkFuZmxCblI7WUFZQSxXQXZoQkFwQixNQTBnQkFlLE1BQ0FLOztjQUtFRSxXQVJ3Q0osT0FJMUNHLHdCQURBRCxhQUtFRTs7O1NBdUNGNEYsWUE5WkEvQixVQTBZSHNCLE9Bb0JHUztTQURBNEw7VUFqckJBNVQsaUJBaXJCQTRULDRCQUVBN1E7OztPQXJCSHdFLFdBS0dtTTtPQUxIbk0sWUE5cEJHdkgsaUJBbXFCQTBULHlCQUxIbk07T0FzRU0sR0FBQSxvQkF0RU5BLFVBK0RPaU0seUJBUEZyUyxpQkFJQTJHLGNBSEF5TDs7UUFEQXBTLGlCQUFBQTtRQUVBaUYsZ0NBMURMbUI7Ozs7ZUEyZGE5TSxPQS9EZGlULCtCQStEY2pUO2dCQUZkeVk7Ozs7O0dBbUIrRDtZQUcvRFcsK0JBQWlDcFosR0FBRzJZLElBQUtVO0lBQzdCLElBQVZ0TixVQTdwQkFtQixVQTRwQitCbE47SUFFaEMsR0FBQSxXQTNoQ0dvRyxTQTBoQ0YyRjtLQUVvQyxPQXZCdEMyTTtjQW9CaUMxWTtjQUFHMlk7O2VBR1ksTUFBQTtjQUFZO0lBRWxELElBQU4vSyxRQXRoQ0F0SCxJQWczQkpnTSxPQWlLaUN0UyxJQUMvQitMLFVBT21CLE9BaElyQjZHLG1CQXdIaUM1UyxHQUs3QjROO0lBR0QsR0FBQSw2Q0FSaUMrSztLQVNJLE9BN0J4Q0Q7Y0FvQmlDMVk7Y0FBRzJZOztlQVNjLE1BQUE7Y0FBWTtJQUcxQztLQUFBLE9BaDhCaEIvUSxlQW14QkowSyxPQWlLaUN0UyxJQUMvQitMLFNBSUU2QjtLQU1FMEwsT0FDRiw2Q0FaZ0NYO0lBY2xDLE9BbENGRCxjQW9CaUMxWSxHQVczQnNaLE1BWG1DRDtHQWNIO1lBR3RDRSxTQUFRNUosUUFBUUQ7SUFDbEI7TUFBRzs7UUFEZUE7Ozs7Ozs7OzJEQUFBQTs7Ozs7OztLQUdoQjs7UUF6YUluTixhQXNhSW9OLFdBdGdDTzZKLGFBc2dDUDdKO2tCQTNaQW5ILGNBRUNqRztLQUhIO01BRTZDcUo7TUFBM0I2TjtNQUFmMVU7TUFHRHVELGdCQTV4Qkp6RCxTQXl4QktFO01BSURzRDtRQS9ZTjRFLCtCQTRZTzFLLFlBREF3QztNQU9EWSw0QkEzeEJGYixTQW94QkdDO01BUURrRDtRQW53Qkp2QztVQTJ2Qm9CK1QsMkJBT2hCOVQ7TUExd0Jjb0M7UUFEbEJ4QyxpQkE0d0JJMEMsaUJBSkFJO01Bd0JJLE9BQUEsV0E3cUJSbEM7TUE0cUIrQixPQWxyQ2pDNUYsS0F3cENPZ0M7TUEwQlEsT0FBQTtNQURQLE9BQUE7TUFaRnVLOztTQWZBdEU7U0FFQ2pHO1NBOXhCSHFDLFNBOHhCR3JDO1NBREF3QztTQUdEdUQ7U0FJQTNDO1NBSEEwQzs7U0FJQUo7U0Ezd0JjRjs7TUFveUJoQixXQW5CRStFLE9BZDJDbEI7TUFud0J0QjtRQUFBLHNCQUFQN0Q7O1dBQXlDLG1CQUF6Q0E7S0FreUJsQixXQWxzQ0Y1SCxTQW9xQ09vQyxZQURBd0M7SUFpQ2U7SUFNYjtLQTlDRDZHO09BQ1IsMEJBTkVySjtLQW1ETyxPQUFBLDJCQTlDRHFKO0tBNENFLE9BQUEsV0F0ckJSekY7T0FxQ1dxVDtTQUFXclksTUFBWHFZLGVBQUEzVyxXQUFXMUI7O1NBQVgwQjtJQStvQmY7S0FBQTs7O1FBL29Ca0Msc0RBQW5CQTs7Ozs7O0tBMmdDYjdDOztRQUxNMlA7UUFBUUQ7UUFoTGhCNkMsc0JBbDdDQTVTLFVBa21EUWdROzs7UUFsbURSaFE7O0lBdW1ERUssT0F6R0ZpVCwrQkF5R0VqVDtJQTFDRjBZO01BMENFMVk7TUFMYzBQOztPQW1CaUMsTUFBQTtNQUFZO0lBQS9ELE9BZEkxUDtHQWVIO1lBR0MwWixvQkFBb0IxWixHQUFHd0csSUFBR0M7SUFLbkIsV0FyS1BtTSxtQkFnS29CNVMsR0FBR3dHO0lBRXZCLE9BaGtCRXVJLGFBOGpCa0IvTyxNQUFHd0csVUFBR0M7R0FNakI7WUFtQlRrVCwwQkFBMEIzWixHQUFHd0c7SUFDL0IsR0FBRyw2Q0FENEJBLElBQUh4Rzs7Ozs7b0VBQUFBOzs7OztvRUFBR3dHOzs7Ozs7Ozs7SUFFNUIsV0FBQSw2Q0FGNEJBLElBQUh4RztJQUV6QixXQUFBOzs7OzttRUFGeUJBOzs7OzttRUFBR3dHOzs7Ozs7OztHQUdpQjtZQUc5Q29ULE1BQUk1WixHQUFHd0csSUFBR0M7SUFOVmtULDBCQU1JM1osR0FBR3dHO0lBS0MsV0F2T1JpTSx1QkFrT0l6UyxHQUFHd0c7SUFHUCxPQWhtQkV1SSxhQTZsQkUvTyxZQUFHd0csSUFBR0M7R0FPRDtZQUdUb1QsT0FBTzdaLEdBQUVpUjtJQUFRLElBeFpSL00sTUF3WkZsRSxNQXZaSG9ILE9BREtsRCxRQUVMOEksTUF6cUJBN0YsZ0JBd3FCQUMsTUF1Wks2SjtJQTdhUGpDLGdCQXFCTzlLLEtBRUw4STtJQUNKLE9BQUEsV0E5c0JJM0csTUE0c0JBZSxNQUNBNEY7R0FzWnlEO1lBQzdEOE0sTUFBTTlaO0lBQUksSUE5V0ZrRSxNQThXRmxFLE1BN1dDLFdBeGpCTHlNLFNBdWpCTXZJOztLQUFBQTtLQU1OO01BRklrRCxPQUpFbEQ7TUFLRjZWLG9CQUFTL00sS0FBTSxPQUFBLFdBM3ZCakIzRyxNQTB2QkVlLE1BQ1M0RixLQUFnQztNQUN6Q3BCLFNBTkUxSDthQU1GMEg7OztVQUNKbEY7O09BQ2MsSUFBUm9HLHlCQUZGbEIsUUFDSmxGLGlCQUFBQTtPQUVLLEdBQUEscUJBRENvRztRQUFBQTtZQUlFaEYsUUFKRmdGLGtCQUlFaEY7O2FBQ0ppRjs7VUFDWSxJQUFOQyx1QkFGRmxGLE9BQ0ppRixnQkFBQUE7aUJBRVMsV0E1d0JYM0csU0Eyd0JRNEc7V0Exc0JSMUYsS0Fnc0JFRixNQVVNNEYsS0FUTitNO1dBYTBCLFdBQUEsV0FoeEI1QjVUO1dBZ3hCTSxpQkFOQTJCLE9BQ0ppRixnQkFBQUE7O1VBQUEsV0FBQUE7c0JBQUFBO2NBQUFBOzs7O09BTkosV0FBQXJHO21CQUFBQTtXQUFBQTs7Ozs7Ozs7R0F1VzZDO1lBQy9Dc1QsSUFBSWhhLEdBQUVpUixPQUFRLElBamJSL00sTUFpYkZsRSxNQWpiVSxPQXhxQlZnSCxTQXdxQkU5QyxRQWliQStNLE9BQWlEO1lBRXZEZ0osZUFBZWphLEdBQUVpUixPQXJtQ0QzSyxLQUVERTtJQW9tQ2pCLE9BSEV3VCxJQUVlaGEsR0FBRWlSLFFBRWQ7SUF0QkgwSSwwQkFvQmUzWixHQW5tQ0F3RztRQXd1Qk50QyxNQTJYTWxFO0lBaG5CYjhPLGlCQXFQTzVLLEtBMXVCT29DO0lBNnVCTixJQTN1QkNjLE9Bd3VCRmxELFFBeHVCSThJLE1BZ0NUN0YsZ0JBaENPQyxNQW1tQ002SjtJQWpiZmpDLGdCQXNETzlLLEtBeHVCSThJO0lBRk8sK0JBRVQ1RixNQUFFNEYsMkJBRkcxRztJQUVHLCtCQUFSYyxNQUFFNEYsMkJBQUV4RztJQTh1QmYsT0E5UUVxSSxpQkF3UU8zSyxLQXh1Qkk4STtHQXVtQ3NDO1lBR25Ea04sV0FBV2xhLEdBQUVpUixPQUFPeks7SUFBSyxPQVB6QnlULGVBT1dqYSxHQUFFaVIsT0F2UGJ3Qix1QkF1UFd6UyxHQUFTd0csS0FBQUE7R0FBa0U7WUFFdEYyVCwyQkFBMkJuYSxHQUFFaVIsT0FBT3pLO0lBQ3RDLE9BVkV5VCxlQVMyQmphLEdBQUVpUixPQUFPekssSUF0TnBDb00sbUJBc04yQjVTLEdBQVN3RztHQUNzQjtZQUcxRDRULHVCQUF1QnBhO0lBQ2YsSUFBTmdOLE1BL3ZCQUUsVUE4dkJxQmxOO0lBRXRCLE9BQUEsV0E3bkNHb0csU0E0bkNGNEcsZUFwbkNFMUcsSUFnM0JKZ00sT0FtUXVCdFMsSUFDckJnTjtHQUMyRTtZQUc3RXFOLDJCQUEyQkM7SUFDbkIsSUFBTnROLE1BcHdCQUUsVUFtd0J5Qm9OO0lBRTFCLEtBQUEsV0Fsb0NHbFUsU0Fpb0NGNEcsTUFPQyxPQWhvQ0MxRyxJQWczQkpnTSxPQXdRMkJnSSxRQUN6QnROOzs7Ozs7Ozs7Y0EvUkYyRCw2QixlQThSMkIySjs7Ozs7Ozs7R0FRSztZQUdoQ0MsdUJBQXVCdmEsR0FuakNDdUg7SUFvakMxQjtLQXBqQ3FCSCxPQWd5Qm5Ca0wsT0FtUnVCdFM7S0FuakNRNkgsV0FoRjNCdkIsSUFnRmVjLE1BQUtHO0tBQ2xCaVQ7S0FDQS9TLGNBRmtCRjtLQUdsQkc7O1VBQUFBLHNCQUZBOFM7S0FJUyxJQUFQN1MsU0E1RUpiLEtBdUVlTSxNQUViSztLQUlDLEdBQUEsb0JBdEZIbkIsSUFnRmVjLE1BRWJLLGFBRnlCSTtNQU9RLFdBTmpDMlMsbUJBTWlDLE9BckZuQ2hVLEdBOEVlWSxNQUViSztNQURBK1M7T0FNcUI7O1FBRm5CN1MsV0FMZ0JKLE9BR2xCRyx3QkFEQUQsYUFHRUU7O0dBZ2pDZ0U7WUFHeEU4Uyx1QkFBdUJ6YSxHQUFFZ047SUFDaEIsSUFBUDVGLE9BelJGa0wsT0F3UnVCdFM7SUFFc0IsT0E3aUN6QzRILGVBNGlDRlIsTUFEdUI0RixLQXhvQ3JCMUcsSUF5b0NGYyxNQUR1QjRGO0dBRStDO1lBR3hFME4sK0JBQStCMWE7SUFDdkIsSUFBTmdOLE1BenhCQUUsVUF3eEI2QmxOO0lBRTlCLE9BQUEsV0F2cENHb0csU0FzcENGNEcsZUFYRnVOLHVCQVUrQnZhLEdBQzdCZ047R0FDMEU7WUFHNUUyTiwrQkFBK0IzYTtJQUN2QixJQUFOZ04sTUE5eEJBRSxVQTZ4QjZCbE47SUFFOUIsT0FBQSxXQTVwQ0dvRyxTQTJwQ0Y0RyxlQVhGeU4sdUJBVStCemEsR0FDN0JnTjtHQUMwRTtZQUc1RTROLGlDQUFtQ0M7SUFDM0IsSUFBTjdOLE1BbnlCQUUsVUFreUJpQzJOO0lBRWxDLEdBQUEsV0FqcUNHelUsU0FncUNGNEc7Ozs7Ozs7OztlQTlURjJELDZCLGVBNlRtQ2tLOzs7Ozs7O0tBSW5DOztJQUFBLE9BeEJBTix1QkFvQm1DTSxPQUNqQzdOO0dBT3dCO1lBRzFCOE4saUNBQW1DQztJQUMzQixJQUFOL04sTUE5eUJBRSxVQTZ5QmlDNk47SUFFbEMsR0FBQSxXQTVxQ0czVSxTQTJxQ0Y0Rzs7Ozs7Ozs7O2VBelVGMkQsNkIsZUF3VW1Db0s7Ozs7Ozs7S0FJbkM7O0lBQUEsT0E5QkFOLHVCQTBCbUNNLE9BQ2pDL047R0FPd0I7WUFHMUJnTyxpQkFBaUJoYixHQUFHcVo7SUFDdEI7S0E3ZDJDOUosTUE0ZHhCdlA7S0E1ZG1Cc0csTUF1UHBDNE0saUJBcU9pQmxUO0tBNWRFa0UsTUE0ZEZsRTtLQTNkYjhNLHlCQURlNUk7S0FFaEIsT0FBQSxxQkFEQzRJO0lBQ0Q7S0FFVTtNQUFQUyxTQTlqQkZoQyxLQTJqQkF1QixPQURnQ3hHO01BSzlCd0IsUUFKRmdGO01BS0UxRixPQU5hbEQ7TUFPYnFELDZCQUZBTyxPQURBeUYsWUFBQUE7TUFJRyxXQUFBLFdBanVCTG5ILFNBZ3VCRW1COztNQUdZLElBQVZFLGNBSEZGLFdBSUVHOztZQUFBQTtPQUdTLElBRFBzRixNQUhGdkYsWUFJRUUsU0F0dEJOYixLQThzQkVNLE1BT0k0RjtVQUNBckYsV0FQSkosVUFJRUcsd0JBREFELGFBSUVFO09BRWMsV0EvdEJwQm5CLEdBcXRCRVksTUFPSTRGO09BR0QsR0FBQSxtREFoQmdDdUM7UUFrQmpDLFdBMGNZOEosY0EvY1ZyTTtRQXpDUmdDLGdCQTRCaUI5SyxLQWFUOEk7UUFPRixXQXR1QkozRyxNQXd0QkVlLE1BT0k0RjtRQU5KekYsNEJBRkFPLE9BREF5RixZQUFBQTs7Ozs7Ozs7Ozs7R0E2ZEk7Ozs7Ozs7OztRQTlrRFIvTDtRQTVCQUs7UUFaQUo7UUE0Q0lZO1FBQUFBO1FBQ0FUO1FBaENKRTtRQUlBSTtRQUhBSDtRQUNBQztRQUNBQztRQUVBRTtRQUNBQzs7T0Eyd0NGdU87T0FyREFSOztXQUlGcEssYUFFSUcsUUFDQW1LLE1BRUFHLGNBREFEO09BZ0tGOEM7O1FBMThDRXZTO1FBZEpOO1FBMEpjSTtRQXhKVmY7UUFrQkFtQjtRQTBHQU87UUExSEFaOztRQTRISmdDO1FBQUFJO1FBb0JJYztRQWFBRTtRQTFCQWpCO1FBTEFQO1FBNkNBOEI7UUFQQUQ7T0FxNENGbVY7T0E1UEFuSjtPQVhRYjtPQUhSRztPQXlFQTJDO09BREFEO09BOUNBM0I7T0F3RUFpQztPQThFQVE7T0EvQ0FOO09Ba0RBUTtPQWtEQXNGO09Bb0JBVTtPQTRKQTRCO09BaFpRN0w7T0EyS1IrRDtPQUVBQztPQThJQXlHO09BL0JBRjtPQTJDQU07T0FGQUg7T0FXQUs7T0FFQUM7T0FaQUw7T0FnQkFNO09BS0FDO09BcUJBSztPQUtBQztPQUtBQztPQVdBRTtPQXhQQWhJO09BV0FDO1dBci9DQXBULFVBazdDQTRTLDJCQXY1Q0V4Uzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBUaW1pbmdfd2hlZWwuSW1wb3J0ICopXG5tb2R1bGUgSW1wb3J0ID0gVGltaW5nX3doZWVsX19JbXBvcnRcblxuKCoqIEBjYW5vbmljYWwgVGltaW5nX3doZWVsLlRpbWluZ193aGVlbF9pbnRmICopXG5tb2R1bGUgVGltaW5nX3doZWVsX2ludGYgPSBUaW1pbmdfd2hlZWxfX1RpbWluZ193aGVlbF9pbnRmXG5cbm1vZHVsZSBUaW1pbmdfd2hlZWxfXyA9IHN0cnVjdCBlbmRcbltAQGRlcHJlY2F0ZWQgXCJ0aGlzIG1vZHVsZSBpcyBzaGFkb3dlZFwiXVxuIiwiKCogQmUgc3VyZSBhbmQgZmlyc3QgcmVhZCB0aGUgaW1wbGVtZW50YXRpb24gb3ZlcnZpZXcgaW4gdGltaW5nX3doZWVsX2ludGYubWwuXG5cbiAgIEEgdGltaW5nIHdoZWVsIGlzIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIFwibGV2ZWxzXCIsIHdoZXJlIGVhY2ggbGV2ZWwgaXMgYW4gYXJyYXkgb2ZcbiAgIFwic2xvdHNcIi4gIEVhY2ggc2xvdCByZXByZXNlbnRzIGEgcmFuZ2Ugb2Yga2V5cywgYW5kIGhvbGRzIGVsZW1lbnRzIGFzc29jaWF0ZWQgd2l0aFxuICAgdGhvc2Uga2V5cy4gIEVhY2ggbGV2ZWwgaXMgZGV0ZXJtaW5lZCBieSB0d28gcGFyYW1ldGVyczogW2JpdHNdLCB0aGUgbnVtYmVyIG9mIGtleSBiaXRzXG4gICB0aGF0IHRoYXQgbGV2ZWwgaXMgcmVzcG9uc2libGUgZm9yIGRpc3Rpbmd1aXNoaW5nLCBhbmQgW2JpdHNfcGVyX3Nsb3RdLCB0aGUgc2l6ZSBvZiB0aGVcbiAgIHJhbmdlIG9mIGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIGEgc2luZ2xlIHNsb3QgaW4gdGhlIGFycmF5LiAgQ29uY2VwdHVhbGx5LCBlYWNoIGxldmVsXG4gICBicmVha3MgdXAgYWxsIHBvc3NpYmxlIGtleXMgaW50byByYW5nZXMgb2Ygc2l6ZSBbMl5iaXRzX3Blcl9zbG90XS4gIFRoZSBsZW5ndGggb2YgYVxuICAgbGV2ZWwgYXJyYXkgaXMgWzJeYml0c10sIGFuZCB0aGUgYXJyYXkgaXMgdXNlZCBsaWtlIGEgY2lyY3VsYXIgYnVmZmVyIHRvIHRyYXZlcnNlIHRoZVxuICAgcmFuZ2VzIGFzIHRoZSB0aW1pbmcgd2hlZWwncyBbbWluX2FsbG93ZWRfa2V5XSBpbmNyZWFzZXMuICBBIGtleSBba10sIGlmIHN0b3JlZCBpbiB0aGVcbiAgIGxldmVsLCBpcyBzdG9yZWQgYXQgaW5kZXggWyhrIC8gMl5iaXRzX3Blcl9zbG90KSBtb2QgMl5iaXRzXS5cblxuICAgVGhlIHNldHRpbmdzIG9mIHRoZSBbYml0c10gdmFsdWVzIGFyZSBjb25maWd1cmFibGUgYnkgdXNlciBjb2RlIHVzaW5nIFtMZXZlbF9iaXRzXSxcbiAgIGFsdGhvdWdoIHRoZXJlIGlzIGEgcmVhc29uYWJsZSBkZWZhdWx0IHNldHRpbmcuICBHaXZlbiB0aGUgW2JpdHNdIHZhbHVlcywgdGhlXG4gICBbYml0c19wZXJfc2xvdF0gYXJlIGNob3NlbiBzbyB0aGF0IFtiaXRzX3Blcl9zbG90XSBhdCBsZXZlbCBbaV0gaXMgdGhlIHN1bSBvZiB0aGVcbiAgIFtiaXRzXSBhdCBhbGwgbG93ZXIgbGV2ZWxzLiAgVGh1cywgYSBzbG90J3MgcmFuZ2UgYXQgbGV2ZWwgW2ldIGlzIGFzIGxhcmdlIGFzIHRoZVxuICAgZW50aXJlIHJhbmdlIG9mIHRoZSBhcnJheSBhdCBsZXZlbCBbaSAtIDFdLlxuXG4gICBFYWNoIGxldmVsIGhhcyBhIFttaW5fYWxsb3dlZF9rZXldIGFuZCBhIFttYXhfYWxsb3dlZF9rZXldIHRoYXQgZGV0ZXJtaW5lIHRoZSByYW5nZSBvZlxuICAga2V5cyB0aGF0IGl0IGN1cnJlbnRseSByZXByZXNlbnRzLiAgVGhlIGNydWNpYWwgaW52YXJpYW50IG9mIHRoZSB0aW1pbmcgd2hlZWwgZGF0YVxuICAgc3RydWN0dXJlIGlzIHRoYXQgdGhlIFttaW5fYWxsb3dlZF9rZXldIGF0IGxldmVsIFtpXSBpcyBubyBtb3JlIHRoYW4gdGhlXG4gICBbbWF4X2FsbG93ZWRfa2V5ICsgMV0gb2YgbGV2ZWwgW2kgLSAxXS4gIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBsZXZlbHMgY2FuIHJlcHJlc2VudCBhbGxcbiAgIGtleXMgZnJvbSB0aGUgW21pbl9hbGxvd2VkX2tleV0gb2YgdGhlIGxvd2VzdCBsZXZlbCB0byB0aGUgW21heF9hbGxvd2VkX2tleV0gb2YgdGhlXG4gICBoaWdoZXN0IGxldmVsLiAgVGhlIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciByZXN0b3JpbmdcbiAgIHRoaXMgaW52YXJpYW50LlxuXG4gICBBdCBsZXZlbCAwLCBbYml0c19wZXJfc2xvdCA9IDBdLCBhbmQgc28gdGhlIHNpemUgb2YgZWFjaCBzbG90IGlzIFsxXS4gIFRoYXQgaXMsIGxldmVsIDBcbiAgIHByZWNpc2VseSBkaXN0aW5ndWlzaGVzIGFsbCB0aGUga2V5cyBiZXR3ZWVuIGl0cyBbbWluX2FsbG93ZWRfa2V5XSAod2hpY2ggaXMgdGhlIHNhbWVcbiAgIGFzIHRoZSBbbWluX2FsbG93ZWRfa2V5XSBvZiB0aGUgZW50aXJlIHRpbWluZyB3aGVlbCkgYW5kIFttYXhfYWxsb3dlZF9rZXldLiAgQXMgdGhlXG4gICBsZXZlbHMgaW5jcmVhc2UsIHRoZSBbbWluX2FsbG93ZWRfa2V5XSBpbmNyZWFzZXMsIHRoZSBbYml0c19wZXJfc2xvdF0gaW5jcmVhc2VzLCBhbmRcbiAgIHRoZSByYW5nZSBvZiBrZXlzIHN0b3JlZCBpbiB0aGUgbGV2ZWwgaW5jcmVhc2VzIChkcmFtYXRpY2FsbHkpLlxuXG4gICBUaGUgaWRlYSBvZiB0aGUgaW1wbGVtZW50YXRpb24gaXMgc2ltaWxhciB0byB0aGUgaGllcmFyY2hpY2FsIGFwcHJvYWNoIGRlc2NyaWJlZCBpbjpcblxuICAge3ZcbiAgICAgSGFzaGVkIGFuZCBIaWVyYXJjaGljYWwgVGltaW5nIFdoZWVsczpcbiAgICAgRWZmaWNpZW50IERhdGEgU3RydWN0dXJlcyBmb3IgSW1wbGVtZW50aW5nIGEgVGltZXIgRmFjaWxpdHlcblxuICAgICBWYXJnaGVzZSAmIExhdWNrLCAxOTk2XG4gICB2fVxuXG4gICBIb3dldmVyLCB0aGUgY29kZSBpcyBjb21wbGV0ZWx5IG5ldy4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuISBUaW1pbmdfd2hlZWxfaW50ZlxubW9kdWxlIFBvb2wgPSBUdXBsZV9wb29sXG5tb2R1bGUgVGltZV9ucyA9IENvcmVfcHJpdmF0ZS5UaW1lX25zX2FsdGVybmF0ZV9zZXhwXG5cbmxldCBzZXhwX29mX3Rfc3R5bGUgOiBbIGBQcmV0dHkgfCBgSW50ZXJuYWwgXSByZWYgPSByZWYgYFByZXR0eVxuXG4oKiBbe21heCxtaW59X3RpbWVdIGFyZSBib3VuZHMgb24gdGhlIHRpbWVzIHN1cHBvcnRlZCBieSBhIHRpbWluZyB3aGVlbC4gKilcblxubGV0IG1heF90aW1lID0gVGltZV9ucy5tYXhfdmFsdWVfcmVwcmVzZW50YWJsZVxubGV0IG1pbl90aW1lID0gVGltZV9ucy5lcG9jaFxuXG5tb2R1bGUgTnVtX2tleV9iaXRzIDogc2lnXG4gIHR5cGUgdCA9IHByaXZhdGUgaW50IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgaW5jbHVkZSBDb21wYXJhYmxlIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBJbnZhcmlhbnQuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIHplcm8gOiB0XG5cbiAgKCogdmFsIG1pbl92YWx1ZSA6IHQgKilcblxuICB2YWwgbWF4X3ZhbHVlIDogdFxuICB2YWwgdG9faW50IDogdCAtPiBpbnRcbiAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gIHZhbCAoICsgKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIC0gKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCBwb3cyIDogdCAtPiBJbnQ2My50XG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbnRcblxuICBsZXQgbWluX3ZhbHVlID0gMFxuXG4gICgqKiBXZSBzdXBwb3J0IGFsbCBub24tbmVnYXRpdmUgW1RpbWVfbnMudF0gdmFsdWVzLiAqKVxuICBsZXQgbWF4X3ZhbHVlID0gSW50NjMubnVtX2JpdHMgLSAxXG5cbiAgbGV0IGludmFyaWFudCB0ID1cbiAgICBhc3NlcnQgKHQgPj0gbWluX3ZhbHVlKTtcbiAgICBhc3NlcnQgKHQgPD0gbWF4X3ZhbHVlKVxuICA7O1xuXG4gIGxldCBvZl9pbnQgaSA9XG4gICAgaW52YXJpYW50IGk7XG4gICAgaVxuICA7O1xuXG4gIGxldCAoICsgKSB0MSB0MiA9XG4gICAgbGV0IHQgPSB0MSArIHQyIGluXG4gICAgaW52YXJpYW50IHQ7XG4gICAgdFxuICA7O1xuXG4gIGxldCAoIC0gKSB0MSB0MiA9XG4gICAgbGV0IHQgPSB0MSAtIHQyIGluXG4gICAgaW52YXJpYW50IHQ7XG4gICAgdFxuICA7O1xuXG4gIGxldCBwb3cyIHQgPSBJbnQ2My5zaGlmdF9sZWZ0IEludDYzLm9uZSB0XG5lbmRcblxubW9kdWxlIExldmVsX2JpdHMgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gTnVtX2tleV9iaXRzLnQgbGlzdCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gIGxldCBtYXhfbnVtX2JpdHMgPSAoTnVtX2tleV9iaXRzLm1heF92YWx1ZSA6PiBpbnQpXG4gIGxldCBudW1fYml0c19pbnRlcm5hbCB0ID0gTGlzdC5mb2xkIHQgfmluaXQ6TnVtX2tleV9iaXRzLnplcm8gfmY6TnVtX2tleV9iaXRzLiggKyApXG4gIGxldCBudW1fYml0cyB0ID0gKG51bV9iaXRzX2ludGVybmFsIHQgOj4gaW50KVxuXG4gIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgYXNzZXJ0IChub3QgKExpc3QuaXNfZW1wdHkgdCkpO1xuICAgIExpc3QuaXRlciB0IH5mOihmdW4gbnVtX2tleV9iaXRzIC0+XG4gICAgICBOdW1fa2V5X2JpdHMuaW52YXJpYW50IG51bV9rZXlfYml0cztcbiAgICAgIGFzc2VydCAoTnVtX2tleV9iaXRzLiggPiApIG51bV9rZXlfYml0cyBOdW1fa2V5X2JpdHMuemVybykpO1xuICAgIE51bV9rZXlfYml0cy5pbnZhcmlhbnQgKG51bV9iaXRzX2ludGVybmFsIHQpXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgdCA9IHNleHAgfD4gWyVvZl9zZXhwOiB0XSBpblxuICAgIGludmFyaWFudCB0O1xuICAgIHRcbiAgOztcblxuICBsZXQgY3JlYXRlX2V4biA/KGV4dGVuZF90b19tYXhfbnVtX2JpdHMgPSBmYWxzZSkgaW50cyA9XG4gICAgaWYgTGlzdC5pc19lbXB0eSBpbnRzIHRoZW4gZmFpbHdpdGggXCJMZXZlbF9iaXRzLmNyZWF0ZV9leG4gcmVxdWlyZXMgYSBub25lbXB0eSBsaXN0XCI7XG4gICAgaWYgTGlzdC5leGlzdHMgaW50cyB+ZjooZnVuIGJpdHMgLT4gYml0cyA8PSAwKVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlIFwiTGV2ZWxfYml0cy5jcmVhdGVfZXhuIGdvdCBub25wb3NpdGl2ZSBudW0gYml0c1wiIH5fOihpbnRzIDogaW50IGxpc3QpXTtcbiAgICBsZXQgbnVtX2JpdHMgPSBMaXN0LmZvbGQgaW50cyB+aW5pdDowIH5mOiggKyApIGluXG4gICAgaWYgbnVtX2JpdHMgPiBtYXhfbnVtX2JpdHNcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiTGV2ZWxfYml0cy5jcmVhdGVfZXhuIGdvdCB0b28gbWFueSBiaXRzXCJcbiAgICAgICAgICAgIH5fOihpbnRzIDogaW50IGxpc3QpXG4gICAgICAgICAgICB+Z290OihudW1fYml0cyA6IGludClcbiAgICAgICAgICAgIChtYXhfbnVtX2JpdHMgOiBpbnQpXTtcbiAgICBsZXQgaW50cyA9XG4gICAgICBpZiBleHRlbmRfdG9fbWF4X251bV9iaXRzXG4gICAgICB0aGVuIGludHMgQCBMaXN0LmluaXQgKG1heF9udW1fYml0cyAtIG51bV9iaXRzKSB+ZjooY29uc3QgMSlcbiAgICAgIGVsc2UgaW50c1xuICAgIGluXG4gICAgTGlzdC5tYXAgaW50cyB+ZjpOdW1fa2V5X2JpdHMub2ZfaW50XG4gIDs7XG5cbiAgbGV0IGRlZmF1bHQgPSBjcmVhdGVfZXhuIFsgMTE7IDEwOyAxMDsgMTA7IDEwOyAxMDsgMSBdXG5cbiAgbGV0IHRyaW0gdCB+bWF4X251bV9iaXRzID1cbiAgICBpZiBOdW1fa2V5X2JpdHMuKCA8PSApIChudW1fYml0c19pbnRlcm5hbCB0KSBtYXhfbnVtX2JpdHNcbiAgICB0aGVuIHRcbiAgICBlbHNlIChcbiAgICAgIGxldCByZWMgbG9vcCB0IH5yZW1haW5pbmcgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBbXSAtPiBbXVxuICAgICAgICB8IGIgOjogdCAtPlxuICAgICAgICAgIGlmIE51bV9rZXlfYml0cy4oID49ICkgYiByZW1haW5pbmdcbiAgICAgICAgICB0aGVuIFsgcmVtYWluaW5nIF1cbiAgICAgICAgICBlbHNlIGIgOjogbG9vcCB0IH5yZW1haW5pbmc6KE51bV9rZXlfYml0cy4oIC0gKSByZW1haW5pbmcgYilcbiAgICAgIGluXG4gICAgICBsb29wIHQgfnJlbWFpbmluZzptYXhfbnVtX2JpdHMpXG4gIDs7XG5lbmRcblxubW9kdWxlIEFsYXJtX3ByZWNpc2lvbiA6IHNpZ1xuICBpbmNsdWRlIEFsYXJtX3ByZWNpc2lvblxuXG4gIHZhbCBudW1fa2V5X2JpdHMgOiB0IC0+IE51bV9rZXlfYml0cy50XG4gIHZhbCBpbnRlcnZhbF9udW0gOiB0IC0+IFRpbWVfbnMudCAtPiBJbnQ2My50XG4gIHZhbCBpbnRlcnZhbF9udW1fc3RhcnQgOiB0IC0+IEludDYzLnQgLT4gVGltZV9ucy50XG5lbmQgPSBzdHJ1Y3RcbiAgKCoqIFt0XSBpcyByZXByZXNlbnRlZCBhcyB0aGUgbG9nMiBvZiBhIG51bWJlciBvZiBuYW5vc2Vjb25kcy4gKilcbiAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nIGNvbXBhcmUsIGhhc2hdXG5cbiAgbGV0IGVxdWFsID0gWyVjb21wYXJlLmVxdWFsOiB0XVxuICBsZXQgbnVtX2tleV9iaXRzIHQgPSB0IHw+IE51bV9rZXlfYml0cy5vZl9pbnRcblxuICBsZXQgdG9fc3BhbiB0ID1cbiAgICBpZiB0IDwgMFxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJbQWxhcm1fcHJlY2lzaW9uLnRvX3NwYW5dIG9mIG5lZ2F0aXZlIHBvd2VyIG9mIHR3byBuYW5vc2Vjb25kc1wiIH5fOih0IDogaW50KV07XG4gICAgSW50NjMuKHNoaWZ0X2xlZnQgb25lKSB0IHw+IFRpbWVfbnMuU3Bhbi5vZl9pbnQ2M19uc1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgdCA9IFslc2V4cCAodCB8PiB0b19zcGFuIDogVGltZV9ucy5TcGFuLnQpXVxuICBsZXQgb25lX25hbm9zZWNvbmQgPSAwXG4gIGxldCBhYm91dF9vbmVfbWljcm9zZWNvbmQgPSAxMFxuICBsZXQgYWJvdXRfb25lX21pbGxpc2Vjb25kID0gMjBcbiAgbGV0IGFib3V0X29uZV9zZWNvbmQgPSAzMFxuICBsZXQgYWJvdXRfb25lX2RheSA9IDQ2XG4gIGxldCBtdWwgdCB+cG93MiA9IHQgKyBwb3cyXG4gIGxldCBkaXYgdCB+cG93MiA9IHQgLSBwb3cyXG4gIGxldCBpbnRlcnZhbF9udW0gdCB0aW1lID0gSW50NjMuc2hpZnRfcmlnaHQgKHRpbWUgfD4gVGltZV9ucy50b19pbnQ2M19uc19zaW5jZV9lcG9jaCkgdFxuXG4gIGxldCBpbnRlcnZhbF9udW1fc3RhcnQgdCBpbnRlcnZhbF9udW0gPVxuICAgIEludDYzLnNoaWZ0X2xlZnQgaW50ZXJ2YWxfbnVtIHQgfD4gVGltZV9ucy5vZl9pbnQ2M19uc19zaW5jZV9lcG9jaFxuICA7O1xuXG4gIGxldCBvZl9zcGFuX2Zsb29yX3BvdzJfbnMgc3BhbiA9XG4gICAgaWYgVGltZV9ucy5TcGFuLiggPD0gKSBzcGFuIFRpbWVfbnMuU3Bhbi56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIltBbGFybV9wcmVjaXNpb24ub2Zfc3Bhbl9mbG9vcl9wb3cyX25zXSBnb3Qgbm9uLXBvc2l0aXZlIHNwYW5cIlxuICAgICAgICAgICAgKHNwYW4gOiBUaW1lX25zLlNwYW4udCldO1xuICAgIHNwYW4gfD4gVGltZV9ucy5TcGFuLnRvX2ludDYzX25zIHw+IEludDYzLmZsb29yX2xvZzJcbiAgOztcblxuICBsZXQgb2Zfc3BhbiA9IG9mX3NwYW5fZmxvb3JfcG93Ml9uc1xuXG4gIG1vZHVsZSBVbnN0YWJsZSA9IHN0cnVjdFxuICAgIG1vZHVsZSBUID0gc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdCBbQEBkZXJpdmluZyBjb21wYXJlXVxuXG4gICAgICBsZXQgb2ZfYmluYWJsZSA9IG9mX3NwYW5fZmxvb3JfcG93Ml9uc1xuICAgICAgbGV0IHRvX2JpbmFibGUgPSB0b19zcGFuXG4gICAgICBsZXQgb2Zfc2V4cGFibGUgPSBvZl9zcGFuX2Zsb29yX3BvdzJfbnNcbiAgICAgIGxldCB0b19zZXhwYWJsZSA9IHRvX3NwYW5cbiAgICBlbmRcblxuICAgIGluY2x1ZGUgVFxuICAgIGluY2x1ZGUgQmluYWJsZS5PZl9iaW5hYmxlX3dpdGhvdXRfdXVpZCBbQGFsZXJ0IFwiLWxlZ2FjeVwiXSAoVGltZV9ucy5TcGFuKSAoVClcbiAgICBpbmNsdWRlIFNleHBhYmxlLk9mX3NleHBhYmxlIChUaW1lX25zLlNwYW4pIChUKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQ29uZmlnID0gc3RydWN0XG4gIGxldCBsZXZlbF9iaXRzX2RlZmF1bHQgPSBMZXZlbF9iaXRzLmRlZmF1bHRcblxuICB0eXBlIHQgPVxuICAgIHsgYWxhcm1fcHJlY2lzaW9uIDogQWxhcm1fcHJlY2lzaW9uLlVuc3RhYmxlLnRcbiAgICA7IGxldmVsX2JpdHMgOiBMZXZlbF9iaXRzLnQgW0BkZWZhdWx0IGxldmVsX2JpdHNfZGVmYXVsdF1cbiAgICA7IGNhcGFjaXR5IDogaW50IG9wdGlvbiBbQHNleHAub3B0aW9uXVxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF1cblxuICBsZXQgYWxhcm1fcHJlY2lzaW9uIHQgPSBBbGFybV9wcmVjaXNpb24udG9fc3BhbiB0LmFsYXJtX3ByZWNpc2lvblxuXG4gICgqIFttYXhfbnVtX2xldmVsX2JpdHMgYWxhcm1fcHJlY2lzaW9uXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbGV2ZWwgYml0cyBuZWVkZWQgZm9yIGFcbiAgICAgdGltaW5nIHdoZWVsIHdpdGggdGhlIHNwZWNpZmllZCBbYWxhcm1fcHJlY2lzaW9uXSB0byBiZSBhYmxlIHRvIHJlcHJlc2VudCBhbGxcbiAgICAgcG9zc2libGUgdGltZXMgZnJvbSBbVGltZV9ucy5lcG9jaF0gb253YXJkLiAgU2luY2Ugbm9uLW5lZ2F0aXZlIHRpbWVzIGhhdmUgNjIgYml0cyxcbiAgICAgd2UgcmVxdWlyZSBbTCA8PSA2MiAtIEFdLCB3aGVyZSBbQV0gaXMgdGhlIG51bWJlciBvZiBhbGFybSBiaXRzIGFuZCBbTF0gaXMgdGhlXG4gICAgIG51bWJlciBvZiBsZXZlbCBiaXRzLiAqKVxuICBsZXQgbWF4X251bV9sZXZlbF9iaXRzIGFsYXJtX3ByZWNpc2lvbiA9XG4gICAgTnVtX2tleV9iaXRzLiggLSApXG4gICAgICBOdW1fa2V5X2JpdHMubWF4X3ZhbHVlXG4gICAgICAoQWxhcm1fcHJlY2lzaW9uLm51bV9rZXlfYml0cyBhbGFybV9wcmVjaXNpb24pXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudCB0ID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgIGFzc2VydCAoXG4gICAgICAgIE51bV9rZXlfYml0cy4oIDw9IClcbiAgICAgICAgICAoTGV2ZWxfYml0cy5udW1fYml0c19pbnRlcm5hbCB0LmxldmVsX2JpdHMpXG4gICAgICAgICAgKG1heF9udW1fbGV2ZWxfYml0cyB0LmFsYXJtX3ByZWNpc2lvbikpO1xuICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+YWxhcm1fcHJlY2lzaW9uOmlnbm9yZVxuICAgICAgICB+Y2FwYWNpdHk6aWdub3JlXG4gICAgICAgIH5sZXZlbF9iaXRzOihjaGVjayBMZXZlbF9iaXRzLmludmFyaWFudCkpXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSA/Y2FwYWNpdHkgPyhsZXZlbF9iaXRzID0gbGV2ZWxfYml0c19kZWZhdWx0KSB+YWxhcm1fcHJlY2lzaW9uICgpID1cbiAgICBsZXQgbGV2ZWxfYml0cyA9XG4gICAgICBMZXZlbF9iaXRzLnRyaW0gbGV2ZWxfYml0cyB+bWF4X251bV9iaXRzOihtYXhfbnVtX2xldmVsX2JpdHMgYWxhcm1fcHJlY2lzaW9uKVxuICAgIGluXG4gICAgeyBhbGFybV9wcmVjaXNpb247IGxldmVsX2JpdHM7IGNhcGFjaXR5IH1cbiAgOztcblxuICBsZXQgbWljcm9zZWNvbmRfcHJlY2lzaW9uICgpID1cbiAgICBjcmVhdGVcbiAgICAgICgpXG4gICAgICB+YWxhcm1fcHJlY2lzaW9uOkFsYXJtX3ByZWNpc2lvbi5hYm91dF9vbmVfbWljcm9zZWNvbmRcbiAgICAgIH5sZXZlbF9iaXRzOihMZXZlbF9iaXRzLmNyZWF0ZV9leG4gWyAxMDsgMTA7IDY7IDY7IDUgXSlcbiAgOztcblxuICBsZXQgZHVyYXRpb25zIHQgPVxuICAgIExpc3QuZm9sZGluZ19tYXBcbiAgICAgIHQubGV2ZWxfYml0c1xuICAgICAgfmluaXQ6KEFsYXJtX3ByZWNpc2lvbi5udW1fa2V5X2JpdHMgdC5hbGFybV9wcmVjaXNpb24gfD4gTnVtX2tleV9iaXRzLnRvX2ludClcbiAgICAgIH5mOihmdW4gbnVtX2JpdHNfYWNjdW0gbGV2ZWxfbnVtX2JpdHMgLT5cbiAgICAgICAgbGV0IG51bV9iaXRzX2FjY3VtID0gbnVtX2JpdHNfYWNjdW0gKyAobGV2ZWxfbnVtX2JpdHMgfD4gTnVtX2tleV9iaXRzLnRvX2ludCkgaW5cbiAgICAgICAgbGV0IGR1cmF0aW9uID1cbiAgICAgICAgICBUaW1lX25zLlNwYW4ub2ZfaW50NjNfbnNcbiAgICAgICAgICAgIChpZiBudW1fYml0c19hY2N1bSA9IEludDYzLm51bV9iaXRzIC0gMVxuICAgICAgICAgICAgIHRoZW4gSW50NjMubWF4X3ZhbHVlXG4gICAgICAgICAgICAgZWxzZSBJbnQ2My5zaGlmdF9sZWZ0IEludDYzLm9uZSBudW1fYml0c19hY2N1bSlcbiAgICAgICAgaW5cbiAgICAgICAgbnVtX2JpdHNfYWNjdW0sIGR1cmF0aW9uKVxuICA7O1xuZW5kXG5cbigqKiBUaW1pbmcgd2hlZWwgaXMgaW1wbGVtZW50ZWQgYXMgYSBwcmlvcml0eSBxdWV1ZSBpbiB3aGljaCB0aGUga2V5cyBhcmVcbiAgICBub24tbmVnYXRpdmUgaW50ZWdlcnMgY29ycmVzcG9uZGluZyB0byB0aGUgaW50ZXJ2YWxzIG9mIHRpbWUuICBUaGUgcHJpb3JpdHkgcXVldWUgaXNcbiAgICB1bmxpa2UgYSB0eXBpY2FsIHByaW9yaXR5IHF1ZXVlIGluIHRoYXQgcmF0aGVyIHRoYW4gaGF2aW5nIGEgXCJkZWxldGUgbWluXCIgb3BlcmF0aW9uLFxuICAgIGl0IGhhcyBhIG5vbmRlY3JlYXNpbmcgbWluaW11bSBhbGxvd2VkIGtleSwgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIGN1cnJlbnQgdGltZSxcbiAgICBhbmQgYW4gW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gb3BlcmF0aW9uLCB3aGljaCBpbXBsZW1lbnRzIFthZHZhbmNlX2Nsb2NrXS5cbiAgICBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSBhcyBhIHNpZGUgZWZmZWN0IHJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIHRpbWluZ1xuICAgIHdoZWVsIHdob3NlIGtleSBpcyBzbWFsbGVyIHRoYW4gdGhlIG5ldyBtaW5pbXVtLCB3aGljaCBpbXBsZW1lbnRzIGZpcmluZyB0aGUgYWxhcm1zXG4gICAgd2hvc2UgdGltZSBoYXMgZXhwaXJlZC5cblxuICAgIEFkZGluZyBlbGVtZW50cyB0byBhbmQgcmVtb3ZpbmcgZWxlbWVudHMgZnJvbSBhIHRpbWluZyB3aGVlbCB0YWtlcyBjb25zdGFudCB0aW1lLFxuICAgIHVubGlrZSBhIGhlYXAtYmFzZWQgcHJpb3JpdHkgcXVldWUgd2hpY2ggdGFrZXMgbG9nKE4pLCB3aGVyZSBOIGlzIHRoZSBudW1iZXIgb2ZcbiAgICBlbGVtZW50cyBpbiB0aGUgaGVhcC4gIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIHRha2VzIHRpbWUgcHJvcG9ydGlvbmFsIHRvIHRoZVxuICAgIGFtb3VudCBvZiBpbmNyZWFzZSBpbiB0aGUgbWluLWFsbG93ZWQga2V5LCBhcyBjb21wYXJlZCB0byBsb2coTikgZm9yIGEgaGVhcC4gIEl0IGlzXG4gICAgdGhlc2UgcGVyZm9ybWFuY2UgZGlmZmVyZW5jZXMgdGhhdCBtb3RpdmF0ZSB0aGUgZXhpc3RlbmNlIG9mIHRpbWluZyB3aGVlbHMgYW5kIG1ha2VcbiAgICB0aGVtIGEgZ29vZCBjaG9pY2UgZm9yIG1haW50YWluZyBhIHNldCBvZiBhbGFybXMuICBXaXRoIGEgdGltaW5nIHdoZWVsLCBvbmUgY2FuXG4gICAgc3VwcG9ydCBhbnkgbnVtYmVyIG9mIGFsYXJtcyBwYXlpbmcgY29uc3RhbnQgb3ZlcmhlYWQgcGVyIGFsYXJtLCB3aGlsZSBwYXlpbmcgYVxuICAgIHNtYWxsIGNvbnN0YW50IG92ZXJoZWFkIHBlciB1bml0IG9mIHRpbWUgcGFzc2VkLlxuXG4gICAgQXMgdGhlIG1pbmltdW0gYWxsb3dlZCBrZXkgaW5jcmVhc2VzLCB0aGUgdGltaW5nIHdoZWVsIGRvZXMgYSBsYXp5IHJhZGl4IHNvcnQgb2YgdGhlXG4gICAgZWxlbWVudCBrZXlzLCB3aXRoIGxldmVsIDAgaGFuZGxpbmcgdGhlIGxlYXN0IHNpZ25pZmljYW50IFtiXzBdIGJpdHMgaW4gYSBrZXksIGFuZFxuICAgIGVhY2ggc3Vic2VxdWVudCBsZXZlbCBbaV0gaGFuZGxpbmcgdGhlIG5leHQgbW9zdCBzaWduaWZpY2FudCBbYl9pXSBiaXRzLiAgVGhlIGxldmVsc1xuICAgIGhvbGQgaW5jcmVhc2luZ2x5IGxhcmdlciByYW5nZXMgb2Yga2V5cywgd2hlcmUgdGhlIHVuaW9uIG9mIGFsbCB0aGUgbGV2ZWxzIGNhbiBob2xkXG4gICAgYW55IGtleSBmcm9tIFttaW5fYWxsb3dlZF9rZXkgdF0gdG8gW21heF9hbGxvd2VkX2tleSB0XS4gIFdoZW4gYSBrZXkgaXMgYWRkZWQgdG8gdGhlXG4gICAgdGltaW5nIHdoZWVsLCBpdCBpcyBhZGRlZCBhdCB0aGUgbG93ZXN0IHBvc3NpYmxlIGxldmVsIHRoYXQgY2FuIHN0b3JlIHRoZSBrZXkuICBBc1xuICAgIHRoZSBtaW5pbXVtIGFsbG93ZWQga2V5IGluY3JlYXNlcywgdGltaW5nLXdoZWVsIGVsZW1lbnRzIG1vdmUgZG93biBsZXZlbHMgdW50aWwgdGhleVxuICAgIHJlYWNoIGxldmVsIDAsIGFuZCB0aGVuIGFyZSBldmVudHVhbGx5IHJlbW92ZWQuICAqKVxubW9kdWxlIFByaW9yaXR5X3F1ZXVlIDogc2lnXG4gIHR5cGUgJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICB0eXBlICdhIHByaW9yaXR5X3F1ZXVlID0gJ2EgdFxuXG4gIG1vZHVsZSBLZXkgOiBJbnRlcnZhbF9udW1cblxuICBtb2R1bGUgRWx0IDogc2lnXG4gICAgKCoqIEFuIFtFbHQudF0gcmVwcmVzZW50cyBhbiBlbGVtZW50IHRoYXQgd2FzIGFkZGVkIHRvIGEgdGltaW5nIHdoZWVsLiAqKVxuICAgIHR5cGUgJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgdmFsIGF0IDogJ2EgcHJpb3JpdHlfcXVldWUgLT4gJ2EgdCAtPiBUaW1lX25zLnRcbiAgICB2YWwga2V5IDogJ2EgcHJpb3JpdHlfcXVldWUgLT4gJ2EgdCAtPiBLZXkudFxuICAgIHZhbCB2YWx1ZSA6ICdhIHByaW9yaXR5X3F1ZXVlIC0+ICdhIHQgLT4gJ2FcbiAgICB2YWwgbnVsbCA6IHVuaXQgLT4gJ2EgdFxuICBlbmRcblxuICBtb2R1bGUgSW50ZXJuYWxfZWx0IDogc2lnXG4gICAgbW9kdWxlIFBvb2wgOiBzaWdcbiAgICAgIHR5cGUgJ2EgdFxuICAgIGVuZFxuXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwga2V5IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gS2V5LnRcbiAgICB2YWwgbWF4X2FsYXJtX3RpbWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB3aXRoX2tleTpLZXkudCAtPiBUaW1lX25zLnRcbiAgICB2YWwgbWluX2FsYXJtX3RpbWUgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB3aXRoX2tleTpLZXkudCAtPiBUaW1lX25zLnRcbiAgICB2YWwgaXNfbnVsbCA6IF8gdCAtPiBib29sXG4gICAgdmFsIHRvX2V4dGVybmFsIDogJ2EgdCAtPiAnYSBFbHQudFxuICBlbmRcblxuICB2YWwgcG9vbCA6ICdhIHQgLT4gJ2EgSW50ZXJuYWxfZWx0LlBvb2wudFxuXG4gIGluY2x1ZGUgSW52YXJpYW50LlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAoKiogW2NyZWF0ZSA/bGV2ZWxfYml0cyAoKV0gY3JlYXRlcyBhIG5ldyBlbXB0eSB0aW1pbmcgd2hlZWwsIFt0XSwgd2l0aCBbbGVuZ3RoIHQgPSAwXVxuICAgICAgYW5kIFttaW5fYWxsb3dlZF9rZXkgdCA9IDBdLiAqKVxuICB2YWwgY3JlYXRlIDogP2NhcGFjaXR5OmludCAtPiA/bGV2ZWxfYml0czpMZXZlbF9iaXRzLnQgLT4gdW5pdCAtPiAnYSB0XG5cbiAgKCoqIFtsZW5ndGggdF0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0aW1pbmcgd2hlZWwuICopXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG5cbiAgKCoqIFttaW5fYWxsb3dlZF9rZXkgdF0gaXMgdGhlIG1pbmltdW0ga2V5IHRoYXQgY2FuIGJlIHN0b3JlZCBpbiBbdF0uICBUaGlzIG9ubHlcbiAgICAgIGluZGljYXRlcyB0aGUgcG9zc2liaWxpdHk7IHRoZXJlIG5lZWQgbm90IGJlIGFuIGVsZW1lbnQgW2VsdF0gaW4gW3RdIHdpdGggW0VsdC5rZXlcbiAgICAgIGVsdCA9IG1pbl9hbGxvd2VkX2tleSB0XS4gIFRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBcIm1pbl9rZXlcIiBvcGVyYXRpb24gaW4gYVxuICAgICAgdHlwaWNhbCBwcmlvcml0eSBxdWV1ZS5cblxuICAgICAgW21pbl9hbGxvd2VkX2tleSB0XSBjYW4gaW5jcmVhc2Ugb3ZlciB0aW1lLCB2aWEgY2FsbHMgdG9cbiAgICAgIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldLiAqKVxuICB2YWwgbWluX2FsbG93ZWRfa2V5IDogXyB0IC0+IEtleS50XG5cbiAgKCoqIFttYXhfYWxsb3dlZF9rZXkgdF0gaXMgdGhlIG1heGltdW0gYWxsb3dlZCBrZXkgdGhhdCBjYW4gYmUgc3RvcmVkIGluIFt0XS4gIEFzXG4gICAgICBbbWluX2FsbG93ZWRfa2V5XSBpbmNyZWFzZXMsIHNvIGRvZXMgW21heF9hbGxvd2VkX2tleV07IGhvd2V2ZXIgaXQgaXMgbm90IHRoZSBjYXNlXG4gICAgICB0aGF0IFttYXhfYWxsb3dlZF9rZXkgdCAtIG1pbl9hbGxvd2VkX2tleSB0XSBpcyBhIGNvbnN0YW50LiAgSXQgaXMgZ3VhcmFudGVlZCB0aGF0XG4gICAgICBbbWF4X2FsbG93ZWRfa2V5IHQgPj0gbWluX2FsbG93ZWRfa2V5IHQgKyAyXkIgLSAxXSxcbiAgICAgIHdoZXJlIFtCXSBpcyB0aGUgc3VtIG9mIHRoZSBiX2kgaW4gW2xldmVsX2JpdHNdLiAqKVxuICB2YWwgbWF4X2FsbG93ZWRfa2V5IDogXyB0IC0+IEtleS50XG5cbiAgdmFsIG1pbl9lbHRfIDogJ2EgdCAtPiAnYSBJbnRlcm5hbF9lbHQudFxuICB2YWwgaW50ZXJuYWxfYWRkIDogJ2EgdCAtPiBrZXk6S2V5LnQgLT4gYXQ6VGltZV9ucy50IC0+ICdhIC0+ICdhIEludGVybmFsX2VsdC50XG5cbiAgKCoqIFtyZW1vdmUgdCBlbHRdIHJlbW92ZXMgW2VsdF0gZnJvbSBbdF0uICBJdCBpcyBhbiBlcnJvciBpZiBbZWx0XSBpcyBub3QgY3VycmVudGx5XG4gICAgICBpbiBbdF0sIGFuZCB0aGlzIGVycm9yIG1heSBvciBtYXkgbm90IGJlIGRldGVjdGVkLiAqKVxuICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiAnYSBFbHQudCAtPiB1bml0XG5cbiAgdmFsIGNoYW5nZSA6ICdhIHQgLT4gJ2EgRWx0LnQgLT4ga2V5OktleS50IC0+IGF0OlRpbWVfbnMudCAtPiB1bml0XG5cbiAgKCoqIFtjbGVhciB0XSByZW1vdmVzIGFsbCBlbHRzIGZyb20gW3RdLiAqKVxuICB2YWwgY2xlYXIgOiBfIHQgLT4gdW5pdFxuXG4gIHZhbCBtZW0gOiAnYSB0IC0+ICdhIEVsdC50IC0+IGJvb2xcblxuICBtb2R1bGUgSW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5X3Jlc3VsdCA6IHNpZ1xuICAgIHR5cGUgdCA9XG4gICAgICB8IE1heF9hbGxvd2VkX2tleV9kaWRfbm90X2NoYW5nZVxuICAgICAgfCBNYXhfYWxsb3dlZF9rZXlfbWF5YmVfY2hhbmdlZFxuICBlbmRcblxuICAoKiogW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleSB0IH5rZXkgfmhhbmRsZV9yZW1vdmVkXSBpbmNyZWFzZXMgdGhlIG1pbmltdW0gYWxsb3dlZFxuICAgICAga2V5IGluIFt0XSB0byBba2V5XSwgYW5kIHJlbW92ZXMgYWxsIGVsZW1lbnRzIHdpdGgga2V5cyBsZXNzIHRoYW4gW2tleV0sIGFwcGx5aW5nXG4gICAgICBbaGFuZGxlX3JlbW92ZWRdIHRvIGVhY2ggZWxlbWVudCB0aGF0IGlzIHJlbW92ZWQuICBJZiBba2V5IDw9IG1pbl9hbGxvd2VkX2tleSB0XSxcbiAgICAgIHRoZW4gW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gZG9lcyBub3RoaW5nLiAgT3RoZXJ3aXNlLCBpZlxuICAgICAgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gcmV0dXJucyBzdWNjZXNzZnVsbHksIFttaW5fYWxsb3dlZF9rZXkgdCA9IGtleV0uXG5cbiAgICAgIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIHRha2VzIHRpbWUgcHJvcG9ydGlvbmFsIHRvIFtrZXkgLSBtaW5fYWxsb3dlZF9rZXkgdF0sXG4gICAgICBhbHRob3VnaCBwb3NzaWJseSBsZXNzIHRpbWUuXG5cbiAgICAgIEJlaGF2aW9yIGlzIHVuc3BlY2lmaWVkIGlmIFtoYW5kbGVfcmVtb3ZlZF0gYWNjZXNzZXMgW3RdIGluIGFueSB3YXkgb3RoZXIgdGhhblxuICAgICAgW0VsdF0gZnVuY3Rpb25zLiAqKVxuICB2YWwgaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XG4gICAgOiAgJ2EgdFxuICAgIC0+IGtleTpLZXkudFxuICAgIC0+IGhhbmRsZV9yZW1vdmVkOignYSBFbHQudCAtPiB1bml0KVxuICAgIC0+IEluY3JlYXNlX21pbl9hbGxvd2VkX2tleV9yZXN1bHQudFxuXG4gIHZhbCBpdGVyIDogJ2EgdCAtPiBmOignYSBFbHQudCAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGZpcmVfcGFzdF9hbGFybXNcbiAgICA6ICAnYSB0XG4gICAgLT4gaGFuZGxlX2ZpcmVkOignYSBFbHQudCAtPiB1bml0KVxuICAgIC0+IGtleTpLZXkudFxuICAgIC0+IG5vdzpUaW1lX25zLnRcbiAgICAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgKCoqIEVhY2ggc2xvdCBpbiBhIGxldmVsIGlzIGEgKHBvc3NpYmx5IG51bGwpIHBvaW50ZXIgdG8gYSBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3RcbiAgICAgIG9mIGVsZW1lbnRzLiAgV2UgcG9vbCB0aGUgZWxlbWVudHMgc28gdGhhdCB3ZSBjYW4gcmV1c2UgdGhlbSBhZnRlciB0aGV5IGFyZSByZW1vdmVkXG4gICAgICBmcm9tIHRoZSB0aW1pbmcgd2hlZWwgKGVpdGhlciB2aWEgW3JlbW92ZV0gb3IgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0pLiAgSW5cbiAgICAgIGFkZGl0aW9uIHRvIHN0b3JpbmcgdGhlIFtrZXldLCBbYXRdLCBhbmQgW3ZhbHVlXSBpbiB0aGUgZWxlbWVudCwgd2Ugc3RvcmUgdGhlXG4gICAgICBbbGV2ZWxfaW5kZXhdIHNvIHRoYXQgd2UgY2FuIHF1aWNrbHkgZ2V0IHRvIHRoZSBsZXZlbCBob2xkaW5nIGFuIGVsZW1lbnQgd2hlbiB3ZVxuICAgICAgW3JlbW92ZV0gaXQuXG5cbiAgICAgIFdlIGRpc3Rpbmd1aXNoIGJldHdlZW4gW0V4dGVybmFsX2VsdF0gYW5kIFtJbnRlcm5hbF9lbHRdLCB3aGljaCBhcmUgdGhlIHNhbWVcbiAgICAgIHVuZGVybmVhdGguICBXZSBtYWludGFpbiB0aGUgaW52YXJpYW50IHRoYXQgYW4gW0ludGVybmFsX2VsdF0gaXMgZWl0aGVyIFtudWxsXSBvciBhXG4gICAgICB2YWxpZCBwb2ludGVyLiAgT24gdGhlIG90aGVyIGhhbmQsIFtFeHRlcm5hbF9lbHRdcyBhcmUgcmV0dXJuZWQgdG8gdXNlciBjb2RlLCBzb1xuICAgICAgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIG9mIHZhbGlkaXR5IC0tIHdlIGFsd2F5cyB2YWxpZGF0ZSBhbiBbRXh0ZXJuYWxfZWx0XSBiZWZvcmVcbiAgICAgIGRvaW5nIGFueXRoaW5nIHdpdGggaXQuXG5cbiAgICAgIEl0IGlzIHRoZXJlZm9yZSBPSyB0byB1c2UgW1Bvb2wuVW5zYWZlXSwgYmVjYXVzZSB3ZSB3aWxsIG5ldmVyIGF0dGVtcHQgdG8gYWNjZXNzIGFcbiAgICAgIHNsb3Qgb2YgYW4gaW52YWxpZCBwb2ludGVyLiAqKVxuICBtb2R1bGUgUG9vbCA9IFBvb2wuVW5zYWZlXG5cbiAgbW9kdWxlIFBvaW50ZXIgPSBQb29sLlBvaW50ZXJcblxuICBtb2R1bGUgS2V5IDogc2lnXG4gICAgKCoqIFtJbnRlcnZhbF9udW1dIGlzIHRoZSBwdWJsaWMgQVBJLiAgRXZlcnl0aGluZyBmb2xsb3dpbmcgaW4gdGhlIHNpZ25hdHVyZSBpc1xuICAgICAgICBmb3IgaW50ZXJuYWwgdXNlLiAqKVxuICAgIGluY2x1ZGUgVGltaW5nX3doZWVsX2ludGYuSW50ZXJ2YWxfbnVtXG5cbiAgICAoKiogW2FkZF9jbGFtcF90b19tYXhdIGRvZXNuJ3Qgd29yayBhdCBhbGwgd2l0aCBuZWdhdGl2ZSBzcGFucyAqKVxuICAgIHZhbCBhZGRfY2xhbXBfdG9fbWF4IDogdCAtPiBTcGFuLnQgLT4gdFxuXG4gICAgdmFsIHN1Y2NfY2xhbXBfdG9fbWF4IDogdCAtPiB0XG5cbiAgICAoKiogW1Nsb3RzX21hc2tdIGlzIHVzZWQgdG8gcXVpY2tseSBkZXRlcm1pbmUgYSBrZXkncyBzbG90IGluIGEgZ2l2ZW4gbGV2ZWwuICopXG4gICAgbW9kdWxlIFNsb3RzX21hc2sgOiBzaWdcbiAgICAgIHR5cGUgdCA9IHByaXZhdGUgSW50NjMudCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgICB2YWwgY3JlYXRlIDogbGV2ZWxfYml0czpOdW1fa2V5X2JpdHMudCAtPiB0XG4gICAgICB2YWwgbmV4dF9zbG90IDogdCAtPiBpbnQgLT4gaW50XG4gICAgZW5kXG5cbiAgICAoKiogW01pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tdIGlzIHVzZWQgdG8gcXVpY2tseSBkZXRlcm1pbmUgdGhlIG1pbmltdW0ga2V5IGluIHRoZVxuICAgICAgICBzYW1lIHNsb3QgYXMgYSBnaXZlbiBrZXkuICopXG4gICAgbW9kdWxlIE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgOiBzaWdcbiAgICAgIHR5cGUgdCA9IHByaXZhdGUgSW50NjMudCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgICBpbmNsdWRlIEVxdWFsLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgICB2YWwgY3JlYXRlIDogYml0c19wZXJfc2xvdDpOdW1fa2V5X2JpdHMudCAtPiB0XG4gICAgZW5kXG5cbiAgICB2YWwgbnVtX2tleXMgOiBOdW1fa2V5X2JpdHMudCAtPiBTcGFuLnRcbiAgICB2YWwgbWluX2tleV9pbl9zYW1lX3Nsb3QgOiB0IC0+IE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sudCAtPiB0XG4gICAgdmFsIHNsb3QgOiB0IC0+IGJpdHNfcGVyX3Nsb3Q6TnVtX2tleV9iaXRzLnQgLT4gc2xvdHNfbWFzazpTbG90c19tYXNrLnQgLT4gaW50XG4gIGVuZCA9IHN0cnVjdFxuICAgIG1vZHVsZSBTbG90c19tYXNrID0gc3RydWN0XG4gICAgICB0eXBlIHQgPSBJbnQ2My50IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICAgIGxldCBjcmVhdGUgfmxldmVsX2JpdHMgPSBJbnQ2My4oIC0gKSAoTnVtX2tleV9iaXRzLnBvdzIgbGV2ZWxfYml0cykgSW50NjMub25lXG4gICAgICBsZXQgbmV4dF9zbG90IHQgc2xvdCA9IChzbG90ICsgMSkgbGFuZCBJbnQ2My50b19pbnRfZXhuIHRcbiAgICBlbmRcblxuICAgIGxldCBudW1fa2V5cyBudW1fYml0cyA9IE51bV9rZXlfYml0cy5wb3cyIG51bV9iaXRzXG5cbiAgICBtb2R1bGUgTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBJbnQ2M1xuXG4gICAgICBsZXQgY3JlYXRlIH5iaXRzX3Blcl9zbG90ID0gYml0X25vdCAoTnVtX2tleV9iaXRzLnBvdzIgYml0c19wZXJfc2xvdCAtIG9uZSlcbiAgICBlbmRcblxuICAgIG1vZHVsZSBTcGFuID0gc3RydWN0XG4gICAgICBpbmNsdWRlIEludDYzXG5cbiAgICAgIGxldCB0b19pbnQ2MyB0ID0gdFxuICAgICAgbGV0IG9mX2ludDYzIGkgPSBpXG4gICAgICBsZXQgc2NhbGVfaW50IHQgaSA9IHQgKiBvZl9pbnQgaVxuICAgIGVuZFxuXG4gICAgaW5jbHVkZSBJbnQ2M1xuXG4gICAgbGV0IG9mX2ludDYzIGkgPSBpXG4gICAgbGV0IHRvX2ludDYzIHQgPSB0XG4gICAgbGV0IGFkZCB0IGkgPSB0ICsgaVxuICAgIGxldCBhZGRfY2xhbXBfdG9fbWF4IHQgaSA9IGlmIHQgPiBtYXhfdmFsdWUgLSBpIHRoZW4gbWF4X3ZhbHVlIGVsc2UgdCArIGlcbiAgICBsZXQgc3VjY19jbGFtcF90b19tYXggdCA9IGlmIHQgPSBtYXhfdmFsdWUgdGhlbiBtYXhfdmFsdWUgZWxzZSBzdWNjIHRcbiAgICBsZXQgc3ViIHQgaSA9IHQgLSBpXG4gICAgbGV0IGRpZmYgdDEgdDIgPSB0MSAtIHQyXG5cbiAgICBsZXQgc2xvdCB0IH4oYml0c19wZXJfc2xvdCA6IE51bV9rZXlfYml0cy50KSB+c2xvdHNfbWFzayA9XG4gICAgICB0b19pbnRfZXhuIChiaXRfYW5kIChzaGlmdF9yaWdodCB0IChiaXRzX3Blcl9zbG90IDo+IGludCkpIHNsb3RzX21hc2spXG4gICAgOztcblxuICAgIGxldCBtaW5fa2V5X2luX3NhbWVfc2xvdCB0IG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgPVxuICAgICAgYml0X2FuZCB0IG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayA9IEtleS5NaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gIG1vZHVsZSBTbG90c19tYXNrID0gS2V5LlNsb3RzX21hc2tcblxuICBtb2R1bGUgRXh0ZXJuYWxfZWx0ID0gc3RydWN0XG4gICAgKCoqIFRoZSBbcG9vbF9zbG90c10gaGVyZSBoYXMgbm90aGluZyB0byBkbyB3aXRoIHRoZSBzbG90cyBpbiBhIGxldmVsIGFycmF5LiAgVGhpcyBpc1xuICAgICAgICBmb3IgdGhlIHNsb3RzIGluIHRoZSBwb29sIHR1cGxlIHJlcHJlc2VudGluZyBhIGxldmVsIGVsZW1lbnQuICopXG4gICAgdHlwZSAnYSBwb29sX3Nsb3RzID1cbiAgICAgICggS2V5LnRcbiAgICAgICwgVGltZV9ucy50XG4gICAgICAsICdhXG4gICAgICAsIGludFxuICAgICAgLCAnYSBwb29sX3Nsb3RzIFBvaW50ZXIudFxuICAgICAgLCAnYSBwb29sX3Nsb3RzIFBvaW50ZXIudCApXG4gICAgICBQb29sLlNsb3RzLnQ2XG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIHR5cGUgJ2EgdCA9ICdhIHBvb2xfc2xvdHMgUG9pbnRlci50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICBsZXQgbnVsbCA9IFBvaW50ZXIubnVsbFxuICBlbmRcblxuICBtb2R1bGUgSW50ZXJuYWxfZWx0IDogc2lnXG4gICAgbW9kdWxlIFBvb2wgOiBzaWdcbiAgICAgIHR5cGUgJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgICBpbmNsdWRlIEludmFyaWFudC5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICAgIHZhbCBjcmVhdGUgOiA/Y2FwYWNpdHk6aW50IC0+IHVuaXQgLT4gXyB0XG4gICAgICB2YWwgaXNfZnVsbCA6IF8gdCAtPiBib29sXG4gICAgICB2YWwgZ3JvdyA6ID9jYXBhY2l0eTppbnQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgZW5kXG5cbiAgICB0eXBlICdhIHQgPSBwcml2YXRlICdhIEV4dGVybmFsX2VsdC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICB2YWwgbnVsbCA6IHVuaXQgLT4gXyB0XG4gICAgdmFsIGlzX251bGwgOiBfIHQgLT4gYm9vbFxuICAgIHZhbCBpc192YWxpZCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IGJvb2xcblxuICAgICgqKiBEZWFsaW5nIHdpdGggW0V4dGVybmFsX2VsdF1zLiAqKVxuXG4gICAgdmFsIGV4dGVybmFsX2lzX3ZhbGlkIDogJ2EgUG9vbC50IC0+ICdhIEV4dGVybmFsX2VsdC50IC0+IGJvb2xcbiAgICB2YWwgdG9fZXh0ZXJuYWwgOiAnYSB0IC0+ICdhIEV4dGVybmFsX2VsdC50XG4gICAgdmFsIG9mX2V4dGVybmFsX2V4biA6ICdhIFBvb2wudCAtPiAnYSBFeHRlcm5hbF9lbHQudCAtPiAnYSB0XG4gICAgdmFsIGVxdWFsIDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaW52YXJpYW50IDogJ2EgUG9vbC50IC0+ICgnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcblxuICAgICgqKiBbY3JlYXRlXSByZXR1cm5zIGFuIGVsZW1lbnQgd2hvc2UgW25leHRdIGFuZCBbcHJldl0gYXJlIFtudWxsXS4gKilcbiAgICB2YWwgY3JlYXRlXG4gICAgICA6ICAnYSBQb29sLnRcbiAgICAgIC0+IGtleTpLZXkudFxuICAgICAgICAgICAoKiogW2F0XSBpcyB1c2VkIHdoZW4gdGhlIHByaW9yaXR5IHF1ZXVlIGlzIHVzZWQgdG8gaW1wbGVtZW50IGEgdGltaW5nIHdoZWVsLiAgSWZcbiAgICAgICAgICB1bnVzZWQsIGl0IHdpbGwgYmUgW1RpbWVfbnMuZXBvY2hdLiAqKVxuICAgICAgLT4gYXQ6VGltZV9ucy50XG4gICAgICAtPiB2YWx1ZTonYVxuICAgICAgLT4gbGV2ZWxfaW5kZXg6aW50XG4gICAgICAtPiAnYSB0XG5cbiAgICB2YWwgZnJlZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHVuaXRcblxuICAgICgqKiBhY2Nlc3NvcnMgKilcblxuICAgIHZhbCBrZXkgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBLZXkudFxuICAgIHZhbCBhdCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IFRpbWVfbnMudFxuICAgIHZhbCBsZXZlbF9pbmRleCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IGludFxuICAgIHZhbCBuZXh0IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCB2YWx1ZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+ICdhXG5cbiAgICAoKiogbXV0YXRvcnMgKilcblxuICAgIHZhbCBzZXRfa2V5IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gS2V5LnQgLT4gdW5pdFxuICAgIHZhbCBzZXRfYXQgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBUaW1lX25zLnQgLT4gdW5pdFxuICAgIHZhbCBzZXRfbGV2ZWxfaW5kZXggOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBpbnQgLT4gdW5pdFxuXG4gICAgKCoqIFtpbnNlcnRfYXRfZW5kIHBvb2wgdCB+dG9fYWRkXSB0cmVhdHMgW3RdIGFzIHRoZSBoZWFkIG9mIHRoZSBsaXN0IGFuZCBhZGRzIFt0b19hZGRdXG4gICAgICAgIHRvIHRoZSBlbmQgb2YgaXQuICopXG4gICAgdmFsIGluc2VydF9hdF9lbmQgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB0b19hZGQ6J2EgdCAtPiB1bml0XG5cbiAgICAoKiogW2xpbmtfdG9fc2VsZiBwb29sIHRdIG1ha2VzIFt0XSBiZSBhIHNpbmdsZXRvbiBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3QuICopXG4gICAgdmFsIGxpbmtfdG9fc2VsZiA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHVuaXRcblxuICAgICgqKiBbdW5saW5rIHAgdF0gdW5saW5rcyBbdF0gZnJvbSB0aGUgY2lyY3VsYXJseSBkb3VibHktbGlua2VkIGxpc3QgdGhhdCBpdCBpcyBpbi4gIEl0XG4gICAgICAgIGNoYW5nZXMgdGhlIHBvaW50ZXJzIG9mIFt0XSdzIFtwcmV2XSBhbmQgW25leHRdIGVsdHMsIGJ1dCBub3QgW3RdJ3MgW3ByZXZdIGFuZFxuICAgICAgICBbbmV4dF0gcG9pbnRlcnMuICBbdW5saW5rXSBpcyBtZWFuaW5nbGVzcyBpZiBbdF0gaXMgYSBzaW5nbGV0b24uICopXG4gICAgdmFsIHVubGluayA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHVuaXRcblxuICAgICgqKiBJdGVyYXRvcnMuICBbaXRlciBwIHQgfmluaXQgfmZdIHZpc2l0cyBlYWNoIGVsZW1lbnQgaW4gdGhlIGRvdWJseS1saW5rZWQgbGlzdFxuICAgICAgICBjb250YWluaW5nIFt0XSwgc3RhcnRpbmcgYXQgW3RdLCBhbmQgZm9sbG93aW5nIFtuZXh0XSBwb2ludGVycy4gIFtsZW5ndGhdIGNvdW50c1xuICAgICAgICBieSB2aXNpdGluZyBlYWNoIGVsZW1lbnQgaW4gdGhlIGxpc3QuICopXG4gICAgdmFsIGl0ZXIgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBmOignYSB0IC0+IHVuaXQpIC0+IHVuaXRcblxuICAgIHZhbCBsZW5ndGggOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBpbnRcblxuICAgICgqKiBbbWF4X2FsYXJtX3RpbWUgdCBlbHQgfndpdGhfa2V5XSBmaW5kcyB0aGUgbWF4IFthdF0gaW4gW2VsdF0ncyBsaXN0IGFtb25nIHRoZSBlbHRzXG4gICAgICAgIHdob3NlIGtleSBpcyBbd2l0aF9rZXldLCByZXR1cm5pbmcgW1RpbWVfbnMuZXBvY2hdIGlmIHRoZSBsaXN0IGlzIGVtcHR5LiAqKVxuICAgIHZhbCBtYXhfYWxhcm1fdGltZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHdpdGhfa2V5OktleS50IC0+IFRpbWVfbnMudFxuXG4gICAgdmFsIG1pbl9hbGFybV90aW1lIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gd2l0aF9rZXk6S2V5LnQgLT4gVGltZV9ucy50XG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgcG9vbF9zbG90cyA9ICdhIEV4dGVybmFsX2VsdC5wb29sX3Nsb3RzIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gICAgdHlwZSAnYSB0ID0gJ2EgRXh0ZXJuYWxfZWx0LnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGxldCBudWxsID0gUG9pbnRlci5udWxsXG4gICAgbGV0IGlzX251bGwgPSBQb2ludGVyLmlzX251bGxcbiAgICBsZXQgZXF1YWwgdDEgdDIgPSBQb2ludGVyLnBoeXNfZXF1YWwgdDEgdDJcblxuICAgIGxldCBjcmVhdGUgcG9vbCB+a2V5IH5hdCB+dmFsdWUgfmxldmVsX2luZGV4ID1cbiAgICAgIFBvb2wubmV3NiBwb29sIGtleSBhdCB2YWx1ZSBsZXZlbF9pbmRleCAobnVsbCAoKSkgKG51bGwgKCkpXG4gICAgOztcblxuICAgIGxldCBmcmVlID0gUG9vbC5mcmVlXG4gICAgbGV0IGtleSBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQwXG4gICAgbGV0IHNldF9rZXkgcCB0IGsgPSBQb29sLnNldCBwIHQgUG9vbC5TbG90LnQwIGtcbiAgICBsZXQgYXQgcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50MVxuICAgIGxldCBzZXRfYXQgcCB0IHggPSBQb29sLnNldCBwIHQgUG9vbC5TbG90LnQxIHhcbiAgICBsZXQgdmFsdWUgcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50MlxuICAgIGxldCBsZXZlbF9pbmRleCBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQzXG4gICAgbGV0IHNldF9sZXZlbF9pbmRleCBwIHQgaSA9IFBvb2wuc2V0IHAgdCBQb29sLlNsb3QudDMgaVxuICAgIGxldCBwcmV2IHAgdCA9IFBvb2wuZ2V0IHAgdCBQb29sLlNsb3QudDRcbiAgICBsZXQgc2V0X3ByZXYgcCB0IHggPSBQb29sLnNldCBwIHQgUG9vbC5TbG90LnQ0IHhcbiAgICBsZXQgbmV4dCBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQ1XG4gICAgbGV0IHNldF9uZXh0IHAgdCB4ID0gUG9vbC5zZXQgcCB0IFBvb2wuU2xvdC50NSB4XG4gICAgbGV0IGlzX3ZhbGlkIHAgdCA9IFBvb2wucG9pbnRlcl9pc192YWxpZCBwIHRcbiAgICBsZXQgZXh0ZXJuYWxfaXNfdmFsaWQgPSBpc192YWxpZFxuXG4gICAgbGV0IGludmFyaWFudCBwb29sIGludmFyaWFudF9hIHQgPVxuICAgICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICAgICAgYXNzZXJ0IChpc192YWxpZCBwb29sIHQpO1xuICAgICAgICBpbnZhcmlhbnRfYSAodmFsdWUgcG9vbCB0KTtcbiAgICAgICAgbGV0IG4gPSBuZXh0IHBvb2wgdCBpblxuICAgICAgICBhc3NlcnQgKGlzX251bGwgbiB8fCBQb2ludGVyLnBoeXNfZXF1YWwgdCAocHJldiBwb29sIG4pKTtcbiAgICAgICAgbGV0IHAgPSBwcmV2IHBvb2wgdCBpblxuICAgICAgICBhc3NlcnQgKGlzX251bGwgcCB8fCBQb2ludGVyLnBoeXNfZXF1YWwgdCAobmV4dCBwb29sIHApKSlcbiAgICA7O1xuXG4gICAgbW9kdWxlIFBvb2wgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIHBvb2xfc2xvdHMgUG9vbC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICAgIGxldCBpbnZhcmlhbnQgX2ludmFyaWFudF9hIHQgPSBQb29sLmludmFyaWFudCBpZ25vcmUgdFxuICAgICAgbGV0IGNyZWF0ZSA/KGNhcGFjaXR5ID0gMSkgKCkgPSBQb29sLmNyZWF0ZSBQb29sLlNsb3RzLnQ2IH5jYXBhY2l0eVxuICAgICAgbGV0IGdyb3cgPSBQb29sLmdyb3dcbiAgICAgIGxldCBpc19mdWxsID0gUG9vbC5pc19mdWxsXG4gICAgZW5kXG5cbiAgICBsZXQgdG9fZXh0ZXJuYWwgdCA9IHRcblxuICAgIGxldCBvZl9leHRlcm5hbF9leG4gcG9vbCB0ID1cbiAgICAgIGlmIGlzX3ZhbGlkIHBvb2wgdCB0aGVuIHQgZWxzZSByYWlzZV9zIFslbWVzc2FnZSBcIlRpbWluZ193aGVlbCBnb3QgaW52YWxpZCBhbGFybVwiXVxuICAgIDs7XG5cbiAgICBsZXQgdW5saW5rIHBvb2wgdCA9XG4gICAgICBzZXRfbmV4dCBwb29sIChwcmV2IHBvb2wgdCkgKG5leHQgcG9vbCB0KTtcbiAgICAgIHNldF9wcmV2IHBvb2wgKG5leHQgcG9vbCB0KSAocHJldiBwb29sIHQpXG4gICAgOztcblxuICAgIGxldCBsaW5rIHBvb2wgcHJldiBuZXh0ID1cbiAgICAgIHNldF9uZXh0IHBvb2wgcHJldiBuZXh0O1xuICAgICAgc2V0X3ByZXYgcG9vbCBuZXh0IHByZXZcbiAgICA7O1xuXG4gICAgbGV0IGxpbmtfdG9fc2VsZiBwb29sIHQgPSBsaW5rIHBvb2wgdCB0XG5cbiAgICBsZXQgaW5zZXJ0X2F0X2VuZCBwb29sIHQgfnRvX2FkZCA9XG4gICAgICBsZXQgcHJldiA9IHByZXYgcG9vbCB0IGluXG4gICAgICBsaW5rIHBvb2wgcHJldiB0b19hZGQ7XG4gICAgICBsaW5rIHBvb2wgdG9fYWRkIHRcbiAgICA7O1xuXG4gICAgbGV0IGl0ZXIgcG9vbCBmaXJzdCB+ZiA9XG4gICAgICBsZXQgY3VycmVudCA9IHJlZiBmaXJzdCBpblxuICAgICAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICAoKiBXZSBnZXQgW25leHRdIGJlZm9yZSBjYWxsaW5nIFtmXSBzbyB0aGF0IFtmXSBjYW4gbW9kaWZ5IG9yIFtmcmVlXSBbIWN1cnJlbnRdLiAqKVxuICAgICAgICBsZXQgbmV4dCA9IG5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgICBmICFjdXJyZW50O1xuICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgZG9uZVxuICAgIDs7XG5cbiAgICBsZXQgbGVuZ3RoIHBvb2wgZmlyc3QgPVxuICAgICAgbGV0IHIgPSByZWYgMCBpblxuICAgICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgaW5jciByO1xuICAgICAgICBsZXQgbmV4dCA9IG5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgZG9uZTtcbiAgICAgICFyXG4gICAgOztcblxuICAgIGxldCBtYXhfYWxhcm1fdGltZSBwb29sIGZpcnN0IH53aXRoX2tleSA9XG4gICAgICBsZXQgbWF4X2FsYXJtX3RpbWUgPSByZWYgVGltZV9ucy5lcG9jaCBpblxuICAgICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgbGV0IG5leHQgPSBuZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgaWYgS2V5LmVxdWFsIChrZXkgcG9vbCAhY3VycmVudCkgd2l0aF9rZXlcbiAgICAgICAgdGhlbiBtYXhfYWxhcm1fdGltZSA6PSBUaW1lX25zLm1heCAoYXQgcG9vbCAhY3VycmVudCkgIW1heF9hbGFybV90aW1lO1xuICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgZG9uZTtcbiAgICAgICFtYXhfYWxhcm1fdGltZVxuICAgIDs7XG5cbiAgICBsZXQgbWluX2FsYXJtX3RpbWUgcG9vbCBmaXJzdCB+d2l0aF9rZXkgPVxuICAgICAgbGV0IG1pbl9hbGFybV90aW1lID0gcmVmIFRpbWVfbnMubWF4X3ZhbHVlX3JlcHJlc2VudGFibGUgaW5cbiAgICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAgIGxldCBuZXh0ID0gbmV4dCBwb29sICFjdXJyZW50IGluXG4gICAgICAgICgqIFRoZSBba2V5XSBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBmb3IgW21heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF0gYmVjYXVzZVxuICAgICAgICAgICBtYXggdGltZSBwZXIgaW50ZXJ2YWwgaXMgbm90IHRoZSBzYW1lIGFzIG1heCB0aW1lIGdsb2JhbGx5LlxuXG4gICAgICAgICAgIFRoaXMgaXMgbm90IHNvIGZvciBbbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsXSwgc28gdGhpcyBjYW4gcG90ZW50aWFsbHlcbiAgICAgICAgICAgYmUgc2ltcGxpZmllZC5cblxuICAgICAgICAgICBQcm9iYWJseSBhIGJldHRlciBjaGFuZ2Ugd291bGQgYmUgdG8gc2ltcGx5IHRyYW5zZmVyIHRoZSBldmVudHMgdG8gdGhlXG4gICAgICAgICAgIFwiZmlyZWRcIiBjb2xsZWN0aW9uIChhbmQgcmVuYW1lIGl0IHRvIFwiYWJvdXQgdG8gZmlyZVwiKSwgd2hpY2ggaXMgc29ydGVkIGJ5IHRpbWUsXG4gICAgICAgICAgIHNvIGdldHRpbmcgdGhlIGZpcnN0IGVsZW1lbnQgZnJvbSB0aGF0IGNvbGxlY3Rpb24gaXMgZWZmaWNpZW50LlxuICAgICAgICAqKVxuICAgICAgICBpZiBLZXkuZXF1YWwgKGtleSBwb29sICFjdXJyZW50KSB3aXRoX2tleVxuICAgICAgICB0aGVuIG1pbl9hbGFybV90aW1lIDo9IFRpbWVfbnMubWluIChhdCBwb29sICFjdXJyZW50KSAhbWluX2FsYXJtX3RpbWU7XG4gICAgICAgIGlmIHBoeXNfZXF1YWwgbmV4dCBmaXJzdCB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlIGVsc2UgY3VycmVudCA6PSBuZXh0XG4gICAgICBkb25lO1xuICAgICAgIW1pbl9hbGFybV90aW1lXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIExldmVsID0gc3RydWN0XG4gICAgKCoqIEZvciBnaXZlbiBsZXZlbCwgb25lIGNhbiBicmVhayB0aGUgYml0cyBpbnRvIGEga2V5IGludG8gdGhyZWUgcmVnaW9uczpcblxuICAgICAgICB7dlxuICAgICAgICAgfCBoaWdoZXIgbGV2ZWxzIHwgdGhpcyBsZXZlbCB8IGxvd2VyIGxldmVscyB8XG4gICAgICAgIHZ9XG5cbiAgICAgICAgXCJMb3dlciBsZXZlbHNcIiBpcyBbYml0c19wZXJfc2xvdF0gYml0cyB3aWRlLiAgXCJUaGlzIGxldmVsXCIgaXMgW2JpdHNdIHdpZGUuICopXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgKCogVGhlIFtpbmRleF0gaW4gdGhlIHRpbWluZyB3aGVlbCdzIGFycmF5IG9mIGxldmVscyB3aGVyZSB0aGlzIGxldmVsIGlzLiAqKVxuICAgICAgICBpbmRleCA6IGludFxuICAgICAgOyAoKiBIb3cgbWFueSBbYml0c10gdGhpcyBsZXZlbCBpcyByZXNwb25zaWJsZSBmb3IuICopXG4gICAgICAgIGJpdHMgOiBOdW1fa2V5X2JpdHMudFxuICAgICAgOyAoKiBbc2xvdHNfbWFzayA9IFNsb3RzX21hc2suY3JlYXRlIH5sZXZlbF9iaXRzOnQuYml0c10uICopXG4gICAgICAgIHNsb3RzX21hc2sgOiBTbG90c19tYXNrLnRcbiAgICAgIDsgKCogW2JpdHNfcGVyX3Nsb3RdIGlzIGhvdyBtYW55IGJpdHMgZWFjaCBzbG90IGRpc3Rpbmd1aXNoZXMsIGFuZCBpcyB0aGUgc3VtIG9mIG9mXG4gICAgICAgICAgIHRoZSBbYml0c10gb2YgYWxsIHRoZSBsb3dlciBsZXZlbHMuICopXG4gICAgICAgIGJpdHNfcGVyX3Nsb3QgOiBOdW1fa2V5X2JpdHMudFxuICAgICAgOyBrZXlzX3Blcl9zbG90IDogS2V5LlNwYW4udFxuICAgICAgOyBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrIDogTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzay50XG4gICAgICA7ICgqIFtkaWZmX21heF9taW5fYWxsb3dlZF9rZXkgPSBrZXlzX3Blcl9zbG90ICogQXJyYXkubGVuZ3RoIHNsb3RzIC0gMV0gKilcbiAgICAgICAgZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5IDogS2V5LlNwYW4udFxuICAgICAgOyAoKiBbbGVuZ3RoXSBpcyB0aGUgbnVtYmVyIG9mIGVsdHMgY3VycmVudGx5IGluIHRoaXMgbGV2ZWwuICopXG4gICAgICAgIG11dGFibGUgbGVuZ3RoIDogaW50XG4gICAgICA7ICgqIEFsbCBlbGVtZW50cyBhdCB0aGlzIGxldmVsIGhhdmUgdGhlaXIgW2tleV0gc2F0aXNmeSBbbWluX2FsbG93ZWRfa2V5IDw9IGtleSA8PVxuICAgICAgICAgICBtYXhfYWxsb3dlZF9rZXldLiAgQWxzbywgW21pbl9hbGxvd2VkX2tleV0gaXMgYSBtdWx0aXBsZSBvZiBba2V5c19wZXJfc2xvdF0uICopXG4gICAgICAgIG11dGFibGUgbWluX2FsbG93ZWRfa2V5IDogS2V5LnRcbiAgICAgIDsgbXV0YWJsZSBtYXhfYWxsb3dlZF9rZXkgOiBLZXkudFxuICAgICAgOyAoKiBbc2xvdHNdIGhvbGRzIHRoZSAocG9zc2libHkgbnVsbCkgcG9pbnRlcnMgdG8gdGhlIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdHNcbiAgICAgICAgICAgb2YgZWx0cy4gIFtBcnJheS5sZW5ndGggc2xvdHMgPSAxIGxzbCBiaXRzXS4gKilcbiAgICAgICAgc2xvdHMgOiAoJ2EgSW50ZXJuYWxfZWx0LnQgYXJyYXlbQHNleHAub3BhcXVlXSlcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG4gICAgbGV0IHNsb3QgdCB+a2V5ID0gS2V5LnNsb3Qga2V5IH5iaXRzX3Blcl9zbG90OnQuYml0c19wZXJfc2xvdCB+c2xvdHNfbWFzazp0LnNsb3RzX21hc2tcbiAgICBsZXQgbmV4dF9zbG90IHQgc2xvdCA9IFNsb3RzX21hc2submV4dF9zbG90IHQuc2xvdHNfbWFzayBzbG90XG5cbiAgICBsZXQgbWluX2tleV9pbl9zYW1lX3Nsb3QgdCB+a2V5ID1cbiAgICAgIEtleS5taW5fa2V5X2luX3NhbWVfc2xvdCBrZXkgdC5taW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gICAgOztcblxuICAgIGxldCBjb21wdXRlX21pbl9hbGxvd2VkX2tleSB0IH5wcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSA9XG4gICAgICAoKiBUaGlzIGNvbXB1dGF0aW9uIGVuc3VyZXMgdGhhdCBbdF0ncyBbbWluX2FsbG93ZWRfa2V5XSBpcyBhcyBsYXJnZSBhcyBwb3NzaWJsZVxuICAgICAgICAgc3ViamVjdCB0byB0aGUgY29uc3RyYWludCB0aGF0IHRoZXJlIGlzIG5vIGludGVyLWxldmVsIGdhcC4gKilcbiAgICAgIGlmIEtleS5lcXVhbCBwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSBLZXkubWF4X3ZhbHVlXG4gICAgICB0aGVuIEtleS5tYXhfdmFsdWVcbiAgICAgIGVsc2UgbWluX2tleV9pbl9zYW1lX3Nsb3QgdCB+a2V5OihLZXkuc3VjYyBwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSlcbiAgICA7O1xuICBlbmRcblxuICB0eXBlICdhIHQgPVxuICAgIHsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgICA7IG11dGFibGUgcG9vbCA6ICdhIEludGVybmFsX2VsdC5Qb29sLnRcbiAgICA7ICgqIFttaW5fZWx0XSBpcyBlaXRoZXIgbnVsbCBvciBhbiBlbGVtZW50IHdob3NlIGtleSBpcyBbZWx0X2tleV9sb3dlcl9ib3VuZF0uICopXG4gICAgICBtdXRhYmxlIG1pbl9lbHQgOiAnYSBJbnRlcm5hbF9lbHQudFxuICAgIDsgKCogQWxsIGVsZW1lbnRzIGluIHRoZSBwcmlvcml0eSBxdWV1ZSBoYXZlIHRoZWlyIGtleSBbPj0gZWx0X2tleV9sb3dlcl9ib3VuZF0uICopXG4gICAgICBtdXRhYmxlIGVsdF9rZXlfbG93ZXJfYm91bmQgOiBLZXkudFxuICAgIDsgbGV2ZWxzIDogJ2EgTGV2ZWwudCBhcnJheVxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxuICB0eXBlICdhIHByaW9yaXR5X3F1ZXVlID0gJ2EgdFxuXG4gIG1vZHVsZSBFbHQgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBFeHRlcm5hbF9lbHQudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgbGV0IG51bGwgPSBFeHRlcm5hbF9lbHQubnVsbFxuICAgIGxldCBhdCBwIHQgPSBJbnRlcm5hbF9lbHQuYXQgcC5wb29sIChJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHAucG9vbCB0KVxuICAgIGxldCBrZXkgcCB0ID0gSW50ZXJuYWxfZWx0LmtleSBwLnBvb2wgKEludGVybmFsX2VsdC5vZl9leHRlcm5hbF9leG4gcC5wb29sIHQpXG4gICAgbGV0IHZhbHVlIHAgdCA9IEludGVybmFsX2VsdC52YWx1ZSBwLnBvb2wgKEludGVybmFsX2VsdC5vZl9leHRlcm5hbF9leG4gcC5wb29sIHQpXG4gIGVuZFxuXG4gIGxldCBzZXhwX29mX3RfaW50ZXJuYWwgPSBzZXhwX29mX3RcbiAgbGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcbiAgbGV0IG51bV9sZXZlbHMgdCA9IEFycmF5Lmxlbmd0aCB0LmxldmVsc1xuICBsZXQgbWluX2FsbG93ZWRfa2V5IHQgPSBMZXZlbC5taW5fYWxsb3dlZF9rZXkgdC5sZXZlbHMuKDApXG4gIGxldCBtYXhfYWxsb3dlZF9rZXkgdCA9IExldmVsLm1heF9hbGxvd2VkX2tleSB0LmxldmVscy4obnVtX2xldmVscyB0IC0gMSlcblxuICBsZXQgaW50ZXJuYWxfaXRlciB0IH5mID1cbiAgICBpZiB0Lmxlbmd0aCA+IDBcbiAgICB0aGVuIChcbiAgICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgICBsZXQgbGV2ZWxzID0gdC5sZXZlbHMgaW5cbiAgICAgIGZvciBsZXZlbF9pbmRleCA9IDAgdG8gQXJyYXkubGVuZ3RoIGxldmVscyAtIDEgZG9cbiAgICAgICAgbGV0IGxldmVsID0gbGV2ZWxzLihsZXZlbF9pbmRleCkgaW5cbiAgICAgICAgaWYgbGV2ZWwubGVuZ3RoID4gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgICAgICAgIGZvciBzbG90X2luZGV4ID0gMCB0byBBcnJheS5sZW5ndGggc2xvdHMgLSAxIGRvXG4gICAgICAgICAgICBsZXQgZWx0ID0gc2xvdHMuKHNsb3RfaW5kZXgpIGluXG4gICAgICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIGVsdCkgdGhlbiBJbnRlcm5hbF9lbHQuaXRlciBwb29sIGVsdCB+ZlxuICAgICAgICAgIGRvbmUpXG4gICAgICBkb25lKVxuICA7O1xuXG4gIGxldCBpdGVyIHQgfmYgPSBpbnRlcm5hbF9pdGVyIHQgfmY6KGYgOiBfIEVsdC50IC0+IHVuaXQgOj4gXyBJbnRlcm5hbF9lbHQudCAtPiB1bml0KVxuXG4gIG1vZHVsZSBQcmV0dHkgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgRWx0ID0gc3RydWN0XG4gICAgICB0eXBlICdhIHQgPVxuICAgICAgICB7IGtleSA6IEtleS50XG4gICAgICAgIDsgdmFsdWUgOiAnYVxuICAgICAgICB9XG4gICAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIGVuZFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgbWluX2FsbG93ZWRfa2V5IDogS2V5LnRcbiAgICAgIDsgbWF4X2FsbG93ZWRfa2V5IDogS2V5LnRcbiAgICAgIDsgZWx0cyA6ICdhIEVsdC50IGxpc3RcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICBsZXQgcHJldHR5IHQgPVxuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgeyBQcmV0dHkubWluX2FsbG93ZWRfa2V5ID0gbWluX2FsbG93ZWRfa2V5IHRcbiAgICA7IG1heF9hbGxvd2VkX2tleSA9IG1heF9hbGxvd2VkX2tleSB0XG4gICAgOyBlbHRzID1cbiAgICAgICAgKGxldCByID0gcmVmIFtdIGluXG4gICAgICAgICBpbnRlcm5hbF9pdGVyIHQgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgICAgclxuICAgICAgICAgICAgIDo9IHsgUHJldHR5LkVsdC5rZXkgPSBJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0XG4gICAgICAgICAgICAgICAgOyB2YWx1ZSA9IEludGVybmFsX2VsdC52YWx1ZSBwb29sIGVsdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6OiAhcik7XG4gICAgICAgICBMaXN0LnJldiAhcilcbiAgICB9XG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gICAgbWF0Y2ggIXNleHBfb2ZfdF9zdHlsZSB3aXRoXG4gICAgfCBgSW50ZXJuYWwgLT4gWyVzZXhwICh0IDogYSB0X2ludGVybmFsKV1cbiAgICB8IGBQcmV0dHkgLT4gWyVzZXhwIChwcmV0dHkgdCA6IGEgUHJldHR5LnQpXVxuICA7O1xuXG4gIGxldCBjb21wdXRlX2RpZmZfbWF4X21pbl9hbGxvd2VkX2tleSB+bGV2ZWxfYml0cyB+Yml0c19wZXJfc2xvdCA9XG4gICAgbGV0IGJpdHMgPSBOdW1fa2V5X2JpdHMuKCArICkgbGV2ZWxfYml0cyBiaXRzX3Blcl9zbG90IGluXG4gICAgaWYgTnVtX2tleV9iaXRzLmVxdWFsIGJpdHMgTnVtX2tleV9iaXRzLm1heF92YWx1ZVxuICAgIHRoZW4gS2V5LlNwYW4ubWF4X3ZhbHVlXG4gICAgZWxzZSBLZXkuU3Bhbi5wcmVkIChLZXkubnVtX2tleXMgYml0cylcbiAgOztcblxuICBsZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgOiB1bml0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBsZXZlbF9pbnZhcmlhbnQgbGV2ZWwgPVxuICAgICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIGxldmVsIFslc2V4cF9vZjogXyBMZXZlbC50XSAoZnVuICgpIC0+XG4gICAgICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIGxldmVsIGYgaW5cbiAgICAgICAgTGV2ZWwuRmllbGRzLml0ZXJcbiAgICAgICAgICB+aW5kZXg6KGNoZWNrIChmdW4gaW5kZXggLT4gYXNzZXJ0IChpbmRleCA+PSAwKSkpXG4gICAgICAgICAgfmJpdHM6KGNoZWNrIChmdW4gYml0cyAtPiBhc3NlcnQgKE51bV9rZXlfYml0cy4oID4gKSBiaXRzIE51bV9rZXlfYml0cy56ZXJvKSkpXG4gICAgICAgICAgfnNsb3RzX21hc2s6XG4gICAgICAgICAgICAoY2hlY2tcbiAgICAgICAgICAgICAgIChbJXRlc3RfcmVzdWx0OiBTbG90c19tYXNrLnRdXG4gICAgICAgICAgICAgICAgICB+ZXhwZWN0OihTbG90c19tYXNrLmNyZWF0ZSB+bGV2ZWxfYml0czpsZXZlbC5iaXRzKSkpXG4gICAgICAgICAgfmJpdHNfcGVyX3Nsb3Q6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBiaXRzX3Blcl9zbG90IC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKE51bV9rZXlfYml0cy4oID49ICkgYml0c19wZXJfc2xvdCBOdW1fa2V5X2JpdHMuemVybykpKVxuICAgICAgICAgIH5rZXlzX3Blcl9zbG90OlxuICAgICAgICAgICAgKGNoZWNrIChmdW4ga2V5c19wZXJfc2xvdCAtPlxuICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogS2V5LlNwYW4udF1cbiAgICAgICAgICAgICAgICAga2V5c19wZXJfc2xvdFxuICAgICAgICAgICAgICAgICB+ZXhwZWN0OihLZXkubnVtX2tleXMgbGV2ZWwuYml0c19wZXJfc2xvdCkpKVxuICAgICAgICAgIH5taW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrOlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayAtPlxuICAgICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgICAgTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzay5lcXVhbFxuICAgICAgICAgICAgICAgICAgIG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgICAgICAgICAgICAgICAgICAoTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzay5jcmVhdGUgfmJpdHNfcGVyX3Nsb3Q6bGV2ZWwuYml0c19wZXJfc2xvdCkpKSlcbiAgICAgICAgICB+ZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5OlxuICAgICAgICAgICAgKGNoZWNrXG4gICAgICAgICAgICAgICAoWyV0ZXN0X3Jlc3VsdDogS2V5LlNwYW4udF1cbiAgICAgICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAgICAgIChjb21wdXRlX2RpZmZfbWF4X21pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICAgICAgICB+bGV2ZWxfYml0czpsZXZlbC5iaXRzXG4gICAgICAgICAgICAgICAgICAgICAgIH5iaXRzX3Blcl9zbG90OmxldmVsLmJpdHNfcGVyX3Nsb3QpKSlcbiAgICAgICAgICB+bGVuZ3RoOlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gbGVuZ3RoIC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgICBsZW5ndGhcbiAgICAgICAgICAgICAgICAgPSBBcnJheS5mb2xkIGxldmVsLnNsb3RzIH5pbml0OjAgfmY6KGZ1biBuIGVsdCAtPlxuICAgICAgICAgICAgICAgICAgICAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gICAgICAgICAgICAgICAgICAgICB0aGVuIG5cbiAgICAgICAgICAgICAgICAgICAgIGVsc2UgbiArIEludGVybmFsX2VsdC5sZW5ndGggcG9vbCBlbHQpKSkpXG4gICAgICAgICAgfm1pbl9hbGxvd2VkX2tleTpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIG1pbl9hbGxvd2VkX2tleSAtPlxuICAgICAgICAgICAgICAgYXNzZXJ0IChLZXkuKCA+PSApIG1pbl9hbGxvd2VkX2tleSBLZXkuemVybyk7XG4gICAgICAgICAgICAgICBpZiBLZXkuKCA8ICkgbWluX2FsbG93ZWRfa2V5IEtleS5tYXhfdmFsdWVcbiAgICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogS2V5LlNwYW4udF1cbiAgICAgICAgICAgICAgICAgICAoS2V5LnJlbSBtaW5fYWxsb3dlZF9rZXkgbGV2ZWwua2V5c19wZXJfc2xvdClcbiAgICAgICAgICAgICAgICAgICB+ZXhwZWN0OktleS5TcGFuLnplcm8pKVxuICAgICAgICAgIH5tYXhfYWxsb3dlZF9rZXk6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBtYXhfYWxsb3dlZF9rZXkgLT5cbiAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEtleS50XVxuICAgICAgICAgICAgICAgICBtYXhfYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgfmV4cGVjdDpcbiAgICAgICAgICAgICAgICAgICAoS2V5LmFkZF9jbGFtcF90b19tYXhcbiAgICAgICAgICAgICAgICAgICAgICBsZXZlbC5taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgICAgICBsZXZlbC5kaWZmX21heF9taW5fYWxsb3dlZF9rZXkpKSlcbiAgICAgICAgICB+c2xvdHM6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBzbG90cyAtPlxuICAgICAgICAgICAgICAgQXJyYXkuaXRlciBzbG90cyB+ZjooZnVuIGVsdCAtPlxuICAgICAgICAgICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIGVsdClcbiAgICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgICAgSW50ZXJuYWxfZWx0LmludmFyaWFudCBwb29sIGludmFyaWFudF9hIGVsdDtcbiAgICAgICAgICAgICAgICAgICBJbnRlcm5hbF9lbHQuaXRlciBwb29sIGVsdCB+ZjooZnVuIGVsdCAtPlxuICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChLZXkuKCA+PSApIChJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KSBsZXZlbC5taW5fYWxsb3dlZF9rZXkpO1xuICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChLZXkuKCA8PSApIChJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KSBsZXZlbC5tYXhfYWxsb3dlZF9rZXkpO1xuICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChLZXkuKCA+PSApIChJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KSB0LmVsdF9rZXlfbG93ZXJfYm91bmQpO1xuICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChJbnRlcm5hbF9lbHQubGV2ZWxfaW5kZXggcG9vbCBlbHQgPSBsZXZlbC5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICBpbnZhcmlhbnRfYSAoSW50ZXJuYWxfZWx0LnZhbHVlIHBvb2wgZWx0KSkpKSkpKVxuICAgIGluXG4gICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRfaW50ZXJuYWxdIChmdW4gKCkgLT5cbiAgICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgICAgYXNzZXJ0IChLZXkuKCA+PSApIChtaW5fYWxsb3dlZF9rZXkgdCkgS2V5Lnplcm8pO1xuICAgICAgYXNzZXJ0IChLZXkuKCA+PSApIChtYXhfYWxsb3dlZF9rZXkgdCkgKG1pbl9hbGxvd2VkX2tleSB0KSk7XG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+bGVuZ3RoOihjaGVjayAoZnVuIGxlbmd0aCAtPiBhc3NlcnQgKGxlbmd0aCA+PSAwKSkpXG4gICAgICAgIH5wb29sOihjaGVjayAoSW50ZXJuYWxfZWx0LlBvb2wuaW52YXJpYW50IGlnbm9yZSkpXG4gICAgICAgIH5taW5fZWx0OlxuICAgICAgICAgIChjaGVjayAoZnVuIGVsdF8gLT5cbiAgICAgICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIGVsdF8pXG4gICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICBhc3NlcnQgKEludGVybmFsX2VsdC5pc192YWxpZCB0LnBvb2wgZWx0Xyk7XG4gICAgICAgICAgICAgICBhc3NlcnQgKEtleS5lcXVhbCB0LmVsdF9rZXlfbG93ZXJfYm91bmQgKEludGVybmFsX2VsdC5rZXkgdC5wb29sIGVsdF8pKSkpKVxuICAgICAgICB+ZWx0X2tleV9sb3dlcl9ib3VuZDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBlbHRfa2V5X2xvd2VyX2JvdW5kIC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChLZXkuKCA+PSApIGVsdF9rZXlfbG93ZXJfYm91bmQgKG1pbl9hbGxvd2VkX2tleSB0KSk7XG4gICAgICAgICAgICAgYXNzZXJ0IChLZXkuKCA8PSApIGVsdF9rZXlfbG93ZXJfYm91bmQgKG1heF9hbGxvd2VkX2tleSB0KSk7XG4gICAgICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCB0Lm1pbl9lbHQpXG4gICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgYXNzZXJ0IChLZXkuZXF1YWwgZWx0X2tleV9sb3dlcl9ib3VuZCAoSW50ZXJuYWxfZWx0LmtleSB0LnBvb2wgdC5taW5fZWx0KSkpKVxuICAgICAgICB+bGV2ZWxzOlxuICAgICAgICAgIChjaGVjayAoZnVuIGxldmVscyAtPlxuICAgICAgICAgICAgIGFzc2VydCAobnVtX2xldmVscyB0ID4gMCk7XG4gICAgICAgICAgICAgQXJyYXkuaXRlcmkgbGV2ZWxzIH5mOihmdW4gbGV2ZWxfaW5kZXggbGV2ZWwgLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAobGV2ZWxfaW5kZXggPSBMZXZlbC5pbmRleCBsZXZlbCk7XG4gICAgICAgICAgICAgICBsZXZlbF9pbnZhcmlhbnQgbGV2ZWw7XG4gICAgICAgICAgICAgICBpZiBsZXZlbF9pbmRleCA+IDBcbiAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICBsZXQgcHJldl9sZXZlbCA9IGxldmVscy4obGV2ZWxfaW5kZXggLSAxKSBpblxuICAgICAgICAgICAgICAgICBsZXQgbW9kdWxlIEwgPSBMZXZlbCBpblxuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBLZXkuU3Bhbi50XVxuICAgICAgICAgICAgICAgICAgIChMLmtleXNfcGVyX3Nsb3QgbGV2ZWwpXG4gICAgICAgICAgICAgICAgICAgfmV4cGVjdDooS2V5LlNwYW4uc3VjYyBwcmV2X2xldmVsLmRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSk7XG4gICAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEtleS50XVxuICAgICAgICAgICAgICAgICAgIGxldmVsLm1pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAgICAgICAoTGV2ZWwuY29tcHV0ZV9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXk6cHJldl9sZXZlbC5tYXhfYWxsb3dlZF9rZXkpKSkpKSlcbiAgOztcblxuICAoKiogW21pbl9lbHRfXSByZXR1cm5zIFtudWxsXSBpZiBpdCBjYW4ndCBmaW5kIHRoZSBkZXNpcmVkIGVsZW1lbnQuICBXZSB3cmFwIGl0IHVwXG4gICAgICBhZnRlcndhcmRzIHRvIHJldHVybiBhbiBbb3B0aW9uXS4gKilcbiAgbGV0IG1pbl9lbHRfIHQgPVxuICAgIGlmIGlzX2VtcHR5IHRcbiAgICB0aGVuIEludGVybmFsX2VsdC5udWxsICgpXG4gICAgZWxzZSBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIHQubWluX2VsdClcbiAgICB0aGVuIHQubWluX2VsdFxuICAgIGVsc2UgKFxuICAgICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICAgIGxldCBtaW5fZWx0X2FscmVhZHlfZm91bmQgPSByZWYgKEludGVybmFsX2VsdC5udWxsICgpKSBpblxuICAgICAgbGV0IG1pbl9rZXlfYWxyZWFkeV9mb3VuZCA9IHJlZiBLZXkubWF4X3ZhbHVlIGluXG4gICAgICBsZXQgbGV2ZWxfaW5kZXggPSByZWYgMCBpblxuICAgICAgbGV0IG51bV9sZXZlbHMgPSBudW1fbGV2ZWxzIHQgaW5cbiAgICAgIHdoaWxlICFsZXZlbF9pbmRleCA8IG51bV9sZXZlbHMgZG9cbiAgICAgICAgbGV0IGxldmVsID0gdC5sZXZlbHMuKCFsZXZlbF9pbmRleCkgaW5cbiAgICAgICAgaWYgS2V5LiggPiApIChMZXZlbC5taW5fYWxsb3dlZF9rZXkgbGV2ZWwpICFtaW5fa2V5X2FscmVhZHlfZm91bmRcbiAgICAgICAgdGhlblxuICAgICAgICAgICgqIFdlIGRvbid0IG5lZWQgdG8gY29uc2lkZXIgYW55IG1vcmUgbGV2ZWxzLiAgUXVpdCB0aGUgbG9vcC4gKilcbiAgICAgICAgICBsZXZlbF9pbmRleCA6PSBudW1fbGV2ZWxzXG4gICAgICAgIGVsc2UgaWYgbGV2ZWwubGVuZ3RoID0gMFxuICAgICAgICB0aGVuIGluY3IgbGV2ZWxfaW5kZXhcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogTG9vayBpbiBbbGV2ZWxdLiAqKVxuICAgICAgICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgICAgICAgbGV0IHNsb3RfbWluX2tleSA9XG4gICAgICAgICAgICByZWZcbiAgICAgICAgICAgICAgKExldmVsLm1pbl9rZXlfaW5fc2FtZV9zbG90XG4gICAgICAgICAgICAgICAgIGxldmVsXG4gICAgICAgICAgICAgICAgIH5rZXk6KEtleS5tYXggbGV2ZWwubWluX2FsbG93ZWRfa2V5IHQuZWx0X2tleV9sb3dlcl9ib3VuZCkpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgc2xvdCA9IHJlZiAoTGV2ZWwuc2xvdCBsZXZlbCB+a2V5OiFzbG90X21pbl9rZXkpIGluXG4gICAgICAgICAgKCogRmluZCB0aGUgZmlyc3Qgbm9uZW1wdHkgc2xvdCB3aXRoIGEgc21hbGwgZW5vdWdoIFtzbG90X21pbl9rZXldLiAqKVxuICAgICAgICAgIHdoaWxlXG4gICAgICAgICAgICBJbnRlcm5hbF9lbHQuaXNfbnVsbCBzbG90cy4oIXNsb3QpXG4gICAgICAgICAgICAmJiBLZXkuKCA8ICkgIXNsb3RfbWluX2tleSAhbWluX2tleV9hbHJlYWR5X2ZvdW5kXG4gICAgICAgICAgZG9cbiAgICAgICAgICAgIHNsb3QgOj0gTGV2ZWwubmV4dF9zbG90IGxldmVsICFzbG90O1xuICAgICAgICAgICAgc2xvdF9taW5fa2V5IDo9IEtleS5hZGQgIXNsb3RfbWluX2tleSBsZXZlbC5rZXlzX3Blcl9zbG90XG4gICAgICAgICAgZG9uZTtcbiAgICAgICAgICBsZXQgZmlyc3QgPSBzbG90cy4oIXNsb3QpIGluXG4gICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBmaXJzdClcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICgqIFZpc2l0IGFsbCBvZiB0aGUgZWx0cyBpbiB0aGlzIHNsb3QgYW5kIGZpbmQgb25lIHdpdGggbWluaW11bSBrZXkuICopXG4gICAgICAgICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICAgICAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICAgICAgICBsZXQgY3VycmVudF9rZXkgPSBJbnRlcm5hbF9lbHQua2V5IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgICAgICAgaWYgS2V5LiggPD0gKSBjdXJyZW50X2tleSAhbWluX2tleV9hbHJlYWR5X2ZvdW5kXG4gICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgIG1pbl9lbHRfYWxyZWFkeV9mb3VuZCA6PSAhY3VycmVudDtcbiAgICAgICAgICAgICAgICBtaW5fa2V5X2FscmVhZHlfZm91bmQgOj0gY3VycmVudF9rZXkpO1xuICAgICAgICAgICAgICBsZXQgbmV4dCA9IEludGVybmFsX2VsdC5uZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgICAgICAgKCogSWYgWyFsZXZlbF9pbmRleCA9IDBdIHRoZW4gYWxsIGVsdHMgaW4gdGhpcyBzbG90IGhhdmUgdGhlIHNhbWUgW2tleV0sXG4gICAgICAgICAgICAgICAgIGkuZS4gWyFzbG90X21pbl9rZXldLiAgU28sIHdlIGRvbid0IGhhdmUgdG8gY2hlY2sgYW55IGVsZW1lbnRzIGFmdGVyXG4gICAgICAgICAgICAgICAgIFtmaXJzdF0uICBUaGlzIGlzIGEgdXNlZnVsIHNob3J0IGN1dCBpbiB0aGUgY29tbW9uIGNhc2UgdGhhdCB0aGVyZSBhcmVcbiAgICAgICAgICAgICAgICAgbXVsdGlwbGUgZWxlbWVudHMgaW4gdGhlIHNhbWUgbWluIHNsb3QgaW4gbGV2ZWwgMC4gKilcbiAgICAgICAgICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHx8ICFsZXZlbF9pbmRleCA9IDBcbiAgICAgICAgICAgICAgdGhlbiBjb250aW51ZSA6PSBmYWxzZVxuICAgICAgICAgICAgICBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgICAgICAgZG9uZSk7XG4gICAgICAgICAgKCogRmluaXNoZWQgbG9va2luZyBpbiBbbGV2ZWxdLiAgTW92ZSB1cCB0byB0aGUgbmV4dCBsZXZlbC4gKilcbiAgICAgICAgICBpbmNyIGxldmVsX2luZGV4KVxuICAgICAgZG9uZTtcbiAgICAgIHQubWluX2VsdCA8LSAhbWluX2VsdF9hbHJlYWR5X2ZvdW5kO1xuICAgICAgdC5lbHRfa2V5X2xvd2VyX2JvdW5kIDwtICFtaW5fa2V5X2FscmVhZHlfZm91bmQ7XG4gICAgICB0Lm1pbl9lbHQpXG4gIDs7XG5cbiAgbGV0W0Bjb2xkXSByYWlzZV9hZGRfZWx0X2tleV9vdXRfb2ZfYm91bmRzIHQga2V5ID1cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJQcmlvcml0eV9xdWV1ZS5hZGRfZWx0IGtleSBvdXQgb2YgYm91bmRzXCJcbiAgICAgICAgICAoa2V5IDogS2V5LnQpXG4gICAgICAgICAgKG1pbl9hbGxvd2VkX2tleSB0IDogS2V5LnQpXG4gICAgICAgICAgKG1heF9hbGxvd2VkX2tleSB0IDogS2V5LnQpXG4gICAgICAgICAgfnByaW9yaXR5X3F1ZXVlOih0IDogXyB0KV1cbiAgOztcblxuICBsZXRbQGNvbGRdIHJhaXNlX2FkZF9lbHRfa2V5X291dF9vZl9sZXZlbF9ib3VuZHMga2V5IGxldmVsID1cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJQcmlvcml0eV9xdWV1ZS5hZGRfZWx0IGtleSBvdXQgb2YgbGV2ZWwgYm91bmRzXCIgKGtleSA6IEtleS50KSAobGV2ZWwgOiBfIExldmVsLnQpXVxuICA7O1xuXG4gIGxldCBhZGRfZWx0IHQgZWx0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBrZXkgPSBJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0IGluXG4gICAgaWYgbm90IChLZXkuKCA+PSApIGtleSAobWluX2FsbG93ZWRfa2V5IHQpICYmIEtleS4oIDw9ICkga2V5IChtYXhfYWxsb3dlZF9rZXkgdCkpXG4gICAgdGhlbiByYWlzZV9hZGRfZWx0X2tleV9vdXRfb2ZfYm91bmRzIHQga2V5O1xuICAgICgqIEZpbmQgdGhlIGxvd2VzdCBsZXZlbCB0aGF0IHdpbGwgaG9sZCBbZWx0XS4gKilcbiAgICBsZXQgbGV2ZWxfaW5kZXggPVxuICAgICAgbGV0IGxldmVsX2luZGV4ID0gcmVmIDAgaW5cbiAgICAgIHdoaWxlIEtleS4oID4gKSBrZXkgKExldmVsLm1heF9hbGxvd2VkX2tleSB0LmxldmVscy4oIWxldmVsX2luZGV4KSkgZG9cbiAgICAgICAgaW5jciBsZXZlbF9pbmRleFxuICAgICAgZG9uZTtcbiAgICAgICFsZXZlbF9pbmRleFxuICAgIGluXG4gICAgbGV0IGxldmVsID0gdC5sZXZlbHMuKGxldmVsX2luZGV4KSBpblxuICAgIGlmIG5vdCAoS2V5LiggPj0gKSBrZXkgbGV2ZWwubWluX2FsbG93ZWRfa2V5ICYmIEtleS4oIDw9ICkga2V5IGxldmVsLm1heF9hbGxvd2VkX2tleSlcbiAgICB0aGVuIHJhaXNlX2FkZF9lbHRfa2V5X291dF9vZl9sZXZlbF9ib3VuZHMga2V5IGxldmVsO1xuICAgIGxldmVsLmxlbmd0aCA8LSBsZXZlbC5sZW5ndGggKyAxO1xuICAgIEludGVybmFsX2VsdC5zZXRfbGV2ZWxfaW5kZXggcG9vbCBlbHQgbGV2ZWxfaW5kZXg7XG4gICAgbGV0IHNsb3QgPSBMZXZlbC5zbG90IGxldmVsIH5rZXkgaW5cbiAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgIGxldCBmaXJzdCA9IHNsb3RzLihzbG90KSBpblxuICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgZmlyc3QpXG4gICAgdGhlbiBJbnRlcm5hbF9lbHQuaW5zZXJ0X2F0X2VuZCBwb29sIGZpcnN0IH50b19hZGQ6ZWx0XG4gICAgZWxzZSAoXG4gICAgICBzbG90cy4oc2xvdCkgPC0gZWx0O1xuICAgICAgSW50ZXJuYWxfZWx0LmxpbmtfdG9fc2VsZiBwb29sIGVsdClcbiAgOztcblxuICBsZXQgaW50ZXJuYWxfYWRkX2VsdCB0IGVsdCA9XG4gICAgbGV0IGtleSA9IEludGVybmFsX2VsdC5rZXkgdC5wb29sIGVsdCBpblxuICAgIGlmIEtleS4oIDwgKSBrZXkgdC5lbHRfa2V5X2xvd2VyX2JvdW5kXG4gICAgdGhlbiAoXG4gICAgICB0Lm1pbl9lbHQgPC0gZWx0O1xuICAgICAgdC5lbHRfa2V5X2xvd2VyX2JvdW5kIDwtIGtleSk7XG4gICAgYWRkX2VsdCB0IGVsdDtcbiAgICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDFcbiAgOztcblxuICBsZXRbQGNvbGRdIHJhaXNlX2dvdF9pbnZhbGlkX2tleSB0IGtleSA9XG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiVGltaW5nX3doZWVsLmFkZF9hdF9pbnRlcnZhbF9udW0gZ290IGludmFsaWQgaW50ZXJ2YWwgbnVtXCJcbiAgICAgICAgICB+aW50ZXJ2YWxfbnVtOihrZXkgOiBLZXkudClcbiAgICAgICAgICB+bWluX2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtOihtaW5fYWxsb3dlZF9rZXkgdCA6IEtleS50KVxuICAgICAgICAgIH5tYXhfYWxsb3dlZF9hbGFybV9pbnRlcnZhbF9udW06KG1heF9hbGxvd2VkX2tleSB0IDogS2V5LnQpXVxuICA7O1xuXG4gIGxldCBlbnN1cmVfdmFsaWRfa2V5IHQgfmtleSA9XG4gICAgaWYgS2V5LiggPCApIGtleSAobWluX2FsbG93ZWRfa2V5IHQpIHx8IEtleS4oID4gKSBrZXkgKG1heF9hbGxvd2VkX2tleSB0KVxuICAgIHRoZW4gcmFpc2VfZ290X2ludmFsaWRfa2V5IHQga2V5XG4gIDs7XG5cbiAgbGV0IGludGVybmFsX2FkZCB0IH5rZXkgfmF0IHZhbHVlID1cbiAgICBlbnN1cmVfdmFsaWRfa2V5IHQgfmtleTtcbiAgICBpZiBJbnRlcm5hbF9lbHQuUG9vbC5pc19mdWxsIHQucG9vbCB0aGVuIHQucG9vbCA8LSBJbnRlcm5hbF9lbHQuUG9vbC5ncm93IHQucG9vbDtcbiAgICBsZXQgZWx0ID0gSW50ZXJuYWxfZWx0LmNyZWF0ZSB0LnBvb2wgfmtleSB+YXQgfnZhbHVlIH5sZXZlbF9pbmRleDooLTEpIGluXG4gICAgaW50ZXJuYWxfYWRkX2VsdCB0IGVsdDtcbiAgICBlbHRcbiAgOztcblxuICAoKiogW3JlbW92ZV9vcl9yZV9hZGRfZWx0c10gdmlzaXRzIGVhY2ggZWxlbWVudCBpbiB0aGUgY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0XG4gICAgICBbZmlyc3RdLiAgSWYgdGhlIGVsZW1lbnQncyBrZXkgaXMgWz49IHRfbWluX2FsbG93ZWRfa2V5XSwgdGhlbiBpdCBhZGRzIHRoZSBlbGVtZW50XG4gICAgICBiYWNrIGF0IGEgbG93ZXIgbGV2ZWwuICBJZiBub3QsIHRoZW4gaXQgY2FsbHMgW2hhbmRsZV9yZW1vdmVkXSBhbmQgW2ZyZWVdcyB0aGVcbiAgICAgIGVsZW1lbnQuICopXG4gIGxldCByZW1vdmVfb3JfcmVfYWRkX2VsdHMgdCAobGV2ZWwgOiBfIExldmVsLnQpIGZpcnN0IH50X21pbl9hbGxvd2VkX2tleSB+aGFuZGxlX3JlbW92ZWRcbiAgICA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBsZXQgY3VycmVudCA9IHJlZiBmaXJzdCBpblxuICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAoKiBXZSBleHRyYWN0IFtuZXh0XSBmcm9tIFtjdXJyZW50XSBmaXJzdCwgYmVjYXVzZSB3ZSB3aWxsIG1vZGlmeSBvciBbZnJlZV1cbiAgICAgICAgIFtjdXJyZW50XSBiZWZvcmUgY29udGludWluZyB0aGUgbG9vcC4gKilcbiAgICAgIGxldCBuZXh0ID0gSW50ZXJuYWxfZWx0Lm5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgbGV2ZWwubGVuZ3RoIDwtIGxldmVsLmxlbmd0aCAtIDE7XG4gICAgICBpZiBLZXkuKCA+PSApIChJbnRlcm5hbF9lbHQua2V5IHBvb2wgIWN1cnJlbnQpIHRfbWluX2FsbG93ZWRfa2V5XG4gICAgICB0aGVuIGFkZF9lbHQgdCAhY3VycmVudFxuICAgICAgZWxzZSAoXG4gICAgICAgIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMTtcbiAgICAgICAgaGFuZGxlX3JlbW92ZWQgKEludGVybmFsX2VsdC50b19leHRlcm5hbCAhY3VycmVudCk7XG4gICAgICAgIEludGVybmFsX2VsdC5mcmVlIHBvb2wgIWN1cnJlbnQpO1xuICAgICAgaWYgcGh5c19lcXVhbCBuZXh0IGZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHRcbiAgICBkb25lXG4gIDs7XG5cbiAgKCoqIFtpbmNyZWFzZV9sZXZlbF9taW5fYWxsb3dlZF9rZXldIGluY3JlYXNlcyB0aGUgW21pbl9hbGxvd2VkX2tleV0gb2YgW2xldmVsXSB0byBhc1xuICAgICAgbGFyZ2UgYSB2YWx1ZSBhcyBwb3NzaWJsZSwgYnV0IG5vIG1vcmUgdGhhbiBbbWF4X2xldmVsX21pbl9hbGxvd2VkX2tleV0uXG4gICAgICBbdF9taW5fYWxsb3dlZF9rZXldIGlzIHRoZSBtaW5pbXVtIGFsbG93ZWQga2V5IGZvciB0aGUgZW50aXJlIHRpbWluZyB3aGVlbC4gIEFzXG4gICAgICBlbGVtZW50cyBhcmUgZW5jb3VudGVyZWQsIHRoZXkgYXJlIHJlbW92ZWQgZnJvbSB0aGUgdGltaW5nIHdoZWVsIGlmIHRoZWlyIGtleSBpc1xuICAgICAgc21hbGxlciB0aGFuIFt0X21pbl9hbGxvd2VkX2tleV0sIG9yIGFkZGVkIGF0IGEgbG93ZXIgbGV2ZWwgaWYgbm90LiAqKVxuICBsZXQgaW5jcmVhc2VfbGV2ZWxfbWluX2FsbG93ZWRfa2V5XG4gICAgdFxuICAgIChsZXZlbCA6IF8gTGV2ZWwudClcbiAgICB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXlcbiAgICB+dF9taW5fYWxsb3dlZF9rZXlcbiAgICB+aGFuZGxlX3JlbW92ZWRcbiAgICA9XG4gICAgbGV0IGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5ID1cbiAgICAgIExldmVsLmNvbXB1dGVfbWluX2FsbG93ZWRfa2V5IGxldmVsIH5wcmV2X2xldmVsX21heF9hbGxvd2VkX2tleVxuICAgIGluXG4gICAgKCogV2UgcmVxdWlyZSB0aGF0IFttb2QgbGV2ZWwubWluX2FsbG93ZWRfa2V5IGxldmVsLmtleXNfcGVyX3Nsb3QgPSAwXS4gIFNvLFxuICAgICAgIHdlIHN0YXJ0IFtsZXZlbF9taW5fYWxsb3dlZF9rZXldIHdoZXJlIHRoYXQgaXMgdHJ1ZSwgYW5kIHRoZW4gaW5jcmVhc2UgaXQgYnlcbiAgICAgICBba2V5c19wZXJfc2xvdF0gZWFjaCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuICopXG4gICAgbGV0IGxldmVsX21pbl9hbGxvd2VkX2tleSA9XG4gICAgICBMZXZlbC5taW5fa2V5X2luX3NhbWVfc2xvdFxuICAgICAgICBsZXZlbFxuICAgICAgICB+a2V5OlxuICAgICAgICAgIChLZXkubWluXG4gICAgICAgICAgICAgZGVzaXJlZF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAoS2V5Lm1heCBsZXZlbC5taW5fYWxsb3dlZF9rZXkgdC5lbHRfa2V5X2xvd2VyX2JvdW5kKSlcbiAgICBpblxuICAgIGxldCBsZXZlbF9taW5fYWxsb3dlZF9rZXkgPSByZWYgbGV2ZWxfbWluX2FsbG93ZWRfa2V5IGluXG4gICAgbGV0IHNsb3QgPSByZWYgKExldmVsLnNsb3QgbGV2ZWwgfmtleTohbGV2ZWxfbWluX2FsbG93ZWRfa2V5KSBpblxuICAgIGxldCBrZXlzX3Blcl9zbG90ID0gbGV2ZWwua2V5c19wZXJfc2xvdCBpblxuICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgd2hpbGUgS2V5LiggPCApICFsZXZlbF9taW5fYWxsb3dlZF9rZXkgZGVzaXJlZF9taW5fYWxsb3dlZF9rZXkgZG9cbiAgICAgIGlmIGxldmVsLmxlbmd0aCA9IDBcbiAgICAgIHRoZW5cbiAgICAgICAgKCogSWYgbm8gZWxlbWVudHMgcmVtYWluIGF0IHRoaXMgbGV2ZWwsIHdlIGNhbiBqdXN0IHNldCBbbWluX2FsbG93ZWRfa2V5XSB0byB0aGVcbiAgICAgICAgICAgZGVzaXJlZCB2YWx1ZS4gKilcbiAgICAgICAgbGV2ZWxfbWluX2FsbG93ZWRfa2V5IDo9IGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGZpcnN0ID0gc2xvdHMuKCFzbG90KSBpblxuICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIGZpcnN0KVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBzbG90cy4oIXNsb3QpIDwtIEludGVybmFsX2VsdC5udWxsICgpO1xuICAgICAgICAgIHJlbW92ZV9vcl9yZV9hZGRfZWx0cyB0IGxldmVsIGZpcnN0IH50X21pbl9hbGxvd2VkX2tleSB+aGFuZGxlX3JlbW92ZWQpO1xuICAgICAgICBzbG90IDo9IExldmVsLm5leHRfc2xvdCBsZXZlbCAhc2xvdDtcbiAgICAgICAgbGV2ZWxfbWluX2FsbG93ZWRfa2V5IDo9IEtleS5hZGRfY2xhbXBfdG9fbWF4ICFsZXZlbF9taW5fYWxsb3dlZF9rZXkga2V5c19wZXJfc2xvdClcbiAgICBkb25lO1xuICAgIGxldmVsLm1pbl9hbGxvd2VkX2tleSA8LSBkZXNpcmVkX21pbl9hbGxvd2VkX2tleTtcbiAgICBsZXZlbC5tYXhfYWxsb3dlZF9rZXlcbiAgICAgIDwtIEtleS5hZGRfY2xhbXBfdG9fbWF4IGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5IGxldmVsLmRpZmZfbWF4X21pbl9hbGxvd2VkX2tleVxuICA7O1xuXG4gIG1vZHVsZSBJbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlfcmVzdWx0ID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgTWF4X2FsbG93ZWRfa2V5X2RpZF9ub3RfY2hhbmdlXG4gICAgICB8IE1heF9hbGxvd2VkX2tleV9tYXliZV9jaGFuZ2VkXG4gIGVuZFxuXG4gIGxldCBpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXkgdCB+a2V5IH5oYW5kbGVfcmVtb3ZlZCA6IEluY3JlYXNlX21pbl9hbGxvd2VkX2tleV9yZXN1bHQudCA9XG4gICAgaWYgS2V5LiggPD0gKSBrZXkgKG1pbl9hbGxvd2VkX2tleSB0KVxuICAgIHRoZW4gTWF4X2FsbG93ZWRfa2V5X2RpZF9ub3RfY2hhbmdlXG4gICAgZWxzZSAoXG4gICAgICAoKiBXZSBpbmNyZWFzZSB0aGUgW21pbl9hbGxvd2VkX2tleV0gb2YgbGV2ZWxzIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlIGludmFyaWFudFxuICAgICAgICAgdGhhdCB0aGV5IGhhdmUgYXMgbGFyZ2UgYXMgcG9zc2libGUgYSBbbWluX2FsbG93ZWRfa2V5XSwgd2hpbGUgbGVhdmluZyBubyBnYXBzXG4gICAgICAgICBpbiBrZXlzLiAqKVxuICAgICAgbGV0IGxldmVsX2luZGV4ID0gcmVmIDAgaW5cbiAgICAgIGxldCByZXN1bHQgPSByZWYgSW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5X3Jlc3VsdC5NYXhfYWxsb3dlZF9rZXlfbWF5YmVfY2hhbmdlZCBpblxuICAgICAgbGV0IHByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5ID0gcmVmIChLZXkucHJlZCBrZXkpIGluXG4gICAgICBsZXQgbGV2ZWxzID0gdC5sZXZlbHMgaW5cbiAgICAgIGxldCBudW1fbGV2ZWxzID0gbnVtX2xldmVscyB0IGluXG4gICAgICB3aGlsZSAhbGV2ZWxfaW5kZXggPCBudW1fbGV2ZWxzIGRvXG4gICAgICAgIGxldCBsZXZlbCA9IGxldmVscy4oIWxldmVsX2luZGV4KSBpblxuICAgICAgICBsZXQgbWluX2FsbG93ZWRfa2V5X2JlZm9yZSA9IGxldmVsLm1pbl9hbGxvd2VkX2tleSBpblxuICAgICAgICBpbmNyZWFzZV9sZXZlbF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICB0XG4gICAgICAgICAgbGV2ZWxcbiAgICAgICAgICB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXk6IXByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5XG4gICAgICAgICAgfnRfbWluX2FsbG93ZWRfa2V5OmtleVxuICAgICAgICAgIH5oYW5kbGVfcmVtb3ZlZDtcbiAgICAgICAgaWYgS2V5LmVxdWFsIChMZXZlbC5taW5fYWxsb3dlZF9rZXkgbGV2ZWwpIG1pbl9hbGxvd2VkX2tleV9iZWZvcmVcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgKCogVGhpcyBsZXZlbCBkaWQgbm90IHNoaWZ0LiAgRG9uJ3Qgc2hpZnQgYW55IGhpZ2hlciBsZXZlbHMuICopXG4gICAgICAgICAgbGV2ZWxfaW5kZXggOj0gbnVtX2xldmVscztcbiAgICAgICAgICByZXN1bHQgOj0gTWF4X2FsbG93ZWRfa2V5X2RpZF9ub3RfY2hhbmdlKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBMZXZlbCBbbGV2ZWxfaW5kZXhdIHNoaWZ0ZWQuICBDb25zaWRlciBzaGlmdGluZyBoaWdoZXIgbGV2ZWxzLiAqKVxuICAgICAgICAgIGxldmVsX2luZGV4IDo9ICFsZXZlbF9pbmRleCArIDE7XG4gICAgICAgICAgcHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkgOj0gTGV2ZWwubWF4X2FsbG93ZWRfa2V5IGxldmVsKVxuICAgICAgZG9uZTtcbiAgICAgIGlmIEtleS4oID4gKSBrZXkgdC5lbHRfa2V5X2xvd2VyX2JvdW5kXG4gICAgICB0aGVuIChcbiAgICAgICAgKCogV2UgaGF2ZSByZW1vdmVkIFt0Lm1pbl9lbHRdIG9yIGl0IHdhcyBhbHJlYWR5IG51bGwsIHNvIGp1c3Qgc2V0IGl0IHRvXG4gICAgICAgICAgIG51bGwuICopXG4gICAgICAgIHQubWluX2VsdCA8LSBJbnRlcm5hbF9lbHQubnVsbCAoKTtcbiAgICAgICAgdC5lbHRfa2V5X2xvd2VyX2JvdW5kIDwtIG1pbl9hbGxvd2VkX2tleSB0KTtcbiAgICAgICFyZXN1bHQpXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSA/Y2FwYWNpdHkgP2xldmVsX2JpdHMgKCkgPVxuICAgIGxldCBsZXZlbF9iaXRzID1cbiAgICAgIG1hdGNoIGxldmVsX2JpdHMgd2l0aFxuICAgICAgfCBTb21lIGwgLT4gbFxuICAgICAgfCBOb25lIC0+IExldmVsX2JpdHMuZGVmYXVsdFxuICAgIGluXG4gICAgbGV0IF8sIF8sIGxldmVscyA9XG4gICAgICBMaXN0LmZvbGRpXG4gICAgICAgIGxldmVsX2JpdHNcbiAgICAgICAgfmluaXQ6KE51bV9rZXlfYml0cy56ZXJvLCBLZXkuemVybywgW10pXG4gICAgICAgIH5mOlxuICAgICAgICAgIChmdW5cbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAoYml0c19wZXJfc2xvdCwgbWF4X2xldmVsX21pbl9hbGxvd2VkX2tleSwgbGV2ZWxzKVxuICAgICAgICAgICAgKGxldmVsX2JpdHMgOiBOdW1fa2V5X2JpdHMudClcbiAgICAgICAgICAgIC0+XG4gICAgICAgIGxldCBrZXlzX3Blcl9zbG90ID0gS2V5Lm51bV9rZXlzIGJpdHNfcGVyX3Nsb3QgaW5cbiAgICAgICAgbGV0IGRpZmZfbWF4X21pbl9hbGxvd2VkX2tleSA9XG4gICAgICAgICAgY29tcHV0ZV9kaWZmX21heF9taW5fYWxsb3dlZF9rZXkgfmxldmVsX2JpdHMgfmJpdHNfcGVyX3Nsb3RcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgPSBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrLmNyZWF0ZSB+Yml0c19wZXJfc2xvdCBpblxuICAgICAgICBsZXQgbWluX2FsbG93ZWRfa2V5ID1cbiAgICAgICAgICBLZXkubWluX2tleV9pbl9zYW1lX3Nsb3QgbWF4X2xldmVsX21pbl9hbGxvd2VkX2tleSBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtYXhfYWxsb3dlZF9rZXkgPVxuICAgICAgICAgIEtleS5hZGRfY2xhbXBfdG9fbWF4IG1pbl9hbGxvd2VkX2tleSBkaWZmX21heF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGxldmVsID1cbiAgICAgICAgICB7IExldmVsLmluZGV4XG4gICAgICAgICAgOyBiaXRzID0gbGV2ZWxfYml0c1xuICAgICAgICAgIDsgc2xvdHNfbWFzayA9IFNsb3RzX21hc2suY3JlYXRlIH5sZXZlbF9iaXRzXG4gICAgICAgICAgOyBiaXRzX3Blcl9zbG90XG4gICAgICAgICAgOyBrZXlzX3Blcl9zbG90XG4gICAgICAgICAgOyBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gICAgICAgICAgOyBkaWZmX21heF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICA7IGxlbmd0aCA9IDBcbiAgICAgICAgICA7IG1pbl9hbGxvd2VkX2tleVxuICAgICAgICAgIDsgbWF4X2FsbG93ZWRfa2V5XG4gICAgICAgICAgOyBzbG90cyA9XG4gICAgICAgICAgICAgIEFycmF5LmNyZWF0ZVxuICAgICAgICAgICAgICAgIH5sZW46KEludDYzLnRvX2ludF9leG4gKE51bV9rZXlfYml0cy5wb3cyIGxldmVsX2JpdHMpKVxuICAgICAgICAgICAgICAgIChJbnRlcm5hbF9lbHQubnVsbCAoKSlcbiAgICAgICAgICB9XG4gICAgICAgIGluXG4gICAgICAgICggTnVtX2tleV9iaXRzLiggKyApIGxldmVsX2JpdHMgYml0c19wZXJfc2xvdFxuICAgICAgICAsIEtleS5zdWNjX2NsYW1wX3RvX21heCBtYXhfYWxsb3dlZF9rZXlcbiAgICAgICAgLCBsZXZlbCA6OiBsZXZlbHMgKSlcbiAgICBpblxuICAgIHsgbGVuZ3RoID0gMFxuICAgIDsgcG9vbCA9IEludGVybmFsX2VsdC5Qb29sLmNyZWF0ZSA/Y2FwYWNpdHkgKClcbiAgICA7IG1pbl9lbHQgPSBJbnRlcm5hbF9lbHQubnVsbCAoKVxuICAgIDsgZWx0X2tleV9sb3dlcl9ib3VuZCA9IEtleS56ZXJvXG4gICAgOyBsZXZlbHMgPSBBcnJheS5vZl9saXN0X3JldiBsZXZlbHNcbiAgICB9XG4gIDs7XG5cbiAgbGV0IG1lbSB0IGVsdCA9IEludGVybmFsX2VsdC5leHRlcm5hbF9pc192YWxpZCB0LnBvb2wgZWx0XG5cbiAgbGV0IGludGVybmFsX3JlbW92ZSB0IGVsdCA9XG4gICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICBpZiBJbnRlcm5hbF9lbHQuZXF1YWwgZWx0IHQubWluX2VsdFxuICAgIHRoZW5cbiAgICAgIHQubWluX2VsdCA8LSBJbnRlcm5hbF9lbHQubnVsbCAoKVxuICAgICAgKCogV2Uga2VlcCBbdC5lbHRfbG93ZXJfYm91bmRdIHNpbmNlIGl0IGlzIHZhbGlkIGV2ZW4gdGhvdWdoIFt0Lm1pbl9lbHRdIGlzIGJlaW5nXG4gICAgICAgcmVtb3ZlZC4gKik7XG4gICAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICAgIGxldCBsZXZlbCA9IHQubGV2ZWxzLihJbnRlcm5hbF9lbHQubGV2ZWxfaW5kZXggcG9vbCBlbHQpIGluXG4gICAgbGV2ZWwubGVuZ3RoIDwtIGxldmVsLmxlbmd0aCAtIDE7XG4gICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICBsZXQgc2xvdCA9IExldmVsLnNsb3QgbGV2ZWwgfmtleTooSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdCkgaW5cbiAgICBsZXQgZmlyc3QgPSBzbG90cy4oc2xvdCkgaW5cbiAgICBpZiBwaHlzX2VxdWFsIGVsdCAoSW50ZXJuYWxfZWx0Lm5leHQgcG9vbCBlbHQpXG4gICAgdGhlbiAoKiBbZWx0XSBpcyB0aGUgb25seSBlbGVtZW50IGluIHRoZSBzbG90ICopXG4gICAgICBzbG90cy4oc2xvdCkgPC0gSW50ZXJuYWxfZWx0Lm51bGwgKClcbiAgICBlbHNlIChcbiAgICAgIGlmIHBoeXNfZXF1YWwgZWx0IGZpcnN0IHRoZW4gc2xvdHMuKHNsb3QpIDwtIEludGVybmFsX2VsdC5uZXh0IHBvb2wgZWx0O1xuICAgICAgSW50ZXJuYWxfZWx0LnVubGluayBwb29sIGVsdClcbiAgOztcblxuICBsZXQgcmVtb3ZlIHQgZWx0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBlbHQgPSBJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHBvb2wgZWx0IGluXG4gICAgaW50ZXJuYWxfcmVtb3ZlIHQgZWx0O1xuICAgIEludGVybmFsX2VsdC5mcmVlIHBvb2wgZWx0XG4gIDs7XG5cbiAgbGV0IGZpcmVfcGFzdF9hbGFybXMgdCB+aGFuZGxlX2ZpcmVkIH5rZXkgfm5vdyA9XG4gICAgbGV0IGxldmVsID0gdC5sZXZlbHMuKDApIGluXG4gICAgaWYgbGV2ZWwubGVuZ3RoID4gMFxuICAgIHRoZW4gKFxuICAgICAgbGV0IHNsb3QgPSBMZXZlbC5zbG90IGxldmVsIH5rZXkgaW5cbiAgICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgICAgbGV0IGZpcnN0ID0gcmVmIHNsb3RzLihzbG90KSBpblxuICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCAhZmlyc3QpXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGN1cnJlbnQgPSByZWYgIWZpcnN0IGluXG4gICAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICAgIGxldCBlbHQgPSAhY3VycmVudCBpblxuICAgICAgICAgIGxldCBuZXh0ID0gSW50ZXJuYWxfZWx0Lm5leHQgcG9vbCBlbHQgaW5cbiAgICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgIWZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHQ7XG4gICAgICAgICAgaWYgVGltZV9ucy4oIDw9ICkgKEludGVybmFsX2VsdC5hdCBwb29sIGVsdCkgbm93XG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBoYW5kbGVfZmlyZWQgKEludGVybmFsX2VsdC50b19leHRlcm5hbCBlbHQpO1xuICAgICAgICAgICAgaW50ZXJuYWxfcmVtb3ZlIHQgZWx0O1xuICAgICAgICAgICAgSW50ZXJuYWxfZWx0LmZyZWUgcG9vbCBlbHQ7XG4gICAgICAgICAgICAoKiBXZSByZWNvbXB1dGUgW2ZpcnN0XSBiZWNhdXNlIFtpbnRlcm5hbF9yZW1vdmVdIG1heSBoYXZlIGNoYW5nZWQgaXQuICopXG4gICAgICAgICAgICBmaXJzdCA6PSBzbG90cy4oc2xvdCkpXG4gICAgICAgIGRvbmUpKVxuICA7O1xuXG4gIGxldCBjaGFuZ2UgdCBlbHQgfmtleSB+YXQgPVxuICAgIGVuc3VyZV92YWxpZF9rZXkgdCB+a2V5O1xuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgbGV0IGVsdCA9IEludGVybmFsX2VsdC5vZl9leHRlcm5hbF9leG4gcG9vbCBlbHQgaW5cbiAgICBpbnRlcm5hbF9yZW1vdmUgdCBlbHQ7XG4gICAgSW50ZXJuYWxfZWx0LnNldF9rZXkgcG9vbCBlbHQga2V5O1xuICAgIEludGVybmFsX2VsdC5zZXRfYXQgcG9vbCBlbHQgYXQ7XG4gICAgaW50ZXJuYWxfYWRkX2VsdCB0IGVsdFxuICA7O1xuXG4gIGxldCBjbGVhciB0ID1cbiAgICBpZiBub3QgKGlzX2VtcHR5IHQpXG4gICAgdGhlbiAoXG4gICAgICB0Lmxlbmd0aCA8LSAwO1xuICAgICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICAgIGxldCBmcmVlX2VsdCBlbHQgPSBJbnRlcm5hbF9lbHQuZnJlZSBwb29sIGVsdCBpblxuICAgICAgbGV0IGxldmVscyA9IHQubGV2ZWxzIGluXG4gICAgICBmb3IgbGV2ZWxfaW5kZXggPSAwIHRvIEFycmF5Lmxlbmd0aCBsZXZlbHMgLSAxIGRvXG4gICAgICAgIGxldCBsZXZlbCA9IGxldmVscy4obGV2ZWxfaW5kZXgpIGluXG4gICAgICAgIGlmIGxldmVsLmxlbmd0aCA+IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV2ZWwubGVuZ3RoIDwtIDA7XG4gICAgICAgICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICAgICAgICBmb3Igc2xvdF9pbmRleCA9IDAgdG8gQXJyYXkubGVuZ3RoIHNsb3RzIC0gMSBkb1xuICAgICAgICAgICAgbGV0IGVsdCA9IHNsb3RzLihzbG90X2luZGV4KSBpblxuICAgICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQpXG4gICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgSW50ZXJuYWxfZWx0Lml0ZXIgcG9vbCBlbHQgfmY6ZnJlZV9lbHQ7XG4gICAgICAgICAgICAgIHNsb3RzLihzbG90X2luZGV4KSA8LSBJbnRlcm5hbF9lbHQubnVsbCAoKSlcbiAgICAgICAgICBkb25lKVxuICAgICAgZG9uZSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgSW50ZXJuYWxfZWx0ID0gUHJpb3JpdHlfcXVldWUuSW50ZXJuYWxfZWx0XG5tb2R1bGUgS2V5ID0gUHJpb3JpdHlfcXVldWUuS2V5XG5tb2R1bGUgSW50ZXJ2YWxfbnVtID0gS2V5XG5cbmxldCBtaW5faW50ZXJ2YWxfbnVtID0gSW50ZXJ2YWxfbnVtLnplcm9cblxuKCogQWxsIHRpbWUgZnJvbSB0aGUgZXBvY2ggb253YXJkcyBpcyBicm9rZW4gaW50byBoYWxmLW9wZW4gaW50ZXJ2YWxzIG9mIHNpemVcbiAgIFtDb25maWcuYWxhcm1fcHJlY2lzaW9uIGNvbmZpZ10uICBUaGUgaW50ZXJ2YWxzIGFyZSBudW1iZXJlZCBzdGFydGluZyBhdCB6ZXJvLCBhbmQgYVxuICAgdGltZSdzIGludGVydmFsIG51bWJlciBzZXJ2ZXMgYXMgaXRzIGtleSBpbiBbcHJpb3JpdHlfcXVldWVdLiAqKVxudHlwZSAnYSB0ID1cbiAgeyBjb25maWcgOiBDb25maWcudFxuICA7IHN0YXJ0IDogVGltZV9ucy50XG4gIDsgKCogW21heF9pbnRlcnZhbF9udW1dIGlzIHRoZSBpbnRlcnZhbCBudW1iZXIgb2YgW21heF90aW1lXS4gKilcbiAgICBtYXhfaW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnRcbiAgOyBtdXRhYmxlIG5vdyA6IFRpbWVfbnMudFxuICA7IG11dGFibGUgbm93X2ludGVydmFsX251bV9zdGFydCA6IFRpbWVfbnMudFxuICA7IG11dGFibGUgbWF4X2FsbG93ZWRfYWxhcm1fdGltZSA6IFRpbWVfbnMudFxuICA7IHByaW9yaXR5X3F1ZXVlIDogJ2EgUHJpb3JpdHlfcXVldWUudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG50eXBlICdhIHRpbWluZ193aGVlbCA9ICdhIHRcbnR5cGUgJ2EgdF9ub3cgPSAnYSB0XG5cbmxldCBzZXhwX29mX3Rfbm93IF8gdCA9IFslc2V4cCAodC5ub3cgOiBUaW1lX25zLnQpXVxubGV0IGFsYXJtX3ByZWNpc2lvbiB0ID0gQ29uZmlnLmFsYXJtX3ByZWNpc2lvbiB0LmNvbmZpZ1xuXG5tb2R1bGUgQWxhcm0gPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgUHJpb3JpdHlfcXVldWUuRWx0LnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgbnVsbCA9IFByaW9yaXR5X3F1ZXVlLkVsdC5udWxsXG4gIGxldCBhdCB0dyB0ID0gUHJpb3JpdHlfcXVldWUuRWx0LmF0IHR3LnByaW9yaXR5X3F1ZXVlIHRcbiAgbGV0IHZhbHVlIHR3IHQgPSBQcmlvcml0eV9xdWV1ZS5FbHQudmFsdWUgdHcucHJpb3JpdHlfcXVldWUgdFxuICBsZXQgaW50ZXJ2YWxfbnVtIHR3IHQgPSBQcmlvcml0eV9xdWV1ZS5FbHQua2V5IHR3LnByaW9yaXR5X3F1ZXVlIHRcbmVuZFxuXG5sZXQgc2V4cF9vZl90X2ludGVybmFsID0gc2V4cF9vZl90XG5sZXQgaXRlciB0IH5mID0gUHJpb3JpdHlfcXVldWUuaXRlciB0LnByaW9yaXR5X3F1ZXVlIH5mXG5cbm1vZHVsZSBQcmV0dHkgPSBzdHJ1Y3RcbiAgbW9kdWxlIEFsYXJtID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgYXQgOiBUaW1lX25zLnRcbiAgICAgIDsgdmFsdWUgOiAnYVxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycywgc2V4cF9vZl1cblxuICAgIGxldCBjcmVhdGUgdCBhbGFybSA9IHsgYXQgPSBBbGFybS5hdCB0IGFsYXJtOyB2YWx1ZSA9IEFsYXJtLnZhbHVlIHQgYWxhcm0gfVxuICAgIGxldCBjb21wYXJlIHQxIHQyID0gVGltZV9ucy5jb21wYXJlIChhdCB0MSkgKGF0IHQyKVxuICBlbmRcblxuICB0eXBlICdhIHQgPVxuICAgIHsgY29uZmlnIDogQ29uZmlnLnRcbiAgICA7IHN0YXJ0IDogVGltZV9ucy50XG4gICAgOyBtYXhfaW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnRcbiAgICA7IG5vdyA6IFRpbWVfbnMudFxuICAgIDsgYWxhcm1zIDogJ2EgQWxhcm0udCBsaXN0XG4gICAgfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbmxldCBwcmV0dHlcbiAgKHsgY29uZmlnXG4gICA7IHN0YXJ0XG4gICA7IG1heF9pbnRlcnZhbF9udW1cbiAgIDsgbm93XG4gICA7IG5vd19pbnRlcnZhbF9udW1fc3RhcnQgPSBfXG4gICA7IG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgPSBfXG4gICA7IHByaW9yaXR5X3F1ZXVlID0gX1xuICAgfSBhcyB0KVxuICA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gciA6PSBQcmV0dHkuQWxhcm0uY3JlYXRlIHQgYSA6OiAhcik7XG4gIGxldCBhbGFybXMgPSBMaXN0LnNvcnQgIXIgfmNvbXBhcmU6UHJldHR5LkFsYXJtLmNvbXBhcmUgaW5cbiAgeyBQcmV0dHkuY29uZmlnOyBzdGFydDsgbWF4X2ludGVydmFsX251bTsgbm93OyBhbGFybXMgfVxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gIG1hdGNoICFzZXhwX29mX3Rfc3R5bGUgd2l0aFxuICB8IGBJbnRlcm5hbCAtPiBzZXhwX29mX3RfaW50ZXJuYWwgc2V4cF9vZl9hIHRcbiAgfCBgUHJldHR5IC0+IFslc2V4cCAocHJldHR5IHQgOiBhIFByZXR0eS50KV1cbjs7XG5cbmxldCBsZW5ndGggdCA9IFByaW9yaXR5X3F1ZXVlLmxlbmd0aCB0LnByaW9yaXR5X3F1ZXVlXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG5sZXRbQGNvbGRdIHJhaXNlX25leHRfYWxhcm1fZmlyZXNfYXRfZXhuX29mX2VtcHR5X3RpbWluZ193aGVlbCB0ID1cbiAgcmFpc2Vfc1xuICAgIFslbWVzc2FnZVxuICAgICAgXCJUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdF9leG4gb2YgZW1wdHkgdGltaW5nIHdoZWVsXCIgfnRpbWluZ193aGVlbDoodCA6IF8gdCldXG47O1xuXG5sZXRbQGNvbGRdIHJhaXNlX25leHRfYWxhcm1fZmlyZXNfYXRfd2l0aF9hbGxfYWxhcm1zX2luX21heF9pbnRlcnZhbCB0ID1cbiAgcmFpc2Vfc1xuICAgIFslbWVzc2FnZVxuICAgICAgXCJUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdF9leG4gd2l0aCBhbGwgYWxhcm1zIGluIG1heCBpbnRlcnZhbFwiXG4gICAgICAgIH50aW1pbmdfd2hlZWw6KHQgOiBfIHQpXVxuOztcblxubGV0IHBvb2wgdCA9IFByaW9yaXR5X3F1ZXVlLnBvb2wgdC5wcmlvcml0eV9xdWV1ZVxuXG5sZXQgaW50ZXJ2YWxfbnVtX2ludGVybmFsIH50aW1lIH5hbGFybV9wcmVjaXNpb24gPVxuICBJbnRlcnZhbF9udW0ub2ZfaW50NjMgKEFsYXJtX3ByZWNpc2lvbi5pbnRlcnZhbF9udW0gYWxhcm1fcHJlY2lzaW9uIHRpbWUpXG47O1xuXG5sZXQgaW50ZXJ2YWxfbnVtX3VuY2hlY2tlZCB0IHRpbWUgPVxuICBpbnRlcnZhbF9udW1faW50ZXJuYWwgfnRpbWUgfmFsYXJtX3ByZWNpc2lvbjp0LmNvbmZpZy5hbGFybV9wcmVjaXNpb25cbjs7XG5cbmxldCBpbnRlcnZhbF9udW0gdCB0aW1lID1cbiAgaWYgVGltZV9ucy4oIDwgKSB0aW1lIG1pbl90aW1lXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwuaW50ZXJ2YWxfbnVtIGdvdCB0aW1lIHRvbyBmYXIgaW4gdGhlIHBhc3RcIiAodGltZSA6IFRpbWVfbnMudCldO1xuICBpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgdGltZVxuOztcblxubGV0IGludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQgdCBpbnRlcnZhbF9udW0gPVxuICBBbGFybV9wcmVjaXNpb24uaW50ZXJ2YWxfbnVtX3N0YXJ0XG4gICAgdC5jb25maWcuYWxhcm1fcHJlY2lzaW9uXG4gICAgKGludGVydmFsX251bSB8PiBJbnRlcnZhbF9udW0udG9faW50NjMpXG47O1xuXG5sZXRbQGNvbGRdIHJhaXNlX2ludGVydmFsX251bV9zdGFydF9nb3RfdG9vX3NtYWxsIGludGVydmFsX251bSA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiVGltaW5nX3doZWVsLmludGVydmFsX251bV9zdGFydCBnb3QgdG9vIHNtYWxsIGludGVydmFsX251bVwiXG4gICAgICAgIChpbnRlcnZhbF9udW0gOiBJbnRlcnZhbF9udW0udClcbiAgICAgICAgKG1pbl9pbnRlcnZhbF9udW0gOiBJbnRlcnZhbF9udW0udCldXG47O1xuXG5sZXRbQGNvbGRdIHJhaXNlX2ludGVydmFsX251bV9zdGFydF9nb3RfdG9vX2xhcmdlIHQgaW50ZXJ2YWxfbnVtID1cbiAgcmFpc2Vfc1xuICAgIFslbWVzc2FnZVxuICAgICAgXCJUaW1pbmdfd2hlZWwuaW50ZXJ2YWxfbnVtX3N0YXJ0IGdvdCB0b28gbGFyZ2UgaW50ZXJ2YWxfbnVtXCJcbiAgICAgICAgKGludGVydmFsX251bSA6IEludGVydmFsX251bS50KVxuICAgICAgICAodC5tYXhfaW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnQpXVxuOztcblxubGV0IGludGVydmFsX251bV9zdGFydCB0IGludGVydmFsX251bSA9XG4gIGlmIEludGVydmFsX251bS4oIDwgKSBpbnRlcnZhbF9udW0gbWluX2ludGVydmFsX251bVxuICB0aGVuIHJhaXNlX2ludGVydmFsX251bV9zdGFydF9nb3RfdG9vX3NtYWxsIGludGVydmFsX251bTtcbiAgaWYgSW50ZXJ2YWxfbnVtLiggPiApIGludGVydmFsX251bSB0Lm1heF9pbnRlcnZhbF9udW1cbiAgdGhlbiByYWlzZV9pbnRlcnZhbF9udW1fc3RhcnRfZ290X3Rvb19sYXJnZSB0IGludGVydmFsX251bTtcbiAgaW50ZXJ2YWxfbnVtX3N0YXJ0X3VuY2hlY2tlZCB0IGludGVydmFsX251bVxuOztcblxubGV0IG5leHRfYWxhcm1fZmlyZXNfYXRfaW50ZXJuYWwgdCBrZXkgPVxuICAoKiBbaW50ZXJ2YWxfbnVtX3N0YXJ0IHQga2V5XSBpcyB0aGUga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0aW1lIGludGVydmFsXG4gICAgIGhvbGRpbmcgdGhlIGZpcnN0IGFsYXJtIGluIFt0XS4gIEFkdmFuY2luZyB0byB0aGF0IHdvdWxkIG5vdCBiZSBlbm91Z2gsIHNpbmNlIHRoZVxuICAgICBhbGFybXMgaW4gdGhhdCBpbnRlcnZhbCBkb24ndCBmaXJlIHVudGlsIHRoZSBjbG9jayBpcyBhZHZhbmNlZCB0byB0aGUgc3RhcnQgb2YgdGhlXG4gICAgIG5leHQgaW50ZXJ2YWwuICBTbywgd2UgdXNlIFtzdWNjIGtleV0gdG8gYWR2YW5jZSB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHRcbiAgICAgaW50ZXJ2YWwuICopXG4gIGludGVydmFsX251bV9zdGFydCB0IChLZXkuc3VjYyBrZXkpXG47O1xuXG5sZXQgbmV4dF9hbGFybV9maXJlc19hdCB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQga2V5ID0gSW50ZXJuYWxfZWx0LmtleSAocG9vbCB0KSBlbHQgaW5cbiAgICBpZiBJbnRlcnZhbF9udW0uZXF1YWwga2V5IHQubWF4X2ludGVydmFsX251bVxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgU29tZSAobmV4dF9hbGFybV9maXJlc19hdF9pbnRlcm5hbCB0IGtleSkpXG47O1xuXG5sZXQgbmV4dF9hbGFybV9maXJlc19hdF9leG4gdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdCB0aGVuIHJhaXNlX25leHRfYWxhcm1fZmlyZXNfYXRfZXhuX29mX2VtcHR5X3RpbWluZ193aGVlbCB0O1xuICBsZXQga2V5ID0gSW50ZXJuYWxfZWx0LmtleSAocG9vbCB0KSBlbHQgaW5cbiAgaWYgSW50ZXJ2YWxfbnVtLmVxdWFsIGtleSB0Lm1heF9pbnRlcnZhbF9udW1cbiAgdGhlbiByYWlzZV9uZXh0X2FsYXJtX2ZpcmVzX2F0X3dpdGhfYWxsX2FsYXJtc19pbl9tYXhfaW50ZXJ2YWwgdDtcbiAgbmV4dF9hbGFybV9maXJlc19hdF9pbnRlcm5hbCB0IGtleVxuOztcblxubGV0IGNvbXB1dGVfbWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0ID1cbiAgbGV0IG1heF9hbGxvd2VkX2tleSA9IFByaW9yaXR5X3F1ZXVlLm1heF9hbGxvd2VkX2tleSB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVydmFsX251bS4oID49ICkgbWF4X2FsbG93ZWRfa2V5IHQubWF4X2ludGVydmFsX251bVxuICB0aGVuIG1heF90aW1lXG4gIGVsc2VcbiAgICBUaW1lX25zLmFkZFxuICAgICAgKGludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQgdCBtYXhfYWxsb3dlZF9rZXkpXG4gICAgICAoVGltZV9ucy5TcGFuLiggLSApIChhbGFybV9wcmVjaXNpb24gdCkgVGltZV9ucy5TcGFuLm5hbm9zZWNvbmQpXG47O1xuXG5sZXQgbm93X2ludGVydmFsX251bSB0ID0gUHJpb3JpdHlfcXVldWUubWluX2FsbG93ZWRfa2V5IHQucHJpb3JpdHlfcXVldWVcbmxldCBtaW5fYWxsb3dlZF9hbGFybV9pbnRlcnZhbF9udW0gPSBub3dfaW50ZXJ2YWxfbnVtXG5sZXQgbWF4X2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtIHQgPSBpbnRlcnZhbF9udW0gdCAobWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0KVxubGV0IGludGVydmFsX3N0YXJ0IHQgdGltZSA9IGludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQgdCAoaW50ZXJ2YWxfbnVtIHQgdGltZSlcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfmNvbmZpZzooY2hlY2sgQ29uZmlnLmludmFyaWFudClcbiAgICAgIH5zdGFydDpcbiAgICAgICAgKGNoZWNrIChmdW4gc3RhcnQgLT5cbiAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPj0gKSBzdGFydCBtaW5fdGltZSk7XG4gICAgICAgICAgIGFzc2VydCAoVGltZV9ucy4oIDw9ICkgc3RhcnQgbWF4X3RpbWUpKSlcbiAgICAgIH5tYXhfaW50ZXJ2YWxfbnVtOlxuICAgICAgICAoY2hlY2sgKGZ1biBtYXhfaW50ZXJ2YWxfbnVtIC0+XG4gICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEludGVydmFsX251bS50XVxuICAgICAgICAgICAgIH5leHBlY3Q6bWF4X2ludGVydmFsX251bVxuICAgICAgICAgICAgIChpbnRlcnZhbF9udW0gdCBtYXhfdGltZSk7XG4gICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEludGVydmFsX251bS50XVxuICAgICAgICAgICAgIH5leHBlY3Q6bWF4X2ludGVydmFsX251bVxuICAgICAgICAgICAgIChpbnRlcnZhbF9udW0gdCAoaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgbWF4X2ludGVydmFsX251bSkpKSlcbiAgICAgIH5ub3c6XG4gICAgICAgIChjaGVjayAoZnVuIG5vdyAtPlxuICAgICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA+PSApIG5vdyB0LnN0YXJ0KTtcbiAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPD0gKSBub3cgbWF4X3RpbWUpO1xuICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgIEludGVydmFsX251bS5lcXVhbFxuICAgICAgICAgICAgICAgKGludGVydmFsX251bSB0IHQubm93KVxuICAgICAgICAgICAgICAgKFByaW9yaXR5X3F1ZXVlLm1pbl9hbGxvd2VkX2tleSB0LnByaW9yaXR5X3F1ZXVlKSkpKVxuICAgICAgfm5vd19pbnRlcnZhbF9udW1fc3RhcnQ6XG4gICAgICAgIChjaGVjayAoZnVuIG5vd19pbnRlcnZhbF9udW1fc3RhcnQgLT5cbiAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogVGltZV9ucy50XVxuICAgICAgICAgICAgIG5vd19pbnRlcnZhbF9udW1fc3RhcnRcbiAgICAgICAgICAgICB+ZXhwZWN0OihpbnRlcnZhbF9udW1fc3RhcnQgdCAobm93X2ludGVydmFsX251bSB0KSkpKVxuICAgICAgfm1heF9hbGxvd2VkX2FsYXJtX3RpbWU6XG4gICAgICAgIChjaGVjayAoZnVuIG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgLT5cbiAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogVGltZV9ucy50XVxuICAgICAgICAgICAgIG1heF9hbGxvd2VkX2FsYXJtX3RpbWVcbiAgICAgICAgICAgICB+ZXhwZWN0Oihjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdCkpKVxuICAgICAgfnByaW9yaXR5X3F1ZXVlOihjaGVjayAoUHJpb3JpdHlfcXVldWUuaW52YXJpYW50IGludmFyaWFudF9hKSk7XG4gICAgaXRlciB0IH5mOihmdW4gYWxhcm0gLT5cbiAgICAgIGFzc2VydCAoXG4gICAgICAgIEludGVydmFsX251bS5lcXVhbFxuICAgICAgICAgIChBbGFybS5pbnRlcnZhbF9udW0gdCBhbGFybSlcbiAgICAgICAgICAoaW50ZXJ2YWxfbnVtIHQgKEFsYXJtLmF0IHQgYWxhcm0pKSk7XG4gICAgICBhc3NlcnQgKFxuICAgICAgICBUaW1lX25zLiggPj0gKSAoaW50ZXJ2YWxfc3RhcnQgdCAoQWxhcm0uYXQgdCBhbGFybSkpIChpbnRlcnZhbF9zdGFydCB0IChub3cgdCkpKTtcbiAgICAgIGFzc2VydCAoVGltZV9ucy4oID4gKSAoQWxhcm0uYXQgdCBhbGFybSkgKFRpbWVfbnMuc3ViIChub3cgdCkgKGFsYXJtX3ByZWNpc2lvbiB0KSkpKSlcbjs7XG5cbmxldCBkZWJ1ZyA9IGZhbHNlXG5cbmxldCBhZHZhbmNlX2Nsb2NrIHQgfnRvXyB+aGFuZGxlX2ZpcmVkID1cbiAgaWYgVGltZV9ucy4oID4gKSB0b18gKG5vdyB0KVxuICB0aGVuIChcbiAgICB0Lm5vdyA8LSB0b187XG4gICAgbGV0IGtleSA9IGludGVydmFsX251bV91bmNoZWNrZWQgdCB0b18gaW5cbiAgICB0Lm5vd19pbnRlcnZhbF9udW1fc3RhcnQgPC0gaW50ZXJ2YWxfbnVtX3N0YXJ0X3VuY2hlY2tlZCB0IGtleTtcbiAgICBtYXRjaFxuICAgICAgUHJpb3JpdHlfcXVldWUuaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgIHQucHJpb3JpdHlfcXVldWVcbiAgICAgICAgfmtleVxuICAgICAgICB+aGFuZGxlX3JlbW92ZWQ6aGFuZGxlX2ZpcmVkXG4gICAgd2l0aFxuICAgIHwgTWF4X2FsbG93ZWRfa2V5X2RpZF9ub3RfY2hhbmdlIC0+XG4gICAgICBpZiBkZWJ1Z1xuICAgICAgdGhlblxuICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA9ICkgdC5tYXhfYWxsb3dlZF9hbGFybV90aW1lIChjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdCkpXG4gICAgfCBNYXhfYWxsb3dlZF9rZXlfbWF5YmVfY2hhbmdlZCAtPlxuICAgICAgdC5tYXhfYWxsb3dlZF9hbGFybV90aW1lIDwtIGNvbXB1dGVfbWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0KVxuOztcblxubGV0IGFkdmFuY2VfY2xvY2tfc3RvcF9hdF9uZXh0X2FsYXJtIHQgfnRvXyB+aGFuZGxlX2ZpcmVkID1cbiAgbGV0IG1pbl9lbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIG1pbl9lbHRcbiAgdGhlbiBhZHZhbmNlX2Nsb2NrIHQgfnRvXyB+aGFuZGxlX2ZpcmVkOihmdW4gXyAtPiBhc3NlcnQgZmFsc2UpXG4gIGVsc2UgKFxuICAgIGxldCBrZXkgPSBJbnRlcm5hbF9lbHQua2V5IChwb29sIHQpIG1pbl9lbHQgaW5cbiAgICAoKiBhcyBhbiBvcHRpbWl6YXRpb24sIGNvbXBhcmUgYWdhaW5zdCBbaW50ZXJ2YWxfbnVtX3N0YXJ0XSB0byBhdm9pZCB0aGUgcG90ZW50aWFsbHlcbiAgICAgICBjb3N0bHkgY29tcHV0YXRpb24gb2YgW0ludGVybmFsX2VsdC5taW5fYWxhcm1fdGltZV0gKilcbiAgICBpZiBUaW1lX25zLiggPCApIHRvXyAoaW50ZXJ2YWxfbnVtX3N0YXJ0IHQga2V5KVxuICAgIHRoZW4gYWR2YW5jZV9jbG9jayB0IH50b18gfmhhbmRsZV9maXJlZDooZnVuIF8gLT4gYXNzZXJ0IGZhbHNlKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHRvXyA9XG4gICAgICAgIFRpbWVfbnMubWluIHRvXyAoSW50ZXJuYWxfZWx0Lm1pbl9hbGFybV90aW1lIChwb29sIHQpIG1pbl9lbHQgfndpdGhfa2V5OmtleSlcbiAgICAgIGluXG4gICAgICBhZHZhbmNlX2Nsb2NrIHQgfnRvXyB+aGFuZGxlX2ZpcmVkKSlcbjs7XG5cbmxldCBjcmVhdGUgfmNvbmZpZyB+c3RhcnQgPVxuICBpZiBUaW1lX25zLiggPCApIHN0YXJ0IFRpbWVfbnMuZXBvY2hcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZSBcIlRpbWluZ193aGVlbC5jcmVhdGUgZ290IHN0YXJ0IGJlZm9yZSB0aGUgZXBvY2hcIiAoc3RhcnQgOiBUaW1lX25zLnQpXTtcbiAgbGV0IHQgPVxuICAgIHsgY29uZmlnXG4gICAgOyBzdGFydFxuICAgIDsgbWF4X2ludGVydmFsX251bSA9XG4gICAgICAgIGludGVydmFsX251bV9pbnRlcm5hbCB+dGltZTptYXhfdGltZSB+YWxhcm1fcHJlY2lzaW9uOmNvbmZpZy5hbGFybV9wcmVjaXNpb25cbiAgICA7IG5vdyA9IFRpbWVfbnMubWluX3ZhbHVlX2Zvcl8xdXNfcm91bmRpbmcgKCogc2V0IGJ5IFthZHZhbmNlX2Nsb2NrXSBiZWxvdyAqKVxuICAgIDsgbm93X2ludGVydmFsX251bV9zdGFydCA9XG4gICAgICAgIFRpbWVfbnMubWluX3ZhbHVlX2Zvcl8xdXNfcm91bmRpbmcgKCogc2V0IGJ5IFthZHZhbmNlX2Nsb2NrXSBiZWxvdyAqKVxuICAgIDsgbWF4X2FsbG93ZWRfYWxhcm1fdGltZSA9IG1heF90aW1lICgqIHNldCBieSBbYWR2YW5jZV9jbG9ja10gYmVsb3cgKilcbiAgICA7IHByaW9yaXR5X3F1ZXVlID1cbiAgICAgICAgUHJpb3JpdHlfcXVldWUuY3JlYXRlID9jYXBhY2l0eTpjb25maWcuY2FwYWNpdHkgfmxldmVsX2JpdHM6Y29uZmlnLmxldmVsX2JpdHMgKClcbiAgICB9XG4gIGluXG4gIHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSA8LSBjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdDtcbiAgYWR2YW5jZV9jbG9jayB0IH50b186c3RhcnQgfmhhbmRsZV9maXJlZDooZnVuIF8gLT4gYXNzZXJ0IGZhbHNlKTtcbiAgdFxuOztcblxubGV0IGFkZF9hdF9pbnRlcnZhbF9udW0gdCB+YXQgdmFsdWUgPVxuICBJbnRlcm5hbF9lbHQudG9fZXh0ZXJuYWxcbiAgICAoUHJpb3JpdHlfcXVldWUuaW50ZXJuYWxfYWRkXG4gICAgICAgdC5wcmlvcml0eV9xdWV1ZVxuICAgICAgIH5rZXk6YXRcbiAgICAgICB+YXQ6KGludGVydmFsX251bV9zdGFydCB0IGF0KVxuICAgICAgIHZhbHVlKVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV90aGF0X2Zhcl9pbl90aGVfZnV0dXJlIHQgYXQgPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbCBjYW5ub3Qgc2NoZWR1bGUgYWxhcm0gdGhhdCBmYXIgaW4gdGhlIGZ1dHVyZVwiXG4gICAgICAgIChhdCA6IFRpbWVfbnMudClcbiAgICAgICAgfm1heF9hbGxvd2VkX2FsYXJtX3RpbWU6KHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSA6IFRpbWVfbnMudCldXG47O1xuXG5sZXRbQGNvbGRdIHJhaXNlX2JlZm9yZV9zdGFydF9vZl9jdXJyZW50X2ludGVydmFsIHQgYXQgPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbCBjYW5ub3Qgc2NoZWR1bGUgYWxhcm0gYmVmb3JlIHN0YXJ0IG9mIGN1cnJlbnQgaW50ZXJ2YWxcIlxuICAgICAgICAoYXQgOiBUaW1lX25zLnQpXG4gICAgICAgIH5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0Oih0Lm5vd19pbnRlcnZhbF9udW1fc3RhcnQgOiBUaW1lX25zLnQpXVxuOztcblxubGV0IGVuc3VyZV9jYW5fc2NoZWR1bGVfYWxhcm0gdCB+YXQgPVxuICBpZiBUaW1lX25zLiggPiApIGF0IHQubWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0aGVuIHJhaXNlX3RoYXRfZmFyX2luX3RoZV9mdXR1cmUgdCBhdDtcbiAgaWYgVGltZV9ucy4oIDwgKSBhdCB0Lm5vd19pbnRlcnZhbF9udW1fc3RhcnRcbiAgdGhlbiByYWlzZV9iZWZvcmVfc3RhcnRfb2ZfY3VycmVudF9pbnRlcnZhbCB0IGF0XG47O1xuXG5sZXQgYWRkIHQgfmF0IHZhbHVlID1cbiAgZW5zdXJlX2Nhbl9zY2hlZHVsZV9hbGFybSB0IH5hdDtcbiAgSW50ZXJuYWxfZWx0LnRvX2V4dGVybmFsXG4gICAgKFByaW9yaXR5X3F1ZXVlLmludGVybmFsX2FkZFxuICAgICAgIHQucHJpb3JpdHlfcXVldWVcbiAgICAgICB+a2V5OihpbnRlcnZhbF9udW1fdW5jaGVja2VkIHQgYXQpXG4gICAgICAgfmF0XG4gICAgICAgdmFsdWUpXG47O1xuXG5sZXQgcmVtb3ZlIHQgYWxhcm0gPSBQcmlvcml0eV9xdWV1ZS5yZW1vdmUgdC5wcmlvcml0eV9xdWV1ZSBhbGFybVxubGV0IGNsZWFyIHQgPSBQcmlvcml0eV9xdWV1ZS5jbGVhciB0LnByaW9yaXR5X3F1ZXVlXG5sZXQgbWVtIHQgYWxhcm0gPSBQcmlvcml0eV9xdWV1ZS5tZW0gdC5wcmlvcml0eV9xdWV1ZSBhbGFybVxuXG5sZXQgcmVzY2hlZHVsZV9nZW4gdCBhbGFybSB+a2V5IH5hdCA9XG4gIGlmIG5vdCAobWVtIHQgYWxhcm0pXG4gIHRoZW4gZmFpbHdpdGggXCJUaW1pbmdfd2hlZWwgY2Fubm90IHJlc2NoZWR1bGUgYWxhcm0gbm90IGluIHRpbWluZyB3aGVlbFwiO1xuICBlbnN1cmVfY2FuX3NjaGVkdWxlX2FsYXJtIHQgfmF0O1xuICBQcmlvcml0eV9xdWV1ZS5jaGFuZ2UgdC5wcmlvcml0eV9xdWV1ZSBhbGFybSB+a2V5IH5hdFxuOztcblxubGV0IHJlc2NoZWR1bGUgdCBhbGFybSB+YXQgPSByZXNjaGVkdWxlX2dlbiB0IGFsYXJtIH5rZXk6KGludGVydmFsX251bV91bmNoZWNrZWQgdCBhdCkgfmF0XG5cbmxldCByZXNjaGVkdWxlX2F0X2ludGVydmFsX251bSB0IGFsYXJtIH5hdCA9XG4gIHJlc2NoZWR1bGVfZ2VuIHQgYWxhcm0gfmtleTphdCB+YXQ6KGludGVydmFsX251bV9zdGFydCB0IGF0KVxuOztcblxubGV0IG1pbl9hbGFybV9pbnRlcnZhbF9udW0gdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdCB0aGVuIE5vbmUgZWxzZSBTb21lIChJbnRlcm5hbF9lbHQua2V5IChwb29sIHQpIGVsdClcbjs7XG5cbmxldCBtaW5fYWxhcm1faW50ZXJ2YWxfbnVtX2V4biB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwubWluX2FsYXJtX2ludGVydmFsX251bV9leG4gb2YgZW1wdHkgdGltaW5nX3doZWVsXCJcbiAgICAgICAgICB+dGltaW5nX3doZWVsOih0IDogXyB0KV1cbiAgZWxzZSBJbnRlcm5hbF9lbHQua2V5IChwb29sIHQpIGVsdFxuOztcblxubGV0IG1heF9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQgPVxuICBsZXQgcG9vbCA9IHBvb2wgdCBpblxuICBJbnRlcm5hbF9lbHQubWF4X2FsYXJtX3RpbWUgcG9vbCBlbHQgfndpdGhfa2V5OihJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KVxuOztcblxubGV0IG1pbl9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQgPVxuICBsZXQgcG9vbCA9IHBvb2wgdCBpblxuICBJbnRlcm5hbF9lbHQubWluX2FsYXJtX3RpbWUgcG9vbCBlbHQgfndpdGhfa2V5OihJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KVxuOztcblxubGV0IG1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKG1heF9hbGFybV90aW1lX2luX2xpc3QgdCBlbHQpXG47O1xuXG5sZXQgbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQgdGhlbiBOb25lIGVsc2UgU29tZSAobWluX2FsYXJtX3RpbWVfaW5fbGlzdCB0IGVsdClcbjs7XG5cbmxldCBtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHRcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlRpbWluZ193aGVlbC5tYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIG9mIGVtcHR5IHRpbWluZyB3aGVlbFwiXG4gICAgICAgICAgfnRpbWluZ193aGVlbDoodCA6IF8gdCldO1xuICBtYXhfYWxhcm1fdGltZV9pbl9saXN0IHQgZWx0XG47O1xuXG5sZXQgbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0XG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwubWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biBvZiBlbXB0eSB0aW1pbmcgd2hlZWxcIlxuICAgICAgICAgIH50aW1pbmdfd2hlZWw6KHQgOiBfIHQpXTtcbiAgbWluX2FsYXJtX3RpbWVfaW5fbGlzdCB0IGVsdFxuOztcblxubGV0IGZpcmVfcGFzdF9hbGFybXMgdCB+aGFuZGxlX2ZpcmVkID1cbiAgUHJpb3JpdHlfcXVldWUuZmlyZV9wYXN0X2FsYXJtc1xuICAgIHQucHJpb3JpdHlfcXVldWVcbiAgICB+aGFuZGxlX2ZpcmVkXG4gICAgfmtleToobm93X2ludGVydmFsX251bSB0KVxuICAgIH5ub3c6dC5ub3dcbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBOdW1fa2V5X2JpdHMgPSBOdW1fa2V5X2JpdHNcblxuICBsZXQgaW50ZXJ2YWxfbnVtX2ludGVybmFsID0gaW50ZXJ2YWxfbnVtX2ludGVybmFsXG4gIGxldCBtYXhfdGltZSA9IG1heF90aW1lXG5lbmRcbiJdfQ==
