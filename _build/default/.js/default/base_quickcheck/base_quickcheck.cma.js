// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Base_quickcheck__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Base_quickcheck = [0],
    Base_quickcheck$0 = [0, Base_quickcheck];
   runtime.caml_register_global(0, Base_quickcheck$0, "Base_quickcheck__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__With_basic_types
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Base_quickcheck_With_basic_typ = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_With_basic_typ, "Base_quickcheck__With_basic_types");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Bigarray_helpers
//# unitInfo: Requires: Base, Base__Array, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_ba_get_2 = runtime.caml_ba_get_2,
    caml_ba_layout = runtime.caml_ba_layout;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Base_Array = global_data.Base__Array,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray;
   function offset(param){return param ? 1 : 0;}
   var Layout = [0, offset];
   function iteri(t, f){
    var
     _v_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _v_),
     _x_ = caml_ba_dim_1(t) - 1 | 0,
     _w_ = 0;
    if(_x_ >= 0){
     var i = _w_;
     for(;;){
      caml_call2(f, i + offset | 0, caml_ba_get_1(t, i + offset | 0));
      var _y_ = i + 1 | 0;
      if(_x_ === i) break;
      var i = _y_;
     }
    }
    return 0;
   }
   function init(kind, layout, dim, f){
    var t = caml_call3(Stdlib_Bigarray[19][1], kind, layout, dim);
    iteri
     (t,
      function(i, param){
       return runtime.caml_ba_set_1(t, i, caml_call1(f, i));
      });
    return t;
   }
   function fold(t, init, f){
    var init$0 = [0, init];
    iteri
     (t,
      function(i, param){
       var _u_ = caml_ba_get_1(t, i);
       init$0[1] = caml_call2(f, init$0[1], _u_);
       return 0;
      });
    return init$0[1];
   }
   function to_array(t){
    var _r_ = caml_ba_layout(t), offset = caml_call1(Layout[1], _r_);
    function _s_(i){return caml_ba_get_1(t, i + offset | 0);}
    var _t_ = caml_ba_dim_1(t);
    return caml_call2(Base_Array[41], _t_, _s_);
   }
   function sexp_of_t(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_001 = to_array(t);
    return caml_call2(Base[95], sexp_of_elt, x_001);
   }
   function hash_fold(hash_fold_elt, state, t){
    var _q_ = caml_ba_dim_1(t), state$0 = caml_call2(Base[133], state, _q_);
    return fold(t, state$0, hash_fold_elt);
   }
   function iteri$0(t, f){
    var
     _j_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _j_),
     _l_ = caml_ba_dim_1(t) - 1 | 0,
     _k_ = 0;
    if(_l_ >= 0){
     var i = _k_;
     for(;;){
      var _n_ = caml_ba_dim_2(t) - 1 | 0, _m_ = 0;
      if(_n_ >= 0){
       var j = _m_;
       for(;;){
        caml_call3
         (f,
          i + offset | 0,
          j + offset | 0,
          caml_ba_get_2(t, i + offset | 0, j + offset | 0));
        var _p_ = j + 1 | 0;
        if(_n_ === j) break;
        var j = _p_;
       }
      }
      var _o_ = i + 1 | 0;
      if(_l_ === i) break;
      var i = _o_;
     }
    }
    return 0;
   }
   function init$0(kind, layout, dim1, dim2, f){
    var t = caml_call4(Stdlib_Bigarray[20][1], kind, layout, dim1, dim2);
    iteri$0
     (t,
      function(i, j, param){
       return runtime.caml_ba_set_2(t, i, j, caml_call2(f, i, j));
      });
    return t;
   }
   function fold$0(t, init, f){
    var init$0 = [0, init];
    iteri$0
     (t,
      function(param, _i_, elt){
       init$0[1] = caml_call2(f, init$0[1], elt);
       return 0;
      });
    return init$0[1];
   }
   function to_array$0(t){
    var _d_ = caml_ba_layout(t), offset = caml_call1(Layout[1], _d_);
    function _e_(i){
     function _g_(j){return caml_ba_get_2(t, i + offset | 0, j + offset | 0);}
     var _h_ = caml_ba_dim_2(t);
     return caml_call2(Base_Array[41], _h_, _g_);
    }
    var _f_ = caml_ba_dim_1(t);
    return caml_call2(Base_Array[41], _f_, _e_);
   }
   function sexp_of_t$0(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_002 = to_array$0(t), _c_ = caml_call1(Base[95], sexp_of_elt);
    return caml_call2(Base[95], _c_, x_002);
   }
   function hash_fold$0(hash_fold_elt, state, t){
    var
     _a_ = caml_ba_dim_1(t),
     state$0 = caml_call2(Base[133], state, _a_),
     _b_ = caml_ba_dim_2(t),
     state$1 = caml_call2(Base[133], state$0, _b_);
    return fold$0(t, state$1, hash_fold_elt);
   }
   var
    Base_quickcheck_Bigarray_helpe =
      [0,
       Layout,
       [0, sexp_of_t, init, iteri, fold, to_array, hash_fold],
       [0, sexp_of_t$0, init$0, iteri$0, fold$0, to_array$0, hash_fold$0]];
   runtime.caml_register_global
    (3, Base_quickcheck_Bigarray_helpe, "Base_quickcheck__Bigarray_helpers");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer0
//# unitInfo: Requires: Base, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    _a_ = [0, "size"],
    cst_Base_quickcheck_Observer_o =
      "Base_quickcheck.Observer.observe: size < 0";
   function create(f){return f;}
   function observe(t, x, size, hash){
    if(0 <= size) return caml_call3(t, x, size, hash);
    var
     _c_ = [0, [1, [0, _a_, [0, caml_call1(Base[136], size), 0]]], 0],
     _d_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Observer_o),
         _c_]];
    return caml_call1(Base[246], _d_);
   }
   function opaque(param, _b_, hash){return hash;}
   var Base_quickcheck_Observer0 = [0, opaque, create, observe];
   runtime.caml_register_global
    (4, Base_quickcheck_Observer0, "Base_quickcheck__Observer0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Generator
//# unitInfo: Requires: Base, Base__Applicative, Base__Array, Base__Bytes, Base__Char, Base__Either, Base__Error, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__Lazy, Base__List, Base__Map, Base__Monad, Base__Nativeint, Base__Option, Base__Sequence, Base__Set, Base__Staged, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Observer0, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lower_bound = "lower_bound",
    cst_src_generator_ml = "src/generator.ml",
    cst_upper_bound = "upper_bound",
    cst_weight = "weight",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_div = runtime.caml_int64_div,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_mul = runtime.caml_mul,
    caml_notequal = runtime.caml_notequal,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_Array = global_data.Base__Array,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Set = global_data.Base__Set,
    Base_List = global_data.Base__List,
    Base_String = global_data.Base__String,
    Base_Float = global_data.Base__Float,
    Splittable_random = global_data.Splittable_random,
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Int63 = global_data.Base__Int63,
    Stdlib = global_data.Stdlib,
    Base_Char = global_data.Base__Char,
    Base_Lazy = global_data.Base__Lazy,
    Base_Int = global_data.Base__Int,
    Base_Either = global_data.Base__Either,
    Base_Option = global_data.Base__Option,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Error = global_data.Base__Error,
    Base_Hash = global_data.Base__Hash,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Staged = global_data.Base__Staged,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Bytes = global_data.Base__Bytes,
    _aG_ = [0, 0, 0],
    _ax_ = [0, cst_upper_bound],
    _ay_ = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_re =
      "Float.uniform_exclusive: requested range is empty",
    _av_ = [0, cst_upper_bound],
    _aw_ = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_bo =
      "Float.uniform_exclusive: bounds are not finite",
    _j_ = [0, "p"],
    cst_geometric_distribution_p_m =
      "geometric distribution: p must be between 0 and 1",
    _h_ = [0, 0],
    _g_ = [0, 1],
    _f_ = [0, cst_src_generator_ml, 198, 4],
    _e_ = [0, cst_src_generator_ml, 225, 6],
    cst_Base_quickcheck_Generator_$5 =
      "Base_quickcheck.Generator.weighted_recursive_union: lists must be non-empty",
    _d_ = [0, cst_src_generator_ml, 160, 14],
    cst_Base_quickcheck_Generator_$4 =
      "Base_quickcheck.Generator.of_weighted_list: total weight is zero",
    _c_ = [0, cst_weight],
    cst_Base_quickcheck_Generator_$3 =
      "Base_quickcheck.Generator.of_weighted_list: weight is negative",
    _b_ = [0, cst_weight],
    cst_Base_quickcheck_Generator_$2 =
      "Base_quickcheck.Generator.of_weighted_list: weight is not finite",
    cst_Base_quickcheck_Generator_$1 =
      "Base_quickcheck.Generator.of_weighted_list: empty list",
    cst_Base_quickcheck_Generator_$0 =
      "Base_quickcheck.Generator.of_list: empty list",
    _a_ = [0, "size"],
    cst_Base_quickcheck_Generator_ =
      "Base_quickcheck.Generator.generate: size < 0";
   function create(f){return caml_call1(Base_Staged[1], f);}
   function generate(t, size, random){
    if(0 <= size) return caml_call3(Base_Staged[2], t, size, random);
    var
     _ek_ = [0, [1, [0, _a_, [0, caml_call1(Base[136], size), 0]]], 0],
     _el_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_),
         _ek_]];
    return caml_call1(Base[246], _el_);
   }
   var size = create(function(size, param){return size;});
   function fn(dom, rng){
    return create
            (function(size, random){
              var random$0 = caml_call1(Splittable_random[5], random);
              return function(x){
               var
                _ei_ = caml_call1(Base_Hash[7], 0),
                hash =
                  caml_call4(Base_quickcheck_Observer0[3], dom, x, size, _ei_),
                random = caml_call1(Splittable_random[4], random$0),
                _ej_ = caml_call1(Base_Hash[9], hash);
               caml_call2(Splittable_random[3], random, _ej_);
               return generate(rng, size, random);};
             });
   }
   function with_size(t, size){
    return create(function(param, random){return generate(t, size, random);});
   }
   function perturb(t, salt){
    return create
            (function(size, random){
              caml_call2(Splittable_random[3], random, salt);
              return generate(t, size, random);
             });
   }
   function filter_map(t, f){
    function loop(size, random){
     var size$0 = size;
     for(;;){
      var x = generate(t, size$0, random), match = caml_call1(f, x);
      if(match){var y = match[1]; return y;}
      var size$1 = size$0 + 1 | 0, size$0 = size$1;
     }
    }
    return create(loop);
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function return$0(x){return create(function(param, _eh_){return x;});}
   function map(t, f){
    return create
            (function(size, random){
              return caml_call1(f, generate(t, size, random));
             });
   }
   function apply(tf, tx){
    return create
            (function(size, random){
              var
               f = generate(tf, size, random),
               x = generate(tx, size, random);
              return caml_call1(f, x);
             });
   }
   function bind(t, f){
    return create
            (function(size, random){
              var x = generate(t, size, random);
              return generate(caml_call1(f, x), size, random);
             });
   }
   function all(list){
    return create
            (function(size, random){
              function _ef_(_eg_){return generate(_eg_, size, random);}
              return caml_call2(Base_List[53], list, _ef_);
             });
   }
   function all_unit(list){
    return create
            (function(size, random){
              function _ed_(_ee_){return generate(_ee_, size, random);}
              return caml_call2(Base_List[19], list, _ed_);
             });
   }
   var
    map$0 = [0, -198771759, map],
    For_applicative =
      caml_call1(Base_Applicative[7], [0, return$0, apply, map$0]),
    both = For_applicative[3],
    map2 = For_applicative[9],
    map3 = For_applicative[10],
    include = For_applicative[13],
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    map$1 = [0, -198771759, map],
    For_monad = caml_call1(Base_Monad[1], [0, bind, return$0, map$1]),
    ignore_m = For_monad[8],
    join = For_monad[7],
    include$0 = For_monad[3],
    symbol_bind = include$0[1],
    symbol_map = include$0[2];
   function of_list(list){
    if(caml_call1(Base_List[18], list)){
     var
      _ec_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$0);
     caml_call1(Base_Error[32], _ec_);
    }
    var
     array = caml_call1(Base_Array[9], list),
     hi = array.length - 1 - 1 | 0,
     lo = 0;
    return create
            (function(param, random){
              var index = caml_call3(Splittable_random[8], random, lo, hi);
              return caml_check_bound(array, index)[1 + index];
             });
   }
   function union(list){return caml_call1(join, of_list(list));}
   function of_weighted_list(alist){
    if(caml_call1(Base_List[18], alist)){
     var
      _d6_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$1);
     caml_call1(Base_Error[32], _d6_);
    }
    var
     match = caml_call1(Base_List[107], alist),
     values = match[2],
     weights = match[1],
     value_array = caml_call1(Base_Array[9], values);
    function _d7_(param){return 0.;}
    var array = caml_call2(Base_Array[41], value_array.length - 1, _d7_);
    function _d8_(index, acc, weight){
     if(1 - caml_call1(Base_Float[80], weight)){
      var
       _d__ = [0, [1, [0, _b_, [0, caml_call1(Base[126], weight), 0]]], 0],
       _d$_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$2),
           _d__]];
      caml_call1(Base_Error[32], _d$_);
     }
     if(weight < 0.){
      var
       _ea_ = [0, [1, [0, _c_, [0, caml_call1(Base[126], weight), 0]]], 0],
       _eb_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$3),
           _ea_]];
      caml_call1(Base_Error[32], _eb_);
     }
     var cumulative = caml_call2(Base[234], acc, weight);
     runtime.caml_array_set(array, index, cumulative);
     return cumulative;
    }
    var sum = caml_call3(Base_List[33], weights, 0., _d8_);
    if(sum <= 0.){
     var
      _d9_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$4);
     caml_call1(Base_Error[32], _d9_);
    }
    return create
            (function(param, random){
              var
               choice = caml_call3(Splittable_random[13], random, 0., sum),
               match =
                 caml_call6
                  (Base_Array[7],
                   0,
                   0,
                   array,
                   runtime.caml_float_compare,
                   926943384,
                   choice);
              if(! match)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
              var index = match[1];
              return caml_check_bound(value_array, index)[1 + index];
             });
   }
   function weighted_union(alist){
    return caml_call1(join, of_weighted_list(alist));
   }
   function of_lazy(lazy_t){
    return create
            (function(size, random){
              var _d4_ = caml_obj_tag(lazy_t);
              a:
              if(250 === _d4_)
               var _d5_ = lazy_t[1];
              else{
               if(246 !== _d4_ && 244 !== _d4_){var _d5_ = lazy_t; break a;}
               var _d5_ = caml_call1(CamlinternalLazy[2], lazy_t);
              }
              return generate(_d5_, size, random);
             });
   }
   function fixed_point(of_generator){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246,
       function(param){return caml_call1(of_generator, of_lazy(lazy_t));}]);
    var _d3_ = caml_obj_tag(lazy_t);
    if(250 === _d3_) return lazy_t[1];
    if(246 !== _d3_ && 244 !== _d3_) return lazy_t;
    return caml_call1(CamlinternalLazy[2], lazy_t);
   }
   function weighted_recursive_union(nonrec_list, f){
    return fixed_point
            (function(self){
              function _dW_(param){
               var t = param[2], w = param[1];
               function _d2_(n){return with_size(t, n - 1 | 0);}
               return [0, w, caml_call2(For_monad[11][4][2], size, _d2_)];
              }
              var
               _dX_ = caml_call1(f, self),
               rec_list = caml_call2(Base_List[53], _dX_, _dW_),
               _dY_ = caml_call1(Base_List[18], nonrec_list),
               _dZ_ = _dY_ || caml_call1(Base_List[18], rec_list);
              if(_dZ_){
               var
                _d0_ =
                  caml_call1
                   (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$5);
               caml_call1(Base[246], _d0_);
              }
              var
               nonrec_gen = weighted_union(nonrec_list),
               rec_gen =
                 weighted_union(caml_call2(Base[222], nonrec_list, rec_list));
              function _d1_(param){return 0 === param ? nonrec_gen : rec_gen;}
              return caml_call2(For_monad[11][4][2], size, _d1_);
             });
   }
   function recursive_union(nonrec_list, f){
    function weighted(list){
     function _dV_(t){return [0, 1., t];}
     return caml_call2(Base_List[53], list, _dV_);
    }
    function _dU_(self){return weighted(caml_call1(f, self));}
    return weighted_recursive_union(weighted(nonrec_list), _dU_);
   }
   function sizes(opt, _dH_, param){
    if(opt) var sth = opt[1], min_length = sth; else var min_length = 0;
    if(_dH_)
     var sth$0 = _dH_[1], max_length = sth$0;
    else
     var max_length = Base_Int[65];
    return create
            (function(size, random){
              if(min_length > max_length)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
              var
               upper_bound = min_length + size | 0,
               max_length$0 =
                 min_length <= upper_bound
                  ? caml_call2(Base[233], max_length, upper_bound)
                  : max_length,
               len =
                 caml_call3
                  (Splittable_random[15][1], random, min_length, max_length$0);
              if(0 === len) return 0;
              function _dI_(param){return 0;}
              var
               sizes = caml_call2(Base_Array[41], len, _dI_),
               remaining = size - (len - min_length | 0) | 0,
               max_index = len - 1 | 0,
               _dJ_ = 1;
              if(remaining >= 1){
               var for$0 = _dJ_;
               for(;;){
                var
                 index =
                   caml_call3(Splittable_random[15][1], random, 0, max_index);
                sizes[1 + index] =
                 caml_check_bound(sizes, index)[1 + index] + 1 | 0;
                var _dQ_ = for$0 + 1 | 0;
                if(remaining === for$0) break;
                var for$0 = _dQ_;
               }
              }
              var _dL_ = max_index - 1 | 0, _dK_ = 0;
              if(_dL_ >= 0){
               var i = _dK_;
               for(;;){
                var
                 j = caml_call3(Splittable_random[8], random, i, max_index);
                caml_call3(Base_Array[81], sizes, i, j);
                var _dP_ = i + 1 | 0;
                if(_dL_ === i) break;
                var i = _dP_;
               }
              }
              var _dM_ = len - min_length | 0;
              function _dN_(_dT_){return _dT_;}
              function _dO_(_dS_, _dR_){return _dS_ + _dR_ | 0;}
              if
               ((caml_call3
                 (Base_Array[27], [0, Base_Int[79], _dO_], sizes, _dN_)
                + _dM_
                | 0)
                === size)
               return caml_call1(Base_Array[30], sizes);
              throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
             });
   }
   var
    unit = caml_call1(For_monad[11][1], 0),
    bool =
      create
       (function(param, random){
         return caml_call1(Splittable_random[7], random);
        });
   function option(value_t){
    var _dG_ = [0, map(value_t, Base_Option[23]), 0];
    return union([0, caml_call1(For_monad[11][1], 0), _dG_]);
   }
   function either(fst_t, snd_t){
    var _dF_ = [0, map(snd_t, Base_Either[20]), 0];
    return union([0, map(fst_t, Base_Either[19]), _dF_]);
   }
   function result(ok_t, err_t){
    function _dE_(param){
     if(0 === param[0]){var ok = param[1]; return [0, ok];}
     var err = param[1];
     return [1, err];
    }
    return map(either(ok_t, err_t), _dE_);
   }
   function list_generic(min_length, max_length, elt_gen){
    function _dB_(sizes){
     function _dD_(size){return with_size(elt_gen, size);}
     return all(caml_call2(Base_List[53], sizes, _dD_));
    }
    var _dC_ = sizes(min_length, max_length, 0);
    return caml_call2(For_monad[11][4][2], _dC_, _dB_);
   }
   function list(elt_gen){return list_generic(0, 0, elt_gen);}
   function list_non_empty(elt_gen){return list_generic(_g_, 0, elt_gen);}
   function list_with_length(elt_gen, length){
    return list_generic([0, length], [0, length], elt_gen);
   }
   function list_filtered(elts){
    var
     elts$0 = caml_call1(Base_Array[9], elts),
     length_of_input = elts$0.length - 1;
    return create
            (function(param, random){
              var
               length_of_output =
                 caml_call3(Splittable_random[8], random, 0, length_of_input);
              function _du_(_dA_){return _dA_;}
              var
               indices = caml_call2(Base_Array[41], length_of_input, _du_),
               _dw_ = length_of_output - 1 | 0,
               _dv_ = 0;
              if(_dw_ >= 0){
               var i = _dv_;
               for(;;){
                var
                 j =
                   caml_call3
                    (Splittable_random[8], random, i, length_of_input - 1 | 0);
                caml_call3(Base_Array[81], indices, i, j);
                var _dy_ = i + 1 | 0;
                if(_dw_ === i) break;
                var i = _dy_;
               }
              }
              caml_call4
               (Base_Array[66],
                _h_,
                [0, length_of_output],
                indices,
                Base_Int[14]);
              function _dx_(i){
               var _dz_ = caml_check_bound(indices, i)[1 + i];
               return caml_check_bound(elts$0, _dz_)[1 + _dz_];
              }
              return caml_call2(Base_List[40], length_of_output, _dx_);
             });
   }
   function list_permutations(list){
    return create
            (function(param, random){
              var
               array = caml_call1(Base_Array[9], list),
               _ds_ = array.length - 1 - 1 | 0,
               _dr_ = 1;
              if(_ds_ >= 1){
               var i = _dr_;
               for(;;){
                var j = caml_call3(Splittable_random[8], random, 0, i);
                caml_call3(Base_Array[81], array, i, j);
                var _dt_ = i + 1 | 0;
                if(_ds_ === i) break;
                var i = _dt_;
               }
              }
              return caml_call1(Base_Array[30], array);
             });
   }
   function array(t){var _dq_ = Base_Array[9]; return map(list(t), _dq_);}
   function ref(t){return map(t, function(_dp_){return [0, _dp_];});}
   function lazy_t(t){return map(t, Base_Lazy[24]);}
   function char_uniform_inclusive(lo, hi){
    return create
            (function(param, random){
              var
               _dm_ = caml_call1(Base_Char[32], hi),
               _dn_ = caml_call1(Base_Char[32], lo),
               _do_ = caml_call3(Splittable_random[8], random, _dn_, _dm_);
              return caml_call1(Base_Char[35], _do_);
             });
   }
   var
    char_uppercase = char_uniform_inclusive(65, 90),
    char_lowercase = char_uniform_inclusive(97, 122),
    char_digit = char_uniform_inclusive(48, 57),
    char_print_uniform = char_uniform_inclusive(32, 126),
    char_uniform = char_uniform_inclusive(Base_Char[53], Base_Char[54]),
    char_alpha = union([0, char_lowercase, [0, char_uppercase, 0]]),
    char_alphanum =
      weighted_union([0, [0, 52., char_alpha], [0, [0, 10., char_digit], 0]]),
    char_whitespace =
      of_list(caml_call2(Base_List[12], Base_Char[1], Base_Char[45])),
    char_print =
      weighted_union
       ([0, [0, 10., char_alphanum], [0, [0, 1., char_print_uniform], 0]]),
    _i_ = [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[54])], 0],
    char$0 =
      weighted_union
       ([0,
         [0, 100., char_print],
         [0,
          [0, 10., char_uniform],
          [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[53])], _i_]]]);
   function small_int(allow_zero){
    return create
            (function(size, random){
              var
               lower_bound = allow_zero ? 0 : 1,
               upper_bound = size + 1 | 0,
               weighted_low =
                 caml_call3
                  (Splittable_random[15][1],
                   random,
                   0,
                   upper_bound - lower_bound | 0),
               weighted_high = upper_bound - weighted_low | 0;
              return weighted_high;
             });
   }
   var
    small_positive_or_zero_int = small_int(1),
    small_strictly_positive_int = small_int(0);
   function For_integer(Integer){
    function geometric(lo, p){
     if(p == 1.) return caml_call1(For_monad[11][1], lo);
     if(p == 0.) return caml_call1(For_monad[11][1], Integer[88]);
     if(! (p < 0.) && ! (1. < p) && ! caml_call1(Base_Float[78], p)){
      var denominator = runtime.caml_log1p_float(caml_call1(Base[240], p));
      return create
              (function(param, random){
                var
                 uniform = caml_call1(Splittable_random[14], random),
                 exponential =
                   caml_call2(Base[237], Math.log(uniform), denominator),
                 float$0 = caml_call1(Base_Float[57], exponential);
                try{var int$0 = caml_call1(Integer[2], float$0);}
                catch(_dl_){
                 var _dk_ = caml_wrap_exception(_dl_);
                 if(_dk_[1] === Stdlib[6]) return Integer[88];
                 throw caml_maybe_attach_backtrace(_dk_, 0);
                }
                var int$1 = caml_call2(Integer[45], lo, int$0);
                return caml_call2(Integer[16], int$1, lo)
                        ? Integer[88]
                        : int$1;
               });
     }
     var
      _di_ = [0, [1, [0, _j_, [0, caml_call1(Base[126], p), 0]]], 0],
      _dj_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_geometric_distribution_p_m),
          _di_]];
     return caml_call1(Base[246], _dj_);
    }
    function uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[100], random, lo, hi);
              });
    }
    function log_uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[101], random, lo, hi);
              });
    }
    function non_uniform(f, lo, hi){
     var
      _dg_ = [0, [0, 0.9, caml_call2(f, lo, hi)], 0],
      _dh_ = [0, [0, 0.05, caml_call1(For_monad[11][1], hi)], _dg_];
     return weighted_union
             ([0, [0, 0.05, caml_call1(For_monad[11][1], lo)], _dh_]);
    }
    function inclusive(_de_, _df_){
     return non_uniform(uniform_inclusive, _de_, _df_);
    }
    function log_inclusive(_dc_, _dd_){
     return non_uniform(log_uniform_inclusive, _dc_, _dd_);
    }
    var
     uniform_all = uniform_inclusive(Integer[89], Integer[88]),
     let_syntax_004 = log_inclusive(Integer[42], Integer[88]);
    function _da_(param){
     var magnitude = param[2], negative = param[1];
     return negative ? caml_call1(Integer[74], magnitude) : magnitude;
    }
    var
     _db_ = caml_call2(For_monad[11][4][4], bool, let_syntax_004),
     all = caml_call2(For_monad[11][4][3], _db_, _da_);
    return [0,
            geometric,
            uniform_inclusive,
            log_uniform_inclusive,
            ,
            inclusive,
            log_inclusive,
            uniform_all,
            all];
   }
   var
    t_sexp_grammar = Base_Int[2],
    of_float = Base_Int[3],
    to_float = Base_Int[4],
    of_int_exn = Base_Int[5],
    to_int_exn = Base_Int[6],
    hash_fold_t = Base_Int[7],
    hash = Base_Int[8],
    t_of_sexp = Base_Int[9],
    sexp_of_t = Base_Int[10],
    of_string = Base_Int[11],
    to_string = Base_Int[12],
    equal = Base_Int[13],
    compare = Base_Int[14],
    min = Base_Int[15],
    max = Base_Int[16],
    ascending = Base_Int[17],
    descending = Base_Int[18],
    between = Base_Int[19],
    clamp_exn = Base_Int[20],
    clamp = Base_Int[21],
    comparator = Base_Int[22],
    pp = Base_Int[23],
    hashable = Base_Int[24],
    is_positive = Base_Int[25],
    is_non_negative = Base_Int[26],
    is_negative = Base_Int[27],
    is_non_positive = Base_Int[28],
    sign = Base_Int[29],
    compare_local = Base_Int[30],
    equal_local = Base_Int[31],
    invariant = Base_Int[32],
    Hex = Base_Int[33],
    Binary = Base_Int[34],
    of_string_opt = Base_Int[35],
    to_string_hum = Base_Int[36],
    one = Base_Int[37],
    minus_one = Base_Int[38],
    rem = Base_Int[39],
    round = Base_Int[40],
    round_towards_zero = Base_Int[41],
    round_down = Base_Int[42],
    round_up = Base_Int[43],
    round_nearest = Base_Int[44],
    succ = Base_Int[45],
    pred = Base_Int[46],
    pow = Base_Int[47],
    bit_and = Base_Int[48],
    bit_or = Base_Int[49],
    bit_xor = Base_Int[50],
    bit_not = Base_Int[51],
    popcount = Base_Int[52],
    shift_left = Base_Int[53],
    shift_right = Base_Int[54],
    decr = Base_Int[55],
    incr = Base_Int[56],
    of_int32_exn = Base_Int[57],
    to_int32_exn = Base_Int[58],
    of_int64_exn = Base_Int[59],
    to_int64 = Base_Int[60],
    of_nativeint_exn = Base_Int[61],
    to_nativeint_exn = Base_Int[62],
    of_float_unchecked = Base_Int[63],
    num_bits = Base_Int[64],
    max_value = Base_Int[65],
    min_value = Base_Int[66],
    shift_right_logical = Base_Int[67],
    ceil_pow2 = Base_Int[68],
    floor_pow2 = Base_Int[69],
    ceil_log2 = Base_Int[70],
    floor_log2 = Base_Int[71],
    is_pow2 = Base_Int[72],
    clz = Base_Int[73],
    ctz = Base_Int[74],
    O = Base_Int[75],
    symbol$2 = Base_Int[76],
    lnot = Base_Int[77],
    abs = Base_Int[78],
    zero = Base_Int[79],
    symbol$3 = Base_Int[80],
    symbol$4 = Base_Int[81],
    symbol$5 = Base_Int[82],
    uniform = Splittable_random[8],
    log_uniform = Splittable_random[15][1];
   function _k_(_c$_, _c__){return _c$_ >>> _c__ | 0;}
   function _l_(_c9_, _c8_){return _c9_ >> _c8_;}
   function _m_(_c7_, _c6_){return _c7_ << _c6_;}
   var _n_ = O[2];
   function _o_(_c5_, _c4_){return _c5_ ^ _c4_;}
   function _p_(_c3_, _c2_){return _c3_ | _c2_;}
   function _q_(_c1_, _c0_){return _c1_ & _c0_;}
   var _r_ = O[7], _s_ = O[6], _t_ = O[5], _u_ = O[4];
   function _v_(_cZ_){return - _cZ_ | 0;}
   var _w_ = O[3];
   function _x_(_cY_, _cX_){return _cY_ !== _cX_ ? 1 : 0;}
   function _y_(_cW_, _cV_){return _cW_ < _cV_ ? 1 : 0;}
   function _z_(_cU_, _cT_){return _cT_ < _cU_ ? 1 : 0;}
   function _A_(_cS_, _cR_){return _cS_ === _cR_ ? 1 : 0;}
   function _B_(_cQ_, _cP_){return _cQ_ <= _cP_ ? 1 : 0;}
   function _C_(_cO_, _cN_){return _cN_ <= _cO_ ? 1 : 0;}
   var _D_ = O[1];
   function _E_(_cM_){return - _cM_ | 0;}
   var _F_ = caml_div, _G_ = caml_mul;
   function _H_(_cL_, _cK_){return _cL_ - _cK_ | 0;}
   var
    _I_ =
      [0,
       function(_cJ_, _cI_){return _cJ_ + _cI_ | 0;},
       _H_,
       _G_,
       _F_,
       _E_,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_,
       _v_,
       _u_,
       _t_,
       _s_,
       _r_,
       _q_,
       _p_,
       _o_,
       _n_,
       _m_,
       _l_,
       _k_];
   function _J_(_cH_, _cG_){return _cH_ >>> _cG_ | 0;}
   function _K_(_cF_, _cE_){return _cF_ >> _cE_;}
   function _L_(_cD_, _cC_){return _cD_ << _cC_;}
   function _M_(_cB_, _cA_){return _cB_ ^ _cA_;}
   function _N_(_cz_, _cy_){return _cz_ | _cy_;}
   function _O_(_cx_, _cw_){return _cx_ & _cw_;}
   var _P_ = caml_div;
   function _Q_(_cv_){return - _cv_ | 0;}
   function _R_(_cu_){return - _cu_ | 0;}
   var _S_ = caml_mul;
   function _T_(_ct_, _cs_){return _ct_ - _cs_ | 0;}
   function _U_(_cr_, _cq_){return _cr_ + _cq_ | 0;}
   function _V_(_cp_, _co_){return _cp_ !== _co_ ? 1 : 0;}
   function _W_(_cn_, _cm_){return _cn_ < _cm_ ? 1 : 0;}
   function _X_(_cl_, _ck_){return _ck_ < _cl_ ? 1 : 0;}
   function _Y_(_cj_, _ci_){return _cj_ === _ci_ ? 1 : 0;}
   function _Z_(_ch_, _cg_){return _ch_ <= _cg_ ? 1 : 0;}
   var
    For_int =
      For_integer
       ([0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(_cf_, _ce_){return _ce_ <= _cf_ ? 1 : 0;},
         _Z_,
         _Y_,
         _X_,
         _W_,
         _V_,
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         compare_local,
         equal_local,
         invariant,
         Hex,
         Binary,
         of_string_opt,
         to_string_hum,
         zero,
         one,
         minus_one,
         _U_,
         _T_,
         _S_,
         symbol$2,
         _R_,
         _Q_,
         symbol$4,
         symbol$3,
         _P_,
         rem,
         symbol$5,
         _O_,
         _N_,
         _M_,
         lnot,
         _L_,
         _K_,
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         of_float_unchecked,
         num_bits,
         max_value,
         min_value,
         _J_,
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         floor_log2,
         is_pow2,
         clz,
         ctz,
         _I_,
         uniform,
         log_uniform]),
    int$0 = For_int[8],
    int_uniform = For_int[7],
    int_inclusive = For_int[5],
    int_uniform_inclusive = For_int[2],
    int_log_inclusive = For_int[6],
    int_log_uniform_inclusive = For_int[3],
    int_geometric = For_int[1],
    t_sexp_grammar$0 = Base_Int32[2],
    of_float$0 = Base_Int32[3],
    to_float$0 = Base_Int32[4],
    of_int_exn$0 = Base_Int32[5],
    to_int_exn$0 = Base_Int32[6],
    hash_fold_t$0 = Base_Int32[7],
    hash$0 = Base_Int32[8],
    t_of_sexp$0 = Base_Int32[9],
    sexp_of_t$0 = Base_Int32[10],
    of_string$0 = Base_Int32[11],
    to_string$0 = Base_Int32[12],
    symbol$6 = Base_Int32[13],
    symbol$7 = Base_Int32[14],
    symbol$8 = Base_Int32[15],
    symbol$9 = Base_Int32[16],
    symbol$10 = Base_Int32[17],
    symbol$11 = Base_Int32[18],
    equal$0 = Base_Int32[19],
    compare$0 = Base_Int32[20],
    min$0 = Base_Int32[21],
    max$0 = Base_Int32[22],
    ascending$0 = Base_Int32[23],
    descending$0 = Base_Int32[24],
    between$0 = Base_Int32[25],
    clamp_exn$0 = Base_Int32[26],
    clamp$0 = Base_Int32[27],
    comparator$0 = Base_Int32[28],
    pp$0 = Base_Int32[29],
    hashable$0 = Base_Int32[30],
    is_positive$0 = Base_Int32[31],
    is_non_negative$0 = Base_Int32[32],
    is_negative$0 = Base_Int32[33],
    is_non_positive$0 = Base_Int32[34],
    sign$0 = Base_Int32[35],
    compare_local$0 = Base_Int32[36],
    equal_local$0 = Base_Int32[37],
    invariant$0 = Base_Int32[38],
    Hex$0 = Base_Int32[39],
    Binary$0 = Base_Int32[40],
    of_string_opt$0 = Base_Int32[41],
    to_string_hum$0 = Base_Int32[42],
    zero$0 = Base_Int32[43],
    one$0 = Base_Int32[44],
    minus_one$0 = Base_Int32[45],
    symbol$12 = Base_Int32[46],
    symbol$13 = Base_Int32[47],
    symbol$14 = Base_Int32[48],
    symbol$15 = Base_Int32[49],
    neg = Base_Int32[50],
    symbol$16 = Base_Int32[51],
    symbol$17 = Base_Int32[52],
    symbol$18 = Base_Int32[53],
    symbol$19 = Base_Int32[54],
    rem$0 = Base_Int32[55],
    symbol$20 = Base_Int32[56],
    land = Base_Int32[57],
    lor = Base_Int32[58],
    lxor = Base_Int32[59],
    lnot$0 = Base_Int32[60],
    lsl = Base_Int32[61],
    asr = Base_Int32[62],
    round$0 = Base_Int32[63],
    round_towards_zero$0 = Base_Int32[64],
    round_down$0 = Base_Int32[65],
    round_up$0 = Base_Int32[66],
    round_nearest$0 = Base_Int32[67],
    abs$0 = Base_Int32[68],
    succ$0 = Base_Int32[69],
    pred$0 = Base_Int32[70],
    pow$0 = Base_Int32[71],
    bit_and$0 = Base_Int32[72],
    bit_or$0 = Base_Int32[73],
    bit_xor$0 = Base_Int32[74],
    bit_not$0 = Base_Int32[75],
    popcount$0 = Base_Int32[76],
    shift_left$0 = Base_Int32[77],
    shift_right$0 = Base_Int32[78],
    decr$0 = Base_Int32[79],
    incr$0 = Base_Int32[80],
    of_int32_exn$0 = Base_Int32[81],
    to_int32_exn$0 = Base_Int32[82],
    of_int64_exn$0 = Base_Int32[83],
    to_int64$0 = Base_Int32[84],
    of_nativeint_exn$0 = Base_Int32[85],
    to_nativeint_exn$0 = Base_Int32[86],
    of_float_unchecked$0 = Base_Int32[87],
    num_bits$0 = Base_Int32[88],
    max_value$0 = Base_Int32[89],
    min_value$0 = Base_Int32[90],
    lsr = Base_Int32[91],
    shift_right_logical$0 = Base_Int32[92],
    ceil_pow2$0 = Base_Int32[93],
    floor_pow2$0 = Base_Int32[94],
    ceil_log2$0 = Base_Int32[95],
    floor_log2$0 = Base_Int32[96],
    is_pow2$0 = Base_Int32[97],
    clz$0 = Base_Int32[98],
    ctz$0 = Base_Int32[99],
    O$0 = Base_Int32[100],
    uniform$0 = Splittable_random[9],
    log_uniform$0 = Splittable_random[15][2],
    For_int32 =
      For_integer
       ([0,
         t_sexp_grammar$0,
         of_float$0,
         to_float$0,
         of_int_exn$0,
         to_int_exn$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$0,
         of_string$0,
         to_string$0,
         symbol$6,
         symbol$7,
         symbol$8,
         symbol$9,
         symbol$10,
         symbol$11,
         equal$0,
         compare$0,
         min$0,
         max$0,
         ascending$0,
         descending$0,
         between$0,
         clamp_exn$0,
         clamp$0,
         comparator$0,
         pp$0,
         hashable$0,
         is_positive$0,
         is_non_negative$0,
         is_negative$0,
         is_non_positive$0,
         sign$0,
         compare_local$0,
         equal_local$0,
         invariant$0,
         Hex$0,
         Binary$0,
         of_string_opt$0,
         to_string_hum$0,
         zero$0,
         one$0,
         minus_one$0,
         symbol$12,
         symbol$13,
         symbol$14,
         symbol$15,
         neg,
         symbol$16,
         symbol$17,
         symbol$18,
         symbol$19,
         rem$0,
         symbol$20,
         land,
         lor,
         lxor,
         lnot$0,
         lsl,
         asr,
         round$0,
         round_towards_zero$0,
         round_down$0,
         round_up$0,
         round_nearest$0,
         abs$0,
         succ$0,
         pred$0,
         pow$0,
         bit_and$0,
         bit_or$0,
         bit_xor$0,
         bit_not$0,
         popcount$0,
         shift_left$0,
         shift_right$0,
         decr$0,
         incr$0,
         of_int32_exn$0,
         to_int32_exn$0,
         of_int64_exn$0,
         to_int64$0,
         of_nativeint_exn$0,
         to_nativeint_exn$0,
         of_float_unchecked$0,
         num_bits$0,
         max_value$0,
         min_value$0,
         lsr,
         shift_right_logical$0,
         ceil_pow2$0,
         floor_pow2$0,
         ceil_log2$0,
         floor_log2$0,
         is_pow2$0,
         clz$0,
         ctz$0,
         O$0,
         uniform$0,
         log_uniform$0]),
    int32 = For_int32[8],
    int32_uniform = For_int32[7],
    int32_inclusive = For_int32[5],
    int32_uniform_inclusive = For_int32[2],
    int32_log_inclusive = For_int32[6],
    int32_log_uniform_inclusive = For_int32[3],
    int32_geometric = For_int32[1],
    t_sexp_grammar$1 = Base_Int63[1],
    of_float$1 = Base_Int63[2],
    to_float$1 = Base_Int63[3],
    of_int_exn$1 = Base_Int63[4],
    to_int_exn$1 = Base_Int63[5],
    hash_fold_t$1 = Base_Int63[6],
    hash$1 = Base_Int63[7],
    t_of_sexp$1 = Base_Int63[8],
    sexp_of_t$1 = Base_Int63[9],
    of_string$1 = Base_Int63[10],
    to_string$1 = Base_Int63[11],
    symbol$21 = Base_Int63[12],
    symbol$22 = Base_Int63[13],
    symbol$23 = Base_Int63[14],
    symbol$24 = Base_Int63[15],
    symbol$25 = Base_Int63[16],
    symbol$26 = Base_Int63[17],
    equal$1 = Base_Int63[18],
    compare$1 = Base_Int63[19],
    min$1 = Base_Int63[20],
    max$1 = Base_Int63[21],
    ascending$1 = Base_Int63[22],
    descending$1 = Base_Int63[23],
    between$1 = Base_Int63[24],
    clamp_exn$1 = Base_Int63[25],
    clamp$1 = Base_Int63[26],
    comparator$1 = Base_Int63[27],
    pp$1 = Base_Int63[28],
    hashable$1 = Base_Int63[29],
    is_positive$1 = Base_Int63[30],
    is_non_negative$1 = Base_Int63[31],
    is_negative$1 = Base_Int63[32],
    is_non_positive$1 = Base_Int63[33],
    sign$1 = Base_Int63[34],
    compare_local$1 = Base_Int63[35],
    equal_local$1 = Base_Int63[36],
    invariant$1 = Base_Int63[37],
    Hex$1 = Base_Int63[38],
    Binary$1 = Base_Int63[39],
    of_string_opt$1 = Base_Int63[40],
    to_string_hum$1 = Base_Int63[41],
    zero$1 = Base_Int63[42],
    one$1 = Base_Int63[43],
    minus_one$1 = Base_Int63[44],
    symbol$27 = Base_Int63[45],
    symbol$28 = Base_Int63[46],
    symbol$29 = Base_Int63[47],
    symbol$30 = Base_Int63[48],
    neg$0 = Base_Int63[49],
    symbol$31 = Base_Int63[50],
    symbol$32 = Base_Int63[51],
    symbol$33 = Base_Int63[52],
    symbol$34 = Base_Int63[53],
    rem$1 = Base_Int63[54],
    symbol$35 = Base_Int63[55],
    land$0 = Base_Int63[56],
    lor$0 = Base_Int63[57],
    lxor$0 = Base_Int63[58],
    lnot$1 = Base_Int63[59],
    lsl$0 = Base_Int63[60],
    asr$0 = Base_Int63[61],
    round$1 = Base_Int63[62],
    round_towards_zero$1 = Base_Int63[63],
    round_down$1 = Base_Int63[64],
    round_up$1 = Base_Int63[65],
    round_nearest$1 = Base_Int63[66],
    abs$1 = Base_Int63[67],
    succ$1 = Base_Int63[68],
    pred$1 = Base_Int63[69],
    pow$1 = Base_Int63[70],
    bit_and$1 = Base_Int63[71],
    bit_or$1 = Base_Int63[72],
    bit_xor$1 = Base_Int63[73],
    bit_not$1 = Base_Int63[74],
    popcount$1 = Base_Int63[75],
    shift_left$1 = Base_Int63[76],
    shift_right$1 = Base_Int63[77],
    decr$1 = Base_Int63[78],
    incr$1 = Base_Int63[79],
    of_int32_exn$1 = Base_Int63[80],
    to_int32_exn$1 = Base_Int63[81],
    of_int64_exn$1 = Base_Int63[82],
    to_int64$1 = Base_Int63[83],
    of_nativeint_exn$1 = Base_Int63[84],
    to_nativeint_exn$1 = Base_Int63[85],
    of_float_unchecked$1 = Base_Int63[86],
    num_bits$1 = Base_Int63[87],
    max_value$1 = Base_Int63[88],
    min_value$1 = Base_Int63[89],
    lsr$0 = Base_Int63[90],
    shift_right_logical$1 = Base_Int63[91],
    ceil_pow2$1 = Base_Int63[92],
    floor_pow2$1 = Base_Int63[93],
    ceil_log2$1 = Base_Int63[94],
    is_pow2$1 = Base_Int63[95],
    clz$1 = Base_Int63[96],
    ctz$1 = Base_Int63[97],
    O$1 = Base_Int63[98],
    floor_log2$1 = Base_Int63[117],
    uniform$1 = Splittable_random[10],
    log_uniform$1 = Splittable_random[15][3],
    For_int63 =
      For_integer
       ([0,
         t_sexp_grammar$1,
         of_float$1,
         to_float$1,
         of_int_exn$1,
         to_int_exn$1,
         hash_fold_t$1,
         hash$1,
         t_of_sexp$1,
         sexp_of_t$1,
         of_string$1,
         to_string$1,
         symbol$21,
         symbol$22,
         symbol$23,
         symbol$24,
         symbol$25,
         symbol$26,
         equal$1,
         compare$1,
         min$1,
         max$1,
         ascending$1,
         descending$1,
         between$1,
         clamp_exn$1,
         clamp$1,
         comparator$1,
         pp$1,
         hashable$1,
         is_positive$1,
         is_non_negative$1,
         is_negative$1,
         is_non_positive$1,
         sign$1,
         compare_local$1,
         equal_local$1,
         invariant$1,
         Hex$1,
         Binary$1,
         of_string_opt$1,
         to_string_hum$1,
         zero$1,
         one$1,
         minus_one$1,
         symbol$27,
         symbol$28,
         symbol$29,
         symbol$30,
         neg$0,
         symbol$31,
         symbol$32,
         symbol$33,
         symbol$34,
         rem$1,
         symbol$35,
         land$0,
         lor$0,
         lxor$0,
         lnot$1,
         lsl$0,
         asr$0,
         round$1,
         round_towards_zero$1,
         round_down$1,
         round_up$1,
         round_nearest$1,
         abs$1,
         succ$1,
         pred$1,
         pow$1,
         bit_and$1,
         bit_or$1,
         bit_xor$1,
         bit_not$1,
         popcount$1,
         shift_left$1,
         shift_right$1,
         decr$1,
         incr$1,
         of_int32_exn$1,
         to_int32_exn$1,
         of_int64_exn$1,
         to_int64$1,
         of_nativeint_exn$1,
         to_nativeint_exn$1,
         of_float_unchecked$1,
         num_bits$1,
         max_value$1,
         min_value$1,
         lsr$0,
         shift_right_logical$1,
         ceil_pow2$1,
         floor_pow2$1,
         ceil_log2$1,
         floor_log2$1,
         is_pow2$1,
         clz$1,
         ctz$1,
         O$1,
         uniform$1,
         log_uniform$1]),
    int63 = For_int63[8],
    int63_uniform = For_int63[7],
    int63_inclusive = For_int63[5],
    int63_uniform_inclusive = For_int63[2],
    int63_log_inclusive = For_int63[6],
    int63_log_uniform_inclusive = For_int63[3],
    int63_geometric = For_int63[1],
    t_sexp_grammar$2 = Base_Int64[2],
    of_float$2 = Base_Int64[3],
    to_float$2 = Base_Int64[4],
    of_int_exn$2 = Base_Int64[5],
    to_int_exn$2 = Base_Int64[6],
    hash_fold_t$2 = Base_Int64[7],
    hash$2 = Base_Int64[8],
    t_of_sexp$2 = Base_Int64[9],
    sexp_of_t$2 = Base_Int64[10],
    of_string$2 = Base_Int64[11],
    to_string$2 = Base_Int64[12],
    equal$2 = Base_Int64[13],
    compare$2 = Base_Int64[14],
    min$2 = Base_Int64[15],
    max$2 = Base_Int64[16],
    ascending$2 = Base_Int64[17],
    descending$2 = Base_Int64[18],
    between$2 = Base_Int64[19],
    clamp_exn$2 = Base_Int64[20],
    clamp$2 = Base_Int64[21],
    comparator$2 = Base_Int64[22],
    pp$2 = Base_Int64[23],
    hashable$2 = Base_Int64[24],
    is_positive$2 = Base_Int64[25],
    is_non_negative$2 = Base_Int64[26],
    is_negative$2 = Base_Int64[27],
    is_non_positive$2 = Base_Int64[28],
    sign$2 = Base_Int64[29],
    compare_local$2 = Base_Int64[30],
    equal_local$2 = Base_Int64[31],
    invariant$2 = Base_Int64[32],
    Hex$2 = Base_Int64[33],
    Binary$2 = Base_Int64[34],
    of_string_opt$2 = Base_Int64[35],
    to_string_hum$2 = Base_Int64[36],
    one$2 = Base_Int64[37],
    minus_one$2 = Base_Int64[38],
    rem$2 = Base_Int64[39],
    round$2 = Base_Int64[40],
    round_towards_zero$2 = Base_Int64[41],
    round_down$2 = Base_Int64[42],
    round_up$2 = Base_Int64[43],
    round_nearest$2 = Base_Int64[44],
    succ$2 = Base_Int64[45],
    pred$2 = Base_Int64[46],
    pow$2 = Base_Int64[47],
    bit_and$2 = Base_Int64[48],
    bit_or$2 = Base_Int64[49],
    bit_xor$2 = Base_Int64[50],
    bit_not$2 = Base_Int64[51],
    popcount$2 = Base_Int64[52],
    shift_left$2 = Base_Int64[53],
    shift_right$2 = Base_Int64[54],
    decr$2 = Base_Int64[55],
    incr$2 = Base_Int64[56],
    of_int32_exn$2 = Base_Int64[57],
    to_int32_exn$2 = Base_Int64[58],
    of_int64_exn$2 = Base_Int64[59],
    to_int64$2 = Base_Int64[60],
    of_nativeint_exn$2 = Base_Int64[61],
    to_nativeint_exn$2 = Base_Int64[62],
    of_float_unchecked$2 = Base_Int64[63],
    num_bits$2 = Base_Int64[64],
    max_value$2 = Base_Int64[65],
    min_value$2 = Base_Int64[66],
    shift_right_logical$2 = Base_Int64[67],
    ceil_pow2$2 = Base_Int64[68],
    floor_pow2$2 = Base_Int64[69],
    ceil_log2$2 = Base_Int64[70],
    floor_log2$2 = Base_Int64[71],
    is_pow2$2 = Base_Int64[72],
    clz$2 = Base_Int64[73],
    ctz$2 = Base_Int64[74],
    O$2 = Base_Int64[75],
    symbol$36 = Base_Int64[76],
    lnot$2 = Base_Int64[77],
    abs$2 = Base_Int64[78],
    zero$2 = Base_Int64[79],
    symbol$37 = Base_Int64[80],
    symbol$38 = Base_Int64[81],
    symbol$39 = Base_Int64[82],
    uniform$2 = Splittable_random[11],
    log_uniform$2 = Splittable_random[15][4],
    For_int64 =
      For_integer
       ([0,
         t_sexp_grammar$2,
         of_float$2,
         to_float$2,
         of_int_exn$2,
         to_int_exn$2,
         hash_fold_t$2,
         hash$2,
         t_of_sexp$2,
         sexp_of_t$2,
         of_string$2,
         to_string$2,
         caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         caml_notequal,
         equal$2,
         compare$2,
         min$2,
         max$2,
         ascending$2,
         descending$2,
         between$2,
         clamp_exn$2,
         clamp$2,
         comparator$2,
         pp$2,
         hashable$2,
         is_positive$2,
         is_non_negative$2,
         is_negative$2,
         is_non_positive$2,
         sign$2,
         compare_local$2,
         equal_local$2,
         invariant$2,
         Hex$2,
         Binary$2,
         of_string_opt$2,
         to_string_hum$2,
         zero$2,
         one$2,
         minus_one$2,
         caml_int64_add,
         caml_int64_sub,
         caml_int64_mul,
         symbol$36,
         caml_int64_neg,
         caml_int64_neg,
         symbol$38,
         symbol$37,
         caml_int64_div,
         rem$2,
         symbol$39,
         caml_int64_and,
         caml_int64_or,
         caml_int64_xor,
         lnot$2,
         caml_int64_shift_left,
         caml_int64_shift_right,
         round$2,
         round_towards_zero$2,
         round_down$2,
         round_up$2,
         round_nearest$2,
         abs$2,
         succ$2,
         pred$2,
         pow$2,
         bit_and$2,
         bit_or$2,
         bit_xor$2,
         bit_not$2,
         popcount$2,
         shift_left$2,
         shift_right$2,
         decr$2,
         incr$2,
         of_int32_exn$2,
         to_int32_exn$2,
         of_int64_exn$2,
         to_int64$2,
         of_nativeint_exn$2,
         to_nativeint_exn$2,
         of_float_unchecked$2,
         num_bits$2,
         max_value$2,
         min_value$2,
         caml_int64_shift_right_unsigne,
         shift_right_logical$2,
         ceil_pow2$2,
         floor_pow2$2,
         ceil_log2$2,
         floor_log2$2,
         is_pow2$2,
         clz$2,
         ctz$2,
         [0,
          caml_int64_add,
          caml_int64_sub,
          caml_int64_mul,
          caml_int64_div,
          caml_int64_neg,
          O$2[1],
          caml_greaterequal,
          caml_lessequal,
          caml_equal,
          caml_greaterthan,
          caml_lessthan,
          caml_notequal,
          O$2[3],
          caml_int64_neg,
          O$2[4],
          O$2[5],
          O$2[6],
          O$2[7],
          caml_int64_and,
          caml_int64_or,
          caml_int64_xor,
          O$2[2],
          caml_int64_shift_left,
          caml_int64_shift_right,
          caml_int64_shift_right_unsigne],
         uniform$2,
         log_uniform$2]),
    int64 = For_int64[8],
    int64_uniform = For_int64[7],
    int64_inclusive = For_int64[5],
    int64_uniform_inclusive = For_int64[2],
    int64_log_inclusive = For_int64[6],
    int64_log_uniform_inclusive = For_int64[3],
    int64_geometric = For_int64[1],
    t_sexp_grammar$3 = Base_Nativeint[2],
    of_float$3 = Base_Nativeint[3],
    to_float$3 = Base_Nativeint[4],
    of_int_exn$3 = Base_Nativeint[5],
    to_int_exn$3 = Base_Nativeint[6],
    hash_fold_t$3 = Base_Nativeint[7],
    hash$3 = Base_Nativeint[8],
    t_of_sexp$3 = Base_Nativeint[9],
    sexp_of_t$3 = Base_Nativeint[10],
    of_string$3 = Base_Nativeint[11],
    to_string$3 = Base_Nativeint[12],
    symbol$40 = Base_Nativeint[13],
    symbol$41 = Base_Nativeint[14],
    symbol$42 = Base_Nativeint[15],
    symbol$43 = Base_Nativeint[16],
    symbol$44 = Base_Nativeint[17],
    symbol$45 = Base_Nativeint[18],
    equal$3 = Base_Nativeint[19],
    compare$3 = Base_Nativeint[20],
    min$3 = Base_Nativeint[21],
    max$3 = Base_Nativeint[22],
    ascending$3 = Base_Nativeint[23],
    descending$3 = Base_Nativeint[24],
    between$3 = Base_Nativeint[25],
    clamp_exn$3 = Base_Nativeint[26],
    clamp$3 = Base_Nativeint[27],
    comparator$3 = Base_Nativeint[28],
    pp$3 = Base_Nativeint[29],
    hashable$3 = Base_Nativeint[30],
    is_positive$3 = Base_Nativeint[31],
    is_non_negative$3 = Base_Nativeint[32],
    is_negative$3 = Base_Nativeint[33],
    is_non_positive$3 = Base_Nativeint[34],
    sign$3 = Base_Nativeint[35],
    compare_local$3 = Base_Nativeint[36],
    equal_local$3 = Base_Nativeint[37],
    invariant$3 = Base_Nativeint[38],
    Hex$3 = Base_Nativeint[39],
    Binary$3 = Base_Nativeint[40],
    of_string_opt$3 = Base_Nativeint[41],
    to_string_hum$3 = Base_Nativeint[42],
    zero$3 = Base_Nativeint[43],
    one$3 = Base_Nativeint[44],
    minus_one$3 = Base_Nativeint[45],
    symbol$46 = Base_Nativeint[46],
    symbol$47 = Base_Nativeint[47],
    symbol$48 = Base_Nativeint[48],
    symbol$49 = Base_Nativeint[49],
    neg$1 = Base_Nativeint[50],
    symbol$50 = Base_Nativeint[51],
    symbol$51 = Base_Nativeint[52],
    symbol$52 = Base_Nativeint[53],
    symbol$53 = Base_Nativeint[54],
    rem$3 = Base_Nativeint[55],
    symbol$54 = Base_Nativeint[56],
    land$1 = Base_Nativeint[57],
    lor$1 = Base_Nativeint[58],
    lxor$1 = Base_Nativeint[59],
    lnot$3 = Base_Nativeint[60],
    lsl$1 = Base_Nativeint[61],
    asr$1 = Base_Nativeint[62],
    round$3 = Base_Nativeint[63],
    round_towards_zero$3 = Base_Nativeint[64],
    round_down$3 = Base_Nativeint[65],
    round_up$3 = Base_Nativeint[66],
    round_nearest$3 = Base_Nativeint[67],
    abs$3 = Base_Nativeint[68],
    succ$3 = Base_Nativeint[69],
    pred$3 = Base_Nativeint[70],
    pow$3 = Base_Nativeint[71],
    bit_and$3 = Base_Nativeint[72],
    bit_or$3 = Base_Nativeint[73],
    bit_xor$3 = Base_Nativeint[74],
    bit_not$3 = Base_Nativeint[75],
    popcount$3 = Base_Nativeint[76],
    shift_left$3 = Base_Nativeint[77],
    shift_right$3 = Base_Nativeint[78],
    decr$3 = Base_Nativeint[79],
    incr$3 = Base_Nativeint[80],
    of_int32_exn$3 = Base_Nativeint[81],
    to_int32_exn$3 = Base_Nativeint[82],
    of_int64_exn$3 = Base_Nativeint[83],
    to_int64$3 = Base_Nativeint[84],
    of_nativeint_exn$3 = Base_Nativeint[85],
    to_nativeint_exn$3 = Base_Nativeint[86],
    of_float_unchecked$3 = Base_Nativeint[87],
    num_bits$3 = Base_Nativeint[88],
    max_value$3 = Base_Nativeint[89],
    min_value$3 = Base_Nativeint[90],
    lsr$1 = Base_Nativeint[91],
    shift_right_logical$3 = Base_Nativeint[92],
    ceil_pow2$3 = Base_Nativeint[93],
    floor_pow2$3 = Base_Nativeint[94],
    ceil_log2$3 = Base_Nativeint[95],
    floor_log2$3 = Base_Nativeint[96],
    is_pow2$3 = Base_Nativeint[97],
    clz$3 = Base_Nativeint[98],
    ctz$3 = Base_Nativeint[99],
    O$3 = Base_Nativeint[100],
    uniform$3 = Splittable_random[12],
    log_uniform$3 = Splittable_random[15][5],
    For_nativeint =
      For_integer
       ([0,
         t_sexp_grammar$3,
         of_float$3,
         to_float$3,
         of_int_exn$3,
         to_int_exn$3,
         hash_fold_t$3,
         hash$3,
         t_of_sexp$3,
         sexp_of_t$3,
         of_string$3,
         to_string$3,
         symbol$40,
         symbol$41,
         symbol$42,
         symbol$43,
         symbol$44,
         symbol$45,
         equal$3,
         compare$3,
         min$3,
         max$3,
         ascending$3,
         descending$3,
         between$3,
         clamp_exn$3,
         clamp$3,
         comparator$3,
         pp$3,
         hashable$3,
         is_positive$3,
         is_non_negative$3,
         is_negative$3,
         is_non_positive$3,
         sign$3,
         compare_local$3,
         equal_local$3,
         invariant$3,
         Hex$3,
         Binary$3,
         of_string_opt$3,
         to_string_hum$3,
         zero$3,
         one$3,
         minus_one$3,
         symbol$46,
         symbol$47,
         symbol$48,
         symbol$49,
         neg$1,
         symbol$50,
         symbol$51,
         symbol$52,
         symbol$53,
         rem$3,
         symbol$54,
         land$1,
         lor$1,
         lxor$1,
         lnot$3,
         lsl$1,
         asr$1,
         round$3,
         round_towards_zero$3,
         round_down$3,
         round_up$3,
         round_nearest$3,
         abs$3,
         succ$3,
         pred$3,
         pow$3,
         bit_and$3,
         bit_or$3,
         bit_xor$3,
         bit_not$3,
         popcount$3,
         shift_left$3,
         shift_right$3,
         decr$3,
         incr$3,
         of_int32_exn$3,
         to_int32_exn$3,
         of_int64_exn$3,
         to_int64$3,
         of_nativeint_exn$3,
         to_nativeint_exn$3,
         of_float_unchecked$3,
         num_bits$3,
         max_value$3,
         min_value$3,
         lsr$1,
         shift_right_logical$3,
         ceil_pow2$3,
         floor_pow2$3,
         ceil_log2$3,
         floor_log2$3,
         is_pow2$3,
         clz$3,
         ctz$3,
         O$3,
         uniform$3,
         log_uniform$3]),
    nativeint = For_nativeint[8],
    nativeint_uniform = For_nativeint[7],
    nativeint_inclusive = For_nativeint[5],
    nativeint_uniform_inclusive = For_nativeint[2],
    nativeint_log_inclusive = For_nativeint[6],
    nativeint_log_uniform_inclusiv = For_nativeint[3],
    nativeint_geometric = For_nativeint[1],
    float_zero_exponent = caml_call1(Base_Float[117], 0.),
    float_zero_mantissa = caml_call1(Base_Float[118], 0.),
    float_max_positive_subnormal_v =
      caml_call2(Base_Float[47], 759637122, Base_Float[43]),
    float_subnormal_exponent = caml_call1(Base_Float[117], Base_Float[42]),
    float_min_subnormal_mantissa = caml_call1(Base_Float[118], Base_Float[42]),
    float_max_subnormal_mantissa =
      caml_call1(Base_Float[118], float_max_positive_subnormal_v),
    float_max_positive_normal_valu = Base_Float[41],
    float_min_normal_exponent = caml_call1(Base_Float[117], Base_Float[43]),
    float_max_normal_exponent =
      caml_call1(Base_Float[117], float_max_positive_normal_valu),
    float_max_normal_mantissa =
      caml_call1(Base_Float[118], float_max_positive_normal_valu),
    float_inf_exponent = caml_call1(Base_Float[117], Base_Float[29]),
    float_inf_mantissa = caml_call1(Base_Float[118], Base_Float[29]),
    float_nan_exponent = caml_call1(Base_Float[117], Base_Float[28]),
    float_min_nan_mantissa = caml_call1(Base_Int63[68], float_inf_mantissa),
    float_num_mantissa_bits = 52;
   function ___(num_bits){
    function _ca_(bits){
     return caml_call2(Base_Int63[76], bits, 52 - num_bits | 0);
    }
    var
     _cb_ = caml_call2(Base_Int63[76], Base_Int63[43], num_bits),
     _cc_ = caml_call1(Base_Int63[69], _cb_),
     _cd_ = For_int63[5].call(null, Base_Int63[42], _cc_);
    return caml_call2(For_monad[11][4][3], _cd_, _ca_);
   }
   var
    _$_ = For_int[2].call(null, 0, float_num_mantissa_bits),
    float_normal_mantissa = caml_call2(For_monad[11][4][2], _$_, ___),
    lower_bound = caml_call1(Base_Float[117], 1.),
    _ae_ = 0;
   function _aa_(offset){return lower_bound + offset | 0;}
   var
    _ab_ =
      For_int[6].call(null, 0, float_max_normal_exponent - lower_bound | 0),
    _af_ = [0, caml_call2(For_monad[11][4][3], _ab_, _aa_), _ae_];
   function _ac_(offset){return lower_bound - offset | 0;}
   var
    _ad_ =
      For_int[6].call(null, 0, lower_bound - float_min_normal_exponent | 0),
    float_exponent =
      union([0, caml_call2(For_monad[11][4][3], _ad_, _ac_), _af_]);
   function _ag_(negative){
    return caml_call3
            (Base_Float[115],
             negative,
             float_zero_exponent,
             float_zero_mantissa);
   }
   var
    float_zero = caml_call2(For_monad[11][4][3], bool, _ag_),
    let_syntax_012 = caml_call1(For_monad[11][1], float_subnormal_exponent),
    let_syntax_013 =
      For_int63[6].call
       (null, float_min_subnormal_mantissa, float_max_subnormal_mantissa);
   function _ah_(param){
    var
     match = param[2],
     mantissa = match[2],
     exponent = match[1],
     negative = param[1];
    return caml_call3(Base_Float[115], negative, exponent, mantissa);
   }
   var
    _ai_ = caml_call2(For_monad[11][4][4], let_syntax_012, let_syntax_013),
    _aj_ = caml_call2(For_monad[11][4][4], bool, _ai_),
    float_subnormal = caml_call2(For_monad[11][4][3], _aj_, _ah_);
   function _ak_(param){
    var
     match = param[2],
     mantissa = match[2],
     exponent = match[1],
     negative = param[1];
    return caml_call3(Base_Float[115], negative, exponent, mantissa);
   }
   var
    _al_ =
      caml_call2(For_monad[11][4][4], float_exponent, float_normal_mantissa),
    _am_ = caml_call2(For_monad[11][4][4], bool, _al_),
    float_normal = caml_call2(For_monad[11][4][3], _am_, _ak_);
   function _an_(negative){
    return caml_call3
            (Base_Float[115],
             negative,
             float_inf_exponent,
             float_inf_mantissa);
   }
   var
    float_infinite = caml_call2(For_monad[11][4][3], bool, _an_),
    let_syntax_021 = caml_call1(For_monad[11][1], float_nan_exponent),
    let_syntax_022 =
      For_int63[5].call
       (null, float_min_nan_mantissa, float_max_normal_mantissa);
   function _ao_(param){
    var
     match = param[2],
     mantissa = match[2],
     exponent = match[1],
     negative = param[1];
    return caml_call3(Base_Float[115], negative, exponent, mantissa);
   }
   var
    _ap_ = caml_call2(For_monad[11][4][4], let_syntax_021, let_syntax_022),
    _aq_ = caml_call2(For_monad[11][4][4], bool, _ap_),
    float_nan = caml_call2(For_monad[11][4][3], _aq_, _ao_);
   function float_of_class(c){
    switch(c){
      case 0:
       return float_infinite;
      case 1:
       return float_nan;
      case 2:
       return float_normal;
      case 3:
       return float_subnormal;
      default: return float_zero;
    }
   }
   function float_matching_classes(filter){
    function _b9_(c){
     if(! caml_call1(filter, c)) return 0;
     var _b__ = float_of_class(c);
     switch(c){
       case 0:
        var _b$_ = 1.; break;
       case 1:
        var _b$_ = 1.; break;
       case 2:
        var _b$_ = 100.; break;
       case 3:
        var _b$_ = 10.; break;
       default: var _b$_ = 1.;
     }
     return [0, [0, _b$_, _b__]];
    }
    return weighted_union(caml_call2(Base_List[13], Base_Float[109][3], _b9_));
   }
   var
    float_finite =
      float_matching_classes(function(param){return 2 <= param ? 1 : 0;}),
    float_without_nan =
      float_matching_classes(function(param){return 1 === param ? 0 : 1;}),
    float$0 = float_matching_classes(function(param){return 1;}),
    float_finite_non_zero =
      float_matching_classes
       (function(param){return 1 < param - 2 >>> 0 ? 0 : 1;});
   function _ar_(t){return caml_call1(Base_Float[98], t);}
   var
    float_strictly_positive =
      caml_call2(For_monad[11][4][3], float_finite_non_zero, _ar_);
   function _as_(t){
    var _b8_ = caml_call1(Base_Float[98], t);
    return caml_call1(Base[240], _b8_);
   }
   var
    float_strictly_negative =
      caml_call2(For_monad[11][4][3], float_finite_non_zero, _as_);
   function _at_(t){return caml_call1(Base_Float[98], t);}
   var
    float_positive_or_zero =
      caml_call2(For_monad[11][4][3], float_finite, _at_);
   function _au_(t){
    var _b7_ = caml_call1(Base_Float[98], t);
    return caml_call1(Base[240], _b7_);
   }
   var
    float_negative_or_zero =
      caml_call2(For_monad[11][4][3], float_finite, _au_);
   function float_uniform_exclusive(lower_bound, upper_bound){
    var
     _bZ_ = 1 - caml_call1(Base_Float[80], lower_bound),
     _b0_ = _bZ_ || 1 - caml_call1(Base_Float[80], upper_bound);
    if(_b0_){
     var
      _b1_ =
        [0, [1, [0, _av_, [0, caml_call1(Base[126], upper_bound), 0]]], 0],
      _b2_ =
        [0, [1, [0, _aw_, [0, caml_call1(Base[126], lower_bound), 0]]], _b1_],
      _b3_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Float_uniform_exclusive_bo),
          _b2_]];
     caml_call1(Base[246], _b3_);
    }
    var
     lower_inclusive = caml_call2(Base_Float[47], 19067, lower_bound),
     upper_inclusive = caml_call2(Base_Float[47], 759637122, upper_bound);
    if(caml_call2(Base_Float[99][11], lower_inclusive, upper_inclusive)){
     var
      _b4_ =
        [0, [1, [0, _ax_, [0, caml_call1(Base[126], upper_bound), 0]]], 0],
      _b5_ =
        [0, [1, [0, _ay_, [0, caml_call1(Base[126], lower_bound), 0]]], _b4_],
      _b6_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Float_uniform_exclusive_re),
          _b5_]];
     caml_call1(Base[246], _b6_);
    }
    return create
            (function(param, random){
              return caml_call3
                      (Splittable_random[13],
                       random,
                       lower_inclusive,
                       upper_inclusive);
             });
   }
   function float_inclusive(lower_bound, upper_bound){
    if(lower_bound == upper_bound)
     return caml_call1(For_monad[11][1], lower_bound);
    if(caml_call2(Base_Float[47], 19067, lower_bound) == upper_bound){
     var _bW_ = [0, caml_call1(For_monad[11][1], upper_bound), 0];
     return union([0, caml_call1(For_monad[11][1], lower_bound), _bW_]);
    }
    var
     _bX_ =
       [0, [0, 0.9, float_uniform_exclusive(lower_bound, upper_bound)], 0],
     _bY_ = [0, [0, 0.05, caml_call1(For_monad[11][1], upper_bound)], _bX_];
    return weighted_union
            ([0, [0, 0.05, caml_call1(For_monad[11][1], lower_bound)], _bY_]);
   }
   function string_with_length_of(char_gen, length){
    var _bV_ = list_with_length(char_gen, length);
    return map(_bV_, Base_String[137]);
   }
   function string_of(char_gen){
    return bind
            (small_positive_or_zero_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   function string_non_empty_of(char_gen){
    return bind
            (small_strictly_positive_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   var
    string = string_of(char$0),
    string_non_empty = string_non_empty_of(char$0);
   function string_with_length(length){
    return string_with_length_of(char$0, length);
   }
   function edit_insert(string){
    function _bM_(pos){
     function _bO_(len){
      function _bQ_(str){
       var
        _bS_ = [0, str, [0, caml_call2(Base_String[123], string, pos), 0]],
        _bT_ = [0, caml_call2(Base_String[121], string, pos), _bS_],
        _bU_ = caml_call2(Base_String[68], 0, _bT_);
       return caml_call1(For_monad[11][1], _bU_);
      }
      var _bR_ = string_with_length(len);
      return caml_call2(For_monad[11][4][2], _bR_, _bQ_);
     }
     var _bP_ = int_geometric(1, 0.5);
     return caml_call2(For_monad[11][4][2], _bP_, _bO_);
    }
    var _bN_ = int_uniform_inclusive(0, caml_ml_string_length(string));
    return caml_call2(For_monad[11][4][2], _bN_, _bM_);
   }
   function edit(string, n_times){
    if(0 >= n_times) return caml_call1(For_monad[11][1], string);
    function _bt_(string){return edit(string, n_times - 1 | 0);}
    if(caml_call1(Base_String[14], string))
     var _bu_ = edit_insert(string);
    else
     var
      _bp_ = 0,
      _bn_ =
        function(len){
         function _bH_(pos){
          var
           _bJ_ = [0, caml_call2(Base_String[123], string, pos), 0],
           _bK_ =
             [0, caml_call2(Base_String[121], string, pos + len | 0), _bJ_],
           _bL_ = caml_call2(Base_String[68], 0, _bK_);
          return caml_call1(For_monad[11][1], _bL_);
         }
         var
          _bI_ =
            int_uniform_inclusive(0, caml_ml_string_length(string) - len | 0);
         return caml_call2(For_monad[11][4][2], _bI_, _bH_);
        },
      _bo_ = int_log_uniform_inclusive(1, caml_ml_string_length(string)),
      _bq_ = [0, caml_call2(For_monad[11][4][2], _bo_, _bn_), _bp_],
      _bl_ =
        function(len){
         function _bA_(pos){
          function _bC_(str){
           var
            _bE_ =
              [0,
               str,
               [0, caml_call2(Base_String[123], string, pos + len | 0), 0]],
            _bF_ = [0, caml_call2(Base_String[121], string, pos), _bE_],
            _bG_ = caml_call2(Base_String[68], 0, _bF_);
           return caml_call1(For_monad[11][1], _bG_);
          }
          var _bD_ = string_with_length(len);
          return caml_call2(For_monad[11][4][2], _bD_, _bC_);
         }
         var
          _bB_ =
            int_uniform_inclusive(0, caml_ml_string_length(string) - len | 0);
         return caml_call2(For_monad[11][4][2], _bB_, _bA_);
        },
      _bm_ = int_log_uniform_inclusive(1, caml_ml_string_length(string)),
      _br_ = [0, caml_call2(For_monad[11][4][2], _bm_, _bl_), _bq_],
      _bj_ =
        function(len){
         function _bv_(pos){
          var
           _bx_ = [0, caml_call2(Base_String[123], string, pos + len | 0), 0],
           _by_ = [0, caml_call2(Base_String[121], string, pos), _bx_],
           _bz_ = caml_call2(Base_String[68], 0, _by_);
          return caml_call1(For_monad[11][1], _bz_);
         }
         var
          _bw_ =
            int_uniform_inclusive(0, caml_ml_string_length(string) - len | 0);
         return caml_call2(For_monad[11][4][2], _bw_, _bv_);
        },
      _bk_ = int_log_uniform_inclusive(1, caml_ml_string_length(string)),
      _bs_ = [0, caml_call2(For_monad[11][4][2], _bk_, _bj_), _br_],
      _bu_ = union([0, edit_insert(string), _bs_]);
    return caml_call2(For_monad[11][4][2], _bu_, _bt_);
   }
   function string_like(string){
    function _bh_(n_times){return edit(string, n_times);}
    var _bi_ = int_geometric(0, 0.5);
    return caml_call2(For_monad[11][4][2], _bi_, _bh_);
   }
   var bytes = map(string, Base_Bytes[28]);
   function sexp_of(atom){
    return fixed_point
            (function(self){
              function _bb_(size){
               function _bc_(param){
                if(0 === param){
                 var _be_ = function(atom){return [0, atom];};
                 return caml_call2(For_monad[11][4][3], atom, _be_);
                }
                function _bf_(list){return [1, list];}
                var _bg_ = list(self);
                return caml_call2(For_monad[11][4][3], _bg_, _bf_);
               }
               var _bd_ = For_int[3].call(null, 0, size + 1 | 0);
               return caml_call2(For_monad[11][4][2], _bd_, _bc_);
              }
              return caml_call2(For_monad[11][4][2], size, _bb_);
             });
   }
   var sexp = sexp_of(string);
   function map_tree_using_comparator(comparator, key_gen, data_gen){
    function _a7_(keys){
     var keys$0 = caml_call2(Base_List[126], keys, comparator[1]);
     function _a9_(data){
      var
       _a$_ = caml_call2(Base_List[110], keys$0, data),
       _ba_ = caml_call2(Base_Map[118][3][13], comparator, _a$_);
      return caml_call1(For_monad[11][1], _ba_);
     }
     var _a__ = list_with_length(data_gen, caml_call1(Base_List[45], keys$0));
     return caml_call2(For_monad[11][4][2], _a__, _a9_);
    }
    var _a8_ = list(key_gen);
    return caml_call2(For_monad[11][4][2], _a8_, _a7_);
   }
   function set_tree_using_comparator(comparator, elt_gen){
    var _a6_ = caml_call1(Base_Set[75][3][56], comparator);
    return map(list(elt_gen), _a6_);
   }
   function map_t_m(m, key_gen, data_gen){
    var
     comparator = m[1],
     _a5_ = map_tree_using_comparator(comparator, key_gen, data_gen);
    return map(_a5_, caml_call1(Base_Map[118][33], comparator));
   }
   function set_t_m(m, elt_gen){
    var
     comparator = m[1],
     _a4_ = set_tree_using_comparator(comparator, elt_gen);
    return map(_a4_, caml_call1(Base_Set[75][66], comparator));
   }
   function bigarray1(t, kind, layout, length){
    function _a0_(elts){
     var
      elts$0 = caml_call1(Base_Array[9], elts),
      dim = elts$0.length - 1,
      offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
     function _a2_(i){
      var _a3_ = i - offset | 0;
      return caml_check_bound(elts$0, _a3_)[1 + _a3_];
     }
     return caml_call4
             (Base_quickcheck_Bigarray_helpe[2][2], kind, layout, dim, _a2_);
    }
    if(length)
     var length$0 = length[1], _a1_ = list_with_length(t, length$0);
    else
     var _a1_ = list(t);
    return caml_call2(For_monad[11][4][3], _a1_, _a0_);
   }
   var _az_ = 0, _aA_ = 12;
   function bigstring_gen(_aZ_){return bigarray1(char$0, _aA_, _az_, _aZ_);}
   var _aB_ = 1, _aC_ = 0;
   function float32_vec_gen(_aY_){
    return bigarray1(float$0, _aC_, _aB_, _aY_);
   }
   var _aD_ = 1, _aE_ = 1;
   function float64_vec_gen(_aX_){
    return bigarray1(float$0, _aE_, _aD_, _aX_);
   }
   var
    bigstring = bigstring_gen(0),
    float32_vec = float32_vec_gen(0),
    float64_vec = float64_vec_gen(0);
   function bigstring_with_length(length){return bigstring_gen([0, length]);}
   function float32_vec_with_length(length){return float32_vec_gen([0, length]);
   }
   function float64_vec_with_length(length){return float64_vec_gen([0, length]);
   }
   function _aF_(max_total_size){
    if(0 === max_total_size) return caml_call1(For_monad[11][1], _aG_);
    function _aQ_(a){
     function _aS_(b){
      function _aW_(param){return param ? [0, a, b] : [0, b, a];}
      return caml_call2(For_monad[11][4][3], bool, _aW_);
     }
     var max_b = caml_div(max_total_size, a);
     function _aT_(b_weighted_low){return max_b - b_weighted_low | 0;}
     var
      _aU_ = int_log_uniform_inclusive(0, max_b),
      _aV_ = caml_call2(For_monad[11][4][3], _aU_, _aT_);
     return caml_call2(For_monad[11][4][2], _aV_, _aS_);
    }
    var _aR_ = int_log_uniform_inclusive(1, max_total_size);
    return caml_call2(For_monad[11][4][2], _aR_, _aQ_);
   }
   var bigarray2_dim = caml_call2(For_monad[11][4][2], size, _aF_);
   function bigarray2(t, kind, layout){
    function _aK_(param){
     var dim2 = param[2], dim1 = param[1];
     function _aL_(elts){
      var
       elts$0 = caml_call2(Base_Array[85], elts, Base_Array[9]),
       offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
      function _aN_(i, j){
       var _aO_ = j - offset | 0, _aP_ = i - offset | 0;
       return caml_check_bound(caml_check_bound(elts$0, _aP_)[1 + _aP_], _aO_)
               [1 + _aO_];
      }
      return caml_call5
              (Base_quickcheck_Bigarray_helpe[3][2],
               kind,
               layout,
               dim1,
               dim2,
               _aN_);
     }
     var _aM_ = list_with_length(list_with_length(t, dim2), dim1);
     return caml_call2(For_monad[11][4][3], _aM_, _aL_);
    }
    return caml_call2(For_monad[11][4][2], bigarray2_dim, _aK_);
   }
   var
    float32_mat = bigarray2(float$0, 0, 1),
    float64_mat = bigarray2(float$0, 1, 1);
   function coverage(Cmp, sample){
    function _aH_(counts, value){
     function _aJ_(param){
      if(! param) return 1;
      var prev = param[1];
      return prev + 1 | 0;
     }
     return caml_call3(Base_Map[41], counts, value, _aJ_);
    }
    var _aI_ = caml_call1(Base_Map[6], Cmp);
    return caml_call3(Base_Sequence[11], sample, _aI_, _aH_);
   }
   function monitor(t, f){
    return map(t, function(value){caml_call1(f, value); return value;});
   }
   var
    Debug = [0, coverage, monitor],
    Base_quickcheck_Generator =
      [0,
       unit,
       bool,
       char$0,
       string,
       bytes,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t_m,
       set_t_m,
       map_tree_using_comparator,
       set_tree_using_comparator,
       of_list,
       union,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply,
       map2,
       map3,
       For_applicative[13],
       symbol_bind,
       symbol_map,
       For_monad[3],
       bind,
       return$0,
       map,
       join,
       ignore_m,
       all,
       all_unit,
       For_monad[11],
       size,
       with_size,
       sizes,
       filter,
       filter_map,
       recursive_union,
       fixed_point,
       of_lazy,
       of_weighted_list,
       weighted_union,
       weighted_recursive_union,
       small_positive_or_zero_int,
       small_strictly_positive_int,
       int_uniform,
       int32_uniform,
       int63_uniform,
       int64_uniform,
       nativeint_uniform,
       int_inclusive,
       int32_inclusive,
       int63_inclusive,
       int64_inclusive,
       nativeint_inclusive,
       int_uniform_inclusive,
       int32_uniform_inclusive,
       int63_uniform_inclusive,
       int64_uniform_inclusive,
       nativeint_uniform_inclusive,
       int_log_uniform_inclusive,
       int32_log_uniform_inclusive,
       int63_log_uniform_inclusive,
       int64_log_uniform_inclusive,
       nativeint_log_uniform_inclusiv,
       int_log_inclusive,
       int32_log_inclusive,
       int63_log_inclusive,
       int64_log_inclusive,
       nativeint_log_inclusive,
       int_geometric,
       int32_geometric,
       int63_geometric,
       int64_geometric,
       nativeint_geometric,
       float_inclusive,
       float_uniform_exclusive,
       float_without_nan,
       float_finite,
       float_strictly_positive,
       float_strictly_negative,
       float_positive_or_zero,
       float_negative_or_zero,
       float_of_class,
       char_lowercase,
       char_uppercase,
       char_digit,
       char_alpha,
       char_alphanum,
       char_whitespace,
       char_print,
       char_uniform_inclusive,
       string_non_empty,
       string_with_length,
       string_of,
       string_non_empty_of,
       string_with_length_of,
       string_like,
       sexp_of,
       list_non_empty,
       list_with_length,
       list_filtered,
       list_permutations,
       bigarray1,
       bigstring_with_length,
       float32_vec_with_length,
       float64_vec_with_length,
       perturb,
       create,
       generate,
       Debug];
   runtime.caml_register_global
    (88, Base_quickcheck_Generator, "Base_quickcheck__Generator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Shrinker
//# unitInfo: Requires: Base__Array, Base__Bytes, Base__Either, Base__Field, Base__Int, Base__Lazy, Base__List, Base__Map, Base__Option, Base__Sequence, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, CamlinternalLazy, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_layout = runtime.caml_ba_layout,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_List = global_data.Base__List,
    Base_Either = global_data.Base__Either,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Lazy = global_data.Base__Lazy,
    Base_Array = global_data.Base__Array,
    Base_Option = global_data.Base__Option,
    Base_Field = global_data.Base__Field,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Int = global_data.Base__Int,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes,
    cst_dim2 = "dim2",
    cst_dim1 = "dim1";
   function atomic(param){return Base_Sequence[41];}
   function create(_ax_){return _ax_;}
   function shrink(_aw_){return _aw_;}
   function map(t, f, f_inverse){
    return function(x){
     var _av_ = caml_call1(t, caml_call1(f_inverse, x));
     return caml_call2(Base_Sequence[35], _av_, f);};
   }
   function filter(t, f){
    return function(x){
     var _au_ = caml_call1(t, x);
     return caml_call2(Base_Sequence[54], _au_, f);};
   }
   function filter_map(t, f, f_inverse){
    return function(x){
     var _at_ = caml_call1(t, caml_call1(f_inverse, x));
     return caml_call2(Base_Sequence[80], _at_, f);};
   }
   function of_lazy(lazy_t){
    return function(x){
     var
      _ap_ =
        [246,
         function(_aq_){
          var _ar_ = caml_obj_tag(lazy_t);
          a:
          if(250 === _ar_)
           var _as_ = lazy_t[1];
          else{
           if(246 !== _ar_ && 244 !== _ar_){var _as_ = lazy_t; break a;}
           var _as_ = caml_call1(CamlinternalLazy[2], lazy_t);
          }
          return caml_call1(_as_, x);
         }];
     return caml_call1(Base_Sequence[107], _ap_);};
   }
   function fixed_point(of_shrinker){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(of_shrinker, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   function both(fst_t, snd_t){
    return function(param){
     var snd = param[2], fst = param[1], _ai_ = 0;
     function _aj_(snd){return [0, fst, snd];}
     var
      _ak_ = caml_call1(snd_t, snd),
      _al_ = [0, caml_call2(Base_Sequence[35], _ak_, _aj_), _ai_];
     function _am_(fst){return [0, fst, snd];}
     var
      _an_ = caml_call1(fst_t, fst),
      _ao_ = [0, caml_call2(Base_Sequence[35], _an_, _am_), _al_];
     return caml_call1(Base_Sequence[70], _ao_);};
   }
   function float32_vec(src){
    var dim = caml_ba_dim_1(src);
    if(0 === dim) return Base_Sequence[41];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
    function _ag_(to_skip){
     var to_skip$0 = to_skip + offset | 0;
     function _ah_(i){
      var i$0 = i < to_skip$0 ? i : i + 1 | 0;
      return runtime.caml_ba_get_1(src, i$0);
     }
     return caml_call4
             (Base_quickcheck_Bigarray_helpe[2][2],
              kind,
              layout,
              dim - 1 | 0,
              _ah_);
    }
    return caml_call2(Base_Sequence[79], dim, _ag_);
   }
   function dim2(r){return r[2];}
   function dim1(r){return r[1];}
   function _a_(r, v){return [0, r[1], v];}
   var
    _b_ = 0,
    dim2$0 = [0, function(param){return 0;}, cst_dim2, _b_, dim2, _a_];
   function _c_(r, v){return [0, v, r[2]];}
   var
    _d_ = 0,
    dim1$0 = [0, function(param){return 0;}, cst_dim1, _d_, dim1, _c_];
   function shrink$0(field, src){
    var
     _ac_ = runtime.caml_ba_dim_2(src),
     dims = [0, caml_ba_dim_1(src), _ac_];
    if(0 === caml_call2(Base_Field[3], field, dims)) return Base_Sequence[41];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout),
     match = caml_call3(Base_Field[6], field, dims, Base_Int[46]),
     dim2 = match[2],
     dim1 = match[1];
    function _ad_(to_skip){
     var to_skip$0 = to_skip + offset | 0;
     function skip(i){return i < to_skip$0 ? i : i + 1 | 0;}
     function _af_(dim1, dim2){
      var
       match = caml_call3(Base_Field[6], field, [0, dim1, dim2], skip),
       dim2$0 = match[2],
       dim1$0 = match[1];
      return runtime.caml_ba_get_2(src, dim1$0, dim2$0);
     }
     return caml_call5
             (Base_quickcheck_Bigarray_helpe[3][2],
              kind,
              layout,
              dim1,
              dim2,
              _af_);
    }
    var _ae_ = caml_call2(Base_Field[3], field, dims);
    return caml_call2(Base_Sequence[79], _ae_, _ad_);
   }
   function float32_mat(src){
    var
     _aa_ = [0, shrink$0(dim2$0, src), 0],
     _ab_ = [0, shrink$0(dim1$0, src), _aa_];
    return caml_call1(Base_Sequence[70], _ab_);
   }
   function option(value_t){
    return function(param){
     if(! param) return Base_Sequence[41];
     var
      value = param[1],
      _Y_ = Base_Option[23],
      _Z_ = caml_call1(value_t, value),
      ___ = caml_call2(Base_Sequence[35], _Z_, _Y_),
      _$_ = caml_call1(Base_Sequence[101], 0);
     return caml_call2(Base_Sequence[65], _$_, ___);};
   }
   function list(elt_t){
    return fixed_point
            (function(list_t){
              return function(param){
               if(! param) return Base_Sequence[41];
               var tail = param[2], head = param[1], _Q_ = 0;
               function _R_(tail){return [0, head, tail];}
               var
                _S_ = caml_call1(list_t, tail),
                _T_ = [0, caml_call2(Base_Sequence[35], _S_, _R_), _Q_];
               function _U_(head){return [0, head, tail];}
               var
                _V_ = caml_call1(elt_t, head),
                _W_ = [0, caml_call2(Base_Sequence[35], _V_, _U_), _T_],
                _X_ = [0, caml_call1(Base_Sequence[101], tail), _W_];
               return caml_call1(Base_Sequence[70], _X_);};
             });
   }
   var
    _e_ = Base_String[25],
    _f_ = Base_String[137],
    string = map(list(atomic), _f_, _e_),
    bytes = map(string, Base_Bytes[28], Base_Bytes[29]);
   function array(t){
    var _O_ = Base_Array[30], _P_ = Base_Array[9];
    return map(list(t), _P_, _O_);
   }
   function ref(t){
    function _L_(_N_){return _N_[1];}
    return map(t, function(_M_){return [0, _M_];}, _L_);
   }
   function lazy_t(t){
    function _I_(_J_){
     var _K_ = caml_obj_tag(_J_);
     if(250 === _K_) return _J_[1];
     if(246 !== _K_ && 244 !== _K_) return _J_;
     return caml_call1(CamlinternalLazy[2], _J_);
    }
    return map(t, Base_Lazy[24], _I_);
   }
   var
    sexp =
      fixed_point
       (function(shrinker){
         return function(param){
          if(0 === param[0]) return Base_Sequence[41];
          var
           l = param[1],
           _G_ = list(shrinker)(l),
           _H_ = Base_Sequence[35],
           shrink_list = caml_call2(_H_, _G_, function(l){return [1, l];}),
           shrink_tree = caml_call1(Base_Sequence[106], l);
          return caml_call1
                  (Base_Sequence[70], [0, shrink_list, [0, shrink_tree, 0]]);};
        });
   function either(fst_t, snd_t){
    return function(either){
     if(0 === either[0]){
      var
       fst = either[1],
       _C_ = Base_Either[19],
       _D_ = caml_call1(fst_t, fst);
      return caml_call2(Base_Sequence[35], _D_, _C_);
     }
     var snd = either[1], _E_ = Base_Either[20], _F_ = caml_call1(snd_t, snd);
     return caml_call2(Base_Sequence[35], _F_, _E_);};
   }
   function result(ok_t, err_t){
    function _A_(param){
     if(0 === param[0]){var ok = param[1]; return [0, ok];}
     var err = param[1];
     return [1, err];
    }
    function _B_(param){
     if(0 === param[0]){var ok = param[1]; return [0, ok];}
     var err = param[1];
     return [1, err];
    }
    return map(either(ok_t, err_t), _B_, _A_);
   }
   function map_tree_using_comparator(comparator, key_t, data_t){
    return function(tree){
     var alist = caml_call2(Base_Map[118][3][74], 0, tree);
     function _q_(param){
      var k = param[1];
      return caml_call3(Base_Map[118][3][46], comparator, tree, k);
     }
     var
      _r_ = caml_call1(Base_Sequence[106], alist),
      drop_keys = caml_call2(Base_Sequence[35], _r_, _q_);
     function _s_(param){
      var
       data = param[2],
       key = param[1],
       tree$0 = caml_call3(Base_Map[118][3][46], comparator, tree, key);
      function _y_(smaller_key){
       var
        match =
          caml_call4
           (Base_Map[118][3][36], comparator, tree$0, smaller_key, data);
       if(typeof match === "number") return 0;
       var tree = match[2];
       return [0, tree];
      }
      var _z_ = caml_call1(key_t, key);
      return caml_call2(Base_Sequence[80], _z_, _y_);
     }
     var
      _t_ = caml_call2(Base_List[53], alist, _s_),
      shrink_keys = caml_call1(Base_Sequence[70], _t_);
     function _u_(param){
      var data = param[2], key = param[1];
      function _w_(smaller_data){
       return caml_call4
               (Base_Map[118][3][38], comparator, tree, key, smaller_data);
      }
      var _x_ = caml_call1(data_t, data);
      return caml_call2(Base_Sequence[35], _x_, _w_);
     }
     var
      _v_ = caml_call2(Base_List[53], alist, _u_),
      shrink_data = caml_call1(Base_Sequence[70], _v_);
     return caml_call1
             (Base_Sequence[70],
              [0, drop_keys, [0, shrink_keys, [0, shrink_data, 0]]]);};
   }
   function set_tree_using_comparator(comparator, elt_t){
    return function(tree){
     var list = caml_call1(Base_Set[75][3][14], tree);
     function _k_(elt){
      return caml_call3(Base_Set[75][3][19], comparator, tree, elt);
     }
     var
      _l_ = caml_call1(Base_Sequence[106], list),
      drop_elts = caml_call2(Base_Sequence[35], _l_, _k_);
     function _m_(elt){
      var tree$0 = caml_call3(Base_Set[75][3][19], comparator, tree, elt);
      function _o_(smaller_elt){
       return caml_call3(Base_Set[75][3][17], comparator, tree$0, smaller_elt)
               ? 0
               : [0,
                 caml_call3
                  (Base_Set[75][3][18], comparator, tree$0, smaller_elt)];
      }
      var _p_ = caml_call1(elt_t, elt);
      return caml_call2(Base_Sequence[80], _p_, _o_);
     }
     var
      _n_ = caml_call2(Base_List[53], list, _m_),
      shrink_elts = caml_call1(Base_Sequence[70], _n_);
     return caml_call1(Base_Sequence[70], [0, drop_elts, [0, shrink_elts, 0]]);};
   }
   function map_t(key_t, data_t){
    return function(map_t){
     var
      comparator = caml_call1(Base_Map[5], map_t),
      _i_ = Base_Map[118][104],
      _j_ = caml_call1(Base_Map[118][33], comparator),
      t = map(map_tree_using_comparator(comparator, key_t, data_t), _j_, _i_);
     return t(map_t);};
   }
   function set_t(elt_t){
    return function(set_t){
     var
      comparator = caml_call1(Base_Set[4], set_t),
      _g_ = Base_Set[75][49],
      _h_ = caml_call1(Base_Set[75][66], comparator),
      t = map(set_tree_using_comparator(comparator, elt_t), _h_, _g_);
     return t(set_t);};
   }
   var
    Base_quickcheck_Shrinker =
      [0,
       atomic,
       atomic,
       atomic,
       atomic,
       string,
       bytes,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       float32_vec,
       float32_vec,
       float32_vec,
       float32_mat,
       float32_mat,
       map_t,
       set_t,
       map_tree_using_comparator,
       set_tree_using_comparator,
       map,
       filter,
       filter_map,
       fixed_point,
       of_lazy,
       create,
       shrink];
   runtime.caml_register_global
    (16, Base_quickcheck_Shrinker, "Base_quickcheck__Shrinker");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_quickcheck_Test_intf = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_Test_intf, "Base_quickcheck__Test_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test
//# unitInfo: Requires: Base, Base__Backtrace, Base__Error, Base__List, Base__Or_error, Base__Random, Base__Sequence, Base__String, Base__Word_size, Base_quickcheck__Generator, Base_quickcheck__Shrinker, Base_quickcheck__Test_intf, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_test_count = "test_count";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "...",
    Base_Backtrace = global_data.Base__Backtrace,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Sequence = global_data.Base__Sequence,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    Base = global_data.Base,
    Splittable_random = global_data.Splittable_random,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Random = global_data.Base__Random,
    Base_List = global_data.Base__List,
    Base_Word_size = global_data.Base__Word_size,
    _s_ = [0, "error"],
    _t_ = [0, "input"],
    cst_Base_quickcheck_Test_run_t = "Base_quickcheck.Test.run: test failed",
    _r_ = [0, 0],
    _p_ = [0, 0],
    _q_ = [0, 0],
    _n_ = [0, "number_of_size_values"],
    _o_ = [0, cst_test_count],
    cst_Base_quickcheck_Test_run_i =
      "Base_quickcheck.Test.run: insufficient size values for test count",
    _c_ = [0, "sizes"],
    _d_ = [0, "shrink_count"],
    _e_ = [0, cst_test_count],
    _f_ = [0, "seed"],
    _a_ = [0, "Deterministic"],
    _b_ = [0, "Nondeterministic"],
    _g_ = [0, 104758188],
    _h_ = [0, 104758188],
    _m_ = [0, "an arbitrary but deterministic string"];
   function sexp_of_t(param){
    if(! param) return _b_;
    var arg0_001 = param[1], res0_002 = caml_call1(Base[202], arg0_001);
    return [1, [0, _a_, [0, res0_002, 0]]];
   }
   var Seed = [0, sexp_of_t];
   function sexp_of_t$0(param){
    var
     sizes_010 = param[4],
     shrink_count_008 = param[3],
     test_count_006 = param[2],
     seed_004 = param[1],
     sexp_of_elt = Base[136],
     match = caml_call2(Base_Sequence[90], sizes_010, 100),
     suffix = match[2],
     prefix = match[1],
     prefix$0 = caml_call2(Base_List[53], prefix, sexp_of_elt),
     bnds_003 = 0,
     suffix$0 =
       caml_call1(Base_Sequence[9], suffix)
        ? 0
        : [0, caml_call1(Sexplib0_Sexp_conv[7], cst), 0],
     arg_011 = [1, caml_call2(Base[222], prefix$0, suffix$0)],
     bnds_003$0 = [0, [1, [0, _c_, [0, arg_011, 0]]], bnds_003],
     arg_009 = caml_call1(Base[136], shrink_count_008),
     bnds_003$1 = [0, [1, [0, _d_, [0, arg_009, 0]]], bnds_003$0],
     arg_007 = caml_call1(Base[136], test_count_006),
     bnds_003$2 = [0, [1, [0, _e_, [0, arg_007, 0]]], bnds_003$1],
     arg_005 = caml_call1(Seed[1], seed_004),
     bnds_003$3 = [0, [1, [0, _f_, [0, arg_005, 0]]], bnds_003$2];
    return [1, bnds_003$3];
   }
   var
    _i_ = caml_call5(Base_List[132], 0, _h_, _g_, 0, 30),
    _j_ = caml_call1(Base_Sequence[99], _i_),
    _k_ = 10000,
    _l_ = Base_Word_size[3] ? 10000 : 1000,
    default_config = [0, _m_, _l_, _k_, _j_],
    lazy_nondeterministic_state =
      [246, function(_V_){return caml_call2(Base_Random[19][3], 0, 0);}];
   function with_sample(f, opt, _R_, generator){
    if(opt) var sth = opt[1], config = sth; else var config = default_config;
    if(_R_) var sth$0 = _R_[1], examples = sth$0; else var examples = 0;
    var match = config[1];
    if(match)
     var
      string = match[1],
      _J_ = runtime.Base_hash_string(string),
      random = caml_call1(Splittable_random[2], _J_);
    else{
     var _K_ = runtime.caml_obj_tag(lazy_nondeterministic_state);
     a:
     if(250 === _K_)
      var _L_ = lazy_nondeterministic_state[1];
     else{
      if(246 !== _K_ && 244 !== _K_){
       var _L_ = lazy_nondeterministic_state;
       break a;
      }
      var _L_ = caml_call1(CamlinternalLazy[2], lazy_nondeterministic_state);
     }
     var random = caml_call1(Splittable_random[1], _L_);
    }
    function _M_(param){
     var number_of_size_values = param[2], sizes = param[1];
     if(config[2] <= number_of_size_values) return 0;
     var match = caml_call1(Base_Sequence[42], sizes);
     if(match){
      var match$0 = match[1], remaining_sizes = match$0[2], size = match$0[1];
      return [0,
              [0, size, [0, remaining_sizes, number_of_size_values + 1 | 0]]];
     }
     var
      _S_ =
        [0,
         [1, [0, _n_, [0, caml_call1(Base[136], number_of_size_values), 0]]],
         0],
      _T_ = [0, [1, [0, _o_, [0, caml_call1(Base[136], config[2]), 0]]], _S_],
      _U_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Test_run_i),
          _T_]];
     return caml_call1(Base[246], _U_);
    }
    var
     _N_ = caml_call2(Base_Sequence[45], [0, config[4], 0], _M_),
     _O_ = Base_Sequence[35],
     _P_ =
       caml_call2
        (_O_,
         _N_,
         function(size){
          return caml_call3
                  (Base_quickcheck_Generator[128], generator, size, random);
         }),
     _Q_ = caml_call1(Base_Sequence[106], examples),
     sequence = caml_call2(Base_Sequence[65], _Q_, _P_);
    return caml_call1(f, sequence);
   }
   function result(f, opt, _E_, m){
    if(opt) var sth = opt[1], config = sth; else var config = default_config;
    if(_E_) var sth$0 = _E_[1], examples = sth$0; else var examples = 0;
    var _F_ = m[2], _G_ = [0, examples], _H_ = [0, config];
    return with_sample
            (function(sequence){
              function _I_(param, input){
               var match = caml_call1(f, input);
               if(0 === match[0]) return _p_;
               var error = match[1];
               return [1, [0, input, error]];
              }
              var match$2 = caml_call3(Base_Sequence[12], sequence, 0, _I_);
              if(0 === match$2[0]) return _q_;
              var
               match$3 = match$2[1],
               error$1 = match$3[2],
               input$0 = match$3[1],
               shrinker = m[3],
               shrink_count$1 = config[3],
               alternates$2 =
                 caml_call2(Base_quickcheck_Shrinker[37], shrinker, input$0),
               shrink_count = shrink_count$1,
               alternates = alternates$2,
               input = input$0,
               error = error$1;
              for(;;){
               if(0 !== shrink_count){
                var
                 shrink_count$0 = shrink_count - 1 | 0,
                 match = caml_call1(Base_Sequence[42], alternates);
                if(match){
                 var
                  match$0 = match[1],
                  alternates$0 = match$0[2],
                  alternate = match$0[1],
                  match$1 = caml_call1(f, alternate);
                 if(0 === match$1[0]){
                  var
                   shrink_count = shrink_count$0,
                   alternates = alternates$0;
                  continue;
                 }
                 var
                  error$0 = match$1[1],
                  alternates$1 =
                    caml_call2
                     (Base_quickcheck_Shrinker[37], shrinker, alternate),
                  shrink_count = shrink_count$0,
                  alternates = alternates$1,
                  input = alternate,
                  error = error$0;
                 continue;
                }
               }
               return [1, [0, input, error]];
              }
             },
             _H_,
             _G_,
             _F_);
   }
   function run(f, config, examples, M){
    function f$0(x){
     function _C_(param){return caml_call1(f, x);}
     var _D_ = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return caml_call2(Base_Or_error[32], _D_, _C_);
    }
    var match = result(f$0, config, examples, M);
    if(0 === match[0]) return _r_;
    var
     match$0 = match[1],
     error = match$0[2],
     input = match$0[1],
     _z_ = [0, [1, [0, _s_, [0, caml_call1(Base_Error[9], error), 0]]], 0],
     _A_ = [0, [1, [0, _t_, [0, caml_call1(M[1], input), 0]]], _z_],
     _B_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Test_run_t),
         _A_]];
    return caml_call1(Base_Or_error[39], _B_);
   }
   function with_sample_exn(f, config, examples, generator){
    function f$0(x){
     function _y_(param){return caml_call1(f, x);}
     return caml_call2(Base_Or_error[31], 0, _y_);
    }
    var _x_ = with_sample(f$0, config, examples, generator);
    return caml_call1(Base_Or_error[34], _x_);
   }
   function run_exn(f, config, examples, testable){
    function f$0(x){
     function _v_(param){return caml_call1(f, x);}
     var _w_ = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return caml_call2(Base_Or_error[31], _w_, _v_);
    }
    var _u_ = run(f$0, config, examples, testable);
    return caml_call1(Base_Or_error[34], _u_);
   }
   var
    Base_quickcheck_Test =
      [0,
       [0, Seed, sexp_of_t$0],
       default_config,
       run,
       run_exn,
       result,
       with_sample,
       with_sample_exn];
   runtime.caml_register_global
    (32, Base_quickcheck_Test, "Base_quickcheck__Test");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer
//# unitInfo: Requires: Base, Base__Array, Base__Bool, Base__Bytes, Base__Char, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__List, Base__Map, Base__Nativeint, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Generator, Base_quickcheck__Observer0, CamlinternalLazy, Splittable_random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_Hash = global_data.Base__Hash,
    Splittable_random = global_data.Splittable_random,
    Base_List = global_data.Base__List,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Array = global_data.Base__Array,
    Base = global_data.Base,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int63 = global_data.Base__Int63,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Float = global_data.Base__Float,
    Base_String = global_data.Base__String,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Bytes = global_data.Base__Bytes,
    opaque = Base_quickcheck_Observer0[1],
    create = Base_quickcheck_Observer0[2],
    observe = Base_quickcheck_Observer0[3],
    _a_ = [0, 0];
   function unmap(t, f){
    return caml_call1
            (create,
             function(x, size, hash){
              return caml_call4(observe, t, caml_call1(f, x), size, hash);
             });
   }
   function of_hash_fold(f){
    return caml_call1
            (create, function(x, param, hash){return caml_call2(f, hash, x);});
   }
   function of_lazy(lazy_t){
    return caml_call1
            (create,
             function(x, size, hash){
              var _s_ = caml_obj_tag(lazy_t);
              a:
              if(250 === _s_)
               var _t_ = lazy_t[1];
              else{
               if(246 !== _s_ && 244 !== _s_){var _t_ = lazy_t; break a;}
               var _t_ = caml_call1(CamlinternalLazy[2], lazy_t);
              }
              return caml_call4(observe, _t_, x, size, hash);
             });
   }
   function fixed_point(wrap){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(wrap, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   var
    bool = of_hash_fold(Base_Bool[4]),
    char$0 = of_hash_fold(Base_Char[4]),
    int$0 = of_hash_fold(Base_Int[7]),
    int32 = of_hash_fold(Base_Int32[7]),
    int63 = of_hash_fold(Base_Int63[6]),
    int64 = of_hash_fold(Base_Int64[7]),
    nativeint = of_hash_fold(Base_Nativeint[7]),
    float$0 = of_hash_fold(Base_Float[5]),
    string = of_hash_fold(Base_String[40]),
    sexp = of_hash_fold(Base[85][2]),
    bigstring =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[112])),
    float32_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[123])),
    float64_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[123])),
    float32_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[123])),
    float64_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[123])),
    bytes = unmap(string, Base_Bytes[29]);
   function either(fst_t, snd_t){
    return caml_call1
            (create,
             function(either, size, hash){
              if(0 === either[0]){
               var fst = either[1];
               return caml_call4
                       (observe, fst_t, fst, size, caml_call2(Base[133], hash, 1));
              }
              var snd = either[1];
              return caml_call4
                      (observe, snd_t, snd, size, caml_call2(Base[133], hash, 2));
             });
   }
   function result(ok_t, err_t){
    function _r_(param){
     if(0 === param[0]){var ok = param[1]; return [0, ok];}
     var err = param[1];
     return [1, err];
    }
    return unmap(either(ok_t, err_t), _r_);
   }
   function both(fst_t, snd_t){
    return caml_call1
            (create,
             function(param, size, hash){
              var
               snd = param[2],
               fst = param[1],
               hash$0 = caml_call4(observe, fst_t, fst, size, hash),
               hash$1 = caml_call4(observe, snd_t, snd, size, hash$0);
              return hash$1;
             });
   }
   function option(value_t){
    function _q_(param){
     if(! param) return _a_;
     var value = param[1];
     return [1, value];
    }
    return unmap(either(opaque, value_t), _q_);
   }
   function list(elt_t){
    return caml_call1
            (create,
             function(list, size, hash){
              var
               _m_ = caml_call1(Base_Hash[9], hash),
               random = caml_call1(Splittable_random[2], _m_),
               length = caml_call1(Base_List[45], list),
               _n_ =
                 caml_call3
                  (Base_quickcheck_Generator[53], [0, length], [0, length], 0),
               sizes =
                 caml_call3(Base_quickcheck_Generator[128], _n_, size, random);
              function _o_(hash, elt, size){
               return caml_call4
                       (observe, elt_t, elt, size, caml_call2(Base[133], hash, 1));
              }
              var _p_ = caml_call2(Base[133], hash, 0);
              return caml_call4(Base_List[71], list, sizes, _p_, _o_);
             });
   }
   function array(t){var _l_ = Base_Array[30]; return unmap(list(t), _l_);}
   function ref(t){return unmap(t, function(_k_){return _k_[1];});}
   function lazy_t(t){
    return unmap
            (t,
             function(_i_){
              var _j_ = caml_obj_tag(_i_);
              if(250 === _j_) return _i_[1];
              if(246 !== _j_ && 244 !== _j_) return _i_;
              return caml_call1(CamlinternalLazy[2], _i_);
             });
   }
   function fn(dom, rng){
    return caml_call1
            (create,
             function(f, size, hash){
              var
               _f_ = caml_call1(Base_Hash[9], hash),
               random = caml_call1(Splittable_random[2], _f_),
               _g_ = caml_call3(Base_quickcheck_Generator[53], 0, 0, 0),
               sizes =
                 caml_call3
                  (Base_quickcheck_Generator[128], _g_, size * 2 | 0, random);
              function _h_(hash, size){
               var
                x =
                  caml_call3
                   (Base_quickcheck_Generator[128], dom, size, random);
               return caml_call4(observe, rng, caml_call1(f, x), size, hash);
              }
              return caml_call3(Base_List[20], sizes, hash, _h_);
             });
   }
   function map_tree(key_obs, data_obs){
    var arg = Base_Map[118][3][74];
    function _e_(eta){return caml_call2(arg, 0, eta);}
    return unmap(list(both(key_obs, data_obs)), _e_);
   }
   function set_tree(elt_obs){
    var _d_ = Base_Set[75][3][14];
    return unmap(list(elt_obs), _d_);
   }
   function map_t(key_obs, data_obs){
    var _c_ = Base_Map[118][104];
    return unmap(map_tree(key_obs, data_obs), _c_);
   }
   function set_t(elt_obs){
    var _b_ = Base_Set[75][49];
    return unmap(set_tree(elt_obs), _b_);
   }
   var
    Base_quickcheck_Observer =
      [0,
       opaque,
       opaque,
       bool,
       char$0,
       string,
       bytes,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t,
       set_t,
       map_tree,
       set_tree,
       of_hash_fold,
       unmap,
       fixed_point,
       of_lazy,
       create,
       observe];
   runtime.caml_register_global
    (22, Base_quickcheck_Observer, "Base_quickcheck__Observer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Export
//# unitInfo: Requires: Base_quickcheck__Generator, Base_quickcheck__Observer, Base_quickcheck__Shrinker
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Observer = global_data.Base_quickcheck__Observer,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    quickcheck_generator_unit = Base_quickcheck_Generator[1],
    quickcheck_generator_bool = Base_quickcheck_Generator[2],
    quickcheck_generator_char = Base_quickcheck_Generator[3],
    quickcheck_generator_string = Base_quickcheck_Generator[4],
    quickcheck_generator_bytes = Base_quickcheck_Generator[5],
    quickcheck_generator_int = Base_quickcheck_Generator[6],
    quickcheck_generator_int32 = Base_quickcheck_Generator[7],
    quickcheck_generator_int64 = Base_quickcheck_Generator[9],
    quickcheck_generator_nativeint = Base_quickcheck_Generator[10],
    quickcheck_generator_float = Base_quickcheck_Generator[11],
    quickcheck_generator_option = Base_quickcheck_Generator[13],
    quickcheck_generator_list = Base_quickcheck_Generator[14],
    quickcheck_generator_array = Base_quickcheck_Generator[15],
    quickcheck_generator_ref = Base_quickcheck_Generator[16],
    quickcheck_generator_lazy_t = Base_quickcheck_Generator[17],
    quickcheck_observer_unit = Base_quickcheck_Observer[2],
    quickcheck_observer_bool = Base_quickcheck_Observer[3],
    quickcheck_observer_char = Base_quickcheck_Observer[4],
    quickcheck_observer_string = Base_quickcheck_Observer[5],
    quickcheck_observer_bytes = Base_quickcheck_Observer[6],
    quickcheck_observer_int = Base_quickcheck_Observer[7],
    quickcheck_observer_int32 = Base_quickcheck_Observer[8],
    quickcheck_observer_int64 = Base_quickcheck_Observer[10],
    quickcheck_observer_nativeint = Base_quickcheck_Observer[11],
    quickcheck_observer_float = Base_quickcheck_Observer[12],
    quickcheck_observer_option = Base_quickcheck_Observer[14],
    quickcheck_observer_list = Base_quickcheck_Observer[15],
    quickcheck_observer_array = Base_quickcheck_Observer[16],
    quickcheck_observer_ref = Base_quickcheck_Observer[17],
    quickcheck_observer_lazy_t = Base_quickcheck_Observer[18],
    quickcheck_shrinker_unit = Base_quickcheck_Shrinker[2],
    quickcheck_shrinker_bool = Base_quickcheck_Shrinker[3],
    quickcheck_shrinker_char = Base_quickcheck_Shrinker[4],
    quickcheck_shrinker_string = Base_quickcheck_Shrinker[5],
    quickcheck_shrinker_bytes = Base_quickcheck_Shrinker[6],
    quickcheck_shrinker_int = Base_quickcheck_Shrinker[7],
    quickcheck_shrinker_int32 = Base_quickcheck_Shrinker[8],
    quickcheck_shrinker_int64 = Base_quickcheck_Shrinker[10],
    quickcheck_shrinker_nativeint = Base_quickcheck_Shrinker[11],
    quickcheck_shrinker_float = Base_quickcheck_Shrinker[12],
    quickcheck_shrinker_option = Base_quickcheck_Shrinker[14],
    quickcheck_shrinker_list = Base_quickcheck_Shrinker[15],
    quickcheck_shrinker_array = Base_quickcheck_Shrinker[16],
    quickcheck_shrinker_ref = Base_quickcheck_Shrinker[17],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Shrinker[18],
    Base_quickcheck_Export =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t];
   runtime.caml_register_global
    (3, Base_quickcheck_Export, "Base_quickcheck__Export");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck
//# unitInfo: Requires: Base_quickcheck__Export
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Export = global_data.Base_quickcheck__Export,
    quickcheck_generator_unit = Base_quickcheck_Export[1],
    quickcheck_generator_bool = Base_quickcheck_Export[2],
    quickcheck_generator_char = Base_quickcheck_Export[3],
    quickcheck_generator_string = Base_quickcheck_Export[4],
    quickcheck_generator_bytes = Base_quickcheck_Export[5],
    quickcheck_generator_int = Base_quickcheck_Export[6],
    quickcheck_generator_int32 = Base_quickcheck_Export[7],
    quickcheck_generator_int64 = Base_quickcheck_Export[8],
    quickcheck_generator_nativeint = Base_quickcheck_Export[9],
    quickcheck_generator_float = Base_quickcheck_Export[10],
    quickcheck_observer_unit = Base_quickcheck_Export[11],
    quickcheck_observer_bool = Base_quickcheck_Export[12],
    quickcheck_observer_char = Base_quickcheck_Export[13],
    quickcheck_observer_string = Base_quickcheck_Export[14],
    quickcheck_observer_bytes = Base_quickcheck_Export[15],
    quickcheck_observer_int = Base_quickcheck_Export[16],
    quickcheck_observer_int32 = Base_quickcheck_Export[17],
    quickcheck_observer_int64 = Base_quickcheck_Export[18],
    quickcheck_observer_nativeint = Base_quickcheck_Export[19],
    quickcheck_observer_float = Base_quickcheck_Export[20],
    quickcheck_shrinker_unit = Base_quickcheck_Export[21],
    quickcheck_shrinker_bool = Base_quickcheck_Export[22],
    quickcheck_shrinker_char = Base_quickcheck_Export[23],
    quickcheck_shrinker_string = Base_quickcheck_Export[24],
    quickcheck_shrinker_bytes = Base_quickcheck_Export[25],
    quickcheck_shrinker_int = Base_quickcheck_Export[26],
    quickcheck_shrinker_int32 = Base_quickcheck_Export[27],
    quickcheck_shrinker_int64 = Base_quickcheck_Export[28],
    quickcheck_shrinker_nativeint = Base_quickcheck_Export[29],
    quickcheck_shrinker_float = Base_quickcheck_Export[30],
    quickcheck_generator_option = Base_quickcheck_Export[31],
    quickcheck_generator_list = Base_quickcheck_Export[32],
    quickcheck_generator_array = Base_quickcheck_Export[33],
    quickcheck_generator_ref = Base_quickcheck_Export[34],
    quickcheck_generator_lazy_t = Base_quickcheck_Export[35],
    quickcheck_observer_option = Base_quickcheck_Export[36],
    quickcheck_observer_list = Base_quickcheck_Export[37],
    quickcheck_observer_array = Base_quickcheck_Export[38],
    quickcheck_observer_ref = Base_quickcheck_Export[39],
    quickcheck_observer_lazy_t = Base_quickcheck_Export[40],
    quickcheck_shrinker_option = Base_quickcheck_Export[41],
    quickcheck_shrinker_list = Base_quickcheck_Export[42],
    quickcheck_shrinker_array = Base_quickcheck_Export[43],
    quickcheck_shrinker_ref = Base_quickcheck_Export[44],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Export[45],
    Private = [0],
    Base_quickcheck =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t,
       Private];
   runtime.caml_register_global(1, Base_quickcheck, "Base_quickcheck");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIm9mZnNldCIsIml0ZXJpIiwidCIsImYiLCJpIiwiaW5pdCIsImtpbmQiLCJsYXlvdXQiLCJkaW0iLCJmb2xkIiwiaW5pdCQwIiwidG9fYXJyYXkiLCJzZXhwX29mX3QiLCJzZXhwX29mX2VsdCIsInNleHBfb2ZfcGFjayIsInNleHBfb2ZfbGF5b3V0IiwieF8wMDEiLCJoYXNoX2ZvbGQiLCJoYXNoX2ZvbGRfZWx0Iiwic3RhdGUiLCJzdGF0ZSQwIiwiaXRlcmkkMCIsImoiLCJkaW0xIiwiZGltMiIsImZvbGQkMCIsImVsdCIsInRvX2FycmF5JDAiLCJzZXhwX29mX3QkMCIsInhfMDAyIiwiaGFzaF9mb2xkJDAiLCJzdGF0ZSQxIiwiY3JlYXRlIiwib2JzZXJ2ZSIsIngiLCJzaXplIiwiaGFzaCIsIm9wYXF1ZSIsImdlbmVyYXRlIiwicmFuZG9tIiwiZm4iLCJkb20iLCJybmciLCJyYW5kb20kMCIsIndpdGhfc2l6ZSIsInBlcnR1cmIiLCJzYWx0IiwiZmlsdGVyX21hcCIsImxvb3AiLCJzaXplJDAiLCJ5Iiwic2l6ZSQxIiwiZmlsdGVyIiwicmV0dXJuJDAiLCJtYXAiLCJhcHBseSIsInRmIiwidHgiLCJiaW5kIiwiYWxsIiwibGlzdCIsImFsbF91bml0IiwibWFwJDAiLCJib3RoIiwibWFwMiIsIm1hcDMiLCJtYXAkMSIsImlnbm9yZV9tIiwiam9pbiIsIm9mX2xpc3QiLCJhcnJheSIsImhpIiwibG8iLCJpbmRleCIsInVuaW9uIiwib2Zfd2VpZ2h0ZWRfbGlzdCIsImFsaXN0IiwidmFsdWVzIiwid2VpZ2h0cyIsInZhbHVlX2FycmF5IiwiYWNjIiwid2VpZ2h0IiwiY3VtdWxhdGl2ZSIsInN1bSIsImNob2ljZSIsIndlaWdodGVkX3VuaW9uIiwib2ZfbGF6eSIsImxhenlfdCIsImZpeGVkX3BvaW50Iiwib2ZfZ2VuZXJhdG9yIiwid2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uIiwibm9ucmVjX2xpc3QiLCJzZWxmIiwidyIsIm4iLCJyZWNfbGlzdCIsIm5vbnJlY19nZW4iLCJyZWNfZ2VuIiwicmVjdXJzaXZlX3VuaW9uIiwid2VpZ2h0ZWQiLCJzaXplcyIsIm9wdCIsInN0aCIsIm1pbl9sZW5ndGgiLCJzdGgkMCIsIm1heF9sZW5ndGgiLCJ1cHBlcl9ib3VuZCIsIm1heF9sZW5ndGgkMCIsImxlbiIsInJlbWFpbmluZyIsIm1heF9pbmRleCIsInVuaXQiLCJib29sIiwib3B0aW9uIiwidmFsdWVfdCIsImVpdGhlciIsImZzdF90Iiwic25kX3QiLCJyZXN1bHQiLCJva190IiwiZXJyX3QiLCJvayIsImVyciIsImxpc3RfZ2VuZXJpYyIsImVsdF9nZW4iLCJsaXN0X25vbl9lbXB0eSIsImxpc3Rfd2l0aF9sZW5ndGgiLCJsZW5ndGgiLCJsaXN0X2ZpbHRlcmVkIiwiZWx0cyIsImVsdHMkMCIsImxlbmd0aF9vZl9pbnB1dCIsImxlbmd0aF9vZl9vdXRwdXQiLCJpbmRpY2VzIiwibGlzdF9wZXJtdXRhdGlvbnMiLCJyZWYiLCJjaGFyX3VuaWZvcm1faW5jbHVzaXZlIiwiY2hhcl91cHBlcmNhc2UiLCJjaGFyX2xvd2VyY2FzZSIsImNoYXJfZGlnaXQiLCJjaGFyX3ByaW50X3VuaWZvcm0iLCJjaGFyX3VuaWZvcm0iLCJjaGFyX2FscGhhIiwiY2hhcl9hbHBoYW51bSIsImNoYXJfd2hpdGVzcGFjZSIsImNoYXJfcHJpbnQiLCJjaGFyJDAiLCJzbWFsbF9pbnQiLCJhbGxvd196ZXJvIiwibG93ZXJfYm91bmQiLCJ3ZWlnaHRlZF9sb3ciLCJ3ZWlnaHRlZF9oaWdoIiwic21hbGxfcG9zaXRpdmVfb3JfemVyb19pbnQiLCJzbWFsbF9zdHJpY3RseV9wb3NpdGl2ZV9pbnQiLCJnZW9tZXRyaWMiLCJwIiwiZGVub21pbmF0b3IiLCJ1bmlmb3JtIiwiZXhwb25lbnRpYWwiLCJmbG9hdCQwIiwiaW50JDAiLCJpbnQkMSIsInVuaWZvcm1faW5jbHVzaXZlIiwibG9nX3VuaWZvcm1faW5jbHVzaXZlIiwibm9uX3VuaWZvcm0iLCJpbmNsdXNpdmUiLCJsb2dfaW5jbHVzaXZlIiwidW5pZm9ybV9hbGwiLCJsZXRfc3ludGF4XzAwNCIsIm1hZ25pdHVkZSIsIm5lZ2F0aXZlIiwibG9nX3VuaWZvcm0iLCJpbnRfdW5pZm9ybSIsImludF9pbmNsdXNpdmUiLCJpbnRfdW5pZm9ybV9pbmNsdXNpdmUiLCJpbnRfbG9nX2luY2x1c2l2ZSIsImludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJpbnRfZ2VvbWV0cmljIiwidW5pZm9ybSQwIiwibG9nX3VuaWZvcm0kMCIsImludDMyIiwiaW50MzJfdW5pZm9ybSIsImludDMyX2luY2x1c2l2ZSIsImludDMyX3VuaWZvcm1faW5jbHVzaXZlIiwiaW50MzJfbG9nX2luY2x1c2l2ZSIsImludDMyX2xvZ191bmlmb3JtX2luY2x1c2l2ZSIsImludDMyX2dlb21ldHJpYyIsInVuaWZvcm0kMSIsImxvZ191bmlmb3JtJDEiLCJpbnQ2MyIsImludDYzX3VuaWZvcm0iLCJpbnQ2M19pbmNsdXNpdmUiLCJpbnQ2M191bmlmb3JtX2luY2x1c2l2ZSIsImludDYzX2xvZ19pbmNsdXNpdmUiLCJpbnQ2M19sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJpbnQ2M19nZW9tZXRyaWMiLCJ0X3NleHBfZ3JhbW1hciQyIiwib2ZfZmxvYXQkMiIsInRvX2Zsb2F0JDIiLCJvZl9pbnRfZXhuJDIiLCJ0b19pbnRfZXhuJDIiLCJoYXNoX2ZvbGRfdCQyIiwiaGFzaCQyIiwidF9vZl9zZXhwJDIiLCJzZXhwX29mX3QkMiIsIm9mX3N0cmluZyQyIiwidG9fc3RyaW5nJDIiLCJlcXVhbCQyIiwiY29tcGFyZSQyIiwibWluJDIiLCJtYXgkMiIsImFzY2VuZGluZyQyIiwiZGVzY2VuZGluZyQyIiwiYmV0d2VlbiQyIiwiY2xhbXBfZXhuJDIiLCJjbGFtcCQyIiwiY29tcGFyYXRvciQyIiwicHAkMiIsImhhc2hhYmxlJDIiLCJpc19wb3NpdGl2ZSQyIiwiaXNfbm9uX25lZ2F0aXZlJDIiLCJpc19uZWdhdGl2ZSQyIiwiaXNfbm9uX3Bvc2l0aXZlJDIiLCJzaWduJDIiLCJjb21wYXJlX2xvY2FsJDIiLCJlcXVhbF9sb2NhbCQyIiwiaW52YXJpYW50JDIiLCJvZl9zdHJpbmdfb3B0JDIiLCJ0b19zdHJpbmdfaHVtJDIiLCJvbmUkMiIsIm1pbnVzX29uZSQyIiwicmVtJDIiLCJyb3VuZCQyIiwicm91bmRfdG93YXJkc196ZXJvJDIiLCJyb3VuZF9kb3duJDIiLCJyb3VuZF91cCQyIiwicm91bmRfbmVhcmVzdCQyIiwic3VjYyQyIiwicHJlZCQyIiwicG93JDIiLCJiaXRfYW5kJDIiLCJiaXRfb3IkMiIsImJpdF94b3IkMiIsImJpdF9ub3QkMiIsInBvcGNvdW50JDIiLCJzaGlmdF9sZWZ0JDIiLCJzaGlmdF9yaWdodCQyIiwiZGVjciQyIiwiaW5jciQyIiwib2ZfaW50MzJfZXhuJDIiLCJ0b19pbnQzMl9leG4kMiIsIm9mX2ludDY0X2V4biQyIiwidG9faW50NjQkMiIsIm9mX25hdGl2ZWludF9leG4kMiIsInRvX25hdGl2ZWludF9leG4kMiIsIm9mX2Zsb2F0X3VuY2hlY2tlZCQyIiwibnVtX2JpdHMkMiIsIm1heF92YWx1ZSQyIiwibWluX3ZhbHVlJDIiLCJzaGlmdF9yaWdodF9sb2dpY2FsJDIiLCJjZWlsX3BvdzIkMiIsImZsb29yX3BvdzIkMiIsImNlaWxfbG9nMiQyIiwiZmxvb3JfbG9nMiQyIiwiaXNfcG93MiQyIiwiY2x6JDIiLCJjdHokMiIsInN5bWJvbCQzNiIsImxub3QkMiIsImFicyQyIiwiemVybyQyIiwic3ltYm9sJDM3Iiwic3ltYm9sJDM4Iiwic3ltYm9sJDM5IiwidW5pZm9ybSQyIiwibG9nX3VuaWZvcm0kMiIsImludDY0IiwiaW50NjRfdW5pZm9ybSIsImludDY0X2luY2x1c2l2ZSIsImludDY0X3VuaWZvcm1faW5jbHVzaXZlIiwiaW50NjRfbG9nX2luY2x1c2l2ZSIsImludDY0X2xvZ191bmlmb3JtX2luY2x1c2l2ZSIsImludDY0X2dlb21ldHJpYyIsInVuaWZvcm0kMyIsImxvZ191bmlmb3JtJDMiLCJuYXRpdmVpbnQiLCJuYXRpdmVpbnRfdW5pZm9ybSIsIm5hdGl2ZWludF9pbmNsdXNpdmUiLCJuYXRpdmVpbnRfdW5pZm9ybV9pbmNsdXNpdmUiLCJuYXRpdmVpbnRfbG9nX2luY2x1c2l2ZSIsIm5hdGl2ZWludF9sb2dfdW5pZm9ybV9pbmNsdXNpdiIsIm5hdGl2ZWludF9nZW9tZXRyaWMiLCJmbG9hdF96ZXJvX2V4cG9uZW50IiwiZmxvYXRfemVyb19tYW50aXNzYSIsImZsb2F0X21heF9wb3NpdGl2ZV9zdWJub3JtYWxfdiIsImZsb2F0X3N1Ym5vcm1hbF9leHBvbmVudCIsImZsb2F0X21pbl9zdWJub3JtYWxfbWFudGlzc2EiLCJmbG9hdF9tYXhfc3Vibm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1IiwiZmxvYXRfbWluX25vcm1hbF9leHBvbmVudCIsImZsb2F0X21heF9ub3JtYWxfZXhwb25lbnQiLCJmbG9hdF9tYXhfbm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfaW5mX2V4cG9uZW50IiwiZmxvYXRfaW5mX21hbnRpc3NhIiwiZmxvYXRfbmFuX2V4cG9uZW50IiwiZmxvYXRfbWluX25hbl9tYW50aXNzYSIsImZsb2F0X251bV9tYW50aXNzYV9iaXRzIiwibnVtX2JpdHMiLCJiaXRzIiwiZmxvYXRfbm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfZXhwb25lbnQiLCJmbG9hdF96ZXJvIiwibGV0X3N5bnRheF8wMTIiLCJsZXRfc3ludGF4XzAxMyIsIm1hbnRpc3NhIiwiZXhwb25lbnQiLCJmbG9hdF9zdWJub3JtYWwiLCJmbG9hdF9ub3JtYWwiLCJmbG9hdF9pbmZpbml0ZSIsImxldF9zeW50YXhfMDIxIiwibGV0X3N5bnRheF8wMjIiLCJmbG9hdF9uYW4iLCJmbG9hdF9vZl9jbGFzcyIsImMiLCJmbG9hdF9tYXRjaGluZ19jbGFzc2VzIiwiZmxvYXRfZmluaXRlIiwiZmxvYXRfd2l0aG91dF9uYW4iLCJmbG9hdF9maW5pdGVfbm9uX3plcm8iLCJmbG9hdF9zdHJpY3RseV9wb3NpdGl2ZSIsImZsb2F0X3N0cmljdGx5X25lZ2F0aXZlIiwiZmxvYXRfcG9zaXRpdmVfb3JfemVybyIsImZsb2F0X25lZ2F0aXZlX29yX3plcm8iLCJmbG9hdF91bmlmb3JtX2V4Y2x1c2l2ZSIsImxvd2VyX2luY2x1c2l2ZSIsInVwcGVyX2luY2x1c2l2ZSIsImZsb2F0X2luY2x1c2l2ZSIsInN0cmluZ193aXRoX2xlbmd0aF9vZiIsImNoYXJfZ2VuIiwic3RyaW5nX29mIiwic3RyaW5nX25vbl9lbXB0eV9vZiIsInN0cmluZyIsInN0cmluZ19ub25fZW1wdHkiLCJzdHJpbmdfd2l0aF9sZW5ndGgiLCJlZGl0X2luc2VydCIsInBvcyIsInN0ciIsImVkaXQiLCJuX3RpbWVzIiwic3RyaW5nX2xpa2UiLCJieXRlcyIsInNleHBfb2YiLCJhdG9tIiwic2V4cCIsIm1hcF90cmVlX3VzaW5nX2NvbXBhcmF0b3IiLCJjb21wYXJhdG9yIiwia2V5X2dlbiIsImRhdGFfZ2VuIiwia2V5cyIsImtleXMkMCIsImRhdGEiLCJzZXRfdHJlZV91c2luZ19jb21wYXJhdG9yIiwibWFwX3RfbSIsIm0iLCJzZXRfdF9tIiwiYmlnYXJyYXkxIiwibGVuZ3RoJDAiLCJiaWdzdHJpbmdfZ2VuIiwiZmxvYXQzMl92ZWNfZ2VuIiwiZmxvYXQ2NF92ZWNfZ2VuIiwiYmlnc3RyaW5nIiwiZmxvYXQzMl92ZWMiLCJmbG9hdDY0X3ZlYyIsImJpZ3N0cmluZ193aXRoX2xlbmd0aCIsImZsb2F0MzJfdmVjX3dpdGhfbGVuZ3RoIiwiZmxvYXQ2NF92ZWNfd2l0aF9sZW5ndGgiLCJtYXhfdG90YWxfc2l6ZSIsImEiLCJiIiwibWF4X2IiLCJiX3dlaWdodGVkX2xvdyIsImJpZ2FycmF5Ml9kaW0iLCJiaWdhcnJheTIiLCJmbG9hdDMyX21hdCIsImZsb2F0NjRfbWF0IiwiY292ZXJhZ2UiLCJDbXAiLCJzYW1wbGUiLCJjb3VudHMiLCJ2YWx1ZSIsInByZXYiLCJtb25pdG9yIiwiYXRvbWljIiwic2hyaW5rIiwiZl9pbnZlcnNlIiwib2Zfc2hyaW5rZXIiLCJzbmQiLCJmc3QiLCJzcmMiLCJ0b19za2lwIiwidG9fc2tpcCQwIiwiaSQwIiwiciIsInYiLCJkaW0yJDAiLCJkaW0xJDAiLCJzaHJpbmskMCIsImZpZWxkIiwiZGltcyIsInNraXAiLCJlbHRfdCIsImxpc3RfdCIsInRhaWwiLCJoZWFkIiwic2hyaW5rZXIiLCJsIiwic2hyaW5rX2xpc3QiLCJzaHJpbmtfdHJlZSIsImtleV90IiwiZGF0YV90IiwidHJlZSIsImsiLCJkcm9wX2tleXMiLCJrZXkiLCJ0cmVlJDAiLCJzbWFsbGVyX2tleSIsInNocmlua19rZXlzIiwic21hbGxlcl9kYXRhIiwic2hyaW5rX2RhdGEiLCJkcm9wX2VsdHMiLCJzbWFsbGVyX2VsdCIsInNocmlua19lbHRzIiwibWFwX3QiLCJzZXRfdCIsImFyZzBfMDAxIiwicmVzMF8wMDIiLCJzaXplc18wMTAiLCJzaHJpbmtfY291bnRfMDA4IiwidGVzdF9jb3VudF8wMDYiLCJzZWVkXzAwNCIsInN1ZmZpeCIsInByZWZpeCIsInByZWZpeCQwIiwiYm5kc18wMDMiLCJzdWZmaXgkMCIsImFyZ18wMTEiLCJibmRzXzAwMyQwIiwiYXJnXzAwOSIsImJuZHNfMDAzJDEiLCJhcmdfMDA3IiwiYm5kc18wMDMkMiIsImFyZ18wMDUiLCJibmRzXzAwMyQzIiwiZGVmYXVsdF9jb25maWciLCJsYXp5X25vbmRldGVybWluaXN0aWNfc3RhdGUiLCJ3aXRoX3NhbXBsZSIsImdlbmVyYXRvciIsImNvbmZpZyIsImV4YW1wbGVzIiwibnVtYmVyX29mX3NpemVfdmFsdWVzIiwicmVtYWluaW5nX3NpemVzIiwic2VxdWVuY2UiLCJpbnB1dCIsImVycm9yIiwiZXJyb3IkMSIsImlucHV0JDAiLCJzaHJpbmtfY291bnQkMSIsImFsdGVybmF0ZXMkMiIsInNocmlua19jb3VudCIsImFsdGVybmF0ZXMiLCJzaHJpbmtfY291bnQkMCIsImFsdGVybmF0ZXMkMCIsImFsdGVybmF0ZSIsImVycm9yJDAiLCJhbHRlcm5hdGVzJDEiLCJydW4iLCJNIiwiZiQwIiwid2l0aF9zYW1wbGVfZXhuIiwicnVuX2V4biIsInRlc3RhYmxlIiwidW5tYXAiLCJvZl9oYXNoX2ZvbGQiLCJ3cmFwIiwiaGFzaCQwIiwiaGFzaCQxIiwibWFwX3RyZWUiLCJrZXlfb2JzIiwiZGF0YV9vYnMiLCJzZXRfdHJlZSIsImVsdF9vYnMiXSwic291cmNlcyI6WyIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZV9xdWlja2NoZWNrL2Jhc2VfcXVpY2tjaGVja19fLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2VfcXVpY2tjaGVjay9iaWdhcnJheV9oZWxwZXJzLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2VfcXVpY2tjaGVjay9vYnNlcnZlcjAubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZV9xdWlja2NoZWNrL2dlbmVyYXRvci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9vY2FtbC9pbnQ2NC5tbGkiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZV9xdWlja2NoZWNrL3Nocmlua2VyLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2VfcXVpY2tjaGVjay90ZXN0Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2VfcXVpY2tjaGVjay9vYnNlcnZlci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlX3F1aWNrY2hlY2svYmFzZV9xdWlja2NoZWNrLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0dBNkIyQjs7SUFBQTs7OztFOzs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7O1lDeEJyQkEsYztHQUhVLGlCQUdWQTtZQVNBQyxNQUFN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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQXZFcEJkO1NBQ0FjO0lBR0ZYO0lBQ0FZO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBS0VDO0lBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBREFEO1NBQ0FDO0lBR0ZDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBS0VDO0lBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBREFEO1NBQ0FDO0lBR0ZDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lDcGFJQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQzs7O0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFD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RUMsU0FBU0M7SUFBVTtJQUFNLE9BdEZ6QlQsTUFxREFwYSxLQWlDUzZhO0dBQW1FO1lBRTVFMUQsTUFBTXVELFNBQVFDO0lBQ2hCO0lBQU0sT0F6RkpQLE1Ba0ZBSyxTQU1NQyxTQUFRQztHQUNpRDtZQUcvRHZELE1BQU15RDtJQUFVO0lBQU0sT0E1RnRCVCxNQXNGQVEsU0FNTUM7R0FBa0U7Ozs7OztPQWxGeEV6WDtPQUNBa0M7T0FPQWtNO09BT0FTO09BYkE3TDtPQUNBb0I7T0FDQVM7T0FDQXVGO09BQ0FTO09BQ0E5SDtPQUVBaU07T0E0QkEvTztPQU1BckQ7T0FZQVU7T0FDQWlFO09BQ0FoRDtPQTNCQXhCO09BYkFvRDtPQU9BRztPQWRBMlA7T0FDQUM7T0FDQUM7T0FDQVc7T0FDQUM7T0E2Q0F2VjtPQW1CQXVZO09BSUFDO09BVkFxRDtPQUlBRztPQXJGQVA7T0FEQUQ7T0FJQXhZO09BRkFGOzs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7OztHQ09hOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgQmFzZV9xdWlja2NoZWNrLkJpZ2FycmF5X2hlbHBlcnMgKilcbm1vZHVsZSBCaWdhcnJheV9oZWxwZXJzID0gQmFzZV9xdWlja2NoZWNrX19CaWdhcnJheV9oZWxwZXJzXG5cbigqKiBAY2Fub25pY2FsIEJhc2VfcXVpY2tjaGVjay5FeHBvcnQgKilcbm1vZHVsZSBFeHBvcnQgPSBCYXNlX3F1aWNrY2hlY2tfX0V4cG9ydFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlX3F1aWNrY2hlY2suR2VuZXJhdG9yICopXG5tb2R1bGUgR2VuZXJhdG9yID0gQmFzZV9xdWlja2NoZWNrX19HZW5lcmF0b3JcblxuKCoqIEBjYW5vbmljYWwgQmFzZV9xdWlja2NoZWNrLk9ic2VydmVyICopXG5tb2R1bGUgT2JzZXJ2ZXIgPSBCYXNlX3F1aWNrY2hlY2tfX09ic2VydmVyXG5cbigqKiBAY2Fub25pY2FsIEJhc2VfcXVpY2tjaGVjay5PYnNlcnZlcjAgKilcbm1vZHVsZSBPYnNlcnZlcjAgPSBCYXNlX3F1aWNrY2hlY2tfX09ic2VydmVyMFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlX3F1aWNrY2hlY2suU2hyaW5rZXIgKilcbm1vZHVsZSBTaHJpbmtlciA9IEJhc2VfcXVpY2tjaGVja19fU2hyaW5rZXJcblxuKCoqIEBjYW5vbmljYWwgQmFzZV9xdWlja2NoZWNrLlRlc3QgKilcbm1vZHVsZSBUZXN0ID0gQmFzZV9xdWlja2NoZWNrX19UZXN0XG5cbigqKiBAY2Fub25pY2FsIEJhc2VfcXVpY2tjaGVjay5UZXN0X2ludGYgKilcbm1vZHVsZSBUZXN0X2ludGYgPSBCYXNlX3F1aWNrY2hlY2tfX1Rlc3RfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlX3F1aWNrY2hlY2suV2l0aF9iYXNpY190eXBlcyAqKVxubW9kdWxlIFdpdGhfYmFzaWNfdHlwZXMgPSBCYXNlX3F1aWNrY2hlY2tfX1dpdGhfYmFzaWNfdHlwZXNcblxubW9kdWxlIEJhc2VfcXVpY2tjaGVja19fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCJvcGVuISBCYXNlXG5cbm1vZHVsZSBMYXlvdXQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgQmlnYXJyYXkubGF5b3V0XG5cbiAgbGV0IG9mZnNldCA6IHR5cGUgYS4gYSB0IC0+IGludCA9IGZ1bmN0aW9uXG4gICAgfCBCaWdhcnJheS5Gb3J0cmFuX2xheW91dCAtPiAxXG4gICAgfCBCaWdhcnJheS5DX2xheW91dCAtPiAwXG4gIDs7XG5lbmRcblxubW9kdWxlIEFycmF5MSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIEJpZ2FycmF5LkFycmF5MS50XG5cbiAgbGV0IGl0ZXJpIHQgfmYgPVxuICAgIGxldCBvZmZzZXQgPSBMYXlvdXQub2Zmc2V0IChCaWdhcnJheS5BcnJheTEubGF5b3V0IHQpIGluXG4gICAgZm9yIGkgPSAwIHRvIEJpZ2FycmF5LkFycmF5MS5kaW0gdCAtIDEgZG9cbiAgICAgIGYgKGkgKyBvZmZzZXQpIHQue2kgKyBvZmZzZXR9XG4gICAgZG9uZVxuICA7O1xuXG4gIGxldCBpbml0ICh0eXBlIGVsdCkgKGtpbmQgOiAoZWx0LCBfKSBCaWdhcnJheS5raW5kKSBsYXlvdXQgZGltIH5mID1cbiAgICBsZXQgdCA9IEJpZ2FycmF5LkFycmF5MS5jcmVhdGUga2luZCBsYXlvdXQgZGltIGluXG4gICAgaXRlcmkgdCB+ZjooZnVuIGkgKF8gOiBlbHQpIC0+IHQue2l9IDwtIGYgaSk7XG4gICAgdFxuICA7O1xuXG4gIGxldCBmb2xkICh0eXBlIGVsdCkgKHQgOiAoZWx0LCBfLCBfKSB0KSB+aW5pdCB+ZiA9XG4gICAgbGV0IGluaXQgPSByZWYgaW5pdCBpblxuICAgIGl0ZXJpIHQgfmY6KGZ1biBpIChfIDogZWx0KSAtPiBpbml0IDo9IGYgIWluaXQgdC57aX0pO1xuICAgICFpbml0XG4gIDs7XG5cbiAgbGV0IHRvX2FycmF5IHQgPVxuICAgIGxldCBvZmZzZXQgPSBMYXlvdXQub2Zmc2V0IChCaWdhcnJheS5BcnJheTEubGF5b3V0IHQpIGluXG4gICAgQXJyYXkuaW5pdCAoQmlnYXJyYXkuQXJyYXkxLmRpbSB0KSB+ZjooZnVuIGkgLT4gdC57aSArIG9mZnNldH0pXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2VsdCBfc2V4cF9vZl9wYWNrIF9zZXhwX29mX2xheW91dCB0ID1cbiAgICBbJXNleHAgKHRvX2FycmF5IHQgOiBlbHQgYXJyYXkpXVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGQgaGFzaF9mb2xkX2VsdCBzdGF0ZSB0ID1cbiAgICBsZXQgc3RhdGUgPSBoYXNoX2ZvbGRfaW50IHN0YXRlIChCaWdhcnJheS5BcnJheTEuZGltIHQpIGluXG4gICAgZm9sZCB0IH5pbml0OnN0YXRlIH5mOmhhc2hfZm9sZF9lbHRcbiAgOztcbmVuZFxuXG5tb2R1bGUgQXJyYXkyID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgQmlnYXJyYXkuQXJyYXkyLnRcblxuICBsZXQgaXRlcmkgdCB+ZiA9XG4gICAgbGV0IG9mZnNldCA9IExheW91dC5vZmZzZXQgKEJpZ2FycmF5LkFycmF5Mi5sYXlvdXQgdCkgaW5cbiAgICBmb3IgaSA9IDAgdG8gQmlnYXJyYXkuQXJyYXkyLmRpbTEgdCAtIDEgZG9cbiAgICAgIGZvciBqID0gMCB0byBCaWdhcnJheS5BcnJheTIuZGltMiB0IC0gMSBkb1xuICAgICAgICBmIChpICsgb2Zmc2V0KSAoaiArIG9mZnNldCkgdC57aSArIG9mZnNldCwgaiArIG9mZnNldH1cbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIDs7XG5cbiAgbGV0IGluaXQgKHR5cGUgZWx0KSAoa2luZCA6IChlbHQsIF8pIEJpZ2FycmF5LmtpbmQpIGxheW91dCBkaW0xIGRpbTIgfmYgPVxuICAgIGxldCB0ID0gQmlnYXJyYXkuQXJyYXkyLmNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBpdGVyaSB0IH5mOihmdW4gaSBqIChfIDogZWx0KSAtPiB0LntpLCBqfSA8LSBmIGkgaik7XG4gICAgdFxuICA7O1xuXG4gIGxldCBmb2xkICh0eXBlIGVsdCkgKHQgOiAoZWx0LCBfLCBfKSB0KSB+aW5pdCB+ZiA9XG4gICAgbGV0IGluaXQgPSByZWYgaW5pdCBpblxuICAgIGl0ZXJpIHQgfmY6KGZ1biAoXyA6IGludCkgKF8gOiBpbnQpIGVsdCAtPiBpbml0IDo9IGYgIWluaXQgZWx0KTtcbiAgICAhaW5pdFxuICA7O1xuXG4gIGxldCB0b19hcnJheSB0ID1cbiAgICBsZXQgb2Zmc2V0ID0gTGF5b3V0Lm9mZnNldCAoQmlnYXJyYXkuQXJyYXkyLmxheW91dCB0KSBpblxuICAgIEFycmF5LmluaXQgKEJpZ2FycmF5LkFycmF5Mi5kaW0xIHQpIH5mOihmdW4gaSAtPlxuICAgICAgQXJyYXkuaW5pdCAoQmlnYXJyYXkuQXJyYXkyLmRpbTIgdCkgfmY6KGZ1biBqIC0+IHQue2kgKyBvZmZzZXQsIGogKyBvZmZzZXR9KSlcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfZWx0IF9zZXhwX29mX3BhY2sgX3NleHBfb2ZfbGF5b3V0IHQgPVxuICAgIFslc2V4cCAodG9fYXJyYXkgdCA6IGVsdCBhcnJheSBhcnJheSldXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZCBoYXNoX2ZvbGRfZWx0IHN0YXRlIHQgPVxuICAgIGxldCBzdGF0ZSA9IGhhc2hfZm9sZF9pbnQgc3RhdGUgKEJpZ2FycmF5LkFycmF5Mi5kaW0xIHQpIGluXG4gICAgbGV0IHN0YXRlID0gaGFzaF9mb2xkX2ludCBzdGF0ZSAoQmlnYXJyYXkuQXJyYXkyLmRpbTIgdCkgaW5cbiAgICBmb2xkIHQgfmluaXQ6c3RhdGUgfmY6aGFzaF9mb2xkX2VsdFxuICA7O1xuZW5kXG4iLCJvcGVuISBCYXNlXG5cbnR5cGUgJ2EgdCA9ICdhIC0+IHNpemU6aW50IC0+IGhhc2g6SGFzaC5zdGF0ZSAtPiBIYXNoLnN0YXRlXG5cbmxldCBjcmVhdGUgZiA6IF8gdCA9IGZcblxubGV0IG9ic2VydmUgKHQgOiBfIHQpIHggfnNpemUgfmhhc2ggPVxuICBpZiBzaXplIDwgMFxuICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLk9ic2VydmVyLm9ic2VydmU6IHNpemUgPCAwXCIgKHNpemUgOiBpbnQpXVxuICBlbHNlIHQgeCB+c2l6ZSB+aGFzaFxuOztcblxubGV0IG9wYXF1ZSBfIH5zaXplOl8gfmhhc2ggPSBoYXNoXG4iLCJvcGVuISBCYXNlXG5cbm1vZHVsZSBUIDogc2lnXG4gIHR5cGUgKydhIHRcblxuICB2YWwgY3JlYXRlIDogKHNpemU6aW50IC0+IHJhbmRvbTpTcGxpdHRhYmxlX3JhbmRvbS50IC0+ICdhKSAtPiAnYSB0XG4gIHZhbCBnZW5lcmF0ZSA6ICdhIHQgLT4gc2l6ZTppbnQgLT4gcmFuZG9tOlNwbGl0dGFibGVfcmFuZG9tLnQgLT4gJ2FcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAoc2l6ZTppbnQgLT4gcmFuZG9tOlNwbGl0dGFibGVfcmFuZG9tLnQgLT4gJ2EpIFN0YWdlZC50XG5cbiAgbGV0IGNyZWF0ZSBmIDogXyB0ID0gU3RhZ2VkLnN0YWdlIGZcblxuICBsZXQgZ2VuZXJhdGUgKHQgOiBfIHQpIH5zaXplIH5yYW5kb20gPVxuICAgIGlmIHNpemUgPCAwXG4gICAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3IuZ2VuZXJhdGU6IHNpemUgPCAwXCIgKHNpemUgOiBpbnQpXVxuICAgIGVsc2UgU3RhZ2VkLnVuc3RhZ2UgdCB+c2l6ZSB+cmFuZG9tXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBzaXplID0gY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbTpfIC0+IHNpemUpXG5cbmxldCBmbiBkb20gcm5nID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIGxldCByYW5kb20gPSBTcGxpdHRhYmxlX3JhbmRvbS5zcGxpdCByYW5kb20gaW5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IGhhc2ggPSBPYnNlcnZlcjAub2JzZXJ2ZSBkb20geCB+c2l6ZSB+aGFzaDooSGFzaC5hbGxvYyAoKSkgaW5cbiAgICAgIGxldCByYW5kb20gPSBTcGxpdHRhYmxlX3JhbmRvbS5jb3B5IHJhbmRvbSBpblxuICAgICAgU3BsaXR0YWJsZV9yYW5kb20ucGVydHVyYiByYW5kb20gKEhhc2guZ2V0X2hhc2hfdmFsdWUgaGFzaCk7XG4gICAgICBnZW5lcmF0ZSBybmcgfnNpemUgfnJhbmRvbSlcbjs7XG5cbmxldCB3aXRoX3NpemUgdCB+c2l6ZSA9IGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPiBnZW5lcmF0ZSB0IH5zaXplIH5yYW5kb20pXG5cbmxldCBwZXJ0dXJiIHQgc2FsdCA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBTcGxpdHRhYmxlX3JhbmRvbS5wZXJ0dXJiIHJhbmRvbSBzYWx0O1xuICAgIGdlbmVyYXRlIHQgfnNpemUgfnJhbmRvbSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgfnNpemUgfnJhbmRvbSA9XG4gICAgbGV0IHggPSBnZW5lcmF0ZSB0IH5zaXplIH5yYW5kb20gaW5cbiAgICBtYXRjaCBmIHggd2l0aFxuICAgIHwgU29tZSB5IC0+IHlcbiAgICB8IE5vbmUgLT4gbG9vcCB+c2l6ZTooc2l6ZSArIDEpIH5yYW5kb21cbiAgaW5cbiAgY3JlYXRlIGxvb3Bcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcl9tYXAgdCB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSlcbmxldCByZXR1cm4geCA9IGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbTpfIC0+IHgpXG5sZXQgbWFwIHQgfmYgPSBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+IGYgKGdlbmVyYXRlIHQgfnNpemUgfnJhbmRvbSkpXG5cbmxldCBhcHBseSB0ZiB0eCA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBsZXQgZiA9IGdlbmVyYXRlIHRmIH5zaXplIH5yYW5kb20gaW5cbiAgICBsZXQgeCA9IGdlbmVyYXRlIHR4IH5zaXplIH5yYW5kb20gaW5cbiAgICBmIHgpXG47O1xuXG5sZXQgYmluZCB0IH5mID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIGxldCB4ID0gZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tIGluXG4gICAgZ2VuZXJhdGUgKGYgeCkgfnNpemUgfnJhbmRvbSlcbjs7XG5cbmxldCBhbGwgbGlzdCA9IGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT4gTGlzdC5tYXAgbGlzdCB+ZjooZ2VuZXJhdGUgfnNpemUgfnJhbmRvbSkpXG5cbmxldCBhbGxfdW5pdCBsaXN0ID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPiBMaXN0Lml0ZXIgbGlzdCB+ZjooZ2VuZXJhdGUgfnNpemUgfnJhbmRvbSkpXG47O1xuXG5tb2R1bGUgRm9yX2FwcGxpY2F0aXZlID0gQXBwbGljYXRpdmUuTWFrZSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IHJldHVybiA9IHJldHVyblxuICBsZXQgYXBwbHkgPSBhcHBseVxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbmVuZClcblxubGV0IGJvdGggPSBGb3JfYXBwbGljYXRpdmUuYm90aFxubGV0IG1hcDIgPSBGb3JfYXBwbGljYXRpdmUubWFwMlxubGV0IG1hcDMgPSBGb3JfYXBwbGljYXRpdmUubWFwM1xuXG5tb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBGb3JfYXBwbGljYXRpdmUuQXBwbGljYXRpdmVfaW5maXhcbmluY2x1ZGUgQXBwbGljYXRpdmVfaW5maXhcblxubW9kdWxlIEZvcl9tb25hZCA9IE1vbmFkLk1ha2UgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCByZXR1cm4gPSByZXR1cm5cbiAgbGV0IGJpbmQgPSBiaW5kXG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuZW5kKVxuXG5sZXQgaWdub3JlX20gPSBGb3JfbW9uYWQuaWdub3JlX21cbmxldCBqb2luID0gRm9yX21vbmFkLmpvaW5cblxubW9kdWxlIE1vbmFkX2luZml4ID0gRm9yX21vbmFkLk1vbmFkX2luZml4XG5pbmNsdWRlIE1vbmFkX2luZml4XG5tb2R1bGUgTGV0X3N5bnRheCA9IEZvcl9tb25hZC5MZXRfc3ludGF4XG5vcGVuIExldF9zeW50YXhcblxubGV0IG9mX2xpc3QgbGlzdCA9XG4gIGlmIExpc3QuaXNfZW1wdHkgbGlzdFxuICB0aGVuIEVycm9yLnJhaXNlX3MgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl9saXN0OiBlbXB0eSBsaXN0XCJdO1xuICBsZXQgYXJyYXkgPSBBcnJheS5vZl9saXN0IGxpc3QgaW5cbiAgbGV0IGxvID0gMCBpblxuICBsZXQgaGkgPSBBcnJheS5sZW5ndGggYXJyYXkgLSAxIGluXG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIGxldCBpbmRleCA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvIH5oaSBpblxuICAgIGFycmF5LihpbmRleCkpXG47O1xuXG5sZXQgdW5pb24gbGlzdCA9IGpvaW4gKG9mX2xpc3QgbGlzdClcblxubGV0IG9mX3dlaWdodGVkX2xpc3QgYWxpc3QgPVxuICBpZiBMaXN0LmlzX2VtcHR5IGFsaXN0XG4gIHRoZW4gRXJyb3IucmFpc2VfcyBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suR2VuZXJhdG9yLm9mX3dlaWdodGVkX2xpc3Q6IGVtcHR5IGxpc3RcIl07XG4gIGxldCB3ZWlnaHRzLCB2YWx1ZXMgPSBMaXN0LnVuemlwIGFsaXN0IGluXG4gIGxldCB2YWx1ZV9hcnJheSA9IEFycmF5Lm9mX2xpc3QgdmFsdWVzIGluXG4gIGxldCB0b3RhbF93ZWlnaHQsIGN1bXVsYXRpdmVfd2VpZ2h0X2FycmF5ID1cbiAgICBsZXQgYXJyYXkgPSBBcnJheS5pbml0IChBcnJheS5sZW5ndGggdmFsdWVfYXJyYXkpIH5mOihmdW4gXyAtPiAwLikgaW5cbiAgICBsZXQgc3VtID1cbiAgICAgIExpc3QuZm9sZGkgd2VpZ2h0cyB+aW5pdDowLiB+ZjooZnVuIGluZGV4IGFjYyB3ZWlnaHQgLT5cbiAgICAgICAgaWYgbm90IChGbG9hdC5pc19maW5pdGUgd2VpZ2h0KVxuICAgICAgICB0aGVuXG4gICAgICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl93ZWlnaHRlZF9saXN0OiB3ZWlnaHQgaXMgbm90IGZpbml0ZVwiXG4gICAgICAgICAgICAgICAgKHdlaWdodCA6IGZsb2F0KV07XG4gICAgICAgIGlmIEZsb2F0LiggPCApIHdlaWdodCAwLlxuICAgICAgICB0aGVuXG4gICAgICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl93ZWlnaHRlZF9saXN0OiB3ZWlnaHQgaXMgbmVnYXRpdmVcIlxuICAgICAgICAgICAgICAgICh3ZWlnaHQgOiBmbG9hdCldO1xuICAgICAgICBsZXQgY3VtdWxhdGl2ZSA9IGFjYyArLiB3ZWlnaHQgaW5cbiAgICAgICAgYXJyYXkuKGluZGV4KSA8LSBjdW11bGF0aXZlO1xuICAgICAgICBjdW11bGF0aXZlKVxuICAgIGluXG4gICAgaWYgRmxvYXQuKCA8PSApIHN1bSAwLlxuICAgIHRoZW5cbiAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl93ZWlnaHRlZF9saXN0OiB0b3RhbCB3ZWlnaHQgaXMgemVyb1wiXTtcbiAgICBzdW0sIGFycmF5XG4gIGluXG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIGxldCBjaG9pY2UgPSBTcGxpdHRhYmxlX3JhbmRvbS5mbG9hdCByYW5kb20gfmxvOjAuIH5oaTp0b3RhbF93ZWlnaHQgaW5cbiAgICBtYXRjaFxuICAgICAgQXJyYXkuYmluYXJ5X3NlYXJjaFxuICAgICAgICBjdW11bGF0aXZlX3dlaWdodF9hcnJheVxuICAgICAgICB+Y29tcGFyZTpGbG9hdC5jb21wYXJlXG4gICAgICAgIGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG9cbiAgICAgICAgY2hvaWNlXG4gICAgd2l0aFxuICAgIHwgU29tZSBpbmRleCAtPiB2YWx1ZV9hcnJheS4oaW5kZXgpXG4gICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbmxldCB3ZWlnaHRlZF91bmlvbiBhbGlzdCA9IGpvaW4gKG9mX3dlaWdodGVkX2xpc3QgYWxpc3QpXG5sZXQgb2ZfbGF6eSBsYXp5X3QgPSBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+IGdlbmVyYXRlIChmb3JjZSBsYXp5X3QpIH5zaXplIH5yYW5kb20pXG5cbmxldCBmaXhlZF9wb2ludCBvZl9nZW5lcmF0b3IgPVxuICBsZXQgcmVjIGxhenlfdCA9IGxhenkgKG9mX2dlbmVyYXRvciAob2ZfbGF6eSBsYXp5X3QpKSBpblxuICBmb3JjZSBsYXp5X3Rcbjs7XG5cbmxldCB3ZWlnaHRlZF9yZWN1cnNpdmVfdW5pb24gbm9ucmVjX2xpc3QgfmYgPVxuICBmaXhlZF9wb2ludCAoZnVuIHNlbGYgLT5cbiAgICBsZXQgcmVjX2xpc3QgPVxuICAgICAgTGlzdC5tYXAgKGYgc2VsZikgfmY6KGZ1biAodywgdCkgLT5cbiAgICAgICAgKCB3XG4gICAgICAgICwgbGV0JWJpbmQgbiA9IHNpemUgaW5cbiAgICAgICAgICB3aXRoX3NpemUgfnNpemU6KG4gLSAxKSB0ICkpXG4gICAgaW5cbiAgICBpZiBMaXN0LmlzX2VtcHR5IG5vbnJlY19saXN0IHx8IExpc3QuaXNfZW1wdHkgcmVjX2xpc3RcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci53ZWlnaHRlZF9yZWN1cnNpdmVfdW5pb246IGxpc3RzIG11c3QgYmUgbm9uLWVtcHR5XCJdO1xuICAgIGxldCBub25yZWNfZ2VuID0gd2VpZ2h0ZWRfdW5pb24gbm9ucmVjX2xpc3QgaW5cbiAgICBsZXQgcmVjX2dlbiA9IHdlaWdodGVkX3VuaW9uIChub25yZWNfbGlzdCBAIHJlY19saXN0KSBpblxuICAgIG1hdGNoJWJpbmQgc2l6ZSB3aXRoXG4gICAgfCAwIC0+IG5vbnJlY19nZW5cbiAgICB8IF8gLT4gcmVjX2dlbilcbjs7XG5cbmxldCByZWN1cnNpdmVfdW5pb24gbm9ucmVjX2xpc3QgfmYgPVxuICBsZXQgd2VpZ2h0ZWQgbGlzdCA9IExpc3QubWFwIGxpc3QgfmY6KGZ1biB0IC0+IDEuLCB0KSBpblxuICB3ZWlnaHRlZF9yZWN1cnNpdmVfdW5pb24gKHdlaWdodGVkIG5vbnJlY19saXN0KSB+ZjooZnVuIHNlbGYgLT4gd2VpZ2h0ZWQgKGYgc2VsZikpXG47O1xuXG5sZXQgc2l6ZXMgPyhtaW5fbGVuZ3RoID0gMCkgPyhtYXhfbGVuZ3RoID0gSW50Lm1heF92YWx1ZSkgKCkgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgYXNzZXJ0IChtaW5fbGVuZ3RoIDw9IG1heF9sZW5ndGgpO1xuICAgIGxldCB1cHBlcl9ib3VuZCA9IG1pbl9sZW5ndGggKyBzaXplIGluXG4gICAgbGV0IG1heF9sZW5ndGggPVxuICAgICAgaWYgdXBwZXJfYm91bmQgPj0gbWluX2xlbmd0aCAoKiBndWFyZCBhZ2FpbnN0IG92ZXJmbG93ICopXG4gICAgICB0aGVuIG1pbiBtYXhfbGVuZ3RoIHVwcGVyX2JvdW5kXG4gICAgICBlbHNlIG1heF9sZW5ndGhcbiAgICBpblxuICAgICgqIHBpY2sgYSBsZW5ndGgsIHdlaWdodGVkIGxvdyBzbyB0aGF0IG1vc3Qgb2YgdGhlIHNpemUgaXMgc3BlbnQgb24gZWxlbWVudHMgKilcbiAgICBsZXQgbGVuID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50IHJhbmRvbSB+bG86bWluX2xlbmd0aCB+aGk6bWF4X2xlbmd0aCBpblxuICAgICgqIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyByZXR1cm4gYW4gZW1wdHkgYXJyYXksIG90aGVyd2lzZSByZXR1cm4gYSBub24tZW1wdHkgYXJyYXlcbiAgICAgICB3aXRoIHRoZSBzaXplIGRpc3RyaWJ1dGVkIGFtb25nIHRoZSBlbGVtZW50cyAqKVxuICAgIGlmIGxlbiA9IDBcbiAgICB0aGVuIFtdXG4gICAgZWxzZSAoXG4gICAgICBsZXQgc2l6ZXMgPSBBcnJheS5pbml0IGxlbiB+ZjooZnVuIF8gLT4gMCkgaW5cbiAgICAgIGxldCByZW1haW5pbmcgPSBzaXplIC0gKGxlbiAtIG1pbl9sZW5ndGgpIGluXG4gICAgICBsZXQgbWF4X2luZGV4ID0gbGVuIC0gMSBpblxuICAgICAgZm9yIF8gPSAxIHRvIHJlbWFpbmluZyBkb1xuICAgICAgICAoKiBwaWNrIGFuIGluZGV4LCB3ZWlnaHRlZCBsb3cgc28gdGhhdCB3ZSBzZWUgdW5iYWxhbmNlZCBkaXN0cmlidXRpb25zIG9mdGVuICopXG4gICAgICAgIGxldCBpbmRleCA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludCByYW5kb20gfmxvOjAgfmhpOm1heF9pbmRleCBpblxuICAgICAgICBzaXplcy4oaW5kZXgpIDwtIHNpemVzLihpbmRleCkgKyAxXG4gICAgICBkb25lO1xuICAgICAgKCogcGVybXV0ZSB0aGUgYXJyYXkgc28gdGhhdCBubyBpbmRleCBpcyBmYXZvcmVkIG92ZXIgYW5vdGhlciAqKVxuICAgICAgZm9yIGkgPSAwIHRvIG1heF9pbmRleCAtIDEgZG9cbiAgICAgICAgbGV0IGogPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbzppIH5oaTptYXhfaW5kZXggaW5cbiAgICAgICAgQXJyYXkuc3dhcCBzaXplcyBpIGpcbiAgICAgIGRvbmU7XG4gICAgICBhc3NlcnQgKEFycmF5LnN1bSAobW9kdWxlIEludCkgc2l6ZXMgfmY6Rm4uaWQgKyAobGVuIC0gbWluX2xlbmd0aCkgPSBzaXplKTtcbiAgICAgIEFycmF5LnRvX2xpc3Qgc2l6ZXMpKVxuOztcblxubGV0IHVuaXQgPSByZXR1cm4gKClcbmxldCBib29sID0gY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+IFNwbGl0dGFibGVfcmFuZG9tLmJvb2wgcmFuZG9tKVxubGV0IG9wdGlvbiB2YWx1ZV90ID0gdW5pb24gWyByZXR1cm4gTm9uZTsgbWFwIHZhbHVlX3QgfmY6T3B0aW9uLnJldHVybiBdXG5sZXQgZWl0aGVyIGZzdF90IHNuZF90ID0gdW5pb24gWyBtYXAgZnN0X3QgfmY6RWl0aGVyLmZpcnN0OyBtYXAgc25kX3QgfmY6RWl0aGVyLnNlY29uZCBdXG5cbmxldCByZXN1bHQgb2tfdCBlcnJfdCA9XG4gIG1hcCAoZWl0aGVyIG9rX3QgZXJyX3QpIH5mOihmdW5jdGlvblxuICAgIHwgRmlyc3Qgb2sgLT4gT2sgb2tcbiAgICB8IFNlY29uZCBlcnIgLT4gRXJyb3IgZXJyKVxuOztcblxubGV0IGxpc3RfZ2VuZXJpYyA/bWluX2xlbmd0aCA/bWF4X2xlbmd0aCBlbHRfZ2VuID1cbiAgbGV0JWJpbmQgc2l6ZXMgPSBzaXplcyA/bWluX2xlbmd0aCA/bWF4X2xlbmd0aCAoKSBpblxuICBMaXN0Lm1hcCBzaXplcyB+ZjooZnVuIHNpemUgLT4gd2l0aF9zaXplIH5zaXplIGVsdF9nZW4pIHw+IGFsbFxuOztcblxubGV0IGxpc3QgZWx0X2dlbiA9IGxpc3RfZ2VuZXJpYyBlbHRfZ2VuXG5sZXQgbGlzdF9ub25fZW1wdHkgZWx0X2dlbiA9IGxpc3RfZ2VuZXJpYyB+bWluX2xlbmd0aDoxIGVsdF9nZW5cblxubGV0IGxpc3Rfd2l0aF9sZW5ndGggZWx0X2dlbiB+bGVuZ3RoID1cbiAgbGlzdF9nZW5lcmljIH5taW5fbGVuZ3RoOmxlbmd0aCB+bWF4X2xlbmd0aDpsZW5ndGggZWx0X2dlblxuOztcblxubGV0IGxpc3RfZmlsdGVyZWQgZWx0cyA9XG4gIGxldCBlbHRzID0gQXJyYXkub2ZfbGlzdCBlbHRzIGluXG4gIGxldCBsZW5ndGhfb2ZfaW5wdXQgPSBBcnJheS5sZW5ndGggZWx0cyBpblxuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBsZXQgbGVuZ3RoX29mX291dHB1dCA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOjAgfmhpOmxlbmd0aF9vZl9pbnB1dCBpblxuICAgIGxldCBpbmRpY2VzID0gQXJyYXkuaW5pdCBsZW5ndGhfb2ZfaW5wdXQgfmY6Rm4uaWQgaW5cbiAgICAoKiBDaG9vc2UgW2xlbmd0aF9vZl9vdXRwdXRdIHJhbmRvbSB2YWx1ZXMgaW4gdGhlIHByZWZpeCBvZiBbaW5kaWNlc10uICopXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aF9vZl9vdXRwdXQgLSAxIGRvXG4gICAgICBsZXQgaiA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOmkgfmhpOihsZW5ndGhfb2ZfaW5wdXQgLSAxKSBpblxuICAgICAgQXJyYXkuc3dhcCBpbmRpY2VzIGkgalxuICAgIGRvbmU7XG4gICAgKCogU29ydCB0aGUgY2hvc2VuIGluZGljZXMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIHJlb3JkZXIgdGhlbS4gKilcbiAgICBBcnJheS5zb3J0IGluZGljZXMgfnBvczowIH5sZW46bGVuZ3RoX29mX291dHB1dCB+Y29tcGFyZTpJbnQuY29tcGFyZTtcbiAgICAoKiBSZXR1cm4gdGhlIGNob3NlbiBlbGVtZW50cy4gKilcbiAgICBMaXN0LmluaXQgbGVuZ3RoX29mX291dHB1dCB+ZjooZnVuIGkgLT4gZWx0cy4oaW5kaWNlcy4oaSkpKSlcbjs7XG5cbmxldCBsaXN0X3Blcm11dGF0aW9ucyBsaXN0ID1cbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgbGV0IGFycmF5ID0gQXJyYXkub2ZfbGlzdCBsaXN0IGluXG4gICAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnJheSAtIDEgZG9cbiAgICAgIGxldCBqID0gU3BsaXR0YWJsZV9yYW5kb20uaW50IHJhbmRvbSB+bG86MCB+aGk6aSBpblxuICAgICAgQXJyYXkuc3dhcCBhcnJheSBpIGpcbiAgICBkb25lO1xuICAgIEFycmF5LnRvX2xpc3QgYXJyYXkpXG47O1xuXG5sZXQgYXJyYXkgdCA9IG1hcCAobGlzdCB0KSB+ZjpBcnJheS5vZl9saXN0XG5sZXQgcmVmIHQgPSBtYXAgdCB+ZjpSZWYuY3JlYXRlXG5sZXQgbGF6eV90IHQgPSBtYXAgdCB+ZjpMYXp5LmZyb21fdmFsXG5cbmxldCBjaGFyX3VuaWZvcm1faW5jbHVzaXZlIGxvIGhpID1cbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgU3BsaXR0YWJsZV9yYW5kb20uaW50IHJhbmRvbSB+bG86KENoYXIudG9faW50IGxvKSB+aGk6KENoYXIudG9faW50IGhpKVxuICAgIHw+IENoYXIudW5zYWZlX29mX2ludClcbjs7XG5cbmxldCBjaGFyX3VwcGVyY2FzZSA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgJ0EnICdaJ1xubGV0IGNoYXJfbG93ZXJjYXNlID0gY2hhcl91bmlmb3JtX2luY2x1c2l2ZSAnYScgJ3onXG5sZXQgY2hhcl9kaWdpdCA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgJzAnICc5J1xubGV0IGNoYXJfcHJpbnRfdW5pZm9ybSA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgJyAnICd+J1xubGV0IGNoYXJfdW5pZm9ybSA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgQ2hhci5taW5fdmFsdWUgQ2hhci5tYXhfdmFsdWVcbmxldCBjaGFyX2FscGhhID0gdW5pb24gWyBjaGFyX2xvd2VyY2FzZTsgY2hhcl91cHBlcmNhc2UgXVxuXG5sZXQgY2hhcl9hbHBoYW51bSA9XG4gIHdlaWdodGVkX3VuaW9uXG4gICAgKCogTW9zdCBwZW9wbGUgcHJvYmFibHkgZXhwZWN0IHRoaXMgdG8gYmUgYSB1bmlmb3JtIGRpc3RyaWJ1dGlvbiwgbm90IHdlaWdodGVkXG4gICAgICAgdG93YXJkIGRpZ2l0cyBsaWtlIHdlIHdvdWxkIGdldCB3aXRoIFt1bmlvbl0gKHNpbmNlIHRoZXJlIGFyZSBmZXdlciBkaWdpdHMgdGhhblxuICAgICAgIGxldHRlcnMpLiAqKVxuICAgIFsgNTIuLCBjaGFyX2FscGhhOyAxMC4sIGNoYXJfZGlnaXQgXVxuOztcblxubGV0IGNoYXJfd2hpdGVzcGFjZSA9IG9mX2xpc3QgKExpc3QuZmlsdGVyIENoYXIuYWxsIH5mOkNoYXIuaXNfd2hpdGVzcGFjZSlcbmxldCBjaGFyX3ByaW50ID0gd2VpZ2h0ZWRfdW5pb24gWyAxMC4sIGNoYXJfYWxwaGFudW07IDEuLCBjaGFyX3ByaW50X3VuaWZvcm0gXVxuXG5sZXQgY2hhciA9XG4gIHdlaWdodGVkX3VuaW9uXG4gICAgWyAxMDAuLCBjaGFyX3ByaW50XG4gICAgOyAxMC4sIGNoYXJfdW5pZm9ybVxuICAgIDsgMS4sIHJldHVybiBDaGFyLm1pbl92YWx1ZVxuICAgIDsgMS4sIHJldHVybiBDaGFyLm1heF92YWx1ZVxuICAgIF1cbjs7XG5cbigqIFByb2R1Y2VzIGEgbnVtYmVyIGZyb20gMCBvciAxIHRvIHNpemUgKyAxLCB3ZWlnaHRlZCBoaWdoLiBXZSBoYXZlIGZvdW5kIHRoaXNcbiAgIGRpc3RyaWJ1dGlvbiBlbXBpcmljYWxseSB1c2VmdWwgZm9yIHN0cmluZyBsZW5ndGhzLiAqKVxubGV0IHNtYWxsX2ludCB+YWxsb3dfemVybyA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBsZXQgbG93ZXJfYm91bmQgPSBpZiBhbGxvd196ZXJvIHRoZW4gMCBlbHNlIDEgaW5cbiAgICBsZXQgdXBwZXJfYm91bmQgPSBzaXplICsgMSBpblxuICAgIGxldCB3ZWlnaHRlZF9sb3cgPVxuICAgICAgU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50IHJhbmRvbSB+bG86MCB+aGk6KHVwcGVyX2JvdW5kIC0gbG93ZXJfYm91bmQpXG4gICAgaW5cbiAgICBsZXQgd2VpZ2h0ZWRfaGlnaCA9IHVwcGVyX2JvdW5kIC0gd2VpZ2h0ZWRfbG93IGluXG4gICAgd2VpZ2h0ZWRfaGlnaClcbjs7XG5cbmxldCBzbWFsbF9wb3NpdGl2ZV9vcl96ZXJvX2ludCA9IHNtYWxsX2ludCB+YWxsb3dfemVybzp0cnVlXG5sZXQgc21hbGxfc3RyaWN0bHlfcG9zaXRpdmVfaW50ID0gc21hbGxfaW50IH5hbGxvd196ZXJvOmZhbHNlXG5cbm1vZHVsZSB0eXBlIEludF93aXRoX3JhbmRvbSA9IHNpZ1xuICBpbmNsdWRlIEludC5TXG5cbiAgdmFsIHVuaWZvcm0gOiBTcGxpdHRhYmxlX3JhbmRvbS50IC0+IGxvOnQgLT4gaGk6dCAtPiB0XG4gIHZhbCBsb2dfdW5pZm9ybSA6IFNwbGl0dGFibGVfcmFuZG9tLnQgLT4gbG86dCAtPiBoaTp0IC0+IHRcbmVuZFxuXG5tb2R1bGUgRm9yX2ludGVnZXIgKEludGVnZXIgOiBJbnRfd2l0aF9yYW5kb20pID0gc3RydWN0XG4gIGxldCBnZW9tZXRyaWMgbG8gfnAgPVxuICAgIGlmIEZsb2F0LmVxdWFsIHAgMS5cbiAgICB0aGVuIHJldHVybiBsb1xuICAgIGVsc2UgaWYgRmxvYXQuZXF1YWwgcCAwLlxuICAgIHRoZW4gcmV0dXJuIEludGVnZXIubWF4X3ZhbHVlXG4gICAgZWxzZSBpZiBGbG9hdC4oIDwgKSBwIDAuIHx8IEZsb2F0LiggPiApIHAgMS4gfHwgRmxvYXQuaXNfbmFuIHBcbiAgICB0aGVuXG4gICAgICByYWlzZV9zIFslbWVzc2FnZSBcImdlb21ldHJpYyBkaXN0cmlidXRpb246IHAgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDFcIiAocCA6IGZsb2F0KV1cbiAgICBlbHNlIChcbiAgICAgICgqIFdlIHN0YXJ0IHdpdGggYSB1bmlmb3JtIGRpc3RyaWJ1dGlvbi4gV2UgY29udmVydCB0byBleHBvbmVudGlhbCBkaXN0cmlidXRpb25cbiAgICAgICAgIHVzaW5nIFtsb2ddLiBXZSBjb252ZXJ0IHRvIGdlb21ldHJpYyB3aXRoIFtyb3VuZF9kb3duXS4gVGhlbiB3ZSBib3VuZHMgY2hlY2sgYW5kXG4gICAgICAgICByZXR1cm4uICopXG4gICAgICBsZXQgZGVub21pbmF0b3IgPSBGbG9hdC5sb2cxcCAoLS5wKSBpblxuICAgICAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20udW5pdF9mbG9hdCByYW5kb20gaW5cbiAgICAgICAgbGV0IGV4cG9uZW50aWFsID0gRmxvYXQubG9nIHVuaWZvcm0gLy4gZGVub21pbmF0b3IgaW5cbiAgICAgICAgbGV0IGZsb2F0ID0gRmxvYXQucm91bmRfZG93biBleHBvbmVudGlhbCBpblxuICAgICAgICBtYXRjaCBJbnRlZ2VyLm9mX2Zsb2F0IGZsb2F0IHdpdGhcbiAgICAgICAgfCBleGNlcHRpb24gSW52YWxpZF9hcmd1bWVudCBfIC0+IEludGVnZXIubWF4X3ZhbHVlXG4gICAgICAgIHwgaW50IC0+XG4gICAgICAgICAgbGV0IGludCA9IEludGVnZXIuKCArICkgbG8gaW50IGluXG4gICAgICAgICAgaWYgSW50ZWdlci4oIDwgKSBpbnQgbG8gdGhlbiBJbnRlZ2VyLm1heF92YWx1ZSBlbHNlIGludCkpXG4gIDs7XG5cbiAgbGV0IHVuaWZvcm1faW5jbHVzaXZlIGxvIGhpID1cbiAgICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT4gSW50ZWdlci51bmlmb3JtIHJhbmRvbSB+bG8gfmhpKVxuICA7O1xuXG4gIGxldCBsb2dfdW5pZm9ybV9pbmNsdXNpdmUgbG8gaGkgPVxuICAgIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPiBJbnRlZ2VyLmxvZ191bmlmb3JtIHJhbmRvbSB+bG8gfmhpKVxuICA7O1xuXG4gIGxldCBub25fdW5pZm9ybSBmIGxvIGhpID1cbiAgICB3ZWlnaHRlZF91bmlvbiBbIDAuMDUsIHJldHVybiBsbzsgMC4wNSwgcmV0dXJuIGhpOyAwLjksIGYgbG8gaGkgXVxuICA7O1xuXG4gIGxldCBpbmNsdXNpdmUgPSBub25fdW5pZm9ybSB1bmlmb3JtX2luY2x1c2l2ZVxuICBsZXQgbG9nX2luY2x1c2l2ZSA9IG5vbl91bmlmb3JtIGxvZ191bmlmb3JtX2luY2x1c2l2ZVxuICBsZXQgdW5pZm9ybV9hbGwgPSB1bmlmb3JtX2luY2x1c2l2ZSBJbnRlZ2VyLm1pbl92YWx1ZSBJbnRlZ2VyLm1heF92YWx1ZVxuXG4gIGxldCBhbGwgPVxuICAgIFslbWFwXG4gICAgICBsZXQgbmVnYXRpdmUgPSBib29sXG4gICAgICBhbmQgbWFnbml0dWRlID0gbG9nX2luY2x1c2l2ZSBJbnRlZ2VyLnplcm8gSW50ZWdlci5tYXhfdmFsdWUgaW5cbiAgICAgIGlmIG5lZ2F0aXZlIHRoZW4gSW50ZWdlci5iaXRfbm90IG1hZ25pdHVkZSBlbHNlIG1hZ25pdHVkZV1cbiAgOztcbmVuZFxuXG5tb2R1bGUgRm9yX2ludCA9IEZvcl9pbnRlZ2VyIChzdHJ1Y3RcbiAgaW5jbHVkZSBJbnRcblxuICBsZXQgdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLmludFxuICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnRcbmVuZClcblxubGV0IGludCA9IEZvcl9pbnQuYWxsXG5sZXQgaW50X3VuaWZvcm0gPSBGb3JfaW50LnVuaWZvcm1fYWxsXG5sZXQgaW50X2luY2x1c2l2ZSA9IEZvcl9pbnQuaW5jbHVzaXZlXG5sZXQgaW50X3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludC51bmlmb3JtX2luY2x1c2l2ZVxubGV0IGludF9sb2dfaW5jbHVzaXZlID0gRm9yX2ludC5sb2dfaW5jbHVzaXZlXG5sZXQgaW50X2xvZ191bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQubG9nX3VuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50X2dlb21ldHJpYyA9IEZvcl9pbnQuZ2VvbWV0cmljXG5cbm1vZHVsZSBGb3JfaW50MzIgPSBGb3JfaW50ZWdlciAoc3RydWN0XG4gIGluY2x1ZGUgSW50MzJcblxuICBsZXQgdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLmludDMyXG4gIGxldCBsb2dfdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludDMyXG5lbmQpXG5cbmxldCBpbnQzMiA9IEZvcl9pbnQzMi5hbGxcbmxldCBpbnQzMl91bmlmb3JtID0gRm9yX2ludDMyLnVuaWZvcm1fYWxsXG5sZXQgaW50MzJfaW5jbHVzaXZlID0gRm9yX2ludDMyLmluY2x1c2l2ZVxubGV0IGludDMyX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDMyLnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50MzJfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQzMi5sb2dfaW5jbHVzaXZlXG5sZXQgaW50MzJfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDMyLmxvZ191bmlmb3JtX2luY2x1c2l2ZVxubGV0IGludDMyX2dlb21ldHJpYyA9IEZvcl9pbnQzMi5nZW9tZXRyaWNcblxubW9kdWxlIEZvcl9pbnQ2MyA9IEZvcl9pbnRlZ2VyIChzdHJ1Y3RcbiAgaW5jbHVkZSBJbnQ2M1xuXG4gIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uaW50NjNcbiAgbGV0IGxvZ191bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50NjNcbmVuZClcblxubGV0IGludDYzID0gRm9yX2ludDYzLmFsbFxubGV0IGludDYzX3VuaWZvcm0gPSBGb3JfaW50NjMudW5pZm9ybV9hbGxcbmxldCBpbnQ2M19pbmNsdXNpdmUgPSBGb3JfaW50NjMuaW5jbHVzaXZlXG5sZXQgaW50NjNfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50NjMudW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnQ2M19sb2dfaW5jbHVzaXZlID0gRm9yX2ludDYzLmxvZ19pbmNsdXNpdmVcbmxldCBpbnQ2M19sb2dfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50NjMubG9nX3VuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50NjNfZ2VvbWV0cmljID0gRm9yX2ludDYzLmdlb21ldHJpY1xuXG5tb2R1bGUgRm9yX2ludDY0ID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICBpbmNsdWRlIEludDY0XG5cbiAgbGV0IHVuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQ2NFxuICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQ2NFxuZW5kKVxuXG5sZXQgaW50NjQgPSBGb3JfaW50NjQuYWxsXG5sZXQgaW50NjRfdW5pZm9ybSA9IEZvcl9pbnQ2NC51bmlmb3JtX2FsbFxubGV0IGludDY0X2luY2x1c2l2ZSA9IEZvcl9pbnQ2NC5pbmNsdXNpdmVcbmxldCBpbnQ2NF91bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQ2NC51bmlmb3JtX2luY2x1c2l2ZVxubGV0IGludDY0X2xvZ19pbmNsdXNpdmUgPSBGb3JfaW50NjQubG9nX2luY2x1c2l2ZVxubGV0IGludDY0X2xvZ191bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQ2NC5sb2dfdW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnQ2NF9nZW9tZXRyaWMgPSBGb3JfaW50NjQuZ2VvbWV0cmljXG5cbm1vZHVsZSBGb3JfbmF0aXZlaW50ID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICBpbmNsdWRlIE5hdGl2ZWludFxuXG4gIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20ubmF0aXZlaW50XG4gIGxldCBsb2dfdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLm5hdGl2ZWludFxuZW5kKVxuXG5sZXQgbmF0aXZlaW50ID0gRm9yX25hdGl2ZWludC5hbGxcbmxldCBuYXRpdmVpbnRfdW5pZm9ybSA9IEZvcl9uYXRpdmVpbnQudW5pZm9ybV9hbGxcbmxldCBuYXRpdmVpbnRfaW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC5pbmNsdXNpdmVcbmxldCBuYXRpdmVpbnRfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfbmF0aXZlaW50LnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgbmF0aXZlaW50X2xvZ19pbmNsdXNpdmUgPSBGb3JfbmF0aXZlaW50LmxvZ19pbmNsdXNpdmVcbmxldCBuYXRpdmVpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC5sb2dfdW5pZm9ybV9pbmNsdXNpdmVcbmxldCBuYXRpdmVpbnRfZ2VvbWV0cmljID0gRm9yX25hdGl2ZWludC5nZW9tZXRyaWNcbmxldCBmbG9hdF96ZXJvX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCAwLlxubGV0IGZsb2F0X3plcm9fbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIDAuXG5cbmxldCBmbG9hdF9tYXhfcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlID1cbiAgRmxvYXQub25lX3VscCBgRG93biBGbG9hdC5taW5fcG9zaXRpdmVfbm9ybWFsX3ZhbHVlXG47O1xuXG5sZXQgZmxvYXRfc3Vibm9ybWFsX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBGbG9hdC5taW5fcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWluX3N1Ym5vcm1hbF9tYW50aXNzYSA9IEZsb2F0LmllZWVfbWFudGlzc2EgRmxvYXQubWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZVxubGV0IGZsb2F0X21heF9zdWJub3JtYWxfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIGZsb2F0X21heF9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9tYXhfcG9zaXRpdmVfbm9ybWFsX3ZhbHVlID0gRmxvYXQubWF4X2Zpbml0ZV92YWx1ZVxubGV0IGZsb2F0X21pbl9ub3JtYWxfZXhwb25lbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IEZsb2F0Lm1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9tYXhfbm9ybWFsX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBmbG9hdF9tYXhfcG9zaXRpdmVfbm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWF4X25vcm1hbF9tYW50aXNzYSA9IEZsb2F0LmllZWVfbWFudGlzc2EgZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1ZVxubGV0IGZsb2F0X2luZl9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgRmxvYXQuaW5maW5pdHlcbmxldCBmbG9hdF9pbmZfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIEZsb2F0LmluZmluaXR5XG5sZXQgZmxvYXRfbmFuX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBGbG9hdC5uYW5cbmxldCBmbG9hdF9taW5fbmFuX21hbnRpc3NhID0gSW50NjMuc3VjYyBmbG9hdF9pbmZfbWFudGlzc2FcbmxldCBmbG9hdF9tYXhfbmFuX21hbnRpc3NhID0gZmxvYXRfbWF4X25vcm1hbF9tYW50aXNzYVxubGV0IGZsb2F0X251bV9tYW50aXNzYV9iaXRzID0gNTJcblxuKCogV2Ugd2VpZ2h0IG1hbnRpc3NhcyBzbyB0aGF0IFwiaW50ZWdlci1saWtlXCIgdmFsdWVzLCBhbmQgdmFsdWVzIHdpdGggb25seSBhIGZldyBkaWdpdHNcbiAgIHBhc3QgdGhlIGRlY2ltYWwsIGFyZSByZWFzb25hYmx5IGNvbW1vbi4gKilcbmxldCBmbG9hdF9ub3JtYWxfbWFudGlzc2EgPVxuICBsZXQlYmluZCBudW1fYml0cyA9IEZvcl9pbnQudW5pZm9ybV9pbmNsdXNpdmUgMCBmbG9hdF9udW1fbWFudGlzc2FfYml0cyBpblxuICBsZXQlbWFwIGJpdHMgPVxuICAgIEZvcl9pbnQ2My5pbmNsdXNpdmUgSW50NjMuemVybyAoSW50NjMucHJlZCAoSW50NjMuc2hpZnRfbGVmdCBJbnQ2My5vbmUgbnVtX2JpdHMpKVxuICBpblxuICBJbnQ2My5zaGlmdF9sZWZ0IGJpdHMgKEludC4oIC0gKSBmbG9hdF9udW1fbWFudGlzc2FfYml0cyBudW1fYml0cylcbjs7XG5cbmxldCBmbG9hdF9leHBvbmVudF93ZWlnaHRlZF9sb3cgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgPVxuICBsZXQlbWFwIG9mZnNldCA9IEZvcl9pbnQubG9nX2luY2x1c2l2ZSAwIChJbnQuKCAtICkgdXBwZXJfYm91bmQgbG93ZXJfYm91bmQpIGluXG4gIEludC4oICsgKSBsb3dlcl9ib3VuZCBvZmZzZXRcbjs7XG5cbmxldCBmbG9hdF9leHBvbmVudF93ZWlnaHRlZF9oaWdoIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kID1cbiAgbGV0JW1hcCBvZmZzZXQgPSBGb3JfaW50LmxvZ19pbmNsdXNpdmUgMCAoSW50LiggLSApIHVwcGVyX2JvdW5kIGxvd2VyX2JvdW5kKSBpblxuICBJbnQuKCAtICkgdXBwZXJfYm91bmQgb2Zmc2V0XG47O1xuXG4oKiBXZSB3ZWlnaHQgZXhwb25lbnRzIHN1Y2ggdGhhdCB2YWx1ZXMgbmVhciAxIGFyZSBtb3JlIGxpa2VseS4gKilcbmxldCBmbG9hdF9leHBvbmVudCA9XG4gIGxldCBtaWRwb2ludCA9IEZsb2F0LmllZWVfZXhwb25lbnQgMS4gaW5cbiAgdW5pb25cbiAgICBbIGZsb2F0X2V4cG9uZW50X3dlaWdodGVkX2hpZ2ggZmxvYXRfbWluX25vcm1hbF9leHBvbmVudCBtaWRwb2ludFxuICAgIDsgZmxvYXRfZXhwb25lbnRfd2VpZ2h0ZWRfbG93IG1pZHBvaW50IGZsb2F0X21heF9ub3JtYWxfZXhwb25lbnRcbiAgICBdXG47O1xuXG5sZXQgZmxvYXRfemVybyA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4blxuICAgIH5uZWdhdGl2ZVxuICAgIH5leHBvbmVudDpmbG9hdF96ZXJvX2V4cG9uZW50XG4gICAgfm1hbnRpc3NhOmZsb2F0X3plcm9fbWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9zdWJub3JtYWwgPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbFxuICBhbmQgZXhwb25lbnQgPSByZXR1cm4gZmxvYXRfc3Vibm9ybWFsX2V4cG9uZW50XG4gIGFuZCBtYW50aXNzYSA9XG4gICAgRm9yX2ludDYzLmxvZ19pbmNsdXNpdmUgZmxvYXRfbWluX3N1Ym5vcm1hbF9tYW50aXNzYSBmbG9hdF9tYXhfc3Vibm9ybWFsX21hbnRpc3NhXG4gIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYVxuOztcblxubGV0IGZsb2F0X25vcm1hbCA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sXG4gIGFuZCBleHBvbmVudCA9IGZsb2F0X2V4cG9uZW50XG4gIGFuZCBtYW50aXNzYSA9IGZsb2F0X25vcm1hbF9tYW50aXNzYSBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9pbmZpbml0ZSA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4blxuICAgIH5uZWdhdGl2ZVxuICAgIH5leHBvbmVudDpmbG9hdF9pbmZfZXhwb25lbnRcbiAgICB+bWFudGlzc2E6ZmxvYXRfaW5mX21hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfbmFuID1cbiAgbGV0JW1hcCBuZWdhdGl2ZSA9IGJvb2xcbiAgYW5kIGV4cG9uZW50ID0gcmV0dXJuIGZsb2F0X25hbl9leHBvbmVudFxuICBhbmQgbWFudGlzc2EgPSBGb3JfaW50NjMuaW5jbHVzaXZlIGZsb2F0X21pbl9uYW5fbWFudGlzc2EgZmxvYXRfbWF4X25hbl9tYW50aXNzYSBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9vZl9jbGFzcyBjID1cbiAgbWF0Y2ggKGMgOiBGbG9hdC5DbGFzcy50KSB3aXRoXG4gIHwgWmVybyAtPiBmbG9hdF96ZXJvXG4gIHwgU3Vibm9ybWFsIC0+IGZsb2F0X3N1Ym5vcm1hbFxuICB8IE5vcm1hbCAtPiBmbG9hdF9ub3JtYWxcbiAgfCBJbmZpbml0ZSAtPiBmbG9hdF9pbmZpbml0ZVxuICB8IE5hbiAtPiBmbG9hdF9uYW5cbjs7XG5cbmxldCBmbG9hdF93ZWlnaHRfb2ZfY2xhc3MgYyA9XG4gIG1hdGNoIChjIDogRmxvYXQuQ2xhc3MudCkgd2l0aFxuICB8IFplcm8gLT4gMS5cbiAgfCBTdWJub3JtYWwgLT4gMTAuXG4gIHwgTm9ybWFsIC0+IDEwMC5cbiAgfCBJbmZpbml0ZSAtPiAxLlxuICB8IE5hbiAtPiAxLlxuOztcblxubGV0IGZsb2F0X21hdGNoaW5nX2NsYXNzZXMgZmlsdGVyID1cbiAgTGlzdC5maWx0ZXJfbWFwIEZsb2F0LkNsYXNzLmFsbCB+ZjooZnVuIGMgLT5cbiAgICBpZiBmaWx0ZXIgYyB0aGVuIFNvbWUgKGZsb2F0X3dlaWdodF9vZl9jbGFzcyBjLCBmbG9hdF9vZl9jbGFzcyBjKSBlbHNlIE5vbmUpXG4gIHw+IHdlaWdodGVkX3VuaW9uXG47O1xuXG5sZXQgZmxvYXRfZmluaXRlID1cbiAgZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyAoZnVuY3Rpb25cbiAgICB8IFplcm8gfCBTdWJub3JtYWwgfCBOb3JtYWwgLT4gdHJ1ZVxuICAgIHwgSW5maW5pdGUgfCBOYW4gLT4gZmFsc2UpXG47O1xuXG5sZXQgZmxvYXRfd2l0aG91dF9uYW4gPVxuICBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIChmdW5jdGlvblxuICAgIHwgWmVybyB8IFN1Ym5vcm1hbCB8IE5vcm1hbCB8IEluZmluaXRlIC0+IHRydWVcbiAgICB8IE5hbiAtPiBmYWxzZSlcbjs7XG5cbmxldCBmbG9hdCA9IGZsb2F0X21hdGNoaW5nX2NsYXNzZXMgKGZ1biBfIC0+IHRydWUpXG5cbmxldCBmbG9hdF9maW5pdGVfbm9uX3plcm8gPVxuICBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIChmdW5jdGlvblxuICAgIHwgU3Vibm9ybWFsIHwgTm9ybWFsIC0+IHRydWVcbiAgICB8IFplcm8gfCBJbmZpbml0ZSB8IE5hbiAtPiBmYWxzZSlcbjs7XG5cbmxldCBmbG9hdF9zdHJpY3RseV9wb3NpdGl2ZSA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZV9ub25femVybyBpblxuICBGbG9hdC5hYnMgdFxuOztcblxubGV0IGZsb2F0X3N0cmljdGx5X25lZ2F0aXZlID1cbiAgbGV0JW1hcCB0ID0gZmxvYXRfZmluaXRlX25vbl96ZXJvIGluXG4gIH4tLihGbG9hdC5hYnMgdClcbjs7XG5cbmxldCBmbG9hdF9wb3NpdGl2ZV9vcl96ZXJvID1cbiAgbGV0JW1hcCB0ID0gZmxvYXRfZmluaXRlIGluXG4gIEZsb2F0LmFicyB0XG47O1xuXG5sZXQgZmxvYXRfbmVnYXRpdmVfb3JfemVybyA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZSBpblxuICB+LS4oRmxvYXQuYWJzIHQpXG47O1xuXG5sZXQgZmxvYXRfdW5pZm9ybV9leGNsdXNpdmUgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgPVxuICBsZXQgb3BlbiBGbG9hdC5PIGluXG4gIGlmIChub3QgKEZsb2F0LmlzX2Zpbml0ZSBsb3dlcl9ib3VuZCkpIHx8IG5vdCAoRmxvYXQuaXNfZmluaXRlIHVwcGVyX2JvdW5kKVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiRmxvYXQudW5pZm9ybV9leGNsdXNpdmU6IGJvdW5kcyBhcmUgbm90IGZpbml0ZVwiXG4gICAgICAgICAgKGxvd2VyX2JvdW5kIDogZmxvYXQpXG4gICAgICAgICAgKHVwcGVyX2JvdW5kIDogZmxvYXQpXTtcbiAgbGV0IGxvd2VyX2luY2x1c2l2ZSA9IEZsb2F0Lm9uZV91bHAgYFVwIGxvd2VyX2JvdW5kIGluXG4gIGxldCB1cHBlcl9pbmNsdXNpdmUgPSBGbG9hdC5vbmVfdWxwIGBEb3duIHVwcGVyX2JvdW5kIGluXG4gIGlmIGxvd2VyX2luY2x1c2l2ZSA+IHVwcGVyX2luY2x1c2l2ZVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiRmxvYXQudW5pZm9ybV9leGNsdXNpdmU6IHJlcXVlc3RlZCByYW5nZSBpcyBlbXB0eVwiXG4gICAgICAgICAgKGxvd2VyX2JvdW5kIDogZmxvYXQpXG4gICAgICAgICAgKHVwcGVyX2JvdW5kIDogZmxvYXQpXTtcbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgU3BsaXR0YWJsZV9yYW5kb20uZmxvYXQgcmFuZG9tIH5sbzpsb3dlcl9pbmNsdXNpdmUgfmhpOnVwcGVyX2luY2x1c2l2ZSlcbjs7XG5cbmxldCBmbG9hdF9pbmNsdXNpdmUgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgPVxuICBpZiBGbG9hdC5lcXVhbCBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZFxuICB0aGVuIHJldHVybiBsb3dlcl9ib3VuZFxuICBlbHNlIGlmIEZsb2F0LiggPSApIChGbG9hdC5vbmVfdWxwIGBVcCBsb3dlcl9ib3VuZCkgdXBwZXJfYm91bmRcbiAgdGhlbiB1bmlvbiBbIHJldHVybiBsb3dlcl9ib3VuZDsgcmV0dXJuIHVwcGVyX2JvdW5kIF1cbiAgZWxzZVxuICAgIHdlaWdodGVkX3VuaW9uXG4gICAgICBbIDAuMDUsIHJldHVybiBsb3dlcl9ib3VuZFxuICAgICAgOyAwLjA1LCByZXR1cm4gdXBwZXJfYm91bmRcbiAgICAgIDsgMC45LCBmbG9hdF91bmlmb3JtX2V4Y2x1c2l2ZSBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZFxuICAgICAgXVxuOztcblxubGV0IHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyX2dlbiB+bGVuZ3RoID1cbiAgbGlzdF93aXRoX2xlbmd0aCBjaGFyX2dlbiB+bGVuZ3RoIHw+IG1hcCB+ZjpTdHJpbmcub2ZfY2hhcl9saXN0XG47O1xuXG5sZXQgc3RyaW5nX29mIGNoYXJfZ2VuID1cbiAgYmluZCBzbWFsbF9wb3NpdGl2ZV9vcl96ZXJvX2ludCB+ZjooZnVuIGxlbmd0aCAtPlxuICAgIHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyX2dlbiB+bGVuZ3RoKVxuOztcblxubGV0IHN0cmluZ19ub25fZW1wdHlfb2YgY2hhcl9nZW4gPVxuICBiaW5kIHNtYWxsX3N0cmljdGx5X3Bvc2l0aXZlX2ludCB+ZjooZnVuIGxlbmd0aCAtPlxuICAgIHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyX2dlbiB+bGVuZ3RoKVxuOztcblxubGV0IHN0cmluZyA9IHN0cmluZ19vZiBjaGFyXG5sZXQgc3RyaW5nX25vbl9lbXB0eSA9IHN0cmluZ19ub25fZW1wdHlfb2YgY2hhclxubGV0IHN0cmluZ193aXRoX2xlbmd0aCB+bGVuZ3RoID0gc3RyaW5nX3dpdGhfbGVuZ3RoX29mIGNoYXIgfmxlbmd0aFxuXG5tb2R1bGUgRWRpdF9zdHJpbmcgPSBzdHJ1Y3RcbiAgbGV0IGVkaXRfaW5zZXJ0IHN0cmluZyA9XG4gICAgbGV0JWJpbmQgcG9zID0gaW50X3VuaWZvcm1faW5jbHVzaXZlIDAgKFN0cmluZy5sZW5ndGggc3RyaW5nKSBpblxuICAgIGxldCViaW5kIGxlbiA9IGludF9nZW9tZXRyaWMgMSB+cDowLjUgaW5cbiAgICBsZXQlYmluZCBzdHIgPSBzdHJpbmdfd2l0aF9sZW5ndGggfmxlbmd0aDpsZW4gaW5cbiAgICBbIFN0cmluZy5wcmVmaXggc3RyaW5nIHBvczsgc3RyOyBTdHJpbmcuZHJvcF9wcmVmaXggc3RyaW5nIHBvcyBdXG4gICAgfD4gU3RyaW5nLmNvbmNhdFxuICAgIHw+IHJldHVyblxuICA7O1xuXG4gIGxldCBlZGl0X3JlbW92ZSBzdHJpbmcgPVxuICAgIGxldCViaW5kIGxlbiA9IGludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgMSAoU3RyaW5nLmxlbmd0aCBzdHJpbmcpIGluXG4gICAgbGV0JWJpbmQgcG9zID0gaW50X3VuaWZvcm1faW5jbHVzaXZlIDAgKFN0cmluZy5sZW5ndGggc3RyaW5nIC0gbGVuKSBpblxuICAgIFsgU3RyaW5nLnByZWZpeCBzdHJpbmcgcG9zOyBTdHJpbmcuZHJvcF9wcmVmaXggc3RyaW5nIChwb3MgKyBsZW4pIF1cbiAgICB8PiBTdHJpbmcuY29uY2F0XG4gICAgfD4gcmV0dXJuXG4gIDs7XG5cbiAgbGV0IGVkaXRfcmVwbGFjZSBzdHJpbmcgPVxuICAgIGxldCViaW5kIGxlbiA9IGludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgMSAoU3RyaW5nLmxlbmd0aCBzdHJpbmcpIGluXG4gICAgbGV0JWJpbmQgcG9zID0gaW50X3VuaWZvcm1faW5jbHVzaXZlIDAgKFN0cmluZy5sZW5ndGggc3RyaW5nIC0gbGVuKSBpblxuICAgIGxldCViaW5kIHN0ciA9IHN0cmluZ193aXRoX2xlbmd0aCB+bGVuZ3RoOmxlbiBpblxuICAgIFsgU3RyaW5nLnByZWZpeCBzdHJpbmcgcG9zOyBzdHI7IFN0cmluZy5kcm9wX3ByZWZpeCBzdHJpbmcgKHBvcyArIGxlbikgXVxuICAgIHw+IFN0cmluZy5jb25jYXRcbiAgICB8PiByZXR1cm5cbiAgOztcblxuICBsZXQgZWRpdF9kb3VibGUgc3RyaW5nID1cbiAgICBsZXQlYmluZCBsZW4gPSBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIDEgKFN0cmluZy5sZW5ndGggc3RyaW5nKSBpblxuICAgIGxldCViaW5kIHBvcyA9IGludF91bmlmb3JtX2luY2x1c2l2ZSAwIChTdHJpbmcubGVuZ3RoIHN0cmluZyAtIGxlbikgaW5cbiAgICBbIFN0cmluZy5wcmVmaXggc3RyaW5nIChwb3MgKyBsZW4pOyBTdHJpbmcuZHJvcF9wcmVmaXggc3RyaW5nIHBvcyBdXG4gICAgfD4gU3RyaW5nLmNvbmNhdFxuICAgIHw+IHJldHVyblxuICA7O1xuXG4gIGxldCBlZGl0X25vbmVtcHR5IHN0cmluZyA9XG4gICAgWyBlZGl0X2luc2VydCBzdHJpbmc7IGVkaXRfcmVtb3ZlIHN0cmluZzsgZWRpdF9yZXBsYWNlIHN0cmluZzsgZWRpdF9kb3VibGUgc3RyaW5nIF1cbiAgICB8PiB1bmlvblxuICA7O1xuXG4gIGxldCByZWMgZWRpdCBzdHJpbmcgbl90aW1lcyA9XG4gICAgaWYgbl90aW1lcyA8PSAwXG4gICAgdGhlbiByZXR1cm4gc3RyaW5nXG4gICAgZWxzZSAoXG4gICAgICBsZXQlYmluZCBzdHJpbmcgPVxuICAgICAgICBpZiBTdHJpbmcuaXNfZW1wdHkgc3RyaW5nIHRoZW4gZWRpdF9pbnNlcnQgc3RyaW5nIGVsc2UgZWRpdF9ub25lbXB0eSBzdHJpbmdcbiAgICAgIGluXG4gICAgICBlZGl0IHN0cmluZyAobl90aW1lcyAtIDEpKVxuICA7O1xuZW5kXG5cbmxldCBzdHJpbmdfbGlrZSBzdHJpbmcgPVxuICBsZXQlYmluZCBuX3RpbWVzID0gaW50X2dlb21ldHJpYyAwIH5wOjAuNSBpblxuICBFZGl0X3N0cmluZy5lZGl0IHN0cmluZyBuX3RpbWVzXG47O1xuXG5sZXQgYnl0ZXMgPSBtYXAgc3RyaW5nIH5mOkJ5dGVzLm9mX3N0cmluZ1xuXG5sZXQgc2V4cF9vZiBhdG9tID1cbiAgZml4ZWRfcG9pbnQgKGZ1biBzZWxmIC0+XG4gICAgbGV0JWJpbmQgc2l6ZSA9IHNpemUgaW5cbiAgICAoKiBjaG9vc2UgYSBudW1iZXIgd2VpZ2h0ZWQgbG93IHNvIHdlIGhhdmUgYSBkZWNyZWFzaW5nLCBidXQgbm90IHZhbmlzaGluZywgY2hhbmNlXG4gICAgICAgdG8gZ2VuZXJhdGUgYXRvbXMgYXMgc2l6ZSBncm93cyAqKVxuICAgIG1hdGNoJWJpbmQgRm9yX2ludC5sb2dfdW5pZm9ybV9pbmNsdXNpdmUgMCAoc2l6ZSArIDEpIHdpdGhcbiAgICAoKiBnZW5lcmF0ZSBhbiBhdG9tIHVzaW5nIHRoZSBnaXZlbiBzaXplICopXG4gICAgfCAwIC0+XG4gICAgICBsZXQlbWFwIGF0b20gPSBhdG9tIGluXG4gICAgICBTZXhwLkF0b20gYXRvbVxuICAgICgqIHJlbHlpbmcgb24gW0xpc3QuZ2VuXSB0byBkaXN0cmlidXRlIFtzaXplXSBvdmVyIHN1Yi1zZXhwcyAqKVxuICAgIHwgXyAtPlxuICAgICAgbGV0JW1hcCBsaXN0ID0gbGlzdCBzZWxmIGluXG4gICAgICBTZXhwLkxpc3QgbGlzdClcbjs7XG5cbmxldCBzZXhwID0gc2V4cF9vZiBzdHJpbmdcblxubGV0IG1hcF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3Iga2V5X2dlbiBkYXRhX2dlbiA9XG4gIGxldCViaW5kIGtleXMgPSBsaXN0IGtleV9nZW4gaW5cbiAgbGV0IGtleXMgPSBMaXN0LmRlZHVwX2FuZF9zb3J0IGtleXMgfmNvbXBhcmU6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgbGV0JWJpbmQgZGF0YSA9IGxpc3Rfd2l0aF9sZW5ndGggZGF0YV9nZW4gfmxlbmd0aDooTGlzdC5sZW5ndGgga2V5cykgaW5cbiAgcmV0dXJuIChNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLm9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciAoTGlzdC56aXBfZXhuIGtleXMgZGF0YSkpXG47O1xuXG5sZXQgc2V0X3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBlbHRfZ2VuID1cbiAgbWFwIChsaXN0IGVsdF9nZW4pIH5mOihTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLm9mX2xpc3QgfmNvbXBhcmF0b3IpXG47O1xuXG5sZXQgY29tcGFyYXRvcl9vZl9tXG4gICh0eXBlIGEgYylcbiAgKG1vZHVsZSBNIDogQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gYSBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjKVxuICA9XG4gIE0uY29tcGFyYXRvclxuOztcblxubGV0IG1hcF90X20gbSBrZXlfZ2VuIGRhdGFfZ2VuID1cbiAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yX29mX20gbSBpblxuICBtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV9nZW4gZGF0YV9nZW5cbiAgfD4gbWFwIH5mOihNYXAuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuOztcblxubGV0IHNldF90X20gbSBlbHRfZ2VuID1cbiAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yX29mX20gbSBpblxuICBzZXRfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGVsdF9nZW5cbiAgfD4gbWFwIH5mOihTZXQuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuOztcblxubGV0IGJpZ2FycmF5MSB0IGtpbmQgbGF5b3V0IH5sZW5ndGggPVxuICBsZXQlbWFwIGVsdHMgPVxuICAgIG1hdGNoIGxlbmd0aCB3aXRoXG4gICAgfCBOb25lIC0+IGxpc3QgdFxuICAgIHwgU29tZSBsZW5ndGggLT4gbGlzdF93aXRoX2xlbmd0aCB0IH5sZW5ndGhcbiAgaW5cbiAgbGV0IGVsdHMgPSBBcnJheS5vZl9saXN0IGVsdHMgaW5cbiAgbGV0IGRpbSA9IEFycmF5Lmxlbmd0aCBlbHRzIGluXG4gIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gIEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkxLmluaXQga2luZCBsYXlvdXQgZGltIH5mOihmdW4gaSAtPiBlbHRzLihpIC0gb2Zmc2V0KSlcbjs7XG5cbmxldCBiaWdzdHJpbmdfZ2VuID0gYmlnYXJyYXkxIGNoYXIgQ2hhciBDX2xheW91dFxubGV0IGZsb2F0MzJfdmVjX2dlbiA9IGJpZ2FycmF5MSBmbG9hdCBGbG9hdDMyIEZvcnRyYW5fbGF5b3V0XG5sZXQgZmxvYXQ2NF92ZWNfZ2VuID0gYmlnYXJyYXkxIGZsb2F0IEZsb2F0NjQgRm9ydHJhbl9sYXlvdXRcbmxldCBiaWdzdHJpbmcgPSBiaWdzdHJpbmdfZ2VuIH5sZW5ndGg6Tm9uZVxubGV0IGZsb2F0MzJfdmVjID0gZmxvYXQzMl92ZWNfZ2VuIH5sZW5ndGg6Tm9uZVxubGV0IGZsb2F0NjRfdmVjID0gZmxvYXQ2NF92ZWNfZ2VuIH5sZW5ndGg6Tm9uZVxubGV0IGJpZ3N0cmluZ193aXRoX2xlbmd0aCB+bGVuZ3RoID0gYmlnc3RyaW5nX2dlbiB+bGVuZ3RoOihTb21lIGxlbmd0aClcbmxldCBmbG9hdDMyX3ZlY193aXRoX2xlbmd0aCB+bGVuZ3RoID0gZmxvYXQzMl92ZWNfZ2VuIH5sZW5ndGg6KFNvbWUgbGVuZ3RoKVxubGV0IGZsb2F0NjRfdmVjX3dpdGhfbGVuZ3RoIH5sZW5ndGggPSBmbG9hdDY0X3ZlY19nZW4gfmxlbmd0aDooU29tZSBsZW5ndGgpXG5cbmxldCBiaWdhcnJheTJfZGltID1cbiAgbWF0Y2glYmluZCBzaXplIHdpdGhcbiAgfCAwIC0+IHJldHVybiAoMCwgMClcbiAgfCBtYXhfdG90YWxfc2l6ZSAtPlxuICAgIGxldCViaW5kIGEgPVxuICAgICAgKCogY2hvb3NlIGEgZGltZW5zaW9uIHVwIHRvIFttYXhfdG90YWxfc2l6ZV0sIHdlaWdodGVkIGxvdyB0byBnaXZlIHRoZSBvdGhlclxuICAgICAgICAgZGltZW5zaW9uIGEgZ29vZCBjaGFuY2Ugb2YgYmVpbmcgY29tcGFyYXRpdmVseSBoaWdoICopXG4gICAgICBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIDEgbWF4X3RvdGFsX3NpemVcbiAgICBpblxuICAgIGxldCViaW5kIGIgPVxuICAgICAgKCogY2hvb3NlIGEgZGltZW5zaW9uIHVwIHRvIFttYXhfdG90YWxfc2l6ZSAvIGFdLCB3ZWlnaHRlZCBoaWdoIHRvIHJlYWNoIGNsb3NlIHRvXG4gICAgICAgICBbbWF4X3RvdGFsX3NpemVdIG1vc3Qgb2YgdGhlIHRpbWUgKilcbiAgICAgIGxldCBtYXhfYiA9IG1heF90b3RhbF9zaXplIC8gYSBpblxuICAgICAgbGV0JW1hcCBiX3dlaWdodGVkX2xvdyA9IGludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgMCBtYXhfYiBpblxuICAgICAgbWF4X2IgLSBiX3dlaWdodGVkX2xvd1xuICAgIGluXG4gICAgKCogYXZvaWQgYW55IHNrZXcgb2YgYSB2cyBiIGJ5IHJhbmRvbWx5IHN3YXBwaW5nICopXG4gICAgaWYlbWFwIGJvb2wgdGhlbiBhLCBiIGVsc2UgYiwgYVxuOztcblxubGV0IGJpZ2FycmF5MiB0IGtpbmQgbGF5b3V0ID1cbiAgbGV0JWJpbmQgZGltMSwgZGltMiA9IGJpZ2FycmF5Ml9kaW0gaW5cbiAgbGV0JW1hcCBlbHRzID0gbGlzdF93aXRoX2xlbmd0aCB+bGVuZ3RoOmRpbTEgKGxpc3Rfd2l0aF9sZW5ndGggfmxlbmd0aDpkaW0yIHQpIGluXG4gIGxldCBlbHRzID0gQXJyYXkub2ZfbGlzdF9tYXAgfmY6QXJyYXkub2ZfbGlzdCBlbHRzIGluXG4gIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gIEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkyLmluaXQga2luZCBsYXlvdXQgZGltMSBkaW0yIH5mOihmdW4gaSBqIC0+XG4gICAgZWx0cy4oaSAtIG9mZnNldCkuKGogLSBvZmZzZXQpKVxuOztcblxubGV0IGZsb2F0MzJfbWF0ID0gYmlnYXJyYXkyIGZsb2F0IEZsb2F0MzIgRm9ydHJhbl9sYXlvdXRcbmxldCBmbG9hdDY0X21hdCA9IGJpZ2FycmF5MiBmbG9hdCBGbG9hdDY0IEZvcnRyYW5fbGF5b3V0XG5cbm1vZHVsZSBEZWJ1ZyA9IHN0cnVjdFxuICBsZXQgY292ZXJhZ2VcbiAgICAodHlwZSBrIGNtcClcbiAgICAobW9kdWxlIENtcCA6IENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA9IGsgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKVxuICAgIHNhbXBsZVxuICAgID1cbiAgICBTZXF1ZW5jZS5mb2xkXG4gICAgICBzYW1wbGVcbiAgICAgIH5pbml0OihNYXAuZW1wdHkgKG1vZHVsZSBDbXApKVxuICAgICAgfmY6KGZ1biBjb3VudHMgdmFsdWUgLT5cbiAgICAgICAgTWFwLnVwZGF0ZSBjb3VudHMgdmFsdWUgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IDFcbiAgICAgICAgICB8IFNvbWUgcHJldiAtPiBwcmV2ICsgMSkpXG4gIDs7XG5cbiAgbGV0IG1vbml0b3IgdCB+ZiA9XG4gICAgbWFwIHQgfmY6KGZ1biB2YWx1ZSAtPlxuICAgICAgZiB2YWx1ZTtcbiAgICAgIHZhbHVlKVxuICA7O1xuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiA2NC1iaXQgaW50ZWdlcnMuXG5cbiAgIFRoaXMgbW9kdWxlIHByb3ZpZGVzIG9wZXJhdGlvbnMgb24gdGhlIHR5cGUgW2ludDY0XSBvZlxuICAgc2lnbmVkIDY0LWJpdCBpbnRlZ2Vycy4gIFVubGlrZSB0aGUgYnVpbHQtaW4gW2ludF0gdHlwZSxcbiAgIHRoZSB0eXBlIFtpbnQ2NF0gaXMgZ3VhcmFudGVlZCB0byBiZSBleGFjdGx5IDY0LWJpdCB3aWRlIG9uIGFsbFxuICAgcGxhdGZvcm1zLiAgQWxsIGFyaXRobWV0aWMgb3BlcmF0aW9ucyBvdmVyIFtpbnQ2NF0gYXJlIHRha2VuXG4gICBtb2R1bG8gMnteNjR9XG5cbiAgIFBlcmZvcm1hbmNlIG5vdGljZTogdmFsdWVzIG9mIHR5cGUgW2ludDY0XSBvY2N1cHkgbW9yZSBtZW1vcnlcbiAgIHNwYWNlIHRoYW4gdmFsdWVzIG9mIHR5cGUgW2ludF0sIGFuZCBhcml0aG1ldGljIG9wZXJhdGlvbnMgb25cbiAgIFtpbnQ2NF0gYXJlIGdlbmVyYWxseSBzbG93ZXIgdGhhbiB0aG9zZSBvbiBbaW50XS4gIFVzZSBbaW50NjRdXG4gICBvbmx5IHdoZW4gdGhlIGFwcGxpY2F0aW9uIHJlcXVpcmVzIGV4YWN0IDY0LWJpdCBhcml0aG1ldGljLlxuXG4gICAgTGl0ZXJhbHMgZm9yIDY0LWJpdCBpbnRlZ2VycyBhcmUgc3VmZml4ZWQgYnkgTDpcbiAgICB7W1xuICAgICAgbGV0IHplcm86IGludDY0ID0gMExcbiAgICAgIGxldCBvbmU6IGludDY0ID0gMUxcbiAgICAgIGxldCBtX29uZTogaW50NjQgPSAtMUxcbiAgICBdfVxuKilcblxudmFsIHplcm8gOiBpbnQ2NFxuKCoqIFRoZSA2NC1iaXQgaW50ZWdlciAwLiAqKVxuXG52YWwgb25lIDogaW50NjRcbigqKiBUaGUgNjQtYml0IGludGVnZXIgMS4gKilcblxudmFsIG1pbnVzX29uZSA6IGludDY0XG4oKiogVGhlIDY0LWJpdCBpbnRlZ2VyIC0xLiAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X25lZ1wiXG4oKiogVW5hcnkgbmVnYXRpb24uICopXG5cbmV4dGVybmFsIGFkZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYWRkXCJcbigqKiBBZGRpdGlvbi4gKilcblxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuKCoqIFN1YnRyYWN0aW9uLiAqKVxuXG5leHRlcm5hbCBtdWwgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X211bFwiXG4oKiogTXVsdGlwbGljYXRpb24uICopXG5cbmV4dGVybmFsIGRpdiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfZGl2XCJcbigqKiBJbnRlZ2VyIGRpdmlzaW9uLlxuICAgQHJhaXNlIERpdmlzaW9uX2J5X3plcm8gaWYgdGhlIHNlY29uZFxuICAgYXJndW1lbnQgaXMgemVyby4gIFRoaXMgZGl2aXNpb24gcm91bmRzIHRoZSByZWFsIHF1b3RpZW50IG9mXG4gICBpdHMgYXJndW1lbnRzIHRvd2FyZHMgemVybywgYXMgc3BlY2lmaWVkIGZvciB7IVN0ZGxpYi4oLyl9LiAqKVxuXG52YWwgdW5zaWduZWRfZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjRcbigqKiBTYW1lIGFzIHshZGl2fSwgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFuZCByZXN1bHQgYXJlIGludGVycHJldGVkIGFzIHtlXG4gICAgdW5zaWduZWR9IDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgIEBzaW5jZSA0LjA4ICopXG5cbmV4dGVybmFsIHJlbSA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbW9kXCJcbigqKiBJbnRlZ2VyIHJlbWFpbmRlci4gIElmIFt5XSBpcyBub3QgemVybywgdGhlIHJlc3VsdFxuICAgb2YgW0ludDY0LnJlbSB4IHldIHNhdGlzZmllcyB0aGUgZm9sbG93aW5nIHByb3BlcnR5OlxuICAgW3ggPSBJbnQ2NC5hZGQgKEludDY0Lm11bCAoSW50NjQuZGl2IHggeSkgeSkgKEludDY0LnJlbSB4IHkpXS5cbiAgIElmIFt5ID0gMF0sIFtJbnQ2NC5yZW0geCB5XSByYWlzZXMgW0RpdmlzaW9uX2J5X3plcm9dLiAqKVxuXG52YWwgdW5zaWduZWRfcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjRcbigqKiBTYW1lIGFzIHshcmVtfSwgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFuZCByZXN1bHQgYXJlIGludGVycHJldGVkIGFzIHtlXG4gICAgdW5zaWduZWR9IDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgIEBzaW5jZSA0LjA4ICopXG5cbnZhbCBzdWNjIDogaW50NjQgLT4gaW50NjRcbigqKiBTdWNjZXNzb3IuICBbSW50NjQuc3VjYyB4XSBpcyBbSW50NjQuYWRkIHggSW50NjQub25lXS4gKilcblxudmFsIHByZWQgOiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFByZWRlY2Vzc29yLiAgW0ludDY0LnByZWQgeF0gaXMgW0ludDY0LnN1YiB4IEludDY0Lm9uZV0uICopXG5cbnZhbCBhYnMgOiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFthYnMgeF0gaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIFt4XS4gT24gW21pbl9pbnRdIHRoaXNcbiAgIGlzIFttaW5faW50XSBpdHNlbGYgYW5kIHRodXMgcmVtYWlucyBuZWdhdGl2ZS4gKilcblxudmFsIG1heF9pbnQgOiBpbnQ2NFxuKCoqIFRoZSBncmVhdGVzdCByZXByZXNlbnRhYmxlIDY0LWJpdCBpbnRlZ2VyLCAye142M30gLSAxLiAqKVxuXG52YWwgbWluX2ludCA6IGludDY0XG4oKiogVGhlIHNtYWxsZXN0IHJlcHJlc2VudGFibGUgNjQtYml0IGludGVnZXIsIC0ye142M30uICopXG5cbmV4dGVybmFsIGxvZ2FuZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYW5kXCJcbigqKiBCaXR3aXNlIGxvZ2ljYWwgYW5kLiAqKVxuXG5leHRlcm5hbCBsb2dvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfb3JcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBvci4gKilcblxuZXh0ZXJuYWwgbG9neG9yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF94b3JcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBleGNsdXNpdmUgb3IuICopXG5cbnZhbCBsb2dub3QgOiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIEJpdHdpc2UgbG9naWNhbCBuZWdhdGlvbi4gKilcblxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzbFwiXG4oKiogW0ludDY0LnNoaWZ0X2xlZnQgeCB5XSBzaGlmdHMgW3hdIHRvIHRoZSBsZWZ0IGJ5IFt5XSBiaXRzLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuKCoqIFtJbnQ2NC5zaGlmdF9yaWdodCB4IHldIHNoaWZ0cyBbeF0gdG8gdGhlIHJpZ2h0IGJ5IFt5XSBiaXRzLlxuICAgVGhpcyBpcyBhbiBhcml0aG1ldGljIHNoaWZ0OiB0aGUgc2lnbiBiaXQgb2YgW3hdIGlzIHJlcGxpY2F0ZWRcbiAgIGFuZCBpbnNlcnRlZCBpbiB0aGUgdmFjYXRlZCBiaXRzLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG4oKiogW0ludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgeCB5XSBzaGlmdHMgW3hdIHRvIHRoZSByaWdodCBieSBbeV0gYml0cy5cbiAgIFRoaXMgaXMgYSBsb2dpY2FsIHNoaWZ0OiB6ZXJvZXMgYXJlIGluc2VydGVkIGluIHRoZSB2YWNhdGVkIGJpdHNcbiAgIHJlZ2FyZGxlc3Mgb2YgdGhlIHNpZ24gb2YgW3hdLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiBpbnRlZ2VyICh0eXBlIFtpbnRdKSB0byBhIDY0LWJpdCBpbnRlZ2VyXG4gICAgKHR5cGUgW2ludDY0XSkuICopXG5cbmV4dGVybmFsIHRvX2ludCA6IGludDY0IC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkgdG8gYW5cbiAgIGludGVnZXIgKHR5cGUgW2ludF0pLiAgT24gNjQtYml0IHBsYXRmb3JtcywgdGhlIDY0LWJpdCBpbnRlZ2VyXG4gICBpcyB0YWtlbiBtb2R1bG8gMnteNjN9LCBpLmUuIHRoZSBoaWdoLW9yZGVyIGJpdCBpcyBsb3N0XG4gICBkdXJpbmcgdGhlIGNvbnZlcnNpb24uICBPbiAzMi1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye14zMX0sIGkuZS4gdGhlIHRvcCAzMyBiaXRzIGFyZSBsb3N0XG4gICBkdXJpbmcgdGhlIGNvbnZlcnNpb24uICopXG5cbnZhbCB1bnNpZ25lZF90b19pbnQgOiBpbnQ2NCAtPiBpbnQgb3B0aW9uXG4oKiogU2FtZSBhcyB7IXRvX2ludH0sIGJ1dCBpbnRlcnByZXRzIHRoZSBhcmd1bWVudCBhcyBhbiB7ZSB1bnNpZ25lZH0gaW50ZWdlci5cbiAgICBSZXR1cm5zIFtOb25lXSBpZiB0aGUgdW5zaWduZWQgdmFsdWUgb2YgdGhlIGFyZ3VtZW50IGNhbm5vdCBmaXQgaW50byBhblxuICAgIFtpbnRdLlxuXG4gICAgQHNpbmNlIDQuMDggKilcblxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbigqKiBDb252ZXJ0IHRoZSBnaXZlbiBmbG9hdGluZy1wb2ludCBudW1iZXIgdG8gYSA2NC1iaXQgaW50ZWdlcixcbiAgIGRpc2NhcmRpbmcgdGhlIGZyYWN0aW9uYWwgcGFydCAodHJ1bmNhdGUgdG93YXJkcyAwKS5cbiAgIElmIHRoZSB0cnVuY2F0ZWQgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIG91dHNpZGUgdGhlIHJhbmdlXG4gICBcXFt7IUludDY0Lm1pbl9pbnR9LCB7IUludDY0Lm1heF9pbnR9XFxdLCBubyBleGNlcHRpb24gaXMgcmFpc2VkLCBhbmRcbiAgIGFuIHVuc3BlY2lmaWVkLCBwbGF0Zm9ybS1kZXBlbmRlbnQgaW50ZWdlciBpcyByZXR1cm5lZC4gKilcblxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF90b19mbG9hdFwiIFwiY2FtbF9pbnQ2NF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbigqKiBDb252ZXJ0IHRoZSBnaXZlbiA2NC1iaXQgaW50ZWdlciB0byBhIGZsb2F0aW5nLXBvaW50IG51bWJlci4gKilcblxuXG5leHRlcm5hbCBvZl9pbnQzMiA6IGludDMyIC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50MzJcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIDMyLWJpdCBpbnRlZ2VyICh0eXBlIFtpbnQzMl0pXG4gICB0byBhIDY0LWJpdCBpbnRlZ2VyICh0eXBlIFtpbnQ2NF0pLiAqKVxuXG5leHRlcm5hbCB0b19pbnQzMiA6IGludDY0IC0+IGludDMyID0gXCIlaW50NjRfdG9faW50MzJcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIDY0LWJpdCBpbnRlZ2VyICh0eXBlIFtpbnQ2NF0pIHRvIGFcbiAgIDMyLWJpdCBpbnRlZ2VyICh0eXBlIFtpbnQzMl0pLiBUaGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye14zMn0sIGkuZS4gdGhlIHRvcCAzMiBiaXRzIGFyZSBsb3N0XG4gICBkdXJpbmcgdGhlIGNvbnZlcnNpb24uICAqKVxuXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIG5hdGl2ZSBpbnRlZ2VyICh0eXBlIFtuYXRpdmVpbnRdKVxuICAgdG8gYSA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKS4gKilcblxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKSB0byBhXG4gICBuYXRpdmUgaW50ZWdlci4gIE9uIDMyLWJpdCBwbGF0Zm9ybXMsIHRoZSA2NC1iaXQgaW50ZWdlclxuICAgaXMgdGFrZW4gbW9kdWxvIDJ7XjMyfS4gIE9uIDY0LWJpdCBwbGF0Zm9ybXMsXG4gICB0aGUgY29udmVyc2lvbiBpcyBleGFjdC4gKilcblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0ID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIGEgNjQtYml0IGludGVnZXIuXG4gICBUaGUgc3RyaW5nIGlzIHJlYWQgaW4gZGVjaW1hbCAoYnkgZGVmYXVsdCwgb3IgaWYgdGhlIHN0cmluZ1xuICAgYmVnaW5zIHdpdGggWzB1XSkgb3IgaW4gaGV4YWRlY2ltYWwsIG9jdGFsIG9yIGJpbmFyeSBpZiB0aGVcbiAgIHN0cmluZyBiZWdpbnMgd2l0aCBbMHhdLCBbMG9dIG9yIFswYl0gcmVzcGVjdGl2ZWx5LlxuXG4gICBUaGUgWzB1XSBwcmVmaXggcmVhZHMgdGhlIGlucHV0IGFzIGFuIHVuc2lnbmVkIGludGVnZXIgaW4gdGhlIHJhbmdlXG4gICBbWzAsIDIqSW50NjQubWF4X2ludCsxXV0uICBJZiB0aGUgaW5wdXQgZXhjZWVkcyB7IUludDY0Lm1heF9pbnR9XG4gICBpdCBpcyBjb252ZXJ0ZWQgdG8gdGhlIHNpZ25lZCBpbnRlZ2VyXG4gICBbSW50NjQubWluX2ludCArIGlucHV0IC0gSW50NjQubWF4X2ludCAtIDFdLlxuXG4gICBUaGUgW19dICh1bmRlcnNjb3JlKSBjaGFyYWN0ZXIgY2FuIGFwcGVhciBhbnl3aGVyZSBpbiB0aGUgc3RyaW5nXG4gICBhbmQgaXMgaWdub3JlZC5cbiAgIEByYWlzZSBGYWlsdXJlIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgbm90XG4gICBhIHZhbGlkIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIsIG9yIGlmIHRoZSBpbnRlZ2VyIHJlcHJlc2VudGVkXG4gICBleGNlZWRzIHRoZSByYW5nZSBvZiBpbnRlZ2VycyByZXByZXNlbnRhYmxlIGluIHR5cGUgW2ludDY0XS4gKilcblxudmFsIG9mX3N0cmluZ19vcHQ6IHN0cmluZyAtPiBpbnQ2NCBvcHRpb25cbigqKiBTYW1lIGFzIFtvZl9zdHJpbmddLCBidXQgcmV0dXJuIFtOb25lXSBpbnN0ZWFkIG9mIHJhaXNpbmcuXG4gICAgQHNpbmNlIDQuMDUgKilcblxudmFsIHRvX3N0cmluZyA6IGludDY0IC0+IHN0cmluZ1xuKCoqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGl0cyBhcmd1bWVudCwgaW4gZGVjaW1hbC4gKilcblxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbigqKiBSZXR1cm4gdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBmbG9hdCBhY2NvcmRpbmdcbiAgIHRvIHRoZSBJRUVFIDc1NCBmbG9hdGluZy1wb2ludCAnZG91YmxlIGZvcm1hdCcgYml0IGxheW91dC5cbiAgIEJpdCA2MyBvZiB0aGUgcmVzdWx0IHJlcHJlc2VudHMgdGhlIHNpZ24gb2YgdGhlIGZsb2F0O1xuICAgYml0cyA2MiB0byA1MiByZXByZXNlbnQgdGhlIChiaWFzZWQpIGV4cG9uZW50OyBiaXRzIDUxIHRvIDBcbiAgIHJlcHJlc2VudCB0aGUgbWFudGlzc2EuICopXG5cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogUmV0dXJuIHRoZSBmbG9hdGluZy1wb2ludCBudW1iZXIgd2hvc2UgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24sXG4gICBhY2NvcmRpbmcgdG8gdGhlIElFRUUgNzU0IGZsb2F0aW5nLXBvaW50ICdkb3VibGUgZm9ybWF0JyBiaXQgbGF5b3V0LFxuICAgaXMgdGhlIGdpdmVuIFtpbnQ2NF0uICopXG5cbnR5cGUgdCA9IGludDY0XG4oKiogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIDY0LWJpdCBpbnRlZ2Vycy4gKilcblxudmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbigqKiBUaGUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgNjQtYml0IGludGVnZXJzLCB3aXRoIHRoZSBzYW1lIHNwZWNpZmljYXRpb24gYXNcbiAgICB7IVN0ZGxpYi5jb21wYXJlfS4gIEFsb25nIHdpdGggdGhlIHR5cGUgW3RdLCB0aGlzIGZ1bmN0aW9uIFtjb21wYXJlXVxuICAgIGFsbG93cyB0aGUgbW9kdWxlIFtJbnQ2NF0gdG8gYmUgcGFzc2VkIGFzIGFyZ3VtZW50IHRvIHRoZSBmdW5jdG9yc1xuICAgIHshU2V0Lk1ha2V9IGFuZCB7IU1hcC5NYWtlfS4gKilcblxudmFsIHVuc2lnbmVkX2NvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbigqKiBTYW1lIGFzIHshY29tcGFyZX0sIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMge2UgdW5zaWduZWR9XG4gICAgNjQtYml0IGludGVnZXJzLlxuXG4gICAgQHNpbmNlIDQuMDggKilcblxudmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuKCoqIFRoZSBlcXVhbCBmdW5jdGlvbiBmb3IgaW50NjRzLlxuICAgIEBzaW5jZSA0LjAzICopXG5cbnZhbCBtaW46IHQgLT4gdCAtPiB0XG4oKiogUmV0dXJuIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gYXJndW1lbnRzLlxuICAgIEBzaW5jZSA0LjEzXG4qKVxuXG52YWwgbWF4OiB0IC0+IHQgLT4gdFxuKCoqIFJldHVybiB0aGUgZ3JlYXRlciBvZiB0aGUgdHdvIGFyZ3VtZW50cy5cbiAgICBAc2luY2UgNC4xM1xuICopXG5cbnZhbCBzZWVkZWRfaGFzaCA6IGludCAtPiB0IC0+IGludFxuKCoqIEEgc2VlZGVkIGhhc2ggZnVuY3Rpb24gZm9yIDY0LWJpdCBpbnRzLCB3aXRoIHRoZSBzYW1lIG91dHB1dCB2YWx1ZSBhc1xuICAgIHshSGFzaHRibC5zZWVkZWRfaGFzaH0uIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlIHBhc3NlZCBhc1xuICAgIGFyZ3VtZW50IHRvIHRoZSBmdW5jdG9yIHshSGFzaHRibC5NYWtlU2VlZGVkfS5cblxuICAgIEBzaW5jZSA1LjEgKilcblxudmFsIGhhc2ggOiB0IC0+IGludFxuKCoqIEFuIHVuc2VlZGVkIGhhc2ggZnVuY3Rpb24gZm9yIDY0LWJpdCBpbnRzLCB3aXRoIHRoZSBzYW1lIG91dHB1dCB2YWx1ZSBhc1xuICAgIHshSGFzaHRibC5oYXNofS4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmUgcGFzc2VkIGFzIGFyZ3VtZW50XG4gICAgdG8gdGhlIGZ1bmN0b3IgeyFIYXNodGJsLk1ha2V9LlxuXG4gICAgQHNpbmNlIDUuMSAqKVxuIiwib3BlbiEgQmFzZVxuXG5tb2R1bGUgVCA6IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgYXRvbWljIDogXyB0XG4gIHZhbCBjcmVhdGUgOiAoJ2EgLT4gJ2EgU2VxdWVuY2UudCkgLT4gJ2EgdFxuICB2YWwgc2hyaW5rIDogJ2EgdCAtPiAnYSAtPiAnYSBTZXF1ZW5jZS50XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgLT4gJ2EgU2VxdWVuY2UudFxuXG4gIGxldCBhdG9taWMgXyA9IFNlcXVlbmNlLmVtcHR5XG4gIGxldCBjcmVhdGUgPSBGbi5pZFxuICBsZXQgc2hyaW5rID0gRm4uaWRcbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IG1hcCB0IH5mIH5mX2ludmVyc2UgPSBjcmVhdGUgKGZ1biB4IC0+IFNlcXVlbmNlLm1hcCB+ZiAoc2hyaW5rIHQgKGZfaW52ZXJzZSB4KSkpXG5sZXQgZmlsdGVyIHQgfmYgPSBjcmVhdGUgKGZ1biB4IC0+IFNlcXVlbmNlLmZpbHRlciB+ZiAoc2hyaW5rIHQgeCkpXG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgfmZfaW52ZXJzZSA9XG4gIGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2UuZmlsdGVyX21hcCB+ZiAoc2hyaW5rIHQgKGZfaW52ZXJzZSB4KSkpXG47O1xuXG5sZXQgb2ZfbGF6eSBsYXp5X3QgPSBjcmVhdGUgKGZ1biB4IC0+IFNlcXVlbmNlLm9mX2xhenkgKGxhenkgKHNocmluayAoZm9yY2UgbGF6eV90KSB4KSkpXG5cbmxldCBmaXhlZF9wb2ludCBvZl9zaHJpbmtlciA9XG4gIGxldCByZWMgbGF6eV90ID0gbGF6eSAob2Zfc2hyaW5rZXIgKG9mX2xhenkgbGF6eV90KSkgaW5cbiAgb2ZfbGF6eSBsYXp5X3Rcbjs7XG5cbmxldCBib3RoIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gKGZzdCwgc25kKSAtPlxuICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICBbIFNlcXVlbmNlLm1hcCAoc2hyaW5rIGZzdF90IGZzdCkgfmY6KGZ1biBmc3QgLT4gZnN0LCBzbmQpXG4gICAgICA7IFNlcXVlbmNlLm1hcCAoc2hyaW5rIHNuZF90IHNuZCkgfmY6KGZ1biBzbmQgLT4gZnN0LCBzbmQpXG4gICAgICBdKVxuOztcblxubGV0IHVuaXQgPSBhdG9taWNcbmxldCBib29sID0gYXRvbWljXG5sZXQgY2hhciA9IGF0b21pY1xubGV0IGludCA9IGF0b21pY1xubGV0IGludDMyID0gYXRvbWljXG5sZXQgaW50NjMgPSBhdG9taWNcbmxldCBpbnQ2NCA9IGF0b21pY1xubGV0IG5hdGl2ZWludCA9IGF0b21pY1xubGV0IGZsb2F0ID0gYXRvbWljXG5cbmxldCBiaWdhcnJheTEgc3JjID1cbiAgbGV0IGRpbSA9IEJpZ2FycmF5LkFycmF5MS5kaW0gc3JjIGluXG4gIG1hdGNoIGRpbSB3aXRoXG4gIHwgMCAtPiBTZXF1ZW5jZS5lbXB0eVxuICB8IF8gLT5cbiAgICBsZXQga2luZCA9IEJpZ2FycmF5LkFycmF5MS5raW5kIHNyYyBpblxuICAgIGxldCBsYXlvdXQgPSBCaWdhcnJheS5BcnJheTEubGF5b3V0IHNyYyBpblxuICAgIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gICAgU2VxdWVuY2UuaW5pdCBkaW0gfmY6KGZ1biB0b19za2lwIC0+XG4gICAgICBsZXQgdG9fc2tpcCA9IHRvX3NraXAgKyBvZmZzZXQgaW5cbiAgICAgIEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkxLmluaXQga2luZCBsYXlvdXQgKGRpbSAtIDEpIH5mOihmdW4gaSAtPlxuICAgICAgICBzcmMue2lmIGkgPCB0b19za2lwIHRoZW4gaSBlbHNlIGkgKyAxfSkpXG47O1xuXG5sZXQgYmlnc3RyaW5nID0gY3JlYXRlIGJpZ2FycmF5MVxubGV0IGZsb2F0MzJfdmVjID0gY3JlYXRlIGJpZ2FycmF5MVxubGV0IGZsb2F0NjRfdmVjID0gY3JlYXRlIGJpZ2FycmF5MVxuXG5sZXQgYmlnYXJyYXkyID1cbiAgbGV0IG1vZHVsZSBEaW1zID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHsgZGltMSA6IGludFxuICAgICAgOyBkaW0yIDogaW50XG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgZmllbGRzIH5maWVsZHNdXG5cbiAgICBsZXQgY3JlYXRlIGEgPSBCaWdhcnJheS5BcnJheTIueyBkaW0xID0gZGltMSBhOyBkaW0yID0gZGltMiBhIH1cbiAgZW5kXG4gIGluXG4gIGxldCBzaHJpbmsgZmllbGQgc3JjID1cbiAgICBsZXQgZGltcyA9IERpbXMuY3JlYXRlIHNyYyBpblxuICAgIG1hdGNoIEZpZWxkLmdldCBmaWVsZCBkaW1zIHdpdGhcbiAgICB8IDAgLT4gU2VxdWVuY2UuZW1wdHlcbiAgICB8IF8gLT5cbiAgICAgIGxldCBraW5kID0gQmlnYXJyYXkuQXJyYXkyLmtpbmQgc3JjIGluXG4gICAgICBsZXQgbGF5b3V0ID0gQmlnYXJyYXkuQXJyYXkyLmxheW91dCBzcmMgaW5cbiAgICAgIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gICAgICBsZXQgKHsgZGltMTsgZGltMiB9IDogRGltcy50KSA9IEZpZWxkLm1hcCBmaWVsZCBkaW1zIH5mOkludC5wcmVkIGluXG4gICAgICBTZXF1ZW5jZS5pbml0IChGaWVsZC5nZXQgZmllbGQgZGltcykgfmY6KGZ1biB0b19za2lwIC0+XG4gICAgICAgIGxldCB0b19za2lwID0gdG9fc2tpcCArIG9mZnNldCBpblxuICAgICAgICBsZXQgc2tpcCBpID0gaWYgaSA8IHRvX3NraXAgdGhlbiBpIGVsc2UgaSArIDEgaW5cbiAgICAgICAgQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaW5pdCBraW5kIGxheW91dCBkaW0xIGRpbTIgfmY6KGZ1biBkaW0xIGRpbTIgLT5cbiAgICAgICAgICBsZXQgKHsgZGltMTsgZGltMiB9IDogRGltcy50KSA9IEZpZWxkLm1hcCBmaWVsZCB7IGRpbTE7IGRpbTIgfSB+Zjpza2lwIGluXG4gICAgICAgICAgc3JjLntkaW0xLCBkaW0yfSkpXG4gIGluXG4gIGZ1biBzcmMgLT5cbiAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpbiBbIHNocmluayBEaW1zLkZpZWxkcy5kaW0xIHNyYzsgc2hyaW5rIERpbXMuRmllbGRzLmRpbTIgc3JjIF1cbjs7XG5cbmxldCBmbG9hdDMyX21hdCA9IGNyZWF0ZSBiaWdhcnJheTJcbmxldCBmbG9hdDY0X21hdCA9IGNyZWF0ZSBiaWdhcnJheTJcblxubGV0IG9wdGlvbiB2YWx1ZV90ID1cbiAgY3JlYXRlIChmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgIHwgU29tZSB2YWx1ZSAtPlxuICAgICAgU2VxdWVuY2UuYXBwZW5kXG4gICAgICAgIChTZXF1ZW5jZS5zaW5nbGV0b24gTm9uZSlcbiAgICAgICAgKFNlcXVlbmNlLm1hcCB+ZjpPcHRpb24ucmV0dXJuIChzaHJpbmsgdmFsdWVfdCB2YWx1ZSkpKVxuOztcblxubGV0IGxpc3QgZWx0X3QgPVxuICBmaXhlZF9wb2ludCAoZnVuIGxpc3RfdCAtPlxuICAgIGNyZWF0ZSAoZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gU2VxdWVuY2UuZW1wdHlcbiAgICAgIHwgaGVhZCA6OiB0YWlsIC0+XG4gICAgICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICAgICAgWyBTZXF1ZW5jZS5zaW5nbGV0b24gdGFpbFxuICAgICAgICAgIDsgU2VxdWVuY2UubWFwIChzaHJpbmsgZWx0X3QgaGVhZCkgfmY6KGZ1biBoZWFkIC0+IGhlYWQgOjogdGFpbClcbiAgICAgICAgICA7IFNlcXVlbmNlLm1hcCAoc2hyaW5rIGxpc3RfdCB0YWlsKSB+ZjooZnVuIHRhaWwgLT4gaGVhZCA6OiB0YWlsKVxuICAgICAgICAgIF0pKVxuOztcblxubGV0IHN0cmluZyA9IG1hcCAobGlzdCBjaGFyKSB+ZjpTdHJpbmcub2ZfY2hhcl9saXN0IH5mX2ludmVyc2U6U3RyaW5nLnRvX2xpc3RcbmxldCBieXRlcyA9IG1hcCBzdHJpbmcgfmY6Qnl0ZXMub2Zfc3RyaW5nIH5mX2ludmVyc2U6Qnl0ZXMudG9fc3RyaW5nXG5sZXQgYXJyYXkgdCA9IG1hcCAobGlzdCB0KSB+ZjpBcnJheS5vZl9saXN0IH5mX2ludmVyc2U6QXJyYXkudG9fbGlzdFxubGV0IHJlZiB0ID0gbWFwIHQgfmY6UmVmLmNyZWF0ZSB+Zl9pbnZlcnNlOlJlZi4oICEgKVxubGV0IGxhenlfdCB0ID0gbWFwIHQgfmY6TGF6eS5mcm9tX3ZhbCB+Zl9pbnZlcnNlOkxhenkuZm9yY2VcblxubGV0IHNleHAgPVxuICBmaXhlZF9wb2ludCAoZnVuIHNocmlua2VyIC0+XG4gICAgY3JlYXRlIChmdW5jdGlvblxuICAgICAgfCBTZXhwLkF0b20gXyAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgICAgfCBTZXhwLkxpc3QgbCAtPlxuICAgICAgICBsZXQgc2hyaW5rX2xpc3QgPVxuICAgICAgICAgIHNocmluayAobGlzdCBzaHJpbmtlcikgbCB8PiBTZXF1ZW5jZS5tYXAgfmY6KGZ1biBsIC0+IFNleHAuTGlzdCBsKVxuICAgICAgICBpblxuICAgICAgICBsZXQgc2hyaW5rX3RyZWUgPSBTZXF1ZW5jZS5vZl9saXN0IGwgaW5cbiAgICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBzaHJpbmtfbGlzdDsgc2hyaW5rX3RyZWUgXSkpXG47O1xuXG5sZXQgZWl0aGVyIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gZWl0aGVyIC0+XG4gICAgbWF0Y2ggKGVpdGhlciA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICB8IEZpcnN0IGZzdCAtPiBTZXF1ZW5jZS5tYXAgKHNocmluayBmc3RfdCBmc3QpIH5mOkVpdGhlci5maXJzdFxuICAgIHwgU2Vjb25kIHNuZCAtPiBTZXF1ZW5jZS5tYXAgKHNocmluayBzbmRfdCBzbmQpIH5mOkVpdGhlci5zZWNvbmQpXG47O1xuXG5sZXQgcmVzdWx0IG9rX3QgZXJyX3QgPVxuICBtYXBcbiAgICAoZWl0aGVyIG9rX3QgZXJyX3QpXG4gICAgfmY6KGZ1bmN0aW9uXG4gICAgICB8IEZpcnN0IG9rIC0+IE9rIG9rXG4gICAgICB8IFNlY29uZCBlcnIgLT4gRXJyb3IgZXJyKVxuICAgIH5mX2ludmVyc2U6KGZ1bmN0aW9uXG4gICAgICB8IE9rIG9rIC0+IEZpcnN0IG9rXG4gICAgICB8IEVycm9yIGVyciAtPiBTZWNvbmQgZXJyKVxuOztcblxubGV0IG1hcF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3Iga2V5X3QgZGF0YV90ID1cbiAgY3JlYXRlIChmdW4gdHJlZSAtPlxuICAgIGxldCBhbGlzdCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fYWxpc3QgdHJlZSBpblxuICAgIGxldCBkcm9wX2tleXMgPVxuICAgICAgU2VxdWVuY2UubWFwIChTZXF1ZW5jZS5vZl9saXN0IGFsaXN0KSB+ZjooZnVuIChrLCBfKSAtPlxuICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGspXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2tleXMgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGFsaXN0IH5mOihmdW4gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgbGV0IHRyZWUgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGtleSBpblxuICAgICAgICAgICBTZXF1ZW5jZS5maWx0ZXJfbWFwIChzaHJpbmsga2V5X3Qga2V5KSB+ZjooZnVuIHNtYWxsZXJfa2V5IC0+XG4gICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUuYWRkIH5jb21wYXJhdG9yIHRyZWUgfmtleTpzbWFsbGVyX2tleSB+ZGF0YVxuICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICB8IGBPayB0cmVlIC0+IFNvbWUgdHJlZVxuICAgICAgICAgICAgIHwgYER1cGxpY2F0ZSAtPiBOb25lKSkpXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2RhdGEgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGFsaXN0IH5mOihmdW4gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgU2VxdWVuY2UubWFwIChzaHJpbmsgZGF0YV90IGRhdGEpIH5mOihmdW4gc21hbGxlcl9kYXRhIC0+XG4gICAgICAgICAgICAgTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5zZXQgfmNvbXBhcmF0b3IgdHJlZSB+a2V5IH5kYXRhOnNtYWxsZXJfZGF0YSkpKVxuICAgIGluXG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBkcm9wX2tleXM7IHNocmlua19rZXlzOyBzaHJpbmtfZGF0YSBdKVxuOztcblxubGV0IHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X3QgPVxuICBjcmVhdGUgKGZ1biB0cmVlIC0+XG4gICAgbGV0IGxpc3QgPSBTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLnRvX2xpc3QgdHJlZSBpblxuICAgIGxldCBkcm9wX2VsdHMgPVxuICAgICAgU2VxdWVuY2UubWFwIChTZXF1ZW5jZS5vZl9saXN0IGxpc3QpIH5mOihmdW4gZWx0IC0+XG4gICAgICAgIFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUucmVtb3ZlIH5jb21wYXJhdG9yIHRyZWUgZWx0KVxuICAgIGluXG4gICAgbGV0IHNocmlua19lbHRzID1cbiAgICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICAgIChMaXN0Lm1hcCBsaXN0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgIGxldCB0cmVlID0gU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5yZW1vdmUgfmNvbXBhcmF0b3IgdHJlZSBlbHQgaW5cbiAgICAgICAgICAgU2VxdWVuY2UuZmlsdGVyX21hcCAoc2hyaW5rIGVsdF90IGVsdCkgfmY6KGZ1biBzbWFsbGVyX2VsdCAtPlxuICAgICAgICAgICAgIG1hdGNoIFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUubWVtIH5jb21wYXJhdG9yIHRyZWUgc21hbGxlcl9lbHQgd2l0aFxuICAgICAgICAgICAgIHwgdHJ1ZSAtPiBOb25lXG4gICAgICAgICAgICAgfCBmYWxzZSAtPiBTb21lIChTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLmFkZCB0cmVlIH5jb21wYXJhdG9yIHNtYWxsZXJfZWx0KSkpKVxuICAgIGluXG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBkcm9wX2VsdHM7IHNocmlua19lbHRzIF0pXG47O1xuXG5sZXQgbWFwX3Qga2V5X3QgZGF0YV90ID1cbiAgY3JlYXRlIChmdW4gbWFwX3QgLT5cbiAgICBsZXQgY29tcGFyYXRvciA9IE1hcC5jb21wYXJhdG9yIG1hcF90IGluXG4gICAgbGV0IHQgPVxuICAgICAgbWFwXG4gICAgICAgIChtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV90IGRhdGFfdClcbiAgICAgICAgfmY6KE1hcC5Vc2luZ19jb21wYXJhdG9yLm9mX3RyZWUgfmNvbXBhcmF0b3IpXG4gICAgICAgIH5mX2ludmVyc2U6TWFwLlVzaW5nX2NvbXBhcmF0b3IudG9fdHJlZVxuICAgIGluXG4gICAgc2hyaW5rIHQgbWFwX3QpXG47O1xuXG5sZXQgc2V0X3QgZWx0X3QgPVxuICBjcmVhdGUgKGZ1biBzZXRfdCAtPlxuICAgIGxldCBjb21wYXJhdG9yID0gU2V0LmNvbXBhcmF0b3Igc2V0X3QgaW5cbiAgICBsZXQgdCA9XG4gICAgICBtYXBcbiAgICAgICAgKHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X3QpXG4gICAgICAgIH5mOihTZXQuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuICAgICAgICB+Zl9pbnZlcnNlOlNldC5Vc2luZ19jb21wYXJhdG9yLnRvX3RyZWVcbiAgICBpblxuICAgIHNocmluayB0IHNldF90KVxuOztcbiIsIm9wZW4hIEJhc2VcbmluY2x1ZGUgVGVzdF9pbnRmXG5cbm1vZHVsZSBDb25maWcgPSBzdHJ1Y3RcbiAgbW9kdWxlIFNlZWQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgfCBOb25kZXRlcm1pbmlzdGljXG4gICAgICB8IERldGVybWluaXN0aWMgb2Ygc3RyaW5nXG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgbW9kdWxlIFBvdGVudGlhbGx5X2luZmluaXRlX3NlcXVlbmNlID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgU2VxdWVuY2UudFxuXG4gICAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2VsdCBzZXF1ZW5jZSA9XG4gICAgICBsZXQgcHJlZml4LCBzdWZmaXggPSBTZXF1ZW5jZS5zcGxpdF9uIHNlcXVlbmNlIDEwMCBpblxuICAgICAgbGV0IHByZWZpeCA9IExpc3QubWFwIHByZWZpeCB+ZjpzZXhwX29mX2VsdCBpblxuICAgICAgbGV0IHN1ZmZpeCA9XG4gICAgICAgIG1hdGNoIFNlcXVlbmNlLmlzX2VtcHR5IHN1ZmZpeCB3aXRoXG4gICAgICAgIHwgdHJ1ZSAtPiBbXVxuICAgICAgICB8IGZhbHNlIC0+IFsgWyVtZXNzYWdlIFwiLi4uXCJdIF1cbiAgICAgIGluXG4gICAgICBTZXhwLkxpc3QgKHByZWZpeCBAIHN1ZmZpeClcbiAgICA7O1xuICBlbmRcblxuICB0eXBlIHQgPVxuICAgIHsgc2VlZCA6IFNlZWQudFxuICAgIDsgdGVzdF9jb3VudCA6IGludFxuICAgIDsgc2hyaW5rX2NvdW50IDogaW50XG4gICAgOyBzaXplcyA6IGludCBQb3RlbnRpYWxseV9pbmZpbml0ZV9zZXF1ZW5jZS50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMsIHNleHBfb2ZdXG5lbmRcblxubGV0IGRlZmF1bHRfY29uZmlnIDogQ29uZmlnLnQgPVxuICB7IHNlZWQgPSBEZXRlcm1pbmlzdGljIFwiYW4gYXJiaXRyYXJ5IGJ1dCBkZXRlcm1pbmlzdGljIHN0cmluZ1wiXG4gIDsgdGVzdF9jb3VudCA9XG4gICAgICAoKiBbU3BsaXR0YWJsZV9yYW5kb21dIGlzIGJhc2VkIG9uIDY0LWJpdCBhcml0aG1ldGljLCBhbmQgc28gdGVzdHMgcnVuIG11Y2ggc2xvd2VyXG4gICAgICAgICBvbiAzMi1iaXQgdGFyZ2V0cy4gV2UgcnVuIGFuIG9yZGVyIG9mIG1hZ25pdHVkZSBmZXdlciB0cmlhbHMgc28gYXMgbm90IHRvXG4gICAgICAgICBjb21wbGV0ZWx5IGJvZyBkb3duIGNvbnRpbnVvdXMgaW50ZWdyYXRpb24gc3lzdGVtcy4gKilcbiAgICAgIChtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICAgICB8IFc2NCAtPiAxMF8wMDBcbiAgICAgICB8IFczMiAtPiAxXzAwMClcbiAgOyBzaHJpbmtfY291bnQgPSAxMF8wMDBcbiAgOyBzaXplcyA9IFNlcXVlbmNlLmN5Y2xlX2xpc3RfZXhuIChMaXN0LnJhbmdlIDAgfnN0YXJ0OmBpbmNsdXNpdmUgMzAgfnN0b3A6YGluY2x1c2l2ZSlcbiAgfVxuOztcblxubGV0IGxhenlfbm9uZGV0ZXJtaW5pc3RpY19zdGF0ZSA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IGluaXRpYWxfcmFuZG9tX3N0YXRlIH5jb25maWcgPVxuICBtYXRjaCBDb25maWcuc2VlZCBjb25maWcgd2l0aFxuICB8IE5vbmRldGVybWluaXN0aWMgLT4gU3BsaXR0YWJsZV9yYW5kb20uY3JlYXRlIChmb3JjZSBsYXp5X25vbmRldGVybWluaXN0aWNfc3RhdGUpXG4gIHwgRGV0ZXJtaW5pc3RpYyBzdHJpbmcgLT4gU3BsaXR0YWJsZV9yYW5kb20ub2ZfaW50IChTdHJpbmcuaGFzaCBzdHJpbmcpXG47O1xuXG5sZXQgb25lX3NpemVfcGVyX3Rlc3Qgfihjb25maWcgOiBDb25maWcudCkgPVxuICBTZXF1ZW5jZS51bmZvbGQgfmluaXQ6KGNvbmZpZy5zaXplcywgMCkgfmY6KGZ1biAoc2l6ZXMsIG51bWJlcl9vZl9zaXplX3ZhbHVlcykgLT5cbiAgICBtYXRjaCBudW1iZXJfb2Zfc2l6ZV92YWx1ZXMgPj0gY29uZmlnLnRlc3RfY291bnQgd2l0aFxuICAgIHwgdHJ1ZSAtPiBOb25lXG4gICAgfCBmYWxzZSAtPlxuICAgICAgKG1hdGNoIFNlcXVlbmNlLm5leHQgc2l6ZXMgd2l0aFxuICAgICAgIHwgU29tZSAoc2l6ZSwgcmVtYWluaW5nX3NpemVzKSAtPlxuICAgICAgICAgU29tZSAoc2l6ZSwgKHJlbWFpbmluZ19zaXplcywgbnVtYmVyX29mX3NpemVfdmFsdWVzICsgMSkpXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICByYWlzZV9zXG4gICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLlRlc3QucnVuOiBpbnN1ZmZpY2llbnQgc2l6ZSB2YWx1ZXMgZm9yIHRlc3QgY291bnRcIlxuICAgICAgICAgICAgICAgfnRlc3RfY291bnQ6KGNvbmZpZy50ZXN0X2NvdW50IDogaW50KVxuICAgICAgICAgICAgICAgKG51bWJlcl9vZl9zaXplX3ZhbHVlcyA6IGludCldKSlcbjs7XG5cbmxldCBzaHJpbmtfZXJyb3IgfnNocmlua2VyIH5jb25maWcgfmYgaW5wdXQgZXJyb3IgPVxuICBsZXQgcmVjIGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvciA9XG4gICAgbWF0Y2ggc2hyaW5rX2NvdW50IHdpdGhcbiAgICB8IDAgLT4gaW5wdXQsIGVycm9yXG4gICAgfCBfIC0+XG4gICAgICBsZXQgc2hyaW5rX2NvdW50ID0gc2hyaW5rX2NvdW50IC0gMSBpblxuICAgICAgKG1hdGNoIFNlcXVlbmNlLm5leHQgYWx0ZXJuYXRlcyB3aXRoXG4gICAgICAgfCBOb25lIC0+IGlucHV0LCBlcnJvclxuICAgICAgIHwgU29tZSAoYWx0ZXJuYXRlLCBhbHRlcm5hdGVzKSAtPlxuICAgICAgICAgKG1hdGNoIGYgYWx0ZXJuYXRlIHdpdGhcbiAgICAgICAgICB8IE9rICgpIC0+IGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvclxuICAgICAgICAgIHwgRXJyb3IgZXJyb3IgLT5cbiAgICAgICAgICAgIGxldCBhbHRlcm5hdGVzID0gU2hyaW5rZXIuc2hyaW5rIHNocmlua2VyIGFsdGVybmF0ZSBpblxuICAgICAgICAgICAgbG9vcCB+c2hyaW5rX2NvdW50IH5hbHRlcm5hdGVzIGFsdGVybmF0ZSBlcnJvcikpXG4gIGluXG4gIGxldCBzaHJpbmtfY291bnQgPSBDb25maWcuc2hyaW5rX2NvdW50IGNvbmZpZyBpblxuICBsZXQgYWx0ZXJuYXRlcyA9IFNocmlua2VyLnNocmluayBzaHJpbmtlciBpbnB1dCBpblxuICBsb29wIH5zaHJpbmtfY291bnQgfmFsdGVybmF0ZXMgaW5wdXQgZXJyb3Jcbjs7XG5cbmxldCBpbnB1dF9zZXF1ZW5jZSB+Y29uZmlnIH5leGFtcGxlcyB+Z2VuZXJhdG9yID1cbiAgbGV0IHJhbmRvbSA9IGluaXRpYWxfcmFuZG9tX3N0YXRlIH5jb25maWcgaW5cbiAgU2VxdWVuY2UuYXBwZW5kXG4gICAgKFNlcXVlbmNlLm9mX2xpc3QgZXhhbXBsZXMpXG4gICAgKG9uZV9zaXplX3Blcl90ZXN0IH5jb25maWdcbiAgICAgfD4gU2VxdWVuY2UubWFwIH5mOihmdW4gc2l6ZSAtPiBHZW5lcmF0b3IuZ2VuZXJhdGUgZ2VuZXJhdG9yIH5zaXplIH5yYW5kb20pKVxuOztcblxubGV0IHdpdGhfc2FtcGxlIH5mID8oY29uZmlnID0gZGVmYXVsdF9jb25maWcpID8oZXhhbXBsZXMgPSBbXSkgZ2VuZXJhdG9yID1cbiAgbGV0IHNlcXVlbmNlID0gaW5wdXRfc2VxdWVuY2UgfmNvbmZpZyB+ZXhhbXBsZXMgfmdlbmVyYXRvciBpblxuICBmIHNlcXVlbmNlXG47O1xuXG5sZXQgcmVzdWx0ICh0eXBlIGEpIH5mID8oY29uZmlnID0gZGVmYXVsdF9jb25maWcpID8oZXhhbXBsZXMgPSBbXSkgbSA9XG4gIGxldCAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPSBtIGluXG4gIHdpdGhfc2FtcGxlIE0ucXVpY2tjaGVja19nZW5lcmF0b3IgfmNvbmZpZyB+ZXhhbXBsZXMgfmY6KGZ1biBzZXF1ZW5jZSAtPlxuICAgIG1hdGNoXG4gICAgICBTZXF1ZW5jZS5mb2xkX3Jlc3VsdCBzZXF1ZW5jZSB+aW5pdDooKSB+ZjooZnVuICgpIGlucHV0IC0+XG4gICAgICAgIG1hdGNoIGYgaW5wdXQgd2l0aFxuICAgICAgICB8IE9rICgpIC0+IE9rICgpXG4gICAgICAgIHwgRXJyb3IgZXJyb3IgLT4gRXJyb3IgKGlucHV0LCBlcnJvcikpXG4gICAgd2l0aFxuICAgIHwgT2sgKCkgLT4gT2sgKClcbiAgICB8IEVycm9yIChpbnB1dCwgZXJyb3IpIC0+XG4gICAgICBsZXQgc2hyaW5rZXIgPSBNLnF1aWNrY2hlY2tfc2hyaW5rZXIgaW5cbiAgICAgIGxldCBpbnB1dCwgZXJyb3IgPSBzaHJpbmtfZXJyb3IgfnNocmlua2VyIH5jb25maWcgfmYgaW5wdXQgZXJyb3IgaW5cbiAgICAgIEVycm9yIChpbnB1dCwgZXJyb3IpKVxuOztcblxubGV0IHJ1biAodHlwZSBhKSB+ZiA/Y29uZmlnID9leGFtcGxlcyAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPVxuICBsZXQgZiB4ID1cbiAgICBPcl9lcnJvci50cnlfd2l0aF9qb2luIH5iYWNrdHJhY2U6KEJhY2t0cmFjZS5FeG4uYW1fcmVjb3JkaW5nICgpKSAoZnVuICgpIC0+IGYgeClcbiAgaW5cbiAgbWF0Y2ggcmVzdWx0IH5mID9jb25maWcgP2V4YW1wbGVzIChtb2R1bGUgTSkgd2l0aFxuICB8IE9rICgpIC0+IE9rICgpXG4gIHwgRXJyb3IgKGlucHV0LCBlcnJvcikgLT5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suVGVzdC5ydW46IHRlc3QgZmFpbGVkXCIgKGlucHV0IDogTS50KSAoZXJyb3IgOiBFcnJvci50KV1cbjs7XG5cbmxldCB3aXRoX3NhbXBsZV9leG4gfmYgP2NvbmZpZyA/ZXhhbXBsZXMgZ2VuZXJhdG9yID1cbiAgbGV0IGYgeCA9IE9yX2Vycm9yLnRyeV93aXRoIChmdW4gKCkgLT4gZiB4KSBpblxuICB3aXRoX3NhbXBsZSB+ZiA/Y29uZmlnID9leGFtcGxlcyBnZW5lcmF0b3IgfD4gT3JfZXJyb3Iub2tfZXhuXG47O1xuXG5sZXQgcnVuX2V4biB+ZiA/Y29uZmlnID9leGFtcGxlcyB0ZXN0YWJsZSA9XG4gIGxldCBmIHggPVxuICAgIE9yX2Vycm9yLnRyeV93aXRoIH5iYWNrdHJhY2U6KEJhY2t0cmFjZS5FeG4uYW1fcmVjb3JkaW5nICgpKSAoZnVuICgpIC0+IGYgeClcbiAgaW5cbiAgcnVuIH5mID9jb25maWcgP2V4YW1wbGVzIHRlc3RhYmxlIHw+IE9yX2Vycm9yLm9rX2V4blxuOztcbiIsIm9wZW4hIEJhc2VcbmluY2x1ZGUgT2JzZXJ2ZXIwXG5cbmxldCB1bm1hcCB0IH5mID0gY3JlYXRlIChmdW4geCB+c2l6ZSB+aGFzaCAtPiBvYnNlcnZlIHQgKGYgeCkgfnNpemUgfmhhc2gpXG5sZXQgb2ZfaGFzaF9mb2xkIGYgPSBjcmVhdGUgKGZ1biB4IH5zaXplOl8gfmhhc2ggLT4gZiBoYXNoIHgpXG5sZXQgb2ZfbGF6eSBsYXp5X3QgPSBjcmVhdGUgKGZ1biB4IH5zaXplIH5oYXNoIC0+IG9ic2VydmUgKGZvcmNlIGxhenlfdCkgeCB+c2l6ZSB+aGFzaClcblxubGV0IGZpeGVkX3BvaW50IHdyYXAgPVxuICBsZXQgcmVjIGxhenlfdCA9IGxhenkgKHdyYXAgKG9mX2xhenkgbGF6eV90KSkgaW5cbiAgb2ZfbGF6eSBsYXp5X3Rcbjs7XG5cbmxldCB1bml0ID0gb3BhcXVlXG5sZXQgYm9vbCA9IG9mX2hhc2hfZm9sZCBCb29sLmhhc2hfZm9sZF90XG5sZXQgY2hhciA9IG9mX2hhc2hfZm9sZCBDaGFyLmhhc2hfZm9sZF90XG5sZXQgaW50ID0gb2ZfaGFzaF9mb2xkIEludC5oYXNoX2ZvbGRfdFxubGV0IGludDMyID0gb2ZfaGFzaF9mb2xkIEludDMyLmhhc2hfZm9sZF90XG5sZXQgaW50NjMgPSBvZl9oYXNoX2ZvbGQgSW50NjMuaGFzaF9mb2xkX3RcbmxldCBpbnQ2NCA9IG9mX2hhc2hfZm9sZCBJbnQ2NC5oYXNoX2ZvbGRfdFxubGV0IG5hdGl2ZWludCA9IG9mX2hhc2hfZm9sZCBOYXRpdmVpbnQuaGFzaF9mb2xkX3RcbmxldCBmbG9hdCA9IG9mX2hhc2hfZm9sZCBGbG9hdC5oYXNoX2ZvbGRfdFxubGV0IHN0cmluZyA9IG9mX2hhc2hfZm9sZCBTdHJpbmcuaGFzaF9mb2xkX3RcbmxldCBzZXhwID0gb2ZfaGFzaF9mb2xkIFNleHAuaGFzaF9mb2xkX3RcbmxldCBiaWdzdHJpbmcgPSBvZl9oYXNoX2ZvbGQgKEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkxLmhhc2hfZm9sZCBoYXNoX2ZvbGRfY2hhcilcbmxldCBmbG9hdDMyX3ZlYyA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDY0X3ZlYyA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDMyX21hdCA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDY0X21hdCA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBieXRlcyA9IHVubWFwIHN0cmluZyB+ZjpCeXRlcy50b19zdHJpbmdcblxubGV0IGVpdGhlciBmc3RfdCBzbmRfdCA9XG4gIGNyZWF0ZSAoZnVuIGVpdGhlciB+c2l6ZSB+aGFzaCAtPlxuICAgIG1hdGNoIChlaXRoZXIgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgfCBGaXJzdCBmc3QgLT4gb2JzZXJ2ZSBmc3RfdCBmc3QgfnNpemUgfmhhc2g6KGhhc2hfZm9sZF9pbnQgaGFzaCAxKVxuICAgIHwgU2Vjb25kIHNuZCAtPiBvYnNlcnZlIHNuZF90IHNuZCB+c2l6ZSB+aGFzaDooaGFzaF9mb2xkX2ludCBoYXNoIDIpKVxuOztcblxubGV0IHJlc3VsdCBva190IGVycl90ID1cbiAgdW5tYXAgKGVpdGhlciBva190IGVycl90KSB+ZjooZnVuY3Rpb25cbiAgICB8IE9rIG9rIC0+IEZpcnN0IG9rXG4gICAgfCBFcnJvciBlcnIgLT4gU2Vjb25kIGVycilcbjs7XG5cbmxldCBib3RoIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gKGZzdCwgc25kKSB+c2l6ZSB+aGFzaCAtPlxuICAgIGxldCBoYXNoID0gb2JzZXJ2ZSBmc3RfdCBmc3QgfnNpemUgfmhhc2ggaW5cbiAgICBsZXQgaGFzaCA9IG9ic2VydmUgc25kX3Qgc25kIH5zaXplIH5oYXNoIGluXG4gICAgaGFzaClcbjs7XG5cbmxldCBvcHRpb24gdmFsdWVfdCA9XG4gIHVubWFwIChlaXRoZXIgb3BhcXVlIHZhbHVlX3QpIH5mOihmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBGaXJzdCAoKVxuICAgIHwgU29tZSB2YWx1ZSAtPiBTZWNvbmQgdmFsdWUpXG47O1xuXG5sZXQgbGlzdCBlbHRfdCA9XG4gIGNyZWF0ZSAoZnVuIGxpc3QgfnNpemUgfmhhc2ggLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20ub2ZfaW50IChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpIGluXG4gICAgbGV0IGxlbmd0aCA9IExpc3QubGVuZ3RoIGxpc3QgaW5cbiAgICBsZXQgc2l6ZXMgPVxuICAgICAgR2VuZXJhdG9yLnNpemVzIH5taW5fbGVuZ3RoOmxlbmd0aCB+bWF4X2xlbmd0aDpsZW5ndGggKClcbiAgICAgIHw+IEdlbmVyYXRvci5nZW5lcmF0ZSB+c2l6ZSB+cmFuZG9tXG4gICAgaW5cbiAgICBMaXN0LmZvbGQyX2V4biBsaXN0IHNpemVzIH5pbml0OihoYXNoX2ZvbGRfaW50IGhhc2ggMCkgfmY6KGZ1biBoYXNoIGVsdCBzaXplIC0+XG4gICAgICBvYnNlcnZlIGVsdF90IGVsdCB+c2l6ZSB+aGFzaDooaGFzaF9mb2xkX2ludCBoYXNoIDEpKSlcbjs7XG5cbmxldCBhcnJheSB0ID0gdW5tYXAgKGxpc3QgdCkgfmY6QXJyYXkudG9fbGlzdFxubGV0IHJlZiB0ID0gdW5tYXAgdCB+ZjpSZWYuKCAhIClcbmxldCBsYXp5X3QgdCA9IHVubWFwIHQgfmY6TGF6eS5mb3JjZVxuXG5sZXQgZm4gZG9tIHJuZyA9XG4gIGNyZWF0ZSAoZnVuIGYgfnNpemUgfmhhc2ggLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20ub2ZfaW50IChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpIGluXG4gICAgbGV0IHNpemVzID1cbiAgICAgICgqIEVtcGlyaWNhbGx5LCBkb3VibGluZyB0aGUgc2l6ZSB3aGVuIGdlbmVyYXRpbmcgdGhlIGxpc3Qgb2YgaW5wdXRzIGdpdmVzIHVzIG11Y2hcbiAgICAgICAgIGJldHRlciBjb3ZlcmFnZSBvZiB0aGUgc3BhY2Ugb2YgZnVuY3Rpb25zLiAqKVxuICAgICAgR2VuZXJhdG9yLmdlbmVyYXRlIChHZW5lcmF0b3Iuc2l6ZXMgKCkpIH5zaXplOihzaXplICogMikgfnJhbmRvbVxuICAgIGluXG4gICAgTGlzdC5mb2xkIHNpemVzIH5pbml0Omhhc2ggfmY6KGZ1biBoYXNoIHNpemUgLT5cbiAgICAgIGxldCB4ID0gR2VuZXJhdG9yLmdlbmVyYXRlIGRvbSB+c2l6ZSB+cmFuZG9tIGluXG4gICAgICBvYnNlcnZlIHJuZyAoZiB4KSB+c2l6ZSB+aGFzaCkpXG47O1xuXG5sZXQgbWFwX3RyZWUga2V5X29icyBkYXRhX29icyA9XG4gIHVubWFwIChsaXN0IChib3RoIGtleV9vYnMgZGF0YV9vYnMpKSB+ZjpNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnRvX2FsaXN0XG47O1xuXG5sZXQgc2V0X3RyZWUgZWx0X29icyA9IHVubWFwIChsaXN0IGVsdF9vYnMpIH5mOlNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fbGlzdFxuXG5sZXQgbWFwX3Qga2V5X29icyBkYXRhX29icyA9XG4gIHVubWFwIChtYXBfdHJlZSBrZXlfb2JzIGRhdGFfb2JzKSB+ZjpNYXAuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG47O1xuXG5sZXQgc2V0X3QgZWx0X29icyA9IHVubWFwIChzZXRfdHJlZSBlbHRfb2JzKSB+ZjpTZXQuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG4iLCJtb2R1bGUgR2VuZXJhdG9yID0gR2VuZXJhdG9yXG5tb2R1bGUgT2JzZXJ2ZXIgPSBPYnNlcnZlclxubW9kdWxlIFNocmlua2VyID0gU2hyaW5rZXJcbm1vZHVsZSBUZXN0ID0gVGVzdFxubW9kdWxlIEV4cG9ydCA9IEV4cG9ydFxuaW5jbHVkZSBFeHBvcnRcblxuKCoqLyoqKVxuXG4oKl8gVGhpcyBtb2R1bGUgaXMgZXhwb3NlZCBvbmx5IHRvIG1ha2Ugb2NhbWxkb2Mgb3V0cHV0IG1vcmUgcmVhZGFibGUuICopXG5tb2R1bGUgV2l0aF9iYXNpY190eXBlcyA9IFdpdGhfYmFzaWNfdHlwZXNcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIEJpZ2FycmF5X2hlbHBlcnMgPSBCaWdhcnJheV9oZWxwZXJzXG5lbmRcbiJdfQ==
