// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ppx_module_timer_runtime
//# unitInfo: Requires: Base, Base__Int, Base__Int63, Base__List, Base__Option, Base__Printf, Base__String, CamlinternalLazy, Stdio, Stdlib, Stdlib__Gc, Stdlib__Sys, Time_now
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_PPX_MODULE_TIMER = "PPX_MODULE_TIMER",
    cst_ns$1 = "ns",
    cst_runtime_ppx_module_timer_r = "runtime/ppx_module_timer_runtime.ml",
    caml_gc_quick_stat = runtime.caml_gc_quick_stat,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = "\n",
    cst$1 = " ",
    cst$2 = cst$4,
    cst$0 = cst$4,
    cst = cst$4,
    am_recording_environment_varia = cst_PPX_MODULE_TIMER,
    Base = global_data.Base,
    Base_List = global_data.Base__List,
    Base_String = global_data.Base__String,
    Base_Int63 = global_data.Base__Int63,
    Stdio = global_data.Stdio,
    Base_Option = global_data.Base__Option,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Printf = global_data.Base__Printf,
    Base_Int = global_data.Base__Int,
    Time_now = global_data.Time_now,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib;
   a:
   {
    var
     cst_ppx_module_timer_overridin =
       "ppx_module_timer: overriding time measurements for testing",
     _e_ = [0, [11, "Line ", [4, 0, 0, 0, 0]], "Line %d"],
     _f_ =
       [0, [11, "Fake__Dependency_", [4, 0, 0, 0, 0]], "Fake__Dependency_%d"],
     _d_ = [0, [2, [1, 1], [12, 32, [2, 0, 0]]], "%*s %s"],
     cst_compactions = "compactions",
     cst_major_collections = "major collections",
     cst_minor_collections = "minor collections",
     _c_ = [0, ", "],
     cst_GC = "; GC: ",
     _b_ = [0, cst_runtime_ppx_module_timer_r, 110, 6],
     _a_ = [0, cst_runtime_ppx_module_timer_r, 94, 6],
     cst_ns$0 = cst_ns$1,
     cst_ns = cst_ns$1;
    try{var value = runtime.caml_sys_getenv(cst_PPX_MODULE_TIMER);}
    catch(_X_){var am_recording_value = 0; break a;}
    var am_recording_value = [0, value];
   }
   var am_recording = caml_call1(Base_Option[53], am_recording_value);
   function to_nanoseconds(t){return t;}
   function of_nanoseconds(t){return t;}
   function of_string(string){
    var _W_ = caml_call2(Base_String[114], string, cst_ns);
    return caml_call1(Base_Int63[10], _W_);
   }
   function to_string(nanos){
    var _V_ = caml_call1(Base_Int63[11], nanos);
    return caml_call2(Base[241], _V_, cst_ns$0);
   }
   function to_string_with_same_unit(list){
    return caml_call2(Base_List[53], list, to_string);
   }
   var format = [0, [0, of_string, to_string_with_same_unit]];
   function create(nested_timer, param){
    var _U_ = caml_gc_quick_stat(0);
    return [0, cst, Base_Int63[42], _U_, nested_timer, 0];
   }
   function record_start(t, description){
    if(am_recording){
     if(! caml_call1(Base_String[14], t[1]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     t[1] = description;
     t[3] = caml_gc_quick_stat(0);
     t[2] = caml_call1(Time_now[2], 0);
     var _T_ = 0;
    }
    else
     var _T_ = am_recording;
    return _T_;
   }
   function record_until(t, description){
    if(! am_recording) return am_recording;
    var
     until = caml_call1(Time_now[2], 0),
     start = t[2],
     gc_stats_after = caml_gc_quick_stat(0),
     gc_stats_before = t[3],
     runtime = caml_call2(Base_Int63[46], until, start);
    if(! caml_call2(Base_String[134], t[1], description))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var
     gc_events =
       [0,
        gc_stats_after[4] - gc_stats_before[4] | 0,
        gc_stats_after[5] - gc_stats_before[5] | 0,
        gc_stats_after[14] - gc_stats_before[14] | 0],
     match$0 = t[4];
    if(match$0)
     var
      nested$0 = match$0[1],
      nested_timing_events = caml_call1(Base_List[63], nested$0[5]);
    else
     var nested_timing_events = 0;
    var
     timing_event = [0, description, runtime, gc_events, nested_timing_events];
    t[5] = [0, timing_event, t[5]];
    t[1] = cst$0;
    t[2] = Base_Int63[42];
    var match = t[4];
    if(! match) return 0;
    var nested = match[1];
    nested[5] = 0;
    return 0;
   }
   var
    definition_timer = create(0, 0),
    module_timer = create([0, definition_timer], 0);
   function record_start$0(module_name){
    return record_start(module_timer, module_name);
   }
   function record_until$0(module_name){
    return record_until(module_timer, module_name);
   }
   function record_definition_start(loc){
    return record_start(definition_timer, loc);
   }
   function record_definition_until(loc){
    return record_until(definition_timer, loc);
   }
   function timing_events_to_strings(list, indent){
    function _D_(timing_event){return timing_event[2];}
    var
     string = caml_call2(Base_List[53], list, _D_),
     Format = format[1],
     duration_strings = caml_call1(Format[2], string),
     prefix = caml_call2(Base_String[66], indent, 32);
    function _E_(duration_string, param){
     var
      nested_timing_events = param[4],
      gc_events = param[3],
      description = param[1];
     function _L_(line){return caml_call2(Base[241], cst$3, line);}
     var
      _M_ = timing_events_to_strings(nested_timing_events, indent + 4 | 0),
      _N_ = caml_call2(Base_List[53], _M_, _L_),
      _O_ = caml_call2(Base_String[68], 0, _N_),
      compactions = gc_events[3],
      major_collections = gc_events[2],
      minor_collections = gc_events[1];
     function to_list(description, count){
      if(0 === count) return 0;
      var
       _R_ = caml_call2(Base[241], cst$1, description),
       _S_ = caml_call1(Base_Int[12], count);
      return [0, caml_call2(Base[241], _S_, _R_), 0];
     }
     var
      _G_ = to_list(cst_compactions, compactions),
      _H_ = to_list(cst_major_collections, major_collections),
      _I_ = caml_call2(Base[222], _H_, _G_),
      _J_ = to_list(cst_minor_collections, minor_collections),
      strings = caml_call2(Base[222], _J_, _I_);
     if(caml_call1(Base_List[18], strings))
      var _P_ = cst$2;
     else
      var
       _K_ = caml_call2(Base_String[68], _c_, strings),
       _P_ = caml_call2(Base[241], cst_GC, _K_);
     var _Q_ = caml_call2(Base[241], _P_, _O_);
     return [0, duration_string, caml_call2(Base[241], description, _Q_)];
    }
    var list$0 = caml_call3(Base_List[98], duration_strings, list, _E_);
    function _A_(width, param){
     var left = param[1];
     return caml_call2
             (Base_Int[16], width, runtime.caml_ml_string_length(left));
    }
    var left_column_width = caml_call3(Base_List[20], list$0, 0, _A_);
    function _B_(param){
     var right = param[2], left = param[1];
     return caml_call4(Base_Printf[2], _d_, left_column_width, left, right);
    }
    var _C_ = caml_call2(Base_List[53], list$0, _B_), _F_ = Base_List[53];
    return caml_call2
            (_F_,
             _C_,
             function(line){return caml_call2(Base[241], prefix, line);});
   }
   function gc_events(i){
    var
     _x_ = 7 === caml_call2(Base[227], i, 8) ? 1 : 0,
     _y_ = 3 === caml_call2(Base[227], i, 4) ? 1 : 0,
     _z_ = 1 === caml_call2(Base[227], i, 2) ? 1 : 0;
    return [0, _z_, _y_, _x_];
   }
   var
    fake_timing_events =
      [246,
       function(_p_){
        function _q_(i){
         if(0 === caml_call2(Base[227], i + 1 | 0, 4))
          var
           _r_ =
             function(j){
              var
               _v_ = gc_events(j),
               _w_ = caml_call1(Base_Int63[100], 900 * (j + 1 | 0) | 0);
              return [0,
                      caml_call2(Base_Printf[2], _e_, j + 1 | 0),
                      _w_,
                      _v_,
                      0];
             },
           _s_ = caml_call2(Base_List[40], i + 1 | 0, _r_);
         else
          var _s_ = 0;
         var
          _t_ = gc_events(i),
          _u_ = caml_call1(Base_Int63[100], 900 * (i + 1 | 0) | 0);
         return [0, caml_call2(Base_Printf[2], _f_, i + 1 | 0), _u_, _t_, _s_];
        }
        return caml_call2(Base_List[40], 12, _q_);
       }];
   if(am_recording){
    var
     _g_ =
       function(param){
        var timing_events$0 = caml_call1(Base_List[63], module_timer[5]);
        function notify_of_overriding(param){
         return caml_call1(Stdio[9], cst_ppx_module_timer_overridin);
        }
        var string = caml_call4(Base_Option[31], 0, 0, 0, am_recording_value);
        a:
        if(runtime.caml_string_notequal(string, "FAKE_MODULES")){
         try{var Format = format[1], override = caml_call1(Format[1], string);
         }
         catch(_o_){var timing_events = timing_events$0; break a;}
         notify_of_overriding(0);
         var
          _i_ =
            function(index, timing_event){
             var
              _l_ = caml_call1(Base_Int63[100], index + 1 | 0),
              runtime = caml_call2(Base_Int63[47], override, _l_);
             function _m_(index, nested_timing_event){
              var
               _n_ = caml_call1(Base_Int63[100], index + 1 | 0),
               runtime = caml_call2(Base_Int63[47], override, _n_);
              return [0,
                      nested_timing_event[1],
                      runtime,
                      nested_timing_event[3],
                      nested_timing_event[4]];
             }
             var
              nested_timing_events =
                caml_call2(Base_List[41], timing_event[4], _m_);
             return [0,
                     timing_event[1],
                     runtime,
                     timing_event[3],
                     nested_timing_events];
            },
          timing_events = caml_call2(Base_List[41], timing_events$0, _i_);
        }
        else{
         notify_of_overriding(0);
         var _j_ = runtime.caml_obj_tag(fake_timing_events);
         b:
         if(250 === _j_)
          var _k_ = fake_timing_events[1];
         else{
          if(246 !== _j_ && 244 !== _j_){
           var _k_ = fake_timing_events;
           break b;
          }
          var _k_ = caml_call1(CamlinternalLazy[2], fake_timing_events);
         }
         var timing_events = _k_;
        }
        var _h_ = timing_events_to_strings(timing_events, 0);
        return caml_call2(Base_List[19], _h_, Stdio[9]);
       };
    caml_call1(Stdlib[100], _g_);
   }
   var
    Ppx_module_timer_runtime =
      [0,
       am_recording,
       am_recording_environment_varia,
       [0, to_nanoseconds, of_nanoseconds, format],
       record_start$0,
       record_until$0,
       record_definition_start,
       record_definition_until];
   runtime.caml_register_global
    (32, Ppx_module_timer_runtime, "Ppx_module_timer_runtime");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfbW9kdWxlX3RpbWVyX3J1bnRpbWUuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImFtX3JlY29yZGluZ19lbnZpcm9ubWVudF92YXJpYSIsInZhbHVlIiwiYW1fcmVjb3JkaW5nX3ZhbHVlIiwiYW1fcmVjb3JkaW5nIiwidG9fbmFub3NlY29uZHMiLCJ0Iiwib2ZfbmFub3NlY29uZHMiLCJvZl9zdHJpbmciLCJzdHJpbmciLCJ0b19zdHJpbmciLCJuYW5vcyIsInRvX3N0cmluZ193aXRoX3NhbWVfdW5pdCIsImxpc3QiLCJmb3JtYXQiLCJjcmVhdGUiLCJuZXN0ZWRfdGltZXIiLCJyZWNvcmRfc3RhcnQiLCJkZXNjcmlwdGlvbiIsInJlY29yZF91bnRpbCIsInVudGlsIiwic3RhcnQiLCJnY19zdGF0c19hZnRlciIsImdjX3N0YXRzX2JlZm9yZSIsInJ1bnRpbWUiLCJnY19ldmVudHMiLCJuZXN0ZWQkMCIsIm5lc3RlZF90aW1pbmdfZXZlbnRzIiwidGltaW5nX2V2ZW50IiwibmVzdGVkIiwiZGVmaW5pdGlvbl90aW1lciIsIm1vZHVsZV90aW1lciIsInJlY29yZF9zdGFydCQwIiwibW9kdWxlX25hbWUiLCJyZWNvcmRfdW50aWwkMCIsInJlY29yZF9kZWZpbml0aW9uX3N0YXJ0IiwibG9jIiwicmVjb3JkX2RlZmluaXRpb25fdW50aWwiLCJ0aW1pbmdfZXZlbnRzX3RvX3N0cmluZ3MiLCJpbmRlbnQiLCJGb3JtYXQiLCJkdXJhdGlvbl9zdHJpbmdzIiwicHJlZml4IiwiZHVyYXRpb25fc3RyaW5nIiwibGluZSIsImNvbXBhY3Rpb25zIiwibWFqb3JfY29sbGVjdGlvbnMiLCJtaW5vcl9jb2xsZWN0aW9ucyIsInRvX2xpc3QiLCJjb3VudCIsInN0cmluZ3MiLCJsaXN0JDAiLCJ3aWR0aCIsImxlZnQiLCJsZWZ0X2NvbHVtbl93aWR0aCIsInJpZ2h0IiwiaSIsImZha2VfdGltaW5nX2V2ZW50cyIsImoiLCJ0aW1pbmdfZXZlbnRzJDAiLCJub3RpZnlfb2Zfb3ZlcnJpZGluZyIsIm92ZXJyaWRlIiwidGltaW5nX2V2ZW50cyIsImluZGV4IiwibmVzdGVkX3RpbWluZ19ldmVudCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9wcHhfbW9kdWxlX3RpbWVyL3J1bnRpbWUvcHB4X21vZHVsZV90aW1lcl9ydW50aW1lLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7OztJQUtJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUlGLElBQU0sSUFDSkMsUUFESTttQkFLSkM7UUFBQUEseUJBSkFEOztHQUtlLElBQWZFLGVBQWUsNEJBRGZEO1lBTUVFLGVBQWVDLEdBQUksT0FBSkEsRUFBSztZQUNwQkMsZUFBZUQsR0FBSSxPQUFKQSxFQUFLO1lBUWxCRSxVQUFVQztJQUFTLFVBQUEsNkJBQVRBO0lBQVMsT0FBQTtHQUE2RDtZQUNoRkMsVUFBVUM7SUFBUSxVQUFBLDJCQUFSQTtJQUFRLE9BQUE7R0FBNEI7WUFDOUNDLHlCQUF5QkM7SUFBTyxpQ0FBUEEsTUFEekJIO0dBQzBEO0dBR25ELElBQVRJLGlCQUxFTixXQUVBSTtZQTBDRkcsT0FBUUM7SUFHcUIsVUFBQTtJQUYvQixxQ0FEVUE7R0FNVDtZQVdDQyxhQUFhWCxHQUFFWTtJQUNqQixHQTVFQWQ7S0E4RVMsS0FBQSw0QkFITUU7TUFHYixNQUFBO0tBSGFBLE9BQUVZO0tBQUZaLE9BS21CO0tBTG5CQSxPQU9xQjs7OztlQWxGcENGOztHQWtGOEU7WUFHNUVlLGFBQWFiLEdBQUVZO0lBQ2pCLEtBdEZBZCxjQUFlLE9BQWZBO0lBeUZjO0tBQVJnQixRQUFRO0tBQ1JDLFFBTFNmO0tBTVRnQixpQkFBaUI7S0FDakJDLGtCQVBTakI7S0FRVGtCLFVBQVUsMkJBSlZKLE9BQ0FDO0lBSUcsS0FBQSw2QkFUTWYsTUFBRVk7S0FTZixNQUFBO0lBRUU7S0FERU87O1FBSkFILG9CQUNBQztRQURB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QzthQUNyQztjQUFtQyxNQUFBLDRCQURMbUM7Y0FDMUJ2QyxVQUFVLDJCQUhoQnFDO2FBSUUsYUFHWUUsT0FBTUM7Y0FDZDtlQUFtQyxNQUFBLDRCQUQzQkQ7ZUFDSnZDLFVBQVUsMkJBUnBCcUM7Y0FTTTtzQkFGY0c7c0JBQ1Z4QztzQkFEVXdDO3NCQUFBQTthQUVzQjthQUp0QztjQURFckM7Z0JBQ0YsMEJBSG1DQzthQVNyQztxQkFUcUNBO3FCQUNqQ0o7cUJBRGlDSTtxQkFFakNEO1lBTytDO1VBbEJ4RG1DLGdCQVNHLDBCQWJ3Qkg7OztTQUMzQkM7d0NBMUJGSDs7O29CQUFBQTs7O3FCQUFBQTs7O29EQUFBQTs7YUE2QkVLOztrQkFwREV4Qix5QkFvREZ3QjtRQXFCSixPQUFBO09BUTBFO0lBRnhFOzs7OztPQWpPQTFEO09BVkFIO1dBZUVJLGdCQUNBRSxnQkFhQU87T0FvR0ZrQjtPQUNBRTtPQUNBQztPQUNBRTs7OztFIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiEgQmFzZVxubW9kdWxlIEdjID0gU3RkbGliLkdjXG5cbmV4dGVybmFsIF9fTU9EVUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfTU9EVUxFXCJcblxubGV0IGFtX3JlY29yZGluZ19lbnZpcm9ubWVudF92YXJpYWJsZSA9IFwiUFBYX01PRFVMRV9USU1FUlwiXG5cbmxldCBnZXRfYW1fcmVjb3JkaW5nX2Vudmlyb25tZW50X3ZhcmlhYmxlICgpID1cbiAgKCogYXZvaWQgU3RkbGliLlN5cy5nZXRlbnZfb3B0IHRvIHByZXNlcnZlIDQuMDQueCBjb21wYXRpYmlsaXR5ICopXG4gIG1hdGNoIFN0ZGxpYi5TeXMuZ2V0ZW52IGFtX3JlY29yZGluZ19lbnZpcm9ubWVudF92YXJpYWJsZSB3aXRoXG4gIHwgdmFsdWUgLT4gU29tZSB2YWx1ZVxuICB8IGV4Y2VwdGlvbiBfIC0+IE5vbmVcbjs7XG5cbmxldCBhbV9yZWNvcmRpbmdfdmFsdWUgPSBnZXRfYW1fcmVjb3JkaW5nX2Vudmlyb25tZW50X3ZhcmlhYmxlICgpXG5sZXQgYW1fcmVjb3JkaW5nID0gT3B0aW9uLmlzX3NvbWUgYW1fcmVjb3JkaW5nX3ZhbHVlXG5cbm1vZHVsZSBEdXJhdGlvbiA9IHN0cnVjdFxuICB0eXBlIHQgPSBJbnQ2My50XG5cbiAgbGV0IHRvX25hbm9zZWNvbmRzIHQgPSB0XG4gIGxldCBvZl9uYW5vc2Vjb25kcyB0ID0gdFxuXG4gIG1vZHVsZSB0eXBlIEZvcm1hdCA9IHNpZ1xuICAgIHZhbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gdFxuICAgIHZhbCB0b19zdHJpbmdfd2l0aF9zYW1lX3VuaXQgOiB0IGxpc3QgLT4gc3RyaW5nIGxpc3RcbiAgZW5kXG5cbiAgbW9kdWxlIERlZmF1bHRfZm9ybWF0ID0gc3RydWN0XG4gICAgbGV0IG9mX3N0cmluZyBzdHJpbmcgPSBTdHJpbmcuY2hvcF9zdWZmaXhfZXhuIHN0cmluZyB+c3VmZml4OlwibnNcIiB8PiBJbnQ2My5vZl9zdHJpbmdcbiAgICBsZXQgdG9fc3RyaW5nIG5hbm9zID0gSW50NjMudG9fc3RyaW5nIG5hbm9zIF4gXCJuc1wiXG4gICAgbGV0IHRvX3N0cmluZ193aXRoX3NhbWVfdW5pdCBsaXN0ID0gTGlzdC5tYXAgbGlzdCB+Zjp0b19zdHJpbmdcbiAgZW5kXG5cbiAgbGV0IGZvcm1hdCA9IHJlZiAobW9kdWxlIERlZmF1bHRfZm9ybWF0IDogRm9ybWF0KVxuXG4gIGxldCBvZl9zdHJpbmcgc3RyaW5nID1cbiAgICBsZXQgKG1vZHVsZSBGb3JtYXQpID0gIWZvcm1hdCBpblxuICAgIEZvcm1hdC5vZl9zdHJpbmcgc3RyaW5nXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZ193aXRoX3NhbWVfdW5pdCBzdHJpbmcgPVxuICAgIGxldCAobW9kdWxlIEZvcm1hdCkgPSAhZm9ybWF0IGluXG4gICAgRm9ybWF0LnRvX3N0cmluZ193aXRoX3NhbWVfdW5pdCBzdHJpbmdcbiAgOztcbmVuZFxuXG5tb2R1bGUgR2NfZXZlbnRzID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBtaW5vcl9jb2xsZWN0aW9ucyA6IGludFxuICAgIDsgbWFqb3JfY29sbGVjdGlvbnMgOiBpbnRcbiAgICA7IGNvbXBhY3Rpb25zIDogaW50XG4gICAgfVxuZW5kXG5cbm1vZHVsZSBUaW1pbmdfZXZlbnQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGRlc2NyaXB0aW9uIDogc3RyaW5nXG4gICAgOyBydW50aW1lIDogRHVyYXRpb24udFxuICAgIDsgZ2NfZXZlbnRzIDogR2NfZXZlbnRzLnRcbiAgICA7IG5lc3RlZF90aW1pbmdfZXZlbnRzIDogdCBsaXN0XG4gICAgfVxuZW5kXG5cbm1vZHVsZSBUaW1lciA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgbXV0YWJsZSBjdXJyZW50bHlfcnVubmluZ19kZXNjcmlwdGlvbiA6IHN0cmluZ1xuICAgIDsgbXV0YWJsZSBjdXJyZW50bHlfcnVubmluZ19zdGFydF90aW1lIDogRHVyYXRpb24udFxuICAgIDsgbXV0YWJsZSBjdXJyZW50bHlfcnVubmluZ19nY19zdGF0cyA6IEdjLnN0YXRcbiAgICA7IG11dGFibGUgbmVzdGVkX3RpbWVyIDogdCBvcHRpb25cbiAgICA7IG11dGFibGUgdGltaW5nX2V2ZW50c19pbl9yZXZlcnNlX2Nocm9ub2xvZ2ljYWxfb3JkZXIgOiBUaW1pbmdfZXZlbnQudCBsaXN0XG4gICAgfVxuXG4gIGxldCBjcmVhdGUgP25lc3RlZF90aW1lciAoKSA9XG4gICAgeyBjdXJyZW50bHlfcnVubmluZ19kZXNjcmlwdGlvbiA9IFwiXCJcbiAgICA7IGN1cnJlbnRseV9ydW5uaW5nX3N0YXJ0X3RpbWUgPSBJbnQ2My56ZXJvXG4gICAgOyBjdXJyZW50bHlfcnVubmluZ19nY19zdGF0cyA9IEdjLnF1aWNrX3N0YXQgKClcbiAgICA7IG5lc3RlZF90aW1lclxuICAgIDsgdGltaW5nX2V2ZW50c19pbl9yZXZlcnNlX2Nocm9ub2xvZ2ljYWxfb3JkZXIgPSBbXVxuICAgIH1cbiAgOztcblxuICBsZXQgcmVzZXQgdCA9XG4gICAgdC5jdXJyZW50bHlfcnVubmluZ19kZXNjcmlwdGlvbiA8LSBcIlwiO1xuICAgIHQuY3VycmVudGx5X3J1bm5pbmdfc3RhcnRfdGltZSA8LSBJbnQ2My56ZXJvO1xuICAgIG1hdGNoIHQubmVzdGVkX3RpbWVyIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgbmVzdGVkIC0+IG5lc3RlZC50aW1pbmdfZXZlbnRzX2luX3JldmVyc2VfY2hyb25vbG9naWNhbF9vcmRlciA8LSBbXVxuICA7O1xuXG4gIGxldCByZWNvcmRfc3RhcnQgdCBkZXNjcmlwdGlvbiA9XG4gICAgaWYgYW1fcmVjb3JkaW5nXG4gICAgdGhlbiAoXG4gICAgICBhc3NlcnQgKFN0cmluZy5pc19lbXB0eSB0LmN1cnJlbnRseV9ydW5uaW5nX2Rlc2NyaXB0aW9uKTtcbiAgICAgIHQuY3VycmVudGx5X3J1bm5pbmdfZGVzY3JpcHRpb24gPC0gZGVzY3JpcHRpb247XG4gICAgICB0LmN1cnJlbnRseV9ydW5uaW5nX2djX3N0YXRzIDwtIEdjLnF1aWNrX3N0YXQgKCk7XG4gICAgICAoKiBjYWxsIFtUaW1lX25vd10gYXMgbGF0ZSBhcyBwb3NzaWJsZSBiZWZvcmUgcnVubmluZyB0aGUgbW9kdWxlIGJvZHkgKilcbiAgICAgIHQuY3VycmVudGx5X3J1bm5pbmdfc3RhcnRfdGltZSA8LSBUaW1lX25vdy5uYW5vc2Vjb25kX2NvdW50ZXJfZm9yX3RpbWluZyAoKSlcbiAgOztcblxuICBsZXQgcmVjb3JkX3VudGlsIHQgZGVzY3JpcHRpb24gPVxuICAgIGlmIGFtX3JlY29yZGluZ1xuICAgIHRoZW4gKFxuICAgICAgKCogY29tcHV0ZSBbVGltZV9ub3ddIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgcnVubmluZyB0aGUgbW9kdWxlIGJvZHkgKilcbiAgICAgIGxldCB1bnRpbCA9IFRpbWVfbm93Lm5hbm9zZWNvbmRfY291bnRlcl9mb3JfdGltaW5nICgpIGluXG4gICAgICBsZXQgc3RhcnQgPSB0LmN1cnJlbnRseV9ydW5uaW5nX3N0YXJ0X3RpbWUgaW5cbiAgICAgIGxldCBnY19zdGF0c19hZnRlciA9IEdjLnF1aWNrX3N0YXQgKCkgaW5cbiAgICAgIGxldCBnY19zdGF0c19iZWZvcmUgPSB0LmN1cnJlbnRseV9ydW5uaW5nX2djX3N0YXRzIGluXG4gICAgICBsZXQgcnVudGltZSA9IEludDYzLiggLSApIHVudGlsIHN0YXJ0IGluXG4gICAgICBhc3NlcnQgKFN0cmluZy5lcXVhbCB0LmN1cnJlbnRseV9ydW5uaW5nX2Rlc2NyaXB0aW9uIGRlc2NyaXB0aW9uKTtcbiAgICAgIGxldCBnY19ldmVudHMgOiBHY19ldmVudHMudCA9XG4gICAgICAgIHsgbWlub3JfY29sbGVjdGlvbnMgPVxuICAgICAgICAgICAgZ2Nfc3RhdHNfYWZ0ZXIubWlub3JfY29sbGVjdGlvbnMgLSBnY19zdGF0c19iZWZvcmUubWlub3JfY29sbGVjdGlvbnNcbiAgICAgICAgOyBtYWpvcl9jb2xsZWN0aW9ucyA9XG4gICAgICAgICAgICBnY19zdGF0c19hZnRlci5tYWpvcl9jb2xsZWN0aW9ucyAtIGdjX3N0YXRzX2JlZm9yZS5tYWpvcl9jb2xsZWN0aW9uc1xuICAgICAgICA7IGNvbXBhY3Rpb25zID0gZ2Nfc3RhdHNfYWZ0ZXIuY29tcGFjdGlvbnMgLSBnY19zdGF0c19iZWZvcmUuY29tcGFjdGlvbnNcbiAgICAgICAgfVxuICAgICAgaW5cbiAgICAgIGxldCBuZXN0ZWRfdGltaW5nX2V2ZW50cyA9XG4gICAgICAgIG1hdGNoIHQubmVzdGVkX3RpbWVyIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFtdXG4gICAgICAgIHwgU29tZSBuZXN0ZWQgLT4gTGlzdC5yZXYgbmVzdGVkLnRpbWluZ19ldmVudHNfaW5fcmV2ZXJzZV9jaHJvbm9sb2dpY2FsX29yZGVyXG4gICAgICBpblxuICAgICAgbGV0IHRpbWluZ19ldmVudCA6IFRpbWluZ19ldmVudC50ID1cbiAgICAgICAgeyBkZXNjcmlwdGlvbjsgcnVudGltZTsgZ2NfZXZlbnRzOyBuZXN0ZWRfdGltaW5nX2V2ZW50cyB9XG4gICAgICBpblxuICAgICAgdC50aW1pbmdfZXZlbnRzX2luX3JldmVyc2VfY2hyb25vbG9naWNhbF9vcmRlclxuICAgICAgICA8LSB0aW1pbmdfZXZlbnQgOjogdC50aW1pbmdfZXZlbnRzX2luX3JldmVyc2VfY2hyb25vbG9naWNhbF9vcmRlcjtcbiAgICAgIHJlc2V0IHQpXG4gIDs7XG5lbmRcblxubGV0IGRlZmluaXRpb25fdGltZXIgPSBUaW1lci5jcmVhdGUgKClcbmxldCBtb2R1bGVfdGltZXIgPSBUaW1lci5jcmVhdGUgfm5lc3RlZF90aW1lcjpkZWZpbml0aW9uX3RpbWVyICgpXG5sZXQgcmVjb3JkX3N0YXJ0IG1vZHVsZV9uYW1lID0gVGltZXIucmVjb3JkX3N0YXJ0IG1vZHVsZV90aW1lciBtb2R1bGVfbmFtZVxubGV0IHJlY29yZF91bnRpbCBtb2R1bGVfbmFtZSA9IFRpbWVyLnJlY29yZF91bnRpbCBtb2R1bGVfdGltZXIgbW9kdWxlX25hbWVcbmxldCByZWNvcmRfZGVmaW5pdGlvbl9zdGFydCBsb2MgPSBUaW1lci5yZWNvcmRfc3RhcnQgZGVmaW5pdGlvbl90aW1lciBsb2NcbmxldCByZWNvcmRfZGVmaW5pdGlvbl91bnRpbCBsb2MgPSBUaW1lci5yZWNvcmRfdW50aWwgZGVmaW5pdGlvbl90aW1lciBsb2NcblxubGV0IGdjX2V2ZW50c19zdWZmaXhfc3RyaW5nXG4gICh7IG1pbm9yX2NvbGxlY3Rpb25zOyBtYWpvcl9jb2xsZWN0aW9uczsgY29tcGFjdGlvbnMgfSA6IEdjX2V2ZW50cy50KVxuICA9XG4gIGxldCB0b19saXN0IGRlc2NyaXB0aW9uIGNvdW50ID1cbiAgICBpZiBjb3VudCA9IDAgdGhlbiBbXSBlbHNlIFsgSW50LnRvX3N0cmluZyBjb3VudCBeIFwiIFwiIF4gZGVzY3JpcHRpb24gXVxuICBpblxuICBsZXQgc3RyaW5ncyA9XG4gICAgdG9fbGlzdCBcIm1pbm9yIGNvbGxlY3Rpb25zXCIgbWlub3JfY29sbGVjdGlvbnNcbiAgICBAIHRvX2xpc3QgXCJtYWpvciBjb2xsZWN0aW9uc1wiIG1ham9yX2NvbGxlY3Rpb25zXG4gICAgQCB0b19saXN0IFwiY29tcGFjdGlvbnNcIiBjb21wYWN0aW9uc1xuICBpblxuICBpZiBMaXN0LmlzX2VtcHR5IHN0cmluZ3MgdGhlbiBcIlwiIGVsc2UgXCI7IEdDOiBcIiBeIFN0cmluZy5jb25jYXQgc3RyaW5ncyB+c2VwOlwiLCBcIlxuOztcblxubGV0IHdpdGhfbGVmdF9jb2x1bW5fcmlnaHRfanVzdGlmaWVkIGxpc3QgPVxuICBsZXQgbGVmdF9jb2x1bW5fd2lkdGggPVxuICAgIExpc3QuZm9sZCBsaXN0IH5pbml0OjAgfmY6KGZ1biB3aWR0aCAobGVmdCwgXykgLT4gSW50Lm1heCB3aWR0aCAoU3RyaW5nLmxlbmd0aCBsZWZ0KSlcbiAgaW5cbiAgTGlzdC5tYXAgbGlzdCB+ZjooZnVuIChsZWZ0LCByaWdodCkgLT5cbiAgICBQcmludGYuc3ByaW50ZiBcIiUqcyAlc1wiIGxlZnRfY29sdW1uX3dpZHRoIGxlZnQgcmlnaHQpXG47O1xuXG5sZXQgcmVjIHRpbWluZ19ldmVudHNfdG9fc3RyaW5ncyBsaXN0IH5pbmRlbnQgPVxuICBsZXQgZHVyYXRpb25fc3RyaW5ncyA9XG4gICAgTGlzdC5tYXAgbGlzdCB+ZjooZnVuICh0aW1pbmdfZXZlbnQgOiBUaW1pbmdfZXZlbnQudCkgLT4gdGltaW5nX2V2ZW50LnJ1bnRpbWUpXG4gICAgfD4gRHVyYXRpb24udG9fc3RyaW5nX3dpdGhfc2FtZV91bml0XG4gIGluXG4gIGxldCBwcmVmaXggPSBTdHJpbmcubWFrZSBpbmRlbnQgJyAnIGluXG4gIExpc3QubWFwMl9leG5cbiAgICBkdXJhdGlvbl9zdHJpbmdzXG4gICAgbGlzdFxuICAgIH5mOlxuICAgICAgKGZ1blxuICAgICAgICBkdXJhdGlvbl9zdHJpbmcgeyBydW50aW1lID0gXzsgZGVzY3JpcHRpb247IGdjX2V2ZW50czsgbmVzdGVkX3RpbWluZ19ldmVudHMgfSAtPlxuICAgICggZHVyYXRpb25fc3RyaW5nXG4gICAgLCBkZXNjcmlwdGlvblxuICAgICAgXiBnY19ldmVudHNfc3VmZml4X3N0cmluZyBnY19ldmVudHNcbiAgICAgIF4gU3RyaW5nLmNvbmNhdFxuICAgICAgICAgIChMaXN0Lm1hcFxuICAgICAgICAgICAgICh0aW1pbmdfZXZlbnRzX3RvX3N0cmluZ3MgbmVzdGVkX3RpbWluZ19ldmVudHMgfmluZGVudDooaW5kZW50ICsgNCkpXG4gICAgICAgICAgICAgfmY6KGZ1biBsaW5lIC0+IFwiXFxuXCIgXiBsaW5lKSkgKSlcbiAgfD4gd2l0aF9sZWZ0X2NvbHVtbl9yaWdodF9qdXN0aWZpZWRcbiAgfD4gTGlzdC5tYXAgfmY6KGZ1biBsaW5lIC0+IHByZWZpeCBeIGxpbmUpXG47O1xuXG5sZXQgZmFrZV90aW1pbmdfZXZlbnRzID1cbiAgbGV0IGdjX2V2ZW50cyBpIDogR2NfZXZlbnRzLnQgPVxuICAgIHsgbWlub3JfY29sbGVjdGlvbnMgPSAoaWYgaSAlIDIgPSAxIHRoZW4gMSBlbHNlIDApXG4gICAgOyBtYWpvcl9jb2xsZWN0aW9ucyA9IChpZiBpICUgNCA9IDMgdGhlbiAxIGVsc2UgMClcbiAgICA7IGNvbXBhY3Rpb25zID0gKGlmIGkgJSA4ID0gNyB0aGVuIDEgZWxzZSAwKVxuICAgIH1cbiAgaW5cbiAgbGF6eVxuICAgIChMaXN0LmluaXQgMTIgfmY6KGZ1biBpIDogVGltaW5nX2V2ZW50LnQgLT5cbiAgICAgICB7IGRlc2NyaXB0aW9uID0gUHJpbnRmLnNwcmludGYgXCJGYWtlX19EZXBlbmRlbmN5XyVkXCIgKGkgKyAxKVxuICAgICAgIDsgcnVudGltZSA9IEludDYzLm9mX2ludCAoOTAwICogKGkgKyAxKSlcbiAgICAgICA7IGdjX2V2ZW50cyA9IGdjX2V2ZW50cyBpXG4gICAgICAgOyBuZXN0ZWRfdGltaW5nX2V2ZW50cyA9XG4gICAgICAgICAgIChpZiAoaSArIDEpICUgNCA9IDBcbiAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgTGlzdC5pbml0IChpICsgMSkgfmY6KGZ1biBqIDogVGltaW5nX2V2ZW50LnQgLT5cbiAgICAgICAgICAgICAgICB7IGRlc2NyaXB0aW9uID0gUHJpbnRmLnNwcmludGYgXCJMaW5lICVkXCIgKGogKyAxKVxuICAgICAgICAgICAgICAgIDsgcnVudGltZSA9IEludDYzLm9mX2ludCAoOTAwICogKGogKyAxKSlcbiAgICAgICAgICAgICAgICA7IGdjX2V2ZW50cyA9IGdjX2V2ZW50cyBqXG4gICAgICAgICAgICAgICAgOyBuZXN0ZWRfdGltaW5nX2V2ZW50cyA9IFtdXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGVsc2UgW10pXG4gICAgICAgfSkpXG47O1xuXG5sZXQgcHJpbnRfcmVjb3JkZWRfdGltaW5nX2V2ZW50cyB0aW1pbmdfZXZlbnRzID1cbiAgbGV0IG5vdGlmeV9vZl9vdmVycmlkaW5nICgpID1cbiAgICBTdGRpby5wcmludF9lbmRsaW5lIFwicHB4X21vZHVsZV90aW1lcjogb3ZlcnJpZGluZyB0aW1lIG1lYXN1cmVtZW50cyBmb3IgdGVzdGluZ1wiXG4gIGluXG4gIGxldCB0aW1pbmdfZXZlbnRzID1cbiAgICBtYXRjaCBPcHRpb24udmFsdWVfZXhuIGFtX3JlY29yZGluZ192YWx1ZSB3aXRoXG4gICAgfCBcIkZBS0VfTU9EVUxFU1wiIC0+XG4gICAgICBub3RpZnlfb2Zfb3ZlcnJpZGluZyAoKTtcbiAgICAgIGZvcmNlIGZha2VfdGltaW5nX2V2ZW50c1xuICAgIHwgc3RyaW5nIC0+XG4gICAgICAobWF0Y2ggRHVyYXRpb24ub2Zfc3RyaW5nIHN0cmluZyB3aXRoXG4gICAgICAgfCBvdmVycmlkZSAtPlxuICAgICAgICAgbm90aWZ5X29mX292ZXJyaWRpbmcgKCk7XG4gICAgICAgICBMaXN0Lm1hcGkgdGltaW5nX2V2ZW50cyB+ZjooZnVuIGluZGV4ICh0aW1pbmdfZXZlbnQgOiBUaW1pbmdfZXZlbnQudCkgLT5cbiAgICAgICAgICAgbGV0IHJ1bnRpbWUgPSBJbnQ2My4oICogKSBvdmVycmlkZSAoSW50NjMub2ZfaW50IChpbmRleCArIDEpKSBpblxuICAgICAgICAgICBsZXQgbmVzdGVkX3RpbWluZ19ldmVudHMgPVxuICAgICAgICAgICAgIExpc3QubWFwaVxuICAgICAgICAgICAgICAgdGltaW5nX2V2ZW50Lm5lc3RlZF90aW1pbmdfZXZlbnRzXG4gICAgICAgICAgICAgICB+ZjooZnVuIGluZGV4IG5lc3RlZF90aW1pbmdfZXZlbnQgLT5cbiAgICAgICAgICAgICAgIGxldCBydW50aW1lID0gSW50NjMuKCAqICkgb3ZlcnJpZGUgKEludDYzLm9mX2ludCAoaW5kZXggKyAxKSkgaW5cbiAgICAgICAgICAgICAgIHsgbmVzdGVkX3RpbWluZ19ldmVudCB3aXRoIHJ1bnRpbWUgfSlcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgeyB0aW1pbmdfZXZlbnQgd2l0aCBydW50aW1lOyBuZXN0ZWRfdGltaW5nX2V2ZW50cyB9KVxuICAgICAgIHwgZXhjZXB0aW9uIF8gLT4gdGltaW5nX2V2ZW50cylcbiAgaW5cbiAgdGltaW5nX2V2ZW50cyB8PiB0aW1pbmdfZXZlbnRzX3RvX3N0cmluZ3MgfmluZGVudDowIHw+IExpc3QuaXRlciB+ZjpTdGRpby5wcmludF9lbmRsaW5lXG47O1xuXG5sZXQgKCkgPVxuICBpZiBhbV9yZWNvcmRpbmdcbiAgdGhlblxuICAgIFN0ZGxpYi5hdF9leGl0IChmdW4gKCkgLT5cbiAgICAgIHByaW50X3JlY29yZGVkX3RpbWluZ19ldmVudHNcbiAgICAgICAgKExpc3QucmV2IG1vZHVsZV90aW1lci50aW1pbmdfZXZlbnRzX2luX3JldmVyc2VfY2hyb25vbG9naWNhbF9vcmRlcikpXG47O1xuIl19
