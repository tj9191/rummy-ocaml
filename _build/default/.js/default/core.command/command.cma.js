// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Command__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Command = [0],
    Command$0 = [0, Command];
   runtime.caml_register_global(0, Command$0, "Command__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Command__Import
//# unitInfo: Requires: Base__Printf, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Stdio
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Command_Import = "Command__Import",
    cst_command = "command";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Stdio = global_data.Stdio,
    Base_Printf = global_data.Base__Printf;
   caml_call1(Ppx_module_timer_runtime[4], cst_Command_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_command);
   caml_call1(Ppx_expect_runtime[1][1], "command/src/import.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_command, "import.ml");
   var
    eprintf = Stdio[7],
    printf = Stdio[4],
    print_s = Stdio[5],
    print_string = Stdio[8],
    print_endline = Stdio[9],
    prerr_endline = Stdio[10],
    sprintf = Base_Printf[2],
    failwithf = Base_Printf[6],
    ksprintf = Base_Printf[4];
   caml_call1(Ppx_inline_test_lib[7], cst_command);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Command_Import);
   var
    Command_Import =
      [0,
       eprintf,
       printf,
       print_s,
       print_string,
       print_endline,
       prerr_endline,
       sprintf,
       failwithf,
       ksprintf];
   runtime.caml_register_global(13, Command_Import, cst_Command_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Command__Env_var
//# unitInfo: Requires: Base, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Command_Env_var$0 = "Command__Env_var",
    cst_command$0 = "command";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, [0, 2, 0]]],
    Base = global_data.Base,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Command_Env_var$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_command$0);
   caml_call1(Ppx_expect_runtime[1][1], "command/src/env_var.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_command$0, "env_var.ml");
   var
    compare = runtime.caml_int_compare,
    _a_ = [0, "COMMAND_OUTPUT_INSTALLATION_BASH"],
    _b_ = [0, "COMMAND_OUTPUT_HELP_SEXP"],
    _c_ = [0, "COMP_CWORD"],
    cst_command = cst_command$0,
    cst_Command_Env_var = cst_Command_Env_var$0;
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   function to_string(t){
    var _d_ = sexp_of_t(t);
    return caml_call1(Base[85][16], _d_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_command);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Command_Env_var);
   var Command_Env_var = [0, compare, all, sexp_of_t, to_string];
   runtime.caml_register_global(16, Command_Env_var, cst_Command_Env_var$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Command__Shape
//# unitInfo: Requires: Base, Base__Char, Base__Error, Base__Fn, Base__Int, Base__Invariant, Base__Lazy, Base__List, Base__Option, Base__Or_error, Base__Result, Base__Set, Base__String, Bin_prot__Common, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Write, Bin_shape, CamlinternalLazy, Command__Env_var, Command__Import, Expect_test_config, Filename_base, Inline_test_config, Ppx_bench_lib__Benchmark_accumulator, Ppx_compare_lib, Ppx_expect_runtime, Ppx_expect_runtime__Test_block, Ppx_expect_runtime__Test_node, Ppx_expect_runtime__Types, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Sexplib0__Sexp_conv_record, Stable_witness, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$7 = "",
    cst$8 = " ",
    cst$6 = ", ",
    cst$5 = "-",
    cst_Ad_hoc = "Ad_hoc",
    cst_Base = "Base",
    cst_Basic = "Basic",
    cst_Command_Shape$0 = "Command__Shape",
    cst_Concat = "Concat",
    cst_Exec = "Exec",
    cst_Grammar = "Grammar",
    cst_Group = "Group",
    cst_Lazy = "Lazy",
    cst_Many = "Many",
    cst_Maybe = "Maybe",
    cst_One = "One",
    cst_Usage = "Usage",
    cst_V1$0 = "V1",
    cst_V2$0 = "V2",
    cst_V3$0 = "V3",
    cst_Zero = "Zero",
    cst_build_info = "[-build-info]",
    cst_help = "[-help]",
    cst_version = "[-version]",
    cst_a$1 = "a",
    cst_ad_hoc = "ad_hoc",
    cst_aliases$1 = "aliases",
    cst_anons$1 = "anons",
    cst_base = "base",
    cst_basic = "basic",
    cst_bug_in_command_ml$1 = "bug in command.ml",
    cst_child_subcommand$1 = "child_subcommand",
    cst_command$0 = "command",
    cst_command_src_shape_ml$0 = "command/src/shape.ml",
    cst_concat = "concat",
    cst_doc$1 = "doc",
    cst_exec = "exec",
    cst_flags$2 = "flags",
    cst_grammar = "grammar",
    cst_group = "group",
    cst_help$0 = "help",
    cst_lazy = "lazy",
    cst_many = "many",
    cst_maybe = "maybe",
    cst_name$1 = "name",
    cst_one = "one",
    cst_path_to_exe$3 = "path_to_exe",
    cst_readme$9 = "readme",
    cst_subcommands$2 = "subcommands",
    cst_summary$9 = "summary",
    cst_usage$0 = "usage",
    cst_v1 = "v1",
    cst_v2 = "v2",
    cst_v3 = "v3",
    cst_version$0 = "version",
    cst_working_dir$2 = "working_dir",
    cst_zero = "zero",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call14
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    return (f.l >= 0 ? f.l : f.l = f.length) == 14
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
            : runtime.caml_call_gen
              (f,
               [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$4 = cst$5,
    cst$3 = cst$5,
    cst$2 = cst$7,
    cst$1 = cst$8,
    flag_name$0 = cst_name$1,
    cst$0 = "/",
    cst = cst$7,
    error_source_022 = "command/src/shape.ml.Stable.Anons.Grammar.V1.t",
    error_source_067 = "command/src/shape.ml.Stable.Anons.V2.t",
    error_source_088 = "command/src/shape.ml.Stable.Flag_info.V1.t",
    error_source_104 = "command/src/shape.ml.Stable.Base_info.V2.t",
    error_source_118 = "command/src/shape.ml.Stable.Base_info.V1.t",
    error_source_145 = "command/src/shape.ml.Stable.Group_info.V2.t",
    error_source_178 = "command/src/shape.ml.Stable.Group_info.V1.t",
    error_source_206 = "command/src/shape.ml.Stable.Exec_info.V3.t",
    error_source_222 = "command/src/shape.ml.Stable.Exec_info.V2.t",
    error_source_236 = "command/src/shape.ml.Stable.Exec_info.V1.t",
    error_source_261 = "command/src/shape.ml.Stable.Fully_forced.V1.t",
    error_source_290 = "command/src/shape.ml.Stable.Sexpable.V3.t",
    error_source_322 = "command/src/shape.ml.Stable.Sexpable.V2.t",
    error_source_347 = "command/src/shape.ml.Stable.Sexpable.V1.t",
    error_source_372 = "command/src/shape.ml.Stable.Sexpable.Versioned.t",
    error_source_411 = "command/src/shape.ml.Anons.Grammar.t",
    error_source_456 = "command/src/shape.ml.Anons.t",
    enumerate_474 = [0, 0, [0, 1, 0]],
    enumerate_475 = [0, 0, [0, 1, 0]],
    maybe_missing_prefix = "[",
    maybe_missing_suffix = "]",
    maybe_more_suffix = " ...",
    error_source_499 = "command/src/shape.ml.Flag_info.t",
    indentation = "  ",
    spacing_dot = ". ",
    error_source_517 = "command/src/shape.ml.Base_info.t",
    error_source_546 = "command/src/shape.ml.Group_info.t",
    error_source_574 = "command/src/shape.ml.Exec_info.t",
    error_source_603 = "command/src/shape.ml.Fully_forced.t",
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Set = global_data.Base__Set,
    Base_Lazy = global_data.Base__Lazy,
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base = global_data.Base,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_String = global_data.Base__String,
    Base_Error = global_data.Base__Error,
    Base_Result = global_data.Base__Result,
    Base_Or_error = global_data.Base__Or_error,
    Base_Char = global_data.Base__Char,
    Command_Import = global_data.Command__Import,
    Assert_failure = global_data.Assert_failure,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_Option = global_data.Base__Option,
    Stdlib_List = global_data.Stdlib__List,
    Stable_witness = global_data.Stable_witness,
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Filename_base = global_data.Filename_base;
   global_data.Bin_prot__Read;
   global_data.Bin_prot__Common;
   global_data.Bin_prot__Write;
   var
    Stdlib = global_data.Stdlib,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Bin_shape = global_data.Bin_shape,
    Base_Fn = global_data.Base__Fn,
    Expect_test_config = global_data.Expect_test_config,
    Ppx_expect_runtime_Test_block = global_data.Ppx_expect_runtime__Test_block,
    Ppx_expect_runtime_Test_node = global_data.Ppx_expect_runtime__Test_node,
    Inline_test_config = global_data.Inline_test_config,
    Command_Env_var = global_data.Command__Env_var,
    Base_Int = global_data.Base__Int;
   caml_call1(Ppx_module_timer_runtime[4], cst_Command_Shape$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_command$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_command_src_shape_ml$0);
   caml_call2(Ppx_inline_test_lib[6], cst_command$0, "shape.ml");
   var
    t_of_sexp = Sexplib0_Sexp_conv[40],
    sexp_of_t = Sexplib0_Sexp_conv[16],
    compare = Base_Lazy[1],
    _aW_ = [0, cst_Base],
    _aX_ = [0, cst_Group],
    _aY_ = [0, cst_Exec],
    _aZ_ = [0, cst_Lazy],
    _aV_ = [0, 0, 0],
    _aS_ = [0, cst_Basic],
    _aT_ = [0, cst_Group],
    _aU_ = [0, cst_Exec],
    _aN_ = [0, cst_child_subcommand$1],
    _aO_ = [0, cst_path_to_exe$3],
    _aP_ = [0, cst_working_dir$2],
    _aQ_ = [0, cst_readme$9],
    _aR_ = [0, cst_summary$9],
    cst_child_subcommand$0 = cst_child_subcommand$1,
    cst_path_to_exe$2 = cst_path_to_exe$3,
    cst_working_dir$1 = cst_working_dir$2,
    cst_readme$8 = cst_readme$9,
    cst_summary$8 = cst_summary$9,
    cst_Subcommands_must_not_begin = "Subcommands must not begin with '-'",
    _aK_ = [0, cst_subcommands$2],
    _aL_ = [0, cst_readme$9],
    _aM_ = [0, cst_summary$9],
    cst_subcommands$1 = cst_subcommands$2,
    cst_readme$7 = cst_readme$9,
    cst_summary$7 = cst_summary$9,
    cst_Flags_must_begin_with = "Flags must begin with '-'",
    _aG_ = [0, cst_flags$2],
    _aH_ = [0, cst_anons$1],
    _aI_ = [0, cst_readme$9],
    _aJ_ = [0, cst_summary$9],
    cst_flags$1 = cst_flags$2,
    cst_anons$0 = cst_anons$1,
    cst_readme$6 = cst_readme$9,
    cst_summary$6 = cst_summary$9,
    _aB_ = [0, cst$6],
    cst_Key_type_s_is_an_ambiguous =
      "%{Key_type} %s is an ambiguous prefix: %s",
    _aC_ = [12, 32, [2, 0, [11, " is an ambiguous prefix: ", [2, 0, 0]]]],
    _aD_ = [0, 0],
    cst_unknown_Key_type_s = "unknown %{Key_type} %s",
    _aE_ = [12, 32, [2, 0, 0]],
    _aF_ = [0, 0],
    cst_unknown = "unknown ",
    cst_flag = "flag",
    cst_subcommand = "subcommand",
    _aA_ = [0, cst$6],
    _ax_ = [0, [0, "\n", 0], 0],
    cst_Unable_to_parse = "Unable to parse",
    _au_ = [0, cst_aliases$1],
    _av_ = [0, cst_doc$1],
    _aw_ = [0, cst_name$1],
    cst_aliases$0 = cst_aliases$1,
    cst_doc$0 = cst_doc$1,
    cst_name$0 = cst_name$1,
    _a2_ = [0, cst_command_src_shape_ml$0, 414, 6],
    _a1_ = [0, cst_command_src_shape_ml$0, 415, 6],
    _as_ = [0, "at_most_once"],
    _at_ = [0, "at_least_once"],
    _aq_ = [0, cst_Usage],
    _ar_ = [0, cst_Grammar],
    _ak_ = [0, cst_Zero],
    _al_ = [0, cst_One],
    _am_ = [0, cst_Many],
    _an_ = [0, cst_Maybe],
    _ao_ = [0, cst_Concat],
    _ap_ = [0, cst_Ad_hoc],
    cst_unsupported_version_to_use = "unsupported version_to_use",
    _aj_ = [0, [0, cst_command_src_shape_ml$0, 336, 8993, 9011]],
    _ag_ = [0, cst_V1$0],
    _ah_ = [0, cst_V2$0],
    _ai_ = [0, cst_V3$0],
    _ad_ = [0, cst_Base],
    _ae_ = [0, cst_Group],
    _af_ = [0, cst_Exec],
    _aa_ = [0, cst_Base],
    _ab_ = [0, cst_Group],
    _ac_ = [0, cst_Exec],
    _Y_ = [0, cst_Base],
    _Z_ = [0, cst_Group],
    ___ = [0, cst_Exec],
    _$_ = [0, cst_Lazy],
    _V_ = [0, cst_Basic],
    _W_ = [0, cst_Group],
    _X_ = [0, cst_Exec],
    _S_ = [0, cst_path_to_exe$3],
    _T_ = [0, cst_readme$9],
    _U_ = [0, cst_summary$9],
    cst_path_to_exe$1 = cst_path_to_exe$3,
    cst_readme$5 = cst_readme$9,
    cst_summary$5 = cst_summary$9,
    _O_ = [0, cst_path_to_exe$3],
    _P_ = [0, cst_working_dir$2],
    _Q_ = [0, cst_readme$9],
    _R_ = [0, cst_summary$9],
    cst_path_to_exe$0 = cst_path_to_exe$3,
    cst_working_dir$0 = cst_working_dir$2,
    cst_readme$4 = cst_readme$9,
    cst_summary$4 = cst_summary$9,
    _J_ = [0, cst_child_subcommand$1],
    _K_ = [0, cst_path_to_exe$3],
    _L_ = [0, cst_working_dir$2],
    _M_ = [0, cst_readme$9],
    _N_ = [0, cst_summary$9],
    cst_child_subcommand = cst_child_subcommand$1,
    cst_path_to_exe = cst_path_to_exe$3,
    cst_working_dir = cst_working_dir$2,
    cst_readme$3 = cst_readme$9,
    cst_summary$3 = cst_summary$9,
    _G_ = [0, cst_subcommands$2],
    _H_ = [0, cst_readme$9],
    _I_ = [0, cst_summary$9],
    cst_subcommands$0 = cst_subcommands$2,
    cst_readme$2 = cst_readme$9,
    cst_summary$2 = cst_summary$9,
    _D_ = [0, cst_subcommands$2],
    _E_ = [0, cst_readme$9],
    _F_ = [0, cst_summary$9],
    cst_subcommands = cst_subcommands$2,
    cst_readme$1 = cst_readme$9,
    cst_summary$1 = cst_summary$9,
    _u_ = [0, cst_flags$2],
    _v_ = [0, cst_usage$0],
    _w_ = [0, cst_readme$9],
    _x_ = [0, cst_summary$9],
    cst_flags$0 = cst_flags$2,
    cst_usage = cst_usage$0,
    cst_readme$0 = cst_readme$9,
    cst_summary$0 = cst_summary$9,
    _q_ = [0, cst_flags$2],
    _r_ = [0, cst_anons$1],
    _s_ = [0, cst_readme$9],
    _t_ = [0, cst_summary$9],
    cst_flags = cst_flags$2,
    cst_anons = cst_anons$1,
    cst_readme = cst_readme$9,
    cst_summary = cst_summary$9,
    _n_ = [0, cst_aliases$1],
    _o_ = [0, cst_doc$1],
    _p_ = [0, cst_name$1],
    cst_aliases = cst_aliases$1,
    cst_doc = cst_doc$1,
    cst_name = cst_name$1,
    _l_ = [0, cst_Usage],
    _m_ = [0, cst_Grammar],
    cst_Many_Zero_should_be_just_Z = "Many Zero should be just Zero",
    cst_Maybe_Zero_should_be_just_ = "Maybe Zero should be just Zero",
    cst_Flatten_zero_and_one_eleme = "Flatten zero and one-element Concat",
    _g_ = [0, cst_command_src_shape_ml$0, 25, 586, 621],
    _i_ = [0, [11, "[(", [2, 0, [11, ") ...]", 0]]], "[(%s) ...]"],
    cst_bug_in_command_ml = cst_bug_in_command_ml$1,
    _h_ = [0, [12, 91, [2, 0, [11, " ...]", 0]]], "[%s ...]"],
    cst_bug_in_command_ml$0 = cst_bug_in_command_ml$1,
    _j_ = [0, [12, 91, [2, 0, [12, 93, 0]]], "[%s]"],
    _k_ = [0, cst$8],
    _a_ = [0, cst_Zero],
    _b_ = [0, cst_One],
    _c_ = [0, cst_Many],
    _d_ = [0, cst_Maybe],
    _e_ = [0, cst_Concat],
    _f_ = [0, cst_Ad_hoc],
    _y_ =
      [0,
       [0,
        "Dummy_type_because_we_cannot_digest_type_constructors_only_concrete_types",
        0],
       0],
    cst_a = cst_a$1,
    cst_command_src_shape_ml_125_4 = "command/src/shape.ml:125:4",
    cst_a$0 = cst_a$1,
    cst_V1 = cst_V1$0,
    cst_V2 = cst_V2$0,
    cst_V3 = cst_V3$0,
    _a3_ =
      [0,
       [0,
        [0,
         '\n      (((at_least_once false) (at_most_once false)) "[name] ...")\n      (((at_least_once true) (at_most_once false)) "name ...")\n      (((at_least_once false) (at_most_once true)) [name])\n      (((at_least_once true) (at_most_once true)) name)\n      ',
         [0, cst$7]],
        [0, 11098, 11104, 11359]]],
    _a4_ = [0, 11085, 11089, 11360],
    _a7_ = [0, "to_help_string"],
    _a__ = [0, 10743, 10745, 11360],
    _a$_ = [0, 11351, 11360, 11360],
    _ba_ = [0, 10743, 10745, 11360],
    cst_command_src_shape_ml = cst_command_src_shape_ml$0,
    cst_command = cst_command$0,
    cst_Command_Shape = cst_Command_Shape$0;
   function compare$0(a_006, b_007){
    var a_006$0 = a_006, b_007$0 = b_007;
    for(;;){
     if(a_006$0 === b_007$0) return 0;
     if(typeof a_006$0 === "number")
      return typeof b_007$0 === "number" ? 0 : -1;
     a:
     {
      b:
      {
       c:
       {
        switch(a_006$0[0]){
          case 0:
           var a_008 = a_006$0[1];
           if(typeof b_007$0 === "number") break a;
           if(0 !== b_007$0[0]) return -1;
           var b_009 = b_007$0[1];
           return caml_call2(Ppx_compare_lib[5][8], a_008, b_009);
          case 1:
           var a_010 = a_006$0[1];
           if(typeof b_007$0 === "number") break a;
           switch(b_007$0[0]){
             case 0:
              break b;
             case 1:
              var b_011 = b_007$0[1], a_006$0 = a_010, b_007$0 = b_011;
              continue;
             default: return -1;
           }
          case 2:
           var a_012 = a_006$0[1];
           if(typeof b_007$0 === "number") break a;
           switch(b_007$0[0]){
             case 0:
              break b;
             case 1:
              break c;
             case 2:
              var b_013 = b_007$0[1], a_006$0 = a_012, b_007$0 = b_013;
              continue;
             default: return -1;
           }
          case 3:
           var a_014 = a_006$0[1];
           if(typeof b_007$0 === "number") break a;
           switch(b_007$0[0]){
             case 0:
              break b;
             case 1:
              break c;
             case 2: break;
             case 3:
              var
               b_015 = b_007$0[1],
               _fv_ = function(a_016, b_017){return compare$0(a_016, b_017);};
              return caml_call3(Ppx_compare_lib[5][12], _fv_, a_014, b_015);
             default: return -1;
           }
           break;
          default:
           var a_018 = a_006$0[1];
           if(typeof b_007$0 === "number") break a;
           switch(b_007$0[0]){
             case 0:
              break b;
             case 1:
              break c;
             case 2: break;
             case 3:
              return 1;
             default:
              var b_019 = b_007$0[1];
              return caml_call2(Ppx_compare_lib[5][8], a_018, b_019);
           }
        }
        return 1;
       }
       return 1;
      }
      return 1;
     }
     return 1;
    }
   }
   var t_of_sexp$0 = function _fu_(_ft_){return _fu_.fun(_ft_);};
   caml_update_dummy
    (t_of_sexp$0,
     function(sexp_024){
      a:
      {
       if(0 === sexp_024[0]){
        var _fo_ = sexp_024[1], _fp_ = caml_string_compare(_fo_, cst_ad_hoc);
        b:
        {
         c:
         {
          d:
          {
           e:
           {
            f:
            {
             if(0 <= _fp_){
              if(0 < _fp_){
               if(! caml_string_notequal(_fo_, cst_concat)) break f;
               if(! caml_string_notequal(_fo_, cst_many)) break e;
               if(! caml_string_notequal(_fo_, cst_maybe)) break d;
               if(! caml_string_notequal(_fo_, cst_one)) break c;
               if(caml_string_notequal(_fo_, cst_zero)) break a;
               break b;
              }
             }
             else if(caml_string_notequal(_fo_, cst_Ad_hoc)){
              if(! caml_string_notequal(_fo_, cst_Concat)) break f;
              if(! caml_string_notequal(_fo_, cst_Many)) break e;
              if(! caml_string_notequal(_fo_, cst_Maybe)) break d;
              if(! caml_string_notequal(_fo_, cst_One)) break c;
              if(caml_string_notequal(_fo_, cst_Zero)) break a;
              break b;
             }
             return caml_call2
                     (Sexplib0_Sexp_conv_error[9], error_source_022, sexp_024);
            }
            return caml_call2
                    (Sexplib0_Sexp_conv_error[9], error_source_022, sexp_024);
           }
           return caml_call2
                   (Sexplib0_Sexp_conv_error[9], error_source_022, sexp_024);
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_022, sexp_024);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_022, sexp_024);
        }
        return 0;
       }
       var _fq_ = sexp_024[1];
       if(! _fq_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_022, sexp_024);
       var _fr_ = _fq_[1];
       if(0 !== _fr_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_022, sexp_024);
       var tag_025 = _fr_[1], _fs_ = caml_string_compare(tag_025, cst_ad_hoc);
       b:
       {
        c:
        {
         d:
         {
          e:
          {
           f:
           {
            if(0 <= _fs_){
             if(0 < _fs_){
              if(! caml_string_notequal(tag_025, cst_concat)) break f;
              if(! caml_string_notequal(tag_025, cst_many)) break e;
              if(! caml_string_notequal(tag_025, cst_maybe)) break d;
              if(! caml_string_notequal(tag_025, cst_one)) break c;
              if(caml_string_notequal(tag_025, cst_zero)) break a;
              break b;
             }
            }
            else if(caml_string_notequal(tag_025, cst_Ad_hoc)){
             if(! caml_string_notequal(tag_025, cst_Concat)) break f;
             if(! caml_string_notequal(tag_025, cst_Many)) break e;
             if(! caml_string_notequal(tag_025, cst_Maybe)) break d;
             if(! caml_string_notequal(tag_025, cst_One)) break c;
             if(caml_string_notequal(tag_025, cst_Zero)) break a;
             break b;
            }
            var sexp_args_046 = _fq_[2];
            if(sexp_args_046 && ! sexp_args_046[2]){
             var
              arg0_047 = sexp_args_046[1],
              res0_048 = caml_call1(Sexplib0_Sexp_conv[31], arg0_047);
             return [4, res0_048];
            }
            return caml_call3
                    (Sexplib0_Sexp_conv_error[8],
                     error_source_022,
                     tag_025,
                     sexp_024);
           }
           var sexp_args_041 = _fq_[2];
           if(sexp_args_041 && ! sexp_args_041[2]){
            var
             arg0_042 = sexp_args_041[1],
             res0_043 =
               caml_call2(Sexplib0_Sexp_conv[44], t_of_sexp$0, arg0_042);
            return [3, res0_043];
           }
           return caml_call3
                   (Sexplib0_Sexp_conv_error[8],
                    error_source_022,
                    tag_025,
                    sexp_024);
          }
          var sexp_args_031 = _fq_[2];
          if(sexp_args_031 && ! sexp_args_031[2]){
           var
            arg0_032 = sexp_args_031[1],
            res0_033 = caml_call1(t_of_sexp$0, arg0_032);
           return [1, res0_033];
          }
          return caml_call3
                  (Sexplib0_Sexp_conv_error[8],
                   error_source_022,
                   tag_025,
                   sexp_024);
         }
         var sexp_args_036 = _fq_[2];
         if(sexp_args_036 && ! sexp_args_036[2]){
          var
           arg0_037 = sexp_args_036[1],
           res0_038 = caml_call1(t_of_sexp$0, arg0_037);
          return [2, res0_038];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_022,
                  tag_025,
                  sexp_024);
        }
        var sexp_args_026 = _fq_[2];
        if(sexp_args_026 && ! sexp_args_026[2]){
         var
          arg0_027 = sexp_args_026[1],
          res0_028 = caml_call1(Sexplib0_Sexp_conv[31], arg0_027);
         return [0, res0_028];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_022,
                 tag_025,
                 sexp_024);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_022, sexp_024);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_022, sexp_024);
     });
   function sexp_of_t$0(param){
    if(typeof param === "number") return _a_;
    switch(param[0]){
      case 0:
       var
        arg0_049 = param[1],
        res0_050 = caml_call1(Sexplib0_Sexp_conv[7], arg0_049);
       return [1, [0, _b_, [0, res0_050, 0]]];
      case 1:
       var arg0_051 = param[1], res0_052 = sexp_of_t$0(arg0_051);
       return [1, [0, _c_, [0, res0_052, 0]]];
      case 2:
       var arg0_053 = param[1], res0_054 = sexp_of_t$0(arg0_053);
       return [1, [0, _d_, [0, res0_054, 0]]];
      case 3:
       var
        arg0_055 = param[1],
        res0_056 = caml_call2(Sexplib0_Sexp_conv[20], sexp_of_t$0, arg0_055);
       return [1, [0, _e_, [0, res0_056, 0]]];
      default:
       var
        arg0_057 = param[1],
        res0_058 = caml_call1(Sexplib0_Sexp_conv[7], arg0_057);
       return [1, [0, _f_, [0, res0_058, 0]]];
    }
   }
   var
    stable_witness_checks_for_t = function _fn_(_fm_){return _fn_.fun(_fm_);},
    stable_witness = Stable_witness[6];
   caml_update_dummy(stable_witness_checks_for_t, function(param){return 0;});
   function invariant(t){
    function _fl_(param){
     if(typeof t === "number") return 0;
     switch(t[0]){
       case 0:
        return 0;
       case 1:
        var t$0 = t[1];
        return typeof t$0 === "number"
                ? caml_call1(Stdlib[2], cst_Many_Zero_should_be_just_Z)
                : invariant(t$0);
       case 2:
        var t$1 = t[1];
        return typeof t$1 === "number"
                ? caml_call1(Stdlib[2], cst_Maybe_Zero_should_be_just_)
                : invariant(t$1);
       case 3:
        var ts = t[1];
        if(ts && ts[2]) return caml_call2(Base_List[19], ts, invariant);
        return caml_call1(Stdlib[2], cst_Flatten_zero_and_one_eleme);
       default: return 0;
     }
    }
    return caml_call4(Base_Invariant[1], _g_, t, sexp_of_t$0, _fl_);
   }
   function t_of_sexp$1(sexp){
    var t = caml_call1(t_of_sexp$0, sexp);
    invariant(t);
    return t;
   }
   function usage(param){
    if(typeof param === "number") return cst;
    switch(param[0]){
      case 0:
       var usage$0 = param[1]; return usage$0;
      case 1:
       var t = param[1];
       if(typeof t === "number")
        return caml_call1(Stdlib[2], cst_bug_in_command_ml);
       if(0 === t[0]){
        var _fh_ = usage(t);
        return caml_call2(Command_Import[7], _h_, _fh_);
       }
       var _fi_ = usage(t);
       return caml_call2(Command_Import[7], _i_, _fi_);
      case 2:
       var t$0 = param[1];
       if(typeof t$0 === "number")
        return caml_call1(Stdlib[2], cst_bug_in_command_ml$0);
       var _fj_ = usage(t$0);
       return caml_call2(Command_Import[7], _j_, _fj_);
      case 3:
       var ts = param[1], _fk_ = caml_call2(Base_List[53], ts, usage);
       return caml_call2(Base_String[68], _k_, _fk_);
      default: var usage$1 = param[1]; return usage$1;
    }
   }
   function compare$1(a_059, b_060){
    if(a_059 === b_060) return 0;
    if(0 === a_059[0]){
     var a_061 = a_059[1];
     if(0 !== b_060[0]) return -1;
     var b_062 = b_060[1];
     return caml_call2(Ppx_compare_lib[5][8], a_061, b_062);
    }
    var a_063 = a_059[1];
    if(0 === b_060[0]) return 1;
    var b_064 = b_060[1];
    return compare$0(a_063, b_064);
   }
   function t_of_sexp$2(sexp_069){
    a:
    {
     if(0 === sexp_069[0]){
      var _fe_ = sexp_069[1];
      b:
      if(caml_string_notequal(_fe_, cst_Grammar)){
       if(caml_string_notequal(_fe_, cst_Usage)){
        if(! caml_string_notequal(_fe_, cst_grammar)) break b;
        if(caml_string_notequal(_fe_, cst_usage$0)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_067, sexp_069);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_067, sexp_069);
     }
     var _ff_ = sexp_069[1];
     if(! _ff_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_067, sexp_069);
     var _fg_ = _ff_[1];
     if(0 !== _fg_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_067, sexp_069);
     var tag_070 = _fg_[1];
     b:
     if(caml_string_notequal(tag_070, cst_Grammar)){
      if(caml_string_notequal(tag_070, cst_Usage)){
       if(! caml_string_notequal(tag_070, cst_grammar)) break b;
       if(caml_string_notequal(tag_070, cst_usage$0)) break a;
      }
      var sexp_args_071 = _ff_[2];
      if(sexp_args_071 && ! sexp_args_071[2]){
       var
        arg0_072 = sexp_args_071[1],
        res0_073 = caml_call1(Sexplib0_Sexp_conv[31], arg0_072);
       return [0, res0_073];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_067,
               tag_070,
               sexp_069);
     }
     var sexp_args_076 = _ff_[2];
     if(sexp_args_076 && ! sexp_args_076[2]){
      var arg0_077 = sexp_args_076[1], res0_078 = t_of_sexp$1(arg0_077);
      return [1, res0_078];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_067,
              tag_070,
              sexp_069);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_067, sexp_069);
   }
   function sexp_of_t$1(param){
    if(0 === param[0]){
     var
      arg0_079 = param[1],
      res0_080 = caml_call1(Sexplib0_Sexp_conv[7], arg0_079);
     return [1, [0, _l_, [0, res0_080, 0]]];
    }
    var arg0_081 = param[1], res0_082 = sexp_of_t$0(arg0_081);
    return [1, [0, _m_, [0, res0_082, 0]]];
   }
   var stable_witness$0 = Stable_witness[6];
   function compare$2(a_083, b_084){
    if(a_083 === b_084) return 0;
    var n = caml_call2(Ppx_compare_lib[5][8], a_083[1], b_084[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Ppx_compare_lib[5][8], a_083[2], b_084[2]);
    if(0 !== n$0) return n$0;
    var _fb_ = b_084[3], _fc_ = a_083[3];
    function _fd_(a_085, b_086){
     return caml_call2(Ppx_compare_lib[5][8], a_085, b_086);
    }
    return caml_call3(Ppx_compare_lib[5][12], _fd_, _fc_, _fb_);
   }
   function t_of_sexp$3(x_089){
    function _e8_(param){
     var
      _fa_ = param[2],
      aliases = _fa_[2][1],
      doc = _fa_[1],
      name = param[1];
     return [0, name, doc, aliases];
    }
    var _e9_ = 0;
    function _e__(param){
     return caml_string_notequal(param, cst_aliases$1)
             ? caml_string_notequal
                (param, cst_doc$1)
               ? caml_string_notequal(param, cst_name$1) ? -1 : 0
               : 1
             : 2;
    }
    var
     _e$_ =
       [0,
        cst_aliases,
        1,
        caml_call1(Sexplib0_Sexp_conv[44], Sexplib0_Sexp_conv[31]),
        0];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_088,
             [0,
              cst_name,
              1,
              Sexplib0_Sexp_conv[31],
              [0, cst_doc, 1, Sexplib0_Sexp_conv[31], _e$_]],
             _e__,
             _e9_,
             _e8_,
             x_089);
   }
   function sexp_of_t$2(param){
    var
     aliases_095 = param[3],
     doc_093 = param[2],
     name_091 = param[1],
     arg_096 =
       caml_call2(Sexplib0_Sexp_conv[20], Sexplib0_Sexp_conv[7], aliases_095),
     bnds_090 = [0, [1, [0, _n_, [0, arg_096, 0]]], 0],
     arg_094 = caml_call1(Sexplib0_Sexp_conv[7], doc_093),
     bnds_090$0 = [0, [1, [0, _o_, [0, arg_094, 0]]], bnds_090],
     arg_092 = caml_call1(Sexplib0_Sexp_conv[7], name_091),
     bnds_090$1 = [0, [1, [0, _p_, [0, arg_092, 0]]], bnds_090$0];
    return [1, bnds_090$1];
   }
   var stable_witness$1 = Stable_witness[6];
   function compare$3(a_097, b_098){
    if(a_097 === b_098) return 0;
    var n = caml_call2(Ppx_compare_lib[5][8], a_097[1], b_098[1]);
    if(0 !== n) return n;
    var _e2_ = b_098[2], _e3_ = a_097[2];
    function _e4_(a_099, b_100){
     return caml_call2(Ppx_compare_lib[5][8], a_099, b_100);
    }
    var n$0 = caml_call3(Ppx_compare_lib[5][13], _e4_, _e3_, _e2_);
    if(0 !== n$0) return n$0;
    var n$1 = compare$1(a_097[3], b_098[3]);
    if(0 !== n$1) return n$1;
    var _e5_ = b_098[4], _e6_ = a_097[4];
    function _e7_(a_101, b_102){return compare$2(a_101, b_102);}
    return caml_call3(Ppx_compare_lib[5][12], _e7_, _e6_, _e5_);
   }
   function t_of_sexp$4(x_105){
    function _eW_(param){
     var
      _e0_ = param[2],
      _e1_ = _e0_[2],
      flags = _e1_[2][1],
      anons = _e1_[1],
      readme = _e0_[1],
      summary = param[1];
     return [0, summary, readme, anons, flags];
    }
    var _eX_ = 0;
    function _eY_(param){
     return caml_string_notequal(param, cst_anons$1)
             ? caml_string_notequal
                (param, cst_flags$2)
               ? caml_string_notequal
                  (param, cst_readme$9)
                 ? caml_string_notequal(param, cst_summary$9) ? -1 : 0
                 : 1
               : 3
             : 2;
    }
    var
     _eZ_ =
       [0,
        cst_anons,
        1,
        t_of_sexp$2,
        [0, cst_flags, 1, caml_call1(Sexplib0_Sexp_conv[44], t_of_sexp$3), 0]];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_104,
             [0,
              cst_summary,
              1,
              Sexplib0_Sexp_conv[31],
              [0, cst_readme, 5, Sexplib0_Sexp_conv[31], _eZ_]],
             _eY_,
             _eX_,
             _eW_,
             x_105);
   }
   function sexp_of_t$3(param){
    var
     flags_115 = param[4],
     anons_113 = param[3],
     readme_109 = param[2],
     summary_107 = param[1],
     arg_116 = caml_call2(Sexplib0_Sexp_conv[20], sexp_of_t$2, flags_115),
     bnds_106 = [0, [1, [0, _q_, [0, arg_116, 0]]], 0],
     arg_114 = sexp_of_t$1(anons_113),
     bnds_106$0 = [0, [1, [0, _r_, [0, arg_114, 0]]], bnds_106];
    if(readme_109)
     var
      v_110 = readme_109[1],
      arg_112 = caml_call1(Sexplib0_Sexp_conv[7], v_110),
      bnd_111 = [1, [0, _s_, [0, arg_112, 0]]],
      bnds_106$1 = [0, bnd_111, bnds_106$0];
    else
     var bnds_106$1 = bnds_106$0;
    var
     arg_108 = caml_call1(Sexplib0_Sexp_conv[7], summary_107),
     bnds_106$2 = [0, [1, [0, _t_, [0, arg_108, 0]]], bnds_106$1];
    return [1, bnds_106$2];
   }
   var stable_witness$2 = Stable_witness[6];
   function t_of_sexp$5(x_119){
    function _eQ_(param){
     var
      _eU_ = param[2],
      _eV_ = _eU_[2],
      flags = _eV_[2][1],
      usage = _eV_[1],
      readme = _eU_[1],
      summary = param[1];
     return [0, summary, readme, usage, flags];
    }
    var _eR_ = 0;
    function _eS_(param){
     return caml_string_notequal(param, cst_flags$2)
             ? caml_string_notequal
                (param, cst_readme$9)
               ? caml_string_notequal
                  (param, cst_summary$9)
                 ? caml_string_notequal(param, cst_usage$0) ? -1 : 2
                 : 0
               : 1
             : 3;
    }
    var
     _eT_ =
       [0, cst_flags$0, 1, caml_call1(Sexplib0_Sexp_conv[44], t_of_sexp$3), 0];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_118,
             [0,
              cst_summary$0,
              1,
              Sexplib0_Sexp_conv[31],
              [0,
               cst_readme$0,
               5,
               Sexplib0_Sexp_conv[31],
               [0, cst_usage, 1, Sexplib0_Sexp_conv[31], _eT_]]],
             _eS_,
             _eR_,
             _eQ_,
             x_119);
   }
   function sexp_of_t$4(param){
    var
     flags_129 = param[4],
     usage_127 = param[3],
     readme_123 = param[2],
     summary_121 = param[1],
     arg_130 = caml_call2(Sexplib0_Sexp_conv[20], sexp_of_t$2, flags_129),
     bnds_120 = [0, [1, [0, _u_, [0, arg_130, 0]]], 0],
     arg_128 = caml_call1(Sexplib0_Sexp_conv[7], usage_127),
     bnds_120$0 = [0, [1, [0, _v_, [0, arg_128, 0]]], bnds_120];
    if(readme_123)
     var
      v_124 = readme_123[1],
      arg_126 = caml_call1(Sexplib0_Sexp_conv[7], v_124),
      bnd_125 = [1, [0, _w_, [0, arg_126, 0]]],
      bnds_120$1 = [0, bnd_125, bnds_120$0];
    else
     var bnds_120$1 = bnds_120$0;
    var
     arg_122 = caml_call1(Sexplib0_Sexp_conv[7], summary_121),
     bnds_120$2 = [0, [1, [0, _x_, [0, arg_122, 0]]], bnds_120$1];
    return [1, bnds_120$2];
   }
   var stable_witness$3 = Stable_witness[6];
   function to_latest(param){
    var
     flags = param[4],
     usage = param[3],
     readme = param[2],
     summary = param[1];
    return [0, summary, readme, [0, usage], flags];
   }
   function of_latest(param){
    var
     flags = param[4],
     anons = param[3],
     readme = param[2],
     summary = param[1];
    if(0 === anons[0])
     var usage$0 = anons[1], usage$1 = usage$0;
    else
     var grammar = anons[1], usage$1 = usage(grammar);
    return [0, summary, readme, usage$1, flags];
   }
   var
    _z_ = caml_call1(Bin_prot_Shape[5], _y_),
    _A_ = [0, [0, caml_call1(Bin_shape[2][1], cst_a), 0, _z_], 0],
    _B_ = caml_call1(Bin_shape[4][1], cst_command_src_shape_ml_125_4),
    group = caml_call2(Bin_prot_Shape[2], _B_, _A_),
    _C_ = caml_call1(Bin_shape[2][1], cst_a$0);
   caml_call1(caml_call2(Bin_prot_Shape[10], group, _C_), 0);
   function compare$4(cmp_a, a_131, b_132){
    if(a_131 === b_132) return 0;
    var n = caml_call2(Ppx_compare_lib[5][8], a_131[1], b_132[1]);
    if(0 !== n) return n;
    var _eK_ = b_132[2], _eL_ = a_131[2];
    function _eM_(a_133, b_134){
     return caml_call2(Ppx_compare_lib[5][8], a_133, b_134);
    }
    var n$0 = caml_call3(Ppx_compare_lib[5][13], _eM_, _eL_, _eK_);
    if(0 !== n$0) return n$0;
    var _eN_ = b_132[3], _eO_ = a_131[3];
    return caml_call3
            (compare,
             function(a_135, b_136){
              function _eP_(a_137, b_138){
               var
                t_140 = a_137[2],
                t_139 = a_137[1],
                t_142 = b_138[2],
                t_141 = b_138[1],
                n = caml_call2(Ppx_compare_lib[5][8], t_139, t_141);
               return 0 === n ? caml_call2(cmp_a, t_140, t_142) : n;
              }
              return caml_call3(Ppx_compare_lib[5][12], _eP_, a_135, b_136);
             },
             _eO_,
             _eN_);
   }
   function t_of_sexp$6(of_a_143, x_151){
    function _eB_(param){
     var
      _eJ_ = param[2],
      subcommands = _eJ_[2][1],
      readme = _eJ_[1],
      summary = param[1];
     return [0, summary, readme, subcommands];
    }
    var _eC_ = 0;
    function _eD_(param){
     return caml_string_notequal(param, cst_readme$9)
             ? caml_string_notequal
                (param, cst_subcommands$2)
               ? caml_string_notequal(param, cst_summary$9) ? -1 : 0
               : 2
             : 1;
    }
    var _eE_ = 0;
    function _eF_(sexp_150){
     if(1 === sexp_150[0]){
      var _eH_ = sexp_150[1];
      if(_eH_){
       var _eI_ = _eH_[2];
       if(_eI_ && ! _eI_[2]){
        var
         arg1_147 = _eI_[1],
         arg0_146 = _eH_[1],
         res0_148 = caml_call1(Sexplib0_Sexp_conv[31], arg0_146),
         res1_149 = caml_call1(of_a_143, arg1_147);
        return [0, res0_148, res1_149];
       }
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4], error_source_145, 2, sexp_150);
    }
    var
     _eG_ =
       [0,
        cst_subcommands,
        1,
        caml_call1(t_of_sexp, caml_call1(Sexplib0_Sexp_conv[44], _eF_)),
        _eE_];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_145,
             [0,
              cst_summary$1,
              1,
              Sexplib0_Sexp_conv[31],
              [0, cst_readme$1, 5, Sexplib0_Sexp_conv[31], _eG_]],
             _eD_,
             _eC_,
             _eB_,
             x_151);
   }
   function sexp_of_t$5(of_a_152, param){
    var
     subcommands_160 = param[3],
     readme_156 = param[2],
     summary_154 = param[1],
     bnds_153 = 0;
    function _eA_(param){
     var
      arg1_163 = param[2],
      arg0_162 = param[1],
      res0_164 = caml_call1(Sexplib0_Sexp_conv[7], arg0_162),
      res1_165 = caml_call1(of_a_152, arg1_163);
     return [1, [0, res0_164, [0, res1_165, 0]]];
    }
    var
     arg_161 =
       caml_call2
        (sexp_of_t, caml_call1(Sexplib0_Sexp_conv[20], _eA_), subcommands_160),
     bnds_153$0 = [0, [1, [0, _D_, [0, arg_161, 0]]], bnds_153];
    if(readme_156)
     var
      v_157 = readme_156[1],
      arg_159 = caml_call1(Sexplib0_Sexp_conv[7], v_157),
      bnd_158 = [1, [0, _E_, [0, arg_159, 0]]],
      bnds_153$1 = [0, bnd_158, bnds_153$0];
    else
     var bnds_153$1 = bnds_153$0;
    var
     arg_155 = caml_call1(Sexplib0_Sexp_conv[7], summary_154),
     bnds_153$2 = [0, [1, [0, _F_, [0, arg_155, 0]]], bnds_153$1];
    return [1, bnds_153$2];
   }
   function stable_witness$4(a_stable_witness){return Stable_witness[6];}
   function map(t, f){
    var _ew_ = Base_List[137][9];
    function _ex_(_ez_){return caml_call2(_ew_, _ez_, f);}
    var _ey_ = caml_call2(Base_Lazy[15], t[3], _ex_);
    return [0, t[1], t[2], _ey_];
   }
   function t_of_sexp$7(of_a_176, x_184){
    function _en_(param){
     var
      _ev_ = param[2],
      subcommands = _ev_[2][1],
      readme = _ev_[1],
      summary = param[1];
     return [0, summary, readme, subcommands];
    }
    var _eo_ = 0;
    function _ep_(param){
     return caml_string_notequal(param, cst_readme$9)
             ? caml_string_notequal
                (param, cst_subcommands$2)
               ? caml_string_notequal(param, cst_summary$9) ? -1 : 0
               : 2
             : 1;
    }
    var _eq_ = 0;
    function _er_(sexp_183){
     if(1 === sexp_183[0]){
      var _et_ = sexp_183[1];
      if(_et_){
       var _eu_ = _et_[2];
       if(_eu_ && ! _eu_[2]){
        var
         arg1_180 = _eu_[1],
         arg0_179 = _et_[1],
         res0_181 = caml_call1(Sexplib0_Sexp_conv[31], arg0_179),
         res1_182 = caml_call1(of_a_176, arg1_180);
        return [0, res0_181, res1_182];
       }
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4], error_source_178, 2, sexp_183);
    }
    var
     _es_ =
       [0,
        cst_subcommands$0,
        1,
        caml_call1(Sexplib0_Sexp_conv[44], _er_),
        _eq_];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_178,
             [0,
              cst_summary$2,
              1,
              Sexplib0_Sexp_conv[31],
              [0, cst_readme$2, 5, Sexplib0_Sexp_conv[31], _es_]],
             _ep_,
             _eo_,
             _en_,
             x_184);
   }
   function sexp_of_t$6(of_a_185, param){
    var
     subcommands_193 = param[3],
     readme_189 = param[2],
     summary_187 = param[1],
     bnds_186 = 0;
    function _em_(param){
     var
      arg1_196 = param[2],
      arg0_195 = param[1],
      res0_197 = caml_call1(Sexplib0_Sexp_conv[7], arg0_195),
      res1_198 = caml_call1(of_a_185, arg1_196);
     return [1, [0, res0_197, [0, res1_198, 0]]];
    }
    var
     arg_194 = caml_call2(Sexplib0_Sexp_conv[20], _em_, subcommands_193),
     bnds_186$0 = [0, [1, [0, _G_, [0, arg_194, 0]]], bnds_186];
    if(readme_189)
     var
      v_190 = readme_189[1],
      arg_192 = caml_call1(Sexplib0_Sexp_conv[7], v_190),
      bnd_191 = [1, [0, _H_, [0, arg_192, 0]]],
      bnds_186$1 = [0, bnd_191, bnds_186$0];
    else
     var bnds_186$1 = bnds_186$0;
    var
     arg_188 = caml_call1(Sexplib0_Sexp_conv[7], summary_187),
     bnds_186$2 = [0, [1, [0, _I_, [0, arg_188, 0]]], bnds_186$1];
    return [1, bnds_186$2];
   }
   function map$0(t, f){
    var _el_ = caml_call2(Base_List[137][9], t[3], f);
    return [0, t[1], t[2], _el_];
   }
   function to_latest$0(param){
    var subcommands = param[3], readme = param[2], summary = param[1];
    return [0, summary, readme, caml_call1(Base_Lazy[24], subcommands)];
   }
   function of_latest$0(param){
    var
     subcommands = param[3],
     readme = param[2],
     summary = param[1],
     _ej_ = caml_obj_tag(subcommands);
    a:
    if(250 === _ej_)
     var _ek_ = subcommands[1];
    else{
     if(246 !== _ej_ && 244 !== _ej_){var _ek_ = subcommands; break a;}
     var _ek_ = caml_call1(CamlinternalLazy[2], subcommands);
    }
    return [0, summary, readme, _ek_];
   }
   function abs_path(dir, path){
    return caml_call1(Filename_base[30], path)
            ? path
            : caml_call2(Filename_base[28], dir, path);
   }
   function compare$5(a_199, b_200){
    if(a_199 === b_200) return 0;
    var n = caml_call2(Ppx_compare_lib[5][8], a_199[1], b_200[1]);
    if(0 !== n) return n;
    var _ed_ = b_200[2], _ee_ = a_199[2];
    function _ef_(a_201, b_202){
     return caml_call2(Ppx_compare_lib[5][8], a_201, b_202);
    }
    var n$0 = caml_call3(Ppx_compare_lib[5][13], _ef_, _ee_, _ed_);
    if(0 !== n$0) return n$0;
    var n$1 = caml_call2(Ppx_compare_lib[5][8], a_199[3], b_200[3]);
    if(0 !== n$1) return n$1;
    var n$2 = caml_call2(Ppx_compare_lib[5][8], a_199[4], b_200[4]);
    if(0 !== n$2) return n$2;
    var _eg_ = b_200[5], _eh_ = a_199[5];
    function _ei_(a_203, b_204){
     return caml_call2(Ppx_compare_lib[5][8], a_203, b_204);
    }
    return caml_call3(Ppx_compare_lib[5][12], _ei_, _eh_, _eg_);
   }
   function t_of_sexp$8(x_207){
    function _d8_(param){
     var
      _ea_ = param[2],
      _eb_ = _ea_[2],
      _ec_ = _eb_[2],
      child_subcommand = _ec_[2][1],
      path_to_exe = _ec_[1],
      working_dir = _eb_[1],
      readme = _ea_[1],
      summary = param[1];
     return [0, summary, readme, working_dir, path_to_exe, child_subcommand];
    }
    var _d9_ = 0;
    function _d__(param){
     return caml_string_notequal(param, cst_child_subcommand$1)
             ? caml_string_notequal
                (param, cst_path_to_exe$3)
               ? caml_string_notequal
                  (param, cst_readme$9)
                 ? caml_string_notequal
                    (param, cst_summary$9)
                   ? caml_string_notequal(param, cst_working_dir$2) ? -1 : 2
                   : 0
                 : 1
               : 3
             : 4;
    }
    var
     _d$_ =
       [0,
        cst_child_subcommand,
        1,
        caml_call1(Sexplib0_Sexp_conv[44], Sexplib0_Sexp_conv[31]),
        0];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_206,
             [0,
              cst_summary$3,
              1,
              Sexplib0_Sexp_conv[31],
              [0,
               cst_readme$3,
               5,
               Sexplib0_Sexp_conv[31],
               [0,
                cst_working_dir,
                1,
                Sexplib0_Sexp_conv[31],
                [0, cst_path_to_exe, 1, Sexplib0_Sexp_conv[31], _d$_]]]],
             _d__,
             _d9_,
             _d8_,
             x_207);
   }
   function sexp_of_t$7(param){
    var
     child_subcommand_219 = param[5],
     path_to_exe_217 = param[4],
     working_dir_215 = param[3],
     readme_211 = param[2],
     summary_209 = param[1],
     arg_220 =
       caml_call2
        (Sexplib0_Sexp_conv[20], Sexplib0_Sexp_conv[7], child_subcommand_219),
     bnds_208 = [0, [1, [0, _J_, [0, arg_220, 0]]], 0],
     arg_218 = caml_call1(Sexplib0_Sexp_conv[7], path_to_exe_217),
     bnds_208$0 = [0, [1, [0, _K_, [0, arg_218, 0]]], bnds_208],
     arg_216 = caml_call1(Sexplib0_Sexp_conv[7], working_dir_215),
     bnds_208$1 = [0, [1, [0, _L_, [0, arg_216, 0]]], bnds_208$0];
    if(readme_211)
     var
      v_212 = readme_211[1],
      arg_214 = caml_call1(Sexplib0_Sexp_conv[7], v_212),
      bnd_213 = [1, [0, _M_, [0, arg_214, 0]]],
      bnds_208$2 = [0, bnd_213, bnds_208$1];
    else
     var bnds_208$2 = bnds_208$1;
    var
     arg_210 = caml_call1(Sexplib0_Sexp_conv[7], summary_209),
     bnds_208$3 = [0, [1, [0, _N_, [0, arg_210, 0]]], bnds_208$2];
    return [1, bnds_208$3];
   }
   var stable_witness$5 = Stable_witness[6];
   function to_latest$1(_d7_){return _d7_;}
   function of_latest$1(_d6_){return _d6_;}
   function t_of_sexp$9(x_223){
    function _d1_(param){
     var
      _d4_ = param[2],
      _d5_ = _d4_[2],
      path_to_exe = _d5_[2][1],
      working_dir = _d5_[1],
      readme = _d4_[1],
      summary = param[1];
     return [0, summary, readme, working_dir, path_to_exe];
    }
    var _d2_ = 0;
    function _d3_(param){
     return caml_string_notequal(param, cst_path_to_exe$3)
             ? caml_string_notequal
                (param, cst_readme$9)
               ? caml_string_notequal
                  (param, cst_summary$9)
                 ? caml_string_notequal(param, cst_working_dir$2) ? -1 : 2
                 : 0
               : 1
             : 3;
    }
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_222,
             [0,
              cst_summary$4,
              1,
              Sexplib0_Sexp_conv[31],
              [0,
               cst_readme$4,
               5,
               Sexplib0_Sexp_conv[31],
               [0,
                cst_working_dir$0,
                1,
                Sexplib0_Sexp_conv[31],
                [0, cst_path_to_exe$0, 1, Sexplib0_Sexp_conv[31], 0]]]],
             _d3_,
             _d2_,
             _d1_,
             x_223);
   }
   function sexp_of_t$8(param){
    var
     path_to_exe_233 = param[4],
     working_dir_231 = param[3],
     readme_227 = param[2],
     summary_225 = param[1],
     arg_234 = caml_call1(Sexplib0_Sexp_conv[7], path_to_exe_233),
     bnds_224 = [0, [1, [0, _O_, [0, arg_234, 0]]], 0],
     arg_232 = caml_call1(Sexplib0_Sexp_conv[7], working_dir_231),
     bnds_224$0 = [0, [1, [0, _P_, [0, arg_232, 0]]], bnds_224];
    if(readme_227)
     var
      v_228 = readme_227[1],
      arg_230 = caml_call1(Sexplib0_Sexp_conv[7], v_228),
      bnd_229 = [1, [0, _Q_, [0, arg_230, 0]]],
      bnds_224$1 = [0, bnd_229, bnds_224$0];
    else
     var bnds_224$1 = bnds_224$0;
    var
     arg_226 = caml_call1(Sexplib0_Sexp_conv[7], summary_225),
     bnds_224$2 = [0, [1, [0, _R_, [0, arg_226, 0]]], bnds_224$1];
    return [1, bnds_224$2];
   }
   var stable_witness$6 = Stable_witness[6];
   function to_v3(t){return [0, t[1], t[2], t[3], t[4], 0];}
   function of_v3(t){
    var _d0_ = abs_path(t[3], t[4]);
    return [0, t[1], t[2], t[3], _d0_];
   }
   var
    to_latest$2 = caml_call2(Base_Fn[5], to_latest$1, to_v3),
    of_latest$2 = caml_call2(Base_Fn[5], of_v3, of_latest$1);
   function t_of_sexp$10(x_237){
    function _dW_(param){
     var
      _dZ_ = param[2],
      path_to_exe = _dZ_[2][1],
      readme = _dZ_[1],
      summary = param[1];
     return [0, summary, readme, path_to_exe];
    }
    var _dX_ = 0;
    function _dY_(param){
     return caml_string_notequal(param, cst_path_to_exe$3)
             ? caml_string_notequal
                (param, cst_readme$9)
               ? caml_string_notequal(param, cst_summary$9) ? -1 : 0
               : 1
             : 2;
    }
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_236,
             [0,
              cst_summary$5,
              1,
              Sexplib0_Sexp_conv[31],
              [0,
               cst_readme$5,
               5,
               Sexplib0_Sexp_conv[31],
               [0, cst_path_to_exe$1, 1, Sexplib0_Sexp_conv[31], 0]]],
             _dY_,
             _dX_,
             _dW_,
             x_237);
   }
   function sexp_of_t$9(param){
    var
     path_to_exe_245 = param[3],
     readme_241 = param[2],
     summary_239 = param[1],
     arg_246 = caml_call1(Sexplib0_Sexp_conv[7], path_to_exe_245),
     bnds_238 = [0, [1, [0, _S_, [0, arg_246, 0]]], 0];
    if(readme_241)
     var
      v_242 = readme_241[1],
      arg_244 = caml_call1(Sexplib0_Sexp_conv[7], v_242),
      bnd_243 = [1, [0, _T_, [0, arg_244, 0]]],
      bnds_238$0 = [0, bnd_243, bnds_238];
    else
     var bnds_238$0 = bnds_238;
    var
     arg_240 = caml_call1(Sexplib0_Sexp_conv[7], summary_239),
     bnds_238$1 = [0, [1, [0, _U_, [0, arg_240, 0]]], bnds_238$0];
    return [1, bnds_238$1];
   }
   var stable_witness$7 = Stable_witness[6];
   function to_v2(t){return [0, t[1], t[2], cst$0, t[3]];}
   function of_v2(t){
    var _dV_ = abs_path(t[3], t[4]);
    return [0, t[1], t[2], _dV_];
   }
   var
    to_latest$3 = caml_call2(Base_Fn[5], to_latest$2, to_v2),
    of_latest$3 = caml_call2(Base_Fn[5], of_v2, of_latest$2);
   function compare$6(a_247, b_248){
    var a_247$0 = a_247, b_248$0 = b_248;
    for(;;){
     if(a_247$0 === b_248$0) return 0;
     switch(a_247$0[0]){
       case 0:
        var a_249 = a_247$0[1];
        if(0 !== b_248$0[0]) return -1;
        var b_250 = b_248$0[1];
        return compare$3(a_249, b_250);
       case 1:
        var a_251 = a_247$0[1];
        switch(b_248$0[0]){
          case 0: break;
          case 1:
           var b_252 = b_248$0[1];
           return compare$4
                   (function(a_253, b_254){return compare$6(a_253, b_254);},
                    a_251,
                    b_252);
          default: return -1;
        }
        break;
       default:
        var a_257 = a_247$0[2], a_255 = a_247$0[1];
        switch(b_248$0[0]){
          case 0: break;
          case 1:
           return 1;
          default:
           var
            b_258 = b_248$0[2],
            b_256 = b_248$0[1],
            n = compare$5(a_255, b_256);
           if(0 !== n) return n;
           var a_247$0 = a_257, b_248$0 = b_258;
           continue;
        }
     }
     return 1;
    }
   }
   var t_of_sexp$11 = function _dU_(_dT_){return _dU_.fun(_dT_);};
   caml_update_dummy
    (t_of_sexp$11,
     function(sexp_263){
      a:
      {
       if(0 === sexp_263[0]){
        var _dP_ = sexp_263[1];
        b:
        if(caml_string_notequal(_dP_, cst_Basic)){
         c:
         if(caml_string_notequal(_dP_, cst_Exec)){
          if(caml_string_notequal(_dP_, cst_Group)){
           if(! caml_string_notequal(_dP_, cst_basic)) break b;
           if(! caml_string_notequal(_dP_, cst_exec)) break c;
           if(caml_string_notequal(_dP_, cst_group)) break a;
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_261, sexp_263);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_261, sexp_263);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_261, sexp_263);
       }
       var _dQ_ = sexp_263[1];
       if(! _dQ_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_261, sexp_263);
       var _dR_ = _dQ_[1];
       if(0 !== _dR_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_261, sexp_263);
       var tag_264 = _dR_[1];
       b:
       if(caml_string_notequal(tag_264, cst_Basic)){
        c:
        if(caml_string_notequal(tag_264, cst_Exec)){
         if(caml_string_notequal(tag_264, cst_Group)){
          if(! caml_string_notequal(tag_264, cst_basic)) break b;
          if(! caml_string_notequal(tag_264, cst_exec)) break c;
          if(caml_string_notequal(tag_264, cst_group)) break a;
         }
         var sexp_args_270 = _dQ_[2];
         if(sexp_args_270 && ! sexp_args_270[2]){
          var
           arg0_271 = sexp_args_270[1],
           res0_272 = t_of_sexp$6(t_of_sexp$11, arg0_271);
          return [1, res0_272];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_261,
                  tag_264,
                  sexp_263);
        }
        var sexp_args_275 = _dQ_[2];
        if(sexp_args_275){
         var _dS_ = sexp_args_275[2];
         if(_dS_ && ! _dS_[2]){
          var
           arg1_277 = _dS_[1],
           arg0_276 = sexp_args_275[1],
           res0_278 = t_of_sexp$8(arg0_276),
           res1_279 = caml_call1(t_of_sexp$11, arg1_277);
          return [2, res0_278, res1_279];
         }
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_261,
                 tag_264,
                 sexp_263);
       }
       var sexp_args_265 = _dQ_[2];
       if(sexp_args_265 && ! sexp_args_265[2]){
        var arg0_266 = sexp_args_265[1], res0_267 = t_of_sexp$4(arg0_266);
        return [0, res0_267];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_261,
                tag_264,
                sexp_263);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_261, sexp_263);
     });
   function sexp_of_t$10(param){
    switch(param[0]){
      case 0:
       var arg0_280 = param[1], res0_281 = sexp_of_t$3(arg0_280);
       return [1, [0, _V_, [0, res0_281, 0]]];
      case 1:
       var
        arg0_282 = param[1],
        res0_283 = sexp_of_t$5(sexp_of_t$10, arg0_282);
       return [1, [0, _W_, [0, res0_283, 0]]];
      default:
       var
        arg1_285 = param[2],
        arg0_284 = param[1],
        res0_286 = sexp_of_t$7(arg0_284),
        res1_287 = sexp_of_t$10(arg1_285);
       return [1, [0, _X_, [0, res0_286, [0, res1_287, 0]]]];
    }
   }
   var
    stable_witness_checks_for_t$0 =
      function _dO_(_dN_){return _dO_.fun(_dN_);},
    stable_witness$8 = Stable_witness[6];
   caml_update_dummy
    (stable_witness_checks_for_t$0, function(param){return 0;});
   var t_of_sexp$12 = function _dM_(_dL_){return _dM_.fun(_dL_);};
   caml_update_dummy
    (t_of_sexp$12,
     function(sexp_292){
      a:
      {
       if(0 === sexp_292[0]){
        var _dI_ = sexp_292[1];
        b:
        if(caml_string_notequal(_dI_, cst_Base)){
         c:
         if(caml_string_notequal(_dI_, cst_Exec)){
          d:
          if(caml_string_notequal(_dI_, cst_Group)){
           if(caml_string_notequal(_dI_, cst_Lazy)){
            if(! caml_string_notequal(_dI_, cst_base)) break b;
            if(! caml_string_notequal(_dI_, cst_exec)) break c;
            if(! caml_string_notequal(_dI_, cst_group)) break d;
            if(caml_string_notequal(_dI_, cst_lazy)) break a;
           }
           return caml_call2
                   (Sexplib0_Sexp_conv_error[9], error_source_290, sexp_292);
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_290, sexp_292);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_290, sexp_292);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_290, sexp_292);
       }
       var _dJ_ = sexp_292[1];
       if(! _dJ_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_290, sexp_292);
       var _dK_ = _dJ_[1];
       if(0 !== _dK_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_290, sexp_292);
       var tag_293 = _dK_[1];
       b:
       if(caml_string_notequal(tag_293, cst_Base)){
        c:
        if(caml_string_notequal(tag_293, cst_Exec)){
         d:
         if(caml_string_notequal(tag_293, cst_Group)){
          if(caml_string_notequal(tag_293, cst_Lazy)){
           if(! caml_string_notequal(tag_293, cst_base)) break b;
           if(! caml_string_notequal(tag_293, cst_exec)) break c;
           if(! caml_string_notequal(tag_293, cst_group)) break d;
           if(caml_string_notequal(tag_293, cst_lazy)) break a;
          }
          var sexp_args_309 = _dJ_[2];
          if(sexp_args_309 && ! sexp_args_309[2]){
           var
            arg0_310 = sexp_args_309[1],
            res0_311 = caml_call2(t_of_sexp, t_of_sexp$12, arg0_310);
           return [3, res0_311];
          }
          return caml_call3
                  (Sexplib0_Sexp_conv_error[8],
                   error_source_290,
                   tag_293,
                   sexp_292);
         }
         var sexp_args_299 = _dJ_[2];
         if(sexp_args_299 && ! sexp_args_299[2]){
          var
           arg0_300 = sexp_args_299[1],
           res0_301 = t_of_sexp$6(t_of_sexp$12, arg0_300);
          return [1, res0_301];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_290,
                  tag_293,
                  sexp_292);
        }
        var sexp_args_304 = _dJ_[2];
        if(sexp_args_304 && ! sexp_args_304[2]){
         var arg0_305 = sexp_args_304[1], res0_306 = t_of_sexp$8(arg0_305);
         return [2, res0_306];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_290,
                 tag_293,
                 sexp_292);
       }
       var sexp_args_294 = _dJ_[2];
       if(sexp_args_294 && ! sexp_args_294[2]){
        var arg0_295 = sexp_args_294[1], res0_296 = t_of_sexp$4(arg0_295);
        return [0, res0_296];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_290,
                tag_293,
                sexp_292);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_290, sexp_292);
     });
   function sexp_of_t$11(param){
    switch(param[0]){
      case 0:
       var arg0_312 = param[1], res0_313 = sexp_of_t$3(arg0_312);
       return [1, [0, _Y_, [0, res0_313, 0]]];
      case 1:
       var
        arg0_314 = param[1],
        res0_315 = sexp_of_t$5(sexp_of_t$11, arg0_314);
       return [1, [0, _Z_, [0, res0_315, 0]]];
      case 2:
       var arg0_316 = param[1], res0_317 = sexp_of_t$7(arg0_316);
       return [1, [0, ___, [0, res0_317, 0]]];
      default:
       var
        arg0_318 = param[1],
        res0_319 = caml_call2(sexp_of_t, sexp_of_t$11, arg0_318);
       return [1, [0, _$_, [0, res0_319, 0]]];
    }
   }
   var
    stable_witness_checks_for_t$1 =
      function _dH_(_dG_){return _dH_.fun(_dG_);};
   caml_update_dummy
    (stable_witness_checks_for_t$1, function(param){return 0;});
   var t_of_sexp$13 = function _dF_(_dE_){return _dF_.fun(_dE_);};
   caml_update_dummy
    (t_of_sexp$13,
     function(sexp_324){
      a:
      {
       if(0 === sexp_324[0]){
        var _dB_ = sexp_324[1];
        b:
        if(caml_string_notequal(_dB_, cst_Base)){
         c:
         if(caml_string_notequal(_dB_, cst_Exec)){
          if(caml_string_notequal(_dB_, cst_Group)){
           if(! caml_string_notequal(_dB_, cst_base)) break b;
           if(! caml_string_notequal(_dB_, cst_exec)) break c;
           if(caml_string_notequal(_dB_, cst_group)) break a;
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_322, sexp_324);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_322, sexp_324);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_322, sexp_324);
       }
       var _dC_ = sexp_324[1];
       if(! _dC_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_322, sexp_324);
       var _dD_ = _dC_[1];
       if(0 !== _dD_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_322, sexp_324);
       var tag_325 = _dD_[1];
       b:
       if(caml_string_notequal(tag_325, cst_Base)){
        c:
        if(caml_string_notequal(tag_325, cst_Exec)){
         if(caml_string_notequal(tag_325, cst_Group)){
          if(! caml_string_notequal(tag_325, cst_base)) break b;
          if(! caml_string_notequal(tag_325, cst_exec)) break c;
          if(caml_string_notequal(tag_325, cst_group)) break a;
         }
         var sexp_args_331 = _dC_[2];
         if(sexp_args_331 && ! sexp_args_331[2]){
          var
           arg0_332 = sexp_args_331[1],
           res0_333 = t_of_sexp$7(t_of_sexp$13, arg0_332);
          return [1, res0_333];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_322,
                  tag_325,
                  sexp_324);
        }
        var sexp_args_336 = _dC_[2];
        if(sexp_args_336 && ! sexp_args_336[2]){
         var arg0_337 = sexp_args_336[1], res0_338 = t_of_sexp$9(arg0_337);
         return [2, res0_338];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_322,
                 tag_325,
                 sexp_324);
       }
       var sexp_args_326 = _dC_[2];
       if(sexp_args_326 && ! sexp_args_326[2]){
        var arg0_327 = sexp_args_326[1], res0_328 = t_of_sexp$4(arg0_327);
        return [0, res0_328];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_322,
                tag_325,
                sexp_324);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_322, sexp_324);
     });
   function sexp_of_t$12(param){
    switch(param[0]){
      case 0:
       var arg0_339 = param[1], res0_340 = sexp_of_t$3(arg0_339);
       return [1, [0, _aa_, [0, res0_340, 0]]];
      case 1:
       var
        arg0_341 = param[1],
        res0_342 = sexp_of_t$6(sexp_of_t$12, arg0_341);
       return [1, [0, _ab_, [0, res0_342, 0]]];
      default:
       var arg0_343 = param[1], res0_344 = sexp_of_t$8(arg0_343);
       return [1, [0, _ac_, [0, res0_344, 0]]];
    }
   }
   var
    stable_witness_checks_for_t$2 =
      function _dA_(_dz_){return _dA_.fun(_dz_);};
   caml_update_dummy
    (stable_witness_checks_for_t$2, function(param){return 0;});
   function to_latest$4(param){
    switch(param[0]){
      case 0:
       var b = param[1]; return [0, b];
      case 1:
       var g = param[1]; return [1, to_latest$0(map$0(g, to_latest$4))];
      default: var e = param[1]; return [2, caml_call1(to_latest$2, e)];
    }
   }
   function of_latest$4(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var b = param$0[1]; return [0, b];
       case 1:
        var g = param$0[1]; return [1, map$0(of_latest$0(g), of_latest$4)];
       case 2:
        var e = param$0[1]; return [2, caml_call1(of_latest$2, e)];
       default:
        var thunk = param$0[1], _dy_ = caml_obj_tag(thunk);
        a:
        if(250 === _dy_)
         var param$1 = thunk[1];
        else{
         if(246 !== _dy_ && 244 !== _dy_){var param$1 = thunk; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], thunk);
        }
        var param$0 = param$1;
     }
   }
   var t_of_sexp$14 = function _dx_(_dw_){return _dx_.fun(_dw_);};
   caml_update_dummy
    (t_of_sexp$14,
     function(sexp_349){
      a:
      {
       if(0 === sexp_349[0]){
        var _dt_ = sexp_349[1];
        b:
        if(caml_string_notequal(_dt_, cst_Base)){
         c:
         if(caml_string_notequal(_dt_, cst_Exec)){
          if(caml_string_notequal(_dt_, cst_Group)){
           if(! caml_string_notequal(_dt_, cst_base)) break b;
           if(! caml_string_notequal(_dt_, cst_exec)) break c;
           if(caml_string_notequal(_dt_, cst_group)) break a;
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_347, sexp_349);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_347, sexp_349);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_347, sexp_349);
       }
       var _du_ = sexp_349[1];
       if(! _du_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_347, sexp_349);
       var _dv_ = _du_[1];
       if(0 !== _dv_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_347, sexp_349);
       var tag_350 = _dv_[1];
       b:
       if(caml_string_notequal(tag_350, cst_Base)){
        c:
        if(caml_string_notequal(tag_350, cst_Exec)){
         if(caml_string_notequal(tag_350, cst_Group)){
          if(! caml_string_notequal(tag_350, cst_base)) break b;
          if(! caml_string_notequal(tag_350, cst_exec)) break c;
          if(caml_string_notequal(tag_350, cst_group)) break a;
         }
         var sexp_args_356 = _du_[2];
         if(sexp_args_356 && ! sexp_args_356[2]){
          var
           arg0_357 = sexp_args_356[1],
           res0_358 = t_of_sexp$7(t_of_sexp$14, arg0_357);
          return [1, res0_358];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_347,
                  tag_350,
                  sexp_349);
        }
        var sexp_args_361 = _du_[2];
        if(sexp_args_361 && ! sexp_args_361[2]){
         var arg0_362 = sexp_args_361[1], res0_363 = t_of_sexp$10(arg0_362);
         return [2, res0_363];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_347,
                 tag_350,
                 sexp_349);
       }
       var sexp_args_351 = _du_[2];
       if(sexp_args_351 && ! sexp_args_351[2]){
        var arg0_352 = sexp_args_351[1], res0_353 = t_of_sexp$5(arg0_352);
        return [0, res0_353];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_347,
                tag_350,
                sexp_349);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_347, sexp_349);
     });
   function sexp_of_t$13(param){
    switch(param[0]){
      case 0:
       var arg0_364 = param[1], res0_365 = sexp_of_t$4(arg0_364);
       return [1, [0, _ad_, [0, res0_365, 0]]];
      case 1:
       var
        arg0_366 = param[1],
        res0_367 = sexp_of_t$6(sexp_of_t$13, arg0_366);
       return [1, [0, _ae_, [0, res0_367, 0]]];
      default:
       var arg0_368 = param[1], res0_369 = sexp_of_t$9(arg0_368);
       return [1, [0, _af_, [0, res0_369, 0]]];
    }
   }
   var
    stable_witness_checks_for_t$3 =
      function _ds_(_dr_){return _ds_.fun(_dr_);};
   caml_update_dummy
    (stable_witness_checks_for_t$3, function(param){return 0;});
   function to_latest$5(param){
    switch(param[0]){
      case 0:
       var b = param[1]; return [0, to_latest(b)];
      case 1:
       var g = param[1]; return [1, to_latest$0(map$0(g, to_latest$5))];
      default: var e = param[1]; return [2, caml_call1(to_latest$3, e)];
    }
   }
   function of_latest$5(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var b = param$0[1]; return [0, of_latest(b)];
       case 1:
        var g = param$0[1]; return [1, map$0(of_latest$0(g), of_latest$5)];
       case 2:
        var e = param$0[1]; return [2, caml_call1(of_latest$3, e)];
       default:
        var thunk = param$0[1], _dq_ = caml_obj_tag(thunk);
        a:
        if(250 === _dq_)
         var param$1 = thunk[1];
        else{
         if(246 !== _dq_ && 244 !== _dq_){var param$1 = thunk; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], thunk);
        }
        var param$0 = param$1;
     }
   }
   function t_of_sexp$15(sexp_374){
    a:
    {
     if(0 === sexp_374[0]){
      var _dn_ = sexp_374[1];
      b:
      if(caml_string_notequal(_dn_, cst_V1$0)){
       c:
       if(caml_string_notequal(_dn_, cst_V2$0)){
        if(caml_string_notequal(_dn_, cst_V3$0)){
         if(! caml_string_notequal(_dn_, cst_v1)) break b;
         if(! caml_string_notequal(_dn_, cst_v2)) break c;
         if(caml_string_notequal(_dn_, cst_v3)) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_372, sexp_374);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_372, sexp_374);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_372, sexp_374);
     }
     var _do_ = sexp_374[1];
     if(! _do_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_372, sexp_374);
     var _dp_ = _do_[1];
     if(0 !== _dp_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_372, sexp_374);
     var tag_375 = _dp_[1];
     b:
     if(caml_string_notequal(tag_375, cst_V1$0)){
      c:
      if(caml_string_notequal(tag_375, cst_V2$0)){
       if(caml_string_notequal(tag_375, cst_V3$0)){
        if(! caml_string_notequal(tag_375, cst_v1)) break b;
        if(! caml_string_notequal(tag_375, cst_v2)) break c;
        if(caml_string_notequal(tag_375, cst_v3)) break a;
       }
       var sexp_args_386 = _do_[2];
       if(sexp_args_386 && ! sexp_args_386[2]){
        var
         arg0_387 = sexp_args_386[1],
         res0_388 = caml_call1(t_of_sexp$12, arg0_387);
        return [2, res0_388];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_372,
                tag_375,
                sexp_374);
      }
      var sexp_args_381 = _do_[2];
      if(sexp_args_381 && ! sexp_args_381[2]){
       var
        arg0_382 = sexp_args_381[1],
        res0_383 = caml_call1(t_of_sexp$13, arg0_382);
       return [1, res0_383];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_372,
               tag_375,
               sexp_374);
     }
     var sexp_args_376 = _do_[2];
     if(sexp_args_376 && ! sexp_args_376[2]){
      var
       arg0_377 = sexp_args_376[1],
       res0_378 = caml_call1(t_of_sexp$14, arg0_377);
      return [0, res0_378];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_372,
              tag_375,
              sexp_374);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_372, sexp_374);
   }
   function sexp_of_t$14(param){
    switch(param[0]){
      case 0:
       var arg0_389 = param[1], res0_390 = sexp_of_t$13(arg0_389);
       return [1, [0, _ag_, [0, res0_390, 0]]];
      case 1:
       var arg0_391 = param[1], res0_392 = sexp_of_t$12(arg0_391);
       return [1, [0, _ah_, [0, res0_392, 0]]];
      default:
       var arg0_393 = param[1], res0_394 = sexp_of_t$11(arg0_393);
       return [1, [0, _ai_, [0, res0_394, 0]]];
    }
   }
   function v1(v0){return [0, v0];}
   function v2(v0){return [1, v0];}
   function v3(v0){return [2, v0];}
   var
    v1$0 = [0, cst_V1, 0, v1],
    v2$0 = [0, cst_V2, 1, v2],
    v3$0 = [0, cst_V3, 2, v3];
   function of_versioned(param){
    switch(param[0]){
      case 0:
       var t = param[1]; return to_latest$5(t);
      case 1:
       var t$0 = param[1]; return to_latest$4(t$0);
      default: var t$1 = param[1]; return t$1;
    }
   }
   function compare$7(a_395, b_396){
    var a_395$0 = a_395, b_396$0 = b_396;
    for(;;){
     if(a_395$0 === b_396$0) return 0;
     if(typeof a_395$0 === "number")
      return typeof b_396$0 === "number" ? 0 : -1;
     a:
     {
      b:
      {
       c:
       {
        switch(a_395$0[0]){
          case 0:
           var a_397 = a_395$0[1];
           if(typeof b_396$0 === "number") break a;
           if(0 !== b_396$0[0]) return -1;
           var b_398 = b_396$0[1];
           return caml_call2(Base[195], a_397, b_398);
          case 1:
           var a_399 = a_395$0[1];
           if(typeof b_396$0 === "number") break a;
           switch(b_396$0[0]){
             case 0:
              break b;
             case 1:
              var b_400 = b_396$0[1], a_395$0 = a_399, b_396$0 = b_400;
              continue;
             default: return -1;
           }
          case 2:
           var a_401 = a_395$0[1];
           if(typeof b_396$0 === "number") break a;
           switch(b_396$0[0]){
             case 0:
              break b;
             case 1:
              break c;
             case 2:
              var b_402 = b_396$0[1], a_395$0 = a_401, b_396$0 = b_402;
              continue;
             default: return -1;
           }
          case 3:
           var a_403 = a_395$0[1];
           if(typeof b_396$0 === "number") break a;
           switch(b_396$0[0]){
             case 0:
              break b;
             case 1:
              break c;
             case 2: break;
             case 3:
              var
               b_404 = b_396$0[1],
               _dm_ = function(a_405, b_406){return compare$7(a_405, b_406);};
              return caml_call3(Base[159], _dm_, a_403, b_404);
             default: return -1;
           }
           break;
          default:
           var a_407 = a_395$0[1];
           if(typeof b_396$0 === "number") break a;
           switch(b_396$0[0]){
             case 0:
              break b;
             case 1:
              break c;
             case 2: break;
             case 3:
              return 1;
             default:
              var b_408 = b_396$0[1];
              return caml_call2(Base[195], a_407, b_408);
           }
        }
        return 1;
       }
       return 1;
      }
      return 1;
     }
     return 1;
    }
   }
   var t_of_sexp$16 = function _dl_(_dk_){return _dl_.fun(_dk_);};
   caml_update_dummy
    (t_of_sexp$16,
     function(sexp_413){
      a:
      {
       if(0 === sexp_413[0]){
        var _df_ = sexp_413[1], _dg_ = caml_string_compare(_df_, cst_ad_hoc);
        b:
        {
         c:
         {
          d:
          {
           e:
           {
            f:
            {
             if(0 <= _dg_){
              if(0 < _dg_){
               if(! caml_string_notequal(_df_, cst_concat)) break f;
               if(! caml_string_notequal(_df_, cst_many)) break e;
               if(! caml_string_notequal(_df_, cst_maybe)) break d;
               if(! caml_string_notequal(_df_, cst_one)) break c;
               if(caml_string_notequal(_df_, cst_zero)) break a;
               break b;
              }
             }
             else if(caml_string_notequal(_df_, cst_Ad_hoc)){
              if(! caml_string_notequal(_df_, cst_Concat)) break f;
              if(! caml_string_notequal(_df_, cst_Many)) break e;
              if(! caml_string_notequal(_df_, cst_Maybe)) break d;
              if(! caml_string_notequal(_df_, cst_One)) break c;
              if(caml_string_notequal(_df_, cst_Zero)) break a;
              break b;
             }
             return caml_call2
                     (Sexplib0_Sexp_conv_error[9], error_source_411, sexp_413);
            }
            return caml_call2
                    (Sexplib0_Sexp_conv_error[9], error_source_411, sexp_413);
           }
           return caml_call2
                   (Sexplib0_Sexp_conv_error[9], error_source_411, sexp_413);
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_411, sexp_413);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_411, sexp_413);
        }
        return 0;
       }
       var _dh_ = sexp_413[1];
       if(! _dh_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_411, sexp_413);
       var _di_ = _dh_[1];
       if(0 !== _di_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_411, sexp_413);
       var tag_414 = _di_[1], _dj_ = caml_string_compare(tag_414, cst_ad_hoc);
       b:
       {
        c:
        {
         d:
         {
          e:
          {
           f:
           {
            if(0 <= _dj_){
             if(0 < _dj_){
              if(! caml_string_notequal(tag_414, cst_concat)) break f;
              if(! caml_string_notequal(tag_414, cst_many)) break e;
              if(! caml_string_notequal(tag_414, cst_maybe)) break d;
              if(! caml_string_notequal(tag_414, cst_one)) break c;
              if(caml_string_notequal(tag_414, cst_zero)) break a;
              break b;
             }
            }
            else if(caml_string_notequal(tag_414, cst_Ad_hoc)){
             if(! caml_string_notequal(tag_414, cst_Concat)) break f;
             if(! caml_string_notequal(tag_414, cst_Many)) break e;
             if(! caml_string_notequal(tag_414, cst_Maybe)) break d;
             if(! caml_string_notequal(tag_414, cst_One)) break c;
             if(caml_string_notequal(tag_414, cst_Zero)) break a;
             break b;
            }
            var sexp_args_435 = _dh_[2];
            if(sexp_args_435 && ! sexp_args_435[2]){
             var
              arg0_436 = sexp_args_435[1],
              res0_437 = caml_call1(Base[201], arg0_436);
             return [4, res0_437];
            }
            return caml_call3
                    (Sexplib0_Sexp_conv_error[8],
                     error_source_411,
                     tag_414,
                     sexp_413);
           }
           var sexp_args_430 = _dh_[2];
           if(sexp_args_430 && ! sexp_args_430[2]){
            var
             arg0_431 = sexp_args_430[1],
             res0_432 = caml_call2(Base[164], t_of_sexp$16, arg0_431);
            return [3, res0_432];
           }
           return caml_call3
                   (Sexplib0_Sexp_conv_error[8],
                    error_source_411,
                    tag_414,
                    sexp_413);
          }
          var sexp_args_420 = _dh_[2];
          if(sexp_args_420 && ! sexp_args_420[2]){
           var
            arg0_421 = sexp_args_420[1],
            res0_422 = caml_call1(t_of_sexp$16, arg0_421);
           return [1, res0_422];
          }
          return caml_call3
                  (Sexplib0_Sexp_conv_error[8],
                   error_source_411,
                   tag_414,
                   sexp_413);
         }
         var sexp_args_425 = _dh_[2];
         if(sexp_args_425 && ! sexp_args_425[2]){
          var
           arg0_426 = sexp_args_425[1],
           res0_427 = caml_call1(t_of_sexp$16, arg0_426);
          return [2, res0_427];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_411,
                  tag_414,
                  sexp_413);
        }
        var sexp_args_415 = _dh_[2];
        if(sexp_args_415 && ! sexp_args_415[2]){
         var
          arg0_416 = sexp_args_415[1],
          res0_417 = caml_call1(Base[201], arg0_416);
         return [0, res0_417];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_411,
                 tag_414,
                 sexp_413);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_411, sexp_413);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_411, sexp_413);
     });
   function sexp_of_t$15(param){
    if(typeof param === "number") return _ak_;
    switch(param[0]){
      case 0:
       var arg0_438 = param[1], res0_439 = caml_call1(Base[202], arg0_438);
       return [1, [0, _al_, [0, res0_439, 0]]];
      case 1:
       var arg0_440 = param[1], res0_441 = sexp_of_t$15(arg0_440);
       return [1, [0, _am_, [0, res0_441, 0]]];
      case 2:
       var arg0_442 = param[1], res0_443 = sexp_of_t$15(arg0_442);
       return [1, [0, _an_, [0, res0_443, 0]]];
      case 3:
       var
        arg0_444 = param[1],
        res0_445 = caml_call2(Base[165], sexp_of_t$15, arg0_444);
       return [1, [0, _ao_, [0, res0_445, 0]]];
      default:
       var arg0_446 = param[1], res0_447 = caml_call1(Base[202], arg0_446);
       return [1, [0, _ap_, [0, res0_447, 0]]];
    }
   }
   function compare$8(a_448, b_449){
    if(a_448 === b_449) return 0;
    if(0 === a_448[0]){
     var a_450 = a_448[1];
     if(0 !== b_449[0]) return -1;
     var b_451 = b_449[1];
     return caml_call2(Base[195], a_450, b_451);
    }
    var a_452 = a_448[1];
    if(0 === b_449[0]) return 1;
    var b_453 = b_449[1];
    return compare$7(a_452, b_453);
   }
   function t_of_sexp$17(sexp_458){
    a:
    {
     if(0 === sexp_458[0]){
      var _dc_ = sexp_458[1];
      b:
      if(caml_string_notequal(_dc_, cst_Grammar)){
       if(caml_string_notequal(_dc_, cst_Usage)){
        if(! caml_string_notequal(_dc_, cst_grammar)) break b;
        if(caml_string_notequal(_dc_, cst_usage$0)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_456, sexp_458);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_456, sexp_458);
     }
     var _dd_ = sexp_458[1];
     if(! _dd_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_456, sexp_458);
     var _de_ = _dd_[1];
     if(0 !== _de_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_456, sexp_458);
     var tag_459 = _de_[1];
     b:
     if(caml_string_notequal(tag_459, cst_Grammar)){
      if(caml_string_notequal(tag_459, cst_Usage)){
       if(! caml_string_notequal(tag_459, cst_grammar)) break b;
       if(caml_string_notequal(tag_459, cst_usage$0)) break a;
      }
      var sexp_args_460 = _dd_[2];
      if(sexp_args_460 && ! sexp_args_460[2]){
       var
        arg0_461 = sexp_args_460[1],
        res0_462 = caml_call1(Base[201], arg0_461);
       return [0, res0_462];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_456,
               tag_459,
               sexp_458);
     }
     var sexp_args_465 = _dd_[2];
     if(sexp_args_465 && ! sexp_args_465[2]){
      var
       arg0_466 = sexp_args_465[1],
       res0_467 = caml_call1(t_of_sexp$16, arg0_466);
      return [1, res0_467];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_456,
              tag_459,
              sexp_458);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_456, sexp_458);
   }
   function sexp_of_t$16(param){
    if(0 === param[0]){
     var arg0_468 = param[1], res0_469 = caml_call1(Base[202], arg0_468);
     return [1, [0, _aq_, [0, res0_469, 0]]];
    }
    var arg0_470 = param[1], res0_471 = sexp_of_t$15(arg0_470);
    return [1, [0, _ar_, [0, res0_471, 0]]];
   }
   function compare$9(a_472, b_473){
    if(a_472 === b_473) return 0;
    var n = caml_call2(Base[98], a_472[1], b_473[1]);
    return 0 === n ? caml_call2(Base[98], a_472[2], b_473[2]) : n;
   }
   var acc = 0, enumerate_478 = enumerate_474, enumerate_479 = enumerate_475;
   for(;;){
    if(! enumerate_479) break;
    if(enumerate_478)
     var
      enumerate_477 = enumerate_479[1],
      enumerate_480 = enumerate_478[2],
      enumerate_476 = enumerate_478[1],
      acc$0 = [0, [0, enumerate_476, enumerate_477], acc],
      acc = acc$0,
      enumerate_478 = enumerate_480;
    else
     var
      enumerate_480$0 = enumerate_479[2],
      enumerate_478 = enumerate_474,
      enumerate_479 = enumerate_480$0;
   }
   var all = caml_call1(Stdlib_List[10], acc);
   function sexp_of_t$17(param){
    var
     at_most_once_484 = param[2],
     at_least_once_482 = param[1],
     arg_485 = caml_call1(Base[105], at_most_once_484),
     bnds_481 = [0, [1, [0, _as_, [0, arg_485, 0]]], 0],
     arg_483 = caml_call1(Base[105], at_least_once_482),
     bnds_481$0 = [0, [1, [0, _at_, [0, arg_483, 0]]], bnds_481];
    return [1, bnds_481$0];
   }
   function to_help_string(t, flag_name){
    var
     at_most_once = t[2],
     at_least_once = t[1],
     description =
       at_least_once
        ? flag_name
        : caml_call2
          (Base_String[68],
           0,
           [0,
            maybe_missing_prefix,
            [0, flag_name, [0, maybe_missing_suffix, 0]]]);
    return at_most_once
            ? description
            : caml_call2
              (Base_String[68],
               0,
               [0, description, [0, maybe_more_suffix, 0]]);
   }
   function of_help_string(name){
    var match = caml_call2(Base_String[116], name, maybe_more_suffix);
    if(match)
     var name$0 = match[1], name$1 = name$0, at_most_once = 0;
    else
     var name$1 = name, at_most_once = 1;
    var _c__ = Base_String[116];
    function _c$_(_db_){return caml_call2(_c__, _db_, maybe_missing_suffix);}
    var
     _da_ = caml_call2(Base_String[117], name$1, maybe_missing_prefix),
     match$0 = caml_call2(Base_Option[22], _da_, _c$_);
    if(match$0)
     var name$2 = match$0[1], name$3 = name$2, at_least_once = 0;
    else
     var name$3 = name$1, at_least_once = 1;
    return [0, [0, at_least_once, at_most_once], name$3];
   }
   if(typeof Ppx_inline_test_lib[3] !== "number"){
    var
     Ppx_expect_test_block =
       caml_call1(Ppx_expect_runtime_Test_block[1], Expect_test_config),
     _a0_ =
       function(param){
        function _c4_(x_486){
         var
          s = to_help_string(x_486, flag_name$0),
          _c6_ = [0, caml_call1(Sexplib0_Sexp_conv[7], s), 0],
          _c7_ = [1, [0, sexp_of_t$17(x_486), _c6_]];
         caml_call2(Command_Import[3], 0, _c7_);
         var
          match = of_help_string(s),
          flag_name = match[2],
          x_487 = match[1],
          _c8_ = 0 === compare$9(x_486, x_487) ? 1 : 0;
         if(! _c8_)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _a2_], 1);
         var
          _c9_ = 0 === caml_call2(Base[195], flag_name$0, flag_name) ? 1 : 0;
         if(_c9_) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a1_], 1);
        }
        caml_call2(Base_List[19], all, _c4_);
        var _c5_ = caml_call1(Ppx_expect_runtime_Types[4][1], 0);
        return caml_call1(Ppx_expect_test_block[2], _c5_);
       },
     _a5_ =
       caml_call3
        (Ppx_expect_runtime_Test_node[1][1],
         [0, Ppx_expect_runtime_Types[1][1]],
         _a4_,
         _a3_),
     _a6_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 0), _a5_], 0],
     _a8_ = caml_call1(Ppx_expect_runtime_Types[4][1], 2),
     _a9_ = caml_call1(Ppx_expect_runtime_Types[4][1], 1);
    caml_call14
     (Ppx_expect_test_block[3],
      cst_command_src_shape_ml,
      408,
      _ba_,
      _a$_,
      _a__,
      [0, Ppx_expect_runtime_Types[1][1]],
      0,
      _a9_,
      _a8_,
      _a7_,
      0,
      Inline_test_config,
      _a6_,
      _a0_);
   }
   function compare$10(a_494, b_495){
    if(a_494 === b_495) return 0;
    var n = caml_call2(Base[195], a_494[1], b_495[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Base[195], a_494[2], b_495[2]);
    if(0 !== n$0) return n$0;
    var _c1_ = b_495[3], _c2_ = a_494[3];
    function _c3_(a_496, b_497){return caml_call2(Base[195], a_496, b_497);}
    return caml_call3(Base[159], _c3_, _c2_, _c1_);
   }
   function aliases(r){return r[3];}
   function doc(r){return r[2];}
   function name(r){return r[1];}
   function t_of_sexp$18(x_500){
    function _cW_(param){
     var
      _c0_ = param[2],
      aliases = _c0_[2][1],
      doc = _c0_[1],
      name = param[1];
     return [0, name, doc, aliases];
    }
    var _cX_ = 0;
    function _cY_(param){
     return caml_string_notequal(param, cst_aliases$1)
             ? caml_string_notequal
                (param, cst_doc$1)
               ? caml_string_notequal(param, cst_name$1) ? -1 : 0
               : 1
             : 2;
    }
    var _cZ_ = [0, cst_aliases$0, 1, caml_call1(Base[164], Base[201]), 0];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_499,
             [0, cst_name$0, 1, Base[201], [0, cst_doc$0, 1, Base[201], _cZ_]],
             _cY_,
             _cX_,
             _cW_,
             x_500);
   }
   function sexp_of_t$18(param){
    var
     aliases_506 = param[3],
     doc_504 = param[2],
     name_502 = param[1],
     arg_507 = caml_call2(Base[165], Base[202], aliases_506),
     bnds_501 = [0, [1, [0, _au_, [0, arg_507, 0]]], 0],
     arg_505 = caml_call1(Base[202], doc_504),
     bnds_501$0 = [0, [1, [0, _av_, [0, arg_505, 0]]], bnds_501],
     arg_503 = caml_call1(Base[202], name_502),
     bnds_501$1 = [0, [1, [0, _aw_, [0, arg_503, 0]]], bnds_501$0];
    return [1, bnds_501$1];
   }
   function parse_name(t){
    var
     match = of_help_string(t[1]),
     flag_name = match[2],
     num_occurrences = match[1],
     match$0 = caml_call2(Base_String[102], flag_name, 32);
    if(match$0){
     var _cT_ = match$0[2], flag_name$0 = match$0[1];
     if(! _cT_) return [0, [0, num_occurrences, 0, flag_name$0]];
     if(! _cT_[2]) return [0, [0, num_occurrences, 1, flag_name$0]];
    }
    var
     _cU_ = [0, caml_call1(Sexplib0_Sexp_conv[7], flag_name), 0],
     _cV_ =
       [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Unable_to_parse), _cU_]];
    return [1, caml_call1(Base_Error[20], _cV_)];
   }
   function flag_name(t){
    function _cR_(param){var flag_name = param[3]; return flag_name;}
    var _cS_ = parse_name(t);
    return caml_call2(Base_Or_error[47], _cS_, _cR_);
   }
   function num_occurrences(t){
    function _cP_(param){
     var num_occurrences = param[1];
     return num_occurrences;
    }
    var _cQ_ = parse_name(t);
    return caml_call2(Base_Or_error[47], _cQ_, _cP_);
   }
   function requires_arg(t){
    function _cN_(param){var requires_arg = param[2]; return requires_arg;}
    var _cO_ = parse_name(t);
    return caml_call2(Base_Or_error[47], _cO_, _cN_);
   }
   function help_screen_compare(a, b){
    return caml_string_notequal(b, cst_help)
            ? caml_string_notequal
               (a, cst_help)
              ? caml_string_notequal
                 (b, cst_version)
                ? caml_string_notequal
                   (a, cst_version)
                  ? caml_string_notequal
                     (b, cst_build_info)
                    ? caml_string_notequal
                       (a, cst_build_info)
                      ? caml_string_notequal
                         (b, cst_help$0)
                        ? caml_string_notequal
                           (a, cst_help$0)
                          ? caml_string_notequal
                             (b, cst_version$0)
                            ? caml_string_notequal(a, cst_version$0) ? 0 : 1
                            : -1
                          : 1
                        : -1
                      : 1
                    : -1
                  : 1
                : -1
              : 1
            : -1;
   }
   function sort(t){
    function _cM_(a, b){return help_screen_compare(a[1], b[1]);}
    return caml_call2(Base_List[84], t, _cM_);
   }
   function word_wrap_and_strip(text, width){
    var chunks = caml_call2(Base_String[102], text, 10);
    function _cF_(text){
     function _cG_(word){return 1 - caml_call1(Base_String[14], word);}
     var
      _cH_ = caml_call2(Base_String[102], text, 32),
      words = caml_call2(Base_List[12], _cH_, _cG_);
     function _cI_(acc, word){
      if(acc)
       var
        match = acc[1],
        line = match[2],
        lines = match[1],
        _cJ_ = caml_call2(Base[241], cst$1, word),
        line_and_word = caml_call2(Base[241], line, _cJ_),
        _cK_ =
          caml_ml_string_length(line_and_word) <= width
           ? [0, lines, line_and_word]
           : [0, [0, line, lines], word],
        _cL_ = _cK_;
      else
       var _cL_ = [0, 0, word];
      return [0, _cL_];
     }
     var match = caml_call3(Base_List[20], words, 0, _cI_);
     if(! match) return 0;
     var match$0 = match[1], line = match$0[2], lines = match$0[1];
     return caml_call1(Base_List[63], [0, line, lines]);
    }
    return caml_call2(Base_List[14], chunks, _cF_);
   }
   function spaces_string(width){
    return caml_call2(Base_String[66], width, 32);
   }
   function pad_spaces_to_suffix(x, width){
    var
     slack = width - caml_ml_string_length(x) | 0,
     _cE_ = spaces_string(slack);
    return caml_call2(Base[241], x, _cE_);
   }
   function indent_and_newline(x){
    return caml_call1(Base_List[11], [0, [0, indentation, 0], [0, x, _ax_]]);
   }
   var
    lhs_pad = spaces_string(29),
    dot_indentation_offset = 27,
    _ay_ = Base_List[53];
   function _az_(v){return indent_and_newline([0, lhs_pad, [0, v, 0]]);}
   function to_string(t){
    function _cB_(t){
     var
      flag = t[1],
      flag_name_with_aliases =
        caml_call2(Base_String[68], _aA_, [0, flag, t[3]]),
      documentation = t[2],
      flag_width = 2 + caml_ml_string_length(flag_name_with_aliases) | 0,
      flag_on_its_own_line =
        29 <= flag_width
         ? indent_and_newline([0, flag_name_with_aliases, 0])
         : indent_and_newline
           ([0,
             pad_spaces_to_suffix
              (flag_name_with_aliases, dot_indentation_offset),
             [0, spacing_dot, 0]]),
      wrapped_documentation = word_wrap_and_strip(documentation, 49);
     if(wrapped_documentation)
      var
       doc_wrapped_rest_lines = wrapped_documentation[2],
       doc_wrapped_first_line = wrapped_documentation[1],
       wrapped_doc_lines = caml_call2(_ay_, doc_wrapped_rest_lines, _az_),
       prefix_doc_wrapped_first_line_ =
         function(x){
          return indent_and_newline
                  ([0,
                    pad_spaces_to_suffix(x, dot_indentation_offset),
                    [0, spacing_dot, [0, doc_wrapped_first_line, 0]]]);
         },
       _cD_ =
         27 <= caml_ml_string_length(flag_name_with_aliases)
          ? [0,
            flag_on_its_own_line,
            [0, prefix_doc_wrapped_first_line_(cst$2), wrapped_doc_lines]]
          : [0,
            prefix_doc_wrapped_first_line_(flag_name_with_aliases),
            wrapped_doc_lines];
     else
      var _cD_ = [0, flag_on_its_own_line, 0];
     return caml_call1(Base_List[11], _cD_);
    }
    var _cC_ = caml_call2(Base_List[14], t, _cB_);
    return caml_call2(Base_String[68], 0, _cC_);
   }
   function to_string$0(param){return param ? cst_flag : cst_subcommand;}
   var Key_type = [0, to_string$0];
   function lookup_expand(alist, prefix, key_type){
    var is_dash = caml_call1(Base_Char[16], 45);
    if(caml_call2(Base_String[20], prefix, is_dash))
     var
      _ct_ =
        function(param){
         var data = param[2][1], key = param[1];
         return [0, key, [0, data, -461087063]];
        },
      alist$0 = caml_call2(Base_List[53], alist, _ct_);
    else
     var alist$0 = alist;
    function _cu_(param){
     var key = param[1];
     return -461087063 <= param[2][2]
             ? caml_call2(Base_String[47], key, prefix)
             : caml_call2(Base_String[97], key, prefix);
    }
    var matches = caml_call2(Base_List[12], alist$0, _cu_);
    if(! matches){
     var
      _cA_ =
        [0,
         [11,
          cst_unknown,
          [24,
           _aF_,
           function(param, custom_printf_508){
            return caml_call1(Key_type[1], custom_printf_508);
           },
           _aE_]],
         cst_unknown_Key_type_s];
     return [1, caml_call3(Command_Import[7], _cA_, key_type, prefix)];
    }
    if(! matches[2]){
     var _cz_ = matches[1], data$0 = _cz_[2][1], key$0 = _cz_[1];
     return [0, [0, key$0, data$0]];
    }
    function _cv_(param){
     var key = param[1];
     return caml_call2(Base_String[47], key, prefix);
    }
    var match = caml_call2(Base_List[27], matches, _cv_);
    if(match){
     var _cw_ = match[1], data = _cw_[2][1], key = _cw_[1];
     return [0, [0, key, data]];
    }
    var
     matching_keys = caml_call2(Base_List[53], matches, Base[242]),
     _cx_ = caml_call2(Base_String[68], _aB_, matching_keys),
     _cy_ =
       [0,
        [24,
         _aD_,
         function(param, custom_printf_509){
          return caml_call1(Key_type[1], custom_printf_509);
         },
         _aC_],
        cst_Key_type_s_is_an_ambiguous];
    return [1, caml_call4(Command_Import[7], _cy_, key_type, prefix, _cx_)];
   }
   function compare$11(a_510, b_511){
    if(a_510 === b_511) return 0;
    var n = caml_call2(Base[195], a_510[1], b_511[1]);
    if(0 !== n) return n;
    var _cn_ = b_511[2], _co_ = a_510[2];
    function _cp_(a_512, b_513){return caml_call2(Base[195], a_512, b_513);}
    var n$0 = caml_call3(Base[178], _cp_, _co_, _cn_);
    if(0 !== n$0) return n$0;
    var n$1 = compare$8(a_510[3], b_511[3]);
    if(0 !== n$1) return n$1;
    var _cq_ = b_511[4], _cr_ = a_510[4];
    function _cs_(a_514, b_515){return compare$10(a_514, b_515);}
    return caml_call3(Base[159], _cs_, _cr_, _cq_);
   }
   function flags(r){return r[4];}
   function anons(r){return r[3];}
   function readme(r){return r[2];}
   function summary(r){return r[1];}
   function t_of_sexp$19(x_518){
    function _ch_(param){
     var
      _cl_ = param[2],
      _cm_ = _cl_[2],
      flags = _cm_[2][1],
      anons = _cm_[1],
      readme = _cl_[1],
      summary = param[1];
     return [0, summary, readme, anons, flags];
    }
    var _ci_ = 0;
    function _cj_(param){
     return caml_string_notequal(param, cst_anons$1)
             ? caml_string_notequal
                (param, cst_flags$2)
               ? caml_string_notequal
                  (param, cst_readme$9)
                 ? caml_string_notequal(param, cst_summary$9) ? -1 : 0
                 : 1
               : 3
             : 2;
    }
    var
     _ck_ =
       [0,
        cst_anons$0,
        1,
        t_of_sexp$17,
        [0, cst_flags$1, 1, caml_call1(Base[164], t_of_sexp$18), 0]];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_517,
             [0,
              cst_summary$6,
              1,
              Base[201],
              [0, cst_readme$6, 5, Base[201], _ck_]],
             _cj_,
             _ci_,
             _ch_,
             x_518);
   }
   function sexp_of_t$19(param){
    var
     flags_528 = param[4],
     anons_526 = param[3],
     readme_522 = param[2],
     summary_520 = param[1],
     arg_529 = caml_call2(Base[165], sexp_of_t$18, flags_528),
     bnds_519 = [0, [1, [0, _aG_, [0, arg_529, 0]]], 0],
     arg_527 = sexp_of_t$16(anons_526),
     bnds_519$0 = [0, [1, [0, _aH_, [0, arg_527, 0]]], bnds_519];
    if(readme_522)
     var
      v_523 = readme_522[1],
      arg_525 = caml_call1(Base[202], v_523),
      bnd_524 = [1, [0, _aI_, [0, arg_525, 0]]],
      bnds_519$1 = [0, bnd_524, bnds_519$0];
    else
     var bnds_519$1 = bnds_519$0;
    var
     arg_521 = caml_call1(Base[202], summary_520),
     bnds_519$2 = [0, [1, [0, _aJ_, [0, arg_521, 0]]], bnds_519$1];
    return [1, bnds_519$2];
   }
   function find_flag(t, prefix){
    if(caml_call2(Base_String[97], prefix, cst$3)){
     var
      _b6_ =
        function(choices){
         var
          _cd_ = Base[243],
          _ce_ = Base_Error[14],
          _cf_ = lookup_expand(caml_call1(Base_List[11], choices), prefix, 1),
          _cg_ = caml_call2(Base_Result[34], _cf_, _ce_);
         return caml_call2(Base_Or_error[47], _cg_, _cd_);
        },
      _b7_ =
        function(flag_info){
         function _ca_(flag_name){
          function _cc_(key){return [0, key, [0, flag_info, -481604174]];}
          return [0,
                  caml_call2
                   (Base_List[53], [0, flag_name, flag_info[3]], _cc_)];
         }
         var _cb_ = flag_name(flag_info);
         return caml_call2(Base_Or_error[28][4][2], _cb_, _ca_);
        },
      _b8_ = caml_call2(Base_List[53], t[4], _b7_),
      _b9_ = caml_call1(Base_Or_error[50], _b8_);
     return caml_call2(Base_Or_error[28][4][2], _b9_, _b6_);
    }
    var
     _b__ = [0, caml_call1(Sexplib0_Sexp_conv[7], prefix), 0],
     _b$_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Flags_must_begin_with),
         _b__]];
    return [1, caml_call1(Base_Error[20], _b$_)];
   }
   function get_usage(t){
    var match = t[3];
    if(0 === match[0]){var usage$0 = match[1]; return usage$0;}
    var grammar = match[1];
    return usage(grammar);
   }
   function compare$12(cmp_a, a_532, b_533){
    if(a_532 === b_533) return 0;
    var n = caml_call2(Base[195], a_532[1], b_533[1]);
    if(0 !== n) return n;
    var _bZ_ = b_533[2], _b0_ = a_532[2];
    function _b1_(a_534, b_535){return caml_call2(Base[195], a_534, b_535);}
    var n$0 = caml_call3(Base[178], _b1_, _b0_, _bZ_);
    if(0 !== n$0) return n$0;
    var _b2_ = b_533[3], _b3_ = a_532[3];
    function _b4_(a_536, b_537){
     function _b5_(a_538, b_539){
      var
       t_541 = a_538[2],
       t_540 = a_538[1],
       t_543 = b_539[2],
       t_542 = b_539[1],
       n = caml_call2(Base[195], t_540, t_542);
      return 0 === n ? caml_call2(cmp_a, t_541, t_543) : n;
     }
     return caml_call3(Base_List[1], _b5_, a_536, b_537);
    }
    return caml_call3(Base_Lazy[1], _b4_, _b3_, _b2_);
   }
   function subcommands(r){return r[3];}
   function readme$0(r){return r[2];}
   function summary$0(r){return r[1];}
   function t_of_sexp$20(of_a_544, x_552){
    function _bP_(param){
     var
      _bY_ = param[2],
      subcommands = _bY_[2][1],
      readme = _bY_[1],
      summary = param[1];
     return [0, summary, readme, subcommands];
    }
    var _bQ_ = 0;
    function _bR_(param){
     return caml_string_notequal(param, cst_readme$9)
             ? caml_string_notequal
                (param, cst_subcommands$2)
               ? caml_string_notequal(param, cst_summary$9) ? -1 : 0
               : 2
             : 1;
    }
    var _bS_ = 0;
    function _bT_(sexp_551){
     if(1 === sexp_551[0]){
      var _bW_ = sexp_551[1];
      if(_bW_){
       var _bX_ = _bW_[2];
       if(_bX_ && ! _bX_[2]){
        var
         arg1_548 = _bX_[1],
         arg0_547 = _bW_[1],
         res0_549 = caml_call1(Base[201], arg0_547),
         res1_550 = caml_call1(of_a_544, arg1_548);
        return [0, res0_549, res1_550];
       }
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4], error_source_546, 2, sexp_551);
    }
    var
     _bU_ = caml_call1(Base_List[5], _bT_),
     _bV_ = [0, cst_subcommands$1, 1, caml_call1(Base_Lazy[7], _bU_), _bS_];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_546,
             [0,
              cst_summary$7,
              1,
              Base[201],
              [0, cst_readme$7, 5, Base[201], _bV_]],
             _bR_,
             _bQ_,
             _bP_,
             x_552);
   }
   function sexp_of_t$20(of_a_553, param){
    var
     subcommands_561 = param[3],
     readme_557 = param[2],
     summary_555 = param[1],
     bnds_554 = 0;
    function _bN_(param){
     var
      arg1_564 = param[2],
      arg0_563 = param[1],
      res0_565 = caml_call1(Base[202], arg0_563),
      res1_566 = caml_call1(of_a_553, arg1_564);
     return [1, [0, res0_565, [0, res1_566, 0]]];
    }
    var
     _bO_ = caml_call1(Base_List[6], _bN_),
     arg_562 = caml_call2(Base_Lazy[8], _bO_, subcommands_561),
     bnds_554$0 = [0, [1, [0, _aK_, [0, arg_562, 0]]], bnds_554];
    if(readme_557)
     var
      v_558 = readme_557[1],
      arg_560 = caml_call1(Base[202], v_558),
      bnd_559 = [1, [0, _aL_, [0, arg_560, 0]]],
      bnds_554$1 = [0, bnd_559, bnds_554$0];
    else
     var bnds_554$1 = bnds_554$0;
    var
     arg_556 = caml_call1(Base[202], summary_555),
     bnds_554$2 = [0, [1, [0, _aM_, [0, arg_556, 0]]], bnds_554$1];
    return [1, bnds_554$2];
   }
   function find_subcommand(t, prefix){
    if(caml_call2(Base_String[97], prefix, cst$4)){
     var
      _bD_ = [0, caml_call1(Sexplib0_Sexp_conv[7], prefix), 0],
      _bE_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Subcommands_must_not_begin),
          _bD_]];
     return [1, caml_call1(Base_Error[20], _bE_)];
    }
    function _bF_(param){
     var a = param[2], key = param[1];
     return [0, key, [0, a, -481604174]];
    }
    var _bG_ = t[3], _bH_ = caml_obj_tag(_bG_);
    a:
    if(250 === _bH_)
     var _bI_ = _bG_[1];
    else{
     if(246 !== _bH_ && 244 !== _bH_){var _bI_ = _bG_; break a;}
     var _bI_ = caml_call1(CamlinternalLazy[2], _bG_);
    }
    var
     choices = caml_call2(Base_List[53], _bI_, _bF_),
     _bJ_ = Base[243],
     _bK_ = Base_Error[14],
     _bL_ = lookup_expand(choices, prefix, 0),
     _bM_ = caml_call2(Base_Result[34], _bL_, _bK_);
    return caml_call2(Base_Or_error[47], _bM_, _bJ_);
   }
   function compare$13(a_567, b_568){
    if(a_567 === b_568) return 0;
    var n = caml_call2(Base[195], a_567[1], b_568[1]);
    if(0 !== n) return n;
    var _bx_ = b_568[2], _by_ = a_567[2];
    function _bz_(a_569, b_570){return caml_call2(Base[195], a_569, b_570);}
    var n$0 = caml_call3(Base[178], _bz_, _by_, _bx_);
    if(0 !== n$0) return n$0;
    var n$1 = caml_call2(Base[195], a_567[3], b_568[3]);
    if(0 !== n$1) return n$1;
    var n$2 = caml_call2(Base[195], a_567[4], b_568[4]);
    if(0 !== n$2) return n$2;
    var _bA_ = b_568[5], _bB_ = a_567[5];
    function _bC_(a_571, b_572){return caml_call2(Base[195], a_571, b_572);}
    return caml_call3(Base[159], _bC_, _bB_, _bA_);
   }
   function t_of_sexp$21(x_575){
    function _bq_(param){
     var
      _bu_ = param[2],
      _bv_ = _bu_[2],
      _bw_ = _bv_[2],
      child_subcommand = _bw_[2][1],
      path_to_exe = _bw_[1],
      working_dir = _bv_[1],
      readme = _bu_[1],
      summary = param[1];
     return [0, summary, readme, working_dir, path_to_exe, child_subcommand];
    }
    var _br_ = 0;
    function _bs_(param){
     return caml_string_notequal(param, cst_child_subcommand$1)
             ? caml_string_notequal
                (param, cst_path_to_exe$3)
               ? caml_string_notequal
                  (param, cst_readme$9)
                 ? caml_string_notequal
                    (param, cst_summary$9)
                   ? caml_string_notequal(param, cst_working_dir$2) ? -1 : 2
                   : 0
                 : 1
               : 3
             : 4;
    }
    var
     _bt_ =
       [0, cst_child_subcommand$0, 1, caml_call1(Base[164], Base[201]), 0];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_574,
             [0,
              cst_summary$8,
              1,
              Base[201],
              [0,
               cst_readme$8,
               5,
               Base[201],
               [0,
                cst_working_dir$1,
                1,
                Base[201],
                [0, cst_path_to_exe$2, 1, Base[201], _bt_]]]],
             _bs_,
             _br_,
             _bq_,
             x_575);
   }
   function sexp_of_t$21(param){
    var
     child_subcommand_587 = param[5],
     path_to_exe_585 = param[4],
     working_dir_583 = param[3],
     readme_579 = param[2],
     summary_577 = param[1],
     arg_588 = caml_call2(Base[165], Base[202], child_subcommand_587),
     bnds_576 = [0, [1, [0, _aN_, [0, arg_588, 0]]], 0],
     arg_586 = caml_call1(Base[202], path_to_exe_585),
     bnds_576$0 = [0, [1, [0, _aO_, [0, arg_586, 0]]], bnds_576],
     arg_584 = caml_call1(Base[202], working_dir_583),
     bnds_576$1 = [0, [1, [0, _aP_, [0, arg_584, 0]]], bnds_576$0];
    if(readme_579)
     var
      v_580 = readme_579[1],
      arg_582 = caml_call1(Base[202], v_580),
      bnd_581 = [1, [0, _aQ_, [0, arg_582, 0]]],
      bnds_576$2 = [0, bnd_581, bnds_576$1];
    else
     var bnds_576$2 = bnds_576$1;
    var
     arg_578 = caml_call1(Base[202], summary_577),
     bnds_576$3 = [0, [1, [0, _aR_, [0, arg_578, 0]]], bnds_576$2];
    return [1, bnds_576$3];
   }
   function compare$14(a_589, b_590){
    var a_589$0 = a_589, b_590$0 = b_590;
    for(;;){
     if(a_589$0 === b_590$0) return 0;
     switch(a_589$0[0]){
       case 0:
        var a_591 = a_589$0[1];
        if(0 !== b_590$0[0]) return -1;
        var b_592 = b_590$0[1];
        return compare$11(a_591, b_592);
       case 1:
        var a_593 = a_589$0[1];
        switch(b_590$0[0]){
          case 0: break;
          case 1:
           var b_594 = b_590$0[1];
           return compare$12
                   (function(a_595, b_596){return compare$14(a_595, b_596);},
                    a_593,
                    b_594);
          default: return -1;
        }
        break;
       default:
        var a_599 = a_589$0[2], a_597 = a_589$0[1];
        switch(b_590$0[0]){
          case 0: break;
          case 1:
           return 1;
          default:
           var
            b_600 = b_590$0[2],
            b_598 = b_590$0[1],
            n = compare$13(a_597, b_598);
           if(0 !== n) return n;
           var a_589$0 = a_599, b_590$0 = b_600;
           continue;
        }
     }
     return 1;
    }
   }
   var t_of_sexp$22 = function _bp_(_bo_){return _bp_.fun(_bo_);};
   caml_update_dummy
    (t_of_sexp$22,
     function(sexp_605){
      a:
      {
       if(0 === sexp_605[0]){
        var _bk_ = sexp_605[1];
        b:
        if(caml_string_notequal(_bk_, cst_Basic)){
         c:
         if(caml_string_notequal(_bk_, cst_Exec)){
          if(caml_string_notequal(_bk_, cst_Group)){
           if(! caml_string_notequal(_bk_, cst_basic)) break b;
           if(! caml_string_notequal(_bk_, cst_exec)) break c;
           if(caml_string_notequal(_bk_, cst_group)) break a;
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_603, sexp_605);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_603, sexp_605);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_603, sexp_605);
       }
       var _bl_ = sexp_605[1];
       if(! _bl_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_603, sexp_605);
       var _bm_ = _bl_[1];
       if(0 !== _bm_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_603, sexp_605);
       var tag_606 = _bm_[1];
       b:
       if(caml_string_notequal(tag_606, cst_Basic)){
        c:
        if(caml_string_notequal(tag_606, cst_Exec)){
         if(caml_string_notequal(tag_606, cst_Group)){
          if(! caml_string_notequal(tag_606, cst_basic)) break b;
          if(! caml_string_notequal(tag_606, cst_exec)) break c;
          if(caml_string_notequal(tag_606, cst_group)) break a;
         }
         var sexp_args_612 = _bl_[2];
         if(sexp_args_612 && ! sexp_args_612[2]){
          var
           arg0_613 = sexp_args_612[1],
           res0_614 = t_of_sexp$20(t_of_sexp$22, arg0_613);
          return [1, res0_614];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_603,
                  tag_606,
                  sexp_605);
        }
        var sexp_args_617 = _bl_[2];
        if(sexp_args_617){
         var _bn_ = sexp_args_617[2];
         if(_bn_ && ! _bn_[2]){
          var
           arg1_619 = _bn_[1],
           arg0_618 = sexp_args_617[1],
           res0_620 = t_of_sexp$21(arg0_618),
           res1_621 = caml_call1(t_of_sexp$22, arg1_619);
          return [2, res0_620, res1_621];
         }
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_603,
                 tag_606,
                 sexp_605);
       }
       var sexp_args_607 = _bl_[2];
       if(sexp_args_607 && ! sexp_args_607[2]){
        var arg0_608 = sexp_args_607[1], res0_609 = t_of_sexp$19(arg0_608);
        return [0, res0_609];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_603,
                tag_606,
                sexp_605);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_603, sexp_605);
     });
   function sexp_of_t$22(param){
    switch(param[0]){
      case 0:
       var arg0_622 = param[1], res0_623 = sexp_of_t$19(arg0_622);
       return [1, [0, _aS_, [0, res0_623, 0]]];
      case 1:
       var
        arg0_624 = param[1],
        res0_625 = sexp_of_t$20(sexp_of_t$22, arg0_624);
       return [1, [0, _aT_, [0, res0_625, 0]]];
      default:
       var
        arg1_627 = param[2],
        arg0_626 = param[1],
        res0_628 = sexp_of_t$21(arg0_626),
        res1_629 = sexp_of_t$22(arg1_627);
       return [1, [0, _aU_, [0, res0_628, [0, res1_629, 0]]]];
    }
   }
   function expanded_subcommands(t){
    function expand(param){
     var param$0 = param;
     for(;;)
      switch(param$0[0]){
        case 0:
         return _aV_;
        case 1:
         var
          subcommands = param$0[1][3],
          _bf_ =
            function(param){
             var t = param[2], name = param[1];
             function _bi_(path){return [0, name, path];}
             var _bj_ = expand(t);
             return caml_call2(Base_List[53], _bj_, _bi_);
            },
          _bg_ = caml_obj_tag(subcommands);
         a:
         if(250 === _bg_)
          var _bh_ = subcommands[1];
         else{
          if(246 !== _bg_ && 244 !== _bg_){var _bh_ = subcommands; break a;}
          var _bh_ = caml_call1(CamlinternalLazy[2], subcommands);
         }
         return caml_call2(Base_List[14], _bh_, _bf_);
        default: var t = param$0[2], param$0 = t;
      }
    }
    var _be_ = expand(t);
    return caml_call1(Base_List[63], _be_);
   }
   function sexp_of_t$23(param){
    switch(param[0]){
      case 0:
       var arg0_630 = param[1], res0_631 = sexp_of_t$19(arg0_630);
       return [1, [0, _aW_, [0, res0_631, 0]]];
      case 1:
       var
        arg0_632 = param[1],
        res0_633 = sexp_of_t$20(sexp_of_t$23, arg0_632);
       return [1, [0, _aX_, [0, res0_633, 0]]];
      case 2:
       var arg0_634 = param[1], res0_635 = sexp_of_t$21(arg0_634);
       return [1, [0, _aY_, [0, res0_635, 0]]];
      default:
       var
        arg0_636 = param[1],
        res0_637 = caml_call2(Base_Lazy[8], sexp_of_t$23, arg0_636);
       return [1, [0, _aZ_, [0, res0_637, 0]]];
    }
   }
   var extraction_var = caml_call1(Command_Env_var[4], 1);
   function f(i, supported, param){
    return caml_call2(Base_Set[10], supported, i);
   }
   var
    init = caml_call1(Base_Set[5], [0, Base_Int[22]]),
    supported_versions = f(3, f(2, f(1, init, v1$0), v2$0), v3$0);
   function to_versioned(latest, version_to_use){
    var switcher = version_to_use - 1 | 0;
    if(2 >= switcher >>> 0)
     switch(switcher){
       case 0:
        return [0, of_latest$5(latest)];
       case 1:
        return [1, of_latest$4(latest)];
       default: return [2, latest];
     }
    var
     _bd_ =
       caml_call5
        (Base_Error[19],
         _aj_,
         0,
         cst_unsupported_version_to_use,
         version_to_use,
         Sexplib0_Sexp_conv[10]);
    return caml_call1(Base_Error[31], _bd_);
   }
   function fully_forced(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var b = param$0[1]; return [0, b];
       case 1:
        var g = param$0[1]; return [1, map(g, fully_forced)];
       case 2:
        var f = param$0[2], e = param$0[1];
        return [2, e, fully_forced(caml_call1(f, 0))];
       default:
        var thunk = param$0[1], _bc_ = caml_obj_tag(thunk);
        a:
        if(250 === _bc_)
         var param$1 = thunk[1];
        else{
         if(246 !== _bc_ && 244 !== _bc_){var param$1 = thunk; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], thunk);
        }
        var param$0 = param$1;
     }
   }
   function get_summary(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var b = param$0[1]; return b[1];
       case 1:
        var g = param$0[1]; return g[1];
       case 2:
        var e = param$0[1]; return e[1];
       default:
        var thunk = param$0[1], _bb_ = caml_obj_tag(thunk);
        a:
        if(250 === _bb_)
         var param$1 = thunk[1];
        else{
         if(246 !== _bb_ && 244 !== _bb_){var param$1 = thunk; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], thunk);
        }
        var param$0 = param$1;
     }
   }
   caml_call1(Ppx_inline_test_lib[7], cst_command);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Command_Shape);
   var
    Command_Shape =
      [0,
       [0,
        [0, compare$7, sexp_of_t$15, invariant, usage],
        compare$8,
        sexp_of_t$16],
       [0, compare$9, all, sexp_of_t$17, to_help_string],
       [0,
        compare$10,
        aliases,
        doc,
        name,
        sexp_of_t$18,
        flag_name,
        num_occurrences,
        requires_arg,
        t_of_sexp$18],
       [0, sort, to_string],
       [0,
        compare$11,
        flags,
        anons,
        readme,
        summary,
        sexp_of_t$19,
        find_flag,
        get_usage,
        t_of_sexp$19],
       [0,
        compare$12,
        subcommands,
        readme$0,
        summary$0,
        sexp_of_t$20,
        find_subcommand,
        map,
        t_of_sexp$20],
       [0, compare$13, sexp_of_t$21, t_of_sexp$21],
       [0, compare$14, sexp_of_t$22, expanded_subcommands, t_of_sexp$22],
       fully_forced,
       get_summary,
       [0,
        sexp_of_t$23,
        extraction_var,
        supported_versions,
        [0, t_of_sexp$15, sexp_of_t$14],
        of_versioned,
        to_versioned],
       228660148,
       [0,
        [0,
         [0, [0, compare$0, t_of_sexp$1, sexp_of_t$0, stable_witness]],
         [0, compare$1, t_of_sexp$2, sexp_of_t$1, stable_witness$0]],
        [0, [0, compare$2, t_of_sexp$3, sexp_of_t$2, stable_witness$1]],
        [0,
         [0, compare$3, t_of_sexp$4, sexp_of_t$3, stable_witness$2],
         [0, t_of_sexp$5, sexp_of_t$4, stable_witness$3, to_latest, of_latest]],
        [0, [0, compare$4, t_of_sexp$6, sexp_of_t$5, stable_witness$4, map]],
        [0,
         [0, compare$5, t_of_sexp$8, sexp_of_t$7, stable_witness$5],
         [0,
          t_of_sexp$9,
          sexp_of_t$8,
          stable_witness$6,
          to_latest$2,
          of_latest$2],
         [0,
          t_of_sexp$10,
          sexp_of_t$9,
          stable_witness$7,
          to_latest$3,
          of_latest$3]],
        [0, [0, compare$6, t_of_sexp$11, sexp_of_t$10, stable_witness$8]]],
       [0,
        Key_type,
        abs_path,
        help_screen_compare,
        lookup_expand,
        word_wrap_and_strip]];
   runtime.caml_register_global(455, Command_Shape, cst_Command_Shape$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Command__Command_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Command_Command_intf = "Command__Command_intf",
    cst_command = "command";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Command_Command_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_command);
   caml_call1(Ppx_expect_runtime[1][1], "command/src/command_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_command, "command_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_command);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Command_Command_intf);
   var Command_Command_intf = [0];
   runtime.caml_register_global
    (11, Command_Command_intf, cst_Command_Command_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Command
//# unitInfo: Requires: Base, Base__Applicative, Base__Array, Base__Bool, Base__Char, Base__Comparator, Base__Error, Base__Exn, Base__Float, Base__Fn, Base__Info, Base__Int, Base__Lazy, Base__List, Base__Map, Base__Nothing, Base__Option, Base__Or_error, Base__Result, Base__Set, Base__Staged, Base__String, Base__Type_equal, CamlinternalLazy, Command__Command_intf, Command__Env_var, Command__Import, Command__Shape, Expect_test_config, Filename_base, Inline_test_config, Parsexp, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_expect_runtime__Test_block, Ppx_expect_runtime__Test_node, Ppx_expect_runtime__Types, Ppx_inline_test_lib, Ppx_module_timer_runtime, Ppx_string_runtime, Sexplib0__Sexp_conv, Sexplib__Conv, Sexplib__Sexp, Stdio, Stdio__In_channel, Stdlib, Stdlib__List, Stdlib__Sys, Univ_map
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$23 = "",
    cst$26 = "\n",
    cst$28 = "\n\n",
    cst$21 = " ",
    cst$22 = "  ",
    cst_passed_more_than_once = " passed more than once",
    cst_value = " value ",
    cst_s = "%s",
    cst$27 = ",",
    cst$24 = "-",
    cst_build_info$1 = "--build-info",
    cst_help$9 = "--help",
    cst_version$2 = "--version",
    cst_build_info$2 = "-build-info",
    cst_expand_dots$1 = "-expand-dots",
    cst_flags$1 = "-flags",
    cst_help$8 = "-help",
    cst_version$3 = "-version",
    cst$25 = ".",
    cst_Command$0 = "Command",
    cst$29 = "_",
    cst_command$0 = "command",
    cst_command_src_command_ml$3 = "command/src/command.ml",
    cst_failed_to_parse = "failed to parse ",
    cst_flag = "flag ",
    cst_flag_s_passed_more_than_on = "flag %s passed more than once",
    cst_help$7 = "help",
    cst_invalid$1 = "invalid ",
    cst_missing_required_flag$0 = "missing required flag: ",
    cst_missing_required_flag_s = "missing required flag: %s",
    cst_multiple_flags_named = "multiple flags named ",
    cst_multiple_flags_named_s = "multiple flags named %s",
    cst_same_as = 'same as "',
    cst_same_as_s = 'same as "%s"',
    cst_stderr$0 = "stderr",
    cst_stdout$0 = "stdout",
    cst_too_many_anonymous_argumen = "too many anonymous arguments",
    cst_unknown_subcommand = "unknown subcommand ",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call14
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    return (f.l >= 0 ? f.l : f.l = f.length) == 14
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
            : runtime.caml_call_gen
              (f,
               [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$19 = cst$21,
    cst$20 = cst$22,
    name = "-validate-parsing",
    cst$18 = cst$22,
    cst$17 = cst$24,
    partial = [12, 32, [2, 0, [12, 10, [10, 0]]]],
    cst$15 = cst$21,
    cst$16 = cst$25,
    opt = [0, 0],
    version_list =
      [0, "hg://some/path_0xdeadbeef", [0, "ssh://a/path_8badf00d", 0]],
    cst$9 = cst$24,
    cst$10 = cst$24,
    cst$14 = cst$23,
    cst$13 = cst$23,
    cst$12 = cst$21,
    cst$11 = cst$22,
    cst$8 = cst$22,
    cst$5 = cst$24,
    cst$6 = cst$24,
    cst$7 = cst$24,
    cst$4 = cst$25,
    cst$3 = cst$21,
    cst$2 = cst$21,
    cst$1 = cst$27,
    cst$0 = cst$23,
    cst = ")",
    enumerate_008 = [0, 0, [0, 1, 0]],
    enumerate_009 = [0, 0, [0, 1, 0]],
    any = [0, 0, 0],
    at_least_once = [0, 1, 0],
    at_most_once = [0, 0, 1],
    exactly_once = [0, 1, 1],
    Base_Lazy = global_data.Base__Lazy,
    Base = global_data.Base,
    Base_List = global_data.Base__List,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Option = global_data.Base__Option,
    Base_Error = global_data.Base__Error,
    Stdio = global_data.Stdio,
    Base_String = global_data.Base__String,
    Command_Shape = global_data.Command__Shape,
    Base_Int = global_data.Base__Int,
    Command_Import = global_data.Command__Import,
    Base_Array = global_data.Base__Array,
    Sexplib_Sexp = global_data.Sexplib__Sexp,
    Base_Set = global_data.Base__Set,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Info = global_data.Base__Info,
    Stdio_In_channel = global_data.Stdio__In_channel,
    Base_Result = global_data.Base__Result,
    Base_Staged = global_data.Base__Staged,
    Base_Nothing = global_data.Base__Nothing,
    Command_Env_var = global_data.Command__Env_var,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_Map = global_data.Base__Map,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Expect_test_config = global_data.Expect_test_config,
    Ppx_expect_runtime_Test_block = global_data.Ppx_expect_runtime__Test_block,
    Ppx_expect_runtime_Test_node = global_data.Ppx_expect_runtime__Test_node,
    Inline_test_config = global_data.Inline_test_config,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Filename_base = global_data.Filename_base,
    Univ_map = global_data.Univ_map,
    Ppx_string_runtime = global_data.Ppx_string_runtime,
    Base_Char = global_data.Base__Char,
    Base_Fn = global_data.Base__Fn,
    Base_Type_equal = global_data.Base__Type_equal,
    Stdlib_List = global_data.Stdlib__List,
    Parsexp = global_data.Parsexp,
    Base_Or_error = global_data.Base__Or_error,
    Sexplib_Conv = global_data.Sexplib__Conv,
    Base_Exn = global_data.Base__Exn,
    Stdlib = global_data.Stdlib,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Base_Applicative = global_data.Base__Applicative,
    Base_Float = global_data.Base__Float,
    Base_Bool = global_data.Base__Bool,
    Base_Comparator = global_data.Base__Comparator;
   caml_call1(Ppx_module_timer_runtime[4], cst_Command$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_command$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_command_src_command_ml$3);
   caml_call2(Ppx_inline_test_lib[6], cst_command$0, "command.ml");
   var _a_ = Ppx_inline_test_lib[3];
   a:
   {
    var
     _aZ_ = [0, "=== flags ==="],
     cst_help$5 = cst_help$7,
     _a8_ =
       [0,
        [11, "missing subcommand for command ", [2, 0, 0]],
        "missing subcommand for command %s"],
     _a9_ = [0, cst$21],
     _a6_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"],
     _a7_ = [0, [2, 0, 0], cst_s],
     cst_expand_dots$0 = cst_expand_dots$1,
     cst_flags$0 = cst_flags$1,
     cst_r = "-r",
     cst_help$6 = cst_help$8,
     cst_validate_arguments_are_par =
       " validate arguments are parsed correctly and exit immediately",
     _a5_ = [0, "--validate-parsing", 0],
     _a4_ = [0, cst$23, 0],
     cst_missing_executable_name = "missing executable name",
     cst_Couldn_t_choose_a_supporte =
       "Couldn't choose a supported help output version for Command.exec from the given supported versions.",
     _a3_ = [0, [0, cst_command_src_command_ml$3, 3102, 96602, 96616]],
     _a2_ = [0, [2, 0, 0], cst_s],
     _a1_ = [0, cst_command_src_command_ml$3, 3047, 22],
     _a0_ =
       [0,
        [11,
         cst_unknown_subcommand,
         [2, 0, [11, " for command ", [2, 0, [11, ": ", [2, 0, 0]]]]]],
        "unknown subcommand %s for command %s: %s"],
     cst_SUBCOMMAND = "SUBCOMMAND",
     cst_expand_subcommands_in_recu = " expand subcommands in recursive help",
     cst_expand_dots = cst_expand_dots$1,
     cst_show_flags_as_well_in_recu = " show flags as well in recursive help",
     cst_flags = cst_flags$1,
     cst_show_subcommands_of_subcom = " show subcommands of subcommands, etc.",
     cst_recursive = "-recursive",
     cst_explain_a_given_subcommand =
       "explain a given subcommand (perhaps recursively)",
     cst_subcommands_and_flags = "=== subcommands and flags ===",
     cst_subcommands$0 = "=== subcommands ===",
     _aY_ = [0, " SUBCOMMAND", 0],
     cst_help$4 = "[-help]",
     cst_help$3 = cst_help$7,
     _aW_ =
       [0,
        [11, "unexpected subcommand ", [3, 0, 0]],
        "unexpected subcommand %S"],
     _aX_ =
       [0, [11, cst_unknown_subcommand, [3, 0, 0]], "unknown subcommand %S"],
     _aU_ = [0, cst_stderr$0],
     _aV_ = [0, cst_stdout$0],
     cst_cannot_parse_command_shape = "cannot parse command shape",
     _aT_ = [0, "info"],
     cst_BUG_failed_to_read = "BUG failed to read",
     cst_stdout = cst_stdout$0,
     cst_stderr = cst_stderr$0,
     cst_argv_0 = "<argv_0>",
     _aR_ =
       [0, [11, "_jsautocom_", [4, 0, [0, 2, 10], 0, 0]], "_jsautocom_%010d"],
     _aS_ =
       [0,
        [11,
         "function ",
         [2,
          0,
          [11,
           " {\n  export COMP_CWORD\n  COMP_WORDS[0]=",
           [2,
            0,
            [11,
             '\n  if type readarray > /dev/null\n  then readarray -t COMPREPLY < <("${COMP_WORDS[',
             [17,
              0,
              [11,
               '}")\n  else IFS="\n" read -d "" -A COMPREPLY < <("${COMP_WORDS[',
               [17, 0, [11, '}")\n  fi\n}\ncomplete -F ', [2, 0, partial]]]]]]]]]],
        'function %s {\n  export COMP_CWORD\n  COMP_WORDS[0]=%s\n  if type readarray > /dev/null\n  then readarray -t COMPREPLY < <("${COMP_WORDS[@]}")\n  else IFS="\n" read -d "" -A COMPREPLY < <("${COMP_WORDS[@]}")\n  fi\n}\ncomplete -F %s %s\n%!'],
     _aQ_ = [0, cst_command_src_command_ml$3, 2670, 26],
     cst_some_build_info = "some build info",
     _aK_ =
       [0,
        [0,
         [0,
          "\n        hg://some/path_0xdeadbeef\n        ssh://a/path_8badf00d\n        ",
          [0, cst$23]],
         [0, 79767, 79775, 79852]]],
     _aL_ = [0, 79752, 79758, 79853],
     _aM_ = [0, "print version where multiple repos are used"],
     _aN_ = [0, 79612, 79616, 79853],
     _aO_ = [0, 79842, 79853, 79853],
     _aP_ = [0, 79612, 79616, 79853],
     cst_command_src_command_ml$0 = cst_command_src_command_ml$3,
     _aE_ =
       [0,
        [0, [0, " some build info ", [0, cst$23]], [0, 79977, 79992, 80013]]],
     _aF_ = [0, 79977, 79983, 80014],
     _aG_ = [0, "print build info"],
     _aH_ = [0, 79862, 79866, 80014],
     _aI_ = [0, 79977, 80014, 80014],
     _aJ_ = [0, 79862, 79866, 80014],
     cst_command_src_command_ml = cst_command_src_command_ml$3,
     cst_version$1 = "version",
     cst_the_version_of_this_build = "the version of this build",
     _aA_ = [0, cst_version$2, 0],
     cst_version$0 = cst_version$3,
     cst_info_about_this_build = "info about this build",
     _aB_ = [0, cst_build_info$1, 0],
     cst_build_info$0 = cst_build_info$2,
     _aC_ = [0, cst$26],
     cst_print_build_info_for_this_ = " print build info for this build",
     cst_build_info = cst_build_info$2,
     cst_print_the_version_of_this_ = " print the version of this build",
     cst_version = cst_version$3,
     cst_print_version_information = "print version information",
     cst_Path_passed_to_Absolute_mu =
       "Path passed to `Absolute must be absolute",
     cst_Path_passed_to_Relative_to =
       "Path passed to `Relative_to_me must be relative",
     _az_ =
       [0,
        [11, "multiple subcommands named ", [2, 0, 0]],
        "multiple subcommands named %s"],
     _aw_ = [0, [2, 0, 0], cst_s],
     cst_this_help_text = "this help text",
     _ax_ = [0, cst_help$9, 0],
     _ay_ = [0, "-?", 0],
     cst_help$2 = cst_help$8,
     _av_ =
       [0,
        [11, " print ", [2, 0, [11, " and exit", 0]]],
        " print %s and exit"],
     _au_ =
       [0,
        [11, "there is already a ", [2, 0, [11, " named ", [2, 0, 0]]]],
        "there is already a %s named %s"],
     cst_Arg_Tuple_is_not_supported =
       "Arg.Tuple is not supported by Command.Spec.flags_of_args_exn",
     _at_ = [0, 0],
     cst_Arg_Rest_all_is_not_suppor =
       "Arg.Rest_all is not supported by Command.Spec.flags_of_args_exn",
     cst_Arg_Expand_is_not_supporte =
       "Arg.Expand is not supported by Command.Spec.flags_of_args_exn",
     cst_No_help_for_parsing = "No help for parsing",
     _ar_ = [0, 1],
     _as_ = [0, [0, cst_command_src_command_ml$3, 2155, 65352, 65381]],
     cst_and_arg_name_expects_exact =
       "[and_arg_name] expects exactly one name, got",
     cst_missing_required_flag = "missing required flag",
     _aq_ = [0, 0],
     cst_Cannot_pass_more_than_one_ =
       "Cannot pass more than one of these: \n  %{Choice_name.list_to_string}",
     _al_ = [0, 0],
     cst_Cannot_pass_more_than_one_$0 =
       "Cannot pass more than one of these: \n  ",
     _ao_ =
       [0,
        [11,
         'Not all flags in group "',
         [2, 0, [11, '" are given: ', [2, 0, 0]]]],
        'Not all flags in group "%s" are given: %s'],
     _am_ = [0, 0],
     cst_Must_pass_one_of_these_Cho =
       "Must pass one of these:\n  %{Choice_name.list_to_string}",
     _an_ = [0, 0],
     cst_Must_pass_one_of_these = "Must pass one of these:\n  ",
     _aj_ =
       [0, [11, ' [requires: "', [2, 0, [11, '"]', 0]]], ' [requires: "%s"]'],
     _ak_ = [0, [2, 0, [2, 0, 0]], "%s%s"],
     cst_Command_Spec_choose_one_ca =
       "[Command.Spec.choose_one] called with duplicate name",
     _ap_ = [0, [0, cst_command_src_command_ml$3, 2018, 60195, 60213]],
     _ai_ = [0, "\n  "],
     _ah_ = [0, cst$27],
     _af_ = [0, cst$27],
     _ag_ = [0, cst$27],
     cst_choose_one_expects_choices =
       "[choose_one] expects choices to read command-line arguments.",
     cst_For_simplicity_Command_Spe =
       "For simplicity, [Command.Spec.choose_one] does not support names with commas.",
     _ae_ = [0, [0, cst_command_src_command_ml$3, 1936, 57337, 57357]],
     cst_optional_to_required_got_a =
       "[optional_to_required] got a [None] result",
     cst_s_default_Sexp = "%s (default: %{Sexp})",
     _ac_ = [12, 41, 0],
     _ad_ = [0, 0],
     cst_default = " (default: ",
     cst_ARG = "ARG",
     cst_help$1 = " -help\n",
     cst_For_usage_information_run = "For usage information, run",
     cst_Error_parsing_command_line = "Error parsing command line:",
     _Z_ = [0, cst$28],
     _Y_ =
       [0,
        [11, "missing argument for flag ", [2, 0, 0]],
        "missing argument for flag %s"],
     _X_ = [0, [2, 0, 0], cst_s],
     _W_ = [0, cst$26],
     cst_help = cst_help$8,
     _V_ =
       [0,
        [11, cst_multiple_flags_named, [2, 0, 0]],
        cst_multiple_flags_named_s],
     cst_invalid_Key_type_name_S = "invalid %{Key_type} name: %S",
     _R_ = [11, " name: ", [3, 0, 0]],
     _S_ = [0, 0],
     cst_invalid = cst_invalid$1,
     cst_invalid_Key_type_name_cont =
       "invalid %{Key_type} name (contains whitespace): %S",
     _T_ = [11, " name (contains whitespace): ", [3, 0, 0]],
     _U_ = [0, 0],
     cst_invalid$0 = cst_invalid$1,
     _Q_ =
       [0,
        [2,
         0,
         [12,
          32,
          [2, 0, [11, " contains an underscore. Use a dash instead.", 0]]]],
        "%s %s contains an underscore. Use a dash instead."],
     cst_WILL_NEVER_BE_PRINTED = "WILL NEVER BE PRINTED",
     cst_Empty_anonymous_argument_n = "Empty anonymous argument name provided",
     _O_ =
       [0,
        [11, "argument name ", [3, 0, [11, " has surrounding whitespace", 0]]],
        "argument name %S has surrounding whitespace"],
     _P_ =
       [0,
        60,
        [0, 62, [0, 91, [0, 93, [0, 40, [0, 41, [0, 123, [0, 125, 0]]]]]]]],
     _L_ = [0, cst_command_src_command_ml$3, 1210, 8],
     cst_BUG_asked_for_final_value_ =
       "BUG: asked for final value when doing completion",
     _M_ =
       [0,
        [11, cst_too_many_anonymous_argumen, 0],
        cst_too_many_anonymous_argumen],
     _N_ = [3, 0],
     _K_ =
       [0,
        [11, "missing anonymous argument: ", [2, 0, 0]],
        "missing anonymous argument: %s"],
     _I_ = [3, 0],
     _J_ =
       [0,
        [11,
         cst_failed_to_parse,
         [2, 0, [11, cst_value, [3, 0, [12, 10, [2, 0, 0]]]]]],
        "failed to parse %s value %S\n%s"],
     _F_ = [0, cst_command_src_command_ml$3, 959, 11],
     cst_bug_in_command_ml = "bug in command.ml",
     _H_ =
       [0,
        [11,
         "the grammar ",
         [2,
          0,
          [11,
           " for anonymous arguments is not supported because there is the possibility for arguments (",
           [2,
            0,
            [11,
             ") following a variable number of arguments (",
             [2,
              0,
              [11,
               ").  Supporting such grammars would complicate the implementation significantly.",
               0]]]]]]],
        "the grammar %s for anonymous arguments is not supported because there is the possibility for arguments (%s) following a variable number of arguments (%s).  Supporting such grammars would complicate the implementation significantly."],
     _G_ =
       [0,
        [11,
         "iteration of variable-length grammars such as ",
         [2, 0, [11, " is disallowed", 0]]],
        "iteration of variable-length grammars such as %s is disallowed"],
     _E_ = [0, cst_command_src_command_ml$3, 909, 11],
     _D_ =
       [0,
        [11, cst_missing_required_flag$0, [2, 0, 0]],
        cst_missing_required_flag_s],
     _C_ = [0, cst$29],
     _B_ = [0, cst$29],
     _A_ = [0, cst_command_src_command_ml$3, 764, 19],
     _z_ =
       [0,
        [11, cst_flag, [2, 0, [11, cst_passed_more_than_once, 0]]],
        cst_flag_s_passed_more_than_on],
     _y_ =
       [0,
        [11, cst_missing_required_flag$0, [2, 0, 0]],
        cst_missing_required_flag_s],
     _x_ = [0, cst$29],
     _w_ =
       [0,
        [11, cst_missing_required_flag$0, [2, 0, 0]],
        cst_missing_required_flag_s],
     _v_ = [0, cst$29],
     _u_ =
       [0,
        [11, cst_flag, [2, 0, [11, cst_passed_more_than_once, 0]]],
        cst_flag_s_passed_more_than_on],
     _t_ =
       [0,
        [11,
         cst_failed_to_parse,
         [2, 0, [11, cst_value, [3, 0, [11, ".\n", [2, 0, 0]]]]]],
        "failed to parse %s value %S.\n%s"],
     _r_ =
       [0,
        [11, "multiple flags or aliases named ", [2, 0, 0]],
        "multiple flags or aliases named %s"],
     _s_ =
       [0,
        [11, cst_multiple_flags_named, [2, 0, 0]],
        cst_multiple_flags_named_s],
     _q_ = [0, [11, cst_same_as, [2, 0, [12, 34, 0]]], cst_same_as_s],
     _p_ = [0, [11, cst_same_as, [2, 0, [12, 34, 0]]], cst_same_as_s],
     _o_ = [0, cst$29],
     cst_Command_Spec_Arg_type_comm =
       "Command.Spec.Arg_type.comma_separated: empty list not allowed",
     _n_ = [0, cst$27],
     cst_case_insensitive = " (case insensitive)",
     _k_ = [0, cst$27],
     _l_ =
       [0,
        [11, "valid arguments", [2, 0, [11, ": {", [2, 0, [12, 125, 0]]]]],
        "valid arguments%s: {%s}"],
     _j_ = [0, ", "],
     cst_can_be = "(can be: ",
     _i_ = [0, "duplicate_keys"],
     cst_Command_Spec_Arg_type_of_a = "Command.Spec.Arg_type.of_alist_exn",
     _g_ = [0, cst$28],
     _f_ = [0, cst$21],
     _c_ = [0, "status"],
     _d_ = [0, "command/src/command.ml.Exit_called"],
     _e_ = [0, "_none_", 0, -1],
     cst_Command_Exit_called = "Command.Exit_called",
     cst_Command_Failed_to_parse_co = "Command.Failed_to_parse_command_line",
     cst_internal_validate_parsing = "----internal-validate-parsing",
     _m_ = [0, 0],
     cst_path = "path",
     cst_args = "args",
     cst_help$0 = cst_help$7,
     cst_subcommands = "subcommands",
     cst_command_src_command_ml$1 = cst_command_src_command_ml$3,
     cst_Version_info = "Version_info",
     _a$_ =
       [0,
        [0,
         [0,
          '\n    function _jsautocom_0000012345 {\n      export COMP_CWORD\n      COMP_WORDS[0]=<argv_0>\n      if type readarray > /dev/null\n      then readarray -t COMPREPLY < <("${COMP_WORDS[@]}")\n      else IFS="\n    " read -d "" -A COMPREPLY < <("${COMP_WORDS[@]}")\n      fi\n    }\n    complete -F _jsautocom_0000012345 <argv_0>\n    ',
          [0, cst$23]],
         [0, 83018, 83022, 83348]]],
     _ba_ = [0, 83007, 83009, 83349],
     _bd_ = [0, "Demonstrate [autocomplete_function]"],
     _bg_ = [0, 82879, 82879, 83349],
     _bh_ = [0, 83342, 83349, 83349],
     _bi_ = [0, 82879, 82879, 83349],
     cst_command_src_command_ml$2 = cst_command_src_command_ml$3,
     cst_command = cst_command$0,
     cst_Command = cst_Command$0;
    if(typeof _a_ !== "number" && 545942154 <= _a_[2]){var raise_instead_of_exit = 1; break a;}
    var raise_instead_of_exit = 0;
   }
   var Exit_called = [248, cst_Command_Exit_called, caml_fresh_oo_id(0)];
   function _b_(param){
    if(param[1] !== Exit_called)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
    var
     status_002 = param[2],
     arg_003 = caml_call1(Base[136], status_002),
     bnds_001 = [0, [1, [0, _c_, [0, arg_003, 0]]], 0];
    return [1, [0, _d_, bnds_001]];
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, Exit_called, _b_);
   function exit(status){
    if(raise_instead_of_exit)
     throw caml_maybe_attach_backtrace([0, Exit_called, status], 1);
    return caml_call1(Stdlib[99], status);
   }
   function unparagraphs(xs){return caml_call2(Base_String[68], _g_, xs);}
   var
    Failed_to_parse_command_line =
      [248, cst_Command_Failed_to_parse_co, caml_fresh_oo_id(0)];
   function die(fmt){
    function _jz_(msg, param){
     throw caml_maybe_attach_backtrace
            ([0, Failed_to_parse_command_line, msg], 1);
    }
    return caml_call2(Command_Import[9], _jz_, fmt);
   }
   var
    help_screen_compare = Command_Shape[14][3],
    empty = Univ_map[4],
    set = Univ_map[7],
    mem = Univ_map[8],
    find = Univ_map[10],
    find_exn = Univ_map[11],
    update = Univ_map[16],
    With_default = Univ_map[30];
   function key_create(name){
    return caml_call2(Base_Type_equal[12][4], name, Sexplib_Conv[23]);
   }
   var
    multi_add = Univ_map[32][4],
    set_with_default = Univ_map[30][2],
    key_internal_validate_parsing =
      caml_call2
       (Base_Type_equal[12][4], cst_internal_validate_parsing, Base[220]);
   function apply(f, x){
    var _ju_ = f[2], _jv_ = _ju_ || x[2];
    function _jw_(param, _jy_){
     var err_1 = param[2];
     return [0, 696341824, err_1];
    }
    function _jx_(f, x){return caml_call1(f, x);}
    return [0, caml_call4(Base_Result[35], f[1], x[1], _jx_, _jw_), _jv_];
   }
   function introduce_missing_required_fla(t){
    var _jt_ = t[2];
    return [0, caml_call1(Base_Result[16], t[1]), _jt_];
   }
   function _h_(param, f){
    var has_arg = param[2], result = param[1];
    return [0, caml_call2(Base_Result[33], result, f), has_arg];
   }
   function return_no_arg(v){return [0, [0, v], 0];}
   function return_with_arg(v){return [0, [0, v], 1];}
   function error(has_arg, err){return [0, [1, err], has_arg];}
   var
    map = [0, -198771759, _h_],
    include = caml_call1(Base_Applicative[7], [0, return_no_arg, apply, map]),
    return$0 = include[1],
    map$0 = include[2],
    symbol = include[4],
    apply$0 = include[8],
    For_escape = [0],
    Auto_complete = [0, For_escape];
   function run_and_exit(t, env, part){
    function _jq_(completions){
     var _jr_ = Command_Import[5], _js_ = caml_call2(completions, env, part);
     return caml_call2(Base_List[19], _js_, _jr_);
    }
    caml_call2(Base_Option[37], t, _jq_);
    return exit(0);
   }
   function extra_doc(r){return r[4];}
   function parse(t, s){
    function _jp_(param){return caml_call1(t[1], s);}
    return caml_call2(Base_Or_error[31], 0, _jp_);
   }
   function create(complete, key, of_string){
    return [0, of_string, complete, key, caml_call1(Base_Lazy[24], 0)];
   }
   function map$1(key, t, f){
    var _jn_ = t[4], _jo_ = t[2];
    return [0,
            function(s){return caml_call1(f, caml_call1(t[1], s));},
            _jo_,
            key,
            _jn_];
   }
   function of_lazy(key, t){
    function parse(str){
     var _jl_ = caml_obj_tag(t);
     a:
     if(250 === _jl_)
      var _jm_ = t[1];
     else{
      if(246 !== _jl_ && 244 !== _jl_){var _jm_ = t; break a;}
      var _jm_ = caml_call1(CamlinternalLazy[2], t);
     }
     return caml_call1(_jm_[1], str);
    }
    function complete(env, part){
     var _jj_ = caml_obj_tag(t);
     a:
     if(250 === _jj_)
      var _jk_ = t[1];
     else{
      if(246 !== _jj_ && 244 !== _jj_){var _jk_ = t; break a;}
      var _jk_ = caml_call1(CamlinternalLazy[2], t);
     }
     var match = _jk_[2];
     if(! match) return 0;
     var complete = match[1];
     return caml_call2(complete, env, part);
    }
    var extra_doc$0 = caml_call2(Base_Lazy[13], t, extra_doc);
    return [0, parse, [0, complete], key, extra_doc$0];
   }
   var
    string = create(0, 0, function(_ji_){return _ji_;}),
    int$0 = create(0, 0, Base_Int[11]),
    char$0 = create(0, 0, Base_Char[8]),
    float$0 = create(0, 0, Base_Float[9]),
    sexp = create(0, 0, Parsexp[3][10]);
   function sexp_conv(complete, of_sexp){
    return create
            (complete,
             0,
             function(s){
              return caml_call1(of_sexp, caml_call1(Parsexp[3][10], s));
             });
   }
   function of_alist_exn
   (accept_unique_prefixes$0,
    opt,
    list_values_in_help$0,
    auto_complete,
    key,
    alist){
    if(opt)
     var sth$1 = opt[1], case_sensitive = sth$1;
    else
     var case_sensitive = 1;
    if(accept_unique_prefixes$0)
     var sth = accept_unique_prefixes$0[1], accept_unique_prefixes = sth;
    else
     var accept_unique_prefixes = 1;
    if(list_values_in_help$0)
     var sth$0 = list_values_in_help$0[1], list_values_in_help = sth$0;
    else
     var list_values_in_help = 1;
    function make(cmp){
     var match = caml_call2(Base_Map[8], [0, cmp[1]], alist);
     if(17724 <= match[1])
      var map = match[2], _jh_ = map;
     else
      var
       _i$_ = function(param){if(param && param[2]) return 1; return 0;},
       _ja_ = function(param){var k = param[1]; return [0, k, k];},
       _jb_ = caml_call2(Base_List[53], alist, _ja_),
       _jc_ = caml_call2(Base_Map[11], [0, cmp[1]], _jb_),
       _jd_ = caml_call2(Base_Map[60], _jc_, _i$_),
       duplicate_keys = caml_call1(Base_Map[74], _jd_),
       _je_ = caml_call1(Base[165], Base[202]),
       _jf_ =
         [0,
          [1, [0, _i_, [0, caml_call2(Base[165], _je_, duplicate_keys), 0]]],
          0],
       _jg_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Command_Spec_Arg_type_of_a),
           _jf_]],
       _jh_ = caml_call1(Base[246], _jg_);
     return [0, cmp, _jh_];
    }
    if(case_sensitive)
     var match = make([0, Base_String[59], Base_String[97]]);
    else
     var _i0_ = Base_String[75], match = make([0, _i0_[21], _i0_[24]]);
    var map = match[2], S = match[1];
    function complete(univ_map, prefix){
     if(auto_complete){
      var complete = auto_complete[1];
      return caml_call2(complete, univ_map, prefix);
     }
     function _i9_(param){
      var name = param[1];
      if(! caml_call2(S[2], name, prefix)) return 0;
      var
       suffix =
         caml_call3
          (Base_String[5], [0, caml_ml_string_length(prefix)], 0, name),
       name$0 = caml_call2(Base[241], prefix, suffix);
      return [0, name$0];
     }
     var _i__ = caml_call2(Base_Map[75], 0, map);
     return caml_call2(Base_List[13], _i__, _i9_);
    }
    var
     _iZ_ =
       [246,
        function(_i5_){
         if(! list_values_in_help) return 0;
         var
          _i6_ = caml_call1(Base_Map[73], map),
          values = caml_call2(Base_String[68], _j_, _i6_),
          _i7_ =
            [0, values, [0, caml_call1(Ppx_string_runtime[1][2], cst), 0]],
          _i8_ = [0, caml_call1(Ppx_string_runtime[1][2], cst_can_be), _i7_];
         return [0, caml_call1(Ppx_string_runtime[1][4], _i8_)];
        }];
    return [0,
            function(arg){
             var s = caml_call2(Base_Map[42], map, arg);
             a:
             if(s)
              var match$0 = s;
             else if(accept_unique_prefixes){
              var
               _i1_ =
                 function(param){
                  var name = param[1];
                  return caml_call2(S[2], name, arg);
                 },
               _i2_ = caml_call2(Base_Map[75], 0, map),
               match = caml_call2(Base_List[12], _i2_, _i1_);
              if(match && ! match[2]){
               var v = match[1][2], match$0 = [0, v];
               break a;
              }
              var match$0 = 0;
             }
             else
              var match$0 = 0;
             if(match$0){var v$0 = match$0[1]; return v$0;}
             var
              valid_arguments_extra =
                case_sensitive ? cst$0 : cst_case_insensitive,
              _i3_ = caml_call1(Base_Map[73], map),
              _i4_ = caml_call2(Base_String[68], _k_, _i3_);
             return caml_call4
                     (Command_Import[8], _l_, valid_arguments_extra, _i4_, 0);
            },
            [0, complete],
            key,
            _iZ_];
   }
   function of_map
   (accept_unique_prefixes,
    case_sensitive,
    list_values_in_help,
    auto_complete,
    key,
    map){
    return of_alist_exn
            (accept_unique_prefixes,
             case_sensitive,
             list_values_in_help,
             auto_complete,
             key,
             caml_call2(Base_Map[75], 0, map));
   }
   function enumerated
   (accept_unique_prefixes,
    case_sensitive,
    list_values_in_help,
    auto_complete,
    key,
    E){
    function _iY_(t){return [0, caml_call1(E[2], t), t];}
    return of_alist_exn
            (accept_unique_prefixes,
             case_sensitive,
             list_values_in_help,
             auto_complete,
             key,
             caml_call2(Base_List[58][4][3], E[1], _iY_));
   }
   function enumerated_sexpable
   (accept_unique_prefixes,
    case_sensitive,
    list_values_in_help,
    auto_complete,
    key,
    E){
    var all = E[1];
    function to_string(t){
     var _iX_ = caml_call1(E[2], t);
     return caml_call1(Base[85][16], _iX_);
    }
    return enumerated
            (accept_unique_prefixes,
             case_sensitive,
             list_values_in_help,
             auto_complete,
             key,
             [0, all, to_string]);
   }
   var bool = enumerated(0, 0, _m_, 0, 0, [0, Base_Bool[1], Base_Bool[9]]);
   function comma_separated(opt, key, _iJ_, _iI_, t){
    if(opt) var sth = opt[1], allow_empty = sth; else var allow_empty = 0;
    if(_iJ_)
     var sth$0 = _iJ_[1], strip_whitespace = sth$0;
    else
     var strip_whitespace = 0;
    if(_iI_)
     var sth$1 = _iI_[1], unique_values = sth$1;
    else
     var unique_values = 0;
    var
     strip =
       strip_whitespace
        ? function(str){return caml_call2(Base_String[109], 0, str);}
        : function(_iW_){return _iW_;};
    function _iK_(complete_elt, env, part){
     var
      _iO_ = caml_call2(Base_String[102], part, 44),
      match = caml_call1(Base_List[63], _iO_);
     if(match)
      var
       tl = match[2],
       hd = match[1],
       suffix = hd,
       prefixes = caml_call1(Base_List[63], tl);
     else
      var suffix = part, prefixes = 0;
     if(unique_values)
      var
       _iP_ = caml_call2(Base_List[53], prefixes, strip),
       seen_already = caml_call2(Base_Set[32], [0, Base_String[59]], _iP_),
       is_allowed =
         function(choice){
          var _iV_ = strip(choice);
          return 1 - caml_call2(Base_Set[9], seen_already, _iV_);
         };
     else
      var is_allowed = function(param){return 1;};
     function _iQ_(choice){
      var _iU_ = 1 - caml_call2(Base_String[65], choice, 44);
      return _iU_ ? is_allowed(choice) : _iU_;
     }
     var
      _iR_ = caml_call2(complete_elt, env, suffix),
      choices = caml_call2(Base_List[12], _iR_, _iQ_);
     a:
     {
      if(choices && ! choices[2]){
       var
        choice = choices[1],
        choices$0 = [0, choice, [0, caml_call2(Base[241], choice, cst$1), 0]];
       break a;
      }
      var choices$0 = choices;
     }
     function _iS_(choice){
      var _iT_ = caml_call2(Base[222], prefixes, [0, choice, 0]);
      return caml_call2(Base_String[68], _n_, _iT_);
     }
     return caml_call2(Base_List[53], choices$0, _iS_);
    }
    var complete = caml_call2(Base_Option[24], t[2], _iK_);
    function of_string(string){
     var string$0 = strip(string);
     if(caml_call1(Base_String[14], string$0))
      return allow_empty
              ? 0
              : caml_call1(Base[244], cst_Command_Spec_Arg_type_comm);
     function _iL_(str){var _iN_ = strip(str); return caml_call1(t[1], _iN_);}
     var _iM_ = caml_call2(Base_String[102], string$0, 44);
     return caml_call2(Base_List[53], _iM_, _iL_);
    }
    return create(complete, key, of_string);
   }
   var include$0 = [0, string, int$0, char$0, float$0, bool, sexp, sexp_conv];
   function auto_complete(t){
    var match = t[2];
    if(! match) return function(param, _iH_){return 0;};
    var f = match[1];
    return f;
   }
   var acc = 0, enumerate_012 = enumerate_008, enumerate_013 = enumerate_009;
   for(;;){
    if(! enumerate_013) break;
    if(enumerate_012)
     var
      enumerate_011 = enumerate_013[1],
      enumerate_014 = enumerate_012[2],
      enumerate_010 = enumerate_012[1],
      acc$0 = [0, [0, enumerate_010, enumerate_011], acc],
      acc = acc$0,
      enumerate_012 = enumerate_014;
    else
     var
      enumerate_014$0 = enumerate_013[2],
      enumerate_012 = enumerate_008,
      enumerate_013 = enumerate_014$0;
   }
   caml_call1(Stdlib_List[10], acc);
   var to_help_string = Command_Shape[2][4];
   function parse$0(action, doc){
    var match = caml_call2(Base_String[100], doc, 32);
    a:
    {
     switch(action[0]){
       case 2:
        if(match && caml_string_notequal(match[1][1], cst$23)) break;
        var doc$0 = doc, arg_doc = _o_;
        break a;
       case 3:
        if(match && caml_string_notequal(match[1][1], cst$23)) break;
        var doc$0 = doc, arg_doc = 0;
        break a;
       default: var doc$0 = doc, arg_doc = 0; break a;
     }
     var
      match$0 = match[1],
      doc$1 = match$0[2],
      arg = match$0[1],
      arg_doc$0 = [0, arg],
      doc$0 = doc$1,
      arg_doc = arg_doc$0;
    }
    return [0, arg_doc, caml_call2(Base_String[109], 0, doc$0)];
   }
   function concat(name, arg_doc){
    if(! arg_doc) return name;
    var
     arg_doc$0 = arg_doc[1],
     _iG_ = caml_call2(Base[241], cst$2, arg_doc$0);
    return caml_call2(Base[241], name, _iG_);
   }
   function wrap_if_optional(t, flag_name){
    var at_least_once = t[6][1];
    return caml_call2(to_help_string, [0, at_least_once, 1], flag_name);
   }
   function help(t){
    var doc = t[5], action = t[4], aliases = t[2], name = t[1];
    if(caml_call2(Base_String[97], doc, cst$3)){
     var
      _iB_ =
        function(x){return [0, x, caml_call2(Command_Import[7], _p_, name)];},
      _iC_ = caml_call2(Base_List[53], aliases, _iB_);
     return [0, [0, name, caml_call2(Base_String[107], 0, doc)], _iC_];
    }
    var match = parse$0(action, doc), doc$0 = match[2], arg_doc = match[1];
    function _iD_(x){
     var _iF_ = caml_call2(Command_Import[7], _q_, name);
     return [0, wrap_if_optional(t, concat(x, arg_doc)), _iF_];
    }
    var _iE_ = caml_call2(Base_List[53], aliases, _iD_);
    return [0, [0, wrap_if_optional(t, concat(name, arg_doc)), doc$0], _iE_];
   }
   function align(t){
    var
     doc = t[5],
     action = t[4],
     aliases = t[2],
     name$0 = t[1],
     match = parse$0(action, doc),
     doc$0 = match[2],
     arg_doc = match[1],
     flag_name = concat(name$0, arg_doc),
     name = caml_call2(to_help_string, t[6], flag_name);
    return [0, name, doc$0, aliases];
   }
   function create$0(flags){
    function _iu_(flag){return [0, flag[1], flag];}
    var
     _iv_ = caml_call2(Base_List[53], flags, _iu_),
     match = caml_call2(Base_Map[8], [0, Base_String[59]], _iv_);
    if(17724 <= match[1]){
     var
      map = match[2],
      _iw_ = function(x){return caml_call3(Command_Import[8], _r_, x, 0);},
      _ix_ =
        function(a_020, b_021){return caml_call2(Base[195], a_020, b_021);},
      _iy_ = function(flag){return [0, flag[1], flag[2]];},
      _iz_ = caml_call2(Base_List[14], flags, _iy_),
      _iA_ = caml_call2(Base_List[128], _iz_, _ix_);
     caml_call2(Base_Option[37], _iA_, _iw_);
     return map;
    }
    var flag = match[2];
    return caml_call3(Command_Import[8], _s_, flag, 0);
   }
   function arg_flag(name, arg_type, read, write, num_occurrences){
    var _is_ = arg_type[4];
    function update(env, arg){
     var match = parse(arg_type, arg);
     if(0 !== match[0]){
      var error = match[1], _it_ = caml_call1(Base_Error[12], error);
      return caml_call4(die(_t_), name, arg, _it_, 0);
     }
     var
      arg$0 = match[1],
      env$0 = caml_call2(write, env, arg$0),
      match$0 = arg_type[3];
     if(! match$0) return env$0;
     var key = match$0[1];
     return caml_call3(multi_add, env$0, key, arg$0);
    }
    return [0, [2, update, arg_type[2]], read, num_occurrences, _is_];
   }
   function map_flag(t, f, input){
    var
     match = caml_call1(t, input),
     extra_doc = match[4],
     num_occurrences = match[3],
     read = match[2],
     action = match[1];
    return [0,
            action,
            function(env){return caml_call2(map$0, caml_call1(read, env), f);},
            num_occurrences,
            extra_doc];
   }
   function write_option(name, key, env, arg){
    return caml_call3
            (update,
             env,
             key,
             function(param){
              return param ? caml_call2(die(_u_), name, 0) : arg;
             });
   }
   function required_value(default$0, arg_type, name, num_occurrences){
    function _iq_(param){return _v_;}
    var key = caml_call2(Base_Type_equal[12][4], name, _iq_);
    function read(env){
     var match = caml_call2(find, env, key);
     if(match){var v = match[1]; return return_with_arg(v);}
     if(default$0){var v$0 = default$0[1]; return return_no_arg(v$0);}
     var _ir_ = caml_call2(Command_Import[7], _w_, name);
     return error(0, [0, 696341824, caml_call1(Base_Error[14], _ir_)]);
    }
    function write(env, arg){return write_option(name, key, env, arg);}
    return arg_flag(name, arg_type, read, write, num_occurrences);
   }
   function required(arg_type, name){
    return required_value(0, arg_type, name, exactly_once);
   }
   function optional_with_default(default$0, arg_type, name){
    return required_value([0, default$0], arg_type, name, at_most_once);
   }
   function optional(arg_type, name){
    function _ip_(param){return _x_;}
    var key = caml_call2(Base_Type_equal[12][4], name, _ip_);
    function read(env){
     var value = caml_call2(find, env, key);
     return value ? return_with_arg(value) : return_no_arg(0);
    }
    function write(env, arg){return write_option(name, key, env, arg);}
    return arg_flag(name, arg_type, read, write, at_most_once);
   }
   function no_arg_general(is_required, key_value, deprecated_hook, name){
    var key = caml_call2(Base_Type_equal[12][4], name, Base[220]);
    function read(env){
     if(caml_call2(mem, env, key)) return return_with_arg(1);
     if(! is_required) return return_no_arg(0);
     var _io_ = caml_call2(Command_Import[7], _y_, name);
     return error(0, [0, 696341824, caml_call1(Base_Error[14], _io_)]);
    }
    function action(env){
     function _in_(env, param){
      var value = param[2], key = param[1];
      return caml_call3(set_with_default, env, key, value);
     }
     var env$0 = caml_call3(Base_Option[34], key_value, env, _in_);
     return caml_call2(mem, env$0, key)
             ? caml_call2(die(_z_), name, 0)
             : caml_call3(set, env$0, key, 0);
    }
    if(deprecated_hook)
     var
      f = deprecated_hook[1],
      action$0 =
        function(env){
         var env$0 = action(env);
         caml_call1(f, 0);
         return env$0;
        };
    else
     var action$0 = action;
    var
     _il_ = caml_call1(Base_Lazy[24], 0),
     _im_ = is_required ? exactly_once : at_most_once;
    return [0, [0, action$0], read, _im_, _il_];
   }
   function no_arg(name){return no_arg_general(0, 0, 0, name);}
   function no_arg_required(v, name){
    function _ig_(param){
     if(param) return v;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
    }
    var _ih_ = 0, _ii_ = 0, _ij_ = 1;
    return map_flag
            (function(_ik_){return no_arg_general(_ij_, _ii_, _ih_, _ik_);},
             _ig_,
             name);
   }
   function no_arg_register(key, value, name){
    return no_arg_general(0, [0, [0, key, value]], 0, name);
   }
   function no_arg_some(value){
    function _ie_(param){return param ? [0, value] : 0;}
    return function(_if_){return map_flag(no_arg, _ie_, _if_);};
   }
   function listed(arg_type, name){
    function _ia_(x_022){
     function _id_(param){return _B_;}
     return caml_call2(Base[165], _id_, x_022);
    }
    var key = caml_call3(With_default[1][1], 0, name, _ia_);
    function read(env){
     var
      _ic_ = caml_call2(With_default[3], env, key),
      value_list = caml_call1(Base_List[63], _ic_);
     return value_list ? return_with_arg(value_list) : return_no_arg(0);
    }
    function write(env, arg){
     function _ib_(list){return [0, arg, list];}
     return caml_call3(With_default[4], env, key, _ib_);
    }
    return arg_flag(name, arg_type, read, write, any);
   }
   function one_or_more_as_pair(arg_type, name){
    function _h7_(x_023){
     function _h$_(param){return _C_;}
     return caml_call2(Base[165], _h$_, x_023);
    }
    var key = caml_call3(With_default[1][1], 0, name, _h7_);
    function read(env){
     var
      _h9_ = caml_call2(With_default[3], env, key),
      match = caml_call1(Base_List[63], _h9_);
     if(match){
      var rest = match[2], first = match[1];
      return return_with_arg([0, first, rest]);
     }
     var _h__ = caml_call2(Command_Import[7], _D_, name);
     return error(0, [0, 696341824, caml_call1(Base_Error[14], _h__)]);
    }
    function write(env, arg){
     function _h8_(q){return [0, arg, q];}
     return caml_call3(With_default[4], env, key, _h8_);
    }
    return arg_flag(name, arg_type, read, write, at_least_once);
   }
   function one_or_more_as_list(arg_type){
    function _h3_(param){var xs = param[2], x = param[1]; return [0, x, xs];}
    function _h4_(_h6_){return one_or_more_as_pair(arg_type, _h6_);}
    return function(_h5_){return map_flag(_h4_, _h3_, _h5_);};
   }
   function escape_general(complete, deprecated_hook, name){
    function _h2_(x_024){return caml_call2(Base[165], Base[202], x_024);}
    var key = caml_call2(Base_Type_equal[12][4], name, _h2_);
    function action(env, cmd_line){
     return caml_call3(set, env, key, cmd_line);
    }
    function read(env){
     var value = caml_call2(find, env, key);
     return value ? return_with_arg(value) : return_no_arg(0);
    }
    if(deprecated_hook)
     var
      f = deprecated_hook[1],
      action$0 = function(env, x){caml_call1(f, x); return action(env, x);};
    else
     var action$0 = action;
    return [0,
            [3, action$0, complete],
            read,
            at_most_once,
            caml_call1(Base_Lazy[24], 0)];
   }
   function no_arg_abort(exit, name){
    var _hZ_ = caml_call1(Base_Lazy[24], 0);
    function _h0_(param){return return_no_arg(0);}
    return [0,
            [0,
             function(param){
              var _h1_ = caml_call1(exit, 0);
              return caml_call1(Base_Nothing[4], _h1_);
             }],
            _h0_,
            at_most_once,
            _hZ_];
   }
   function escape(name){return escape_general(0, 0, name);}
   function escape_with_autocomplete(complete, name){return escape_general([0, complete], 0, name);
   }
   function no_arg$0(hook, name){
    return no_arg_general(0, 0, [0, hook], name);
   }
   function escape$0(hook){
    var _hW_ = [0, hook], _hX_ = 0;
    return function(_hY_){return escape_general(_hX_, _hW_, _hY_);};
   }
   var empty$0 = 0;
   function create$1(path_to_exe){return [0, path_to_exe, 0];}
   function append(t, subcommand){return [0, subcommand, t];}
   var parts = Base_List[63];
   function parts_exe_basename(t){
    var match = caml_call1(Base_List[63], t);
    if(! match) return 0;
    var tl = match[2], hd = match[1];
    return [0, caml_call1(Filename_base[37], hd), tl];
   }
   function to_string(t){
    var xs = parts_exe_basename(t);
    return caml_call2(Base_String[68], _f_, xs);
   }
   var length = Base_List[45];
   function replace_first(t, from, to){
    var parts$2 = caml_call1(parts, t), parts$0 = parts$2, acc = 0;
    for(;;){
     if(! parts$0) return acc;
     var parts$1 = parts$0[2], hd = parts$0[1];
     if(caml_call2(Base_String[47], hd, from))
      return caml_call2(Base_List[64], parts$1, [0, to, acc]);
     var acc$0 = [0, hd, acc], parts$0 = parts$1, acc = acc$0;
    }
   }
   function to_string_dots(t){
    if(t)
     var
      init = t[2],
      last = t[1],
      _hU_ = caml_call1(Base_Fn[1], cst$4),
      _hV_ = [0, last, caml_call2(Base_List[53], init, _hU_)];
    else
     var _hV_ = 0;
    return to_string(_hV_);
   }
   var
    is_empty = Base_List[18],
    invariant = Command_Shape[1][1][3],
    usage = Command_Shape[1][1][4];
   function is_fixed_arity(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 1;
     switch(param$0[0]){
       case 0:
        return 1;
       case 1:
        return 0;
       case 2:
        return 0;
       case 3:
        var ts = param$0[1], match = caml_call1(Base_List[63], ts);
        if(! match) return caml_call1(Base[244], cst_bug_in_command_ml);
        var others = match[2], last = match[1];
        if(! caml_call2(Base_List[24], others, is_fixed_arity))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
        var param$0 = last;
        break;
       default: return 0;
     }
    }
   }
   function names(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     switch(param$0[0]){
       case 0:
        var s = param$0[1]; return [0, s, 0];
       case 1:
        var t = param$0[1], param$0 = t; break;
       case 2:
        var t$0 = param$0[1], param$0 = t$0; break;
       case 3:
        var ts = param$0[1]; return caml_call2(Base_List[14], ts, names);
       default: var s$0 = param$0[1]; return [0, s$0, 0];
     }
    }
   }
   var zero = 0;
   function concat$0(param){
    if(! param) return 0;
    var cdr = param[2], car = param[1];
    function _hQ_(param, t2){
     var acc = param[2], t1 = param[1];
     if(typeof t1 === "number")
      var t = t2;
     else{
      if(typeof t2 !== "number"){
       if(is_fixed_arity(t1)) return [0, t2, [0, t1, acc]];
       var
        _hR_ = caml_call1(usage, t1),
        _hS_ = caml_call1(usage, t2),
        _hT_ =
          caml_call1
           (usage, [3, caml_call1(Base_List[63], [0, t2, [0, t1, acc]])]);
       return caml_call5(Command_Import[8], _H_, _hT_, _hS_, _hR_, 0);
      }
      var t = t1;
     }
     return [0, t, acc];
    }
    var
     match = caml_call3(Base_List[20], cdr, [0, car, 0], _hQ_),
     cdr$0 = match[2],
     car$0 = match[1];
    return cdr$0 ? [3, caml_call1(Base_List[63], [0, car$0, cdr$0])] : car$0;
   }
   function parse_more(param, f){
    var complete = param[3], parse = param[2], name = param[1];
    function parse$0(arg, for_completion){
     var
      match = caml_call2(parse, arg, for_completion),
      update_env = match[2],
      parser = match[1];
     return [0, caml_call1(f, parser), update_env];
    }
    return [1, [0, name, parse$0, complete]];
   }
   function pack_for_completion(x){
    switch(x[0]){
      case 0:
       return 0;
      case 3:
       var ps = x[1]; return ps;
      default: return [0, [0, x], 0];
    }
   }
   function symbol$0(t_left, t_right){
    a:
    {
     switch(t_left[0]){
       case 0:
        var f = t_left[1];
        switch(t_right[0]){
          case 0:
           var x = t_right[1];
           return [0,
                   function(env){
                    var
                     f_outcome = caml_call1(f, env),
                     x_outcome = caml_call1(x, env);
                    return caml_call1(f_outcome, x_outcome);
                   }];
          case 1:
           var more = t_right[1];
           return parse_more(more, function(tr){return symbol$0(t_left, tr);});
          case 2:
           var test = t_right[1];
           return [2,
                   function(more){
                    return symbol$0(t_left, caml_call1(test, more));
                   }];
          case 3:
           break a;
          default: var tr = t_right[1], tl = t_left;
        }
        break;
       case 1:
        var more$0 = t_left[1];
        return parse_more(more$0, function(tl){return symbol$0(tl, t_right);});
       case 2:
        var test$0 = t_left[1];
        return [2,
                function(more){
                 return symbol$0(caml_call1(test$0, more), t_right);
                }];
       case 4:
        var tr = t_right, tl = t_left[1]; break;
       default: break a;
     }
     return [4, symbol$0(tl, tr)];
    }
    var
     _hO_ = pack_for_completion(t_right),
     _hP_ = pack_for_completion(t_left);
    return [3, caml_call2(Base[222], _hP_, _hO_)];
   }
   function return$1(a){return [0, function(param){return a;}];}
   function symbol_map(t, f){return symbol$0(return$1(f), t);}
   function from_env(f){
    return [0, function(env){return caml_call1(f, env);}];
   }
   function symbol_map$0(t, f){
    return symbol_map(t, function(_hN_){return caml_call2(map$0, _hN_, f);});
   }
   function symbol$1(t_left, t_right){
    return symbol$0(symbol$0(return$1(symbol), t_left), t_right);
   }
   function return$2(a){return return$1(caml_call1(return$0, a));}
   function return_with_arg$0(a){
    return [0, function(param){return return_with_arg(a);}];
   }
   function one(name, arg_type){
    return [2,
            function(more){
             if(! more)
              return [0,
                      function(param){
                       var _hM_ = caml_call2(Command_Import[7], _K_, name);
                       return error
                               (0, [0, 696341824, caml_call1(Base_Error[14], _hM_)]);
                      }];
             function parse$0(anon, for_completion){
              var match = parse(arg_type, anon);
              if(0 === match[0]){
               var
                v = match[1],
                _hI_ =
                  function(env){
                   function _hL_(env, key){
                    return caml_call3(multi_add, env, key, v);
                   }
                   return caml_call3(Base_Option[34], arg_type[3], env, _hL_);
                  };
               return [0, return_with_arg$0(v), _hI_];
              }
              var error = match[1];
              if(for_completion)
               return [0, _I_, function(_hK_){return _hK_;}];
              var _hJ_ = caml_call1(Base_Error[12], error);
              return caml_call4(die(_J_), name, anon, _hJ_, 0);
             }
             return [1, [0, name, parse$0, arg_type[2]]];
            }];
   }
   function sequence(t){
    var loop = [];
    runtime.caml_update_dummy
     (loop,
      [2,
       function(more){
        return more
                ? symbol$1
                  (symbol$1
                    (return$2(function(v, acc){return [0, v, acc];}), t),
                   loop)
                : return$2(0);
       }]);
    return loop;
   }
   function consume(t, arg, for_completion){
    var t$0 = t;
    for(;;)
     switch(t$0[0]){
       case 0:
        return caml_call1(die(_M_), 0);
       case 1:
        var
         parse = t$0[1][2],
         match = caml_call2(parse, arg, for_completion),
         update_env = match[2],
         parser = match[1];
        return [0, parser, 1, update_env];
       case 2:
        var f = t$0[1], t$1 = caml_call1(f, 1), t$0 = t$1; break;
       case 3:
        var packed = t$0[1];
        if(! packed) return [0, _N_, 1, function(_hH_){return _hH_;}];
        var
         rest = packed[2],
         t$2 = packed[1][1],
         match$0 = consume(t$2, arg, for_completion),
         update_env$0 = match$0[3],
         parse_flags = match$0[2],
         parser$0 = match$0[1],
         _hF_ = pack_for_completion(parser$0);
        return [0,
                [3, caml_call2(Base[222], _hF_, rest)],
                parse_flags,
                update_env$0];
       default:
        var t$3 = t$0[1], _hG_ = consume(t$3, arg, for_completion);
        return [0, _hG_[1], 0, _hG_[3]];
     }
   }
   function t2(t1, t2){
    var
     _hC_ = concat$0([0, t1[2], [0, t2[2], 0]]),
     _hD_ = t2[1],
     _hE_ = t1[1];
    return [0,
            symbol$1
             (symbol$1(return$2(function(a1, a2){return [0, a1, a2];}), _hE_),
              _hD_),
            _hC_];
   }
   function t3(t1, t2, t3){
    var
     _hy_ = concat$0([0, t1[2], [0, t2[2], [0, t3[2], 0]]]),
     _hz_ = t3[1],
     _hA_ = t2[1],
     _hB_ = t1[1];
    return [0,
            symbol$1
             (symbol$1
               (symbol$1
                 (return$2(function(a1, a2, a3){return [0, a1, a2, a3];}),
                  _hB_),
                _hA_),
              _hz_),
            _hy_];
   }
   function t4(t1, t2, t3, t4){
    var
     _ht_ = concat$0([0, t1[2], [0, t2[2], [0, t3[2], [0, t4[2], 0]]]]),
     _hu_ = t4[1],
     _hv_ = t3[1],
     _hw_ = t2[1],
     _hx_ = t1[1];
    return [0,
            symbol$1
             (symbol$1
               (symbol$1
                 (symbol$1
                   (return$2
                     (function(a1, a2, a3, a4){return [0, a1, a2, a3, a4];}),
                    _hx_),
                  _hw_),
                _hv_),
              _hu_),
            _ht_];
   }
   function normalize(str){
    var strlen = caml_ml_string_length(str);
    if(0 === strlen) caml_call1(Base[244], cst_Empty_anonymous_argument_n);
    var _hr_ = caml_call2(Base_String[109], 0, str);
    if(caml_call2(Base_String[50], _hr_, str))
     caml_call3(Command_Import[8], _O_, str, 0);
    var
     special_chars = caml_call2(Base_Set[32], [0, Base_Char[25]], _P_),
     _hs_ = caml_call1(Base_Set[9], special_chars),
     has_special_chars = caml_call2(Base_String[19], str, _hs_);
    return has_special_chars ? str : caml_call1(Base_String[71], str);
   }
   function symbol$2(name, arg_type){
    var name$0 = normalize(name);
    return [0, one(name$0, arg_type), [0, name$0]];
   }
   function map_anons(t, f){
    var _hq_ = t[2];
    return [0, symbol_map$0(t[1], f), _hq_];
   }
   function maybe(t){
    var t$0 = t[2], _hp_ = typeof t$0 === "number" ? 0 : [2, t$0], t$1 = t[1];
    return [0,
            [2,
             function(more){
              return more
                      ? symbol$1
                        (return_with_arg$0(function(a){return [0, a];}), t$1)
                      : return$2(0);
             }],
            _hp_];
   }
   function maybe_with_default(default$0, t){
    var t$0 = maybe(t), _hn_ = t$0[2];
    function _ho_(v){return caml_call2(Base_Option[30], v, default$0);}
    return [0, symbol_map$0(t$0[1], _ho_), _hn_];
   }
   function sequence$0(t){
    var t$0 = t[2];
    if(typeof t$0 === "number")
     var _hm_ = 0;
    else{
     if(1 - is_fixed_arity(t$0)){
      var _hl_ = caml_call1(usage, t$0);
      caml_call3(Command_Import[8], _G_, _hl_, 0);
     }
     var _hm_ = [1, t$0];
    }
    return [0, sequence(t[1]), _hm_];
   }
   function non_empty_sequence_as_pair(t){return t2(t, sequence$0(t));}
   function non_empty_sequence_as_list(t){
    var t$0 = non_empty_sequence_as_pair(t), _hj_ = t$0[2];
    function _hk_(param){var xs = param[2], x = param[1]; return [0, x, xs];}
    return [0, symbol_map$0(t$0[1], _hk_), _hj_];
   }
   function ad_hoc(usage_arg){
    return [0,
            sequence(one(cst_WILL_NEVER_BE_PRINTED, include$0[1])),
            [4, usage_arg]];
   }
   function compare(a_025, b_026){
    var a_025$0 = a_025, b_026$0 = b_026;
    for(;;){
     if(a_025$0 === b_026$0) return 0;
     if(typeof a_025$0 === "number")
      return typeof b_026$0 === "number" ? 0 : -1;
     if(0 === a_025$0[0]){
      var a_029 = a_025$0[2], a_027 = a_025$0[1];
      if(typeof b_026$0 !== "number"){
       if(0 !== b_026$0[0]) return -1;
       var
        b_030 = b_026$0[2],
        b_028 = b_026$0[1],
        n = caml_call2(Base[195], a_027, b_028);
       if(0 !== n) return n;
       var a_025$0 = a_029, b_026$0 = b_030;
       continue;
      }
     }
     else{
      var a_031 = a_025$0[1];
      if(typeof b_026$0 !== "number"){
       if(0 === b_026$0[0]) return 1;
       var b_032 = b_026$0[1];
       return caml_call2(Base[195], a_031, b_032);
      }
     }
     return 1;
    }
   }
   function of_list(args){
    var _hh_ = 0;
    function _hi_(arg, args){return [0, arg, args];}
    return caml_call3(Base_List[105], args, _hi_, _hh_);
   }
   function to_list(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]){
     var xs = param[2], x = param[1];
     return [0, x, to_list(xs)];
    }
    var x$0 = param[1];
    return [0, x$0, 0];
   }
   function ends_in_complete(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 !== param$0[0]) return 1;
     var args = param$0[2], param$0 = args;
    }
   }
   function extend(t, extend, path){
    if(ends_in_complete(t)) return t;
    var
     _hd_ = caml_call1(parts, path),
     _he_ = caml_call1(Base_List[87], _hd_),
     path_list = caml_call2(Base_Option[30], _he_, 0),
     _hf_ = caml_call1(extend, path_list),
     _hg_ = to_list(t);
    return of_list(caml_call2(Base[222], _hg_, _hf_));
   }
   function normalize$0(key_type, flag_or_subcommand){
    function _g9_(c){return caml_call2(Base_Char[12], c, 95);}
    if(caml_call2(Base_String[19], flag_or_subcommand, _g9_)){
     var _g__ = caml_call1(Command_Shape[14][1][1], key_type);
     caml_call4(Command_Import[8], _Q_, _g__, flag_or_subcommand, 0);
    }
    if(! key_type) return caml_call1(Base_String[72], flag_or_subcommand);
    if(caml_call2(Base_String[134], flag_or_subcommand, cst$5)){
     var
      _g$_ = 0,
      _ha_ =
        [0,
         [11,
          cst_invalid,
          [24,
           _S_,
           function(param, custom_printf_033){
            return caml_call1(Command_Shape[14][1][1], custom_printf_033);
           },
           _R_]],
         cst_invalid_Key_type_name_S];
     caml_call4(Command_Import[8], _ha_, key_type, flag_or_subcommand, _g$_);
    }
    if(caml_call2(Base_String[19], flag_or_subcommand, Base_Char[45])){
     var
      _hb_ = 0,
      _hc_ =
        [0,
         [11,
          cst_invalid$0,
          [24,
           _U_,
           function(param, custom_printf_034){
            return caml_call1(Command_Shape[14][1][1], custom_printf_034);
           },
           _T_]],
         cst_invalid_Key_type_name_cont];
     caml_call4(Command_Import[8], _hc_, key_type, flag_or_subcommand, _hb_);
    }
    return caml_call2(Base_String[97], flag_or_subcommand, cst$6)
            ? flag_or_subcommand
            : caml_call2(Base[241], cst$7, flag_or_subcommand);
   }
   var lookup_expand = Command_Shape[14][4];
   function subcommand_cmp_fst(param, _g8_){
    var c = _g8_[1], a = param[1];
    return caml_call2(help_screen_compare, a, c);
   }
   function shape(t){
    function _g0_(a, b){return caml_call2(Base_String[51], a[1], b[1]);}
    var
     _g1_ = caml_call1(Base_Map[74], t[3]),
     _g2_ = caml_call2(Base_List[53], _g1_, align),
     _g3_ = caml_call2(Base_List[83], _g2_, _g0_),
     _g4_ = caml_call1(Command_Shape[4][1], _g3_),
     _g5_ = [1, t[5]];
    function _g6_(readme){return caml_call1(readme, 0);}
    var _g7_ = caml_call2(Base_Option[24], t[2], _g6_);
    return [0, t[1], _g7_, _g5_, _g4_];
   }
   var
    path_key = key_create(cst_path),
    args_key = key_create(cst_args),
    help_key = key_create(cst_help$0),
    normalized_path = [0, 0],
    normalized_args = [0, 0];
   function get_flag_and_action(t, prefix){
    var map = t[3], key_type = 1;
    function _gV_(flag){
     var
      name_matching = flag[8],
      aliases_excluded_from_help = flag[3],
      aliases = flag[2],
      name = flag[1],
      data = [0, flag, name_matching],
      aliases$0 = caml_call2(Base[222], aliases_excluded_from_help, aliases);
     function _gZ_(alias){return [0, alias, data];}
     return [0, [0, name, data], caml_call2(Base_List[53], aliases$0, _gZ_)];
    }
    var
     _gW_ = caml_call1(Base_Map[74], map),
     alist = caml_call2(Base_List[14], _gW_, _gV_);
    function _gX_(param, _gY_){
     var s2 = _gY_[1], s1 = param[1];
     return caml_call2(Base_String[51], s1, s2);
    }
    var match = caml_call2(Base_List[128], alist, _gX_);
    if(match)
     var
      flag = match[1][1],
      match$0 = caml_call3(Command_Import[8], _V_, flag, 0);
    else
     var match$0 = caml_call3(lookup_expand, alist, prefix, key_type);
    if(0 === match$0[0]){
     var match$1 = match$0[1], flag$0 = match$1[2], flag_name = match$1[1];
     return [0, flag_name, flag$0[4]];
    }
    var msg = match$0[1];
    return caml_call2(die(_X_), msg, 0);
   }
   function run_exn(exn, for_completion, path, verbose_on_parse_error){
    if(exn[1] === Failed_to_parse_command_line && for_completion)
     return exit(0);
    if(exn[1] === Exit_called){var status = exn[2]; return exit(status);}
    if(exn[1] === Failed_to_parse_command_line)
     var msg = exn[2], exn_str = msg;
    else
     var
      _gU_ = caml_call1(Base[117], exn),
      exn_str = caml_call2(Base[85][14], 0, _gU_);
    var verbose = caml_call2(Base_Option[30], verbose_on_parse_error, 1);
    if(verbose)
     var
      _gQ_ = to_string(path),
      _gR_ = caml_call2(Base[241], _gQ_, cst_help$1),
      _gS_ =
        [0,
         cst_For_usage_information_run,
         [0, caml_call2(Base[241], cst$11, _gR_), 0]],
      _gN_ = function(line){return caml_call2(Base[241], cst$8, line);},
      _gO_ = caml_call2(Base_String[102], exn_str, 10),
      _gP_ = caml_call2(Base_List[53], _gO_, _gN_),
      _gT_ =
        [0,
         cst_Error_parsing_command_line,
         [0, caml_call2(Base_String[68], _W_, _gP_), _gS_]],
      error_msg = caml_call2(Base_String[68], _Z_, _gT_);
    else
     var error_msg = exn_str;
    caml_call1(Command_Import[6], error_msg);
    return exit(1);
   }
   function run
   (t,
    env,
    when_parsing_succeeds,
    path,
    cmdline,
    verbose_on_parse_error,
    help_text,
    on_failure){
    var
     for_completion = ends_in_complete(cmdline),
     _gw_ = to_list(cmdline),
     env$0 =
       caml_call3
        (set,
         caml_call3(set, caml_call3(set, env, path_key, path), args_key, _gw_),
         help_key,
         help_text);
    function _gx_(param){
     var parser$1 = caml_call1(t[4], 0);
     a:
     {
      b:
      {
       var
        env$1 = env$0,
        parser = parser$1,
        cmdline$0 = cmdline,
        parse_flags = 1,
        normalized_args$0 = 0;
       for(;;){
        if(typeof cmdline$0 === "number") break b;
        if(0 !== cmdline$0[0]) break;
        var args = cmdline$0[2], arg$1 = cmdline$0[1];
        c:
        if(parse_flags && caml_string_notequal(arg$1, cst$24)){
         if
          (!
           caml_string_notequal(arg$1, "-anon")
           && typeof args !== "number" && 0 === args[0]){
          var
           args$0 = args[2],
           arg$3 = args[1],
           arg_is_flag = 0,
           cmdline$1 = args$0,
           arg$2 = arg$3;
          break c;
         }
         var
          arg_is_flag = caml_call2(Base_String[97], arg$1, cst$9),
          cmdline$1 = args,
          arg$2 = arg$1;
        }
        else
         var arg_is_flag = 0, cmdline$1 = args, arg$2 = arg$1;
        if(arg_is_flag){
         var
          match = get_flag_and_action(t, arg$2),
          action = match[2],
          flag = match[1];
         switch(action[0]){
           case 0:
            var _gI_ = [0, flag, 0]; break;
           case 1:
            var _gI_ = [0, flag, 0]; break;
           case 2:
            if(typeof cmdline$1 !== "number" && 0 === cmdline$1[0]){
             var arg = cmdline$1[1], _gI_ = [0, flag, [0, arg, 0]];
             break;
            }
            var _gI_ = 0;
            break;
           default: var _gI_ = [0, flag, to_list(cmdline$1)];
         }
         var
          normalized_args$1 = [0, _gI_, normalized_args$0],
          match$0 = get_flag_and_action(t, arg$2),
          action$0 = match$0[2],
          flag$0 = match$0[1];
         switch(action$0[0]){
           case 0:
            var
             f$1 = action$0[1],
             match$1 = [0, caml_call1(f$1, env$1), cmdline$1];
            break;
           case 1:
            var info = action$0[1], completing = ends_in_complete(cmdline$1);
            if(completing)
             var match$1 = [0, env$1, cmdline$1];
            else{
             var _gz_ = caml_call1(info, env$1);
             caml_call1(Command_Import[5], _gz_);
             var match$1 = exit(0);
            }
            break;
           case 2:
            var comp = action$0[2], f$2 = action$0[1];
            if(typeof cmdline$1 === "number")
             var match$1 = caml_call2(die(_Y_), flag$0, 0);
            else if(0 === cmdline$1[0]){
             var rest = cmdline$1[2], arg$0 = cmdline$1[1];
             try{var _gA_ = caml_call2(f$2, env$1, arg$0), env = _gA_;}
             catch(e$0){
              var e = caml_wrap_exception(e$0);
              if(e[1] !== Failed_to_parse_command_line)
               throw caml_maybe_attach_backtrace(e, 0);
              if(! ends_in_complete(rest))
               throw caml_maybe_attach_backtrace(e, 0);
              var env = env$1;
             }
             var match$1 = [0, env, rest];
            }
            else
             var
              part = cmdline$1[1],
              _gB_ = run_and_exit(comp, env$1, part),
              match$1 = caml_call1(Base_Nothing[4], _gB_);
            break;
           default:
            var
             comp$0 = action$0[2],
             f$3 = action$0[1],
             arg_list = to_list(cmdline$1);
            if(ends_in_complete(cmdline$1)){
             var _gC_ = run_and_exit(comp$0, env$1, arg_list);
             caml_call1(Base_Nothing[4], _gC_);
            }
            var match$1 = [0, caml_call2(f$3, env$1, arg_list), 0];
         }
         var
          cmdline$2 = match$1[2],
          env$2 = match$1[1],
          env$1 = env$2,
          cmdline$0 = cmdline$2,
          normalized_args$0 = normalized_args$1;
        }
        else
         var
          match$2 = consume(parser, arg$2, for_completion),
          update_env = match$2[3],
          parse_flags2 = match$2[2],
          parser$0 = match$2[1],
          env$3 = caml_call1(update_env, env$1),
          parse_flags$0 = parse_flags ? parse_flags2 : parse_flags,
          normalized_args$2 = [0, [0, arg$2, 0], normalized_args$0],
          env$1 = env$3,
          parser = parser$0,
          cmdline$0 = cmdline$1,
          parse_flags = parse_flags$0,
          normalized_args$0 = normalized_args$2;
       }
       var part$0 = cmdline$0[1];
       if(parse_flags && caml_call2(Base_String[97], part$0, cst$10)){
        var
         _gJ_ =
           function(name){
            var _gM_ = caml_call2(Base_String[97], name, part$0);
            return _gM_ ? caml_call1(Command_Import[5], name) : _gM_;
           },
         _gK_ = caml_call1(Base_Map[73], t[3]);
        caml_call2(Base_List[19], _gK_, _gJ_);
        var match$3 = exit(0);
        break a;
       }
       var t$3 = parser;
       for(;;){
        switch(t$3[0]){
          case 0:
           var _gL_ = exit(0); break;
          case 1:
           var
            complete = t$3[1][3],
            _gL_ = run_and_exit(complete, env$1, part$0);
           break;
          case 2:
           var f$0 = t$3[1], t$4 = caml_call1(f$0, 1), t$3 = t$4; continue;
          case 3:
           var t$5 = t$3[1];
           if(t$5){var t$6 = t$5[1][1], t$3 = t$6; continue;}
           var _gL_ = exit(0);
           break;
          default: var t$7 = t$3[1], t$3 = t$7; continue;
        }
        var match$3 = caml_call1(Base_Nothing[4], _gL_);
        break a;
       }
      }
      var
       _gD_ = function(flag){return caml_call1(flag[7], env$1);},
       _gE_ = caml_call1(Base_Map[74], t[3]);
      caml_call2(Base_List[19], _gE_, _gD_);
      var
       _gF_ = caml_call1(Base_List[63], normalized_args$0),
       t$0 = parser,
       _gG_ = caml_call1(Base_List[11], _gF_);
      for(;;){
       switch(t$0[0]){
         case 0:
          var a = t$0[1], _gH_ = caml_call1(a, env$1); break;
         case 1:
          throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
         case 2:
          var f = t$0[1], t$1 = caml_call1(f, 0), t$0 = t$1; continue;
         case 3:
          var _gH_ = caml_call1(Base[244], cst_BUG_asked_for_final_value_);
          break;
         default: var t$2 = t$0[1], t$0 = t$2; continue;
       }
       var
        match$3 =
          [0,
           [0,
            -1061020774,
            caml_call2(mem, env$1, key_internal_validate_parsing)],
           _gH_,
           _gG_];
       break;
      }
     }
     var
      parsed_normalized_args = match$3[3],
      main = match$3[2],
      is_using_validate_parsing = match$3[1];
     normalized_path[1] = [0, path];
     normalized_args[1] = [0, parsed_normalized_args];
     return [0, is_using_validate_parsing, caml_call1(main, 15369289)];
    }
    var match = caml_call1(Base_Result[41], _gx_);
    if(0 !== match[0]){
     var exn = match[1];
     return caml_call4
             (on_failure, exn, for_completion, path, verbose_on_parse_error);
    }
    var _gy_ = match[1];
    if(_gy_[1][2]){caml_call1(when_parsing_succeeds, 0); return exit(0);}
    var thunk = _gy_[2];
    caml_call1(when_parsing_succeeds, 0);
    return caml_call1(thunk, -903816947);
   }
   function wrap_value(v, param){return return_no_arg(v);}
   function apply$1(f, x){
    function _gp_(param){
     var _gu_ = caml_call1(f[3], 0), _gv_ = caml_call1(x[3], 0);
     return caml_call2(Base[222], _gv_, _gu_);
    }
    function _gq_(param){
     var _gt_ = [0, caml_call1(x[2], 0), 0];
     return concat$0([0, caml_call1(f[2], 0), _gt_]);
    }
    return [0,
            function(param){
             var _gr_ = caml_call1(x[1], 0), _gs_ = caml_call1(f[1], 0);
             return symbol$0
                     (symbol$0
                       (return$1
                         (function(f, x, param){
                           var
                            f_outcome = caml_call1(f, 0),
                            x_outcome = caml_call1(x, 0);
                           return caml_call2(apply$0, f_outcome, x_outcome);
                          }),
                        _gs_),
                      _gr_);
            },
            _gq_,
            _gp_];
   }
   function ___(param){return 0;}
   function _$_(param){return zero;}
   var
    empty_spec =
      [0,
       function(param){
        return return$1
                (function(param){
                  return return_no_arg(function(_go_){return _go_;});
                 });
       },
       _$_,
       ___];
   function map_outcome(x, f){
    var _gl_ = x[3], _gm_ = x[2];
    return [0,
            function(param){
             function _gn_(x, param){
              var x_outcome = caml_call1(x, 0);
              return caml_call1(f, x_outcome);
             }
             return symbol_map(caml_call1(x[1], 0), _gn_);
            },
            _gm_,
            _gl_];
   }
   function map$2(x, f){
    return map_outcome(x, function(_gk_){return caml_call2(map$0, _gk_, f);});
   }
   function lookup(key){
    function _gi_(param){return 0;}
    function _gj_(param){return zero;}
    return [0,
            function(param){
             return symbol_map
                     (from_env
                       (function(env){return caml_call2(find_exn, env, key);}),
                      wrap_value);
            },
            _gj_,
            _gi_];
   }
   var
    path = lookup(path_key),
    args = lookup(args_key),
    help$0 = lookup(help_key);
   function _aa_(param){return 0;}
   function _ab_(param){return zero;}
   var
    env =
      [0,
       function(param){
        return symbol_map(from_env(function(env){return env;}), wrap_value);
       },
       _ab_,
       _aa_],
    string$0 = include$0[1],
    int$1 = include$0[2],
    char$1 = include$0[3],
    float$1 = include$0[4],
    bool$0 = include$0[5],
    sexp$0 = include$0[6],
    sexp_conv$0 = include$0[7];
   function anon(spec){
    caml_call1(invariant, spec[2]);
    function _gf_(param){return 0;}
    function _gg_(param){return spec[2];}
    return [0,
            function(param){
             function _gh_(outcome, param){return outcome;}
             return symbol_map(spec[1], _gh_);
            },
            _gg_,
            _gf_];
   }
   function escape_anon(final_anon){
    var t = t2(final_anon, sequence$0(symbol$2(cst_ARG, string$0)));
    return anon([0, [4, t[1]], t[2]]);
   }
   function flag(opt, full_flag_required, name){
    return function(mode){
     return function(doc){
      var aliases_excluded_from_help = 0;
      if(opt) var sth = opt[1], aliases = sth; else var aliases = 0;
      function normalize(flag){return normalize$0(1, flag);}
      var
       name$0 = normalize(name),
       aliases$0 = caml_call2(Base_List[53], aliases, normalize),
       match = caml_call1(mode, name$0),
       extra_doc = match[4],
       num_occurrences = match[3],
       read = match[2],
       action = match[1],
       check_available =
         num_occurrences[1]
          ? function(env){caml_call1(read, env); return 0;}
          : function(_ge_){return 0;},
       name_matching =
         caml_call1(Base_Option[53], full_flag_required)
          ? -461087063
          : -481604174;
      function _f9_(param){
       var _gb_ = caml_obj_tag(extra_doc);
       a:
       {
        var _ga_ = 0;
        if(250 === _gb_)
         var match = extra_doc[1];
        else{
         if(246 !== _gb_ && 244 !== _gb_){var match = extra_doc; break a;}
         var match = caml_call1(CamlinternalLazy[2], extra_doc);
        }
       }
       if(match)
        var
         extra_doc$0 = match[1],
         _gc_ =
           [0,
            doc,
            [0,
             caml_call1(Ppx_string_runtime[1][2], cst$12),
             [0, extra_doc$0, 0]]],
         _gd_ = caml_call1(Ppx_string_runtime[1][4], _gc_);
       else
        var _gd_ = doc;
       return [0,
               [0,
                name$0,
                aliases$0,
                aliases_excluded_from_help,
                action,
                _gd_,
                num_occurrences,
                check_available,
                name_matching],
               _ga_];
      }
      function _f__(param){return zero;}
      return [0,
              function(param){
               function _f$_(v, param){return v;}
               return symbol_map
                       (from_env(function(env){return caml_call1(read, env);}),
                        _f$_);
              },
              _f__,
              _f9_];};};
   }
   function flag_optional_with_default_doc
   (aliases,
    full_flag_required,
    name,
    arg_type,
    sexp_of_default,
    default$0,
    doc){
    var default_sexp = caml_call1(sexp_of_default, default$0);
    a:
    {
     if
      (0 === default_sexp[0]
       && ! caml_string_notequal(default_sexp[1], cst$29)){var doc$0 = doc; break a;}
     var
      _f6_ =
        [0,
         [2,
          0,
          [11,
           cst_default,
           [24,
            _ad_,
            function(param, custom_printf_035){
             return caml_call1(Base[85][16], custom_printf_035);
            },
            _ac_]]],
         cst_s_default_Sexp],
      doc$0 = caml_call3(Command_Import[7], _f6_, doc, default_sexp);
    }
    function _f7_(_f8_){
     return optional_with_default(default$0, arg_type, _f8_);
    }
    return caml_call1(flag(aliases, full_flag_required, name)(_f7_), doc$0);
   }
   function return$3(v){
    function _f4_(param){return 0;}
    function _f5_(param){return zero;}
    return [0,
            function(param){
             return return$1(function(param){return return_no_arg(v);});
            },
            _f5_,
            _f4_];
   }
   function optional_to_required(t){
    var _f1_ = t[3], _f2_ = t[2];
    return [0,
            function(param){
             function _f3_(f, param){
              var outcome = caml_call1(f, 0);
              return introduce_missing_required_fla
                      (caml_call2
                        (map$0,
                         outcome,
                         function(param){
                          if(! param)
                           return [1,
                                   [0,
                                    696341824,
                                    caml_call1(Base_Error[14], cst_optional_to_required_got_a)]];
                          var v = param[1];
                          return [0, v];
                         }));
             }
             return symbol_map(caml_call1(t[1], 0), _f3_);
            },
            _f2_,
            _f1_];
   }
   var
    map$3 = [0, -198771759, map$2],
    include$1 = caml_call1(Base_Applicative[7], [0, return$3, apply$1, map$3]),
    return$4 = include$1[1],
    map$4 = include$1[2],
    both = include$1[3],
    symbol$3 = include$1[4],
    symbol$4 = include$1[5],
    symbol$5 = include$1[6],
    symbol_map$1 = include$1[7],
    apply$2 = include$1[8],
    map2 = include$1[9],
    map3 = include$1[10],
    all = include$1[11],
    all_unit = include$1[12],
    Applicative_infix = include$1[13];
   function arg_names(t){
    var
     flags = create$0(caml_call1(t[3], 0)),
     flag_names = caml_call1(Base_Map[73], flags),
     anon_names = names(caml_call1(t[2], 0));
    return caml_call1(Base_List[11], [0, flag_names, [0, anon_names, 0]]);
   }
   function compare$0(a_036, b_037){
    if(a_036 === b_037) return 0;
    var _fV_ = b_037[1], _fW_ = a_036[1];
    function _fX_(a_038, b_039){return caml_call2(Base[195], a_038, b_039);}
    var n = caml_call3(Base[159], _fX_, _fW_, _fV_);
    if(0 !== n) return n;
    var _fY_ = b_037[2], _fZ_ = a_036[2];
    function _f0_(a_040, b_041){return caml_call2(Base[195], a_040, b_041);}
    return caml_call3(Base[159], _f0_, _fZ_, _fY_);
   }
   function sexp_of_t(t){
    var x_042 = t[1];
    return caml_call2(Base[165], Base[202], x_042);
   }
   var
    T = [0, compare$0, sexp_of_t],
    sexp_of_t$0 = T[2],
    include$2 = caml_call1(Base_Comparator[7], T),
    comparator = include$2[1];
   function create_exn(t){
    var flags = create$0(caml_call1(t[3], 0));
    function _fP_(param){
     var flag = param[2], name = param[1];
     return flag[6][1] ? [0, name] : 0;
    }
    var
     _fQ_ = caml_call2(Base_Map[75], 0, flags),
     required_args = caml_call2(Base_List[13], _fQ_, _fP_),
     names = arg_names(t);
    function _fR_(s){return caml_call4(Base_String[70], 0, 0, s, 44);}
    var names_with_commas = caml_call2(Base_List[12], names, _fR_);
    if(1 - caml_call1(Base_List[18], names_with_commas)){
     var
      _fS_ = function(x_043){return caml_call2(Base[165], Base[202], x_043);},
      _fT_ =
        caml_call5
         (Base_Error[19],
          _ae_,
          0,
          cst_For_simplicity_Command_Spe,
          names_with_commas,
          _fS_);
     caml_call1(Base_Error[31], _fT_);
    }
    if(names) return [0, names, required_args];
    var
     _fU_ = caml_call1(Sexplib0_Sexp_conv[7], cst_choose_one_expects_choices);
    return caml_call1(Base[246], _fU_);
   }
   function to_string$0(t){
    return t[2]
            ? caml_call2(Base_String[68], _af_, t[2])
            : caml_call2(Base_String[68], _ag_, t[1]);
   }
   function list_to_string(ts){
    var _fO_ = caml_call2(Base_List[53], ts, to_string$0);
    return caml_call2(Base_String[68], _ai_, _fO_);
   }
   var If_nothing_chosen = [0];
   function choose_one_non_optional(opt, ts, if_nothing_chosen){
    if(opt) var sth = opt[1], new_behavior = sth; else var new_behavior = 1;
    function _fb_(t){
     if(new_behavior)
      var
       name_of_the_group = create_exn(t),
       _fA_ =
         function(param){
          function _fD_(flag_internal){
           var
            except = flag_internal[1],
            _fG_ = flag_internal[8],
            _fH_ = flag_internal[7],
            _fI_ = [0, 0, flag_internal[6][2]],
            _fJ_ = flag_internal[5],
            _fK_ = flag_internal[4],
            _fL_ = flag_internal[3],
            _fM_ = flag_internal[2];
           function _fF_(x){
            return 1 - caml_call2(Base_String[134], except, x);
           }
           var
            l = caml_call2(Base_List[12], name_of_the_group[2], _fF_),
            match = l ? [0, caml_call2(Base_String[68], _ah_, l)] : 0;
           if(match)
            var
             group = match[1],
             _fN_ = caml_call2(Command_Import[7], _aj_, group);
           else
            var _fN_ = cst$13;
           return [0,
                   except,
                   _fM_,
                   _fL_,
                   _fK_,
                   caml_call3(Command_Import[7], _ak_, _fJ_, _fN_),
                   _fI_,
                   _fH_,
                   _fG_];
          }
          var _fE_ = caml_call1(t[3], 0);
          return caml_call2(Base_List[53], _fE_, _fD_);
         },
       _fB_ =
         function(param){
          var anon = caml_call1(t[2], 0);
          if(typeof anon === "number") return 0;
          switch(anon[0]){
            case 1:
             var t$0 = anon[1]; return [1, t$0];
            case 2:
             var t$1 = anon[1]; return [2, t$1];
            default: return [2, anon];
          }
         },
       _fC_ = [0, t[1], _fB_, _fA_];
     else
      var _fC_ = t;
     return [0, create_exn(t), _fC_];
    }
    var
     _fc_ = caml_call2(Base_List[53], ts, _fb_),
     match = caml_call2(Base_Map[8], [0, comparator], _fc_);
    if(17724 <= match[1]){
     var
      ts$0 = match[2],
      _fd_ =
        function(value_list){
         var arg_counter = caml_call1(Base_List[45], value_list);
         function more_than_one_error(passed){
          var
           _fx_ = 0,
           _fy_ = caml_call2(Base_List[53], passed, Base[242]),
           _fz_ = 0;
          return caml_call2
                  (die
                    ([0,
                      [11,
                       cst_Cannot_pass_more_than_one_$0,
                       [24,
                        _al_,
                        function(param, custom_printf_044){
                         return list_to_string(custom_printf_044);
                        },
                        _fz_]],
                      cst_Cannot_pass_more_than_one_]),
                   _fy_,
                   _fx_);
         }
         function _fn_(param){
          var match = param[2], name = param[1];
          if(0 === match[0]){
           var value = match[1];
           return [0, [0, name, value]];
          }
          var err = match[1];
          return [1, [0, name, err]];
         }
         var
          match = caml_call2(Base_List[16], value_list, _fn_),
          error_list = match[2],
          success_list = match[1];
         if(success_list){
          var _fo_ = success_list[1];
          if(success_list[2]) return more_than_one_error(success_list);
          var value = _fo_[2];
          if(1 < arg_counter) return more_than_one_error(value_list);
          var
           _fp_ =
             typeof if_nothing_chosen === "number"
              ? if_nothing_chosen ? [0, value] : value
              : value;
          return [0, _fp_];
         }
         if(error_list && ! error_list[2]){
          var
           _ft_ = error_list[1],
           err = _ft_[2][2],
           name = _ft_[1],
           _fu_ = caml_call1(Base_Error[12], err),
           _fv_ = to_string$0(name),
           _fw_ = caml_call3(Command_Import[7], _ao_, _fv_, _fu_);
          return [1, [0, 696341824, caml_call1(Base_Error[14], _fw_)]];
         }
         if(typeof if_nothing_chosen !== "number"){
          var value$0 = if_nothing_chosen[1];
          return [0, value$0];
         }
         if(if_nothing_chosen) return _am_;
         var
          _fq_ = 0,
          _fr_ = caml_call1(Base_Map[73], ts$0),
          _fs_ = 0,
          fmt =
            [0,
             [11,
              cst_Must_pass_one_of_these,
              [24,
               _an_,
               function(param, custom_printf_045){
                return list_to_string(custom_printf_045);
               },
               _fs_]],
             cst_Must_pass_one_of_these_Cho];
         function _fm_(msg, param){
          return [1, [0, 696341824, caml_call1(Base_Error[14], msg)]];
         }
         return caml_call2
                 (caml_call2(Command_Import[9], _fm_, fmt), _fr_, _fq_);
        },
      _fe_ =
        function(name, t, acc){
         function _fk_(acc, param){
          var has_arg = param[2], value = param[1];
          return has_arg ? [0, [0, name, value], acc] : acc;
         }
         var _fi_ = t[3], _fj_ = t[2];
         return caml_call3
                 (map2,
                  acc,
                  [0,
                   function(param){
                    function _fl_(f, param){
                     var outcome = caml_call1(f, 0);
                     return [0, [0, outcome], outcome[2]];
                    }
                    return symbol_map(caml_call1(t[1], 0), _fl_);
                   },
                   _fj_,
                   _fi_],
                  _fk_);
        },
      _ff_ = caml_call1(return$4, 0),
      t = caml_call2(map$4, caml_call3(Base_Map[55], ts$0, _ff_, _fe_), _fd_),
      _e$_ = t[3],
      _fa_ = t[2];
     return [0,
             function(param){
              function _fh_(f, param){
               var outcome = caml_call1(f, 0);
               return introduce_missing_required_fla(outcome);
              }
              return symbol_map(caml_call1(t[1], 0), _fh_);
             },
             _fa_,
             _e$_];
    }
    var
     name = match[2],
     _fg_ =
       caml_call5
        (Base_Error[19],
         _ap_,
         0,
         cst_Command_Spec_choose_one_ca,
         name,
         sexp_of_t$0);
    return caml_call1(Base_Error[31], _fg_);
   }
   function choose_one(ts, if_nothing_chosen){
    function _e__(t){
     return map_outcome
             (t,
              function(param){
               var has_arg = param[2], result = param[1];
               if(0 !== result[0]) return [0, result, has_arg];
               var match = result[1];
               if(! match)
                return [0,
                        [1,
                         [0,
                          696341824,
                          caml_call1(Base_Error[14], cst_missing_required_flag)]],
                        0];
               var value = match[1];
               return [0, [0, value], 1];
              });
    }
    return choose_one_non_optional
            (_aq_, caml_call2(Base_List[53], ts, _e__), if_nothing_chosen);
   }
   function choose_one_non_optional$0(lst, if_nothing_chosen){
    return choose_one_non_optional(0, lst, if_nothing_chosen);
   }
   function and_arg_names(t){
    return caml_call2
            (map$4, t, function(value){return [0, value, arg_names(t)];});
   }
   function and_arg_name(t){
    var names = arg_names(t);
    if(names && ! names[2]){
     var name = names[1];
     return caml_call2(map$4, t, function(value){return [0, value, name];});
    }
    var
     _e8_ = [0, caml_call2(Base[165], Base[202], names), 0],
     _e9_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_and_arg_name_expects_exact),
         _e8_]];
    return caml_call1(Base[246], _e9_);
   }
   function parse$1(param, args){
    var
     flags = param[3],
     f = param[1],
     cmdline = of_list(args),
     result = [0, 0];
    function _eZ_(exn, param, _e7_, _e6_){
     result[1] = [0, [1, caml_call2(Base_Error[27], 0, exn)]];
     return 0;
    }
    function _e0_(_e5_){return _e5_;}
    var _e1_ = Univ_map[4];
    function _e2_(param){
     function _e3_(params, param, _e4_){
      var outcome = caml_call1(params, 0), match = outcome[1];
      if(0 === match[0]){var x = match[1]; result[1] = [0, [0, x]]; return 0;}
      var err = match[1][2];
      result[1] = [0, [1, err]];
      return 0;
     }
     return symbol_map(caml_call1(f, 0), _e3_);
    }
    run
     ([0, cst$14, 0, create$0(caml_call1(flags, 0)), _e2_, zero],
      _e1_,
      _e0_,
      empty$0,
      cmdline,
      _ar_,
      cst_No_help_for_parsing,
      _eZ_);
    return caml_call4(Base_Option[31], _as_, 0, 0, result[1]);
   }
   function symbol$6(t1, t2){
    return caml_call3
            (map2,
             t1,
             t2,
             function(f1, f2, x){return caml_call1(f2, caml_call1(f1, x));});
   }
   function symbol$7(t1, p2){
    return caml_call3
            (map2,
             t1,
             p2,
             function(f1, p2, x){return caml_call1(caml_call1(f1, x), p2);});
   }
   function symbol$8(t1, p2){
    return caml_call3
            (map2,
             p2,
             t1,
             function(p2, f1, x){return caml_call1(f1, caml_call1(x, p2));});
   }
   function step(f){return caml_call1(return$4, f);}
   function const$0(x){return caml_call1(return$4, x);}
   function wrap(f, t){
    return caml_call2
            (map$4, t, function(run, main){return caml_call2(f, run, main);});
   }
   function of_param(p){
    return caml_call2(map$4, p, function(f, k){return caml_call1(k, f);});
   }
   function to_param(t, m){
    return caml_call2(map$4, t, function(f){return caml_call1(f, m);});
   }
   var
    string$1 = include$0[1],
    int$2 = include$0[2],
    char$2 = include$0[3],
    float$2 = include$0[4],
    bool$1 = include$0[5],
    sexp$1 = include$0[6],
    sexp_conv$1 = include$0[7],
    map$5 = [0, -198771759, map$4],
    include$3 = caml_call1(Base_Applicative[7], [0, return$4, apply$2, map$5]),
    return$5 = include$3[1],
    map$6 = include$3[2],
    both$0 = include$3[3],
    symbol$9 = include$3[4],
    symbol$10 = include$3[5],
    symbol$11 = include$3[6],
    symbol_map$2 = include$3[7],
    apply$3 = include$3[8],
    map2$0 = include$3[9],
    map3$0 = include$3[10],
    all$0 = include$3[11],
    all_unit$0 = include$3[12],
    Applicative_infix$0 = include$3[13];
   function flags_of_args_exn(args){
    function _eP_(acc, param){
     var doc = param[3], spec = param[2], name = param[1];
     function gen(f, flag_type){
      var _eY_ = caml_call1(flag(0, 0, name)(flag_type), doc);
      return symbol$7(step(function(m, x){caml_call1(f, x); return m;}), _eY_);
     }
     function call(f, arg_type){
      function _eW_(_eX_){return optional(arg_type, _eX_);}
      return gen(function(x){return caml_call2(Base_Option[37], x, f);}, _eW_);
     }
     function set(r, arg_type){
      return call(function(x){r[1] = x; return 0;}, arg_type);
     }
     function set_bool(r, b){
      return gen
              (function(passed){
                var _eV_ = passed ? (r[1] = b, 0) : passed;
                return _eV_;
               },
               no_arg);
     }
     switch(spec[0]){
       case 0:
        var
         f = spec[1],
         _eQ_ =
           gen
            (function(passed){return passed ? caml_call1(f, 0) : passed;},
             no_arg);
        break;
       case 1:
        var f$0 = spec[1], _eQ_ = call(f$0, bool$1); break;
       case 2:
        var r = spec[1], _eQ_ = set_bool(r, 1); break;
       case 3:
        var r$0 = spec[1], _eQ_ = set_bool(r$0, 0); break;
       case 4:
        var f$1 = spec[1], _eQ_ = call(f$1, string$1); break;
       case 5:
        var r$1 = spec[1], _eQ_ = set(r$1, string$1); break;
       case 6:
        var f$2 = spec[1], _eQ_ = call(f$2, int$2); break;
       case 7:
        var r$2 = spec[1], _eQ_ = set(r$2, int$2); break;
       case 8:
        var f$3 = spec[1], _eQ_ = call(f$3, float$2); break;
       case 9:
        var r$3 = spec[1], _eQ_ = set(r$3, float$2); break;
       case 10:
        var _eQ_ = caml_call1(Base[244], cst_Arg_Tuple_is_not_supported);
        break;
       case 11:
        var
         f$4 = spec[2],
         syms = spec[1],
         _eR_ = function(sym){return [0, sym, sym];},
         arg_type =
           of_alist_exn
            (0, 0, _at_, 0, 0, caml_call2(Base_List[53], syms, _eR_)),
         _eQ_ = call(f$4, arg_type);
        break;
       case 12:
        var
         f$5 = spec[1],
         _eQ_ =
           gen
            (function(x){
              var _eS_ = Base_List[19];
              function _eT_(_eU_){return caml_call2(_eS_, _eU_, f$5);}
              return caml_call2(Base_Option[37], x, _eT_);
             },
             escape);
        break;
       case 13:
        var _eQ_ = caml_call1(Base[244], cst_Arg_Rest_all_is_not_suppor);
        break;
       default:
        var _eQ_ = caml_call1(Base[244], cst_Arg_Expand_is_not_supporte);
     }
     return symbol$6(acc, _eQ_);
    }
    return caml_call3(Base_List[20], args, empty_spec, _eP_);
   }
   var Deprecated = [0, no_arg$0, escape$0, ad_hoc];
   function shape$0(subcommand_to_shape, t){
    var _eJ_ = Base_List[137][9];
    function _eK_(_eO_){return caml_call2(_eJ_, _eO_, subcommand_to_shape);}
    var _eL_ = caml_call2(Base_Lazy[15], t[3], _eK_);
    function _eM_(readme){return caml_call1(readme, 0);}
    var _eN_ = caml_call2(Base_Option[24], t[2], _eM_);
    return [0, t[1], _eN_, _eL_];
   }
   var abs_path = Command_Shape[14][2], comp_cword = 2;
   function shape$1(t){
    var _eE_ = t[5], _eF_ = t[4], _eG_ = t[3];
    function _eH_(readme){return caml_call1(readme, 0);}
    var _eI_ = caml_call2(Base_Option[24], t[2], _eH_);
    return [0, t[1], _eI_, _eG_, _eF_, _eE_];
   }
   function sexpable_shape(param){
    switch(param[0]){
      case 0:
       var base = param[1]; return [0, shape(base)];
      case 1:
       var group = param[1]; return [1, shape$0(sexpable_shape, group)];
      case 2:
       var exec = param[1]; return [2, shape$1(exec)];
      default:
       var thunk = param[1];
       return [3, caml_call2(Base_Lazy[15], thunk, sexpable_shape)];
    }
   }
   function extend_exn(mem, add, map, key_type, key, data){
    if(caml_call2(mem, map, key)){
     var _eD_ = caml_call1(Command_Shape[14][1][1], key_type);
     caml_call4(Command_Import[8], _au_, _eD_, key, 0);
    }
    return caml_call3(add, map, key, data);
   }
   function extend_map_exn(map, key_type, key, data){
    return extend_exn(Base_Map[45], Base_Map[34], map, key_type, key, data);
   }
   function extend_alist_exn(alist, key_type, key, data){
    function _eC_(alist, key, data){
     return caml_call4(Base_List[137][4], alist, Base_String[134], key, data);
    }
    return extend_exn
            (function(alist, key){
              return caml_call3
                      (Base_List[137][7], alist, Base_String[134], key);
             },
             _eC_,
             alist,
             key_type,
             key,
             data);
   }
   function add
   (base, name, aliases, aliases_excluded_from_help, text, text_summary){
    var flags = base[3], _ey_ = -481604174;
    function _ez_(_eB_){return 0;}
    var
     _eA_ = caml_call2(Command_Import[7], _av_, text_summary),
     flags$0 =
       extend_map_exn
        (flags,
         1,
         name,
         [0,
          name,
          aliases,
          aliases_excluded_from_help,
          [1, function(env){return caml_call1(text, env);}],
          _eA_,
          at_most_once,
          _ez_,
          _ey_]);
    return [0, base[1], base[2], flags$0, base[4], base[5]];
   }
   function basic(summary, readme, param){
    var
     flags = param[3],
     usage = param[2],
     f = param[1],
     flags$0 = caml_call1(flags, 0),
     usage$0 = caml_call1(usage, 0);
    function anons(param){
     function _ew_(params, param){
      var outcome = caml_call1(params, 0), match = outcome[1];
      if(0 === match[0]){
       var thunk = match[1];
       return function(param){return caml_call1(thunk, 0);};
      }
      var err = match[1][2], _ex_ = caml_call1(Base_Error[12], err);
      return caml_call2(die(_aw_), _ex_, 0);
     }
     return symbol_map(caml_call1(f, 0), _ew_);
    }
    var
     flags$1 = create$0(flags$0),
     base = [0, summary, readme, flags$1, anons, usage$0],
     base$0 =
       add
        (base,
         cst_help$2,
         _ay_,
         _ax_,
         function(env){
          var
           _eu_ = caml_call2(find_exn, env, help_key),
           _ev_ = caml_obj_tag(_eu_);
          if(250 === _ev_) return _eu_[1];
          if(246 !== _ev_ && 244 !== _ev_) return _eu_;
          return caml_call1(CamlinternalLazy[2], _eu_);
         },
         cst_this_help_text);
    return [0, base$0];
   }
   function basic_spec(summary, readme, spec, main){
    return basic(summary, readme, to_param(spec, main));
   }
   var subs_key = key_create(cst_subcommands);
   function lazy_group
   (summary, readme, preserve_subcommand_order, body, alist){
    function _es_(alist){
     function _et_(param){
      var t = param[2], name = param[1];
      return [0, normalize$0(0, name), t];
     }
     var
      alist$0 = caml_call2(Base_List[53], alist, _et_),
      match = caml_call2(Base_Map[8], [0, Base_String[59]], alist$0);
     if(17724 <= match[1]){
      var map = match[2];
      return preserve_subcommand_order
              ? alist$0
              : caml_call2(Base_Map[75], 0, map);
     }
     var name = match[2];
     return caml_call3(Command_Import[8], _az_, name, 0);
    }
    var subcommands = caml_call2(Base_Lazy[15], alist, _es_);
    return [1, [0, summary, readme, subcommands, body]];
   }
   function group(summary, readme, preserve_subcommand_order, body, alist){
    function _eq_(f, param){
     var _er_ = caml_call1(f, 0);
     return caml_call2(Base_String[109], 0, _er_);
    }
    var readme$0 = caml_call2(Base_Option[24], readme, _eq_);
    return lazy_group
            (summary,
             readme$0,
             preserve_subcommand_order,
             body,
             caml_call1(Base_Lazy[24], alist));
   }
   function exec(summary, readme, opt, env, path_to_exe, param){
    if(opt)
     var sth = opt[1], child_subcommand = sth;
    else
     var child_subcommand = 0;
    var
     _ep_ =
       -310138871 <= path_to_exe[1]
        ? Stdlib_Sys[1]
        : caml_check_bound(caml_sys_argv(0), 0)[1],
     working_dir = caml_call1(Filename_base[38], _ep_);
    if(491227799 <= path_to_exe[1])
     var
      p = path_to_exe[2],
      p$0 =
        caml_call1(Filename_base[30], p)
         ? p
         : caml_call1(Base[244], cst_Path_passed_to_Absolute_mu),
      path_to_exe$0 = p$0;
    else
     var
      p$1 = path_to_exe[2],
      p$2 =
        caml_call1(Filename_base[29], p$1)
         ? p$1
         : caml_call1(Base[244], cst_Path_passed_to_Relative_to),
      path_to_exe$0 = p$2;
    return [2,
            [0,
             summary,
             readme,
             working_dir,
             path_to_exe$0,
             child_subcommand,
             env]];
   }
   function of_lazy$0(thunk){return [3, thunk];}
   function proxy_of_sexpable
   (sexpable, working_dir, path_to_exe, child_subcommand, path_to_subcommand){
    var
     kind =
       kind_of_sexpable
        (sexpable,
         working_dir,
         path_to_exe,
         child_subcommand,
         path_to_subcommand);
    return [0,
            working_dir,
            path_to_exe,
            path_to_subcommand,
            child_subcommand,
            kind];
   }
   function kind_of_sexpable
   (sexpable, working_dir, path_to_exe, child_subcommand, path_to_subcommand){
    switch(sexpable[0]){
      case 0:
       var b = sexpable[1]; return [0, b];
      case 1:
       var
        g = sexpable[1],
        _ej_ = Base_List[53],
        _ek_ =
          function(param){
           var
            sexpable = param[2],
            str = param[1],
            path_to_subcommand$0 =
              caml_call2(Base[222], path_to_subcommand, [0, str, 0]),
            proxy =
              proxy_of_sexpable
               (sexpable,
                working_dir,
                path_to_exe,
                child_subcommand,
                path_to_subcommand$0);
           return [0, str, proxy];
          },
        _el_ = function(_eo_){return caml_call2(_ej_, _eo_, _ek_);},
        _em_ = caml_call2(Base_Lazy[15], g[3], _el_);
       return [1, [0, g[1], g[2], _em_]];
      case 2:
       var e = sexpable[1]; return [2, e];
      default:
       var
        l = sexpable[1],
        _en_ =
          function(sexpable){
           return kind_of_sexpable
                   (sexpable,
                    working_dir,
                    path_to_exe,
                    child_subcommand,
                    path_to_subcommand);
          };
       return [3, caml_call2(Base_Lazy[15], l, _en_)];
    }
   }
   function Version_info(Version_util){
    function print_version(version){
     var _eh_ = caml_obj_tag(version);
     a:
     if(250 === _eh_)
      var _ei_ = version[1];
     else{
      if(246 !== _eh_ && 244 !== _eh_){var _ei_ = version; break a;}
      var _ei_ = caml_call1(CamlinternalLazy[2], version);
     }
     return caml_call1(Command_Import[5], _ei_);
    }
    function print_build_info(build_info){
     var _ef_ = caml_obj_tag(build_info);
     a:
     if(250 === _ef_)
      var _eg_ = build_info[1];
     else{
      if(246 !== _ef_ && 244 !== _ef_){var _eg_ = build_info; break a;}
      var _eg_ = caml_call1(CamlinternalLazy[2], build_info);
     }
     return caml_call1(Command_Import[5], _eg_);
    }
    function command(version, build_info){
     var
      _ed_ =
        caml_call1
         (flag(0, 0, cst_build_info)(no_arg), cst_print_build_info_for_this_),
      _ee_ =
        caml_call1
         (flag(0, 0, cst_version)(no_arg), cst_print_the_version_of_this_);
     return basic
             (cst_print_version_information,
              0,
              caml_call2
               (symbol$3,
                caml_call2
                 (symbol$3,
                  caml_call1
                   (return$4,
                    function(version_flag, build_info_flag){
                     if(build_info_flag)
                      print_build_info(build_info);
                     else if(version_flag)
                      print_version(version);
                     else{print_build_info(build_info); print_version(version);}
                     return exit(0);
                    }),
                  _ee_),
                _ed_));
    }
    function add$0(version, build_info, unversioned){
     switch(unversioned[0]){
       case 0:
        var
         base = unversioned[1],
         base$0 =
           add
            (base,
             cst_version$0,
             0,
             _aA_,
             function(param){
              var _ec_ = caml_obj_tag(version);
              if(250 === _ec_) return version[1];
              if(246 !== _ec_ && 244 !== _ec_) return version;
              return caml_call1(CamlinternalLazy[2], version);
             },
             cst_the_version_of_this_build),
         base$1 =
           add
            (base$0,
             cst_build_info$0,
             0,
             _aB_,
             function(param){
              var _eb_ = caml_obj_tag(build_info);
              if(250 === _eb_) return build_info[1];
              if(246 !== _eb_ && 244 !== _eb_) return build_info;
              return caml_call1(CamlinternalLazy[2], build_info);
             },
             cst_info_about_this_build);
        return [0, base$1];
       case 1:
        var
         group = unversioned[1],
         _d9_ =
           function(subcommands){
            return extend_alist_exn
                    (subcommands,
                     0,
                     cst_version$1,
                     command(version, build_info));
           },
         subcommands = caml_call2(Base_Lazy[15], group[3], _d9_);
        return [1, [0, group[1], group[2], subcommands, group[4]]];
       case 2:
        var exec = unversioned[1]; return [2, exec];
       default:
        var thunk = unversioned[1];
        return [3,
                [246,
                 function(_d__){
                  var _d$_ = caml_obj_tag(thunk);
                  a:
                  if(250 === _d$_)
                   var _ea_ = thunk[1];
                  else{
                   if(246 !== _d$_ && 244 !== _d$_){var _ea_ = thunk; break a;}
                   var _ea_ = caml_call1(CamlinternalLazy[2], thunk);
                  }
                  return add$0(version, build_info, _ea_);
                 }]];
     }
    }
    function normalize_version_lines(lines){
     var _d8_ = caml_call2(Base_List[83], lines, Base_String[51]);
     return caml_call2(Base_String[68], _aC_, _d8_);
    }
    var
     default_version =
       [246, function(_d7_){return normalize_version_lines(Version_util[2]);}],
     default_build_info =
       [246,
        function(_d6_){
         return caml_call1(Version_util[3], Version_util[1][1]);
        }];
    return [0,
            print_version,
            print_build_info,
            ,
            add$0,
            normalize_version_lines,
            default_version,
            default_build_info];
   }
   function _aD_(param){
    function reprint_build_info(to_sexp){
     var _d5_ = caml_call1(to_sexp, 0);
     return caml_call1(Base[85][16], _d5_);
    }
    var
     sexp_of_t = Base[220],
     Time = [0, sexp_of_t],
     Version_info$0 =
       Version_info([0, Time, version_list, reprint_build_info]);
    if(typeof Ppx_inline_test_lib[3] !== "number"){
     var
      Ppx_expect_test_block$0 =
        caml_call1(Ppx_expect_runtime_Test_block[1], Expect_test_config),
      _dY_ =
        function(param){
         Version_info$0[1].call(null, Version_info$0[6]);
         var _d4_ = caml_call1(Ppx_expect_runtime_Types[4][1], 0);
         return caml_call1(Ppx_expect_test_block$0[2], _d4_);
        },
      _dZ_ =
        caml_call3
         (Ppx_expect_runtime_Test_node[1][1],
          [0, Ppx_expect_runtime_Types[1][1]],
          _aL_,
          _aK_),
      _d0_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 0), _dZ_], 0],
      _d1_ = caml_call1(Ppx_expect_runtime_Types[4][1], 2),
      _d2_ = caml_call1(Ppx_expect_runtime_Types[4][1], 1);
     caml_call14
      (Ppx_expect_test_block$0[3],
       cst_command_src_command_ml$0,
       2633,
       _aP_,
       _aO_,
       _aN_,
       [0, Ppx_expect_runtime_Types[1][1]],
       0,
       _d2_,
       _d1_,
       _aM_,
       0,
       Inline_test_config,
       _d0_,
       _dY_);
    }
    if(typeof Ppx_inline_test_lib[3] !== "number"){
     var
      Ppx_expect_test_block =
        caml_call1(Ppx_expect_runtime_Test_block[1], Expect_test_config),
      _dT_ =
        function(param){
         Version_info$0[2].call(null, cst_some_build_info);
         var _d3_ = caml_call1(Ppx_expect_runtime_Types[4][1], 3);
         return caml_call1(Ppx_expect_test_block[2], _d3_);
        },
      _dU_ =
        caml_call3
         (Ppx_expect_runtime_Test_node[1][1],
          [0, Ppx_expect_runtime_Types[1][1]],
          _aF_,
          _aE_),
      _dV_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 3), _dU_], 0],
      _dW_ = caml_call1(Ppx_expect_runtime_Types[4][1], 5),
      _dX_ = caml_call1(Ppx_expect_runtime_Types[4][1], 4);
     caml_call14
      (Ppx_expect_test_block[3],
       cst_command_src_command_ml,
       2642,
       _aJ_,
       _aI_,
       _aH_,
       [0, Ppx_expect_runtime_Types[1][1]],
       0,
       _dX_,
       _dW_,
       _aG_,
       0,
       Inline_test_config,
       _dV_,
       _dT_);
    }
    return 0;
   }
   caml_call8
    (Ppx_inline_test_lib[10],
     Inline_test_config,
     cst_Version_info,
     0,
     cst_command_src_command_ml$1,
     2622,
     0,
     752,
     _aD_);
   function summary(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var x = param$0[1]; return x[1];
       case 1:
        var x$0 = param$0[1]; return x$0[1];
       case 2:
        var x$1 = param$0[1]; return x$1[1];
       default:
        var thunk = param$0[1], _dS_ = caml_obj_tag(thunk);
        a:
        if(250 === _dS_)
         var param$1 = thunk[1];
        else{
         if(246 !== _dS_ && 244 !== _dS_){var param$1 = thunk; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], thunk);
        }
        var param$0 = param$1;
     }
   }
   var path$0 = caml_call2(map$6, path, parts_exe_basename);
   function get_flag_names(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var base = param$0[1]; return caml_call1(Base_Map[73], base[3]);
       case 3:
        var thunk = param$0[1], _dR_ = caml_obj_tag(thunk);
        a:
        if(250 === _dR_)
         var param$1 = thunk[1];
        else{
         if(246 !== _dR_ && 244 !== _dR_){var param$1 = thunk; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], thunk);
        }
        var param$0 = param$1;
        break;
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _aQ_], 1);
     }
   }
   function help_recursive(cmd, with_flags, expand_dots, t, s){
    function help_recursive_rec(cmd, t, s){
     var t$0 = t;
     for(;;){
      var
       cmd$0 = expand_dots ? cmd : cst$16,
       _dH_ = caml_call2(Base[241], cmd$0, cst$15),
       new_s = caml_call2(Base[241], s, _dH_);
      switch(t$0[0]){
        case 0:
         var
          base = t$0[1],
          _dI_ = summary([0, base]),
          base_help = [0, caml_call2(Base[241], s, cmd), _dI_];
         if(! with_flags) return [0, base_help, 0];
         var
          _dJ_ =
            function(param){
             var h = param[2], flag = param[1];
             return [0, caml_call2(Base[241], new_s, flag), h];
            },
          display_help_flags = opt[1],
          flags = caml_call1(Base_Map[74], base[3]);
         if(display_help_flags)
          var flags$0 = flags;
         else
          var
           _dG_ =
             function(f){return caml_call2(Base_String[50], f[1], cst_help);},
           flags$0 = caml_call2(Base_List[12], flags, _dG_);
         var
          _dF_ = caml_call2(Base_List[14], flags$0, help),
          _dK_ = caml_call2(Base_List[83], _dF_, subcommand_cmp_fst);
         return [0, base_help, caml_call2(Base_List[53], _dK_, _dJ_)];
        case 1:
         var
          match = t$0[1],
          subcommands = match[3],
          summary$0 = match[1],
          _dL_ =
            function(param){
             var t = param[2], cmd = param[1];
             return help_recursive_rec(cmd, t, new_s);
            },
          _dM_ = caml_obj_tag(subcommands);
         a:
         if(250 === _dM_)
          var _dN_ = subcommands[1];
         else{
          if(246 !== _dM_ && 244 !== _dM_){var _dN_ = subcommands; break a;}
          var _dN_ = caml_call1(CamlinternalLazy[2], subcommands);
         }
         var
          _dO_ = caml_call2(Base_List[83], _dN_, subcommand_cmp_fst),
          _dP_ = caml_call2(Base_List[14], _dO_, _dL_);
         return [0, [0, caml_call2(Base[241], s, cmd), summary$0], _dP_];
        case 2:
         return 0;
        default:
         var thunk = t$0[1], _dQ_ = caml_obj_tag(thunk);
         a:
         if(250 === _dQ_)
          var t$1 = thunk[1];
         else{
          if(246 !== _dQ_ && 244 !== _dQ_){var t$1 = thunk; break a;}
          var t$1 = caml_call1(CamlinternalLazy[2], thunk);
         }
         var t$0 = t$1;
      }
     }
    }
    return help_recursive_rec(cmd, t, s);
   }
   function autocomplete_function(argv_0, pid){
    var fname = caml_call2(Command_Import[7], _aR_, pid);
    return caml_call5(Command_Import[7], _aS_, fname, argv_0, fname, argv_0);
   }
   if(typeof Ppx_inline_test_lib[3] !== "number"){
    var
     Ppx_expect_test_block =
       caml_call1(Ppx_expect_runtime_Test_block[1], Expect_test_config),
     _a__ =
       function(param){
        var _dD_ = autocomplete_function(cst_argv_0, 12345);
        caml_call1(Command_Import[5], _dD_);
        var _dE_ = caml_call1(Ppx_expect_runtime_Types[4][1], 6);
        return caml_call1(Ppx_expect_test_block[2], _dE_);
       },
     _bb_ =
       caml_call3
        (Ppx_expect_runtime_Test_node[1][1],
         [0, Ppx_expect_runtime_Types[1][1]],
         _ba_,
         _a$_),
     _bc_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 6), _bb_], 0],
     _be_ = caml_call1(Ppx_expect_runtime_Types[4][1], 8),
     _bf_ = caml_call1(Ppx_expect_runtime_Types[4][1], 7);
    caml_call14
     (Ppx_expect_test_block[3],
      cst_command_src_command_ml$2,
      2736,
      _bi_,
      _bh_,
      _bg_,
      [0, Ppx_expect_runtime_Types[1][1]],
      0,
      _bf_,
      _be_,
      _bd_,
      0,
      Inline_test_config,
      _bc_,
      _a__);
   }
   var path$1 = caml_call2(map$4, path, parts_exe_basename);
   function basic$0(summary, readme, param){
    function _dB_(f, param){
     var _dC_ = caml_call1(f, 0);
     return caml_call2(Base_String[109], 0, _dC_);
    }
    var readme$0 = caml_call2(Base_Option[24], readme, _dB_);
    return basic(summary, readme$0, param);
   }
   function basic_or_error(summary, readme, param){
    return basic$0
            (summary,
             readme,
             caml_call2
              (map$4,
               param,
               function(run, param){
                var match = caml_call1(run, 0);
                if(0 === match[0]) return 0;
                var e = match[1], _dA_ = caml_call1(Base_Error[12], e);
                caml_call1(Stdio[10], _dA_);
                return exit(1);
               }));
   }
   function normalized_path$0(param){
    return caml_call2(Base_Option[24], normalized_path[1], parts);
   }
   function normalized_args$0(param){return normalized_args[1];}
   var
    For_telemetry = [0, normalized_path$0, normalized_args$0],
    word_wrap = Command_Shape[14][5];
   function to_string_for_choose_one(param){return to_string$0(create_exn(param));
   }
   caml_call1(Ppx_inline_test_lib[7], cst_command);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Command);
   var
    run$0 = 228660148,
    shape$2 = 228660148,
    Command =
      [0,
       Auto_complete,
       [0,
        create,
        parse,
        map$1,
        of_lazy,
        of_map,
        of_alist_exn,
        enumerated,
        enumerated_sexpable,
        comma_separated,
        include$0,
        auto_complete],
       [0,
        required,
        optional,
        optional_with_default,
        listed,
        one_or_more_as_pair,
        one_or_more_as_list,
        no_arg,
        no_arg_register,
        no_arg_some,
        no_arg_required,
        no_arg_abort,
        escape,
        escape_with_autocomplete,
        map_flag],
       [0,
        symbol$2,
        sequence$0,
        non_empty_sequence_as_pair,
        non_empty_sequence_as_list,
        maybe,
        maybe_with_default,
        t2,
        t3,
        t4,
        map_anons],
       [0,
        return$4,
        map$4,
        both,
        symbol$3,
        symbol$4,
        symbol$5,
        symbol_map$1,
        apply$2,
        map2,
        map3,
        all,
        all_unit,
        Applicative_infix,
        help$0,
        path$1,
        args,
        flag,
        flag_optional_with_default_doc,
        anon,
        escape_anon,
        If_nothing_chosen,
        choose_one,
        choose_one_non_optional$0,
        and_arg_names,
        and_arg_name,
        arg_names,
        optional_to_required,
        [0,
         create,
         parse,
         map$1,
         of_lazy,
         of_map,
         of_alist_exn,
         enumerated,
         enumerated_sexpable,
         comma_separated,
         include$0,
         auto_complete],
        string$0,
        int$1,
        char$1,
        float$1,
        bool$0,
        sexp$0,
        sexp_conv$0,
        required,
        optional,
        optional_with_default,
        listed,
        one_or_more_as_pair,
        one_or_more_as_list,
        no_arg,
        no_arg_register,
        no_arg_some,
        no_arg_required,
        no_arg_abort,
        escape,
        escape_with_autocomplete,
        map_flag,
        symbol$2,
        sequence$0,
        non_empty_sequence_as_pair,
        non_empty_sequence_as_list,
        maybe,
        maybe_with_default,
        t2,
        t3,
        t4,
        map_anons,
        parse$1],
       [0,
        return$4,
        symbol$3,
        symbol$4,
        symbol$5,
        symbol_map$1,
        [0, return$4, map$4, both]],
       [0,
        return$5,
        map$6,
        both$0,
        symbol$9,
        symbol$10,
        symbol$11,
        symbol_map$2,
        apply$3,
        map2$0,
        map3$0,
        all$0,
        all_unit$0,
        Applicative_infix$0,
        help$0,
        path$0,
        args,
        flag,
        flag_optional_with_default_doc,
        anon,
        escape_anon,
        If_nothing_chosen,
        choose_one,
        choose_one_non_optional$0,
        and_arg_names,
        and_arg_name,
        arg_names,
        const$0,
        both,
        empty_spec,
        symbol$6,
        symbol$7,
        symbol$8,
        step,
        wrap,
        [0,
         create,
         parse,
         map$1,
         of_lazy,
         of_map,
         of_alist_exn,
         enumerated,
         enumerated_sexpable,
         comma_separated,
         include$0,
         auto_complete],
        string$1,
        int$2,
        char$2,
        float$2,
        bool$1,
        sexp$1,
        sexp_conv$1,
        required,
        optional,
        optional_with_default,
        listed,
        one_or_more_as_pair,
        one_or_more_as_list,
        no_arg,
        no_arg_register,
        no_arg_some,
        no_arg_required,
        no_arg_abort,
        escape,
        escape_with_autocomplete,
        map_flag,
        flags_of_args_exn,
        symbol$2,
        sequence$0,
        non_empty_sequence_as_pair,
        non_empty_sequence_as_list,
        maybe,
        maybe_with_default,
        t2,
        t3,
        t4,
        map_anons,
        to_param,
        of_param],
       basic_spec,
       basic$0,
       basic_or_error,
       group,
       lazy_group,
       exec,
       of_lazy$0,
       summary,
       exit,
       For_telemetry,
       [0, Deprecated, summary, help_recursive, get_flag_names],
       run$0,
       [0],
       shape$2,
       [0,
        abs_path,
        word_wrap,
        [0, normalize],
        [0,
         empty$0,
         create$1,
         append,
         parts,
         replace_first,
         to_string,
         to_string_dots],
        [0, compare, of_list, extend],
        [0, flags_of_args_exn, to_string_for_choose_one],
        function(For_unix_with_string_env_var){
         var
          Version_info$0 = Version_info(For_unix_with_string_env_var[1]),
          Pid = For_unix_with_string_env_var[2],
          Thread = For_unix_with_string_env_var[4],
          Unix = For_unix_with_string_env_var[5],
          getpid = Unix[2],
          close = Unix[3],
          in_channel_of_descr = Unix[4],
          wait = Unix[11],
          _bj_ = Unix[5],
          _bk_ = Unix[6],
          _bl_ = Unix[7],
          _bm_ = Unix[10];
         function getenv_and_clear(var$0){
          var value = caml_call1(_bl_, caml_call1(Command_Env_var[4], var$0));
          if(caml_call1(Base_Option[53], value))
           caml_call1(_bk_, caml_call1(Command_Env_var[4], var$0));
          return value;
         }
         var
          include = Command_Shape[11],
          supported_versions = include[3],
          Versioned = include[4],
          of_versioned = include[5],
          to_versioned = include[6];
         function of_external(working_dir, path_to_exe, child_subcommand){
          var
           _dl_ =
             caml_call2(Base_Set[68], [0, Base_Int[10]], supported_versions),
           help_sexp = caml_call1(Base[85][16], _dl_),
           env = [0, -72399366, [0, [0, 1, help_sexp], 0]],
           prog = caml_call2(abs_path, working_dir, path_to_exe),
           argv0 = 0,
           prog_search_path = 0,
           working_dir$0 = 0,
           _dh_ = 0;
          function convert_command_env_var_to_str(list){
           function _dz_(param){
            var str = param[2], env_var = param[1];
            return [0, caml_call1(Command_Env_var[4], env_var), str];
           }
           return caml_call2(Base_List[53], list, _dz_);
          }
          var _dg_ = env[1];
          if(-72399366 <= _dg_)
           if(584703596 <= _dg_)
            var
             list = env[2],
             _di_ = [0, 584703596, convert_command_env_var_to_str(list)];
           else
            var
             list$0 = env[2],
             _di_ = [0, -72399366, convert_command_env_var_to_str(list$0)];
          else if(-126259180 <= _dg_)
           var
            list$1 = env[2],
            _di_ = [0, -126259180, convert_command_env_var_to_str(list$1)];
          else
           var _di_ = env;
          var
           process_info =
             caml_call7
              (_bm_,
               working_dir$0,
               prog_search_path,
               argv0,
               prog,
               child_subcommand,
               _di_,
               _dh_);
          caml_call2(close, 0, process_info[2]);
          function start_reading(descr, info){
           var output = [0, 0], _dr_ = 0;
           function _ds_(param){
            function _dx_(param){
             var _dy_ = caml_call1(in_channel_of_descr, descr);
             return caml_call1(Stdio_In_channel[14], _dy_);
            }
            var result = caml_call1(Base_Result[41], _dx_);
            output[1] = [0, result];
            return 0;
           }
           var thread = caml_call3(Thread[1], 890699316, _ds_, _dr_);
           function _dt_(param){
            caml_call1(Thread[2], thread);
            caml_call2(close, 0, descr);
            var _du_ = output[1];
            if(! _du_){
             var
              _dv_ =
                [0, [1, [0, _aT_, [0, caml_call1(Base_Info[9], info), 0]]], 0],
              _dw_ =
                [1,
                 [0,
                  caml_call1(Sexplib0_Sexp_conv[7], cst_BUG_failed_to_read),
                  _dv_]];
             return caml_call1(Base[246], _dw_);
            }
            var match = _du_[1];
            if(0 === match[0]){var output$0 = match[1]; return output$0;}
            var exn = match[1];
            throw caml_maybe_attach_backtrace(exn, 1);
           }
           return caml_call1(Base_Staged[1], _dt_);
          }
          var
           _dj_ = caml_call1(Base_Info[14], cst_stdout),
           finish_stdout = start_reading(process_info[3], _dj_),
           _dk_ = caml_call1(Base_Info[14], cst_stderr),
           finish_stderr = start_reading(process_info[4], _dk_),
           stderr = caml_call2(Base_Staged[2], finish_stderr, 0),
           stdout = caml_call2(Base_Staged[2], finish_stdout, 0);
          caml_call1(wait, process_info[1]);
          try{
           var
            _dq_ = caml_call1(Sexplib_Sexp[43], stdout),
            t = caml_call1(of_versioned, caml_call1(Versioned[1], _dq_));
           return t;
          }
          catch(exn$0){
           var
            exn = caml_wrap_exception(exn$0),
            _dm_ =
              [0, [1, [0, _aU_, [0, caml_call1(Base[202], stderr), 0]]], 0],
            _dn_ =
              [0, [1, [0, _aV_, [0, caml_call1(Base[202], stdout), 0]]], _dm_],
            _do_ = [0, caml_call1(Base[117], exn), _dn_],
            _dp_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_cannot_parse_command_shape),
                _do_]];
           return caml_call1(Base[246], _dp_);
          }
         }
         function shape_of_proxy(proxy){return shape_of_proxy_kind(proxy[5]);}
         function shape_of_exe
         (param, child_subcommand, path_to_exe, working_dir){
          return shape_of_proxy
                  (proxy_of_sexpable
                    (of_external(working_dir, path_to_exe, child_subcommand),
                     working_dir,
                     path_to_exe,
                     child_subcommand,
                     0));
         }
         function shape_of_proxy_kind(kind){
          switch(kind[0]){
            case 0:
             var b = kind[1]; return [0, b];
            case 1:
             var
              g = kind[1],
              _db_ = Base_List[137][9],
              _dc_ =
                function(_df_){return caml_call2(_db_, _df_, shape_of_proxy);},
              _dd_ = caml_call2(Base_Lazy[15], g[3], _dc_);
             return [1, [0, g[1], g[2], _dd_]];
            case 2:
             var
              e = kind[1],
              child_subcommand = e[5],
              path_to_exe = e[4],
              working_dir = e[3];
             return [2,
                     e,
                     function(_de_){
                      return shape_of_exe
                              (_de_, child_subcommand, path_to_exe, working_dir);
                     }];
            default:
             var l = kind[1];
             return [3, caml_call2(Base_Lazy[15], l, shape_of_proxy_kind)];
          }
         }
         function shape$2(t){
          var t$0 = t;
          for(;;)
           switch(t$0[0]){
             case 0:
              var b = t$0[1]; return [0, shape(b)];
             case 1:
              var g = t$0[1]; return [1, shape$0(shape$2, g)];
             case 2:
              var
               e = t$0[1],
               child_subcommand = e[5],
               path_to_exe = e[4],
               working_dir = e[3],
               _c__ =
                 function(_da_){
                  return shape_of_exe
                          (_da_, child_subcommand, path_to_exe, working_dir);
                 };
              return [2, shape$1(e), _c__];
             default:
              var thunk = t$0[1], _c$_ = caml_obj_tag(thunk);
              a:
              if(250 === _c$_)
               var t$1 = thunk[1];
              else{
               if(246 !== _c$_ && 244 !== _c$_){var t$1 = thunk; break a;}
               var t$1 = caml_call1(CamlinternalLazy[2], thunk);
              }
              var t$0 = t$1;
           }
         }
         function group_or_exec_help_text
         (flags, path, summary, readme, format_list){
          var
           _c6_ = [0, [0, caml_call1(Command_Shape[4][2], format_list)], 0],
           _c7_ = flags ? cst_subcommands_and_flags : cst_subcommands$0,
           _c8_ = [0, cst$18, [0, to_string(path), _aY_]],
           _c9_ =
             [0,
              [0, summary],
              [0,
               [0, caml_call2(Base_String[68], 0, _c8_)],
               [0, readme, [0, [0, _c7_], _c6_]]]];
          return unparagraphs(caml_call1(Base_List[136], _c9_));
         }
         function help_for_shape(shape, path, expand_dots, flags, recursive){
          var shape$0 = shape;
          for(;;){
           var
            loop =
              function(path, acc, shape){
               var shape$0 = shape;
               for(;;){
                var string_of_path = expand_dots ? to_string : to_string_dots;
                switch(shape$0[0]){
                  case 0:
                   var b = shape$0[1];
                   if(! flags) return acc;
                   var
                    _cV_ =
                      function(acc, fmt){
                       var
                        path$0 = [0, fmt[1], path],
                        _c4_ = fmt[3],
                        _c5_ = fmt[2],
                        fmt$0 = [0, string_of_path(path$0), _c5_, _c4_];
                       return [0, fmt$0, acc];
                      },
                    _cW_ =
                      function(fmt){
                       return caml_call2(Base_String[50], fmt[1], cst_help$4);
                      },
                    _cX_ = caml_call2(Base_List[12], b[4], _cW_);
                   return caml_call3(Base_List[20], _cX_, acc, _cV_);
                  case 1:
                   var g = shape$0[1], _cY_ = g[3], _cZ_ = caml_obj_tag(_cY_);
                   a:
                   if(250 === _cZ_)
                    var subcommands = _cY_[1];
                   else{
                    if(246 !== _cZ_ && 244 !== _cZ_){
                     var subcommands = _cY_;
                     break a;
                    }
                    var subcommands = caml_call1(CamlinternalLazy[2], _cY_);
                   }
                   var
                    filtered_subcommands =
                      caml_call1(is_empty, path)
                       ? subcommands
                       : caml_call3
                         (Base_List[137][8],
                          subcommands,
                          Base_String[47],
                          cst_help$3),
                    _cS_ =
                      function(acc, param){
                       var
                        shape = param[2],
                        subcommand = param[1],
                        path$0 = [0, subcommand, path],
                        name = string_of_path(path$0),
                        doc = caml_call1(Command_Shape[10], shape),
                        acc$0 = [0, [0, name, doc, 0], acc];
                       return recursive ? loop(path$0, acc$0, shape) : acc$0;
                      },
                    _cT_ =
                      function(a, b){
                       var _c3_ = caml_call1(Base[242], b);
                       return caml_call2
                               (help_screen_compare, caml_call1(Base[242], a), _c3_);
                      },
                    _cU_ = caml_call2(Base_List[84], filtered_subcommands, _cT_);
                   return caml_call3(Base_List[20], _cU_, acc, _cS_);
                  case 2:
                   var shape$1 = shape$0[2];
                   try{
                    var _c0_ = loop(path, acc, caml_call1(shape$1, 0));
                    return _c0_;
                   }
                   catch(_c2_){return acc;}
                  default:
                   var thunk = shape$0[1], _c1_ = caml_obj_tag(thunk);
                   a:
                   if(250 === _c1_)
                    var shape$2 = thunk[1];
                   else{
                    if(246 !== _c1_ && 244 !== _c1_){var shape$2 = thunk; break a;}
                    var shape$2 = caml_call1(CamlinternalLazy[2], thunk);
                   }
                   var shape$0 = shape$2;
                }
               }
              },
            _cK_ = loop(empty$0, 0, shape$0),
            format_list = caml_call1(Base_List[63], _cK_);
           switch(shape$0[0]){
             case 0:
              var
               b = shape$0[1],
               usage = caml_call1(Command_Shape[5][8], b),
               _cL_ =
                 [0, _aZ_, [0, [0, caml_call1(Command_Shape[4][2], b[4])], 0]],
               _cM_ = [0, b[2], _cL_],
               _cN_ = caml_call2(Base[241], cst$19, usage),
               _cO_ = to_string(path),
               _cP_ = caml_call2(Base[241], _cO_, _cN_),
               _cQ_ = [0, [0, caml_call2(Base[241], cst$20, _cP_)], _cM_];
              return unparagraphs
                      (caml_call1(Base_List[136], [0, [0, b[1]], _cQ_]));
             case 1:
              var g = shape$0[1];
              return group_or_exec_help_text
                      (flags, path, g[1], g[2], format_list);
             case 2:
              var e = shape$0[1];
              return group_or_exec_help_text
                      (flags, path, e[1], e[2], format_list);
             default:
              var thunk = shape$0[1], _cR_ = caml_obj_tag(thunk);
              a:
              if(250 === _cR_)
               var shape$1 = thunk[1];
              else{
               if(246 !== _cR_ && 244 !== _cR_){var shape$1 = thunk; break a;}
               var shape$1 = caml_call1(CamlinternalLazy[2], thunk);
              }
              var shape$0 = shape$1;
           }
          }
         }
         function add(t){
          switch(t[0]){
            case 0:
             var
              base = t[1],
              flags = base[3],
              _cC_ = -481604174,
              _cD_ = function(_cJ_){return 0;},
              flags$0 =
                extend_map_exn
                 (flags,
                  1,
                  name,
                  [0,
                   name,
                   0,
                   _a5_,
                   [0,
                    function(env){
                     return caml_call3
                             (set, env, key_internal_validate_parsing, 0);
                    }],
                   cst_validate_arguments_are_par,
                   at_most_once,
                   _cD_,
                   _cC_]);
             return [0, [0, base[1], base[2], flags$0, base[4], base[5]]];
            case 1:
             var
              match = t[1],
              body = match[4],
              subcommands = match[3],
              readme = match[2],
              summary = match[1],
              _cE_ =
                function(subcommands){
                 function _cI_(param){
                  var command = param[2], name = param[1];
                  return [0, name, add(command)];
                 }
                 return caml_call2(Base_List[53], subcommands, _cI_);
                },
              subcommands$0 = caml_call2(Base_Lazy[15], subcommands, _cE_);
             return [1, [0, summary, readme, subcommands$0, body]];
            case 2:
             return t;
            default:
             var thunk = t[1];
             return [3,
                     [246,
                      function(_cF_){
                       var _cG_ = caml_obj_tag(thunk);
                       a:
                       if(250 === _cG_)
                        var _cH_ = thunk[1];
                       else{
                        if(246 !== _cG_ && 244 !== _cG_){var _cH_ = thunk; break a;}
                        var _cH_ = caml_call1(CamlinternalLazy[2], thunk);
                       }
                       return add(_cH_);
                      }]];
          }
         }
         function add_help_subcommands(t){
          switch(t[0]){
            case 0:
             return t;
            case 1:
             var
              match = t[1],
              body = match[4],
              subcommands = match[3],
              readme = match[2],
              summary = match[1],
              _cl_ =
                function(subcommands){
                 var
                  _cp_ = anon(maybe(symbol$2(cst_SUBCOMMAND, string$0))),
                  _cq_ =
                    caml_call1
                     (flag(0, 0, cst_expand_dots)(no_arg),
                      cst_expand_subcommands_in_recu),
                  _cr_ =
                    caml_call1
                     (flag(0, 0, cst_flags)(no_arg),
                      cst_show_flags_as_well_in_recu),
                  _cs_ =
                    caml_call1
                     (flag(0, 0, cst_recursive)(no_arg),
                      cst_show_subcommands_of_subcom),
                  _ct_ =
                    basic
                     (cst_explain_a_given_subcommand,
                      0,
                      caml_call2
                       (symbol$3,
                        caml_call2
                         (symbol$3,
                          caml_call2
                           (symbol$3,
                            caml_call2
                             (symbol$3,
                              caml_call2
                               (symbol$3,
                                caml_call2
                                 (symbol$3,
                                  caml_call1
                                   (return$4,
                                    function
                                    (recursive, flags, expand_dots, path$0, env, cmd_opt, param){
                                     var match = caml_call2(find, env, subs_key);
                                     if(! match)
                                      throw caml_maybe_attach_backtrace
                                             ([0, Assert_failure, _a1_], 1);
                                     var subs = match[1];
                                     if(path$0 && ! caml_string_notequal(path$0[1], cst_help$7)){
                                      var
                                       path = path$0[2],
                                       _cu_ =
                                         function(path, subcommand){return [0, subcommand, path];},
                                       path$1 = caml_call3(Base_Option[34], cmd_opt, path, _cu_);
                                      if(cmd_opt){
                                       var
                                        cmd = cmd_opt[1],
                                        _cv_ = 0,
                                        _cw_ = function(x){return [0, x, -481604174];},
                                        match$0 =
                                          caml_call3
                                           (lookup_expand,
                                            caml_call2(Base_List[137][9], subs, _cw_),
                                            cmd,
                                            _cv_);
                                       if(0 === match$0[0])
                                        var
                                         match$1 = match$0[1],
                                         t = match$1[2],
                                         possibly_expanded_name = match$1[1],
                                         path$2 = replace_first(path$1, cmd, possibly_expanded_name),
                                         shape = shape$2(t),
                                         path$3 = path$2;
                                       else
                                        var
                                         e = match$0[1],
                                         _cy_ = to_string(path$1),
                                         _cz_ = caml_call4(die(_a0_), cmd, _cy_, e, 0),
                                         shape = _cz_[2],
                                         path$3 = _cz_[1];
                                      }
                                      else
                                       var
                                        _cA_ = caml_call2(Base_List[137][9], subs, shape$2),
                                        subcommands = caml_call1(Base_Lazy[24], _cA_),
                                        _cB_ = function(readme){return caml_call1(readme, 0);},
                                        readme$0 = caml_call2(Base_Option[24], readme, _cB_),
                                        shape$0 = [1, [0, summary, readme$0, subcommands]],
                                        shape = shape$0,
                                        path$3 = path$1;
                                      var
                                       _cx_ =
                                         help_for_shape(shape, path$3, expand_dots, flags, recursive);
                                      return caml_call1(Command_Import[5], _cx_);
                                     }
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _E_], 1);
                                    }),
                                  _cs_),
                                _cr_),
                              _cq_),
                            path),
                          env),
                        _cp_));
                 return extend_alist_exn
                         (caml_call2
                           (Base_List[137][9], subcommands, add_help_subcommands),
                          0,
                          cst_help$5,
                          _ct_);
                },
              subcommands$0 = caml_call2(Base_Lazy[15], subcommands, _cl_);
             return [1, [0, summary, readme, subcommands$0, body]];
            case 2:
             return t;
            default:
             var thunk = t[1];
             return [3,
                     [246,
                      function(_cm_){
                       var _cn_ = caml_obj_tag(thunk);
                       a:
                       if(250 === _cn_)
                        var _co_ = thunk[1];
                       else{
                        if(246 !== _cn_ && 244 !== _cn_){var _co_ = thunk; break a;}
                        var _co_ = caml_call1(CamlinternalLazy[2], thunk);
                       }
                       return add_help_subcommands(_co_);
                      }]];
          }
         }
         function maybe_apply_extend(args, extend$0, path){
          function _ck_(f){return extend(args, f, path);}
          return caml_call3(Base_Option[32], extend$0, args, _ck_);
         }
         function dispatch
         (t,
          env$0,
          extend,
          path,
          args$0,
          maybe_new_comp_cword,
          version,
          build_info,
          verbose_on_parse_error,
          when_parsing_succeeds,
          complete_subcommands){
          var t$0 = t;
          for(;;)
           switch(t$0[0]){
             case 0:
              var
               base = t$0[1],
               args$1 = maybe_apply_extend(args$0, extend, path),
               help_text =
                 [246,
                  function(param){
                   return help_for_shape(shape$2(t$0), path, 0, 1, 0);
                  }];
              return run
                      (base,
                       env$0,
                       when_parsing_succeeds,
                       path,
                       args$1,
                       verbose_on_parse_error,
                       help_text,
                       run_exn);
             case 1:
              var
               group = t$0[1],
               body = group[4],
               subs = group[3],
               readme = group[2],
               summary = group[1],
               completing = ends_in_complete(args$0),
               _b3_ = caml_obj_tag(subs);
              a:
              if(250 === _b3_)
               var _b4_ = subs[1];
              else{
               if(246 !== _b3_ && 244 !== _b3_){var _b4_ = subs; break a;}
               var _b4_ = caml_call1(CamlinternalLazy[2], subs);
              }
              var
               env$1 = caml_call3(set, env$0, subs_key, _b4_),
               die_showing_help =
                 function(msg){
                  if(completing) return exit(0);
                  var
                   _cj_ =
                     help_for_shape
                      (shape$2([1, [0, summary, readme, subs, body]]),
                       path,
                       0,
                       0,
                       0);
                  caml_call2(Command_Import[1], _a6_, _cj_);
                  return caml_call2(die(_a7_), msg, 0);
                 },
               parse_group =
                 function(args, maybe_new_comp_cword){
                  var
                   maybe_new_comp_cword$0 =
                     caml_call2
                      (Base_Option[24], maybe_new_comp_cword, Base_Int[46]);
                  function skip(rest){
                   return parse_group(rest, maybe_new_comp_cword$0);
                  }
                  function resolve(sub, rest){
                   function _cg_(x){return [0, x, -481604174];}
                   var _ch_ = caml_obj_tag(subs);
                   a:
                   if(250 === _ch_)
                    var _ci_ = subs[1];
                   else{
                    if(246 !== _ch_ && 244 !== _ch_){var _ci_ = subs; break a;}
                    var _ci_ = caml_call1(CamlinternalLazy[2], subs);
                   }
                   var
                    subs$0 = caml_call2(Base_List[137][9], _ci_, _cg_),
                    match = caml_call3(lookup_expand, subs$0, sub, 0);
                   if(0 === match[0]){
                    var match$0 = match[1], t = match$0[2], sub$0 = match$0[1];
                    return dispatch
                            (t,
                             env$1,
                             extend,
                             [0, sub$0, path],
                             rest,
                             maybe_new_comp_cword$0,
                             version,
                             build_info,
                             verbose_on_parse_error,
                             when_parsing_succeeds,
                             complete_subcommands);
                   }
                   var msg = match[1];
                   return die_showing_help(msg);
                  }
                  if(typeof args === "number"){
                   if(body){
                    var body$0 = body[1];
                    return caml_call1(body$0, parts_exe_basename(path));
                   }
                   var _b6_ = to_string(path);
                   return die_showing_help
                           (caml_call2(Command_Import[7], _a8_, _b6_));
                  }
                  if(0 !== args[0]){
                   var
                    part = args[1],
                    _b8_ = Base_String[51],
                    _b9_ =
                      function(name){
                       return caml_call2(Base_String[97], name, part);
                      },
                    _b__ = Base[242],
                    _b$_ = caml_obj_tag(subs);
                   a:
                   if(250 === _b$_)
                    var _ca_ = subs[1];
                   else{
                    if(246 !== _b$_ && 244 !== _b$_){var _ca_ = subs; break a;}
                    var _ca_ = caml_call1(CamlinternalLazy[2], subs);
                   }
                   var
                    _cb_ = caml_call2(Base_List[53], _ca_, _b__),
                    _cc_ = caml_call2(Base_List[12], _cb_, _b9_),
                    subs$0 = caml_call2(Base_List[83], _cc_, _b8_);
                   if(! complete_subcommands){
                    caml_call2(Base_List[19], subs$0, Command_Import[5]);
                    return exit(0);
                   }
                   var
                    f = complete_subcommands[1],
                    _cd_ = shape$2(t$0),
                    _ce_ = caml_call1(Command_Shape[9], _cd_),
                    subcommands = caml_call1(Command_Shape[8][3], _ce_),
                    match =
                      caml_call3(f, caml_call1(parts, path), part, subcommands);
                   if(! match) return exit(1);
                   var
                    to_output = match[1],
                    _cf_ = caml_call2(Base_String[68], _a9_, to_output);
                   caml_call1(Command_Import[5], _cf_);
                   return exit(0);
                  }
                  var rest = args[2], sub = args[1];
                  a:
                  {
                   b:
                   if(caml_string_notequal(sub, cst_build_info$1)){
                    c:
                    if(caml_string_notequal(sub, cst_help$9)){
                     if(caml_string_notequal(sub, cst_version$2)){
                      if(! caml_string_notequal(sub, cst_build_info$2)) break b;
                      if(! caml_string_notequal(sub, cst_help$8)) break c;
                      if(caml_string_notequal(sub, cst_version$3)) break a;
                     }
                     if(1 === caml_call1(length, path))
                      return completing
                              ? skip(rest)
                              : (Version_info$0[1].call(null, version), exit(0));
                     break a;
                    }
                    if(completing) return skip(rest);
                    if(typeof rest !== "number" && 0 === rest[0]){
                     var rest_of_rest = rest[2], first_of_rest = rest[1];
                     return resolve(first_of_rest, [0, sub, rest_of_rest]);
                    }
                    var
                     _b7_ =
                       help_for_shape
                        (shape$2([1, [0, group[1], group[2], subs, group[4]]]),
                         path,
                         0,
                         0,
                         0);
                    caml_call1(Command_Import[5], _b7_);
                    return exit(0);
                   }
                   if(1 === caml_call1(length, path))
                    return completing
                            ? skip(rest)
                            : (Version_info$0[2].call(null, build_info), exit(0));
                  }
                  return resolve(sub, rest);
                 };
              return parse_group(args$0, maybe_new_comp_cword);
             case 2:
              var
               exec = t$0[1],
               args$2 = to_list(maybe_apply_extend(args$0, extend, path)),
               prog = caml_call2(abs_path, exec[3], exec[4]),
               args = caml_call2(Base[222], exec[5], args$2),
               env = exec[6],
               _b1_ =
                 function(n){
                  var
                   new_value$0 = n + caml_call1(Base_List[45], exec[5]) | 0,
                   new_value = caml_call1(Base_Int[12], new_value$0);
                  return caml_call2
                          (_bj_,
                           caml_call1(Command_Env_var[4], comp_cword),
                           new_value);
                 };
              caml_call2(Base_Option[37], maybe_new_comp_cword, _b1_);
              var
               _b2_ =
                 caml_call5
                  (For_unix_with_string_env_var[5][8],
                   prog,
                   [0, prog, args],
                   0,
                   env,
                   0);
              return caml_call1(Base_Nothing[4], _b2_);
             default:
              var thunk = t$0[1], _b5_ = caml_obj_tag(thunk);
              a:
              if(250 === _b5_)
               var t$1 = thunk[1];
              else{
               if(246 !== _b5_ && 244 !== _b5_){var t$1 = thunk; break a;}
               var t$1 = caml_call1(CamlinternalLazy[2], thunk);
              }
              var t$0 = t$1;
           }
         }
         function run$0
         (opt,
          verbose_on_parse_error,
          version,
          build_info,
          _bt_,
          extend,
          _bs_,
          complete_subcommands,
          t){
          if(opt)
           var sth = opt[1], add_validate_parsing_flag = sth;
          else
           var add_validate_parsing_flag = 0;
          if(_bt_)
           var sth$0 = _bt_[1], argv = sth$0;
          else
           var
            _bu_ = caml_sys_argv(0),
            argv = caml_call1(Base_Array[30], _bu_);
          if(_bs_)
           var sth$1 = _bs_[1], when_parsing_succeeds = sth$1;
          else
           var when_parsing_succeeds = function(_b0_){return _b0_;};
          if(build_info)
           var v = build_info[1], build_info$0 = v;
          else
           var build_info$0 = Version_info$0[7];
          if(version)
           var
            v$0 = version[1],
            version$0 =
              [246,
               function(param){
                var _bV_ = Base_String[102];
                function _bW_(_bZ_){return caml_call2(_bV_, _bZ_, 10);}
                var
                 _bX_ = caml_call2(Base_String[102], v$0, 32),
                 _bY_ = caml_call2(Base_List[14], _bX_, _bW_);
                return Version_info$0[5].call(null, _bY_);
               }];
          else
           var version$0 = Version_info$0[6];
          function f(param){
           var
            t$0 = Version_info$0[4].call(null, version$0, build_info$0, t),
            t$1 = add_help_subcommands(t$0),
            t$2 = add_validate_parsing_flag ? add(t$1) : t$1;
           if(argv){
            var
             path_to_subcommand = argv[2],
             cmd = argv[1],
             _bx_ =
               function(version){
                var
                 _bU_ = caml_call1(Sexplib_Sexp[43], version),
                 supported_versions$0 =
                   caml_call2
                    (Base_Set[69], [0, Base_Int[9], Base_Int[22]], _bU_),
                 _bN_ =
                   caml_call2
                    (Base_Set[14], supported_versions, supported_versions$0),
                 param = caml_call1(Base_Set[54], _bN_);
                if(param){
                 var
                  version_to_use = param[1],
                  t$4 = sexpable_shape(t$2),
                  t = t$4,
                  path_to_subcommand$0 = path_to_subcommand;
                 for(;;){
                  if(path_to_subcommand$0){
                   var
                    path_to_subcommand$1 = path_to_subcommand$0[2],
                    sub = path_to_subcommand$0[1];
                   if(caml_call2(Base_String[97], sub, cst$17))
                    var _bO_ = t;
                   else
                    switch(t[0]){
                      case 0:
                       var _bO_ = caml_call3(Command_Import[8], _aW_, sub, 0);
                       break;
                      case 1:
                       var
                        g = t[1],
                        _bJ_ = g[3],
                        _bI_ = Base_String[134],
                        _bK_ = caml_obj_tag(_bJ_);
                       a:
                       if(250 === _bK_)
                        var _bL_ = _bJ_[1];
                       else{
                        if(246 !== _bK_ && 244 !== _bK_){var _bL_ = _bJ_; break a;}
                        var _bL_ = caml_call1(CamlinternalLazy[2], _bJ_);
                       }
                       var match = caml_call3(Base_List[137][5], _bL_, _bI_, sub);
                       if(match){
                        var
                         t$0 = match[1],
                         t = t$0,
                         path_to_subcommand$0 = path_to_subcommand$1;
                        continue;
                       }
                       var _bO_ = caml_call3(Command_Import[8], _aX_, sub, 0);
                       break;
                      case 2:
                       var
                        match$0 = t[1],
                        child_subcommand = match$0[5],
                        path_to_exe = match$0[4],
                        working_dir = match$0[3],
                        path_to_subcommand$2 =
                          [0,
                           sub,
                           caml_call2
                            (Base[222], path_to_subcommand$1, child_subcommand)],
                        t$1 =
                          of_external(working_dir, path_to_exe, child_subcommand),
                        t = t$1,
                        path_to_subcommand$0 = path_to_subcommand$2;
                       continue;
                      default:
                       var thunk = t[1], _bM_ = caml_obj_tag(thunk);
                       a:
                       if(250 === _bM_)
                        var t$3 = thunk[1];
                       else{
                        if(246 !== _bM_ && 244 !== _bM_){var t$3 = thunk; break a;}
                        var t$3 = caml_call1(CamlinternalLazy[2], thunk);
                       }
                       var t = t$3;
                       continue;
                    }
                  }
                  else
                   var _bO_ = t;
                  var
                   _bP_ = caml_call2(to_versioned, _bO_, version_to_use),
                   _bQ_ = caml_call1(Versioned[2], _bP_),
                   _bR_ = caml_call1(Base[85][16], _bQ_);
                  caml_call1(Command_Import[4], _bR_);
                  break;
                 }
                }
                else{
                 var
                  _bS_ = caml_call1(Base_Set[68], [0, Base_Int[10]]),
                  _bT_ =
                    caml_call5
                     (Base_Error[19],
                      _a3_,
                      0,
                      cst_Couldn_t_choose_a_supporte,
                      supported_versions,
                      _bS_);
                 caml_call1(Base_Error[31], _bT_);
                }
                return exit(0);
               },
             _by_ = getenv_and_clear(1);
            caml_call2(Base_Option[37], _by_, _bx_);
            var
             _bz_ =
               function(param){
                var
                 _bF_ = caml_call1(getpid, 0),
                 _bG_ = caml_call1(Pid[1], _bF_),
                 _bH_ =
                   autocomplete_function
                    (caml_check_bound(caml_sys_argv(0), 0)[1], _bG_);
                caml_call2(Command_Import[2], _a2_, _bH_);
                return exit(0);
               },
             _bA_ = getenv_and_clear(0);
            caml_call2(Base_Option[37], _bA_, _bz_);
            var match = [0, cmd, path_to_subcommand];
           }
           else
            var match = caml_call1(Base[244], cst_missing_executable_name);
           var
            args$1 = match[2],
            cmd$0 = match[1],
            _bv_ = Base_Int[11],
            _bw_ = getenv_and_clear(comp_cword),
            maybe_new_comp_cword = caml_call2(Base_Option[24], _bw_, _bv_);
           if(maybe_new_comp_cword)
            var
             comp_cword$0 = maybe_new_comp_cword[1],
             _bB_ = caml_call2(Base[222], args$1, _a4_),
             args = caml_call2(Base_List[139], _bB_, comp_cword$0),
             _bC_ = 0,
             _bD_ =
               function(arg, args){
                return typeof args === "number" ? [1, arg] : [0, arg, args];
               },
             args$0 = caml_call3(Base_List[105], args, _bD_, _bC_);
           else
            var args$0 = of_list(args$1);
           var path = create$1(cmd$0);
           try{
            var
             _bE_ =
               dispatch
                (t$2,
                 empty,
                 extend,
                 path,
                 args$0,
                 maybe_new_comp_cword,
                 version$0,
                 build_info$0,
                 verbose_on_parse_error,
                 when_parsing_succeeds,
                 complete_subcommands);
            return _bE_;
           }
           catch(exn$0){
            var exn = caml_wrap_exception(exn$0);
            if(exn[1] !== Failed_to_parse_command_line)
             throw caml_maybe_attach_backtrace(exn, 0);
            var msg = exn[2];
            return ends_in_complete(args$0)
                    ? exit(0)
                    : (caml_call1(Command_Import[6], msg), exit(1));
           }
          }
          if(! raise_instead_of_exit) return caml_call1(Base_Exn[15], f);
          try{var _br_ = f(0); return _br_;}
          catch(exn$0){
           var exn = caml_wrap_exception(exn$0);
           if(exn[1] === Exit_called && 0 === exn[2]){
            var _bq_ = caml_call1(Base[117], exn);
            return caml_call2(Command_Import[3], 0, _bq_);
           }
           throw caml_maybe_attach_backtrace(exn, 0);
          }
         }
         function deprecated_run
         (t,
          cmd,
          args,
          is_help,
          is_help_rec,
          is_help_rec_flags,
          is_expand_dots){
          var
           path_strings = caml_call2(Base_String[102], cmd, 32),
           path = caml_call1(Base_List[63], path_strings),
           args$0 = is_expand_dots ? [0, cst_expand_dots$0, args] : args,
           args$1 = is_help_rec_flags ? [0, cst_flags$0, args$0] : args$0,
           args$2 = is_help_rec ? [0, cst_r, args$1] : args$1,
           args$3 = is_help ? [0, cst_help$6, args$2] : args$2,
           args$4 = of_list(args$3),
           t$0 = add_help_subcommands(t),
           _bn_ = 0;
          function _bo_(_bp_){return _bp_;}
          return dispatch
                  (t$0,
                   empty,
                   0,
                   path,
                   args$4,
                   0,
                   Version_info$0[6],
                   Version_info$0[7],
                   0,
                   _bo_,
                   _bn_);
         }
         return [0, shape$2, help_for_shape, run$0, deprecated_run];
        }]];
   runtime.caml_register_global(300, Command, cst_Command$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJjb21tYW5kLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJlcHJpbnRmIiwicHJpbnRmIiwicHJpbnRfcyIsInByaW50X3N0cmluZyIsInByaW50X2VuZGxpbmUiLCJwcmVycl9lbmRsaW5lIiwic3ByaW50ZiIsImZhaWx3aXRoZiIsImtzcHJpbnRmIiwiYWxsIiwiY29tcGFyZSIsInNleHBfb2ZfdCIsInRvX3N0cmluZyIsInQiLCJmbGFnX25hbWUkMCIsImVycm9yX3NvdXJjZV8wMjIiLCJlcnJvcl9zb3VyY2VfMDY3IiwiZXJyb3Jfc291cmNlXzA4OCIsImVycm9yX3NvdXJjZV8xMDQiLCJlcnJvcl9zb3VyY2VfMTE4IiwiZXJyb3Jfc291cmNlXzE0NSIsImVycm9yX3NvdXJjZV8xNzgiLCJlcnJvcl9zb3VyY2VfMjA2IiwiZXJyb3Jfc291cmNlXzIyMiIsImVycm9yX3NvdXJjZV8yMzYiLCJlcnJvcl9zb3VyY2VfMjYxIiwiZXJyb3Jfc291cmNlXzI5MCIsImVycm9yX3NvdXJjZV8zMjIiLCJlcnJvcl9zb3VyY2VfMzQ3IiwiZXJyb3Jfc291cmNlXzM3MiIsImVycm9yX3NvdXJjZV80MTEiLCJlcnJvcl9zb3VyY2VfNDU2IiwiZW51bWVyYXRlXzQ3NCIsImVudW1lcmF0ZV80NzUiLCJtYXliZV9taXNzaW5nX3ByZWZpeCIsIm1heWJlX21pc3Npbmdfc3VmZml4IiwibWF5YmVfbW9yZV9zdWZmaXgiLCJlcnJvcl9zb3VyY2VfNDk5IiwiaW5kZW50YXRpb24iLCJzcGFjaW5nX2RvdCIsImVycm9yX3NvdXJjZV81MTciLCJlcnJvcl9zb3VyY2VfNTQ2IiwiZXJyb3Jfc291cmNlXzU3NCIsImVycm9yX3NvdXJjZV82MDMiLCJ0X29mX3NleHAiLCJjb21wYXJlJDAiLCJhXzAwNiIsImJfMDA3IiwiYV8wMDYkMCIsImJfMDA3JDAiLCJhXzAwOCIsImJfMDA5IiwiYV8wMTAiLCJiXzAxMSIsImFfMDEyIiwiYl8wMTMiLCJhXzAxNCIsImJfMDE1IiwiYV8wMTYiLCJiXzAxNyIsImFfMDE4IiwiYl8wMTkiLCJ0X29mX3NleHAkMCIsInNleHBfMDI0IiwidGFnXzAyNSIsInNleHBfYXJnc18wNDYiLCJhcmcwXzA0NyIsInJlczBfMDQ4Iiwic2V4cF9hcmdzXzA0MSIsImFyZzBfMDQyIiwicmVzMF8wNDMiLCJzZXhwX2FyZ3NfMDMxIiwiYXJnMF8wMzIiLCJyZXMwXzAzMyIsInNleHBfYXJnc18wMzYiLCJhcmcwXzAzNyIsInJlczBfMDM4Iiwic2V4cF9hcmdzXzAyNiIsImFyZzBfMDI3IiwicmVzMF8wMjgiLCJzZXhwX29mX3QkMCIsImFyZzBfMDQ5IiwicmVzMF8wNTAiLCJhcmcwXzA1MSIsInJlczBfMDUyIiwiYXJnMF8wNTMiLCJyZXMwXzA1NCIsImFyZzBfMDU1IiwicmVzMF8wNTYiLCJhcmcwXzA1NyIsInJlczBfMDU4Iiwic3RhYmxlX3dpdG5lc3NfY2hlY2tzX2Zvcl90Iiwic3RhYmxlX3dpdG5lc3MiLCJpbnZhcmlhbnQiLCJ0JDAiLCJ0JDEiLCJ0cyIsInRfb2Zfc2V4cCQxIiwic2V4cCIsInVzYWdlIiwidXNhZ2UkMCIsInVzYWdlJDEiLCJjb21wYXJlJDEiLCJhXzA1OSIsImJfMDYwIiwiYV8wNjEiLCJiXzA2MiIsImFfMDYzIiwiYl8wNjQiLCJ0X29mX3NleHAkMiIsInNleHBfMDY5IiwidGFnXzA3MCIsInNleHBfYXJnc18wNzEiLCJhcmcwXzA3MiIsInJlczBfMDczIiwic2V4cF9hcmdzXzA3NiIsImFyZzBfMDc3IiwicmVzMF8wNzgiLCJzZXhwX29mX3QkMSIsImFyZzBfMDc5IiwicmVzMF8wODAiLCJhcmcwXzA4MSIsInJlczBfMDgyIiwic3RhYmxlX3dpdG5lc3MkMCIsImNvbXBhcmUkMiIsImFfMDgzIiwiYl8wODQiLCJuIiwibiQwIiwiYV8wODUiLCJiXzA4NiIsInRfb2Zfc2V4cCQzIiwieF8wODkiLCJhbGlhc2VzIiwiZG9jIiwibmFtZSIsInNleHBfb2ZfdCQyIiwiYWxpYXNlc18wOTUiLCJkb2NfMDkzIiwibmFtZV8wOTEiLCJhcmdfMDk2IiwiYm5kc18wOTAiLCJhcmdfMDk0IiwiYm5kc18wOTAkMCIsImFyZ18wOTIiLCJibmRzXzA5MCQxIiwic3RhYmxlX3dpdG5lc3MkMSIsImNvbXBhcmUkMyIsImFfMDk3IiwiYl8wOTgiLCJhXzA5OSIsImJfMTAwIiwibiQxIiwiYV8xMDEiLCJiXzEwMiIsInRfb2Zfc2V4cCQ0IiwieF8xMDUiLCJmbGFncyIsImFub25zIiwicmVhZG1lIiwic3VtbWFyeSIsInNleHBfb2ZfdCQzIiwiZmxhZ3NfMTE1IiwiYW5vbnNfMTEzIiwicmVhZG1lXzEwOSIsInN1bW1hcnlfMTA3IiwiYXJnXzExNiIsImJuZHNfMTA2IiwiYXJnXzExNCIsImJuZHNfMTA2JDAiLCJ2XzExMCIsImFyZ18xMTIiLCJibmRfMTExIiwiYm5kc18xMDYkMSIsImFyZ18xMDgiLCJibmRzXzEwNiQyIiwic3RhYmxlX3dpdG5lc3MkMiIsInRfb2Zfc2V4cCQ1IiwieF8xMTkiLCJzZXhwX29mX3QkNCIsImZsYWdzXzEyOSIsInVzYWdlXzEyNyIsInJlYWRtZV8xMjMiLCJzdW1tYXJ5XzEyMSIsImFyZ18xMzAiLCJibmRzXzEyMCIsImFyZ18xMjgiLCJibmRzXzEyMCQwIiwidl8xMjQiLCJhcmdfMTI2IiwiYm5kXzEyNSIsImJuZHNfMTIwJDEiLCJhcmdfMTIyIiwiYm5kc18xMjAkMiIsInN0YWJsZV93aXRuZXNzJDMiLCJ0b19sYXRlc3QiLCJvZl9sYXRlc3QiLCJncmFtbWFyIiwiZ3JvdXAiLCJjb21wYXJlJDQiLCJjbXBfYSIsImFfMTMxIiwiYl8xMzIiLCJhXzEzMyIsImJfMTM0IiwiYV8xMzUiLCJiXzEzNiIsImFfMTM3IiwiYl8xMzgiLCJ0XzE0MCIsInRfMTM5IiwidF8xNDIiLCJ0XzE0MSIsInRfb2Zfc2V4cCQ2Iiwib2ZfYV8xNDMiLCJ4XzE1MSIsInN1YmNvbW1hbmRzIiwic2V4cF8xNTAiLCJhcmcxXzE0NyIsImFyZzBfMTQ2IiwicmVzMF8xNDgiLCJyZXMxXzE0OSIsInNleHBfb2ZfdCQ1Iiwib2ZfYV8xNTIiLCJzdWJjb21tYW5kc18xNjAiLCJyZWFkbWVfMTU2Iiwic3VtbWFyeV8xNTQiLCJibmRzXzE1MyIsImFyZzFfMTYzIiwiYXJnMF8xNjIiLCJyZXMwXzE2NCIsInJlczFfMTY1IiwiYXJnXzE2MSIsImJuZHNfMTUzJDAiLCJ2XzE1NyIsImFyZ18xNTkiLCJibmRfMTU4IiwiYm5kc18xNTMkMSIsImFyZ18xNTUiLCJibmRzXzE1MyQyIiwic3RhYmxlX3dpdG5lc3MkNCIsImFfc3RhYmxlX3dpdG5lc3MiLCJtYXAiLCJmIiwidF9vZl9zZXhwJDciLCJvZl9hXzE3NiIsInhfMTg0Iiwic2V4cF8xODMiLCJhcmcxXzE4MCIsImFyZzBfMTc5IiwicmVzMF8xODEiLCJyZXMxXzE4MiIsInNleHBfb2ZfdCQ2Iiwib2ZfYV8xODUiLCJzdWJjb21tYW5kc18xOTMiLCJyZWFkbWVfMTg5Iiwic3VtbWFyeV8xODciLCJibmRzXzE4NiIsImFyZzFfMTk2IiwiYXJnMF8xOTUiLCJyZXMwXzE5NyIsInJlczFfMTk4IiwiYXJnXzE5NCIsImJuZHNfMTg2JDAiLCJ2XzE5MCIsImFyZ18xOTIiLCJibmRfMTkxIiwiYm5kc18xODYkMSIsImFyZ18xODgiLCJibmRzXzE4NiQyIiwibWFwJDAiLCJ0b19sYXRlc3QkMCIsIm9mX2xhdGVzdCQwIiwiYWJzX3BhdGgiLCJkaXIiLCJwYXRoIiwiY29tcGFyZSQ1IiwiYV8xOTkiLCJiXzIwMCIsImFfMjAxIiwiYl8yMDIiLCJuJDIiLCJhXzIwMyIsImJfMjA0IiwidF9vZl9zZXhwJDgiLCJ4XzIwNyIsImNoaWxkX3N1YmNvbW1hbmQiLCJwYXRoX3RvX2V4ZSIsIndvcmtpbmdfZGlyIiwic2V4cF9vZl90JDciLCJjaGlsZF9zdWJjb21tYW5kXzIxOSIsInBhdGhfdG9fZXhlXzIxNyIsIndvcmtpbmdfZGlyXzIxNSIsInJlYWRtZV8yMTEiLCJzdW1tYXJ5XzIwOSIsImFyZ18yMjAiLCJibmRzXzIwOCIsImFyZ18yMTgiLCJibmRzXzIwOCQwIiwiYXJnXzIxNiIsImJuZHNfMjA4JDEiLCJ2XzIxMiIsImFyZ18yMTQiLCJibmRfMjEzIiwiYm5kc18yMDgkMiIsImFyZ18yMTAiLCJibmRzXzIwOCQzIiwic3RhYmxlX3dpdG5lc3MkNSIsInRvX2xhdGVzdCQxIiwib2ZfbGF0ZXN0JDEiLCJ0X29mX3NleHAkOSIsInhfMjIzIiwic2V4cF9vZl90JDgiLCJwYXRoX3RvX2V4ZV8yMzMiLCJ3b3JraW5nX2Rpcl8yMzEiLCJyZWFkbWVfMjI3Iiwic3VtbWFyeV8yMjUiLCJhcmdfMjM0IiwiYm5kc18yMjQiLCJhcmdfMjMyIiwiYm5kc18yMjQkMCIsInZfMjI4IiwiYXJnXzIzMCIsImJuZF8yMjkiLCJibmRzXzIyNCQxIiwiYXJnXzIyNiIsImJuZHNfMjI0JDIiLCJzdGFibGVfd2l0bmVzcyQ2IiwidG9fdjMiLCJvZl92MyIsInRvX2xhdGVzdCQyIiwib2ZfbGF0ZXN0JDIiLCJ0X29mX3NleHAkMTAiLCJ4XzIzNyIsInNleHBfb2ZfdCQ5IiwicGF0aF90b19leGVfMjQ1IiwicmVhZG1lXzI0MSIsInN1bW1hcnlfMjM5IiwiYXJnXzI0NiIsImJuZHNfMjM4Iiwidl8yNDIiLCJhcmdfMjQ0IiwiYm5kXzI0MyIsImJuZHNfMjM4JDAiLCJhcmdfMjQwIiwiYm5kc18yMzgkMSIsInN0YWJsZV93aXRuZXNzJDciLCJ0b192MiIsIm9mX3YyIiwidG9fbGF0ZXN0JDMiLCJvZl9sYXRlc3QkMyIsImNvbXBhcmUkNiIsImFfMjQ3IiwiYl8yNDgiLCJhXzI0NyQwIiwiYl8yNDgkMCIsImFfMjQ5IiwiYl8yNTAiLCJhXzI1MSIsImJfMjUyIiwiYV8yNTMiLCJiXzI1NCIsImFfMjU3IiwiYV8yNTUiLCJiXzI1OCIsImJfMjU2IiwidF9vZl9zZXhwJDExIiwic2V4cF8yNjMiLCJ0YWdfMjY0Iiwic2V4cF9hcmdzXzI3MCIsImFyZzBfMjcxIiwicmVzMF8yNzIiLCJzZXhwX2FyZ3NfMjc1IiwiYXJnMV8yNzciLCJhcmcwXzI3NiIsInJlczBfMjc4IiwicmVzMV8yNzkiLCJzZXhwX2FyZ3NfMjY1IiwiYXJnMF8yNjYiLCJyZXMwXzI2NyIsInNleHBfb2ZfdCQxMCIsImFyZzBfMjgwIiwicmVzMF8yODEiLCJhcmcwXzI4MiIsInJlczBfMjgzIiwiYXJnMV8yODUiLCJhcmcwXzI4NCIsInJlczBfMjg2IiwicmVzMV8yODciLCJzdGFibGVfd2l0bmVzc19jaGVja3NfZm9yX3QkMCIsInN0YWJsZV93aXRuZXNzJDgiLCJ0X29mX3NleHAkMTIiLCJzZXhwXzI5MiIsInRhZ18yOTMiLCJzZXhwX2FyZ3NfMzA5IiwiYXJnMF8zMTAiLCJyZXMwXzMxMSIsInNleHBfYXJnc18yOTkiLCJhcmcwXzMwMCIsInJlczBfMzAxIiwic2V4cF9hcmdzXzMwNCIsImFyZzBfMzA1IiwicmVzMF8zMDYiLCJzZXhwX2FyZ3NfMjk0IiwiYXJnMF8yOTUiLCJyZXMwXzI5NiIsInNleHBfb2ZfdCQxMSIsImFyZzBfMzEyIiwicmVzMF8zMTMiLCJhcmcwXzMxNCIsInJlczBfMzE1IiwiYXJnMF8zMTYiLCJyZXMwXzMxNyIsImFyZzBfMzE4IiwicmVzMF8zMTkiLCJzdGFibGVfd2l0bmVzc19jaGVja3NfZm9yX3QkMSIsInRfb2Zfc2V4cCQxMyIsInNleHBfMzI0IiwidGFnXzMyNSIsInNleHBfYXJnc18zMzEiLCJhcmcwXzMzMiIsInJlczBfMzMzIiwic2V4cF9hcmdzXzMzNiIsImFyZzBfMzM3IiwicmVzMF8zMzgiLCJzZXhwX2FyZ3NfMzI2IiwiYXJnMF8zMjciLCJyZXMwXzMyOCIsInNleHBfb2ZfdCQxMiIsImFyZzBfMzM5IiwicmVzMF8zNDAiLCJhcmcwXzM0MSIsInJlczBfMzQyIiwiYXJnMF8zNDMiLCJyZXMwXzM0NCIsInN0YWJsZV93aXRuZXNzX2NoZWNrc19mb3JfdCQyIiwidG9fbGF0ZXN0JDQiLCJiIiwiZyIsImUiLCJvZl9sYXRlc3QkNCIsInRodW5rIiwidF9vZl9zZXhwJDE0Iiwic2V4cF8zNDkiLCJ0YWdfMzUwIiwic2V4cF9hcmdzXzM1NiIsImFyZzBfMzU3IiwicmVzMF8zNTgiLCJzZXhwX2FyZ3NfMzYxIiwiYXJnMF8zNjIiLCJyZXMwXzM2MyIsInNleHBfYXJnc18zNTEiLCJhcmcwXzM1MiIsInJlczBfMzUzIiwic2V4cF9vZl90JDEzIiwiYXJnMF8zNjQiLCJyZXMwXzM2NSIsImFyZzBfMzY2IiwicmVzMF8zNjciLCJhcmcwXzM2OCIsInJlczBfMzY5Iiwic3RhYmxlX3dpdG5lc3NfY2hlY2tzX2Zvcl90JDMiLCJ0b19sYXRlc3QkNSIsIm9mX2xhdGVzdCQ1IiwidF9vZl9zZXhwJDE1Iiwic2V4cF8zNzQiLCJ0YWdfMzc1Iiwic2V4cF9hcmdzXzM4NiIsImFyZzBfMzg3IiwicmVzMF8zODgiLCJzZXhwX2FyZ3NfMzgxIiwiYXJnMF8zODIiLCJyZXMwXzM4MyIsInNleHBfYXJnc18zNzYiLCJhcmcwXzM3NyIsInJlczBfMzc4Iiwic2V4cF9vZl90JDE0IiwiYXJnMF8zODkiLCJyZXMwXzM5MCIsImFyZzBfMzkxIiwicmVzMF8zOTIiLCJhcmcwXzM5MyIsInJlczBfMzk0IiwidjEiLCJ2MCIsInYyIiwidjMiLCJ2MSQwIiwidjIkMCIsInYzJDAiLCJvZl92ZXJzaW9uZWQiLCJjb21wYXJlJDciLCJhXzM5NSIsImJfMzk2IiwiYV8zOTUkMCIsImJfMzk2JDAiLCJhXzM5NyIsImJfMzk4IiwiYV8zOTkiLCJiXzQwMCIsImFfNDAxIiwiYl80MDIiLCJhXzQwMyIsImJfNDA0IiwiYV80MDUiLCJiXzQwNiIsImFfNDA3IiwiYl80MDgiLCJ0X29mX3NleHAkMTYiLCJzZXhwXzQxMyIsInRhZ180MTQiLCJzZXhwX2FyZ3NfNDM1IiwiYXJnMF80MzYiLCJyZXMwXzQzNyIsInNleHBfYXJnc180MzAiLCJhcmcwXzQzMSIsInJlczBfNDMyIiwic2V4cF9hcmdzXzQyMCIsImFyZzBfNDIxIiwicmVzMF80MjIiLCJzZXhwX2FyZ3NfNDI1IiwiYXJnMF80MjYiLCJyZXMwXzQyNyIsInNleHBfYXJnc180MTUiLCJhcmcwXzQxNiIsInJlczBfNDE3Iiwic2V4cF9vZl90JDE1IiwiYXJnMF80MzgiLCJyZXMwXzQzOSIsImFyZzBfNDQwIiwicmVzMF80NDEiLCJhcmcwXzQ0MiIsInJlczBfNDQzIiwiYXJnMF80NDQiLCJyZXMwXzQ0NSIsImFyZzBfNDQ2IiwicmVzMF80NDciLCJjb21wYXJlJDgiLCJhXzQ0OCIsImJfNDQ5IiwiYV80NTAiLCJiXzQ1MSIsImFfNDUyIiwiYl80NTMiLCJ0X29mX3NleHAkMTciLCJzZXhwXzQ1OCIsInRhZ180NTkiLCJzZXhwX2FyZ3NfNDYwIiwiYXJnMF80NjEiLCJyZXMwXzQ2MiIsInNleHBfYXJnc180NjUiLCJhcmcwXzQ2NiIsInJlczBfNDY3Iiwic2V4cF9vZl90JDE2IiwiYXJnMF80NjgiLCJyZXMwXzQ2OSIsImFyZzBfNDcwIiwicmVzMF80NzEiLCJjb21wYXJlJDkiLCJhXzQ3MiIsImJfNDczIiwiYWNjIiwiZW51bWVyYXRlXzQ3OCIsImVudW1lcmF0ZV80NzkiLCJlbnVtZXJhdGVfNDc3IiwiZW51bWVyYXRlXzQ4MCIsImVudW1lcmF0ZV80NzYiLCJhY2MkMCIsImVudW1lcmF0ZV80ODAkMCIsInNleHBfb2ZfdCQxNyIsImF0X21vc3Rfb25jZV80ODQiLCJhdF9sZWFzdF9vbmNlXzQ4MiIsImFyZ180ODUiLCJibmRzXzQ4MSIsImFyZ180ODMiLCJibmRzXzQ4MSQwIiwidG9faGVscF9zdHJpbmciLCJmbGFnX25hbWUiLCJhdF9tb3N0X29uY2UiLCJhdF9sZWFzdF9vbmNlIiwiZGVzY3JpcHRpb24iLCJvZl9oZWxwX3N0cmluZyIsIm5hbWUkMCIsIm5hbWUkMSIsIm5hbWUkMiIsIm5hbWUkMyIsInhfNDg2IiwicyIsInhfNDg3IiwiY29tcGFyZSQxMCIsImFfNDk0IiwiYl80OTUiLCJhXzQ5NiIsImJfNDk3IiwiciIsInRfb2Zfc2V4cCQxOCIsInhfNTAwIiwic2V4cF9vZl90JDE4IiwiYWxpYXNlc181MDYiLCJkb2NfNTA0IiwibmFtZV81MDIiLCJhcmdfNTA3IiwiYm5kc181MDEiLCJhcmdfNTA1IiwiYm5kc181MDEkMCIsImFyZ181MDMiLCJibmRzXzUwMSQxIiwicGFyc2VfbmFtZSIsIm51bV9vY2N1cnJlbmNlcyIsInJlcXVpcmVzX2FyZyIsImhlbHBfc2NyZWVuX2NvbXBhcmUiLCJhIiwic29ydCIsIndvcmRfd3JhcF9hbmRfc3RyaXAiLCJ0ZXh0Iiwid2lkdGgiLCJjaHVua3MiLCJ3b3JkIiwid29yZHMiLCJsaW5lIiwibGluZXMiLCJsaW5lX2FuZF93b3JkIiwic3BhY2VzX3N0cmluZyIsInBhZF9zcGFjZXNfdG9fc3VmZml4IiwieCIsInNsYWNrIiwiaW5kZW50X2FuZF9uZXdsaW5lIiwibGhzX3BhZCIsImRvdF9pbmRlbnRhdGlvbl9vZmZzZXQiLCJ2IiwiZmxhZyIsImZsYWdfbmFtZV93aXRoX2FsaWFzZXMiLCJkb2N1bWVudGF0aW9uIiwiZmxhZ193aWR0aCIsImZsYWdfb25faXRzX293bl9saW5lIiwid3JhcHBlZF9kb2N1bWVudGF0aW9uIiwiZG9jX3dyYXBwZWRfcmVzdF9saW5lcyIsImRvY193cmFwcGVkX2ZpcnN0X2xpbmUiLCJ3cmFwcGVkX2RvY19saW5lcyIsInByZWZpeF9kb2Nfd3JhcHBlZF9maXJzdF9saW5lXyIsInRvX3N0cmluZyQwIiwibG9va3VwX2V4cGFuZCIsImFsaXN0IiwicHJlZml4Iiwia2V5X3R5cGUiLCJpc19kYXNoIiwiZGF0YSIsImtleSIsImFsaXN0JDAiLCJtYXRjaGVzIiwiY3VzdG9tX3ByaW50Zl81MDgiLCJkYXRhJDAiLCJrZXkkMCIsIm1hdGNoaW5nX2tleXMiLCJjdXN0b21fcHJpbnRmXzUwOSIsImNvbXBhcmUkMTEiLCJhXzUxMCIsImJfNTExIiwiYV81MTIiLCJiXzUxMyIsImFfNTE0IiwiYl81MTUiLCJ0X29mX3NleHAkMTkiLCJ4XzUxOCIsInNleHBfb2ZfdCQxOSIsImZsYWdzXzUyOCIsImFub25zXzUyNiIsInJlYWRtZV81MjIiLCJzdW1tYXJ5XzUyMCIsImFyZ181MjkiLCJibmRzXzUxOSIsImFyZ181MjciLCJibmRzXzUxOSQwIiwidl81MjMiLCJhcmdfNTI1IiwiYm5kXzUyNCIsImJuZHNfNTE5JDEiLCJhcmdfNTIxIiwiYm5kc181MTkkMiIsImZpbmRfZmxhZyIsImNob2ljZXMiLCJmbGFnX2luZm8iLCJnZXRfdXNhZ2UiLCJjb21wYXJlJDEyIiwiYV81MzIiLCJiXzUzMyIsImFfNTM0IiwiYl81MzUiLCJhXzUzNiIsImJfNTM3IiwiYV81MzgiLCJiXzUzOSIsInRfNTQxIiwidF81NDAiLCJ0XzU0MyIsInRfNTQyIiwicmVhZG1lJDAiLCJzdW1tYXJ5JDAiLCJ0X29mX3NleHAkMjAiLCJvZl9hXzU0NCIsInhfNTUyIiwic2V4cF81NTEiLCJhcmcxXzU0OCIsImFyZzBfNTQ3IiwicmVzMF81NDkiLCJyZXMxXzU1MCIsInNleHBfb2ZfdCQyMCIsIm9mX2FfNTUzIiwic3ViY29tbWFuZHNfNTYxIiwicmVhZG1lXzU1NyIsInN1bW1hcnlfNTU1IiwiYm5kc181NTQiLCJhcmcxXzU2NCIsImFyZzBfNTYzIiwicmVzMF81NjUiLCJyZXMxXzU2NiIsImFyZ181NjIiLCJibmRzXzU1NCQwIiwidl81NTgiLCJhcmdfNTYwIiwiYm5kXzU1OSIsImJuZHNfNTU0JDEiLCJhcmdfNTU2IiwiYm5kc181NTQkMiIsImZpbmRfc3ViY29tbWFuZCIsImNvbXBhcmUkMTMiLCJhXzU2NyIsImJfNTY4IiwiYV81NjkiLCJiXzU3MCIsImFfNTcxIiwiYl81NzIiLCJ0X29mX3NleHAkMjEiLCJ4XzU3NSIsInNleHBfb2ZfdCQyMSIsImNoaWxkX3N1YmNvbW1hbmRfNTg3IiwicGF0aF90b19leGVfNTg1Iiwid29ya2luZ19kaXJfNTgzIiwicmVhZG1lXzU3OSIsInN1bW1hcnlfNTc3IiwiYXJnXzU4OCIsImJuZHNfNTc2IiwiYXJnXzU4NiIsImJuZHNfNTc2JDAiLCJhcmdfNTg0IiwiYm5kc181NzYkMSIsInZfNTgwIiwiYXJnXzU4MiIsImJuZF81ODEiLCJibmRzXzU3NiQyIiwiYXJnXzU3OCIsImJuZHNfNTc2JDMiLCJjb21wYXJlJDE0IiwiYV81ODkiLCJiXzU5MCIsImFfNTg5JDAiLCJiXzU5MCQwIiwiYV81OTEiLCJiXzU5MiIsImFfNTkzIiwiYl81OTQiLCJhXzU5NSIsImJfNTk2IiwiYV81OTkiLCJhXzU5NyIsImJfNjAwIiwiYl81OTgiLCJ0X29mX3NleHAkMjIiLCJzZXhwXzYwNSIsInRhZ182MDYiLCJzZXhwX2FyZ3NfNjEyIiwiYXJnMF82MTMiLCJyZXMwXzYxNCIsInNleHBfYXJnc182MTciLCJhcmcxXzYxOSIsImFyZzBfNjE4IiwicmVzMF82MjAiLCJyZXMxXzYyMSIsInNleHBfYXJnc182MDciLCJhcmcwXzYwOCIsInJlczBfNjA5Iiwic2V4cF9vZl90JDIyIiwiYXJnMF82MjIiLCJyZXMwXzYyMyIsImFyZzBfNjI0IiwicmVzMF82MjUiLCJhcmcxXzYyNyIsImFyZzBfNjI2IiwicmVzMF82MjgiLCJyZXMxXzYyOSIsImV4cGFuZGVkX3N1YmNvbW1hbmRzIiwiZXhwYW5kIiwic2V4cF9vZl90JDIzIiwiYXJnMF82MzAiLCJyZXMwXzYzMSIsImFyZzBfNjMyIiwicmVzMF82MzMiLCJhcmcwXzYzNCIsInJlczBfNjM1IiwiYXJnMF82MzYiLCJyZXMwXzYzNyIsImV4dHJhY3Rpb25fdmFyIiwiaSIsInN1cHBvcnRlZCIsImluaXQiLCJzdXBwb3J0ZWRfdmVyc2lvbnMiLCJ0b192ZXJzaW9uZWQiLCJsYXRlc3QiLCJ2ZXJzaW9uX3RvX3VzZSIsImZ1bGx5X2ZvcmNlZCIsImdldF9zdW1tYXJ5Iiwib3B0IiwidmVyc2lvbl9saXN0IiwiZW51bWVyYXRlXzAwOCIsImVudW1lcmF0ZV8wMDkiLCJhbnkiLCJleGFjdGx5X29uY2UiLCJyYWlzZV9pbnN0ZWFkX29mX2V4aXQiLCJzdGF0dXNfMDAyIiwiYXJnXzAwMyIsImV4aXQiLCJzdGF0dXMiLCJ1bnBhcmFncmFwaHMiLCJ4cyIsImRpZSIsImZtdCIsIm1zZyIsImtleV9jcmVhdGUiLCJtdWx0aV9hZGQiLCJzZXRfd2l0aF9kZWZhdWx0Iiwia2V5X2ludGVybmFsX3ZhbGlkYXRlX3BhcnNpbmciLCJhcHBseSIsImVycl8xIiwiaW50cm9kdWNlX21pc3NpbmdfcmVxdWlyZWRfZmxhIiwiaGFzX2FyZyIsInJlc3VsdCIsInJldHVybl9ub19hcmciLCJyZXR1cm5fd2l0aF9hcmciLCJlcnJvciIsImVyciIsInJ1bl9hbmRfZXhpdCIsImVudiIsInBhcnQiLCJjb21wbGV0aW9ucyIsImV4dHJhX2RvYyIsInBhcnNlIiwiY3JlYXRlIiwiY29tcGxldGUiLCJvZl9zdHJpbmciLCJtYXAkMSIsIm9mX2xhenkiLCJzdHIiLCJleHRyYV9kb2MkMCIsInN0cmluZyIsImludCQwIiwiY2hhciQwIiwiZmxvYXQkMCIsInNleHBfY29udiIsIm9mX3NleHAiLCJvZl9hbGlzdF9leG4iLCJhY2NlcHRfdW5pcXVlX3ByZWZpeGVzJDAiLCJsaXN0X3ZhbHVlc19pbl9oZWxwJDAiLCJhdXRvX2NvbXBsZXRlIiwic3RoJDEiLCJjYXNlX3NlbnNpdGl2ZSIsInN0aCIsImFjY2VwdF91bmlxdWVfcHJlZml4ZXMiLCJzdGgkMCIsImxpc3RfdmFsdWVzX2luX2hlbHAiLCJtYWtlIiwiY21wIiwiayIsImR1cGxpY2F0ZV9rZXlzIiwiUyIsInVuaXZfbWFwIiwic3VmZml4IiwidmFsdWVzIiwiYXJnIiwidiQwIiwidmFsaWRfYXJndW1lbnRzX2V4dHJhIiwib2ZfbWFwIiwiZW51bWVyYXRlZCIsIkUiLCJlbnVtZXJhdGVkX3NleHBhYmxlIiwiYm9vbCIsImNvbW1hX3NlcGFyYXRlZCIsImFsbG93X2VtcHR5Iiwic3RyaXBfd2hpdGVzcGFjZSIsInVuaXF1ZV92YWx1ZXMiLCJzdHJpcCIsImNvbXBsZXRlX2VsdCIsInRsIiwiaGQiLCJwcmVmaXhlcyIsInNlZW5fYWxyZWFkeSIsImlzX2FsbG93ZWQiLCJjaG9pY2UiLCJjaG9pY2VzJDAiLCJzdHJpbmckMCIsImVudW1lcmF0ZV8wMTIiLCJlbnVtZXJhdGVfMDEzIiwiZW51bWVyYXRlXzAxMSIsImVudW1lcmF0ZV8wMTQiLCJlbnVtZXJhdGVfMDEwIiwiZW51bWVyYXRlXzAxNCQwIiwicGFyc2UkMCIsImFjdGlvbiIsImRvYyQwIiwiYXJnX2RvYyIsImRvYyQxIiwiYXJnX2RvYyQwIiwiY29uY2F0Iiwid3JhcF9pZl9vcHRpb25hbCIsImhlbHAiLCJhbGlnbiIsImNyZWF0ZSQwIiwiYV8wMjAiLCJiXzAyMSIsImFyZ19mbGFnIiwiYXJnX3R5cGUiLCJyZWFkIiwid3JpdGUiLCJ1cGRhdGUiLCJhcmckMCIsImVudiQwIiwibWFwX2ZsYWciLCJpbnB1dCIsIndyaXRlX29wdGlvbiIsInJlcXVpcmVkX3ZhbHVlIiwiZGVmYXVsdCQwIiwicmVxdWlyZWQiLCJvcHRpb25hbF93aXRoX2RlZmF1bHQiLCJvcHRpb25hbCIsInZhbHVlIiwibm9fYXJnX2dlbmVyYWwiLCJpc19yZXF1aXJlZCIsImtleV92YWx1ZSIsImRlcHJlY2F0ZWRfaG9vayIsImFjdGlvbiQwIiwibm9fYXJnIiwibm9fYXJnX3JlcXVpcmVkIiwibm9fYXJnX3JlZ2lzdGVyIiwibm9fYXJnX3NvbWUiLCJsaXN0ZWQiLCJ4XzAyMiIsInZhbHVlX2xpc3QiLCJsaXN0Iiwib25lX29yX21vcmVfYXNfcGFpciIsInhfMDIzIiwicmVzdCIsImZpcnN0IiwicSIsIm9uZV9vcl9tb3JlX2FzX2xpc3QiLCJlc2NhcGVfZ2VuZXJhbCIsInhfMDI0IiwiY21kX2xpbmUiLCJub19hcmdfYWJvcnQiLCJlc2NhcGUiLCJlc2NhcGVfd2l0aF9hdXRvY29tcGxldGUiLCJub19hcmckMCIsImhvb2siLCJlc2NhcGUkMCIsImVtcHR5JDAiLCJjcmVhdGUkMSIsImFwcGVuZCIsInN1YmNvbW1hbmQiLCJwYXJ0cyIsInBhcnRzX2V4ZV9iYXNlbmFtZSIsImxlbmd0aCIsInJlcGxhY2VfZmlyc3QiLCJmcm9tIiwidG8iLCJwYXJ0cyQyIiwicGFydHMkMCIsInBhcnRzJDEiLCJ0b19zdHJpbmdfZG90cyIsImxhc3QiLCJpc19lbXB0eSIsImlzX2ZpeGVkX2FyaXR5Iiwib3RoZXJzIiwibmFtZXMiLCJzJDAiLCJ6ZXJvIiwiY29uY2F0JDAiLCJjZHIiLCJjYXIiLCJ0MiIsInQxIiwiY2RyJDAiLCJjYXIkMCIsInBhcnNlX21vcmUiLCJmb3JfY29tcGxldGlvbiIsInVwZGF0ZV9lbnYiLCJwYXJzZXIiLCJwYWNrX2Zvcl9jb21wbGV0aW9uIiwicHMiLCJzeW1ib2wkMCIsInRfbGVmdCIsInRfcmlnaHQiLCJmX291dGNvbWUiLCJ4X291dGNvbWUiLCJtb3JlIiwidHIiLCJ0ZXN0IiwibW9yZSQwIiwidGVzdCQwIiwicmV0dXJuJDEiLCJzeW1ib2xfbWFwIiwiZnJvbV9lbnYiLCJzeW1ib2xfbWFwJDAiLCJzeW1ib2wkMSIsInJldHVybiQyIiwicmV0dXJuX3dpdGhfYXJnJDAiLCJvbmUiLCJhbm9uIiwic2VxdWVuY2UiLCJsb29wIiwiY29uc3VtZSIsInBhY2tlZCIsInQkMiIsInVwZGF0ZV9lbnYkMCIsInBhcnNlX2ZsYWdzIiwicGFyc2VyJDAiLCJ0JDMiLCJhMSIsImEyIiwidDMiLCJhMyIsInQ0IiwiYTQiLCJub3JtYWxpemUiLCJzdHJsZW4iLCJzcGVjaWFsX2NoYXJzIiwiaGFzX3NwZWNpYWxfY2hhcnMiLCJzeW1ib2wkMiIsIm1hcF9hbm9ucyIsIm1heWJlIiwibWF5YmVfd2l0aF9kZWZhdWx0Iiwic2VxdWVuY2UkMCIsIm5vbl9lbXB0eV9zZXF1ZW5jZV9hc19wYWlyIiwibm9uX2VtcHR5X3NlcXVlbmNlX2FzX2xpc3QiLCJhZF9ob2MiLCJ1c2FnZV9hcmciLCJhXzAyNSIsImJfMDI2IiwiYV8wMjUkMCIsImJfMDI2JDAiLCJhXzAyOSIsImFfMDI3IiwiYl8wMzAiLCJiXzAyOCIsImFfMDMxIiwiYl8wMzIiLCJvZl9saXN0IiwiYXJncyIsInRvX2xpc3QiLCJ4JDAiLCJlbmRzX2luX2NvbXBsZXRlIiwiZXh0ZW5kIiwicGF0aF9saXN0Iiwibm9ybWFsaXplJDAiLCJmbGFnX29yX3N1YmNvbW1hbmQiLCJjIiwiY3VzdG9tX3ByaW50Zl8wMzMiLCJjdXN0b21fcHJpbnRmXzAzNCIsInN1YmNvbW1hbmRfY21wX2ZzdCIsInNoYXBlIiwicGF0aF9rZXkiLCJhcmdzX2tleSIsImhlbHBfa2V5Iiwibm9ybWFsaXplZF9wYXRoIiwibm9ybWFsaXplZF9hcmdzIiwiZ2V0X2ZsYWdfYW5kX2FjdGlvbiIsIm5hbWVfbWF0Y2hpbmciLCJhbGlhc2VzX2V4Y2x1ZGVkX2Zyb21faGVscCIsImFsaWFzZXMkMCIsImFsaWFzIiwiczIiLCJzMSIsImZsYWckMCIsInJ1bl9leG4iLCJleG4iLCJ2ZXJib3NlX29uX3BhcnNlX2Vycm9yIiwiZXhuX3N0ciIsInZlcmJvc2UiLCJlcnJvcl9tc2ciLCJydW4iLCJ3aGVuX3BhcnNpbmdfc3VjY2VlZHMiLCJjbWRsaW5lIiwiaGVscF90ZXh0Iiwib25fZmFpbHVyZSIsInBhcnNlciQxIiwiZW52JDEiLCJjbWRsaW5lJDAiLCJub3JtYWxpemVkX2FyZ3MkMCIsImFyZyQxIiwiYXJncyQwIiwiYXJnJDMiLCJhcmdfaXNfZmxhZyIsImNtZGxpbmUkMSIsImFyZyQyIiwibm9ybWFsaXplZF9hcmdzJDEiLCJmJDEiLCJpbmZvIiwiY29tcGxldGluZyIsImNvbXAiLCJmJDIiLCJlJDAiLCJjb21wJDAiLCJmJDMiLCJhcmdfbGlzdCIsImNtZGxpbmUkMiIsImVudiQyIiwicGFyc2VfZmxhZ3MyIiwiZW52JDMiLCJwYXJzZV9mbGFncyQwIiwibm9ybWFsaXplZF9hcmdzJDIiLCJwYXJ0JDAiLCJmJDAiLCJ0JDQiLCJ0JDUiLCJ0JDYiLCJ0JDciLCJwYXJzZWRfbm9ybWFsaXplZF9hcmdzIiwibWFpbiIsImlzX3VzaW5nX3ZhbGlkYXRlX3BhcnNpbmciLCJ3cmFwX3ZhbHVlIiwiYXBwbHkkMSIsImVtcHR5X3NwZWMiLCJtYXBfb3V0Y29tZSIsIm1hcCQyIiwibG9va3VwIiwiaGVscCQwIiwiaW50JDEiLCJjaGFyJDEiLCJmbG9hdCQxIiwiYm9vbCQwIiwic2V4cCQwIiwic2V4cF9jb252JDAiLCJzcGVjIiwib3V0Y29tZSIsImVzY2FwZV9hbm9uIiwiZmluYWxfYW5vbiIsImZ1bGxfZmxhZ19yZXF1aXJlZCIsIm1vZGUiLCJjaGVja19hdmFpbGFibGUiLCJmbGFnX29wdGlvbmFsX3dpdGhfZGVmYXVsdF9kb2MiLCJzZXhwX29mX2RlZmF1bHQiLCJkZWZhdWx0X3NleHAiLCJjdXN0b21fcHJpbnRmXzAzNSIsInJldHVybiQzIiwib3B0aW9uYWxfdG9fcmVxdWlyZWQiLCJtYXAkMyIsImJvdGgiLCJhcmdfbmFtZXMiLCJmbGFnX25hbWVzIiwiYW5vbl9uYW1lcyIsImFfMDM2IiwiYl8wMzciLCJhXzAzOCIsImJfMDM5IiwiYV8wNDAiLCJiXzA0MSIsInhfMDQyIiwiY3JlYXRlX2V4biIsInJlcXVpcmVkX2FyZ3MiLCJuYW1lc193aXRoX2NvbW1hcyIsInhfMDQzIiwibGlzdF90b19zdHJpbmciLCJjaG9vc2Vfb25lX25vbl9vcHRpb25hbCIsImlmX25vdGhpbmdfY2hvc2VuIiwibmV3X2JlaGF2aW9yIiwibmFtZV9vZl90aGVfZ3JvdXAiLCJmbGFnX2ludGVybmFsIiwiZXhjZXB0IiwibCIsInRzJDAiLCJhcmdfY291bnRlciIsIm1vcmVfdGhhbl9vbmVfZXJyb3IiLCJwYXNzZWQiLCJjdXN0b21fcHJpbnRmXzA0NCIsImVycm9yX2xpc3QiLCJzdWNjZXNzX2xpc3QiLCJ2YWx1ZSQwIiwiY3VzdG9tX3ByaW50Zl8wNDUiLCJjaG9vc2Vfb25lIiwiY2hvb3NlX29uZV9ub25fb3B0aW9uYWwkMCIsImxzdCIsImFuZF9hcmdfbmFtZXMiLCJhbmRfYXJnX25hbWUiLCJwYXJzZSQxIiwicGFyYW1zIiwic3ltYm9sJDYiLCJmMSIsImYyIiwic3ltYm9sJDciLCJwMiIsInN5bWJvbCQ4Iiwic3RlcCIsImNvbnN0JDAiLCJ3cmFwIiwib2ZfcGFyYW0iLCJwIiwidG9fcGFyYW0iLCJtIiwic3RyaW5nJDEiLCJpbnQkMiIsImNoYXIkMiIsImZsb2F0JDIiLCJib29sJDEiLCJzZXhwJDEiLCJzZXhwX2NvbnYkMSIsIm1hcCQ1IiwiZmxhZ3Nfb2ZfYXJnc19leG4iLCJnZW4iLCJmbGFnX3R5cGUiLCJjYWxsIiwic2V0Iiwic2V0X2Jvb2wiLCJyJDAiLCJyJDEiLCJyJDIiLCJyJDMiLCJmJDQiLCJzeW1zIiwic3ltIiwiZiQ1Iiwic2hhcGUkMCIsInN1YmNvbW1hbmRfdG9fc2hhcGUiLCJjb21wX2N3b3JkIiwic2hhcGUkMSIsInNleHBhYmxlX3NoYXBlIiwiYmFzZSIsImV4ZWMiLCJleHRlbmRfZXhuIiwibWVtIiwiYWRkIiwiZXh0ZW5kX21hcF9leG4iLCJleHRlbmRfYWxpc3RfZXhuIiwidGV4dF9zdW1tYXJ5IiwiZmxhZ3MkMCIsImJhc2ljIiwiZmxhZ3MkMSIsImJhc2UkMCIsImJhc2ljX3NwZWMiLCJzdWJzX2tleSIsImxhenlfZ3JvdXAiLCJwcmVzZXJ2ZV9zdWJjb21tYW5kX29yZGVyIiwiYm9keSIsInAkMCIsInBhdGhfdG9fZXhlJDAiLCJwJDEiLCJwJDIiLCJvZl9sYXp5JDAiLCJwcm94eV9vZl9zZXhwYWJsZSIsInNleHBhYmxlIiwicGF0aF90b19zdWJjb21tYW5kIiwia2luZCIsImtpbmRfb2Zfc2V4cGFibGUiLCJwYXRoX3RvX3N1YmNvbW1hbmQkMCIsInByb3h5IiwicHJpbnRfdmVyc2lvbiIsInZlcnNpb24iLCJwcmludF9idWlsZF9pbmZvIiwiYnVpbGRfaW5mbyIsImNvbW1hbmQiLCJ2ZXJzaW9uX2ZsYWciLCJidWlsZF9pbmZvX2ZsYWciLCJhZGQkMCIsInVudmVyc2lvbmVkIiwiYmFzZSQxIiwibm9ybWFsaXplX3ZlcnNpb25fbGluZXMiLCJkZWZhdWx0X3ZlcnNpb24iLCJkZWZhdWx0X2J1aWxkX2luZm8iLCJyZXByaW50X2J1aWxkX2luZm8iLCJ0b19zZXhwIiwieCQxIiwicGF0aCQwIiwiZ2V0X2ZsYWdfbmFtZXMiLCJoZWxwX3JlY3Vyc2l2ZSIsImNtZCIsIndpdGhfZmxhZ3MiLCJleHBhbmRfZG90cyIsImhlbHBfcmVjdXJzaXZlX3JlYyIsImNtZCQwIiwibmV3X3MiLCJiYXNlX2hlbHAiLCJoIiwiZGlzcGxheV9oZWxwX2ZsYWdzIiwiYXV0b2NvbXBsZXRlX2Z1bmN0aW9uIiwiYXJndl8wIiwicGlkIiwiZm5hbWUiLCJwYXRoJDEiLCJiYXNpYyQwIiwicGFyYW0iLCJiYXNpY19vcl9lcnJvciIsIm5vcm1hbGl6ZWRfcGF0aCQwIiwid29yZF93cmFwIiwidG9fc3RyaW5nX2Zvcl9jaG9vc2Vfb25lIiwicnVuJDAiLCJzaGFwZSQyIiwiZ2V0cGlkIiwiY2xvc2UiLCJpbl9jaGFubmVsX29mX2Rlc2NyIiwid2FpdCIsImdldGVudl9hbmRfY2xlYXIiLCJ2YXIkMCIsIm9mX2V4dGVybmFsIiwiaGVscF9zZXhwIiwicHJvZyIsImFyZ3YwIiwicHJvZ19zZWFyY2hfcGF0aCIsIndvcmtpbmdfZGlyJDAiLCJjb252ZXJ0X2NvbW1hbmRfZW52X3Zhcl90b19zdHIiLCJlbnZfdmFyIiwibGlzdCQwIiwibGlzdCQxIiwicHJvY2Vzc19pbmZvIiwic3RhcnRfcmVhZGluZyIsImRlc2NyIiwib3V0cHV0IiwidGhyZWFkIiwib3V0cHV0JDAiLCJmaW5pc2hfc3Rkb3V0IiwiZmluaXNoX3N0ZGVyciIsInN0ZGVyciIsInN0ZG91dCIsImV4biQwIiwic2hhcGVfb2ZfcHJveHkiLCJzaGFwZV9vZl9wcm94eV9raW5kIiwic2hhcGVfb2ZfZXhlIiwiZ3JvdXBfb3JfZXhlY19oZWxwX3RleHQiLCJmb3JtYXRfbGlzdCIsImhlbHBfZm9yX3NoYXBlIiwicmVjdXJzaXZlIiwic3RyaW5nX29mX3BhdGgiLCJmbXQkMCIsImZpbHRlcmVkX3N1YmNvbW1hbmRzIiwic3ViY29tbWFuZHMkMCIsImFkZF9oZWxwX3N1YmNvbW1hbmRzIiwiY21kX29wdCIsInN1YnMiLCJwb3NzaWJseV9leHBhbmRlZF9uYW1lIiwicGF0aCQyIiwicGF0aCQzIiwibWF5YmVfYXBwbHlfZXh0ZW5kIiwiZXh0ZW5kJDAiLCJkaXNwYXRjaCIsIm1heWJlX25ld19jb21wX2N3b3JkIiwiY29tcGxldGVfc3ViY29tbWFuZHMiLCJhcmdzJDEiLCJkaWVfc2hvd2luZ19oZWxwIiwicGFyc2VfZ3JvdXAiLCJtYXliZV9uZXdfY29tcF9jd29yZCQwIiwic2tpcCIsInJlc29sdmUiLCJzdWIiLCJzdWJzJDAiLCJzdWIkMCIsImJvZHkkMCIsInRvX291dHB1dCIsInJlc3Rfb2ZfcmVzdCIsImZpcnN0X29mX3Jlc3QiLCJhcmdzJDIiLCJuZXdfdmFsdWUkMCIsIm5ld192YWx1ZSIsImFkZF92YWxpZGF0ZV9wYXJzaW5nX2ZsYWciLCJhcmd2IiwiYnVpbGRfaW5mbyQwIiwidmVyc2lvbiQwIiwic3VwcG9ydGVkX3ZlcnNpb25zJDAiLCJwYXRoX3RvX3N1YmNvbW1hbmQkMSIsInBhdGhfdG9fc3ViY29tbWFuZCQyIiwiY29tcF9jd29yZCQwIiwiZGVwcmVjYXRlZF9ydW4iLCJpc19oZWxwIiwiaXNfaGVscF9yZWMiLCJpc19oZWxwX3JlY19mbGFncyIsImlzX2V4cGFuZF9kb3RzIiwicGF0aF9zdHJpbmdzIiwiYXJncyQzIiwiYXJncyQ0Il0sInNvdXJjZXMiOlsiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2NvcmUvY29tbWFuZC9jb21tYW5kX18ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvY29yZS9jb21tYW5kL2ltcG9ydC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9jb3JlL2NvbW1hbmQvZW52X3Zhci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9jb3JlL2NvbW1hbmQvc2hhcGUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvY29yZS9jb21tYW5kL2NvbW1hbmQubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0FjbUI7O0lBQUE7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNYYkE7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFRQUM7SUFDQUM7SUFDQUM7Ozs7Ozs7O09BZkFSO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BUUFDO09BQ0FDO09BQ0FDOzs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUNmTkM7Ozs7Ozs7Ozs7O0dBQUE7SUFBQUM7Ozs7OztZQUFBQztJQUFBLHNCQUNFLG1CQUNBLG9CQUNBOztHQUNzQztZQUVw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TUFHckI7Z0JBQ0Y2akM7ZUFBQXZQLDBCQUFBdVA7Y0FBQXZQLGdDQUFBQTs2Q0FBQUE7Ozs2Q0FBQUE7OztrQkFzekdKc1M7VUFBZWwxQztVQUFHbXZDO1VBQUtsTztVQUFNa1U7VUFBU0M7VUFBYUM7VUFBbUJDO1VBRXhFO1dBaitFV0MsZUFpK0VRLDZCQUZDcEc7V0FHaEI3K0IsT0FsK0VlLDBCQUFSaWxDO1dBbStFUDVSLFNBSm9FMlIsd0NBQS9DclUsUUFBQUE7V0FLckJ5UyxTQUxpRDJCLHFDQUlqRDFSLFVBQUFBO1dBRUE0USxTQU5vQ2EseUJBS3BDMUIsVUFBQUE7V0FFQThCLFNBUDJCTCwwQkFNM0JaLFVBQUFBO1dBRUFrQixTQW5oRUZ6VSxRQWtoRUV3VTtXQUVBdndDLE1BMU9FOHRDLHFCQWlPVy95QztXQVNUOzhCO1VBQ1IsT0F0Tk11ekM7bUJBcU5GdHVDOzs7bUJBTkFxTDttQkFLQW1sQzs7Ozs7OztTQWF3QjtvQkFsZXRCakYsU0E2REFpQyxnQkF5VkpsQyxPQXVEQTJFOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBDb21tYW5kLkNvbW1hbmRfaW50ZiAqKVxubW9kdWxlIENvbW1hbmRfaW50ZiA9IENvbW1hbmRfX0NvbW1hbmRfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBDb21tYW5kLkVudl92YXIgKilcbm1vZHVsZSBFbnZfdmFyID0gQ29tbWFuZF9fRW52X3ZhclxuXG4oKiogQGNhbm9uaWNhbCBDb21tYW5kLkltcG9ydCAqKVxubW9kdWxlIEltcG9ydCA9IENvbW1hbmRfX0ltcG9ydFxuXG4oKiogQGNhbm9uaWNhbCBDb21tYW5kLlNoYXBlICopXG5tb2R1bGUgU2hhcGUgPSBDb21tYW5kX19TaGFwZVxuXG5tb2R1bGUgQ29tbWFuZF9fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCJpbmNsdWRlIHN0cnVjdFxuICBvcGVuIFN0ZGlvXG5cbiAgbGV0IGVwcmludGYgPSBlcHJpbnRmXG4gIGxldCBwcmludGYgPSBwcmludGZcbiAgbGV0IHByaW50X3MgPSBwcmludF9zXG4gIGxldCBwcmludF9zdHJpbmcgPSBwcmludF9zdHJpbmdcbiAgbGV0IHByaW50X2VuZGxpbmUgPSBwcmludF9lbmRsaW5lXG4gIGxldCBwcmVycl9lbmRsaW5lID0gcHJlcnJfZW5kbGluZVxuXG4gIG1vZHVsZSBJbl9jaGFubmVsID0gSW5fY2hhbm5lbFxuZW5kXG5cbmluY2x1ZGUgc3RydWN0XG4gIG9wZW4gQmFzZS5QcmludGZcblxuICBsZXQgc3ByaW50ZiA9IHNwcmludGZcbiAgbGV0IGZhaWx3aXRoZiA9IGZhaWx3aXRoZlxuICBsZXQga3NwcmludGYgPSBrc3ByaW50ZlxuZW5kXG4iLCJvcGVuISBCYXNlXG5vcGVuISBJbXBvcnRcblxudHlwZSB0ID1cbiAgfCBDT01NQU5EX09VVFBVVF9JTlNUQUxMQVRJT05fQkFTSFxuICB8IENPTU1BTkRfT1VUUFVUX0hFTFBfU0VYUFxuICB8IENPTVBfQ1dPUkRcbltAQGRlcml2aW5nIGNvbXBhcmUsIGVudW1lcmF0ZSwgc2V4cF9vZl1cblxubGV0IHRvX3N0cmluZyB0ID0gU2V4cC50b19zdHJpbmcgKHNleHBfb2ZfdCB0KVxuIiwibW9kdWxlIFN0YWJsZSA9IHN0cnVjdFxuICBvcGVuIFNleHBsaWIwLlNleHBfY29udlxuICBvcGVuIFBweF9jb21wYXJlX2xpYi5CdWlsdGluXG4gIG9wZW4gUHB4X3N0YWJsZV93aXRuZXNzX3J1bnRpbWUuU3RhYmxlX3dpdG5lc3MuRXhwb3J0XG5cbiAgbW9kdWxlIExhenkgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBsYXp5X3QgW0BAZGVyaXZpbmcgc2V4cCwgc3RhYmxlX3dpdG5lc3NdXG5cbiAgICBsZXQgY29tcGFyZSA9IEJhc2UuTGF6eS5jb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSBBbm9ucyA9IHN0cnVjdFxuICAgIG1vZHVsZSBHcmFtbWFyID0gc3RydWN0XG4gICAgICBtb2R1bGUgVjEgPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID1cbiAgICAgICAgICB8IFplcm9cbiAgICAgICAgICB8IE9uZSBvZiBzdHJpbmdcbiAgICAgICAgICB8IE1hbnkgb2YgdFxuICAgICAgICAgIHwgTWF5YmUgb2YgdFxuICAgICAgICAgIHwgQ29uY2F0IG9mIHQgbGlzdFxuICAgICAgICAgIHwgQWRfaG9jIG9mIHN0cmluZ1xuICAgICAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwLCBzdGFibGVfd2l0bmVzc11cblxuICAgICAgICBsZXQgcmVjIGludmFyaWFudCB0ID1cbiAgICAgICAgICBCYXNlLkludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgICAgICB8IFplcm8gLT4gKClcbiAgICAgICAgICAgIHwgT25lIF8gLT4gKClcbiAgICAgICAgICAgIHwgTWFueSBaZXJvIC0+IGZhaWx3aXRoIFwiTWFueSBaZXJvIHNob3VsZCBiZSBqdXN0IFplcm9cIlxuICAgICAgICAgICAgfCBNYW55IHQgLT4gaW52YXJpYW50IHRcbiAgICAgICAgICAgIHwgTWF5YmUgWmVybyAtPiBmYWlsd2l0aCBcIk1heWJlIFplcm8gc2hvdWxkIGJlIGp1c3QgWmVyb1wiXG4gICAgICAgICAgICB8IE1heWJlIHQgLT4gaW52YXJpYW50IHRcbiAgICAgICAgICAgIHwgQ29uY2F0IFtdIHwgQ29uY2F0IFsgXyBdIC0+IGZhaWx3aXRoIFwiRmxhdHRlbiB6ZXJvIGFuZCBvbmUtZWxlbWVudCBDb25jYXRcIlxuICAgICAgICAgICAgfCBDb25jYXQgdHMgLT4gQmFzZS5MaXN0Lml0ZXIgdHMgfmY6aW52YXJpYW50XG4gICAgICAgICAgICB8IEFkX2hvYyBfIC0+ICgpKVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCB0X29mX3NleHAgc2V4cCA9XG4gICAgICAgICAgbGV0IHQgPSBbJW9mX3NleHA6IHRdIHNleHAgaW5cbiAgICAgICAgICBpbnZhcmlhbnQgdDtcbiAgICAgICAgICB0XG4gICAgICAgIDs7XG5cbiAgICAgICAgbGV0IHJlYyB1c2FnZSA9XG4gICAgICAgICAgbGV0IG9wZW4gSW1wb3J0IGluXG4gICAgICAgICAgZnVuY3Rpb25cbiAgICAgICAgICB8IFplcm8gLT4gXCJcIlxuICAgICAgICAgIHwgT25lIHVzYWdlIC0+IHVzYWdlXG4gICAgICAgICAgfCBNYW55IFplcm8gLT4gZmFpbHdpdGggXCJidWcgaW4gY29tbWFuZC5tbFwiXG4gICAgICAgICAgfCBNYW55IChPbmUgXyBhcyB0KSAtPiBzcHJpbnRmIFwiWyVzIC4uLl1cIiAodXNhZ2UgdClcbiAgICAgICAgICB8IE1hbnkgdCAtPiBzcHJpbnRmIFwiWyglcykgLi4uXVwiICh1c2FnZSB0KVxuICAgICAgICAgIHwgTWF5YmUgWmVybyAtPiBmYWlsd2l0aCBcImJ1ZyBpbiBjb21tYW5kLm1sXCJcbiAgICAgICAgICB8IE1heWJlIHQgLT4gc3ByaW50ZiBcIlslc11cIiAodXNhZ2UgdClcbiAgICAgICAgICB8IENvbmNhdCB0cyAtPiBCYXNlLlN0cmluZy5jb25jYXQgfnNlcDpcIiBcIiAoQmFzZS5MaXN0Lm1hcCB0cyB+Zjp1c2FnZSlcbiAgICAgICAgICB8IEFkX2hvYyB1c2FnZSAtPiB1c2FnZVxuICAgICAgICA7O1xuICAgICAgZW5kXG5cbiAgICAgIG1vZHVsZSBNb2RlbCA9IFYxXG4gICAgZW5kXG5cbiAgICBtb2R1bGUgVjIgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9XG4gICAgICAgIHwgVXNhZ2Ugb2Ygc3RyaW5nXG4gICAgICAgIHwgR3JhbW1hciBvZiBHcmFtbWFyLlYxLnRcbiAgICAgIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHAsIHN0YWJsZV93aXRuZXNzXVxuICAgIGVuZFxuXG4gICAgbW9kdWxlIE1vZGVsID0gVjJcbiAgZW5kXG5cbiAgbW9kdWxlIEZsYWdfaW5mbyA9IHN0cnVjdFxuICAgIG1vZHVsZSBWMSA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID1cbiAgICAgICAgeyBuYW1lIDogc3RyaW5nXG4gICAgICAgIDsgZG9jIDogc3RyaW5nXG4gICAgICAgIDsgYWxpYXNlcyA6IHN0cmluZyBsaXN0XG4gICAgICAgIH1cbiAgICAgIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHAsIHN0YWJsZV93aXRuZXNzXVxuICAgIGVuZFxuXG4gICAgbW9kdWxlIE1vZGVsID0gVjFcbiAgZW5kXG5cbiAgbW9kdWxlIEJhc2VfaW5mbyA9IHN0cnVjdFxuICAgIG1vZHVsZSBWMiA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID1cbiAgICAgICAgeyBzdW1tYXJ5IDogc3RyaW5nXG4gICAgICAgIDsgcmVhZG1lIDogc3RyaW5nIG9wdGlvbiBbQHNleHAub3B0aW9uXVxuICAgICAgICA7IGFub25zIDogQW5vbnMuVjIudFxuICAgICAgICA7IGZsYWdzIDogRmxhZ19pbmZvLlYxLnQgbGlzdFxuICAgICAgICB9XG4gICAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwLCBzdGFibGVfd2l0bmVzc11cbiAgICBlbmRcblxuICAgIG1vZHVsZSBWMSA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID1cbiAgICAgICAgeyBzdW1tYXJ5IDogc3RyaW5nXG4gICAgICAgIDsgcmVhZG1lIDogc3RyaW5nIG9wdGlvbiBbQHNleHAub3B0aW9uXVxuICAgICAgICA7IHVzYWdlIDogc3RyaW5nXG4gICAgICAgIDsgZmxhZ3MgOiBGbGFnX2luZm8uVjEudCBsaXN0XG4gICAgICAgIH1cbiAgICAgIFtAQGRlcml2aW5nIHNleHAsIHN0YWJsZV93aXRuZXNzXVxuXG4gICAgICBsZXQgdG9fbGF0ZXN0IHsgc3VtbWFyeTsgcmVhZG1lOyB1c2FnZTsgZmxhZ3MgfSA9XG4gICAgICAgIHsgVjIuc3VtbWFyeTsgcmVhZG1lOyBhbm9ucyA9IFVzYWdlIHVzYWdlOyBmbGFncyB9XG4gICAgICA7O1xuXG4gICAgICBsZXQgb2ZfbGF0ZXN0IHsgVjIuc3VtbWFyeTsgcmVhZG1lOyBhbm9uczsgZmxhZ3MgfSA9XG4gICAgICAgIHsgc3VtbWFyeVxuICAgICAgICA7IHJlYWRtZVxuICAgICAgICA7IHVzYWdlID1cbiAgICAgICAgICAgIChtYXRjaCBhbm9ucyB3aXRoXG4gICAgICAgICAgICAgfCBVc2FnZSB1c2FnZSAtPiB1c2FnZVxuICAgICAgICAgICAgIHwgR3JhbW1hciBncmFtbWFyIC0+IEFub25zLkdyYW1tYXIuVjEudXNhZ2UgZ3JhbW1hcilcbiAgICAgICAgOyBmbGFnc1xuICAgICAgICB9XG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgbW9kdWxlIE1vZGVsID0gVjJcbiAgZW5kXG5cbiAgbW9kdWxlIEdyb3VwX2luZm8gPSBzdHJ1Y3RcbiAgICB0eXBlIGEgPSBEdW1teV90eXBlX2JlY2F1c2Vfd2VfY2Fubm90X2RpZ2VzdF90eXBlX2NvbnN0cnVjdG9yc19vbmx5X2NvbmNyZXRlX3R5cGVzXG4gICAgW0BAZGVyaXZpbmcgYmluX2lvXVxuXG4gICAgbW9kdWxlIFYyID0gc3RydWN0XG4gICAgICB0eXBlICdhIHQgPVxuICAgICAgICB7IHN1bW1hcnkgOiBzdHJpbmdcbiAgICAgICAgOyByZWFkbWUgOiBzdHJpbmcgb3B0aW9uIFtAc2V4cC5vcHRpb25dXG4gICAgICAgIDsgc3ViY29tbWFuZHMgOiAoc3RyaW5nICogJ2EpIGxpc3QgTGF6eS50XG4gICAgICAgIH1cbiAgICAgIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHAsIHN0YWJsZV93aXRuZXNzXVxuXG4gICAgICBvcGVuISBCYXNlXG5cbiAgICAgIGxldCBtYXAgdCB+ZiA9XG4gICAgICAgIHsgdCB3aXRoIHN1YmNvbW1hbmRzID0gTGF6eS5tYXAgdC5zdWJjb21tYW5kcyB+ZjooTGlzdC5Bc3NvYy5tYXAgfmYpIH1cbiAgICAgIDs7XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgTW9kZWwgPSBWMlxuXG4gICAgbW9kdWxlIFYxID0gc3RydWN0XG4gICAgICB0eXBlICdhIHQgPVxuICAgICAgICB7IHN1bW1hcnkgOiBzdHJpbmdcbiAgICAgICAgOyByZWFkbWUgOiBzdHJpbmcgb3B0aW9uIFtAc2V4cC5vcHRpb25dXG4gICAgICAgIDsgc3ViY29tbWFuZHMgOiAoc3RyaW5nICogJ2EpIGxpc3RcbiAgICAgICAgfVxuICAgICAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cCwgc3RhYmxlX3dpdG5lc3NdXG5cbiAgICAgIG9wZW4hIEJhc2VcblxuICAgICAgbGV0IG1hcCB0IH5mID0geyB0IHdpdGggc3ViY29tbWFuZHMgPSBMaXN0LkFzc29jLm1hcCB0LnN1YmNvbW1hbmRzIH5mIH1cblxuICAgICAgbGV0IHRvX2xhdGVzdCB7IHN1bW1hcnk7IHJlYWRtZTsgc3ViY29tbWFuZHMgfSA6ICdhIE1vZGVsLnQgPVxuICAgICAgICB7IHN1bW1hcnk7IHJlYWRtZTsgc3ViY29tbWFuZHMgPSBMYXp5LmZyb21fdmFsIHN1YmNvbW1hbmRzIH1cbiAgICAgIDs7XG5cbiAgICAgIGxldCBvZl9sYXRlc3QgKHsgc3VtbWFyeTsgcmVhZG1lOyBzdWJjb21tYW5kcyB9IDogJ2EgTW9kZWwudCkgOiAnYSB0ID1cbiAgICAgICAgeyBzdW1tYXJ5OyByZWFkbWU7IHN1YmNvbW1hbmRzID0gTGF6eS5mb3JjZSBzdWJjb21tYW5kcyB9XG4gICAgICA7O1xuICAgIGVuZFxuICBlbmRcblxuICBtb2R1bGUgRXhlY19pbmZvID0gc3RydWN0XG4gICAgbGV0IGFic19wYXRoIH5kaXIgcGF0aCA9XG4gICAgICBpZiBGaWxlbmFtZV9iYXNlLmlzX2Fic29sdXRlIHBhdGggdGhlbiBwYXRoIGVsc2UgRmlsZW5hbWVfYmFzZS5jb25jYXQgZGlyIHBhdGhcbiAgICA7O1xuXG4gICAgbW9kdWxlIFYzID0gc3RydWN0XG4gICAgICB0eXBlIHQgPVxuICAgICAgICB7IHN1bW1hcnkgOiBzdHJpbmdcbiAgICAgICAgOyByZWFkbWUgOiBzdHJpbmcgb3B0aW9uIFtAc2V4cC5vcHRpb25dXG4gICAgICAgIDsgd29ya2luZ19kaXIgOiBzdHJpbmdcbiAgICAgICAgOyBwYXRoX3RvX2V4ZSA6IHN0cmluZ1xuICAgICAgICA7IGNoaWxkX3N1YmNvbW1hbmQgOiBzdHJpbmcgbGlzdFxuICAgICAgICB9XG4gICAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwLCBzdGFibGVfd2l0bmVzc11cblxuICAgICAgbGV0IHRvX2xhdGVzdCA9IEJhc2UuRm4uaWRcbiAgICAgIGxldCBvZl9sYXRlc3QgPSBCYXNlLkZuLmlkXG4gICAgZW5kXG5cbiAgICBtb2R1bGUgTW9kZWwgPSBWM1xuXG4gICAgbW9kdWxlIFYyID0gc3RydWN0XG4gICAgICB0eXBlIHQgPVxuICAgICAgICB7IHN1bW1hcnkgOiBzdHJpbmdcbiAgICAgICAgOyByZWFkbWUgOiBzdHJpbmcgb3B0aW9uIFtAc2V4cC5vcHRpb25dXG4gICAgICAgIDsgd29ya2luZ19kaXIgOiBzdHJpbmdcbiAgICAgICAgOyBwYXRoX3RvX2V4ZSA6IHN0cmluZ1xuICAgICAgICB9XG4gICAgICBbQEBkZXJpdmluZyBzZXhwLCBzdGFibGVfd2l0bmVzc11cblxuICAgICAgbGV0IHRvX3YzIHQgOiBWMy50ID1cbiAgICAgICAgeyBzdW1tYXJ5ID0gdC5zdW1tYXJ5XG4gICAgICAgIDsgcmVhZG1lID0gdC5yZWFkbWVcbiAgICAgICAgOyB3b3JraW5nX2RpciA9IHQud29ya2luZ19kaXJcbiAgICAgICAgOyBwYXRoX3RvX2V4ZSA9IHQucGF0aF90b19leGVcbiAgICAgICAgOyBjaGlsZF9zdWJjb21tYW5kID0gW11cbiAgICAgICAgfVxuICAgICAgOztcblxuICAgICAgbGV0IG9mX3YzICh0IDogVjMudCkgPVxuICAgICAgICB7IHN1bW1hcnkgPSB0LnN1bW1hcnlcbiAgICAgICAgOyByZWFkbWUgPSB0LnJlYWRtZVxuICAgICAgICA7IHdvcmtpbmdfZGlyID0gdC53b3JraW5nX2RpclxuICAgICAgICA7IHBhdGhfdG9fZXhlID0gYWJzX3BhdGggfmRpcjp0LndvcmtpbmdfZGlyIHQucGF0aF90b19leGVcbiAgICAgICAgfVxuICAgICAgOztcblxuICAgICAgbGV0IHRvX2xhdGVzdCA9IEJhc2UuRm4uY29tcG9zZSBWMy50b19sYXRlc3QgdG9fdjNcbiAgICAgIGxldCBvZl9sYXRlc3QgPSBCYXNlLkZuLmNvbXBvc2Ugb2ZfdjMgVjMub2ZfbGF0ZXN0XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgVjEgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9XG4gICAgICAgIHsgc3VtbWFyeSA6IHN0cmluZ1xuICAgICAgICA7IHJlYWRtZSA6IHN0cmluZyBvcHRpb24gW0BzZXhwLm9wdGlvbl1cbiAgICAgICAgOyAoKiBbcGF0aF90b19leGVdIG11c3QgYmUgYWJzb2x1dGUuICopXG4gICAgICAgICAgcGF0aF90b19leGUgOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgW0BAZGVyaXZpbmcgc2V4cCwgc3RhYmxlX3dpdG5lc3NdXG5cbiAgICAgIGxldCB0b192MiB0IDogVjIudCA9XG4gICAgICAgIHsgc3VtbWFyeSA9IHQuc3VtbWFyeVxuICAgICAgICA7IHJlYWRtZSA9IHQucmVhZG1lXG4gICAgICAgIDsgd29ya2luZ19kaXIgPSBcIi9cIlxuICAgICAgICA7IHBhdGhfdG9fZXhlID0gdC5wYXRoX3RvX2V4ZVxuICAgICAgICB9XG4gICAgICA7O1xuXG4gICAgICBsZXQgb2ZfdjIgKHQgOiBWMi50KSA9XG4gICAgICAgIHsgc3VtbWFyeSA9IHQuc3VtbWFyeVxuICAgICAgICA7IHJlYWRtZSA9IHQucmVhZG1lXG4gICAgICAgIDsgcGF0aF90b19leGUgPSBhYnNfcGF0aCB+ZGlyOnQud29ya2luZ19kaXIgdC5wYXRoX3RvX2V4ZVxuICAgICAgICB9XG4gICAgICA7O1xuXG4gICAgICBsZXQgdG9fbGF0ZXN0ID0gQmFzZS5Gbi5jb21wb3NlIFYyLnRvX2xhdGVzdCB0b192MlxuICAgICAgbGV0IG9mX2xhdGVzdCA9IEJhc2UuRm4uY29tcG9zZSBvZl92MiBWMi5vZl9sYXRlc3RcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIEZ1bGx5X2ZvcmNlZCA9IHN0cnVjdFxuICAgIG1vZHVsZSBWMSA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID1cbiAgICAgICAgfCBCYXNpYyBvZiBCYXNlX2luZm8uVjIudFxuICAgICAgICB8IEdyb3VwIG9mIHQgR3JvdXBfaW5mby5WMi50XG4gICAgICAgIHwgRXhlYyBvZiBFeGVjX2luZm8uVjMudCAqIHRcbiAgICAgIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHAsIHN0YWJsZV93aXRuZXNzXVxuICAgIGVuZFxuXG4gICAgbW9kdWxlIE1vZGVsID0gVjFcbiAgZW5kXG5cbiAgbW9kdWxlIFNleHBhYmxlID0gc3RydWN0XG4gICAgbW9kdWxlIFYzID0gc3RydWN0XG4gICAgICB0eXBlIHQgPVxuICAgICAgICB8IEJhc2Ugb2YgQmFzZV9pbmZvLlYyLnRcbiAgICAgICAgfCBHcm91cCBvZiB0IEdyb3VwX2luZm8uVjIudFxuICAgICAgICB8IEV4ZWMgb2YgRXhlY19pbmZvLlYzLnRcbiAgICAgICAgfCBMYXp5IG9mIHQgTGF6eS50XG4gICAgICBbQEBkZXJpdmluZyBzZXhwLCBzdGFibGVfd2l0bmVzc11cblxuICAgICAgbGV0IHRvX2xhdGVzdCA9IEJhc2UuRm4uaWRcbiAgICAgIGxldCBvZl9sYXRlc3QgPSBCYXNlLkZuLmlkXG4gICAgZW5kXG5cbiAgICBtb2R1bGUgTW9kZWwgPSBWM1xuXG4gICAgbW9kdWxlIFYyID0gc3RydWN0XG4gICAgICB0eXBlIHQgPVxuICAgICAgICB8IEJhc2Ugb2YgQmFzZV9pbmZvLlYyLnRcbiAgICAgICAgfCBHcm91cCBvZiB0IEdyb3VwX2luZm8uVjEudFxuICAgICAgICB8IEV4ZWMgb2YgRXhlY19pbmZvLlYyLnRcbiAgICAgIFtAQGRlcml2aW5nIHNleHAsIHN0YWJsZV93aXRuZXNzXVxuXG4gICAgICBsZXQgcmVjIHRvX2xhdGVzdCA6IHQgLT4gTW9kZWwudCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgQmFzZSBiIC0+IEJhc2UgYlxuICAgICAgICB8IEV4ZWMgZSAtPiBFeGVjIChFeGVjX2luZm8uVjIudG9fbGF0ZXN0IGUpXG4gICAgICAgIHwgR3JvdXAgZyAtPiBHcm91cCAoR3JvdXBfaW5mby5WMS50b19sYXRlc3QgKEdyb3VwX2luZm8uVjEubWFwIGcgfmY6dG9fbGF0ZXN0KSlcbiAgICAgIDs7XG5cbiAgICAgIGxldCByZWMgb2ZfbGF0ZXN0IDogTW9kZWwudCAtPiB0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBCYXNlIGIgLT4gQmFzZSBiXG4gICAgICAgIHwgRXhlYyBlIC0+IEV4ZWMgKEV4ZWNfaW5mby5WMi5vZl9sYXRlc3QgZSlcbiAgICAgICAgfCBMYXp5IHRodW5rIC0+IG9mX2xhdGVzdCAoQmFzZS5MYXp5LmZvcmNlIHRodW5rKVxuICAgICAgICB8IEdyb3VwIGcgLT4gR3JvdXAgKEdyb3VwX2luZm8uVjEubWFwIChHcm91cF9pbmZvLlYxLm9mX2xhdGVzdCBnKSB+ZjpvZl9sYXRlc3QpXG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgbW9kdWxlIFYxID0gc3RydWN0XG4gICAgICB0eXBlIHQgPVxuICAgICAgICB8IEJhc2Ugb2YgQmFzZV9pbmZvLlYxLnRcbiAgICAgICAgfCBHcm91cCBvZiB0IEdyb3VwX2luZm8uVjEudFxuICAgICAgICB8IEV4ZWMgb2YgRXhlY19pbmZvLlYxLnRcbiAgICAgIFtAQGRlcml2aW5nIHNleHAsIHN0YWJsZV93aXRuZXNzXVxuXG4gICAgICBsZXQgcmVjIHRvX2xhdGVzdCA6IHQgLT4gTW9kZWwudCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgQmFzZSBiIC0+IEJhc2UgKEJhc2VfaW5mby5WMS50b19sYXRlc3QgYilcbiAgICAgICAgfCBFeGVjIGUgLT4gRXhlYyAoRXhlY19pbmZvLlYxLnRvX2xhdGVzdCBlKVxuICAgICAgICB8IEdyb3VwIGcgLT4gR3JvdXAgKEdyb3VwX2luZm8uVjEudG9fbGF0ZXN0IChHcm91cF9pbmZvLlYxLm1hcCBnIH5mOnRvX2xhdGVzdCkpXG4gICAgICA7O1xuXG4gICAgICBsZXQgcmVjIG9mX2xhdGVzdCA6IE1vZGVsLnQgLT4gdCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgQmFzZSBiIC0+IEJhc2UgKEJhc2VfaW5mby5WMS5vZl9sYXRlc3QgYilcbiAgICAgICAgfCBFeGVjIGUgLT4gRXhlYyAoRXhlY19pbmZvLlYxLm9mX2xhdGVzdCBlKVxuICAgICAgICB8IExhenkgdGh1bmsgLT4gb2ZfbGF0ZXN0IChCYXNlLkxhenkuZm9yY2UgdGh1bmspXG4gICAgICAgIHwgR3JvdXAgZyAtPiBHcm91cCAoR3JvdXBfaW5mby5WMS5tYXAgKEdyb3VwX2luZm8uVjEub2ZfbGF0ZXN0IGcpIH5mOm9mX2xhdGVzdClcbiAgICAgIDs7XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgVmVyc2lvbmVkID0gc3RydWN0XG4gICAgICB0eXBlIHQgPVxuICAgICAgICB8IFYxIG9mIFYxLnRcbiAgICAgICAgfCBWMiBvZiBWMi50XG4gICAgICAgIHwgVjMgb2YgVjMudCAoKiBhdmFpbGFibGUgYXQgbGVhc3Qgc2luY2UgMjAyMC0wNCAqKVxuICAgICAgW0BAZGVyaXZpbmcgc2V4cCwgdmFyaWFudHMsIHN0YWJsZV93aXRuZXNzXVxuXG4gICAgICBsZXQgdG9fbGF0ZXN0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBWMSB0IC0+IFYxLnRvX2xhdGVzdCB0XG4gICAgICAgIHwgVjIgdCAtPiBWMi50b19sYXRlc3QgdFxuICAgICAgICB8IFYzIHQgLT4gVjMudG9fbGF0ZXN0IHRcbiAgICAgIDs7XG5cbiAgICAgIGxldCBvZl9sYXRlc3QgfnZlcnNpb25fdG9fdXNlIGxhdGVzdCA9XG4gICAgICAgIG1hdGNoIHZlcnNpb25fdG9fdXNlIHdpdGhcbiAgICAgICAgfCAxIC0+IFYxIChWMS5vZl9sYXRlc3QgbGF0ZXN0KVxuICAgICAgICB8IDIgLT4gVjIgKFYyLm9mX2xhdGVzdCBsYXRlc3QpXG4gICAgICAgIHwgMyAtPiBWMyAoVjMub2ZfbGF0ZXN0IGxhdGVzdClcbiAgICAgICAgfCBvdGhlciAtPlxuICAgICAgICAgIEJhc2UuRXJyb3IuY3JlYXRlXG4gICAgICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgICAgICBcInVuc3VwcG9ydGVkIHZlcnNpb25fdG9fdXNlXCJcbiAgICAgICAgICAgIG90aGVyXG4gICAgICAgICAgICBbJXNleHBfb2Y6IGludF1cbiAgICAgICAgICB8PiBCYXNlLkVycm9yLnJhaXNlXG4gICAgICA7O1xuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5vcGVuISBCYXNlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIEFub25zID0gc3RydWN0XG4gIG1vZHVsZSBHcmFtbWFyID0gc3RydWN0XG4gICAgdHlwZSB0ID0gU3RhYmxlLkFub25zLkdyYW1tYXIuTW9kZWwudCA9XG4gICAgICB8IFplcm9cbiAgICAgIHwgT25lIG9mIHN0cmluZ1xuICAgICAgfCBNYW55IG9mIHRcbiAgICAgIHwgTWF5YmUgb2YgdFxuICAgICAgfCBDb25jYXQgb2YgdCBsaXN0XG4gICAgICB8IEFkX2hvYyBvZiBzdHJpbmdcbiAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gICAgbGV0IGludmFyaWFudCA9IFN0YWJsZS5Bbm9ucy5HcmFtbWFyLk1vZGVsLmludmFyaWFudFxuICAgIGxldCB1c2FnZSA9IFN0YWJsZS5Bbm9ucy5HcmFtbWFyLk1vZGVsLnVzYWdlXG4gIGVuZFxuXG4gIHR5cGUgdCA9IFN0YWJsZS5Bbm9ucy5Nb2RlbC50ID1cbiAgICB8IFVzYWdlIG9mIHN0cmluZ1xuICAgIHwgR3JhbW1hciBvZiBHcmFtbWFyLnRcbiAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cbmVuZFxuXG5tb2R1bGUgTnVtX29jY3VycmVuY2VzID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBhdF9sZWFzdF9vbmNlIDogYm9vbFxuICAgIDsgYXRfbW9zdF9vbmNlIDogYm9vbFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgY29tcGFyZSwgZW51bWVyYXRlLCBzZXhwX29mXVxuXG4gIGxldCBtYXliZV9taXNzaW5nX3ByZWZpeCA9IFwiW1wiXG4gIGxldCBtYXliZV9taXNzaW5nX3N1ZmZpeCA9IFwiXVwiXG4gIGxldCBtYXliZV9tb3JlX3N1ZmZpeCA9IFwiIC4uLlwiXG5cbiAgbGV0IHRvX2hlbHBfc3RyaW5nIHQgfmZsYWdfbmFtZSA9XG4gICAgbGV0IHsgYXRfbGVhc3Rfb25jZTsgYXRfbW9zdF9vbmNlIH0gPSB0IGluXG4gICAgbGV0IGRlc2NyaXB0aW9uID1cbiAgICAgIGlmIGF0X2xlYXN0X29uY2VcbiAgICAgIHRoZW4gZmxhZ19uYW1lXG4gICAgICBlbHNlIFN0cmluZy5jb25jYXQgWyBtYXliZV9taXNzaW5nX3ByZWZpeDsgZmxhZ19uYW1lOyBtYXliZV9taXNzaW5nX3N1ZmZpeCBdXG4gICAgaW5cbiAgICBpZiBhdF9tb3N0X29uY2UgdGhlbiBkZXNjcmlwdGlvbiBlbHNlIFN0cmluZy5jb25jYXQgWyBkZXNjcmlwdGlvbjsgbWF5YmVfbW9yZV9zdWZmaXggXVxuICA7O1xuXG4gIGxldCBvZl9oZWxwX3N0cmluZyBuYW1lID1cbiAgICBsZXQgYXRfbW9zdF9vbmNlLCBuYW1lID1cbiAgICAgIG1hdGNoIFN0cmluZy5jaG9wX3N1ZmZpeCBuYW1lIH5zdWZmaXg6bWF5YmVfbW9yZV9zdWZmaXggd2l0aFxuICAgICAgfCBOb25lIC0+IHRydWUsIG5hbWVcbiAgICAgIHwgU29tZSBuYW1lIC0+IGZhbHNlLCBuYW1lXG4gICAgaW5cbiAgICBsZXQgYXRfbGVhc3Rfb25jZSwgbmFtZSA9XG4gICAgICBtYXRjaFxuICAgICAgICBTdHJpbmcuY2hvcF9wcmVmaXggbmFtZSB+cHJlZml4Om1heWJlX21pc3NpbmdfcHJlZml4XG4gICAgICAgIHw+IE9wdGlvbi5iaW5kIH5mOihTdHJpbmcuY2hvcF9zdWZmaXggfnN1ZmZpeDptYXliZV9taXNzaW5nX3N1ZmZpeClcbiAgICAgIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB0cnVlLCBuYW1lXG4gICAgICB8IFNvbWUgbmFtZSAtPiBmYWxzZSwgbmFtZVxuICAgIGluXG4gICAgeyBhdF9sZWFzdF9vbmNlOyBhdF9tb3N0X29uY2UgfSwgbmFtZVxuICA7O1xuXG4gIGxldCVleHBlY3RfdGVzdCBcInRvX2hlbHBfc3RyaW5nXCIgPVxuICAgIGxldCBmbGFnX25hbWUgPSBcIm5hbWVcIiBpblxuICAgIExpc3QuaXRlciBbJWFsbDogdF0gfmY6KGZ1biB0IC0+XG4gICAgICBsZXQgcyA9IHRvX2hlbHBfc3RyaW5nIHQgfmZsYWdfbmFtZSBpblxuICAgICAgcHJpbnRfcyBbJW1lc3NhZ2UgXCJcIiB+XzoodCA6IHQpIHNdO1xuICAgICAgbGV0IHQnLCBmbGFnX25hbWUnID0gb2ZfaGVscF9zdHJpbmcgcyBpblxuICAgICAgYXNzZXJ0IChbJWNvbXBhcmUuZXF1YWw6IHRdIHQgdCcpO1xuICAgICAgYXNzZXJ0IChbJWNvbXBhcmUuZXF1YWw6IHN0cmluZ10gZmxhZ19uYW1lIGZsYWdfbmFtZScpKTtcbiAgICBbJWV4cGVjdFxuICAgICAge3xcbiAgICAgICgoKGF0X2xlYXN0X29uY2UgZmFsc2UpIChhdF9tb3N0X29uY2UgZmFsc2UpKSBcIltuYW1lXSAuLi5cIilcbiAgICAgICgoKGF0X2xlYXN0X29uY2UgdHJ1ZSkgKGF0X21vc3Rfb25jZSBmYWxzZSkpIFwibmFtZSAuLi5cIilcbiAgICAgICgoKGF0X2xlYXN0X29uY2UgZmFsc2UpIChhdF9tb3N0X29uY2UgdHJ1ZSkpIFtuYW1lXSlcbiAgICAgICgoKGF0X2xlYXN0X29uY2UgdHJ1ZSkgKGF0X21vc3Rfb25jZSB0cnVlKSkgbmFtZSlcbiAgICAgIHx9XVxuICA7O1xuZW5kXG5cbm1vZHVsZSBGbGFnX2luZm8gPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gU3RhYmxlLkZsYWdfaW5mby5Nb2RlbC50ID1cbiAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICA7IGRvYyA6IHN0cmluZ1xuICAgIDsgYWxpYXNlcyA6IHN0cmluZyBsaXN0XG4gICAgfVxuICBbQEBkZXJpdmluZyBjb21wYXJlLCBmaWVsZHMgfmdldHRlcnMsIHNleHBdXG5cbiAgbGV0IHBhcnNlX25hbWUgdCA9XG4gICAgbGV0IG51bV9vY2N1cnJlbmNlcywgZmxhZ19uYW1lID0gTnVtX29jY3VycmVuY2VzLm9mX2hlbHBfc3RyaW5nIHQubmFtZSBpblxuICAgIG1hdGNoIFN0cmluZy5zcGxpdCBmbGFnX25hbWUgfm9uOicgJyB3aXRoXG4gICAgfCBbIGZsYWdfbmFtZSBdIC0+IE9rIChudW1fb2NjdXJyZW5jZXMsIGZhbHNlLCBmbGFnX25hbWUpXG4gICAgfCBbIGZsYWdfbmFtZTsgX2FyZ19kb2MgXSAtPiBPayAobnVtX29jY3VycmVuY2VzLCB0cnVlLCBmbGFnX25hbWUpXG4gICAgfCBfIC0+IEVycm9yIChFcnJvci5jcmVhdGVfcyBbJW1lc3NhZ2UgXCJVbmFibGUgdG8gcGFyc2VcIiBmbGFnX25hbWVdKVxuICA7O1xuXG4gICgqIFVzZXJzIGFyZSBsaWtlbHkgdG8gY2FsbCBhbGwgdGhyZWUgb2YgdGhlc2UgZnVuY3Rpb25zLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgcmUtcGFyc2VcbiAgICAgdGhlIFtuYW1lXSBzZXZlcmFsIHRpbWVzLiBXZSBkb24ndCBleHBlY3QgdXNlcnMgb2YgdGhlc2UgZnVuY3Rpb25zIHRvIGNhcmUgYWJvdXQgdGhlXG4gICAgIGluZWZmaWNpZW5jeS4gKilcbiAgbGV0IGZsYWdfbmFtZSB0ID1cbiAgICBwYXJzZV9uYW1lIHRcbiAgICB8PiBPcl9lcnJvci5tYXAgfmY6KGZ1biAoKF8gOiBOdW1fb2NjdXJyZW5jZXMudCksIChfIDogYm9vbCksIGZsYWdfbmFtZSkgLT4gZmxhZ19uYW1lKVxuICA7O1xuXG4gIGxldCBudW1fb2NjdXJyZW5jZXMgdCA9XG4gICAgcGFyc2VfbmFtZSB0XG4gICAgfD4gT3JfZXJyb3IubWFwIH5mOihmdW4gKG51bV9vY2N1cnJlbmNlcywgKF8gOiBib29sKSwgKF8gOiBzdHJpbmcpKSAtPlxuICAgICAgICAgbnVtX29jY3VycmVuY2VzKVxuICA7O1xuXG4gIGxldCByZXF1aXJlc19hcmcgdCA9XG4gICAgcGFyc2VfbmFtZSB0XG4gICAgfD4gT3JfZXJyb3IubWFwIH5mOihmdW4gKChfIDogTnVtX29jY3VycmVuY2VzLnQpLCByZXF1aXJlc19hcmcsIChfIDogc3RyaW5nKSkgLT5cbiAgICAgICAgIHJlcXVpcmVzX2FyZylcbiAgOztcblxuICBsZXQgaGVscF9zY3JlZW5fY29tcGFyZSBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgXywgXCJbLWhlbHBdXCIgLT4gLTFcbiAgICB8IFwiWy1oZWxwXVwiLCBfIC0+IDFcbiAgICB8IF8sIFwiWy12ZXJzaW9uXVwiIC0+IC0xXG4gICAgfCBcIlstdmVyc2lvbl1cIiwgXyAtPiAxXG4gICAgfCBfLCBcIlstYnVpbGQtaW5mb11cIiAtPiAtMVxuICAgIHwgXCJbLWJ1aWxkLWluZm9dXCIsIF8gLT4gMVxuICAgIHwgXywgXCJoZWxwXCIgLT4gLTFcbiAgICB8IFwiaGVscFwiLCBfIC0+IDFcbiAgICB8IF8sIFwidmVyc2lvblwiIC0+IC0xXG4gICAgfCBcInZlcnNpb25cIiwgXyAtPiAxXG4gICAgfCBfIC0+IDBcbiAgOztcbmVuZFxuXG5tb2R1bGUgRmxhZ19oZWxwX2Rpc3BsYXkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gRmxhZ19pbmZvLnQgbGlzdFxuXG4gIGxldCBzb3J0IHQgPVxuICAgIExpc3Quc3RhYmxlX3NvcnQgdCB+Y29tcGFyZTooZnVuIGEgYiAtPlxuICAgICAgRmxhZ19pbmZvLmhlbHBfc2NyZWVuX2NvbXBhcmUgYS5GbGFnX2luZm8ubmFtZSBiLkZsYWdfaW5mby5uYW1lKVxuICA7O1xuXG4gIGxldCB3b3JkX3dyYXBfYW5kX3N0cmlwIHRleHQgd2lkdGggPVxuICAgIGxldCBjaHVua3MgPSBTdHJpbmcuc3BsaXQgdGV4dCB+b246J1xcbicgaW5cbiAgICBMaXN0LmNvbmNhdF9tYXAgY2h1bmtzIH5mOihmdW4gdGV4dCAtPlxuICAgICAgbGV0IHdvcmRzID1cbiAgICAgICAgU3RyaW5nLnNwbGl0IHRleHQgfm9uOicgJ1xuICAgICAgICB8PiBMaXN0LmZpbHRlciB+ZjooZnVuIHdvcmQgLT4gbm90IChTdHJpbmcuaXNfZW1wdHkgd29yZCkpXG4gICAgICBpblxuICAgICAgbWF0Y2hcbiAgICAgICAgTGlzdC5mb2xkIHdvcmRzIH5pbml0Ok5vbmUgfmY6KGZ1biBhY2Mgd29yZCAtPlxuICAgICAgICAgIFNvbWVcbiAgICAgICAgICAgIChtYXRjaCBhY2Mgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiBbXSwgd29yZFxuICAgICAgICAgICAgIHwgU29tZSAobGluZXMsIGxpbmUpIC0+XG4gICAgICAgICAgICAgICAoKiBlZmZpY2llbmN5IGlzIG5vdCBhIGNvbmNlcm4gZm9yIHRoZSBzdHJpbmcgbGVuZ3RocyB3ZSBleHBlY3QgKilcbiAgICAgICAgICAgICAgIGxldCBsaW5lX2FuZF93b3JkID0gbGluZSBeIFwiIFwiIF4gd29yZCBpblxuICAgICAgICAgICAgICAgaWYgU3RyaW5nLmxlbmd0aCBsaW5lX2FuZF93b3JkIDw9IHdpZHRoXG4gICAgICAgICAgICAgICB0aGVuIGxpbmVzLCBsaW5lX2FuZF93b3JkXG4gICAgICAgICAgICAgICBlbHNlIGxpbmUgOjogbGluZXMsIHdvcmQpKVxuICAgICAgd2l0aFxuICAgICAgfCBOb25lIC0+IFtdXG4gICAgICB8IFNvbWUgKGxpbmVzLCBsaW5lKSAtPiBMaXN0LnJldiAobGluZSA6OiBsaW5lcykpXG4gIDs7XG5cbiAgbW9kdWxlIERpc3BsYXkgOiBzaWdcbiAgICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IG51bV9jb2xzID0gODBcbiAgICBsZXQgc3BhY2VzX3N0cmluZyB3aWR0aCA9IFN0cmluZy5tYWtlIHdpZHRoICcgJ1xuXG4gICAgbGV0IHBhZF9zcGFjZXNfdG9fc3VmZml4IHggfndpZHRoID1cbiAgICAgIGxldCBzbGFjayA9IHdpZHRoIC0gU3RyaW5nLmxlbmd0aCB4IGluXG4gICAgICB4IF4gc3BhY2VzX3N0cmluZyBzbGFja1xuICAgIDs7XG5cbiAgICBsZXQgaW5kZW50YXRpb24gPSBcIiAgXCJcbiAgICBsZXQgaW5kZW50X2FuZF9uZXdsaW5lIHggPSBMaXN0LmNvbmNhdCBbIFsgaW5kZW50YXRpb24gXTsgeDsgWyBcIlxcblwiIF0gXVxuICAgIGxldCBzcGFjaW5nX2RvdCA9IFwiLiBcIlxuICAgIGxldCBkb3RfaW5kZW50YXRpb25fb2Zmc2V0ID0gMjdcbiAgICBsZXQgZG9jdW1lbnRhdGlvbl9zdGFydF9jb2x1bW4gPSBkb3RfaW5kZW50YXRpb25fb2Zmc2V0ICsgU3RyaW5nLmxlbmd0aCBpbmRlbnRhdGlvblxuICAgIGxldCBsaHNfd2lkdGggPSBkb2N1bWVudGF0aW9uX3N0YXJ0X2NvbHVtblxuICAgIGxldCBsaHNfcGFkX3dpZHRoID0gZG90X2luZGVudGF0aW9uX29mZnNldCArIFN0cmluZy5sZW5ndGggaW5kZW50YXRpb25cbiAgICBsZXQgbGhzX3BhZCA9IHNwYWNlc19zdHJpbmcgbGhzX3BhZF93aWR0aFxuXG4gICAgbGV0IGxoc19wYWRfYW5kX25ld2xpbmVfdGVybWluYXRlID1cbiAgICAgIExpc3QubWFwIH5mOihmdW4gdiAtPiBpbmRlbnRfYW5kX25ld2xpbmUgWyBsaHNfcGFkOyB2IF0pXG4gICAgOztcblxuICAgIGxldCByb3dzIGZsYWdfbmFtZV93aXRoX2FsaWFzZXMgZG9jdW1lbnRhdGlvbiA9XG4gICAgICBsZXQgZmxhZ19vbl9pdHNfb3duX2xpbmUgPVxuICAgICAgICBsZXQgZmxhZ193aWR0aCA9XG4gICAgICAgICAgU3RyaW5nLmxlbmd0aCBpbmRlbnRhdGlvbiArIFN0cmluZy5sZW5ndGggZmxhZ19uYW1lX3dpdGhfYWxpYXNlc1xuICAgICAgICBpblxuICAgICAgICBpZiBmbGFnX3dpZHRoID49IGRvdF9pbmRlbnRhdGlvbl9vZmZzZXQgKyBTdHJpbmcubGVuZ3RoIHNwYWNpbmdfZG90XG4gICAgICAgIHRoZW4gaW5kZW50X2FuZF9uZXdsaW5lIFsgZmxhZ19uYW1lX3dpdGhfYWxpYXNlcyBdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpbmRlbnRfYW5kX25ld2xpbmVcbiAgICAgICAgICAgIFsgcGFkX3NwYWNlc190b19zdWZmaXggfndpZHRoOmRvdF9pbmRlbnRhdGlvbl9vZmZzZXQgZmxhZ19uYW1lX3dpdGhfYWxpYXNlc1xuICAgICAgICAgICAgOyBzcGFjaW5nX2RvdFxuICAgICAgICAgICAgXVxuICAgICAgaW5cbiAgICAgIGxldCB3cmFwcGVkX2RvY3VtZW50YXRpb24gPVxuICAgICAgICB3b3JkX3dyYXBfYW5kX3N0cmlwXG4gICAgICAgICAgZG9jdW1lbnRhdGlvblxuICAgICAgICAgIChudW1fY29scyAtIGxoc193aWR0aCAtIFN0cmluZy5sZW5ndGggaW5kZW50YXRpb24pXG4gICAgICBpblxuICAgICAgbWF0Y2ggd3JhcHBlZF9kb2N1bWVudGF0aW9uIHdpdGhcbiAgICAgIHwgW10gLT4gWyBmbGFnX29uX2l0c19vd25fbGluZSBdXG4gICAgICB8IGRvY193cmFwcGVkX2ZpcnN0X2xpbmUgOjogZG9jX3dyYXBwZWRfcmVzdF9saW5lcyAtPlxuICAgICAgICBsZXQgd3JhcHBlZF9kb2NfbGluZXMgPSBsaHNfcGFkX2FuZF9uZXdsaW5lX3Rlcm1pbmF0ZSBkb2Nfd3JhcHBlZF9yZXN0X2xpbmVzIGluXG4gICAgICAgIGxldCBwcmVmaXhfZG9jX3dyYXBwZWRfZmlyc3RfbGluZV93aXRoIHggPVxuICAgICAgICAgIGluZGVudF9hbmRfbmV3bGluZVxuICAgICAgICAgICAgWyBwYWRfc3BhY2VzX3RvX3N1ZmZpeCB+d2lkdGg6ZG90X2luZGVudGF0aW9uX29mZnNldCB4XG4gICAgICAgICAgICA7IHNwYWNpbmdfZG90XG4gICAgICAgICAgICA7IGRvY193cmFwcGVkX2ZpcnN0X2xpbmVcbiAgICAgICAgICAgIF1cbiAgICAgICAgaW5cbiAgICAgICAgaWYgU3RyaW5nLmxlbmd0aCBmbGFnX25hbWVfd2l0aF9hbGlhc2VzID49IGRvdF9pbmRlbnRhdGlvbl9vZmZzZXRcbiAgICAgICAgdGhlblxuICAgICAgICAgIGZsYWdfb25faXRzX293bl9saW5lXG4gICAgICAgICAgOjogcHJlZml4X2RvY193cmFwcGVkX2ZpcnN0X2xpbmVfd2l0aCBcIlwiXG4gICAgICAgICAgOjogd3JhcHBlZF9kb2NfbGluZXNcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHByZWZpeF9kb2Nfd3JhcHBlZF9maXJzdF9saW5lX3dpdGggZmxhZ19uYW1lX3dpdGhfYWxpYXNlcyA6OiB3cmFwcGVkX2RvY19saW5lc1xuICAgIDs7XG5cbiAgICBsZXQgdG9fc3RyaW5nIHQgPVxuICAgICAgTGlzdC5jb25jYXRfbWFwIHQgfmY6KGZ1biB0IC0+XG4gICAgICAgIGxldCBmbGFnX25hbWVfd2l0aF9hbGlhc2VzID1cbiAgICAgICAgICBsZXQgZmxhZyA9IHQuRmxhZ19pbmZvLm5hbWUgaW5cbiAgICAgICAgICBTdHJpbmcuY29uY2F0IH5zZXA6XCIsIFwiIChmbGFnIDo6IHQuYWxpYXNlcylcbiAgICAgICAgaW5cbiAgICAgICAgcm93cyBmbGFnX25hbWVfd2l0aF9hbGlhc2VzIHQuZG9jIHw+IExpc3QuY29uY2F0KVxuICAgICAgfD4gU3RyaW5nLmNvbmNhdFxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB0b19zdHJpbmcgdCA9IERpc3BsYXkudG9fc3RyaW5nIHRcbmVuZFxuXG5tb2R1bGUgS2V5X3R5cGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IFN1YmNvbW1hbmRcbiAgICB8IEZsYWdcblxuICBsZXQgdG9fc3RyaW5nID0gZnVuY3Rpb25cbiAgICB8IFN1YmNvbW1hbmQgLT4gXCJzdWJjb21tYW5kXCJcbiAgICB8IEZsYWcgLT4gXCJmbGFnXCJcbiAgOztcbmVuZFxuXG5sZXQgbG9va3VwX2V4cGFuZCBhbGlzdCBwcmVmaXgga2V5X3R5cGUgPVxuICBsZXQgaXNfZGFzaCA9IENoYXIuZXF1YWwgJy0nIGluXG4gIGxldCBhbGlzdCA9XG4gICAgKCogbm8gcGFydGlhbCBtYXRjaGVzIHVubGVzcyBzb21lIG5vbi1kYXNoIGNoYXIgaXMgcHJlc2VudCAqKVxuICAgIGlmIFN0cmluZy5mb3JfYWxsIHByZWZpeCB+Zjppc19kYXNoXG4gICAgdGhlbiBMaXN0Lm1hcCBhbGlzdCB+ZjooZnVuIChrZXksIChkYXRhLCBfKSkgLT4ga2V5LCAoZGF0YSwgYEZ1bGxfbWF0Y2hfcmVxdWlyZWQpKVxuICAgIGVsc2UgYWxpc3RcbiAgaW5cbiAgbWF0Y2hcbiAgICBMaXN0LmZpbHRlciBhbGlzdCB+ZjooZnVuY3Rpb25cbiAgICAgIHwga2V5LCAoXywgYEZ1bGxfbWF0Y2hfcmVxdWlyZWQpIC0+IFN0cmluZy4oID0gKSBrZXkgcHJlZml4XG4gICAgICB8IGtleSwgKF8sIGBQcmVmaXgpIC0+IFN0cmluZy5pc19wcmVmaXgga2V5IH5wcmVmaXgpXG4gIHdpdGhcbiAgfCBbIChrZXksIChkYXRhLCBfbmFtZV9tYXRjaGluZykpIF0gLT4gT2sgKGtleSwgZGF0YSlcbiAgfCBbXSAtPiBFcnJvciAoc3ByaW50ZiAhXCJ1bmtub3duICV7S2V5X3R5cGV9ICVzXCIga2V5X3R5cGUgcHJlZml4KVxuICB8IG1hdGNoZXMgLT5cbiAgICAobWF0Y2ggTGlzdC5maW5kIG1hdGNoZXMgfmY6KGZ1biAoa2V5LCBfKSAtPiBTdHJpbmcuKCA9ICkga2V5IHByZWZpeCkgd2l0aFxuICAgICB8IFNvbWUgKGtleSwgKGRhdGEsIF9uYW1lX21hdGNoaW5nKSkgLT4gT2sgKGtleSwgZGF0YSlcbiAgICAgfCBOb25lIC0+XG4gICAgICAgbGV0IG1hdGNoaW5nX2tleXMgPSBMaXN0Lm1hcCB+Zjpmc3QgbWF0Y2hlcyBpblxuICAgICAgIEVycm9yXG4gICAgICAgICAoc3ByaW50ZlxuICAgICAgICAgICAgIVwiJXtLZXlfdHlwZX0gJXMgaXMgYW4gYW1iaWd1b3VzIHByZWZpeDogJXNcIlxuICAgICAgICAgICAga2V5X3R5cGVcbiAgICAgICAgICAgIHByZWZpeFxuICAgICAgICAgICAgKFN0cmluZy5jb25jYXQgfnNlcDpcIiwgXCIgbWF0Y2hpbmdfa2V5cykpKVxuOztcblxubW9kdWxlIEJhc2VfaW5mbyA9IHN0cnVjdFxuICB0eXBlIHQgPSBTdGFibGUuQmFzZV9pbmZvLk1vZGVsLnQgPVxuICAgIHsgc3VtbWFyeSA6IHN0cmluZ1xuICAgIDsgcmVhZG1lIDogc3RyaW5nIG9wdGlvbiBbQHNleHAub3B0aW9uXVxuICAgIDsgYW5vbnMgOiBBbm9ucy50XG4gICAgOyBmbGFncyA6IEZsYWdfaW5mby50IGxpc3RcbiAgICB9XG4gIFtAQGRlcml2aW5nIGNvbXBhcmUsIGZpZWxkcyB+Z2V0dGVycywgc2V4cF1cblxuICBsZXQgZmluZF9mbGFnIHQgcHJlZml4ID1cbiAgICBtYXRjaCBTdHJpbmcuaXNfcHJlZml4IHByZWZpeCB+cHJlZml4OlwiLVwiIHdpdGhcbiAgICB8IGZhbHNlIC0+IEVycm9yIChFcnJvci5jcmVhdGVfcyBbJW1lc3NhZ2UgXCJGbGFncyBtdXN0IGJlZ2luIHdpdGggJy0nXCIgcHJlZml4XSlcbiAgICB8IHRydWUgLT5cbiAgICAgIGxldCViaW5kLk9yX2Vycm9yIGNob2ljZXMgPVxuICAgICAgICBMaXN0Lm1hcCB0LmZsYWdzIH5mOihmdW4gKGZsYWdfaW5mbyA6IEZsYWdfaW5mby50KSAtPlxuICAgICAgICAgIGxldCViaW5kLk9yX2Vycm9yIGZsYWdfbmFtZSA9IEZsYWdfaW5mby5mbGFnX25hbWUgZmxhZ19pbmZvIGluXG4gICAgICAgICAgT2tcbiAgICAgICAgICAgIChMaXN0Lm1hcCAoZmxhZ19uYW1lIDo6IGZsYWdfaW5mby5hbGlhc2VzKSB+ZjooZnVuIGtleSAtPlxuICAgICAgICAgICAgICAga2V5LCAoZmxhZ19pbmZvLCBgUHJlZml4KSkpKVxuICAgICAgICB8PiBPcl9lcnJvci5jb21iaW5lX2Vycm9yc1xuICAgICAgaW5cbiAgICAgIGxvb2t1cF9leHBhbmQgKExpc3QuY29uY2F0IGNob2ljZXMpIHByZWZpeCBGbGFnXG4gICAgICB8PiBSZXN1bHQubWFwX2Vycm9yIH5mOkVycm9yLm9mX3N0cmluZ1xuICAgICAgfD4gT3JfZXJyb3IubWFwIH5mOnNuZFxuICA7O1xuXG4gIGxldCBnZXRfdXNhZ2UgdCA9XG4gICAgbWF0Y2ggdC5hbm9ucyB3aXRoXG4gICAgfCBVc2FnZSB1c2FnZSAtPiB1c2FnZVxuICAgIHwgR3JhbW1hciBncmFtbWFyIC0+IEFub25zLkdyYW1tYXIudXNhZ2UgZ3JhbW1hclxuICA7O1xuZW5kXG5cbm1vZHVsZSBHcm91cF9pbmZvID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIFN0YWJsZS5Hcm91cF9pbmZvLk1vZGVsLnQgPVxuICAgIHsgc3VtbWFyeSA6IHN0cmluZ1xuICAgIDsgcmVhZG1lIDogc3RyaW5nIG9wdGlvbiBbQHNleHAub3B0aW9uXVxuICAgIDsgc3ViY29tbWFuZHMgOiAoc3RyaW5nICogJ2EpIExpc3QudCBMYXp5LnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGNvbXBhcmUsIGZpZWxkcyB+Z2V0dGVycywgc2V4cF1cblxuICBsZXQgZmluZF9zdWJjb21tYW5kIHQgcHJlZml4ID1cbiAgICBtYXRjaCBTdHJpbmcuaXNfcHJlZml4IHByZWZpeCB+cHJlZml4OlwiLVwiIHdpdGhcbiAgICB8IHRydWUgLT5cbiAgICAgIEVycm9yIChFcnJvci5jcmVhdGVfcyBbJW1lc3NhZ2UgXCJTdWJjb21tYW5kcyBtdXN0IG5vdCBiZWdpbiB3aXRoICctJ1wiIHByZWZpeF0pXG4gICAgfCBmYWxzZSAtPlxuICAgICAgbGV0IGNob2ljZXMgPVxuICAgICAgICBMaXN0Lm1hcCAoZm9yY2UgdC5zdWJjb21tYW5kcykgfmY6KGZ1biAoa2V5LCBhKSAtPiBrZXksIChhLCBgUHJlZml4KSlcbiAgICAgIGluXG4gICAgICBsb29rdXBfZXhwYW5kIGNob2ljZXMgcHJlZml4IFN1YmNvbW1hbmRcbiAgICAgIHw+IFJlc3VsdC5tYXBfZXJyb3IgfmY6RXJyb3Iub2Zfc3RyaW5nXG4gICAgICB8PiBPcl9lcnJvci5tYXAgfmY6c25kXG4gIDs7XG5cbiAgbGV0IG1hcCA9IFN0YWJsZS5Hcm91cF9pbmZvLk1vZGVsLm1hcFxuZW5kXG5cbm1vZHVsZSBFeGVjX2luZm8gPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gU3RhYmxlLkV4ZWNfaW5mby5Nb2RlbC50ID1cbiAgICB7IHN1bW1hcnkgOiBzdHJpbmdcbiAgICA7IHJlYWRtZSA6IHN0cmluZyBvcHRpb24gW0BzZXhwLm9wdGlvbl1cbiAgICA7IHdvcmtpbmdfZGlyIDogc3RyaW5nXG4gICAgOyBwYXRoX3RvX2V4ZSA6IHN0cmluZ1xuICAgIDsgY2hpbGRfc3ViY29tbWFuZCA6IHN0cmluZyBsaXN0XG4gICAgfVxuICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuZW5kXG5cbm1vZHVsZSBGdWxseV9mb3JjZWQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gU3RhYmxlLkZ1bGx5X2ZvcmNlZC5Nb2RlbC50ID1cbiAgICB8IEJhc2ljIG9mIEJhc2VfaW5mby50XG4gICAgfCBHcm91cCBvZiB0IEdyb3VwX2luZm8udFxuICAgIHwgRXhlYyBvZiBFeGVjX2luZm8udCAqIHRcbiAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICBsZXQgZXhwYW5kZWRfc3ViY29tbWFuZHMgdCA9XG4gICAgbGV0IHJlYyBleHBhbmQgPSBmdW5jdGlvblxuICAgICAgfCBFeGVjIChfLCB0KSAtPiBleHBhbmQgdFxuICAgICAgfCBCYXNpYyBfIC0+IFsgW10gXVxuICAgICAgfCBHcm91cCB7IHN1YmNvbW1hbmRzOyBfIH0gLT5cbiAgICAgICAgTGlzdC5jb25jYXRfbWFwIChMYXp5LmZvcmNlIHN1YmNvbW1hbmRzKSB+ZjooZnVuIChuYW1lLCB0KSAtPlxuICAgICAgICAgIExpc3QubWFwIH5mOihmdW4gcGF0aCAtPiBuYW1lIDo6IHBhdGgpIChleHBhbmQgdCkpXG4gICAgaW5cbiAgICAoKiBSZXZlcnNpbmcgc28gdGhhdCB0aGUgY29tbWFuZHMgc2hvdyB1cCBpbiB0aGUgc2FtZSBvcmRlciBhcyBoZWxwIGlzIG91dHB1dCAqKVxuICAgIExpc3QucmV2IChleHBhbmQgdClcbiAgOztcbmVuZFxuXG5tb2R1bGUgU2V4cGFibGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gU3RhYmxlLlNleHBhYmxlLk1vZGVsLnQgPVxuICAgIHwgQmFzZSBvZiBCYXNlX2luZm8udFxuICAgIHwgR3JvdXAgb2YgdCBHcm91cF9pbmZvLnRcbiAgICB8IEV4ZWMgb2YgRXhlY19pbmZvLnRcbiAgICB8IExhenkgb2YgdCBMYXp5LnRcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgZXh0cmFjdGlvbl92YXIgPSBFbnZfdmFyLnRvX3N0cmluZyBDT01NQU5EX09VVFBVVF9IRUxQX1NFWFBcblxuICBtb2R1bGUgVmVyc2lvbmVkID0gU3RhYmxlLlNleHBhYmxlLlZlcnNpb25lZFxuXG4gIGxldCBzdXBwb3J0ZWRfdmVyc2lvbnMgPVxuICAgIGxldCBmIGkgc3VwcG9ydGVkIF8gPSBTZXQuYWRkIHN1cHBvcnRlZCBpIGluXG4gICAgVmVyc2lvbmVkLlZhcmlhbnRzLmZvbGQgfmluaXQ6KFNldC5lbXB0eSAobW9kdWxlIEludCkpIH52MTooZiAxKSB+djI6KGYgMikgfnYzOihmIDMpXG4gIDs7XG5cbiAgbGV0IG9mX3ZlcnNpb25lZCA9IFZlcnNpb25lZC50b19sYXRlc3RcbiAgbGV0IHRvX3ZlcnNpb25lZCB0IH52ZXJzaW9uX3RvX3VzZSA9IFZlcnNpb25lZC5vZl9sYXRlc3QgdCB+dmVyc2lvbl90b191c2VcbmVuZFxuXG50eXBlIHQgPVxuICB8IEJhc2ljIG9mIEJhc2VfaW5mby50XG4gIHwgR3JvdXAgb2YgdCBHcm91cF9pbmZvLnRcbiAgfCBFeGVjIG9mIEV4ZWNfaW5mby50ICogKHVuaXQgLT4gdClcbiAgfCBMYXp5IG9mIHQgTGF6eS50XG5cbmxldCByZWMgZnVsbHlfZm9yY2VkIDogdCAtPiBGdWxseV9mb3JjZWQudCA9IGZ1bmN0aW9uXG4gIHwgQmFzaWMgYiAtPiBCYXNpYyBiXG4gIHwgR3JvdXAgZyAtPiBHcm91cCAoR3JvdXBfaW5mby5tYXAgZyB+ZjpmdWxseV9mb3JjZWQpXG4gIHwgRXhlYyAoZSwgZikgLT4gRXhlYyAoZSwgZnVsbHlfZm9yY2VkIChmICgpKSlcbiAgfCBMYXp5IHRodW5rIC0+IGZ1bGx5X2ZvcmNlZCAoTGF6eS5mb3JjZSB0aHVuaylcbjs7XG5cbmxldCByZWMgZ2V0X3N1bW1hcnkgPSBmdW5jdGlvblxuICB8IEJhc2ljIGIgLT4gYi5zdW1tYXJ5XG4gIHwgR3JvdXAgZyAtPiBnLnN1bW1hcnlcbiAgfCBFeGVjIChlLCBfKSAtPiBlLnN1bW1hcnlcbiAgfCBMYXp5IHRodW5rIC0+IGdldF9zdW1tYXJ5IChMYXp5LmZvcmNlIHRodW5rKVxuOztcblxubGV0IGhlbHBfdGV4dCA9IGBVc2VfQ29tbWFuZF91bml4XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBLZXlfdHlwZSA9IEtleV90eXBlXG5cbiAgbGV0IGFic19wYXRoID0gU3RhYmxlLkV4ZWNfaW5mby5hYnNfcGF0aFxuICBsZXQgaGVscF9zY3JlZW5fY29tcGFyZSA9IEZsYWdfaW5mby5oZWxwX3NjcmVlbl9jb21wYXJlXG4gIGxldCB3b3JkX3dyYXAgPSBGbGFnX2hlbHBfZGlzcGxheS53b3JkX3dyYXBfYW5kX3N0cmlwXG4gIGxldCBsb29rdXBfZXhwYW5kID0gbG9va3VwX2V4cGFuZFxuZW5kXG4iLCJvcGVuISBCYXNlXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgQ29tbWFuZF9pbnRmXG5tb2R1bGUgU2hhcGUgPSBTaGFwZVxuXG4oKiBpbiBvcmRlciB0byBkZWZpbmUgZXhwZWN0IHRlc3RzLCB3ZSB3YW50IHRvIHJhaXNlIHJhdGhlciB0aGFuIGV4aXQgaWYgdGhlIGNvZGUgaXNcbiAgIHJ1bm5pbmcgaW4gdGhlIHRlc3QgcnVubmVyIHByb2Nlc3MgKilcbmxldCByYWlzZV9pbnN0ZWFkX29mX2V4aXQgPVxuICBtYXRjaCBQcHhfaW5saW5lX3Rlc3RfbGliLnRlc3Rpbmcgd2l0aFxuICB8IGBUZXN0aW5nIGBBbV90ZXN0X3J1bm5lciAtPiB0cnVlXG4gIHwgYFRlc3RpbmcgYEFtX2NoaWxkX29mX3Rlc3RfcnVubmVyIHwgYE5vdF90ZXN0aW5nIC0+IGZhbHNlXG47O1xuXG5leGNlcHRpb24gRXhpdF9jYWxsZWQgb2YgeyBzdGF0dXMgOiBpbnQgfSBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4oKiBbcmFpc2VfaW5zdGVhZF9vZl9leGl0XS1yZXNwZWN0aW5nIHdyYXBwZXJzIGZvciBbZXhpdF0gYW5kIGZ1bmN0aW9ucyB0aGF0IGNhbGwgaXQgKilcbmluY2x1ZGUgc3RydWN0XG4gIGxldCBleGl0IHN0YXR1cyA9XG4gICAgaWYgcmFpc2VfaW5zdGVhZF9vZl9leGl0IHRoZW4gcmFpc2UgKEV4aXRfY2FsbGVkIHsgc3RhdHVzIH0pIGVsc2UgU3RkbGliLmV4aXQgc3RhdHVzXG4gIDs7XG5cbiAgbW9kdWxlIEV4biA9IHN0cnVjdFxuICAgIGxldCBoYW5kbGVfdW5jYXVnaHRfYW5kX2V4aXQgZiA9XG4gICAgICBpZiByYWlzZV9pbnN0ZWFkX29mX2V4aXRcbiAgICAgIHRoZW4gKFxuICAgICAgICB0cnkgZiAoKSB3aXRoXG4gICAgICAgIHwgRXhpdF9jYWxsZWQgeyBzdGF0dXMgPSAwIH0gYXMgZXhuIC0+IHByaW50X3MgWyVzZXhwIChleG4gOiBleG4pXSlcbiAgICAgIGVsc2UgRXhuLmhhbmRsZV91bmNhdWdodF9hbmRfZXhpdCBmXG4gICAgOztcbiAgZW5kXG5lbmRcblxubGV0IHVud29yZHMgeHMgPSBTdHJpbmcuY29uY2F0IH5zZXA6XCIgXCIgeHNcbmxldCB1bnBhcmFncmFwaHMgeHMgPSBTdHJpbmcuY29uY2F0IH5zZXA6XCJcXG5cXG5cIiB4c1xuXG5leGNlcHRpb24gRmFpbGVkX3RvX3BhcnNlX2NvbW1hbmRfbGluZSBvZiBzdHJpbmdcblxubGV0IGRpZSBmbXQgPSBrc3ByaW50ZiAoZnVuIG1zZyAoKSAtPiByYWlzZSAoRmFpbGVkX3RvX3BhcnNlX2NvbW1hbmRfbGluZSBtc2cpKSBmbXRcbmxldCBoZWxwX3NjcmVlbl9jb21wYXJlID0gU2hhcGUuUHJpdmF0ZS5oZWxwX3NjcmVlbl9jb21wYXJlXG5cbigqIHVuaXZlcnNhbCBtYXBzIGFyZSB1c2VkIHRvIHBhc3MgYXJvdW5kIHZhbHVlcyBiZXR3ZWVuIGRpZmZlcmVudCBiaXRzXG4gICBvZiBjb21tYW5kIGxpbmUgcGFyc2luZyBjb2RlIHdpdGhvdXQgaGF2aW5nIGEgaHVnZSBpbXBhY3Qgb24gdGhlXG4gICB0eXBlcyBpbnZvbHZlZFxuXG4gICAxLiBwYXNzaW5nIHZhbHVlcyBmcm9tIHBhcnNlZCBhcmdzIHRvIGNvbW1hbmQtbGluZSBhdXRvY29tcGxldGUgZnVuY3Rpb25zXG4gICAyLiBwYXNzaW5nIHNwZWNpYWwgdmFsdWVzIHRvIGEgYmFzZSBjb21tYW5kcyB0aGF0IHJlcXVlc3QgdGhlbSBpbiB0aGVpciBzcGVjXG4gKiBleHBhbmRlZCBzdWJjb21tYW5kIHBhdGhcbiAqIGFyZ3MgcGFzc2VkIHRvIHRoZSBiYXNlIGNvbW1hbmRcbiAqIGhlbHAgdGV4dCBmb3IgdGhlIGJhc2UgY29tbWFuZFxuICopXG5tb2R1bGUgRW52ID0gc3RydWN0XG4gIGluY2x1ZGUgVW5pdl9tYXBcblxuICBsZXQga2V5X2NyZWF0ZSBuYW1lID0gVW5pdl9tYXAuS2V5LmNyZWF0ZSB+bmFtZSBTZXhwbGliLkNvbnYuc2V4cF9vZl9vcGFxdWVcbiAgbGV0IG11bHRpX2FkZCA9IFVuaXZfbWFwLk11bHRpLmFkZFxuICBsZXQgc2V0X3dpdGhfZGVmYXVsdCA9IFVuaXZfbWFwLldpdGhfZGVmYXVsdC5zZXRcbmVuZFxuXG5sZXQga2V5X2ludGVybmFsX3ZhbGlkYXRlX3BhcnNpbmcgPVxuICBFbnYuS2V5LmNyZWF0ZSB+bmFtZTpcIi0tLS1pbnRlcm5hbC12YWxpZGF0ZS1wYXJzaW5nXCIgWyVzZXhwX29mOiB1bml0XVxuOztcblxubW9kdWxlIFBhcnNpbmdfb3V0Y29tZSA6IHNpZ1xuICB0eXBlICdhIHQgPVxuICAgIHsgcmVzdWx0IDogKCdhLCBbIGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzIG9mIEVycm9yLnQgXSkgUmVzdWx0LnRcbiAgICA7IGhhc19hcmcgOiBib29sXG4gICAgfVxuXG4gIHZhbCByZXR1cm5fbm9fYXJnIDogJ2EgLT4gJ2EgdFxuICB2YWwgcmV0dXJuX3dpdGhfYXJnIDogJ2EgLT4gJ2EgdFxuICB2YWwgZXJyb3IgOiBoYXNfYXJnOmJvb2wgLT4gWyBgTWlzc2luZ19yZXF1aXJlZF9mbGFncyBvZiBFcnJvci50IF0gLT4gJ2EgdFxuICB2YWwgcmVjb3Zlcl9mcm9tX21pc3NpbmdfcmVxdWlyZWRfZmxhZ3MgOiAnYSB0IC0+ICdhIHQgdFxuXG4gIHZhbCBpbnRyb2R1Y2VfbWlzc2luZ19yZXF1aXJlZF9mbGFnc1xuICAgIDogICgnYSwgWyBgTWlzc2luZ19yZXF1aXJlZF9mbGFncyBvZiBFcnJvci50IF0pIFJlc3VsdC50IHRcbiAgICAtPiAnYSB0XG5cbiAgaW5jbHVkZSBBcHBsaWNhdGl2ZS5TIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgcmVzdWx0IDogKCdhLCBbIGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzIG9mIEVycm9yLnQgXSkgUmVzdWx0LnRcbiAgICA7IGhhc19hcmcgOiBib29sXG4gICAgfVxuXG4gIGxldCBhcHBseSBmIHggPVxuICAgIHsgcmVzdWx0ID1cbiAgICAgICAgUmVzdWx0LmNvbWJpbmVcbiAgICAgICAgICBmLnJlc3VsdFxuICAgICAgICAgIHgucmVzdWx0XG4gICAgICAgICAgfm9rOihmdW4gZiB4IC0+IGYgeClcbiAgICAgICAgICB+ZXJyOihmdW4gKGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzIGVycl8xKSAoYE1pc3NpbmdfcmVxdWlyZWRfZmxhZ3MgX2Vycl8yKSAtPlxuICAgICAgICAgICAgYE1pc3NpbmdfcmVxdWlyZWRfZmxhZ3MgZXJyXzEpXG4gICAgOyBoYXNfYXJnID0gZi5oYXNfYXJnIHx8IHguaGFzX2FyZ1xuICAgIH1cbiAgOztcblxuICBsZXQgcmVjb3Zlcl9mcm9tX21pc3NpbmdfcmVxdWlyZWRfZmxhZ3MgdCA9IHsgcmVzdWx0ID0gT2sgdDsgaGFzX2FyZyA9IHQuaGFzX2FyZyB9XG5cbiAgbGV0IGludHJvZHVjZV9taXNzaW5nX3JlcXVpcmVkX2ZsYWdzIHQgPVxuICAgIHsgcmVzdWx0ID0gUmVzdWx0LmpvaW4gdC5yZXN1bHQ7IGhhc19hcmcgPSB0Lmhhc19hcmcgfVxuICA7O1xuXG4gIGxldCBtYXAgeyByZXN1bHQ7IGhhc19hcmcgfSB+ZiA9IHsgcmVzdWx0ID0gUmVzdWx0Lm1hcCByZXN1bHQgfmY7IGhhc19hcmcgfVxuICBsZXQgcmV0dXJuX25vX2FyZyB2ID0geyByZXN1bHQgPSBPayB2OyBoYXNfYXJnID0gZmFsc2UgfVxuICBsZXQgcmV0dXJuX3dpdGhfYXJnIHYgPSB7IHJlc3VsdCA9IE9rIHY7IGhhc19hcmcgPSB0cnVlIH1cbiAgbGV0IGVycm9yIH5oYXNfYXJnIGVyciA9IHsgcmVzdWx0ID0gRXJyb3IgZXJyOyBoYXNfYXJnIH1cblxuICBpbmNsdWRlIEFwcGxpY2F0aXZlLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuX25vX2FyZ1xuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgIGxldCBhcHBseSA9IGFwcGx5XG4gIGVuZClcbmVuZFxuXG5tb2R1bGUgQXV0b19jb21wbGV0ZSA9IHN0cnVjdFxuICB0eXBlIHQgPSBFbnYudCAtPiBwYXJ0OnN0cmluZyAtPiBzdHJpbmcgbGlzdFxuXG4gIG1vZHVsZSBGb3JfZXNjYXBlID0gc3RydWN0XG4gICAgdHlwZSB0ID0gRW52LnQgLT4gcGFydDpzdHJpbmcgbGlzdCAtPiBzdHJpbmcgbGlzdFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQ29tcGxldGVyID0gc3RydWN0XG4gIHR5cGUgdCA9IEF1dG9fY29tcGxldGUudCBvcHRpb25cblxuICBtb2R1bGUgRm9yX2VzY2FwZSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IEF1dG9fY29tcGxldGUuRm9yX2VzY2FwZS50IG9wdGlvblxuICBlbmRcblxuICBsZXQgcnVuX2FuZF9leGl0IHQgZW52IH5wYXJ0IDogTm90aGluZy50ID1cbiAgICBPcHRpb24uaXRlciB0IH5mOihmdW4gY29tcGxldGlvbnMgLT5cbiAgICAgIExpc3QuaXRlciB+ZjpwcmludF9lbmRsaW5lIChjb21wbGV0aW9ucyBlbnYgfnBhcnQpKTtcbiAgICBleGl0IDBcbiAgOztcbmVuZFxuXG5tb2R1bGUgQXJnX3R5cGUgOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGV4dHJhX2RvYyA6ICdhIHQgLT4gc3RyaW5nIG9wdGlvbiBsYXp5X3RcbiAgdmFsIGtleSA6ICdhIHQgLT4gJ2EgRW52Lk11bHRpLktleS50IG9wdGlvblxuICB2YWwgY29tcGxldGUgOiAnYSB0IC0+IENvbXBsZXRlci50XG4gIHZhbCBwYXJzZSA6ICdhIHQgLT4gc3RyaW5nIC0+ICdhIE9yX2Vycm9yLnRcblxuICB2YWwgY3JlYXRlXG4gICAgOiAgP2NvbXBsZXRlOkF1dG9fY29tcGxldGUudFxuICAgIC0+ID9rZXk6J2EgRW52Lk11bHRpLktleS50XG4gICAgLT4gKHN0cmluZyAtPiAnYSlcbiAgICAtPiAnYSB0XG5cbiAgdmFsIG1hcCA6ID9rZXk6J2EgRW52Lk11bHRpLktleS50IC0+ICdiIHQgLT4gZjooJ2IgLT4gJ2EpIC0+ICdhIHRcbiAgdmFsIG9mX2xhenkgOiA/a2V5OidhIEVudi5NdWx0aS5LZXkudCAtPiAnYSB0IGxhenlfdCAtPiAnYSB0XG5cbiAgdmFsIG9mX21hcFxuICAgIDogID9hY2NlcHRfdW5pcXVlX3ByZWZpeGVzOmJvb2xcbiAgICAtPiA/Y2FzZV9zZW5zaXRpdmU6Ym9vbFxuICAgIC0+ID9saXN0X3ZhbHVlc19pbl9oZWxwOmJvb2xcbiAgICAtPiA/YXV0b19jb21wbGV0ZTpBdXRvX2NvbXBsZXRlLnRcbiAgICAtPiA/a2V5OidhIEVudi5NdWx0aS5LZXkudFxuICAgIC0+ICdhIE1hcC5NKFN0cmluZykudFxuICAgIC0+ICdhIHRcblxuICB2YWwgb2ZfYWxpc3RfZXhuXG4gICAgOiAgP2FjY2VwdF91bmlxdWVfcHJlZml4ZXM6Ym9vbFxuICAgIC0+ID9jYXNlX3NlbnNpdGl2ZTpib29sXG4gICAgLT4gP2xpc3RfdmFsdWVzX2luX2hlbHA6Ym9vbFxuICAgIC0+ID9hdXRvX2NvbXBsZXRlOkF1dG9fY29tcGxldGUudFxuICAgIC0+ID9rZXk6J2EgRW52Lk11bHRpLktleS50XG4gICAgLT4gKHN0cmluZyAqICdhKSBsaXN0XG4gICAgLT4gJ2EgdFxuXG4gIHZhbCBlbnVtZXJhdGVkXG4gICAgOiAgP2FjY2VwdF91bmlxdWVfcHJlZml4ZXM6Ym9vbFxuICAgIC0+ID9jYXNlX3NlbnNpdGl2ZTpib29sXG4gICAgLT4gP2xpc3RfdmFsdWVzX2luX2hlbHA6Ym9vbFxuICAgIC0+ID9hdXRvX2NvbXBsZXRlOkF1dG9fY29tcGxldGUudFxuICAgIC0+ID9rZXk6J2EgRW52Lk11bHRpLktleS50XG4gICAgLT4gKG1vZHVsZSBFbnVtZXJhYmxlX3N0cmluZ2FibGUgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAtPiAnYSB0XG5cbiAgdmFsIGVudW1lcmF0ZWRfc2V4cGFibGVcbiAgICA6ICA/YWNjZXB0X3VuaXF1ZV9wcmVmaXhlczpib29sXG4gICAgLT4gP2Nhc2Vfc2Vuc2l0aXZlOmJvb2xcbiAgICAtPiA/bGlzdF92YWx1ZXNfaW5faGVscDpib29sXG4gICAgLT4gP2F1dG9fY29tcGxldGU6QXV0b19jb21wbGV0ZS50XG4gICAgLT4gP2tleTonYSBFbnYuTXVsdGkuS2V5LnRcbiAgICAtPiAobW9kdWxlIEVudW1lcmFibGVfc2V4cGFibGUgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAtPiAnYSB0XG5cbiAgdmFsIGNvbW1hX3NlcGFyYXRlZFxuICAgIDogID9hbGxvd19lbXB0eTpib29sXG4gICAgLT4gP2tleTonYSBsaXN0IEVudi5NdWx0aS5LZXkudFxuICAgIC0+ID9zdHJpcF93aGl0ZXNwYWNlOmJvb2xcbiAgICAtPiA/dW5pcXVlX3ZhbHVlczpib29sXG4gICAgLT4gJ2EgdFxuICAgIC0+ICdhIGxpc3QgdFxuXG4gIG1vZHVsZSBFeHBvcnQgOiBzaWdcbiAgICB2YWwgc3RyaW5nIDogc3RyaW5nIHRcbiAgICB2YWwgaW50IDogaW50IHRcbiAgICB2YWwgY2hhciA6IGNoYXIgdFxuICAgIHZhbCBmbG9hdCA6IGZsb2F0IHRcbiAgICB2YWwgYm9vbCA6IGJvb2wgdFxuICAgIHZhbCBzZXhwIDogU2V4cC50IHRcbiAgICB2YWwgc2V4cF9jb252IDogP2NvbXBsZXRlOkF1dG9fY29tcGxldGUudCAtPiAoU2V4cC50IC0+ICdhKSAtPiAnYSB0XG4gIGVuZFxuXG4gIHZhbCBhdXRvX2NvbXBsZXRlIDogXyB0IC0+IEF1dG9fY29tcGxldGUudFxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBwYXJzZSA6IHN0cmluZyAtPiAnYVxuICAgIDsgY29tcGxldGUgOiBDb21wbGV0ZXIudFxuICAgIDsga2V5IDogJ2EgVW5pdl9tYXAuTXVsdGkuS2V5LnQgb3B0aW9uXG4gICAgOyBleHRyYV9kb2MgOiBzdHJpbmcgb3B0aW9uIExhenkudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzXVxuXG4gIGxldCBwYXJzZSB0IHMgPSBPcl9lcnJvci50cnlfd2l0aCAoZnVuICgpIC0+IHQucGFyc2UgcylcbiAgbGV0IGNyZWF0ZScgP2NvbXBsZXRlID9rZXkgcGFyc2UgfmV4dHJhX2RvYyA9IHsgcGFyc2U7IGtleTsgY29tcGxldGU7IGV4dHJhX2RvYyB9XG5cbiAgbGV0IGNyZWF0ZSA/Y29tcGxldGUgP2tleSBvZl9zdHJpbmcgPVxuICAgIGNyZWF0ZScgP2NvbXBsZXRlID9rZXkgb2Zfc3RyaW5nIH5leHRyYV9kb2M6KExhenkuZnJvbV92YWwgTm9uZSlcbiAgOztcblxuICBsZXQgbWFwID9rZXkgdCB+ZiA9IHsgdCB3aXRoIGtleTsgcGFyc2UgPSAoZnVuIHMgLT4gZiAodC5wYXJzZSBzKSkgfVxuXG4gIGxldCBvZl9sYXp5ID9rZXkgdCA9XG4gICAgbGV0IHBhcnNlIHN0ciA9IChmb3JjZSB0KS5wYXJzZSBzdHIgaW5cbiAgICBsZXQgY29tcGxldGUgZW52IH5wYXJ0ID1cbiAgICAgIG1hdGNoIChmb3JjZSB0KS5jb21wbGV0ZSB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgKCogU2VlIFtydW5fYW5kX2V4aXRdIC0gbm8gY29tcGxldGlvbnMgaXMgZXF1aXZhbGVudCB0byBub3QgaGF2aW5nIGFcbiAgICAgICAgICAgW0NvbXBsZXRlXS4gKilcbiAgICAgICAgW11cbiAgICAgIHwgU29tZSBjb21wbGV0ZSAtPiBjb21wbGV0ZSBlbnYgfnBhcnRcbiAgICBpblxuICAgIGxldCBleHRyYV9kb2MgPSBMYXp5LmJpbmQgdCB+ZjpleHRyYV9kb2MgaW5cbiAgICB7IHBhcnNlOyBjb21wbGV0ZSA9IFNvbWUgY29tcGxldGU7IGtleTsgZXh0cmFfZG9jIH1cbiAgOztcblxuICBsZXQgc3RyaW5nID0gY3JlYXRlIEZuLmlkXG4gIGxldCBpbnQgPSBjcmVhdGUgSW50Lm9mX3N0cmluZ1xuICBsZXQgY2hhciA9IGNyZWF0ZSBDaGFyLm9mX3N0cmluZ1xuICBsZXQgZmxvYXQgPSBjcmVhdGUgRmxvYXQub2Zfc3RyaW5nXG4gIGxldCBzZXhwID0gY3JlYXRlIFBhcnNleHAuU2luZ2xlLnBhcnNlX3N0cmluZ19leG5cblxuICBsZXQgc2V4cF9jb252ID9jb21wbGV0ZSBvZl9zZXhwID1cbiAgICBjcmVhdGUgP2NvbXBsZXRlIChmdW4gcyAtPiBvZl9zZXhwIChQYXJzZXhwLlNpbmdsZS5wYXJzZV9zdHJpbmdfZXhuIHMpKVxuICA7O1xuXG4gIGxldCBhc3NvY2lhdGl2ZVxuICAgID8oYWNjZXB0X3VuaXF1ZV9wcmVmaXhlcyA9IHRydWUpXG4gICAgPyhsaXN0X3ZhbHVlc19pbl9oZWxwID0gdHJ1ZSlcbiAgICA/YXV0b19jb21wbGV0ZVxuICAgID9rZXlcbiAgICB+Y2FzZV9zZW5zaXRpdmVcbiAgICBhbGlzdFxuICAgID1cbiAgICBsZXQgb3BlbiBzdHJ1Y3RcbiAgICAgIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICAgICAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgPSBzdHJpbmdcblxuICAgICAgICB2YWwgaXNfcHJlZml4IDogc3RyaW5nIC0+IHByZWZpeDpzdHJpbmcgLT4gYm9vbFxuICAgICAgZW5kXG5cbiAgICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgIHwgVCA6XG4gICAgICAgICAgICB7IGNtcCA6IChtb2R1bGUgUyB3aXRoIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2NtcClcbiAgICAgICAgICAgIDsgbWFwIDogKHN0cmluZywgJ2EsICdjbXApIE1hcC50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAtPiAnYSB0XG4gICAgZW5kIGluXG4gICAgbGV0IChUIHsgY21wID0gKG1vZHVsZSBTKTsgbWFwIH0pID1cbiAgICAgIGxldCBtYWtlX21hcF9yYWlzZV9kdXBsaWNhdGVfa2V5XG4gICAgICAgICh0eXBlIGNtcClcbiAgICAgICAgKG1vZHVsZSBTIDogUyB3aXRoIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKVxuICAgICAgICBhbGlzdFxuICAgICAgICA9XG4gICAgICAgIG1hdGNoIE1hcC5vZl9hbGlzdCAobW9kdWxlIFMpIGFsaXN0IHdpdGhcbiAgICAgICAgfCBgT2sgbWFwIC0+IG1hcFxuICAgICAgICB8IGBEdXBsaWNhdGVfa2V5IChfIDogUy50KSAtPlxuICAgICAgICAgIGxldCBkdXBsaWNhdGVfa2V5cyA9XG4gICAgICAgICAgICBMaXN0Lm1hcCBhbGlzdCB+ZjooZnVuIChrLCAoXyA6ICdhKSkgLT4gaywgaylcbiAgICAgICAgICAgIHw+IE1hcC5vZl9hbGlzdF9tdWx0aSAobW9kdWxlIFMpXG4gICAgICAgICAgICB8PiBNYXAuZmlsdGVyIH5mOihmdW5jdGlvblxuICAgICAgICAgICAgICAgICB8IFtdIHwgWyBfIF0gLT4gZmFsc2VcbiAgICAgICAgICAgICAgICAgfCBfIDo6IF8gOjogXyAtPiB0cnVlKVxuICAgICAgICAgICAgfD4gTWFwLmRhdGFcbiAgICAgICAgICBpblxuICAgICAgICAgIHJhaXNlX3NcbiAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICBcIkNvbW1hbmQuU3BlYy5BcmdfdHlwZS5vZl9hbGlzdF9leG5cIiAoZHVwbGljYXRlX2tleXMgOiBzdHJpbmcgbGlzdCBsaXN0KV1cbiAgICAgIGluXG4gICAgICBsZXQgbWFrZSBjbXAgPSBUIHsgY21wOyBtYXAgPSBtYWtlX21hcF9yYWlzZV9kdXBsaWNhdGVfa2V5IGNtcCBhbGlzdCB9IGluXG4gICAgICBpZiBjYXNlX3NlbnNpdGl2ZSB0aGVuIG1ha2UgKG1vZHVsZSBTdHJpbmcpIGVsc2UgbWFrZSAobW9kdWxlIFN0cmluZy5DYXNlbGVzcylcbiAgICBpblxuICAgIGxldCBjb21wbGV0ZSB1bml2X21hcCB+cGFydDpwcmVmaXggPVxuICAgICAgbWF0Y2ggYXV0b19jb21wbGV0ZSB3aXRoXG4gICAgICB8IFNvbWUgY29tcGxldGUgLT4gY29tcGxldGUgdW5pdl9tYXAgfnBhcnQ6cHJlZml4XG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgTGlzdC5maWx0ZXJfbWFwIChNYXAudG9fYWxpc3QgbWFwKSB+ZjooZnVuIChuYW1lLCBfKSAtPlxuICAgICAgICAgIG1hdGNoIFMuaXNfcHJlZml4IG5hbWUgfnByZWZpeCB3aXRoXG4gICAgICAgICAgfCBmYWxzZSAtPiBOb25lXG4gICAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgICAoKiBCYXNoIGNvbXBsZXRpb24gd2lsbCBub3QgYWNjZXB0IFtGb29dIGFzIGEgY29tcGxldGlvbiBmb3IgW2ZdLiBTbyB3ZSBuZWVkXG4gICAgICAgICAgICAgICB0byBtYXRjaCB0aGUgY2FwaXRhbGl6YXRpb24gZ2l2ZW4uICopXG4gICAgICAgICAgICBsZXQgc3VmZml4ID0gU3RyaW5nLnN1Ym8gbmFtZSB+cG9zOihTdHJpbmcubGVuZ3RoIHByZWZpeCkgaW5cbiAgICAgICAgICAgIGxldCBuYW1lID0gcHJlZml4IF4gc3VmZml4IGluXG4gICAgICAgICAgICBTb21lIG5hbWUpXG4gICAgaW5cbiAgICBsZXQgZmluZCBhcmcgPVxuICAgICAgbWF0Y2ggTWFwLmZpbmQgbWFwIGFyZyB3aXRoXG4gICAgICB8IFNvbWUgXyBhcyBzIC0+IHNcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAobWF0Y2ggYWNjZXB0X3VuaXF1ZV9wcmVmaXhlcyB3aXRoXG4gICAgICAgICB8IGZhbHNlIC0+IE5vbmVcbiAgICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgICAobWF0Y2hcbiAgICAgICAgICAgICAgTWFwLnRvX2FsaXN0IG1hcFxuICAgICAgICAgICAgICB8PiBMaXN0LmZpbHRlciB+ZjooZnVuIChuYW1lLCBfKSAtPiBTLmlzX3ByZWZpeCBuYW1lIH5wcmVmaXg6YXJnKVxuICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgfCBbIChfc2luZ2xldG9uX2tleSwgdikgXSAtPiBTb21lIHZcbiAgICAgICAgICAgIHwgW10gfCBfIDo6IF8gOjogXyAtPlxuICAgICAgICAgICAgICAoKiBJbiB0aGUgdHdvLW9yLW1vcmUgY2FzZSB3ZSBjb3VsZCBwcm92aWRlIGZpbHRlcmVkIGhlbHAgdGV4dCwgYnV0IGl0J3NcbiAgICAgICAgICAgICAgICAgbW9yZSBnZW5lcmFsbHkgdXNlZnVsIHRvIGxpc3QgYWxsIHRoZSBvcHRpb25zLCB3aGljaCB3ZSBkbyBiZWxvdy4gKilcbiAgICAgICAgICAgICAgTm9uZSkpXG4gICAgaW5cbiAgICBjcmVhdGUnXG4gICAgICB+ZXh0cmFfZG9jOlxuICAgICAgICAobGF6eVxuICAgICAgICAgIChpZiBsaXN0X3ZhbHVlc19pbl9oZWxwXG4gICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBTdHJpbmcuY29uY2F0IH5zZXA6XCIsIFwiIChNYXAua2V5cyBtYXApIGluXG4gICAgICAgICAgICAgU29tZSBbJXN0cmluZyBcIihjYW4gYmU6ICV7dmFsdWVzfSlcIl0pXG4gICAgICAgICAgIGVsc2UgTm9uZSkpXG4gICAgICA/a2V5XG4gICAgICB+Y29tcGxldGVcbiAgICAgIChmdW4gYXJnIC0+XG4gICAgICAgIG1hdGNoIGZpbmQgYXJnIHdpdGhcbiAgICAgICAgfCBTb21lIHYgLT4gdlxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBsZXQgdmFsaWRfYXJndW1lbnRzX2V4dHJhID1cbiAgICAgICAgICAgIGlmIGNhc2Vfc2Vuc2l0aXZlIHRoZW4gXCJcIiBlbHNlIFwiIChjYXNlIGluc2Vuc2l0aXZlKVwiXG4gICAgICAgICAgaW5cbiAgICAgICAgICBmYWlsd2l0aGZcbiAgICAgICAgICAgIFwidmFsaWQgYXJndW1lbnRzJXM6IHslc31cIlxuICAgICAgICAgICAgdmFsaWRfYXJndW1lbnRzX2V4dHJhXG4gICAgICAgICAgICAoU3RyaW5nLmNvbmNhdCB+c2VwOlwiLFwiIChNYXAua2V5cyBtYXApKVxuICAgICAgICAgICAgKCkpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4blxuICAgID9hY2NlcHRfdW5pcXVlX3ByZWZpeGVzXG4gICAgPyhjYXNlX3NlbnNpdGl2ZSA9IHRydWUpXG4gICAgP2xpc3RfdmFsdWVzX2luX2hlbHBcbiAgICA/YXV0b19jb21wbGV0ZVxuICAgID9rZXlcbiAgICBhbGlzdFxuICAgID1cbiAgICBhc3NvY2lhdGl2ZVxuICAgICAgP2FjY2VwdF91bmlxdWVfcHJlZml4ZXNcbiAgICAgID9saXN0X3ZhbHVlc19pbl9oZWxwXG4gICAgICA/YXV0b19jb21wbGV0ZVxuICAgICAgP2tleVxuICAgICAgfmNhc2Vfc2Vuc2l0aXZlXG4gICAgICBhbGlzdFxuICA7O1xuXG4gIGxldCBvZl9tYXBcbiAgICA/YWNjZXB0X3VuaXF1ZV9wcmVmaXhlc1xuICAgID9jYXNlX3NlbnNpdGl2ZVxuICAgID9saXN0X3ZhbHVlc19pbl9oZWxwXG4gICAgP2F1dG9fY29tcGxldGVcbiAgICA/a2V5XG4gICAgbWFwXG4gICAgPVxuICAgIG9mX2FsaXN0X2V4blxuICAgICAgP2FjY2VwdF91bmlxdWVfcHJlZml4ZXNcbiAgICAgID9jYXNlX3NlbnNpdGl2ZVxuICAgICAgP2xpc3RfdmFsdWVzX2luX2hlbHBcbiAgICAgID9hdXRvX2NvbXBsZXRlXG4gICAgICA/a2V5XG4gICAgICAoTWFwLnRvX2FsaXN0IG1hcClcbiAgOztcblxuICBsZXQgZW51bWVyYXRlZFxuICAgICh0eXBlIHQpXG4gICAgP2FjY2VwdF91bmlxdWVfcHJlZml4ZXNcbiAgICA/Y2FzZV9zZW5zaXRpdmVcbiAgICA/bGlzdF92YWx1ZXNfaW5faGVscFxuICAgID9hdXRvX2NvbXBsZXRlXG4gICAgP2tleVxuICAgIChtb2R1bGUgRSA6IEVudW1lcmFibGVfc3RyaW5nYWJsZSB3aXRoIHR5cGUgdCA9IHQpXG4gICAgPVxuICAgIG9mX2FsaXN0X2V4blxuICAgICAgP2FjY2VwdF91bmlxdWVfcHJlZml4ZXNcbiAgICAgID9jYXNlX3NlbnNpdGl2ZVxuICAgICAgP2xpc3RfdmFsdWVzX2luX2hlbHBcbiAgICAgID9hdXRvX2NvbXBsZXRlXG4gICAgICA/a2V5XG4gICAgICAobGV0JW1hcC5MaXN0IHQgPSBFLmFsbCBpblxuICAgICAgIEUudG9fc3RyaW5nIHQsIHQpXG4gIDs7XG5cbiAgbGV0IGVudW1lcmF0ZWRfc2V4cGFibGVcbiAgICAodHlwZSB0KVxuICAgID9hY2NlcHRfdW5pcXVlX3ByZWZpeGVzXG4gICAgP2Nhc2Vfc2Vuc2l0aXZlXG4gICAgP2xpc3RfdmFsdWVzX2luX2hlbHBcbiAgICA/YXV0b19jb21wbGV0ZVxuICAgID9rZXlcbiAgICAobW9kdWxlIEUgOiBFbnVtZXJhYmxlX3NleHBhYmxlIHdpdGggdHlwZSB0ID0gdClcbiAgICA9XG4gICAgZW51bWVyYXRlZFxuICAgICAgP2FjY2VwdF91bmlxdWVfcHJlZml4ZXNcbiAgICAgID9jYXNlX3NlbnNpdGl2ZVxuICAgICAgP2xpc3RfdmFsdWVzX2luX2hlbHBcbiAgICAgID9hdXRvX2NvbXBsZXRlXG4gICAgICA/a2V5XG4gICAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgICBpbmNsdWRlIEVcblxuICAgICAgICBsZXQgdG9fc3RyaW5nIHQgPSBTZXhwLnRvX3N0cmluZyBbJXNleHAgKHQgOiBFLnQpXVxuICAgICAgZW5kKVxuICA7O1xuXG4gIGxldCBib29sID0gZW51bWVyYXRlZCB+bGlzdF92YWx1ZXNfaW5faGVscDpmYWxzZSAobW9kdWxlIEJvb2wpXG5cbiAgbGV0IGNvbW1hX3NlcGFyYXRlZFxuICAgID8oYWxsb3dfZW1wdHkgPSBmYWxzZSlcbiAgICA/a2V5XG4gICAgPyhzdHJpcF93aGl0ZXNwYWNlID0gZmFsc2UpXG4gICAgPyh1bmlxdWVfdmFsdWVzID0gZmFsc2UpXG4gICAgdFxuICAgID1cbiAgICBsZXQgc3RyaXAgPSBpZiBzdHJpcF93aGl0ZXNwYWNlIHRoZW4gZnVuIHN0ciAtPiBTdHJpbmcuc3RyaXAgc3RyIGVsc2UgRm4uaWQgaW5cbiAgICBsZXQgY29tcGxldGUgPVxuICAgICAgT3B0aW9uLm1hcCB0LmNvbXBsZXRlIH5mOihmdW4gY29tcGxldGVfZWx0IGVudiB+cGFydCAtPlxuICAgICAgICBsZXQgcHJlZml4ZXMsIHN1ZmZpeCA9XG4gICAgICAgICAgbWF0Y2ggU3RyaW5nLnNwbGl0IHBhcnQgfm9uOicsJyB8PiBMaXN0LnJldiB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBbXSwgcGFydFxuICAgICAgICAgIHwgaGQgOjogdGwgLT4gTGlzdC5yZXYgdGwsIGhkXG4gICAgICAgIGluXG4gICAgICAgIGxldCBpc19hbGxvd2VkID1cbiAgICAgICAgICBpZiBub3QgdW5pcXVlX3ZhbHVlc1xuICAgICAgICAgIHRoZW4gZnVuIChfIDogc3RyaW5nKSAtPiB0cnVlXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgc2Vlbl9hbHJlYWR5ID1cbiAgICAgICAgICAgICAgcHJlZml4ZXMgfD4gTGlzdC5tYXAgfmY6c3RyaXAgfD4gU2V0Lm9mX2xpc3QgKG1vZHVsZSBTdHJpbmcpXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgZnVuIGNob2ljZSAtPiBub3QgKFNldC5tZW0gc2Vlbl9hbHJlYWR5IChzdHJpcCBjaG9pY2UpKSlcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGNob2ljZXMgPVxuICAgICAgICAgIG1hdGNoXG4gICAgICAgICAgICBMaXN0LmZpbHRlciAoY29tcGxldGVfZWx0IGVudiB+cGFydDpzdWZmaXgpIH5mOihmdW4gY2hvaWNlIC0+XG4gICAgICAgICAgICAgIChub3QgKFN0cmluZy5tZW0gY2hvaWNlICcsJykpICYmIGlzX2FsbG93ZWQgY2hvaWNlKVxuICAgICAgICAgIHdpdGhcbiAgICAgICAgICAoKiBJZiB0aGVyZSBpcyBleGFjdGx5IG9uZSBjaG9pY2UgdG8gYXV0by1jb21wbGV0ZSwgYWRkIGEgc2Vjb25kIGNob2ljZSB3aXRoXG4gICAgICAgICAgICAgYSB0cmFpbGluZyBjb21tYSBzbyB0aGF0IGF1dG8tY29tcGxldGlvbiB3aWxsIGdvIHRvIHRoZSBlbmQgYnV0IGJhc2hcbiAgICAgICAgICAgICB3b24ndCBhZGQgYSBzcGFjZS4gIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjaG9pY2VzLCBvciBhIHNpbmdsZSBjaG9pY2VcbiAgICAgICAgICAgICB0aGF0IG11c3QgYmUgZmluYWwsIHRoZXJlIGlzIG5vIG5lZWQgdG8gYWRkIGEgZHVtbXkgb3B0aW9uLiAqKVxuICAgICAgICAgIHwgWyBjaG9pY2UgXSAtPiBbIGNob2ljZTsgY2hvaWNlIF4gXCIsXCIgXVxuICAgICAgICAgIHwgY2hvaWNlcyAtPiBjaG9pY2VzXG4gICAgICAgIGluXG4gICAgICAgIExpc3QubWFwIGNob2ljZXMgfmY6KGZ1biBjaG9pY2UgLT4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiLFwiIChwcmVmaXhlcyBAIFsgY2hvaWNlIF0pKSlcbiAgICBpblxuICAgIGxldCBvZl9zdHJpbmcgc3RyaW5nID1cbiAgICAgIGxldCBzdHJpbmcgPSBzdHJpcCBzdHJpbmcgaW5cbiAgICAgIGlmIFN0cmluZy5pc19lbXB0eSBzdHJpbmdcbiAgICAgIHRoZW5cbiAgICAgICAgaWYgYWxsb3dfZW1wdHlcbiAgICAgICAgdGhlbiBbXVxuICAgICAgICBlbHNlIGZhaWx3aXRoIFwiQ29tbWFuZC5TcGVjLkFyZ190eXBlLmNvbW1hX3NlcGFyYXRlZDogZW1wdHkgbGlzdCBub3QgYWxsb3dlZFwiXG4gICAgICBlbHNlIExpc3QubWFwIChTdHJpbmcuc3BsaXQgc3RyaW5nIH5vbjonLCcpIH5mOihmdW4gc3RyIC0+IHQucGFyc2UgKHN0cmlwIHN0cikpXG4gICAgaW5cbiAgICBjcmVhdGUgP2tleSA/Y29tcGxldGUgb2Zfc3RyaW5nXG4gIDs7XG5cbiAgbW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICAgIGxldCBzdHJpbmcgPSBzdHJpbmdcbiAgICBsZXQgaW50ID0gaW50XG4gICAgbGV0IGNoYXIgPSBjaGFyXG4gICAgbGV0IGZsb2F0ID0gZmxvYXRcbiAgICBsZXQgYm9vbCA9IGJvb2xcbiAgICBsZXQgc2V4cCA9IHNleHBcbiAgICBsZXQgc2V4cF9jb252ID0gc2V4cF9jb252XG4gIGVuZFxuXG4gIGxldCBhdXRvX2NvbXBsZXRlIHQgPVxuICAgIG1hdGNoIHQuY29tcGxldGUgd2l0aFxuICAgIHwgU29tZSBmIC0+IGZcbiAgICB8IE5vbmUgLT4gZnVuIF8gfnBhcnQ6XyAtPiBbXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBGbGFnID0gc3RydWN0XG4gIG1vZHVsZSBOdW1fb2NjdXJyZW5jZXMgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBTaGFwZS5OdW1fb2NjdXJyZW5jZXMudCA9XG4gICAgICB7IGF0X2xlYXN0X29uY2UgOiBib29sXG4gICAgICA7IGF0X21vc3Rfb25jZSA6IGJvb2xcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBlbnVtZXJhdGUsIHNleHBfb2ZdXG5cbiAgICBsZXQgdG9faGVscF9zdHJpbmcgPSBTaGFwZS5OdW1fb2NjdXJyZW5jZXMudG9faGVscF9zdHJpbmdcblxuICAgIGxldCB0b19oZWxwX3N0cmluZ19kZXByZWNhdGVkIHsgYXRfbGVhc3Rfb25jZTsgYXRfbW9zdF9vbmNlID0gXyB9IGZsYWdfbmFtZSA9XG4gICAgICB0b19oZWxwX3N0cmluZyB7IGF0X2xlYXN0X29uY2U7IGF0X21vc3Rfb25jZSA9IHRydWUgfSB+ZmxhZ19uYW1lXG4gICAgOztcblxuICAgIGxldCBhbnkgPSB7IGF0X2xlYXN0X29uY2UgPSBmYWxzZTsgYXRfbW9zdF9vbmNlID0gZmFsc2UgfVxuICAgIGxldCBhdF9sZWFzdF9vbmNlID0geyBhdF9sZWFzdF9vbmNlID0gdHJ1ZTsgYXRfbW9zdF9vbmNlID0gZmFsc2UgfVxuICAgIGxldCBhdF9tb3N0X29uY2UgPSB7IGF0X2xlYXN0X29uY2UgPSBmYWxzZTsgYXRfbW9zdF9vbmNlID0gdHJ1ZSB9XG4gICAgbGV0IGV4YWN0bHlfb25jZSA9IHsgYXRfbGVhc3Rfb25jZSA9IHRydWU7IGF0X21vc3Rfb25jZSA9IHRydWUgfVxuICBlbmRcblxuICB0eXBlIGFjdGlvbiA9XG4gICAgfCBOb19hcmcgb2YgKEVudi50IC0+IEVudi50KVxuICAgIHwgUHJpbnRfaW5mb19hbmRfcXVpdCBvZiAoRW52LnQgLT4gc3RyaW5nKVxuICAgIHwgQXJnIG9mIChFbnYudCAtPiBzdHJpbmcgLT4gRW52LnQpICogQ29tcGxldGVyLnRcbiAgICB8IFJlc3Qgb2YgKEVudi50IC0+IHN0cmluZyBsaXN0IC0+IEVudi50KSAqIENvbXBsZXRlci5Gb3JfZXNjYXBlLnRcblxuICBtb2R1bGUgSW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgeyBuYW1lIDogc3RyaW5nXG4gICAgICA7IGFsaWFzZXMgOiBzdHJpbmcgbGlzdFxuICAgICAgOyBhbGlhc2VzX2V4Y2x1ZGVkX2Zyb21faGVscCA6IHN0cmluZyBsaXN0XG4gICAgICAgICAgKCogW2FsaWFzZXNfZXhjbHVkZWRfZnJvbV9oZWxwXSBhcmUgYWxpYXNlcyB0aGF0IGRvbid0IHNob3cgdXAgaW4gLWhlbHAgb3V0cHV0LlxuICAgICAgICAgQ3VycmVudGx5IHRoZXkncmUgb25seSB1c2VkIGZvciBkb3VibGUtZGFzaCBidWlsdC1pbiBmbGFncyBsaWtlIC0taGVscCBhbmRcbiAgICAgICAgIC0tdmVyc2lvbi4gKilcbiAgICAgIDsgYWN0aW9uIDogYWN0aW9uXG4gICAgICA7IGRvYyA6IHN0cmluZ1xuICAgICAgOyBudW1fb2NjdXJyZW5jZXMgOiBOdW1fb2NjdXJyZW5jZXMudFxuICAgICAgOyBjaGVja19hdmFpbGFibGUgOiBFbnYudCAtPiB1bml0XG4gICAgICA7IG5hbWVfbWF0Y2hpbmcgOiBbIGBQcmVmaXggfCBgRnVsbF9tYXRjaF9yZXF1aXJlZCBdXG4gICAgICB9XG5cbiAgICBsZXQgd3JhcF9pZl9vcHRpb25hbCB0IGZsYWdfbmFtZSA9XG4gICAgICBOdW1fb2NjdXJyZW5jZXMudG9faGVscF9zdHJpbmcgdC5udW1fb2NjdXJyZW5jZXMgfmZsYWdfbmFtZVxuICAgIDs7XG5cbiAgICBtb2R1bGUgRG9jID0gc3RydWN0XG4gICAgICB0eXBlIHQgPVxuICAgICAgICB7IGFyZ19kb2MgOiBzdHJpbmcgb3B0aW9uXG4gICAgICAgIDsgZG9jIDogc3RyaW5nXG4gICAgICAgIH1cblxuICAgICAgbGV0IHBhcnNlIH5hY3Rpb24gfmRvYyA9XG4gICAgICAgIGxldCBhcmdfZG9jLCBkb2MgPVxuICAgICAgICAgIG1hdGNoIChhY3Rpb24gOiBhY3Rpb24pLCBTdHJpbmcubHNwbGl0MiBkb2Mgfm9uOicgJyB3aXRoXG4gICAgICAgICAgfCAoTm9fYXJnIF8gfCBQcmludF9pbmZvX2FuZF9xdWl0IF8pLCBfIC0+IE5vbmUsIGRvY1xuICAgICAgICAgIHwgQXJnIF8sIChOb25lIHwgU29tZSAoXCJcIiwgXykpIC0+IFNvbWUgXCJfXCIsIGRvY1xuICAgICAgICAgIHwgUmVzdCBfLCAoTm9uZSB8IFNvbWUgKFwiXCIsIF8pKSAtPiBOb25lLCBkb2NcbiAgICAgICAgICB8IChBcmcgXyB8IFJlc3QgXyksIFNvbWUgKGFyZywgZG9jKSAtPiBTb21lIGFyZywgZG9jXG4gICAgICAgIGluXG4gICAgICAgIHsgZG9jID0gU3RyaW5nLnN0cmlwIGRvYzsgYXJnX2RvYyB9XG4gICAgICA7O1xuXG4gICAgICBsZXQgY29uY2F0IH5uYW1lIH5hcmdfZG9jID1cbiAgICAgICAgbWF0Y2ggYXJnX2RvYyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBuYW1lXG4gICAgICAgIHwgU29tZSBhcmdfZG9jIC0+IG5hbWUgXiBcIiBcIiBeIGFyZ19kb2NcbiAgICAgIDs7XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgRGVwcmVjYXRlZCA9IHN0cnVjdFxuICAgICAgbGV0IHdyYXBfaWZfb3B0aW9uYWwgdCB4ID1cbiAgICAgICAgTnVtX29jY3VycmVuY2VzLnRvX2hlbHBfc3RyaW5nX2RlcHJlY2F0ZWQgdC5udW1fb2NjdXJyZW5jZXMgeFxuICAgICAgOztcblxuICAgICAgKCogZmxhZyBoZWxwIGluIHRoZSBmb3JtYXQgb2YgdGhlIG9sZCBjb21tYW5kLiB1c2VkIGZvciBpbmplY3Rpb24gKilcbiAgICAgIGxldCBoZWxwXG4gICAgICAgICh7IG5hbWVcbiAgICAgICAgIDsgZG9jXG4gICAgICAgICA7IGFsaWFzZXNcbiAgICAgICAgIDsgYWN0aW9uXG4gICAgICAgICA7IG51bV9vY2N1cnJlbmNlcyA9IF9cbiAgICAgICAgIDsgY2hlY2tfYXZhaWxhYmxlID0gX1xuICAgICAgICAgOyBuYW1lX21hdGNoaW5nID0gX1xuICAgICAgICAgOyBhbGlhc2VzX2V4Y2x1ZGVkX2Zyb21faGVscCA9IF9cbiAgICAgICAgIH0gYXMgdClcbiAgICAgICAgPVxuICAgICAgICBpZiBTdHJpbmcuaXNfcHJlZml4IGRvYyB+cHJlZml4OlwiIFwiXG4gICAgICAgIHRoZW5cbiAgICAgICAgICAobmFtZSwgU3RyaW5nLmxzdHJpcCBkb2MpXG4gICAgICAgICAgOjogTGlzdC5tYXAgYWxpYXNlcyB+ZjooZnVuIHggLT4geCwgc3ByaW50ZiBcInNhbWUgYXMgXFxcIiVzXFxcIlwiIG5hbWUpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCB7IERvYy5hcmdfZG9jOyBkb2MgfSA9IERvYy5wYXJzZSB+YWN0aW9uIH5kb2MgaW5cbiAgICAgICAgICAod3JhcF9pZl9vcHRpb25hbCB0IChEb2MuY29uY2F0IH5uYW1lIH5hcmdfZG9jKSwgZG9jKVxuICAgICAgICAgIDo6IExpc3QubWFwIGFsaWFzZXMgfmY6KGZ1biB4IC0+XG4gICAgICAgICAgICAgICAoIHdyYXBfaWZfb3B0aW9uYWwgdCAoRG9jLmNvbmNhdCB+bmFtZTp4IH5hcmdfZG9jKVxuICAgICAgICAgICAgICAgLCBzcHJpbnRmIFwic2FtZSBhcyBcXFwiJXNcXFwiXCIgbmFtZSApKSlcbiAgICAgIDs7XG4gICAgZW5kXG5cbiAgICBsZXQgYWxpZ25cbiAgICAgICh7IG5hbWVcbiAgICAgICA7IGRvY1xuICAgICAgIDsgYWxpYXNlc1xuICAgICAgIDsgYWN0aW9uXG4gICAgICAgOyBudW1fb2NjdXJyZW5jZXMgPSBfXG4gICAgICAgOyBjaGVja19hdmFpbGFibGUgPSBfXG4gICAgICAgOyBuYW1lX21hdGNoaW5nID0gX1xuICAgICAgIDsgYWxpYXNlc19leGNsdWRlZF9mcm9tX2hlbHAgPSBfXG4gICAgICAgfSBhcyB0KVxuICAgICAgOiBTaGFwZS5GbGFnX2luZm8udFxuICAgICAgPVxuICAgICAgbGV0IHsgRG9jLmFyZ19kb2M7IGRvYyB9ID0gRG9jLnBhcnNlIH5hY3Rpb24gfmRvYyBpblxuICAgICAgbGV0IG5hbWUgPSB3cmFwX2lmX29wdGlvbmFsIHQgKERvYy5jb25jYXQgfm5hbWUgfmFyZ19kb2MpIGluXG4gICAgICB7IG5hbWU7IGRvYzsgYWxpYXNlcyB9XG4gICAgOztcblxuICAgIGxldCBjcmVhdGUgZmxhZ3MgPVxuICAgICAgbWF0Y2hcbiAgICAgICAgTWFwLm9mX2FsaXN0IChtb2R1bGUgU3RyaW5nKSAoTGlzdC5tYXAgZmxhZ3MgfmY6KGZ1biBmbGFnIC0+IGZsYWcubmFtZSwgZmxhZykpXG4gICAgICB3aXRoXG4gICAgICB8IGBEdXBsaWNhdGVfa2V5IGZsYWcgLT4gZmFpbHdpdGhmIFwibXVsdGlwbGUgZmxhZ3MgbmFtZWQgJXNcIiBmbGFnICgpXG4gICAgICB8IGBPayBtYXAgLT5cbiAgICAgICAgTGlzdC5jb25jYXRfbWFwIGZsYWdzIH5mOihmdW4gZmxhZyAtPiBmbGFnLm5hbWUgOjogZmxhZy5hbGlhc2VzKVxuICAgICAgICB8PiBMaXN0LmZpbmRfYV9kdXAgfmNvbXBhcmU6WyVjb21wYXJlOiBzdHJpbmddXG4gICAgICAgIHw+IE9wdGlvbi5pdGVyIH5mOihmdW4geCAtPiBmYWlsd2l0aGYgXCJtdWx0aXBsZSBmbGFncyBvciBhbGlhc2VzIG5hbWVkICVzXCIgeCAoKSk7XG4gICAgICAgIG1hcFxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgJ2Egc3RhdGUgPVxuICAgIHsgYWN0aW9uIDogYWN0aW9uXG4gICAgOyByZWFkIDogRW52LnQgLT4gJ2EgUGFyc2luZ19vdXRjb21lLnRcbiAgICA7IG51bV9vY2N1cnJlbmNlcyA6IE51bV9vY2N1cnJlbmNlcy50XG4gICAgOyBleHRyYV9kb2MgOiBzdHJpbmcgb3B0aW9uIExhenkudFxuICAgIH1cblxuICB0eXBlICdhIHQgPSBzdHJpbmcgLT4gJ2Egc3RhdGVcblxuICBsZXQgYXJnX2ZsYWcgbmFtZSBhcmdfdHlwZSByZWFkIHdyaXRlIG51bV9vY2N1cnJlbmNlcyA9XG4gICAgeyByZWFkXG4gICAgOyBudW1fb2NjdXJyZW5jZXNcbiAgICA7IGFjdGlvbiA9XG4gICAgICAgIChsZXQgdXBkYXRlIGVudiBhcmcgPVxuICAgICAgICAgICBtYXRjaCBBcmdfdHlwZS5wYXJzZSBhcmdfdHlwZSBhcmcgd2l0aFxuICAgICAgICAgICB8IEVycm9yIGVycm9yIC0+XG4gICAgICAgICAgICAgZGllXG4gICAgICAgICAgICAgICBcImZhaWxlZCB0byBwYXJzZSAlcyB2YWx1ZSAlUy5cXG4lc1wiXG4gICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICBhcmdcbiAgICAgICAgICAgICAgIChFcnJvci50b19zdHJpbmdfaHVtIGVycm9yKVxuICAgICAgICAgICAgICAgKClcbiAgICAgICAgICAgfCBPayBhcmcgLT5cbiAgICAgICAgICAgICBsZXQgZW52ID0gd3JpdGUgZW52IGFyZyBpblxuICAgICAgICAgICAgIChtYXRjaCBBcmdfdHlwZS5rZXkgYXJnX3R5cGUgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gZW52XG4gICAgICAgICAgICAgIHwgU29tZSBrZXkgLT4gRW52Lm11bHRpX2FkZCBlbnYgfmtleSB+ZGF0YTphcmcpXG4gICAgICAgICBpblxuICAgICAgICAgQXJnICh1cGRhdGUsIEFyZ190eXBlLmNvbXBsZXRlIGFyZ190eXBlKSlcbiAgICA7IGV4dHJhX2RvYyA9IEFyZ190eXBlLmV4dHJhX2RvYyBhcmdfdHlwZVxuICAgIH1cbiAgOztcblxuICBsZXQgbWFwX2ZsYWcgKHQgOiBfIHQpIH5mIGlucHV0ID1cbiAgICBsZXQgeyBhY3Rpb247IHJlYWQ7IG51bV9vY2N1cnJlbmNlczsgZXh0cmFfZG9jIH0gPSB0IGlucHV0IGluXG4gICAgeyBhY3Rpb25cbiAgICA7IHJlYWQgPSAoZnVuIGVudiAtPiBQYXJzaW5nX291dGNvbWUubWFwIChyZWFkIGVudikgfmYpXG4gICAgOyBudW1fb2NjdXJyZW5jZXNcbiAgICA7IGV4dHJhX2RvY1xuICAgIH1cbiAgOztcblxuICBsZXQgd3JpdGVfb3B0aW9uIG5hbWUga2V5IGVudiBhcmcgPVxuICAgIEVudi51cGRhdGUgZW52IGtleSB+ZjooZnVuY3Rpb25cbiAgICAgIHwgTm9uZSAtPiBhcmdcbiAgICAgIHwgU29tZSBfIC0+IGRpZSBcImZsYWcgJXMgcGFzc2VkIG1vcmUgdGhhbiBvbmNlXCIgbmFtZSAoKSlcbiAgOztcblxuICBsZXQgcmVxdWlyZWRfdmFsdWUgP2RlZmF1bHQgYXJnX3R5cGUgbmFtZSBudW1fb2NjdXJyZW5jZXMgPVxuICAgIGxldCBrZXkgPSBFbnYuS2V5LmNyZWF0ZSB+bmFtZSBbJXNleHBfb2Y6IF9dIGluXG4gICAgbGV0IHJlYWQgZW52ID1cbiAgICAgIG1hdGNoIEVudi5maW5kIGVudiBrZXkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gUGFyc2luZ19vdXRjb21lLnJldHVybl93aXRoX2FyZyB2XG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgKG1hdGNoIGRlZmF1bHQgd2l0aFxuICAgICAgICAgfCBTb21lIHYgLT4gUGFyc2luZ19vdXRjb21lLnJldHVybl9ub19hcmcgdlxuICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgIFBhcnNpbmdfb3V0Y29tZS5lcnJvclxuICAgICAgICAgICAgIH5oYXNfYXJnOmZhbHNlXG4gICAgICAgICAgICAgKGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzXG4gICAgICAgICAgICAgICAoRXJyb3Iub2Zfc3RyaW5nIChzcHJpbnRmIFwibWlzc2luZyByZXF1aXJlZCBmbGFnOiAlc1wiIG5hbWUpKSkpXG4gICAgaW5cbiAgICBsZXQgd3JpdGUgZW52IGFyZyA9IHdyaXRlX29wdGlvbiBuYW1lIGtleSBlbnYgYXJnIGluXG4gICAgYXJnX2ZsYWcgbmFtZSBhcmdfdHlwZSByZWFkIHdyaXRlIG51bV9vY2N1cnJlbmNlc1xuICA7O1xuXG4gIGxldCByZXF1aXJlZCBhcmdfdHlwZSBuYW1lID0gcmVxdWlyZWRfdmFsdWUgYXJnX3R5cGUgbmFtZSBOdW1fb2NjdXJyZW5jZXMuZXhhY3RseV9vbmNlXG5cbiAgbGV0IG9wdGlvbmFsX3dpdGhfZGVmYXVsdCBkZWZhdWx0IGFyZ190eXBlIG5hbWUgPVxuICAgIHJlcXVpcmVkX3ZhbHVlIH5kZWZhdWx0IGFyZ190eXBlIG5hbWUgTnVtX29jY3VycmVuY2VzLmF0X21vc3Rfb25jZVxuICA7O1xuXG4gIGxldCBvcHRpb25hbCBhcmdfdHlwZSBuYW1lID1cbiAgICBsZXQga2V5ID0gRW52LktleS5jcmVhdGUgfm5hbWUgWyVzZXhwX29mOiBfXSBpblxuICAgIGxldCByZWFkIGVudiA9XG4gICAgICBtYXRjaCBFbnYuZmluZCBlbnYga2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBQYXJzaW5nX291dGNvbWUucmV0dXJuX25vX2FyZyBOb25lXG4gICAgICB8IFNvbWUgXyBhcyB2YWx1ZSAtPiBQYXJzaW5nX291dGNvbWUucmV0dXJuX3dpdGhfYXJnIHZhbHVlXG4gICAgaW5cbiAgICBsZXQgd3JpdGUgZW52IGFyZyA9IHdyaXRlX29wdGlvbiBuYW1lIGtleSBlbnYgYXJnIGluXG4gICAgYXJnX2ZsYWcgbmFtZSBhcmdfdHlwZSByZWFkIHdyaXRlIE51bV9vY2N1cnJlbmNlcy5hdF9tb3N0X29uY2VcbiAgOztcblxuICBsZXQgbm9fYXJnX2dlbmVyYWwgfmlzX3JlcXVpcmVkIH5rZXlfdmFsdWUgfmRlcHJlY2F0ZWRfaG9vayBuYW1lID1cbiAgICBsZXQga2V5ID0gRW52LktleS5jcmVhdGUgfm5hbWUgWyVzZXhwX29mOiB1bml0XSBpblxuICAgIGxldCByZWFkIGVudiA9XG4gICAgICBtYXRjaCBFbnYubWVtIGVudiBrZXkgd2l0aFxuICAgICAgfCB0cnVlIC0+IFBhcnNpbmdfb3V0Y29tZS5yZXR1cm5fd2l0aF9hcmcgdHJ1ZVxuICAgICAgfCBmYWxzZSAtPlxuICAgICAgICBpZiBpc19yZXF1aXJlZFxuICAgICAgICB0aGVuXG4gICAgICAgICAgUGFyc2luZ19vdXRjb21lLmVycm9yXG4gICAgICAgICAgICB+aGFzX2FyZzpmYWxzZVxuICAgICAgICAgICAgKGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzXG4gICAgICAgICAgICAgIChFcnJvci5vZl9zdHJpbmcgKHNwcmludGYgXCJtaXNzaW5nIHJlcXVpcmVkIGZsYWc6ICVzXCIgbmFtZSkpKVxuICAgICAgICBlbHNlIFBhcnNpbmdfb3V0Y29tZS5yZXR1cm5fbm9fYXJnIGZhbHNlXG4gICAgaW5cbiAgICBsZXQgd3JpdGUgZW52ID1cbiAgICAgIGlmIEVudi5tZW0gZW52IGtleVxuICAgICAgdGhlbiBkaWUgXCJmbGFnICVzIHBhc3NlZCBtb3JlIHRoYW4gb25jZVwiIG5hbWUgKClcbiAgICAgIGVsc2UgRW52LnNldCBlbnYgfmtleSB+ZGF0YTooKVxuICAgIGluXG4gICAgbGV0IGFjdGlvbiBlbnYgPVxuICAgICAgbGV0IGVudiA9XG4gICAgICAgIE9wdGlvbi5mb2xkIGtleV92YWx1ZSB+aW5pdDplbnYgfmY6KGZ1biBlbnYgKGtleSwgdmFsdWUpIC0+XG4gICAgICAgICAgRW52LnNldF93aXRoX2RlZmF1bHQgZW52IH5rZXkgfmRhdGE6dmFsdWUpXG4gICAgICBpblxuICAgICAgd3JpdGUgZW52XG4gICAgaW5cbiAgICBsZXQgYWN0aW9uID1cbiAgICAgIG1hdGNoIGRlcHJlY2F0ZWRfaG9vayB3aXRoXG4gICAgICB8IE5vbmUgLT4gYWN0aW9uXG4gICAgICB8IFNvbWUgZiAtPlxuICAgICAgICBmdW4gZW52IC0+XG4gICAgICAgICAgbGV0IGVudiA9IGFjdGlvbiBlbnYgaW5cbiAgICAgICAgICBmICgpO1xuICAgICAgICAgIGVudlxuICAgIGluXG4gICAgeyByZWFkXG4gICAgOyBhY3Rpb24gPSBOb19hcmcgYWN0aW9uXG4gICAgOyBudW1fb2NjdXJyZW5jZXMgPVxuICAgICAgICAoaWYgaXNfcmVxdWlyZWRcbiAgICAgICAgIHRoZW4gTnVtX29jY3VycmVuY2VzLmV4YWN0bHlfb25jZVxuICAgICAgICAgZWxzZSBOdW1fb2NjdXJyZW5jZXMuYXRfbW9zdF9vbmNlKVxuICAgIDsgZXh0cmFfZG9jID0gTGF6eS5mcm9tX3ZhbCBOb25lXG4gICAgfVxuICA7O1xuXG4gIGxldCBub19hcmcgbmFtZSA9XG4gICAgbm9fYXJnX2dlbmVyYWwgbmFtZSB+aXNfcmVxdWlyZWQ6ZmFsc2UgfmtleV92YWx1ZTpOb25lIH5kZXByZWNhdGVkX2hvb2s6Tm9uZVxuICA7O1xuXG4gIGxldCBub19hcmdfcmVxdWlyZWQgdiBuYW1lID1cbiAgICBtYXBfZmxhZ1xuICAgICAgKG5vX2FyZ19nZW5lcmFsIH5pc19yZXF1aXJlZDp0cnVlIH5rZXlfdmFsdWU6Tm9uZSB+ZGVwcmVjYXRlZF9ob29rOk5vbmUpXG4gICAgICB+ZjooZnVuY3Rpb25cbiAgICAgICAgfCB0cnVlIC0+IHZcbiAgICAgICAgfCBmYWxzZSAtPiBhc3NlcnQgZmFsc2UpXG4gICAgICBuYW1lXG4gIDs7XG5cbiAgbGV0IG5vX2FyZ19yZWdpc3RlciB+a2V5IH52YWx1ZSBuYW1lID1cbiAgICBub19hcmdfZ2VuZXJhbFxuICAgICAgbmFtZVxuICAgICAgfmlzX3JlcXVpcmVkOmZhbHNlXG4gICAgICB+a2V5X3ZhbHVlOihTb21lIChrZXksIHZhbHVlKSlcbiAgICAgIH5kZXByZWNhdGVkX2hvb2s6Tm9uZVxuICA7O1xuXG4gIGxldCBub19hcmdfc29tZSB2YWx1ZSA9XG4gICAgbWFwX2ZsYWcgbm9fYXJnIH5mOihmdW5jdGlvblxuICAgICAgfCB0cnVlIC0+IFNvbWUgdmFsdWVcbiAgICAgIHwgZmFsc2UgLT4gTm9uZSlcbiAgOztcblxuICBsZXQgbGlzdGVkIGFyZ190eXBlIG5hbWUgPVxuICAgIGxldCBrZXkgPSBFbnYuV2l0aF9kZWZhdWx0LktleS5jcmVhdGUgfmRlZmF1bHQ6W10gfm5hbWUgWyVzZXhwX29mOiBfIGxpc3RdIGluXG4gICAgbGV0IHJlYWQgZW52ID1cbiAgICAgIG1hdGNoIExpc3QucmV2IChFbnYuV2l0aF9kZWZhdWx0LmZpbmQgZW52IGtleSkgd2l0aFxuICAgICAgfCBbXSAtPiBQYXJzaW5nX291dGNvbWUucmV0dXJuX25vX2FyZyBbXVxuICAgICAgfCBfIDo6IF8gYXMgdmFsdWVfbGlzdCAtPiBQYXJzaW5nX291dGNvbWUucmV0dXJuX3dpdGhfYXJnIHZhbHVlX2xpc3RcbiAgICBpblxuICAgIGxldCB3cml0ZSBlbnYgYXJnID0gRW52LldpdGhfZGVmYXVsdC5jaGFuZ2UgZW52IGtleSB+ZjooZnVuIGxpc3QgLT4gYXJnIDo6IGxpc3QpIGluXG4gICAgYXJnX2ZsYWcgbmFtZSBhcmdfdHlwZSByZWFkIHdyaXRlIE51bV9vY2N1cnJlbmNlcy5hbnlcbiAgOztcblxuICBsZXQgb25lX29yX21vcmVfYXNfcGFpciBhcmdfdHlwZSBuYW1lID1cbiAgICBsZXQga2V5ID0gRW52LldpdGhfZGVmYXVsdC5LZXkuY3JlYXRlIH5kZWZhdWx0OltdIH5uYW1lIFslc2V4cF9vZjogXyBsaXN0XSBpblxuICAgIGxldCByZWFkIGVudiA9XG4gICAgICBtYXRjaCBMaXN0LnJldiAoRW52LldpdGhfZGVmYXVsdC5maW5kIGVudiBrZXkpIHdpdGhcbiAgICAgIHwgZmlyc3QgOjogcmVzdCAtPiBQYXJzaW5nX291dGNvbWUucmV0dXJuX3dpdGhfYXJnIChmaXJzdCwgcmVzdClcbiAgICAgIHwgW10gLT5cbiAgICAgICAgUGFyc2luZ19vdXRjb21lLmVycm9yXG4gICAgICAgICAgfmhhc19hcmc6ZmFsc2VcbiAgICAgICAgICAoYE1pc3NpbmdfcmVxdWlyZWRfZmxhZ3NcbiAgICAgICAgICAgIChFcnJvci5vZl9zdHJpbmcgKHNwcmludGYgXCJtaXNzaW5nIHJlcXVpcmVkIGZsYWc6ICVzXCIgbmFtZSkpKVxuICAgIGluXG4gICAgbGV0IHdyaXRlIGVudiBhcmcgPSBFbnYuV2l0aF9kZWZhdWx0LmNoYW5nZSBlbnYga2V5IH5mOihmdW4gcSAtPiBhcmcgOjogcSkgaW5cbiAgICBhcmdfZmxhZyBuYW1lIGFyZ190eXBlIHJlYWQgd3JpdGUgTnVtX29jY3VycmVuY2VzLmF0X2xlYXN0X29uY2VcbiAgOztcblxuICBsZXQgb25lX29yX21vcmVfYXNfbGlzdCBhcmdfdHlwZSA9XG4gICAgb25lX29yX21vcmVfYXNfcGFpciBhcmdfdHlwZSB8PiBtYXBfZmxhZyB+ZjooZnVuICh4LCB4cykgLT4geCA6OiB4cylcbiAgOztcblxuICBsZXQgZXNjYXBlX2dlbmVyYWwgfmNvbXBsZXRlIH5kZXByZWNhdGVkX2hvb2sgbmFtZSA9XG4gICAgbGV0IGtleSA9IEVudi5LZXkuY3JlYXRlIH5uYW1lIFslc2V4cF9vZjogc3RyaW5nIGxpc3RdIGluXG4gICAgbGV0IGFjdGlvbiBlbnYgY21kX2xpbmUgPSBFbnYuc2V0IGVudiB+a2V5IH5kYXRhOmNtZF9saW5lIGluXG4gICAgbGV0IHJlYWQgZW52ID1cbiAgICAgIG1hdGNoIEVudi5maW5kIGVudiBrZXkgd2l0aFxuICAgICAgfCBOb25lIC0+IFBhcnNpbmdfb3V0Y29tZS5yZXR1cm5fbm9fYXJnIE5vbmVcbiAgICAgIHwgU29tZSBfIGFzIHZhbHVlIC0+IFBhcnNpbmdfb3V0Y29tZS5yZXR1cm5fd2l0aF9hcmcgdmFsdWVcbiAgICBpblxuICAgIGxldCBhY3Rpb24gPVxuICAgICAgbWF0Y2ggZGVwcmVjYXRlZF9ob29rIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBhY3Rpb25cbiAgICAgIHwgU29tZSBmIC0+XG4gICAgICAgIGZ1biBlbnYgeCAtPlxuICAgICAgICAgIGYgeDtcbiAgICAgICAgICBhY3Rpb24gZW52IHhcbiAgICBpblxuICAgIHsgYWN0aW9uID0gUmVzdCAoYWN0aW9uLCBjb21wbGV0ZSlcbiAgICA7IHJlYWRcbiAgICA7IG51bV9vY2N1cnJlbmNlcyA9IE51bV9vY2N1cnJlbmNlcy5hdF9tb3N0X29uY2VcbiAgICA7IGV4dHJhX2RvYyA9IExhenkuZnJvbV92YWwgTm9uZVxuICAgIH1cbiAgOztcblxuICBsZXQgbm9fYXJnX2Fib3J0IH5leGl0IF9uYW1lID1cbiAgICB7IGFjdGlvbiA9IE5vX2FyZyAoZnVuIF8gLT4gTm90aGluZy51bnJlYWNoYWJsZV9jb2RlIChleGl0ICgpKSlcbiAgICA7IG51bV9vY2N1cnJlbmNlcyA9IE51bV9vY2N1cnJlbmNlcy5hdF9tb3N0X29uY2VcbiAgICA7IHJlYWQgPVxuICAgICAgICAoZnVuIF8gLT5cbiAgICAgICAgICAoKiBXZSBrbm93IHRoYXQgdGhlIGZsYWcgd2Fzbid0IHBhc3NlZCBoZXJlIGJlY2F1c2UgaWYgaXQgd2FzIHBhc3NlZFxuICAgICAgICAgICAgICB0aGVuIHRoZSBbYWN0aW9uXSB3b3VsZCBoYXZlIGNhbGxlZCBbZXhpdF0uICopXG4gICAgICAgICAgUGFyc2luZ19vdXRjb21lLnJldHVybl9ub19hcmcgKCkpXG4gICAgOyBleHRyYV9kb2MgPSBMYXp5LmZyb21fdmFsIE5vbmVcbiAgICB9XG4gIDs7XG5cbiAgbGV0IGVzY2FwZSBuYW1lID0gZXNjYXBlX2dlbmVyYWwgfmNvbXBsZXRlOk5vbmUgfmRlcHJlY2F0ZWRfaG9vazpOb25lIG5hbWVcblxuICBsZXQgZXNjYXBlX3dpdGhfYXV0b2NvbXBsZXRlIH5jb21wbGV0ZSBuYW1lID1cbiAgICBlc2NhcGVfZ2VuZXJhbCB+Y29tcGxldGU6KFNvbWUgY29tcGxldGUpIH5kZXByZWNhdGVkX2hvb2s6Tm9uZSBuYW1lXG4gIDs7XG5cbiAgbW9kdWxlIERlcHJlY2F0ZWQgPSBzdHJ1Y3RcbiAgICBsZXQgbm9fYXJnIH5ob29rIG5hbWUgPVxuICAgICAgbm9fYXJnX2dlbmVyYWwgfmlzX3JlcXVpcmVkOmZhbHNlIH5kZXByZWNhdGVkX2hvb2s6KFNvbWUgaG9vaykgfmtleV92YWx1ZTpOb25lIG5hbWVcbiAgICA7O1xuXG4gICAgbGV0IGVzY2FwZSB+aG9vayA9IGVzY2FwZV9nZW5lcmFsIH5jb21wbGV0ZTpOb25lIH5kZXByZWNhdGVkX2hvb2s6KFNvbWUgaG9vaylcbiAgZW5kXG5lbmRcblxubW9kdWxlIFBhdGggOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIGVtcHR5IDogdFxuICB2YWwgY3JlYXRlIDogcGF0aF90b19leGU6c3RyaW5nIC0+IHRcbiAgdmFsIG9mX3BhcnRzIDogc3RyaW5nIGxpc3QgLT4gdFxuICB2YWwgYXBwZW5kIDogdCAtPiBzdWJjb21tYW5kOnN0cmluZyAtPiB0XG4gIHZhbCByZXBsYWNlX2ZpcnN0IDogdCAtPiBmcm9tOnN0cmluZyAtPiB0b186c3RyaW5nIC0+IHRcbiAgdmFsIHBhcnRzIDogdCAtPiBzdHJpbmcgbGlzdFxuICB2YWwgcGFydHNfZXhlX2Jhc2VuYW1lIDogdCAtPiBzdHJpbmcgbGlzdFxuICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgdmFsIHRvX3N0cmluZ19kb3RzIDogdCAtPiBzdHJpbmdcbiAgdmFsIHBvcF9oZWxwIDogdCAtPiB0XG4gIHZhbCBsZW5ndGggOiB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiB0IC0+IGJvb2xcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBzdHJpbmcgbGlzdFxuXG4gIGxldCBlbXB0eSA9IFtdXG4gIGxldCBjcmVhdGUgfnBhdGhfdG9fZXhlID0gWyBwYXRoX3RvX2V4ZSBdXG4gIGxldCBvZl9wYXJ0cyBwYXJ0cyA9IExpc3QucmV2IHBhcnRzXG4gIGxldCBhcHBlbmQgdCB+c3ViY29tbWFuZCA9IHN1YmNvbW1hbmQgOjogdFxuICBsZXQgcGFydHMgPSBMaXN0LnJldlxuXG4gIGxldCBwYXJ0c19leGVfYmFzZW5hbWUgdCA9XG4gICAgbWF0Y2ggTGlzdC5yZXYgdCB3aXRoXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgaGQgOjogdGwgLT4gRmlsZW5hbWVfYmFzZS5iYXNlbmFtZSBoZCA6OiB0bFxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgdCA9IHVud29yZHMgKHBhcnRzX2V4ZV9iYXNlbmFtZSB0KVxuICBsZXQgbGVuZ3RoID0gTGlzdC5sZW5ndGhcblxuICBsZXQgcmVwbGFjZV9maXJzdCB0IH5mcm9tIH50b18gPVxuICAgIGxldCByZWMgYXV4IHBhcnRzIH5hY2MgfmZyb20gfnRvXyA9XG4gICAgICBtYXRjaCBwYXJ0cyB3aXRoXG4gICAgICB8IFtdIC0+IGFjY1xuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICBpZiBTdHJpbmcuKCA9ICkgaGQgZnJvbVxuICAgICAgICB0aGVuIExpc3QucmV2X2FwcGVuZCB0bCAodG9fIDo6IGFjYylcbiAgICAgICAgZWxzZSBhdXggdGwgfmFjYzooaGQgOjogYWNjKSB+ZnJvbSB+dG9fXG4gICAgaW5cbiAgICBhdXggKHBhcnRzIHQpIH5hY2M6W10gfmZyb20gfnRvX1xuICA7O1xuXG4gIGxldCBwb3BfaGVscCA9IGZ1bmN0aW9uXG4gICAgfCBcImhlbHBcIiA6OiB0IC0+IHRcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZ19kb3RzIHQgPVxuICAgIChtYXRjaCB0IHdpdGhcbiAgICAgfCBbXSAtPiBbXVxuICAgICB8IGxhc3QgOjogaW5pdCAtPiBsYXN0IDo6IExpc3QubWFwIGluaXQgfmY6KEZuLmNvbnN0IFwiLlwiKSlcbiAgICB8PiB0b19zdHJpbmdcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgPSBMaXN0LmlzX2VtcHR5XG5lbmRcblxubW9kdWxlIEFub25zID0gc3RydWN0XG4gIG1vZHVsZSBHcmFtbWFyIDogc2lnXG4gICAgdHlwZSB0ID0gU2hhcGUuQW5vbnMuR3JhbW1hci50XG5cbiAgICB2YWwgemVybyA6IHRcbiAgICB2YWwgb25lIDogc3RyaW5nIC0+IHRcbiAgICB2YWwgbWFueSA6IHQgLT4gdFxuICAgIHZhbCBtYXliZSA6IHQgLT4gdFxuICAgIHZhbCBtYXliZV9pZGVtcG90ZW50IDogdCAtPiB0XG4gICAgdmFsIGNvbmNhdCA6IHQgbGlzdCAtPiB0XG4gICAgdmFsIGFkX2hvYyA6IHVzYWdlOnN0cmluZyAtPiB0XG5cbiAgICBpbmNsdWRlIEludmFyaWFudC5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBuYW1lcyA6IHQgLT4gc3RyaW5nIGxpc3RcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSB0ID0gU2hhcGUuQW5vbnMuR3JhbW1hci50ID1cbiAgICAgIHwgWmVyb1xuICAgICAgfCBPbmUgb2Ygc3RyaW5nXG4gICAgICB8IE1hbnkgb2YgdFxuICAgICAgfCBNYXliZSBvZiB0XG4gICAgICB8IENvbmNhdCBvZiB0IGxpc3RcbiAgICAgIHwgQWRfaG9jIG9mIHN0cmluZ1xuXG4gICAgbGV0IGludmFyaWFudCA9IFNoYXBlLkFub25zLkdyYW1tYXIuaW52YXJpYW50XG4gICAgbGV0IHVzYWdlID0gU2hhcGUuQW5vbnMuR3JhbW1hci51c2FnZVxuXG4gICAgbGV0IHJlYyBpc19maXhlZF9hcml0eSA9IGZ1bmN0aW9uXG4gICAgICB8IFplcm8gLT4gdHJ1ZVxuICAgICAgfCBPbmUgXyAtPiB0cnVlXG4gICAgICB8IE1hbnkgXyAtPiBmYWxzZVxuICAgICAgfCBNYXliZSBfIC0+IGZhbHNlXG4gICAgICB8IEFkX2hvYyBfIC0+IGZhbHNlXG4gICAgICB8IENvbmNhdCB0cyAtPlxuICAgICAgICAobWF0Y2ggTGlzdC5yZXYgdHMgd2l0aFxuICAgICAgICAgfCBbXSAtPiBmYWlsd2l0aCBcImJ1ZyBpbiBjb21tYW5kLm1sXCJcbiAgICAgICAgIHwgbGFzdCA6OiBvdGhlcnMgLT5cbiAgICAgICAgICAgYXNzZXJ0IChMaXN0LmZvcl9hbGwgb3RoZXJzIH5mOmlzX2ZpeGVkX2FyaXR5KTtcbiAgICAgICAgICAgaXNfZml4ZWRfYXJpdHkgbGFzdClcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBuYW1lcyA9IGZ1bmN0aW9uXG4gICAgICB8IFplcm8gLT4gW11cbiAgICAgIHwgT25lIHMgLT4gWyBzIF1cbiAgICAgIHwgTWFueSB0IC0+IG5hbWVzIHRcbiAgICAgIHwgTWF5YmUgdCAtPiBuYW1lcyB0XG4gICAgICB8IEFkX2hvYyBzIC0+IFsgcyBdXG4gICAgICB8IENvbmNhdCB0cyAtPiBMaXN0LmNvbmNhdF9tYXAgdHMgfmY6bmFtZXNcbiAgICA7O1xuXG4gICAgbGV0IHplcm8gPSBaZXJvXG4gICAgbGV0IG9uZSBuYW1lID0gT25lIG5hbWVcblxuICAgIGxldCBtYW55ID0gZnVuY3Rpb25cbiAgICAgIHwgWmVybyAtPiBaZXJvICgqIHN0cmFuZ2UsIGJ1dCBub3Qgbm9uLXNlbnNlICopXG4gICAgICB8IHQgLT5cbiAgICAgICAgaWYgbm90IChpc19maXhlZF9hcml0eSB0KVxuICAgICAgICB0aGVuXG4gICAgICAgICAgZmFpbHdpdGhmXG4gICAgICAgICAgICBcIml0ZXJhdGlvbiBvZiB2YXJpYWJsZS1sZW5ndGggZ3JhbW1hcnMgc3VjaCBhcyAlcyBpcyBkaXNhbGxvd2VkXCJcbiAgICAgICAgICAgICh1c2FnZSB0KVxuICAgICAgICAgICAgKCk7XG4gICAgICAgIE1hbnkgdFxuICAgIDs7XG5cbiAgICBsZXQgbWF5YmUgPSBmdW5jdGlvblxuICAgICAgfCBaZXJvIC0+IFplcm8gKCogc3RyYW5nZSwgYnV0IG5vdCBub24tc2Vuc2UgKilcbiAgICAgIHwgdCAtPiBNYXliZSB0XG4gICAgOztcblxuICAgIGxldCBtYXliZV9pZGVtcG90ZW50ID0gZnVuY3Rpb25cbiAgICAgIHwgWmVybyAtPiBaZXJvICgqIHN0cmFuZ2UsIGJ1dCBub3Qgbm9uLXNlbnNlICopXG4gICAgICB8IE1heWJlIHQgLT4gTWF5YmUgdFxuICAgICAgfCBNYW55IHQgLT4gTWFueSB0XG4gICAgICB8IHQgLT4gTWF5YmUgdFxuICAgIDs7XG5cbiAgICBsZXQgY29uY2F0ID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gWmVyb1xuICAgICAgfCBjYXIgOjogY2RyIC0+XG4gICAgICAgIGxldCBjYXIsIGNkciA9XG4gICAgICAgICAgTGlzdC5mb2xkIGNkciB+aW5pdDooY2FyLCBbXSkgfmY6KGZ1biAodDEsIGFjYykgdDIgLT5cbiAgICAgICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgICAgICB8IFplcm8sIHQgfCB0LCBaZXJvIC0+IHQsIGFjY1xuICAgICAgICAgICAgfCBfLCBfIC0+XG4gICAgICAgICAgICAgIGlmIGlzX2ZpeGVkX2FyaXR5IHQxXG4gICAgICAgICAgICAgIHRoZW4gdDIsIHQxIDo6IGFjY1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZmFpbHdpdGhmXG4gICAgICAgICAgICAgICAgICBcInRoZSBncmFtbWFyICVzIGZvciBhbm9ueW1vdXMgYXJndW1lbnRzIGlzIG5vdCBzdXBwb3J0ZWQgYmVjYXVzZSB0aGVyZSBcXFxuICAgICAgICAgICAgICAgICAgIGlzIHRoZSBwb3NzaWJpbGl0eSBmb3IgYXJndW1lbnRzICglcykgZm9sbG93aW5nIGEgdmFyaWFibGUgbnVtYmVyIG9mIFxcXG4gICAgICAgICAgICAgICAgICAgYXJndW1lbnRzICglcykuICBTdXBwb3J0aW5nIHN1Y2ggZ3JhbW1hcnMgd291bGQgY29tcGxpY2F0ZSB0aGUgXFxcbiAgICAgICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiBzaWduaWZpY2FudGx5LlwiXG4gICAgICAgICAgICAgICAgICAodXNhZ2UgKENvbmNhdCAoTGlzdC5yZXYgKHQyIDo6IHQxIDo6IGFjYykpKSlcbiAgICAgICAgICAgICAgICAgICh1c2FnZSB0MilcbiAgICAgICAgICAgICAgICAgICh1c2FnZSB0MSlcbiAgICAgICAgICAgICAgICAgICgpKVxuICAgICAgICBpblxuICAgICAgICAobWF0Y2ggY2RyIHdpdGhcbiAgICAgICAgIHwgW10gLT4gY2FyXG4gICAgICAgICB8IF8gOjogXyAtPiBDb25jYXQgKExpc3QucmV2IChjYXIgOjogY2RyKSkpXG4gICAgOztcblxuICAgIGxldCBhZF9ob2MgfnVzYWdlID0gQWRfaG9jIHVzYWdlXG4gIGVuZFxuXG4gIG1vZHVsZSBQYXJzZXIgOiBzaWdcbiAgICBtb2R1bGUgQmFzaWMgOiBzaWdcbiAgICAgIHR5cGUgKydhIHRcblxuICAgICAgbW9kdWxlIEZvcl9vcGVuaW5nIDogc2lnXG4gICAgICAgIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG4gICAgICAgIHZhbCAoIDwqPiApIDogKCdhIC0+ICdiKSB0IC0+ICdhIHQgLT4gJ2IgdFxuICAgICAgICB2YWwgKCA+PnwgKSA6ICdhIHQgLT4gKCdhIC0+ICdiKSAtPiAnYiB0XG4gICAgICBlbmRcblxuICAgICAgdmFsIGZyb21fZW52IDogKEVudi50IC0+ICdhKSAtPiAnYSB0XG4gICAgZW5kXG5cbiAgICB0eXBlICsnYSB0ID0gJ2EgUGFyc2luZ19vdXRjb21lLnQgQmFzaWMudFxuXG4gICAgdmFsIG9uZSA6IG5hbWU6c3RyaW5nIC0+ICdhIEFyZ190eXBlLnQgLT4gJ2EgdFxuICAgIHZhbCBtYXliZSA6ICdhIHQgLT4gJ2Egb3B0aW9uIHRcbiAgICB2YWwgc2VxdWVuY2UgOiAnYSB0IC0+ICdhIGxpc3QgdFxuICAgIHZhbCBzdG9wX3BhcnNpbmcgOiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgZmluYWxfdmFsdWUgOiAnYSBCYXNpYy50IC0+IEVudi50IC0+ICdhXG5cbiAgICBtb2R1bGUgQ29uc3VtZV9yZXN1bHQgOiBzaWdcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPVxuICAgICAgICB7ICgqIElmIGVtYWNzIGhpZ2hsaWdodHMgW3BhcnNlcl0gYXMgaWYgaXQgd2VyZSBhIGtleXdvcmQsIHRoYXQncyBvbmx5IGJlY2F1c2VcbiAgICAgICAgICAgICBbcGFyc2VyXSB3YXMgYSBrZXl3b3JkIGluIGNhbWxwNC4gW3BhcnNlcl0gaXMgYSByZWd1bGFyIG5hbWUgaW4gT0NhbWwuICopXG4gICAgICAgICAgcGFyc2VyIDogJ2EgQmFzaWMudFxuICAgICAgICA7IHBhcnNlX2ZsYWdzIDogYm9vbFxuICAgICAgICA7IHVwZGF0ZV9lbnYgOiBFbnYudCAtPiBFbnYudFxuICAgICAgICB9XG4gICAgZW5kXG5cbiAgICB2YWwgY29uc3VtZSA6ICdhIEJhc2ljLnQgLT4gc3RyaW5nIC0+IGZvcl9jb21wbGV0aW9uOmJvb2wgLT4gJ2EgQ29uc3VtZV9yZXN1bHQudFxuICAgIHZhbCBjb21wbGV0ZSA6ICdhIEJhc2ljLnQgLT4gRW52LnQgLT4gcGFydDpzdHJpbmcgLT4gTm90aGluZy50XG5cbiAgICBtb2R1bGUgRm9yX29wZW5pbmcgOiBzaWdcbiAgICAgIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG4gICAgICB2YWwgKCA8Kj4gKSA6ICgnYSAtPiAnYikgdCAtPiAnYSB0IC0+ICdiIHRcbiAgICAgIHZhbCAoID4+fCApIDogJ2EgdCAtPiAoJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgICBlbmRcbiAgZW5kID0gc3RydWN0XG4gICAgbW9kdWxlIEJhc2ljID0gc3RydWN0XG4gICAgICB0eXBlICdhIHQgPVxuICAgICAgICB8IERvbmUgb2YgKEVudi50IC0+ICdhKVxuICAgICAgICB8IE1vcmUgb2YgJ2EgbW9yZVxuICAgICAgICAoKiBBIFtUZXN0XSB3aWxsIChnZW5lcmFsbHkpIHJldHVybiBhIFtEb25lIF9dIHZhbHVlIGlmIHRoZXJlIGlzIG5vIG1vcmUgaW5wdXQgYW5kXG4gICAgICAgICAgIGEgW01vcmVdIHBhcnNlciB0byB1c2UgaWYgdGhlcmUgaXMgYW55IG1vcmUgaW5wdXQuICopXG4gICAgICAgIHwgVGVzdCBvZiAobW9yZTpib29sIC0+ICdhIHQpXG4gICAgICAgICgqIElmIHdlJ3JlIG9ubHkgY29tcGxldGluZywgd2UgY2FuJ3QgcHVsbCB2YWx1ZXMgb3V0LCBidXQgd2UgY2FuIHN0aWxsIHN0ZXAgdGhyb3VnaFxuICAgICAgICAgICBbdF1zICh3aGljaCBtYXkgaGF2ZSBjb21wbGV0aW9uIHNldCB1cCkuICopXG4gICAgICAgIHwgT25seV9mb3JfY29tcGxldGlvbiBvZiBwYWNrZWQgbGlzdFxuICAgICAgICB8IFN0b3BfcGFyc2luZyBvZiAnYSB0XG5cbiAgICAgIGFuZCAnYSBtb3JlID1cbiAgICAgICAgeyBuYW1lIDogc3RyaW5nXG4gICAgICAgIDsgcGFyc2UgOiBzdHJpbmcgLT4gZm9yX2NvbXBsZXRpb246Ym9vbCAtPiAnYSBwYXJzZV9yZXN1bHRcbiAgICAgICAgOyBjb21wbGV0ZSA6IENvbXBsZXRlci50XG4gICAgICAgIH1cblxuICAgICAgYW5kIHBhY2tlZCA9IFBhY2tlZCA6ICdhIHQgLT4gcGFja2VkXG5cbiAgICAgIGFuZCAnYSBwYXJzZV9yZXN1bHQgPVxuICAgICAgICB7IHBhcnNlciA6ICdhIHRcbiAgICAgICAgOyB1cGRhdGVfZW52IDogRW52LnQgLT4gRW52LnRcbiAgICAgICAgfVxuXG4gICAgICBsZXQgcGFyc2VfbW9yZSB7IG5hbWU7IHBhcnNlOyBjb21wbGV0ZSB9IH5mID1cbiAgICAgICAgbGV0IHBhcnNlIGFyZyB+Zm9yX2NvbXBsZXRpb24gPVxuICAgICAgICAgIGxldCB7IHBhcnNlcjsgdXBkYXRlX2VudiB9ID0gcGFyc2UgYXJnIH5mb3JfY29tcGxldGlvbiBpblxuICAgICAgICAgIHsgcGFyc2VyID0gZiBwYXJzZXI7IHVwZGF0ZV9lbnYgfVxuICAgICAgICBpblxuICAgICAgICBNb3JlIHsgbmFtZTsgcGFyc2U7IGNvbXBsZXRlIH1cbiAgICAgIDs7XG5cbiAgICAgIGxldCBwYWNrX2Zvcl9jb21wbGV0aW9uID0gZnVuY3Rpb25cbiAgICAgICAgfCBEb25lIF8gLT4gW10gKCogd29uJ3QgY29tcGxldGUgb3IgY29uc3VtZSBhbnl0aGluZyAqKVxuICAgICAgICB8IChNb3JlIF8gfCBUZXN0IF8gfCBTdG9wX3BhcnNpbmcgXykgYXMgeCAtPiBbIFBhY2tlZCB4IF1cbiAgICAgICAgfCBPbmx5X2Zvcl9jb21wbGV0aW9uIHBzIC0+IHBzXG4gICAgICA7O1xuXG4gICAgICBsZXQgcmVjICggPCo+ICkgdF9sZWZ0IHRfcmlnaHQgPVxuICAgICAgICBtYXRjaCB0X2xlZnQsIHRfcmlnaHQgd2l0aFxuICAgICAgICAoKiBbRG9uZV0gKilcbiAgICAgICAgfCBEb25lIGYsIERvbmUgeCAtPlxuICAgICAgICAgIERvbmVcbiAgICAgICAgICAgIChmdW4gZW52IC0+XG4gICAgICAgICAgICAgIGxldCBmX291dGNvbWUgPSBmIGVudiBpblxuICAgICAgICAgICAgICBsZXQgeF9vdXRjb21lID0geCBlbnYgaW5cbiAgICAgICAgICAgICAgZl9vdXRjb21lIHhfb3V0Y29tZSlcbiAgICAgICAgKCogbmV4dCBzdGVwIFtNb3JlXSAqKVxuICAgICAgICB8IE1vcmUgbW9yZSwgXyAtPiBwYXJzZV9tb3JlIG1vcmUgfmY6KGZ1biB0bCAtPiB0bCA8Kj4gdF9yaWdodClcbiAgICAgICAgfCBEb25lIF8sIE1vcmUgbW9yZSAtPiBwYXJzZV9tb3JlIG1vcmUgfmY6KGZ1biB0ciAtPiB0X2xlZnQgPCo+IHRyKVxuICAgICAgICAoKiBuZXh0IHN0ZXAgW09ubHlfZm9yX2NvbXBsZXRpb25dICopXG4gICAgICAgIHwgT25seV9mb3JfY29tcGxldGlvbiBfLCBfIHwgRG9uZSBfLCBPbmx5X2Zvcl9jb21wbGV0aW9uIF8gLT5cbiAgICAgICAgICBPbmx5X2Zvcl9jb21wbGV0aW9uIChwYWNrX2Zvcl9jb21wbGV0aW9uIHRfbGVmdCBAIHBhY2tfZm9yX2NvbXBsZXRpb24gdF9yaWdodClcbiAgICAgICAgKCogbmV4dCBzdGVwIFtTdG9wX3BhcnNpbmddICopXG4gICAgICAgIHwgU3RvcF9wYXJzaW5nIHRsLCB0ciB8IChEb25lIF8gYXMgdGwpLCBTdG9wX3BhcnNpbmcgdHIgLT4gU3RvcF9wYXJzaW5nICh0bCA8Kj4gdHIpXG4gICAgICAgICgqIG5leHQgc3RlcCBbVGVzdF0gKilcbiAgICAgICAgfCBUZXN0IHRlc3QsIF8gLT4gVGVzdCAoZnVuIH5tb3JlIC0+IHRlc3Qgfm1vcmUgPCo+IHRfcmlnaHQpXG4gICAgICAgIHwgRG9uZSBfLCBUZXN0IHRlc3QgLT4gVGVzdCAoZnVuIH5tb3JlIC0+IHRfbGVmdCA8Kj4gdGVzdCB+bW9yZSlcbiAgICAgIDs7XG5cbiAgICAgIGxldCByZXR1cm4gYSA9IERvbmUgKGZ1biBfIC0+IGEpXG4gICAgICBsZXQgKCA+PnwgKSB0IGYgPSByZXR1cm4gZiA8Kj4gdFxuICAgICAgbGV0IGZyb21fZW52IGYgPSBEb25lIChmdW4gZW52IC0+IGYgZW52KVxuXG4gICAgICBtb2R1bGUgRm9yX29wZW5pbmcgPSBzdHJ1Y3RcbiAgICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgICBsZXQgKCA8Kj4gKSA9ICggPCo+IClcbiAgICAgICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIG9wZW4gQmFzaWNcblxuICAgIHR5cGUgJ2EgdCA9ICdhIFBhcnNpbmdfb3V0Y29tZS50IEJhc2ljLnRcblxuICAgIGxldCAoID4+fCApIHQgZiA9IHQgPj58IFBhcnNpbmdfb3V0Y29tZS5tYXAgfmZcbiAgICBsZXQgKCA8Kj4gKSB0X2xlZnQgdF9yaWdodCA9IHJldHVybiBQYXJzaW5nX291dGNvbWUuKCA8Kj4gKSA8Kj4gdF9sZWZ0IDwqPiB0X3JpZ2h0XG4gICAgbGV0IHJldHVybiBhID0gcmV0dXJuIChQYXJzaW5nX291dGNvbWUucmV0dXJuIGEpXG4gICAgbGV0IHJldHVybl93aXRoX2FyZyBhID0gRG9uZSAoZnVuIF8gLT4gUGFyc2luZ19vdXRjb21lLnJldHVybl93aXRoX2FyZyBhKVxuICAgIGxldCBzdG9wX3BhcnNpbmcgdCA9IFN0b3BfcGFyc2luZyB0XG5cbiAgICBsZXQgb25lX21vcmUgfm5hbWUgYXJnX3R5cGUgPVxuICAgICAgbGV0IHBhcnNlIGFub24gfmZvcl9jb21wbGV0aW9uID1cbiAgICAgICAgbWF0Y2ggQXJnX3R5cGUucGFyc2UgYXJnX3R5cGUgYW5vbiB3aXRoXG4gICAgICAgIHwgRXJyb3IgZXJyb3IgLT5cbiAgICAgICAgICBpZiBmb3JfY29tcGxldGlvblxuICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICgqIHdlIGRvbid0ICpyZWFsbHkqIGNhcmUgYWJvdXQgdGhpcyB2YWx1ZSwgc28ganVzdCBwdXQgaW4gYSBkdW1teSB2YWx1ZSBzb1xuICAgICAgICAgICAgICAgY29tcGxldGlvbiBjYW4gY29udGludWUgKilcbiAgICAgICAgICAgIHsgcGFyc2VyID0gT25seV9mb3JfY29tcGxldGlvbiBbXTsgdXBkYXRlX2VudiA9IEZuLmlkIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkaWUgXCJmYWlsZWQgdG8gcGFyc2UgJXMgdmFsdWUgJVNcXG4lc1wiIG5hbWUgYW5vbiAoRXJyb3IudG9fc3RyaW5nX2h1bSBlcnJvcikgKClcbiAgICAgICAgfCBPayB2IC0+XG4gICAgICAgICAgeyBwYXJzZXIgPSByZXR1cm5fd2l0aF9hcmcgdlxuICAgICAgICAgIDsgdXBkYXRlX2VudiA9XG4gICAgICAgICAgICAgIChmdW4gZW52IC0+XG4gICAgICAgICAgICAgICAgT3B0aW9uLmZvbGQgKEFyZ190eXBlLmtleSBhcmdfdHlwZSkgfmluaXQ6ZW52IH5mOihmdW4gZW52IGtleSAtPlxuICAgICAgICAgICAgICAgICAgRW52Lm11bHRpX2FkZCBlbnYgfmtleSB+ZGF0YTp2KSlcbiAgICAgICAgICB9XG4gICAgICBpblxuICAgICAgTW9yZSB7IG5hbWU7IHBhcnNlOyBjb21wbGV0ZSA9IEFyZ190eXBlLmNvbXBsZXRlIGFyZ190eXBlIH1cbiAgICA7O1xuXG4gICAgbGV0IG9uZSB+bmFtZSBhcmdfdHlwZSA9XG4gICAgICBUZXN0XG4gICAgICAgIChmdW4gfm1vcmUgLT5cbiAgICAgICAgICBpZiBtb3JlXG4gICAgICAgICAgdGhlbiBvbmVfbW9yZSB+bmFtZSBhcmdfdHlwZVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIERvbmVcbiAgICAgICAgICAgICAgKGZ1biBfIC0+XG4gICAgICAgICAgICAgICAgUGFyc2luZ19vdXRjb21lLmVycm9yXG4gICAgICAgICAgICAgICAgICB+aGFzX2FyZzpmYWxzZVxuICAgICAgICAgICAgICAgICAgKGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzXG4gICAgICAgICAgICAgICAgICAgIChFcnJvci5vZl9zdHJpbmcgKHNwcmludGYgXCJtaXNzaW5nIGFub255bW91cyBhcmd1bWVudDogJXNcIiBuYW1lKSkpKSlcbiAgICA7O1xuXG4gICAgbGV0IG1heWJlIHQgPVxuICAgICAgVGVzdFxuICAgICAgICAoZnVuIH5tb3JlIC0+XG4gICAgICAgICAgaWYgbW9yZSB0aGVuIHJldHVybl93aXRoX2FyZyAoZnVuIGEgLT4gU29tZSBhKSA8Kj4gdCBlbHNlIHJldHVybiBOb25lKVxuICAgIDs7XG5cbiAgICBsZXQgc2VxdWVuY2UgdCA9XG4gICAgICBsZXQgcmVjIGxvb3AgPVxuICAgICAgICBUZXN0XG4gICAgICAgICAgKGZ1biB+bW9yZSAtPlxuICAgICAgICAgICAgaWYgbW9yZSB0aGVuIHJldHVybiAoZnVuIHYgYWNjIC0+IHYgOjogYWNjKSA8Kj4gdCA8Kj4gbG9vcCBlbHNlIHJldHVybiBbXSlcbiAgICAgIGluXG4gICAgICBsb29wXG4gICAgOztcblxuICAgIGxldCByZWMgZmluYWxfdmFsdWUgdCBlbnYgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IERvbmUgYSAtPiBhIGVudlxuICAgICAgfCBTdG9wX3BhcnNpbmcgdCAtPiBmaW5hbF92YWx1ZSB0IGVudlxuICAgICAgfCBUZXN0IGYgLT4gZmluYWxfdmFsdWUgKGYgfm1vcmU6ZmFsc2UpIGVudlxuICAgICAgfCBNb3JlIF8gLT5cbiAgICAgICAgKCogdGhpcyBkb2Vzbid0IGhhcHBlbiBiZWNhdXNlIGFsbCBvY2N1cnJlbmNlcyBvZiBbTW9yZV0gYXJlIHByb3RlY3RlZFxuICAgICAgICAgICBieSBbVGVzdF0sIHdoaWNoIG1lYW5zIHRoZXJlIHdpbGwgYWx3YXlzIGJlIGFuIGV4dHJhIGFyZ3VtZW50IHRvIGdpdmVcbiAgICAgICAgICAgYmVmb3JlIHJlcXVlc3RpbmcgdGhlIGZpbmFsIHZhbHVlICopXG4gICAgICAgIGFzc2VydCBmYWxzZVxuICAgICAgfCBPbmx5X2Zvcl9jb21wbGV0aW9uIF8gLT5cbiAgICAgICAgZmFpbHdpdGggXCJCVUc6IGFza2VkIGZvciBmaW5hbCB2YWx1ZSB3aGVuIGRvaW5nIGNvbXBsZXRpb25cIlxuICAgIDs7XG5cbiAgICBtb2R1bGUgQ29uc3VtZV9yZXN1bHQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPVxuICAgICAgICB7IHBhcnNlciA6ICdhIEJhc2ljLnRcbiAgICAgICAgOyBwYXJzZV9mbGFncyA6IGJvb2xcbiAgICAgICAgOyB1cGRhdGVfZW52IDogRW52LnQgLT4gRW52LnRcbiAgICAgICAgfVxuICAgIGVuZFxuXG4gICAgbGV0IHJlYyBjb25zdW1lXG4gICAgICA6IHR5cGUgYS4gYSBCYXNpYy50IC0+IHN0cmluZyAtPiBmb3JfY29tcGxldGlvbjpib29sIC0+IGEgQ29uc3VtZV9yZXN1bHQudFxuICAgICAgPVxuICAgICAgZnVuIHQgYXJnIH5mb3JfY29tcGxldGlvbiAtPlxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IERvbmUgXyAtPiBkaWUgXCJ0b28gbWFueSBhbm9ueW1vdXMgYXJndW1lbnRzXCIgKClcbiAgICAgIHwgVGVzdCBmIC0+IGNvbnN1bWUgKGYgfm1vcmU6dHJ1ZSkgYXJnIH5mb3JfY29tcGxldGlvblxuICAgICAgfCBNb3JlIHsgcGFyc2U7IF8gfSAtPlxuICAgICAgICBsZXQgeyBwYXJzZXI7IHVwZGF0ZV9lbnYgfSA9IHBhcnNlIGFyZyB+Zm9yX2NvbXBsZXRpb24gaW5cbiAgICAgICAgeyBwYXJzZXI7IHBhcnNlX2ZsYWdzID0gdHJ1ZTsgdXBkYXRlX2VudiB9XG4gICAgICB8IFN0b3BfcGFyc2luZyB0IC0+IHsgKGNvbnN1bWUgdCBhcmcgfmZvcl9jb21wbGV0aW9uKSB3aXRoIHBhcnNlX2ZsYWdzID0gZmFsc2UgfVxuICAgICAgfCBPbmx5X2Zvcl9jb21wbGV0aW9uIHBhY2tlZCAtPlxuICAgICAgICAobWF0Y2ggcGFja2VkIHdpdGhcbiAgICAgICAgIHwgW10gLT5cbiAgICAgICAgICAgeyBwYXJzZXIgPSBPbmx5X2Zvcl9jb21wbGV0aW9uIFtdOyBwYXJzZV9mbGFncyA9IHRydWU7IHVwZGF0ZV9lbnYgPSBGbi5pZCB9XG4gICAgICAgICB8IFBhY2tlZCB0IDo6IHJlc3QgLT5cbiAgICAgICAgICAgbGV0ICh7IHVwZGF0ZV9lbnY7IHBhcnNlX2ZsYWdzOyBwYXJzZXIgfSA6IF8gQ29uc3VtZV9yZXN1bHQudCkgPVxuICAgICAgICAgICAgIGNvbnN1bWUgdCBhcmcgfmZvcl9jb21wbGV0aW9uXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIHsgdXBkYXRlX2VudlxuICAgICAgICAgICA7IHBhcnNlX2ZsYWdzXG4gICAgICAgICAgIDsgcGFyc2VyID0gT25seV9mb3JfY29tcGxldGlvbiAocGFja19mb3JfY29tcGxldGlvbiBwYXJzZXIgQCByZXN0KVxuICAgICAgICAgICB9KVxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGNvbXBsZXRlIDogdHlwZSBhLiBhIEJhc2ljLnQgLT4gRW52LnQgLT4gcGFydDpzdHJpbmcgLT4gTm90aGluZy50ID1cbiAgICAgIGZ1biB0IGVudiB+cGFydCAtPlxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IERvbmUgXyAtPiBleGl0IDBcbiAgICAgIHwgVGVzdCBmIC0+IGNvbXBsZXRlIChmIH5tb3JlOnRydWUpIGVudiB+cGFydFxuICAgICAgfCBNb3JlIHsgY29tcGxldGU7IF8gfSAtPiBDb21wbGV0ZXIucnVuX2FuZF9leGl0IGNvbXBsZXRlIGVudiB+cGFydFxuICAgICAgfCBTdG9wX3BhcnNpbmcgdCAtPiBjb21wbGV0ZSB0IGVudiB+cGFydFxuICAgICAgfCBPbmx5X2Zvcl9jb21wbGV0aW9uIHQgLT5cbiAgICAgICAgKG1hdGNoIHQgd2l0aFxuICAgICAgICAgfCBbXSAtPiBleGl0IDBcbiAgICAgICAgIHwgUGFja2VkIHQgOjogXyAtPiBjb21wbGV0ZSB0IGVudiB+cGFydClcbiAgICA7O1xuXG4gICAgbW9kdWxlIEZvcl9vcGVuaW5nID0gc3RydWN0XG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgKCA8Kj4gKSA9ICggPCo+IClcbiAgICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICAgIGVuZFxuICBlbmRcblxuICBvcGVuIFBhcnNlci5Gb3Jfb3BlbmluZ1xuXG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBwIDogJ2EgUGFyc2VyLnRcbiAgICA7IGdyYW1tYXIgOiBHcmFtbWFyLnRcbiAgICB9XG5cbiAgbGV0IHQyIHQxIHQyID1cbiAgICB7IHAgPSByZXR1cm4gKGZ1biBhMSBhMiAtPiBhMSwgYTIpIDwqPiB0MS5wIDwqPiB0Mi5wXG4gICAgOyBncmFtbWFyID0gR3JhbW1hci5jb25jYXQgWyB0MS5ncmFtbWFyOyB0Mi5ncmFtbWFyIF1cbiAgICB9XG4gIDs7XG5cbiAgbGV0IHQzIHQxIHQyIHQzID1cbiAgICB7IHAgPSByZXR1cm4gKGZ1biBhMSBhMiBhMyAtPiBhMSwgYTIsIGEzKSA8Kj4gdDEucCA8Kj4gdDIucCA8Kj4gdDMucFxuICAgIDsgZ3JhbW1hciA9IEdyYW1tYXIuY29uY2F0IFsgdDEuZ3JhbW1hcjsgdDIuZ3JhbW1hcjsgdDMuZ3JhbW1hciBdXG4gICAgfVxuICA7O1xuXG4gIGxldCB0NCB0MSB0MiB0MyB0NCA9XG4gICAgeyBwID0gcmV0dXJuIChmdW4gYTEgYTIgYTMgYTQgLT4gYTEsIGEyLCBhMywgYTQpIDwqPiB0MS5wIDwqPiB0Mi5wIDwqPiB0My5wIDwqPiB0NC5wXG4gICAgOyBncmFtbWFyID0gR3JhbW1hci5jb25jYXQgWyB0MS5ncmFtbWFyOyB0Mi5ncmFtbWFyOyB0My5ncmFtbWFyOyB0NC5ncmFtbWFyIF1cbiAgICB9XG4gIDs7XG5cbiAgbGV0IG5vcm1hbGl6ZSBzdHIgPVxuICAgICgqIFZlcmlmeSB0aGUgc3RyaW5nIGlzIG5vdCBlbXB0eSBvciBzdXJyb3VuZGVkIGJ5IHdoaXRlc3BhY2UgKilcbiAgICBsZXQgc3RybGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBpZiBzdHJsZW4gPSAwIHRoZW4gZmFpbHdpdGggXCJFbXB0eSBhbm9ueW1vdXMgYXJndW1lbnQgbmFtZSBwcm92aWRlZFwiO1xuICAgIGlmIFN0cmluZy4oIDw+ICkgKFN0cmluZy5zdHJpcCBzdHIpIHN0clxuICAgIHRoZW4gZmFpbHdpdGhmIFwiYXJndW1lbnQgbmFtZSAlUyBoYXMgc3Vycm91bmRpbmcgd2hpdGVzcGFjZVwiIHN0ciAoKTtcbiAgICAoKiBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIHNwZWNpYWwgc3Vycm91bmRpbmcgY2hhcmFjdGVycywgZG9uJ3QgZG8gYW55dGhpbmcgKilcbiAgICBsZXQgaGFzX3NwZWNpYWxfY2hhcnMgPVxuICAgICAgbGV0IHNwZWNpYWxfY2hhcnMgPVxuICAgICAgICBTZXQub2ZfbGlzdCAobW9kdWxlIENoYXIpIFsgJzwnOyAnPic7ICdbJzsgJ10nOyAnKCc7ICcpJzsgJ3snOyAnfScgXVxuICAgICAgaW5cbiAgICAgIFN0cmluZy5leGlzdHMgc3RyIH5mOihTZXQubWVtIHNwZWNpYWxfY2hhcnMpXG4gICAgaW5cbiAgICBpZiBoYXNfc3BlY2lhbF9jaGFycyB0aGVuIHN0ciBlbHNlIFN0cmluZy51cHBlcmNhc2Ugc3RyXG4gIDs7XG5cbiAgbGV0ICggJTogKSBuYW1lIGFyZ190eXBlID1cbiAgICBsZXQgbmFtZSA9IG5vcm1hbGl6ZSBuYW1lIGluXG4gICAgeyBwID0gUGFyc2VyLm9uZSB+bmFtZSBhcmdfdHlwZTsgZ3JhbW1hciA9IEdyYW1tYXIub25lIG5hbWUgfVxuICA7O1xuXG4gIGxldCBtYXBfYW5vbnMgdCB+ZiA9IHsgcCA9IHQucCA+PnwgZjsgZ3JhbW1hciA9IHQuZ3JhbW1hciB9XG4gIGxldCBtYXliZSB0ID0geyBwID0gUGFyc2VyLm1heWJlIHQucDsgZ3JhbW1hciA9IEdyYW1tYXIubWF5YmUgdC5ncmFtbWFyIH1cblxuICBsZXQgbWF5YmVfd2l0aF9kZWZhdWx0IGRlZmF1bHQgdCA9XG4gICAgbGV0IHQgPSBtYXliZSB0IGluXG4gICAgeyB0IHdpdGggcCA9ICh0LnAgPj58IGZ1biB2IC0+IE9wdGlvbi52YWx1ZSB+ZGVmYXVsdCB2KSB9XG4gIDs7XG5cbiAgbGV0IHNlcXVlbmNlIHQgPSB7IHAgPSBQYXJzZXIuc2VxdWVuY2UgdC5wOyBncmFtbWFyID0gR3JhbW1hci5tYW55IHQuZ3JhbW1hciB9XG4gIGxldCBub25fZW1wdHlfc2VxdWVuY2VfYXNfcGFpciB0ID0gdDIgdCAoc2VxdWVuY2UgdClcblxuICBsZXQgbm9uX2VtcHR5X3NlcXVlbmNlX2FzX2xpc3QgdCA9XG4gICAgbGV0IHQgPSBub25fZW1wdHlfc2VxdWVuY2VfYXNfcGFpciB0IGluXG4gICAgeyB0IHdpdGggcCA9ICh0LnAgPj58IGZ1biAoeCwgeHMpIC0+IHggOjogeHMpIH1cbiAgOztcblxuICBsZXQgZXNjYXBlIHQgPSB7IHAgPSBQYXJzZXIuc3RvcF9wYXJzaW5nIHQucDsgZ3JhbW1hciA9IHQuZ3JhbW1hciB9XG5cbiAgbW9kdWxlIERlcHJlY2F0ZWQgPSBzdHJ1Y3RcbiAgICBsZXQgYWRfaG9jIH51c2FnZV9hcmcgPVxuICAgICAgeyBwID1cbiAgICAgICAgICBQYXJzZXIuc2VxdWVuY2VcbiAgICAgICAgICAgIChQYXJzZXIub25lIH5uYW1lOlwiV0lMTCBORVZFUiBCRSBQUklOVEVEXCIgQXJnX3R5cGUuRXhwb3J0LnN0cmluZylcbiAgICAgIDsgZ3JhbW1hciA9IEdyYW1tYXIuYWRfaG9jIH51c2FnZTp1c2FnZV9hcmdcbiAgICAgIH1cbiAgICA7O1xuICBlbmRcbmVuZFxuXG5tb2R1bGUgQ21kbGluZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgTmlsXG4gICAgfCBDb25zIG9mIHN0cmluZyAqIHRcbiAgICB8IENvbXBsZXRlIG9mIHN0cmluZ1xuICBbQEBkZXJpdmluZyBjb21wYXJlXVxuXG4gIGxldCBvZl9saXN0IGFyZ3MgPSBMaXN0LmZvbGRfcmlnaHQgYXJncyB+aW5pdDpOaWwgfmY6KGZ1biBhcmcgYXJncyAtPiBDb25zIChhcmcsIGFyZ3MpKVxuXG4gIGxldCByZWMgdG9fbGlzdCA9IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gW11cbiAgICB8IENvbnMgKHgsIHhzKSAtPiB4IDo6IHRvX2xpc3QgeHNcbiAgICB8IENvbXBsZXRlIHggLT4gWyB4IF1cbiAgOztcblxuICBsZXQgcmVjIGVuZHNfaW5fY29tcGxldGUgPSBmdW5jdGlvblxuICAgIHwgQ29tcGxldGUgXyAtPiB0cnVlXG4gICAgfCBOaWwgLT4gZmFsc2VcbiAgICB8IENvbnMgKF8sIGFyZ3MpIC0+IGVuZHNfaW5fY29tcGxldGUgYXJnc1xuICA7O1xuXG4gIGxldCBleHRlbmQgdCB+ZXh0ZW5kIH5wYXRoID1cbiAgICBpZiBlbmRzX2luX2NvbXBsZXRlIHRcbiAgICB0aGVuIHRcbiAgICBlbHNlIChcbiAgICAgIGxldCBwYXRoX2xpc3QgPSBPcHRpb24udmFsdWUgfmRlZmF1bHQ6W10gKExpc3QudGwgKFBhdGgucGFydHMgcGF0aCkpIGluXG4gICAgICBvZl9saXN0ICh0b19saXN0IHQgQCBleHRlbmQgcGF0aF9saXN0KSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgS2V5X3R5cGUgPSBTaGFwZS5Qcml2YXRlLktleV90eXBlXG5cbmxldCBhc3NlcnRfbm9fdW5kZXJzY29yZXMga2V5X3R5cGUgZmxhZ19vcl9zdWJjb21tYW5kID1cbiAgaWYgU3RyaW5nLmV4aXN0cyBmbGFnX29yX3N1YmNvbW1hbmQgfmY6KGZ1biBjIC0+IENoYXIuKCA9ICkgYyAnXycpXG4gIHRoZW5cbiAgICBmYWlsd2l0aGZcbiAgICAgIFwiJXMgJXMgY29udGFpbnMgYW4gdW5kZXJzY29yZS4gVXNlIGEgZGFzaCBpbnN0ZWFkLlwiXG4gICAgICAoS2V5X3R5cGUudG9fc3RyaW5nIGtleV90eXBlKVxuICAgICAgZmxhZ19vcl9zdWJjb21tYW5kXG4gICAgICAoKVxuOztcblxubGV0IG5vcm1hbGl6ZSBrZXlfdHlwZSBrZXkgPVxuICBhc3NlcnRfbm9fdW5kZXJzY29yZXMga2V5X3R5cGUga2V5O1xuICBtYXRjaCBrZXlfdHlwZSB3aXRoXG4gIHwgS2V5X3R5cGUuRmxhZyAtPlxuICAgIGlmIFN0cmluZy5lcXVhbCBrZXkgXCItXCIgdGhlbiBmYWlsd2l0aGYgIVwiaW52YWxpZCAle0tleV90eXBlfSBuYW1lOiAlU1wiIGtleV90eXBlIGtleSAoKTtcbiAgICBpZiBTdHJpbmcuZXhpc3RzIGtleSB+ZjpDaGFyLmlzX3doaXRlc3BhY2VcbiAgICB0aGVuIGZhaWx3aXRoZiAhXCJpbnZhbGlkICV7S2V5X3R5cGV9IG5hbWUgKGNvbnRhaW5zIHdoaXRlc3BhY2UpOiAlU1wiIGtleV90eXBlIGtleSAoKTtcbiAgICBpZiBTdHJpbmcuaXNfcHJlZml4IH5wcmVmaXg6XCItXCIga2V5IHRoZW4ga2V5IGVsc2UgXCItXCIgXiBrZXlcbiAgfCBLZXlfdHlwZS5TdWJjb21tYW5kIC0+IFN0cmluZy5sb3dlcmNhc2Uga2V5XG47O1xuXG5sZXQgbG9va3VwX2V4cGFuZCA9IFNoYXBlLlByaXZhdGUubG9va3VwX2V4cGFuZFxuXG5sZXQgbG9va3VwX2V4cGFuZF93aXRoX2FsaWFzZXMgbWFwIHByZWZpeCBrZXlfdHlwZSA9XG4gIGxldCBhbGlzdCA9XG4gICAgTGlzdC5jb25jYXRfbWFwIChNYXAuZGF0YSBtYXApIH5mOihmdW4gZmxhZyAtPlxuICAgICAgbGV0IHsgRmxhZy5JbnRlcm5hbC5uYW1lXG4gICAgICAgICAgOyBhbGlhc2VzXG4gICAgICAgICAgOyBhbGlhc2VzX2V4Y2x1ZGVkX2Zyb21faGVscFxuICAgICAgICAgIDsgYWN0aW9uID0gX1xuICAgICAgICAgIDsgZG9jID0gX1xuICAgICAgICAgIDsgbnVtX29jY3VycmVuY2VzID0gX1xuICAgICAgICAgIDsgY2hlY2tfYXZhaWxhYmxlID0gX1xuICAgICAgICAgIDsgbmFtZV9tYXRjaGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgPVxuICAgICAgICBmbGFnXG4gICAgICBpblxuICAgICAgbGV0IGRhdGEgPSBmbGFnLCBuYW1lX21hdGNoaW5nIGluXG4gICAgICBsZXQgYWxpYXNlcyA9IGFsaWFzZXNfZXhjbHVkZWRfZnJvbV9oZWxwIEAgYWxpYXNlcyBpblxuICAgICAgKG5hbWUsIGRhdGEpIDo6IExpc3QubWFwIGFsaWFzZXMgfmY6KGZ1biBhbGlhcyAtPiBhbGlhcywgZGF0YSkpXG4gIGluXG4gIG1hdGNoIExpc3QuZmluZF9hX2R1cCBhbGlzdCB+Y29tcGFyZTooZnVuIChzMSwgXykgKHMyLCBfKSAtPiBTdHJpbmcuY29tcGFyZSBzMSBzMikgd2l0aFxuICB8IE5vbmUgLT4gbG9va3VwX2V4cGFuZCBhbGlzdCBwcmVmaXgga2V5X3R5cGVcbiAgfCBTb21lIChmbGFnLCBfKSAtPiBmYWlsd2l0aGYgXCJtdWx0aXBsZSBmbGFncyBuYW1lZCAlc1wiIGZsYWcgKClcbjs7XG5cbm1vZHVsZSBDb21tYW5kX2Jhc2UgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHN1bW1hcnkgOiBzdHJpbmdcbiAgICA7IHJlYWRtZSA6ICh1bml0IC0+IHN0cmluZykgb3B0aW9uXG4gICAgOyBmbGFncyA6IEZsYWcuSW50ZXJuYWwudCBNYXAuTShTdHJpbmcpLnRcbiAgICA7IGFub25zIDogdW5pdCAtPiAoWyBgUGFyc2VfYXJncyBdIC0+IFsgYFJ1bl9tYWluIF0gLT4gdW5pdCkgQW5vbnMuUGFyc2VyLkJhc2ljLnRcbiAgICA7IHVzYWdlIDogQW5vbnMuR3JhbW1hci50XG4gICAgfVxuXG4gIG1vZHVsZSBEZXByZWNhdGVkID0gc3RydWN0XG4gICAgbGV0IHN1YmNvbW1hbmRfY21wX2ZzdCAoYSwgXykgKGMsIF8pID0gaGVscF9zY3JlZW5fY29tcGFyZSBhIGNcblxuICAgIGxldCBmbGFnc19oZWxwID8oZGlzcGxheV9oZWxwX2ZsYWdzID0gdHJ1ZSkgdCA9XG4gICAgICBsZXQgZmxhZ3MgPSBNYXAuZGF0YSB0LmZsYWdzIGluXG4gICAgICBsZXQgZmxhZ3MgPVxuICAgICAgICBpZiBkaXNwbGF5X2hlbHBfZmxhZ3NcbiAgICAgICAgdGhlbiBmbGFnc1xuICAgICAgICBlbHNlIExpc3QuZmlsdGVyIGZsYWdzIH5mOihmdW4gZiAtPiBTdHJpbmcuKCA8PiApIGYubmFtZSBcIi1oZWxwXCIpXG4gICAgICBpblxuICAgICAgTGlzdC5jb25jYXRfbWFwIH5mOkZsYWcuSW50ZXJuYWwuRGVwcmVjYXRlZC5oZWxwIGZsYWdzXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IGZvcm1hdHRlZF9mbGFncyB0ID1cbiAgICBNYXAuZGF0YSB0LmZsYWdzXG4gICAgfD4gTGlzdC5tYXAgfmY6RmxhZy5JbnRlcm5hbC5hbGlnblxuICAgICgqIHRoaXMgc29ydCBwdXRzIG9wdGlvbmFsIGZsYWdzIGFmdGVyIHJlcXVpcmVkIG9uZXMgKilcbiAgICB8PiBMaXN0LnNvcnQgfmNvbXBhcmU6KGZ1biBhIGIgLT4gU3RyaW5nLmNvbXBhcmUgYS5uYW1lIGIubmFtZSlcbiAgICB8PiBTaGFwZS5GbGFnX2hlbHBfZGlzcGxheS5zb3J0XG4gIDs7XG5cbiAgbGV0IHNoYXBlIHQgOiBTaGFwZS5CYXNlX2luZm8udCA9XG4gICAgeyBzdW1tYXJ5ID0gdC5zdW1tYXJ5XG4gICAgOyByZWFkbWUgPSBPcHRpb24ubWFwIHQucmVhZG1lIH5mOihmdW4gcmVhZG1lIC0+IHJlYWRtZSAoKSlcbiAgICA7IGFub25zID0gR3JhbW1hciB0LnVzYWdlXG4gICAgOyBmbGFncyA9IGZvcm1hdHRlZF9mbGFncyB0XG4gICAgfVxuICA7O1xuXG4gIGxldCBwYXRoX2tleSA9IEVudi5rZXlfY3JlYXRlIFwicGF0aFwiXG4gIGxldCBhcmdzX2tleSA9IEVudi5rZXlfY3JlYXRlIFwiYXJnc1wiXG4gIGxldCBoZWxwX2tleSA9IEVudi5rZXlfY3JlYXRlIFwiaGVscFwiXG4gIGxldCBub3JtYWxpemVkX3BhdGggPSByZWYgTm9uZVxuICBsZXQgbm9ybWFsaXplZF9hcmdzID0gcmVmIE5vbmVcblxuICBsZXQgaW5kZW50X2J5XzIgc3RyID1cbiAgICBTdHJpbmcuc3BsaXQgfm9uOidcXG4nIHN0clxuICAgIHw+IExpc3QubWFwIH5mOihmdW4gbGluZSAtPiBcIiAgXCIgXiBsaW5lKVxuICAgIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIlxcblwiXG4gIDs7XG5cbiAgbGV0IGdldF9mbGFnX2FuZF9hY3Rpb24gdCBhcmcgPVxuICAgIG1hdGNoIGxvb2t1cF9leHBhbmRfd2l0aF9hbGlhc2VzIHQuZmxhZ3MgYXJnIEZsYWcgd2l0aFxuICAgIHwgRXJyb3IgbXNnIC0+IGRpZSBcIiVzXCIgbXNnICgpXG4gICAgfCBPayAoZmxhZ19uYW1lLCBmbGFnKSAtPiBmbGFnX25hbWUsIGZsYWcuYWN0aW9uXG4gIDs7XG5cbiAgbGV0IGdldF9jb21wbGV0ZV9mbGFnX25hbWUgdCBhcmcgKGFyZ3MgOiBDbWRsaW5lLnQpID1cbiAgICBsZXQgZmxhZywgYWN0aW9uID0gZ2V0X2ZsYWdfYW5kX2FjdGlvbiB0IGFyZyBpblxuICAgIG1hdGNoIGFjdGlvbiB3aXRoXG4gICAgfCBQcmludF9pbmZvX2FuZF9xdWl0IF9pbmZvIC0+IFsgZmxhZyBdXG4gICAgfCBOb19hcmcgX2YgLT4gWyBmbGFnIF1cbiAgICB8IEFyZyAoX2YsIF9jb21wKSAtPlxuICAgICAgKG1hdGNoIGFyZ3Mgd2l0aFxuICAgICAgIHwgQ29ucyAoYXJnLCBfcmVzdCkgLT4gWyBmbGFnOyBhcmcgXVxuICAgICAgIHwgTmlsIHwgQ29tcGxldGUgXyAtPiBbXSlcbiAgICB8IFJlc3QgKF9mLCBfY29tcCkgLT4gZmxhZyA6OiBDbWRsaW5lLnRvX2xpc3QgYXJnc1xuICA7O1xuXG4gIGxldCBydW5fZmxhZyB0IGVudiBhcmcgKGFyZ3MgOiBDbWRsaW5lLnQpID1cbiAgICBsZXQgZmxhZywgYWN0aW9uID0gZ2V0X2ZsYWdfYW5kX2FjdGlvbiB0IGFyZyBpblxuICAgIG1hdGNoIGFjdGlvbiB3aXRoXG4gICAgfCBQcmludF9pbmZvX2FuZF9xdWl0IGluZm8gLT5cbiAgICAgIGxldCBjb21wbGV0aW5nID0gQ21kbGluZS5lbmRzX2luX2NvbXBsZXRlIGFyZ3MgaW5cbiAgICAgICgqIElmIHdlJ3JlIGRvaW5nIGNvbXBsZXRpb24sIHZlcnNpb24vaGVscCBpbmZvIGFyZW4ndCB1c2VmdWwgY29tcGxldGlvblxuICAgICAgICAgcmVzcG9uc2VzLiAqKVxuICAgICAgaWYgY29tcGxldGluZ1xuICAgICAgdGhlbiBlbnYsIGFyZ3NcbiAgICAgIGVsc2UgKFxuICAgICAgICBwcmludF9lbmRsaW5lIChpbmZvIGVudik7XG4gICAgICAgIGV4aXQgMClcbiAgICB8IE5vX2FyZyBmIC0+IGYgZW52LCBhcmdzXG4gICAgfCBBcmcgKGYsIGNvbXApIC0+XG4gICAgICAobWF0Y2ggYXJncyB3aXRoXG4gICAgICAgfCBOaWwgLT4gZGllIFwibWlzc2luZyBhcmd1bWVudCBmb3IgZmxhZyAlc1wiIGZsYWcgKClcbiAgICAgICB8IENvbnMgKGFyZywgcmVzdCkgLT5cbiAgICAgICAgIGxldCBlbnYgPVxuICAgICAgICAgICB0cnkgZiBlbnYgYXJnIHdpdGhcbiAgICAgICAgICAgfCBGYWlsZWRfdG9fcGFyc2VfY29tbWFuZF9saW5lIF8gYXMgZSAtPlxuICAgICAgICAgICAgIGlmIENtZGxpbmUuZW5kc19pbl9jb21wbGV0ZSByZXN0IHRoZW4gZW52IGVsc2UgcmFpc2UgZVxuICAgICAgICAgaW5cbiAgICAgICAgIGVudiwgcmVzdFxuICAgICAgIHwgQ29tcGxldGUgcGFydCAtPiBOb3RoaW5nLnVucmVhY2hhYmxlX2NvZGUgKENvbXBsZXRlci5ydW5fYW5kX2V4aXQgY29tcCBlbnYgfnBhcnQpKVxuICAgIHwgUmVzdCAoZiwgY29tcCkgLT5cbiAgICAgIGxldCBhcmdfbGlzdCA9IENtZGxpbmUudG9fbGlzdCBhcmdzIGluXG4gICAgICBpZiBDbWRsaW5lLmVuZHNfaW5fY29tcGxldGUgYXJnc1xuICAgICAgdGhlbiBOb3RoaW5nLnVucmVhY2hhYmxlX2NvZGUgKENvbXBsZXRlci5ydW5fYW5kX2V4aXQgY29tcCBlbnYgfnBhcnQ6YXJnX2xpc3QpO1xuICAgICAgZiBlbnYgYXJnX2xpc3QsIE5pbFxuICA7O1xuXG4gIGxldCByZWMgcnVuX2NtZGxpbmVcbiAgICB0XG4gICAgZW52XG4gICAgcGFyc2VyXG4gICAgKGNtZGxpbmUgOiBDbWRsaW5lLnQpXG4gICAgfmZvcl9jb21wbGV0aW9uXG4gICAgfnBhcnNlX2ZsYWdzXG4gICAgfm5vcm1hbGl6ZWRfYXJnc1xuICAgID1cbiAgICBtYXRjaCBjbWRsaW5lIHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgTGlzdC5pdGVyIChNYXAuZGF0YSB0LmZsYWdzKSB+ZjooZnVuIGZsYWcgLT4gZmxhZy5jaGVja19hdmFpbGFibGUgZW52KTtcbiAgICAgICggYE9ubHlfdmFsaWRhdGVfcGFyc2luZyAoRW52Lm1lbSBlbnYga2V5X2ludGVybmFsX3ZhbGlkYXRlX3BhcnNpbmcpXG4gICAgICAsIEFub25zLlBhcnNlci5maW5hbF92YWx1ZSBwYXJzZXIgZW52XG4gICAgICAsIExpc3QuY29uY2F0IChMaXN0LnJldiBub3JtYWxpemVkX2FyZ3MpIClcbiAgICB8IENvbXBsZXRlIHBhcnQgLT5cbiAgICAgIGlmIHBhcnNlX2ZsYWdzICYmIFN0cmluZy5pc19wcmVmaXggcGFydCB+cHJlZml4OlwiLVwiXG4gICAgICB0aGVuIChcbiAgICAgICAgTGlzdC5pdGVyIChNYXAua2V5cyB0LmZsYWdzKSB+ZjooZnVuIG5hbWUgLT5cbiAgICAgICAgICBpZiBTdHJpbmcuaXNfcHJlZml4IG5hbWUgfnByZWZpeDpwYXJ0IHRoZW4gcHJpbnRfZW5kbGluZSBuYW1lKTtcbiAgICAgICAgZXhpdCAwKVxuICAgICAgZWxzZSBOb3RoaW5nLnVucmVhY2hhYmxlX2NvZGUgKEFub25zLlBhcnNlci5jb21wbGV0ZSBwYXJzZXIgZW52IH5wYXJ0KVxuICAgIHwgQ29ucyAoYXJnLCBhcmdzKSAtPlxuICAgICAgbGV0IGFyZywgYXJncywgYXJnX2lzX2ZsYWcgPVxuICAgICAgICBtYXRjaCBwYXJzZV9mbGFncyB3aXRoXG4gICAgICAgIHwgZmFsc2UgLT4gYXJnLCBhcmdzLCBmYWxzZVxuICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICAobWF0Y2ggYXJnLCBhcmdzIHdpdGhcbiAgICAgICAgICAgKCogdGhlICctYW5vbicgZmxhZyBpcyBoZXJlIGFzIGFuIGVzY2FwZSBoYXRjaCBpbiBjYXNlIHlvdSBoYXZlIGFuXG4gICAgICAgICAgICAgIGFub255bW91cyBhcmd1bWVudCB0aGF0IHN0YXJ0cyB3aXRoIGEgaHlwaGVuLiAqKVxuICAgICAgICAgICB8IFwiLWFub25cIiwgQ29ucyAoYXJnLCBhcmdzKSAtPiBhcmcsIGFyZ3MsIGZhbHNlXG4gICAgICAgICAgICgqIHN1cHBvcnQgdGhlIGNvbW1vbiBVbml4IGNvbnZlbnRpb24gd2hlcmUgXCItXCIgbWVhbnMgc3RkaW4gKilcbiAgICAgICAgICAgfCBcIi1cIiwgXyAtPiBhcmcsIGFyZ3MsIGZhbHNlXG4gICAgICAgICAgIHwgXywgXyAtPiBhcmcsIGFyZ3MsIFN0cmluZy5pc19wcmVmaXggYXJnIH5wcmVmaXg6XCItXCIpXG4gICAgICBpblxuICAgICAgKG1hdGNoIGFyZ19pc19mbGFnIHdpdGhcbiAgICAgICB8IHRydWUgLT5cbiAgICAgICAgIGxldCBub3JtYWxpemVkX2FyZ3MgPSBnZXRfY29tcGxldGVfZmxhZ19uYW1lIHQgYXJnIGFyZ3MgOjogbm9ybWFsaXplZF9hcmdzIGluXG4gICAgICAgICBsZXQgZW52LCBhcmdzID0gcnVuX2ZsYWcgdCBlbnYgYXJnIGFyZ3MgaW5cbiAgICAgICAgIHJ1bl9jbWRsaW5lIH5ub3JtYWxpemVkX2FyZ3MgdCBlbnYgcGFyc2VyIGFyZ3MgfnBhcnNlX2ZsYWdzIH5mb3JfY29tcGxldGlvblxuICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgIGxldCBwYXJzZV9mbGFnczEgPSBwYXJzZV9mbGFncyBpblxuICAgICAgICAgbGV0ICh7IHBhcnNlcjsgcGFyc2VfZmxhZ3MgPSBwYXJzZV9mbGFnczI7IHVwZGF0ZV9lbnYgfVxuICAgICAgICAgICAgICAgOiBfIEFub25zLlBhcnNlci5Db25zdW1lX3Jlc3VsdC50KVxuICAgICAgICAgICA9XG4gICAgICAgICAgIEFub25zLlBhcnNlci5jb25zdW1lIHBhcnNlciBhcmcgfmZvcl9jb21wbGV0aW9uXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IGVudiA9IHVwZGF0ZV9lbnYgZW52IGluXG4gICAgICAgICBsZXQgcGFyc2VfZmxhZ3MgPSBwYXJzZV9mbGFnczEgJiYgcGFyc2VfZmxhZ3MyIGluXG4gICAgICAgICBydW5fY21kbGluZVxuICAgICAgICAgICB+bm9ybWFsaXplZF9hcmdzOihbIGFyZyBdIDo6IG5vcm1hbGl6ZWRfYXJncylcbiAgICAgICAgICAgdFxuICAgICAgICAgICBlbnZcbiAgICAgICAgICAgcGFyc2VyXG4gICAgICAgICAgIH5wYXJzZV9mbGFnc1xuICAgICAgICAgICBhcmdzXG4gICAgICAgICAgIH5mb3JfY29tcGxldGlvbilcbiAgOztcblxuICBsZXQgcnVuX2V4biBleG4gfmZvcl9jb21wbGV0aW9uIH5wYXRoIH52ZXJib3NlX29uX3BhcnNlX2Vycm9yID1cbiAgICBtYXRjaCBleG4gd2l0aFxuICAgIHwgRmFpbGVkX3RvX3BhcnNlX2NvbW1hbmRfbGluZSBfIHdoZW4gZm9yX2NvbXBsZXRpb24gLT4gZXhpdCAwXG4gICAgfCBFeGl0X2NhbGxlZCB7IHN0YXR1cyB9IC0+IGV4aXQgc3RhdHVzXG4gICAgfCBfIC0+XG4gICAgICBsZXQgZXhuX3N0ciA9XG4gICAgICAgIG1hdGNoIGV4biB3aXRoXG4gICAgICAgIHwgRmFpbGVkX3RvX3BhcnNlX2NvbW1hbmRfbGluZSBtc2cgLT4gbXNnXG4gICAgICAgIHwgXyAtPiBTZXhwLnRvX3N0cmluZ19odW0gWyVzZXhwIChleG4gOiBleG4pXVxuICAgICAgaW5cbiAgICAgIGxldCB2ZXJib3NlID0gT3B0aW9uLnZhbHVlIHZlcmJvc2Vfb25fcGFyc2VfZXJyb3IgfmRlZmF1bHQ6dHJ1ZSBpblxuICAgICAgbGV0IGVycm9yX21zZyA9XG4gICAgICAgIGlmIHZlcmJvc2VcbiAgICAgICAgdGhlblxuICAgICAgICAgIFN0cmluZy5jb25jYXRcbiAgICAgICAgICAgIH5zZXA6XCJcXG5cXG5cIlxuICAgICAgICAgICAgWyBcIkVycm9yIHBhcnNpbmcgY29tbWFuZCBsaW5lOlwiXG4gICAgICAgICAgICA7IGluZGVudF9ieV8yIGV4bl9zdHJcbiAgICAgICAgICAgIDsgXCJGb3IgdXNhZ2UgaW5mb3JtYXRpb24sIHJ1blwiXG4gICAgICAgICAgICA7IFwiICBcIiBeIFBhdGgudG9fc3RyaW5nIHBhdGggXiBcIiAtaGVscFxcblwiXG4gICAgICAgICAgICBdXG4gICAgICAgIGVsc2UgZXhuX3N0clxuICAgICAgaW5cbiAgICAgIHByZXJyX2VuZGxpbmUgZXJyb3JfbXNnO1xuICAgICAgZXhpdCAxXG4gIDs7XG5cbiAgbGV0IHJ1blxuICAgIHRcbiAgICBlbnZcbiAgICB+d2hlbl9wYXJzaW5nX3N1Y2NlZWRzXG4gICAgfnBhdGhcbiAgICB+YXJnc1xuICAgIH52ZXJib3NlX29uX3BhcnNlX2Vycm9yXG4gICAgfmhlbHBfdGV4dFxuICAgIH5vbl9mYWlsdXJlXG4gICAgPVxuICAgIGxldCBmb3JfY29tcGxldGlvbiA9IENtZGxpbmUuZW5kc19pbl9jb21wbGV0ZSBhcmdzIGluXG4gICAgbGV0IGVudiA9XG4gICAgICBlbnZcbiAgICAgIHw+IEVudi5zZXQgfmtleTpwYXRoX2tleSB+ZGF0YTpwYXRoXG4gICAgICB8PiBFbnYuc2V0IH5rZXk6YXJnc19rZXkgfmRhdGE6KENtZGxpbmUudG9fbGlzdCBhcmdzKVxuICAgICAgfD4gRW52LnNldCB+a2V5OmhlbHBfa2V5IH5kYXRhOmhlbHBfdGV4dFxuICAgIGluXG4gICAgbWF0Y2hcbiAgICAgIFJlc3VsdC50cnlfd2l0aCAoZnVuICgpIC0+XG4gICAgICAgIGxldCBpc191c2luZ192YWxpZGF0ZV9wYXJzaW5nLCBtYWluLCBwYXJzZWRfbm9ybWFsaXplZF9hcmdzID1cbiAgICAgICAgICBydW5fY21kbGluZVxuICAgICAgICAgICAgdFxuICAgICAgICAgICAgZW52XG4gICAgICAgICAgICAodC5hbm9ucyAoKSlcbiAgICAgICAgICAgIH5mb3JfY29tcGxldGlvblxuICAgICAgICAgICAgfnBhcnNlX2ZsYWdzOnRydWVcbiAgICAgICAgICAgIH5ub3JtYWxpemVkX2FyZ3M6W11cbiAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgaW5cbiAgICAgICAgbm9ybWFsaXplZF9wYXRoIDo9IFNvbWUgcGF0aDtcbiAgICAgICAgbm9ybWFsaXplZF9hcmdzIDo9IFNvbWUgcGFyc2VkX25vcm1hbGl6ZWRfYXJncztcbiAgICAgICAgaXNfdXNpbmdfdmFsaWRhdGVfcGFyc2luZywgbWFpbiBgUGFyc2VfYXJncylcbiAgICB3aXRoXG4gICAgfCBPayAoYE9ubHlfdmFsaWRhdGVfcGFyc2luZyB0cnVlLCAoX3RodW5rIDogXykpIC0+XG4gICAgICB3aGVuX3BhcnNpbmdfc3VjY2VlZHMgKCk7XG4gICAgICBleGl0IDBcbiAgICB8IE9rIChgT25seV92YWxpZGF0ZV9wYXJzaW5nIGZhbHNlLCB0aHVuaykgLT5cbiAgICAgIHdoZW5fcGFyc2luZ19zdWNjZWVkcyAoKTtcbiAgICAgIHRodW5rIGBSdW5fbWFpblxuICAgIHwgRXJyb3IgZXhuIC0+IG9uX2ZhaWx1cmUgZXhuIH5mb3JfY29tcGxldGlvbiB+cGF0aCB+dmVyYm9zZV9vbl9wYXJzZV9lcnJvclxuICA7O1xuXG4gIG1vZHVsZSBQYXJhbSA9IHN0cnVjdFxuICAgIHR5cGUgKydhIHQgPVxuICAgICAgeyBmIDogdW5pdCAtPiAodW5pdCAtPiAnYSBQYXJzaW5nX291dGNvbWUudCkgQW5vbnMuUGFyc2VyLkJhc2ljLnRcbiAgICAgIDsgdXNhZ2UgOiB1bml0IC0+IEFub25zLkdyYW1tYXIudFxuICAgICAgOyBmbGFncyA6IHVuaXQgLT4gRmxhZy5JbnRlcm5hbC50IGxpc3RcbiAgICAgIH1cblxuICAgIG9wZW4gQW5vbnMuUGFyc2VyLkJhc2ljLkZvcl9vcGVuaW5nXG5cbiAgICBsZXQgd3JhcF92YWx1ZSB2ICgpID0gUGFyc2luZ19vdXRjb21lLnJldHVybl9ub19hcmcgdlxuXG4gICAgbGV0IGFwcGx5IGYgeCA9XG4gICAgICB7IGYgPVxuICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgIHJldHVybiAoZnVuIGYgeCAoKSAtPlxuICAgICAgICAgICAgICAoKiBvcmRlciBvZiBldmFsdWF0aW9uIGhlcmUgYWZmZWN0cyBpbiB3aGF0IG9yZGVyIHRoZSB1c2VycycgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICBhcmUgZXZhbHVhdGVkLCBzbyBpdCdzIGltcG9ydGFudCB0byBjYWxsIFtmXSBiZWZvcmUgW3hdICopXG4gICAgICAgICAgICAgIGxldCBmX291dGNvbWUgPSBmICgpIGluXG4gICAgICAgICAgICAgIGxldCB4X291dGNvbWUgPSB4ICgpIGluXG4gICAgICAgICAgICAgIFBhcnNpbmdfb3V0Y29tZS5hcHBseSBmX291dGNvbWUgeF9vdXRjb21lKVxuICAgICAgICAgICAgPCo+IGYuZiAoKVxuICAgICAgICAgICAgPCo+IHguZiAoKSlcbiAgICAgIDsgZmxhZ3MgPSAoZnVuICgpIC0+IHguZmxhZ3MgKCkgQCBmLmZsYWdzICgpKVxuICAgICAgOyB1c2FnZSA9IChmdW4gKCkgLT4gQW5vbnMuR3JhbW1hci5jb25jYXQgWyBmLnVzYWdlICgpOyB4LnVzYWdlICgpIF0pXG4gICAgICB9XG4gICAgOztcblxuICAgIGxldCBlbXB0eV9zcGVjIDogJ20uICgnbSAtPiAnbSkgdCA9XG4gICAgICB7IGYgPSAoZnVuICgpIC0+IHJldHVybiAoZnVuICgpIC0+IFBhcnNpbmdfb3V0Y29tZS5yZXR1cm5fbm9fYXJnIEZuLmlkKSlcbiAgICAgIDsgZmxhZ3MgPSAoZnVuICgpIC0+IFtdKVxuICAgICAgOyB1c2FnZSA9IChmdW4gKCkgLT4gQW5vbnMuR3JhbW1hci56ZXJvKVxuICAgICAgfVxuICAgIDs7XG5cbiAgICBsZXQgbWFwX291dGNvbWUgeCB+ZiA9XG4gICAgICB7IGYgPVxuICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgIHguZiAoKVxuICAgICAgICAgICAgPj58IGZ1biB4ICgpIC0+XG4gICAgICAgICAgICBsZXQgeF9vdXRjb21lID0geCAoKSBpblxuICAgICAgICAgICAgZiB4X291dGNvbWUpXG4gICAgICA7IGZsYWdzID0geC5mbGFnc1xuICAgICAgOyB1c2FnZSA9IHgudXNhZ2VcbiAgICAgIH1cbiAgICA7O1xuXG4gICAgbGV0IG1hcCB4IH5mID0gbWFwX291dGNvbWUgeCB+ZjooUGFyc2luZ19vdXRjb21lLm1hcCB+ZilcblxuICAgIGxldCBsb29rdXAga2V5ID1cbiAgICAgIHsgZiA9XG4gICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgQW5vbnMuUGFyc2VyLkJhc2ljLmZyb21fZW52IChmdW4gZW52IC0+IEVudi5maW5kX2V4biBlbnYga2V5KSA+Pnwgd3JhcF92YWx1ZSlcbiAgICAgIDsgZmxhZ3MgPSAoZnVuICgpIC0+IFtdKVxuICAgICAgOyB1c2FnZSA9IChmdW4gKCkgLT4gQW5vbnMuR3JhbW1hci56ZXJvKVxuICAgICAgfVxuICAgIDs7XG5cbiAgICBsZXQgcGF0aCA6IFBhdGgudCB0ID0gbG9va3VwIHBhdGhfa2V5XG4gICAgbGV0IGFyZ3MgOiBzdHJpbmcgbGlzdCB0ID0gbG9va3VwIGFyZ3Nfa2V5XG4gICAgbGV0IGhlbHAgOiBzdHJpbmcgTGF6eS50IHQgPSBsb29rdXAgaGVscF9rZXlcblxuICAgICgqIFRoaXMgaXMgb25seSB1c2VkIGludGVybmFsbHksIGZvciB0aGUgaGVscCBjb21tYW5kLiAqKVxuICAgIGxldCBlbnYgPVxuICAgICAgeyBmID0gKGZ1biAoKSAtPiBBbm9ucy5QYXJzZXIuQmFzaWMuZnJvbV9lbnYgKGZ1biBlbnYgLT4gZW52KSA+Pnwgd3JhcF92YWx1ZSlcbiAgICAgIDsgZmxhZ3MgPSAoZnVuICgpIC0+IFtdKVxuICAgICAgOyB1c2FnZSA9IChmdW4gKCkgLT4gQW5vbnMuR3JhbW1hci56ZXJvKVxuICAgICAgfVxuICAgIDs7XG5cbiAgICBpbmNsdWRlIHN0cnVjdFxuICAgICAgbW9kdWxlIEFyZ190eXBlID0gQXJnX3R5cGVcbiAgICAgIGluY2x1ZGUgQXJnX3R5cGUuRXhwb3J0XG4gICAgZW5kXG5cbiAgICBpbmNsdWRlIHN0cnVjdFxuICAgICAgb3BlbiBBbm9uc1xuXG4gICAgICBsZXQgKCAlOiApID0gKCAlOiApXG4gICAgICBsZXQgbWFwX2Fub25zID0gbWFwX2Fub25zXG4gICAgICBsZXQgbWF5YmUgPSBtYXliZVxuICAgICAgbGV0IG1heWJlX3dpdGhfZGVmYXVsdCA9IG1heWJlX3dpdGhfZGVmYXVsdFxuICAgICAgbGV0IHNlcXVlbmNlID0gc2VxdWVuY2VcbiAgICAgIGxldCBub25fZW1wdHlfc2VxdWVuY2VfYXNfcGFpciA9IG5vbl9lbXB0eV9zZXF1ZW5jZV9hc19wYWlyXG4gICAgICBsZXQgbm9uX2VtcHR5X3NlcXVlbmNlX2FzX2xpc3QgPSBub25fZW1wdHlfc2VxdWVuY2VfYXNfbGlzdFxuICAgICAgbGV0IHQyID0gdDJcbiAgICAgIGxldCB0MyA9IHQzXG4gICAgICBsZXQgdDQgPSB0NFxuXG4gICAgICBsZXQgYW5vbiBzcGVjID1cbiAgICAgICAgQW5vbnMuR3JhbW1hci5pbnZhcmlhbnQgc3BlYy5ncmFtbWFyO1xuICAgICAgICB7IGYgPSAoZnVuICgpIC0+IHNwZWMucCA+PnwgZnVuIG91dGNvbWUgKCkgLT4gb3V0Y29tZSlcbiAgICAgICAgOyBmbGFncyA9IChmdW4gKCkgLT4gW10pXG4gICAgICAgIDsgdXNhZ2UgPSAoZnVuICgpIC0+IHNwZWMuZ3JhbW1hcilcbiAgICAgICAgfVxuICAgICAgOztcbiAgICBlbmRcblxuICAgIGxldCBlc2NhcGVfYW5vbiB+ZmluYWxfYW5vbiA9XG4gICAgICBBbm9ucy5lc2NhcGUgKHQyIGZpbmFsX2Fub24gKHNlcXVlbmNlIChcIkFSR1wiICU6IHN0cmluZykpKSB8PiBhbm9uXG4gICAgOztcblxuICAgIGluY2x1ZGUgc3RydWN0XG4gICAgICBvcGVuIEZsYWdcblxuICAgICAgbGV0IG1hcF9mbGFnID0gbWFwX2ZsYWdcbiAgICAgIGxldCBlc2NhcGUgPSBlc2NhcGVcbiAgICAgIGxldCBlc2NhcGVfd2l0aF9hdXRvY29tcGxldGUgPSBlc2NhcGVfd2l0aF9hdXRvY29tcGxldGVcbiAgICAgIGxldCBsaXN0ZWQgPSBsaXN0ZWRcbiAgICAgIGxldCBvbmVfb3JfbW9yZV9hc19wYWlyID0gb25lX29yX21vcmVfYXNfcGFpclxuICAgICAgbGV0IG9uZV9vcl9tb3JlX2FzX2xpc3QgPSBvbmVfb3JfbW9yZV9hc19saXN0XG4gICAgICBsZXQgbm9fYXJnID0gbm9fYXJnXG4gICAgICBsZXQgbm9fYXJnX3JlcXVpcmVkID0gbm9fYXJnX3JlcXVpcmVkXG4gICAgICBsZXQgbm9fYXJnX3JlZ2lzdGVyID0gbm9fYXJnX3JlZ2lzdGVyXG4gICAgICBsZXQgbm9fYXJnX2Fib3J0ID0gbm9fYXJnX2Fib3J0XG4gICAgICBsZXQgbm9fYXJnX3NvbWUgPSBub19hcmdfc29tZVxuICAgICAgbGV0IG9wdGlvbmFsID0gb3B0aW9uYWxcbiAgICAgIGxldCBvcHRpb25hbF93aXRoX2RlZmF1bHQgPSBvcHRpb25hbF93aXRoX2RlZmF1bHRcbiAgICAgIGxldCByZXF1aXJlZCA9IHJlcXVpcmVkXG5cbiAgICAgIGxldCBmbGFnX2ludGVybmFsXG4gICAgICAgID8oYWxpYXNlcyA9IFtdKVxuICAgICAgICA/ZnVsbF9mbGFnX3JlcXVpcmVkXG4gICAgICAgIG5hbWVcbiAgICAgICAgbW9kZVxuICAgICAgICB+ZG9jXG4gICAgICAgIH5hbGlhc2VzX2V4Y2x1ZGVkX2Zyb21faGVscFxuICAgICAgICA9XG4gICAgICAgIGxldCBub3JtYWxpemUgZmxhZyA9IG5vcm1hbGl6ZSBLZXlfdHlwZS5GbGFnIGZsYWcgaW5cbiAgICAgICAgbGV0IG5hbWUgPSBub3JtYWxpemUgbmFtZSBpblxuICAgICAgICBsZXQgYWxpYXNlcyA9IExpc3QubWFwIH5mOm5vcm1hbGl6ZSBhbGlhc2VzIGluXG4gICAgICAgIGxldCB7IHJlYWQ7IGFjdGlvbjsgbnVtX29jY3VycmVuY2VzOyBleHRyYV9kb2MgfSA9IG1vZGUgbmFtZSBpblxuICAgICAgICBsZXQgY2hlY2tfYXZhaWxhYmxlID1cbiAgICAgICAgICBtYXRjaCBudW1fb2NjdXJyZW5jZXMuYXRfbGVhc3Rfb25jZSB3aXRoXG4gICAgICAgICAgfCBmYWxzZSAtPiAoaWdub3JlIDogVW5pdl9tYXAudCAtPiB1bml0KVxuICAgICAgICAgIHwgdHJ1ZSAtPiBmdW4gZW52IC0+IGlnbm9yZSAocmVhZCBlbnYgOiBfKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbmFtZV9tYXRjaGluZyA9XG4gICAgICAgICAgaWYgT3B0aW9uLmlzX3NvbWUgZnVsbF9mbGFnX3JlcXVpcmVkIHRoZW4gYEZ1bGxfbWF0Y2hfcmVxdWlyZWQgZWxzZSBgUHJlZml4XG4gICAgICAgIGluXG4gICAgICAgIHsgZiA9XG4gICAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICAgIEFub25zLlBhcnNlci5CYXNpYy5mcm9tX2VudiAoZnVuIGVudiAtPiByZWFkIGVudikgPj58IGZ1biB2ICgpIC0+IHYpXG4gICAgICAgIDsgZmxhZ3MgPVxuICAgICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICBbIHsgbmFtZVxuICAgICAgICAgICAgICAgIDsgYWxpYXNlc1xuICAgICAgICAgICAgICAgIDsgYWxpYXNlc19leGNsdWRlZF9mcm9tX2hlbHBcbiAgICAgICAgICAgICAgICA7IGRvYyA9XG4gICAgICAgICAgICAgICAgICAgIChtYXRjaCBmb3JjZSBleHRyYV9kb2Mgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgfCBTb21lIGV4dHJhX2RvYyAtPiBbJXN0cmluZyBcIiV7ZG9jfSAle2V4dHJhX2RvY31cIl1cbiAgICAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBkb2MpXG4gICAgICAgICAgICAgICAgOyBhY3Rpb25cbiAgICAgICAgICAgICAgICA7IG51bV9vY2N1cnJlbmNlc1xuICAgICAgICAgICAgICAgIDsgY2hlY2tfYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgOyBuYW1lX21hdGNoaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdKVxuICAgICAgICA7IHVzYWdlID0gKGZ1biAoKSAtPiBBbm9ucy5HcmFtbWFyLnplcm8pXG4gICAgICAgIH1cbiAgICAgIDs7XG5cbiAgICAgIGxldCBmbGFnID0gZmxhZ19pbnRlcm5hbCB+YWxpYXNlc19leGNsdWRlZF9mcm9tX2hlbHA6W11cblxuICAgICAgbGV0IGZsYWdfb3B0aW9uYWxfd2l0aF9kZWZhdWx0X2RvY1xuICAgICAgICA/YWxpYXNlc1xuICAgICAgICA/ZnVsbF9mbGFnX3JlcXVpcmVkXG4gICAgICAgIG5hbWVcbiAgICAgICAgYXJnX3R5cGVcbiAgICAgICAgc2V4cF9vZl9kZWZhdWx0XG4gICAgICAgIH5kZWZhdWx0XG4gICAgICAgIH5kb2NcbiAgICAgICAgPVxuICAgICAgICBsZXQgZG9jID1cbiAgICAgICAgICBtYXRjaCBzZXhwX29mX2RlZmF1bHQgZGVmYXVsdCB3aXRoXG4gICAgICAgICAgfCBTZXhwLkF0b20gXCJfXCIgLT4gZG9jXG4gICAgICAgICAgfCBkZWZhdWx0X3NleHAgLT4gc3ByaW50ZiAhXCIlcyAoZGVmYXVsdDogJXtTZXhwfSlcIiBkb2MgZGVmYXVsdF9zZXhwXG4gICAgICAgIGluXG4gICAgICAgIGZsYWdcbiAgICAgICAgICA/YWxpYXNlc1xuICAgICAgICAgID9mdWxsX2ZsYWdfcmVxdWlyZWRcbiAgICAgICAgICBuYW1lXG4gICAgICAgICAgKG9wdGlvbmFsX3dpdGhfZGVmYXVsdCBkZWZhdWx0IGFyZ190eXBlKVxuICAgICAgICAgIH5kb2NcbiAgICAgIDs7XG4gICAgZW5kXG5cbiAgICBsZXQgcmV0dXJuIHYgPVxuICAgICAgeyBmID0gKGZ1biAoKSAtPiByZXR1cm4gKGZ1biAoKSAtPiBQYXJzaW5nX291dGNvbWUucmV0dXJuX25vX2FyZyB2KSlcbiAgICAgIDsgZmxhZ3MgPSAoZnVuICgpIC0+IFtdKVxuICAgICAgOyB1c2FnZSA9IChmdW4gKCkgLT4gQW5vbnMuR3JhbW1hci56ZXJvKVxuICAgICAgfVxuICAgIDs7XG5cbiAgICBsZXQgcmVjb3Zlcl9mcm9tX21pc3NpbmdfcmVxdWlyZWRfZmxhZ3MgdCA9XG4gICAgICB7IHQgd2l0aFxuICAgICAgICBmID1cbiAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICB0LmYgKClcbiAgICAgICAgICAgID4+fCBmdW4gZiAoKSAtPlxuICAgICAgICAgICAgbGV0IG91dGNvbWUgPSBmICgpIGluXG4gICAgICAgICAgICBQYXJzaW5nX291dGNvbWUucmVjb3Zlcl9mcm9tX21pc3NpbmdfcmVxdWlyZWRfZmxhZ3Mgb3V0Y29tZSlcbiAgICAgIH1cbiAgICA7O1xuXG4gICAgbGV0IGludHJvZHVjZV9taXNzaW5nX3JlcXVpcmVkX2ZsYWdzIHQgPVxuICAgICAgeyB0IHdpdGhcbiAgICAgICAgZiA9XG4gICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgdC5mICgpXG4gICAgICAgICAgICA+PnwgZnVuIGYgKCkgLT5cbiAgICAgICAgICAgIGxldCBvdXRjb21lID0gZiAoKSBpblxuICAgICAgICAgICAgUGFyc2luZ19vdXRjb21lLmludHJvZHVjZV9taXNzaW5nX3JlcXVpcmVkX2ZsYWdzIG91dGNvbWUpXG4gICAgICB9XG4gICAgOztcblxuICAgIGxldCBvcHRpb25hbF90b19yZXF1aXJlZCB0ID1cbiAgICAgIHsgdCB3aXRoXG4gICAgICAgIGYgPVxuICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgIHQuZiAoKVxuICAgICAgICAgICAgPj58IGZ1biBmICgpIC0+XG4gICAgICAgICAgICBsZXQgb3V0Y29tZSA9IGYgKCkgaW5cbiAgICAgICAgICAgIFBhcnNpbmdfb3V0Y29tZS5pbnRyb2R1Y2VfbWlzc2luZ19yZXF1aXJlZF9mbGFnc1xuICAgICAgICAgICAgICAoUGFyc2luZ19vdXRjb21lLm1hcCBvdXRjb21lIH5mOihmdW5jdGlvblxuICAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgKGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzXG4gICAgICAgICAgICAgICAgICAgICAgKEVycm9yLm9mX3N0cmluZyBcIltvcHRpb25hbF90b19yZXF1aXJlZF0gZ290IGEgW05vbmVdIHJlc3VsdFwiKSlcbiAgICAgICAgICAgICAgICB8IFNvbWUgdiAtPiBPayB2KSkpXG4gICAgICB9XG4gICAgOztcblxuICAgIGluY2x1ZGUgQXBwbGljYXRpdmUuTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgYXBwbHkgPSBhcHBseVxuICAgICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgZW5kKVxuXG4gICAgbGV0IGFyZ19uYW1lcyB0ID1cbiAgICAgIGxldCBmbGFncyA9IEZsYWcuSW50ZXJuYWwuY3JlYXRlICh0LmZsYWdzICgpKSBpblxuICAgICAgbGV0IGZsYWdfbmFtZXMgPSBNYXAua2V5cyBmbGFncyBpblxuICAgICAgbGV0IGFub25fbmFtZXMgPSBBbm9ucy5HcmFtbWFyLm5hbWVzICh0LnVzYWdlICgpKSBpblxuICAgICAgTGlzdC5jb25jYXQgWyBmbGFnX25hbWVzOyBhbm9uX25hbWVzIF1cbiAgICA7O1xuXG4gICAgbGV0IHJlcXVpcmVkX2FyZ19uYW1lcyB0ID1cbiAgICAgIGxldCBmbGFncyA9IEZsYWcuSW50ZXJuYWwuY3JlYXRlICh0LmZsYWdzICgpKSBpblxuICAgICAgTGlzdC5maWx0ZXJfbWFwIChNYXAudG9fYWxpc3QgZmxhZ3MpIH5mOihmdW4gKG5hbWUsIGZsYWcpIC0+XG4gICAgICAgIGlmIGZsYWcubnVtX29jY3VycmVuY2VzLmF0X2xlYXN0X29uY2UgdGhlbiBTb21lIG5hbWUgZWxzZSBOb25lKVxuICAgIDs7XG5cbiAgICBtb2R1bGUgQ2hvb3NlX29uZSA9IHN0cnVjdFxuICAgICAgdHlwZSAnYSBwYXJhbSA9ICdhIHRcblxuICAgICAgbW9kdWxlIENob2ljZV9uYW1lIDogc2lnXG4gICAgICAgIHR5cGUgdCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgICAgIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgICAgICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgICAgICAgdmFsIGxpc3RfdG9fc3RyaW5nIDogdCBsaXN0IC0+IHN0cmluZ1xuICAgICAgICB2YWwgY3JlYXRlX2V4biA6ICdhIHBhcmFtIC0+IHRcbiAgICAgICAgdmFsIGVudW1lcmF0ZV9yZXF1aXJlZF9mbGFncyA6IHQgLT4gZXhjZXB0OnN0cmluZyAtPiBzdHJpbmcgb3B0aW9uXG4gICAgICBlbmQgPSBzdHJ1Y3RcbiAgICAgICAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPVxuICAgICAgICAgICAgeyBhbGxfYXJncyA6IHN0cmluZyBsaXN0XG4gICAgICAgICAgICA7IHJlcXVpcmVkX2FyZ3MgOiBzdHJpbmcgbGlzdFxuICAgICAgICAgICAgfVxuICAgICAgICAgIFtAQGRlcml2aW5nIGNvbXBhcmVdXG5cbiAgICAgICAgICBsZXQgc2V4cF9vZl90IHQgPSBbJXNleHAgKHQuYWxsX2FyZ3MgOiBzdHJpbmcgbGlzdCldXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGluY2x1ZGUgVFxuICAgICAgICBpbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuICAgICAgICBsZXQgY3JlYXRlX2V4biBwYXJhbSA9XG4gICAgICAgICAgbGV0IHJlcXVpcmVkX2FyZ3MgPSByZXF1aXJlZF9hcmdfbmFtZXMgcGFyYW0gaW5cbiAgICAgICAgICBsZXQgbmFtZXMgPSBhcmdfbmFtZXMgcGFyYW0gaW5cbiAgICAgICAgICBsZXQgbmFtZXNfd2l0aF9jb21tYXMgPSBMaXN0LmZpbHRlciBuYW1lcyB+ZjooZnVuIHMgLT4gU3RyaW5nLmNvbnRhaW5zIHMgJywnKSBpblxuICAgICAgICAgIGlmIG5vdCAoTGlzdC5pc19lbXB0eSBuYW1lc193aXRoX2NvbW1hcylcbiAgICAgICAgICB0aGVuXG4gICAgICAgICAgICBFcnJvci5jcmVhdGVcbiAgICAgICAgICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgICAgICAgICBcIkZvciBzaW1wbGljaXR5LCBbQ29tbWFuZC5TcGVjLmNob29zZV9vbmVdIGRvZXMgbm90IHN1cHBvcnQgbmFtZXMgd2l0aCBcXFxuICAgICAgICAgICAgICAgY29tbWFzLlwiXG4gICAgICAgICAgICAgIG5hbWVzX3dpdGhfY29tbWFzXG4gICAgICAgICAgICAgIFslc2V4cF9vZjogc3RyaW5nIGxpc3RdXG4gICAgICAgICAgICB8PiBFcnJvci5yYWlzZTtcbiAgICAgICAgICBtYXRjaCBuYW1lcyB3aXRoXG4gICAgICAgICAgfCBbXSAtPlxuICAgICAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgICAgICBbJW1lc3NhZ2UgXCJbY2hvb3NlX29uZV0gZXhwZWN0cyBjaG9pY2VzIHRvIHJlYWQgY29tbWFuZC1saW5lIGFyZ3VtZW50cy5cIl1cbiAgICAgICAgICB8IF8gOjogXyAtPiB7IGFsbF9hcmdzID0gbmFtZXM7IHJlcXVpcmVkX2FyZ3MgfVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCB0b19zdHJpbmcgdCA9XG4gICAgICAgICAgbWF0Y2ggdC5yZXF1aXJlZF9hcmdzIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IFN0cmluZy5jb25jYXQgfnNlcDpcIixcIiB0LmFsbF9hcmdzXG4gICAgICAgICAgfCBfIDo6IF8gLT4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiLFwiIHQucmVxdWlyZWRfYXJnc1xuICAgICAgICA7O1xuXG4gICAgICAgIGxldCBlbnVtZXJhdGVfcmVxdWlyZWRfZmxhZ3MgdCB+ZXhjZXB0ID1cbiAgICAgICAgICBtYXRjaCBMaXN0LmZpbHRlciB0LnJlcXVpcmVkX2FyZ3MgfmY6KGZ1biB4IC0+IG5vdCAoU3RyaW5nLmVxdWFsIGV4Y2VwdCB4KSkgd2l0aFxuICAgICAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgICAgIHwgXyA6OiBfIGFzIGwgLT4gU29tZSAoU3RyaW5nLmNvbmNhdCB+c2VwOlwiLFwiIGwpXG4gICAgICAgIDs7XG5cbiAgICAgICAgbGV0IGxpc3RfdG9fc3RyaW5nIHRzID0gTGlzdC5tYXAgdHMgfmY6dG9fc3RyaW5nIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIlxcbiAgXCJcbiAgICAgIGVuZFxuXG4gICAgICBtb2R1bGUgSWZfbm90aGluZ19jaG9zZW4gPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoXywgXykgdCA9XG4gICAgICAgICAgfCBEZWZhdWx0X3RvIDogJ2EgLT4gKCdhLCAnYSkgdFxuICAgICAgICAgIHwgUmFpc2UgOiAoJ2EsICdhKSB0XG4gICAgICAgICAgfCBSZXR1cm5fbm9uZSA6ICgnYSwgJ2Egb3B0aW9uKSB0XG4gICAgICBlbmRcblxuICAgICAgbGV0IGNob29zZV9vbmVfbm9uX29wdGlvbmFsXG4gICAgICAgICh0eXBlIGEgYilcbiAgICAgICAgPyhuZXdfYmVoYXZpb3IgPSB0cnVlKVxuICAgICAgICAodHMgOiBhIHBhcmFtIGxpc3QpXG4gICAgICAgIH4oaWZfbm90aGluZ19jaG9zZW4gOiAoYSwgYikgSWZfbm90aGluZ19jaG9zZW4udClcbiAgICAgICAgPVxuICAgICAgICBsZXQgZml4X2ZsYWcgdCA9XG4gICAgICAgICAgaWYgbmV3X2JlaGF2aW9yXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmFtZV9vZl90aGVfZ3JvdXAgPSBDaG9pY2VfbmFtZS5jcmVhdGVfZXhuIHQgaW5cbiAgICAgICAgICAgIGxldCBmaXhfbnVtX29jY3VycmVuY2VzIGZsYWcgPVxuICAgICAgICAgICAgICB7IGZsYWcgd2l0aFxuICAgICAgICAgICAgICAgIEZsYWcuSW50ZXJuYWwubnVtX29jY3VycmVuY2VzID1cbiAgICAgICAgICAgICAgICAgIHsgZmxhZy5GbGFnLkludGVybmFsLm51bV9vY2N1cnJlbmNlcyB3aXRoIGF0X2xlYXN0X29uY2UgPSBmYWxzZSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuZCBmaXhfZG9jIGZsYWcgPVxuICAgICAgICAgICAgICB7IGZsYWcgd2l0aFxuICAgICAgICAgICAgICAgIEZsYWcuSW50ZXJuYWwuZG9jID1cbiAgICAgICAgICAgICAgICAgIHNwcmludGZcbiAgICAgICAgICAgICAgICAgICAgXCIlcyVzXCJcbiAgICAgICAgICAgICAgICAgICAgZmxhZy5GbGFnLkludGVybmFsLmRvY1xuICAgICAgICAgICAgICAgICAgICAobWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgQ2hvaWNlX25hbWUuZW51bWVyYXRlX3JlcXVpcmVkX2ZsYWdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgfmV4Y2VwdDpmbGFnLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lX29mX3RoZV9ncm91cFxuICAgICAgICAgICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgIHwgU29tZSBncm91cCAtPiBzcHJpbnRmIFwiIFtyZXF1aXJlczogXFxcIiVzXFxcIl1cIiBncm91cClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5kIG1ha2VfYW5vbnNfb3B0aW9uYWwgKGFub24gOiBBbm9ucy5HcmFtbWFyLnQpID1cbiAgICAgICAgICAgICAgQW5vbnMuR3JhbW1hci5tYXliZV9pZGVtcG90ZW50IGFub25cbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICB7IHQgd2l0aFxuICAgICAgICAgICAgICB1c2FnZSA9IChmdW4gKCkgLT4gbWFrZV9hbm9uc19vcHRpb25hbCAodC51c2FnZSAoKSkpXG4gICAgICAgICAgICA7IGZsYWdzID1cbiAgICAgICAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICBMaXN0Lm1hcCAodC5mbGFncyAoKSkgfmY6KGZ1biBmbGFnX2ludGVybmFsIC0+XG4gICAgICAgICAgICAgICAgICAgIGZsYWdfaW50ZXJuYWwgfD4gZml4X251bV9vY2N1cnJlbmNlcyB8PiBmaXhfZG9jKSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgZWxzZSB0XG4gICAgICAgIGluXG4gICAgICAgIG1hdGNoXG4gICAgICAgICAgTGlzdC5tYXAgdHMgfmY6KGZ1biB0IC0+IENob2ljZV9uYW1lLmNyZWF0ZV9leG4gdCwgZml4X2ZsYWcgdClcbiAgICAgICAgICB8PiBNYXAub2ZfYWxpc3QgKG1vZHVsZSBDaG9pY2VfbmFtZSlcbiAgICAgICAgd2l0aFxuICAgICAgICB8IGBEdXBsaWNhdGVfa2V5IG5hbWUgLT5cbiAgICAgICAgICBFcnJvci5jcmVhdGVcbiAgICAgICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgICAgIFwiW0NvbW1hbmQuU3BlYy5jaG9vc2Vfb25lXSBjYWxsZWQgd2l0aCBkdXBsaWNhdGUgbmFtZVwiXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICBbJXNleHBfb2Y6IENob2ljZV9uYW1lLnRdXG4gICAgICAgICAgfD4gRXJyb3IucmFpc2VcbiAgICAgICAgfCBgT2sgdHMgLT5cbiAgICAgICAgICBNYXAuZm9sZCB0cyB+aW5pdDoocmV0dXJuIFtdKSB+ZjooZnVuIH5rZXk6bmFtZSB+ZGF0YTp0IGFjYyAtPlxuICAgICAgICAgICAgbWFwMlxuICAgICAgICAgICAgICBhY2NcbiAgICAgICAgICAgICAgKHJlY292ZXJfZnJvbV9taXNzaW5nX3JlcXVpcmVkX2ZsYWdzIHQpXG4gICAgICAgICAgICAgIH5mOihmdW4gYWNjIHsgcmVzdWx0ID0gdmFsdWU7IGhhc19hcmcgfSAtPlxuICAgICAgICAgICAgICBtYXRjaCBoYXNfYXJnIHdpdGhcbiAgICAgICAgICAgICAgfCBmYWxzZSAtPiBhY2NcbiAgICAgICAgICAgICAgfCB0cnVlIC0+IChuYW1lLCB2YWx1ZSkgOjogYWNjKSlcbiAgICAgICAgICB8PiBtYXAgfmY6KGZ1biB2YWx1ZV9saXN0IC0+XG4gICAgICAgICAgICAgICBsZXQgYXJnX2NvdW50ZXIgPSBMaXN0Lmxlbmd0aCB2YWx1ZV9saXN0IGluXG4gICAgICAgICAgICAgICBsZXQgbWlzc2luZ19mbGFnX2Vycm9yIGZtdCA9XG4gICAgICAgICAgICAgICAgIGtzcHJpbnRmXG4gICAgICAgICAgICAgICAgICAgKGZ1biBtc2cgKCkgLT4gRXJyb3IgKGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzIChFcnJvci5vZl9zdHJpbmcgbXNnKSkpXG4gICAgICAgICAgICAgICAgICAgZm10XG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgbGV0IG1vcmVfdGhhbl9vbmVfZXJyb3IgcGFzc2VkID1cbiAgICAgICAgICAgICAgICAgZGllXG4gICAgICAgICAgICAgICAgICAgIVwiQ2Fubm90IHBhc3MgbW9yZSB0aGFuIG9uZSBvZiB0aGVzZTogXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgXFwgICV7Q2hvaWNlX25hbWUubGlzdF90b19zdHJpbmd9XCJcbiAgICAgICAgICAgICAgICAgICAoTGlzdC5tYXAgcGFzc2VkIH5mOmZzdClcbiAgICAgICAgICAgICAgICAgICAoKVxuICAgICAgICAgICAgICAgYW5kIHN1Y2Nlc3NfbGlzdCwgZXJyb3JfbGlzdCA9XG4gICAgICAgICAgICAgICAgIExpc3QucGFydGl0aW9uX21hcCB2YWx1ZV9saXN0IH5mOihmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgIHwgbmFtZSwgT2sgdmFsdWUgLT4gRmlyc3QgKG5hbWUsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgIHwgbmFtZSwgRXJyb3IgZXJyIC0+IFNlY29uZCAobmFtZSwgZXJyKSlcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICBtYXRjaCBzdWNjZXNzX2xpc3Qgd2l0aFxuICAgICAgICAgICAgICAgfCBfIDo6IF8gOjogXyBhcyBwYXNzZWQgLT4gbW9yZV90aGFuX29uZV9lcnJvciBwYXNzZWRcbiAgICAgICAgICAgICAgIHwgWyAoXywgKHZhbHVlIDogYSkpIF0gLT5cbiAgICAgICAgICAgICAgICAgaWYgYXJnX2NvdW50ZXIgPiAxXG4gICAgICAgICAgICAgICAgIHRoZW4gbW9yZV90aGFuX29uZV9lcnJvciB2YWx1ZV9saXN0XG4gICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICBPa1xuICAgICAgICAgICAgICAgICAgICAgKG1hdGNoIGlmX25vdGhpbmdfY2hvc2VuIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICB8IERlZmF1bHRfdG8gKF8gOiBhKSAtPiAodmFsdWUgOiBiKVxuICAgICAgICAgICAgICAgICAgICAgIHwgUmFpc2UgLT4gKHZhbHVlIDogYilcbiAgICAgICAgICAgICAgICAgICAgICB8IFJldHVybl9ub25lIC0+IChTb21lIHZhbHVlIDogYikpXG4gICAgICAgICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBlcnJvcl9saXN0IHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgWyAobmFtZSwgYE1pc3NpbmdfcmVxdWlyZWRfZmxhZ3MgZXJyKSBdIC0+XG4gICAgICAgICAgICAgICAgICAgIEVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgKGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzXG4gICAgICAgICAgICAgICAgICAgICAgICAoRXJyb3Iub2Zfc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoc3ByaW50ZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJOb3QgYWxsIGZsYWdzIGluIGdyb3VwIFxcXCIlc1xcXCIgYXJlIGdpdmVuOiAlc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQ2hvaWNlX25hbWUudG9fc3RyaW5nIG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoRXJyb3IudG9fc3RyaW5nX2h1bSBlcnIpKSkpXG4gICAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgKG1hdGNoIGlmX25vdGhpbmdfY2hvc2VuIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgIHwgRGVmYXVsdF90byB2YWx1ZSAtPiBPayB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgfCBSZXR1cm5fbm9uZSAtPiBPayBOb25lXG4gICAgICAgICAgICAgICAgICAgICB8IFJhaXNlIC0+XG4gICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdfZmxhZ19lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICFcIk11c3QgcGFzcyBvbmUgb2YgdGhlc2U6XFxuICAle0Nob2ljZV9uYW1lLmxpc3RfdG9fc3RyaW5nfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKE1hcC5rZXlzIHRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgpKSkpXG4gICAgICAgICAgfD4gaW50cm9kdWNlX21pc3NpbmdfcmVxdWlyZWRfZmxhZ3NcbiAgICAgIDs7XG5cbiAgICAgIGxldCBjaG9vc2Vfb25lXG4gICAgICAgICh0eXBlIGEgYilcbiAgICAgICAgKHRzIDogYSBvcHRpb24gcGFyYW0gbGlzdClcbiAgICAgICAgfihpZl9ub3RoaW5nX2Nob3NlbiA6IChhLCBiKSBJZl9ub3RoaW5nX2Nob3Nlbi50KVxuICAgICAgICA9XG4gICAgICAgIGNob29zZV9vbmVfbm9uX29wdGlvbmFsXG4gICAgICAgICAgfm5ld19iZWhhdmlvcjpmYWxzZVxuICAgICAgICAgIH5pZl9ub3RoaW5nX2Nob3NlblxuICAgICAgICAgIChMaXN0Lm1hcCB0cyB+ZjooZnVuIHQgLT5cbiAgICAgICAgICAgICBtYXBfb3V0Y29tZSB0IH5mOihmdW4geyBQYXJzaW5nX291dGNvbWUucmVzdWx0OyBoYXNfYXJnIH0gLT5cbiAgICAgICAgICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgICAgICAgICB8IE9rIChTb21lIHZhbHVlKSAtPiB7IFBhcnNpbmdfb3V0Y29tZS5yZXN1bHQgPSBPayB2YWx1ZTsgaGFzX2FyZyA9IHRydWUgfVxuICAgICAgICAgICAgICAgfCBPayBOb25lIC0+XG4gICAgICAgICAgICAgICAgIHsgaGFzX2FyZyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgIDsgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgIEVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgIChgTWlzc2luZ19yZXF1aXJlZF9mbGFncyAoRXJyb3Iub2Zfc3RyaW5nIFwibWlzc2luZyByZXF1aXJlZCBmbGFnXCIpKVxuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB8IEVycm9yIF8gYXMgcmVzdWx0IC0+IHsgaGFzX2FyZzsgcmVzdWx0IH0pKSlcbiAgICAgIDs7XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgSWZfbm90aGluZ19jaG9zZW4gPSBDaG9vc2Vfb25lLklmX25vdGhpbmdfY2hvc2VuXG5cbiAgICBsZXQgY2hvb3NlX29uZSA9IENob29zZV9vbmUuY2hvb3NlX29uZVxuXG4gICAgbGV0IGNob29zZV9vbmVfbm9uX29wdGlvbmFsIGxzdCB+aWZfbm90aGluZ19jaG9zZW4gPVxuICAgICAgQ2hvb3NlX29uZS5jaG9vc2Vfb25lX25vbl9vcHRpb25hbCBsc3QgfmlmX25vdGhpbmdfY2hvc2VuXG4gICAgOztcblxuICAgIGxldCBhbmRfYXJnX25hbWVzIHQgPSBtYXAgdCB+ZjooZnVuIHZhbHVlIC0+IHZhbHVlLCBhcmdfbmFtZXMgdClcblxuICAgIGxldCBhbmRfYXJnX25hbWUgdCA9XG4gICAgICBtYXRjaCBhcmdfbmFtZXMgdCB3aXRoXG4gICAgICB8IFsgbmFtZSBdIC0+IG1hcCB0IH5mOihmdW4gdmFsdWUgLT4gdmFsdWUsIG5hbWUpXG4gICAgICB8IG5hbWVzIC0+XG4gICAgICAgIHJhaXNlX3NcbiAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgIFwiW2FuZF9hcmdfbmFtZV0gZXhwZWN0cyBleGFjdGx5IG9uZSBuYW1lLCBnb3RcIiB+XzoobmFtZXMgOiBzdHJpbmcgbGlzdCldXG4gICAgOztcblxuICAgIGxldCBwYXJzZSB7IGZsYWdzOyB1c2FnZSA9IF87IGYgfSBhcmdzID1cbiAgICAgIGxldCBjbWRsaW5lID0gQ21kbGluZS5vZl9saXN0IGFyZ3MgaW5cbiAgICAgIGxldCByZXN1bHQgPSByZWYgTm9uZSBpblxuICAgICAgcnVuXG4gICAgICAgIHsgc3VtbWFyeSA9IFwiXCJcbiAgICAgICAgOyByZWFkbWUgPSBOb25lXG4gICAgICAgIDsgZmxhZ3MgPSBmbGFncyAoKSB8PiBGbGFnLkludGVybmFsLmNyZWF0ZVxuICAgICAgICA7IGFub25zID1cbiAgICAgICAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgbGV0IG9wZW4gQW5vbnMuUGFyc2VyLkJhc2ljLkZvcl9vcGVuaW5nIGluXG4gICAgICAgICAgICAgIGYgKClcbiAgICAgICAgICAgICAgPj58IGZ1biBwYXJhbXMgYFBhcnNlX2FyZ3MgYFJ1bl9tYWluIC0+XG4gICAgICAgICAgICAgIGxldCBvdXRjb21lID0gcGFyYW1zICgpIGluXG4gICAgICAgICAgICAgIG1hdGNoIG91dGNvbWUucmVzdWx0IHdpdGhcbiAgICAgICAgICAgICAgfCBFcnJvciAoYE1pc3NpbmdfcmVxdWlyZWRfZmxhZ3MgZXJyKSAtPiByZXN1bHQgOj0gU29tZSAoRXJyb3IgZXJyKVxuICAgICAgICAgICAgICB8IE9rIHggLT4gcmVzdWx0IDo9IFNvbWUgKE9rIHgpKVxuICAgICAgICA7IHVzYWdlID0gQW5vbnMuR3JhbW1hci56ZXJvXG4gICAgICAgIH1cbiAgICAgICAgVW5pdl9tYXAuZW1wdHlcbiAgICAgICAgfndoZW5fcGFyc2luZ19zdWNjZWVkczpGbi5pZFxuICAgICAgICB+YXJnczpjbWRsaW5lXG4gICAgICAgIH5wYXRoOlBhdGguZW1wdHlcbiAgICAgICAgfnZlcmJvc2Vfb25fcGFyc2VfZXJyb3I6KFNvbWUgdHJ1ZSlcbiAgICAgICAgfmhlbHBfdGV4dDoobGF6eSBcIk5vIGhlbHAgZm9yIHBhcnNpbmdcIilcbiAgICAgICAgfm9uX2ZhaWx1cmU6XG4gICAgICAgICAgKGZ1blxuICAgICAgICAgICAgZXhuXG4gICAgICAgICAgICB+Zm9yX2NvbXBsZXRpb246KF8gOiBib29sKVxuICAgICAgICAgICAgfnBhdGg6KF8gOiBQYXRoLnQpXG4gICAgICAgICAgICB+dmVyYm9zZV9vbl9wYXJzZV9lcnJvcjooXyA6IGJvb2wgb3B0aW9uKVxuICAgICAgICAgICAgLT4gcmVzdWx0IDo9IFNvbWUgKEVycm9yIChFcnJvci5vZl9leG4gZXhuKSkpO1xuICAgICAgT3B0aW9uLnZhbHVlX2V4biB+aGVyZTpbJWhlcmVdICFyZXN1bHRcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgU3BlYyA9IHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSAtPiAnYikgUGFyYW0udFxuICAgIHR5cGUgJ2EgcGFyYW0gPSAnYSBQYXJhbS50XG5cbiAgICBsZXQgYXBwbHkgPSBQYXJhbS5hcHBseVxuICAgIGxldCAoICsrICkgdDEgdDIgPSBQYXJhbS5tYXAyIHQxIHQyIH5mOihmdW4gZjEgZjIgeCAtPiBmMiAoZjEgeCkpXG4gICAgbGV0ICggKz4gKSB0MSBwMiA9IFBhcmFtLm1hcDIgdDEgcDIgfmY6KGZ1biBmMSBwMiB4IC0+IChmMSB4KSBwMilcbiAgICBsZXQgKCArPCApIHQxIHAyID0gUGFyYW0ubWFwMiBwMiB0MSB+ZjooZnVuIHAyIGYxIHggLT4gZjEgKHggcDIpKVxuICAgIGxldCBzdGVwIGYgPSBQYXJhbS5yZXR1cm4gZlxuXG4gICAgKCogSWRlYWxseSB0aGlzIHdvdWxkIGJlIFtsZXQgZW1wdHkgPSBQYXJhbS5yZXR1cm4gRm4uaWRdLCBidXQgdW5mb3J0dW5hdGVseSB0aGF0XG4gICAgICAgZG9lc24ndCBjb21waWxlIGJlY2F1c2Ugb2YgdGhlIHZhbHVlIHJlc3RyaWN0aW9uICopXG4gICAgbGV0IGVtcHR5ID0gUGFyYW0uZW1wdHlfc3BlY1xuICAgIGxldCBjb25zdCB4ID0gUGFyYW0ucmV0dXJuIHhcbiAgICBsZXQgbWFwID0gUGFyYW0ubWFwXG4gICAgbGV0IHdyYXAgZiB0ID0gUGFyYW0ubWFwIHQgfmY6KGZ1biBydW4gbWFpbiAtPiBmIH5ydW4gfm1haW4pXG4gICAgbGV0IG9mX3BhcmFtIHAgPSBtYXAgcCB+ZjooZnVuIGYgayAtPiBrIGYpXG4gICAgbGV0IHRvX3BhcmFtIHQgbSA9IG1hcCB0IH5mOihmdW4gZiAtPiBmIG0pXG4gICAgbGV0IHBhdGggOiBQYXRoLnQgcGFyYW0gPSBQYXJhbS5wYXRoXG4gICAgbGV0IGFyZ3MgOiBzdHJpbmcgbGlzdCBwYXJhbSA9IFBhcmFtLmFyZ3NcbiAgICBsZXQgaGVscCA6IHN0cmluZyBMYXp5LnQgcGFyYW0gPSBQYXJhbS5oZWxwXG5cbiAgICBpbmNsdWRlIHN0cnVjdFxuICAgICAgbW9kdWxlIEFyZ190eXBlID0gQXJnX3R5cGVcbiAgICAgIGluY2x1ZGUgQXJnX3R5cGUuRXhwb3J0XG4gICAgZW5kXG5cbiAgICBpbmNsdWRlIHN0cnVjdFxuICAgICAgb3BlbiBBbm9uc1xuXG4gICAgICB0eXBlICdhIGFub25zID0gJ2EgdFxuXG4gICAgICBsZXQgKCAlOiApID0gKCAlOiApXG4gICAgICBsZXQgbWFwX2Fub25zID0gbWFwX2Fub25zXG4gICAgICBsZXQgbWF5YmUgPSBtYXliZVxuICAgICAgbGV0IG1heWJlX3dpdGhfZGVmYXVsdCA9IG1heWJlX3dpdGhfZGVmYXVsdFxuICAgICAgbGV0IG5vbl9lbXB0eV9zZXF1ZW5jZV9hc19saXN0ID0gbm9uX2VtcHR5X3NlcXVlbmNlX2FzX2xpc3RcbiAgICAgIGxldCBub25fZW1wdHlfc2VxdWVuY2VfYXNfcGFpciA9IG5vbl9lbXB0eV9zZXF1ZW5jZV9hc19wYWlyXG4gICAgICBsZXQgc2VxdWVuY2UgPSBzZXF1ZW5jZVxuICAgICAgbGV0IHQyID0gdDJcbiAgICAgIGxldCB0MyA9IHQzXG4gICAgICBsZXQgdDQgPSB0NFxuICAgICAgbGV0IGFub24gPSBQYXJhbS5hbm9uXG4gICAgZW5kXG5cbiAgICBsZXQgZXNjYXBlX2Fub24gPSBQYXJhbS5lc2NhcGVfYW5vblxuXG4gICAgaW5jbHVkZSBzdHJ1Y3RcbiAgICAgIG9wZW4gRmxhZ1xuXG4gICAgICB0eXBlICdhIGZsYWcgPSAnYSB0XG5cbiAgICAgIGxldCBtYXBfZmxhZyA9IG1hcF9mbGFnXG4gICAgICBsZXQgZXNjYXBlID0gZXNjYXBlXG4gICAgICBsZXQgZXNjYXBlX3dpdGhfYXV0b2NvbXBsZXRlID0gZXNjYXBlX3dpdGhfYXV0b2NvbXBsZXRlXG4gICAgICBsZXQgbGlzdGVkID0gbGlzdGVkXG4gICAgICBsZXQgb25lX29yX21vcmVfYXNfcGFpciA9IG9uZV9vcl9tb3JlX2FzX3BhaXJcbiAgICAgIGxldCBvbmVfb3JfbW9yZV9hc19saXN0ID0gb25lX29yX21vcmVfYXNfbGlzdFxuICAgICAgbGV0IG5vX2FyZyA9IG5vX2FyZ1xuICAgICAgbGV0IG5vX2FyZ19yZXF1aXJlZCA9IG5vX2FyZ19yZXF1aXJlZFxuICAgICAgbGV0IG5vX2FyZ19yZWdpc3RlciA9IG5vX2FyZ19yZWdpc3RlclxuICAgICAgbGV0IG5vX2FyZ19hYm9ydCA9IG5vX2FyZ19hYm9ydFxuICAgICAgbGV0IG5vX2FyZ19zb21lID0gbm9fYXJnX3NvbWVcbiAgICAgIGxldCBvcHRpb25hbCA9IG9wdGlvbmFsXG4gICAgICBsZXQgb3B0aW9uYWxfd2l0aF9kZWZhdWx0ID0gb3B0aW9uYWxfd2l0aF9kZWZhdWx0XG4gICAgICBsZXQgcmVxdWlyZWQgPSByZXF1aXJlZFxuICAgICAgbGV0IGZsYWcgPSBQYXJhbS5mbGFnXG4gICAgICBsZXQgZmxhZ19vcHRpb25hbF93aXRoX2RlZmF1bHRfZG9jID0gUGFyYW0uZmxhZ19vcHRpb25hbF93aXRoX2RlZmF1bHRfZG9jXG5cbiAgICAgIGluY2x1ZGUgQXBwbGljYXRpdmUuTWFrZSAoc3RydWN0XG4gICAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSBQYXJhbS50XG5cbiAgICAgICAgbGV0IHJldHVybiA9IFBhcmFtLnJldHVyblxuICAgICAgICBsZXQgYXBwbHkgPSBhcHBseVxuICAgICAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICAgIGVuZClcblxuICAgICAgbGV0IHBhaXIgPSBQYXJhbS5ib3RoXG4gICAgZW5kXG5cbiAgICBsZXQgZmxhZ3Nfb2ZfYXJnc19leG4gYXJncyA9XG4gICAgICBMaXN0LmZvbGQgYXJncyB+aW5pdDplbXB0eSB+ZjooZnVuIGFjYyAobmFtZSwgc3BlYywgZG9jKSAtPlxuICAgICAgICBsZXQgZ2VuIGYgZmxhZ190eXBlID1cbiAgICAgICAgICBzdGVwIChmdW4gbSB4IC0+XG4gICAgICAgICAgICBmIHg7XG4gICAgICAgICAgICBtKVxuICAgICAgICAgICs+IFBhcmFtLmZsYWcgbmFtZSBmbGFnX3R5cGUgfmRvY1xuICAgICAgICBpblxuICAgICAgICBsZXQgY2FsbCBmIGFyZ190eXBlID0gZ2VuIChmdW4geCAtPiBPcHRpb24uaXRlciB4IH5mKSAoUGFyYW0ub3B0aW9uYWwgYXJnX3R5cGUpIGluXG4gICAgICAgIGxldCBzZXQgciBhcmdfdHlwZSA9IGNhbGwgKGZ1biB4IC0+IHIgOj0geCkgYXJnX3R5cGUgaW5cbiAgICAgICAgbGV0IHNldF9ib29sIHIgYiA9IGdlbiAoZnVuIHBhc3NlZCAtPiBpZiBwYXNzZWQgdGhlbiByIDo9IGIpIFBhcmFtLm5vX2FyZyBpblxuICAgICAgICBhY2NcbiAgICAgICAgKytcbiAgICAgICAgbWF0Y2ggKHNwZWMgOiBTdGRsaWIuQXJnLnNwZWMpIHdpdGhcbiAgICAgICAgfCBVbml0IGYgLT4gZ2VuIChmdW4gcGFzc2VkIC0+IGlmIHBhc3NlZCB0aGVuIGYgKCkpIFBhcmFtLm5vX2FyZ1xuICAgICAgICB8IFNldCByIC0+IHNldF9ib29sIHIgdHJ1ZVxuICAgICAgICB8IENsZWFyIHIgLT4gc2V0X2Jvb2wgciBmYWxzZVxuICAgICAgICB8IFN0cmluZyBmIC0+IGNhbGwgZiBzdHJpbmdcbiAgICAgICAgfCBTZXRfc3RyaW5nIHIgLT4gc2V0IHIgc3RyaW5nXG4gICAgICAgIHwgSW50IGYgLT4gY2FsbCBmIGludFxuICAgICAgICB8IFNldF9pbnQgciAtPiBzZXQgciBpbnRcbiAgICAgICAgfCBGbG9hdCBmIC0+IGNhbGwgZiBmbG9hdFxuICAgICAgICB8IFNldF9mbG9hdCByIC0+IHNldCByIGZsb2F0XG4gICAgICAgIHwgQm9vbCBmIC0+IGNhbGwgZiBib29sXG4gICAgICAgIHwgU3ltYm9sIChzeW1zLCBmKSAtPlxuICAgICAgICAgIGxldCBhcmdfdHlwZSA9XG4gICAgICAgICAgICBBcmdfdHlwZS5vZl9hbGlzdF9leG5cbiAgICAgICAgICAgICAgfmxpc3RfdmFsdWVzX2luX2hlbHA6ZmFsc2VcbiAgICAgICAgICAgICAgKExpc3QubWFwIHN5bXMgfmY6KGZ1biBzeW0gLT4gc3ltLCBzeW0pKVxuICAgICAgICAgIGluXG4gICAgICAgICAgY2FsbCBmIGFyZ190eXBlXG4gICAgICAgIHwgUmVzdCBmIC0+IGdlbiAoZnVuIHggLT4gT3B0aW9uLml0ZXIgeCB+ZjooTGlzdC5pdGVyIH5mKSkgUGFyYW0uZXNjYXBlXG4gICAgICAgIHwgVHVwbGUgXyAtPlxuICAgICAgICAgIGZhaWx3aXRoIFwiQXJnLlR1cGxlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgQ29tbWFuZC5TcGVjLmZsYWdzX29mX2FyZ3NfZXhuXCJcbiAgICAgICAgfCAoKEV4cGFuZCBfKSBbQGlmIG9jYW1sX3ZlcnNpb24gPj0gKDQsIDA1LCAwKV0pIC0+XG4gICAgICAgICAgZmFpbHdpdGggXCJBcmcuRXhwYW5kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgQ29tbWFuZC5TcGVjLmZsYWdzX29mX2FyZ3NfZXhuXCJcbiAgICAgICAgfCAoKFJlc3RfYWxsIF8pIFtAaWYgb2NhbWxfdmVyc2lvbiA+PSAoNCwgMTIsIDApXSkgLT5cbiAgICAgICAgICBmYWlsd2l0aCBcIkFyZy5SZXN0X2FsbCBpcyBub3Qgc3VwcG9ydGVkIGJ5IENvbW1hbmQuU3BlYy5mbGFnc19vZl9hcmdzX2V4blwiKVxuICAgIDs7XG5cbiAgICBtb2R1bGUgRGVwcmVjYXRlZCA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBGbGFnLkRlcHJlY2F0ZWRcbiAgICAgIGluY2x1ZGUgQW5vbnMuRGVwcmVjYXRlZFxuICAgIGVuZFxuXG4gICAgbGV0IGFyZ19uYW1lcyA9IFBhcmFtLmFyZ19uYW1lc1xuXG4gICAgbW9kdWxlIElmX25vdGhpbmdfY2hvc2VuID0gUGFyYW0uQ2hvb3NlX29uZS5JZl9ub3RoaW5nX2Nob3NlblxuXG4gICAgbGV0IGNob29zZV9vbmUgPSBQYXJhbS5jaG9vc2Vfb25lXG4gICAgbGV0IGNob29zZV9vbmVfbm9uX29wdGlvbmFsID0gUGFyYW0uY2hvb3NlX29uZV9ub25fb3B0aW9uYWxcbiAgICBsZXQgYW5kX2FyZ19uYW1lcyA9IFBhcmFtLmFuZF9hcmdfbmFtZXNcbiAgICBsZXQgYW5kX2FyZ19uYW1lID0gUGFyYW0uYW5kX2FyZ19uYW1lXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBHcm91cCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgc3VtbWFyeSA6IHN0cmluZ1xuICAgIDsgcmVhZG1lIDogKHVuaXQgLT4gc3RyaW5nKSBvcHRpb25cbiAgICA7IHN1YmNvbW1hbmRzIDogKHN0cmluZyAqICdhKSBsaXN0IExhenkudFxuICAgIDsgYm9keSA6IChwYXRoOnN0cmluZyBsaXN0IC0+IHVuaXQpIG9wdGlvblxuICAgIH1cblxuICBsZXQgc2hhcGUgfnN1YmNvbW1hbmRfdG9fc2hhcGUgdCA6IF8gU2hhcGUuR3JvdXBfaW5mby50ID1cbiAgICB7IHN1bW1hcnkgPSB0LnN1bW1hcnlcbiAgICA7IHJlYWRtZSA9IE9wdGlvbi5tYXAgfmY6KGZ1biByZWFkbWUgLT4gcmVhZG1lICgpKSB0LnJlYWRtZVxuICAgIDsgc3ViY29tbWFuZHMgPSBMYXp5Lm1hcCB0LnN1YmNvbW1hbmRzIH5mOihMaXN0LkFzc29jLm1hcCB+ZjpzdWJjb21tYW5kX3RvX3NoYXBlKVxuICAgIH1cbiAgOztcbmVuZFxuXG5sZXQgYWJzX3BhdGggPSBTaGFwZS5Qcml2YXRlLmFic19wYXRoXG5sZXQgY29tcF9jd29yZCA9IEVudl92YXIuQ09NUF9DV09SRFxuXG5tb2R1bGUgRXhlYyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgc3VtbWFyeSA6IHN0cmluZ1xuICAgIDsgcmVhZG1lIDogKHVuaXQgLT4gc3RyaW5nKSBvcHRpb25cbiAgICA7ICgqIElmIFtwYXRoX3RvX2V4ZV0gaXMgcmVsYXRpdmUsIGludGVycHJldCB3LnIudC4gW3dvcmtpbmdfZGlyXSAqKVxuICAgICAgd29ya2luZ19kaXIgOiBzdHJpbmdcbiAgICA7IHBhdGhfdG9fZXhlIDogc3RyaW5nXG4gICAgOyBjaGlsZF9zdWJjb21tYW5kIDogc3RyaW5nIGxpc3RcbiAgICA7IGVudiA6IGVudiBvcHRpb25cbiAgICB9XG5cbiAgbGV0IHNoYXBlIHQgOiBTaGFwZS5FeGVjX2luZm8udCA9XG4gICAgeyBzdW1tYXJ5ID0gdC5zdW1tYXJ5XG4gICAgOyByZWFkbWUgPSBPcHRpb24ubWFwIH5mOihmdW4gcmVhZG1lIC0+IHJlYWRtZSAoKSkgdC5yZWFkbWVcbiAgICA7IHdvcmtpbmdfZGlyID0gdC53b3JraW5nX2RpclxuICAgIDsgcGF0aF90b19leGUgPSB0LnBhdGhfdG9fZXhlXG4gICAgOyBjaGlsZF9zdWJjb21tYW5kID0gdC5jaGlsZF9zdWJjb21tYW5kXG4gICAgfVxuICA7O1xuZW5kXG5cbigqIEEgcHJveHkgY29tbWFuZCBpcyB0aGUgc3RydWN0dXJlIG9mIGFuIEV4ZWMgY29tbWFuZCBvYnRhaW5lZCBieSBydW5uaW5nIGl0IGluIGFcbiAgIHNwZWNpYWwgd2F5ICopXG5tb2R1bGUgUHJveHkgPSBzdHJ1Y3RcbiAgbW9kdWxlIEtpbmQgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPVxuICAgICAgfCBCYXNlIG9mIFNoYXBlLkJhc2VfaW5mby50XG4gICAgICB8IEdyb3VwIG9mICdhIFNoYXBlLkdyb3VwX2luZm8udFxuICAgICAgfCBFeGVjIG9mIFNoYXBlLkV4ZWNfaW5mby50XG4gICAgICB8IExhenkgb2YgJ2EgdCBMYXp5LnRcbiAgZW5kXG5cbiAgdHlwZSB0ID1cbiAgICB7IHdvcmtpbmdfZGlyIDogc3RyaW5nXG4gICAgOyBwYXRoX3RvX2V4ZSA6IHN0cmluZ1xuICAgIDsgcGF0aF90b19zdWJjb21tYW5kIDogc3RyaW5nIGxpc3RcbiAgICA7IGNoaWxkX3N1YmNvbW1hbmQgOiBzdHJpbmcgbGlzdFxuICAgIDsga2luZCA6IHQgS2luZC50XG4gICAgfVxuZW5kXG5cbnR5cGUgdCA9XG4gIHwgQmFzZSBvZiBDb21tYW5kX2Jhc2UudFxuICB8IEdyb3VwIG9mIHQgR3JvdXAudFxuICB8IEV4ZWMgb2YgRXhlYy50XG4gIHwgTGF6eSBvZiB0IExhenkudFxuXG5sZXQgcmVjIHNleHBhYmxlX3NoYXBlIDogdCAtPiBTaGFwZS5TZXhwYWJsZS50ID0gZnVuY3Rpb25cbiAgfCBCYXNlIGJhc2UgLT4gQmFzZSAoQ29tbWFuZF9iYXNlLnNoYXBlIGJhc2UpXG4gIHwgRXhlYyBleGVjIC0+IEV4ZWMgKEV4ZWMuc2hhcGUgZXhlYylcbiAgfCBHcm91cCBncm91cCAtPiBHcm91cCAoR3JvdXAuc2hhcGUgfnN1YmNvbW1hbmRfdG9fc2hhcGU6c2V4cGFibGVfc2hhcGUgZ3JvdXApXG4gIHwgTGF6eSB0aHVuayAtPiBMYXp5IChMYXp5Lm1hcCB+ZjpzZXhwYWJsZV9zaGFwZSB0aHVuaylcbjs7XG5cbnR5cGUgKCdtYWluLCAncmVzdWx0KSBiYXNpY19zcGVjX2NvbW1hbmQgPVxuICBzdW1tYXJ5OnN0cmluZ1xuICAtPiA/cmVhZG1lOih1bml0IC0+IHN0cmluZylcbiAgLT4gKCdtYWluLCB1bml0IC0+ICdyZXN1bHQpIENvbW1hbmRfYmFzZS5TcGVjLnRcbiAgLT4gJ21haW5cbiAgLT4gdFxuXG5sZXQgZXh0ZW5kX2V4biB+bWVtIH5hZGQgbWFwIGtleV90eXBlIH5rZXkgZGF0YSA9XG4gIGlmIG1lbSBtYXAga2V5XG4gIHRoZW4gZmFpbHdpdGhmIFwidGhlcmUgaXMgYWxyZWFkeSBhICVzIG5hbWVkICVzXCIgKEtleV90eXBlLnRvX3N0cmluZyBrZXlfdHlwZSkga2V5ICgpO1xuICBhZGQgbWFwIH5rZXkgfmRhdGFcbjs7XG5cbmxldCBleHRlbmRfbWFwX2V4biBtYXAga2V5X3R5cGUgfmtleSBkYXRhID1cbiAgZXh0ZW5kX2V4biBtYXAga2V5X3R5cGUgfmtleSBkYXRhIH5tZW06TWFwLm1lbSB+YWRkOk1hcC5zZXRcbjs7XG5cbmxldCBleHRlbmRfYWxpc3RfZXhuIGFsaXN0IGtleV90eXBlIH5rZXkgZGF0YSA9XG4gIGV4dGVuZF9leG5cbiAgICBhbGlzdFxuICAgIGtleV90eXBlXG4gICAgfmtleVxuICAgIGRhdGFcbiAgICB+bWVtOihmdW4gYWxpc3Qga2V5IC0+IExpc3QuQXNzb2MubWVtIGFsaXN0IGtleSB+ZXF1YWw6U3RyaW5nLmVxdWFsKVxuICAgIH5hZGQ6KGZ1biBhbGlzdCB+a2V5IH5kYXRhIC0+IExpc3QuQXNzb2MuYWRkIGFsaXN0IGtleSBkYXRhIH5lcXVhbDpTdHJpbmcuZXF1YWwpXG47O1xuXG5tb2R1bGUgQmFpbG91dF9kdW1wX2ZsYWcgPSBzdHJ1Y3RcbiAgbGV0IGFkZCBiYXNlIH5uYW1lIH5hbGlhc2VzIH5hbGlhc2VzX2V4Y2x1ZGVkX2Zyb21faGVscCB+dGV4dCB+dGV4dF9zdW1tYXJ5ID1cbiAgICBsZXQgZmxhZ3MgPSBiYXNlLkNvbW1hbmRfYmFzZS5mbGFncyBpblxuICAgIGxldCBmbGFncyA9XG4gICAgICBleHRlbmRfbWFwX2V4blxuICAgICAgICBmbGFnc1xuICAgICAgICBLZXlfdHlwZS5GbGFnXG4gICAgICAgIH5rZXk6bmFtZVxuICAgICAgICB7IG5hbWVcbiAgICAgICAgOyBhbGlhc2VzX2V4Y2x1ZGVkX2Zyb21faGVscFxuICAgICAgICA7IGFsaWFzZXNcbiAgICAgICAgOyBudW1fb2NjdXJyZW5jZXMgPSBGbGFnLk51bV9vY2N1cnJlbmNlcy5hdF9tb3N0X29uY2VcbiAgICAgICAgOyBjaGVja19hdmFpbGFibGUgPSBpZ25vcmVcbiAgICAgICAgOyBhY3Rpb24gPSBQcmludF9pbmZvX2FuZF9xdWl0IChmdW4gZW52IC0+IHRleHQgZW52KVxuICAgICAgICA7IGRvYyA9IHNwcmludGYgXCIgcHJpbnQgJXMgYW5kIGV4aXRcIiB0ZXh0X3N1bW1hcnlcbiAgICAgICAgOyBuYW1lX21hdGNoaW5nID0gYFByZWZpeFxuICAgICAgICB9XG4gICAgaW5cbiAgICB7IGJhc2Ugd2l0aCBmbGFncyB9XG4gIDs7XG5lbmRcblxubGV0IGJhc2ljIH5zdW1tYXJ5ID9yZWFkbWUgeyBDb21tYW5kX2Jhc2UuUGFyYW0udXNhZ2U7IGZsYWdzOyBmIH0gPVxuICBsZXQgZmxhZ3MgPSBmbGFncyAoKSBpblxuICBsZXQgdXNhZ2UgPSB1c2FnZSAoKSBpblxuICBsZXQgYW5vbnMgKCkgPVxuICAgIGxldCBvcGVuIEFub25zLlBhcnNlci5CYXNpYy5Gb3Jfb3BlbmluZyBpblxuICAgIGYgKClcbiAgICA+PnwgZnVuIHBhcmFtcyBgUGFyc2VfYXJncyAtPlxuICAgIGxldCBvdXRjb21lID0gcGFyYW1zICgpIGluXG4gICAgbWF0Y2ggb3V0Y29tZS5yZXN1bHQgd2l0aFxuICAgIHwgRXJyb3IgKGBNaXNzaW5nX3JlcXVpcmVkX2ZsYWdzIGVycikgLT4gZGllIFwiJXNcIiAoRXJyb3IudG9fc3RyaW5nX2h1bSBlcnIpICgpXG4gICAgfCBPayB0aHVuayAtPiBmdW4gYFJ1bl9tYWluIC0+IHRodW5rICgpXG4gIGluXG4gIGxldCBmbGFncyA9IEZsYWcuSW50ZXJuYWwuY3JlYXRlIGZsYWdzIGluXG4gIGxldCBiYXNlID0geyBDb21tYW5kX2Jhc2Uuc3VtbWFyeTsgcmVhZG1lOyB1c2FnZTsgZmxhZ3M7IGFub25zIH0gaW5cbiAgbGV0IGJhc2UgPVxuICAgIEJhaWxvdXRfZHVtcF9mbGFnLmFkZFxuICAgICAgYmFzZVxuICAgICAgfm5hbWU6XCItaGVscFwiXG4gICAgICB+YWxpYXNlczpbIFwiLT9cIiBdXG4gICAgICB+YWxpYXNlc19leGNsdWRlZF9mcm9tX2hlbHA6WyBcIi0taGVscFwiIF1cbiAgICAgIH50ZXh0X3N1bW1hcnk6XCJ0aGlzIGhlbHAgdGV4dFwiXG4gICAgICB+dGV4dDooZnVuIGVudiAtPiBMYXp5LmZvcmNlIChFbnYuZmluZF9leG4gZW52IENvbW1hbmRfYmFzZS5oZWxwX2tleSkpXG4gIGluXG4gIEJhc2UgYmFzZVxuOztcblxubGV0IGJhc2ljX3NwZWMgfnN1bW1hcnkgP3JlYWRtZSBzcGVjIG1haW4gPVxuICBiYXNpYyB+c3VtbWFyeSA/cmVhZG1lIChDb21tYW5kX2Jhc2UuU3BlYy50b19wYXJhbSBzcGVjIG1haW4pXG47O1xuXG5sZXQgc3Vic19rZXkgOiAoc3RyaW5nICogdCkgbGlzdCBFbnYuS2V5LnQgPSBFbnYua2V5X2NyZWF0ZSBcInN1YmNvbW1hbmRzXCJcblxubGV0IGxhenlfZ3JvdXAgfnN1bW1hcnkgP3JlYWRtZSA/cHJlc2VydmVfc3ViY29tbWFuZF9vcmRlciA/Ym9keSBhbGlzdCA9XG4gIGxldCBzdWJjb21tYW5kcyA9XG4gICAgTGF6eS5tYXAgYWxpc3QgfmY6KGZ1biBhbGlzdCAtPlxuICAgICAgbGV0IGFsaXN0ID1cbiAgICAgICAgTGlzdC5tYXAgYWxpc3QgfmY6KGZ1biAobmFtZSwgdCkgLT4gbm9ybWFsaXplIEtleV90eXBlLlN1YmNvbW1hbmQgbmFtZSwgdClcbiAgICAgIGluXG4gICAgICBtYXRjaCBNYXAub2ZfYWxpc3QgKG1vZHVsZSBTdHJpbmcpIGFsaXN0IHdpdGhcbiAgICAgIHwgYER1cGxpY2F0ZV9rZXkgbmFtZSAtPiBmYWlsd2l0aGYgXCJtdWx0aXBsZSBzdWJjb21tYW5kcyBuYW1lZCAlc1wiIG5hbWUgKClcbiAgICAgIHwgYE9rIG1hcCAtPlxuICAgICAgICAobWF0Y2ggcHJlc2VydmVfc3ViY29tbWFuZF9vcmRlciB3aXRoXG4gICAgICAgICB8IFNvbWUgKCkgLT4gYWxpc3RcbiAgICAgICAgIHwgTm9uZSAtPiBNYXAudG9fYWxpc3QgbWFwKSlcbiAgaW5cbiAgR3JvdXAgeyBzdW1tYXJ5OyByZWFkbWU7IHN1YmNvbW1hbmRzOyBib2R5IH1cbjs7XG5cbmxldCBncm91cCB+c3VtbWFyeSA/cmVhZG1lID9wcmVzZXJ2ZV9zdWJjb21tYW5kX29yZGVyID9ib2R5IGFsaXN0ID1cbiAgbGV0IHJlYWRtZSA9IE9wdGlvbi5tYXAgcmVhZG1lIH5mOihmdW4gZiAoKSAtPiBTdHJpbmcuc3RyaXAgKGYgKCkpKSBpblxuICBsYXp5X2dyb3VwIH5zdW1tYXJ5ID9yZWFkbWUgP3ByZXNlcnZlX3N1YmNvbW1hbmRfb3JkZXIgP2JvZHkgKExhenkuZnJvbV92YWwgYWxpc3QpXG47O1xuXG5sZXQgZXhlYyB+c3VtbWFyeSA/cmVhZG1lID8oY2hpbGRfc3ViY29tbWFuZCA9IFtdKSA/ZW52IH5wYXRoX3RvX2V4ZSAoKSA9XG4gIGxldCB3b3JraW5nX2RpciA9XG4gICAgRmlsZW5hbWVfYmFzZS5kaXJuYW1lXG4gICAgQEBcbiAgICBtYXRjaCBwYXRoX3RvX2V4ZSB3aXRoXG4gICAgfCBgQWJzb2x1dGUgXyB8IGBSZWxhdGl2ZV90b19tZSBfIC0+IFN0ZGxpYi5TeXMuZXhlY3V0YWJsZV9uYW1lXG4gICAgfCBgUmVsYXRpdmVfdG9fYXJndjAgXyAtPiBTdGRsaWIuU3lzLmFyZ3YuKDApXG4gIGluXG4gIGxldCBwYXRoX3RvX2V4ZSA9XG4gICAgbWF0Y2ggcGF0aF90b19leGUgd2l0aFxuICAgIHwgYEFic29sdXRlIHAgLT5cbiAgICAgIGlmIG5vdCAoRmlsZW5hbWVfYmFzZS5pc19hYnNvbHV0ZSBwKVxuICAgICAgdGhlbiBmYWlsd2l0aCBcIlBhdGggcGFzc2VkIHRvIGBBYnNvbHV0ZSBtdXN0IGJlIGFic29sdXRlXCJcbiAgICAgIGVsc2UgcFxuICAgIHwgYFJlbGF0aXZlX3RvX21lIHAgfCBgUmVsYXRpdmVfdG9fYXJndjAgcCAtPlxuICAgICAgaWYgbm90IChGaWxlbmFtZV9iYXNlLmlzX3JlbGF0aXZlIHApXG4gICAgICB0aGVuIGZhaWx3aXRoIFwiUGF0aCBwYXNzZWQgdG8gYFJlbGF0aXZlX3RvX21lIG11c3QgYmUgcmVsYXRpdmVcIlxuICAgICAgZWxzZSBwXG4gIGluXG4gIEV4ZWMgeyBzdW1tYXJ5OyByZWFkbWU7IHdvcmtpbmdfZGlyOyBwYXRoX3RvX2V4ZTsgY2hpbGRfc3ViY29tbWFuZDsgZW52IH1cbjs7XG5cbmxldCBvZl9sYXp5IHRodW5rID0gTGF6eSB0aHVua1xuXG5sZXQgcmVjIHByb3h5X29mX3NleHBhYmxlXG4gIHNleHBhYmxlXG4gIH53b3JraW5nX2RpclxuICB+cGF0aF90b19leGVcbiAgfmNoaWxkX3N1YmNvbW1hbmRcbiAgfnBhdGhfdG9fc3ViY29tbWFuZFxuICA6IFByb3h5LnRcbiAgPVxuICBsZXQga2luZCA9XG4gICAga2luZF9vZl9zZXhwYWJsZVxuICAgICAgc2V4cGFibGVcbiAgICAgIH53b3JraW5nX2RpclxuICAgICAgfnBhdGhfdG9fZXhlXG4gICAgICB+Y2hpbGRfc3ViY29tbWFuZFxuICAgICAgfnBhdGhfdG9fc3ViY29tbWFuZFxuICBpblxuICB7IHdvcmtpbmdfZGlyOyBwYXRoX3RvX2V4ZTsgcGF0aF90b19zdWJjb21tYW5kOyBjaGlsZF9zdWJjb21tYW5kOyBraW5kIH1cblxuYW5kIGtpbmRfb2Zfc2V4cGFibGVcbiAgc2V4cGFibGVcbiAgfndvcmtpbmdfZGlyXG4gIH5wYXRoX3RvX2V4ZVxuICB+Y2hpbGRfc3ViY29tbWFuZFxuICB+cGF0aF90b19zdWJjb21tYW5kXG4gID1cbiAgbWF0Y2ggKHNleHBhYmxlIDogU2hhcGUuU2V4cGFibGUudCkgd2l0aFxuICB8IEJhc2UgYiAtPiBQcm94eS5LaW5kLkJhc2UgYlxuICB8IEV4ZWMgZSAtPiBQcm94eS5LaW5kLkV4ZWMgZVxuICB8IExhenkgbCAtPlxuICAgIFByb3h5LktpbmQuTGF6eVxuICAgICAgKExhenkubWFwIGwgfmY6KGZ1biBzZXhwYWJsZSAtPlxuICAgICAgICAga2luZF9vZl9zZXhwYWJsZVxuICAgICAgICAgICBzZXhwYWJsZVxuICAgICAgICAgICB+d29ya2luZ19kaXJcbiAgICAgICAgICAgfnBhdGhfdG9fZXhlXG4gICAgICAgICAgIH5jaGlsZF9zdWJjb21tYW5kXG4gICAgICAgICAgIH5wYXRoX3RvX3N1YmNvbW1hbmQpKVxuICB8IEdyb3VwIGcgLT5cbiAgICBQcm94eS5LaW5kLkdyb3VwXG4gICAgICB7IGcgd2l0aFxuICAgICAgICBzdWJjb21tYW5kcyA9XG4gICAgICAgICAgTGF6eS5tYXBcbiAgICAgICAgICAgIGcuc3ViY29tbWFuZHNcbiAgICAgICAgICAgIH5mOlxuICAgICAgICAgICAgICAoTGlzdC5tYXAgfmY6KGZ1biAoc3RyLCBzZXhwYWJsZSkgLT5cbiAgICAgICAgICAgICAgICAgbGV0IHBhdGhfdG9fc3ViY29tbWFuZCA9IHBhdGhfdG9fc3ViY29tbWFuZCBAIFsgc3RyIF0gaW5cbiAgICAgICAgICAgICAgICAgbGV0IHByb3h5ID1cbiAgICAgICAgICAgICAgICAgICBwcm94eV9vZl9zZXhwYWJsZVxuICAgICAgICAgICAgICAgICAgICAgc2V4cGFibGVcbiAgICAgICAgICAgICAgICAgICAgIH53b3JraW5nX2RpclxuICAgICAgICAgICAgICAgICAgICAgfnBhdGhfdG9fZXhlXG4gICAgICAgICAgICAgICAgICAgICB+Y2hpbGRfc3ViY29tbWFuZFxuICAgICAgICAgICAgICAgICAgICAgfnBhdGhfdG9fc3ViY29tbWFuZFxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICBzdHIsIHByb3h5KSlcbiAgICAgIH1cbjs7XG5cbm1vZHVsZSBWZXJzaW9uX2luZm8gKFZlcnNpb25fdXRpbCA6IFZlcnNpb25fdXRpbCkgPSBzdHJ1Y3RcbiAgbGV0IHByaW50X3ZlcnNpb24gfnZlcnNpb24gPSBwcmludF9lbmRsaW5lIChmb3JjZSB2ZXJzaW9uKVxuICBsZXQgcHJpbnRfYnVpbGRfaW5mbyB+YnVpbGRfaW5mbyA9IHByaW50X2VuZGxpbmUgKGZvcmNlIGJ1aWxkX2luZm8pXG5cbiAgbGV0IGNvbW1hbmQgfnZlcnNpb24gfmJ1aWxkX2luZm8gPVxuICAgIGJhc2ljXG4gICAgICB+c3VtbWFyeTpcInByaW50IHZlcnNpb24gaW5mb3JtYXRpb25cIlxuICAgICAgQ29tbWFuZF9iYXNlLlBhcmFtLihcbiAgICAgICAgcmV0dXJuIChmdW4gdmVyc2lvbl9mbGFnIGJ1aWxkX2luZm9fZmxhZyAtPlxuICAgICAgICAgIGlmIGJ1aWxkX2luZm9fZmxhZ1xuICAgICAgICAgIHRoZW4gcHJpbnRfYnVpbGRfaW5mbyB+YnVpbGRfaW5mb1xuICAgICAgICAgIGVsc2UgaWYgdmVyc2lvbl9mbGFnXG4gICAgICAgICAgdGhlbiBwcmludF92ZXJzaW9uIH52ZXJzaW9uXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBwcmludF9idWlsZF9pbmZvIH5idWlsZF9pbmZvO1xuICAgICAgICAgICAgcHJpbnRfdmVyc2lvbiB+dmVyc2lvbik7XG4gICAgICAgICAgZXhpdCAwKVxuICAgICAgICA8Kj4gZmxhZyBcIi12ZXJzaW9uXCIgbm9fYXJnIH5kb2M6XCIgcHJpbnQgdGhlIHZlcnNpb24gb2YgdGhpcyBidWlsZFwiXG4gICAgICAgIDwqPiBmbGFnIFwiLWJ1aWxkLWluZm9cIiBub19hcmcgfmRvYzpcIiBwcmludCBidWlsZCBpbmZvIGZvciB0aGlzIGJ1aWxkXCIpXG4gIDs7XG5cbiAgbGV0IHJlYyBhZGQgfnZlcnNpb24gfmJ1aWxkX2luZm8gdW52ZXJzaW9uZWQgPVxuICAgIG1hdGNoIHVudmVyc2lvbmVkIHdpdGhcbiAgICB8IEJhc2UgYmFzZSAtPlxuICAgICAgbGV0IGJhc2UgPVxuICAgICAgICBCYWlsb3V0X2R1bXBfZmxhZy5hZGRcbiAgICAgICAgICBiYXNlXG4gICAgICAgICAgfm5hbWU6XCItdmVyc2lvblwiXG4gICAgICAgICAgfmFsaWFzZXM6W11cbiAgICAgICAgICB+YWxpYXNlc19leGNsdWRlZF9mcm9tX2hlbHA6WyBcIi0tdmVyc2lvblwiIF1cbiAgICAgICAgICB+dGV4dF9zdW1tYXJ5OlwidGhlIHZlcnNpb24gb2YgdGhpcyBidWlsZFwiXG4gICAgICAgICAgfnRleHQ6KGZ1biBfIC0+IGZvcmNlIHZlcnNpb24pXG4gICAgICBpblxuICAgICAgbGV0IGJhc2UgPVxuICAgICAgICBCYWlsb3V0X2R1bXBfZmxhZy5hZGRcbiAgICAgICAgICBiYXNlXG4gICAgICAgICAgfm5hbWU6XCItYnVpbGQtaW5mb1wiXG4gICAgICAgICAgfmFsaWFzZXM6W11cbiAgICAgICAgICB+YWxpYXNlc19leGNsdWRlZF9mcm9tX2hlbHA6WyBcIi0tYnVpbGQtaW5mb1wiIF1cbiAgICAgICAgICB+dGV4dF9zdW1tYXJ5OlwiaW5mbyBhYm91dCB0aGlzIGJ1aWxkXCJcbiAgICAgICAgICB+dGV4dDooZnVuIF8gLT4gZm9yY2UgYnVpbGRfaW5mbylcbiAgICAgIGluXG4gICAgICBCYXNlIGJhc2VcbiAgICB8IEdyb3VwIGdyb3VwIC0+XG4gICAgICBsZXQgc3ViY29tbWFuZHMgPVxuICAgICAgICBMYXp5Lm1hcCBncm91cC5Hcm91cC5zdWJjb21tYW5kcyB+ZjooZnVuIHN1YmNvbW1hbmRzIC0+XG4gICAgICAgICAgZXh0ZW5kX2FsaXN0X2V4blxuICAgICAgICAgICAgc3ViY29tbWFuZHNcbiAgICAgICAgICAgIEtleV90eXBlLlN1YmNvbW1hbmRcbiAgICAgICAgICAgIH5rZXk6XCJ2ZXJzaW9uXCJcbiAgICAgICAgICAgIChjb21tYW5kIH52ZXJzaW9uIH5idWlsZF9pbmZvKSlcbiAgICAgIGluXG4gICAgICBHcm91cCB7IGdyb3VwIHdpdGggR3JvdXAuc3ViY29tbWFuZHMgfVxuICAgIHwgRXhlYyBleGVjIC0+IEV4ZWMgZXhlY1xuICAgIHwgTGF6eSB0aHVuayAtPiBMYXp5IChsYXp5IChhZGQgfnZlcnNpb24gfmJ1aWxkX2luZm8gKExhenkuZm9yY2UgdGh1bmspKSlcbiAgOztcblxuICBsZXQgbm9ybWFsaXplX3ZlcnNpb25fbGluZXMgbGluZXMgPVxuICAgIFN0cmluZy5jb25jYXQgfnNlcDpcIlxcblwiIChMaXN0LnNvcnQgbGluZXMgfmNvbXBhcmU6U3RyaW5nLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGRlZmF1bHRfdmVyc2lvbiA9IGxhenkgKG5vcm1hbGl6ZV92ZXJzaW9uX2xpbmVzIFZlcnNpb25fdXRpbC52ZXJzaW9uX2xpc3QpXG5cbiAgbGV0IGRlZmF1bHRfYnVpbGRfaW5mbyA9XG4gICAgbGF6eVxuICAgICAgKCogbGF6eSB0byBhdm9pZCBsb2FkaW5nIGFsbCB0aGUgdGltZSB6b25lIHN0dWZmIGF0IHRvcGxldmVsICopXG4gICAgICAoVmVyc2lvbl91dGlsLnJlcHJpbnRfYnVpbGRfaW5mbyBWZXJzaW9uX3V0aWwuVGltZS5zZXhwX29mX3QpXG4gIDs7XG5lbmRcblxubGV0JXRlc3RfbW9kdWxlIFwiVmVyc2lvbl9pbmZvXCIgPVxuICAobW9kdWxlIHN0cnVjdFxuICAgIG1vZHVsZSBWZXJzaW9uX2luZm8gPSBWZXJzaW9uX2luZm8gKHN0cnVjdFxuICAgICAgbGV0IHZlcnNpb25fbGlzdCA9IFsgXCJoZzovL3NvbWUvcGF0aF8weGRlYWRiZWVmXCI7IFwic3NoOi8vYS9wYXRoXzhiYWRmMDBkXCIgXVxuICAgICAgbGV0IHJlcHJpbnRfYnVpbGRfaW5mbyB0b19zZXhwID0gU2V4cC50b19zdHJpbmcgKHRvX3NleHAgKCkpXG5cbiAgICAgIG1vZHVsZSBUaW1lID0gc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IHVuaXQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICAgIGVuZFxuICAgIGVuZClcblxuICAgIGxldCVleHBlY3RfdGVzdCBcInByaW50IHZlcnNpb24gd2hlcmUgbXVsdGlwbGUgcmVwb3MgYXJlIHVzZWRcIiA9XG4gICAgICBWZXJzaW9uX2luZm8ucHJpbnRfdmVyc2lvbiB+dmVyc2lvbjpWZXJzaW9uX2luZm8uZGVmYXVsdF92ZXJzaW9uO1xuICAgICAgWyVleHBlY3RcbiAgICAgICAge3xcbiAgICAgICAgaGc6Ly9zb21lL3BhdGhfMHhkZWFkYmVlZlxuICAgICAgICBzc2g6Ly9hL3BhdGhfOGJhZGYwMGRcbiAgICAgICAgfH1dXG4gICAgOztcblxuICAgIGxldCVleHBlY3RfdGVzdCBcInByaW50IGJ1aWxkIGluZm9cIiA9XG4gICAgICBWZXJzaW9uX2luZm8ucHJpbnRfYnVpbGRfaW5mbyB+YnVpbGRfaW5mbzoobGF6eSBcInNvbWUgYnVpbGQgaW5mb1wiKTtcbiAgICAgIFslZXhwZWN0IHt8IHNvbWUgYnVpbGQgaW5mbyB8fV1cbiAgICA7O1xuICBlbmQpXG47O1xuXG5sZXQgcmVjIHN1bW1hcnkgPSBmdW5jdGlvblxuICB8IEJhc2UgeCAtPiB4LnN1bW1hcnlcbiAgfCBHcm91cCB4IC0+IHguc3VtbWFyeVxuICB8IEV4ZWMgeCAtPiB4LnN1bW1hcnlcbiAgfCBMYXp5IHRodW5rIC0+IHN1bW1hcnkgKExhenkuZm9yY2UgdGh1bmspXG47O1xuXG5tb2R1bGUgU3BlYyA9IHN0cnVjdFxuICBpbmNsdWRlIENvbW1hbmRfYmFzZS5TcGVjXG5cbiAgbGV0IHBhdGggPSBtYXAgfmY6UGF0aC5wYXJ0c19leGVfYmFzZW5hbWUgcGF0aFxuZW5kXG5cbm1vZHVsZSBEZXByZWNhdGVkID0gc3RydWN0XG4gIG1vZHVsZSBTcGVjID0gU3BlYy5EZXByZWNhdGVkXG5cbiAgbGV0IHN1bW1hcnkgPSBzdW1tYXJ5XG5cbiAgbGV0IHJlYyBnZXRfZmxhZ19uYW1lcyA9IGZ1bmN0aW9uXG4gICAgfCBCYXNlIGJhc2UgLT4gYmFzZS5Db21tYW5kX2Jhc2UuZmxhZ3MgfD4gTWFwLmtleXNcbiAgICB8IExhenkgdGh1bmsgLT4gZ2V0X2ZsYWdfbmFtZXMgKExhenkuZm9yY2UgdGh1bmspXG4gICAgfCBHcm91cCBfIHwgRXhlYyBfIC0+IGFzc2VydCBmYWxzZVxuICA7O1xuXG4gIGxldCBoZWxwX3JlY3Vyc2l2ZSB+Y21kIH53aXRoX2ZsYWdzIH5leHBhbmRfZG90cyB0IHMgPVxuICAgIGxldCByZWMgaGVscF9yZWN1cnNpdmVfcmVjIH5jbWQgdCBzID1cbiAgICAgIGxldCBuZXdfcyA9IHMgXiAoaWYgZXhwYW5kX2RvdHMgdGhlbiBjbWQgZWxzZSBcIi5cIikgXiBcIiBcIiBpblxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IExhenkgdGh1bmsgLT5cbiAgICAgICAgbGV0IHQgPSBMYXp5LmZvcmNlIHRodW5rIGluXG4gICAgICAgIGhlbHBfcmVjdXJzaXZlX3JlYyB+Y21kIHQgc1xuICAgICAgfCBCYXNlIGJhc2UgLT5cbiAgICAgICAgbGV0IGJhc2VfaGVscCA9IHMgXiBjbWQsIHN1bW1hcnkgKEJhc2UgYmFzZSkgaW5cbiAgICAgICAgaWYgd2l0aF9mbGFnc1xuICAgICAgICB0aGVuXG4gICAgICAgICAgYmFzZV9oZWxwXG4gICAgICAgICAgOjogTGlzdC5tYXBcbiAgICAgICAgICAgICAgIH5mOihmdW4gKGZsYWcsIGgpIC0+IG5ld19zIF4gZmxhZywgaClcbiAgICAgICAgICAgICAgIChMaXN0LnNvcnRcbiAgICAgICAgICAgICAgICAgIH5jb21wYXJlOkNvbW1hbmRfYmFzZS5EZXByZWNhdGVkLnN1YmNvbW1hbmRfY21wX2ZzdFxuICAgICAgICAgICAgICAgICAgKENvbW1hbmRfYmFzZS5EZXByZWNhdGVkLmZsYWdzX2hlbHAgfmRpc3BsYXlfaGVscF9mbGFnczpmYWxzZSBiYXNlKSlcbiAgICAgICAgZWxzZSBbIGJhc2VfaGVscCBdXG4gICAgICB8IEdyb3VwIHsgc3VtbWFyeTsgc3ViY29tbWFuZHM7IHJlYWRtZSA9IF87IGJvZHkgPSBfIH0gLT5cbiAgICAgICAgKHMgXiBjbWQsIHN1bW1hcnkpXG4gICAgICAgIDo6IChMYXp5LmZvcmNlIHN1YmNvbW1hbmRzXG4gICAgICAgICAgICB8PiBMaXN0LnNvcnQgfmNvbXBhcmU6Q29tbWFuZF9iYXNlLkRlcHJlY2F0ZWQuc3ViY29tbWFuZF9jbXBfZnN0XG4gICAgICAgICAgICB8PiBMaXN0LmNvbmNhdF9tYXAgfmY6KGZ1biAoY21kJywgdCkgLT4gaGVscF9yZWN1cnNpdmVfcmVjIH5jbWQ6Y21kJyB0IG5ld19zKVxuICAgICAgICAgICApXG4gICAgICB8IEV4ZWMgXyAtPlxuICAgICAgICAoKiBDb21tYW5kLmV4ZWMgZG9lcyBub3Qgc3VwcG9ydCBkZXByZWNhdGVkIGNvbW1hbmRzICopXG4gICAgICAgIFtdXG4gICAgaW5cbiAgICBoZWxwX3JlY3Vyc2l2ZV9yZWMgfmNtZCB0IHNcbiAgOztcbmVuZFxuXG4oKiBUaGlzIHNjcmlwdCB3b3JrcyBpbiBib3RoIGJhc2ggKHZpYSByZWFkYXJyYXkpIGFuZCB6c2ggKHZpYSByZWFkIC1BKS4gIElmIHlvdSBjaGFuZ2VcbiAgIGl0LCBwbGVhc2UgdGVzdCBpbiBib3RoIGJhc2ggYW5kIHpzaC4gIEl0IGRvZXMgbm90IHdvcmsgdGNzaCAoZGlmZmVyZW50IGZ1bmN0aW9uXG4gICBzeW50YXgpLiAqKVxubGV0IGF1dG9jb21wbGV0ZV9mdW5jdGlvbiB+YXJndl8wIH5waWQgPVxuICBsZXQgZm5hbWUgPVxuICAgICgqIE5vdGU6IHdlIHBhZCB0aGUgcGlkIHRvIGEgZGV0ZXJtaW5pc3RpYyBsZW5ndGgsIGFzIGluIDIwMjMgaXQgd2FzIGRldGVybWluZWQgdGhhdFxuICAgICAgIGlmIG11bHRpcGxlIGludm9jYXRpb25zIG9jY3VycmVkIGF0IHRoZSBzYW1lIHRpbWUgb2YgcmVxdWVzdGluZyB0aGVzZSBmdW5jdGlvbnMgdG9cbiAgICAgICBiZSB3cml0dGVuIHRvIHRoZSBzYW1lIGZpbGUgKGUuZy4gMiBzaGVsbHMgb3BlbmluZyBhdCAvZXhhY3RseS8gdGhlIHJpZ2h0IHRpbWUpXG4gICAgICAgdGhlcmUgd291bGQgYmUgYmFkIGV4dHJhIGJ5dGVzIGxlZnQgb3ZlciBpbiB0aGUgd3JpdHRlbiBmaWxlLCBzbyBtYWtpbmcgaXQsXG4gICAgICAgZGV0ZXJtaW5pc3RpYyBpbiBsZW5ndGggaXJyZXNwZWN0aXZlIG9mIHRoZSBwaWQgaXMgaW1wb3J0YW50LiBHaXZlbiB0aGF0IHBpZHMgZG9uJ3RcbiAgICAgICBleGNlZWQgNjU1MzYsIDEwIGRpZ2l0cyBzaG91bGQgZ2l2ZSB1cyBsb3RzIG9mIGJyZWF0aGluZyByb29tLiAqKVxuICAgIHNwcmludGYgXCJfanNhdXRvY29tXyUwMTBkXCIgcGlkXG4gIGluXG4gIHNwcmludGZcbiAgICBcImZ1bmN0aW9uICVzIHtcXG5cXFxuICAgIFxcICBleHBvcnQgQ09NUF9DV09SRFxcblxcXG4gICAgXFwgIENPTVBfV09SRFNbMF09JXNcXG5cXFxuICAgIFxcICBpZiB0eXBlIHJlYWRhcnJheSA+IC9kZXYvbnVsbFxcblxcXG4gICAgXFwgIHRoZW4gcmVhZGFycmF5IC10IENPTVBSRVBMWSA8IDwoXFxcIiR7Q09NUF9XT1JEU1tAXX1cXFwiKVxcblxcXG4gICAgXFwgIGVsc2UgSUZTPVxcXCJcXG5cXFxuICAgICBcXFwiIHJlYWQgLWQgXFxcIlxcXCIgLUEgQ09NUFJFUExZIDwgPChcXFwiJHtDT01QX1dPUkRTW0BdfVxcXCIpXFxuXFxcbiAgICBcXCAgZmlcXG5cXFxuICAgICB9XFxuXFxcbiAgICAgY29tcGxldGUgLUYgJXMgJXNcXG5cXFxuICAgICAlIVwiXG4gICAgZm5hbWVcbiAgICBhcmd2XzBcbiAgICBmbmFtZVxuICAgIGFyZ3ZfMFxuOztcblxubGV0JWV4cGVjdF90ZXN0IFwiRGVtb25zdHJhdGUgW2F1dG9jb21wbGV0ZV9mdW5jdGlvbl1cIiA9XG4gIGF1dG9jb21wbGV0ZV9mdW5jdGlvbiB+YXJndl8wOlwiPGFyZ3ZfMD5cIiB+cGlkOjEyMzQ1IHw+IHByaW50X2VuZGxpbmU7XG4gIFslZXhwZWN0XG4gICAge3xcbiAgICBmdW5jdGlvbiBfanNhdXRvY29tXzAwMDAwMTIzNDUge1xuICAgICAgZXhwb3J0IENPTVBfQ1dPUkRcbiAgICAgIENPTVBfV09SRFNbMF09PGFyZ3ZfMD5cbiAgICAgIGlmIHR5cGUgcmVhZGFycmF5ID4gL2Rldi9udWxsXG4gICAgICB0aGVuIHJlYWRhcnJheSAtdCBDT01QUkVQTFkgPCA8KFwiJHtDT01QX1dPUkRTW0BdfVwiKVxuICAgICAgZWxzZSBJRlM9XCJcbiAgICBcIiByZWFkIC1kIFwiXCIgLUEgQ09NUFJFUExZIDwgPChcIiR7Q09NUF9XT1JEU1tAXX1cIilcbiAgICAgIGZpXG4gICAgfVxuICAgIGNvbXBsZXRlIC1GIF9qc2F1dG9jb21fMDAwMDAxMjM0NSA8YXJndl8wPlxuICAgIHx9XVxuOztcblxubW9kdWxlIEZvcl91bml4IChGb3JfdW5peF93aXRoX3N0cmluZ19lbnZfdmFyIDogRm9yX3VuaXggd2l0aCB0eXBlIGVudl92YXIgOj0gc3RyaW5nKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFZlcnNpb25faW5mbyA9IFZlcnNpb25faW5mbyAoRm9yX3VuaXhfd2l0aF9zdHJpbmdfZW52X3Zhci5WZXJzaW9uX3V0aWwpXG5cbiAgbW9kdWxlIEZvcl91bml4X3dpdGhfY29tbWFuZF9lbnZfdmFyIDogRm9yX3VuaXggd2l0aCB0eXBlIGVudl92YXIgOj0gRW52X3Zhci50ID0gc3RydWN0XG4gICAgKCogV2UgZm9yY2UgYWNjZXNzIHRvIGVudiB2YXJzIHRvIGdvIHRocm91Z2ggW0NvbW1hbmRfZW52X3Zhcl0gc28gdGhhdCB3ZSBjYW4ga2VlcCBhblxuICAgICAgIGFjY3VyYXRlIGVudW1lcmF0aW9uIG9mIHRoZSB2YXJpYWJsZXMgd2UgdXNlLiAqKVxuXG4gICAgaW5jbHVkZSBGb3JfdW5peF93aXRoX3N0cmluZ19lbnZfdmFyXG5cbiAgICBtb2R1bGUgVW5peCA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBVbml4XG5cbiAgICAgIGxldCBwdXRlbnYgfmtleSB+ZGF0YSA9IHB1dGVudiB+a2V5OihFbnZfdmFyLnRvX3N0cmluZyBrZXkpIH5kYXRhXG4gICAgICBsZXQgdW5zZXRlbnYga2V5ID0gdW5zZXRlbnYgKEVudl92YXIudG9fc3RyaW5nIGtleSlcbiAgICAgIGxldCB1bnNhZmVfZ2V0ZW52IGtleSA9IHVuc2FmZV9nZXRlbnYgKEVudl92YXIudG9fc3RyaW5nIGtleSlcblxuICAgICAgbGV0IGNvbnZlcnRfZW52IGVudiA9XG4gICAgICAgIGxldCBjb252ZXJ0X2NvbW1hbmRfZW52X3Zhcl90b19zdHJpbmcgbGlzdCA9XG4gICAgICAgICAgTGlzdC5tYXAgbGlzdCB+ZjooZnVuIChlbnZfdmFyLCBzdHIpIC0+IEVudl92YXIudG9fc3RyaW5nIGVudl92YXIsIHN0cilcbiAgICAgICAgaW5cbiAgICAgICAgbWF0Y2ggZW52IHdpdGhcbiAgICAgICAgfCBgUmVwbGFjZSBsaXN0IC0+IGBSZXBsYWNlIChjb252ZXJ0X2NvbW1hbmRfZW52X3Zhcl90b19zdHJpbmcgbGlzdClcbiAgICAgICAgfCBgRXh0ZW5kIGxpc3QgLT4gYEV4dGVuZCAoY29udmVydF9jb21tYW5kX2Vudl92YXJfdG9fc3RyaW5nIGxpc3QpXG4gICAgICAgIHwgYE92ZXJyaWRlIGxpc3QgLT4gYE92ZXJyaWRlIChjb252ZXJ0X2NvbW1hbmRfZW52X3Zhcl90b19zdHJpbmcgbGlzdClcbiAgICAgICAgfCBgUmVwbGFjZV9yYXcgXyBhcyByZXBsYWNlIC0+IHJlcGxhY2VcbiAgICAgIDs7XG5cbiAgICAgIGxldCBleGVjIH5wcm9nIH5hcmd2ID91c2VfcGF0aCA/ZW52ICgpID1cbiAgICAgICAgZXhlYyB+cHJvZyB+YXJndiA/dXNlX3BhdGggP2VudjooT3B0aW9uLm1hcCBlbnYgfmY6Y29udmVydF9lbnYpICgpXG4gICAgICA7O1xuXG4gICAgICBsZXQgY3JlYXRlX3Byb2Nlc3NfZW52ID93b3JraW5nX2RpciA/cHJvZ19zZWFyY2hfcGF0aCA/YXJndjAgfnByb2cgfmFyZ3MgfmVudiAoKSA9XG4gICAgICAgIGNyZWF0ZV9wcm9jZXNzX2VudlxuICAgICAgICAgID93b3JraW5nX2RpclxuICAgICAgICAgID9wcm9nX3NlYXJjaF9wYXRoXG4gICAgICAgICAgP2FyZ3YwXG4gICAgICAgICAgfnByb2dcbiAgICAgICAgICB+YXJnc1xuICAgICAgICAgIH5lbnY6KGNvbnZlcnRfZW52IGVudilcbiAgICAgICAgICAoKVxuICAgICAgOztcbiAgICBlbmRcbiAgZW5kXG5cbiAgb3BlbiBGb3JfdW5peF93aXRoX2NvbW1hbmRfZW52X3ZhclxuXG4gICgqIENsZWFyIHRoZSBzZXR0aW5nIG9mIGVudmlyb25tZW50IHZhcmlhYmxlIGFzc29jaWF0ZWQgd2l0aCBjb21tYW5kLWxpbmVcbiAgICAgY29tcGxldGlvbiBhbmQgcmVjdXJzaXZlIGhlbHAgc28gdGhhdCBzdWJwcm9jZXNzZXMgZG9uJ3Qgc2VlIHRoZW0uXG5cbiAgICAgVXNlIFt1bnNhZmVfZ2V0ZW52XSBzbyBzZXR1aWQtcm9vdCBwcm9ncmFtcyBjYW4gc3RpbGwgcmVhZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgIFRoZXJlIGlzIG5vIHNlY3VyaXR5IHJpc2sgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZXMgYXJlIG9ubHkgdXNlZCBhcyB0cmlnZ2VycyB0byBkdW1wXG4gICAgIG91dCBjb21tYW5kIGluZm9ybWF0aW9uLiAqKVxuICBsZXQgZ2V0ZW52X2FuZF9jbGVhciB2YXIgPVxuICAgIGxldCB2YWx1ZSA9IFVuaXgudW5zYWZlX2dldGVudiB2YXIgaW5cbiAgICBpZiBPcHRpb24uaXNfc29tZSB2YWx1ZSB0aGVuIFVuaXgudW5zZXRlbnYgdmFyO1xuICAgIHZhbHVlXG4gIDs7XG5cbiAgbGV0IG1heWJlX2NvbXBfY3dvcmQgKCkgPSBnZXRlbnZfYW5kX2NsZWFyIGNvbXBfY3dvcmQgfD4gT3B0aW9uLm1hcCB+ZjpJbnQub2Zfc3RyaW5nXG5cbiAgbGV0IHNldF9jb21wX2N3b3JkIG5ld192YWx1ZSA9XG4gICAgbGV0IG5ld192YWx1ZSA9IEludC50b19zdHJpbmcgbmV3X3ZhbHVlIGluXG4gICAgVW5peC5wdXRlbnYgfmtleTpjb21wX2N3b3JkIH5kYXRhOm5ld192YWx1ZVxuICA7O1xuXG4gIG1vZHVsZSBFeGVjID0gc3RydWN0XG4gICAgaW5jbHVkZSBFeGVjXG5cbiAgICBsZXQgZXhlY193aXRoX2FyZ3MgdCB+YXJncyB+bWF5YmVfbmV3X2NvbXBfY3dvcmQgPVxuICAgICAgbGV0IHByb2cgPSBhYnNfcGF0aCB+ZGlyOnQud29ya2luZ19kaXIgdC5wYXRoX3RvX2V4ZSBpblxuICAgICAgbGV0IGFyZ3MgPSB0LmNoaWxkX3N1YmNvbW1hbmQgQCBhcmdzIGluXG4gICAgICBsZXQgZW52ID0gdC5lbnYgaW5cbiAgICAgIE9wdGlvbi5pdGVyIG1heWJlX25ld19jb21wX2N3b3JkIH5mOihmdW4gbiAtPlxuICAgICAgICAoKiBUaGUgbG9naWMgZm9yIHRyYWNraW5nIFttYXliZV9uZXdfY29tcF9jd29yZF0gZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB3aGV0aGVyXG4gICAgICAgICAgIHRoaXMgZXhlYyBzcGVjaWZpZXMgYSBjaGlsZCBzdWJjb21tYW5kLiBJZiBpdCBkb2VzLCBDT01QX0NXT1JEIG5lZWRzIHRvIGJlIHNldFxuICAgICAgICAgICBoaWdoZXIgdG8gYWNjb3VudCBmb3IgdGhlIGFyZ3VtZW50cyB1c2VkIHRvIHNwZWNpZnkgdGhlIGNoaWxkIHN1YmNvbW1hbmQuICopXG4gICAgICAgIHNldF9jb21wX2N3b3JkIChuICsgTGlzdC5sZW5ndGggdC5jaGlsZF9zdWJjb21tYW5kKSk7XG4gICAgICBOb3RoaW5nLnVucmVhY2hhYmxlX2NvZGVcbiAgICAgICAgKEZvcl91bml4X3dpdGhfc3RyaW5nX2Vudl92YXIuVW5peC5leGVjID9lbnYgfnByb2cgfmFyZ3Y6KHByb2cgOjogYXJncykgKCkpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIFNleHBhYmxlID0gc3RydWN0XG4gICAgaW5jbHVkZSBTaGFwZS5TZXhwYWJsZVxuXG4gICAgbGV0IHJlYWRfc3Rkb3V0X2FuZF9zdGRlcnIgKHByb2Nlc3NfaW5mbyA6IFVuaXguUHJvY2Vzc19pbmZvLnQpID1cbiAgICAgICgqIFdlIG5lZWQgdG8gcmVhZCBlYWNoIG9mIHN0ZG91dCBhbmQgc3RkZXJyIGluIGEgc2VwYXJhdGUgdGhyZWFkIHRvIGF2b2lkIGRlYWRsb2Nrc1xuICAgICAgICAgaWYgdGhlIGNoaWxkIHByb2Nlc3MgZGVjaWRlcyB0byB3YWl0IGZvciBhIHJlYWQgb24gb25lIGJlZm9yZSBjbG9zaW5nIHRoZSBvdGhlci5cbiAgICAgICAgIEJ1ZmZlcmluZyBtYXkgaGlkZSB0aGlzIHByb2JsZW0gdW50aWwgb3V0cHV0IGlzIFwic3VmZmljaWVudGx5IGxhcmdlXCIuICopXG4gICAgICBsZXQgc3RhcnRfcmVhZGluZyBkZXNjciBpbmZvID1cbiAgICAgICAgbGV0IG91dHB1dCA9IHJlZiBOb25lIGluXG4gICAgICAgIGxldCB0aHJlYWQgPVxuICAgICAgICAgIFRocmVhZC5jcmVhdGVcbiAgICAgICAgICAgIH5vbl91bmNhdWdodF9leG46YFByaW50X3RvX3N0ZGVyclxuICAgICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICBsZXQgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICBSZXN1bHQudHJ5X3dpdGggKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgICAgZGVzY3IgfD4gVW5peC5pbl9jaGFubmVsX29mX2Rlc2NyIHw+IEluX2NoYW5uZWwuaW5wdXRfYWxsKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBvdXRwdXQgOj0gU29tZSByZXN1bHQpXG4gICAgICAgICAgICAoKVxuICAgICAgICBpblxuICAgICAgICBTdGFnZWQuc3RhZ2UgKGZ1biAoKSAtPlxuICAgICAgICAgIFRocmVhZC5qb2luIHRocmVhZDtcbiAgICAgICAgICBVbml4LmNsb3NlIGRlc2NyO1xuICAgICAgICAgIG1hdGNoICFvdXRwdXQgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiByYWlzZV9zIFslbWVzc2FnZSBcIkJVRyBmYWlsZWQgdG8gcmVhZFwiIChpbmZvIDogSW5mby50KV1cbiAgICAgICAgICB8IFNvbWUgKE9rIG91dHB1dCkgLT4gb3V0cHV0XG4gICAgICAgICAgfCBTb21lIChFcnJvciBleG4pIC0+IHJhaXNlIGV4bilcbiAgICAgIGluXG4gICAgICAoKiBXZSBtaWdodCBoYW5nIGZvcmV2ZXIgdHJ5aW5nIHRvIGpvaW4gdGhlIHJlYWRpbmcgdGhyZWFkcyBpZiB0aGUgY2hpbGQgcHJvY2VzcyBrZWVwc1xuICAgICAgICAgdGhlIGZpbGUgZGVzY3JpcHRvciBvcGVuLiBOb3QgaGFuZGxpbmcgdGhpcyBiZWNhdXNlIEkgdGhpbmsgd2UndmUgbmV2ZXIgc2VlbiBpdFxuICAgICAgICAgaW4gdGhlIHdpbGQgZGVzcGl0ZSBydW5uaW5nIHZ1bG5lcmFibGUgY29kZSBmb3IgeWVhcnMuICopXG4gICAgICAoKiBXZSBoYXZlIHRvIHN0YXJ0IGJvdGggdGhyZWFkcyBiZWZvcmUgam9pbmluZyBhbnkgb2YgdGhlbS4gKilcbiAgICAgIGxldCBmaW5pc2hfc3Rkb3V0ID0gc3RhcnRfcmVhZGluZyBwcm9jZXNzX2luZm8uc3Rkb3V0IChJbmZvLm9mX3N0cmluZyBcInN0ZG91dFwiKSBpblxuICAgICAgbGV0IGZpbmlzaF9zdGRlcnIgPSBzdGFydF9yZWFkaW5nIHByb2Nlc3NfaW5mby5zdGRlcnIgKEluZm8ub2Zfc3RyaW5nIFwic3RkZXJyXCIpIGluXG4gICAgICBTdGFnZWQudW5zdGFnZSBmaW5pc2hfc3Rkb3V0ICgpLCBTdGFnZWQudW5zdGFnZSBmaW5pc2hfc3RkZXJyICgpXG4gICAgOztcblxuICAgIGxldCBvZl9leHRlcm5hbCB+d29ya2luZ19kaXIgfnBhdGhfdG9fZXhlIH5jaGlsZF9zdWJjb21tYW5kID1cbiAgICAgIGxldCBwcm9jZXNzX2luZm8gPVxuICAgICAgICBVbml4LmNyZWF0ZV9wcm9jZXNzX2VudlxuICAgICAgICAgICgpXG4gICAgICAgICAgfnByb2c6KGFic19wYXRoIH5kaXI6d29ya2luZ19kaXIgcGF0aF90b19leGUpXG4gICAgICAgICAgfmFyZ3M6Y2hpbGRfc3ViY29tbWFuZFxuICAgICAgICAgIH5lbnY6XG4gICAgICAgICAgICAobGV0IGhlbHBfc2V4cCA9XG4gICAgICAgICAgICAgICBzdXBwb3J0ZWRfdmVyc2lvbnMgfD4gU2V0LnNleHBfb2ZfbV9fdCAobW9kdWxlIEludCkgfD4gU2V4cC50b19zdHJpbmdcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIGBFeHRlbmQgWyBDT01NQU5EX09VVFBVVF9IRUxQX1NFWFAsIGhlbHBfc2V4cCBdKVxuICAgICAgaW5cbiAgICAgIFVuaXguY2xvc2UgcHJvY2Vzc19pbmZvLnN0ZGluO1xuICAgICAgbGV0IHN0ZG91dCwgc3RkZXJyID0gcmVhZF9zdGRvdXRfYW5kX3N0ZGVyciBwcm9jZXNzX2luZm8gaW5cbiAgICAgIFVuaXgud2FpdCBwcm9jZXNzX2luZm8ucGlkO1xuICAgICAgKCogTm93IHdlJ3ZlIGtpbGxlZCBhbGwgdGhlIHByb2Nlc3NlcyBhbmQgdGhyZWFkcyB3ZSBtYWRlLiAqKVxuICAgICAgbWF0Y2ggc3Rkb3V0IHw+IFNleHBsaWIuU2V4cC5vZl9zdHJpbmcgfD4gVmVyc2lvbmVkLnRfb2Zfc2V4cCB8PiBvZl92ZXJzaW9uZWQgd2l0aFxuICAgICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICAgIHJhaXNlX3NcbiAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgIFwiY2Fubm90IHBhcnNlIGNvbW1hbmQgc2hhcGVcIlxuICAgICAgICAgICAgICB+XzooZXhuIDogZXhuKVxuICAgICAgICAgICAgICAoc3Rkb3V0IDogc3RyaW5nKVxuICAgICAgICAgICAgICAoc3RkZXJyIDogc3RyaW5nKV1cbiAgICAgIHwgdCAtPiB0XG4gICAgOztcblxuICAgIGxldCByZWMgZmluZCAodCA6IHQpIH5wYXRoX3RvX3N1YmNvbW1hbmQgPVxuICAgICAgbWF0Y2ggcGF0aF90b19zdWJjb21tYW5kIHdpdGhcbiAgICAgIHwgW10gLT4gdFxuICAgICAgfCBzdWIgOjogc3VicyAtPlxuICAgICAgICBpZiBTdHJpbmcuaXNfcHJlZml4IHN1YiB+cHJlZml4OlwiLVwiXG4gICAgICAgIHRoZW4gdFxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgICB8IEJhc2UgXyAtPiBmYWlsd2l0aGYgXCJ1bmV4cGVjdGVkIHN1YmNvbW1hbmQgJVNcIiBzdWIgKClcbiAgICAgICAgICB8IExhenkgdGh1bmsgLT4gZmluZCAoTGF6eS5mb3JjZSB0aHVuaykgfnBhdGhfdG9fc3ViY29tbWFuZFxuICAgICAgICAgIHwgRXhlYyB7IHBhdGhfdG9fZXhlOyB3b3JraW5nX2RpcjsgY2hpbGRfc3ViY29tbWFuZDsgXyB9IC0+XG4gICAgICAgICAgICBmaW5kXG4gICAgICAgICAgICAgIChvZl9leHRlcm5hbCB+d29ya2luZ19kaXIgfnBhdGhfdG9fZXhlIH5jaGlsZF9zdWJjb21tYW5kKVxuICAgICAgICAgICAgICB+cGF0aF90b19zdWJjb21tYW5kOihzdWIgOjogKHN1YnMgQCBjaGlsZF9zdWJjb21tYW5kKSlcbiAgICAgICAgICB8IEdyb3VwIGcgLT5cbiAgICAgICAgICAgIChtYXRjaCBMaXN0LkFzc29jLmZpbmQgKExhenkuZm9yY2UgZy5zdWJjb21tYW5kcykgfmVxdWFsOlN0cmluZy5lcXVhbCBzdWIgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiBmYWlsd2l0aGYgXCJ1bmtub3duIHN1YmNvbW1hbmQgJVNcIiBzdWIgKClcbiAgICAgICAgICAgICB8IFNvbWUgdCAtPiBmaW5kIHQgfnBhdGhfdG9fc3ViY29tbWFuZDpzdWJzKSlcbiAgICA7O1xuICBlbmRcblxuICBsZXQgcHJveHlfb2ZfZXhlIH53b3JraW5nX2RpciBwYXRoX3RvX2V4ZSBjaGlsZF9zdWJjb21tYW5kID1cbiAgICBTZXhwYWJsZS5vZl9leHRlcm5hbCB+d29ya2luZ19kaXIgfnBhdGhfdG9fZXhlIH5jaGlsZF9zdWJjb21tYW5kXG4gICAgfD4gcHJveHlfb2Zfc2V4cGFibGVcbiAgICAgICAgIH53b3JraW5nX2RpclxuICAgICAgICAgfnBhdGhfdG9fZXhlXG4gICAgICAgICB+Y2hpbGRfc3ViY29tbWFuZFxuICAgICAgICAgfnBhdGhfdG9fc3ViY29tbWFuZDpbXVxuICA7O1xuXG4gIGxldCByZWMgc2hhcGVfb2ZfcHJveHkgcHJveHkgOiBTaGFwZS50ID0gc2hhcGVfb2ZfcHJveHlfa2luZCBwcm94eS5Qcm94eS5raW5kXG5cbiAgYW5kIHNoYXBlX29mX2V4ZSAoKSB+Y2hpbGRfc3ViY29tbWFuZCB+cGF0aF90b19leGUgfndvcmtpbmdfZGlyID1cbiAgICBzaGFwZV9vZl9wcm94eSAocHJveHlfb2ZfZXhlIH53b3JraW5nX2RpciBwYXRoX3RvX2V4ZSBjaGlsZF9zdWJjb21tYW5kKVxuXG4gIGFuZCBzaGFwZV9vZl9wcm94eV9raW5kIGtpbmQgPVxuICAgIG1hdGNoIGtpbmQgd2l0aFxuICAgIHwgQmFzZSBiIC0+IEJhc2ljIGJcbiAgICB8IExhenkgbCAtPiBMYXp5IChMYXp5Lm1hcCB+ZjpzaGFwZV9vZl9wcm94eV9raW5kIGwpXG4gICAgfCBHcm91cCBnIC0+XG4gICAgICBHcm91cFxuICAgICAgICB7IGcgd2l0aFxuICAgICAgICAgIHN1YmNvbW1hbmRzID0gTGF6eS5tYXAgZy5zdWJjb21tYW5kcyB+ZjooTGlzdC5Bc3NvYy5tYXAgfmY6c2hhcGVfb2ZfcHJveHkpXG4gICAgICAgIH1cbiAgICB8IEV4ZWMgKHsgY2hpbGRfc3ViY29tbWFuZDsgcGF0aF90b19leGU7IHdvcmtpbmdfZGlyOyBfIH0gYXMgZSkgLT5cbiAgICAgIEV4ZWMgKGUsIHNoYXBlX29mX2V4ZSB+Y2hpbGRfc3ViY29tbWFuZCB+cGF0aF90b19leGUgfndvcmtpbmdfZGlyKVxuICA7O1xuXG4gIGxldCByZWMgc2hhcGUgdCA6IFNoYXBlLnQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgQmFzZSBiIC0+IEJhc2ljIChDb21tYW5kX2Jhc2Uuc2hhcGUgYilcbiAgICB8IEdyb3VwIGcgLT4gR3JvdXAgKEdyb3VwLnNoYXBlIH5zdWJjb21tYW5kX3RvX3NoYXBlOnNoYXBlIGcpXG4gICAgfCBFeGVjICh7IEV4ZWMuY2hpbGRfc3ViY29tbWFuZDsgcGF0aF90b19leGU7IHdvcmtpbmdfZGlyOyBfIH0gYXMgZSkgLT5cbiAgICAgIEV4ZWMgKEV4ZWMuc2hhcGUgZSwgc2hhcGVfb2ZfZXhlIH5jaGlsZF9zdWJjb21tYW5kIH5wYXRoX3RvX2V4ZSB+d29ya2luZ19kaXIpXG4gICAgfCBMYXp5IHRodW5rIC0+IHNoYXBlIChMYXp5LmZvcmNlIHRodW5rKVxuICA7O1xuXG4gIGxldCBnYXRoZXJfaGVscCB+cmVjdXJzaXZlIH5mbGFncyB+ZXhwYW5kX2RvdHMgc2hhcGUgPVxuICAgIGxldCByZWMgbG9vcCBwYXRoIGFjYyBzaGFwZSA9XG4gICAgICBsZXQgc3RyaW5nX29mX3BhdGggPSBpZiBleHBhbmRfZG90cyB0aGVuIFBhdGgudG9fc3RyaW5nIGVsc2UgUGF0aC50b19zdHJpbmdfZG90cyBpblxuICAgICAgbGV0IGdhdGhlcl9ncm91cCBwYXRoIGFjYyBzdWJjb21tYW5kcyA9XG4gICAgICAgIGxldCBmaWx0ZXJlZF9zdWJjb21tYW5kcyA9XG4gICAgICAgICAgKCogT25seSBzaG93IHRoZSBbaGVscF0gc3ViY29tbWFuZCBhdCB0b3AtbGV2ZWwuICopXG4gICAgICAgICAgaWYgUGF0aC5pc19lbXB0eSBwYXRoXG4gICAgICAgICAgdGhlbiBzdWJjb21tYW5kc1xuICAgICAgICAgIGVsc2UgTGlzdC5Bc3NvYy5yZW1vdmUgfmVxdWFsOlN0cmluZy4oID0gKSBzdWJjb21tYW5kcyBcImhlbHBcIlxuICAgICAgICBpblxuICAgICAgICBmaWx0ZXJlZF9zdWJjb21tYW5kc1xuICAgICAgICB8PiBMaXN0LnN0YWJsZV9zb3J0IH5jb21wYXJlOihmdW4gYSBiIC0+IGhlbHBfc2NyZWVuX2NvbXBhcmUgKGZzdCBhKSAoZnN0IGIpKVxuICAgICAgICB8PiBMaXN0LmZvbGQgfmluaXQ6YWNjIH5mOihmdW4gYWNjIChzdWJjb21tYW5kLCBzaGFwZSkgLT5cbiAgICAgICAgICAgICBsZXQgcGF0aCA9IFBhdGguYXBwZW5kIHBhdGggfnN1YmNvbW1hbmQgaW5cbiAgICAgICAgICAgICBsZXQgbmFtZSA9IHN0cmluZ19vZl9wYXRoIHBhdGggaW5cbiAgICAgICAgICAgICBsZXQgZG9jID0gU2hhcGUuZ2V0X3N1bW1hcnkgc2hhcGUgaW5cbiAgICAgICAgICAgICBsZXQgYWNjID0geyBTaGFwZS5GbGFnX2luZm8ubmFtZTsgZG9jOyBhbGlhc2VzID0gW10gfSA6OiBhY2MgaW5cbiAgICAgICAgICAgICBpZiByZWN1cnNpdmUgdGhlbiBsb29wIHBhdGggYWNjIHNoYXBlIGVsc2UgYWNjKVxuICAgICAgaW5cbiAgICAgIG1hdGNoIHNoYXBlIHdpdGhcbiAgICAgIHwgRXhlYyAoXywgc2hhcGUpIC0+XG4gICAgICAgICgqIElmIHRoZSBleGVjdXRhYmxlIGJlaW5nIGNhbGxlZCBkb2Vzbid0IHVzZSBbQ29yZS5Db21tYW5kXSwgdGhlbiBzZXhwIGV4dHJhY3Rpb25cbiAgICAgICAgICAgd2lsbCBmYWlsLiAqKVxuICAgICAgICAodHJ5IGxvb3AgcGF0aCBhY2MgKHNoYXBlICgpKSB3aXRoXG4gICAgICAgICB8IF8gLT4gYWNjKVxuICAgICAgfCBHcm91cCBnIC0+IGdhdGhlcl9ncm91cCBwYXRoIGFjYyAoTGF6eS5mb3JjZSBnLnN1YmNvbW1hbmRzKVxuICAgICAgfCBCYXNpYyBiIC0+XG4gICAgICAgIGlmIGZsYWdzXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBiLmZsYWdzXG4gICAgICAgICAgfD4gTGlzdC5maWx0ZXIgfmY6KGZ1biBmbXQgLT4gU3RyaW5nLiggPD4gKSBmbXQubmFtZSBcIlstaGVscF1cIilcbiAgICAgICAgICB8PiBMaXN0LmZvbGQgfmluaXQ6YWNjIH5mOihmdW4gYWNjIGZtdCAtPlxuICAgICAgICAgICAgICAgbGV0IHBhdGggPSBQYXRoLmFwcGVuZCBwYXRoIH5zdWJjb21tYW5kOmZtdC5uYW1lIGluXG4gICAgICAgICAgICAgICBsZXQgZm10ID0geyBmbXQgd2l0aCBuYW1lID0gc3RyaW5nX29mX3BhdGggcGF0aCB9IGluXG4gICAgICAgICAgICAgICBmbXQgOjogYWNjKVxuICAgICAgICBlbHNlIGFjY1xuICAgICAgfCBMYXp5IHRodW5rIC0+IGxvb3AgcGF0aCBhY2MgKExhenkuZm9yY2UgdGh1bmspXG4gICAgaW5cbiAgICBsb29wIFBhdGguZW1wdHkgW10gc2hhcGUgfD4gTGlzdC5yZXZcbiAgOztcblxuICBsZXQgZ3JvdXBfb3JfZXhlY19oZWxwX3RleHQgfmZsYWdzIH5wYXRoIH5zdW1tYXJ5IH5yZWFkbWUgfmZvcm1hdF9saXN0ID1cbiAgICB1bnBhcmFncmFwaHNcbiAgICAgIChMaXN0LmZpbHRlcl9vcHRcbiAgICAgICAgIFsgU29tZSBzdW1tYXJ5XG4gICAgICAgICA7IFNvbWUgKFN0cmluZy5jb25jYXQgWyBcIiAgXCI7IFBhdGgudG9fc3RyaW5nIHBhdGg7IFwiIFNVQkNPTU1BTkRcIiBdKVxuICAgICAgICAgOyByZWFkbWVcbiAgICAgICAgIDsgU29tZSAoaWYgZmxhZ3MgdGhlbiBcIj09PSBzdWJjb21tYW5kcyBhbmQgZmxhZ3MgPT09XCIgZWxzZSBcIj09PSBzdWJjb21tYW5kcyA9PT1cIilcbiAgICAgICAgIDsgU29tZSAoU2hhcGUuRmxhZ19oZWxwX2Rpc3BsYXkudG9fc3RyaW5nIGZvcm1hdF9saXN0KVxuICAgICAgICAgXSlcbiAgOztcblxuICBsZXQgcmVjIGhlbHBfZm9yX3NoYXBlIHNoYXBlIHBhdGggfmV4cGFuZF9kb3RzIH5mbGFncyB+cmVjdXJzaXZlID1cbiAgICBsZXQgZm9ybWF0X2xpc3QgPSBnYXRoZXJfaGVscCB+ZXhwYW5kX2RvdHMgfmZsYWdzIH5yZWN1cnNpdmUgc2hhcGUgaW5cbiAgICBtYXRjaCBzaGFwZSB3aXRoXG4gICAgfCBCYXNpYyBiIC0+XG4gICAgICBsZXQgdXNhZ2UgPSBTaGFwZS5CYXNlX2luZm8uZ2V0X3VzYWdlIGIgaW5cbiAgICAgIHVucGFyYWdyYXBoc1xuICAgICAgICAoTGlzdC5maWx0ZXJfb3B0XG4gICAgICAgICAgIFsgU29tZSBiLnN1bW1hcnlcbiAgICAgICAgICAgOyBTb21lIChcIiAgXCIgXiBQYXRoLnRvX3N0cmluZyBwYXRoIF4gXCIgXCIgXiB1c2FnZSlcbiAgICAgICAgICAgOyBiLnJlYWRtZVxuICAgICAgICAgICA7IFNvbWUgXCI9PT0gZmxhZ3MgPT09XCJcbiAgICAgICAgICAgOyBTb21lIChTaGFwZS5GbGFnX2hlbHBfZGlzcGxheS50b19zdHJpbmcgYi5mbGFncylcbiAgICAgICAgICAgXSlcbiAgICB8IEdyb3VwIGcgLT5cbiAgICAgIGdyb3VwX29yX2V4ZWNfaGVscF90ZXh0XG4gICAgICAgIH5mbGFnc1xuICAgICAgICB+cGF0aFxuICAgICAgICB+cmVhZG1lOmcucmVhZG1lXG4gICAgICAgIH5zdW1tYXJ5Omcuc3VtbWFyeVxuICAgICAgICB+Zm9ybWF0X2xpc3RcbiAgICB8IEV4ZWMgKGUsIF8pIC0+XG4gICAgICBncm91cF9vcl9leGVjX2hlbHBfdGV4dFxuICAgICAgICB+ZmxhZ3NcbiAgICAgICAgfnBhdGhcbiAgICAgICAgfnJlYWRtZTplLnJlYWRtZVxuICAgICAgICB+c3VtbWFyeTplLnN1bW1hcnlcbiAgICAgICAgfmZvcm1hdF9saXN0XG4gICAgfCBMYXp5IHRodW5rIC0+IGhlbHBfZm9yX3NoYXBlIChMYXp5LmZvcmNlIHRodW5rKSBwYXRoIH5leHBhbmRfZG90cyB+ZmxhZ3MgfnJlY3Vyc2l2ZVxuICA7O1xuXG4gIGxldCBoZWxwX3N1YmNvbW1hbmQgfnN1bW1hcnkgfnJlYWRtZSA9XG4gICAgYmFzaWNcbiAgICAgIH5zdW1tYXJ5OlwiZXhwbGFpbiBhIGdpdmVuIHN1YmNvbW1hbmQgKHBlcmhhcHMgcmVjdXJzaXZlbHkpXCJcbiAgICAgIENvbW1hbmRfYmFzZS5QYXJhbS4oXG4gICAgICAgIHJldHVybiAoZnVuIHJlY3Vyc2l2ZSBmbGFncyBleHBhbmRfZG90cyBwYXRoIChlbnYgOiBFbnYudCkgY21kX29wdCAoKSAtPlxuICAgICAgICAgIGxldCBzdWJzID1cbiAgICAgICAgICAgIG1hdGNoIEVudi5maW5kIGVudiBzdWJzX2tleSB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgc3VicyAtPiBzdWJzXG4gICAgICAgICAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICAoKiBtYWludGFpbmVkIGJ5IFtkaXNwYXRjaF0gKilcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBwYXRoID1cbiAgICAgICAgICAgIGxldCBwYXRoID0gUGF0aC5wb3BfaGVscCBwYXRoIGluXG4gICAgICAgICAgICBPcHRpb24uZm9sZCBjbWRfb3B0IH5pbml0OnBhdGggfmY6KGZ1biBwYXRoIHN1YmNvbW1hbmQgLT5cbiAgICAgICAgICAgICAgUGF0aC5hcHBlbmQgcGF0aCB+c3ViY29tbWFuZClcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBwYXRoLCBzaGFwZSA9XG4gICAgICAgICAgICBtYXRjaCBjbWRfb3B0IHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICBsZXQgc3ViY29tbWFuZHMgPSBMaXN0LkFzc29jLm1hcCBzdWJzIH5mOnNoYXBlIHw+IExhenkuZnJvbV92YWwgaW5cbiAgICAgICAgICAgICAgbGV0IHJlYWRtZSA9IE9wdGlvbi5tYXAgcmVhZG1lIH5mOihmdW4gcmVhZG1lIC0+IHJlYWRtZSAoKSkgaW5cbiAgICAgICAgICAgICAgcGF0aCwgU2hhcGUuR3JvdXAgeyByZWFkbWU7IHN1bW1hcnk7IHN1YmNvbW1hbmRzIH1cbiAgICAgICAgICAgIHwgU29tZSBjbWQgLT5cbiAgICAgICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICAgICAgIGxvb2t1cF9leHBhbmRcbiAgICAgICAgICAgICAgICAgICAoTGlzdC5Bc3NvYy5tYXAgc3VicyB+ZjooZnVuIHggLT4geCwgYFByZWZpeCkpXG4gICAgICAgICAgICAgICAgICAgY21kXG4gICAgICAgICAgICAgICAgICAgU3ViY29tbWFuZFxuICAgICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgICAgfCBFcnJvciBlIC0+XG4gICAgICAgICAgICAgICAgIGRpZVxuICAgICAgICAgICAgICAgICAgIFwidW5rbm93biBzdWJjb21tYW5kICVzIGZvciBjb21tYW5kICVzOiAlc1wiXG4gICAgICAgICAgICAgICAgICAgY21kXG4gICAgICAgICAgICAgICAgICAgKFBhdGgudG9fc3RyaW5nIHBhdGgpXG4gICAgICAgICAgICAgICAgICAgZVxuICAgICAgICAgICAgICAgICAgICgpXG4gICAgICAgICAgICAgICB8IE9rIChwb3NzaWJseV9leHBhbmRlZF9uYW1lLCB0KSAtPlxuICAgICAgICAgICAgICAgICAoKiBGaXggdGhlIHVuZXhwYW5kZWQgdmFsdWUgKilcbiAgICAgICAgICAgICAgICAgbGV0IHBhdGggPVxuICAgICAgICAgICAgICAgICAgIFBhdGgucmVwbGFjZV9maXJzdCB+ZnJvbTpjbWQgfnRvXzpwb3NzaWJseV9leHBhbmRlZF9uYW1lIHBhdGhcbiAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgcGF0aCwgc2hhcGUgdClcbiAgICAgICAgICBpblxuICAgICAgICAgIHByaW50X2VuZGxpbmUgKGhlbHBfZm9yX3NoYXBlIHNoYXBlIHBhdGggfnJlY3Vyc2l2ZSB+ZmxhZ3MgfmV4cGFuZF9kb3RzKSlcbiAgICAgICAgPCo+IGZsYWcgXCItcmVjdXJzaXZlXCIgbm9fYXJnIH5kb2M6XCIgc2hvdyBzdWJjb21tYW5kcyBvZiBzdWJjb21tYW5kcywgZXRjLlwiXG4gICAgICAgIDwqPiBmbGFnIFwiLWZsYWdzXCIgbm9fYXJnIH5kb2M6XCIgc2hvdyBmbGFncyBhcyB3ZWxsIGluIHJlY3Vyc2l2ZSBoZWxwXCJcbiAgICAgICAgPCo+IGZsYWcgXCItZXhwYW5kLWRvdHNcIiBub19hcmcgfmRvYzpcIiBleHBhbmQgc3ViY29tbWFuZHMgaW4gcmVjdXJzaXZlIGhlbHBcIlxuICAgICAgICA8Kj4gcGF0aFxuICAgICAgICA8Kj4gZW52XG4gICAgICAgIDwqPiBhbm9uIChtYXliZSAoXCJTVUJDT01NQU5EXCIgJTogc3RyaW5nKSkpXG4gIDs7XG5cbiAgbGV0IGR1bXBfYXV0b2NvbXBsZXRlX2Z1bmN0aW9uICgpID1cbiAgICBhdXRvY29tcGxldGVfZnVuY3Rpb24gfmFyZ3ZfMDpTdGRsaWIuU3lzLmFyZ3YuKDApIH5waWQ6KFVuaXguZ2V0cGlkICgpIHw+IFBpZC50b19pbnQpXG4gICAgfD4gcHJpbnRmIFwiJXNcIlxuICA7O1xuXG4gIGxldCBkdW1wX2hlbHBfc2V4cCB+c3VwcG9ydGVkX3ZlcnNpb25zIHQgfnBhdGhfdG9fc3ViY29tbWFuZCA9XG4gICAgU2V0LmludGVyIFNleHBhYmxlLnN1cHBvcnRlZF92ZXJzaW9ucyBzdXBwb3J0ZWRfdmVyc2lvbnNcbiAgICB8PiBTZXQubWF4X2VsdFxuICAgIHw+IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+XG4gICAgICBFcnJvci5jcmVhdGVcbiAgICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgICBcIkNvdWxkbid0IGNob29zZSBhIHN1cHBvcnRlZCBoZWxwIG91dHB1dCB2ZXJzaW9uIGZvciBDb21tYW5kLmV4ZWMgZnJvbSB0aGUgZ2l2ZW4gXFxcbiAgICAgICAgIHN1cHBvcnRlZCB2ZXJzaW9ucy5cIlxuICAgICAgICBTZXhwYWJsZS5zdXBwb3J0ZWRfdmVyc2lvbnNcbiAgICAgICAgKFNldC5zZXhwX29mX21fX3QgKG1vZHVsZSBJbnQpKVxuICAgICAgfD4gRXJyb3IucmFpc2VcbiAgICB8IFNvbWUgdmVyc2lvbl90b191c2UgLT5cbiAgICAgIHNleHBhYmxlX3NoYXBlIHRcbiAgICAgIHw+IFNleHBhYmxlLmZpbmQgfnBhdGhfdG9fc3ViY29tbWFuZFxuICAgICAgfD4gU2V4cGFibGUudG9fdmVyc2lvbmVkIH52ZXJzaW9uX3RvX3VzZVxuICAgICAgfD4gU2V4cGFibGUuVmVyc2lvbmVkLnNleHBfb2ZfdFxuICAgICAgfD4gU2V4cC50b19zdHJpbmdcbiAgICAgIHw+IHByaW50X3N0cmluZ1xuICA7O1xuXG4gIGxldCBoYW5kbGVfZW52aXJvbm1lbnQgdCB+YXJndiA9XG4gICAgbWF0Y2ggYXJndiB3aXRoXG4gICAgfCBbXSAtPiBmYWlsd2l0aCBcIm1pc3NpbmcgZXhlY3V0YWJsZSBuYW1lXCJcbiAgICB8IGNtZCA6OiBhcmdzIC0+XG4gICAgICBPcHRpb24uaXRlciAoZ2V0ZW52X2FuZF9jbGVhciBDT01NQU5EX09VVFBVVF9IRUxQX1NFWFApIH5mOihmdW4gdmVyc2lvbiAtPlxuICAgICAgICBsZXQgc3VwcG9ydGVkX3ZlcnNpb25zID1cbiAgICAgICAgICBTZXhwbGliLlNleHAub2Zfc3RyaW5nIHZlcnNpb24gfD4gU2V0Lm1fX3Rfb2Zfc2V4cCAobW9kdWxlIEludClcbiAgICAgICAgaW5cbiAgICAgICAgZHVtcF9oZWxwX3NleHAgfnN1cHBvcnRlZF92ZXJzaW9ucyB0IH5wYXRoX3RvX3N1YmNvbW1hbmQ6YXJncztcbiAgICAgICAgZXhpdCAwKTtcbiAgICAgIE9wdGlvbi5pdGVyIChnZXRlbnZfYW5kX2NsZWFyIENPTU1BTkRfT1VUUFVUX0lOU1RBTExBVElPTl9CQVNIKSB+ZjooZnVuIF8gLT5cbiAgICAgICAgZHVtcF9hdXRvY29tcGxldGVfZnVuY3Rpb24gKCk7XG4gICAgICAgIGV4aXQgMCk7XG4gICAgICBjbWQsIGFyZ3NcbiAgOztcblxuICBsZXQgcHJvY2Vzc19hcmdzIH5jbWQgfmFyZ3MgPVxuICAgIGxldCBtYXliZV9jb21wX2N3b3JkID0gbWF5YmVfY29tcF9jd29yZCAoKSBpblxuICAgIGxldCBhcmdzID1cbiAgICAgIG1hdGNoIG1heWJlX2NvbXBfY3dvcmQgd2l0aFxuICAgICAgfCBOb25lIC0+IENtZGxpbmUub2ZfbGlzdCBhcmdzXG4gICAgICB8IFNvbWUgY29tcF9jd29yZCAtPlxuICAgICAgICBsZXQgYXJncyA9IExpc3QudGFrZSAoYXJncyBAIFsgXCJcIiBdKSBjb21wX2N3b3JkIGluXG4gICAgICAgIExpc3QuZm9sZF9yaWdodCBhcmdzIH5pbml0OkNtZGxpbmUuTmlsIH5mOihmdW4gYXJnIGFyZ3MgLT5cbiAgICAgICAgICBtYXRjaCBhcmdzIHdpdGhcbiAgICAgICAgICB8IENtZGxpbmUuTmlsIC0+IENtZGxpbmUuQ29tcGxldGUgYXJnXG4gICAgICAgICAgfCBfIC0+IENtZGxpbmUuQ29ucyAoYXJnLCBhcmdzKSlcbiAgICBpblxuICAgIFBhdGguY3JlYXRlIH5wYXRoX3RvX2V4ZTpjbWQsIGFyZ3MsIG1heWJlX2NvbXBfY3dvcmRcbiAgOztcblxuICBtb2R1bGUgT25seV92YWxpZGF0ZV9wYXJzaW5nID0gc3RydWN0XG4gICAgbGV0IGZsYWcgYmFzZSA9XG4gICAgICBsZXQgbmFtZSA9IFwiLXZhbGlkYXRlLXBhcnNpbmdcIiBpblxuICAgICAgbGV0IGZsYWdzID0gYmFzZS5Db21tYW5kX2Jhc2UuZmxhZ3MgaW5cbiAgICAgIGxldCBmbGFncyA9XG4gICAgICAgIGV4dGVuZF9tYXBfZXhuXG4gICAgICAgICAgZmxhZ3NcbiAgICAgICAgICBLZXlfdHlwZS5GbGFnXG4gICAgICAgICAgfmtleTpuYW1lXG4gICAgICAgICAgeyBuYW1lXG4gICAgICAgICAgOyBhbGlhc2VzX2V4Y2x1ZGVkX2Zyb21faGVscCA9IFsgXCItLXZhbGlkYXRlLXBhcnNpbmdcIiBdXG4gICAgICAgICAgOyBhbGlhc2VzID0gW11cbiAgICAgICAgICA7IG51bV9vY2N1cnJlbmNlcyA9IEZsYWcuTnVtX29jY3VycmVuY2VzLmF0X21vc3Rfb25jZVxuICAgICAgICAgIDsgY2hlY2tfYXZhaWxhYmxlID0gaWdub3JlXG4gICAgICAgICAgOyBhY3Rpb24gPVxuICAgICAgICAgICAgICBOb19hcmcgKGZ1biBlbnYgLT4gRW52LnNldCB+a2V5OmtleV9pbnRlcm5hbF92YWxpZGF0ZV9wYXJzaW5nIH5kYXRhOigpIGVudilcbiAgICAgICAgICA7IGRvYyA9IFwiIHZhbGlkYXRlIGFyZ3VtZW50cyBhcmUgcGFyc2VkIGNvcnJlY3RseSBhbmQgZXhpdCBpbW1lZGlhdGVseVwiXG4gICAgICAgICAgOyBuYW1lX21hdGNoaW5nID0gYFByZWZpeFxuICAgICAgICAgIH1cbiAgICAgIGluXG4gICAgICB7IGJhc2Ugd2l0aCBmbGFncyB9XG4gICAgOztcblxuICAgIGxldCByZWMgYWRkID0gZnVuY3Rpb25cbiAgICAgIHwgQmFzZSBiYXNlIC0+IEJhc2UgKGZsYWcgYmFzZSlcbiAgICAgIHwgRXhlYyBfIGFzIHQgLT4gdFxuICAgICAgfCBHcm91cCB7IHN1bW1hcnk7IHJlYWRtZTsgc3ViY29tbWFuZHM7IGJvZHkgfSAtPlxuICAgICAgICBsZXQgc3ViY29tbWFuZHMgPVxuICAgICAgICAgIExhenkubWFwIHN1YmNvbW1hbmRzIH5mOihmdW4gc3ViY29tbWFuZHMgLT5cbiAgICAgICAgICAgIExpc3QubWFwIHN1YmNvbW1hbmRzIH5mOihmdW4gKG5hbWUsIGNvbW1hbmQpIC0+IG5hbWUsIGFkZCBjb21tYW5kKSlcbiAgICAgICAgaW5cbiAgICAgICAgR3JvdXAgeyBzdW1tYXJ5OyByZWFkbWU7IHN1YmNvbW1hbmRzOyBib2R5IH1cbiAgICAgIHwgTGF6eSB0aHVuayAtPiBMYXp5IChsYXp5IChhZGQgKExhenkuZm9yY2UgdGh1bmspKSlcbiAgICA7O1xuICBlbmRcblxuICBsZXQgcmVjIGFkZF9oZWxwX3N1YmNvbW1hbmRzID0gZnVuY3Rpb25cbiAgICB8IEJhc2UgXyBhcyB0IC0+IHRcbiAgICB8IEV4ZWMgXyBhcyB0IC0+IHRcbiAgICB8IEdyb3VwIHsgc3VtbWFyeTsgcmVhZG1lOyBzdWJjb21tYW5kczsgYm9keSB9IC0+XG4gICAgICBsZXQgc3ViY29tbWFuZHMgPVxuICAgICAgICBMYXp5Lm1hcCBzdWJjb21tYW5kcyB+ZjooZnVuIHN1YmNvbW1hbmRzIC0+XG4gICAgICAgICAgZXh0ZW5kX2FsaXN0X2V4blxuICAgICAgICAgICAgKExpc3QuQXNzb2MubWFwIHN1YmNvbW1hbmRzIH5mOmFkZF9oZWxwX3N1YmNvbW1hbmRzKVxuICAgICAgICAgICAgS2V5X3R5cGUuU3ViY29tbWFuZFxuICAgICAgICAgICAgfmtleTpcImhlbHBcIlxuICAgICAgICAgICAgKGhlbHBfc3ViY29tbWFuZCB+c3VtbWFyeSB+cmVhZG1lKSlcbiAgICAgIGluXG4gICAgICBHcm91cCB7IHN1bW1hcnk7IHJlYWRtZTsgc3ViY29tbWFuZHM7IGJvZHkgfVxuICAgIHwgTGF6eSB0aHVuayAtPiBMYXp5IChsYXp5IChhZGRfaGVscF9zdWJjb21tYW5kcyAoTGF6eS5mb3JjZSB0aHVuaykpKVxuICA7O1xuXG4gIGxldCBtYXliZV9hcHBseV9leHRlbmQgYXJncyB+ZXh0ZW5kIH5wYXRoID1cbiAgICBPcHRpb24udmFsdWVfbWFwIGV4dGVuZCB+ZGVmYXVsdDphcmdzIH5mOihmdW4gZiAtPlxuICAgICAgQ21kbGluZS5leHRlbmQgYXJncyB+ZXh0ZW5kOmYgfnBhdGgpXG4gIDs7XG5cbiAgbGV0IHJlYyBkaXNwYXRjaFxuICAgIHRcbiAgICBlbnZcbiAgICB+ZXh0ZW5kXG4gICAgfnBhdGhcbiAgICB+YXJnc1xuICAgIH5tYXliZV9uZXdfY29tcF9jd29yZFxuICAgIH52ZXJzaW9uXG4gICAgfmJ1aWxkX2luZm9cbiAgICB+dmVyYm9zZV9vbl9wYXJzZV9lcnJvclxuICAgIH53aGVuX3BhcnNpbmdfc3VjY2VlZHNcbiAgICB+Y29tcGxldGVfc3ViY29tbWFuZHNcbiAgICA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBMYXp5IHRodW5rIC0+XG4gICAgICBsZXQgdCA9IExhenkuZm9yY2UgdGh1bmsgaW5cbiAgICAgIGRpc3BhdGNoXG4gICAgICAgIHRcbiAgICAgICAgZW52XG4gICAgICAgIH5leHRlbmRcbiAgICAgICAgfnBhdGhcbiAgICAgICAgfmFyZ3NcbiAgICAgICAgfm1heWJlX25ld19jb21wX2N3b3JkXG4gICAgICAgIH52ZXJzaW9uXG4gICAgICAgIH5idWlsZF9pbmZvXG4gICAgICAgIH52ZXJib3NlX29uX3BhcnNlX2Vycm9yXG4gICAgICAgIH53aGVuX3BhcnNpbmdfc3VjY2VlZHNcbiAgICAgICAgfmNvbXBsZXRlX3N1YmNvbW1hbmRzXG4gICAgfCBCYXNlIGJhc2UgLT5cbiAgICAgIGxldCBhcmdzID0gbWF5YmVfYXBwbHlfZXh0ZW5kIGFyZ3MgfmV4dGVuZCB+cGF0aCBpblxuICAgICAgbGV0IGhlbHBfdGV4dCA9XG4gICAgICAgIGxhenlcbiAgICAgICAgICAoaGVscF9mb3Jfc2hhcGUgKHNoYXBlIHQpIHBhdGggfnJlY3Vyc2l2ZTpmYWxzZSB+ZmxhZ3M6dHJ1ZSB+ZXhwYW5kX2RvdHM6ZmFsc2UpXG4gICAgICBpblxuICAgICAgQ29tbWFuZF9iYXNlLnJ1blxuICAgICAgICBiYXNlXG4gICAgICAgIGVudlxuICAgICAgICB+cGF0aFxuICAgICAgICB+YXJnc1xuICAgICAgICB+dmVyYm9zZV9vbl9wYXJzZV9lcnJvclxuICAgICAgICB+aGVscF90ZXh0XG4gICAgICAgIH53aGVuX3BhcnNpbmdfc3VjY2VlZHNcbiAgICAgICAgfm9uX2ZhaWx1cmU6Q29tbWFuZF9iYXNlLnJ1bl9leG5cbiAgICB8IEV4ZWMgZXhlYyAtPlxuICAgICAgbGV0IGFyZ3MgPSBDbWRsaW5lLnRvX2xpc3QgKG1heWJlX2FwcGx5X2V4dGVuZCBhcmdzIH5leHRlbmQgfnBhdGgpIGluXG4gICAgICBFeGVjLmV4ZWNfd2l0aF9hcmdzIH5hcmdzIGV4ZWMgfm1heWJlX25ld19jb21wX2N3b3JkXG4gICAgfCBHcm91cCAoeyBzdW1tYXJ5OyByZWFkbWU7IHN1YmNvbW1hbmRzID0gc3ViczsgYm9keSB9IGFzIGdyb3VwKSAtPlxuICAgICAgbGV0IGNvbXBsZXRpbmcgPSBDbWRsaW5lLmVuZHNfaW5fY29tcGxldGUgYXJncyBpblxuICAgICAgbGV0IGVudiA9IEVudi5zZXQgZW52IH5rZXk6c3Vic19rZXkgfmRhdGE6KExhenkuZm9yY2Ugc3VicykgaW5cbiAgICAgIGxldCBkaWVfc2hvd2luZ19oZWxwIG1zZyA9XG4gICAgICAgIGlmIGNvbXBsZXRpbmdcbiAgICAgICAgdGhlbiBleGl0IDBcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgZXByaW50ZlxuICAgICAgICAgICAgXCIlc1xcbiUhXCJcbiAgICAgICAgICAgIChoZWxwX2Zvcl9zaGFwZVxuICAgICAgICAgICAgICAgfnJlY3Vyc2l2ZTpmYWxzZVxuICAgICAgICAgICAgICAgfmZsYWdzOmZhbHNlXG4gICAgICAgICAgICAgICB+ZXhwYW5kX2RvdHM6ZmFsc2VcbiAgICAgICAgICAgICAgIChzaGFwZSAoR3JvdXAgeyBzdW1tYXJ5OyByZWFkbWU7IHN1YmNvbW1hbmRzID0gc3ViczsgYm9keSB9KSlcbiAgICAgICAgICAgICAgIHBhdGgpO1xuICAgICAgICAgIGRpZSBcIiVzXCIgbXNnICgpKVxuICAgICAgaW5cbiAgICAgIGxldCByZWMgcGFyc2VfZ3JvdXAgYXJncyB+bWF5YmVfbmV3X2NvbXBfY3dvcmQgPVxuICAgICAgICBsZXQgbWF5YmVfbmV3X2NvbXBfY3dvcmQgPSBPcHRpb24ubWFwIH5mOkludC5wcmVkIG1heWJlX25ld19jb21wX2N3b3JkIGluXG4gICAgICAgIGxldCBza2lwIHJlc3QgPSBwYXJzZV9ncm91cCByZXN0IH5tYXliZV9uZXdfY29tcF9jd29yZCBpblxuICAgICAgICBsZXQgcmVzb2x2ZSBzdWIgcmVzdCA9XG4gICAgICAgICAgbGV0IHN1YnMgPSBMaXN0LkFzc29jLm1hcCAoTGF6eS5mb3JjZSBzdWJzKSB+ZjooZnVuIHggLT4geCwgYFByZWZpeCkgaW5cbiAgICAgICAgICBtYXRjaCBsb29rdXBfZXhwYW5kIHN1YnMgc3ViIFN1YmNvbW1hbmQgd2l0aFxuICAgICAgICAgIHwgRXJyb3IgbXNnIC0+IGRpZV9zaG93aW5nX2hlbHAgbXNnXG4gICAgICAgICAgfCBPayAoc3ViLCB0KSAtPlxuICAgICAgICAgICAgZGlzcGF0Y2hcbiAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICBlbnZcbiAgICAgICAgICAgICAgfndoZW5fcGFyc2luZ19zdWNjZWVkc1xuICAgICAgICAgICAgICB+ZXh0ZW5kXG4gICAgICAgICAgICAgIH5wYXRoOihQYXRoLmFwcGVuZCBwYXRoIH5zdWJjb21tYW5kOnN1YilcbiAgICAgICAgICAgICAgfmFyZ3M6cmVzdFxuICAgICAgICAgICAgICB+bWF5YmVfbmV3X2NvbXBfY3dvcmRcbiAgICAgICAgICAgICAgfnZlcnNpb25cbiAgICAgICAgICAgICAgfmJ1aWxkX2luZm9cbiAgICAgICAgICAgICAgfnZlcmJvc2Vfb25fcGFyc2VfZXJyb3JcbiAgICAgICAgICAgICAgfmNvbXBsZXRlX3N1YmNvbW1hbmRzXG4gICAgICAgIGluXG4gICAgICAgIG1hdGNoIChhcmdzIDogQ21kbGluZS50KSB3aXRoXG4gICAgICAgIHwgTmlsIC0+XG4gICAgICAgICAgKG1hdGNoIGJvZHkgd2l0aFxuICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICBkaWVfc2hvd2luZ19oZWxwXG4gICAgICAgICAgICAgICAoc3ByaW50ZiBcIm1pc3Npbmcgc3ViY29tbWFuZCBmb3IgY29tbWFuZCAlc1wiIChQYXRoLnRvX3N0cmluZyBwYXRoKSlcbiAgICAgICAgICAgfCBTb21lIGJvZHkgLT4gYm9keSB+cGF0aDooUGF0aC5wYXJ0c19leGVfYmFzZW5hbWUgcGF0aCkpXG4gICAgICAgIHwgQ29ucyAoc3ViLCByZXN0KSAtPlxuICAgICAgICAgICgqIE1hdGNoIGZvciBmbGFncyByZWNvZ25pemVkIHdoZW4gc3ViY29tbWFuZHMgYXJlIGV4cGVjdGVkIG5leHQgKilcbiAgICAgICAgICAobWF0Y2ggc3ViIHdpdGhcbiAgICAgICAgICAgKCogUmVjb2duaXplZCBhdCB0aGUgdG9wIGxldmVsIGNvbW1hbmQgb25seSAqKVxuICAgICAgICAgICB8IChcIi12ZXJzaW9uXCIgfCBcIi0tdmVyc2lvblwiKSB3aGVuIFBhdGgubGVuZ3RoIHBhdGggPSAxIC0+XG4gICAgICAgICAgICAgaWYgY29tcGxldGluZ1xuICAgICAgICAgICAgIHRoZW4gc2tpcCByZXN0XG4gICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgICBWZXJzaW9uX2luZm8ucHJpbnRfdmVyc2lvbiB+dmVyc2lvbjtcbiAgICAgICAgICAgICAgIGV4aXQgMClcbiAgICAgICAgICAgfCAoXCItYnVpbGQtaW5mb1wiIHwgXCItLWJ1aWxkLWluZm9cIikgd2hlbiBQYXRoLmxlbmd0aCBwYXRoID0gMSAtPlxuICAgICAgICAgICAgIGlmIGNvbXBsZXRpbmdcbiAgICAgICAgICAgICB0aGVuIHNraXAgcmVzdFxuICAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICAgVmVyc2lvbl9pbmZvLnByaW50X2J1aWxkX2luZm8gfmJ1aWxkX2luZm87XG4gICAgICAgICAgICAgICBleGl0IDApXG4gICAgICAgICAgICgqIFJlY29nbml6ZWQgZXZlcnl3aGVyZSAqKVxuICAgICAgICAgICB8IFwiLWhlbHBcIiB8IFwiLS1oZWxwXCIgLT5cbiAgICAgICAgICAgICBpZiBjb21wbGV0aW5nXG4gICAgICAgICAgICAgdGhlbiBza2lwIHJlc3RcbiAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgIG1hdGNoIHJlc3Qgd2l0aFxuICAgICAgICAgICAgICAgfCBOaWwgfCBDb21wbGV0ZSAoXyA6IHN0cmluZykgLT5cbiAgICAgICAgICAgICAgICAgcHJpbnRfZW5kbGluZVxuICAgICAgICAgICAgICAgICAgIChoZWxwX2Zvcl9zaGFwZVxuICAgICAgICAgICAgICAgICAgICAgIH5yZWN1cnNpdmU6ZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICB+ZmxhZ3M6ZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICB+ZXhwYW5kX2RvdHM6ZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAoc2hhcGUgKEdyb3VwIHsgZ3JvdXAgd2l0aCBzdWJjb21tYW5kcyA9IHN1YnMgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgcGF0aCk7XG4gICAgICAgICAgICAgICAgIGV4aXQgMFxuICAgICAgICAgICAgICAgfCBDbWRsaW5lLkNvbnMgKGZpcnN0X29mX3Jlc3QsIHJlc3Rfb2ZfcmVzdCkgLT5cbiAgICAgICAgICAgICAgICAgcmVzb2x2ZSBmaXJzdF9vZl9yZXN0IChDb25zIChzdWIsIHJlc3Rfb2ZfcmVzdCkpKVxuICAgICAgICAgICB8IChfIDogc3RyaW5nKSAtPiByZXNvbHZlIHN1YiByZXN0KVxuICAgICAgICB8IENvbXBsZXRlIHBhcnQgLT5cbiAgICAgICAgICBsZXQgc3VicyA9XG4gICAgICAgICAgICBMYXp5LmZvcmNlIHN1YnNcbiAgICAgICAgICAgIHw+IExpc3QubWFwIH5mOmZzdFxuICAgICAgICAgICAgfD4gTGlzdC5maWx0ZXIgfmY6KGZ1biBuYW1lIC0+IFN0cmluZy5pc19wcmVmaXggbmFtZSB+cHJlZml4OnBhcnQpXG4gICAgICAgICAgICB8PiBMaXN0LnNvcnQgfmNvbXBhcmU6U3RyaW5nLmNvbXBhcmVcbiAgICAgICAgICBpblxuICAgICAgICAgIChtYXRjaCBjb21wbGV0ZV9zdWJjb21tYW5kcyB3aXRoXG4gICAgICAgICAgIHwgU29tZSBmIC0+XG4gICAgICAgICAgICAgbGV0IHN1YmNvbW1hbmRzID1cbiAgICAgICAgICAgICAgIHNoYXBlIHQgfD4gU2hhcGUuZnVsbHlfZm9yY2VkIHw+IFNoYXBlLkZ1bGx5X2ZvcmNlZC5leHBhbmRlZF9zdWJjb21tYW5kc1xuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgKG1hdGNoIGYgfnBhdGg6KFBhdGgucGFydHMgcGF0aCkgfnBhcnQgc3ViY29tbWFuZHMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gZXhpdCAxXG4gICAgICAgICAgICAgIHwgU29tZSB0b19vdXRwdXQgLT5cbiAgICAgICAgICAgICAgICBwcmludF9lbmRsaW5lIChTdHJpbmcuY29uY2F0IH5zZXA6XCIgXCIgdG9fb3V0cHV0KTtcbiAgICAgICAgICAgICAgICBleGl0IDApXG4gICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgIExpc3QuaXRlciBzdWJzIH5mOnByaW50X2VuZGxpbmU7XG4gICAgICAgICAgICAgZXhpdCAwKVxuICAgICAgaW5cbiAgICAgIHBhcnNlX2dyb3VwIGFyZ3Mgfm1heWJlX25ld19jb21wX2N3b3JkXG4gIDs7XG5cbiAgbGV0IHJ1blxuICAgID8oYWRkX3ZhbGlkYXRlX3BhcnNpbmdfZmxhZyA9IGZhbHNlKVxuICAgID92ZXJib3NlX29uX3BhcnNlX2Vycm9yXG4gICAgP3ZlcnNpb25cbiAgICA/YnVpbGRfaW5mb1xuICAgID8oYXJndiA9IEFycmF5LnRvX2xpc3QgU3RkbGliLlN5cy5hcmd2KVxuICAgID9leHRlbmRcbiAgICA/KHdoZW5fcGFyc2luZ19zdWNjZWVkcyA9IEZuLmlkKVxuICAgID9jb21wbGV0ZV9zdWJjb21tYW5kc1xuICAgIHRcbiAgICA9XG4gICAgbGV0IGJ1aWxkX2luZm8gPVxuICAgICAgbWF0Y2ggYnVpbGRfaW5mbyB3aXRoXG4gICAgICB8IFNvbWUgdiAtPiBsYXp5IHZcbiAgICAgIHwgTm9uZSAtPiBWZXJzaW9uX2luZm8uZGVmYXVsdF9idWlsZF9pbmZvXG4gICAgaW5cbiAgICBsZXQgdmVyc2lvbiA9XG4gICAgICBtYXRjaCB2ZXJzaW9uIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBWZXJzaW9uX2luZm8uZGVmYXVsdF92ZXJzaW9uXG4gICAgICB8IFNvbWUgdiAtPlxuICAgICAgICAoKiBbdmVyc2lvbl0gd2FzIHNwYWNlIGRlbGltaXRlZCBhdCBzb21lIHBvaW50IGFuZCBuZXdsaW5lIGRlbGltaXRlZFxuICAgICAgICAgICBhdCBhbm90aGVyLiAgV2UgYWx3YXlzIHByaW50IG9uZSAocmVwbywgcmV2aXNpb24pIHBhaXIgcGVyIGxpbmVcbiAgICAgICAgICAgYW5kIGVuc3VyZSBzb3J0ZWQgb3JkZXIgKilcbiAgICAgICAgbGF6eVxuICAgICAgICAgIChWZXJzaW9uX2luZm8ubm9ybWFsaXplX3ZlcnNpb25fbGluZXNcbiAgICAgICAgICAgICAoU3RyaW5nLnNwbGl0IHYgfm9uOicgJyB8PiBMaXN0LmNvbmNhdF9tYXAgfmY6KFN0cmluZy5zcGxpdCB+b246J1xcbicpKSlcbiAgICBpblxuICAgIEV4bi5oYW5kbGVfdW5jYXVnaHRfYW5kX2V4aXQgKGZ1biAoKSAtPlxuICAgICAgbGV0IHQgPSBWZXJzaW9uX2luZm8uYWRkIHQgfnZlcnNpb24gfmJ1aWxkX2luZm8gaW5cbiAgICAgIGxldCB0ID0gYWRkX2hlbHBfc3ViY29tbWFuZHMgdCBpblxuICAgICAgbGV0IHQgPSBpZiBhZGRfdmFsaWRhdGVfcGFyc2luZ19mbGFnIHRoZW4gT25seV92YWxpZGF0ZV9wYXJzaW5nLmFkZCB0IGVsc2UgdCBpblxuICAgICAgbGV0IGNtZCwgYXJncyA9IGhhbmRsZV9lbnZpcm9ubWVudCB0IH5hcmd2IGluXG4gICAgICBsZXQgcGF0aCwgYXJncywgbWF5YmVfbmV3X2NvbXBfY3dvcmQgPSBwcm9jZXNzX2FyZ3MgfmNtZCB+YXJncyBpblxuICAgICAgdHJ5XG4gICAgICAgIGRpc3BhdGNoXG4gICAgICAgICAgdFxuICAgICAgICAgIEVudi5lbXB0eVxuICAgICAgICAgIH5leHRlbmRcbiAgICAgICAgICB+cGF0aFxuICAgICAgICAgIH5hcmdzXG4gICAgICAgICAgfm1heWJlX25ld19jb21wX2N3b3JkXG4gICAgICAgICAgfnZlcnNpb25cbiAgICAgICAgICB+YnVpbGRfaW5mb1xuICAgICAgICAgIH52ZXJib3NlX29uX3BhcnNlX2Vycm9yXG4gICAgICAgICAgfndoZW5fcGFyc2luZ19zdWNjZWVkc1xuICAgICAgICAgIH5jb21wbGV0ZV9zdWJjb21tYW5kc1xuICAgICAgd2l0aFxuICAgICAgfCBGYWlsZWRfdG9fcGFyc2VfY29tbWFuZF9saW5lIG1zZyAtPlxuICAgICAgICBpZiBDbWRsaW5lLmVuZHNfaW5fY29tcGxldGUgYXJnc1xuICAgICAgICB0aGVuIGV4aXQgMFxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBwcmVycl9lbmRsaW5lIG1zZztcbiAgICAgICAgICBleGl0IDEpKVxuICA7O1xuXG4gIGxldCBkZXByZWNhdGVkX3J1biB0IH5jbWQgfmFyZ3MgfmlzX2hlbHAgfmlzX2hlbHBfcmVjIH5pc19oZWxwX3JlY19mbGFncyB+aXNfZXhwYW5kX2RvdHNcbiAgICA9XG4gICAgbGV0IHBhdGhfc3RyaW5ncyA9IFN0cmluZy5zcGxpdCBjbWQgfm9uOicgJyBpblxuICAgIGxldCBwYXRoID0gUGF0aC5vZl9wYXJ0cyBwYXRoX3N0cmluZ3MgaW5cbiAgICBsZXQgYXJncyA9IGlmIGlzX2V4cGFuZF9kb3RzIHRoZW4gXCItZXhwYW5kLWRvdHNcIiA6OiBhcmdzIGVsc2UgYXJncyBpblxuICAgIGxldCBhcmdzID0gaWYgaXNfaGVscF9yZWNfZmxhZ3MgdGhlbiBcIi1mbGFnc1wiIDo6IGFyZ3MgZWxzZSBhcmdzIGluXG4gICAgbGV0IGFyZ3MgPSBpZiBpc19oZWxwX3JlYyB0aGVuIFwiLXJcIiA6OiBhcmdzIGVsc2UgYXJncyBpblxuICAgIGxldCBhcmdzID0gaWYgaXNfaGVscCB0aGVuIFwiLWhlbHBcIiA6OiBhcmdzIGVsc2UgYXJncyBpblxuICAgIGxldCBhcmdzID0gQ21kbGluZS5vZl9saXN0IGFyZ3MgaW5cbiAgICBsZXQgdCA9IGFkZF9oZWxwX3N1YmNvbW1hbmRzIHQgaW5cbiAgICBkaXNwYXRjaFxuICAgICAgdFxuICAgICAgRW52LmVtcHR5XG4gICAgICB+cGF0aFxuICAgICAgfmFyZ3NcbiAgICAgIH5leHRlbmQ6Tm9uZVxuICAgICAgfm1heWJlX25ld19jb21wX2N3b3JkOk5vbmVcbiAgICAgIH52ZXJzaW9uOlZlcnNpb25faW5mby5kZWZhdWx0X3ZlcnNpb25cbiAgICAgIH5idWlsZF9pbmZvOlZlcnNpb25faW5mby5kZWZhdWx0X2J1aWxkX2luZm9cbiAgICAgIH52ZXJib3NlX29uX3BhcnNlX2Vycm9yOk5vbmVcbiAgICAgIH53aGVuX3BhcnNpbmdfc3VjY2VlZHM6Rm4uaWRcbiAgICAgIH5jb21wbGV0ZV9zdWJjb21tYW5kczpOb25lXG4gIDs7XG5lbmRcblxubW9kdWxlIFBhcmFtID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlICsnYSB0XG5cbiAgICBpbmNsdWRlIEFwcGxpY2F0aXZlLlMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgdmFsIGhlbHAgOiBzdHJpbmcgTGF6eS50IHRcbiAgICB2YWwgcGF0aCA6IHN0cmluZyBsaXN0IHRcbiAgICB2YWwgYXJncyA6IHN0cmluZyBsaXN0IHRcblxuICAgIHZhbCBmbGFnXG4gICAgICA6ICA/YWxpYXNlczpzdHJpbmcgbGlzdFxuICAgICAgLT4gP2Z1bGxfZmxhZ19yZXF1aXJlZDp1bml0XG4gICAgICAtPiBzdHJpbmdcbiAgICAgIC0+ICdhIEZsYWcudFxuICAgICAgLT4gZG9jOnN0cmluZ1xuICAgICAgLT4gJ2EgdFxuXG4gICAgdmFsIGZsYWdfb3B0aW9uYWxfd2l0aF9kZWZhdWx0X2RvY1xuICAgICAgOiAgP2FsaWFzZXM6c3RyaW5nIGxpc3RcbiAgICAgIC0+ID9mdWxsX2ZsYWdfcmVxdWlyZWQ6dW5pdFxuICAgICAgLT4gc3RyaW5nXG4gICAgICAtPiAnYSBBcmdfdHlwZS50XG4gICAgICAtPiAoJ2EgLT4gU2V4cC50KVxuICAgICAgLT4gZGVmYXVsdDonYVxuICAgICAgLT4gZG9jOnN0cmluZ1xuICAgICAgLT4gJ2EgdFxuXG4gICAgdmFsIGFub24gOiAnYSBBbm9ucy50IC0+ICdhIHRcbiAgICB2YWwgZXNjYXBlX2Fub24gOiBmaW5hbF9hbm9uOidhIEFub25zLnQgLT4gKCdhICogc3RyaW5nIGxpc3QpIHRcblxuICAgIG1vZHVsZSBJZl9ub3RoaW5nX2Nob3NlbiA6IHNpZ1xuICAgICAgdHlwZSAoXywgXykgdCA9XG4gICAgICAgIHwgRGVmYXVsdF90byA6ICdhIC0+ICgnYSwgJ2EpIHRcbiAgICAgICAgfCBSYWlzZSA6ICgnYSwgJ2EpIHRcbiAgICAgICAgfCBSZXR1cm5fbm9uZSA6ICgnYSwgJ2Egb3B0aW9uKSB0XG4gICAgZW5kXG5cbiAgICB2YWwgY2hvb3NlX29uZVxuICAgICAgOiAgJ2Egb3B0aW9uIHQgbGlzdFxuICAgICAgLT4gaWZfbm90aGluZ19jaG9zZW46KCdhLCAnYikgSWZfbm90aGluZ19jaG9zZW4udFxuICAgICAgLT4gJ2IgdFxuXG4gICAgdmFsIGNob29zZV9vbmVfbm9uX29wdGlvbmFsXG4gICAgICA6ICAnYSB0IGxpc3RcbiAgICAgIC0+IGlmX25vdGhpbmdfY2hvc2VuOignYSwgJ2IpIElmX25vdGhpbmdfY2hvc2VuLnRcbiAgICAgIC0+ICdiIHRcblxuICAgIHZhbCBhbmRfYXJnX25hbWVzIDogJ2EgdCAtPiAoJ2EgKiBzdHJpbmcgbGlzdCkgdFxuICAgIHZhbCBhbmRfYXJnX25hbWUgOiAnYSB0IC0+ICgnYSAqIHN0cmluZykgdFxuICAgIHZhbCBhcmdfbmFtZXMgOiAnYSB0IC0+IHN0cmluZyBsaXN0XG4gIGVuZFxuXG4gIGluY2x1ZGUgQ29tbWFuZF9iYXNlLlBhcmFtXG5cbiAgbGV0IHBhdGggPSBtYXAgfmY6UGF0aC5wYXJ0c19leGVfYmFzZW5hbWUgcGF0aFxuZW5kXG5cbm1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gIGluY2x1ZGUgUGFyYW1cblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgUGFyYW1cbiAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBQYXJhbVxuICBlbmRcbmVuZFxuXG50eXBlICdyZXN1bHQgYmFzaWNfY29tbWFuZCA9XG4gIHN1bW1hcnk6c3RyaW5nIC0+ID9yZWFkbWU6KHVuaXQgLT4gc3RyaW5nKSAtPiAodW5pdCAtPiAncmVzdWx0KSBQYXJhbS50IC0+IHRcblxubGV0IGJhc2ljIH5zdW1tYXJ5ID9yZWFkbWUgcGFyYW0gPVxuICBsZXQgcmVhZG1lID0gT3B0aW9uLm1hcCByZWFkbWUgfmY6KGZ1biBmICgpIC0+IFN0cmluZy5zdHJpcCAoZiAoKSkpIGluXG4gIGJhc2ljIH5zdW1tYXJ5ID9yZWFkbWUgcGFyYW1cbjs7XG5cbmxldCBiYXNpY19vcl9lcnJvciB+c3VtbWFyeSA/cmVhZG1lIHBhcmFtID1cbiAgYmFzaWNcbiAgICB+c3VtbWFyeVxuICAgID9yZWFkbWVcbiAgICAobGV0JW1hcCBydW4gPSBwYXJhbSBpblxuICAgICBmdW4gKCkgLT5cbiAgICAgICBtYXRjaCBydW4gKCkgd2l0aFxuICAgICAgIHwgT2sgKCkgLT4gKClcbiAgICAgICB8IEVycm9yIGUgLT5cbiAgICAgICAgIFN0ZGlvLnByZXJyX2VuZGxpbmUgKEVycm9yLnRvX3N0cmluZ19odW0gZSk7XG4gICAgICAgICBleGl0IDEpXG47O1xuXG5tb2R1bGUgRm9yX3RlbGVtZXRyeSA9IHN0cnVjdFxuICBsZXQgbm9ybWFsaXplZF9wYXRoICgpID0gT3B0aW9uLm1hcCAhQ29tbWFuZF9iYXNlLm5vcm1hbGl6ZWRfcGF0aCB+ZjpQYXRoLnBhcnRzXG4gIGxldCBub3JtYWxpemVkX2FyZ3MgKCkgPSAhQ29tbWFuZF9iYXNlLm5vcm1hbGl6ZWRfYXJnc1xuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBhYnNfcGF0aCA9IGFic19wYXRoXG4gIGxldCB3b3JkX3dyYXAgPSBTaGFwZS5Qcml2YXRlLndvcmRfd3JhcFxuXG4gIG1vZHVsZSBBbm9ucyA9IEFub25zXG4gIG1vZHVsZSBDbWRsaW5lID0gQ21kbGluZVxuICBtb2R1bGUgRm9yX3VuaXggPSBGb3JfdW5peFxuICBtb2R1bGUgUGF0aCA9IFBhdGhcblxuICBtb2R1bGUgU3BlYyA9IHN0cnVjdFxuICAgIGluY2x1ZGUgU3BlY1xuXG4gICAgbGV0IHRvX3N0cmluZ19mb3JfY2hvb3NlX29uZSBwYXJhbSA9XG4gICAgICBDb21tYW5kX2Jhc2UuUGFyYW0uQ2hvb3NlX29uZS5DaG9pY2VfbmFtZS4oY3JlYXRlX2V4biBwYXJhbSB8PiB0b19zdHJpbmcpXG4gICAgOztcbiAgZW5kXG5lbmRcblxubGV0IHJ1biA9IGBVc2VfQ29tbWFuZF91bml4XG5sZXQgc2hhcGUgPSBgVXNlX0NvbW1hbmRfdW5peFxuIl19
