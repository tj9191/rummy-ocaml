// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Stdio__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Stdio = [0], Stdio$0 = [0, Stdio];
   runtime.caml_register_global(0, Stdio$0, "Stdio__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdio__In_channel
//# unitInfo: Requires: Base__Buffer, Base__Char, Base__Exn, Base__List, Base__String, Stdlib, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    flags = [0, 0, 0],
    Base_List = global_data.Base__List,
    Stdlib = global_data.Stdlib,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Base_Buffer = global_data.Base__Buffer,
    Base_Exn = global_data.Base__Exn;
   function equal(t1, t2){return t1 === t2 ? 1 : 0;}
   var
    seek = Stdlib[96][4],
    pos = Stdlib[96][5],
    length = Stdlib[96][6],
    stdin = Stdlib[38];
   function create(opt, file){
    if(opt) var sth = opt[1], binary = sth; else var binary = 1;
    var flags$0 = binary ? [0, 6, flags] : flags;
    return caml_call3(Stdlib[81], flags$0, 0, file);
   }
   var close = Stdlib[93];
   function with_file(binary, file, f){
    var _i_ = create(binary, file);
    return caml_call3(Base_Exn[12], f, _i_, close);
   }
   function may_eof(f){
    try{var _g_ = [0, caml_call1(f, 0)]; return _g_;}
    catch(_h_){
     var _f_ = caml_wrap_exception(_h_);
     if(_f_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_f_, 0);
    }
   }
   function input(t, buf, pos, len){
    return caml_call4(Stdlib[84], t, buf, pos, len);
   }
   function really_input(t, buf, pos, len){
    return may_eof
            (function(param){return caml_call4(Stdlib[85], t, buf, pos, len);});
   }
   function really_input_exn(t, buf, pos, len){
    return caml_call4(Stdlib[85], t, buf, pos, len);
   }
   function input_byte(t){
    return may_eof(function(param){return caml_call1(Stdlib[87], t);});
   }
   function input_char(t){
    return may_eof(function(param){return caml_call1(Stdlib[82], t);});
   }
   function input_binary_int(t){
    return may_eof(function(param){return caml_call1(Stdlib[88], t);});
   }
   function unsafe_input_value(t){
    return may_eof(function(param){return caml_call1(Stdlib[89], t);});
   }
   function input_buffer(t, buf, len){
    return may_eof
            (function(param){
              return caml_call3(Stdlib_Buffer[22], buf, t, len);
             });
   }
   var set_binary_mode = Stdlib[95];
   function input_all(t){
    var buffer = caml_call1(Base_Buffer[2], 65536), chunk_size = 65536;
    try{for(;;) caml_call3(Stdlib_Buffer[22], buffer, t, chunk_size);}
    catch(_e_){
     var _d_ = caml_wrap_exception(_e_);
     if(_d_ === Stdlib[12]) return caml_call1(Base_Buffer[3], buffer);
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function trim(fix_win_eol, line){
    if(! fix_win_eol) return line;
    var len = runtime.caml_ml_string_length(line);
    if(0 < len){
     var _c_ = runtime.caml_string_get(line, len - 1 | 0);
     if(caml_call2(Base_Char[16], _c_, 13))
      return caml_call3(Base_String[3], line, 0, len - 1 | 0);
    }
    return line;
   }
   function input_line(opt, t){
    if(opt) var sth = opt[1], fix_win_eol = sth; else var fix_win_eol = 1;
    var match = may_eof(function(param){return caml_call1(Stdlib[83], t);});
    if(! match) return 0;
    var line = match[1];
    return [0, trim(fix_win_eol, line)];
   }
   function input_line_exn(opt, t){
    if(opt) var sth = opt[1], fix_win_eol = sth; else var fix_win_eol = 1;
    var line = caml_call1(Stdlib[83], t);
    return trim(fix_win_eol, line);
   }
   function fold_lines(fix_win_eol, t, init, f){
    var ac = init;
    for(;;){
     var match = input_line(fix_win_eol, t);
     if(! match) return ac;
     var line = match[1], ac$0 = caml_call2(f, ac, line), ac = ac$0;
    }
   }
   function input_lines(fix_win_eol, t){
    var
     _b_ =
       fold_lines
        (fix_win_eol, t, 0, function(lines, line){return [0, line, lines];});
    return caml_call1(Base_List[63], _b_);
   }
   function iter_lines(fix_win_eol, t, f){
    return fold_lines
            (fix_win_eol,
             t,
             0,
             function(param, line){return caml_call1(f, line);});
   }
   function read_lines(fix_win_eol, fname){
    return with_file
            (0, fname, function(_a_){return input_lines(fix_win_eol, _a_);});
   }
   function read_all(fname){return with_file(0, fname, input_all);}
   var
    Stdio_In_channel =
      [0,
       equal,
       stdin,
       create,
       with_file,
       close,
       input,
       really_input,
       really_input_exn,
       input_char,
       input_byte,
       input_binary_int,
       unsafe_input_value,
       input_buffer,
       input_all,
       input_line,
       input_line_exn,
       fold_lines,
       input_lines,
       iter_lines,
       seek,
       pos,
       length,
       set_binary_mode,
       read_lines,
       read_all];
   runtime.caml_register_global(8, Stdio_In_channel, "Stdio__In_channel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdio__Out_channel
//# unitInfo: Requires: Base, Base__Exn, Base__List, Stdlib, Stdlib__Buffer, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\n",
    flags = [0, 1, [0, 3, 0]],
    Base_Exn = global_data.Base__Exn,
    Base = global_data.Base,
    Base_List = global_data.Base__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Printf = global_data.Stdlib__Printf,
    _a_ = [0, "<stderr>"],
    _b_ = [0, "<stdout>"],
    _c_ = [0, "<Out_channel.t>"];
   function equal(t1, t2){return t1 === t2 ? 1 : 0;}
   var
    seek = Stdlib[96][1],
    pos = Stdlib[96][2],
    length = Stdlib[96][3],
    stdout = Stdlib[39],
    stderr = Stdlib[40];
   function sexp_of_t(t){
    return t === stderr ? _a_ : t === stdout ? _b_ : _c_;
   }
   function create(opt, _h_, _g_, _f_, file){
    if(opt) var sth = opt[1], binary = sth; else var binary = 1;
    if(_h_) var sth$0 = _h_[1], append = sth$0; else var append = 0;
    if(_g_)
     var sth$1 = _g_[1], fail_if_exists = sth$1;
    else
     var fail_if_exists = 0;
    if(_f_) var sth$2 = _f_[1], perm = sth$2; else var perm = 438;
    var
     _i_ = binary ? 6 : 7,
     flags$0 = [0, _i_, flags],
     _j_ = append ? 2 : 4,
     flags$1 = [0, _j_, flags$0],
     flags$2 = fail_if_exists ? [0, 5, flags$1] : flags$1;
    return caml_call3(Stdlib[62], flags$2, perm, file);
   }
   var
    set_binary_mode = Stdlib[78],
    flush = Stdlib[63],
    close = Stdlib[76],
    close_no_err = Stdlib[77];
   function output(t, buf, pos, len){
    return caml_call4(Stdlib[68], t, buf, pos, len);
   }
   function output_substring(t, buf, pos, len){
    return caml_call4(Stdlib[69], t, buf, pos, len);
   }
   var
    output_string = Stdlib[66],
    output_bytes = Stdlib[67],
    output_char = Stdlib[65],
    output_byte = Stdlib[70],
    output_binary_int = Stdlib[71],
    output_buffer = Stdlib_Buffer[10],
    output_value = Stdlib[72];
   function newline(t){return caml_call2(output_string, t, cst);}
   function output_line(t, line){
    caml_call2(output_string, t, line);
    return newline(t);
   }
   function output_lines(t, lines){
    function _e_(line){return output_line(t, line);}
    return caml_call2(Base_List[19], lines, _e_);
   }
   var
    printf = Stdlib_Printf[2],
    eprintf = Stdlib_Printf[3],
    fprintf = Stdlib_Printf[1],
    kfprintf = Stdlib_Printf[8],
    print_string = Stdlib[42],
    print_endline = Stdlib[46],
    prerr_endline = Stdlib[53];
   function fprint_s(mach, t, sexp){
    var
     string =
       mach
        ? caml_call1(Base[85][15], sexp)
        : caml_call2(Base[85][14], 0, sexp);
    caml_call2(output_string, t, string);
    caml_call2(output_char, t, 10);
    return caml_call1(flush, t);
   }
   function print_s(mach, sexp){return fprint_s(mach, stdout, sexp);}
   function eprint_s(mach, sexp){return fprint_s(mach, stderr, sexp);}
   function with_file(binary, append, fail_if_exists, perm, file, f){
    var _d_ = create(binary, append, fail_if_exists, perm, file);
    return caml_call3(Base_Exn[12], f, _d_, close);
   }
   function write_lines(file, lines){
    return with_file
            (0, 0, 0, 0, file, function(t){return output_lines(t, lines);});
   }
   function write_all(file, data){
    return with_file
            (0,
             0,
             0,
             0,
             file,
             function(t){return caml_call2(output_string, t, data);});
   }
   var
    Stdio_Out_channel =
      [0,
       sexp_of_t,
       equal,
       stdout,
       stderr,
       create,
       with_file,
       close,
       close_no_err,
       set_binary_mode,
       flush,
       output,
       output_string,
       output_substring,
       output_bytes,
       output_char,
       output_byte,
       output_binary_int,
       output_buffer,
       output_value,
       newline,
       output_lines,
       output_line,
       fprintf,
       printf,
       fprint_s,
       print_s,
       eprint_s,
       eprintf,
       kfprintf,
       print_string,
       print_endline,
       prerr_endline,
       seek,
       pos,
       length,
       write_lines,
       write_all];
   runtime.caml_register_global(11, Stdio_Out_channel, "Stdio__Out_channel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdio
//# unitInfo: Requires: Stdio__In_channel, Stdio__Out_channel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdio_In_channel = global_data.Stdio__In_channel,
    Stdio_Out_channel = global_data.Stdio__Out_channel,
    stdin = Stdio_In_channel[2],
    stdout = Stdio_Out_channel[3],
    stderr = Stdio_Out_channel[4],
    eprintf = Stdio_Out_channel[28],
    printf = Stdio_Out_channel[24],
    print_s = Stdio_Out_channel[26],
    eprint_s = Stdio_Out_channel[27],
    print_string = Stdio_Out_channel[30],
    print_endline = Stdio_Out_channel[31],
    prerr_endline = Stdio_Out_channel[32],
    Stdio =
      [0,
       stdin,
       stdout,
       stderr,
       printf,
       print_s,
       eprint_s,
       eprintf,
       print_string,
       print_endline,
       prerr_endline];
   runtime.caml_register_global(2, Stdio, "Stdio");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzdGRpby5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZmxhZ3MiLCJlcXVhbCIsInQxIiwidDIiLCJzZWVrIiwicG9zIiwibGVuZ3RoIiwic3RkaW4iLCJjcmVhdGUiLCJvcHQiLCJmaWxlIiwic3RoIiwiYmluYXJ5IiwiZmxhZ3MkMCIsImNsb3NlIiwid2l0aF9maWxlIiwiZiIsIm1heV9lb2YiLCJpbnB1dCIsInQiLCJidWYiLCJsZW4iLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfZXhuIiwiaW5wdXRfYnl0ZSIsImlucHV0X2NoYXIiLCJpbnB1dF9iaW5hcnlfaW50IiwidW5zYWZlX2lucHV0X3ZhbHVlIiwiaW5wdXRfYnVmZmVyIiwic2V0X2JpbmFyeV9tb2RlIiwiaW5wdXRfYWxsIiwiYnVmZmVyIiwiY2h1bmtfc2l6ZSIsInRyaW0iLCJmaXhfd2luX2VvbCIsImxpbmUiLCJpbnB1dF9saW5lIiwiaW5wdXRfbGluZV9leG4iLCJmb2xkX2xpbmVzIiwiaW5pdCIsImFjIiwiYWMkMCIsImlucHV0X2xpbmVzIiwibGluZXMiLCJpdGVyX2xpbmVzIiwicmVhZF9saW5lcyIsImZuYW1lIiwicmVhZF9hbGwiLCJzdGRvdXQiLCJzdGRlcnIiLCJzZXhwX29mX3QiLCJzdGgkMCIsImFwcGVuZCIsInN0aCQxIiwiZmFpbF9pZl9leGlzdHMiLCJzdGgkMiIsInBlcm0iLCJmbGFncyQxIiwiZmxhZ3MkMiIsImZsdXNoIiwiY2xvc2Vfbm9fZXJyIiwib3V0cHV0Iiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXRfYnl0ZXMiLCJvdXRwdXRfY2hhciIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2JpbmFyeV9pbnQiLCJvdXRwdXRfYnVmZmVyIiwib3V0cHV0X3ZhbHVlIiwibmV3bGluZSIsIm91dHB1dF9saW5lIiwib3V0cHV0X2xpbmVzIiwicHJpbnRmIiwiZXByaW50ZiIsImZwcmludGYiLCJrZnByaW50ZiIsInByaW50X3N0cmluZyIsInByaW50X2VuZGxpbmUiLCJwcmVycl9lbmRsaW5lIiwiZnByaW50X3MiLCJtYWNoIiwic2V4cCIsInN0cmluZyIsInByaW50X3MiLCJlcHJpbnRfcyIsIndyaXRlX2xpbmVzIiwid3JpdGVfYWxsIiwiZGF0YSJdLCJzb3VyY2VzIjpbIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9zdGRpby9zdGRpb19fLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL3N0ZGlvL2luX2NoYW5uZWwubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvc3RkaW8vb3V0X2NoYW5uZWwubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0FRaUIsdUNBQUE7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQ0dYQTs7Ozs7Ozs7WUFQRkMsTUFBT0MsSUFBUUMsSUFBSyxPQUFiRCxPQUFRQyxXQUFxQjs7SUFDcENDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBRUFDLE9BQVNDLEtBQWVDO0lBQzFCLEdBRFdELFNBQVNFLE1BQVRGLFFBQUFHLFNBQVNELGNBQVRDO0lBRVgsSUFBSUMsVUFGT0QsZ0JBQ1BaLFNBQUFBO0lBRUosT0FBQSx1QkFESWEsWUFGc0JIO0dBR1M7T0FHakNJO1lBQ0FDLFVBQVdILFFBQU9GLE1BQU1NO0lBQWlCLFVBUHpDUixPQU9XSSxRQUFPRjtvQ0FBTU0sUUFEeEJGO0dBQ2dGO1lBRWhGRyxRQUFRRDtJQUNWLElBQUksY0FBSyxXQURDQSxRQUNOOzs7NEJBQ2E7OztHQUFJO1lBR25CRSxNQUFNQyxHQUFHQyxLQUFLZixLQUFLZ0I7SUFBTSxPQUFBLHVCQUFuQkYsR0FBR0MsS0FBS2YsS0FBS2dCO0dBQWdDO1lBQ25EQyxhQUFhSCxHQUFHQyxLQUFLZixLQUFLZ0I7SUFBTSxPQU5oQ0o7NkJBTW1ELE9BQW5CLHVCQUFuQkUsR0FBR0MsS0FBS2YsS0FBS2dCLEtBQTBEO0dBQUM7WUFDckZFLGlCQUFpQkosR0FBR0Ms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RWVpQyxNQUFpQztZQUVoRG5FLFVBQVdILFFBQVF3QyxRQUFRRSxnQkFBZ0JFLE1BQUs5QyxNQUFNTTtJQUMzQyxVQTdEWFIsT0E0RFdJLFFBQVF3QyxRQUFRRSxnQkFBZ0JFLE1BQUs5QztvQ0FBTU0sUUE1Q3RERjtHQTZDZ0Y7WUFHaEZ3RSxZQUFZNUUsTUFBS2lDO0lBQVEsT0FKekI1Qjt5QkFJWUwsZUFBb0NTLEdBQUssT0E5QnJEcUQsYUE4QmdEckQsR0FBL0J3QixPQUF3RDtHQUFDO1lBQzFFNEMsVUFBVTdFLE1BQU04RTtJQUFPLE9BTHZCekU7Ozs7O2FBS1VMO3NCQUFvQ1MsR0FBSyxPQUE1QixXQTdDdkI0QyxlQTZDOEM1QyxHQUE5QnFFLE1BQXVEO0dBQUM7Ozs7T0E1RXhFdEM7T0FQQWpEO09BSUErQztPQUNBQztPQWFBekM7T0E0REFPO09BNUNBRDtPQUNBOEM7T0FIQS9CO09BQ0E4QjtPQUdBRTtPQUVBRTtPQURBRDtPQUVBRTtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQU9BRTtPQUxBRDtPQVFBSTtPQUZBRjtPQWNBTztPQVFBSTtPQUNBQztPQXRCQVg7T0FFQUU7T0FDQUM7T0FDQUM7T0FDQUM7T0ExREEzRTtPQUNBQztPQUNBQztPQStFQWdGO09BQ0FDOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgU3RkaW8uSW5fY2hhbm5lbCAqKVxubW9kdWxlIEluX2NoYW5uZWwgPSBTdGRpb19fSW5fY2hhbm5lbFxuXG4oKiogQGNhbm9uaWNhbCBTdGRpby5PdXRfY2hhbm5lbCAqKVxubW9kdWxlIE91dF9jaGFubmVsID0gU3RkaW9fX091dF9jaGFubmVsXG5cbm1vZHVsZSBTdGRpb19fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCJvcGVuISBCYXNlXG5cbnR5cGUgdCA9IFN0ZGxpYi5pbl9jaGFubmVsXG5cbmxldCBlcXVhbCAodDEgOiB0KSB0MiA9IHBoeXNfZXF1YWwgdDEgdDJcbmxldCBzZWVrID0gU3RkbGliLkxhcmdlRmlsZS5zZWVrX2luXG5sZXQgcG9zID0gU3RkbGliLkxhcmdlRmlsZS5wb3NfaW5cbmxldCBsZW5ndGggPSBTdGRsaWIuTGFyZ2VGaWxlLmluX2NoYW5uZWxfbGVuZ3RoXG5sZXQgc3RkaW4gPSBTdGRsaWIuc3RkaW5cblxubGV0IGNyZWF0ZSA/KGJpbmFyeSA9IHRydWUpIGZpbGUgPVxuICBsZXQgZmxhZ3MgPSBbIE9wZW5fcmRvbmx5IF0gaW5cbiAgbGV0IGZsYWdzID0gaWYgYmluYXJ5IHRoZW4gT3Blbl9iaW5hcnkgOjogZmxhZ3MgZWxzZSBmbGFncyBpblxuICBTdGRsaWIub3Blbl9pbl9nZW4gZmxhZ3MgMG8wMDAgZmlsZVxuOztcblxubGV0IGNsb3NlID0gU3RkbGliLmNsb3NlX2luXG5sZXQgd2l0aF9maWxlID9iaW5hcnkgZmlsZSB+ZiA9IEV4bi5wcm90ZWN0eCAoY3JlYXRlID9iaW5hcnkgZmlsZSkgfmYgfmZpbmFsbHk6Y2xvc2VcblxubGV0IG1heV9lb2YgZiA9XG4gIHRyeSBTb21lIChmICgpKSB3aXRoXG4gIHwgRW5kX29mX2ZpbGUgLT4gTm9uZVxuOztcblxubGV0IGlucHV0IHQgfmJ1ZiB+cG9zIH5sZW4gPSBTdGRsaWIuaW5wdXQgdCBidWYgcG9zIGxlblxubGV0IHJlYWxseV9pbnB1dCB0IH5idWYgfnBvcyB+bGVuID0gbWF5X2VvZiAoZnVuICgpIC0+IFN0ZGxpYi5yZWFsbHlfaW5wdXQgdCBidWYgcG9zIGxlbilcbmxldCByZWFsbHlfaW5wdXRfZXhuIHQgfmJ1ZiB+cG9zIH5sZW4gPSBTdGRsaWIucmVhbGx5X2lucHV0IHQgYnVmIHBvcyBsZW5cbmxldCBpbnB1dF9ieXRlIHQgPSBtYXlfZW9mIChmdW4gKCkgLT4gU3RkbGliLmlucHV0X2J5dGUgdClcbmxldCBpbnB1dF9jaGFyIHQgPSBtYXlfZW9mIChmdW4gKCkgLT4gU3RkbGliLmlucHV0X2NoYXIgdClcbmxldCBpbnB1dF9iaW5hcnlfaW50IHQgPSBtYXlfZW9mIChmdW4gKCkgLT4gU3RkbGliLmlucHV0X2JpbmFyeV9pbnQgdClcbmxldCB1bnNhZmVfaW5wdXRfdmFsdWUgdCA9IG1heV9lb2YgKGZ1biAoKSAtPiBTdGRsaWIuaW5wdXRfdmFsdWUgdClcbmxldCBpbnB1dF9idWZmZXIgdCBidWYgfmxlbiA9IG1heV9lb2YgKGZ1biAoKSAtPiBTdGRsaWIuQnVmZmVyLmFkZF9jaGFubmVsIGJ1ZiB0IGxlbilcbmxldCBzZXRfYmluYXJ5X21vZGUgPSBTdGRsaWIuc2V0X2JpbmFyeV9tb2RlX2luXG5cbmxldCBpbnB1dF9hbGwgdCA9XG4gICgqIFdlIHVzZSA2NTUzNiBiZWNhdXNlIHRoYXQgaXMgdGhlIHNpemUgb2YgT0NhbWwncyBJTyBidWZmZXJzLiAqKVxuICBsZXQgY2h1bmtfc2l6ZSA9IDY1NTM2IGluXG4gIGxldCBidWZmZXIgPSBCdWZmZXIuY3JlYXRlIGNodW5rX3NpemUgaW5cbiAgbGV0IHJlYyBsb29wICgpID1cbiAgICBTdGRsaWIuQnVmZmVyLmFkZF9jaGFubmVsIGJ1ZmZlciB0IGNodW5rX3NpemU7XG4gICAgbG9vcCAoKVxuICBpblxuICB0cnkgbG9vcCAoKSB3aXRoXG4gIHwgRW5kX29mX2ZpbGUgLT4gQnVmZmVyLmNvbnRlbnRzIGJ1ZmZlclxuOztcblxubGV0IHRyaW0gfmZpeF93aW5fZW9sIGxpbmUgPVxuICBpZiBmaXhfd2luX2VvbFxuICB0aGVuIChcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBsaW5lIGluXG4gICAgaWYgbGVuID4gMCAmJiBDaGFyLmVxdWFsIChTdHJpbmcuZ2V0IGxpbmUgKGxlbiAtIDEpKSAnXFxyJ1xuICAgIHRoZW4gU3RyaW5nLnN1YiBsaW5lIH5wb3M6MCB+bGVuOihsZW4gLSAxKVxuICAgIGVsc2UgbGluZSlcbiAgZWxzZSBsaW5lXG47O1xuXG5sZXQgaW5wdXRfbGluZSA/KGZpeF93aW5fZW9sID0gdHJ1ZSkgdCA9XG4gIG1hdGNoIG1heV9lb2YgKGZ1biAoKSAtPiBTdGRsaWIuaW5wdXRfbGluZSB0KSB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBsaW5lIC0+IFNvbWUgKHRyaW0gfmZpeF93aW5fZW9sIGxpbmUpXG47O1xuXG5sZXQgaW5wdXRfbGluZV9leG4gPyhmaXhfd2luX2VvbCA9IHRydWUpIHQgPVxuICBsZXQgbGluZSA9IFN0ZGxpYi5pbnB1dF9saW5lIHQgaW5cbiAgdHJpbSB+Zml4X3dpbl9lb2wgbGluZVxuOztcblxubGV0IGZvbGRfbGluZXMgP2ZpeF93aW5fZW9sIHQgfmluaXQgfmYgPVxuICBsZXQgcmVjIGxvb3AgYWMgPVxuICAgIG1hdGNoIGlucHV0X2xpbmUgP2ZpeF93aW5fZW9sIHQgd2l0aFxuICAgIHwgTm9uZSAtPiBhY1xuICAgIHwgU29tZSBsaW5lIC0+IGxvb3AgKGYgYWMgbGluZSlcbiAgaW5cbiAgbG9vcCBpbml0XG47O1xuXG5sZXQgaW5wdXRfbGluZXMgP2ZpeF93aW5fZW9sIHQgPVxuICBMaXN0LnJldiAoZm9sZF9saW5lcyA/Zml4X3dpbl9lb2wgdCB+aW5pdDpbXSB+ZjooZnVuIGxpbmVzIGxpbmUgLT4gbGluZSA6OiBsaW5lcykpXG47O1xuXG5sZXQgaXRlcl9saW5lcyA/Zml4X3dpbl9lb2wgdCB+ZiA9XG4gIGZvbGRfbGluZXMgP2ZpeF93aW5fZW9sIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSBsaW5lIC0+IGYgbGluZSlcbjs7XG5cbmxldCByZWFkX2xpbmVzID9maXhfd2luX2VvbCBmbmFtZSA9IHdpdGhfZmlsZSBmbmFtZSB+ZjooaW5wdXRfbGluZXMgP2ZpeF93aW5fZW9sKVxubGV0IHJlYWRfYWxsIGZuYW1lID0gd2l0aF9maWxlIGZuYW1lIH5mOmlucHV0X2FsbFxuIiwib3BlbiEgQmFzZVxuXG50eXBlIHQgPSBTdGRsaWIub3V0X2NoYW5uZWxcblxubGV0IGVxdWFsICh0MSA6IHQpIHQyID0gcGh5c19lcXVhbCB0MSB0MlxubGV0IHNlZWsgPSBTdGRsaWIuTGFyZ2VGaWxlLnNlZWtfb3V0XG5sZXQgcG9zID0gU3RkbGliLkxhcmdlRmlsZS5wb3Nfb3V0XG5sZXQgbGVuZ3RoID0gU3RkbGliLkxhcmdlRmlsZS5vdXRfY2hhbm5lbF9sZW5ndGhcbmxldCBzdGRvdXQgPSBTdGRsaWIuc3Rkb3V0XG5sZXQgc3RkZXJyID0gU3RkbGliLnN0ZGVyclxuXG5sZXQgc2V4cF9vZl90IHQgPVxuICBpZiBwaHlzX2VxdWFsIHQgc3RkZXJyXG4gIHRoZW4gU2V4cC5BdG9tIFwiPHN0ZGVycj5cIlxuICBlbHNlIGlmIHBoeXNfZXF1YWwgdCBzdGRvdXRcbiAgdGhlbiBTZXhwLkF0b20gXCI8c3Rkb3V0PlwiXG4gIGVsc2UgU2V4cC5BdG9tIFwiPE91dF9jaGFubmVsLnQ+XCJcbjs7XG5cbnR5cGUgJ2Egd2l0aF9jcmVhdGVfYXJncyA9XG4gID9iaW5hcnk6Ym9vbCAtPiA/YXBwZW5kOmJvb2wgLT4gP2ZhaWxfaWZfZXhpc3RzOmJvb2wgLT4gP3Blcm06aW50IC0+ICdhXG5cbmxldCBjcmVhdGVcbiAgPyhiaW5hcnkgPSB0cnVlKVxuICA/KGFwcGVuZCA9IGZhbHNlKVxuICA/KGZhaWxfaWZfZXhpc3RzID0gZmFsc2UpXG4gID8ocGVybSA9IDBvNjY2KVxuICBmaWxlXG4gID1cbiAgbGV0IGZsYWdzID0gWyBPcGVuX3dyb25seTsgT3Blbl9jcmVhdCBdIGluXG4gIGxldCBmbGFncyA9IChpZiBiaW5hcnkgdGhlbiBPcGVuX2JpbmFyeSBlbHNlIE9wZW5fdGV4dCkgOjogZmxhZ3MgaW5cbiAgbGV0IGZsYWdzID0gKGlmIGFwcGVuZCB0aGVuIE9wZW5fYXBwZW5kIGVsc2UgT3Blbl90cnVuYykgOjogZmxhZ3MgaW5cbiAgbGV0IGZsYWdzID0gaWYgZmFpbF9pZl9leGlzdHMgdGhlbiBPcGVuX2V4Y2wgOjogZmxhZ3MgZWxzZSBmbGFncyBpblxuICBTdGRsaWIub3Blbl9vdXRfZ2VuIGZsYWdzIHBlcm0gZmlsZVxuOztcblxubGV0IHNldF9iaW5hcnlfbW9kZSA9IFN0ZGxpYi5zZXRfYmluYXJ5X21vZGVfb3V0XG5sZXQgZmx1c2ggPSBTdGRsaWIuZmx1c2hcbmxldCBjbG9zZSA9IFN0ZGxpYi5jbG9zZV9vdXRcbmxldCBjbG9zZV9ub19lcnIgPSBTdGRsaWIuY2xvc2Vfb3V0X25vZXJyXG5sZXQgb3V0cHV0IHQgfmJ1ZiB+cG9zIH5sZW4gPSBTdGRsaWIub3V0cHV0IHQgYnVmIHBvcyBsZW5cbmxldCBvdXRwdXRfc3Vic3RyaW5nIHQgfmJ1ZiB+cG9zIH5sZW4gPSBTdGRsaWIub3V0cHV0X3N1YnN0cmluZyB0IGJ1ZiBwb3MgbGVuXG5sZXQgb3V0cHV0X3N0cmluZyA9IFN0ZGxpYi5vdXRwdXRfc3RyaW5nXG5sZXQgb3V0cHV0X2J5dGVzID0gU3RkbGliLm91dHB1dF9ieXRlc1xubGV0IG91dHB1dF9jaGFyID0gU3RkbGliLm91dHB1dF9jaGFyXG5sZXQgb3V0cHV0X2J5dGUgPSBTdGRsaWIub3V0cHV0X2J5dGVcbmxldCBvdXRwdXRfYmluYXJ5X2ludCA9IFN0ZGxpYi5vdXRwdXRfYmluYXJ5X2ludFxubGV0IG91dHB1dF9idWZmZXIgPSBTdGRsaWIuQnVmZmVyLm91dHB1dF9idWZmZXJcbmxldCBvdXRwdXRfdmFsdWUgPSBTdGRsaWIub3V0cHV0X3ZhbHVlXG5sZXQgbmV3bGluZSB0ID0gb3V0cHV0X3N0cmluZyB0IFwiXFxuXCJcblxubGV0IG91dHB1dF9saW5lIHQgbGluZSA9XG4gIG91dHB1dF9zdHJpbmcgdCBsaW5lO1xuICBuZXdsaW5lIHRcbjs7XG5cbmxldCBvdXRwdXRfbGluZXMgdCBsaW5lcyA9IExpc3QuaXRlciBsaW5lcyB+ZjooZnVuIGxpbmUgLT4gb3V0cHV0X2xpbmUgdCBsaW5lKVxubGV0IHByaW50ZiA9IFN0ZGxpYi5QcmludGYucHJpbnRmXG5sZXQgZXByaW50ZiA9IFN0ZGxpYi5QcmludGYuZXByaW50ZlxubGV0IGZwcmludGYgPSBTdGRsaWIuUHJpbnRmLmZwcmludGZcbmxldCBrZnByaW50ZiA9IFN0ZGxpYi5QcmludGYua2ZwcmludGZcbmxldCBwcmludF9zdHJpbmcgPSBTdGRsaWIucHJpbnRfc3RyaW5nXG5sZXQgcHJpbnRfZW5kbGluZSA9IFN0ZGxpYi5wcmludF9lbmRsaW5lXG5sZXQgcHJlcnJfZW5kbGluZSA9IFN0ZGxpYi5wcmVycl9lbmRsaW5lXG5cbmxldCBmcHJpbnRfZW5kbGluZSB0IHN0cmluZyA9XG4gIG91dHB1dF9zdHJpbmcgdCBzdHJpbmc7XG4gIG91dHB1dF9jaGFyIHQgJ1xcbic7XG4gIGZsdXNoIHRcbjs7XG5cbmxldCBmcHJpbnRfcyA/bWFjaCB0IHNleHAgPVxuICBmcHJpbnRfZW5kbGluZVxuICAgIHRcbiAgICAobWF0Y2ggbWFjaCB3aXRoXG4gICAgIHwgU29tZSAoKSAtPiBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHBcbiAgICAgfCBOb25lIC0+IFNleHAudG9fc3RyaW5nX2h1bSBzZXhwKVxuOztcblxubGV0IHByaW50X3MgP21hY2ggc2V4cCA9IGZwcmludF9zID9tYWNoIHN0ZG91dCBzZXhwXG5sZXQgZXByaW50X3MgP21hY2ggc2V4cCA9IGZwcmludF9zID9tYWNoIHN0ZGVyciBzZXhwXG5cbmxldCB3aXRoX2ZpbGUgP2JpbmFyeSA/YXBwZW5kID9mYWlsX2lmX2V4aXN0cyA/cGVybSBmaWxlIH5mID1cbiAgRXhuLnByb3RlY3R4IChjcmVhdGUgP2JpbmFyeSA/YXBwZW5kID9mYWlsX2lmX2V4aXN0cyA/cGVybSBmaWxlKSB+ZiB+ZmluYWxseTpjbG9zZVxuOztcblxubGV0IHdyaXRlX2xpbmVzIGZpbGUgbGluZXMgPSB3aXRoX2ZpbGUgZmlsZSB+ZjooZnVuIHQgLT4gb3V0cHV0X2xpbmVzIHQgbGluZXMpXG5sZXQgd3JpdGVfYWxsIGZpbGUgfmRhdGEgPSB3aXRoX2ZpbGUgZmlsZSB+ZjooZnVuIHQgLT4gb3V0cHV0X3N0cmluZyB0IGRhdGEpXG4iXX0=
