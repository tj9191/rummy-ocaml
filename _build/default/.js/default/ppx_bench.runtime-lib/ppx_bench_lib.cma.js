// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ppx_bench_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ppx_bench_lib = [0];
   runtime.caml_register_global(0, Ppx_bench_lib, "Ppx_bench_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_bench_lib__Export
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ppx_bench_lib_Export = [0];
   runtime.caml_register_global
    (0, Ppx_bench_lib_Export, "Ppx_bench_lib__Export");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_bench_lib__Benchmark_accumulator
//# unitInfo: Requires: Stdlib, Stdlib__Hashtbl, Stdlib__List, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_equal = runtime.caml_string_equal,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ".",
    null$0 = "<unknown>",
    cst$0 = "",
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    r = [0, 0],
    libname_ref = [0, null$0];
   function set(str){libname_ref[1] = str; return 0;}
   function unset(param){libname_ref[1] = null$0; return 0;}
   var t = [0, 0];
   function pop_exn(param){t[1] = caml_call1(Stdlib_List[7], t[1]); return 0;}
   function compare(t1, t2){return runtime.caml_int_compare(t1[1], t2[1]);}
   function get_module_name_opt(t){
    var str = t[3], len = runtime.caml_ml_string_length(str), i = 0;
    for(;;){
     if((i + 4 | 0) > len) return 0;
     if(caml_string_equal(caml_call3(Stdlib_String[16], str, i, 4), ".ml."))
      return [0,
              caml_call3
               (Stdlib_String[16], str, i + 4 | 0, (len - i | 0) - 4 | 0)];
     var i$0 = i + 1 | 0, i = i$0;
    }
   }
   function with_test_spec(t, test_spec){
    return [0,
            t[1],
            t[2],
            t[3],
            t[4],
            t[5],
            t[6],
            t[7],
            t[8],
            test_spec,
            t[10]];
   }
   try{var _d_ = caml_sys_getenv("BENCHMARKS_RUNNER"), v = _d_;}
   catch(_s_){
    var _a_ = caml_wrap_exception(_s_);
    if(_a_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a_, 0);
    var v = cst$0;
   }
   var
    add_environment_var = caml_string_equal(v, "TRUE"),
    libs_to_entries = caml_call2(Stdlib_Hashtbl[1], 0, 10);
   function lookup_rev_lib(libname){
    try{
     var _q_ = caml_call2(Stdlib_Hashtbl[6], libs_to_entries, libname);
     return _q_;
    }
    catch(_r_){
     var _p_ = caml_wrap_exception(_r_);
     if(_p_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_p_, 0);
    }
   }
   function lookup_lib(libname){
    var _o_ = lookup_rev_lib(libname);
    return caml_call1(Stdlib_List[10], _o_);
   }
   try{caml_sys_getenv("FORCE_DROP_BENCH"); var _c_ = 1, force_drop = _c_;}
   catch(_n_){
    var _b_ = caml_wrap_exception(_n_);
    if(_b_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b_, 0);
    var force_drop = 0;
   }
   function get_mode(param){return force_drop ? -950194894 : 984731018;}
   function add_bench
   (name, code, filename, type_conv_path, line, startpos, endpos, test_spec){
    if(984731018 > get_mode(0)) return 0;
    var libname = libname_ref[1], ms = t[1];
    if(ms)
     var
      _k_ = caml_call1(Stdlib_List[10], ms),
      _l_ = [0, caml_call2(Stdlib_String[7], cst, _k_)];
    else
     var _l_ = 0;
    r[1]++;
    var
     entry =
       [0,
        r[1],
        code,
        type_conv_path,
        name,
        filename,
        line,
        startpos,
        endpos,
        test_spec,
        _l_],
     _m_ = [0, entry, lookup_rev_lib(libname)];
    return caml_call3(Stdlib_Hashtbl[5], libs_to_entries, libname, _m_);
   }
   function add_bench_module(name, param, _i_, _h_, _g_, _f_, _e_, f){
    if(984731018 > get_mode(0)) return 0;
    t[1] = [0, name, t[1]];
    try{caml_call1(f, 0); var _j_ = pop_exn(0); return _j_;}
    catch(ex$0){
     var ex = caml_wrap_exception(ex$0);
     pop_exn(0);
     throw caml_maybe_attach_backtrace(ex, 0);
    }
   }
   var
    Ppx_bench_lib_Benchmark_accumu =
      [0,
       [0, set, unset],
       [0, with_test_spec, compare, get_module_name_opt],
       add_environment_var,
       lookup_lib,
       add_bench,
       add_bench_module];
   runtime.caml_register_global
    (11,
     Ppx_bench_lib_Benchmark_accumu,
     "Ppx_bench_lib__Benchmark_accumulator");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfYmVuY2hfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJudWxsJDAiLCJyIiwibGlibmFtZV9yZWYiLCJzZXQiLCJzdHIiLCJ1bnNldCIsInQiLCJwb3BfZXhuIiwiY29tcGFyZSIsInQxIiwidDIiLCJnZXRfbW9kdWxlX25hbWVfb3B0IiwibGVuIiwiaSIsImkkMCIsIndpdGhfdGVzdF9zcGVjIiwidGVzdF9zcGVjIiwidiIsImFkZF9lbnZpcm9ubWVudF92YXIiLCJsaWJzX3RvX2VudHJpZXMiLCJsb29rdXBfcmV2X2xpYiIsImxpYm5hbWUiLCJsb29rdXBfbGliIiwiZm9yY2VfZHJvcCIsImdldF9tb2RlIiwiYWRkX2JlbmNoIiwibmFtZSIsImNvZGUiLCJmaWxlbmFtZSIsInR5cGVfY29udl9wYXRoIiwibGluZSIsInN0YXJ0cG9zIiwiZW5kcG9zIiwibXMiLCJlbnRyeSIsImFkZF9iZW5jaF9tb2R1bGUiLCJmIiwiZXgkMCIsImV4Il0sInNvdXJjZXMiOlsiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL3BweF9iZW5jaC9ydW50aW1lLWxpYi9iZW5jaG1hcmtfYWNjdW11bGF0b3IubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHQUNVOzs7SUFTSkE7Ozs7OztJQVRBQztJQVVBQyxrQkFEQUY7WUFFQUcsSUFBSUMsS0FESkYsaUJBQ0lFLGNBQXdCO1lBQzVCQyxhQUZBSCxpQkFEQUYsaUJBRzhCO0dBSzFCLElBQUpNO1lBRUFDLGVBRkFELE9BRWtCLDJCQUZsQkEsZ0JBRTRCO1lBbUM1QkUsUUFBUUMsSUFBR0MsSUFBSyxnQ0FBUkQsT0FBR0MsT0FBc0M7WUFJakRDLG9CQUFvQkw7SUFDdEIsSUFBSUYsTUFEa0JFLE1BRWxCTSxNQUFKLDhCQURJUixNQUVTUztJQUNYO1NBRFdBLGFBRFRELEtBT0c7S0FIQSxHQUFBLGtCQUFBLDhCQUxIUixLQUVTUztNQUlKO2NBQUs7bUNBTlZULEtBRVNTLFlBRFRELE1BQ1NDO0tBS0osSUFMSUMsTUFBQUQsV0FBQUEsSUFBQUM7O0dBUVA7WUFHSkMsZUFBZVQsR0FBRVU7SUFBWTtZQUFkVjtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTtZQUFFVTtZQUFGVjtHQUFrQztPQVEvQyxJQUFBLE1BQUEsc0NBREZXOzs7O1FBQUFBOztHQUlKO0lBTEVDLHNCQUtGLGtCQUpJRDtJQVVGRSxrQkFBcUQ7WUFFckRDLGVBQWdCQztJQUNsQjtLQUFJLFVBQUEsOEJBSEZGLGlCQUVnQkU7S0FDZDs7OzsyQkFDVzs7O0dBQUU7WUFHZkMsV0FBWUQ7SUFBbUIsVUFML0JELGVBS1lDO0lBQW1CLE9BQUE7R0FBeUI7T0FNaEQscUNBQ1IsSUFBQSxTQUxBRTs7OztRQUFBQTs7WUFVQUMsZ0JBQWMsT0FWZEQsb0NBVXNEO1lBRXZDRTtJQUNoQkMsTUFDQUMsTUFDQUMsVUFDQUMsZ0JBQ0FDLE1BQ0FDLFVBQ0FDLFFBQ0RoQjtJQUVBLGVBWkVRLGFBYVc7UUFFUEgsVUFqSEZuQixnQkFjQStCLEtBUEEzQjtPQU9BMkI7S0FBOEI7TUFBQSxNQUFBLDRCQUE5QkE7Z0JBQVc7OztJQXhCWGhDO0lBNkhBO0tBREVpQzs7UUE1SEZqQztRQWdISDBCO1FBRUFFO1FBSEFIO1FBRUFFO1FBRUFFO1FBQ0FDO1FBQ0FDO1FBQ0RoQjs7S0FtQnNDLFVBYmhDa0IsT0FqQ0pkLGVBZ0NJQztJQWNnQyxPQUFBLDhCQWhEcENGLGlCQWtDSUU7R0Fja0U7WUFHdkRjLGlCQUNoQlQsc0NBT0RVO0lBRUEsZUExQ0VaLGFBMkNXO0lBdElUbEIsV0E0SEhvQixNQTVIR3BCO0lBeUlGLElBRUcsV0FSTDhCLE9BU0ssVUExSUQ3QixZQTBJQztVQUVBOEI7U0FBQUMseUJBQUFEO0tBNUlEOUI7S0E4SUMsTUFBQSw0QkFGQStCOztHQUVTOzs7O1dBdEpWbkMsS0FDQUU7V0E0REFVLGdCQWxCQVAsU0FJQUc7T0FvQkZPO09Ba0JBSTtPQWNlRztPQThCQVU7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsibGV0IHVuaXF1ZV9pZCA9XG4gIGxldCByID0gcmVmIDAgaW5cbiAgZnVuICgpIC0+XG4gICAgaW5jciByO1xuICAgICFyXG47O1xuXG4oKiBVc2VkIHRvIHRyYWNrIHRoZSBjdXJyZW50IGxpYm5hbWUgaW4gc3VjaCBhIHdheSB0aGF0IGZvciBmdW5jdG9yIGFwcGxpY2F0aW9ucywgaXQgaXNcbiAgIHRoZSBjYWxsaW5nIGxpYnJhcmllcyBuYW1lIHRoYXQgZ2V0cyByZWdpc3RlcmVkLiAqKVxubW9kdWxlIEN1cnJlbnRfbGlibmFtZSA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiPHVua25vd24+XCJcbiAgbGV0IGxpYm5hbWVfcmVmID0gcmVmIG51bGxcbiAgbGV0IHNldCBzdHIgPSBsaWJuYW1lX3JlZiA6PSBzdHJcbiAgbGV0IHVuc2V0ICgpID0gbGlibmFtZV9yZWYgOj0gbnVsbFxuICBsZXQgZ2V0ICgpID0gIWxpYm5hbWVfcmVmXG5lbmRcblxubW9kdWxlIEN1cnJlbnRfYmVuY2hfbW9kdWxlX3N0YWNrID0gc3RydWN0XG4gIGxldCB0ID0gcmVmIFtdXG4gIGxldCBwdXNoIHMgPSB0IDo9IHMgOjogIXRcbiAgbGV0IHBvcF9leG4gKCkgPSB0IDo9IExpc3QudGwgIXRcblxuICBsZXQgdG9fbmFtZSAoKSA9XG4gICAgbWF0Y2ggIXQgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgbXMgLT4gU29tZSAoU3RyaW5nLmNvbmNhdCBcIi5cIiAoTGlzdC5yZXYgbXMpKVxuICA7O1xuZW5kXG5cbigqIFRoaXMgaXMgdGhlIG1haW4gZGF0YSBzdHJ1Y3R1cmUgb2YgdGhpcyBtb2R1bGUuIEFuIFtFbnRyeS50XSByZXByZXNlbnRzIGEgYmVuY2htYXJrXG4gICBhbG9uZyB3aXRoIHNvbWUgbWV0YWRhdGEgYWJvdXQgaXMgcG9zaXRpb24sIGFyZ3VtZW50cyBldGMuICopXG5tb2R1bGUgRW50cnkgPSBzdHJ1Y3RcbiAgdHlwZSAoJ3BhcmFtLCAnYSkgcGFyYW1ldGVyaXNlZF9zcGVjID1cbiAgICB7IGFyZ19uYW1lIDogc3RyaW5nXG4gICAgOyBwYXJhbXMgOiAoc3RyaW5nICogJ3BhcmFtKSBsaXN0XG4gICAgOyB0aHVuayA6ICdwYXJhbSAtPiB1bml0IC0+ICdhXG4gICAgfVxuXG4gIHR5cGUgdGVzdF9zcGVjID1cbiAgICB8IFJlZ3VsYXJfdGh1bmsgOiAoWyBgaW5pdCBdIC0+IHVuaXQgLT4gJ2EpIC0+IHRlc3Rfc3BlY1xuICAgIHwgUGFyYW1ldGVyaXNlZF90aHVuayA6ICgncGFyYW0sICdhKSBwYXJhbWV0ZXJpc2VkX3NwZWMgLT4gdGVzdF9zcGVjXG5cbiAgdHlwZSB0ID1cbiAgICB7IHVuaXF1ZV9pZCA6IGludFxuICAgIDsgY29kZSA6IHN0cmluZ1xuICAgIDsgdHlwZV9jb252X3BhdGggOiBzdHJpbmdcbiAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICA7IGZpbGVuYW1lIDogc3RyaW5nXG4gICAgOyBsaW5lIDogaW50XG4gICAgOyBzdGFydHBvcyA6IGludFxuICAgIDsgZW5kcG9zIDogaW50XG4gICAgOyB0ZXN0X3NwZWMgOiB0ZXN0X3NwZWNcbiAgICA7IGJlbmNoX21vZHVsZV9uYW1lIDogc3RyaW5nIG9wdGlvblxuICAgIH1cblxuICBsZXQgY29tcGFyZSB0MSB0MiA9IGNvbXBhcmUgdDEudW5pcXVlX2lkIHQyLnVuaXF1ZV9pZFxuXG4gICgqIEV4dHJhY3RzIG1vZHVsZSBuYW1lIGZyb20gW1wiZmlsZW5hbWUubWwuTW9kdWxlXCJdLCB3aGljaCBpcyB0aGUgZm9ybWF0IG9mIFtleHRfbmFtZV1cbiAgICAgYXMgc2V0IGJ5IFt0eXBlY29udl0uICopXG4gIGxldCBnZXRfbW9kdWxlX25hbWVfb3B0IHQgPVxuICAgIGxldCBzdHIgPSB0LnR5cGVfY29udl9wYXRoIGluXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSArIDQgPD0gbGVuXG4gICAgICB0aGVuXG4gICAgICAgIGlmIFN0cmluZy5zdWIgc3RyIGkgNCA9IFwiLm1sLlwiXG4gICAgICAgIHRoZW4gU29tZSAoU3RyaW5nLnN1YiBzdHIgKGkgKyA0KSAobGVuIC0gaSAtIDQpKVxuICAgICAgICBlbHNlIGxvb3AgKGkgKyAxKVxuICAgICAgZWxzZSBOb25lXG4gICAgaW5cbiAgICBsb29wIDBcbiAgOztcblxuICBsZXQgd2l0aF90ZXN0X3NwZWMgdCB0ZXN0X3NwZWMgPSB7IHQgd2l0aCB0ZXN0X3NwZWMgfVxuZW5kXG5cbigqIEluc3BlY3Qgc3lzdGVtIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byBkZWNpZGUgaWYgYmVuY2htYXJrcyBhcmUgYmVpbmcgcnVuLiBUaGlzIGlzXG4gICBjYWxsZWQgYnkgdGhlIGNvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBbcGFfYmVuY2hdIHN5bnRheCB0byBkZWNpZGUgaWYgdGhlIGdsb2JhbCBoYXNodGFibGVcbiAgIHNob3VsZCBiZSBwb3B1bGF0ZWQuICopXG5sZXQgYWRkX2Vudmlyb25tZW50X3ZhciA9XG4gIGxldCB2ID1cbiAgICB0cnkgU3lzLmdldGVudiBcIkJFTkNITUFSS1NfUlVOTkVSXCIgd2l0aFxuICAgIHwgTm90X2ZvdW5kIC0+IFwiXCJcbiAgaW5cbiAgdiA9IFwiVFJVRVwiXG47O1xuXG4oKiBUaGlzIGhhc2h0YWJsZSBjb250YWlucyBhbGwgdGhlIGJlbmNobWFya3MgZnJvbSBhbGwgdGhlIG9mIGxpYnJhcmllcyB0aGF0IGhhdmUgYmVlblxuICAgbG9hZGVkLiBBdCB0aGUgdGltZSB0aGUgYmVuY2htYXJrcyBhcmUgcmVnaXN0ZXJpbmcgdGhlbXNlbHZlcyB3aXRoIFtwcHhfYmVuY2hfbGliXSB3ZVxuICAgZG9uJ3QgeWV0IGtub3cgd2hpY2ggbGlicmFyaWVzIHdpbGwgbmVlZCB0byBiZSBydW4uICAqKVxubGV0IGxpYnNfdG9fZW50cmllcyA6IChzdHJpbmcsIEVudHJ5LnQgbGlzdCkgSGFzaHRibC50ID0gSGFzaHRibC5jcmVhdGUgMTBcblxubGV0IGxvb2t1cF9yZXZfbGliIH5saWJuYW1lID1cbiAgdHJ5IEhhc2h0YmwuZmluZCBsaWJzX3RvX2VudHJpZXMgbGlibmFtZSB3aXRoXG4gIHwgTm90X2ZvdW5kIC0+IFtdXG47O1xuXG5sZXQgbG9va3VwX2xpYiB+bGlibmFtZSA9IExpc3QucmV2IChsb29rdXBfcmV2X2xpYiB+bGlibmFtZSlcblxubGV0IGZvcmNlX2Ryb3AgPVxuICAoKiBVc2VmdWwgZm9yIGpzX29mX29jYW1sIHRvIHBlcmZvcm0gZGVhZGNvZGUgZWxpbWluYXRpb24uXG4gICAgIHNlZSBwcHgvcHB4X2lubGluZV90ZXN0L3J1bnRpbWUtbGliL3J1bnRpbWUubWwgW0FjdGlvbi5nZXRdIGZvciBtb3JlIGRldGFpbHMgKilcbiAgdHJ5XG4gICAgaWdub3JlIChTeXMuZ2V0ZW52IFwiRk9SQ0VfRFJPUF9CRU5DSFwiIDogc3RyaW5nKTtcbiAgICB0cnVlXG4gIHdpdGhcbiAgfCBOb3RfZm91bmQgLT4gZmFsc2Vcbjs7XG5cbmxldCBnZXRfbW9kZSAoKSA9IGlmIGZvcmNlX2Ryb3AgdGhlbiBgSWdub3JlIGVsc2UgYENvbGxlY3RcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGFkZF9iZW5jaFxuICB+bmFtZVxuICB+Y29kZVxuICB+ZmlsZW5hbWVcbiAgfnR5cGVfY29udl9wYXRoXG4gIH5saW5lXG4gIH5zdGFydHBvc1xuICB+ZW5kcG9zXG4gIHRlc3Rfc3BlY1xuICA9XG4gIG1hdGNoIGdldF9tb2RlICgpIHdpdGhcbiAgfCBgSWdub3JlIC0+ICgpXG4gIHwgYENvbGxlY3QgLT5cbiAgICBsZXQgbGlibmFtZSA9IEN1cnJlbnRfbGlibmFtZS5nZXQgKCkgaW5cbiAgICBsZXQgZW50cnkgPVxuICAgICAgeyBFbnRyeS5jb2RlXG4gICAgICA7IHVuaXF1ZV9pZCA9IHVuaXF1ZV9pZCAoKVxuICAgICAgOyB0eXBlX2NvbnZfcGF0aFxuICAgICAgOyBiZW5jaF9tb2R1bGVfbmFtZSA9IEN1cnJlbnRfYmVuY2hfbW9kdWxlX3N0YWNrLnRvX25hbWUgKClcbiAgICAgIDsgbmFtZVxuICAgICAgOyBmaWxlbmFtZVxuICAgICAgOyBsaW5lXG4gICAgICA7IHN0YXJ0cG9zXG4gICAgICA7IGVuZHBvc1xuICAgICAgOyB0ZXN0X3NwZWNcbiAgICAgIH1cbiAgICBpblxuICAgIEhhc2h0YmwuYWRkIGxpYnNfdG9fZW50cmllcyBsaWJuYW1lIChlbnRyeSA6OiBsb29rdXBfcmV2X2xpYiB+bGlibmFtZSlcbjs7XG5cbmxldFtAaW5saW5lIG5ldmVyXSBhZGRfYmVuY2hfbW9kdWxlXG4gIH5uYW1lXG4gIH5jb2RlOl9cbiAgfnR5cGVfY29udl9wYXRoOl9cbiAgfmZpbGVuYW1lOl9cbiAgfmxpbmU6X1xuICB+c3RhcnRwb3M6X1xuICB+ZW5kcG9zOl9cbiAgZlxuICA9XG4gIG1hdGNoIGdldF9tb2RlICgpIHdpdGhcbiAgfCBgSWdub3JlIC0+ICgpXG4gIHwgYENvbGxlY3QgLT5cbiAgICAoKiBSdW5uaW5nIGYgcmVnaXN0ZXJzIHRoZSBiZW5jaG1hcmtzIHVzaW5nIEJFTkNIICopXG4gICAgQ3VycmVudF9iZW5jaF9tb2R1bGVfc3RhY2sucHVzaCBuYW1lO1xuICAgICh0cnlcbiAgICAgICBmICgpO1xuICAgICAgIEN1cnJlbnRfYmVuY2hfbW9kdWxlX3N0YWNrLnBvcF9leG4gKClcbiAgICAgd2l0aFxuICAgICB8IGV4IC0+XG4gICAgICAgQ3VycmVudF9iZW5jaF9tb2R1bGVfc3RhY2sucG9wX2V4biAoKTtcbiAgICAgICByYWlzZSBleClcbjs7XG4iXX0=
