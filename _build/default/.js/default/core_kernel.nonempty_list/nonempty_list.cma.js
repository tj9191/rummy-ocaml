// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Nonempty_list
//# unitInfo: Requires: Base, Base__Indexed_container, Base__Monad, Base__Sequence, Base_quickcheck__Generator, Base_quickcheck__Observer, Base_quickcheck__Shrinker, Bin_prot__Common, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Write, Bin_shape, Core, Core__Binable, Core__Bool, Core__Command_internal, Core__Comparator, Core__Fn, Core__List, Core__Map, Core__Or_error, Core__Result, Core__Sequence, Core__Sexpable, Core__Stable, Expect_test_config, Inline_test_config, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_expect_runtime__Test_block, Ppx_expect_runtime__Test_node, Ppx_expect_runtime__Types, Ppx_inline_test_lib, Ppx_module_timer_runtime, Reversed_list, Sexplib0__Sexp_conv, Stable_witness, Stdlib, Typerep_lib__Make_typename, Typerep_lib__Std, Typerep_lib__Typename, Validate
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    cst$1 = "::",
    cst_Nonempty_list$0 = "Nonempty_list",
    cst_a$10 = "a",
    cst_nonempty_list$0 = "nonempty_list",
    cst_nonempty_list_src_nonempty$17 = "nonempty_list/src/nonempty_list.ml",
    cst_nonempty_list_src_nonempty$16 =
      "nonempty_list/src/nonempty_list.ml.T'.t",
    cst_t$7 = "t";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call14
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    return (f.l >= 0 ? f.l : f.l = f.length) == 14
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
            : runtime.caml_call_gen
              (f,
               [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    name = cst_nonempty_list_src_nonempty$16,
    cst$0 = cst$1,
    name$0 = "nonempty_list/src/nonempty_list.ml.Option.t",
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Core_Command_internal = global_data.Core__Command_internal,
    Core_Fn = global_data.Core__Fn,
    Core_List = global_data.Core__List,
    Reversed_list = global_data.Reversed_list,
    Validate = global_data.Validate,
    Core_Or_error = global_data.Core__Or_error,
    Core_Result = global_data.Core__Result,
    Core_Map = global_data.Core__Map,
    Core_Sequence = global_data.Core__Sequence,
    Bin_prot_Read = global_data.Bin_prot__Read,
    Bin_prot_Common = global_data.Bin_prot__Common,
    Bin_prot_Write = global_data.Bin_prot__Write,
    Bin_shape = global_data.Bin_shape,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    Typerep_lib_Std = global_data.Typerep_lib__Std,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    Base_Sequence = global_data.Base__Sequence,
    Base = global_data.Base,
    Base_quickcheck_Observer = global_data.Base_quickcheck__Observer,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Core_Stable = global_data.Core__Stable,
    Stdlib = global_data.Stdlib,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Stable_witness = global_data.Stable_witness,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Binable = global_data.Core__Binable,
    Core_Sexpable = global_data.Core__Sexpable,
    Expect_test_config = global_data.Expect_test_config,
    Ppx_expect_runtime_Test_block = global_data.Ppx_expect_runtime__Test_block,
    Ppx_expect_runtime_Test_node = global_data.Ppx_expect_runtime__Test_node,
    Inline_test_config = global_data.Inline_test_config,
    Typerep_lib_Make_typename = global_data.Typerep_lib__Make_typename,
    Core_Comparator = global_data.Core__Comparator,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Nonempty_list$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_nonempty_list$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_nonempty_list_src_nonempty$17);
   caml_call2(Ppx_inline_test_lib[6], cst_nonempty_list$0, "nonempty_list.ml");
   var
    cst_Nonempty_list_Option_value =
      "Nonempty_list.Option.value_exn: empty list",
    _T_ = [0, 0],
    _S_ =
      [0,
       [11, "Nonempty_list.init ", [4, 0, 0, 0, 0]],
       "Nonempty_list.init %d"],
    _Q_ =
      [0,
       [11,
        "Nonempty_list.nth_exn ",
        [4, 0, 0, 0, [11, " called on list of length ", [4, 0, 0, 0, 0]]]],
       "Nonempty_list.nth_exn %d called on list of length %d"],
    cst_empty_list = "empty list",
    _P_ = [1, cst_nonempty_list_src_nonempty$16],
    cst_nonempty_list_src_nonempty$12 = cst_nonempty_list_src_nonempty$16,
    cst_t$6 = cst_t$7,
    cst_nonempty_list_src_nonempty$8 =
      "nonempty_list/src/nonempty_list.ml.Stable.V1.Pair_format.t",
    cst_t$4 = cst_t$7,
    cst_nonempty_list_src_nonempty$4 =
      "nonempty_list/src/nonempty_list.ml.Stable.V2.Record_format.t",
    cst_t$2 = cst_t$7,
    cst_t$0 = cst_t$7,
    cst_Nonempty_list_of_list_exn_ = "Nonempty_list.of_list_exn: empty list",
    cst_a = cst_a$10,
    cst_nonempty_list_src_nonempty =
      "nonempty_list/src/nonempty_list.ml:19:18",
    cst_a$0 = cst_a$10,
    cst_t = cst_t$7,
    cst_nonempty_list_src_nonempty$0 =
      "nonempty_list/src/nonempty_list.ml:19:6",
    cst_9a63aaee_82e0_11ea_8fb6_aa = "9a63aaee-82e0-11ea-8fb6-aa00005c6184",
    _an_ =
      [0,
       [0,
        [0, " eaa5c1535ea5c1691291b3bdbbd7b014 ", [0, cst$2]],
        [0, 1537, 1552, 1590]]],
    _ao_ = [0, 1537, 1543, 1591],
    _at_ = [0, 1471, 1475, 1591],
    _au_ = [0, 1537, 1591, 1591],
    _av_ = [0, 1471, 1475, 1591],
    cst_nonempty_list_src_nonempty$15 = cst_nonempty_list_src_nonempty$17,
    cst_a$1 = cst_a$10,
    cst_nonempty_list_src_nonempty$1 =
      "nonempty_list/src/nonempty_list.ml:78:15",
    cst_tl = "tl",
    cst_a$2 = cst_a$10,
    cst_nonempty_list_src_nonempty$2 =
      "nonempty_list/src/nonempty_list.ml:77:15",
    cst_hd = "hd",
    cst_a$3 = cst_a$10,
    cst_t$1 = cst_t$7,
    cst_nonempty_list_src_nonempty$3 =
      "nonempty_list/src/nonempty_list.ml:76:6",
    _ad_ =
      [0,
       [0,
        [0, " 2aede2e9b03754f5dfa5f1a61877b330 ", [0, cst$2]],
        [0, 2788, 2803, 2841]]],
    _ae_ = [0, 2788, 2794, 2842],
    _aj_ = [0, 2722, 2726, 2842],
    _ak_ = [0, 2788, 2842, 2842],
    _al_ = [0, 2722, 2726, 2842],
    cst_nonempty_list_src_nonempty$14 = cst_nonempty_list_src_nonempty$17,
    cst_a$4 = cst_a$10,
    cst_nonempty_list_src_nonempty$5 =
      "nonempty_list/src/nonempty_list.ml:123:23",
    cst_a$5 = cst_a$10,
    cst_nonempty_list_src_nonempty$6 =
      "nonempty_list/src/nonempty_list.ml:123:18",
    cst_a$6 = cst_a$10,
    cst_t$3 = cst_t$7,
    cst_nonempty_list_src_nonempty$7 =
      "nonempty_list/src/nonempty_list.ml:123:6",
    _V_ =
      [0,
       [0,
        [0, " f27871ef428aef2925f18d6be687bf9c ", [0, cst$2]],
        [0, 3954, 3969, 4007]]],
    _W_ = [0, 3954, 3960, 4008],
    _$_ = [0, 3888, 3892, 4008],
    _aa_ = [0, 3954, 4008, 4008],
    _ab_ = [0, 3888, 3892, 4008],
    cst_nonempty_list_src_nonempty$13 = cst_nonempty_list_src_nonempty$17,
    cst_a$7 = cst_a$10,
    cst_nonempty_list_src_nonempty$9 =
      "nonempty_list/src/nonempty_list.ml:160:46",
    cst_a$8 = cst_a$10,
    cst_nonempty_list_src_nonempty$10 =
      "nonempty_list/src/nonempty_list.ml:160:41",
    cst_a$9 = cst_a$10,
    cst_t$5 = cst_t$7,
    cst_nonempty_list_src_nonempty$11 =
      "nonempty_list/src/nonempty_list.ml:160:2",
    cst_nonempty_list = cst_nonempty_list$0,
    cst_Nonempty_list = cst_Nonempty_list$0;
   function compare(cmp_a, a_001, b_002){
    if(a_001 === b_002) return 0;
    var
     b_006 = b_002[2],
     b_004 = b_002[1],
     a_005 = a_001[2],
     a_003 = a_001[1],
     n = caml_call2(cmp_a, a_003, b_004);
    if(0 !== n) return n;
    function _cg_(a_007, b_008){return caml_call2(cmp_a, a_007, b_008);}
    return caml_call3(Core_Stable[446], _cg_, a_005, b_006);
   }
   function equal(cmp_a, a_009, b_010){
    if(a_009 === b_010) return 1;
    var
     b_014 = b_010[2],
     b_012 = b_010[1],
     a_013 = a_009[2],
     a_011 = a_009[1],
     _ce_ = caml_call2(cmp_a, a_011, b_012);
    if(! _ce_) return _ce_;
    function _cf_(a_015, b_016){return caml_call2(cmp_a, a_015, b_016);}
    return caml_call3(Core_Stable[460], _cf_, a_013, b_014);
   }
   function hash_fold_t(hash_fold_a, hsv, arg){
    var a1 = arg[2], a0 = arg[1], hsv$0 = caml_call2(hash_fold_a, hsv, a0);
    return caml_call3(Core_Stable[291], hash_fold_a, hsv$0, a1);
   }
   function to_list(param){
    var tl = param[2], hd = param[1];
    return [0, hd, tl];
   }
   function of_list_exn(param){
    if(param){var tl = param[2], hd = param[1]; return [0, hd, tl];}
    var
     _cd_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Nonempty_list_of_list_exn_);
    return caml_call1(Core[261], _cd_);
   }
   var
    _a_ = caml_call1(Bin_shape[3][1], cst_a),
    _b_ = caml_call1(Bin_shape[4][1], cst_nonempty_list_src_nonempty),
    _c_ = caml_call2(Bin_prot_Shape[11], _b_, _a_),
    _d_ = caml_call1(Core_Stable[203], _c_),
    _e_ = [0, caml_call1(Bin_shape[3][1], cst_a$0), 0],
    _f_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), _e_, _d_], 0],
    _g_ = caml_call1(Bin_shape[4][1], cst_nonempty_list_src_nonempty$0),
    group = caml_call2(Bin_prot_Shape[2], _g_, _f_);
   function bin_shape_t(a){
    var _cc_ = caml_call1(Bin_shape[2][1], cst_t$0);
    return caml_call1(caml_call2(Bin_prot_Shape[10], group, _cc_), [0, a, 0]);
   }
   function bin_size_t(size_of_a, v){
    return caml_call2(Core_Stable[18], size_of_a, v);
   }
   function bin_write_t(write_a, buf, pos, v){
    return caml_call4(Core_Stable[205], write_a, buf, pos, v);
   }
   function bin_read_t(of_a, buf, pos_ref, vint){
    return caml_call3(caml_call1(Core_Stable[209], of_a), buf, pos_ref, vint);
   }
   function bin_read_t$0(of_a, buf, pos_ref){
    return caml_call2(caml_call1(Core_Stable[208], of_a), buf, pos_ref);
   }
   var t_of_sexp = Core_Stable[343], sexp_of_t = Core_Stable[342];
   function stable_witness(a_stable_witness){return Stable_witness[6];}
   var
    caller_identity =
      caml_call1(Bin_shape[5][1], cst_9a63aaee_82e0_11ea_8fb6_aa),
    _h_ =
      caml_call1
       (caml_call1
         (Core_Binable[16][2][2],
          [0, bin_shape_t, bin_size_t, bin_write_t, bin_read_t$0, bin_read_t]),
        [0, to_list, of_list_exn, caller_identity]),
    bin_shape_t$0 = _h_[1],
    bin_size_t$0 = _h_[2],
    bin_write_t$0 = _h_[3],
    bin_read_t$1 = _h_[4],
    bin_read_t$2 = _h_[5],
    bin_writer_t = _h_[6],
    bin_reader_t = _h_[7],
    bin_t = _h_[8],
    include =
      caml_call1
       (caml_call1(Core_Sexpable[2][2][1], [0, t_of_sexp, sexp_of_t]),
        [0, to_list, of_list_exn]),
    t_of_sexp$0 = include[1],
    sexp_of_t$0 = include[2];
   function t_sexp_grammar(param){return [2, [0, param, [1, param]]];}
   function stable_witness$0(witness){
    return caml_call4
            (caml_call1(caml_call1(Stable_witness[3], [0]), [0])[1],
             stable_witness,
             of_list_exn,
             to_list,
             witness);
   }
   if(typeof Ppx_inline_test_lib[3] !== "number"){
    var
     Ppx_expect_test_block$1 =
       caml_call1(Ppx_expect_runtime_Test_block[1], Expect_test_config),
     _am_ =
       function(param){
        var
         _b__ = caml_call1(bin_shape_t$0, Core_Stable[123]),
         _b$_ = caml_call1(Bin_prot_Shape[15], _b__),
         _ca_ = caml_call1(Bin_shape[19][4], _b$_);
        caml_call1(Stdlib[46], _ca_);
        var _cb_ = caml_call1(Ppx_expect_runtime_Types[4][1], 0);
        return caml_call1(Ppx_expect_test_block$1[2], _cb_);
       },
     _ap_ =
       caml_call3
        (Ppx_expect_runtime_Test_node[1][1],
         [0, Ppx_expect_runtime_Types[1][1]],
         _ao_,
         _an_),
     _aq_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 0), _ap_], 0],
     _ar_ = caml_call1(Ppx_expect_runtime_Types[4][1], 2),
     _as_ = caml_call1(Ppx_expect_runtime_Types[4][1], 1);
    caml_call14
     (Ppx_expect_test_block$1[3],
      cst_nonempty_list_src_nonempty$15,
      58,
      _av_,
      _au_,
      _at_,
      [0, Ppx_expect_runtime_Types[1][1]],
      0,
      _as_,
      _ar_,
      0,
      0,
      Inline_test_config,
      _aq_,
      _am_);
   }
   function compare$0(cmp_a, a_022, b_023){
    if(a_022 === b_023) return 0;
    var
     b_027 = b_023[2],
     b_025 = b_023[1],
     a_026 = a_022[2],
     a_024 = a_022[1],
     n = caml_call2(cmp_a, a_024, b_025);
    if(0 !== n) return n;
    function _b9_(a_028, b_029){return caml_call2(cmp_a, a_028, b_029);}
    return caml_call3(Core_Stable[446], _b9_, a_026, b_027);
   }
   function equal$0(cmp_a, a_030, b_031){
    if(a_030 === b_031) return 1;
    var
     b_035 = b_031[2],
     b_033 = b_031[1],
     a_034 = a_030[2],
     a_032 = a_030[1],
     _b7_ = caml_call2(cmp_a, a_032, b_033);
    if(! _b7_) return _b7_;
    function _b8_(a_036, b_037){return caml_call2(cmp_a, a_036, b_037);}
    return caml_call3(Core_Stable[460], _b8_, a_034, b_035);
   }
   function hash_fold_t$0(hash_fold_a, hsv, arg){
    var a1 = arg[2], a0 = arg[1], hsv$0 = caml_call2(hash_fold_a, hsv, a0);
    return caml_call3(Core_Stable[291], hash_fold_a, hsv$0, a1);
   }
   var
    _i_ = caml_call1(Bin_shape[3][1], cst_a$1),
    _j_ = caml_call1(Bin_shape[4][1], cst_nonempty_list_src_nonempty$1),
    _k_ = caml_call2(Bin_prot_Shape[11], _j_, _i_),
    _l_ = [0, [0, cst_tl, caml_call1(Core_Stable[203], _k_)], 0],
    _m_ = caml_call1(Bin_shape[3][1], cst_a$2),
    _n_ = caml_call1(Bin_shape[4][1], cst_nonempty_list_src_nonempty$2),
    _o_ = [0, [0, cst_hd, caml_call2(Bin_prot_Shape[11], _n_, _m_)], _l_],
    _p_ = caml_call1(Bin_prot_Shape[4], _o_),
    _q_ = [0, caml_call1(Bin_shape[3][1], cst_a$3), 0],
    _r_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$1), _q_, _p_], 0],
    _s_ = caml_call1(Bin_shape[4][1], cst_nonempty_list_src_nonempty$3),
    group$0 = caml_call2(Bin_prot_Shape[2], _s_, _r_);
   function bin_shape_t$1(a){
    var _b6_ = caml_call1(Bin_shape[2][1], cst_t$2);
    return caml_call1
            (caml_call2(Bin_prot_Shape[10], group$0, _b6_), [0, a, 0]);
   }
   function bin_size_t$1(size_of_a, param){
    var
     v2 = param[2],
     v1 = param[1],
     _b4_ = caml_call1(size_of_a, v1),
     size = caml_call2(Bin_prot_Common[23], 0, _b4_),
     _b5_ = caml_call2(Core_Stable[18], size_of_a, v2);
    return caml_call2(Bin_prot_Common[23], size, _b5_);
   }
   function bin_write_t$1(write_a, buf, pos, param){
    var
     v2 = param[2],
     v1 = param[1],
     pos$0 = caml_call3(write_a, buf, pos, v1);
    return caml_call4(Core_Stable[205], write_a, buf, pos$0, v2);
   }
   function bin_read_t$3(of_a, buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19],
             cst_nonempty_list_src_nonempty$4,
             pos_ref[1]);
   }
   function bin_read_t$4(of_a, buf, pos_ref){
    var
     v_hd = caml_call2(of_a, buf, pos_ref),
     v_tl = caml_call2(caml_call1(Core_Stable[208], of_a), buf, pos_ref);
    return [0, v_hd, v_tl];
   }
   function stable_witness$1(a_stable_witness){return Stable_witness[6];}
   function of_nonempty_list(param){
    var tl = param[2], hd = param[1];
    return [0, hd, tl];
   }
   function to_nonempty_list(param){
    var tl = param[2], hd = param[1];
    return [0, hd, tl];
   }
   var
    include$0 =
      caml_call1
       (caml_call1
         (Core_Binable[16][2][1],
          [0,
           bin_shape_t$1,
           bin_size_t$1,
           bin_write_t$1,
           bin_read_t$4,
           bin_read_t$3]),
        [0, of_nonempty_list, to_nonempty_list]),
    bin_shape_t$2 = include$0[1],
    bin_size_t$2 = include$0[2],
    bin_write_t$2 = include$0[3],
    bin_read_t$5 = include$0[4],
    bin_read_t$6 = include$0[5],
    bin_writer_t$0 = include$0[6],
    bin_reader_t$0 = include$0[7],
    bin_t$0 = include$0[8];
   function stable_witness$2(witness){
    return caml_call4
            (caml_call1(caml_call1(Stable_witness[3], [0]), [0])[1],
             stable_witness$1,
             to_nonempty_list,
             of_nonempty_list,
             witness);
   }
   if(typeof Ppx_inline_test_lib[3] !== "number"){
    var
     Ppx_expect_test_block$0 =
       caml_call1(Ppx_expect_runtime_Test_block[1], Expect_test_config),
     _ac_ =
       function(param){
        var
         _b0_ = caml_call1(bin_shape_t$2, Core_Stable[123]),
         _b1_ = caml_call1(Bin_prot_Shape[15], _b0_),
         _b2_ = caml_call1(Bin_shape[19][4], _b1_);
        caml_call1(Stdlib[46], _b2_);
        var _b3_ = caml_call1(Ppx_expect_runtime_Types[4][1], 3);
        return caml_call1(Ppx_expect_test_block$0[2], _b3_);
       },
     _af_ =
       caml_call3
        (Ppx_expect_runtime_Test_node[1][1],
         [0, Ppx_expect_runtime_Types[1][1]],
         _ae_,
         _ad_),
     _ag_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 3), _af_], 0],
     _ah_ = caml_call1(Ppx_expect_runtime_Types[4][1], 5),
     _ai_ = caml_call1(Ppx_expect_runtime_Types[4][1], 4);
    caml_call14
     (Ppx_expect_test_block$0[3],
      cst_nonempty_list_src_nonempty$14,
      106,
      _al_,
      _ak_,
      _aj_,
      [0, Ppx_expect_runtime_Types[1][1]],
      0,
      _ai_,
      _ah_,
      0,
      0,
      Inline_test_config,
      _ag_,
      _ac_);
   }
   function compare$1(cmp_a, a_042, b_043){
    if(a_042 === b_043) return 0;
    var
     b_047 = b_043[2],
     b_045 = b_043[1],
     a_046 = a_042[2],
     a_044 = a_042[1],
     n = caml_call2(cmp_a, a_044, b_045);
    if(0 !== n) return n;
    function _bZ_(a_048, b_049){return caml_call2(cmp_a, a_048, b_049);}
    return caml_call3(Core_Stable[446], _bZ_, a_046, b_047);
   }
   function equal$1(cmp_a, a_050, b_051){
    if(a_050 === b_051) return 1;
    var
     b_055 = b_051[2],
     b_053 = b_051[1],
     a_054 = a_050[2],
     a_052 = a_050[1],
     _bX_ = caml_call2(cmp_a, a_052, b_053);
    if(! _bX_) return _bX_;
    function _bY_(a_056, b_057){return caml_call2(cmp_a, a_056, b_057);}
    return caml_call3(Core_Stable[460], _bY_, a_054, b_055);
   }
   var
    _t_ = caml_call1(Bin_shape[3][1], cst_a$4),
    _u_ = caml_call1(Bin_shape[4][1], cst_nonempty_list_src_nonempty$5),
    _v_ = caml_call2(Bin_prot_Shape[11], _u_, _t_),
    _w_ = [0, caml_call1(Core_Stable[203], _v_), 0],
    _x_ = caml_call1(Bin_shape[3][1], cst_a$5),
    _y_ = caml_call1(Bin_shape[4][1], cst_nonempty_list_src_nonempty$6),
    _z_ = [0, caml_call2(Bin_prot_Shape[11], _y_, _x_), _w_],
    _A_ = caml_call1(Bin_prot_Shape[3], _z_),
    _B_ = [0, caml_call1(Bin_shape[3][1], cst_a$6), 0],
    _C_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$3), _B_, _A_], 0],
    _D_ = caml_call1(Bin_shape[4][1], cst_nonempty_list_src_nonempty$7),
    group$1 = caml_call2(Bin_prot_Shape[2], _D_, _C_);
   function bin_shape_t$3(a){
    var _bW_ = caml_call1(Bin_shape[2][1], cst_t$4);
    return caml_call1
            (caml_call2(Bin_prot_Shape[10], group$1, _bW_), [0, a, 0]);
   }
   function bin_size_t$3(size_of_a, param){
    var
     v2 = param[2],
     v1 = param[1],
     _bU_ = caml_call1(size_of_a, v1),
     size = caml_call2(Bin_prot_Common[23], 0, _bU_),
     _bV_ = caml_call2(Core_Stable[18], size_of_a, v2);
    return caml_call2(Bin_prot_Common[23], size, _bV_);
   }
   function bin_write_t$3(write_a, buf, pos, param){
    var
     v2 = param[2],
     v1 = param[1],
     pos$0 = caml_call3(write_a, buf, pos, v1);
    return caml_call4(Core_Stable[205], write_a, buf, pos$0, v2);
   }
   function bin_read_t$7(of_a, buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19],
             cst_nonempty_list_src_nonempty$8,
             pos_ref[1]);
   }
   function bin_read_t$8(of_a, buf, pos_ref){
    var
     v1 = caml_call2(of_a, buf, pos_ref),
     v2 = caml_call2(caml_call1(Core_Stable[208], of_a), buf, pos_ref);
    return [0, v1, v2];
   }
   function stable_witness$3(a_stable_witness){return Stable_witness[6];}
   function of_nonempty_list$0(param){
    var tl = param[2], hd = param[1];
    return [0, hd, tl];
   }
   function to_nonempty_list$0(param){
    var tl = param[2], hd = param[1];
    return [0, hd, tl];
   }
   var
    include$1 =
      caml_call1
       (caml_call1
         (Core_Binable[16][2][1],
          [0,
           bin_shape_t$3,
           bin_size_t$3,
           bin_write_t$3,
           bin_read_t$8,
           bin_read_t$7]),
        [0, of_nonempty_list$0, to_nonempty_list$0]),
    bin_shape_t$4 = include$1[1],
    bin_size_t$4 = include$1[2],
    bin_write_t$4 = include$1[3],
    bin_read_t$9 = include$1[4],
    bin_read_t$10 = include$1[5],
    bin_writer_t$1 = include$1[6],
    bin_reader_t$1 = include$1[7],
    bin_t$1 = include$1[8];
   function stable_witness$4(witness){
    return caml_call4
            (caml_call1(caml_call1(Stable_witness[3], [0]), [0])[1],
             stable_witness$3,
             to_nonempty_list$0,
             of_nonempty_list$0,
             witness);
   }
   if(typeof Ppx_inline_test_lib[3] !== "number"){
    var
     Ppx_expect_test_block =
       caml_call1(Ppx_expect_runtime_Test_block[1], Expect_test_config),
     _U_ =
       function(param){
        var
         _bQ_ = caml_call1(bin_shape_t$4, Core_Stable[123]),
         _bR_ = caml_call1(Bin_prot_Shape[15], _bQ_),
         _bS_ = caml_call1(Bin_shape[19][4], _bR_);
        caml_call1(Stdlib[46], _bS_);
        var _bT_ = caml_call1(Ppx_expect_runtime_Types[4][1], 6);
        return caml_call1(Ppx_expect_test_block[2], _bT_);
       },
     _X_ =
       caml_call3
        (Ppx_expect_runtime_Test_node[1][1],
         [0, Ppx_expect_runtime_Types[1][1]],
         _W_,
         _V_),
     _Y_ = [0, [0, caml_call1(Ppx_expect_runtime_Types[4][1], 6), _X_], 0],
     _Z_ = caml_call1(Ppx_expect_runtime_Types[4][1], 8),
     ___ = caml_call1(Ppx_expect_runtime_Types[4][1], 7);
    caml_call14
     (Ppx_expect_test_block[3],
      cst_nonempty_list_src_nonempty$13,
      149,
      _ab_,
      _aa_,
      _$_,
      [0, Ppx_expect_runtime_Types[1][1]],
      0,
      ___,
      _Z_,
      0,
      0,
      Inline_test_config,
      _Y_,
      _U_);
   }
   function compare$2(cmp_a, a_066, b_067){
    if(a_066 === b_067) return 0;
    var
     b_071 = b_067[2],
     b_069 = b_067[1],
     a_070 = a_066[2],
     a_068 = a_066[1],
     n = caml_call2(cmp_a, a_068, b_069);
    if(0 !== n) return n;
    function _bP_(a_072, b_073){return caml_call2(cmp_a, a_072, b_073);}
    return caml_call3(Core[466], _bP_, a_070, b_071);
   }
   function equal$2(cmp_a, a_074, b_075){
    if(a_074 === b_075) return 1;
    var
     b_079 = b_075[2],
     b_077 = b_075[1],
     a_078 = a_074[2],
     a_076 = a_074[1],
     _bN_ = caml_call2(cmp_a, a_076, b_077);
    if(! _bN_) return _bN_;
    function _bO_(a_080, b_081){return caml_call2(cmp_a, a_080, b_081);}
    return caml_call3(Core[468], _bO_, a_078, b_079);
   }
   function hash_fold_t$1(hash_fold_a, hsv, arg){
    var a1 = arg[2], a0 = arg[1], hsv$0 = caml_call2(hash_fold_a, hsv, a0);
    return caml_call3(Core[471], hash_fold_a, hsv$0, a1);
   }
   function quickcheck_generator(generator_091){
    var _bI_ = 0;
    function _bJ_(size_092, random_093){
     var
      _bL_ = caml_call1(Core[129], generator_091),
      _bM_ =
        caml_call3(Base_quickcheck_Generator[128], _bL_, size_092, random_093);
     return [0,
             caml_call3
              (Base_quickcheck_Generator[128],
               generator_091,
               size_092,
               random_093),
             _bM_];
    }
    var
     _bK_ =
       [0, [0, 1., caml_call1(Base_quickcheck_Generator[127], _bJ_)], _bI_];
    return caml_call1(Base_quickcheck_Generator[60], _bK_);
   }
   function quickcheck_observer(observer_085){
    function _bG_(x_086, size_087, hash_088){
     var
      x_090 = x_086[2],
      x_089 = x_086[1],
      hash_088$0 = caml_call2(Base[133], hash_088, 0),
      hash_088$1 =
        caml_call4
         (Base_quickcheck_Observer[37],
          observer_085,
          x_089,
          size_087,
          hash_088$0),
      _bH_ = caml_call1(Core[134], observer_085),
      hash_088$2 =
        caml_call4
         (Base_quickcheck_Observer[37], _bH_, x_090, size_087, hash_088$1);
     return hash_088$2;
    }
    return caml_call1(Base_quickcheck_Observer[36], _bG_);
   }
   function quickcheck_shrinker(shrinker_082){
    function _bx_(param){
     var x_084 = param[2], x_083 = param[1], _by_ = 0;
     function _bz_(x_084){return [0, x_083, x_084];}
     var
      _bA_ = caml_call1(Core[139], shrinker_082),
      _bB_ = caml_call2(Base_quickcheck_Shrinker[37], _bA_, x_084),
      _bC_ = [0, caml_call2(Base_Sequence[35], _bB_, _bz_), _by_];
     function _bD_(x_083){return [0, x_083, x_084];}
     var
      _bE_ = caml_call2(Base_quickcheck_Shrinker[37], shrinker_082, x_083),
      _bF_ = [0, caml_call2(Base_Sequence[35], _bE_, _bD_), _bC_];
     return caml_call1(Base_Sequence[70], _bF_);
    }
    return caml_call1(Base_quickcheck_Shrinker[36], _bx_);
   }
   var
    Typename_of_t = caml_call1(Typerep_lib_Make_typename[2], [0, name]),
    typename_of_t = Typename_of_t[2];
   function typerep_of_t(of_a){
    var name_of_t = caml_call1(Typename_of_t[1], of_a);
    return [9,
            [0,
             name_of_t,
             [0,
              [246,
               function(param){
                var
                 _bt_ =
                   [0,
                    function(param){
                     var v1 = param[2], v0 = param[1];
                     return [0, v0, v1];
                    }],
                 _bu_ = caml_call2(Typerep_lib_Typename[1], 0, 0),
                 _bv_ = caml_call1(Core[475], of_a),
                 _bw_ =
                   [0,
                    cst,
                    caml_call2(Core[275], of_a, _bv_),
                    2,
                    0,
                    0,
                    0,
                    _bu_,
                    _bt_],
                 tag0 = caml_call1(Typerep_lib_Std[1][4][9], _bw_),
                 typename = caml_call1(Typerep_lib_Std[1][1][2], name_of_t),
                 tags = [0, [0, tag0]],
                 polymorphic = 0;
                function value(param){
                 var v1 = param[2], v0 = param[1];
                 return [0, tag0, [0, v0, v1]];
                }
                return [8,
                        caml_call1
                         (Typerep_lib_Std[1][6][7],
                          [0, typename, tags, polymorphic, value])];
               }]]]];
   }
   var
    _E_ = caml_call1(Bin_shape[3][1], cst_a$7),
    _F_ = caml_call1(Bin_shape[4][1], cst_nonempty_list_src_nonempty$9),
    _G_ = caml_call2(Bin_prot_Shape[11], _F_, _E_),
    _H_ = [0, caml_call1(Core[456], _G_), 0],
    _I_ = caml_call1(Bin_shape[3][1], cst_a$8),
    _J_ = caml_call1(Bin_shape[4][1], cst_nonempty_list_src_nonempty$10),
    _K_ =
      [0, [0, cst$0, [0, caml_call2(Bin_prot_Shape[11], _J_, _I_), _H_]], 0],
    _L_ = caml_call1(Bin_prot_Shape[5], _K_),
    _M_ = [0, caml_call1(Bin_shape[3][1], cst_a$9), 0],
    _N_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$5), _M_, _L_], 0],
    _O_ = caml_call1(Bin_shape[4][1], cst_nonempty_list_src_nonempty$11),
    group$2 = caml_call2(Bin_prot_Shape[2], _O_, _N_);
   function bin_shape_t$5(a){
    var _bs_ = caml_call1(Bin_shape[2][1], cst_t$6);
    return caml_call1
            (caml_call2(Bin_prot_Shape[10], group$2, _bs_), [0, a, 0]);
   }
   function bin_size_t$5(size_of_a, param){
    var
     v2 = param[2],
     v1 = param[1],
     _bq_ = caml_call1(size_of_a, v1),
     size = caml_call2(Bin_prot_Common[23], 1, _bq_),
     _br_ = caml_call2(Core[457], size_of_a, v2);
    return caml_call2(Bin_prot_Common[23], size, _br_);
   }
   function bin_write_t$5(write_a, buf, pos, param){
    var
     v2 = param[2],
     v1 = param[1],
     pos$0 = caml_call3(Bin_prot_Write[30], buf, pos, 0),
     pos$1 = caml_call3(write_a, buf, pos$0, v1);
    return caml_call4(Core[459], write_a, buf, pos$1, v2);
   }
   function bin_writer_t$2(bin_writer_a){
    function _bm_(v){
     var _bn_ = bin_writer_a[2];
     return function(_bo_, _bp_){return bin_write_t$5(_bn_, v, _bo_, _bp_);};
    }
    return [0, function(v){return bin_size_t$5(bin_writer_a[1], v);}, _bm_];
   }
   function bin_read_t$11(of_a, buf, pos_ref, vint){
    return caml_call2
            (Bin_prot_Common[19],
             cst_nonempty_list_src_nonempty$12,
             pos_ref[1]);
   }
   function bin_read_t$12(of_a, buf, pos_ref){
    if(0 !== caml_call2(Bin_prot_Read[29], buf, pos_ref))
     return caml_call2(Bin_prot_Common[18], _P_, pos_ref[1]);
    var
     arg_1 = caml_call2(of_a, buf, pos_ref),
     arg_2 = caml_call2(caml_call1(Core[462], of_a), buf, pos_ref);
    return [0, arg_1, arg_2];
   }
   function bin_reader_t$2(bin_reader_a){
    function _bl_(buf, pos_ref, vtag){
     return bin_read_t$11(bin_reader_a[1], buf, pos_ref, vtag);
    }
    return [0,
            function(buf, pos_ref){
             return bin_read_t$12(bin_reader_a[1], buf, pos_ref);
            },
            _bl_];
   }
   function bin_t$2(bin_a){
    var _bj_ = bin_reader_t$2(bin_a[3]), _bk_ = bin_writer_t$2(bin_a[2]);
    return [0, bin_shape_t$5(bin_a[1]), _bk_, _bj_];
   }
   function globalize(globalize_a_095, x_096){
    var
     arg_097 = x_096[2],
     arg_099 = x_096[1],
     _bi_ = caml_call2(Core[470], globalize_a_095, arg_097);
    return [0, caml_call1(globalize_a_095, arg_099), _bi_];
   }
   function hd(param){var hd = param[1]; return hd;}
   function tl(param){var tl = param[2]; return tl;}
   function of_list(param){
    if(! param) return 0;
    var tl = param[2], hd = param[1];
    return [0, [0, hd, tl]];
   }
   function of_list_error(param){
    if(param){var tl = param[2], hd = param[1]; return [0, [0, hd, tl]];}
    var _bh_ = caml_call1(Sexplib0_Sexp_conv[7], cst_empty_list);
    return caml_call1(Core[245], _bh_);
   }
   function fold(param, init, f){
    var tl = param[2], hd = param[1], _bg_ = caml_call2(f, init, hd);
    return caml_call3(Core_List[20], tl, _bg_, f);
   }
   var
    foldi = -304398144,
    iter =
      [0,
       -198771759,
       function(param, f){
        var tl = param[2], hd = param[1];
        caml_call1(f, hd);
        return caml_call2(Core_List[19], tl, f);
       }],
    iteri = -304398144,
    length =
      [0,
       -198771759,
       function(param){
        var tl = param[2];
        return 1 + caml_call1(Core_List[45], tl) | 0;
       }],
    include$2 = caml_call1(Core_Comparator[9], [0, compare$2, sexp_of_t$0]),
    comparator = include$2[1];
   function is_empty(param){return 0;}
   var
    From_indexed_container_make =
      caml_call1
       (Base_Indexed_container[8], [0, fold, iter, length, iteri, foldi]),
    mem = From_indexed_container_make[1],
    length$0 = From_indexed_container_make[2],
    iter$0 = From_indexed_container_make[4],
    fold$0 = From_indexed_container_make[5],
    fold_result = From_indexed_container_make[6],
    fold_until = From_indexed_container_make[7],
    exists = From_indexed_container_make[8],
    for_all = From_indexed_container_make[9],
    count = From_indexed_container_make[10],
    sum = From_indexed_container_make[11],
    find = From_indexed_container_make[12],
    find_map = From_indexed_container_make[13],
    to_array = From_indexed_container_make[15],
    min_elt = From_indexed_container_make[16],
    max_elt = From_indexed_container_make[17],
    iteri$0 = From_indexed_container_make[19],
    find_mapi = From_indexed_container_make[24],
    findi = From_indexed_container_make[23],
    counti = From_indexed_container_make[22],
    for_alli = From_indexed_container_make[21],
    existsi = From_indexed_container_make[20],
    foldi$0 = From_indexed_container_make[18];
   function invariant(f, t){return caml_call2(iter$0, t, f);}
   function create(hd, tl){return [0, hd, tl];}
   function singleton(hd){return [0, hd, 0];}
   function cons(x, param){
    var tl = param[2], hd = param[1];
    return [0, x, [0, hd, tl]];
   }
   function nth(param, n){
    var tl = param[2], hd = param[1];
    return 0 === n ? [0, hd] : caml_call2(Core_List[57], tl, n - 1 | 0);
   }
   function nth_exn(t, n){
    var match = nth(t, n);
    if(match){var a = match[1]; return a;}
    var _bf_ = caml_call1(length$0, t);
    return caml_call4(Core[250], _Q_, n, _bf_, 0);
   }
   function mapi(param, f){
    var tl = param[2], hd = param[1], hd$0 = caml_call2(f, 0, hd);
    function _be_(i, x){return caml_call2(f, i + 1 | 0, x);}
    return [0, hd$0, caml_call2(Core_List[41], tl, _be_)];
   }
   function filter_map(param, f){
    var tl = param[2], hd = param[1], match = caml_call1(f, hd);
    if(! match) return caml_call2(Core_List[13], tl, f);
    var hd$0 = match[1];
    return [0, hd$0, caml_call2(Core_List[13], tl, f)];
   }
   function filter_mapi(param, f){
    var tl = param[2], hd = param[1], hd$0 = caml_call2(f, 0, hd);
    function f$0(i, x){return caml_call2(f, i + 1 | 0, x);}
    if(! hd$0) return caml_call2(Core_List[43], tl, f$0);
    var hd$1 = hd$0[1];
    return [0, hd$1, caml_call2(Core_List[43], tl, f$0)];
   }
   function filter(param, f){
    var tl = param[2], hd = param[1];
    return caml_call1(f, hd)
            ? [0, hd, caml_call2(Core_List[12], tl, f)]
            : caml_call2(Core_List[12], tl, f);
   }
   function filteri(param, f){
    var tl = param[2], hd = param[1], include_hd = caml_call2(f, 0, hd);
    function f$0(i, x){return caml_call2(f, i + 1 | 0, x);}
    return include_hd
            ? [0, hd, caml_call2(Core_List[42], tl, f$0)]
            : caml_call2(Core_List[42], tl, f$0);
   }
   function _R_(t, f){
    return mapi(t, function(param, x){return caml_call1(f, x);});
   }
   function map2(t1, t2, f){
    var
     _bc_ = to_list(t2),
     _bd_ = to_list(t1),
     match = caml_call3(Core_List[95], _bd_, _bc_, f);
    if(! match) return 0;
    var x = match[1];
    return [0, of_list_exn(x)];
   }
   function map2_exn(t1, t2, f){
    var _ba_ = to_list(t2), _bb_ = to_list(t1);
    return of_list_exn(caml_call3(Core_List[94], _bb_, _ba_, f));
   }
   function reduce(param, f){
    var tl = param[2], hd = param[1];
    return caml_call3(Core_List[20], tl, hd, f);
   }
   function reverse(param){
    var tl = param[2], hd = param[1], acc = 0, x = hd, xs = tl;
    for(;;){
     if(! xs) return [0, x, acc];
     var
      ys = xs[2],
      y = xs[1],
      acc$0 = [0, x, acc],
      acc = acc$0,
      x = y,
      xs = ys;
    }
   }
   function append(param, l){
    var tl = param[2], hd = param[1];
    return [0, hd, caml_call2(Core_List[10], tl, l)];
   }
   function return$0(hd){return [0, hd, 0];}
   var map = [0, -198771759, _R_];
   function bind(param, f){
    var tl = param[2], hd = param[1], f_hd = caml_call1(f, hd);
    function _a$_(x){return to_list(caml_call1(f, x));}
    return append(f_hd, caml_call2(Core_List[14], tl, _a$_));
   }
   var
    include$3 = caml_call1(Base_Monad[5], [0, bind, return$0, map]),
    symbol_bind = include$3[1],
    symbol_map = include$3[2],
    Monad_infix = include$3[3],
    bind$0 = include$3[4],
    return$1 = include$3[5],
    map$0 = include$3[6],
    join = include$3[7],
    ignore_m = include$3[8],
    all = include$3[9],
    all_unit = include$3[10],
    Let_syntax = include$3[11];
   function unzip(param){
    var
     tl = param[2],
     match = param[1],
     hd2 = match[2],
     hd1 = match[1],
     match$0 = caml_call1(Core_List[103], tl),
     tl2 = match$0[2],
     tl1 = match$0[1];
    return [0, [0, hd1, tl1], [0, hd2, tl2]];
   }
   function concat(t){
    return caml_call2(bind$0, t, function(_a__){return _a__;});
   }
   function zip(t1, t2){
    var
     _a8_ = to_list(t2),
     _a9_ = to_list(t1),
     match = caml_call2(Core_List[105], _a9_, _a8_);
    if(! match) return 0;
    var x = match[1];
    return [0, of_list_exn(x)];
   }
   function zip_exn(t1, t2){
    var _a6_ = to_list(t2), _a7_ = to_list(t1);
    return of_list_exn(caml_call2(Core_List[106], _a7_, _a6_));
   }
   function last(param){
    var tl = param[2], hd = param[1];
    function _a5_(param, elt){return elt;}
    return caml_call3(Core_List[20], tl, hd, _a5_);
   }
   function drop_last(param){
    var tl = param[2], hd = param[1], match = caml_call1(Core_List[139], tl);
    if(! match) return 0;
    var l = match[1];
    return [0, hd, l];
   }
   function to_sequence(t){
    var _a4_ = to_list(t);
    return caml_call1(Core_Sequence[111], _a4_);
   }
   function sort(t, compare){
    var _a3_ = to_list(t);
    return of_list_exn(caml_call2(Core_List[79], _a3_, compare));
   }
   function stable_sort(t, compare){
    var _a2_ = to_list(t);
    return of_list_exn(caml_call2(Core_List[80], _a2_, compare));
   }
   function dedup_and_sort(t, compare){
    var _a1_ = to_list(t);
    return of_list_exn(caml_call2(Core_List[122], _a1_, compare));
   }
   function permute(random_state, t){
    var _a0_ = to_list(t);
    return of_list_exn(caml_call2(Core_List[144], random_state, _a0_));
   }
   function min_elt$0(param, compare){
    var tl = param[2], hd = param[1];
    function _aY_(min, elt){
     var _aZ_ = caml_call2(compare, min, elt);
     return caml_call2(Core[91], _aZ_, 0) ? elt : min;
    }
    return caml_call3(Core_List[20], tl, hd, _aY_);
   }
   function max_elt$0(t, compare){
    return min_elt$0(t, function(x, y){return caml_call2(compare, y, x);});
   }
   function map_add_multi(map, key, data){
    function _aX_(param){
     if(! param) return singleton(data);
     var t = param[1];
     return cons(data, t);
    }
    return caml_call3(Core_Map[43], map, key, _aX_);
   }
   function map_of_container_multi(fold, container, comparator){
    function _aW_(acc, param){
     var data = param[2], key = param[1];
     return map_add_multi(acc, key, data);
    }
    return caml_call3
            (fold, container, caml_call1(Core_Map[4], comparator), _aW_);
   }
   function map_of_alist_multi(alist){
    var _aU_ = Core_List[20];
    return function(_aV_){return map_of_container_multi(_aU_, alist, _aV_);};
   }
   function map_of_sequence_multi(sequence){
    var _aS_ = Core_Sequence[21];
    return function(_aT_){
     return map_of_container_multi(_aS_, sequence, _aT_);};
   }
   function fold_nonempty(param, init, f){
    var tl = param[2], hd = param[1], _aR_ = caml_call1(init, hd);
    return caml_call3(Core_List[20], tl, _aR_, f);
   }
   function map_of_list_with_key_multi(list, comparator, get_key){
    function _aP_(acc, data){
     var key = caml_call1(get_key, data);
     return map_add_multi(acc, key, data);
    }
    var _aQ_ = caml_call1(Core_Map[4], comparator);
    return caml_call3(Core_List[20], list, _aQ_, _aP_);
   }
   function fold_right(param, acc, f){
    var
     tl = param[2],
     hd = param[1],
     acc$0 = caml_call3(Core_List[101], tl, f, acc);
    return caml_call2(f, hd, acc$0);
   }
   function folding_map(param, init, f){
    var
     tl = param[2],
     hd = param[1],
     match = caml_call2(f, init, hd),
     hd$0 = match[2],
     acc = match[1];
    return [0, hd$0, caml_call3(Core_List[90], tl, acc, f)];
   }
   function fold_map(param, acc, f){
    var
     tl = param[2],
     hd = param[1],
     match = caml_call2(f, acc, hd),
     hd$0 = match[2],
     acc$0 = match[1],
     match$0 = caml_call3(Core_List[92], tl, acc$0, f),
     tl$0 = match$0[2],
     acc$1 = match$0[1];
    return [0, acc$1, [0, hd$0, tl$0]];
   }
   function combine_errors(t){
    var _aO_ = to_list(t), match = caml_call1(Core_Result[49], _aO_);
    if(0 === match[0]){var oks = match[1]; return [0, of_list_exn(oks)];}
    var errors = match[1];
    return [1, of_list_exn(errors)];
   }
   function combine_errors_unit(t){
    var _aN_ = to_list(t), ok = caml_call1(Core_Result[50], _aN_);
    if(0 === ok[0]) return ok;
    var errors = ok[1];
    return [1, of_list_exn(errors)];
   }
   function combine_or_errors(t){
    var _aM_ = to_list(t), e = caml_call1(Core_Or_error[56], _aM_);
    if(0 !== e[0]) return e;
    var oks = e[1];
    return [0, of_list_exn(oks)];
   }
   function combine_or_errors_unit(t){
    var _aL_ = to_list(t);
    return caml_call1(Core_Or_error[57], _aL_);
   }
   function validate(name, check, t){
    var _aK_ = to_list(t);
    return caml_call3(Validate[29], name, check, _aK_);
   }
   function validate_indexed(check, t){
    var _aJ_ = to_list(t);
    return caml_call2(Validate[28], check, _aJ_);
   }
   function rev_append(xs, acc){
    var xs$0 = xs, acc$0 = acc;
    for(;;){
     if(! xs$0) return acc$0;
     var
      tl = xs$0[2],
      hd = xs$0[1],
      acc$1 = cons(hd, acc$0),
      xs$0 = tl,
      acc$0 = acc$1;
    }
   }
   function init(n, f){
    if(caml_call2(Core[92], n, 1)) caml_call3(Core[250], _S_, n, 0);
    function _aI_(i){return caml_call1(f, i + 1 | 0);}
    var
     tl = caml_call2(Core_List[40], n - 1 | 0, _aI_),
     hd = caml_call1(f, 0);
    return [0, hd, tl];
   }
   function cartesian_product(t$0, t){
    var _aG_ = to_list(t), _aH_ = to_list(t$0);
    return of_list_exn(caml_call2(Core_List[143], _aH_, _aG_));
   }
   function to_rev_list(param){
    var tl = param[2], hd = param[1];
    return [0, hd, tl];
   }
   function rev_append$0(param, xs){
    var tl = param[2], hd = param[1];
    return rev_append(tl, [0, hd, xs]);
   }
   function rev(t){return rev_append$0(t, 0);}
   function rev_mapi(param, f){
    var
     tl$0 = param[2],
     hd$0 = param[1],
     acc$1 = [0, caml_call2(f, 0, hd$0), 0],
     i = 1,
     xs = tl$0,
     acc = acc$1;
    for(;;){
     if(! xs) return acc;
     var
      tl = xs[2],
      hd = xs[1],
      acc$0 = cons(caml_call2(f, i, hd), acc),
      i$0 = i + 1 | 0,
      i = i$0,
      xs = tl,
      acc = acc$0;
    }
   }
   function rev_map(t, f){
    return rev_mapi(t, function(param, x){return caml_call1(f, x);});
   }
   function cons$0(x, t){return [0, x, to_rev_list(t)];}
   function sexp_of_t$1(sexp_of_a, t){
    var _aF_ = to_rev_list(t);
    return caml_call2(Reversed_list[9][1], sexp_of_a, _aF_);
   }
   var With_sexp_of = [0, sexp_of_t$1];
   function sexp_of_t$2(sexp_of_a, t){
    var _aE_ = to_rev_list(t);
    return caml_call2(Reversed_list[10][1], sexp_of_a, _aE_);
   }
   var With_rev_sexp_of = [0, sexp_of_t$2];
   function rev$0(param){
    var tl = param[2], hd = param[1], _aD_ = caml_call1(Core_Fn[6], cons$0);
    return caml_call3(Core_List[20], tl, [0, hd, 0], _aD_);
   }
   function flag(arg_type){
    function _aB_(param){
     var more = param[2], one = param[1];
     return [0, one, more];
    }
    var _aC_ = caml_call1(Core_Command_internal[20][32], arg_type);
    return caml_call2(Core_Command_internal[20][41], _aC_, _aB_);
   }
   function comma_separated_argtype
   (key, strip_whitespace, unique_values, arg_type){
    var
     _aA_ =
       caml_call5
        (Core_Command_internal[19][9],
         _T_,
         0,
         strip_whitespace,
         unique_values,
         arg_type);
    return caml_call3(Core_Command_internal[19][3], key, _aA_, of_list_exn);
   }
   function compare$3(cmp_a, a_100, b_101){
    function _az_(a_102, b_103){return caml_call2(cmp_a, a_102, b_103);}
    return caml_call3(Core[466], _az_, a_100, b_101);
   }
   function equal$3(cmp_a, a_104, b_105){
    function _ay_(a_106, b_107){return caml_call2(cmp_a, a_106, b_107);}
    return caml_call3(Core[468], _ay_, a_104, b_105);
   }
   var t_of_sexp$1 = Core[473], sexp_of_t$3 = Core[472];
   function t_sexp_grammar$0(a_sexp_grammar){
    return caml_call1(Core[474], a_sexp_grammar);
   }
   var hash_fold_t$2 = Core[471];
   function quickcheck_generator$0(generator_115){return caml_call1(Core[129], generator_115);
   }
   function quickcheck_observer$0(observer_114){return caml_call1(Core[134], observer_114);
   }
   function quickcheck_shrinker$0(shrinker_113){return caml_call1(Core[139], shrinker_113);
   }
   var
    Typename_of_t$0 = caml_call1(Typerep_lib_Make_typename[2], [0, name$0]),
    typename_of_t$0 = Typename_of_t$0[2];
   function typerep_of_t$0(of_a){
    var name_of_t = caml_call1(Typename_of_t$0[1], of_a);
    return [9,
            [0,
             name_of_t,
             [0, [246, function(_ax_){return caml_call1(Core[475], of_a);}]]]];
   }
   var none = 0;
   function some(value){return value;}
   function unchecked_value(t){return t;}
   function is_none(t){return t === 0 ? 1 : 0;}
   function is_some(t){return 1 - (t === 0 ? 1 : 0);}
   function of_option(param){
    if(! param) return none;
    var value = param[1];
    return value;
   }
   function value_exn(l){
    if(l) return l;
    var
     _aw_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Nonempty_list_Option_value);
    return caml_call1(Core[261], _aw_);
   }
   function value(t, default$0){
    return runtime.caml_csel_value(t === 0 ? 1 : 0, default$0, t);
   }
   var
    Optional_syntax = [0, is_none, unchecked_value],
    Optional_syntax$0 = [0, Optional_syntax];
   caml_call1(Ppx_inline_test_lib[7], cst_nonempty_list);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Nonempty_list);
   var
    Nonempty_list =
      [0,
       compare$2,
       equal$2,
       t_of_sexp$0,
       sexp_of_t$0,
       t_sexp_grammar,
       hash_fold_t$1,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       typerep_of_t,
       typename_of_t,
       bin_shape_t$5,
       bin_size_t$5,
       bin_write_t$5,
       bin_read_t$12,
       bin_read_t$11,
       bin_writer_t$2,
       bin_reader_t$2,
       bin_t$2,
       globalize,
       comparator,
       invariant,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       mem,
       length$0,
       is_empty,
       iter$0,
       fold$0,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi$0,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       create,
       init,
       of_list,
       of_list_error,
       of_list_exn,
       singleton,
       cons,
       hd,
       tl,
       nth,
       nth_exn,
       reduce,
       reverse,
       append,
       unzip,
       zip,
       zip_exn,
       mapi,
       map2,
       map2_exn,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat,
       bind$0,
       last,
       drop_last,
       to_sequence,
       sort,
       stable_sort,
       dedup_and_sort,
       permute,
       iteri$0,
       cartesian_product,
       fold_nonempty,
       fold_right,
       folding_map,
       fold_map,
       min_elt$0,
       max_elt$0,
       map_add_multi,
       map_of_alist_multi,
       map_of_sequence_multi,
       map_of_list_with_key_multi,
       combine_errors,
       combine_errors_unit,
       combine_or_errors,
       combine_or_errors_unit,
       validate_indexed,
       validate,
       flag,
       comma_separated_argtype,
       [0,
        compare$3,
        equal$3,
        t_of_sexp$1,
        sexp_of_t$3,
        t_sexp_grammar$0,
        hash_fold_t$2,
        quickcheck_generator$0,
        quickcheck_observer$0,
        quickcheck_shrinker$0,
        typerep_of_t$0,
        typename_of_t$0,
        none,
        some,
        is_none,
        is_some,
        value,
        value_exn,
        unchecked_value,
        of_list,
        of_option,
        Optional_syntax$0],
       [0,
        cons$0,
        to_rev_list,
        rev,
        rev_append$0,
        rev_map,
        rev_mapi,
        With_sexp_of,
        With_rev_sexp_of],
       rev$0,
       rev_append,
       [0,
        bin_shape_t$0,
        bin_size_t$0,
        bin_write_t$0,
        bin_read_t$1,
        bin_read_t$2,
        bin_writer_t,
        bin_reader_t,
        bin_t,
        compare,
        equal,
        hash_fold_t,
        t_of_sexp$0,
        sexp_of_t$0,
        t_sexp_grammar],
       [0,
        [0,
         bin_shape_t$0,
         bin_size_t$0,
         bin_write_t$0,
         bin_read_t$1,
         bin_read_t$2,
         bin_writer_t,
         bin_reader_t,
         bin_t,
         compare,
         equal,
         t_of_sexp$0,
         sexp_of_t$0,
         t_sexp_grammar,
         hash_fold_t,
         stable_witness$0],
        [0,
         bin_shape_t$2,
         bin_size_t$2,
         bin_write_t$2,
         bin_read_t$5,
         bin_read_t$6,
         bin_writer_t$0,
         bin_reader_t$0,
         bin_t$0,
         compare$0,
         equal$0,
         t_of_sexp$0,
         sexp_of_t$0,
         hash_fold_t$0,
         stable_witness$2],
        [0,
         bin_shape_t$4,
         bin_size_t$4,
         bin_write_t$4,
         bin_read_t$9,
         bin_read_t$10,
         bin_writer_t$1,
         bin_reader_t$1,
         bin_t$1,
         compare$1,
         equal$1,
         t_of_sexp$0,
         sexp_of_t$0,
         stable_witness$4]]];
   runtime.caml_register_global(114, Nonempty_list, cst_Nonempty_list$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJub25lbXB0eV9saXN0LmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJuYW1lIiwibmFtZSQwIiwiY29tcGFyZSIsImNtcF9hIiwiYV8wMDEiLCJiXzAwMiIsImJfMDA2IiwiYl8wMDQiLCJhXzAwNSIsImFfMDAzIiwibiIsImFfMDA3IiwiYl8wMDgiLCJlcXVhbCIsImFfMDA5IiwiYl8wMTAiLCJiXzAxNCIsImJfMDEyIiwiYV8wMTMiLCJhXzAxMSIsImFfMDE1IiwiYl8wMTYiLCJoYXNoX2ZvbGRfdCIsImhhc2hfZm9sZF9hIiwiaHN2IiwiYXJnIiwiYTEiLCJhMCIsImhzdiQwIiwidG9fbGlzdCIsInRsIiwiaGQiLCJvZl9saXN0X2V4biIsImdyb3VwIiwiYmluX3NoYXBlX3QiLCJhIiwiYmluX3NpemVfdCIsInNpemVfb2ZfYSIsInYiLCJiaW5fd3JpdGVfdCIsIndyaXRlX2EiLCJidWYiLCJwb3MiLCJiaW5fcmVhZF90Iiwib2ZfYSIsInBvc19yZWYiLCJ2aW50IiwiYmluX3JlYWRfdCQwIiwidF9vZl9zZXhwIiwic2V4cF9vZl90Iiwic3RhYmxlX3dpdG5lc3MiLCJhX3N0YWJsZV93aXRuZXNzIiwiY2FsbGVyX2lkZW50aXR5IiwidF9vZl9zZXhwJDAiLCJzZXhwX29mX3QkMCIsInRfc2V4cF9ncmFtbWFyIiwicGFyYW0iLCJzdGFibGVfd2l0bmVzcyQwIiwid2l0bmVzcyIsImNvbXBhcmUkMCIsImFfMDIyIiwiYl8wMjMiLCJiXzAyNyIsImJfMDI1IiwiYV8wMjYiLCJhXzAyNCIsImFfMDI4IiwiYl8wMjkiLCJlcXVhbCQwIiwiYV8wMzAiLCJiXzAzMSIsImJfMDM1IiwiYl8wMzMiLCJhXzAzNCIsImFfMDMyIiwiYV8wMzYiLCJiXzAzNyIsImhhc2hfZm9sZF90JDAiLCJncm91cCQwIiwiYmluX3NoYXBlX3QkMSIsImJpbl9zaXplX3QkMSIsInYyIiwidjEiLCJzaXplIiwiYmluX3dyaXRlX3QkMSIsInBvcyQwIiwiYmluX3JlYWRfdCQzIiwiYmluX3JlYWRfdCQ0Iiwidl9oZCIsInZfdGwiLCJzdGFibGVfd2l0bmVzcyQxIiwib2Zfbm9uZW1wdHlfbGlzdCIsInRvX25vbmVtcHR5X2xpc3QiLCJzdGFibGVfd2l0bmVzcyQyIiwiY29tcGFyZSQxIiwiYV8wNDIiLCJiXzA0MyIsImJfMDQ3IiwiYl8wNDUiLCJhXzA0NiIsImFfMDQ0IiwiYV8wNDgiLCJiXzA0OSIsImVxdWFsJDEiLCJhXzA1MCIsImJfMDUxIiwiYl8wNTUiLCJiXzA1MyIsImFfMDU0IiwiYV8wNTIiLCJhXzA1NiIsImJfMDU3IiwiZ3JvdXAkMSIsImJpbl9zaGFwZV90JDMiLCJiaW5fc2l6ZV90JDMiLCJiaW5fd3JpdGVfdCQzIiwiYmluX3JlYWRfdCQ3IiwiYmluX3JlYWRfdCQ4Iiwic3RhYmxlX3dpdG5lc3MkMyIsIm9mX25vbmVtcHR5X2xpc3QkMCIsInRvX25vbmVtcHR5X2xpc3QkMCIsInN0YWJsZV93aXRuZXNzJDQiLCJjb21wYXJlJDIiLCJhXzA2NiIsImJfMDY3IiwiYl8wNzEiLCJiXzA2OSIsImFfMDcwIiwiYV8wNjgiLCJhXzA3MiIsImJfMDczIiwiZXF1YWwkMiIsImFfMDc0IiwiYl8wNzUiLCJiXzA3OSIsImJfMDc3IiwiYV8wNzgiLCJhXzA3NiIsImFfMDgwIiwiYl8wODEiLCJoYXNoX2ZvbGRfdCQxIiwicXVpY2tjaGVja19nZW5lcmF0b3IiLCJnZW5lcmF0b3JfMDkxIiwic2l6ZV8wOTIiLCJyYW5kb21fMDkzIiwicXVpY2tjaGVja19vYnNlcnZlciIsIm9ic2VydmVyXzA4NSIsInhfMDg2Iiwic2l6ZV8wODciLCJoYXNoXzA4OCIsInhfMDkwIiwieF8wODkiLCJoYXNoXzA4OCQwIiwiaGFzaF8wODgkMSIsImhhc2hfMDg4JDIiLCJxdWlja2NoZWNrX3Nocmlua2VyIiwic2hyaW5rZXJfMDgyIiwieF8wODQiLCJ4XzA4MyIsInR5cGVuYW1lX29mX3QiLCJ0eXBlcmVwX29mX3QiLCJuYW1lX29mX3QiLCJ2MCIsInRhZzAiLCJ0eXBlbmFtZSIsInRhZ3MiLCJwb2x5bW9ycGhpYyIsInZhbHVlIiwiZ3JvdXAkMiIsImJpbl9zaGFwZV90JDUiLCJiaW5fc2l6ZV90JDUiLCJiaW5fd3JpdGVfdCQ1IiwicG9zJDEiLCJiaW5fd3JpdGVyX3QkMiIsImJpbl93cml0ZXJfYSIsImJpbl9yZWFkX3QkMTEiLCJiaW5fcmVhZF90JDEyIiwiYXJnXzEiLCJhcmdfMiIsImJpbl9yZWFkZXJfdCQyIiwiYmluX3JlYWRlcl9hIiwidnRhZyIsImJpbl90JDIiLCJiaW5fYSIsImdsb2JhbGl6ZSIsImdsb2JhbGl6ZV9hXzA5NSIsInhfMDk2IiwiYXJnXzA5NyIsImFyZ18wOTkiLCJvZl9saXN0Iiwib2ZfbGlzdF9lcnJvciIsImZvbGQiLCJpbml0IiwiZiIsImZvbGRpIiwiaXRlciIsIml0ZXJpIiwibGVuZ3RoIiwiaXNfZW1wdHkiLCJtZW0iLCJsZW5ndGgkMCIsIml0ZXIkMCIsImZvbGQkMCIsImZvbGRfcmVzdWx0IiwiZm9sZF91bnRpbCIsImV4aXN0cyIsImZvcl9hbGwiLCJjb3VudCIsInN1bSIsImZpbmQiLCJmaW5kX21hcCIsInRvX2FycmF5IiwibWluX2VsdCIsIm1heF9lbHQiLCJpdGVyaSQwIiwiZmluZF9tYXBpIiwiZmluZGkiLCJjb3VudGkiLCJmb3JfYWxsaSIsImV4aXN0c2kiLCJmb2xkaSQwIiwiaW52YXJpYW50IiwidCIsImNyZWF0ZSIsInNpbmdsZXRvbiIsImNvbnMiLCJ4IiwibnRoIiwibnRoX2V4biIsIm1hcGkiLCJoZCQwIiwiaSIsImZpbHRlcl9tYXAiLCJmaWx0ZXJfbWFwaSIsImYkMCIsImhkJDEiLCJmaWx0ZXIiLCJmaWx0ZXJpIiwiaW5jbHVkZV9oZCIsIm1hcDIiLCJ0MSIsInQyIiwibWFwMl9leG4iLCJyZWR1Y2UiLCJyZXZlcnNlIiwiYWNjIiwieHMiLCJ5cyIsInkiLCJhY2MkMCIsImFwcGVuZCIsImwiLCJyZXR1cm4kMCIsIm1hcCIsImJpbmQiLCJmX2hkIiwidW56aXAiLCJoZDIiLCJoZDEiLCJ0bDIiLCJ0bDEiLCJjb25jYXQiLCJ6aXAiLCJ6aXBfZXhuIiwibGFzdCIsImVsdCIsImRyb3BfbGFzdCIsInRvX3NlcXVlbmNlIiwic29ydCIsInN0YWJsZV9zb3J0IiwiZGVkdXBfYW5kX3NvcnQiLCJwZXJtdXRlIiwicmFuZG9tX3N0YXRlIiwibWluX2VsdCQwIiwibWluIiwibWF4X2VsdCQwIiwibWFwX2FkZF9tdWx0aSIsImtleSIsImRhdGEiLCJtYXBfb2ZfY29udGFpbmVyX211bHRpIiwiY29udGFpbmVyIiwiY29tcGFyYXRvciIsIm1hcF9vZl9hbGlzdF9tdWx0aSIsImFsaXN0IiwibWFwX29mX3NlcXVlbmNlX211bHRpIiwic2VxdWVuY2UiLCJmb2xkX25vbmVtcHR5IiwibWFwX29mX2xpc3Rfd2l0aF9rZXlfbXVsdGkiLCJsaXN0IiwiZ2V0X2tleSIsImZvbGRfcmlnaHQiLCJmb2xkaW5nX21hcCIsImZvbGRfbWFwIiwidGwkMCIsImFjYyQxIiwiY29tYmluZV9lcnJvcnMiLCJva3MiLCJlcnJvcnMiLCJjb21iaW5lX2Vycm9yc191bml0Iiwib2siLCJjb21iaW5lX29yX2Vycm9ycyIsImUiLCJjb21iaW5lX29yX2Vycm9yc191bml0IiwidmFsaWRhdGUiLCJjaGVjayIsInZhbGlkYXRlX2luZGV4ZWQiLCJyZXZfYXBwZW5kIiwieHMkMCIsImNhcnRlc2lhbl9wcm9kdWN0IiwidCQwIiwidG9fcmV2X2xpc3QiLCJyZXZfYXBwZW5kJDAiLCJyZXYiLCJyZXZfbWFwaSIsImkkMCIsInJldl9tYXAiLCJjb25zJDAiLCJzZXhwX29mX3QkMSIsInNleHBfb2ZfYSIsInNleHBfb2ZfdCQyIiwicmV2JDAiLCJmbGFnIiwiYXJnX3R5cGUiLCJtb3JlIiwib25lIiwiY29tbWFfc2VwYXJhdGVkX2FyZ3R5cGUiLCJzdHJpcF93aGl0ZXNwYWNlIiwidW5pcXVlX3ZhbHVlcyIsImNvbXBhcmUkMyIsImFfMTAwIiwiYl8xMDEiLCJhXzEwMiIsImJfMTAzIiwiZXF1YWwkMyIsImFfMTA0IiwiYl8xMDUiLCJhXzEwNiIsImJfMTA3IiwidF9vZl9zZXhwJDEiLCJzZXhwX29mX3QkMyIsInRfc2V4cF9ncmFtbWFyJDAiLCJhX3NleHBfZ3JhbW1hciIsImhhc2hfZm9sZF90JDIiLCJxdWlja2NoZWNrX2dlbmVyYXRvciQwIiwiZ2VuZXJhdG9yXzExNSIsInF1aWNrY2hlY2tfb2JzZXJ2ZXIkMCIsIm9ic2VydmVyXzExNCIsInF1aWNrY2hlY2tfc2hyaW5rZXIkMCIsInNocmlua2VyXzExMyIsInR5cGVuYW1lX29mX3QkMCIsInR5cGVyZXBfb2ZfdCQwIiwibm9uZSIsInNvbWUiLCJ1bmNoZWNrZWRfdmFsdWUiLCJpc19ub25lIiwiaXNfc29tZSIsIm9mX29wdGlvbiIsInZhbHVlX2V4biIsImRlZmF1bHQkMCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9jb3JlX2tlcm5lbC9ub25lbXB0eV9saXN0L25vbmVtcHR5X2xpc3QubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7SUErSkVBOztJQStVQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F6ZUksU0FBQUMsUUFBQUMsT0FBQUMsT0FBQUM7SUFBQSxHQUFBRCxVQUFBQyxPQUFBO0lBQTZCO0tBQVZDLFFBQW5CRDtLQUFtQkUsUUFBbkJGO0tBQW1CRyxRQUFuQko7S0FBbUJLLFFBQW5CTDtLQUE2Qk0sSUFBQSxXQUE3QlAsT0FBbUJNLE9BQUFGO2FBQVVHLEdBQUEsT0FBQUE7a0JBQUtDLE9BQUFDLE9BQUEsT0FBQSxXQUFsQ1QsT0FBa0NRLE9BQUFDLE9BQUU7SUFBQyxPQUFBLG1DQUFsQkosT0FBQUY7R0FBd0Q7WUFBM0VPLE1BQUFWLE9BQUFXLE9B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U0FHSWxEO1NBREFDO1NBdUJGbUU7OztFIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiBDb3JlLkNvcmVfc3RhYmxlXG5cbm1vZHVsZSBTdGFibGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIFYzID0gc3RydWN0XG4gICAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAoIDo6ICkgb2YgJ2EgKiAnYSBsaXN0IFtAQGRlcml2aW5nIGNvbXBhcmUsIGVxdWFsLCBoYXNoXVxuXG4gICAgICBsZXQgdG9fbGlzdCAoaGQgOjogdGwpIDogXyBsaXN0ID0gaGQgOjogdGxcblxuICAgICAgbGV0IG9mX2xpc3RfZXhuIDogXyBsaXN0IC0+IF8gdCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgW10gLT4gQ29yZS5yYWlzZV9zIFslbWVzc2FnZSBcIk5vbmVtcHR5X2xpc3Qub2ZfbGlzdF9leG46IGVtcHR5IGxpc3RcIl1cbiAgICAgICAgfCBoZCA6OiB0bCAtPiBoZCA6OiB0bFxuICAgICAgOztcbiAgICBlbmRcblxuICAgIGluY2x1ZGUgVFxuXG4gICAgbW9kdWxlIEZvcm1hdCA9IHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgbGlzdCBbQEBkZXJpdmluZyBiaW5faW8sIHNleHAsIHN0YWJsZV93aXRuZXNzXVxuICAgIGVuZFxuXG4gICAgaW5jbHVkZVxuICAgICAgQmluYWJsZS5PZl9iaW5hYmxlMS5WMlxuICAgICAgICAoRm9ybWF0KVxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgaW5jbHVkZSBUXG5cbiAgICAgICAgICBsZXQgdG9fYmluYWJsZSA9IHRvX2xpc3RcbiAgICAgICAgICBsZXQgb2ZfYmluYWJsZSA9IG9mX2xpc3RfZXhuXG5cbiAgICAgICAgICBsZXQgY2FsbGVyX2lkZW50aXR5ID1cbiAgICAgICAgICAgIEJpbl9wcm90LlNoYXBlLlV1aWQub2Zfc3RyaW5nIFwiOWE2M2FhZWUtODJlMC0xMWVhLThmYjYtYWEwMDAwNWM2MTg0XCJcbiAgICAgICAgICA7O1xuICAgICAgICBlbmQpXG5cbiAgICBpbmNsdWRlXG4gICAgICBTZXhwYWJsZS5PZl9zZXhwYWJsZTEuVjFcbiAgICAgICAgKEZvcm1hdClcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIGluY2x1ZGUgVFxuXG4gICAgICAgICAgbGV0IHRvX3NleHBhYmxlID0gdG9fbGlzdFxuICAgICAgICAgIGxldCBvZl9zZXhwYWJsZSA9IG9mX2xpc3RfZXhuXG4gICAgICAgIGVuZClcblxuICAgIGxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoeyB1bnR5cGVkID0gZWxlbWVudCB9IDogWyVzZXhwX2dyYW1tYXI6IGFdKVxuICAgICAgOiBbJXNleHBfZ3JhbW1hcjogYSB0XVxuICAgICAgPVxuICAgICAgeyB1bnR5cGVkID0gTGlzdCAoQ29ucyAoZWxlbWVudCwgTWFueSBlbGVtZW50KSkgfVxuICAgIDs7XG5cbiAgICBsZXQgc3RhYmxlX3dpdG5lc3MgKHR5cGUgYSkgOiBhIFN0YWJsZV93aXRuZXNzLnQgLT4gYSB0IFN0YWJsZV93aXRuZXNzLnQgPVxuICAgICAgZnVuIHdpdG5lc3MgLT5cbiAgICAgIGxldCBtb2R1bGUgU3RhYmxlX3dpdG5lc3MgPSBTdGFibGVfd2l0bmVzcy5PZl9zZXJpYWxpemFibGUxIChGb3JtYXQpIChUKSBpblxuICAgICAgU3RhYmxlX3dpdG5lc3Mub2Zfc2VyaWFsaXphYmxlIEZvcm1hdC5zdGFibGVfd2l0bmVzcyBvZl9saXN0X2V4biB0b19saXN0IHdpdG5lc3NcbiAgICA7O1xuXG4gICAgbGV0JWV4cGVjdF90ZXN0IF8gPVxuICAgICAgcHJpbnRfZW5kbGluZSBbJWJpbl9kaWdlc3Q6IGludCB0XTtcbiAgICAgIFslZXhwZWN0IHt8IGVhYTVjMTUzNWVhNWMxNjkxMjkxYjNiZGJiZDdiMDE0IHx9XVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBWMiA9IHN0cnVjdFxuICAgIG1vZHVsZSBUID0gc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgVjMudCA9ICggOjogKSBvZiAnYSAqICdhIGxpc3RcbiAgICAgIFtAQGRlcml2aW5nIGNvbXBhcmUsIGVxdWFsLCBoYXNoXVxuXG4gICAgICBsZXQgc2V4cF9vZl90ID0gVjMuc2V4cF9vZl90XG4gICAgICBsZXQgdF9vZl9zZXhwID0gVjMudF9vZl9zZXhwXG4gICAgZW5kXG5cbiAgICBpbmNsdWRlIFRcblxuICAgIG1vZHVsZSBSZWNvcmRfZm9ybWF0ID0gc3RydWN0XG4gICAgICB0eXBlICdhIHQgPVxuICAgICAgICB7IGhkIDogJ2FcbiAgICAgICAgOyB0bCA6ICdhIGxpc3RcbiAgICAgICAgfVxuICAgICAgW0BAZGVyaXZpbmcgYmluX2lvLCBjb21wYXJlLCBzdGFibGVfd2l0bmVzc11cblxuICAgICAgbGV0IG9mX25vbmVtcHR5X2xpc3QgKGhkIDo6IHRsKSA9IHsgaGQ7IHRsIH1cbiAgICAgIGxldCB0b19ub25lbXB0eV9saXN0IHsgaGQ7IHRsIH0gPSBoZCA6OiB0bFxuICAgIGVuZFxuXG4gICAgaW5jbHVkZVxuICAgICAgQmluYWJsZS5PZl9iaW5hYmxlMS5WMSBbQGFsZXJ0IFwiLWxlZ2FjeVwiXVxuICAgICAgICAoUmVjb3JkX2Zvcm1hdClcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIGluY2x1ZGUgVFxuXG4gICAgICAgICAgbGV0IHRvX2JpbmFibGUgPSBSZWNvcmRfZm9ybWF0Lm9mX25vbmVtcHR5X2xpc3RcbiAgICAgICAgICBsZXQgb2ZfYmluYWJsZSA9IFJlY29yZF9mb3JtYXQudG9fbm9uZW1wdHlfbGlzdFxuICAgICAgICBlbmQpXG5cbiAgICBsZXQgc3RhYmxlX3dpdG5lc3MgKHR5cGUgYSkgOiBhIFN0YWJsZV93aXRuZXNzLnQgLT4gYSB0IFN0YWJsZV93aXRuZXNzLnQgPVxuICAgICAgZnVuIHdpdG5lc3MgLT5cbiAgICAgIGxldCBtb2R1bGUgU3RhYmxlX3dpdG5lc3MgPSBTdGFibGVfd2l0bmVzcy5PZl9zZXJpYWxpemFibGUxIChSZWNvcmRfZm9ybWF0KSAoVCkgaW5cbiAgICAgIFN0YWJsZV93aXRuZXNzLm9mX3NlcmlhbGl6YWJsZVxuICAgICAgICBSZWNvcmRfZm9ybWF0LnN0YWJsZV93aXRuZXNzXG4gICAgICAgIFJlY29yZF9mb3JtYXQudG9fbm9uZW1wdHlfbGlzdFxuICAgICAgICBSZWNvcmRfZm9ybWF0Lm9mX25vbmVtcHR5X2xpc3RcbiAgICAgICAgd2l0bmVzc1xuICAgIDs7XG5cbiAgICBsZXQlZXhwZWN0X3Rlc3QgXyA9XG4gICAgICBwcmludF9lbmRsaW5lIFslYmluX2RpZ2VzdDogaW50IHRdO1xuICAgICAgWyVleHBlY3Qge3wgMmFlZGUyZTliMDM3NTRmNWRmYTVmMWE2MTg3N2IzMzAgfH1dXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIFYxID0gc3RydWN0XG4gICAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIFYyLnQgPSAoIDo6ICkgb2YgJ2EgKiAnYSBsaXN0IFtAQGRlcml2aW5nIGNvbXBhcmUsIGVxdWFsXVxuXG4gICAgICBsZXQgc2V4cF9vZl90ID0gVjIuc2V4cF9vZl90XG4gICAgICBsZXQgdF9vZl9zZXhwID0gVjIudF9vZl9zZXhwXG4gICAgZW5kXG5cbiAgICBpbmNsdWRlIFRcblxuICAgIG1vZHVsZSBQYWlyX2Zvcm1hdCA9IHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgKiAnYSBsaXN0IFtAQGRlcml2aW5nIGJpbl9pbywgY29tcGFyZSwgc3RhYmxlX3dpdG5lc3NdXG5cbiAgICAgIGxldCBvZl9ub25lbXB0eV9saXN0IChoZCA6OiB0bCkgPSBoZCwgdGxcbiAgICAgIGxldCB0b19ub25lbXB0eV9saXN0IChoZCwgdGwpID0gaGQgOjogdGxcbiAgICBlbmRcblxuICAgIGluY2x1ZGVcbiAgICAgIEJpbmFibGUuT2ZfYmluYWJsZTEuVjEgW0BhbGVydCBcIi1sZWdhY3lcIl1cbiAgICAgICAgKFBhaXJfZm9ybWF0KVxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgaW5jbHVkZSBUXG5cbiAgICAgICAgICBsZXQgdG9fYmluYWJsZSA9IFBhaXJfZm9ybWF0Lm9mX25vbmVtcHR5X2xpc3RcbiAgICAgICAgICBsZXQgb2ZfYmluYWJsZSA9IFBhaXJfZm9ybWF0LnRvX25vbmVtcHR5X2xpc3RcbiAgICAgICAgZW5kKVxuXG4gICAgbGV0IHN0YWJsZV93aXRuZXNzICh0eXBlIGEpIDogYSBTdGFibGVfd2l0bmVzcy50IC0+IGEgdCBTdGFibGVfd2l0bmVzcy50ID1cbiAgICAgIGZ1biB3aXRuZXNzIC0+XG4gICAgICBsZXQgbW9kdWxlIFN0YWJsZV93aXRuZXNzID0gU3RhYmxlX3dpdG5lc3MuT2Zfc2VyaWFsaXphYmxlMSAoUGFpcl9mb3JtYXQpIChUKSBpblxuICAgICAgU3RhYmxlX3dpdG5lc3Mub2Zfc2VyaWFsaXphYmxlXG4gICAgICAgIFBhaXJfZm9ybWF0LnN0YWJsZV93aXRuZXNzXG4gICAgICAgIFBhaXJfZm9ybWF0LnRvX25vbmVtcHR5X2xpc3RcbiAgICAgICAgUGFpcl9mb3JtYXQub2Zfbm9uZW1wdHlfbGlzdFxuICAgICAgICB3aXRuZXNzXG4gICAgOztcblxuICAgIGxldCVleHBlY3RfdGVzdCBfID1cbiAgICAgIHByaW50X2VuZGxpbmUgWyViaW5fZGlnZXN0OiBpbnQgdF07XG4gICAgICBbJWV4cGVjdCB7fCBmMjc4NzFlZjQyOGFlZjI5MjVmMThkNmJlNjg3YmY5YyB8fV1cbiAgICA7O1xuICBlbmRcbmVuZFxuXG5vcGVuIENvcmVcbm1vZHVsZSBVbnN0YWJsZSA9IFN0YWJsZS5WM1xuXG5tb2R1bGUgVCcgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgU3RhYmxlLlYzLnQgPSAoIDo6ICkgb2YgJ2EgKiAnYSBsaXN0XG4gIFtAQGRlcml2aW5nIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBxdWlja2NoZWNrLCB0eXBlcmVwLCBiaW5faW8sIGdsb2JhbGl6ZV1cblxuICBsZXQgc2V4cF9vZl90ID0gU3RhYmxlLlYzLnNleHBfb2ZfdFxuICBsZXQgdF9vZl9zZXhwID0gU3RhYmxlLlYzLnRfb2Zfc2V4cFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgPSBTdGFibGUuVjMudF9zZXhwX2dyYW1tYXJcbiAgbGV0IHRvX2xpc3QgPSBTdGFibGUuVjMudG9fbGlzdFxuICBsZXQgb2ZfbGlzdF9leG4gPSBTdGFibGUuVjMub2ZfbGlzdF9leG5cbiAgbGV0IGhkIChoZCA6OiBfKSA9IGhkXG4gIGxldCB0bCAoXyA6OiB0bCkgPSB0bFxuXG4gIGxldCBvZl9saXN0ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IGhkIDo6IHRsIC0+IFNvbWUgKGhkIDo6IHRsKVxuICA7O1xuXG4gIGxldCBvZl9saXN0X2Vycm9yID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IENvcmUuZXJyb3JfcyBbJW1lc3NhZ2UgXCJlbXB0eSBsaXN0XCJdXG4gICAgfCBoZCA6OiB0bCAtPiBPayAoaGQgOjogdGwpXG4gIDs7XG5cbiAgbGV0IGZvbGQgKGhkIDo6IHRsKSB+aW5pdCB+ZiA9IExpc3QuZm9sZCB0bCB+aW5pdDooZiBpbml0IGhkKSB+ZlxuICBsZXQgZm9sZGkgPSBgRGVmaW5lX3VzaW5nX2ZvbGRcblxuICBsZXQgaXRlciA9XG4gICAgYEN1c3RvbVxuICAgICAgKGZ1biAoaGQgOjogdGwpIH5mIC0+XG4gICAgICAgIGYgaGQ7XG4gICAgICAgIExpc3QuaXRlciB0bCB+ZilcbiAgOztcblxuICBsZXQgaXRlcmkgPSBgRGVmaW5lX3VzaW5nX2ZvbGRcbiAgbGV0IGxlbmd0aCA9IGBDdXN0b20gKGZ1biAoXyA6OiB0bCkgLT4gMSArIExpc3QubGVuZ3RoIHRsKVxuZW5kXG5cbmluY2x1ZGUgVCdcbmluY2x1ZGUgQ29tcGFyYXRvci5EZXJpdmVkIChUJylcblxuaW5jbHVkZSBzdHJ1Y3RcbiAgbGV0IGlzX2VtcHR5IF8gPSBmYWxzZVxuXG4gICgqIFtDb250YWluZXIuTWFrZV0gd291bGQgZm9sZCB0aHJvdWdoIHRoZSB0YWlsIGFuZCByZS1jb25zIGV2ZXJ5IGVsdC4gKilcbiAgbGV0IHRvX2xpc3QgPSB0b19saXN0XG5cbiAgbW9kdWxlIEZyb21faW5kZXhlZF9jb250YWluZXJfbWFrZSA9IEluZGV4ZWRfY29udGFpbmVyLk1ha2UgKFQnKVxuICBvcGVuIEZyb21faW5kZXhlZF9jb250YWluZXJfbWFrZVxuXG4gIGxldCBtZW0gPSBtZW1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICBsZXQgaXRlciA9IGl0ZXJcbiAgbGV0IGZvbGQgPSBmb2xkXG4gIGxldCBmb2xkX3Jlc3VsdCA9IGZvbGRfcmVzdWx0XG4gIGxldCBmb2xkX3VudGlsID0gZm9sZF91bnRpbFxuICBsZXQgZXhpc3RzID0gZXhpc3RzXG4gIGxldCBmb3JfYWxsID0gZm9yX2FsbFxuICBsZXQgY291bnQgPSBjb3VudFxuICBsZXQgc3VtID0gc3VtXG4gIGxldCBmaW5kID0gZmluZFxuICBsZXQgZmluZF9tYXAgPSBmaW5kX21hcFxuICBsZXQgdG9fYXJyYXkgPSB0b19hcnJheVxuICBsZXQgbWluX2VsdCA9IG1pbl9lbHRcbiAgbGV0IG1heF9lbHQgPSBtYXhfZWx0XG4gIGxldCBpdGVyaSA9IGl0ZXJpXG4gIGxldCBmaW5kX21hcGkgPSBmaW5kX21hcGlcbiAgbGV0IGZpbmRpID0gZmluZGlcbiAgbGV0IGNvdW50aSA9IGNvdW50aVxuICBsZXQgZm9yX2FsbGkgPSBmb3JfYWxsaVxuICBsZXQgZXhpc3RzaSA9IGV4aXN0c2lcbiAgbGV0IGZvbGRpID0gZm9sZGlcbmVuZFxuXG5sZXQgaW52YXJpYW50IGYgdCA9IGl0ZXIgdCB+ZlxubGV0IGNyZWF0ZSBoZCB0bCA9IGhkIDo6IHRsXG5sZXQgc2luZ2xldG9uIGhkID0gWyBoZCBdXG5sZXQgY29ucyB4IChoZCA6OiB0bCkgPSB4IDo6IGhkIDo6IHRsXG5cbmxldCBudGggKGhkIDo6IHRsKSBuID1cbiAgbWF0Y2ggbiB3aXRoXG4gIHwgMCAtPiBTb21lIGhkXG4gIHwgbiAtPiBMaXN0Lm50aCB0bCAobiAtIDEpXG47O1xuXG5sZXQgbnRoX2V4biB0IG4gPVxuICBtYXRjaCBudGggdCBuIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgaW52YWxpZF9hcmdmIFwiTm9uZW1wdHlfbGlzdC5udGhfZXhuICVkIGNhbGxlZCBvbiBsaXN0IG9mIGxlbmd0aCAlZFwiIG4gKGxlbmd0aCB0KSAoKVxuICB8IFNvbWUgYSAtPiBhXG47O1xuXG5sZXQgbWFwaSAoaGQgOjogdGwpIH5mID1cbiAgKCogQmVpbmcgb3Zlcmx5IGNhdXRpb3VzIGFib3V0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgbGV0IGhkID0gZiAwIGhkIGluXG4gIGhkIDo6IExpc3QubWFwaSB0bCB+ZjooZnVuIGkgeCAtPiBmIChpICsgMSkgeClcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIChoZCA6OiB0bCkgfmYgOiBfIGxpc3QgPVxuICBtYXRjaCBmIGhkIHdpdGhcbiAgfCBOb25lIC0+IExpc3QuZmlsdGVyX21hcCB0bCB+ZlxuICB8IFNvbWUgaGQgLT4gaGQgOjogTGlzdC5maWx0ZXJfbWFwIHRsIH5mXG47O1xuXG5sZXQgZmlsdGVyX21hcGkgKGhkIDo6IHRsKSB+ZiA6IF8gbGlzdCA9XG4gIGxldCBoZCA9IGYgMCBoZCBpblxuICBsZXRbQGlubGluZSBhbHdheXNdIGYgaSB4ID0gZiAoaSArIDEpIHggaW5cbiAgbWF0Y2ggaGQgd2l0aFxuICB8IE5vbmUgLT4gTGlzdC5maWx0ZXJfbWFwaSB0bCB+ZiBbQG5vbnRhaWxdXG4gIHwgU29tZSBoZCAtPiBoZCA6OiBMaXN0LmZpbHRlcl9tYXBpIHRsIH5mXG47O1xuXG5sZXQgZmlsdGVyIChoZCA6OiB0bCkgfmYgOiBfIGxpc3QgPVxuICBtYXRjaCBmIGhkIHdpdGhcbiAgfCBmYWxzZSAtPiBMaXN0LmZpbHRlciB0bCB+ZlxuICB8IHRydWUgLT4gaGQgOjogTGlzdC5maWx0ZXIgdGwgfmZcbjs7XG5cbmxldCBmaWx0ZXJpIChoZCA6OiB0bCkgfmYgOiBfIGxpc3QgPVxuICBsZXQgaW5jbHVkZV9oZCA9IGYgMCBoZCBpblxuICBsZXRbQGlubGluZSBhbHdheXNdIGYgaSB4ID0gZiAoaSArIDEpIHggaW5cbiAgbWF0Y2ggaW5jbHVkZV9oZCB3aXRoXG4gIHwgZmFsc2UgLT4gTGlzdC5maWx0ZXJpIHRsIH5mIFtAbm9udGFpbF1cbiAgfCB0cnVlIC0+IGhkIDo6IExpc3QuZmlsdGVyaSB0bCB+ZlxuOztcblxubGV0IG1hcCB0IH5mID0gbWFwaSB0IH5mOihmdW4gKF8gOiBpbnQpIHggLT4gZiB4KSBbQG5vbnRhaWxdXG5cbmxldCBtYXAyIHQxIHQyIH5mIDogXyBMaXN0Lk9yX3VuZXF1YWxfbGVuZ3Rocy50ID1cbiAgbWF0Y2ggTGlzdC5tYXAyICh0b19saXN0IHQxKSAodG9fbGlzdCB0MikgfmYgd2l0aFxuICB8IE9rIHggLT4gT2sgKG9mX2xpc3RfZXhuIHgpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIC0+IFVuZXF1YWxfbGVuZ3Roc1xuOztcblxubGV0IG1hcDJfZXhuIHQxIHQyIH5mID0gTGlzdC5tYXAyX2V4biAodG9fbGlzdCB0MSkgKHRvX2xpc3QgdDIpIH5mIHw+IG9mX2xpc3RfZXhuXG5sZXQgcmVkdWNlIChoZCA6OiB0bCkgfmYgPSBMaXN0LmZvbGQgfmluaXQ6aGQgdGwgfmZcblxubGV0IHJldmVyc2UgKGhkIDo6IHRsKSA9XG4gIGxldCByZWMgbG9vcCBhY2MgeCB4cyA9XG4gICAgbWF0Y2ggeHMgd2l0aFxuICAgIHwgW10gLT4geCA6OiBhY2NcbiAgICB8IHkgOjogeXMgLT4gbG9vcCAoeCA6OiBhY2MpIHkgeXNcbiAgaW5cbiAgbG9vcCBbXSBoZCB0bFxuOztcblxubGV0IGFwcGVuZCAoaGQgOjogdGwpIGwgPSBoZCA6OiBMaXN0LmFwcGVuZCB0bCBsXG5cbmluY2x1ZGUgTW9uYWQuTWFrZV9sb2NhbCAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IHJldHVybiBoZCA9IFsgaGQgXVxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcblxuICBsZXQgYmluZCAoaGQgOjogdGwpIH5mID1cbiAgICBsZXQgZl9oZCA9IGYgaGQgaW5cbiAgICBhcHBlbmQgZl9oZCAoTGlzdC5jb25jYXRfbWFwIHRsIH5mOihmdW4geCAtPiB0b19saXN0IChmIHgpKSlcbiAgOztcbmVuZClcblxubGV0IHVuemlwICgoaGQxLCBoZDIpIDo6IHRsKSA9XG4gIGxldCB0bDEsIHRsMiA9IExpc3QudW56aXAgdGwgaW5cbiAgaGQxIDo6IHRsMSwgaGQyIDo6IHRsMlxuOztcblxubGV0IGNvbmNhdCB0ID0gYmluZCB0IH5mOkZuLmlkXG5sZXQgY29uY2F0X21hcCA9IGJpbmRcblxubGV0IHppcCB0MSB0MiA6IF8gTGlzdC5Pcl91bmVxdWFsX2xlbmd0aHMudCA9XG4gIG1hdGNoIExpc3QuemlwICh0b19saXN0IHQxKSAodG9fbGlzdCB0Mikgd2l0aFxuICB8IE9rIHggLT4gT2sgKG9mX2xpc3RfZXhuIHgpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIC0+IFVuZXF1YWxfbGVuZ3Roc1xuOztcblxubGV0IHppcF9leG4gdDEgdDIgPSBMaXN0LnppcF9leG4gKHRvX2xpc3QgdDEpICh0b19saXN0IHQyKSB8PiBvZl9saXN0X2V4blxubGV0IGxhc3QgKGhkIDo6IHRsKSA9IExpc3QuZm9sZCB0bCB+aW5pdDpoZCB+ZjooZnVuIF8gZWx0IC0+IGVsdClcblxubGV0IGRyb3BfbGFzdCAoaGQgOjogdGwpID1cbiAgbWF0Y2ggTGlzdC5kcm9wX2xhc3QgdGwgd2l0aFxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIGwgLT4gaGQgOjogbFxuOztcblxubGV0IHRvX3NlcXVlbmNlIHQgPVxuICAoKiBbdG9fbGlzdF0ganVzdCBwZXJmb3JtcyBvbmUgWzo6XSwgc28gdGhpcyBzZXF1ZW5jZSBpcyBjcmVhdGVkIHdpdGggb25seSBjb25zdGFudFxuICAgICB1cC1mcm9udCB3b3JrICopXG4gIFNlcXVlbmNlLm9mX2xpc3QgKHRvX2xpc3QgdClcbjs7XG5cbmxldCBzb3J0IHQgfmNvbXBhcmUgPSBMaXN0LnNvcnQgKHRvX2xpc3QgdCkgfmNvbXBhcmUgfD4gb2ZfbGlzdF9leG5cbmxldCBzdGFibGVfc29ydCB0IH5jb21wYXJlID0gTGlzdC5zdGFibGVfc29ydCAodG9fbGlzdCB0KSB+Y29tcGFyZSB8PiBvZl9saXN0X2V4blxubGV0IGRlZHVwX2FuZF9zb3J0IHQgfmNvbXBhcmUgPSBMaXN0LmRlZHVwX2FuZF9zb3J0IH5jb21wYXJlICh0b19saXN0IHQpIHw+IG9mX2xpc3RfZXhuXG5sZXQgcGVybXV0ZSA/cmFuZG9tX3N0YXRlIHQgPSBMaXN0LnBlcm11dGUgP3JhbmRvbV9zdGF0ZSAodG9fbGlzdCB0KSB8PiBvZl9saXN0X2V4blxuXG5sZXQgbWluX2VsdCcgKGhkIDo6IHRsKSB+Y29tcGFyZSA9XG4gIExpc3QuZm9sZCB0bCB+aW5pdDpoZCB+ZjooZnVuIG1pbiBlbHQgLT4gaWYgY29tcGFyZSBtaW4gZWx0ID4gMCB0aGVuIGVsdCBlbHNlIG1pbikgW0Bub250YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG47O1xuXG5sZXQgbWF4X2VsdCcgdCB+Y29tcGFyZSA9IG1pbl9lbHQnIHQgfmNvbXBhcmU6KGZ1biB4IHkgLT4gY29tcGFyZSB5IHgpIFtAbm9udGFpbF1cblxubGV0IG1hcF9hZGRfbXVsdGkgbWFwIH5rZXkgfmRhdGEgPVxuICBNYXAudXBkYXRlIG1hcCBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IHNpbmdsZXRvbiBkYXRhXG4gICAgfCBTb21lIHQgLT4gY29ucyBkYXRhIHQpXG47O1xuXG5sZXQgbWFwX29mX2NvbnRhaW5lcl9tdWx0aSBmb2xkIGNvbnRhaW5lciB+Y29tcGFyYXRvciA9XG4gIGZvbGQgY29udGFpbmVyIH5pbml0OihNYXAuZW1wdHkgY29tcGFyYXRvcikgfmY6KGZ1biBhY2MgKGtleSwgZGF0YSkgLT5cbiAgICBtYXBfYWRkX211bHRpIGFjYyB+a2V5IH5kYXRhKVxuOztcblxubGV0IG1hcF9vZl9hbGlzdF9tdWx0aSBhbGlzdCA9IG1hcF9vZl9jb250YWluZXJfbXVsdGkgTGlzdC5mb2xkIGFsaXN0XG5sZXQgbWFwX29mX3NlcXVlbmNlX211bHRpIHNlcXVlbmNlID0gbWFwX29mX2NvbnRhaW5lcl9tdWx0aSBTZXF1ZW5jZS5mb2xkIHNlcXVlbmNlXG5sZXQgZm9sZF9ub25lbXB0eSAoaGQgOjogdGwpIH5pbml0IH5mID0gTGlzdC5mb2xkIHRsIH5pbml0Oihpbml0IGhkKSB+ZlxuXG5sZXQgbWFwX29mX2xpc3Rfd2l0aF9rZXlfbXVsdGkgbGlzdCB+Y29tcGFyYXRvciB+Z2V0X2tleSA9XG4gIExpc3QuZm9sZCBsaXN0IH5pbml0OihNYXAuZW1wdHkgY29tcGFyYXRvcikgfmY6KGZ1biBhY2MgZGF0YSAtPlxuICAgIGxldCBrZXkgPSBnZXRfa2V5IGRhdGEgaW5cbiAgICBtYXBfYWRkX211bHRpIGFjYyB+a2V5IH5kYXRhKVxuOztcblxubGV0IGZvbGRfcmlnaHQgKGhkIDo6IHRsKSB+aW5pdDphY2MgfmYgPVxuICBsZXQgYWNjID0gTGlzdC5mb2xkX3JpZ2h0IHRsIH5pbml0OmFjYyB+ZiBpblxuICBmIGhkIGFjY1xuOztcblxubGV0IGZvbGRpbmdfbWFwIChoZCA6OiB0bCkgfmluaXQgfmYgPVxuICBsZXQgYWNjLCBoZCA9IGYgaW5pdCBoZCBpblxuICBoZCA6OiBMaXN0LmZvbGRpbmdfbWFwIHRsIH5pbml0OmFjYyB+ZlxuOztcblxubGV0IGZvbGRfbWFwIChoZCA6OiB0bCkgfmluaXQ6YWNjIH5mID1cbiAgbGV0IGFjYywgaGQgPSBmIGFjYyBoZCBpblxuICBsZXQgYWNjLCB0bCA9IExpc3QuZm9sZF9tYXAgdGwgfmluaXQ6YWNjIH5mIGluXG4gIGFjYywgaGQgOjogdGxcbjs7XG5cbmxldCBjb21iaW5lX2Vycm9ycyB0ID1cbiAgbWF0Y2ggUmVzdWx0LmNvbWJpbmVfZXJyb3JzICh0b19saXN0IHQpIHdpdGhcbiAgfCBPayBva3MgLT4gT2sgKG9mX2xpc3RfZXhuIG9rcylcbiAgfCBFcnJvciBlcnJvcnMgLT4gRXJyb3IgKG9mX2xpc3RfZXhuIGVycm9ycylcbjs7XG5cbmxldCBjb21iaW5lX2Vycm9yc191bml0IHQgPVxuICBtYXRjaCBSZXN1bHQuY29tYmluZV9lcnJvcnNfdW5pdCAodG9fbGlzdCB0KSB3aXRoXG4gIHwgT2sgXyBhcyBvayAtPiBva1xuICB8IEVycm9yIGVycm9ycyAtPiBFcnJvciAob2ZfbGlzdF9leG4gZXJyb3JzKVxuOztcblxubGV0IGNvbWJpbmVfb3JfZXJyb3JzIHQgPVxuICBtYXRjaCBPcl9lcnJvci5jb21iaW5lX2Vycm9ycyAodG9fbGlzdCB0KSB3aXRoXG4gIHwgT2sgb2tzIC0+IE9rIChvZl9saXN0X2V4biBva3MpXG4gIHwgRXJyb3IgXyBhcyBlIC0+IGVcbjs7XG5cbmxldCBjb21iaW5lX29yX2Vycm9yc191bml0IHQgPSB0b19saXN0IHQgfD4gT3JfZXJyb3IuY29tYmluZV9lcnJvcnNfdW5pdFxubGV0IHZhbGlkYXRlIH5uYW1lIGNoZWNrIHQgPSBWYWxpZGF0ZS5saXN0IH5uYW1lIGNoZWNrICh0b19saXN0IHQpXG5sZXQgdmFsaWRhdGVfaW5kZXhlZCBjaGVjayB0ID0gVmFsaWRhdGUubGlzdF9pbmRleGVkIGNoZWNrICh0b19saXN0IHQpXG5cbmxldCByZWMgcmV2X2FwcGVuZCB4cyBhY2MgPVxuICBtYXRjaCAoeHMgOiBfIFJldmVyc2VkX2xpc3QudCkgd2l0aFxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IHRsIC0+IHJldl9hcHBlbmQgdGwgKGNvbnMgaGQgYWNjKVxuOztcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIG4gPCAxIHRoZW4gaW52YWxpZF9hcmdmIFwiTm9uZW1wdHlfbGlzdC5pbml0ICVkXCIgbiAoKTtcbiAgKCogW0xpc3QuaW5pdF0gY2FsbHMgW2ZdIG9uIHRoZSBoaWdoZXN0IGluZGV4IGZpcnN0IGFuZCB3b3JrcyBpdHMgd2F5IGRvd24uXG4gICAgIFdlIGRvIHRoZSBzYW1lIGhlcmUuICopXG4gIGxldCB0bCA9IExpc3QuaW5pdCAobiAtIDEpIH5mOihmdW4gaSAtPiBmIChpICsgMSkpIGluXG4gIGxldCBoZCA9IGYgMCBpblxuICBoZCA6OiB0bFxuOztcblxubGV0IGNhcnRlc2lhbl9wcm9kdWN0IHQgdCcgPVxuICBMaXN0LmNhcnRlc2lhbl9wcm9kdWN0ICh0b19saXN0IHQpICh0b19saXN0IHQnKSB8PiBvZl9saXN0X2V4blxuOztcblxubW9kdWxlIFJldmVyc2VkID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICggOjogKSBvZiAnYSAqICdhIFJldmVyc2VkX2xpc3QudFxuXG4gIGxldCB0b19yZXZfbGlzdCAoaGQgOjogdGwpIDogXyBSZXZlcnNlZF9saXN0LnQgPSBoZCA6OiB0bFxuICBsZXQgcmV2X2FwcGVuZCAoaGQgOjogdGwgOiBfIHQpIHhzID0gcmV2X2FwcGVuZCB0bCAoaGQgOjogeHMpXG4gIGxldCByZXYgdCA9IHJldl9hcHBlbmQgdCBbXVxuXG4gIGxldCByZWMgcmV2X21hcF9hdXggaSB4cyB+ZiBhY2MgPVxuICAgIG1hdGNoICh4cyA6IF8gUmV2ZXJzZWRfbGlzdC50KSB3aXRoXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+IHJldl9tYXBfYXV4IChpICsgMSkgdGwgfmYgKGNvbnMgKGYgaSBoZCkgYWNjKVxuICA7O1xuXG4gIGxldCByZXZfbWFwaSAoaGQgOjogdGwgOiBfIHQpIH5mID0gcmV2X21hcF9hdXggMSB0bCB+ZiAoWyBmIDAgaGQgXSA6IF8gVCcudClcbiAgbGV0IHJldl9tYXAgdCB+ZiA9IHJldl9tYXBpIHQgfmY6KGZ1biBfIHggLT4gZiB4KSBbQG5vbnRhaWxdXG4gIGxldCBjb25zIHggdCA9IHggOjogdG9fcmV2X2xpc3QgdFxuXG4gIG1vZHVsZSBXaXRoX3NleHBfb2YgPSBzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gICAgICBSZXZlcnNlZF9saXN0LldpdGhfc2V4cF9vZi5zZXhwX29mX3Qgc2V4cF9vZl9hICh0b19yZXZfbGlzdCB0KVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBXaXRoX3Jldl9zZXhwX29mID0gc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgICAgUmV2ZXJzZWRfbGlzdC5XaXRoX3Jldl9zZXhwX29mLnNleHBfb2ZfdCBzZXhwX29mX2EgKHRvX3Jldl9saXN0IHQpXG4gICAgOztcbiAgZW5kXG5lbmRcblxubGV0IHJldicgKGhkIDo6IHRsKSA9XG4gIExpc3QuZm9sZCB0bCB+aW5pdDooWyBoZCBdIDogXyBSZXZlcnNlZC50KSB+ZjooRm4uZmxpcCBSZXZlcnNlZC5jb25zKVxuOztcblxubGV0IGZsYWcgYXJnX3R5cGUgPVxuICBDb21tYW5kLlBhcmFtLm1hcF9mbGFnXG4gICAgKENvbW1hbmQuUGFyYW0ub25lX29yX21vcmVfYXNfcGFpciBhcmdfdHlwZSlcbiAgICB+ZjooZnVuIChvbmUsIG1vcmUpIC0+IG9uZSA6OiBtb3JlKVxuOztcblxubGV0IGNvbW1hX3NlcGFyYXRlZF9hcmd0eXBlID9rZXkgP3N0cmlwX3doaXRlc3BhY2UgP3VuaXF1ZV92YWx1ZXMgYXJnX3R5cGUgPVxuICBhcmdfdHlwZVxuICB8PiBDb21tYW5kLlBhcmFtLkFyZ190eXBlLmNvbW1hX3NlcGFyYXRlZFxuICAgICAgIH5hbGxvd19lbXB0eTpmYWxzZVxuICAgICAgID9zdHJpcF93aGl0ZXNwYWNlXG4gICAgICAgP3VuaXF1ZV92YWx1ZXNcbiAgfD4gQ29tbWFuZC5QYXJhbS5BcmdfdHlwZS5tYXAgP2tleSB+ZjpvZl9saXN0X2V4blxuOztcblxudHlwZSAnYSBub25lbXB0eV9saXN0ID0gJ2EgdFxuXG4oKiogVGhpcyByZWxpZXMgb24gdGhlIGZhY3QgdGhhdCB0aGUgcmVwcmVzZW50YXRpb24gb2YgW0xpc3QuKCA6OiApXSBjb25zdHJ1Y3RvciBpc1xuICAgIGlkZW50aWNhbCB0byB0aGF0IG9mIFtOb25lbXB0eV9saXN0LiggOjogKV0sIGFuZCB0aGF0IHRoZXkgYXJlIGVhY2ggdGhlIGZpcnN0XG4gICAgbm9uLWNvbnN0YW50IGNvbnN0cnVjdG9yIGluIHRoZWlyIHJlc3BlY3RpdmUgdHlwZXMuICopXG5tb2R1bGUgT3B0aW9uID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIGxpc3RcbiAgW0BAZGVyaXZpbmcgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hciwgaGFzaCwgcXVpY2tjaGVjaywgdHlwZXJlcF1cblxuICBsZXQgbm9uZSA9IFtdXG4gIGxldCBzb21lIChfIDo6IF8gYXMgdmFsdWUgOiAnYSBub25lbXB0eV9saXN0KSA6ICdhIHQgPSBPYmoubWFnaWMgdmFsdWVcbiAgbGV0IHVuY2hlY2tlZF92YWx1ZSAodCA6ICdhIHQpIDogJ2Egbm9uZW1wdHlfbGlzdCA9IE9iai5tYWdpYyB0XG4gIGxldCBpc19ub25lIHQgPSBwaHlzX2VxdWFsIHQgbm9uZVxuICBsZXQgaXNfc29tZSB0ID0gbm90IChpc19ub25lIHQpXG4gIGxldCB0b19vcHRpb24gPSBvZl9saXN0XG5cbiAgbGV0IG9mX29wdGlvbiA9IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IG5vbmVcbiAgICB8IFNvbWUgdmFsdWUgLT4gc29tZSB2YWx1ZVxuICA7O1xuXG4gIGxldCB2YWx1ZV9leG4gPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmFpc2VfcyBbJXNleHAgXCJOb25lbXB0eV9saXN0Lk9wdGlvbi52YWx1ZV9leG46IGVtcHR5IGxpc3RcIl1cbiAgICB8IF8gOjogXyBhcyBsIC0+IHVuY2hlY2tlZF92YWx1ZSBsXG4gIDs7XG5cbiAgbGV0IHZhbHVlIHQgfmRlZmF1bHQgPSBCb29sLnNlbGVjdCAoaXNfbm9uZSB0KSBkZWZhdWx0ICh1bmNoZWNrZWRfdmFsdWUgdClcblxuICBtb2R1bGUgT3B0aW9uYWxfc3ludGF4ID0gc3RydWN0XG4gICAgbW9kdWxlIE9wdGlvbmFsX3N5bnRheCA9IHN0cnVjdFxuICAgICAgbGV0IGlzX25vbmUgPSBpc19ub25lXG4gICAgICBsZXQgdW5zYWZlX3ZhbHVlID0gdW5jaGVja2VkX3ZhbHVlXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXX0=
