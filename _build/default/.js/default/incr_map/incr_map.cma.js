// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Incr_map__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Incr_map = [0],
    Incr_map$0 = [0, Incr_map];
   runtime.caml_register_global(0, Incr_map$0, "Incr_map__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incr_map__Incr_map_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incr_map_Incr_map_intf = "Incr_map__Incr_map_intf",
    cst_incr_map = "incr_map";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incr_map_Incr_map_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incr_map);
   caml_call1(Ppx_expect_runtime[1][1], "src/incr_map_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incr_map, "incr_map_intf.ml");
   var Instrumentation = [0];
   caml_call1(Ppx_inline_test_lib[7], cst_incr_map);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incr_map_Incr_map_intf);
   var Incr_map_Incr_map_intf = [0, Instrumentation];
   runtime.caml_register_global
    (11, Incr_map_Incr_map_intf, cst_Incr_map_Incr_map_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incr_map
//# unitInfo: Requires: Base__Option, CamlinternalLazy, Core, Core__Bool, Core__Info, Core__Int, Core__Lazy, Core__List, Core__Map, Core__Maybe_bound, Core__Option, Core__Sequence, Core__Set, Core__Sexp, Core__Tuple, Incr_map__Incr_map_intf, Incremental, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incr_map$0 = "Incr_map",
    cst_incr_map$0 = "incr_map",
    cst_key = "key",
    cst_src_incr_map_ml = "src/incr_map.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Int = global_data.Core__Int,
    Core_Map = global_data.Core__Map,
    Core = global_data.Core,
    Incremental = global_data.Incremental,
    Core_Option = global_data.Core__Option,
    Core_Info = global_data.Core__Info,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Core_List = global_data.Core__List,
    Core_Bool = global_data.Core__Bool,
    Core_Tuple = global_data.Core__Tuple,
    Assert_failure = global_data.Assert_failure,
    Core_Maybe_bound = global_data.Core__Maybe_bound,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Lazy = global_data.Core__Lazy,
    Core_Set = global_data.Core__Set,
    Core_Sexp = global_data.Core__Sexp,
    Base_Option = global_data.Base__Option,
    Core_Sequence = global_data.Core__Sequence,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incr_map$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incr_map$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_incr_map_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incr_map$0, "incr_map.ml");
   var
    _G_ = [0, "entries"],
    _H_ = [0, "actual_value"],
    _I_ = [0, cst_key],
    _B_ = [0, "node_is_unnecessary"],
    _C_ = [0, "node_is_invalid"],
    _D_ = [0, "node_is_const"],
    _E_ = [0, "node_info"],
    _F_ = [0, "saved_value"],
    cst_Incr_map_observe_changes_e =
      "[Incr_map.observe_changes_exn] called in scope that is not top-level",
    _A_ = [0, 1],
    _z_ = [0, 1],
    _y_ = [0, 1],
    _x_ = [0, 1],
    _w_ = [0, 1],
    _v_ = [0, [0, 0, 0]],
    _u_ = [0, cst_src_incr_map_ml, 1574, 6],
    _t_ = [0, cst_src_incr_map_ml, 1574, 6],
    _s_ = [0, cst_src_incr_map_ml, 1574, 6],
    _r_ = [0, cst_src_incr_map_ml, 1574, 6],
    _q_ = [0, cst_src_incr_map_ml, 1574, 6],
    _p_ = [0, cst_src_incr_map_ml, 1574, 6],
    _o_ = [0, cst_src_incr_map_ml, 1574, 6],
    _n_ = [0, cst_src_incr_map_ml, 1574, 6],
    _l_ = [0, cst_src_incr_map_ml, 1574, 6],
    _m_ = [0, [0, 0, 0]],
    _g_ = [0, "to_"],
    _h_ = [0, "from"],
    cst_Invalid_indices = "Invalid indices",
    _i_ = [0, 0, 0],
    _k_ = [0, cst_src_incr_map_ml, 1558, 10],
    _j_ = [0, cst_src_incr_map_ml, 1559, 10],
    cst_BUG_Hit_supposedly_impossi =
      "BUG: Hit supposedly impossible case in Incr_map.index_by",
    _f_ = [0, 1],
    _e_ = [0, 1],
    cst_impossible_case_BUG_in_inc =
      "impossible case: BUG in incr_map.ml subrange",
    _d_ = [0, 1],
    _c_ = [0, 1],
    _b_ = [0, cst_key],
    cst_caller_has_broken_invarian =
      "caller has broken invariant, a key is present in both maps",
    cst_Incr_map_merge_disjoint = "Incr_map.merge_disjoint",
    cst_src_incr_map_ml_596_14 = "src/incr_map.ml:596:14",
    _a_ = [0, cst_src_incr_map_ml, 329, 11],
    cst_incr_map = cst_incr_map$0,
    cst_Incr_map = cst_Incr_map$0;
   function no_instrumentation(f){return caml_call1(f, 0);}
   function with_old(instrumentation, i, f){
    var old = [0, 0];
    function _f9_(a){
     return caml_call1
             (instrumentation,
              function(param){
               var b = caml_call2(f, old[1], a);
               old[1] = [0, [0, a, b]];
               return b;
              });
    }
    return caml_call2(Incremental[76][3][5], i, _f9_);
   }
   function cutoff(opt, map, cutoff){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    function data_equal(old_value, new_value){
     return caml_call3(Incremental[58][10], cutoff, old_value, new_value);
    }
    return with_old
            (instrumentation,
             map,
             function(old, cur){
              if(! old) return cur;
              var old$0 = old[1][2];
              function _f7_(acc, param){
               var change = param[2], key = param[1], _f8_ = change[1];
               if(847852583 === _f8_)
                return caml_call2(Core_Map[47], acc, key);
               if(1013247643 <= _f8_){
                var new_value = change[2][2];
                return caml_call3(Core_Map[38], acc, key, new_value);
               }
               var new$0 = change[2];
               return caml_call3(Core_Map[37], acc, key, new$0);
              }
              return caml_call5
                      (Core_Map[89], old$0, cur, data_equal, old$0, _f7_);
             });
   }
   function unordered_fold
   (instrumentation,
    opt,
    update,
    specialized_initial,
    _f0_,
    _fZ_,
    map,
    init,
    add,
    remove){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = function(_f6_, _f5_){return _f6_ === _f5_ ? 1 : 0;};
    if(_f0_)
     var sth$0 = _f0_[1], finalize = sth$0;
    else
     var finalize = function(_f4_){return _f4_;};
    if(_fZ_)
     var sth$1 = _fZ_[1], revert_to_init_when_empty = sth$1;
    else
     var revert_to_init_when_empty = 0;
    function default$0(key, old_data, new_data, acc){
     return caml_call3
             (add, key, new_data, caml_call3(remove, key, old_data, acc));
    }
    var update$0 = caml_call2(Core_Option[39], update, default$0);
    return with_old
            (instrumentation,
             map,
             function(old, new_in){
              if(old){
               var match = old[1], old_out = match[2], old_in = match[1];
               a:
               {
                if(revert_to_init_when_empty){
                 var _f1_ = caml_call1(Core_Map[35], new_in);
                 if(caml_call2(Core[90], _f1_, 0)){var init$0 = init; break a;}
                }
                var
                 _f2_ =
                   function(acc, param){
                    var change = param[2], key = param[1], _f3_ = change[1];
                    if(847852583 === _f3_){
                     var old = change[2];
                     return caml_call3(remove, key, old, acc);
                    }
                    if(1013247643 <= _f3_){
                     var match = change[2], new$0 = match[2], old$0 = match[1];
                     return caml_call4(update$0, key, old$0, new$0, acc);
                    }
                    var new$1 = change[2];
                    return caml_call3(add, key, new$1, acc);
                   },
                 init$0 =
                   caml_call5
                    (Core_Map[89], old_in, new_in, data_equal, old_out, _f2_);
               }
               var acc = init$0;
              }
              else if(specialized_initial)
               var
                initial = specialized_initial[1],
                acc = caml_call2(initial, init, new_in);
              else
               var acc = caml_call3(Core_Map[61], new_in, init, add);
              return caml_call1(finalize, acc);
             });
   }
   function unordered_fold_nested_maps
   (instrumentation,
    opt,
    revert_to_init_when_empty,
    update,
    incr_map,
    init,
    add,
    remove){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = function(_fY_, _fX_){return _fY_ === _fX_ ? 1 : 0;};
    if(update)
     var update$0 = update[1], update$1 = update$0;
    else
     var
      update$1 =
        function(outer_key, inner_key, old_data, new_data, acc){
         return caml_call4
                 (add,
                  outer_key,
                  inner_key,
                  new_data,
                  caml_call4(remove, outer_key, inner_key, old_data, acc));
        };
    function _fP_(outer_key, inner_map, acc){
     function _fW_(inner_key, data, acc){
      return caml_call4(remove, outer_key, inner_key, data, acc);
     }
     return caml_call3(Core_Map[61], inner_map, acc, _fW_);
    }
    function _fQ_(outer_key, inner_map, acc){
     function _fV_(inner_key, data, acc){
      return caml_call4(add, outer_key, inner_key, data, acc);
     }
     return caml_call3(Core_Map[61], inner_map, acc, _fV_);
    }
    var _fR_ = 0, _fS_ = 0;
    return unordered_fold
            (instrumentation,
             0,
             [0,
              function(outer_key, old_inner_map, new_inner_map, acc){
               function _fT_(acc, param){
                var diff = param[2], inner_key = param[1], _fU_ = diff[1];
                if(847852583 === _fU_){
                 var data_removed = diff[2];
                 return caml_call4
                         (remove, outer_key, inner_key, data_removed, acc);
                }
                if(1013247643 <= _fU_){
                 var
                  match = diff[2],
                  new_data = match[2],
                  old_data = match[1];
                 return caml_call5
                         (update$1, outer_key, inner_key, old_data, new_data, acc);
                }
                var data_added = diff[2];
                return caml_call4(add, outer_key, inner_key, data_added, acc);
               }
               return caml_call2
                       (caml_call3
                         (Core_Map[89], old_inner_map, new_inner_map, data_equal),
                        acc,
                        _fT_);
              }],
             _fS_,
             _fR_,
             revert_to_init_when_empty,
             incr_map,
             init,
             _fQ_,
             _fP_);
   }
   function with_comparator(get_comparator, x, f){
    var
     _fN_ = caml_call2(Incremental[10], x, get_comparator),
     _fO_ = caml_call2(Incremental[34], 0, _fN_);
    return caml_call2(Incremental[26], _fO_, f);
   }
   function with_comparator$0(map, f){
    return with_comparator(Core_Map[2], map, f);
   }
   function of_set(opt, set){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    function _fI_(comparator){
     var
      old_input = [0, caml_call1(Core_Set[3][1], comparator)],
      old_output = [0, caml_call1(Core_Map[124][1], comparator)];
     function _fJ_(new_input){
      return caml_call1
              (instrumentation,
               function(param){
                function _fK_(output, param){
                 if(0 === param[0]){
                  var k = param[1];
                  return caml_call2(Core_Map[47], output, k);
                 }
                 var k$0 = param[1];
                 return caml_call3(Core_Map[37], output, k$0, 0);
                }
                var
                 _fL_ = old_output[1],
                 _fM_ = caml_call2(Core_Set[18], old_input[1], new_input),
                 new_output = caml_call3(Core_Sequence[21], _fM_, _fL_, _fK_);
                old_input[1] = new_input;
                old_output[1] = new_output;
                return new_output;
               });
     }
     return caml_call2(Incremental[10], set, _fJ_);
    }
    return with_comparator(Core_Set[6], set, _fI_);
   }
   function generic_mapi(witness, instrumentation, opt, map, f){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = function(_fH_, _fG_){return _fH_ === _fG_ ? 1 : 0;};
    return with_old
            (instrumentation,
             map,
             function(old, input){
              if(0 !== caml_call1(Core_Map[35], input) && old){
               var
                match = old[1],
                old_output = match[2],
                old_input = match[1],
                _fE_ =
                  function(output, param){
                   var change = param[2], key = param[1], _fF_ = change[1];
                   if(847852583 === _fF_)
                    return caml_call2(Core_Map[47], output, key);
                   var
                    new_data = 1013247643 <= _fF_ ? change[2][2] : change[2],
                    res = caml_call2(f, key, new_data);
                   if(! witness)
                    return caml_call3(Core_Map[38], output, key, res);
                   if(! res) return caml_call2(Core_Map[47], output, key);
                   var output_data = res[1];
                   return caml_call3(Core_Map[38], output, key, output_data);
                  };
               return caml_call5
                       (Core_Map[89],
                        old_input,
                        input,
                        data_equal,
                        old_output,
                        _fE_);
              }
              return witness
                      ? caml_call2(Core_Map[69], input, f)
                      : caml_call2(Core_Map[58], input, f);
             });
   }
   function mapi(opt, data_equal, map, f){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    return generic_mapi(0, instrumentation, data_equal, map, f);
   }
   function filter_mapi(opt, data_equal, map, f){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    return generic_mapi(1, instrumentation, data_equal, map, f);
   }
   function map(instrumentation, data_equal, map, f){
    return mapi
            (instrumentation,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function filter_map(instrumentation, data_equal, map, f){
    return filter_mapi
            (instrumentation,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function with_old2(instrumentation, i1, i2, f){
    var old = [0, 0];
    function _fD_(a1, a2){
     return caml_call1
             (instrumentation,
              function(param){
               var b = caml_call3(f, old[1], a1, a2);
               old[1] = [0, [0, a1, a2, b]];
               return b;
              });
    }
    return caml_call3(Incremental[12], i1, i2, _fD_);
   }
   function unordered_fold_with_extra
   (opt,
    _ft_,
    _fs_,
    update,
    specialized_initial,
    _fr_,
    _fq_,
    map,
    extra,
    init,
    add,
    remove,
    extra_changed){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    if(_ft_)
     var sth$0 = _ft_[1], data_equal = sth$0;
    else
     var data_equal = function(_fC_, _fB_){return _fC_ === _fB_ ? 1 : 0;};
    if(_fs_)
     var sth$1 = _fs_[1], extra_equal = sth$1;
    else
     var extra_equal = function(_fA_, _fz_){return _fA_ === _fz_ ? 1 : 0;};
    if(_fr_)
     var sth$2 = _fr_[1], finalize = sth$2;
    else
     var finalize = function(_fy_){return _fy_;};
    if(_fq_)
     var sth$3 = _fq_[1], revert_to_init_when_empty = sth$3;
    else
     var revert_to_init_when_empty = 0;
    function default$0(key, old_data, new_data, acc, extra){
     return caml_call4
             (add,
              key,
              new_data,
              caml_call4(remove, key, old_data, acc, extra),
              extra);
    }
    var update$0 = caml_call2(Core_Option[39], update, default$0);
    return with_old2
            (instrumentation,
             map,
             extra,
             function(old, new_in, new_extra){
              if(old){
               var
                match = old[1],
                old_out = match[3],
                old_extra = match[2],
                old_in = match[1],
                acc =
                  caml_call2(extra_equal, old_extra, new_extra)
                   ? old_out
                   : caml_call4
                     (extra_changed, old_extra, new_extra, old_in, old_out);
               a:
               {
                if(revert_to_init_when_empty){
                 var _fu_ = caml_call1(Core_Map[35], new_in);
                 if(caml_call2(Core[90], _fu_, 0)){var init$0 = init; break a;}
                }
                var
                 _fv_ =
                   function(acc, param){
                    var change = param[2], key = param[1], _fx_ = change[1];
                    if(847852583 === _fx_){
                     var old = change[2];
                     return caml_call4(remove, key, old, acc, new_extra);
                    }
                    if(1013247643 <= _fx_){
                     var match = change[2], new$0 = match[2], old$0 = match[1];
                     return caml_call5
                             (update$0, key, old$0, new$0, acc, new_extra);
                    }
                    var new$1 = change[2];
                    return caml_call4(add, key, new$1, acc, new_extra);
                   },
                 init$0 =
                   caml_call5
                    (Core_Map[89], old_in, new_in, data_equal, acc, _fv_);
               }
               var acc$0 = init$0;
              }
              else if(specialized_initial)
               var
                initial = specialized_initial[1],
                acc$0 = caml_call3(initial, init, new_in, new_extra);
              else
               var
                _fw_ =
                  function(key, data, acc){
                   return caml_call4(add, key, data, acc, new_extra);
                  },
                acc$0 = caml_call3(Core_Map[61], new_in, init, _fw_);
              return caml_call1(finalize, acc$0);
             });
   }
   function mapi_count(opt, _fe_, input, comparator, f){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    if(_fe_)
     var sth$0 = _fe_[1], data_equal = sth$0;
    else
     var data_equal = function(_fp_, _fo_){return _fp_ === _fo_ ? 1 : 0;};
    function add(new_key, acc){
     function _fn_(param){
      if(! param) return 1;
      var n = param[1];
      return n + 1 | 0;
     }
     return caml_call3(Core_Map[43], acc, new_key, _fn_);
    }
    function remove(new_key, acc){
     function _fm_(param){
      if(! param) return 0;
      var n = param[1];
      return 1 === n ? 0 : [0, n - 1 | 0];
     }
     return caml_call3(Core_Map[42], acc, new_key, _fm_);
    }
    function _ff_(key, data, acc){
     return remove(caml_call2(f, key, data), acc);
    }
    function _fg_(key, data, acc){return add(caml_call2(f, key, data), acc);}
    var
     _fh_ = caml_call1(Core_Map[4], comparator),
     _fi_ = 0,
     _fj_ = 0,
     _fk_ = 0;
    return unordered_fold
            (instrumentation,
             [0, data_equal],
             [0,
              function(key, old_data, new_data, acc){
               var
                prev_key = caml_call2(f, key, old_data),
                new_key = caml_call2(f, key, new_data),
                _fl_ = caml_call2(comparator[1][1], prev_key, new_key);
               return caml_call2(Core[90], _fl_, 0)
                       ? acc
                       : add(new_key, remove(prev_key, acc));
              }],
             _fk_,
             _fj_,
             _fi_,
             input,
             _fh_,
             _fg_,
             _ff_);
   }
   function map_count(instrumentation, data_equal, input, comparator, f){
    return mapi_count
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function min_helper(map){
    var match = caml_call1(Core_Map[90], map);
    if(! match) return 0;
    var min = match[1][1];
    return [0, min];
   }
   function max_helper(map){
    var match = caml_call1(Core_Map[92], map);
    if(! match) return 0;
    var max = match[1][1];
    return [0, max];
   }
   function bounds_helper(map){
    var
     match = caml_call1(Core_Map[90], map),
     match$0 = caml_call1(Core_Map[92], map);
    if(match){
     if(match$0){
      var max = match$0[1][1], min = match[1][1];
      return [0, [0, min, max]];
     }
    }
    else if(! match$0) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function mapi_min(instrumentation, data_equal, input, comparator, f){
    var _fd_ = mapi_count(instrumentation, data_equal, input, comparator, f);
    return caml_call2(Incremental[10], _fd_, min_helper);
   }
   function mapi_max(instrumentation, data_equal, input, comparator, f){
    var _fc_ = mapi_count(instrumentation, data_equal, input, comparator, f);
    return caml_call2(Incremental[10], _fc_, max_helper);
   }
   function mapi_bounds(instrumentation, data_equal, input, comparator, f){
    var _fb_ = mapi_count(instrumentation, data_equal, input, comparator, f);
    return caml_call2(Incremental[10], _fb_, bounds_helper);
   }
   function map_min(instrumentation, data_equal, input, comparator, f){
    return mapi_min
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function map_max(instrumentation, data_equal, input, comparator, f){
    return mapi_max
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function min_value(instrumentation, data_equal, input, comparator){
    return map_min
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(_fa_){return _fa_;});
   }
   function max_value(instrumentation, data_equal, input, comparator){
    return map_max
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(_e$_){return _e$_;});
   }
   function map_bounds(instrumentation, data_equal, input, comparator, f){
    return mapi_bounds
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function value_bounds(instrumentation, data_equal, input, comparator){
    return map_bounds
            (instrumentation,
             data_equal,
             input,
             comparator,
             function(_e__){return _e__;});
   }
   function merge_shared_impl
   (old, new_left_map, new_right_map, data_equal_left, data_equal_right, f){
    var comparator = caml_call1(Core_Map[2], new_left_map);
    if(old)
     var
      x = old[1],
      old_output = x[3],
      old_right_map = x[2],
      old_left_map = x[1];
    else
     var
      old_left_map$0 = caml_call1(Core_Map[124][1], comparator),
      old_output = old_left_map$0,
      old_right_map = old_left_map$0,
      old_left_map = old_left_map$0;
    function apply_right(output, param){
     var diff_element = param[2], key = param[1];
     return caml_call4
             (f, old_output, key, output, [0, -57574468, diff_element]);
    }
    if(old_left_map === new_left_map)
     return caml_call5
             (Core_Map[89],
              old_right_map,
              new_right_map,
              data_equal_right,
              old_output,
              apply_right);
    var
     right_diffs =
       caml_call3
        (Core_Map[88], old_right_map, new_right_map, data_equal_right);
    function _e4_(param, _e8_){
     var
      left_diff_element = _e8_[2],
      left_key = _e8_[1],
      right_diffs = param[2],
      output = param[1],
      compare = comparator[1],
      output$0 = output,
      right_diffs$0 = right_diffs;
     for(;;){
      var
       apply_left =
         function(output){
          return caml_call4
                  (f,
                   old_output,
                   left_key,
                   output,
                   [0, 847852583, left_diff_element]);
         };
      if(! right_diffs$0) return [0, apply_left(output$0), right_diffs$0];
      var
       match = right_diffs$0[1],
       tl = match[2],
       hd = match[1],
       right_diff_element = hd[2],
       right_key = hd[1],
       x = caml_call2(compare, left_key, right_key);
      if(0 === x){
       var _e9_ = caml_call1(Core_Sequence[50], tl);
       return [0,
               caml_call4
                (f,
                 old_output,
                 left_key,
                 output$0,
                 [0, 737457313, [0, left_diff_element, right_diff_element]]),
               _e9_];
      }
      if(! caml_call2(Core[91], x, 0))
       return [0, apply_left(output$0), right_diffs$0];
      var
       right_diffs$1 = caml_call1(Core_Sequence[50], tl),
       diff_element = hd[2],
       key = hd[1],
       output$1 =
         caml_call4
          (f, old_output, key, output$0, [0, -57574468, diff_element]),
       output$0 = output$1,
       right_diffs$0 = right_diffs$1;
     }
    }
    var
     _e5_ = [0, old_output, caml_call1(Core_Sequence[50], right_diffs)],
     match =
       caml_call5
        (Core_Map[89],
         old_left_map,
         new_left_map,
         data_equal_left,
         _e5_,
         _e4_),
     right_diffs$0 = match[2],
     output = match[1];
    function _e6_(param){
     var tl = param[2], hd = param[1], _e7_ = apply_right(output, hd);
     return caml_call3(Core_Sequence[21], tl, _e7_, apply_right);
    }
    return caml_call3(Core_Option[41], right_diffs$0, output, _e6_);
   }
   function new_data_from_diff_element(param){
    var _e3_ = param[1];
    if(847852583 === _e3_) return 0;
    var x = 1013247643 <= _e3_ ? param[2][2] : param[2];
    return [0, x];
   }
   function merge(opt, _eW_, _eV_, left_map, right_map, f){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    if(_eW_)
     var sth$0 = _eW_[1], data_equal_left = sth$0;
    else
     var
      data_equal_left = function(_e2_, _e1_){return _e2_ === _e1_ ? 1 : 0;};
    if(_eV_)
     var sth$1 = _eV_[1], data_equal_right = sth$1;
    else
     var
      data_equal_right = function(_e0_, _eZ_){return _e0_ === _eZ_ ? 1 : 0;};
    return with_old2
            (instrumentation,
             left_map,
             right_map,
             function(old, new_left_map, new_right_map){
              return merge_shared_impl
                      (old,
                       new_left_map,
                       new_right_map,
                       data_equal_left,
                       data_equal_right,
                       function(param, key, output, diff_element){
                        var _eX_ = diff_element[1];
                        if(737457313 === _eX_)
                         var
                          match = diff_element[2],
                          right_diff = match[2],
                          left_diff = match[1],
                          right_data_opt = new_data_from_diff_element(right_diff),
                          left_data_opt = new_data_from_diff_element(left_diff),
                          right_data_opt$0 = right_data_opt,
                          left_data_opt$0 = left_data_opt;
                        else if(847852583 <= _eX_)
                         var
                          left_diff$0 = diff_element[2],
                          right_data_opt$1 =
                            caml_call2(Core_Map[44], new_right_map, key),
                          right_data_opt$0 = right_data_opt$1,
                          left_data_opt$0 = new_data_from_diff_element(left_diff$0);
                        else
                         var
                          right_diff$0 = diff_element[2],
                          right_data_opt$2 = new_data_from_diff_element(right_diff$0),
                          right_data_opt$0 = right_data_opt$2,
                          left_data_opt$0 =
                            caml_call2(Core_Map[44], new_left_map, key);
                        if(left_data_opt$0){
                         var x = left_data_opt$0[1];
                         if(right_data_opt$0)
                          var
                           y = right_data_opt$0[1],
                           _eY_ = caml_call2(f, key, [0, 737457313, [0, x, y]]);
                         else
                          var _eY_ = caml_call2(f, key, [0, 847852583, x]);
                         var output_data_opt = _eY_;
                        }
                        else if(right_data_opt$0)
                         var
                          y$0 = right_data_opt$0[1],
                          output_data_opt = caml_call2(f, key, [0, -57574468, y$0]);
                        else
                         var output_data_opt = 0;
                        if(! output_data_opt)
                         return caml_call2(Core_Map[47], output, key);
                        var data = output_data_opt[1];
                        return caml_call3(Core_Map[38], output, key, data);
                       });
             });
   }
   function merge_both_some(opt, _eB_, _eA_, _ez_, left_map, right_map, f){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    if(_eB_)
     var sth$0 = _eB_[1], data_equal_left = sth$0;
    else
     var
      data_equal_left = function(_eU_, _eT_){return _eU_ === _eT_ ? 1 : 0;};
    if(_eA_)
     var sth$1 = _eA_[1], data_equal_right = sth$1;
    else
     var
      data_equal_right = function(_eS_, _eR_){return _eS_ === _eR_ ? 1 : 0;};
    if(_ez_)
     var sth$2 = _ez_[1], out_equal = sth$2;
    else
     var out_equal = function(_eQ_, _eP_){return _eQ_ === _eP_ ? 1 : 0;};
    return with_old2
            (instrumentation,
             left_map,
             right_map,
             function(old, new_left_map, new_right_map){
              var
               comparator = caml_call1(Core_Map[2], new_left_map),
               empty = caml_call1(Core_Map[124][1], comparator),
               match = caml_call1(Core_Map[35], new_left_map),
               match$0 = caml_call1(Core_Map[35], new_right_map);
              if(0 !== match && 0 !== match$0)
               return merge_shared_impl
                       (old,
                        new_left_map,
                        new_right_map,
                        data_equal_left,
                        data_equal_right,
                        function(old_output, key, output, diff_element){
                         var _eC_ = diff_element[1];
                         if(737457313 === _eC_)
                          var
                           match = diff_element[2],
                           right_diff = match[2],
                           left_diff = match[1],
                           _eD_ =
                             function(left_data){
                              function _eJ_(right_data){
                               return [0, left_data, right_data];
                              }
                              var _eK_ = new_data_from_diff_element(right_diff);
                              return caml_call2(Base_Option[29][4][3], _eK_, _eJ_);
                             },
                           _eE_ = new_data_from_diff_element(left_diff),
                           left_and_right_data_opt =
                             caml_call2(Base_Option[29][4][2], _eE_, _eD_);
                         else if(847852583 <= _eC_)
                          var
                           left_diff$0 = diff_element[2],
                           _eF_ =
                             function(left_data){
                              function _eL_(right_data){
                               return [0, left_data, right_data];
                              }
                              var _eM_ = caml_call2(Core_Map[44], new_right_map, key);
                              return caml_call2(Base_Option[29][4][3], _eM_, _eL_);
                             },
                           _eG_ = new_data_from_diff_element(left_diff$0),
                           left_and_right_data_opt =
                             caml_call2(Base_Option[29][4][2], _eG_, _eF_);
                         else
                          var
                           right_diff$0 = diff_element[2],
                           _eH_ =
                             function(right_data){
                              function _eN_(left_data){return [0, left_data, right_data];}
                              var _eO_ = caml_call2(Core_Map[44], new_left_map, key);
                              return caml_call2(Base_Option[29][4][3], _eO_, _eN_);
                             },
                           _eI_ = new_data_from_diff_element(right_diff$0),
                           left_and_right_data_opt =
                             caml_call2(Base_Option[29][4][2], _eI_, _eH_);
                         var prev_out = caml_call2(Core_Map[44], old_output, key);
                         if(! left_and_right_data_opt)
                          return prev_out
                                  ? caml_call2(Core_Map[47], output, key)
                                  : output;
                         var
                          match$0 = left_and_right_data_opt[1],
                          y = match$0[2],
                          x = match$0[1],
                          data = caml_call3(f, key, x, y);
                         if(prev_out){
                          var prev_out$0 = prev_out[1];
                          if(caml_call2(out_equal, data, prev_out$0)) return output;
                         }
                         return caml_call3(Core_Map[38], output, key, data);
                        });
              return empty;
             });
   }
   function merge_disjoint(opt, _ej_, left_map, right_map){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    if(_ej_)
     var sth$0 = _ej_[1], data_equal = sth$0;
    else
     var data_equal = function(_ey_, _ex_){return _ey_ === _ex_ ? 1 : 0;};
    return with_old2
            (instrumentation,
             left_map,
             right_map,
             function(old, new_left_map, new_right_map){
              var
               comparator = caml_call1(Core_Map[2], new_left_map),
               empty = caml_call1(Core_Map[124][1], comparator);
              function merge_from_scratch(param){
               function _eq_(key, param, _er_){
                var
                 _es_ = caml_call1(comparator[2], key),
                 _et_ =
                   [0,
                    [1, [0, _b_, [0, caml_call1(Core_Sexp[93], _es_), 0]]],
                    0],
                 _eu_ =
                   [0,
                    caml_call1
                     (Sexplib0_Sexp_conv[7], cst_caller_has_broken_invarian),
                    _et_],
                 _ev_ =
                   [0,
                    caml_call1
                     (Sexplib0_Sexp_conv[7], cst_Incr_map_merge_disjoint),
                    _eu_],
                 _ew_ =
                   [1,
                    [0,
                     caml_call1
                      (Sexplib0_Sexp_conv[7], cst_src_incr_map_ml_596_14),
                     _ev_]];
                return caml_call1(Core[261], _ew_);
               }
               return caml_call3
                       (Core_Map[86], new_left_map, new_right_map, _eq_);
              }
              var
               l = caml_call1(Core_Map[35], new_left_map),
               r = caml_call1(Core_Map[35], new_right_map);
              if(0 === l) return 0 === r ? empty : new_right_map;
              if(0 === r) return new_left_map;
              var _ek_ = caml_call1(Core_Int[51], r);
              if(! caml_call2(Core[92], l, _ek_)){
               var _el_ = caml_call1(Core_Int[51], l);
               if(! caml_call2(Core[92], r, _el_)){
                if(! old) return merge_from_scratch(0);
                var
                 match = old[1],
                 old_result = match[3],
                 old_right_map = match[2],
                 old_left_map = match[1],
                 _em_ =
                   function(acc, param){
                    var elt = param[2], key = param[1], _ep_ = elt[1];
                    if(847852583 === _ep_)
                     return caml_call2(Core_Map[47], acc, key);
                    if(1013247643 <= _ep_){
                     var cur = elt[2][2];
                     return caml_call3(Core_Map[38], acc, key, cur);
                    }
                    var data = elt[2];
                    return caml_call3(Core_Map[38], acc, key, data);
                   },
                 with_left_changes =
                   caml_call5
                    (Core_Map[89],
                     old_left_map,
                     new_left_map,
                     data_equal,
                     old_result,
                     _em_),
                 _en_ =
                   function(acc, param){
                    var elt = param[2], key = param[1], _eo_ = elt[1];
                    if(847852583 === _eo_)
                     return caml_call2(Core_Map[48], new_left_map, key)
                             ? acc
                             : caml_call2(Core_Map[47], acc, key);
                    if(1013247643 <= _eo_){
                     var cur = elt[2][2];
                     return caml_call3(Core_Map[38], acc, key, cur);
                    }
                    var data = elt[2];
                    return caml_call3(Core_Map[38], acc, key, data);
                   };
                return caml_call5
                        (Core_Map[89],
                         old_right_map,
                         new_right_map,
                         data_equal,
                         with_left_changes,
                         _en_);
               }
              }
              return merge_from_scratch(0);
             });
   }
   function generic_mapi_with_comparator
   (witness, instrumentation, cutoff, opt, lhs, comparator, f){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = function(_ei_, _eh_){return _ei_ === _eh_ ? 1 : 0;};
    var
     incremental_state = caml_call1(Incremental[4], lhs),
     empty_map = caml_call1(Core_Map[124][1], comparator),
     prev_map = [0, empty_map],
     prev_nodes = [0, empty_map],
     acc = [0, empty_map];
    function _d3_(param){return acc[1];}
    var
     result = caml_call3(Incremental[79][2][2], incremental_state, 0, _d3_),
     on_inner_change =
       witness
        ? function
         (key, opt){
          var old = acc[1];
          if(opt)
           var data = opt[1], _eg_ = caml_call3(Core_Map[38], old, key, data);
          else
           var _eg_ = caml_call2(Core_Map[47], old, key);
          acc[1] = _eg_;
          return 0;
         }
        : function
         (key, data){
          acc[1] = caml_call3(Core_Map[38], acc[1], key, data);
          return 0;
         },
     lhs_change = [];
    caml_update_dummy
     (lhs_change,
      [246,
       function(_d6_){
        function _d7_(map){
         return caml_call1
                 (instrumentation,
                  function(param){
                   function _d8_(nodes, param){
                    var changed = param[2], key = param[1], _d9_ = changed[1];
                    if(847852583 === _d9_){
                     var
                      match = caml_call2(Core_Map[45], nodes, key),
                      dep = match[2],
                      node = match[1],
                      nodes$0 = caml_call2(Core_Map[47], nodes, key);
                     caml_call2(Incremental[79][2][7], result, dep);
                     acc[1] = caml_call2(Core_Map[47], acc[1], key);
                     caml_call1(Incremental[79][2][5], node);
                     return nodes$0;
                    }
                    if(1013247643 <= _d9_){
                     var node$0 = caml_call2(Core_Map[45], nodes, key)[1];
                     caml_call1(Incremental[79][2][4], node$0);
                     return nodes;
                    }
                    function _d__(param){
                     return caml_call2(Core_Map[45], prev_map[1], key);
                    }
                    var
                     node$1 =
                       caml_call3
                        (Incremental[79][2][2], incremental_state, 0, _d__);
                    function _d$_(c){
                     var _ef_ = caml_call1(Incremental[79][2][3], node$1);
                     return caml_call2(Incremental[59], _ef_, c);
                    }
                    caml_call2(Core_Option[46], cutoff, _d$_);
                    var
                     _ea_ = caml_call1(Core[248], lhs_change),
                     _eb_ = caml_call2(Incremental[79][1][2], 0, _ea_);
                    caml_call2(Incremental[79][2][6], node$1, _eb_);
                    var
                     _ec_ =
                       caml_call2
                        (f, key, caml_call1(Incremental[79][2][3], node$1)),
                     _ed_ =
                       [0, function(_ee_){return on_inner_change(key, _ee_);}],
                     user_function_dep =
                       caml_call2(Incremental[79][1][2], _ed_, _ec_);
                    caml_call2(Incremental[79][2][6], result, user_function_dep);
                    return caml_call3
                            (Core_Map[38], nodes, key, [0, node$1, user_function_dep]);
                   }
                   var
                    new_nodes =
                      caml_call5
                       (Core_Map[89],
                        prev_map[1],
                        map,
                        data_equal,
                        prev_nodes[1],
                        _d8_);
                   prev_nodes[1] = new_nodes;
                   prev_map[1] = map;
                   return 0;
                  });
        }
        return caml_call2(Incremental[10], lhs, _d7_);
       }]);
    var
     _d4_ = caml_call1(Core[248], lhs_change),
     _d5_ = caml_call2(Incremental[79][1][2], 0, _d4_);
    caml_call2(Incremental[79][2][6], result, _d5_);
    return caml_call1(Incremental[79][2][3], result);
   }
   function filter_mapi$0(opt, cutoff, data_equal, map, f){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    return with_comparator$0
            (map,
             function(comparator){
              return generic_mapi_with_comparator
                      (1, instrumentation, cutoff, data_equal, map, comparator, f);
             });
   }
   function mapi$0(opt, cutoff, data_equal, map, f){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    return with_comparator$0
            (map,
             function(comparator){
              return generic_mapi_with_comparator
                      (0, instrumentation, cutoff, data_equal, map, comparator, f);
             });
   }
   function map$0(instrumentation, cutoff, data_equal, map, f){
    return mapi$0
            (instrumentation,
             cutoff,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function filter_map$0(instrumentation, cutoff, data_equal, map, f){
    return filter_mapi$0
            (instrumentation,
             cutoff,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function merge$0
   (instrumentation, cutoff, data_equal_left, data_equal_right, map1, map2, f){
    function _d2_(key, diff){return caml_call2(f, key, diff);}
    return filter_mapi$0
            (instrumentation,
             cutoff,
             0,
             merge
              (instrumentation,
               data_equal_left,
               data_equal_right,
               map1,
               map2,
               function(param, diff){return [0, diff];}),
             _d2_);
   }
   function unzip_mapi
   (opt, data_equal, left_result_equal, right_result_equal, input, f){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    var
     pair =
       with_comparator$0
        (input,
         function(comparator){
          if(data_equal)
           var sth = data_equal[1], data_equal$0 = sth;
          else
           var
            data_equal$0 = function(_d1_, _d0_){return _d1_ === _d0_ ? 1 : 0;};
          if(left_result_equal)
           var sth$0 = left_result_equal[1], left_result_equal$0 = sth$0;
          else
           var
            left_result_equal$0 =
              function(_dZ_, _dY_){return _dZ_ === _dY_ ? 1 : 0;};
          if(right_result_equal)
           var sth$1 = right_result_equal[1], right_result_equal$0 = sth$1;
          else
           var
            right_result_equal$0 =
              function(_dX_, _dW_){return _dX_ === _dW_ ? 1 : 0;};
          var
           incremental_state = caml_call1(Incremental[4], input),
           empty_map = caml_call1(Core_Map[124][1], comparator),
           left_acc = [0, empty_map];
          function _dH_(param){return left_acc[1];}
          var
           left_result =
             caml_call3(Incremental[79][2][2], incremental_state, 0, _dH_),
           right_acc = [0, empty_map];
          function _dI_(param){return right_acc[1];}
          var
           right_result =
             caml_call3(Incremental[79][2][2], incremental_state, 0, _dI_),
           prev_map = [0, empty_map];
          function _dJ_(map){
           return caml_call1
                   (instrumentation,
                    function(param){
                     var
                      match = caml_call1(Core_Map[34], prev_map[1]),
                      match$0 = caml_call1(Core_Map[34], map);
                     a:
                     {
                      if(match){
                       if(! match$0){
                        var
                         _dO_ =
                           function(key, data){
                            var l = caml_call2(f, key, data)[1];
                            return l;
                           },
                         left$0 = caml_call2(Core_Map[58], map, _dO_),
                         _dP_ =
                           function(key, data){
                            var r = caml_call2(f, key, data)[2];
                            return r;
                           },
                         right$0 = caml_call2(Core_Map[58], map, _dP_),
                         right = right$0,
                         left = left$0;
                        break a;
                       }
                      }
                      else if(! match$0){
                       var
                        _dQ_ =
                          function(param, _dS_){
                           var
                            changed = _dS_[2],
                            key = _dS_[1],
                            right = param[2],
                            left = param[1],
                            _dT_ = changed[1];
                           if(847852583 === _dT_){
                            var _dU_ = caml_call2(Core_Map[47], right, key);
                            return [0, caml_call2(Core_Map[47], left, key), _dU_];
                           }
                           if(1013247643 <= _dT_){
                            var
                             match = changed[2],
                             new$0 = match[2],
                             prev = match[1],
                             match$0 = caml_call2(f, key, prev),
                             prev_b = match$0[2],
                             prev_a = match$0[1],
                             match$1 = caml_call2(f, key, new$0),
                             new_b = match$1[2],
                             new_a = match$1[1],
                             left$0 =
                               caml_call2(left_result_equal$0, prev_a, new_a)
                                ? left
                                : caml_call3(Core_Map[38], left, key, new_a),
                             right$0 =
                               caml_call2(right_result_equal$0, prev_b, new_b)
                                ? right
                                : caml_call3(Core_Map[38], right, key, new_b);
                            return [0, left$0, right$0];
                           }
                           var
                            element = changed[2],
                            match$2 = caml_call2(f, key, element),
                            b = match$2[2],
                            a = match$2[1],
                            _dV_ = caml_call3(Core_Map[38], right, key, b);
                           return [0, caml_call3(Core_Map[38], left, key, a), _dV_];
                          },
                        _dR_ =
                          caml_call5
                           (Core_Map[89],
                            prev_map[1],
                            map,
                            data_equal$0,
                            [0, left_acc[1], right_acc[1]],
                            _dQ_),
                        right = _dR_[2],
                        left = _dR_[1];
                       break a;
                      }
                      var right = empty_map, left = empty_map;
                     }
                     if(1 - (left_acc[1] === left ? 1 : 0))
                      caml_call1(Incremental[79][2][4], left_result);
                     if(1 - (right_acc[1] === right ? 1 : 0))
                      caml_call1(Incremental[79][2][4], right_result);
                     left_acc[1] = left;
                     right_acc[1] = right;
                     prev_map[1] = map;
                     return 0;
                    });
          }
          var
           input_change = caml_call2(Incremental[10], input, _dJ_),
           _dK_ = caml_call2(Incremental[79][1][2], 0, input_change);
          caml_call2(Incremental[79][2][6], left_result, _dK_);
          var _dL_ = caml_call2(Incremental[79][1][2], 0, input_change);
          caml_call2(Incremental[79][2][6], right_result, _dL_);
          var
           _dM_ = caml_call1(Incremental[79][2][3], right_result),
           _dN_ = [0, caml_call1(Incremental[79][2][3], left_result), _dM_];
          return caml_call2(Core_Tuple[1][8], Incremental[40], _dN_);
         });
    function _dC_(_dG_){return _dG_[2];}
    var _dD_ = caml_call2(Incremental[10], pair, _dC_);
    function _dE_(_dF_){return _dF_[1];}
    return [0, caml_call2(Incremental[10], pair, _dE_), _dD_];
   }
   function unzip
   (instrumentation, left_result_equal, right_result_equal, input){
    function _dB_(l, r){return caml_call2(Core_Tuple[1][10], l, r);}
    var
     data_equal =
       caml_call3
        (Core_Option[28], left_result_equal, right_result_equal, _dB_);
    return unzip_mapi
            (instrumentation,
             data_equal,
             left_result_equal,
             right_result_equal,
             input,
             function(param, data){return data;});
   }
   function unzip_mapi$0(opt, cutoff, data_equal, input, f){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    var
     pair =
       with_comparator$0
        (input,
         function(comparator){
          if(data_equal)
           var sth = data_equal[1], data_equal$0 = sth;
          else
           var
            data_equal$0 = function(_dA_, _dz_){return _dA_ === _dz_ ? 1 : 0;};
          var
           incremental_state = caml_call1(Incremental[4], input),
           empty_map = caml_call1(Core_Map[124][1], comparator),
           prev_map = [0, empty_map],
           prev_nodes = [0, empty_map],
           left_acc = [0, empty_map];
          function _df_(param){return left_acc[1];}
          var
           left_result =
             caml_call3(Incremental[79][2][2], incremental_state, 0, _df_),
           right_acc = [0, empty_map];
          function _dg_(param){return right_acc[1];}
          var
           right_result =
             caml_call3(Incremental[79][2][2], incremental_state, 0, _dg_),
           input_change = [];
          caml_update_dummy
           (input_change,
            [246,
             function(_do_){
              function _dp_(map){
               return caml_call1
                       (instrumentation,
                        function(param){
                         function _dq_(nodes, param){
                          var changed = param[2], key = param[1], _dr_ = changed[1];
                          if(847852583 === _dr_){
                           var
                            match = caml_call2(Core_Map[45], nodes, key),
                            right_dep = match[3],
                            left_dep = match[2],
                            node = match[1],
                            nodes$0 = caml_call2(Core_Map[47], nodes, key);
                           caml_call2(Incremental[79][2][7], left_result, left_dep);
                           caml_call2(Incremental[79][2][7], right_result, right_dep);
                           left_acc[1] = caml_call2(Core_Map[47], left_acc[1], key);
                           right_acc[1] = caml_call2(Core_Map[47], right_acc[1], key);
                           caml_call1(Incremental[79][2][5], node);
                           return nodes$0;
                          }
                          if(1013247643 <= _dr_){
                           var node$0 = caml_call2(Core_Map[45], nodes, key)[1];
                           caml_call1(Incremental[79][2][4], node$0);
                           return nodes;
                          }
                          function _ds_(param){
                           return caml_call2(Core_Map[45], prev_map[1], key);
                          }
                          var
                           node$1 =
                             caml_call3
                              (Incremental[79][2][2], incremental_state, 0, _ds_);
                          function _dt_(c){
                           var _dy_ = caml_call1(Incremental[79][2][3], node$1);
                           return caml_call2(Incremental[59], _dy_, c);
                          }
                          caml_call2(Core_Option[46], cutoff, _dt_);
                          var
                           _du_ = caml_call1(Core[248], input_change),
                           _dv_ = caml_call2(Incremental[79][1][2], 0, _du_);
                          caml_call2(Incremental[79][2][6], node$1, _dv_);
                          var
                           match$0 =
                             caml_call2
                              (f, key, caml_call1(Incremental[79][2][3], node$1)),
                           right_incr = match$0[2],
                           left_incr = match$0[1],
                           _dw_ =
                             [0,
                              function(data){
                               left_acc[1] =
                                caml_call3(Core_Map[38], left_acc[1], key, data);
                               return 0;
                              }],
                           left_user_function_dep =
                             caml_call2(Incremental[79][1][2], _dw_, left_incr),
                           _dx_ =
                             [0,
                              function(data){
                               right_acc[1] =
                                caml_call3(Core_Map[38], right_acc[1], key, data);
                               return 0;
                              }],
                           right_user_function_dep =
                             caml_call2(Incremental[79][1][2], _dx_, right_incr);
                          caml_call2
                           (Incremental[79][2][6], left_result, left_user_function_dep);
                          caml_call2
                           (Incremental[79][2][6],
                            right_result,
                            right_user_function_dep);
                          return caml_call3
                                  (Core_Map[38],
                                   nodes,
                                   key,
                                   [0, node$1, left_user_function_dep, right_user_function_dep]);
                         }
                         var
                          new_nodes =
                            caml_call5
                             (Core_Map[89],
                              prev_map[1],
                              map,
                              data_equal$0,
                              prev_nodes[1],
                              _dq_);
                         prev_nodes[1] = new_nodes;
                         prev_map[1] = map;
                         return 0;
                        });
              }
              return caml_call2(Incremental[10], input, _dp_);
             }]);
          var
           _dh_ = caml_call1(Core[248], input_change),
           _di_ = caml_call2(Incremental[79][1][2], 0, _dh_);
          caml_call2(Incremental[79][2][6], left_result, _di_);
          var
           _dj_ = caml_call1(Core[248], input_change),
           _dk_ = caml_call2(Incremental[79][1][2], 0, _dj_);
          caml_call2(Incremental[79][2][6], right_result, _dk_);
          var
           _dl_ = caml_call1(Incremental[79][2][3], right_result),
           _dm_ = [0, caml_call1(Incremental[79][2][3], left_result), _dl_],
           _dn_ = caml_call1(Incremental[4], input);
          return caml_call2(Incremental[9], _dn_, _dm_);
         });
    function _da_(_de_){return _de_[2];}
    var _db_ = caml_call2(Incremental[26], pair, _da_);
    function _dc_(_dd_){return _dd_[1];}
    return [0, caml_call2(Incremental[26], pair, _dc_), _db_];
   }
   function keys(opt, map){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    return with_comparator$0
            (map,
             function(comparator){
              function add(key, param, acc){
               return caml_call2(Core_Set[12], acc, key);
              }
              function remove(key, param, acc){
               return caml_call2(Core_Set[13], acc, key);
              }
              function data_equal(param, _c$_){return 1;}
              return unordered_fold
                      (instrumentation,
                       [0, data_equal],
                       0,
                       0,
                       0,
                       _c_,
                       map,
                       caml_call1(Core_Set[3][1], comparator),
                       add,
                       remove);
             });
   }
   function partition_mapi(opt, data_equal, map, f){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    return with_comparator$0
            (map,
             function(comparator){
              var empty = caml_call1(Core_Map[124][1], comparator);
              function _c1_(key, param, _c9_){
               var
                second = _c9_[2],
                first = _c9_[1],
                _c__ = caml_call2(Core_Map[47], second, key);
               return [0, caml_call2(Core_Map[47], first, key), _c__];
              }
              function _c2_(key, data, param){
               var
                second = param[2],
                first = param[1],
                match = caml_call2(f, key, data);
               if(0 === match[0]){
                var data$0 = match[1];
                return [0,
                        caml_call3(Core_Map[37], first, key, data$0),
                        second];
               }
               var data$1 = match[1];
               return [0,
                       first,
                       caml_call3(Core_Map[37], second, key, data$1)];
              }
              var _c3_ = [0, empty, empty], _c4_ = 0, _c5_ = 0;
              return unordered_fold
                      (instrumentation,
                       data_equal,
                       [0,
                        function(key, param, data, _c6_){
                         var
                          second = _c6_[2],
                          first = _c6_[1],
                          match = caml_call2(f, key, data);
                         if(0 === match[0]){
                          var
                           data$0 = match[1],
                           _c7_ = caml_call2(Core_Map[47], second, key);
                          return [0,
                                  caml_call3(Core_Map[38], first, key, data$0),
                                  _c7_];
                         }
                         var
                          data$1 = match[1],
                          _c8_ = caml_call3(Core_Map[38], second, key, data$1);
                         return [0, caml_call2(Core_Map[47], first, key), _c8_];
                        }],
                       _c5_,
                       _c4_,
                       _d_,
                       map,
                       _c3_,
                       _c2_,
                       _c1_);
             });
   }
   function partition_mapi$0(instrumentation, cutoff, data_equal, map, f){
    function _c0_(param, data){return data;}
    return partition_mapi
            (instrumentation,
             0,
             mapi$0(instrumentation, cutoff, data_equal, map, f),
             _c0_);
   }
   function flatten(state, map){
    var
     _cV_ = caml_call1(Core_Map[2], map),
     result = [0, caml_call1(Core_Map[124][1], _cV_)];
    function _cW_(param){return result[1];}
    var node = caml_call3(Incremental[79][2][2], state, 0, _cW_);
    function _cX_(key, incr){
     var
      _cY_ =
        [0,
         function(a){
          result[1] = caml_call3(Core_Map[38], result[1], key, a);
          return 0;
         }],
      _cZ_ = caml_call2(Incremental[79][1][2], _cY_, incr);
     return caml_call2(Incremental[79][2][6], node, _cZ_);
    }
    caml_call2(Core_Map[51], map, _cX_);
    return caml_call1(Incremental[79][2][3], node);
   }
   function join(opt, map_incr){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    return with_comparator$0
            (map_incr,
             function(comparator){
              var
               incremental_state = caml_call1(Incremental[4], map_incr),
               empty_map = caml_call1(Core_Map[124][1], comparator),
               result_map = [0, empty_map],
               old_map_of_incrs = [0, empty_map],
               current_dependencies = [0, empty_map];
              function _cL_(param){return result_map[1];}
              var
               result =
                 caml_call3(Incremental[79][2][2], incremental_state, 0, _cL_);
              function add_subnode(current_dependencies, key, data_node){
               var
                _cU_ =
                  [0,
                   function(data){
                    result_map[1] =
                     caml_call3(Core_Map[38], result_map[1], key, data);
                    return 0;
                   }],
                new_dep = caml_call2(Incremental[79][1][2], _cU_, data_node);
               caml_call2(Incremental[79][2][6], result, new_dep);
               return caml_call3
                       (Core_Map[38], current_dependencies, key, new_dep);
              }
              function remove_subnode(current_dependencies, key){
               var dep = caml_call2(Core_Map[45], current_dependencies, key);
               caml_call2(Incremental[79][2][7], result, dep);
               result_map[1] = caml_call2(Core_Map[47], result_map[1], key);
               return caml_call2(Core_Map[47], current_dependencies, key);
              }
              function _cM_(map_of_incrs){
               return caml_call1
                       (instrumentation,
                        function(param){
                         function _cO_(current_dependencies, param){
                          var diff = param[2], key = param[1], _cT_ = diff[1];
                          if(847852583 === _cT_)
                           return remove_subnode(current_dependencies, key);
                          if(1013247643 <= _cT_){
                           var data_node = diff[2][2];
                           return add_subnode
                                   (remove_subnode(current_dependencies, key), key, data_node);
                          }
                          var data_node$0 = diff[2];
                          return add_subnode(current_dependencies, key, data_node$0);
                         }
                         var _cP_ = current_dependencies[1];
                         function _cQ_(_cS_, _cR_){return _cS_ === _cR_ ? 1 : 0;}
                         var
                          new_dependency_map =
                            caml_call5
                             (Core_Map[89],
                              old_map_of_incrs[1],
                              map_of_incrs,
                              _cQ_,
                              _cP_,
                              _cO_);
                         current_dependencies[1] = new_dependency_map;
                         old_map_of_incrs[1] = map_of_incrs;
                         return 0;
                        });
              }
              var
               lhs_change = caml_call2(Incremental[10], map_incr, _cM_),
               _cN_ = caml_call2(Incremental[79][1][2], 0, lhs_change);
              caml_call2(Incremental[79][2][6], result, _cN_);
              return caml_call1(Incremental[79][2][3], result);
             });
   }
   function separate(opt, input_map, data_equal){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    var incremental_state = caml_call1(Incremental[4], input_map);
    return with_comparator$0
            (input_map,
             function(comparator){
              var
               empty = caml_call1(Core_Map[124][1], comparator),
               state = [0, empty, empty, empty];
              function _cz_(param){return state[3];}
              var
               output_map_node =
                 caml_call3(Incremental[79][2][2], incremental_state, 0, _cz_);
              function make_node_depend_on_input_map_(node, input_map_changed){
               var
                _cK_ = caml_call1(Core_Lazy[37], input_map_changed),
                dependency = caml_call2(Incremental[79][1][2], 0, _cK_);
               return caml_call2(Incremental[79][2][6], node, dependency);
              }
              var input_map_changed = [];
              caml_update_dummy
               (input_map_changed,
                [246,
                 function(_cA_){
                  function _cB_(input_map){
                   return caml_call1
                           (instrumentation,
                            function(param){
                             var prev_input_map = state[1];
                             function _cC_(param, _cE_){
                              var
                               change = _cE_[2],
                               key = _cE_[1],
                               output_map = param[2],
                               expert_nodes = param[1],
                               _cF_ = change[1];
                              if(847852583 === _cF_){
                               var old_node = caml_call2(Core_Map[45], expert_nodes, key);
                               caml_call1(Incremental[79][2][5], old_node);
                               caml_call1(Incremental[79][2][4], output_map_node);
                               var _cG_ = caml_call2(Core_Map[47], output_map, key);
                               return [0,
                                       caml_call2(Core_Map[47], expert_nodes, key),
                                       _cG_];
                              }
                              if(1013247643 <= _cF_){
                               var _cH_ = caml_call2(Core_Map[45], expert_nodes, key);
                               caml_call1(Incremental[79][2][4], _cH_);
                               return [0, expert_nodes, output_map];
                              }
                              function _cD_(param){
                               return caml_call2(Core_Map[45], state[1], key);
                              }
                              var
                               node =
                                 caml_call3
                                  (Incremental[79][2][2], incremental_state, 0, _cD_);
                              make_node_depend_on_input_map_(node, input_map_changed);
                              caml_call1(Incremental[79][2][4], output_map_node);
                              var
                               _cI_ = caml_call1(Incremental[79][2][3], node),
                               _cJ_ = caml_call3(Core_Map[37], output_map, key, _cI_);
                              return [0,
                                      caml_call3(Core_Map[37], expert_nodes, key, node),
                                      _cJ_];
                             }
                             var
                              match =
                                caml_call5
                                 (Core_Map[89],
                                  prev_input_map,
                                  input_map,
                                  data_equal,
                                  [0, state[2], state[3]],
                                  _cC_),
                              output_map = match[2],
                              expert_nodes = match[1];
                             state[1] = input_map;
                             state[2] = expert_nodes;
                             state[3] = output_map;
                             return 0;
                            });
                  }
                  return caml_call2(Incremental[10], input_map, _cB_);
                 }]);
              make_node_depend_on_input_map_
               (output_map_node, input_map_changed);
              return caml_call1(Incremental[79][2][3], output_map_node);
             });
   }
   function subrange(opt, _ci_, map_incr, range){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    if(_ci_)
     var sth$0 = _ci_[1], data_equal = sth$0;
    else
     var data_equal = function(_cy_, _cx_){return _cy_ === _cx_ ? 1 : 0;};
    return with_old2
            (instrumentation,
             map_incr,
             range,
             function(old, map, range){
              var compare = caml_call1(Core_Map[2], map)[1];
              function equal(l, r){
               var _cw_ = caml_call2(compare, l, r);
               return caml_call2(Core[90], _cw_, 0);
              }
              function maybe_bound_equal(a_008, b_009){
               if(a_008 === b_009) return 1;
               if(typeof a_008 === "number"){
                if(typeof b_009 === "number") return 1;
                if(1 === b_009[0]) return 0;
               }
               else{
                if(0 === a_008[0]){
                 var a_010 = a_008[1];
                 if(typeof b_009 !== "number" && 0 === b_009[0]){
                  var b_011 = b_009[1];
                  return equal(a_010, b_011);
                 }
                 return 0;
                }
                var a_012 = a_008[1];
                if(typeof b_009 === "number") return 0;
                if(0 !== b_009[0]){
                 var b_013 = b_009[1];
                 return equal(a_012, b_013);
                }
               }
               return 0;
              }
              function range_is_empty(min, max){
               a:
               if(typeof min !== "number"){
                if(0 === min[0]){
                 var min$0 = min[1];
                 if(typeof max === "number") break a;
                 if(0 === max[0]){
                  var
                   max$0 = max[1],
                   _ct_ = caml_call2(compare, min$0, max$0);
                  return caml_call2(Core[91], _ct_, 0);
                 }
                 var max$1 = max[1], min$1 = min$0;
                }
                else{
                 var _cv_ = min[1];
                 if(typeof max === "number") break a;
                 var max$1 = max[1], min$1 = _cv_;
                }
                var _cu_ = caml_call2(compare, min$1, max$1);
                return caml_call2(Core[88], _cu_, 0);
               }
               return 0;
              }
              function range_includes(min, max, key){
               var _cs_ = caml_call3(Core_Maybe_bound[22], min, key, compare);
               return _cs_
                       ? caml_call3(Core_Maybe_bound[23], max, key, compare)
                       : _cs_;
              }
              if(! range){
               var _cl_ = caml_call1(Core_Map[2], map);
               return caml_call1(Core_Map[124][1], _cl_);
              }
              var range$0 = range[1], max = range$0[2], min = range$0[1];
              function from_scratch(param){
               return caml_call3(Core_Map[107], map, min, max);
              }
              if(old){
               var _cj_ = old[1], match = _cj_[2];
               if(match){
                var
                 old_range = match[1],
                 old_min = old_range[1],
                 old_map = _cj_[1],
                 old_max = old_range[2];
                if
                 (!
                  range_is_empty(old_min, old_max)
                  &&
                   !
                   range_is_empty(min, old_max)
                   && ! range_is_empty(old_min, max)){
                 var
                  old_res = _cj_[3],
                  old_max$0 = old_range[2],
                  _ck_ =
                    function(param){
                     function apply_diff_in_intersection(param$0, _cp_){
                      var
                       data = _cp_[2],
                       key = _cp_[1],
                       map = param$0[2],
                       outside = param$0[1],
                       _co_ = range_includes(min, max, key),
                       _cq_ = _co_ ? range_includes(old_min, old_max$0, key) : _co_;
                      if(! _cq_){
                       var outside$0 = outside - 1 | 0;
                       return 0 <= outside$0
                               ? [0, outside$0, caml_call2(Core_Map[47], map, key)]
                               : caml_call1(param, from_scratch(0));
                      }
                      var _cr_ = data[1];
                      if(847852583 === _cr_)
                       return [0, outside, caml_call2(Core_Map[47], map, key)];
                      var data$0 = 1013247643 <= _cr_ ? data[2][2] : data[2];
                      return [0,
                              outside,
                              caml_call3(Core_Map[38], map, key, data$0)];
                     }
                     var
                      outside_cutoff = caml_call1(Core_Map[35], old_res) / 4 | 0,
                      with_updated_values_in_interse =
                        caml_call5
                          (Core_Map[89],
                           old_map,
                           map,
                           data_equal,
                           [0, outside_cutoff, old_res],
                           apply_diff_in_intersection)
                         [2];
                     if
                      (caml_call4
                        (Core_Tuple[1][10],
                         maybe_bound_equal,
                         maybe_bound_equal,
                         old_range,
                         range$0))
                      return with_updated_values_in_interse;
                     var
                      without_keys_out_of_range =
                        caml_call3
                         (Core_Map[107], with_updated_values_in_interse, min, max);
                     function map_append_exn(lower_part, upper_part){
                      var
                       match = caml_call2(Core_Map[106], lower_part, upper_part);
                      if(typeof match === "number")
                       return caml_call1(Core[6], cst_impossible_case_BUG_in_inc);
                      var map = match[2];
                      return map;
                     }
                     if(typeof old_min === "number")
                      var
                       _cm_ = caml_call1(Core_Map[2], map),
                       lower_part = caml_call1(Core_Map[124][1], _cm_);
                     else if(0 === old_min[0])
                      var
                       old_min$0 = old_min[1],
                       lower_part =
                         caml_call3(Core_Map[107], map, min, [1, old_min$0]);
                     else
                      var
                       old_min$1 = old_min[1],
                       lower_part =
                         caml_call3(Core_Map[107], map, min, [0, old_min$1]);
                     if(typeof old_max$0 === "number")
                      var
                       _cn_ = caml_call1(Core_Map[2], map),
                       upper_part = caml_call1(Core_Map[124][1], _cn_);
                     else if(0 === old_max$0[0])
                      var
                       old_max = old_max$0[1],
                       upper_part =
                         caml_call3(Core_Map[107], map, [1, old_max], max);
                     else
                      var
                       old_max$1 = old_max$0[1],
                       upper_part =
                         caml_call3(Core_Map[107], map, [0, old_max$1], max);
                     var
                      with_new_keys_now_in_range =
                        map_append_exn
                         (lower_part,
                          map_append_exn(without_keys_out_of_range, upper_part));
                     return with_new_keys_now_in_range;
                    };
                 return caml_call1(Core[268], _ck_);
                }
                return from_scratch(0);
               }
              }
              return from_scratch(0);
             });
   }
   function rekey(opt, data_equal, map_incr, outer_comparator, f){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    function _b9_(_ch_){return _ch_[1];}
    function _b__(key, data, param){
     var adds = param[2], output = param[1], _cg_ = caml_call2(f, key, data);
     return [0, caml_call2(Core_Map[47], output, _cg_), adds];
    }
    function _b$_(key, data, param){
     var
      adds = param[2],
      output = param[1],
      new_entry = [0, caml_call2(f, key, data), data];
     return [0, output, [0, new_entry, adds]];
    }
    var
     _ca_ = [0, caml_call1(Core_Map[4], outer_comparator), 0],
     _cb_ =
       [0,
        function(param){
         var adds = param[2], output = param[1];
         function _cf_(output, param){
          var data = param[2], key = param[1];
          return caml_call3(Core_Map[37], output, key, data);
         }
         var output$0 = caml_call3(Core_List[20], adds, output, _cf_);
         return [0, output$0, 0];
        }],
     _cc_ = 0,
     _cd_ =
       unordered_fold
        (instrumentation,
         data_equal,
         [0,
          function(key, old_data, new_data, param){
           var
            adds = param[2],
            output = param[1],
            prev_key = caml_call2(f, key, old_data),
            new_key = caml_call2(f, key, new_data),
            _ce_ =
              caml_call2
               (caml_call1(Core_Map[2], output)[1], prev_key, new_key);
           if(caml_call2(Core[90], _ce_, 0))
            return [0,
                    caml_call3(Core_Map[38], output, new_key, new_data),
                    adds];
           var output$0 = caml_call2(Core_Map[47], output, prev_key);
           return [0, output$0, [0, [0, new_key, new_data], adds]];
          }],
         _cc_,
         _cb_,
         _e_,
         map_incr,
         _ca_,
         _b$_,
         _b__);
    return caml_call2(Incremental[10], _cd_, _b9_);
   }
   function index_byi(opt, data_equal, map_incr, outer_comparator, index){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    return with_comparator$0
            (map_incr,
             function(inner_comparator){
              function _b5_(inner_key, data, outer_map){
               var match = caml_call2(index, inner_key, data);
               if(! match) return outer_map;
               var outer_key = match[1];
               function _b8_(param){
                if(! param)
                 return caml_call1(Core[6], cst_BUG_Hit_supposedly_impossi);
                var
                 inner_map = param[1],
                 inner_map$0 = caml_call2(Core_Map[47], inner_map, inner_key);
                return caml_call1(Core_Map[34], inner_map$0)
                        ? 0
                        : [0, inner_map$0];
               }
               return caml_call3(Core_Map[42], outer_map, outer_key, _b8_);
              }
              function _b6_(inner_key, data, outer_map){
               var match = caml_call2(index, inner_key, data);
               if(! match) return outer_map;
               var outer_key = match[1];
               function _b7_(param){
                if(! param)
                 return caml_call3
                         (Core_Map[124][2], inner_comparator, inner_key, data);
                var inner_map = param[1];
                return caml_call3(Core_Map[37], inner_map, inner_key, data);
               }
               return caml_call3(Core_Map[43], outer_map, outer_key, _b7_);
              }
              return unordered_fold
                      (instrumentation,
                       data_equal,
                       0,
                       0,
                       0,
                       _f_,
                       map_incr,
                       caml_call1(Core_Map[4], outer_comparator),
                       _b6_,
                       _b5_);
             });
   }
   function index_by(instrumentation, data_equal, map_incr, comparator, index){
    return index_byi
            (instrumentation,
             data_equal,
             map_incr,
             comparator,
             function(param, data){return caml_call1(index, data);});
   }
   function is_known(param){
    if(typeof param === "number" && param) return 0;
    return 1;
   }
   function to_option(param){
    if(typeof param === "number") return 0;
    var k = param[1];
    return [0, k];
   }
   function find_key_range_linear(from, to, map){
    var
     len = caml_call1(Core_Map[35], map),
     begin_key = caml_call2(Core_Int[81], from, len) ? 0 : 1,
     end_key = caml_call2(Core_Int[81], to, len) ? 0 : 1;
    function find_keys(fold, start_pos, advance_pos){
     function _b3_(param){
      return caml_call3
              (fold,
               map,
               [0, begin_key, end_key, start_pos],
               function(key, param$0, _b4_){
                var
                 pos = _b4_[3],
                 end_key = _b4_[2],
                 begin_key = _b4_[1],
                 begin_key$0 =
                   caml_call2(Core_Int[83], pos, from) ? [0, key] : begin_key,
                 end_key$0 =
                   caml_call2(Core_Int[83], pos, to) ? [0, key] : end_key;
                if(is_known(begin_key$0) && is_known(end_key$0))
                 return caml_call1(param, [0, begin_key$0, end_key$0, pos]);
                return [0,
                        begin_key$0,
                        end_key$0,
                        caml_call1(advance_pos, pos)];
               });
     }
     return caml_call1(Core[268], _b3_);
    }
    if(caml_call2(Core[92], to, len - from | 0))
     var
      _bZ_ = function(pos){return pos + 1 | 0;},
      match = find_keys(Core_Map[61], 0, _bZ_);
    else
     var
      _b2_ = function(pos){return pos - 1 | 0;},
      match = find_keys(Core_Map[63], len - 1 | 0, _b2_);
    var end_key$0 = match[2], begin_key$0 = match[1];
    function _b0_(begin_key){return [0, begin_key, to_option(end_key$0)];}
    var _b1_ = to_option(begin_key$0);
    return caml_call2(Core_Option[34], _b1_, _b0_);
   }
   function rank(opt, map, key){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    return with_comparator$0
            (map,
             function(comparator){
              var compare_key = comparator[1];
              function same_key(a, b){
               var _bY_ = caml_call2(compare_key, a, b);
               return caml_call2(Core[90], _bY_, 0);
              }
              function process(old, new_map, new_key){
               var old$0 = old;
               for(;;){
                if(! caml_call2(Core_Map[48], new_map, new_key)) return 0;
                if(old$0){
                 var
                  match = old$0[1],
                  old_rank = match[3],
                  old_key = match[2],
                  old_map = match[1];
                 if(new_map === old_map && same_key(old_key, new_key))
                  return old_rank;
                 if(old_rank){
                  var old_rank$0 = old_rank[1];
                  if(new_map === old_map){
                   var _bQ_ = caml_call2(compare_key, new_key, old_key);
                   if(caml_call2(Core[92], _bQ_, 0))
                    var
                     upper_bound = [1, old_key],
                     lower_bound = [1, new_key],
                     subrange =
                       caml_call3(Core_Map[107], new_map, lower_bound, upper_bound),
                     _bT_ =
                       (old_rank$0 - caml_call1(Core_Map[35], subrange) | 0) - 1
                       | 0;
                   else
                    var
                     upper_bound$0 = [1, new_key],
                     lower_bound$0 = [1, old_key],
                     subrange$0 =
                       caml_call3
                        (Core_Map[107], new_map, lower_bound$0, upper_bound$0),
                     _bT_ =
                       (old_rank$0 + caml_call1(Core_Map[35], subrange$0) | 0) + 1
                       | 0;
                   return [0, _bT_];
                  }
                  if(same_key(new_key, old_key)){
                   var
                    _bR_ =
                      function(acc, param){
                       var diff = param[2], diff_key = param[1];
                       if(typeof diff !== "number"){
                        var _bV_ = diff[1];
                        if(-57574468 === _bV_){
                         var _bW_ = caml_call2(compare_key, diff_key, new_key);
                         if(caml_call2(Core[92], _bW_, 0)) return acc + 1 | 0;
                        }
                        else if(847852583 === _bV_){
                         var _bX_ = caml_call2(compare_key, diff_key, new_key);
                         if(caml_call2(Core[92], _bX_, 0)) return acc - 1 | 0;
                        }
                       }
                       return acc;
                      },
                    _bS_ = function(param, _bU_){return 1;};
                   return [0,
                           caml_call5
                            (Core_Map[89], old_map, new_map, _bS_, old_rank$0, _bR_)];
                  }
                  var
                   old_rank$1 =
                     process
                      ([0, [0, old_map, old_key, [0, old_rank$0]]],
                       new_map,
                       old_key),
                   old$1 = [0, [0, new_map, old_key, old_rank$1]],
                   old$0 = old$1;
                  continue;
                 }
                }
                return caml_call2(Core_Map[113], new_map, new_key);
               }
              }
              return with_old2(instrumentation, map, key, process);
             });
   }
   function subrange_by_rank(opt, data_equal, map, range){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    function find_key_range(range){
     return with_old2
             (instrumentation,
              map,
              range,
              function(old, map, param){
               var
                to = param[2],
                from = param[1],
                _bx_ = caml_call2(Core_Int[85], to, from),
                _by_ = _bx_ || caml_call2(Core_Int[85], from, 0);
               if(_by_){
                var
                 _bz_ =
                   [0, [1, [0, _g_, [0, caml_call1(Core[389], to), 0]]], 0],
                 _bA_ =
                   [0,
                    [1, [0, _h_, [0, caml_call1(Core[389], from), 0]]],
                    _bz_],
                 _bB_ =
                   [1,
                    [0,
                     caml_call1(Sexplib0_Sexp_conv[7], cst_Invalid_indices),
                     _bA_]];
                caml_call1(Core[261], _bB_);
               }
               if(old){
                var _bC_ = old[1], _bD_ = _bC_[3];
                if(_bD_){
                 var
                  _bE_ = _bD_[1],
                  end_key_opt$0 = _bE_[2],
                  begin_key = _bE_[1],
                  match = _bC_[2],
                  old_to = match[2],
                  old_from = match[1],
                  old_map = _bC_[1],
                  compare = caml_call1(Core_Map[2], map)[1],
                  find_offset =
                    function(key, changed_key, change){
                     var _bO_ = caml_call2(compare, changed_key, key);
                     if(! caml_call2(Core_Int[85], _bO_, 0)) return 0;
                     if(typeof change !== "number"){
                      var _bP_ = change[1];
                      if(-57574468 === _bP_) return -1;
                      if(847852583 === _bP_) return 1;
                     }
                     return 0;
                    },
                  range_offset_begin = from - old_from | 0,
                  range_offset_end = to - old_to | 0,
                  adjust_and_offset =
                    function(by$1, key$1){
                     a:
                     {
                      if
                       (caml_call2(Core[88], by$1, 0)
                        && ! caml_call2(Core_Map[48], map, key$1)){var _bN_ = 1; break a;}
                      var _bN_ = 0;
                     }
                     var by$2 = by$1 + _bN_ | 0, key = key$1, by = by$2;
                     for(;;){
                      if(caml_call2(Core_Int[83], by, 0)) return [0, key];
                      if(caml_call2(Core_Int[85], by, 0))
                       var add = 1, closest_dir = -640801497;
                      else
                       var add = -1, closest_dir = -779285466;
                      var
                       match = caml_call3(Core_Map[110], map, closest_dir, key);
                      if(! match) return 0;
                      var
                       key$0 = match[1][1],
                       by$0 = by + add | 0,
                       key = key$0,
                       by = by$0;
                     }
                    },
                  diff =
                    function(init, f){
                     function _bL_(param, _bM_){return 1;}
                     return caml_call5(Core_Map[89], old_map, map, _bL_, init, f);
                    };
                 if(end_key_opt$0)
                  var
                   end_key = end_key_opt$0[1],
                   match$0 =
                     diff
                      (_i_,
                       function(param, _bI_){
                        var
                         change = _bI_[2],
                         key = _bI_[1],
                         offset_end = param[2],
                         offset_begin = param[1],
                         _bJ_ = offset_end + find_offset(end_key, key, change) | 0;
                        return [0,
                                offset_begin + find_offset(begin_key, key, change) | 0,
                                _bJ_];
                       }),
                   map_offset_end = match$0[2],
                   map_offset_begin = match$0[1],
                   end_key_opt$1 =
                     adjust_and_offset
                      (map_offset_end + range_offset_end | 0, end_key),
                   end_key_opt$2 = end_key_opt$1,
                   begin_key_opt =
                     adjust_and_offset
                      (map_offset_begin + range_offset_begin | 0, begin_key);
                 else
                  var
                   map_offset_begin$0 =
                     diff
                      (0,
                       function(offset_begin, param){
                        var change = param[2], key = param[1];
                        return offset_begin + find_offset(begin_key, key, change)
                               | 0;
                       }),
                   _bv_ = function(_bK_){return _bK_[1];},
                   _bw_ = find_key_range_linear(to, to, map),
                   end_key_opt = caml_call2(Core_Option[34], _bw_, _bv_),
                   begin_key_opt$0 =
                     adjust_and_offset
                      (map_offset_begin$0 + range_offset_begin | 0, begin_key),
                   end_key_opt$2 = end_key_opt,
                   begin_key_opt = begin_key_opt$0;
                 var _bF_ = caml_call1(Core_Map[48], map);
                 if(! caml_call2(Core_Option[48], begin_key_opt, _bF_))
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _k_], 1);
                 var _bG_ = caml_call1(Core_Map[48], map);
                 if(! caml_call2(Core_Option[48], end_key_opt$2, _bG_))
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _j_], 1);
                 var
                  _bH_ =
                    function(begin_key){return [0, begin_key, end_key_opt$2];};
                 return caml_call2(Core_Option[34], begin_key_opt, _bH_);
                }
               }
               return find_key_range_linear(from, to, map);
              });
    }
    function symbol(new$0, bound){
     function _bu_(param){return new$0;}
     return caml_call2(Core_Maybe_bound[21], bound, _bu_);
    }
    var
     _a9_ = caml_call1(Incremental[4], map),
     return$0 = caml_call1(Incremental[9], _a9_);
    function _a__(param){
     if(3 < param >>> 0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     switch(param){
       case 0:
        return caml_call1(return$0, _m_);
       case 1:
        var
         _bb_ =
           function(param){
            var _bt_ = param[1];
            if(typeof _bt_ !== "number"){
             var pattern_syntax_014 = _bt_[1];
             if(typeof param[2] !== "number") return pattern_syntax_014;
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
           },
         l = caml_call2(Incremental[76][3][5], range, _bb_),
         _bc_ =
           function(param){
            var pattern_syntax_015 = param[1];
            if
             (typeof pattern_syntax_015 !== "number"
              && typeof param[2] !== "number")
             return pattern_syntax_015;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
           },
         lb = caml_call2(Incremental[76][3][5], range, _bc_),
         _bd_ =
           function(param){
            if(typeof param[1] !== "number"){
             var match = param[2];
             if(typeof match !== "number"){
              var pattern_syntax_016 = match[1];
              return pattern_syntax_016;
             }
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
           },
         u = caml_call2(Incremental[76][3][5], range, _bd_),
         _be_ =
           function(param){
            if(typeof param[1] !== "number"){
             var pattern_syntax_017 = param[2];
             if(typeof pattern_syntax_017 !== "number")
              return pattern_syntax_017;
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
           },
         ub = caml_call2(Incremental[76][3][5], range, _be_),
         let_syntax_022 = find_key_range(caml_call2(Incremental[40], l, u)),
         _bf_ =
           function(param){
            var
             match = param[2],
             ub = match[2],
             lb = match[1],
             key_range = param[1];
            if(! key_range) return 0;
            var _br_ = key_range[1], match$0 = _br_[2], begin_key = _br_[1];
            if(! match$0) return [0, [0, symbol(begin_key, lb), 0]];
            var end_key = match$0[1], _bs_ = symbol(end_key, ub);
            return [0, [0, symbol(begin_key, lb), _bs_]];
           },
         _bg_ = caml_call2(Incremental[76][3][20], lb, ub),
         _bh_ = caml_call2(Incremental[76][3][20], let_syntax_022, _bg_);
        return caml_call2(Incremental[76][3][5], _bh_, _bf_);
       case 2:
        var
         _bi_ =
           function(param){
            var _bq_ = param[1];
            if(typeof _bq_ !== "number"){
             var pattern_syntax_018 = _bq_[1];
             if(typeof param[2] === "number") return pattern_syntax_018;
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
           },
         l$0 = caml_call2(Incremental[76][3][5], range, _bi_),
         _bj_ =
           function(param){
            var pattern_syntax_019 = param[1];
            if
             (typeof pattern_syntax_019 !== "number"
              && typeof param[2] === "number")
             return pattern_syntax_019;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
           },
         lb$0 = caml_call2(Incremental[76][3][5], range, _bj_),
         let_syntax_026 =
           find_key_range(caml_call2(Incremental[40], l$0, l$0)),
         _bk_ =
           function(param){
            var lb = param[2], key_range = param[1];
            if(! key_range) return 0;
            var key = key_range[1][1];
            return [0, [0, symbol(key, lb), 0]];
           },
         _bl_ = caml_call2(Incremental[76][3][20], let_syntax_026, lb$0);
        return caml_call2(Incremental[76][3][5], _bl_, _bk_);
       default:
        var
         _bm_ =
           function(param){
            if(typeof param[1] === "number"){
             var match = param[2];
             if(typeof match !== "number"){
              var pattern_syntax_020 = match[1];
              return pattern_syntax_020;
             }
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
           },
         u$0 = caml_call2(Incremental[76][3][5], range, _bm_),
         _bn_ =
           function(param){
            if(typeof param[1] === "number"){
             var pattern_syntax_021 = param[2];
             if(typeof pattern_syntax_021 !== "number")
              return pattern_syntax_021;
            }
            throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
           },
         ub$0 = caml_call2(Incremental[76][3][5], range, _bn_),
         let_syntax_029 =
           find_key_range(caml_call2(Incremental[40], u$0, u$0)),
         _bo_ =
           function(param){
            var ub = param[2], key_range = param[1];
            if(! key_range) return _v_;
            var key = key_range[1][1];
            return [0, [0, 0, symbol(key, ub)]];
           },
         _bp_ = caml_call2(Incremental[76][3][20], let_syntax_029, ub$0);
        return caml_call2(Incremental[76][3][5], _bp_, _bo_);
     }
    }
    function _a$_(param){
     return typeof param[1] === "number"
             ? typeof param[2] === "number" ? 0 : 3
             : typeof param[2] === "number" ? 2 : 1;
    }
    var
     _ba_ = caml_call2(Incremental[76][3][5], range, _a$_),
     key_range = caml_call2(Incremental[76][3][1], _ba_, _a__);
    return subrange(0, data_equal, map, key_range);
   }
   function transpose(opt, _aW_, k2_comparator, m){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    if(_aW_)
     var sth$0 = _aW_[1], data_equal = sth$0;
    else
     var data_equal = function(_a8_, _a7_){return _a8_ === _a7_ ? 1 : 0;};
    return with_comparator$0
            (m,
             function(k1_comparator){
              function update(k1, old_data, new_data, acc){
               function _a1_(acc, param){
                var diff = param[2], k2 = param[1], _a2_ = diff[1];
                if(847852583 === _a2_)
                 var value = 0;
                else
                 var
                  x = 1013247643 <= _a2_ ? diff[2][2] : diff[2],
                  value = [0, x];
                function _a3_(acc_inner){
                 function _a4_(param){return value;}
                 var
                  _a5_ = caml_call1(Core_Map[124][1], k1_comparator),
                  _a6_ = caml_call2(Core_Option[39], acc_inner, _a5_),
                  acc_inner$0 = caml_call3(Core_Map[42], _a6_, k1, _a4_);
                 return caml_call1(Core_Map[34], acc_inner$0)
                         ? 0
                         : [0, acc_inner$0];
                }
                return caml_call3(Core_Map[42], acc, k2, _a3_);
               }
               return caml_call5
                       (Core_Map[89], old_data, new_data, data_equal, acc, _a1_);
              }
              function add(key, data){
               var _aZ_ = caml_call1(Core_Map[4], k2_comparator);
               return function(_a0_){return update(key, _aZ_, data, _a0_);};
              }
              function remove(key, data){
               var _aX_ = caml_call1(Core_Map[4], k2_comparator);
               return function(_aY_){return update(key, data, _aX_, _aY_);};
              }
              return unordered_fold
                      (instrumentation,
                       0,
                       [0, update],
                       0,
                       0,
                       _w_,
                       m,
                       caml_call1(Core_Map[4], k2_comparator),
                       add,
                       remove);
             });
   }
   function collapse_by(opt, data_equal, map_incr, merge_keys, comparator){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    function _aQ_(outer_key, inner_key, param, acc){
     var _aV_ = caml_call2(merge_keys, outer_key, inner_key);
     return caml_call2(Core_Map[47], acc, _aV_);
    }
    function _aR_(outer_key, inner_key, data, acc){
     var _aU_ = caml_call2(merge_keys, outer_key, inner_key);
     return caml_call3(Core_Map[37], acc, _aU_, data);
    }
    var _aS_ = caml_call1(Core_Map[4], comparator);
    return unordered_fold_nested_maps
            (instrumentation,
             data_equal,
             _x_,
             [0,
              function(outer_key, inner_key, param, new_data, acc){
               var _aT_ = caml_call2(merge_keys, outer_key, inner_key);
               return caml_call3(Core_Map[38], acc, _aT_, new_data);
              }],
             map_incr,
             _aS_,
             _aR_,
             _aQ_);
   }
   function collapse(instrumentation, data_equal, map_incr, inner_comparator){
    return with_comparator$0
            (map_incr,
             function(outer_comparator){
              var
               inner_comparator$0 = inner_comparator[1],
               comparator =
                 caml_call2
                  (Core_Tuple[1][5], outer_comparator, inner_comparator$0);
              return collapse_by
                      (instrumentation,
                       data_equal,
                       map_incr,
                       Core_Tuple[1][6],
                       [0, comparator]);
             });
   }
   function expand
   (opt, data_equal, map_incr, outer_comparator, inner_comparator){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    function _aF_(param, _aN_, acc){
     var inner_key = param[2], outer_key = param[1];
     function _aO_(param){
      if(! param) return 0;
      var
       map = param[1],
       map$0 = caml_call2(Core_Map[47], map, inner_key),
       _aP_ = 1 - caml_call1(Core_Map[34], map$0);
      return caml_call2(Core_Option[60], _aP_, map$0);
     }
     return caml_call3(Core_Map[42], acc, outer_key, _aO_);
    }
    function _aG_(param, data, acc){
     var inner_key = param[2], outer_key = param[1];
     function _aM_(param){
      if(! param)
       return caml_call3(Core_Map[5], inner_comparator, inner_key, data);
      var map = param[1];
      return caml_call3(Core_Map[37], map, inner_key, data);
     }
     return caml_call3(Core_Map[43], acc, outer_key, _aM_);
    }
    var _aH_ = caml_call1(Core_Map[4], outer_comparator), _aI_ = 0, _aJ_ = 0;
    return unordered_fold
            (instrumentation,
             data_equal,
             [0,
              function(param, _aK_, new_data, acc){
               var inner_key = param[2], outer_key = param[1];
               function _aL_(param){
                if(! param)
                 return caml_call3
                         (Core_Map[5], inner_comparator, inner_key, new_data);
                var map = param[1];
                return caml_call3(Core_Map[38], map, inner_key, new_data);
               }
               return caml_call3(Core_Map[43], acc, outer_key, _aL_);
              }],
             _aJ_,
             _aI_,
             _y_,
             map_incr,
             _aH_,
             _aG_,
             _aF_);
   }
   function counti(opt, data_equal, map_incr, f){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    function _aE_(key, data, count){
     return caml_call2(f, key, data) ? count - 1 | 0 : count;
    }
    return unordered_fold
            (instrumentation,
             data_equal,
             0,
             0,
             0,
             _z_,
             map_incr,
             0,
             function(key, data, count){
              return caml_call2(f, key, data) ? count + 1 | 0 : count;
             },
             _aE_);
   }
   function count(instrumentation, data_equal, map_incr, f){
    return counti
            (instrumentation,
             data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   function existsi(instrumentation, data_equal, map_incr, f){
    function _aC_(count){return caml_call2(Core[93], count, 0);}
    var _aD_ = counti(instrumentation, data_equal, map_incr, f);
    return caml_call2(Incremental[10], _aD_, _aC_);
   }
   function exists(instrumentation, data_equal, map_incr, f){
    return existsi
            (instrumentation,
             data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   function sum(opt, data_equal, map_incr, Group, f){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    function _ay_(param, v, acc){
     var _aB_ = caml_call1(f, v);
     return caml_call2(Group[3], acc, _aB_);
    }
    function _az_(param, v, acc){
     var _aA_ = caml_call1(f, v);
     return caml_call2(Group[2], acc, _aA_);
    }
    return unordered_fold
            (instrumentation,
             data_equal,
             0,
             0,
             0,
             _A_,
             map_incr,
             Group[1],
             _az_,
             _ay_);
   }
   function observe_changes_exn(opt, map, f){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = function(_ax_, _aw_){return _ax_ === _aw_ ? 1 : 0;};
    var
     state = caml_call1(Incremental[4], map),
     scope = caml_call2(Incremental[50][2], state, 0);
    if(1 - caml_call1(Incremental[50][4], scope))
     caml_call1(Core[6], cst_Incr_map_observe_changes_e);
    function empty_version_of(map){
     var _av_ = caml_call1(Core_Map[3], map);
     return caml_call1(Core_Map[4], _av_);
    }
    var observer = caml_call2(Incremental[53], 0, map);
    function _as_(diff_elt){
     if(typeof diff_elt === "number"){
      var match = caml_call1(Incremental[52][5], observer);
      if(0 === match[0])
       var
        final_value = match[1],
        _au_ = [0, [0, final_value, empty_version_of(final_value)]];
      else
       var _au_ = 0;
      var before_and_after = _au_;
     }
     else if(0 === diff_elt[0])
      var
       v = diff_elt[1],
       before_and_after = [0, [0, empty_version_of(v), v]];
     else
      var
       v2 = diff_elt[2],
       v1 = diff_elt[1],
       before_and_after = [0, [0, v1, v2]];
     if(! before_and_after) return 0;
     var
      match$0 = before_and_after[1],
      after = match$0[2],
      before = match$0[1];
     function _at_(param, update){return caml_call1(f, update);}
     return caml_call5(Core_Map[89], before, after, data_equal, 0, _at_);
    }
    return caml_call2(Incremental[52][8], observer, _as_);
   }
   function for_alli(instrumentation, data_equal, map_incr, f){
    function _aq_(count){return caml_call2(Core[90], count, 0);}
    var
     _ar_ =
       counti
        (instrumentation,
         data_equal,
         map_incr,
         function(key, data){return 1 - caml_call2(f, key, data);});
    return caml_call2(Incremental[10], _ar_, _aq_);
   }
   function for_all(instrumentation, data_equal, map_incr, f){
    return for_alli
            (instrumentation,
             data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   function unordered_fold$0
   (opt,
    data_equal,
    update,
    specialized_initial,
    finalize,
    revert_to_init_when_empty,
    map,
    init,
    add,
    remove){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    return unordered_fold
            (instrumentation,
             data_equal,
             update,
             specialized_initial,
             finalize,
             revert_to_init_when_empty,
             map,
             init,
             add,
             remove);
   }
   function unordered_fold_nested_maps$0
   (opt,
    data_equal,
    revert_to_init_when_empty,
    update,
    map,
    init,
    add,
    remove){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    return unordered_fold_nested_maps
            (instrumentation,
             data_equal,
             revert_to_init_when_empty,
             update,
             map,
             init,
             add,
             remove);
   }
   var For_testing = [0, find_key_range_linear];
   function M(K){return [0];}
   function create(opt, _ae_, input_map, comparator){
    if(opt)
     var sth = opt[1], instrumentation = sth;
    else
     var instrumentation = no_instrumentation;
    if(_ae_)
     var sth$0 = _ae_[1], data_equal = sth$0;
    else
     var data_equal = function(_ap_, _ao_){return _ap_ === _ao_ ? 1 : 0;};
    var self = [];
    caml_update_dummy
     (self,
      [246,
       function(param){
        function _ag_(input_map){
         return caml_call1
                 (instrumentation,
                  function(param){
                   var _ai_ = caml_obj_tag(self);
                   a:
                   if(250 === _ai_)
                    var self$0 = self[1];
                   else{
                    if(246 !== _ai_ && 244 !== _ai_){var self$0 = self; break a;}
                    var self$0 = caml_call1(CamlinternalLazy[2], self);
                   }
                   function _aj_(param, _ak_){
                    var
                     changed_value = _ak_[2],
                     key = _ak_[1],
                     entries = caml_call2(Core_Map[41], self$0[2], key);
                    function _al_(entry){
                     var _am_ = changed_value[1];
                     if(847852583 === _am_)
                      var _an_ = 0;
                     else
                      var
                       new_value =
                         1013247643 <= _am_ ? changed_value[2][2] : changed_value[2],
                       _an_ = [0, new_value];
                     entry[1] = _an_;
                     return caml_call1(Incremental[79][2][4], entry[2]);
                    }
                    return caml_call2(Core_List[19], entries, _al_);
                   }
                   caml_call5
                    (Core_Map[89], self$0[1], input_map, data_equal, 0, _aj_);
                   self$0[1] = input_map;
                   return 0;
                  });
        }
        var
         updater_node = caml_call2(Incremental[10], input_map, _ag_),
         empty_map = caml_call1(Core_Map[124][1], comparator),
         _ah_ = caml_call1(Incremental[4], input_map);
        return [0,
                empty_map,
                empty_map,
                updater_node,
                caml_call2(Incremental[50][2], _ah_, 0)];
       }]);
    var _af_ = caml_obj_tag(self);
    if(250 === _af_) return self[1];
    if(246 !== _af_ && 244 !== _af_) return self;
    return caml_call1(CamlinternalLazy[2], self);
   }
   function find(t, key){
    var match = caml_call2(Core_Map[41], t[2], key);
    if(match){
     var entry = match[1];
     return caml_call1(Incremental[79][2][3], entry[2]);
    }
    var incremental_state = caml_call1(Incremental[4], t[3]);
    function _U_(param){
     var entry = [];
     caml_update_dummy
      (entry,
       [246,
        function(param){
         function _X_(param){return caml_call1(Core[248], entry)[1];}
         var
          _Y_ =
            [0,
             function(is_now_observable){
              var ___ = caml_obj_tag(entry);
              a:
              if(250 === ___)
               var entry$0 = entry[1];
              else{
               if(246 !== ___ && 244 !== ___){var entry$0 = entry; break a;}
               var entry$0 = caml_call1(CamlinternalLazy[2], entry);
              }
              var current_entries = caml_call2(Core_Map[41], t[2], key);
              function _$_(_ad_){return entry$0 === _ad_ ? 1 : 0;}
              var is_linked = caml_call2(Core_List[23], current_entries, _$_);
              if(caml_call2(Core_Bool[32], is_linked, is_now_observable))
               return 0;
              if(is_now_observable){
               var
                _aa_ =
                  function(param){
                   if(param){
                    var other_entries = param[1];
                    if(other_entries){
                     var other_entry = other_entries[1];
                     entry$0[1] = other_entry[1];
                     return [0, entry$0, other_entries];
                    }
                   }
                   entry$0[1] = caml_call2(Core_Map[44], t[1], key);
                   return [0, entry$0, 0];
                  };
               t[2] = caml_call3(Core_Map[43], t[2], key, _aa_);
               return 0;
              }
              function _ab_(x){return 1 - (entry$0 === x ? 1 : 0);}
              var
               new_entries = caml_call2(Core_List[12], current_entries, _ab_),
               _ac_ =
                 caml_call1(Core_List[18], new_entries)
                  ? caml_call2(Core_Map[47], t[2], key)
                  : caml_call3(Core_Map[38], t[2], key, new_entries);
              t[2] = _ac_;
              return 0;
             }],
          _Z_ = caml_call3(Incremental[79][2][2], incremental_state, _Y_, _X_);
         return [0, caml_call2(Core_Map[44], t[1], key), _Z_];
        }]);
     var _V_ = caml_obj_tag(entry);
     a:
     if(250 === _V_)
      var entry$0 = entry[1];
     else{
      if(246 !== _V_ && 244 !== _V_){var entry$0 = entry; break a;}
      var entry$0 = caml_call1(CamlinternalLazy[2], entry);
     }
     var _W_ = caml_call2(Incremental[79][1][2], 0, t[3]);
     caml_call2(Incremental[79][2][6], entry$0[2], _W_);
     return caml_call1(Incremental[79][2][3], entry$0[2]);
    }
    return caml_call3(Incremental[50][3], incremental_state, t[4], _U_);
   }
   function sexp_of_t(sexp_of_key, sexp_of_value, t){
    function _J_(key, data){
     var _K_ = data[1];
     if(737457313 === _K_)
      var
       match = data[2],
       entries = match[2],
       x = match[1],
       actual_value = [0, x],
       entries$0 = entries,
       actual_value$0 = actual_value;
     else if(847852583 <= _K_)
      var x$0 = data[2], entries$0 = 0, actual_value$0 = [0, x$0];
     else
      var y = data[2], entries$0 = y, actual_value$0 = 0;
     var _L_ = 0, _M_ = 0;
     function _N_(entry){
      var
       saved_value = entry[1],
       node = entry[2],
       node$0 = caml_call1(Incremental[79][2][3], node),
       match = caml_call1(Incremental[67], node$0),
       _P_ = caml_call1(Incremental[5], node$0),
       match$0 = caml_call2(Core_Option[60], _P_, 0),
       _Q_ = 1 - caml_call1(Incremental[6], node$0),
       match$1 = caml_call2(Core_Option[60], _Q_, 0),
       _R_ = 1 - caml_call1(Incremental[7], node$0),
       _S_ = caml_call2(Core_Option[60], _R_, 0),
       match$2 = 0;
      if(_S_)
       var
        v = _S_[1],
        match$3 =
          [0, [1, [0, _B_, [0, caml_call1(Core[620], v), 0]]], match$2];
      else
       var match$3 = match$2;
      if(match$1)
       var
        v$0 = match$1[1],
        match$4 =
          [0, [1, [0, _C_, [0, caml_call1(Core[620], v$0), 0]]], match$3];
      else
       var match$4 = match$3;
      if(match$0)
       var
        v$1 = match$0[1],
        match$5 =
          [0, [1, [0, _D_, [0, caml_call1(Core[620], v$1), 0]]], match$4];
      else
       var match$5 = match$4;
      if(match)
       var
        v$2 = match[1],
        _T_ =
          [0, [1, [0, _E_, [0, caml_call1(Core_Info[9], v$2), 0]]], match$5];
      else
       var _T_ = match$5;
      return [1,
              [0,
               [1,
                [0,
                 _F_,
                 [0, caml_call2(Core[515], sexp_of_value, saved_value), 0]]],
               _T_]];
     }
     var
      match$0 =
        [0,
         [1, [0, _G_, [0, caml_call2(Core[472], _N_, entries$0), _M_]]],
         _L_];
     if(actual_value$0)
      var
       v = actual_value$0[1],
       _O_ = [0, [1, [0, _H_, [0, caml_call1(sexp_of_value, v), 0]]], match$0];
     else
      var _O_ = match$0;
     return [0,
             [1,
              [0, [1, [0, _I_, [0, caml_call1(sexp_of_key, key), 0]]], _O_]]];
    }
    var info_per_key = caml_call3(Core_Map[84], t[1], t[2], _J_);
    return [1, caml_call1(Core_Map[80], info_per_key)];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incr_map);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incr_map);
   var
    Incr_map =
      [0,
       of_set,
       filter_mapi,
       mapi,
       filter_map,
       map,
       filter_mapi$0,
       map$0,
       filter_map$0,
       mapi$0,
       partition_mapi,
       partition_mapi$0,
       unordered_fold$0,
       unordered_fold_with_extra,
       cutoff,
       mapi_count,
       map_count,
       mapi_min,
       mapi_max,
       map_min,
       map_max,
       min_value,
       max_value,
       mapi_bounds,
       map_bounds,
       value_bounds,
       merge,
       merge_both_some,
       merge_disjoint,
       merge$0,
       unzip,
       unzip_mapi,
       unzip_mapi$0,
       flatten,
       join,
       separate,
       keys,
       rank,
       subrange,
       subrange_by_rank,
       rekey,
       index_byi,
       index_by,
       unordered_fold_nested_maps$0,
       transpose,
       collapse,
       collapse_by,
       expand,
       counti,
       count,
       for_alli,
       for_all,
       existsi,
       exists,
       sum,
       observe_changes_exn,
       [0, create, find, M, [0, sexp_of_t]],
       For_testing,
       function(Incr){
        function flatten$0(x){return flatten(Incr[2][3], x);}
        function M(K){return [0];}
        return [0,
                of_set,
                filter_mapi,
                mapi,
                filter_map,
                map,
                filter_mapi$0,
                mapi$0,
                filter_map$0,
                map$0,
                partition_mapi,
                partition_mapi$0,
                unordered_fold$0,
                unordered_fold_with_extra,
                cutoff,
                mapi_count,
                map_count,
                mapi_min,
                mapi_max,
                map_min,
                map_max,
                min_value,
                max_value,
                mapi_bounds,
                map_bounds,
                value_bounds,
                merge,
                merge_both_some,
                merge_disjoint,
                unzip,
                unzip_mapi,
                unzip_mapi$0,
                merge$0,
                flatten$0,
                join,
                separate,
                keys,
                rank,
                subrange,
                subrange_by_rank,
                rekey,
                index_byi,
                index_by,
                unordered_fold_nested_maps$0,
                transpose,
                collapse,
                collapse_by,
                expand,
                counti,
                count,
                for_alli,
                for_all,
                existsi,
                exists,
                sum,
                observe_changes_exn,
                [0, create, find, M, [0, sexp_of_t]],
                For_testing];
       }];
   runtime.caml_register_global(71, Incr_map, cst_Incr_map$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJpbmNyX21hcC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsibm9faW5zdHJ1bWVudGF0aW9uIiwiZiIsIndpdGhfb2xkIiwiaW5zdHJ1bWVudGF0aW9uIiwiaSIsIm9sZCIsImEiLCJiIiwiY3V0b2ZmIiwib3B0IiwibWFwIiwic3RoIiwiZGF0YV9lcXVhbCIsIm9sZF92YWx1ZSIsIm5ld192YWx1ZSIsImN1ciIsIm9sZCQwIiwiYWNjIiwiY2hhbmdlIiwia2V5IiwibmV3JDAiLCJ1bm9yZGVyZWRfZm9sZCIsInVwZGF0ZSIsInNwZWNpYWxpemVkX2luaXRpYWwiLCJpbml0IiwiYWRkIiwicmVtb3ZlIiwic3RoJDAiLCJmaW5hbGl6ZSIsInN0aCQxIiwicmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eSIsImRlZmF1bHQkMCIsIm9sZF9kYXRhIiwibmV3X2RhdGEiLCJ1cGRhdGUkMCIsIm5ld19pbiIsIm9sZF9vdXQiLCJvbGRfaW4iLCJpbml0JDAiLCJuZXckMSIsImluaXRpYWwiLCJ1bm9yZGVyZWRfZm9sZF9uZXN0ZWRfbWFwcyIsImluY3JfbWFwIiwidXBkYXRlJDEiLCJvdXRlcl9rZXkiLCJpbm5lcl9rZXkiLCJpbm5lcl9tYXAiLCJkYXRhIiwib2xkX2lubmVyX21hcCIsIm5ld19pbm5lcl9tYXAiLCJkaWZmIiwiZGF0YV9yZW1vdmVkIiwiZGF0YV9hZGRlZCIsIndpdGhfY29tcGFyYXRvciIsImdldF9jb21wYXJhdG9yIiwieCIsIndpdGhfY29tcGFyYXRvciQwIiwib2Zfc2V0Iiwic2V0IiwiY29tcGFyYXRvciIsIm9sZF9pbnB1dCIsIm9sZF9vdXRwdXQiLCJuZXdfaW5wdXQiLCJvdXRwdXQiLCJrIiwiayQwIiwibmV3X291dHB1dCIsImdlbmVyaWNfbWFwaSIsIndpdG5lc3MiLCJpbnB1dCIsInJlcyIsIm91dHB1dF9kYXRhIiwibWFwaSIsImZpbHRlcl9tYXBpIiwiZmlsdGVyX21hcCIsIndpdGhfb2xkMiIsImkxIiwiaTIiLCJhMSIsImEyIiwidW5vcmRlcmVkX2ZvbGRfd2l0aF9leHRyYSIsImV4dHJhIiwiZXh0cmFfY2hhbmdlZCIsImV4dHJhX2VxdWFsIiwic3RoJDIiLCJzdGgkMyIsIm5ld19leHRyYSIsIm9sZF9leHRyYSIsImFjYyQwIiwibWFwaV9jb3VudCIsIm5ld19rZXkiLCJuIiwicHJldl9rZXkiLCJtYXBfY291bnQiLCJtaW5faGVscGVyIiwibWluIiwibWF4X2hlbHBlciIsIm1heCIsImJvdW5kc19oZWxwZXIiLCJtYXBpX21pbiIsIm1hcGlfbWF4IiwibWFwaV9ib3VuZHMiLCJtYXBfbWluIiwibWFwX21heCIsIm1pbl92YWx1ZSIsIm1heF92YWx1ZSIsIm1hcF9ib3VuZHMiLCJ2YWx1ZV9ib3VuZHMiLCJtZXJnZV9zaGFyZWRfaW1wbCIsIm5ld19sZWZ0X21hcCIsIm5ld19yaWdodF9tYXAiLCJkYXRhX2VxdWFsX2xlZnQiLCJkYXRhX2VxdWFsX3JpZ2h0Iiwib2xkX3JpZ2h0X21hcCIsIm9sZF9sZWZ0X21hcCIsIm9sZF9sZWZ0X21hcCQwIiwiYXBwbHlfcmlnaHQiLCJkaWZmX2VsZW1lbnQiLCJyaWdodF9kaWZmcyIsImxlZnRfZGlmZl9lbGVtZW50IiwibGVmdF9rZXkiLCJjb21wYXJlIiwib3V0cHV0JDAiLCJyaWdodF9kaWZmcyQwIiwiYXBwbHlfbGVmdCIsInRsIiwiaGQiLCJyaWdodF9kaWZmX2VsZW1lbnQiLCJyaWdodF9rZXkiLCJyaWdodF9kaWZmcyQxIiwib3V0cHV0JDEiLCJuZXdfZGF0YV9mcm9tX2RpZmZfZWxlbWVudCIsIm1lcmdlIiwibGVmdF9tYXAiLCJyaWdodF9tYXAiLCJyaWdodF9kaWZmIiwibGVmdF9kaWZmIiwicmlnaHRfZGF0YV9vcHQiLCJsZWZ0X2RhdGFfb3B0IiwicmlnaHRfZGF0YV9vcHQkMCIsImxlZnRfZGF0YV9vcHQkMCIsImxlZnRfZGlmZiQwIiwicmlnaHRfZGlmZiQwIiwieSIsIm91dHB1dF9kYXRhX29wdCIsInkkMCIsIm1lcmdlX2JvdGhfc29tZSIsIm91dF9lcXVhbCIsImVtcHR5IiwibGVmdF9kYXRhIiwicmlnaHRfZGF0YSIsImxlZnRfYW5kX3JpZ2h0X2RhdGFfb3B0IiwicHJldl9vdXQiLCJwcmV2X291dCQwIiwibWVyZ2VfZGlzam9pbnQiLCJtZXJnZV9mcm9tX3NjcmF0Y2giLCJsIiwiciIsIm9sZF9yZXN1bHQiLCJlbHQiLCJ3aXRoX2xlZnRfY2hhbmdlcyIsImdlbmVyaWNfbWFwaV93aXRoX2NvbXBhcmF0b3IiLCJsaHMiLCJpbmNyZW1lbnRhbF9zdGF0ZSIsImVtcHR5X21hcCIsInByZXZfbWFwIiwicHJldl9ub2RlcyIsInJlc3VsdCIsIm9uX2lubmVyX2NoYW5nZSIsImxoc19jaGFuZ2UiLCJub2RlcyIsImNoYW5nZWQiLCJkZXAiLCJub2RlIiwibm9kZXMkMCIsIm5vZGUkMCIsIm5vZGUkMSIsImMiLCJ1c2VyX2Z1bmN0aW9uX2RlcCIsIm5ld19ub2RlcyIsImZpbHRlcl9tYXBpJDAiLCJtYXBpJDAiLCJtYXAkMCIsImZpbHRlcl9tYXAkMCIsIm1lcmdlJDAiLCJtYXAxIiwibWFwMiIsInVuemlwX21hcGkiLCJsZWZ0X3Jlc3VsdF9lcXVhbCIsInJpZ2h0X3Jlc3VsdF9lcXVhbCIsInBhaXIiLCJkYXRhX2VxdWFsJDAiLCJsZWZ0X3Jlc3VsdF9lcXVhbCQwIiwicmlnaHRfcmVzdWx0X2VxdWFsJDAiLCJsZWZ0X2FjYyIsImxlZnRfcmVzdWx0IiwicmlnaHRfYWNjIiwicmlnaHRfcmVzdWx0IiwibGVmdCQwIiwicmlnaHQkMCIsInJpZ2h0IiwibGVmdCIsInByZXYiLCJwcmV2X2IiLCJwcmV2X2EiLCJuZXdfYiIsIm5ld19hIiwiZWxlbWVudCIsImlucHV0X2NoYW5nZSIsInVuemlwIiwidW56aXBfbWFwaSQwIiwicmlnaHRfZGVwIiwibGVmdF9kZXAiLCJyaWdodF9pbmNyIiwibGVmdF9pbmNyIiwibGVmdF91c2VyX2Z1bmN0aW9uX2RlcCIsInJpZ2h0X3VzZXJfZnVuY3Rpb25fZGVwIiwia2V5cyIsInBhcnRpdGlvbl9tYXBpIiwic2Vjb25kIiwiZmlyc3QiLCJkYXRhJDAiLCJkYXRhJDEiLCJwYXJ0aXRpb25fbWFwaSQwIiwiZmxhdHRlbiIsInN0YXRlIiwiaW5jciIsImpvaW4iLCJtYXBfaW5jciIsInJlc3VsdF9tYXAiLCJvbGRfbWFwX29mX2luY3JzIiwiY3VycmVudF9kZXBlbmRlbmNpZXMiLCJhZGRfc3Vibm9kZSIsImRhdGFfbm9kZSIsIm5ld19kZXAiLCJyZW1vdmVfc3Vibm9kZSIsIm1hcF9vZl9pbmNycyIsImRhdGFfbm9kZSQwIiwibmV3X2RlcGVuZGVuY3lfbWFwIiwic2VwYXJhdGUiLCJpbnB1dF9tYXAiLCJvdXRwdXRfbWFwX25vZGUiLCJtYWtlX25vZGVfZGVwZW5kX29uX2lucHV0X21hcF8iLCJpbnB1dF9tYXBfY2hhbmdlZCIsImRlcGVuZGVuY3kiLCJwcmV2X2lucHV0X21hcCIsIm91dHB1dF9tYXAiLCJleHBlcnRfbm9kZXMiLCJvbGRfbm9kZSIsInN1YnJhbmdlIiwicmFuZ2UiLCJlcXVhbCIsIm1heWJlX2JvdW5kX2VxdWFsIiwiYV8wMDgiLCJiXzAwOSIsImFfMDEwIiwiYl8wMTEiLCJhXzAxMiIsImJfMDEzIiwicmFuZ2VfaXNfZW1wdHkiLCJtaW4kMCIsIm1heCQwIiwibWF4JDEiLCJtaW4kMSIsInJhbmdlX2luY2x1ZGVzIiwicmFuZ2UkMCIsImZyb21fc2NyYXRjaCIsIm9sZF9yYW5nZSIsIm9sZF9taW4iLCJvbGRfbWFwIiwib2xkX21heCIsIm9sZF9yZXMiLCJvbGRfbWF4JDAiLCJwYXJhbSIsImFwcGx5X2RpZmZfaW5faW50ZXJzZWN0aW9uIiwib3V0c2lkZSIsIm91dHNpZGUkMCIsIm91dHNpZGVfY3V0b2ZmIiwid2l0aF91cGRhdGVkX3ZhbHVlc19pbl9pbnRlcnNlIiwid2l0aG91dF9rZXlzX291dF9vZl9yYW5nZSIsIm1hcF9hcHBlbmRfZXhuIiwibG93ZXJfcGFydCIsInVwcGVyX3BhcnQiLCJvbGRfbWluJDAiLCJvbGRfbWluJDEiLCJvbGRfbWF4JDEiLCJ3aXRoX25ld19rZXlzX25vd19pbl9yYW5nZSIsInJla2V5Iiwib3V0ZXJfY29tcGFyYXRvciIsImFkZHMiLCJuZXdfZW50cnkiLCJpbmRleF9ieWkiLCJpbmRleCIsImlubmVyX2NvbXBhcmF0b3IiLCJvdXRlcl9tYXAiLCJpbm5lcl9tYXAkMCIsImluZGV4X2J5IiwiaXNfa25vd24iLCJ0b19vcHRpb24iLCJmaW5kX2tleV9yYW5nZV9saW5lYXIiLCJmcm9tIiwidG8iLCJsZW4iLCJiZWdpbl9rZXkiLCJlbmRfa2V5IiwiZmluZF9rZXlzIiwiZm9sZCIsInN0YXJ0X3BvcyIsImFkdmFuY2VfcG9zIiwicG9zIiwiYmVnaW5fa2V5JDAiLCJlbmRfa2V5JDAiLCJyYW5rIiwiY29tcGFyZV9rZXkiLCJzYW1lX2tleSIsInByb2Nlc3MiLCJuZXdfbWFwIiwib2xkX3JhbmsiLCJvbGRfa2V5Iiwib2xkX3JhbmskMCIsInVwcGVyX2JvdW5kIiwibG93ZXJfYm91bmQiLCJ1cHBlcl9ib3VuZCQwIiwibG93ZXJfYm91bmQkMCIsInN1YnJhbmdlJDAiLCJkaWZmX2tleSIsIm9sZF9yYW5rJDEiLCJvbGQkMSIsInN1YnJhbmdlX2J5X3JhbmsiLCJmaW5kX2tleV9yYW5nZSIsImVuZF9rZXlfb3B0JDAiLCJvbGRfdG8iLCJvbGRfZnJvbSIsImZpbmRfb2Zmc2V0IiwiY2hhbmdlZF9rZXkiLCJyYW5nZV9vZmZzZXRfYmVnaW4iLCJyYW5nZV9vZmZzZXRfZW5kIiwiYWRqdXN0X2FuZF9vZmZzZXQiLCJieSQxIiwia2V5JDEiLCJieSQyIiwiYnkiLCJjbG9zZXN0X2RpciIsImtleSQwIiwiYnkkMCIsIm9mZnNldF9lbmQiLCJvZmZzZXRfYmVnaW4iLCJtYXBfb2Zmc2V0X2VuZCIsIm1hcF9vZmZzZXRfYmVnaW4iLCJlbmRfa2V5X29wdCQyIiwiYmVnaW5fa2V5X29wdCIsIm1hcF9vZmZzZXRfYmVnaW4kMCIsImVuZF9rZXlfb3B0IiwiYmVnaW5fa2V5X29wdCQwIiwic3ltYm9sIiwiYm91bmQiLCJyZXR1cm4kMCIsInBhdHRlcm5fc3ludGF4XzAxNCIsInBhdHRlcm5fc3ludGF4XzAxNSIsImxiIiwicGF0dGVybl9zeW50YXhfMDE2IiwidSIsInBhdHRlcm5fc3ludGF4XzAxNyIsInViIiwibGV0X3N5bnRheF8wMjIiLCJrZXlfcmFuZ2UiLCJwYXR0ZXJuX3N5bnRheF8wMTgiLCJsJDAiLCJwYXR0ZXJuX3N5bnRheF8wMTkiLCJsYiQwIiwibGV0X3N5bnRheF8wMjYiLCJwYXR0ZXJuX3N5bnRheF8wMjAiLCJ1JDAiLCJwYXR0ZXJuX3N5bnRheF8wMjEiLCJ1YiQwIiwibGV0X3N5bnRheF8wMjkiLCJ0cmFuc3Bvc2UiLCJrMl9jb21wYXJhdG9yIiwibSIsImsxX2NvbXBhcmF0b3IiLCJrMSIsImsyIiwidmFsdWUiLCJhY2NfaW5uZXIiLCJhY2NfaW5uZXIkMCIsImNvbGxhcHNlX2J5IiwibWVyZ2Vfa2V5cyIsImNvbGxhcHNlIiwiaW5uZXJfY29tcGFyYXRvciQwIiwiZXhwYW5kIiwiY291bnRpIiwiY291bnQiLCJleGlzdHNpIiwiZXhpc3RzIiwic3VtIiwiR3JvdXAiLCJ2Iiwib2JzZXJ2ZV9jaGFuZ2VzX2V4biIsInNjb3BlIiwiZW1wdHlfdmVyc2lvbl9vZiIsIm9ic2VydmVyIiwiZGlmZl9lbHQiLCJmaW5hbF92YWx1ZSIsImJlZm9yZV9hbmRfYWZ0ZXIiLCJ2MiIsInYxIiwiYWZ0ZXIiLCJiZWZvcmUiLCJmb3JfYWxsaSIsImZvcl9hbGwiLCJ1bm9yZGVyZWRfZm9sZCQwIiwidW5vcmRlcmVkX2ZvbGRfbmVzdGVkX21hcHMkMCIsImNyZWF0ZSIsInNlbGYiLCJzZWxmJDAiLCJjaGFuZ2VkX3ZhbHVlIiwiZW50cmllcyIsImVudHJ5IiwidXBkYXRlcl9ub2RlIiwiZmluZCIsInQiLCJpc19ub3dfb2JzZXJ2YWJsZSIsImVudHJ5JDAiLCJjdXJyZW50X2VudHJpZXMiLCJpc19saW5rZWQiLCJvdGhlcl9lbnRyaWVzIiwib3RoZXJfZW50cnkiLCJuZXdfZW50cmllcyIsInNleHBfb2ZfdCIsInNleHBfb2Zfa2V5Iiwic2V4cF9vZl92YWx1ZSIsImFjdHVhbF92YWx1ZSIsImVudHJpZXMkMCIsImFjdHVhbF92YWx1ZSQwIiwieCQwIiwic2F2ZWRfdmFsdWUiLCJtYXRjaCQyIiwibWF0Y2gkMyIsInYkMCIsIm1hdGNoJDQiLCJ2JDEiLCJtYXRjaCQ1IiwidiQyIiwibWF0Y2gkMCIsImluZm9fcGVyX2tleSIsImZsYXR0ZW4kMCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyX21hcC9pbmNyX21hcF9fLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2luY3JfbWFwL2luY3JfbWFwX2ludGYubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvaW5jcl9tYXAvaW5jcl9tYXAubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0FLb0I7O0lBQUE7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7R0NISzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDQ3JCQSxtQkFBZ0RDLEdBQUssT0FBQSxXQUFMQSxNQUFTO1lBa0J2REMsU0FBVUMsaUJBQWdCQyxHQUFHSDtJQUVyQixJQUFOSTtrQkFDSUM7S0FDUixPQUFrQztjQUp0Qkg7O2VBS0YsSUFBSkksSUFBSSxXQUxxQk4sR0FFM0JJLFFBQ0lDO2VBREpELGlCQUNJQyxHQUVGQztlQUVKLE9BRklBO2NBRUg7SUFBQzs2Q0FQd0JIO0dBT3hCO1lBR0ZJLE9BQVNDLEtBQXNDQyxLQUFLRjtJQUN0RCxHQURXQztTQUFrQkUsTUFBbEJGLFFBQUFOLGtCQUFrQlE7O1NBQWxCUixrQkE1QlhIO0lBNkJBLFNBQUlZLFdBQVdDLFdBQVVDO0tBQ3ZCLE9BQUEsZ0NBRm9ETixRQUN2Q0ssV0FBVUM7SUFDc0M7SUFFOUIsT0FkL0JaO2FB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QTZFQVc7Z0JBdkJBRjtnQkFxREFJO2dCQTZCQUM7Z0JBV0FDO2dCQXdEQWlCO2dCQU9BQztnQkEzREFqQjtnQkFLQUM7Z0JBSUFDO2dCQWtCQUc7b0JBNkdFZSxRQW9GQU8sYUF5QlNTOzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgSW5jcl9tYXAuSW5jcl9tYXBfaW50ZiAqKVxubW9kdWxlIEluY3JfbWFwX2ludGYgPSBJbmNyX21hcF9fSW5jcl9tYXBfaW50ZlxuXG5tb2R1bGUgSW5jcl9tYXBfXyA9IHN0cnVjdCBlbmRcbltAQGRlcHJlY2F0ZWQgXCJ0aGlzIG1vZHVsZSBpcyBzaGFkb3dlZFwiXVxuIiwib3BlbiEgQ29yZVxuXG5tb2R1bGUgSW5zdHJ1bWVudGF0aW9uID0gc3RydWN0XG4gICgqKiBBbGwgW0luY3JfbWFwXSBmdW5jdGlvbnMgdGFrZSBhbiBvcHRpb25hbCBbaW5zdHJ1bWVudGF0aW9uXSBwYXJhbWV0ZXIgdGhhdCBoYXMgdHlwZVxuICAgICAgW0luc3RydW1lbnRhdGlvbi50XS4gIEEgdmFsdWUgb2YgdGhpcyB0eXBlIGlzIGEgcmVjb3JkIGNvbnRhaW5pbmcgYSBmdW5jdGlvbiB3aGljaFxuICAgICAgaXMgcG9seW1vcnBoaWMgb3ZlciBhIHVuaXZlcnNhbGx5LXF1YW50aWZpZWQgdHlwZSBbJ2FdLiBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZFxuICAgICAgYSBbdW5pdCAtPiAnYV0gZnVuY3Rpb24sIHdoaWNoIG11c3QgYmUgaW1tZWRpYXRlbHkgZXhlY3V0ZWQsIGFuZCB0aGUgcmVzdWx0IG9mXG4gICAgICB3aGljaCBtdXN0IGJlIHJldHVybmVkLlxuXG4gICAgICBUaGUgZnVuY3Rpb24gcGFzc2VkIHRvIHRoZSBpbnN0cnVtZW50b3Igd2lsbCBiZSBkb2luZyB0aGUgYnVsayBvZiB0aGUgd29yayBmb3IgdGhlXG4gICAgICBbSW5jcl9tYXBdIGZ1bmN0aW9uIGluIHF1ZXN0aW9uICh1c3VhbGx5IGEgW01hcC5mb2xkX3N5bW1ldHJpY19kaWZmXSkuXG5cbiAgICAgIFlvdSBtYXkgd2FudCB0byB1c2UgdGhlIEluc3RydW1lbnRhdGlvbiBBUEkgdG8gYXNzaXN0IGluIHBlcmZvcm1hbmNlIHByb2ZpbGluZyBsaWtlXG4gICAgICBzbzpcblxuICAgICAge1tcbiAgICAgICAgbGV0IHByb2ZpbGUgbmFtZSA9XG4gICAgICAgICAgeyBJbmNyX21hcC5JbnN0cnVtZW50YXRpb24uZiA9IGZ1biBmIC0+XG4gICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBUaW1lLm5vdyAoKSBpblxuICAgICAgICAgICAgICBsZXQgciA9IGYgKCkgaW5cbiAgICAgICAgICAgICAgbGV0IGFmdGVyID0gVGltZS5ub3cgKCkgaW5cbiAgICAgICAgICAgICAgbGV0IGRlbHRhID0gVGltZS5zdWIgYWZ0ZXIgYmVmb3JlIGluXG4gICAgICAgICAgICAgIHByaW50ZiBcIiVzIHRvb2sgJXNcIiBuYW1lIChUaW1lLlNwYW4udG9fc3RyaW5nX2h1bSBkZWx0YSk7XG4gICAgICAgICAgICAgIHJcbiAgICAgICAgICB9XG4gICAgICAgIDs7XG5cbiAgICAgICAgSW5jcl9tYXAubWFwIH5pbnN0cnVtZW50YXRpb246KHByb2ZpbGUgXCJmb29cIikgfmY6bWFwX2Zvb1xuICAgICAgXX0gKilcblxuICB0eXBlIHQgPSB7IGYgOiAnYS4gKHVuaXQgLT4gJ2EpIC0+ICdhIH0gW0BAdW5ib3hlZF1cbmVuZFxuXG4oKiogW1NfZ2VuXSBpcyB0aGUgdHlwZSBvZiB0aGUgbW9kdWxlIHJldHVybmVkIGJ5IFtJbmNyX21hcC5NYWtlXS4gIEl0IGlzIGEgc3BlY2lhbGl6YXRpb25cbiAgICBvZiB0aGUgaW50ZXJmYWNlIG9mIFtJbmNyX21hcF0sIHdpdGg6XG5cbiAgICAtIHRoZSBbJ3ddIHN0YXRlX3dpdG5lc3MgdHlwZSBwYXJhbWV0ZXIgcmVtb3ZlZFxuICAgIC0gdGhlIFtJbmNyZW1lbnRhbC5TdGF0ZS50XSBhcmd1bWVudCByZW1vdmVkXG5cbiAgICBUaGUgY29tbWVudHMgZm9yIGNvbXBvbmVudHMgb2YgW1NfZ2VuXSBhcmUgaW4gW21vZHVsZSB0eXBlIEluY3JfbWFwXSBiZWxvdy4gKilcbm1vZHVsZSB0eXBlIFNfZ2VuID0gc2lnXG4gIG1vZHVsZSBJbmNyIDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICBtb2R1bGUgQ3V0b2ZmIDogc2lnXG4gICAgICB0eXBlICdhIHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIEluc3RydW1lbnRhdGlvbiA9IEluc3RydW1lbnRhdGlvblxuXG4gIHZhbCBvZl9zZXRcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gKCdrLCAnY21wKSBTZXQudCBJbmNyLnRcbiAgICAtPiAoJ2ssIHVuaXQsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YxLCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondjEgLT4gJ3YyIG9wdGlvbilcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIG1hcGlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2MSwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MilcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIGZpbHRlcl9tYXBcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2MSwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gZjooJ3YxIC0+ICd2MiBvcHRpb24pXG4gICAgLT4gKCdrLCAndjIsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBtYXBcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2MSwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gZjooJ3YxIC0+ICd2MilcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIGZpbHRlcl9tYXBpJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOid2MSBJbmNyLkN1dG9mZi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2MSwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIEluY3IudCAtPiAndjIgb3B0aW9uIEluY3IudClcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIG1hcGknXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9jdXRvZmY6J3YxIEluY3IuQ3V0b2ZmLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YxLCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondjEgSW5jci50IC0+ICd2MiBJbmNyLnQpXG4gICAgLT4gKCdrLCAndjIsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBmaWx0ZXJfbWFwJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOid2MSBJbmNyLkN1dG9mZi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2MSwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gZjooJ3YxIEluY3IudCAtPiAndjIgb3B0aW9uIEluY3IudClcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIG1hcCdcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2N1dG9mZjondjEgSW5jci5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+IGY6KCd2MSBJbmNyLnQgLT4gJ3YyIEluY3IudClcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgoJ2ssICd2MiwgJ2NtcCkgTWFwLnQgKiAoJ2ssICd2MywgJ2NtcCkgTWFwLnQpIEluY3IudFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwaSdcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2N1dG9mZjondjEgSW5jci5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSBJbmNyLnQgLT4gKCd2MiwgJ3YzKSBFaXRoZXIudCBJbmNyLnQpXG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCAqICgnaywgJ3YzLCAnY21wKSBNYXAudCkgSW5jci50XG5cbiAgdmFsIHVub3JkZXJlZF9mb2xkXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ID91cGRhdGU6KGtleTonayAtPiBvbGRfZGF0YTondiAtPiBuZXdfZGF0YTondiAtPiAnYWNjIC0+ICdhY2MpXG4gICAgLT4gP3NwZWNpYWxpemVkX2luaXRpYWw6KGluaXQ6J2FjYyAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCAtPiAnYWNjKVxuICAgIC0+ID9maW5hbGl6ZTooJ2FjYyAtPiAnYWNjKVxuICAgIC0+ID9yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OmJvb2xcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBhZGQ6KGtleTonayAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylcbiAgICAtPiByZW1vdmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylcbiAgICAtPiAnYWNjIEluY3IudFxuXG4gIHZhbCB1bm9yZGVyZWRfZm9sZF93aXRoX2V4dHJhXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ID9leHRyYV9lcXVhbDooJ2V4dHJhIC0+ICdleHRyYSAtPiBib29sKVxuICAgIC0+ID91cGRhdGU6KGtleTonayAtPiBvbGRfZGF0YTondiAtPiBuZXdfZGF0YTondiAtPiAnYWNjIC0+ICdleHRyYSAtPiAnYWNjKVxuICAgIC0+ID9zcGVjaWFsaXplZF9pbml0aWFsOihpbml0OidhY2MgLT4gKCdrLCAndiwgJ2UpIE1hcC50IC0+ICdleHRyYSAtPiAnYWNjKVxuICAgIC0+ID9maW5hbGl6ZTooJ2FjYyAtPiAnYWNjKVxuICAgIC0+ID9yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OmJvb2xcbiAgICAtPiAoJ2ssICd2LCAnZSkgTWFwLnQgSW5jci50XG4gICAgLT4gJ2V4dHJhIEluY3IudFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGFkZDooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnZXh0cmEgLT4gJ2FjYylcbiAgICAtPiByZW1vdmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2V4dHJhIC0+ICdhY2MpXG4gICAgLT4gZXh0cmFfY2hhbmdlZDpcbiAgICAgICAgIChvbGRfZXh0cmE6J2V4dHJhXG4gICAgICAgICAgLT4gbmV3X2V4dHJhOidleHRyYVxuICAgICAgICAgIC0+IGlucHV0OignaywgJ3YsICdlKSBNYXAudFxuICAgICAgICAgIC0+ICdhY2NcbiAgICAgICAgICAtPiAnYWNjKVxuICAgIC0+ICdhY2MgSW5jci50XG5cbiAgdmFsIGN1dG9mZlxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBjdXRvZmY6J3YgSW5jcmVtZW50YWwuQ3V0b2ZmLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgbWFwaV9jb3VudFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIE1hcC50IEluY3IudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBmOihrZXk6J2sxIC0+IGRhdGE6J3YgLT4gJ2syKVxuICAgIC0+ICgnazIsIGludCwgJ2NtcDIpIE1hcC50IEluY3IudFxuXG4gIHZhbCBtYXBfY291bnRcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrMSwgJ3YsICdjbXAxKSBNYXAudCBJbmNyLnRcbiAgICAtPiBjb21wYXJhdG9yOignazIsICdjbXAyKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooJ3YgLT4gJ2syKVxuICAgIC0+ICgnazIsIGludCwgJ2NtcDIpIE1hcC50IEluY3IudFxuXG4gIHZhbCBtYXBpX21pblxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCBfKSBNYXAudCBJbmNyLnRcbiAgICAtPiBjb21wYXJhdG9yOignciwgXykgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdyKVxuICAgIC0+ICdyIG9wdGlvbiBJbmNyLnRcblxuICB2YWwgbWFwaV9tYXhcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ3IsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAncilcbiAgICAtPiAnciBvcHRpb24gSW5jci50XG5cbiAgdmFsIG1hcF9taW5cbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ3IsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBmOigndiAtPiAncilcbiAgICAtPiAnciBvcHRpb24gSW5jci50XG5cbiAgdmFsIG1hcF9tYXhcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ3IsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBmOigndiAtPiAncilcbiAgICAtPiAnciBvcHRpb24gSW5jci50XG5cbiAgdmFsIG1pbl92YWx1ZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCBfKSBNYXAudCBJbmNyLnRcbiAgICAtPiBjb21wYXJhdG9yOigndiwgXykgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICd2IG9wdGlvbiBJbmNyLnRcblxuICB2YWwgbWF4X3ZhbHVlXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsIF8pIE1hcC50IEluY3IudFxuICAgIC0+IGNvbXBhcmF0b3I6KCd2LCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gJ3Ygb3B0aW9uIEluY3IudFxuXG4gIHZhbCBtYXBpX2JvdW5kc1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCBfKSBNYXAudCBJbmNyLnRcbiAgICAtPiBjb21wYXJhdG9yOignciwgXykgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdyKVxuICAgIC0+ICgnciAqICdyKSBvcHRpb24gSW5jci50XG5cbiAgdmFsIG1hcF9ib3VuZHNcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ3IsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBmOigndiAtPiAncilcbiAgICAtPiAoJ3IgKiAncikgb3B0aW9uIEluY3IudFxuXG4gIHZhbCB2YWx1ZV9ib3VuZHNcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ3YsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ3YgKiAndikgb3B0aW9uIEluY3IudFxuXG4gIHZhbCBtZXJnZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbF9sZWZ0OigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gP2RhdGFfZXF1YWxfcmlnaHQ6KCd2MiAtPiAndjIgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2MSwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gKCdrLCAndjIsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+IGY6KGtleTonayAtPiAoJ3YxLCAndjIpIE1hcC5NZXJnZV9lbGVtZW50LnQgLT4gJ3YzIG9wdGlvbilcbiAgICAtPiAoJ2ssICd2MywgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIG1lcmdlX2JvdGhfc29tZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbF9sZWZ0OigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gP2RhdGFfZXF1YWxfcmlnaHQ6KCd2MiAtPiAndjIgLT4gYm9vbClcbiAgICAtPiA/b3V0X2VxdWFsOigndjMgLT4gJ3YzIC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gJ3YxIC0+ICd2MiAtPiAndjMpXG4gICAgLT4gKCdrLCAndjMsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBtZXJnZV9kaXNqb2ludFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgdW56aXBcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2xlZnRfcmVzdWx0X2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gP3JpZ2h0X3Jlc3VsdF9lcXVhbDooJ3YyIC0+ICd2MiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YxICogJ3YyLCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiAoJ2ssICd2MSwgJ2NtcCkgTWFwLnQgSW5jci50ICogKCdrLCAndjIsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCB1bnppcF9tYXBpXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ID9sZWZ0X3Jlc3VsdF9lcXVhbDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ID9yaWdodF9yZXN1bHRfZXF1YWw6KCd2MiAtPiAndjIgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAndjEgKiAndjIpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudCAqICgnaywgJ3YyLCAnY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgdW56aXBfbWFwaSdcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2N1dG9mZjondiBJbmNyLkN1dG9mZi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgSW5jci50IC0+ICd2MSBJbmNyLnQgKiAndjIgSW5jci50KVxuICAgIC0+ICgnaywgJ3YxLCAnY21wKSBNYXAudCBJbmNyLnQgKiAoJ2ssICd2MiwgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIG1lcmdlJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOigndjEsICd2MikgTWFwLk1lcmdlX2VsZW1lbnQudCBJbmNyLkN1dG9mZi50XG4gICAgLT4gP2RhdGFfZXF1YWxfbGVmdDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ID9kYXRhX2VxdWFsX3JpZ2h0OigndjIgLT4gJ3YyIC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndjEsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gKCd2MSwgJ3YyKSBNYXAuTWVyZ2VfZWxlbWVudC50IEluY3IudCAtPiAndjMgb3B0aW9uIEluY3IudClcbiAgICAtPiAoJ2ssICd2MywgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIGZsYXR0ZW4gOiAoJ2ssICd2IEluY3IudCwgJ2NtcCkgTWFwLnQgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIGpvaW5cbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gKCdrLCAndiBJbmNyLnQsICdjbXApIE1hcC50IEluY3IudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBzZXBhcmF0ZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBkYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YgSW5jci50LCAnY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwga2V5c1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiAoJ2ssICd2LCAnYykgTWFwLnQgSW5jci50XG4gICAgLT4gKCdrLCAnYykgU2V0LnQgSW5jci50XG5cbiAgdmFsIHJhbmtcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgQmFzZS5NYXAudCBJbmNyLnRcbiAgICAtPiAnayBJbmNyLnRcbiAgICAtPiBpbnQgb3B0aW9uIEluY3IudFxuXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiAoJ2sgTWF5YmVfYm91bmQuQXNfbG93ZXJfYm91bmQudCAqICdrIE1heWJlX2JvdW5kLkFzX3VwcGVyX2JvdW5kLnQpIG9wdGlvbiBJbmNyLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgc3VicmFuZ2VfYnlfcmFua1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiAoaW50IE1heWJlX2JvdW5kLkFzX2xvd2VyX2JvdW5kLnQgKiBpbnQgTWF5YmVfYm91bmQuQXNfdXBwZXJfYm91bmQudCkgSW5jci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIHJla2V5XG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnazEsICd2LCAnY21wMSkgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ2syLCAnY21wMikgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGY6KGtleTonazEgLT4gZGF0YTondiAtPiAnazIpXG4gICAgLT4gKCdrMiwgJ3YsICdjbXAyKSBNYXAudCBJbmNyLnRcblxuICB2YWwgaW5kZXhfYnlpXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaW5uZXJfa2V5LCAndiwgJ2lubmVyX2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ291dGVyX2tleSwgJ291dGVyX2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGluZGV4OihrZXk6J2lubmVyX2tleSAtPiBkYXRhOid2IC0+ICdvdXRlcl9rZXkgb3B0aW9uKVxuICAgIC0+ICgnb3V0ZXJfa2V5LCAoJ2lubmVyX2tleSwgJ3YsICdpbm5lcl9jbXApIE1hcC50LCAnb3V0ZXJfY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgaW5kZXhfYnlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBjb21wYXJhdG9yOignb3V0ZXJfa2V5LCAnb3V0ZXJfY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gaW5kZXg6KCd2IC0+ICdvdXRlcl9rZXkgb3B0aW9uKVxuICAgIC0+ICgnb3V0ZXJfa2V5LCAoJ2lubmVyX2tleSwgJ3YsICdpbm5lcl9jbXApIE1hcC50LCAnb3V0ZXJfY21wKSBNYXAudCBJbmNyLnRcblxuICB2YWwgdW5vcmRlcmVkX2ZvbGRfbmVzdGVkX21hcHNcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gP3JldmVydF90b19pbml0X3doZW5fZW1wdHk6Ym9vbFxuICAgIC0+ID91cGRhdGU6XG4gICAgICAgICAob3V0ZXJfa2V5OidvdXRlcl9rZXlcbiAgICAgICAgICAtPiBpbm5lcl9rZXk6J2lubmVyX2tleVxuICAgICAgICAgIC0+IG9sZF9kYXRhOid2XG4gICAgICAgICAgLT4gbmV3X2RhdGE6J3ZcbiAgICAgICAgICAtPiAnYWNjXG4gICAgICAgICAgLT4gJ2FjYylcbiAgICAtPiAoJ291dGVyX2tleSwgKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCwgJ291dGVyX2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gYWRkOihvdXRlcl9rZXk6J291dGVyX2tleSAtPiBpbm5lcl9rZXk6J2lubmVyX2tleSAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylcbiAgICAtPiByZW1vdmU6KG91dGVyX2tleTonb3V0ZXJfa2V5IC0+IGlubmVyX2tleTonaW5uZXJfa2V5IC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+ICdhY2MgSW5jci50XG5cbiAgdmFsIHRyYW5zcG9zZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2syLCAnazJfY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrMSwgKCdrMiwgJ3YsICdrMl9jbXApIE1hcC50LCAnazFfY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiAoJ2syLCAoJ2sxLCAndiwgJ2sxX2NtcCkgTWFwLnQsICdrMl9jbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBjb2xsYXBzZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ291dGVyX2tleSwgKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCwgJ291dGVyX2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gY29tcGFyYXRvcjooJ2lubmVyX2tleSwgJ2lubmVyX2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICggJ291dGVyX2tleSAqICdpbm5lcl9rZXlcbiAgICAgICAsICd2XG4gICAgICAgLCAoJ291dGVyX2NtcCwgJ2lubmVyX2NtcCkgVHVwbGUyLmNvbXBhcmF0b3Jfd2l0bmVzcyApXG4gICAgICAgTWFwLnRcbiAgICAgICBJbmNyLnRcblxuICB2YWwgY29sbGFwc2VfYnlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdvdXRlcl9rZXksICgnaW5uZXJfa2V5LCAndiwgJ2lubmVyX2NtcCkgTWFwLnQsICdvdXRlcl9jbXApIE1hcC50IEluY3IudFxuICAgIC0+IG1lcmdlX2tleXM6KCdvdXRlcl9rZXkgLT4gJ2lubmVyX2tleSAtPiAnY29tYmluZWRfa2V5KVxuICAgIC0+IGNvbXBhcmF0b3I6KCdjb21iaW5lZF9rZXksICdjb21iaW5lZF9jbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2NvbWJpbmVkX2tleSwgJ3YsICdjb21iaW5lZF9jbXApIE1hcC50IEluY3IudFxuXG4gIHZhbCBleHBhbmRcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdvdXRlcl9rZXkgKiAnaW5uZXJfa2V5LCAndiwgJ3R1cGxlX2NtcCkgTWFwLnQgSW5jci50XG4gICAgLT4gb3V0ZXJfY29tcGFyYXRvcjooJ291dGVyX2tleSwgJ291dGVyX2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGlubmVyX2NvbXBhcmF0b3I6KCdpbm5lcl9rZXksICdpbm5lcl9jbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ291dGVyX2tleSwgKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCwgJ291dGVyX2NtcCkgTWFwLnQgSW5jci50XG5cbiAgdmFsIGNvdW50aVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCBfKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKVxuICAgIC0+IGludCBJbmNyLnRcblxuICB2YWwgY291bnRcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKF8sICd2LCBfKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOigndiAtPiBib29sKVxuICAgIC0+IGludCBJbmNyLnRcblxuICB2YWwgZm9yX2FsbGlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbClcbiAgICAtPiBib29sIEluY3IudFxuXG4gIHZhbCBmb3JfYWxsXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+IChfLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gZjooJ3YgLT4gYm9vbClcbiAgICAtPiBib29sIEluY3IudFxuXG4gIHZhbCBleGlzdHNpXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsIF8pIE1hcC50IEluY3IudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpXG4gICAgLT4gYm9vbCBJbmNyLnRcblxuICB2YWwgZXhpc3RzXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+IChfLCAndiwgXykgTWFwLnQgSW5jci50XG4gICAgLT4gZjooJ3YgLT4gYm9vbClcbiAgICAtPiBib29sIEluY3IudFxuXG4gIHZhbCBzdW1cbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKF8sICd2LCBfKSBNYXAudCBJbmNyLnRcbiAgICAtPiAobW9kdWxlIEFic3RyYWN0X2FsZ2VicmEuQ29tbXV0YXRpdmVfZ3JvdXAuV2l0aG91dF9zZXhwIHdpdGggdHlwZSB0ID0gJ3UpXG4gICAgLT4gZjooJ3YgLT4gJ3UpXG4gICAgLT4gJ3UgSW5jci50XG5cbiAgdmFsIG9ic2VydmVfY2hhbmdlc19leG5cbiAgICA6ICA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBNYXAudCBJbmNyLnRcbiAgICAtPiBmOigoJ2ssICd2KSBNYXAuU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gIG1vZHVsZSBMb29rdXAgOiBzaWdcbiAgICB0eXBlICgnaywgJ3YsICdjbXApIHRcblxuICAgIHZhbCBjcmVhdGVcbiAgICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgSW5jci50XG4gICAgICAtPiBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgICB2YWwgZmluZCA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sgLT4gJ3Ygb3B0aW9uIEluY3IudFxuXG4gICAgbW9kdWxlIE0gKEsgOiBzaWdcbiAgICAgIHR5cGUgdFxuICAgICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpIDogc2lnXG4gICAgICB0eXBlIG5vbnJlYyAndiB0ID0gKEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgRm9yX2RlYnVnIDogc2lnXG4gICAgICB2YWwgc2V4cF9vZl90IDogKCdrIC0+IFNleHAudCkgLT4gKCd2IC0+IFNleHAudCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBTZXhwLnRcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIEZvcl90ZXN0aW5nIDogc2lnXG4gICAgdmFsIGZpbmRfa2V5X3JhbmdlX2xpbmVhclxuICAgICAgOiAgZnJvbTppbnRcbiAgICAgIC0+IHRvXzppbnRcbiAgICAgIC0+ICgnYSwgJ2IsICdjKSBCYXNlLk1hcC50XG4gICAgICAtPiAoJ2EgKiAnYSBvcHRpb24pIG9wdGlvblxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmNyX21hcCA9IHNpZ1xuICAoKiogRnVuY3Rpb25zIGZvciB1c2luZyBtYXBzIGVmZmljaWVudGx5IHdpdGhpbiBJbmNyZW1lbnRhbC4gIFRoZSBnb2FsIG9mIHRoZSBhbGdvcml0aG1zXG4gICAgICBoZXJlIGlzIHRvIGRvIHdvcmsgb24gdGhlIG91dHB1dCBvZiB0aGUgY29tcHV0YXRpb24gcHJvcG9ydGlvbmFsIHRvIHRoZSBhbW91bnQgb2ZcbiAgICAgIHdvcmsgZG9uZSBvbiB0aGUgaW5wdXQuICBpLmUuLCBba10gbW9kaWZpY2F0aW9ucyB0byB0aGUgaW5wdXQgbWFwIGZvciBzb21lXG4gICAgICBjb21wdXRhdGlvbiB3aWxsIHJlc3VsdCBpbiBba10gbW9kaWZpY2F0aW9ucyB0byB0aGUgb3V0cHV0IG1hcC4gIFRoZSBjaGFuZ2VzIHRvIHRoZVxuICAgICAgaW5wdXQgbWFwIGFyZSB0eXBpY2FsbHkgY29tcHV0ZWQgdXNpbmcgW01hcC5zeW1tZXRyaWNfZGlmZl0uXG5cbiAgICAgIFVubGVzcyBzdGF0ZWQgb3RoZXJ3aXNlLCB0aGUgbm9uLWluY3JlbWVudGFsIHNlbWFudGljcyBvZiB0aGVzZSBmdW5jdGlvbnMgKGkuZS4uLFxuICAgICAgaWdub3JpbmcgcGVyZm9ybWFuY2UpIGlzIHRoZSBzYW1lIGFzIHRoZSBjb3JyZXNwb25kaW5nIGZ1bmN0aW9uIGluIENvcmUncyBbTWFwXVxuICAgICAgbW9kdWxlLiAgKilcblxuICBtb2R1bGUgSW5zdHJ1bWVudGF0aW9uID0gSW5zdHJ1bWVudGF0aW9uXG5cbiAgdmFsIG9mX3NldFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiAoKCdrLCAnY21wKSBTZXQudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiAoKCdrLCB1bml0LCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgZmlsdGVyX21hcGlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndjEsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIgb3B0aW9uKVxuICAgIC0+ICgoJ2ssICd2MiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgdmFsIG1hcGlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndjEsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIpXG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2MSwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gZjooJ3YxIC0+ICd2MiBvcHRpb24pXG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgbWFwXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOigndjEgLT4gJ3YyKVxuICAgIC0+ICgoJ2ssICd2MiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgdmFsIGZpbHRlcl9tYXBpJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOid2MSBJbmNyZW1lbnRhbC5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTooJ3YxLCAndykgSW5jcmVtZW50YWwudCAtPiAoJ3YyIG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnQpXG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgbWFwJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOid2MSBJbmNyZW1lbnRhbC5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOigoJ3YxLCAndykgSW5jcmVtZW50YWwudCAtPiAoJ3YyLCAndykgSW5jcmVtZW50YWwudClcbiAgICAtPiAoKCdrLCAndjIsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gIHZhbCBmaWx0ZXJfbWFwJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOid2MSBJbmNyZW1lbnRhbC5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOigoJ3YxLCAndykgSW5jcmVtZW50YWwudCAtPiAoJ3YyIG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnQpXG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgbWFwaSdcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2N1dG9mZjondjEgSW5jcmVtZW50YWwuQ3V0b2ZmLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2MSwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6KCd2MSwgJ3cpIEluY3JlbWVudGFsLnQgLT4gKCd2MiwgJ3cpIEluY3JlbWVudGFsLnQpXG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndjEsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgoJ2ssICd2MiwgJ2NtcCkgTWFwLnQgKiAoJ2ssICd2MywgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOid2MSBJbmNyZW1lbnRhbC5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsOigndjEgLT4gJ3YxIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOlxuICAgICAgICAgKGtleTona1xuICAgICAgICAgIC0+IGRhdGE6KCd2MSwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAgICAgICAtPiAoKCd2MiwgJ3YzKSBFaXRoZXIudCwgJ3cpIEluY3JlbWVudGFsLnQpXG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCAqICgnaywgJ3YzLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogW3Vub3JkZXJlZF9mb2xkIGkgfmluaXQgfmFkZCB+cmVtb3ZlXSBjb25zdHJ1Y3RzIGEgbW9yZSBpbmNyZW1lbnRhbCB2ZXJzaW9uIG9mOlxuXG4gICAgICB7W1xuICAgICAgICBsZXQlbWFwIG0gPSBpIGluXG4gICAgICAgIE1hcC5mb2xkIG0gfmluaXQgfmY6YWRkXG4gICAgICBdfVxuXG4gICAgICBhc3N1bWluZyB0aGF0IFtyZW1vdmVdIGlzIHRoZSBpbnZlcnNlIG9mIFthZGRdLCBhbmQgdGhhdCB0aGUgb3BlcmF0aW9ucyBmb3JcbiAgICAgIGRpZmZlcmVudCBrZXlzIGNhbiBiZSBwZXJmb3JtZWQgaW4gYW55IG9yZGVyLiBOb3RlIHRoYXQgW2RhdGFfZXF1YWxdIGRlZmF1bHRzXG4gICAgICB0byBbcGh5c19lcXVhbF0sIGJ1dCBhIG1vcmUgcHJlY2lzZSBlcXVhbGl0eSBjYW4gYmUgcHJvdmlkZWQgaW5zdGVhZC5cblxuICAgICAgV2hlbiB0aGUgZGF0YSBmb3IgYSBrZXkgdXBkYXRlcywgYnkgZGVmYXVsdCBbcmVtb3ZlXSBpcyBjYWxsZWQgb24gdGhlIG9sZCBkYXRhXG4gICAgICBhbmQgdGhlbiBbYWRkXSBpcyBjYWxsZWQgb24gdGhlIG5ldyBkYXRhLlxuICAgICAgW3VwZGF0ZV0gcHJvdmlkZXMgYW4gYWx0ZXJuYXRpdmUgc2luZ2xlIGZ1bmN0aW9uIHRvIGNhbGwgZWFjaCB0aW1lIGEga2V5J3MgZGF0YVxuICAgICAgdXBkYXRlcywgYW5kIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgZWZmaWNpZW5jeS5cblxuICAgICAgRm9yIHRoZSBpbml0aWFsIGNvbXB1dGF0aW9uLCBieSBkZWZhdWx0IFthZGRdIGlzIGNhbGxlZCBvbiBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZVxuICAgICAgbWFwLiBBcyB0aGlzIGNhbiBiZSBpbmVmZmljaWVudCwgW3NwZWNpYWxpemVkX2luaXRpYWxdIGNhbiBiZSBwcm92aWRlZCB0byBwZXJmb3JtXG4gICAgICB0aGUgY29tcHV0YXRpb24gaW4gYSBtb3JlIGVmZmVjdGl2ZSB3YXkuXG5cbiAgICAgIElmIFtyZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5XSBpcyB0cnVlLCB0aGVuIGlmIHRoZSBpbnB1dCBtYXAgdHJhbnNpdGlvbnMgZnJvbVxuICAgICAgYmVpbmcgZnVsbCB0byBlbXB0eSwgdGhlbiBpbnN0ZWFkIG9mIGNhbGxpbmcgW3JlbW92ZV0gb24gZXZlcnkga3YtcGFpciwgaXQgd2lsbFxuICAgICAgaW5zdGVhZCBqdXN0IHNldCB0aGUgb3V0cHV0IHRvIHdoYXRldmVyIHlvdSd2ZSBwYXNzZWQgYXMgW2luaXRdLlxuICAgICAgVGhlIGRlZmF1bHQgdmFsdWUgb2YgW3JldmVydF90b19pbml0X3doZW5fZW1wdHldIGlzIFtmYWxzZV0sIHNvIHRoaXMgb3B0aW1pemF0aW9uXG4gICAgICBkb2VzIG5vdCBhcHBseSBhdXRvbWF0aWNhbGx5LlxuXG4gICAgICBbZmluYWxpemVdIGRlZmF1bHRzIHRvIFtGbi5pZF0gaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgYWNjdW11bGF0b3IgdmFsdWVcbiAgICAgIGlzIHN0b3JlZCBhbmQgcmV0dXJuZWQgZHVyaW5nIHN0YWJpbGl6YXRpb24uICBZb3UgY2FuIHVzZSBpdCB0byBlLmcuIHByb2Nlc3MgdGhlXG4gICAgICBmb2xkIG9wZXJhdGlvbnMgaW4gYSBkaWZmZXJlbnQgb3JkZXIuICopXG4gIHZhbCB1bm9yZGVyZWRfZm9sZFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiA/dXBkYXRlOihrZXk6J2sgLT4gb2xkX2RhdGE6J3YgLT4gbmV3X2RhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+ID9zcGVjaWFsaXplZF9pbml0aWFsOihpbml0OidhY2MgLT4gKCdrLCAndiwgJ2NtcCkgTWFwLnQgLT4gJ2FjYylcbiAgICAtPiA/ZmluYWxpemU6KCdhY2MgLT4gJ2FjYylcbiAgICAtPiA/cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTpib29sXG4gICAgLT4gKCgnaywgJ3YsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGFkZDooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+IHJlbW92ZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+ICgnYWNjLCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBbdW5vcmRlcmVkX2ZvbGRfd2l0aF9leHRyYV0gaXMgc2ltaWxhciB0byBbdW5vcmRlcmVkX2ZvbGRdLCBidXQgaXQgYWxzb1xuICAgICAgZGVwZW5kcyBvbiBhbm90aGVyIGFyYml0cmFyeSBpbmNyZW1lbnRhbCB2YWx1ZSB3aGljaCBjYW4gYmUgZmFjdG9yZWQgaW50b1xuICAgICAgdGhlIGZvbGRpbmcgY29tcHV0YXRpb24uICopXG4gIHZhbCB1bm9yZGVyZWRfZm9sZF93aXRoX2V4dHJhXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ID9leHRyYV9lcXVhbDooJ2V4dHJhIC0+ICdleHRyYSAtPiBib29sKVxuICAgIC0+ID91cGRhdGU6KGtleTonayAtPiBvbGRfZGF0YTondiAtPiBuZXdfZGF0YTondiAtPiAnYWNjIC0+ICdleHRyYSAtPiAnYWNjKVxuICAgIC0+ID9zcGVjaWFsaXplZF9pbml0aWFsOihpbml0OidhY2MgLT4gKCdrLCAndiwgJ2UpIE1hcC50IC0+ICdleHRyYSAtPiAnYWNjKVxuICAgIC0+ID9maW5hbGl6ZTooJ2FjYyAtPiAnYWNjKVxuICAgIC0+ID9yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OmJvb2xcbiAgICAtPiAoKCdrLCAndiwgJ2UpIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+ICgnZXh0cmEsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gYWRkOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICdleHRyYSAtPiAnYWNjKVxuICAgIC0+IHJlbW92ZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnZXh0cmEgLT4gJ2FjYylcbiAgICAtPiBleHRyYV9jaGFuZ2VkOlxuICAgICAgICAgKG9sZF9leHRyYTonZXh0cmFcbiAgICAgICAgICAtPiBuZXdfZXh0cmE6J2V4dHJhXG4gICAgICAgICAgLT4gaW5wdXQ6KCdrLCAndiwgJ2UpIE1hcC50XG4gICAgICAgICAgLT4gJ2FjY1xuICAgICAgICAgIC0+ICdhY2MpXG4gICAgLT4gKCdhY2MsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgKCoqIFtjdXRvZmZdIGFwcGxpZXMgYSBjdXRvZmYgdG8gdmFsdWVzIGluIHRoZSBtYXAgYXMgdGhleSBwYXNzIHRocm91Z2ggdGhlXG4gICAgICBmdW5jdGlvbi4gIEl0IGhhcyB0aGUgc2FtZSBiZWhhdmlvciBhcyBjYWxsaW5nIFtJbmNyX21hcC5tYXAnXSB3aXRoIGFuXG4gICAgICBbSW5jci5zZXRfY3V0b2ZmXSBpbnNpZGUsIGJ1dCB3aXRoIGNvbnNpZGVyYWJseSBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kXG4gICAgICBtZW1vcnkgdXNhZ2UuICopXG4gIHZhbCBjdXRvZmZcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gKCgnaywgJ3YsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGN1dG9mZjondiBJbmNyZW1lbnRhbC5DdXRvZmYudFxuICAgIC0+ICgoJ2ssICd2LCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogR2l2ZW4gYW4gaW5wdXQgbWFwIGFuZCBhIGZ1bmN0aW9uIG1hcHBpbmcgYSBrdi1wYWlyIHRvIGEgbmV3XG4gICAgICB2YWx1ZSwgW21hcGlfY291bnRdIHdpbGwgY29tcHV0ZSBhIG11bHRpLXNldCBrZXllZCBvbiB0aGF0XG4gICAgICBuZXcgdmFsdWUuXG5cbiAgICAgIEFueSB2YWx1ZSB0aGF0IHdvdWxkIG90aGVyd2lzZSBoYXZlIGEgY291bnQgb2YgXCIwXCIgaXMgaW5zdGVhZFxuICAgICAgcmVtb3ZlZCBmcm9tIHRoZSBtYXAuXG5cbiAgICAgIEl0IGlzIGFzc3VtZWQgdGhhdCBbZl0gaXMgcXVpdGUgZmFzdCBhcyB0aGUgZnVuY3Rpb24gd2lsbCBiZVxuICAgICAgY2FsbGVkIG1vcmUgb2Z0ZW4gdGhhbiBzdHJpY3RseSBuZWNlc3NhcnksIGJ1dCBpdCBkb2VzIHRoaXNcbiAgICAgIGluIG9yZGVyIHRvIGF2b2lkIGFsbG9jYXRpbmcgYW4gZXh0cmEgbWFwLiAgSWYgW2ZdIGlzIHZlcnkgc2xvd1xuICAgICAgYW5kIHlvdSBkb24ndCBtaW5kIHRoZSBleHRyYSBhbGxvY2F0aW9ucywgdXNlXG4gICAgICBbSW5jcl9tYXAuaW5kZXhfYnlpXSBjb21wb3NlZCB3aXRoIFtJbmNyX21hcC5tYXAgfmY6TWFwLmxlbmd0aF0gKilcbiAgdmFsIG1hcGlfY291bnRcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnazEsICd2LCAnY21wMSkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gY29tcGFyYXRvcjooJ2syLCAnY21wMikgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGY6KGtleTonazEgLT4gZGF0YTondiAtPiAnazIpXG4gICAgLT4gKCgnazIsIGludCwgJ2NtcDIpIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBUaGUgc2FtZSBhcyBbbWFwaV9jb3VudF0gYnV0IHRoZSBbZl0gZnVuY3Rpb24gb25seSBnZXRzIHRvIHNlZSB0aGVcbiAgICAgIGRhdGEgaW5zdGVhZCBvZiBib3RoIHRoZSBrZXkgYW5kIHRoZSBkYXRhLiAqKVxuICB2YWwgbWFwX2NvdW50XG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ2sxLCAndiwgJ2NtcDEpIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBmOigndiAtPiAnazIpXG4gICAgLT4gKCgnazIsIGludCwgJ2NtcDIpIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBDb21wdXRlcyB0aGUgc21hbGxlc3QgW3JdIHdoZXJlIFtyXSBpcyBjb21wdXRlZCBmb3IgZWFjaCBrdi1wYWlyIGluIHRoZVxuICAgICAgaW5wdXQgbWFwLiAqKVxuICB2YWwgbWFwaV9taW5cbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdyLCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ3IpXG4gICAgLT4gKCdyIG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogQ29tcHV0ZXMgdGhlIGxhcmdlc3QgW3JdIHdoZXJlIFtyXSBpcyBjb21wdXRlZCBmb3IgZWFjaCBrdi1wYWlyIGluIHRoZVxuICAgICAgaW5wdXQgbWFwLiAqKVxuICB2YWwgbWFwaV9tYXhcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdyLCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ3IpXG4gICAgLT4gKCdyIG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogQ29tcHV0ZXMgdGhlIHNtYWxsZXN0IFtyXSB3aGVyZSBbcl0gaXMgY29tcHV0ZWQgZm9yIGVhY2gga3YtcGFpciBpbiB0aGVcbiAgICAgIGlucHV0IG1hcC4gKilcbiAgdmFsIG1hcF9taW5cbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdyLCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooJ3YgLT4gJ3IpXG4gICAgLT4gKCdyIG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogQ29tcHV0ZXMgdGhlIGxhcmdlc3QgW3JdIHdoZXJlIFtyXSBpcyBjb21wdXRlZCBmb3IgZWFjaCBrdi1wYWlyIGluIHRoZVxuICAgICAgaW5wdXQgbWFwLiAqKVxuICB2YWwgbWFwX21heFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndiwgXykgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gY29tcGFyYXRvcjooJ3IsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBmOigndiAtPiAncilcbiAgICAtPiAoJ3Igb3B0aW9uLCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBDb21wdXRlcyB0aGUgc21hbGxlc3QgZGF0YSB2YWx1ZSBmcm9tIHRoZSBpbnB1dCBtYXAuICopXG4gIHZhbCBtaW5fdmFsdWVcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCd2LCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCd2IG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogQ29tcHV0ZXMgdGhlIGxhcmdlc3QgZGF0YSB2YWx1ZSBmcm9tIHRoZSBpbnB1dCBtYXAuICopXG4gIHZhbCBtYXhfdmFsdWVcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCd2LCBfKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCd2IG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogQ29tcHV0ZXMgW21pbiAqIG1heF0gd2hlcmUgdGhlIHZhbHVlIGlzIGNvbXB1dGVkIGZvciBlYWNoIGt2LXBhaXJcbiAgICAgIGluIHRoZSBpbnB1dCBtYXAgKilcbiAgdmFsIG1hcGlfYm91bmRzXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2LCBfKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBjb21wYXJhdG9yOignciwgXykgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdyKVxuICAgIC0+ICgoJ3IgKiAncikgb3B0aW9uLCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBDb21wdXRlcyBbbWluICogbWF4XSB3aGVyZSB0aGUgdmFsdWUgaXMgY29tcHV0ZWQgZm9yIGVhY2gga3YtcGFpclxuICAgICAgaW4gdGhlIGlucHV0IG1hcCAqKVxuICB2YWwgbWFwX2JvdW5kc1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndiwgXykgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gY29tcGFyYXRvcjooJ3IsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBmOigndiAtPiAncilcbiAgICAtPiAoKCdyICogJ3IpIG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogQ29tcHV0ZXMgdGhlIHNtYWxsZXN0IGFuZCBsYXJnZXN0IGRhdGEgdmFsdWUgZnJvbSB0aGUgaW5wdXQgbWFwLiAqKVxuICB2YWwgdmFsdWVfYm91bmRzXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2LCBfKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBjb21wYXJhdG9yOigndiwgXykgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgoJ3YgKiAndikgb3B0aW9uLCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBMaWtlIFttZXJnZV0gaW4gW0Jhc2UuTWFwLm1lcmdlXS4gTm90ZSB0aGF0IFtmXSBpcyBjYWxsZWQgYXQgbW9zdCBvbmNlIHBlciBrZXkgaW5cbiAgICAgIGFueSBnaXZlbiBzdGFiaWxpemF0aW9uLiAqKVxuICB2YWwgbWVyZ2VcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWxfbGVmdDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ID9kYXRhX2VxdWFsX3JpZ2h0OigndjIgLT4gJ3YyIC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YxLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiAoKCdrLCAndjIsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGY6KGtleTonayAtPiAoJ3YxLCAndjIpIE1hcC5NZXJnZV9lbGVtZW50LnQgLT4gJ3YzIG9wdGlvbilcbiAgICAtPiAoKCdrLCAndjMsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBbbWVyZ2VfYm90aF9zYW1lXSBpcyBsaWtlIFttZXJnZV0sIGJ1dCBvcHRpbWl6ZWQgZm9yIHRoZSBjYXNlIHdoZXJlIHlvdSBvbmx5IGNhcmVcbiAgICAgIGFib3V0IHRoZSBjYXNlIHdoZXJlIGJvdGggbWFwcyBjb250YWluIGEgcGFydGljdWxhciBrZXkuICopXG4gIHZhbCBtZXJnZV9ib3RoX3NvbWVcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWxfbGVmdDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ID9kYXRhX2VxdWFsX3JpZ2h0OigndjIgLT4gJ3YyIC0+IGJvb2wpXG4gICAgLT4gP291dF9lcXVhbDooJ3YzIC0+ICd2MyAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2MSwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gJ3YxIC0+ICd2MiAtPiAndjMpXG4gICAgLT4gKCgnaywgJ3YzLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogW21lcmdlX2Rpc2pvaW50XSBtZXJnZXMgdHdvIG1hcHMgdGhhdCBfbXVzdF8gbm90IHNoYXJlIGFueSBrZXlzIG9uIGEgZ2l2ZW4gXG4gICAgICBzdGFiaWxpemF0aW9uLiAgSWYgdGhpcyBpbnZhcmlhbnQgaXMgbm90IHVwaGVsZCBieSB0aGUgY2FsbGVyLCBpbmNyZW1lbnRhbCBtYXkgXG4gICAgICBjcmFzaCwgb3IgdGhlIG91dHB1dCBtYXAgbWF5IGNvbnRhaW4gaW5jb3JyZWN0IHJlc3VsdHMuICopXG4gIHZhbCBtZXJnZV9kaXNqb2ludFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gKCgnaywgJ3YsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+ICgoJ2ssICd2LCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogTGlrZSBbbWVyZ2VdLCBidXQgb3BlcmF0aW5nIHVzaW5nIGluY3JlbWVudGFsIG5vZGVzLiBUaGlzIGlzIGEgZ29vZCB1c2UgY2FzZSBmb3JcbiAgICAgIFtwcHhfcGF0dGVybl9iaW5kXS4gKilcbiAgdmFsIG1lcmdlJ1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/Y3V0b2ZmOigndjEsICd2MikgTWFwLk1lcmdlX2VsZW1lbnQudCBJbmNyZW1lbnRhbC5DdXRvZmYudFxuICAgIC0+ID9kYXRhX2VxdWFsX2xlZnQ6KCd2MSAtPiAndjEgLT4gYm9vbClcbiAgICAtPiA/ZGF0YV9lcXVhbF9yaWdodDooJ3YyIC0+ICd2MiAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2MSwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gKCgnaywgJ3YyLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOlxuICAgICAgICAgKGtleTona1xuICAgICAgICAgIC0+ICgoJ3YxLCAndjIpIE1hcC5NZXJnZV9lbGVtZW50LnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgICAgICAgLT4gKCd2MyBvcHRpb24sICd3KSBJbmNyZW1lbnRhbC50KVxuICAgIC0+ICgoJ2ssICd2MywgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgdmFsIHVuemlwXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9sZWZ0X3Jlc3VsdF9lcXVhbDooJ2EgLT4gJ2EgLT4gYm9vbClcbiAgICAtPiA/cmlnaHRfcmVzdWx0X2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+ICgoJ2ssICdhICogJ2IsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+ICgoJ2ssICdhLCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnQgKiAoKCdrLCAnYiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgKCoqIFt1bnppcF9tYXBpXSBpcyBzaW1pbGFyIHRvIFtMaXN0LnVuemlwXSwgYnV0IGZvciBpbmNyZW1lbnRhbCBtYXBzLiBOb3RlIHRoYXQgW2ZdIG1heVxuICAgICAgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIG9uIGEgc2luZ2xlIGVsZW1lbnQuICopXG4gIHZhbCB1bnppcF9tYXBpXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ID9sZWZ0X3Jlc3VsdF9lcXVhbDooJ3YxIC0+ICd2MSAtPiBib29sKVxuICAgIC0+ID9yaWdodF9yZXN1bHRfZXF1YWw6KCd2MiAtPiAndjIgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ3YxICogJ3YyKVxuICAgIC0+ICgoJ2ssICd2MSwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgICAgKiAoKCdrLCAndjIsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBbdW56aXBfbWFwaSddIGlzIGxpa2UgW3VuemlwX21hcGldLCBidXQgYWxsb3dzIHlvdSB0byBkZWZpbmUgdGhlIG1hcHBpbmcgZnJvbSB0aGVcbiAgICAgIGlucHV0IG1hcCdzIGVsZW1lbnRzIHRvIHRoZSBvdXRwdXQgbWFwcycgZWxlbWVudHMgaW5jcmVtZW50YWxseS5cblxuICAgICAgVGhlIG5haXZlIGltcGxlbWVudGF0aW9uIChzZWUgYmVsb3cpIHByb2R1Y2VzIHdvcnNlIEluY3JlbWVudGFsIGdyYXBocy5cblxuICAgICAge1tcbiAgICAgICAgbGV0IHRlbXAgPVxuICAgICAgICAgIEluY3JfbWFwLm1hcGknIGlucHV0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICAgICAgZiB+a2V5IH5kYXRhIHw+IFR1cGxlMi51bmN1cnJ5IEluY3IuYm90aClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGxlZnQgPSBJbmNyX21hcC5tYXAgdGVtcCB+ZjpUdXBsZTIuZ2V0MSBpblxuICAgICAgICBsZXQgcmlnaHQgPSBJbmNyX21hcC5tYXAgdGVtcCB+ZjpUdXBsZTIuZ2V0MiBpblxuICAgICAgICBsZWZ0LCByaWdodFxuICAgICAgXX0gKilcbiAgdmFsIHVuemlwX21hcGknXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9jdXRvZmY6J3YgSW5jcmVtZW50YWwuQ3V0b2ZmLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gZjpcbiAgICAgICAgIChrZXk6J2tcbiAgICAgICAgICAtPiBkYXRhOigndiwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAgICAgICAtPiAoJ3YxLCAndykgSW5jcmVtZW50YWwudCAqICgndjIsICd3KSBJbmNyZW1lbnRhbC50KVxuICAgIC0+ICgoJ2ssICd2MSwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgICAgKiAoKCdrLCAndjIsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBUaGlzIGlzIHRoZSBcImVhc3lcIiB2ZXJzaW9uIG9mIFtqb2luXSAqKVxuICB2YWwgZmxhdHRlblxuICAgIDogICd3IEluY3JlbWVudGFsLlN0YXRlLnRcbiAgICAtPiAoJ2ssICgndiwgJ3cpIEluY3JlbWVudGFsLnQsICdjbXApIE1hcC50XG4gICAgLT4gKCgnaywgJ3YsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBUaGUgbm9uLWluY3JlbWVudGFsIHNlbWFudGljcyBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBpZGVudGl0eSBmdW5jdGlvbi4gIEl0c1xuICAgICAgcHVycG9zZSBpcyB0byBjb2xsYXBzZSB0aGUgZXh0cmEgbGV2ZWwgb2YgaW5jcmVtZW50YWxpdHkgYXQgdGhlIGxldmVsIG9mIHRoZSBkYXRhIG9mXG4gICAgICB0aGUgbWFwLiopXG4gIHZhbCBqb2luXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ICgoJ2ssICgndiwgJ3cpIEluY3JlbWVudGFsLnQsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+ICgoJ2ssICd2LCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgc2VwYXJhdGVcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gKCgnaywgJ3YsICdjbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGRhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgKCd2LCAndykgSW5jcmVtZW50YWwudCwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgdmFsIGtleXNcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gKCgnaywgJ3YsICdjKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiAoKCdrLCAnYykgU2V0LnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgKCoqIENvbXB1dGVzIHRoZSBbcmFua10gb2YgYSBrZXkgKGdpdmVuIGluY3JlbWVudGFsbHkpIGluc2lkZSBvZiBhIG1hcCAoYWxzb1xuICAgICAgaW5jcmVtZW50YWwpLiAgVGhlIHRyYWRpdGlvbmFsIFtNYXAucmFua10gZnVuY3Rpb24gaXMgTyhuKSwgYW5kIHRoaXMgaW5jcmVtZW50YWxcbiAgICAgIHJhbmsgZnVuY3Rpb24gaGFzIHRoZSBmb2xsb3dpbmcgcGVyZm9ybWFuY2UgY2hhcmFjdGVyaXN0aWNzOlxuXG4gICAgICBkZWZpbml0aW9uczpcbiAgICAgIG4gOiB0aGUgc2l6ZSBvZiB0aGUgbWFwXG4gICAgICByIDogdGhlIHRpbWUgdG8gY29tcHV0ZSBbTWFwLnN5bW1ldHJpY19kaWZmXSBiZXR3ZWVuIHRoZSB0d28gbWFwc1xuICAgICAgayA6IHRoZSBjaGFuZ2UgaW4gcmFuayBvZiB0aGUga2V5IGJldHdlZW4gdHdvIHN0YWJpbGl6YXRpb25zXG5cbiAgICAgIG5vdGUgdGhhdCBbcl0gYW5kIFtrXSBhcmUgX211Y2hfIHNtYWxsZXIgdGhhbiBbbl0gZm9yIG1vc3QgcHJhY3RpY2FsIHB1cnBvc2VzXG5cbiAgICAgIC0gTyhsb2cgbikgd2hlbiB0aGUga2V5IGlzIG5vdCBpbiB0aGUgbWFwLlxuICAgICAgICBUaGlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBvdGhlciBldmVyeSBvdGhlciBzY2VuYXJpby5cbiAgICAgIC0gTyhuKSBvbiB0aGUgaW5pdGlhbCBzdGFiaWxpemF0aW9uXG4gICAgICAtIE8obikgd2hlbiB0aGUga2V5IHRyYW5zaXRpb25zIGZyb20gbm90IGJlaW5nIGluIHRoZSBtYXAgdG8gYmVpbmcgaW4gdGhlIG1hcFxuICAgICAgLSBPKGxvZyBuICsgcikgd2hlbiB0aGUgbWFwIGNoYW5nZXNcbiAgICAgIC0gTyhsb2cgbiArIGspIHdoZW4gdGhlIGtleSBjaGFuZ2VzXG4gICAgICAtIE8obG9nIG4gKyByICsgaykgd2hlbiBib3RoIGtleSBhbmQgbWFwIGNoYW5nZSAqKVxuICB2YWwgcmFua1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiAoKCdrLCAndiwgJ2NtcCkgQmFzZS5NYXAudCwgJ3N0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAtPiAoJ2ssICdzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgLT4gKGludCBvcHRpb24sICdzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG5cbiAgKCoqIFtzdWJyYW5nZSBtYXAgKG1pbiwgbWF4KV0gY29uc3RydWN0cyBhbiBpbmNyZW1lbnRhbCBzdWJtYXAgdGhhdCBpbmNsdWRlcyBhbGwgb2YgdGhlXG4gICAgICBrZXlzIGFuZCBkYXRhIGZyb20gW21hcF0gYmV0d2VlbiBbbWluXSBhbmQgW21heF0sIGFuZCBub25lIG9mIHRoZSBrZXlzIG91dHNpZGUgdGhlXG4gICAgICByYW5nZS5cblxuICAgICAgW3N1YnJhbmdlIG1hcCBOb25lXSBpcyB0aGUgZW1wdHkgbWFwLiBbcmFuZ2VdIGJlaW5nIFtOb25lXSBtZWFucyBubyBlbGVtZW50cyBhcmVcbiAgICAgIGNob3Nlbi5cblxuICAgICAgTm90ZSB0aGF0IGluY3JlbWVudGFsIGNoYW5nZXMgaGF2ZSBhIHJ1bnRpbWUgb2YgTygoayArIG0pIGxvZyBuKSB3aGVyZSBrIGlzIHRoZSBzaXplXG4gICAgICBvZiB0aGUgY2hhbmdlcyB0byB0aGUgdW5kZXJseWluZyBtYXAgYW5kIG0gaXMgdGhlIHNpemUgb2YgdGhlIGNoYW5nZXMgdG8gdGhlXG4gICAgICBlbGVtZW50cyBjb250YWluZWQgYnkgdGhlIHJhbmdlLiBUaGUgY29tcGxleGl0eSBvZiB0aGUgaW5pdGlhbCBjb21wdXRhdGlvbiBpcyB0aGVcbiAgICAgIHNhbWUgYXMgdGhlIGluY3JlbWVudGFsIGNvbXB1dGF0aW9uLCB3aXRoIHNvbWUgc2ltcGxpZmljYXRpb24uIGsgPSAwIGJlY2F1c2Ugd2UgaGF2ZVxuICAgICAgbm90IG1hZGUgYW55IGNoYW5nZXMgdG8gdGhlIHVuZGVybHlpbmcgbWFwIHlldCwgYW5kIG0gZXF1YWxzIHRoZSBzaXplIG9mIHRoZSByYW5nZSxcbiAgICAgIGJlY2F1c2UgdGhlIGluaXRpYWwgcmFuZ2UgaXMgZW1wdHkuICopXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gKCAoJ2sgTWF5YmVfYm91bmQuQXNfbG93ZXJfYm91bmQudCAqICdrIE1heWJlX2JvdW5kLkFzX3VwcGVyX2JvdW5kLnQpIG9wdGlvblxuICAgICAgICwgJ3cgKVxuICAgICAgIEluY3JlbWVudGFsLnRcbiAgICAtPiAoKCdrLCAndiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgKCoqIFtzdWJyYW5nZV9ieV9yYW5rIG1hcCAocywgZSldIGNvbnN0cnVjdHMgYW4gaW5jcmVtZW50YWwgc3VibWFwIHRoYXQgaW5jbHVkZXMgKGUtcysxKVxuICAgICAga2V5cyBiZXR3ZWVuIHMtdGggYW5kIGUtdGgsIGluY2x1c2l2ZS5cblxuICAgICAgSWYgcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIG1hcCBsZW5ndGgsIHRoZSByZXN1bHQgaXMgZW1wdHkuXG4gICAgICBJZiBlIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gbWFwIGxlbmd0aCwgdGhlIHJlc3VsdCBjb250YWlucyBrZXlzIGZyb20gcy10aCB0byB0aGVcbiAgICAgIGxhc3Qgb25lLlxuXG4gICAgICBSYWlzZXMgZm9yIGludmFsaWQgaW5kaWNlcyAtIHMgPCAwIG9yIGUgPCBzLlxuXG4gICAgICBSdW50aW1lIG9mIHRoZSBpbml0aWFsIGNvbXB1dGF0aW9uIGlzIE8obWluKGUsIG4tcykgKyBsb2cobikpLCBpLmUuIGxpbmVhcixcbiAgICAgIGJ1dCBvcHRpbWl6ZWQgZm9yIHJhbmdlcyBjbG9zZSB0byBiZWdpbm5pbmcgb3IgZW5kLlxuXG4gICAgICBSdW50aW1lIG9mIHRoZSBpbmNyZW1lbnRhbCBjb21wdXRhdGlvbiBpcyBPKGxvZyhuKSArIGsgKyAobSttJykgKiBsb2cobikpIHdoZXJlOlxuICAgICAgLSBrIGlzIHRoZSBzaXplIG9mIHRoZSBkaWZmXG4gICAgICAtIG0gaXMgdGhlIHRvdGFsIGltcGFjdCBvZiBtYXAgY2hhbmdlcyBvbiB0aGUgcmFuZ2UsIGJvdW5kZWQgYnkgayAoZS5nLiBpZiB3ZSBhZGRcbiAgICAgICAgMTAwMSBrZXlzIGFuZCByZW1vdmUgMTAwMCBiZWxvdyBzLCB0aGVuIG0gPSAxKVxuICAgICAgLSBtJyA9IE8oIHxuZXcgcyAtIG9sZCBzfCArIHxuZXcgZSAtIG9sZCBlfCApLlxuICAqKVxuICB2YWwgc3VicmFuZ2VfYnlfcmFua1xuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gKCBpbnQgTWF5YmVfYm91bmQuQXNfbG93ZXJfYm91bmQudCAqIGludCBNYXliZV9ib3VuZC5Bc191cHBlcl9ib3VuZC50XG4gICAgICAgLCAndyApXG4gICAgICAgSW5jcmVtZW50YWwudFxuICAgIC0+ICgoJ2ssICd2LCAnY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogW3Jla2V5XSB0cmFuc2Zvcm1zIGEgbWFwIGJ5IG1vZGlmeWluZyB0aGUgdHlwZSBvZiB0aGUga2V5LiAgVGhlIHVzZXIgaXNcbiAgICAgIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyB0aGF0IFtmXSBkb2Vzbid0IHJldHVybiB0aGUgc2FtZSBvdXRwdXQga2V5IGZvclxuICAgICAgbXVsdGlwbGUgaW5wdXQga2V5cy5cblxuICAgICAgVGhpcyBmdW5jdGlvbiBhc3N1bWVzIFtmXSBpcyBjaGVhcCB0byBjb21wdXRlIGFuZCBhY2NvcmRpbmdseSBtYXkgY2FsbFxuICAgICAgaXQgbXVsdGlwbGUgdGltZXMuICopXG4gIHZhbCByZWtleVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrMSwgJ3YsICdjbXAxKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBjb21wYXJhdG9yOignazIsICdjbXAyKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gZjooa2V5OidrMSAtPiBkYXRhOid2IC0+ICdrMilcbiAgICAtPiAoKCdrMiwgJ3YsICdjbXAyKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogW2luZGV4X2J5aSBtYXAgfmNvbXBhcmF0b3IgfmluZGV4XSBjb25zdHJ1Y3RzIGFuIGluY3JlbWVudGFsIG1hcC1vZi1tYXBzIHdoZXJlIGVhY2hcbiAgICAgIGtleS1kYXRhIHBhaXIgb2YgdGhlIGlucHV0IG1hcCBpcyBwcmVzZW50IGluIG9uZSAob3Igbm9uZSkgb2YgdGhlIGlubmVyIG1hcHMuXG4gICAgICBbaW5kZXhdIHNwZWNpZmllcyB0aGUgb3V0ZXIgbWFwIGtleSB1bmRlciB3aGljaCBlYWNoIG9yaWdpbmFsIGtleS1kYXRhIHBhaXIgaXNcbiAgICAgIGZvdW5kLlxuXG4gICAgICBBbGwgb2YgdGhlIHJlc3VsdGluZyBpbm5lciBtYXBzIGFyZSBndWFyYW50ZWVkIHRvIGJlIG5vbi1lbXB0eTsgaWYgdGhlIGlubmVyIG1hcFxuICAgICAgd291bGQgb3RoZXJ3aXNlIGJlIGVtcHR5LCB0aGVuIHRoZSBrZXkgZm9yIHRoYXQgbWFwIGlzIGluc3RlYWQgcmVtb3ZlZCBmcm9tIHRoZVxuICAgICAgb3V0ZXIgbWFwLlxuXG4gICAgICBBbiBhbGwtYXQtb25jZSB2ZXJzaW9uIG9mIFtpbmRleF9ieV0gd291bGQgbG9vayBsaWtlOlxuXG4gICAgICB7W1xuICAgICAgICBsZXQgaW5kZXhfYnlpIG1hcCB+Y29tcGFyYXRvciB+aW5kZXggPVxuICAgICAgICAgIE1hcC50b19hbGlzdCBtYXBcbiAgICAgICAgICB8PiBMaXN0LmZpbHRlcl9tYXAgfmY6KGZ1biAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgICAgbWF0Y2ggaW5kZXggfmtleSB+ZGF0YSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgICAgfCBTb21lIGluZGV4IC0+IFNvbWUgKGluZGV4LCAoa2V5LCBkYXRhKSkpXG4gICAgICAgICAgfD4gTWFwLm9mX2FsaXN0X211bHRpIGNvbXBhcmF0b3JcbiAgICAgICAgICB8PiBNYXAubWFwIH5mOihNYXAub2ZfYWxpc3RfZXhuIChNYXAuY29tcGFyYXRvcl9zIG1hcCkpXG4gICAgICAgIDs7XG4gICAgICBdfSAqKVxuICB2YWwgaW5kZXhfYnlpXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ2lubmVyX2tleSwgJ3YsICdpbm5lcl9jbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdvdXRlcl9rZXksICdvdXRlcl9jbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBpbmRleDooa2V5Oidpbm5lcl9rZXkgLT4gZGF0YTondiAtPiAnb3V0ZXJfa2V5IG9wdGlvbilcbiAgICAtPiAoICgnb3V0ZXJfa2V5LCAoJ2lubmVyX2tleSwgJ3YsICdpbm5lcl9jbXApIE1hcC50LCAnb3V0ZXJfY21wKSBNYXAudFxuICAgICAgICwgJ3cgKVxuICAgICAgIEluY3JlbWVudGFsLnRcblxuICAoKiogW2luZGV4X2J5IG1hcCB+Y29tcGFyYXRvciB+aW5kZXhdIGlzIGxpa2UgW2luZGV4X2J5aSBtYXAgfmNvbXBhcmF0b3IgfmluZGV4XSwgYnV0XG4gICAgICB0aGUgW2luZGV4XSBmdW5jdGlvbiBkb2VzIG5vdCB0YWtlIHRoZSBpbm5lciBtYXAncyBba2V5XS4gKilcbiAgdmFsIGluZGV4X2J5XG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ2lubmVyX2tleSwgJ3YsICdpbm5lcl9jbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGNvbXBhcmF0b3I6KCdvdXRlcl9rZXksICdvdXRlcl9jbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBpbmRleDooJ3YgLT4gJ291dGVyX2tleSBvcHRpb24pXG4gICAgLT4gKCAoJ291dGVyX2tleSwgKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCwgJ291dGVyX2NtcCkgTWFwLnRcbiAgICAgICAsICd3IClcbiAgICAgICBJbmNyZW1lbnRhbC50XG5cbiAgdmFsIHVub3JkZXJlZF9mb2xkX25lc3RlZF9tYXBzXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ID9yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OmJvb2xcbiAgICAtPiA/dXBkYXRlOlxuICAgICAgICAgKG91dGVyX2tleTonb3V0ZXJfa2V5XG4gICAgICAgICAgLT4gaW5uZXJfa2V5Oidpbm5lcl9rZXlcbiAgICAgICAgICAtPiBvbGRfZGF0YTondlxuICAgICAgICAgIC0+IG5ld19kYXRhOid2XG4gICAgICAgICAgLT4gJ2FjY1xuICAgICAgICAgIC0+ICdhY2MpXG4gICAgLT4gKCAoJ291dGVyX2tleSwgKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCwgJ291dGVyX2NtcCkgTWFwLnRcbiAgICAgICAsICd3IClcbiAgICAgICBJbmNyZW1lbnRhbC50XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gYWRkOihvdXRlcl9rZXk6J291dGVyX2tleSAtPiBpbm5lcl9rZXk6J2lubmVyX2tleSAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylcbiAgICAtPiByZW1vdmU6KG91dGVyX2tleTonb3V0ZXJfa2V5IC0+IGlubmVyX2tleTonaW5uZXJfa2V5IC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+ICgnYWNjLCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBbdHJhbnNwb3NlXSBmbGlwcyB0aGUgb3JkZXIgb2YgYSBkb3VibHkgbmVzdGVkIGluY3JlbWVudGFsIG1hcC5cblxuICAgICAgQWxsIGlubmVyIG1hcCBpbnN0YW5jZXMgd2lsbCBoYXZlIGF0IGxlYXN0IG9uZSBlbGVtZW50LiAqKVxuICB2YWwgdHJhbnNwb3NlXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnazIsICdrMl9jbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoKCdrMSwgKCdrMiwgJ3YsICdrMl9jbXApIE1hcC50LCAnazFfY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiAoKCdrMiwgKCdrMSwgJ3YsICdrMV9jbXApIE1hcC50LCAnazJfY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgY29sbGFwc2VcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCAoJ291dGVyX2tleSwgKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCwgJ291dGVyX2NtcCkgTWFwLnRcbiAgICAgICAsICd3IClcbiAgICAgICBJbmNyZW1lbnRhbC50XG4gICAgLT4gY29tcGFyYXRvcjooJ2lubmVyX2tleSwgJ2lubmVyX2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICggKCAnb3V0ZXJfa2V5ICogJ2lubmVyX2tleVxuICAgICAgICAgLCAndlxuICAgICAgICAgLCAoJ291dGVyX2NtcCwgJ2lubmVyX2NtcCkgVHVwbGUyLmNvbXBhcmF0b3Jfd2l0bmVzcyApXG4gICAgICAgICBNYXAudFxuICAgICAgICwgJ3cgKVxuICAgICAgIEluY3JlbWVudGFsLnRcblxuICAoKiogW2NvbGxhcHNlX2J5XSBpcyBzaW1pbGFyIHRvIFtjb2xsYXBzZV0sIGJ1dCBpdCBhbGxvd3MgdGhlIHVzZXIgdG9cbiAgICAgIGNob29zZSBob3cgdG8gY29tYmluZSB0aGUgdHdvIGtleXMgZnJvbSB0aGUgb3V0ZXIgYW5kIGlubmVyIG1hcHMuXG4gICAgICBUaGlzIGRvZXMgbWVhbiB0aGF0IGl0J3MgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBpbXBsZW1lbnRvciBvZiB0aGVcbiAgICAgIFttZXJnZV9rZXlzXSBmdW5jdGlvbiB0byB1cGhvbGQgdGhpcyBpbnZhcmlhbnQ6XG5cbiAgICAgID4gYSBtZXJnZWQta2V5IGJlaW5nIGVxdWFsIHRvIGFub3RoZXIgbWVyZ2VkLWtleSBpbXBsaWVzIHRoYXQgdGhlXG4gICAgICA+IG91dGVyLWtleXMgYW5kIGlubmVyLWtleXMgd2hpY2ggd2VyZSB1c2VkIHRvIGJ1aWxkIHRoZSBtZXJnZWQga2V5cyBhbHNvXG4gICAgICA+IGNvbXBhcmUgdG8gYmUgZXF1YWwgdG8gb25lIGFub3RoZXJcblxuICAgICAgVGhlIFt+Y29tcGFyYXRvcl0gYXJndW1lbnQgdGhlIGZpcnN0LWNsYXNzIG1vZHVsZSBvZiB0aGUgb3V0cHV0IGtleSwgaXRcbiAgICAgIHVzdWFsbHkgbG9va3MgbGlrZSB0aGlzOlxuICAgICAgWyB+Y29tcGFyYXRvcjoobW9kdWxlIENvbWJpbmVkX2tleSkgXVxuICAgICAgYnV0IG1ha2Ugc3VyZSB0aGF0IHRoZSBtb2R1bGUgaW1wbGVtZW50cyB0aGUgW0NvbXBhcmF0b3IuU10gc2lnbmF0dXJlLiAqKVxuICB2YWwgY29sbGFwc2VfYnlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCAoJ291dGVyX2tleSwgKCdpbm5lcl9rZXksICd2LCAnaW5uZXJfY21wKSBNYXAudCwgJ291dGVyX2NtcCkgTWFwLnRcbiAgICAgICAsICd3IClcbiAgICAgICBJbmNyZW1lbnRhbC50XG4gICAgLT4gbWVyZ2Vfa2V5czooJ291dGVyX2tleSAtPiAnaW5uZXJfa2V5IC0+ICdjb21iaW5lZF9rZXkpXG4gICAgLT4gY29tcGFyYXRvcjooJ2NvbWJpbmVkX2tleSwgJ2NvbWJpbmVkX2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgoJ2NvbWJpbmVkX2tleSwgJ3YsICdjb21iaW5lZF9jbXApIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuXG4gICgqKiBDb252ZXJ0IGEgbWFwIHdpdGggdHVwbGVzIGZvciBrZXlzIGludG8gYSBuZXN0ZWQgbWFwLiBUaGlzIG9wZXJhdGlvbiBpcyByb3VnaGx5IHRoZVxuICAgICAgaW52ZXJzZSBvZiBbY29sbGFwc2VdLCB0aG91Z2ggaWYgdGhlcmUgYXJlIG91dGVyIGtleXMgaW4gdGhlIHVuY29sbGFwc2VkIG1hcCB0aGF0XG4gICAgICBjb3JyZXNwb25kIHRvIGVtcHR5IGlubmVyIG1hcHMsIHRoZSBvdXRlciBrZXlzIHdpbGwgYmUgZHJvcHBlZCBmcm9tIHRoZSBleHBhbmRlZFxuICAgICAgbWFwLiAqKVxuICB2YWwgZXhwYW5kXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ291dGVyX2tleSAqICdpbm5lcl9rZXksICd2LCAndHVwbGVfY21wKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBvdXRlcl9jb21wYXJhdG9yOignb3V0ZXJfa2V5LCAnb3V0ZXJfY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gaW5uZXJfY29tcGFyYXRvcjooJ2lubmVyX2tleSwgJ2lubmVyX2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICggKCdvdXRlcl9rZXksICgnaW5uZXJfa2V5LCAndiwgJ2lubmVyX2NtcCkgTWFwLnQsICdvdXRlcl9jbXApIE1hcC50XG4gICAgICAgLCAndyApXG4gICAgICAgSW5jcmVtZW50YWwudFxuXG4gIHZhbCBjb3VudGlcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCgnaywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpXG4gICAgLT4gKGludCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgY291bnRcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKChfLCAndiwgXykgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gZjooJ3YgLT4gYm9vbClcbiAgICAtPiAoaW50LCAndykgSW5jcmVtZW50YWwudFxuXG4gIHZhbCBmb3JfYWxsaVxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndiwgXykgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbClcbiAgICAtPiAoYm9vbCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICB2YWwgZm9yX2FsbFxuICAgIDogID9pbnN0cnVtZW50YXRpb246SW5zdHJ1bWVudGF0aW9uLnRcbiAgICAtPiA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKF8sICd2LCBfKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOigndiAtPiBib29sKVxuICAgIC0+IChib29sLCAndykgSW5jcmVtZW50YWwudFxuXG4gIHZhbCBleGlzdHNpXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoJ2ssICd2LCBfKSBNYXAudCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKVxuICAgIC0+IChib29sLCAndykgSW5jcmVtZW50YWwudFxuXG4gIHZhbCBleGlzdHNcbiAgICA6ICA/aW5zdHJ1bWVudGF0aW9uOkluc3RydW1lbnRhdGlvbi50XG4gICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKChfLCAndiwgXykgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgLT4gZjooJ3YgLT4gYm9vbClcbiAgICAtPiAoYm9vbCwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAoKiogSW5jcmVtZW50YWxseSBjb21wdXRlIHRoZSBzdW0gb2YgYWxsIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIG1hcC5cblxuICAgICAgQmV3YXJlIG9mIGZsb2F0J3MgbmVnYXRpdmUgaW5maW5pdGllcy4gVGhleSBhcmVuJ3QgY29tbXV0YXRpdmUgYW5kIHdpbGwgbWlzYmVoYXZlXG4gICAgICBoZXJlLlxuICAqKVxuICB2YWwgc3VtXG4gICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgIC0+ID9kYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgoXywgJ3YsIF8pIE1hcC50LCAndykgSW5jcmVtZW50YWwudFxuICAgIC0+IChtb2R1bGUgQWJzdHJhY3RfYWxnZWJyYS5Db21tdXRhdGl2ZV9ncm91cC5XaXRob3V0X3NleHAgd2l0aCB0eXBlIHQgPSAndSlcbiAgICAtPiBmOigndiAtPiAndSlcbiAgICAtPiAoJ3UsICd3KSBJbmNyZW1lbnRhbC50XG5cbiAgKCoqIE9ic2VydmVzIGNoYW5nZXMgdG8gYW4gaW5jcmVtZW50YWwgbWFwLiAgRXZlcnkgc3RhYmlsaXplLCB0aGlzIG9ic2VydmVyIHdpbGxcbiAgICAgIGNvbXBhcmUgdGhlIG1hcCBmcm9tIHRoZSBwcmV2aW91cyBzdGFiaWxpemF0aW9uIGFuZCB0aGUgY3VycmVudCBzdGFiaWxpemF0aW9uLFxuICAgICAgY2FsbGluZyBbZl0gZm9yIGV2ZXJ5IGNoYW5nZSB0aGF0IGl0IGRldGVjdHMuXG5cbiAgICAgIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgY2hhbmdlcyB0byB0aGUgbWFwIF9iZXR3ZWVuXyBzdGFiaWxpemF0aW9ucyB3aWxsXG4gICAgICBub3QgYmUgcHJvY2Vzc2VkLCBmb3IgZXhhbXBsZTogXG5cbiAgICAgIHtbXG4gICAgICAgIGxldCB2YXIgPSBJbmNyLlZhci5jcmVhdGUgU3RyaW5nLk1hcC5lbXB0eSBpblxuICAgICAgICBJbmNyX21hcC5vYnNlcnZlX2NoYW5nZXNfZXhuIChJbmNyLlZhci53YXRjaCB2YXIpIH5mOiguLi4pO1xuXG4gICAgICAgIEluY3Iuc3RhYmlsaXplICgpO1xuXG4gICAgICAgIEluY3IuVmFyLnJlcGxhY2UgdmFyIH5mOihmdW4gbWFwIC0+IE1hcC5hZGRfZXhuIG1hcCBcImhpXCIgNSk7XG4gICAgICAgIEluY3IuVmFyLnJlcGxhY2UgdmFyIH5mOihmdW4gbWFwIC0+IE1hcC5zZXQgbWFwIFwiaGlcIiAxMCk7XG4gICAgICAgIEluY3IuVmFyLnJlcGxhY2UgdmFyIH5mOihmdW4gbWFwIC0+IE1hcC5yZW1vdmUgbWFwIFwiaGlcIik7XG4gICAgICAgIEluY3Iuc3RhYmlsaXplICgpO1xuICAgICAgXX1cblxuICAgICAgd29uJ3QgcmVzdWx0IGluIGFueSBjYWxscyB0byBbZl0sIGJlY2F1c2UgdGhlIG1hcCBjb250ZW50cyBkaWRuJ3QgY2hhbmdlIFxuICAgICAgZnJvbSBvbmUgc3RhYmlsaXphdGlvbiB0byBhbm90aGVyLlxuXG4gICAgICBbb2JzZXJ2ZV9jaGFuZ2VzX2V4bl0gbXVzdCBvbmx5IGJlIGNhbGxlZCBmcm9tIHRoZSB0b3AtbGV2ZWwgaW5jcmVtZW50YWwgXG4gICAgICBzY29wZS4gIEluIHByYWN0aWNlIHRoaXMgbWVhbnMgdGhhdCBpdCBtdXN0IG5vdCBiZSBpbnNpZGUgb2YgYW4gaW5jcmVtZW50YWxcbiAgICAgIGJpbmQsIG9yIGEgY2FsbCB0byBbSW5jcmVtZW50YWwuU2NvcGUud2l0aGluXS4gIElmIG5vdCBpbnZva2VkIGF0IHRvcC1sZXZlbCxcbiAgICAgIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHJhaXNlZCwgaXJyZXZlcnNpYmx5IGRlc3Ryb3lpbmcgeW91ciBpbmNyZW1lbnRhbCB1bml2ZXJzZS4gKilcbiAgdmFsIG9ic2VydmVfY2hhbmdlc19leG5cbiAgICA6ICA/ZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoKCdrLCAndiwgJ2NtcCkgTWFwLnQsIF8pIEluY3JlbWVudGFsLnRcbiAgICAtPiBmOigoJ2ssICd2KSBNYXAuU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBbKCdrLCAndikgTG9va3VwLnRdIHByb3ZpZGVzIGEgd2F5IHRvIGxvb2t1cCBrZXlzIGluIGEgbWFwIHdoaWNoIHVzZXMgc3ltbWV0cmljXG4gICAgICBkaWZmcyB0byB0cmlnZ2VyIHVwZGF0ZXMgb2YgdGhlIGxvb2t1cHMuXG5cbiAgICAgIFRoZSBjb21wbGV4aXR5IG9mIGFuIHVwZGF0ZSBkZXBlbmRzIG9uOlxuICAgICAgLSBbbl06IHRoZSBudW1iZXIgb2Yga2V5cyBpbiB0aGUgbGFyZ2VyIG9mIHRoZSBvbGQvdXBkYXRlZCBpbnB1dCBtYXBcbiAgICAgIC0gW2tdOiB0aGUgbnVtYmVyIG9mIGxvb2t1cCBub2RlcyBjcmVhdGVkIHVzaW5nIFtmaW5kXVxuICAgICAgLSBbbV06IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHN5bWRpZmYgb2YgdGhlIG1hcHNcbiAgICAgIC0gW3N5bWRpZmYobildOiB0aGUgY29zdCBvZiBwZXJmb3JtaW5nIHRoZSBzeW1kaWZmIG9uIHRoZSBtYXAgKG0gPD0gc3ltZGlmZihuKSA8PSBuKVxuXG4gICAgICBFYWNoIHVwZGF0ZSBzaG91bGQgY29zdCBbTyhzeW1kaWZmKG4pICsgbSAqIGxvZyBrKV0sIHNvIHRoaXMgd2lsbCBiZSBlZmZpY2llbnQgd2hlblxuICAgICAgdGhlcmUgYXJlIGEgbG90IG9mIGxvb2t1cHMgKGNsb3NlIHRvIG4pIGludG8gYSBtYXAgd2hpY2ggY2FuIGJlIGVmZmljaWVudGx5XG4gICAgICBzeW1kaWZmZWQgKGFuZCB0aGVyZWZvcmUgaGFzIGEgc21hbGwgbnVtYmVyIG9mIGNoYW5nZXMgYWxzbykuIFRoZSBjb3N0IG9mIHVwZGF0aW5nXG4gICAgICB3aGVuIHBlcmZvcm1pbmcgdGhlIHNhbWUgbG9va3VwcyBieSBtZWFucyBvZiBbSW5jci5tYXAgfmY6KGZ1biBtIC0+IE1hcC5maW5kIG0ga2V5KV1cbiAgICAgIGlzIFtPKGsgKiBsb2cgbildLiAqKVxuICBtb2R1bGUgTG9va3VwIDogc2lnXG4gICAgdHlwZSAoJ2ssICd2LCAnY21wLCAndykgdFxuXG4gICAgKCoqIENyZWF0ZSB0aGUgbG9va3VwIHN0cnVjdHVyZSBvbiBhbiBpbmNyZW1lbnRhbCBtYXAuICopXG4gICAgdmFsIGNyZWF0ZVxuICAgICAgOiAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgICAgLT4gP2RhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgICAtPiAoKCdrLCAndiwgJ2NtcCkgTWFwLnQsICd3KSBJbmNyZW1lbnRhbC50XG4gICAgICAtPiBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoJ2ssICd2LCAnY21wLCAndykgdFxuXG4gICAgKCoqIENyZWF0ZSBhIG5vZGUgd2hpY2ggcGVyZm9ybXMgW01hcC5maW5kXSBvbiB0aGUgaW5wdXQgbWFwLlxuXG4gICAgICAgIFtmaW5kIChjcmVhdGUgaW5jcl9tYXApIGtleV0gc2hvdWxkIGJlIGVxdWl2YWxlbnQgdG8gW0luY3IubWFwIH5mOihmdW4gbSAtPlxuICAgICAgICBNYXAuZmluZCBtIGtleSkgaW5jcl9tYXBdLCBidXQgd2hlbiB5b3UgY2FsbCBbZmluZF0gbWFueSB0aW1lcyBmb3IgYSBzaW5nbGVcbiAgICAgICAgW2NyZWF0ZV0gdGhlIG5vZGVzIHNob3VsZCB1cGRhdGUgbW9yZSBlZmZpY2llbnRseSBpbiBzdGFiaWxpc2F0aW9uIHdoZW4gW2luY3JfbWFwXVxuICAgICAgICBjaGFuZ2VzIGluIGEgd2F5IHdoaWNoIGNhbiBiZSBlZmZpY2llbnRseSBkaWZmZWQuXG5cbiAgICAgICAgVGhpcyB3aWxsIHJlLXVzZSBleGlzdGluZyBub2RlcyB3aGVuIGl0IGNhbiwgYnV0IHdpbGwgbm90IGFsd2F5cyBkbyBzby5cbiAgICAqKVxuICAgIHZhbCBmaW5kIDogKCdrLCAndiwgXywgJ3cpIHQgLT4gJ2sgLT4gKCd2IG9wdGlvbiwgJ3cpIEluY3JlbWVudGFsLnRcblxuICAgICgqKiBBIGNvbnZlbmllbnQgd2F5IHRvIHJlZmVyIHRvIHRoZSB0eXBlIGZvciBhIGdpdmVuIGtleS4gKilcbiAgICBtb2R1bGUgTSAoSyA6IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZCkgOiBzaWdcbiAgICAgIHR5cGUgbm9ucmVjICgndiwgJ3cpIHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MsICd3KSB0XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgRm9yX2RlYnVnIDogc2lnXG4gICAgICB2YWwgc2V4cF9vZl90IDogKCdrIC0+IFNleHAudCkgLT4gKCd2IC0+IFNleHAudCkgLT4gKCdrLCAndiwgJ2NtcCwgXykgdCAtPiBTZXhwLnRcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIEZvcl90ZXN0aW5nIDogc2lnXG4gICAgdmFsIGZpbmRfa2V5X3JhbmdlX2xpbmVhclxuICAgICAgOiAgZnJvbTppbnRcbiAgICAgIC0+IHRvXzppbnRcbiAgICAgIC0+ICgnYSwgJ2IsICdjKSBCYXNlLk1hcC50XG4gICAgICAtPiAoJ2EgKiAnYSBvcHRpb24pIG9wdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTX2dlbiA9IFNfZ2VuXG5cbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgc3RhdGVfd2l0bmVzc1xuXG4gICAgaW5jbHVkZVxuICAgICAgU19nZW5cbiAgICAgICAgd2l0aCB0eXBlICdhIEluY3IudCA9ICgnYSwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgICAgYW5kIHR5cGUgJ2EgSW5jci5DdXRvZmYudCA9ICdhIEluY3JlbWVudGFsLkN1dG9mZi50XG4gICAgICAgICBhbmQgdHlwZSAoJ2ssICd2LCAnY21wKSBMb29rdXAudCA9ICgnaywgJ3YsICdjbXAsIHN0YXRlX3dpdG5lc3MpIExvb2t1cC50XG4gIGVuZFxuXG4gIG1vZHVsZSBNYWtlIChJbmNyIDogSW5jcmVtZW50YWwuUykgOlxuICAgIFMgd2l0aCB0eXBlIHN0YXRlX3dpdG5lc3MgOj0gSW5jci5zdGF0ZV93aXRuZXNzIGFuZCBtb2R1bGUgSW5jciA6PSBJbmNyXG5lbmRcbiIsIm9wZW4hIENvcmVcbmluY2x1ZGUgSW5jcl9tYXBfaW50ZlxuXG5sZXQgbm9faW5zdHJ1bWVudGF0aW9uID0geyBJbnN0cnVtZW50YXRpb24uZiA9IChmdW4gZiAtPiBmICgpKSB9XG5cbigqKiBUaGlzIHR5cGUgbGV0cyB1cyBjYXB0dXJlIHRoZSBraW5kIG9mIG1hcCBmdW5jdGlvbiBiZWluZyBwZXJmb3JtZWQsIHNvIHdlIGNhbiB3aXRoXG4gICAgb25lIGltcGxlbWVudGF0aW9uIHBlcmZvcm0gbWFwIGFuZCBmaWx0ZXItbWFwIG9wZXJhdGlvbnMuXG5cbiAgICBIZXJlLCBbJ2lucHV0X2RhdGFdIGlzIHRoZSB0eXBlIG9mIGRhdGEgaW4gdGhlIGlucHV0IG1hcCwgWydvdXRwdXRfZGF0YV0gaXMgdGhlIHR5cGVcbiAgICBvZiBkYXRhIGluIHRoZSBvdXRwdXQgbWFwLCBhbmQgWydmX291dHB1dF0gaXMgdGhlIHJldHVybiB0eXBlIG9mIHRoZSBbfmZdIGZ1bmN0aW9uXG4gICAgcGFzc2VkIHRvIHRoZSBtYXBwaW5nIGZ1bmN0aW9uLiAqKVxubW9kdWxlIE1hcF90eXBlID0gc3RydWN0XG4gIHR5cGUgKCdpbnB1dF9kYXRhLCAnb3V0cHV0X2RhdGEsICdmX291dHB1dCkgdCA9XG4gICAgfCBNYXAgOiAoJ2lucHV0X2RhdGEsICdvdXRwdXRfZGF0YSwgJ291dHB1dF9kYXRhKSB0XG4gICAgfCBGaWx0ZXJfbWFwIDogKCdpbnB1dF9kYXRhLCAnb3V0cHV0X2RhdGEsICdvdXRwdXRfZGF0YSBvcHRpb24pIHRcblxuICAoKiBUaGUgZXh0cmEgdHlwZSB2YXJpYWJsZSAnYSBpcyB0byBhbGxvdyBpbiBmdXR1cmU6XG4gICAgIHwgRmlsdGVyIDogKCdvdXRwdXRfZGF0YSwgJ291dHB1dF9kYXRhLCBib29sKSB0ICopXG5lbmRcblxubW9kdWxlIEdlbmVyaWMgPSBzdHJ1Y3RcbiAgbGV0IHdpdGhfb2xkIH5pbnN0cnVtZW50YXRpb24gaSB+ZiA9XG4gICAgbGV0IG9wZW4gSW5jcmVtZW50YWwuTGV0X3N5bnRheCBpblxuICAgIGxldCBvbGQgPSByZWYgTm9uZSBpblxuICAgIGxldCVtYXAgYSA9IGkgaW5cbiAgICBpbnN0cnVtZW50YXRpb24uSW5zdHJ1bWVudGF0aW9uLmYgKGZ1biAoKSAtPlxuICAgICAgbGV0IGIgPSBmIH5vbGQ6IW9sZCBhIGluXG4gICAgICBvbGQgOj0gU29tZSAoYSwgYik7XG4gICAgICBiKVxuICA7O1xuXG4gIGxldCBjdXRvZmYgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pIG1hcCB+Y3V0b2ZmID1cbiAgICBsZXQgZGF0YV9lcXVhbCBvbGRfdmFsdWUgbmV3X3ZhbHVlID1cbiAgICAgIEluY3JlbWVudGFsLkN1dG9mZi5zaG91bGRfY3V0b2ZmIGN1dG9mZiB+b2xkX3ZhbHVlIH5uZXdfdmFsdWVcbiAgICBpblxuICAgIHdpdGhfb2xkIH5pbnN0cnVtZW50YXRpb24gbWFwIH5mOihmdW4gfm9sZCBjdXIgLT5cbiAgICAgIG1hdGNoIG9sZCB3aXRoXG4gICAgICB8IE5vbmUgLT4gY3VyXG4gICAgICB8IFNvbWUgKF9vbGRfaW4sIG9sZCkgLT5cbiAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmYgfmRhdGFfZXF1YWwgfmluaXQ6b2xkIG9sZCBjdXIgfmY6KGZ1biBhY2MgKGtleSwgY2hhbmdlKSAtPlxuICAgICAgICAgIG1hdGNoIGNoYW5nZSB3aXRoXG4gICAgICAgICAgfCBgTGVmdCBfb2xkIC0+IE1hcC5yZW1vdmUgYWNjIGtleVxuICAgICAgICAgIHwgYFJpZ2h0IG5ld18gLT4gTWFwLmFkZF9leG4gYWNjIH5rZXkgfmRhdGE6bmV3X1xuICAgICAgICAgIHwgYFVuZXF1YWwgKF9vbGQsIG5ld192YWx1ZSkgLT4gTWFwLnNldCBhY2MgfmtleSB+ZGF0YTpuZXdfdmFsdWUpKVxuICA7O1xuXG4gIGxldCB1bm9yZGVyZWRfZm9sZFxuICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgID91cGRhdGVcbiAgICA/c3BlY2lhbGl6ZWRfaW5pdGlhbFxuICAgID8oZmluYWxpemUgPSBGbi5pZClcbiAgICA/KHJldmVydF90b19pbml0X3doZW5fZW1wdHkgPSBmYWxzZSlcbiAgICBtYXBcbiAgICB+aW5pdFxuICAgIH5hZGRcbiAgICB+cmVtb3ZlXG4gICAgPVxuICAgIGxldCB1cGRhdGUgPVxuICAgICAgbGV0IGRlZmF1bHQgfmtleSB+b2xkX2RhdGEgfm5ld19kYXRhIGFjYyA9XG4gICAgICAgIGFkZCB+a2V5IH5kYXRhOm5ld19kYXRhIChyZW1vdmUgfmtleSB+ZGF0YTpvbGRfZGF0YSBhY2MpXG4gICAgICBpblxuICAgICAgT3B0aW9uLnZhbHVlIHVwZGF0ZSB+ZGVmYXVsdFxuICAgIGluXG4gICAgd2l0aF9vbGQgfmluc3RydW1lbnRhdGlvbiBtYXAgfmY6KGZ1biB+b2xkIG5ld19pbiAtPlxuICAgICAgbGV0IGFjYyA9XG4gICAgICAgIG1hdGNoIG9sZCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIChtYXRjaCBzcGVjaWFsaXplZF9pbml0aWFsIHdpdGhcbiAgICAgICAgICAgfCBOb25lIC0+IE1hcC5mb2xkIH5pbml0IH5mOmFkZCBuZXdfaW5cbiAgICAgICAgICAgfCBTb21lIGluaXRpYWwgLT4gaW5pdGlhbCB+aW5pdCBuZXdfaW4pXG4gICAgICAgIHwgU29tZSAob2xkX2luLCBvbGRfb3V0KSAtPlxuICAgICAgICAgIGlmIHJldmVydF90b19pbml0X3doZW5fZW1wdHkgJiYgTWFwLmxlbmd0aCBuZXdfaW4gPSAwXG4gICAgICAgICAgdGhlbiBpbml0XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgfmluaXQ6b2xkX291dFxuICAgICAgICAgICAgICBvbGRfaW5cbiAgICAgICAgICAgICAgbmV3X2luXG4gICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgIH5mOihmdW4gYWNjIChrZXksIGNoYW5nZSkgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlIHdpdGhcbiAgICAgICAgICAgICAgfCBgTGVmdCBvbGQgLT4gcmVtb3ZlIH5rZXkgfmRhdGE6b2xkIGFjY1xuICAgICAgICAgICAgICB8IGBSaWdodCBuZXdfIC0+IGFkZCB+a2V5IH5kYXRhOm5ld18gYWNjXG4gICAgICAgICAgICAgIHwgYFVuZXF1YWwgKG9sZCwgbmV3XykgLT4gdXBkYXRlIH5rZXkgfm9sZF9kYXRhOm9sZCB+bmV3X2RhdGE6bmV3XyBhY2MpXG4gICAgICBpblxuICAgICAgZmluYWxpemUgYWNjKVxuICA7O1xuXG4gIGxldCB1bm9yZGVyZWRfZm9sZF9uZXN0ZWRfbWFwc1xuICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgID9yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5XG4gICAgP3VwZGF0ZVxuICAgIGluY3JfbWFwXG4gICAgfmluaXRcbiAgICB+YWRkXG4gICAgfnJlbW92ZVxuICAgID1cbiAgICBsZXQgdXBkYXRlID1cbiAgICAgIG1hdGNoIHVwZGF0ZSB3aXRoXG4gICAgICB8IFNvbWUgdXBkYXRlIC0+IHVwZGF0ZVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIGZ1biB+b3V0ZXJfa2V5IH5pbm5lcl9rZXkgfm9sZF9kYXRhIH5uZXdfZGF0YSBhY2MgLT5cbiAgICAgICAgICBhZGRcbiAgICAgICAgICAgIH5vdXRlcl9rZXlcbiAgICAgICAgICAgIH5pbm5lcl9rZXlcbiAgICAgICAgICAgIH5kYXRhOm5ld19kYXRhXG4gICAgICAgICAgICAocmVtb3ZlIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YTpvbGRfZGF0YSBhY2MpXG4gICAgaW5cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgaW5jcl9tYXBcbiAgICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICAgID9yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5XG4gICAgICB+aW5pdFxuICAgICAgfnVwZGF0ZTooZnVuIH5rZXk6b3V0ZXJfa2V5IH5vbGRfZGF0YTpvbGRfaW5uZXJfbWFwIH5uZXdfZGF0YTpuZXdfaW5uZXJfbWFwIGFjYyAtPlxuICAgICAgICAoTWFwLmZvbGRfc3ltbWV0cmljX2RpZmYgb2xkX2lubmVyX21hcCBuZXdfaW5uZXJfbWFwIH5kYXRhX2VxdWFsKVxuICAgICAgICAgIH5pbml0OmFjY1xuICAgICAgICAgIH5mOihmdW4gYWNjIChpbm5lcl9rZXksIGRpZmYpIC0+XG4gICAgICAgICAgbWF0Y2ggZGlmZiB3aXRoXG4gICAgICAgICAgfCBgTGVmdCBkYXRhX3JlbW92ZWQgLT4gcmVtb3ZlIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YTpkYXRhX3JlbW92ZWQgYWNjXG4gICAgICAgICAgfCBgUmlnaHQgZGF0YV9hZGRlZCAtPiBhZGQgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhOmRhdGFfYWRkZWQgYWNjXG4gICAgICAgICAgfCBgVW5lcXVhbCAob2xkX2RhdGEsIG5ld19kYXRhKSAtPlxuICAgICAgICAgICAgdXBkYXRlIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+b2xkX2RhdGEgfm5ld19kYXRhIGFjYykgW0Bub250YWlsXSlcbiAgICAgIH5hZGQ6KGZ1biB+a2V5Om91dGVyX2tleSB+ZGF0YTppbm5lcl9tYXAgYWNjIC0+XG4gICAgICAgIE1hcC5mb2xkIGlubmVyX21hcCB+aW5pdDphY2MgfmY6KGZ1biB+a2V5OmlubmVyX2tleSB+ZGF0YSBhY2MgLT5cbiAgICAgICAgICBhZGQgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhIGFjYykpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleTpvdXRlcl9rZXkgfmRhdGE6aW5uZXJfbWFwIGFjYyAtPlxuICAgICAgICBNYXAuZm9sZCBpbm5lcl9tYXAgfmluaXQ6YWNjIH5mOihmdW4gfmtleTppbm5lcl9rZXkgfmRhdGEgYWNjIC0+XG4gICAgICAgICAgcmVtb3ZlIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YSBhY2MpKVxuICA7O1xuXG4gIGxldCB3aXRoX2NvbXBhcmF0b3InIGdldF9jb21wYXJhdG9yIHggZiA9XG4gICAgSW5jcmVtZW50YWwuYmluZCAoSW5jcmVtZW50YWwuZnJlZXplIChJbmNyZW1lbnRhbC5tYXAgeCB+ZjpnZXRfY29tcGFyYXRvcikpIH5mXG4gIDs7XG5cbiAgKCoqIENhcHR1cmVzIHRoZSBjb21wYXJhdG9yICh3aGljaCBjYW4ndCBjaGFuZ2UgYW55d2F5LCBzaW5jZSB0aGUgdHlwZSBkZXRlcm1pbmVzIHRoZVxuICAgICAgY29tcGFyYXRvcikgYnkgZnJlZXppbmcgdGhlIGNvcnJlc3BvbmRpbmcgbWFwLiAgTm90ZSB0aGF0IGJ5IGZpcnN0IHVzaW5nIEluY3JlbWVudGFsLm1hcCB0b1xuICAgICAgZ2V0IHRoZSBjb21wYXJhdG9yIG91dCBvZiB0aGUgbWFwLCB3ZSBhbGxvdyB0aGUgaW5pdGlhbCBtYXAgaXRzZWxmIHRvIGJlIGdhcmJhZ2VcbiAgICAgIGNvbGxlY3RlZCAqKVxuICBsZXQgd2l0aF9jb21wYXJhdG9yIG1hcCBmID0gd2l0aF9jb21wYXJhdG9yJyBNYXAuY29tcGFyYXRvciBtYXAgZlxuXG4gIGxldCBvZl9zZXQgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pIHNldCA9XG4gICAgd2l0aF9jb21wYXJhdG9yJyBTZXQuY29tcGFyYXRvciBzZXQgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICBsZXQgb2xkX2lucHV0ID0gcmVmIChTZXQuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcikgaW5cbiAgICAgIGxldCBvbGRfb3V0cHV0ID0gcmVmIChNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcikgaW5cbiAgICAgIEluY3JlbWVudGFsLm1hcCBzZXQgfmY6KGZ1biBuZXdfaW5wdXQgLT5cbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uLkluc3RydW1lbnRhdGlvbi5mIChmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgbmV3X291dHB1dCA9XG4gICAgICAgICAgICBTZXF1ZW5jZS5mb2xkXG4gICAgICAgICAgICAgIChTZXQuc3ltbWV0cmljX2RpZmYgIW9sZF9pbnB1dCBuZXdfaW5wdXQpXG4gICAgICAgICAgICAgIH5pbml0OiFvbGRfb3V0cHV0XG4gICAgICAgICAgICAgIH5mOihmdW4gb3V0cHV0IC0+IGZ1bmN0aW9uXG4gICAgICAgICAgICAgIHwgRmlyc3QgayAtPiBNYXAucmVtb3ZlIG91dHB1dCBrXG4gICAgICAgICAgICAgIHwgU2Vjb25kIGsgLT4gTWFwLmFkZF9leG4gb3V0cHV0IH5rZXk6ayB+ZGF0YTooKSlcbiAgICAgICAgICBpblxuICAgICAgICAgIG9sZF9pbnB1dCA6PSBuZXdfaW5wdXQ7XG4gICAgICAgICAgb2xkX291dHB1dCA6PSBuZXdfb3V0cHV0O1xuICAgICAgICAgIG5ld19vdXRwdXQpKSlcbiAgOztcblxuICBsZXQgZ2VuZXJpY19tYXBpXG4gICAgKHR5cGUgaW5wdXRfZGF0YSBvdXRwdXRfZGF0YSBmX291dHB1dCBzdGF0ZV93aXRuZXNzKVxuICAgICh3aXRuZXNzIDogKGlucHV0X2RhdGEsIG91dHB1dF9kYXRhLCBmX291dHB1dCkgTWFwX3R5cGUudClcbiAgICB+aW5zdHJ1bWVudGF0aW9uXG4gICAgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbClcbiAgICAobWFwIDogKCgna2V5LCBpbnB1dF9kYXRhLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICB+KGYgOiBrZXk6J2tleSAtPiBkYXRhOmlucHV0X2RhdGEgLT4gZl9vdXRwdXQpXG4gICAgPVxuICAgIHdpdGhfb2xkIH5pbnN0cnVtZW50YXRpb24gbWFwIH5mOihmdW4gfm9sZCBpbnB1dCAtPlxuICAgICAgbWF0Y2ggb2xkLCBNYXAubGVuZ3RoIGlucHV0IHdpdGhcbiAgICAgIHwgXywgMCB8IE5vbmUsIF8gLT5cbiAgICAgICAgKG1hdGNoIHdpdG5lc3Mgd2l0aFxuICAgICAgICAgfCBNYXBfdHlwZS5NYXAgLT4gKE1hcC5tYXBpIGlucHV0IH5mIDogKCdrZXksIG91dHB1dF9kYXRhLCAnY21wKSBNYXAudClcbiAgICAgICAgIHwgTWFwX3R5cGUuRmlsdGVyX21hcCAtPiBNYXAuZmlsdGVyX21hcGkgaW5wdXQgfmYpXG4gICAgICB8IFNvbWUgKG9sZF9pbnB1dCwgb2xkX291dHB1dCksIF8gLT5cbiAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICBvbGRfaW5wdXRcbiAgICAgICAgICBpbnB1dFxuICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgfmluaXQ6b2xkX291dHB1dFxuICAgICAgICAgIH5mOihmdW4gb3V0cHV0IChrZXksIGNoYW5nZSkgLT5cbiAgICAgICAgICBtYXRjaCBjaGFuZ2Ugd2l0aFxuICAgICAgICAgIHwgYExlZnQgXyAtPiBNYXAucmVtb3ZlIG91dHB1dCBrZXlcbiAgICAgICAgICB8IGBSaWdodCBuZXdfZGF0YSB8IGBVbmVxdWFsIChfLCBuZXdfZGF0YSkgLT5cbiAgICAgICAgICAgIGxldCByZXMgPSBmIH5rZXkgfmRhdGE6bmV3X2RhdGEgaW5cbiAgICAgICAgICAgIChtYXRjaCB3aXRuZXNzIHdpdGhcbiAgICAgICAgICAgICB8IE1hcF90eXBlLk1hcCAtPiBNYXAuc2V0IG91dHB1dCB+a2V5IH5kYXRhOnJlc1xuICAgICAgICAgICAgIHwgTWFwX3R5cGUuRmlsdGVyX21hcCAtPlxuICAgICAgICAgICAgICAgKG1hdGNoIHJlcyB3aXRoXG4gICAgICAgICAgICAgICAgfCBOb25lIC0+IE1hcC5yZW1vdmUgb3V0cHV0IGtleVxuICAgICAgICAgICAgICAgIHwgU29tZSBvdXRwdXRfZGF0YSAtPiBNYXAuc2V0IG91dHB1dCB+a2V5IH5kYXRhOm91dHB1dF9kYXRhKSkpKVxuICA7O1xuXG4gIGxldCBtYXBpID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKSA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIGdlbmVyaWNfbWFwaSBNYXAgfmluc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBtYXAgfmZcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGkgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgZ2VuZXJpY19tYXBpIEZpbHRlcl9tYXAgfmluc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBtYXAgfmZcbiAgOztcblxuICBsZXQgbWFwID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICBtYXBpID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgbWFwIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgZmlsdGVyX21hcGkgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBtYXAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCB3aXRoX29sZDIgfmluc3RydW1lbnRhdGlvbiBpMSBpMiB+ZiA9XG4gICAgbGV0IG9sZCA9IHJlZiBOb25lIGluXG4gICAgSW5jcmVtZW50YWwubWFwMiBpMSBpMiB+ZjooZnVuIGExIGEyIC0+XG4gICAgICBpbnN0cnVtZW50YXRpb24uSW5zdHJ1bWVudGF0aW9uLmYgKGZ1biAoKSAtPlxuICAgICAgICBsZXQgYiA9IGYgfm9sZDohb2xkIGExIGEyIGluXG4gICAgICAgIG9sZCA6PSBTb21lIChhMSwgYTIsIGIpO1xuICAgICAgICBiKSlcbiAgOztcblxuICBsZXQgdW5vcmRlcmVkX2ZvbGRfd2l0aF9leHRyYVxuICAgID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKVxuICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgPyhleHRyYV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgP3VwZGF0ZVxuICAgID9zcGVjaWFsaXplZF9pbml0aWFsXG4gICAgPyhmaW5hbGl6ZSA9IEZuLmlkKVxuICAgID8ocmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eSA9IGZhbHNlKVxuICAgIG1hcFxuICAgIGV4dHJhXG4gICAgfmluaXRcbiAgICB+YWRkXG4gICAgfnJlbW92ZVxuICAgIH5leHRyYV9jaGFuZ2VkXG4gICAgPVxuICAgIGxldCB1cGRhdGUgPVxuICAgICAgbGV0IGRlZmF1bHQgfmtleSB+b2xkX2RhdGEgfm5ld19kYXRhIGFjYyBleHRyYSA9XG4gICAgICAgIGFkZCB+a2V5IH5kYXRhOm5ld19kYXRhIChyZW1vdmUgfmtleSB+ZGF0YTpvbGRfZGF0YSBhY2MgZXh0cmEpIGV4dHJhXG4gICAgICBpblxuICAgICAgT3B0aW9uLnZhbHVlIHVwZGF0ZSB+ZGVmYXVsdFxuICAgIGluXG4gICAgd2l0aF9vbGQyIH5pbnN0cnVtZW50YXRpb24gbWFwIGV4dHJhIH5mOihmdW4gfm9sZCBuZXdfaW4gbmV3X2V4dHJhIC0+XG4gICAgICBsZXQgYWNjID1cbiAgICAgICAgbWF0Y2ggb2xkIHdpdGhcbiAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgKG1hdGNoIHNwZWNpYWxpemVkX2luaXRpYWwgd2l0aFxuICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICBNYXAuZm9sZCBuZXdfaW4gfmluaXQgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBhZGQgfmtleSB+ZGF0YSBhY2MgbmV3X2V4dHJhKVxuICAgICAgICAgICB8IFNvbWUgaW5pdGlhbCAtPiBpbml0aWFsIH5pbml0IG5ld19pbiBuZXdfZXh0cmEpXG4gICAgICAgIHwgU29tZSAob2xkX2luLCBvbGRfZXh0cmEsIG9sZF9vdXQpIC0+XG4gICAgICAgICAgbGV0IGFjYyA9XG4gICAgICAgICAgICBpZiBleHRyYV9lcXVhbCBvbGRfZXh0cmEgbmV3X2V4dHJhXG4gICAgICAgICAgICB0aGVuIG9sZF9vdXRcbiAgICAgICAgICAgIGVsc2UgZXh0cmFfY2hhbmdlZCB+b2xkX2V4dHJhIH5uZXdfZXh0cmEgfmlucHV0Om9sZF9pbiBvbGRfb3V0XG4gICAgICAgICAgaW5cbiAgICAgICAgICBpZiByZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5ICYmIE1hcC5sZW5ndGggbmV3X2luID0gMFxuICAgICAgICAgIHRoZW4gaW5pdFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgIH5pbml0OmFjY1xuICAgICAgICAgICAgICBvbGRfaW5cbiAgICAgICAgICAgICAgbmV3X2luXG4gICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgIH5mOihmdW4gYWNjIChrZXksIGNoYW5nZSkgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlIHdpdGhcbiAgICAgICAgICAgICAgfCBgTGVmdCBvbGQgLT4gcmVtb3ZlIH5rZXkgfmRhdGE6b2xkIGFjYyBuZXdfZXh0cmFcbiAgICAgICAgICAgICAgfCBgUmlnaHQgbmV3XyAtPiBhZGQgfmtleSB+ZGF0YTpuZXdfIGFjYyBuZXdfZXh0cmFcbiAgICAgICAgICAgICAgfCBgVW5lcXVhbCAob2xkLCBuZXdfKSAtPlxuICAgICAgICAgICAgICAgIHVwZGF0ZSB+a2V5IH5vbGRfZGF0YTpvbGQgfm5ld19kYXRhOm5ld18gYWNjIG5ld19leHRyYSlcbiAgICAgIGluXG4gICAgICBmaW5hbGl6ZSBhY2MpXG4gIDs7XG5cbiAgbGV0IG1hcGlfY291bnRcbiAgICAodHlwZSBhIGNtcClcbiAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgIGlucHV0XG4gICAgfihjb21wYXJhdG9yIDogKG1vZHVsZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgPSBhIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcCkpXG4gICAgfmZcbiAgICA9XG4gICAgbGV0IG1vZHVsZSBNID0gKHZhbCBjb21wYXJhdG9yKSBpblxuICAgIGxldCBhZGQgbmV3X2tleSBhY2MgPVxuICAgICAgTWFwLnVwZGF0ZSBhY2MgbmV3X2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgfCBOb25lIC0+IDFcbiAgICAgICAgfCBTb21lIG4gLT4gbiArIDEpXG4gICAgaW5cbiAgICBsZXQgcmVtb3ZlIG5ld19rZXkgYWNjID1cbiAgICAgIE1hcC5jaGFuZ2UgYWNjIG5ld19rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSAxIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIG4gLT4gU29tZSAobiAtIDEpKVxuICAgIGluXG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICAgIH5kYXRhX2VxdWFsXG4gICAgICBpbnB1dFxuICAgICAgfmluaXQ6KE1hcC5lbXB0eSAobW9kdWxlIE0pKVxuICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGFkZCAoZiB+a2V5IH5kYXRhKSBhY2MpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gcmVtb3ZlIChmIH5rZXkgfmRhdGEpIGFjYylcbiAgICAgIH51cGRhdGU6KGZ1biB+a2V5IH5vbGRfZGF0YSB+bmV3X2RhdGEgYWNjIC0+XG4gICAgICAgIGxldCBwcmV2X2tleSA9IGYgfmtleSB+ZGF0YTpvbGRfZGF0YSBpblxuICAgICAgICBsZXQgbmV3X2tleSA9IGYgfmtleSB+ZGF0YTpuZXdfZGF0YSBpblxuICAgICAgICBpZiBNLmNvbXBhcmF0b3IuY29tcGFyZSBwcmV2X2tleSBuZXdfa2V5ID0gMFxuICAgICAgICB0aGVuIGFjY1xuICAgICAgICBlbHNlIGFjYyB8PiByZW1vdmUgcHJldl9rZXkgfD4gYWRkIG5ld19rZXkpXG4gIDs7XG5cbiAgbGV0IG1hcF9jb3VudCA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBtYXBpX2NvdW50ID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT5cbiAgICAgIGYgZGF0YSlcbiAgOztcblxuICBsZXQgbWluX2hlbHBlciBtYXAgPVxuICAgIG1hdGNoIE1hcC5taW5fZWx0IG1hcCB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgKG1pbiwgXykgLT4gU29tZSBtaW5cbiAgOztcblxuICBsZXQgbWF4X2hlbHBlciBtYXAgPVxuICAgIG1hdGNoIE1hcC5tYXhfZWx0IG1hcCB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgKG1heCwgXykgLT4gU29tZSBtYXhcbiAgOztcblxuICBsZXQgYm91bmRzX2hlbHBlciBtYXAgPVxuICAgIG1hdGNoIE1hcC5taW5fZWx0IG1hcCwgTWFwLm1heF9lbHQgbWFwIHdpdGhcbiAgICB8IE5vbmUsIE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSAobWluLCBfKSwgU29tZSAobWF4LCBfKSAtPiBTb21lIChtaW4sIG1heClcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIDs7XG5cbiAgbGV0IG1hcGlfbWluID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYgPVxuICAgIEluY3JlbWVudGFsLm1hcFxuICAgICAgfmY6bWluX2hlbHBlclxuICAgICAgKG1hcGlfY291bnQgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZilcbiAgOztcblxuICBsZXQgbWFwaV9tYXggP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgSW5jcmVtZW50YWwubWFwXG4gICAgICB+ZjptYXhfaGVscGVyXG4gICAgICAobWFwaV9jb3VudCA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mKVxuICA7O1xuXG4gIGxldCBtYXBpX2JvdW5kcyA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBJbmNyZW1lbnRhbC5tYXBcbiAgICAgIH5mOmJvdW5kc19oZWxwZXJcbiAgICAgIChtYXBpX2NvdW50ID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYpXG4gIDs7XG5cbiAgbGV0IG1hcF9taW4gP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgbWFwaV9taW4gP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPlxuICAgICAgZiBkYXRhKVxuICA7O1xuXG4gIGxldCBtYXBfbWF4ID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYgPVxuICAgIG1hcGlfbWF4ID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT5cbiAgICAgIGYgZGF0YSlcbiAgOztcblxuICBsZXQgbWluX3ZhbHVlID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgPVxuICAgIG1hcF9taW4gP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjpGbi5pZFxuICA7O1xuXG4gIGxldCBtYXhfdmFsdWUgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciA9XG4gICAgbWFwX21heCA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mOkZuLmlkXG4gIDs7XG5cbiAgbGV0IG1hcF9ib3VuZHMgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgbWFwaV9ib3VuZHMgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPlxuICAgICAgZiBkYXRhKVxuICA7O1xuXG4gIGxldCB2YWx1ZV9ib3VuZHMgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciA9XG4gICAgbWFwX2JvdW5kcyA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mOkZuLmlkXG4gIDs7XG5cbiAgbGV0IG1lcmdlX3NoYXJlZF9pbXBsXG4gICAgfm9sZFxuICAgIH5uZXdfbGVmdF9tYXBcbiAgICB+bmV3X3JpZ2h0X21hcFxuICAgIH5kYXRhX2VxdWFsX2xlZnRcbiAgICB+ZGF0YV9lcXVhbF9yaWdodFxuICAgIH5mXG4gICAgPVxuICAgIGxldCBjb21wYXJhdG9yID0gTWFwLmNvbXBhcmF0b3IgbmV3X2xlZnRfbWFwIGluXG4gICAgbGV0IG9sZF9sZWZ0X21hcCwgb2xkX3JpZ2h0X21hcCwgb2xkX291dHB1dCA9XG4gICAgICBtYXRjaCBvbGQgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIGxldCBlbXB0eSA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yIGluXG4gICAgICAgIGVtcHR5LCBlbXB0eSwgZW1wdHlcbiAgICAgIHwgU29tZSB4IC0+IHhcbiAgICBpblxuICAgIGxldCBhcHBseV9yaWdodCBvdXRwdXQgKGtleSwgZGlmZl9lbGVtZW50KSA9XG4gICAgICBmIH5vbGRfb3V0cHV0IH5rZXkgfm91dHB1dCB+ZGlmZl9lbGVtZW50OihgUmlnaHQgZGlmZl9lbGVtZW50KVxuICAgIGluXG4gICAgaWYgcGh5c19lcXVhbCBvbGRfbGVmdF9tYXAgbmV3X2xlZnRfbWFwXG4gICAgdGhlblxuICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgfmluaXQ6b2xkX291dHB1dFxuICAgICAgICBvbGRfcmlnaHRfbWFwXG4gICAgICAgIG5ld19yaWdodF9tYXBcbiAgICAgICAgfmRhdGFfZXF1YWw6ZGF0YV9lcXVhbF9yaWdodFxuICAgICAgICB+ZjphcHBseV9yaWdodCBbQG5vbnRhaWxdXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmlnaHRfZGlmZnMgPVxuICAgICAgICBNYXAuc3ltbWV0cmljX2RpZmYgb2xkX3JpZ2h0X21hcCBuZXdfcmlnaHRfbWFwIH5kYXRhX2VxdWFsOmRhdGFfZXF1YWxfcmlnaHRcbiAgICAgIGluXG4gICAgICBsZXQgb3V0cHV0LCByaWdodF9kaWZmcyA9XG4gICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgfmluaXQ6KG9sZF9vdXRwdXQsIFNlcXVlbmNlLm5leHQgcmlnaHRfZGlmZnMpXG4gICAgICAgICAgb2xkX2xlZnRfbWFwXG4gICAgICAgICAgbmV3X2xlZnRfbWFwXG4gICAgICAgICAgfmRhdGFfZXF1YWw6ZGF0YV9lcXVhbF9sZWZ0XG4gICAgICAgICAgfmY6KGZ1biAob3V0cHV0LCByaWdodF9kaWZmcykgKGxlZnRfa2V5LCBsZWZ0X2RpZmZfZWxlbWVudCkgLT5cbiAgICAgICAgICAgIGxldCByZWMgbG9vcFxuICAgICAgICAgICAgICBjb21wYXJlXG4gICAgICAgICAgICAgIH5vbGRfb3V0cHV0XG4gICAgICAgICAgICAgIH5vdXRwdXRcbiAgICAgICAgICAgICAgcmlnaHRfZGlmZnNcbiAgICAgICAgICAgICAgbGVmdF9rZXlcbiAgICAgICAgICAgICAgbGVmdF9kaWZmX2VsZW1lbnRcbiAgICAgICAgICAgICAgfmZcbiAgICAgICAgICAgICAgPVxuICAgICAgICAgICAgICBsZXRbQGlubGluZV0gYXBwbHlfbGVmdCBvdXRwdXQgPVxuICAgICAgICAgICAgICAgIGZcbiAgICAgICAgICAgICAgICAgIH5vbGRfb3V0cHV0XG4gICAgICAgICAgICAgICAgICB+a2V5OmxlZnRfa2V5XG4gICAgICAgICAgICAgICAgICB+b3V0cHV0XG4gICAgICAgICAgICAgICAgICB+ZGlmZl9lbGVtZW50OihgTGVmdCBsZWZ0X2RpZmZfZWxlbWVudClcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgbGV0W0BpbmxpbmVdIGFwcGx5X3JpZ2h0IG91dHB1dCAoa2V5LCBkaWZmX2VsZW1lbnQpID1cbiAgICAgICAgICAgICAgICBmIH5vbGRfb3V0cHV0IH5rZXkgfm91dHB1dCB+ZGlmZl9lbGVtZW50OihgUmlnaHQgZGlmZl9lbGVtZW50KVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBtYXRjaCByaWdodF9kaWZmcyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBhcHBseV9sZWZ0IG91dHB1dCwgcmlnaHRfZGlmZnNcbiAgICAgICAgICAgICAgfCBTb21lICgoKHJpZ2h0X2tleSwgcmlnaHRfZGlmZl9lbGVtZW50KSBhcyBoZCksIHRsKSAtPlxuICAgICAgICAgICAgICAgIChtYXRjaCBjb21wYXJlIGxlZnRfa2V5IHJpZ2h0X2tleSB3aXRoXG4gICAgICAgICAgICAgICAgIHwgMCAtPlxuICAgICAgICAgICAgICAgICAgICggZlxuICAgICAgICAgICAgICAgICAgICAgICB+b2xkX291dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICB+a2V5OmxlZnRfa2V5XG4gICAgICAgICAgICAgICAgICAgICAgIH5vdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgfmRpZmZfZWxlbWVudDooYEJvdGggKGxlZnRfZGlmZl9lbGVtZW50LCByaWdodF9kaWZmX2VsZW1lbnQpKVxuICAgICAgICAgICAgICAgICAgICwgU2VxdWVuY2UubmV4dCB0bCApXG4gICAgICAgICAgICAgICAgIHwgeCB3aGVuIHggPiAwIC0+XG4gICAgICAgICAgICAgICAgICAgKGxvb3AgW0B0YWlsY2FsbF0pXG4gICAgICAgICAgICAgICAgICAgICBjb21wYXJlXG4gICAgICAgICAgICAgICAgICAgICB+b2xkX291dHB1dFxuICAgICAgICAgICAgICAgICAgICAgfm91dHB1dDooYXBwbHlfcmlnaHQgb3V0cHV0IGhkKVxuICAgICAgICAgICAgICAgICAgICAgKFNlcXVlbmNlLm5leHQgdGwpXG4gICAgICAgICAgICAgICAgICAgICBsZWZ0X2tleVxuICAgICAgICAgICAgICAgICAgICAgbGVmdF9kaWZmX2VsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgIH5mXG4gICAgICAgICAgICAgICAgIHwgXyAtPiBhcHBseV9sZWZ0IG91dHB1dCwgcmlnaHRfZGlmZnMpXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbG9vcFxuICAgICAgICAgICAgICBjb21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICAgICAgICAgfm9sZF9vdXRwdXRcbiAgICAgICAgICAgICAgfm91dHB1dFxuICAgICAgICAgICAgICByaWdodF9kaWZmc1xuICAgICAgICAgICAgICBsZWZ0X2tleVxuICAgICAgICAgICAgICBsZWZ0X2RpZmZfZWxlbWVudFxuICAgICAgICAgICAgICB+ZiBbQG5vbnRhaWxdKVxuICAgICAgaW5cbiAgICAgIE9wdGlvbi52YWx1ZV9tYXAgcmlnaHRfZGlmZnMgfmRlZmF1bHQ6b3V0cHV0IH5mOihmdW4gKGhkLCB0bCkgLT5cbiAgICAgICAgU2VxdWVuY2UuZm9sZCB+aW5pdDooYXBwbHlfcmlnaHQgb3V0cHV0IGhkKSB0bCB+ZjphcHBseV9yaWdodCkgW0Bub250YWlsXSlcbiAgOztcblxuICBsZXQgbmV3X2RhdGFfZnJvbV9kaWZmX2VsZW1lbnQgPSBmdW5jdGlvblxuICAgIHwgYExlZnQgXyAtPiBOb25lXG4gICAgfCBgUmlnaHQgeCB8IGBVbmVxdWFsIChfLCB4KSAtPiBTb21lIHhcbiAgOztcblxuICBsZXQgbWVyZ2VcbiAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICA/KGRhdGFfZXF1YWxfbGVmdCA9IHBoeXNfZXF1YWwpXG4gICAgPyhkYXRhX2VxdWFsX3JpZ2h0ID0gcGh5c19lcXVhbClcbiAgICBsZWZ0X21hcFxuICAgIHJpZ2h0X21hcFxuICAgIH5mXG4gICAgPVxuICAgIHdpdGhfb2xkMlxuICAgICAgbGVmdF9tYXBcbiAgICAgIHJpZ2h0X21hcFxuICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgfmY6KGZ1biB+b2xkIG5ld19sZWZ0X21hcCBuZXdfcmlnaHRfbWFwIC0+XG4gICAgICBtZXJnZV9zaGFyZWRfaW1wbFxuICAgICAgICB+b2xkXG4gICAgICAgIH5uZXdfbGVmdF9tYXBcbiAgICAgICAgfm5ld19yaWdodF9tYXBcbiAgICAgICAgfmRhdGFfZXF1YWxfbGVmdFxuICAgICAgICB+ZGF0YV9lcXVhbF9yaWdodFxuICAgICAgICB+ZjooZnVuIH5vbGRfb3V0cHV0Ol8gfmtleSB+b3V0cHV0IH5kaWZmX2VsZW1lbnQgLT5cbiAgICAgICAgKCogVGhlc2UgdmFsdWVzIHJlcHJlc2VudCB3aGV0aGVyIHRoZXJlIGlzIGRhdGEgZm9yIHRoZSBnaXZlbiBrZXkgaW4gdGhlIG5ld1xuICAgICAgICAgICAgICAgaW5wdXQgaW4gdGhlIGxlZnQgYW5kIHJpZ2h0IG1hcC4gKilcbiAgICAgICAgbGV0IGxlZnRfZGF0YV9vcHQsIHJpZ2h0X2RhdGFfb3B0ID1cbiAgICAgICAgICBtYXRjaCBkaWZmX2VsZW1lbnQgd2l0aFxuICAgICAgICAgIHwgYEJvdGggKGxlZnRfZGlmZiwgcmlnaHRfZGlmZikgLT5cbiAgICAgICAgICAgIG5ld19kYXRhX2Zyb21fZGlmZl9lbGVtZW50IGxlZnRfZGlmZiwgbmV3X2RhdGFfZnJvbV9kaWZmX2VsZW1lbnQgcmlnaHRfZGlmZlxuICAgICAgICAgIHwgYExlZnQgbGVmdF9kaWZmIC0+XG4gICAgICAgICAgICBuZXdfZGF0YV9mcm9tX2RpZmZfZWxlbWVudCBsZWZ0X2RpZmYsIE1hcC5maW5kIG5ld19yaWdodF9tYXAga2V5XG4gICAgICAgICAgfCBgUmlnaHQgcmlnaHRfZGlmZiAtPlxuICAgICAgICAgICAgTWFwLmZpbmQgbmV3X2xlZnRfbWFwIGtleSwgbmV3X2RhdGFfZnJvbV9kaWZmX2VsZW1lbnQgcmlnaHRfZGlmZlxuICAgICAgICBpblxuICAgICAgICBsZXQgb3V0cHV0X2RhdGFfb3B0ID1cbiAgICAgICAgICBtYXRjaCBsZWZ0X2RhdGFfb3B0LCByaWdodF9kYXRhX29wdCB3aXRoXG4gICAgICAgICAgfCBOb25lLCBOb25lIC0+IE5vbmVcbiAgICAgICAgICB8IFNvbWUgeCwgTm9uZSAtPiBmIH5rZXkgKGBMZWZ0IHgpXG4gICAgICAgICAgfCBOb25lLCBTb21lIHkgLT4gZiB+a2V5IChgUmlnaHQgeSlcbiAgICAgICAgICB8IFNvbWUgeCwgU29tZSB5IC0+IGYgfmtleSAoYEJvdGggKHgsIHkpKVxuICAgICAgICBpblxuICAgICAgICBtYXRjaCBvdXRwdXRfZGF0YV9vcHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gTWFwLnJlbW92ZSBvdXRwdXQga2V5XG4gICAgICAgIHwgU29tZSBkYXRhIC0+IE1hcC5zZXQgb3V0cHV0IH5rZXkgfmRhdGEpKVxuICA7O1xuXG4gIGxldCBtZXJnZV9ib3RoX3NvbWVcbiAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICA/KGRhdGFfZXF1YWxfbGVmdCA9IHBoeXNfZXF1YWwpXG4gICAgPyhkYXRhX2VxdWFsX3JpZ2h0ID0gcGh5c19lcXVhbClcbiAgICA/KG91dF9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgbGVmdF9tYXBcbiAgICByaWdodF9tYXBcbiAgICB+ZlxuICAgID1cbiAgICB3aXRoX29sZDJcbiAgICAgIGxlZnRfbWFwXG4gICAgICByaWdodF9tYXBcbiAgICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICAgIH5mOihmdW4gfm9sZCBuZXdfbGVmdF9tYXAgbmV3X3JpZ2h0X21hcCAtPlxuICAgICAgbGV0IGNvbXBhcmF0b3IgPSBNYXAuY29tcGFyYXRvciBuZXdfbGVmdF9tYXAgaW5cbiAgICAgIGxldCBlbXB0eSA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yIGluXG4gICAgICBtYXRjaCBNYXAubGVuZ3RoIG5ld19sZWZ0X21hcCwgTWFwLmxlbmd0aCBuZXdfcmlnaHRfbWFwIHdpdGhcbiAgICAgICgqIEJlY2F1c2Ugd2Ugb25seSBjYXJlIGFib3V0IGtleXMgdGhhdCBhcmUgaW4gYm90aCBtYXBzLCBpZiBlaXRoZXIgbWFwIGlzXG4gICAgICAgICAgIGVtcHR5LCBiYWlsIGVhcmx5LiAqKVxuICAgICAgfCAwLCBfIHwgXywgMCAtPiBlbXB0eVxuICAgICAgfCBfIC0+XG4gICAgICAgIG1lcmdlX3NoYXJlZF9pbXBsXG4gICAgICAgICAgfm9sZFxuICAgICAgICAgIH5uZXdfbGVmdF9tYXBcbiAgICAgICAgICB+bmV3X3JpZ2h0X21hcFxuICAgICAgICAgIH5kYXRhX2VxdWFsX2xlZnRcbiAgICAgICAgICB+ZGF0YV9lcXVhbF9yaWdodFxuICAgICAgICAgIH5mOihmdW4gfm9sZF9vdXRwdXQgfmtleSB+b3V0cHV0IH5kaWZmX2VsZW1lbnQgLT5cbiAgICAgICAgICBsZXQgbGVmdF9hbmRfcmlnaHRfZGF0YV9vcHQgPVxuICAgICAgICAgICAgbGV0IG9wZW4gT3B0aW9uLkxldF9zeW50YXggaW5cbiAgICAgICAgICAgIG1hdGNoIGRpZmZfZWxlbWVudCB3aXRoXG4gICAgICAgICAgICB8IGBCb3RoIChsZWZ0X2RpZmYsIHJpZ2h0X2RpZmYpIC0+XG4gICAgICAgICAgICAgIGxldCViaW5kIGxlZnRfZGF0YSA9IG5ld19kYXRhX2Zyb21fZGlmZl9lbGVtZW50IGxlZnRfZGlmZiBpblxuICAgICAgICAgICAgICBsZXQlbWFwIHJpZ2h0X2RhdGEgPSBuZXdfZGF0YV9mcm9tX2RpZmZfZWxlbWVudCByaWdodF9kaWZmIGluXG4gICAgICAgICAgICAgIGxlZnRfZGF0YSwgcmlnaHRfZGF0YVxuICAgICAgICAgICAgfCBgTGVmdCBsZWZ0X2RpZmYgLT5cbiAgICAgICAgICAgICAgbGV0JWJpbmQgbGVmdF9kYXRhID0gbmV3X2RhdGFfZnJvbV9kaWZmX2VsZW1lbnQgbGVmdF9kaWZmIGluXG4gICAgICAgICAgICAgIGxldCVtYXAgcmlnaHRfZGF0YSA9IE1hcC5maW5kIG5ld19yaWdodF9tYXAga2V5IGluXG4gICAgICAgICAgICAgIGxlZnRfZGF0YSwgcmlnaHRfZGF0YVxuICAgICAgICAgICAgfCBgUmlnaHQgcmlnaHRfZGlmZiAtPlxuICAgICAgICAgICAgICAoKiBUaGlzIG1hdGNoIGFybSBiaW5kcyBbcmlnaHRfZGF0YV0gZmlyc3QgYmVjYXVzZSB0aGUgbWFwIGxvb2t1cFxuICAgICAgICAgICAgICAgICAgICAgaXMgc2xvd2VyIHRoYW4gY2FsbGluZyBbbmV3X2RhdGFfZnJvbV9kaWZmX2VsZW1lbnRdLiAqKVxuICAgICAgICAgICAgICBsZXQlYmluZCByaWdodF9kYXRhID0gbmV3X2RhdGFfZnJvbV9kaWZmX2VsZW1lbnQgcmlnaHRfZGlmZiBpblxuICAgICAgICAgICAgICBsZXQlbWFwIGxlZnRfZGF0YSA9IE1hcC5maW5kIG5ld19sZWZ0X21hcCBrZXkgaW5cbiAgICAgICAgICAgICAgbGVmdF9kYXRhLCByaWdodF9kYXRhXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoKiBsb29rIGZvciB0aGUgcHJldmlvdXNseSBjb21wdXRlZCB2YWx1ZSB0byBzZWUgaWYgd2UgYWN0dWFsbHkgbmVlZCB0b1xuICAgICAgICAgICAgICAgICBhZGQgb3IgcmVtb3ZlIHRoZSBrZXkuICopXG4gICAgICAgICAgbGV0IHByZXZfb3V0ID0gTWFwLmZpbmQgb2xkX291dHB1dCBrZXkgaW5cbiAgICAgICAgICBtYXRjaCBsZWZ0X2FuZF9yaWdodF9kYXRhX29wdCB3aXRoXG4gICAgICAgICAgfCBTb21lICh4LCB5KSAtPlxuICAgICAgICAgICAgbGV0IGRhdGEgPSBmIH5rZXkgeCB5IGluXG4gICAgICAgICAgICAobWF0Y2ggcHJldl9vdXQgd2l0aFxuICAgICAgICAgICAgICgqIGlmIHRoZSBuZXcgcmVzdWx0IGlzIHRoZSBzYW1lIGFzIHRoZSBvbGQsIGRvbid0IGNoYW5nZSB0aGUgbWFwICopXG4gICAgICAgICAgICAgfCBTb21lIHByZXZfb3V0IHdoZW4gb3V0X2VxdWFsIGRhdGEgcHJldl9vdXQgLT4gb3V0cHV0XG4gICAgICAgICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE1hcC5zZXQgb3V0cHV0IH5rZXkgfmRhdGEpXG4gICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAobWF0Y2ggcHJldl9vdXQgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiBvdXRwdXRcbiAgICAgICAgICAgICB8IFNvbWUgXyAtPiBNYXAucmVtb3ZlIG91dHB1dCBrZXkpKSlcbiAgOztcblxuICBsZXQgbWVyZ2VfZGlzam9pbnRcbiAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgIGxlZnRfbWFwXG4gICAgcmlnaHRfbWFwXG4gICAgPVxuICAgIHdpdGhfb2xkMlxuICAgICAgbGVmdF9tYXBcbiAgICAgIHJpZ2h0X21hcFxuICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgfmY6KGZ1biB+b2xkIG5ld19sZWZ0X21hcCBuZXdfcmlnaHRfbWFwIC0+XG4gICAgICBsZXQgY29tcGFyYXRvciA9IE1hcC5jb21wYXJhdG9yIG5ld19sZWZ0X21hcCBpblxuICAgICAgbGV0IGVtcHR5ID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICAgIGxldCBtZXJnZV9mcm9tX3NjcmF0Y2ggKCkgPVxuICAgICAgICBNYXAubWVyZ2Vfc2tld2VkIG5ld19sZWZ0X21hcCBuZXdfcmlnaHRfbWFwIH5jb21iaW5lOihmdW4gfmtleSBfIF8gLT5cbiAgICAgICAgICByYWlzZV9zXG4gICAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgICAgWyVoZXJlXVxuICAgICAgICAgICAgICAgIFwiSW5jcl9tYXAubWVyZ2VfZGlzam9pbnRcIlxuICAgICAgICAgICAgICAgIFwiY2FsbGVyIGhhcyBicm9rZW4gaW52YXJpYW50LCBhIGtleSBpcyBwcmVzZW50IGluIGJvdGggbWFwc1wiXG4gICAgICAgICAgICAgICAgfmtleTooY29tcGFyYXRvci5zZXhwX29mX3Qga2V5IDogU2V4cC50KV0pXG4gICAgICBpblxuICAgICAgbWF0Y2ggTWFwLmxlbmd0aCBuZXdfbGVmdF9tYXAsIE1hcC5sZW5ndGggbmV3X3JpZ2h0X21hcCB3aXRoXG4gICAgICB8IDAsIDAgLT4gZW1wdHlcbiAgICAgIHwgMCwgXyAtPlxuICAgICAgICAoKiBpZiB0aGUgbGVmdCBtYXAgaXMgZW1wdHksIHRoZSBcIm1lcmdlZFwiIHJlc3VsdCBpcyB0aGUgcmlnaHQgbWFwICopXG4gICAgICAgIG5ld19yaWdodF9tYXBcbiAgICAgIHwgXywgMCAtPlxuICAgICAgICAoKiBpZiB0aGUgcmlnaHQgbWFwIGlzIGVtcHR5LCB0aGUgXCJtZXJnZWRcIiByZXN1bHQgaXMgdGhlIGxlZnQgbWFwKilcbiAgICAgICAgbmV3X2xlZnRfbWFwXG4gICAgICB8IGwsIHIgd2hlbiBsIDwgSW50LmZsb29yX2xvZzIgciB8fCByIDwgSW50LmZsb29yX2xvZzIgbCAtPlxuICAgICAgICAoKiBJZiBvbmUgb2YgdGhlIG1hcHMgaXMgc21hbGwgZW5vdWdoIGluIGNvbXBhcmlzb24gdG8gdGhlIG90aGVyLFxuICAgICAgICAgICAgIFtNYXAubWVyZ2Vfc2tld2VkXSBpcyBsaWtlbHkgY2hlYXBlciB0aGFuIGNvbXB1dGluZyB0aGUgc3ltbWV0cmljIGRpZmYgb2YgYm90aCBtYXBzICopXG4gICAgICAgIG1lcmdlX2Zyb21fc2NyYXRjaCAoKVxuICAgICAgfCBfLCBfIC0+XG4gICAgICAgIChtYXRjaCBvbGQgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IG1lcmdlX2Zyb21fc2NyYXRjaCAoKVxuICAgICAgICAgfCBTb21lIChvbGRfbGVmdF9tYXAsIG9sZF9yaWdodF9tYXAsIG9sZF9yZXN1bHQpIC0+XG4gICAgICAgICAgIGxldCB3aXRoX2xlZnRfY2hhbmdlcyA9XG4gICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgIG9sZF9sZWZ0X21hcFxuICAgICAgICAgICAgICAgbmV3X2xlZnRfbWFwXG4gICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAgfmluaXQ6b2xkX3Jlc3VsdFxuICAgICAgICAgICAgICAgfmY6KGZ1biBhY2MgKGtleSwgZWx0KSAtPlxuICAgICAgICAgICAgICAgbWF0Y2ggZWx0IHdpdGhcbiAgICAgICAgICAgICAgIHwgYFJpZ2h0IGRhdGEgLT4gTWFwLnNldCBhY2MgfmtleSB+ZGF0YVxuICAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+IE1hcC5yZW1vdmUgYWNjIGtleVxuICAgICAgICAgICAgICAgfCBgVW5lcXVhbCAoX3ByZXYsIGN1cikgLT4gTWFwLnNldCBhY2MgfmtleSB+ZGF0YTpjdXIpXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgb2xkX3JpZ2h0X21hcFxuICAgICAgICAgICAgIG5ld19yaWdodF9tYXBcbiAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgIH5pbml0OndpdGhfbGVmdF9jaGFuZ2VzXG4gICAgICAgICAgICAgfmY6KGZ1biBhY2MgKGtleSwgZWx0KSAtPlxuICAgICAgICAgICAgIG1hdGNoIGVsdCB3aXRoXG4gICAgICAgICAgICAgfCBgUmlnaHQgZGF0YSAtPiBNYXAuc2V0IGFjYyB+a2V5IH5kYXRhXG4gICAgICAgICAgICAgfCBgTGVmdCBfIC0+XG4gICAgICAgICAgICAgICAoKiB0aGUga2V5IG1heSBoYXZlIGJlZW4gbW92ZWQgaW50byB0aGUgdGhlIGxlZnQgbWFwLCBzbyBjaGVjayBiZWZvcmUgcmVtb3ZpbmcgKilcbiAgICAgICAgICAgICAgIGlmIE1hcC5tZW0gbmV3X2xlZnRfbWFwIGtleSB0aGVuIGFjYyBlbHNlIE1hcC5yZW1vdmUgYWNjIGtleVxuICAgICAgICAgICAgIHwgYFVuZXF1YWwgKF9wcmV2LCBjdXIpIC0+IE1hcC5zZXQgYWNjIH5rZXkgfmRhdGE6Y3VyKSkpXG4gIDs7XG5cbiAgbGV0IGdlbmVyaWNfbWFwaV93aXRoX2NvbXBhcmF0b3InXG4gICAgKHR5cGUgaW5wdXRfZGF0YSBvdXRwdXRfZGF0YSBmX291dHB1dCBzdGF0ZV93aXRuZXNzKVxuICAgICh3aXRuZXNzIDogKGlucHV0X2RhdGEsIG91dHB1dF9kYXRhLCBmX291dHB1dCkgTWFwX3R5cGUudClcbiAgICB+aW5zdHJ1bWVudGF0aW9uXG4gICAgP2N1dG9mZlxuICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgKGxocyA6ICgoJ2tleSwgaW5wdXRfZGF0YSwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgfihjb21wYXJhdG9yIDogKCdrZXksICdjbXApIENvbXBhcmF0b3IudClcbiAgICB+KGYgOlxuICAgICAgICBrZXk6J2tleVxuICAgICAgICAtPiBkYXRhOihpbnB1dF9kYXRhLCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgICAgIC0+IChmX291dHB1dCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICA6ICgoJ2tleSwgb3V0cHV0X2RhdGEsICdjbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgPVxuICAgIGxldCBtb2R1bGUgRSA9IEluY3JlbWVudGFsLkV4cGVydCBpblxuICAgIGxldCBpbmNyZW1lbnRhbF9zdGF0ZSA9IEluY3JlbWVudGFsLnN0YXRlIGxocyBpblxuICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgIGxldCBwcmV2X21hcCA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcHJldl9ub2RlcyA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgYWNjIDogKCdrZXksIG91dHB1dF9kYXRhLCAnY21wKSBNYXAudCByZWYgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IHJlc3VsdCA9IEUuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPiAhYWNjKSBpblxuICAgIGxldCAob25faW5uZXJfY2hhbmdlIDoga2V5OidrZXkgLT4gZl9vdXRwdXQgLT4gdW5pdCkgPVxuICAgICAgbWF0Y2ggd2l0bmVzcyB3aXRoXG4gICAgICB8IE1hcF90eXBlLk1hcCAtPiBmdW4gfmtleSBkYXRhIC0+IGFjYyA6PSBNYXAuc2V0ICFhY2MgfmtleSB+ZGF0YVxuICAgICAgfCBNYXBfdHlwZS5GaWx0ZXJfbWFwIC0+XG4gICAgICAgIGZ1biB+a2V5IG9wdCAtPlxuICAgICAgICAgIGxldCBvbGQgPSAhYWNjIGluXG4gICAgICAgICAgYWNjXG4gICAgICAgICAgICA6PSAobWF0Y2ggb3B0IHdpdGhcbiAgICAgICAgICAgICAgICB8IE5vbmUgLT4gTWFwLnJlbW92ZSBvbGQga2V5XG4gICAgICAgICAgICAgICAgfCBTb21lIGRhdGEgLT4gTWFwLnNldCBvbGQgfmtleSB+ZGF0YSlcbiAgICBpblxuICAgIGxldCByZWMgbGhzX2NoYW5nZSA9XG4gICAgICBsYXp5XG4gICAgICAgIChJbmNyZW1lbnRhbC5tYXAgbGhzIH5mOihmdW4gbWFwIC0+XG4gICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5JbnN0cnVtZW50YXRpb24uZiAoZnVuICgpIC0+XG4gICAgICAgICAgICAgbGV0IG5ld19ub2RlcyA9XG4gICAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAgICAhcHJldl9tYXBcbiAgICAgICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgICAgIH5pbml0OiFwcmV2X25vZGVzXG4gICAgICAgICAgICAgICAgIH5mOihmdW4gbm9kZXMgKGtleSwgY2hhbmdlZCkgLT5cbiAgICAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlZCB3aXRoXG4gICAgICAgICAgICAgICAgIHwgYFVuZXF1YWwgXyAtPlxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlLCBfZGVwID0gTWFwLmZpbmRfZXhuIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5tYWtlX3N0YWxlIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgbm9kZXNcbiAgICAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IG5vZGUsIGRlcCA9IE1hcC5maW5kX2V4biBub2RlcyBrZXkgaW5cbiAgICAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSBNYXAucmVtb3ZlIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5yZW1vdmVfZGVwZW5kZW5jeSByZXN1bHQgZGVwO1xuICAgICAgICAgICAgICAgICAgIGFjYyA6PSBNYXAucmVtb3ZlICFhY2Mga2V5O1xuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5pbnZhbGlkYXRlIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgbm9kZXNcbiAgICAgICAgICAgICAgICAgfCBgUmlnaHQgXyAtPlxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlID1cbiAgICAgICAgICAgICAgICAgICAgIEUuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICBNYXAuZmluZF9leG4gIXByZXZfbWFwIGtleSlcbiAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgIE9wdGlvbi5pdGVyIGN1dG9mZiB+ZjooZnVuIGMgLT5cbiAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLnNldF9jdXRvZmYgKEUuTm9kZS53YXRjaCBub2RlKSBjKTtcbiAgICAgICAgICAgICAgICAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3kgbm9kZSAoRS5EZXBlbmRlbmN5LmNyZWF0ZSAoZm9yY2UgbGhzX2NoYW5nZSkpO1xuICAgICAgICAgICAgICAgICAgIGxldCB1c2VyX2Z1bmN0aW9uX2RlcCA9XG4gICAgICAgICAgICAgICAgICAgICBFLkRlcGVuZGVuY3kuY3JlYXRlXG4gICAgICAgICAgICAgICAgICAgICAgIChmIH5rZXkgfmRhdGE6KEUuTm9kZS53YXRjaCBub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgfm9uX2NoYW5nZToob25faW5uZXJfY2hhbmdlIH5rZXkpXG4gICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3kgcmVzdWx0IHVzZXJfZnVuY3Rpb25fZGVwO1xuICAgICAgICAgICAgICAgICAgIE1hcC5zZXQgbm9kZXMgfmtleSB+ZGF0YToobm9kZSwgdXNlcl9mdW5jdGlvbl9kZXApKVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgcHJldl9ub2RlcyA6PSBuZXdfbm9kZXM7XG4gICAgICAgICAgICAgcHJldl9tYXAgOj0gbWFwKSkpXG4gICAgaW5cbiAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3kgcmVzdWx0IChFLkRlcGVuZGVuY3kuY3JlYXRlIChmb3JjZSBsaHNfY2hhbmdlKSk7XG4gICAgRS5Ob2RlLndhdGNoIHJlc3VsdFxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwaScgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgZ2VuZXJpY19tYXBpX3dpdGhfY29tcGFyYXRvcidcbiAgICAgICAgTWFwX3R5cGUuRmlsdGVyX21hcFxuICAgICAgICB+aW5zdHJ1bWVudGF0aW9uXG4gICAgICAgID9jdXRvZmZcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgbWFwXG4gICAgICAgIH5mXG4gICAgICAgIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBtYXBpJyA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbikgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIHdpdGhfY29tcGFyYXRvciBtYXAgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICBnZW5lcmljX21hcGlfd2l0aF9jb21wYXJhdG9yJ1xuICAgICAgICBNYXBfdHlwZS5NYXBcbiAgICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgICA/Y3V0b2ZmXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIG1hcFxuICAgICAgICB+ZlxuICAgICAgICB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgbWFwJyA/aW5zdHJ1bWVudGF0aW9uID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICBtYXBpJyA/aW5zdHJ1bWVudGF0aW9uID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCcgP2luc3RydW1lbnRhdGlvbiA/Y3V0b2ZmID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgZmlsdGVyX21hcGknID9pbnN0cnVtZW50YXRpb24gP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCBtZXJnZScgP2luc3RydW1lbnRhdGlvbiA/Y3V0b2ZmID9kYXRhX2VxdWFsX2xlZnQgP2RhdGFfZXF1YWxfcmlnaHQgbWFwMSBtYXAyIH5mID1cbiAgICBtZXJnZVxuICAgICAgP2luc3RydW1lbnRhdGlvblxuICAgICAgP2RhdGFfZXF1YWxfbGVmdFxuICAgICAgP2RhdGFfZXF1YWxfcmlnaHRcbiAgICAgIG1hcDFcbiAgICAgIG1hcDJcbiAgICAgIH5mOihmdW4gfmtleTpfIGRpZmYgLT4gU29tZSBkaWZmKVxuICAgIHw+IGZpbHRlcl9tYXBpJyA/aW5zdHJ1bWVudGF0aW9uID9jdXRvZmYgfmY6KGZ1biB+a2V5IH5kYXRhOmRpZmYgLT4gZiB+a2V5IGRpZmYpXG4gIDs7XG5cbiAgbGV0IHVuemlwX21hcGlfd2l0aF9jb21wYXJhdG9yXG4gICAgKHR5cGUgdiB2MSB2MiBzdGF0ZV93aXRuZXNzKVxuICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICA/KGRhdGFfZXF1YWwgOiB2IC0+IHYgLT4gYm9vbCA9IHBoeXNfZXF1YWwpXG4gICAgPyhsZWZ0X3Jlc3VsdF9lcXVhbCA6IHYxIC0+IHYxIC0+IGJvb2wgPSBwaHlzX2VxdWFsKVxuICAgID8ocmlnaHRfcmVzdWx0X2VxdWFsIDogdjIgLT4gdjIgLT4gYm9vbCA9IHBoeXNfZXF1YWwpXG4gICAgKGlucHV0IDogKCgna2V5LCB2LCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICB+KGNvbXBhcmF0b3IgOiAoJ2tleSwgJ2NtcCkgQ29tcGFyYXRvci50KVxuICAgIH4oZiA6IGtleTona2V5IC0+IGRhdGE6diAtPiB2MSAqIHYyKVxuICAgIDogKCgna2V5LCB2MSwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgICogKCgna2V5LCB2MiwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICA9XG4gICAgbGV0IG1vZHVsZSBFID0gSW5jcmVtZW50YWwuRXhwZXJ0IGluXG4gICAgbGV0IGluY3JlbWVudGFsX3N0YXRlID0gSW5jcmVtZW50YWwuc3RhdGUgaW5wdXQgaW5cbiAgICBsZXQgZW1wdHlfbWFwID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICBsZXQgbGVmdF9hY2MgOiAoJ2tleSwgdjEsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgbGVmdF9yZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIWxlZnRfYWNjKSBpblxuICAgIGxldCByaWdodF9hY2MgOiAoJ2tleSwgdjIsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcmlnaHRfcmVzdWx0ID0gRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+ICFyaWdodF9hY2MpIGluXG4gICAgbGV0IHByZXZfbWFwID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBpbnB1dF9jaGFuZ2UgPVxuICAgICAgSW5jcmVtZW50YWwubWFwIGlucHV0IH5mOihmdW4gbWFwIC0+XG4gICAgICAgIGluc3RydW1lbnRhdGlvbi5JbnN0cnVtZW50YXRpb24uZiAoZnVuICgpIC0+XG4gICAgICAgICAgbGV0IGxlZnQsIHJpZ2h0ID1cbiAgICAgICAgICAgIG1hdGNoIE1hcC5pc19lbXB0eSAhcHJldl9tYXAsIE1hcC5pc19lbXB0eSBtYXAgd2l0aFxuICAgICAgICAgICAgfCB0cnVlLCB0cnVlIHwgZmFsc2UsIHRydWUgLT4gZW1wdHlfbWFwLCBlbXB0eV9tYXBcbiAgICAgICAgICAgIHwgdHJ1ZSwgZmFsc2UgLT5cbiAgICAgICAgICAgICAgKCogTWFwcGluZyBvbiBhIG1hcCBpcyB3YXkgZmFzdGVyIHRoYW4gc3ltbWV0cmljIGRpZmZpbmcgYW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgYnVpbGRpbmcgdGhlIG1hcHMgdXAgcGllY2UgYnkgcGllY2UsIHNvIHdlIGRvIHRoaXMgd2hlbmV2ZXIgd2VcbiAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbiBmcm9tIFwiZW1wdHlcIiB0byBcInNvbWV0aGluZ1wiLCB3aGljaCB3aWxsIGFsbW9zdCBhbHdheXNcbiAgICAgICAgICAgICAgICAgaGFwcGVuIG9uIHRoZSBmaXJzdCBzdGFiaWxpemF0aW9uLiAqKVxuICAgICAgICAgICAgICBsZXQgbGVmdCA9XG4gICAgICAgICAgICAgICAgTWFwLm1hcGkgbWFwIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICAgICAgICAgICAgbGV0IGwsIF8gPSBmIH5rZXkgfmRhdGEgaW5cbiAgICAgICAgICAgICAgICAgIGwpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIGxldCByaWdodCA9XG4gICAgICAgICAgICAgICAgTWFwLm1hcGkgbWFwIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICAgICAgICAgICAgbGV0IF8sIHIgPSBmIH5rZXkgfmRhdGEgaW5cbiAgICAgICAgICAgICAgICAgIHIpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIGxlZnQsIHJpZ2h0XG4gICAgICAgICAgICB8IGZhbHNlLCBmYWxzZSAtPlxuICAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgICAgIXByZXZfbWFwXG4gICAgICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgICAgfmluaXQ6KCFsZWZ0X2FjYywgIXJpZ2h0X2FjYylcbiAgICAgICAgICAgICAgICB+ZjooZnVuIChsZWZ0LCByaWdodCkgKGtleSwgY2hhbmdlZCkgLT5cbiAgICAgICAgICAgICAgICBtYXRjaCBjaGFuZ2VkIHdpdGhcbiAgICAgICAgICAgICAgICB8IGBVbmVxdWFsIChwcmV2LCBuZXdfKSAtPlxuICAgICAgICAgICAgICAgICAgbGV0IHByZXZfYSwgcHJldl9iID0gZiB+a2V5IH5kYXRhOnByZXYgaW5cbiAgICAgICAgICAgICAgICAgIGxldCBuZXdfYSwgbmV3X2IgPSBmIH5rZXkgfmRhdGE6bmV3XyBpblxuICAgICAgICAgICAgICAgICAgbGV0IGxlZnQgPVxuICAgICAgICAgICAgICAgICAgICBpZiBsZWZ0X3Jlc3VsdF9lcXVhbCBwcmV2X2EgbmV3X2FcbiAgICAgICAgICAgICAgICAgICAgdGhlbiBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgTWFwLnNldCBsZWZ0IH5rZXkgfmRhdGE6bmV3X2FcbiAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPVxuICAgICAgICAgICAgICAgICAgICBpZiByaWdodF9yZXN1bHRfZXF1YWwgcHJldl9iIG5ld19iXG4gICAgICAgICAgICAgICAgICAgIHRoZW4gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBNYXAuc2V0IHJpZ2h0IH5rZXkgfmRhdGE6bmV3X2JcbiAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICBsZWZ0LCByaWdodFxuICAgICAgICAgICAgICAgIHwgYExlZnQgXyAtPiBNYXAucmVtb3ZlIGxlZnQga2V5LCBNYXAucmVtb3ZlIHJpZ2h0IGtleVxuICAgICAgICAgICAgICAgIHwgYFJpZ2h0IGVsZW1lbnQgLT5cbiAgICAgICAgICAgICAgICAgIGxldCBhLCBiID0gZiB+a2V5IH5kYXRhOmVsZW1lbnQgaW5cbiAgICAgICAgICAgICAgICAgIE1hcC5zZXQgbGVmdCB+a2V5IH5kYXRhOmEsIE1hcC5zZXQgcmlnaHQgfmtleSB+ZGF0YTpiKVxuICAgICAgICAgIGluXG4gICAgICAgICAgaWYgbm90IChwaHlzX2VxdWFsICFsZWZ0X2FjYyBsZWZ0KSB0aGVuIEUuTm9kZS5tYWtlX3N0YWxlIGxlZnRfcmVzdWx0O1xuICAgICAgICAgIGlmIG5vdCAocGh5c19lcXVhbCAhcmlnaHRfYWNjIHJpZ2h0KSB0aGVuIEUuTm9kZS5tYWtlX3N0YWxlIHJpZ2h0X3Jlc3VsdDtcbiAgICAgICAgICBsZWZ0X2FjYyA6PSBsZWZ0O1xuICAgICAgICAgIHJpZ2h0X2FjYyA6PSByaWdodDtcbiAgICAgICAgICBwcmV2X21hcCA6PSBtYXApKVxuICAgIGluXG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IGxlZnRfcmVzdWx0IChFLkRlcGVuZGVuY3kuY3JlYXRlIGlucHV0X2NoYW5nZSk7XG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJpZ2h0X3Jlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSBpbnB1dF9jaGFuZ2UpO1xuICAgIEUuTm9kZS53YXRjaCBsZWZ0X3Jlc3VsdCwgRS5Ob2RlLndhdGNoIHJpZ2h0X3Jlc3VsdFxuICA7O1xuXG4gIGxldCB1bnppcF9tYXBpXG4gICAgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pXG4gICAgP2RhdGFfZXF1YWxcbiAgICA/bGVmdF9yZXN1bHRfZXF1YWxcbiAgICA/cmlnaHRfcmVzdWx0X2VxdWFsXG4gICAgaW5wdXRcbiAgICB+ZlxuICAgID1cbiAgICBsZXQgcGFpciA9XG4gICAgICB3aXRoX2NvbXBhcmF0b3IgaW5wdXQgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICAgIGlucHV0XG4gICAgICAgIHw+IHVuemlwX21hcGlfd2l0aF9jb21wYXJhdG9yXG4gICAgICAgICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgICAgICAgP2xlZnRfcmVzdWx0X2VxdWFsXG4gICAgICAgICAgICAgP3JpZ2h0X3Jlc3VsdF9lcXVhbFxuICAgICAgICAgICAgIH5jb21wYXJhdG9yXG4gICAgICAgICAgICAgfmZcbiAgICAgICAgfD4gVHVwbGUyLnVuY3VycnkgSW5jcmVtZW50YWwuYm90aClcbiAgICBpblxuICAgIEluY3JlbWVudGFsLm1hcCB+Zjpmc3QgcGFpciwgSW5jcmVtZW50YWwubWFwIH5mOnNuZCBwYWlyXG4gIDs7XG5cbiAgbGV0IHVuemlwID9pbnN0cnVtZW50YXRpb24gP2xlZnRfcmVzdWx0X2VxdWFsID9yaWdodF9yZXN1bHRfZXF1YWwgaW5wdXQgPVxuICAgIGxldCBkYXRhX2VxdWFsID1cbiAgICAgIE9wdGlvbi5tYXAyIGxlZnRfcmVzdWx0X2VxdWFsIHJpZ2h0X3Jlc3VsdF9lcXVhbCB+ZjooZnVuIGwgciAtPlxuICAgICAgICBUdXBsZTIuZXF1YWwgfmVxMTpsIH5lcTI6cilcbiAgICBpblxuICAgIHVuemlwX21hcGlcbiAgICAgID9pbnN0cnVtZW50YXRpb25cbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICA/bGVmdF9yZXN1bHRfZXF1YWxcbiAgICAgID9yaWdodF9yZXN1bHRfZXF1YWxcbiAgICAgIGlucHV0XG4gICAgICB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBkYXRhKVxuICA7O1xuXG4gIGxldCB1bnppcF9tYXBpX3dpdGhfY29tcGFyYXRvcidcbiAgICAodHlwZSB2IHYxIHYyIHN0YXRlX3dpdG5lc3MpXG4gICAgfmluc3RydW1lbnRhdGlvblxuICAgID9jdXRvZmZcbiAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgIChpbnB1dCA6ICgoJ2tleSwgdiwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgfihjb21wYXJhdG9yIDogKCdrZXksICdjbXApIENvbXBhcmF0b3IudClcbiAgICB+KGYgOlxuICAgICAgICBrZXk6J2tleVxuICAgICAgICAtPiBkYXRhOih2LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgICAgIC0+ICh2MSwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudCAqICh2Miwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICA6ICgoJ2tleSwgdjEsICdjbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgICAqICgoJ2tleSwgdjIsICdjbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgPVxuICAgIGxldCBtb2R1bGUgRSA9IEluY3JlbWVudGFsLkV4cGVydCBpblxuICAgIGxldCBpbmNyZW1lbnRhbF9zdGF0ZSA9IEluY3JlbWVudGFsLnN0YXRlIGlucHV0IGluXG4gICAgbGV0IGVtcHR5X21hcCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yIGluXG4gICAgbGV0IHByZXZfbWFwID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBwcmV2X25vZGVzID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBsZWZ0X2FjYyA6ICgna2V5LCB2MSwgJ2NtcCkgTWFwLnQgcmVmID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBsZWZ0X3Jlc3VsdCA9IEUuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPiAhbGVmdF9hY2MpIGluXG4gICAgbGV0IHJpZ2h0X2FjYyA6ICgna2V5LCB2MiwgJ2NtcCkgTWFwLnQgcmVmID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCByaWdodF9yZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIXJpZ2h0X2FjYykgaW5cbiAgICBsZXQgbGVmdF9vbl9pbm5lcl9jaGFuZ2UgfmtleSBkYXRhID0gbGVmdF9hY2MgOj0gTWFwLnNldCAhbGVmdF9hY2MgfmtleSB+ZGF0YSBpblxuICAgIGxldCByaWdodF9vbl9pbm5lcl9jaGFuZ2UgfmtleSBkYXRhID0gcmlnaHRfYWNjIDo9IE1hcC5zZXQgIXJpZ2h0X2FjYyB+a2V5IH5kYXRhIGluXG4gICAgbGV0IHJlYyBpbnB1dF9jaGFuZ2UgPVxuICAgICAgbGF6eVxuICAgICAgICAoSW5jcmVtZW50YWwubWFwIGlucHV0IH5mOihmdW4gbWFwIC0+XG4gICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5JbnN0cnVtZW50YXRpb24uZiAoZnVuICgpIC0+XG4gICAgICAgICAgICAgbGV0IG5ld19ub2RlcyA9XG4gICAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAgICAhcHJldl9tYXBcbiAgICAgICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgICAgIH5pbml0OiFwcmV2X25vZGVzXG4gICAgICAgICAgICAgICAgIH5mOihmdW4gbm9kZXMgKGtleSwgY2hhbmdlZCkgLT5cbiAgICAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlZCB3aXRoXG4gICAgICAgICAgICAgICAgIHwgYFVuZXF1YWwgXyAtPlxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlLCBfbGVmdF9kZXAsIF9yaWdodF9kZXAgPSBNYXAuZmluZF9leG4gbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLm1ha2Vfc3RhbGUgbm9kZTtcbiAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT5cbiAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSwgbGVmdF9kZXAsIHJpZ2h0X2RlcCA9IE1hcC5maW5kX2V4biBub2RlcyBrZXkgaW5cbiAgICAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSBNYXAucmVtb3ZlIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5yZW1vdmVfZGVwZW5kZW5jeSBsZWZ0X3Jlc3VsdCBsZWZ0X2RlcDtcbiAgICAgICAgICAgICAgICAgICBFLk5vZGUucmVtb3ZlX2RlcGVuZGVuY3kgcmlnaHRfcmVzdWx0IHJpZ2h0X2RlcDtcbiAgICAgICAgICAgICAgICAgICBsZWZ0X2FjYyA6PSBNYXAucmVtb3ZlICFsZWZ0X2FjYyBrZXk7XG4gICAgICAgICAgICAgICAgICAgcmlnaHRfYWNjIDo9IE1hcC5yZW1vdmUgIXJpZ2h0X2FjYyBrZXk7XG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmludmFsaWRhdGUgbm9kZTtcbiAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICB8IGBSaWdodCBfIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgIE1hcC5maW5kX2V4biAhcHJldl9tYXAga2V5KVxuICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgT3B0aW9uLml0ZXIgY3V0b2ZmIH5mOihmdW4gYyAtPlxuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuc2V0X2N1dG9mZiAoRS5Ob2RlLndhdGNoIG5vZGUpIGMpO1xuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSBub2RlIChFLkRlcGVuZGVuY3kuY3JlYXRlIChmb3JjZSBpbnB1dF9jaGFuZ2UpKTtcbiAgICAgICAgICAgICAgICAgICBsZXQgbGVmdF9pbmNyLCByaWdodF9pbmNyID0gZiB+a2V5IH5kYXRhOihFLk5vZGUud2F0Y2ggbm9kZSkgaW5cbiAgICAgICAgICAgICAgICAgICBsZXQgbGVmdF91c2VyX2Z1bmN0aW9uX2RlcCA9XG4gICAgICAgICAgICAgICAgICAgICBFLkRlcGVuZGVuY3kuY3JlYXRlIGxlZnRfaW5jciB+b25fY2hhbmdlOihsZWZ0X29uX2lubmVyX2NoYW5nZSB+a2V5KVxuICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0X3VzZXJfZnVuY3Rpb25fZGVwID1cbiAgICAgICAgICAgICAgICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRfaW5jclxuICAgICAgICAgICAgICAgICAgICAgICB+b25fY2hhbmdlOihyaWdodF9vbl9pbm5lcl9jaGFuZ2UgfmtleSlcbiAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSBsZWZ0X3Jlc3VsdCBsZWZ0X3VzZXJfZnVuY3Rpb25fZGVwO1xuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSByaWdodF9yZXN1bHQgcmlnaHRfdXNlcl9mdW5jdGlvbl9kZXA7XG4gICAgICAgICAgICAgICAgICAgTWFwLnNldFxuICAgICAgICAgICAgICAgICAgICAgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgIH5rZXlcbiAgICAgICAgICAgICAgICAgICAgIH5kYXRhOihub2RlLCBsZWZ0X3VzZXJfZnVuY3Rpb25fZGVwLCByaWdodF91c2VyX2Z1bmN0aW9uX2RlcCkpXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBwcmV2X25vZGVzIDo9IG5ld19ub2RlcztcbiAgICAgICAgICAgICBwcmV2X21hcCA6PSBtYXApKSlcbiAgICBpblxuICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSBsZWZ0X3Jlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSAoZm9yY2UgaW5wdXRfY2hhbmdlKSk7XG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJpZ2h0X3Jlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSAoZm9yY2UgaW5wdXRfY2hhbmdlKSk7XG4gICAgRS5Ob2RlLndhdGNoIGxlZnRfcmVzdWx0LCBFLk5vZGUud2F0Y2ggcmlnaHRfcmVzdWx0XG4gIDs7XG5cbiAgbGV0IHVuemlwX21hcGknID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKSA/Y3V0b2ZmID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgbGV0IHBhaXIgPVxuICAgICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgICAgbWFwXG4gICAgICAgIHw+IHVuemlwX21hcGlfd2l0aF9jb21wYXJhdG9yJyB+aW5zdHJ1bWVudGF0aW9uID9jdXRvZmYgP2RhdGFfZXF1YWwgfmNvbXBhcmF0b3IgfmZcbiAgICAgICAgfD4gSW5jcmVtZW50YWwucmV0dXJuIChJbmNyZW1lbnRhbC5zdGF0ZSBtYXApKVxuICAgIGluXG4gICAgSW5jcmVtZW50YWwuYmluZCB+Zjpmc3QgcGFpciwgSW5jcmVtZW50YWwuYmluZCB+ZjpzbmQgcGFpclxuICA7O1xuXG4gIGxldCBrZXlzID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKSBtYXAgPVxuICAgIHdpdGhfY29tcGFyYXRvciBtYXAgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICBsZXQgYWRkIH5rZXkgfmRhdGE6XyBhY2MgPSBTZXQuYWRkIGFjYyBrZXkgaW5cbiAgICAgIGxldCByZW1vdmUgfmtleSB+ZGF0YTpfIGFjYyA9IFNldC5yZW1vdmUgYWNjIGtleSBpblxuICAgICAgbGV0IGRhdGFfZXF1YWwgXyBfID0gdHJ1ZSBpblxuICAgICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgICAgbWFwXG4gICAgICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICAgICAgfmluaXQ6KFNldC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yKVxuICAgICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgIH5hZGRcbiAgICAgICAgfnJlbW92ZSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcGkgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBlbXB0eSA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yIGluXG4gICAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICBtYXBcbiAgICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgICB+aW5pdDooZW1wdHksIGVtcHR5KVxuICAgICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICAgIH51cGRhdGU6KGZ1biB+a2V5IH5vbGRfZGF0YTpfIH5uZXdfZGF0YTpkYXRhIChmaXJzdCwgc2Vjb25kKSAtPlxuICAgICAgICAgIG1hdGNoIGYgfmtleSB+ZGF0YSB3aXRoXG4gICAgICAgICAgfCBGaXJzdCBkYXRhIC0+IE1hcC5zZXQgZmlyc3QgfmtleSB+ZGF0YSwgTWFwLnJlbW92ZSBzZWNvbmQga2V5XG4gICAgICAgICAgfCBTZWNvbmQgZGF0YSAtPiBNYXAucmVtb3ZlIGZpcnN0IGtleSwgTWFwLnNldCBzZWNvbmQgfmtleSB+ZGF0YSlcbiAgICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgKGZpcnN0LCBzZWNvbmQpIC0+XG4gICAgICAgICAgbWF0Y2ggZiB+a2V5IH5kYXRhIHdpdGhcbiAgICAgICAgICB8IEZpcnN0IGRhdGEgLT4gTWFwLmFkZF9leG4gZmlyc3QgfmtleSB+ZGF0YSwgc2Vjb25kXG4gICAgICAgICAgfCBTZWNvbmQgZGF0YSAtPiBmaXJzdCwgTWFwLmFkZF9leG4gc2Vjb25kIH5rZXkgfmRhdGEpXG4gICAgICAgIH5yZW1vdmU6KGZ1biB+a2V5IH5kYXRhOl8gKGZpcnN0LCBzZWNvbmQpIC0+XG4gICAgICAgICAgTWFwLnJlbW92ZSBmaXJzdCBrZXksIE1hcC5yZW1vdmUgc2Vjb25kIGtleSkpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXBpJyA/aW5zdHJ1bWVudGF0aW9uID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICBtYXBpJyA/aW5zdHJ1bWVudGF0aW9uID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mXG4gICAgfD4gcGFydGl0aW9uX21hcGkgP2luc3RydW1lbnRhdGlvbiB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBkYXRhKVxuICA7O1xuXG4gIGxldCBmbGF0dGVuIHN0YXRlIG1hcCA9XG4gICAgbGV0IG1vZHVsZSBFID0gSW5jcmVtZW50YWwuRXhwZXJ0IGluXG4gICAgbGV0IHJlc3VsdCA9IHJlZiAoTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3I6KE1hcC5jb21wYXJhdG9yIG1hcCkpIGluXG4gICAgbGV0IG5vZGUgPSBFLk5vZGUuY3JlYXRlIHN0YXRlIChmdW4gKCkgLT4gIXJlc3VsdCkgaW5cbiAgICBNYXAuaXRlcmkgbWFwIH5mOihmdW4gfmtleSB+ZGF0YTppbmNyIC0+XG4gICAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3lcbiAgICAgICAgbm9kZVxuICAgICAgICAoRS5EZXBlbmRlbmN5LmNyZWF0ZSBpbmNyIH5vbl9jaGFuZ2U6KGZ1biBhIC0+XG4gICAgICAgICAgIHJlc3VsdCA6PSBNYXAuc2V0ICFyZXN1bHQgfmtleSB+ZGF0YTphKSkpO1xuICAgIEUuTm9kZS53YXRjaCBub2RlXG4gIDs7XG5cbiAgbGV0IGpvaW5fd2l0aF9jb21wYXJhdG9yIH5pbnN0cnVtZW50YXRpb24gbWFwX2luY3IgfmNvbXBhcmF0b3IgPVxuICAgIGxldCBtb2R1bGUgRSA9IEluY3JlbWVudGFsLkV4cGVydCBpblxuICAgIGxldCBpbmNyZW1lbnRhbF9zdGF0ZSA9IEluY3JlbWVudGFsLnN0YXRlIG1hcF9pbmNyIGluXG4gICAgbGV0IGVtcHR5X21hcCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yIGluXG4gICAgbGV0IHJlc3VsdF9tYXAgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IG9sZF9tYXBfb2ZfaW5jcnMgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IGN1cnJlbnRfZGVwZW5kZW5jaWVzID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCByZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIXJlc3VsdF9tYXApIGluXG4gICAgbGV0IGFkZF9zdWJub2RlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIH5rZXkgfmRhdGFfbm9kZSA9XG4gICAgICBsZXQgbmV3X2RlcCA9XG4gICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGUgZGF0YV9ub2RlIH5vbl9jaGFuZ2U6KGZ1biBkYXRhIC0+XG4gICAgICAgICAgcmVzdWx0X21hcCA6PSBNYXAuc2V0ICFyZXN1bHRfbWFwIH5rZXkgfmRhdGEpXG4gICAgICBpblxuICAgICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJlc3VsdCBuZXdfZGVwO1xuICAgICAgTWFwLnNldCBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5IH5kYXRhOm5ld19kZXBcbiAgICBpblxuICAgIGxldCByZW1vdmVfc3Vibm9kZSBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5ID1cbiAgICAgIGxldCBkZXAgPSBNYXAuZmluZF9leG4gY3VycmVudF9kZXBlbmRlbmNpZXMga2V5IGluXG4gICAgICBFLk5vZGUucmVtb3ZlX2RlcGVuZGVuY3kgcmVzdWx0IGRlcDtcbiAgICAgIHJlc3VsdF9tYXAgOj0gTWFwLnJlbW92ZSAhcmVzdWx0X21hcCBrZXk7XG4gICAgICBNYXAucmVtb3ZlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIGtleVxuICAgIGluXG4gICAgbGV0IGxoc19jaGFuZ2UgPVxuICAgICAgSW5jcmVtZW50YWwubWFwIG1hcF9pbmNyIH5mOihmdW4gbWFwX29mX2luY3JzIC0+XG4gICAgICAgIGluc3RydW1lbnRhdGlvbi5JbnN0cnVtZW50YXRpb24uZiAoZnVuICgpIC0+XG4gICAgICAgICAgbGV0IG5ld19kZXBlbmRlbmN5X21hcCA9XG4gICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICB+ZGF0YV9lcXVhbDpwaHlzX2VxdWFsXG4gICAgICAgICAgICAgICFvbGRfbWFwX29mX2luY3JzXG4gICAgICAgICAgICAgIG1hcF9vZl9pbmNyc1xuICAgICAgICAgICAgICB+aW5pdDohY3VycmVudF9kZXBlbmRlbmNpZXNcbiAgICAgICAgICAgICAgfmY6KGZ1biBjdXJyZW50X2RlcGVuZGVuY2llcyAoa2V5LCBkaWZmKSAtPlxuICAgICAgICAgICAgICBtYXRjaCBkaWZmIHdpdGhcbiAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+IHJlbW92ZV9zdWJub2RlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIH5rZXlcbiAgICAgICAgICAgICAgfCBgUmlnaHQgZGF0YV9ub2RlIC0+IGFkZF9zdWJub2RlIGN1cnJlbnRfZGVwZW5kZW5jaWVzIH5rZXkgfmRhdGFfbm9kZVxuICAgICAgICAgICAgICB8IGBVbmVxdWFsIChfLCBkYXRhX25vZGUpIC0+XG4gICAgICAgICAgICAgICAgcmVtb3ZlX3N1Ym5vZGUgY3VycmVudF9kZXBlbmRlbmNpZXMgfmtleSB8PiBhZGRfc3Vibm9kZSB+a2V5IH5kYXRhX25vZGUpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBjdXJyZW50X2RlcGVuZGVuY2llcyA6PSBuZXdfZGVwZW5kZW5jeV9tYXA7XG4gICAgICAgICAgb2xkX21hcF9vZl9pbmNycyA6PSBtYXBfb2ZfaW5jcnMpKVxuICAgIGluXG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IHJlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSBsaHNfY2hhbmdlKTtcbiAgICBFLk5vZGUud2F0Y2ggcmVzdWx0XG4gIDs7XG5cbiAgbGV0IGpvaW4gPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pIG1hcCA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGpvaW5fd2l0aF9jb21wYXJhdG9yIH5pbnN0cnVtZW50YXRpb24gbWFwIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIG1vZHVsZSBTZXBhcmF0ZV9zdGF0ZSA9IHN0cnVjdFxuICAgIHR5cGUgKCdrLCAndiwgJ2NtcCwgJ3cpIHQgPVxuICAgICAgeyBtdXRhYmxlIGlucHV0X21hcCA6ICgnaywgJ3YsICdjbXApIE1hcC50XG4gICAgICA7IG11dGFibGUgZXhwZXJ0X25vZGVzIDogKCdrLCAoJ3YsICd3KSBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS50LCAnY21wKSBNYXAudFxuICAgICAgOyBtdXRhYmxlIG91dHB1dF9tYXAgOiAoJ2ssICgndiwgJ3cpIEluY3JlbWVudGFsLnQsICdjbXApIE1hcC50XG4gICAgICB9XG5cbiAgICBsZXQgY3JlYXRlIGNvbXBhcmF0b3IgPVxuICAgICAgbGV0IGVtcHR5ID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICAgIHsgaW5wdXRfbWFwID0gZW1wdHk7IGV4cGVydF9ub2RlcyA9IGVtcHR5OyBvdXRwdXRfbWFwID0gZW1wdHkgfVxuICAgIDs7XG5cbiAgICBsZXQgY3JlYXRlX2xvb2t1cF9ub2RlIHN0YXRlIHQga2V5ID1cbiAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmNyZWF0ZSBzdGF0ZSAoZnVuICgpIC0+IE1hcC5maW5kX2V4biB0LmlucHV0X21hcCBrZXkpXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHNlcGFyYXRlID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKSBpbnB1dF9tYXAgfmRhdGFfZXF1YWwgPVxuICAgIGxldCBpbmNyZW1lbnRhbF9zdGF0ZSA9IEluY3JlbWVudGFsLnN0YXRlIGlucHV0X21hcCBpblxuICAgIHdpdGhfY29tcGFyYXRvciBpbnB1dF9tYXAgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICBsZXQgc3RhdGUgPSBTZXBhcmF0ZV9zdGF0ZS5jcmVhdGUgY29tcGFyYXRvciBpblxuICAgICAgbGV0IG91dHB1dF9tYXBfbm9kZSA9XG4gICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+IHN0YXRlLm91dHB1dF9tYXApXG4gICAgICBpblxuICAgICAgbGV0IG1ha2Vfbm9kZV9kZXBlbmRfb25faW5wdXRfbWFwX2NoYW5nZWQgbm9kZSB+aW5wdXRfbWFwX2NoYW5nZWQgPVxuICAgICAgICBsZXQgZGVwZW5kZW5jeSA9XG4gICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0LkRlcGVuZGVuY3kuY3JlYXRlIChMYXp5LmZvcmNlX3ZhbCBpbnB1dF9tYXBfY2hhbmdlZClcbiAgICAgICAgaW5cbiAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuYWRkX2RlcGVuZGVuY3kgbm9kZSBkZXBlbmRlbmN5XG4gICAgICBpblxuICAgICAgKCogV2Ugd2FudCB0byBtYWtlIG5vZGVzIGRlcGVuZCBvbiBbaW5wdXRfbWFwX2NoYW5nZWRdIHNvIHRoYXQgW2lucHV0X21hcF9jaGFuZ2VkXVxuICAgICAgICAgaXMgYWxsb3dlZCB0byBtYWtlIHRoZW0gc3RhbGUsIGJ1dCB3ZSBkbyBub3Qgd2FudCB0aGVtIHRvIGJlIHJlY29tcHV0ZWQgZm9yIGFueVxuICAgICAgICAgb3RoZXIgcmVhc29uLiBTbyB3ZSBtYWtlIFtpbnB1dF9tYXBfY2hhbmdlZF0gYSB1bml0IGluY3JlbWVudGFsICh0aGF0IHRoZXJlZm9yZVxuICAgICAgICAgbmV2ZXIgY2hhbmdlcykgYW5kIHRoaXMgd2F5IFtvdXRwdXRfbWFwX25vZGVdIGFuZCB0aGUgbG9va3VwIG5vZGVzIHdpbGwgb25seSBiZVxuICAgICAgICAgcmVjb21wdXRlZCB3aGVuIHRoZXkgYXJlIGV4cGxpY2l0bHkgbWFkZSBzdGFsZS5cbiAgICAgICopXG4gICAgICBsZXQgcmVjIGlucHV0X21hcF9jaGFuZ2VkID1cbiAgICAgICAgbGF6eVxuICAgICAgICAgIChJbmNyZW1lbnRhbC5tYXAgaW5wdXRfbWFwIH5mOihmdW4gaW5wdXRfbWFwIC0+XG4gICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLkluc3RydW1lbnRhdGlvbi5mIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgIGxldCBwcmV2X2lucHV0X21hcCA9IHN0YXRlLmlucHV0X21hcCBpblxuICAgICAgICAgICAgICAgbGV0IGV4cGVydF9ub2Rlcywgb3V0cHV0X21hcCA9XG4gICAgICAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgICAgICAgcHJldl9pbnB1dF9tYXBcbiAgICAgICAgICAgICAgICAgICBpbnB1dF9tYXBcbiAgICAgICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAgICAgIH5pbml0OihzdGF0ZS5leHBlcnRfbm9kZXMsIHN0YXRlLm91dHB1dF9tYXApXG4gICAgICAgICAgICAgICAgICAgfmY6KGZ1biAoZXhwZXJ0X25vZGVzLCBvdXRwdXRfbWFwKSAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlIHdpdGhcbiAgICAgICAgICAgICAgICAgICB8IGBMZWZ0IF9vbGRfdmFsdWUgLT5cbiAgICAgICAgICAgICAgICAgICAgIGxldCBvbGRfbm9kZSA9IE1hcC5maW5kX2V4biBleHBlcnRfbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS5pbnZhbGlkYXRlIG9sZF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUubWFrZV9zdGFsZSBvdXRwdXRfbWFwX25vZGU7XG4gICAgICAgICAgICAgICAgICAgICBNYXAucmVtb3ZlIGV4cGVydF9ub2RlcyBrZXksIE1hcC5yZW1vdmUgb3V0cHV0X21hcCBrZXlcbiAgICAgICAgICAgICAgICAgICB8IGBSaWdodCBfbmV3X3ZhbHVlIC0+XG4gICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9XG4gICAgICAgICAgICAgICAgICAgICAgIFNlcGFyYXRlX3N0YXRlLmNyZWF0ZV9sb29rdXBfbm9kZSBpbmNyZW1lbnRhbF9zdGF0ZSBzdGF0ZSBrZXlcbiAgICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICBtYWtlX25vZGVfZGVwZW5kX29uX2lucHV0X21hcF9jaGFuZ2VkIG5vZGUgfmlucHV0X21hcF9jaGFuZ2VkO1xuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUubWFrZV9zdGFsZSBvdXRwdXRfbWFwX25vZGU7XG4gICAgICAgICAgICAgICAgICAgICAoIE1hcC5hZGRfZXhuIGV4cGVydF9ub2RlcyB+a2V5IH5kYXRhOm5vZGVcbiAgICAgICAgICAgICAgICAgICAgICwgTWFwLmFkZF9leG5cbiAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRfbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAgfmtleVxuICAgICAgICAgICAgICAgICAgICAgICAgIH5kYXRhOihJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS53YXRjaCBub2RlKSApXG4gICAgICAgICAgICAgICAgICAgfCBgVW5lcXVhbCAoX29sZF92YWx1ZSwgX25ld192YWx1ZSkgLT5cbiAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLm1ha2Vfc3RhbGUgKE1hcC5maW5kX2V4biBleHBlcnRfbm9kZXMga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgIGV4cGVydF9ub2Rlcywgb3V0cHV0X21hcClcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICBzdGF0ZS5pbnB1dF9tYXAgPC0gaW5wdXRfbWFwO1xuICAgICAgICAgICAgICAgc3RhdGUuZXhwZXJ0X25vZGVzIDwtIGV4cGVydF9ub2RlcztcbiAgICAgICAgICAgICAgIHN0YXRlLm91dHB1dF9tYXAgPC0gb3V0cHV0X21hcCkpKVxuICAgICAgaW5cbiAgICAgIG1ha2Vfbm9kZV9kZXBlbmRfb25faW5wdXRfbWFwX2NoYW5nZWQgb3V0cHV0X21hcF9ub2RlIH5pbnB1dF9tYXBfY2hhbmdlZDtcbiAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLndhdGNoIG91dHB1dF9tYXBfbm9kZSlcbiAgOztcblxuICAoKiBKdXN0IGZvciBkZXJpdmluZyBzdHJ1Y3R1cmFsIGVxdWFsaXR5LiAqKVxuICB0eXBlICdhIG1heWJlX2JvdW5kX3N0cnVjdHVyYWxseSA9ICdhIE1heWJlX2JvdW5kLnQgPVxuICAgIHwgSW5jbCBvZiAnYVxuICAgIHwgRXhjbCBvZiAnYVxuICAgIHwgVW5ib3VuZGVkXG4gIFtAQGRlcml2aW5nIGVxdWFsXVxuXG4gIGxldCBzdWJyYW5nZVxuICAgICh0eXBlIGsgdiBjbXAgc3RhdGVfd2l0bmVzcylcbiAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgIChtYXBfaW5jciA6ICgoaywgdiwgY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICByYW5nZVxuICAgID1cbiAgICB3aXRoX29sZDIgfmluc3RydW1lbnRhdGlvbiBtYXBfaW5jciByYW5nZSB+ZjooZnVuIH5vbGQgbWFwIHJhbmdlIC0+XG4gICAgICBsZXQgY29tcGFyZSA9IChNYXAuY29tcGFyYXRvciBtYXApLmNvbXBhcmUgaW5cbiAgICAgIGxldCBlcXVhbCBsIHIgPSBjb21wYXJlIGwgciA9IDAgaW5cbiAgICAgIGxldCAoID4gKSBhIGIgPSBjb21wYXJlIGEgYiA+IDBcbiAgICAgIGFuZCAoID49ICkgYSBiID0gY29tcGFyZSBhIGIgPj0gMCBpblxuICAgICAgbGV0IG1heWJlX2JvdW5kX2VxdWFsIGEgYiA6IGJvb2wgPSBlcXVhbF9tYXliZV9ib3VuZF9zdHJ1Y3R1cmFsbHkgZXF1YWwgYSBiIGluXG4gICAgICBsZXQgcmFuZ2VfaXNfZW1wdHkgfm1pbiB+bWF4IDogYm9vbCA9XG4gICAgICAgIG1hdGNoIG1pbiwgbWF4IHdpdGhcbiAgICAgICAgfCBVbmJvdW5kZWQsIChVbmJvdW5kZWQgfCBFeGNsIF8gfCBJbmNsIF8pIHwgKEV4Y2wgXyB8IEluY2wgXyksIFVuYm91bmRlZCAtPiBmYWxzZVxuICAgICAgICB8IEluY2wgbWluLCBJbmNsIG1heCAtPiBtaW4gPiBtYXhcbiAgICAgICAgfCBFeGNsIG1pbiwgRXhjbCBtYXggfCBJbmNsIG1pbiwgRXhjbCBtYXggfCBFeGNsIG1pbiwgSW5jbCBtYXggLT4gbWluID49IG1heFxuICAgICAgaW5cbiAgICAgIGxldCByYW5nZV9pbmNsdWRlcyB+bWluIH5tYXgga2V5IDogYm9vbCA9XG4gICAgICAgIE1heWJlX2JvdW5kLmlzX2xvd2VyX2JvdW5kIG1pbiB+b2ZfOmtleSB+Y29tcGFyZVxuICAgICAgICAmJiBNYXliZV9ib3VuZC5pc191cHBlcl9ib3VuZCBtYXggfm9mXzprZXkgfmNvbXBhcmVcbiAgICAgIGluXG4gICAgICBtYXRjaCByYW5nZSB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgKCogRW1wdHkgbmV3IHJhbmdlIG1lYW5zIGVtcHR5IG1hcCAqKVxuICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjooTWFwLmNvbXBhcmF0b3IgbWFwKVxuICAgICAgfCBTb21lICgobWluLCBtYXgpIGFzIHJhbmdlKSAtPlxuICAgICAgICBsZXQgZnJvbV9zY3JhdGNoICgpID0gTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQ6bWluIH51cHBlcl9ib3VuZDptYXggaW5cbiAgICAgICAgKG1hdGNoIG9sZCB3aXRoXG4gICAgICAgICB8IE5vbmUgfCBTb21lIChfLCBOb25lLCBfKSAtPlxuICAgICAgICAgICAoKiBubyBvbGQgcmFuZ2UgKilcbiAgICAgICAgICAgZnJvbV9zY3JhdGNoICgpXG4gICAgICAgICB8IFNvbWUgKF8sIFNvbWUgKG9sZF9taW4sIG9sZF9tYXgpLCBfKVxuICAgICAgICAgICB3aGVuIHJhbmdlX2lzX2VtcHR5IH5taW46b2xkX21pbiB+bWF4Om9sZF9tYXhcbiAgICAgICAgICAgICAgICB8fCByYW5nZV9pc19lbXB0eSB+bWluIH5tYXg6b2xkX21heFxuICAgICAgICAgICAgICAgIHx8IHJhbmdlX2lzX2VtcHR5IH5taW46b2xkX21pbiB+bWF4IC0+XG4gICAgICAgICAgICgqIGVtcHR5IG9sZCByYW5nZSBvciBvbGQgcmFuZ2UgZGlzam9pbnQgd2l0aCBuZXcgKilcbiAgICAgICAgICAgZnJvbV9zY3JhdGNoICgpXG4gICAgICAgICB8IFNvbWUgKG9sZF9tYXAsIFNvbWUgKChvbGRfbWluLCBvbGRfbWF4KSBhcyBvbGRfcmFuZ2UpLCBvbGRfcmVzKSAtPlxuICAgICAgICAgICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICAgICAgICAgICAoKiBSZXR1cm5zIHRydWUgaWZmIHRoZSBrZXkgaXMgaW4gYm90aCBuZXcgYW5kIG9sZCByYW5nZXMgKilcbiAgICAgICAgICAgICBsZXQgaW5fcmFuZ2VfaW50ZXJzZWN0aW9uIGtleSA9XG4gICAgICAgICAgICAgICByYW5nZV9pbmNsdWRlcyB+bWluIH5tYXgga2V5XG4gICAgICAgICAgICAgICAmJiByYW5nZV9pbmNsdWRlcyB+bWluOm9sZF9taW4gfm1heDpvbGRfbWF4IGtleVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgKCogQXBwbHkgY2hhbmdlcyB0byBrZXlzIHdoaWNoIGFyZSBpbiB0aGUgaW50ZXJzZWN0aW9uIG9mIGJvdGggcmFuZ2VzLlxuXG4gICAgICAgICAgICAgICAgW291dHNpZGVdIGlzIHRoZSBudW1iZXIgb2YgdXBkYXRlcyBvdXRzaWRlIHRoZSByYW5nZSBpbnRlcnNlY3Rpb24gdGhhdCB3ZVxuICAgICAgICAgICAgICAgIHRvbGVyYXRlIGJlZm9yZSBnaXZpbmcgdXAgYW5kIHJlY29uc3RydWN0aW5nIGJhc2VkIG9uIHRoZSBuZXcgcmFuZ2UuIFRoaXNcbiAgICAgICAgICAgICAgICBpcyBhbiBvcHRpbWlzYXRpb24gaW4gdGhlIGNhc2UgdGhhdCB0aGUgbWFwIGNoYW5nZXMgaW4gYSB2ZXJ5IGJpZyB3YXksIGF0XG4gICAgICAgICAgICAgICAgd2hpY2ggcG9pbnQgY29tcHV0aW5nIGJhc2VkIG9uIHRoZSBuZXcgcmFuZ2UgaXMgY2hlYXBlci4gICopXG4gICAgICAgICAgICAgbGV0IGFwcGx5X2RpZmZfaW5faW50ZXJzZWN0aW9uIChvdXRzaWRlLCBtYXApIChrZXksIGRhdGEpID1cbiAgICAgICAgICAgICAgIGlmIGluX3JhbmdlX2ludGVyc2VjdGlvbiBrZXlcbiAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICBtYXRjaCBkYXRhIHdpdGhcbiAgICAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+IG91dHNpZGUsIE1hcC5yZW1vdmUgbWFwIGtleVxuICAgICAgICAgICAgICAgICB8IGBSaWdodCBkYXRhIHwgYFVuZXF1YWwgKF8sIGRhdGEpIC0+IG91dHNpZGUsIE1hcC5zZXQgbWFwIH5rZXkgfmRhdGEpXG4gICAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgICAgbGV0IG91dHNpZGUgPSBvdXRzaWRlIC0gMSBpblxuICAgICAgICAgICAgICAgICBpZiBJbnQuTy4ob3V0c2lkZSA8IDApXG4gICAgICAgICAgICAgICAgIHRoZW4gcmV0dXJuIChmcm9tX3NjcmF0Y2ggKCkpXG4gICAgICAgICAgICAgICAgIGVsc2Ugb3V0c2lkZSwgTWFwLnJlbW92ZSBtYXAga2V5KVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgKCogRmlyc3QgdXBkYXRlIHRoZSBrZXlzIGluIC9ib3RoLyB0aGUgb2xkIGFuZCB0aGUgbmV3IHJhbmdlLiAqKVxuICAgICAgICAgICAgIGxldCB3aXRoX3VwZGF0ZWRfdmFsdWVzX2luX2ludGVyc2VjdGlvbiA9XG4gICAgICAgICAgICAgICAoKiBDdXRvZmYgdGhlIGJpZyBkaWZmIGNvbXB1dGF0aW9uIGlmIHdlIHJlYWNoIE8ofHN1Ym1hcHwpIG51bWJlciBvZlxuICAgICAgICAgICAgICAgICAgY2hhbmdlcyB0aGF0IGFyZSBvdXRzaWRlIHRoZSByYW5nZSAqKVxuICAgICAgICAgICAgICAgbGV0IG91dHNpZGVfY3V0b2ZmID0gTWFwLmxlbmd0aCBvbGRfcmVzIC8gNCBpblxuICAgICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgICAgb2xkX21hcFxuICAgICAgICAgICAgICAgICBtYXBcbiAgICAgICAgICAgICAgICAgfmluaXQ6KG91dHNpZGVfY3V0b2ZmLCBvbGRfcmVzKVxuICAgICAgICAgICAgICAgICB+ZjphcHBseV9kaWZmX2luX2ludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgfD4gc25kXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBpZiBUdXBsZTIuZXF1YWwgfmVxMTptYXliZV9ib3VuZF9lcXVhbCB+ZXEyOm1heWJlX2JvdW5kX2VxdWFsIG9sZF9yYW5nZSByYW5nZVxuICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgICgqIFRoZXJlIGFyZSBubyBrZXlzIHRvIHJlbW92ZSBhbmQgZXZlcnl0aGluZyBpbiByYW5nZSBpcyB1cGRhdGVkLiAqKVxuICAgICAgICAgICAgICAgd2l0aF91cGRhdGVkX3ZhbHVlc19pbl9pbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgICgqIFJlbW92ZSBhbnkga2V5cyB3aGljaCBhcmUgbm90IGluIHRoZSBuZXcgcmFuZ2UuICopXG4gICAgICAgICAgICAgICBsZXQgd2l0aG91dF9rZXlzX291dF9vZl9yYW5nZSA9XG4gICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZVxuICAgICAgICAgICAgICAgICAgIHdpdGhfdXBkYXRlZF92YWx1ZXNfaW5faW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgfmxvd2VyX2JvdW5kOm1pblxuICAgICAgICAgICAgICAgICAgIH51cHBlcl9ib3VuZDptYXhcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAoKiBBZGQgaW4gYW55IGtleXMgd2hpY2ggYXJlIGluIHRoZSBuZXcgcmFuZ2UgYnV0IG5vdCB0aGUgb2xkIHJhbmdlLiAqKVxuICAgICAgICAgICAgICAgbGV0IHdpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlID1cbiAgICAgICAgICAgICAgICAgbGV0IG1hcF9hcHBlbmRfZXhuIGxvd2VyX3BhcnQgdXBwZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggTWFwLmFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBgT2sgbWFwIC0+IG1hcFxuICAgICAgICAgICAgICAgICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT5cbiAgICAgICAgICAgICAgICAgICAgIGZhaWx3aXRoIFwiaW1wb3NzaWJsZSBjYXNlOiBCVUcgaW4gaW5jcl9tYXAubWwgc3VicmFuZ2VcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICBsZXQgbG93ZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggb2xkX21pbiB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBVbmJvdW5kZWQgLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOihNYXAuY29tcGFyYXRvciBtYXApXG4gICAgICAgICAgICAgICAgICAgfCBFeGNsIG9sZF9taW4gLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kOm1pbiB+dXBwZXJfYm91bmQ6KEluY2wgb2xkX21pbilcbiAgICAgICAgICAgICAgICAgICB8IEluY2wgb2xkX21pbiAtPlxuICAgICAgICAgICAgICAgICAgICAgTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQ6bWluIH51cHBlcl9ib3VuZDooRXhjbCBvbGRfbWluKVxuICAgICAgICAgICAgICAgICBhbmQgdXBwZXJfcGFydCA9XG4gICAgICAgICAgICAgICAgICAgbWF0Y2ggb2xkX21heCB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCBVbmJvdW5kZWQgLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOihNYXAuY29tcGFyYXRvciBtYXApXG4gICAgICAgICAgICAgICAgICAgfCBFeGNsIG9sZF9tYXggLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kOihJbmNsIG9sZF9tYXgpIH51cHBlcl9ib3VuZDptYXhcbiAgICAgICAgICAgICAgICAgICB8IEluY2wgb2xkX21heCAtPlxuICAgICAgICAgICAgICAgICAgICAgTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQ6KEV4Y2wgb2xkX21heCkgfnVwcGVyX2JvdW5kOm1heFxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICBtYXBfYXBwZW5kX2V4blxuICAgICAgICAgICAgICAgICAgIGxvd2VyX3BhcnRcbiAgICAgICAgICAgICAgICAgICAobWFwX2FwcGVuZF9leG4gd2l0aG91dF9rZXlzX291dF9vZl9yYW5nZSB1cHBlcl9wYXJ0KVxuICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgIHdpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlKSkpKVxuICA7O1xuXG4gIGxldCByZWtleVxuICAgID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKVxuICAgID9kYXRhX2VxdWFsXG4gICAgbWFwX2luY3JcbiAgICB+Y29tcGFyYXRvcjpvdXRlcl9jb21wYXJhdG9yXG4gICAgfmZcbiAgICA9XG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgIG1hcF9pbmNyXG4gICAgICA/ZGF0YV9lcXVhbFxuICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgfmluaXQ6KE1hcC5lbXB0eSBvdXRlcl9jb21wYXJhdG9yLCBbXSlcbiAgICAgIH5yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OnRydWVcbiAgICAgIH5hZGQ6KGZ1biB+a2V5IH5kYXRhIChvdXRwdXQsIGFkZHMpIC0+XG4gICAgICAgIGxldCBuZXdfZW50cnkgPSBmIH5rZXkgfmRhdGEsIGRhdGEgaW5cbiAgICAgICAgb3V0cHV0LCBuZXdfZW50cnkgOjogYWRkcylcbiAgICAgIH5yZW1vdmU6KGZ1biB+a2V5IH5kYXRhIChvdXRwdXQsIGFkZHMpIC0+IE1hcC5yZW1vdmUgb3V0cHV0IChmIH5rZXkgfmRhdGEpLCBhZGRzKVxuICAgICAgfnVwZGF0ZTooZnVuIH5rZXkgfm9sZF9kYXRhIH5uZXdfZGF0YSAob3V0cHV0LCBhZGRzKSAtPlxuICAgICAgICBsZXQgcHJldl9rZXkgPSBmIH5rZXkgfmRhdGE6b2xkX2RhdGEgaW5cbiAgICAgICAgbGV0IG5ld19rZXkgPSBmIH5rZXkgfmRhdGE6bmV3X2RhdGEgaW5cbiAgICAgICAgaWYgKE1hcC5jb21wYXJhdG9yIG91dHB1dCkuY29tcGFyZSBwcmV2X2tleSBuZXdfa2V5ID0gMFxuICAgICAgICB0aGVuIE1hcC5zZXQgb3V0cHV0IH5rZXk6bmV3X2tleSB+ZGF0YTpuZXdfZGF0YSwgYWRkc1xuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgb3V0cHV0ID0gTWFwLnJlbW92ZSBvdXRwdXQgcHJldl9rZXkgaW5cbiAgICAgICAgICBvdXRwdXQsIChuZXdfa2V5LCBuZXdfZGF0YSkgOjogYWRkcykpXG4gICAgICB+ZmluYWxpemU6KGZ1biAob3V0cHV0LCBhZGRzKSAtPlxuICAgICAgICBsZXQgb3V0cHV0ID1cbiAgICAgICAgICBMaXN0LmZvbGQgYWRkcyB+aW5pdDpvdXRwdXQgfmY6KGZ1biBvdXRwdXQgKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgIE1hcC5hZGRfZXhuIG91dHB1dCB+a2V5IH5kYXRhKVxuICAgICAgICBpblxuICAgICAgICBvdXRwdXQsIFtdKVxuICAgIHw+IEluY3JlbWVudGFsLm1hcCB+Zjpmc3RcbiAgOztcblxuICBsZXQgaW5kZXhfYnlpXG4gICAgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pXG4gICAgP2RhdGFfZXF1YWxcbiAgICBtYXBfaW5jclxuICAgIH5jb21wYXJhdG9yOm91dGVyX2NvbXBhcmF0b3JcbiAgICB+aW5kZXhcbiAgICA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcF9pbmNyIChmdW4gaW5uZXJfY29tcGFyYXRvciAtPlxuICAgICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgICBtYXBfaW5jclxuICAgICAgICB+aW5pdDooTWFwLmVtcHR5IG91dGVyX2NvbXBhcmF0b3IpXG4gICAgICAgIH5yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OnRydWVcbiAgICAgICAgfmFkZDooZnVuIH5rZXk6aW5uZXJfa2V5IH5kYXRhIG91dGVyX21hcCAtPlxuICAgICAgICAgIG1hdGNoIGluZGV4IH5rZXk6aW5uZXJfa2V5IH5kYXRhIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gb3V0ZXJfbWFwXG4gICAgICAgICAgfCBTb21lIG91dGVyX2tleSAtPlxuICAgICAgICAgICAgTWFwLnVwZGF0ZSBvdXRlcl9tYXAgb3V0ZXJfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gaW5uZXJfa2V5IGRhdGEgfmNvbXBhcmF0b3I6aW5uZXJfY29tcGFyYXRvclxuICAgICAgICAgICAgICB8IFNvbWUgaW5uZXJfbWFwIC0+IE1hcC5hZGRfZXhuIGlubmVyX21hcCB+a2V5OmlubmVyX2tleSB+ZGF0YSkpXG4gICAgICAgIH5yZW1vdmU6KGZ1biB+a2V5OmlubmVyX2tleSB+ZGF0YSBvdXRlcl9tYXAgLT5cbiAgICAgICAgICBtYXRjaCBpbmRleCB+a2V5OmlubmVyX2tleSB+ZGF0YSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG91dGVyX21hcFxuICAgICAgICAgIHwgU29tZSBvdXRlcl9rZXkgLT5cbiAgICAgICAgICAgIE1hcC5jaGFuZ2Ugb3V0ZXJfbWFwIG91dGVyX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgZmFpbHdpdGggXCJCVUc6IEhpdCBzdXBwb3NlZGx5IGltcG9zc2libGUgY2FzZSBpbiBJbmNyX21hcC5pbmRleF9ieVwiXG4gICAgICAgICAgICAgIHwgU29tZSBpbm5lcl9tYXAgLT5cbiAgICAgICAgICAgICAgICBsZXQgaW5uZXJfbWFwID0gTWFwLnJlbW92ZSBpbm5lcl9tYXAgaW5uZXJfa2V5IGluXG4gICAgICAgICAgICAgICAgaWYgTWFwLmlzX2VtcHR5IGlubmVyX21hcCB0aGVuIE5vbmUgZWxzZSBTb21lIGlubmVyX21hcCkpKVxuICA7O1xuXG4gIGxldCBpbmRleF9ieSA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5jb21wYXJhdG9yIH5pbmRleCA9XG4gICAgaW5kZXhfYnlpXG4gICAgICA/aW5zdHJ1bWVudGF0aW9uXG4gICAgICA/ZGF0YV9lcXVhbFxuICAgICAgbWFwX2luY3JcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICB+aW5kZXg6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gaW5kZXggZGF0YSlcbiAgOztcblxuICAoKiogRmluZCB0d28ga2V5cyBpbiBtYXAgYnkgaW5kZXgsIE8obikuIFdlIHVzZSBqdXN0IG9uZSBmb2xkICh0d28gTWFwLm50aCB3b3VsZCB1c2UgdHdvKVxuICAgICAgYW5kIG9wdGltaXplIGZvciBrZXlzIGNsb3NlIHRvIGVpdGhlciBiZWdpbm5pbmcgb3IgZW5kIGJ5IHVzaW5nIGVpdGhlciBmb2xkIG9yXG4gICAgICBmb2xkX3JpZ2h0LlxuICAqKVxuICBtb2R1bGUgS2V5X3N0YXR1cyA9IHN0cnVjdFxuICAgIHR5cGUgJ2sgdCA9XG4gICAgICB8IEtub3duIG9mICdrXG4gICAgICB8IEtub3duX25vbmVcbiAgICAgIHwgVW5rbm93blxuXG4gICAgbGV0IGlzX2tub3duID0gZnVuY3Rpb25cbiAgICAgIHwgVW5rbm93biAtPiBmYWxzZVxuICAgICAgfCBfIC0+IHRydWVcbiAgICA7O1xuXG4gICAgbGV0IHRvX29wdGlvbiA9IGZ1bmN0aW9uXG4gICAgICB8IFVua25vd24gfCBLbm93bl9ub25lIC0+IE5vbmVcbiAgICAgIHwgS25vd24gayAtPiBTb21lIGtcbiAgICA7O1xuICBlbmRcblxuICBsZXQgZmluZF9rZXlfcmFuZ2VfbGluZWFyICh0eXBlIGspIH5mcm9tIH50b18gKG1hcCA6IChrLCBfLCBfKSBNYXAudClcbiAgICA6IChrICogayBvcHRpb24pIG9wdGlvblxuICAgID1cbiAgICBsZXQgb3BlbiBLZXlfc3RhdHVzIGluXG4gICAgbGV0IGxlbiA9IE1hcC5sZW5ndGggbWFwIGluXG4gICAgbGV0IGJlZ2luX2tleSA9IGlmIEludC4oID49ICkgZnJvbSBsZW4gdGhlbiBLbm93bl9ub25lIGVsc2UgVW5rbm93biBpblxuICAgIGxldCBlbmRfa2V5ID0gaWYgSW50LiggPj0gKSB0b18gbGVuIHRoZW4gS25vd25fbm9uZSBlbHNlIFVua25vd24gaW5cbiAgICBsZXQgZmluZF9rZXlzIGZvbGQgfnN0YXJ0X3BvcyB+YWR2YW5jZV9wb3MgPVxuICAgICAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgICAgIGZvbGRcbiAgICAgICAgICBtYXBcbiAgICAgICAgICB+aW5pdDooYmVnaW5fa2V5LCBlbmRfa2V5LCBzdGFydF9wb3MpXG4gICAgICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhOl8gKGJlZ2luX2tleSwgZW5kX2tleSwgcG9zKSAtPlxuICAgICAgICAgIGxldCBiZWdpbl9rZXkgPSBpZiBJbnQuKCA9ICkgcG9zIGZyb20gdGhlbiBLbm93biBrZXkgZWxzZSBiZWdpbl9rZXkgaW5cbiAgICAgICAgICBsZXQgZW5kX2tleSA9IGlmIEludC4oID0gKSBwb3MgdG9fIHRoZW4gS25vd24ga2V5IGVsc2UgZW5kX2tleSBpblxuICAgICAgICAgIGlmIGlzX2tub3duIGJlZ2luX2tleSAmJiBpc19rbm93biBlbmRfa2V5XG4gICAgICAgICAgdGhlbiByZXR1cm4gKGJlZ2luX2tleSwgZW5kX2tleSwgcG9zKVxuICAgICAgICAgIGVsc2UgYmVnaW5fa2V5LCBlbmRfa2V5LCBhZHZhbmNlX3BvcyBwb3MpKVxuICAgIGluXG4gICAgbGV0IGJlZ2luX2tleSwgZW5kX2tleSwgXyA9XG4gICAgICAoKiBTZWFyY2hpbmcgZnJvbSBsZWZ0IHRha2VzIE8odG9fKSwgZnJvbSByaWdodCAtIE8obGVuIC0gZnJvbSksIHNvIHNlbGVjdCB0aGVcbiAgICAgICAgIHNtYWxsZXIgb25lLiAqKVxuICAgICAgaWYgdG9fIDwgbGVuIC0gZnJvbVxuICAgICAgdGhlbiBmaW5kX2tleXMgTWFwLmZvbGQgfnN0YXJ0X3BvczowIH5hZHZhbmNlX3BvczooZnVuIHBvcyAtPiBwb3MgKyAxKVxuICAgICAgZWxzZSBmaW5kX2tleXMgTWFwLmZvbGRfcmlnaHQgfnN0YXJ0X3BvczoobGVuIC0gMSkgfmFkdmFuY2VfcG9zOihmdW4gcG9zIC0+IHBvcyAtIDEpXG4gICAgaW5cbiAgICBPcHRpb24ubWFwIChLZXlfc3RhdHVzLnRvX29wdGlvbiBiZWdpbl9rZXkpIH5mOihmdW4gYmVnaW5fa2V5IC0+XG4gICAgICBiZWdpbl9rZXksIEtleV9zdGF0dXMudG9fb3B0aW9uIGVuZF9rZXkpXG4gIDs7XG5cbiAgbGV0IG50aF9mcm9tX2VpdGhlcl9zaWRlICh0eXBlIGspIG4gKG1hcCA6IChrLCBfLCBfKSBNYXAudCkgOiBrIG9wdGlvbiA9XG4gICAgT3B0aW9uLm1hcCB+Zjpmc3QgKGZpbmRfa2V5X3JhbmdlX2xpbmVhciB+ZnJvbTpuIH50b186biBtYXApXG4gIDs7XG5cbiAgKCoqIEZpbmQga2V5IFtieV0gcG9zaXRpb25zIGVhcmxpZXIvbGF0ZXIgaW4gYSBtYXAuIFJldHVybnMgbm9uZSBpZiBvdXQgb2YgYm91bmRzLiAqKVxuICBsZXQgcmVjIG9mZnNldCAoa2V5IDogJ2spIChtYXAgOiAoJ2ssIF8sIF8pIE1hcC50KSB+YnkgOiAnayBvcHRpb24gPVxuICAgIGlmIEludC4oID0gKSBieSAwXG4gICAgdGhlbiBTb21lIGtleVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNsb3Nlc3RfZGlyLCBhZGQgPVxuICAgICAgICBpZiBJbnQuKCA8ICkgYnkgMCB0aGVuIGBMZXNzX3RoYW4sIDEgZWxzZSBgR3JlYXRlcl90aGFuLCAtMVxuICAgICAgaW5cbiAgICAgIG1hdGNoIE1hcC5jbG9zZXN0X2tleSBtYXAgY2xvc2VzdF9kaXIga2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgKGtleSwgXykgLT4gb2Zmc2V0IGtleSBtYXAgfmJ5OihieSArIGFkZCkpXG4gIDs7XG5cbiAgKCoqIEZpbmQgaG93IHdlIG5lZWQgdG8gbW92ZSBba2V5XSBpZiBbY2hhbmdlZF9rZXldIGNoYW5nZWQgaW4gdGhlIGdpdmVuXG4gICAgICB3YXkgKilcbiAgbGV0IGZpbmRfb2Zmc2V0IH5jb21wYXJlIH5rZXkgfmNoYW5nZWRfa2V5IGNoYW5nZSA9XG4gICAgaWYgSW50LiggPCApIChjb21wYXJlIGNoYW5nZWRfa2V5IGtleSkgMFxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggY2hhbmdlIHdpdGhcbiAgICAgIHwgYExlZnQgXyAtPiAxXG4gICAgICB8IGBSaWdodCBfIC0+IC0xXG4gICAgICB8IF8gLT4gMClcbiAgICBlbHNlIDBcbiAgOztcblxuICBsZXQgcmFua1xuICAgICh0eXBlIGsgdiBjbXAgc3RhdGVfd2l0bmVzcylcbiAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICAobWFwIDogKChrLCB2LCBjbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgIChrZXkgOiAoaywgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBjb21wYXJlX2tleSA9IGNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgICAgbGV0IHNhbWVfa2V5IGEgYiA9IGNvbXBhcmVfa2V5IGEgYiA9IDAgaW5cbiAgICAgIGxldCB3aGVuX2tleV9jaGFuZ2VkIH5tYXAgfm9sZF9rZXkgfm5ld19rZXkgfm9sZF9yYW5rID1cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgbmV3X2tleSBvbGRfa2V5IDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBJZiB0aGUgbmV3IGtleSBpcyBzbWFsbGVyIHRoYW4gdGhlIG9sZCBrZXksIGZpbmQgdGhlIHNpemUgb2YgdGhlIG1hcCBzdWJyYW5nZVxuICAgICAgICAgICAgIGJldHdlZW4gdGhlbSBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcHJldmlvdXMgcmFuayAqKVxuICAgICAgICAgIGxldCBsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQgPSBFeGNsIG5ld19rZXksIEV4Y2wgb2xkX2tleSBpblxuICAgICAgICAgIGxldCBzdWJyYW5nZSA9IE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCBpblxuICAgICAgICAgIG9sZF9yYW5rIC0gTWFwLmxlbmd0aCBzdWJyYW5nZSAtIDEpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIE90aGVyd2lzZSwgdGhlIG5ldyBrZXkgaXMgbGFyZ2VyIHRoYW4gdGhlIG9sZCBrZXksIHNvIGZpbmQgdGhlIHNpemUgb2YgdGhlXG4gICAgICAgICAgICAgbWFwIHN1YnJhbmdlIGJldHdlZW4gdGhlbSBhbmQgYWRkIGl0IHRvIHRoZSBwcmV2aW91cyByYW5rICopXG4gICAgICAgICAgbGV0IGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCA9IEV4Y2wgb2xkX2tleSwgRXhjbCBuZXdfa2V5IGluXG4gICAgICAgICAgbGV0IHN1YnJhbmdlID0gTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kIGluXG4gICAgICAgICAgb2xkX3JhbmsgKyBNYXAubGVuZ3RoIHN1YnJhbmdlICsgMSlcbiAgICAgIGluXG4gICAgICBsZXQgd2hlbl9tYXBfY2hhbmdlZCB+b2xkX21hcCB+bmV3X21hcCB+a2V5IH5vbGRfcmFuayA9XG4gICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICgqIFdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGRhdGEsIHNvIG9wdGltaXplIHRoZXNlIGNoZWNrcyAqKVxuICAgICAgICAgIH5kYXRhX2VxdWFsOihmdW4gXyBfIC0+IHRydWUpXG4gICAgICAgICAgb2xkX21hcFxuICAgICAgICAgIG5ld19tYXBcbiAgICAgICAgICB+aW5pdDpvbGRfcmFua1xuICAgICAgICAgIH5mOihmdW4gYWNjIChkaWZmX2tleSwgZGlmZikgLT5cbiAgICAgICAgICAgIG1hdGNoIGRpZmYgd2l0aFxuICAgICAgICAgICAgfCBgTGVmdCBfIHdoZW4gY29tcGFyZV9rZXkgZGlmZl9rZXkga2V5IDwgMCAtPiBhY2MgLSAxXG4gICAgICAgICAgICB8IGBSaWdodCBfIHdoZW4gY29tcGFyZV9rZXkgZGlmZl9rZXkga2V5IDwgMCAtPiBhY2MgKyAxXG4gICAgICAgICAgICB8IF8gLT4gYWNjKVxuICAgICAgaW5cbiAgICAgIGxldCByZWMgcHJvY2VzcyB+KG9sZCA6ICgoaywgdiwgXykgTWFwLnQgKiBfICogXykgb3B0aW9uKSBuZXdfbWFwIChuZXdfa2V5IDogaykgPVxuICAgICAgICBpZiBub3QgKE1hcC5tZW0gbmV3X21hcCBuZXdfa2V5KVxuICAgICAgICB0aGVuIE5vbmVcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggb2xkIHdpdGhcbiAgICAgICAgICAoKiBJZiB0aGUgbWFwIGFuZCBrZXkgYXJlIHRoZSBzYW1lLCBqdXN0IHJldXNlIHRoZSBvbGQgcmFuayAqKVxuICAgICAgICAgIHwgU29tZSAob2xkX21hcCwgb2xkX2tleSwgb2xkX3JhbmspXG4gICAgICAgICAgICB3aGVuIHBoeXNfZXF1YWwgbmV3X21hcCBvbGRfbWFwICYmIHNhbWVfa2V5IG9sZF9rZXkgbmV3X2tleSAtPiBvbGRfcmFua1xuICAgICAgICAgICgqIElmIHRoZSBtYXAgaXMgdGhlIHNhbWUgYnV0IHRoZSBrZXkgY2hhbmdlZCAqKVxuICAgICAgICAgIHwgU29tZSAob2xkX21hcCwgb2xkX2tleSwgU29tZSBvbGRfcmFuaykgd2hlbiBwaHlzX2VxdWFsIG5ld19tYXAgb2xkX21hcCAtPlxuICAgICAgICAgICAgU29tZSAod2hlbl9rZXlfY2hhbmdlZCB+bWFwOm5ld19tYXAgfm9sZF9rZXkgfm5ld19rZXkgfm9sZF9yYW5rKVxuICAgICAgICAgICgqIElmIHRoZSBrZXkgaXMgdGhlIHNhbWUgYnV0IHRoZSBtYXAgY2hhbmdlZCAqKVxuICAgICAgICAgIHwgU29tZSAob2xkX21hcCwgb2xkX2tleSwgU29tZSBvbGRfcmFuaykgd2hlbiBzYW1lX2tleSBuZXdfa2V5IG9sZF9rZXkgLT5cbiAgICAgICAgICAgIFNvbWUgKHdoZW5fbWFwX2NoYW5nZWQgfm9sZF9tYXAgfm5ld19tYXAgfmtleTpuZXdfa2V5IH5vbGRfcmFuaylcbiAgICAgICAgICAoKiBJZiBib3RoIHRoZSBtYXAgYW5kIHRoZSBrZXkgY2hhbmdlZCwgdGhpcyBjYW4gYmUgc2ltdWxhdGVkIGFzIHRoZVxuICAgICAgICAgICAgIG1hcCBjaGFuZ2luZyBmb2xsb3dlZCBieSB0aGUga2V5IGNoYW5naW5nICopXG4gICAgICAgICAgfCBTb21lIChvbGRfbWFwLCBvbGRfa2V5LCBTb21lIG9sZF9yYW5rKSAtPlxuICAgICAgICAgICAgKCogV2UgY2FsbCBbcHJvY2Vzc10gcmVjdXJzaXZlbHkgaW5zdGVhZCBvZiBkaXJlY3RseSBjYWxsaW5nXG4gICAgICAgICAgICAgICBbd2hlbl9tYXBfY2hhbmdlZF0gZm9sbG93ZWQgYnkgW3doZW5fa2V5X2NoYW5nZWRdIHNpbmNlIGl0IG1pZ2h0IGJlIHRoZVxuICAgICAgICAgICAgICAgY2FzZSB0aGF0IFtvbGRfa2V5XSBpcyBpbiBbb2xkX21hcF0gYW5kIFtuZXdfa2V5XSBpcyBpbiBbbmV3X21hcF0sIGJ1dFxuICAgICAgICAgICAgICAgW29sZF9rZXldIGlzIG5vdCBpbiBbbmV3X21hcF0uICopXG4gICAgICAgICAgICBsZXQgb2xkX3JhbmsgPVxuICAgICAgICAgICAgICBwcm9jZXNzIH5vbGQ6KFNvbWUgKG9sZF9tYXAsIG9sZF9rZXksIFNvbWUgb2xkX3JhbmspKSBuZXdfbWFwIG9sZF9rZXlcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBwcm9jZXNzIH5vbGQ6KFNvbWUgKG5ld19tYXAsIG9sZF9rZXksIG9sZF9yYW5rKSkgbmV3X21hcCBuZXdfa2V5XG4gICAgICAgICAgKCogSWYgdGhlIHByZXZpb3VzIGtleSB3YXMgbm90IGluIHRoZSBtYXAgb3IgdGhpcyBpcyB0aGUgZmlyc3Qgc3RhYmlsaXphdGlvbixcbiAgICAgICAgICAgICBjb21wdXRlIHRoZSByYW5rIGZyb20gc2NyYXRjaCAqKVxuICAgICAgICAgIHwgU29tZSAoXywgXywgTm9uZSkgfCBOb25lIC0+IE1hcC5yYW5rIG5ld19tYXAgbmV3X2tleSlcbiAgICAgIGluXG4gICAgICB3aXRoX29sZDIgfmluc3RydW1lbnRhdGlvbiBtYXAga2V5IH5mOnByb2Nlc3MpXG4gIDs7XG5cbiAgKCoqIFJhbmdlIG1hcCBieSBpbmRpY2VzICopXG4gIGxldCBzdWJyYW5nZV9ieV9yYW5rXG4gICAgKHR5cGUgayBzdGF0ZV93aXRuZXNzKVxuICAgID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKVxuICAgID9kYXRhX2VxdWFsXG4gICAgKG1hcCA6ICgoaywgXywgXykgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgKHJhbmdlIDogKGludCBNYXliZV9ib3VuZC50ICogaW50IE1heWJlX2JvdW5kLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgPVxuICAgIGxldCBmaW5kX2tleV9yYW5nZSAocmFuZ2UgOiAoaW50ICogaW50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgICAgOiAoKGsgKiBrIG9wdGlvbikgb3B0aW9uLCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgICA9XG4gICAgICB3aXRoX29sZDIgbWFwIHJhbmdlIH5pbnN0cnVtZW50YXRpb24gfmY6KGZ1biB+b2xkIG1hcCAoZnJvbSwgdG9fKSAtPlxuICAgICAgICAoKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgbm8ga2V5cywgb25seSBiZWdpbiBrZXksIG9yIGJlZ2luIGFuZCBlbmQga2V5cy5cbiAgICAgICAgICAgVGhlc2UgYXJlIHRoZSBrZXlzIGF0IFtmcm9tXSBhbmQgW3RvX10gcG9zaXRpb25zIGluIHRoZSBtYXAsIG9yIE5vbmUgaWYgdGhlXG4gICAgICAgICAgIGluZGljZXMgYXJlIHRvbyBiaWcuIEFzIGFsd2F5cyBbMCA8PSBmcm9tICYmIGZyb20gPD0gdG9fXSwgdGhlcmUgaXMgbm9cbiAgICAgICAgICAgcG9zc2liaWxpdHkgb2Ygb25seSBbdG9fXSBiZWluZyBhIHZhbGlkIHBvc2l0aW9uLlxuICAgICAgICAqKVxuICAgICAgICBpZiBJbnQuKCA8ICkgdG9fIGZyb20gfHwgSW50LiggPCApIGZyb20gMFxuICAgICAgICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiSW52YWxpZCBpbmRpY2VzXCIgKGZyb20gOiBpbnQpICh0b18gOiBpbnQpXTtcbiAgICAgICAgbWF0Y2ggb2xkIHdpdGhcbiAgICAgICAgfCBTb21lIChvbGRfbWFwLCAob2xkX2Zyb20sIG9sZF90byksIFNvbWUgKGJlZ2luX2tleSwgZW5kX2tleV9vcHQpKSAtPlxuICAgICAgICAgIGxldCBmaW5kX29mZnNldCA9IGZpbmRfb2Zmc2V0IH5jb21wYXJlOihNYXAuY29tcGFyYXRvciBtYXApLmNvbXBhcmUgaW5cbiAgICAgICAgICBsZXQgcmFuZ2Vfb2Zmc2V0X2JlZ2luID0gZnJvbSAtIG9sZF9mcm9tIGluXG4gICAgICAgICAgbGV0IHJhbmdlX29mZnNldF9lbmQgPSB0b18gLSBvbGRfdG8gaW5cbiAgICAgICAgICBsZXQgYWRqdXN0X2FuZF9vZmZzZXQgfmJ5IGtleSA9XG4gICAgICAgICAgICBsZXQgYnkgPSBieSArIGlmIGJ5ID49IDAgJiYgbm90IChNYXAubWVtIG1hcCBrZXkpIHRoZW4gMSBlbHNlIDAgaW5cbiAgICAgICAgICAgIG9mZnNldCBrZXkgbWFwIH5ieVxuICAgICAgICAgIGluXG4gICAgICAgICAgKCogV2Ugb25seSBjYXJlIGFib3V0IHRoZSBrZXlzIGNoYW5naW5nIGFuZCBub3QgdGhlIGRhdGEsIHNvIFtkYXRhX2VxdWFsXSBoZXJlXG4gICAgICAgICAgICAgY2FuIGJlIGFsd2F5cyB0cnVlICopXG4gICAgICAgICAgbGV0IGRpZmYgfmluaXQgfmYgPVxuICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmYgfmRhdGFfZXF1YWw6KGZ1biBfIF8gLT4gdHJ1ZSkgb2xkX21hcCBtYXAgfmluaXQgfmZcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBiZWdpbl9rZXlfb3B0LCBlbmRfa2V5X29wdCA9XG4gICAgICAgICAgICBtYXRjaCBlbmRfa2V5X29wdCB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgZW5kX2tleSAtPlxuICAgICAgICAgICAgICBsZXQgbWFwX29mZnNldF9iZWdpbiwgbWFwX29mZnNldF9lbmQgPVxuICAgICAgICAgICAgICAgIGRpZmYgfmluaXQ6KDAsIDApIH5mOihmdW4gKG9mZnNldF9iZWdpbiwgb2Zmc2V0X2VuZCkgKGtleSwgY2hhbmdlKSAtPlxuICAgICAgICAgICAgICAgICAgKCBvZmZzZXRfYmVnaW4gKyBmaW5kX29mZnNldCB+a2V5OmJlZ2luX2tleSB+Y2hhbmdlZF9rZXk6a2V5IGNoYW5nZVxuICAgICAgICAgICAgICAgICAgLCBvZmZzZXRfZW5kICsgZmluZF9vZmZzZXQgfmtleTplbmRfa2V5IH5jaGFuZ2VkX2tleTprZXkgY2hhbmdlICkpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICggYWRqdXN0X2FuZF9vZmZzZXQgYmVnaW5fa2V5IH5ieToobWFwX29mZnNldF9iZWdpbiArIHJhbmdlX29mZnNldF9iZWdpbilcbiAgICAgICAgICAgICAgLCBhZGp1c3RfYW5kX29mZnNldCBlbmRfa2V5IH5ieToobWFwX29mZnNldF9lbmQgKyByYW5nZV9vZmZzZXRfZW5kKSApXG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgbGV0IG1hcF9vZmZzZXRfYmVnaW4gPVxuICAgICAgICAgICAgICAgIGRpZmYgfmluaXQ6MCB+ZjooZnVuIG9mZnNldF9iZWdpbiAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICAgICAgICBvZmZzZXRfYmVnaW4gKyBmaW5kX29mZnNldCB+a2V5OmJlZ2luX2tleSB+Y2hhbmdlZF9rZXk6a2V5IGNoYW5nZSlcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgKCBhZGp1c3RfYW5kX29mZnNldCBiZWdpbl9rZXkgfmJ5OihtYXBfb2Zmc2V0X2JlZ2luICsgcmFuZ2Vfb2Zmc2V0X2JlZ2luKVxuICAgICAgICAgICAgICAsIG50aF9mcm9tX2VpdGhlcl9zaWRlIHRvXyBtYXAgKVxuICAgICAgICAgIGluXG4gICAgICAgICAgYXNzZXJ0IChPcHRpb24uZm9yX2FsbCB+ZjooTWFwLm1lbSBtYXApIGJlZ2luX2tleV9vcHQpO1xuICAgICAgICAgIGFzc2VydCAoT3B0aW9uLmZvcl9hbGwgfmY6KE1hcC5tZW0gbWFwKSBlbmRfa2V5X29wdCk7XG4gICAgICAgICAgT3B0aW9uLm1hcCBiZWdpbl9rZXlfb3B0IH5mOihmdW4gYmVnaW5fa2V5IC0+IGJlZ2luX2tleSwgZW5kX2tleV9vcHQpXG4gICAgICAgIHwgTm9uZSB8IFNvbWUgKF8sIF8sIE5vbmUpIC0+XG4gICAgICAgICAgKCogT24gZmlyc3QgcnVuICh3aGVuIHdlIGhhdmUgdG8pIG9yIHdoZW4gYm90aCB0aGUga2V5cyBhcmUgbm9uZSwgcnVuIE8obilcbiAgICAgICAgICAgICBzY2FuLiBUaGlzIGlzIGZpbmUgZm9yIGtleXMtYXJlLW5vbmUgY2FzZSBhcyBpdCBoYXBwZW5zIHdoZW4gdGhlIHBvc2l0aW9uc1xuICAgICAgICAgICAgIGFyZSBwYXN0IGVuZCBvZiB0aGUgbWFwLCBzbyB0aGV5IHNob3VsZG4ndCBiZSB0b28gZmFyIGZyb20gZW5kIGFmdGVyIHRoZVxuICAgICAgICAgICAgIG1hcCBjaGFuZ2VzLCBhbmQgW2ZpbmRfa2V5X3JhbmdlX2xpbmVhcl0gaXMgZmFzdCBpbiBzdWNoIGNhc2UuICopXG4gICAgICAgICAgZmluZF9rZXlfcmFuZ2VfbGluZWFyIG1hcCB+ZnJvbSB+dG9fKVxuICAgIGluXG4gICAgKCogSGFuZGxlIGRpZmZlcmVudCBNYXliZV9ib3VuZCBjYXNlcyBhbmQgY2FsbCBmaW5kX2tleV9yYW5nZSBpZiBuZWNlc3NhcnkuIEl0J3NcbiAgICAgICBuaWNlciB0byBkbyB0aGlzIGhlcmUgYXMgb3Bwb3NlZCB0byBtYWtpbmcgZmluZF9rZXlfcmFuZ2UgZXZlbiBtb3JlIGNvbXBsaWNhdGVkICopXG4gICAgbGV0IG9wZW4gSW5jcmVtZW50YWwuTGV0X3N5bnRheCBpblxuICAgIGxldCAoID4+PiApIG5ld18gYm91bmQgPSBNYXliZV9ib3VuZC5tYXAgfmY6KGZ1biBfIC0+IG5ld18pIGJvdW5kIGluXG4gICAgbGV0IHJldHVybiA9IEluY3JlbWVudGFsLnJldHVybiAoSW5jcmVtZW50YWwuc3RhdGUgbWFwKSBpblxuICAgIGxldCBrZXlfcmFuZ2UgPVxuICAgICAgbWF0Y2glcGF0dGVybl9iaW5kIHJhbmdlIHdpdGhcbiAgICAgIHwgTWF5YmVfYm91bmQuVW5ib3VuZGVkLCBNYXliZV9ib3VuZC5VbmJvdW5kZWQgLT5cbiAgICAgICAgcmV0dXJuIChTb21lIChNYXliZV9ib3VuZC5VbmJvdW5kZWQsIE1heWJlX2JvdW5kLlVuYm91bmRlZCkpXG4gICAgICB8ICggKChNYXliZV9ib3VuZC5JbmNsIGwgfCBNYXliZV9ib3VuZC5FeGNsIGwpIGFzIGxiKVxuICAgICAgICAsICgoTWF5YmVfYm91bmQuSW5jbCB1IHwgTWF5YmVfYm91bmQuRXhjbCB1KSBhcyB1YikgKSAtPlxuICAgICAgICBsZXQlbWFwIGtleV9yYW5nZSA9IGZpbmRfa2V5X3JhbmdlIChJbmNyZW1lbnRhbC5ib3RoIGwgdSlcbiAgICAgICAgYW5kIGxiID0gbGJcbiAgICAgICAgYW5kIHViID0gdWIgaW5cbiAgICAgICAgKG1hdGNoIGtleV9yYW5nZSB3aXRoXG4gICAgICAgICB8IFNvbWUgKGJlZ2luX2tleSwgU29tZSBlbmRfa2V5KSAtPiBTb21lIChiZWdpbl9rZXkgPj4+IGxiLCBlbmRfa2V5ID4+PiB1YilcbiAgICAgICAgIHwgU29tZSAoYmVnaW5fa2V5LCBOb25lKSAtPiBTb21lIChiZWdpbl9rZXkgPj4+IGxiLCBVbmJvdW5kZWQpXG4gICAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICAgIHwgKChNYXliZV9ib3VuZC5JbmNsIGwgfCBNYXliZV9ib3VuZC5FeGNsIGwpIGFzIGxiKSwgTWF5YmVfYm91bmQuVW5ib3VuZGVkIC0+XG4gICAgICAgIGxldCVtYXAga2V5X3JhbmdlID0gZmluZF9rZXlfcmFuZ2UgKEluY3JlbWVudGFsLmJvdGggbCBsKVxuICAgICAgICBhbmQgbGIgPSBsYiBpblxuICAgICAgICAobWF0Y2gga2V5X3JhbmdlIHdpdGhcbiAgICAgICAgIHwgU29tZSAoa2V5LCBfKSAtPiBTb21lIChrZXkgPj4+IGxiLCBVbmJvdW5kZWQpXG4gICAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICAgIHwgTWF5YmVfYm91bmQuVW5ib3VuZGVkLCAoKE1heWJlX2JvdW5kLkluY2wgdSB8IE1heWJlX2JvdW5kLkV4Y2wgdSkgYXMgdWIpIC0+XG4gICAgICAgIGxldCVtYXAga2V5X3JhbmdlID0gZmluZF9rZXlfcmFuZ2UgKEluY3JlbWVudGFsLmJvdGggdSB1KVxuICAgICAgICBhbmQgdWIgPSB1YiBpblxuICAgICAgICAobWF0Y2gga2V5X3JhbmdlIHdpdGhcbiAgICAgICAgIHwgU29tZSAoa2V5LCBfKSAtPiBTb21lIChVbmJvdW5kZWQsIGtleSA+Pj4gdWIpXG4gICAgICAgICAoKiBJbiB0aGlzIGNhc2UsIHRoZSB1cHBlciBib3VuZCB3YXMgbGFyZ2VyIHRoYW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGVcbiAgICAgICAgICAgIG1hcCwgc28gdGhlIHVwcGVyIGJvdW5kIGZvciB0aGUga2V5IHJhbmdlIGlzIFtVbmJvdW5kZWRdLlxuICAgICAgICAgICAgVGhpcyBiZWhhdmlvciBpcyBkZW1vbnN0cmF0ZWQgaW4gYSB0ZXN0IGluIFsuLi90ZXN0L3Rlc3Rfc3VicmFuZ2UubWxdLiAqKVxuICAgICAgICAgfCBOb25lIC0+IFNvbWUgKFVuYm91bmRlZCwgVW5ib3VuZGVkKSlcbiAgICBpblxuICAgIHN1YnJhbmdlID9kYXRhX2VxdWFsIG1hcCBrZXlfcmFuZ2VcbiAgOztcblxuICBsZXQgdHJhbnNwb3NlXG4gICAgOiB0eXBlIGsxIGsyIHYgazFfY21wIGsyX2NtcCBzdGF0ZV93aXRuZXNzLlxuICAgICAgP2luc3RydW1lbnRhdGlvbjpJbnN0cnVtZW50YXRpb24udFxuICAgICAgLT4gP2RhdGFfZXF1YWw6KHYgLT4gdiAtPiBib29sKVxuICAgICAgLT4gKGsyLCBrMl9jbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAgIC0+ICgoazEsIChrMiwgdiwgazJfY21wKSBNYXAudCwgazFfY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgLT4gKChrMiwgKGsxLCB2LCBrMV9jbXApIE1hcC50LCBrMl9jbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgPVxuICAgIGZ1biA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbikgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbCkgazJfY29tcGFyYXRvciBtIC0+XG4gICAgd2l0aF9jb21wYXJhdG9yIG0gKGZ1biBrMV9jb21wYXJhdG9yIC0+XG4gICAgICBsZXQgdXBkYXRlXG4gICAgICAgIDogIGtleTprMSAtPiBvbGRfZGF0YTooazIsIHYsIGsyX2NtcCkgTWFwLnQgLT4gbmV3X2RhdGE6KGsyLCB2LCBrMl9jbXApIE1hcC50XG4gICAgICAgIC0+IChrMiwgKGsxLCB2LCBrMV9jbXApIE1hcC50LCBrMl9jbXApIE1hcC50XG4gICAgICAgIC0+IChrMiwgKGsxLCB2LCBrMV9jbXApIE1hcC50LCBrMl9jbXApIE1hcC50XG4gICAgICAgID1cbiAgICAgICAgZnVuIH5rZXk6azEgfm9sZF9kYXRhIH5uZXdfZGF0YSBhY2MgLT5cbiAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICBvbGRfZGF0YVxuICAgICAgICAgIG5ld19kYXRhXG4gICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICB+aW5pdDphY2NcbiAgICAgICAgICB+ZjooZnVuIGFjYyAoazIsIGRpZmYpIC0+XG4gICAgICAgICAgbGV0IHZhbHVlID1cbiAgICAgICAgICAgIG1hdGNoIGRpZmYgd2l0aFxuICAgICAgICAgICAgfCBgTGVmdCBfIC0+IE5vbmVcbiAgICAgICAgICAgIHwgYFJpZ2h0IHggfCBgVW5lcXVhbCAoXywgeCkgLT4gU29tZSB4XG4gICAgICAgICAgaW5cbiAgICAgICAgICBNYXAuY2hhbmdlIGFjYyBrMiB+ZjooZnVuIGFjY19pbm5lciAtPlxuICAgICAgICAgICAgbGV0IGFjY19pbm5lciA9XG4gICAgICAgICAgICAgIE1hcC5jaGFuZ2VcbiAgICAgICAgICAgICAgICAoT3B0aW9uLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgYWNjX2lubmVyXG4gICAgICAgICAgICAgICAgICAgfmRlZmF1bHQ6KE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOmsxX2NvbXBhcmF0b3IpKVxuICAgICAgICAgICAgICAgIGsxXG4gICAgICAgICAgICAgICAgfmY6KGZ1biBfIC0+IHZhbHVlKVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGlmIE1hcC5pc19lbXB0eSBhY2NfaW5uZXIgdGhlbiBOb25lIGVsc2UgU29tZSBhY2NfaW5uZXIpKVxuICAgICAgaW5cbiAgICAgIGxldCBhZGQgfmtleSB+ZGF0YSA9XG4gICAgICAgIHVwZGF0ZSB+a2V5IH5vbGRfZGF0YTooTWFwLmVtcHR5IGsyX2NvbXBhcmF0b3IpIH5uZXdfZGF0YTpkYXRhXG4gICAgICBpblxuICAgICAgbGV0IHJlbW92ZSB+a2V5IH5kYXRhID1cbiAgICAgICAgdXBkYXRlIH5rZXkgfm9sZF9kYXRhOmRhdGEgfm5ld19kYXRhOihNYXAuZW1wdHkgazJfY29tcGFyYXRvcilcbiAgICAgIGluXG4gICAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgICBtXG4gICAgICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICAgICAgfmluaXQ6KE1hcC5lbXB0eSBrMl9jb21wYXJhdG9yKVxuICAgICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICAgIH51cGRhdGVcbiAgICAgICAgfmFkZFxuICAgICAgICB+cmVtb3ZlKVxuICA7O1xuXG4gIGxldCBjb2xsYXBzZV9ieVxuICAgICh0eXBlIG91dGVyX2tleSBvdXRlcl9jbXAgaW5uZXJfa2V5IGlubmVyX2NtcCBjb21iaW5lZF9rZXkgY29tYmluZWRfY21wKVxuICAgID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKVxuICAgID9kYXRhX2VxdWFsXG4gICAgKG1hcF9pbmNyIDpcbiAgICAgICgob3V0ZXJfa2V5LCAoaW5uZXJfa2V5LCBfLCBpbm5lcl9jbXApIE1hcC50LCBvdXRlcl9jbXApIE1hcC50LCBfKSBJbmNyZW1lbnRhbC50KVxuICAgIH4obWVyZ2Vfa2V5cyA6IG91dGVyX2tleSAtPiBpbm5lcl9rZXkgLT4gY29tYmluZWRfa2V5KVxuICAgIH4oY29tcGFyYXRvciA6IChjb21iaW5lZF9rZXksIGNvbWJpbmVkX2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudClcbiAgICA9XG4gICAgdW5vcmRlcmVkX2ZvbGRfbmVzdGVkX21hcHNcbiAgICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICBtYXBfaW5jclxuICAgICAgfmluaXQ6KE1hcC5lbXB0eSBjb21wYXJhdG9yKVxuICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgfnVwZGF0ZTooZnVuIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+b2xkX2RhdGE6XyB+bmV3X2RhdGEgYWNjIC0+XG4gICAgICAgIE1hcC5zZXQgYWNjIH5rZXk6KG1lcmdlX2tleXMgb3V0ZXJfa2V5IGlubmVyX2tleSkgfmRhdGE6bmV3X2RhdGEpXG4gICAgICB+YWRkOihmdW4gfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhIGFjYyAtPlxuICAgICAgICBNYXAuYWRkX2V4biBhY2MgfmtleToobWVyZ2Vfa2V5cyBvdXRlcl9rZXkgaW5uZXJfa2V5KSB+ZGF0YSlcbiAgICAgIH5yZW1vdmU6KGZ1biB+b3V0ZXJfa2V5IH5pbm5lcl9rZXkgfmRhdGE6XyBhY2MgLT5cbiAgICAgICAgTWFwLnJlbW92ZSBhY2MgKG1lcmdlX2tleXMgb3V0ZXJfa2V5IGlubmVyX2tleSkpXG4gIDs7XG5cbiAgbGV0IGNvbGxhcHNlXG4gICAgKHR5cGUgb3V0ZXJfa2V5IG91dGVyX2NtcCBpbm5lcl9rZXkgaW5uZXJfY21wKVxuICAgID9pbnN0cnVtZW50YXRpb25cbiAgICA/ZGF0YV9lcXVhbFxuICAgIChtYXBfaW5jciA6XG4gICAgICAoKG91dGVyX2tleSwgKGlubmVyX2tleSwgXywgaW5uZXJfY21wKSBNYXAudCwgb3V0ZXJfY21wKSBNYXAudCwgXykgSW5jcmVtZW50YWwudClcbiAgICB+Y29tcGFyYXRvcjooaW5uZXJfY29tcGFyYXRvciA6IChpbm5lcl9rZXksIGlubmVyX2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudClcbiAgICA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcF9pbmNyIChmdW4gb3V0ZXJfY29tcGFyYXRvciAtPlxuICAgICAgbGV0IG1vZHVsZSBDbXAgPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gb3V0ZXJfa2V5ICogaW5uZXJfa2V5XG4gICAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gKG91dGVyX2NtcCwgaW5uZXJfY21wKSBUdXBsZTIuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgICAgICAgbGV0IGNvbXBhcmF0b3IgPVxuICAgICAgICAgIGxldCBpbm5lcl9jb21wYXJhdG9yID1cbiAgICAgICAgICAgIGxldCBtb2R1bGUgTSA9ICh2YWwgaW5uZXJfY29tcGFyYXRvcikgaW5cbiAgICAgICAgICAgIE0uY29tcGFyYXRvclxuICAgICAgICAgIGluXG4gICAgICAgICAgVHVwbGUyLmNvbXBhcmF0b3Igb3V0ZXJfY29tcGFyYXRvciBpbm5lcl9jb21wYXJhdG9yXG4gICAgICAgIDs7XG4gICAgICBlbmRcbiAgICAgIGluXG4gICAgICBjb2xsYXBzZV9ieVxuICAgICAgICA/aW5zdHJ1bWVudGF0aW9uXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIG1hcF9pbmNyXG4gICAgICAgIH5tZXJnZV9rZXlzOlR1cGxlMi5jcmVhdGVcbiAgICAgICAgfmNvbXBhcmF0b3I6KG1vZHVsZSBDbXApKVxuICA7O1xuXG4gIGxldCBleHBhbmRcbiAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICA/ZGF0YV9lcXVhbFxuICAgIG1hcF9pbmNyXG4gICAgfm91dGVyX2NvbXBhcmF0b3JcbiAgICB+aW5uZXJfY29tcGFyYXRvclxuICAgID1cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgP2RhdGFfZXF1YWxcbiAgICAgIG1hcF9pbmNyXG4gICAgICB+aW5pdDooTWFwLmVtcHR5IG91dGVyX2NvbXBhcmF0b3IpXG4gICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICB+dXBkYXRlOihmdW4gfmtleToob3V0ZXJfa2V5LCBpbm5lcl9rZXkpIH5vbGRfZGF0YTpfIH5uZXdfZGF0YSBhY2MgLT5cbiAgICAgICAgTWFwLnVwZGF0ZSBhY2Mgb3V0ZXJfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBNYXAuc2luZ2xldG9uIGlubmVyX2NvbXBhcmF0b3IgaW5uZXJfa2V5IG5ld19kYXRhXG4gICAgICAgICAgfCBTb21lIG1hcCAtPiBNYXAuc2V0IG1hcCB+a2V5OmlubmVyX2tleSB+ZGF0YTpuZXdfZGF0YSkpXG4gICAgICB+YWRkOihmdW4gfmtleToob3V0ZXJfa2V5LCBpbm5lcl9rZXkpIH5kYXRhIGFjYyAtPlxuICAgICAgICBNYXAudXBkYXRlIGFjYyBvdXRlcl9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IE1hcC5zaW5nbGV0b24gaW5uZXJfY29tcGFyYXRvciBpbm5lcl9rZXkgZGF0YVxuICAgICAgICAgIHwgU29tZSBtYXAgLT4gTWFwLmFkZF9leG4gbWFwIH5rZXk6aW5uZXJfa2V5IH5kYXRhKSlcbiAgICAgIH5yZW1vdmU6KGZ1biB+a2V5OihvdXRlcl9rZXksIGlubmVyX2tleSkgfmRhdGE6XyBhY2MgLT5cbiAgICAgICAgTWFwLmNoYW5nZSBhY2Mgb3V0ZXJfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lIG1hcCAtPlxuICAgICAgICAgICAgbGV0IG1hcCA9IE1hcC5yZW1vdmUgbWFwIGlubmVyX2tleSBpblxuICAgICAgICAgICAgT3B0aW9uLnNvbWVfaWYgKG5vdCAoTWFwLmlzX2VtcHR5IG1hcCkpIG1hcCkpXG4gIDs7XG5cbiAgbGV0IGNvdW50aSA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbikgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIHVub3JkZXJlZF9mb2xkXG4gICAgICB+aW5zdHJ1bWVudGF0aW9uXG4gICAgICA/ZGF0YV9lcXVhbFxuICAgICAgbWFwX2luY3JcbiAgICAgIH5pbml0OjBcbiAgICAgIH5yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OnRydWVcbiAgICAgIH5hZGQ6KGZ1biB+a2V5IH5kYXRhIGNvdW50IC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIGNvdW50ICsgMSBlbHNlIGNvdW50KVxuICAgICAgfnJlbW92ZTooZnVuIH5rZXkgfmRhdGEgY291bnQgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gY291bnQgLSAxIGVsc2UgY291bnQpXG4gIDs7XG5cbiAgbGV0IGNvdW50ID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIGNvdW50aSA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgZXhpc3RzaSA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mID1cbiAgICBJbmNyZW1lbnRhbC5tYXAgKGNvdW50aSA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mKSB+ZjooZnVuIGNvdW50IC0+XG4gICAgICBjb3VudCA8PiAwKVxuICA7O1xuXG4gIGxldCBleGlzdHMgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgZXhpc3RzaSA/aW5zdHJ1bWVudGF0aW9uID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgc3VtXG4gICAgKHR5cGUgdSlcbiAgICA/KGluc3RydW1lbnRhdGlvbiA9IG5vX2luc3RydW1lbnRhdGlvbilcbiAgICA/ZGF0YV9lcXVhbFxuICAgIChtYXBfaW5jciA6ICgoXywgXywgXykgTWFwLnQsIF8pIEluY3JlbWVudGFsLnQpXG4gICAgKG1vZHVsZSBHcm91cCA6IEFic3RyYWN0X2FsZ2VicmEuQ29tbXV0YXRpdmVfZ3JvdXAuV2l0aG91dF9zZXhwIHdpdGggdHlwZSB0ID0gdSlcbiAgICB+ZlxuICAgID1cbiAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgP2RhdGFfZXF1YWxcbiAgICAgIG1hcF9pbmNyXG4gICAgICB+aW5pdDpHcm91cC56ZXJvXG4gICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICB+YWRkOihmdW4gfmtleTpfIH5kYXRhOnYgYWNjIC0+IEdyb3VwLiggKyApIGFjYyAoZiB2KSlcbiAgICAgIH5yZW1vdmU6KGZ1biB+a2V5Ol8gfmRhdGE6diBhY2MgLT4gR3JvdXAuKCAtICkgYWNjIChmIHYpKVxuICA7O1xuXG4gIGxldCBvYnNlcnZlX2NoYW5nZXNfZXhuID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpIG1hcCB+ZiA9XG4gICAgbGV0IHN0YXRlID0gSW5jcmVtZW50YWwuc3RhdGUgbWFwIGluXG4gICAgbGV0IHNjb3BlID0gSW5jcmVtZW50YWwuU2NvcGUuY3VycmVudCBzdGF0ZSAoKSBpblxuICAgIGlmIG5vdCAoSW5jcmVtZW50YWwuU2NvcGUuaXNfdG9wIHNjb3BlKVxuICAgIHRoZW4gZmFpbHdpdGggXCJbSW5jcl9tYXAub2JzZXJ2ZV9jaGFuZ2VzX2V4bl0gY2FsbGVkIGluIHNjb3BlIHRoYXQgaXMgbm90IHRvcC1sZXZlbFwiO1xuICAgIGxldCBvbl9kaWZmIHYxIHYyID1cbiAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmIHYxIHYyIH5kYXRhX2VxdWFsIH5pbml0OigpIH5mOihmdW4gKCkgdXBkYXRlIC0+IGYgdXBkYXRlKVxuICAgIGluXG4gICAgbGV0IGVtcHR5X3ZlcnNpb25fb2YgbWFwID0gTWFwLmVtcHR5IChNYXAuY29tcGFyYXRvcl9zIG1hcCkgaW5cbiAgICBsZXQgb2JzZXJ2ZXIgPSBJbmNyZW1lbnRhbC5vYnNlcnZlIG1hcCBpblxuICAgIEluY3JlbWVudGFsLk9ic2VydmVyLm9uX3VwZGF0ZV9leG4gb2JzZXJ2ZXIgfmY6KGZ1biBkaWZmX2VsdCAtPlxuICAgICAgbGV0IGJlZm9yZV9hbmRfYWZ0ZXIgPVxuICAgICAgICBtYXRjaCBkaWZmX2VsdCB3aXRoXG4gICAgICAgIHwgSW52YWxpZGF0ZWQgLT5cbiAgICAgICAgICAobWF0Y2ggSW5jcmVtZW50YWwuT2JzZXJ2ZXIudmFsdWUgb2JzZXJ2ZXIgd2l0aFxuICAgICAgICAgICB8IE9rIGZpbmFsX3ZhbHVlIC0+IFNvbWUgKGZpbmFsX3ZhbHVlLCBlbXB0eV92ZXJzaW9uX29mIGZpbmFsX3ZhbHVlKVxuICAgICAgICAgICB8IEVycm9yIF8gLT4gTm9uZSlcbiAgICAgICAgfCBJbml0aWFsaXplZCB2IC0+IFNvbWUgKGVtcHR5X3ZlcnNpb25fb2YgdiwgdilcbiAgICAgICAgfCBDaGFuZ2VkICh2MSwgdjIpIC0+IFNvbWUgKHYxLCB2MilcbiAgICAgIGluXG4gICAgICBtYXRjaCBiZWZvcmVfYW5kX2FmdGVyIHdpdGhcbiAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIChiZWZvcmUsIGFmdGVyKSAtPiBvbl9kaWZmIGJlZm9yZSBhZnRlcilcbiAgOztcblxuICBsZXQgZm9yX2FsbGkgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgSW5jcmVtZW50YWwubWFwXG4gICAgICAoY291bnRpID9pbnN0cnVtZW50YXRpb24gP2RhdGFfZXF1YWwgbWFwX2luY3IgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgICBub3QgKGYgfmtleSB+ZGF0YSkpKVxuICAgICAgfmY6KGZ1biBjb3VudCAtPiBjb3VudCA9IDApXG4gIDs7XG5cbiAgbGV0IGZvcl9hbGwgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZiA9XG4gICAgZm9yX2FsbGkgP2luc3RydW1lbnRhdGlvbiA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHVub3JkZXJlZF9mb2xkXG4gICAgPyhpbnN0cnVtZW50YXRpb24gPSBub19pbnN0cnVtZW50YXRpb24pXG4gICAgP2RhdGFfZXF1YWxcbiAgICA/dXBkYXRlXG4gICAgP3NwZWNpYWxpemVkX2luaXRpYWxcbiAgICA/ZmluYWxpemVcbiAgICA/cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eVxuICAgIG1hcFxuICAgIH5pbml0XG4gICAgfmFkZFxuICAgIH5yZW1vdmVcbiAgICA9XG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgIH5pbnN0cnVtZW50YXRpb25cbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICA/dXBkYXRlXG4gICAgICA/c3BlY2lhbGl6ZWRfaW5pdGlhbFxuICAgICAgP2ZpbmFsaXplXG4gICAgICA/cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eVxuICAgICAgbWFwXG4gICAgICB+aW5pdFxuICAgICAgfmFkZFxuICAgICAgfnJlbW92ZVxuICA7O1xuXG4gIGxldCB1bm9yZGVyZWRfZm9sZF9uZXN0ZWRfbWFwc1xuICAgID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKVxuICAgID9kYXRhX2VxdWFsXG4gICAgP3JldmVydF90b19pbml0X3doZW5fZW1wdHlcbiAgICA/dXBkYXRlXG4gICAgbWFwXG4gICAgfmluaXRcbiAgICB+YWRkXG4gICAgfnJlbW92ZVxuICAgID1cbiAgICB1bm9yZGVyZWRfZm9sZF9uZXN0ZWRfbWFwc1xuICAgICAgfmluc3RydW1lbnRhdGlvblxuICAgICAgP2RhdGFfZXF1YWxcbiAgICAgID9yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5XG4gICAgICA/dXBkYXRlXG4gICAgICBtYXBcbiAgICAgIH5pbml0XG4gICAgICB+YWRkXG4gICAgICB+cmVtb3ZlXG4gIDs7XG5cbiAgbW9kdWxlIEZvcl90ZXN0aW5nID0gc3RydWN0XG4gICAgbGV0IGZpbmRfa2V5X3JhbmdlX2xpbmVhciA9IGZpbmRfa2V5X3JhbmdlX2xpbmVhclxuICBlbmRcblxuICBtb2R1bGUgTG9va3VwID0gc3RydWN0XG4gICAgdHlwZSAoJ3YsICd3KSBlbnRyeSA9XG4gICAgICB7IG11dGFibGUgc2F2ZWRfdmFsdWUgOiAndiBvcHRpb25cbiAgICAgIDsgbm9kZSA6ICgndiBvcHRpb24sICd3KSBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS50XG4gICAgICB9XG5cbiAgICB0eXBlICgnaywgJ3YsICdjbXAsICd3KSB0ID1cbiAgICAgIHsgbXV0YWJsZSBzYXZlZF9tYXAgOiAoJ2ssICd2LCAnY21wKSBNYXAudFxuICAgICAgICAgICgqIFdlIG1heSBoYXZlIG11bHRpcGxlIGVudHJpZXMgcGVyIGtleSBpZiBub2RlcyBiZWNvbWUgbmVjZXNzYXJ5IGFnYWluIGFmdGVyIGJlaW5nXG4gICAgICAgICByZW1vdmVkLiAqKVxuICAgICAgOyBtdXRhYmxlIGxvb2t1cF9lbnRyaWVzIDogKCdrLCAoJ3YsICd3KSBlbnRyeSBsaXN0LCAnY21wKSBNYXAudFxuICAgICAgOyB1cGRhdGVyX25vZGUgOiAodW5pdCwgJ3cpIEluY3JlbWVudGFsLnRcbiAgICAgIDsgc2NvcGUgOiAndyBJbmNyZW1lbnRhbC5TY29wZS50XG4gICAgICB9XG5cbiAgICBtb2R1bGUgTSAoSyA6IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZCkgPVxuICAgIHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgKCd2LCAndykgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcywgJ3cpIHRcbiAgICBlbmRcblxuICAgIGxldCBjcmVhdGVcbiAgICAgID8oaW5zdHJ1bWVudGF0aW9uID0gbm9faW5zdHJ1bWVudGF0aW9uKVxuICAgICAgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbClcbiAgICAgIGlucHV0X21hcFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgID1cbiAgICAgIGxldCByZWMgc2VsZiA9XG4gICAgICAgIGxhenlcbiAgICAgICAgICAobGV0IHVwZGF0ZXJfbm9kZSA9XG4gICAgICAgICAgICAgSW5jcmVtZW50YWwubWFwIGlucHV0X21hcCB+ZjooZnVuIGlucHV0X21hcCAtPlxuICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLkluc3RydW1lbnRhdGlvbi5mIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICAgbGV0IChsYXp5IHNlbGYpID0gc2VsZiBpblxuICAgICAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgICAgIHNlbGYuc2F2ZWRfbWFwXG4gICAgICAgICAgICAgICAgICAgaW5wdXRfbWFwXG4gICAgICAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgICAgICB+aW5pdDooKVxuICAgICAgICAgICAgICAgICAgIH5mOihmdW4gKCkgKGtleSwgY2hhbmdlZF92YWx1ZSkgLT5cbiAgICAgICAgICAgICAgICAgICBsZXQgZW50cmllcyA9IE1hcC5maW5kX211bHRpIHNlbGYubG9va3VwX2VudHJpZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgTGlzdC5pdGVyIGVudHJpZXMgfmY6KGZ1biBlbnRyeSAtPlxuICAgICAgICAgICAgICAgICAgICAgZW50cnkuc2F2ZWRfdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgPC0gKG1hdGNoIGNoYW5nZWRfdmFsdWUgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+IE5vbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYFJpZ2h0IG5ld192YWx1ZSB8IGBVbmVxdWFsIChfLCBuZXdfdmFsdWUpIC0+IFNvbWUgbmV3X3ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLm1ha2Vfc3RhbGUgZW50cnkubm9kZSkpO1xuICAgICAgICAgICAgICAgICBzZWxmLnNhdmVkX21hcCA8LSBpbnB1dF9tYXApKVxuICAgICAgICAgICBpblxuICAgICAgICAgICBsZXQgZW1wdHlfbWFwID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICAgICAgICAgeyBzYXZlZF9tYXAgPSBlbXB0eV9tYXBcbiAgICAgICAgICAgOyBsb29rdXBfZW50cmllcyA9IGVtcHR5X21hcFxuICAgICAgICAgICA7IHVwZGF0ZXJfbm9kZVxuICAgICAgICAgICA7IHNjb3BlID0gSW5jcmVtZW50YWwuU2NvcGUuY3VycmVudCAoSW5jcmVtZW50YWwuc3RhdGUgaW5wdXRfbWFwKSAoKVxuICAgICAgICAgICB9KVxuICAgICAgaW5cbiAgICAgIExhenkuZm9yY2Ugc2VsZlxuICAgIDs7XG5cbiAgICBsZXRbQGNvbGRdIHNsb3dfcGF0aF9saW5rX2VudHJ5IHQgZW50cnkgfmtleSB+aXNfbm93X29ic2VydmFibGUgPVxuICAgICAgbGV0IChsYXp5IGVudHJ5KSA9IGVudHJ5IGluXG4gICAgICBsZXQgY3VycmVudF9lbnRyaWVzID0gTWFwLmZpbmRfbXVsdGkgdC5sb29rdXBfZW50cmllcyBrZXkgaW5cbiAgICAgIGxldCBpc19saW5rZWQgPSBMaXN0LmV4aXN0cyBjdXJyZW50X2VudHJpZXMgfmY6KHBoeXNfZXF1YWwgZW50cnkpIGluXG4gICAgICBpZiBCb29sLmVxdWFsIGlzX2xpbmtlZCBpc19ub3dfb2JzZXJ2YWJsZVxuICAgICAgdGhlbiAoKVxuICAgICAgZWxzZSBpZiBpc19ub3dfb2JzZXJ2YWJsZVxuICAgICAgdGhlblxuICAgICAgICB0Lmxvb2t1cF9lbnRyaWVzXG4gICAgICAgICAgPC0gTWFwLnVwZGF0ZSB0Lmxvb2t1cF9lbnRyaWVzIGtleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgICAgIHwgU29tZSAob3RoZXJfZW50cnkgOjogXyBhcyBvdGhlcl9lbnRyaWVzKSAtPlxuICAgICAgICAgICAgICAgICAoKiBVcGRhdGUgdGhpcyBlbnRyeSdzIHZhbHVlIHRvIGJlIGN1cnJlbnQuICopXG4gICAgICAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlIDwtIG90aGVyX2VudHJ5LnNhdmVkX3ZhbHVlO1xuICAgICAgICAgICAgICAgICBlbnRyeSA6OiBvdGhlcl9lbnRyaWVzXG4gICAgICAgICAgICAgICB8IE5vbmUgfCBTb21lIFtdIC0+XG4gICAgICAgICAgICAgICAgIGVudHJ5LnNhdmVkX3ZhbHVlIDwtIE1hcC5maW5kIHQuc2F2ZWRfbWFwIGtleTtcbiAgICAgICAgICAgICAgICAgWyBlbnRyeSBdKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBuZXdfZW50cmllcyA9XG4gICAgICAgICAgTGlzdC5maWx0ZXIgY3VycmVudF9lbnRyaWVzIH5mOihmdW4geCAtPiBub3QgKHBoeXNfZXF1YWwgZW50cnkgeCkpXG4gICAgICAgIGluXG4gICAgICAgIHQubG9va3VwX2VudHJpZXNcbiAgICAgICAgICA8LSAoaWYgTGlzdC5pc19lbXB0eSBuZXdfZW50cmllc1xuICAgICAgICAgICAgICB0aGVuIE1hcC5yZW1vdmUgdC5sb29rdXBfZW50cmllcyBrZXlcbiAgICAgICAgICAgICAgZWxzZSBNYXAuc2V0IHQubG9va3VwX2VudHJpZXMgfmtleSB+ZGF0YTpuZXdfZW50cmllcykpXG4gICAgOztcblxuICAgIGxldFtAY29sZF0gc2xvd19wYXRoX2NyZWF0ZV9ub2RlIHQga2V5ID1cbiAgICAgIGxldCBpbmNyZW1lbnRhbF9zdGF0ZSA9IEluY3JlbWVudGFsLnN0YXRlIHQudXBkYXRlcl9ub2RlIGluXG4gICAgICBJbmNyZW1lbnRhbC5TY29wZS53aXRoaW4gaW5jcmVtZW50YWxfc3RhdGUgdC5zY29wZSB+ZjooZnVuICgpIC0+XG4gICAgICAgIGxldCByZWMgZW50cnkgPVxuICAgICAgICAgIGxhenlcbiAgICAgICAgICAgIHsgc2F2ZWRfdmFsdWUgPSBNYXAuZmluZCB0LnNhdmVkX21hcCBrZXlcbiAgICAgICAgICAgIDsgbm9kZSA9XG4gICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuY3JlYXRlXG4gICAgICAgICAgICAgICAgICBpbmNyZW1lbnRhbF9zdGF0ZVxuICAgICAgICAgICAgICAgICAgKGZ1biAoKSAtPiAoZm9yY2UgZW50cnkpLnNhdmVkX3ZhbHVlKVxuICAgICAgICAgICAgICAgICAgfm9uX29ic2VydmFiaWxpdHlfY2hhbmdlOihzbG93X3BhdGhfbGlua19lbnRyeSB0IGVudHJ5IH5rZXkpXG4gICAgICAgICAgICB9XG4gICAgICAgIGluXG4gICAgICAgIGxldCAobGF6eSBlbnRyeSkgPSBlbnRyeSBpblxuICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS5hZGRfZGVwZW5kZW5jeVxuICAgICAgICAgIGVudHJ5Lm5vZGVcbiAgICAgICAgICAoSW5jcmVtZW50YWwuRXhwZXJ0LkRlcGVuZGVuY3kuY3JlYXRlIHQudXBkYXRlcl9ub2RlKTtcbiAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUud2F0Y2ggZW50cnkubm9kZSlcbiAgICA7O1xuXG4gICAgbGV0IGZpbmQgdCBrZXkgPVxuICAgICAgbWF0Y2ggTWFwLmZpbmRfbXVsdGkgdC5sb29rdXBfZW50cmllcyBrZXkgd2l0aFxuICAgICAgfCBlbnRyeSA6OiBfIC0+IEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLndhdGNoIGVudHJ5Lm5vZGVcbiAgICAgIHwgW10gLT4gc2xvd19wYXRoX2NyZWF0ZV9ub2RlIHQga2V5XG4gICAgOztcblxuICAgIG1vZHVsZSBGb3JfZGVidWcgPSBzdHJ1Y3RcbiAgICAgIGxldFtAY29sZF0gc2V4cF9vZl9lbnRyeSBzZXhwX29mX3ZhbHVlIGVudHJ5ID1cbiAgICAgICAgbGV0IHsgc2F2ZWRfdmFsdWU7IG5vZGUgfSA9IGVudHJ5IGluXG4gICAgICAgIGxldCBub2RlID0gSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUud2F0Y2ggbm9kZSBpblxuICAgICAgICBbJXNleHBcbiAgICAgICAgICB7IHNhdmVkX3ZhbHVlIDogdmFsdWUgb3B0aW9uXG4gICAgICAgICAgOyBub2RlX2luZm8gPSAoSW5jcmVtZW50YWwudXNlcl9pbmZvIG5vZGUgOiAoSW5mby50IG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAgICAgICA7IG5vZGVfaXNfY29uc3QgPVxuICAgICAgICAgICAgICAoT3B0aW9uLnNvbWVfaWYgKEluY3JlbWVudGFsLmlzX2NvbnN0IG5vZGUpICgpXG4gICAgICAgICAgICAgICAgOiAodW5pdCBvcHRpb25bQHNleHAub3B0aW9uXSkpXG4gICAgICAgICAgOyBub2RlX2lzX2ludmFsaWQgPVxuICAgICAgICAgICAgICAoT3B0aW9uLnNvbWVfaWYgKG5vdCAoSW5jcmVtZW50YWwuaXNfdmFsaWQgbm9kZSkpICgpXG4gICAgICAgICAgICAgICAgOiAodW5pdCBvcHRpb25bQHNleHAub3B0aW9uXSkpXG4gICAgICAgICAgOyBub2RlX2lzX3VubmVjZXNzYXJ5ID1cbiAgICAgICAgICAgICAgKE9wdGlvbi5zb21lX2lmIChub3QgKEluY3JlbWVudGFsLmlzX25lY2Vzc2FyeSBub2RlKSkgKClcbiAgICAgICAgICAgICAgICA6ICh1bml0IG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAgICAgICB9XVxuICAgICAgOztcblxuICAgICAgbGV0W0Bjb2xkXSBzZXhwX29mX3Qgc2V4cF9vZl9rZXkgc2V4cF9vZl92YWx1ZSB0ID1cbiAgICAgICAgbGV0IGluZm9fcGVyX2tleSA9XG4gICAgICAgICAgTWFwLm1lcmdlIHQuc2F2ZWRfbWFwIHQubG9va3VwX2VudHJpZXMgfmY6KGZ1biB+a2V5IGRhdGEgLT5cbiAgICAgICAgICAgIGxldCBhY3R1YWxfdmFsdWUsIGVudHJpZXMgPVxuICAgICAgICAgICAgICBtYXRjaCBkYXRhIHdpdGhcbiAgICAgICAgICAgICAgfCBgTGVmdCB4IC0+IFNvbWUgeCwgW11cbiAgICAgICAgICAgICAgfCBgUmlnaHQgeSAtPiBOb25lLCB5XG4gICAgICAgICAgICAgIHwgYEJvdGggKHgsIHkpIC0+IFNvbWUgeCwgeVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIFNvbWVcbiAgICAgICAgICAgICAgWyVzZXhwXG4gICAgICAgICAgICAgICAgeyBrZXkgOiBrZXlcbiAgICAgICAgICAgICAgICA7IGFjdHVhbF92YWx1ZSA6ICh2YWx1ZSBvcHRpb25bQHNleHAub3B0aW9uXSlcbiAgICAgICAgICAgICAgICA7IGVudHJpZXMgOiB2YWx1ZSBlbnRyeSBsaXN0XG4gICAgICAgICAgICAgICAgfV0pXG4gICAgICAgIGluXG4gICAgICAgIFNleHAuTGlzdCAoTWFwLmRhdGEgaW5mb19wZXJfa2V5KVxuICAgICAgOztcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIHN0YXRlX3dpdG5lc3NcblxuICBpbmNsdWRlXG4gICAgU19nZW5cbiAgICAgIHdpdGggdHlwZSAnYSBJbmNyLnQgPSAoJ2EsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgICBhbmQgdHlwZSAnYSBJbmNyLkN1dG9mZi50ID0gJ2EgSW5jcmVtZW50YWwuQ3V0b2ZmLnRcbiAgICAgICBhbmQgdHlwZSAoJ2ssICd2LCAnY21wKSBMb29rdXAudCA9ICgnaywgJ3YsICdjbXAsIHN0YXRlX3dpdG5lc3MpIEdlbmVyaWMuTG9va3VwLnRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoSW5jciA6IEluY3JlbWVudGFsLlMpID0gc3RydWN0XG4gIGluY2x1ZGUgR2VuZXJpY1xuICBtb2R1bGUgSW5zdHJ1bWVudGF0aW9uID0gSW5zdHJ1bWVudGF0aW9uXG5cbiAgbGV0IGZsYXR0ZW4geCA9IGZsYXR0ZW4gSW5jci5TdGF0ZS50IHhcblxuICBtb2R1bGUgTG9va3VwID0gc3RydWN0XG4gICAgaW5jbHVkZSBMb29rdXBcblxuICAgIHR5cGUgKCdrLCAndiwgJ2NtcCkgdCA9ICgnaywgJ3YsICdjbXAsIEluY3Iuc3RhdGVfd2l0bmVzcykgTG9va3VwLnRcblxuICAgIG1vZHVsZSBNIChLIDogc2lnXG4gICAgICB0eXBlIHRcbiAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKSA6IHNpZ1xuICAgICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgIGVuZCA9IHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIEdlbmVyaWNcbiJdfQ==
