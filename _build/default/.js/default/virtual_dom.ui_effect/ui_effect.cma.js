// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ui_effect__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Ui_effect = [0],
    Ui_effect$0 = [0, Ui_effect];
   runtime.caml_register_global(0, Ui_effect$0, "Ui_effect__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ui_effect__Ui_effect_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Ui_effect_Ui_effect_intf = "Ui_effect__Ui_effect_intf",
    cst_ui_effect = "ui_effect";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ui_effect_Ui_effect_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ui_effect);
   caml_call1(Ppx_expect_runtime[1][1], "ui_effect/ui_effect_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_ui_effect, "ui_effect_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_ui_effect);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ui_effect_Ui_effect_intf);
   var Ui_effect_Ui_effect_intf = [0];
   runtime.caml_register_global
    (11, Ui_effect_Ui_effect_intf, cst_Ui_effect_Ui_effect_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ui_effect
//# unitInfo: Requires: Base, Base__Hashtbl, Base__Int, Base__List, Base__Monad, CamlinternalLazy, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stdio, Stdlib__Obj, Ui_effect__Ui_effect_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Ui_effect$0 = "Ui_effect",
    cst_Unrecognized_variant$1 = "Unrecognized variant",
    cst_ui_effect$0 = "ui_effect",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_List = global_data.Base__List,
    Stdio = global_data.Stdio,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base = global_data.Base,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Int = global_data.Base__Int,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Ui_effect$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_ui_effect$0);
   caml_call1(Ppx_expect_runtime[1][1], "ui_effect/ui_effect.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_ui_effect$0, "ui_effect.ml");
   var
    Ignore = [248, "Ui_effect.Ignore", caml_fresh_oo_id(0)],
    Many = [248, "Ui_effect.Many", caml_fresh_oo_id(0)],
    handlers =
      caml_call3
       (Base_Hashtbl[4],
        0,
        [0, 8],
        [0, Base_Int[14], Base_Int[10], Base_Int[8]]),
    cst_Unrecognized_variant$0 = cst_Unrecognized_variant$1,
    cst_on_response_called_multipl = "on_response called multiple times!",
    cst_Ui_effect_Define1_Handler_ = "Ui_effect.Define1(Handler).C",
    cst_Unrecognized_variant = cst_Unrecognized_variant$1,
    cst_Ui_effect_Define_Handler_C = "Ui_effect.Define(Handler).C",
    cst_Ui_effect_Return = "Ui_effect.Return",
    cst_Ui_effect_Lazy = "Ui_effect.Lazy",
    cst_Ui_effect_Bind = "Ui_effect.Bind",
    cst_Ui_effect_Map = "Ui_effect.Map",
    cst_Ui_effect_Never = "Ui_effect.Never",
    cst_Ui_effect_Fun = "Ui_effect.Fun",
    cst_ui_effect = cst_ui_effect$0,
    cst_Ui_effect = cst_Ui_effect$0;
   function Define(Handler){
    var
     C = [248, cst_Ui_effect_Define_Handler_C, caml_fresh_oo_id(0)],
     key = caml_call1(Stdlib_Obj[23][3], C);
    function _w_(inp){
     var _x_ = inp[1], match = _x_[1];
     if(match[1] === C){
      var callback = _x_[2], value = match[2];
      caml_call1(Handler[2], value);
      return caml_call1(callback, 0);
     }
     var _y_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Unrecognized_variant);
     return caml_call1(Base[246], _y_);
    }
    caml_call3(Base_Hashtbl[39], handlers, key, _w_);
    function inject(v){return [0, C, v];}
    return [0, inject];
   }
   function Define1(Handler){
    var
     C = [248, cst_Ui_effect_Define1_Handler_, caml_fresh_oo_id(0)],
     key = caml_call1(Stdlib_Obj[23][3], C);
    function _t_(inp){
     var _u_ = inp[1], match = _u_[1];
     if(match[1] === C){
      var
       callback = _u_[2],
       value = match[2],
       called = [0, 0],
       callback$0 =
         function(a){
          if(called[1])
           caml_call1(Base[244], cst_on_response_called_multipl);
          else
           called[1] = 1;
          return caml_call1(callback, a);
         };
      return caml_call2(Handler[2], value, callback$0);
     }
     var _v_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Unrecognized_variant$0);
     return caml_call1(Base[246], _v_);
    }
    caml_call3(Base_Hashtbl[39], handlers, key, _t_);
    function inject(v){return [0, C, v];}
    return [0, inject];
   }
   function handle(s){return caml_call2(Stdio[5], 0, s);}
   var
    Print_s = Define([0, [0], handle]),
    print_s = Print_s[1],
    Return = [248, cst_Ui_effect_Return, caml_fresh_oo_id(0)],
    Lazy = [248, cst_Ui_effect_Lazy, caml_fresh_oo_id(0)],
    Bind = [248, cst_Ui_effect_Bind, caml_fresh_oo_id(0)],
    Map = [248, cst_Ui_effect_Map, caml_fresh_oo_id(0)],
    Never = [248, cst_Ui_effect_Never, caml_fresh_oo_id(0)],
    Fun = [248, cst_Ui_effect_Fun, caml_fresh_oo_id(0)];
   function return$0(a){return [0, Return, a];}
   function bind(t, f){return [0, Bind, t, f];}
   function _a_(t, f){return [0, Map, t, f];}
   function of_fun(f){return [0, Fun, f];}
   function lazy(a){return [0, Lazy, a];}
   var
    map = [0, -198771759, _a_],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function eval$0(t, callback){
    var t$0 = t, callback$0 = callback;
    for(;;){
     if(t$0[1] === Fun){var f = t$0[2]; return caml_call1(f, callback$0);}
     if(t$0 === Ignore) return caml_call1(callback$0, 0);
     if(t$0[1] === Return){var a = t$0[2]; return caml_call1(callback$0, a);}
     if(t$0[1] === Lazy){
      var _n_ = t$0[2], _o_ = runtime.caml_obj_tag(_n_);
      a:
      if(250 === _o_)
       var t$1 = _n_[1];
      else{
       if(246 !== _o_ && 244 !== _o_){var t$1 = _n_; break a;}
       var t$1 = caml_call1(CamlinternalLazy[2], _n_);
      }
      var t$0 = t$1;
     }
     else{
      if(t$0[1] === Many){
       var
        l = t$0[2],
        _p_ = function(_s_){return 0;},
        _q_ = function(_r_){return eval$0(_r_, _p_);};
       caml_call2(Base_List[19], l, _q_);
       return caml_call1(callback$0, 0);
      }
      if(t$0[1] === Bind)
       var
        f$0 = t$0[3],
        t$2 = t$0[2],
        callback$3 =
          function(callback, f){
           function callback$0(a){return eval$0(caml_call1(f, a), callback);}
           return callback$0;
          },
        callback$1 = callback$3(callback$0, f$0),
        t$0 = t$2,
        callback$0 = callback$1;
      else{
       if(t$0[1] !== Map){
        if(t$0 === Never) return 0;
        var
         _l_ = caml_call1(Stdlib_Obj[23][1], t$0),
         _m_ = caml_call1(Stdlib_Obj[23][3], _l_);
        return caml_call3
                (Base_Hashtbl[57], handlers, _m_, [0, [0, t$0, callback$0]]);
       }
       var
        f$1 = t$0[3],
        t$3 = t$0[2],
        callback$4 =
          function(callback, f){
           function callback$0(a){
            return caml_call1(callback, caml_call1(f, a));
           }
           return callback$0;
          },
        callback$2 = callback$4(callback$0, f$1),
        t$0 = t$3,
        callback$0 = callback$2;
      }
     }
    }
   }
   function _b_(_k_){return 0;}
   function handle$0(_j_){return eval$0(_j_, _b_);}
   function eval$1(t, f){return eval$0(t, f);}
   var Action = [0];
   function handle$1(param, on_response){
    var f = param[2], a = param[1];
    return caml_call1(on_response, caml_call1(f, a));
   }
   var Sync_fun_arg = [0, Action, handle$1], Sync_fun = Define1(Sync_fun_arg);
   function of_sync_fun(f, a){return caml_call1(Sync_fun[1], [0, a, f]);}
   function of_thunk(f){return of_sync_fun(f, 0);}
   function make(request, on_response){return [0, request, on_response];}
   function request(param){var request = param[1]; return request;}
   function respond_to(param, response){
    var on_response = param[2];
    return caml_call1(on_response, response);
   }
   var Callback = [0, make, request, respond_to];
   function make$0(request, evaluator){
    return of_fun
            (function(callback){
              function _i_(response){
               caml_call1(callback, response);
               return Ignore;
              }
              var callback$0 = caml_call2(Callback[1], request, _i_);
              return caml_call1(evaluator, callback$0);
             });
   }
   var Private = [0, Callback, make$0];
   function create(param){return [0, [0, 0]];}
   function upon(t, handler){
    var match = t[1];
    if(0 === match[0]){match[1] = [0, handler, match[1]]; return 0;}
    var x = match[1];
    return caml_call1(handler, x);
   }
   function fill_if_empty(t, x){
    var match = t[1];
    if(0 !== match[0]) return 0;
    var handlers = match[1];
    function _h_(handler){return caml_call1(handler, x);}
    caml_call2(Base_List[19], handlers, _h_);
    t[1] = [1, x];
    return 0;
   }
   function peek(t){
    var match = t[1];
    if(0 === match[0]) return 0;
    var x = match[1];
    return [0, x];
   }
   var Svar = [0, create, upon, fill_if_empty, peek], Action$0 = [0];
   function handle$2(param, on_response){
    var f = param[2], a = param[1], _g_ = caml_call1(f, a);
    return caml_call2(Svar[2], _g_, on_response);
   }
   var
    Svar_fun_arg = [0, Action$0, handle$2],
    Svar_fun = Define1(Svar_fun_arg);
   function of_svar_fun(f, a){return caml_call1(Svar_fun[1], [0, a, f]);}
   function create$0(param){return [0, 0];}
   function queries_pending_response(t){
    function _f_(param){var query = param[1]; return query;}
    return caml_call2(Base_List[53], t[1], _f_);
   }
   function maybe_respond(t, f){
    function _e_(param){
     var response = param[2], query = param[1], match = caml_call1(f, query);
     if(! match) return 1;
     var resp = match[1];
     caml_call2(Svar[3], response, resp);
     return 0;
    }
    t[1] = caml_call2(Base_List[12], t[1], _e_);
    return 0;
   }
   function of_query_response_tracker(qrt){
    function _c_(query){
     var response = caml_call1(Svar[1], 0);
     qrt[1] = [0, [0, query, response], qrt[1]];
     return response;
    }
    return function(_d_){return of_svar_fun(_c_, _d_);};
   }
   caml_call1(Ppx_inline_test_lib[7], cst_ui_effect);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Ui_effect);
   var
    Ui_effect =
      [0,
       Ignore,
       Many,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       Never,
       lazy,
       print_s,
       of_sync_fun,
       of_thunk,
       Define,
       Define1,
       [0, eval$1, handle$0, handlers, of_fun],
       Private,
       [0,
        Svar,
        of_svar_fun,
        [0, create$0, maybe_respond, queries_pending_response],
        of_query_response_tracker]];
   runtime.caml_register_global(34, Ui_effect, cst_Ui_effect$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ1aV9lZmZlY3QuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImhhbmRsZXJzIiwia2V5IiwiaW5wIiwiY2FsbGJhY2siLCJ2YWx1ZSIsImluamVjdCIsInYiLCJjYWxsZWQiLCJjYWxsYmFjayQwIiwiYSIsImhhbmRsZSIsInMiLCJwcmludF9zIiwiTmV2ZXIiLCJyZXR1cm4kMCIsImJpbmQiLCJ0IiwiZiIsIm9mX2Z1biIsImxhenkiLCJtYXAiLCJldmFsJDAiLCJ0JDAiLCJ0JDEiLCJsIiwiZiQwIiwidCQyIiwiY2FsbGJhY2skMyIsImNhbGxiYWNrJDEiLCJmJDEiLCJ0JDMiLCJjYWxsYmFjayQ0IiwiY2FsbGJhY2skMiIsImhhbmRsZSQwIiwiZXZhbCQxIiwiaGFuZGxlJDEiLCJvbl9yZXNwb25zZSIsIm9mX3N5bmNfZnVuIiwib2ZfdGh1bmsiLCJtYWtlIiwicmVxdWVzdCIsInJlc3BvbmRfdG8iLCJyZXNwb25zZSIsIm1ha2UkMCIsImV2YWx1YXRvciIsImNyZWF0ZSIsInVwb24iLCJoYW5kbGVyIiwibWF0Y2giLCJ4IiwiZmlsbF9pZl9lbXB0eSIsInBlZWsiLCJoYW5kbGUkMiIsIm9mX3N2YXJfZnVuIiwiY3JlYXRlJDAiLCJxdWVyaWVzX3BlbmRpbmdfcmVzcG9uc2UiLCJxdWVyeSIsIm1heWJlX3Jlc3BvbmQiLCJyZXNwIiwib2ZfcXVlcnlfcmVzcG9uc2VfdHJhY2tlciIsInFydCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi92aXJ0dWFsX2RvbS91aV9lZmZlY3QvdWlfZWZmZWN0X18ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvdmlydHVhbF9kb20vdWlfZWZmZWN0L3VpX2VmZmVjdC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztHQUtxQjs7SUFBQTs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7O0c7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QSwwQkFEWXhDO0dBQzBCO1lBT25EeUMsY0FBY3pDLEdBQUdDOztLQUVJLElBQWN5QixxQkFBUGMsa0JBQ2pCLFFBQUEsV0FITXZDLEdBRVd1QztpQkFFRjtTQUNYRTtLQUNSLG9CQUo0QmhCLFVBR3BCZ0I7S0FDUjtJQUNNO0lBUEMxQyxPQUVYLDBCQUZXQTs7R0FPRDtZQUlmMkMsMEJBQTBCQztJQUFrQixhQXpCOUJKO0tBQ0MsSUFBWGQsV0FBVztLQXdCV2tCLGlCQXpCWkosT0FDVmQsV0F3QnNCa0I7S0F0QjFCLE9BRklsQjs7SUF3QndDLHFCLE9BckM1Q1c7R0FxQ2tGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0ExSnRGeEM7T0FFQU07T0F4QkFQO09BdUVFeUI7T0FDQUM7OztXQXBCQUosUUFEQUQsVUEzR0ZqQyxVQStFQWtCOzs7O1FBb0hJbUM7WUFVRUMsVUFnQkFHLGVBUkFGO1FBbUJGSTs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBVaV9lZmZlY3QuVWlfZWZmZWN0X2ludGYgKilcbm1vZHVsZSBVaV9lZmZlY3RfaW50ZiA9IFVpX2VmZmVjdF9fVWlfZWZmZWN0X2ludGZcblxubW9kdWxlIFVpX2VmZmVjdF9fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCJvcGVuISBCYXNlXG5pbmNsdWRlIFVpX2VmZmVjdF9pbnRmXG5cbnR5cGUgJ2EgdCA9IC4uXG50eXBlICdhIHQgKz0gSWdub3JlIDogdW5pdCB0IHwgTWFueSA6IHVuaXQgdCBsaXN0IC0+IHVuaXQgdFxuXG4oKiBXZSB1c2UgdGhpcyB0YWJsZSBmb3IgZGlzcGF0Y2hpbmcgdG8gdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXIgaW4gYW4gZWZmaWNpZW50IHdheS4gICopXG50eXBlIGhpZGRlbiA9IFQgOiAoJ2EgdCAqICgnYSAtPiB1bml0KSkgLT4gaGlkZGVuXG5cbmxldCBoYW5kbGVycyA6IChoaWRkZW4gLT4gdW5pdCkgSGFzaHRibC5NKEludCkudCA9IEhhc2h0YmwuY3JlYXRlIChtb2R1bGUgSW50KSB+c2l6ZTo4XG5cbm1vZHVsZSBEZWZpbmUgKEhhbmRsZXIgOiBIYW5kbGVyKSA6XG4gIFMgd2l0aCB0eXBlIGFjdGlvbiA6PSBIYW5kbGVyLkFjdGlvbi50IGFuZCB0eXBlICdhIHQgOj0gJ2EgdCA9IHN0cnVjdFxuICB0eXBlIF8gdCArPSBDIDogSGFuZGxlci5BY3Rpb24udCAtPiB1bml0IHRcblxuICBsZXQga2V5ID0gU3RkbGliLk9iai5FeHRlbnNpb25fY29uc3RydWN0b3IuaWQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgQ11cblxuICBsZXQgKCkgPVxuICAgIEhhc2h0YmwuYWRkX2V4biBoYW5kbGVycyB+a2V5IH5kYXRhOihmdW4gaW5wIC0+XG4gICAgICBtYXRjaCBpbnAgd2l0aFxuICAgICAgfCBUIChDIHZhbHVlLCBjYWxsYmFjaykgLT5cbiAgICAgICAgSGFuZGxlci5oYW5kbGUgdmFsdWU7XG4gICAgICAgIGNhbGxiYWNrICgpXG4gICAgICB8IF8gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJVbnJlY29nbml6ZWQgdmFyaWFudFwiXSlcbiAgOztcblxuICBsZXQgaW5qZWN0IHYgPSBDIHZcbmVuZFxuXG5tb2R1bGUgRGVmaW5lMSAoSGFuZGxlciA6IEhhbmRsZXIxKSA6XG4gIFMxIHdpdGggdHlwZSAnYSBhY3Rpb24gOj0gJ2EgSGFuZGxlci5BY3Rpb24udCBhbmQgdHlwZSAnYSB0IDo9ICdhIHQgPSBzdHJ1Y3RcbiAgdHlwZSBfIHQgKz0gQyA6ICdhIEhhbmRsZXIuQWN0aW9uLnQgLT4gJ2EgdFxuXG4gIGxldCBrZXkgPSBTdGRsaWIuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBDXVxuXG4gIGxldCAoKSA9XG4gICAgSGFzaHRibC5hZGRfZXhuIGhhbmRsZXJzIH5rZXkgfmRhdGE6KGZ1biBpbnAgLT5cbiAgICAgIG1hdGNoIGlucCB3aXRoXG4gICAgICB8IFQgKEMgdmFsdWUsIGNhbGxiYWNrKSAtPlxuICAgICAgICBsZXQgY2FsbGVkID0gcmVmIGZhbHNlIGluXG4gICAgICAgIGxldCBjYWxsYmFjayBhID1cbiAgICAgICAgICBpZiAhY2FsbGVkXG4gICAgICAgICAgdGhlbiBmYWlsd2l0aCBcIm9uX3Jlc3BvbnNlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyFcIlxuICAgICAgICAgIGVsc2UgY2FsbGVkIDo9IHRydWU7XG4gICAgICAgICAgY2FsbGJhY2sgYVxuICAgICAgICBpblxuICAgICAgICBIYW5kbGVyLmhhbmRsZSB2YWx1ZSB+b25fcmVzcG9uc2U6Y2FsbGJhY2tcbiAgICAgIHwgXyAtPiByYWlzZV9zIFslbWVzc2FnZSBcIlVucmVjb2duaXplZCB2YXJpYW50XCJdKVxuICA7O1xuXG4gIGxldCBpbmplY3QgdiA9IEMgdlxuZW5kXG5cbmxldCBnZXRfa2V5IHQgPSBTdGRsaWIuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci4oaWQgKG9mX3ZhbCB0KSlcblxubGV0IGhhbmRsZV9yZWdpc3RlcmVkX2V2ZW50IChUICh0LCBjYikpID1cbiAgSGFzaHRibC5maW5kX2V4biBoYW5kbGVycyAoZ2V0X2tleSB0KSAoVCAodCwgY2IpKVxuOztcblxubW9kdWxlIFByaW50X3MgPSBEZWZpbmUgKHN0cnVjdFxuICBtb2R1bGUgQWN0aW9uID0gU2V4cFxuXG4gIGxldCBoYW5kbGUgcyA9IFN0ZGlvLnByaW50X3Mgc1xuZW5kKVxuXG5sZXQgcHJpbnRfcyA9IFByaW50X3MuaW5qZWN0XG5cbigqIEVmZmVjdGZ1bCB0aGluZ3MgKilcbnR5cGUgJ2EgdCArPVxuICB8IFJldHVybiA6ICdhIC0+ICdhIHRcbiAgfCBMYXp5IDogJ2EgdCBMYXp5LnQgLT4gJ2EgdFxuICB8IEJpbmQgOlxuICAgICAgeyB0IDogJ2EgdFxuICAgICAgOyBmIDogJ2EgLT4gJ2IgdFxuICAgICAgfVxuICAgICAgLT4gJ2IgdFxuICB8IE1hcCA6XG4gICAgICB7IHQgOiAnYSB0XG4gICAgICA7IGYgOiAnYSAtPiAnYlxuICAgICAgfVxuICAgICAgLT4gJ2IgdFxuICB8IE5ldmVyIDogJ2IgdFxuICB8IEZ1biA6IChjYWxsYmFjazooJ2EgLT4gdW5pdCkgLT4gdW5pdCkgLT4gJ2EgdFxuXG5sZXQgcmV0dXJuIGEgPSBSZXR1cm4gYVxubGV0IGJpbmQgKHR5cGUgYSkgKHQgOiBhIHQpIH5mID0gQmluZCB7IHQ7IGYgfVxubGV0IG1hcCAodHlwZSBhIGIpICh0IDogYSB0KSB+ZiA6IGIgdCA9IE1hcCB7IHQ7IGYgfVxubGV0IG5ldmVyID0gTmV2ZXJcbmxldCBvZl9mdW4gfmYgPSBGdW4gZlxubGV0IGxhenlfIGEgPSBMYXp5IGFcblxuaW5jbHVkZSBCYXNlLk1vbmFkLk1ha2UgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCByZXR1cm4gPSByZXR1cm5cbiAgbGV0IGJpbmQgPSBiaW5kXG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuZW5kKVxuXG5sZXQgcmVjIGV2YWwgOiB0eXBlIGEuIGEgdCAtPiBjYWxsYmFjazooYSAtPiB1bml0KSAtPiB1bml0ID1cbiAgZnVuIHQgfmNhbGxiYWNrIC0+XG4gIG1hdGNoIHQgd2l0aFxuICB8IEZ1biBmIC0+IGYgfmNhbGxiYWNrXG4gIHwgSWdub3JlIC0+IGNhbGxiYWNrICgpXG4gIHwgUmV0dXJuIGEgLT4gY2FsbGJhY2sgYVxuICB8IExhenkgKGxhenkgdCkgLT4gZXZhbCB0IH5jYWxsYmFja1xuICB8IE1hbnkgbCAtPlxuICAgIExpc3QuaXRlciBsIH5mOihldmFsIH5jYWxsYmFjazppZ25vcmUpO1xuICAgIGNhbGxiYWNrICgpXG4gIHwgQmluZCB7IHQ7IGYgfSAtPiBldmFsIHQgfmNhbGxiYWNrOihmdW4gYSAtPiBldmFsIChmIGEpIH5jYWxsYmFjaylcbiAgfCBNYXAgeyB0OyBmIH0gLT4gZXZhbCB0IH5jYWxsYmFjazooZnVuIGEgLT4gY2FsbGJhY2sgKGYgYSkpXG4gIHwgTmV2ZXIgLT4gKClcbiAgfCB0IC0+IGhhbmRsZV9yZWdpc3RlcmVkX2V2ZW50IChUICh0LCBjYWxsYmFjaykpXG47O1xuXG5tb2R1bGUgRXhwZXJ0ID0gc3RydWN0XG4gIGxldCBoYW5kbGUgPSBldmFsIH5jYWxsYmFjazppZ25vcmVcbiAgbGV0IGV2YWwgdCB+ZiA9IGV2YWwgdCB+Y2FsbGJhY2s6ZlxuXG4gIHR5cGUgaGlkZSA9IGhpZGRlbiA9IFQgOiAoJ2EgdCAqICgnYSAtPiB1bml0KSkgLT4gaGlkZVxuXG4gIGxldCBoYW5kbGVycyA9IGhhbmRsZXJzXG4gIGxldCBvZl9mdW4gPSBvZl9mdW5cbmVuZFxuXG5tb2R1bGUgQWR2YW5jZWQgPSBzdHJ1Y3RcbiAgbW9kdWxlIFN5bmNfZnVuX2FyZyA9IHN0cnVjdFxuICAgIG1vZHVsZSBBY3Rpb24gPSBzdHJ1Y3RcbiAgICAgIHR5cGUgJ3IgdCA9IFQgOiAnYSAqICgnYSAtPiAncikgLT4gJ3IgdFxuICAgIGVuZFxuXG4gICAgbGV0IGhhbmRsZSAoQWN0aW9uLlQgKGEsIGYpKSB+b25fcmVzcG9uc2UgPSBvbl9yZXNwb25zZSAoZiBhKVxuICBlbmRcblxuICBtb2R1bGUgU3luY19mdW4gPSBEZWZpbmUxIChTeW5jX2Z1bl9hcmcpXG5cbiAgbGV0IG9mX3N5bmNfZnVuIGYgYSA9IFN5bmNfZnVuLmluamVjdCAoVCAoYSwgZikpXG4gIGxldCBvZl90aHVuayBmID0gb2Zfc3luY19mdW4gZiAoKVxuXG4gIG1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gICAgbW9kdWxlIENhbGxiYWNrID0gc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID1cbiAgICAgICAgeyByZXF1ZXN0IDogJ2FcbiAgICAgICAgOyBvbl9yZXNwb25zZSA6ICdiIC0+IHVuaXQgdFxuICAgICAgICB9XG5cbiAgICAgIGxldCBtYWtlIH5yZXF1ZXN0IH5vbl9yZXNwb25zZSA9IHsgcmVxdWVzdDsgb25fcmVzcG9uc2UgfVxuICAgICAgbGV0IHJlcXVlc3QgeyByZXF1ZXN0OyBfIH0gPSByZXF1ZXN0XG4gICAgICBsZXQgcmVzcG9uZF90byB7IG9uX3Jlc3BvbnNlOyBfIH0gcmVzcG9uc2UgPSBvbl9yZXNwb25zZSByZXNwb25zZVxuICAgIGVuZFxuXG4gICAgbGV0IG1ha2UgOiByZXF1ZXN0OidhIC0+IGV2YWx1YXRvcjooKCdhLCAnYikgQ2FsbGJhY2sudCAtPiB1bml0KSAtPiAnYiB0ID1cbiAgICAgIGZ1biB+cmVxdWVzdCB+ZXZhbHVhdG9yIC0+XG4gICAgICBFeHBlcnQub2ZfZnVuIH5mOihmdW4gfmNhbGxiYWNrIC0+XG4gICAgICAgIGxldCBjYWxsYmFjayA9XG4gICAgICAgICAgQ2FsbGJhY2subWFrZSB+cmVxdWVzdCB+b25fcmVzcG9uc2U6KGZ1biByZXNwb25zZSAtPlxuICAgICAgICAgICAgY2FsbGJhY2sgcmVzcG9uc2U7XG4gICAgICAgICAgICBJZ25vcmUpXG4gICAgICAgIGluXG4gICAgICAgIGV2YWx1YXRvciBjYWxsYmFjaylcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRm9yX3Rlc3RpbmcgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgU3ZhciA9IHN0cnVjdFxuICAgICAgdHlwZSAnYSBzdGF0ZSA9XG4gICAgICAgIHwgRW1wdHkgb2YgeyBtdXRhYmxlIGhhbmRsZXJzIDogKCdhIC0+IHVuaXQpIGxpc3QgfVxuICAgICAgICB8IEZ1bGwgb2YgJ2FcblxuICAgICAgdHlwZSAnYSB0ID0gJ2Egc3RhdGUgcmVmXG5cbiAgICAgIGxldCBjcmVhdGUgKCkgPSByZWYgKEVtcHR5IHsgaGFuZGxlcnMgPSBbXSB9KVxuXG4gICAgICBsZXQgdXBvbiB0IGhhbmRsZXIgPVxuICAgICAgICBtYXRjaCAhdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgdCAtPiB0LmhhbmRsZXJzIDwtIGhhbmRsZXIgOjogdC5oYW5kbGVyc1xuICAgICAgICB8IEZ1bGwgeCAtPiBoYW5kbGVyIHhcbiAgICAgIDs7XG5cbiAgICAgIGxldCBmaWxsX2lmX2VtcHR5IHQgeCA9XG4gICAgICAgIG1hdGNoICF0IHdpdGhcbiAgICAgICAgfCBGdWxsIF8gLT4gKClcbiAgICAgICAgfCBFbXB0eSB7IGhhbmRsZXJzIH0gLT5cbiAgICAgICAgICBMaXN0Lml0ZXIgaGFuZGxlcnMgfmY6KGZ1biBoYW5kbGVyIC0+IGhhbmRsZXIgeCk7XG4gICAgICAgICAgdCA6PSBGdWxsIHhcbiAgICAgIDs7XG5cbiAgICAgIGxldCBwZWVrIHQgPVxuICAgICAgICBtYXRjaCAhdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgXyAtPiBOb25lXG4gICAgICAgIHwgRnVsbCB4IC0+IFNvbWUgeFxuICAgICAgOztcbiAgICBlbmRcblxuICAgIG1vZHVsZSBTdmFyX2Z1bl9hcmcgPSBzdHJ1Y3RcbiAgICAgIG1vZHVsZSBBY3Rpb24gPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAnciB0ID0gVCA6ICdhICogKCdhIC0+ICdyIFN2YXIudCkgLT4gJ3IgdFxuICAgICAgZW5kXG5cbiAgICAgIGxldCBoYW5kbGUgKEFjdGlvbi5UIChhLCBmKSkgfm9uX3Jlc3BvbnNlID0gU3Zhci51cG9uIChmIGEpIG9uX3Jlc3BvbnNlXG4gICAgZW5kXG5cbiAgICBtb2R1bGUgU3Zhcl9mdW4gPSBEZWZpbmUxIChTdmFyX2Z1bl9hcmcpXG5cbiAgICBsZXQgb2Zfc3Zhcl9mdW4gZiBhID0gU3Zhcl9mdW4uaW5qZWN0IChUIChhLCBmKSlcblxuICAgIG1vZHVsZSBRdWVyeV9yZXNwb25zZV90cmFja2VyID0gc3RydWN0XG4gICAgICB0eXBlICgncSwgJ3IpIHJwYyA9XG4gICAgICAgIHsgcXVlcnkgOiAncVxuICAgICAgICA7IHJlc3BvbnNlIDogJ3IgU3Zhci50XG4gICAgICAgIH1cblxuICAgICAgdHlwZSAoJ3EsICdyKSB0ID0gKCdxLCAncikgcnBjIGxpc3QgcmVmXG5cbiAgICAgIGxldCBjcmVhdGUgKCkgPSByZWYgW11cblxuICAgICAgbGV0IGFkZF9xdWVyeSB0IHF1ZXJ5ID1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gU3Zhci5jcmVhdGUgKCkgaW5cbiAgICAgICAgdCA6PSB7IHF1ZXJ5OyByZXNwb25zZSB9IDo6ICF0O1xuICAgICAgICByZXNwb25zZVxuICAgICAgOztcblxuICAgICAgbGV0IHF1ZXJpZXNfcGVuZGluZ19yZXNwb25zZSB0ID1cbiAgICAgICAgTGlzdC5tYXAgIXQgfmY6KGZ1biB7IHF1ZXJ5OyByZXNwb25zZSA9IF8gfSAtPiBxdWVyeSlcbiAgICAgIDs7XG5cbiAgICAgIHR5cGUgJ3IgbWF5YmVfcmVzcG9uZCA9XG4gICAgICAgIHwgTm9fcmVzcG9uc2VfeWV0XG4gICAgICAgIHwgUmVzcG9uZCBvZiAnclxuXG4gICAgICBsZXQgbWF5YmVfcmVzcG9uZCB0IH5mID1cbiAgICAgICAgdFxuICAgICAgICAgIDo9IExpc3QuZmlsdGVyICF0IH5mOihmdW4geyBxdWVyeTsgcmVzcG9uc2UgfSAtPlxuICAgICAgICAgICAgICAgbWF0Y2ggZiBxdWVyeSB3aXRoXG4gICAgICAgICAgICAgICB8IE5vX3Jlc3BvbnNlX3lldCAtPiB0cnVlXG4gICAgICAgICAgICAgICB8IFJlc3BvbmQgcmVzcCAtPlxuICAgICAgICAgICAgICAgICBTdmFyLmZpbGxfaWZfZW1wdHkgcmVzcG9uc2UgcmVzcDtcbiAgICAgICAgICAgICAgICAgZmFsc2UpXG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgbGV0IG9mX3F1ZXJ5X3Jlc3BvbnNlX3RyYWNrZXIgcXJ0ID0gb2Zfc3Zhcl9mdW4gKFF1ZXJ5X3Jlc3BvbnNlX3RyYWNrZXIuYWRkX3F1ZXJ5IHFydClcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSBBZHZhbmNlZFxuIl19
