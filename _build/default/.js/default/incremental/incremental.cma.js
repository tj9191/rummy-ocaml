// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Incremental__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Incremental = [0],
    Incremental$0 = [0, Incremental];
   runtime.caml_register_global(0, Incremental$0, "Incremental__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Before_or_after
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Before_or_afte$0 = "Incremental__Before_or_after",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Before_or_afte$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/before_or_after.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "before_or_after.ml");
   var
    _a_ = [0, "After"],
    _b_ = [0, "Before"],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Before_or_afte = cst_Incremental_Before_or_afte$0;
   function sexp_of_t(param){return param ? _a_ : _b_;}
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Before_or_afte);
   var Incremental_Before_or_after = [0, sexp_of_t];
   runtime.caml_register_global
    (13, Incremental_Before_or_after, cst_Incremental_Before_or_afte$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Import
//# unitInfo: Requires: Core, Core__Array, Core__String, Core__Time_ns, Core__Uniform_array, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Uopt
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Import$0 = "Incremental__Import",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Array = global_data.Core__Array,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_String = global_data.Core__String,
    Core_Time_ns = global_data.Core__Time_ns,
    include = global_data.Uopt,
    Core_Uniform_array = global_data.Core__Uniform_array;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Import$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/import.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "import.ml");
   var
    concat = Core_String[46],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Import = cst_Incremental_Import$0,
    debug = 0;
   function tag(arg0_001, arg1_002, sexp_of_a){
    var
     res0_003 = caml_call1(Core[558], arg0_001),
     res1_004 = caml_call1(sexp_of_a, arg1_002);
    return [1, [0, res0_003, [0, res1_004, 0]]];
   }
   var
    Span = Core_Time_ns[1],
    Ofday = Core_Time_ns[2],
    hash_fold_t = Core_Time_ns[3],
    hash = Core_Time_ns[4],
    typerep_of_t = Core_Time_ns[5],
    typename_of_t = Core_Time_ns[6],
    bin_size_t = Core_Time_ns[7],
    bin_write_t = Core_Time_ns[8],
    bin_read_t = Core_Time_ns[9],
    bin_read_t$0 = Core_Time_ns[10],
    bin_shape_t = Core_Time_ns[11],
    bin_writer_t = Core_Time_ns[12],
    bin_reader_t = Core_Time_ns[13],
    bin_t = Core_Time_ns[14],
    symbol = Core_Time_ns[15],
    symbol$0 = Core_Time_ns[16],
    symbol$1 = Core_Time_ns[17],
    symbol$2 = Core_Time_ns[18],
    symbol$3 = Core_Time_ns[19],
    symbol$4 = Core_Time_ns[20],
    equal = Core_Time_ns[21],
    compare = Core_Time_ns[22],
    min = Core_Time_ns[23],
    max = Core_Time_ns[24],
    Alternate_sexp = Core_Time_ns[25],
    Option = Core_Time_ns[26],
    quickcheck_generator = Core_Time_ns[27],
    quickcheck_observer = Core_Time_ns[28],
    quickcheck_shrinker = Core_Time_ns[29],
    gen_incl = Core_Time_ns[30],
    gen_uniform_incl = Core_Time_ns[31],
    is_earlier = Core_Time_ns[32],
    is_later = Core_Time_ns[33],
    of_date_ofday = Core_Time_ns[34],
    of_date_ofday_precise = Core_Time_ns[35],
    to_date_ofday = Core_Time_ns[36],
    to_date_ofday_precise = Core_Time_ns[37],
    to_date = Core_Time_ns[38],
    to_ofday = Core_Time_ns[39],
    reset_date_cache = Core_Time_ns[40],
    convert = Core_Time_ns[41],
    utc_offset = Core_Time_ns[42],
    to_filename_string = Core_Time_ns[43],
    of_filename_string = Core_Time_ns[44],
    to_string_abs = Core_Time_ns[45],
    to_string_abs_trimmed = Core_Time_ns[46],
    to_string_abs_parts = Core_Time_ns[47],
    to_string_trimmed = Core_Time_ns[48],
    to_sec_string = Core_Time_ns[49],
    to_sec_string_with_zone = Core_Time_ns[50],
    of_localized_string = Core_Time_ns[51],
    of_string_gen = Core_Time_ns[52],
    to_string_iso8601_basic = Core_Time_ns[53],
    occurrence = Core_Time_ns[54],
    of_string = Core_Time_ns[55],
    of_string_with_utc_offset = Core_Time_ns[56],
    to_string = Core_Time_ns[57],
    to_string_utc = Core_Time_ns[58],
    epoch = Core_Time_ns[59],
    min_value_representable = Core_Time_ns[60],
    max_value_representable = Core_Time_ns[61],
    min_value_for_1us_rounding = Core_Time_ns[62],
    max_value_for_1us_rounding = Core_Time_ns[63],
    min_value = Core_Time_ns[64],
    max_value = Core_Time_ns[65],
    now = Core_Time_ns[66],
    add = Core_Time_ns[67],
    add_saturating = Core_Time_ns[68],
    sub_saturating = Core_Time_ns[69],
    sub = Core_Time_ns[70],
    next = Core_Time_ns[71],
    prev = Core_Time_ns[72],
    diff = Core_Time_ns[73],
    abs_diff = Core_Time_ns[74],
    to_span_since_epoch = Core_Time_ns[75],
    of_span_since_epoch = Core_Time_ns[76],
    to_int63_ns_since_epoch = Core_Time_ns[77],
    of_int63_ns_since_epoch = Core_Time_ns[78],
    to_int_ns_since_epoch = Core_Time_ns[79],
    of_int_ns_since_epoch = Core_Time_ns[80],
    next_multiple = Core_Time_ns[81],
    prev_multiple = Core_Time_ns[82],
    round_up_to_us = Core_Time_ns[83],
    round_up_to_ms = Core_Time_ns[84],
    round_up_to_sec = Core_Time_ns[85],
    round_down_to_us = Core_Time_ns[86],
    round_down_to_ms = Core_Time_ns[87],
    round_down_to_sec = Core_Time_ns[88],
    random = Core_Time_ns[89],
    of_time = Core_Time_ns[90],
    to_time = Core_Time_ns[91],
    to_time_float_round_nearest = Core_Time_ns[92],
    to_time_float_round_nearest_mi = Core_Time_ns[93],
    of_time_float_round_nearest = Core_Time_ns[94],
    of_time_float_round_nearest_mi = Core_Time_ns[95],
    Utc = Core_Time_ns[96],
    O = Core_Time_ns[97],
    Stable = Core_Time_ns[98],
    Hash_queue = Core_Time_ns[99],
    Hash_set = Core_Time_ns[100],
    Map = Core_Time_ns[101],
    Replace_polymorphic_compare = Core_Time_ns[102],
    Set = Core_Time_ns[103],
    Table = Core_Time_ns[104],
    Zone = Core_Time_ns[105],
    arg_type = Core_Time_ns[106],
    comparator = Core_Time_ns[107],
    get_sexp_zone = Core_Time_ns[108],
    interruptible_pause = Core_Time_ns[109],
    of_date_ofday_zoned = Core_Time_ns[110],
    of_string_abs = Core_Time_ns[111],
    of_string_fix_proto = Core_Time_ns[112],
    pause = Core_Time_ns[113],
    pause_forever = Core_Time_ns[114],
    pp = Core_Time_ns[115],
    set_sexp_zone = Core_Time_ns[116],
    sexp_of_t_abs = Core_Time_ns[118],
    t_of_sexp = Core_Time_ns[119],
    t_of_sexp_abs = Core_Time_ns[120],
    to_date_ofday_zoned = Core_Time_ns[121],
    to_ofday_zoned = Core_Time_ns[122],
    to_string_fix_proto = Core_Time_ns[123],
    validate_bound = Core_Time_ns[124],
    validate_lbound = Core_Time_ns[125],
    validate_ubound = Core_Time_ns[126],
    sexp_of_t = Core_Time_ns[25][12],
    Time_ns =
      [0,
       Span,
       Ofday,
       hash_fold_t,
       hash,
       typerep_of_t,
       typename_of_t,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       Alternate_sexp,
       Option,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       gen_incl,
       gen_uniform_incl,
       is_earlier,
       is_later,
       of_date_ofday,
       of_date_ofday_precise,
       to_date_ofday,
       to_date_ofday_precise,
       to_date,
       to_ofday,
       reset_date_cache,
       convert,
       utc_offset,
       to_filename_string,
       of_filename_string,
       to_string_abs,
       to_string_abs_trimmed,
       to_string_abs_parts,
       to_string_trimmed,
       to_sec_string,
       to_sec_string_with_zone,
       of_localized_string,
       of_string_gen,
       to_string_iso8601_basic,
       occurrence,
       of_string,
       of_string_with_utc_offset,
       to_string,
       to_string_utc,
       epoch,
       min_value_representable,
       max_value_representable,
       min_value_for_1us_rounding,
       max_value_for_1us_rounding,
       min_value,
       max_value,
       now,
       add,
       add_saturating,
       sub_saturating,
       sub,
       next,
       prev,
       diff,
       abs_diff,
       to_span_since_epoch,
       of_span_since_epoch,
       to_int63_ns_since_epoch,
       of_int63_ns_since_epoch,
       to_int_ns_since_epoch,
       of_int_ns_since_epoch,
       next_multiple,
       prev_multiple,
       round_up_to_us,
       round_up_to_ms,
       round_up_to_sec,
       round_down_to_us,
       round_down_to_ms,
       round_down_to_sec,
       random,
       of_time,
       to_time,
       to_time_float_round_nearest,
       to_time_float_round_nearest_mi,
       of_time_float_round_nearest,
       of_time_float_round_nearest_mi,
       Utc,
       O,
       Stable,
       Hash_queue,
       Hash_set,
       Map,
       Replace_polymorphic_compare,
       Set,
       Table,
       Zone,
       arg_type,
       comparator,
       get_sexp_zone,
       interruptible_pause,
       of_date_ofday_zoned,
       of_string_abs,
       of_string_fix_proto,
       pause,
       pause_forever,
       pp,
       set_sexp_zone,
       sexp_of_t_abs,
       t_of_sexp,
       t_of_sexp_abs,
       to_date_ofday_zoned,
       to_ofday_zoned,
       to_string_fix_proto,
       validate_bound,
       validate_lbound,
       validate_ubound,
       sexp_of_t],
    bin_shape_t$0 = Core_Array[1],
    bin_size_t$0 = Core_Array[2],
    bin_write_t$0 = Core_Array[3],
    bin_read_t$1 = Core_Array[4],
    bin_read_t$2 = Core_Array[5],
    bin_writer_t$0 = Core_Array[6],
    bin_reader_t$0 = Core_Array[7],
    bin_t$0 = Core_Array[8],
    bin_size_t_local = Core_Array[9],
    bin_write_t_local = Core_Array[10],
    quickcheck_generator$0 = Core_Array[11],
    quickcheck_observer$0 = Core_Array[12],
    quickcheck_shrinker$0 = Core_Array[13],
    typerep_of_t$0 = Core_Array[14],
    typename_of_t$0 = Core_Array[15],
    compare$0 = Core_Array[16],
    compare_local = Core_Array[17],
    globalize = Core_Array[18],
    t_of_sexp$0 = Core_Array[19],
    sexp_of_t$0 = Core_Array[20],
    t_sexp_grammar = Core_Array[21],
    binary_search = Core_Array[22],
    binary_search_segmented = Core_Array[23],
    of_list = Core_Array[24],
    of_array = Core_Array[25],
    append = Core_Array[26],
    map = Core_Array[27],
    filter = Core_Array[28],
    filter_map = Core_Array[29],
    concat_map = Core_Array[30],
    partition_tf = Core_Array[31],
    partition_map = Core_Array[32],
    mem = Core_Array[33],
    is_empty = Core_Array[34],
    iter = Core_Array[35],
    fold = Core_Array[36],
    fold_result = Core_Array[37],
    fold_until = Core_Array[38],
    exists = Core_Array[39],
    for_all = Core_Array[40],
    count = Core_Array[41],
    sum = Core_Array[42],
    find = Core_Array[43],
    find_map = Core_Array[44],
    to_list = Core_Array[45],
    to_array = Core_Array[46],
    min_elt = Core_Array[47],
    max_elt = Core_Array[48],
    foldi = Core_Array[49],
    iteri = Core_Array[50],
    existsi = Core_Array[51],
    for_alli = Core_Array[52],
    counti = Core_Array[53],
    findi = Core_Array[54],
    find_mapi = Core_Array[55],
    init = Core_Array[56],
    mapi = Core_Array[57],
    filteri = Core_Array[58],
    filter_mapi = Core_Array[59],
    concat_mapi = Core_Array[60],
    invariant = Core_Array[61],
    max_length = Core_Array[62],
    create = Core_Array[63],
    create_local = Core_Array[64],
    create_float_uninitialized = Core_Array[65],
    make_matrix = Core_Array[66],
    copy_matrix = Core_Array[67],
    concat$0 = Core_Array[68],
    copy = Core_Array[69],
    fill = Core_Array[70],
    blit = Core_Array[71],
    blito = Core_Array[72],
    unsafe_blit = Core_Array[73],
    sub$0 = Core_Array[74],
    subo = Core_Array[75],
    folding_map = Core_Array[76],
    folding_mapi = Core_Array[77],
    fold_map = Core_Array[78],
    fold_mapi = Core_Array[79],
    fold_right = Core_Array[80],
    sort = Core_Array[81],
    stable_sort = Core_Array[82],
    is_sorted = Core_Array[83],
    is_sorted_strictly = Core_Array[84],
    merge = Core_Array[85],
    partitioni_tf = Core_Array[86],
    cartesian_product = Core_Array[87],
    transpose = Core_Array[88],
    transpose_exn = Core_Array[89],
    filter_opt = Core_Array[90],
    iter2_exn = Core_Array[91],
    map2_exn = Core_Array[92],
    fold2_exn = Core_Array[93],
    for_all2_exn = Core_Array[94],
    exists2_exn = Core_Array[95],
    swap = Core_Array[96],
    rev_inplace = Core_Array[97],
    rev = Core_Array[98],
    of_list_rev = Core_Array[99],
    of_list_map = Core_Array[100],
    of_list_mapi = Core_Array[101],
    of_list_rev_map = Core_Array[102],
    of_list_rev_mapi = Core_Array[103],
    map_inplace = Core_Array[104],
    find_exn = Core_Array[105],
    find_map_exn = Core_Array[106],
    findi_exn = Core_Array[107],
    find_mapi_exn = Core_Array[108],
    find_consecutive_duplicate = Core_Array[109],
    reduce = Core_Array[110],
    reduce_exn = Core_Array[111],
    permute = Core_Array[112],
    random_element = Core_Array[113],
    random_element_exn = Core_Array[114],
    zip = Core_Array[115],
    zip_exn = Core_Array[116],
    unzip = Core_Array[117],
    sorted_copy = Core_Array[118],
    last = Core_Array[119],
    equal$0 = Core_Array[120],
    equal_local = Core_Array[121],
    to_sequence = Core_Array[122],
    to_sequence_mutable = Core_Array[123],
    Int = Core_Array[124],
    Float = Core_Array[125],
    normalize = Core_Array[126],
    slice = Core_Array[127],
    nget = Core_Array[128],
    nset = Core_Array[129],
    Permissioned = Core_Array[130];
   function realloc(t, len, a){
    var new_t = caml_call2(create, len, a);
    caml_call5(Core_Array[71], t, 0, new_t, 0, t.length - 1);
    return new_t;
   }
   var
    Array =
      [0,
       bin_shape_t$0,
       bin_size_t$0,
       bin_write_t$0,
       bin_read_t$1,
       bin_read_t$2,
       bin_writer_t$0,
       bin_reader_t$0,
       bin_t$0,
       bin_size_t_local,
       bin_write_t_local,
       quickcheck_generator$0,
       quickcheck_observer$0,
       quickcheck_shrinker$0,
       typerep_of_t$0,
       typename_of_t$0,
       compare$0,
       compare_local,
       globalize,
       t_of_sexp$0,
       sexp_of_t$0,
       t_sexp_grammar,
       binary_search,
       binary_search_segmented,
       of_list,
       of_array,
       append,
       map,
       filter,
       filter_map,
       concat_map,
       partition_tf,
       partition_map,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init,
       mapi,
       filteri,
       filter_mapi,
       concat_mapi,
       invariant,
       max_length,
       create,
       create_local,
       create_float_uninitialized,
       make_matrix,
       copy_matrix,
       concat$0,
       copy,
       fill,
       blit,
       blito,
       unsafe_blit,
       sub$0,
       subo,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       fold_right,
       sort,
       stable_sort,
       is_sorted,
       is_sorted_strictly,
       merge,
       partitioni_tf,
       cartesian_product,
       transpose,
       transpose_exn,
       filter_opt,
       iter2_exn,
       map2_exn,
       fold2_exn,
       for_all2_exn,
       exists2_exn,
       swap,
       rev_inplace,
       rev,
       of_list_rev,
       of_list_map,
       of_list_mapi,
       of_list_rev_map,
       of_list_rev_mapi,
       map_inplace,
       find_exn,
       find_map_exn,
       findi_exn,
       find_mapi_exn,
       find_consecutive_duplicate,
       reduce,
       reduce_exn,
       permute,
       random_element,
       random_element_exn,
       zip,
       zip_exn,
       unzip,
       sorted_copy,
       last,
       equal$0,
       equal_local,
       to_sequence,
       to_sequence_mutable,
       Int,
       Float,
       normalize,
       slice,
       nget,
       nset,
       Permissioned,
       realloc],
    t_of_sexp$1 = include[1],
    sexp_of_t$1 = include[2],
    globalize$0 = include[3],
    invariant$0 = include[4],
    none = include[5],
    some = include[6],
    is_none = include[7],
    is_some = include[8],
    value_exn = include[9],
    value = include[10],
    some_if = include[11],
    unsafe_value = include[12],
    to_option = include[13],
    of_option = include[14],
    Optional_syntax = include[15],
    Local = include[16],
    Uopt =
      [0,
       t_of_sexp$1,
       sexp_of_t$1,
       globalize$0,
       invariant$0,
       none,
       some,
       is_none,
       is_some,
       value_exn,
       value,
       some_if,
       to_option,
       of_option,
       Optional_syntax,
       Local,
       unsafe_value],
    bin_shape_t$1 = Core_Uniform_array[1],
    bin_size_t$1 = Core_Uniform_array[2],
    bin_write_t$1 = Core_Uniform_array[3],
    bin_read_t$3 = Core_Uniform_array[4],
    bin_read_t$4 = Core_Uniform_array[5],
    bin_writer_t$1 = Core_Uniform_array[6],
    bin_reader_t$1 = Core_Uniform_array[7],
    bin_t$1 = Core_Uniform_array[8],
    t_of_sexp$2 = Core_Uniform_array[9],
    sexp_of_t$2 = Core_Uniform_array[10],
    t_sexp_grammar$0 = Core_Uniform_array[11],
    compare$1 = Core_Uniform_array[12],
    compare_local$0 = Core_Uniform_array[13],
    invariant$1 = Core_Uniform_array[14],
    empty = Core_Uniform_array[15],
    create$0 = Core_Uniform_array[16],
    singleton = Core_Uniform_array[17],
    init$0 = Core_Uniform_array[18],
    length = Core_Uniform_array[19],
    get = Core_Uniform_array[20],
    unsafe_get = Core_Uniform_array[21],
    unsafe_get_local = Core_Uniform_array[22],
    swap$0 = Core_Uniform_array[25],
    unsafe_set_omit_phys_equal_che = Core_Uniform_array[26],
    unsafe_set_with_caml_modify = Core_Uniform_array[27],
    set_with_caml_modify = Core_Uniform_array[28],
    map$0 = Core_Uniform_array[29],
    mapi$0 = Core_Uniform_array[30],
    iter$0 = Core_Uniform_array[31],
    iteri$0 = Core_Uniform_array[32],
    fold$0 = Core_Uniform_array[33],
    foldi$0 = Core_Uniform_array[34],
    unsafe_to_array_inplace_promis = Core_Uniform_array[35],
    of_array$0 = Core_Uniform_array[36],
    to_array$0 = Core_Uniform_array[37],
    of_list$0 = Core_Uniform_array[38],
    of_list_rev$0 = Core_Uniform_array[39],
    to_list$0 = Core_Uniform_array[40],
    blit$0 = Core_Uniform_array[41],
    blito$0 = Core_Uniform_array[42],
    unsafe_blit$0 = Core_Uniform_array[43],
    sub$1 = Core_Uniform_array[44],
    subo$0 = Core_Uniform_array[45],
    copy$0 = Core_Uniform_array[46],
    exists$0 = Core_Uniform_array[47],
    existsi$0 = Core_Uniform_array[48],
    for_all$0 = Core_Uniform_array[49],
    for_alli$0 = Core_Uniform_array[50],
    concat$1 = Core_Uniform_array[51],
    concat_map$0 = Core_Uniform_array[52],
    concat_mapi$0 = Core_Uniform_array[53],
    partition_map$0 = Core_Uniform_array[54],
    filter$0 = Core_Uniform_array[55],
    filteri$0 = Core_Uniform_array[56],
    filter_map$0 = Core_Uniform_array[57],
    filter_mapi$0 = Core_Uniform_array[58],
    find$0 = Core_Uniform_array[59],
    findi$0 = Core_Uniform_array[60],
    find_map$0 = Core_Uniform_array[61],
    find_mapi$0 = Core_Uniform_array[62],
    map2_exn$0 = Core_Uniform_array[63],
    fold2_exn$0 = Core_Uniform_array[64],
    min_elt$0 = Core_Uniform_array[65],
    max_elt$0 = Core_Uniform_array[66],
    sort$0 = Core_Uniform_array[67],
    binary_search$0 = Core_Uniform_array[68],
    binary_search_segmented$0 = Core_Uniform_array[69],
    unsafe_create_uninitialized = Core_Uniform_array[70],
    create_obj_array = Core_Uniform_array[71],
    unsafe_set_assuming_currently_ = Core_Uniform_array[72],
    unsafe_set_int_assuming_curren = Core_Uniform_array[73],
    unsafe_set_int = Core_Uniform_array[74],
    unsafe_clear_if_pointer = Core_Uniform_array[75];
   function realloc$0(t, len){
    var new_t = caml_call2(create$0, len, Uopt[5]);
    caml_call5(blit$0, t, 0, new_t, 0, caml_call1(length, t));
    return new_t;
   }
   var
    Uniform_array =
      [0,
       bin_shape_t$1,
       bin_size_t$1,
       bin_write_t$1,
       bin_read_t$3,
       bin_read_t$4,
       bin_writer_t$1,
       bin_reader_t$1,
       bin_t$1,
       t_of_sexp$2,
       sexp_of_t$2,
       t_sexp_grammar$0,
       compare$1,
       compare_local$0,
       invariant$1,
       empty,
       create$0,
       singleton,
       init$0,
       length,
       get,
       unsafe_get,
       unsafe_get_local,
       swap$0,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       set_with_caml_modify,
       map$0,
       mapi$0,
       iter$0,
       iteri$0,
       fold$0,
       foldi$0,
       unsafe_to_array_inplace_promis,
       of_array$0,
       to_array$0,
       of_list$0,
       of_list_rev$0,
       to_list$0,
       blit$0,
       blito$0,
       unsafe_blit$0,
       sub$1,
       subo$0,
       copy$0,
       exists$0,
       existsi$0,
       for_all$0,
       for_alli$0,
       concat$1,
       concat_map$0,
       concat_mapi$0,
       partition_map$0,
       filter$0,
       filteri$0,
       filter_map$0,
       filter_mapi$0,
       find$0,
       findi$0,
       find_map$0,
       find_mapi$0,
       map2_exn$0,
       fold2_exn$0,
       min_elt$0,
       max_elt$0,
       sort$0,
       binary_search$0,
       binary_search_segmented$0,
       unsafe_create_uninitialized,
       create_obj_array,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_clear_if_pointer,
       unsafe_set_with_caml_modify,
       set_with_caml_modify,
       realloc$0];
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Import);
   var
    Incremental_Import =
      [0, debug, concat, tag, Time_ns, Array, Uopt, Uniform_array];
   runtime.caml_register_global
    (17, Incremental_Import, cst_Incremental_Import$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Cutoff
//# unitInfo: Requires: Base__Invariant, Core, Core__Sexp, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Always = "Always",
    cst_Compare = "Compare",
    cst_Equal = "Equal",
    cst_F = "F",
    cst_Incremental_Cutoff$0 = "Incremental__Cutoff",
    cst_Never = "Never",
    cst_Phys_equal = "Phys_equal",
    cst_always = "always",
    cst_compare = "compare",
    cst_equal = "equal",
    cst_f = "f",
    cst_incremental$0 = "incremental",
    cst_never = "never",
    cst_phys_equal = "phys_equal",
    cst_src_cutoff_ml = "src/cutoff.ml",
    caml_string_compare = runtime.caml_string_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_012 = "src/cutoff.ml.For_analyzer.t",
    Core_Sexp = global_data.Core__Sexp,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Core = global_data.Core,
    Base_Invariant = global_data.Base__Invariant,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Cutoff$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_cutoff_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "cutoff.ml");
   var
    _i_ = [0, cst_Always],
    _j_ = [0, cst_Never],
    _k_ = [0, cst_Phys_equal],
    _l_ = [0, cst_Compare],
    _m_ = [0, cst_Equal],
    _n_ = [0, cst_F],
    _g_ = [0, "_"],
    _h_ = [0, cst_src_cutoff_ml, 17, 409, 431],
    _a_ = [0, cst_Always],
    _b_ = [0, cst_Never],
    _c_ = [0, cst_Phys_equal],
    _d_ = [0, cst_Compare],
    _e_ = [0, cst_Equal],
    _f_ = [0, cst_F],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Cutoff = cst_Incremental_Cutoff$0;
   function sexp_of_t(of_a_001, param){
    if(typeof param === "number")
     switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;}
    switch(param[0]){
      case 0:
       var
        _A_ = function(_F_){return 0;},
        res0_003 = caml_call1(Sexplib0_Sexp_conv[24], _A_);
       return [1, [0, _d_, [0, res0_003, 0]]];
      case 1:
       var
        _B_ = function(_E_){return 0;},
        res0_005 = caml_call1(Sexplib0_Sexp_conv[24], _B_);
       return [1, [0, _e_, [0, res0_005, 0]]];
      default:
       var
        _C_ = function(_D_){return 0;},
        res0_007 = caml_call1(Sexplib0_Sexp_conv[24], _C_);
       return [1, [0, _f_, [0, res0_007, 0]]];
    }
   }
   function invariant(param, t){
    function _y_(param){return 0;}
    function _z_(x_009){
     return sexp_of_t(function(param){return _g_;}, x_009);
    }
    return caml_call4(Base_Invariant[1], _h_, t, _z_, _y_);
   }
   function create(f){return [2, f];}
   function of_compare(f){return [0, f];}
   function of_equal(f){return [1, f];}
   var poly_equal = [1, runtime.caml_equal], never = 1, always = 0;
   function should_cutoff(t, old_value, new_value){
    if(typeof t === "number")
     switch(t){
       case 0:
        return 1;
       case 1:
        return 0;
       default: return old_value === new_value ? 1 : 0;
     }
    switch(t[0]){
      case 0:
       var f = t[1], _x_ = caml_call2(f, old_value, new_value);
       return caml_call2(Core[90], _x_, 0);
      case 1:
       var f$0 = t[1]; return caml_call2(f$0, old_value, new_value);
      default: var f$1 = t[1]; return caml_call2(f$1, old_value, new_value);
    }
   }
   function equal(t1, t2){
    if(typeof t1 === "number")
     switch(t1){
       case 0:
        if(typeof t2 === "number" && ! t2) return 1; return 0;
       case 1:
        if(typeof t2 === "number" && 1 === t2) return 1; return 0;
       default: if(typeof t2 === "number" && 2 <= t2) return 1; return 0;
     }
    switch(t1[0]){
      case 0:
       var f1 = t1[1];
       if(typeof t2 !== "number" && 0 === t2[0]){
        var f2 = t2[1];
        return f1 === f2 ? 1 : 0;
       }
       return 0;
      case 1:
       var f1$0 = t1[1];
       if(typeof t2 !== "number" && 1 === t2[0]){
        var f2$0 = t2[1];
        return f1$0 === f2$0 ? 1 : 0;
       }
       return 0;
      default:
       var f1$1 = t1[1];
       if(typeof t2 !== "number" && 2 === t2[0]){
        var f2$1 = t2[1];
        return f1$1 === f2$1 ? 1 : 0;
       }
       return 0;
    }
   }
   var phys_equal = 2;
   function t_of_sexp(sexp_013){
    a:
    {
     if(0 === sexp_013[0]){
      var _r_ = sexp_013[1], _s_ = caml_string_compare(_r_, cst_always);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          f:
          {
           if(0 <= _s_){
            if(0 < _s_){
             if(! caml_string_notequal(_r_, cst_compare)) break f;
             if(! caml_string_notequal(_r_, cst_equal)) break e;
             if(! caml_string_notequal(_r_, cst_f)) break d;
             if(! caml_string_notequal(_r_, cst_never)) break c;
             if(caml_string_notequal(_r_, cst_phys_equal)) break a;
             break b;
            }
           }
           else if(caml_string_notequal(_r_, cst_Always)){
            if(! caml_string_notequal(_r_, cst_Compare)) break f;
            if(! caml_string_notequal(_r_, cst_Equal)) break e;
            if(! caml_string_notequal(_r_, cst_F)) break d;
            if(! caml_string_notequal(_r_, cst_Never)) break c;
            if(caml_string_notequal(_r_, cst_Phys_equal)) break a;
            break b;
           }
           return 0;
          }
          return 3;
         }
         return 4;
        }
        return 5;
       }
       return 1;
      }
      return 2;
     }
     var _t_ = sexp_013[1];
     if(! _t_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_012, sexp_013);
     var _u_ = _t_[1];
     if(0 !== _u_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_012, sexp_013);
     var _v_ = _u_[1], _w_ = caml_string_compare(_v_, cst_always);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          if(0 <= _w_){
           if(0 < _w_){
            if(! caml_string_notequal(_v_, cst_compare)) break f;
            if(! caml_string_notequal(_v_, cst_equal)) break e;
            if(! caml_string_notequal(_v_, cst_f)) break d;
            if(! caml_string_notequal(_v_, cst_never)) break c;
            if(caml_string_notequal(_v_, cst_phys_equal)) break a;
            break b;
           }
          }
          else if(caml_string_notequal(_v_, cst_Always)){
           if(! caml_string_notequal(_v_, cst_Compare)) break f;
           if(! caml_string_notequal(_v_, cst_Equal)) break e;
           if(! caml_string_notequal(_v_, cst_F)) break d;
           if(! caml_string_notequal(_v_, cst_Never)) break c;
           if(caml_string_notequal(_v_, cst_Phys_equal)) break a;
           break b;
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[7], error_source_012, sexp_013);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7], error_source_012, sexp_013);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[7], error_source_012, sexp_013);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_012, sexp_013);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_012, sexp_013);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_012, sexp_013);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_012, sexp_013);
   }
   function sexp_of_t$0(param){
    switch(param){
      case 0:
       return _i_;
      case 1:
       return _j_;
      case 2:
       return _k_;
      case 3:
       return _l_;
      case 4:
       return _m_;
      default: return _n_;
    }
   }
   function equal$0(_q_, _p_){return _q_ === _p_ ? 1 : 0;}
   function of_cutoff(c){
    if(typeof c === "number")
     switch(c){case 0: return 0;case 1: return 1;default: return 2;}
    switch(c[0]){case 0: return 3;case 1: return 4;default: return 5;
    }
   }
   function to_string(t){
    var _o_ = sexp_of_t$0(t);
    return caml_call1(Core_Sexp[86], _o_);
   }
   var
    For_analyzer = [0, t_of_sexp, sexp_of_t$0, equal$0, of_cutoff, to_string];
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Cutoff);
   var
    Incremental_Cutoff =
      [0,
       sexp_of_t,
       invariant,
       create,
       of_compare,
       of_equal,
       always,
       never,
       phys_equal,
       poly_equal,
       equal,
       should_cutoff,
       For_analyzer];
   runtime.caml_register_global
    (55, Incremental_Cutoff, cst_Incremental_Cutoff$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Dot_user_info
//# unitInfo: Requires: Core, Core__Info, Core__List, Core__Map, Core__Set, Core__String, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv_error, Sexplib0__Sexp_conv_record
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = '"',
    cst_Append = "Append",
    cst_Dot = "Dot",
    cst_Incremental_Dot_user_info$0 = "Incremental__Dot_user_info",
    cst_Info = "Info",
    cst_append = "append",
    cst_attributes$0 = "attributes",
    cst_dot = "dot",
    cst_incremental$0 = "incremental",
    cst_info = "info",
    cst_label$0 = "label",
    cst_new$0 = "new_",
    cst_prior$0 = "prior",
    cst$9 = "{",
    cst$10 = "|",
    cst$8 = "}",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$6 = cst$8,
    cst$7 = cst$9,
    cst$4 = cst$8,
    cst$5 = cst$9,
    cst$3 = "\\",
    cst = cst$11,
    cst$0 = '\\"',
    cst$1 = cst$11,
    cst$2 = cst$11,
    error_source_009 = "src/dot_user_info.ml.dot",
    error_source_018 = "src/dot_user_info.ml.t",
    Core_String = global_data.Core__String,
    Core_Info = global_data.Core__Info,
    Core_Set = global_data.Core__Set,
    Core_Map = global_data.Core__Map,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Dot_user_info$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/dot_user_info.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "dot_user_info.ml");
   var
    _j_ = [0, [12, 32, [2, 0, [12, 61, [2, 0, 0]]]], " %s=%s"],
    _h_ = [0, cst$10],
    cst_Mrecord = "Mrecord",
    _i_ = [0, cst$10],
    _k_ = [0, " "],
    _l_ =
      [0,
       [11,
        "  ",
        [2,
         0,
         [11,
          " [shape=",
          [2, 0, [11, " label=", [2, 0, [12, 32, [2, 0, [12, 93, 0]]]]]]]]],
       "  %s [shape=%s label=%s %s]"],
    _c_ = [0, cst_Dot],
    _d_ = [0, cst_Info],
    _e_ = [0, cst_new$0],
    _f_ = [0, cst_prior$0],
    _g_ = [0, cst_Append],
    cst_new = cst_new$0,
    cst_prior = cst_prior$0,
    _a_ = [0, cst_attributes$0],
    _b_ = [0, cst_label$0],
    cst_attributes = cst_attributes$0,
    cst_label = cst_label$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Dot_user_info = cst_Incremental_Dot_user_info$0;
   function t_of_sexp(x_006){return caml_call2(Core[473], Core[559], x_006);}
   function sexp_of_t(x_007){return caml_call2(Core[472], Core[558], x_007);}
   var comparator = caml_call1(Core_List[171], Core_String[158]);
   function dot_of_sexp(x_010){
    function _P_(param){
     var attributes = param[2][1], label = param[1];
     return [0, label, attributes];
    }
    var _Q_ = 0;
    function _R_(param){
     return caml_string_notequal(param, cst_attributes$0)
             ? caml_string_notequal(param, cst_label$0) ? -1 : 0
             : 1;
    }
    var
     _S_ =
       [0, cst_attributes, 1, caml_call1(Core_String[159][44], Core[559]), 0],
     _T_ =
       [0,
        cst_label,
        1,
        caml_call1(Core_Set[86], [0, t_of_sexp, comparator]),
        _S_];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_009,
             _T_,
             _R_,
             _Q_,
             _P_,
             x_010);
   }
   function sexp_of_dot(param){
    var
     attributes_014 = param[2],
     label_012 = param[1],
     arg_015 = caml_call2(Core_String[159][45], Core[558], attributes_014),
     bnds_011 = [0, [1, [0, _a_, [0, arg_015, 0]]], 0],
     arg_013 = caml_call2(Core_Set[85], [0, sexp_of_t], label_012),
     bnds_011$0 = [0, [1, [0, _b_, [0, arg_013, 0]]], bnds_011];
    return [1, bnds_011$0];
   }
   var t_of_sexp$0 = function _O_(_N_){return _O_.fun(_N_);};
   runtime.caml_update_dummy
    (t_of_sexp$0,
     function(sexp_020){
      a:
      {
       if(0 === sexp_020[0]){
        var _H_ = sexp_020[1];
        b:
        if(caml_string_notequal(_H_, cst_Append)){
         c:
         if(caml_string_notequal(_H_, cst_Dot)){
          if(caml_string_notequal(_H_, cst_Info)){
           if(! caml_string_notequal(_H_, cst_append)) break b;
           if(! caml_string_notequal(_H_, cst_dot)) break c;
           if(caml_string_notequal(_H_, cst_info)) break a;
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[9], error_source_018, sexp_020);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[9], error_source_018, sexp_020);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_018, sexp_020);
       }
       var _I_ = sexp_020[1];
       if(! _I_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[11], error_source_018, sexp_020);
       var _J_ = _I_[1];
       if(0 !== _J_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[10], error_source_018, sexp_020);
       var tag_021 = _J_[1];
       b:
       if(caml_string_notequal(tag_021, cst_Append)){
        c:
        if(caml_string_notequal(tag_021, cst_Dot)){
         if(caml_string_notequal(tag_021, cst_Info)){
          if(! caml_string_notequal(tag_021, cst_append)) break b;
          if(! caml_string_notequal(tag_021, cst_dot)) break c;
          if(caml_string_notequal(tag_021, cst_info)) break a;
         }
         var sexp_args_027 = _I_[2];
         if(sexp_args_027 && ! sexp_args_027[2]){
          var
           arg0_028 = sexp_args_027[1],
           res0_029 = caml_call1(Core_Info[8], arg0_028);
          return [1, res0_029];
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[8],
                  error_source_018,
                  tag_021,
                  sexp_020);
        }
        var sexp_args_022 = _I_[2];
        if(sexp_args_022 && ! sexp_args_022[2]){
         var arg0_023 = sexp_args_022[1], res0_024 = dot_of_sexp(arg0_023);
         return [0, res0_024];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[8],
                 error_source_018,
                 tag_021,
                 sexp_020);
       }
       var
        sexps_031 = _I_[2],
        _K_ =
          function(param){
           var new$0 = param[2][1], prior = param[1];
           return [2, prior, new$0];
          },
        _L_ = 0,
        _M_ =
          function(param){
           return caml_string_notequal(param, cst_new$0)
                   ? caml_string_notequal(param, cst_prior$0) ? -1 : 0
                   : 1;
          };
       return caml_call7
               (Sexplib0_Sexp_conv_record[4],
                error_source_018,
                sexp_020,
                [0,
                 cst_prior,
                 1,
                 t_of_sexp$0,
                 [0, cst_new, 1, t_of_sexp$0, 0]],
                _M_,
                _L_,
                _K_,
                sexps_031);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[12], error_source_018, sexp_020);
     });
   function sexp_of_t$0(param){
    switch(param[0]){
      case 0:
       var arg0_032 = param[1], res0_033 = sexp_of_dot(arg0_032);
       return [1, [0, _c_, [0, res0_033, 0]]];
      case 1:
       var arg0_034 = param[1], res0_035 = caml_call1(Core_Info[9], arg0_034);
       return [1, [0, _d_, [0, res0_035, 0]]];
      default:
       var
        new_039 = param[2],
        prior_037 = param[1],
        arg_040 = sexp_of_t$0(new_039),
        bnds_036 = [0, [1, [0, _e_, [0, arg_040, 0]]], 0],
        arg_038 = sexp_of_t$0(prior_037),
        bnds_036$0 = [0, [1, [0, _f_, [0, arg_038, 0]]], bnds_036];
       return [1, [0, _g_, bnds_036$0]];
    }
   }
   function info(info){return [1, info];}
   function append(prior, new$0){return [2, prior, new$0];}
   function dot(label, attributes){
    var label$0 = caml_call2(Core_Set[8], [0, comparator], label);
    return [0, [0, label$0, attributes]];
   }
   function to_dot(param){
    switch(param[0]){
      case 0:
       var dot = param[1]; return dot;
      case 1:
       var
        i = param[1],
        _E_ = Core_String[159][5],
        _F_ = [0, caml_call1(Core_Info[12], i), 0];
       return [0, caml_call2(Core_Set[8], [0, comparator], _F_), _E_];
      default:
       var
        new$0 = param[2],
        prior = param[1],
        prior$0 = to_dot(prior),
        new$1 = to_dot(new$0),
        label = caml_call2(Core_Set[14], prior$0[1], new$1[1]),
        _G_ = function(param, left, right){return right;},
        attributes = caml_call3(Core_Map[86], prior$0[2], new$1[2], _G_);
       return [0, label, attributes];
    }
   }
   function escape_dot_string(s){
    var
     _C_ = caml_call3(Core_String[67], s, cst$1, cst$0),
     _D_ = caml_call2(Core[18], _C_, cst);
    return caml_call2(Core[18], cst$2, _D_);
   }
   function escape_record_label(s){
    function _z_(c){
     a:
     {
      if(62 <= c){
       var _A_ = c - 63 | 0;
       if(59 < _A_ >>> 0){if(63 <= _A_) break a;} else if(29 !== _A_) break a;
      }
      else if(32 !== c && 60 !== c) break a;
      var _B_ = caml_call1(Core_String[111], c);
      return caml_call2(Core[18], cst$3, _B_);
     }
     return caml_call1(Core_String[111], c);
    }
    return caml_call3(Core_String[86], 0, s, _z_);
   }
   function to_string(opt, name, param){
    if(opt) var sth = opt[1], shape = sth; else var shape = cst_Mrecord;
    var attributes = param[2], label = param[1];
    function _m_(cols){
     var
      _w_ = caml_call2(Core_List[51], cols, escape_record_label),
      _x_ = caml_call2(Core_String[46], _h_, _w_),
      _y_ = caml_call2(Core[18], _x_, cst$4);
     return caml_call2(Core[18], cst$5, _y_);
    }
    var
     _n_ = caml_call1(Core_Set[39], label),
     _o_ = caml_call2(Core_List[51], _n_, _m_),
     s = caml_call2(Core_String[46], _i_, _o_),
     _p_ = caml_call2(Core[18], s, cst$6),
     label$0 = caml_call2(Core[18], cst$7, _p_);
    function _q_(param){
     var
      v = param[2],
      k = param[1],
      _u_ = escape_dot_string(v),
      _v_ = escape_dot_string(k);
     return caml_call3(Core[265], _j_, _v_, _u_);
    }
    var
     _r_ = caml_call2(Core_Map[81], 0, attributes),
     _s_ = caml_call2(Core_List[51], _r_, _q_),
     attributes$0 = caml_call2(Core_String[46], _k_, _s_),
     _t_ = escape_dot_string(label$0);
    return caml_call5(Core[265], _l_, name, shape, _t_, attributes$0);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Dot_user_info);
   var
    Incremental_Dot_user_info =
      [0,
       sexp_of_dot,
       dot_of_sexp,
       t_of_sexp$0,
       sexp_of_t$0,
       info,
       dot,
       to_dot,
       append,
       to_string];
   runtime.caml_register_global
    (63, Incremental_Dot_user_info, cst_Incremental_Dot_user_info$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Node_id
//# unitInfo: Requires: Core__Int, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Node_id$0 = "Incremental__Node_id",
    cst_incremental$0 = "incremental",
    cst_src_node_id_ml = "src/node_id.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Int = global_data.Core__Int;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Node_id$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_node_id_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "node_id.ml");
   var
    incr = Core_Int[36],
    sexp_of_t = Core_Int[77],
    to_string = Core_Int[79],
    symbol = Core_Int[81],
    compare = Core_Int[88],
    hash_fold_t = Core_Int[100],
    hash = Core_Int[101],
    hashable = Core_Int[102],
    Table = Core_Int[103],
    Hash_set = Core_Int[104],
    Hash_queue = Core_Int[105],
    _a_ = [0, cst_src_node_id_ml, 5, 18],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Node_id = cst_Incremental_Node_id$0;
   function invariant(t){
    if(caml_call2(symbol, t, 1)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   var r = [0, 0];
   function next(param){caml_call1(incr, r); return r[1];}
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Node_id);
   var
    Incremental_Node_id =
      [0,
       sexp_of_t,
       compare,
       hash_fold_t,
       hash,
       hashable,
       [0,
        Table[1],
        Table[2],
        Table[3],
        Table[4],
        Table[5],
        Table[6],
        Table[7],
        Table[8],
        Table[9],
        Table[10],
        Table[11],
        Table[12],
        Table[13],
        Table[14],
        Table[15],
        Table[16],
        Table[17],
        Table[18]],
       [0,
        Hash_set[1],
        Hash_set[2],
        Hash_set[3],
        Hash_set[4],
        Hash_set[5],
        Hash_set[6],
        Hash_set[7]],
       Hash_queue,
       invariant,
       next,
       to_string];
   runtime.caml_register_global
    (14, Incremental_Node_id, cst_Incremental_Node_id$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Stabilization_num
//# unitInfo: Requires: Core__Int, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Stabilization_$0 = "Incremental__Stabilization_num",
    cst_incremental$0 = "incremental",
    cst_src_stabilization_num_ml = "src/stabilization_num.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Int = global_data.Core__Int;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Stabilization_$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_stabilization_num_ml);
   caml_call2
    (Ppx_inline_test_lib[6], cst_incremental$0, "stabilization_num.ml");
   var
    zero = Core_Int[59],
    to_int = Core_Int[65],
    sexp_of_t = Core_Int[77],
    symbol = Core_Int[81],
    symbol$0 = Core_Int[83],
    equal = Core_Int[87],
    compare = Core_Int[88],
    _a_ = [0, cst_src_stabilization_num_ml, 5, 18],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Stabilization_ = cst_Incremental_Stabilization_$0;
   function invariant(t){
    if(caml_call2(symbol, t, -1)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   var none = -1;
   function is_none(t){return caml_call2(symbol$0, t, none);}
   function is_some(t){return caml_call2(symbol, t, 0);}
   function add1(t){return t + 1 | 0;}
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Stabilization_);
   var
    _b_ = Core_Int[99],
    _c_ = _b_[2],
    _d_ = _b_[1],
    _e_ = Core_Int[98],
    _f_ = _e_[2],
    _g_ = _e_[1],
    Incremental_Stabilization_num =
      [0,
       compare,
       sexp_of_t,
       equal,
       invariant,
       none,
       zero,
       is_none,
       is_some,
       add1,
       to_int,
       [0,
        Core_Int[76],
        Core_Int[77],
        Core_Int[81],
        Core_Int[82],
        Core_Int[83],
        Core_Int[84],
        Core_Int[85],
        Core_Int[86],
        Core_Int[87],
        Core_Int[88],
        Core_Int[89],
        Core_Int[90],
        Core_Int[91],
        Core_Int[92],
        Core_Int[93],
        Core_Int[94],
        Core_Int[95],
        Core_Int[97],
        Core_Int[106],
        Core_Int[107],
        Core_Int[108],
        Core_Int[96],
        [0,
         [0, _g_[9], _g_[10], _g_[11]],
         [0, _f_[9], _f_[10], _f_[11], _f_[12], _f_[13]],
         _e_[3],
         _e_[4],
         _e_[5],
         _e_[6],
         _e_[7],
         _e_[8],
         _e_[9],
         _e_[10],
         _e_[11],
         _e_[12],
         _e_[13],
         _e_[14],
         _e_[15],
         _e_[16],
         _e_[17],
         _e_[18],
         _e_[19],
         _e_[20],
         _e_[21],
         _e_[22],
         _e_[23],
         _e_[24],
         _e_[25],
         _e_[26],
         _e_[27],
         _e_[28],
         _e_[29],
         _e_[30],
         _e_[31],
         _e_[32],
         _e_[33],
         _e_[34],
         _e_[35],
         _e_[36],
         _e_[37],
         _e_[38],
         _e_[39],
         _e_[40],
         _e_[41],
         _e_[42],
         _e_[43],
         _e_[44],
         _e_[45]],
        [0,
         [0, _d_[1], _d_[2], _d_[11]],
         [0, _c_[9], _c_[10], _c_[11], _c_[12], _c_[13]],
         _b_[3],
         _b_[4],
         _b_[5],
         _b_[6],
         _b_[7],
         _b_[8],
         _b_[9],
         _b_[10],
         _b_[11],
         _b_[12],
         _b_[13],
         _b_[14],
         _b_[15],
         _b_[16],
         _b_[17],
         _b_[18],
         _b_[19],
         _b_[20],
         _b_[21],
         _b_[22],
         _b_[23],
         _b_[24],
         _b_[25],
         _b_[26],
         _b_[27],
         _b_[28]],
        Core_Int[79]]];
   runtime.caml_register_global
    (14, Incremental_Stabilization_num, cst_Incremental_Stabilization_$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__On_update_handler
//# unitInfo: Requires: Core, Incremental__Stabilization_num, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Changed = "Changed",
    cst_Incremental_On_update_hand$0 = "Incremental__On_update_handler",
    cst_Invalidated = "Invalidated",
    cst_Necessary = "Necessary",
    cst_Unnecessary = "Unnecessary",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Incremental_Stabilization_num = global_data.Incremental__Stabilization_num,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_On_update_hand$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/on_update_handler.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_incremental$0, "on_update_handler.ml");
   var
    _j_ = [0, "created_at"],
    _k_ = [0, "previous_update_kind"],
    _l_ = [0, "f"],
    _f_ = [0, cst_Invalidated],
    _g_ = [0, cst_Unnecessary],
    _h_ = [0, cst_Necessary],
    _i_ = [0, cst_Changed],
    _a_ = [0, "Never_been_updated"],
    _b_ = [0, cst_Necessary],
    _c_ = [0, cst_Changed],
    _d_ = [0, cst_Invalidated],
    _e_ = [0, cst_Unnecessary],
    cst_incremental = cst_incremental$0,
    cst_Incremental_On_update_hand = cst_Incremental_On_update_hand$0;
   function compare(cmp_a, a_001, b_002){
    if(a_001 === b_002) return 0;
    a:
    {
     if(typeof a_001 === "number"){
      if(0 === a_001){
       if(typeof b_002 === "number") return 0 === b_002 ? 0 : -1;
       if(0 === b_002[0]) break a;
      }
      else{
       if(typeof b_002 === "number") return 0 === b_002 ? 1 : 0;
       if(0 === b_002[0]) break a;
      }
      return 1;
     }
     if(0 === a_001[0]){
      var a_003 = a_001[1];
      if(typeof b_002 !== "number" && 0 === b_002[0]){
       var b_004 = b_002[1];
       return caml_call2(cmp_a, a_003, b_004);
      }
      return -1;
     }
     var a_007 = a_001[2], a_005 = a_001[1];
     if(typeof b_002 === "number") return -1;
     if(0 !== b_002[0]){
      var
       b_008 = b_002[2],
       b_006 = b_002[1],
       n = caml_call2(cmp_a, a_005, b_006);
      return 0 === n ? caml_call2(cmp_a, a_007, b_008) : n;
     }
    }
    return 1;
   }
   function sexp_of_t(of_a_009, param){
    if(typeof param === "number") return 0 === param ? _f_ : _g_;
    if(0 === param[0]){
     var arg0_010 = param[1], res0_011 = caml_call1(of_a_009, arg0_010);
     return [1, [0, _h_, [0, res0_011, 0]]];
    }
    var
     arg1_013 = param[2],
     arg0_012 = param[1],
     res0_014 = caml_call1(of_a_009, arg0_012),
     res1_015 = caml_call1(of_a_009, arg1_013);
    return [1, [0, _i_, [0, res0_014, [0, res1_015, 0]]]];
   }
   var Node_update = [0, compare, sexp_of_t];
   function sexp_of_t$0(of_a_017, param){
    var
     previous_update_kind_021 = param[2],
     created_at_023 = param[3],
     arg_024 = caml_call1(Incremental_Stabilization_num[2], created_at_023),
     bnds_018 = [0, [1, [0, _j_, [0, arg_024, 0]]], 0];
    switch(previous_update_kind_021){
      case 0:
       var arg_022 = _a_; break;
      case 1:
       var arg_022 = _b_; break;
      case 2:
       var arg_022 = _c_; break;
      case 3:
       var arg_022 = _d_; break;
      default: var arg_022 = _e_;
    }
    var bnds_018$0 = [0, [1, [0, _k_, [0, arg_022, 0]]], bnds_018];
    function _p_(_q_){return 0;}
    var
     arg_020 = caml_call1(Sexplib0_Sexp_conv[24], _p_),
     bnds_018$1 = [0, [1, [0, _l_, [0, arg_020, 0]]], bnds_018$0];
    return [1, bnds_018$1];
   }
   function create(f, created_at){return [0, f, 0, created_at];}
   function really_run(t, node_update){
    var
     _o_ =
       typeof node_update === "number"
        ? 0 === node_update ? 3 : 4
        : 0 === node_update[0] ? 1 : 2;
    t[2] = _o_;
    return caml_call1(t[1], node_update);
   }
   function run(t, node_update, now){
    var
     _m_ = caml_call2(Incremental_Stabilization_num[1], t[3], now),
     _n_ = caml_call2(Core[92], _m_, 0);
    if(! _n_) return _n_;
    a:
    {
     b:
     {
      switch(t[2]){
        case 0:
         if(typeof node_update === "number") break a;
         if(1 === node_update[0]) break b;
         break a;
        case 1:
         if(typeof node_update === "number" || 0 !== node_update[0]) break a;
         break;
        case 2:
         if(typeof node_update === "number" || 0 !== node_update[0]) break a;
         break;
        case 3:
         return 0;
        default:
         if(typeof node_update !== "number"){
          if(1 === node_update[0]) break b;
          break a;
         }
         if(1 !== node_update) break a;
      }
      return 0;
     }
     var a = node_update[2];
     return really_run(t, [0, a]);
    }
    return really_run(t, node_update);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_On_update_hand);
   var
    Incremental_On_update_handler = [0, Node_update, sexp_of_t$0, create, run];
   runtime.caml_register_global
    (26, Incremental_On_update_handler, cst_Incremental_On_update_hand$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Raised_exn
//# unitInfo: Requires: Base__Backtrace, Base__Exn, Core, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Raised_exn$0 = "Incremental__Raised_exn",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Exn = global_data.Base__Exn,
    Base_Backtrace = global_data.Base__Backtrace,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Raised_exn$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/raised_exn.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "raised_exn.ml");
   var
    _a_ = [0, "backtrace"],
    _b_ = [0, "exn"],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Raised_exn = cst_Incremental_Raised_exn$0;
   function sexp_of_t(param){
    var
     backtrace_004 = param[2],
     exn_002 = param[1],
     arg_005 = caml_call1(Base_Backtrace[1], backtrace_004),
     bnds_001 = [0, [1, [0, _a_, [0, arg_005, 0]]], 0],
     arg_003 = caml_call1(Core[625], exn_002),
     bnds_001$0 = [0, [1, [0, _b_, [0, arg_003, 0]]], bnds_001];
    return [1, bnds_001$0];
   }
   function create(exn){return [0, exn, caml_call1(Base_Backtrace[6][4], 0)];}
   function reraise_with_message(param, msg){
    var backtrace = param[2], exn = param[1];
    return caml_call2(Base_Exn[7], [0, Base_Exn[4], msg, exn], backtrace);
   }
   function reraise(param){
    var backtrace = param[2], exn = param[1];
    return caml_call2(Base_Exn[7], exn, backtrace);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Raised_exn);
   var
    Incremental_Raised_exn =
      [0, sexp_of_t, create, reraise, reraise_with_message];
   runtime.caml_register_global
    (16, Incremental_Raised_exn, cst_Incremental_Raised_exn$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Types
//# unitInfo: Requires: CamlinternalMod, Core, Incremental__Import, Incremental__Node_id, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Types$0 = "Incremental__Types",
    cst = "_",
    cst_incremental$0 = "incremental",
    cst_src_types_ml = "src/types.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_Node_id = global_data.Incremental__Node_id,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    CamlinternalMod = global_data.CamlinternalMod;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Types$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_types_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "types.ml");
   var
    Adjust_heights_heap =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 22, 2], [0, [0]]),
    Alarm =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 27, 2], [0, [0]]),
    Alarm_value =
      caml_call2
       (CamlinternalMod[1], [0, cst_src_types_ml, 43, 2], [0, [0, [0, [0]]]]),
    Array_fold =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 52, 2], [0, [0]]),
    At =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 62, 2], [0, [0]]),
    At_intervals =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 73, 2], [0, [0]]),
    Bind =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 86, 2], [0, [0]]),
    Clock =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 96, 2], [0, [0]]),
    Expert =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 117, 2], [0, [0]]),
    Freeze =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 126, 2], [0, [0]]),
    If_then_else =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 138, 2], [0, [0]]),
    Internal_observer =
      caml_call2
       (CamlinternalMod[1],
        [0, cst_src_types_ml, 165, 2],
        [0, [0, [0, [0]], [0, [0]]]]),
    Join =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 175, 2], [0, [0]]),
    Kind =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 416, 2], [0, [0]]),
    Node =
      caml_call2
       (CamlinternalMod[1],
        [0, cst_src_types_ml, 459, 6],
        [0, [0, 0, [0, [0, 0]], 0, 0, 0]]),
    Observer =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 518, 2], [0, [0]]),
    Only_in_debug =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 526, 2], [0, [0]]),
    Packed_weak_hashtbl =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 531, 2], [0, [0]]),
    Recompute_heap =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 540, 2], [0, [0]]),
    Run_on_update_handlers =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 545, 2], [0, [0]]),
    Scope =
      caml_call2
       (CamlinternalMod[1], [0, cst_src_types_ml, 552, 6], [0, [0, 0]]),
    Snapshot =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 572, 2], [0, [0]]),
    State =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 605, 2], [0, [0]]),
    Status =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 614, 2], [0, [0]]),
    Step_function_node =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 628, 2], [0, [0]]),
    Unordered_array_fold =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 642, 2], [0, [0]]),
    Var =
      caml_call2
       (CamlinternalMod[1], [0, cst_src_types_ml, 658, 2], [0, [0, [0, [0]]]]);
   caml_call3
    (CamlinternalMod[2], [0, [0]], Adjust_heights_heap, Adjust_heights_heap);
   caml_call3(CamlinternalMod[2], [0, [0]], Alarm, Alarm);
   caml_call3
    (CamlinternalMod[2], [0, [0, [0, [0]]]], Alarm_value, Alarm_value);
   caml_call3(CamlinternalMod[2], [0, [0]], Array_fold, Array_fold);
   caml_call3(CamlinternalMod[2], [0, [0]], At, At);
   caml_call3(CamlinternalMod[2], [0, [0]], At_intervals, At_intervals);
   caml_call3(CamlinternalMod[2], [0, [0]], Bind, Bind);
   caml_call3(CamlinternalMod[2], [0, [0]], Clock, Clock);
   caml_call3(CamlinternalMod[2], [0, [0]], Expert, Expert);
   caml_call3(CamlinternalMod[2], [0, [0]], Freeze, Freeze);
   caml_call3(CamlinternalMod[2], [0, [0]], If_then_else, If_then_else);
   caml_call3
    (CamlinternalMod[2],
     [0, [0, [0, [0]], [0, [0]]]],
     Internal_observer,
     Internal_observer);
   caml_call3(CamlinternalMod[2], [0, [0]], Join, Join);
   caml_call3(CamlinternalMod[2], [0, [0]], Kind, Kind);
   var
    _h_ = [0, cst],
    cst_Top = "Top",
    _a_ = [0, cst],
    cst_n = "n",
    _b_ = [0, [0, 0, [0, [0, 0]], 0, 0, 0]],
    _c_ = [0, [0]],
    _d_ = [0, [0]],
    _e_ = [0, [0]],
    _f_ = [0, [0]],
    _g_ = [0, [0]],
    _i_ = [0, [0, 0]],
    _j_ = [0, [0]],
    _k_ = [0, [0]],
    _l_ = [0, [0]],
    _m_ = [0, [0]],
    _n_ = [0, [0]],
    _o_ = [0, [0, [0, [0]]]],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Types = cst_Incremental_Types$0;
   function sexp_of_node(param, t){
    var
     _w_ = [0, cst_n, [0, caml_call1(Incremental_Node_id[11], t[1]), 0]],
     _x_ = caml_call2(Incremental_Import[2], 0, _w_);
    return caml_call1(Core[558], _x_);
   }
   function sexp_of_t(x_003){
    return sexp_of_node(function(param){return _a_;}, x_003);
   }
   function is_valid(t){
    var _v_ = t[5];
    if(typeof _v_ === "number" && ! _v_) return 0;
    return 1;
   }
   function is_necessary(t){
    var _q_ = caml_call2(Core[91], t[9], 0);
    if(_q_)
     var _r_ = _q_;
    else{
     var _s_ = caml_call1(Incremental_Import[6][8], t[21]);
     if(_s_)
      var _r_ = _s_;
     else{
      var _t_ = t[5];
      a:
      {
       if(typeof _t_ !== "number" && 7 === _t_[0]){var _u_ = 1; break a;}
       var _u_ = 0;
      }
      var _r_ = _u_ || t[26];
     }
    }
    return _r_;
   }
   function type_equal_if_phys_same(t1, t2){return t1 === t2 ? [0, 0] : 0;}
   caml_call3
    (CamlinternalMod[2],
     _b_,
     Node,
     [0,
      sexp_of_node,
      [0, sexp_of_t],
      is_valid,
      is_necessary,
      type_equal_if_phys_same]);
   caml_call3(CamlinternalMod[2], _c_, Observer, Observer);
   caml_call3(CamlinternalMod[2], _d_, Only_in_debug, Only_in_debug);
   caml_call3
    (CamlinternalMod[2], _e_, Packed_weak_hashtbl, Packed_weak_hashtbl);
   caml_call3(CamlinternalMod[2], _f_, Recompute_heap, Recompute_heap);
   caml_call3
    (CamlinternalMod[2], _g_, Run_on_update_handlers, Run_on_update_handlers);
   function sexp_of_t$0(param){
    if(! param) return caml_call1(Core[558], cst_Top);
    var bind = param[1], x_004 = bind[1];
    function _p_(param){return _h_;}
    return caml_call2(Node[1], _p_, x_004);
   }
   caml_call3(CamlinternalMod[2], _i_, Scope, [0, sexp_of_t$0]);
   caml_call3(CamlinternalMod[2], _j_, Snapshot, Snapshot);
   caml_call3(CamlinternalMod[2], _k_, State, State);
   caml_call3(CamlinternalMod[2], _l_, Status, Status);
   caml_call3(CamlinternalMod[2], _m_, Step_function_node, Step_function_node);
   caml_call3
    (CamlinternalMod[2], _n_, Unordered_array_fold, Unordered_array_fold);
   caml_call3(CamlinternalMod[2], _o_, Var, Var);
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Types);
   var
    Incremental_Types =
      [0,
       Adjust_heights_heap,
       Alarm,
       Alarm_value,
       Array_fold,
       At,
       At_intervals,
       Bind,
       Clock,
       Expert,
       Freeze,
       If_then_else,
       Internal_observer,
       Join,
       Kind,
       Node,
       Observer,
       Only_in_debug,
       Packed_weak_hashtbl,
       Recompute_heap,
       Run_on_update_handlers,
       Scope,
       Snapshot,
       State,
       Status,
       Step_function_node,
       Unordered_array_fold,
       Var];
   runtime.caml_register_global
    (100, Incremental_Types, cst_Incremental_Types$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Var
//# unitInfo: Requires: Base__Invariant, Incremental__Import, Incremental__Stabilization_num, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Var$0 = "Incremental__Var",
    cst = "_",
    cst_incremental$0 = "incremental",
    cst_set_at$0 = "set_at",
    cst_src_var_ml = "src/var.ml",
    cst_value$0 = "value",
    cst_value_set_during_stabiliza$0 = "value_set_during_stabilization",
    cst_watch$0 = "watch",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Incremental_Import = global_data.Incremental__Import,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Stabilization_num = global_data.Incremental__Stabilization_num,
    Incremental_Types = global_data.Incremental__Types,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Var$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_var_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "var.ml");
   var
    _q_ = [0, cst],
    _r_ = [0, "T"],
    _o_ = [0, cst],
    _n_ = [0, cst_src_var_ml, 32, 23],
    _m_ = [0, cst_src_var_ml, 33, 18],
    _p_ = [0, cst_src_var_ml, 22, 929, 951],
    _i_ = [0, cst_watch$0],
    _j_ = [0, cst_set_at$0],
    _k_ = [0, cst_value_set_during_stabiliza$0],
    _l_ = [0, cst_value$0],
    cst_watch = cst_watch$0,
    cst_set_at = cst_set_at$0,
    cst_value_set_during_stabiliza = cst_value_set_during_stabiliza$0,
    cst_value = cst_value$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Var = cst_Incremental_Var$0;
   function watch(r){return r[4];}
   function set_at(r){return r[3];}
   function set_set_at(r, v){r[3] = v; return 0;}
   function value_set_during_stabilization(r){return r[2];}
   function set_value_set_during_stabiliza(r, v){r[2] = v; return 0;}
   function value(r){return r[1];}
   function set_value(r, v){r[1] = v; return 0;}
   function _a_(r, v){return [0, r[1], r[2], r[3], v];}
   var
    _b_ = 0,
    watch$0 = [0, function(param){return 0;}, cst_watch, _b_, watch, _a_];
   function _c_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _d_ = [0, set_set_at],
    set_at$0 = [0, function(param){return 0;}, cst_set_at, _d_, set_at, _c_];
   function _e_(r, v){return [0, r[1], v, r[3], r[4]];}
   var
    _f_ = [0, set_value_set_during_stabiliza],
    value_set_during_stabilization$0 =
      [0,
       function(param){return 0;},
       cst_value_set_during_stabiliza,
       _f_,
       value_set_during_stabilization,
       _e_];
   function _g_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _h_ = [0, set_value],
    value$0 = [0, function(param){return 0;}, cst_value, _h_, value, _g_];
   function sexp_of_var(of_a_001, param){
    var
     value_003 = param[1],
     value_set_during_stabilization = param[2],
     set_at_007 = param[3],
     watch_009 = param[4],
     arg_010 = caml_call2(Incremental_Types[15][1], of_a_001, watch_009),
     bnds_002 = [0, [1, [0, _i_, [0, arg_010, 0]]], 0],
     arg_008 = caml_call1(Incremental_Stabilization_num[2], set_at_007),
     bnds_002$0 = [0, [1, [0, _j_, [0, arg_008, 0]]], bnds_002],
     arg_006 =
       caml_call2
        (Incremental_Import[6][2], of_a_001, value_set_during_stabilization),
     bnds_002$1 = [0, [1, [0, _k_, [0, arg_006, 0]]], bnds_002$0],
     arg_004 = caml_call1(of_a_001, value_003),
     bnds_002$2 = [0, [1, [0, _l_, [0, arg_004, 0]]], bnds_002$1];
    return [1, bnds_002$2];
   }
   function invariant(invariant_a, t){
    function _s_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      watch_fun =
        check
         (function(watch){
           var match = watch[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(16 === match[0]){
            var t$0 = match[1];
            if(t === t$0) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
          }),
      set_at_fun = check(Incremental_Stabilization_num[4]),
      value_set_during_stabilization =
        check(caml_call1(Incremental_Import[6][4], invariant_a)),
      value_fun = check(invariant_a);
     caml_call1(value_fun, value$0);
     caml_call1
      (value_set_during_stabilization, value_set_during_stabilization$0);
     caml_call1(set_at_fun, set_at$0);
     return caml_call1(watch_fun, watch$0);
    }
    function _t_(x_011){
     return sexp_of_var(function(param){return _o_;}, x_011);
    }
    return caml_call4(Base_Invariant[1], _p_, t, _t_, _s_);
   }
   function incr_state(t){return t[4][2];}
   function sexp_of_t(param){
    var res0_015 = sexp_of_var(function(param){return _q_;}, param);
    return [1, [0, _r_, [0, res0_015, 0]]];
   }
   function latest_value(t){
    return caml_call1(Incremental_Import[6][8], t[2])
            ? caml_call1(Incremental_Import[6][16], t[2])
            : t[1];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Var);
   var
    Incremental_Var =
      [0, invariant, sexp_of_var, [0, sexp_of_t], latest_value, incr_state];
   runtime.caml_register_global(30, Incremental_Var, cst_Incremental_Var$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Unordered_array_fold
//# unitInfo: Requires: Base__Invariant, Core, Incremental__Import, Incremental__Types, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Unordered_arra$0 = "Incremental__Unordered_array_fold",
    cst = "_",
    cst_children$0 = "children",
    cst_fold_value$0 = "fold_value",
    cst_full_compute_every_n_chang$0 = "full_compute_every_n_changes",
    cst_incremental$0 = "incremental",
    cst_init$0 = "init",
    cst_main$0 = "main",
    cst_num_changes_since_last_ful$0 = "num_changes_since_last_full_compute",
    cst_src_unordered_array_fold_m = "src/unordered_array_fold.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/unordered_array_fold.ml:56:26",
    Incremental_Types = global_data.Incremental__Types,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_Import = global_data.Incremental__Import,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Unordered_arra$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_unordered_array_fold_m);
   caml_call2
    (Ppx_inline_test_lib[6], cst_incremental$0, "unordered_array_fold.ml");
   var
    _J_ = [0, cst],
    _I_ = [0, cst],
    _F_ = [0, cst],
    _G_ = [0, "child"],
    _H_ = [0, "child_index"],
    _K_ = [0, "unordered_array_fold"],
    cst_Unordered_array_fold_child =
      "[Unordered_array_fold.child_changed] mismatch",
    _D_ = [0, cst],
    _C_ = [0, cst],
    _B_ = [0, cst_src_unordered_array_fold_m, 42, 40],
    _A_ = [0, cst_src_unordered_array_fold_m, 43, 18],
    _z_ = [0, cst_src_unordered_array_fold_m, 66, 11],
    _y_ = [0, cst_src_unordered_array_fold_m, 52, 18],
    _x_ = [0, cst_src_unordered_array_fold_m, 62, 11],
    _w_ = [0, cst_src_unordered_array_fold_m, 63, 11],
    _E_ = [0, cst_src_unordered_array_fold_m, 35, 924, 946],
    _o_ = [0, cst_num_changes_since_last_ful$0],
    _p_ = [0, cst_fold_value$0],
    _q_ = [0, cst_children$0],
    _r_ = [0, cst_full_compute_every_n_chang$0],
    _s_ = [0, "update"],
    _t_ = [0, "f"],
    _u_ = [0, cst_init$0],
    _v_ = [0, cst_main$0],
    _a_ = [0, "F_inverse"],
    _b_ = [0, "Update"],
    cst_num_changes_since_last_ful = cst_num_changes_since_last_ful$0,
    cst_fold_value = cst_fold_value$0,
    cst_children = cst_children$0,
    cst_full_compute_every_n_chang = cst_full_compute_every_n_chang$0,
    cst_init = cst_init$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Unordered_arra = cst_Incremental_Unordered_arra$0;
   function sexp_of_t(of_a_001, of_b_002, param){
    if(0 === param[0]){
     var
      _am_ = function(_ap_){return 0;},
      res0_004 = caml_call1(Sexplib0_Sexp_conv[24], _am_);
     return [1, [0, _a_, [0, res0_004, 0]]];
    }
    function _an_(_ao_){return 0;}
    var res0_006 = caml_call1(Sexplib0_Sexp_conv[24], _an_);
    return [1, [0, _b_, [0, res0_006, 0]]];
   }
   function num_changes_since_last_full_co(r){return r[8];}
   function set_num_changes_since_last_ful(r, v){r[8] = v; return 0;}
   function fold_value(r){return r[7];}
   function set_fold_value(r, v){r[7] = v; return 0;}
   function children(r){return r[6];}
   function full_compute_every_n_changes(r){return r[5];}
   function init(r){return r[2];}
   function main(r){return r[1];}
   function _c_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v];
   }
   var
    _d_ = [0, set_num_changes_since_last_ful],
    num_changes_since_last_full_co$0 =
      [0,
       function(param){return 0;},
       cst_num_changes_since_last_ful,
       _d_,
       num_changes_since_last_full_co,
       _c_];
   function _e_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
   }
   var
    _f_ = [0, set_fold_value],
    fold_value$0 =
      [0, function(param){return 0;}, cst_fold_value, _f_, fold_value, _e_];
   function _g_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
   }
   var
    _h_ = 0,
    children$0 =
      [0, function(param){return 0;}, cst_children, _h_, children, _g_];
   function _i_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8]];
   }
   var
    _j_ = 0,
    full_compute_every_n_changes$0 =
      [0,
       function(param){return 0;},
       cst_full_compute_every_n_chang,
       _j_,
       full_compute_every_n_changes,
       _i_];
   function _k_(r, v){
    return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _l_ = 0,
    init$0 = [0, function(param){return 0;}, cst_init, _l_, init, _k_];
   function _m_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _n_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _n_, main, _m_];
   function sexp_of_t$0(of_a_009, of_acc_010, param){
    var
     children_022 = param[6],
     full_compute_every_n_changes_0 = param[5],
     init_014 = param[2],
     main_012 = param[1],
     fold_value_024 = param[7],
     num_changes_since_last_full_co = param[8],
     arg_027 = caml_call1(Core[389], num_changes_since_last_full_co),
     bnds_011 = [0, [1, [0, _o_, [0, arg_027, 0]]], 0],
     arg_025 =
       caml_call2(Incremental_Import[6][2], of_acc_010, fold_value_024),
     bnds_011$0 = [0, [1, [0, _p_, [0, arg_025, 0]]], bnds_011],
     _ah_ = caml_call1(Incremental_Types[15][1], of_a_009),
     arg_023 = caml_call2(Core[301], _ah_, children_022),
     bnds_011$1 = [0, [1, [0, _q_, [0, arg_023, 0]]], bnds_011$0],
     arg_021 = caml_call1(Core[389], full_compute_every_n_changes_0),
     bnds_011$2 = [0, [1, [0, _r_, [0, arg_021, 0]]], bnds_011$1];
    function _ai_(_al_){return 0;}
    var
     arg_019 = caml_call1(Sexplib0_Sexp_conv[24], _ai_),
     bnds_011$3 = [0, [1, [0, _s_, [0, arg_019, 0]]], bnds_011$2];
    function _aj_(_ak_){return 0;}
    var
     arg_017 = caml_call1(Sexplib0_Sexp_conv[24], _aj_),
     bnds_011$4 = [0, [1, [0, _t_, [0, arg_017, 0]]], bnds_011$3],
     arg_015 = caml_call1(of_acc_010, init_014),
     bnds_011$5 = [0, [1, [0, _u_, [0, arg_015, 0]]], bnds_011$4],
     arg_013 = caml_call2(Incremental_Types[15][1], of_acc_010, main_012),
     bnds_011$6 = [0, [1, [0, _v_, [0, arg_013, 0]]], bnds_011$5];
    return [1, bnds_011$6];
   }
   function invariant(invariant_a, invariant_acc, t){
    function _ac_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      num_changes_since_last_full_co =
        check
         (function(num_changes_since_last_full_co){
           if(! caml_call2(Core[88], num_changes_since_last_full_co, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
           if(caml_call2(Core[89], num_changes_since_last_full_co, t[5]))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
          }),
      fold_value_fun =
        check
         (function(fold_value){
           caml_call2(Incremental_Import[6][4], invariant_acc, fold_value);
           var
            got = caml_call1(Incremental_Import[6][8], fold_value),
            expect = caml_call2(Core[92], t[8], t[5]),
            sexpifier = Core[323],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_029, b_030){
            return caml_call2(Core[316], a_029, b_030);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    got);
          }),
      children_fun =
        check
         (function(children){
           function _af_(child){
            caml_call2(Incremental_Import[6][4], invariant_a, child[4]);
            var _ag_ = caml_call2(Core[92], t[8], t[5]);
            if(! _ag_) return _ag_;
            if(caml_call1(Incremental_Import[6][8], child[4])) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
           }
           return caml_call2(Incremental_Import[5][35], children, _af_);
          }),
      full_compute_every_n_changes_f =
        check
         (function(full_compute_every_n_changes){
           if(caml_call2(Core[91], full_compute_every_n_changes, 0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
          }),
      init_fun = check(invariant_acc),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(15 === match[0]){
            var t$0 = match[1];
            if(t === t$0) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(init_fun, init$0);
     caml_call1
      (full_compute_every_n_changes_f, full_compute_every_n_changes$0);
     caml_call1(children_fun, children$0);
     caml_call1(fold_value_fun, fold_value$0);
     return caml_call1
             (num_changes_since_last_full_co,
              num_changes_since_last_full_co$0);
    }
    function _ad_(x_028){
     function _ae_(param){return _C_;}
     return sexp_of_t$0(function(param){return _D_;}, _ae_, x_028);
    }
    return caml_call4(Base_Invariant[1], _E_, t, _ad_, _ac_);
   }
   function create
   (init, f, update$0, full_compute_every_n_changes, children, main){
    var _aa_ = Incremental_Import[6][5];
    if(0 === update$0[0])
     var
      f_inverse = update$0[1],
      _ab_ =
        function(fold_value, old_value, new_value){
         return caml_call2
                 (f, caml_call2(f_inverse, fold_value, old_value), new_value);
        };
    else
     var update = update$0[1], _ab_ = update;
    return [0,
            main,
            init,
            f,
            _ab_,
            full_compute_every_n_changes,
            children,
            _aa_,
            full_compute_every_n_changes];
   }
   function compute(t){
    if(caml_call2(Core[90], t[8], t[5])){
     t[8] = 0;
     var
      children = t[6],
      f = t[3],
      init = t[2],
      result = [0, init],
      _Z_ = children.length - 1 - 1 | 0,
      _Y_ = 0;
     if(_Z_ >= 0){
      var i = _Y_;
      for(;;){
       var ___ = caml_call1(Incremental_Import[6][9], children[1 + i][4]);
       result[1] = caml_call2(f, result[1], ___);
       var _$_ = i + 1 | 0;
       if(_Z_ === i) break;
       var i = _$_;
      }
     }
     t[7] = caml_call1(Incremental_Import[6][6], result[1]);
    }
    return caml_call1(Incremental_Import[6][9], t[7]);
   }
   function force_full_compute(t){
    t[7] = Incremental_Import[6][5];
    t[8] = t[5];
    return 0;
   }
   function child_changed(x_031, child, child_index, old_value_opt, new_value){
    var
     child_at_index =
       runtime.caml_check_bound(x_031[6], child_index)[1 + child_index];
    if(! caml_call2(Incremental_Types[15][5], child, child_at_index)){
     var
      _P_ = 0,
      _Q_ = 0,
      _R_ = function(param){return _F_;},
      _S_ =
        [0,
         [1,
          [0, _G_, [0, caml_call2(Incremental_Types[15][1], _R_, child), _Q_]]],
         _P_],
      _T_ =
        [0, [1, [0, _H_, [0, caml_call1(Core[389], child_index), 0]]], _S_],
      _U_ = 0,
      _V_ = function(param){return _I_;},
      _W_ =
        [0,
         [1,
          [0,
           _K_,
           [0, sexp_of_t$0(function(param){return _J_;}, _V_, x_031), _U_]]],
         _T_],
      _X_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Unordered_array_fold_child),
          _W_]];
     return caml_call1(Core[261], _X_);
    }
    if(caml_call2(Core[92], x_031[8], x_031[5] - 1 | 0)){
     x_031[8] = x_031[8] + 1 | 0;
     var
      _L_ = caml_call1(Incremental_Import[6][9], old_value_opt),
      _M_ = caml_call1(Incremental_Import[6][9], x_031[7]),
      _N_ = caml_call3(x_031[4], _M_, _L_, new_value);
     x_031[7] = caml_call1(Incremental_Import[6][6], _N_);
     return 0;
    }
    var _O_ = caml_call2(Core[92], x_031[8], x_031[5]);
    return _O_ ? force_full_compute(x_031) : _O_;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Unordered_arra);
   var
    Incremental_Unordered_array_fo =
      [0,
       invariant,
       sexp_of_t$0,
       [0, sexp_of_t],
       create,
       compute,
       child_changed,
       force_full_compute];
   runtime.caml_register_global
    (53, Incremental_Unordered_array_fo, cst_Incremental_Unordered_arra$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Alarm
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Alarm$0 = "Incremental__Alarm",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Timing_wheel = global_data.Timing_wheel,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Alarm$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/alarm.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "alarm.ml");
   var
    cst_incremental = cst_incremental$0,
    cst_Incremental_Alarm = cst_Incremental_Alarm$0;
   function sexp_of_t(x_001){
    return caml_call2(Timing_wheel[5][1], Sexplib0_Sexp_conv[23], x_001);
   }
   function invariant(param){return 0;}
   var null$0 = caml_call1(Timing_wheel[5][2], 0);
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Alarm);
   var Incremental_Alarm = [0, sexp_of_t, invariant, null$0];
   runtime.caml_register_global
    (13, Incremental_Alarm, cst_Incremental_Alarm$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Step_function_node
//# unitInfo: Requires: Base__Invariant, Core__Sequence, Incremental__Alarm, Incremental__Import, Incremental__Stabilization_num, Incremental__Types, Incremental_step_function, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Step_function_$0 = "Incremental__Step_function_node",
    cst_alarm$0 = "alarm",
    cst_alarm_value$0 = "alarm_value",
    cst_incremental$0 = "incremental",
    cst_main$0 = "main",
    cst_src_step_function_node_ml = "src/step_function_node.ml",
    cst_value$0 = "value",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Sequence = global_data.Core__Sequence,
    Incremental_Import = global_data.Incremental__Import,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Alarm = global_data.Incremental__Alarm,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_Stabilization_num = global_data.Incremental__Stabilization_num,
    Incremental_step_function = global_data.Incremental_step_function,
    Incremental_Types = global_data.Incremental__Types,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Step_function_$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_step_function_node_ml);
   caml_call2
    (Ppx_inline_test_lib[6], cst_incremental$0, "step_function_node.ml");
   var
    _u_ = [0, "_"],
    _t_ = [0, cst_src_step_function_node_ml, 30, 33],
    _s_ = [0, cst_src_step_function_node_ml, 31, 18],
    _q_ = [0, cst_src_step_function_node_ml, 41, 18],
    _r_ = [0, cst_src_step_function_node_ml, 40, 33],
    _v_ = [0, cst_src_step_function_node_ml, 22, 642, 664],
    _i_ = [0, "clock"],
    _j_ = [0, cst_alarm_value$0],
    _k_ = [0, cst_alarm$0],
    _l_ = [0, "upcoming_steps"],
    _m_ = [0, cst_value$0],
    _n_ = [0, "extracted_step_function_from_child_at"],
    _o_ = [0, "child"],
    _p_ = [0, cst_main$0],
    cst_alarm_value = cst_alarm_value$0,
    cst_alarm = cst_alarm$0,
    cst_value = cst_value$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Step_function_ = cst_Incremental_Step_function_$0;
   function alarm_value(r){return r[7];}
   function set_alarm_value(r, v){r[7] = v; return 0;}
   function alarm(r){return r[6];}
   function set_alarm(r, v){r[6] = v; return 0;}
   function value(r){return r[4];}
   function set_value(r, v){r[4] = v; return 0;}
   function main(r){return r[1];}
   function _a_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
   }
   var
    _b_ = [0, set_alarm_value],
    alarm_value$0 =
      [0, function(param){return 0;}, cst_alarm_value, _b_, alarm_value, _a_];
   function _c_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
   }
   var
    _d_ = [0, set_alarm],
    alarm$0 = [0, function(param){return 0;}, cst_alarm, _d_, alarm, _c_];
   function _e_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8]];
   }
   var
    _f_ = [0, set_value],
    value$0 = [0, function(param){return 0;}, cst_value, _f_, value, _e_];
   function _g_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _h_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _h_, main, _g_];
   function sexp_of_t(of_a_001, param){
    var
     main_003 = param[1],
     child_005 = param[2],
     extracted_step_function_from_c = param[3],
     value_009 = param[4],
     upcoming_steps_011 = param[5],
     alarm_017 = param[6],
     alarm_value_019 = param[7],
     clock_021 = param[8],
     arg_022 = caml_call1(Sexplib0_Sexp_conv[23], clock_021),
     bnds_002 = [0, [1, [0, _i_, [0, arg_022, 0]]], 0],
     arg_020 = caml_call1(Sexplib0_Sexp_conv[23], alarm_value_019),
     bnds_002$0 = [0, [1, [0, _j_, [0, arg_020, 0]]], bnds_002],
     arg_018 = caml_call1(Incremental_Alarm[1], alarm_017),
     bnds_002$1 = [0, [1, [0, _k_, [0, arg_018, 0]]], bnds_002$0];
    function _z_(param){
     var
      arg1_014 = param[2],
      arg0_013 = param[1],
      res0_015 = caml_call1(Incremental_Import[4][126], arg0_013),
      res1_016 = caml_call1(of_a_001, arg1_014);
     return [1, [0, res0_015, [0, res1_016, 0]]];
    }
    var
     arg_012 = caml_call2(Core_Sequence[12], _z_, upcoming_steps_011),
     bnds_002$2 = [0, [1, [0, _l_, [0, arg_012, 0]]], bnds_002$1],
     arg_010 = caml_call2(Incremental_Import[6][2], of_a_001, value_009),
     bnds_002$3 = [0, [1, [0, _m_, [0, arg_010, 0]]], bnds_002$2],
     arg_008 =
       caml_call1
        (Incremental_Stabilization_num[2], extracted_step_function_from_c),
     bnds_002$4 = [0, [1, [0, _n_, [0, arg_008, 0]]], bnds_002$3],
     _A_ = caml_call1(Incremental_step_function[1], of_a_001),
     _B_ = caml_call1(Incremental_Types[15][1], _A_),
     arg_006 = caml_call2(Incremental_Import[6][2], _B_, child_005),
     bnds_002$5 = [0, [1, [0, _o_, [0, arg_006, 0]]], bnds_002$4],
     arg_004 = caml_call2(Incremental_Types[15][1], of_a_001, main_003),
     bnds_002$6 = [0, [1, [0, _p_, [0, arg_004, 0]]], bnds_002$5];
    return [1, bnds_002$6];
   }
   function invariant(invariant_a, t){
    function _x_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      alarm_value_fun =
        check
         (function(alarm_value){
           var match = alarm_value[1];
           if(3 !== match[0])
            throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
           var t2 = match[1];
           if(t === t2) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
          }),
      alarm_fun = check(Incremental_Alarm[2]),
      value_fun = check(caml_call1(Incremental_Import[6][4], invariant_a)),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else
            switch(match[0]){
              case 5:
               return 0;
              case 14:
               var t$0 = match[1];
               if(t === t$0) return 0;
               throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
            }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(value_fun, value$0);
     caml_call1(alarm_fun, alarm$0);
     caml_call1(alarm_value_fun, alarm_value$0);
     return 0;
    }
    function _y_(x_023){
     return sexp_of_t(function(param){return _u_;}, x_023);
    }
    return caml_call4(Base_Invariant[1], _v_, t, _y_, _x_);
   }
   function advance(t, to){
    var
     steps$0 = t[5],
     a1$0 = caml_call1(Incremental_Import[6][9], t[4]),
     a1 = a1$0,
     steps = steps$0;
    for(;;){
     var match = caml_call1(Core_Sequence[50], steps);
     if(match){
      var
       _w_ = match[1],
       steps2 = _w_[2],
       match$0 = _w_[1],
       a2 = match$0[2],
       step_at = match$0[1];
      if(caml_call2(Incremental_Import[4][15], to, step_at)){var a1 = a2, steps = steps2; continue;}
     }
     t[4] = caml_call1(Incremental_Import[6][6], a1);
     t[5] = steps;
     return 0;
    }
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Step_function_);
   var Incremental_Step_function_node = [0, invariant, sexp_of_t, advance];
   runtime.caml_register_global
    (42, Incremental_Step_function_node, cst_Incremental_Step_function_$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Array_fold
//# unitInfo: Requires: Base__Invariant, Core, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Array_fold$0 = "Incremental__Array_fold",
    cst = "_",
    cst_children$0 = "children",
    cst_incremental$0 = "incremental",
    cst_init$0 = "init",
    cst_src_array_fold_ml = "src/array_fold.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Incremental_Import = global_data.Incremental__Import,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Types = global_data.Incremental__Types,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Array_fold$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_array_fold_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "array_fold.ml");
   var
    _i_ = [0, cst],
    _h_ = [0, cst],
    _j_ = [0, cst_src_array_fold_ml, 13, 269, 291],
    _e_ = [0, cst_children$0],
    _f_ = [0, "f"],
    _g_ = [0, cst_init$0],
    cst_children = cst_children$0,
    cst_init = cst_init$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Array_fold = cst_Incremental_Array_fold$0;
   function children(r){return r[3];}
   function init(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], v];}
   var
    _b_ = 0,
    children$0 =
      [0, function(param){return 0;}, cst_children, _b_, children, _a_];
   function _c_(r, v){return [0, v, r[2], r[3]];}
   var
    _d_ = 0,
    init$0 = [0, function(param){return 0;}, cst_init, _d_, init, _c_];
   function sexp_of_t(of_a_001, of_acc_002, param){
    var
     children_008 = param[3],
     init_004 = param[1],
     _s_ = caml_call1(Incremental_Types[15][1], of_a_001),
     arg_009 = caml_call2(Core[301], _s_, children_008),
     bnds_003 = [0, [1, [0, _e_, [0, arg_009, 0]]], 0];
    function _t_(_u_){return 0;}
    var
     arg_007 = caml_call1(Sexplib0_Sexp_conv[24], _t_),
     bnds_003$0 = [0, [1, [0, _f_, [0, arg_007, 0]]], bnds_003],
     arg_005 = caml_call1(of_acc_002, init_004),
     bnds_003$1 = [0, [1, [0, _g_, [0, arg_005, 0]]], bnds_003$0];
    return [1, bnds_003$1];
   }
   function invariant(invariant_a, invariant_acc, t){
    function _o_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      children_fun =
        check
         (function(children){
           function _r_(child){
            return caml_call2(Incremental_Import[6][4], invariant_a, child[4]);
           }
           return caml_call2(Incremental_Import[5][35], children, _r_);
          }),
      init_fun = check(invariant_acc);
     caml_call1(init_fun, init$0);
     return caml_call1(children_fun, children$0);
    }
    function _p_(x_010){
     function _q_(param){return _h_;}
     return sexp_of_t(function(param){return _i_;}, _q_, x_010);
    }
    return caml_call4(Base_Invariant[1], _j_, t, _p_, _o_);
   }
   function compute(param){
    var
     children = param[3],
     f = param[2],
     init = param[1],
     result = [0, init],
     _l_ = children.length - 1 - 1 | 0,
     _k_ = 0;
    if(_l_ >= 0){
     var i = _k_;
     for(;;){
      var _m_ = caml_call1(Incremental_Import[6][9], children[1 + i][4]);
      result[1] = caml_call2(f, result[1], _m_);
      var _n_ = i + 1 | 0;
      if(_l_ === i) break;
      var i = _n_;
     }
    }
    return result[1];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Array_fold);
   var Incremental_Array_fold = [0, sexp_of_t, invariant, compute];
   runtime.caml_register_global
    (25, Incremental_Array_fold, cst_Incremental_Array_fold$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__At
//# unitInfo: Requires: Base__Invariant, Incremental__Alarm, Incremental__Before_or_after, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_At$0 = "Incremental__At",
    cst_alarm$0 = "alarm",
    cst_incremental$0 = "incremental",
    cst_main$0 = "main",
    cst_src_at_ml = "src/at.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Alarm = global_data.Incremental__Alarm,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_Before_or_after = global_data.Incremental__Before_or_after,
    Incremental_Types = global_data.Incremental__Types,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_At$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_at_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "at.ml");
   var
    _j_ = [0, cst_src_at_ml, 23, 22],
    _i_ = [0, cst_src_at_ml, 24, 18],
    _k_ = [0, cst_src_at_ml, 15, 280, 302],
    _e_ = [0, "clock"],
    _f_ = [0, cst_alarm$0],
    _g_ = [0, "at"],
    _h_ = [0, cst_main$0],
    cst_alarm = cst_alarm$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_At = cst_Incremental_At$0;
   function alarm(r){return r[3];}
   function set_alarm(r, v){r[3] = v; return 0;}
   function main(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _b_ = [0, set_alarm],
    alarm$0 = [0, function(param){return 0;}, cst_alarm, _b_, alarm, _a_];
   function _c_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _d_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _d_, main, _c_];
   function sexp_of_t(param){
    var
     at_004 = param[2],
     main_002 = param[1],
     alarm_006 = param[3],
     clock_008 = param[4],
     arg_009 = caml_call1(Sexplib0_Sexp_conv[23], clock_008),
     bnds_001 = [0, [1, [0, _e_, [0, arg_009, 0]]], 0],
     arg_007 = caml_call1(Incremental_Alarm[1], alarm_006),
     bnds_001$0 = [0, [1, [0, _f_, [0, arg_007, 0]]], bnds_001],
     arg_005 = caml_call1(Incremental_Import[4][126], at_004),
     bnds_001$1 = [0, [1, [0, _g_, [0, arg_005, 0]]], bnds_001$0],
     arg_003 =
       caml_call2
        (Incremental_Types[15][1], Incremental_Before_or_after[1], main_002),
     bnds_001$2 = [0, [1, [0, _h_, [0, arg_003, 0]]], bnds_001$1];
    return [1, bnds_001$2];
   }
   function invariant(t){
    function _l_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      alarm_fun = check(Incremental_Alarm[2]),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else
            switch(match[0]){
              case 1:
               var t$0 = match[1];
               if(t === t$0) return 0;
               throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
              case 5:
               if(match[1]) return 0; break;
            }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(alarm_fun, alarm$0);
     return 0;
    }
    return caml_call4(Base_Invariant[1], _k_, t, sexp_of_t, _l_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_At);
   var Incremental_At = [0, invariant, sexp_of_t];
   runtime.caml_register_global(29, Incremental_At, cst_Incremental_At$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__At_intervals
//# unitInfo: Requires: Base__Invariant, Core, Incremental__Alarm, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_At_intervals$0 = "Incremental__At_intervals",
    cst_alarm$0 = "alarm",
    cst_incremental$0 = "incremental",
    cst_interval$0 = "interval",
    cst_main$0 = "main",
    cst_src_at_intervals_ml = "src/at_intervals.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Incremental_Import = global_data.Incremental__Import,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Alarm = global_data.Incremental__Alarm,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Incremental_Types = global_data.Incremental__Types,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_At_intervals$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_at_intervals_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "at_intervals.ml");
   var
    _n_ = [0, cst_src_at_intervals_ml, 23, 32],
    _m_ = [0, cst_src_at_intervals_ml, 24, 18],
    _l_ = [0, cst_src_at_intervals_ml, 26, 40],
    _o_ = [0, cst_src_at_intervals_ml, 16, 309, 331],
    _g_ = [0, "clock"],
    _h_ = [0, cst_alarm$0],
    _i_ = [0, cst_interval$0],
    _j_ = [0, "base"],
    _k_ = [0, cst_main$0],
    cst_alarm = cst_alarm$0,
    cst_interval = cst_interval$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_At_intervals = cst_Incremental_At_intervals$0;
   function alarm(r){return r[4];}
   function set_alarm(r, v){r[4] = v; return 0;}
   function interval(r){return r[3];}
   function main(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], r[3], v, r[5]];}
   var
    _b_ = [0, set_alarm],
    alarm$0 = [0, function(param){return 0;}, cst_alarm, _b_, alarm, _a_];
   function _c_(r, v){return [0, r[1], r[2], v, r[4], r[5]];}
   var
    _d_ = 0,
    interval$0 =
      [0, function(param){return 0;}, cst_interval, _d_, interval, _c_];
   function _e_(r, v){return [0, v, r[2], r[3], r[4], r[5]];}
   var
    _f_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _f_, main, _e_];
   function sexp_of_t(param){
    var
     interval_006 = param[3],
     base_004 = param[2],
     main_002 = param[1],
     alarm_008 = param[4],
     clock_010 = param[5],
     arg_011 = caml_call1(Sexplib0_Sexp_conv[23], clock_010),
     bnds_001 = [0, [1, [0, _g_, [0, arg_011, 0]]], 0],
     arg_009 = caml_call1(Incremental_Alarm[1], alarm_008),
     bnds_001$0 = [0, [1, [0, _h_, [0, arg_009, 0]]], bnds_001],
     arg_007 = caml_call1(Incremental_Import[4][1][10], interval_006),
     bnds_001$1 = [0, [1, [0, _i_, [0, arg_007, 0]]], bnds_001$0],
     arg_005 = caml_call1(Incremental_Import[4][126], base_004),
     bnds_001$2 = [0, [1, [0, _j_, [0, arg_005, 0]]], bnds_001$1],
     arg_003 = caml_call2(Incremental_Types[15][1], Core[620], main_002),
     bnds_001$3 = [0, [1, [0, _k_, [0, arg_003, 0]]], bnds_001$2];
    return [1, bnds_001$3];
   }
   function invariant(t){
    function _p_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      alarm_fun = check(Incremental_Alarm[2]),
      interval_fun =
        check
         (function(interval){
           if(caml_call1(Incremental_Import[4][1][34], interval)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
          }),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(2 === match[0]){
            var t$0 = match[1];
            if(t === t$0) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(interval_fun, interval$0);
     caml_call1(alarm_fun, alarm$0);
     return 0;
    }
    return caml_call4(Base_Invariant[1], _o_, t, sexp_of_t, _p_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_At_intervals);
   var Incremental_At_intervals = [0, invariant, sexp_of_t];
   runtime.caml_register_global
    (32, Incremental_At_intervals, cst_Incremental_At_intervals$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Bind
//# unitInfo: Requires: Base__Invariant, Core, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Bind$0 = "Incremental__Bind",
    cst = "_",
    cst_all_nodes_created_on_rhs$0 = "all_nodes_created_on_rhs",
    cst_incremental$0 = "incremental",
    cst_lhs_change$0 = "lhs_change",
    cst_main$0 = "main",
    cst_rhs_scope$0 = "rhs_scope",
    cst_src_bind_ml = "src/bind.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Incremental_Types = global_data.Incremental__Types,
    Core = global_data.Core,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Import = global_data.Incremental__Import,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Bind$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_bind_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "bind.ml");
   var
    _z_ = [0, cst],
    _y_ = [0, cst],
    _x_ = [0, cst_src_bind_ml, 52, 29],
    _w_ = [0, cst_src_bind_ml, 53, 18],
    _v_ = [0, cst_src_bind_ml, 58, 11],
    _u_ = [0, cst_src_bind_ml, 61, 35],
    _t_ = [0, cst_src_bind_ml, 62, 18],
    _r_ = [0, cst_src_bind_ml, 67, 23],
    _s_ = [0, cst_src_bind_ml, 66, 25],
    _q_ = [0, cst_src_bind_ml, 71, 13],
    _p_ = [0, cst_src_bind_ml, 72, 44],
    _A_ = [0, cst_src_bind_ml, 45, 1454, 1476],
    _i_ = [0, cst_all_nodes_created_on_rhs$0],
    _j_ = [0, cst_rhs_scope$0],
    _k_ = [0, "rhs"],
    _l_ = [0, cst_lhs_change$0],
    _m_ = [0, "lhs"],
    _n_ = [0, "f"],
    _o_ = [0, cst_main$0],
    cst_all_nodes_created_on_rhs = cst_all_nodes_created_on_rhs$0,
    cst_rhs_scope = cst_rhs_scope$0,
    cst_lhs_change = cst_lhs_change$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Bind = cst_Incremental_Bind$0;
   function all_nodes_created_on_rhs(r){return r[7];}
   function set_all_nodes_created_on_rhs(r, v){r[7] = v; return 0;}
   function rhs_scope(r){return r[6];}
   function set_rhs_scope(r, v){r[6] = v; return 0;}
   function lhs_change(r){return r[4];}
   function main(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], r[6], v];}
   var
    _b_ = [0, set_all_nodes_created_on_rhs],
    all_nodes_created_on_rhs$0 =
      [0,
       function(param){return 0;},
       cst_all_nodes_created_on_rhs,
       _b_,
       all_nodes_created_on_rhs,
       _a_];
   function _c_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v, r[7]];}
   var
    _d_ = [0, set_rhs_scope],
    rhs_scope$0 =
      [0, function(param){return 0;}, cst_rhs_scope, _d_, rhs_scope, _c_];
   function _e_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6], r[7]];}
   var
    _f_ = 0,
    lhs_change$0 =
      [0, function(param){return 0;}, cst_lhs_change, _f_, lhs_change, _e_];
   function _g_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6], r[7]];}
   var
    _h_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _h_, main, _g_];
   function sexp_of_t(of_a_001, of_b_002, param){
    var
     main_004 = param[1],
     lhs_change_010 = param[4],
     lhs_008 = param[3],
     rhs_012 = param[5],
     rhs_scope_014 = param[6],
     all_nodes_created_on_rhs_016 = param[7],
     arg_017 =
       caml_call2
        (Incremental_Import[6][2],
         Incremental_Types[15][2][1],
         all_nodes_created_on_rhs_016),
     bnds_003 = [0, [1, [0, _i_, [0, arg_017, 0]]], 0],
     arg_015 = caml_call1(Incremental_Types[21][1], rhs_scope_014),
     bnds_003$0 = [0, [1, [0, _j_, [0, arg_015, 0]]], bnds_003],
     _G_ = caml_call1(Incremental_Types[15][1], of_b_002),
     arg_013 = caml_call2(Incremental_Import[6][2], _G_, rhs_012),
     bnds_003$1 = [0, [1, [0, _k_, [0, arg_013, 0]]], bnds_003$0],
     arg_011 = caml_call2(Incremental_Types[15][1], Core[620], lhs_change_010),
     bnds_003$2 = [0, [1, [0, _l_, [0, arg_011, 0]]], bnds_003$1],
     arg_009 = caml_call2(Incremental_Types[15][1], of_a_001, lhs_008),
     bnds_003$3 = [0, [1, [0, _m_, [0, arg_009, 0]]], bnds_003$2];
    function _H_(_I_){return 0;}
    var
     arg_007 = caml_call1(Sexplib0_Sexp_conv[24], _H_),
     bnds_003$4 = [0, [1, [0, _n_, [0, arg_007, 0]]], bnds_003$3],
     arg_005 = caml_call2(Incremental_Types[15][1], of_b_002, main_004),
     bnds_003$5 = [0, [1, [0, _o_, [0, arg_005, 0]]], bnds_003$4];
    return [1, bnds_003$5];
   }
   function is_valid(t){
    var _F_ = t[1][5];
    if(typeof _F_ === "number" && ! _F_) return 0;
    return 1;
   }
   function iter_nodes_created_on_rhs(t, f){
    var r = [0, t[7]];
    for(;;){
     if(! caml_call1(Incremental_Import[6][8], r[1])) return 0;
     var match = caml_call1(Incremental_Import[6][16], r[1]);
     r[1] = match[13];
     caml_call1(f, match);
    }
   }
   function invariant(invariant_a, invariant_b, t){
    function _B_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      all_nodes_created_on_rhs_fun =
        check
         (function(param){
           return iter_nodes_created_on_rhs
                   (t,
                    function(node){
                     if(node[12] !== t[6])
                      throw caml_maybe_attach_backtrace
                             ([0, Assert_failure, _q_], 1);
                     var _E_ = caml_call1(Incremental_Types[15][4], node);
                     if(! _E_) return _E_;
                     if(caml_call2(Core[92], t[4][14], node[14])) return 0;
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _p_], 1);
                    });
          }),
      rhs_scope_fun =
        check
         (function(param){
           if(! param)
            throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
           var t$0 = param[1];
           if(t === t$0) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
          }),
      lhs_change_fun =
        check
         (function(lhs_change){
           if(lhs_change[12] !== t[1][12])
            throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
           var match = lhs_change[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(3 === match[0]){
            var t$0 = match[1];
            if(t === t$0) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
          }),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(4 === match[0]){
            var t$0 = match[1];
            if(t === t$0) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(lhs_change_fun, lhs_change$0);
     caml_call1(rhs_scope_fun, rhs_scope$0);
     return caml_call1
             (all_nodes_created_on_rhs_fun, all_nodes_created_on_rhs$0);
    }
    function _C_(x_018){
     function _D_(param){return _y_;}
     return sexp_of_t(function(param){return _z_;}, _D_, x_018);
    }
    return caml_call4(Base_Invariant[1], _A_, t, _C_, _B_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Bind);
   var
    Incremental_Bind =
      [0, invariant, sexp_of_t, is_valid, iter_nodes_created_on_rhs];
   runtime.caml_register_global(43, Incremental_Bind, cst_Incremental_Bind$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Expert
//# unitInfo: Requires: Core, Core__Int, Incremental__Import, Incremental__Types, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Expert$0 = "Incremental__Expert",
    cst_incremental$0 = "incremental",
    cst_src_expert_ml = "src/expert.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos$0 = "src/expert.ml:74:19",
    pos$1 = "src/expert.ml:67:22",
    pos = "src/expert.ml:60:21",
    Incremental_Import = global_data.Incremental__Import,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Core_Int = global_data.Core__Int,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Incremental_Types = global_data.Incremental__Types,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Expert$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_expert_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "expert.ml");
   var
    _q_ = [0, cst_src_expert_ml, 140, 2],
    _p_ = [0, cst_src_expert_ml, 109, 2],
    _o_ = [0, cst_src_expert_ml, 102, 18],
    _m_ = [0, cst_src_expert_ml, 61, 15],
    _n_ = [0, cst_src_expert_ml, 53, 2],
    _f_ = [0, "will_fire_all_callbacks"],
    _g_ = [0, "num_invalid_children"],
    _h_ = [0, "force_stale"],
    _i_ = [0, "num_children"],
    _j_ = [0, "children"],
    _k_ = [0, "on_observability_change"],
    _l_ = [0, "f"],
    _d_ = [0, "_"],
    _e_ = [0, "E"],
    _a_ = [0, "index"],
    _b_ = [0, "on_change"],
    _c_ = [0, "child"],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Expert = cst_Incremental_Expert$0;
   function sexp_of_edge(of_a_001, param){
    var
     child_003 = param[1],
     index_007 = param[3],
     arg_008 = caml_call2(Incremental_Import[6][2], Core[389], index_007),
     bnds_002 = [0, [1, [0, _a_, [0, arg_008, 0]]], 0];
    function _W_(_X_){return 0;}
    var
     arg_006 = caml_call1(Sexplib0_Sexp_conv[24], _W_),
     bnds_002$0 = [0, [1, [0, _b_, [0, arg_006, 0]]], bnds_002],
     arg_004 = caml_call2(Incremental_Types[15][1], of_a_001, child_003),
     bnds_002$1 = [0, [1, [0, _c_, [0, arg_004, 0]]], bnds_002$0];
    return [1, bnds_002$1];
   }
   function sexp_of_packed_edge(param){
    var res0_010 = sexp_of_edge(function(param){return _d_;}, param);
    return [1, [0, _e_, [0, res0_010, 0]]];
   }
   function sexp_of_t(of_a_011, param){
    var
     children_017 = param[3],
     num_children_019 = param[4],
     force_stale_021 = param[5],
     num_invalid_children_023 = param[6],
     will_fire_all_callbacks_025 = param[7],
     arg_026 = caml_call1(Core[323], will_fire_all_callbacks_025),
     bnds_012 = [0, [1, [0, _f_, [0, arg_026, 0]]], 0],
     arg_024 = caml_call1(Core[389], num_invalid_children_023),
     bnds_012$0 = [0, [1, [0, _g_, [0, arg_024, 0]]], bnds_012],
     arg_022 = caml_call1(Core[323], force_stale_021),
     bnds_012$1 = [0, [1, [0, _h_, [0, arg_022, 0]]], bnds_012$0],
     arg_020 = caml_call1(Core[389], num_children_019),
     bnds_012$2 = [0, [1, [0, _i_, [0, arg_020, 0]]], bnds_012$1],
     _R_ = caml_call1(Incremental_Import[6][2], sexp_of_packed_edge),
     arg_018 = caml_call2(Incremental_Import[7][10], _R_, children_017),
     bnds_012$3 = [0, [1, [0, _j_, [0, arg_018, 0]]], bnds_012$2];
    function _S_(_V_){return 0;}
    var
     arg_016 = caml_call1(Sexplib0_Sexp_conv[24], _S_),
     bnds_012$4 = [0, [1, [0, _k_, [0, arg_016, 0]]], bnds_012$3];
    function _T_(_U_){return 0;}
    var
     arg_014 = caml_call1(Sexplib0_Sexp_conv[24], _T_),
     bnds_012$5 = [0, [1, [0, _l_, [0, arg_014, 0]]], bnds_012$4];
    return [1, bnds_012$5];
   }
   function invariant(invariant_a, param){
    var
     children = param[3],
     num_children = param[4],
     _O_ = caml_call1(Incremental_Import[7][19], children);
    if(! caml_call2(Core[89], num_children, _O_))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    function _P_(expect, uopt){
     if(caml_call2(Core[92], expect, num_children)){
      var
       _Q_ = caml_call1(Incremental_Import[6][9], uopt)[3],
       got = caml_call1(Incremental_Import[6][9], _Q_),
       sexpifier = Core[389],
       equal = 0,
       message = 0,
       here = 0,
       comparator =
         function(a_027, b_028){return caml_call2(Core[382], a_027, b_028);};
      return caml_call8
              (Ppx_assert_lib_Runtime[3],
               pos,
               sexpifier,
               comparator,
               here,
               message,
               equal,
               expect,
               got);
     }
     if(caml_call1(Incremental_Import[6][7], uopt)) return 0;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    }
    return caml_call2(Incremental_Import[7][30], children, _P_);
   }
   function invariant_about_num_invalid_ch(t, is_necessary){
    var children = t[3], num_children = t[4], num_invalid_children = t[6];
    if(! is_necessary){
     var
      sexpifier$0 = Core[389],
      expect$0 = 0,
      equal$0 = 0,
      message$0 = 0,
      here$0 = 0,
      comparator$0 =
        function(a_029, b_030){return caml_call2(Core[382], a_029, b_030);};
     return caml_call8
             (Ppx_assert_lib_Runtime[3],
              pos$1,
              sexpifier$0,
              comparator$0,
              here$0,
              message$0,
              equal$0,
              expect$0,
              num_invalid_children);
    }
    var count_invalid_children = [0, 0], _L_ = num_children - 1 | 0, _K_ = 0;
    if(_L_ >= 0){
     var i = _K_;
     for(;;){
      var
       _M_ = caml_call2(Incremental_Import[7][20], children, i),
       r = caml_call1(Incremental_Import[6][9], _M_);
      if(1 - caml_call1(Incremental_Types[15][3], r[1]))
       count_invalid_children[1]++;
      var _N_ = i + 1 | 0;
      if(_L_ === i) break;
      var i = _N_;
     }
    }
    var
     expect = count_invalid_children[1],
     sexpifier = Core[389],
     equal = 0,
     message = 0,
     here = 0;
    function comparator(a_031, b_032){
     return caml_call2(Core[382], a_031, b_032);
    }
    return caml_call8
            (Ppx_assert_lib_Runtime[3],
             pos$0,
             sexpifier,
             comparator,
             here,
             message,
             equal,
             expect,
             num_invalid_children);
   }
   function create(f, on_observability_change){
    return [0,
            f,
            on_observability_change,
            Incremental_Import[7][15],
            0,
            0,
            0,
            1];
   }
   function make_stale(t){return t[5] ? 534011858 : (t[5] = 1, 17724);}
   function incr_invalid_children(t){t[6] = t[6] + 1 | 0; return 0;}
   function decr_invalid_children(t){t[6] = t[6] - 1 | 0; return 0;}
   function add_child_edge(t, packed_edge){
    if(! caml_call1(Incremental_Import[6][7], packed_edge[3]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var _G_ = caml_call1(Incremental_Import[7][19], t[3]);
    if(caml_call2(Core[88], t[4], _G_)){
     if(Incremental_Import[1]){
      var _H_ = caml_call1(Incremental_Import[7][19], t[3]);
      if(! caml_call2(Core[90], t[4], _H_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
     }
     var
      _I_ = 2 * caml_call1(Incremental_Import[7][19], t[3]) | 0,
      new_max = caml_call2(Core_Int[90], 2, _I_);
     t[3] = caml_call2(Incremental_Import[7][76], t[3], new_max);
    }
    var new_child_index = t[4];
    packed_edge[3] = caml_call1(Incremental_Import[6][6], new_child_index);
    var _J_ = caml_call1(Incremental_Import[6][6], packed_edge);
    caml_call3(Incremental_Import[7][75], t[3], new_child_index, _J_);
    t[4] = t[4] + 1 | 0;
    t[5] = 1;
    return new_child_index;
   }
   function swap_children(t, child_index1, child_index2){
    var
     _E_ = caml_call2(Incremental_Import[7][20], t[3], child_index1),
     edge1 = caml_call1(Incremental_Import[6][9], _E_),
     _F_ = caml_call2(Incremental_Import[7][20], t[3], child_index2),
     match = caml_call1(Incremental_Import[6][9], _F_);
    edge1[3] = caml_call1(Incremental_Import[6][6], child_index2);
    match[3] = caml_call1(Incremental_Import[6][6], child_index1);
    return caml_call3
            (Incremental_Import[7][23], t[3], child_index1, child_index2);
   }
   function last_child_edge_exn(t){
    var
     last_index = t[4] - 1 | 0,
     _D_ = caml_call2(Incremental_Import[7][20], t[3], last_index);
    return caml_call1(Incremental_Import[6][9], _D_);
   }
   function remove_last_child_edge_exn(t){
    var
     last_index = t[4] - 1 | 0,
     packed_edge_opt = caml_call2(Incremental_Import[7][20], t[3], last_index);
    caml_call3
     (Incremental_Import[7][75], t[3], last_index, Incremental_Import[6][5]);
    t[4] = last_index;
    t[5] = 1;
    if(! caml_call1(Incremental_Import[6][8], packed_edge_opt))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
    var match = caml_call1(Incremental_Import[6][16], packed_edge_opt);
    match[3] = Incremental_Import[6][5];
    return 0;
   }
   function before_main_computation(t){
    if(caml_call2(Core[91], t[6], 0)) return 144245463;
    t[5] = 0;
    var will_fire_all_callbacks = t[7];
    t[7] = 0;
    if(will_fire_all_callbacks){
     var _z_ = t[4] - 1 | 0, _y_ = 0;
     if(_z_ >= 0){
      var i = _y_;
      for(;;){
       var
        _A_ = caml_call2(Incremental_Import[7][20], t[3], i),
        match = caml_call1(Incremental_Import[6][9], _A_),
        _B_ = caml_call1(Incremental_Import[6][9], match[1][4]);
       caml_call1(match[2], _B_);
       var _C_ = i + 1 | 0;
       if(_z_ === i) break;
       var i = _C_;
      }
     }
    }
    return 17724;
   }
   function observability_change(t, is_now_observable){
    caml_call1(t[2], is_now_observable);
    var
     _w_ = 1 - is_now_observable,
     _x_ = _w_ ? (t[7] = 1, t[6] = 0, 0) : _w_;
    return _x_;
   }
   function run_edge_callback(t, child_index){
    var _r_ = 1 - t[7];
    if(_r_){
     var
      _s_ = caml_call2(Incremental_Import[7][20], t[3], child_index),
      r = caml_call1(Incremental_Import[6][9], _s_),
      _t_ = caml_call1(Incremental_Import[6][8], r[1][4]);
     if(_t_){
      var _u_ = caml_call1(Incremental_Import[6][16], r[1][4]);
      return caml_call1(r[2], _u_);
     }
     var _v_ = _t_;
    }
    else
     var _v_ = _r_;
    return _v_;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Expert);
   var
    Incremental_Expert =
      [0,
       invariant,
       sexp_of_t,
       sexp_of_edge,
       invariant_about_num_invalid_ch,
       create,
       make_stale,
       incr_invalid_children,
       decr_invalid_children,
       add_child_edge,
       swap_children,
       last_child_edge_exn,
       remove_last_child_edge_exn,
       before_main_computation,
       observability_change,
       run_edge_callback];
   runtime.caml_register_global
    (38, Incremental_Expert, cst_Incremental_Expert$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Sexp_of
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Sexp_of = "Incremental__Sexp_of",
    cst_incremental = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Sexp_of);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][1], "src/sexp_of.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental, "sexp_of.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Sexp_of);
   var Incremental_Sexp_of = [0];
   runtime.caml_register_global
    (11, Incremental_Sexp_of, cst_Incremental_Sexp_of);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Scope
//# unitInfo: Requires: Incremental__Bind, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Scope$0 = "Incremental__Scope",
    cst_incremental$0 = "incremental",
    cst_src_scope_ml = "src/scope.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_Types = global_data.Incremental__Types,
    Incremental_Bind = global_data.Incremental__Bind,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Scope$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_scope_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "scope.ml");
   var
    include = Incremental_Types[21],
    sexp_of_t = include[1],
    _a_ = [0, cst_src_scope_ml, 37, 2],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Scope = cst_Incremental_Scope$0,
    top = 0;
   function is_top(param){return param ? 0 : 1;}
   function invariant(param){
    if(! param) return 0;
    var bind = param[1];
    function _b_(_e_){return 0;}
    function _c_(_d_){return 0;}
    return caml_call3(Incremental_Bind[1], _c_, _b_, bind);
   }
   function height(param){
    if(! param) return -1;
    var bind = param[1];
    return bind[4][14];
   }
   function is_valid(param){
    if(! param) return 1;
    var bind = param[1];
    return caml_call1(Incremental_Bind[3], bind);
   }
   function is_necessary(param){
    if(! param) return 1;
    var bind = param[1];
    return caml_call1(Incremental_Types[15][4], bind[1]);
   }
   function add_node(t, node){
    if(node[12] !== t)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    if(! t) return 0;
    var bind = t[1];
    node[13] = bind[7];
    bind[7] = caml_call1(Incremental_Import[6][6], node);
    return 0;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Scope);
   var
    Incremental_Scope =
      [0,
       sexp_of_t,
       invariant,
       top,
       is_top,
       height,
       is_valid,
       is_necessary,
       add_node];
   runtime.caml_register_global
    (16, Incremental_Scope, cst_Incremental_Scope$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Freeze
//# unitInfo: Requires: Base__Invariant, Incremental__Scope, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Freeze$0 = "Incremental__Freeze",
    cst_incremental$0 = "incremental",
    cst_main$0 = "main",
    cst_src_freeze_ml = "src/freeze.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Incremental_Scope = global_data.Incremental__Scope,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_Types = global_data.Incremental__Types,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Freeze$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_freeze_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "freeze.ml");
   var
    _i_ = [0, "_"],
    _h_ = [0, cst_src_freeze_ml, 19, 11],
    _g_ = [0, cst_src_freeze_ml, 23, 26],
    _f_ = [0, cst_src_freeze_ml, 24, 18],
    _j_ = [0, cst_src_freeze_ml, 14, 255, 277],
    _c_ = [0, "only_freeze_when"],
    _d_ = [0, "child"],
    _e_ = [0, cst_main$0],
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Freeze = cst_Incremental_Freeze$0;
   function main(r){return r[1];}
   function _a_(r, v){return [0, v, r[2], r[3]];}
   var
    _b_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _b_, main, _a_];
   function sexp_of_t(of_a_001, param){
    var child_005 = param[2], main_003 = param[1], bnds_002 = 0;
    function _m_(_n_){return 0;}
    var
     arg_008 = caml_call1(Sexplib0_Sexp_conv[24], _m_),
     bnds_002$0 = [0, [1, [0, _c_, [0, arg_008, 0]]], bnds_002],
     arg_006 = caml_call2(Incremental_Types[15][1], of_a_001, child_005),
     bnds_002$1 = [0, [1, [0, _d_, [0, arg_006, 0]]], bnds_002$0],
     arg_004 = caml_call2(Incremental_Types[15][1], of_a_001, main_003),
     bnds_002$2 = [0, [1, [0, _e_, [0, arg_004, 0]]], bnds_002$1];
    return [1, bnds_002$2];
   }
   function invariant(invariant_a, t){
    function _k_(param){
     function f(main){
      if(! caml_call1(Incremental_Scope[4], main[12]))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      var match = main[5];
      if(typeof match === "number"){if(0 === match) return 0;}
      else
       switch(match[0]){
         case 5:
          return 0;
         case 7:
          var t$0 = match[1];
          if(t === t$0) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
       }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
     var main_fun = caml_call2(Base_Invariant[2], t, f);
     caml_call1(main_fun, main$0);
     return 0;
    }
    function _l_(x_009){
     return sexp_of_t(function(param){return _i_;}, x_009);
    }
    return caml_call4(Base_Invariant[1], _j_, t, _l_, _k_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Freeze);
   var Incremental_Freeze = [0, invariant, sexp_of_t];
   runtime.caml_register_global
    (27, Incremental_Freeze, cst_Incremental_Freeze$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__If_then_else
//# unitInfo: Requires: Base__Invariant, Core, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_If_then_else$0 = "Incremental__If_then_else",
    cst_current_branch$0 = "current_branch",
    cst_incremental$0 = "incremental",
    cst_main$0 = "main",
    cst_src_if_then_else_ml = "src/if_then_else.ml",
    cst_test_change$0 = "test_change",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Incremental_Import = global_data.Incremental__Import,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Types = global_data.Incremental__Types,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_If_then_else$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_if_then_else_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "if_then_else.ml");
   var
    _q_ = [0, "_"],
    _p_ = [0, cst_src_if_then_else_ml, 26, 32],
    _o_ = [0, cst_src_if_then_else_ml, 33, 34],
    _n_ = [0, cst_src_if_then_else_ml, 34, 18],
    _m_ = [0, cst_src_if_then_else_ml, 40, 13],
    _r_ = [0, cst_src_if_then_else_ml, 19, 398, 420],
    _g_ = [0, "else_"],
    _h_ = [0, "then_"],
    _i_ = [0, cst_current_branch$0],
    _j_ = [0, cst_test_change$0],
    _k_ = [0, "test"],
    _l_ = [0, cst_main$0],
    cst_current_branch = cst_current_branch$0,
    cst_test_change = cst_test_change$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_If_then_else = cst_Incremental_If_then_else$0;
   function current_branch(r){return r[4];}
   function set_current_branch(r, v){r[4] = v; return 0;}
   function test_change(r){return r[3];}
   function main(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6]];}
   var
    _b_ = [0, set_current_branch],
    current_branch$0 =
      [0,
       function(param){return 0;},
       cst_current_branch,
       _b_,
       current_branch,
       _a_];
   function _c_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6]];}
   var
    _d_ = 0,
    test_change$0 =
      [0, function(param){return 0;}, cst_test_change, _d_, test_change, _c_];
   function _e_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6]];}
   var
    _f_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _f_, main, _e_];
   function sexp_of_t(of_a_001, param){
    var
     test_change_007 = param[3],
     test_005 = param[2],
     main_003 = param[1],
     current_branch_009 = param[4],
     else_013 = param[6],
     then_011 = param[5],
     arg_014 = caml_call2(Incremental_Types[15][1], of_a_001, else_013),
     bnds_002 = [0, [1, [0, _g_, [0, arg_014, 0]]], 0],
     arg_012 = caml_call2(Incremental_Types[15][1], of_a_001, then_011),
     bnds_002$0 = [0, [1, [0, _h_, [0, arg_012, 0]]], bnds_002],
     _v_ = caml_call1(Incremental_Types[15][1], of_a_001),
     arg_010 = caml_call2(Incremental_Import[6][2], _v_, current_branch_009),
     bnds_002$1 = [0, [1, [0, _i_, [0, arg_010, 0]]], bnds_002$0],
     arg_008 =
       caml_call2(Incremental_Types[15][1], Core[620], test_change_007),
     bnds_002$2 = [0, [1, [0, _j_, [0, arg_008, 0]]], bnds_002$1],
     arg_006 = caml_call2(Incremental_Types[15][1], Core[323], test_005),
     bnds_002$3 = [0, [1, [0, _k_, [0, arg_006, 0]]], bnds_002$2],
     arg_004 = caml_call2(Incremental_Types[15][1], of_a_001, main_003),
     bnds_002$4 = [0, [1, [0, _l_, [0, arg_004, 0]]], bnds_002$3];
    return [1, bnds_002$4];
   }
   function invariant(invariant_a, t){
    function _s_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      current_branch_fun =
        check
         (function(current_branch){
           var _u_ = caml_call1(Incremental_Import[6][8], current_branch);
           if(! _u_) return _u_;
           var
            current_branch$0 =
              caml_call1(Incremental_Import[6][9], current_branch);
           if(current_branch$0 !== t[5] && current_branch$0 !== t[6])
            throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
           return 0;
          }),
      test_change_fun =
        check
         (function(test_change){
           var match = test_change[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(8 === match[0]){
            var t$0 = match[1];
            if(t === t$0) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
          }),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(9 === match[0]){
            var t$0 = match[1];
            if(t === t$0) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
           }
           return 0;
          });
     caml_call1(main_fun, main$0);
     caml_call1(test_change_fun, test_change$0);
     caml_call1(current_branch_fun, current_branch$0);
     return 0;
    }
    function _t_(x_015){
     return sexp_of_t(function(param){return _q_;}, x_015);
    }
    return caml_call4(Base_Invariant[1], _r_, t, _t_, _s_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_If_then_else);
   var Incremental_If_then_else = [0, invariant, sexp_of_t];
   runtime.caml_register_global
    (34, Incremental_If_then_else, cst_Incremental_If_then_else$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Join
//# unitInfo: Requires: Base__Invariant, Core, Incremental__Import, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Join$0 = "Incremental__Join",
    cst_incremental$0 = "incremental",
    cst_lhs_change$0 = "lhs_change",
    cst_main$0 = "main",
    cst_src_join_ml = "src/join.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Types = global_data.Incremental__Types,
    Incremental_Import = global_data.Incremental__Import,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Join$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_join_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "join.ml");
   var
    _m_ = [0, "_"],
    _l_ = [0, cst_src_join_ml, 24, 29],
    _k_ = [0, cst_src_join_ml, 25, 18],
    _j_ = [0, cst_src_join_ml, 31, 35],
    _i_ = [0, cst_src_join_ml, 32, 18],
    _n_ = [0, cst_src_join_ml, 17, 338, 360],
    _e_ = [0, "rhs"],
    _f_ = [0, cst_lhs_change$0],
    _g_ = [0, "lhs"],
    _h_ = [0, cst_main$0],
    cst_lhs_change = cst_lhs_change$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Join = cst_Incremental_Join$0;
   function lhs_change(r){return r[3];}
   function main(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _b_ = 0,
    lhs_change$0 =
      [0, function(param){return 0;}, cst_lhs_change, _b_, lhs_change, _a_];
   function _c_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _d_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _d_, main, _c_];
   function sexp_of_t(of_a_001, param){
    var
     lhs_change_007 = param[3],
     lhs_005 = param[2],
     main_003 = param[1],
     rhs_009 = param[4],
     _q_ = caml_call1(Incremental_Types[15][1], of_a_001),
     arg_010 = caml_call2(Incremental_Import[6][2], _q_, rhs_009),
     bnds_002 = [0, [1, [0, _e_, [0, arg_010, 0]]], 0],
     arg_008 = caml_call2(Incremental_Types[15][1], Core[620], lhs_change_007),
     bnds_002$0 = [0, [1, [0, _f_, [0, arg_008, 0]]], bnds_002],
     _r_ = caml_call1(Incremental_Types[15][1], of_a_001),
     arg_006 = caml_call2(Incremental_Types[15][1], _r_, lhs_005),
     bnds_002$1 = [0, [1, [0, _g_, [0, arg_006, 0]]], bnds_002$0],
     arg_004 = caml_call2(Incremental_Types[15][1], of_a_001, main_003),
     bnds_002$2 = [0, [1, [0, _h_, [0, arg_004, 0]]], bnds_002$1];
    return [1, bnds_002$2];
   }
   function invariant(invariant_a, t){
    function _o_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      lhs_change_fun =
        check
         (function(lhs_change){
           var match = lhs_change[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(10 === match[0]){
            var t$0 = match[1];
            if(t === t$0) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
          }),
      main_fun =
        check
         (function(main){
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else if(11 === match[0]){
            var t$0 = match[1];
            if(t === t$0) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
           }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(lhs_change_fun, lhs_change$0);
     return 0;
    }
    function _p_(x_011){
     return sexp_of_t(function(param){return _m_;}, x_011);
    }
    return caml_call4(Base_Invariant[1], _n_, t, _p_, _o_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Join);
   var Incremental_Join = [0, invariant, sexp_of_t];
   runtime.caml_register_global(30, Incremental_Join, cst_Incremental_Join$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Snapshot
//# unitInfo: Requires: Base__Invariant, Incremental__Import, Incremental__Scope, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Snapshot$0 = "Incremental__Snapshot",
    cst_before$0 = "before",
    cst_incremental$0 = "incremental",
    cst_main$0 = "main",
    cst_src_snapshot_ml = "src/snapshot.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Incremental_Scope = global_data.Incremental__Scope,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_Types = global_data.Incremental__Types,
    Incremental_Import = global_data.Incremental__Import,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Snapshot$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_snapshot_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "snapshot.ml");
   var
    _m_ = [0, "_"],
    _l_ = [0, cst_src_snapshot_ml, 21, 11],
    _k_ = [0, cst_src_snapshot_ml, 25, 28],
    _j_ = [0, cst_src_snapshot_ml, 26, 18],
    _n_ = [0, cst_src_snapshot_ml, 16, 302, 324],
    _e_ = [0, "clock"],
    _f_ = [0, "value_at"],
    _g_ = [0, cst_before$0],
    _h_ = [0, "at"],
    _i_ = [0, cst_main$0],
    cst_before = cst_before$0,
    cst_main = cst_main$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Snapshot = cst_Incremental_Snapshot$0;
   function before(r){return r[3];}
   function main(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], v, r[4], r[5]];}
   var
    _b_ = 0,
    before$0 = [0, function(param){return 0;}, cst_before, _b_, before, _a_];
   function _c_(r, v){return [0, v, r[2], r[3], r[4], r[5]];}
   var
    _d_ = 0,
    main$0 = [0, function(param){return 0;}, cst_main, _d_, main, _c_];
   function sexp_of_t(of_a_001, param){
    var
     clock_011 = param[5],
     value_at_009 = param[4],
     before_007 = param[3],
     at_005 = param[2],
     main_003 = param[1],
     arg_012 = caml_call1(Sexplib0_Sexp_conv[23], clock_011),
     bnds_002 = [0, [1, [0, _e_, [0, arg_012, 0]]], 0],
     arg_010 = caml_call2(Incremental_Types[15][1], of_a_001, value_at_009),
     bnds_002$0 = [0, [1, [0, _f_, [0, arg_010, 0]]], bnds_002],
     arg_008 = caml_call1(of_a_001, before_007),
     bnds_002$1 = [0, [1, [0, _g_, [0, arg_008, 0]]], bnds_002$0],
     arg_006 = caml_call1(Incremental_Import[4][126], at_005),
     bnds_002$2 = [0, [1, [0, _h_, [0, arg_006, 0]]], bnds_002$1],
     arg_004 = caml_call2(Incremental_Types[15][1], of_a_001, main_003),
     bnds_002$3 = [0, [1, [0, _i_, [0, arg_004, 0]]], bnds_002$2];
    return [1, bnds_002$3];
   }
   function invariant(invariant_a, t){
    function _o_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      before_fun = check(invariant_a),
      main_fun =
        check
         (function(main){
           if(! caml_call1(Incremental_Scope[4], main[12]))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
           var match = main[5];
           if(typeof match === "number"){if(0 === match) return 0;}
           else
            switch(match[0]){
              case 5:
               return 0;
              case 13:
               var t$0 = match[1];
               if(t === t$0) return 0;
               throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
            }
           throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
          });
     caml_call1(main_fun, main$0);
     caml_call1(before_fun, before$0);
     return 0;
    }
    function _p_(x_013){
     return sexp_of_t(function(param){return _m_;}, x_013);
    }
    return caml_call4(Base_Invariant[1], _n_, t, _p_, _o_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Snapshot);
   var Incremental_Snapshot = [0, invariant, sexp_of_t];
   runtime.caml_register_global
    (32, Incremental_Snapshot, cst_Incremental_Snapshot$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Kind
//# unitInfo: Requires: Core, Incremental__Array_fold, Incremental__At, Incremental__At_intervals, Incremental__Bind, Incremental__Expert, Incremental__Freeze, Incremental__If_then_else, Incremental__Import, Incremental__Join, Incremental__Snapshot, Incremental__Step_function_node, Incremental__Types, Incremental__Unordered_array_fold, Incremental__Var, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Array_fold$0 = "Array_fold",
    cst_At$0 = "At",
    cst_At_intervals$0 = "At_intervals",
    cst_Bind_lhs_change$0 = "Bind_lhs_change",
    cst_Bind_main$0 = "Bind_main",
    cst_Const$0 = "Const",
    cst_Expert$0 = "Expert",
    cst_Freeze$0 = "Freeze",
    cst_If_test_change$0 = "If_test_change",
    cst_If_then_else$0 = "If_then_else",
    cst_Incremental_Kind$0 = "Incremental__Kind",
    cst_Invalid$0 = "Invalid",
    cst_Join_lhs_change$0 = "Join_lhs_change",
    cst_Join_main$0 = "Join_main",
    cst_Map$0 = "Map",
    cst_Map10$0 = "Map10",
    cst_Map11$0 = "Map11",
    cst_Map12$0 = "Map12",
    cst_Map13$0 = "Map13",
    cst_Map14$0 = "Map14",
    cst_Map15$0 = "Map15",
    cst_Map2$0 = "Map2",
    cst_Map3$0 = "Map3",
    cst_Map4$0 = "Map4",
    cst_Map5$0 = "Map5",
    cst_Map6$0 = "Map6",
    cst_Map7$0 = "Map7",
    cst_Map8$0 = "Map8",
    cst_Map9$0 = "Map9",
    cst_Snapshot$0 = "Snapshot",
    cst_Step_function$0 = "Step_function",
    cst_Uninitialized$0 = "Uninitialized",
    cst_Unordered_array_fold$0 = "Unordered_array_fold",
    cst_Var$0 = "Var",
    cst = "_",
    cst_incremental$0 = "incremental",
    cst_src_kind_ml = "src/kind.ml",
    caml_check_bound = runtime.caml_check_bound;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_Array_fold = global_data.Incremental__Array_fold,
    Incremental_At = global_data.Incremental__At,
    Incremental_At_intervals = global_data.Incremental__At_intervals,
    Incremental_Bind = global_data.Incremental__Bind,
    Incremental_Expert = global_data.Incremental__Expert,
    Incremental_Freeze = global_data.Incremental__Freeze,
    Incremental_If_then_else = global_data.Incremental__If_then_else,
    Incremental_Join = global_data.Incremental__Join,
    Incremental_Snapshot = global_data.Incremental__Snapshot,
    Incremental_Step_function_node =
      global_data.Incremental__Step_function_node,
    Incremental_Unordered_array_fo =
      global_data.Incremental__Unordered_array_fold,
    Incremental_Var = global_data.Incremental__Var,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_Types = global_data.Incremental__Types,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Kind$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_kind_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "kind.ml");
   var
    _bQ_ = [0, cst],
    cst_Kind_slow_get_child_got_in = "Kind.slow_get_child got invalid index",
    _bR_ = [0, cst_src_kind_ml, 602, 14347, 14361],
    cst_Invalid = cst_Invalid$0,
    cst_Uninitialized = cst_Uninitialized$0,
    cst_Array_fold = cst_Array_fold$0,
    cst_At = cst_At$0,
    cst_At_intervals = cst_At_intervals$0,
    cst_Bind_lhs_change = cst_Bind_lhs_change$0,
    cst_Bind_main = cst_Bind_main$0,
    cst_Const = cst_Const$0,
    cst_Expert = cst_Expert$0,
    cst_Freeze = cst_Freeze$0,
    cst_If_test_change = cst_If_test_change$0,
    cst_If_then_else = cst_If_then_else$0,
    cst_Join_lhs_change = cst_Join_lhs_change$0,
    cst_Join_main = cst_Join_main$0,
    cst_Map = cst_Map$0,
    cst_Snapshot = cst_Snapshot$0,
    cst_Step_function = cst_Step_function$0,
    cst_Unordered_array_fold = cst_Unordered_array_fold$0,
    cst_Var = cst_Var$0,
    cst_Map2 = cst_Map2$0,
    cst_Map3 = cst_Map3$0,
    cst_Map4 = cst_Map4$0,
    cst_Map5 = cst_Map5$0,
    cst_Map6 = cst_Map6$0,
    cst_Map7 = cst_Map7$0,
    cst_Map8 = cst_Map8$0,
    cst_Map9 = cst_Map9$0,
    cst_Map10 = cst_Map10$0,
    cst_Map11 = cst_Map11$0,
    cst_Map12 = cst_Map12$0,
    cst_Map13 = cst_Map13$0,
    cst_Map14 = cst_Map14$0,
    cst_Map15 = cst_Map15$0,
    _bO_ = [0, cst],
    _bN_ = [0, cst],
    _bM_ = [0, cst],
    _bL_ = [0, cst],
    _bK_ = [0, cst],
    _bJ_ = [0, cst],
    _bI_ = [0, cst],
    _bH_ = [0, cst],
    _bG_ = [0, cst],
    _bF_ = [0, cst],
    _bE_ = [0, cst],
    _bD_ = [0, cst],
    _bC_ = [0, cst],
    _bB_ = [0, cst],
    _bA_ = [0, cst],
    _by_ = [0, cst],
    _bx_ = [0, cst],
    _bw_ = [0, cst],
    _bv_ = [0, cst],
    _bu_ = [0, cst],
    _bt_ = [0, cst],
    _bs_ = [0, cst],
    _br_ = [0, cst],
    _bq_ = [0, cst],
    _bp_ = [0, cst],
    _bo_ = [0, cst],
    _bn_ = [0, cst],
    _bm_ = [0, cst],
    _bl_ = [0, cst],
    _bj_ = [0, cst],
    _bi_ = [0, cst],
    _bh_ = [0, cst],
    _bg_ = [0, cst],
    _bf_ = [0, cst],
    _be_ = [0, cst],
    _bd_ = [0, cst],
    _bc_ = [0, cst],
    _bb_ = [0, cst],
    _ba_ = [0, cst],
    _a$_ = [0, cst],
    _a__ = [0, cst],
    _a9_ = [0, cst],
    _a7_ = [0, cst],
    _a6_ = [0, cst],
    _a5_ = [0, cst],
    _a4_ = [0, cst],
    _a3_ = [0, cst],
    _a2_ = [0, cst],
    _a1_ = [0, cst],
    _a0_ = [0, cst],
    _aZ_ = [0, cst],
    _aY_ = [0, cst],
    _aX_ = [0, cst],
    _aW_ = [0, cst],
    _aU_ = [0, cst],
    _aT_ = [0, cst],
    _aS_ = [0, cst],
    _aR_ = [0, cst],
    _aQ_ = [0, cst],
    _aP_ = [0, cst],
    _aO_ = [0, cst],
    _aN_ = [0, cst],
    _aM_ = [0, cst],
    _aL_ = [0, cst],
    _aK_ = [0, cst],
    _aI_ = [0, cst],
    _aH_ = [0, cst],
    _aG_ = [0, cst],
    _aF_ = [0, cst],
    _aE_ = [0, cst],
    _aD_ = [0, cst],
    _aC_ = [0, cst],
    _aB_ = [0, cst],
    _aA_ = [0, cst],
    _az_ = [0, cst],
    _ax_ = [0, cst],
    _aw_ = [0, cst],
    _av_ = [0, cst],
    _au_ = [0, cst],
    _at_ = [0, cst],
    _as_ = [0, cst],
    _ar_ = [0, cst],
    _aq_ = [0, cst],
    _ap_ = [0, cst],
    _an_ = [0, cst],
    _am_ = [0, cst],
    _al_ = [0, cst],
    _ak_ = [0, cst],
    _aj_ = [0, cst],
    _ai_ = [0, cst],
    _ah_ = [0, cst],
    _ag_ = [0, cst],
    _ae_ = [0, cst],
    _ad_ = [0, cst],
    _ac_ = [0, cst],
    _ab_ = [0, cst],
    _aa_ = [0, cst],
    _$_ = [0, cst],
    ___ = [0, cst],
    _Y_ = [0, cst],
    _X_ = [0, cst],
    _W_ = [0, cst],
    _V_ = [0, cst],
    _U_ = [0, cst],
    _T_ = [0, cst],
    _R_ = [0, cst],
    _Q_ = [0, cst],
    _P_ = [0, cst],
    _O_ = [0, cst],
    _N_ = [0, cst],
    _L_ = [0, cst],
    _K_ = [0, cst],
    _J_ = [0, cst],
    _I_ = [0, cst],
    _G_ = [0, cst],
    _F_ = [0, cst],
    _E_ = [0, cst],
    _C_ = [0, cst],
    _B_ = [0, cst],
    _y_ = [0, cst],
    _u_ = [0, cst],
    _r_ = [0, cst],
    _o_ = [0, cst],
    _j_ = [0, cst],
    _h_ = [0, cst],
    _g_ = [0, cst],
    _c_ = [0, cst],
    _a_ = [0, cst_Invalid$0],
    _b_ = [0, cst_Uninitialized$0],
    _d_ = [0, cst_Array_fold$0],
    _e_ = [0, cst_At$0],
    _f_ = [0, cst_At_intervals$0],
    _i_ = [0, cst_Bind_lhs_change$0],
    _k_ = [0, cst_Bind_main$0],
    _l_ = [0, cst_Const$0],
    _m_ = [0, cst_Expert$0],
    _n_ = [0, cst_Freeze$0],
    _p_ = [0, cst_If_test_change$0],
    _q_ = [0, cst_If_then_else$0],
    _s_ = [0, cst_Join_lhs_change$0],
    _t_ = [0, cst_Join_main$0],
    _v_ = [0, cst_Map$0],
    _w_ = [0, cst_Snapshot$0],
    _x_ = [0, cst_Step_function$0],
    _z_ = [0, cst_Unordered_array_fold$0],
    _A_ = [0, cst_Var$0],
    _D_ = [0, cst_Map2$0],
    _H_ = [0, cst_Map3$0],
    _M_ = [0, cst_Map4$0],
    _S_ = [0, cst_Map5$0],
    _Z_ = [0, cst_Map6$0],
    _af_ = [0, cst_Map7$0],
    _ao_ = [0, cst_Map8$0],
    _ay_ = [0, cst_Map9$0],
    _aJ_ = [0, cst_Map10$0],
    _aV_ = [0, cst_Map11$0],
    _a8_ = [0, cst_Map12$0],
    _bk_ = [0, cst_Map13$0],
    _bz_ = [0, cst_Map14$0],
    _bP_ = [0, cst_Map15$0],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Kind = cst_Incremental_Kind$0;
   function sexp_of_t(of_a_001, param){
    if(typeof param === "number") return 0 === param ? _a_ : _b_;
    switch(param[0]){
      case 0:
       var
        arg0_002 = param[1],
        _co_ = function(param){return _c_;},
        res0_003 =
          caml_call3(Incremental_Array_fold[1], _co_, of_a_001, arg0_002);
       return [1, [0, _d_, [0, res0_003, 0]]];
      case 1:
       var
        arg0_004 = param[1],
        res0_005 = caml_call1(Incremental_At[2], arg0_004);
       return [1, [0, _e_, [0, res0_005, 0]]];
      case 2:
       var
        arg0_006 = param[1],
        res0_007 = caml_call1(Incremental_At_intervals[2], arg0_006);
       return [1, [0, _f_, [0, res0_007, 0]]];
      case 3:
       var
        arg0_008 = param[1],
        _cp_ = function(param){return _g_;},
        _cq_ = function(param){return _h_;},
        res0_009 = caml_call3(Incremental_Bind[2], _cq_, _cp_, arg0_008);
       return [1, [0, _i_, [0, res0_009, 0]]];
      case 4:
       var
        arg0_010 = param[1],
        _cr_ = function(param){return _j_;},
        res0_011 = caml_call3(Incremental_Bind[2], _cr_, of_a_001, arg0_010);
       return [1, [0, _k_, [0, res0_011, 0]]];
      case 5:
       var arg0_012 = param[1], res0_013 = caml_call1(of_a_001, arg0_012);
       return [1, [0, _l_, [0, res0_013, 0]]];
      case 6:
       var
        arg0_014 = param[1],
        res0_015 = caml_call2(Incremental_Expert[2], of_a_001, arg0_014);
       return [1, [0, _m_, [0, res0_015, 0]]];
      case 7:
       var
        arg0_016 = param[1],
        res0_017 = caml_call2(Incremental_Freeze[2], of_a_001, arg0_016);
       return [1, [0, _n_, [0, res0_017, 0]]];
      case 8:
       var
        arg0_018 = param[1],
        _cs_ = function(param){return _o_;},
        res0_019 = caml_call2(Incremental_If_then_else[2], _cs_, arg0_018);
       return [1, [0, _p_, [0, res0_019, 0]]];
      case 9:
       var
        arg0_020 = param[1],
        res0_021 = caml_call2(Incremental_If_then_else[2], of_a_001, arg0_020);
       return [1, [0, _q_, [0, res0_021, 0]]];
      case 10:
       var
        arg0_022 = param[1],
        _ct_ = function(param){return _r_;},
        res0_023 = caml_call2(Incremental_Join[2], _ct_, arg0_022);
       return [1, [0, _s_, [0, res0_023, 0]]];
      case 11:
       var
        arg0_024 = param[1],
        res0_025 = caml_call2(Incremental_Join[2], of_a_001, arg0_024);
       return [1, [0, _t_, [0, res0_025, 0]]];
      case 12:
       var
        arg1_027 = param[2],
        _cu_ = function(_eQ_){return 0;},
        res0_028 = caml_call1(Sexplib0_Sexp_conv[24], _cu_),
        _cv_ = function(param){return _u_;},
        res1_029 = caml_call2(Incremental_Types[15][1], _cv_, arg1_027);
       return [1, [0, _v_, [0, res0_028, [0, res1_029, 0]]]];
      case 13:
       var
        arg0_030 = param[1],
        res0_031 = caml_call2(Incremental_Snapshot[2], of_a_001, arg0_030);
       return [1, [0, _w_, [0, res0_031, 0]]];
      case 14:
       var
        arg0_032 = param[1],
        res0_033 =
          caml_call2(Incremental_Step_function_node[2], of_a_001, arg0_032);
       return [1, [0, _x_, [0, res0_033, 0]]];
      case 15:
       var
        arg0_034 = param[1],
        _cw_ = function(param){return _y_;},
        res0_035 =
          caml_call3
           (Incremental_Unordered_array_fo[2], _cw_, of_a_001, arg0_034);
       return [1, [0, _z_, [0, res0_035, 0]]];
      case 16:
       var
        arg0_036 = param[1],
        res0_037 = caml_call2(Incremental_Var[2], of_a_001, arg0_036);
       return [1, [0, _A_, [0, res0_037, 0]]];
      case 17:
       var
        arg2_040 = param[3],
        arg1_039 = param[2],
        _cx_ = function(_eP_){return 0;},
        res0_041 = caml_call1(Sexplib0_Sexp_conv[24], _cx_),
        _cy_ = function(param){return _B_;},
        res1_042 = caml_call2(Incremental_Types[15][1], _cy_, arg1_039),
        _cz_ = function(param){return _C_;},
        res2_043 = caml_call2(Incremental_Types[15][1], _cz_, arg2_040);
       return [1, [0, _D_, [0, res0_041, [0, res1_042, [0, res2_043, 0]]]]];
      case 18:
       var
        arg3_047 = param[4],
        arg2_046 = param[3],
        arg1_045 = param[2],
        _cA_ = function(_eO_){return 0;},
        res0_048 = caml_call1(Sexplib0_Sexp_conv[24], _cA_),
        _cB_ = function(param){return _E_;},
        res1_049 = caml_call2(Incremental_Types[15][1], _cB_, arg1_045),
        _cC_ = function(param){return _F_;},
        res2_050 = caml_call2(Incremental_Types[15][1], _cC_, arg2_046),
        _cD_ = function(param){return _G_;},
        res3_051 = caml_call2(Incremental_Types[15][1], _cD_, arg3_047);
       return [1,
               [0,
                _H_,
                [0, res0_048, [0, res1_049, [0, res2_050, [0, res3_051, 0]]]]]];
      case 19:
       var
        arg4_056 = param[5],
        arg3_055 = param[4],
        arg2_054 = param[3],
        arg1_053 = param[2],
        _cE_ = function(_eN_){return 0;},
        res0_057 = caml_call1(Sexplib0_Sexp_conv[24], _cE_),
        _cF_ = function(param){return _I_;},
        res1_058 = caml_call2(Incremental_Types[15][1], _cF_, arg1_053),
        _cG_ = function(param){return _J_;},
        res2_059 = caml_call2(Incremental_Types[15][1], _cG_, arg2_054),
        _cH_ = function(param){return _K_;},
        res3_060 = caml_call2(Incremental_Types[15][1], _cH_, arg3_055),
        _cI_ = function(param){return _L_;},
        res4_061 = caml_call2(Incremental_Types[15][1], _cI_, arg4_056);
       return [1,
               [0,
                _M_,
                [0,
                 res0_057,
                 [0, res1_058, [0, res2_059, [0, res3_060, [0, res4_061, 0]]]]]]];
      case 20:
       var
        arg5_067 = param[6],
        arg4_066 = param[5],
        arg3_065 = param[4],
        arg2_064 = param[3],
        arg1_063 = param[2],
        _cJ_ = function(_eM_){return 0;},
        res0_068 = caml_call1(Sexplib0_Sexp_conv[24], _cJ_),
        _cK_ = function(param){return _N_;},
        res1_069 = caml_call2(Incremental_Types[15][1], _cK_, arg1_063),
        _cL_ = function(param){return _O_;},
        res2_070 = caml_call2(Incremental_Types[15][1], _cL_, arg2_064),
        _cM_ = function(param){return _P_;},
        res3_071 = caml_call2(Incremental_Types[15][1], _cM_, arg3_065),
        _cN_ = function(param){return _Q_;},
        res4_072 = caml_call2(Incremental_Types[15][1], _cN_, arg4_066),
        _cO_ = function(param){return _R_;},
        res5_073 = caml_call2(Incremental_Types[15][1], _cO_, arg5_067);
       return [1,
               [0,
                _S_,
                [0,
                 res0_068,
                 [0,
                  res1_069,
                  [0,
                   res2_070,
                   [0, res3_071, [0, res4_072, [0, res5_073, 0]]]]]]]];
      case 21:
       var
        arg6_080 = param[7],
        arg5_079 = param[6],
        arg4_078 = param[5],
        arg3_077 = param[4],
        arg2_076 = param[3],
        arg1_075 = param[2],
        _cP_ = function(_eL_){return 0;},
        res0_081 = caml_call1(Sexplib0_Sexp_conv[24], _cP_),
        _cQ_ = function(param){return _T_;},
        res1_082 = caml_call2(Incremental_Types[15][1], _cQ_, arg1_075),
        _cR_ = function(param){return _U_;},
        res2_083 = caml_call2(Incremental_Types[15][1], _cR_, arg2_076),
        _cS_ = function(param){return _V_;},
        res3_084 = caml_call2(Incremental_Types[15][1], _cS_, arg3_077),
        _cT_ = function(param){return _W_;},
        res4_085 = caml_call2(Incremental_Types[15][1], _cT_, arg4_078),
        _cU_ = function(param){return _X_;},
        res5_086 = caml_call2(Incremental_Types[15][1], _cU_, arg5_079),
        _cV_ = function(param){return _Y_;},
        res6_087 = caml_call2(Incremental_Types[15][1], _cV_, arg6_080);
       return [1,
               [0,
                _Z_,
                [0,
                 res0_081,
                 [0,
                  res1_082,
                  [0,
                   res2_083,
                   [0,
                    res3_084,
                    [0, res4_085, [0, res5_086, [0, res6_087, 0]]]]]]]]];
      case 22:
       var
        arg7_095 = param[8],
        arg6_094 = param[7],
        arg5_093 = param[6],
        arg4_092 = param[5],
        arg3_091 = param[4],
        arg2_090 = param[3],
        arg1_089 = param[2],
        _cW_ = function(_eK_){return 0;},
        res0_096 = caml_call1(Sexplib0_Sexp_conv[24], _cW_),
        _cX_ = function(param){return ___;},
        res1_097 = caml_call2(Incremental_Types[15][1], _cX_, arg1_089),
        _cY_ = function(param){return _$_;},
        res2_098 = caml_call2(Incremental_Types[15][1], _cY_, arg2_090),
        _cZ_ = function(param){return _aa_;},
        res3_099 = caml_call2(Incremental_Types[15][1], _cZ_, arg3_091),
        _c0_ = function(param){return _ab_;},
        res4_100 = caml_call2(Incremental_Types[15][1], _c0_, arg4_092),
        _c1_ = function(param){return _ac_;},
        res5_101 = caml_call2(Incremental_Types[15][1], _c1_, arg5_093),
        _c2_ = function(param){return _ad_;},
        res6_102 = caml_call2(Incremental_Types[15][1], _c2_, arg6_094),
        _c3_ = function(param){return _ae_;},
        res7_103 = caml_call2(Incremental_Types[15][1], _c3_, arg7_095);
       return [1,
               [0,
                _af_,
                [0,
                 res0_096,
                 [0,
                  res1_097,
                  [0,
                   res2_098,
                   [0,
                    res3_099,
                    [0,
                     res4_100,
                     [0, res5_101, [0, res6_102, [0, res7_103, 0]]]]]]]]]];
      case 23:
       var
        arg8_112 = param[9],
        arg7_111 = param[8],
        arg6_110 = param[7],
        arg5_109 = param[6],
        arg4_108 = param[5],
        arg3_107 = param[4],
        arg2_106 = param[3],
        arg1_105 = param[2],
        _c4_ = function(_eJ_){return 0;},
        res0_113 = caml_call1(Sexplib0_Sexp_conv[24], _c4_),
        _c5_ = function(param){return _ag_;},
        res1_114 = caml_call2(Incremental_Types[15][1], _c5_, arg1_105),
        _c6_ = function(param){return _ah_;},
        res2_115 = caml_call2(Incremental_Types[15][1], _c6_, arg2_106),
        _c7_ = function(param){return _ai_;},
        res3_116 = caml_call2(Incremental_Types[15][1], _c7_, arg3_107),
        _c8_ = function(param){return _aj_;},
        res4_117 = caml_call2(Incremental_Types[15][1], _c8_, arg4_108),
        _c9_ = function(param){return _ak_;},
        res5_118 = caml_call2(Incremental_Types[15][1], _c9_, arg5_109),
        _c__ = function(param){return _al_;},
        res6_119 = caml_call2(Incremental_Types[15][1], _c__, arg6_110),
        _c$_ = function(param){return _am_;},
        res7_120 = caml_call2(Incremental_Types[15][1], _c$_, arg7_111),
        _da_ = function(param){return _an_;},
        res8_121 = caml_call2(Incremental_Types[15][1], _da_, arg8_112);
       return [1,
               [0,
                _ao_,
                [0,
                 res0_113,
                 [0,
                  res1_114,
                  [0,
                   res2_115,
                   [0,
                    res3_116,
                    [0,
                     res4_117,
                     [0,
                      res5_118,
                      [0, res6_119, [0, res7_120, [0, res8_121, 0]]]]]]]]]]];
      case 24:
       var
        arg9_131 = param[10],
        arg8_130 = param[9],
        arg7_129 = param[8],
        arg6_128 = param[7],
        arg5_127 = param[6],
        arg4_126 = param[5],
        arg3_125 = param[4],
        arg2_124 = param[3],
        arg1_123 = param[2],
        _db_ = function(_eI_){return 0;},
        res0_132 = caml_call1(Sexplib0_Sexp_conv[24], _db_),
        _dc_ = function(param){return _ap_;},
        res1_133 = caml_call2(Incremental_Types[15][1], _dc_, arg1_123),
        _dd_ = function(param){return _aq_;},
        res2_134 = caml_call2(Incremental_Types[15][1], _dd_, arg2_124),
        _de_ = function(param){return _ar_;},
        res3_135 = caml_call2(Incremental_Types[15][1], _de_, arg3_125),
        _df_ = function(param){return _as_;},
        res4_136 = caml_call2(Incremental_Types[15][1], _df_, arg4_126),
        _dg_ = function(param){return _at_;},
        res5_137 = caml_call2(Incremental_Types[15][1], _dg_, arg5_127),
        _dh_ = function(param){return _au_;},
        res6_138 = caml_call2(Incremental_Types[15][1], _dh_, arg6_128),
        _di_ = function(param){return _av_;},
        res7_139 = caml_call2(Incremental_Types[15][1], _di_, arg7_129),
        _dj_ = function(param){return _aw_;},
        res8_140 = caml_call2(Incremental_Types[15][1], _dj_, arg8_130),
        _dk_ = function(param){return _ax_;},
        res9_141 = caml_call2(Incremental_Types[15][1], _dk_, arg9_131);
       return [1,
               [0,
                _ay_,
                [0,
                 res0_132,
                 [0,
                  res1_133,
                  [0,
                   res2_134,
                   [0,
                    res3_135,
                    [0,
                     res4_136,
                     [0,
                      res5_137,
                      [0,
                       res6_138,
                       [0, res7_139, [0, res8_140, [0, res9_141, 0]]]]]]]]]]]];
      case 25:
       var
        arg10_152 = param[11],
        arg9_151 = param[10],
        arg8_150 = param[9],
        arg7_149 = param[8],
        arg6_148 = param[7],
        arg5_147 = param[6],
        arg4_146 = param[5],
        arg3_145 = param[4],
        arg2_144 = param[3],
        arg1_143 = param[2],
        _dl_ = function(_eH_){return 0;},
        res0_153 = caml_call1(Sexplib0_Sexp_conv[24], _dl_),
        _dm_ = function(param){return _az_;},
        res1_154 = caml_call2(Incremental_Types[15][1], _dm_, arg1_143),
        _dn_ = function(param){return _aA_;},
        res2_155 = caml_call2(Incremental_Types[15][1], _dn_, arg2_144),
        _do_ = function(param){return _aB_;},
        res3_156 = caml_call2(Incremental_Types[15][1], _do_, arg3_145),
        _dp_ = function(param){return _aC_;},
        res4_157 = caml_call2(Incremental_Types[15][1], _dp_, arg4_146),
        _dq_ = function(param){return _aD_;},
        res5_158 = caml_call2(Incremental_Types[15][1], _dq_, arg5_147),
        _dr_ = function(param){return _aE_;},
        res6_159 = caml_call2(Incremental_Types[15][1], _dr_, arg6_148),
        _ds_ = function(param){return _aF_;},
        res7_160 = caml_call2(Incremental_Types[15][1], _ds_, arg7_149),
        _dt_ = function(param){return _aG_;},
        res8_161 = caml_call2(Incremental_Types[15][1], _dt_, arg8_150),
        _du_ = function(param){return _aH_;},
        res9_162 = caml_call2(Incremental_Types[15][1], _du_, arg9_151),
        _dv_ = function(param){return _aI_;},
        res10_163 = caml_call2(Incremental_Types[15][1], _dv_, arg10_152);
       return [1,
               [0,
                _aJ_,
                [0,
                 res0_153,
                 [0,
                  res1_154,
                  [0,
                   res2_155,
                   [0,
                    res3_156,
                    [0,
                     res4_157,
                     [0,
                      res5_158,
                      [0,
                       res6_159,
                       [0,
                        res7_160,
                        [0, res8_161, [0, res9_162, [0, res10_163, 0]]]]]]]]]]]]];
      case 26:
       var
        arg11_175 = param[12],
        arg10_174 = param[11],
        arg9_173 = param[10],
        arg8_172 = param[9],
        arg7_171 = param[8],
        arg6_170 = param[7],
        arg5_169 = param[6],
        arg4_168 = param[5],
        arg3_167 = param[4],
        arg2_166 = param[3],
        arg1_165 = param[2],
        _dw_ = function(_eG_){return 0;},
        res0_176 = caml_call1(Sexplib0_Sexp_conv[24], _dw_),
        _dx_ = function(param){return _aK_;},
        res1_177 = caml_call2(Incremental_Types[15][1], _dx_, arg1_165),
        _dy_ = function(param){return _aL_;},
        res2_178 = caml_call2(Incremental_Types[15][1], _dy_, arg2_166),
        _dz_ = function(param){return _aM_;},
        res3_179 = caml_call2(Incremental_Types[15][1], _dz_, arg3_167),
        _dA_ = function(param){return _aN_;},
        res4_180 = caml_call2(Incremental_Types[15][1], _dA_, arg4_168),
        _dB_ = function(param){return _aO_;},
        res5_181 = caml_call2(Incremental_Types[15][1], _dB_, arg5_169),
        _dC_ = function(param){return _aP_;},
        res6_182 = caml_call2(Incremental_Types[15][1], _dC_, arg6_170),
        _dD_ = function(param){return _aQ_;},
        res7_183 = caml_call2(Incremental_Types[15][1], _dD_, arg7_171),
        _dE_ = function(param){return _aR_;},
        res8_184 = caml_call2(Incremental_Types[15][1], _dE_, arg8_172),
        _dF_ = function(param){return _aS_;},
        res9_185 = caml_call2(Incremental_Types[15][1], _dF_, arg9_173),
        _dG_ = function(param){return _aT_;},
        res10_186 = caml_call2(Incremental_Types[15][1], _dG_, arg10_174),
        _dH_ = function(param){return _aU_;},
        res11_187 = caml_call2(Incremental_Types[15][1], _dH_, arg11_175);
       return [1,
               [0,
                _aV_,
                [0,
                 res0_176,
                 [0,
                  res1_177,
                  [0,
                   res2_178,
                   [0,
                    res3_179,
                    [0,
                     res4_180,
                     [0,
                      res5_181,
                      [0,
                       res6_182,
                       [0,
                        res7_183,
                        [0,
                         res8_184,
                         [0, res9_185, [0, res10_186, [0, res11_187, 0]]]]]]]]]]]]]];
      case 27:
       var
        arg12_200 = param[13],
        arg11_199 = param[12],
        arg10_198 = param[11],
        arg9_197 = param[10],
        arg8_196 = param[9],
        arg7_195 = param[8],
        arg6_194 = param[7],
        arg5_193 = param[6],
        arg4_192 = param[5],
        arg3_191 = param[4],
        arg2_190 = param[3],
        arg1_189 = param[2],
        _dI_ = function(_eF_){return 0;},
        res0_201 = caml_call1(Sexplib0_Sexp_conv[24], _dI_),
        _dJ_ = function(param){return _aW_;},
        res1_202 = caml_call2(Incremental_Types[15][1], _dJ_, arg1_189),
        _dK_ = function(param){return _aX_;},
        res2_203 = caml_call2(Incremental_Types[15][1], _dK_, arg2_190),
        _dL_ = function(param){return _aY_;},
        res3_204 = caml_call2(Incremental_Types[15][1], _dL_, arg3_191),
        _dM_ = function(param){return _aZ_;},
        res4_205 = caml_call2(Incremental_Types[15][1], _dM_, arg4_192),
        _dN_ = function(param){return _a0_;},
        res5_206 = caml_call2(Incremental_Types[15][1], _dN_, arg5_193),
        _dO_ = function(param){return _a1_;},
        res6_207 = caml_call2(Incremental_Types[15][1], _dO_, arg6_194),
        _dP_ = function(param){return _a2_;},
        res7_208 = caml_call2(Incremental_Types[15][1], _dP_, arg7_195),
        _dQ_ = function(param){return _a3_;},
        res8_209 = caml_call2(Incremental_Types[15][1], _dQ_, arg8_196),
        _dR_ = function(param){return _a4_;},
        res9_210 = caml_call2(Incremental_Types[15][1], _dR_, arg9_197),
        _dS_ = function(param){return _a5_;},
        res10_211 = caml_call2(Incremental_Types[15][1], _dS_, arg10_198),
        _dT_ = function(param){return _a6_;},
        res11_212 = caml_call2(Incremental_Types[15][1], _dT_, arg11_199),
        _dU_ = function(param){return _a7_;},
        res12_213 = caml_call2(Incremental_Types[15][1], _dU_, arg12_200);
       return [1,
               [0,
                _a8_,
                [0,
                 res0_201,
                 [0,
                  res1_202,
                  [0,
                   res2_203,
                   [0,
                    res3_204,
                    [0,
                     res4_205,
                     [0,
                      res5_206,
                      [0,
                       res6_207,
                       [0,
                        res7_208,
                        [0,
                         res8_209,
                         [0,
                          res9_210,
                          [0, res10_211, [0, res11_212, [0, res12_213, 0]]]]]]]]]]]]]]];
      case 28:
       var
        arg13_227 = param[14],
        arg12_226 = param[13],
        arg11_225 = param[12],
        arg10_224 = param[11],
        arg9_223 = param[10],
        arg8_222 = param[9],
        arg7_221 = param[8],
        arg6_220 = param[7],
        arg5_219 = param[6],
        arg4_218 = param[5],
        arg3_217 = param[4],
        arg2_216 = param[3],
        arg1_215 = param[2],
        _dV_ = function(_eE_){return 0;},
        res0_228 = caml_call1(Sexplib0_Sexp_conv[24], _dV_),
        _dW_ = function(param){return _a9_;},
        res1_229 = caml_call2(Incremental_Types[15][1], _dW_, arg1_215),
        _dX_ = function(param){return _a__;},
        res2_230 = caml_call2(Incremental_Types[15][1], _dX_, arg2_216),
        _dY_ = function(param){return _a$_;},
        res3_231 = caml_call2(Incremental_Types[15][1], _dY_, arg3_217),
        _dZ_ = function(param){return _ba_;},
        res4_232 = caml_call2(Incremental_Types[15][1], _dZ_, arg4_218),
        _d0_ = function(param){return _bb_;},
        res5_233 = caml_call2(Incremental_Types[15][1], _d0_, arg5_219),
        _d1_ = function(param){return _bc_;},
        res6_234 = caml_call2(Incremental_Types[15][1], _d1_, arg6_220),
        _d2_ = function(param){return _bd_;},
        res7_235 = caml_call2(Incremental_Types[15][1], _d2_, arg7_221),
        _d3_ = function(param){return _be_;},
        res8_236 = caml_call2(Incremental_Types[15][1], _d3_, arg8_222),
        _d4_ = function(param){return _bf_;},
        res9_237 = caml_call2(Incremental_Types[15][1], _d4_, arg9_223),
        _d5_ = function(param){return _bg_;},
        res10_238 = caml_call2(Incremental_Types[15][1], _d5_, arg10_224),
        _d6_ = function(param){return _bh_;},
        res11_239 = caml_call2(Incremental_Types[15][1], _d6_, arg11_225),
        _d7_ = function(param){return _bi_;},
        res12_240 = caml_call2(Incremental_Types[15][1], _d7_, arg12_226),
        _d8_ = function(param){return _bj_;},
        res13_241 = caml_call2(Incremental_Types[15][1], _d8_, arg13_227);
       return [1,
               [0,
                _bk_,
                [0,
                 res0_228,
                 [0,
                  res1_229,
                  [0,
                   res2_230,
                   [0,
                    res3_231,
                    [0,
                     res4_232,
                     [0,
                      res5_233,
                      [0,
                       res6_234,
                       [0,
                        res7_235,
                        [0,
                         res8_236,
                         [0,
                          res9_237,
                          [0,
                           res10_238,
                           [0, res11_239, [0, res12_240, [0, res13_241, 0]]]]]]]]]]]]]]]];
      case 29:
       var
        arg14_256 = param[15],
        arg13_255 = param[14],
        arg12_254 = param[13],
        arg11_253 = param[12],
        arg10_252 = param[11],
        arg9_251 = param[10],
        arg8_250 = param[9],
        arg7_249 = param[8],
        arg6_248 = param[7],
        arg5_247 = param[6],
        arg4_246 = param[5],
        arg3_245 = param[4],
        arg2_244 = param[3],
        arg1_243 = param[2],
        _d9_ = function(_eD_){return 0;},
        res0_257 = caml_call1(Sexplib0_Sexp_conv[24], _d9_),
        _d__ = function(param){return _bl_;},
        res1_258 = caml_call2(Incremental_Types[15][1], _d__, arg1_243),
        _d$_ = function(param){return _bm_;},
        res2_259 = caml_call2(Incremental_Types[15][1], _d$_, arg2_244),
        _ea_ = function(param){return _bn_;},
        res3_260 = caml_call2(Incremental_Types[15][1], _ea_, arg3_245),
        _eb_ = function(param){return _bo_;},
        res4_261 = caml_call2(Incremental_Types[15][1], _eb_, arg4_246),
        _ec_ = function(param){return _bp_;},
        res5_262 = caml_call2(Incremental_Types[15][1], _ec_, arg5_247),
        _ed_ = function(param){return _bq_;},
        res6_263 = caml_call2(Incremental_Types[15][1], _ed_, arg6_248),
        _ee_ = function(param){return _br_;},
        res7_264 = caml_call2(Incremental_Types[15][1], _ee_, arg7_249),
        _ef_ = function(param){return _bs_;},
        res8_265 = caml_call2(Incremental_Types[15][1], _ef_, arg8_250),
        _eg_ = function(param){return _bt_;},
        res9_266 = caml_call2(Incremental_Types[15][1], _eg_, arg9_251),
        _eh_ = function(param){return _bu_;},
        res10_267 = caml_call2(Incremental_Types[15][1], _eh_, arg10_252),
        _ei_ = function(param){return _bv_;},
        res11_268 = caml_call2(Incremental_Types[15][1], _ei_, arg11_253),
        _ej_ = function(param){return _bw_;},
        res12_269 = caml_call2(Incremental_Types[15][1], _ej_, arg12_254),
        _ek_ = function(param){return _bx_;},
        res13_270 = caml_call2(Incremental_Types[15][1], _ek_, arg13_255),
        _el_ = function(param){return _by_;},
        res14_271 = caml_call2(Incremental_Types[15][1], _el_, arg14_256);
       return [1,
               [0,
                _bz_,
                [0,
                 res0_257,
                 [0,
                  res1_258,
                  [0,
                   res2_259,
                   [0,
                    res3_260,
                    [0,
                     res4_261,
                     [0,
                      res5_262,
                      [0,
                       res6_263,
                       [0,
                        res7_264,
                        [0,
                         res8_265,
                         [0,
                          res9_266,
                          [0,
                           res10_267,
                           [0,
                            res11_268,
                            [0, res12_269, [0, res13_270, [0, res14_271, 0]]]]]]]]]]]]]]]]];
      default:
       var
        arg15_287 = param[16],
        arg14_286 = param[15],
        arg13_285 = param[14],
        arg12_284 = param[13],
        arg11_283 = param[12],
        arg10_282 = param[11],
        arg9_281 = param[10],
        arg8_280 = param[9],
        arg7_279 = param[8],
        arg6_278 = param[7],
        arg5_277 = param[6],
        arg4_276 = param[5],
        arg3_275 = param[4],
        arg2_274 = param[3],
        arg1_273 = param[2],
        _em_ = function(_eC_){return 0;},
        res0_288 = caml_call1(Sexplib0_Sexp_conv[24], _em_),
        _en_ = function(param){return _bA_;},
        res1_289 = caml_call2(Incremental_Types[15][1], _en_, arg1_273),
        _eo_ = function(param){return _bB_;},
        res2_290 = caml_call2(Incremental_Types[15][1], _eo_, arg2_274),
        _ep_ = function(param){return _bC_;},
        res3_291 = caml_call2(Incremental_Types[15][1], _ep_, arg3_275),
        _eq_ = function(param){return _bD_;},
        res4_292 = caml_call2(Incremental_Types[15][1], _eq_, arg4_276),
        _er_ = function(param){return _bE_;},
        res5_293 = caml_call2(Incremental_Types[15][1], _er_, arg5_277),
        _es_ = function(param){return _bF_;},
        res6_294 = caml_call2(Incremental_Types[15][1], _es_, arg6_278),
        _et_ = function(param){return _bG_;},
        res7_295 = caml_call2(Incremental_Types[15][1], _et_, arg7_279),
        _eu_ = function(param){return _bH_;},
        res8_296 = caml_call2(Incremental_Types[15][1], _eu_, arg8_280),
        _ev_ = function(param){return _bI_;},
        res9_297 = caml_call2(Incremental_Types[15][1], _ev_, arg9_281),
        _ew_ = function(param){return _bJ_;},
        res10_298 = caml_call2(Incremental_Types[15][1], _ew_, arg10_282),
        _ex_ = function(param){return _bK_;},
        res11_299 = caml_call2(Incremental_Types[15][1], _ex_, arg11_283),
        _ey_ = function(param){return _bL_;},
        res12_300 = caml_call2(Incremental_Types[15][1], _ey_, arg12_284),
        _ez_ = function(param){return _bM_;},
        res13_301 = caml_call2(Incremental_Types[15][1], _ez_, arg13_285),
        _eA_ = function(param){return _bN_;},
        res14_302 = caml_call2(Incremental_Types[15][1], _eA_, arg14_286),
        _eB_ = function(param){return _bO_;},
        res15_303 = caml_call2(Incremental_Types[15][1], _eB_, arg15_287);
       return [1,
               [0,
                _bP_,
                [0,
                 res0_288,
                 [0,
                  res1_289,
                  [0,
                   res2_290,
                   [0,
                    res3_291,
                    [0,
                     res4_292,
                     [0,
                      res5_293,
                      [0,
                       res6_294,
                       [0,
                        res7_295,
                        [0,
                         res8_296,
                         [0,
                          res9_297,
                          [0,
                           res10_298,
                           [0,
                            res11_299,
                            [0,
                             res12_300,
                             [0, res13_301, [0, res14_302, [0, res15_303, 0]]]]]]]]]]]]]]]]]];
    }
   }
   function name(param){
    if(typeof param === "number")
     return 0 === param ? cst_Invalid : cst_Uninitialized;
    switch(param[0]){
      case 0:
       return cst_Array_fold;
      case 1:
       return cst_At;
      case 2:
       return cst_At_intervals;
      case 3:
       return cst_Bind_lhs_change;
      case 4:
       return cst_Bind_main;
      case 5:
       return cst_Const;
      case 6:
       return cst_Expert;
      case 7:
       return cst_Freeze;
      case 8:
       return cst_If_test_change;
      case 9:
       return cst_If_then_else;
      case 10:
       return cst_Join_lhs_change;
      case 11:
       return cst_Join_main;
      case 12:
       return cst_Map;
      case 13:
       return cst_Snapshot;
      case 14:
       return cst_Step_function;
      case 15:
       return cst_Unordered_array_fold;
      case 16:
       return cst_Var;
      case 17:
       return cst_Map2;
      case 18:
       return cst_Map3;
      case 19:
       return cst_Map4;
      case 20:
       return cst_Map5;
      case 21:
       return cst_Map6;
      case 22:
       return cst_Map7;
      case 23:
       return cst_Map8;
      case 24:
       return cst_Map9;
      case 25:
       return cst_Map10;
      case 26:
       return cst_Map11;
      case 27:
       return cst_Map12;
      case 28:
       return cst_Map13;
      case 29:
       return cst_Map14;
      default: return cst_Map15;
    }
   }
   function invariant(invariant_a, t){
    if(typeof t === "number") return 0 === t ? 0 : 0;
    switch(t[0]){
      case 0:
       var array_fold = t[1], _b__ = function(_cn_){return 0;};
       return caml_call3
               (Incremental_Array_fold[2], _b__, invariant_a, array_fold);
      case 1:
       var at = t[1]; return caml_call1(Incremental_At[1], at);
      case 2:
       var at_intervals = t[1];
       return caml_call1(Incremental_At_intervals[1], at_intervals);
      case 3:
       var
        bind = t[1],
        _b$_ = function(_cm_){return 0;},
        _ca_ = function(_cl_){return 0;};
       return caml_call3(Incremental_Bind[1], _ca_, _b$_, bind);
      case 4:
       var bind$0 = t[1], _cb_ = function(_ck_){return 0;};
       return caml_call3(Incremental_Bind[1], _cb_, invariant_a, bind$0);
      case 5:
       var a = t[1]; return caml_call1(invariant_a, a);
      case 6:
       var e = t[1]; return caml_call2(Incremental_Expert[1], invariant_a, e);
      case 7:
       var freeze = t[1];
       return caml_call2(Incremental_Freeze[1], invariant_a, freeze);
      case 8:
       var if_then_else = t[1], _cc_ = function(_cj_){return 0;};
       return caml_call2(Incremental_If_then_else[1], _cc_, if_then_else);
      case 9:
       var if_then_else$0 = t[1];
       return caml_call2
               (Incremental_If_then_else[1], invariant_a, if_then_else$0);
      case 10:
       var join = t[1], _cd_ = function(_ci_){return 0;};
       return caml_call2(Incremental_Join[1], _cd_, join);
      case 11:
       var join$0 = t[1];
       return caml_call2(Incremental_Join[1], invariant_a, join$0);
      case 13:
       var snapshot = t[1];
       return caml_call2(Incremental_Snapshot[1], invariant_a, snapshot);
      case 14:
       var step_function_node = t[1];
       return caml_call2
               (Incremental_Step_function_node[1],
                invariant_a,
                step_function_node);
      case 15:
       var unordered_array_fold = t[1], _ce_ = function(_ch_){return 0;};
       return caml_call3
               (Incremental_Unordered_array_fo[1],
                _ce_,
                invariant_a,
                unordered_array_fold);
      case 16:
       var var$0 = t[1], _cf_ = function(_cg_){return 0;};
       return caml_call2(Incremental_Var[1], _cf_, var$0);
      default: return 0;
    }
   }
   function initial_num_children(t){
    if(typeof t === "number") return 0 === t ? 0 : 0;
    switch(t[0]){
      case 0:
       var children = t[1][3]; return children.length - 1;
      case 1:
       return 0;
      case 2:
       return 0;
      case 3:
       return 1;
      case 4:
       return 2;
      case 5:
       return 0;
      case 6:
       return 0;
      case 7:
       return 1;
      case 8:
       return 1;
      case 9:
       return 2;
      case 10:
       return 1;
      case 11:
       return 2;
      case 12:
       return 1;
      case 13:
       return 0;
      case 14:
       return 1;
      case 15:
       var children$0 = t[1][6]; return children$0.length - 1;
      case 16:
       return 0;
      case 17:
       return 2;
      case 18:
       return 3;
      case 19:
       return 4;
      case 20:
       return 5;
      case 21:
       return 6;
      case 22:
       return 7;
      case 23:
       return 8;
      case 24:
       return 9;
      case 25:
       return 10;
      case 26:
       return 11;
      case 27:
       return 12;
      case 28:
       return 13;
      case 29:
       return 14;
      default: return 15;
    }
   }
   var
    bind_rhs_child_index = 1,
    freeze_child_index = 0,
    if_branch_child_index = 1,
    join_rhs_child_index = 1;
   function iteri_children(t, f){
    if(typeof t === "number") return 0 === t ? 0 : 0;
    switch(t[0]){
      case 0:
       var children = t[1][3], _bX_ = children.length - 1 - 1 | 0, _bW_ = 0;
       if(_bX_ >= 0){
        var i = _bW_;
        for(;;){
         caml_call2(f, i, children[1 + i]);
         var _bY_ = i + 1 | 0;
         if(_bX_ === i) break;
         var i = _bY_;
        }
       }
       return 0;
      case 1:
       return 0;
      case 2:
       return 0;
      case 3:
       var bind = t[1]; return caml_call2(f, 0, bind[3]);
      case 4:
       var match = t[1], lhs_change = match[4], rhs = match[5];
       caml_call2(f, 0, lhs_change);
       var _bZ_ = caml_call1(Incremental_Import[6][8], rhs);
       return _bZ_
               ? caml_call2(f, 1, caml_call1(Incremental_Import[6][16], rhs))
               : _bZ_;
      case 5:
       return 0;
      case 6:
       var
        match$0 = t[1],
        children$0 = match$0[3],
        num_children = match$0[4],
        _b1_ = num_children - 1 | 0,
        _b0_ = 0;
       if(_b1_ >= 0){
        var i$0 = _b0_;
        for(;;){
         var _b2_ = caml_call2(Incremental_Import[7][21], children$0, i$0);
         caml_call2(f, i$0, caml_call1(Incremental_Import[6][9], _b2_)[1]);
         var _b3_ = i$0 + 1 | 0;
         if(_b1_ === i$0) break;
         var i$0 = _b3_;
        }
       }
       return 0;
      case 7:
       var child = t[1][2]; return caml_call2(f, 0, child);
      case 8:
       var test = t[1][2]; return caml_call2(f, 0, test);
      case 9:
       var
        match$1 = t[1],
        test_change = match$1[3],
        current_branch = match$1[4];
       caml_call2(f, 0, test_change);
       var _b4_ = caml_call1(Incremental_Import[6][8], current_branch);
       return _b4_
               ? caml_call2
                 (f, 1, caml_call1(Incremental_Import[6][16], current_branch))
               : _b4_;
      case 10:
       var lhs = t[1][2]; return caml_call2(f, 0, lhs);
      case 11:
       var match$2 = t[1], lhs_change$0 = match$2[3], rhs$0 = match$2[4];
       caml_call2(f, 0, lhs_change$0);
       var _b5_ = caml_call1(Incremental_Import[6][8], rhs$0);
       return _b5_
               ? caml_call2
                 (f, 1, caml_call1(Incremental_Import[6][16], rhs$0))
               : _b5_;
      case 12:
       var node0 = t[2]; return caml_call2(f, 0, node0);
      case 13:
       return 0;
      case 14:
       var
        child$0 = t[1][2],
        _b6_ = caml_call1(Incremental_Import[6][8], child$0);
       return _b6_
               ? caml_call2
                 (f, 0, caml_call1(Incremental_Import[6][16], child$0))
               : _b6_;
      case 15:
       var
        children$1 = t[1][6],
        _b8_ = children$1.length - 1 - 1 | 0,
        _b7_ = 0;
       if(_b8_ >= 0){
        var i$1 = _b7_;
        for(;;){
         caml_call2(f, i$1, children$1[1 + i$1]);
         var _b9_ = i$1 + 1 | 0;
         if(_b8_ === i$1) break;
         var i$1 = _b9_;
        }
       }
       return 0;
      case 16:
       return 0;
      case 17:
       var node1 = t[3], node0$0 = t[2];
       caml_call2(f, 0, node0$0);
       return caml_call2(f, 1, node1);
      case 18:
       var node2 = t[4], node1$0 = t[3], node0$1 = t[2];
       caml_call2(f, 0, node0$1);
       caml_call2(f, 1, node1$0);
       return caml_call2(f, 2, node2);
      case 19:
       var node3 = t[5], node2$0 = t[4], node1$1 = t[3], node0$2 = t[2];
       caml_call2(f, 0, node0$2);
       caml_call2(f, 1, node1$1);
       caml_call2(f, 2, node2$0);
       return caml_call2(f, 3, node3);
      case 20:
       var
        node4 = t[6],
        node3$0 = t[5],
        node2$1 = t[4],
        node1$2 = t[3],
        node0$3 = t[2];
       caml_call2(f, 0, node0$3);
       caml_call2(f, 1, node1$2);
       caml_call2(f, 2, node2$1);
       caml_call2(f, 3, node3$0);
       return caml_call2(f, 4, node4);
      case 21:
       var
        node5 = t[7],
        node4$0 = t[6],
        node3$1 = t[5],
        node2$2 = t[4],
        node1$3 = t[3],
        node0$4 = t[2];
       caml_call2(f, 0, node0$4);
       caml_call2(f, 1, node1$3);
       caml_call2(f, 2, node2$2);
       caml_call2(f, 3, node3$1);
       caml_call2(f, 4, node4$0);
       return caml_call2(f, 5, node5);
      case 22:
       var
        node6 = t[8],
        node5$0 = t[7],
        node4$1 = t[6],
        node3$2 = t[5],
        node2$3 = t[4],
        node1$4 = t[3],
        node0$5 = t[2];
       caml_call2(f, 0, node0$5);
       caml_call2(f, 1, node1$4);
       caml_call2(f, 2, node2$3);
       caml_call2(f, 3, node3$2);
       caml_call2(f, 4, node4$1);
       caml_call2(f, 5, node5$0);
       return caml_call2(f, 6, node6);
      case 23:
       var
        node7 = t[9],
        node6$0 = t[8],
        node5$1 = t[7],
        node4$2 = t[6],
        node3$3 = t[5],
        node2$4 = t[4],
        node1$5 = t[3],
        node0$6 = t[2];
       caml_call2(f, 0, node0$6);
       caml_call2(f, 1, node1$5);
       caml_call2(f, 2, node2$4);
       caml_call2(f, 3, node3$3);
       caml_call2(f, 4, node4$2);
       caml_call2(f, 5, node5$1);
       caml_call2(f, 6, node6$0);
       return caml_call2(f, 7, node7);
      case 24:
       var
        node8 = t[10],
        node7$0 = t[9],
        node6$1 = t[8],
        node5$2 = t[7],
        node4$3 = t[6],
        node3$4 = t[5],
        node2$5 = t[4],
        node1$6 = t[3],
        node0$7 = t[2];
       caml_call2(f, 0, node0$7);
       caml_call2(f, 1, node1$6);
       caml_call2(f, 2, node2$5);
       caml_call2(f, 3, node3$4);
       caml_call2(f, 4, node4$3);
       caml_call2(f, 5, node5$2);
       caml_call2(f, 6, node6$1);
       caml_call2(f, 7, node7$0);
       return caml_call2(f, 8, node8);
      case 25:
       var
        node9 = t[11],
        node8$0 = t[10],
        node7$1 = t[9],
        node6$2 = t[8],
        node5$3 = t[7],
        node4$4 = t[6],
        node3$5 = t[5],
        node2$6 = t[4],
        node1$7 = t[3],
        node0$8 = t[2];
       caml_call2(f, 0, node0$8);
       caml_call2(f, 1, node1$7);
       caml_call2(f, 2, node2$6);
       caml_call2(f, 3, node3$5);
       caml_call2(f, 4, node4$4);
       caml_call2(f, 5, node5$3);
       caml_call2(f, 6, node6$2);
       caml_call2(f, 7, node7$1);
       caml_call2(f, 8, node8$0);
       return caml_call2(f, 9, node9);
      case 26:
       var
        node10 = t[12],
        node9$0 = t[11],
        node8$1 = t[10],
        node7$2 = t[9],
        node6$3 = t[8],
        node5$4 = t[7],
        node4$5 = t[6],
        node3$6 = t[5],
        node2$7 = t[4],
        node1$8 = t[3],
        node0$9 = t[2];
       caml_call2(f, 0, node0$9);
       caml_call2(f, 1, node1$8);
       caml_call2(f, 2, node2$7);
       caml_call2(f, 3, node3$6);
       caml_call2(f, 4, node4$5);
       caml_call2(f, 5, node5$4);
       caml_call2(f, 6, node6$3);
       caml_call2(f, 7, node7$2);
       caml_call2(f, 8, node8$1);
       caml_call2(f, 9, node9$0);
       return caml_call2(f, 10, node10);
      case 27:
       var
        node11 = t[13],
        node10$0 = t[12],
        node9$1 = t[11],
        node8$2 = t[10],
        node7$3 = t[9],
        node6$4 = t[8],
        node5$5 = t[7],
        node4$6 = t[6],
        node3$7 = t[5],
        node2$8 = t[4],
        node1$9 = t[3],
        node0$10 = t[2];
       caml_call2(f, 0, node0$10);
       caml_call2(f, 1, node1$9);
       caml_call2(f, 2, node2$8);
       caml_call2(f, 3, node3$7);
       caml_call2(f, 4, node4$6);
       caml_call2(f, 5, node5$5);
       caml_call2(f, 6, node6$4);
       caml_call2(f, 7, node7$3);
       caml_call2(f, 8, node8$2);
       caml_call2(f, 9, node9$1);
       caml_call2(f, 10, node10$0);
       return caml_call2(f, 11, node11);
      case 28:
       var
        node12 = t[14],
        node11$0 = t[13],
        node10$1 = t[12],
        node9$2 = t[11],
        node8$3 = t[10],
        node7$4 = t[9],
        node6$5 = t[8],
        node5$6 = t[7],
        node4$7 = t[6],
        node3$8 = t[5],
        node2$9 = t[4],
        node1$10 = t[3],
        node0$11 = t[2];
       caml_call2(f, 0, node0$11);
       caml_call2(f, 1, node1$10);
       caml_call2(f, 2, node2$9);
       caml_call2(f, 3, node3$8);
       caml_call2(f, 4, node4$7);
       caml_call2(f, 5, node5$6);
       caml_call2(f, 6, node6$5);
       caml_call2(f, 7, node7$4);
       caml_call2(f, 8, node8$3);
       caml_call2(f, 9, node9$2);
       caml_call2(f, 10, node10$1);
       caml_call2(f, 11, node11$0);
       return caml_call2(f, 12, node12);
      case 29:
       var
        node13 = t[15],
        node12$0 = t[14],
        node11$1 = t[13],
        node10$2 = t[12],
        node9$3 = t[11],
        node8$4 = t[10],
        node7$5 = t[9],
        node6$6 = t[8],
        node5$7 = t[7],
        node4$8 = t[6],
        node3$9 = t[5],
        node2$10 = t[4],
        node1$11 = t[3],
        node0$12 = t[2];
       caml_call2(f, 0, node0$12);
       caml_call2(f, 1, node1$11);
       caml_call2(f, 2, node2$10);
       caml_call2(f, 3, node3$9);
       caml_call2(f, 4, node4$8);
       caml_call2(f, 5, node5$7);
       caml_call2(f, 6, node6$6);
       caml_call2(f, 7, node7$5);
       caml_call2(f, 8, node8$4);
       caml_call2(f, 9, node9$3);
       caml_call2(f, 10, node10$2);
       caml_call2(f, 11, node11$1);
       caml_call2(f, 12, node12$0);
       return caml_call2(f, 13, node13);
      default:
       var
        node14 = t[16],
        node13$0 = t[15],
        node12$1 = t[14],
        node11$2 = t[13],
        node10$3 = t[12],
        node9$4 = t[11],
        node8$5 = t[10],
        node7$6 = t[9],
        node6$7 = t[8],
        node5$8 = t[7],
        node4$9 = t[6],
        node3$10 = t[5],
        node2$11 = t[4],
        node1$12 = t[3],
        node0$13 = t[2];
       caml_call2(f, 0, node0$13);
       caml_call2(f, 1, node1$12);
       caml_call2(f, 2, node2$11);
       caml_call2(f, 3, node3$10);
       caml_call2(f, 4, node4$9);
       caml_call2(f, 5, node5$8);
       caml_call2(f, 6, node6$7);
       caml_call2(f, 7, node7$6);
       caml_call2(f, 8, node8$5);
       caml_call2(f, 9, node9$4);
       caml_call2(f, 10, node10$3);
       caml_call2(f, 11, node11$2);
       caml_call2(f, 12, node12$1);
       caml_call2(f, 13, node13$0);
       return caml_call2(f, 14, node14);
    }
   }
   function slow_get_child(t, index){
    if(typeof t !== "number")
     switch(t[0]){
       case 0:
        var children = t[1][3];
        return caml_check_bound(children, index)[1 + index];
       case 6:
        var
         children$0 = t[1][3],
         _bT_ = caml_call2(Incremental_Import[7][20], children$0, index);
        return caml_call1(Incremental_Import[6][9], _bT_)[1];
       case 15:
        var children$1 = t[1][6];
        return caml_check_bound(children$1, index)[1 + index];
     }
    function _bS_(r){
     iteri_children
      (t,
       function(i, child){
        var _bV_ = caml_call2(Core[90], i, index);
        return _bV_ ? caml_call1(r, child) : _bV_;
       });
     function _bU_(param){
      var
       arg1_306 = param[2],
       arg0_305 = param[1],
       res0_307 = caml_call1(Core[389], arg0_305),
       res1_308 = sexp_of_t(function(param){return _bQ_;}, arg1_306);
      return [1, [0, res0_307, [0, res1_308, 0]]];
     }
     return caml_call5
             (Core[247],
              0,
              _bR_,
              cst_Kind_slow_get_child_got_in,
              [0, index, t],
              _bU_);
    }
    return caml_call1(Core[268], _bS_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Kind);
   var
    Incremental_Kind =
      [0,
       invariant,
       sexp_of_t,
       name,
       initial_num_children,
       slow_get_child,
       bind_rhs_child_index,
       freeze_child_index,
       if_branch_child_index,
       join_rhs_child_index,
       iteri_children];
   runtime.caml_register_global(223, Incremental_Kind, cst_Incremental_Kind$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Node
//# unitInfo: Requires: Base__Backtrace, Base__Invariant, Core, Core__Hash_set, Core__Info, Core__Int, Core__List, Incremental__Cutoff, Incremental__Dot_user_info, Incremental__Expert, Incremental__Import, Incremental__Kind, Incremental__Node_id, Incremental__On_update_handler, Incremental__Scope, Incremental__Stabilization_num, Incremental__Types, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Node$0 = "Incremental__Node",
    cst = "_",
    cst_changed_at$0 = "changed_at",
    cst_created_in$0 = "created_in",
    cst_cutoff$0 = "cutoff",
    cst_height$0 = "height",
    cst_height_in_adjust_heights_h$0 = "height_in_adjust_heights_heap",
    cst_height_in_recompute_heap$0 = "height_in_recompute_heap",
    cst_id$0 = "id",
    cst_incremental$0 = "incremental",
    cst_kind$0 = "kind",
    cst_my_child_index_in_parent_a$0 = "my_child_index_in_parent_at_index",
    cst_my_parent_index_in_child_a$0 = "my_parent_index_in_child_at_index",
    cst_next_in_adjust_heights_hea$0 = "next_in_adjust_heights_heap",
    cst_next_in_recompute_heap$0 = "next_in_recompute_heap",
    cst_next_node_in_same_scope$0 = "next_node_in_same_scope",
    cst_num_on_update_handlers$0 = "num_on_update_handlers",
    cst_num_parents$0 = "num_parents",
    cst_observers$0 = "observers",
    cst_old_value_opt$0 = "old_value_opt",
    cst_parent0$0 = "parent0",
    cst_parent1_and_beyond$0 = "parent1_and_beyond",
    cst_prev_in_recompute_heap$0 = "prev_in_recompute_heap",
    cst_recomputed_at$0 = "recomputed_at",
    cst_src_node_ml = "src/node.ml",
    cst_value_opt$0 = "value_opt",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos$4 = "src/node.ml:329:27",
    pos$3 = "src/node.ml:341:24",
    pos$2 = "src/node.ml:347:22",
    pos$1 = "src/node.ml:407:29",
    pos$0 = "src/node.ml:423:26",
    pos = "src/node.ml:293:15",
    Core_Hash_set = global_data.Core__Hash_set,
    Incremental_Node_id = global_data.Incremental__Node_id,
    Core_List = global_data.Core__List,
    Incremental_Types = global_data.Incremental__Types,
    Core = global_data.Core,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_Kind = global_data.Incremental__Kind,
    Assert_failure = global_data.Assert_failure,
    Core_Int = global_data.Core__Int,
    Base_Backtrace = global_data.Base__Backtrace,
    Incremental_Stabilization_num = global_data.Incremental__Stabilization_num,
    Incremental_Cutoff = global_data.Incremental__Cutoff,
    Incremental_Scope = global_data.Incremental__Scope,
    Incremental_On_update_handler = global_data.Incremental__On_update_handler,
    Incremental_Expert = global_data.Incremental__Expert,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Dot_user_info = global_data.Incremental__Dot_user_info,
    Core_Info = global_data.Core__Info,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Node$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_node_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "node.ml");
   var
    _be_ = [0, cst],
    _bd_ = [0, cst_src_node_ml, 621, 4],
    _bc_ = [0, cst_src_node_ml, 622, 4],
    _bb_ = [0, cst_src_node_ml, 631, 4],
    _ba_ = [0, cst_src_node_ml, 633, 4],
    _a$_ = [0, cst_src_node_ml, 600, 16],
    _a__ = [0, cst_src_node_ml, 602, 16],
    _a9_ = [0, cst_src_node_ml, 556, 18],
    _a8_ = [0, cst_src_node_ml, 560, 16],
    _a7_ = [0, cst_src_node_ml, 549, 16],
    _a6_ = [0, cst_src_node_ml, 465, 12],
    _a4_ = [0, cst_src_node_ml, 484, 33],
    _a5_ = [0, cst_src_node_ml, 477, 14],
    _a2_ = [0, cst],
    cst_attempt_to_get_value_of_an = "attempt to get value of an invalid node",
    _a3_ = [0, cst_src_node_ml, 444, 18705, 18728],
    _a0_ = [0, cst],
    _aY_ = [0, cst_src_node_ml, 312, 50],
    _aX_ = [0, cst_src_node_ml, 326, 16],
    _aW_ = [0, cst_src_node_ml, 336, 11],
    _aV_ = [0, cst_src_node_ml, 337, 11],
    _aU_ = [0, cst_src_node_ml, 352, 16],
    _aS_ = [0, cst_src_node_ml, 355, 34],
    _aT_ = [0, cst_src_node_ml, 355, 60],
    _aR_ = [0, cst_src_node_ml, 358, 11],
    _aQ_ = [0, cst_src_node_ml, 359, 11],
    _aP_ = [0, cst_src_node_ml, 363, 16],
    _aO_ = [0, cst_src_node_ml, 367, 13],
    _aN_ = [0, cst_src_node_ml, 368, 13],
    _aM_ = [0, cst_src_node_ml, 372, 16],
    _aL_ = [0, cst_src_node_ml, 376, 13],
    _aK_ = [0, cst_src_node_ml, 377, 13],
    _aJ_ = [0, cst_src_node_ml, 381, 16],
    _aI_ = [0, cst_src_node_ml, 385, 16],
    _aH_ = [0, cst_src_node_ml, 389, 13],
    _aG_ = [0, cst_src_node_ml, 390, 13],
    _aF_ = [0, cst_src_node_ml, 395, 13],
    _aE_ = [0, cst_src_node_ml, 398, 37],
    _aD_ = [0, cst_src_node_ml, 420, 74],
    _aC_ = [0, cst_src_node_ml, 413, 15],
    _aB_ = [0, cst_src_node_ml, 434, 74],
    _aA_ = [0, cst_src_node_ml, 427, 13],
    _az_ = [0, cst_src_node_ml, 302, 6],
    _ay_ = [0, cst_src_node_ml, 303, 6],
    _ax_ = [0, cst_src_node_ml, 304, 6],
    _av_ = [0, cst_src_node_ml, 298, 8],
    _au_ = [0, cst_src_node_ml, 299, 8],
    _aZ_ = [0, cst_src_node_ml, 296, 6],
    _aw_ = [0, cst_src_node_ml, 300, 6],
    _a1_ = [0, cst_src_node_ml, 292, 11888, 11910],
    _at_ = [0, cst_src_node_ml, 235, 21],
    _as_ = [0, cst_src_node_ml, 145, 21],
    _S_ = [0, "creation_backtrace"],
    _T_ = [0, "user_info"],
    _U_ = [0, "force_necessary"],
    _V_ = [0, cst_my_child_index_in_parent_a$0],
    _W_ = [0, cst_my_parent_index_in_child_a$0],
    _X_ = [0, "on_update_handlers"],
    _Y_ = [0, "is_in_handle_after_stabilization"],
    _Z_ = [0, cst_observers$0],
    ___ = [0, cst_old_value_opt$0],
    _$_ = [0, cst_next_in_adjust_heights_hea$0],
    _aa_ = [0, cst_height_in_adjust_heights_h$0],
    _ab_ = [0, cst_next_in_recompute_heap$0],
    _ac_ = [0, cst_prev_in_recompute_heap$0],
    _ad_ = [0, cst_height_in_recompute_heap$0],
    _ae_ = [0, cst_height$0],
    _af_ = [0, cst_next_node_in_same_scope$0],
    _ag_ = [0, cst_created_in$0],
    _ah_ = [0, cst_parent0$0],
    _ai_ = [0, cst_parent1_and_beyond$0],
    _aj_ = [0, cst_num_parents$0],
    _ak_ = [0, cst_num_on_update_handlers$0],
    _al_ = [0, cst_changed_at$0],
    _am_ = [0, cst_cutoff$0],
    _an_ = [0, cst_kind$0],
    _ao_ = [0, cst_value_opt$0],
    _ap_ = [0, cst_recomputed_at$0],
    _aq_ = [0, "state"],
    _ar_ = [0, cst_id$0],
    cst_my_child_index_in_parent_a = cst_my_child_index_in_parent_a$0,
    cst_my_parent_index_in_child_a = cst_my_parent_index_in_child_a$0,
    cst_observers = cst_observers$0,
    cst_old_value_opt = cst_old_value_opt$0,
    cst_next_in_adjust_heights_hea = cst_next_in_adjust_heights_hea$0,
    cst_height_in_adjust_heights_h = cst_height_in_adjust_heights_h$0,
    cst_next_in_recompute_heap = cst_next_in_recompute_heap$0,
    cst_prev_in_recompute_heap = cst_prev_in_recompute_heap$0,
    cst_height_in_recompute_heap = cst_height_in_recompute_heap$0,
    cst_height = cst_height$0,
    cst_next_node_in_same_scope = cst_next_node_in_same_scope$0,
    cst_created_in = cst_created_in$0,
    cst_parent0 = cst_parent0$0,
    cst_parent1_and_beyond = cst_parent1_and_beyond$0,
    cst_num_parents = cst_num_parents$0,
    cst_num_on_update_handlers = cst_num_on_update_handlers$0,
    cst_changed_at = cst_changed_at$0,
    cst_cutoff = cst_cutoff$0,
    cst_kind = cst_kind$0,
    cst_value_opt = cst_value_opt$0,
    cst_recomputed_at = cst_recomputed_at$0,
    cst_id = cst_id$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Node = cst_Incremental_Node$0;
   function my_child_index_in_parent_at_in(r){return r[25];}
   function set_my_child_index_in_parent_a(r, v){r[25] = v; return 0;}
   function my_parent_index_in_child_at_in(r){return r[24];}
   function set_my_parent_index_in_child_a(r, v){r[24] = v; return 0;}
   function observers(r){return r[21];}
   function set_observers(r, v){r[21] = v; return 0;}
   function old_value_opt(r){return r[20];}
   function set_old_value_opt(r, v){r[20] = v; return 0;}
   function next_in_adjust_heights_heap(r){return r[19];}
   function set_next_in_adjust_heights_hea(r, v){r[19] = v; return 0;}
   function height_in_adjust_heights_heap(r){return r[18];}
   function set_height_in_adjust_heights_h(r, v){r[18] = v; return 0;}
   function next_in_recompute_heap(r){return r[17];}
   function set_next_in_recompute_heap(r, v){r[17] = v; return 0;}
   function prev_in_recompute_heap(r){return r[16];}
   function set_prev_in_recompute_heap(r, v){r[16] = v; return 0;}
   function height_in_recompute_heap(r){return r[15];}
   function set_height_in_recompute_heap(r, v){r[15] = v; return 0;}
   function height(r){return r[14];}
   function set_height(r, v){r[14] = v; return 0;}
   function next_node_in_same_scope(r){return r[13];}
   function set_next_node_in_same_scope(r, v){r[13] = v; return 0;}
   function created_in(r){return r[12];}
   function set_created_in(r, v){r[12] = v; return 0;}
   function parent0(r){return r[11];}
   function set_parent0(r, v){r[11] = v; return 0;}
   function parent1_and_beyond(r){return r[10];}
   function set_parent1_and_beyond(r, v){r[10] = v; return 0;}
   function num_parents(r){return r[9];}
   function set_num_parents(r, v){r[9] = v; return 0;}
   function num_on_update_handlers(r){return r[8];}
   function set_num_on_update_handlers(r, v){r[8] = v; return 0;}
   function changed_at(r){return r[7];}
   function set_changed_at(r, v){r[7] = v; return 0;}
   function cutoff(r){return r[6];}
   function set_cutoff(r, v){r[6] = v; return 0;}
   function kind(r){return r[5];}
   function set_kind(r, v){r[5] = v; return 0;}
   function value_opt(r){return r[4];}
   function set_value_opt(r, v){r[4] = v; return 0;}
   function recomputed_at(r){return r[3];}
   function set_recomputed_at(r, v){r[3] = v; return 0;}
   function id(r){return r[1];}
   function _a_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            v,
            r[26],
            r[27],
            r[28]];
   }
   var
    _b_ = [0, set_my_child_index_in_parent_a],
    my_child_index_in_parent_at_in$0 =
      [0,
       function(param){return 0;},
       cst_my_child_index_in_parent_a,
       _b_,
       my_child_index_in_parent_at_in,
       _a_];
   function _c_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            v,
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _d_ = [0, set_my_parent_index_in_child_a],
    my_parent_index_in_child_at_in$0 =
      [0,
       function(param){return 0;},
       cst_my_parent_index_in_child_a,
       _d_,
       my_parent_index_in_child_at_in,
       _c_];
   function _e_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            v,
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _f_ = [0, set_observers],
    observers$0 =
      [0, function(param){return 0;}, cst_observers, _f_, observers, _e_];
   function _g_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            v,
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _h_ = [0, set_old_value_opt],
    old_value_opt$0 =
      [0,
       function(param){return 0;},
       cst_old_value_opt,
       _h_,
       old_value_opt,
       _g_];
   function _i_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            v,
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _j_ = [0, set_next_in_adjust_heights_hea],
    next_in_adjust_heights_heap$0 =
      [0,
       function(param){return 0;},
       cst_next_in_adjust_heights_hea,
       _j_,
       next_in_adjust_heights_heap,
       _i_];
   function _k_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            v,
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _l_ = [0, set_height_in_adjust_heights_h],
    height_in_adjust_heights_heap$0 =
      [0,
       function(param){return 0;},
       cst_height_in_adjust_heights_h,
       _l_,
       height_in_adjust_heights_heap,
       _k_];
   function _m_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            v,
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _n_ = [0, set_next_in_recompute_heap],
    next_in_recompute_heap$0 =
      [0,
       function(param){return 0;},
       cst_next_in_recompute_heap,
       _n_,
       next_in_recompute_heap,
       _m_];
   function _o_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            v,
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _p_ = [0, set_prev_in_recompute_heap],
    prev_in_recompute_heap$0 =
      [0,
       function(param){return 0;},
       cst_prev_in_recompute_heap,
       _p_,
       prev_in_recompute_heap,
       _o_];
   function _q_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            v,
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _r_ = [0, set_height_in_recompute_heap],
    height_in_recompute_heap$0 =
      [0,
       function(param){return 0;},
       cst_height_in_recompute_heap,
       _r_,
       height_in_recompute_heap,
       _q_];
   function _s_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            v,
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _t_ = [0, set_height],
    height$0 = [0, function(param){return 0;}, cst_height, _t_, height, _s_];
   function _u_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            v,
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _v_ = [0, set_next_node_in_same_scope],
    next_node_in_same_scope$0 =
      [0,
       function(param){return 0;},
       cst_next_node_in_same_scope,
       _v_,
       next_node_in_same_scope,
       _u_];
   function _w_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            v,
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _x_ = [0, set_created_in],
    created_in$0 =
      [0, function(param){return 0;}, cst_created_in, _x_, created_in, _w_];
   function _y_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            v,
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _z_ = [0, set_parent0],
    parent0$0 =
      [0, function(param){return 0;}, cst_parent0, _z_, parent0, _y_];
   function _A_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            v,
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _B_ = [0, set_parent1_and_beyond],
    parent1_and_beyond$0 =
      [0,
       function(param){return 0;},
       cst_parent1_and_beyond,
       _B_,
       parent1_and_beyond,
       _A_];
   function _C_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _D_ = [0, set_num_parents],
    num_parents$0 =
      [0, function(param){return 0;}, cst_num_parents, _D_, num_parents, _C_];
   function _E_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _F_ = [0, set_num_on_update_handlers],
    num_on_update_handlers$0 =
      [0,
       function(param){return 0;},
       cst_num_on_update_handlers,
       _F_,
       num_on_update_handlers,
       _E_];
   function _G_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _H_ = [0, set_changed_at],
    changed_at$0 =
      [0, function(param){return 0;}, cst_changed_at, _H_, changed_at, _G_];
   function _I_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _J_ = [0, set_cutoff],
    cutoff$0 = [0, function(param){return 0;}, cst_cutoff, _J_, cutoff, _I_];
   function _K_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _L_ = [0, set_kind],
    kind$0 = [0, function(param){return 0;}, cst_kind, _L_, kind, _K_];
   function _M_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _N_ = [0, set_value_opt],
    value_opt$0 =
      [0, function(param){return 0;}, cst_value_opt, _N_, value_opt, _M_];
   function _O_(r, v){
    return [0,
            r[1],
            r[2],
            v,
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _P_ = [0, set_recomputed_at],
    recomputed_at$0 =
      [0,
       function(param){return 0;},
       cst_recomputed_at,
       _P_,
       recomputed_at,
       _O_];
   function _Q_(r, v){
    return [0,
            v,
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var _R_ = 0, id$0 = [0, function(param){return 0;}, cst_id, _R_, id, _Q_];
   function sexp_of_t(of_a_001, param){
    var
     state_005 = param[2],
     id_003 = param[1],
     recomputed_at_007 = param[3],
     value_opt_009 = param[4],
     kind_011 = param[5],
     cutoff_013 = param[6],
     changed_at_015 = param[7],
     num_on_update_handlers_017 = param[8],
     num_parents_019 = param[9],
     parent1_and_beyond_021 = param[10],
     parent0_023 = param[11],
     created_in_025 = param[12],
     next_node_in_same_scope_027 = param[13],
     height_029 = param[14],
     height_in_recompute_heap_031 = param[15],
     prev_in_recompute_heap_033 = param[16],
     next_in_recompute_heap_035 = param[17],
     height_in_adjust_heights_heap_ = param[18],
     next_in_adjust_heights_heap_03 = param[19],
     old_value_opt_041 = param[20],
     observers_043 = param[21],
     is_in_handle_after_stabilizati = param[22],
     on_update_handlers_047 = param[23],
     my_parent_index_in_child_at_in = param[24],
     my_child_index_in_parent_at_in = param[25],
     force_necessary_053 = param[26],
     user_info_055 = param[27],
     creation_backtrace_057 = param[28],
     arg_058 =
       caml_call2(Core[515], Base_Backtrace[1], creation_backtrace_057),
     bnds_002 = [0, [1, [0, _S_, [0, arg_058, 0]]], 0],
     arg_056 =
       caml_call2(Core[515], Incremental_Dot_user_info[4], user_info_055),
     bnds_002$0 = [0, [1, [0, _T_, [0, arg_056, 0]]], bnds_002],
     arg_054 = caml_call1(Core[323], force_necessary_053),
     bnds_002$1 = [0, [1, [0, _U_, [0, arg_054, 0]]], bnds_002$0],
     arg_052 =
       caml_call2(Core[301], Core[389], my_child_index_in_parent_at_in),
     bnds_002$2 = [0, [1, [0, _V_, [0, arg_052, 0]]], bnds_002$1],
     arg_050 =
       caml_call2(Core[301], Core[389], my_parent_index_in_child_at_in),
     bnds_002$3 = [0, [1, [0, _W_, [0, arg_050, 0]]], bnds_002$2],
     _cz_ = caml_call1(Incremental_On_update_handler[2], of_a_001),
     arg_048 = caml_call2(Core[472], _cz_, on_update_handlers_047),
     bnds_002$4 = [0, [1, [0, _X_, [0, arg_048, 0]]], bnds_002$3],
     arg_046 = caml_call1(Core[323], is_in_handle_after_stabilizati),
     bnds_002$5 = [0, [1, [0, _Y_, [0, arg_046, 0]]], bnds_002$4],
     arg_044 =
       caml_call2
        (Incremental_Import[6][2], Sexplib0_Sexp_conv[23], observers_043),
     bnds_002$6 = [0, [1, [0, _Z_, [0, arg_044, 0]]], bnds_002$5],
     arg_042 =
       caml_call2(Incremental_Import[6][2], of_a_001, old_value_opt_041),
     bnds_002$7 = [0, [1, [0, ___, [0, arg_042, 0]]], bnds_002$6],
     arg_040 =
       caml_call2
        (Incremental_Import[6][2],
         Incremental_Types[15][2][1],
         next_in_adjust_heights_heap_03),
     bnds_002$8 = [0, [1, [0, _$_, [0, arg_040, 0]]], bnds_002$7],
     arg_038 = caml_call1(Core[389], height_in_adjust_heights_heap_),
     bnds_002$9 = [0, [1, [0, _aa_, [0, arg_038, 0]]], bnds_002$8],
     arg_036 =
       caml_call2
        (Incremental_Import[6][2],
         Incremental_Types[15][2][1],
         next_in_recompute_heap_035),
     bnds_002$10 = [0, [1, [0, _ab_, [0, arg_036, 0]]], bnds_002$9],
     arg_034 =
       caml_call2
        (Incremental_Import[6][2],
         Incremental_Types[15][2][1],
         prev_in_recompute_heap_033),
     bnds_002$11 = [0, [1, [0, _ac_, [0, arg_034, 0]]], bnds_002$10],
     arg_032 = caml_call1(Core[389], height_in_recompute_heap_031),
     bnds_002$12 = [0, [1, [0, _ad_, [0, arg_032, 0]]], bnds_002$11],
     arg_030 = caml_call1(Core[389], height_029),
     bnds_002$13 = [0, [1, [0, _ae_, [0, arg_030, 0]]], bnds_002$12],
     arg_028 =
       caml_call2
        (Incremental_Import[6][2],
         Incremental_Types[15][2][1],
         next_node_in_same_scope_027),
     bnds_002$14 = [0, [1, [0, _af_, [0, arg_028, 0]]], bnds_002$13],
     arg_026 = caml_call1(Incremental_Scope[1], created_in_025),
     bnds_002$15 = [0, [1, [0, _ag_, [0, arg_026, 0]]], bnds_002$14],
     arg_024 =
       caml_call2
        (Incremental_Import[6][2], Incremental_Types[15][2][1], parent0_023),
     bnds_002$16 = [0, [1, [0, _ah_, [0, arg_024, 0]]], bnds_002$15],
     _cA_ = caml_call1(Incremental_Import[6][2], Incremental_Types[15][2][1]),
     arg_022 =
       caml_call2(Incremental_Import[7][10], _cA_, parent1_and_beyond_021),
     bnds_002$17 = [0, [1, [0, _ai_, [0, arg_022, 0]]], bnds_002$16],
     arg_020 = caml_call1(Core[389], num_parents_019),
     bnds_002$18 = [0, [1, [0, _aj_, [0, arg_020, 0]]], bnds_002$17],
     arg_018 = caml_call1(Core[389], num_on_update_handlers_017),
     bnds_002$19 = [0, [1, [0, _ak_, [0, arg_018, 0]]], bnds_002$18],
     arg_016 = caml_call1(Incremental_Stabilization_num[2], changed_at_015),
     bnds_002$20 = [0, [1, [0, _al_, [0, arg_016, 0]]], bnds_002$19],
     arg_014 = caml_call2(Incremental_Cutoff[1], of_a_001, cutoff_013),
     bnds_002$21 = [0, [1, [0, _am_, [0, arg_014, 0]]], bnds_002$20],
     arg_012 = caml_call2(Incremental_Kind[2], of_a_001, kind_011),
     bnds_002$22 = [0, [1, [0, _an_, [0, arg_012, 0]]], bnds_002$21],
     arg_010 = caml_call2(Incremental_Import[6][2], of_a_001, value_opt_009),
     bnds_002$23 = [0, [1, [0, _ao_, [0, arg_010, 0]]], bnds_002$22],
     arg_008 = caml_call1(Incremental_Stabilization_num[2], recomputed_at_007),
     bnds_002$24 = [0, [1, [0, _ap_, [0, arg_008, 0]]], bnds_002$23],
     arg_006 = caml_call1(Sexplib0_Sexp_conv[23], state_005),
     bnds_002$25 = [0, [1, [0, _aq_, [0, arg_006, 0]]], bnds_002$24],
     arg_004 = caml_call1(Incremental_Node_id[1], id_003),
     bnds_002$26 = [0, [1, [0, _ar_, [0, arg_004, 0]]], bnds_002$25];
    return [1, bnds_002$26];
   }
   function same(t1, t2){return t1 === t2 ? 1 : 0;}
   var is_necessary = Incremental_Types[15][4];
   function iteri_children(t, f){
    return caml_call2(Incremental_Kind[10], t[5], f);
   }
   var
    is_valid = Incremental_Types[15][3],
    type_equal_if_phys_same = Incremental_Types[15][5];
   function user_info(t){
    var _cx_ = t[27];
    if(! _cx_) return 0;
    var other = _cx_[1];
    if(1 === other[0]){var i = other[1]; return [0, i];}
    var _cy_ = caml_call1(Incremental_Dot_user_info[4], other);
    return [0, caml_call1(Core_Info[20], _cy_)];
   }
   function set_user_info(t, info){
    if(info) var i = info[1], _cw_ = [0, [1, i]]; else var _cw_ = 0;
    t[27] = _cw_;
    return 0;
   }
   function append_user_info_graphviz(t, label, attrs){
    var
     new$0 = caml_call2(Incremental_Dot_user_info[6], label, attrs),
     match = t[27];
    if(match)
     var
      other = match[1],
      _cv_ = [0, caml_call2(Incremental_Dot_user_info[8], other, new$0)];
    else
     var _cv_ = [0, new$0];
    t[27] = _cv_;
    return 0;
   }
   function edge_is_stale(child, parent){
    var
     _cu_ = caml_call2(Incremental_Stabilization_num[1], child[7], parent[3]);
    return caml_call2(Core[91], _cu_, 0);
   }
   function is_stale_with_respect_to_a_chi(t){
    var is_stale = [0, 0];
    iteri_children
     (t,
      function(param, child){
       var
        _cs_ = edge_is_stale(child, t),
        _ct_ = _cs_ ? (is_stale[1] = 1, 0) : _cs_;
       return _ct_;
      });
    return is_stale[1];
   }
   function is_stale(t){
    var _cl_ = t[5];
    if(typeof _cl_ === "number"){
     if(0 === _cl_) return 0;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _as_], 1);
    }
    switch(_cl_[0]){
      case 1:
       return caml_call1(Incremental_Stabilization_num[7], t[3]);
      case 2:
       return caml_call1(Incremental_Stabilization_num[7], t[3]);
      case 3:
       var _cn_ = caml_call1(Incremental_Stabilization_num[7], t[3]);
       return _cn_ ? _cn_ : is_stale_with_respect_to_a_chi(t);
      case 5:
       return caml_call1(Incremental_Stabilization_num[7], t[3]);
      case 6:
       var force_stale = _cl_[1][5];
       if(force_stale)
        var force_stale$0 = force_stale;
       else{
        var _co_ = caml_call1(Incremental_Stabilization_num[7], t[3]);
        if(! _co_) return is_stale_with_respect_to_a_chi(t);
        var force_stale$0 = _co_;
       }
       return force_stale$0;
      case 8:
       var _cp_ = caml_call1(Incremental_Stabilization_num[7], t[3]);
       return _cp_ ? _cp_ : is_stale_with_respect_to_a_chi(t);
      case 10:
       var _cq_ = caml_call1(Incremental_Stabilization_num[7], t[3]);
       return _cq_ ? _cq_ : is_stale_with_respect_to_a_chi(t);
      case 13:
       return caml_call1(Incremental_Stabilization_num[7], t[3]);
      case 16:
       var
        set_at = _cl_[1][3],
        _cr_ = caml_call2(Incremental_Stabilization_num[1], set_at, t[3]);
       return caml_call2(Core[91], _cr_, 0);
      default:
       var _cm_ = caml_call1(Incremental_Stabilization_num[7], t[3]);
       return _cm_ ? _cm_ : is_stale_with_respect_to_a_chi(t);
    }
   }
   function needs_to_be_computed(t){
    var _ck_ = caml_call1(is_necessary, t);
    return _ck_ ? is_stale(t) : _ck_;
   }
   function is_in_recompute_heap(t){return caml_call2(Core[88], t[15], 0);}
   function is_in_adjust_heights_heap(t){
    return caml_call2(Core[88], t[18], 0);
   }
   function get_parent(t, index){
    var
     _cj_ =
       caml_call2(Core[90], index, 0)
        ? t[11]
        : caml_call2(Incremental_Import[7][20], t[10], index - 1 | 0);
    return caml_call1(Incremental_Import[6][9], _cj_);
   }
   function iteri_parents(t, f){
    if(caml_call2(Core[91], t[9], 0)){
     caml_call2(f, 0, caml_call1(Incremental_Import[6][9], t[11]));
     var _cg_ = t[9] - 1 | 0, _cf_ = 1;
     if(_cg_ >= 1){
      var index = _cf_;
      for(;;){
       var _ch_ = caml_call2(Incremental_Import[7][20], t[10], index - 1 | 0);
       caml_call2(f, index, caml_call1(Incremental_Import[6][9], _ch_));
       var _ci_ = index + 1 | 0;
       if(_cg_ === index) break;
       var index = _ci_;
      }
     }
    }
    return;
   }
   function has_child(t, child){
    var has = [0, 0];
    iteri_children
     (t,
      function(param, child$0){
       var _cd_ = has[1], _ce_ = _cd_ || (child === child$0 ? 1 : 0);
       has[1] = _ce_;
       return 0;
      });
    return has[1];
   }
   function has_parent(t, parent){
    var has = [0, 0];
    iteri_parents
     (t,
      function(param, parent$0){
       var _cb_ = has[1], _cc_ = _cb_ || (parent === parent$0 ? 1 : 0);
       has[1] = _cc_;
       return 0;
      });
    return has[1];
   }
   function should_be_invalidated(t){
    var _b__ = t[5];
    if(typeof _b__ !== "number")
     switch(_b__[0]){
       case 1:
        return 0;
       case 2:
        return 0;
       case 3:
        var lhs = _b__[1][3]; return 1 - caml_call1(is_valid, lhs);
       case 4:
        var lhs_change = _b__[1][4];
        return 1 - caml_call1(is_valid, lhs_change);
       case 6:
        return 0;
       case 8:
        var test = _b__[1][2]; return 1 - caml_call1(is_valid, test);
       case 9:
        var test_change = _b__[1][3];
        return 1 - caml_call1(is_valid, test_change);
       case 10:
        var lhs$0 = _b__[1][2]; return 1 - caml_call1(is_valid, lhs$0);
       case 11:
        var lhs_change$0 = _b__[1][3];
        return 1 - caml_call1(is_valid, lhs_change$0);
       case 5:
       case 13:
       case 16:
        return 0;
       default:
        var has = [0, 0];
        iteri_children
         (t,
          function(param, child){
           var _b$_ = has[1], _ca_ = _b$_ || 1 - caml_call1(is_valid, child);
           has[1] = _ca_;
           return 0;
          });
        return has[1];
     }
    if(0 === _b__) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _at_], 1);
   }
   function fold_observers(t, init, f){
    var r = [0, t[21]], ac = [0, init];
    for(;;){
     if(! caml_call1(Incremental_Import[6][8], r[1])) return ac[1];
     var observer = caml_call1(Incremental_Import[6][9], r[1]);
     r[1] = observer[7];
     ac[1] = caml_call2(f, ac[1], observer);
    }
   }
   function invariant(invariant_a, t){
    function _bI_(param){
     var
      t2 = is_in_recompute_heap(t),
      t1 = needs_to_be_computed(t),
      sexpifier = Core[323],
      equal = 0,
      message = 0,
      here = 0;
     function comparator(a_060, b_061){
      return caml_call2(Core[316], a_060, b_061);
     }
     caml_call8
      (Ppx_assert_lib_Runtime[2],
       pos,
       sexpifier,
       comparator,
       here,
       message,
       equal,
       t1,
       t2);
     if(caml_call1(is_necessary, t)){
      var _bK_ = caml_call1(Incremental_Scope[5], t[12]);
      if(! caml_call2(Core[91], t[14], _bK_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _aZ_], 1);
      iteri_children
       (t,
        function(param, child){
         if(! caml_call2(Core[91], t[14], child[14]))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _av_], 1);
         if(has_parent(child, t)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _au_], 1);
        });
      if(should_be_invalidated(t))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _aw_], 1);
     }
     iteri_parents
      (t,
       function(param, parent){
        if(! has_child(parent, t))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _az_], 1);
        if(! caml_call1(is_necessary, parent))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _ay_], 1);
        if(caml_call2(Core[92], t[14], parent[14])) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _ax_], 1);
       });
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      my_child_index_in_parent_at_in =
        check
         (function(my_child_index_in_parent_at_in){
           var
            got = my_child_index_in_parent_at_in.length - 1,
            expect = caml_call1(Incremental_Import[7][19], t[10]) + 1 | 0,
            sexpifier = Core[389],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_070, b_071){
            return caml_call2(Core[382], a_070, b_071);
           }
           caml_call8
            (Ppx_assert_lib_Runtime[3],
             pos$0,
             sexpifier,
             comparator,
             here,
             message,
             equal,
             expect,
             got);
           iteri_parents
            (t,
             function(parent_index, param){
              var
               _b9_ =
                 caml_check_bound
                   (my_child_index_in_parent_at_in, parent_index)
                  [1 + parent_index];
              if(t === caml_call2(Incremental_Kind[5], param[5], _b9_))
               return 0;
              throw caml_maybe_attach_backtrace([0, Assert_failure, _aA_], 1);
             });
           var
            _b6_ = Incremental_Import[1],
            _b7_ = _b6_ ? 1 - caml_call1(is_necessary, t) : _b6_;
           if(! _b7_) return _b7_;
           function _b8_(x){
            if(caml_call2(Core[90], x, -1)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aB_], 1);
           }
           return caml_call2
                   (Incremental_Import[5][35],
                    my_child_index_in_parent_at_in,
                    _b8_);
          }),
      my_parent_index_in_child_at_in =
        check
         (function(my_parent_index_in_child_at_in){
           var _b2_ = t[5];
           a:
           {
            if(typeof _b2_ !== "number" && 6 === _b2_[0]) break a;
            var
             got = my_parent_index_in_child_at_in.length - 1,
             expect = caml_call1(Incremental_Kind[4], t[5]),
             sexpifier = Core[389],
             equal = 0,
             message = 0,
             here = 0,
             comparator =
               function(a_068, b_069){
                return caml_call2(Core[382], a_068, b_069);
               };
            caml_call8
             (Ppx_assert_lib_Runtime[3],
              pos$1,
              sexpifier,
              comparator,
              here,
              message,
              equal,
              expect,
              got);
           }
           if(caml_call1(is_necessary, t))
            iteri_children
             (t,
              function(child_index, param){
               if
                (t
                 ===
                  get_parent
                   (param,
                    caml_check_bound
                      (my_parent_index_in_child_at_in, child_index)
                     [1 + child_index]))
                return 0;
               throw caml_maybe_attach_backtrace([0, Assert_failure, _aC_], 1);
              });
           var
            _b3_ = Incremental_Import[1],
            _b4_ = _b3_ ? 1 - caml_call1(is_necessary, t) : _b3_;
           if(! _b4_) return _b4_;
           function _b5_(x){
            if(caml_call2(Core[90], x, -1)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aD_], 1);
           }
           return caml_call2
                   (Incremental_Import[5][35],
                    my_parent_index_in_child_at_in,
                    _b5_);
          }),
      observers_fun =
        check
         (function(param){
           return fold_observers
                   (t,
                    0,
                    function(param, observer){
                     var state = observer[1], observing = observer[2];
                     if(t !== observing)
                      throw caml_maybe_attach_backtrace
                             ([0, Assert_failure, _aF_], 1);
                     if(1 < state - 1 >>> 0)
                      throw caml_maybe_attach_backtrace
                             ([0, Assert_failure, _aE_], 1);
                     return 0;
                    });
          }),
      old_value_opt_fun =
        check(caml_call1(Incremental_Import[6][4], invariant_a)),
      next_in_adjust_heights_heap_fu =
        check
         (function(next_in_adjust_heights_heap){
           if(is_in_adjust_heights_heap(t)){
            var
             _b1_ =
               caml_call1
                (Incremental_Import[6][8], next_in_adjust_heights_heap);
            if(! _b1_) return _b1_;
            var
             next =
               caml_call1
                (Incremental_Import[6][9], next_in_adjust_heights_heap);
            if(! is_in_adjust_heights_heap(next))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _aH_], 1);
            if(caml_call2(Core[90], t[18], next[18])) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aG_], 1);
           }
           if
            (caml_call1(Incremental_Import[6][7], next_in_adjust_heights_heap))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aI_], 1);
          }),
      height_in_adjust_heights_heap_ =
        check
         (function(height_in_adjust_heights_heap){
           var _b0_ = caml_call2(Core[88], height_in_adjust_heights_heap, 0);
           if(! _b0_) return _b0_;
           if(caml_call2(Core[92], height_in_adjust_heights_heap, t[14]))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aJ_], 1);
          }),
      next_in_recompute_heap_fun =
        check
         (function(next_in_recompute_heap){
           if
            (1 - is_in_recompute_heap(t)
             && ! caml_call1(Incremental_Import[6][7], next_in_recompute_heap))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aM_], 1);
           var
            _bZ_ =
              caml_call1(Incremental_Import[6][8], next_in_recompute_heap);
           if(! _bZ_) return _bZ_;
           var
            next =
              caml_call1(Incremental_Import[6][9], next_in_recompute_heap);
           if(t !== caml_call1(Incremental_Import[6][9], next[16]))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aL_], 1);
           if(caml_call2(Core[90], t[15], next[15])) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aK_], 1);
          }),
      prev_in_recompute_heap_fun =
        check
         (function(prev_in_recompute_heap){
           if
            (1 - is_in_recompute_heap(t)
             && ! caml_call1(Incremental_Import[6][7], prev_in_recompute_heap))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aP_], 1);
           var
            _bY_ =
              caml_call1(Incremental_Import[6][8], prev_in_recompute_heap);
           if(! _bY_) return _bY_;
           var
            prev =
              caml_call1(Incremental_Import[6][9], prev_in_recompute_heap);
           if(t !== caml_call1(Incremental_Import[6][9], prev[17]))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aO_], 1);
           if(caml_call2(Core[90], t[15], prev[15])) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aN_], 1);
          }),
      height_in_recompute_heap_fun =
        check
         (function(height_in_recompute_heap){
           if(! caml_call2(Core[88], height_in_recompute_heap, -1))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aR_], 1);
           if(caml_call2(Core[89], height_in_recompute_heap, t[14])) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aQ_], 1);
          }),
      height_fun =
        check
         (function(height){
           if(caml_call1(is_necessary, t)){
            if(caml_call2(Core[88], height, 0)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aS_], 1);
           }
           if(caml_call2(Core[90], height, -1)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aT_], 1);
          }),
      next_node_in_same_scope_fun =
        check
         (function(next_node_in_same_scope){
           var
            _bW_ = caml_call1(Incremental_Scope[4], t[12]),
            _bX_ = _bW_ || 1 - caml_call1(is_valid, t);
           if(! _bX_) return _bX_;
           if(caml_call1(Incremental_Import[6][7], next_node_in_same_scope))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aU_], 1);
          }),
      created_in_fun = check(Incremental_Scope[2]),
      parent0_fun =
        check
         (function(parent0){
           var
            t2 = caml_call1(Incremental_Import[6][8], parent0),
            t1 = caml_call2(Core[91], t[9], 0),
            sexpifier = Core[323],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_066, b_067){
            return caml_call2(Core[316], a_066, b_067);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[2],
                    pos$2,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    t1,
                    t2);
          }),
      parent1_and_beyond_fun =
        check
         (function(parent1_and_beyond){
           var
            _bT_ = caml_call1(Incremental_Import[7][19], parent1_and_beyond),
            _bS_ = 1;
           if(_bT_ >= 1){
            var parent_index = _bS_;
            for(;;){
             var
              _bU_ =
                caml_call2
                 (Incremental_Import[7][20],
                  parent1_and_beyond,
                  parent_index - 1 | 0),
              t2 = caml_call1(Incremental_Import[6][8], _bU_),
              t1 = caml_call2(Core[92], parent_index, t[9]),
              sexpifier = Core[323],
              equal = 0,
              message = 0,
              here = 0,
              comparator =
                function(a_064, b_065){
                 return caml_call2(Core[316], a_064, b_065);
                };
             caml_call8
              (Ppx_assert_lib_Runtime[2],
               pos$3,
               sexpifier,
               comparator,
               here,
               message,
               equal,
               t1,
               t2);
             var _bV_ = parent_index + 1 | 0;
             if(_bT_ === parent_index) break;
             var parent_index = _bV_;
            }
           }
           return 0;
          }),
      num_parents_fun =
        check
         (function(num_parents){
           if(! caml_call2(Core[88], num_parents, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aW_], 1);
           var _bR_ = 1 + caml_call1(Incremental_Import[7][19], t[10]) | 0;
           if(caml_call2(Core[89], num_parents, _bR_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aV_], 1);
          }),
      _bL_ =
        fold_observers
         (t,
          0,
          function(n, param){
           var on_update_handlers = param[3];
           return n + caml_call1(Core_List[45], on_update_handlers) | 0;
          }),
      expect = caml_call1(Core_List[45], t[23]) + _bL_ | 0,
      num_on_update_handlers_fun =
        check
         (function(eta){
           var sexpifier = Core[389], equal = 0, message = 0, here = 0;
           function comparator(a_062, b_063){
            return caml_call2(Core[382], a_062, b_063);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$4,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    eta);
          }),
      changed_at_fun =
        check
         (function(changed_at){
           caml_call1(Incremental_Stabilization_num[4], changed_at);
           var _bP_ = caml_call1(Incremental_Stabilization_num[8], t[3]);
           if(! _bP_) return _bP_;
           var
            _bQ_ =
              caml_call2(Incremental_Stabilization_num[1], changed_at, t[3]);
           if(caml_call2(Core[89], _bQ_, 0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _aX_], 1);
          }),
      cutoff_fun = check(caml_call1(Incremental_Cutoff[2], invariant_a)),
      kind_fun =
        check
         (function(kind){
           caml_call2(Incremental_Kind[1], invariant_a, kind);
           if(typeof kind !== "number" && 6 === kind[0]){
            var e = kind[1], _bO_ = caml_call1(is_necessary, t);
            return caml_call2(Incremental_Expert[4], e, _bO_);
           }
           return 0;
          }),
      value_opt_fun =
        check
         (function(value_opt){
           var
            _bM_ = caml_call1(is_valid, t),
            _bN_ = _bM_ ? 1 - is_stale(t) : _bM_;
           if(_bN_ && ! caml_call1(Incremental_Import[6][8], value_opt))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _aY_], 1);
           return caml_call2(Incremental_Import[6][4], invariant_a, value_opt);
          }),
      recomputed_at_fun = check(Incremental_Stabilization_num[4]),
      id_fun = check(Incremental_Node_id[9]);
     caml_call1(id_fun, id$0);
     caml_call1(recomputed_at_fun, recomputed_at$0);
     caml_call1(value_opt_fun, value_opt$0);
     caml_call1(kind_fun, kind$0);
     caml_call1(cutoff_fun, cutoff$0);
     caml_call1(changed_at_fun, changed_at$0);
     caml_call1(num_on_update_handlers_fun, num_on_update_handlers$0);
     caml_call1(num_parents_fun, num_parents$0);
     caml_call1(parent1_and_beyond_fun, parent1_and_beyond$0);
     caml_call1(parent0_fun, parent0$0);
     caml_call1(created_in_fun, created_in$0);
     caml_call1(next_node_in_same_scope_fun, next_node_in_same_scope$0);
     caml_call1(height_fun, height$0);
     caml_call1(height_in_recompute_heap_fun, height_in_recompute_heap$0);
     caml_call1(prev_in_recompute_heap_fun, prev_in_recompute_heap$0);
     caml_call1(next_in_recompute_heap_fun, next_in_recompute_heap$0);
     caml_call1
      (height_in_adjust_heights_heap_, height_in_adjust_heights_heap$0);
     caml_call1(next_in_adjust_heights_heap_fu, next_in_adjust_heights_heap$0);
     caml_call1(old_value_opt_fun, old_value_opt$0);
     caml_call1(observers_fun, observers$0);
     caml_call1
      (my_parent_index_in_child_at_in, my_parent_index_in_child_at_in$0);
     caml_call1
      (my_child_index_in_parent_at_in, my_child_index_in_parent_at_in$0);
     return 0;
    }
    function _bJ_(x_059){
     return sexp_of_t(function(param){return _a0_;}, x_059);
    }
    return caml_call4(Base_Invariant[1], _a1_, t, _bJ_, _bI_);
   }
   function unsafe_value(t){
    return caml_call1(Incremental_Import[6][16], t[4]);
   }
   function value_exn(t){
    if(caml_call1(Incremental_Import[6][8], t[4]))
     return caml_call1(Incremental_Import[6][16], t[4]);
    function _bH_(x_072){
     return sexp_of_t(function(param){return _a2_;}, x_072);
    }
    return caml_call5
            (Core[247], 0, _a3_, cst_attempt_to_get_value_of_an, t, _bH_);
   }
   function get_cutoff(t){return t[6];}
   function set_cutoff$0(t, cutoff){t[6] = cutoff; return 0;}
   function is_const(t){
    var _bG_ = t[5];
    if(typeof _bG_ !== "number" && 5 === _bG_[0]) return 1;
    return 0;
   }
   function on_update(t, on_update_handler){
    t[23] = [0, on_update_handler, t[23]];
    t[8] = t[8] + 1 | 0;
    return 0;
   }
   function run_on_update_handlers(t, node_update, now){
    var r = [0, t[23]];
    for(;;){
     if(caml_call1(Core_List[18], r[1])) break;
     var match$0 = r[1];
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a6_], 1);
     var rest$0 = match$0[2], on_update_handler$0 = match$0[1];
     r[1] = rest$0;
     caml_call3
      (Incremental_On_update_handler[4],
       on_update_handler$0,
       node_update,
       now);
    }
    var r$0 = [0, t[21]];
    for(;;){
     if(! caml_call1(Incremental_Import[6][8], r$0[1])) return 0;
     var observer = caml_call1(Incremental_Import[6][9], r$0[1]);
     r$0[1] = observer[7];
     var r$1 = [0, observer[3]];
     for(;;){
      if(caml_call1(Core_List[18], r$1[1])) break;
      var match = r$1[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a5_], 1);
      var rest = match[2], on_update_handler = match[1];
      r$1[1] = rest;
      var _bF_ = observer[1];
      a:
      if(_bF_){
       switch(_bF_ - 1 | 0){
         case 0:
          caml_call3
           (Incremental_On_update_handler[4],
            on_update_handler,
            node_update,
            now);
          break;
         case 1: break;
         default: break a;
       }
       continue;
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a4_], 1);
     }
    }
   }
   function set_kind$0(t, kind){
    t[5] = kind;
    var _bE_ = caml_call1(Incremental_Kind[4], kind);
    t[24] = caml_call2(Incremental_Import[5][63], _bE_, -1);
    return 0;
   }
   function create(state, created_in, kind){
    var
     _bp_ = state[18] ? [0, caml_call2(Base_Backtrace[2], 0, 0)] : 0,
     _bq_ = caml_call1(Incremental_Kind[4], kind),
     _br_ = caml_call2(Incremental_Import[5][63], _bq_, -1),
     _bs_ = Incremental_Import[6][5],
     _bt_ = Incremental_Import[6][5],
     _bu_ = Incremental_Import[6][5],
     _bv_ = Incremental_Import[6][5],
     _bw_ = Incremental_Import[6][5],
     _bx_ = Incremental_Import[6][5],
     _by_ = Incremental_Import[6][5],
     _bz_ = Incremental_Import[7][15],
     _bA_ = Incremental_Stabilization_num[5],
     _bB_ = Incremental_Cutoff[8],
     _bC_ = Incremental_Import[6][5],
     _bD_ = Incremental_Stabilization_num[5],
     t =
       [0,
        caml_call1(Incremental_Node_id[10], 0),
        state,
        _bD_,
        _bC_,
        kind,
        _bB_,
        _bA_,
        0,
        0,
        _bz_,
        _by_,
        created_in,
        _bx_,
        -1,
        -1,
        _bw_,
        _bv_,
        -1,
        _bu_,
        _bt_,
        _bs_,
        0,
        0,
        _br_,
        [0, -1],
        0,
        0,
        _bp_];
    caml_call2(Incremental_Scope[8], created_in, t);
    return t;
   }
   function max_num_parents(t){
    return 1 + caml_call1(Incremental_Import[7][19], t[10]) | 0;
   }
   function set_parent(child, parent, parent_index){
    if(! caml_call2(Core[90], parent_index, 0))
     return caml_call3
             (Incremental_Import[7][75],
              child[10],
              parent_index - 1 | 0,
              parent);
    child[11] = parent;
    return;
   }
   function link(child, child_index, parent, parent_index){
    set_parent
     (child, caml_call1(Incremental_Import[6][6], parent), parent_index);
    caml_check_bound(child[25], parent_index)[1 + parent_index] = child_index;
    caml_check_bound(parent[24], child_index)[1 + child_index] = parent_index;
    return;
   }
   function add_parent(child, parent, child_index){
    var _bn_ = max_num_parents(child);
    if(caml_call2(Core[90], child[9], _bn_)){
     var new_max_num_parents = 2 * max_num_parents(child) | 0;
     child[10] =
      caml_call2
       (Incremental_Import[7][76], child[10], new_max_num_parents - 1 | 0);
     child[25] =
      caml_call3
       (Incremental_Import[5][131], child[25], new_max_num_parents, -1);
    }
    if(Incremental_Import[1]){
     var _bo_ = max_num_parents(child);
     if(! caml_call2(Core[92], child[9], _bo_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a7_], 1);
    }
    var max_num_children = parent[24].length - 1;
    if(caml_call2(Core[88], child_index, max_num_children)){
     if
      (Incremental_Import[1]
       && ! caml_call2(Core[90], child_index, max_num_children))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a9_], 1);
     var
      new_max_num_children =
        caml_call2(Core_Int[90], 2, 2 * max_num_children | 0);
     parent[24] =
      caml_call3
       (Incremental_Import[5][131], parent[24], new_max_num_children, -1);
    }
    if
     (Incremental_Import[1]
      && ! caml_call2(Core[92], child_index, parent[24].length - 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a8_], 1);
    link(child, child_index, parent, child[9]);
    child[9] = child[9] + 1 | 0;
    return 0;
   }
   function remove_parent(child, parent, child_index){
    if(Incremental_Import[1] && ! caml_call2(Core[88], child[9], 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a$_], 1);
    var
     parent_index = caml_check_bound(parent[24], child_index)[1 + child_index];
    if(Incremental_Import[1] && parent !== get_parent(child, parent_index))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a__], 1);
    var last_parent_index = child[9] - 1 | 0;
    if(caml_call2(Core[92], parent_index, last_parent_index)){
     var
      _bm_ =
        caml_call2
         (Incremental_Import[7][20], child[10], last_parent_index - 1 | 0),
      match = caml_call1(Incremental_Import[6][9], _bm_);
     link
      (child,
       caml_check_bound(child[25], last_parent_index)[1 + last_parent_index],
       match,
       parent_index);
    }
    set_parent(child, Incremental_Import[6][5], last_parent_index);
    if(Incremental_Import[1]){
     caml_check_bound(child[25], last_parent_index)[1 + last_parent_index] = -1;
     caml_check_bound(parent[24], child_index)[1 + child_index] = -1;
    }
    child[9] = child[9] - 1 | 0;
    return 0;
   }
   function swap_children_except_in_kind
   (parent, child1, child_index1, child2, child_index2){
    if(Incremental_Import[1]){
     if(child1 !== caml_call2(Incremental_Kind[5], parent[5], child_index1))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bd_], 1);
     if(child2 !== caml_call2(Incremental_Kind[5], parent[5], child_index2))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bc_], 1);
    }
    var
     index_of_parent_in_child1 =
       caml_check_bound(parent[24], child_index1)[1 + child_index1],
     index_of_parent_in_child2 =
       caml_check_bound(parent[24], child_index2)[1 + child_index2];
    if(Incremental_Import[1]){
     var
      _bk_ =
        caml_check_bound(child1[25], index_of_parent_in_child1)
         [1 + index_of_parent_in_child1];
     if(! caml_call2(Core[90], _bk_, child_index1))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bb_], 1);
     var
      _bl_ =
        caml_check_bound(child2[25], index_of_parent_in_child2)
         [1 + index_of_parent_in_child2];
     if(! caml_call2(Core[90], _bl_, child_index2))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _ba_], 1);
    }
    caml_check_bound(child1[25], index_of_parent_in_child1)
     [1 + index_of_parent_in_child1]
    = child_index2;
    caml_check_bound(child2[25], index_of_parent_in_child2)
     [1 + index_of_parent_in_child2]
    = child_index1;
    caml_check_bound(parent[24], child_index1)[1 + child_index1] = index_of_parent_in_child2;
    caml_check_bound(parent[24], child_index2)[1 + child_index2] = index_of_parent_in_child1;
    return 0;
   }
   function sexp_of_t$0(x_073){
    return sexp_of_t(function(param){return _be_;}, x_073);
   }
   function invariant$0(param){
    return invariant(function(_bj_){return 0;}, param);
   }
   function iter_descendants(ts, f){
    var seen = caml_call3(Incremental_Node_id[7][3], 0, 0, 0);
    function iter_descendants(t){
     var _bi_ = 1 - caml_call2(Core_Hash_set[20], seen, t[1]);
     return _bi_
             ? (caml_call2
                (Core_Hash_set[22], seen, t[1]),
               caml_call1(f, t),
               iteri_children
                (t, function(param, t){return iter_descendants(t);}))
             : _bi_;
    }
    caml_call2(Core_List[19], ts, iter_descendants);
    return 0;
   }
   function append_user_info_graphviz$0(param){
    return function(_bg_, _bh_){
     return append_user_info_graphviz(param, _bg_, _bh_);};
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Node);
   var
    Incremental_Node =
      [0,
       [0,
        sexp_of_t$0,
        invariant$0,
        function(M){
         function fold(t, init, f){
          var ac = [0, init], r = [0, t];
          for(;;){
           if(! caml_call1(Incremental_Import[6][8], r[1])) return ac[1];
           var packed_node = caml_call1(Incremental_Import[6][16], r[1]);
           r[1] = caml_call1(M[1], packed_node);
           ac[1] = caml_call2(f, ac[1], packed_node);
          }
         }
         function iter(t, f){
          return fold(t, 0, function(param, n){return caml_call1(f, n);});
         }
         function invariant(t){return iter(t, invariant$0);}
         function length(t){
          return fold(t, 0, function(n, param){return n + 1 | 0;});
         }
         function sexp_of_t(t){
          var
           _bf_ = fold(t, 0, function(ac, n){return [0, n, ac];}),
           x_074 = caml_call1(Core_List[59], _bf_);
          return caml_call2(Core[472], Incremental_Types[15][2][1], x_074);
         }
         return [0, sexp_of_t, invariant, length, iter];
        },
        iter_descendants,
        append_user_info_graphviz$0],
       sexp_of_t,
       type_equal_if_phys_same,
       invariant,
       create,
       set_kind$0,
       same,
       iteri_children,
       get_parent,
       add_parent,
       remove_parent,
       swap_children_except_in_kind,
       is_const,
       is_in_recompute_heap,
       is_necessary,
       is_valid,
       should_be_invalidated,
       edge_is_stale,
       is_stale,
       needs_to_be_computed,
       value_exn,
       unsafe_value,
       get_cutoff,
       set_cutoff$0,
       on_update,
       run_on_update_handlers,
       user_info,
       set_user_info,
       append_user_info_graphviz,
       has_child,
       has_parent];
   runtime.caml_register_global(145, Incremental_Node, cst_Incremental_Node$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Recompute_heap
//# unitInfo: Requires: Base__Invariant, Core, Incremental__Import, Incremental__Node, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Recompute_heap$0 = "Incremental__Recompute_heap",
    cst = "_",
    cst_height_lower_bound$0 = "height_lower_bound",
    cst_incremental$0 = "incremental",
    cst_length$0 = "length",
    cst_nodes_by_height$0 = "nodes_by_height",
    cst_src_recompute_heap_ml = "src/recompute_heap.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos = "src/recompute_heap.ml:38:22",
    Incremental_Import = global_data.Incremental__Import,
    Assert_failure = global_data.Assert_failure,
    Core = global_data.Core,
    Incremental_Node = global_data.Incremental__Node,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Recompute_heap$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_recompute_heap_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "recompute_heap.ml");
   var
    _z_ = [0, cst_src_recompute_heap_ml, 172, 16],
    cst_Recompute_heap_remove_min_ =
      "Recompute_heap.remove_min unexpectedly reached end of heap",
    _A_ = [0, cst_src_recompute_heap_ml, 180, 5948, 5962],
    _B_ = [0, cst_src_recompute_heap_ml, 192, 16],
    _y_ = [0, cst_src_recompute_heap_ml, 153, 4],
    _x_ = [0, cst_src_recompute_heap_ml, 154, 4],
    _w_ = [0, cst_src_recompute_heap_ml, 155, 4],
    _u_ = [0, cst],
    cst_incorrect_remove_of_node_f =
      "incorrect [remove] of node from recompute heap",
    _v_ = [0, cst_src_recompute_heap_ml, 140, 4716, 4728],
    _r_ = [0, cst],
    cst_incorrect_attempt_to_add_n =
      "incorrect attempt to add node to recompute heap",
    _s_ = [0, cst_src_recompute_heap_ml, 125, 4239, 4251],
    _t_ = [0, cst_src_recompute_heap_ml, 129, 16],
    _q_ = [0, cst_src_recompute_heap_ml, 99, 16],
    _p_ = [0, cst_src_recompute_heap_ml, 62, 6],
    _n_ = [0, cst_src_recompute_heap_ml, 41, 11],
    _m_ = [0, cst_src_recompute_heap_ml, 42, 11],
    _l_ = [0, cst_src_recompute_heap_ml, 44, 13],
    _k_ = [0, cst_src_recompute_heap_ml, 50, 15],
    _j_ = [0, cst_src_recompute_heap_ml, 51, 15],
    _o_ = [0, cst_src_recompute_heap_ml, 30, 894, 916],
    _g_ = [0, cst_nodes_by_height$0],
    _h_ = [0, cst_height_lower_bound$0],
    _i_ = [0, cst_length$0],
    cst_nodes_by_height = cst_nodes_by_height$0,
    cst_height_lower_bound = cst_height_lower_bound$0,
    cst_length = cst_length$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Recompute_heap = cst_Incremental_Recompute_heap$0;
   function next(param){return param[17];}
   var As_recompute_list = caml_call1(Incremental_Node[1][3], [0, next]);
   function nodes_by_height(r){return r[3];}
   function set_nodes_by_height(r, v){r[3] = v; return 0;}
   function height_lower_bound(r){return r[2];}
   function set_height_lower_bound(r, v){r[2] = v; return 0;}
   function length(r){return r[1];}
   function set_length(r, v){r[1] = v; return 0;}
   function _a_(r, v){return [0, r[1], r[2], v];}
   var
    _b_ = [0, set_nodes_by_height],
    nodes_by_height$0 =
      [0,
       function(param){return 0;},
       cst_nodes_by_height,
       _b_,
       nodes_by_height,
       _a_];
   function _c_(r, v){return [0, r[1], v, r[3]];}
   var
    _d_ = [0, set_height_lower_bound],
    height_lower_bound$0 =
      [0,
       function(param){return 0;},
       cst_height_lower_bound,
       _d_,
       height_lower_bound,
       _c_];
   function _e_(r, v){return [0, v, r[2], r[3]];}
   var
    _f_ = [0, set_length],
    length$0 = [0, function(param){return 0;}, cst_length, _f_, length, _e_];
   function sexp_of_t(param){
    var
     length_003 = param[1],
     height_lower_bound_005 = param[2],
     nodes_by_height_007 = param[3],
     max_nonempty_index = [0, -1],
     bnds_002 = 0;
    function _al_(i, l){
     var
      _am_ = caml_call1(Incremental_Import[6][8], l),
      _an_ = _am_ ? (max_nonempty_index[1] = i, 0) : _am_;
     return _an_;
    }
    caml_call2(Incremental_Import[7][30], nodes_by_height_007, _al_);
    var
     x_001 =
       caml_call3
        (Incremental_Import[7][42],
         nodes_by_height_007,
         0,
         max_nonempty_index[1] + 1 | 0),
     arg_008 =
       caml_call2(Incremental_Import[7][10], As_recompute_list[1], x_001),
     bnds_002$0 = [0, [1, [0, _g_, [0, arg_008, 0]]], bnds_002],
     arg_006 = caml_call1(Core[389], height_lower_bound_005),
     bnds_002$1 = [0, [1, [0, _h_, [0, arg_006, 0]]], bnds_002$0],
     arg_004 = caml_call1(Core[389], length_003),
     bnds_002$2 = [0, [1, [0, _i_, [0, arg_004, 0]]], bnds_002$1];
    return [1, bnds_002$2];
   }
   function max_height_allowed(t){
    return caml_call1(Incremental_Import[7][19], t[3]) - 1 | 0;
   }
   function invariant(t){
    function _ab_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      nodes_by_height_fun =
        check
         (function(nodes_by_height){
           function _aj_(height, node){
            function _ak_(node){
             if(! caml_call2(Core[90], node[15], height))
              throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
             if(caml_call1(Incremental_Node[20], node)) return 0;
             throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
            }
            return caml_call2(As_recompute_list[4], node, _ak_);
           }
           return caml_call2(Incremental_Import[7][30], nodes_by_height, _aj_);
          }),
      height_lower_bound_fun =
        check
         (function(height_lower_bound){
           if(! caml_call2(Core[88], height_lower_bound, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
           var _ae_ = caml_call1(Incremental_Import[7][19], t[3]);
           if(! caml_call2(Core[89], height_lower_bound, _ae_))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
           var _ag_ = height_lower_bound - 1 | 0, _af_ = 0;
           if(_ag_ >= 0){
            var height = _af_;
            for(;;){
             var _ah_ = caml_call2(Incremental_Import[7][20], t[3], height);
             if(! caml_call1(Incremental_Import[6][7], _ah_))
              throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
             var _ai_ = height + 1 | 0;
             if(_ag_ === height) break;
             var height = _ai_;
            }
           }
           return 0;
          }),
      length_fun =
        check
         (function(length){
           var actual_length = [0, 0];
           function _ac_(node){
            var _ad_ = caml_call1(As_recompute_list[3], node);
            actual_length[1] = actual_length[1] + _ad_ | 0;
            return 0;
           }
           caml_call2(Incremental_Import[7][29], t[3], _ac_);
           var
            t2 = actual_length[1],
            sexpifier = Core[389],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_009, b_010){
            return caml_call2(Core[382], a_009, b_010);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[2],
                    pos,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    length,
                    t2);
          });
     caml_call1(length_fun, length$0);
     caml_call1(height_lower_bound_fun, height_lower_bound$0);
     return caml_call1(nodes_by_height_fun, nodes_by_height$0);
    }
    return caml_call4(Base_Invariant[1], _o_, t, sexp_of_t, _ab_);
   }
   function create_nodes_by_height(max_height_allowed){
    return caml_call2
            (Incremental_Import[7][16],
             max_height_allowed + 1 | 0,
             Incremental_Import[6][5]);
   }
   function set_max_height_allowed(t, max_height_allowed){
    if(Incremental_Import[1]){
     var
      _V_ = max_height_allowed + 1 | 0,
      _W_ = caml_call1(Incremental_Import[7][19], t[3]) - 1 | 0;
     if(_W_ >= _V_){
      var i = _V_;
      for(;;){
       var _$_ = caml_call2(Incremental_Import[7][20], t[3], i);
       if(! caml_call1(Incremental_Import[6][7], _$_))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
       var _aa_ = i + 1 | 0;
       if(_W_ === i) break;
       var i = _aa_;
      }
     }
    }
    var
     src = t[3],
     dst = create_nodes_by_height(max_height_allowed),
     _X_ = caml_call1(Incremental_Import[7][19], dst),
     _Y_ = caml_call1(Incremental_Import[7][19], src),
     _Z_ = caml_call2(Core[96], _Y_, _X_);
    caml_call5(Incremental_Import[7][39], src, 0, dst, 0, _Z_);
    t[3] = dst;
    var ___ = caml_call1(Incremental_Import[7][19], dst);
    t[2] = caml_call2(Core[96], t[2], ___);
    return 0;
   }
   function create(max_height_allowed){
    return [0,
            0,
            max_height_allowed + 1 | 0,
            create_nodes_by_height(max_height_allowed)];
   }
   function set_prev(next, prev){
    if(caml_call1(Incremental_Import[6][8], next))
     caml_call1(Incremental_Import[6][16], next)[16] = prev;
    return;
   }
   function link(t, node){
    var height = node[14];
    if(Incremental_Import[1]){
     var _T_ = max_height_allowed(t);
     if(! caml_call2(Core[89], height, _T_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
    }
    node[15] = height;
    var next = caml_call2(Incremental_Import[7][20], t[3], height);
    node[17] = next;
    set_prev(next, caml_call1(Incremental_Import[6][6], node));
    var _U_ = caml_call1(Incremental_Import[6][6], node);
    return caml_call3(Incremental_Import[7][74], t[3], height, _U_);
   }
   function unlink(t, node){
    var
     prev = node[16],
     next = node[17],
     _S_ = caml_call2(Incremental_Import[7][20], t[3], node[15]);
    if(caml_call1(Incremental_Import[6][6], node) === _S_)
     caml_call3(Incremental_Import[7][74], t[3], node[15], next);
    set_prev(next, prev);
    if(caml_call1(Incremental_Import[6][8], prev))
     caml_call1(Incremental_Import[6][16], prev)[17] = next;
    node[16] = Incremental_Import[6][5];
    return;
   }
   function add(t, node){
    var _M_ = Incremental_Import[1];
    if(_M_)
     var
      _N_ = caml_call1(Incremental_Node[14], node),
      _O_ = _N_ || 1 - caml_call1(Incremental_Node[20], node);
    else
     var _O_ = _M_;
    if(_O_){
     var
      _P_ =
        function(x_011){
         function _R_(param){return _r_;}
         return caml_call2(Incremental_Node[2], _R_, x_011);
        };
     caml_call5(Core[247], 0, _s_, cst_incorrect_attempt_to_add_n, node, _P_);
    }
    if(Incremental_Import[1]){
     var _Q_ = max_height_allowed(t);
     if(! caml_call2(Core[89], node[14], _Q_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
    }
    var height = node[14];
    if(caml_call2(Core[92], height, t[2])) t[2] = height;
    link(t, node);
    t[1] = t[1] + 1 | 0;
    return 0;
   }
   function remove(t, node){
    var _H_ = Incremental_Import[1];
    if(_H_)
     var
      _I_ = 1 - caml_call1(Incremental_Node[14], node),
      _J_ = _I_ || caml_call1(Incremental_Node[20], node);
    else
     var _J_ = _H_;
    if(_J_){
     var
      _K_ =
        function(x_012){
         function _L_(param){return _u_;}
         return caml_call2(Incremental_Node[2], _L_, x_012);
        };
     caml_call5(Core[247], 0, _v_, cst_incorrect_remove_of_node_f, node, _K_);
    }
    unlink(t, node);
    node[17] = Incremental_Import[6][5];
    node[15] = -1;
    t[1] = t[1] - 1 | 0;
    return 0;
   }
   function increase_height(t, node){
    if(Incremental_Import[1]){
     if(! caml_call2(Core[91], node[14], node[15]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
     var _G_ = max_height_allowed(t);
     if(! caml_call2(Core[89], node[14], _G_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
     if(! caml_call1(Incremental_Node[14], node))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
    }
    unlink(t, node);
    return link(t, node);
   }
   function min_height(t){
    if(caml_call2(Core[90], t[1], 0))
     t[2] = caml_call1(Incremental_Import[7][19], t[3]);
    else{
     var nodes_by_height = t[3];
     for(;;){
      var _F_ = caml_call2(Incremental_Import[7][20], nodes_by_height, t[2]);
      if(! caml_call1(Incremental_Import[6][7], _F_)) break;
      t[2] = t[2] + 1 | 0;
     }
    }
    return t[2];
   }
   function remove_min(t){
    if(Incremental_Import[1] && caml_call2(Core[90], t[1], 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
    var
     nodes_by_height = t[3],
     node = [0, caml_call2(Incremental_Import[7][20], nodes_by_height, t[2])];
    for(;;){
     if(! caml_call1(Incremental_Import[6][7], node[1])) break;
     t[2] = t[2] + 1 | 0;
     var _C_ = Incremental_Import[1];
     if(_C_)
      var
       _D_ = caml_call1(Incremental_Import[7][19], t[3]),
       _E_ = caml_call2(Core[88], t[2], _D_);
     else
      var _E_ = _C_;
     if(_E_)
      caml_call5
       (Core[247], 0, _A_, cst_Recompute_heap_remove_min_, t, sexp_of_t);
     node[1] = caml_call2(Incremental_Import[7][20], nodes_by_height, t[2]);
    }
    var node$0 = caml_call1(Incremental_Import[6][16], node[1]);
    node$0[15] = -1;
    t[1] = t[1] - 1 | 0;
    var next = node$0[17];
    caml_call3(Incremental_Import[7][75], t[3], t[2], next);
    set_prev(next, Incremental_Import[6][5]);
    if
     (Incremental_Import[1]
      && ! caml_call1(Incremental_Import[6][7], node$0[16]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
    node$0[17] = Incremental_Import[6][5];
    return node$0;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Recompute_heap);
   var
    Incremental_Recompute_heap =
      [0,
       sexp_of_t,
       invariant,
       create,
       length,
       max_height_allowed,
       set_max_height_allowed,
       min_height,
       add,
       remove,
       remove_min,
       increase_height];
   runtime.caml_register_global
    (46, Incremental_Recompute_heap, cst_Incremental_Recompute_heap$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Adjust_heights_heap
//# unitInfo: Requires: Base__Invariant, Core, Incremental__Import, Incremental__Node, Incremental__Recompute_heap, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Adjust_heights$0 = "Incremental__Adjust_heights_heap",
    cst = "_",
    cst_height_lower_bound$0 = "height_lower_bound",
    cst_incremental$0 = "incremental",
    cst_length$0 = "length",
    cst_max_height_seen$0 = "max_height_seen",
    cst_nodes_by_height$0 = "nodes_by_height",
    cst_src_adjust_heights_heap_ml = "src/adjust_heights_heap.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Incremental_Import = global_data.Incremental__Import,
    Assert_failure = global_data.Assert_failure,
    Core = global_data.Core,
    Incremental_Node = global_data.Incremental__Node,
    Incremental_Recompute_heap = global_data.Incremental__Recompute_heap,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Adjust_heights$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_adjust_heights_heap_ml);
   caml_call2
    (Ppx_inline_test_lib[6], cst_incremental$0, "adjust_heights_heap.ml");
   var
    _Q_ = [0, cst_src_adjust_heights_heap_ml, 163, 16],
    _P_ = [0, cst_src_adjust_heights_heap_ml, 164, 16],
    _O_ = [0, cst_src_adjust_heights_heap_ml, 203, 16],
    _N_ = [0, cst_src_adjust_heights_heap_ml, 204, 16],
    _I_ = [0, cst],
    _G_ = [0, cst],
    _H_ = [0, "child"],
    _J_ = [0, "parent"],
    _M_ = [0, cst_src_adjust_heights_heap_ml, 139, 16],
    _L_ = [0, cst_src_adjust_heights_heap_ml, 140, 16],
    cst_adding_edge_made_graph_cyc = "adding edge made graph cyclic",
    _K_ = [0, cst_src_adjust_heights_heap_ml, 144, 5086, 5098],
    _D_ = [0, "Height"],
    _E_ = [0, "Max"],
    cst_node_with_too_large_height = "node with too large height",
    _F_ = [0, cst_src_adjust_heights_heap_ml, 131, 4645, 4659],
    cst_Adjust_heights_heap_remove =
      "Adjust_heights_heap.remove_min of empty heap",
    _C_ = [0, cst_src_adjust_heights_heap_ml, 109, 3886, 3906],
    _B_ = [0, cst_src_adjust_heights_heap_ml, 97, 18],
    _A_ = [0, cst_src_adjust_heights_heap_ml, 99, 18],
    _x_ = [0, cst_max_height_seen$0],
    cst_cannot_set_max_height_allo =
      "cannot set_max_height_allowed less than the max height already seen",
    _y_ = [0, cst_src_adjust_heights_heap_ml, 83, 2754, 2766],
    _z_ = [0, cst_src_adjust_heights_heap_ml, 87, 16],
    _v_ = [0, cst_src_adjust_heights_heap_ml, 56, 30],
    _u_ = [0, cst_src_adjust_heights_heap_ml, 59, 11],
    _t_ = [0, cst_src_adjust_heights_heap_ml, 60, 11],
    _s_ = [0, cst_src_adjust_heights_heap_ml, 62, 13],
    _r_ = [0, cst_src_adjust_heights_heap_ml, 66, 11],
    _q_ = [0, cst_src_adjust_heights_heap_ml, 67, 11],
    _w_ = [0, cst_src_adjust_heights_heap_ml, 52, 1642, 1664],
    _m_ = [0, cst_nodes_by_height$0],
    _n_ = [0, cst_max_height_seen$0],
    _o_ = [0, cst_height_lower_bound$0],
    _p_ = [0, cst_length$0],
    _c_ = [0, cst_src_adjust_heights_heap_ml, 23, 10],
    _b_ = [0, cst_src_adjust_heights_heap_ml, 24, 10],
    _a_ = [0, cst_src_adjust_heights_heap_ml, 26, 15],
    _d_ = [0, cst_src_adjust_heights_heap_ml, 19, 534, 558],
    cst_nodes_by_height = cst_nodes_by_height$0,
    cst_max_height_seen = cst_max_height_seen$0,
    cst_height_lower_bound = cst_height_lower_bound$0,
    cst_length = cst_length$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Adjust_heights = cst_Incremental_Adjust_heights$0;
   function next(param){return param[19];}
   var As_adjust_heights_list = caml_call1(Incremental_Node[1][3], [0, next]);
   function sexp_of_t(t){
    var max_nonempty_index = [0, -1];
    function _ay_(i, l){
     var
      _az_ = caml_call1(Incremental_Import[6][8], l),
      _aA_ = _az_ ? (max_nonempty_index[1] = i, 0) : _az_;
     return _aA_;
    }
    caml_call2(Incremental_Import[7][30], t, _ay_);
    var
     x_001 =
       caml_call3
        (Incremental_Import[7][42], t, 0, max_nonempty_index[1] + 1 | 0);
    return caml_call2
            (Incremental_Import[7][10], As_adjust_heights_list[1], x_001);
   }
   function invariant(t){
    function _au_(param){
     function _av_(height, nodes){
      caml_call1(As_adjust_heights_list[2], nodes);
      function _aw_(node){
       if(! caml_call2(Core[90], node[18], height))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       if(! caml_call2(Core[91], node[14], node[18]))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
       var _ax_ = caml_call1(Incremental_Node[14], node);
       if(! _ax_) return _ax_;
       if(caml_call2(Core[90], node[15], node[18])) return 0;
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      }
      return caml_call2(As_adjust_heights_list[4], nodes, _aw_);
     }
     return caml_call2(Incremental_Import[7][30], t, _av_);
    }
    return caml_call4(Base_Invariant[1], _d_, t, sexp_of_t, _au_);
   }
   function create(max_height_allowed){
    return caml_call2
            (Incremental_Import[7][16],
             max_height_allowed + 1 | 0,
             Incremental_Import[6][5]);
   }
   function nodes_by_height(r){return r[4];}
   function set_nodes_by_height(r, v){r[4] = v; return 0;}
   function max_height_seen(r){return r[3];}
   function set_max_height_seen(r, v){r[3] = v; return 0;}
   function height_lower_bound(r){return r[2];}
   function set_height_lower_bound(r, v){r[2] = v; return 0;}
   function length(r){return r[1];}
   function set_length(r, v){r[1] = v; return 0;}
   function _e_(r, v){return [0, r[1], r[2], r[3], v];}
   var
    _f_ = [0, set_nodes_by_height],
    nodes_by_height$0 =
      [0,
       function(param){return 0;},
       cst_nodes_by_height,
       _f_,
       nodes_by_height,
       _e_];
   function _g_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _h_ = [0, set_max_height_seen],
    max_height_seen$0 =
      [0,
       function(param){return 0;},
       cst_max_height_seen,
       _h_,
       max_height_seen,
       _g_];
   function _i_(r, v){return [0, r[1], v, r[3], r[4]];}
   var
    _j_ = [0, set_height_lower_bound],
    height_lower_bound$0 =
      [0,
       function(param){return 0;},
       cst_height_lower_bound,
       _j_,
       height_lower_bound,
       _i_];
   function _k_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _l_ = [0, set_length],
    length$0 = [0, function(param){return 0;}, cst_length, _l_, length, _k_];
   function sexp_of_t$0(param){
    var
     length_003 = param[1],
     height_lower_bound_005 = param[2],
     max_height_seen_007 = param[3],
     nodes_by_height_009 = param[4],
     arg_010 = sexp_of_t(nodes_by_height_009),
     bnds_002 = [0, [1, [0, _m_, [0, arg_010, 0]]], 0],
     arg_008 = caml_call1(Core[389], max_height_seen_007),
     bnds_002$0 = [0, [1, [0, _n_, [0, arg_008, 0]]], bnds_002],
     arg_006 = caml_call1(Core[389], height_lower_bound_005),
     bnds_002$1 = [0, [1, [0, _o_, [0, arg_006, 0]]], bnds_002$0],
     arg_004 = caml_call1(Core[389], length_003),
     bnds_002$2 = [0, [1, [0, _p_, [0, arg_004, 0]]], bnds_002$1];
    return [1, bnds_002$2];
   }
   function is_empty(t){return caml_call2(Core[90], t[1], 0);}
   function max_height_allowed(t){
    return caml_call1(Incremental_Import[7][19], t[4]) - 1 | 0;
   }
   function invariant$0(t){
    function _al_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      nodes_by_height_fun = check(invariant),
      max_height_seen_fun =
        check
         (function(max_height_seen){
           if(! caml_call2(Core[88], max_height_seen, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
           var _at_ = max_height_allowed(t);
           if(caml_call2(Core[89], max_height_seen, _at_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
          }),
      height_lower_bound_fun =
        check
         (function(height_lower_bound){
           if(! caml_call2(Core[88], height_lower_bound, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
           var _ao_ = caml_call1(Incremental_Import[7][19], t[4]);
           if(! caml_call2(Core[89], height_lower_bound, _ao_))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
           var _aq_ = height_lower_bound - 1 | 0, _ap_ = 0;
           if(_aq_ >= 0){
            var height = _ap_;
            for(;;){
             var _ar_ = caml_call2(Incremental_Import[7][20], t[4], height);
             if(! caml_call1(Incremental_Import[6][7], _ar_))
              throw caml_maybe_attach_backtrace([0, Assert_failure, _s_], 1);
             var _as_ = height + 1 | 0;
             if(_aq_ === height) break;
             var height = _as_;
            }
           }
           return 0;
          }),
      length_fun =
        check
         (function(length){
           var t$0 = t[4], r = [0, 0];
           function _am_(node){
            var _an_ = caml_call1(As_adjust_heights_list[3], node);
            r[1] = r[1] + _an_ | 0;
            return 0;
           }
           caml_call2(Incremental_Import[7][29], t$0, _am_);
           if(caml_call2(Core[90], length, r[1])) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
          });
     caml_call1(length_fun, length$0);
     caml_call1(height_lower_bound_fun, height_lower_bound$0);
     caml_call1(max_height_seen_fun, max_height_seen$0);
     return caml_call1(nodes_by_height_fun, nodes_by_height$0);
    }
    return caml_call4(Base_Invariant[1], _w_, t, sexp_of_t$0, _al_);
   }
   function create$0(max_height_allowed){
    return [0, 0, max_height_allowed + 1 | 0, 0, create(max_height_allowed)];
   }
   function set_max_height_allowed(t, max_height_allowed){
    if(caml_call2(Core[92], max_height_allowed, t[3])){
     var
      _ak_ =
        function(param){
         var
          arg1_013 = param[2],
          arg0_012 = param[1],
          res0_014 = caml_call1(Core[389], arg0_012),
          v_011 = arg1_013[2],
          res1_015 = [1, [0, _x_, [0, caml_call1(Core[389], v_011), 0]]];
         return [1, [0, res0_014, [0, res1_015, 0]]];
        };
     caml_call5
      (Core[247],
       0,
       _y_,
       cst_cannot_set_max_height_allo,
       [0, max_height_allowed, [0, -794774856, t[3]]],
       _ak_);
    }
    if(Incremental_Import[1] && ! is_empty(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
    t[4] = create(max_height_allowed);
    return 0;
   }
   function set_height(t, node, height){
    if(caml_call2(Core[91], height, t[3])){
     t[3] = height;
     var _ah_ = max_height_allowed(t);
     if(caml_call2(Core[91], height, _ah_)){
      var
       _ai_ =
         function(param){
          var
           arg1_019 = param[2],
           arg0_018 = param[1],
           v_016 = arg0_018[2],
           res0_020 = [1, [0, _D_, [0, caml_call1(Core[389], v_016), 0]]],
           v_017 = arg1_019[2],
           res1_021 = [1, [0, _E_, [0, caml_call1(Core[389], v_017), 0]]];
          return [1, [0, res0_020, [0, res1_021, 0]]];
         },
       _aj_ = [0, [0, 920681479, height], [0, 3850884, max_height_allowed(t)]];
      caml_call5
       (Core[247], 0, _F_, cst_node_with_too_large_height, _aj_, _ai_);
     }
    }
    node[14] = height;
    return 0;
   }
   function ensure_height_requirement
   (t, original_child, original_parent, child, parent){
    if(Incremental_Import[1] && ! caml_call1(Incremental_Node[15], child))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
    if(Incremental_Import[1] && ! caml_call1(Incremental_Node[15], parent))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
    if(caml_call2(Incremental_Node[7], parent, original_child)){
     var
      _ab_ =
        function(param){
         var
          arg1_025 = param[2],
          arg0_024 = param[1],
          v_022 = arg0_024[2],
          _ad_ = 0;
         function _ae_(param){return _G_;}
         var
          res0_026 =
            [1,
             [0, _H_, [0, caml_call2(Incremental_Node[2], _ae_, v_022), _ad_]]],
          v_023 = arg1_025[2],
          _af_ = 0;
         function _ag_(param){return _I_;}
         var
          res1_027 =
            [1,
             [0, _J_, [0, caml_call2(Incremental_Node[2], _ag_, v_023), _af_]]];
         return [1, [0, res0_026, [0, res1_027, 0]]];
        };
     caml_call5
      (Core[247],
       0,
       _K_,
       cst_adding_edge_made_graph_cyc,
       [0, [0, -977688164, original_child], [0, -310508246, original_parent]],
       _ab_);
    }
    var _ac_ = caml_call2(Core[88], child[14], parent[14]);
    if(! _ac_) return _ac_;
    if(caml_call2(Core[90], parent[18], -1)){
     var height = parent[14];
     if(Incremental_Import[1] && ! caml_call2(Core[88], height, t[2]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
     if(Incremental_Import[1]){
      var _$_ = max_height_allowed(t);
      if(! caml_call2(Core[89], height, _$_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     }
     parent[18] = height;
     t[1] = t[1] + 1 | 0;
     parent[19] = caml_call2(Incremental_Import[7][20], t[4], height);
     var _aa_ = caml_call1(Incremental_Import[6][6], parent);
     caml_call3(Incremental_Import[7][74], t[4], height, _aa_);
    }
    return set_height(t, parent, child[14] + 1 | 0);
   }
   function adjust_heights(t, recompute_heap, original_child, original_parent){
    if(Incremental_Import[1] && ! is_empty(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _Q_], 1);
    if
     (Incremental_Import[1]
      && ! caml_call2(Core[88], original_child[14], original_parent[14]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
    t[2] = original_parent[14];
    ensure_height_requirement
     (t, original_child, original_parent, original_child, original_parent);
    for(;;){
     if(! caml_call2(Core[91], t[1], 0)){
      if(Incremental_Import[1] && ! is_empty(t))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _O_], 1);
      var ___ = Incremental_Import[1];
      if(! ___) return ___;
      if(caml_call2(Core[92], original_child[14], original_parent[14]))
       return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _N_], 1);
     }
     var _R_ = Incremental_Import[1], _S_ = _R_ ? is_empty(t) : _R_;
     if(_S_)
      caml_call5
       (Core[247], 0, _C_, cst_Adjust_heights_heap_remove, t, sexp_of_t$0);
     var r = [0, t[2]];
     for(;;){
      var _T_ = caml_call2(Incremental_Import[7][20], t[4], r[1]);
      if(! caml_call1(Incremental_Import[6][7], _T_)) break;
      r[1]++;
     }
     var height = r[1];
     t[2] = height;
     var
      _U_ = caml_call2(Incremental_Import[7][21], t[4], height),
      child = caml_call1(Incremental_Import[6][16], _U_);
     child[18] = -1;
     t[1] = t[1] - 1 | 0;
     caml_call3(Incremental_Import[7][74], t[4], height, child[19]);
     child[19] = Incremental_Import[6][5];
     if(caml_call1(Incremental_Node[14], child))
      caml_call2(Incremental_Recompute_heap[11], recompute_heap, child);
     if(caml_call2(Core[91], child[9], 0)){
      var parent = caml_call1(Incremental_Import[6][9], child[11]);
      ensure_height_requirement
       (t, original_child, original_parent, child, parent);
      var _W_ = child[9] - 1 | 0, _V_ = 1;
      if(_W_ >= 1){
       var parent_index = _V_;
       for(;;){
        var
         _Y_ =
           caml_call2
            (Incremental_Import[7][20], child[10], parent_index - 1 | 0);
        ensure_height_requirement
         (t,
          original_child,
          original_parent,
          child,
          caml_call1(Incremental_Import[6][9], _Y_));
        var _Z_ = parent_index + 1 | 0;
        if(_W_ === parent_index) break;
        var parent_index = _Z_;
       }
      }
     }
     var _X_ = child[5];
     a:
     if(typeof _X_ !== "number" && 3 === _X_[0]){
      var
       all_nodes_created_on_rhs = _X_[1][7],
       r$0 = [0, all_nodes_created_on_rhs];
      for(;;){
       if(! caml_call1(Incremental_Import[6][8], r$0[1])) break;
       var node_on_rhs = caml_call1(Incremental_Import[6][16], r$0[1]);
       r$0[1] = node_on_rhs[13];
       if(caml_call1(Incremental_Node[15], node_on_rhs))
        ensure_height_requirement
         (t, original_child, original_parent, child, node_on_rhs);
      }
      break a;
     }
    }
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Adjust_heights);
   var
    Incremental_Adjust_heights_hea =
      [0,
       sexp_of_t$0,
       invariant$0,
       create$0,
       length,
       max_height_allowed,
       set_max_height_allowed,
       max_height_seen,
       set_height,
       adjust_heights];
   runtime.caml_register_global
    (60, Incremental_Adjust_heights_hea, cst_Incremental_Adjust_heights$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Alarm_value
//# unitInfo: Requires: Base__Invariant, Incremental__At, Incremental__At_intervals, Incremental__Import, Incremental__Snapshot, Incremental__Step_function_node, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Alarm_value$0 = "Incremental__Alarm_value",
    cst = "_",
    cst_action$0 = "action",
    cst_incremental$0 = "incremental",
    cst_src_alarm_value_ml = "src/alarm_value.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Incremental_Import = global_data.Incremental__Import,
    Base_Invariant = global_data.Base__Invariant,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_At = global_data.Incremental__At,
    Incremental_At_intervals = global_data.Incremental__At_intervals,
    Incremental_Snapshot = global_data.Incremental__Snapshot,
    Incremental_Step_function_node =
      global_data.Incremental__Step_function_node,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Alarm_value$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_alarm_value_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "alarm_value.ml");
   var
    _k_ = [0, cst_src_alarm_value_ml, 30, 836, 858],
    _i_ = [0, "next_fired"],
    _j_ = [0, cst_action$0],
    _e_ = [0, cst],
    _c_ = [0, cst],
    _a_ = [0, "At"],
    _b_ = [0, "At_intervals"],
    _d_ = [0, "Snapshot"],
    _f_ = [0, "Step_function"],
    cst_action = cst_action$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Alarm_value = cst_Incremental_Alarm_value$0;
   function invariant(param){
    switch(param[0]){
      case 0:
       var at = param[1]; return caml_call1(Incremental_At[1], at);
      case 1:
       var at_intervals = param[1];
       return caml_call1(Incremental_At_intervals[1], at_intervals);
      case 2:
       var snapshot = param[1], _o_ = function(_r_){return 0;};
       return caml_call2(Incremental_Snapshot[1], _o_, snapshot);
      default:
       var step_function_node = param[1], _p_ = function(_q_){return 0;};
       return caml_call2
               (Incremental_Step_function_node[1], _p_, step_function_node);
    }
   }
   function action(r){return r[1];}
   function _g_(r, v){return [0, v, r[2]];}
   var
    _h_ = 0,
    action$0 = [0, function(param){return 0;}, cst_action, _h_, action, _g_];
   function sexp_of_t(param){
    var
     action_010 = param[1],
     next_fired_012 = param[2],
     arg_013 = caml_call1(Sexplib0_Sexp_conv[23], next_fired_012),
     bnds_009 = [0, [1, [0, _i_, [0, arg_013, 0]]], 0];
    switch(action_010[0]){
      case 0:
       var
        arg0_001 = action_010[1],
        res0_002 = caml_call1(Incremental_At[2], arg0_001),
        arg_011 = [1, [0, _a_, [0, res0_002, 0]]];
       break;
      case 1:
       var
        arg0_003 = action_010[1],
        res0_004 = caml_call1(Incremental_At_intervals[2], arg0_003),
        arg_011 = [1, [0, _b_, [0, res0_004, 0]]];
       break;
      case 2:
       var
        arg0_005 = action_010[1],
        _m_ = function(param){return _c_;},
        res0_006 = caml_call2(Incremental_Snapshot[2], _m_, arg0_005),
        arg_011 = [1, [0, _d_, [0, res0_006, 0]]];
       break;
      default:
       var
        arg0_007 = action_010[1],
        _n_ = function(param){return _e_;},
        res0_008 =
          caml_call2(Incremental_Step_function_node[2], _n_, arg0_007),
        arg_011 = [1, [0, _f_, [0, res0_008, 0]]];
    }
    var bnds_009$0 = [0, [1, [0, _j_, [0, arg_011, 0]]], bnds_009];
    return [1, bnds_009$0];
   }
   function invariant$0(t){
    function _l_(param){
     var action_fun = caml_call2(Base_Invariant[2], t, invariant);
     caml_call1(action_fun, action$0);
     return 0;
    }
    return caml_call4(Base_Invariant[1], _k_, t, sexp_of_t, _l_);
   }
   function create(action){return [0, action, Incremental_Import[6][5]];}
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Alarm_value);
   var Incremental_Alarm_value = [0, [0], invariant$0, sexp_of_t, create];
   runtime.caml_register_global
    (29, Incremental_Alarm_value, cst_Incremental_Alarm_value$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Config_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Config_intf = "Incremental__Config_intf",
    cst_incremental = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Config_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][1], "src/config_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental, "config_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Config_intf);
   var Incremental_Config_intf = [0];
   runtime.caml_register_global
    (11, Incremental_Config_intf, cst_Incremental_Config_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Config
//# unitInfo: Requires: Incremental__Config_intf, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Config$0 = "Incremental__Config",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Config$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/config.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "config.ml");
   var
    cst_incremental = cst_incremental$0,
    cst_Incremental_Config = cst_Incremental_Config$0;
   function Default(symbol){return [0, 1];}
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Config);
   var Incremental_Config = [0, Default];
   runtime.caml_register_global
    (11, Incremental_Config, cst_Incremental_Config$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Internal_observer
//# unitInfo: Requires: Base__Invariant, Core, Core__List, Incremental__Import, Incremental__Node, Incremental__On_update_handler, Incremental__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Internal_obser$0 = "Incremental__Internal_observer",
    cst = "_",
    cst_incremental$0 = "incremental",
    cst_next_in_all$0 = "next_in_all",
    cst_next_in_observing$0 = "next_in_observing",
    cst_observing$0 = "observing",
    cst_on_update_handlers$0 = "on_update_handlers",
    cst_prev_in_all$0 = "prev_in_all",
    cst_prev_in_observing$0 = "prev_in_observing",
    cst_src_internal_observer_ml = "src/internal_observer.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Incremental_Import = global_data.Incremental__Import,
    Core_List = global_data.Core__List,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Incremental_Node = global_data.Incremental__Node,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_On_update_handler = global_data.Incremental__On_update_handler,
    Incremental_Types = global_data.Incremental__Types,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Internal_obser$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_internal_observer_ml);
   caml_call2
    (Ppx_inline_test_lib[6], cst_incremental$0, "internal_observer.ml");
   var
    _S_ = [0, cst],
    _P_ = [0, cst],
    cst_on_update_disallowed = "on_update disallowed",
    _Q_ = [0, cst_src_internal_observer_ml, 142, 4451, 4471],
    _R_ = [0, cst_src_internal_observer_ml, 146, 32],
    _J_ = [0, cst],
    _N_ = [0, cst],
    _L_ = [0, cst],
    cst_Observer_value_exn_called_ =
      "Observer.value_exn called after disallow_future_use",
    _M_ = [0, cst_src_internal_observer_ml, 127, 4041, 4053],
    cst_Observer_value_exn_called_$0 =
      "Observer.value_exn called without stabilizing",
    _O_ = [0, cst_src_internal_observer_ml, 121, 3894, 3906],
    cst_attempt_to_get_value_of_an = "attempt to get value of an invalid node",
    _K_ = [0, cst_src_internal_observer_ml, 135, 4239, 4261],
    _H_ = [0, cst],
    _G_ = [0, cst_src_internal_observer_ml, 70, 25],
    _F_ = [0, cst_src_internal_observer_ml, 75, 36],
    _E_ = [0, cst_src_internal_observer_ml, 78, 13],
    _D_ = [0, cst_src_internal_observer_ml, 86, 36],
    _C_ = [0, cst_src_internal_observer_ml, 89, 13],
    _B_ = [0, cst_src_internal_observer_ml, 97, 36],
    _A_ = [0, cst_src_internal_observer_ml, 100, 13],
    _z_ = [0, cst_src_internal_observer_ml, 108, 36],
    _y_ = [0, cst_src_internal_observer_ml, 111, 13],
    _I_ = [0, cst_src_internal_observer_ml, 61, 1712, 1734],
    _r_ = [0, cst_next_in_observing$0],
    _s_ = [0, cst_prev_in_observing$0],
    _t_ = [0, cst_next_in_all$0],
    _u_ = [0, cst_prev_in_all$0],
    _v_ = [0, cst_on_update_handlers$0],
    _w_ = [0, cst_observing$0],
    _x_ = [0, "state"],
    _b_ = [0, "Created"],
    _c_ = [0, "In_use"],
    _d_ = [0, "Disallowed"],
    _e_ = [0, "Unlinked"],
    _a_ = [0, cst],
    cst_next_in_observing = cst_next_in_observing$0,
    cst_prev_in_observing = cst_prev_in_observing$0,
    cst_next_in_all = cst_next_in_all$0,
    cst_prev_in_all = cst_prev_in_all$0,
    cst_on_update_handlers = cst_on_update_handlers$0,
    cst_observing = cst_observing$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_Internal_obser = cst_Incremental_Internal_obser$0;
   function sexp_of_t(param){
    var x_001 = param[2];
    function _al_(param){return _a_;}
    return caml_call2(Incremental_Types[15][1], _al_, x_001);
   }
   function next_in_all(param){return param[5];}
   function set_prev_in_all(param, t2){param[4] = t2; return 0;}
   function next_in_observing(r){return r[7];}
   function set_next_in_observing(r, v){r[7] = v; return 0;}
   function prev_in_observing(r){return r[6];}
   function set_prev_in_observing(r, v){r[6] = v; return 0;}
   function next_in_all$0(r){return r[5];}
   function set_next_in_all(r, v){r[5] = v; return 0;}
   function prev_in_all(r){return r[4];}
   function set_prev_in_all$0(r, v){r[4] = v; return 0;}
   function on_update_handlers(r){return r[3];}
   function set_on_update_handlers(r, v){r[3] = v; return 0;}
   function observing(r){return r[2];}
   function _f_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], r[6], v];}
   var
    _g_ = [0, set_next_in_observing],
    next_in_observing$0 =
      [0,
       function(param){return 0;},
       cst_next_in_observing,
       _g_,
       next_in_observing,
       _f_];
   function _h_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v, r[7]];}
   var
    _i_ = [0, set_prev_in_observing],
    prev_in_observing$0 =
      [0,
       function(param){return 0;},
       cst_prev_in_observing,
       _i_,
       prev_in_observing,
       _h_];
   function _j_(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6], r[7]];}
   var
    _k_ = [0, set_next_in_all],
    next_in_all$1 =
      [0,
       function(param){return 0;},
       cst_next_in_all,
       _k_,
       next_in_all$0,
       _j_];
   function _l_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6], r[7]];}
   var
    _m_ = [0, set_prev_in_all$0],
    prev_in_all$0 =
      [0, function(param){return 0;}, cst_prev_in_all, _m_, prev_in_all, _l_];
   function _n_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6], r[7]];}
   var
    _o_ = [0, set_on_update_handlers],
    on_update_handlers$0 =
      [0,
       function(param){return 0;},
       cst_on_update_handlers,
       _o_,
       on_update_handlers,
       _n_];
   function _p_(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6], r[7]];}
   var
    _q_ = 0,
    observing$0 =
      [0, function(param){return 0;}, cst_observing, _q_, observing, _p_];
   function sexp_of_internal_observer(of_a_002, param){
    var
     state_004 = param[1],
     observing_006 = param[2],
     on_update_handlers_008 = param[3],
     prev_in_all_010 = param[4],
     next_in_all_012 = param[5],
     prev_in_observing_014 = param[6],
     next_in_observing_016 = param[7],
     arg_017 =
       caml_call2
        (Incremental_Import[6][2],
         Sexplib0_Sexp_conv[23],
         next_in_observing_016),
     bnds_003 = [0, [1, [0, _r_, [0, arg_017, 0]]], 0],
     arg_015 =
       caml_call2
        (Incremental_Import[6][2],
         Sexplib0_Sexp_conv[23],
         prev_in_observing_014),
     bnds_003$0 = [0, [1, [0, _s_, [0, arg_015, 0]]], bnds_003],
     arg_013 =
       caml_call2(Incremental_Import[6][2], sexp_of_t, next_in_all_012),
     bnds_003$1 = [0, [1, [0, _t_, [0, arg_013, 0]]], bnds_003$0],
     arg_011 =
       caml_call2(Incremental_Import[6][2], sexp_of_t, prev_in_all_010),
     bnds_003$2 = [0, [1, [0, _u_, [0, arg_011, 0]]], bnds_003$1],
     _ak_ = caml_call1(Incremental_On_update_handler[2], of_a_002),
     arg_009 = caml_call2(Core[472], _ak_, on_update_handlers_008),
     bnds_003$3 = [0, [1, [0, _v_, [0, arg_009, 0]]], bnds_003$2],
     arg_007 = caml_call2(Incremental_Node[2], of_a_002, observing_006),
     bnds_003$4 = [0, [1, [0, _w_, [0, arg_007, 0]]], bnds_003$3];
    switch(state_004){
      case 0:
       var arg_005 = _b_; break;
      case 1:
       var arg_005 = _c_; break;
      case 2:
       var arg_005 = _d_; break;
      default: var arg_005 = _e_;
    }
    var bnds_003$5 = [0, [1, [0, _x_, [0, arg_005, 0]]], bnds_003$4];
    return [1, bnds_003$5];
   }
   function incr_state(t){return t[2][2];}
   function use_is_allowed(t){return 2 <= t[1] ? 0 : 1;}
   function same(t1, t2){return t1 === t2 ? 1 : 0;}
   function invariant(invariant_a, t){
    function _aa_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      next_in_observing_fun =
        check
         (function(next_in_observing){
           if
            (1 < t[1] - 1 >>> 0
             && ! caml_call1(Incremental_Import[6][7], next_in_observing))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
           var _ai_ = caml_call1(Incremental_Import[6][8], next_in_observing);
           if(! _ai_) return _ai_;
           var
            _aj_ = caml_call1(Incremental_Import[6][9], next_in_observing)[6];
           if(t === caml_call1(Incremental_Import[6][9], _aj_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
          }),
      prev_in_observing_fun =
        check
         (function(prev_in_observing){
           if
            (1 < t[1] - 1 >>> 0
             && ! caml_call1(Incremental_Import[6][7], prev_in_observing))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
           var _ag_ = caml_call1(Incremental_Import[6][8], prev_in_observing);
           if(! _ag_) return _ag_;
           var
            _ah_ = caml_call1(Incremental_Import[6][9], prev_in_observing)[7];
           if(t === caml_call1(Incremental_Import[6][9], _ah_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
          }),
      next_in_all_fun =
        check
         (function(next_in_all){
           if
            (1 < t[1] - 1 >>> 0
             && ! caml_call1(Incremental_Import[6][7], next_in_all))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
           var _ae_ = caml_call1(Incremental_Import[6][8], next_in_all);
           if(! _ae_) return _ae_;
           var _af_ = caml_call1(Incremental_Import[6][9], next_in_all)[4];
           if(t === caml_call1(Incremental_Import[6][9], _af_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
          }),
      prev_in_all_fun =
        check
         (function(prev_in_all){
           if
            (1 < t[1] - 1 >>> 0
             && ! caml_call1(Incremental_Import[6][7], prev_in_all))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
           var _ac_ = caml_call1(Incremental_Import[6][8], prev_in_all);
           if(! _ac_) return _ac_;
           var _ad_ = caml_call1(Incremental_Import[6][9], prev_in_all)[5];
           if(t === caml_call1(Incremental_Import[6][9], _ad_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
          }),
      on_update_handlers_fun =
        check
         (function(on_update_handlers){
           if(3 > t[1]) return 0;
           if(caml_call1(Core_List[18], on_update_handlers)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _G_], 1);
          }),
      observing_fun = check(caml_call1(Incremental_Node[4], invariant_a));
     caml_call1(observing_fun, observing$0);
     caml_call1(on_update_handlers_fun, on_update_handlers$0);
     caml_call1(prev_in_all_fun, prev_in_all$0);
     caml_call1(next_in_all_fun, next_in_all$1);
     caml_call1(prev_in_observing_fun, prev_in_observing$0);
     return caml_call1(next_in_observing_fun, next_in_observing$0);
    }
    function _ab_(x_020){
     return sexp_of_internal_observer(function(param){return _H_;}, x_020);
    }
    return caml_call4(Base_Invariant[1], _I_, t, _ab_, _aa_);
   }
   function value_exn(t){
    var _Y_ = t[1];
    if(1 === _Y_){
     var uopt = t[2][4];
     if(caml_call1(Incremental_Import[6][7], uopt)){
      var
       _Z_ =
         function(x_023){
          return sexp_of_internal_observer
                  (function(param){return _J_;}, x_023);
         };
      caml_call5(Core[247], 0, _K_, cst_attempt_to_get_value_of_an, t, _Z_);
     }
     return caml_call1(Incremental_Import[6][16], uopt);
    }
    if(_Y_){
     var
      ___ =
        function(x_022){
         return sexp_of_internal_observer(function(param){return _L_;}, x_022);
        };
     return caml_call5
             (Core[247], 0, _M_, cst_Observer_value_exn_called_, t, ___);
    }
    function _$_(x_021){
     return sexp_of_internal_observer(function(param){return _N_;}, x_021);
    }
    return caml_call5
            (Core[247], 0, _O_, cst_Observer_value_exn_called_$0, t, _$_);
   }
   function on_update_exn(t, on_update_handler){
    if(2 <= t[1]){
     var
      _W_ =
        function(x_024){
         return sexp_of_internal_observer(function(param){return _P_;}, x_024);
        };
     return caml_call5(Core[247], 0, _Q_, cst_on_update_disallowed, t, _W_);
    }
    t[3] = [0, on_update_handler, t[3]];
    var _X_ = t[1];
    if(1 === _X_){
     var observing = t[2];
     observing[8] = observing[8] + 1 | 0;
     return 0;
    }
    if(_X_) throw caml_maybe_attach_backtrace([0, Assert_failure, _R_], 1);
    return 0;
   }
   function unlink(t){
    var prev = t[6], next = t[7];
    t[6] = Incremental_Import[6][5];
    t[7] = Incremental_Import[6][5];
    if(caml_call1(Incremental_Import[6][8], next))
     caml_call1(Incremental_Import[6][16], next)[6] = prev;
    if(caml_call1(Incremental_Import[6][8], prev))
     caml_call1(Incremental_Import[6][16], prev)[7] = next;
    var observing = t[2];
    if(t === caml_call1(Incremental_Import[6][9], observing[21]))
     observing[21] = next;
    var _U_ = caml_call1(Core_List[45], t[3]);
    observing[8] = observing[8] - _U_ | 0;
    t[3] = 0;
    var prev$0 = t[4], next$0 = t[5];
    t[4] = Incremental_Import[6][5];
    t[5] = Incremental_Import[6][5];
    if(caml_call1(Incremental_Import[6][8], next$0))
     set_prev_in_all(caml_call1(Incremental_Import[6][16], next$0), prev$0);
    var _V_ = caml_call1(Incremental_Import[6][8], prev$0);
    return _V_
            ? (caml_call1(Incremental_Import[6][16], prev$0)[5] = next$0, 0)
            : _V_;
   }
   function sexp_of_t$0(x_025){
    return sexp_of_internal_observer(function(param){return _S_;}, x_025);
   }
   function invariant$0(param){
    return invariant(function(_T_){return 0;}, param);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Internal_obser);
   var
    Incremental_Internal_observer =
      [0,
       invariant,
       sexp_of_internal_observer,
       same,
       observing,
       use_is_allowed,
       value_exn,
       on_update_exn,
       unlink,
       incr_state,
       [0, sexp_of_t$0, invariant$0, next_in_all, set_prev_in_all]];
   runtime.caml_register_global
    (64, Incremental_Internal_observer, cst_Incremental_Internal_obser$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Observer
//# unitInfo: Requires: Core, Incremental__Internal_observer, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Observer$0 = "Incremental__Observer",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Incremental_Internal_observer = global_data.Incremental__Internal_observer,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Observer$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/observer.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "observer.ml");
   var
    cst_incremental = cst_incremental$0,
    cst_Incremental_Observer = cst_Incremental_Observer$0;
   function sexp_of_t(of_a_001, x_002){
    var _a_ = caml_call1(Incremental_Internal_observer[2], of_a_001);
    return caml_call2(Core[598], _a_, x_002);
   }
   function invariant(invariant_a, t){
    return caml_call2(Incremental_Internal_observer[1], invariant_a, t[1]);
   }
   function observing(t){
    return caml_call1(Incremental_Internal_observer[4], t[1]);
   }
   function use_is_allowed(t){
    return caml_call1(Incremental_Internal_observer[5], t[1]);
   }
   function value_exn(t){
    return caml_call1(Incremental_Internal_observer[6], t[1]);
   }
   function incr_state(t){
    return caml_call1(Incremental_Internal_observer[9], t[1]);
   }
   function on_update_exn(t, on_update_handler){
    return caml_call2
            (Incremental_Internal_observer[7], t[1], on_update_handler);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Observer);
   var
    Incremental_Observer =
      [0,
       invariant,
       sexp_of_t,
       observing,
       use_is_allowed,
       value_exn,
       on_update_exn,
       incr_state];
   runtime.caml_register_global
    (13, Incremental_Observer, cst_Incremental_Observer$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__State
//# unitInfo: Requires: Base__Backtrace, Base__Invariant, Core, Core__Error, Core__Fn, Core__Gc, Core__Hashtbl, Core__Int, Core__Lazy, Core__List, Core__Option, Core__Or_error, Core__Percent, Core__Sequence, Core__Stack, Core__Tuple, Incremental__Adjust_heights_heap, Incremental__Alarm, Incremental__Alarm_value, Incremental__Array_fold, Incremental__Cutoff, Incremental__Expert, Incremental__Import, Incremental__Internal_observer, Incremental__Kind, Incremental__Node, Incremental__Observer, Incremental__On_update_handler, Incremental__Raised_exn, Incremental__Recompute_heap, Incremental__Scope, Incremental__Stabilization_num, Incremental__Step_function_node, Incremental__Unordered_array_fold, Incremental__Var, Incremental_step_function, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Sexplib0__Sexp_conv_record, Thread_safe_queue, Timing_wheel, Weak_hashtbl
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_during_stabilization$0 = " during stabilization",
    cst_Incremental_State$0 = "Incremental__State",
    cst_T = "T",
    cst = "_",
    cst_adjust_heights_heap$0 = "adjust_heights_heap",
    cst_all_observers$0 = "all_observers",
    cst_bind_lhs_change_should_inv$0 = "bind_lhs_change_should_invalidate_rhs",
    cst_can_only_call$2 = "can only call ",
    cst_cannot = "cannot ",
    cst_current_kind = "current.kind",
    cst_current_scope$0 = "current_scope",
    cst_currently_running_node$0 = "currently_running_node",
    cst_disallowed_observers$0 = "disallowed_observers",
    cst_expert_nodes_created_by_cu$0 = "expert_nodes_created_by_current_node",
    cst_finalized_observers$0 = "finalized_observers",
    cst_fired_alarm_values$0 = "fired_alarm_values",
    cst_handle_after_stabilization$0 = "handle_after_stabilization",
    cst_handle_fired$0 = "handle_fired",
    cst_incremental$0 = "incremental",
    cst_keep_node_creation_backtra$0 = "keep_node_creation_backtrace",
    cst_max_num_parents$0 = "max_num_parents",
    cst_new_observers$0 = "new_observers",
    cst_node_kind = "node.kind",
    cst_now$0 = "now",
    cst_num_active_observers$0 = "num_active_observers",
    cst_num_nodes_became_necessary$0 = "num_nodes_became_necessary",
    cst_num_nodes_became_unnecessa$0 = "num_nodes_became_unnecessary",
    cst_num_nodes_changed$0 = "num_nodes_changed",
    cst_num_nodes_created$0 = "num_nodes_created",
    cst_num_nodes_invalidated$0 = "num_nodes_invalidated",
    cst_num_nodes_recomputed$0 = "num_nodes_recomputed",
    cst_num_nodes_recomputed_direc$1 =
      "num_nodes_recomputed_directly_because_min_height",
    cst_num_nodes_recomputed_direc$2 =
      "num_nodes_recomputed_directly_because_one_child",
    cst_num_var_sets$0 = "num_var_sets",
    cst_only_in_debug$0 = "only_in_debug",
    cst_percentage_of_nodes_by_num$0 = "percentage_of_nodes_by_num_parents",
    cst_propagate_invalidity$0 = "propagate_invalidity",
    cst_recompute_heap$0 = "recompute_heap",
    cst_run_on_update_handlers$0 = "run_on_update_handlers",
    cst_set_during_stabilization$0 = "set_during_stabilization",
    cst_src_state_ml = "src/state.ml",
    cst_stabilization_num$0 = "stabilization_num",
    cst_status$0 = "status",
    cst_timing_wheel$0 = "timing_wheel",
    cst_weak_hashtbls$0 = "weak_hashtbls",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   function caml_call10(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9){
    return (f.l >= 0 ? f.l : f.l = f.length) == 10
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9]);
   }
   function caml_call11(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10){
    return (f.l >= 0 ? f.l : f.l = f.length) == 11
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10]);
   }
   function caml_call12(f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11){
    return (f.l >= 0 ? f.l : f.l = f.length) == 12
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11]);
   }
   function caml_call13
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12){
    return (f.l >= 0 ? f.l : f.l = f.length) == 13
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)
            : runtime.caml_call_gen
              (f, [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12]);
   }
   function caml_call14
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13){
    return (f.l >= 0 ? f.l : f.l = f.length) == 14
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
            : runtime.caml_call_gen
              (f,
               [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13]);
   }
   function caml_call15
   (f, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14){
    return (f.l >= 0 ? f.l : f.l = f.length) == 15
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14]);
   }
   function caml_call27
   (f,
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21,
    a22,
    a23,
    a24,
    a25,
    a26){
    return (f.l >= 0 ? f.l : f.l = f.length) == 27
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21,
               a22,
               a23,
               a24,
               a25,
               a26)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15,
                a16,
                a17,
                a18,
                a19,
                a20,
                a21,
                a22,
                a23,
                a24,
                a25,
                a26]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    error_source_079 = "src/state.ml.Stats.t",
    Incremental_Node = global_data.Incremental__Node,
    Core = global_data.Core,
    Incremental_Expert = global_data.Incremental__Expert,
    Incremental_Unordered_array_fo =
      global_data.Incremental__Unordered_array_fold,
    Incremental_Import = global_data.Incremental__Import,
    Assert_failure = global_data.Assert_failure,
    Incremental_Recompute_heap = global_data.Incremental__Recompute_heap,
    Incremental_Scope = global_data.Incremental__Scope,
    Core_Stack = global_data.Core__Stack,
    Incremental_Array_fold = global_data.Incremental__Array_fold,
    Incremental_Kind = global_data.Incremental__Kind,
    Incremental_Stabilization_num = global_data.Incremental__Stabilization_num,
    Incremental_step_function = global_data.Incremental_step_function,
    Incremental_Step_function_node =
      global_data.Incremental__Step_function_node,
    Core_Sequence = global_data.Core__Sequence,
    Incremental_Cutoff = global_data.Incremental__Cutoff,
    Core_List = global_data.Core__List,
    Core_Option = global_data.Core__Option,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Weak_hashtbl = global_data.Weak_hashtbl,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Incremental_Adjust_heights_hea =
      global_data.Incremental__Adjust_heights_heap,
    Timing_wheel = global_data.Timing_wheel,
    Incremental_Alarm = global_data.Incremental__Alarm,
    Incremental_Alarm_value = global_data.Incremental__Alarm_value,
    Core_Or_error = global_data.Core__Or_error,
    Core_Fn = global_data.Core__Fn,
    Core_Int = global_data.Core__Int,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Core_Lazy = global_data.Core__Lazy,
    Core_Gc = global_data.Core__Gc,
    Core_Tuple = global_data.Core__Tuple,
    Incremental_Raised_exn = global_data.Incremental__Raised_exn,
    Incremental_Var = global_data.Incremental__Var,
    Incremental_Observer = global_data.Incremental__Observer,
    Incremental_On_update_handler = global_data.Incremental__On_update_handler,
    Core_Error = global_data.Core__Error,
    Incremental_Internal_observer = global_data.Incremental__Internal_observer,
    Base_Backtrace = global_data.Base__Backtrace,
    Base_Invariant = global_data.Base__Invariant,
    Core_Percent = global_data.Core__Percent,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_State$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_state_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "state.ml");
   var
    _bs_ = [0, cst_src_state_ml, 387, 16],
    _bu_ = [0, cst_src_state_ml, 428, 18],
    _bt_ = [0, cst_src_state_ml, 461, 18],
    _by_ = [0, cst_src_state_ml, 542, 16],
    _bB_ = [0, cst_src_state_ml, 576, 18],
    _bz_ = [0, cst],
    cst_Trying_to_make_a_node_nece =
      "Trying to make a node necessary whose defining bind is not necessary",
    _bA_ = [0, cst_src_state_ml, 560, 25819, 25831],
    _bC_ = [0, cst_src_state_ml, 581, 16],
    _bD_ = [0, cst_src_state_ml, 582, 16],
    _bI_ = [0, cst_src_state_ml, 758, 4],
    _bJ_ = [0, cst_src_state_ml, 807, 21],
    _bK_ = [0, cst_src_state_ml, 688, 18],
    _bL_ = [0, cst_src_state_ml, 731, 18],
    _bM_ = [0, cst_src_state_ml, 776, 18],
    _bU_ = [0, cst_src_state_ml, 1024, 22],
    _bT_ = [0, cst_src_state_ml, 1057, 20],
    _bO_ = [0, cst_src_state_ml, 1062, 29],
    _bR_ = [0, cst_src_state_ml, 1064, 20],
    _bS_ = [0, cst_src_state_ml, 1065, 30],
    _bN_ = [0, cst_src_state_ml, 1066, 54],
    _bQ_ = [0, cst_src_state_ml, 1120, 24],
    _bP_ = [0, cst_src_state_ml, 1121, 24],
    cst_remove_dependency = "remove_dependency",
    _cl_ = [0, cst_src_state_ml, 2097, 20],
    cst_add_dependency = "add_dependency",
    _ck_ = [0, cst_src_state_ml, 2067, 22],
    cst_invalidate = "invalidate",
    cst_make_stale = "make_stale",
    _ci_ = [0, cst],
    _cg_ = [0, cst],
    _ch_ = [0, cst_current_kind],
    _cj_ = [0, cst_node_kind],
    cst_on_children_nodes = " on children nodes",
    cst_can_only_call$1 = cst_can_only_call$2,
    _ce_ = [0, cst],
    _cc_ = [0, cst],
    _cd_ = [0, cst_current_kind],
    _cf_ = [0, cst_node_kind],
    cst_on_parent_nodes = " on parent nodes",
    cst_can_only_call$0 = cst_can_only_call$2,
    cst_during_stabilization = cst_during_stabilization$0,
    cst_can_only_call = cst_can_only_call$2,
    _cb_ = [0, cst],
    cst_unexpected_kind_for_expert = "unexpected kind for expert node",
    cst_advance_clock = "advance_clock",
    _b$_ = [5, 1],
    _ca_ = [0, cst_src_state_ml, 1888, 22],
    cst_cannot_take_snapshot_in_th = "cannot take snapshot in the past",
    cst_at_intervals_got_too_small = "at_intervals got too small interval",
    _b__ = [0, cst_src_state_ml, 1795, 69176, 69188],
    _b8_ = [0, 0],
    _b9_ = [0, cst_src_state_ml, 1786, 16],
    _b7_ = [0, cst_src_state_ml, 1753, 16],
    cst_unordered_array_fold_got_n =
      "unordered_array_fold got non-positive full_compute_every_n_changes",
    _b6_ = [0, cst_src_state_ml, 1664, 65613, 65625],
    cst_step = "step",
    _b5_ = [0, cst_src_state_ml, 1406, 6],
    _b3_ = [0, "Done"],
    _b4_ = [0, "Keep_going"],
    cst_stabilize = "stabilize",
    cst_cannot_set_var_stabilizati =
      "cannot set var -- stabilization previously raised",
    _b2_ = [0, cst_src_state_ml, 1282, 18],
    _b0_ = [0, cst],
    cst_Observer_value_exn_called_ =
      "Observer.value_exn called during stabilization",
    _b1_ = [0, cst_src_state_ml, 1251, 52155, 52167],
    cst_Observer_value_exn_called_$0 =
      "Observer.value_exn called after stabilize previously raised",
    _bY_ = [0, cst_src_state_ml, 1211, 29],
    _bZ_ = [0, cst_src_state_ml, 1236, 20],
    _bX_ = [0, cst_src_state_ml, 1144, 6],
    _bV_ = [0, cst],
    cst_node_unexpectedly_does_not =
      "node unexpectedly does not need to be computed",
    _bW_ = [0, cst_src_state_ml, 1131, 47733, 47745],
    _bH_ = [0, cst_src_state_ml, 670, 16],
    cst_attempt_to_run_within_an_i = "attempt to run within an invalid scope",
    _bG_ = [0, cst_src_state_ml, 636, 28770, 28793],
    _bF_ = [0, cst_src_state_ml, 595, 16],
    _bE_ = [0, cst_src_state_ml, 613, 16],
    _bw_ = [0, cst_src_state_ml, 513, 22],
    _bv_ = [0, cst_src_state_ml, 525, 15],
    cst_set_max_height_allowed = "set_max_height_allowed",
    _bn_ =
      [0,
       [11, cst_cannot, [2, 0, [11, cst_during_stabilization$0, 0]]],
       "cannot %s during stabilization"],
    _bo_ = [0, cst_src_state_ml, 337, 15160, 15172],
    _bp_ =
      [0,
       [11, cst_cannot, [2, 0, [11, " during on-update handlers", 0]]],
       "cannot %s during on-update handlers"],
    _bq_ = [0, cst_src_state_ml, 326, 14790, 14804],
    _br_ =
      [0,
       [11, cst_cannot, [2, 0, [11, " -- stabilize previously raised", 0]]],
       "cannot %s -- stabilize previously raised"],
    _bk_ = [0, cst_src_state_ml, 257, 39],
    _bj_ = [0, cst_src_state_ml, 261, 13],
    _bi_ = [0, cst_src_state_ml, 265, 13],
    _bh_ = [0, cst_src_state_ml, 267, 46],
    _bg_ = [0, cst_src_state_ml, 282, 41],
    _bf_ = [0, cst_src_state_ml, 290, 49],
    _bd_ = [0, cst_src_state_ml, 300, 19],
    _bc_ = [0, cst_src_state_ml, 296, 15],
    _be_ = [0, cst_src_state_ml, 294, 48],
    _bb_ = [0, cst_src_state_ml, 247, 39],
    _ba_ = [0, cst_src_state_ml, 248, 8],
    _a__ = [0, cst],
    cst_member_of_all_observers_wi =
      "member of all_observers with unexpected state",
    _a$_ = [0, cst_src_state_ml, 240, 10704, 10723],
    _bl_ = [0, cst_src_state_ml, 249, 6],
    _bm_ = [0, cst_src_state_ml, 233, 10405, 10429],
    cst_cannot_call_am_stabilizing =
      "cannot call am_stabilizing -- stabilize previously raised",
    _a8_ = [0, cst_percentage_of_nodes_by_num$0],
    _a9_ = [0, cst_max_num_parents$0],
    cst_percentage_of_nodes_by_num = cst_percentage_of_nodes_by_num$0,
    cst_max_num_parents = cst_max_num_parents$0,
    _a6_ = [0, cst_src_state_ml, 156, 13],
    _a5_ = [0, cst_src_state_ml, 159, 44],
    _a7_ = [0, cst_src_state_ml, 151, 7547, 7571],
    _a1_ = [0, cst_fired_alarm_values$0],
    _a2_ = [0, cst_handle_fired$0],
    _a3_ = [0, cst_now$0],
    _a4_ = [0, cst_timing_wheel$0],
    _as_ = [0, cst_num_var_sets$0],
    _at_ = [0, cst_num_nodes_recomputed_direc$1],
    _au_ = [0, cst_num_nodes_recomputed_direc$2],
    _av_ = [0, cst_num_nodes_recomputed$0],
    _aw_ = [0, cst_num_nodes_invalidated$0],
    _ax_ = [0, cst_num_nodes_created$0],
    _ay_ = [0, cst_num_nodes_changed$0],
    _az_ = [0, cst_num_nodes_became_unnecessa$0],
    _aA_ = [0, cst_num_nodes_became_necessary$0],
    _aB_ = [0, cst_keep_node_creation_backtra$0],
    _aC_ = [0, cst_weak_hashtbls$0],
    _aD_ = [0, cst_only_in_debug$0],
    _aE_ = [0, cst_run_on_update_handlers$0],
    _aF_ = [0, cst_handle_after_stabilization$0],
    _aG_ = [0, cst_set_during_stabilization$0],
    _aH_ = [0, cst_disallowed_observers$0],
    _aI_ = [0, cst_new_observers$0],
    _aJ_ = [0, cst_finalized_observers$0],
    _aK_ = [0, cst_all_observers$0],
    _aL_ = [0, cst_num_active_observers$0],
    _aM_ = [0, cst_propagate_invalidity$0],
    _aN_ = [0, cst_adjust_heights_heap$0],
    _aO_ = [0, cst_recompute_heap$0],
    _aP_ = [0, cst_current_scope$0],
    _aQ_ = [0, cst_stabilization_num$0],
    _aR_ = [0, cst_bind_lhs_change_should_inv$0],
    _aS_ = [0, cst_status$0],
    _q_ = [0, cst],
    _p_ = [0, cst],
    _r_ = [0, cst_T],
    _o_ = [0, cst_src_state_ml, 38, 1165, 1189],
    _m_ = [0, cst_expert_nodes_created_by_cu$0],
    _n_ = [0, cst_currently_running_node$0],
    _h_ = [0, cst_src_state_ml, 25, 715, 739],
    _f_ = [0, cst],
    _e_ = [0, cst],
    _g_ = [0, cst_T],
    _a_ = [0, "Stabilizing"],
    _b_ = [0, "Running_on_update_handlers"],
    _c_ = [0, "Not_stabilizing"],
    _d_ = [0, "Stabilize_previously_raised"],
    cst_expert_nodes_created_by_cu = cst_expert_nodes_created_by_cu$0,
    cst_currently_running_node = cst_currently_running_node$0,
    cst_num_var_sets = cst_num_var_sets$0,
    cst_num_nodes_recomputed_direc = cst_num_nodes_recomputed_direc$1,
    cst_num_nodes_recomputed_direc$0 = cst_num_nodes_recomputed_direc$2,
    cst_num_nodes_recomputed = cst_num_nodes_recomputed$0,
    cst_num_nodes_invalidated = cst_num_nodes_invalidated$0,
    cst_num_nodes_created = cst_num_nodes_created$0,
    cst_num_nodes_changed = cst_num_nodes_changed$0,
    cst_num_nodes_became_unnecessa = cst_num_nodes_became_unnecessa$0,
    cst_num_nodes_became_necessary = cst_num_nodes_became_necessary$0,
    cst_keep_node_creation_backtra = cst_keep_node_creation_backtra$0,
    cst_weak_hashtbls = cst_weak_hashtbls$0,
    cst_only_in_debug = cst_only_in_debug$0,
    cst_run_on_update_handlers = cst_run_on_update_handlers$0,
    cst_handle_after_stabilization = cst_handle_after_stabilization$0,
    cst_set_during_stabilization = cst_set_during_stabilization$0,
    cst_disallowed_observers = cst_disallowed_observers$0,
    cst_new_observers = cst_new_observers$0,
    cst_finalized_observers = cst_finalized_observers$0,
    cst_all_observers = cst_all_observers$0,
    cst_num_active_observers = cst_num_active_observers$0,
    cst_propagate_invalidity = cst_propagate_invalidity$0,
    cst_adjust_heights_heap = cst_adjust_heights_heap$0,
    cst_recompute_heap = cst_recompute_heap$0,
    cst_current_scope = cst_current_scope$0,
    cst_stabilization_num = cst_stabilization_num$0,
    cst_bind_lhs_change_should_inv = cst_bind_lhs_change_should_inv$0,
    cst_status = cst_status$0,
    cst_fired_alarm_values = cst_fired_alarm_values$0,
    cst_handle_fired = cst_handle_fired$0,
    cst_now = cst_now$0,
    cst_timing_wheel = cst_timing_wheel$0,
    cst_incremental = cst_incremental$0,
    cst_Incremental_State = cst_Incremental_State$0;
   function sexp_of_status(param){
    if(typeof param === "number")
     switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;}
    var
     arg0_001 = param[1],
     res0_002 = caml_call1(Incremental_Raised_exn[1], arg0_001);
    return [1, [0, _d_, [0, res0_002, 0]]];
   }
   function sexp_of_t(param){
    var arg1_004 = param[2], arg0_003 = param[1];
    function _in_(param){return _e_;}
    var res0_005 = caml_call2(Incremental_Node[2], _in_, arg0_003);
    function _io_(param){return _f_;}
    var
     res1_006 =
       caml_call2(Incremental_On_update_handler[1][2], _io_, arg1_004);
    return [1, [0, _g_, [0, res0_005, [0, res1_006, 0]]]];
   }
   function invariant(t){
    var node = t[1];
    function _ik_(param){
     function _il_(_im_){return 0;}
     return caml_call2(Incremental_Node[4], _il_, node);
    }
    return caml_call4(Base_Invariant[1], _h_, t, sexp_of_t, _ik_);
   }
   var Run_on_update_handlers = [0, sexp_of_t, invariant];
   function expert_nodes_created_by_curren(r){return r[2];}
   function set_expert_nodes_created_by_cu(r, v){r[2] = v; return 0;}
   function currently_running_node(r){return r[1];}
   function set_currently_running_node(r, v){r[1] = v; return 0;}
   function _i_(r, v){return [0, r[1], v];}
   var
    _j_ = [0, set_expert_nodes_created_by_cu],
    expert_nodes_created_by_curren$0 =
      [0,
       function(param){return 0;},
       cst_expert_nodes_created_by_cu,
       _j_,
       expert_nodes_created_by_curren,
       _i_];
   function _k_(r, v){return [0, v, r[2]];}
   var
    _l_ = [0, set_currently_running_node],
    currently_running_node$0 =
      [0,
       function(param){return 0;},
       cst_currently_running_node,
       _l_,
       currently_running_node,
       _k_];
   function iter(currently_running_node_fun, expert_nodes_created_by_curren){
    caml_call1(currently_running_node_fun, currently_running_node$0);
    return caml_call1
            (expert_nodes_created_by_curren, expert_nodes_created_by_curren$0);
   }
   var
    Fields =
      [0, expert_nodes_created_by_curren$0, currently_running_node$0, iter];
   function sexp_of_t$0(param){
    var
     currently_running_node_008 = param[1],
     expert_nodes_created_by_curren = param[2],
     arg_011 =
       caml_call2
        (Core[472], Incremental_Node[1][1], expert_nodes_created_by_curren),
     bnds_007 = [0, [1, [0, _m_, [0, arg_011, 0]]], 0],
     arg_009 =
       caml_call2
        (Core[515], Incremental_Node[1][1], currently_running_node_008),
     bnds_007$0 = [0, [1, [0, _n_, [0, arg_009, 0]]], bnds_007];
    return [1, bnds_007$0];
   }
   function invariant$0(t){
    function _if_(param){
     function _ig_(_ij_){return 0;}
     function _ih_(_ii_){return 0;}
     return caml_call2(Fields[3], _ih_, _ig_);
    }
    return caml_call4(Base_Invariant[1], _o_, t, sexp_of_t$0, _if_);
   }
   function create(param){return [0, 0, 0];}
   var
    Only_in_debug =
      [0,
       expert_nodes_created_by_curren,
       set_expert_nodes_created_by_cu,
       currently_running_node,
       set_currently_running_node,
       Fields,
       sexp_of_t$0,
       invariant$0,
       create];
   function sexp_of_t$1(param){
    var arg0_012 = param[1];
    function _id_(param){return _p_;}
    function _ie_(param){return _q_;}
    var res0_013 = caml_call3(Weak_hashtbl[1], _ie_, _id_, arg0_012);
    return [1, [0, _r_, [0, res0_013, 0]]];
   }
   var Packed_weak_hashtbl = [0, sexp_of_t$1];
   function num_var_sets(r){return r[27];}
   function set_num_var_sets(r, v){r[27] = v; return 0;}
   function num_nodes_recomputed_directly_(r){return r[26];}
   function set_num_nodes_recomputed_direc(r, v){r[26] = v; return 0;}
   function num_nodes_recomputed_directly_$0(r){return r[25];}
   function set_num_nodes_recomputed_direc$0(r, v){r[25] = v; return 0;}
   function num_nodes_recomputed(r){return r[24];}
   function set_num_nodes_recomputed(r, v){r[24] = v; return 0;}
   function num_nodes_invalidated(r){return r[23];}
   function set_num_nodes_invalidated(r, v){r[23] = v; return 0;}
   function num_nodes_created(r){return r[22];}
   function set_num_nodes_created(r, v){r[22] = v; return 0;}
   function num_nodes_changed(r){return r[21];}
   function set_num_nodes_changed(r, v){r[21] = v; return 0;}
   function num_nodes_became_unnecessary(r){return r[20];}
   function set_num_nodes_became_unnecessa(r, v){r[20] = v; return 0;}
   function num_nodes_became_necessary(r){return r[19];}
   function set_num_nodes_became_necessary(r, v){r[19] = v; return 0;}
   function keep_node_creation_backtrace(r){return r[18];}
   function set_keep_node_creation_backtra(r, v){r[18] = v; return 0;}
   function weak_hashtbls(r){return r[17];}
   function only_in_debug(r){return r[16];}
   function set_only_in_debug(r, v){r[16] = v; return 0;}
   function run_on_update_handlers(r){return r[15];}
   function handle_after_stabilization(r){return r[14];}
   function set_during_stabilization(r){return r[13];}
   function disallowed_observers(r){return r[12];}
   function new_observers(r){return r[11];}
   function finalized_observers(r){return r[10];}
   function all_observers(r){return r[9];}
   function set_all_observers(r, v){r[9] = v; return 0;}
   function num_active_observers(r){return r[8];}
   function set_num_active_observers(r, v){r[8] = v; return 0;}
   function propagate_invalidity(r){return r[7];}
   function adjust_heights_heap(r){return r[6];}
   function recompute_heap(r){return r[5];}
   function current_scope(r){return r[4];}
   function set_current_scope(r, v){r[4] = v; return 0;}
   function stabilization_num(r){return r[3];}
   function set_stabilization_num(r, v){r[3] = v; return 0;}
   function bind_lhs_change_should_invalid(r){return r[2];}
   function status(r){return r[1];}
   function set_status(r, v){r[1] = v; return 0;}
   function _s_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            v];
   }
   var
    _t_ = [0, set_num_var_sets],
    num_var_sets$0 =
      [0,
       function(param){return 0;},
       cst_num_var_sets,
       _t_,
       num_var_sets,
       _s_];
   function _u_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            v,
            r[27]];
   }
   var
    _v_ = [0, set_num_nodes_recomputed_direc],
    num_nodes_recomputed_directly_$1 =
      [0,
       function(param){return 0;},
       cst_num_nodes_recomputed_direc,
       _v_,
       num_nodes_recomputed_directly_,
       _u_];
   function _w_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            v,
            r[26],
            r[27]];
   }
   var
    _x_ = [0, set_num_nodes_recomputed_direc$0],
    num_nodes_recomputed_directly_$2 =
      [0,
       function(param){return 0;},
       cst_num_nodes_recomputed_direc$0,
       _x_,
       num_nodes_recomputed_directly_$0,
       _w_];
   function _y_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            v,
            r[25],
            r[26],
            r[27]];
   }
   var
    _z_ = [0, set_num_nodes_recomputed],
    num_nodes_recomputed$0 =
      [0,
       function(param){return 0;},
       cst_num_nodes_recomputed,
       _z_,
       num_nodes_recomputed,
       _y_];
   function _A_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            v,
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _B_ = [0, set_num_nodes_invalidated],
    num_nodes_invalidated$0 =
      [0,
       function(param){return 0;},
       cst_num_nodes_invalidated,
       _B_,
       num_nodes_invalidated,
       _A_];
   function _C_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            v,
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _D_ = [0, set_num_nodes_created],
    num_nodes_created$0 =
      [0,
       function(param){return 0;},
       cst_num_nodes_created,
       _D_,
       num_nodes_created,
       _C_];
   function _E_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            v,
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _F_ = [0, set_num_nodes_changed],
    num_nodes_changed$0 =
      [0,
       function(param){return 0;},
       cst_num_nodes_changed,
       _F_,
       num_nodes_changed,
       _E_];
   function _G_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            v,
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _H_ = [0, set_num_nodes_became_unnecessa],
    num_nodes_became_unnecessary$0 =
      [0,
       function(param){return 0;},
       cst_num_nodes_became_unnecessa,
       _H_,
       num_nodes_became_unnecessary,
       _G_];
   function _I_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            v,
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _J_ = [0, set_num_nodes_became_necessary],
    num_nodes_became_necessary$0 =
      [0,
       function(param){return 0;},
       cst_num_nodes_became_necessary,
       _J_,
       num_nodes_became_necessary,
       _I_];
   function _K_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            v,
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _L_ = [0, set_keep_node_creation_backtra],
    keep_node_creation_backtrace$0 =
      [0,
       function(param){return 0;},
       cst_keep_node_creation_backtra,
       _L_,
       keep_node_creation_backtrace,
       _K_];
   function _M_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            v,
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _N_ = 0,
    weak_hashtbls$0 =
      [0,
       function(param){return 0;},
       cst_weak_hashtbls,
       _N_,
       weak_hashtbls,
       _M_];
   function _O_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            v,
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _P_ = [0, set_only_in_debug],
    only_in_debug$0 =
      [0,
       function(param){return 0;},
       cst_only_in_debug,
       _P_,
       only_in_debug,
       _O_];
   function _Q_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            v,
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _R_ = 0,
    run_on_update_handlers$0 =
      [0,
       function(param){return 0;},
       cst_run_on_update_handlers,
       _R_,
       run_on_update_handlers,
       _Q_];
   function _S_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            v,
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _T_ = 0,
    handle_after_stabilization$0 =
      [0,
       function(param){return 0;},
       cst_handle_after_stabilization,
       _T_,
       handle_after_stabilization,
       _S_];
   function _U_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            v,
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _V_ = 0,
    set_during_stabilization$0 =
      [0,
       function(param){return 0;},
       cst_set_during_stabilization,
       _V_,
       set_during_stabilization,
       _U_];
   function _W_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            v,
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _X_ = 0,
    disallowed_observers$0 =
      [0,
       function(param){return 0;},
       cst_disallowed_observers,
       _X_,
       disallowed_observers,
       _W_];
   function _Y_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            v,
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _Z_ = 0,
    new_observers$0 =
      [0,
       function(param){return 0;},
       cst_new_observers,
       _Z_,
       new_observers,
       _Y_];
   function ___(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            v,
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _$_ = 0,
    finalized_observers$0 =
      [0,
       function(param){return 0;},
       cst_finalized_observers,
       _$_,
       finalized_observers,
       ___];
   function _aa_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _ab_ = [0, set_all_observers],
    all_observers$0 =
      [0,
       function(param){return 0;},
       cst_all_observers,
       _ab_,
       all_observers,
       _aa_];
   function _ac_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _ad_ = [0, set_num_active_observers],
    num_active_observers$0 =
      [0,
       function(param){return 0;},
       cst_num_active_observers,
       _ad_,
       num_active_observers,
       _ac_];
   function _ae_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _af_ = 0,
    propagate_invalidity$0 =
      [0,
       function(param){return 0;},
       cst_propagate_invalidity,
       _af_,
       propagate_invalidity,
       _ae_];
   function _ag_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _ah_ = 0,
    adjust_heights_heap$0 =
      [0,
       function(param){return 0;},
       cst_adjust_heights_heap,
       _ah_,
       adjust_heights_heap,
       _ag_];
   function _ai_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _aj_ = 0,
    recompute_heap$0 =
      [0,
       function(param){return 0;},
       cst_recompute_heap,
       _aj_,
       recompute_heap,
       _ai_];
   function _ak_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _al_ = [0, set_current_scope],
    current_scope$0 =
      [0,
       function(param){return 0;},
       cst_current_scope,
       _al_,
       current_scope,
       _ak_];
   function _am_(r, v){
    return [0,
            r[1],
            r[2],
            v,
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _an_ = [0, set_stabilization_num],
    stabilization_num$0 =
      [0,
       function(param){return 0;},
       cst_stabilization_num,
       _an_,
       stabilization_num,
       _am_];
   function _ao_(r, v){
    return [0,
            r[1],
            v,
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _ap_ = 0,
    bind_lhs_change_should_invalid$0 =
      [0,
       function(param){return 0;},
       cst_bind_lhs_change_should_inv,
       _ap_,
       bind_lhs_change_should_invalid,
       _ao_];
   function _aq_(r, v){
    return [0,
            v,
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27]];
   }
   var
    _ar_ = [0, set_status],
    status$0 = [0, function(param){return 0;}, cst_status, _ar_, status, _aq_];
   function iter$0
   (status_fun,
    bind_lhs_change_should_invalid,
    stabilization_num_fun,
    current_scope_fun,
    recompute_heap_fun,
    adjust_heights_heap_fun,
    propagate_invalidity_fun,
    num_active_observers_fun,
    all_observers_fun,
    finalized_observers_fun,
    new_observers_fun,
    disallowed_observers_fun,
    set_during_stabilization_fun,
    handle_after_stabilization_fun,
    run_on_update_handlers_fun,
    only_in_debug_fun,
    weak_hashtbls_fun,
    keep_node_creation_backtrace_f,
    num_nodes_became_necessary_fun,
    num_nodes_became_unnecessary_f,
    num_nodes_changed_fun,
    num_nodes_created_fun,
    num_nodes_invalidated_fun,
    num_nodes_recomputed_fun,
    num_nodes_recomputed_directly_$0,
    num_nodes_recomputed_directly_,
    num_var_sets_fun){
    caml_call1(status_fun, status$0);
    caml_call1
     (bind_lhs_change_should_invalid, bind_lhs_change_should_invalid$0);
    caml_call1(stabilization_num_fun, stabilization_num$0);
    caml_call1(current_scope_fun, current_scope$0);
    caml_call1(recompute_heap_fun, recompute_heap$0);
    caml_call1(adjust_heights_heap_fun, adjust_heights_heap$0);
    caml_call1(propagate_invalidity_fun, propagate_invalidity$0);
    caml_call1(num_active_observers_fun, num_active_observers$0);
    caml_call1(all_observers_fun, all_observers$0);
    caml_call1(finalized_observers_fun, finalized_observers$0);
    caml_call1(new_observers_fun, new_observers$0);
    caml_call1(disallowed_observers_fun, disallowed_observers$0);
    caml_call1(set_during_stabilization_fun, set_during_stabilization$0);
    caml_call1(handle_after_stabilization_fun, handle_after_stabilization$0);
    caml_call1(run_on_update_handlers_fun, run_on_update_handlers$0);
    caml_call1(only_in_debug_fun, only_in_debug$0);
    caml_call1(weak_hashtbls_fun, weak_hashtbls$0);
    caml_call1(keep_node_creation_backtrace_f, keep_node_creation_backtrace$0);
    caml_call1(num_nodes_became_necessary_fun, num_nodes_became_necessary$0);
    caml_call1(num_nodes_became_unnecessary_f, num_nodes_became_unnecessary$0);
    caml_call1(num_nodes_changed_fun, num_nodes_changed$0);
    caml_call1(num_nodes_created_fun, num_nodes_created$0);
    caml_call1(num_nodes_invalidated_fun, num_nodes_invalidated$0);
    caml_call1(num_nodes_recomputed_fun, num_nodes_recomputed$0);
    caml_call1
     (num_nodes_recomputed_directly_$0, num_nodes_recomputed_directly_$2);
    caml_call1
     (num_nodes_recomputed_directly_, num_nodes_recomputed_directly_$1);
    return caml_call1(num_var_sets_fun, num_var_sets$0);
   }
   var
    Fields$0 =
      [0,
       num_var_sets$0,
       num_nodes_recomputed_directly_$1,
       num_nodes_recomputed_directly_$2,
       num_nodes_recomputed$0,
       num_nodes_invalidated$0,
       num_nodes_created$0,
       num_nodes_changed$0,
       num_nodes_became_unnecessary$0,
       num_nodes_became_necessary$0,
       keep_node_creation_backtrace$0,
       weak_hashtbls$0,
       only_in_debug$0,
       run_on_update_handlers$0,
       handle_after_stabilization$0,
       set_during_stabilization$0,
       disallowed_observers$0,
       new_observers$0,
       finalized_observers$0,
       all_observers$0,
       num_active_observers$0,
       propagate_invalidity$0,
       adjust_heights_heap$0,
       recompute_heap$0,
       current_scope$0,
       stabilization_num$0,
       bind_lhs_change_should_invalid$0,
       status$0,
       iter$0];
   function sexp_of_t$2(param){
    var
     status_015 = param[1],
     bind_lhs_change_should_invalid = param[2],
     stabilization_num_019 = param[3],
     current_scope_021 = param[4],
     propagate_invalidity_027 = param[7],
     adjust_heights_heap_025 = param[6],
     recompute_heap_023 = param[5],
     num_active_observers_029 = param[8],
     all_observers_031 = param[9],
     run_on_update_handlers_043 = param[15],
     handle_after_stabilization_041 = param[14],
     set_during_stabilization_039 = param[13],
     disallowed_observers_037 = param[12],
     new_observers_035 = param[11],
     finalized_observers_033 = param[10],
     only_in_debug_045 = param[16],
     weak_hashtbls_047 = param[17],
     keep_node_creation_backtrace_0 = param[18],
     num_nodes_became_necessary_051 = param[19],
     num_nodes_became_unnecessary_0 = param[20],
     num_nodes_changed_055 = param[21],
     num_nodes_created_057 = param[22],
     num_nodes_invalidated_059 = param[23],
     num_nodes_recomputed_061 = param[24],
     num_nodes_recomputed_directly_ = param[25],
     num_nodes_recomputed_directly_$0 = param[26],
     num_var_sets_067 = param[27],
     arg_068 = caml_call1(Core[389], num_var_sets_067),
     bnds_014 = [0, [1, [0, _as_, [0, arg_068, 0]]], 0],
     arg_066 = caml_call1(Core[389], num_nodes_recomputed_directly_$0),
     bnds_014$0 = [0, [1, [0, _at_, [0, arg_066, 0]]], bnds_014],
     arg_064 = caml_call1(Core[389], num_nodes_recomputed_directly_),
     bnds_014$1 = [0, [1, [0, _au_, [0, arg_064, 0]]], bnds_014$0],
     arg_062 = caml_call1(Core[389], num_nodes_recomputed_061),
     bnds_014$2 = [0, [1, [0, _av_, [0, arg_062, 0]]], bnds_014$1],
     arg_060 = caml_call1(Core[389], num_nodes_invalidated_059),
     bnds_014$3 = [0, [1, [0, _aw_, [0, arg_060, 0]]], bnds_014$2],
     arg_058 = caml_call1(Core[389], num_nodes_created_057),
     bnds_014$4 = [0, [1, [0, _ax_, [0, arg_058, 0]]], bnds_014$3],
     arg_056 = caml_call1(Core[389], num_nodes_changed_055),
     bnds_014$5 = [0, [1, [0, _ay_, [0, arg_056, 0]]], bnds_014$4],
     arg_054 = caml_call1(Core[389], num_nodes_became_unnecessary_0),
     bnds_014$6 = [0, [1, [0, _az_, [0, arg_054, 0]]], bnds_014$5],
     arg_052 = caml_call1(Core[389], num_nodes_became_necessary_051),
     bnds_014$7 = [0, [1, [0, _aA_, [0, arg_052, 0]]], bnds_014$6],
     arg_050 = caml_call1(Core[323], keep_node_creation_backtrace_0),
     bnds_014$8 = [0, [1, [0, _aB_, [0, arg_050, 0]]], bnds_014$7],
     arg_048 =
       caml_call2
        (Thread_safe_queue[1], Packed_weak_hashtbl[1], weak_hashtbls_047),
     bnds_014$9 = [0, [1, [0, _aC_, [0, arg_048, 0]]], bnds_014$8],
     arg_046 = caml_call1(Only_in_debug[6], only_in_debug_045),
     bnds_014$10 = [0, [1, [0, _aD_, [0, arg_046, 0]]], bnds_014$9],
     arg_044 =
       caml_call2
        (Core_Stack[2], Run_on_update_handlers[1], run_on_update_handlers_043),
     bnds_014$11 = [0, [1, [0, _aE_, [0, arg_044, 0]]], bnds_014$10],
     arg_042 =
       caml_call2
        (Core_Stack[2],
         Incremental_Node[1][1],
         handle_after_stabilization_041),
     bnds_014$12 = [0, [1, [0, _aF_, [0, arg_042, 0]]], bnds_014$11],
     arg_040 =
       caml_call2
        (Core_Stack[2], Incremental_Var[3][1], set_during_stabilization_039),
     bnds_014$13 = [0, [1, [0, _aG_, [0, arg_040, 0]]], bnds_014$12],
     arg_038 =
       caml_call2
        (Core_Stack[2],
         Incremental_Internal_observer[10][1],
         disallowed_observers_037),
     bnds_014$14 = [0, [1, [0, _aH_, [0, arg_038, 0]]], bnds_014$13],
     arg_036 =
       caml_call2
        (Core_Stack[2],
         Incremental_Internal_observer[10][1],
         new_observers_035),
     bnds_014$15 = [0, [1, [0, _aI_, [0, arg_036, 0]]], bnds_014$14],
     arg_034 =
       caml_call2
        (Thread_safe_queue[1],
         Incremental_Internal_observer[10][1],
         finalized_observers_033),
     bnds_014$16 = [0, [1, [0, _aJ_, [0, arg_034, 0]]], bnds_014$15],
     arg_032 =
       caml_call2
        (Incremental_Import[6][2],
         Incremental_Internal_observer[10][1],
         all_observers_031),
     bnds_014$17 = [0, [1, [0, _aK_, [0, arg_032, 0]]], bnds_014$16],
     arg_030 = caml_call1(Core[389], num_active_observers_029),
     bnds_014$18 = [0, [1, [0, _aL_, [0, arg_030, 0]]], bnds_014$17],
     arg_028 =
       caml_call2
        (Core_Stack[2], Incremental_Node[1][1], propagate_invalidity_027),
     bnds_014$19 = [0, [1, [0, _aM_, [0, arg_028, 0]]], bnds_014$18],
     arg_026 =
       caml_call1(Incremental_Adjust_heights_hea[1], adjust_heights_heap_025),
     bnds_014$20 = [0, [1, [0, _aN_, [0, arg_026, 0]]], bnds_014$19],
     arg_024 = caml_call1(Incremental_Recompute_heap[1], recompute_heap_023),
     bnds_014$21 = [0, [1, [0, _aO_, [0, arg_024, 0]]], bnds_014$20],
     arg_022 = caml_call1(Incremental_Scope[1], current_scope_021),
     bnds_014$22 = [0, [1, [0, _aP_, [0, arg_022, 0]]], bnds_014$21],
     arg_020 =
       caml_call1(Incremental_Stabilization_num[2], stabilization_num_019),
     bnds_014$23 = [0, [1, [0, _aQ_, [0, arg_020, 0]]], bnds_014$22],
     arg_018 = caml_call1(Core[323], bind_lhs_change_should_invalid),
     bnds_014$24 = [0, [1, [0, _aR_, [0, arg_018, 0]]], bnds_014$23],
     arg_016 = sexp_of_status(status_015),
     bnds_014$25 = [0, [1, [0, _aS_, [0, arg_016, 0]]], bnds_014$24];
    return [1, bnds_014$25];
   }
   function fired_alarm_values(r){return r[4];}
   function set_fired_alarm_values(r, v){r[4] = v; return 0;}
   function handle_fired(r){return r[3];}
   function now(r){return r[2];}
   function timing_wheel(r){return r[1];}
   function _aT_(r, v){return [0, r[1], r[2], r[3], v];}
   var
    _aU_ = [0, set_fired_alarm_values],
    fired_alarm_values$0 =
      [0,
       function(param){return 0;},
       cst_fired_alarm_values,
       _aU_,
       fired_alarm_values,
       _aT_];
   function _aV_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _aW_ = 0,
    handle_fired$0 =
      [0,
       function(param){return 0;},
       cst_handle_fired,
       _aW_,
       handle_fired,
       _aV_];
   function _aX_(r, v){return [0, r[1], v, r[3], r[4]];}
   var
    _aY_ = 0,
    now$0 = [0, function(param){return 0;}, cst_now, _aY_, now, _aX_];
   function _aZ_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _a0_ = 0,
    timing_wheel$0 =
      [0,
       function(param){return 0;},
       cst_timing_wheel,
       _a0_,
       timing_wheel,
       _aZ_];
   function iter$1
   (timing_wheel_fun, now_fun, handle_fired_fun, fired_alarm_values_fun){
    caml_call1(timing_wheel_fun, timing_wheel$0);
    caml_call1(now_fun, now$0);
    caml_call1(handle_fired_fun, handle_fired$0);
    return caml_call1(fired_alarm_values_fun, fired_alarm_values$0);
   }
   var
    Fields$1 =
      [0, fired_alarm_values$0, handle_fired$0, now$0, timing_wheel$0, iter$1];
   function sexp_of_t$3(param){
    var
     now_072 = param[2],
     timing_wheel_070 = param[1],
     fired_alarm_values_076 = param[4],
     arg_077 =
       caml_call2
        (Incremental_Import[6][2],
         Incremental_Alarm_value[3],
         fired_alarm_values_076),
     bnds_069 = [0, [1, [0, _a1_, [0, arg_077, 0]]], 0];
    function _ib_(_ic_){return 0;}
    var
     arg_075 = caml_call1(Sexplib0_Sexp_conv[24], _ib_),
     bnds_069$0 = [0, [1, [0, _a2_, [0, arg_075, 0]]], bnds_069],
     arg_073 =
       caml_call2(Incremental_Var[2], Incremental_Import[4][126], now_072),
     bnds_069$1 = [0, [1, [0, _a3_, [0, arg_073, 0]]], bnds_069$0],
     arg_071 =
       caml_call2
        (Timing_wheel[2], Incremental_Alarm_value[3], timing_wheel_070),
     bnds_069$2 = [0, [1, [0, _a4_, [0, arg_071, 0]]], bnds_069$1];
    return [1, bnds_069$2];
   }
   function invariant$1(t){
    function _h6_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      _h7_ =
        check
         (function(fired_alarm_values){
           if(caml_call1(Incremental_Import[6][7], fired_alarm_values))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _a5_], 1);
          });
     function _h8_(_ia_){return 0;}
     var
      _h9_ =
        check
         (function(now){
           var _h$_ = caml_call1(Timing_wheel[11], t[1]);
           if(caml_call2(Incremental_Import[4][21], now[1], _h$_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _a6_], 1);
          }),
      _h__ = check(caml_call1(Timing_wheel[6], Incremental_Alarm_value[2]));
     return caml_call4(Fields$1[5], _h__, _h9_, _h8_, _h7_);
    }
    return caml_call4(Base_Invariant[1], _a7_, t, sexp_of_t$3, _h6_);
   }
   function incr_state(t){return caml_call1(Incremental_Var[5], t[2]);}
   var
    Clock =
      [0,
       fired_alarm_values,
       set_fired_alarm_values,
       handle_fired,
       now,
       timing_wheel,
       Fields$1,
       sexp_of_t$3,
       invariant$1,
       incr_state];
   function now$1(clock){return clock[2][1];}
   function timing_wheel_length(clock){
    return caml_call1(Timing_wheel[14], clock[1]);
   }
   function num_stabilizes(t){
    return caml_call1(Incremental_Stabilization_num[10], t[3]);
   }
   function max_height_allowed(t){
    return caml_call1(Incremental_Adjust_heights_hea[5], t[6]);
   }
   function max_height_seen(t){
    return caml_call1(Incremental_Adjust_heights_hea[7], t[6]);
   }
   function iter_observers(t, f){
    var r = [0, t[9]];
    for(;;){
     if(! caml_call1(Incremental_Import[6][8], r[1])) return 0;
     var observer = caml_call1(Incremental_Import[6][16], r[1]);
     r[1] = caml_call1(Incremental_Internal_observer[10][3], observer);
     caml_call1(f, observer);
    }
   }
   function directly_observed(t){
    var r = [0, 0];
    iter_observers(t, function(param){r[1] = [0, param[2], r[1]]; return 0;});
    return r[1];
   }
   function iter_observer_descendants(t, f){
    var _h5_ = directly_observed(t);
    return caml_call2(Incremental_Node[1][4], _h5_, f);
   }
   function t_of_sexp(x_085){
    function _hX_(param){
     var
      percentage_of_nodes_by_num_par = param[2][1],
      max_num_parents = param[1];
     return [0, max_num_parents, percentage_of_nodes_by_num_par];
    }
    var _hY_ = 0;
    function _hZ_(param){
     return caml_string_notequal(param, cst_max_num_parents$0)
             ? caml_string_notequal
                (param, cst_percentage_of_nodes_by_num$0)
               ? -1
               : 1
             : 0;
    }
    var _h0_ = 0;
    function _h1_(sexp_084){
     if(1 === sexp_084[0]){
      var _h3_ = sexp_084[1];
      if(_h3_){
       var _h4_ = _h3_[2];
       if(_h4_ && ! _h4_[2]){
        var
         arg1_081 = _h4_[1],
         arg0_080 = _h3_[1],
         res0_082 = caml_call1(Core[390], arg0_080),
         res1_083 = caml_call1(Core_Percent[9], arg1_081);
        return [0, res0_082, res1_083];
       }
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4], error_source_079, 2, sexp_084);
    }
    var
     _h2_ =
       [0,
        cst_percentage_of_nodes_by_num,
        1,
        caml_call1(Core[473], _h1_),
        _h0_];
    return caml_call6
            (Sexplib0_Sexp_conv_record[3],
             error_source_079,
             [0, cst_max_num_parents, 1, Core[390], _h2_],
             _hZ_,
             _hY_,
             _hX_,
             x_085);
   }
   function sexp_of_t$4(param){
    var
     percentage_of_nodes_by_num_par = param[2],
     max_num_parents_087 = param[1],
     bnds_086 = 0;
    function _hW_(param){
     var
      arg1_092 = param[2],
      arg0_091 = param[1],
      res0_093 = caml_call1(Core[389], arg0_091),
      res1_094 = caml_call1(Core_Percent[10], arg1_092);
     return [1, [0, res0_093, [0, res1_094, 0]]];
    }
    var
     arg_090 = caml_call2(Core[472], _hW_, percentage_of_nodes_by_num_par),
     bnds_086$0 = [0, [1, [0, _a8_, [0, arg_090, 0]]], bnds_086],
     arg_088 = caml_call1(Core[389], max_num_parents_087),
     bnds_086$1 = [0, [1, [0, _a9_, [0, arg_088, 0]]], bnds_086$0];
    return [1, bnds_086$1];
   }
   var Stats = [0, t_of_sexp, sexp_of_t$4];
   function stats(t){
    var max_num_parents = [0, -1], num_necessary_nodes = [0, 0];
    iter_observer_descendants
     (t,
      function(param){
       num_necessary_nodes[1]++;
       max_num_parents[1] =
        caml_call2(Core_Int[90], max_num_parents[1], param[9]);
       return 0;
      });
    var
     max_num_parents$0 = max_num_parents[1],
     num_nodes_by_num_parents =
       caml_call2(Incremental_Import[5][63], max_num_parents$0 + 1 | 0, 0);
    iter_observer_descendants
     (t,
      function(param){
       var num_parents = param[9];
       num_nodes_by_num_parents[1 + num_parents] =
        caml_check_bound(num_nodes_by_num_parents, num_parents)
         [1 + num_parents]
        + 1
        | 0;
       return 0;
      });
    function _hU_(i, ac, num_nodes){
     return caml_call2(Core[90], num_nodes, 0)
             ? ac
             : [0,
               [0,
                i,
                caml_call1
                 (Core_Percent[76], num_nodes / num_necessary_nodes[1])],
               ac];
    }
    var
     _hV_ =
       caml_call3
        (Incremental_Import[5][49], num_nodes_by_num_parents, 0, _hU_),
     percentage_of_nodes_by_num_par = caml_call1(Core_List[59], _hV_);
    return [0, max_num_parents$0, percentage_of_nodes_by_num_par];
   }
   function am_stabilizing(t){
    var match = t[1];
    if(typeof match === "number") return 2 <= match ? 0 : 1;
    var raised_exn = match[1];
    return caml_call2
            (Incremental_Raised_exn[4],
             raised_exn,
             cst_cannot_call_am_stabilizing);
   }
   function invariant$2(t){
    if(typeof t[1] !== "number") return 0;
    function _g1_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     iter_observers
      (t,
       function(internal_observer){
        if(1 < internal_observer[1] - 1 >>> 0){
         var
          _hQ_ =
            function(x_095){
             function _hT_(param){return _a__;}
             return caml_call2(Incremental_Internal_observer[2], _hT_, x_095);
            };
         caml_call5
          (Core[247],
           0,
           _a$_,
           cst_member_of_all_observers_wi,
           internal_observer,
           _hQ_);
        }
        function _hR_(_hS_){return 0;}
        return caml_call2
                (Incremental_Internal_observer[1], _hR_, internal_observer);
       });
     iter_observer_descendants
      (t,
       function(node){
        function _hN_(_hP_){return 0;}
        caml_call2(Incremental_Node[4], _hN_, node);
        if
         (1 - am_stabilizing(t)
          && ! caml_call1(Incremental_Import[6][7], node[20]))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _bb_], 1);
        var _hO_ = caml_call1(Incremental_Adjust_heights_hea[7], t[6]);
        if(caml_call2(Core[89], node[14], _hO_)) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _ba_], 1);
       });
     var
      _g2_ = caml_call1(Incremental_Recompute_heap[5], t[5]),
      _g3_ = caml_call1(Incremental_Adjust_heights_hea[5], t[6]);
     if(! caml_call2(Core[90], _g3_, _g2_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bl_], 1);
     function _g4_(_hM_){return 0;}
     function _g5_(_hL_){return 0;}
     function _g6_(_hK_){return 0;}
     function _g7_(_hJ_){return 0;}
     function _g8_(_hI_){return 0;}
     function _g9_(_hH_){return 0;}
     function _g__(_hG_){return 0;}
     function _g$_(_hF_){return 0;}
     function _ha_(_hE_){return 0;}
     function _hb_(_hD_){return 0;}
     function _hc_(_hC_){return 0;}
     var
      _hd_ = check(Only_in_debug[7]),
      _he_ = check(caml_call1(Core_Stack[4], Run_on_update_handlers[2])),
      _hf_ = check(caml_call1(Core_Stack[4], Incremental_Node[1][2])),
      _hg_ =
        check
         (function(set_during_stabilization){
           var _hA_ = t[1];
           if(typeof _hA_ !== "number")
            throw caml_maybe_attach_backtrace([0, Assert_failure, _be_], 1);
           if(! _hA_){
            var
             _hB_ =
               function(param){
                if(caml_call1(Incremental_Import[6][8], param[2])) return 0;
                throw caml_maybe_attach_backtrace
                       ([0, Assert_failure, _bd_], 1);
               };
            return caml_call2(Core_Stack[4], _hB_, set_during_stabilization);
           }
           if(caml_call1(Core_Stack[7], set_during_stabilization)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bc_], 1);
          });
     function _hh_(packed){
      caml_call1(Incremental_Internal_observer[10][2], packed);
      if(2 === packed[1]) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bf_], 1);
     }
     var _hi_ = check(caml_call1(Core_Stack[4], _hh_));
     function _hj_(packed){
      caml_call1(Incremental_Internal_observer[10][2], packed);
      if(1 < packed[1] - 1 >>> 0) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bg_], 1);
     }
     var _hk_ = check(caml_call1(Core_Stack[4], _hj_));
     function _hl_(_hz_){return 0;}
     function _hm_(_hy_){return 0;}
     var
      _hn_ =
        check
         (function(num_active_observers){
           if(caml_call2(Core[88], num_active_observers, 0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bh_], 1);
          }),
      _ho_ =
        check
         (function(propagate_invalidity){
           if(caml_call1(Core_Stack[7], propagate_invalidity)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bi_], 1);
          }),
      _hp_ =
        check
         (function(adjust_heights_heap){
           var
            _hx_ =
              caml_call1
               (Incremental_Adjust_heights_hea[4], adjust_heights_heap);
           if(caml_call2(Core[90], _hx_, 0))
            return caml_call1
                    (Incremental_Adjust_heights_hea[2], adjust_heights_heap);
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bj_], 1);
          }),
      _hq_ = check(Incremental_Recompute_heap[2]),
      _hr_ =
        check
         (function(current_scope){
           if(current_scope === Incremental_Scope[3]) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _bk_], 1);
          }),
      _hs_ = check(Incremental_Stabilization_num[4]);
     function _ht_(_hw_){return 0;}
     function _hu_(_hv_){return 0;}
     return caml_call27
             (Fields$0[28],
              _hu_,
              _ht_,
              _hs_,
              _hr_,
              _hq_,
              _hp_,
              _ho_,
              _hn_,
              _hm_,
              _hl_,
              _hk_,
              _hi_,
              _hg_,
              _hf_,
              _he_,
              _hd_,
              _hc_,
              _hb_,
              _ha_,
              _g$_,
              _g__,
              _g9_,
              _g8_,
              _g7_,
              _g6_,
              _g5_,
              _g4_);
    }
    return caml_call4(Base_Invariant[1], _bm_, t, sexp_of_t$2, _g1_);
   }
   function ensure_not_stabilizing(t, name, allow_in_update_handler){
    var match = t[1];
    if(typeof match === "number")
     switch(match){
       case 0:
        var
         backtrace = caml_call2(Base_Backtrace[2], 0, 0),
         _gV_ = Base_Backtrace[1],
         _gW_ = caml_call2(Core[265], _bn_, name);
        return caml_call5(Core[247], 0, _bo_, _gW_, backtrace, _gV_);
       case 1:
        var _gX_ = 1 - allow_in_update_handler;
        if(! _gX_) return _gX_;
        var
         backtrace$0 = caml_call2(Base_Backtrace[2], 0, 0),
         _gY_ = Base_Backtrace[1],
         _gZ_ = caml_call2(Core[265], _bp_, name);
        return caml_call5(Core[247], 0, _bq_, _gZ_, backtrace$0, _gY_);
       default: return 0;
     }
    var raised_exn = match[1], _g0_ = caml_call2(Core[265], _br_, name);
    return caml_call2(Incremental_Raised_exn[4], raised_exn, _g0_);
   }
   function set_height(node, height){
    var t = node[2];
    return caml_call3(Incremental_Adjust_heights_hea[8], t[6], node, height);
   }
   function set_max_height_allowed(t, height){
    ensure_not_stabilizing(t, cst_set_max_height_allowed, 1);
    caml_call2(Incremental_Adjust_heights_hea[6], t[6], height);
    return caml_call2(Incremental_Recompute_heap[6], t[5], height);
   }
   function handle_after_stabilization$1(node){
    var _gU_ = 1 - node[22];
    if(! _gU_) return _gU_;
    var t = node[2];
    node[22] = 1;
    return caml_call2(Core_Stack[25], t[14], node);
   }
   function remove_children(parent){
    function _gT_(child_index, param){
     return remove_child(param, parent, child_index);
    }
    return caml_call2(Incremental_Node[8], parent, _gT_);
   }
   function remove_child(child, parent, child_index){
    caml_call3(Incremental_Node[11], child, parent, child_index);
    return check_if_unnecessary(child);
   }
   function check_if_unnecessary(node){
    var _gS_ = 1 - caml_call1(Incremental_Node[15], node);
    return _gS_ ? became_unnecessary(node) : _gS_;
   }
   function became_unnecessary(node){
    var t = node[2];
    t[20] = t[20] + 1 | 0;
    if(caml_call2(Core[91], node[8], 0)) handle_after_stabilization$1(node);
    node[14] = -1;
    remove_children(node);
    var match = node[5];
    a:
    if(typeof match !== "number")
     switch(match[0]){
       case 6:
        var p = match[1]; caml_call2(Incremental_Expert[14], p, 0); break a;
       case 15:
        var u = match[1];
        caml_call1(Incremental_Unordered_array_fo[7], u);
        break a;
     }
    if(Incremental_Import[1] && caml_call1(Incremental_Node[20], node))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bs_], 1);
    var _gR_ = caml_call1(Incremental_Node[14], node);
    return _gR_ ? caml_call2(Incremental_Recompute_heap[9], t[5], node) : _gR_;
   }
   function remove_alarm(clock, alarm){
    var _gQ_ = caml_call2(Timing_wheel[28], clock[1], alarm);
    return _gQ_ ? caml_call2(Timing_wheel[29], clock[1], alarm) : _gQ_;
   }
   function invalidate_node(node){
    var _gJ_ = caml_call1(Incremental_Node[16], node);
    if(_gJ_){
     var t = node[2];
     if(caml_call2(Core[91], node[8], 0)) handle_after_stabilization$1(node);
     node[4] = Incremental_Import[6][5];
     if
      (Incremental_Import[1]
       && ! caml_call1(Incremental_Import[6][7], node[20]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bu_], 1);
     node[7] = t[3];
     node[3] = t[3];
     t[23] = t[23] + 1 | 0;
     if(caml_call1(Incremental_Node[15], node)){
      remove_children(node);
      node[14] = caml_call1(Incremental_Scope[5], node[12]) + 1 | 0;
     }
     var match = node[5];
     a:
     if(typeof match !== "number")
      switch(match[0]){
        case 1:
         var at = match[1]; remove_alarm(at[4], at[3]); break a;
        case 2:
         var at_intervals = match[1];
         remove_alarm(at_intervals[5], at_intervals[4]);
         break a;
        case 4:
         var bind = match[1];
         invalidate_nodes_created_on_rh(bind[7]);
         break a;
        case 14:
         var match$0 = match[1], alarm = match$0[6], clock = match$0[8];
         remove_alarm(clock, alarm);
         break a;
      }
     caml_call2(Incremental_Node[6], node, 0);
     var _gL_ = node[9] - 1 | 0, _gK_ = 0;
     if(_gL_ >= 0){
      var index = _gK_;
      for(;;){
       var _gO_ = caml_call2(Incremental_Node[9], node, index);
       caml_call2(Core_Stack[25], t[7], _gO_);
       var _gP_ = index + 1 | 0;
       if(_gL_ === index) break;
       var index = _gP_;
      }
     }
     if(Incremental_Import[1] && caml_call1(Incremental_Node[20], node))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bt_], 1);
     var _gM_ = caml_call1(Incremental_Node[14], node);
     if(_gM_) return caml_call2(Incremental_Recompute_heap[9], t[5], node);
     var _gN_ = _gM_;
    }
    else
     var _gN_ = _gJ_;
    return _gN_;
   }
   function invalidate_nodes_created_on_rh(node){
    var r = [0, node];
    for(;;){
     if(! caml_call1(Incremental_Import[6][8], r[1])) return 0;
     var match = caml_call1(Incremental_Import[6][16], r[1]);
     r[1] = match[13];
     match[13] = Incremental_Import[6][5];
     invalidate_node(match);
    }
   }
   function rescope_nodes_created_on_rhs(t, first_node_on_rhs, new_scope){
    var r = [0, first_node_on_rhs];
    for(;;){
     if(! caml_call1(Incremental_Import[6][8], r[1])) return 0;
     var match = caml_call1(Incremental_Import[6][16], r[1]);
     r[1] = match[13];
     match[13] = Incremental_Import[6][5];
     match[12] = new_scope;
     caml_call2(Incremental_Scope[8], new_scope, match);
    }
   }
   function propagate_invalidity$1(t){
    for(;;){
     if(caml_call1(Core_Stack[7], t[7])) return 0;
     var node = caml_call1(Core_Stack[27], t[7]);
     if(caml_call1(Incremental_Node[16], node))
      if(caml_call1(Incremental_Node[17], node))
       invalidate_node(node);
      else{
       if(Incremental_Import[1] && ! caml_call1(Incremental_Node[20], node))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _bw_], 1);
       var kind = node[5];
       a:
       {
        if(typeof kind !== "number" && 6 === kind[0]){
         var expert = kind[1];
         caml_call1(Incremental_Expert[7], expert);
         break a;
        }
        if(Incremental_Import[1]){
         if(typeof kind !== "number")
          switch(kind[0]){case 4:case 9:case 11: break a;}
         throw caml_maybe_attach_backtrace([0, Assert_failure, _bv_], 1);
        }
       }
       if(1 - caml_call1(Incremental_Node[14], node))
        caml_call2(Incremental_Recompute_heap[8], t[5], node);
      }
    }
   }
   function add_parent_without_adjusting_h(child, parent, child_index){
    if(Incremental_Import[1] && ! caml_call1(Incremental_Node[15], parent))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _by_], 1);
    var t = child[2], was_necessary = caml_call1(Incremental_Node[15], child);
    caml_call3(Incremental_Node[10], child, parent, child_index);
    if(1 - caml_call1(Incremental_Node[16], child))
     caml_call2(Core_Stack[25], t[7], parent);
    if(1 - was_necessary) _bx_(child);
    var match = parent[5];
    if(typeof match !== "number" && 6 === match[0]){
     var e = match[1];
     return caml_call2(Incremental_Expert[15], e, child_index);
    }
    return 0;
   }
   function _bx_(node){
    var
     _gD_ = caml_call1(Incremental_Node[16], node),
     _gE_ = _gD_ ? 1 - caml_call1(Incremental_Scope[7], node[12]) : _gD_;
    if(_gE_){
     var
      _gF_ =
        function(x_096){
         function _gI_(param){return _bz_;}
         return caml_call2(Incremental_Node[2], _gI_, x_096);
        };
     caml_call5
      (Core[247], 0, _bA_, cst_Trying_to_make_a_node_nece, node, _gF_);
    }
    var t = node[2];
    t[19] = t[19] + 1 | 0;
    if(caml_call2(Core[91], node[8], 0)) handle_after_stabilization$1(node);
    set_height(node, caml_call1(Incremental_Scope[5], node[12]) + 1 | 0);
    function _gG_(child_index, child){
     add_parent_without_adjusting_h(child, node, child_index);
     if(Incremental_Import[1] && ! caml_call2(Core[88], child[14], 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bB_], 1);
     var _gH_ = caml_call2(Core[88], child[14], node[14]);
     return _gH_ ? set_height(node, child[14] + 1 | 0) : _gH_;
    }
    caml_call2(Incremental_Node[8], node, _gG_);
    if(Incremental_Import[1] && caml_call1(Incremental_Node[14], node))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bC_], 1);
    if(Incremental_Import[1] && ! caml_call1(Incremental_Node[15], node))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bD_], 1);
    if(caml_call1(Incremental_Node[19], node))
     caml_call2(Incremental_Recompute_heap[8], t[5], node);
    var match = node[5];
    if(typeof match !== "number" && 6 === match[0]){
     var p = match[1];
     return caml_call2(Incremental_Expert[14], p, 1);
    }
    return;
   }
   function became_necessary(node){
    _bx_(node);
    return propagate_invalidity$1(node[2]);
   }
   function add_parent(child, parent, child_index){
    if(Incremental_Import[1] && ! caml_call1(Incremental_Node[15], parent))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bF_], 1);
    var t = parent[2];
    add_parent_without_adjusting_h(child, parent, child_index);
    if(caml_call2(Core[88], child[14], parent[14]))
     caml_call4(Incremental_Adjust_heights_hea[9], t[6], t[5], child, parent);
    propagate_invalidity$1(t);
    if(Incremental_Import[1] && ! caml_call1(Incremental_Node[15], parent))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bE_], 1);
    var _gA_ = 1 - caml_call1(Incremental_Node[14], parent);
    if(_gA_)
     var
      _gB_ = caml_call1(Incremental_Stabilization_num[7], parent[3]),
      _gC_ = _gB_ || caml_call2(Incremental_Node[18], child, parent);
    else
     var _gC_ = _gA_;
    return _gC_
            ? caml_call2(Incremental_Recompute_heap[8], t[5], parent)
            : _gC_;
   }
   function run_with_scope(t, scope, f){
    var saved = t[4];
    t[4] = scope;
    try{var v = caml_call1(f, 0); t[4] = saved; return v;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[4] = saved;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function within_scope(t, scope, f){
    if(1 - caml_call1(Incremental_Scope[6], scope))
     caml_call5
      (Core[247], 0, _bG_, cst_attempt_to_run_within_an_i, t, sexp_of_t$2);
    return run_with_scope(t, scope, f);
   }
   function change_child(parent, old_child, new_child, child_index){
    if(caml_call1(Incremental_Import[6][7], old_child))
     return add_parent(new_child, parent, child_index);
    var
     old_child$0 = caml_call1(Incremental_Import[6][16], old_child),
     _gz_ = 1 - (old_child$0 === new_child ? 1 : 0);
    return _gz_
            ? (caml_call3
               (Incremental_Node[11], old_child$0, parent, child_index),
              old_child$0[26] = 1,
              add_parent(new_child, parent, child_index),
              old_child$0[26] = 0,
              check_if_unnecessary(old_child$0))
            : _gz_;
   }
   function add_alarm(clock, at, alarm_value){
    if(Incremental_Import[1]){
     var _gy_ = now$1(clock);
     if(! caml_call2(Incremental_Import[4][18], at, _gy_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bH_], 1);
    }
    return caml_call3(Timing_wheel[26], clock[1], at, alarm_value);
   }
   function recompute(node){
    var t = node[2];
    if(Incremental_Import[1]){t[16][1] = [0, node]; t[16][2] = 0;}
    t[24] = t[24] + 1 | 0;
    node[3] = t[3];
    var match = node[5];
    if(typeof match === "number"){
     if(0 === match)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _bI_], 1);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _bJ_], 1);
    }
    switch(match[0]){
      case 0:
       var array_fold = match[1];
       return maybe_change_value
               (node, caml_call1(Incremental_Array_fold[3], array_fold));
      case 1:
       var match$0 = match[1], at = match$0[2], clock = match$0[4];
       if(Incremental_Import[1]){
        var _eQ_ = now$1(clock);
        if(! caml_call2(Incremental_Import[4][18], at, _eQ_))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _bK_], 1);
       }
       return maybe_change_value(node, 0);
      case 2:
       return maybe_change_value(node, 0);
      case 3:
       var
        bind = match[1],
        main = bind[1],
        f = bind[2],
        lhs = bind[3],
        old_rhs = bind[5],
        rhs_scope = bind[6],
        old_all_nodes_created_on_rhs = bind[7];
       bind[7] = Incremental_Import[6][5];
       var
        rhs =
          run_with_scope
           (t,
            rhs_scope,
            function(param){
             return caml_call1(f, caml_call1(Incremental_Node[21], lhs));
            });
       bind[5] = caml_call1(Incremental_Import[6][6], rhs);
       node[7] = t[3];
       change_child(main, old_rhs, rhs, Incremental_Kind[6]);
       if(caml_call1(Incremental_Import[6][8], old_rhs)){
        if(t[2])
         invalidate_nodes_created_on_rh(old_all_nodes_created_on_rhs);
        else
         rescope_nodes_created_on_rhs
          (t, old_all_nodes_created_on_rhs, main[12]);
        propagate_invalidity$1(t);
       }
       if(Incremental_Import[1] && ! caml_call1(Incremental_Node[16], node))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _bL_], 1);
       return maybe_change_value(node, 0);
      case 4:
       var rhs$0 = match[1][5];
       return copy_child(node, caml_call1(Incremental_Import[6][9], rhs$0));
      case 5:
       var a = match[1]; return maybe_change_value(node, a);
      case 6:
       var expert = match[1];
       return 144245463 <= caml_call1(Incremental_Expert[13], expert)
               ? (invalidate_node(node), propagate_invalidity$1(t))
               : maybe_change_value(node, caml_call1(expert[1], 0));
      case 7:
       var
        match$1 = match[1],
        only_freeze_when = match$1[3],
        child = match$1[2],
        value = caml_call1(Incremental_Node[21], child);
       if(caml_call1(only_freeze_when, value)){
        remove_children(node);
        caml_call2(Incremental_Node[6], node, [5, value]);
        if(caml_call1(Incremental_Node[15], node))
         set_height(node, 0);
        else
         became_unnecessary(node);
       }
       return maybe_change_value(node, value);
      case 8:
       var
        if_then_else = match[1],
        test = if_then_else[2],
        main$0 = if_then_else[1],
        current_branch = if_then_else[4],
        else$0 = if_then_else[6],
        then = if_then_else[5],
        desired_branch =
          caml_call1(Incremental_Node[21], test) ? then : else$0;
       if_then_else[4] = caml_call1(Incremental_Import[6][6], desired_branch);
       node[7] = t[3];
       change_child
        (main$0, current_branch, desired_branch, Incremental_Kind[8]);
       return maybe_change_value(node, 0);
      case 9:
       var current_branch$0 = match[1][4];
       return copy_child
               (node, caml_call1(Incremental_Import[6][9], current_branch$0));
      case 10:
       var
        join = match[1],
        lhs$0 = join[2],
        main$1 = join[1],
        old_rhs$0 = join[4],
        rhs$1 = caml_call1(Incremental_Node[21], lhs$0);
       join[4] = caml_call1(Incremental_Import[6][6], rhs$1);
       node[7] = t[3];
       change_child(main$1, old_rhs$0, rhs$1, Incremental_Kind[9]);
       return maybe_change_value(node, 0);
      case 11:
       var rhs$2 = match[1][4];
       return copy_child(node, caml_call1(Incremental_Import[6][9], rhs$2));
      case 12:
       var n1 = match[2], f$0 = match[1];
       return maybe_change_value
               (node, caml_call1(f$0, caml_call1(Incremental_Node[21], n1)));
      case 13:
       var
        match$2 = match[1],
        clock$0 = match$2[5],
        before = match$2[3],
        at$0 = match$2[2];
       if(Incremental_Import[1]){
        var _eR_ = now$1(clock$0);
        if(! caml_call2(Incremental_Import[4][18], at$0, _eR_))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _bM_], 1);
       }
       return maybe_change_value(node, before);
      case 14:
       var
        step_function_node = match[1],
        child$0 = step_function_node[2],
        clock$1 = step_function_node[8];
       if(caml_call1(Incremental_Import[6][8], child$0)){
        var
         child$1 = caml_call1(Incremental_Import[6][9], child$0),
         _eS_ =
           caml_call2
            (Incremental_Stabilization_num[1],
             child$1[7],
             step_function_node[3]);
        if(caml_call2(Core[91], _eS_, 0)){
         step_function_node[3] = child$1[7];
         remove_alarm(clock$1, step_function_node[6]);
         var
          step_function = caml_call1(Incremental_Node[21], child$1),
          _eT_ = caml_call1(Incremental_step_function[3], step_function);
         step_function_node[4] = caml_call1(Incremental_Import[6][6], _eT_);
         step_function_node[5] =
          caml_call1(Incremental_step_function[4], step_function);
         if(caml_call1(Incremental_Node[13], child$1)){
          remove_children(node);
          step_function_node[2] = Incremental_Import[6][5];
          set_height(node, caml_call1(Incremental_Scope[5], node[12]) + 1 | 0);
         }
        }
       }
       var _eU_ = now$1(clock$1);
       caml_call2(Incremental_Step_function_node[3], step_function_node, _eU_);
       var
        step_function_value =
          caml_call1(Incremental_Import[6][9], step_function_node[4]),
        match$3 = caml_call1(Core_Sequence[65], step_function_node[5]);
       if(match$3){
        var at$1 = match$3[1][1];
        step_function_node[6] =
         add_alarm(clock$1, at$1, step_function_node[7]);
       }
       else if(caml_call1(Incremental_Import[6][7], child$0))
        caml_call2(Incremental_Node[6], node, [5, step_function_value]);
       return maybe_change_value(node, step_function_value);
      case 15:
       var u = match[1];
       return maybe_change_value
               (node, caml_call1(Incremental_Unordered_array_fo[5], u));
      case 16:
       var var$0 = match[1]; return maybe_change_value(node, var$0[1]);
      case 17:
       var
        n2 = match[3],
        n1$0 = match[2],
        f$1 = match[1],
        _eV_ = caml_call1(Incremental_Node[21], n2);
       return maybe_change_value
               (node,
                caml_call2(f$1, caml_call1(Incremental_Node[21], n1$0), _eV_));
      case 18:
       var
        n3 = match[4],
        n2$0 = match[3],
        n1$1 = match[2],
        f$2 = match[1],
        _eW_ = caml_call1(Incremental_Node[21], n3),
        _eX_ = caml_call1(Incremental_Node[21], n2$0);
       return maybe_change_value
               (node,
                caml_call3
                 (f$2, caml_call1(Incremental_Node[21], n1$1), _eX_, _eW_));
      case 19:
       var
        n4 = match[5],
        n3$0 = match[4],
        n2$1 = match[3],
        n1$2 = match[2],
        f$3 = match[1],
        _eY_ = caml_call1(Incremental_Node[21], n4),
        _eZ_ = caml_call1(Incremental_Node[21], n3$0),
        _e0_ = caml_call1(Incremental_Node[21], n2$1);
       return maybe_change_value
               (node,
                caml_call4
                 (f$3,
                  caml_call1(Incremental_Node[21], n1$2),
                  _e0_,
                  _eZ_,
                  _eY_));
      case 20:
       var
        n5 = match[6],
        n4$0 = match[5],
        n3$1 = match[4],
        n2$2 = match[3],
        n1$3 = match[2],
        f$4 = match[1],
        _e1_ = caml_call1(Incremental_Node[21], n5),
        _e2_ = caml_call1(Incremental_Node[21], n4$0),
        _e3_ = caml_call1(Incremental_Node[21], n3$1),
        _e4_ = caml_call1(Incremental_Node[21], n2$2);
       return maybe_change_value
               (node,
                caml_call5
                 (f$4,
                  caml_call1(Incremental_Node[21], n1$3),
                  _e4_,
                  _e3_,
                  _e2_,
                  _e1_));
      case 21:
       var
        n6 = match[7],
        n5$0 = match[6],
        n4$1 = match[5],
        n3$2 = match[4],
        n2$3 = match[3],
        n1$4 = match[2],
        f$5 = match[1],
        _e5_ = caml_call1(Incremental_Node[21], n6),
        _e6_ = caml_call1(Incremental_Node[21], n5$0),
        _e7_ = caml_call1(Incremental_Node[21], n4$1),
        _e8_ = caml_call1(Incremental_Node[21], n3$2),
        _e9_ = caml_call1(Incremental_Node[21], n2$3);
       return maybe_change_value
               (node,
                caml_call6
                 (f$5,
                  caml_call1(Incremental_Node[21], n1$4),
                  _e9_,
                  _e8_,
                  _e7_,
                  _e6_,
                  _e5_));
      case 22:
       var
        n7 = match[8],
        n6$0 = match[7],
        n5$1 = match[6],
        n4$2 = match[5],
        n3$3 = match[4],
        n2$4 = match[3],
        n1$5 = match[2],
        f$6 = match[1],
        _e__ = caml_call1(Incremental_Node[21], n7),
        _e$_ = caml_call1(Incremental_Node[21], n6$0),
        _fa_ = caml_call1(Incremental_Node[21], n5$1),
        _fb_ = caml_call1(Incremental_Node[21], n4$2),
        _fc_ = caml_call1(Incremental_Node[21], n3$3),
        _fd_ = caml_call1(Incremental_Node[21], n2$4);
       return maybe_change_value
               (node,
                caml_call7
                 (f$6,
                  caml_call1(Incremental_Node[21], n1$5),
                  _fd_,
                  _fc_,
                  _fb_,
                  _fa_,
                  _e$_,
                  _e__));
      case 23:
       var
        n8 = match[9],
        n7$0 = match[8],
        n6$1 = match[7],
        n5$2 = match[6],
        n4$3 = match[5],
        n3$4 = match[4],
        n2$5 = match[3],
        n1$6 = match[2],
        f$7 = match[1],
        _fe_ = caml_call1(Incremental_Node[21], n8),
        _ff_ = caml_call1(Incremental_Node[21], n7$0),
        _fg_ = caml_call1(Incremental_Node[21], n6$1),
        _fh_ = caml_call1(Incremental_Node[21], n5$2),
        _fi_ = caml_call1(Incremental_Node[21], n4$3),
        _fj_ = caml_call1(Incremental_Node[21], n3$4),
        _fk_ = caml_call1(Incremental_Node[21], n2$5);
       return maybe_change_value
               (node,
                caml_call8
                 (f$7,
                  caml_call1(Incremental_Node[21], n1$6),
                  _fk_,
                  _fj_,
                  _fi_,
                  _fh_,
                  _fg_,
                  _ff_,
                  _fe_));
      case 24:
       var
        n9 = match[10],
        n8$0 = match[9],
        n7$1 = match[8],
        n6$2 = match[7],
        n5$3 = match[6],
        n4$4 = match[5],
        n3$5 = match[4],
        n2$6 = match[3],
        n1$7 = match[2],
        f$8 = match[1],
        _fl_ = caml_call1(Incremental_Node[21], n9),
        _fm_ = caml_call1(Incremental_Node[21], n8$0),
        _fn_ = caml_call1(Incremental_Node[21], n7$1),
        _fo_ = caml_call1(Incremental_Node[21], n6$2),
        _fp_ = caml_call1(Incremental_Node[21], n5$3),
        _fq_ = caml_call1(Incremental_Node[21], n4$4),
        _fr_ = caml_call1(Incremental_Node[21], n3$5),
        _fs_ = caml_call1(Incremental_Node[21], n2$6);
       return maybe_change_value
               (node,
                caml_call9
                 (f$8,
                  caml_call1(Incremental_Node[21], n1$7),
                  _fs_,
                  _fr_,
                  _fq_,
                  _fp_,
                  _fo_,
                  _fn_,
                  _fm_,
                  _fl_));
      case 25:
       var
        n10 = match[11],
        n9$0 = match[10],
        n8$1 = match[9],
        n7$2 = match[8],
        n6$3 = match[7],
        n5$4 = match[6],
        n4$5 = match[5],
        n3$6 = match[4],
        n2$7 = match[3],
        n1$8 = match[2],
        f$9 = match[1],
        _ft_ = caml_call1(Incremental_Node[21], n10),
        _fu_ = caml_call1(Incremental_Node[21], n9$0),
        _fv_ = caml_call1(Incremental_Node[21], n8$1),
        _fw_ = caml_call1(Incremental_Node[21], n7$2),
        _fx_ = caml_call1(Incremental_Node[21], n6$3),
        _fy_ = caml_call1(Incremental_Node[21], n5$4),
        _fz_ = caml_call1(Incremental_Node[21], n4$5),
        _fA_ = caml_call1(Incremental_Node[21], n3$6),
        _fB_ = caml_call1(Incremental_Node[21], n2$7);
       return maybe_change_value
               (node,
                caml_call10
                 (f$9,
                  caml_call1(Incremental_Node[21], n1$8),
                  _fB_,
                  _fA_,
                  _fz_,
                  _fy_,
                  _fx_,
                  _fw_,
                  _fv_,
                  _fu_,
                  _ft_));
      case 26:
       var
        n11 = match[12],
        n10$0 = match[11],
        n9$1 = match[10],
        n8$2 = match[9],
        n7$3 = match[8],
        n6$4 = match[7],
        n5$5 = match[6],
        n4$6 = match[5],
        n3$7 = match[4],
        n2$8 = match[3],
        n1$9 = match[2],
        f$10 = match[1],
        _fC_ = caml_call1(Incremental_Node[21], n11),
        _fD_ = caml_call1(Incremental_Node[21], n10$0),
        _fE_ = caml_call1(Incremental_Node[21], n9$1),
        _fF_ = caml_call1(Incremental_Node[21], n8$2),
        _fG_ = caml_call1(Incremental_Node[21], n7$3),
        _fH_ = caml_call1(Incremental_Node[21], n6$4),
        _fI_ = caml_call1(Incremental_Node[21], n5$5),
        _fJ_ = caml_call1(Incremental_Node[21], n4$6),
        _fK_ = caml_call1(Incremental_Node[21], n3$7),
        _fL_ = caml_call1(Incremental_Node[21], n2$8);
       return maybe_change_value
               (node,
                caml_call11
                 (f$10,
                  caml_call1(Incremental_Node[21], n1$9),
                  _fL_,
                  _fK_,
                  _fJ_,
                  _fI_,
                  _fH_,
                  _fG_,
                  _fF_,
                  _fE_,
                  _fD_,
                  _fC_));
      case 27:
       var
        n12 = match[13],
        n11$0 = match[12],
        n10$1 = match[11],
        n9$2 = match[10],
        n8$3 = match[9],
        n7$4 = match[8],
        n6$5 = match[7],
        n5$6 = match[6],
        n4$7 = match[5],
        n3$8 = match[4],
        n2$9 = match[3],
        n1$10 = match[2],
        f$11 = match[1],
        _fM_ = caml_call1(Incremental_Node[21], n12),
        _fN_ = caml_call1(Incremental_Node[21], n11$0),
        _fO_ = caml_call1(Incremental_Node[21], n10$1),
        _fP_ = caml_call1(Incremental_Node[21], n9$2),
        _fQ_ = caml_call1(Incremental_Node[21], n8$3),
        _fR_ = caml_call1(Incremental_Node[21], n7$4),
        _fS_ = caml_call1(Incremental_Node[21], n6$5),
        _fT_ = caml_call1(Incremental_Node[21], n5$6),
        _fU_ = caml_call1(Incremental_Node[21], n4$7),
        _fV_ = caml_call1(Incremental_Node[21], n3$8),
        _fW_ = caml_call1(Incremental_Node[21], n2$9);
       return maybe_change_value
               (node,
                caml_call12
                 (f$11,
                  caml_call1(Incremental_Node[21], n1$10),
                  _fW_,
                  _fV_,
                  _fU_,
                  _fT_,
                  _fS_,
                  _fR_,
                  _fQ_,
                  _fP_,
                  _fO_,
                  _fN_,
                  _fM_));
      case 28:
       var
        n13 = match[14],
        n12$0 = match[13],
        n11$1 = match[12],
        n10$2 = match[11],
        n9$3 = match[10],
        n8$4 = match[9],
        n7$5 = match[8],
        n6$6 = match[7],
        n5$7 = match[6],
        n4$8 = match[5],
        n3$9 = match[4],
        n2$10 = match[3],
        n1$11 = match[2],
        f$12 = match[1],
        _fX_ = caml_call1(Incremental_Node[21], n13),
        _fY_ = caml_call1(Incremental_Node[21], n12$0),
        _fZ_ = caml_call1(Incremental_Node[21], n11$1),
        _f0_ = caml_call1(Incremental_Node[21], n10$2),
        _f1_ = caml_call1(Incremental_Node[21], n9$3),
        _f2_ = caml_call1(Incremental_Node[21], n8$4),
        _f3_ = caml_call1(Incremental_Node[21], n7$5),
        _f4_ = caml_call1(Incremental_Node[21], n6$6),
        _f5_ = caml_call1(Incremental_Node[21], n5$7),
        _f6_ = caml_call1(Incremental_Node[21], n4$8),
        _f7_ = caml_call1(Incremental_Node[21], n3$9),
        _f8_ = caml_call1(Incremental_Node[21], n2$10);
       return maybe_change_value
               (node,
                caml_call13
                 (f$12,
                  caml_call1(Incremental_Node[21], n1$11),
                  _f8_,
                  _f7_,
                  _f6_,
                  _f5_,
                  _f4_,
                  _f3_,
                  _f2_,
                  _f1_,
                  _f0_,
                  _fZ_,
                  _fY_,
                  _fX_));
      case 29:
       var
        n14 = match[15],
        n13$0 = match[14],
        n12$1 = match[13],
        n11$2 = match[12],
        n10$3 = match[11],
        n9$4 = match[10],
        n8$5 = match[9],
        n7$6 = match[8],
        n6$7 = match[7],
        n5$8 = match[6],
        n4$9 = match[5],
        n3$10 = match[4],
        n2$11 = match[3],
        n1$12 = match[2],
        f$13 = match[1],
        _f9_ = caml_call1(Incremental_Node[21], n14),
        _f__ = caml_call1(Incremental_Node[21], n13$0),
        _f$_ = caml_call1(Incremental_Node[21], n12$1),
        _ga_ = caml_call1(Incremental_Node[21], n11$2),
        _gb_ = caml_call1(Incremental_Node[21], n10$3),
        _gc_ = caml_call1(Incremental_Node[21], n9$4),
        _gd_ = caml_call1(Incremental_Node[21], n8$5),
        _ge_ = caml_call1(Incremental_Node[21], n7$6),
        _gf_ = caml_call1(Incremental_Node[21], n6$7),
        _gg_ = caml_call1(Incremental_Node[21], n5$8),
        _gh_ = caml_call1(Incremental_Node[21], n4$9),
        _gi_ = caml_call1(Incremental_Node[21], n3$10),
        _gj_ = caml_call1(Incremental_Node[21], n2$11);
       return maybe_change_value
               (node,
                caml_call14
                 (f$13,
                  caml_call1(Incremental_Node[21], n1$12),
                  _gj_,
                  _gi_,
                  _gh_,
                  _gg_,
                  _gf_,
                  _ge_,
                  _gd_,
                  _gc_,
                  _gb_,
                  _ga_,
                  _f$_,
                  _f__,
                  _f9_));
      default:
       var
        n15 = match[16],
        n14$0 = match[15],
        n13$1 = match[14],
        n12$2 = match[13],
        n11$3 = match[12],
        n10$4 = match[11],
        n9$5 = match[10],
        n8$6 = match[9],
        n7$7 = match[8],
        n6$8 = match[7],
        n5$9 = match[6],
        n4$10 = match[5],
        n3$11 = match[4],
        n2$12 = match[3],
        n1$13 = match[2],
        f$14 = match[1],
        _gk_ = caml_call1(Incremental_Node[21], n15),
        _gl_ = caml_call1(Incremental_Node[21], n14$0),
        _gm_ = caml_call1(Incremental_Node[21], n13$1),
        _gn_ = caml_call1(Incremental_Node[21], n12$2),
        _go_ = caml_call1(Incremental_Node[21], n11$3),
        _gp_ = caml_call1(Incremental_Node[21], n10$4),
        _gq_ = caml_call1(Incremental_Node[21], n9$5),
        _gr_ = caml_call1(Incremental_Node[21], n8$6),
        _gs_ = caml_call1(Incremental_Node[21], n7$7),
        _gt_ = caml_call1(Incremental_Node[21], n6$8),
        _gu_ = caml_call1(Incremental_Node[21], n5$9),
        _gv_ = caml_call1(Incremental_Node[21], n4$10),
        _gw_ = caml_call1(Incremental_Node[21], n3$11),
        _gx_ = caml_call1(Incremental_Node[21], n2$12);
       return maybe_change_value
               (node,
                caml_call15
                 (f$14,
                  caml_call1(Incremental_Node[21], n1$13),
                  _gx_,
                  _gw_,
                  _gv_,
                  _gu_,
                  _gt_,
                  _gs_,
                  _gr_,
                  _gq_,
                  _gp_,
                  _go_,
                  _gn_,
                  _gm_,
                  _gl_,
                  _gk_));
    }
   }
   function copy_child(parent, child){
    return caml_call1(Incremental_Node[16], child)
            ? maybe_change_value
              (parent, caml_call1(Incremental_Node[21], child))
            : (invalidate_node(parent), propagate_invalidity$1(parent[2]));
   }
   function maybe_change_value(node, new_value){
    var
     t = node[2],
     old_value_opt = node[4],
     _ez_ = caml_call1(Incremental_Import[6][7], old_value_opt);
    if(_ez_)
     var _eA_ = _ez_;
    else
     var
      _eP_ = caml_call1(Incremental_Import[6][16], old_value_opt),
      _eA_ = 1 - caml_call3(Incremental_Cutoff[11], node[6], _eP_, new_value);
    if(_eA_){
     node[4] = caml_call1(Incremental_Import[6][6], new_value);
     node[7] = t[3];
     t[21] = t[21] + 1 | 0;
     if(caml_call2(Core[91], node[8], 0)){
      node[20] = old_value_opt;
      handle_after_stabilization$1(node);
     }
     if(caml_call2(Core[88], node[9], 1)){
      var _eC_ = node[9] - 1 | 0, _eB_ = 1;
      if(_eC_ >= 1){
       var parent_index = _eB_;
       for(;;){
        var
         _eM_ =
           caml_call2
            (Incremental_Import[7][20], node[10], parent_index - 1 | 0),
         parent$0 = caml_call1(Incremental_Import[6][9], _eM_),
         match$1 = parent$0[5];
        a:
        if(typeof match$1 !== "number")
         switch(match$1[0]){
           case 6:
            var
             expert = match$1[1],
             child_index$0 =
               caml_check_bound(node[25], parent_index)[1 + parent_index];
            caml_call2(Incremental_Expert[15], expert, child_index$0);
            break a;
           case 15:
            var
             u$0 = match$1[1],
             _eO_ = caml_check_bound(node[25], parent_index)[1 + parent_index];
            caml_call5
             (Incremental_Unordered_array_fo[6],
              u$0,
              node,
              _eO_,
              old_value_opt,
              new_value);
            break a;
         }
        if
         (Incremental_Import[1]
          && ! caml_call1(Incremental_Node[20], parent$0))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _bU_], 1);
        if(1 - caml_call1(Incremental_Node[14], parent$0))
         caml_call2(Incremental_Recompute_heap[8], t[5], parent$0);
        var _eN_ = parent_index + 1 | 0;
        if(_eC_ === parent_index) break;
        var parent_index = _eN_;
       }
      }
      var
       parent = caml_call1(Incremental_Import[6][9], node[11]),
       match = parent[5];
      a:
      if(typeof match !== "number")
       switch(match[0]){
         case 6:
          var p = match[1], child_index = caml_check_bound(node[25], 0)[1];
          caml_call2(Incremental_Expert[15], p, child_index);
          break a;
         case 15:
          var u = match[1], _eL_ = caml_check_bound(node[25], 0)[1];
          caml_call5
           (Incremental_Unordered_array_fo[6],
            u,
            node,
            _eL_,
            old_value_opt,
            new_value);
          break a;
       }
      if(Incremental_Import[1] && ! caml_call1(Incremental_Node[20], parent))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _bT_], 1);
      a:
      if(1 - caml_call1(Incremental_Node[14], parent)){
       var match$0 = parent[5];
       b:
       {
        if(typeof match$0 !== "number"){
         switch(match$0[0]){
           case 1:
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bR_], 1);
           case 2:
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bS_], 1);
           case 3:
            var
             _eF_ = caml_call1(Incremental_Scope[5], parent[12]),
             can_recompute_now = caml_call2(Core[91], node[14], _eF_);
            break;
           case 4:
            var
             b = match$0[1],
             can_recompute_now = caml_call2(Core[91], node[14], b[4][14]);
            break;
           case 7:
            var
             _eG_ = caml_call1(Incremental_Scope[5], parent[12]),
             can_recompute_now = caml_call2(Core[91], node[14], _eG_);
            break;
           case 8:
            var
             _eH_ = caml_call1(Incremental_Scope[5], parent[12]),
             can_recompute_now = caml_call2(Core[91], node[14], _eH_);
            break;
           case 9:
            var
             i = match$0[1],
             can_recompute_now = caml_call2(Core[91], node[14], i[3][14]);
            break;
           case 10:
            var
             _eI_ = caml_call1(Incremental_Scope[5], parent[12]),
             can_recompute_now = caml_call2(Core[91], node[14], _eI_);
            break;
           case 11:
            var
             j = match$0[1],
             can_recompute_now = caml_call2(Core[91], node[14], j[3][14]);
            break;
           case 12:
            var
             _eJ_ = caml_call1(Incremental_Scope[5], parent[12]),
             can_recompute_now = caml_call2(Core[91], node[14], _eJ_);
            break;
           case 14:
            var
             _eK_ = caml_call1(Incremental_Scope[5], parent[12]),
             can_recompute_now = caml_call2(Core[91], node[14], _eK_);
            break;
           case 5:
           case 13:
           case 16:
            break b;
           default: var can_recompute_now = 0;
         }
         if(can_recompute_now){
          t[25] = t[25] + 1 | 0;
          recompute(parent);
         }
         else{
          var _eE_ = caml_call1(Incremental_Recompute_heap[7], t[5]);
          if(caml_call2(Core[89], parent[14], _eE_)){t[26] = t[26] + 1 | 0; recompute(parent);
          }
          else{
           if
            (Incremental_Import[1]
             && ! caml_call1(Incremental_Node[20], parent))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bQ_], 1);
           if
            (Incremental_Import[1] && caml_call1(Incremental_Node[14], parent))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _bP_], 1);
           caml_call2(Incremental_Recompute_heap[8], t[5], parent);
          }
         }
         break a;
        }
        if(1 === match$0)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _bO_], 1);
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _bN_], 1);
      }
     }
    }
    var _eD_ = Incremental_Import[1];
    return _eD_ ? invariant$2(t) : _eD_;
   }
   function recompute_first_node_that_is_n(r){
    var
     node = caml_call1(Incremental_Recompute_heap[10], r),
     _ev_ = Incremental_Import[1],
     _ew_ = _ev_ ? 1 - caml_call1(Incremental_Node[20], node) : _ev_;
    if(_ew_){
     var
      _ex_ =
        function(x_097){
         function _ey_(param){return _bV_;}
         return caml_call2(Incremental_Node[2], _ey_, x_097);
        };
     caml_call5
      (Core[247], 0, _bW_, cst_node_unexpectedly_does_not, node, _ex_);
    }
    return recompute(node);
   }
   function unlink_disallowed_observers(t){
    for(;;){
     var _et_ = caml_call1(Core_Stack[6], t[12]);
     if(! caml_call2(Core[91], _et_, 0)) return 0;
     var internal_observer = caml_call1(Core_Stack[27], t[12]);
     if(Incremental_Import[1]){
      var _eu_ = 2 === internal_observer[1] ? 1 : 0;
      if(! _eu_)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _bX_], 1);
     }
     internal_observer[1] = 3;
     var all_observers = caml_call1(Incremental_Import[6][9], t[9]);
     if
      (caml_call2
        (Incremental_Internal_observer[3], internal_observer, all_observers))
      t[9] = internal_observer[5];
     caml_call1(Incremental_Internal_observer[8], internal_observer);
     check_if_unnecessary(internal_observer[2]);
    }
   }
   function disallow_future_use(internal_observer){
    var
     t = caml_call1(Incremental_Internal_observer[9], internal_observer),
     _es_ = internal_observer[1];
    return 1 === _es_
            ? (t
               [8]
              = t[8] - 1 | 0,
              internal_observer[1] = 2,
              caml_call2(Core_Stack[25], t[12], internal_observer))
            : _es_
              ? 0
              : (t
                 [8]
                = t[8] - 1 | 0,
                internal_observer[1] = 3,
                internal_observer[3] = 0,
                0);
   }
   function disallow_finalized_observers(t){
    for(;;){
     var _er_ = caml_call1(Thread_safe_queue[4], t[10]);
     if(! caml_call2(Core[91], _er_, 0)) return 0;
     var internal_observer = caml_call1(Thread_safe_queue[6], t[10]);
     if(caml_call1(Core_List[18], internal_observer[3]))
      disallow_future_use(internal_observer);
    }
   }
   function observer_finalizer(t){
    function _eq_(observer){
     var internal_observer = observer[1];
     return caml_call2(Thread_safe_queue[5], t[10], internal_observer);
    }
    return caml_call1(Core[266], _eq_);
   }
   function create_observer(opt, observing){
    if(opt)
     var sth = opt[1], should_finalize = sth;
    else
     var should_finalize = 1;
    var
     t = observing[2],
     internal_observer =
       [0,
        0,
        observing,
        0,
        Incremental_Import[6][5],
        Incremental_Import[6][5],
        Incremental_Import[6][5],
        Incremental_Import[6][5]];
    caml_call2(Core_Stack[25], t[11], internal_observer);
    var observer = [0, internal_observer];
    if(should_finalize){
     var _eo_ = observer_finalizer(t), _ep_ = caml_call1(Core[267], _eo_);
     caml_call2(Core_Gc[15][2], observer, _ep_);
    }
    t[8] = t[8] + 1 | 0;
    return observer;
   }
   function add_new_observers(t){
    for(;;){
     var _ei_ = caml_call1(Core_Stack[6], t[11]);
     if(! caml_call2(Core[91], _ei_, 0)) return 0;
     var
      internal_observer = caml_call1(Core_Stack[27], t[11]),
      _ej_ = internal_observer[1];
     if(_ej_){
      if(3 > _ej_)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _bY_], 1);
     }
     else{
      internal_observer[1] = 1;
      var old_all_observers = t[9];
      if(caml_call1(Incremental_Import[6][8], old_all_observers)){
       internal_observer[5] = old_all_observers;
       var
        _ek_ = caml_call1(Incremental_Import[6][6], internal_observer),
        _el_ = caml_call1(Incremental_Import[6][16], old_all_observers);
       caml_call2(Incremental_Internal_observer[10][4], _el_, _ek_);
      }
      t[9] = caml_call1(Incremental_Import[6][6], internal_observer);
      var
       observing = internal_observer[2],
       was_necessary = caml_call1(Incremental_Node[15], observing),
       _em_ = caml_call1(Core_List[45], internal_observer[3]);
      observing[8] = observing[8] + _em_ | 0;
      var old_observers = observing[21];
      if(caml_call1(Incremental_Import[6][8], old_observers)){
       internal_observer[7] = old_observers;
       var _en_ = caml_call1(Incremental_Import[6][6], internal_observer);
       caml_call1(Incremental_Import[6][16], old_observers)[6] = _en_;
      }
      observing[21] = caml_call1(Incremental_Import[6][6], internal_observer);
      handle_after_stabilization$1(observing);
      if
       (Incremental_Import[1] && ! caml_call1(Incremental_Node[15], observing))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _bZ_], 1);
      if(1 - was_necessary) became_necessary(observing);
     }
    }
   }
   function observer_value_exn(observer){
    var t = caml_call1(Incremental_Observer[7], observer), match = t[1];
    if(typeof match !== "number"){
     var raised_exn = match[1];
     return caml_call2
             (Incremental_Raised_exn[4],
              raised_exn,
              cst_Observer_value_exn_called_$0);
    }
    if(match) return caml_call1(Incremental_Observer[5], observer);
    function _eg_(x_098){
     function _eh_(param){return _b0_;}
     return caml_call2(Incremental_Observer[2], _eh_, x_098);
    }
    return caml_call5
            (Core[247],
             0,
             _b1_,
             cst_Observer_value_exn_called_,
             observer,
             _eg_);
   }
   function observer_value(observer){
    try{var _ef_ = [0, observer_value_exn(observer)]; return _ef_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return [1, caml_call2(Core_Error[27], 0, exn)];
    }
   }
   function node_on_update(node, f){
    var
     t = node[2],
     _ee_ = caml_call2(Incremental_On_update_handler[3], f, t[3]);
    caml_call2(Incremental_Node[25], node, _ee_);
    return handle_after_stabilization$1(node);
   }
   function observer_on_update_exn(observer, f){
    var
     t = caml_call1(Incremental_Observer[7], observer),
     _ed_ = caml_call2(Incremental_On_update_handler[3], f, t[3]);
    caml_call2(Incremental_Observer[6], observer, _ed_);
    return handle_after_stabilization$1
            (caml_call1(Incremental_Observer[3], observer));
   }
   function set_var_while_not_stabilizing(var$0, value){
    var t = caml_call1(Incremental_Var[5], var$0);
    t[27] = t[27] + 1 | 0;
    var$0[1] = value;
    var
     _d__ = caml_call2(Incremental_Stabilization_num[1], var$0[3], t[3]),
     _d$_ = caml_call2(Core[92], _d__, 0);
    if(_d$_){
     var$0[3] = t[3];
     var watch = var$0[4];
     if(Incremental_Import[1] && ! caml_call1(Incremental_Node[19], watch))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b2_], 1);
     var
      _ea_ = caml_call1(Incremental_Node[15], watch),
      _eb_ = _ea_ ? 1 - caml_call1(Incremental_Node[14], watch) : _ea_;
     if(_eb_) return caml_call2(Incremental_Recompute_heap[8], t[5], watch);
     var _ec_ = _eb_;
    }
    else
     var _ec_ = _d$_;
    return _ec_;
   }
   function set_var(var$0, value){
    var t = caml_call1(Incremental_Var[5], var$0), match = t[1];
    if(typeof match !== "number"){
     var raised_exn = match[1];
     return caml_call2
             (Incremental_Raised_exn[4],
              raised_exn,
              cst_cannot_set_var_stabilizati);
    }
    if(match) return set_var_while_not_stabilizing(var$0, value);
    if(caml_call1(Incremental_Import[6][7], var$0[2]))
     caml_call2(Core_Stack[25], t[13], var$0);
    var$0[2] = caml_call1(Incremental_Import[6][6], value);
    return 0;
   }
   function reclaim_space_in_weak_hashtbls(t){
    for(;;){
     var _d9_ = caml_call1(Thread_safe_queue[4], t[17]);
     if(! caml_call2(Core[91], _d9_, 0)) return 0;
     var weak_hashtbl = caml_call1(Thread_safe_queue[6], t[17])[1];
     caml_call1(Weak_hashtbl[12], weak_hashtbl);
    }
   }
   function stabilize_start(t){
    t[1] = 0;
    disallow_finalized_observers(t);
    add_new_observers(t);
    unlink_disallowed_observers(t);
    var _d8_ = Incremental_Import[1];
    return _d8_ ? invariant$2(t) : _d8_;
   }
   function stabilize_end(t){
    if(Incremental_Import[1]){t[16][1] = 0; t[16][2] = 0;}
    t[3] = caml_call1(Incremental_Stabilization_num[9], t[3]);
    for(;;){
     if(caml_call1(Core_Stack[7], t[13])) break;
     var
      match$0 = caml_call1(Core_Stack[27], t[13]),
      value = caml_call1(Incremental_Import[6][9], match$0[2]);
     match$0[2] = Incremental_Import[6][5];
     set_var_while_not_stabilizing(match$0, value);
    }
    for(;;){
     if(caml_call1(Core_Stack[7], t[14])) break;
     var node$0 = caml_call1(Core_Stack[27], t[14]);
     node$0[22] = 0;
     var old_value = node$0[20];
     node$0[20] = Incremental_Import[6][5];
     if(caml_call1(Incremental_Node[16], node$0))
      if(caml_call1(Incremental_Node[15], node$0))
       var
        new_value = caml_call1(Incremental_Import[6][9], node$0[4]),
        _d7_ =
          caml_call1(Incremental_Import[6][7], old_value)
           ? [0, new_value]
           : [1, caml_call1(Incremental_Import[6][16], old_value), new_value],
        node_update$0 = _d7_;
      else
       var node_update$0 = 1;
     else
      var node_update$0 = 0;
     caml_call2(Core_Stack[25], t[15], [0, node$0, node_update$0]);
    }
    t[1] = 1;
    var now = t[3];
    for(;;){
     if(caml_call1(Core_Stack[7], t[15])){
      t[1] = 2;
      return reclaim_space_in_weak_hashtbls(t);
     }
     var
      match = caml_call1(Core_Stack[27], t[15]),
      node_update = match[2],
      node = match[1];
     caml_call3(Incremental_Node[26], node, node_update, now);
    }
   }
   function raise_during_stabilization(t, exn){
    var raised = caml_call1(Incremental_Raised_exn[2], exn);
    t[1] = [0, raised];
    return caml_call1(Incremental_Raised_exn[3], raised);
   }
   function stabilize(t){
    ensure_not_stabilizing(t, cst_stabilize, 0);
    try{
     stabilize_start(t);
     var r = t[5];
     for(;;){
      var _d5_ = caml_call1(Incremental_Recompute_heap[4], r);
      if(! caml_call2(Core[91], _d5_, 0)){
       var _d6_ = stabilize_end(t);
       return _d6_;
      }
      recompute_first_node_that_is_n(r);
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return raise_during_stabilization(t, exn);
    }
   }
   function sexp_of_t$5(param){return param ? _b3_ : _b4_;}
   var Step_result = [0, sexp_of_t$5];
   function do_one_step_of_stabilize(t){
    try{
     var _d1_ = t[1];
     a:
     if(typeof _d1_ === "number"){
      switch(_d1_){
        case 0:
         var
          r = t[5],
          _d2_ = caml_call1(Incremental_Recompute_heap[4], r),
          _d3_ =
            caml_call2(Core[91], _d2_, 0)
             ? (recompute_first_node_that_is_n(r), 0)
             : (stabilize_end(t), 1),
          _d4_ = _d3_;
         break;
        case 2:
         stabilize_start(t); var _d4_ = 0; break;
        default: break a;
      }
      return _d4_;
     }
     ensure_not_stabilizing(t, cst_step, 0);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b5_], 1);
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(typeof t[1] === "number") return raise_during_stabilization(t, exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function create_node_in(t, created_in, kind){
    t[22] = t[22] + 1 | 0;
    return caml_call3(Incremental_Node[5], t, created_in, kind);
   }
   function create_node(t, kind){return create_node_in(t, t[4], kind);}
   function create_node_top(t, kind){
    return create_node_in(t, Incremental_Scope[3], kind);
   }
   function create_var(t, opt, value){
    if(opt)
     var sth = opt[1], use_current_scope = sth;
    else
     var use_current_scope = 0;
    var
     scope = use_current_scope ? t[4] : Incremental_Scope[3],
     watch = create_node_in(t, scope, 1),
     var$0 = [0, value, Incremental_Import[6][5], t[3], watch];
    caml_call2(Incremental_Node[6], watch, [16, var$0]);
    return var$0;
   }
   function const$0(t, a){return create_node(t, [5, a]);}
   function map(n, f){return create_node(n[2], [12, f, n]);}
   function map2(n1, n2, f){return create_node(n1[2], [17, f, n1, n2]);}
   function both(n1, n2){
    var _d0_ = n1[5];
    a:
    if(typeof _d0_ !== "number" && 5 === _d0_[0]){
     var a = _d0_[1], match = n2[5];
     if(typeof match !== "number" && 5 === match[0]){
      var b = match[1];
      return const$0(n1[2], [0, a, b]);
     }
     break a;
    }
    return map2(n1, n2, Core_Tuple[1][6]);
   }
   function map3(n1, n2, n3, f){
    return create_node(n1[2], [18, f, n1, n2, n3]);
   }
   function map4(n1, n2, n3, n4, f){
    return create_node(n1[2], [19, f, n1, n2, n3, n4]);
   }
   function map5(n1, n2, n3, n4, n5, f){
    return create_node(n1[2], [20, f, n1, n2, n3, n4, n5]);
   }
   function map6(n1, n2, n3, n4, n5, n6, f){
    return create_node(n1[2], [21, f, n1, n2, n3, n4, n5, n6]);
   }
   function map7(n1, n2, n3, n4, n5, n6, n7, f){
    return create_node(n1[2], [22, f, n1, n2, n3, n4, n5, n6, n7]);
   }
   function map8(n1, n2, n3, n4, n5, n6, n7, n8, f){
    return create_node(n1[2], [23, f, n1, n2, n3, n4, n5, n6, n7, n8]);
   }
   function map9(n1, n2, n3, n4, n5, n6, n7, n8, n9, f){
    return create_node(n1[2], [24, f, n1, n2, n3, n4, n5, n6, n7, n8, n9]);
   }
   function map10(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, f){
    return create_node
            (n1[2], [25, f, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10]);
   }
   function map11(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, f){
    return create_node
            (n1[2], [26, f, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11]);
   }
   function map12(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, f){
    return create_node
            (n1[2],
             [27, f, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12]);
   }
   function map13(n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, f){
    return create_node
            (n1[2],
             [28, f, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13]);
   }
   function map14
   (n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, f){
    return create_node
            (n1[2],
             [29,
              f,
              n1,
              n2,
              n3,
              n4,
              n5,
              n6,
              n7,
              n8,
              n9,
              n10,
              n11,
              n12,
              n13,
              n14]);
   }
   function map15
   (n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, f){
    return create_node
            (n1[2],
             [30,
              f,
              n1,
              n2,
              n3,
              n4,
              n5,
              n6,
              n7,
              n8,
              n9,
              n10,
              n11,
              n12,
              n13,
              n14,
              n15]);
   }
   function preserve_cutoff(input, output){
    function _dX_(param, _dZ_){
     return caml_call2(Incremental_Stabilization_num[3], input[7], output[7]);
    }
    var _dY_ = caml_call1(Incremental_Cutoff[3], _dX_);
    return caml_call2(Incremental_Node[24], output, _dY_);
   }
   function depend_on(input, depend_on){
    var output = map2(input, depend_on, function(a, param){return a;});
    preserve_cutoff(input, output);
    return output;
   }
   function necessary_if_alive(input){
    var
     observer = create_observer(0, input),
     output =
       map(input, function(a){caml_call1(Core_Gc[10], observer); return a;});
    preserve_cutoff(input, output);
    return output;
   }
   function bind(lhs, f){
    var
     t = lhs[2],
     lhs_change = create_node(t, 1),
     main = create_node(t, 1),
     bind =
       [0,
        main,
        f,
        lhs,
        lhs_change,
        Incremental_Import[6][5],
        Incremental_Scope[3],
        Incremental_Import[6][5]];
    caml_call2(Incremental_Node[24], lhs_change, Incremental_Cutoff[7]);
    bind[6] = [0, bind];
    caml_call2(Incremental_Node[6], lhs_change, [3, bind]);
    caml_call2(Incremental_Node[6], main, [4, bind]);
    return main;
   }
   function bind2(n1, n2, f){
    function _dW_(param){
     var v2 = param[2], v1 = param[1];
     return caml_call2(f, v1, v2);
    }
    return bind(map2(n1, n2, function(v1, v2){return [0, v1, v2];}), _dW_);
   }
   function bind3(n1, n2, n3, f){
    function _dV_(param){
     var v3 = param[3], v2 = param[2], v1 = param[1];
     return caml_call3(f, v1, v2, v3);
    }
    return bind
            (map3(n1, n2, n3, function(v1, v2, v3){return [0, v1, v2, v3];}),
             _dV_);
   }
   function bind4(n1, n2, n3, n4, f){
    function _dU_(param){
     var v4 = param[4], v3 = param[3], v2 = param[2], v1 = param[1];
     return caml_call4(f, v1, v2, v3, v4);
    }
    return bind
            (map4
              (n1,
               n2,
               n3,
               n4,
               function(v1, v2, v3, v4){return [0, v1, v2, v3, v4];}),
             _dU_);
   }
   function join(lhs){
    var
     t = lhs[2],
     lhs_change = create_node(t, 1),
     main = create_node(t, 1),
     join = [0, main, lhs, lhs_change, Incremental_Import[6][5]];
    caml_call2(Incremental_Node[24], lhs_change, Incremental_Cutoff[7]);
    caml_call2(Incremental_Node[6], lhs_change, [10, join]);
    caml_call2(Incremental_Node[6], main, [11, join]);
    return main;
   }
   function if$0(test, then, else$0){
    var
     t = test[2],
     test_change = create_node(t, 1),
     main = create_node(t, 1),
     if_then_else =
       [0, main, test, test_change, Incremental_Import[6][5], then, else$0];
    caml_call2(Incremental_Node[24], test_change, Incremental_Cutoff[7]);
    caml_call2(Incremental_Node[6], test_change, [8, if_then_else]);
    caml_call2(Incremental_Node[6], main, [9, if_then_else]);
    return main;
   }
   function lazy_from_fun(t, f){
    var scope = t[4];
    function _dT_(param){return within_scope(t, scope, f);}
    return caml_call1(Core_Lazy[38], _dT_);
   }
   var default_hash_table_initial_siz = 4;
   function memoize_fun_by_key(opt, t, hashable, project_key, f){
    if(opt)
     var sth = opt[1], initial_size = sth;
    else
     var initial_size = default_hash_table_initial_siz;
    var
     scope = t[4],
     table = caml_call3(Core_Hashtbl[4], 0, [0, initial_size], hashable);
    function _dS_(a){
     var
      key = caml_call1(project_key, a),
      match = caml_call2(Core_Hashtbl[56], table, key);
     if(match){var b = match[1]; return b;}
     var
      b$0 = within_scope(t, scope, function(param){return caml_call1(f, a);});
     caml_call3(Core_Hashtbl[39], table, key, b$0);
     return b$0;
    }
    return caml_call1(Core[266], _dS_);
   }
   function array_fold(t, children, init, f){
    return caml_call2(Core[90], children.length - 1, 0)
            ? const$0(t, init)
            : create_node(t, [0, [0, init, f, children]]);
   }
   function all(t, ts){
    function _dR_(ac, a){return [0, a, ac];}
    return array_fold(t, caml_call1(Incremental_Import[5][99], ts), 0, _dR_);
   }
   function unordered_array_fold(t, opt, children, init, f, update){
    if(opt)
     var sth = opt[1], full_compute_every_n_changes = sth;
    else
     var full_compute_every_n_changes = Core_Int[45];
    if(caml_call2(Core[90], children.length - 1, 0)) return const$0(t, init);
    if(caml_call2(Core[89], full_compute_every_n_changes, 0))
     return caml_call5
             (Core[247],
              0,
              _b6_,
              cst_unordered_array_fold_got_n,
              full_compute_every_n_changes,
              Core[389]);
    var
     main = create_node(t, 1),
     _dQ_ =
       [15,
        caml_call6
         (Incremental_Unordered_array_fo[4],
          init,
          f,
          update,
          full_compute_every_n_changes,
          children,
          main)];
    caml_call2(Incremental_Node[6], main, _dQ_);
    return main;
   }
   function opt_unordered_array_fold
   (t, full_compute_every_n_changes, ts, init, f, f_inverse){
    function f$0(param, x){
     var num_invalid = param[2], accum = param[1];
     if(! x) return [0, accum, num_invalid + 1 | 0];
     var x$0 = x[1];
     return [0, caml_call2(f, accum, x$0), num_invalid];
    }
    function f_inverse$0(param, x){
     var num_invalid = param[2], accum = param[1];
     if(! x) return [0, accum, num_invalid - 1 | 0];
     var x$0 = x[1];
     return [0, caml_call2(f_inverse, accum, x$0), num_invalid];
    }
    function _dP_(param){
     var num_invalid = param[2], accum = param[1];
     return caml_call2(Core[90], num_invalid, 0) ? [0, accum] : 0;
    }
    return map
            (unordered_array_fold
              (t,
               full_compute_every_n_changes,
               ts,
               [0, init, 0],
               f$0,
               [0, f_inverse$0]),
             _dP_);
   }
   function at_least_k_of(t, nodes, k){
    function bool_to_int(b){return b ? 1 : 0;}
    function _dN_(i){return caml_call2(Core[88], i, k);}
    var
     _dO_ = [0, function(num_true, b){return num_true - bool_to_int(b) | 0;}];
    return map
            (unordered_array_fold
              (t,
               0,
               nodes,
               0,
               function(num_true, b){return num_true + bool_to_int(b) | 0;},
               _dO_),
             _dN_);
   }
   function exists(t, nodes){return at_least_k_of(t, nodes, 1);}
   function for_all(t, nodes){
    return at_least_k_of(t, nodes, nodes.length - 1);
   }
   function sum(t, full_compute_every_n_changes, nodes, zero, add, sub){
    return unordered_array_fold
            (t, full_compute_every_n_changes, nodes, zero, add, [0, sub]);
   }
   function opt_sum(t, full_compute_every_n_changes, nodes, zero, add, sub){
    return opt_unordered_array_fold
            (t, full_compute_every_n_changes, nodes, zero, add, sub);
   }
   function sum_int(t, nodes){
    function _dI_(_dM_, _dL_){return _dM_ - _dL_ | 0;}
    return sum
            (t,
             0,
             nodes,
             0,
             function(_dK_, _dJ_){return _dK_ + _dJ_ | 0;},
             _dI_);
   }
   function sum_float(t, nodes){
    function _dD_(_dH_, _dG_){return _dH_ - _dG_;}
    return sum
            (t,
             [0, nodes.length - 1],
             nodes,
             0.,
             function(_dF_, _dE_){return _dF_ + _dE_;},
             _dD_);
   }
   function set_freeze(node, child, only_freeze_when){
    if(Incremental_Import[1] && ! caml_call1(Incremental_Scope[4], node[12]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b7_], 1);
    var was_necessary = caml_call1(Incremental_Node[15], node);
    caml_call2
     (Incremental_Node[6], node, [7, [0, node, child, only_freeze_when]]);
    return was_necessary
            ? add_parent(child, node, Incremental_Kind[7])
            : became_necessary(node);
   }
   function freeze(child, only_freeze_when){
    var t = child[2], node = create_node_top(t, 1);
    set_freeze(node, child, only_freeze_when);
    return node;
   }
   function at(clock, time){
    var t = caml_call1(Clock[9], clock), _dC_ = now$1(clock);
    if(caml_call2(Incremental_Import[4][16], time, _dC_))
     return const$0(t, 1);
    var
     main = create_node(t, 1),
     at = [0, main, time, Incremental_Alarm[3], clock];
    caml_call2(Incremental_Node[6], main, [1, at]);
    at[3] =
     add_alarm(clock, time, caml_call1(Incremental_Alarm_value[4], [0, at]));
    return main;
   }
   function after(clock, span){
    var _dB_ = now$1(clock);
    return at(clock, caml_call2(Incremental_Import[4][67], _dB_, span));
   }
   function next_interval_alarm_strict(clock, base, interval){
    var
     after = now$1(clock),
     at =
       caml_call5(Incremental_Import[4][81], _b8_, base, after, interval, 0);
    if
     (Incremental_Import[1]
      && ! caml_call2(Incremental_Import[4][18], at, after))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b9_], 1);
    return at;
   }
   function at_intervals(clock, interval){
    var
     t = caml_call1(Clock[9], clock),
     _dz_ = caml_call1(Timing_wheel[10], clock[1]);
    if(caml_call2(Incremental_Import[4][1][19], interval, _dz_))
     caml_call5
      (Core[247],
       0,
       _b__,
       cst_at_intervals_got_too_small,
       interval,
       Incremental_Import[4][1][10]);
    var
     main = create_node(t, 1),
     base = now$1(clock),
     at_intervals = [0, main, base, interval, Incremental_Alarm[3], clock];
    caml_call2(Incremental_Node[6], main, [2, at_intervals]);
    caml_call2(Incremental_Node[24], main, Incremental_Cutoff[7]);
    var _dA_ = caml_call1(Incremental_Alarm_value[4], [1, at_intervals]);
    at_intervals[4] =
     add_alarm(clock, next_interval_alarm_strict(clock, base, interval), _dA_);
    return main;
   }
   function snapshot(clock, value_at, at, before){
    var t = caml_call1(Clock[9], clock), _dx_ = now$1(clock);
    if(caml_call2(Incremental_Import[4][16], at, _dx_)){
     var _dy_ = now$1(clock);
     return caml_call2(Incremental_Import[4][19], at, _dy_)
             ? caml_call5
               (Core_Or_error[44],
                0,
                0,
                cst_cannot_take_snapshot_in_th,
                at,
                Incremental_Import[4][126])
             : [0, freeze(value_at, caml_call1(Core_Fn[1], 1))];
    }
    var
     main = create_node_top(t, 1),
     snapshot = [0, main, at, before, value_at, clock];
    caml_call2(Incremental_Node[6], main, [13, snapshot]);
    add_alarm
     (clock, at, caml_call1(Incremental_Alarm_value[4], [2, snapshot]));
    return [0, main];
   }
   function incremental_step_function(clock, child){
    var
     t = caml_call1(Clock[9], clock),
     main = create_node(t, 1),
     _dt_ = Incremental_Alarm[3],
     _du_ = Core_Sequence[49],
     _dv_ = Incremental_Import[6][5],
     _dw_ = Incremental_Stabilization_num[5],
     step_function_node =
       [0,
        main,
        caml_call1(Incremental_Import[6][6], child),
        _dw_,
        _dv_,
        _du_,
        _dt_,
        0,
        clock];
    step_function_node[7] =
     caml_call1(Incremental_Alarm_value[4], [3, step_function_node]);
    caml_call2(Incremental_Node[6], main, [14, step_function_node]);
    return main;
   }
   function make_stale(node){
    var t = node[2];
    node[3] = Incremental_Stabilization_num[5];
    var
     _dr_ = caml_call1(Incremental_Node[20], node),
     _ds_ = _dr_ ? 1 - caml_call1(Incremental_Node[14], node) : _dr_;
    return _ds_ ? caml_call2(Incremental_Recompute_heap[8], t[5], node) : _ds_;
   }
   function advance_clock(clock, to){
    var t = caml_call1(Clock[9], clock);
    ensure_not_stabilizing(t, cst_advance_clock, 1);
    if(Incremental_Import[1]) invariant$2(t);
    var
     _dn_ = now$1(clock),
     _do_ = caml_call2(Incremental_Import[4][18], to, _dn_);
    if(_do_){
     set_var_while_not_stabilizing(clock[2], to);
     caml_call3(Timing_wheel[20], clock[1], to, clock[3]);
     caml_call2(Timing_wheel[22], clock[1], clock[3]);
     for(;;){
      if(! caml_call1(Incremental_Import[6][8], clock[4])){
       var _dp_ = Incremental_Import[1];
       if(_dp_) return invariant$2(t);
       var _dq_ = _dp_;
       break;
      }
      var alarm_value = caml_call1(Incremental_Import[6][16], clock[4]);
      clock[4] = alarm_value[2];
      alarm_value[2] = Incremental_Import[6][5];
      var match = alarm_value[1];
      switch(match[0]){
        case 0:
         var main = match[1][1];
         if(caml_call1(Incremental_Node[16], main)){
          caml_call2(Incremental_Node[6], main, _b$_);
          make_stale(main);
         }
         break;
        case 1:
         var
          at_intervals = match[1],
          interval = at_intervals[3],
          base = at_intervals[2],
          main$0 = at_intervals[1];
         if(caml_call1(Incremental_Node[16], main$0)){
          at_intervals[4] =
           add_alarm
            (clock,
             next_interval_alarm_strict(clock, base, interval),
             alarm_value);
          make_stale(main$0);
         }
         break;
        case 2:
         var match$0 = match[1], value_at = match$0[4], main$1 = match$0[1];
         if
          (Incremental_Import[1] && ! caml_call1(Incremental_Node[16], main$1))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _ca_], 1);
         set_freeze(main$1, value_at, function(param){return 1;});
         make_stale(main$1);
         break;
        default:
         var main$2 = match[1][1];
         if(caml_call1(Incremental_Node[16], main$2)) make_stale(main$2);
      }
     }
    }
    else
     var _dq_ = _do_;
    return _dq_;
   }
   function create_clock(t, timing_wheel_config, start){
    var
     timing_wheel = caml_call2(Timing_wheel[9], timing_wheel_config, start),
     clock = [],
     handle_fired = function _dm_(_dl_){return _dm_.fun(_dl_);},
     _dk_ = Incremental_Import[6][5];
    caml_update_dummy
     (clock, [0, timing_wheel, create_var(t, 0, start), handle_fired, _dk_]);
    caml_update_dummy
     (handle_fired,
      function(alarm){
       var alarm_value = caml_call2(Timing_wheel[5][5], clock[1], alarm);
       alarm_value[2] = clock[4];
       clock[4] = caml_call1(Incremental_Import[6][6], alarm_value);
       return 0;
      });
    return clock;
   }
   function create$0(Config, max_height_allowed){
    var
     adjust_heights_heap =
       caml_call1(Incremental_Adjust_heights_hea[3], max_height_allowed),
     recompute_heap =
       caml_call1(Incremental_Recompute_heap[3], max_height_allowed),
     _da_ = caml_call1(Thread_safe_queue[3], 0),
     _db_ = caml_call1(Only_in_debug[8], 0),
     _dc_ = caml_call1(Core_Stack[23], 0),
     _dd_ = caml_call1(Core_Stack[23], 0),
     _de_ = caml_call1(Core_Stack[23], 0),
     _df_ = caml_call1(Core_Stack[23], 0),
     _dg_ = caml_call1(Core_Stack[23], 0),
     _dh_ = caml_call1(Thread_safe_queue[3], 0),
     _di_ = Incremental_Import[6][5],
     _dj_ = caml_call1(Core_Stack[23], 0),
     t =
       [0,
        2,
        Config[1],
        Incremental_Stabilization_num[6],
        Incremental_Scope[3],
        recompute_heap,
        adjust_heights_heap,
        _dj_,
        0,
        _di_,
        _dh_,
        _dg_,
        _df_,
        _de_,
        _dd_,
        _dc_,
        _db_,
        _da_,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0];
    return t;
   }
   function weak_memoize_fun_by_key(opt, t, hashable, project_key, f){
    if(opt)
     var sth = opt[1], initial_size = sth;
    else
     var initial_size = default_hash_table_initial_siz;
    var
     scope = t[4],
     table = caml_call3(Weak_hashtbl[2], 0, [0, initial_size], hashable),
     packed = [0, table];
    function _c__(param){
     return caml_call2(Thread_safe_queue[5], t[17], packed);
    }
    caml_call2(Weak_hashtbl[13], table, _c__);
    function _c$_(a){
     var
      key = caml_call1(project_key, a),
      match = caml_call2(Weak_hashtbl[5], table, key);
     if(match){var b = match[1]; return b;}
     var
      b$0 = within_scope(t, scope, function(param){return caml_call1(f, a);});
     caml_call3(Weak_hashtbl[9], table, key, b$0);
     return b$0;
    }
    return caml_call1(Core[266], _c$_);
   }
   function expert_kind_of_node(node){
    var x_099 = node[5];
    if(typeof x_099 === "number"){
     if(0 === x_099) return Incremental_Import[6][5];
    }
    else if(6 === x_099[0]){
     var e = x_099[1];
     return caml_call1(Incremental_Import[6][6], e);
    }
    var _c6_ = 0;
    function _c7_(param){return _cb_;}
    var
     _c8_ = [0, caml_call2(Incremental_Kind[2], _c7_, x_099), _c6_],
     _c9_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_unexpected_kind_for_expert),
         _c8_]];
    return caml_call1(Core[261], _c9_);
   }
   function create$1(state, on_observability_change, f){
    var
     e = caml_call2(Incremental_Expert[5], f, on_observability_change),
     node = create_node(state, [6, e]);
    if(Incremental_Import[1] && caml_call1(Core_Option[62], state[16][1]))
     state[16][2] = [0, node, state[16][2]];
    return node;
   }
   function currently_running_node_exn(state, name){
    var match = state[16][1];
    if(match){var current = match[1]; return current;}
    var
     _c3_ = caml_call2(Core[18], name, cst_during_stabilization),
     _c4_ = caml_call2(Core[18], cst_can_only_call, _c3_),
     _c5_ = caml_call1(Core[558], _c4_);
    return caml_call1(Core[261], _c5_);
   }
   function assert_currently_running_node_(state, node, name){
    var
     current = currently_running_node_exn(state, name),
     _cS_ = 1 - caml_call2(Incremental_Node[30], node, current);
    if(! _cS_) return _cS_;
    var x_101 = current[5], _cT_ = 0, _cU_ = 0;
    function _cV_(param){return _cc_;}
    var
     _cW_ =
       [0,
        [1,
         [0, _cd_, [0, caml_call2(Incremental_Kind[2], _cV_, x_101), _cU_]]],
        _cT_],
     x_100 = node[5],
     _cX_ = 0;
    function _cY_(param){return _ce_;}
    var
     _cZ_ =
       [0,
        [1,
         [0, _cf_, [0, caml_call2(Incremental_Kind[2], _cY_, x_100), _cX_]]],
        _cW_],
     _c0_ = caml_call2(Core[18], name, cst_on_parent_nodes),
     _c1_ = caml_call2(Core[18], cst_can_only_call$0, _c0_),
     _c2_ = [1, [0, caml_call1(Core[558], _c1_), _cZ_]];
    return caml_call1(Core[261], _c2_);
   }
   function assert_currently_running_node_$0(state, node, name){
    var
     current = currently_running_node_exn(state, name),
     _cH_ = 1 - caml_call2(Incremental_Node[31], node, current);
    if(! _cH_) return _cH_;
    var x_103 = current[5], _cI_ = 0, _cJ_ = 0;
    function _cK_(param){return _cg_;}
    var
     _cL_ =
       [0,
        [1,
         [0, _ch_, [0, caml_call2(Incremental_Kind[2], _cK_, x_103), _cJ_]]],
        _cI_],
     x_102 = node[5],
     _cM_ = 0;
    function _cN_(param){return _ci_;}
    var
     _cO_ =
       [0,
        [1,
         [0, _cj_, [0, caml_call2(Incremental_Kind[2], _cN_, x_102), _cM_]]],
        _cL_],
     _cP_ = caml_call2(Core[18], name, cst_on_children_nodes),
     _cQ_ = caml_call2(Core[18], cst_can_only_call$1, _cP_),
     _cR_ = [1, [0, caml_call1(Core[558], _cQ_), _cO_]];
    return caml_call1(Core[261], _cR_);
   }
   function make_stale$0(node){
    var
     state = node[2],
     e_opt = expert_kind_of_node(node),
     _cD_ = caml_call1(Incremental_Import[6][8], e_opt);
    if(_cD_){
     if(Incremental_Import[1])
      assert_currently_running_node_(state, node, cst_make_stale);
     var e = caml_call1(Incremental_Import[6][16], e_opt);
     if(534011858 <= caml_call1(Incremental_Expert[6], e)) return 0;
     var
      _cE_ = caml_call1(Incremental_Node[15], node),
      _cF_ = _cE_ ? 1 - caml_call1(Incremental_Node[14], node) : _cE_;
     if(_cF_)
      return caml_call2(Incremental_Recompute_heap[8], state[5], node);
     var _cG_ = _cF_;
    }
    else
     var _cG_ = _cD_;
    return _cG_;
   }
   function invalidate(node){
    var state = node[2];
    if(Incremental_Import[1])
     assert_currently_running_node_(state, node, cst_invalidate);
    invalidate_node(node);
    return propagate_invalidity$1(state);
   }
   function add_dependency(node, dep){
    var
     state = node[2],
     e_opt = expert_kind_of_node(node),
     _ct_ = caml_call1(Incremental_Import[6][8], e_opt);
    if(_ct_){
     if(Incremental_Import[1]){
      var _cu_ = am_stabilizing(state);
      if(_cu_)
       var
        _cv_ = function(_cC_, _cB_){return _cC_ === _cB_ ? 1 : 0;},
        _cw_ = 1 - caml_call3(Core_List[17], state[16][2], node, _cv_);
      else
       var _cw_ = _cu_;
      if(_cw_)
       assert_currently_running_node_(state, node, cst_add_dependency);
     }
     var
      e = caml_call1(Incremental_Import[6][16], e_opt),
      new_child_index = caml_call2(Incremental_Expert[9], e, dep),
      _cx_ = caml_call1(Incremental_Node[15], node);
     if(_cx_){
      add_parent(dep[1], node, new_child_index);
      if(Incremental_Import[1] && ! caml_call1(Incremental_Node[20], node))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _ck_], 1);
      var _cy_ = 1 - caml_call1(Incremental_Node[14], node);
      if(_cy_)
       return caml_call2(Incremental_Recompute_heap[8], state[5], node);
      var _cz_ = _cy_;
     }
     else
      var _cz_ = _cx_;
     var _cA_ = _cz_;
    }
    else
     var _cA_ = _ct_;
    return _cA_;
   }
   function remove_dependency(node, edge){
    var
     state = node[2],
     e_opt = expert_kind_of_node(node),
     _cm_ = caml_call1(Incremental_Import[6][8], e_opt);
    if(_cm_){
     if(Incremental_Import[1])
      assert_currently_running_node_(state, node, cst_remove_dependency);
     var
      e = caml_call1(Incremental_Import[6][16], e_opt),
      edge_index = caml_call1(Incremental_Import[6][9], edge[3]),
      last_edge = caml_call1(Incremental_Expert[11], e),
      last_edge_index = caml_call1(Incremental_Import[6][9], last_edge[3]);
     if(caml_call2(Core[93], edge_index, last_edge_index)){
      if(caml_call1(Incremental_Node[15], node))
       caml_call5
        (Incremental_Node[12],
         node,
         edge[1],
         edge_index,
         last_edge[1],
         last_edge_index);
      caml_call3(Incremental_Expert[10], e, edge_index, last_edge_index);
      if(Incremental_Import[1]){
       var _cn_ = function(_cs_){return 0;};
       caml_call2(Incremental_Node[4], _cn_, node);
      }
     }
     caml_call1(Incremental_Expert[12], e);
     if(Incremental_Import[1] && ! caml_call1(Incremental_Node[19], node))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _cl_], 1);
     var _co_ = caml_call1(Incremental_Node[15], node);
     if(_co_){
      remove_child(edge[1], node, last_edge_index);
      if(1 - caml_call1(Incremental_Node[14], node))
       caml_call2(Incremental_Recompute_heap[8], state[5], node);
      var _cp_ = 1 - caml_call1(Incremental_Node[16], edge[1]);
      if(_cp_) return caml_call1(Incremental_Expert[8], e);
      var _cq_ = _cp_;
     }
     else
      var _cq_ = _co_;
     var _cr_ = _cq_;
    }
    else
     var _cr_ = _cm_;
    return _cr_;
   }
   var
    Expert =
      [0,
       expert_kind_of_node,
       create$1,
       currently_running_node_exn,
       assert_currently_running_node_,
       assert_currently_running_node_$0,
       make_stale$0,
       invalidate,
       add_dependency,
       remove_dependency];
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_State);
   var
    Incremental_State =
      [0,
       sexp_of_status,
       Run_on_update_handlers,
       Only_in_debug,
       Packed_weak_hashtbl,
       num_var_sets,
       set_num_var_sets,
       num_nodes_recomputed_directly_,
       set_num_nodes_recomputed_direc,
       num_nodes_recomputed_directly_$0,
       set_num_nodes_recomputed_direc$0,
       num_nodes_recomputed,
       set_num_nodes_recomputed,
       num_nodes_invalidated,
       set_num_nodes_invalidated,
       num_nodes_created,
       set_num_nodes_created,
       num_nodes_changed,
       set_num_nodes_changed,
       num_nodes_became_unnecessary,
       set_num_nodes_became_unnecessa,
       num_nodes_became_necessary,
       set_num_nodes_became_necessary,
       keep_node_creation_backtrace,
       set_keep_node_creation_backtra,
       weak_hashtbls,
       only_in_debug,
       set_only_in_debug,
       run_on_update_handlers,
       set_during_stabilization,
       disallowed_observers,
       new_observers,
       finalized_observers,
       all_observers,
       set_all_observers,
       num_active_observers,
       set_num_active_observers,
       adjust_heights_heap,
       recompute_heap,
       current_scope,
       set_current_scope,
       stabilization_num,
       set_stabilization_num,
       bind_lhs_change_should_invalid,
       status,
       set_status,
       Fields$0,
       sexp_of_t$2,
       Clock,
       now$1,
       timing_wheel_length,
       num_stabilizes,
       max_height_allowed,
       max_height_seen,
       iter_observers,
       directly_observed,
       iter_observer_descendants,
       Stats,
       stats,
       am_stabilizing,
       invariant$2,
       ensure_not_stabilizing,
       set_height,
       set_max_height_allowed,
       handle_after_stabilization$1,
       remove_children,
       remove_child,
       check_if_unnecessary,
       became_unnecessary,
       remove_alarm,
       invalidate_node,
       invalidate_nodes_created_on_rh,
       rescope_nodes_created_on_rhs,
       propagate_invalidity$1,
       add_parent_without_adjusting_h,
       became_necessary,
       add_parent,
       run_with_scope,
       within_scope,
       change_child,
       add_alarm,
       recompute,
       copy_child,
       maybe_change_value,
       recompute_first_node_that_is_n,
       unlink_disallowed_observers,
       disallow_future_use,
       disallow_finalized_observers,
       observer_finalizer,
       create_observer,
       add_new_observers,
       observer_value_exn,
       observer_value,
       node_on_update,
       observer_on_update_exn,
       set_var_while_not_stabilizing,
       set_var,
       reclaim_space_in_weak_hashtbls,
       stabilize_start,
       stabilize_end,
       raise_during_stabilization,
       stabilize,
       Step_result,
       do_one_step_of_stabilize,
       create_node_in,
       create_node,
       create_node_top,
       create_var,
       const$0,
       map,
       map2,
       both,
       map3,
       map4,
       map5,
       map6,
       map7,
       map8,
       map9,
       map10,
       map11,
       map12,
       map13,
       map14,
       map15,
       preserve_cutoff,
       depend_on,
       necessary_if_alive,
       bind,
       bind2,
       bind3,
       bind4,
       join,
       if$0,
       lazy_from_fun,
       default_hash_table_initial_siz,
       memoize_fun_by_key,
       array_fold,
       all,
       unordered_array_fold,
       opt_unordered_array_fold,
       at_least_k_of,
       exists,
       for_all,
       sum,
       opt_sum,
       sum_int,
       sum_float,
       set_freeze,
       freeze,
       at,
       after,
       next_interval_alarm_strict,
       at_intervals,
       snapshot,
       incremental_step_function,
       make_stale,
       advance_clock,
       create_clock,
       create$0,
       weak_memoize_fun_by_key,
       Expert];
   runtime.caml_register_global
    (246, Incremental_State, cst_Incremental_State$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Expert1
//# unitInfo: Requires: Incremental__Expert, Incremental__Import, Incremental__Node, Incremental__State, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Expert1$0 = "Incremental__Expert1",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Incremental_State = global_data.Incremental__State,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_Node = global_data.Incremental__Node,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Incremental_Expert = global_data.Incremental__Expert;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Expert1$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/expert1.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "expert1.ml");
   var
    sexp_of_t = Incremental_Expert[3],
    cst_Dependency_value = "Dependency.value",
    cst_incremental = cst_incremental$0,
    cst_Incremental_Expert1 = cst_Incremental_Expert1$0;
   function create(opt, child){
    if(opt)
     var sth = opt[1], on_change = sth;
    else
     var on_change = function(_b_){return 0;};
    return [0, child, on_change, Incremental_Import[6][5]];
   }
   function value(t){
    var state = t[1][2];
    if(Incremental_Import[1])
     caml_call3(Incremental_State[161][5], state, t[1], cst_Dependency_value);
    return caml_call1(Incremental_Node[21], t[1]);
   }
   var
    Dependency = [0, sexp_of_t, create, value],
    sexp_of_t$0 = Incremental_Node[2];
   function create$0(state, opt, f){
    if(opt)
     var sth = opt[1], on_observability_change = sth;
    else
     var on_observability_change = function(param){return 0;};
    return caml_call3
            (Incremental_State[161][2], state, on_observability_change, f);
   }
   var make_stale = Incremental_State[161][6];
   function watch(_a_){return _a_;}
   var
    invalidate = Incremental_State[161][7],
    add_dependency = Incremental_State[161][8],
    remove_dependency = Incremental_State[161][9];
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Expert1);
   var
    Incremental_Expert1 =
      [0,
       Dependency,
       [0,
        sexp_of_t$0,
        create$0,
        watch,
        make_stale,
        invalidate,
        add_dependency,
        remove_dependency]];
   runtime.caml_register_global
    (16, Incremental_Expert1, cst_Incremental_Expert1$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Reduce_balanced
//# unitInfo: Requires: Balanced_reducer, Core, Incremental__Expert1, Incremental__Import, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Reduce_balance$0 = "Incremental__Reduce_balanced",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Balanced_reducer = global_data.Balanced_reducer,
    Incremental_Import = global_data.Incremental__Import,
    Core = global_data.Core,
    Incremental_Expert1 = global_data.Incremental__Expert1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Reduce_balance$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/reduce_balanced.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "reduce_balanced.ml");
   var
    cst_incremental = cst_incremental$0,
    cst_Incremental_Reduce_balance = cst_Incremental_Reduce_balance$0;
   function create(state, children, f, reduce){
    var len = children.length - 1;
    if(caml_call2(Core[90], len, 0)) return 0;
    var reducer = caml_call4(Balanced_reducer[3], 0, 0, len, reduce);
    if(Incremental_Import[1]){
     var _a_ = caml_call1(Core[242], 0);
     caml_call2(Balanced_reducer[2], _a_, reducer);
    }
    function _b_(param){
     var a = caml_call1(Balanced_reducer[6], reducer);
     if(Incremental_Import[1]){
      var _l_ = caml_call1(Core[242], 0);
      caml_call2(Balanced_reducer[2], _l_, reducer);
     }
     return a;
    }
    var
     node = caml_call3(Incremental_Expert1[2][2], state, 0, _b_),
     _d_ = len - 1 | 0,
     _c_ = 0;
    if(_d_ >= 0){
     var i = _c_;
     for(;;){
      var
       _e_ = runtime.caml_check_bound(children, i)[1 + i],
       _f_ =
         [0,
          function(i){
            return function(a){
             var _i_ = caml_call1(f, a);
             caml_call3(Balanced_reducer[4], reducer, i, _i_);
             var _j_ = Incremental_Import[1];
             if(! _j_) return _j_;
             var _k_ = caml_call1(Core[242], 0);
             return caml_call2(Balanced_reducer[2], _k_, reducer);};
           }
           (i)],
       _g_ = caml_call2(Incremental_Expert1[1][2], _f_, _e_);
      caml_call2(Incremental_Expert1[2][6], node, _g_);
      var _h_ = i + 1 | 0;
      if(_d_ === i) break;
      var i = _h_;
     }
    }
    return [0, caml_call1(Incremental_Expert1[2][3], node)];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Reduce_balance);
   var Incremental_Reduce_balanced = [0, create];
   runtime.caml_register_global
    (15, Incremental_Reduce_balanced, cst_Incremental_Reduce_balance$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__For_analyzer
//# unitInfo: Requires: Core, Core__Int, Core__List, Core__Sexp, Core__String, Core__Time_ns, Incremental__Bind, Incremental__Cutoff, Incremental__Dot_user_info, Incremental__Node, Incremental__Node_id, Incremental__Stabilization_num, Incremental__State, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv_error, Sexplib0__Sexp_conv_record
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Array_fold = "Array_fold",
    cst_At = "At",
    cst_At_intervals = "At_intervals",
    cst_Bind_lhs_change = "Bind_lhs_change",
    cst_Bind_main = "Bind_main",
    cst_Const = "Const",
    cst_Expert = "Expert",
    cst_Freeze = "Freeze",
    cst_If_test_change = "If_test_change",
    cst_If_then_else = "If_then_else",
    cst_Incremental_For_analyzer$0 = "Incremental__For_analyzer",
    cst_Invalid = "Invalid",
    cst_Join_lhs_change = "Join_lhs_change",
    cst_Join_main = "Join_main",
    cst_Map = "Map",
    cst_Map10 = "Map10",
    cst_Map11 = "Map11",
    cst_Map12 = "Map12",
    cst_Map13 = "Map13",
    cst_Map14 = "Map14",
    cst_Map15 = "Map15",
    cst_Map2 = "Map2",
    cst_Map3 = "Map3",
    cst_Map4 = "Map4",
    cst_Map5 = "Map5",
    cst_Map6 = "Map6",
    cst_Map7 = "Map7",
    cst_Map8 = "Map8",
    cst_Map9 = "Map9",
    cst_Snapshot = "Snapshot",
    cst_Step_function = "Step_function",
    cst_Uninitialized = "Uninitialized",
    cst_Unordered_array_fold = "Unordered_array_fold",
    cst_Var = "Var",
    cst_array_fold = "array_fold",
    cst_at$1 = "at",
    cst_at_intervals = "at_intervals",
    cst_base$0 = "base",
    cst_bind_lhs_change = "bind_lhs_change",
    cst_bind_main = "bind_main",
    cst_const = "const",
    cst_expert = "expert",
    cst_freeze = "freeze",
    cst_if_test_change = "if_test_change",
    cst_if_then_else = "if_then_else",
    cst_incremental$0 = "incremental",
    cst_interval$0 = "interval",
    cst_invalid = "invalid",
    cst_join_lhs_change = "join_lhs_change",
    cst_join_main = "join_main",
    cst_map = "map",
    cst_map10 = "map10",
    cst_map11 = "map11",
    cst_map12 = "map12",
    cst_map13 = "map13",
    cst_map14 = "map14",
    cst_map15 = "map15",
    cst_map2 = "map2",
    cst_map3 = "map3",
    cst_map4 = "map4",
    cst_map5 = "map5",
    cst_map6 = "map6",
    cst_map7 = "map7",
    cst_map8 = "map8",
    cst_map9 = "map9",
    cst_snapshot = "snapshot",
    cst_step_function = "step_function",
    cst_uninitialized = "uninitialized",
    cst_unordered_array_fold = "unordered_array_fold",
    cst_var = "var",
    caml_string_compare = runtime.caml_string_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "src/for_analyzer.ml.Kind.t",
    Core_List = global_data.Core__List,
    Incremental_Node = global_data.Incremental__Node,
    Incremental_Bind = global_data.Incremental__Bind,
    Incremental_Cutoff = global_data.Incremental__Cutoff,
    Incremental_Node_id = global_data.Incremental__Node_id,
    Core_Int = global_data.Core__Int,
    Core = global_data.Core,
    Core_Sexp = global_data.Core__Sexp,
    Core_String = global_data.Core__String,
    Incremental_Dot_user_info = global_data.Incremental__Dot_user_info,
    Core_Time_ns = global_data.Core__Time_ns,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Sexplib0_Sexp_conv_record = global_data.Sexplib0__Sexp_conv_record,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Incremental_Stabilization_num = global_data.Incremental__Stabilization_num,
    Incremental_State = global_data.Incremental__State;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_For_analyzer$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/for_analyzer.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "for_analyzer.ml");
   var
    _L_ = [0, [11, "height=", [4, 0, 0, 0, 0]], "height=%d"],
    _a_ = [0, cst_Array_fold],
    _b_ = [0, cst_Bind_lhs_change],
    _c_ = [0, cst_Bind_main],
    _d_ = [0, cst_Const],
    _e_ = [0, cst_Expert],
    _f_ = [0, cst_Freeze],
    _g_ = [0, cst_If_test_change],
    _h_ = [0, cst_If_then_else],
    _i_ = [0, cst_Invalid],
    _j_ = [0, cst_Join_lhs_change],
    _k_ = [0, cst_Join_main],
    _l_ = [0, cst_Map],
    _m_ = [0, cst_Step_function],
    _n_ = [0, cst_Uninitialized],
    _o_ = [0, cst_Unordered_array_fold],
    _p_ = [0, cst_Var],
    _q_ = [0, cst_Map2],
    _r_ = [0, cst_Map3],
    _s_ = [0, cst_Map4],
    _t_ = [0, cst_Map5],
    _u_ = [0, cst_Map6],
    _v_ = [0, cst_Map7],
    _w_ = [0, cst_Map8],
    _x_ = [0, cst_Map9],
    _y_ = [0, cst_Map10],
    _z_ = [0, cst_Map11],
    _A_ = [0, cst_Map12],
    _B_ = [0, cst_Map13],
    _C_ = [0, cst_Map14],
    _D_ = [0, cst_Map15],
    _E_ = [0, cst_at$1],
    _F_ = [0, cst_At],
    _G_ = [0, cst_interval$0],
    _H_ = [0, cst_base$0],
    _I_ = [0, cst_At_intervals],
    _J_ = [0, cst_at$1],
    _K_ = [0, cst_Snapshot],
    cst_at$0 = cst_at$1,
    cst_interval = cst_interval$0,
    cst_base = cst_base$0,
    cst_at = cst_at$1,
    cst_incremental = cst_incremental$0,
    cst_Incremental_For_analyzer = cst_Incremental_For_analyzer$0;
   function t_of_sexp(sexp_005){
    a:
    {
     if(0 === sexp_005[0]){
      var
       _ab_ = sexp_005[1],
       _ac_ = caml_string_compare(_ab_, cst_array_fold);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          f:
          {
           g:
           {
            h:
            {
             i:
             {
              j:
              {
               k:
               {
                l:
                {
                 m:
                 {
                  n:
                  {
                   o:
                   {
                    p:
                    {
                     q:
                     {
                      r:
                      {
                       s:
                       {
                        t:
                        {
                         u:
                         {
                          v:
                          {
                           w:
                           {
                            x:
                            {
                             y:
                             {
                              z:
                              {
                               A:
                               {
                                B:
                                {
                                 C:
                                 {
                                  D:
                                  {
                                   E:
                                   {
                                    F:
                                    {
                                     G:
                                     {
                                      if(0 <= _ac_){
                                       if(0 >= _ac_) break i;
                                       var _ad_ = caml_string_compare(_ab_, cst_map13);
                                       if(0 <= _ad_){
                                        if(0 >= _ad_) break y;
                                        var _ae_ = caml_string_compare(_ab_, cst_map7);
                                        if(0 <= _ae_){
                                         if(0 >= _ae_) break G;
                                         if(! caml_string_notequal(_ab_, cst_map8)) break F;
                                         if(! caml_string_notequal(_ab_, cst_map9)) break E;
                                         if(! caml_string_notequal(_ab_, cst_snapshot)) break D;
                                         if(! caml_string_notequal(_ab_, cst_step_function)) break C;
                                         if(! caml_string_notequal(_ab_, cst_uninitialized)) break B;
                                         if(! caml_string_notequal(_ab_, cst_unordered_array_fold))
                                          break A;
                                         if(caml_string_notequal(_ab_, cst_var)) break a;
                                         break z;
                                        }
                                        if(! caml_string_notequal(_ab_, cst_map14)) break x;
                                        if(! caml_string_notequal(_ab_, cst_map15)) break w;
                                        if(! caml_string_notequal(_ab_, cst_map2)) break v;
                                        if(! caml_string_notequal(_ab_, cst_map3)) break u;
                                        if(! caml_string_notequal(_ab_, cst_map4)) break t;
                                        if(! caml_string_notequal(_ab_, cst_map5)) break s;
                                        if(caml_string_notequal(_ab_, cst_map6)) break a;
                                        break r;
                                       }
                                       var _af_ = caml_string_compare(_ab_, cst_if_then_else);
                                       if(0 > _af_){
                                        if(! caml_string_notequal(_ab_, cst_at$1)) break h;
                                        if(! caml_string_notequal(_ab_, cst_at_intervals)) break g;
                                        if(! caml_string_notequal(_ab_, cst_bind_lhs_change))
                                         break f;
                                        if(! caml_string_notequal(_ab_, cst_bind_main)) break e;
                                        if(! caml_string_notequal(_ab_, cst_const)) break d;
                                        if(! caml_string_notequal(_ab_, cst_expert)) break c;
                                        if(! caml_string_notequal(_ab_, cst_freeze)) break b;
                                        if(caml_string_notequal(_ab_, cst_if_test_change)) break a;
                                        break q;
                                       }
                                       if(0 >= _af_) break p;
                                       if(! caml_string_notequal(_ab_, cst_invalid)) break o;
                                       if(! caml_string_notequal(_ab_, cst_join_lhs_change))
                                        break n;
                                       if(! caml_string_notequal(_ab_, cst_join_main)) break m;
                                       if(! caml_string_notequal(_ab_, cst_map)) break l;
                                       if(! caml_string_notequal(_ab_, cst_map10)) break k;
                                       if(! caml_string_notequal(_ab_, cst_map11)) break j;
                                       if(caml_string_notequal(_ab_, cst_map12)) break a;
                                      }
                                      else{
                                       var _ag_ = caml_string_compare(_ab_, cst_Map12);
                                       if(0 > _ag_){
                                        var _ai_ = caml_string_compare(_ab_, cst_If_test_change);
                                        if(0 <= _ai_){
                                         if(0 >= _ai_) break q;
                                         if(! caml_string_notequal(_ab_, cst_If_then_else)) break p;
                                         if(! caml_string_notequal(_ab_, cst_Invalid)) break o;
                                         if(! caml_string_notequal(_ab_, cst_Join_lhs_change))
                                          break n;
                                         if(! caml_string_notequal(_ab_, cst_Join_main)) break m;
                                         if(! caml_string_notequal(_ab_, cst_Map)) break l;
                                         if(! caml_string_notequal(_ab_, cst_Map10)) break k;
                                         if(caml_string_notequal(_ab_, cst_Map11)) break a;
                                         break j;
                                        }
                                        if(! caml_string_notequal(_ab_, cst_Array_fold)) break i;
                                        if(! caml_string_notequal(_ab_, cst_At)) break h;
                                        if(! caml_string_notequal(_ab_, cst_At_intervals)) break g;
                                        if(! caml_string_notequal(_ab_, cst_Bind_lhs_change))
                                         break f;
                                        if(! caml_string_notequal(_ab_, cst_Bind_main)) break e;
                                        if(! caml_string_notequal(_ab_, cst_Const)) break d;
                                        if(! caml_string_notequal(_ab_, cst_Expert)) break c;
                                        if(caml_string_notequal(_ab_, cst_Freeze)) break a;
                                        break b;
                                       }
                                       if(0 < _ag_){
                                        var _ah_ = caml_string_compare(_ab_, cst_Map7);
                                        if(0 <= _ah_){
                                         if(0 >= _ah_) break G;
                                         if(! caml_string_notequal(_ab_, cst_Map8)) break F;
                                         if(! caml_string_notequal(_ab_, cst_Map9)) break E;
                                         if(! caml_string_notequal(_ab_, cst_Snapshot)) break D;
                                         if(! caml_string_notequal(_ab_, cst_Step_function)) break C;
                                         if(! caml_string_notequal(_ab_, cst_Uninitialized)) break B;
                                         if(! caml_string_notequal(_ab_, cst_Unordered_array_fold))
                                          break A;
                                         if(caml_string_notequal(_ab_, cst_Var)) break a;
                                         break z;
                                        }
                                        if(! caml_string_notequal(_ab_, cst_Map13)) break y;
                                        if(! caml_string_notequal(_ab_, cst_Map14)) break x;
                                        if(! caml_string_notequal(_ab_, cst_Map15)) break w;
                                        if(! caml_string_notequal(_ab_, cst_Map2)) break v;
                                        if(! caml_string_notequal(_ab_, cst_Map3)) break u;
                                        if(! caml_string_notequal(_ab_, cst_Map4)) break t;
                                        if(! caml_string_notequal(_ab_, cst_Map5)) break s;
                                        if(caml_string_notequal(_ab_, cst_Map6)) break a;
                                        break r;
                                       }
                                      }
                                      return 26;
                                     }
                                     return 21;
                                    }
                                    return 22;
                                   }
                                   return 23;
                                  }
                                  return caml_call2
                                          (Sexplib0_Sexp_conv_error[9], error_source_003, sexp_005);
                                 }
                                 return 12;
                                }
                                return 13;
                               }
                               return 14;
                              }
                              return 15;
                             }
                             return 27;
                            }
                            return 28;
                           }
                           return 29;
                          }
                          return 16;
                         }
                         return 17;
                        }
                        return 18;
                       }
                       return 19;
                      }
                      return 20;
                     }
                     return 6;
                    }
                    return 7;
                   }
                   return 8;
                  }
                  return 9;
                 }
                 return 10;
                }
                return 11;
               }
               return 24;
              }
              return 25;
             }
             return 0;
            }
            return caml_call2
                    (Sexplib0_Sexp_conv_error[9], error_source_003, sexp_005);
           }
           return caml_call2
                   (Sexplib0_Sexp_conv_error[9], error_source_003, sexp_005);
          }
          return 1;
         }
         return 2;
        }
        return 3;
       }
       return 4;
      }
      return 5;
     }
     var _aj_ = sexp_005[1];
     if(! _aj_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_003, sexp_005);
     var _ak_ = _aj_[1];
     if(0 !== _ak_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_003, sexp_005);
     var _al_ = _ak_[1], _am_ = caml_string_compare(_al_, cst_array_fold);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           h:
           {
            i:
            {
             j:
             {
              k:
              {
               l:
               {
                m:
                {
                 n:
                 {
                  o:
                  {
                   p:
                   {
                    q:
                    {
                     r:
                     {
                      s:
                      {
                       t:
                       {
                        u:
                        {
                         v:
                         {
                          w:
                          {
                           x:
                           {
                            y:
                            {
                             z:
                             {
                              A:
                              {
                               B:
                               {
                                C:
                                {
                                 D:
                                 {
                                  E:
                                  {
                                   F:
                                   {
                                    G:
                                    {
                                     if(0 <= _am_){
                                      if(0 >= _am_) break i;
                                      var _an_ = caml_string_compare(_al_, cst_map13);
                                      if(0 <= _an_){
                                       if(0 >= _an_) break y;
                                       var _ao_ = caml_string_compare(_al_, cst_map7);
                                       if(0 <= _ao_){
                                        if(0 >= _ao_) break G;
                                        if(! caml_string_notequal(_al_, cst_map8)) break F;
                                        if(! caml_string_notequal(_al_, cst_map9)) break E;
                                        if(! caml_string_notequal(_al_, cst_snapshot)) break D;
                                        if(! caml_string_notequal(_al_, cst_step_function)) break C;
                                        if(! caml_string_notequal(_al_, cst_uninitialized)) break B;
                                        if(! caml_string_notequal(_al_, cst_unordered_array_fold))
                                         break A;
                                        if(caml_string_notequal(_al_, cst_var)) break a;
                                        break z;
                                       }
                                       if(! caml_string_notequal(_al_, cst_map14)) break x;
                                       if(! caml_string_notequal(_al_, cst_map15)) break w;
                                       if(! caml_string_notequal(_al_, cst_map2)) break v;
                                       if(! caml_string_notequal(_al_, cst_map3)) break u;
                                       if(! caml_string_notequal(_al_, cst_map4)) break t;
                                       if(! caml_string_notequal(_al_, cst_map5)) break s;
                                       if(caml_string_notequal(_al_, cst_map6)) break a;
                                       break r;
                                      }
                                      var _as_ = caml_string_compare(_al_, cst_if_then_else);
                                      if(0 > _as_){
                                       if(! caml_string_notequal(_al_, cst_at$1)) break h;
                                       if(! caml_string_notequal(_al_, cst_at_intervals)) break g;
                                       if(! caml_string_notequal(_al_, cst_bind_lhs_change))
                                        break f;
                                       if(! caml_string_notequal(_al_, cst_bind_main)) break e;
                                       if(! caml_string_notequal(_al_, cst_const)) break d;
                                       if(! caml_string_notequal(_al_, cst_expert)) break c;
                                       if(! caml_string_notequal(_al_, cst_freeze)) break b;
                                       if(caml_string_notequal(_al_, cst_if_test_change)) break a;
                                       break q;
                                      }
                                      if(0 >= _as_) break p;
                                      if(! caml_string_notequal(_al_, cst_invalid)) break o;
                                      if(! caml_string_notequal(_al_, cst_join_lhs_change))
                                       break n;
                                      if(! caml_string_notequal(_al_, cst_join_main)) break m;
                                      if(! caml_string_notequal(_al_, cst_map)) break l;
                                      if(! caml_string_notequal(_al_, cst_map10)) break k;
                                      if(! caml_string_notequal(_al_, cst_map11)) break j;
                                      if(caml_string_notequal(_al_, cst_map12)) break a;
                                     }
                                     else{
                                      var _az_ = caml_string_compare(_al_, cst_Map12);
                                      if(0 > _az_){
                                       var _aB_ = caml_string_compare(_al_, cst_If_test_change);
                                       if(0 <= _aB_){
                                        if(0 >= _aB_) break q;
                                        if(! caml_string_notequal(_al_, cst_If_then_else)) break p;
                                        if(! caml_string_notequal(_al_, cst_Invalid)) break o;
                                        if(! caml_string_notequal(_al_, cst_Join_lhs_change))
                                         break n;
                                        if(! caml_string_notequal(_al_, cst_Join_main)) break m;
                                        if(! caml_string_notequal(_al_, cst_Map)) break l;
                                        if(! caml_string_notequal(_al_, cst_Map10)) break k;
                                        if(caml_string_notequal(_al_, cst_Map11)) break a;
                                        break j;
                                       }
                                       if(! caml_string_notequal(_al_, cst_Array_fold)) break i;
                                       if(! caml_string_notequal(_al_, cst_At)) break h;
                                       if(! caml_string_notequal(_al_, cst_At_intervals)) break g;
                                       if(! caml_string_notequal(_al_, cst_Bind_lhs_change))
                                        break f;
                                       if(! caml_string_notequal(_al_, cst_Bind_main)) break e;
                                       if(! caml_string_notequal(_al_, cst_Const)) break d;
                                       if(! caml_string_notequal(_al_, cst_Expert)) break c;
                                       if(caml_string_notequal(_al_, cst_Freeze)) break a;
                                       break b;
                                      }
                                      if(0 < _az_){
                                       var _aA_ = caml_string_compare(_al_, cst_Map7);
                                       if(0 <= _aA_){
                                        if(0 >= _aA_) break G;
                                        if(! caml_string_notequal(_al_, cst_Map8)) break F;
                                        if(! caml_string_notequal(_al_, cst_Map9)) break E;
                                        if(! caml_string_notequal(_al_, cst_Snapshot)) break D;
                                        if(! caml_string_notequal(_al_, cst_Step_function)) break C;
                                        if(! caml_string_notequal(_al_, cst_Uninitialized)) break B;
                                        if(! caml_string_notequal(_al_, cst_Unordered_array_fold))
                                         break A;
                                        if(caml_string_notequal(_al_, cst_Var)) break a;
                                        break z;
                                       }
                                       if(! caml_string_notequal(_al_, cst_Map13)) break y;
                                       if(! caml_string_notequal(_al_, cst_Map14)) break x;
                                       if(! caml_string_notequal(_al_, cst_Map15)) break w;
                                       if(! caml_string_notequal(_al_, cst_Map2)) break v;
                                       if(! caml_string_notequal(_al_, cst_Map3)) break u;
                                       if(! caml_string_notequal(_al_, cst_Map4)) break t;
                                       if(! caml_string_notequal(_al_, cst_Map5)) break s;
                                       if(caml_string_notequal(_al_, cst_Map6)) break a;
                                       break r;
                                      }
                                     }
                                     return caml_call2
                                             (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                                    }
                                    return caml_call2
                                            (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                                   }
                                   return caml_call2
                                           (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                                  }
                                  return caml_call2
                                          (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                                 }
                                 var
                                  sexps_010 = _aj_[2],
                                  _ap_ = function(param){var at = param[1]; return [2, at];},
                                  _aq_ = 0,
                                  _ar_ =
                                    function(param){
                                     return caml_string_notequal(param, cst_at$1) ? -1 : 0;
                                    };
                                 return caml_call7
                                         (Sexplib0_Sexp_conv_record[4],
                                          error_source_003,
                                          sexp_005,
                                          [0, cst_at, 1, Core_Time_ns[25][11], 0],
                                          _ar_,
                                          _aq_,
                                          _ap_,
                                          sexps_010);
                                }
                                return caml_call2
                                        (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                               }
                               return caml_call2
                                       (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                              }
                              return caml_call2
                                      (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                             }
                             return caml_call2
                                     (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                            }
                            return caml_call2
                                    (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                           }
                           return caml_call2
                                   (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                          }
                          return caml_call2
                                  (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                         }
                         return caml_call2
                                 (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                        }
                        return caml_call2
                                (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                       }
                       return caml_call2
                               (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                      }
                      return caml_call2
                              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                     }
                     return caml_call2
                             (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                    }
                    return caml_call2
                            (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                   }
                   return caml_call2
                           (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                  }
                  return caml_call2
                          (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                 }
                 return caml_call2
                         (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
                }
                return caml_call2
                        (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
               }
               return caml_call2
                       (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
              }
              return caml_call2
                      (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
             }
             return caml_call2
                     (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
            }
            return caml_call2
                    (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
           }
           var
            sexps_006 = _aj_[2],
            _aw_ = function(param){var at = param[1]; return [0, at];},
            _ax_ = 0,
            _ay_ =
              function(param){
               return caml_string_notequal(param, cst_at$1) ? -1 : 0;
              };
           return caml_call7
                   (Sexplib0_Sexp_conv_record[4],
                    error_source_003,
                    sexp_005,
                    [0, cst_at$0, 1, Core_Time_ns[25][11], 0],
                    _ay_,
                    _ax_,
                    _aw_,
                    sexps_006);
          }
          var
           sexps_008 = _aj_[2],
           _at_ =
             function(param){
              var interval = param[2][1], base = param[1];
              return [1, base, interval];
             },
           _au_ = 0,
           _av_ =
             function(param){
              return caml_string_notequal(param, cst_base$0)
                      ? caml_string_notequal(param, cst_interval$0) ? -1 : 1
                      : 0;
             };
          return caml_call7
                  (Sexplib0_Sexp_conv_record[4],
                   error_source_003,
                   sexp_005,
                   [0,
                    cst_base,
                    1,
                    Core_Time_ns[25][11],
                    [0, cst_interval, 1, Core_Time_ns[1][9], 0]],
                   _av_,
                   _au_,
                   _at_,
                   sexps_008);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_005);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_003, sexp_005);
   }
   function sexp_of_t(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return _a_;
       case 1:
        return _b_;
       case 2:
        return _c_;
       case 3:
        return _d_;
       case 4:
        return _e_;
       case 5:
        return _f_;
       case 6:
        return _g_;
       case 7:
        return _h_;
       case 8:
        return _i_;
       case 9:
        return _j_;
       case 10:
        return _k_;
       case 11:
        return _l_;
       case 12:
        return _m_;
       case 13:
        return _n_;
       case 14:
        return _o_;
       case 15:
        return _p_;
       case 16:
        return _q_;
       case 17:
        return _r_;
       case 18:
        return _s_;
       case 19:
        return _t_;
       case 20:
        return _u_;
       case 21:
        return _v_;
       case 22:
        return _w_;
       case 23:
        return _x_;
       case 24:
        return _y_;
       case 25:
        return _z_;
       case 26:
        return _A_;
       case 27:
        return _B_;
       case 28:
        return _C_;
       default: return _D_;
     }
    switch(param[0]){
      case 0:
       var
        at_012 = param[1],
        arg_013 = caml_call1(Core_Time_ns[25][12], at_012),
        bnds_011 = [0, [1, [0, _E_, [0, arg_013, 0]]], 0];
       return [1, [0, _F_, bnds_011]];
      case 1:
       var
        interval_017 = param[2],
        base_015 = param[1],
        arg_018 = caml_call1(Core_Time_ns[1][10], interval_017),
        bnds_014 = [0, [1, [0, _G_, [0, arg_018, 0]]], 0],
        arg_016 = caml_call1(Core_Time_ns[25][12], base_015),
        bnds_014$0 = [0, [1, [0, _H_, [0, arg_016, 0]]], bnds_014];
       return [1, [0, _I_, bnds_014$0]];
      default:
       var
        at_020 = param[1],
        arg_021 = caml_call1(Core_Time_ns[25][12], at_020),
        bnds_019 = [0, [1, [0, _J_, [0, arg_021, 0]]], 0];
       return [1, [0, _K_, bnds_019]];
    }
   }
   function to_string(t){
    var _aa_ = sexp_of_t(t);
    return caml_call1(Core_Sexp[86], _aa_);
   }
   var
    Kind = [0, t_of_sexp, sexp_of_t, to_string],
    sexp_of_dot = Incremental_Dot_user_info[1],
    dot_of_sexp = Incremental_Dot_user_info[2],
    t_of_sexp$0 = Incremental_Dot_user_info[3],
    sexp_of_t$0 = Incremental_Dot_user_info[4],
    dot = Incremental_Dot_user_info[6],
    to_dot = Incremental_Dot_user_info[7],
    append = Incremental_Dot_user_info[8],
    to_string$0 = Incremental_Dot_user_info[9];
   function default$0(name, kind, height){
    var
     ___ = [0, caml_call2(Core[265], _L_, height), 0],
     _$_ = caml_call1(Kind[2], kind),
     label = [0, name, [0, caml_call1(Core_Sexp[86], _$_), ___]];
    return caml_call2
            (Incremental_Dot_user_info[6], label, Core_String[159][5]);
   }
   var
    is_none = Incremental_Stabilization_num[7],
    is_some = Incremental_Stabilization_num[8],
    to_int = Incremental_Stabilization_num[10],
    include = Incremental_Stabilization_num[11],
    t_of_sexp$1 = include[1],
    sexp_of_t$1 = include[2],
    symbol = include[3],
    symbol$0 = include[4],
    symbol$1 = include[5],
    symbol$2 = include[6],
    symbol$3 = include[7],
    symbol$4 = include[8],
    equal = include[9],
    compare = include[10],
    min = include[11],
    max = include[12],
    ascending = include[13],
    descending = include[14],
    between = include[15],
    clamp_exn = include[16],
    clamp = include[17],
    comparator = include[18],
    validate_lbound = include[19],
    validate_ubound = include[20],
    validate_bound = include[21],
    Replace_polymorphic_compare = include[22],
    Map = include[23],
    Set = include[24],
    to_string$1 = include[25];
   function node_id(param){
    var _Z_ = caml_call1(Incremental_Node_id[11], param[1]);
    return caml_call1(Core_Int[78], _Z_);
   }
   var directly_observed = Incremental_State[55];
   function traverse(packed_list, add_node){
    function map_of_iter(iterator, f){
     var out = [0, 0];
     caml_call1
      (iterator,
       function(x){
        var _Y_ = out[1];
        out[1] = [0, caml_call1(f, x), _Y_];
        return 0;
       });
     return caml_call1(Core_List[59], out[1]);
    }
    function _V_(packed_node){
     var
      children =
        map_of_iter
         (function(f){
           function _X_(param, node){return caml_call1(f, node);}
           return caml_call1
                   (caml_call1(Incremental_Node[8], packed_node), _X_);
          },
          node_id),
      bind_children =
        map_of_iter
         (function(f){
           var match = packed_node[5];
           if(typeof match !== "number" && 3 === match[0]){
            var bind = match[1];
            return caml_call2(Incremental_Bind[4], bind, f);
           }
           return 0;
          },
          node_id),
      id = node_id(packed_node),
      _W_ = packed_node[5];
     if(typeof _W_ === "number")
      var kind = 0 === _W_ ? 8 : 13;
     else
      switch(_W_[0]){
        case 0:
         var kind = 0; break;
        case 1:
         var at = _W_[1][2], kind = [0, at]; break;
        case 2:
         var
          match = _W_[1],
          interval = match[3],
          base = match[2],
          kind = [1, base, interval];
         break;
        case 3:
         var kind = 1; break;
        case 4:
         var kind = 2; break;
        case 5:
         var kind = 3; break;
        case 6:
         var kind = 4; break;
        case 7:
         var kind = 5; break;
        case 8:
         var kind = 6; break;
        case 9:
         var kind = 7; break;
        case 10:
         var kind = 9; break;
        case 11:
         var kind = 10; break;
        case 12:
         var kind = 11; break;
        case 13:
         var at$0 = _W_[1][2], kind = [2, at$0]; break;
        case 14:
         var kind = 12; break;
        case 15:
         var kind = 14; break;
        case 16:
         var kind = 15; break;
        case 17:
         var kind = 16; break;
        case 18:
         var kind = 17; break;
        case 19:
         var kind = 18; break;
        case 20:
         var kind = 19; break;
        case 21:
         var kind = 20; break;
        case 22:
         var kind = 21; break;
        case 23:
         var kind = 22; break;
        case 24:
         var kind = 23; break;
        case 25:
         var kind = 24; break;
        case 26:
         var kind = 25; break;
        case 27:
         var kind = 26; break;
        case 28:
         var kind = 27; break;
        case 29:
         var kind = 28; break;
        default: var kind = 29;
      }
     var
      cutoff = caml_call1(Incremental_Cutoff[12][4], packed_node[6]),
      user_info = packed_node[27],
      recomputed_at = packed_node[3],
      changed_at = packed_node[7],
      height = packed_node[14];
     return caml_call9
             (add_node,
              id,
              kind,
              cutoff,
              children,
              bind_children,
              user_info,
              recomputed_at,
              changed_at,
              height);
    }
    return caml_call2(Incremental_Node[1][4], packed_list, _V_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_For_analyzer);
   var
    _M_ = Core_Int[99],
    _N_ = _M_[2],
    _O_ = _M_[1],
    _P_ = Core_Int[98],
    _Q_ = _P_[2],
    _R_ = _P_[1],
    _S_ = Core_Int[104],
    _T_ = Core_Int[103],
    _U_ = Incremental_Cutoff[12],
    Incremental_For_analyzer =
      [0,
       [0, _U_[1], _U_[2], _U_[3], _U_[5]],
       Kind,
       [0,
        t_of_sexp$0,
        sexp_of_t$0,
        sexp_of_dot,
        dot_of_sexp,
        dot,
        to_dot,
        append,
        to_string$0,
        default$0],
       [0,
        t_of_sexp$1,
        sexp_of_t$1,
        symbol,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        equal,
        compare,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        validate_lbound,
        validate_ubound,
        validate_bound,
        Replace_polymorphic_compare,
        Map,
        Set,
        to_string$1,
        to_int,
        is_some,
        is_none],
       [0,
        Core_Int[76],
        Core_Int[77],
        Core_Int[100],
        Core_Int[101],
        Core_Int[102],
        [0,
         _T_[1],
         _T_[2],
         _T_[3],
         _T_[4],
         _T_[5],
         _T_[6],
         _T_[7],
         _T_[8],
         _T_[9],
         _T_[10],
         _T_[11],
         _T_[12],
         _T_[13],
         _T_[14],
         _T_[15],
         _T_[16],
         _T_[17],
         _T_[18]],
        [0, _S_[1], _S_[2], _S_[3], _S_[4], _S_[5], _S_[6], _S_[7]],
        Core_Int[105],
        Core_Int[81],
        Core_Int[82],
        Core_Int[83],
        Core_Int[84],
        Core_Int[85],
        Core_Int[86],
        Core_Int[87],
        Core_Int[88],
        Core_Int[89],
        Core_Int[90],
        Core_Int[91],
        Core_Int[92],
        Core_Int[93],
        Core_Int[94],
        Core_Int[95],
        Core_Int[97],
        Core_Int[106],
        Core_Int[107],
        Core_Int[108],
        Core_Int[96],
        [0,
         [0, _R_[9], _R_[10], _R_[11]],
         [0, _Q_[9], _Q_[10], _Q_[11], _Q_[12], _Q_[13]],
         _P_[3],
         _P_[4],
         _P_[5],
         _P_[6],
         _P_[7],
         _P_[8],
         _P_[9],
         _P_[10],
         _P_[11],
         _P_[12],
         _P_[13],
         _P_[14],
         _P_[15],
         _P_[16],
         _P_[17],
         _P_[18],
         _P_[19],
         _P_[20],
         _P_[21],
         _P_[22],
         _P_[23],
         _P_[24],
         _P_[25],
         _P_[26],
         _P_[27],
         _P_[28],
         _P_[29],
         _P_[30],
         _P_[31],
         _P_[32],
         _P_[33],
         _P_[34],
         _P_[35],
         _P_[36],
         _P_[37],
         _P_[38],
         _P_[39],
         _P_[40],
         _P_[41],
         _P_[42],
         _P_[43],
         _P_[44],
         _P_[45]],
        [0,
         [0, _O_[1], _O_[2], _O_[11]],
         [0, _N_[9], _N_[10], _N_[11], _N_[12], _N_[13]],
         _M_[3],
         _M_[4],
         _M_[5],
         _M_[6],
         _M_[7],
         _M_[8],
         _M_[9],
         _M_[10],
         _M_[11],
         _M_[12],
         _M_[13],
         _M_[14],
         _M_[15],
         _M_[16],
         _M_[17],
         _M_[18],
         _M_[19],
         _M_[20],
         _M_[21],
         _M_[22],
         _M_[23],
         _M_[24],
         _M_[25],
         _M_[26],
         _M_[27],
         _M_[28]],
        Core_Int[79],
        Core_Int[65],
        Core_Int[64]],
       directly_observed,
       traverse];
   runtime.caml_register_global
    (205, Incremental_For_analyzer, cst_Incremental_For_analyzer$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__For_analyzer_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_For_analyzer_i = "Incremental__For_analyzer_intf",
    cst_incremental = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_For_analyzer_i);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][1], "src/for_analyzer_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental, "for_analyzer_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_For_analyzer_i);
   var Incremental_For_analyzer_intf = [0];
   runtime.caml_register_global
    (11, Incremental_For_analyzer_intf, cst_Incremental_For_analyzer_i);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Node_to_dot
//# unitInfo: Requires: Core, Core__Hash_set, Core__List, Incremental__For_analyzer, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Stdio__Out_channel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "  ",
    cst_rankdir_BT = "  rankdir = BT\n",
    cst$0 = " -> ",
    cst_Incremental_Node_to_dot$0 = "Incremental__Node_to_dot",
    cst_digraph_G = "digraph G {\n",
    cst_incremental$0 = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdio_Out_channel = global_data.Stdio__Out_channel,
    Core_Hash_set = global_data.Core__Hash_set,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Incremental_For_analyzer = global_data.Incremental__For_analyzer,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Node_to_dot$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/node_to_dot.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "node_to_dot.ml");
   var
    _e_ =
      [0,
       [11, cst, [2, 0, [11, cst$0, [2, 0, [11, " [style=dashed]\n", 0]]]]],
       "  %s -> %s [style=dashed]\n"],
    _d_ =
      [0, [11, cst, [2, 0, [11, cst$0, [2, 0, [12, 10, 0]]]]], "  %s -> %s\n"],
    cst_n$0 = "n",
    cst_n = "n###",
    _b_ = [0, [11, cst_digraph_G, 0], cst_digraph_G],
    _c_ = [0, [11, cst_rankdir_BT, 0], cst_rankdir_BT],
    _f_ = [0, [11, "}\n", [10, 0]], "}\n%!"],
    _a_ = [0, [2, 0, [12, 10, 0]], "%s\n"],
    cst_incremental = cst_incremental$0,
    cst_Incremental_Node_to_dot = cst_Incremental_Node_to_dot$0;
   function save_dot(emit_bind_edges, out, ts){
    var
     node_name =
       Core[628]
        ? function(param){return cst_n;}
        : function
         (id){
          var _t_ = caml_call1(Incremental_For_analyzer[5][31], id);
          return caml_call2(Core[18], cst_n$0, _t_);
         };
    caml_call2(Core[249], out, _b_);
    caml_call2(Core[249], out, _c_);
    var
     seen = caml_call3(Incremental_For_analyzer[5][7][3], 0, 0, 0),
     bind_edges = [0, 0];
    function _h_
    (id, kind, param, children, bind_children, user_info$0, _p_, _o_, height){
     var name = node_name(id);
     caml_call2(Core_Hash_set[22], seen, id);
     var
      default$0 =
        caml_call3(Incremental_For_analyzer[3][9], name, kind, height);
     if(user_info$0)
      var
       user_info = user_info$0[1],
       info = caml_call2(Incremental_For_analyzer[3][7], default$0, user_info);
     else
      var info = default$0;
     var
      _m_ = caml_call1(Incremental_For_analyzer[3][6], info),
      _n_ = caml_call3(Incremental_For_analyzer[3][8], 0, name, _m_);
     caml_call3(Core[249], out, _a_, _n_);
     function _q_(child_id){
      var _s_ = node_name(child_id);
      return caml_call4(Core[249], out, _d_, _s_, name);
     }
     caml_call2(Core_List[19], children, _q_);
     function _r_(bind_child_id){
      bind_edges[1] = [0, [0, bind_child_id, id], bind_edges[1]];
      return 0;
     }
     return caml_call2(Core_List[19], bind_children, _r_);
    }
    caml_call2(Incremental_For_analyzer[7], ts, _h_);
    if(emit_bind_edges){
     var
      _i_ =
        function(param){
         var
          id = param[2],
          bind_child_id = param[1],
          _j_ = caml_call2(Core_Hash_set[20], seen, bind_child_id);
         if(! _j_) return _j_;
         var _k_ = node_name(bind_child_id), _l_ = node_name(id);
         return caml_call4(Core[249], out, _e_, _l_, _k_);
        };
     caml_call2(Core_List[19], bind_edges[1], _i_);
    }
    return caml_call2(Core[249], out, _f_);
   }
   function save_dot_to_file(emit_bind_edges, file, ts){
    function _g_(out){return save_dot(emit_bind_edges, out, ts);}
    return caml_call6(Stdio_Out_channel[6], 0, 0, 0, 0, file, _g_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Node_to_dot);
   var Incremental_Node_to_dot = [0, save_dot, save_dot_to_file];
   runtime.caml_register_global
    (24, Incremental_Node_to_dot, cst_Incremental_Node_to_dot$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental__Incremental_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incremental_Incremental_in = "Incremental__Incremental_intf",
    cst_incremental = "incremental";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental_Incremental_in);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][1], "src/incremental_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_incremental, "incremental_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental_Incremental_in);
   var Incremental_Incremental_intf = [0];
   runtime.caml_register_global
    (11, Incremental_Incremental_intf, cst_Incremental_Incremental_in);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incremental
//# unitInfo: Requires: Core, Incremental__Before_or_after, Incremental__Config, Incremental__Cutoff, Incremental__Expert1, Incremental__For_analyzer, Incremental__Import, Incremental__Incremental_intf, Incremental__Node, Incremental__Node_to_dot, Incremental__Observer, Incremental__On_update_handler, Incremental__Reduce_balanced, Incremental__Scope, Incremental__State, Incremental__Unordered_array_fold, Incremental__Var, Incremental_step_function, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stdio__Out_channel, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_invalid$1 = "<invalid>",
    cst_Incremental$0 = "Incremental",
    cst_incremental$0 = "incremental",
    cst_src_incremental_ml = "src/incremental.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    level_bits = [0, 14, [0, 13, [0, 5, 0]]],
    Incremental_Before_or_after = global_data.Incremental__Before_or_after,
    Incremental_Cutoff = global_data.Incremental__Cutoff,
    Incremental_On_update_handler = global_data.Incremental__On_update_handler,
    Incremental_Config = global_data.Incremental__Config,
    Stdio_Out_channel = global_data.Stdio__Out_channel,
    Assert_failure = global_data.Assert_failure,
    Incremental_Expert1 = global_data.Incremental__Expert1;
   global_data.Incremental__Unordered_array_fold;
   var
    Core = global_data.Core,
    Incremental_Import = global_data.Incremental__Import,
    Incremental_step_function = global_data.Incremental_step_function,
    Timing_wheel = global_data.Timing_wheel,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Incremental_Reduce_balanced = global_data.Incremental__Reduce_balanced,
    Incremental_Node_to_dot = global_data.Incremental__Node_to_dot,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Incremental_State = global_data.Incremental__State,
    Incremental_Scope = global_data.Incremental__Scope,
    Incremental_Node = global_data.Incremental__Node,
    Incremental_Var = global_data.Incremental__Var,
    Incremental_Observer = global_data.Incremental__Observer,
    Incremental_For_analyzer = global_data.Incremental__For_analyzer;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incremental$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incremental$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_incremental_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_incremental$0, "incremental.ml");
   var
    sexp_of_status = Incremental_State[1],
    Run_on_update_handlers = Incremental_State[2],
    Only_in_debug = Incremental_State[3],
    Packed_weak_hashtbl = Incremental_State[4],
    num_var_sets = Incremental_State[5],
    set_num_var_sets = Incremental_State[6],
    num_nodes_recomputed_directly_ = Incremental_State[7],
    set_num_nodes_recomputed_direc = Incremental_State[8],
    num_nodes_recomputed_directly_$0 = Incremental_State[9],
    set_num_nodes_recomputed_direc$0 = Incremental_State[10],
    num_nodes_recomputed = Incremental_State[11],
    set_num_nodes_recomputed = Incremental_State[12],
    num_nodes_invalidated = Incremental_State[13],
    set_num_nodes_invalidated = Incremental_State[14],
    num_nodes_created = Incremental_State[15],
    set_num_nodes_created = Incremental_State[16],
    num_nodes_changed = Incremental_State[17],
    set_num_nodes_changed = Incremental_State[18],
    num_nodes_became_unnecessary = Incremental_State[19],
    set_num_nodes_became_unnecessa = Incremental_State[20],
    num_nodes_became_necessary = Incremental_State[21],
    set_num_nodes_became_necessary = Incremental_State[22],
    keep_node_creation_backtrace = Incremental_State[23],
    set_keep_node_creation_backtra = Incremental_State[24],
    weak_hashtbls = Incremental_State[25],
    only_in_debug = Incremental_State[26],
    set_only_in_debug = Incremental_State[27],
    run_on_update_handlers = Incremental_State[28],
    set_during_stabilization = Incremental_State[29],
    disallowed_observers = Incremental_State[30],
    new_observers = Incremental_State[31],
    finalized_observers = Incremental_State[32],
    all_observers = Incremental_State[33],
    set_all_observers = Incremental_State[34],
    num_active_observers = Incremental_State[35],
    set_num_active_observers = Incremental_State[36],
    adjust_heights_heap = Incremental_State[37],
    recompute_heap = Incremental_State[38],
    current_scope = Incremental_State[39],
    set_current_scope = Incremental_State[40],
    stabilization_num = Incremental_State[41],
    set_stabilization_num = Incremental_State[42],
    bind_lhs_change_should_invalid = Incremental_State[43],
    status = Incremental_State[44],
    set_status = Incremental_State[45],
    Fields = Incremental_State[46],
    sexp_of_t = Incremental_State[47],
    include = Incremental_State[48],
    now = Incremental_State[49],
    timing_wheel_length = Incremental_State[50],
    num_stabilizes = Incremental_State[51],
    max_height_allowed = Incremental_State[52],
    max_height_seen = Incremental_State[53],
    iter_observers = Incremental_State[54],
    directly_observed = Incremental_State[55],
    iter_observer_descendants = Incremental_State[56],
    Stats = Incremental_State[57],
    stats = Incremental_State[58],
    am_stabilizing = Incremental_State[59],
    invariant = Incremental_State[60],
    ensure_not_stabilizing = Incremental_State[61],
    set_height = Incremental_State[62],
    set_max_height_allowed = Incremental_State[63],
    handle_after_stabilization = Incremental_State[64],
    remove_children = Incremental_State[65],
    remove_child = Incremental_State[66],
    check_if_unnecessary = Incremental_State[67],
    became_unnecessary = Incremental_State[68],
    remove_alarm = Incremental_State[69],
    invalidate_node = Incremental_State[70],
    invalidate_nodes_created_on_rh = Incremental_State[71],
    rescope_nodes_created_on_rhs = Incremental_State[72],
    propagate_invalidity = Incremental_State[73],
    add_parent_without_adjusting_h = Incremental_State[74],
    became_necessary = Incremental_State[75],
    add_parent = Incremental_State[76],
    run_with_scope = Incremental_State[77],
    within_scope = Incremental_State[78],
    change_child = Incremental_State[79],
    add_alarm = Incremental_State[80],
    recompute = Incremental_State[81],
    copy_child = Incremental_State[82],
    maybe_change_value = Incremental_State[83],
    recompute_first_node_that_is_n = Incremental_State[84],
    unlink_disallowed_observers = Incremental_State[85],
    disallow_future_use = Incremental_State[86],
    disallow_finalized_observers = Incremental_State[87],
    observer_finalizer = Incremental_State[88],
    create_observer = Incremental_State[89],
    add_new_observers = Incremental_State[90],
    observer_value_exn = Incremental_State[91],
    observer_value = Incremental_State[92],
    node_on_update = Incremental_State[93],
    observer_on_update_exn = Incremental_State[94],
    set_var_while_not_stabilizing = Incremental_State[95],
    set_var = Incremental_State[96],
    reclaim_space_in_weak_hashtbls = Incremental_State[97],
    stabilize_start = Incremental_State[98],
    stabilize_end = Incremental_State[99],
    raise_during_stabilization = Incremental_State[100],
    stabilize = Incremental_State[101],
    Step_result = Incremental_State[102],
    do_one_step_of_stabilize = Incremental_State[103],
    create_node_in = Incremental_State[104],
    create_node = Incremental_State[105],
    create_node_top = Incremental_State[106],
    create_var = Incremental_State[107],
    const$0 = Incremental_State[108],
    map = Incremental_State[109],
    map2 = Incremental_State[110],
    both = Incremental_State[111],
    map3 = Incremental_State[112],
    map4 = Incremental_State[113],
    map5 = Incremental_State[114],
    map6 = Incremental_State[115],
    map7 = Incremental_State[116],
    map8 = Incremental_State[117],
    map9 = Incremental_State[118],
    map10 = Incremental_State[119],
    map11 = Incremental_State[120],
    map12 = Incremental_State[121],
    map13 = Incremental_State[122],
    map14 = Incremental_State[123],
    map15 = Incremental_State[124],
    preserve_cutoff = Incremental_State[125],
    depend_on = Incremental_State[126],
    necessary_if_alive = Incremental_State[127],
    bind = Incremental_State[128],
    bind2 = Incremental_State[129],
    bind3 = Incremental_State[130],
    bind4 = Incremental_State[131],
    join = Incremental_State[132],
    if$0 = Incremental_State[133],
    lazy_from_fun = Incremental_State[134],
    default_hash_table_initial_siz = Incremental_State[135],
    memoize_fun_by_key = Incremental_State[136],
    array_fold = Incremental_State[137],
    all = Incremental_State[138],
    unordered_array_fold = Incremental_State[139],
    opt_unordered_array_fold = Incremental_State[140],
    at_least_k_of = Incremental_State[141],
    exists = Incremental_State[142],
    for_all = Incremental_State[143],
    sum = Incremental_State[144],
    opt_sum = Incremental_State[145],
    sum_int = Incremental_State[146],
    sum_float = Incremental_State[147],
    set_freeze = Incremental_State[148],
    freeze = Incremental_State[149],
    at = Incremental_State[150],
    after = Incremental_State[151],
    next_interval_alarm_strict = Incremental_State[152],
    at_intervals = Incremental_State[153],
    snapshot = Incremental_State[154],
    incremental_step_function = Incremental_State[155],
    make_stale = Incremental_State[156],
    advance_clock = Incremental_State[157],
    create_clock = Incremental_State[158],
    create_internal = Incremental_State[159],
    weak_memoize_fun_by_key = Incremental_State[160],
    Expert = Incremental_State[161],
    _m_ = [0, cst_src_incremental_ml, 298, 2],
    cst_invalid$0 = cst_invalid$1,
    cst_unnecessary = "<unnecessary>",
    cst_uncomputed = "<uncomputed>",
    _j_ = [0, "Invalid"],
    _k_ = [0, "Necessary_maybe_stale"],
    _l_ = [0, "Unnecessary_maybe_stale"],
    cst_invalid = cst_invalid$1,
    cst_unstabilized = "<unstabilized>",
    cst_disallowed = "<disallowed>",
    _f_ = [0, "_"],
    cst_Incremental_bug_Observer_o =
      "Incremental bug -- Observer.on_update_exn got unexpected update Unnecessary",
    _g_ = [0, cst_src_incremental_ml, 152, 3857, 3875],
    _c_ = [0, "Invalidated"],
    _d_ = [0, "Initialized"],
    _e_ = [0, "Changed"],
    _a_ = [0, cst_src_incremental_ml, 31, 8],
    _h_ = [0, 1],
    cst_incremental = cst_incremental$0,
    cst_Incremental = cst_Incremental$0,
    default_max_height_allowed = 128;
   function create(opt, param){
    if(opt)
     var sth = opt[1], max_height_allowed = sth;
    else
     var max_height_allowed = default_max_height_allowed;
    function sexp_of_state_witness(param){
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    }
    var
     t =
       caml_call2
        (create_internal,
         caml_call1(Incremental_Config[1], 0),
         max_height_allowed);
    return [0, sexp_of_state_witness, t];
   }
   var
    sexp_of_t$0 = Incremental_Scope[1],
    invariant$0 = Incremental_Scope[2],
    top = Incremental_Scope[3],
    is_top = Incremental_Scope[4],
    height = Incremental_Scope[5],
    is_valid = Incremental_Scope[6],
    is_necessary = Incremental_Scope[7],
    add_node = Incremental_Scope[8];
   function current(state, param){return state[4];}
   function within(state, t, f){return caml_call3(within_scope, state, t, f);}
   var
    Packed = Incremental_Node[1],
    invariant$1 = Incremental_Node[4],
    is_const = Incremental_Node[13],
    is_necessary$0 = Incremental_Node[15],
    is_valid$0 = Incremental_Node[16],
    unsafe_value = Incremental_Node[22],
    get_cutoff = Incremental_Node[23],
    set_cutoff = Incremental_Node[24],
    user_info = Incremental_Node[27],
    set_user_info = Incremental_Node[28],
    append_user_info_graphviz = Incremental_Node[29],
    sexp_of_t$1 = Packed[1],
    invariant$2 = Packed[2],
    As_list = Packed[3],
    iter_descendants = Packed[4],
    append_user_info_graphviz$0 = Packed[5];
   function save_dot(opt){
    if(opt)
     var sth = opt[1], emit_bind_edges = sth;
    else
     var emit_bind_edges = 1;
    return caml_call1(Incremental_Node_to_dot[1], emit_bind_edges);
   }
   function save_dot_to_file(opt){
    if(opt)
     var sth = opt[1], emit_bind_edges = sth;
    else
     var emit_bind_edges = 1;
    return caml_call1(Incremental_Node_to_dot[2], emit_bind_edges);
   }
   var
    Packed$0 =
      [0,
       sexp_of_t$1,
       invariant$2,
       As_list,
       iter_descendants,
       append_user_info_graphviz$0,
       save_dot,
       save_dot_to_file];
   function state(t){return t[2];}
   function pack(t){return t;}
   function return$0(state, a){return caml_call2(const$0, state, a);}
   var
    N_ary_map_and_bind =
      [0,
       map2,
       map3,
       map4,
       map5,
       map6,
       map7,
       map8,
       map9,
       map10,
       map11,
       map12,
       map13,
       map14,
       map15,
       bind2,
       bind3,
       bind4],
    map2$0 = N_ary_map_and_bind[1],
    map3$0 = N_ary_map_and_bind[2],
    map4$0 = N_ary_map_and_bind[3],
    map5$0 = N_ary_map_and_bind[4],
    map6$0 = N_ary_map_and_bind[5],
    map7$0 = N_ary_map_and_bind[6],
    map8$0 = N_ary_map_and_bind[7],
    map9$0 = N_ary_map_and_bind[8],
    map10$0 = N_ary_map_and_bind[9],
    map11$0 = N_ary_map_and_bind[10],
    map12$0 = N_ary_map_and_bind[11],
    map13$0 = N_ary_map_and_bind[12],
    map14$0 = N_ary_map_and_bind[13],
    map15$0 = N_ary_map_and_bind[14],
    bind2$0 = N_ary_map_and_bind[15],
    bind3$0 = N_ary_map_and_bind[16],
    bind4$0 = N_ary_map_and_bind[17];
   function symbol_map(t, f){return caml_call2(map, t, f);}
   function symbol_bind(t, f){return caml_call2(bind, t, f);}
   var
    Infix = [0, symbol_map, symbol_bind],
    symbol_map$0 = Infix[1],
    symbol_bind$0 = Infix[2];
   function lazy_from_fun$0(state, f){
    return caml_call2(lazy_from_fun, state, f);
   }
   function memoize_fun(initial_size, state, hashable, f){
    return caml_call5
            (memoize_fun_by_key,
             initial_size,
             state,
             hashable,
             function(_aa_){return _aa_;},
             f);
   }
   function array_fold$0(state, ts, init, f){
    return caml_call4(array_fold, state, ts, init, f);
   }
   function reduce_balanced(state, ts, f, reduce){
    return caml_call4(Incremental_Reduce_balanced[1], state, ts, f, reduce);
   }
   var
    invariant$3 = Incremental_Var[1],
    Packed$1 = Incremental_Var[3],
    latest_value = Incremental_Var[4],
    incr_state = Incremental_Var[5];
   function value(t){return t[1];}
   function watch(t){return t[4];}
   function sexp_of_t$2(sexp_of_a, t){return caml_call1(sexp_of_a, t[1]);}
   function replace(t, f){
    return caml_call2(set_var, t, caml_call1(f, caml_call1(latest_value, t)));
   }
   var
    invariant$4 = Incremental_Observer[1],
    observing = Incremental_Observer[3],
    use_is_allowed = Incremental_Observer[4],
    incr_state$0 = Incremental_Observer[7],
    _b_ = Incremental_Observer[2];
   function compare(cmp_a, a_001, b_002){
    if(a_001 === b_002) return 0;
    if(typeof a_001 === "number"){
     if(typeof b_002 === "number") return 0;
     if(1 === b_002[0]) return 1;
    }
    else{
     if(0 === a_001[0]){
      var a_003 = a_001[1];
      if(typeof b_002 !== "number" && 0 === b_002[0]){
       var b_004 = b_002[1];
       return caml_call2(cmp_a, a_003, b_004);
      }
      return -1;
     }
     var a_007 = a_001[2], a_005 = a_001[1];
     if(typeof b_002 === "number") return -1;
     if(0 !== b_002[0]){
      var
       b_008 = b_002[2],
       b_006 = b_002[1],
       n = caml_call2(cmp_a, a_005, b_006);
      return 0 === n ? caml_call2(cmp_a, a_007, b_008) : n;
     }
    }
    return 1;
   }
   function sexp_of_t$3(of_a_009, param){
    if(typeof param === "number") return _c_;
    if(0 === param[0]){
     var arg0_010 = param[1], res0_011 = caml_call1(of_a_009, arg0_010);
     return [1, [0, _d_, [0, res0_011, 0]]];
    }
    var
     arg1_013 = param[2],
     arg0_012 = param[1],
     res0_014 = caml_call1(of_a_009, arg0_012),
     res1_015 = caml_call1(of_a_009, arg1_013);
    return [1, [0, _e_, [0, res0_014, [0, res1_015, 0]]]];
   }
   var Update = [0, compare, sexp_of_t$3];
   function on_update_exn(t, f){
    return caml_call2
            (observer_on_update_exn,
             t,
             function(param){
              if(typeof param === "number"){
               if(0 === param) return caml_call1(f, 0);
               var
                _$_ =
                  function(x_017){
                   return caml_call2(_b_, function(param){return _f_;}, x_017);
                  };
               return caml_call5
                       (Core[247], 0, _g_, cst_Incremental_bug_Observer_o, t, _$_);
              }
              if(0 === param[0]){
               var a = param[1];
               return caml_call1(f, [0, a]);
              }
              var a2 = param[2], a1 = param[1];
              return caml_call1(f, [1, a1, a2]);
             });
   }
   function disallow_future_use$0(t){
    return caml_call1(disallow_future_use, t[1]);
   }
   function sexp_of_t$4(sexp_of_a, t){
    var ___ = t[1][1];
    if(1 !== ___)
     return ___
             ? caml_call1(Sexplib0_Sexp_conv[7], cst_disallowed)
             : caml_call1(Sexplib0_Sexp_conv[7], cst_unstabilized);
    var uopt = t[1][2][4];
    return caml_call1(Incremental_Import[6][7], uopt)
            ? caml_call1(Sexplib0_Sexp_conv[7], cst_invalid)
            : caml_call1
              (sexp_of_a, caml_call1(Incremental_Import[6][16], uopt));
   }
   var
    Observer =
      [0,
       invariant$4,
       observing,
       use_is_allowed,
       incr_state$0,
       Update,
       on_update_exn,
       disallow_future_use$0,
       observer_value,
       observer_value_exn,
       sexp_of_t$4],
    fired_alarm_values = include[1],
    set_fired_alarm_values = include[2],
    handle_fired = include[3],
    timing_wheel = include[5],
    Fields$0 = include[6],
    sexp_of_t$5 = include[7],
    invariant$5 = include[8],
    incr_state$1 = include[9],
    alarm_precision = Timing_wheel[1][10],
    _i_ = [0, caml_call2(Timing_wheel[7][5], _h_, level_bits)],
    default_timing_wheel_config =
      caml_call4(Timing_wheel[8][4], 0, _i_, alarm_precision, 0);
   function create$0(state, opt, start, param){
    if(opt)
     var sth = opt[1], timing_wheel_config = sth;
    else
     var timing_wheel_config = default_timing_wheel_config;
    var
     _Z_ = caml_call1(Incremental_Import[4][93], start),
     start$0 = caml_call1(Incremental_Import[4][95], _Z_);
    return caml_call3(create_clock, state, timing_wheel_config, start$0);
   }
   function alarm_precision$0(t){return caml_call1(Timing_wheel[10], t[1]);}
   function watch_now(t){return t[2][4];}
   function advance_clock_by(t, span){
    var _Y_ = caml_call1(now, t);
    return caml_call2
            (advance_clock,
             t,
             caml_call2(Incremental_Import[4][67], _Y_, span));
   }
   function step_function(t, init, steps){
    var _X_ = caml_call2(Incremental_step_function[7], init, steps);
    return caml_call2
            (incremental_step_function,
             t,
             return$0(caml_call1(incr_state$1, t), _X_));
   }
   function freeze$0(opt, t){
    if(opt)
     var sth = opt[1], when = sth;
    else
     var when = function(param){return 1;};
    return caml_call2(freeze, t, when);
   }
   function depend_on$0(t, depend_on$0){
    return caml_call2(depend_on, t, depend_on$0);
   }
   function stabilize$0(state){return caml_call1(stabilize, state);}
   function am_stabilizing$0(state){return caml_call1(am_stabilizing, state);}
   function save_dot$0(opt, t, out){
    if(opt)
     var sth = opt[1], emit_bind_edges = sth;
    else
     var emit_bind_edges = 1;
    var _W_ = caml_call1(directly_observed, t);
    return caml_call2(Packed$0[6].call(null, [0, emit_bind_edges]), out, _W_);
   }
   function save_dot_to_file$0(opt, t, file){
    if(opt)
     var sth = opt[1], emit_bind_edges = sth;
    else
     var emit_bind_edges = 1;
    var _V_ = caml_call1(directly_observed, t);
    return caml_call2(Packed$0[7].call(null, [0, emit_bind_edges]), file, _V_);
   }
   function sexp_of_t$6(of_a_018, param){
    if(typeof param === "number") return _j_;
    if(0 === param[0]){
     var
      arg0_019 = param[1],
      res0_020 = caml_call2(Core[515], of_a_018, arg0_019);
     return [1, [0, _k_, [0, res0_020, 0]]];
    }
    var
     arg0_021 = param[1],
     res0_022 = caml_call2(Core[515], of_a_018, arg0_021);
    return [1, [0, _l_, [0, res0_022, 0]]];
   }
   var Node_value = [0, sexp_of_t$6];
   function node_value(t){
    return caml_call1(is_valid$0, t)
            ? caml_call1
               (is_necessary$0, t)
              ? [0, caml_call1(Incremental_Import[6][12], t[4])]
              : [1, caml_call1(Incremental_Import[6][12], t[4])]
            : 0;
   }
   function sexp_of_t$7(sexp_of_a, t){
    return caml_call1(is_valid$0, t)
            ? caml_call1
               (is_necessary$0, t)
              ? caml_call1
                 (Incremental_Import[6][7], t[4])
                ? caml_call1(Core[558], cst_uncomputed)
                : caml_call1(sexp_of_a, caml_call1(unsafe_value, t))
              : caml_call1(Core[558], cst_unnecessary)
            : caml_call1(Core[558], cst_invalid$0);
   }
   function both$0(t1, t2){
    return caml_call3(map2$0, t1, t2, function(x1, x2){return [0, x1, x2];});
   }
   var
    map2$1 = N_ary_map_and_bind[1],
    map3$1 = N_ary_map_and_bind[2],
    map4$1 = N_ary_map_and_bind[3],
    map5$1 = N_ary_map_and_bind[4],
    map6$1 = N_ary_map_and_bind[5],
    map7$1 = N_ary_map_and_bind[6],
    map8$1 = N_ary_map_and_bind[7],
    map9$1 = N_ary_map_and_bind[8],
    map10$1 = N_ary_map_and_bind[9],
    map11$1 = N_ary_map_and_bind[10],
    map12$1 = N_ary_map_and_bind[11],
    map13$1 = N_ary_map_and_bind[12],
    map14$1 = N_ary_map_and_bind[13],
    map15$1 = N_ary_map_and_bind[14],
    bind2$1 = N_ary_map_and_bind[15],
    bind3$1 = N_ary_map_and_bind[16],
    bind4$1 = N_ary_map_and_bind[17],
    Open_on_rhs = [0, watch];
   function weak_memoize_fun(initial_size, state, hashable, f){
    return caml_call5
            (weak_memoize_fun_by_key,
             initial_size,
             state,
             hashable,
             function(_U_){return _U_;},
             f);
   }
   function Make_with_config(Incremental_config, symbol){
    function sexp_of_state_witness(param){
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    }
    var
     t = caml_call2(create_internal, Incremental_config, 128),
     State =
       [0,
        sexp_of_status,
        Run_on_update_handlers,
        Only_in_debug,
        Packed_weak_hashtbl,
        num_var_sets,
        set_num_var_sets,
        num_nodes_recomputed_directly_,
        set_num_nodes_recomputed_direc,
        num_nodes_recomputed_directly_$0,
        set_num_nodes_recomputed_direc$0,
        num_nodes_recomputed,
        set_num_nodes_recomputed,
        num_nodes_invalidated,
        set_num_nodes_invalidated,
        num_nodes_created,
        set_num_nodes_created,
        num_nodes_changed,
        set_num_nodes_changed,
        num_nodes_became_unnecessary,
        set_num_nodes_became_unnecessa,
        num_nodes_became_necessary,
        set_num_nodes_became_necessary,
        keep_node_creation_backtrace,
        set_keep_node_creation_backtra,
        weak_hashtbls,
        only_in_debug,
        set_only_in_debug,
        run_on_update_handlers,
        set_during_stabilization,
        disallowed_observers,
        new_observers,
        finalized_observers,
        all_observers,
        set_all_observers,
        num_active_observers,
        set_num_active_observers,
        adjust_heights_heap,
        recompute_heap,
        current_scope,
        set_current_scope,
        stabilization_num,
        set_stabilization_num,
        bind_lhs_change_should_invalid,
        status,
        set_status,
        Fields,
        sexp_of_t,
        include,
        now,
        timing_wheel_length,
        num_stabilizes,
        max_height_allowed,
        max_height_seen,
        iter_observers,
        directly_observed,
        iter_observer_descendants,
        Stats,
        stats,
        am_stabilizing,
        invariant,
        ensure_not_stabilizing,
        set_height,
        set_max_height_allowed,
        handle_after_stabilization,
        remove_children,
        remove_child,
        check_if_unnecessary,
        became_unnecessary,
        remove_alarm,
        invalidate_node,
        invalidate_nodes_created_on_rh,
        rescope_nodes_created_on_rhs,
        propagate_invalidity,
        add_parent_without_adjusting_h,
        became_necessary,
        add_parent,
        run_with_scope,
        within_scope,
        change_child,
        add_alarm,
        recompute,
        copy_child,
        maybe_change_value,
        recompute_first_node_that_is_n,
        unlink_disallowed_observers,
        disallow_future_use,
        disallow_finalized_observers,
        observer_finalizer,
        create_observer,
        add_new_observers,
        observer_value_exn,
        observer_value,
        node_on_update,
        observer_on_update_exn,
        set_var_while_not_stabilizing,
        set_var,
        reclaim_space_in_weak_hashtbls,
        stabilize_start,
        stabilize_end,
        raise_during_stabilization,
        stabilize,
        Step_result,
        do_one_step_of_stabilize,
        create_node_in,
        create_node,
        create_node_top,
        create_var,
        const$0,
        map,
        map2,
        both,
        map3,
        map4,
        map5,
        map6,
        map7,
        map8,
        map9,
        map10,
        map11,
        map12,
        map13,
        map14,
        map15,
        preserve_cutoff,
        depend_on,
        necessary_if_alive,
        bind,
        bind2,
        bind3,
        bind4,
        join,
        if$0,
        lazy_from_fun,
        default_hash_table_initial_siz,
        memoize_fun_by_key,
        array_fold,
        all,
        unordered_array_fold,
        opt_unordered_array_fold,
        at_least_k_of,
        exists,
        for_all,
        sum,
        opt_sum,
        sum_int,
        sum_float,
        set_freeze,
        freeze,
        at,
        after,
        next_interval_alarm_strict,
        at_intervals,
        snapshot,
        incremental_step_function,
        make_stale,
        advance_clock,
        create_clock,
        weak_memoize_fun_by_key,
        Expert,
        create_internal,
        create,
        t];
    function create$1(timing_wheel_config, start, param){
     return create$0(State[163], timing_wheel_config, start, 0);
    }
    var
     Clock =
       [0,
        fired_alarm_values,
        set_fired_alarm_values,
        handle_fired,
        timing_wheel,
        Fields$0,
        sexp_of_t$5,
        invariant$5,
        incr_state$1,
        incr_state$1,
        default_timing_wheel_config,
        alarm_precision$0,
        timing_wheel_length,
        now,
        watch_now,
        at,
        after,
        at_intervals,
        advance_clock,
        advance_clock_by,
        incremental_step_function,
        step_function,
        snapshot,
        create$1],
     Dependency = Incremental_Expert1[1],
     Node = Incremental_Expert1[2],
     sexp_of_t$1 = Node[1],
     watch$0 = Node[3],
     make_stale$0 = Node[4],
     invalidate = Node[5],
     add_dependency = Node[6],
     remove_dependency = Node[7],
     _Q_ = Node[2];
    function create$2(on_observability_change, f){
     return caml_call3(_Q_, State[163], on_observability_change, f);
    }
    var
     Node$0 =
       [0,
        sexp_of_t$1,
        watch$0,
        make_stale$0,
        invalidate,
        add_dependency,
        remove_dependency,
        create$2];
    function do_one_step_of_stabilize$0(param){
     return caml_call1(State[103], State[163]);
    }
    var Expert$0 = [0, Dependency, Node$0, do_one_step_of_stabilize$0];
    function return$1(a){return return$0(State[163], a);}
    var
     Let_syntax =
       [0,
        bind,
        map,
        both$0,
        map2$1,
        map3$1,
        map4$1,
        map5$1,
        map6$1,
        map7$1,
        map8$1,
        map9$1,
        map10$1,
        map11$1,
        map12$1,
        map13$1,
        map14$1,
        map15$1,
        bind2$1,
        bind3$1,
        bind4$1,
        Open_on_rhs,
        return$1],
     Let_syntax$0 = [0, symbol_map$0, symbol_bind$0, return$1, Let_syntax];
    function current(param){return State[163][4];}
    function within$0(t, f){return within(State[163], t, f);}
    var
     Scope =
       [0,
        sexp_of_t$0,
        invariant$0,
        top,
        is_top,
        height,
        is_valid,
        is_necessary,
        add_node,
        current,
        within$0];
    function create$3(use_current_scope, value){
     return caml_call3(create_var, State[163], use_current_scope, value);
    }
    var
     Var =
       [0,
        invariant$3,
        Packed$1,
        latest_value,
        incr_state,
        set_var,
        value,
        watch,
        sexp_of_t$2,
        replace,
        create$3];
    function const$1(a){return return$0(State[163], a);}
    function return$2(a){return return$0(State[163], a);}
    function all$0(ts){return caml_call2(all, State[163], ts);}
    function exists$0(ts){return caml_call2(exists, State[163], ts);}
    function for_all$0(ts){return caml_call2(for_all, State[163], ts);}
    function memoize_fun_by_key$0(initial_size, hashable, project_key, f){
     return caml_call5
             (memoize_fun_by_key,
              initial_size,
              State[163],
              hashable,
              project_key,
              f);
    }
    function memoize_fun$0(initial_size, hashable, f){
     return memoize_fun(initial_size, State[163], hashable, f);
    }
    function array_fold$1(ts, init, f){
     return array_fold$0(State[163], ts, init, f);
    }
    function reduce_balanced$0(ts, f, reduce){
     return reduce_balanced(State[163], ts, f, reduce);
    }
    function unordered_array_fold$0
    (full_compute_every_n_changes, ts, init, f, update){
     return caml_call6
             (unordered_array_fold,
              State[163],
              full_compute_every_n_changes,
              ts,
              init,
              f,
              update);
    }
    function opt_unordered_array_fold$0
    (full_compute_every_n_changes, ts, init, f, f_inverse){
     return caml_call6
             (opt_unordered_array_fold,
              State[163],
              full_compute_every_n_changes,
              ts,
              init,
              f,
              f_inverse);
    }
    function sum$0(full_compute_every_n_changes, ts, zero, add, sub){
     return caml_call6
             (sum,
              State[163],
              full_compute_every_n_changes,
              ts,
              zero,
              add,
              sub);
    }
    function opt_sum$0(full_compute_every_n_changes, ts, zero, add, sub){
     return caml_call6
             (opt_sum,
              State[163],
              full_compute_every_n_changes,
              ts,
              zero,
              add,
              sub);
    }
    function sum_int$0(ts){return caml_call2(sum_int, State[163], ts);}
    function sum_float$0(ts){return caml_call2(sum_float, State[163], ts);}
    function stabilize$1(param){return stabilize$0(State[163]);}
    function am_stabilizing$1(param){return am_stabilizing$0(State[163]);}
    function save_dot(opt, out){
     if(opt)
      var sth = opt[1], emit_bind_edges = sth;
     else
      var emit_bind_edges = 1;
     return save_dot$0([0, emit_bind_edges], State[163], out);
    }
    function save_dot_to_file(opt, file){
     if(opt)
      var sth = opt[1], emit_bind_edges = sth;
     else
      var emit_bind_edges = 1;
     var _R_ = [0, emit_bind_edges];
     function _S_(_T_){return save_dot(_R_, _T_);}
     return caml_call6(Stdio_Out_channel[6], 0, 0, 0, 0, file, _S_);
    }
    function lazy_from_fun$0(f){
     var state = State[163];
     return caml_call2(State[134], state, f);
    }
    function weak_memoize_fun_by_key$0(initial_size, hashable, project_key, f){
     return caml_call5
             (weak_memoize_fun_by_key,
              initial_size,
              State[163],
              hashable,
              project_key,
              f);
    }
    function weak_memoize_fun$0(initial_size, hashable, f){
     return weak_memoize_fun(initial_size, State[163], hashable, f);
    }
    return [0,
            sexp_of_state_witness,
            ,
            invariant$1,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            ,
            is_const,
            ,
            is_necessary$0,
            is_valid$0,
            ,
            ,
            ,
            ,
            ,
            ,
            get_cutoff,
            set_cutoff,
            ,
            user_info,
            set_user_info,
            append_user_info_graphviz,
            ,
            ,
            Packed$0,
            ,
            pack,
            create_observer,
            map,
            bind,
            ,
            map2$0,
            map3$0,
            map4$0,
            map5$0,
            map6$0,
            map7$0,
            map8$0,
            map9$0,
            map10$0,
            map11$0,
            map12$0,
            map13$0,
            map14$0,
            map15$0,
            bind2$0,
            bind3$0,
            bind4$0,
            Infix,
            symbol_map$0,
            symbol_bind$0,
            join,
            if$0,
            default_hash_table_initial_siz,
            ,
            both,
            Observer,
            freeze$0,
            depend_on$0,
            necessary_if_alive,
            node_on_update,
            Node_value,
            node_value,
            sexp_of_t$7,
            State,
            Clock,
            Expert$0,
            Let_syntax$0,
            Scope,
            Var,
            const$1,
            return$2,
            all$0,
            exists$0,
            for_all$0,
            memoize_fun_by_key$0,
            memoize_fun$0,
            array_fold$1,
            reduce_balanced$0,
            unordered_array_fold$0,
            opt_unordered_array_fold$0,
            sum$0,
            opt_sum$0,
            sum_int$0,
            sum_float$0,
            stabilize$1,
            am_stabilizing$1,
            save_dot,
            save_dot_to_file,
            lazy_from_fun$0,
            weak_memoize_fun_by_key$0,
            weak_memoize_fun$0];
   }
   function Add_witness0(M){
    function sexp_of_t(param, t){return caml_call1(M[1], t);}
    return [0, sexp_of_t];
   }
   function Add_witness1(M){
    function invariant(invariant_a, param, t){return caml_call2(M[2], invariant_a, t);
    }
    function sexp_of_t(sexp_of_a, param, t){return caml_call2(M[1], sexp_of_a, t);
    }
    return [0, sexp_of_t, invariant];
   }
   var
    include$0 = Add_witness0([0, sexp_of_t$5, invariant$5]),
    sexp_of_t$8 = include$0[1],
    Dependency = Incremental_Expert1[1],
    Node = Incremental_Expert1[2],
    create$1 = Dependency[2],
    value$0 = Dependency[3],
    sexp_of_t$9 = Dependency[1];
   function invariant$6(param, _P_){return 0;}
   var
    include$1 = Add_witness1([0, sexp_of_t$9, invariant$6]),
    sexp_of_t$10 = include$1[1],
    create$2 = Node[2],
    watch$0 = Node[3],
    make_stale$0 = Node[4],
    invalidate = Node[5],
    add_dependency = Node[6],
    remove_dependency = Node[7],
    sexp_of_t$11 = Node[1];
   function invariant$7(param, _O_){return 0;}
   var
    include$2 = Add_witness1([0, sexp_of_t$11, invariant$7]),
    sexp_of_t$12 = include$2[1];
   function do_one_step_of_stabilize$0(state){
    return caml_call1(do_one_step_of_stabilize, state);
   }
   var
    include$3 = Add_witness1([0, Incremental_Node[2], Incremental_Node[4]]),
    sexp_of_t$13 = include$3[1],
    invariant$8 = include$3[2],
    observing$0 = Observer[2],
    use_is_allowed$0 = Observer[3],
    Update$0 = Observer[5],
    on_update_exn$0 = Observer[6],
    disallow_future_use$1 = Observer[7],
    value$1 = Observer[8],
    value_exn = Observer[9],
    include$4 = Add_witness1([0, Observer[10], Observer[1]]),
    sexp_of_t$14 = include$4[1],
    invariant$9 = include$4[2],
    include$5 = Add_witness0([0, sexp_of_t, invariant]),
    sexp_of_t$15 = include$5[1],
    include$6 = Add_witness1([0, sexp_of_t$2, invariant$3]),
    sexp_of_t$16 = include$6[1],
    debug = Incremental_Import[1],
    Private = [0, debug];
   caml_call1(Ppx_inline_test_lib[7], cst_incremental);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incremental);
   function _n_(_C_, _B_){
    var
     _D_ = Make_with_config(_C_, _B_),
     _E_ = _D_[72],
     _F_ = _E_[2],
     _G_ = _D_[71],
     _H_ = _D_[73],
     _I_ = _H_[4],
     _J_ = _D_[30],
     _K_ = _D_[62],
     _L_ = _D_[75],
     _M_ = _D_[74],
     _N_ = _D_[70];
    return [0,
            _D_[1],
            [0,
             _N_[47],
             _N_[60],
             _N_[163],
             _N_[23],
             _N_[24],
             _N_[52],
             _N_[63],
             _N_[35],
             _N_[53],
             _N_[21],
             _N_[19],
             _N_[17],
             _N_[15],
             _N_[13],
             _N_[11],
             _N_[9],
             _N_[7],
             _N_[51],
             _N_[5],
             [0, _N_[57][2]],
             _N_[58]],
            _D_[69],
            _D_[3],
            _D_[12],
            _D_[15],
            _D_[14],
            _D_[76],
            _D_[77],
            _D_[34],
            _D_[55],
            _D_[37],
            _D_[38],
            _D_[39],
            _D_[40],
            _D_[41],
            _D_[42],
            _D_[43],
            _D_[44],
            _D_[45],
            _D_[46],
            _D_[47],
            _D_[48],
            _D_[49],
            _D_[50],
            _D_[35],
            _D_[56],
            _D_[51],
            _D_[52],
            _D_[53],
            _D_[54],
            _D_[57],
            _D_[58],
            _D_[63],
            _D_[64],
            _D_[65],
            _D_[80],
            _D_[79],
            _D_[78],
            _D_[61],
            _D_[83],
            _D_[84],
            [0],
            _D_[85],
            _D_[86],
            _D_[87],
            _D_[88],
            _D_[89],
            _D_[90],
            [0, _M_[3], _M_[9], _M_[10], _M_[4]],
            [0, _L_[8], _L_[10], _L_[5], _L_[7], _L_[6], _L_[3], _L_[9]],
            [0,
             _K_[10],
             _K_[1],
             _K_[2],
             _K_[3],
             _K_[8],
             _K_[9],
             _K_[5],
             _K_[6],
             _K_[7]],
            _D_[33],
            Incremental_On_update_handler[1],
            _D_[66],
            _D_[91],
            _D_[92],
            [0,
             Incremental_Cutoff[1],
             Incremental_Cutoff[2],
             Incremental_Cutoff[3],
             Incremental_Cutoff[4],
             Incremental_Cutoff[5],
             Incremental_Cutoff[6],
             Incremental_Cutoff[7],
             Incremental_Cutoff[8],
             Incremental_Cutoff[9],
             Incremental_Cutoff[11],
             Incremental_Cutoff[10]],
            _D_[23],
            _D_[22],
            _D_[95],
            _D_[59],
            _D_[82],
            _D_[81],
            _D_[97],
            _D_[96],
            _D_[25],
            _D_[26],
            _D_[27],
            _D_[67],
            _D_[68],
            [0, _J_[6], _J_[7], _J_[5]],
            _D_[32],
            _D_[93],
            _D_[94],
            [0,
             _H_[3],
             _H_[1],
             _H_[2],
             [0,
              _I_[1],
              _I_[22],
              _I_[18],
              _I_[19],
              _I_[20],
              _I_[2],
              _I_[4],
              _I_[5],
              _I_[6],
              _I_[7],
              _I_[8],
              _I_[9],
              _I_[10],
              _I_[11],
              _I_[12],
              _I_[13],
              _I_[14],
              _I_[15],
              _I_[16],
              _I_[17],
              _I_[3],
              _I_[21]]],
            Incremental_Before_or_after,
            [0,
             _G_[6],
             _G_[10],
             _G_[23],
             _G_[11],
             _G_[12],
             _G_[13],
             _G_[14],
             _G_[18],
             _G_[19],
             _G_[15],
             _G_[16],
             _G_[17],
             _G_[21],
             _G_[20],
             _G_[22]],
            [0,
             _E_[1],
             [0, _F_[1], _F_[7], _F_[2], _F_[3], _F_[4], _F_[5], _F_[6]],
             _D_[70][102],
             _E_[3]]];
   }
   function _o_(_p_){
    var
     _A_ = Make_with_config(caml_call1(Incremental_Config[1], 0), 0),
     _q_ = _A_[72],
     _r_ = _q_[2],
     _s_ = _A_[71],
     _t_ = _A_[73],
     _u_ = _t_[4],
     _v_ = _A_[30],
     _w_ = _A_[62],
     _x_ = _A_[75],
     _y_ = _A_[74],
     _z_ = _A_[70];
    return [0,
            _A_[1],
            [0,
             _z_[47],
             _z_[60],
             _z_[163],
             _z_[23],
             _z_[24],
             _z_[52],
             _z_[63],
             _z_[35],
             _z_[53],
             _z_[21],
             _z_[19],
             _z_[17],
             _z_[15],
             _z_[13],
             _z_[11],
             _z_[9],
             _z_[7],
             _z_[51],
             _z_[5],
             [0, _z_[57][2]],
             _z_[58]],
            _A_[69],
            _A_[3],
            _A_[12],
            _A_[15],
            _A_[14],
            _A_[76],
            _A_[77],
            _A_[34],
            _A_[55],
            _A_[37],
            _A_[38],
            _A_[39],
            _A_[40],
            _A_[41],
            _A_[42],
            _A_[43],
            _A_[44],
            _A_[45],
            _A_[46],
            _A_[47],
            _A_[48],
            _A_[49],
            _A_[50],
            _A_[35],
            _A_[56],
            _A_[51],
            _A_[52],
            _A_[53],
            _A_[54],
            _A_[57],
            _A_[58],
            _A_[63],
            _A_[64],
            _A_[65],
            _A_[80],
            _A_[79],
            _A_[78],
            _A_[61],
            _A_[83],
            _A_[84],
            [0],
            _A_[85],
            _A_[86],
            _A_[87],
            _A_[88],
            _A_[89],
            _A_[90],
            [0, _y_[3], _y_[9], _y_[10], _y_[4]],
            [0, _x_[8], _x_[10], _x_[5], _x_[7], _x_[6], _x_[3], _x_[9]],
            [0,
             _w_[10],
             _w_[1],
             _w_[2],
             _w_[3],
             _w_[8],
             _w_[9],
             _w_[5],
             _w_[6],
             _w_[7]],
            _A_[33],
            Incremental_On_update_handler[1],
            _A_[66],
            _A_[91],
            _A_[92],
            [0,
             Incremental_Cutoff[1],
             Incremental_Cutoff[2],
             Incremental_Cutoff[3],
             Incremental_Cutoff[4],
             Incremental_Cutoff[5],
             Incremental_Cutoff[6],
             Incremental_Cutoff[7],
             Incremental_Cutoff[8],
             Incremental_Cutoff[9],
             Incremental_Cutoff[11],
             Incremental_Cutoff[10]],
            _A_[23],
            _A_[22],
            _A_[95],
            _A_[59],
            _A_[82],
            _A_[81],
            _A_[97],
            _A_[96],
            _A_[25],
            _A_[26],
            _A_[27],
            _A_[67],
            _A_[68],
            [0, _v_[6], _v_[7], _v_[5]],
            _A_[32],
            _A_[93],
            _A_[94],
            [0,
             _t_[3],
             _t_[1],
             _t_[2],
             [0,
              _u_[1],
              _u_[22],
              _u_[18],
              _u_[19],
              _u_[20],
              _u_[2],
              _u_[4],
              _u_[5],
              _u_[6],
              _u_[7],
              _u_[8],
              _u_[9],
              _u_[10],
              _u_[11],
              _u_[12],
              _u_[13],
              _u_[14],
              _u_[15],
              _u_[16],
              _u_[17],
              _u_[3],
              _u_[21]]],
            Incremental_Before_or_after,
            [0,
             _s_[6],
             _s_[10],
             _s_[23],
             _s_[11],
             _s_[12],
             _s_[13],
             _s_[14],
             _s_[18],
             _s_[19],
             _s_[15],
             _s_[16],
             _s_[17],
             _s_[21],
             _s_[20],
             _s_[22]],
            [0,
             _q_[1],
             [0, _r_[1], _r_[7], _r_[2], _r_[3], _r_[4], _r_[5], _r_[6]],
             _A_[70][102],
             _q_[3]]];
   }
   var
    Incremental =
      [0,
       [0,
        sexp_of_t$15,
        create,
        keep_node_creation_backtrace,
        set_keep_node_creation_backtra,
        max_height_allowed,
        set_max_height_allowed,
        num_active_observers,
        max_height_seen,
        num_nodes_became_necessary,
        num_nodes_became_unnecessary,
        num_nodes_changed,
        num_nodes_created,
        num_nodes_invalidated,
        num_nodes_recomputed,
        num_nodes_recomputed_directly_$0,
        num_nodes_recomputed_directly_,
        num_stabilizes,
        num_var_sets,
        [0, Stats[2]],
        stats],
       sexp_of_t$13,
       invariant$8,
       state,
       is_const,
       is_valid$0,
       is_necessary$0,
       return$0,
       return$0,
       map,
       symbol_map$0,
       map2$0,
       map3$0,
       map4$0,
       map5$0,
       map6$0,
       map7$0,
       map8$0,
       map9$0,
       map10$0,
       map11$0,
       map12$0,
       map13$0,
       map14$0,
       map15$0,
       bind,
       symbol_bind$0,
       bind2$0,
       bind3$0,
       bind4$0,
       Infix,
       join,
       if$0,
       freeze$0,
       depend_on$0,
       necessary_if_alive,
       for_all,
       exists,
       all,
       both,
       array_fold$0,
       reduce_balanced,
       [0],
       unordered_array_fold,
       opt_unordered_array_fold,
       sum,
       opt_sum,
       sum_int,
       sum_float,
       [0, top, current, within, is_top],
       [0,
        sexp_of_t$16,
        create_var,
        set_var,
        watch,
        value,
        latest_value,
        replace],
       [0,
        sexp_of_t$14,
        invariant$9,
        observing$0,
        use_is_allowed$0,
        value$1,
        value_exn,
        Update$0,
        on_update_exn$0,
        disallow_future_use$1],
       create_observer,
       Incremental_On_update_handler[1],
       node_on_update,
       stabilize$0,
       am_stabilizing$0,
       [0,
        Incremental_Cutoff[1],
        Incremental_Cutoff[2],
        Incremental_Cutoff[3],
        Incremental_Cutoff[4],
        Incremental_Cutoff[5],
        Incremental_Cutoff[6],
        Incremental_Cutoff[7],
        Incremental_Cutoff[8],
        Incremental_Cutoff[9],
        Incremental_Cutoff[11],
        Incremental_Cutoff[10]],
       set_cutoff,
       get_cutoff,
       lazy_from_fun$0,
       default_hash_table_initial_siz,
       memoize_fun,
       memoize_fun_by_key,
       weak_memoize_fun,
       weak_memoize_fun_by_key,
       user_info,
       set_user_info,
       append_user_info_graphviz,
       Node_value,
       node_value,
       [0, Packed$0[6], Packed$0[7]],
       pack,
       save_dot$0,
       save_dot_to_file$0,
       [0,
        symbol_map$0,
        symbol_bind$0,
        [0,
         bind,
         bind2$1,
         bind3$1,
         bind4$1,
         map,
         map2$1,
         map3$1,
         map4$1,
         map5$1,
         map6$1,
         map7$1,
         map8$1,
         map9$1,
         map10$1,
         map11$1,
         map12$1,
         map13$1,
         map14$1,
         map15$1,
         both$0,
         Open_on_rhs]],
       Incremental_Before_or_after,
       [0,
        sexp_of_t$8,
        default_timing_wheel_config,
        create$0,
        alarm_precision$0,
        incr_state$1,
        timing_wheel_length,
        now,
        watch_now,
        advance_clock,
        advance_clock_by,
        at,
        after,
        at_intervals,
        step_function,
        incremental_step_function,
        snapshot],
       [0,
        [0, sexp_of_t$10, create$1, value$0],
        [0,
         sexp_of_t$12,
         create$2,
         watch$0,
         make_stale$0,
         invalidate,
         add_dependency,
         remove_dependency],
        Step_result,
        do_one_step_of_stabilize$0],
       _o_,
       Incremental_Config,
       _n_,
       Private,
       Incremental_For_analyzer];
   runtime.caml_register_global(51, Incremental, cst_Incremental$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJpbmNyZW1lbnRhbC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic2V4cF9vZl90IiwiY29uY2F0IiwiZGVidWciLCJ0YWciLCJhcmcwXzAwMSIsImFyZzFfMDAyIiwic2V4cF9vZl9hIiwicmVzMF8wMDMiLCJyZXMxXzAwNCIsInJlYWxsb2MiLCJ0IiwibGVuIiwiYSIsIm5ld190IiwicmVhbGxvYyQwIiwiZXJyb3Jfc291cmNlXzAxMiIsInJlczBfMDA1IiwicmVzMF8wMDciLCJpbnZhcmlhbnQiLCJ4XzAwOSIsImNyZWF0ZSIsImYiLCJvZl9jb21wYXJlIiwib2ZfZXF1YWwiLCJwb2x5X2VxdWFsIiwibmV2ZXIiLCJhbHdheXMiLCJzaG91bGRfY3V0b2ZmIiwib2xkX3ZhbHVlIiwibmV3X3ZhbHVlIiwiZiQwIiwiZiQxIiwiZXF1YWwiLCJ0MSIsInQyIiwiZjEiLCJmMiIsImYxJDAiLCJmMiQwIiwiZjEkMSIsImYyJDEiLCJwaHlzX2VxdWFsIiwidF9vZl9zZXhwIiwic2V4cF8wMTMiLCJzZXhwX29mX3QkMCIsImVxdWFsJDAiLCJvZl9jdXRvZmYiLCJjIiwidG9fc3RyaW5nIiwiZXJyb3Jfc291cmNlXzAwOSIsImVycm9yX3NvdXJjZV8wMTgiLCJ4XzAwNiIsInhfMDA3IiwiY29tcGFyYXRvciIsImRvdF9vZl9zZXhwIiwieF8wMTAiLCJhdHRyaWJ1dGVzIiwibGFiZWwiLCJzZXhwX29mX2RvdCIsImF0dHJpYnV0ZXNfMDE0IiwibGFiZWxfMDEyIiwiYXJnXzAxNSIsImJuZHNfMDExIiwiYXJnXzAxMyIsImJuZHNfMDExJDAiLCJ0X29mX3NleHAkMCIsInNleHBfMDIwIiwidGFnXzAyMSIsInNleHBfYXJnc18wMjciLCJhcmcwXzAyOCIsInJlczBfMDI5Iiwic2V4cF9hcmdzXzAyMiIsImFyZzBfMDIzIiwicmVzMF8wMjQiLCJzZXhwc18wMzEiLCJuZXckMCIsInByaW9yIiwiYXJnMF8wMzIiLCJyZXMwXzAzMyIsImFyZzBfMDM0IiwicmVzMF8wMzUiLCJuZXdfMDM5IiwicHJpb3JfMDM3IiwiYXJnXzA0MCIsImJuZHNfMDM2IiwiYXJnXzAzOCIsImJuZHNfMDM2JDAiLCJpbmZvIiwiYXBwZW5kIiwiZG90IiwibGFiZWwkMCIsInRvX2RvdCIsImkiLCJwcmlvciQwIiwibmV3JDEiLCJsZWZ0IiwicmlnaHQiLCJlc2NhcGVfZG90X3N0cmluZyIsInMiLCJlc2NhcGVfcmVjb3JkX2xhYmVsIiwib3B0IiwibmFtZSIsInN0aCIsInNoYXBlIiwiY29scyIsInYiLCJrIiwiYXR0cmlidXRlcyQwIiwiciIsIm5leHQiLCJub25lIiwiaXNfbm9uZSIsImlzX3NvbWUiLCJhZGQxIiwiY29tcGFyZSIsImNtcF9hIiwiYV8wMDEiLCJiXzAwMiIsImFfMDAzIiwiYl8wMDQiLCJhXzAwNyIsImFfMDA1IiwiYl8wMDgiLCJiXzAwNiIsIm4iLCJvZl9hXzAwOSIsImFyZzBfMDEwIiwicmVzMF8wMTEiLCJhcmcxXzAxMyIsImFyZzBfMDEyIiwicmVzMF8wMTQiLCJyZXMxXzAxNSIsIm9mX2FfMDE3IiwicHJldmlvdXNfdXBkYXRlX2tpbmRfMDIxIiwiY3JlYXRlZF9hdF8wMjMiLCJhcmdfMDI0IiwiYm5kc18wMTgiLCJhcmdfMDIyIiwiYm5kc18wMTgkMCIsImFyZ18wMjAiLCJibmRzXzAxOCQxIiwiY3JlYXRlZF9hdCIsInJlYWxseV9ydW4iLCJub2RlX3VwZGF0ZSIsInJ1biIsIm5vdyIsImJhY2t0cmFjZV8wMDQiLCJleG5fMDAyIiwiYXJnXzAwNSIsImJuZHNfMDAxIiwiYXJnXzAwMyIsImJuZHNfMDAxJDAiLCJleG4iLCJyZXJhaXNlX3dpdGhfbWVzc2FnZSIsIm1zZyIsImJhY2t0cmFjZSIsInJlcmFpc2UiLCJzZXhwX29mX25vZGUiLCJ4XzAwMyIsImlzX3ZhbGlkIiwiaXNfbmVjZXNzYXJ5IiwidHlwZV9lcXVhbF9pZl9waHlzX3NhbWUiLCJiaW5kIiwieF8wMDQiLCJ3YXRjaCIsInNldF9hdCIsInNldF9zZXRfYXQiLCJ2YWx1ZV9zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24iLCJzZXRfdmFsdWVfc2V0X2R1cmluZ19zdGFiaWxpemEiLCJ2YWx1ZSIsInNldF92YWx1ZSIsIndhdGNoJDAiLCJzZXRfYXQkMCIsInZhbHVlX3NldF9kdXJpbmdfc3RhYmlsaXphdGlvbiQwIiwidmFsdWUkMCIsInNleHBfb2ZfdmFyIiwib2ZfYV8wMDEiLCJ2YWx1ZV8wMDMiLCJzZXRfYXRfMDA3Iiwid2F0Y2hfMDA5IiwiYXJnXzAxMCIsImJuZHNfMDAyIiwiYXJnXzAwOCIsImJuZHNfMDAyJDAiLCJhcmdfMDA2IiwiYm5kc18wMDIkMSIsImFyZ18wMDQiLCJibmRzXzAwMiQyIiwiaW52YXJpYW50X2EiLCJjaGVjayIsIndhdGNoX2Z1biIsInQkMCIsInNldF9hdF9mdW4iLCJ2YWx1ZV9mdW4iLCJ4XzAxMSIsImluY3Jfc3RhdGUiLCJwYXJhbSIsInJlczBfMDE1IiwibGF0ZXN0X3ZhbHVlIiwicG9zIiwicmVzMF8wMDQiLCJyZXMwXzAwNiIsIm51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jbyIsInNldF9udW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bCIsImZvbGRfdmFsdWUiLCJzZXRfZm9sZF92YWx1ZSIsImNoaWxkcmVuIiwiZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyIsImluaXQiLCJtYWluIiwibnVtX2NoYW5nZXNfc2luY2VfbGFzdF9mdWxsX2NvJDAiLCJmb2xkX3ZhbHVlJDAiLCJjaGlsZHJlbiQwIiwiZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyQwIiwiaW5pdCQwIiwibWFpbiQwIiwib2ZfYWNjXzAxMCIsImNoaWxkcmVuXzAyMiIsImZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXNfMCIsImluaXRfMDE0IiwibWFpbl8wMTIiLCJmb2xkX3ZhbHVlXzAyNCIsImFyZ18wMjciLCJhcmdfMDI1IiwiYXJnXzAyMyIsImJuZHNfMDExJDEiLCJhcmdfMDIxIiwiYm5kc18wMTEkMiIsImFyZ18wMTkiLCJibmRzXzAxMSQzIiwiYXJnXzAxNyIsImJuZHNfMDExJDQiLCJibmRzXzAxMSQ1IiwiYm5kc18wMTEkNiIsImludmFyaWFudF9hY2MiLCJmb2xkX3ZhbHVlX2Z1biIsImdvdCIsImV4cGVjdCIsInNleHBpZmllciIsIm1lc3NhZ2UiLCJoZXJlIiwiYV8wMjkiLCJiXzAzMCIsImNoaWxkcmVuX2Z1biIsImNoaWxkIiwiZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlc19mIiwiaW5pdF9mdW4iLCJtYWluX2Z1biIsInhfMDI4IiwidXBkYXRlJDAiLCJmX2ludmVyc2UiLCJ1cGRhdGUiLCJjb21wdXRlIiwicmVzdWx0IiwiZm9yY2VfZnVsbF9jb21wdXRlIiwiY2hpbGRfY2hhbmdlZCIsInhfMDMxIiwiY2hpbGRfaW5kZXgiLCJvbGRfdmFsdWVfb3B0IiwiY2hpbGRfYXRfaW5kZXgiLCJ4XzAwMSIsIm51bGwkMCIsImFsYXJtX3ZhbHVlIiwic2V0X2FsYXJtX3ZhbHVlIiwiYWxhcm0iLCJzZXRfYWxhcm0iLCJhbGFybV92YWx1ZSQwIiwiYWxhcm0kMCIsIm1haW5fMDAzIiwiY2hpbGRfMDA1IiwiZXh0cmFjdGVkX3N0ZXBfZnVuY3Rpb25fZnJvbV9jIiwidmFsdWVfMDA5IiwidXBjb21pbmdfc3RlcHNfMDExIiwiYWxhcm1fMDE3IiwiYWxhcm1fdmFsdWVfMDE5IiwiY2xvY2tfMDIxIiwiYXJnXzAxOCIsImFyZzFfMDE0IiwiYXJnMF8wMTMiLCJyZXMxXzAxNiIsImFyZ18wMTIiLCJibmRzXzAwMiQzIiwiYm5kc18wMDIkNCIsImJuZHNfMDAyJDUiLCJibmRzXzAwMiQ2IiwiYWxhcm1fdmFsdWVfZnVuIiwiYWxhcm1fZnVuIiwieF8wMjMiLCJhZHZhbmNlIiwidG8iLCJzdGVwcyQwIiwiYTEkMCIsImExIiwic3RlcHMiLCJzdGVwczIiLCJhMiIsInN0ZXBfYXQiLCJvZl9hY2NfMDAyIiwiY2hpbGRyZW5fMDA4IiwiaW5pdF8wMDQiLCJhcmdfMDA5IiwiYm5kc18wMDMiLCJhcmdfMDA3IiwiYm5kc18wMDMkMCIsImJuZHNfMDAzJDEiLCJhdF8wMDQiLCJtYWluXzAwMiIsImFsYXJtXzAwNiIsImNsb2NrXzAwOCIsImJuZHNfMDAxJDEiLCJibmRzXzAwMSQyIiwiaW50ZXJ2YWwiLCJpbnRlcnZhbCQwIiwiaW50ZXJ2YWxfMDA2IiwiYmFzZV8wMDQiLCJhbGFybV8wMDgiLCJjbG9ja18wMTAiLCJhcmdfMDExIiwiYm5kc18wMDEkMyIsImludGVydmFsX2Z1biIsImFsbF9ub2Rlc19jcmVhdGVkX29uX3JocyIsInNldF9hbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHMiLCJyaHNfc2NvcGUiLCJzZXRfcmhzX3Njb3BlIiwibGhzX2NoYW5nZSIsImFsbF9ub2Rlc19jcmVhdGVkX29uX3JocyQwIiwicmhzX3Njb3BlJDAiLCJsaHNfY2hhbmdlJDAiLCJvZl9iXzAwMiIsIm1haW5fMDA0IiwibGhzX2NoYW5nZV8wMTAiLCJsaHNfMDA4IiwicmhzXzAxMiIsInJoc19zY29wZV8wMTQiLCJhbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHNfMDE2IiwiYm5kc18wMDMkMiIsImJuZHNfMDAzJDMiLCJibmRzXzAwMyQ0IiwiYm5kc18wMDMkNSIsIml0ZXJfbm9kZXNfY3JlYXRlZF9vbl9yaHMiLCJtYXRjaCIsImludmFyaWFudF9iIiwiYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzX2Z1biIsIm5vZGUiLCJyaHNfc2NvcGVfZnVuIiwibGhzX2NoYW5nZV9mdW4iLCJ4XzAxOCIsInBvcyQwIiwicG9zJDEiLCJzZXhwX29mX2VkZ2UiLCJjaGlsZF8wMDMiLCJpbmRleF8wMDciLCJzZXhwX29mX3BhY2tlZF9lZGdlIiwicmVzMF8wMTAiLCJvZl9hXzAxMSIsImNoaWxkcmVuXzAxNyIsIm51bV9jaGlsZHJlbl8wMTkiLCJmb3JjZV9zdGFsZV8wMjEiLCJudW1faW52YWxpZF9jaGlsZHJlbl8wMjMiLCJ3aWxsX2ZpcmVfYWxsX2NhbGxiYWNrc18wMjUiLCJhcmdfMDI2IiwiYm5kc18wMTIiLCJibmRzXzAxMiQwIiwiYm5kc18wMTIkMSIsImJuZHNfMDEyJDIiLCJibmRzXzAxMiQzIiwiYXJnXzAxNiIsImJuZHNfMDEyJDQiLCJhcmdfMDE0IiwiYm5kc18wMTIkNSIsIm51bV9jaGlsZHJlbiIsInVvcHQiLCJhXzAyNyIsImJfMDI4IiwiaW52YXJpYW50X2Fib3V0X251bV9pbnZhbGlkX2NoIiwibnVtX2ludmFsaWRfY2hpbGRyZW4iLCJzZXhwaWZpZXIkMCIsImV4cGVjdCQwIiwibWVzc2FnZSQwIiwiaGVyZSQwIiwiY29tcGFyYXRvciQwIiwiY291bnRfaW52YWxpZF9jaGlsZHJlbiIsImFfMDMxIiwiYl8wMzIiLCJvbl9vYnNlcnZhYmlsaXR5X2NoYW5nZSIsIm1ha2Vfc3RhbGUiLCJpbmNyX2ludmFsaWRfY2hpbGRyZW4iLCJkZWNyX2ludmFsaWRfY2hpbGRyZW4iLCJhZGRfY2hpbGRfZWRnZSIsInBhY2tlZF9lZGdlIiwibmV3X21heCIsIm5ld19jaGlsZF9pbmRleCIsInN3YXBfY2hpbGRyZW4iLCJjaGlsZF9pbmRleDEiLCJjaGlsZF9pbmRleDIiLCJlZGdlMSIsImxhc3RfY2hpbGRfZWRnZV9leG4iLCJsYXN0X2luZGV4IiwicmVtb3ZlX2xhc3RfY2hpbGRfZWRnZV9leG4iLCJwYWNrZWRfZWRnZV9vcHQiLCJiZWZvcmVfbWFpbl9jb21wdXRhdGlvbiIsIndpbGxfZmlyZV9hbGxfY2FsbGJhY2tzIiwib2JzZXJ2YWJpbGl0eV9jaGFuZ2UiLCJpc19ub3dfb2JzZXJ2YWJsZSIsInJ1bl9lZGdlX2NhbGxiYWNrIiwidG9wIiwiaXNfdG9wIiwiaGVpZ2h0IiwiYWRkX25vZGUiLCJjdXJyZW50X2JyYW5jaCIsInNldF9jdXJyZW50X2JyYW5jaCIsInRlc3RfY2hhbmdlIiwiY3VycmVudF9icmFuY2gkMCIsInRlc3RfY2hhbmdlJDAiLCJ0ZXN0X2NoYW5nZV8wMDciLCJ0ZXN0XzAwNSIsImN1cnJlbnRfYnJhbmNoXzAwOSIsImVsc2VfMDEzIiwidGhlbl8wMTEiLCJjdXJyZW50X2JyYW5jaF9mdW4iLCJ0ZXN0X2NoYW5nZV9mdW4iLCJ4XzAxNSIsImxoc19jaGFuZ2VfMDA3IiwibGhzXzAwNSIsInJoc18wMDkiLCJiZWZvcmUiLCJiZWZvcmUkMCIsImNsb2NrXzAxMSIsInZhbHVlX2F0XzAwOSIsImJlZm9yZV8wMDciLCJhdF8wMDUiLCJiZWZvcmVfZnVuIiwieF8wMTMiLCJhcmcwXzAwMiIsImFyZzBfMDA0IiwiYXJnMF8wMDYiLCJhcmcwXzAwOCIsInJlczBfMDA5IiwicmVzMF8wMTMiLCJhcmcwXzAxNCIsImFyZzBfMDE2IiwicmVzMF8wMTciLCJhcmcwXzAxOCIsInJlczBfMDE5IiwiYXJnMF8wMjAiLCJyZXMwXzAyMSIsImFyZzBfMDIyIiwicmVzMF8wMjMiLCJhcmcwXzAyNCIsInJlczBfMDI1IiwiYXJnMV8wMjciLCJyZXMwXzAyOCIsInJlczFfMDI5IiwiYXJnMF8wMzAiLCJyZXMwXzAzMSIsImFyZzBfMDM2IiwicmVzMF8wMzciLCJhcmcyXzA0MCIsImFyZzFfMDM5IiwicmVzMF8wNDEiLCJyZXMxXzA0MiIsInJlczJfMDQzIiwiYXJnM18wNDciLCJhcmcyXzA0NiIsImFyZzFfMDQ1IiwicmVzMF8wNDgiLCJyZXMxXzA0OSIsInJlczJfMDUwIiwicmVzM18wNTEiLCJhcmc0XzA1NiIsImFyZzNfMDU1IiwiYXJnMl8wNTQiLCJhcmcxXzA1MyIsInJlczBfMDU3IiwicmVzMV8wNTgiLCJyZXMyXzA1OSIsInJlczNfMDYwIiwicmVzNF8wNjEiLCJhcmc1XzA2NyIsImFyZzRfMDY2IiwiYXJnM18wNjUiLCJhcmcyXzA2NCIsImFyZzFfMDYzIiwicmVzMF8wNjgiLCJyZXMxXzA2OSIsInJlczJfMDcwIiwicmVzM18wNzEiLCJyZXM0XzA3MiIsInJlczVfMDczIiwiYXJnNl8wODAiLCJhcmc1XzA3OSIsImFyZzRfMDc4IiwiYXJnM18wNzciLCJhcmcyXzA3NiIsImFyZzFfMDc1IiwicmVzMF8wODEiLCJyZXMxXzA4MiIsInJlczJfMDgzIiwicmVzM18wODQiLCJyZXM0XzA4NSIsInJlczVfMDg2IiwicmVzNl8wODciLCJhcmc3XzA5NSIsImFyZzZfMDk0IiwiYXJnNV8wOTMiLCJhcmc0XzA5MiIsImFyZzNfMDkxIiwiYXJnMl8wOTAiLCJhcmcxXzA4OSIsInJlczBfMDk2IiwicmVzMV8wOTciLCJyZXMyXzA5OCIsInJlczNfMDk5IiwicmVzNF8xMDAiLCJyZXM1XzEwMSIsInJlczZfMTAyIiwicmVzN18xMDMiLCJhcmc4XzExMiIsImFyZzdfMTExIiwiYXJnNl8xMTAiLCJhcmc1XzEwOSIsImFyZzRfMTA4IiwiYXJnM18xMDciLCJhcmcyXzEwNiIsImFyZzFfMTA1IiwicmVzMF8xMTMiLCJyZXMxXzExNCIsInJlczJfMTE1IiwicmVzM18xMTYiLCJyZXM0XzExNyIsInJlczVfMTE4IiwicmVzNl8xMTkiLCJyZXM3XzEyMCIsInJlczhfMTIxIiwiYXJnOV8xMzEiLCJhcmc4XzEzMCIsImFyZzdfMTI5IiwiYXJnNl8xMjgiLCJhcmc1XzEyNyIsImFyZzRfMTI2IiwiYXJnM18xMjUiLCJhcmcyXzEyNCIsImFyZzFfMTIzIiwicmVzMF8xMzIiLCJyZXMxXzEzMyIsInJlczJfMTM0IiwicmVzM18xMzUiLCJyZXM0XzEzNiIsInJlczVfMTM3IiwicmVzNl8xMzgiLCJyZXM3XzEzOSIsInJlczhfMTQwIiwicmVzOV8xNDEiLCJhcmcxMF8xNTIiLCJhcmc5XzE1MSIsImFyZzhfMTUwIiwiYXJnN18xNDkiLCJhcmc2XzE0OCIsImFyZzVfMTQ3IiwiYXJnNF8xNDYiLCJhcmczXzE0NSIsImFyZzJfMTQ0IiwiYXJnMV8xNDMiLCJyZXMwXzE1MyIsInJlczFfMTU0IiwicmVzMl8xNTUiLCJyZXMzXzE1NiIsInJlczRfMTU3IiwicmVzNV8xNTgiLCJyZXM2XzE1OSIsInJlczdfMTYwIiwicmVzOF8xNjEiLCJyZXM5XzE2MiIsInJlczEwXzE2MyIsImFyZzExXzE3NSIsImFyZzEwXzE3NCIsImFyZzlfMTczIiwiYXJnOF8xNzIiLCJhcmc3XzE3MSIsImFyZzZfMTcwIiwiYXJnNV8xNjkiLCJhcmc0XzE2OCIsImFyZzNfMTY3IiwiYXJnMl8xNjYiLCJhcmcxXzE2NSIsInJlczBfMTc2IiwicmVzMV8xNzciLCJyZXMyXzE3OCIsInJlczNfMTc5IiwicmVzNF8xODAiLCJyZXM1XzE4MSIsInJlczZfMTgyIiwicmVzN18xODMiLCJyZXM4XzE4NCIsInJlczlfMTg1IiwicmVzMTBfMTg2IiwicmVzMTFfMTg3IiwiYXJnMTJfMjAwIiwiYXJnMTFfMTk5IiwiYXJnMTBfMTk4IiwiYXJnOV8xOTciLCJhcmc4XzE5NiIsImFyZzdfMTk1IiwiYXJnNl8xOTQiLCJhcmc1XzE5MyIsImFyZzRfMTkyIiwiYXJnM18xOTEiLCJhcmcyXzE5MCIsImFyZzFfMTg5IiwicmVzMF8yMDEiLCJyZXMxXzIwMiIsInJlczJfMjAzIiwicmVzM18yMDQiLCJyZXM0XzIwNSIsInJlczVfMjA2IiwicmVzNl8yMDciLCJyZXM3XzIwOCIsInJlczhfMjA5IiwicmVzOV8yMTAiLCJyZXMxMF8yMTEiLCJyZXMxMV8yMTIiLCJyZXMxMl8yMTMiLCJhcmcxM18yMjciLCJhcmcxMl8yMjYiLCJhcmcxMV8yMjUiLCJhcmcxMF8yMjQiLCJhcmc5XzIyMyIsImFyZzhfMjIyIiwiYXJnN18yMjEiLCJhcmc2XzIyMCIsImFyZzVfMjE5IiwiYXJnNF8yMTgiLCJhcmczXzIxNyIsImFyZzJfMjE2IiwiYXJnMV8yMTUiLCJyZXMwXzIyOCIsInJlczFfMjI5IiwicmVzMl8yMzAiLCJyZXMzXzIzMSIsInJlczRfMjMyIiwicmVzNV8yMzMiLCJyZXM2XzIzNCIsInJlczdfMjM1IiwicmVzOF8yMzYiLCJyZXM5XzIzNyIsInJlczEwXzIzOCIsInJlczExXzIzOSIsInJlczEyXzI0MCIsInJlczEzXzI0MSIsImFyZzE0XzI1NiIsImFyZzEzXzI1NSIsImFyZzEyXzI1NCIsImFyZzExXzI1MyIsImFyZzEwXzI1MiIsImFyZzlfMjUxIiwiYXJnOF8yNTAiLCJhcmc3XzI0OSIsImFyZzZfMjQ4IiwiYXJnNV8yNDciLCJhcmc0XzI0NiIsImFyZzNfMjQ1IiwiYXJnMl8yNDQiLCJhcmcxXzI0MyIsInJlczBfMjU3IiwicmVzMV8yNTgiLCJyZXMyXzI1OSIsInJlczNfMjYwIiwicmVzNF8yNjEiLCJyZXM1XzI2MiIsInJlczZfMjYzIiwicmVzN18yNjQiLCJyZXM4XzI2NSIsInJlczlfMjY2IiwicmVzMTBfMjY3IiwicmVzMTFfMjY4IiwicmVzMTJfMjY5IiwicmVzMTNfMjcwIiwicmVzMTRfMjcxIiwiYXJnMTVfMjg3IiwiYXJnMTRfMjg2IiwiYXJnMTNfMjg1IiwiYXJnMTJfMjg0IiwiYXJnMTFfMjgzIiwiYXJnMTBfMjgyIiwiYXJnOV8yODEiLCJhcmc4XzI4MCIsImFyZzdfMjc5IiwiYXJnNl8yNzgiLCJhcmc1XzI3NyIsImFyZzRfMjc2IiwiYXJnM18yNzUiLCJhcmcyXzI3NCIsImFyZzFfMjczIiwicmVzMF8yODgiLCJyZXMxXzI4OSIsInJlczJfMjkwIiwicmVzM18yOTEiLCJyZXM0XzI5MiIsInJlczVfMjkzIiwicmVzNl8yOTQiLCJyZXM3XzI5NSIsInJlczhfMjk2IiwicmVzOV8yOTciLCJyZXMxMF8yOTgiLCJyZXMxMV8yOTkiLCJyZXMxMl8zMDAiLCJyZXMxM18zMDEiLCJyZXMxNF8zMDIiLCJyZXMxNV8zMDMiLCJhcnJheV9mb2xkIiwiYXQiLCJhdF9pbnRlcnZhbHMiLCJiaW5kJDAiLCJlIiwiZnJlZXplIiwiaWZfdGhlbl9lbHNlIiwiaWZfdGhlbl9lbHNlJDAiLCJqb2luIiwiam9pbiQwIiwic25hcHNob3QiLCJzdGVwX2Z1bmN0aW9uX25vZGUiLCJ1bm9yZGVyZWRfYXJyYXlfZm9sZCIsInZhciQwIiwiaW5pdGlhbF9udW1fY2hpbGRyZW4iLCJiaW5kX3Joc19jaGlsZF9pbmRleCIsImZyZWV6ZV9jaGlsZF9pbmRleCIsImlmX2JyYW5jaF9jaGlsZF9pbmRleCIsImpvaW5fcmhzX2NoaWxkX2luZGV4IiwiaXRlcmlfY2hpbGRyZW4iLCJyaHMiLCJpJDAiLCJ0ZXN0IiwibGhzIiwicmhzJDAiLCJub2RlMCIsImNoaWxkJDAiLCJjaGlsZHJlbiQxIiwiaSQxIiwibm9kZTEiLCJub2RlMCQwIiwibm9kZTIiLCJub2RlMSQwIiwibm9kZTAkMSIsIm5vZGUzIiwibm9kZTIkMCIsIm5vZGUxJDEiLCJub2RlMCQyIiwibm9kZTQiLCJub2RlMyQwIiwibm9kZTIkMSIsIm5vZGUxJDIiLCJub2RlMCQzIiwibm9kZTUiLCJub2RlNCQwIiwibm9kZTMkMSIsIm5vZGUyJDIiLCJub2RlMSQzIiwibm9kZTAkNCIsIm5vZGU2Iiwibm9kZTUkMCIsIm5vZGU0JDEiLCJub2RlMyQyIiwibm9kZTIkMyIsIm5vZGUxJDQiLCJub2RlMCQ1Iiwibm9kZTciLCJub2RlNiQwIiwibm9kZTUkMSIsIm5vZGU0JDIiLCJub2RlMyQzIiwibm9kZTIkNCIsIm5vZGUxJDUiLCJub2RlMCQ2Iiwibm9kZTgiLCJub2RlNyQwIiwibm9kZTYkMSIsIm5vZGU1JDIiLCJub2RlNCQzIiwibm9kZTMkNCIsIm5vZGUyJDUiLCJub2RlMSQ2Iiwibm9kZTAkNyIsIm5vZGU5Iiwibm9kZTgkMCIsIm5vZGU3JDEiLCJub2RlNiQyIiwibm9kZTUkMyIsIm5vZGU0JDQiLCJub2RlMyQ1Iiwibm9kZTIkNiIsIm5vZGUxJDciLCJub2RlMCQ4Iiwibm9kZTEwIiwibm9kZTkkMCIsIm5vZGU4JDEiLCJub2RlNyQyIiwibm9kZTYkMyIsIm5vZGU1JDQiLCJub2RlNCQ1Iiwibm9kZTMkNiIsIm5vZGUyJDciLCJub2RlMSQ4Iiwibm9kZTAkOSIsIm5vZGUxMSIsIm5vZGUxMCQwIiwibm9kZTkkMSIsIm5vZGU4JDIiLCJub2RlNyQzIiwibm9kZTYkNCIsIm5vZGU1JDUiLCJub2RlNCQ2Iiwibm9kZTMkNyIsIm5vZGUyJDgiLCJub2RlMSQ5Iiwibm9kZTAkMTAiLCJub2RlMTIiLCJub2RlMTEkMCIsIm5vZGUxMCQxIiwibm9kZTkkMiIsIm5vZGU4JDMiLCJub2RlNyQ0Iiwibm9kZTYkNSIsIm5vZGU1JDYiLCJub2RlNCQ3Iiwibm9kZTMkOCIsIm5vZGUyJDkiLCJub2RlMSQxMCIsIm5vZGUwJDExIiwibm9kZTEzIiwibm9kZTEyJDAiLCJub2RlMTEkMSIsIm5vZGUxMCQyIiwibm9kZTkkMyIsIm5vZGU4JDQiLCJub2RlNyQ1Iiwibm9kZTYkNiIsIm5vZGU1JDciLCJub2RlNCQ4Iiwibm9kZTMkOSIsIm5vZGUyJDEwIiwibm9kZTEkMTEiLCJub2RlMCQxMiIsIm5vZGUxNCIsIm5vZGUxMyQwIiwibm9kZTEyJDEiLCJub2RlMTEkMiIsIm5vZGUxMCQzIiwibm9kZTkkNCIsIm5vZGU4JDUiLCJub2RlNyQ2Iiwibm9kZTYkNyIsIm5vZGU1JDgiLCJub2RlNCQ5Iiwibm9kZTMkMTAiLCJub2RlMiQxMSIsIm5vZGUxJDEyIiwibm9kZTAkMTMiLCJzbG93X2dldF9jaGlsZCIsImluZGV4IiwiYXJnMV8zMDYiLCJhcmcwXzMwNSIsInJlczBfMzA3IiwicmVzMV8zMDgiLCJwb3MkNCIsInBvcyQzIiwicG9zJDIiLCJteV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW4iLCJzZXRfbXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2EiLCJteV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW4iLCJzZXRfbXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2EiLCJvYnNlcnZlcnMiLCJzZXRfb2JzZXJ2ZXJzIiwic2V0X29sZF92YWx1ZV9vcHQiLCJuZXh0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAiLCJzZXRfbmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWEiLCJoZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCIsInNldF9oZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaCIsIm5leHRfaW5fcmVjb21wdXRlX2hlYXAiLCJzZXRfbmV4dF9pbl9yZWNvbXB1dGVfaGVhcCIsInByZXZfaW5fcmVjb21wdXRlX2hlYXAiLCJzZXRfcHJldl9pbl9yZWNvbXB1dGVfaGVhcCIsImhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcCIsInNldF9oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAiLCJzZXRfaGVpZ2h0IiwibmV4dF9ub2RlX2luX3NhbWVfc2NvcGUiLCJzZXRfbmV4dF9ub2RlX2luX3NhbWVfc2NvcGUiLCJjcmVhdGVkX2luIiwic2V0X2NyZWF0ZWRfaW4iLCJwYXJlbnQwIiwic2V0X3BhcmVudDAiLCJwYXJlbnQxX2FuZF9iZXlvbmQiLCJzZXRfcGFyZW50MV9hbmRfYmV5b25kIiwibnVtX3BhcmVudHMiLCJzZXRfbnVtX3BhcmVudHMiLCJudW1fb25fdXBkYXRlX2hhbmRsZXJzIiwic2V0X251bV9vbl91cGRhdGVfaGFuZGxlcnMiLCJjaGFuZ2VkX2F0Iiwic2V0X2NoYW5nZWRfYXQiLCJjdXRvZmYiLCJzZXRfY3V0b2ZmIiwia2luZCIsInNldF9raW5kIiwidmFsdWVfb3B0Iiwic2V0X3ZhbHVlX29wdCIsInJlY29tcHV0ZWRfYXQiLCJzZXRfcmVjb21wdXRlZF9hdCIsImlkIiwibXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luJDAiLCJteV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW4kMCIsIm9ic2VydmVycyQwIiwib2xkX3ZhbHVlX29wdCQwIiwibmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwJDAiLCJoZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCQwIiwibmV4dF9pbl9yZWNvbXB1dGVfaGVhcCQwIiwicHJldl9pbl9yZWNvbXB1dGVfaGVhcCQwIiwiaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwJDAiLCJoZWlnaHQkMCIsIm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlJDAiLCJjcmVhdGVkX2luJDAiLCJwYXJlbnQwJDAiLCJwYXJlbnQxX2FuZF9iZXlvbmQkMCIsIm51bV9wYXJlbnRzJDAiLCJudW1fb25fdXBkYXRlX2hhbmRsZXJzJDAiLCJjaGFuZ2VkX2F0JDAiLCJjdXRvZmYkMCIsImtpbmQkMCIsInZhbHVlX29wdCQwIiwicmVjb21wdXRlZF9hdCQwIiwiaWQkMCIsInN0YXRlXzAwNSIsImlkXzAwMyIsInJlY29tcHV0ZWRfYXRfMDA3IiwidmFsdWVfb3B0XzAwOSIsImtpbmRfMDExIiwiY3V0b2ZmXzAxMyIsImNoYW5nZWRfYXRfMDE1IiwibnVtX29uX3VwZGF0ZV9oYW5kbGVyc18wMTciLCJudW1fcGFyZW50c18wMTkiLCJwYXJlbnQxX2FuZF9iZXlvbmRfMDIxIiwicGFyZW50MF8wMjMiLCJjcmVhdGVkX2luXzAyNSIsIm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlXzAyNyIsImhlaWdodF8wMjkiLCJoZWlnaHRfaW5fcmVjb21wdXRlX2hlYXBfMDMxIiwicHJldl9pbl9yZWNvbXB1dGVfaGVhcF8wMzMiLCJuZXh0X2luX3JlY29tcHV0ZV9oZWFwXzAzNSIsImhlaWdodF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwXyIsIm5leHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcF8wMyIsIm9sZF92YWx1ZV9vcHRfMDQxIiwib2JzZXJ2ZXJzXzA0MyIsImlzX2luX2hhbmRsZV9hZnRlcl9zdGFiaWxpemF0aSIsIm9uX3VwZGF0ZV9oYW5kbGVyc18wNDciLCJmb3JjZV9uZWNlc3NhcnlfMDUzIiwidXNlcl9pbmZvXzA1NSIsImNyZWF0aW9uX2JhY2t0cmFjZV8wNTciLCJhcmdfMDU4IiwiYXJnXzA1NiIsImFyZ18wNTQiLCJhcmdfMDUyIiwiYXJnXzA1MCIsImFyZ18wNDgiLCJhcmdfMDQ2IiwiYXJnXzA0NCIsImFyZ18wNDIiLCJibmRzXzAwMiQ3IiwiYm5kc18wMDIkOCIsImJuZHNfMDAyJDkiLCJhcmdfMDM2IiwiYm5kc18wMDIkMTAiLCJhcmdfMDM0IiwiYm5kc18wMDIkMTEiLCJhcmdfMDMyIiwiYm5kc18wMDIkMTIiLCJhcmdfMDMwIiwiYm5kc18wMDIkMTMiLCJhcmdfMDI4IiwiYm5kc18wMDIkMTQiLCJibmRzXzAwMiQxNSIsImJuZHNfMDAyJDE2IiwiYm5kc18wMDIkMTciLCJibmRzXzAwMiQxOCIsImJuZHNfMDAyJDE5IiwiYm5kc18wMDIkMjAiLCJibmRzXzAwMiQyMSIsImJuZHNfMDAyJDIyIiwiYm5kc18wMDIkMjMiLCJibmRzXzAwMiQyNCIsImJuZHNfMDAyJDI1IiwiYm5kc18wMDIkMjYiLCJzYW1lIiwidXNlcl9pbmZvIiwib3RoZXIiLCJzZXRfdXNlcl9pbmZvIiwiYXBwZW5kX3VzZXJfaW5mb19ncmFwaHZpeiIsImF0dHJzIiwiZWRnZV9pc19zdGFsZSIsInBhcmVudCIsImlzX3N0YWxlX3dpdGhfcmVzcGVjdF90b19hX2NoaSIsImlzX3N0YWxlIiwiZm9yY2Vfc3RhbGUiLCJmb3JjZV9zdGFsZSQwIiwibmVlZHNfdG9fYmVfY29tcHV0ZWQiLCJpc19pbl9yZWNvbXB1dGVfaGVhcCIsImlzX2luX2FkanVzdF9oZWlnaHRzX2hlYXAiLCJnZXRfcGFyZW50IiwiaXRlcmlfcGFyZW50cyIsImhhc19jaGlsZCIsImhhcyIsImhhc19wYXJlbnQiLCJwYXJlbnQkMCIsInNob3VsZF9iZV9pbnZhbGlkYXRlZCIsImxocyQwIiwiZm9sZF9vYnNlcnZlcnMiLCJhYyIsIm9ic2VydmVyIiwiYV8wNjAiLCJiXzA2MSIsImFfMDcwIiwiYl8wNzEiLCJwYXJlbnRfaW5kZXgiLCJ4IiwiYV8wNjgiLCJiXzA2OSIsIm9ic2VydmVyc19mdW4iLCJzdGF0ZSIsIm9ic2VydmluZyIsIm9sZF92YWx1ZV9vcHRfZnVuIiwibmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwX2Z1IiwibmV4dF9pbl9yZWNvbXB1dGVfaGVhcF9mdW4iLCJwcmV2X2luX3JlY29tcHV0ZV9oZWFwX2Z1biIsInByZXYiLCJoZWlnaHRfaW5fcmVjb21wdXRlX2hlYXBfZnVuIiwiaGVpZ2h0X2Z1biIsIm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlX2Z1biIsImNyZWF0ZWRfaW5fZnVuIiwicGFyZW50MF9mdW4iLCJhXzA2NiIsImJfMDY3IiwicGFyZW50MV9hbmRfYmV5b25kX2Z1biIsImFfMDY0IiwiYl8wNjUiLCJudW1fcGFyZW50c19mdW4iLCJvbl91cGRhdGVfaGFuZGxlcnMiLCJudW1fb25fdXBkYXRlX2hhbmRsZXJzX2Z1biIsImV0YSIsImFfMDYyIiwiYl8wNjMiLCJjaGFuZ2VkX2F0X2Z1biIsImN1dG9mZl9mdW4iLCJraW5kX2Z1biIsInZhbHVlX29wdF9mdW4iLCJyZWNvbXB1dGVkX2F0X2Z1biIsImlkX2Z1biIsInhfMDU5IiwidW5zYWZlX3ZhbHVlIiwidmFsdWVfZXhuIiwieF8wNzIiLCJnZXRfY3V0b2ZmIiwic2V0X2N1dG9mZiQwIiwiaXNfY29uc3QiLCJvbl91cGRhdGUiLCJvbl91cGRhdGVfaGFuZGxlciIsInJ1bl9vbl91cGRhdGVfaGFuZGxlcnMiLCJyZXN0JDAiLCJvbl91cGRhdGVfaGFuZGxlciQwIiwiciQwIiwiciQxIiwicmVzdCIsInNldF9raW5kJDAiLCJtYXhfbnVtX3BhcmVudHMiLCJzZXRfcGFyZW50IiwibGluayIsImFkZF9wYXJlbnQiLCJuZXdfbWF4X251bV9wYXJlbnRzIiwibWF4X251bV9jaGlsZHJlbiIsIm5ld19tYXhfbnVtX2NoaWxkcmVuIiwicmVtb3ZlX3BhcmVudCIsImxhc3RfcGFyZW50X2luZGV4Iiwic3dhcF9jaGlsZHJlbl9leGNlcHRfaW5fa2luZCIsImNoaWxkMSIsImNoaWxkMiIsImluZGV4X29mX3BhcmVudF9pbl9jaGlsZDEiLCJpbmRleF9vZl9wYXJlbnRfaW5fY2hpbGQyIiwieF8wNzMiLCJpbnZhcmlhbnQkMCIsIml0ZXJfZGVzY2VuZGFudHMiLCJ0cyIsInNlZW4iLCJhcHBlbmRfdXNlcl9pbmZvX2dyYXBodml6JDAiLCJmb2xkIiwicGFja2VkX25vZGUiLCJpdGVyIiwibGVuZ3RoIiwieF8wNzQiLCJub2Rlc19ieV9oZWlnaHQiLCJzZXRfbm9kZXNfYnlfaGVpZ2h0IiwiaGVpZ2h0X2xvd2VyX2JvdW5kIiwic2V0X2hlaWdodF9sb3dlcl9ib3VuZCIsInNldF9sZW5ndGgiLCJub2Rlc19ieV9oZWlnaHQkMCIsImhlaWdodF9sb3dlcl9ib3VuZCQwIiwibGVuZ3RoJDAiLCJsZW5ndGhfMDAzIiwiaGVpZ2h0X2xvd2VyX2JvdW5kXzAwNSIsIm5vZGVzX2J5X2hlaWdodF8wMDciLCJtYXhfbm9uZW1wdHlfaW5kZXgiLCJsIiwibWF4X2hlaWdodF9hbGxvd2VkIiwibm9kZXNfYnlfaGVpZ2h0X2Z1biIsImhlaWdodF9sb3dlcl9ib3VuZF9mdW4iLCJsZW5ndGhfZnVuIiwiYWN0dWFsX2xlbmd0aCIsImFfMDA5IiwiYl8wMTAiLCJjcmVhdGVfbm9kZXNfYnlfaGVpZ2h0Iiwic2V0X21heF9oZWlnaHRfYWxsb3dlZCIsInNyYyIsImRzdCIsInNldF9wcmV2IiwidW5saW5rIiwiYWRkIiwicmVtb3ZlIiwieF8wMTIiLCJpbmNyZWFzZV9oZWlnaHQiLCJtaW5faGVpZ2h0IiwicmVtb3ZlX21pbiIsIm5vZGUkMCIsIm5vZGVzIiwibWF4X2hlaWdodF9zZWVuIiwic2V0X21heF9oZWlnaHRfc2VlbiIsIm1heF9oZWlnaHRfc2VlbiQwIiwibWF4X2hlaWdodF9zZWVuXzAwNyIsIm5vZGVzX2J5X2hlaWdodF8wMDkiLCJpc19lbXB0eSIsIm1heF9oZWlnaHRfc2Vlbl9mdW4iLCJjcmVhdGUkMCIsInZfMDExIiwiYXJnMV8wMTkiLCJ2XzAxNiIsInJlczBfMDIwIiwidl8wMTciLCJyZXMxXzAyMSIsImVuc3VyZV9oZWlnaHRfcmVxdWlyZW1lbnQiLCJvcmlnaW5hbF9jaGlsZCIsIm9yaWdpbmFsX3BhcmVudCIsImFyZzFfMDI1Iiwidl8wMjIiLCJyZXMwXzAyNiIsInZfMDIzIiwicmVzMV8wMjciLCJhZGp1c3RfaGVpZ2h0cyIsInJlY29tcHV0ZV9oZWFwIiwibm9kZV9vbl9yaHMiLCJhY3Rpb24iLCJhY3Rpb24kMCIsImFjdGlvbl8wMTAiLCJuZXh0X2ZpcmVkXzAxMiIsImJuZHNfMDA5IiwicmVzMF8wMDIiLCJhcmcwXzAwMyIsImFyZzBfMDA1IiwiYXJnMF8wMDciLCJyZXMwXzAwOCIsImJuZHNfMDA5JDAiLCJhY3Rpb25fZnVuIiwibmV4dF9pbl9hbGwiLCJzZXRfcHJldl9pbl9hbGwiLCJuZXh0X2luX29ic2VydmluZyIsInNldF9uZXh0X2luX29ic2VydmluZyIsInByZXZfaW5fb2JzZXJ2aW5nIiwic2V0X3ByZXZfaW5fb2JzZXJ2aW5nIiwibmV4dF9pbl9hbGwkMCIsInNldF9uZXh0X2luX2FsbCIsInByZXZfaW5fYWxsIiwic2V0X3ByZXZfaW5fYWxsJDAiLCJzZXRfb25fdXBkYXRlX2hhbmRsZXJzIiwibmV4dF9pbl9vYnNlcnZpbmckMCIsInByZXZfaW5fb2JzZXJ2aW5nJDAiLCJuZXh0X2luX2FsbCQxIiwicHJldl9pbl9hbGwkMCIsIm9uX3VwZGF0ZV9oYW5kbGVycyQwIiwib2JzZXJ2aW5nJDAiLCJzZXhwX29mX2ludGVybmFsX29ic2VydmVyIiwib2ZfYV8wMDIiLCJzdGF0ZV8wMDQiLCJvYnNlcnZpbmdfMDA2Iiwib25fdXBkYXRlX2hhbmRsZXJzXzAwOCIsInByZXZfaW5fYWxsXzAxMCIsIm5leHRfaW5fYWxsXzAxMiIsInByZXZfaW5fb2JzZXJ2aW5nXzAxNCIsIm5leHRfaW5fb2JzZXJ2aW5nXzAxNiIsInVzZV9pc19hbGxvd2VkIiwibmV4dF9pbl9vYnNlcnZpbmdfZnVuIiwicHJldl9pbl9vYnNlcnZpbmdfZnVuIiwibmV4dF9pbl9hbGxfZnVuIiwicHJldl9pbl9hbGxfZnVuIiwib25fdXBkYXRlX2hhbmRsZXJzX2Z1biIsIm9ic2VydmluZ19mdW4iLCJ4XzAyMCIsInhfMDIyIiwieF8wMjEiLCJvbl91cGRhdGVfZXhuIiwieF8wMjQiLCJwcmV2JDAiLCJuZXh0JDAiLCJ4XzAyNSIsInhfMDAyIiwiZXJyb3Jfc291cmNlXzA3OSIsInNleHBfb2Zfc3RhdHVzIiwiYXJnMV8wMDQiLCJyZXMxXzAwNiIsImV4cGVydF9ub2Rlc19jcmVhdGVkX2J5X2N1cnJlbiIsInNldF9leHBlcnRfbm9kZXNfY3JlYXRlZF9ieV9jdSIsImN1cnJlbnRseV9ydW5uaW5nX25vZGUiLCJzZXRfY3VycmVudGx5X3J1bm5pbmdfbm9kZSIsImV4cGVydF9ub2Rlc19jcmVhdGVkX2J5X2N1cnJlbiQwIiwiY3VycmVudGx5X3J1bm5pbmdfbm9kZSQwIiwiY3VycmVudGx5X3J1bm5pbmdfbm9kZV9mdW4iLCJjdXJyZW50bHlfcnVubmluZ19ub2RlXzAwOCIsImJuZHNfMDA3IiwiYm5kc18wMDckMCIsInNleHBfb2ZfdCQxIiwibnVtX3Zhcl9zZXRzIiwic2V0X251bV92YXJfc2V0cyIsIm51bV9ub2Rlc19yZWNvbXB1dGVkX2RpcmVjdGx5XyIsInNldF9udW1fbm9kZXNfcmVjb21wdXRlZF9kaXJlYyIsIm51bV9ub2Rlc19yZWNvbXB1dGVkX2RpcmVjdGx5XyQwIiwic2V0X251bV9ub2Rlc19yZWNvbXB1dGVkX2RpcmVjJDAiLCJudW1fbm9kZXNfcmVjb21wdXRlZCIsInNldF9udW1fbm9kZXNfcmVjb21wdXRlZCIsIm51bV9ub2Rlc19pbnZhbGlkYXRlZCIsInNldF9udW1fbm9kZXNfaW52YWxpZGF0ZWQiLCJudW1fbm9kZXNfY3JlYXRlZCIsInNldF9udW1fbm9kZXNfY3JlYXRlZCIsIm51bV9ub2Rlc19jaGFuZ2VkIiwic2V0X251bV9ub2Rlc19jaGFuZ2VkIiwibnVtX25vZGVzX2JlY2FtZV91bm5lY2Vzc2FyeSIsInNldF9udW1fbm9kZXNfYmVjYW1lX3VubmVjZXNzYSIsIm51bV9ub2Rlc19iZWNhbWVfbmVjZXNzYXJ5Iiwic2V0X251bV9ub2Rlc19iZWNhbWVfbmVjZXNzYXJ5Iiwia2VlcF9ub2RlX2NyZWF0aW9uX2JhY2t0cmFjZSIsInNldF9rZWVwX25vZGVfY3JlYXRpb25fYmFja3RyYSIsIndlYWtfaGFzaHRibHMiLCJvbmx5X2luX2RlYnVnIiwic2V0X29ubHlfaW5fZGVidWciLCJoYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiIsInNldF9kdXJpbmdfc3RhYmlsaXphdGlvbiIsImRpc2FsbG93ZWRfb2JzZXJ2ZXJzIiwibmV3X29ic2VydmVycyIsImZpbmFsaXplZF9vYnNlcnZlcnMiLCJhbGxfb2JzZXJ2ZXJzIiwic2V0X2FsbF9vYnNlcnZlcnMiLCJudW1fYWN0aXZlX29ic2VydmVycyIsInNldF9udW1fYWN0aXZlX29ic2VydmVycyIsInByb3BhZ2F0ZV9pbnZhbGlkaXR5IiwiYWRqdXN0X2hlaWdodHNfaGVhcCIsImN1cnJlbnRfc2NvcGUiLCJzZXRfY3VycmVudF9zY29wZSIsInN0YWJpbGl6YXRpb25fbnVtIiwic2V0X3N0YWJpbGl6YXRpb25fbnVtIiwiYmluZF9saHNfY2hhbmdlX3Nob3VsZF9pbnZhbGlkIiwic3RhdHVzIiwic2V0X3N0YXR1cyIsIm51bV92YXJfc2V0cyQwIiwibnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWN0bHlfJDEiLCJudW1fbm9kZXNfcmVjb21wdXRlZF9kaXJlY3RseV8kMiIsIm51bV9ub2Rlc19yZWNvbXB1dGVkJDAiLCJudW1fbm9kZXNfaW52YWxpZGF0ZWQkMCIsIm51bV9ub2Rlc19jcmVhdGVkJDAiLCJudW1fbm9kZXNfY2hhbmdlZCQwIiwibnVtX25vZGVzX2JlY2FtZV91bm5lY2Vzc2FyeSQwIiwibnVtX25vZGVzX2JlY2FtZV9uZWNlc3NhcnkkMCIsImtlZXBfbm9kZV9jcmVhdGlvbl9iYWNrdHJhY2UkMCIsIndlYWtfaGFzaHRibHMkMCIsIm9ubHlfaW5fZGVidWckMCIsInJ1bl9vbl91cGRhdGVfaGFuZGxlcnMkMCIsImhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uJDAiLCJzZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24kMCIsImRpc2FsbG93ZWRfb2JzZXJ2ZXJzJDAiLCJuZXdfb2JzZXJ2ZXJzJDAiLCJmaW5hbGl6ZWRfb2JzZXJ2ZXJzJDAiLCJhbGxfb2JzZXJ2ZXJzJDAiLCJudW1fYWN0aXZlX29ic2VydmVycyQwIiwicHJvcGFnYXRlX2ludmFsaWRpdHkkMCIsImFkanVzdF9oZWlnaHRzX2hlYXAkMCIsInJlY29tcHV0ZV9oZWFwJDAiLCJjdXJyZW50X3Njb3BlJDAiLCJzdGFiaWxpemF0aW9uX251bSQwIiwiYmluZF9saHNfY2hhbmdlX3Nob3VsZF9pbnZhbGlkJDAiLCJzdGF0dXMkMCIsIml0ZXIkMCIsInN0YXR1c19mdW4iLCJzdGFiaWxpemF0aW9uX251bV9mdW4iLCJjdXJyZW50X3Njb3BlX2Z1biIsInJlY29tcHV0ZV9oZWFwX2Z1biIsImFkanVzdF9oZWlnaHRzX2hlYXBfZnVuIiwicHJvcGFnYXRlX2ludmFsaWRpdHlfZnVuIiwibnVtX2FjdGl2ZV9vYnNlcnZlcnNfZnVuIiwiYWxsX29ic2VydmVyc19mdW4iLCJmaW5hbGl6ZWRfb2JzZXJ2ZXJzX2Z1biIsIm5ld19vYnNlcnZlcnNfZnVuIiwiZGlzYWxsb3dlZF9vYnNlcnZlcnNfZnVuIiwic2V0X2R1cmluZ19zdGFiaWxpemF0aW9uX2Z1biIsImhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uX2Z1biIsInJ1bl9vbl91cGRhdGVfaGFuZGxlcnNfZnVuIiwib25seV9pbl9kZWJ1Z19mdW4iLCJ3ZWFrX2hhc2h0YmxzX2Z1biIsImtlZXBfbm9kZV9jcmVhdGlvbl9iYWNrdHJhY2VfZiIsIm51bV9ub2Rlc19iZWNhbWVfbmVjZXNzYXJ5X2Z1biIsIm51bV9ub2Rlc19iZWNhbWVfdW5uZWNlc3NhcnlfZiIsIm51bV9ub2Rlc19jaGFuZ2VkX2Z1biIsIm51bV9ub2Rlc19jcmVhdGVkX2Z1biIsIm51bV9ub2Rlc19pbnZhbGlkYXRlZF9mdW4iLCJudW1fbm9kZXNfcmVjb21wdXRlZF9mdW4iLCJudW1fdmFyX3NldHNfZnVuIiwic2V4cF9vZl90JDIiLCJzdGF0dXNfMDE1Iiwic3RhYmlsaXphdGlvbl9udW1fMDE5IiwiY3VycmVudF9zY29wZV8wMjEiLCJwcm9wYWdhdGVfaW52YWxpZGl0eV8wMjciLCJhZGp1c3RfaGVpZ2h0c19oZWFwXzAyNSIsInJlY29tcHV0ZV9oZWFwXzAyMyIsIm51bV9hY3RpdmVfb2JzZXJ2ZXJzXzAyOSIsImFsbF9vYnNlcnZlcnNfMDMxIiwicnVuX29uX3VwZGF0ZV9oYW5kbGVyc18wNDMiLCJoYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbl8wNDEiLCJzZXRfZHVyaW5nX3N0YWJpbGl6YXRpb25fMDM5IiwiZGlzYWxsb3dlZF9vYnNlcnZlcnNfMDM3IiwibmV3X29ic2VydmVyc18wMzUiLCJmaW5hbGl6ZWRfb2JzZXJ2ZXJzXzAzMyIsIm9ubHlfaW5fZGVidWdfMDQ1Iiwid2Vha19oYXNodGJsc18wNDciLCJrZWVwX25vZGVfY3JlYXRpb25fYmFja3RyYWNlXzAiLCJudW1fbm9kZXNfYmVjYW1lX25lY2Vzc2FyeV8wNTEiLCJudW1fbm9kZXNfYmVjYW1lX3VubmVjZXNzYXJ5XzAiLCJudW1fbm9kZXNfY2hhbmdlZF8wNTUiLCJudW1fbm9kZXNfY3JlYXRlZF8wNTciLCJudW1fbm9kZXNfaW52YWxpZGF0ZWRfMDU5IiwibnVtX25vZGVzX3JlY29tcHV0ZWRfMDYxIiwibnVtX3Zhcl9zZXRzXzA2NyIsImFyZ18wNjgiLCJibmRzXzAxNCIsImFyZ18wNjYiLCJibmRzXzAxNCQwIiwiYXJnXzA2NCIsImJuZHNfMDE0JDEiLCJhcmdfMDYyIiwiYm5kc18wMTQkMiIsImFyZ18wNjAiLCJibmRzXzAxNCQzIiwiYm5kc18wMTQkNCIsImJuZHNfMDE0JDUiLCJibmRzXzAxNCQ2IiwiYm5kc18wMTQkNyIsImJuZHNfMDE0JDgiLCJibmRzXzAxNCQ5IiwiYm5kc18wMTQkMTAiLCJibmRzXzAxNCQxMSIsImJuZHNfMDE0JDEyIiwiYm5kc18wMTQkMTMiLCJibmRzXzAxNCQxNCIsImJuZHNfMDE0JDE1IiwiYm5kc18wMTQkMTYiLCJibmRzXzAxNCQxNyIsImJuZHNfMDE0JDE4IiwiYm5kc18wMTQkMTkiLCJibmRzXzAxNCQyMCIsImJuZHNfMDE0JDIxIiwiYm5kc18wMTQkMjIiLCJibmRzXzAxNCQyMyIsImJuZHNfMDE0JDI0IiwiYm5kc18wMTQkMjUiLCJmaXJlZF9hbGFybV92YWx1ZXMiLCJzZXRfZmlyZWRfYWxhcm1fdmFsdWVzIiwiaGFuZGxlX2ZpcmVkIiwidGltaW5nX3doZWVsIiwiZmlyZWRfYWxhcm1fdmFsdWVzJDAiLCJoYW5kbGVfZmlyZWQkMCIsIm5vdyQwIiwidGltaW5nX3doZWVsJDAiLCJpdGVyJDEiLCJ0aW1pbmdfd2hlZWxfZnVuIiwibm93X2Z1biIsImhhbmRsZV9maXJlZF9mdW4iLCJmaXJlZF9hbGFybV92YWx1ZXNfZnVuIiwic2V4cF9vZl90JDMiLCJub3dfMDcyIiwidGltaW5nX3doZWVsXzA3MCIsImZpcmVkX2FsYXJtX3ZhbHVlc18wNzYiLCJhcmdfMDc3IiwiYm5kc18wNjkiLCJhcmdfMDc1IiwiYm5kc18wNjkkMCIsImFyZ18wNzMiLCJibmRzXzA2OSQxIiwiYXJnXzA3MSIsImJuZHNfMDY5JDIiLCJpbnZhcmlhbnQkMSIsIm5vdyQxIiwiY2xvY2siLCJ0aW1pbmdfd2hlZWxfbGVuZ3RoIiwibnVtX3N0YWJpbGl6ZXMiLCJpdGVyX29ic2VydmVycyIsImRpcmVjdGx5X29ic2VydmVkIiwiaXRlcl9vYnNlcnZlcl9kZXNjZW5kYW50cyIsInhfMDg1IiwicGVyY2VudGFnZV9vZl9ub2Rlc19ieV9udW1fcGFyIiwic2V4cF8wODQiLCJhcmcxXzA4MSIsImFyZzBfMDgwIiwicmVzMF8wODIiLCJyZXMxXzA4MyIsInNleHBfb2ZfdCQ0IiwibWF4X251bV9wYXJlbnRzXzA4NyIsImJuZHNfMDg2IiwiYXJnMV8wOTIiLCJhcmcwXzA5MSIsInJlczBfMDkzIiwicmVzMV8wOTQiLCJhcmdfMDkwIiwiYm5kc18wODYkMCIsImFyZ18wODgiLCJibmRzXzA4NiQxIiwic3RhdHMiLCJudW1fbmVjZXNzYXJ5X25vZGVzIiwibWF4X251bV9wYXJlbnRzJDAiLCJudW1fbm9kZXNfYnlfbnVtX3BhcmVudHMiLCJudW1fbm9kZXMiLCJhbV9zdGFiaWxpemluZyIsInJhaXNlZF9leG4iLCJpbnZhcmlhbnQkMiIsImludGVybmFsX29ic2VydmVyIiwieF8wOTUiLCJwYWNrZWQiLCJlbnN1cmVfbm90X3N0YWJpbGl6aW5nIiwiYWxsb3dfaW5fdXBkYXRlX2hhbmRsZXIiLCJiYWNrdHJhY2UkMCIsImhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uJDEiLCJyZW1vdmVfY2hpbGRyZW4iLCJyZW1vdmVfY2hpbGQiLCJjaGVja19pZl91bm5lY2Vzc2FyeSIsImJlY2FtZV91bm5lY2Vzc2FyeSIsInAiLCJ1IiwicmVtb3ZlX2FsYXJtIiwiaW52YWxpZGF0ZV9ub2RlIiwiaW52YWxpZGF0ZV9ub2Rlc19jcmVhdGVkX29uX3JoIiwicmVzY29wZV9ub2Rlc19jcmVhdGVkX29uX3JocyIsImZpcnN0X25vZGVfb25fcmhzIiwibmV3X3Njb3BlIiwicHJvcGFnYXRlX2ludmFsaWRpdHkkMSIsImV4cGVydCIsImFkZF9wYXJlbnRfd2l0aG91dF9hZGp1c3RpbmdfaCIsIndhc19uZWNlc3NhcnkiLCJ4XzA5NiIsImJlY2FtZV9uZWNlc3NhcnkiLCJydW5fd2l0aF9zY29wZSIsInNjb3BlIiwic2F2ZWQiLCJleG4kMCIsIndpdGhpbl9zY29wZSIsImNoYW5nZV9jaGlsZCIsIm9sZF9jaGlsZCIsIm5ld19jaGlsZCIsIm9sZF9jaGlsZCQwIiwiYWRkX2FsYXJtIiwicmVjb21wdXRlIiwibWF5YmVfY2hhbmdlX3ZhbHVlIiwib2xkX3JocyIsIm9sZF9hbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHMiLCJjb3B5X2NoaWxkIiwib25seV9mcmVlemVfd2hlbiIsImVsc2UkMCIsInRoZW4iLCJkZXNpcmVkX2JyYW5jaCIsIm1haW4kMSIsIm9sZF9yaHMkMCIsInJocyQxIiwicmhzJDIiLCJuMSIsImNsb2NrJDAiLCJhdCQwIiwiY2xvY2skMSIsImNoaWxkJDEiLCJzdGVwX2Z1bmN0aW9uIiwic3RlcF9mdW5jdGlvbl92YWx1ZSIsImF0JDEiLCJuMiIsIm4xJDAiLCJuMyIsIm4yJDAiLCJuMSQxIiwiZiQyIiwibjQiLCJuMyQwIiwibjIkMSIsIm4xJDIiLCJmJDMiLCJuNSIsIm40JDAiLCJuMyQxIiwibjIkMiIsIm4xJDMiLCJmJDQiLCJuNiIsIm41JDAiLCJuNCQxIiwibjMkMiIsIm4yJDMiLCJuMSQ0IiwiZiQ1IiwibjciLCJuNiQwIiwibjUkMSIsIm40JDIiLCJuMyQzIiwibjIkNCIsIm4xJDUiLCJmJDYiLCJuOCIsIm43JDAiLCJuNiQxIiwibjUkMiIsIm40JDMiLCJuMyQ0IiwibjIkNSIsIm4xJDYiLCJmJDciLCJuOSIsIm44JDAiLCJuNyQxIiwibjYkMiIsIm41JDMiLCJuNCQ0IiwibjMkNSIsIm4yJDYiLCJuMSQ3IiwiZiQ4IiwibjEwIiwibjkkMCIsIm44JDEiLCJuNyQyIiwibjYkMyIsIm41JDQiLCJuNCQ1IiwibjMkNiIsIm4yJDciLCJuMSQ4IiwiZiQ5IiwibjExIiwibjEwJDAiLCJuOSQxIiwibjgkMiIsIm43JDMiLCJuNiQ0IiwibjUkNSIsIm40JDYiLCJuMyQ3IiwibjIkOCIsIm4xJDkiLCJmJDEwIiwibjEyIiwibjExJDAiLCJuMTAkMSIsIm45JDIiLCJuOCQzIiwibjckNCIsIm42JDUiLCJuNSQ2IiwibjQkNyIsIm4zJDgiLCJuMiQ5IiwibjEkMTAiLCJmJDExIiwibjEzIiwibjEyJDAiLCJuMTEkMSIsIm4xMCQyIiwibjkkMyIsIm44JDQiLCJuNyQ1IiwibjYkNiIsIm41JDciLCJuNCQ4IiwibjMkOSIsIm4yJDEwIiwibjEkMTEiLCJmJDEyIiwibjE0IiwibjEzJDAiLCJuMTIkMSIsIm4xMSQyIiwibjEwJDMiLCJuOSQ0IiwibjgkNSIsIm43JDYiLCJuNiQ3IiwibjUkOCIsIm40JDkiLCJuMyQxMCIsIm4yJDExIiwibjEkMTIiLCJmJDEzIiwibjE1IiwibjE0JDAiLCJuMTMkMSIsIm4xMiQyIiwibjExJDMiLCJuMTAkNCIsIm45JDUiLCJuOCQ2IiwibjckNyIsIm42JDgiLCJuNSQ5IiwibjQkMTAiLCJuMyQxMSIsIm4yJDEyIiwibjEkMTMiLCJmJDE0IiwiY2hpbGRfaW5kZXgkMCIsInUkMCIsImNhbl9yZWNvbXB1dGVfbm93IiwiYiIsImoiLCJyZWNvbXB1dGVfZmlyc3Rfbm9kZV90aGF0X2lzX24iLCJ4XzA5NyIsInVubGlua19kaXNhbGxvd2VkX29ic2VydmVycyIsImRpc2FsbG93X2Z1dHVyZV91c2UiLCJkaXNhbGxvd19maW5hbGl6ZWRfb2JzZXJ2ZXJzIiwib2JzZXJ2ZXJfZmluYWxpemVyIiwiY3JlYXRlX29ic2VydmVyIiwic2hvdWxkX2ZpbmFsaXplIiwiYWRkX25ld19vYnNlcnZlcnMiLCJvbGRfYWxsX29ic2VydmVycyIsIm9sZF9vYnNlcnZlcnMiLCJvYnNlcnZlcl92YWx1ZV9leG4iLCJ4XzA5OCIsIm9ic2VydmVyX3ZhbHVlIiwibm9kZV9vbl91cGRhdGUiLCJvYnNlcnZlcl9vbl91cGRhdGVfZXhuIiwic2V0X3Zhcl93aGlsZV9ub3Rfc3RhYmlsaXppbmciLCJzZXRfdmFyIiwicmVjbGFpbV9zcGFjZV9pbl93ZWFrX2hhc2h0YmxzIiwid2Vha19oYXNodGJsIiwic3RhYmlsaXplX3N0YXJ0Iiwic3RhYmlsaXplX2VuZCIsIm1hdGNoJDAiLCJub2RlX3VwZGF0ZSQwIiwicmFpc2VfZHVyaW5nX3N0YWJpbGl6YXRpb24iLCJyYWlzZWQiLCJzdGFiaWxpemUiLCJzZXhwX29mX3QkNSIsImRvX29uZV9zdGVwX29mX3N0YWJpbGl6ZSIsImNyZWF0ZV9ub2RlX2luIiwiY3JlYXRlX25vZGUiLCJjcmVhdGVfbm9kZV90b3AiLCJjcmVhdGVfdmFyIiwidXNlX2N1cnJlbnRfc2NvcGUiLCJjb25zdCQwIiwibWFwIiwibWFwMiIsImJvdGgiLCJtYXAzIiwibWFwNCIsIm1hcDUiLCJtYXA2IiwibWFwNyIsIm1hcDgiLCJtYXA5IiwibWFwMTAiLCJtYXAxMSIsIm1hcDEyIiwibWFwMTMiLCJtYXAxNCIsIm1hcDE1IiwicHJlc2VydmVfY3V0b2ZmIiwiaW5wdXQiLCJvdXRwdXQiLCJkZXBlbmRfb24iLCJuZWNlc3NhcnlfaWZfYWxpdmUiLCJiaW5kMiIsInYyIiwidjEiLCJiaW5kMyIsInYzIiwiYmluZDQiLCJ2NCIsImlmJDAiLCJsYXp5X2Zyb21fZnVuIiwiZGVmYXVsdF9oYXNoX3RhYmxlX2luaXRpYWxfc2l6IiwibWVtb2l6ZV9mdW5fYnlfa2V5IiwiaGFzaGFibGUiLCJwcm9qZWN0X2tleSIsImluaXRpYWxfc2l6ZSIsInRhYmxlIiwia2V5IiwiYiQwIiwiYWxsIiwib3B0X3Vub3JkZXJlZF9hcnJheV9mb2xkIiwibnVtX2ludmFsaWQiLCJhY2N1bSIsIngkMCIsImZfaW52ZXJzZSQwIiwiYXRfbGVhc3Rfa19vZiIsImJvb2xfdG9faW50IiwibnVtX3RydWUiLCJleGlzdHMiLCJmb3JfYWxsIiwic3VtIiwiemVybyIsInN1YiIsIm9wdF9zdW0iLCJzdW1faW50Iiwic3VtX2Zsb2F0Iiwic2V0X2ZyZWV6ZSIsInRpbWUiLCJhZnRlciIsInNwYW4iLCJuZXh0X2ludGVydmFsX2FsYXJtX3N0cmljdCIsImJhc2UiLCJ2YWx1ZV9hdCIsImluY3JlbWVudGFsX3N0ZXBfZnVuY3Rpb24iLCJhZHZhbmNlX2Nsb2NrIiwibWFpbiQyIiwiY3JlYXRlX2Nsb2NrIiwidGltaW5nX3doZWVsX2NvbmZpZyIsInN0YXJ0IiwiQ29uZmlnIiwid2Vha19tZW1vaXplX2Z1bl9ieV9rZXkiLCJleHBlcnRfa2luZF9vZl9ub2RlIiwieF8wOTkiLCJjcmVhdGUkMSIsImN1cnJlbnRseV9ydW5uaW5nX25vZGVfZXhuIiwiY3VycmVudCIsImFzc2VydF9jdXJyZW50bHlfcnVubmluZ19ub2RlXyIsInhfMTAxIiwieF8xMDAiLCJhc3NlcnRfY3VycmVudGx5X3J1bm5pbmdfbm9kZV8kMCIsInhfMTAzIiwieF8xMDIiLCJtYWtlX3N0YWxlJDAiLCJlX29wdCIsImludmFsaWRhdGUiLCJhZGRfZGVwZW5kZW5jeSIsImRlcCIsInJlbW92ZV9kZXBlbmRlbmN5IiwiZWRnZSIsImVkZ2VfaW5kZXgiLCJsYXN0X2VkZ2UiLCJsYXN0X2VkZ2VfaW5kZXgiLCJvbl9jaGFuZ2UiLCJyZWR1Y2UiLCJyZWR1Y2VyIiwiZXJyb3Jfc291cmNlXzAwMyIsInNleHBfMDA1Iiwic2V4cHNfMDEwIiwic2V4cHNfMDA2Iiwic2V4cHNfMDA4IiwiYXRfMDEyIiwiaW50ZXJ2YWxfMDE3IiwiYmFzZV8wMTUiLCJhdF8wMjAiLCJibmRzXzAxOSIsImRlZmF1bHQkMCIsIm5vZGVfaWQiLCJ0cmF2ZXJzZSIsInBhY2tlZF9saXN0IiwibWFwX29mX2l0ZXIiLCJpdGVyYXRvciIsIm91dCIsImJpbmRfY2hpbGRyZW4iLCJzYXZlX2RvdCIsImVtaXRfYmluZF9lZGdlcyIsIm5vZGVfbmFtZSIsImJpbmRfZWRnZXMiLCJ1c2VyX2luZm8kMCIsImNoaWxkX2lkIiwiYmluZF9jaGlsZF9pZCIsInNhdmVfZG90X3RvX2ZpbGUiLCJmaWxlIiwibGV2ZWxfYml0cyIsImNyZWF0ZV9pbnRlcm5hbCIsImRlZmF1bHRfbWF4X2hlaWdodF9hbGxvd2VkIiwic2V4cF9vZl9zdGF0ZV93aXRuZXNzIiwid2l0aGluIiwicGFjayIsInJldHVybiQwIiwibWFwMiQwIiwibWFwMyQwIiwibWFwNCQwIiwibWFwNSQwIiwibWFwNiQwIiwibWFwNyQwIiwibWFwOCQwIiwibWFwOSQwIiwibWFwMTAkMCIsIm1hcDExJDAiLCJtYXAxMiQwIiwibWFwMTMkMCIsIm1hcDE0JDAiLCJtYXAxNSQwIiwiYmluZDIkMCIsImJpbmQzJDAiLCJiaW5kNCQwIiwic3ltYm9sX21hcCIsInN5bWJvbF9iaW5kIiwic3ltYm9sX21hcCQwIiwic3ltYm9sX2JpbmQkMCIsImxhenlfZnJvbV9mdW4kMCIsIm1lbW9pemVfZnVuIiwiYXJyYXlfZm9sZCQwIiwicmVkdWNlX2JhbGFuY2VkIiwicmVwbGFjZSIsInhfMDE3IiwiZGlzYWxsb3dfZnV0dXJlX3VzZSQwIiwiaW5jcl9zdGF0ZSQxIiwiYWxhcm1fcHJlY2lzaW9uIiwiZGVmYXVsdF90aW1pbmdfd2hlZWxfY29uZmlnIiwic3RhcnQkMCIsImFsYXJtX3ByZWNpc2lvbiQwIiwid2F0Y2hfbm93IiwiYWR2YW5jZV9jbG9ja19ieSIsImZyZWV6ZSQwIiwid2hlbiIsImRlcGVuZF9vbiQwIiwic3RhYmlsaXplJDAiLCJhbV9zdGFiaWxpemluZyQwIiwic2F2ZV9kb3QkMCIsInNhdmVfZG90X3RvX2ZpbGUkMCIsInNleHBfb2ZfdCQ2Iiwib2ZfYV8wMTgiLCJhcmcwXzAxOSIsImFyZzBfMDIxIiwicmVzMF8wMjIiLCJub2RlX3ZhbHVlIiwic2V4cF9vZl90JDciLCJib3RoJDAiLCJ4MSIsIngyIiwibWFwMiQxIiwibWFwMyQxIiwibWFwNCQxIiwibWFwNSQxIiwibWFwNiQxIiwibWFwNyQxIiwibWFwOCQxIiwibWFwOSQxIiwibWFwMTAkMSIsIm1hcDExJDEiLCJtYXAxMiQxIiwibWFwMTMkMSIsIm1hcDE0JDEiLCJtYXAxNSQxIiwiYmluZDIkMSIsImJpbmQzJDEiLCJiaW5kNCQxIiwid2Vha19tZW1vaXplX2Z1biIsImNyZWF0ZSQyIiwiZG9fb25lX3N0ZXBfb2Zfc3RhYmlsaXplJDAiLCJyZXR1cm4kMSIsIndpdGhpbiQwIiwiY3JlYXRlJDMiLCJjb25zdCQxIiwicmV0dXJuJDIiLCJhbGwkMCIsImV4aXN0cyQwIiwiZm9yX2FsbCQwIiwibWVtb2l6ZV9mdW5fYnlfa2V5JDAiLCJtZW1vaXplX2Z1biQwIiwiYXJyYXlfZm9sZCQxIiwicmVkdWNlX2JhbGFuY2VkJDAiLCJ1bm9yZGVyZWRfYXJyYXlfZm9sZCQwIiwib3B0X3Vub3JkZXJlZF9hcnJheV9mb2xkJDAiLCJzdW0kMCIsIm9wdF9zdW0kMCIsInN1bV9pbnQkMCIsInN1bV9mbG9hdCQwIiwic3RhYmlsaXplJDEiLCJhbV9zdGFiaWxpemluZyQxIiwid2Vha19tZW1vaXplX2Z1bl9ieV9rZXkkMCIsIndlYWtfbWVtb2l6ZV9mdW4kMCIsInNleHBfb2ZfdCQ4IiwiaW52YXJpYW50JDYiLCJzZXhwX29mX3QkMTAiLCJpbnZhcmlhbnQkNyIsInNleHBfb2ZfdCQxMiIsInNleHBfb2ZfdCQxMyIsImludmFyaWFudCQ4Iiwib25fdXBkYXRlX2V4biQwIiwiZGlzYWxsb3dfZnV0dXJlX3VzZSQxIiwidmFsdWUkMSIsInNleHBfb2ZfdCQxNCIsImludmFyaWFudCQ5Iiwic2V4cF9vZl90JDE1Iiwic2V4cF9vZl90JDE2Il0sInNvdXJjZXMiOlsiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2luY3JlbWVudGFsL2luY3JlbWVudGFsX18ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvaW5jcmVtZW50YWwvYmVmb3JlX29yX2FmdGVyLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2luY3JlbWVudGFsL2ltcG9ydC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9jdXRvZmYubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvaW5jcmVtZW50YWwvZG90X3VzZXJfaW5mby5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9ub2RlX2lkLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2luY3JlbWVudGFsL3N0YWJpbGl6YXRpb25fbnVtLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2luY3JlbWVudGFsL29uX3VwZGF0ZV9oYW5kbGVyLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2luY3JlbWVudGFsL3JhaXNlZF9leG4ubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL3R5cGVzLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2luY3JlbWVudGFsL3Zhci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC91bm9yZGVyZWRfYXJyYXlfZm9sZC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9hbGFybS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9zdGVwX2Z1bmN0aW9uX25vZGUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvaW5jcmVtZW50YWwvYXJyYXlfZm9sZC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9hdC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9hdF9pbnRlcnZhbHMubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvaW5jcmVtZW50YWwvYmluZC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9leHBlcnQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvaW5jcmVtZW50YWwvc2NvcGUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvaW5jcmVtZW50YWwvZnJlZXplLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2luY3JlbWVudGFsL2lmX3RoZW5fZWxzZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9qb2luLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2luY3JlbWVudGFsL3NuYXBzaG90Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2luY3JlbWVudGFsL2tpbmQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvaW5jcmVtZW50YWwvbm9kZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9yZWNvbXB1dGVfaGVhcC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9hZGp1c3RfaGVpZ2h0c19oZWFwLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2luY3JlbWVudGFsL2FsYXJtX3ZhbHVlLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2luY3JlbWVudGFsL2NvbmZpZy5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9pbnRlcm5hbF9vYnNlcnZlci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9vYnNlcnZlci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9zdGF0ZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9leHBlcnQxLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2luY3JlbWVudGFsL3JlZHVjZV9iYWxhbmNlZC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9pbmNyZW1lbnRhbC9mb3JfYW5hbHl6ZXIubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvaW5jcmVtZW50YWwvbm9kZV90b19kb3QubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvaW5jcmVtZW50YWwvaW5jcmVtZW50YWwubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0EwSHVCOztJQUFBOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0MxSHZCLFNBQUFBLGlCQUFBLHlCQUdvQjs7Ozs7eUNBSHBCQTs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNvQklDOzs7SUFKQUM7WUFLQUMsSUFBK0NDLFVBQUFDLFVBQXBDQztJQUFZO0tBQXdCQyxpQ0FBQUg7S0FBQUksc0JBQXBDRixXQUFvQ0Q7bUJBQUFFLGNBQUFDO0dBQVc7R0FJN0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUdYUjtJQUhXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BR1hBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQWdCQVMsUUFBUUMsR0FBR0Ms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QUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0F5TUVoQjs7OztRQXVJUjZDO1FBeE9NaEU7UUFVQTFxQjtRQVdBNHFCO1FBdkJBSjtRQXdCQS9aO1FBQ0F2dUM7UUFDQTJvRDtRQUlBbEc7UUFDQW1HO1FBSkF2bEM7UUFDQTgrQjtRQUNBNytCO1FBS0Fxd0I7UUFGQTZPO1FBUUExK0I7O1lBaU5ONG9DOztTQUFBRTs7Ozs7Ozs7UUF3Q0kzQjs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBieSBkdW5lICopXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLkFkanVzdF9oZWlnaHRzX2hlYXAgKilcbm1vZHVsZSBBZGp1c3RfaGVpZ2h0c19oZWFwID0gSW5jcmVtZW50YWxfX0FkanVzdF9oZWlnaHRzX2hlYXBcblxuKCoqIEBjYW5vbmljYWwgSW5jcmVtZW50YWwuQWxhcm0gKilcbm1vZHVsZSBBbGFybSA9IEluY3JlbWVudGFsX19BbGFybVxuXG4oKiogQGNhbm9uaWNhbCBJbmNyZW1lbnRhbC5BbGFybV92YWx1ZSAqKVxubW9kdWxlIEFsYXJtX3ZhbHVlID0gSW5jcmVtZW50YWxfX0FsYXJtX3ZhbHVlXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLkFycmF5X2ZvbGQgKilcbm1vZHVsZSBBcnJheV9mb2xkID0gSW5jcmVtZW50YWxfX0FycmF5X2ZvbGRcblxuKCoqIEBjYW5vbmljYWwgSW5jcmVtZW50YWwuQXQgKilcbm1vZHVsZSBBdCA9IEluY3JlbWVudGFsX19BdFxuXG4oKiogQGNhbm9uaWNhbCBJbmNyZW1lbnRhbC5BdF9pbnRlcnZhbHMgKilcbm1vZHVsZSBBdF9pbnRlcnZhbHMgPSBJbmNyZW1lbnRhbF9fQXRfaW50ZXJ2YWxzXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLkJlZm9yZV9vcl9hZnRlciAqKVxubW9kdWxlIEJlZm9yZV9vcl9hZnRlciA9IEluY3JlbWVudGFsX19CZWZvcmVfb3JfYWZ0ZXJcblxuKCoqIEBjYW5vbmljYWwgSW5jcmVtZW50YWwuQmluZCAqKVxubW9kdWxlIEJpbmQgPSBJbmNyZW1lbnRhbF9fQmluZFxuXG4oKiogQGNhbm9uaWNhbCBJbmNyZW1lbnRhbC5Db25maWcgKilcbm1vZHVsZSBDb25maWcgPSBJbmNyZW1lbnRhbF9fQ29uZmlnXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLkNvbmZpZ19pbnRmICopXG5tb2R1bGUgQ29uZmlnX2ludGYgPSBJbmNyZW1lbnRhbF9fQ29uZmlnX2ludGZcblxuKCoqIEBjYW5vbmljYWwgSW5jcmVtZW50YWwuQ3V0b2ZmICopXG5tb2R1bGUgQ3V0b2ZmID0gSW5jcmVtZW50YWxfX0N1dG9mZlxuXG4oKiogQGNhbm9uaWNhbCBJbmNyZW1lbnRhbC5Eb3RfdXNlcl9pbmZvICopXG5tb2R1bGUgRG90X3VzZXJfaW5mbyA9IEluY3JlbWVudGFsX19Eb3RfdXNlcl9pbmZvXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLkV4cGVydCAqKVxubW9kdWxlIEV4cGVydCA9IEluY3JlbWVudGFsX19FeHBlcnRcblxuKCoqIEBjYW5vbmljYWwgSW5jcmVtZW50YWwuRXhwZXJ0MSAqKVxubW9kdWxlIEV4cGVydDEgPSBJbmNyZW1lbnRhbF9fRXhwZXJ0MVxuXG4oKiogQGNhbm9uaWNhbCBJbmNyZW1lbnRhbC5Gb3JfYW5hbHl6ZXIgKilcbm1vZHVsZSBGb3JfYW5hbHl6ZXIgPSBJbmNyZW1lbnRhbF9fRm9yX2FuYWx5emVyXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLkZvcl9hbmFseXplcl9pbnRmICopXG5tb2R1bGUgRm9yX2FuYWx5emVyX2ludGYgPSBJbmNyZW1lbnRhbF9fRm9yX2FuYWx5emVyX2ludGZcblxuKCoqIEBjYW5vbmljYWwgSW5jcmVtZW50YWwuRnJlZXplICopXG5tb2R1bGUgRnJlZXplID0gSW5jcmVtZW50YWxfX0ZyZWV6ZVxuXG4oKiogQGNhbm9uaWNhbCBJbmNyZW1lbnRhbC5JZl90aGVuX2Vsc2UgKilcbm1vZHVsZSBJZl90aGVuX2Vsc2UgPSBJbmNyZW1lbnRhbF9fSWZfdGhlbl9lbHNlXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLkltcG9ydCAqKVxubW9kdWxlIEltcG9ydCA9IEluY3JlbWVudGFsX19JbXBvcnRcblxuKCoqIEBjYW5vbmljYWwgSW5jcmVtZW50YWwuSW5jcmVtZW50YWxfaW50ZiAqKVxubW9kdWxlIEluY3JlbWVudGFsX2ludGYgPSBJbmNyZW1lbnRhbF9fSW5jcmVtZW50YWxfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBJbmNyZW1lbnRhbC5JbnRlcm5hbF9vYnNlcnZlciAqKVxubW9kdWxlIEludGVybmFsX29ic2VydmVyID0gSW5jcmVtZW50YWxfX0ludGVybmFsX29ic2VydmVyXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLkpvaW4gKilcbm1vZHVsZSBKb2luID0gSW5jcmVtZW50YWxfX0pvaW5cblxuKCoqIEBjYW5vbmljYWwgSW5jcmVtZW50YWwuS2luZCAqKVxubW9kdWxlIEtpbmQgPSBJbmNyZW1lbnRhbF9fS2luZFxuXG4oKiogQGNhbm9uaWNhbCBJbmNyZW1lbnRhbC5Ob2RlICopXG5tb2R1bGUgTm9kZSA9IEluY3JlbWVudGFsX19Ob2RlXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLk5vZGVfaWQgKilcbm1vZHVsZSBOb2RlX2lkID0gSW5jcmVtZW50YWxfX05vZGVfaWRcblxuKCoqIEBjYW5vbmljYWwgSW5jcmVtZW50YWwuTm9kZV90b19kb3QgKilcbm1vZHVsZSBOb2RlX3RvX2RvdCA9IEluY3JlbWVudGFsX19Ob2RlX3RvX2RvdFxuXG4oKiogQGNhbm9uaWNhbCBJbmNyZW1lbnRhbC5PYnNlcnZlciAqKVxubW9kdWxlIE9ic2VydmVyID0gSW5jcmVtZW50YWxfX09ic2VydmVyXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLk9uX3VwZGF0ZV9oYW5kbGVyICopXG5tb2R1bGUgT25fdXBkYXRlX2hhbmRsZXIgPSBJbmNyZW1lbnRhbF9fT25fdXBkYXRlX2hhbmRsZXJcblxuKCoqIEBjYW5vbmljYWwgSW5jcmVtZW50YWwuUmFpc2VkX2V4biAqKVxubW9kdWxlIFJhaXNlZF9leG4gPSBJbmNyZW1lbnRhbF9fUmFpc2VkX2V4blxuXG4oKiogQGNhbm9uaWNhbCBJbmNyZW1lbnRhbC5SZWNvbXB1dGVfaGVhcCAqKVxubW9kdWxlIFJlY29tcHV0ZV9oZWFwID0gSW5jcmVtZW50YWxfX1JlY29tcHV0ZV9oZWFwXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLlJlZHVjZV9iYWxhbmNlZCAqKVxubW9kdWxlIFJlZHVjZV9iYWxhbmNlZCA9IEluY3JlbWVudGFsX19SZWR1Y2VfYmFsYW5jZWRcblxuKCoqIEBjYW5vbmljYWwgSW5jcmVtZW50YWwuU2NvcGUgKilcbm1vZHVsZSBTY29wZSA9IEluY3JlbWVudGFsX19TY29wZVxuXG4oKiogQGNhbm9uaWNhbCBJbmNyZW1lbnRhbC5TZXhwX29mICopXG5tb2R1bGUgU2V4cF9vZiA9IEluY3JlbWVudGFsX19TZXhwX29mXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLlNuYXBzaG90ICopXG5tb2R1bGUgU25hcHNob3QgPSBJbmNyZW1lbnRhbF9fU25hcHNob3RcblxuKCoqIEBjYW5vbmljYWwgSW5jcmVtZW50YWwuU3RhYmlsaXphdGlvbl9udW0gKilcbm1vZHVsZSBTdGFiaWxpemF0aW9uX251bSA9IEluY3JlbWVudGFsX19TdGFiaWxpemF0aW9uX251bVxuXG4oKiogQGNhbm9uaWNhbCBJbmNyZW1lbnRhbC5TdGF0ZSAqKVxubW9kdWxlIFN0YXRlID0gSW5jcmVtZW50YWxfX1N0YXRlXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLlN0ZXBfZnVuY3Rpb25fbm9kZSAqKVxubW9kdWxlIFN0ZXBfZnVuY3Rpb25fbm9kZSA9IEluY3JlbWVudGFsX19TdGVwX2Z1bmN0aW9uX25vZGVcblxuKCoqIEBjYW5vbmljYWwgSW5jcmVtZW50YWwuVHlwZXMgKilcbm1vZHVsZSBUeXBlcyA9IEluY3JlbWVudGFsX19UeXBlc1xuXG4oKiogQGNhbm9uaWNhbCBJbmNyZW1lbnRhbC5Vbm9yZGVyZWRfYXJyYXlfZm9sZCAqKVxubW9kdWxlIFVub3JkZXJlZF9hcnJheV9mb2xkID0gSW5jcmVtZW50YWxfX1Vub3JkZXJlZF9hcnJheV9mb2xkXG5cbigqKiBAY2Fub25pY2FsIEluY3JlbWVudGFsLlZhciAqKVxubW9kdWxlIFZhciA9IEluY3JlbWVudGFsX19WYXJcblxubW9kdWxlIEluY3JlbWVudGFsX18gPSBzdHJ1Y3QgZW5kXG5bQEBkZXByZWNhdGVkIFwidGhpcyBtb2R1bGUgaXMgc2hhZG93ZWRcIl1cbiIsInR5cGUgdCA9XG4gIHwgQmVmb3JlXG4gIHwgQWZ0ZXJcbltAQGRlcml2aW5nIHNleHBfb2ZdXG4iLCJbJSVpbXBvcnQgXCJkZWJ1Zy5tbGhcIl1cblxub3BlbiBDb3JlXG5cbigqIEFsbCBbYXNzZXJ0XXMgYW5kIG90aGVyIGNoZWNrcyB0aHJvdWdob3V0IHRoZSBjb2RlIGFyZSBndWFyZGVkIGJ5IFtpZiBkZWJ1Z10uICBUaGVcbiAgIERFQlVHIHZhcmlhYmxlIGlzIHNldCBpbiB0aGUgbGliIFtpbmNyZW1lbnRhbF0gYW5kIHVuc2V0IGluIHRoZSBsaWJcbiAgIFtpbmNyZW1lbnRhbF9kZWJ1Z10sIGJ1dCBhcGFydCBmcm9tIHRoYXQgdGhleSBhcmUgaWRlbnRpY2FsLiAgVGVzdHMgYXJlIHJ1biB3aXRoIGJvdGhcbiAgIHRoZSBwcm9kdWN0aW9uIGFuZCBkZWJ1ZyBsaWIsIGFuZCB1c2VycyBjYW4gY2hvb3NlIHRvIGJ1aWxkIHdpdGggdGhlIGRlYnVnIGxpYnJhcnksIGlmXG4gICB0aGV5IHN1c3BlY3QgdGhleSBmb3VuZCBhIGJ1ZyBpbiBpbmNyZW1lbnRhbC4gKilcblxuWyUlaWYgSlNDX0RFQlVHXVxuXG5sZXQgZGVidWcgPSB0cnVlXG5cblslJWVsc2VdXG5cbmxldCBkZWJ1ZyA9IGZhbHNlXG5cblslJWVuZGlmXVxuXG5sZXQgY29uY2F0ID0gU3RyaW5nLmNvbmNhdFxubGV0IHRhZyBuYW1lIGEgc2V4cF9vZl9hID0gKG5hbWUsIGEpIHw+IFslc2V4cF9vZjogc3RyaW5nICogYV1cblxubW9kdWxlIFN0ZXBfZnVuY3Rpb24gPSBJbmNyZW1lbnRhbF9zdGVwX2Z1bmN0aW9uXG5cbm1vZHVsZSBUaW1lX25zID0gc3RydWN0XG4gIGluY2x1ZGUgVGltZV9uc1xuXG4gIGxldCBzZXhwX29mX3QgPSBUaW1lX25zLkFsdGVybmF0ZV9zZXhwLnNleHBfb2ZfdFxuZW5kXG5cbm1vZHVsZSBBcnJheSA9IHN0cnVjdFxuICBpbmNsdWRlIEFycmF5XG5cbiAgKCogTm90IGRlZmluaW5nIGFsaWFzZXMgaW4gcHJvZHVjdGlvbiBtb2RlLCBzaW5jZSB0aGV5IGJyZWFrIHR5cGUgc3BlY2lhbGl6YXRpb24gb2ZcbiAgICAgYXJyYXkgYWNjZXNzZXMuICopXG4gIFslJWlmIEpTQ19ERUJVR11cblxuICBsZXQgdW5zYWZlX2dldCA9IGdldFxuICBsZXQgdW5zYWZlX3NldCA9IHNldFxuXG4gIFslJWVuZGlmXVxuXG4gICgqIFJlcXVpcmVzIFtsZW4gPj0gbGVuZ3RoIHRdLiAqKVxuICBsZXQgcmVhbGxvYyB0IH5sZW4gYSA9XG4gICAgbGV0IG5ld190ID0gY3JlYXRlIH5sZW4gYSBpblxuICAgIEFycmF5LmJsaXQgfnNyYzp0IH5zcmNfcG9zOjAgfmRzdDpuZXdfdCB+ZHN0X3BvczowIH5sZW46KGxlbmd0aCB0KTtcbiAgICBuZXdfdFxuICA7O1xuZW5kXG5cbm1vZHVsZSBVb3B0ID0gc3RydWN0XG4gIGluY2x1ZGUgVW9wdFxuXG4gIGxldCB1bnNhZmVfdmFsdWUgPSBpZiBkZWJ1ZyB0aGVuIHZhbHVlX2V4biBlbHNlIHVuc2FmZV92YWx1ZVxuZW5kXG5cbm1vZHVsZSBVbmlmb3JtX2FycmF5ID0gc3RydWN0XG4gIGluY2x1ZGUgVW5pZm9ybV9hcnJheVxuXG4gIFslJWlmIEpTQ19ERUJVR11cblxuICBsZXQgdW5zYWZlX2dldCA9IGdldFxuICBsZXQgdW5zYWZlX3NldCA9IHNldF93aXRoX2NhbWxfbW9kaWZ5XG5cbiAgWyUlZWxzZV1cblxuICAoKiBVbmlmb3JtX2FycmF5IGlzIGJlaW5nIFwic21hcnRcIiBieSBjaGVja2luZyBpZiBlbGVtZW50cyBhcmUgaW50ZWdlcnMsIGJ1dCBVb3B0LnRcbiAgICAgYWxtb3N0IG5ldmVyIGNvbnRhaW4gaW50ZWdlcnMsIHNvIHRoZSBleHRyYSBjaGVjayB0byBtYWtlIGdlbmVyYXRlZCBjb2RlIGhhcmRlciB0b1xuICAgICByZWFkIGFuZCBwb3RlbnRpYWxseSBzbG93ZXIuICopXG4gIGxldCB1bnNhZmVfc2V0ID0gdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5XG4gIGxldCBzZXQgPSBzZXRfd2l0aF9jYW1sX21vZGlmeVxuXG4gIFslJWVuZGlmXVxuXG4gICgqIFJlcXVpcmVzIFtsZW4gPj0gbGVuZ3RoIHRdLiAqKVxuICBsZXQgcmVhbGxvYyB0IH5sZW4gPVxuICAgIGxldCBuZXdfdCA9IGNyZWF0ZSB+bGVuIFVvcHQubm9uZSBpblxuICAgIGJsaXQgfnNyYzp0IH5zcmNfcG9zOjAgfmRzdDpuZXdfdCB+ZHN0X3BvczowIH5sZW46KGxlbmd0aCB0KTtcbiAgICBuZXdfdFxuICA7O1xuZW5kXG5cbm1vZHVsZSBBbGFybV9wcmVjaXNpb24gPSBUaW1pbmdfd2hlZWwuQWxhcm1fcHJlY2lzaW9uXG4iLCJvcGVuIENvcmVcbm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHQgPVxuICAoKiBXZSBzcGVjaWFsaXplIHNvbWUgY3V0b2ZmcyB0byBhdm9pZCBhbiBpbmRpcmVjdCBmdW5jdGlvbiBjYWxsOyBpbiBwYXJ0aWN1bGFyIHdlXG4gICAgIHNwZWNpYWxpemUgdGhlIGRlZmF1bHQgKGFuZCBoZW5jZSBvdmVyd2hlbG1pbmdseSBjb21tb24pIGNhc2Ugb2YgcGh5c2ljYWxcbiAgICAgZXF1YWxpdHkuICopXG4gIHwgQWx3YXlzXG4gIHwgTmV2ZXJcbiAgfCBQaHlzX2VxdWFsXG4gIHwgQ29tcGFyZSBvZiAoJ2EgLT4gJ2EgLT4gaW50KVxuICB8IEVxdWFsIG9mICgnYSAtPiAnYSAtPiBib29sKVxuICB8IEYgb2YgKG9sZF92YWx1ZTonYSAtPiBuZXdfdmFsdWU6J2EgLT4gYm9vbClcbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgXyB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEFsd2F5cyB8IE5ldmVyIHwgUGh5c19lcXVhbCB8IENvbXBhcmUgXyB8IEVxdWFsIF8gfCBGIF8gLT4gKCkpXG47O1xuXG5sZXQgY3JlYXRlIGYgPSBGIGZcbmxldCBvZl9jb21wYXJlIGYgPSBDb21wYXJlIGZcbmxldCBvZl9lcXVhbCBmID0gRXF1YWwgZlxubGV0IG5ldmVyID0gTmV2ZXJcbmxldCBhbHdheXMgPSBBbHdheXNcbmxldCBwb2x5X2VxdWFsID0gRXF1YWwgUG9seS5lcXVhbFxuXG5sZXQgc2hvdWxkX2N1dG9mZiB0IH5vbGRfdmFsdWUgfm5ld192YWx1ZSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFBoeXNfZXF1YWwgLT4gcGh5c19lcXVhbCBvbGRfdmFsdWUgbmV3X3ZhbHVlXG4gIHwgTmV2ZXIgLT4gZmFsc2VcbiAgfCBBbHdheXMgLT4gdHJ1ZVxuICB8IENvbXBhcmUgZiAtPiBmIG9sZF92YWx1ZSBuZXdfdmFsdWUgPSAwXG4gIHwgRXF1YWwgZiAtPiBmIG9sZF92YWx1ZSBuZXdfdmFsdWVcbiAgfCBGIGYgLT4gZiB+b2xkX3ZhbHVlIH5uZXdfdmFsdWVcbjs7XG5cbmxldCBlcXVhbCB0MSB0MiA9XG4gIG1hdGNoIHQxLCB0MiB3aXRoXG4gIHwgQWx3YXlzLCBBbHdheXMgLT4gdHJ1ZVxuICB8IEFsd2F5cywgXyAtPiBmYWxzZVxuICB8IE5ldmVyLCBOZXZlciAtPiB0cnVlXG4gIHwgTmV2ZXIsIF8gLT4gZmFsc2VcbiAgfCBQaHlzX2VxdWFsLCBQaHlzX2VxdWFsIC0+IHRydWVcbiAgfCBQaHlzX2VxdWFsLCBfIC0+IGZhbHNlXG4gIHwgQ29tcGFyZSBmMSwgQ29tcGFyZSBmMiAtPiBwaHlzX2VxdWFsIGYxIGYyXG4gIHwgQ29tcGFyZSBfLCBfIC0+IGZhbHNlXG4gIHwgRXF1YWwgZjEsIEVxdWFsIGYyIC0+IHBoeXNfZXF1YWwgZjEgZjJcbiAgfCBFcXVhbCBfLCBfIC0+IGZhbHNlXG4gIHwgRiBmMSwgRiBmMiAtPiBwaHlzX2VxdWFsIGYxIGYyXG4gIHwgRiBfLCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgcGh5c19lcXVhbCA9IFBoeXNfZXF1YWxcblxubW9kdWxlIEZvcl9hbmFseXplciA9IHN0cnVjdFxuICB0eXBlICdhIHQnID0gJ2EgdFxuXG4gIHR5cGUgdCA9XG4gICAgfCBBbHdheXNcbiAgICB8IE5ldmVyXG4gICAgfCBQaHlzX2VxdWFsXG4gICAgfCBDb21wYXJlXG4gICAgfCBFcXVhbFxuICAgIHwgRlxuICBbQEBkZXJpdmluZyBzZXhwLCBlcXVhbF1cblxuICBsZXQgb2ZfY3V0b2ZmIChjIDogXyB0JykgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgQWx3YXlzIC0+IEFsd2F5c1xuICAgIHwgTmV2ZXIgLT4gTmV2ZXJcbiAgICB8IFBoeXNfZXF1YWwgLT4gUGh5c19lcXVhbFxuICAgIHwgQ29tcGFyZSBfIC0+IENvbXBhcmVcbiAgICB8IEVxdWFsIF8gLT4gRXF1YWxcbiAgICB8IEYgXyAtPiBGXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyB0ID0gU2V4cC50b19zdHJpbmcgKFslc2V4cF9vZjogdF0gdClcbmVuZFxuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIFN0cmluZ19saXN0ID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZyBsaXN0IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gU3RyaW5nLmNvbXBhcmF0b3Jfd2l0bmVzcyBMaXN0LmNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yID0gTGlzdC5jb21wYXJhdG9yIFN0cmluZy5jb21wYXJhdG9yXG5lbmRcblxudHlwZSBkb3QgPVxuICB7IGxhYmVsIDogU2V0Lk0oU3RyaW5nX2xpc3QpLnRcbiAgOyBhdHRyaWJ1dGVzIDogc3RyaW5nIFN0cmluZy5NYXAudFxuICB9XG5bQEBkZXJpdmluZyBzZXhwXVxuXG50eXBlIHQgPVxuICB8IERvdCBvZiBkb3RcbiAgfCBJbmZvIG9mIEluZm8udFxuICB8IEFwcGVuZCBvZlxuICAgICAgeyBwcmlvciA6IHRcbiAgICAgIDsgbmV3XyA6IHRcbiAgICAgIH1cbltAQGRlcml2aW5nIHNleHBdXG5cbmxldCBpbmZvIGluZm8gPSBJbmZvIGluZm9cbmxldCBhcHBlbmQgcHJpb3IgbmV3XyA9IEFwcGVuZCB7IHByaW9yOyBuZXdfIH1cblxubGV0IGRvdCB+bGFiZWwgfmF0dHJpYnV0ZXMgPVxuICBsZXQgbGFiZWwgPSBTZXQuc2luZ2xldG9uIChtb2R1bGUgU3RyaW5nX2xpc3QpIGxhYmVsIGluXG4gIERvdCB7IGxhYmVsOyBhdHRyaWJ1dGVzIH1cbjs7XG5cbmxldCByZWMgdG9fZG90ID0gZnVuY3Rpb25cbiAgfCBJbmZvIGkgLT5cbiAgICB7IGxhYmVsID0gU2V0LnNpbmdsZXRvbiAobW9kdWxlIFN0cmluZ19saXN0KSBbIEluZm8udG9fc3RyaW5nX2h1bSBpIF1cbiAgICA7IGF0dHJpYnV0ZXMgPSBTdHJpbmcuTWFwLmVtcHR5XG4gICAgfVxuICB8IERvdCBkb3QgLT4gZG90XG4gIHwgQXBwZW5kIHsgcHJpb3I7IG5ld18gfSAtPlxuICAgIGxldCBwcmlvciA9IHRvX2RvdCBwcmlvciBpblxuICAgIGxldCBuZXdfID0gdG9fZG90IG5ld18gaW5cbiAgICBsZXQgbGFiZWwgPSBTZXQudW5pb24gcHJpb3IubGFiZWwgbmV3Xy5sYWJlbCBpblxuICAgIGxldCBhdHRyaWJ1dGVzID1cbiAgICAgIE1hcC5tZXJnZV9za2V3ZWRcbiAgICAgICAgcHJpb3IuYXR0cmlidXRlc1xuICAgICAgICBuZXdfLmF0dHJpYnV0ZXNcbiAgICAgICAgfmNvbWJpbmU6KGZ1biB+a2V5Ol8gX2xlZnQgcmlnaHQgLT4gcmlnaHQpXG4gICAgaW5cbiAgICB7IGxhYmVsOyBhdHRyaWJ1dGVzIH1cbjs7XG5cbmxldCBlc2NhcGVfZG90X3N0cmluZyBzID1cbiAgKCogaHR0cHM6Ly9ncmFwaHZpei5vcmcvZG9jL2luZm8vbGFuZy5odG1sICopXG4gIFwiXFxcIlwiIF4gU3RyaW5nLnN1YnN0cl9yZXBsYWNlX2FsbCBzIH5wYXR0ZXJuOlwiXFxcIlwiIH53aXRoXzpcIlxcXFxcXFwiXCIgXiBcIlxcXCJcIlxuOztcblxubGV0IGVzY2FwZV9yZWNvcmRfbGFiZWwgcyA9XG4gICgqIGh0dHBzOi8vZ3JhcGh2aXoub3JnL2RvYy9pbmZvL3NoYXBlcy5odG1sICopXG4gIFN0cmluZy5jb25jYXRfbWFwIHMgfmY6KGZ1bmN0aW9uXG4gICAgfCAoJzwnIHwgJz4nIHwgJ3snIHwgJ30nIHwgJ3wnIHwgJ1xcXFwnIHwgJyAnKSBhcyBjIC0+IFwiXFxcXFwiIF4gU3RyaW5nLm9mX2NoYXIgY1xuICAgIHwgYyAtPiBTdHJpbmcub2ZfY2hhciBjKVxuOztcblxubGV0IHRvX3N0cmluZyA/KHNoYXBlID0gXCJNcmVjb3JkXCIpIH5uYW1lIHsgbGFiZWw7IGF0dHJpYnV0ZXMgfSA9XG4gIGxldCBsYWJlbCA9XG4gICAgbGFiZWxcbiAgICB8PiBTZXQudG9fbGlzdFxuICAgIHw+IExpc3QubWFwIH5mOihmdW4gY29scyAtPlxuICAgICAgICAgXCJ7XCIgXiBTdHJpbmcuY29uY2F0IChMaXN0Lm1hcCBjb2xzIH5mOmVzY2FwZV9yZWNvcmRfbGFiZWwpIH5zZXA6XCJ8XCIgXiBcIn1cIilcbiAgICB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCJ8XCJcbiAgICB8PiBmdW4gcyAtPiBcIntcIiBeIHMgXiBcIn1cIlxuICBpblxuICBsZXQgYXR0cmlidXRlcyA9XG4gICAgYXR0cmlidXRlc1xuICAgIHw+IE1hcC50b19hbGlzdFxuICAgIHw+IExpc3QubWFwIH5mOihmdW4gKGssIHYpIC0+XG4gICAgICAgICBzcHJpbnRmIHt8ICVzPSVzfH0gKGVzY2FwZV9kb3Rfc3RyaW5nIGspIChlc2NhcGVfZG90X3N0cmluZyB2KSlcbiAgICB8PiBTdHJpbmcuY29uY2F0IH5zZXA6XCIgXCJcbiAgaW5cbiAgc3ByaW50ZiB7fCAgJXMgW3NoYXBlPSVzIGxhYmVsPSVzICVzXXx9IG5hbWUgc2hhcGUgKGVzY2FwZV9kb3Rfc3RyaW5nIGxhYmVsKSBhdHRyaWJ1dGVzXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgSW50XG5cbmxldCBpbnZhcmlhbnQgdCA9IGFzc2VydCAodCA+PSAxKVxuXG5sZXQgbmV4dCA9XG4gIGxldCByID0gcmVmIDAgaW5cbiAgZnVuICgpIC0+XG4gICAgaW5jciByO1xuICAgICFyXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgSW50XG5cbmxldCBpbnZhcmlhbnQgdCA9IGFzc2VydCAodCA+PSAtMSlcbmxldCBub25lID0gLTFcbmxldCBpc19ub25lIHQgPSB0ID0gbm9uZVxubGV0IGlzX3NvbWUgdCA9IHQgPj0gMFxubGV0IGFkZDEgdCA9IHQgKyAxXG5cbm1vZHVsZSBGb3JfYW5hbHl6ZXIgPSBJbnRcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgUHJldmlvdXNfdXBkYXRlX2tpbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IE5ldmVyX2JlZW5fdXBkYXRlZFxuICAgIHwgTmVjZXNzYXJ5XG4gICAgfCBDaGFuZ2VkXG4gICAgfCBJbnZhbGlkYXRlZFxuICAgIHwgVW5uZWNlc3NhcnlcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG5tb2R1bGUgTm9kZV91cGRhdGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IE5lY2Vzc2FyeSBvZiAnYVxuICAgIHwgQ2hhbmdlZCBvZiAnYSAqICdhXG4gICAgfCBJbnZhbGlkYXRlZFxuICAgIHwgVW5uZWNlc3NhcnlcbiAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cbmVuZFxuXG50eXBlICdhIHQgPVxuICB7IGYgOiAnYSBOb2RlX3VwZGF0ZS50IC0+IHVuaXRcbiAgOyBtdXRhYmxlIHByZXZpb3VzX3VwZGF0ZV9raW5kIDogUHJldmlvdXNfdXBkYXRlX2tpbmQudFxuICA7IGNyZWF0ZWRfYXQgOiBTdGFiaWxpemF0aW9uX251bS50XG4gIH1cbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBjcmVhdGUgZiB+YXQ6Y3JlYXRlZF9hdCA9IHsgZjsgcHJldmlvdXNfdXBkYXRlX2tpbmQgPSBOZXZlcl9iZWVuX3VwZGF0ZWQ7IGNyZWF0ZWRfYXQgfVxuXG5sZXQgcmVhbGx5X3J1biB0IChub2RlX3VwZGF0ZSA6IF8gTm9kZV91cGRhdGUudCkgPVxuICB0LnByZXZpb3VzX3VwZGF0ZV9raW5kXG4gICAgPC0gKG1hdGNoIG5vZGVfdXBkYXRlIHdpdGhcbiAgICAgICAgfCBOZWNlc3NhcnkgXyAtPiBOZWNlc3NhcnlcbiAgICAgICAgfCBDaGFuZ2VkIF8gLT4gQ2hhbmdlZFxuICAgICAgICB8IEludmFsaWRhdGVkIC0+IEludmFsaWRhdGVkXG4gICAgICAgIHwgVW5uZWNlc3NhcnkgLT4gVW5uZWNlc3NhcnkpO1xuICB0LmYgbm9kZV91cGRhdGVcbjs7XG5cbmxldCBydW4gdCAobm9kZV91cGRhdGUgOiBfIE5vZGVfdXBkYXRlLnQpIH5ub3cgPVxuICAoKiBXZSBvbmx5IHJ1biB0aGUgaGFuZGxlciBpZiB3YXMgY3JlYXRlZCBpbiBhbiBlYXJsaWVyIHN0YWJpbGl6YXRpb24gY3ljbGUuICBJZiB0aGVcbiAgICAgaGFuZGxlciB3YXMgY3JlYXRlZCBieSBhbm90aGVyIG9uLXVwZGF0ZSBoYW5kbGVyIGR1cmluZyB0aGUgcnVubmluZyBvZiBvbi11cGRhdGVcbiAgICAgaGFuZGxlcnMgaW4gdGhlIGN1cnJlbnQgc3RhYmlsaXphdGlvbiwgd2UgdHJlYXQgdGhlIGFkZGVkIGhhbmRsZXIgYXMgaWYgaXQgd2VyZSBhZGRlZFxuICAgICBhZnRlciB0aGlzIHN0YWJpbGl6YXRpb24gZmluaXNoZWQuICBXZSB3aWxsIHJ1biBpdCBhdCB0aGUgbmV4dCBzdGFiaWxpemF0aW9uLCBiZWNhdXNlXG4gICAgIHRoZSBub2RlIHdpdGggdGhlIGhhbmRsZXIgd2FzIHB1c2hlZCBvbiBbc3RhdGUuaGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb25dLiAqKVxuICBpZiBTdGFiaWxpemF0aW9uX251bS5jb21wYXJlIHQuY3JlYXRlZF9hdCBub3cgPCAwXG4gIHRoZW4gKFxuICAgIG1hdGNoIHQucHJldmlvdXNfdXBkYXRlX2tpbmQsIG5vZGVfdXBkYXRlIHdpdGhcbiAgICAoKiBPbmNlIGEgbm9kZSBpcyBpbnZhbGlkYXRlZCwgdGhlcmUgd2lsbCBuZXZlciBiZSBmdXJ0aGVyIGluZm9ybWF0aW9uIHRvIHByb3ZpZGUsXG4gICAgICAgc2luY2UgaW5jcmVtZW50YWwgZG9lcyBub3QgYWxsb3cgYW4gaW52YWxpZCBub2RlIHRvIGJlY29tZSB2YWxpZC4gKilcbiAgICB8IEludmFsaWRhdGVkLCBfIC0+ICgpXG4gICAgKCogVGhlc2UgY2FzZXMgY2FuIGhhcHBlbiBpZiBhIG5vZGUgaXMgaGFuZGxlZCBhZnRlciBzdGFiaWxpemF0aW9uIGR1ZSB0byBhbm90aGVyXG4gICAgICAgaGFuZGxlci4gIEJ1dCBmb3IgdGhlIGN1cnJlbnQgaGFuZGxlciwgdGhlcmUgaXMgbm90aGluZyB0byBkbyBiZWNhdXNlIHRoZXJlIGlzIG5vXG4gICAgICAgbmV3IGluZm9ybWF0aW9uIHRvIHByb3ZpZGUuICopXG4gICAgfCBDaGFuZ2VkLCBOZWNlc3NhcnkgXyB8IE5lY2Vzc2FyeSwgTmVjZXNzYXJ5IF8gfCBVbm5lY2Vzc2FyeSwgVW5uZWNlc3NhcnkgLT4gKClcbiAgICAoKiBJZiB0aGlzIGhhbmRsZXIgaGFzbid0IHNlZW4gYSBub2RlIHRoYXQgaXMgY2hhbmdpbmcsIHdlIHRyZWF0IHRoZSB1cGRhdGUgYXMgYW5cbiAgICAgICBpbml0aWFsaXphdGlvbi4gKilcbiAgICB8IChOZXZlcl9iZWVuX3VwZGF0ZWQgfCBVbm5lY2Vzc2FyeSksIENoYW5nZWQgKF8sIGEpIC0+IHJlYWxseV9ydW4gdCAoTmVjZXNzYXJ5IGEpXG4gICAgKCogQWxsIG90aGVyIHVwZGF0ZXMgYXJlIHJ1biBhcyBpcy4gKilcbiAgICB8IE5ldmVyX2JlZW5fdXBkYXRlZCwgKE5lY2Vzc2FyeSBfIHwgVW5uZWNlc3NhcnkgfCBJbnZhbGlkYXRlZClcbiAgICB8IFVubmVjZXNzYXJ5LCAoTmVjZXNzYXJ5IF8gfCBJbnZhbGlkYXRlZClcbiAgICB8IE5lY2Vzc2FyeSwgKENoYW5nZWQgXyB8IFVubmVjZXNzYXJ5IHwgSW52YWxpZGF0ZWQpXG4gICAgfCBDaGFuZ2VkLCAoQ2hhbmdlZCBfIHwgVW5uZWNlc3NhcnkgfCBJbnZhbGlkYXRlZCkgLT4gcmVhbGx5X3J1biB0IG5vZGVfdXBkYXRlKVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9XG4gIHsgZXhuIDogZXhuXG4gIDsgYmFja3RyYWNlIDogQmFja3RyYWNlLnRcbiAgfVxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGNyZWF0ZSBleG4gPSB7IGV4bjsgYmFja3RyYWNlID0gQmFja3RyYWNlLkV4bi5tb3N0X3JlY2VudCAoKSB9XG5cbmxldCByZXJhaXNlX3dpdGhfbWVzc2FnZSB7IGV4bjsgYmFja3RyYWNlIH0gbXNnID1cbiAgRXhuLnJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIChFeG4uUmVyYWlzZWQgKG1zZywgZXhuKSkgYmFja3RyYWNlXG47O1xuXG5sZXQgcmVyYWlzZSB7IGV4bjsgYmFja3RyYWNlIH0gPSBFeG4ucmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgZXhuIGJhY2t0cmFjZVxuIiwiKCogdHlwZXMubWwgKilcblxuKCogPT09PT09PT0gQ2FyZHMsIFBsYXllcnMsIE1lbGRzID09PT09PT09ICopXG5cbnR5cGUgc3VpdCA9IEhlYXJ0cyB8IFNwYWRlcyB8IERpYW1vbmRzIHwgQ2x1YnNcblxudHlwZSByYW5rID1cbiAgfCBUd28gfCBUaHJlZSB8IEZvdXIgfCBGaXZlIHwgU2l4IHwgU2V2ZW5cbiAgfCBFaWdodCB8IE5pbmUgfCBUZW4gfCBKYWNrIHwgUXVlZW4gfCBLaW5nIHwgQWNlXG5cbnR5cGUgY2FyZCA9IHsgc3VpdCA6IHN1aXQ7IHJhbmsgOiByYW5rIH1cblxudHlwZSBtZWxkX2tpbmQgPSBTZXQgfCBSdW5cbnR5cGUgbWVsZCA9IHsga2luZCA6IG1lbGRfa2luZDsgY2FyZHMgOiBjYXJkIGxpc3QgfVxuXG50eXBlIHBsYXllciA9IHtcbiAgaWQgOiBpbnQ7XG4gIG5hbWUgOiBzdHJpbmc7XG4gIGhhbmQgOiBjYXJkIGxpc3Q7XG59XG5cbigqID09PT09PT09IENvbmZpZyAvIFBvbGljeSA9PT09PT09PSAqKVxuXG50eXBlIGFjZV9wb2xpY3kgPSBMb3cgfCBIaWdoXG50eXBlIHNjb3JpbmcgPSB7XG4gIGRlYWR3b29kX3RocmVzaG9sZCA6IGludCBvcHRpb247XG59XG5cbigqID09PT09PT09IFR1cm4gUGhhc2VzICYgQWN0aW9ucyA9PT09PT09PSAqKVxuXG50eXBlIHBoYXNlID0gRHJhdyB8IFBsYXkgfCBEaXNjYXJkIHwgRW5kQ2hlY2tcblxudHlwZSBwbGF5X2FjdGlvbiA9XG4gIHwgTWFrZV9zZXQgb2YgY2FyZCBsaXN0XG4gIHwgTWFrZV9ydW4gb2YgY2FyZCBsaXN0XG4gIHwgTGF5X29mZiBvZiBjYXJkICogaW50ICAgKCogY2FyZCwgbWVsZCBpbmRleCAqKVxuICB8IFNraXBfdG9fZGlzY2FyZFxuXG50eXBlIGRpc2NhcmRfYWN0aW9uID0gRGlzY2FyZF9jYXJkIG9mIGNhcmRcblxuKCogPT09PT09PT0gV2hvbGUgR2FtZSBTdGF0ZSA9PT09PT09PSAqKVxuXG50eXBlIGRyYXdfc291cmNlID1cbiAgfCBGcm9tRGVja1xuICB8IEZyb21EaXNjYXJkXG4gIHwgRnJvbURpc2NhcmROIG9mIGludFxuXG50eXBlIHN0YXRlID0ge1xuICBkZWNrIDogY2FyZCBsaXN0O1xuICBkaXNjYXJkIDogY2FyZCBsaXN0O1xuICBtZWxkcyA6IG1lbGQgbGlzdDtcbiAgcGxheWVycyA6IHBsYXllciBhcnJheTtcbiAgY3VycmVudCA6IGludDtcbiAgcGhhc2UgOiBwaGFzZTtcbiAgYWNlX3BvbGljeSA6IGFjZV9wb2xpY3k7XG4gIHNjb3JpbmcgOiBzY29yaW5nO1xuICByZXF1aXJlZF90b191c2UgOiBjYXJkIG9wdGlvbjtcbiAgc2NvcmVzIDogaW50IGFycmF5O1xufVxuXG4oKiA9PT09PT09PSBQcmV0dHkgaGVscGVycyA9PT09PT09PSAqKVxuXG5sZXQgc3RyaW5nX29mX3N1aXQgPSBmdW5jdGlvblxuICB8IEhlYXJ0cyAtPiBcIuKZpVwiIHwgU3BhZGVzIC0+IFwi4pmgXCIgfCBEaWFtb25kcyAtPiBcIuKZplwiIHwgQ2x1YnMgLT4gXCLimaNcIlxuXG5sZXQgc3RyaW5nX29mX3JhbmsgPSBmdW5jdGlvblxuICB8IFR3by0+XCIyXCJ8VGhyZWUtPlwiM1wifEZvdXItPlwiNFwifEZpdmUtPlwiNVwifFNpeC0+XCI2XCJ8U2V2ZW4tPlwiN1wiXG4gIHwgRWlnaHQtPlwiOFwifE5pbmUtPlwiOVwifFRlbi0+XCIxMFwifEphY2stPlwiSlwifFF1ZWVuLT5cIlFcInxLaW5nLT5cIktcInxBY2UtPlwiQVwiXG5cbmxldCBzdHJpbmdfb2ZfY2FyZCBjID0gUHJpbnRmLnNwcmludGYgXCIlcyVzXCIgKHN0cmluZ19vZl9yYW5rIGMucmFuaykgKHN0cmluZ19vZl9zdWl0IGMuc3VpdCkiLCJvcGVuIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIE5vZGUgPSBUeXBlcy5Ob2RlXG5cbnR5cGUgJ2EgdCA9ICdhIFR5cGVzLlZhci50ID1cbiAgeyBtdXRhYmxlIHZhbHVlIDogJ2FcbiAgOyAoKiBbdmFsdWVfc2V0X2R1cmluZ19zdGFiaWxpemF0aW9uXSBpcyBvbmx5IHNldCB0byBbVW9wdC5zb21lXSBpZiB0aGUgdXNlciBjYWxsc1xuICAgICAgIFtWYXIuc2V0XSBkdXJpbmcgc3RhYmlsaXphdGlvbiwgaW4gd2hpY2ggY2FzZSBpdCBob2xkcyB0aGUgKGxhc3QpIHZhbHVlIHNldC4gIEF0XG4gICAgICAgdGhlIGVuZCBvZiBzdGFiaWxpemF0aW9uLCBhbGwgc3VjaCB2YXJpYWJsZXMgYXJlIHByb2Nlc3NlZCB0byBkbyBbdC52YWx1ZSA8LVxuICAgICAgIHQudmFsdWVfc2V0X2R1cmluZ19zdGFiaWxpemF0aW9uXS4gKilcbiAgICBtdXRhYmxlIHZhbHVlX3NldF9kdXJpbmdfc3RhYmlsaXphdGlvbiA6ICdhIFVvcHQudFxuICA7ICgqIFtzZXRfYXRdIHRoZSBzdGFiaWxpemF0aW9uIG51bWJlciBpbiBlZmZlY3QgdGhlIG1vc3QgcmVjZW50IHRpbWUgW3QudmFsdWVdIGNoYW5nZWQuXG4gICAgICAgVGhpcyBpcyBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgYXMgdGhlIHN0YWJpbGl6YXRpb24gbnVtYmVyIGluIGVmZmVjdCB0aGUgbW9zdFxuICAgICAgIHJlY2VudCB0aW1lIFtWYXIuc2V0IHRdIHdhcyBjYWxsZWQsIGR1ZSB0byB0aGUgZWZmZWN0IG9mIFtWYXIuc2V0XSBkdXJpbmdcbiAgICAgICBzdGFiaWxpemF0aW9uIGJlaW5nIGRlbGF5ZWQgdW50aWwgYWZ0ZXIgdGhlIHN0YWJpbGl6YXRpb24uICopXG4gICAgbXV0YWJsZSBzZXRfYXQgOiBTdGFiaWxpemF0aW9uX251bS50XG4gIDsgd2F0Y2ggOiAnYSBOb2RlLnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfnZhbHVlOihjaGVjayBpbnZhcmlhbnRfYSlcbiAgICAgIH52YWx1ZV9zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb246KGNoZWNrIChVb3B0LmludmFyaWFudCBpbnZhcmlhbnRfYSkpXG4gICAgICB+c2V0X2F0OihjaGVjayBTdGFiaWxpemF0aW9uX251bS5pbnZhcmlhbnQpXG4gICAgICB+d2F0Y2g6XG4gICAgICAgIChjaGVjayAoZnVuICh3YXRjaCA6IF8gTm9kZS50KSAtPlxuICAgICAgICAgICBtYXRjaCB3YXRjaC5raW5kIHdpdGhcbiAgICAgICAgICAgfCBJbnZhbGlkIC0+ICgpICgqIHBvc3NpYmxlIHdpdGggW351c2VfY3VycmVudF9zY29wZTp0cnVlXSAqKVxuICAgICAgICAgICB8IFZhciB0JyAtPiBhc3NlcnQgKHBoeXNfZXF1YWwgdCB0JylcbiAgICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSkpKVxuOztcblxubGV0IGluY3Jfc3RhdGUgdCA9IHQud2F0Y2guc3RhdGVcblxubW9kdWxlIFBhY2tlZCA9IHN0cnVjdFxuICB0eXBlICdhIHZhciA9ICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSB0ID0gVHlwZXMuVmFyLlBhY2tlZC50ID0gVCA6IF8gdmFyIC0+IHQgW0BAdW5ib3hlZF0gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG5sZXQgbGF0ZXN0X3ZhbHVlIHQgPVxuICBpZiBVb3B0LmlzX3NvbWUgdC52YWx1ZV9zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb25cbiAgdGhlbiBVb3B0LnVuc2FmZV92YWx1ZSB0LnZhbHVlX3NldF9kdXJpbmdfc3RhYmlsaXphdGlvblxuICBlbHNlIHQudmFsdWVcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5vcGVuIFR5cGVzLktpbmRcbm1vZHVsZSBOb2RlID0gVHlwZXMuTm9kZVxuXG5tb2R1bGUgVXBkYXRlID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgfCBGX2ludmVyc2Ugb2YgKCdiIC0+ICdhIC0+ICdiKVxuICAgIHwgVXBkYXRlIG9mICgnYiAtPiBvbGRfdmFsdWU6J2EgLT4gbmV3X3ZhbHVlOidhIC0+ICdiKVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCB1cGRhdGUgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBVcGRhdGUgdXBkYXRlIC0+IHVwZGF0ZVxuICAgIHwgRl9pbnZlcnNlIGZfaW52ZXJzZSAtPlxuICAgICAgZnVuIGZvbGRfdmFsdWUgfm9sZF92YWx1ZSB+bmV3X3ZhbHVlIC0+IGYgKGZfaW52ZXJzZSBmb2xkX3ZhbHVlIG9sZF92YWx1ZSkgbmV3X3ZhbHVlXG4gIDs7XG5lbmRcblxudHlwZSAoJ2EsICdhY2MpIHQgPSAoJ2EsICdhY2MpIFR5cGVzLlVub3JkZXJlZF9hcnJheV9mb2xkLnQgPVxuICB7IG1haW4gOiAnYWNjIE5vZGUudFxuICA7IGluaXQgOiAnYWNjXG4gIDsgZiA6ICdhY2MgLT4gJ2EgLT4gJ2FjY1xuICA7IHVwZGF0ZSA6ICdhY2MgLT4gb2xkX3ZhbHVlOidhIC0+IG5ld192YWx1ZTonYSAtPiAnYWNjXG4gIDsgZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyA6IGludFxuICA7IGNoaWxkcmVuIDogJ2EgTm9kZS50IGFycmF5XG4gIDsgbXV0YWJsZSBmb2xkX3ZhbHVlIDogJ2FjYyBVb3B0LnRcbiAgOyBtdXRhYmxlIG51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlIDogaW50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbmxldCBzYW1lICh0MSA6IChfLCBfKSB0KSAodDIgOiAoXywgXykgdCkgPSBwaHlzX3NhbWUgdDEgdDJcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSBpbnZhcmlhbnRfYWNjIHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IChfLCBfKSB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5tYWluOlxuICAgICAgICAoY2hlY2sgKGZ1biAobWFpbiA6IF8gTm9kZS50KSAtPlxuICAgICAgICAgICBtYXRjaCBtYWluLmtpbmQgd2l0aFxuICAgICAgICAgICB8IEludmFsaWQgLT4gKClcbiAgICAgICAgICAgfCBVbm9yZGVyZWRfYXJyYXlfZm9sZCB0JyAtPiBhc3NlcnQgKHNhbWUgdCB0JylcbiAgICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSkpXG4gICAgICB+aW5pdDooY2hlY2sgaW52YXJpYW50X2FjYylcbiAgICAgIH5mOmlnbm9yZVxuICAgICAgfnVwZGF0ZTppZ25vcmVcbiAgICAgIH5jaGlsZHJlbjpcbiAgICAgICAgKGNoZWNrIChmdW4gY2hpbGRyZW4gLT5cbiAgICAgICAgICAgQXJyYXkuaXRlciBjaGlsZHJlbiB+ZjooZnVuIChjaGlsZCA6IF8gTm9kZS50KSAtPlxuICAgICAgICAgICAgIFVvcHQuaW52YXJpYW50IGludmFyaWFudF9hIGNoaWxkLnZhbHVlX29wdDtcbiAgICAgICAgICAgICBpZiB0Lm51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlIDwgdC5mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzXG4gICAgICAgICAgICAgdGhlbiBhc3NlcnQgKFVvcHQuaXNfc29tZSBjaGlsZC52YWx1ZV9vcHQpKSkpXG4gICAgICB+Zm9sZF92YWx1ZTpcbiAgICAgICAgKGNoZWNrIChmdW4gZm9sZF92YWx1ZSAtPlxuICAgICAgICAgICBVb3B0LmludmFyaWFudCBpbnZhcmlhbnRfYWNjIGZvbGRfdmFsdWU7XG4gICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IGJvb2xdXG4gICAgICAgICAgICAgKFVvcHQuaXNfc29tZSBmb2xkX3ZhbHVlKVxuICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAodC5udW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY29tcHV0ZSA8IHQuZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcykpKVxuICAgICAgfm51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlOlxuICAgICAgICAoY2hlY2sgKGZ1biBudW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY29tcHV0ZSAtPlxuICAgICAgICAgICBhc3NlcnQgKG51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlID49IDApO1xuICAgICAgICAgICBhc3NlcnQgKG51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlIDw9IHQuZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcykpKVxuICAgICAgfmZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXM6XG4gICAgICAgIChjaGVjayAoZnVuIGZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMgLT5cbiAgICAgICAgICAgYXNzZXJ0IChmdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzID4gMCkpKSlcbjs7XG5cbmxldCBjcmVhdGUgfmluaXQgfmYgfnVwZGF0ZSB+ZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyB+Y2hpbGRyZW4gfm1haW4gPVxuICB7IGluaXRcbiAgOyBmXG4gIDsgdXBkYXRlID0gVXBkYXRlLnVwZGF0ZSB1cGRhdGUgfmZcbiAgOyBmdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzXG4gIDsgY2hpbGRyZW5cbiAgOyBtYWluXG4gIDsgZm9sZF92YWx1ZSA9XG4gICAgICBVb3B0Lm5vbmVcbiAgICAgICgqIFdlIG1ha2UgW251bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlID0gZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlc11cbiAgICAgc28gdGhhdCB0aGVyZSB3aWxsIGJlIGEgZnVsbCBjb21wdXRhdGlvbiB0aGUgbmV4dCB0aW1lIHRoZSBub2RlIGlzIGNvbXB1dGVkLiAqKVxuICA7IG51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlID0gZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlc1xuICB9XG47O1xuXG5sZXQgZnVsbF9jb21wdXRlIHsgaW5pdDsgZjsgY2hpbGRyZW47IF8gfSA9XG4gIGxldCByZXN1bHQgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGNoaWxkcmVuIC0gMSBkb1xuICAgIHJlc3VsdCA6PSBmICFyZXN1bHQgKFVvcHQudmFsdWVfZXhuIChBcnJheS51bnNhZmVfZ2V0IGNoaWxkcmVuIGkpLnZhbHVlX29wdClcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGNvbXB1dGUgdCA9XG4gIGlmIHQubnVtX2NoYW5nZXNfc2luY2VfbGFzdF9mdWxsX2NvbXB1dGUgPSB0LmZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXNcbiAgdGhlbiAoXG4gICAgdC5udW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY29tcHV0ZSA8LSAwO1xuICAgIHQuZm9sZF92YWx1ZSA8LSBVb3B0LnNvbWUgKGZ1bGxfY29tcHV0ZSB0KSk7XG4gIFVvcHQudmFsdWVfZXhuIHQuZm9sZF92YWx1ZVxuOztcblxubGV0IGZvcmNlX2Z1bGxfY29tcHV0ZSB0ID1cbiAgdC5mb2xkX3ZhbHVlIDwtIFVvcHQubm9uZTtcbiAgdC5udW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY29tcHV0ZSA8LSB0LmZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXNcbjs7XG5cbmxldCBjaGlsZF9jaGFuZ2VkXG4gICh0eXBlIGEgYilcbiAgKHQgOiAoYSwgXykgdClcbiAgfihjaGlsZCA6IGIgTm9kZS50KVxuICB+Y2hpbGRfaW5kZXhcbiAgfihvbGRfdmFsdWVfb3B0IDogYiBVb3B0LnQpXG4gIH4obmV3X3ZhbHVlIDogYilcbiAgPVxuICBsZXQgY2hpbGRfYXRfaW5kZXggPSB0LmNoaWxkcmVuLihjaGlsZF9pbmRleCkgaW5cbiAgbWF0Y2ggTm9kZS50eXBlX2VxdWFsX2lmX3BoeXNfc2FtZSBjaGlsZCBjaGlsZF9hdF9pbmRleCB3aXRoXG4gIHwgTm9uZSAtPlxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIltVbm9yZGVyZWRfYXJyYXlfZm9sZC5jaGlsZF9jaGFuZ2VkXSBtaXNtYXRjaFwiXG4gICAgICAgICAgfnVub3JkZXJlZF9hcnJheV9mb2xkOih0IDogKF8sIF8pIHQpXG4gICAgICAgICAgKGNoaWxkX2luZGV4IDogaW50KVxuICAgICAgICAgIChjaGlsZCA6IF8gTm9kZS50KV1cbiAgfCBTb21lIFQgLT5cbiAgICBpZiB0Lm51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlIDwgdC5mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzIC0gMVxuICAgIHRoZW4gKFxuICAgICAgdC5udW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY29tcHV0ZSA8LSB0Lm51bV9jaGFuZ2VzX3NpbmNlX2xhc3RfZnVsbF9jb21wdXRlICsgMTtcbiAgICAgICgqIFdlIG9ubHkgcmVhY2ggdGhpcyBjYXNlIGlmIHdlIGhhdmUgYWxyZWFkeSBkb25lIGEgZnVsbCBjb21wdXRlLCBpbiB3aGljaCBjYXNlXG4gICAgICAgICBbVW9wdC5pc19zb21lIHQuZm9sZF92YWx1ZV0gYW5kIFtVb3B0LmlzX3NvbWUgb2xkX3ZhbHVlX29wdF0uICopXG4gICAgICB0LmZvbGRfdmFsdWVcbiAgICAgICAgPC0gVW9wdC5zb21lXG4gICAgICAgICAgICAgKHQudXBkYXRlXG4gICAgICAgICAgICAgICAgKFVvcHQudmFsdWVfZXhuIHQuZm9sZF92YWx1ZSlcbiAgICAgICAgICAgICAgICB+b2xkX3ZhbHVlOihVb3B0LnZhbHVlX2V4biBvbGRfdmFsdWVfb3B0KVxuICAgICAgICAgICAgICAgIH5uZXdfdmFsdWUpKVxuICAgIGVsc2UgaWYgdC5udW1fY2hhbmdlc19zaW5jZV9sYXN0X2Z1bGxfY29tcHV0ZSA8IHQuZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlc1xuICAgIHRoZW4gZm9yY2VfZnVsbF9jb21wdXRlIHRcbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBBbGFybSA9IFRpbWluZ193aGVlbC5BbGFybVxuXG50eXBlIHQgPSAoVHlwZXMuQWxhcm1fdmFsdWUudFtAc2V4cC5vcGFxdWVdKSBBbGFybS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgbnVsbCA9IEFsYXJtLm51bGwgKClcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuIFR5cGVzLktpbmRcbm1vZHVsZSBBbGFybV92YWx1ZSA9IFR5cGVzLkFsYXJtX3ZhbHVlXG5tb2R1bGUgTm9kZSA9IFR5cGVzLk5vZGVcblxudHlwZSAnYSB0ID0gJ2EgVHlwZXMuU3RlcF9mdW5jdGlvbl9ub2RlLnQgPVxuICB7IG1haW4gOiAnYSBOb2RlLnRcbiAgOyBtdXRhYmxlIGNoaWxkIDogJ2EgU3RlcF9mdW5jdGlvbi50IE5vZGUudCBVb3B0LnRcbiAgOyBtdXRhYmxlIGV4dHJhY3RlZF9zdGVwX2Z1bmN0aW9uX2Zyb21fY2hpbGRfYXQgOiBTdGFiaWxpemF0aW9uX251bS50XG4gIDsgbXV0YWJsZSB2YWx1ZSA6ICdhIFVvcHQudFxuICA7IG11dGFibGUgdXBjb21pbmdfc3RlcHMgOiAoVGltZV9ucy50ICogJ2EpIFNlcXVlbmNlLnRcbiAgOyBtdXRhYmxlIGFsYXJtIDogQWxhcm0udFxuICA7IG11dGFibGUgYWxhcm1fdmFsdWUgOiAoQWxhcm1fdmFsdWUudFtAc2V4cC5vcGFxdWVdKVxuICA7IGNsb2NrIDogKFR5cGVzLkNsb2NrLnRbQHNleHAub3BhcXVlXSlcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxubGV0IHBoeXNfc2FtZSAodDEgOiBfIHQpICh0MiA6IF8gdCkgPSBwaHlzX3NhbWUgdDEgdDJcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfm1haW46XG4gICAgICAgIChjaGVjayAoZnVuIChtYWluIDogXyBOb2RlLnQpIC0+XG4gICAgICAgICAgIG1hdGNoIG1haW4ua2luZCB3aXRoXG4gICAgICAgICAgIHwgSW52YWxpZCAtPiAoKVxuICAgICAgICAgICB8IENvbnN0IF8gLT4gKCkgKCogaGFwcGVucyB3aGVuIFt1cGNvbWluZ19zdGVwc10gYmVjb21lcyBlbXB0eS4gKilcbiAgICAgICAgICAgfCBTdGVwX2Z1bmN0aW9uIHQnIC0+IGFzc2VydCAocGh5c19lcXVhbCB0IHQnKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5jaGlsZDppZ25vcmVcbiAgICAgIH5leHRyYWN0ZWRfc3RlcF9mdW5jdGlvbl9mcm9tX2NoaWxkX2F0Omlnbm9yZVxuICAgICAgfnZhbHVlOihjaGVjayAoVW9wdC5pbnZhcmlhbnQgaW52YXJpYW50X2EpKVxuICAgICAgfnVwY29taW5nX3N0ZXBzOmlnbm9yZVxuICAgICAgfmFsYXJtOihjaGVjayBBbGFybS5pbnZhcmlhbnQpXG4gICAgICB+YWxhcm1fdmFsdWU6XG4gICAgICAgIChjaGVjayAoZnVuIChhbGFybV92YWx1ZSA6IEFsYXJtX3ZhbHVlLnQpIC0+XG4gICAgICAgICAgIG1hdGNoIGFsYXJtX3ZhbHVlLmFjdGlvbiB3aXRoXG4gICAgICAgICAgIHwgU3RlcF9mdW5jdGlvbiB0MiAtPiBhc3NlcnQgKHBoeXNfc2FtZSB0IHQyKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5jbG9jazppZ25vcmUpXG47O1xuXG5sZXQgcmVjIGFkdmFuY2VfaW50ZXJuYWwgdCB+dG9fIGExIHN0ZXBzID1cbiAgbWF0Y2ggU2VxdWVuY2UubmV4dCBzdGVwcyB3aXRoXG4gIHwgU29tZSAoKHN0ZXBfYXQsIGEyKSwgc3RlcHMyKSB3aGVuIFRpbWVfbnMuKCA+PSApIHRvXyBzdGVwX2F0IC0+XG4gICAgYWR2YW5jZV9pbnRlcm5hbCB0IH50b18gYTIgc3RlcHMyXG4gIHwgXyAtPlxuICAgIHQudmFsdWUgPC0gVW9wdC5zb21lIGExO1xuICAgIHQudXBjb21pbmdfc3RlcHMgPC0gc3RlcHNcbjs7XG5cbmxldCBhZHZhbmNlIHQgfnRvXyA9IGFkdmFuY2VfaW50ZXJuYWwgdCB+dG9fIChVb3B0LnZhbHVlX2V4biB0LnZhbHVlKSB0LnVwY29taW5nX3N0ZXBzXG4iLCJvcGVuIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIE5vZGUgPSBUeXBlcy5Ob2RlXG5cbnR5cGUgKCdhLCAnYWNjKSB0ID0gKCdhLCAnYWNjKSBUeXBlcy5BcnJheV9mb2xkLnQgPVxuICB7IGluaXQgOiAnYWNjXG4gIDsgZiA6ICdhY2MgLT4gJ2EgLT4gJ2FjY1xuICA7IGNoaWxkcmVuIDogJ2EgTm9kZS50IGFycmF5XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgaW52YXJpYW50X2FjYyB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiAoXywgXykgdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+aW5pdDooY2hlY2sgaW52YXJpYW50X2FjYylcbiAgICAgIH5mOmlnbm9yZVxuICAgICAgfmNoaWxkcmVuOlxuICAgICAgICAoY2hlY2sgKGZ1biBjaGlsZHJlbiAtPlxuICAgICAgICAgICBBcnJheS5pdGVyIGNoaWxkcmVuIH5mOihmdW4gKGNoaWxkIDogXyBOb2RlLnQpIC0+XG4gICAgICAgICAgICAgVW9wdC5pbnZhcmlhbnQgaW52YXJpYW50X2EgY2hpbGQudmFsdWVfb3B0KSkpKVxuOztcblxubGV0IGNvbXB1dGUgeyBpbml0OyBmOyBjaGlsZHJlbiB9ID1cbiAgbGV0IHJlc3VsdCA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggY2hpbGRyZW4gLSAxIGRvXG4gICAgcmVzdWx0IDo9IGYgIXJlc3VsdCAoVW9wdC52YWx1ZV9leG4gKEFycmF5LnVuc2FmZV9nZXQgY2hpbGRyZW4gaSkudmFsdWVfb3B0KVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4gVHlwZXMuS2luZFxubW9kdWxlIE5vZGUgPSBUeXBlcy5Ob2RlXG5cbnR5cGUgdCA9IFR5cGVzLkF0LnQgPVxuICB7IG1haW4gOiBCZWZvcmVfb3JfYWZ0ZXIudCBOb2RlLnRcbiAgOyBhdCA6IFRpbWVfbnMudFxuICA7IG11dGFibGUgYWxhcm0gOiBBbGFybS50XG4gIDsgY2xvY2sgOiAoVHlwZXMuQ2xvY2sudFtAc2V4cC5vcGFxdWVdKVxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfm1haW46XG4gICAgICAgIChjaGVjayAoZnVuIChtYWluIDogQmVmb3JlX29yX2FmdGVyLnQgTm9kZS50KSAtPlxuICAgICAgICAgICBtYXRjaCBtYWluLmtpbmQgd2l0aFxuICAgICAgICAgICB8IEludmFsaWQgLT4gKClcbiAgICAgICAgICAgfCBDb25zdCBBZnRlciAtPiAoKSAoKiBoYXBwZW5zIG9uY2UgdGhlIGN1cnJlbnQgdGltZSBwYXNzZXMgW3QuYXRdLiAqKVxuICAgICAgICAgICB8IEF0IHQnIC0+IGFzc2VydCAocGh5c19lcXVhbCB0IHQnKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5hdDppZ25vcmVcbiAgICAgIH5hbGFybTooY2hlY2sgQWxhcm0uaW52YXJpYW50KVxuICAgICAgfmNsb2NrOmlnbm9yZSlcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiBUeXBlcy5LaW5kXG5tb2R1bGUgTm9kZSA9IFR5cGVzLk5vZGVcblxudHlwZSB0ID0gVHlwZXMuQXRfaW50ZXJ2YWxzLnQgPVxuICB7IG1haW4gOiB1bml0IE5vZGUudFxuICA7IGJhc2UgOiBUaW1lX25zLnRcbiAgOyBpbnRlcnZhbCA6IFRpbWVfbnMuU3Bhbi50XG4gIDsgbXV0YWJsZSBhbGFybSA6IEFsYXJtLnRcbiAgOyBjbG9jayA6IChUeXBlcy5DbG9jay50W0BzZXhwLm9wYXF1ZV0pXG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+bWFpbjpcbiAgICAgICAgKGNoZWNrIChmdW4gKG1haW4gOiBfIE5vZGUudCkgLT5cbiAgICAgICAgICAgbWF0Y2ggbWFpbi5raW5kIHdpdGhcbiAgICAgICAgICAgfCBJbnZhbGlkIC0+ICgpXG4gICAgICAgICAgIHwgQXRfaW50ZXJ2YWxzIHQnIC0+IGFzc2VydCAocGh5c19lcXVhbCB0IHQnKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5iYXNlOmlnbm9yZVxuICAgICAgfmludGVydmFsOihjaGVjayAoZnVuIGludGVydmFsIC0+IGFzc2VydCAoVGltZV9ucy5TcGFuLmlzX3Bvc2l0aXZlIGludGVydmFsKSkpXG4gICAgICB+YWxhcm06KGNoZWNrIEFsYXJtLmludmFyaWFudClcbiAgICAgIH5jbG9jazppZ25vcmUpXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4gVHlwZXMuS2luZFxubW9kdWxlIEJpbmQgPSBUeXBlcy5CaW5kXG5tb2R1bGUgTm9kZSA9IFR5cGVzLk5vZGVcbm1vZHVsZSBTY29wZSA9IFR5cGVzLlNjb3BlXG5cbnR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIEJpbmQudCA9XG4gIHsgbWFpbiA6ICdiIE5vZGUudFxuICA7ICgqIFtmXSBpcyB0aGUgdXNlci1zdXBwbGllZCBmdW5jdGlvbiB0aGF0IHdlIHJ1biBlYWNoIHRpbWUgW3QubGhzXSBjaGFuZ2VzLiAgSXQgaXNcbiAgICAgICBtdXRhYmxlIG9ubHkgc28gd2UgY2FuIGNsZWFyIGl0IHdoZW4gW3RdIGlzIGludmFsaWRhdGVkLiAqKVxuICAgIG11dGFibGUgZiA6ICdhIC0+ICdiIE5vZGUudFxuICA7IGxocyA6ICdhIE5vZGUudFxuICA7IGxoc19jaGFuZ2UgOiB1bml0IE5vZGUudFxuICA7ICgqIFtyaHNdIGlzIGluaXRpYWxseSBbbm9uZV0sIGFuZCBhZnRlciB0aGF0IGlzIFtzb21lXSBvZiB0aGUgcmVzdWx0IG9mIHRoZSBtb3N0IHJlY2VudFxuICAgICAgIGNhbGwgdG8gW2ZdLiAqKVxuICAgIG11dGFibGUgcmhzIDogJ2IgTm9kZS50IFVvcHQudFxuICA7ICgqIFtyaHNfc2NvcGVdIGlzIHRoZSBzY29wZSBpbiB3aGljaCBbdC5mXSBpcyBydW4sIGkuZS4gaXQgaXMgW1Njb3BlLkJpbmQgdF0uICBJdCBpc1xuICAgICAgIFttdXRhYmxlXSBvbmx5IHRvIGF2b2lkIGEgW2xldCByZWNdIGR1cmluZyBjcmVhdGlvbi4gKilcbiAgICBtdXRhYmxlIHJoc19zY29wZSA6IFNjb3BlLnRcbiAgOyAoKiBbYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzXSBpcyB0aGUgaGVhZCBvZiB0aGUgc2luZ2x5LWxpbmtlZCBsaXN0IG9mIG5vZGVzIGNyZWF0ZWQgb25cbiAgICAgICB0aGUgcmlnaHQtaGFuZCBzaWRlIG9mIFt0XSwgaS5lLiBpbiBbdC5yaHNfc2NvcGVdLiAqKVxuICAgIG11dGFibGUgYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzIDogTm9kZS5QYWNrZWQudCBVb3B0LnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxubGV0IHNhbWUgKHQxIDogKF8sIF8pIHQpICh0MiA6IChfLCBfKSB0KSA9IHBoeXNfc2FtZSB0MSB0MlxuXG5sZXQgaXNfdmFsaWQgdCA9XG4gIG1hdGNoIHQubWFpbi5raW5kIHdpdGhcbiAgfCBJbnZhbGlkIC0+IGZhbHNlXG4gIHwgXyAtPiB0cnVlXG47O1xuXG5sZXQgaXRlcl9ub2Rlc19jcmVhdGVkX29uX3JocyB0IH4oZiA6IE5vZGUuUGFja2VkLnQgLT4gdW5pdCkgPVxuICBsZXQgciA9IHJlZiB0LmFsbF9ub2Rlc19jcmVhdGVkX29uX3JocyBpblxuICB3aGlsZSBVb3B0LmlzX3NvbWUgIXIgZG9cbiAgICBsZXQgKFQgbm9kZV9vbl9yaHMpID0gVW9wdC51bnNhZmVfdmFsdWUgIXIgaW5cbiAgICByIDo9IG5vZGVfb25fcmhzLm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlO1xuICAgIGYgKFQgbm9kZV9vbl9yaHMpXG4gIGRvbmVcbjs7XG5cbmxldCBpbnZhcmlhbnQgX2ludmFyaWFudF9hIF9pbnZhcmlhbnRfYiB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiAoXywgXykgdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+bWFpbjpcbiAgICAgICAgKGNoZWNrIChmdW4gKG1haW4gOiBfIE5vZGUudCkgLT5cbiAgICAgICAgICAgbWF0Y2ggbWFpbi5raW5kIHdpdGhcbiAgICAgICAgICAgfCBJbnZhbGlkIC0+ICgpXG4gICAgICAgICAgIHwgQmluZF9tYWluIHQnIC0+IGFzc2VydCAoc2FtZSB0IHQnKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5mOmlnbm9yZVxuICAgICAgfmxoczppZ25vcmVcbiAgICAgIH5saHNfY2hhbmdlOlxuICAgICAgICAoY2hlY2sgKGZ1biAobGhzX2NoYW5nZSA6IF8gTm9kZS50KSAtPlxuICAgICAgICAgICBhc3NlcnQgKHBoeXNfZXF1YWwgbGhzX2NoYW5nZS5jcmVhdGVkX2luIHQubWFpbi5jcmVhdGVkX2luKTtcbiAgICAgICAgICAgbWF0Y2ggbGhzX2NoYW5nZS5raW5kIHdpdGhcbiAgICAgICAgICAgfCBJbnZhbGlkIC0+ICgpXG4gICAgICAgICAgIHwgQmluZF9saHNfY2hhbmdlIHQnIC0+IGFzc2VydCAoc2FtZSB0IHQnKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5yaHM6aWdub3JlXG4gICAgICB+cmhzX3Njb3BlOlxuICAgICAgICAoY2hlY2sgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBTY29wZS5Ub3AgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBCaW5kIHQnIC0+IGFzc2VydCAoc2FtZSB0IHQnKSkpXG4gICAgICB+YWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzOlxuICAgICAgICAoY2hlY2sgKGZ1biBfIC0+XG4gICAgICAgICAgIGl0ZXJfbm9kZXNfY3JlYXRlZF9vbl9yaHMgdCB+ZjooZnVuIChUIG5vZGUpIC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChwaHlzX2VxdWFsIG5vZGUuY3JlYXRlZF9pbiB0LnJoc19zY29wZSk7XG4gICAgICAgICAgICAgaWYgTm9kZS5pc19uZWNlc3Nhcnkgbm9kZSB0aGVuIGFzc2VydCAodC5saHNfY2hhbmdlLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSkpKSlcbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBOb2RlID0gVHlwZXMuTm9kZVxuXG50eXBlICdhIGVkZ2UgPSAnYSBUeXBlcy5FeHBlcnQuZWRnZSA9XG4gIHsgY2hpbGQgOiAnYSBOb2RlLnRcbiAgOyBvbl9jaGFuZ2UgOiAnYSAtPiB1bml0XG4gIDsgKCogW2luZGV4XSBpcyBkZWZpbmVkIHdoZW5ldmVyIHRoZSBbZWRnZV0gaXMgaW4gdGhlIFtjaGlsZHJlbl0gb2Ygc29tZSBbdF0uIFRoZW4gaXQgaXNcbiAgICAgICB0aGUgaW5kZXggb2YgdGhpcyBbZWRnZV0gaW4gdGhhdCBbY2hpbGRyZW5dIGFycmF5LiBJdCBtaWdodCBzZWVtIHJlZHVuZGFudCB3aXRoIGFsbFxuICAgICAgIHRoZSBvdGhlciBpbmRleGVzIHdlIGhhdmUsIGJ1dCBpdCBpcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGNoaWxkcmVuLiAgVGhlIGluZGV4IG1heVxuICAgICAgIGNoYW5nZSBhcyBzaWJsaW5nIGNoaWxkcmVuIGFyZSByZW1vdmVkLiAqKVxuICAgIG11dGFibGUgaW5kZXggOiBpbnQgVW9wdC50XG4gIH1cbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbnR5cGUgcGFja2VkX2VkZ2UgPSBUeXBlcy5FeHBlcnQucGFja2VkX2VkZ2UgPSBFIDogJ2EgZWRnZSAtPiBwYWNrZWRfZWRnZVxuW0BAdW5ib3hlZF0gW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxudHlwZSAnYSB0ID0gJ2EgVHlwZXMuRXhwZXJ0LnQgPVxuICB7IGYgOiB1bml0IC0+ICdhXG4gIDsgb25fb2JzZXJ2YWJpbGl0eV9jaGFuZ2UgOiBpc19ub3dfb2JzZXJ2YWJsZTpib29sIC0+IHVuaXRcbiAgOyBtdXRhYmxlIGNoaWxkcmVuIDogcGFja2VkX2VkZ2UgVW9wdC50IFVuaWZvcm1fYXJyYXkudFxuICA7IG11dGFibGUgbnVtX2NoaWxkcmVuIDogaW50XG4gIDsgKCogV2hlbiBzZXQsIG1ha2VzIHRoZSBub2RlIG9mIFt0XSBzdGFsZS4gIEl0IGlzIHNldCB3aGVuIHRoZSBzZXQgb2YgY2hpbGRyZW4gY2hhbmdlcy5cbiAgICAgICBPdGhlcndpc2UgdGhlIG5vcm1hbCBjaGVjayBvZiBzdGFsZW5lc3MgKGNvbXBhcmluZyB0aGUgW2NoYW5nZWRfYXRdIGZpZWxkIG9mXG4gICAgICAgY2hpbGRyZW4gYW5kIHRoZSBbcmVjb21wdXRlZF9hdF0gZmllbGQgZm9yIHRoZSBub2RlIG9mIFt0XSkgd291bGQgbm90IGJlIGVub3VnaC5cbiAgICAgICBUaGlzIHBsYXlzIGEgcm9sZSBzaW1pbGFyIHRvIHRoZSBjdXRvZmYgb2YgW05ldmVyXSBmb3IgdGhlIGxocy1jaGFuZ2Ugb2YgYmluZHMsIGJ1dFxuICAgICAgIHdlIGRvbid0IGhhdmUgYSBzcGVjaWFsIGNoaWxkLiAqKVxuICAgIG11dGFibGUgZm9yY2Vfc3RhbGUgOiBib29sXG4gIDsgKCogVGhlIG51bWJlciBvZiBpbnZhbGlkIGNoaWxkcmVuIHRoYXQgcG9pbnQgdG8gdXMuICBVc2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBub2RlXG4gICAgICAgb2YgW3RdIG5lZWRzIHRvIGludmFsaWRhdGVkLCB3aXRob3V0IGl0ZXJhdGluZyBvdmVyIGFsbCB0aGUgY2hpbGRyZW4uICBUaGlzIGlzIG5vdFxuICAgICAgIG5lZWRlZCBmb3Igb3RoZXIgbm9kZXMsIGJlY2F1c2UgdGhlcmUgYXJlIG5vIG90aGVyIG5vZGVzIHRoYXQgaGF2ZSBhIHBvdGVudGlhbGx5XG4gICAgICAgbGFyZ2UgYW5kIGR5bmFtaWMgc2V0IG9mIGNoaWxkcmVuLiAqKVxuICAgIG11dGFibGUgbnVtX2ludmFsaWRfY2hpbGRyZW4gOiBpbnRcbiAgOyAoKiBXaGV0aGVyIHdlIHdpbGwgZmlyZSB0aGUgW29uX2NoYW5nZV0gY2FsbGJhY2tzIGZvciBhbGwgY2hpbGRyZW4gd2hlbiB0aGUgbm9kZSBvZiBbdF1cbiAgICAgICBpdHNlbGYgcnVucy4gIFVzZWQgdG8gbWFrZSBzdXJlIHdlIHJlcnVuIGV2ZXJ5dGhpbmcgYWZ0ZXIgW3RdIHN3aXRjaGVzIGZyb21cbiAgICAgICB1bm9ic2VydmFibGUgYW5kIGJhY2sgdG8gb2JzZXJ2YWJsZS4gKilcbiAgICBtdXRhYmxlIHdpbGxfZmlyZV9hbGxfY2FsbGJhY2tzIDogYm9vbFxuICB9XG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50XG4gIF9pbnZhcmlhbnRfYVxuICB7IGYgPSBfXG4gIDsgY2hpbGRyZW5cbiAgOyBudW1fY2hpbGRyZW5cbiAgOyBmb3JjZV9zdGFsZSA9IF9cbiAgOyBudW1faW52YWxpZF9jaGlsZHJlblxuICA7IG9uX29ic2VydmFiaWxpdHlfY2hhbmdlID0gX1xuICA7IHdpbGxfZmlyZV9hbGxfY2FsbGJhY2tzID0gX1xuICB9XG4gID1cbiAgYXNzZXJ0IChudW1fY2hpbGRyZW4gPD0gVW5pZm9ybV9hcnJheS5sZW5ndGggY2hpbGRyZW4pO1xuICBpZ25vcmUgbnVtX2ludmFsaWRfY2hpbGRyZW47XG4gICgqIGludmFyaWFudCBpcyBiZWxvdywgYmVjYXVzZSB3ZSBuZWVkIHNvbWUgY29udGV4dCAqKVxuICBVbmlmb3JtX2FycmF5Lml0ZXJpIGNoaWxkcmVuIH5mOihmdW4gaSB1b3B0IC0+XG4gICAgbWF0Y2ggaSA8IG51bV9jaGlsZHJlbiB3aXRoXG4gICAgfCB0cnVlIC0+XG4gICAgICBsZXQgKEUgcikgPSBVb3B0LnZhbHVlX2V4biB1b3B0IGluXG4gICAgICBbJXRlc3RfcmVzdWx0OiBpbnRdIChVb3B0LnZhbHVlX2V4biByLmluZGV4KSB+ZXhwZWN0OmlcbiAgICB8IGZhbHNlIC0+IGFzc2VydCAoVW9wdC5pc19ub25lIHVvcHQpKVxuOztcblxubGV0IGludmFyaWFudF9hYm91dF9udW1faW52YWxpZF9jaGlsZHJlbiB0IH5pc19uZWNlc3NhcnkgPVxuICBsZXQgeyBjaGlsZHJlbjsgbnVtX2NoaWxkcmVuOyBudW1faW52YWxpZF9jaGlsZHJlbjsgXyB9ID0gdCBpblxuICBpZiBub3QgaXNfbmVjZXNzYXJ5XG4gIHRoZW4gWyV0ZXN0X3Jlc3VsdDogaW50XSBudW1faW52YWxpZF9jaGlsZHJlbiB+ZXhwZWN0OjBcbiAgZWxzZSAoXG4gICAgbGV0IGNvdW50X2ludmFsaWRfY2hpbGRyZW4gPSByZWYgMCBpblxuICAgIGZvciBpID0gMCB0byBudW1fY2hpbGRyZW4gLSAxIGRvXG4gICAgICBsZXQgKEUgcikgPSBVb3B0LnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS5nZXQgY2hpbGRyZW4gaSkgaW5cbiAgICAgIGlmIG5vdCAoTm9kZS5pc192YWxpZCByLmNoaWxkKSB0aGVuIGluY3IgY291bnRfaW52YWxpZF9jaGlsZHJlblxuICAgIGRvbmU7XG4gICAgWyV0ZXN0X3Jlc3VsdDogaW50XSBudW1faW52YWxpZF9jaGlsZHJlbiB+ZXhwZWN0OiFjb3VudF9pbnZhbGlkX2NoaWxkcmVuKVxuOztcblxubGV0IGNyZWF0ZSB+ZiB+b25fb2JzZXJ2YWJpbGl0eV9jaGFuZ2UgPVxuICB7IGZcbiAgOyBvbl9vYnNlcnZhYmlsaXR5X2NoYW5nZVxuICA7IGNoaWxkcmVuID0gVW5pZm9ybV9hcnJheS5lbXB0eVxuICA7IG51bV9jaGlsZHJlbiA9IDBcbiAgOyBmb3JjZV9zdGFsZSA9IGZhbHNlXG4gIDsgbnVtX2ludmFsaWRfY2hpbGRyZW4gPSAwXG4gIDsgd2lsbF9maXJlX2FsbF9jYWxsYmFja3MgPSB0cnVlXG4gIH1cbjs7XG5cbmxldCBtYWtlX3N0YWxlIHQgPVxuICBpZiB0LmZvcmNlX3N0YWxlXG4gIHRoZW4gYEFscmVhZHlfc3RhbGVcbiAgZWxzZSAoXG4gICAgdC5mb3JjZV9zdGFsZSA8LSB0cnVlO1xuICAgIGBPaylcbjs7XG5cbmxldCBpbmNyX2ludmFsaWRfY2hpbGRyZW4gdCA9IHQubnVtX2ludmFsaWRfY2hpbGRyZW4gPC0gdC5udW1faW52YWxpZF9jaGlsZHJlbiArIDFcbmxldCBkZWNyX2ludmFsaWRfY2hpbGRyZW4gdCA9IHQubnVtX2ludmFsaWRfY2hpbGRyZW4gPC0gdC5udW1faW52YWxpZF9jaGlsZHJlbiAtIDFcblxubGV0IG1ha2Vfc3BhY2VfZm9yX2NoaWxkX2lmX25lY2Vzc2FyeSB0ID1cbiAgaWYgdC5udW1fY2hpbGRyZW4gPj0gVW5pZm9ybV9hcnJheS5sZW5ndGggdC5jaGlsZHJlblxuICB0aGVuIChcbiAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAodC5udW1fY2hpbGRyZW4gPSBVbmlmb3JtX2FycmF5Lmxlbmd0aCB0LmNoaWxkcmVuKTtcbiAgICBsZXQgbmV3X21heCA9IEludC5tYXggMiAoMiAqIFVuaWZvcm1fYXJyYXkubGVuZ3RoIHQuY2hpbGRyZW4pIGluXG4gICAgdC5jaGlsZHJlbiA8LSBVbmlmb3JtX2FycmF5LnJlYWxsb2MgdC5jaGlsZHJlbiB+bGVuOm5ld19tYXgpXG47O1xuXG5sZXQgYWRkX2NoaWxkX2VkZ2UgdCBwYWNrZWRfZWRnZSA9XG4gIGxldCAoRSBlZGdlKSA9IHBhY2tlZF9lZGdlIGluXG4gIGFzc2VydCAoVW9wdC5pc19ub25lIGVkZ2UuaW5kZXgpO1xuICBtYWtlX3NwYWNlX2Zvcl9jaGlsZF9pZl9uZWNlc3NhcnkgdDtcbiAgbGV0IG5ld19jaGlsZF9pbmRleCA9IHQubnVtX2NoaWxkcmVuIGluXG4gIGVkZ2UuaW5kZXggPC0gVW9wdC5zb21lIG5ld19jaGlsZF9pbmRleDtcbiAgVW5pZm9ybV9hcnJheS5zZXQgdC5jaGlsZHJlbiBuZXdfY2hpbGRfaW5kZXggKFVvcHQuc29tZSBwYWNrZWRfZWRnZSk7XG4gIHQubnVtX2NoaWxkcmVuIDwtIHQubnVtX2NoaWxkcmVuICsgMTtcbiAgdC5mb3JjZV9zdGFsZSA8LSB0cnVlO1xuICAoKiBXZSB3aWxsIGJ1bXAgdGhlIG51bWJlciBvZiBpbnZhbGlkIGNoaWxkcmVuIGlmIG5lY2Vzc2FyeSB3aGVuIGNvbm5lY3RpbmcgY2hpbGQgYW5kXG4gICAgIHBhcmVudC4gIFNhbWUgdGhpbmcgZm9yIHJ1bm5pbmcgdGhlIFtvbl9jaGFuZ2VdIGNhbGxiYWNrcy4gKilcbiAgbmV3X2NoaWxkX2luZGV4XG47O1xuXG5sZXQgc3dhcF9jaGlsZHJlbiB0IH5jaGlsZF9pbmRleDEgfmNoaWxkX2luZGV4MiA9XG4gIGxldCAoRSBlZGdlMSkgPSBVb3B0LnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS5nZXQgdC5jaGlsZHJlbiBjaGlsZF9pbmRleDEpIGluXG4gIGxldCAoRSBlZGdlMikgPSBVb3B0LnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS5nZXQgdC5jaGlsZHJlbiBjaGlsZF9pbmRleDIpIGluXG4gIGVkZ2UxLmluZGV4IDwtIFVvcHQuc29tZSBjaGlsZF9pbmRleDI7XG4gIGVkZ2UyLmluZGV4IDwtIFVvcHQuc29tZSBjaGlsZF9pbmRleDE7XG4gIFVuaWZvcm1fYXJyYXkuc3dhcCB0LmNoaWxkcmVuIGNoaWxkX2luZGV4MSBjaGlsZF9pbmRleDJcbjs7XG5cbmxldCBsYXN0X2NoaWxkX2VkZ2VfZXhuIHQgPVxuICBsZXQgbGFzdF9pbmRleCA9IHQubnVtX2NoaWxkcmVuIC0gMSBpblxuICBVb3B0LnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS5nZXQgdC5jaGlsZHJlbiBsYXN0X2luZGV4KVxuOztcblxubGV0IHJlbW92ZV9sYXN0X2NoaWxkX2VkZ2VfZXhuIHQgPVxuICBsZXQgbGFzdF9pbmRleCA9IHQubnVtX2NoaWxkcmVuIC0gMSBpblxuICBsZXQgcGFja2VkX2VkZ2Vfb3B0ID0gVW5pZm9ybV9hcnJheS5nZXQgdC5jaGlsZHJlbiBsYXN0X2luZGV4IGluXG4gIFVuaWZvcm1fYXJyYXkuc2V0IHQuY2hpbGRyZW4gbGFzdF9pbmRleCBVb3B0Lm5vbmU7XG4gIHQubnVtX2NoaWxkcmVuIDwtIGxhc3RfaW5kZXg7XG4gIHQuZm9yY2Vfc3RhbGUgPC0gdHJ1ZTtcbiAgYXNzZXJ0IChVb3B0LmlzX3NvbWUgcGFja2VkX2VkZ2Vfb3B0KTtcbiAgbGV0IChFIGVkZ2UpID0gVW9wdC51bnNhZmVfdmFsdWUgcGFja2VkX2VkZ2Vfb3B0IGluXG4gIGVkZ2UuaW5kZXggPC0gVW9wdC5ub25lXG47O1xuXG5sZXQgYmVmb3JlX21haW5fY29tcHV0YXRpb24gdCA9XG4gIGlmIHQubnVtX2ludmFsaWRfY2hpbGRyZW4gPiAwXG4gIHRoZW4gYEludmFsaWRcbiAgZWxzZSAoXG4gICAgdC5mb3JjZV9zdGFsZSA8LSBmYWxzZTtcbiAgICBsZXQgd2lsbF9maXJlX2FsbF9jYWxsYmFja3MgPSB0LndpbGxfZmlyZV9hbGxfY2FsbGJhY2tzIGluXG4gICAgdC53aWxsX2ZpcmVfYWxsX2NhbGxiYWNrcyA8LSBmYWxzZTtcbiAgICBpZiB3aWxsX2ZpcmVfYWxsX2NhbGxiYWNrc1xuICAgIHRoZW5cbiAgICAgIGZvciBpID0gMCB0byB0Lm51bV9jaGlsZHJlbiAtIDEgZG9cbiAgICAgICAgbGV0IChFIHIpID0gVW9wdC52YWx1ZV9leG4gKFVuaWZvcm1fYXJyYXkuZ2V0IHQuY2hpbGRyZW4gaSkgaW5cbiAgICAgICAgci5vbl9jaGFuZ2UgKFVvcHQudmFsdWVfZXhuIHIuY2hpbGQudmFsdWVfb3B0KVxuICAgICAgZG9uZTtcbiAgICBgT2spXG47O1xuXG5sZXQgb2JzZXJ2YWJpbGl0eV9jaGFuZ2UgdCB+aXNfbm93X29ic2VydmFibGUgPVxuICB0Lm9uX29ic2VydmFiaWxpdHlfY2hhbmdlIH5pc19ub3dfb2JzZXJ2YWJsZTtcbiAgaWYgbm90IGlzX25vd19vYnNlcnZhYmxlXG4gIHRoZW4gKFxuICAgIHQud2lsbF9maXJlX2FsbF9jYWxsYmFja3MgPC0gdHJ1ZTtcbiAgICAoKiBJZiB3ZSBkb24ndCByZXNldCBudW1faW52YWxpZF9jaGlsZHJlbiwgd2Ugd291bGQgZG91YmxlIGNvdW50IHRoZW06IGp1c3QgaW1hZ2luZVxuICAgICAgIHdoYXQgaGFwcGVucyB3ZSBpZiByZWNvbm5lY3QvZGlzY29ubmVjdC9yZWNvbm5lY3QvZGlzY29ubmVjdCB3aXRoIGFuIGludmFsaWRcbiAgICAgICBjaGlsZC4gKilcbiAgICB0Lm51bV9pbnZhbGlkX2NoaWxkcmVuIDwtIDApXG47O1xuXG5sZXQgcnVuX2VkZ2VfY2FsbGJhY2sgdCB+Y2hpbGRfaW5kZXggPVxuICBpZiBub3QgdC53aWxsX2ZpcmVfYWxsX2NhbGxiYWNrc1xuICB0aGVuIChcbiAgICBsZXQgKEUgcikgPSBVb3B0LnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS5nZXQgdC5jaGlsZHJlbiBjaGlsZF9pbmRleCkgaW5cbiAgICAoKiBUaGlzIHZhbHVlIGlzIG5vdCBuZWNlc3NhcmlseSBzZXQsIGJlY2F1c2Ugd2UgdHJ5IHRvIHJ1biB0aGlzIHdoZW4gY29ubmVjdGluZyB0aGVcbiAgICAgICBub2RlIHRvIGl0cyBjaGlsZHJlbiwgd2hpY2ggY291bGQgYmUgYmVmb3JlIHRoZXkgaGF2ZSBydW4gZXZlbiBvbmNlLiAgQWxzbyB0aGUgbm9kZVxuICAgICAgIGNvdWxkIGJlIGludmFsaWQuICopXG4gICAgaWYgVW9wdC5pc19zb21lIHIuY2hpbGQudmFsdWVfb3B0XG4gICAgdGhlbiByLm9uX2NoYW5nZSAoVW9wdC51bnNhZmVfdmFsdWUgci5jaGlsZC52YWx1ZV9vcHQpKVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgTm9kZSA9IFR5cGVzLk5vZGVcbmluY2x1ZGUgVHlwZXMuU2NvcGVcblxubGV0IHRvcCA9IFRvcFxuXG5sZXQgaXNfdG9wID0gZnVuY3Rpb25cbiAgfCBUb3AgLT4gdHJ1ZVxuICB8IEJpbmQgXyAtPiBmYWxzZVxuOztcblxubGV0IGludmFyaWFudCA9IGZ1bmN0aW9uXG4gIHwgVG9wIC0+ICgpXG4gIHwgQmluZCBiaW5kIC0+IEJpbmQuaW52YXJpYW50IGlnbm9yZSBpZ25vcmUgYmluZFxuOztcblxuKCogVW5saWtlIGZvciBub2RlcywgdGhlcmUgaXMgbm8gaW52YXJpYW50IFtpc19uZWNlc3NhcnkgdCA8PT4gaGVpZ2h0ID4gLTFdIChkb2Vzbid0IHdvcmtcbiAgIGJlY2F1c2Ugb2YgW1RvcF0pLiAgVGhpcyBpcyBmaW5lIHNpbmNlIHRoZSBoZWlnaHQgb2YgYSBzY29wZSBpcyBvbmx5IHVzZWQgdG8gY29uc3RyYWluXG4gICBvdGhlciBoZWlnaHRzLCBub3QgdG8gc2NoZWR1bGUgaXQuICopXG5sZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgfCBUb3AgLT4gLTFcbiAgfCBCaW5kIGJpbmQgLT4gYmluZC5saHNfY2hhbmdlLmhlaWdodFxuOztcblxubGV0IGlzX3ZhbGlkID0gZnVuY3Rpb25cbiAgfCBUb3AgLT4gdHJ1ZVxuICB8IEJpbmQgYmluZCAtPiBCaW5kLmlzX3ZhbGlkIGJpbmRcbjs7XG5cbmxldCBpc19uZWNlc3NhcnkgPSBmdW5jdGlvblxuICB8IFRvcCAtPiB0cnVlXG4gIHwgQmluZCBiaW5kIC0+IE5vZGUuaXNfbmVjZXNzYXJ5IGJpbmQubWFpblxuOztcblxubGV0IGFkZF9ub2RlIHQgKG5vZGUgOiBfIE5vZGUudCkgPVxuICBhc3NlcnQgKHBoeXNfZXF1YWwgbm9kZS5jcmVhdGVkX2luIHQpO1xuICBtYXRjaCB0IHdpdGhcbiAgfCBUb3AgLT4gKClcbiAgfCBCaW5kIGJpbmQgLT5cbiAgICBub2RlLm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlIDwtIGJpbmQuYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzO1xuICAgIGJpbmQuYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzIDwtIFVvcHQuc29tZSAoVHlwZXMuTm9kZS5QYWNrZWQuVCBub2RlKVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuIFR5cGVzLktpbmRcbm1vZHVsZSBOb2RlID0gVHlwZXMuTm9kZVxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5GcmVlemUudCA9XG4gIHsgbWFpbiA6ICdhIE5vZGUudFxuICA7IGNoaWxkIDogJ2EgTm9kZS50XG4gIDsgb25seV9mcmVlemVfd2hlbiA6ICdhIC0+IGJvb2xcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBfaW52YXJpYW50X2EgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5tYWluOlxuICAgICAgICAoY2hlY2sgKGZ1biAobWFpbiA6IF8gTm9kZS50KSAtPlxuICAgICAgICAgICBhc3NlcnQgKFNjb3BlLmlzX3RvcCBtYWluLmNyZWF0ZWRfaW4pO1xuICAgICAgICAgICBtYXRjaCBtYWluLmtpbmQgd2l0aFxuICAgICAgICAgICB8IEludmFsaWQgLT4gKCkgKCogaGFwcGVucyB3aGVuIGZyZWV6aW5nIGFuIGludmFsaWQgdmFsdWUgKilcbiAgICAgICAgICAgfCBDb25zdCBfIC0+ICgpICgqIGhhcHBlbnMgb24gYmVjb21pbmcgZnJvemVuICopXG4gICAgICAgICAgIHwgRnJlZXplIHQnIC0+IGFzc2VydCAocGh5c19lcXVhbCB0IHQnKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5jaGlsZDppZ25vcmVcbiAgICAgIH5vbmx5X2ZyZWV6ZV93aGVuOmlnbm9yZSlcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiBUeXBlcy5LaW5kXG5tb2R1bGUgTm9kZSA9IFR5cGVzLk5vZGVcblxudHlwZSAnYSB0ID0gJ2EgVHlwZXMuSWZfdGhlbl9lbHNlLnQgPVxuICB7IG1haW4gOiAnYSBOb2RlLnRcbiAgOyB0ZXN0IDogYm9vbCBOb2RlLnRcbiAgOyB0ZXN0X2NoYW5nZSA6IHVuaXQgTm9kZS50XG4gIDsgbXV0YWJsZSBjdXJyZW50X2JyYW5jaCA6ICdhIE5vZGUudCBVb3B0LnRcbiAgOyB0aGVuXyA6ICdhIE5vZGUudFxuICA7IGVsc2VfIDogJ2EgTm9kZS50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbmxldCBzYW1lICh0MSA6IF8gdCkgKHQyIDogXyB0KSA9IHBoeXNfc2FtZSB0MSB0MlxuXG5sZXQgaW52YXJpYW50IF9pbnZhcmlhbnRfYSB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfm1haW46XG4gICAgICAgIChjaGVjayAoZnVuIChtYWluIDogXyBOb2RlLnQpIC0+XG4gICAgICAgICAgIG1hdGNoIG1haW4ua2luZCB3aXRoXG4gICAgICAgICAgIHwgSW52YWxpZCAtPiAoKVxuICAgICAgICAgICB8IElmX3RoZW5fZWxzZSB0JyAtPiBhc3NlcnQgKHBoeXNfZXF1YWwgdCB0JylcbiAgICAgICAgICAgfCBfIC0+ICgpKSlcbiAgICAgIH50ZXN0Omlnbm9yZVxuICAgICAgfnRlc3RfY2hhbmdlOlxuICAgICAgICAoY2hlY2sgKGZ1biAodGVzdF9jaGFuZ2UgOiBfIE5vZGUudCkgLT5cbiAgICAgICAgICAgbWF0Y2ggdGVzdF9jaGFuZ2Uua2luZCB3aXRoXG4gICAgICAgICAgIHwgSW52YWxpZCAtPiAoKVxuICAgICAgICAgICB8IElmX3Rlc3RfY2hhbmdlIHQnIC0+IGFzc2VydCAoc2FtZSB0IHQnKVxuICAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKSlcbiAgICAgIH5jdXJyZW50X2JyYW5jaDpcbiAgICAgICAgKGNoZWNrIChmdW4gY3VycmVudF9icmFuY2ggLT5cbiAgICAgICAgICAgaWYgVW9wdC5pc19zb21lIGN1cnJlbnRfYnJhbmNoXG4gICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgIGxldCBjdXJyZW50X2JyYW5jaCA9IFVvcHQudmFsdWVfZXhuIGN1cnJlbnRfYnJhbmNoIGluXG4gICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgIHBoeXNfZXF1YWwgY3VycmVudF9icmFuY2ggdC50aGVuXyB8fCBwaHlzX2VxdWFsIGN1cnJlbnRfYnJhbmNoIHQuZWxzZV8pKSkpXG4gICAgICB+dGhlbl86aWdub3JlXG4gICAgICB+ZWxzZV86aWdub3JlKVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuIFR5cGVzLktpbmRcbm1vZHVsZSBOb2RlID0gVHlwZXMuTm9kZVxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5Kb2luLnQgPVxuICB7IG1haW4gOiAnYSBOb2RlLnRcbiAgOyBsaHMgOiAnYSBOb2RlLnQgTm9kZS50XG4gIDsgbGhzX2NoYW5nZSA6IHVuaXQgTm9kZS50XG4gIDsgbXV0YWJsZSByaHMgOiAnYSBOb2RlLnQgVW9wdC50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbmxldCBzYW1lICh0MSA6IF8gdCkgKHQyIDogXyB0KSA9IHBoeXNfc2FtZSB0MSB0MlxuXG5sZXQgaW52YXJpYW50IF9pbnZhcmlhbnRfYSB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfm1haW46XG4gICAgICAgIChjaGVjayAoZnVuIChtYWluIDogXyBOb2RlLnQpIC0+XG4gICAgICAgICAgIG1hdGNoIG1haW4ua2luZCB3aXRoXG4gICAgICAgICAgIHwgSW52YWxpZCAtPiAoKVxuICAgICAgICAgICB8IEpvaW5fbWFpbiB0JyAtPiBhc3NlcnQgKHNhbWUgdCB0JylcbiAgICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSkpXG4gICAgICB+bGhzOmlnbm9yZVxuICAgICAgfmxoc19jaGFuZ2U6XG4gICAgICAgIChjaGVjayAoZnVuIChsaHNfY2hhbmdlIDogXyBOb2RlLnQpIC0+XG4gICAgICAgICAgIG1hdGNoIGxoc19jaGFuZ2Uua2luZCB3aXRoXG4gICAgICAgICAgIHwgSW52YWxpZCAtPiAoKVxuICAgICAgICAgICB8IEpvaW5fbGhzX2NoYW5nZSB0JyAtPiBhc3NlcnQgKHNhbWUgdCB0JylcbiAgICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSkpXG4gICAgICB+cmhzOmlnbm9yZSlcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiBUeXBlcy5LaW5kXG5tb2R1bGUgTm9kZSA9IFR5cGVzLk5vZGVcblxudHlwZSAnYSB0ID0gJ2EgVHlwZXMuU25hcHNob3QudCA9XG4gIHsgbWFpbiA6ICdhIE5vZGUudFxuICA7IGF0IDogVGltZV9ucy50XG4gIDsgYmVmb3JlIDogJ2FcbiAgOyB2YWx1ZV9hdCA6ICdhIE5vZGUudFxuICA7IGNsb2NrIDogKFR5cGVzLkNsb2NrLnRbQHNleHAub3BhcXVlXSlcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfm1haW46XG4gICAgICAgIChjaGVjayAoZnVuIChtYWluIDogXyBOb2RlLnQpIC0+XG4gICAgICAgICAgIGFzc2VydCAoU2NvcGUuaXNfdG9wIG1haW4uY3JlYXRlZF9pbik7XG4gICAgICAgICAgIG1hdGNoIG1haW4ua2luZCB3aXRoXG4gICAgICAgICAgIHwgSW52YWxpZCAtPiAoKSAoKiBoYXBwZW5zIHdoZW4gc25hcHNob3R0aW5nIGFuIGludmFsaWQgbm9kZSAqKVxuICAgICAgICAgICB8IENvbnN0IF8gLT4gKCkgKCogaGFwcGVucyBhZnRlciB0aGUgc25hcHNob3QgKilcbiAgICAgICAgICAgfCBTbmFwc2hvdCB0JyAtPiBhc3NlcnQgKHBoeXNfZXF1YWwgdCB0JylcbiAgICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSkpXG4gICAgICB+YXQ6aWdub3JlXG4gICAgICB+YmVmb3JlOihjaGVjayBpbnZhcmlhbnRfYSlcbiAgICAgIH52YWx1ZV9hdDppZ25vcmVcbiAgICAgIH5jbG9jazppZ25vcmUpXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxubW9kdWxlIE5vZGUgPSBUeXBlcy5Ob2RlXG5cbnR5cGUgJ2EgdCA9ICdhIFR5cGVzLktpbmQudCA9XG4gIHwgQXJyYXlfZm9sZCA6IChfLCAnYSkgQXJyYXlfZm9sZC50IC0+ICdhIHRcbiAgfCBBdCA6IEF0LnQgLT4gQmVmb3JlX29yX2FmdGVyLnQgdFxuICB8IEF0X2ludGVydmFscyA6IEF0X2ludGVydmFscy50IC0+IHVuaXQgdFxuICB8IEJpbmRfbGhzX2NoYW5nZSA6IChfLCBfKSBCaW5kLnQgLT4gdW5pdCB0XG4gIHwgQmluZF9tYWluIDogKF8sICdhKSBCaW5kLnQgLT4gJ2EgdFxuICB8IENvbnN0IG9mICdhXG4gIHwgRXhwZXJ0IG9mICdhIEV4cGVydC50XG4gIHwgRnJlZXplIG9mICdhIEZyZWV6ZS50XG4gIHwgSWZfdGVzdF9jaGFuZ2UgOiBfIElmX3RoZW5fZWxzZS50IC0+IHVuaXQgdFxuICB8IElmX3RoZW5fZWxzZSBvZiAnYSBJZl90aGVuX2Vsc2UudFxuICB8IEludmFsaWRcbiAgfCBKb2luX2xoc19jaGFuZ2UgOiBfIEpvaW4udCAtPiB1bml0IHRcbiAgfCBKb2luX21haW4gb2YgJ2EgSm9pbi50XG4gIHwgTWFwIDogKCdhMSAtPiAnYSkgKiAnYTEgTm9kZS50IC0+ICdhIHRcbiAgfCBTbmFwc2hvdCBvZiAnYSBTbmFwc2hvdC50XG4gIHwgU3RlcF9mdW5jdGlvbiBvZiAnYSBTdGVwX2Z1bmN0aW9uX25vZGUudFxuICB8IFVuaW5pdGlhbGl6ZWRcbiAgfCBVbm9yZGVyZWRfYXJyYXlfZm9sZCA6IChfLCAnYSkgVW5vcmRlcmVkX2FycmF5X2ZvbGQudCAtPiAnYSB0XG4gIHwgVmFyIG9mICdhIFZhci50XG4gIHwgTWFwMiA6ICgnYTEgLT4gJ2EyIC0+ICdhKSAqICdhMSBOb2RlLnQgKiAnYTIgTm9kZS50IC0+ICdhIHRcbiAgfCBNYXAzIDogKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhKSAqICdhMSBOb2RlLnQgKiAnYTIgTm9kZS50ICogJ2EzIE5vZGUudCAtPiAnYSB0XG4gIHwgTWFwNCA6XG4gICAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhKSAqICdhMSBOb2RlLnQgKiAnYTIgTm9kZS50ICogJ2EzIE5vZGUudCAqICdhNCBOb2RlLnRcbiAgICAgIC0+ICdhIHRcbiAgfCBNYXA1IDpcbiAgICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhKVxuICAgICAgKiAnYTEgTm9kZS50XG4gICAgICAqICdhMiBOb2RlLnRcbiAgICAgICogJ2EzIE5vZGUudFxuICAgICAgKiAnYTQgTm9kZS50XG4gICAgICAqICdhNSBOb2RlLnRcbiAgICAgIC0+ICdhIHRcbiAgfCBNYXA2IDpcbiAgICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhNiAtPiAnYSlcbiAgICAgICogJ2ExIE5vZGUudFxuICAgICAgKiAnYTIgTm9kZS50XG4gICAgICAqICdhMyBOb2RlLnRcbiAgICAgICogJ2E0IE5vZGUudFxuICAgICAgKiAnYTUgTm9kZS50XG4gICAgICAqICdhNiBOb2RlLnRcbiAgICAgIC0+ICdhIHRcbiAgfCBNYXA3IDpcbiAgICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhNiAtPiAnYTcgLT4gJ2EpXG4gICAgICAqICdhMSBOb2RlLnRcbiAgICAgICogJ2EyIE5vZGUudFxuICAgICAgKiAnYTMgTm9kZS50XG4gICAgICAqICdhNCBOb2RlLnRcbiAgICAgICogJ2E1IE5vZGUudFxuICAgICAgKiAnYTYgTm9kZS50XG4gICAgICAqICdhNyBOb2RlLnRcbiAgICAgIC0+ICdhIHRcbiAgfCBNYXA4IDpcbiAgICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhNiAtPiAnYTcgLT4gJ2E4IC0+ICdhKVxuICAgICAgKiAnYTEgTm9kZS50XG4gICAgICAqICdhMiBOb2RlLnRcbiAgICAgICogJ2EzIE5vZGUudFxuICAgICAgKiAnYTQgTm9kZS50XG4gICAgICAqICdhNSBOb2RlLnRcbiAgICAgICogJ2E2IE5vZGUudFxuICAgICAgKiAnYTcgTm9kZS50XG4gICAgICAqICdhOCBOb2RlLnRcbiAgICAgIC0+ICdhIHRcbiAgfCBNYXA5IDpcbiAgICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhNiAtPiAnYTcgLT4gJ2E4IC0+ICdhOSAtPiAnYSlcbiAgICAgICogJ2ExIE5vZGUudFxuICAgICAgKiAnYTIgTm9kZS50XG4gICAgICAqICdhMyBOb2RlLnRcbiAgICAgICogJ2E0IE5vZGUudFxuICAgICAgKiAnYTUgTm9kZS50XG4gICAgICAqICdhNiBOb2RlLnRcbiAgICAgICogJ2E3IE5vZGUudFxuICAgICAgKiAnYTggTm9kZS50XG4gICAgICAqICdhOSBOb2RlLnRcbiAgICAgIC0+ICdhIHRcbiAgfCBNYXAxMCA6XG4gICAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2E3IC0+ICdhOCAtPiAnYTkgLT4gJ2ExMCAtPiAnYSlcbiAgICAgICogJ2ExIE5vZGUudFxuICAgICAgKiAnYTIgTm9kZS50XG4gICAgICAqICdhMyBOb2RlLnRcbiAgICAgICogJ2E0IE5vZGUudFxuICAgICAgKiAnYTUgTm9kZS50XG4gICAgICAqICdhNiBOb2RlLnRcbiAgICAgICogJ2E3IE5vZGUudFxuICAgICAgKiAnYTggTm9kZS50XG4gICAgICAqICdhOSBOb2RlLnRcbiAgICAgICogJ2ExMCBOb2RlLnRcbiAgICAgIC0+ICdhIHRcbiAgfCBNYXAxMSA6XG4gICAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2E3IC0+ICdhOCAtPiAnYTkgLT4gJ2ExMCAtPiAnYTExIC0+ICdhKVxuICAgICAgKiAnYTEgTm9kZS50XG4gICAgICAqICdhMiBOb2RlLnRcbiAgICAgICogJ2EzIE5vZGUudFxuICAgICAgKiAnYTQgTm9kZS50XG4gICAgICAqICdhNSBOb2RlLnRcbiAgICAgICogJ2E2IE5vZGUudFxuICAgICAgKiAnYTcgTm9kZS50XG4gICAgICAqICdhOCBOb2RlLnRcbiAgICAgICogJ2E5IE5vZGUudFxuICAgICAgKiAnYTEwIE5vZGUudFxuICAgICAgKiAnYTExIE5vZGUudFxuICAgICAgLT4gJ2EgdFxuICB8IE1hcDEyIDpcbiAgICAgICgnYTFcbiAgICAgICAtPiAnYTJcbiAgICAgICAtPiAnYTNcbiAgICAgICAtPiAnYTRcbiAgICAgICAtPiAnYTVcbiAgICAgICAtPiAnYTZcbiAgICAgICAtPiAnYTdcbiAgICAgICAtPiAnYThcbiAgICAgICAtPiAnYTlcbiAgICAgICAtPiAnYTEwXG4gICAgICAgLT4gJ2ExMVxuICAgICAgIC0+ICdhMTJcbiAgICAgICAtPiAnYSlcbiAgICAgICogJ2ExIE5vZGUudFxuICAgICAgKiAnYTIgTm9kZS50XG4gICAgICAqICdhMyBOb2RlLnRcbiAgICAgICogJ2E0IE5vZGUudFxuICAgICAgKiAnYTUgTm9kZS50XG4gICAgICAqICdhNiBOb2RlLnRcbiAgICAgICogJ2E3IE5vZGUudFxuICAgICAgKiAnYTggTm9kZS50XG4gICAgICAqICdhOSBOb2RlLnRcbiAgICAgICogJ2ExMCBOb2RlLnRcbiAgICAgICogJ2ExMSBOb2RlLnRcbiAgICAgICogJ2ExMiBOb2RlLnRcbiAgICAgIC0+ICdhIHRcbiAgfCBNYXAxMyA6XG4gICAgICAoJ2ExXG4gICAgICAgLT4gJ2EyXG4gICAgICAgLT4gJ2EzXG4gICAgICAgLT4gJ2E0XG4gICAgICAgLT4gJ2E1XG4gICAgICAgLT4gJ2E2XG4gICAgICAgLT4gJ2E3XG4gICAgICAgLT4gJ2E4XG4gICAgICAgLT4gJ2E5XG4gICAgICAgLT4gJ2ExMFxuICAgICAgIC0+ICdhMTFcbiAgICAgICAtPiAnYTEyXG4gICAgICAgLT4gJ2ExM1xuICAgICAgIC0+ICdhKVxuICAgICAgKiAnYTEgTm9kZS50XG4gICAgICAqICdhMiBOb2RlLnRcbiAgICAgICogJ2EzIE5vZGUudFxuICAgICAgKiAnYTQgTm9kZS50XG4gICAgICAqICdhNSBOb2RlLnRcbiAgICAgICogJ2E2IE5vZGUudFxuICAgICAgKiAnYTcgTm9kZS50XG4gICAgICAqICdhOCBOb2RlLnRcbiAgICAgICogJ2E5IE5vZGUudFxuICAgICAgKiAnYTEwIE5vZGUudFxuICAgICAgKiAnYTExIE5vZGUudFxuICAgICAgKiAnYTEyIE5vZGUudFxuICAgICAgKiAnYTEzIE5vZGUudFxuICAgICAgLT4gJ2EgdFxuICB8IE1hcDE0IDpcbiAgICAgICgnYTFcbiAgICAgICAtPiAnYTJcbiAgICAgICAtPiAnYTNcbiAgICAgICAtPiAnYTRcbiAgICAgICAtPiAnYTVcbiAgICAgICAtPiAnYTZcbiAgICAgICAtPiAnYTdcbiAgICAgICAtPiAnYThcbiAgICAgICAtPiAnYTlcbiAgICAgICAtPiAnYTEwXG4gICAgICAgLT4gJ2ExMVxuICAgICAgIC0+ICdhMTJcbiAgICAgICAtPiAnYTEzXG4gICAgICAgLT4gJ2ExNFxuICAgICAgIC0+ICdhKVxuICAgICAgKiAnYTEgTm9kZS50XG4gICAgICAqICdhMiBOb2RlLnRcbiAgICAgICogJ2EzIE5vZGUudFxuICAgICAgKiAnYTQgTm9kZS50XG4gICAgICAqICdhNSBOb2RlLnRcbiAgICAgICogJ2E2IE5vZGUudFxuICAgICAgKiAnYTcgTm9kZS50XG4gICAgICAqICdhOCBOb2RlLnRcbiAgICAgICogJ2E5IE5vZGUudFxuICAgICAgKiAnYTEwIE5vZGUudFxuICAgICAgKiAnYTExIE5vZGUudFxuICAgICAgKiAnYTEyIE5vZGUudFxuICAgICAgKiAnYTEzIE5vZGUudFxuICAgICAgKiAnYTE0IE5vZGUudFxuICAgICAgLT4gJ2EgdFxuICB8IE1hcDE1IDpcbiAgICAgICgnYTFcbiAgICAgICAtPiAnYTJcbiAgICAgICAtPiAnYTNcbiAgICAgICAtPiAnYTRcbiAgICAgICAtPiAnYTVcbiAgICAgICAtPiAnYTZcbiAgICAgICAtPiAnYTdcbiAgICAgICAtPiAnYThcbiAgICAgICAtPiAnYTlcbiAgICAgICAtPiAnYTEwXG4gICAgICAgLT4gJ2ExMVxuICAgICAgIC0+ICdhMTJcbiAgICAgICAtPiAnYTEzXG4gICAgICAgLT4gJ2ExNFxuICAgICAgIC0+ICdhMTVcbiAgICAgICAtPiAnYSlcbiAgICAgICogJ2ExIE5vZGUudFxuICAgICAgKiAnYTIgTm9kZS50XG4gICAgICAqICdhMyBOb2RlLnRcbiAgICAgICogJ2E0IE5vZGUudFxuICAgICAgKiAnYTUgTm9kZS50XG4gICAgICAqICdhNiBOb2RlLnRcbiAgICAgICogJ2E3IE5vZGUudFxuICAgICAgKiAnYTggTm9kZS50XG4gICAgICAqICdhOSBOb2RlLnRcbiAgICAgICogJ2ExMCBOb2RlLnRcbiAgICAgICogJ2ExMSBOb2RlLnRcbiAgICAgICogJ2ExMiBOb2RlLnRcbiAgICAgICogJ2ExMyBOb2RlLnRcbiAgICAgICogJ2ExNCBOb2RlLnRcbiAgICAgICogJ2ExNSBOb2RlLnRcbiAgICAgIC0+ICdhIHRcbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBuYW1lIDogdHlwZSBhLiBhIHQgLT4gc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBBcnJheV9mb2xkIF8gLT4gXCJBcnJheV9mb2xkXCJcbiAgfCBBdCBfIC0+IFwiQXRcIlxuICB8IEF0X2ludGVydmFscyBfIC0+IFwiQXRfaW50ZXJ2YWxzXCJcbiAgfCBCaW5kX2xoc19jaGFuZ2UgXyAtPiBcIkJpbmRfbGhzX2NoYW5nZVwiXG4gIHwgQmluZF9tYWluIF8gLT4gXCJCaW5kX21haW5cIlxuICB8IENvbnN0IF8gLT4gXCJDb25zdFwiXG4gIHwgRXhwZXJ0IF8gLT4gXCJFeHBlcnRcIlxuICB8IEZyZWV6ZSBfIC0+IFwiRnJlZXplXCJcbiAgfCBJZl90ZXN0X2NoYW5nZSBfIC0+IFwiSWZfdGVzdF9jaGFuZ2VcIlxuICB8IElmX3RoZW5fZWxzZSBfIC0+IFwiSWZfdGhlbl9lbHNlXCJcbiAgfCBJbnZhbGlkIC0+IFwiSW52YWxpZFwiXG4gIHwgSm9pbl9saHNfY2hhbmdlIF8gLT4gXCJKb2luX2xoc19jaGFuZ2VcIlxuICB8IEpvaW5fbWFpbiBfIC0+IFwiSm9pbl9tYWluXCJcbiAgfCBNYXAgXyAtPiBcIk1hcFwiXG4gIHwgTWFwMiBfIC0+IFwiTWFwMlwiXG4gIHwgTWFwMyBfIC0+IFwiTWFwM1wiXG4gIHwgTWFwNCBfIC0+IFwiTWFwNFwiXG4gIHwgTWFwNSBfIC0+IFwiTWFwNVwiXG4gIHwgTWFwNiBfIC0+IFwiTWFwNlwiXG4gIHwgTWFwNyBfIC0+IFwiTWFwN1wiXG4gIHwgTWFwOCBfIC0+IFwiTWFwOFwiXG4gIHwgTWFwOSBfIC0+IFwiTWFwOVwiXG4gIHwgTWFwMTAgXyAtPiBcIk1hcDEwXCJcbiAgfCBNYXAxMSBfIC0+IFwiTWFwMTFcIlxuICB8IE1hcDEyIF8gLT4gXCJNYXAxMlwiXG4gIHwgTWFwMTMgXyAtPiBcIk1hcDEzXCJcbiAgfCBNYXAxNCBfIC0+IFwiTWFwMTRcIlxuICB8IE1hcDE1IF8gLT4gXCJNYXAxNVwiXG4gIHwgU25hcHNob3QgXyAtPiBcIlNuYXBzaG90XCJcbiAgfCBTdGVwX2Z1bmN0aW9uIF8gLT4gXCJTdGVwX2Z1bmN0aW9uXCJcbiAgfCBVbmluaXRpYWxpemVkIC0+IFwiVW5pbml0aWFsaXplZFwiXG4gIHwgVW5vcmRlcmVkX2FycmF5X2ZvbGQgXyAtPiBcIlVub3JkZXJlZF9hcnJheV9mb2xkXCJcbiAgfCBWYXIgXyAtPiBcIlZhclwiXG47O1xuXG5sZXQgaW52YXJpYW50IDogdHlwZSBhLiBhIEludmFyaWFudC50IC0+IGEgdCBJbnZhcmlhbnQudCA9XG4gIGZ1biBpbnZhcmlhbnRfYSB0IC0+XG4gIG1hdGNoIHQgd2l0aFxuICB8IEFycmF5X2ZvbGQgYXJyYXlfZm9sZCAtPiBBcnJheV9mb2xkLmludmFyaWFudCBpZ25vcmUgaW52YXJpYW50X2EgYXJyYXlfZm9sZFxuICB8IEF0IGF0IC0+IEF0LmludmFyaWFudCBhdFxuICB8IEF0X2ludGVydmFscyBhdF9pbnRlcnZhbHMgLT4gQXRfaW50ZXJ2YWxzLmludmFyaWFudCBhdF9pbnRlcnZhbHNcbiAgfCBCaW5kX2xoc19jaGFuZ2UgYmluZCAtPiBCaW5kLmludmFyaWFudCBpZ25vcmUgaWdub3JlIGJpbmRcbiAgfCBCaW5kX21haW4gYmluZCAtPiBCaW5kLmludmFyaWFudCBpZ25vcmUgaW52YXJpYW50X2EgYmluZFxuICB8IENvbnN0IGEgLT4gaW52YXJpYW50X2EgYVxuICB8IEV4cGVydCBlIC0+IEV4cGVydC5pbnZhcmlhbnQgaW52YXJpYW50X2EgZVxuICB8IEZyZWV6ZSBmcmVlemUgLT4gRnJlZXplLmludmFyaWFudCBpbnZhcmlhbnRfYSBmcmVlemVcbiAgfCBJZl90ZXN0X2NoYW5nZSBpZl90aGVuX2Vsc2UgLT4gSWZfdGhlbl9lbHNlLmludmFyaWFudCBpZ25vcmUgaWZfdGhlbl9lbHNlXG4gIHwgSWZfdGhlbl9lbHNlIGlmX3RoZW5fZWxzZSAtPiBJZl90aGVuX2Vsc2UuaW52YXJpYW50IGludmFyaWFudF9hIGlmX3RoZW5fZWxzZVxuICB8IEludmFsaWQgLT4gKClcbiAgfCBKb2luX2xoc19jaGFuZ2Ugam9pbiAtPiBKb2luLmludmFyaWFudCBpZ25vcmUgam9pblxuICB8IEpvaW5fbWFpbiBqb2luIC0+IEpvaW4uaW52YXJpYW50IGludmFyaWFudF9hIGpvaW5cbiAgfCBNYXAgX1xuICB8IE1hcDIgX1xuICB8IE1hcDMgX1xuICB8IE1hcDQgX1xuICB8IE1hcDUgX1xuICB8IE1hcDYgX1xuICB8IE1hcDcgX1xuICB8IE1hcDggX1xuICB8IE1hcDkgX1xuICB8IE1hcDEwIF9cbiAgfCBNYXAxMSBfXG4gIHwgTWFwMTIgX1xuICB8IE1hcDEzIF9cbiAgfCBNYXAxNCBfXG4gIHwgTWFwMTUgXyAtPiAoKVxuICB8IFNuYXBzaG90IHNuYXBzaG90IC0+IFNuYXBzaG90LmludmFyaWFudCBpbnZhcmlhbnRfYSBzbmFwc2hvdFxuICB8IFN0ZXBfZnVuY3Rpb24gc3RlcF9mdW5jdGlvbl9ub2RlIC0+XG4gICAgU3RlcF9mdW5jdGlvbl9ub2RlLmludmFyaWFudCBpbnZhcmlhbnRfYSBzdGVwX2Z1bmN0aW9uX25vZGVcbiAgfCBVbmluaXRpYWxpemVkIC0+ICgpXG4gIHwgVW5vcmRlcmVkX2FycmF5X2ZvbGQgdW5vcmRlcmVkX2FycmF5X2ZvbGQgLT5cbiAgICBVbm9yZGVyZWRfYXJyYXlfZm9sZC5pbnZhcmlhbnQgaWdub3JlIGludmFyaWFudF9hIHVub3JkZXJlZF9hcnJheV9mb2xkXG4gIHwgVmFyIHZhciAtPiBWYXIuaW52YXJpYW50IGlnbm9yZSB2YXJcbjs7XG5cbmxldCBpbml0aWFsX251bV9jaGlsZHJlbiAodHlwZSBhKSAodCA6IGEgdCkgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBBdCBfIC0+IDBcbiAgfCBBdF9pbnRlcnZhbHMgXyAtPiAwXG4gIHwgQmluZF9saHNfY2hhbmdlIF8gLT4gMVxuICB8IEJpbmRfbWFpbiBfIC0+IDJcbiAgfCBDb25zdCBfIC0+IDBcbiAgfCBFeHBlcnQgXyAtPiAwXG4gIHwgRnJlZXplIF8gLT4gMVxuICB8IElmX3Rlc3RfY2hhbmdlIF8gLT4gMVxuICB8IElmX3RoZW5fZWxzZSBfIC0+IDJcbiAgfCBJbnZhbGlkIC0+IDBcbiAgfCBKb2luX2xoc19jaGFuZ2UgXyAtPiAxXG4gIHwgSm9pbl9tYWluIF8gLT4gMlxuICB8IE1hcCBfIC0+IDFcbiAgfCBNYXAyIF8gLT4gMlxuICB8IE1hcDMgXyAtPiAzXG4gIHwgTWFwNCBfIC0+IDRcbiAgfCBNYXA1IF8gLT4gNVxuICB8IE1hcDYgXyAtPiA2XG4gIHwgTWFwNyBfIC0+IDdcbiAgfCBNYXA4IF8gLT4gOFxuICB8IE1hcDkgXyAtPiA5XG4gIHwgTWFwMTAgXyAtPiAxMFxuICB8IE1hcDExIF8gLT4gMTFcbiAgfCBNYXAxMiBfIC0+IDEyXG4gIHwgTWFwMTMgXyAtPiAxM1xuICB8IE1hcDE0IF8gLT4gMTRcbiAgfCBNYXAxNSBfIC0+IDE1XG4gIHwgU25hcHNob3QgXyAtPiAwXG4gIHwgU3RlcF9mdW5jdGlvbiBfIC0+IDFcbiAgfCBVbmluaXRpYWxpemVkIC0+IDBcbiAgfCBWYXIgXyAtPiAwXG4gIHwgQXJyYXlfZm9sZCB7IGNoaWxkcmVuOyBfIH0gLT4gQXJyYXkubGVuZ3RoIGNoaWxkcmVuXG4gIHwgVW5vcmRlcmVkX2FycmF5X2ZvbGQgeyBjaGlsZHJlbjsgXyB9IC0+IEFycmF5Lmxlbmd0aCBjaGlsZHJlblxuOztcblxubGV0IGJpbmRfcmhzX2NoaWxkX2luZGV4ID0gMVxubGV0IGZyZWV6ZV9jaGlsZF9pbmRleCA9IDBcbmxldCBpZl9icmFuY2hfY2hpbGRfaW5kZXggPSAxXG5sZXQgam9pbl9yaHNfY2hpbGRfaW5kZXggPSAxXG5cbigqIFdlIGRvIG5vdCBpbXBsZW1lbnQgdGhlIHRpbWUtYmFzZWQgbm9kZXMgKFtBdF0sIFtBdF9pbnRlcnZhbHNdLCBbU25hcHNob3RdLFxuICAgW1N0ZXBfZnVuY3Rpb25dKSBhcyBwYXJlbnRzIG9mIHRoZSBjdXJyZW50LXRpbWUgbm9kZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gIFdlIGRvbid0XG4gICB3YW50IGFsbCBzdWNoIG5vZGVzIHRvIGJlIHJlY29tcHV0ZWQgd2hlbmV2ZXIgdGhlIHRpbWUgY2hhbmdlcywgd2hpY2ggd291bGQgYmUgaG9ycmlibHlcbiAgIGlubmVmaWNpZW50LiAgSW5zdGVhZCwgd2Ugb25seSB3YW50IHRoZW0gdG8gYmUgcmVjb21wdXRlZCBhdCB0aGUgXCJyaWdodFwiIHRpbWUsXG4gICBpLmUuIHdoZW4gdGltZSBwYXNzZXMgc29tZSB0aHJlc2hvbGQgcmVsZXZhbnQgdG8gdGhlbS4gIFdlIGRvIHRoaXMgdmlhIHNjaGVkdWxpbmdcbiAgIGFsYXJtcyBhdCB0aG9zZSB0aHJlc2hvbGRzLiAqKVxubGV0IGl0ZXJpX2NoaWxkcmVuICh0eXBlIGEpICh0IDogYSB0KSB+KGYgOiBpbnQgLT4gTm9kZS5QYWNrZWQudCAtPiB1bml0KSA6IHVuaXQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBBcnJheV9mb2xkIHsgY2hpbGRyZW47IF8gfSAtPlxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggY2hpbGRyZW4gLSAxIGRvXG4gICAgICBmIGkgKFQgKEFycmF5LnVuc2FmZV9nZXQgY2hpbGRyZW4gaSkpXG4gICAgZG9uZVxuICB8IEF0IF8gLT4gKClcbiAgfCBBdF9pbnRlcnZhbHMgXyAtPiAoKVxuICB8IEJpbmRfbGhzX2NoYW5nZSBiaW5kIC0+IGYgMCAoVCBiaW5kLmxocylcbiAgfCBCaW5kX21haW4geyBsaHNfY2hhbmdlOyByaHM7IF8gfSAtPlxuICAgICgqIFZhcmlvdXMgY29kZSwgZS5nLiBbc3RhdGUuYmVjYW1lX25lY2Vzc2FyeV0sIHJlbGllcyBvbiBwcm9jZXNzaW5nIFtsaHNfY2hhbmdlXVxuICAgICAgIGJlZm9yZSBbcmhzXS4gKilcbiAgICBmIDAgKFQgbGhzX2NoYW5nZSk7XG4gICAgaWYgVW9wdC5pc19zb21lIHJocyB0aGVuIGYgMSAoVCAoVW9wdC51bnNhZmVfdmFsdWUgcmhzKSlcbiAgfCBDb25zdCBfIC0+ICgpXG4gIHwgRXhwZXJ0IHsgY2hpbGRyZW47IG51bV9jaGlsZHJlbjsgXyB9IC0+XG4gICAgZm9yIGkgPSAwIHRvIG51bV9jaGlsZHJlbiAtIDEgZG9cbiAgICAgIGxldCAoRXhwZXJ0LkUgcikgPSBVb3B0LnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IGNoaWxkcmVuIGkpIGluXG4gICAgICBmIGkgKFQgci5jaGlsZClcbiAgICBkb25lXG4gIHwgRnJlZXplIHsgY2hpbGQ7IF8gfSAtPiBmIDAgKFQgY2hpbGQpXG4gIHwgSWZfdGVzdF9jaGFuZ2UgeyB0ZXN0OyBfIH0gLT4gZiAwIChUIHRlc3QpXG4gIHwgSWZfdGhlbl9lbHNlIHsgdGVzdF9jaGFuZ2U7IGN1cnJlbnRfYnJhbmNoOyBfIH0gLT5cbiAgICBmIDAgKFQgdGVzdF9jaGFuZ2UpO1xuICAgIGlmIFVvcHQuaXNfc29tZSBjdXJyZW50X2JyYW5jaCB0aGVuIGYgMSAoVCAoVW9wdC51bnNhZmVfdmFsdWUgY3VycmVudF9icmFuY2gpKVxuICB8IEludmFsaWQgLT4gKClcbiAgfCBKb2luX2xoc19jaGFuZ2UgeyBsaHM7IF8gfSAtPiBmIDAgKFQgbGhzKVxuICB8IEpvaW5fbWFpbiB7IGxoc19jaGFuZ2U7IHJoczsgXyB9IC0+XG4gICAgZiAwIChUIGxoc19jaGFuZ2UpO1xuICAgIGlmIFVvcHQuaXNfc29tZSByaHMgdGhlbiBmIDEgKFQgKFVvcHQudW5zYWZlX3ZhbHVlIHJocykpXG4gIHwgU25hcHNob3QgXyAtPiAoKVxuICB8IFN0ZXBfZnVuY3Rpb24geyBjaGlsZDsgXyB9IC0+XG4gICAgaWYgVW9wdC5pc19zb21lIGNoaWxkIHRoZW4gZiAwIChUIChVb3B0LnVuc2FmZV92YWx1ZSBjaGlsZCkpXG4gIHwgVW5pbml0aWFsaXplZCAtPiAoKVxuICB8IFVub3JkZXJlZF9hcnJheV9mb2xkIHsgY2hpbGRyZW47IF8gfSAtPlxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggY2hpbGRyZW4gLSAxIGRvXG4gICAgICBmIGkgKFQgKEFycmF5LnVuc2FmZV9nZXQgY2hpbGRyZW4gaSkpXG4gICAgZG9uZVxuICB8IFZhciBfIC0+ICgpXG4gIHwgTWFwIChfLCBub2RlMCkgLT4gZiAwIChUIG5vZGUwKVxuICB8IE1hcDIgKF8sIG5vZGUwLCBub2RlMSkgLT5cbiAgICBmIDAgKFQgbm9kZTApO1xuICAgIGYgMSAoVCBub2RlMSlcbiAgfCBNYXAzIChfLCBub2RlMCwgbm9kZTEsIG5vZGUyKSAtPlxuICAgIGYgMCAoVCBub2RlMCk7XG4gICAgZiAxIChUIG5vZGUxKTtcbiAgICBmIDIgKFQgbm9kZTIpXG4gIHwgTWFwNCAoXywgbm9kZTAsIG5vZGUxLCBub2RlMiwgbm9kZTMpIC0+XG4gICAgZiAwIChUIG5vZGUwKTtcbiAgICBmIDEgKFQgbm9kZTEpO1xuICAgIGYgMiAoVCBub2RlMik7XG4gICAgZiAzIChUIG5vZGUzKVxuICB8IE1hcDUgKF8sIG5vZGUwLCBub2RlMSwgbm9kZTIsIG5vZGUzLCBub2RlNCkgLT5cbiAgICBmIDAgKFQgbm9kZTApO1xuICAgIGYgMSAoVCBub2RlMSk7XG4gICAgZiAyIChUIG5vZGUyKTtcbiAgICBmIDMgKFQgbm9kZTMpO1xuICAgIGYgNCAoVCBub2RlNClcbiAgfCBNYXA2IChfLCBub2RlMCwgbm9kZTEsIG5vZGUyLCBub2RlMywgbm9kZTQsIG5vZGU1KSAtPlxuICAgIGYgMCAoVCBub2RlMCk7XG4gICAgZiAxIChUIG5vZGUxKTtcbiAgICBmIDIgKFQgbm9kZTIpO1xuICAgIGYgMyAoVCBub2RlMyk7XG4gICAgZiA0IChUIG5vZGU0KTtcbiAgICBmIDUgKFQgbm9kZTUpXG4gIHwgTWFwNyAoXywgbm9kZTAsIG5vZGUxLCBub2RlMiwgbm9kZTMsIG5vZGU0LCBub2RlNSwgbm9kZTYpIC0+XG4gICAgZiAwIChUIG5vZGUwKTtcbiAgICBmIDEgKFQgbm9kZTEpO1xuICAgIGYgMiAoVCBub2RlMik7XG4gICAgZiAzIChUIG5vZGUzKTtcbiAgICBmIDQgKFQgbm9kZTQpO1xuICAgIGYgNSAoVCBub2RlNSk7XG4gICAgZiA2IChUIG5vZGU2KVxuICB8IE1hcDggKF8sIG5vZGUwLCBub2RlMSwgbm9kZTIsIG5vZGUzLCBub2RlNCwgbm9kZTUsIG5vZGU2LCBub2RlNykgLT5cbiAgICBmIDAgKFQgbm9kZTApO1xuICAgIGYgMSAoVCBub2RlMSk7XG4gICAgZiAyIChUIG5vZGUyKTtcbiAgICBmIDMgKFQgbm9kZTMpO1xuICAgIGYgNCAoVCBub2RlNCk7XG4gICAgZiA1IChUIG5vZGU1KTtcbiAgICBmIDYgKFQgbm9kZTYpO1xuICAgIGYgNyAoVCBub2RlNylcbiAgfCBNYXA5IChfLCBub2RlMCwgbm9kZTEsIG5vZGUyLCBub2RlMywgbm9kZTQsIG5vZGU1LCBub2RlNiwgbm9kZTcsIG5vZGU4KSAtPlxuICAgIGYgMCAoVCBub2RlMCk7XG4gICAgZiAxIChUIG5vZGUxKTtcbiAgICBmIDIgKFQgbm9kZTIpO1xuICAgIGYgMyAoVCBub2RlMyk7XG4gICAgZiA0IChUIG5vZGU0KTtcbiAgICBmIDUgKFQgbm9kZTUpO1xuICAgIGYgNiAoVCBub2RlNik7XG4gICAgZiA3IChUIG5vZGU3KTtcbiAgICBmIDggKFQgbm9kZTgpXG4gIHwgTWFwMTAgKF8sIG5vZGUwLCBub2RlMSwgbm9kZTIsIG5vZGUzLCBub2RlNCwgbm9kZTUsIG5vZGU2LCBub2RlNywgbm9kZTgsIG5vZGU5KSAtPlxuICAgIGYgMCAoVCBub2RlMCk7XG4gICAgZiAxIChUIG5vZGUxKTtcbiAgICBmIDIgKFQgbm9kZTIpO1xuICAgIGYgMyAoVCBub2RlMyk7XG4gICAgZiA0IChUIG5vZGU0KTtcbiAgICBmIDUgKFQgbm9kZTUpO1xuICAgIGYgNiAoVCBub2RlNik7XG4gICAgZiA3IChUIG5vZGU3KTtcbiAgICBmIDggKFQgbm9kZTgpO1xuICAgIGYgOSAoVCBub2RlOSlcbiAgfCBNYXAxMSAoXywgbm9kZTAsIG5vZGUxLCBub2RlMiwgbm9kZTMsIG5vZGU0LCBub2RlNSwgbm9kZTYsIG5vZGU3LCBub2RlOCwgbm9kZTksIG5vZGUxMClcbiAgICAtPlxuICAgIGYgMCAoVCBub2RlMCk7XG4gICAgZiAxIChUIG5vZGUxKTtcbiAgICBmIDIgKFQgbm9kZTIpO1xuICAgIGYgMyAoVCBub2RlMyk7XG4gICAgZiA0IChUIG5vZGU0KTtcbiAgICBmIDUgKFQgbm9kZTUpO1xuICAgIGYgNiAoVCBub2RlNik7XG4gICAgZiA3IChUIG5vZGU3KTtcbiAgICBmIDggKFQgbm9kZTgpO1xuICAgIGYgOSAoVCBub2RlOSk7XG4gICAgZiAxMCAoVCBub2RlMTApXG4gIHwgTWFwMTJcbiAgICAgICggX1xuICAgICAgLCBub2RlMFxuICAgICAgLCBub2RlMVxuICAgICAgLCBub2RlMlxuICAgICAgLCBub2RlM1xuICAgICAgLCBub2RlNFxuICAgICAgLCBub2RlNVxuICAgICAgLCBub2RlNlxuICAgICAgLCBub2RlN1xuICAgICAgLCBub2RlOFxuICAgICAgLCBub2RlOVxuICAgICAgLCBub2RlMTBcbiAgICAgICwgbm9kZTExICkgLT5cbiAgICBmIDAgKFQgbm9kZTApO1xuICAgIGYgMSAoVCBub2RlMSk7XG4gICAgZiAyIChUIG5vZGUyKTtcbiAgICBmIDMgKFQgbm9kZTMpO1xuICAgIGYgNCAoVCBub2RlNCk7XG4gICAgZiA1IChUIG5vZGU1KTtcbiAgICBmIDYgKFQgbm9kZTYpO1xuICAgIGYgNyAoVCBub2RlNyk7XG4gICAgZiA4IChUIG5vZGU4KTtcbiAgICBmIDkgKFQgbm9kZTkpO1xuICAgIGYgMTAgKFQgbm9kZTEwKTtcbiAgICBmIDExIChUIG5vZGUxMSlcbiAgfCBNYXAxM1xuICAgICAgKCBfXG4gICAgICAsIG5vZGUwXG4gICAgICAsIG5vZGUxXG4gICAgICAsIG5vZGUyXG4gICAgICAsIG5vZGUzXG4gICAgICAsIG5vZGU0XG4gICAgICAsIG5vZGU1XG4gICAgICAsIG5vZGU2XG4gICAgICAsIG5vZGU3XG4gICAgICAsIG5vZGU4XG4gICAgICAsIG5vZGU5XG4gICAgICAsIG5vZGUxMFxuICAgICAgLCBub2RlMTFcbiAgICAgICwgbm9kZTEyICkgLT5cbiAgICBmIDAgKFQgbm9kZTApO1xuICAgIGYgMSAoVCBub2RlMSk7XG4gICAgZiAyIChUIG5vZGUyKTtcbiAgICBmIDMgKFQgbm9kZTMpO1xuICAgIGYgNCAoVCBub2RlNCk7XG4gICAgZiA1IChUIG5vZGU1KTtcbiAgICBmIDYgKFQgbm9kZTYpO1xuICAgIGYgNyAoVCBub2RlNyk7XG4gICAgZiA4IChUIG5vZGU4KTtcbiAgICBmIDkgKFQgbm9kZTkpO1xuICAgIGYgMTAgKFQgbm9kZTEwKTtcbiAgICBmIDExIChUIG5vZGUxMSk7XG4gICAgZiAxMiAoVCBub2RlMTIpXG4gIHwgTWFwMTRcbiAgICAgICggX1xuICAgICAgLCBub2RlMFxuICAgICAgLCBub2RlMVxuICAgICAgLCBub2RlMlxuICAgICAgLCBub2RlM1xuICAgICAgLCBub2RlNFxuICAgICAgLCBub2RlNVxuICAgICAgLCBub2RlNlxuICAgICAgLCBub2RlN1xuICAgICAgLCBub2RlOFxuICAgICAgLCBub2RlOVxuICAgICAgLCBub2RlMTBcbiAgICAgICwgbm9kZTExXG4gICAgICAsIG5vZGUxMlxuICAgICAgLCBub2RlMTMgKSAtPlxuICAgIGYgMCAoVCBub2RlMCk7XG4gICAgZiAxIChUIG5vZGUxKTtcbiAgICBmIDIgKFQgbm9kZTIpO1xuICAgIGYgMyAoVCBub2RlMyk7XG4gICAgZiA0IChUIG5vZGU0KTtcbiAgICBmIDUgKFQgbm9kZTUpO1xuICAgIGYgNiAoVCBub2RlNik7XG4gICAgZiA3IChUIG5vZGU3KTtcbiAgICBmIDggKFQgbm9kZTgpO1xuICAgIGYgOSAoVCBub2RlOSk7XG4gICAgZiAxMCAoVCBub2RlMTApO1xuICAgIGYgMTEgKFQgbm9kZTExKTtcbiAgICBmIDEyIChUIG5vZGUxMik7XG4gICAgZiAxMyAoVCBub2RlMTMpXG4gIHwgTWFwMTVcbiAgICAgICggX1xuICAgICAgLCBub2RlMFxuICAgICAgLCBub2RlMVxuICAgICAgLCBub2RlMlxuICAgICAgLCBub2RlM1xuICAgICAgLCBub2RlNFxuICAgICAgLCBub2RlNVxuICAgICAgLCBub2RlNlxuICAgICAgLCBub2RlN1xuICAgICAgLCBub2RlOFxuICAgICAgLCBub2RlOVxuICAgICAgLCBub2RlMTBcbiAgICAgICwgbm9kZTExXG4gICAgICAsIG5vZGUxMlxuICAgICAgLCBub2RlMTNcbiAgICAgICwgbm9kZTE0ICkgLT5cbiAgICBmIDAgKFQgbm9kZTApO1xuICAgIGYgMSAoVCBub2RlMSk7XG4gICAgZiAyIChUIG5vZGUyKTtcbiAgICBmIDMgKFQgbm9kZTMpO1xuICAgIGYgNCAoVCBub2RlNCk7XG4gICAgZiA1IChUIG5vZGU1KTtcbiAgICBmIDYgKFQgbm9kZTYpO1xuICAgIGYgNyAoVCBub2RlNyk7XG4gICAgZiA4IChUIG5vZGU4KTtcbiAgICBmIDkgKFQgbm9kZTkpO1xuICAgIGYgMTAgKFQgbm9kZTEwKTtcbiAgICBmIDExIChUIG5vZGUxMSk7XG4gICAgZiAxMiAoVCBub2RlMTIpO1xuICAgIGYgMTMgKFQgbm9kZTEzKTtcbiAgICBmIDE0IChUIG5vZGUxNClcbjs7XG5cbigqIFtzbG93X2dldF9jaGlsZF0gaXMgb25seSB1c2VkIGJ5IFtOb2RlLmludmFyaWFudF0sIHNvIHdlIGRvbid0IG1pbmQgdXNpbmcgW3dpdGhfcmV0dXJuXVxuICAgYW5kIFtpdGVyaV9jaGlsZHJlbl0uICBJZiB3ZSBldmVyIG5lZWQgYSBmYXN0IFtnZXRfY2hpbGRdLCB3ZSBjb2RlZCBpdCBpbiByZXZcbiAgIDQ4ZGJmZDAzYzljNS4gKilcbmxldCBzbG93X2dldF9jaGlsZCA6IHR5cGUgYS4gYSB0IC0+IGluZGV4Ol8gLT4gTm9kZS5QYWNrZWQudCA9XG4gIGZ1biB0IH5pbmRleCAtPlxuICBtYXRjaCB0IHdpdGhcbiAgfCBBcnJheV9mb2xkIHsgY2hpbGRyZW47IF8gfSAtPiBUIGNoaWxkcmVuLihpbmRleClcbiAgfCBVbm9yZGVyZWRfYXJyYXlfZm9sZCB7IGNoaWxkcmVuOyBfIH0gLT4gVCBjaGlsZHJlbi4oaW5kZXgpXG4gIHwgRXhwZXJ0IHsgY2hpbGRyZW47IF8gfSAtPlxuICAgIGxldCAoRSBlZGdlKSA9IFVvcHQudmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCBjaGlsZHJlbiBpbmRleCkgaW5cbiAgICBUIGVkZ2UuY2hpbGRcbiAgfCBfIC0+XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyaV9jaGlsZHJlbiB0IH5mOihmdW4gaSBjaGlsZCAtPiBpZiBpID0gaW5kZXggdGhlbiByLnJldHVybiBjaGlsZCk7XG4gICAgICBmYWlsd2l0aHNcbiAgICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgICBcIktpbmQuc2xvd19nZXRfY2hpbGQgZ290IGludmFsaWQgaW5kZXhcIlxuICAgICAgICAoaW5kZXgsIHQpXG4gICAgICAgIFslc2V4cF9vZjogaW50ICogXyB0XSlcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5vcGVuIEtpbmRcbm1vZHVsZSBJbnRlcm5hbF9vYnNlcnZlciA9IFR5cGVzLkludGVybmFsX29ic2VydmVyXG5tb2R1bGUgTm9kZSA9IFR5cGVzLk5vZGVcbm9wZW4gTm9kZVxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5Ob2RlLnQgPVxuICB7ICgqIFtpZF0gaXMgYSB1bmlxdWUgaWQgZm9yIHRoZSBub2RlLiAqKVxuICAgIGlkIDogTm9kZV9pZC50XG4gIDsgc3RhdGUgOiAoVHlwZXMuU3RhdGUudFtAc2V4cC5vcGFxdWVdKVxuICA7ICgqIFRoZSBmaWVsZHMgZnJvbSBbcmVjb21wdXRlZF9hdF0gdG8gW2NyZWF0ZWRfaW5dIGFyZSBncm91cGVkIHRvZ2V0aGVyIGFuZCBhcmUgaW4gdGhlXG4gICAgICAgc2FtZSBvcmRlciBhcyB0aGV5IGFyZSB1c2VkIGJ5IFtTdGF0ZS5yZWNvbXB1dGVdIFRoaXMgaGFzIGEgcG9zaXRpdmUgcGVyZm9ybWFuY2VcbiAgICAgICBpbXBhY3QgZHVlIHRvIGNhY2hlIGVmZmVjdHMuICBEb24ndCBjaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZXNlIG5vZGVzIHdpdGhvdXRcbiAgICAgICBwZXJmb3JtYW5jZSB0ZXN0aW5nLiAqKVxuICAgICgqIFtyZWNvbXB1dGVkX2F0XSBpcyB0aGUgbGFzdCBzdGFiaWxpemF0aW9uIHdoZW4gW3RdJ3MgdmFsdWUgd2FzIHJlY29tcHV0ZWQsIGV2ZW4gaWZcbiAgICAgICBpdCB3YXMgY3V0IG9mZi4gKilcbiAgICBtdXRhYmxlIHJlY29tcHV0ZWRfYXQgOiBTdGFiaWxpemF0aW9uX251bS50XG4gIDsgKCogW3ZhbHVlX29wdF0gc3RhcnRzIGFzIFtub25lXSwgYW5kIHRoZSBmaXJzdCB0aW1lIFt0XSBpcyBjb21wdXRlZCBpdCBpcyBzZXQgdG9cbiAgICAgICBbc29tZV0sIGFuZCByZW1haW5zIFtzb21lXSB0aGVyZWFmdGVyLCB1bnRpbCBbdF0gaXMgaW52YWxpZGF0ZWQsIGlmIGV2ZXIuICopXG4gICAgbXV0YWJsZSB2YWx1ZV9vcHQgOiAnYSBVb3B0LnRcbiAgOyAoKiBba2luZF0gaXMgdGhlIGtpbmQgb2YgREFHIG5vZGUgW3RdIGlzLiAgW2tpbmRdIGlzIG11dGFibGUgYm90aCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICAgICBhbmQgYmVjYXVzZSBpdCBjYW4gY2hhbmdlLCBlLmcuIGlmIFt0XSBpcyBpbnZhbGlkYXRlZC4gKilcbiAgICBtdXRhYmxlIGtpbmQgOiAnYSBLaW5kLnRcbiAgOyBtdXRhYmxlIGN1dG9mZiA6ICdhIEN1dG9mZi50XG4gIDsgKCogW2NoYW5nZWRfYXRdIGlzIHRoZSBsYXN0IHN0YWJpbGl6YXRpb24gd2hlbiB0aGlzIG5vZGUgd2FzIGNvbXB1dGVkIGFuZCBub3QgY3V0IG9mZi5cbiAgICAgICBJdCBpcyB1c2VkIHRvIGRldGVjdCB3aGVuIFt0XSdzIHBhcmVudHMgYXJlIHN0YWxlIGFuZCAoYmVjYXVzZSBhbGwgcGFyZW50cyBhcmVcbiAgICAgICBuZWNlc3NhcnkpIG5lZWQgdG8gYmUgcmVjb21wdXRlZC4gKilcbiAgICBtdXRhYmxlIGNoYW5nZWRfYXQgOiBTdGFiaWxpemF0aW9uX251bS50XG4gIDsgKCogW251bV9vbl91cGRhdGVfaGFuZGxlcnNdIGlzIFtMaXN0Lmxlbmd0aCB0Lm9uX3VwZGF0ZV9oYW5kbGVyc10gcGx1cyB0aGUgbnVtYmVyIG9mXG4gICAgICAgb24tdXBkYXRlIGhhbmRsZXJzIHN1bW1lZCBvdmVyIGFsbCBvYnNlcnZlcnMgaW4gW3Qub2JzZXJ2ZXJzXS4gIEl0IGlzIHVzZWQgdG9cbiAgICAgICBxdWlja2x5IGRlY2lkZSB3aGV0aGVyIFt0XSBuZWVkcyB0byBiZSBhZGRlZCB0byBbc3RhdGUuaGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb25dXG4gICAgICAgd2hlbiBbdF0gY2hhbmdlcy4gIFtudW1fb25fdXBkYXRlX2hhbmRsZXJzXSB3aWxsIGRlY3JlYXNlIHdoZW4gYW4gb2JzZXJ2ZXIgaXNcbiAgICAgICByZW1vdmVkIGZyb20gW3Qub2JzZXJ2ZXJzXSwgaWYgdGhlIG9ic2VydmVyIGhhcyBvbi11cGRhdGUgaGFuZGxlcnMuICopXG4gICAgbXV0YWJsZSBudW1fb25fdXBkYXRlX2hhbmRsZXJzIDogaW50XG4gIDsgKCogVGhlIHBhcmVudHMgb2YgW3RdIGFyZSB0aGUgbm9kZXMgdGhhdCBkZXBlbmQgb24gaXQsIGFuZCBzaG91bGQgYmUgY29tcHV0ZWQgd2hlbiBbdF1cbiAgICAgICBjaGFuZ2VzLCBvbmNlIGFsbCBvZiB0aGVpciBvdGhlciBjaGlsZHJlbiBhcmUgdXAgdG8gZGF0ZS4gIFtudW1fcGFyZW50c10gaXMgdGhlXG4gICAgICAgbnVtYmVyIG9mIHBhcmVudHMuICBJZiBbbnVtX3BhcmVudHMgPj0gMV0sIHRoZW4gW3BhcmVudDBdIGlzIHRoZSBmaXJzdCBwYXJlbnQuXG4gICAgICAgW3BhcmVudDFfYW5kX2JleW9uZF0gaG9sZHMgdGhlIHJlbWFpbmluZyBwYXJlbnRzLiAgVGhlIG9yZGVyIG9mIHRoZSBwYXJlbnRzIGRvZXNuJ3RcbiAgICAgICBtYXR0ZXIuICBPbmUgbm9kZSBtYXkgb2NjdXIgbXVsdGlwbGUgdGltZXMgYXMgYSBwYXJlbnQgb2YgYW5vdGhlciAoZS5nLiBjb25zaWRlclxuICAgICAgIFttYXAyIG4xIG4xIH5mXSkuXG5cbiAgICAgICBUaGlzIHJlcHJlc2VudGF0aW9uIGlzIG9wdGltaXplZCBmb3IgdGhlIG92ZXJ3aGVsbWluZ2x5IGNvbW1vbiBjYXNlIHRoYXQgYSBub2RlIGhhc1xuICAgICAgIG9ubHkgb25lIHBhcmVudC4gKilcbiAgICBtdXRhYmxlIG51bV9wYXJlbnRzIDogaW50XG4gIDsgbXV0YWJsZSBwYXJlbnQxX2FuZF9iZXlvbmQgOiBQYWNrZWQudCBVb3B0LnQgVW5pZm9ybV9hcnJheS50XG4gIDsgbXV0YWJsZSBwYXJlbnQwIDogUGFja2VkLnQgVW9wdC50XG4gIDsgKCogW2NyZWF0ZWRfaW5dIGlzIGluaXRpYWxseSB0aGUgc2NvcGUgdGhhdCB0aGUgbm9kZSBpcyBjcmVhdGVkIGluLiAgSWYgYSBub2RlIGlzXG4gICAgICAgbGF0ZXIgXCJyZXNjb3BlZFwiLCB0aGVuIGNyZWF0ZWRfaW4gd2lsbCBiZSBhZGp1c3RlZCB0byB0aGUgbmV3IHNjb3BlIHRoYXQgdGhlIG5vZGVcbiAgICAgICBpcyBwYXJ0IG9mLiAqKVxuICAgIG11dGFibGUgY3JlYXRlZF9pbiA6IFNjb3BlLnRcbiAgOyAoKiBbbmV4dF9ub2RlX2luX3NhbWVfc2NvcGVdIHNpbmdseSBsaW5rcyBhbGwgbm9kZXMgY3JlYXRlZCBpbiBbdC5jcmVhdGVkX2luXS4gKilcbiAgICBtdXRhYmxlIG5leHRfbm9kZV9pbl9zYW1lX3Njb3BlIDogUGFja2VkLnQgVW9wdC50XG4gIDsgKCogW2hlaWdodF0gaXMgdXNlZCB0byB2aXNpdCBub2RlcyBpbiB0b3BvbG9naWNhbCBvcmRlci4gIElmIFtpc19uZWNlc3NhcnkgdF0sIHRoZW5cbiAgICAgICBbaGVpZ2h0ID4gYy5oZWlnaHRdIGZvciBhbGwgY2hpbGRyZW4gW2NdIG9mIFt0XSwgYW5kIFtoZWlnaHQgPiBTY29wZS5oZWlnaHRcbiAgICAgICB0LmNyZWF0ZWRfaW5dLiAgSWYgW25vdCAoaXNfbmVjZXNzYXJ5IHQpXSwgdGhlbiBbaGVpZ2h0ID0gLTFdLiAqKVxuICAgIG11dGFibGUgaGVpZ2h0IDogaW50XG4gIDsgKCogW2hlaWdodF9pbl9yZWNvbXB1dGVfaGVhcF0gaXMgdGhlIGhlaWdodCBhdCB3aGljaCBbdF0gaXMgc3RvcmVkIGluIHRoZSByZWNvbXB1dGVcbiAgICAgICBoZWFwLCBhbmQgaXMgbm9uLW5lZ2F0aXZlIGlmZiBbdF0gaXMgaW4gdGhlIHJlY29tcHV0ZSBoZWFwLiAgSWYgW3RdIGlzIHRoZVxuICAgICAgIHJlY29tcHV0ZSBoZWFwLCB0aGVuIHR5cGljYWxseSBbdC5oZWlnaHQgPSB0LmhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcF07IGhvd2V2ZXIsXG4gICAgICAgd2hpbGUgaGVpZ2h0IGlzIGJlaW5nIGFkanVzdGVkLCBvbmUgY2FuIHRlbXBvcmFyaWx5IGhhdmUgW3QuaGVpZ2h0ID5cbiAgICAgICB0LmhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcF0uICBXaGVuIGhlaWdodCBhZGp1c3RtZW50IGZpbmlzaGVzLCBlcXVhbGl0eSBpcyByZXN0b3JlZFxuICAgICAgIGJ5IGluY3JlYXNpbmcgW3QuaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwXSB0byBbdC5oZWlnaHRdIGFuZCBzaGlmdGluZyBbdF0nc1xuICAgICAgIHBvc2l0aW9uIGluIHRoZSByZWNvbXB1dGUgaGVhcC4gKilcbiAgICBtdXRhYmxlIGhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcCA6IGludFxuICA7ICgqIFtwcmV2X2luX3JlY29tcHV0ZV9oZWFwXSBhbmQgW25leHRfaW5fcmVjb21wdXRlX2hlYXBdIGRvdWJseSBsaW5rIGFsbCBub2RlcyBvZiB0aGVcbiAgICAgICBzYW1lIGhlaWdodCBpbiB0aGUgcmVjb21wdXRlIGhlYXAuICopXG4gICAgbXV0YWJsZSBwcmV2X2luX3JlY29tcHV0ZV9oZWFwIDogUGFja2VkLnQgVW9wdC50XG4gIDsgbXV0YWJsZSBuZXh0X2luX3JlY29tcHV0ZV9oZWFwIDogUGFja2VkLnQgVW9wdC50XG4gIDsgKCogW2hlaWdodF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwXSBpcyB1c2VkIG9ubHkgZHVyaW5nIGhlaWdodCBhZGp1c3RtZW50LCBhbmQgaXNcbiAgICAgICBub24tbmVnYXRpdmUgaWZmIFt0XSBpcyBpbiB0aGUgYWRqdXN0LWhlaWdodHMgaGVhcC4gIEl0IGhvbGRzIHRoZSBwcmUtYWRqdXN0ZWRcbiAgICAgICBoZWlnaHQgb2YgW3RdLiAqKVxuICAgIG11dGFibGUgaGVpZ2h0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAgOiBpbnRcbiAgOyAoKiBbbmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwXSBzaW5nbHkgbGlua3MgYWxsIG5vZGVzIG9mIHRoZSBzYW1lIGhlaWdodCBpbiB0aGVcbiAgICAgICBhZGp1c3QtaGVpZ2h0cyBoZWFwLiAqKVxuICAgIG11dGFibGUgbmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwIDogUGFja2VkLnQgVW9wdC50XG4gIDsgKCogW29sZF92YWx1ZV9vcHRdIGlzIHVzZWQgb25seSBkdXJpbmcgc3RhYmlsaXphdGlvbiwgYW5kIG9ubHkgaWZcbiAgICAgICBbdC5udW1fb25fdXBkYXRlX2hhbmRsZXJzID4gMF0uICBJdCBob2xkcyB0aGUgcHJlLXN0YWJpbGl6YXRpb24gdmFsdWUgb2YgW3RdLiAgSXRcbiAgICAgICBpcyBjbGVhcmVkIHdoZW4gcnVubmluZyBbdF0ncyBvbi11cGRhdGUgaGFuZGxlcnMsIGFuZCBzbyBpcyBhbHdheXMgW1VvcHQubm9uZV1cbiAgICAgICBiZXR3ZWVuIHN0YWJpbGl6YXRpb25zLiAqKVxuICAgIG11dGFibGUgb2xkX3ZhbHVlX29wdCA6ICdhIFVvcHQudFxuICA7ICgqIFtvYnNlcnZlcnNdIGlzIHRoZSBoZWFkIG9mIHRoZSBkb3VibHktbGlua2VkIGxpc3Qgb2Ygb2JzZXJ2ZXJzIG9mIFt0XSwgb3JcbiAgICAgICBbVW9wdC5ub25lXSBpZiB0aGVyZSBhcmUgbm8gb2JzZXJ2ZXJzLiAqKVxuICAgIG11dGFibGUgb2JzZXJ2ZXJzIDogKCdhIEludGVybmFsX29ic2VydmVyLnRbQHNleHAub3BhcXVlXSkgVW9wdC50XG4gIDsgKCogW2lzX2luX2hhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uXSBpcyB1c2VkIHRvIGF2b2lkIHB1c2hpbmcgdGhlIHNhbWUgbm9kZSBtdWx0aXBsZVxuICAgICAgIHRpbWVzIG9udG8gW3N0YXRlLmhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uXS4gKilcbiAgICBtdXRhYmxlIGlzX2luX2hhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uIDogYm9vbFxuICA7ICgqIFtvbl91cGRhdGVfaGFuZGxlcnNdIGlzIHRoZSBmdW5jdGlvbnMgc3VwcGxpZWQgdG8gW0luY3JlbWVudGFsLm9uX3VwZGF0ZV0gdG8gYmUgcnVuXG4gICAgICAgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2R1bGUgW09uX3VwZGF0ZV9oYW5kbGVyXS4gIFtvbl91cGRhdGVfaGFuZGxlcnNdIGRvZXMgbm90XG4gICAgICAgY29udGFpbiB0aGUgb24tdXBkYXRlIGhhbmRsZXJzIGluIFt0Lm9ic2VydmVyc10uICBbb25fdXBkYXRlX2hhbmRsZXJzXSBvbmx5IGV2ZXJcbiAgICAgICBnZXRzIGxvbmdlcjsgdGhlcmUgaXMgbm8gd2F5IHRvIHJlbW92ZSBlbGVtZW50cy4gKilcbiAgICBtdXRhYmxlIG9uX3VwZGF0ZV9oYW5kbGVycyA6ICdhIE9uX3VwZGF0ZV9oYW5kbGVyLnQgbGlzdFxuICA7IG11dGFibGUgbXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4IDogaW50IGFycmF5XG4gIDsgbXV0YWJsZSBteV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXggOiBpbnQgYXJyYXlcbiAgOyBtdXRhYmxlIGZvcmNlX25lY2Vzc2FyeSA6IGJvb2xcbiAgOyBtdXRhYmxlIHVzZXJfaW5mbyA6IERvdF91c2VyX2luZm8udCBvcHRpb25cbiAgOyBjcmVhdGlvbl9iYWNrdHJhY2UgOiBCYWNrdHJhY2UudCBvcHRpb25cbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxubGV0IHNhbWUgKHQxIDogXyB0KSAodDIgOiBfIHQpID0gcGh5c19zYW1lIHQxIHQyXG5sZXQgcGFja2VkX3NhbWUgKFBhY2tlZC5UIHQxKSAoUGFja2VkLlQgdDIpID0gc2FtZSB0MSB0MlxubGV0IGlzX25lY2Vzc2FyeSA9IE5vZGUuaXNfbmVjZXNzYXJ5XG5sZXQgaW5pdGlhbF9udW1fY2hpbGRyZW4gdCA9IEtpbmQuaW5pdGlhbF9udW1fY2hpbGRyZW4gdC5raW5kXG5sZXQgaXRlcmlfY2hpbGRyZW4gdCB+ZiA9IEtpbmQuaXRlcmlfY2hpbGRyZW4gdC5raW5kIH5mXG5sZXQgaXNfdmFsaWQgPSBOb2RlLmlzX3ZhbGlkXG5sZXQgdHlwZV9lcXVhbF9pZl9waHlzX3NhbWUgPSB0eXBlX2VxdWFsX2lmX3BoeXNfc2FtZVxuXG5sZXQgdXNlcl9pbmZvIHQgPVxuICBtYXRjaCB0LnVzZXJfaW5mbyB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAoSW5mbyBpKSAtPiBTb21lIGlcbiAgfCBTb21lIG90aGVyIC0+IFNvbWUgKEluZm8uY3JlYXRlX3MgKERvdF91c2VyX2luZm8uc2V4cF9vZl90IG90aGVyKSlcbjs7XG5cbmxldCBzZXRfdXNlcl9pbmZvIHQgaW5mbyA9XG4gIHQudXNlcl9pbmZvXG4gICAgPC0gKG1hdGNoIGluZm8gd2l0aFxuICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgaSAtPiBTb21lIChJbmZvIGkpKVxuOztcblxubGV0IGFwcGVuZF91c2VyX2luZm9fZ3JhcGh2aXogdCB+bGFiZWwgfmF0dHJzID1cbiAgbGV0IG5ld18gPSBEb3RfdXNlcl9pbmZvLmRvdCB+bGFiZWwgfmF0dHJpYnV0ZXM6YXR0cnMgaW5cbiAgdC51c2VyX2luZm9cbiAgICA8LSAobWF0Y2ggdC51c2VyX2luZm8gd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSBuZXdfXG4gICAgICAgIHwgU29tZSBvdGhlciAtPiBTb21lIChEb3RfdXNlcl9pbmZvLmFwcGVuZCBvdGhlciBuZXdfKSlcbjs7XG5cbmxldCBlZGdlX2lzX3N0YWxlIH5jaGlsZCB+cGFyZW50ID1cbiAgU3RhYmlsaXphdGlvbl9udW0uY29tcGFyZSBjaGlsZC5jaGFuZ2VkX2F0IHBhcmVudC5yZWNvbXB1dGVkX2F0ID4gMFxuOztcblxubGV0IGlzX3N0YWxlX3dpdGhfcmVzcGVjdF90b19hX2NoaWxkIHQgPVxuICBsZXQgaXNfc3RhbGUgPSByZWYgZmFsc2UgaW5cbiAgaXRlcmlfY2hpbGRyZW4gdCB+ZjooZnVuIF8gKFQgY2hpbGQpIC0+XG4gICAgaWYgZWRnZV9pc19zdGFsZSB+Y2hpbGQgfnBhcmVudDp0IHRoZW4gaXNfc3RhbGUgOj0gdHJ1ZSk7XG4gICFpc19zdGFsZVxuOztcblxubGV0IGlzX3N0YWxlIDogdHlwZSBhLiBhIHQgLT4gYm9vbCA9XG4gIGZ1biAodCA6IGEgdCkgLT5cbiAgbWF0Y2ggdC5raW5kIHdpdGhcbiAgfCBVbmluaXRpYWxpemVkIC0+IGFzc2VydCBmYWxzZVxuICAoKiBBIGNvbnN0IG5vZGUgaXMgc3RhbGUgb25seSBhdCBpbml0aWFsaXphdGlvbi4gKilcbiAgfCBDb25zdCBfIC0+IFN0YWJpbGl6YXRpb25fbnVtLmlzX25vbmUgdC5yZWNvbXB1dGVkX2F0XG4gICgqIFRpbWUtYmFzZWQgbm9kZXMgYXJlIGNvbnNpZGVyZWQgc3RhbGUgd2hlbiBbdC5yZWNvbXB1dGVkX2F0XSBpcyBub25lLCB3aGljaCBoYXBwZW5zXG4gICAgIGF0IGluaXRpYWxpemF0aW9uIGFuZCB3aGVuIHRoZSBhbGFybSBtZWNoYW5pc20gbWFrZXMgYSBub2RlIHN0YWxlIChpdCBzZXRzIHRoZVxuICAgICBbdC5yZWNvbXB1dGVkX2F0XSB0byBbU3RhYmlsaXphdGlvbl9udW0ubm9uZV0pLiAqKVxuICB8IEF0IF8gLT4gU3RhYmlsaXphdGlvbl9udW0uaXNfbm9uZSB0LnJlY29tcHV0ZWRfYXRcbiAgfCBBdF9pbnRlcnZhbHMgXyAtPiBTdGFiaWxpemF0aW9uX251bS5pc19ub25lIHQucmVjb21wdXRlZF9hdFxuICB8IFNuYXBzaG90IF8gLT4gU3RhYmlsaXphdGlvbl9udW0uaXNfbm9uZSB0LnJlY29tcHV0ZWRfYXRcbiAgKCogV2UgbmV2ZXIgY29uc2lkZXIgYW4gaW52YWxpZGF0ZWQgbm9kZSB0byBiZSBzdGFsZSAtLSB3aGVuIHdlIGludmFsaWRhdGUgYSBub2RlLCB3ZVxuICAgICBpbW1lZGlhdGVseSBwcm9wYWdhdGUgaW52YWxpZGl0eSB0byBpdHMgYW5jZXN0b3JzLiAqKVxuICB8IEludmFsaWQgLT4gZmFsc2VcbiAgKCogQSBbVmFyXSBub2RlIGlzIHN0YWxlIGlmIGl0IHdhcyBzZXQgc2luY2UgaXQgd2FzIHJlY29tcHV0ZWQuICopXG4gIHwgVmFyIHsgc2V0X2F0OyBfIH0gLT4gU3RhYmlsaXphdGlvbl9udW0uY29tcGFyZSBzZXRfYXQgdC5yZWNvbXB1dGVkX2F0ID4gMFxuICAoKiBOb2RlcyB0aGF0IGhhdmUgY2hpbGRyZW4uICopXG4gIHwgQmluZF9saHNfY2hhbmdlIF8gLT5cbiAgICBTdGFiaWxpemF0aW9uX251bS5pc19ub25lIHQucmVjb21wdXRlZF9hdCB8fCBpc19zdGFsZV93aXRoX3Jlc3BlY3RfdG9fYV9jaGlsZCB0XG4gIHwgSWZfdGVzdF9jaGFuZ2UgXyAtPlxuICAgIFN0YWJpbGl6YXRpb25fbnVtLmlzX25vbmUgdC5yZWNvbXB1dGVkX2F0IHx8IGlzX3N0YWxlX3dpdGhfcmVzcGVjdF90b19hX2NoaWxkIHRcbiAgfCBKb2luX2xoc19jaGFuZ2UgXyAtPlxuICAgIFN0YWJpbGl6YXRpb25fbnVtLmlzX25vbmUgdC5yZWNvbXB1dGVkX2F0IHx8IGlzX3N0YWxlX3dpdGhfcmVzcGVjdF90b19hX2NoaWxkIHRcbiAgfCBBcnJheV9mb2xkIF9cbiAgfCBCaW5kX21haW4gX1xuICB8IEZyZWV6ZSBfXG4gIHwgSWZfdGhlbl9lbHNlIF9cbiAgfCBKb2luX21haW4gX1xuICB8IE1hcCBfXG4gIHwgTWFwMiBfXG4gIHwgTWFwMyBfXG4gIHwgTWFwNCBfXG4gIHwgTWFwNSBfXG4gIHwgTWFwNiBfXG4gIHwgTWFwNyBfXG4gIHwgTWFwOCBfXG4gIHwgTWFwOSBfXG4gIHwgTWFwMTAgX1xuICB8IE1hcDExIF9cbiAgfCBNYXAxMiBfXG4gIHwgTWFwMTMgX1xuICB8IE1hcDE0IF9cbiAgfCBNYXAxNSBfXG4gIHwgU3RlcF9mdW5jdGlvbiBfXG4gIHwgVW5vcmRlcmVkX2FycmF5X2ZvbGQgXyAtPlxuICAgIFN0YWJpbGl6YXRpb25fbnVtLmlzX25vbmUgdC5yZWNvbXB1dGVkX2F0IHx8IGlzX3N0YWxlX3dpdGhfcmVzcGVjdF90b19hX2NoaWxkIHRcbiAgfCBFeHBlcnQgeyBmb3JjZV9zdGFsZTsgXyB9IC0+XG4gICAgZm9yY2Vfc3RhbGVcbiAgICB8fCBTdGFiaWxpemF0aW9uX251bS5pc19ub25lIHQucmVjb21wdXRlZF9hdFxuICAgIHx8IGlzX3N0YWxlX3dpdGhfcmVzcGVjdF90b19hX2NoaWxkIHRcbjs7XG5cbmxldCBuZWVkc190b19iZV9jb21wdXRlZCB0ID0gaXNfbmVjZXNzYXJ5IHQgJiYgaXNfc3RhbGUgdFxubGV0IGlzX2luX3JlY29tcHV0ZV9oZWFwIHQgPSB0LmhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcCA+PSAwXG5sZXQgaXNfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCB0ID0gdC5oZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCA+PSAwXG5cbmxldCBnZXRfcGFyZW50IHQgfmluZGV4ID1cbiAgVW9wdC52YWx1ZV9leG5cbiAgICAoaWYgaW5kZXggPSAwIHRoZW4gdC5wYXJlbnQwIGVsc2UgVW5pZm9ybV9hcnJheS5nZXQgdC5wYXJlbnQxX2FuZF9iZXlvbmQgKGluZGV4IC0gMSkpXG47O1xuXG5sZXQgaXRlcmlfcGFyZW50cyB0IH5mID1cbiAgaWYgdC5udW1fcGFyZW50cyA+IDBcbiAgdGhlbiAoXG4gICAgZiAwIChVb3B0LnZhbHVlX2V4biB0LnBhcmVudDApO1xuICAgIGZvciBpbmRleCA9IDEgdG8gdC5udW1fcGFyZW50cyAtIDEgZG9cbiAgICAgIGYgaW5kZXggKFVvcHQudmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCB0LnBhcmVudDFfYW5kX2JleW9uZCAoaW5kZXggLSAxKSkpXG4gICAgZG9uZSlcbjs7XG5cbmxldCBoYXNfY2hpbGQgdCB+Y2hpbGQgPVxuICBsZXQgaGFzID0gcmVmIGZhbHNlIGluXG4gIGl0ZXJpX2NoaWxkcmVuIHQgfmY6KGZ1biBfIChUIGNoaWxkJykgLT4gaGFzIDo9ICFoYXMgfHwgc2FtZSBjaGlsZCBjaGlsZCcpO1xuICAhaGFzXG47O1xuXG5sZXQgaGFzX2ludmFsaWRfY2hpbGQgdCA9XG4gIGxldCBoYXMgPSByZWYgZmFsc2UgaW5cbiAgaXRlcmlfY2hpbGRyZW4gdCB+ZjooZnVuIF8gKFQgY2hpbGQpIC0+IGhhcyA6PSAhaGFzIHx8IG5vdCAoaXNfdmFsaWQgY2hpbGQpKTtcbiAgIWhhc1xuOztcblxubGV0IGhhc19wYXJlbnQgKHQgOiBfIHQpIH5wYXJlbnQgPVxuICBsZXQgaGFzID0gcmVmIGZhbHNlIGluXG4gIGl0ZXJpX3BhcmVudHMgdCB+ZjooZnVuIF8gKFQgcGFyZW50JykgLT4gaGFzIDo9ICFoYXMgfHwgc2FtZSBwYXJlbnQgcGFyZW50Jyk7XG4gICFoYXNcbjs7XG5cbmxldCBzaG91bGRfYmVfaW52YWxpZGF0ZWQgOiB0eXBlIGEuIGEgdCAtPiBib29sID1cbiAgZnVuIHQgLT5cbiAgbWF0Y2ggdC5raW5kIHdpdGhcbiAgKCogbm9kZXMgd2l0aCBubyBjaGlsZHJlbiAqKVxuICB8IFVuaW5pdGlhbGl6ZWQgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQXQgXyAtPiBmYWxzZVxuICB8IEF0X2ludGVydmFscyBfIC0+IGZhbHNlXG4gIHwgQ29uc3QgXyB8IFNuYXBzaG90IF8gfCBWYXIgXyAtPiBmYWxzZVxuICB8IEludmFsaWQgLT4gZmFsc2VcbiAgKCogTm9kZXMgd2l0aCBhIGZpeGVkIHNldCBvZiBjaGlsZHJlbiBhcmUgaW52YWxpZCBpZiBhbnkgY2hpbGQgaXMgaW52YWxpZC4gKilcbiAgfCBBcnJheV9mb2xkIF9cbiAgfCBGcmVlemUgX1xuICB8IE1hcCBfXG4gIHwgTWFwMiBfXG4gIHwgTWFwMyBfXG4gIHwgTWFwNCBfXG4gIHwgTWFwNSBfXG4gIHwgTWFwNiBfXG4gIHwgTWFwNyBfXG4gIHwgTWFwOCBfXG4gIHwgTWFwOSBfXG4gIHwgTWFwMTAgX1xuICB8IE1hcDExIF9cbiAgfCBNYXAxMiBfXG4gIHwgTWFwMTMgX1xuICB8IE1hcDE0IF9cbiAgfCBNYXAxNSBfXG4gIHwgU3RlcF9mdW5jdGlvbiBfXG4gIHwgVW5vcmRlcmVkX2FycmF5X2ZvbGQgXyAtPiBoYXNfaW52YWxpZF9jaGlsZCB0XG4gICgqIEEgKl9jaGFuZ2Ugbm9kZSBpcyBpbnZhbGlkIGlmIHRoZSBub2RlIGl0IGlzIHdhdGNoaW5nIGZvciBjaGFuZ2VzIGlzIGludmFsaWQgKHNhbWVcbiAgICAgcmVhc29uIGFzIGFib3ZlKS4gIFRoaXMgaXMgZXF1aXZhbGVudCB0byBbaGFzX2ludmFsaWRfY2hpbGQgdF0uICopXG4gIHwgQmluZF9saHNfY2hhbmdlIHsgbGhzOyBfIH0gLT4gbm90IChpc192YWxpZCBsaHMpXG4gIHwgSWZfdGVzdF9jaGFuZ2UgeyB0ZXN0OyBfIH0gLT4gbm90IChpc192YWxpZCB0ZXN0KVxuICB8IEpvaW5fbGhzX2NoYW5nZSB7IGxoczsgXyB9IC0+IG5vdCAoaXNfdmFsaWQgbGhzKVxuICAoKiBbQmluZF9tYWluXSwgW0lmX3RoZW5fZWxzZV0sIGFuZCBbSm9pbl9tYWluXSBhcmUgaW52YWxpZCBpZiB0aGVpciAqX2NoYW5nZSBjaGlsZCBpcyxcbiAgICAgYnV0IG5vdCBuZWNlc3NhcmlseSBpZiB0aGVpciBvdGhlciBjaGlsZHJlbiBhcmUgLS0gdGhlIGdyYXBoIG1heSBiZSByZXN0cnVjdHVyZWQgdG9cbiAgICAgYXZvaWQgdGhlIGludmFsaWRpdHkgb2YgdGhvc2UuICopXG4gIHwgQmluZF9tYWluIHsgbGhzX2NoYW5nZTsgXyB9IC0+IG5vdCAoaXNfdmFsaWQgbGhzX2NoYW5nZSlcbiAgfCBJZl90aGVuX2Vsc2UgeyB0ZXN0X2NoYW5nZTsgXyB9IC0+IG5vdCAoaXNfdmFsaWQgdGVzdF9jaGFuZ2UpXG4gIHwgSm9pbl9tYWluIHsgbGhzX2NoYW5nZTsgXyB9IC0+IG5vdCAoaXNfdmFsaWQgbGhzX2NoYW5nZSlcbiAgfCBFeHBlcnQgXyAtPlxuICAgICgqIFRoaXMgaXMgc2ltaWxhciB0byB3aGF0IHdlIGRvIGZvciBiaW5kIGFib3ZlLCBleGNlcHQgdGhhdCBhbnkgaW52YWxpZCBjaGlsZCBjYW4gYmVcbiAgICAgICByZW1vdmVkLCBzbyB3ZSBjYW4gb25seSB0ZWxsIGlmIGFuIGV4cGVydCBub2RlIGJlY29tZXMgaW52YWxpZCB3aGVuIGFsbCBpdHNcbiAgICAgICBkZXBlbmRlbmNpZXMgaGF2ZSBmaXJlZCAod2hpY2ggaW4gcHJhY3RpY2UgbWVhbnMgd2hlbiB3ZSBhcmUgYWJvdXQgdG8gcnVuIGl0KS4gKilcbiAgICBmYWxzZVxuOztcblxubGV0IGZvbGRfb2JzZXJ2ZXJzICh0IDogXyB0KSB+aW5pdCB+ZiA9XG4gIGxldCByID0gcmVmIHQub2JzZXJ2ZXJzIGluXG4gIGxldCBhYyA9IHJlZiBpbml0IGluXG4gIHdoaWxlIFVvcHQuaXNfc29tZSAhciBkb1xuICAgIGxldCBvYnNlcnZlciA9IFVvcHQudmFsdWVfZXhuICFyIGluXG4gICAgciA6PSBvYnNlcnZlci5uZXh0X2luX29ic2VydmluZztcbiAgICBhYyA6PSBmICFhYyBvYnNlcnZlclxuICBkb25lO1xuICAhYWNcbjs7XG5cbmxldCBpdGVyX29ic2VydmVycyB0IH5mID0gZm9sZF9vYnNlcnZlcnMgdCB+aW5pdDooKSB+ZjooZnVuICgpIG9ic2VydmVyIC0+IGYgb2JzZXJ2ZXIpXG5cbmxldCBpbnZhcmlhbnQgKHR5cGUgYSkgKGludmFyaWFudF9hIDogYSAtPiB1bml0KSAodCA6IGEgdCkgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgIFsldGVzdF9lcTogYm9vbF0gKG5lZWRzX3RvX2JlX2NvbXB1dGVkIHQpIChpc19pbl9yZWNvbXB1dGVfaGVhcCB0KTtcbiAgICBpZiBpc19uZWNlc3NhcnkgdFxuICAgIHRoZW4gKFxuICAgICAgYXNzZXJ0ICh0LmhlaWdodCA+IFNjb3BlLmhlaWdodCB0LmNyZWF0ZWRfaW4pO1xuICAgICAgaXRlcmlfY2hpbGRyZW4gdCB+ZjooZnVuIF8gKFQgY2hpbGQpIC0+XG4gICAgICAgIGFzc2VydCAodC5oZWlnaHQgPiBjaGlsZC5oZWlnaHQpO1xuICAgICAgICBhc3NlcnQgKGhhc19wYXJlbnQgY2hpbGQgfnBhcmVudDp0KSk7XG4gICAgICBhc3NlcnQgKG5vdCAoc2hvdWxkX2JlX2ludmFsaWRhdGVkIHQpKSk7XG4gICAgaXRlcmlfcGFyZW50cyB0IH5mOihmdW4gXyAoVCBwYXJlbnQpIC0+XG4gICAgICBhc3NlcnQgKGhhc19jaGlsZCBwYXJlbnQgfmNoaWxkOnQpO1xuICAgICAgYXNzZXJ0IChpc19uZWNlc3NhcnkgcGFyZW50KTtcbiAgICAgIGFzc2VydCAodC5oZWlnaHQgPCBwYXJlbnQuaGVpZ2h0KSk7XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5pZDooY2hlY2sgTm9kZV9pZC5pbnZhcmlhbnQpXG4gICAgICB+c3RhdGU6aWdub3JlXG4gICAgICB+cmVjb21wdXRlZF9hdDooY2hlY2sgU3RhYmlsaXphdGlvbl9udW0uaW52YXJpYW50KVxuICAgICAgfnZhbHVlX29wdDpcbiAgICAgICAgKGNoZWNrIChmdW4gdmFsdWVfb3B0IC0+XG4gICAgICAgICAgIGlmIGlzX3ZhbGlkIHQgJiYgbm90IChpc19zdGFsZSB0KSB0aGVuIGFzc2VydCAoVW9wdC5pc19zb21lIHZhbHVlX29wdCk7XG4gICAgICAgICAgIFVvcHQuaW52YXJpYW50IGludmFyaWFudF9hIHZhbHVlX29wdCkpXG4gICAgICB+a2luZDpcbiAgICAgICAgKGNoZWNrIChmdW4ga2luZCAtPlxuICAgICAgICAgICBLaW5kLmludmFyaWFudCBpbnZhcmlhbnRfYSBraW5kO1xuICAgICAgICAgICBtYXRjaCBraW5kIHdpdGhcbiAgICAgICAgICAgfCBFeHBlcnQgZSAtPlxuICAgICAgICAgICAgIEV4cGVydC5pbnZhcmlhbnRfYWJvdXRfbnVtX2ludmFsaWRfY2hpbGRyZW4gZSB+aXNfbmVjZXNzYXJ5Oihpc19uZWNlc3NhcnkgdClcbiAgICAgICAgICAgfCBfIC0+ICgpKSlcbiAgICAgIH5jdXRvZmY6KGNoZWNrIChDdXRvZmYuaW52YXJpYW50IGludmFyaWFudF9hKSlcbiAgICAgIH5jaGFuZ2VkX2F0OlxuICAgICAgICAoY2hlY2sgKGZ1biBjaGFuZ2VkX2F0IC0+XG4gICAgICAgICAgIFN0YWJpbGl6YXRpb25fbnVtLmludmFyaWFudCBjaGFuZ2VkX2F0O1xuICAgICAgICAgICBpZiBTdGFiaWxpemF0aW9uX251bS5pc19zb21lIHQucmVjb21wdXRlZF9hdFxuICAgICAgICAgICB0aGVuIGFzc2VydCAoU3RhYmlsaXphdGlvbl9udW0uY29tcGFyZSBjaGFuZ2VkX2F0IHQucmVjb21wdXRlZF9hdCA8PSAwKSkpXG4gICAgICB+bnVtX29uX3VwZGF0ZV9oYW5kbGVyczpcbiAgICAgICAgKGNoZWNrXG4gICAgICAgICAgIChbJXRlc3RfcmVzdWx0OiBpbnRdXG4gICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAgKExpc3QubGVuZ3RoIHQub25fdXBkYXRlX2hhbmRsZXJzXG4gICAgICAgICAgICAgICAgICsgZm9sZF9vYnNlcnZlcnMgdCB+aW5pdDowIH5mOihmdW4gbiB7IG9uX3VwZGF0ZV9oYW5kbGVyczsgXyB9IC0+XG4gICAgICAgICAgICAgICAgICAgICBuICsgTGlzdC5sZW5ndGggb25fdXBkYXRlX2hhbmRsZXJzKSkpKVxuICAgICAgfm51bV9wYXJlbnRzOlxuICAgICAgICAoY2hlY2sgKGZ1biBudW1fcGFyZW50cyAtPlxuICAgICAgICAgICBhc3NlcnQgKG51bV9wYXJlbnRzID49IDApO1xuICAgICAgICAgICBhc3NlcnQgKG51bV9wYXJlbnRzIDw9IDEgKyBVbmlmb3JtX2FycmF5Lmxlbmd0aCB0LnBhcmVudDFfYW5kX2JleW9uZCkpKVxuICAgICAgfnBhcmVudDFfYW5kX2JleW9uZDpcbiAgICAgICAgKGNoZWNrIChmdW4gcGFyZW50MV9hbmRfYmV5b25kIC0+XG4gICAgICAgICAgIGZvciBwYXJlbnRfaW5kZXggPSAxIHRvIFVuaWZvcm1fYXJyYXkubGVuZ3RoIHBhcmVudDFfYW5kX2JleW9uZCBkb1xuICAgICAgICAgICAgIFsldGVzdF9lcTogYm9vbF1cbiAgICAgICAgICAgICAgIChwYXJlbnRfaW5kZXggPCB0Lm51bV9wYXJlbnRzKVxuICAgICAgICAgICAgICAgKFVvcHQuaXNfc29tZSAoVW5pZm9ybV9hcnJheS5nZXQgcGFyZW50MV9hbmRfYmV5b25kIChwYXJlbnRfaW5kZXggLSAxKSkpXG4gICAgICAgICAgIGRvbmUpKVxuICAgICAgfnBhcmVudDA6XG4gICAgICAgIChjaGVjayAoZnVuIHBhcmVudDAgLT5cbiAgICAgICAgICAgWyV0ZXN0X2VxOiBib29sXSAodC5udW1fcGFyZW50cyA+IDApIChVb3B0LmlzX3NvbWUgcGFyZW50MCkpKVxuICAgICAgfmNyZWF0ZWRfaW46KGNoZWNrIFNjb3BlLmludmFyaWFudClcbiAgICAgIH5uZXh0X25vZGVfaW5fc2FtZV9zY29wZTpcbiAgICAgICAgKGNoZWNrIChmdW4gbmV4dF9ub2RlX2luX3NhbWVfc2NvcGUgLT5cbiAgICAgICAgICAgaWYgU2NvcGUuaXNfdG9wIHQuY3JlYXRlZF9pbiB8fCBub3QgKGlzX3ZhbGlkIHQpXG4gICAgICAgICAgIHRoZW4gYXNzZXJ0IChVb3B0LmlzX25vbmUgbmV4dF9ub2RlX2luX3NhbWVfc2NvcGUpKSlcbiAgICAgIH5oZWlnaHQ6XG4gICAgICAgIChjaGVjayAoZnVuIGhlaWdodCAtPlxuICAgICAgICAgICBpZiBpc19uZWNlc3NhcnkgdCB0aGVuIGFzc2VydCAoaGVpZ2h0ID49IDApIGVsc2UgYXNzZXJ0IChoZWlnaHQgPSAtMSkpKVxuICAgICAgfmhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcDpcbiAgICAgICAgKGNoZWNrIChmdW4gaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwIC0+XG4gICAgICAgICAgIGFzc2VydCAoaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwID49IC0xKTtcbiAgICAgICAgICAgYXNzZXJ0IChoZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAgPD0gdC5oZWlnaHQpKSlcbiAgICAgIH5wcmV2X2luX3JlY29tcHV0ZV9oZWFwOlxuICAgICAgICAoY2hlY2sgKGZ1biAocHJldl9pbl9yZWNvbXB1dGVfaGVhcCA6IFBhY2tlZC50IFVvcHQudCkgLT5cbiAgICAgICAgICAgaWYgbm90IChpc19pbl9yZWNvbXB1dGVfaGVhcCB0KVxuICAgICAgICAgICB0aGVuIGFzc2VydCAoVW9wdC5pc19ub25lIHByZXZfaW5fcmVjb21wdXRlX2hlYXApO1xuICAgICAgICAgICBpZiBVb3B0LmlzX3NvbWUgcHJldl9pbl9yZWNvbXB1dGVfaGVhcFxuICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICBsZXQgKFQgcHJldikgPSBVb3B0LnZhbHVlX2V4biBwcmV2X2luX3JlY29tcHV0ZV9oZWFwIGluXG4gICAgICAgICAgICAgYXNzZXJ0IChwYWNrZWRfc2FtZSAoVCB0KSAoVW9wdC52YWx1ZV9leG4gcHJldi5uZXh0X2luX3JlY29tcHV0ZV9oZWFwKSk7XG4gICAgICAgICAgICAgYXNzZXJ0ICh0LmhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcCA9IHByZXYuaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwKSkpKVxuICAgICAgfm5leHRfaW5fcmVjb21wdXRlX2hlYXA6XG4gICAgICAgIChjaGVjayAoZnVuIChuZXh0X2luX3JlY29tcHV0ZV9oZWFwIDogUGFja2VkLnQgVW9wdC50KSAtPlxuICAgICAgICAgICBpZiBub3QgKGlzX2luX3JlY29tcHV0ZV9oZWFwIHQpXG4gICAgICAgICAgIHRoZW4gYXNzZXJ0IChVb3B0LmlzX25vbmUgbmV4dF9pbl9yZWNvbXB1dGVfaGVhcCk7XG4gICAgICAgICAgIGlmIFVvcHQuaXNfc29tZSBuZXh0X2luX3JlY29tcHV0ZV9oZWFwXG4gICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgIGxldCAoVCBuZXh0KSA9IFVvcHQudmFsdWVfZXhuIG5leHRfaW5fcmVjb21wdXRlX2hlYXAgaW5cbiAgICAgICAgICAgICBhc3NlcnQgKHBhY2tlZF9zYW1lIChUIHQpIChVb3B0LnZhbHVlX2V4biBuZXh0LnByZXZfaW5fcmVjb21wdXRlX2hlYXApKTtcbiAgICAgICAgICAgICBhc3NlcnQgKHQuaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwID0gbmV4dC5oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXApKSkpXG4gICAgICB+aGVpZ2h0X2luX2FkanVzdF9oZWlnaHRzX2hlYXA6XG4gICAgICAgIChjaGVjayAoZnVuIGhlaWdodF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwIC0+XG4gICAgICAgICAgIGlmIGhlaWdodF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwID49IDBcbiAgICAgICAgICAgdGhlbiBhc3NlcnQgKGhlaWdodF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwIDwgdC5oZWlnaHQpKSlcbiAgICAgIH5uZXh0X2luX2FkanVzdF9oZWlnaHRzX2hlYXA6XG4gICAgICAgIChjaGVjayAoZnVuIChuZXh0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAgOiBQYWNrZWQudCBVb3B0LnQpIC0+XG4gICAgICAgICAgIGlmIG5vdCAoaXNfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCB0KVxuICAgICAgICAgICB0aGVuIGFzc2VydCAoVW9wdC5pc19ub25lIG5leHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcClcbiAgICAgICAgICAgZWxzZSBpZiBVb3B0LmlzX3NvbWUgbmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwXG4gICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgIGxldCAoVCBuZXh0KSA9IFVvcHQudmFsdWVfZXhuIG5leHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCBpblxuICAgICAgICAgICAgIGFzc2VydCAoaXNfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCBuZXh0KTtcbiAgICAgICAgICAgICBhc3NlcnQgKHQuaGVpZ2h0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAgPSBuZXh0LmhlaWdodF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwKSkpKVxuICAgICAgfm9sZF92YWx1ZV9vcHQ6KGNoZWNrIChVb3B0LmludmFyaWFudCBpbnZhcmlhbnRfYSkpXG4gICAgICB+b2JzZXJ2ZXJzOlxuICAgICAgICAoY2hlY2sgKGZ1biBfIC0+XG4gICAgICAgICAgIGl0ZXJfb2JzZXJ2ZXJzIHQgfmY6KGZ1biB7IHN0YXRlOyBvYnNlcnZpbmc7IF8gfSAtPlxuICAgICAgICAgICAgIGFzc2VydCAocGh5c19lcXVhbCB0IG9ic2VydmluZyk7XG4gICAgICAgICAgICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICAgICAgIHwgSW5fdXNlIHwgRGlzYWxsb3dlZCAtPiAoKVxuICAgICAgICAgICAgIHwgQ3JlYXRlZCB8IFVubGlua2VkIC0+IGFzc2VydCBmYWxzZSkpKVxuICAgICAgfmlzX2luX2hhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uOmlnbm9yZVxuICAgICAgfm9uX3VwZGF0ZV9oYW5kbGVyczppZ25vcmVcbiAgICAgIH51c2VyX2luZm86aWdub3JlXG4gICAgICB+bXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4OlxuICAgICAgICAoY2hlY2sgKGZ1biBteV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW5kZXggLT5cbiAgICAgICAgICAgKG1hdGNoIHQua2luZCB3aXRoXG4gICAgICAgICAgICB8IEV4cGVydCBfIC0+ICgpXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogaW50XVxuICAgICAgICAgICAgICAgIChBcnJheS5sZW5ndGggbXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4KVxuICAgICAgICAgICAgICAgIH5leHBlY3Q6KGluaXRpYWxfbnVtX2NoaWxkcmVuIHQpKTtcbiAgICAgICAgICAgaWYgaXNfbmVjZXNzYXJ5IHRcbiAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgIGl0ZXJpX2NoaWxkcmVuIHQgfmY6KGZ1biBjaGlsZF9pbmRleCAoVCBjaGlsZCkgLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgICAgIHBhY2tlZF9zYW1lXG4gICAgICAgICAgICAgICAgICAgKFQgdClcbiAgICAgICAgICAgICAgICAgICAoZ2V0X3BhcmVudFxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgICAgfmluZGV4Om15X3BhcmVudF9pbmRleF9pbl9jaGlsZF9hdF9pbmRleC4oY2hpbGRfaW5kZXgpKSkpO1xuICAgICAgICAgICBpZiBkZWJ1ZyAmJiBub3QgKGlzX25lY2Vzc2FyeSB0KVxuICAgICAgICAgICB0aGVuIEFycmF5Lml0ZXIgbXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4IH5mOihmdW4geCAtPiBhc3NlcnQgKHggPSAtMSkpKSlcbiAgICAgIH5teV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXg6XG4gICAgICAgIChjaGVjayAoZnVuIG15X2NoaWxkX2luZGV4X2luX3BhcmVudF9hdF9pbmRleCAtPlxuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBpbnRdXG4gICAgICAgICAgICAgKEFycmF5Lmxlbmd0aCBteV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXgpXG4gICAgICAgICAgICAgfmV4cGVjdDooVW5pZm9ybV9hcnJheS5sZW5ndGggdC5wYXJlbnQxX2FuZF9iZXlvbmQgKyAxKTtcbiAgICAgICAgICAgaXRlcmlfcGFyZW50cyB0IH5mOihmdW4gcGFyZW50X2luZGV4IChUIHBhcmVudCkgLT5cbiAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgcGFja2VkX3NhbWVcbiAgICAgICAgICAgICAgICAgKFQgdClcbiAgICAgICAgICAgICAgICAgKEtpbmQuc2xvd19nZXRfY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmtpbmRcbiAgICAgICAgICAgICAgICAgICAgfmluZGV4Om15X2NoaWxkX2luZGV4X2luX3BhcmVudF9hdF9pbmRleC4ocGFyZW50X2luZGV4KSkpKTtcbiAgICAgICAgICAgaWYgZGVidWcgJiYgbm90IChpc19uZWNlc3NhcnkgdClcbiAgICAgICAgICAgdGhlbiBBcnJheS5pdGVyIG15X2NoaWxkX2luZGV4X2luX3BhcmVudF9hdF9pbmRleCB+ZjooZnVuIHggLT4gYXNzZXJ0ICh4ID0gLTEpKSkpXG4gICAgICB+Zm9yY2VfbmVjZXNzYXJ5Omlnbm9yZVxuICAgICAgfmNyZWF0aW9uX2JhY2t0cmFjZTppZ25vcmUpXG47O1xuXG5sZXQgdW5zYWZlX3ZhbHVlIHQgPSBVb3B0LnVuc2FmZV92YWx1ZSB0LnZhbHVlX29wdFxuXG5sZXQgdmFsdWVfZXhuIHQgPVxuICBpZiBVb3B0LmlzX3NvbWUgdC52YWx1ZV9vcHRcbiAgdGhlbiBVb3B0LnVuc2FmZV92YWx1ZSB0LnZhbHVlX29wdFxuICBlbHNlIGZhaWx3aXRocyB+aGVyZTpbJWhlcmVdIFwiYXR0ZW1wdCB0byBnZXQgdmFsdWUgb2YgYW4gaW52YWxpZCBub2RlXCIgdCBbJXNleHBfb2Y6IF8gdF1cbjs7XG5cbmxldCBnZXRfY3V0b2ZmIHQgPSB0LmN1dG9mZlxubGV0IHNldF9jdXRvZmYgdCBjdXRvZmYgPSB0LmN1dG9mZiA8LSBjdXRvZmZcblxubGV0IGlzX2NvbnN0IHQgPVxuICBtYXRjaCB0LmtpbmQgd2l0aFxuICB8IENvbnN0IF8gLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBvbl91cGRhdGUgdCBvbl91cGRhdGVfaGFuZGxlciA9XG4gIHQub25fdXBkYXRlX2hhbmRsZXJzIDwtIG9uX3VwZGF0ZV9oYW5kbGVyIDo6IHQub25fdXBkYXRlX2hhbmRsZXJzO1xuICB0Lm51bV9vbl91cGRhdGVfaGFuZGxlcnMgPC0gdC5udW1fb25fdXBkYXRlX2hhbmRsZXJzICsgMVxuOztcblxubGV0IHJ1bl9vbl91cGRhdGVfaGFuZGxlcnMgdCBub2RlX3VwZGF0ZSB+bm93ID1cbiAgbGV0IHIgPSByZWYgdC5vbl91cGRhdGVfaGFuZGxlcnMgaW5cbiAgd2hpbGUgbm90IChMaXN0LmlzX2VtcHR5ICFyKSBkb1xuICAgIG1hdGNoICFyIHdpdGhcbiAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgb25fdXBkYXRlX2hhbmRsZXIgOjogcmVzdCAtPlxuICAgICAgciA6PSByZXN0O1xuICAgICAgT25fdXBkYXRlX2hhbmRsZXIucnVuIG9uX3VwZGF0ZV9oYW5kbGVyIG5vZGVfdXBkYXRlIH5ub3dcbiAgZG9uZTtcbiAgbGV0IHIgPSByZWYgdC5vYnNlcnZlcnMgaW5cbiAgd2hpbGUgVW9wdC5pc19zb21lICFyIGRvXG4gICAgbGV0IG9ic2VydmVyID0gVW9wdC52YWx1ZV9leG4gIXIgaW5cbiAgICByIDo9IG9ic2VydmVyLm5leHRfaW5fb2JzZXJ2aW5nO1xuICAgIGxldCByID0gcmVmIG9ic2VydmVyLm9uX3VwZGF0ZV9oYW5kbGVycyBpblxuICAgIHdoaWxlIG5vdCAoTGlzdC5pc19lbXB0eSAhcikgZG9cbiAgICAgIG1hdGNoICFyIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IG9uX3VwZGF0ZV9oYW5kbGVyIDo6IHJlc3QgLT5cbiAgICAgICAgciA6PSByZXN0O1xuICAgICAgICAoKiBXZSBoYXZlIHRvIHRlc3QgW3N0YXRlXSBiZWZvcmUgZWFjaCBvbi11cGRhdGUgaGFuZGxlciwgYmVjYXVzZSBhbiBvbi11cGRhdGVcbiAgICAgICAgICAgaGFuZGxlciBtaWdodCBkaXNhYmxlIGl0cyBvd24gb2JzZXJ2ZXIsIHdoaWNoIHNob3VsZCBwcmV2ZW50IG90aGVyIG9uLXVwZGF0ZVxuICAgICAgICAgICBoYW5kbGVycyBpbiB0aGUgc2FtZSBvYnNlcnZlciBmcm9tIHJ1bm5pbmcuICopXG4gICAgICAgIChtYXRjaCBvYnNlcnZlci5zdGF0ZSB3aXRoXG4gICAgICAgICB8IENyZWF0ZWQgfCBVbmxpbmtlZCAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgIHwgRGlzYWxsb3dlZCAtPiAoKVxuICAgICAgICAgfCBJbl91c2UgLT4gT25fdXBkYXRlX2hhbmRsZXIucnVuIG9uX3VwZGF0ZV9oYW5kbGVyIG5vZGVfdXBkYXRlIH5ub3cpXG4gICAgZG9uZVxuICBkb25lXG47O1xuXG5sZXQgc2V0X2tpbmQgdCBraW5kID1cbiAgdC5raW5kIDwtIGtpbmQ7XG4gIHQubXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4XG4gICAgPC0gQXJyYXkuY3JlYXRlIH5sZW46KEtpbmQuaW5pdGlhbF9udW1fY2hpbGRyZW4ga2luZCkgKC0xKVxuOztcblxubGV0IGNyZWF0ZSBzdGF0ZSBjcmVhdGVkX2luIGtpbmQgPVxuICBsZXQgdCA9XG4gICAgeyBpZCA9IE5vZGVfaWQubmV4dCAoKVxuICAgIDsgc3RhdGVcbiAgICA7IHJlY29tcHV0ZWRfYXQgPSBTdGFiaWxpemF0aW9uX251bS5ub25lXG4gICAgOyB2YWx1ZV9vcHQgPSBVb3B0Lm5vbmVcbiAgICA7IGtpbmRcbiAgICA7IGN1dG9mZiA9IEN1dG9mZi5waHlzX2VxdWFsXG4gICAgOyBjaGFuZ2VkX2F0ID0gU3RhYmlsaXphdGlvbl9udW0ubm9uZVxuICAgIDsgbnVtX29uX3VwZGF0ZV9oYW5kbGVycyA9IDBcbiAgICA7IG51bV9wYXJlbnRzID0gMFxuICAgIDsgcGFyZW50MV9hbmRfYmV5b25kID0gVW5pZm9ybV9hcnJheS5lbXB0eVxuICAgIDsgcGFyZW50MCA9IFVvcHQubm9uZVxuICAgIDsgY3JlYXRlZF9pblxuICAgIDsgbmV4dF9ub2RlX2luX3NhbWVfc2NvcGUgPSBVb3B0Lm5vbmVcbiAgICA7IGhlaWdodCA9IC0xXG4gICAgOyBoZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAgPSAtMVxuICAgIDsgcHJldl9pbl9yZWNvbXB1dGVfaGVhcCA9IFVvcHQubm9uZVxuICAgIDsgbmV4dF9pbl9yZWNvbXB1dGVfaGVhcCA9IFVvcHQubm9uZVxuICAgIDsgaGVpZ2h0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAgPSAtMVxuICAgIDsgbmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwID0gVW9wdC5ub25lXG4gICAgOyBvbGRfdmFsdWVfb3B0ID0gVW9wdC5ub25lXG4gICAgOyBvYnNlcnZlcnMgPSBVb3B0Lm5vbmVcbiAgICA7IGlzX2luX2hhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uID0gZmFsc2VcbiAgICA7IG9uX3VwZGF0ZV9oYW5kbGVycyA9IFtdXG4gICAgOyBteV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW5kZXggPVxuICAgICAgICBBcnJheS5jcmVhdGUgfmxlbjooS2luZC5pbml0aWFsX251bV9jaGlsZHJlbiBraW5kKSAoLTEpXG4gICAgICAgICgqIFtteV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXhdIGhhcyBvbmUgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBuZWVkIHRvIGhvbGRcbiAgICAgICB0aGUgY2hpbGQgaW5kZXggb2YgW3BhcmVudDBdLiAqKVxuICAgIDsgbXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luZGV4ID0gW3wgLTEgfF1cbiAgICA7IGZvcmNlX25lY2Vzc2FyeSA9IGZhbHNlXG4gICAgOyB1c2VyX2luZm8gPSBOb25lXG4gICAgOyBjcmVhdGlvbl9iYWNrdHJhY2UgPVxuICAgICAgICAoaWYgc3RhdGUua2VlcF9ub2RlX2NyZWF0aW9uX2JhY2t0cmFjZSB0aGVuIFNvbWUgKEJhY2t0cmFjZS5nZXQgKCkpIGVsc2UgTm9uZSlcbiAgICB9XG4gIGluXG4gIFNjb3BlLmFkZF9ub2RlIGNyZWF0ZWRfaW4gdDtcbiAgKCogW2ludmFyaWFudF0gZG9lcyBub3QgeWV0IGhvbGQgaGVyZSBiZWNhdXNlIG1hbnkgdXNlcyBvZiBbTm9kZS5jcmVhdGVdIHVzZSBba2luZCA9XG4gICAgIFVuaW5pdGlhbGl6ZWRdLCBhbmQgdGhlbiBtdXRhdGUgW3Qua2luZF0gbGF0ZXIuICopXG4gIHRcbjs7XG5cbmxldCBtYXhfbnVtX3BhcmVudHMgdCA9IDEgKyBVbmlmb3JtX2FycmF5Lmxlbmd0aCB0LnBhcmVudDFfYW5kX2JleW9uZFxuXG5sZXQgbWFrZV9zcGFjZV9mb3JfcGFyZW50X2lmX25lY2Vzc2FyeSB0ID1cbiAgaWYgdC5udW1fcGFyZW50cyA9IG1heF9udW1fcGFyZW50cyB0XG4gIHRoZW4gKFxuICAgIGxldCBuZXdfbWF4X251bV9wYXJlbnRzID0gMiAqIG1heF9udW1fcGFyZW50cyB0IGluXG4gICAgdC5wYXJlbnQxX2FuZF9iZXlvbmRcbiAgICAgIDwtIFVuaWZvcm1fYXJyYXkucmVhbGxvYyB0LnBhcmVudDFfYW5kX2JleW9uZCB+bGVuOihuZXdfbWF4X251bV9wYXJlbnRzIC0gMSk7XG4gICAgdC5teV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXhcbiAgICAgIDwtIEFycmF5LnJlYWxsb2MgdC5teV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXggfmxlbjpuZXdfbWF4X251bV9wYXJlbnRzICgtMSkpO1xuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAodC5udW1fcGFyZW50cyA8IG1heF9udW1fcGFyZW50cyB0KVxuOztcblxubGV0IG1ha2Vfc3BhY2VfZm9yX2NoaWxkX2lmX25lY2Vzc2FyeSB0IH5jaGlsZF9pbmRleCA9XG4gIGxldCBtYXhfbnVtX2NoaWxkcmVuID0gQXJyYXkubGVuZ3RoIHQubXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4IGluXG4gIGlmIGNoaWxkX2luZGV4ID49IG1heF9udW1fY2hpbGRyZW5cbiAgdGhlbiAoXG4gICAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKGNoaWxkX2luZGV4ID0gbWF4X251bV9jaGlsZHJlbik7XG4gICAgbGV0IG5ld19tYXhfbnVtX2NoaWxkcmVuID0gSW50Lm1heCAyICgyICogbWF4X251bV9jaGlsZHJlbikgaW5cbiAgICB0Lm15X3BhcmVudF9pbmRleF9pbl9jaGlsZF9hdF9pbmRleFxuICAgICAgPC0gQXJyYXkucmVhbGxvYyB0Lm15X3BhcmVudF9pbmRleF9pbl9jaGlsZF9hdF9pbmRleCB+bGVuOm5ld19tYXhfbnVtX2NoaWxkcmVuICgtMSkpO1xuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoY2hpbGRfaW5kZXggPCBBcnJheS5sZW5ndGggdC5teV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW5kZXgpXG47O1xuXG5sZXQgc2V0X3BhcmVudCA6IHR5cGUgYS4gY2hpbGQ6YSB0IC0+IHBhcmVudDpQYWNrZWQudCBVb3B0LnQgLT4gcGFyZW50X2luZGV4OmludCAtPiB1bml0ID1cbiAgZnVuIH5jaGlsZCB+cGFyZW50IH5wYXJlbnRfaW5kZXggLT5cbiAgaWYgcGFyZW50X2luZGV4ID0gMFxuICB0aGVuIGNoaWxkLnBhcmVudDAgPC0gcGFyZW50XG4gIGVsc2UgVW5pZm9ybV9hcnJheS5zZXQgY2hpbGQucGFyZW50MV9hbmRfYmV5b25kIChwYXJlbnRfaW5kZXggLSAxKSBwYXJlbnRcbjs7XG5cbmxldCBsaW5rXG4gIDogdHlwZSBhIGIuIGNoaWxkOmEgdCAtPiBjaGlsZF9pbmRleDppbnQgLT4gcGFyZW50OmIgdCAtPiBwYXJlbnRfaW5kZXg6aW50IC0+IHVuaXRcbiAgPVxuICBmdW4gfmNoaWxkIH5jaGlsZF9pbmRleCB+cGFyZW50IH5wYXJlbnRfaW5kZXggLT5cbiAgc2V0X3BhcmVudCB+Y2hpbGQgfnBhcmVudDooVW9wdC5zb21lIChQYWNrZWQuVCBwYXJlbnQpKSB+cGFyZW50X2luZGV4O1xuICBjaGlsZC5teV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXguKHBhcmVudF9pbmRleCkgPC0gY2hpbGRfaW5kZXg7XG4gIHBhcmVudC5teV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW5kZXguKGNoaWxkX2luZGV4KSA8LSBwYXJlbnRfaW5kZXhcbjs7XG5cbmxldCB1bmxpbmtcbiAgOiB0eXBlIGEgYi4gY2hpbGQ6YSB0IC0+IGNoaWxkX2luZGV4OmludCAtPiBwYXJlbnQ6YiB0IC0+IHBhcmVudF9pbmRleDppbnQgLT4gdW5pdFxuICA9XG4gIGZ1biB+Y2hpbGQgfmNoaWxkX2luZGV4IH5wYXJlbnQgfnBhcmVudF9pbmRleCAtPlxuICBzZXRfcGFyZW50IH5jaGlsZCB+cGFyZW50OlVvcHQubm9uZSB+cGFyZW50X2luZGV4O1xuICBpZiBkZWJ1Z1xuICB0aGVuIChcbiAgICBjaGlsZC5teV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXguKHBhcmVudF9pbmRleCkgPC0gLTE7XG4gICAgcGFyZW50Lm15X3BhcmVudF9pbmRleF9pbl9jaGlsZF9hdF9pbmRleC4oY2hpbGRfaW5kZXgpIDwtIC0xKVxuOztcblxubGV0IGFkZF9wYXJlbnQgOiB0eXBlIGEgYi4gY2hpbGQ6YSB0IC0+IHBhcmVudDpiIHQgLT4gY2hpbGRfaW5kZXg6aW50IC0+IHVuaXQgPVxuICBmdW4gfmNoaWxkIH5wYXJlbnQgfmNoaWxkX2luZGV4IC0+XG4gIG1ha2Vfc3BhY2VfZm9yX3BhcmVudF9pZl9uZWNlc3NhcnkgY2hpbGQ7XG4gIG1ha2Vfc3BhY2VfZm9yX2NoaWxkX2lmX25lY2Vzc2FyeSBwYXJlbnQgfmNoaWxkX2luZGV4O1xuICBsaW5rIH5jaGlsZCB+Y2hpbGRfaW5kZXggfnBhcmVudCB+cGFyZW50X2luZGV4OmNoaWxkLm51bV9wYXJlbnRzO1xuICBjaGlsZC5udW1fcGFyZW50cyA8LSBjaGlsZC5udW1fcGFyZW50cyArIDFcbjs7XG5cbmxldCByZW1vdmVfcGFyZW50IDogdHlwZSBhIGIuIGNoaWxkOmEgdCAtPiBwYXJlbnQ6YiB0IC0+IGNoaWxkX2luZGV4OmludCAtPiB1bml0ID1cbiAgZnVuIH5jaGlsZCB+cGFyZW50IH5jaGlsZF9pbmRleCAtPlxuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoY2hpbGQubnVtX3BhcmVudHMgPj0gMSk7XG4gIGxldCBwYXJlbnRfaW5kZXggPSBwYXJlbnQubXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4LihjaGlsZF9pbmRleCkgaW5cbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKHBhY2tlZF9zYW1lIChUIHBhcmVudCkgKGdldF9wYXJlbnQgY2hpbGQgfmluZGV4OnBhcmVudF9pbmRleCkpO1xuICBsZXQgbGFzdF9wYXJlbnRfaW5kZXggPSBjaGlsZC5udW1fcGFyZW50cyAtIDEgaW5cbiAgaWYgcGFyZW50X2luZGV4IDwgbGFzdF9wYXJlbnRfaW5kZXhcbiAgdGhlbiAoXG4gICAgbGV0IChUIHBhcmVudCkgPVxuICAgICAgVW9wdC52YWx1ZV9leG4gKFVuaWZvcm1fYXJyYXkuZ2V0IGNoaWxkLnBhcmVudDFfYW5kX2JleW9uZCAobGFzdF9wYXJlbnRfaW5kZXggLSAxKSlcbiAgICBpblxuICAgIGxpbmtcbiAgICAgIH5jaGlsZFxuICAgICAgfmNoaWxkX2luZGV4OmNoaWxkLm15X2NoaWxkX2luZGV4X2luX3BhcmVudF9hdF9pbmRleC4obGFzdF9wYXJlbnRfaW5kZXgpXG4gICAgICB+cGFyZW50XG4gICAgICB+cGFyZW50X2luZGV4KTtcbiAgdW5saW5rIH5jaGlsZCB+Y2hpbGRfaW5kZXggfnBhcmVudCB+cGFyZW50X2luZGV4Omxhc3RfcGFyZW50X2luZGV4O1xuICBjaGlsZC5udW1fcGFyZW50cyA8LSBjaGlsZC5udW1fcGFyZW50cyAtIDFcbjs7XG5cbmxldCBzd2FwX2NoaWxkcmVuX2V4Y2VwdF9pbl9raW5kIHBhcmVudCB+Y2hpbGQxIH5jaGlsZF9pbmRleDEgfmNoaWxkMiB+Y2hpbGRfaW5kZXgyID1cbiAgaWYgZGVidWdcbiAgdGhlbiAoXG4gICAgYXNzZXJ0IChwYWNrZWRfc2FtZSAoVCBjaGlsZDEpIChLaW5kLnNsb3dfZ2V0X2NoaWxkIHBhcmVudC5raW5kIH5pbmRleDpjaGlsZF9pbmRleDEpKTtcbiAgICBhc3NlcnQgKHBhY2tlZF9zYW1lIChUIGNoaWxkMikgKEtpbmQuc2xvd19nZXRfY2hpbGQgcGFyZW50LmtpbmQgfmluZGV4OmNoaWxkX2luZGV4MikpKTtcbiAgbGV0IGluZGV4X29mX3BhcmVudF9pbl9jaGlsZDEgPVxuICAgIHBhcmVudC5teV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW5kZXguKGNoaWxkX2luZGV4MSlcbiAgaW5cbiAgbGV0IGluZGV4X29mX3BhcmVudF9pbl9jaGlsZDIgPVxuICAgIHBhcmVudC5teV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW5kZXguKGNoaWxkX2luZGV4MilcbiAgaW5cbiAgaWYgZGVidWdcbiAgdGhlbiAoXG4gICAgYXNzZXJ0IChcbiAgICAgIGNoaWxkMS5teV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXguKGluZGV4X29mX3BhcmVudF9pbl9jaGlsZDEpID0gY2hpbGRfaW5kZXgxKTtcbiAgICBhc3NlcnQgKFxuICAgICAgY2hpbGQyLm15X2NoaWxkX2luZGV4X2luX3BhcmVudF9hdF9pbmRleC4oaW5kZXhfb2ZfcGFyZW50X2luX2NoaWxkMikgPSBjaGlsZF9pbmRleDIpKTtcbiAgKCogbm93IHN0YXJ0IHN3YXBwaW5nICopXG4gIGNoaWxkMS5teV9jaGlsZF9pbmRleF9pbl9wYXJlbnRfYXRfaW5kZXguKGluZGV4X29mX3BhcmVudF9pbl9jaGlsZDEpIDwtIGNoaWxkX2luZGV4MjtcbiAgY2hpbGQyLm15X2NoaWxkX2luZGV4X2luX3BhcmVudF9hdF9pbmRleC4oaW5kZXhfb2ZfcGFyZW50X2luX2NoaWxkMikgPC0gY2hpbGRfaW5kZXgxO1xuICBwYXJlbnQubXlfcGFyZW50X2luZGV4X2luX2NoaWxkX2F0X2luZGV4LihjaGlsZF9pbmRleDEpIDwtIGluZGV4X29mX3BhcmVudF9pbl9jaGlsZDI7XG4gIHBhcmVudC5teV9wYXJlbnRfaW5kZXhfaW5fY2hpbGRfYXRfaW5kZXguKGNoaWxkX2luZGV4MikgPC0gaW5kZXhfb2ZfcGFyZW50X2luX2NoaWxkMVxuOztcblxubW9kdWxlIFBhY2tlZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBQYWNrZWQudCA9IFQgOiBfIFR5cGVzLk5vZGUudCAtPiB0IFtAQHVuYm94ZWRdXG5cbiAgbGV0IHNleHBfb2ZfdCAoVCB0KSA9IHQgfD4gWyVzZXhwX29mOiBfIHRdXG4gIGxldCBpbnZhcmlhbnQgKFQgdCkgPSBpbnZhcmlhbnQgaWdub3JlIHRcblxuICBtb2R1bGUgQXNfbGlzdCAoTSA6IHNpZ1xuICAgIHZhbCBuZXh0IDogUGFja2VkLnQgLT4gUGFja2VkLnQgVW9wdC50XG4gIGVuZCkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBQYWNrZWQudCBVb3B0LnRcblxuICAgIGxldCBmb2xkIHQgfmluaXQgfmYgPVxuICAgICAgbGV0IGFjID0gcmVmIGluaXQgaW5cbiAgICAgIGxldCByID0gcmVmIHQgaW5cbiAgICAgIHdoaWxlIFVvcHQuaXNfc29tZSAhciBkb1xuICAgICAgICBsZXQgcGFja2VkX25vZGUgPSBVb3B0LnVuc2FmZV92YWx1ZSAhciBpblxuICAgICAgICByIDo9IE0ubmV4dCBwYWNrZWRfbm9kZTtcbiAgICAgICAgYWMgOj0gZiAhYWMgcGFja2VkX25vZGVcbiAgICAgIGRvbmU7XG4gICAgICAhYWNcbiAgICA7O1xuXG4gICAgbGV0IGl0ZXIgdCB+ZiA9IGZvbGQgdCB+aW5pdDooKSB+ZjooZnVuICgpIG4gLT4gZiBuKVxuICAgIGxldCBpbnZhcmlhbnQgdCA9IGl0ZXIgdCB+ZjppbnZhcmlhbnRcbiAgICBsZXQgbGVuZ3RoIHQgPSBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIG4gXyAtPiBuICsgMSlcbiAgICBsZXQgdG9fbGlzdCB0ID0gTGlzdC5yZXYgKGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIGFjIG4gLT4gbiA6OiBhYykpXG4gICAgbGV0IHNleHBfb2ZfdCB0ID0gdG9fbGlzdCB0IHw+IFslc2V4cF9vZjogUGFja2VkLnQgbGlzdF1cbiAgZW5kXG5cbiAgbGV0IGl0ZXJfZGVzY2VuZGFudHNfaW50ZXJuYWwgdHMgfmYgPVxuICAgIGxldCBzZWVuID0gTm9kZV9pZC5IYXNoX3NldC5jcmVhdGUgKCkgaW5cbiAgICBsZXQgcmVjIGl0ZXJfZGVzY2VuZGFudHMgKFQgdCkgPVxuICAgICAgaWYgbm90IChIYXNoX3NldC5tZW0gc2VlbiB0LmlkKVxuICAgICAgdGhlbiAoXG4gICAgICAgIEhhc2hfc2V0LmFkZCBzZWVuIHQuaWQ7XG4gICAgICAgIGYgKFQgdCk7XG4gICAgICAgIGl0ZXJpX2NoaWxkcmVuIHQgfmY6KGZ1biBfIHQgLT4gaXRlcl9kZXNjZW5kYW50cyB0KSlcbiAgICBpblxuICAgIExpc3QuaXRlciB0cyB+ZjppdGVyX2Rlc2NlbmRhbnRzO1xuICAgIHNlZW5cbiAgOztcblxuICBsZXQgaXRlcl9kZXNjZW5kYW50cyB0cyB+ZiA9IGlnbm9yZSAoaXRlcl9kZXNjZW5kYW50c19pbnRlcm5hbCB0cyB+ZiA6IF8gSGFzaF9zZXQudClcbiAgbGV0IGFwcGVuZF91c2VyX2luZm9fZ3JhcGh2aXogKFQgdCkgPSBhcHBlbmRfdXNlcl9pbmZvX2dyYXBodml6IHRcbmVuZFxuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxuXG5tb2R1bGUgQXNfcmVjb21wdXRlX2xpc3QgPSBOb2RlLlBhY2tlZC5Bc19saXN0IChzdHJ1Y3RcbiAgbGV0IG5leHQgKE5vZGUuUGFja2VkLlQgbm9kZSkgPSBub2RlLm5leHRfaW5fcmVjb21wdXRlX2hlYXBcbmVuZClcblxubW9kdWxlIE5vZGVzX2J5X2hlaWdodCA9IHN0cnVjdFxuICB0eXBlIHQgPSBBc19yZWNvbXB1dGVfbGlzdC50IFVuaWZvcm1fYXJyYXkudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICgqIFdlIGRpc3BsYXkgdGhlIHNtYWxsZXN0IHByZWZpeCBvZiBbbm9kZXNfYnlfaGVpZ2h0XSB0aGF0IGluY2x1ZGVzIGFsbCBub2Rlcy4gKilcbiAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICBsZXQgbWF4X25vbmVtcHR5X2luZGV4ID0gcmVmICgtMSkgaW5cbiAgICBVbmlmb3JtX2FycmF5Lml0ZXJpIHQgfmY6KGZ1biBpIGwgLT4gaWYgVW9wdC5pc19zb21lIGwgdGhlbiBtYXhfbm9uZW1wdHlfaW5kZXggOj0gaSk7XG4gICAgVW5pZm9ybV9hcnJheS5zdWIgdCB+cG9zOjAgfmxlbjooIW1heF9ub25lbXB0eV9pbmRleCArIDEpIHw+IFslc2V4cF9vZjogdF1cbiAgOztcbmVuZFxuXG50eXBlIHQgPSBUeXBlcy5SZWNvbXB1dGVfaGVhcC50ID1cbiAgeyBtdXRhYmxlIGxlbmd0aCA6IGludFxuICA7IG11dGFibGUgaGVpZ2h0X2xvd2VyX2JvdW5kIDogaW50XG4gIDsgbXV0YWJsZSBub2Rlc19ieV9oZWlnaHQgOiBOb2Rlc19ieV9oZWlnaHQudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG5sZXQgbWF4X2hlaWdodF9hbGxvd2VkIHQgPSBVbmlmb3JtX2FycmF5Lmxlbmd0aCB0Lm5vZGVzX2J5X2hlaWdodCAtIDFcbmxldCBpc19lbXB0eSB0ID0gdC5sZW5ndGggPSAwXG5cbmxldCBpbnZhcmlhbnQgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+bGVuZ3RoOlxuICAgICAgICAoY2hlY2sgKGZ1biBsZW5ndGggLT5cbiAgICAgICAgICAgbGV0IGFjdHVhbF9sZW5ndGggPSByZWYgMCBpblxuICAgICAgICAgICBVbmlmb3JtX2FycmF5Lml0ZXIgdC5ub2Rlc19ieV9oZWlnaHQgfmY6KGZ1biBub2RlIC0+XG4gICAgICAgICAgICAgYWN0dWFsX2xlbmd0aCA6PSAhYWN0dWFsX2xlbmd0aCArIEFzX3JlY29tcHV0ZV9saXN0Lmxlbmd0aCBub2RlKTtcbiAgICAgICAgICAgWyV0ZXN0X2VxOiBpbnRdIGxlbmd0aCAhYWN0dWFsX2xlbmd0aCkpXG4gICAgICB+aGVpZ2h0X2xvd2VyX2JvdW5kOlxuICAgICAgICAoY2hlY2sgKGZ1biBoZWlnaHRfbG93ZXJfYm91bmQgLT5cbiAgICAgICAgICAgYXNzZXJ0IChoZWlnaHRfbG93ZXJfYm91bmQgPj0gMCk7XG4gICAgICAgICAgIGFzc2VydCAoaGVpZ2h0X2xvd2VyX2JvdW5kIDw9IFVuaWZvcm1fYXJyYXkubGVuZ3RoIHQubm9kZXNfYnlfaGVpZ2h0KTtcbiAgICAgICAgICAgZm9yIGhlaWdodCA9IDAgdG8gaGVpZ2h0X2xvd2VyX2JvdW5kIC0gMSBkb1xuICAgICAgICAgICAgIGFzc2VydCAoVW9wdC5pc19ub25lIChVbmlmb3JtX2FycmF5LmdldCB0Lm5vZGVzX2J5X2hlaWdodCBoZWlnaHQpKVxuICAgICAgICAgICBkb25lKSlcbiAgICAgIH5ub2Rlc19ieV9oZWlnaHQ6XG4gICAgICAgIChjaGVjayAoZnVuIG5vZGVzX2J5X2hlaWdodCAtPlxuICAgICAgICAgICBVbmlmb3JtX2FycmF5Lml0ZXJpIG5vZGVzX2J5X2hlaWdodCB+ZjooZnVuIGhlaWdodCBub2RlIC0+XG4gICAgICAgICAgICAgQXNfcmVjb21wdXRlX2xpc3QuaXRlciBub2RlIH5mOihmdW4gKFQgbm9kZSkgLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAobm9kZS5oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAgPSBoZWlnaHQpO1xuICAgICAgICAgICAgICAgYXNzZXJ0IChOb2RlLm5lZWRzX3RvX2JlX2NvbXB1dGVkIG5vZGUpKSkpKSlcbjs7XG5cbmxldCBjcmVhdGVfbm9kZXNfYnlfaGVpZ2h0IH5tYXhfaGVpZ2h0X2FsbG93ZWQgPVxuICBVbmlmb3JtX2FycmF5LmNyZWF0ZSB+bGVuOihtYXhfaGVpZ2h0X2FsbG93ZWQgKyAxKSBVb3B0Lm5vbmVcbjs7XG5cbmxldCBzZXRfbWF4X2hlaWdodF9hbGxvd2VkIHQgbWF4X2hlaWdodF9hbGxvd2VkID1cbiAgaWYgZGVidWdcbiAgdGhlblxuICAgIGZvciBpID0gbWF4X2hlaWdodF9hbGxvd2VkICsgMSB0byBVbmlmb3JtX2FycmF5Lmxlbmd0aCB0Lm5vZGVzX2J5X2hlaWdodCAtIDEgZG9cbiAgICAgIGFzc2VydCAoVW9wdC5pc19ub25lIChVbmlmb3JtX2FycmF5LmdldCB0Lm5vZGVzX2J5X2hlaWdodCBpKSlcbiAgICBkb25lO1xuICBsZXQgc3JjID0gdC5ub2Rlc19ieV9oZWlnaHQgaW5cbiAgbGV0IGRzdCA9IGNyZWF0ZV9ub2Rlc19ieV9oZWlnaHQgfm1heF9oZWlnaHRfYWxsb3dlZCBpblxuICBVbmlmb3JtX2FycmF5LmJsaXRcbiAgICB+c3JjXG4gICAgfnNyY19wb3M6MFxuICAgIH5kc3RcbiAgICB+ZHN0X3BvczowXG4gICAgfmxlbjoobWluIChVbmlmb3JtX2FycmF5Lmxlbmd0aCBzcmMpIChVbmlmb3JtX2FycmF5Lmxlbmd0aCBkc3QpKTtcbiAgdC5ub2Rlc19ieV9oZWlnaHQgPC0gZHN0O1xuICB0LmhlaWdodF9sb3dlcl9ib3VuZCA8LSBtaW4gdC5oZWlnaHRfbG93ZXJfYm91bmQgKFVuaWZvcm1fYXJyYXkubGVuZ3RoIGRzdClcbjs7XG5cbmxldCBjcmVhdGUgfm1heF9oZWlnaHRfYWxsb3dlZCA9XG4gIHsgbGVuZ3RoID0gMFxuICA7IGhlaWdodF9sb3dlcl9ib3VuZCA9IG1heF9oZWlnaHRfYWxsb3dlZCArIDFcbiAgOyBub2Rlc19ieV9oZWlnaHQgPSBjcmVhdGVfbm9kZXNfYnlfaGVpZ2h0IH5tYXhfaGVpZ2h0X2FsbG93ZWRcbiAgfVxuOztcblxubGV0IHNldF9uZXh0IChwcmV2IDogTm9kZS5QYWNrZWQudCBVb3B0LnQpIH5uZXh0ID1cbiAgaWYgVW9wdC5pc19zb21lIHByZXZcbiAgdGhlbiAoXG4gICAgbGV0IChUIHByZXYpID0gVW9wdC51bnNhZmVfdmFsdWUgcHJldiBpblxuICAgIHByZXYubmV4dF9pbl9yZWNvbXB1dGVfaGVhcCA8LSBuZXh0KVxuOztcblxubGV0IHNldF9wcmV2IChuZXh0IDogTm9kZS5QYWNrZWQudCBVb3B0LnQpIH5wcmV2ID1cbiAgaWYgVW9wdC5pc19zb21lIG5leHRcbiAgdGhlbiAoXG4gICAgbGV0IChUIG5leHQpID0gVW9wdC51bnNhZmVfdmFsdWUgbmV4dCBpblxuICAgIG5leHQucHJldl9pbl9yZWNvbXB1dGVfaGVhcCA8LSBwcmV2KVxuOztcblxubGV0IGxpbmsgKHR5cGUgYSkgdCAobm9kZSA6IGEgTm9kZS50KSA9XG4gIGxldCBoZWlnaHQgPSBub2RlLmhlaWdodCBpblxuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoaGVpZ2h0IDw9IG1heF9oZWlnaHRfYWxsb3dlZCB0KTtcbiAgbm9kZS5oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAgPC0gaGVpZ2h0O1xuICBsZXQgbmV4dCA9IFVuaWZvcm1fYXJyYXkuZ2V0IHQubm9kZXNfYnlfaGVpZ2h0IGhlaWdodCBpblxuICBub2RlLm5leHRfaW5fcmVjb21wdXRlX2hlYXAgPC0gbmV4dDtcbiAgc2V0X3ByZXYgbmV4dCB+cHJldjooVW9wdC5zb21lIChOb2RlLlBhY2tlZC5UIG5vZGUpKTtcbiAgVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQubm9kZXNfYnlfaGVpZ2h0IGhlaWdodCAoVW9wdC5zb21lIChOb2RlLlBhY2tlZC5UIG5vZGUpKVxuOztcblxubGV0IHVubGluayAodHlwZSBhKSB0IChub2RlIDogYSBOb2RlLnQpID1cbiAgbGV0IHByZXYgPSBub2RlLnByZXZfaW5fcmVjb21wdXRlX2hlYXAgaW5cbiAgbGV0IG5leHQgPSBub2RlLm5leHRfaW5fcmVjb21wdXRlX2hlYXAgaW5cbiAgaWYgcGh5c19zYW1lXG4gICAgICAgKFVvcHQuc29tZSBub2RlKVxuICAgICAgIChVbmlmb3JtX2FycmF5LmdldCB0Lm5vZGVzX2J5X2hlaWdodCBub2RlLmhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcClcbiAgdGhlbiBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdC5ub2Rlc19ieV9oZWlnaHQgbm9kZS5oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAgbmV4dDtcbiAgc2V0X3ByZXYgbmV4dCB+cHJldjtcbiAgc2V0X25leHQgcHJldiB+bmV4dDtcbiAgbm9kZS5wcmV2X2luX3JlY29tcHV0ZV9oZWFwIDwtIFVvcHQubm9uZVxuOztcblxuKCogV2UgZG9uJ3Qgc2V0IFtub2RlLm5leHRfaW5fcmVjb21wdXRlX2hlYXBdIGhlcmUsIGJ1dCByYXRoZXIgYWZ0ZXIgY2FsbGluZyBbdW5saW5rXS4gKilcblxubGV0IGFkZCAodHlwZSBhKSB0IChub2RlIDogYSBOb2RlLnQpID1cbiAgaWYgZGVidWcgJiYgKE5vZGUuaXNfaW5fcmVjb21wdXRlX2hlYXAgbm9kZSB8fCBub3QgKE5vZGUubmVlZHNfdG9fYmVfY29tcHV0ZWQgbm9kZSkpXG4gIHRoZW5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiaW5jb3JyZWN0IGF0dGVtcHQgdG8gYWRkIG5vZGUgdG8gcmVjb21wdXRlIGhlYXBcIlxuICAgICAgbm9kZVxuICAgICAgWyVzZXhwX29mOiBfIE5vZGUudF07XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChub2RlLmhlaWdodCA8PSBtYXhfaGVpZ2h0X2FsbG93ZWQgdCk7XG4gIGxldCBoZWlnaHQgPSBub2RlLmhlaWdodCBpblxuICBpZiBoZWlnaHQgPCB0LmhlaWdodF9sb3dlcl9ib3VuZCB0aGVuIHQuaGVpZ2h0X2xvd2VyX2JvdW5kIDwtIGhlaWdodDtcbiAgbGluayB0IG5vZGU7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuOztcblxubGV0IHJlbW92ZSAodHlwZSBhKSB0IChub2RlIDogYSBOb2RlLnQpID1cbiAgaWYgZGVidWcgJiYgKChub3QgKE5vZGUuaXNfaW5fcmVjb21wdXRlX2hlYXAgbm9kZSkpIHx8IE5vZGUubmVlZHNfdG9fYmVfY29tcHV0ZWQgbm9kZSlcbiAgdGhlblxuICAgIGZhaWx3aXRoc1xuICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgXCJpbmNvcnJlY3QgW3JlbW92ZV0gb2Ygbm9kZSBmcm9tIHJlY29tcHV0ZSBoZWFwXCJcbiAgICAgIG5vZGVcbiAgICAgIFslc2V4cF9vZjogXyBOb2RlLnRdO1xuICB1bmxpbmsgdCBub2RlO1xuICBub2RlLm5leHRfaW5fcmVjb21wdXRlX2hlYXAgPC0gVW9wdC5ub25lO1xuICBub2RlLmhlaWdodF9pbl9yZWNvbXB1dGVfaGVhcCA8LSAtMTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxXG47O1xuXG5sZXQgaW5jcmVhc2VfaGVpZ2h0ICh0eXBlIGEpIHQgKG5vZGUgOiBhIE5vZGUudCkgPVxuICBpZiBkZWJ1Z1xuICB0aGVuIChcbiAgICBhc3NlcnQgKG5vZGUuaGVpZ2h0ID4gbm9kZS5oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXApO1xuICAgIGFzc2VydCAobm9kZS5oZWlnaHQgPD0gbWF4X2hlaWdodF9hbGxvd2VkIHQpO1xuICAgIGFzc2VydCAoTm9kZS5pc19pbl9yZWNvbXB1dGVfaGVhcCBub2RlKSk7XG4gIHVubGluayB0IG5vZGU7XG4gIGxpbmsgdCBub2RlXG47O1xuXG5sZXQgbWluX2hlaWdodCB0ID1cbiAgaWYgdC5sZW5ndGggPSAwXG4gIHRoZW4gdC5oZWlnaHRfbG93ZXJfYm91bmQgPC0gVW5pZm9ybV9hcnJheS5sZW5ndGggdC5ub2Rlc19ieV9oZWlnaHRcbiAgZWxzZSAoXG4gICAgbGV0IG5vZGVzX2J5X2hlaWdodCA9IHQubm9kZXNfYnlfaGVpZ2h0IGluXG4gICAgd2hpbGUgVW9wdC5pc19ub25lIChVbmlmb3JtX2FycmF5LmdldCBub2Rlc19ieV9oZWlnaHQgdC5oZWlnaHRfbG93ZXJfYm91bmQpIGRvXG4gICAgICB0LmhlaWdodF9sb3dlcl9ib3VuZCA8LSB0LmhlaWdodF9sb3dlcl9ib3VuZCArIDFcbiAgICBkb25lKTtcbiAgdC5oZWlnaHRfbG93ZXJfYm91bmRcbjs7XG5cbmxldCByZW1vdmVfbWluIHQgOiBOb2RlLlBhY2tlZC50ID1cbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKG5vdCAoaXNfZW1wdHkgdCkpO1xuICBsZXQgbm9kZXNfYnlfaGVpZ2h0ID0gdC5ub2Rlc19ieV9oZWlnaHQgaW5cbiAgbGV0IG5vZGUgPSByZWYgKFVuaWZvcm1fYXJyYXkuZ2V0IG5vZGVzX2J5X2hlaWdodCB0LmhlaWdodF9sb3dlcl9ib3VuZCkgaW5cbiAgd2hpbGUgVW9wdC5pc19ub25lICFub2RlIGRvXG4gICAgdC5oZWlnaHRfbG93ZXJfYm91bmQgPC0gdC5oZWlnaHRfbG93ZXJfYm91bmQgKyAxO1xuICAgIGlmIGRlYnVnICYmIHQuaGVpZ2h0X2xvd2VyX2JvdW5kID49IFVuaWZvcm1fYXJyYXkubGVuZ3RoIHQubm9kZXNfYnlfaGVpZ2h0XG4gICAgdGhlblxuICAgICAgZmFpbHdpdGhzXG4gICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgXCJSZWNvbXB1dGVfaGVhcC5yZW1vdmVfbWluIHVuZXhwZWN0ZWRseSByZWFjaGVkIGVuZCBvZiBoZWFwXCJcbiAgICAgICAgdFxuICAgICAgICBbJXNleHBfb2Y6IHRdO1xuICAgIG5vZGUgOj0gVW5pZm9ybV9hcnJheS5nZXQgbm9kZXNfYnlfaGVpZ2h0IHQuaGVpZ2h0X2xvd2VyX2JvdW5kXG4gIGRvbmU7XG4gIGxldCAoVCBub2RlKSA9IFVvcHQudW5zYWZlX3ZhbHVlICFub2RlIGluXG4gIG5vZGUuaGVpZ2h0X2luX3JlY29tcHV0ZV9oZWFwIDwtIC0xO1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDE7XG4gIGxldCBuZXh0ID0gbm9kZS5uZXh0X2luX3JlY29tcHV0ZV9oZWFwIGluXG4gIFVuaWZvcm1fYXJyYXkuc2V0IHQubm9kZXNfYnlfaGVpZ2h0IHQuaGVpZ2h0X2xvd2VyX2JvdW5kIG5leHQ7XG4gIHNldF9wcmV2IG5leHQgfnByZXY6VW9wdC5ub25lO1xuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoVW9wdC5pc19ub25lIG5vZGUucHJldl9pbl9yZWNvbXB1dGVfaGVhcCk7XG4gIG5vZGUubmV4dF9pbl9yZWNvbXB1dGVfaGVhcCA8LSBVb3B0Lm5vbmU7XG4gIFQgbm9kZVxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbm9wZW4gVHlwZXMuS2luZFxuXG5tb2R1bGUgQXNfYWRqdXN0X2hlaWdodHNfbGlzdCA9IE5vZGUuUGFja2VkLkFzX2xpc3QgKHN0cnVjdFxuICBsZXQgbmV4dCAoTm9kZS5QYWNrZWQuVCBub2RlKSA9IG5vZGUubmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwXG5lbmQpXG5cbm1vZHVsZSBOb2Rlc19ieV9oZWlnaHQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gQXNfYWRqdXN0X2hlaWdodHNfbGlzdC50IFVuaWZvcm1fYXJyYXkudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBzZXhwX29mX3QgdCA9XG4gICAgbGV0IG1heF9ub25lbXB0eV9pbmRleCA9IHJlZiAoLTEpIGluXG4gICAgVW5pZm9ybV9hcnJheS5pdGVyaSB0IH5mOihmdW4gaSBsIC0+IGlmIFVvcHQuaXNfc29tZSBsIHRoZW4gbWF4X25vbmVtcHR5X2luZGV4IDo9IGkpO1xuICAgIFVuaWZvcm1fYXJyYXkuc3ViIHQgfnBvczowIH5sZW46KCFtYXhfbm9uZW1wdHlfaW5kZXggKyAxKSB8PiBbJXNleHBfb2Y6IHRdXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudCB0ID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgIFVuaWZvcm1fYXJyYXkuaXRlcmkgdCB+ZjooZnVuIGhlaWdodCBub2RlcyAtPlxuICAgICAgICBBc19hZGp1c3RfaGVpZ2h0c19saXN0LmludmFyaWFudCBub2RlcztcbiAgICAgICAgQXNfYWRqdXN0X2hlaWdodHNfbGlzdC5pdGVyIG5vZGVzIH5mOihmdW4gKFQgbm9kZSkgLT5cbiAgICAgICAgICBhc3NlcnQgKG5vZGUuaGVpZ2h0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAgPSBoZWlnaHQpO1xuICAgICAgICAgIGFzc2VydCAobm9kZS5oZWlnaHQgPiBub2RlLmhlaWdodF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwKTtcbiAgICAgICAgICBpZiBOb2RlLmlzX2luX3JlY29tcHV0ZV9oZWFwIG5vZGVcbiAgICAgICAgICB0aGVuIGFzc2VydCAobm9kZS5oZWlnaHRfaW5fcmVjb21wdXRlX2hlYXAgPSBub2RlLmhlaWdodF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwKSkpKVxuICA7O1xuXG4gIGxldCBjcmVhdGUgfm1heF9oZWlnaHRfYWxsb3dlZCA9XG4gICAgVW5pZm9ybV9hcnJheS5jcmVhdGUgfmxlbjoobWF4X2hlaWdodF9hbGxvd2VkICsgMSkgVW9wdC5ub25lXG4gIDs7XG5cbiAgbGV0IGxlbmd0aCB0ID1cbiAgICBsZXQgciA9IHJlZiAwIGluXG4gICAgVW5pZm9ybV9hcnJheS5pdGVyIHQgfmY6KGZ1biBub2RlIC0+IHIgOj0gIXIgKyBBc19hZGp1c3RfaGVpZ2h0c19saXN0Lmxlbmd0aCBub2RlKTtcbiAgICAhclxuICA7O1xuZW5kXG5cbnR5cGUgdCA9IFR5cGVzLkFkanVzdF9oZWlnaHRzX2hlYXAudCA9XG4gIHsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgOyBtdXRhYmxlIGhlaWdodF9sb3dlcl9ib3VuZCA6IGludFxuICA7IG11dGFibGUgbWF4X2hlaWdodF9zZWVuIDogaW50XG4gIDsgbXV0YWJsZSBub2Rlc19ieV9oZWlnaHQgOiBOb2Rlc19ieV9oZWlnaHQudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxubGV0IG1heF9oZWlnaHRfYWxsb3dlZCB0ID0gVW5pZm9ybV9hcnJheS5sZW5ndGggdC5ub2Rlc19ieV9oZWlnaHQgLSAxXG5cbmxldCBpbnZhcmlhbnQgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+bGVuZ3RoOlxuICAgICAgICAoY2hlY2sgKGZ1biBsZW5ndGggLT4gYXNzZXJ0IChsZW5ndGggPSBOb2Rlc19ieV9oZWlnaHQubGVuZ3RoIHQubm9kZXNfYnlfaGVpZ2h0KSkpXG4gICAgICB+aGVpZ2h0X2xvd2VyX2JvdW5kOlxuICAgICAgICAoY2hlY2sgKGZ1biBoZWlnaHRfbG93ZXJfYm91bmQgLT5cbiAgICAgICAgICAgYXNzZXJ0IChoZWlnaHRfbG93ZXJfYm91bmQgPj0gMCk7XG4gICAgICAgICAgIGFzc2VydCAoaGVpZ2h0X2xvd2VyX2JvdW5kIDw9IFVuaWZvcm1fYXJyYXkubGVuZ3RoIHQubm9kZXNfYnlfaGVpZ2h0KTtcbiAgICAgICAgICAgZm9yIGhlaWdodCA9IDAgdG8gaGVpZ2h0X2xvd2VyX2JvdW5kIC0gMSBkb1xuICAgICAgICAgICAgIGFzc2VydCAoVW9wdC5pc19ub25lIChVbmlmb3JtX2FycmF5LmdldCB0Lm5vZGVzX2J5X2hlaWdodCBoZWlnaHQpKVxuICAgICAgICAgICBkb25lKSlcbiAgICAgIH5tYXhfaGVpZ2h0X3NlZW46XG4gICAgICAgIChjaGVjayAoZnVuIG1heF9oZWlnaHRfc2VlbiAtPlxuICAgICAgICAgICBhc3NlcnQgKG1heF9oZWlnaHRfc2VlbiA+PSAwKTtcbiAgICAgICAgICAgYXNzZXJ0IChtYXhfaGVpZ2h0X3NlZW4gPD0gbWF4X2hlaWdodF9hbGxvd2VkIHQpKSlcbiAgICAgIH5ub2Rlc19ieV9oZWlnaHQ6KGNoZWNrIE5vZGVzX2J5X2hlaWdodC5pbnZhcmlhbnQpKVxuOztcblxubGV0IGNyZWF0ZSB+bWF4X2hlaWdodF9hbGxvd2VkID1cbiAgeyBsZW5ndGggPSAwXG4gIDsgaGVpZ2h0X2xvd2VyX2JvdW5kID0gbWF4X2hlaWdodF9hbGxvd2VkICsgMVxuICA7IG1heF9oZWlnaHRfc2VlbiA9IDBcbiAgOyBub2Rlc19ieV9oZWlnaHQgPSBOb2Rlc19ieV9oZWlnaHQuY3JlYXRlIH5tYXhfaGVpZ2h0X2FsbG93ZWRcbiAgfVxuOztcblxubGV0IHNldF9tYXhfaGVpZ2h0X2FsbG93ZWQgdCBtYXhfaGVpZ2h0X2FsbG93ZWQgPVxuICBpZiBtYXhfaGVpZ2h0X2FsbG93ZWQgPCB0Lm1heF9oZWlnaHRfc2VlblxuICB0aGVuXG4gICAgZmFpbHdpdGhzXG4gICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICBcImNhbm5vdCBzZXRfbWF4X2hlaWdodF9hbGxvd2VkIGxlc3MgdGhhbiB0aGUgbWF4IGhlaWdodCBhbHJlYWR5IHNlZW5cIlxuICAgICAgKG1heF9oZWlnaHRfYWxsb3dlZCwgYG1heF9oZWlnaHRfc2VlbiB0Lm1heF9oZWlnaHRfc2VlbilcbiAgICAgIFslc2V4cF9vZjogaW50ICogWyBgbWF4X2hlaWdodF9zZWVuIG9mIGludCBdXTtcbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKGlzX2VtcHR5IHQpO1xuICB0Lm5vZGVzX2J5X2hlaWdodCA8LSBOb2Rlc19ieV9oZWlnaHQuY3JlYXRlIH5tYXhfaGVpZ2h0X2FsbG93ZWRcbjs7XG5cbmxldCBhZGRfdW5sZXNzX21lbSAodHlwZSBhKSB0IChub2RlIDogYSBOb2RlLnQpID1cbiAgaWYgbm9kZS5oZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCA9IC0xXG4gIHRoZW4gKFxuICAgIGxldCBoZWlnaHQgPSBub2RlLmhlaWdodCBpblxuICAgICgqIFdlIHByb2Nlc3Mgbm9kZXMgaW4gaW5jcmVhc2luZyBvcmRlciBvZiBwcmUtYWRqdXN0ZWQgaGVpZ2h0LCBzbyBpdCBpcyBhIGJ1ZyBpZiB3ZVxuICAgICAgIGV2ZXIgdHJ5IHRvIGFkZCBhIG5vZGUgdGhhdCB3b3VsZCB2aW9sYXRlIHRoYXQuICopXG4gICAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKGhlaWdodCA+PSB0LmhlaWdodF9sb3dlcl9ib3VuZCk7XG4gICAgKCogV2hlbmV2ZXIgd2Ugc2V0IGEgbm9kZSdzIGhlaWdodCwgd2UgdXNlIFtzZXRfaGVpZ2h0XSwgd2hpY2ggZW5mb3JjZXMgdGhpcy4gKilcbiAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoaGVpZ2h0IDw9IG1heF9oZWlnaHRfYWxsb3dlZCB0KTtcbiAgICBub2RlLmhlaWdodF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwIDwtIGhlaWdodDtcbiAgICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDE7XG4gICAgbm9kZS5uZXh0X2luX2FkanVzdF9oZWlnaHRzX2hlYXAgPC0gVW5pZm9ybV9hcnJheS5nZXQgdC5ub2Rlc19ieV9oZWlnaHQgaGVpZ2h0O1xuICAgIFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0Lm5vZGVzX2J5X2hlaWdodCBoZWlnaHQgKFVvcHQuc29tZSAoTm9kZS5QYWNrZWQuVCBub2RlKSkpXG47O1xuXG5sZXQgcmVtb3ZlX21pbl9leG4gdCA6IE5vZGUuUGFja2VkLnQgPVxuICBpZiBkZWJ1ZyAmJiBpc19lbXB0eSB0XG4gIHRoZW5cbiAgICBmYWlsd2l0aHMgfmhlcmU6WyVoZXJlXSBcIkFkanVzdF9oZWlnaHRzX2hlYXAucmVtb3ZlX21pbiBvZiBlbXB0eSBoZWFwXCIgdCBbJXNleHBfb2Y6IHRdO1xuICBsZXQgciA9IHJlZiB0LmhlaWdodF9sb3dlcl9ib3VuZCBpblxuICB3aGlsZSBVb3B0LmlzX25vbmUgKFVuaWZvcm1fYXJyYXkuZ2V0IHQubm9kZXNfYnlfaGVpZ2h0ICFyKSBkb1xuICAgIGluY3IgclxuICBkb25lO1xuICBsZXQgaGVpZ2h0ID0gIXIgaW5cbiAgdC5oZWlnaHRfbG93ZXJfYm91bmQgPC0gaGVpZ2h0O1xuICBsZXQgKFQgbm9kZSkgPSBVb3B0LnVuc2FmZV92YWx1ZSAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQubm9kZXNfYnlfaGVpZ2h0IGhlaWdodCkgaW5cbiAgbm9kZS5oZWlnaHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCA8LSAtMTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdC5ub2Rlc19ieV9oZWlnaHQgaGVpZ2h0IG5vZGUubmV4dF9pbl9hZGp1c3RfaGVpZ2h0c19oZWFwO1xuICBub2RlLm5leHRfaW5fYWRqdXN0X2hlaWdodHNfaGVhcCA8LSBVb3B0Lm5vbmU7XG4gIFQgbm9kZVxuOztcblxubGV0IHNldF9oZWlnaHQgdCAobm9kZSA6IF8gTm9kZS50KSBoZWlnaHQgPVxuICBpZiBoZWlnaHQgPiB0Lm1heF9oZWlnaHRfc2VlblxuICB0aGVuIChcbiAgICB0Lm1heF9oZWlnaHRfc2VlbiA8LSBoZWlnaHQ7XG4gICAgaWYgaGVpZ2h0ID4gbWF4X2hlaWdodF9hbGxvd2VkIHRcbiAgICB0aGVuXG4gICAgICBmYWlsd2l0aHNcbiAgICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgICBcIm5vZGUgd2l0aCB0b28gbGFyZ2UgaGVpZ2h0XCJcbiAgICAgICAgKGBIZWlnaHQgaGVpZ2h0LCBgTWF4IChtYXhfaGVpZ2h0X2FsbG93ZWQgdCkpXG4gICAgICAgIFslc2V4cF9vZjogWyBgSGVpZ2h0IG9mIGludCBdICogWyBgTWF4IG9mIGludCBdXSk7XG4gIG5vZGUuaGVpZ2h0IDwtIGhlaWdodFxuOztcblxubGV0IGVuc3VyZV9oZWlnaHRfcmVxdWlyZW1lbnQgdCB+b3JpZ2luYWxfY2hpbGQgfm9yaWdpbmFsX3BhcmVudCB+Y2hpbGQgfnBhcmVudCA9XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLmlzX25lY2Vzc2FyeSBjaGlsZCk7XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLmlzX25lY2Vzc2FyeSBwYXJlbnQpO1xuICBpZiBOb2RlLnNhbWUgcGFyZW50IG9yaWdpbmFsX2NoaWxkXG4gIHRoZW5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiYWRkaW5nIGVkZ2UgbWFkZSBncmFwaCBjeWNsaWNcIlxuICAgICAgKGBjaGlsZCBvcmlnaW5hbF9jaGlsZCwgYHBhcmVudCBvcmlnaW5hbF9wYXJlbnQpXG4gICAgICBbJXNleHBfb2Y6IFsgYGNoaWxkIG9mIF8gTm9kZS50IF0gKiBbIGBwYXJlbnQgb2YgXyBOb2RlLnQgXV07XG4gIGlmIGNoaWxkLmhlaWdodCA+PSBwYXJlbnQuaGVpZ2h0XG4gIHRoZW4gKFxuICAgIGFkZF91bmxlc3NfbWVtIHQgcGFyZW50O1xuICAgICgqIFdlIHNldCBbcGFyZW50LmhlaWdodF0gYWZ0ZXIgYWRkaW5nIFtwYXJlbnRdIHRvIHRoZSBoZWFwLCBzbyB0aGF0IFtwYXJlbnRdIGdvZXNcbiAgICAgICBpbiB0aGUgaGVhcCB3aXRoIGl0cyBwcmUtYWRqdXN0ZWQgaGVpZ2h0LiAqKVxuICAgIHNldF9oZWlnaHQgdCBwYXJlbnQgKGNoaWxkLmhlaWdodCArIDEpKVxuOztcblxubGV0IGFkanVzdF9oZWlnaHRzXG4gICh0eXBlIGEgYilcbiAgdFxuICByZWNvbXB1dGVfaGVhcFxuICB+Y2hpbGQ6KG9yaWdpbmFsX2NoaWxkIDogYSBOb2RlLnQpXG4gIH5wYXJlbnQ6KG9yaWdpbmFsX3BhcmVudCA6IGIgTm9kZS50KVxuICA9XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChpc19lbXB0eSB0KTtcbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKG9yaWdpbmFsX2NoaWxkLmhlaWdodCA+PSBvcmlnaW5hbF9wYXJlbnQuaGVpZ2h0KTtcbiAgdC5oZWlnaHRfbG93ZXJfYm91bmQgPC0gb3JpZ2luYWxfcGFyZW50LmhlaWdodDtcbiAgZW5zdXJlX2hlaWdodF9yZXF1aXJlbWVudFxuICAgIHRcbiAgICB+b3JpZ2luYWxfY2hpbGRcbiAgICB+b3JpZ2luYWxfcGFyZW50XG4gICAgfmNoaWxkOm9yaWdpbmFsX2NoaWxkXG4gICAgfnBhcmVudDpvcmlnaW5hbF9wYXJlbnQ7XG4gIHdoaWxlIGxlbmd0aCB0ID4gMCBkb1xuICAgIGxldCAoVCBjaGlsZCkgPSByZW1vdmVfbWluX2V4biB0IGluXG4gICAgaWYgTm9kZS5pc19pbl9yZWNvbXB1dGVfaGVhcCBjaGlsZFxuICAgIHRoZW4gUmVjb21wdXRlX2hlYXAuaW5jcmVhc2VfaGVpZ2h0IHJlY29tcHV0ZV9oZWFwIGNoaWxkO1xuICAgIGlmIGNoaWxkLm51bV9wYXJlbnRzID4gMFxuICAgIHRoZW4gKFxuICAgICAgbGV0IChUIHBhcmVudCkgPSBVb3B0LnZhbHVlX2V4biBjaGlsZC5wYXJlbnQwIGluXG4gICAgICBlbnN1cmVfaGVpZ2h0X3JlcXVpcmVtZW50IHQgfm9yaWdpbmFsX2NoaWxkIH5vcmlnaW5hbF9wYXJlbnQgfmNoaWxkIH5wYXJlbnQ7XG4gICAgICBmb3IgcGFyZW50X2luZGV4ID0gMSB0byBjaGlsZC5udW1fcGFyZW50cyAtIDEgZG9cbiAgICAgICAgbGV0IChUIHBhcmVudCkgPVxuICAgICAgICAgIFVvcHQudmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCBjaGlsZC5wYXJlbnQxX2FuZF9iZXlvbmQgKHBhcmVudF9pbmRleCAtIDEpKVxuICAgICAgICBpblxuICAgICAgICBlbnN1cmVfaGVpZ2h0X3JlcXVpcmVtZW50IHQgfm9yaWdpbmFsX2NoaWxkIH5vcmlnaW5hbF9wYXJlbnQgfmNoaWxkIH5wYXJlbnRcbiAgICAgIGRvbmUpO1xuICAgIG1hdGNoIGNoaWxkLmtpbmQgd2l0aFxuICAgIHwgQmluZF9saHNfY2hhbmdlIHsgYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzOyBfIH0gLT5cbiAgICAgIGxldCByID0gcmVmIGFsbF9ub2Rlc19jcmVhdGVkX29uX3JocyBpblxuICAgICAgd2hpbGUgVW9wdC5pc19zb21lICFyIGRvXG4gICAgICAgIGxldCAoVCBub2RlX29uX3JocykgPSBVb3B0LnVuc2FmZV92YWx1ZSAhciBpblxuICAgICAgICByIDo9IG5vZGVfb25fcmhzLm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlO1xuICAgICAgICBpZiBOb2RlLmlzX25lY2Vzc2FyeSBub2RlX29uX3Joc1xuICAgICAgICB0aGVuXG4gICAgICAgICAgZW5zdXJlX2hlaWdodF9yZXF1aXJlbWVudFxuICAgICAgICAgICAgdFxuICAgICAgICAgICAgfm9yaWdpbmFsX2NoaWxkXG4gICAgICAgICAgICB+b3JpZ2luYWxfcGFyZW50XG4gICAgICAgICAgICB+Y2hpbGRcbiAgICAgICAgICAgIH5wYXJlbnQ6bm9kZV9vbl9yaHNcbiAgICAgIGRvbmVcbiAgICB8IF8gLT4gKClcbiAgZG9uZTtcbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKGlzX2VtcHR5IHQpO1xuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAob3JpZ2luYWxfY2hpbGQuaGVpZ2h0IDwgb3JpZ2luYWxfcGFyZW50LmhlaWdodClcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgQWN0aW9uID0gc3RydWN0XG4gIHR5cGUgdCA9IFR5cGVzLkFsYXJtX3ZhbHVlLkFjdGlvbi50ID1cbiAgICB8IEF0IG9mIEF0LnRcbiAgICB8IEF0X2ludGVydmFscyBvZiBBdF9pbnRlcnZhbHMudFxuICAgIHwgU25hcHNob3QgOiBfIFNuYXBzaG90LnQgLT4gdFxuICAgIHwgU3RlcF9mdW5jdGlvbiA6IF8gU3RlcF9mdW5jdGlvbl9ub2RlLnQgLT4gdFxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgPSBmdW5jdGlvblxuICAgIHwgQXQgYXQgLT4gQXQuaW52YXJpYW50IGF0XG4gICAgfCBBdF9pbnRlcnZhbHMgYXRfaW50ZXJ2YWxzIC0+IEF0X2ludGVydmFscy5pbnZhcmlhbnQgYXRfaW50ZXJ2YWxzXG4gICAgfCBTbmFwc2hvdCBzbmFwc2hvdCAtPiBTbmFwc2hvdC5pbnZhcmlhbnQgaWdub3JlIHNuYXBzaG90XG4gICAgfCBTdGVwX2Z1bmN0aW9uIHN0ZXBfZnVuY3Rpb25fbm9kZSAtPlxuICAgICAgU3RlcF9mdW5jdGlvbl9ub2RlLmludmFyaWFudCBpZ25vcmUgc3RlcF9mdW5jdGlvbl9ub2RlXG4gIDs7XG5lbmRcblxudHlwZSB0ID0gVHlwZXMuQWxhcm1fdmFsdWUudCA9XG4gIHsgYWN0aW9uIDogQWN0aW9uLnRcbiAgOyAoKiBbbmV4dF9maXJlZF0gc2luZ2x5IGxpbmtzIGFsbCBhbGFybSB2YWx1ZXMgdGhhdCBmaXJlIGR1cmluZyBhIHNpbmdsZSBjYWxsIHRvXG4gICAgICAgW2FkdmFuY2VfY2xvY2tdLiAqKVxuICAgIG11dGFibGUgbmV4dF9maXJlZCA6ICh0IFVvcHQudFtAc2V4cC5vcGFxdWVdKVxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlciB+YWN0aW9uOihjaGVjayBBY3Rpb24uaW52YXJpYW50KSB+bmV4dF9maXJlZDppZ25vcmUpXG47O1xuXG5sZXQgY3JlYXRlIGFjdGlvbiA9IHsgYWN0aW9uOyBuZXh0X2ZpcmVkID0gVW9wdC5ub25lIH1cbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBDb25maWdfaW50ZlxuXG5tb2R1bGUgRGVmYXVsdCAoKSA9IHN0cnVjdFxuICBsZXQgYmluZF9saHNfY2hhbmdlX3Nob3VsZF9pbnZhbGlkYXRlX3JocyA9IHRydWVcbmVuZFxuIiwib3BlbiBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4gVHlwZXMuSW50ZXJuYWxfb2JzZXJ2ZXJcblxubW9kdWxlIFBhY2tlZF8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUeXBlcy5JbnRlcm5hbF9vYnNlcnZlci5QYWNrZWRcblxuICBsZXQgc2V4cF9vZl90IChUIGludGVybmFsX29ic2VydmVyKSA9XG4gICAgaW50ZXJuYWxfb2JzZXJ2ZXIub2JzZXJ2aW5nIHw+IFslc2V4cF9vZjogXyBUeXBlcy5Ob2RlLnRdXG4gIDs7XG5cbiAgbGV0IHByZXZfaW5fYWxsIChUIHQpID0gdC5wcmV2X2luX2FsbFxuICBsZXQgbmV4dF9pbl9hbGwgKFQgdCkgPSB0Lm5leHRfaW5fYWxsXG4gIGxldCBzZXRfcHJldl9pbl9hbGwgKFQgdDEpIHQyID0gdDEucHJldl9pbl9hbGwgPC0gdDJcbiAgbGV0IHNldF9uZXh0X2luX2FsbCAoVCB0MSkgdDIgPSB0MS5uZXh0X2luX2FsbCA8LSB0MlxuZW5kXG5cbm1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuICB0eXBlIHQgPSBUeXBlcy5JbnRlcm5hbF9vYnNlcnZlci5TdGF0ZS50ID1cbiAgICB8IENyZWF0ZWRcbiAgICB8IEluX3VzZVxuICAgIHwgRGlzYWxsb3dlZFxuICAgIHwgVW5saW5rZWRcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbmVuZFxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5JbnRlcm5hbF9vYnNlcnZlci50ID1cbiAgeyAoKiBTdGF0ZSB0cmFuc2l0aW9uczpcblxuICAgICAgIHt2XG4gICAgICAgICBDcmVhdGVkIC0tPiBJbl91c2UgLS0+IERpc2FsbG93ZWQgLS0+IFVubGlua2VkXG4gICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXlxuICAgICAgICAgICBcXC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vXG4gICAgICAgdn0gKilcbiAgICBtdXRhYmxlIHN0YXRlIDogU3RhdGUudFxuICA7IG9ic2VydmluZyA6ICdhIE5vZGUudFxuICA7IG11dGFibGUgb25fdXBkYXRlX2hhbmRsZXJzIDogJ2EgT25fdXBkYXRlX2hhbmRsZXIudCBsaXN0XG4gIDsgKCogW3twcmV2LG5leHR9X2luX2FsbF0gZG91Ymx5IGxpbmsgYWxsIG9ic2VydmVycyBpbiBbc3RhdGUuYWxsX29ic2VydmVyc10uICopXG4gICAgbXV0YWJsZSBwcmV2X2luX2FsbCA6IFBhY2tlZF8udCBVb3B0LnRcbiAgOyBtdXRhYmxlIG5leHRfaW5fYWxsIDogUGFja2VkXy50IFVvcHQudFxuICA7ICgqIFt7cHJldixuZXh0fV9pbl9vYnNlcnZpbmddIGRvdWJseSBsaW5rIGFsbCBvYnNlcnZlcnMgb2YgW29ic2VydmluZ10uICopXG4gICAgbXV0YWJsZSBwcmV2X2luX29ic2VydmluZyA6ICgnYSB0W0BzZXhwLm9wYXF1ZV0pIFVvcHQudFxuICA7IG11dGFibGUgbmV4dF9pbl9vYnNlcnZpbmcgOiAoJ2EgdFtAc2V4cC5vcGFxdWVdKSBVb3B0LnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxudHlwZSAnYSBpbnRlcm5hbF9vYnNlcnZlciA9ICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGluY3Jfc3RhdGUgdCA9IHQub2JzZXJ2aW5nLnN0YXRlXG5cbmxldCB1c2VfaXNfYWxsb3dlZCB0ID1cbiAgbWF0Y2ggdC5zdGF0ZSB3aXRoXG4gIHwgQ3JlYXRlZCB8IEluX3VzZSAtPiB0cnVlXG4gIHwgRGlzYWxsb3dlZCB8IFVubGlua2VkIC0+IGZhbHNlXG47O1xuXG5sZXQgc2FtZSAodDEgOiBfIHQpICh0MiA6IF8gdCkgPSBwaHlzX3NhbWUgdDEgdDJcbmxldCBzYW1lX2FzX3BhY2tlZCAodDEgOiBfIHQpIChQYWNrZWRfLlQgdDIpID0gc2FtZSB0MSB0MlxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+c3RhdGU6aWdub3JlXG4gICAgICB+b2JzZXJ2aW5nOihjaGVjayAoTm9kZS5pbnZhcmlhbnQgaW52YXJpYW50X2EpKVxuICAgICAgfm9uX3VwZGF0ZV9oYW5kbGVyczpcbiAgICAgICAgKGNoZWNrIChmdW4gb25fdXBkYXRlX2hhbmRsZXJzIC0+XG4gICAgICAgICAgIG1hdGNoIHQuc3RhdGUgd2l0aFxuICAgICAgICAgICB8IENyZWF0ZWQgfCBJbl91c2UgfCBEaXNhbGxvd2VkIC0+ICgpXG4gICAgICAgICAgIHwgVW5saW5rZWQgLT4gYXNzZXJ0IChMaXN0LmlzX2VtcHR5IG9uX3VwZGF0ZV9oYW5kbGVycykpKVxuICAgICAgfnByZXZfaW5fYWxsOlxuICAgICAgICAoY2hlY2sgKGZ1biBwcmV2X2luX2FsbCAtPlxuICAgICAgICAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgICAgICAgICB8IEluX3VzZSB8IERpc2FsbG93ZWQgLT4gKClcbiAgICAgICAgICAgIHwgQ3JlYXRlZCB8IFVubGlua2VkIC0+IGFzc2VydCAoVW9wdC5pc19ub25lIHByZXZfaW5fYWxsKSk7XG4gICAgICAgICAgIGlmIFVvcHQuaXNfc29tZSBwcmV2X2luX2FsbFxuICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgIHNhbWVfYXNfcGFja2VkXG4gICAgICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgICAgKFVvcHQudmFsdWVfZXhuIChQYWNrZWRfLm5leHRfaW5fYWxsIChVb3B0LnZhbHVlX2V4biBwcmV2X2luX2FsbCkpKSkpKVxuICAgICAgfm5leHRfaW5fYWxsOlxuICAgICAgICAoY2hlY2sgKGZ1biBuZXh0X2luX2FsbCAtPlxuICAgICAgICAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgICAgICAgICB8IEluX3VzZSB8IERpc2FsbG93ZWQgLT4gKClcbiAgICAgICAgICAgIHwgQ3JlYXRlZCB8IFVubGlua2VkIC0+IGFzc2VydCAoVW9wdC5pc19ub25lIG5leHRfaW5fYWxsKSk7XG4gICAgICAgICAgIGlmIFVvcHQuaXNfc29tZSBuZXh0X2luX2FsbFxuICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgIHNhbWVfYXNfcGFja2VkXG4gICAgICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgICAgKFVvcHQudmFsdWVfZXhuIChQYWNrZWRfLnByZXZfaW5fYWxsIChVb3B0LnZhbHVlX2V4biBuZXh0X2luX2FsbCkpKSkpKVxuICAgICAgfnByZXZfaW5fb2JzZXJ2aW5nOlxuICAgICAgICAoY2hlY2sgKGZ1biBwcmV2X2luX29ic2VydmluZyAtPlxuICAgICAgICAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgICAgICAgICB8IEluX3VzZSB8IERpc2FsbG93ZWQgLT4gKClcbiAgICAgICAgICAgIHwgQ3JlYXRlZCB8IFVubGlua2VkIC0+IGFzc2VydCAoVW9wdC5pc19ub25lIHByZXZfaW5fb2JzZXJ2aW5nKSk7XG4gICAgICAgICAgIGlmIFVvcHQuaXNfc29tZSBwcmV2X2luX29ic2VydmluZ1xuICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgIHBoeXNfZXF1YWxcbiAgICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICAgICAoVW9wdC52YWx1ZV9leG4gKG5leHRfaW5fb2JzZXJ2aW5nIChVb3B0LnZhbHVlX2V4biBwcmV2X2luX29ic2VydmluZykpKSkpKVxuICAgICAgfm5leHRfaW5fb2JzZXJ2aW5nOlxuICAgICAgICAoY2hlY2sgKGZ1biBuZXh0X2luX29ic2VydmluZyAtPlxuICAgICAgICAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgICAgICAgICB8IEluX3VzZSB8IERpc2FsbG93ZWQgLT4gKClcbiAgICAgICAgICAgIHwgQ3JlYXRlZCB8IFVubGlua2VkIC0+IGFzc2VydCAoVW9wdC5pc19ub25lIG5leHRfaW5fb2JzZXJ2aW5nKSk7XG4gICAgICAgICAgIGlmIFVvcHQuaXNfc29tZSBuZXh0X2luX29ic2VydmluZ1xuICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgIHBoeXNfZXF1YWxcbiAgICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICAgICAoVW9wdC52YWx1ZV9leG4gKHByZXZfaW5fb2JzZXJ2aW5nIChVb3B0LnZhbHVlX2V4biBuZXh0X2luX29ic2VydmluZykpKSkpKSlcbjs7XG5cbmxldCB2YWx1ZV9leG4gdCA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IENyZWF0ZWQgLT5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiT2JzZXJ2ZXIudmFsdWVfZXhuIGNhbGxlZCB3aXRob3V0IHN0YWJpbGl6aW5nXCJcbiAgICAgIHRcbiAgICAgIFslc2V4cF9vZjogXyB0XVxuICB8IERpc2FsbG93ZWQgfCBVbmxpbmtlZCAtPlxuICAgIGZhaWx3aXRoc1xuICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgXCJPYnNlcnZlci52YWx1ZV9leG4gY2FsbGVkIGFmdGVyIGRpc2FsbG93X2Z1dHVyZV91c2VcIlxuICAgICAgdFxuICAgICAgWyVzZXhwX29mOiBfIHRdXG4gIHwgSW5fdXNlIC0+XG4gICAgbGV0IHVvcHQgPSB0Lm9ic2VydmluZy52YWx1ZV9vcHQgaW5cbiAgICBpZiBVb3B0LmlzX25vbmUgdW9wdFxuICAgIHRoZW5cbiAgICAgIGZhaWx3aXRocyB+aGVyZTpbJWhlcmVdIFwiYXR0ZW1wdCB0byBnZXQgdmFsdWUgb2YgYW4gaW52YWxpZCBub2RlXCIgdCBbJXNleHBfb2Y6IF8gdF07XG4gICAgVW9wdC51bnNhZmVfdmFsdWUgdW9wdFxuOztcblxubGV0IG9uX3VwZGF0ZV9leG4gdCBvbl91cGRhdGVfaGFuZGxlciA9XG4gIG1hdGNoIHQuc3RhdGUgd2l0aFxuICB8IERpc2FsbG93ZWQgfCBVbmxpbmtlZCAtPlxuICAgIGZhaWx3aXRocyB+aGVyZTpbJWhlcmVdIFwib25fdXBkYXRlIGRpc2FsbG93ZWRcIiB0IFslc2V4cF9vZjogXyB0XVxuICB8IENyZWF0ZWQgfCBJbl91c2UgLT5cbiAgICB0Lm9uX3VwZGF0ZV9oYW5kbGVycyA8LSBvbl91cGRhdGVfaGFuZGxlciA6OiB0Lm9uX3VwZGF0ZV9oYW5kbGVycztcbiAgICAobWF0Y2ggdC5zdGF0ZSB3aXRoXG4gICAgIHwgRGlzYWxsb3dlZCB8IFVubGlua2VkIC0+IGFzc2VydCBmYWxzZVxuICAgICB8IENyZWF0ZWQgLT5cbiAgICAgICAoKiBXZSdsbCBidW1wIFtvYnNlcnZpbmcubnVtX29uX3VwZGF0ZV9oYW5kbGVyc10gd2hlbiBbdF0gaXMgYWN0dWFsbHkgYWRkZWQgdG9cbiAgICAgICAgICBbb2JzZXJ2aW5nLm9ic2VydmVyc10gYXQgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IHN0YWJpbGl6YXRpb24uICopXG4gICAgICAgKClcbiAgICAgfCBJbl91c2UgLT5cbiAgICAgICBsZXQgb2JzZXJ2aW5nID0gdC5vYnNlcnZpbmcgaW5cbiAgICAgICBvYnNlcnZpbmcubnVtX29uX3VwZGF0ZV9oYW5kbGVycyA8LSBvYnNlcnZpbmcubnVtX29uX3VwZGF0ZV9oYW5kbGVycyArIDEpXG47O1xuXG5sZXQgdW5saW5rX2Zyb21fb2JzZXJ2aW5nIHQgPVxuICBsZXQgcHJldiA9IHQucHJldl9pbl9vYnNlcnZpbmcgaW5cbiAgbGV0IG5leHQgPSB0Lm5leHRfaW5fb2JzZXJ2aW5nIGluXG4gIHQucHJldl9pbl9vYnNlcnZpbmcgPC0gVW9wdC5ub25lO1xuICB0Lm5leHRfaW5fb2JzZXJ2aW5nIDwtIFVvcHQubm9uZTtcbiAgaWYgVW9wdC5pc19zb21lIG5leHQgdGhlbiAoVW9wdC51bnNhZmVfdmFsdWUgbmV4dCkucHJldl9pbl9vYnNlcnZpbmcgPC0gcHJldjtcbiAgaWYgVW9wdC5pc19zb21lIHByZXYgdGhlbiAoVW9wdC51bnNhZmVfdmFsdWUgcHJldikubmV4dF9pbl9vYnNlcnZpbmcgPC0gbmV4dDtcbiAgbGV0IG9ic2VydmluZyA9IHQub2JzZXJ2aW5nIGluXG4gIGlmIHBoeXNfZXF1YWwgdCAoVW9wdC52YWx1ZV9leG4gb2JzZXJ2aW5nLm9ic2VydmVycykgdGhlbiBvYnNlcnZpbmcub2JzZXJ2ZXJzIDwtIG5leHQ7XG4gIG9ic2VydmluZy5udW1fb25fdXBkYXRlX2hhbmRsZXJzXG4gICAgPC0gb2JzZXJ2aW5nLm51bV9vbl91cGRhdGVfaGFuZGxlcnMgLSBMaXN0Lmxlbmd0aCB0Lm9uX3VwZGF0ZV9oYW5kbGVycztcbiAgdC5vbl91cGRhdGVfaGFuZGxlcnMgPC0gW11cbjs7XG5cbmxldCB1bmxpbmtfZnJvbV9hbGwgdCA9XG4gIGxldCBwcmV2ID0gdC5wcmV2X2luX2FsbCBpblxuICBsZXQgbmV4dCA9IHQubmV4dF9pbl9hbGwgaW5cbiAgdC5wcmV2X2luX2FsbCA8LSBVb3B0Lm5vbmU7XG4gIHQubmV4dF9pbl9hbGwgPC0gVW9wdC5ub25lO1xuICBpZiBVb3B0LmlzX3NvbWUgbmV4dCB0aGVuIFBhY2tlZF8uc2V0X3ByZXZfaW5fYWxsIChVb3B0LnVuc2FmZV92YWx1ZSBuZXh0KSBwcmV2O1xuICBpZiBVb3B0LmlzX3NvbWUgcHJldiB0aGVuIFBhY2tlZF8uc2V0X25leHRfaW5fYWxsIChVb3B0LnVuc2FmZV92YWx1ZSBwcmV2KSBuZXh0XG47O1xuXG5sZXQgdW5saW5rIHQgPVxuICB1bmxpbmtfZnJvbV9vYnNlcnZpbmcgdDtcbiAgdW5saW5rX2Zyb21fYWxsIHRcbjs7XG5cbm1vZHVsZSBQYWNrZWQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQYWNrZWRfXG5cbiAgbGV0IHNleHBfb2ZfdCAoVCBpbnRlcm5hbF9vYnNlcnZlcikgPVxuICAgIGludGVybmFsX29ic2VydmVyIHw+IFslc2V4cF9vZjogXyBpbnRlcm5hbF9vYnNlcnZlcl1cbiAgOztcblxuICBsZXQgaW52YXJpYW50IChUIHQpID0gaW52YXJpYW50IGlnbm9yZSB0XG5lbmRcbiIsIm9wZW4gQ29yZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgdCA9ICdhIEludGVybmFsX29ic2VydmVyLnQgcmVmIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9IEludGVybmFsX29ic2VydmVyLmludmFyaWFudCBpbnZhcmlhbnRfYSAhdFxubGV0IG9ic2VydmluZyB0ID0gSW50ZXJuYWxfb2JzZXJ2ZXIub2JzZXJ2aW5nICF0XG5sZXQgdXNlX2lzX2FsbG93ZWQgdCA9IEludGVybmFsX29ic2VydmVyLnVzZV9pc19hbGxvd2VkICF0XG5sZXQgdmFsdWVfZXhuIHQgPSBJbnRlcm5hbF9vYnNlcnZlci52YWx1ZV9leG4gIXRcbmxldCBpbmNyX3N0YXRlIHQgPSBJbnRlcm5hbF9vYnNlcnZlci5pbmNyX3N0YXRlICF0XG5cbmxldCBvbl91cGRhdGVfZXhuIHQgb25fdXBkYXRlX2hhbmRsZXIgPVxuICBJbnRlcm5hbF9vYnNlcnZlci5vbl91cGRhdGVfZXhuICF0IG9uX3VwZGF0ZV9oYW5kbGVyXG47O1xuIiwiKCogW1N0YXRlXSBkZWZpbmVzIHRoZSBnbG9iYWwgc3RhdGUgb2Ygd2hpY2ggdGhlcmUgaXMgb25lIGluc3RhbmNlIGZvciBlYWNoIGNhbGwgdG9cbiAgIFtJbmNyZW1lbnRhbC5NYWtlXS5cblxuICAgVGhpcyBtb2R1bGUgZG9lcyBub3QgaGF2ZSBhbiBtbGkgYmVjYXVzZSBpdCB3b3VsZCBlc3NlbnRpYWxseSBkdXBsaWNhdGVcbiAgIFtJbmNyZW1lbnRhbC5TXSwgZXhjZXB0IGFkZGluZyBhbiBleHRyYSBbU3RhdGUudF0gYXJndW1lbnQgdG8gZnVuY3Rpb25zLiAqKVxuXG5vcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5vcGVuIFR5cGVzLktpbmRcblxudHlwZSBzdGF0dXMgPSBUeXBlcy5TdGF0dXMudCA9XG4gIHwgU3RhYmlsaXppbmdcbiAgfCBSdW5uaW5nX29uX3VwZGF0ZV9oYW5kbGVyc1xuICB8IE5vdF9zdGFiaWxpemluZ1xuICB8IFN0YWJpbGl6ZV9wcmV2aW91c2x5X3JhaXNlZCBvZiBSYWlzZWRfZXhuLnRcbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbm1vZHVsZSBOb2RlX3VwZGF0ZSA9IE9uX3VwZGF0ZV9oYW5kbGVyLk5vZGVfdXBkYXRlXG5cbm1vZHVsZSBSdW5fb25fdXBkYXRlX2hhbmRsZXJzID0gc3RydWN0XG4gIHR5cGUgdCA9IFR5cGVzLlJ1bl9vbl91cGRhdGVfaGFuZGxlcnMudCA9IFQgOiAnYSBOb2RlLnQgKiAnYSBOb2RlX3VwZGF0ZS50IC0+IHRcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IChUIChub2RlLCBfbm9kZV91cGRhdGUpIGFzIHQpID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT4gTm9kZS5pbnZhcmlhbnQgaWdub3JlIG5vZGUpXG4gIDs7XG5lbmRcblxubW9kdWxlIE9ubHlfaW5fZGVidWcgPSBzdHJ1Y3RcbiAgKCogRXh0cmEgc3RhdGUga2VwdCBvbmx5IHdoZW4gW2RlYnVnXSBmb3IgdGhlIHB1cnBvc2Ugb2Ygd3JpdGluZyBhc3NlcnRpb25zLiAqKVxuICB0eXBlIHQgPSBUeXBlcy5Pbmx5X2luX2RlYnVnLnQgPVxuICAgIHsgbXV0YWJsZSBjdXJyZW50bHlfcnVubmluZ19ub2RlIDogTm9kZS5QYWNrZWQudCBvcHRpb25cbiAgICA7IG11dGFibGUgZXhwZXJ0X25vZGVzX2NyZWF0ZWRfYnlfY3VycmVudF9ub2RlIDogTm9kZS5QYWNrZWQudCBsaXN0XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+Y3VycmVudGx5X3J1bm5pbmdfbm9kZTppZ25vcmVcbiAgICAgICAgfmV4cGVydF9ub2Rlc19jcmVhdGVkX2J5X2N1cnJlbnRfbm9kZTppZ25vcmUpXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSAoKSA9XG4gICAgeyBjdXJyZW50bHlfcnVubmluZ19ub2RlID0gTm9uZTsgZXhwZXJ0X25vZGVzX2NyZWF0ZWRfYnlfY3VycmVudF9ub2RlID0gW10gfVxuICA7O1xuZW5kXG5cbm1vZHVsZSBQYWNrZWRfd2Vha19oYXNodGJsID0gc3RydWN0XG4gIHR5cGUgdCA9IFR5cGVzLlBhY2tlZF93ZWFrX2hhc2h0YmwudCA9IFQgOiAoXywgXykgV2Vha19oYXNodGJsLnQgLT4gdFxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuZW5kXG5cbnR5cGUgdCA9IFR5cGVzLlN0YXRlLnQgPVxuICB7IG11dGFibGUgc3RhdHVzIDogc3RhdHVzXG4gIDsgYmluZF9saHNfY2hhbmdlX3Nob3VsZF9pbnZhbGlkYXRlX3JocyA6IGJvb2xcbiAgOyAoKiBbc3RhYmlsaXphdGlvbl9udW1dIHN0YXJ0cyBhdCB6ZXJvLCBhbmQgaXMgaW5jcmVtZW50ZWQgYXQgdGhlIGVuZCBvZiBlYWNoXG4gICAgICAgc3RhYmlsaXphdGlvbi4gKilcbiAgICBtdXRhYmxlIHN0YWJpbGl6YXRpb25fbnVtIDogU3RhYmlsaXphdGlvbl9udW0udFxuICA7IG11dGFibGUgY3VycmVudF9zY29wZSA6IFNjb3BlLnRcbiAgOyByZWNvbXB1dGVfaGVhcCA6IFJlY29tcHV0ZV9oZWFwLnRcbiAgOyBhZGp1c3RfaGVpZ2h0c19oZWFwIDogQWRqdXN0X2hlaWdodHNfaGVhcC50XG4gIDsgKCogW3Byb3BhZ2F0ZV9pbnZhbGlkaXR5XSBob2xkcyBub2RlcyB0aGF0IGhhdmUgaW52YWxpZCBjaGlsZHJlbiB0aGF0IHNob3VsZCBiZVxuICAgICAgIGNvbnNpZGVyZWQgZm9yIGludmFsaWRhdGlvbi4gIEl0IGlzIG9ubHkgdXNlZCBkdXJpbmcgZ3JhcGggcmVzdHJ1Y3R1cmluZzpcbiAgICAgICBbaW52YWxpZGF0ZV9ub2RlXSBhbmQgW2FkZF9wYXJlbnRdLiAgT25jZSBhbiBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBzdGFjaywgd2UgdGhlblxuICAgICAgIGl0ZXJhdGUgdW50aWwgaW52YWxpZGl0eSBoYXMgcHJvcGFnYXRlZCB0byBhbGwgYW5jZXN0b3JzIGFzIG5lY2Vzc2FyeSwgYWNjb3JkaW5nIHRvXG4gICAgICAgW05vZGUuc2hvdWxkX2JlX2ludmFsaWRhdGVkXS4gKilcbiAgICBwcm9wYWdhdGVfaW52YWxpZGl0eSA6IE5vZGUuUGFja2VkLnQgU3RhY2sudFxuICA7ICgqIFtudW1fYWN0aXZlX29ic2VydmVyc10gaXMgdGhlIG51bWJlciBvZiBvYnNlcnZlcnMgd2hvc2Ugc3RhdGUgaXMgW0NyZWF0ZWRdIG9yXG4gICAgICAgW0luX3VzZV0uICopXG4gICAgbXV0YWJsZSBudW1fYWN0aXZlX29ic2VydmVycyA6IGludFxuICA7ICgqIFthbGxfb2JzZXJ2ZXJzXSBpcyB0aGUgZG91Ymx5LWxpbmtlZCBsaXN0IG9mIGFsbCBvYnNlcnZlcnMgaW4gZWZmZWN0LCBvciB0aGF0IGhhdmVcbiAgICAgICBiZWVuIGRpc2FsbG93ZWQgc2luY2UgdGhlIG1vc3QgcmVjZW50IHN0YXJ0IG9mIGEgc3RhYmlsaXphdGlvbiAtLSB0aGVzZSBoYXZlXG4gICAgICAgW3N0YXRlXSBhcyBbSW5fdXNlXSBvciBbRGlzYWxsb3dlZF0uICopXG4gICAgbXV0YWJsZSBhbGxfb2JzZXJ2ZXJzIDogSW50ZXJuYWxfb2JzZXJ2ZXIuUGFja2VkLnQgVW9wdC50XG4gIDsgKCogV2UgZW5xdWV1ZSBmaW5hbGl6ZWQgb2JzZXJ2ZXJzIGluIGEgdGhyZWFkLXNhZmUgcXVldWUsIGZvciBoYW5kbGluZyBkdXJpbmdcbiAgICAgICBzdGFiaWxpemF0aW9uLiAgV2UgdXNlIGEgdGhyZWFkLXNhZmUgcXVldWUgYmVjYXVzZSBPQ2FtbCBmaW5hbGl6ZXJzIGNhbiBydW4gaW4gYW55XG4gICAgICAgdGhyZWFkLiAqKVxuICAgIGZpbmFsaXplZF9vYnNlcnZlcnMgOiBJbnRlcm5hbF9vYnNlcnZlci5QYWNrZWQudCBUaHJlYWRfc2FmZV9xdWV1ZS50XG4gIDsgKCogW25ld19vYnNlcnZlcnNdIGhvbGRzIG9ic2VydmVycyBjcmVhdGVkIHNpbmNlIHRoZSBtb3N0IHJlY2VudCBzdGFydCBvZiBhXG4gICAgICAgc3RhYmlsaXphdGlvbiAtLSB0aGVzZSBoYXZlIFtzdGF0ZV0gYXMgW0NyZWF0ZWRdIG9yIFtVbmxpbmtlZF0uICBBdCB0aGUgc3RhcnQgb2ZcbiAgICAgICBzdGFiaWxpemF0aW9uLCB3ZSBsaW5rIGludG8gW2FsbF9vYnNlcnZlcnNdIGFsbCBvYnNlcnZlcnMgaW4gW25ld19vYnNlcnZlcnNdIHdob3NlXG4gICAgICAgc3RhdGUgaXMgW0NyZWF0ZWRdIGFuZCBhZGQgdGhlbSB0byB0aGUgW29ic2VydmVyc10gb2YgdGhlIG5vZGUgdGhleSBhcmUgb2JzZXJ2aW5nLlxuICAgICAgIFdlIHN0cnVjdHVyZSB0aGluZ3MgdGhpcyB3YXkgdG8gYWxsb3cgb2JzZXJ2ZXJzIHRvIGJlIGNyZWF0ZWQgZHVyaW5nIHN0YWJpbGl6YXRpb25cbiAgICAgICB3aGlsZSBydW5uaW5nIHVzZXIgY29kZSAoW21hcF0sIFtiaW5kXSwgZXRjKSwgYnV0IHRvIG5vdCBoYXZlIHRvIGRlYWwgd2l0aCBub2Rlc1xuICAgICAgIGJlY29taW5nIG5lY2Vzc2FyeSBhbmQgdGhlIHRoZSBncmFwaCBjaGFuZ2luZyBkdXJpbmcgc3VjaCBjb2RlLiAqKVxuICAgIG5ld19vYnNlcnZlcnMgOiBJbnRlcm5hbF9vYnNlcnZlci5QYWNrZWQudCBTdGFjay50XG4gIDsgKCogW2Rpc2FsbG93ZWRfb2JzZXJ2ZXJzXSBob2xkcyBhbGwgb2JzZXJ2ZXJzIHRoYXQgaGF2ZSBiZWVuIGRpc2FsbG93ZWQgc2luY2UgdGhlIG1vc3RcbiAgICAgICByZWNlbnQgc3RhcnQgb2YgYSBzdGFiaWxpemF0aW9uIC0tIHRoZXNlIGhhdmUgW3N0YXRlID0gRGlzYWxsb3dlZF0uICBBdCB0aGUgc3RhcnRcbiAgICAgICBvZiBzdGFiaWxpemF0aW9uLCB0aGVzZSBhcmUgdW5saW5rZWQgZnJvbSBbYWxsX29ic2VydmVyc10gYW5kIHRoZWlyIHN0YXRlIGlzXG4gICAgICAgY2hhbmdlZCB0byBbVW5saW5rZWRdLiAgV2Ugc3RydWN0dXJlIHRoaW5ncyB0aGlzIHdheSB0byBhbGxvdyB1c2VyIGNvZGUgcnVubmluZ1xuICAgICAgIGR1cmluZyBzdGFiaWxpemF0aW9uIHRvIGNhbGwgW2Rpc2FsbG93X2Z1dHVyZV91c2VdLCBidXQgdG8gbm90IGhhdmUgdG8gZGVhbCB3aXRoXG4gICAgICAgbm9kZXMgYmVjb21pbmcgdW5uZWNlc3NhcnkgYW5kIHRoZSBncmFwaCBjaGFuZ2luZyBkdXJpbmcgc3VjaCBjb2RlLiAqKVxuICAgIGRpc2FsbG93ZWRfb2JzZXJ2ZXJzIDogSW50ZXJuYWxfb2JzZXJ2ZXIuUGFja2VkLnQgU3RhY2sudFxuICA7ICgqIFdlIGRlbGF5IGFsbCBbVmFyLnNldF0gY2FsbHMgdGhhdCBoYXBwZW4gZHVyaW5nIHN0YWJpbGl6YXRpb24gc28gdGhhdCB0aGV5IHRha2VcbiAgICAgICBlZmZlY3QgYWZ0ZXIgc3RhYmlsaXphdGlvbi4gIEFsbCB2YXJpYWJsZXMgc2V0IGR1cmluZyBzdGFiaWxpemF0aW9uIGFyZSBwdXNoZWQgb25cbiAgICAgICBbc2V0X2R1cmluZ19zdGFiaWxpemF0aW9uXSByYXRoZXIgdGhhbiBzZXR0aW5nIHRoZW0uICBUaGVuLCBhZnRlciB0aGUgZ3JhcGggaGFzXG4gICAgICAgc3RhYmlsaXplZCwgd2UgZG8gYWxsIHRoZSBzZXRzLCBzbyB0aGF0IHRoZXkgdGFrZSBlZmZlY3QgYXQgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0XG4gICAgICAgc3RhYmlsaXphdGlvbi4gKilcbiAgICBzZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24gOiBWYXIuUGFja2VkLnQgU3RhY2sudFxuICA7ICgqIFtoYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbl0gaGFzIGFsbCBub2RlcyB3aXRoIGhhbmRsZXJzIHRvIGNvbnNpZGVyIHJ1bm5pbmcgYXQgdGhlXG4gICAgICAgZW5kIG9mIHRoZSBuZXh0IHN0YWJpbGl6YXRpb24uICBBdCB0aGUgZW5kIG9mIHN0YWJpbGl6YXRpb24sIHdlIGNvbnNpZGVyIGVhY2ggbm9kZVxuICAgICAgIGluIFtoYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbl0sIGFuZCBpZiB3ZSBkZWNpZGUgdG8gcnVuIGl0cyBvbi11cGRhdGUgaGFuZGxlcnMsXG4gICAgICAgcHVzaCBpdCBvbiBbcnVuX29uX3VwZGF0ZV9oYW5kbGVyc10uICBUaGVuLCBvbmNlIHdlJ3ZlIGNvbnNpZGVyZWQgYWxsIG5vZGVzIGluXG4gICAgICAgW2hhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uXSwgd2UgaXRlcmF0ZSB0aHJvdWdoIFtydW5fb25fdXBkYXRlX2hhbmRsZXJzXSBhbmRcbiAgICAgICBhY3R1YWxseSBydW4gdGhlIGhhbmRsZXJzLlxuXG4gICAgICAgVGhlc2UgdHdvIHBhc3NlcyBhcmUgZXNzZW50aWFsIGZvciBjb3JyZWN0bmVzcy4gIER1cmluZyB0aGUgZmlyc3QgcGFzcywgd2UgaGF2ZW4ndFxuICAgICAgIHJ1biBhbnkgdXNlciBoYW5kbGVycywgc28gd2Uga25vdyB0aGF0IHRoZSBzdGF0ZSBpcyBleGFjdGx5IGFzIGl0IHdhcyB3aGVuXG4gICAgICAgc3RhYmlsaXphdGlvbiBmaW5pc2hlZC4gIEluIHBhcnRpY3VsYXIsIHdlIGtub3cgdGhhdCBpZiBhIG5vZGUgaXMgbmVjZXNzYXJ5LCB0aGVuXG4gICAgICAgaXQgaGFzIGEgc3RhYmxlIHZhbHVlOyBvbmNlIHVzZXIgaGFuZGxlcnMgcnVuLCB3ZSBkb24ndCBrbm93IHRoaXMuICBEdXJpbmcgdGhlXG4gICAgICAgc2Vjb25kIHBhc3MsIHVzZXIgaGFuZGxlcnMgY2FuIG1ha2UgY2FsbHMgdG8gYW55IGluY3JlbWVudGFsIGZ1bmN0aW9uIGV4Y2VwdCBmb3JcbiAgICAgICBbc3RhYmlsaXplXS4gIEluIHBhcnRpY3VsYXIsIHNvbWUgZnVuY3Rpb25zIHB1c2ggbm9kZXMgb25cbiAgICAgICBbaGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb25dLiAgQnV0IG5vIGZ1bmN0aW9ucyAoZXhjZXB0IGZvciBbc3RhYmlsaXplXSkgbW9kaWZ5XG4gICAgICAgW3J1bl9vbl91cGRhdGVfaGFuZGxlcnNdLiAqKVxuICAgIGhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uIDogTm9kZS5QYWNrZWQudCBTdGFjay50XG4gIDsgcnVuX29uX3VwZGF0ZV9oYW5kbGVycyA6IFJ1bl9vbl91cGRhdGVfaGFuZGxlcnMudCBTdGFjay50XG4gIDsgbXV0YWJsZSBvbmx5X2luX2RlYnVnIDogT25seV9pbl9kZWJ1Zy50XG4gIDsgd2Vha19oYXNodGJscyA6IFBhY2tlZF93ZWFrX2hhc2h0YmwudCBUaHJlYWRfc2FmZV9xdWV1ZS50XG4gIDsgbXV0YWJsZSBrZWVwX25vZGVfY3JlYXRpb25fYmFja3RyYWNlIDogYm9vbFxuICA7ICgqIFN0YXRzLiAgVGhlc2UgYXJlIGFsbCBpbmNyZW1lbnRlZCBhdCB0aGUgYXBwcm9wcmlhdGUgcGxhY2UsIGFuZCBuZXZlciBkZWNyZW1lbnRlZC4gKilcbiAgICBtdXRhYmxlIG51bV9ub2Rlc19iZWNhbWVfbmVjZXNzYXJ5IDogaW50XG4gIDsgbXV0YWJsZSBudW1fbm9kZXNfYmVjYW1lX3VubmVjZXNzYXJ5IDogaW50XG4gIDsgbXV0YWJsZSBudW1fbm9kZXNfY2hhbmdlZCA6IGludFxuICA7IG11dGFibGUgbnVtX25vZGVzX2NyZWF0ZWQgOiBpbnRcbiAgOyBtdXRhYmxlIG51bV9ub2Rlc19pbnZhbGlkYXRlZCA6IGludFxuICA7IG11dGFibGUgbnVtX25vZGVzX3JlY29tcHV0ZWQgOiBpbnRcbiAgOyBtdXRhYmxlIG51bV9ub2Rlc19yZWNvbXB1dGVkX2RpcmVjdGx5X2JlY2F1c2Vfb25lX2NoaWxkIDogaW50XG4gIDsgbXV0YWJsZSBudW1fbm9kZXNfcmVjb21wdXRlZF9kaXJlY3RseV9iZWNhdXNlX21pbl9oZWlnaHQgOiBpbnRcbiAgOyBtdXRhYmxlIG51bV92YXJfc2V0cyA6IGludFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG5tb2R1bGUgQ2xvY2sgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVHlwZXMuQ2xvY2sudCA9XG4gICAgeyAoKiBXZSB1c2UgW3RpbWluZ193aGVlbF0gZm9yIHRpbWUtYmFzZWQgaW5jcmVtZW50YWxzLiAgW25vd10gaXMgYSB2YXJpYWJsZSBob2xkaW5nXG4gICAgICAgICB0aGUgY3VycmVudCB0aW1lLiAgW2hhbmRsZV9maXJlZF0gaXMgdGhlIGNsb3N1cmUgcGFzc2VkIHRvXG4gICAgICAgICBbVGltaW5nX3doZWVsLmFkdmFuY2VfY2xvY2tdLiAgSXQgbGlua3MgYWxsIHRoZSBmaXJlZCBhbGFybSB2YWx1ZXMgaW50b1xuICAgICAgICAgW2ZpcmVkX2FsYXJtX3ZhbHVlc10uICBBZnRlciBbVGltaW5nX3doZWVsLmFkdmFuY2VfY2xvY2tdIHJldHVybnMsIGl0IHRoZW5cbiAgICAgICAgIHdhbGtzIHRocm91Z2ggdGhlIGxpbmtlZCBsaXN0IGFuZCBhY3R1YWxseSBmaXJlcyB0aGVtLiAgVGhpcyB0d28tcGFzcyBhcHByb2FjaCBpc1xuICAgICAgICAgbmVjZXNzYXJ5IGJlY2F1c2Ugb25lIGlzIG5vdCBhbGxvd2VkIHRvIGNhbGwgW1RpbWluZ193aGVlbF0gZnVuY3Rpb25zIGZyb20gdGhlXG4gICAgICAgICBbaGFuZGxlX2ZpcmVkXSB0aGF0IG9uZSBwYXNzZXMgdG8gW1RpbWluZ193aGVlbC5hZHZhbmNlX2Nsb2NrXS4gKilcbiAgICAgIHRpbWluZ193aGVlbCA6IEFsYXJtX3ZhbHVlLnQgVGltaW5nX3doZWVsLnRcbiAgICA7IG5vdyA6IFRpbWVfbnMudCBWYXIudFxuICAgIDsgaGFuZGxlX2ZpcmVkIDogQWxhcm0udCAtPiB1bml0XG4gICAgOyBtdXRhYmxlIGZpcmVkX2FsYXJtX3ZhbHVlcyA6IEFsYXJtX3ZhbHVlLnQgVW9wdC50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5ub3c6XG4gICAgICAgICAgKGNoZWNrIChmdW4gKG5vdyA6IF8gVmFyLnQpIC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLmVxdWFsIG5vdy52YWx1ZSAoVGltaW5nX3doZWVsLm5vdyB0LnRpbWluZ193aGVlbCkpKSlcbiAgICAgICAgfmhhbmRsZV9maXJlZDppZ25vcmVcbiAgICAgICAgfmZpcmVkX2FsYXJtX3ZhbHVlczpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBmaXJlZF9hbGFybV92YWx1ZXMgLT4gYXNzZXJ0IChVb3B0LmlzX25vbmUgZmlyZWRfYWxhcm1fdmFsdWVzKSkpXG4gICAgICAgIH50aW1pbmdfd2hlZWw6KGNoZWNrIChUaW1pbmdfd2hlZWwuaW52YXJpYW50IEFsYXJtX3ZhbHVlLmludmFyaWFudCkpKVxuICA7O1xuXG4gIGxldCBpbmNyX3N0YXRlIHQgPSBWYXIuaW5jcl9zdGF0ZSB0Lm5vd1xuZW5kXG5cbmxldCBub3cgKGNsb2NrIDogQ2xvY2sudCkgPSBjbG9jay5ub3cudmFsdWVcbmxldCB0aW1pbmdfd2hlZWxfbGVuZ3RoIChjbG9jayA6IENsb2NrLnQpID0gVGltaW5nX3doZWVsLmxlbmd0aCBjbG9jay50aW1pbmdfd2hlZWxcbmxldCBudW1fc3RhYmlsaXplcyB0ID0gU3RhYmlsaXphdGlvbl9udW0udG9faW50IHQuc3RhYmlsaXphdGlvbl9udW1cbmxldCBtYXhfaGVpZ2h0X2FsbG93ZWQgdCA9IEFkanVzdF9oZWlnaHRzX2hlYXAubWF4X2hlaWdodF9hbGxvd2VkIHQuYWRqdXN0X2hlaWdodHNfaGVhcFxubGV0IG1heF9oZWlnaHRfc2VlbiB0ID0gQWRqdXN0X2hlaWdodHNfaGVhcC5tYXhfaGVpZ2h0X3NlZW4gdC5hZGp1c3RfaGVpZ2h0c19oZWFwXG5cbmxldCBpdGVyX29ic2VydmVycyB0IH5mID1cbiAgbGV0IHIgPSByZWYgdC5hbGxfb2JzZXJ2ZXJzIGluXG4gIHdoaWxlIFVvcHQuaXNfc29tZSAhciBkb1xuICAgIGxldCBvYnNlcnZlciA9IFVvcHQudW5zYWZlX3ZhbHVlICFyIGluXG4gICAgciA6PSBJbnRlcm5hbF9vYnNlcnZlci5QYWNrZWQubmV4dF9pbl9hbGwgb2JzZXJ2ZXI7XG4gICAgZiBvYnNlcnZlclxuICBkb25lXG47O1xuXG5sZXQgZGlyZWN0bHlfb2JzZXJ2ZWQgdCA9XG4gIGxldCByIDogTm9kZS5QYWNrZWQudCBsaXN0IHJlZiA9IHJlZiBbXSBpblxuICBpdGVyX29ic2VydmVycyB0IH5mOihmdW4gKFQgaW50ZXJuYWxfb2JzZXJ2ZXIpIC0+XG4gICAgciA6PSBUIGludGVybmFsX29ic2VydmVyLm9ic2VydmluZyA6OiAhcik7XG4gICFyXG47O1xuXG5sZXQgaXRlcl9vYnNlcnZlcl9kZXNjZW5kYW50cyB0IH5mID0gTm9kZS5QYWNrZWQuaXRlcl9kZXNjZW5kYW50cyAoZGlyZWN0bHlfb2JzZXJ2ZWQgdCkgfmZcblxubW9kdWxlIFN0YXRzID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBtYXhfbnVtX3BhcmVudHMgOiBpbnRcbiAgICA7IHBlcmNlbnRhZ2Vfb2Zfbm9kZXNfYnlfbnVtX3BhcmVudHMgOiAoaW50ICogUGVyY2VudC50KSBsaXN0XG4gICAgfVxuICBbQEBkZXJpdmluZyBzZXhwXVxuZW5kXG5cbmxldCBzdGF0cyB0ID1cbiAgbGV0IG1heF9udW1fcGFyZW50cyA9IHJlZiAoLTEpIGluXG4gIGxldCBudW1fbmVjZXNzYXJ5X25vZGVzID0gcmVmIDAgaW5cbiAgaXRlcl9vYnNlcnZlcl9kZXNjZW5kYW50cyB0IH5mOihmdW4gKFQgbm9kZSkgLT5cbiAgICBpbmNyIG51bV9uZWNlc3Nhcnlfbm9kZXM7XG4gICAgbWF4X251bV9wYXJlbnRzIDo9IEludC5tYXggIW1heF9udW1fcGFyZW50cyBub2RlLm51bV9wYXJlbnRzKTtcbiAgbGV0IG1heF9udW1fcGFyZW50cyA9ICFtYXhfbnVtX3BhcmVudHMgaW5cbiAgbGV0IG51bV9ub2Rlc19ieV9udW1fcGFyZW50cyA9IEFycmF5LmNyZWF0ZSB+bGVuOihtYXhfbnVtX3BhcmVudHMgKyAxKSAwIGluXG4gIGl0ZXJfb2JzZXJ2ZXJfZGVzY2VuZGFudHMgdCB+ZjooZnVuIChUIG5vZGUpIC0+XG4gICAgbGV0IG51bV9wYXJlbnRzID0gbm9kZS5udW1fcGFyZW50cyBpblxuICAgIG51bV9ub2Rlc19ieV9udW1fcGFyZW50cy4obnVtX3BhcmVudHMpIDwtIG51bV9ub2Rlc19ieV9udW1fcGFyZW50cy4obnVtX3BhcmVudHMpICsgMSk7XG4gIGxldCBwZXJjZW50YWdlX29mX25vZGVzX2J5X251bV9wYXJlbnRzID1cbiAgICBBcnJheS5mb2xkaSBudW1fbm9kZXNfYnlfbnVtX3BhcmVudHMgfmluaXQ6W10gfmY6KGZ1biBpIGFjIG51bV9ub2RlcyAtPlxuICAgICAgaWYgbnVtX25vZGVzID0gMFxuICAgICAgdGhlbiBhY1xuICAgICAgZWxzZSAoaSwgUGVyY2VudC5vZl9tdWx0IChmbG9hdCBudW1fbm9kZXMgLy4gZmxvYXQgIW51bV9uZWNlc3Nhcnlfbm9kZXMpKSA6OiBhYylcbiAgICB8PiBMaXN0LnJldlxuICBpblxuICB7IFN0YXRzLm1heF9udW1fcGFyZW50czsgcGVyY2VudGFnZV9vZl9ub2Rlc19ieV9udW1fcGFyZW50cyB9XG47O1xuXG5sZXQgYW1fc3RhYmlsaXppbmcgdCA9XG4gIG1hdGNoIHQuc3RhdHVzIHdpdGhcbiAgfCBSdW5uaW5nX29uX3VwZGF0ZV9oYW5kbGVycyB8IFN0YWJpbGl6aW5nIC0+IHRydWVcbiAgfCBOb3Rfc3RhYmlsaXppbmcgLT4gZmFsc2VcbiAgfCBTdGFiaWxpemVfcHJldmlvdXNseV9yYWlzZWQgcmFpc2VkX2V4biAtPlxuICAgIFJhaXNlZF9leG4ucmVyYWlzZV93aXRoX21lc3NhZ2VcbiAgICAgIHJhaXNlZF9leG5cbiAgICAgIFwiY2Fubm90IGNhbGwgYW1fc3RhYmlsaXppbmcgLS0gc3RhYmlsaXplIHByZXZpb3VzbHkgcmFpc2VkXCJcbjs7XG5cbmxldCBpbnZhcmlhbnQgdCA9XG4gIG1hdGNoIHQuc3RhdHVzIHdpdGhcbiAgfCBTdGFiaWxpemVfcHJldmlvdXNseV9yYWlzZWQgXyAtPiAoKVxuICB8IFJ1bm5pbmdfb25fdXBkYXRlX2hhbmRsZXJzIHwgU3RhYmlsaXppbmcgfCBOb3Rfc3RhYmlsaXppbmcgLT5cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgICAgaXRlcl9vYnNlcnZlcnMgdCB+ZjooZnVuIChUIGludGVybmFsX29ic2VydmVyKSAtPlxuICAgICAgICAobWF0Y2ggaW50ZXJuYWxfb2JzZXJ2ZXIuc3RhdGUgd2l0aFxuICAgICAgICAgfCBJbl91c2UgfCBEaXNhbGxvd2VkIC0+ICgpXG4gICAgICAgICB8IENyZWF0ZWQgfCBVbmxpbmtlZCAtPlxuICAgICAgICAgICBmYWlsd2l0aHNcbiAgICAgICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgICAgICAgXCJtZW1iZXIgb2YgYWxsX29ic2VydmVycyB3aXRoIHVuZXhwZWN0ZWQgc3RhdGVcIlxuICAgICAgICAgICAgIGludGVybmFsX29ic2VydmVyXG4gICAgICAgICAgICAgWyVzZXhwX29mOiBfIEludGVybmFsX29ic2VydmVyLnRdKTtcbiAgICAgICAgSW50ZXJuYWxfb2JzZXJ2ZXIuaW52YXJpYW50IGlnbm9yZSBpbnRlcm5hbF9vYnNlcnZlcik7XG4gICAgICBpdGVyX29ic2VydmVyX2Rlc2NlbmRhbnRzIHQgfmY6KGZ1biAoVCBub2RlKSAtPlxuICAgICAgICBOb2RlLmludmFyaWFudCBpZ25vcmUgbm9kZTtcbiAgICAgICAgaWYgbm90IChhbV9zdGFiaWxpemluZyB0KSB0aGVuIGFzc2VydCAoVW9wdC5pc19ub25lIG5vZGUub2xkX3ZhbHVlX29wdCk7XG4gICAgICAgIGFzc2VydCAobm9kZS5oZWlnaHQgPD0gQWRqdXN0X2hlaWdodHNfaGVhcC5tYXhfaGVpZ2h0X3NlZW4gdC5hZGp1c3RfaGVpZ2h0c19oZWFwKSk7XG4gICAgICBhc3NlcnQgKFxuICAgICAgICBBZGp1c3RfaGVpZ2h0c19oZWFwLm1heF9oZWlnaHRfYWxsb3dlZCB0LmFkanVzdF9oZWlnaHRzX2hlYXBcbiAgICAgICAgPSBSZWNvbXB1dGVfaGVhcC5tYXhfaGVpZ2h0X2FsbG93ZWQgdC5yZWNvbXB1dGVfaGVhcCk7XG4gICAgICBGaWVsZHMuaXRlclxuICAgICAgICB+c3RhdHVzOmlnbm9yZVxuICAgICAgICB+YmluZF9saHNfY2hhbmdlX3Nob3VsZF9pbnZhbGlkYXRlX3JoczppZ25vcmVcbiAgICAgICAgfnN0YWJpbGl6YXRpb25fbnVtOihjaGVjayBTdGFiaWxpemF0aW9uX251bS5pbnZhcmlhbnQpXG4gICAgICAgIH5jdXJyZW50X3Njb3BlOlxuICAgICAgICAgIChjaGVjayAoZnVuIGN1cnJlbnRfc2NvcGUgLT4gYXNzZXJ0IChwaHlzX2VxdWFsIGN1cnJlbnRfc2NvcGUgU2NvcGUudG9wKSkpXG4gICAgICAgIH5yZWNvbXB1dGVfaGVhcDooY2hlY2sgUmVjb21wdXRlX2hlYXAuaW52YXJpYW50KVxuICAgICAgICB+YWRqdXN0X2hlaWdodHNfaGVhcDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBhZGp1c3RfaGVpZ2h0c19oZWFwIC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChBZGp1c3RfaGVpZ2h0c19oZWFwLmxlbmd0aCBhZGp1c3RfaGVpZ2h0c19oZWFwID0gMCk7XG4gICAgICAgICAgICAgQWRqdXN0X2hlaWdodHNfaGVhcC5pbnZhcmlhbnQgYWRqdXN0X2hlaWdodHNfaGVhcCkpXG4gICAgICAgIH5wcm9wYWdhdGVfaW52YWxpZGl0eTpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBwcm9wYWdhdGVfaW52YWxpZGl0eSAtPlxuICAgICAgICAgICAgIGFzc2VydCAoU3RhY2suaXNfZW1wdHkgcHJvcGFnYXRlX2ludmFsaWRpdHkpKSlcbiAgICAgICAgfm51bV9hY3RpdmVfb2JzZXJ2ZXJzOlxuICAgICAgICAgIChjaGVjayAoZnVuIG51bV9hY3RpdmVfb2JzZXJ2ZXJzIC0+IGFzc2VydCAobnVtX2FjdGl2ZV9vYnNlcnZlcnMgPj0gMCkpKVxuICAgICAgICB+YWxsX29ic2VydmVyczppZ25vcmVcbiAgICAgICAgfmZpbmFsaXplZF9vYnNlcnZlcnM6aWdub3JlXG4gICAgICAgIH5uZXdfb2JzZXJ2ZXJzOlxuICAgICAgICAgIChjaGVja1xuICAgICAgICAgICAgIChTdGFjay5pbnZhcmlhbnQgKGZ1biBwYWNrZWQgLT5cbiAgICAgICAgICAgICAgICBJbnRlcm5hbF9vYnNlcnZlci5QYWNrZWQuaW52YXJpYW50IHBhY2tlZDtcbiAgICAgICAgICAgICAgICBsZXQgKFQgaW50ZXJuYWxfb2JzZXJ2ZXIpID0gcGFja2VkIGluXG4gICAgICAgICAgICAgICAgKCogV2hlbiBhbiBvYnNlcnZlciBpcyBhZGRlZCB0byBbbmV3X29ic2VydmVyc10sIGl0IGhhcyBbc3RhdGUgPSBDcmVhdGVkXS5cbiAgICAgICAgICAgICAgICAgICBUaGUgb25seSBwb3NzaWJsZSB0cmFuc2l0aW9ucyBmcm9tIHRoZXJlIGFyZSB0byBbVW5saW5rZWRdIG9yIHRvXG4gICAgICAgICAgICAgICAgICAgW0luX3VzZV0sIHdoaWNoIGFsc28gcmVtb3ZlcyBpdCBmcm9tIFtuZXdfb2JzZXJ2ZXJzXSwgbmV2ZXIgdG8gYmUgYWRkZWRcbiAgICAgICAgICAgICAgICAgICBhZ2Fpbi4gIFRodXMgaXQgaXMgaW1wb3NzaWJsZSBmb3IgYW4gb2JzZXJ2ZXIgaW4gW25ld19vYnNlcnZlcnNdIHRvIGJlXG4gICAgICAgICAgICAgICAgICAgW0luX3VzZV0gb3IgW0Rpc2FsbG93ZWRdLiAqKVxuICAgICAgICAgICAgICAgIG1hdGNoIGludGVybmFsX29ic2VydmVyLnN0YXRlIHdpdGhcbiAgICAgICAgICAgICAgICB8IENyZWF0ZWQgfCBVbmxpbmtlZCAtPiAoKVxuICAgICAgICAgICAgICAgIHwgSW5fdXNlIHwgRGlzYWxsb3dlZCAtPiBhc3NlcnQgZmFsc2UpKSlcbiAgICAgICAgfmRpc2FsbG93ZWRfb2JzZXJ2ZXJzOlxuICAgICAgICAgIChjaGVja1xuICAgICAgICAgICAgIChTdGFjay5pbnZhcmlhbnQgKGZ1biBwYWNrZWQgLT5cbiAgICAgICAgICAgICAgICBJbnRlcm5hbF9vYnNlcnZlci5QYWNrZWQuaW52YXJpYW50IHBhY2tlZDtcbiAgICAgICAgICAgICAgICBsZXQgKFQgaW50ZXJuYWxfb2JzZXJ2ZXIpID0gcGFja2VkIGluXG4gICAgICAgICAgICAgICAgbWF0Y2ggaW50ZXJuYWxfb2JzZXJ2ZXIuc3RhdGUgd2l0aFxuICAgICAgICAgICAgICAgIHwgRGlzYWxsb3dlZCAtPiAoKVxuICAgICAgICAgICAgICAgIHwgQ3JlYXRlZCB8IEluX3VzZSB8IFVubGlua2VkIC0+IGFzc2VydCBmYWxzZSkpKVxuICAgICAgICB+c2V0X2R1cmluZ19zdGFiaWxpemF0aW9uOlxuICAgICAgICAgIChjaGVjayAoZnVuIHNldF9kdXJpbmdfc3RhYmlsaXphdGlvbiAtPlxuICAgICAgICAgICAgIG1hdGNoIHQuc3RhdHVzIHdpdGhcbiAgICAgICAgICAgICB8IFN0YWJpbGl6ZV9wcmV2aW91c2x5X3JhaXNlZCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgIHwgUnVubmluZ19vbl91cGRhdGVfaGFuZGxlcnMgfCBOb3Rfc3RhYmlsaXppbmcgLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAoU3RhY2suaXNfZW1wdHkgc2V0X2R1cmluZ19zdGFiaWxpemF0aW9uKVxuICAgICAgICAgICAgIHwgU3RhYmlsaXppbmcgLT5cbiAgICAgICAgICAgICAgIFN0YWNrLmludmFyaWFudFxuICAgICAgICAgICAgICAgICAoZnVuIChWYXIuUGFja2VkLlQgdmFyKSAtPlxuICAgICAgICAgICAgICAgICAgIGFzc2VydCAoVW9wdC5pc19zb21lIHZhci52YWx1ZV9zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24pKVxuICAgICAgICAgICAgICAgICBzZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24pKVxuICAgICAgICB+aGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb246KGNoZWNrIChTdGFjay5pbnZhcmlhbnQgTm9kZS5QYWNrZWQuaW52YXJpYW50KSlcbiAgICAgICAgfnJ1bl9vbl91cGRhdGVfaGFuZGxlcnM6KGNoZWNrIChTdGFjay5pbnZhcmlhbnQgUnVuX29uX3VwZGF0ZV9oYW5kbGVycy5pbnZhcmlhbnQpKVxuICAgICAgICB+b25seV9pbl9kZWJ1ZzooY2hlY2sgT25seV9pbl9kZWJ1Zy5pbnZhcmlhbnQpXG4gICAgICAgIH53ZWFrX2hhc2h0YmxzOmlnbm9yZVxuICAgICAgICB+a2VlcF9ub2RlX2NyZWF0aW9uX2JhY2t0cmFjZTppZ25vcmVcbiAgICAgICAgfm51bV9ub2Rlc19iZWNhbWVfbmVjZXNzYXJ5Omlnbm9yZVxuICAgICAgICB+bnVtX25vZGVzX2JlY2FtZV91bm5lY2Vzc2FyeTppZ25vcmVcbiAgICAgICAgfm51bV9ub2Rlc19jaGFuZ2VkOmlnbm9yZVxuICAgICAgICB+bnVtX25vZGVzX2NyZWF0ZWQ6aWdub3JlXG4gICAgICAgIH5udW1fbm9kZXNfaW52YWxpZGF0ZWQ6aWdub3JlXG4gICAgICAgIH5udW1fbm9kZXNfcmVjb21wdXRlZDppZ25vcmVcbiAgICAgICAgfm51bV9ub2Rlc19yZWNvbXB1dGVkX2RpcmVjdGx5X2JlY2F1c2Vfb25lX2NoaWxkOmlnbm9yZVxuICAgICAgICB+bnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWN0bHlfYmVjYXVzZV9taW5faGVpZ2h0Omlnbm9yZVxuICAgICAgICB+bnVtX3Zhcl9zZXRzOmlnbm9yZSlcbjs7XG5cbmxldCBlbnN1cmVfbm90X3N0YWJpbGl6aW5nIHQgfm5hbWUgfmFsbG93X2luX3VwZGF0ZV9oYW5kbGVyID1cbiAgbWF0Y2ggdC5zdGF0dXMgd2l0aFxuICB8IE5vdF9zdGFiaWxpemluZyAtPiAoKVxuICB8IFJ1bm5pbmdfb25fdXBkYXRlX2hhbmRsZXJzIC0+XG4gICAgaWYgbm90IGFsbG93X2luX3VwZGF0ZV9oYW5kbGVyXG4gICAgdGhlbiAoXG4gICAgICBsZXQgYmFja3RyYWNlID0gQmFja3RyYWNlLmdldCAoKSBpblxuICAgICAgZmFpbHdpdGhzXG4gICAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgICAgKHNwcmludGYgXCJjYW5ub3QgJXMgZHVyaW5nIG9uLXVwZGF0ZSBoYW5kbGVyc1wiIG5hbWUpXG4gICAgICAgIGJhY2t0cmFjZVxuICAgICAgICBbJXNleHBfb2Y6IEJhY2t0cmFjZS50XSlcbiAgfCBTdGFiaWxpemVfcHJldmlvdXNseV9yYWlzZWQgcmFpc2VkX2V4biAtPlxuICAgIFJhaXNlZF9leG4ucmVyYWlzZV93aXRoX21lc3NhZ2VcbiAgICAgIHJhaXNlZF9leG5cbiAgICAgIChzcHJpbnRmIFwiY2Fubm90ICVzIC0tIHN0YWJpbGl6ZSBwcmV2aW91c2x5IHJhaXNlZFwiIG5hbWUpXG4gIHwgU3RhYmlsaXppbmcgLT5cbiAgICBsZXQgYmFja3RyYWNlID0gQmFja3RyYWNlLmdldCAoKSBpblxuICAgIGZhaWx3aXRoc1xuICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgKHNwcmludGYgXCJjYW5ub3QgJXMgZHVyaW5nIHN0YWJpbGl6YXRpb25cIiBuYW1lKVxuICAgICAgYmFja3RyYWNlXG4gICAgICBbJXNleHBfb2Y6IEJhY2t0cmFjZS50XVxuOztcblxubGV0IHNldF9oZWlnaHQgKG5vZGUgOiBfIE5vZGUudCkgaGVpZ2h0ID1cbiAgbGV0IHQgPSBub2RlLnN0YXRlIGluXG4gIEFkanVzdF9oZWlnaHRzX2hlYXAuc2V0X2hlaWdodCB0LmFkanVzdF9oZWlnaHRzX2hlYXAgbm9kZSBoZWlnaHRcbjs7XG5cbmxldCBzZXRfbWF4X2hlaWdodF9hbGxvd2VkIHQgaGVpZ2h0ID1cbiAgZW5zdXJlX25vdF9zdGFiaWxpemluZyB0IH5uYW1lOlwic2V0X21heF9oZWlnaHRfYWxsb3dlZFwiIH5hbGxvd19pbl91cGRhdGVfaGFuZGxlcjp0cnVlO1xuICBBZGp1c3RfaGVpZ2h0c19oZWFwLnNldF9tYXhfaGVpZ2h0X2FsbG93ZWQgdC5hZGp1c3RfaGVpZ2h0c19oZWFwIGhlaWdodDtcbiAgUmVjb21wdXRlX2hlYXAuc2V0X21heF9oZWlnaHRfYWxsb3dlZCB0LnJlY29tcHV0ZV9oZWFwIGhlaWdodFxuOztcblxubGV0IGhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uIDogdHlwZSBhLiBhIE5vZGUudCAtPiB1bml0ID1cbiAgZnVuIG5vZGUgLT5cbiAgaWYgbm90IG5vZGUuaXNfaW5faGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb25cbiAgdGhlbiAoXG4gICAgbGV0IHQgPSBub2RlLnN0YXRlIGluXG4gICAgbm9kZS5pc19pbl9oYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiA8LSB0cnVlO1xuICAgIFN0YWNrLnB1c2ggdC5oYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiAoVCBub2RlKSlcbjs7XG5cbmxldCByZWMgcmVtb3ZlX2NoaWxkcmVuIDogdHlwZSBhLiBhIE5vZGUudCAtPiB1bml0ID1cbiAgZnVuIHBhcmVudCAtPlxuICBOb2RlLml0ZXJpX2NoaWxkcmVuIHBhcmVudCB+ZjooZnVuIGNoaWxkX2luZGV4IChUIGNoaWxkKSAtPlxuICAgIHJlbW92ZV9jaGlsZCB+Y2hpbGQgfnBhcmVudCB+Y2hpbGRfaW5kZXgpXG5cbmFuZCByZW1vdmVfY2hpbGQgOiB0eXBlIGEgYi4gY2hpbGQ6YiBOb2RlLnQgLT4gcGFyZW50OmEgTm9kZS50IC0+IGNoaWxkX2luZGV4OmludCAtPiB1bml0ID1cbiAgZnVuIH5jaGlsZCB+cGFyZW50IH5jaGlsZF9pbmRleCAtPlxuICBOb2RlLnJlbW92ZV9wYXJlbnQgfmNoaWxkIH5wYXJlbnQgfmNoaWxkX2luZGV4O1xuICBjaGVja19pZl91bm5lY2Vzc2FyeSBjaGlsZFxuXG5hbmQgY2hlY2tfaWZfdW5uZWNlc3NhcnkgOiB0eXBlIGEuIGEgTm9kZS50IC0+IHVuaXQgPVxuICBmdW4gbm9kZSAtPiBpZiBub3QgKE5vZGUuaXNfbmVjZXNzYXJ5IG5vZGUpIHRoZW4gYmVjYW1lX3VubmVjZXNzYXJ5IG5vZGVcblxuYW5kIGJlY2FtZV91bm5lY2Vzc2FyeSA6IHR5cGUgYS4gYSBOb2RlLnQgLT4gdW5pdCA9XG4gIGZ1biBub2RlIC0+XG4gIGxldCB0ID0gbm9kZS5zdGF0ZSBpblxuICB0Lm51bV9ub2Rlc19iZWNhbWVfdW5uZWNlc3NhcnkgPC0gdC5udW1fbm9kZXNfYmVjYW1lX3VubmVjZXNzYXJ5ICsgMTtcbiAgaWYgbm9kZS5udW1fb25fdXBkYXRlX2hhbmRsZXJzID4gMCB0aGVuIGhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uIG5vZGU7XG4gIG5vZGUuaGVpZ2h0IDwtIC0xO1xuICByZW1vdmVfY2hpbGRyZW4gbm9kZTtcbiAgKG1hdGNoIG5vZGUua2luZCB3aXRoXG4gICB8IFVub3JkZXJlZF9hcnJheV9mb2xkIHUgLT4gVW5vcmRlcmVkX2FycmF5X2ZvbGQuZm9yY2VfZnVsbF9jb21wdXRlIHVcbiAgIHwgRXhwZXJ0IHAgLT4gRXhwZXJ0Lm9ic2VydmFiaWxpdHlfY2hhbmdlIHAgfmlzX25vd19vYnNlcnZhYmxlOmZhbHNlXG4gICB8IF8gLT4gKCkpO1xuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAobm90IChOb2RlLm5lZWRzX3RvX2JlX2NvbXB1dGVkIG5vZGUpKTtcbiAgaWYgTm9kZS5pc19pbl9yZWNvbXB1dGVfaGVhcCBub2RlIHRoZW4gUmVjb21wdXRlX2hlYXAucmVtb3ZlIHQucmVjb21wdXRlX2hlYXAgbm9kZVxuOztcblxubGV0IHJlbW92ZV9hbGFybSAoY2xvY2sgOiBDbG9jay50KSBhbGFybSA9XG4gIGlmIFRpbWluZ193aGVlbC5tZW0gY2xvY2sudGltaW5nX3doZWVsIGFsYXJtXG4gIHRoZW4gVGltaW5nX3doZWVsLnJlbW92ZSBjbG9jay50aW1pbmdfd2hlZWwgYWxhcm1cbjs7XG5cbigqIEFuIGludmFsaWQgbm9kZSBpcyBub2RlIHdob3NlIGtpbmQgaXMgW0ludmFsaWRdLiAgQSBub2RlJ3Mga2luZCBpcyBzZXQgdG8gW0ludmFsaWRdXG4gICB3aGVuIHRoZSBsaHMgb2YgaXRzIHNjb3BlIGNoYW5nZXMsIG9yIG9uZSBpZiBpdHMgY2hpbGRyZW4gcHJvcGFnYXRlIHRoZSBpbnZhbGlkaXR5XG4gICB1cHdhcmQgKHNlZSBbTm9kZS5zaG91bGRfYmVfaW52YWxpZGF0ZWRdIHRvIHNlZSBpbiB3aGljaCBjYXNlIGludmFsaWRpdHkgcHJvcGFnYXRpb25cbiAgIHN0b3BzKS4gIEludmFsaWRhdGluZyBhIG5vZGUgZGlzY29ubmVjdHMgaXQgZnJvbSBpdHMgY2hpbGRyZW4sIHdoaWNoIG1lYW5zOlxuXG4gICAxLiBhbiBpbnZhbGlkIG5vZGUgY2Fubm90IGVuZCB1cCBvbiB0aGUgc2NoZWR1bGVyIChpZiBpdCBpcyBvbiB0aGUgc2NoZWR1bGVyIHdoZW5cbiAgIGl0IGlzIGludmFsaWRhdGVkLCBpdCBpcyByZW1vdmVkKVxuICAgMi4gYW4gaW52YWxpZCBub2RlIGRvZXNuJ3QgbWFrZSBpdHMgY2hpbGRyZW4gbmVjZXNzYXJ5IGFueW1vcmUuXG5cbiAgIEludmFsaWQgbm9kZXMgdXN1YWxseSBoYXZlIG5vIHBhcmVudHMsIGJlY2F1c2UgdGhlIHVwd2FyZCBpbnZhbGlkaXR5IHByb3BhZ2F0aW9uIG1lYW5zXG4gICB0aGF0IHRoZWlyIHBhcmVudHMgd2lsbCB0aGVtc2VsdmVzIGJlY29tZSBpbnZhbGlkIGFuZCBkaXNjb25uZWN0IGZyb20gdGhlaXIgY2hpbGRyZW4uXG4gICBIb3dldmVyLCBbaWZdLCBbam9pbl0gb3IgW2JpbmRdIGFyZSBub3QgaW52YWxpZGF0ZWQgYnkgdGhlIHVwd2FyZCBwcm9wYWdhdGlvbiwgc28gYW5cbiAgIGludmFsaWQgbm9kZSBjYW4gc3RpbGwgaGF2ZSBwYXJlbnRzLiAgSW52YWxpZCBub2RlcyBjYW4gYmUgbmVjZXNzYXJ5LCBpbiB0aGUgY2FzZSB3aGVyZVxuICAgdGhleSBoYXZlIHBhcmVudHMsIGFuZCBhbHNvIHdoZW4gdGhleSBhcmUgb2JzZXJ2ZWQuXG5cbiAgIFRoZSB1cHdhcmQgcHJvcGFnYXRpb24gb2YgaW52YWxpZGl0eSBoYXBwZW5zIGJvdGggd2hlbiBhIG5vZGUgYmVjb21lcyBpbnZhbGlkLCBhbmQgd2hlblxuICAgdHJ5aW5nIHRvIGFkZCBhbiBlZGdlIGZyb20gYW4gaW52YWxpZCBjaGlsZCBub2RlIHRvIGFub3RoZXIgbm9kZS4gIEJlY2F1c2UgaW52YWxpZGl0eVxuICAgaXMgb25seSBwcm9wYWdhdGVkIHVwd2FyZCwgYW5kIGJlY2F1c2UgdGhlIHJocyBvZiBhIGJpbmQgaXMgaW52YWxpZGF0ZWQgYmVmb3JlIGl0XG4gICBleGVjdXRlcywgYSBub2RlIGNhbm5vdCBiZSBib3RoIGNvbXB1dGVkIGFuZCBpbnZhbGlkYXRlZCBpbiB0aGUgc2FtZSBzdGFiaWxpemF0aW9uLlxuXG4gICBXaGVuIGludmFsaWRhdGluZywgd2UgY2FuJ3QgYXNzdW1lIG11Y2ggYWJvdXQgdGhlIG5vZGVzIHdlIHZpc2l0LiAgV2UgY2Fubm90IGFzc3VtZVxuICAgdGhhdCBub2RlcyBhcmUgdmFsaWQgKHRoZSByaHMgY2FuIGNvbnRhaW4gcHJldmlvdXNseSBpbnZhbGlkYXRlZCBub2RlcyksIG9yIHRoYXQgbm9kZXNcbiAgIGFyZSB1bm5lY2Vzc2FyeSAobm9kZXMgY2FuIGJlIG1hZGUgbmVjZXNzYXJ5IHdpdGhvdXQgZ29pbmcgdGhyb3VnaCB0aGVpciBjb250YWluaW5nXG4gICBiaW5kcykuICopXG5cbmxldCByZWMgaW52YWxpZGF0ZV9ub2RlIDogdHlwZSBhLiBhIE5vZGUudCAtPiB1bml0ID1cbiAgZnVuIG5vZGUgLT5cbiAgaWYgTm9kZS5pc192YWxpZCBub2RlXG4gIHRoZW4gKFxuICAgIGxldCB0ID0gbm9kZS5zdGF0ZSBpblxuICAgIGlmIG5vZGUubnVtX29uX3VwZGF0ZV9oYW5kbGVycyA+IDAgdGhlbiBoYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiBub2RlO1xuICAgIG5vZGUudmFsdWVfb3B0IDwtIFVvcHQubm9uZTtcbiAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoVW9wdC5pc19ub25lIG5vZGUub2xkX3ZhbHVlX29wdCk7XG4gICAgbm9kZS5jaGFuZ2VkX2F0IDwtIHQuc3RhYmlsaXphdGlvbl9udW07XG4gICAgbm9kZS5yZWNvbXB1dGVkX2F0IDwtIHQuc3RhYmlsaXphdGlvbl9udW07XG4gICAgdC5udW1fbm9kZXNfaW52YWxpZGF0ZWQgPC0gdC5udW1fbm9kZXNfaW52YWxpZGF0ZWQgKyAxO1xuICAgIGlmIE5vZGUuaXNfbmVjZXNzYXJ5IG5vZGVcbiAgICB0aGVuIChcbiAgICAgIHJlbW92ZV9jaGlsZHJlbiBub2RlO1xuICAgICAgKCogVGhlIG5vZGUgZG9lc24ndCBoYXZlIGNoaWxkcmVuIGFueW1vcmUsIHNvIHdlIGNhbiBsb3dlciBpdHMgaGVpZ2h0IGFzIG11Y2ggYXNcbiAgICAgICAgIHBvc3NpYmxlLCB0byBvbmUgZ3JlYXRlciB0aGFuIHRoZSBzY29wZSBpdCB3YXMgY3JlYXRlZCBpbi4gIEFsc28sIGJlY2F1c2Ugd2VcbiAgICAgICAgIGFyZSBsb3dlcmluZyB0aGUgaGVpZ2h0LCB3ZSBkb24ndCBuZWVkIHRvIGFkanVzdCBhbnkgb2YgaXRzIGFuY2VzdG9ycycgaGVpZ2h0cy5cbiAgICAgICAgIFdlIGNvdWxkIGxlYXZlIHRoZSBoZWlnaHQgYWxvbmUsIGJ1dCB3ZSBtYXkgYXMgd2VsbCBsb3dlciBpdCBhcyBtdWNoIGFzXG4gICAgICAgICBwb3NzaWJsZSB0byBhdm9pZCBtYWtpbmcgdGhlIGhlaWdodHMgb2YgYW55IGZ1dHVyZSBhbmNlc3RvcnMgdW5uZWNlc3NhcmlseVxuICAgICAgICAgbGFyZ2UuICopXG4gICAgICBub2RlLmhlaWdodCA8LSBTY29wZS5oZWlnaHQgbm9kZS5jcmVhdGVkX2luICsgMSk7XG4gICAgKCogV2UgZG9uJ3Qgc2V0IFtub2RlLmNyZWF0ZWRfaW5dIG9yIFtub2RlLm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlXTsgd2UgbGVhdmUgW25vZGVdXG4gICAgICAgaW4gdGhlIHNjb3BlIGl0IHdhcyBjcmVhdGVkIGluLiAgSWYgdGhhdCBzY29wZSBpcyBldmVyIGludmFsaWRhdGVkLCB0aGVuIHRoYXRcbiAgICAgICB3aWxsIGNsZWFyIFtub2RlLm5leHRfbm9kZV9pbl9zYW1lX3Njb3BlXSAqKVxuICAgIChtYXRjaCBub2RlLmtpbmQgd2l0aFxuICAgICB8IEF0IGF0IC0+IHJlbW92ZV9hbGFybSBhdC5jbG9jayBhdC5hbGFybVxuICAgICB8IEF0X2ludGVydmFscyBhdF9pbnRlcnZhbHMgLT4gcmVtb3ZlX2FsYXJtIGF0X2ludGVydmFscy5jbG9jayBhdF9pbnRlcnZhbHMuYWxhcm1cbiAgICAgfCBCaW5kX21haW4gYmluZCAtPiBpbnZhbGlkYXRlX25vZGVzX2NyZWF0ZWRfb25fcmhzIGJpbmQuYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzXG4gICAgIHwgU3RlcF9mdW5jdGlvbiB7IGFsYXJtOyBjbG9jazsgXyB9IC0+IHJlbW92ZV9hbGFybSBjbG9jayBhbGFybVxuICAgICB8IF8gLT4gKCkpO1xuICAgIE5vZGUuc2V0X2tpbmQgbm9kZSBJbnZhbGlkO1xuICAgICgqIElmIHdlIGNhbGxlZCBbcHJvcGFnYXRlX2ludmFsaWRpdHldIHJpZ2h0IGF3YXkgb24gdGhlIHBhcmVudHMsIHdlIHdvdWxkIGdldCBpbnRvXG4gICAgICAgdHJvdWJsZS4gIFRoZSBwYXJlbnQgd291bGQgZGlzY29ubmVjdCBpdHNlbGYgZnJvbSB0aGUgY3VycmVudCBub2RlLCB0aHVzXG4gICAgICAgbW9kaWZ5aW5nIHRoZSBsaXN0IG9mIHBhcmVudHMgd2UgaXRlcmF0ZSBvbi4gIEV2ZW4gaWYgd2UgbWFkZSBhIHNwZWNpYWwgY2FzZSwgaXRcbiAgICAgICBzdGlsbCB3b3VsZG4ndCBiZSBlbm91Z2ggdG8gaGFuZGxlIG90aGVyIGNhc2VzIHdoZXJlIHRoZSBsaXN0IG9mIHBhcmVudHMgaXNcbiAgICAgICBtb2RpZmllZCAoZS5nLiB3aGVuIFtsaHNdIGlzIGludmFsaWRhdGVkIGluIHRoZSBleGFtcGxlIGluIHRoZSBjb21tZW50IGFib3V0XG4gICAgICAgW2Nhbl9yZWNvbXB1dGVfbm93XSBmYXIgYmVsb3cpLiAqKVxuICAgIGZvciBpbmRleCA9IDAgdG8gbm9kZS5udW1fcGFyZW50cyAtIDEgZG9cbiAgICAgIFN0YWNrLnB1c2ggdC5wcm9wYWdhdGVfaW52YWxpZGl0eSAoTm9kZS5nZXRfcGFyZW50IG5vZGUgfmluZGV4KVxuICAgIGRvbmU7XG4gICAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKG5vdCAoTm9kZS5uZWVkc190b19iZV9jb21wdXRlZCBub2RlKSk7XG4gICAgaWYgTm9kZS5pc19pbl9yZWNvbXB1dGVfaGVhcCBub2RlIHRoZW4gUmVjb21wdXRlX2hlYXAucmVtb3ZlIHQucmVjb21wdXRlX2hlYXAgbm9kZSlcblxuYW5kIGludmFsaWRhdGVfbm9kZXNfY3JlYXRlZF9vbl9yaHMgbm9kZSA9XG4gIGxldCByID0gcmVmIG5vZGUgaW5cbiAgd2hpbGUgVW9wdC5pc19zb21lICFyIGRvXG4gICAgbGV0IChUIG5vZGVfb25fcmhzKSA9IFVvcHQudW5zYWZlX3ZhbHVlICFyIGluXG4gICAgciA6PSBub2RlX29uX3Jocy5uZXh0X25vZGVfaW5fc2FtZV9zY29wZTtcbiAgICBub2RlX29uX3Jocy5uZXh0X25vZGVfaW5fc2FtZV9zY29wZSA8LSBVb3B0Lm5vbmU7XG4gICAgaW52YWxpZGF0ZV9ub2RlIG5vZGVfb25fcmhzXG4gIGRvbmVcbjs7XG5cbigqIFdoZW4gW25vdCB0LmJpbmRfbGhzX2NoYW5nZV9zaG91bGRfaW52YWxpZGF0ZV9yaHNdIGFuZCBhIGJpbmQncyBsaHMgY2hhbmdlcywgd2UgbW92ZVxuICAgbm9kZXMgY3JlYXRlZCBvbiB0aGUgYmluZCdzIHJocyB1cCB0byBpdHMgcGFyZW50IGJpbmQsIGFzIG9wcG9zZWQgdG8gW1Njb3BlLlRvcF0uICBUaGlzXG4gICBtYWludGFpbnMgdGhlaXIgZGVwZW5kZW5jZSBvbiB2YWxpZCBiaW5kIGxlZnQtaGFuZCBzaWRlcywgYW5kIGtlZXBzIHRoZW0gaGlnaGVyIGluIHRoZVxuICAgZ3JhcGguICBUaGlzIGluIHR1cm4gbWVhbnMgdGhhdCB3ZSB3aWxsIGNvbnRpbnVlIHRvIGNvbXB1dGUgdGhvc2Ugbm9kZXMgYWZ0ZXIgdGhlXG4gICBwYXJlbnQgYmluZCdzIGxocywgd2hpY2ggZ2l2ZXMgdGhlbSBtb3JlIG9mIGEgY2hhbmNlIHRvIGJlY29tZSB1bm5lY2Vzc2FyeSBhbmQgbm90IGJlXG4gICBjb21wdXRlZCBzaG91bGQgdGhlIHBhcmVudCBiaW5kJ3MgbGhzIGNoYW5nZS4gKilcbmxldCByZXNjb3BlX25vZGVzX2NyZWF0ZWRfb25fcmhzIF90IChmaXJzdF9ub2RlX29uX3JocyA6IE5vZGUuUGFja2VkLnQgVW9wdC50KSB+bmV3X3Njb3BlID1cbiAgbGV0IHIgPSByZWYgZmlyc3Rfbm9kZV9vbl9yaHMgaW5cbiAgd2hpbGUgVW9wdC5pc19zb21lICFyIGRvXG4gICAgbGV0IChUIG5vZGVfb25fcmhzKSA9IFVvcHQudW5zYWZlX3ZhbHVlICFyIGluXG4gICAgciA6PSBub2RlX29uX3Jocy5uZXh0X25vZGVfaW5fc2FtZV9zY29wZTtcbiAgICBub2RlX29uX3Jocy5uZXh0X25vZGVfaW5fc2FtZV9zY29wZSA8LSBVb3B0Lm5vbmU7XG4gICAgbm9kZV9vbl9yaHMuY3JlYXRlZF9pbiA8LSBuZXdfc2NvcGU7XG4gICAgU2NvcGUuYWRkX25vZGUgbmV3X3Njb3BlIG5vZGVfb25fcmhzXG4gIGRvbmVcbjs7XG5cbmxldCBwcm9wYWdhdGVfaW52YWxpZGl0eSB0ID1cbiAgd2hpbGUgbm90IChTdGFjay5pc19lbXB0eSB0LnByb3BhZ2F0ZV9pbnZhbGlkaXR5KSBkb1xuICAgIGxldCAoVCBub2RlKSA9IFN0YWNrLnBvcF9leG4gdC5wcm9wYWdhdGVfaW52YWxpZGl0eSBpblxuICAgIGlmIE5vZGUuaXNfdmFsaWQgbm9kZVxuICAgIHRoZW5cbiAgICAgIGlmIE5vZGUuc2hvdWxkX2JlX2ludmFsaWRhdGVkIG5vZGVcbiAgICAgIHRoZW4gaW52YWxpZGF0ZV9ub2RlIG5vZGVcbiAgICAgIGVsc2UgKFxuICAgICAgICAoKiBbTm9kZS5uZWVkc190b19iZV9jb21wdXRlZCBub2RlXSBpcyB0cnVlIGJlY2F1c2VcbiAgICAgICAgICAgLSBub2RlIGlzIG5lY2Vzc2FyeS4gVGhpcyBpcyBiZWNhdXNlIGNoaWxkcmVuIGNhbiBvbmx5IHBvaW50IHRvIG5lY2Vzc2FyeVxuICAgICAgICAgICAgIHBhcmVudHNcbiAgICAgICAgICAgLSBub2RlIGlzIHN0YWxlLiBUaGlzIGlzIGJlY2F1c2U6IEZvciBiaW5kLCBpZiwgam9pbiwgdGhpcyBpcyB0cnVlIGJlY2F1c2VcbiAgICAgICAgICAgLSBlaXRoZXIgdGhlIGludmFsaWRhdGlvbiBpcyBjYXVzZWQgYnkgdGhlIGxocyBjaGFuZ2luZyAoaW4gd2hpY2ggY2FzZSB0aGVcbiAgICAgICAgICAgICBsaHMtY2hhbmdlIG5vZGUgYmVpbmcgbmV3ZXIgbWFrZXMgdXMgc3RhbGUpLlxuICAgICAgICAgICAtIG9yIGEgY2hpbGQgYmVjYW1lIGludmFsaWQgdGhpcyBzdGFiaWxpemF0aW9uIGN5Y2xlLCBpbiB3aGljaCBjYXNlIGl0IGhhc1xuICAgICAgICAgICAgIHQuY2hhbmdlZF9hdCBvZiBbdC5zdGFiaWxpemF0aW9uX251bV0sIGFuZCBzbyBbbm9kZV0gaXMgc3RhbGVcbiAgICAgICAgICAgLSBvciBbbm9kZV0ganVzdCBiZWNhbWUgbmVjZXNzYXJ5IGFuZCB0cmllZCBjb25uZWN0aW5nIHRvIGFuIGFscmVhZHkgaW52YWxpZFxuICAgICAgICAgICAgIGNoaWxkLiBJbiB0aGF0IGNhc2UsIFtjaGlsZC5jaGFuZ2VkX2F0ID4gbm9kZS5yZWNvbXB1dGVkX2F0XSBmb3IgdGhhdCBjaGlsZCxcbiAgICAgICAgICAgICBiZWNhdXNlIGlmIHdlIGhhZCBiZWVuIHJlY29tcHV0ZWQgd2hlbiB0aGF0IGNoaWxkIGNoYW5nZWQsIHdlIHdvdWxkIGhhdmUgYmVlblxuICAgICAgICAgICAgIG1hZGUgaW52YWxpZCBiYWNrIHRoZW4uICBGb3IgZXhwZXJ0IG5vZGVzLCB0aGUgYXJndW1lbnQgaXMgdGhlIHNhbWUsIGV4Y2VwdFxuICAgICAgICAgICAgIHRoYXQgaW5zdGVhZCBvZiBsaHMtY2hhbmdlIG5vZGVzIG1ha2UgdGhlIGV4cGVydCBub2RlcyBzdGFsZSwgaXQncyBtYWRlIHN0YWxlXG4gICAgICAgICAgICAgZXhwbGljaXRlbHkgd2hlbiBhZGRpbmcgb3IgcmVtb3ZpbmcgY2hpbGRyZW4uICopXG4gICAgICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLm5lZWRzX3RvX2JlX2NvbXB1dGVkIG5vZGUpO1xuICAgICAgICAobWF0Y2ggbm9kZS5raW5kIHdpdGhcbiAgICAgICAgIHwgRXhwZXJ0IGV4cGVydCAtPlxuICAgICAgICAgICAoKiBJZiBtdWx0aXBsZSBjaGlsZHJlbiBhcmUgaW52YWxpZCwgdGhleSB3aWxsIHB1c2ggdXMgYXMgbWFueSB0aW1lcyBvbiB0aGVcbiAgICAgICAgICAgICAgcHJvcGFnYXRpb24gc3RhY2ssIHNvIHdlIGNvdW50IHRoZW0gcmlnaHQuICopXG4gICAgICAgICAgIEV4cGVydC5pbmNyX2ludmFsaWRfY2hpbGRyZW4gZXhwZXJ0XG4gICAgICAgICB8IGtpbmQgLT5cbiAgICAgICAgICAgaWYgZGVidWdcbiAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgbWF0Y2gga2luZCB3aXRoXG4gICAgICAgICAgICAgfCBCaW5kX21haW4gXyB8IElmX3RoZW5fZWxzZSBfIHwgSm9pbl9tYWluIF8gLT4gKClcbiAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgIGFzc2VydCBmYWxzZSAoKiBub2RlcyB3aXRoIG5vIGNoaWxkcmVuIGFyZSBuZXZlciBwdXNoZWQgb24gdGhlIHN0YWNrICopKSk7XG4gICAgICAgICgqIFdlIGRvIG5vdCBjaGVjayBbTm9kZS5uZWVkc190b19iZV9jb21wdXRlZCBub2RlXSBoZXJlLCBiZWNhdXNlIGl0IHNob3VsZCBiZVxuICAgICAgICAgICB0cnVlLCBhbmQgYmVjYXVzZSBjb21wdXRpbmcgaXQgdGFrZXMgTyhudW1iZXIgb2YgY2hpbGRyZW4pLCBub2RlIGNhbiBiZSBwdXNoZWRcbiAgICAgICAgICAgb24gdGhlIHN0YWNrIG9uY2UgcGVyIGNoaWxkLCBhbmQgZXhwZXJ0IG5vZGVzIGNhbiBoYXZlIGxvdHMgb2YgY2hpbGRyZW4uICopXG4gICAgICAgIGlmIG5vdCAoTm9kZS5pc19pbl9yZWNvbXB1dGVfaGVhcCBub2RlKVxuICAgICAgICB0aGVuIFJlY29tcHV0ZV9oZWFwLmFkZCB0LnJlY29tcHV0ZV9oZWFwIG5vZGUpXG4gIGRvbmVcbjs7XG5cbigqIFthZGRfcGFyZW50X3dpdGhvdXRfYWRqdXN0aW5nX2hlaWdodHMgdCB+Y2hpbGQgfnBhcmVudF0gYWRkcyBbcGFyZW50XSBhcyBhIHBhcmVudCBvZlxuICAgW2NoaWxkXSwgYW5kIG1ha2VzIFtjaGlsZF0gYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMgbmVjZXNzYXJ5LCBlbnN1cmluZyB0aGVpciBoZWlnaHRzXG4gICBhcmUgYWNjdXJhdGUuICBUaGVyZSBpcyBubyBndWFyYW50ZWUgYWJvdXQgdGhlIHJlbGF0aXZlIGhlaWdodHMgb2YgW2NoaWxkXSBhbmQgW3BhcmVudF1cbiAgIHRob3VnaC4gKilcbmxldCByZWMgYWRkX3BhcmVudF93aXRob3V0X2FkanVzdGluZ19oZWlnaHRzXG4gIDogdHlwZSBhIGIuIGNoaWxkOmEgTm9kZS50IC0+IHBhcmVudDpiIE5vZGUudCAtPiBjaGlsZF9pbmRleDppbnQgLT4gdW5pdFxuICA9XG4gIGZ1biB+Y2hpbGQgfnBhcmVudCB+Y2hpbGRfaW5kZXggLT5cbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKE5vZGUuaXNfbmVjZXNzYXJ5IHBhcmVudCk7XG4gIGxldCB0ID0gY2hpbGQuc3RhdGUgaW5cbiAgbGV0IHdhc19uZWNlc3NhcnkgPSBOb2RlLmlzX25lY2Vzc2FyeSBjaGlsZCBpblxuICBOb2RlLmFkZF9wYXJlbnQgfmNoaWxkIH5wYXJlbnQgfmNoaWxkX2luZGV4O1xuICBpZiBub3QgKE5vZGUuaXNfdmFsaWQgY2hpbGQpIHRoZW4gU3RhY2sucHVzaCB0LnByb3BhZ2F0ZV9pbnZhbGlkaXR5IChUIHBhcmVudCk7XG4gIGlmIG5vdCB3YXNfbmVjZXNzYXJ5IHRoZW4gYmVjYW1lX25lY2Vzc2FyeSBjaGlsZDtcbiAgbWF0Y2ggcGFyZW50LmtpbmQgd2l0aFxuICB8IEV4cGVydCBlIC0+IEV4cGVydC5ydW5fZWRnZV9jYWxsYmFjayBlIH5jaGlsZF9pbmRleFxuICB8IF8gLT4gKClcblxuYW5kIGJlY2FtZV9uZWNlc3NhcnkgOiB0eXBlIGEuIGEgTm9kZS50IC0+IHVuaXQgPVxuICBmdW4gbm9kZSAtPlxuICAoKiBbU2NvcGUuaXNfbmVjZXNzYXJ5IG5vZGUuY3JlYXRlZF9pbl0gaXMgdHJ1ZSAoYXNzdW1pbmcgdGhlIHNjb3BlIGl0c2VsZiBpcyB2YWxpZClcbiAgICAgYmVjYXVzZSBbTm9kZS5pdGVyX2NoaWxkcmVuXSBiZWxvdyBmaXJzdCB2aXNpdHMgdGhlIGxocy1jaGFuZ2Ugb2YgYmluZCBub2RlcyBhbmRcbiAgICAgdGhlbiB0aGUgcmhzLiAqKVxuICBpZiBOb2RlLmlzX3ZhbGlkIG5vZGUgJiYgbm90IChTY29wZS5pc19uZWNlc3Nhcnkgbm9kZS5jcmVhdGVkX2luKVxuICB0aGVuXG4gICAgZmFpbHdpdGhzXG4gICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICBcIlRyeWluZyB0byBtYWtlIGEgbm9kZSBuZWNlc3Nhcnkgd2hvc2UgZGVmaW5pbmcgYmluZCBpcyBub3QgbmVjZXNzYXJ5XCJcbiAgICAgIG5vZGVcbiAgICAgIFslc2V4cF9vZjogXyBOb2RlLnRdO1xuICBsZXQgdCA9IG5vZGUuc3RhdGUgaW5cbiAgdC5udW1fbm9kZXNfYmVjYW1lX25lY2Vzc2FyeSA8LSB0Lm51bV9ub2Rlc19iZWNhbWVfbmVjZXNzYXJ5ICsgMTtcbiAgaWYgbm9kZS5udW1fb25fdXBkYXRlX2hhbmRsZXJzID4gMCB0aGVuIGhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uIG5vZGU7XG4gICgqIFNpbmNlIFtub2RlXSBiZWNhbWUgbmVjZXNzYXJ5LCB0byByZXN0b3JlIHRoZSBpbnZhcmlhbnQsIHdlIG5lZWQgdG86XG5cbiAgICAgLSBhZGQgcGFyZW50IHBvaW50ZXJzIHRvIFtub2RlXSBmcm9tIGl0cyBjaGlsZHJlbi5cbiAgICAgLSBzZXQgW25vZGVdJ3MgaGVpZ2h0LlxuICAgICAtIGFkZCBbbm9kZV0gdG8gdGhlIHJlY29tcHV0ZSBoZWFwLCBpZiBuZWNlc3NhcnkuICopXG4gIHNldF9oZWlnaHQgbm9kZSAoU2NvcGUuaGVpZ2h0IG5vZGUuY3JlYXRlZF9pbiArIDEpO1xuICBOb2RlLml0ZXJpX2NoaWxkcmVuIG5vZGUgfmY6KGZ1biBjaGlsZF9pbmRleCAoVCBjaGlsZCkgLT5cbiAgICBhZGRfcGFyZW50X3dpdGhvdXRfYWRqdXN0aW5nX2hlaWdodHMgfmNoaWxkIH5wYXJlbnQ6bm9kZSB+Y2hpbGRfaW5kZXg7XG4gICAgKCogTm93IHRoYXQgY2hpbGQgaXMgbmVjZXNzYXJ5LCBpdCBzaG91bGQgaGF2ZSBhIHZhbGlkIGhlaWdodC4gKilcbiAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoY2hpbGQuaGVpZ2h0ID49IDApO1xuICAgIGlmIGNoaWxkLmhlaWdodCA+PSBub2RlLmhlaWdodCB0aGVuIHNldF9oZWlnaHQgbm9kZSAoY2hpbGQuaGVpZ2h0ICsgMSkpO1xuICAoKiBOb3cgdGhhdCB0aGUgaGVpZ2h0IGlzIGNvcnJlY3QsIG1heWJlIGFkZCBbbm9kZV0gdG8gdGhlIHJlY29tcHV0ZSBoZWFwLiAgW25vZGVdXG4gICAgIGp1c3QgYmVjYW1lIG5lY2Vzc2FyeSwgc28gaXQgY2FuJ3QgaGF2ZSBiZWVuIGluIHRoZSByZWNvbXB1dGUgaGVhcC4gIFNpbmNlIFtub2RlXVxuICAgICBpcyBuZWNlc3NhcnksIHdlIHNob3VsZCBhZGQgaXQgdG8gdGhlIHJlY29tcHV0ZSBoZWFwIGlmZiBpdCBpcyBzdGFsZS4gKilcbiAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKG5vdCAoTm9kZS5pc19pbl9yZWNvbXB1dGVfaGVhcCBub2RlKSk7XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLmlzX25lY2Vzc2FyeSBub2RlKTtcbiAgaWYgTm9kZS5pc19zdGFsZSBub2RlIHRoZW4gUmVjb21wdXRlX2hlYXAuYWRkIHQucmVjb21wdXRlX2hlYXAgbm9kZTtcbiAgbWF0Y2ggbm9kZS5raW5kIHdpdGhcbiAgfCBFeHBlcnQgcCAtPiBFeHBlcnQub2JzZXJ2YWJpbGl0eV9jaGFuZ2UgcCB+aXNfbm93X29ic2VydmFibGU6dHJ1ZVxuICB8IF8gLT4gKClcbjs7XG5cbmxldCBiZWNhbWVfbmVjZXNzYXJ5IG5vZGUgPVxuICBiZWNhbWVfbmVjZXNzYXJ5IG5vZGU7XG4gIHByb3BhZ2F0ZV9pbnZhbGlkaXR5IG5vZGUuc3RhdGVcbjs7XG5cbmxldCBhZGRfcGFyZW50IH5jaGlsZCB+cGFyZW50IH5jaGlsZF9pbmRleCA9XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLmlzX25lY2Vzc2FyeSBwYXJlbnQpO1xuICBsZXQgdCA9IHBhcmVudC5zdGF0ZSBpblxuICAoKiBJbiB0aGUgY2FzZSB3aGVuIHRoZSBlZGdlIGJlaW5nIGFkZGVkIGNyZWF0ZXMgYSBjeWNsZSwgaXQgaXMgcG9zc2libGUgZm9yIHRoZVxuICAgICByZWN1cnNpb24gaW4gW2FkZF9wYXJlbnRfd2l0aG91dF9hZGp1c3RpbmdfaGVpZ2h0c10gdG8gcmVhY2ggW3BhcmVudF0gYXMgYSBkZXNjZW5kYW50XG4gICAgIG9mIFtjaGlsZF0uICBJbiB0aGF0IGNhc2UsIHRoZSByZWN1cnNpb24gdGVybWluYXRlcywgYmVjYXVzZSBbTm9kZS5pc19uZWNlc3NhcnlcbiAgICAgcGFyZW50XS4gIFdlIHRoZW4gcmV0dXJuIGhlcmUgYW5kIHN1YnNlcXVlbnRseSBkZXRlY3QgdGhlIGN5Y2xlIGluXG4gICAgIFthZGp1c3RfaGVpZ2h0c10uICopXG4gIGFkZF9wYXJlbnRfd2l0aG91dF9hZGp1c3RpbmdfaGVpZ2h0cyB+Y2hpbGQgfnBhcmVudCB+Y2hpbGRfaW5kZXg7XG4gICgqIFdlIGFkanVzdCBoZWlnaHRzIHNvIHRoYXQgd2UgZW5zdXJlIHRoZXJlIGFyZSBubyBjeWNsZXMgYmVmb3JlIGNhbGxpbmdcbiAgICAgW3Byb3BhZ2F0ZV9pbnZhbGlkaXR5XS4gKilcbiAgaWYgY2hpbGQuaGVpZ2h0ID49IHBhcmVudC5oZWlnaHRcbiAgdGhlblxuICAgIEFkanVzdF9oZWlnaHRzX2hlYXAuYWRqdXN0X2hlaWdodHNcbiAgICAgIHQuYWRqdXN0X2hlaWdodHNfaGVhcFxuICAgICAgdC5yZWNvbXB1dGVfaGVhcFxuICAgICAgfmNoaWxkXG4gICAgICB+cGFyZW50O1xuICBwcm9wYWdhdGVfaW52YWxpZGl0eSB0O1xuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoTm9kZS5pc19uZWNlc3NhcnkgcGFyZW50KTtcbiAgKCogd2Ugb25seSBhZGQgbmVjZXNzYXJ5IHBhcmVudHMgKilcbiAgaWYgKG5vdCAoTm9kZS5pc19pbl9yZWNvbXB1dGVfaGVhcCBwYXJlbnQpKVxuICAgICAmJiAoU3RhYmlsaXphdGlvbl9udW0uaXNfbm9uZSBwYXJlbnQucmVjb21wdXRlZF9hdFxuICAgICAgICAgfHwgTm9kZS5lZGdlX2lzX3N0YWxlIH5jaGlsZCB+cGFyZW50KVxuICB0aGVuIFJlY29tcHV0ZV9oZWFwLmFkZCB0LnJlY29tcHV0ZV9oZWFwIHBhcmVudFxuOztcblxubGV0IHJ1bl93aXRoX3Njb3BlIHQgc2NvcGUgfmYgPVxuICBsZXQgc2F2ZWQgPSB0LmN1cnJlbnRfc2NvcGUgaW5cbiAgdC5jdXJyZW50X3Njb3BlIDwtIHNjb3BlO1xuICB0cnlcbiAgICBsZXQgdiA9IGYgKCkgaW5cbiAgICB0LmN1cnJlbnRfc2NvcGUgPC0gc2F2ZWQ7XG4gICAgdlxuICB3aXRoXG4gIHwgZXhuIC0+XG4gICAgdC5jdXJyZW50X3Njb3BlIDwtIHNhdmVkO1xuICAgIHJhaXNlIGV4blxuOztcblxubGV0IHdpdGhpbl9zY29wZSB0IHNjb3BlIH5mID1cbiAgaWYgbm90IChTY29wZS5pc192YWxpZCBzY29wZSlcbiAgdGhlbiBmYWlsd2l0aHMgfmhlcmU6WyVoZXJlXSBcImF0dGVtcHQgdG8gcnVuIHdpdGhpbiBhbiBpbnZhbGlkIHNjb3BlXCIgdCBbJXNleHBfb2Y6IHRdO1xuICBydW5fd2l0aF9zY29wZSB0IHNjb3BlIH5mXG47O1xuXG5sZXQgY2hhbmdlX2NoaWxkXG4gIDogdHlwZSBhIGIuXG4gICAgcGFyZW50OmEgTm9kZS50XG4gICAgLT4gb2xkX2NoaWxkOmIgTm9kZS50IFVvcHQudFxuICAgIC0+IG5ld19jaGlsZDpiIE5vZGUudFxuICAgIC0+IGNoaWxkX2luZGV4OmludFxuICAgIC0+IHVuaXRcbiAgPVxuICBmdW4gfnBhcmVudCB+b2xkX2NoaWxkIH5uZXdfY2hpbGQgfmNoaWxkX2luZGV4IC0+XG4gIGlmIFVvcHQuaXNfbm9uZSBvbGRfY2hpbGRcbiAgdGhlbiBhZGRfcGFyZW50IH5jaGlsZDpuZXdfY2hpbGQgfnBhcmVudCB+Y2hpbGRfaW5kZXhcbiAgZWxzZSAoXG4gICAgbGV0IG9sZF9jaGlsZCA9IFVvcHQudW5zYWZlX3ZhbHVlIG9sZF9jaGlsZCBpblxuICAgIGlmIG5vdCAocGh5c19lcXVhbCBvbGRfY2hpbGQgbmV3X2NoaWxkKVxuICAgIHRoZW4gKFxuICAgICAgKCogV2UgcmVtb3ZlIFtvbGRfY2hpbGRdIGJlZm9yZSBhZGRpbmcgW25ld19jaGlsZF0sIGJlY2F1c2UgdGhleSBzaGFyZSB0aGUgc2FtZVxuICAgICAgICAgY2hpbGQgaW5kZXguICopXG4gICAgICBOb2RlLnJlbW92ZV9wYXJlbnQgfmNoaWxkOm9sZF9jaGlsZCB+cGFyZW50IH5jaGlsZF9pbmRleDtcbiAgICAgICgqIFdlIGZvcmNlIFtvbGRfY2hpbGRdIHRvIHRlbXBvcmFyaWx5IGJlIG5lY2Vzc2FyeSBzbyB0aGF0IFthZGRfcGFyZW50XSBjYW4ndFxuICAgICAgICAgbWlzdGFrZW5seSB0aGluayBpdCBpcyB1bm5lY2Vzc2FyeSBhbmQgdHJhbnNpdGlvbiBpdCB0byBuZWNlc3NhcnkgKHdoaWNoIHdvdWxkXG4gICAgICAgICBhZGQgZHVwbGljYXRlIGVkZ2VzIGFuZCBicmVhayB0aGluZ3MgaG9ycmlibHkpLiAqKVxuICAgICAgb2xkX2NoaWxkLmZvcmNlX25lY2Vzc2FyeSA8LSB0cnVlO1xuICAgICAgYWRkX3BhcmVudCB+Y2hpbGQ6bmV3X2NoaWxkIH5wYXJlbnQgfmNoaWxkX2luZGV4O1xuICAgICAgb2xkX2NoaWxkLmZvcmNlX25lY2Vzc2FyeSA8LSBmYWxzZTtcbiAgICAgICgqIFdlIFtjaGVja19pZl91bm5lY2Vzc2FyeV0gYWZ0ZXIgW2FkZF9wYXJlbnRdLCBzbyB0aGF0IHdlIGRvbid0IHVubmVjZXNzYXJpbHlcbiAgICAgICAgIHRyYW5zaXRpb24gbm9kZXMgZnJvbSBuZWNlc3NhcnkgdG8gdW5uZWNlc3NhcnkgYW5kIHRoZW4gYmFjayBhZ2Fpbi4gKilcbiAgICAgIGNoZWNrX2lmX3VubmVjZXNzYXJ5IG9sZF9jaGlsZCkpXG47O1xuXG5sZXQgYWRkX2FsYXJtIGNsb2NrIH5hdCBhbGFybV92YWx1ZSA9XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChUaW1lX25zLiggPiApIGF0IChub3cgY2xvY2spKTtcbiAgVGltaW5nX3doZWVsLmFkZCBjbG9jay50aW1pbmdfd2hlZWwgfmF0IGFsYXJtX3ZhbHVlXG47O1xuXG5sZXQgcmVjIHJlY29tcHV0ZSA6IHR5cGUgYS4gYSBOb2RlLnQgLT4gdW5pdCA9XG4gIGZ1biBub2RlIC0+XG4gIGxldCB0ID0gbm9kZS5zdGF0ZSBpblxuICBpZiBkZWJ1Z1xuICB0aGVuIChcbiAgICB0Lm9ubHlfaW5fZGVidWcuY3VycmVudGx5X3J1bm5pbmdfbm9kZSA8LSBTb21lIChUIG5vZGUpO1xuICAgIHQub25seV9pbl9kZWJ1Zy5leHBlcnRfbm9kZXNfY3JlYXRlZF9ieV9jdXJyZW50X25vZGUgPC0gW10pO1xuICB0Lm51bV9ub2Rlc19yZWNvbXB1dGVkIDwtIHQubnVtX25vZGVzX3JlY29tcHV0ZWQgKyAxO1xuICBub2RlLnJlY29tcHV0ZWRfYXQgPC0gdC5zdGFiaWxpemF0aW9uX251bTtcbiAgbWF0Y2ggbm9kZS5raW5kIHdpdGhcbiAgfCBBcnJheV9mb2xkIGFycmF5X2ZvbGQgLT4gbWF5YmVfY2hhbmdlX3ZhbHVlIG5vZGUgKEFycmF5X2ZvbGQuY29tcHV0ZSBhcnJheV9mb2xkKVxuICB8IEF0IHsgYXQ7IGNsb2NrOyBfIH0gLT5cbiAgICAoKiBJdCBpcyBhIGJ1ZyBpZiB3ZSB0cnkgdG8gY29tcHV0ZSBhbiBbQXRdIG5vZGUgYWZ0ZXIgW2F0XS4gIFthZHZhbmNlX2Nsb2NrXSB3YXNcbiAgICAgICBzdXBwb3NlZCB0byBjb252ZXJ0IGl0IHRvIGEgW0NvbnN0XSBhdCB0aGUgYXBwcm9wcmlhdGUgdGltZS4gKilcbiAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoVGltZV9ucy4oID4gKSBhdCAobm93IGNsb2NrKSk7XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlIG5vZGUgQmVmb3JlXG4gIHwgQXRfaW50ZXJ2YWxzIF8gLT4gbWF5YmVfY2hhbmdlX3ZhbHVlIG5vZGUgKClcbiAgfCBCaW5kX2xoc19jaGFuZ2VcbiAgICAgICh7IG1haW5cbiAgICAgICA7IGZcbiAgICAgICA7IGxoc1xuICAgICAgIDsgcmhzX3Njb3BlXG4gICAgICAgOyByaHMgPSBvbGRfcmhzXG4gICAgICAgOyBhbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHMgPSBvbGRfYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzXG4gICAgICAgOyBfXG4gICAgICAgfSBhcyBiaW5kKSAtPlxuICAgICgqIFdlIGNsZWFyIFthbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHNdIHNvIGl0IHdpbGwgaG9sZCBqdXN0IHRoZSBub2RlcyBjcmVhdGVkIGJ5XG4gICAgICAgdGhpcyBjYWxsIHRvIFtmXS4gKilcbiAgICBiaW5kLmFsbF9ub2Rlc19jcmVhdGVkX29uX3JocyA8LSBVb3B0Lm5vbmU7XG4gICAgbGV0IHJocyA9IHJ1bl93aXRoX3Njb3BlIHQgcmhzX3Njb3BlIH5mOihmdW4gKCkgLT4gZiAoTm9kZS52YWx1ZV9leG4gbGhzKSkgaW5cbiAgICBiaW5kLnJocyA8LSBVb3B0LnNvbWUgcmhzO1xuICAgICgqIEFudGljaXBhdGUgd2hhdCBbbWF5YmVfY2hhbmdlX3ZhbHVlXSB3aWxsIGRvLCB0byBtYWtlIHN1cmUgQmluZF9tYWluIGlzIHN0YWxlXG4gICAgICAgcmlnaHQgYXdheS4gVGhpcyB3YXksIGlmIHRoZSBuZXcgY2hpbGQgaXMgaW52YWxpZCwgd2UnbGwgc2F0aXNmeSB0aGUgaW52YXJpYW50XG4gICAgICAgc2F5aW5nIHRoYXQgW25lZWRzX3RvX2JlX2NvbXB1dGVkIGJpbmRfbWFpbl0gaW4gW3Byb3BhZ2F0ZV9pbnZhbGlkaXR5XSAqKVxuICAgIG5vZGUuY2hhbmdlZF9hdCA8LSB0LnN0YWJpbGl6YXRpb25fbnVtO1xuICAgIGNoYW5nZV9jaGlsZFxuICAgICAgfnBhcmVudDptYWluXG4gICAgICB+b2xkX2NoaWxkOm9sZF9yaHNcbiAgICAgIH5uZXdfY2hpbGQ6cmhzXG4gICAgICB+Y2hpbGRfaW5kZXg6S2luZC5iaW5kX3Joc19jaGlsZF9pbmRleDtcbiAgICBpZiBVb3B0LmlzX3NvbWUgb2xkX3Joc1xuICAgIHRoZW4gKFxuICAgICAgKCogV2UgaW52YWxpZGF0ZSBhZnRlciBbY2hhbmdlX2NoaWxkXSwgYmVjYXVzZSBpbnZhbGlkYXRpb24gY2hhbmdlcyB0aGUgW2tpbmRdIG9mXG4gICAgICAgICBub2RlcyB0byBbSW52YWxpZF0sIHdoaWNoIG1lYW5zIHRoYXQgd2UgY2FuIG5vIGxvbmdlciB2aXNpdCB0aGVpciBjaGlsZHJlbi5cbiAgICAgICAgIEFsc28sIHRoZSBbb2xkX3Joc10gbm9kZXMgYXJlIHR5cGljYWxseSBtYWRlIHVubmVjZXNzYXJ5IGJ5IFtjaGFuZ2VfY2hpbGRdLCBhbmRcbiAgICAgICAgIHNvIGJ5IGludmFsaWRhdGluZyBhZnRlcndhcmRzLCB3ZSB3aWxsIG5vdCB3YXN0ZSB0aW1lIGFkZGluZyB0aGVtIHRvIHRoZVxuICAgICAgICAgcmVjb21wdXRlIGhlYXAgYW5kIHRoZW4gcmVtb3ZpbmcgdGhlbS4gKilcbiAgICAgIGlmIHQuYmluZF9saHNfY2hhbmdlX3Nob3VsZF9pbnZhbGlkYXRlX3Joc1xuICAgICAgdGhlbiBpbnZhbGlkYXRlX25vZGVzX2NyZWF0ZWRfb25fcmhzIG9sZF9hbGxfbm9kZXNfY3JlYXRlZF9vbl9yaHNcbiAgICAgIGVsc2VcbiAgICAgICAgcmVzY29wZV9ub2Rlc19jcmVhdGVkX29uX3Joc1xuICAgICAgICAgIHRcbiAgICAgICAgICBvbGRfYWxsX25vZGVzX2NyZWF0ZWRfb25fcmhzXG4gICAgICAgICAgfm5ld19zY29wZTptYWluLmNyZWF0ZWRfaW47XG4gICAgICBwcm9wYWdhdGVfaW52YWxpZGl0eSB0KTtcbiAgICAoKiBbbm9kZV0gd2FzIHZhbGlkIGF0IHRoZSBzdGFydCBvZiB0aGUgW0JpbmRfbGhzX2NoYW5nZV0gYnJhbmNoLCBhbmQgaW52YWxpZGF0aW9uXG4gICAgICAgb25seSB2aXNpdHMgaGlnaGVyIG5vZGVzLCBzbyBbbm9kZV0gaXMgc3RpbGwgdmFsaWQuICopXG4gICAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKE5vZGUuaXNfdmFsaWQgbm9kZSk7XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlIG5vZGUgKClcbiAgfCBCaW5kX21haW4geyByaHM7IF8gfSAtPiBjb3B5X2NoaWxkIH5wYXJlbnQ6bm9kZSB+Y2hpbGQ6KFVvcHQudmFsdWVfZXhuIHJocylcbiAgfCBDb25zdCBhIC0+IG1heWJlX2NoYW5nZV92YWx1ZSBub2RlIGFcbiAgfCBGcmVlemUgeyBjaGlsZDsgb25seV9mcmVlemVfd2hlbjsgXyB9IC0+XG4gICAgbGV0IHZhbHVlID0gTm9kZS52YWx1ZV9leG4gY2hpbGQgaW5cbiAgICBpZiBvbmx5X2ZyZWV6ZV93aGVuIHZhbHVlXG4gICAgdGhlbiAoXG4gICAgICByZW1vdmVfY2hpbGRyZW4gbm9kZTtcbiAgICAgIE5vZGUuc2V0X2tpbmQgbm9kZSAoQ29uc3QgdmFsdWUpO1xuICAgICAgaWYgTm9kZS5pc19uZWNlc3Nhcnkgbm9kZSB0aGVuIHNldF9oZWlnaHQgbm9kZSAwIGVsc2UgYmVjYW1lX3VubmVjZXNzYXJ5IG5vZGUpO1xuICAgIG1heWJlX2NoYW5nZV92YWx1ZSBub2RlIHZhbHVlXG4gIHwgSWZfdGVzdF9jaGFuZ2UgKHsgbWFpbjsgY3VycmVudF9icmFuY2g7IHRlc3Q7IHRoZW5fOyBlbHNlXzsgXyB9IGFzIGlmX3RoZW5fZWxzZSkgLT5cbiAgICBsZXQgZGVzaXJlZF9icmFuY2ggPSBpZiBOb2RlLnZhbHVlX2V4biB0ZXN0IHRoZW4gdGhlbl8gZWxzZSBlbHNlXyBpblxuICAgIGlmX3RoZW5fZWxzZS5jdXJyZW50X2JyYW5jaCA8LSBVb3B0LnNvbWUgZGVzaXJlZF9icmFuY2g7XG4gICAgKCogc2VlIHRoZSBjb21tZW50IGluIEJpbmRfbGhzX2NoYW5nZSAqKVxuICAgIG5vZGUuY2hhbmdlZF9hdCA8LSB0LnN0YWJpbGl6YXRpb25fbnVtO1xuICAgIGNoYW5nZV9jaGlsZFxuICAgICAgfnBhcmVudDptYWluXG4gICAgICB+b2xkX2NoaWxkOmN1cnJlbnRfYnJhbmNoXG4gICAgICB+bmV3X2NoaWxkOmRlc2lyZWRfYnJhbmNoXG4gICAgICB+Y2hpbGRfaW5kZXg6S2luZC5pZl9icmFuY2hfY2hpbGRfaW5kZXg7XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlIG5vZGUgKClcbiAgfCBJZl90aGVuX2Vsc2UgeyBjdXJyZW50X2JyYW5jaDsgXyB9IC0+XG4gICAgY29weV9jaGlsZCB+cGFyZW50Om5vZGUgfmNoaWxkOihVb3B0LnZhbHVlX2V4biBjdXJyZW50X2JyYW5jaClcbiAgfCBJbnZhbGlkIC0+XG4gICAgKCogV2UgbmV2ZXIgaGF2ZSBpbnZhbGlkIG5vZGVzIGluIHRoZSByZWNvbXB1dGUgaGVhcDsgdGhleSBhcmUgbmV2ZXIgc3RhbGUuICopXG4gICAgYXNzZXJ0IGZhbHNlXG4gIHwgSm9pbl9saHNfY2hhbmdlICh7IGxoczsgbWFpbjsgcmhzID0gb2xkX3JoczsgXyB9IGFzIGpvaW4pIC0+XG4gICAgbGV0IHJocyA9IE5vZGUudmFsdWVfZXhuIGxocyBpblxuICAgIGpvaW4ucmhzIDwtIFVvcHQuc29tZSByaHM7XG4gICAgKCogc2VlIHRoZSBjb21tZW50IGluIEJpbmRfbGhzX2NoYW5nZSAqKVxuICAgIG5vZGUuY2hhbmdlZF9hdCA8LSB0LnN0YWJpbGl6YXRpb25fbnVtO1xuICAgIGNoYW5nZV9jaGlsZFxuICAgICAgfnBhcmVudDptYWluXG4gICAgICB+b2xkX2NoaWxkOm9sZF9yaHNcbiAgICAgIH5uZXdfY2hpbGQ6cmhzXG4gICAgICB+Y2hpbGRfaW5kZXg6S2luZC5qb2luX3Joc19jaGlsZF9pbmRleDtcbiAgICBtYXliZV9jaGFuZ2VfdmFsdWUgbm9kZSAoKVxuICB8IEpvaW5fbWFpbiB7IHJoczsgXyB9IC0+IGNvcHlfY2hpbGQgfnBhcmVudDpub2RlIH5jaGlsZDooVW9wdC52YWx1ZV9leG4gcmhzKVxuICB8IE1hcCAoZiwgbjEpIC0+IG1heWJlX2NoYW5nZV92YWx1ZSBub2RlIChmIChOb2RlLnZhbHVlX2V4biBuMSkpXG4gIHwgU25hcHNob3QgeyBhdDsgYmVmb3JlOyBjbG9jazsgXyB9IC0+XG4gICAgKCogSXQgaXMgYSBidWcgaWYgd2UgdHJ5IHRvIGNvbXB1dGUgYSBbU25hcHNob3RdIGFuZCB0aGUgYWxhcm0gc2hvdWxkIGhhdmUgZmlyZWQuXG4gICAgICAgW2FkdmFuY2VfY2xvY2tdIHdhcyBzdXBwb3NlZCB0byBjb252ZXJ0IGl0IHRvIGEgW0ZyZWV6ZV0gYXQgdGhlIGFwcHJvcHJpYXRlXG4gICAgICAgdGltZS4gKilcbiAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoVGltZV9ucy4oID4gKSBhdCAobm93IGNsb2NrKSk7XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlIG5vZGUgYmVmb3JlXG4gIHwgU3RlcF9mdW5jdGlvbiAoeyBjaGlsZDsgY2xvY2s7IF8gfSBhcyBzdGVwX2Z1bmN0aW9uX25vZGUpIC0+XG4gICAgaWYgVW9wdC5pc19zb21lIGNoaWxkXG4gICAgdGhlbiAoXG4gICAgICBsZXQgY2hpbGQgPSBVb3B0LnZhbHVlX2V4biBjaGlsZCBpblxuICAgICAgaWYgU3RhYmlsaXphdGlvbl9udW0uY29tcGFyZVxuICAgICAgICAgICBjaGlsZC5jaGFuZ2VkX2F0XG4gICAgICAgICAgIHN0ZXBfZnVuY3Rpb25fbm9kZS5leHRyYWN0ZWRfc3RlcF9mdW5jdGlvbl9mcm9tX2NoaWxkX2F0XG4gICAgICAgICA+IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBzdGVwX2Z1bmN0aW9uX25vZGUuZXh0cmFjdGVkX3N0ZXBfZnVuY3Rpb25fZnJvbV9jaGlsZF9hdCA8LSBjaGlsZC5jaGFuZ2VkX2F0O1xuICAgICAgICByZW1vdmVfYWxhcm0gY2xvY2sgc3RlcF9mdW5jdGlvbl9ub2RlLmFsYXJtO1xuICAgICAgICBsZXQgc3RlcF9mdW5jdGlvbiA9IE5vZGUudmFsdWVfZXhuIGNoaWxkIGluXG4gICAgICAgIHN0ZXBfZnVuY3Rpb25fbm9kZS52YWx1ZSA8LSBVb3B0LnNvbWUgKFN0ZXBfZnVuY3Rpb24uaW5pdCBzdGVwX2Z1bmN0aW9uKTtcbiAgICAgICAgc3RlcF9mdW5jdGlvbl9ub2RlLnVwY29taW5nX3N0ZXBzIDwtIFN0ZXBfZnVuY3Rpb24uc3RlcHMgc3RlcF9mdW5jdGlvbjtcbiAgICAgICAgKCogSWYgdGhlIGNoaWxkIGlzIGEgY29uc3RhbnQsIHdlIGRyb3Agb3VyIHJlZmVyZW5jZSB0byBpdCwgdG8gYXZvaWQgaG9sZGluZyBvbiB0b1xuICAgICAgICAgICB0aGUgZW50aXJlIHN0ZXAgZnVuY3Rpb24uICopXG4gICAgICAgIGlmIE5vZGUuaXNfY29uc3QgY2hpbGRcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgcmVtb3ZlX2NoaWxkcmVuIG5vZGU7XG4gICAgICAgICAgc3RlcF9mdW5jdGlvbl9ub2RlLmNoaWxkIDwtIFVvcHQubm9uZTtcbiAgICAgICAgICBzZXRfaGVpZ2h0IG5vZGUgKFNjb3BlLmhlaWdodCBub2RlLmNyZWF0ZWRfaW4gKyAxKSkpKTtcbiAgICBTdGVwX2Z1bmN0aW9uX25vZGUuYWR2YW5jZSBzdGVwX2Z1bmN0aW9uX25vZGUgfnRvXzoobm93IGNsb2NrKTtcbiAgICBsZXQgc3RlcF9mdW5jdGlvbl92YWx1ZSA9IFVvcHQudmFsdWVfZXhuIHN0ZXBfZnVuY3Rpb25fbm9kZS52YWx1ZSBpblxuICAgIChtYXRjaCBTZXF1ZW5jZS5oZCBzdGVwX2Z1bmN0aW9uX25vZGUudXBjb21pbmdfc3RlcHMgd2l0aFxuICAgICB8IE5vbmUgLT4gaWYgVW9wdC5pc19ub25lIGNoaWxkIHRoZW4gTm9kZS5zZXRfa2luZCBub2RlIChDb25zdCBzdGVwX2Z1bmN0aW9uX3ZhbHVlKVxuICAgICB8IFNvbWUgKGF0LCBfKSAtPlxuICAgICAgIHN0ZXBfZnVuY3Rpb25fbm9kZS5hbGFybSA8LSBhZGRfYWxhcm0gY2xvY2sgfmF0IHN0ZXBfZnVuY3Rpb25fbm9kZS5hbGFybV92YWx1ZSk7XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlIG5vZGUgc3RlcF9mdW5jdGlvbl92YWx1ZVxuICB8IFVub3JkZXJlZF9hcnJheV9mb2xkIHUgLT4gbWF5YmVfY2hhbmdlX3ZhbHVlIG5vZGUgKFVub3JkZXJlZF9hcnJheV9mb2xkLmNvbXB1dGUgdSlcbiAgfCBVbmluaXRpYWxpemVkIC0+IGFzc2VydCBmYWxzZVxuICB8IFZhciB2YXIgLT4gbWF5YmVfY2hhbmdlX3ZhbHVlIG5vZGUgdmFyLnZhbHVlXG4gIHwgTWFwMiAoZiwgbjEsIG4yKSAtPlxuICAgIG1heWJlX2NoYW5nZV92YWx1ZSBub2RlIChmIChOb2RlLnZhbHVlX2V4biBuMSkgKE5vZGUudmFsdWVfZXhuIG4yKSlcbiAgfCBNYXAzIChmLCBuMSwgbjIsIG4zKSAtPlxuICAgIG1heWJlX2NoYW5nZV92YWx1ZVxuICAgICAgbm9kZVxuICAgICAgKGYgKE5vZGUudmFsdWVfZXhuIG4xKSAoTm9kZS52YWx1ZV9leG4gbjIpIChOb2RlLnZhbHVlX2V4biBuMykpXG4gIHwgTWFwNCAoZiwgbjEsIG4yLCBuMywgbjQpIC0+XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlXG4gICAgICBub2RlXG4gICAgICAoZiAoTm9kZS52YWx1ZV9leG4gbjEpIChOb2RlLnZhbHVlX2V4biBuMikgKE5vZGUudmFsdWVfZXhuIG4zKSAoTm9kZS52YWx1ZV9leG4gbjQpKVxuICB8IE1hcDUgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSkgLT5cbiAgICBtYXliZV9jaGFuZ2VfdmFsdWVcbiAgICAgIG5vZGVcbiAgICAgIChmXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjIpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjMpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjQpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjUpKVxuICB8IE1hcDYgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYpIC0+XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlXG4gICAgICBub2RlXG4gICAgICAoZlxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4yKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4zKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG40KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG41KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG42KSlcbiAgfCBNYXA3IChmLCBuMSwgbjIsIG4zLCBuNCwgbjUsIG42LCBuNykgLT5cbiAgICBtYXliZV9jaGFuZ2VfdmFsdWVcbiAgICAgIG5vZGVcbiAgICAgIChmXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjIpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjMpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjQpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjUpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjYpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjcpKVxuICB8IE1hcDggKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43LCBuOCkgLT5cbiAgICBtYXliZV9jaGFuZ2VfdmFsdWVcbiAgICAgIG5vZGVcbiAgICAgIChmXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjIpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjMpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjQpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjUpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjYpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjcpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjgpKVxuICB8IE1hcDkgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43LCBuOCwgbjkpIC0+XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlXG4gICAgICBub2RlXG4gICAgICAoZlxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4yKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4zKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG40KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG41KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG42KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG43KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG44KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG45KSlcbiAgfCBNYXAxMCAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNiwgbjcsIG44LCBuOSwgbjEwKSAtPlxuICAgIG1heWJlX2NoYW5nZV92YWx1ZVxuICAgICAgbm9kZVxuICAgICAgKGZcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMylcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNylcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuOClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuOSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTApKVxuICB8IE1hcDExIChmLCBuMSwgbjIsIG4zLCBuNCwgbjUsIG42LCBuNywgbjgsIG45LCBuMTAsIG4xMSkgLT5cbiAgICBtYXliZV9jaGFuZ2VfdmFsdWVcbiAgICAgIG5vZGVcbiAgICAgIChmXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjIpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjMpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjQpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjUpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjYpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjcpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjgpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjkpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEwKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xMSkpXG4gIHwgTWFwMTIgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43LCBuOCwgbjksIG4xMCwgbjExLCBuMTIpIC0+XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlXG4gICAgICBub2RlXG4gICAgICAoZlxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4yKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4zKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG40KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG41KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG42KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG43KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG44KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG45KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xMClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTEpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEyKSlcbiAgfCBNYXAxMyAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNiwgbjcsIG44LCBuOSwgbjEwLCBuMTEsIG4xMiwgbjEzKSAtPlxuICAgIG1heWJlX2NoYW5nZV92YWx1ZVxuICAgICAgbm9kZVxuICAgICAgKGZcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMylcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuNylcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuOClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuOSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTApXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjExKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xMilcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTMpKVxuICB8IE1hcDE0IChmLCBuMSwgbjIsIG4zLCBuNCwgbjUsIG42LCBuNywgbjgsIG45LCBuMTAsIG4xMSwgbjEyLCBuMTMsIG4xNCkgLT5cbiAgICBtYXliZV9jaGFuZ2VfdmFsdWVcbiAgICAgIG5vZGVcbiAgICAgIChmXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjIpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjMpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjQpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjUpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjYpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjcpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjgpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjkpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEwKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xMSlcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTIpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEzKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xNCkpXG4gIHwgTWFwMTUgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43LCBuOCwgbjksIG4xMCwgbjExLCBuMTIsIG4xMywgbjE0LCBuMTUpIC0+XG4gICAgbWF5YmVfY2hhbmdlX3ZhbHVlXG4gICAgICBub2RlXG4gICAgICAoZlxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4yKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4zKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG40KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG41KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG42KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG43KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG44KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG45KVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xMClcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTEpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjEyKVxuICAgICAgICAgKE5vZGUudmFsdWVfZXhuIG4xMylcbiAgICAgICAgIChOb2RlLnZhbHVlX2V4biBuMTQpXG4gICAgICAgICAoTm9kZS52YWx1ZV9leG4gbjE1KSlcbiAgfCBFeHBlcnQgZXhwZXJ0IC0+XG4gICAgKG1hdGNoIEV4cGVydC5iZWZvcmVfbWFpbl9jb21wdXRhdGlvbiBleHBlcnQgd2l0aFxuICAgICB8IGBJbnZhbGlkIC0+XG4gICAgICAgaW52YWxpZGF0ZV9ub2RlIG5vZGU7XG4gICAgICAgcHJvcGFnYXRlX2ludmFsaWRpdHkgdFxuICAgICB8IGBPayAtPiBtYXliZV9jaGFuZ2VfdmFsdWUgbm9kZSAoZXhwZXJ0LmYgKCkpKVxuXG5hbmQgY29weV9jaGlsZCA6IHR5cGUgYS4gcGFyZW50OmEgTm9kZS50IC0+IGNoaWxkOmEgTm9kZS50IC0+IHVuaXQgPVxuICBmdW4gfnBhcmVudCB+Y2hpbGQgLT5cbiAgaWYgTm9kZS5pc192YWxpZCBjaGlsZFxuICB0aGVuIG1heWJlX2NoYW5nZV92YWx1ZSBwYXJlbnQgKE5vZGUudmFsdWVfZXhuIGNoaWxkKVxuICBlbHNlIChcbiAgICBpbnZhbGlkYXRlX25vZGUgcGFyZW50O1xuICAgIHByb3BhZ2F0ZV9pbnZhbGlkaXR5IHBhcmVudC5zdGF0ZSlcblxuYW5kIG1heWJlX2NoYW5nZV92YWx1ZSA6IHR5cGUgYS4gYSBOb2RlLnQgLT4gYSAtPiB1bml0ID1cbiAgZnVuIG5vZGUgbmV3X3ZhbHVlIC0+XG4gIGxldCB0ID0gbm9kZS5zdGF0ZSBpblxuICBsZXQgb2xkX3ZhbHVlX29wdCA9IG5vZGUudmFsdWVfb3B0IGluXG4gIGlmIFVvcHQuaXNfbm9uZSBvbGRfdmFsdWVfb3B0XG4gICAgIHx8IG5vdFxuICAgICAgICAgIChDdXRvZmYuc2hvdWxkX2N1dG9mZlxuICAgICAgICAgICAgIG5vZGUuY3V0b2ZmXG4gICAgICAgICAgICAgfm9sZF92YWx1ZTooVW9wdC51bnNhZmVfdmFsdWUgb2xkX3ZhbHVlX29wdClcbiAgICAgICAgICAgICB+bmV3X3ZhbHVlKVxuICB0aGVuIChcbiAgICBub2RlLnZhbHVlX29wdCA8LSBVb3B0LnNvbWUgbmV3X3ZhbHVlO1xuICAgIG5vZGUuY2hhbmdlZF9hdCA8LSB0LnN0YWJpbGl6YXRpb25fbnVtO1xuICAgIHQubnVtX25vZGVzX2NoYW5nZWQgPC0gdC5udW1fbm9kZXNfY2hhbmdlZCArIDE7XG4gICAgaWYgbm9kZS5udW1fb25fdXBkYXRlX2hhbmRsZXJzID4gMFxuICAgIHRoZW4gKFxuICAgICAgbm9kZS5vbGRfdmFsdWVfb3B0IDwtIG9sZF92YWx1ZV9vcHQ7XG4gICAgICBoYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiBub2RlKTtcbiAgICBpZiBub2RlLm51bV9wYXJlbnRzID49IDFcbiAgICB0aGVuIChcbiAgICAgIGZvciBwYXJlbnRfaW5kZXggPSAxIHRvIG5vZGUubnVtX3BhcmVudHMgLSAxIGRvXG4gICAgICAgIGxldCAoVCBwYXJlbnQpID1cbiAgICAgICAgICBVb3B0LnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS5nZXQgbm9kZS5wYXJlbnQxX2FuZF9iZXlvbmQgKHBhcmVudF9pbmRleCAtIDEpKVxuICAgICAgICBpblxuICAgICAgICAobWF0Y2ggcGFyZW50LmtpbmQgd2l0aFxuICAgICAgICAgfCBFeHBlcnQgZXhwZXJ0IC0+XG4gICAgICAgICAgIGxldCBjaGlsZF9pbmRleCA9IG5vZGUubXlfY2hpbGRfaW5kZXhfaW5fcGFyZW50X2F0X2luZGV4LihwYXJlbnRfaW5kZXgpIGluXG4gICAgICAgICAgIEV4cGVydC5ydW5fZWRnZV9jYWxsYmFjayB+Y2hpbGRfaW5kZXggZXhwZXJ0XG4gICAgICAgICB8IFVub3JkZXJlZF9hcnJheV9mb2xkIHUgLT5cbiAgICAgICAgICAgVW5vcmRlcmVkX2FycmF5X2ZvbGQuY2hpbGRfY2hhbmdlZFxuICAgICAgICAgICAgIHVcbiAgICAgICAgICAgICB+Y2hpbGQ6bm9kZVxuICAgICAgICAgICAgIH5jaGlsZF9pbmRleDpub2RlLm15X2NoaWxkX2luZGV4X2luX3BhcmVudF9hdF9pbmRleC4ocGFyZW50X2luZGV4KVxuICAgICAgICAgICAgIH5vbGRfdmFsdWVfb3B0XG4gICAgICAgICAgICAgfm5ld192YWx1ZVxuICAgICAgICAgfCBfIC0+ICgpKTtcbiAgICAgICAgaWYgZGVidWcgdGhlbiBhc3NlcnQgKE5vZGUubmVlZHNfdG9fYmVfY29tcHV0ZWQgcGFyZW50KTtcbiAgICAgICAgKCogV2UgZG9uJ3QgZG8gdGhlIFtjYW5fcmVjb21wdXRlX25vd10gb3B0aW1pemF0aW9uLiAgU2luY2UgbW9zdCBub2RlcyBvbmx5IGhhdmVcbiAgICAgICAgICAgb25lIHBhcmVudCwgaXQgaXMgbm90IHByb2JhYmx5IG5vdCBhIGJpZyBsb3NzLiAgSWYgd2UgZGlkIGl0IGFueXdheSwgd2UnZFxuICAgICAgICAgICBoYXZlIHRvIGJlIGNhcmVmdWwsIGJlY2F1c2Ugd2hpbGUgd2UgaXRlcmF0ZSBvdmVyIHRoZSBsaXN0IG9mIHBhcmVudHMsIHdlXG4gICAgICAgICAgIHdvdWxkIGV4ZWN1dGUgdGhlbSwgYW5kIGluIHBhcnRpY3VsYXIgd2UgY2FuIGV4ZWN1dGUgbGhzLWNoYW5nZSBub2RlcyB3aG8gY2FuXG4gICAgICAgICAgIGNoYW5nZSB0aGUgc3RydWN0dXJlIG9mIHRoZSBsaXN0IG9mIHBhcmVudHMgd2UgaXRlcmF0ZSBvbi4gIFRoaW5rIGFib3V0OlxuXG4gICAgICAgICAgIHtbXG4gICAgICAgICAgICAgbGhzID4+PSBmdW4gYiAtPiBpZiBiIHRoZW4gbGhzID4+fCBGbi5pZCBlbHNlIGNvbnN0IGJcbiAgICAgICAgICAgXX1cblxuICAgICAgICAgICBJZiB0aGUgb3B0aW1pemF0aW9uIGtpY2tzIGluIHdoZW4gd2UgcHJvcGFnYXRlIGNoYW5nZSB0byB0aGUgcGFyZW50cyBvZiBbbGhzXVxuICAgICAgICAgICAod2hpY2ggY2hhbmdlcyBmcm9tIFt0cnVlXSB0byBbZmFsc2VdKSwgd2UgY291bGQgZXhlY3V0ZSB0aGUgW2xocy1jaGFuZ2VdXG4gICAgICAgICAgIGZpcnN0LCB3aGljaCB3b3VsZCBtYWtlIGRpc2Nvbm5lY3QgdGhlIFttYXBdIG5vZGUgZnJvbSBbbGhzXS4gIEFuZCB0aGVuIHdlXG4gICAgICAgICAgIHdvdWxkIGV4ZWN1dGUgdGhlIHNlY29uZCBjaGlsZCBvZiB0aGUgW2xoc10sIHdoaWNoIGRvZXNuJ3QgZXhpc3QgYW55bW9yZSBhbmRcbiAgICAgICAgICAgaW5jcmVtZW50YWwgd291bGQgc2VnZmF1bHQgKHRoZXJlIG1heSBiZSBhIGxlc3MgbmFpdmUgd2F5IG9mIG1ha2luZyB0aGlzIHdvcmtcbiAgICAgICAgICAgdGhvdWdoKS4gKilcbiAgICAgICAgaWYgbm90IChOb2RlLmlzX2luX3JlY29tcHV0ZV9oZWFwIHBhcmVudClcbiAgICAgICAgdGhlbiBSZWNvbXB1dGVfaGVhcC5hZGQgdC5yZWNvbXB1dGVfaGVhcCBwYXJlbnRcbiAgICAgIGRvbmU7XG4gICAgICBsZXQgKFQgcGFyZW50KSA9IFVvcHQudmFsdWVfZXhuIG5vZGUucGFyZW50MCBpblxuICAgICAgKG1hdGNoIHBhcmVudC5raW5kIHdpdGhcbiAgICAgICB8IEV4cGVydCBwIC0+XG4gICAgICAgICBsZXQgY2hpbGRfaW5kZXggPSBub2RlLm15X2NoaWxkX2luZGV4X2luX3BhcmVudF9hdF9pbmRleC4oMCkgaW5cbiAgICAgICAgIEV4cGVydC5ydW5fZWRnZV9jYWxsYmFjayB+Y2hpbGRfaW5kZXggcFxuICAgICAgIHwgVW5vcmRlcmVkX2FycmF5X2ZvbGQgdSAtPlxuICAgICAgICAgVW5vcmRlcmVkX2FycmF5X2ZvbGQuY2hpbGRfY2hhbmdlZFxuICAgICAgICAgICB1XG4gICAgICAgICAgIH5jaGlsZDpub2RlXG4gICAgICAgICAgIH5jaGlsZF9pbmRleDpub2RlLm15X2NoaWxkX2luZGV4X2luX3BhcmVudF9hdF9pbmRleC4oMClcbiAgICAgICAgICAgfm9sZF92YWx1ZV9vcHRcbiAgICAgICAgICAgfm5ld192YWx1ZVxuICAgICAgIHwgXyAtPiAoKSk7XG4gICAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoTm9kZS5uZWVkc190b19iZV9jb21wdXRlZCBwYXJlbnQpO1xuICAgICAgaWYgbm90IChOb2RlLmlzX2luX3JlY29tcHV0ZV9oZWFwIHBhcmVudClcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgY2FuX3JlY29tcHV0ZV9ub3cgPVxuICAgICAgICAgIG1hdGNoIHBhcmVudC5raW5kIHdpdGhcbiAgICAgICAgICB8IFVuaW5pdGlhbGl6ZWQgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgKCogVGhlc2Ugbm9kZXMgYXJlbid0IHBhcmVudHMuICopXG4gICAgICAgICAgfCBBdCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgQXRfaW50ZXJ2YWxzIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBDb25zdCBfIHwgSW52YWxpZCB8IFNuYXBzaG90IF8gfCBWYXIgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAoKiBUaGVzZSBub2RlcyBoYXZlIG1vcmUgdGhhbiBvbmUgY2hpbGQuICopXG4gICAgICAgICAgfCBBcnJheV9mb2xkIF9cbiAgICAgICAgICB8IE1hcDIgX1xuICAgICAgICAgIHwgTWFwMyBfXG4gICAgICAgICAgfCBNYXA0IF9cbiAgICAgICAgICB8IE1hcDUgX1xuICAgICAgICAgIHwgTWFwNiBfXG4gICAgICAgICAgfCBNYXA3IF9cbiAgICAgICAgICB8IE1hcDggX1xuICAgICAgICAgIHwgTWFwOSBfXG4gICAgICAgICAgfCBNYXAxMCBfXG4gICAgICAgICAgfCBNYXAxMSBfXG4gICAgICAgICAgfCBNYXAxMiBfXG4gICAgICAgICAgfCBNYXAxMyBfXG4gICAgICAgICAgfCBNYXAxNCBfXG4gICAgICAgICAgfCBNYXAxNSBfXG4gICAgICAgICAgfCBVbm9yZGVyZWRfYXJyYXlfZm9sZCBfXG4gICAgICAgICAgfCBFeHBlcnQgXyAtPiBmYWxzZVxuICAgICAgICAgICgqIFdlIGNhbiBpbW1lZGlhdGVseSByZWNvbXB1dGUgW3BhcmVudF0gaWYgbm8gb3RoZXIgbm9kZSBuZWVkcyB0byBiZSBzdGFibGVcbiAgICAgICAgICAgICBiZWZvcmUgY29tcHV0aW5nIGl0LiAgSWYgW3BhcmVudF0gaGFzIGEgc2luZ2xlIGNoaWxkIChpLmUuIFtub2RlXSksIHRoZW5cbiAgICAgICAgICAgICB0aGlzIGFtb3VudHMgdG8gY2hlY2tpbmcgdGhhdCBbcGFyZW50XSB3b24ndCBiZSBpbnZhbGlkYXRlZCwgaS5lLiB0aGF0XG4gICAgICAgICAgICAgW3BhcmVudF0ncyBzY29wZSBoYXMgYWxyZWFkeSBzdGFiaWxpemVkLiAqKVxuICAgICAgICAgIHwgQmluZF9saHNfY2hhbmdlIF8gLT4gbm9kZS5oZWlnaHQgPiBTY29wZS5oZWlnaHQgcGFyZW50LmNyZWF0ZWRfaW5cbiAgICAgICAgICB8IEZyZWV6ZSBfIC0+IG5vZGUuaGVpZ2h0ID4gU2NvcGUuaGVpZ2h0IHBhcmVudC5jcmVhdGVkX2luXG4gICAgICAgICAgfCBJZl90ZXN0X2NoYW5nZSBfIC0+IG5vZGUuaGVpZ2h0ID4gU2NvcGUuaGVpZ2h0IHBhcmVudC5jcmVhdGVkX2luXG4gICAgICAgICAgfCBKb2luX2xoc19jaGFuZ2UgXyAtPiBub2RlLmhlaWdodCA+IFNjb3BlLmhlaWdodCBwYXJlbnQuY3JlYXRlZF9pblxuICAgICAgICAgIHwgTWFwIF8gLT4gbm9kZS5oZWlnaHQgPiBTY29wZS5oZWlnaHQgcGFyZW50LmNyZWF0ZWRfaW5cbiAgICAgICAgICB8IFN0ZXBfZnVuY3Rpb24gXyAtPiBub2RlLmhlaWdodCA+IFNjb3BlLmhlaWdodCBwYXJlbnQuY3JlYXRlZF9pblxuICAgICAgICAgICgqIEZvciB0aGVzZSwgd2UgbmVlZCB0byBjaGVjayB0aGF0IHRoZSBcIl9jaGFuZ2VcIiBjaGlsZCBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICAgICAgICAgZXZhbHVhdGVkIChpZiBuZWVkZWQpLiAgSWYgc28sIHRoaXMgYWxzbyBpbXBsaWVzOlxuXG4gICAgICAgICAgICAge1tcbiAgICAgICAgICAgICAgIG5vZGUuaGVpZ2h0ID4gU2NvcGUuaGVpZ2h0IHBhcmVudC5jcmVhdGVkX2luXG4gICAgICAgICAgICAgXX0gKilcbiAgICAgICAgICB8IEJpbmRfbWFpbiBiIC0+IG5vZGUuaGVpZ2h0ID4gYi5saHNfY2hhbmdlLmhlaWdodFxuICAgICAgICAgIHwgSWZfdGhlbl9lbHNlIGkgLT4gbm9kZS5oZWlnaHQgPiBpLnRlc3RfY2hhbmdlLmhlaWdodFxuICAgICAgICAgIHwgSm9pbl9tYWluIGogLT4gbm9kZS5oZWlnaHQgPiBqLmxoc19jaGFuZ2UuaGVpZ2h0XG4gICAgICAgIGluXG4gICAgICAgIGlmIGNhbl9yZWNvbXB1dGVfbm93XG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHQubnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWN0bHlfYmVjYXVzZV9vbmVfY2hpbGRcbiAgICAgICAgICAgIDwtIHQubnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWN0bHlfYmVjYXVzZV9vbmVfY2hpbGQgKyAxO1xuICAgICAgICAgIHJlY29tcHV0ZSBwYXJlbnQpXG4gICAgICAgIGVsc2UgaWYgcGFyZW50LmhlaWdodCA8PSBSZWNvbXB1dGVfaGVhcC5taW5faGVpZ2h0IHQucmVjb21wdXRlX2hlYXBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgKCogSWYgW3BhcmVudC5oZWlnaHRdIGlzIFs8PV0gdGhlIGhlaWdodCBvZiBhbGwgbm9kZXMgaW4gdGhlIHJlY29tcHV0ZSBoZWFwXG4gICAgICAgICAgICAgKHBvc3NpYmx5IGJlY2F1c2UgdGhlIHJlY29tcHV0ZSBoZWFwIGlzIGVtcHR5KSwgdGhlbiB3ZSBjYW4gcmVjb21wdXRlXG4gICAgICAgICAgICAgW3BhcmVudF0gaW1tZWRpYXRlbHkgYW5kIHNhdmUgYWRkaW5nIGl0IHRvIGFuZCB0aGVuIHJlbW92aW5nIGl0IGZyb20gdGhlXG4gICAgICAgICAgICAgcmVjb21wdXRlIGhlYXAuICopXG4gICAgICAgICAgdC5udW1fbm9kZXNfcmVjb21wdXRlZF9kaXJlY3RseV9iZWNhdXNlX21pbl9oZWlnaHRcbiAgICAgICAgICAgIDwtIHQubnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWN0bHlfYmVjYXVzZV9taW5faGVpZ2h0ICsgMTtcbiAgICAgICAgICByZWNvbXB1dGUgcGFyZW50KVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoTm9kZS5uZWVkc190b19iZV9jb21wdXRlZCBwYXJlbnQpO1xuICAgICAgICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChub3QgKE5vZGUuaXNfaW5fcmVjb21wdXRlX2hlYXAgcGFyZW50KSk7XG4gICAgICAgICAgUmVjb21wdXRlX2hlYXAuYWRkIHQucmVjb21wdXRlX2hlYXAgcGFyZW50KSkpKTtcbiAgaWYgZGVidWcgdGhlbiBpbnZhcmlhbnQgdFxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSByZWNvbXB1dGVfZmlyc3Rfbm9kZV90aGF0X2lzX25lY2Vzc2FyeSByID1cbiAgbGV0IChUIG5vZGUpID0gUmVjb21wdXRlX2hlYXAucmVtb3ZlX21pbiByIGluXG4gIGlmIGRlYnVnICYmIG5vdCAoTm9kZS5uZWVkc190b19iZV9jb21wdXRlZCBub2RlKVxuICB0aGVuXG4gICAgZmFpbHdpdGhzXG4gICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICBcIm5vZGUgdW5leHBlY3RlZGx5IGRvZXMgbm90IG5lZWQgdG8gYmUgY29tcHV0ZWRcIlxuICAgICAgbm9kZVxuICAgICAgWyVzZXhwX29mOiBfIE5vZGUudF07XG4gIHJlY29tcHV0ZSBub2RlXG47O1xuXG5sZXQgdW5saW5rX2Rpc2FsbG93ZWRfb2JzZXJ2ZXJzIHQgPVxuICB3aGlsZSBTdGFjay5sZW5ndGggdC5kaXNhbGxvd2VkX29ic2VydmVycyA+IDAgZG9cbiAgICBsZXQgcGFja2VkID0gU3RhY2sucG9wX2V4biB0LmRpc2FsbG93ZWRfb2JzZXJ2ZXJzIGluXG4gICAgbGV0IChUIGludGVybmFsX29ic2VydmVyKSA9IHBhY2tlZCBpblxuICAgIGlmIGRlYnVnXG4gICAgdGhlblxuICAgICAgYXNzZXJ0IChcbiAgICAgICAgbWF0Y2ggaW50ZXJuYWxfb2JzZXJ2ZXIuc3RhdGUgd2l0aFxuICAgICAgICB8IERpc2FsbG93ZWQgLT4gdHJ1ZVxuICAgICAgICB8IF8gLT4gZmFsc2UpO1xuICAgIGludGVybmFsX29ic2VydmVyLnN0YXRlIDwtIFVubGlua2VkO1xuICAgIGxldCAoVCBhbGxfb2JzZXJ2ZXJzKSA9IFVvcHQudmFsdWVfZXhuIHQuYWxsX29ic2VydmVycyBpblxuICAgIGlmIEludGVybmFsX29ic2VydmVyLnNhbWUgaW50ZXJuYWxfb2JzZXJ2ZXIgYWxsX29ic2VydmVyc1xuICAgIHRoZW4gdC5hbGxfb2JzZXJ2ZXJzIDwtIGludGVybmFsX29ic2VydmVyLm5leHRfaW5fYWxsO1xuICAgIEludGVybmFsX29ic2VydmVyLnVubGluayBpbnRlcm5hbF9vYnNlcnZlcjtcbiAgICBjaGVja19pZl91bm5lY2Vzc2FyeSBpbnRlcm5hbF9vYnNlcnZlci5vYnNlcnZpbmdcbiAgZG9uZVxuOztcblxubGV0IGRpc2FsbG93X2Z1dHVyZV91c2UgaW50ZXJuYWxfb2JzZXJ2ZXIgPVxuICBsZXQgdCA9IEludGVybmFsX29ic2VydmVyLmluY3Jfc3RhdGUgaW50ZXJuYWxfb2JzZXJ2ZXIgaW5cbiAgbWF0Y2ggaW50ZXJuYWxfb2JzZXJ2ZXIuc3RhdGUgd2l0aFxuICB8IERpc2FsbG93ZWQgfCBVbmxpbmtlZCAtPiAoKVxuICB8IENyZWF0ZWQgLT5cbiAgICB0Lm51bV9hY3RpdmVfb2JzZXJ2ZXJzIDwtIHQubnVtX2FjdGl2ZV9vYnNlcnZlcnMgLSAxO1xuICAgIGludGVybmFsX29ic2VydmVyLnN0YXRlIDwtIFVubGlua2VkO1xuICAgIGludGVybmFsX29ic2VydmVyLm9uX3VwZGF0ZV9oYW5kbGVycyA8LSBbXVxuICB8IEluX3VzZSAtPlxuICAgIHQubnVtX2FjdGl2ZV9vYnNlcnZlcnMgPC0gdC5udW1fYWN0aXZlX29ic2VydmVycyAtIDE7XG4gICAgaW50ZXJuYWxfb2JzZXJ2ZXIuc3RhdGUgPC0gRGlzYWxsb3dlZDtcbiAgICBTdGFjay5wdXNoIHQuZGlzYWxsb3dlZF9vYnNlcnZlcnMgKFQgaW50ZXJuYWxfb2JzZXJ2ZXIpXG47O1xuXG5sZXQgZGlzYWxsb3dfZmluYWxpemVkX29ic2VydmVycyB0ID1cbiAgd2hpbGUgVGhyZWFkX3NhZmVfcXVldWUubGVuZ3RoIHQuZmluYWxpemVkX29ic2VydmVycyA+IDAgZG9cbiAgICBsZXQgKFQgaW50ZXJuYWxfb2JzZXJ2ZXIpID0gVGhyZWFkX3NhZmVfcXVldWUuZGVxdWV1ZV9leG4gdC5maW5hbGl6ZWRfb2JzZXJ2ZXJzIGluXG4gICAgaWYgTGlzdC5pc19lbXB0eSBpbnRlcm5hbF9vYnNlcnZlci5vbl91cGRhdGVfaGFuZGxlcnNcbiAgICB0aGVuIGRpc2FsbG93X2Z1dHVyZV91c2UgaW50ZXJuYWxfb2JzZXJ2ZXJcbiAgZG9uZVxuOztcblxubGV0IG9ic2VydmVyX2ZpbmFsaXplciB0ID1cbiAgc3RhZ2UgKGZ1biBvYnNlcnZlciAtPlxuICAgIGxldCBpbnRlcm5hbF9vYnNlcnZlciA9ICFvYnNlcnZlciBpblxuICAgIFRocmVhZF9zYWZlX3F1ZXVlLmVucXVldWUgdC5maW5hbGl6ZWRfb2JzZXJ2ZXJzIChUIGludGVybmFsX29ic2VydmVyKSlcbjs7XG5cbmxldCBjcmVhdGVfb2JzZXJ2ZXIgPyhzaG91bGRfZmluYWxpemUgPSB0cnVlKSAob2JzZXJ2aW5nIDogXyBOb2RlLnQpID1cbiAgbGV0IHQgPSBvYnNlcnZpbmcuc3RhdGUgaW5cbiAgbGV0IGludGVybmFsX29ic2VydmVyIDogXyBJbnRlcm5hbF9vYnNlcnZlci50ID1cbiAgICB7IHN0YXRlID0gQ3JlYXRlZFxuICAgIDsgb2JzZXJ2aW5nXG4gICAgOyBvbl91cGRhdGVfaGFuZGxlcnMgPSBbXVxuICAgIDsgcHJldl9pbl9hbGwgPSBVb3B0Lm5vbmVcbiAgICA7IG5leHRfaW5fYWxsID0gVW9wdC5ub25lXG4gICAgOyBwcmV2X2luX29ic2VydmluZyA9IFVvcHQubm9uZVxuICAgIDsgbmV4dF9pbl9vYnNlcnZpbmcgPSBVb3B0Lm5vbmVcbiAgICB9XG4gIGluXG4gIFN0YWNrLnB1c2ggdC5uZXdfb2JzZXJ2ZXJzIChUIGludGVybmFsX29ic2VydmVyKTtcbiAgbGV0IG9ic2VydmVyID0gcmVmIGludGVybmFsX29ic2VydmVyIGluXG4gIGlmIHNob3VsZF9maW5hbGl6ZVxuICB0aGVuIEdjLkV4cGVydC5hZGRfZmluYWxpemVyX2V4biBvYnNlcnZlciAodW5zdGFnZSAob2JzZXJ2ZXJfZmluYWxpemVyIHQpKTtcbiAgdC5udW1fYWN0aXZlX29ic2VydmVycyA8LSB0Lm51bV9hY3RpdmVfb2JzZXJ2ZXJzICsgMTtcbiAgb2JzZXJ2ZXJcbjs7XG5cbmxldCBhZGRfbmV3X29ic2VydmVycyB0ID1cbiAgd2hpbGUgU3RhY2subGVuZ3RoIHQubmV3X29ic2VydmVycyA+IDAgZG9cbiAgICBsZXQgcGFja2VkID0gU3RhY2sucG9wX2V4biB0Lm5ld19vYnNlcnZlcnMgaW5cbiAgICBsZXQgbW9kdWxlIFBhY2tlZCA9IEludGVybmFsX29ic2VydmVyLlBhY2tlZCBpblxuICAgIGxldCAoVCBpbnRlcm5hbF9vYnNlcnZlcikgPSBwYWNrZWQgaW5cbiAgICBtYXRjaCBpbnRlcm5hbF9vYnNlcnZlci5zdGF0ZSB3aXRoXG4gICAgfCBJbl91c2UgfCBEaXNhbGxvd2VkIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgVW5saW5rZWQgLT4gKClcbiAgICB8IENyZWF0ZWQgLT5cbiAgICAgIGludGVybmFsX29ic2VydmVyLnN0YXRlIDwtIEluX3VzZTtcbiAgICAgIGxldCBvbGRfYWxsX29ic2VydmVycyA9IHQuYWxsX29ic2VydmVycyBpblxuICAgICAgaWYgVW9wdC5pc19zb21lIG9sZF9hbGxfb2JzZXJ2ZXJzXG4gICAgICB0aGVuIChcbiAgICAgICAgaW50ZXJuYWxfb2JzZXJ2ZXIubmV4dF9pbl9hbGwgPC0gb2xkX2FsbF9vYnNlcnZlcnM7XG4gICAgICAgIFBhY2tlZC5zZXRfcHJldl9pbl9hbGwgKFVvcHQudW5zYWZlX3ZhbHVlIG9sZF9hbGxfb2JzZXJ2ZXJzKSAoVW9wdC5zb21lIHBhY2tlZCkpO1xuICAgICAgdC5hbGxfb2JzZXJ2ZXJzIDwtIFVvcHQuc29tZSBwYWNrZWQ7XG4gICAgICBsZXQgb2JzZXJ2aW5nID0gaW50ZXJuYWxfb2JzZXJ2ZXIub2JzZXJ2aW5nIGluXG4gICAgICBsZXQgd2FzX25lY2Vzc2FyeSA9IE5vZGUuaXNfbmVjZXNzYXJ5IG9ic2VydmluZyBpblxuICAgICAgb2JzZXJ2aW5nLm51bV9vbl91cGRhdGVfaGFuZGxlcnNcbiAgICAgICAgPC0gb2JzZXJ2aW5nLm51bV9vbl91cGRhdGVfaGFuZGxlcnNcbiAgICAgICAgICAgKyBMaXN0Lmxlbmd0aCBpbnRlcm5hbF9vYnNlcnZlci5vbl91cGRhdGVfaGFuZGxlcnM7XG4gICAgICBsZXQgb2xkX29ic2VydmVycyA9IG9ic2VydmluZy5vYnNlcnZlcnMgaW5cbiAgICAgIGlmIFVvcHQuaXNfc29tZSBvbGRfb2JzZXJ2ZXJzXG4gICAgICB0aGVuIChcbiAgICAgICAgaW50ZXJuYWxfb2JzZXJ2ZXIubmV4dF9pbl9vYnNlcnZpbmcgPC0gb2xkX29ic2VydmVycztcbiAgICAgICAgKFVvcHQudW5zYWZlX3ZhbHVlIG9sZF9vYnNlcnZlcnMpLnByZXZfaW5fb2JzZXJ2aW5nIDwtIFVvcHQuc29tZSBpbnRlcm5hbF9vYnNlcnZlcik7XG4gICAgICBvYnNlcnZpbmcub2JzZXJ2ZXJzIDwtIFVvcHQuc29tZSBpbnRlcm5hbF9vYnNlcnZlcjtcbiAgICAgICgqIEJ5IGFkZGluZyBbaW50ZXJuYWxfb2JzZXJ2ZXJdIHRvIFtvYnNlcnZpbmcub2JzZXJ2ZXJzXSwgd2UgbWF5IGhhdmUgYWRkZWRcbiAgICAgICAgIG9uLXVwZGF0ZSBoYW5kbGVycyB0byBbb2JzZXJ2aW5nXS4gIFdlIG5lZWQgdG8gaGFuZGxlIFtvYnNlcnZpbmddIGFmdGVyIHRoaXNcbiAgICAgICAgIHN0YWJpbGl6YXRpb24gdG8gZ2l2ZSB0aG9zZSBoYW5kbGVycyBhIGNoYW5jZSB0byBydW4uICopXG4gICAgICBoYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiBvYnNlcnZpbmc7XG4gICAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoTm9kZS5pc19uZWNlc3Nhcnkgb2JzZXJ2aW5nKTtcbiAgICAgIGlmIG5vdCB3YXNfbmVjZXNzYXJ5IHRoZW4gYmVjYW1lX25lY2Vzc2FyeSBvYnNlcnZpbmdcbiAgZG9uZVxuOztcblxubGV0IG9ic2VydmVyX3ZhbHVlX2V4biBvYnNlcnZlciA9XG4gIGxldCB0ID0gT2JzZXJ2ZXIuaW5jcl9zdGF0ZSBvYnNlcnZlciBpblxuICBtYXRjaCB0LnN0YXR1cyB3aXRoXG4gIHwgTm90X3N0YWJpbGl6aW5nIHwgUnVubmluZ19vbl91cGRhdGVfaGFuZGxlcnMgLT4gT2JzZXJ2ZXIudmFsdWVfZXhuIG9ic2VydmVyXG4gIHwgU3RhYmlsaXplX3ByZXZpb3VzbHlfcmFpc2VkIHJhaXNlZF9leG4gLT5cbiAgICBSYWlzZWRfZXhuLnJlcmFpc2Vfd2l0aF9tZXNzYWdlXG4gICAgICByYWlzZWRfZXhuXG4gICAgICBcIk9ic2VydmVyLnZhbHVlX2V4biBjYWxsZWQgYWZ0ZXIgc3RhYmlsaXplIHByZXZpb3VzbHkgcmFpc2VkXCJcbiAgfCBTdGFiaWxpemluZyAtPlxuICAgIGZhaWx3aXRoc1xuICAgICAgfmhlcmU6WyVoZXJlXVxuICAgICAgXCJPYnNlcnZlci52YWx1ZV9leG4gY2FsbGVkIGR1cmluZyBzdGFiaWxpemF0aW9uXCJcbiAgICAgIG9ic2VydmVyXG4gICAgICBbJXNleHBfb2Y6IF8gT2JzZXJ2ZXIudF1cbjs7XG5cbmxldCBvYnNlcnZlcl92YWx1ZSBvYnNlcnZlciA9XG4gIHRyeSBPayAob2JzZXJ2ZXJfdmFsdWVfZXhuIG9ic2VydmVyKSB3aXRoXG4gIHwgZXhuIC0+IEVycm9yIChFcnJvci5vZl9leG4gZXhuKVxuOztcblxubGV0IG5vZGVfb25fdXBkYXRlICh0eXBlIGEpIChub2RlIDogYSBOb2RlLnQpIH5mID1cbiAgbGV0IHQgPSBub2RlLnN0YXRlIGluXG4gIE5vZGUub25fdXBkYXRlIG5vZGUgKE9uX3VwZGF0ZV9oYW5kbGVyLmNyZWF0ZSBmIH5hdDp0LnN0YWJpbGl6YXRpb25fbnVtKTtcbiAgaGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb24gbm9kZVxuOztcblxubGV0IG9ic2VydmVyX29uX3VwZGF0ZV9leG4gb2JzZXJ2ZXIgfmYgPVxuICBsZXQgdCA9IE9ic2VydmVyLmluY3Jfc3RhdGUgb2JzZXJ2ZXIgaW5cbiAgT2JzZXJ2ZXIub25fdXBkYXRlX2V4biBvYnNlcnZlciAoT25fdXBkYXRlX2hhbmRsZXIuY3JlYXRlIGYgfmF0OnQuc3RhYmlsaXphdGlvbl9udW0pO1xuICBoYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiAoT2JzZXJ2ZXIub2JzZXJ2aW5nIG9ic2VydmVyKVxuOztcblxubGV0IHNldF92YXJfd2hpbGVfbm90X3N0YWJpbGl6aW5nIHZhciB2YWx1ZSA9XG4gIGxldCB0ID0gVmFyLmluY3Jfc3RhdGUgdmFyIGluXG4gIHQubnVtX3Zhcl9zZXRzIDwtIHQubnVtX3Zhcl9zZXRzICsgMTtcbiAgdmFyLnZhbHVlIDwtIHZhbHVlO1xuICBpZiBTdGFiaWxpemF0aW9uX251bS5jb21wYXJlIHZhci5zZXRfYXQgdC5zdGFiaWxpemF0aW9uX251bSA8IDBcbiAgdGhlbiAoXG4gICAgdmFyLnNldF9hdCA8LSB0LnN0YWJpbGl6YXRpb25fbnVtO1xuICAgIGxldCB3YXRjaCA9IHZhci53YXRjaCBpblxuICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLmlzX3N0YWxlIHdhdGNoKTtcbiAgICBpZiBOb2RlLmlzX25lY2Vzc2FyeSB3YXRjaCAmJiBub3QgKE5vZGUuaXNfaW5fcmVjb21wdXRlX2hlYXAgd2F0Y2gpXG4gICAgdGhlbiBSZWNvbXB1dGVfaGVhcC5hZGQgdC5yZWNvbXB1dGVfaGVhcCB3YXRjaClcbjs7XG5cbmxldCBzZXRfdmFyIHZhciB2YWx1ZSA9XG4gIGxldCB0ID0gVmFyLmluY3Jfc3RhdGUgdmFyIGluXG4gIG1hdGNoIHQuc3RhdHVzIHdpdGhcbiAgfCBSdW5uaW5nX29uX3VwZGF0ZV9oYW5kbGVycyB8IE5vdF9zdGFiaWxpemluZyAtPlxuICAgIHNldF92YXJfd2hpbGVfbm90X3N0YWJpbGl6aW5nIHZhciB2YWx1ZVxuICB8IFN0YWJpbGl6ZV9wcmV2aW91c2x5X3JhaXNlZCByYWlzZWRfZXhuIC0+XG4gICAgUmFpc2VkX2V4bi5yZXJhaXNlX3dpdGhfbWVzc2FnZVxuICAgICAgcmFpc2VkX2V4blxuICAgICAgXCJjYW5ub3Qgc2V0IHZhciAtLSBzdGFiaWxpemF0aW9uIHByZXZpb3VzbHkgcmFpc2VkXCJcbiAgfCBTdGFiaWxpemluZyAtPlxuICAgIGlmIFVvcHQuaXNfbm9uZSB2YXIudmFsdWVfc2V0X2R1cmluZ19zdGFiaWxpemF0aW9uXG4gICAgdGhlbiBTdGFjay5wdXNoIHQuc2V0X2R1cmluZ19zdGFiaWxpemF0aW9uIChUIHZhcik7XG4gICAgdmFyLnZhbHVlX3NldF9kdXJpbmdfc3RhYmlsaXphdGlvbiA8LSBVb3B0LnNvbWUgdmFsdWVcbjs7XG5cbmxldCByZWNsYWltX3NwYWNlX2luX3dlYWtfaGFzaHRibHMgdCA9XG4gIHdoaWxlIFRocmVhZF9zYWZlX3F1ZXVlLmxlbmd0aCB0LndlYWtfaGFzaHRibHMgPiAwIGRvXG4gICAgbGV0IChUIHdlYWtfaGFzaHRibCkgPSBUaHJlYWRfc2FmZV9xdWV1ZS5kZXF1ZXVlX2V4biB0LndlYWtfaGFzaHRibHMgaW5cbiAgICBXZWFrX2hhc2h0YmwucmVjbGFpbV9zcGFjZV9mb3Jfa2V5c193aXRoX3VudXNlZF9kYXRhIHdlYWtfaGFzaHRibFxuICBkb25lXG47O1xuXG5sZXQgc3RhYmlsaXplX3N0YXJ0IHQgPVxuICB0LnN0YXR1cyA8LSBTdGFiaWxpemluZztcbiAgZGlzYWxsb3dfZmluYWxpemVkX29ic2VydmVycyB0O1xuICAoKiBKdXN0IGxpa2UgZm9yIGJpbmRzLCB3ZSBhZGQgbmV3IG9ic2VydmVycyBiZWZvcmUgcmVtb3ZpbmcgZGlzYWxsb3dlZCBvYnNlcnZlcnMgdG9cbiAgICAgcG90ZW50aWFsbHkgYXZvaWQgc3dpdGNoaW5nIHRoZSBvYnNlcnZhYmlsaXR5IG9mIHNvbWUgbm9kZXMgYmFjayBhbmQgZm9ydGguICopXG4gIGFkZF9uZXdfb2JzZXJ2ZXJzIHQ7XG4gIHVubGlua19kaXNhbGxvd2VkX29ic2VydmVycyB0O1xuICBpZiBkZWJ1ZyB0aGVuIGludmFyaWFudCB0XG47O1xuXG5sZXQgc3RhYmlsaXplX2VuZCB0ID1cbiAgaWYgZGVidWdcbiAgdGhlbiAoXG4gICAgdC5vbmx5X2luX2RlYnVnLmN1cnJlbnRseV9ydW5uaW5nX25vZGUgPC0gTm9uZTtcbiAgICB0Lm9ubHlfaW5fZGVidWcuZXhwZXJ0X25vZGVzX2NyZWF0ZWRfYnlfY3VycmVudF9ub2RlIDwtIFtdKTtcbiAgKCogV2UgaW5jcmVtZW50IFt0LnN0YWJpbGl6YXRpb25fbnVtXSBiZWZvcmUgaGFuZGxpbmcgdmFyaWFibGVzIHNldCBkdXJpbmdcbiAgICAgc3RhYmlsaXphdGlvbiwgc28gdGhhdCB0aGV5IGFyZSB0cmVhdGVkIGFzIHNldCBkdXJpbmcgdGhlIG5ldyBzdGFiaWxpemF0aW9uIGN5Y2xlLlxuICAgICBBbHNvLCB3ZSBpbmNyZW1lbnQgYmVmb3JlIHJ1bm5pbmcgb24tdXBkYXRlIGhhbmRsZXJzLCB0byBhdm9pZCBydW5uaW5nIG9uIHVwZGF0ZVxuICAgICBoYW5kbGVycyBjcmVhdGVkIGR1cmluZyBvbiB1cGRhdGUgaGFuZGxlcnMuICopXG4gIHQuc3RhYmlsaXphdGlvbl9udW0gPC0gU3RhYmlsaXphdGlvbl9udW0uYWRkMSB0LnN0YWJpbGl6YXRpb25fbnVtO1xuICB3aGlsZSBub3QgKFN0YWNrLmlzX2VtcHR5IHQuc2V0X2R1cmluZ19zdGFiaWxpemF0aW9uKSBkb1xuICAgIGxldCAoVCB2YXIpID0gU3RhY2sucG9wX2V4biB0LnNldF9kdXJpbmdfc3RhYmlsaXphdGlvbiBpblxuICAgIGxldCB2YWx1ZSA9IFVvcHQudmFsdWVfZXhuIHZhci52YWx1ZV9zZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24gaW5cbiAgICB2YXIudmFsdWVfc2V0X2R1cmluZ19zdGFiaWxpemF0aW9uIDwtIFVvcHQubm9uZTtcbiAgICBzZXRfdmFyX3doaWxlX25vdF9zdGFiaWxpemluZyB2YXIgdmFsdWVcbiAgZG9uZTtcbiAgd2hpbGUgbm90IChTdGFjay5pc19lbXB0eSB0LmhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uKSBkb1xuICAgIGxldCAoVCBub2RlKSA9IFN0YWNrLnBvcF9leG4gdC5oYW5kbGVfYWZ0ZXJfc3RhYmlsaXphdGlvbiBpblxuICAgIG5vZGUuaXNfaW5faGFuZGxlX2FmdGVyX3N0YWJpbGl6YXRpb24gPC0gZmFsc2U7XG4gICAgbGV0IG9sZF92YWx1ZSA9IG5vZGUub2xkX3ZhbHVlX29wdCBpblxuICAgIG5vZGUub2xkX3ZhbHVlX29wdCA8LSBVb3B0Lm5vbmU7XG4gICAgbGV0IG5vZGVfdXBkYXRlIDogXyBOb2RlX3VwZGF0ZS50ID1cbiAgICAgIGlmIG5vdCAoTm9kZS5pc192YWxpZCBub2RlKVxuICAgICAgdGhlbiBJbnZhbGlkYXRlZFxuICAgICAgZWxzZSBpZiBub3QgKE5vZGUuaXNfbmVjZXNzYXJ5IG5vZGUpXG4gICAgICB0aGVuIFVubmVjZXNzYXJ5XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG5ld192YWx1ZSA9IFVvcHQudmFsdWVfZXhuIG5vZGUudmFsdWVfb3B0IGluXG4gICAgICAgIGlmIFVvcHQuaXNfbm9uZSBvbGRfdmFsdWVcbiAgICAgICAgdGhlbiBOZWNlc3NhcnkgbmV3X3ZhbHVlXG4gICAgICAgIGVsc2UgQ2hhbmdlZCAoVW9wdC51bnNhZmVfdmFsdWUgb2xkX3ZhbHVlLCBuZXdfdmFsdWUpKVxuICAgIGluXG4gICAgU3RhY2sucHVzaCB0LnJ1bl9vbl91cGRhdGVfaGFuZGxlcnMgKFQgKG5vZGUsIG5vZGVfdXBkYXRlKSlcbiAgZG9uZTtcbiAgdC5zdGF0dXMgPC0gUnVubmluZ19vbl91cGRhdGVfaGFuZGxlcnM7XG4gIGxldCBub3cgPSB0LnN0YWJpbGl6YXRpb25fbnVtIGluXG4gIHdoaWxlIG5vdCAoU3RhY2suaXNfZW1wdHkgdC5ydW5fb25fdXBkYXRlX2hhbmRsZXJzKSBkb1xuICAgIGxldCAoVCAobm9kZSwgbm9kZV91cGRhdGUpKSA9IFN0YWNrLnBvcF9leG4gdC5ydW5fb25fdXBkYXRlX2hhbmRsZXJzIGluXG4gICAgTm9kZS5ydW5fb25fdXBkYXRlX2hhbmRsZXJzIG5vZGUgbm9kZV91cGRhdGUgfm5vd1xuICBkb25lO1xuICB0LnN0YXR1cyA8LSBOb3Rfc3RhYmlsaXppbmc7XG4gIHJlY2xhaW1fc3BhY2VfaW5fd2Vha19oYXNodGJscyB0XG47O1xuXG5sZXQgcmFpc2VfZHVyaW5nX3N0YWJpbGl6YXRpb24gdCBleG4gPVxuICBsZXQgcmFpc2VkID0gUmFpc2VkX2V4bi5jcmVhdGUgZXhuIGluXG4gIHQuc3RhdHVzIDwtIFN0YWJpbGl6ZV9wcmV2aW91c2x5X3JhaXNlZCByYWlzZWQ7XG4gIFJhaXNlZF9leG4ucmVyYWlzZSByYWlzZWRcbjs7XG5cbmxldCBzdGFiaWxpemUgdCA9XG4gIGVuc3VyZV9ub3Rfc3RhYmlsaXppbmcgdCB+bmFtZTpcInN0YWJpbGl6ZVwiIH5hbGxvd19pbl91cGRhdGVfaGFuZGxlcjpmYWxzZTtcbiAgdHJ5XG4gICAgc3RhYmlsaXplX3N0YXJ0IHQ7XG4gICAgbGV0IHIgPSB0LnJlY29tcHV0ZV9oZWFwIGluXG4gICAgd2hpbGUgUmVjb21wdXRlX2hlYXAubGVuZ3RoIHIgPiAwIGRvXG4gICAgICByZWNvbXB1dGVfZmlyc3Rfbm9kZV90aGF0X2lzX25lY2Vzc2FyeSByXG4gICAgZG9uZTtcbiAgICBzdGFiaWxpemVfZW5kIHRcbiAgd2l0aFxuICB8IGV4biAtPiByYWlzZV9kdXJpbmdfc3RhYmlsaXphdGlvbiB0IGV4blxuOztcblxubW9kdWxlIFN0ZXBfcmVzdWx0ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBLZWVwX2dvaW5nXG4gICAgfCBEb25lXG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubGV0IGRvX29uZV9zdGVwX29mX3N0YWJpbGl6ZSB0IDogU3RlcF9yZXN1bHQudCA9XG4gIHRyeVxuICAgIG1hdGNoIHQuc3RhdHVzIHdpdGhcbiAgICB8IE5vdF9zdGFiaWxpemluZyAtPlxuICAgICAgc3RhYmlsaXplX3N0YXJ0IHQ7XG4gICAgICBLZWVwX2dvaW5nXG4gICAgfCBTdGFiaWxpemluZyAtPlxuICAgICAgbGV0IHIgPSB0LnJlY29tcHV0ZV9oZWFwIGluXG4gICAgICBpZiBSZWNvbXB1dGVfaGVhcC5sZW5ndGggciA+IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICByZWNvbXB1dGVfZmlyc3Rfbm9kZV90aGF0X2lzX25lY2Vzc2FyeSByO1xuICAgICAgICBLZWVwX2dvaW5nKVxuICAgICAgZWxzZSAoXG4gICAgICAgIHN0YWJpbGl6ZV9lbmQgdDtcbiAgICAgICAgRG9uZSlcbiAgICB8IFJ1bm5pbmdfb25fdXBkYXRlX2hhbmRsZXJzIHwgU3RhYmlsaXplX3ByZXZpb3VzbHlfcmFpc2VkIF8gLT5cbiAgICAgIGVuc3VyZV9ub3Rfc3RhYmlsaXppbmcgdCB+bmFtZTpcInN0ZXBcIiB+YWxsb3dfaW5fdXBkYXRlX2hhbmRsZXI6ZmFsc2U7XG4gICAgICBhc3NlcnQgZmFsc2VcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgIChtYXRjaCB0LnN0YXR1cyB3aXRoXG4gICAgIHwgU3RhYmlsaXplX3ByZXZpb3VzbHlfcmFpc2VkIF8gLT5cbiAgICAgICAoKiBJZiBzdGFiaWxpemF0aW9uIGhhcyBhbHJlYWR5IHJhaXNlZCwgdGhlbiBbZXhuXSBpcyBtZXJlbHkgYSBub3RpZmljYXRpb24gb2YgdGhpc1xuICAgICAgICAgIGZhY3QsIHJhdGhlciB0aGFuIHRoZSBvcmlnaW5hbCBleGNlcHRpb24gaXRzZWxmLiAgV2Ugc2hvdWxkIGp1c3QgcHJvcGFnYXRlIFtleG5dXG4gICAgICAgICAgZm9yd2FyZDsgY2FsbGluZyBbcmFpc2VfZHVyaW5nX3N0YWJpbGl6YXRpb25dIHdvdWxkIHN0b3JlIFtleG5dIGFzIHRoZSBleGNlcHRpb25cbiAgICAgICAgICB0aGF0IGluaXRpYWxseSByYWlzZWQgZHVyaW5nIHN0YWJpbGl6YXRpb24uICopXG4gICAgICAgcmFpc2UgZXhuXG4gICAgIHwgXyAtPiByYWlzZV9kdXJpbmdfc3RhYmlsaXphdGlvbiB0IGV4bilcbjs7XG5cbmxldCBjcmVhdGVfbm9kZV9pbiB0IGNyZWF0ZWRfaW4ga2luZCA9XG4gIHQubnVtX25vZGVzX2NyZWF0ZWQgPC0gdC5udW1fbm9kZXNfY3JlYXRlZCArIDE7XG4gIE5vZGUuY3JlYXRlIHQgY3JlYXRlZF9pbiBraW5kXG47O1xuXG5sZXQgY3JlYXRlX25vZGUgdCBraW5kID0gY3JlYXRlX25vZGVfaW4gdCB0LmN1cnJlbnRfc2NvcGUga2luZFxubGV0IGNyZWF0ZV9ub2RlX3RvcCB0IGtpbmQgPSBjcmVhdGVfbm9kZV9pbiB0IFNjb3BlLnRvcCBraW5kXG5cbmxldCBjcmVhdGVfdmFyIHQgPyh1c2VfY3VycmVudF9zY29wZSA9IGZhbHNlKSB2YWx1ZSA9XG4gIGxldCBzY29wZSA9IGlmIHVzZV9jdXJyZW50X3Njb3BlIHRoZW4gdC5jdXJyZW50X3Njb3BlIGVsc2UgU2NvcGUudG9wIGluXG4gIGxldCB3YXRjaCA9IGNyZWF0ZV9ub2RlX2luIHQgc2NvcGUgVW5pbml0aWFsaXplZCBpblxuICBsZXQgdmFyID1cbiAgICB7IFZhci52YWx1ZVxuICAgIDsgdmFsdWVfc2V0X2R1cmluZ19zdGFiaWxpemF0aW9uID0gVW9wdC5ub25lXG4gICAgOyBzZXRfYXQgPSB0LnN0YWJpbGl6YXRpb25fbnVtXG4gICAgOyB3YXRjaFxuICAgIH1cbiAgaW5cbiAgTm9kZS5zZXRfa2luZCB3YXRjaCAoVmFyIHZhcik7XG4gIHZhclxuOztcblxuKCogQSBbY29uc3RdIHZhbHVlIGNvdWxkIGNvbWUgZnJvbSB0aGUgcmlnaHQtaGFuZCBzaWRlIG9mIGFuIG91dGVyIGJpbmQuICBTbywgd2UgY3JlYXRlIGFcbiAgIFtjb25zdF0gbm9kZSBpbiB0aGUgY3VycmVudCBzY29wZSwgbm90IGluIFtTY29wZS50b3BdLiAqKVxubGV0IGNvbnN0IHQgYSA9IGNyZWF0ZV9ub2RlIHQgKENvbnN0IGEpXG5sZXQgbWFwIChuIDogXyBOb2RlLnQpIH5mID0gY3JlYXRlX25vZGUgbi5zdGF0ZSAoTWFwIChmLCBuKSlcbmxldCBtYXAyIChuMSA6IF8gTm9kZS50KSBuMiB+ZiA9IGNyZWF0ZV9ub2RlIG4xLnN0YXRlIChNYXAyIChmLCBuMSwgbjIpKVxuXG5sZXQgYm90aCAobjEgOiBfIE5vZGUudCkgKG4yIDogXyBOb2RlLnQpID1cbiAgbWF0Y2ggbjEsIG4yIHdpdGhcbiAgfCB7IGtpbmQgPSBDb25zdCBhOyBfIH0sIHsga2luZCA9IENvbnN0IGI7IF8gfSAtPiBjb25zdCBuMS5zdGF0ZSAoYSwgYilcbiAgfCBfIC0+IG1hcDIgbjEgbjIgfmY6VHVwbGUyLmNyZWF0ZVxuOztcblxubGV0IG1hcDMgKG4xIDogXyBOb2RlLnQpIG4yIG4zIH5mID0gY3JlYXRlX25vZGUgbjEuc3RhdGUgKE1hcDMgKGYsIG4xLCBuMiwgbjMpKVxubGV0IG1hcDQgKG4xIDogXyBOb2RlLnQpIG4yIG4zIG40IH5mID0gY3JlYXRlX25vZGUgbjEuc3RhdGUgKE1hcDQgKGYsIG4xLCBuMiwgbjMsIG40KSlcblxubGV0IG1hcDUgKG4xIDogXyBOb2RlLnQpIG4yIG4zIG40IG41IH5mID1cbiAgY3JlYXRlX25vZGUgbjEuc3RhdGUgKE1hcDUgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSkpXG47O1xuXG5sZXQgbWFwNiAobjEgOiBfIE5vZGUudCkgbjIgbjMgbjQgbjUgbjYgfmYgPVxuICBjcmVhdGVfbm9kZSBuMS5zdGF0ZSAoTWFwNiAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNikpXG47O1xuXG5sZXQgbWFwNyAobjEgOiBfIE5vZGUudCkgbjIgbjMgbjQgbjUgbjYgbjcgfmYgPVxuICBjcmVhdGVfbm9kZSBuMS5zdGF0ZSAoTWFwNyAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNiwgbjcpKVxuOztcblxubGV0IG1hcDggKG4xIDogXyBOb2RlLnQpIG4yIG4zIG40IG41IG42IG43IG44IH5mID1cbiAgY3JlYXRlX25vZGUgbjEuc3RhdGUgKE1hcDggKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43LCBuOCkpXG47O1xuXG5sZXQgbWFwOSAobjEgOiBfIE5vZGUudCkgbjIgbjMgbjQgbjUgbjYgbjcgbjggbjkgfmYgPVxuICBjcmVhdGVfbm9kZSBuMS5zdGF0ZSAoTWFwOSAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNiwgbjcsIG44LCBuOSkpXG47O1xuXG5sZXQgbWFwMTAgKG4xIDogXyBOb2RlLnQpIG4yIG4zIG40IG41IG42IG43IG44IG45IG4xMCB+ZiA9XG4gIGNyZWF0ZV9ub2RlIG4xLnN0YXRlIChNYXAxMCAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNiwgbjcsIG44LCBuOSwgbjEwKSlcbjs7XG5cbmxldCBtYXAxMSAobjEgOiBfIE5vZGUudCkgbjIgbjMgbjQgbjUgbjYgbjcgbjggbjkgbjEwIG4xMSB+ZiA9XG4gIGNyZWF0ZV9ub2RlIG4xLnN0YXRlIChNYXAxMSAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNiwgbjcsIG44LCBuOSwgbjEwLCBuMTEpKVxuOztcblxubGV0IG1hcDEyIChuMSA6IF8gTm9kZS50KSBuMiBuMyBuNCBuNSBuNiBuNyBuOCBuOSBuMTAgbjExIG4xMiB+ZiA9XG4gIGNyZWF0ZV9ub2RlIG4xLnN0YXRlIChNYXAxMiAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNiwgbjcsIG44LCBuOSwgbjEwLCBuMTEsIG4xMikpXG47O1xuXG5sZXQgbWFwMTMgKG4xIDogXyBOb2RlLnQpIG4yIG4zIG40IG41IG42IG43IG44IG45IG4xMCBuMTEgbjEyIG4xMyB+ZiA9XG4gIGNyZWF0ZV9ub2RlIG4xLnN0YXRlIChNYXAxMyAoZiwgbjEsIG4yLCBuMywgbjQsIG41LCBuNiwgbjcsIG44LCBuOSwgbjEwLCBuMTEsIG4xMiwgbjEzKSlcbjs7XG5cbmxldCBtYXAxNCAobjEgOiBfIE5vZGUudCkgbjIgbjMgbjQgbjUgbjYgbjcgbjggbjkgbjEwIG4xMSBuMTIgbjEzIG4xNCB+ZiA9XG4gIGNyZWF0ZV9ub2RlXG4gICAgbjEuc3RhdGVcbiAgICAoTWFwMTQgKGYsIG4xLCBuMiwgbjMsIG40LCBuNSwgbjYsIG43LCBuOCwgbjksIG4xMCwgbjExLCBuMTIsIG4xMywgbjE0KSlcbjs7XG5cbmxldCBtYXAxNSAobjEgOiBfIE5vZGUudCkgbjIgbjMgbjQgbjUgbjYgbjcgbjggbjkgbjEwIG4xMSBuMTIgbjEzIG4xNCBuMTUgfmYgPVxuICBjcmVhdGVfbm9kZVxuICAgIG4xLnN0YXRlXG4gICAgKE1hcDE1IChmLCBuMSwgbjIsIG4zLCBuNCwgbjUsIG42LCBuNywgbjgsIG45LCBuMTAsIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjE1KSlcbjs7XG5cbmxldCBwcmVzZXJ2ZV9jdXRvZmYgfihpbnB1dCA6IF8gTm9kZS50KSB+b3V0cHV0ID1cbiAgTm9kZS5zZXRfY3V0b2ZmXG4gICAgb3V0cHV0XG4gICAgKEN1dG9mZi5jcmVhdGUgKGZ1biB+b2xkX3ZhbHVlOl8gfm5ld192YWx1ZTpfIC0+XG4gICAgICAgU3RhYmlsaXphdGlvbl9udW0uZXF1YWwgaW5wdXQuY2hhbmdlZF9hdCBvdXRwdXQuY2hhbmdlZF9hdCkpXG47O1xuXG5sZXQgZGVwZW5kX29uIGlucHV0IH5kZXBlbmRfb24gPVxuICBsZXQgb3V0cHV0ID0gbWFwMiBpbnB1dCBkZXBlbmRfb24gfmY6KGZ1biBhIF8gLT4gYSkgaW5cbiAgcHJlc2VydmVfY3V0b2ZmIH5pbnB1dCB+b3V0cHV0O1xuICBvdXRwdXRcbjs7XG5cbmxldCBuZWNlc3NhcnlfaWZfYWxpdmUgaW5wdXQgPVxuICAoKiBJZiBbb3V0cHV0XSBpcyBhbGl2ZSwgdGhlbiBbb2JzZXJ2ZXJdIGlzIGFsaXZlLCB0aGVuIFtpbnB1dF0gaXMgbmVjZXNzYXJ5LiAgSWZcbiAgICAgW291dHB1dF0gaXMgdW5uZWNlc3NhcnksIHRoZW4gW291dHB1dF0gaXMgbm90IGEgcGFyZW50IG9mIFtpbnB1dF0sIGFuZCB0aHVzXG4gICAgIFtvdXRwdXRdJ3MgbGl2ZW5lc3MgaXMgZGVwZW5kZW50IHNvbGVseSBvbiB1c2VyIGNvZGUuICBBbmQgaW4gcGFydGljdWxhciwgaWYgW291dHB1dF1cbiAgICAgZGllcywgdGhlbiBbb2JzZXJ2ZXJdIHdpbGwgYmUgZmluYWxpemVkLCBhbmQgdGhlbiB1cG9uIHRoZSBuZXh0IHN0YWJpbGl6YXRpb24sXG4gICAgIFtpbnB1dF0gd2lsbCBiZWNvbWUgdW5uZWNlc3NhcnkgKGF0IGxlYXN0IHdpdGggcmVzcGVjdCB0byBbb3V0cHV0XSkuICopXG4gIGxldCBvYnNlcnZlciA9IGNyZWF0ZV9vYnNlcnZlciBpbnB1dCBpblxuICBsZXQgb3V0cHV0ID1cbiAgICBtYXAgaW5wdXQgfmY6KGZ1biBhIC0+XG4gICAgICBHYy5rZWVwX2FsaXZlIG9ic2VydmVyO1xuICAgICAgYSlcbiAgaW5cbiAgcHJlc2VydmVfY3V0b2ZmIH5pbnB1dCB+b3V0cHV0O1xuICBvdXRwdXRcbjs7XG5cbmxldCBiaW5kIChsaHMgOiBfIE5vZGUudCkgfmYgPVxuICBsZXQgdCA9IGxocy5zdGF0ZSBpblxuICBsZXQgbGhzX2NoYW5nZSA9IGNyZWF0ZV9ub2RlIHQgVW5pbml0aWFsaXplZCBpblxuICBsZXQgbWFpbiA9IGNyZWF0ZV9ub2RlIHQgVW5pbml0aWFsaXplZCBpblxuICBsZXQgYmluZCA9XG4gICAgeyBCaW5kLm1haW5cbiAgICA7IGZcbiAgICA7IGxoc1xuICAgIDsgbGhzX2NoYW5nZVxuICAgIDsgcmhzID0gVW9wdC5ub25lXG4gICAgOyByaHNfc2NvcGUgPSBTY29wZS50b3BcbiAgICA7IGFsbF9ub2Rlc19jcmVhdGVkX29uX3JocyA9IFVvcHQubm9uZVxuICAgIH1cbiAgaW5cbiAgKCogV2Ugc2V0IFtsaHNfY2hhbmdlXSB0byBuZXZlciBjdXRvZmYgc28gdGhhdCB3aGVuZXZlciBbbGhzXSBjaGFuZ2VzLCBbbWFpbl0gaXNcbiAgICAgcmVjb21wdXRlZC4gIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBjYXNlcyB3aGVyZSBbZl0gcmV0dXJucyBhbiBleGlzdGluZyBzdGFibGVcbiAgICAgbm9kZSwgaW4gd2hpY2ggY2FzZSB0aGUgW2xoc19jaGFuZ2VdIHdvdWxkIGJlIHRoZSBvbmx5IHRoaW5nIGNhdXNpbmcgW21haW5dIHRvIGJlXG4gICAgIHN0YWxlLiAqKVxuICBOb2RlLnNldF9jdXRvZmYgbGhzX2NoYW5nZSBDdXRvZmYubmV2ZXI7XG4gIGJpbmQucmhzX3Njb3BlIDwtIEJpbmQgYmluZDtcbiAgTm9kZS5zZXRfa2luZCBsaHNfY2hhbmdlIChCaW5kX2xoc19jaGFuZ2UgYmluZCk7XG4gIE5vZGUuc2V0X2tpbmQgbWFpbiAoQmluZF9tYWluIGJpbmQpO1xuICBtYWluXG47O1xuXG5sZXQgYmluZDIgbjEgbjIgfmYgPVxuICBiaW5kIChtYXAyIG4xIG4yIH5mOihmdW4gdjEgdjIgLT4gdjEsIHYyKSkgfmY6KGZ1biAodjEsIHYyKSAtPiBmIHYxIHYyKVxuOztcblxubGV0IGJpbmQzIG4xIG4yIG4zIH5mID1cbiAgYmluZCAobWFwMyBuMSBuMiBuMyB+ZjooZnVuIHYxIHYyIHYzIC0+IHYxLCB2MiwgdjMpKSB+ZjooZnVuICh2MSwgdjIsIHYzKSAtPiBmIHYxIHYyIHYzKVxuOztcblxubGV0IGJpbmQ0IG4xIG4yIG4zIG40IH5mID1cbiAgYmluZFxuICAgIChtYXA0IG4xIG4yIG4zIG40IH5mOihmdW4gdjEgdjIgdjMgdjQgLT4gdjEsIHYyLCB2MywgdjQpKVxuICAgIH5mOihmdW4gKHYxLCB2MiwgdjMsIHY0KSAtPiBmIHYxIHYyIHYzIHY0KVxuOztcblxubGV0IGpvaW4gKGxocyA6IF8gTm9kZS50KSA9XG4gIGxldCB0ID0gbGhzLnN0YXRlIGluXG4gIGxldCBsaHNfY2hhbmdlID0gY3JlYXRlX25vZGUgdCBVbmluaXRpYWxpemVkIGluXG4gIGxldCBtYWluID0gY3JlYXRlX25vZGUgdCBVbmluaXRpYWxpemVkIGluXG4gIGxldCBqb2luID0geyBKb2luLmxoczsgbGhzX2NoYW5nZTsgcmhzID0gVW9wdC5ub25lOyBtYWluIH0gaW5cbiAgTm9kZS5zZXRfY3V0b2ZmIGxoc19jaGFuZ2UgQ3V0b2ZmLm5ldmVyO1xuICBOb2RlLnNldF9raW5kIGxoc19jaGFuZ2UgKEpvaW5fbGhzX2NoYW5nZSBqb2luKTtcbiAgTm9kZS5zZXRfa2luZCBtYWluIChKb2luX21haW4gam9pbik7XG4gIG1haW5cbjs7XG5cbmxldCBpZl8gKHRlc3QgOiBfIE5vZGUudCkgfnRoZW5fIH5lbHNlXyA9XG4gIGxldCB0ID0gdGVzdC5zdGF0ZSBpblxuICBsZXQgdGVzdF9jaGFuZ2UgPSBjcmVhdGVfbm9kZSB0IFVuaW5pdGlhbGl6ZWQgaW5cbiAgbGV0IG1haW4gPSBjcmVhdGVfbm9kZSB0IFVuaW5pdGlhbGl6ZWQgaW5cbiAgbGV0IGlmX3RoZW5fZWxzZSA9XG4gICAgeyBJZl90aGVuX2Vsc2UudGVzdDsgdGhlbl87IGVsc2VfOyB0ZXN0X2NoYW5nZTsgbWFpbjsgY3VycmVudF9icmFuY2ggPSBVb3B0Lm5vbmUgfVxuICBpblxuICBOb2RlLnNldF9jdXRvZmYgdGVzdF9jaGFuZ2UgQ3V0b2ZmLm5ldmVyO1xuICBOb2RlLnNldF9raW5kIHRlc3RfY2hhbmdlIChJZl90ZXN0X2NoYW5nZSBpZl90aGVuX2Vsc2UpO1xuICBOb2RlLnNldF9raW5kIG1haW4gKElmX3RoZW5fZWxzZSBpZl90aGVuX2Vsc2UpO1xuICBtYWluXG47O1xuXG5sZXQgbGF6eV9mcm9tX2Z1biB0IH5mID1cbiAgbGV0IHNjb3BlID0gdC5jdXJyZW50X3Njb3BlIGluXG4gIExhenkuZnJvbV9mdW4gKGZ1biAoKSAtPiB3aXRoaW5fc2NvcGUgdCBzY29wZSB+Zilcbjs7XG5cbmxldCBkZWZhdWx0X2hhc2hfdGFibGVfaW5pdGlhbF9zaXplID0gNFxuXG5sZXQgbWVtb2l6ZV9mdW5fYnlfa2V5XG4gID8oaW5pdGlhbF9zaXplID0gZGVmYXVsdF9oYXNoX3RhYmxlX2luaXRpYWxfc2l6ZSlcbiAgdFxuICBoYXNoYWJsZVxuICBwcm9qZWN0X2tleVxuICBmXG4gID1cbiAgKCogSGVyZSdzIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB3ZSBnZXQgW3QuY3VycmVudF9zY29wZV0gaGVyZSwgYW5kIHRoZW4gY2FsbFxuICAgICBbd2l0aGluX3Njb3BlXSBiZWxvdy4gIENvbnNpZGVyIHRoaXMgKGltcG9zc2libGUpIGFsdGVybmF0ZSBpbXBsZW1lbnRhdGlvbiBvZlxuICAgICBbbWVtb2l6ZV9mdW5fYnlfa2V5XTpcblxuICAgICB7W1xuICAgICAgIGxldCB0YWJsZSA9XG4gICAgICAgICBIYXNodGJsLm9mX2FsaXN0X2V4biBoYXNoYWJsZVxuICAgICAgICAgICAoTGlzdC5tYXAgYWxsX3Bvc3NpYmxlX2FfdmFsdWVzIH5mOihmdW4gYSAtPiAocHJvamVjdF9rZXkgYSwgZiBhKSlcbiAgICAgICBpblxuICAgICAgIHN0YWdlIChmdW4ga2V5IC0+IEhhc2h0YmwuZmluZF9leG4gdGFibGUgKHByb2plY3Rfa2V5IGEpKVxuICAgICBdfVxuXG4gICAgIFRoaXMgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgW2N1cnJlbnRfc2NvcGVdIG9yIFt3aXRoaW5fc2NvcGVdLiAgQWxsIGNhbGxzIHRvIFtmXVxuICAgICBuYXR1cmFsbHkgb2NjdXIgaW4gW3QuY3VycmVudF9zY29wZV0uXG5cbiAgICAgU3VjaCBhbiBpbXBsZW1lbnRhdGlvbiBpcyBpbXBvc3NpYmxlIGJlY2F1c2Ugd2UgZG8gbm90IGhhdmUgW2FsbF9wb3NzaWJsZV9hX3ZhbHVlc10uXG4gICAgIFRoZSBpbXBsZW1lbnRhdGlvbiBiZWxvdyB1c2VzIFt3aXRoaW5fc2NvcGVdIHRvIGNhbGwgW2YgYV0gaW4gdGhlIHNjb3BlIHRoYXQgd2FzXG4gICAgIGN1cnJlbnQgYXQgdGhlIHBvaW50IG9mIHRoZSBjYWxsIHRvIFttZW1vaXplX2Z1bl9ieV9rZXldIHNvIHRoYXQgd2UgY2FuIHRoaW5rIG9mIHRoZVxuICAgICBbdGFibGVdIGFzIGhhdmluZyBiZWVuIGNyZWF0ZWQgdGhlbiwgd2hlbiBpdCBpbiByZWFsaXR5IGlzIGNyZWF0ZWQgb24tZGVtYW5kLiAqKVxuICBsZXQgc2NvcGUgPSB0LmN1cnJlbnRfc2NvcGUgaW5cbiAgbGV0IHRhYmxlID0gSGFzaHRibC5jcmVhdGUgaGFzaGFibGUgfnNpemU6aW5pdGlhbF9zaXplIGluXG4gIHN0YWdlIChmdW4gYSAtPlxuICAgIGxldCBrZXkgPSBwcm9qZWN0X2tleSBhIGluXG4gICAgbWF0Y2ggSGFzaHRibC5maW5kIHRhYmxlIGtleSB3aXRoXG4gICAgfCBTb21lIGIgLT4gYlxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IGIgPSB3aXRoaW5fc2NvcGUgdCBzY29wZSB+ZjooZnVuICgpIC0+IGYgYSkgaW5cbiAgICAgIEhhc2h0YmwuYWRkX2V4biB0YWJsZSB+a2V5IH5kYXRhOmI7XG4gICAgICBiKVxuOztcblxubGV0IGFycmF5X2ZvbGQgdCBjaGlsZHJlbiB+aW5pdCB+ZiA9XG4gIGlmIEFycmF5Lmxlbmd0aCBjaGlsZHJlbiA9IDBcbiAgdGhlbiBjb25zdCB0IGluaXRcbiAgZWxzZSBjcmVhdGVfbm9kZSB0IChBcnJheV9mb2xkIHsgaW5pdDsgZjsgY2hpbGRyZW4gfSlcbjs7XG5cbmxldCBhbGwgdCB0cyA9IGFycmF5X2ZvbGQgdCAoQXJyYXkub2ZfbGlzdF9yZXYgdHMpIH5pbml0OltdIH5mOihmdW4gYWMgYSAtPiBhIDo6IGFjKVxuXG5tb2R1bGUgVW5vcmRlcmVkX2FycmF5X2ZvbGRfdXBkYXRlID0gVW5vcmRlcmVkX2FycmF5X2ZvbGQuVXBkYXRlXG5cbmxldCB1bm9yZGVyZWRfYXJyYXlfZm9sZFxuICB0XG4gID8oZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyA9IEludC5tYXhfdmFsdWUpXG4gIGNoaWxkcmVuXG4gIH5pbml0XG4gIH5mXG4gIH51cGRhdGVcbiAgPVxuICBpZiBBcnJheS5sZW5ndGggY2hpbGRyZW4gPSAwXG4gIHRoZW4gY29uc3QgdCBpbml0XG4gIGVsc2UgaWYgZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyA8PSAwXG4gIHRoZW5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwidW5vcmRlcmVkX2FycmF5X2ZvbGQgZ290IG5vbi1wb3NpdGl2ZSBmdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzXCJcbiAgICAgIGZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXNcbiAgICAgIFslc2V4cF9vZjogaW50XVxuICBlbHNlIChcbiAgICBsZXQgbWFpbiA9IGNyZWF0ZV9ub2RlIHQgVW5pbml0aWFsaXplZCBpblxuICAgIE5vZGUuc2V0X2tpbmRcbiAgICAgIG1haW5cbiAgICAgIChVbm9yZGVyZWRfYXJyYXlfZm9sZFxuICAgICAgICAgKFVub3JkZXJlZF9hcnJheV9mb2xkLmNyZWF0ZVxuICAgICAgICAgICAgfmluaXRcbiAgICAgICAgICAgIH5mXG4gICAgICAgICAgICB+dXBkYXRlXG4gICAgICAgICAgICB+ZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlc1xuICAgICAgICAgICAgfmNoaWxkcmVuXG4gICAgICAgICAgICB+bWFpbikpO1xuICAgIG1haW4pXG47O1xuXG5sZXQgb3B0X3Vub3JkZXJlZF9hcnJheV9mb2xkIHQgP2Z1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMgdHMgfmluaXQgfmYgfmZfaW52ZXJzZSA9XG4gIGxldCBmIChhY2N1bSwgbnVtX2ludmFsaWQpIHggPVxuICAgIG1hdGNoIHggd2l0aFxuICAgIHwgTm9uZSAtPiBhY2N1bSwgbnVtX2ludmFsaWQgKyAxXG4gICAgfCBTb21lIHggLT4gZiBhY2N1bSB4LCBudW1faW52YWxpZFxuICBpblxuICBsZXQgZl9pbnZlcnNlIChhY2N1bSwgbnVtX2ludmFsaWQpIHggPVxuICAgIG1hdGNoIHggd2l0aFxuICAgIHwgTm9uZSAtPiBhY2N1bSwgbnVtX2ludmFsaWQgLSAxXG4gICAgfCBTb21lIHggLT4gZl9pbnZlcnNlIGFjY3VtIHgsIG51bV9pbnZhbGlkXG4gIGluXG4gIG1hcFxuICAgICh1bm9yZGVyZWRfYXJyYXlfZm9sZFxuICAgICAgIHRcbiAgICAgICB0c1xuICAgICAgIH5pbml0Oihpbml0LCAwKVxuICAgICAgIH5mXG4gICAgICAgfnVwZGF0ZTooRl9pbnZlcnNlIGZfaW52ZXJzZSlcbiAgICAgICA/ZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcylcbiAgICB+ZjooZnVuIChhY2N1bSwgbnVtX2ludmFsaWQpIC0+IGlmIG51bV9pbnZhbGlkID0gMCB0aGVuIFNvbWUgYWNjdW0gZWxzZSBOb25lKVxuOztcblxubGV0IGF0X2xlYXN0X2tfb2YgdCBub2RlcyB+ayA9XG4gIGxldCBib29sX3RvX2ludCBiID0gaWYgYiB0aGVuIDEgZWxzZSAwIGluXG4gIG1hcFxuICAgIH5mOihmdW4gaSAtPiBpID49IGspXG4gICAgKHVub3JkZXJlZF9hcnJheV9mb2xkXG4gICAgICAgdFxuICAgICAgIG5vZGVzXG4gICAgICAgfmluaXQ6MFxuICAgICAgIH5mOihmdW4gbnVtX3RydWUgYiAtPiBudW1fdHJ1ZSArIGJvb2xfdG9faW50IGIpXG4gICAgICAgfnVwZGF0ZTooRl9pbnZlcnNlIChmdW4gbnVtX3RydWUgYiAtPiBudW1fdHJ1ZSAtIGJvb2xfdG9faW50IGIpKSlcbjs7XG5cbmxldCBleGlzdHMgdCBub2RlcyA9IGF0X2xlYXN0X2tfb2YgdCBub2RlcyB+azoxXG5sZXQgZm9yX2FsbCB0IG5vZGVzID0gYXRfbGVhc3Rfa19vZiB0IG5vZGVzIH5rOihBcnJheS5sZW5ndGggbm9kZXMpXG5cbmxldCBzdW0gdCA/ZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyBub2RlcyB+emVybyB+YWRkIH5zdWIgPVxuICB1bm9yZGVyZWRfYXJyYXlfZm9sZFxuICAgIHRcbiAgICBub2Rlc1xuICAgIH5pbml0Onplcm9cbiAgICB+ZjphZGRcbiAgICB+dXBkYXRlOihGX2ludmVyc2Ugc3ViKVxuICAgID9mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzXG47O1xuXG5sZXQgb3B0X3N1bSB0ID9mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzIG5vZGVzIH56ZXJvIH5hZGQgfnN1YiA9XG4gIG9wdF91bm9yZGVyZWRfYXJyYXlfZm9sZFxuICAgIHRcbiAgICBub2Rlc1xuICAgIH5pbml0Onplcm9cbiAgICB+ZjphZGRcbiAgICB+Zl9pbnZlcnNlOnN1YlxuICAgID9mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzXG47O1xuXG5sZXQgc3VtX2ludCB0IG5vZGVzID0gc3VtIHQgbm9kZXMgfnplcm86MCB+YWRkOiggKyApIH5zdWI6KCAtIClcblxubGV0IHN1bV9mbG9hdCB0IG5vZGVzID1cbiAgc3VtXG4gICAgdFxuICAgIG5vZGVzXG4gICAgfnplcm86MC5cbiAgICB+YWRkOiggKy4gKVxuICAgIH5zdWI6KCAtLiApXG4gICAgfmZ1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXM6KEFycmF5Lmxlbmd0aCBub2Rlcylcbjs7XG5cbmxldCBzZXRfZnJlZXplIChub2RlIDogXyBOb2RlLnQpIH5jaGlsZCB+b25seV9mcmVlemVfd2hlbiA9XG4gIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChTY29wZS5pc190b3Agbm9kZS5jcmVhdGVkX2luKTtcbiAgKCogQnkgbWFraW5nIFtub2RlLmtpbmRdIGJlIFtGcmVlemVdLCB3ZSBhcmUgbWFraW5nIFtOb2RlLmlzX25lY2Vzc2FyeSBub2RlXS4gKilcbiAgbGV0IHdhc19uZWNlc3NhcnkgPSBOb2RlLmlzX25lY2Vzc2FyeSBub2RlIGluXG4gIE5vZGUuc2V0X2tpbmQgbm9kZSAoRnJlZXplIHsgbWFpbiA9IG5vZGU7IGNoaWxkOyBvbmx5X2ZyZWV6ZV93aGVuIH0pO1xuICBpZiB3YXNfbmVjZXNzYXJ5XG4gIHRoZW4gYWRkX3BhcmVudCB+Y2hpbGQgfnBhcmVudDpub2RlIH5jaGlsZF9pbmRleDpLaW5kLmZyZWV6ZV9jaGlsZF9pbmRleFxuICBlbHNlIGJlY2FtZV9uZWNlc3Nhcnkgbm9kZVxuOztcblxubGV0IGZyZWV6ZSAoY2hpbGQgOiBfIE5vZGUudCkgfm9ubHlfZnJlZXplX3doZW4gPVxuICBsZXQgdCA9IGNoaWxkLnN0YXRlIGluXG4gIGxldCBub2RlID0gY3JlYXRlX25vZGVfdG9wIHQgVW5pbml0aWFsaXplZCBpblxuICBzZXRfZnJlZXplIG5vZGUgfmNoaWxkIH5vbmx5X2ZyZWV6ZV93aGVuO1xuICBub2RlXG47O1xuXG5sZXQgYXQgY2xvY2sgdGltZSA9XG4gIGxldCB0ID0gQ2xvY2suaW5jcl9zdGF0ZSBjbG9jayBpblxuICBpZiBUaW1lX25zLiggPD0gKSB0aW1lIChub3cgY2xvY2spXG4gIHRoZW4gY29uc3QgdCBCZWZvcmVfb3JfYWZ0ZXIuQWZ0ZXJcbiAgZWxzZSAoXG4gICAgbGV0IG1haW4gPSBjcmVhdGVfbm9kZSB0IFVuaW5pdGlhbGl6ZWQgaW5cbiAgICBsZXQgYXQgPSB7IEF0LmF0ID0gdGltZTsgbWFpbjsgYWxhcm0gPSBBbGFybS5udWxsOyBjbG9jayB9IGluXG4gICAgTm9kZS5zZXRfa2luZCBtYWluIChBdCBhdCk7XG4gICAgYXQuYWxhcm0gPC0gYWRkX2FsYXJtIGNsb2NrIH5hdDp0aW1lIChBbGFybV92YWx1ZS5jcmVhdGUgKEF0IGF0KSk7XG4gICAgbWFpbilcbjs7XG5cbmxldCBhZnRlciBjbG9jayBzcGFuID0gYXQgY2xvY2sgKFRpbWVfbnMuYWRkIChub3cgY2xvY2spIHNwYW4pXG5cbmxldCBuZXh0X2ludGVydmFsX2FsYXJtX3N0cmljdCAoY2xvY2sgOiBDbG9jay50KSB+YmFzZSB+aW50ZXJ2YWwgPVxuICBsZXQgYWZ0ZXIgPSBub3cgY2xvY2sgaW5cbiAgbGV0IGF0ID0gVGltZV9ucy5uZXh0X211bHRpcGxlIH5iYXNlIH5hZnRlciB+aW50ZXJ2YWwgfmNhbl9lcXVhbF9hZnRlcjpmYWxzZSAoKSBpblxuICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoVGltZV9ucy4oID4gKSBhdCBhZnRlcik7XG4gIGF0XG47O1xuXG5sZXQgYXRfaW50ZXJ2YWxzIChjbG9jayA6IENsb2NrLnQpIGludGVydmFsID1cbiAgbGV0IHQgPSBDbG9jay5pbmNyX3N0YXRlIGNsb2NrIGluXG4gIGlmIFRpbWVfbnMuU3Bhbi4oIDwgKSBpbnRlcnZhbCAoVGltaW5nX3doZWVsLmFsYXJtX3ByZWNpc2lvbiBjbG9jay50aW1pbmdfd2hlZWwpXG4gIHRoZW5cbiAgICBmYWlsd2l0aHNcbiAgICAgIH5oZXJlOlslaGVyZV1cbiAgICAgIFwiYXRfaW50ZXJ2YWxzIGdvdCB0b28gc21hbGwgaW50ZXJ2YWxcIlxuICAgICAgaW50ZXJ2YWxcbiAgICAgIFslc2V4cF9vZjogVGltZV9ucy5TcGFuLnRdO1xuICBsZXQgbWFpbiA9IGNyZWF0ZV9ub2RlIHQgVW5pbml0aWFsaXplZCBpblxuICBsZXQgYmFzZSA9IG5vdyBjbG9jayBpblxuICBsZXQgYXRfaW50ZXJ2YWxzID0geyBBdF9pbnRlcnZhbHMubWFpbjsgYmFzZTsgaW50ZXJ2YWw7IGFsYXJtID0gQWxhcm0ubnVsbDsgY2xvY2sgfSBpblxuICBOb2RlLnNldF9raW5kIG1haW4gKEF0X2ludGVydmFscyBhdF9pbnRlcnZhbHMpO1xuICAoKiBbbWFpbiA6IHVuaXQgTm9kZS50XSwgc28gd2UgbWFrZSBpdCBuZXZlciBjdXRvZmYgc28gaXQgY2hhbmdlcyBlYWNoIHRpbWUgaXQgaXNcbiAgICAgcmVjb21wdXRlZC4gKilcbiAgTm9kZS5zZXRfY3V0b2ZmIG1haW4gQ3V0b2ZmLm5ldmVyO1xuICBhdF9pbnRlcnZhbHMuYWxhcm1cbiAgICA8LSBhZGRfYWxhcm1cbiAgICAgICAgIGNsb2NrXG4gICAgICAgICB+YXQ6KG5leHRfaW50ZXJ2YWxfYWxhcm1fc3RyaWN0IGNsb2NrIH5iYXNlIH5pbnRlcnZhbClcbiAgICAgICAgIChBbGFybV92YWx1ZS5jcmVhdGUgKEF0X2ludGVydmFscyBhdF9pbnRlcnZhbHMpKTtcbiAgbWFpblxuOztcblxubGV0IHNuYXBzaG90IGNsb2NrIHZhbHVlX2F0IH5hdCB+YmVmb3JlID1cbiAgbGV0IHQgPSBDbG9jay5pbmNyX3N0YXRlIGNsb2NrIGluXG4gIGlmIFRpbWVfbnMuKCA8PSApIGF0IChub3cgY2xvY2spXG4gIHRoZW5cbiAgICBpZiBUaW1lX25zLiggPCApIGF0IChub3cgY2xvY2spXG4gICAgdGhlbiBPcl9lcnJvci5lcnJvciBcImNhbm5vdCB0YWtlIHNuYXBzaG90IGluIHRoZSBwYXN0XCIgYXQgWyVzZXhwX29mOiBUaW1lX25zLnRdXG4gICAgZWxzZSBPayAoZnJlZXplIHZhbHVlX2F0IH5vbmx5X2ZyZWV6ZV93aGVuOihGbi5jb25zdCB0cnVlKSlcbiAgZWxzZSAoXG4gICAgbGV0IG1haW4gPSBjcmVhdGVfbm9kZV90b3AgdCBVbmluaXRpYWxpemVkIGluXG4gICAgbGV0IHNuYXBzaG90ID0geyBTbmFwc2hvdC5tYWluOyBhdDsgYmVmb3JlOyB2YWx1ZV9hdDsgY2xvY2sgfSBpblxuICAgIE5vZGUuc2V0X2tpbmQgbWFpbiAoU25hcHNob3Qgc25hcHNob3QpO1xuICAgICgqIFVubGlrZSBvdGhlciB0aW1lLWJhc2VkIGluY3JlbWVudGFscywgYSBzbmFwc2hvdCBpcyBjcmVhdGVkIGluIFtTY29wZS50b3BdIGFuZFxuICAgICAgIGNhbm5vdCBiZSBpbnZhbGlkYXRlZCBieSBpdHMgc2NvcGUuICBUaHVzLCB0aGVyZSBpcyBubyBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gICAgICAgYWxhcm0gdGhhdCBpcyBhZGRlZCwgYmVjYXVzZSBpdCB3aWxsIG5ldmVyIG5lZWQgdG8gYmUgcmVtb3ZlZCBlYXJseS4gKilcbiAgICBpZ25vcmUgKGFkZF9hbGFybSBjbG9jayB+YXQgKEFsYXJtX3ZhbHVlLmNyZWF0ZSAoU25hcHNob3Qgc25hcHNob3QpKSA6IEFsYXJtLnQpO1xuICAgIE9rIG1haW4pXG47O1xuXG5sZXQgaW5jcmVtZW50YWxfc3RlcF9mdW5jdGlvbiBjbG9jayBjaGlsZCA9XG4gIGxldCB0ID0gQ2xvY2suaW5jcl9zdGF0ZSBjbG9jayBpblxuICBsZXQgbWFpbiA9IGNyZWF0ZV9ub2RlIHQgVW5pbml0aWFsaXplZCBpblxuICBsZXQgc3RlcF9mdW5jdGlvbl9ub2RlID1cbiAgICB7IFN0ZXBfZnVuY3Rpb25fbm9kZS5tYWluXG4gICAgOyB2YWx1ZSA9IFVvcHQubm9uZVxuICAgIDsgY2hpbGQgPSBVb3B0LnNvbWUgY2hpbGRcbiAgICA7IGV4dHJhY3RlZF9zdGVwX2Z1bmN0aW9uX2Zyb21fY2hpbGRfYXQgPSBTdGFiaWxpemF0aW9uX251bS5ub25lXG4gICAgOyB1cGNvbWluZ19zdGVwcyA9IFNlcXVlbmNlLmVtcHR5XG4gICAgOyBhbGFybSA9IEFsYXJtLm51bGxcbiAgICA7IGFsYXJtX3ZhbHVlID0gT2JqLm1hZ2ljIE5vbmUgKCogc2V0IGJlbG93ICopXG4gICAgOyBjbG9ja1xuICAgIH1cbiAgaW5cbiAgc3RlcF9mdW5jdGlvbl9ub2RlLmFsYXJtX3ZhbHVlIDwtIEFsYXJtX3ZhbHVlLmNyZWF0ZSAoU3RlcF9mdW5jdGlvbiBzdGVwX2Z1bmN0aW9uX25vZGUpO1xuICBOb2RlLnNldF9raW5kIG1haW4gKFN0ZXBfZnVuY3Rpb24gc3RlcF9mdW5jdGlvbl9ub2RlKTtcbiAgbWFpblxuOztcblxubGV0IG1ha2Vfc3RhbGUgKG5vZGUgOiBfIE5vZGUudCkgPVxuICBsZXQgdCA9IG5vZGUuc3RhdGUgaW5cbiAgbm9kZS5yZWNvbXB1dGVkX2F0IDwtIFN0YWJpbGl6YXRpb25fbnVtLm5vbmU7XG4gICgqIGZvcmNlIHRoZSBub2RlIHRvIGJlIHN0YWxlICopXG4gIGlmIE5vZGUubmVlZHNfdG9fYmVfY29tcHV0ZWQgbm9kZSAmJiBub3QgKE5vZGUuaXNfaW5fcmVjb21wdXRlX2hlYXAgbm9kZSlcbiAgdGhlbiBSZWNvbXB1dGVfaGVhcC5hZGQgdC5yZWNvbXB1dGVfaGVhcCBub2RlXG47O1xuXG5sZXQgYWR2YW5jZV9jbG9jayAoY2xvY2sgOiBDbG9jay50KSB+dG9fID1cbiAgbGV0IHQgPSBDbG9jay5pbmNyX3N0YXRlIGNsb2NrIGluXG4gIGVuc3VyZV9ub3Rfc3RhYmlsaXppbmcgdCB+bmFtZTpcImFkdmFuY2VfY2xvY2tcIiB+YWxsb3dfaW5fdXBkYXRlX2hhbmRsZXI6dHJ1ZTtcbiAgaWYgZGVidWcgdGhlbiBpbnZhcmlhbnQgdDtcbiAgaWYgVGltZV9ucy4oID4gKSB0b18gKG5vdyBjbG9jaylcbiAgdGhlbiAoXG4gICAgc2V0X3Zhcl93aGlsZV9ub3Rfc3RhYmlsaXppbmcgY2xvY2subm93IHRvXztcbiAgICBUaW1pbmdfd2hlZWwuYWR2YW5jZV9jbG9jayBjbG9jay50aW1pbmdfd2hlZWwgfnRvXyB+aGFuZGxlX2ZpcmVkOmNsb2NrLmhhbmRsZV9maXJlZDtcbiAgICBUaW1pbmdfd2hlZWwuZmlyZV9wYXN0X2FsYXJtcyBjbG9jay50aW1pbmdfd2hlZWwgfmhhbmRsZV9maXJlZDpjbG9jay5oYW5kbGVfZmlyZWQ7XG4gICAgd2hpbGUgVW9wdC5pc19zb21lIGNsb2NrLmZpcmVkX2FsYXJtX3ZhbHVlcyBkb1xuICAgICAgbGV0IGFsYXJtX3ZhbHVlID0gVW9wdC51bnNhZmVfdmFsdWUgY2xvY2suZmlyZWRfYWxhcm1fdmFsdWVzIGluXG4gICAgICBjbG9jay5maXJlZF9hbGFybV92YWx1ZXMgPC0gYWxhcm1fdmFsdWUubmV4dF9maXJlZDtcbiAgICAgIGFsYXJtX3ZhbHVlLm5leHRfZmlyZWQgPC0gVW9wdC5ub25lO1xuICAgICAgbWF0Y2ggYWxhcm1fdmFsdWUuYWN0aW9uIHdpdGhcbiAgICAgIHwgQXQgeyBtYWluOyBfIH0gLT5cbiAgICAgICAgaWYgTm9kZS5pc192YWxpZCBtYWluXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIE5vZGUuc2V0X2tpbmQgbWFpbiAoQ29uc3QgQWZ0ZXIpO1xuICAgICAgICAgIG1ha2Vfc3RhbGUgbWFpbilcbiAgICAgIHwgQXRfaW50ZXJ2YWxzICh7IG1haW47IGJhc2U7IGludGVydmFsOyBfIH0gYXMgYXRfaW50ZXJ2YWxzKSAtPlxuICAgICAgICBpZiBOb2RlLmlzX3ZhbGlkIG1haW5cbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgYXRfaW50ZXJ2YWxzLmFsYXJtXG4gICAgICAgICAgICA8LSBhZGRfYWxhcm1cbiAgICAgICAgICAgICAgICAgY2xvY2tcbiAgICAgICAgICAgICAgICAgfmF0OihuZXh0X2ludGVydmFsX2FsYXJtX3N0cmljdCBjbG9jayB+YmFzZSB+aW50ZXJ2YWwpXG4gICAgICAgICAgICAgICAgIGFsYXJtX3ZhbHVlO1xuICAgICAgICAgIG1ha2Vfc3RhbGUgbWFpbilcbiAgICAgIHwgU25hcHNob3QgeyBtYWluOyB2YWx1ZV9hdDsgXyB9IC0+XG4gICAgICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLmlzX3ZhbGlkIG1haW4pO1xuICAgICAgICBzZXRfZnJlZXplIG1haW4gfmNoaWxkOnZhbHVlX2F0IH5vbmx5X2ZyZWV6ZV93aGVuOihmdW4gXyAtPiB0cnVlKTtcbiAgICAgICAgbWFrZV9zdGFsZSBtYWluXG4gICAgICB8IFN0ZXBfZnVuY3Rpb24geyBtYWluOyBfIH0gLT4gaWYgTm9kZS5pc192YWxpZCBtYWluIHRoZW4gbWFrZV9zdGFsZSBtYWluXG4gICAgZG9uZTtcbiAgICBpZiBkZWJ1ZyB0aGVuIGludmFyaWFudCB0KVxuOztcblxubGV0IGNyZWF0ZV9jbG9jayB0IH50aW1pbmdfd2hlZWxfY29uZmlnIH5zdGFydCA9XG4gIGxldCB0aW1pbmdfd2hlZWwgPSBUaW1pbmdfd2hlZWwuY3JlYXRlIH5jb25maWc6dGltaW5nX3doZWVsX2NvbmZpZyB+c3RhcnQgaW5cbiAgbGV0IHJlYyBjbG9jayA6IENsb2NrLnQgPVxuICAgIHsgbm93ID0gY3JlYXRlX3ZhciB0IHN0YXJ0XG4gICAgOyBoYW5kbGVfZmlyZWRcbiAgICA7IGZpcmVkX2FsYXJtX3ZhbHVlcyA9IFVvcHQubm9uZVxuICAgIDsgdGltaW5nX3doZWVsXG4gICAgfVxuICBhbmQgaGFuZGxlX2ZpcmVkIGFsYXJtID1cbiAgICBsZXQgYWxhcm1fdmFsdWUgPSBUaW1pbmdfd2hlZWwuQWxhcm0udmFsdWUgY2xvY2sudGltaW5nX3doZWVsIGFsYXJtIGluXG4gICAgYWxhcm1fdmFsdWUubmV4dF9maXJlZCA8LSBjbG9jay5maXJlZF9hbGFybV92YWx1ZXM7XG4gICAgY2xvY2suZmlyZWRfYWxhcm1fdmFsdWVzIDwtIFVvcHQuc29tZSBhbGFybV92YWx1ZVxuICBpblxuICBjbG9ja1xuOztcblxubGV0IGNyZWF0ZSAobW9kdWxlIENvbmZpZyA6IENvbmZpZy5JbmNyZW1lbnRhbF9jb25maWcpIH5tYXhfaGVpZ2h0X2FsbG93ZWQgPVxuICBsZXQgYWRqdXN0X2hlaWdodHNfaGVhcCA9IEFkanVzdF9oZWlnaHRzX2hlYXAuY3JlYXRlIH5tYXhfaGVpZ2h0X2FsbG93ZWQgaW5cbiAgbGV0IHJlY29tcHV0ZV9oZWFwID0gUmVjb21wdXRlX2hlYXAuY3JlYXRlIH5tYXhfaGVpZ2h0X2FsbG93ZWQgaW5cbiAgbGV0IHQgPVxuICAgIHsgc3RhdHVzID0gTm90X3N0YWJpbGl6aW5nXG4gICAgOyBiaW5kX2xoc19jaGFuZ2Vfc2hvdWxkX2ludmFsaWRhdGVfcmhzID0gQ29uZmlnLmJpbmRfbGhzX2NoYW5nZV9zaG91bGRfaW52YWxpZGF0ZV9yaHNcbiAgICA7IHN0YWJpbGl6YXRpb25fbnVtID0gU3RhYmlsaXphdGlvbl9udW0uemVyb1xuICAgIDsgY3VycmVudF9zY29wZSA9IFNjb3BlLnRvcFxuICAgIDsgYWRqdXN0X2hlaWdodHNfaGVhcFxuICAgIDsgcmVjb21wdXRlX2hlYXBcbiAgICA7IHByb3BhZ2F0ZV9pbnZhbGlkaXR5ID0gU3RhY2suY3JlYXRlICgpXG4gICAgOyBudW1fYWN0aXZlX29ic2VydmVycyA9IDBcbiAgICA7IGFsbF9vYnNlcnZlcnMgPSBVb3B0Lm5vbmVcbiAgICA7IGZpbmFsaXplZF9vYnNlcnZlcnMgPSBUaHJlYWRfc2FmZV9xdWV1ZS5jcmVhdGUgKClcbiAgICA7IGRpc2FsbG93ZWRfb2JzZXJ2ZXJzID0gU3RhY2suY3JlYXRlICgpXG4gICAgOyBuZXdfb2JzZXJ2ZXJzID0gU3RhY2suY3JlYXRlICgpXG4gICAgOyBzZXRfZHVyaW5nX3N0YWJpbGl6YXRpb24gPSBTdGFjay5jcmVhdGUgKClcbiAgICA7IGhhbmRsZV9hZnRlcl9zdGFiaWxpemF0aW9uID0gU3RhY2suY3JlYXRlICgpXG4gICAgOyBydW5fb25fdXBkYXRlX2hhbmRsZXJzID0gU3RhY2suY3JlYXRlICgpXG4gICAgOyBvbmx5X2luX2RlYnVnID0gT25seV9pbl9kZWJ1Zy5jcmVhdGUgKClcbiAgICA7IHdlYWtfaGFzaHRibHMgPSBUaHJlYWRfc2FmZV9xdWV1ZS5jcmVhdGUgKClcbiAgICA7IGtlZXBfbm9kZV9jcmVhdGlvbl9iYWNrdHJhY2UgPSBmYWxzZVxuICAgIDsgbnVtX25vZGVzX2JlY2FtZV9uZWNlc3NhcnkgPSAwXG4gICAgOyBudW1fbm9kZXNfYmVjYW1lX3VubmVjZXNzYXJ5ID0gMFxuICAgIDsgbnVtX25vZGVzX2NoYW5nZWQgPSAwXG4gICAgOyBudW1fbm9kZXNfaW52YWxpZGF0ZWQgPSAwXG4gICAgOyBudW1fbm9kZXNfY3JlYXRlZCA9IDBcbiAgICA7IG51bV9ub2Rlc19yZWNvbXB1dGVkID0gMFxuICAgIDsgbnVtX25vZGVzX3JlY29tcHV0ZWRfZGlyZWN0bHlfYmVjYXVzZV9vbmVfY2hpbGQgPSAwXG4gICAgOyBudW1fbm9kZXNfcmVjb21wdXRlZF9kaXJlY3RseV9iZWNhdXNlX21pbl9oZWlnaHQgPSAwXG4gICAgOyBudW1fdmFyX3NldHMgPSAwXG4gICAgfVxuICBpblxuICB0XG47O1xuXG5sZXQgd2Vha19tZW1vaXplX2Z1bl9ieV9rZXlcbiAgPyhpbml0aWFsX3NpemUgPSBkZWZhdWx0X2hhc2hfdGFibGVfaW5pdGlhbF9zaXplKVxuICB0XG4gIGhhc2hhYmxlXG4gIHByb2plY3Rfa2V5XG4gIGZcbiAgPVxuICBsZXQgc2NvcGUgPSB0LmN1cnJlbnRfc2NvcGUgaW5cbiAgbGV0IHRhYmxlID0gV2Vha19oYXNodGJsLmNyZWF0ZSB+c2l6ZTppbml0aWFsX3NpemUgaGFzaGFibGUgaW5cbiAgbGV0IHBhY2tlZCA9IFBhY2tlZF93ZWFrX2hhc2h0YmwuVCB0YWJsZSBpblxuICBXZWFrX2hhc2h0Ymwuc2V0X3J1bl93aGVuX3VudXNlZF9kYXRhIHRhYmxlIH50aHJlYWRfc2FmZV9mOihmdW4gKCkgLT5cbiAgICBUaHJlYWRfc2FmZV9xdWV1ZS5lbnF1ZXVlIHQud2Vha19oYXNodGJscyBwYWNrZWQpO1xuICBzdGFnZSAoZnVuIGEgLT5cbiAgICBsZXQga2V5ID0gcHJvamVjdF9rZXkgYSBpblxuICAgIG1hdGNoIFdlYWtfaGFzaHRibC5maW5kIHRhYmxlIGtleSB3aXRoXG4gICAgfCBTb21lIGIgLT4gYlxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IGIgPSB3aXRoaW5fc2NvcGUgdCBzY29wZSB+ZjooZnVuICgpIC0+IGYgYSkgaW5cbiAgICAgIFdlYWtfaGFzaHRibC5hZGRfZXhuIHRhYmxlIH5rZXkgfmRhdGE6YjtcbiAgICAgIGIpXG47O1xuXG5tb2R1bGUgRXhwZXJ0ID0gc3RydWN0XG4gICgqIEdpdmVuIHRoYXQgaW52YWxpZCBub2RlIGFyZSBhdCBhdHRlbXB0IGF0IGF2b2lkaW5nIGJyZWFraW5nIHRoZSBlbnRpcmUgaW5jcmVtZW50YWxcbiAgICAgY29tcHV0YXRpb24gb24gcHJvYmxlbXMsIGxldCdzIGp1c3QgaWdub3JlIGFueSBvcGVyYXRpb24gb24gYW4gaW52YWxpZCBpbmNyZW1lbnRhbFxuICAgICByYXRoZXIgdGhhbiByYWlzaW5nLiAqKVxuICBsZXQgZXhwZXJ0X2tpbmRfb2Zfbm9kZSAobm9kZSA6IF8gTm9kZS50KSA9XG4gICAgbWF0Y2ggbm9kZS5raW5kIHdpdGhcbiAgICB8IEV4cGVydCBlIC0+IFVvcHQuc29tZSBlXG4gICAgfCBJbnZhbGlkIC0+IFVvcHQubm9uZVxuICAgIHwga2luZCAtPiByYWlzZV9zIFslc2V4cCBcInVuZXhwZWN0ZWQga2luZCBmb3IgZXhwZXJ0IG5vZGVcIiwgKGtpbmQgOiBfIEtpbmQudCldXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSBzdGF0ZSB+b25fb2JzZXJ2YWJpbGl0eV9jaGFuZ2UgZiA9XG4gICAgbGV0IGUgPSBFeHBlcnQuY3JlYXRlIH5mIH5vbl9vYnNlcnZhYmlsaXR5X2NoYW5nZSBpblxuICAgIGxldCBub2RlID0gY3JlYXRlX25vZGUgc3RhdGUgKEV4cGVydCBlKSBpblxuICAgIGlmIGRlYnVnXG4gICAgdGhlblxuICAgICAgaWYgT3B0aW9uLmlzX3NvbWUgc3RhdGUub25seV9pbl9kZWJ1Zy5jdXJyZW50bHlfcnVubmluZ19ub2RlXG4gICAgICB0aGVuXG4gICAgICAgIHN0YXRlLm9ubHlfaW5fZGVidWcuZXhwZXJ0X25vZGVzX2NyZWF0ZWRfYnlfY3VycmVudF9ub2RlXG4gICAgICAgICAgPC0gVCBub2RlIDo6IHN0YXRlLm9ubHlfaW5fZGVidWcuZXhwZXJ0X25vZGVzX2NyZWF0ZWRfYnlfY3VycmVudF9ub2RlO1xuICAgIG5vZGVcbiAgOztcblxuICBsZXQgY3VycmVudGx5X3J1bm5pbmdfbm9kZV9leG4gc3RhdGUgbmFtZSA9XG4gICAgbWF0Y2ggc3RhdGUub25seV9pbl9kZWJ1Zy5jdXJyZW50bHlfcnVubmluZ19ub2RlIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2VfcyBbJXNleHAgKFwiY2FuIG9ubHkgY2FsbCBcIiBeIG5hbWUgXiBcIiBkdXJpbmcgc3RhYmlsaXphdGlvblwiIDogc3RyaW5nKV1cbiAgICB8IFNvbWUgY3VycmVudCAtPiBjdXJyZW50XG4gIDs7XG5cbiAgKCogTm90ZSB0aGF0IHRoZSB0d28gZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgbm90IHN5bW1ldHJpYyBvZiBvbmUgYW5vdGhlcjogaW4gW2xldCB5ID1cbiAgICAgbWFwIHhdLCBbeF0gaXMgYWx3YXlzIGEgY2hpbGQgb2YgW3ldIChhc3N1bWluZyBbeF0gZG9lc24ndCBiZWNvbWUgaW52YWxpZCkgYnV0IFt5XSBpblxuICAgICBvbmx5IGEgcGFyZW50IG9mIFt4XSBpZiB5IGlzIG5lY2Vzc2FyeS4gKilcbiAgbGV0IGFzc2VydF9jdXJyZW50bHlfcnVubmluZ19ub2RlX2lzX2NoaWxkIHN0YXRlIG5vZGUgbmFtZSA9XG4gICAgbGV0IChUIGN1cnJlbnQpID0gY3VycmVudGx5X3J1bm5pbmdfbm9kZV9leG4gc3RhdGUgbmFtZSBpblxuICAgIGlmIG5vdCAoTm9kZS5oYXNfY2hpbGQgbm9kZSB+Y2hpbGQ6Y3VycmVudClcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslc2V4cFxuICAgICAgICAgIChcImNhbiBvbmx5IGNhbGwgXCIgXiBuYW1lIF4gXCIgb24gcGFyZW50IG5vZGVzXCIgOiBzdHJpbmcpXG4gICAgICAgICAgLCB+fihub2RlLmtpbmQgOiBfIEtpbmQudClcbiAgICAgICAgICAsIH5+KGN1cnJlbnQua2luZCA6IF8gS2luZC50KV1cbiAgOztcblxuICBsZXQgYXNzZXJ0X2N1cnJlbnRseV9ydW5uaW5nX25vZGVfaXNfcGFyZW50IHN0YXRlIG5vZGUgbmFtZSA9XG4gICAgbGV0IChUIGN1cnJlbnQpID0gY3VycmVudGx5X3J1bm5pbmdfbm9kZV9leG4gc3RhdGUgbmFtZSBpblxuICAgIGlmIG5vdCAoTm9kZS5oYXNfcGFyZW50IH5wYXJlbnQ6Y3VycmVudCBub2RlKVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVzZXhwXG4gICAgICAgICAgKFwiY2FuIG9ubHkgY2FsbCBcIiBeIG5hbWUgXiBcIiBvbiBjaGlsZHJlbiBub2Rlc1wiIDogc3RyaW5nKVxuICAgICAgICAgICwgfn4obm9kZS5raW5kIDogXyBLaW5kLnQpXG4gICAgICAgICAgLCB+fihjdXJyZW50LmtpbmQgOiBfIEtpbmQudCldXG4gIDs7XG5cbiAgbGV0IG1ha2Vfc3RhbGUgKG5vZGUgOiBfIE5vZGUudCkgPVxuICAgIGxldCBzdGF0ZSA9IG5vZGUuc3RhdGUgaW5cbiAgICBsZXQgZV9vcHQgPSBleHBlcnRfa2luZF9vZl9ub2RlIG5vZGUgaW5cbiAgICBpZiBVb3B0LmlzX3NvbWUgZV9vcHRcbiAgICB0aGVuIChcbiAgICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0X2N1cnJlbnRseV9ydW5uaW5nX25vZGVfaXNfY2hpbGQgc3RhdGUgbm9kZSBcIm1ha2Vfc3RhbGVcIjtcbiAgICAgIGxldCBlID0gVW9wdC51bnNhZmVfdmFsdWUgZV9vcHQgaW5cbiAgICAgIG1hdGNoIEV4cGVydC5tYWtlX3N0YWxlIGUgd2l0aFxuICAgICAgfCBgQWxyZWFkeV9zdGFsZSAtPiAoKVxuICAgICAgfCBgT2sgLT5cbiAgICAgICAgaWYgTm9kZS5pc19uZWNlc3Nhcnkgbm9kZSAmJiBub3QgKE5vZGUuaXNfaW5fcmVjb21wdXRlX2hlYXAgbm9kZSlcbiAgICAgICAgdGhlbiBSZWNvbXB1dGVfaGVhcC5hZGQgc3RhdGUucmVjb21wdXRlX2hlYXAgbm9kZSlcbiAgOztcblxuICBsZXQgaW52YWxpZGF0ZSAobm9kZSA6IF8gTm9kZS50KSA9XG4gICAgbGV0IHN0YXRlID0gbm9kZS5zdGF0ZSBpblxuICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0X2N1cnJlbnRseV9ydW5uaW5nX25vZGVfaXNfY2hpbGQgc3RhdGUgbm9kZSBcImludmFsaWRhdGVcIjtcbiAgICBpbnZhbGlkYXRlX25vZGUgbm9kZTtcbiAgICBwcm9wYWdhdGVfaW52YWxpZGl0eSBzdGF0ZVxuICA7O1xuXG4gIGxldCBhZGRfZGVwZW5kZW5jeSAobm9kZSA6IF8gTm9kZS50KSAoZGVwIDogXyBFeHBlcnQuZWRnZSkgPVxuICAgIGxldCBzdGF0ZSA9IG5vZGUuc3RhdGUgaW5cbiAgICBsZXQgZV9vcHQgPSBleHBlcnRfa2luZF9vZl9ub2RlIG5vZGUgaW5cbiAgICBpZiBVb3B0LmlzX3NvbWUgZV9vcHRcbiAgICB0aGVuIChcbiAgICAgIGlmIGRlYnVnXG4gICAgICB0aGVuXG4gICAgICAgIGlmIGFtX3N0YWJpbGl6aW5nIHN0YXRlXG4gICAgICAgICAgICYmIG5vdFxuICAgICAgICAgICAgICAgIChMaXN0Lm1lbVxuICAgICAgICAgICAgICAgICAgIH5lcXVhbDpwaHlzX2VxdWFsXG4gICAgICAgICAgICAgICAgICAgc3RhdGUub25seV9pbl9kZWJ1Zy5leHBlcnRfbm9kZXNfY3JlYXRlZF9ieV9jdXJyZW50X25vZGVcbiAgICAgICAgICAgICAgICAgICAoVCBub2RlKSlcbiAgICAgICAgdGhlbiBhc3NlcnRfY3VycmVudGx5X3J1bm5pbmdfbm9kZV9pc19jaGlsZCBzdGF0ZSBub2RlIFwiYWRkX2RlcGVuZGVuY3lcIjtcbiAgICAgIGxldCBlID0gVW9wdC51bnNhZmVfdmFsdWUgZV9vcHQgaW5cbiAgICAgIGxldCBuZXdfY2hpbGRfaW5kZXggPSBFeHBlcnQuYWRkX2NoaWxkX2VkZ2UgZSAoRSBkZXApIGluXG4gICAgICAoKiBbbm9kZV0gaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgbmVjZXNzYXJ5LCBldmVuIGlmIHdlIGFyZSBydW5uaW5nIGluIGEgY2hpbGQgb2ZcbiAgICAgICAgIFtub2RlXSwgYmVjYXVzZSB3ZSBjb3VsZCBiZSBydW5uaW5nIGR1ZSB0byBhIHBhcmVudCBvdGhlciB0aGFuIFtub2RlXSBtYWtpbmcgdXNcbiAgICAgICAgIG5lY2Vzc2FyeS4gKilcbiAgICAgIGlmIE5vZGUuaXNfbmVjZXNzYXJ5IG5vZGVcbiAgICAgIHRoZW4gKFxuICAgICAgICBhZGRfcGFyZW50IH5jaGlsZDpkZXAuY2hpbGQgfnBhcmVudDpub2RlIH5jaGlsZF9pbmRleDpuZXdfY2hpbGRfaW5kZXg7XG4gICAgICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0IChOb2RlLm5lZWRzX3RvX2JlX2NvbXB1dGVkIG5vZGUpO1xuICAgICAgICBpZiBub3QgKE5vZGUuaXNfaW5fcmVjb21wdXRlX2hlYXAgbm9kZSlcbiAgICAgICAgdGhlbiBSZWNvbXB1dGVfaGVhcC5hZGQgc3RhdGUucmVjb21wdXRlX2hlYXAgbm9kZSkpXG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9kZXBlbmRlbmN5IChub2RlIDogXyBOb2RlLnQpIChlZGdlIDogXyBFeHBlcnQuZWRnZSkgPVxuICAgIGxldCBzdGF0ZSA9IG5vZGUuc3RhdGUgaW5cbiAgICBsZXQgZV9vcHQgPSBleHBlcnRfa2luZF9vZl9ub2RlIG5vZGUgaW5cbiAgICBpZiBVb3B0LmlzX3NvbWUgZV9vcHRcbiAgICB0aGVuIChcbiAgICAgIGlmIGRlYnVnIHRoZW4gYXNzZXJ0X2N1cnJlbnRseV9ydW5uaW5nX25vZGVfaXNfY2hpbGQgc3RhdGUgbm9kZSBcInJlbW92ZV9kZXBlbmRlbmN5XCI7XG4gICAgICBsZXQgZSA9IFVvcHQudW5zYWZlX3ZhbHVlIGVfb3B0IGluXG4gICAgICAoKiBbbm9kZV0gaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgbmVjZXNzYXJ5LCBmb3IgdGhlIHJlYXNvbiBzdGF0ZWQgaW5cbiAgICAgICAgIFthZGRfZGVwZW5kZW5jeV0gKilcbiAgICAgIGxldCBlZGdlX2luZGV4ID0gVW9wdC52YWx1ZV9leG4gZWRnZS5pbmRleCBpblxuICAgICAgbGV0IChFIGxhc3RfZWRnZSkgPSBFeHBlcnQubGFzdF9jaGlsZF9lZGdlX2V4biBlIGluXG4gICAgICBsZXQgbGFzdF9lZGdlX2luZGV4ID0gVW9wdC52YWx1ZV9leG4gbGFzdF9lZGdlLmluZGV4IGluXG4gICAgICBpZiBlZGdlX2luZGV4IDw+IGxhc3RfZWRnZV9pbmRleFxuICAgICAgdGhlbiAoXG4gICAgICAgIGlmIE5vZGUuaXNfbmVjZXNzYXJ5IG5vZGVcbiAgICAgICAgdGhlblxuICAgICAgICAgIE5vZGUuc3dhcF9jaGlsZHJlbl9leGNlcHRfaW5fa2luZFxuICAgICAgICAgICAgbm9kZVxuICAgICAgICAgICAgfmNoaWxkMTplZGdlLmNoaWxkXG4gICAgICAgICAgICB+Y2hpbGRfaW5kZXgxOmVkZ2VfaW5kZXhcbiAgICAgICAgICAgIH5jaGlsZDI6bGFzdF9lZGdlLmNoaWxkXG4gICAgICAgICAgICB+Y2hpbGRfaW5kZXgyOmxhc3RfZWRnZV9pbmRleDtcbiAgICAgICAgRXhwZXJ0LnN3YXBfY2hpbGRyZW4gZSB+Y2hpbGRfaW5kZXgxOmVkZ2VfaW5kZXggfmNoaWxkX2luZGV4MjpsYXN0X2VkZ2VfaW5kZXg7XG4gICAgICAgIGlmIGRlYnVnIHRoZW4gTm9kZS5pbnZhcmlhbnQgaWdub3JlIG5vZGUpO1xuICAgICAgRXhwZXJ0LnJlbW92ZV9sYXN0X2NoaWxkX2VkZ2VfZXhuIGU7XG4gICAgICBpZiBkZWJ1ZyB0aGVuIGFzc2VydCAoTm9kZS5pc19zdGFsZSBub2RlKTtcbiAgICAgIGlmIE5vZGUuaXNfbmVjZXNzYXJ5IG5vZGVcbiAgICAgIHRoZW4gKFxuICAgICAgICByZW1vdmVfY2hpbGQgfmNoaWxkOmVkZ2UuY2hpbGQgfnBhcmVudDpub2RlIH5jaGlsZF9pbmRleDpsYXN0X2VkZ2VfaW5kZXg7XG4gICAgICAgIGlmIG5vdCAoTm9kZS5pc19pbl9yZWNvbXB1dGVfaGVhcCBub2RlKVxuICAgICAgICB0aGVuIFJlY29tcHV0ZV9oZWFwLmFkZCBzdGF0ZS5yZWNvbXB1dGVfaGVhcCBub2RlO1xuICAgICAgICBpZiBub3QgKE5vZGUuaXNfdmFsaWQgZWRnZS5jaGlsZCkgdGhlbiBFeHBlcnQuZGVjcl9pbnZhbGlkX2NoaWxkcmVuIGUpKVxuICA7O1xuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIERlcGVuZGVuY3kgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgRXhwZXJ0LmVkZ2UgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgY3JlYXRlID8ob25fY2hhbmdlID0gaWdub3JlKSBjaGlsZCA6IF8gdCA9IHsgY2hpbGQ7IG9uX2NoYW5nZTsgaW5kZXggPSBVb3B0Lm5vbmUgfVxuXG4gIGxldCB2YWx1ZSAodCA6IF8gdCkgPVxuICAgIGxldCBzdGF0ZSA9IHQuY2hpbGQuc3RhdGUgaW5cbiAgICBpZiBkZWJ1Z1xuICAgIHRoZW5cbiAgICAgIFN0YXRlLkV4cGVydC5hc3NlcnRfY3VycmVudGx5X3J1bm5pbmdfbm9kZV9pc19wYXJlbnRcbiAgICAgICAgc3RhdGVcbiAgICAgICAgdC5jaGlsZFxuICAgICAgICBcIkRlcGVuZGVuY3kudmFsdWVcIjtcbiAgICAoKiBOb3QgZXhwb3NpbmcgdGhlIF9leG4sIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBhZHZlcnRpc2VkIGFzIGJlaW5nIHVzYWJsZSBvbmx5XG4gICAgICAgaW5zaWRlIHRoZSBjYWxsYmFja3Mgb2YgcGFyZW50cywgd2hlcmUgaXQgd2lsbCBub3QgcmFpc2UuICopXG4gICAgTm9kZS52YWx1ZV9leG4gdC5jaGlsZFxuICA7O1xuZW5kXG5cbm1vZHVsZSBOb2RlID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSBOb2RlLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgY3JlYXRlIHN0YXRlID8ob25fb2JzZXJ2YWJpbGl0eV9jaGFuZ2UgPSBmdW4gfmlzX25vd19vYnNlcnZhYmxlOl8gLT4gKCkpIGYgPVxuICAgIFN0YXRlLkV4cGVydC5jcmVhdGUgc3RhdGUgfm9uX29ic2VydmFiaWxpdHlfY2hhbmdlIGZcbiAgOztcblxuICBsZXQgbWFrZV9zdGFsZSA9IFN0YXRlLkV4cGVydC5tYWtlX3N0YWxlXG4gIGxldCB3YXRjaCA9IEZuLmlkXG4gIGxldCBpbnZhbGlkYXRlID0gU3RhdGUuRXhwZXJ0LmludmFsaWRhdGVcbiAgbGV0IGFkZF9kZXBlbmRlbmN5ID0gU3RhdGUuRXhwZXJ0LmFkZF9kZXBlbmRlbmN5XG4gIGxldCByZW1vdmVfZGVwZW5kZW5jeSA9IFN0YXRlLkV4cGVydC5yZW1vdmVfZGVwZW5kZW5jeVxuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubGV0IGNyZWF0ZSBzdGF0ZSBjaGlsZHJlbiB+ZiB+cmVkdWNlID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBjaGlsZHJlbiBpblxuICBpZiBsZW4gPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgcmVkdWNlciA9IEJhbGFuY2VkX3JlZHVjZXIuY3JlYXRlX2V4biAoKSB+bGVuIH5yZWR1Y2UgaW5cbiAgICBpZiBkZWJ1ZyB0aGVuIEJhbGFuY2VkX3JlZHVjZXIuaW52YXJpYW50IChjb25zdCAoKSkgcmVkdWNlcjtcbiAgICBsZXQgbm9kZSA9XG4gICAgICBFeHBlcnQxLk5vZGUuY3JlYXRlIHN0YXRlIChmdW4gKCkgLT5cbiAgICAgICAgbGV0IGEgPSBCYWxhbmNlZF9yZWR1Y2VyLmNvbXB1dGVfZXhuIHJlZHVjZXIgaW5cbiAgICAgICAgaWYgZGVidWcgdGhlbiBCYWxhbmNlZF9yZWR1Y2VyLmludmFyaWFudCAoY29uc3QgKCkpIHJlZHVjZXI7XG4gICAgICAgIGEpXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgRXhwZXJ0MS5Ob2RlLmFkZF9kZXBlbmRlbmN5XG4gICAgICAgIG5vZGVcbiAgICAgICAgKEV4cGVydDEuRGVwZW5kZW5jeS5jcmVhdGUgY2hpbGRyZW4uKGkpIH5vbl9jaGFuZ2U6KGZ1biBhIC0+XG4gICAgICAgICAgIEJhbGFuY2VkX3JlZHVjZXIuc2V0X2V4biByZWR1Y2VyIGkgKGYgYSk7XG4gICAgICAgICAgIGlmIGRlYnVnIHRoZW4gQmFsYW5jZWRfcmVkdWNlci5pbnZhcmlhbnQgKGNvbnN0ICgpKSByZWR1Y2VyKSlcbiAgICBkb25lO1xuICAgIFNvbWUgKEV4cGVydDEuTm9kZS53YXRjaCBub2RlKSlcbjs7XG4iLCJvcGVuISBDb3JlXG5tb2R1bGUgQ3V0b2ZmID0gQ3V0b2ZmLkZvcl9hbmFseXplclxubW9kdWxlIEludGVybmFsX25vZGVfaWQgPSBOb2RlX2lkXG5cbm1vZHVsZSBLaW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBBcnJheV9mb2xkXG4gICAgfCBBdCBvZiB7IGF0IDogVGltZV9ucy5BbHRlcm5hdGVfc2V4cC50IH1cbiAgICB8IEF0X2ludGVydmFscyBvZlxuICAgICAgICB7IGJhc2UgOiBUaW1lX25zLkFsdGVybmF0ZV9zZXhwLnRcbiAgICAgICAgOyBpbnRlcnZhbCA6IFRpbWVfbnMuU3Bhbi50XG4gICAgICAgIH1cbiAgICB8IEJpbmRfbGhzX2NoYW5nZVxuICAgIHwgQmluZF9tYWluXG4gICAgfCBDb25zdFxuICAgIHwgRXhwZXJ0XG4gICAgfCBGcmVlemVcbiAgICB8IElmX3Rlc3RfY2hhbmdlXG4gICAgfCBJZl90aGVuX2Vsc2VcbiAgICB8IEludmFsaWRcbiAgICB8IEpvaW5fbGhzX2NoYW5nZVxuICAgIHwgSm9pbl9tYWluXG4gICAgfCBNYXBcbiAgICB8IFNuYXBzaG90IG9mIHsgYXQgOiBUaW1lX25zLkFsdGVybmF0ZV9zZXhwLnQgfVxuICAgIHwgU3RlcF9mdW5jdGlvblxuICAgIHwgVW5pbml0aWFsaXplZFxuICAgIHwgVW5vcmRlcmVkX2FycmF5X2ZvbGRcbiAgICB8IFZhclxuICAgIHwgTWFwMlxuICAgIHwgTWFwM1xuICAgIHwgTWFwNFxuICAgIHwgTWFwNVxuICAgIHwgTWFwNlxuICAgIHwgTWFwN1xuICAgIHwgTWFwOFxuICAgIHwgTWFwOVxuICAgIHwgTWFwMTBcbiAgICB8IE1hcDExXG4gICAgfCBNYXAxMlxuICAgIHwgTWFwMTNcbiAgICB8IE1hcDE0XG4gICAgfCBNYXAxNVxuICBbQEBkZXJpdmluZyBzZXhwXVxuXG4gIGxldCB0b19zdHJpbmcgdCA9IFNleHAudG9fc3RyaW5nIChbJXNleHBfb2Y6IHRdIHQpXG5lbmRcblxubGV0IGtpbmQgKE5vZGUuUGFja2VkLlQgbm9kZSkgOiBLaW5kLnQgPVxuICBtYXRjaCBub2RlLmtpbmQgd2l0aFxuICB8IEFycmF5X2ZvbGQgXyAtPiBBcnJheV9mb2xkXG4gIHwgQXQgeyBhdDsgXyB9IC0+IEF0IHsgYXQgfVxuICB8IEF0X2ludGVydmFscyB7IGJhc2U7IGludGVydmFsOyBfIH0gLT4gQXRfaW50ZXJ2YWxzIHsgYmFzZTsgaW50ZXJ2YWwgfVxuICB8IEJpbmRfbGhzX2NoYW5nZSBfIC0+IEJpbmRfbGhzX2NoYW5nZVxuICB8IEJpbmRfbWFpbiBfIC0+IEJpbmRfbWFpblxuICB8IENvbnN0IF8gLT4gQ29uc3RcbiAgfCBFeHBlcnQgXyAtPiBFeHBlcnRcbiAgfCBGcmVlemUgXyAtPiBGcmVlemVcbiAgfCBJZl90ZXN0X2NoYW5nZSBfIC0+IElmX3Rlc3RfY2hhbmdlXG4gIHwgSWZfdGhlbl9lbHNlIF8gLT4gSWZfdGhlbl9lbHNlXG4gIHwgSW52YWxpZCAtPiBJbnZhbGlkXG4gIHwgSm9pbl9saHNfY2hhbmdlIF8gLT4gSm9pbl9saHNfY2hhbmdlXG4gIHwgSm9pbl9tYWluIF8gLT4gSm9pbl9tYWluXG4gIHwgTWFwIF8gLT4gTWFwXG4gIHwgU25hcHNob3QgeyBhdDsgXyB9IC0+IFNuYXBzaG90IHsgYXQgfVxuICB8IFN0ZXBfZnVuY3Rpb24gXyAtPiBTdGVwX2Z1bmN0aW9uXG4gIHwgVW5pbml0aWFsaXplZCAtPiBVbmluaXRpYWxpemVkXG4gIHwgVW5vcmRlcmVkX2FycmF5X2ZvbGQgXyAtPiBVbm9yZGVyZWRfYXJyYXlfZm9sZFxuICB8IFZhciBfIC0+IFZhclxuICB8IE1hcDIgXyAtPiBNYXAyXG4gIHwgTWFwMyBfIC0+IE1hcDNcbiAgfCBNYXA0IF8gLT4gTWFwNFxuICB8IE1hcDUgXyAtPiBNYXA1XG4gIHwgTWFwNiBfIC0+IE1hcDZcbiAgfCBNYXA3IF8gLT4gTWFwN1xuICB8IE1hcDggXyAtPiBNYXA4XG4gIHwgTWFwOSBfIC0+IE1hcDlcbiAgfCBNYXAxMCBfIC0+IE1hcDEwXG4gIHwgTWFwMTEgXyAtPiBNYXAxMVxuICB8IE1hcDEyIF8gLT4gTWFwMTJcbiAgfCBNYXAxMyBfIC0+IE1hcDEzXG4gIHwgTWFwMTQgXyAtPiBNYXAxNFxuICB8IE1hcDE1IF8gLT4gTWFwMTVcbjs7XG5cbm1vZHVsZSBEb3RfdXNlcl9pbmZvID0gc3RydWN0XG4gIGluY2x1ZGUgRG90X3VzZXJfaW5mb1xuXG4gIGxldCBkZWZhdWx0IH5uYW1lIH5raW5kIH5oZWlnaHQgPVxuICAgIGxldCBsYWJlbCA9XG4gICAgICBbIG5hbWU7IFNleHAudG9fc3RyaW5nIChbJXNleHBfb2Y6IEtpbmQudF0ga2luZCk7IHNwcmludGYgXCJoZWlnaHQ9JWRcIiBoZWlnaHQgXVxuICAgIGluXG4gICAgRG90X3VzZXJfaW5mby5kb3QgfmxhYmVsIH5hdHRyaWJ1dGVzOlN0cmluZy5NYXAuZW1wdHlcbiAgOztcbmVuZFxuXG5tb2R1bGUgTm9kZV9pZCA9IEludFxuXG5tb2R1bGUgU3RhYmlsaXphdGlvbl9udW0gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTdGFiaWxpemF0aW9uX251bVxuICBpbmNsdWRlIFN0YWJpbGl6YXRpb25fbnVtLkZvcl9hbmFseXplclxuZW5kXG5cbmxldCByZWNvbXB1dGVkX2F0IChOb2RlLlBhY2tlZC5UIG5vZGUpID0gbm9kZS5yZWNvbXB1dGVkX2F0XG5sZXQgY2hhbmdlZF9hdCAoTm9kZS5QYWNrZWQuVCBub2RlKSA9IG5vZGUuY2hhbmdlZF9hdFxubGV0IG5vZGVfaWQgKE5vZGUuUGFja2VkLlQgbm9kZSkgPSBJbnRlcm5hbF9ub2RlX2lkLnRvX3N0cmluZyBub2RlLmlkIHw+IE5vZGVfaWQub2Zfc3RyaW5nXG5sZXQgY3V0b2ZmIChOb2RlLlBhY2tlZC5UIG5vZGUpID0gQ3V0b2ZmLm9mX2N1dG9mZiBub2RlLmN1dG9mZlxubGV0IHVzZXJfaW5mbyAoTm9kZS5QYWNrZWQuVCBub2RlKSA9IG5vZGUudXNlcl9pbmZvXG5sZXQgaGVpZ2h0IChOb2RlLlBhY2tlZC5UIG5vZGUpID0gbm9kZS5oZWlnaHRcbmxldCBpdGVyaV9jaGlsZHJlbiAoTm9kZS5QYWNrZWQuVCBub2RlKSA9IE5vZGUuaXRlcmlfY2hpbGRyZW4gbm9kZVxuXG5sZXQgbWF5YmVfaXRlcl9vbl9iaW5kX25vZGVzX2NyZWF0ZWRfb25fcmhzIChOb2RlLlBhY2tlZC5UIG5vZGUpIH5mID1cbiAgbWF0Y2ggbm9kZS5raW5kIHdpdGhcbiAgfCBCaW5kX2xoc19jaGFuZ2UgYmluZCAtPiBCaW5kLml0ZXJfbm9kZXNfY3JlYXRlZF9vbl9yaHMgYmluZCB+ZlxuICB8IF8gLT4gKClcbjs7XG5cbmxldCBkaXJlY3RseV9vYnNlcnZlZCA9IFN0YXRlLmRpcmVjdGx5X29ic2VydmVkXG5cbmxldCB0cmF2ZXJzZSBwYWNrZWRfbGlzdCB+YWRkX25vZGUgPVxuICBsZXQgbWFwX29mX2l0ZXIgaXRlcmF0b3IgfmYgPVxuICAgIGxldCBvdXQgPSByZWYgW10gaW5cbiAgICBpdGVyYXRvciB+ZjooZnVuIHggLT4gb3V0IDo9IGYgeCA6OiAhb3V0KTtcbiAgICBMaXN0LnJldiAhb3V0XG4gIGluXG4gIE5vZGUuUGFja2VkLml0ZXJfZGVzY2VuZGFudHMgcGFja2VkX2xpc3QgfmY6KGZ1biBwYWNrZWRfbm9kZSAtPlxuICAgIGxldCBjaGlsZHJlbiA9XG4gICAgICBtYXBfb2ZfaXRlclxuICAgICAgICAoZnVuIH5mIC0+IGl0ZXJpX2NoaWxkcmVuIHBhY2tlZF9ub2RlIH5mOihmdW4gXyBub2RlIC0+IGYgbm9kZSkpXG4gICAgICAgIH5mOm5vZGVfaWRcbiAgICBpblxuICAgIGxldCBiaW5kX2NoaWxkcmVuID1cbiAgICAgIG1hcF9vZl9pdGVyIChtYXliZV9pdGVyX29uX2JpbmRfbm9kZXNfY3JlYXRlZF9vbl9yaHMgcGFja2VkX25vZGUpIH5mOm5vZGVfaWRcbiAgICBpblxuICAgIGxldCBpZCA9IG5vZGVfaWQgcGFja2VkX25vZGUgaW5cbiAgICBsZXQga2luZCA9IGtpbmQgcGFja2VkX25vZGUgaW5cbiAgICBsZXQgY3V0b2ZmID0gY3V0b2ZmIHBhY2tlZF9ub2RlIGluXG4gICAgbGV0IHVzZXJfaW5mbyA9IHVzZXJfaW5mbyBwYWNrZWRfbm9kZSBpblxuICAgIGxldCByZWNvbXB1dGVkX2F0ID0gcmVjb21wdXRlZF9hdCBwYWNrZWRfbm9kZSBpblxuICAgIGxldCBjaGFuZ2VkX2F0ID0gY2hhbmdlZF9hdCBwYWNrZWRfbm9kZSBpblxuICAgIGxldCBoZWlnaHQgPSBoZWlnaHQgcGFja2VkX25vZGUgaW5cbiAgICBhZGRfbm9kZVxuICAgICAgfmlkXG4gICAgICB+a2luZFxuICAgICAgfmN1dG9mZlxuICAgICAgfmNoaWxkcmVuXG4gICAgICB+YmluZF9jaGlsZHJlblxuICAgICAgfnVzZXJfaW5mb1xuICAgICAgfnJlY29tcHV0ZWRfYXRcbiAgICAgIH5jaGFuZ2VkX2F0XG4gICAgICB+aGVpZ2h0KVxuOztcbiIsIm9wZW4hIENvcmVcblxubGV0IHByaW50X25vZGUgb3V0IH5uYW1lIH5raW5kIH5oZWlnaHQgfnVzZXJfaW5mbyA9XG4gIGxldCBkZWZhdWx0ID0gRm9yX2FuYWx5emVyLkRvdF91c2VyX2luZm8uZGVmYXVsdCB+bmFtZSB+a2luZCB+aGVpZ2h0IGluXG4gIGxldCBpbmZvID1cbiAgICBtYXRjaCB1c2VyX2luZm8gd2l0aFxuICAgIHwgTm9uZSAtPiBkZWZhdWx0XG4gICAgfCBTb21lIHVzZXJfaW5mbyAtPiBGb3JfYW5hbHl6ZXIuRG90X3VzZXJfaW5mby5hcHBlbmQgZGVmYXVsdCB1c2VyX2luZm9cbiAgaW5cbiAgZnByaW50ZlxuICAgIG91dFxuICAgIFwiJXNcXG5cIlxuICAgIChGb3JfYW5hbHl6ZXIuRG90X3VzZXJfaW5mby50b19zdHJpbmcgfm5hbWUgKEZvcl9hbmFseXplci5Eb3RfdXNlcl9pbmZvLnRvX2RvdCBpbmZvKSlcbjs7XG5cbmxldCBzYXZlX2RvdCB+ZW1pdF9iaW5kX2VkZ2VzIG91dCB0cyA9XG4gIGxldCBub2RlX25hbWUgPVxuICAgIGlmIGFtX3J1bm5pbmdfdGVzdFxuICAgIHRoZW4gZnVuIF8gLT4gXCJuIyMjXCJcbiAgICBlbHNlIGZ1biBpZCAtPiBcIm5cIiBeIEZvcl9hbmFseXplci5Ob2RlX2lkLnRvX3N0cmluZyBpZFxuICBpblxuICBmcHJpbnRmIG91dCBcImRpZ3JhcGggRyB7XFxuXCI7XG4gIGZwcmludGYgb3V0IFwiICByYW5rZGlyID0gQlRcXG5cIjtcbiAgbGV0IHNlZW4gPSBGb3JfYW5hbHl6ZXIuTm9kZV9pZC5IYXNoX3NldC5jcmVhdGUgKCkgaW5cbiAgbGV0IGJpbmRfZWRnZXMgPSByZWYgW10gaW5cbiAgRm9yX2FuYWx5emVyLnRyYXZlcnNlXG4gICAgdHNcbiAgICB+YWRkX25vZGU6XG4gICAgICAoZnVuXG4gICAgICAgIH5pZFxuICAgICAgICB+a2luZFxuICAgICAgICB+Y3V0b2ZmOl9cbiAgICAgICAgfmNoaWxkcmVuXG4gICAgICAgIH5iaW5kX2NoaWxkcmVuXG4gICAgICAgIH51c2VyX2luZm9cbiAgICAgICAgfnJlY29tcHV0ZWRfYXQ6X1xuICAgICAgICB+Y2hhbmdlZF9hdDpfXG4gICAgICAgIH5oZWlnaHRcbiAgICAgICAgLT5cbiAgICBsZXQgbmFtZSA9IG5vZGVfbmFtZSBpZCBpblxuICAgIEhhc2hfc2V0LmFkZCBzZWVuIGlkO1xuICAgIHByaW50X25vZGUgb3V0IH5uYW1lIH5raW5kIH5oZWlnaHQgfnVzZXJfaW5mbztcbiAgICBMaXN0Lml0ZXIgY2hpbGRyZW4gfmY6KGZ1biBjaGlsZF9pZCAtPlxuICAgICAgZnByaW50ZiBvdXQgXCIgICVzIC0+ICVzXFxuXCIgKG5vZGVfbmFtZSBjaGlsZF9pZCkgbmFtZSk7XG4gICAgTGlzdC5pdGVyIGJpbmRfY2hpbGRyZW4gfmY6KGZ1biBiaW5kX2NoaWxkX2lkIC0+XG4gICAgICBiaW5kX2VkZ2VzIDo9IChiaW5kX2NoaWxkX2lkLCBpZCkgOjogIWJpbmRfZWRnZXMpKTtcbiAgaWYgZW1pdF9iaW5kX2VkZ2VzXG4gIHRoZW5cbiAgICBMaXN0Lml0ZXIgIWJpbmRfZWRnZXMgfmY6KGZ1biAoYmluZF9jaGlsZF9pZCwgaWQpIC0+XG4gICAgICBpZiBIYXNoX3NldC5tZW0gc2VlbiBiaW5kX2NoaWxkX2lkXG4gICAgICB0aGVuXG4gICAgICAgIGZwcmludGYgb3V0IFwiICAlcyAtPiAlcyBbc3R5bGU9ZGFzaGVkXVxcblwiIChub2RlX25hbWUgaWQpIChub2RlX25hbWUgYmluZF9jaGlsZF9pZCkpO1xuICBmcHJpbnRmIG91dCBcIn1cXG4lIVwiXG47O1xuXG5sZXQgc2F2ZV9kb3RfdG9fZmlsZSB+ZW1pdF9iaW5kX2VkZ2VzIGZpbGUgdHMgPVxuICBPdXRfY2hhbm5lbC53aXRoX2ZpbGUgZmlsZSB+ZjooZnVuIG91dCAtPiBzYXZlX2RvdCB+ZW1pdF9iaW5kX2VkZ2VzIG91dCB0cylcbjs7XG4iLCIoKiBUaGlzIG1vZHVsZSBpcyBtb3N0bHkgYSB3cmFwcGVyIGFyb3VuZCBbU3RhdGVdIGZ1bmN0aW9ucy4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEluY3JlbWVudGFsX2ludGZcblxubW9kdWxlIHR5cGUgSW5jcmVtZW50YWxfY29uZmlnID0gQ29uZmlnLkluY3JlbWVudGFsX2NvbmZpZ1xuXG5tb2R1bGUgQ29uZmlnID0gQ29uZmlnXG5tb2R1bGUgRm9yX2FuYWx5emVyID0gRm9yX2FuYWx5emVyXG5cbmxldCBkZWZhdWx0X21heF9oZWlnaHRfYWxsb3dlZCA9IDEyOFxuXG5tb2R1bGUgR2VuZXJpYyA9IHN0cnVjdFxuICBtb2R1bGUgQ3V0b2ZmID0gQ3V0b2ZmXG4gIG1vZHVsZSBTdGVwX2Z1bmN0aW9uID0gU3RlcF9mdW5jdGlvblxuXG4gIG1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgU3RhdGVcblxuICAgIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICAgIHR5cGUgc3RhdGVfd2l0bmVzcyBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgICB2YWwgdCA6IHRcbiAgICBlbmRcblxuICAgIGxldCBjcmVhdGVfaW50ZXJuYWwgPSBjcmVhdGVcblxuICAgIGxldCBjcmVhdGUgPyhtYXhfaGVpZ2h0X2FsbG93ZWQgPSBkZWZhdWx0X21heF9oZWlnaHRfYWxsb3dlZCkgKCkgOiAobW9kdWxlIFMpID1cbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgc3RhdGVfd2l0bmVzcyBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgICAgIGxldCB0ID0gY3JlYXRlIChtb2R1bGUgQ29uZmlnLkRlZmF1bHQgKCkpIH5tYXhfaGVpZ2h0X2FsbG93ZWRcbiAgICAgIGVuZClcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgU2NvcGUgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFNjb3BlXG5cbiAgICBsZXQgY3VycmVudCAoc3RhdGUgOiBTdGF0ZS50KSAoKSA9IHN0YXRlLmN1cnJlbnRfc2NvcGVcbiAgICBsZXQgd2l0aGluIHN0YXRlIHQgfmYgPSBTdGF0ZS53aXRoaW5fc2NvcGUgc3RhdGUgdCB+ZlxuICBlbmRcblxuICBpbmNsdWRlIE5vZGVcblxuICBtb2R1bGUgUGFja2VkID0gc3RydWN0XG4gICAgaW5jbHVkZSBQYWNrZWRcblxuICAgIGxldCBzYXZlX2RvdCA/KGVtaXRfYmluZF9lZGdlcyA9IHRydWUpID0gTm9kZV90b19kb3Quc2F2ZV9kb3QgfmVtaXRfYmluZF9lZGdlc1xuXG4gICAgbGV0IHNhdmVfZG90X3RvX2ZpbGUgPyhlbWl0X2JpbmRfZWRnZXMgPSB0cnVlKSA9XG4gICAgICBOb2RlX3RvX2RvdC5zYXZlX2RvdF90b19maWxlIH5lbWl0X2JpbmRfZWRnZXNcbiAgICA7O1xuICBlbmRcblxuICBsZXQgc3RhdGUgdCA9IHQuc3RhdGVcbiAgbGV0IHBhY2sgdCA9IFBhY2tlZC5UIHRcbiAgbGV0IGNvbnN0IHN0YXRlIGEgPSBTdGF0ZS5jb25zdCBzdGF0ZSBhXG4gIGxldCByZXR1cm4gPSBjb25zdFxuICBsZXQgb2JzZXJ2ZSA9IFN0YXRlLmNyZWF0ZV9vYnNlcnZlclxuICBsZXQgbWFwID0gU3RhdGUubWFwXG4gIGxldCBiaW5kID0gU3RhdGUuYmluZFxuXG4gIG1vZHVsZSBOX2FyeV9tYXBfYW5kX2JpbmQgPSBzdHJ1Y3RcbiAgICBsZXQgbWFwMiA9IFN0YXRlLm1hcDJcbiAgICBsZXQgbWFwMyA9IFN0YXRlLm1hcDNcbiAgICBsZXQgbWFwNCA9IFN0YXRlLm1hcDRcbiAgICBsZXQgbWFwNSA9IFN0YXRlLm1hcDVcbiAgICBsZXQgbWFwNiA9IFN0YXRlLm1hcDZcbiAgICBsZXQgbWFwNyA9IFN0YXRlLm1hcDdcbiAgICBsZXQgbWFwOCA9IFN0YXRlLm1hcDhcbiAgICBsZXQgbWFwOSA9IFN0YXRlLm1hcDlcbiAgICBsZXQgbWFwMTAgPSBTdGF0ZS5tYXAxMFxuICAgIGxldCBtYXAxMSA9IFN0YXRlLm1hcDExXG4gICAgbGV0IG1hcDEyID0gU3RhdGUubWFwMTJcbiAgICBsZXQgbWFwMTMgPSBTdGF0ZS5tYXAxM1xuICAgIGxldCBtYXAxNCA9IFN0YXRlLm1hcDE0XG4gICAgbGV0IG1hcDE1ID0gU3RhdGUubWFwMTVcbiAgICBsZXQgYmluZDIgPSBTdGF0ZS5iaW5kMlxuICAgIGxldCBiaW5kMyA9IFN0YXRlLmJpbmQzXG4gICAgbGV0IGJpbmQ0ID0gU3RhdGUuYmluZDRcbiAgZW5kXG5cbiAgaW5jbHVkZSBOX2FyeV9tYXBfYW5kX2JpbmRcblxuICBtb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA+PnwgKSB0IGYgPSBtYXAgdCB+ZlxuICAgIGxldCAoID4+PSApIHQgZiA9IGJpbmQgdCB+ZlxuICBlbmRcblxuICBpbmNsdWRlIEluZml4XG5cbiAgbGV0IGpvaW4gPSBTdGF0ZS5qb2luXG4gIGxldCBpZl8gPSBTdGF0ZS5pZl9cbiAgbGV0IGxhenlfZnJvbV9mdW4gc3RhdGUgZiA9IFN0YXRlLmxhenlfZnJvbV9mdW4gc3RhdGUgfmZcbiAgbGV0IGRlZmF1bHRfaGFzaF90YWJsZV9pbml0aWFsX3NpemUgPSBTdGF0ZS5kZWZhdWx0X2hhc2hfdGFibGVfaW5pdGlhbF9zaXplXG4gIGxldCBtZW1vaXplX2Z1bl9ieV9rZXkgPSBTdGF0ZS5tZW1vaXplX2Z1bl9ieV9rZXlcblxuICBsZXQgbWVtb2l6ZV9mdW4gP2luaXRpYWxfc2l6ZSBzdGF0ZSBoYXNoYWJsZSBmID1cbiAgICBtZW1vaXplX2Z1bl9ieV9rZXkgc3RhdGUgP2luaXRpYWxfc2l6ZSBoYXNoYWJsZSBGbi5pZCBmXG4gIDs7XG5cbiAgbGV0IGFycmF5X2ZvbGQgc3RhdGUgdHMgfmluaXQgfmYgPSBTdGF0ZS5hcnJheV9mb2xkIHN0YXRlIHRzIH5pbml0IH5mXG4gIGxldCByZWR1Y2VfYmFsYW5jZWQgc3RhdGUgdHMgfmYgfnJlZHVjZSA9IFJlZHVjZV9iYWxhbmNlZC5jcmVhdGUgc3RhdGUgdHMgfmYgfnJlZHVjZVxuXG4gIG1vZHVsZSBVbm9yZGVyZWRfYXJyYXlfZm9sZF91cGRhdGUgPSBTdGF0ZS5Vbm9yZGVyZWRfYXJyYXlfZm9sZF91cGRhdGVcblxuICBsZXQgdW5vcmRlcmVkX2FycmF5X2ZvbGQgPSBTdGF0ZS51bm9yZGVyZWRfYXJyYXlfZm9sZFxuICBsZXQgb3B0X3Vub3JkZXJlZF9hcnJheV9mb2xkID0gU3RhdGUub3B0X3Vub3JkZXJlZF9hcnJheV9mb2xkXG4gIGxldCBhbGwgPSBTdGF0ZS5hbGxcbiAgbGV0IGV4aXN0cyA9IFN0YXRlLmV4aXN0c1xuICBsZXQgZm9yX2FsbCA9IFN0YXRlLmZvcl9hbGxcbiAgbGV0IGJvdGggPSBTdGF0ZS5ib3RoXG4gIGxldCBzdW0gPSBTdGF0ZS5zdW1cbiAgbGV0IG9wdF9zdW0gPSBTdGF0ZS5vcHRfc3VtXG4gIGxldCBzdW1faW50ID0gU3RhdGUuc3VtX2ludFxuICBsZXQgc3VtX2Zsb2F0ID0gU3RhdGUuc3VtX2Zsb2F0XG5cbiAgbW9kdWxlIFZhciA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVmFyXG5cbiAgICBsZXQgY3JlYXRlID0gU3RhdGUuY3JlYXRlX3ZhclxuICAgIGxldCBzZXQgPSBTdGF0ZS5zZXRfdmFyXG4gICAgbGV0IHZhbHVlIHQgPSB0LnZhbHVlXG4gICAgbGV0IHdhdGNoIHQgPSB0LndhdGNoXG5cbiAgICAoKiBXZSBvdmVycmlkZSBbc2V4cF9vZl90XSB0byBqdXN0IHNob3cgdGhlIHZhbHVlLCByYXRoZXIgdGhhbiB0aGUgaW50ZXJuYWxcbiAgICAgICByZXByZXNlbnRhdGlvbi4gKilcbiAgICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gdC52YWx1ZSB8PiBbJXNleHBfb2Y6IGFdXG4gICAgbGV0IHJlcGxhY2UgdCB+ZiA9IHNldCB0IChmIChsYXRlc3RfdmFsdWUgdCkpXG4gIGVuZFxuXG4gIG1vZHVsZSBPYnNlcnZlciA9IHN0cnVjdFxuICAgIGluY2x1ZGUgT2JzZXJ2ZXJcblxuICAgIG1vZHVsZSBVcGRhdGUgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgIHwgSW5pdGlhbGl6ZWQgb2YgJ2FcbiAgICAgICAgfCBDaGFuZ2VkIG9mICdhICogJ2FcbiAgICAgICAgfCBJbnZhbGlkYXRlZFxuICAgICAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cbiAgICBlbmRcblxuICAgIGxldCBvbl91cGRhdGVfZXhuIHQgfihmIDogXyBVcGRhdGUudCAtPiB1bml0KSA9XG4gICAgICBTdGF0ZS5vYnNlcnZlcl9vbl91cGRhdGVfZXhuIHQgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgTmVjZXNzYXJ5IGEgLT4gZiAoSW5pdGlhbGl6ZWQgYSlcbiAgICAgICAgfCBDaGFuZ2VkIChhMSwgYTIpIC0+IGYgKENoYW5nZWQgKGExLCBhMikpXG4gICAgICAgIHwgSW52YWxpZGF0ZWQgLT4gZiBJbnZhbGlkYXRlZFxuICAgICAgICB8IFVubmVjZXNzYXJ5IC0+XG4gICAgICAgICAgZmFpbHdpdGhzXG4gICAgICAgICAgICB+aGVyZTpbJWhlcmVdXG4gICAgICAgICAgICBcIkluY3JlbWVudGFsIGJ1ZyAtLSBPYnNlcnZlci5vbl91cGRhdGVfZXhuIGdvdCB1bmV4cGVjdGVkIHVwZGF0ZSBVbm5lY2Vzc2FyeVwiXG4gICAgICAgICAgICB0XG4gICAgICAgICAgICBbJXNleHBfb2Y6IF8gdF0pXG4gICAgOztcblxuICAgIGxldCBkaXNhbGxvd19mdXR1cmVfdXNlIHQgPSBTdGF0ZS5kaXNhbGxvd19mdXR1cmVfdXNlICF0XG4gICAgbGV0IHZhbHVlID0gU3RhdGUub2JzZXJ2ZXJfdmFsdWVcbiAgICBsZXQgdmFsdWVfZXhuID0gU3RhdGUub2JzZXJ2ZXJfdmFsdWVfZXhuXG5cbiAgICAoKiBXZSBvdmVycmlkZSBbc2V4cF9vZl90XSB0byBqdXN0IHNob3cgdGhlIHZhbHVlLCByYXRoZXIgdGhhbiB0aGUgaW50ZXJuYWxcbiAgICAgICByZXByZXNlbnRhdGlvbi4gKilcbiAgICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSAodCA6IF8gdCkgPVxuICAgICAgbWF0Y2ggIXQuc3RhdGUgd2l0aFxuICAgICAgfCBDcmVhdGVkIC0+IFslbWVzc2FnZSBcIjx1bnN0YWJpbGl6ZWQ+XCJdXG4gICAgICB8IERpc2FsbG93ZWQgfCBVbmxpbmtlZCAtPiBbJW1lc3NhZ2UgXCI8ZGlzYWxsb3dlZD5cIl1cbiAgICAgIHwgSW5fdXNlIC0+XG4gICAgICAgIGxldCB1b3B0ID0gIXQub2JzZXJ2aW5nLnZhbHVlX29wdCBpblxuICAgICAgICBpZiBVb3B0LmlzX25vbmUgdW9wdFxuICAgICAgICB0aGVuIFslbWVzc2FnZSBcIjxpbnZhbGlkPlwiXVxuICAgICAgICBlbHNlIFslc2V4cCAoVW9wdC51bnNhZmVfdmFsdWUgdW9wdCA6IGEpXVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBCZWZvcmVfb3JfYWZ0ZXIgPSBCZWZvcmVfb3JfYWZ0ZXJcblxuICBtb2R1bGUgQ2xvY2sgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFN0YXRlLkNsb2NrXG5cbiAgICBsZXQgc3RhdGUgPSBpbmNyX3N0YXRlXG5cbiAgICBsZXQgZGVmYXVsdF90aW1pbmdfd2hlZWxfY29uZmlnID1cbiAgICAgIGxldCBhbGFybV9wcmVjaXNpb24gPSBBbGFybV9wcmVjaXNpb24uYWJvdXRfb25lX21pbGxpc2Vjb25kIGluXG4gICAgICBsZXQgbGV2ZWxfYml0cyA9IFsgMTQ7IDEzOyA1IF0gaW5cbiAgICAgIFRpbWluZ193aGVlbC5Db25maWcuY3JlYXRlXG4gICAgICAgIH5hbGFybV9wcmVjaXNpb25cbiAgICAgICAgfmxldmVsX2JpdHM6XG4gICAgICAgICAgKFRpbWluZ193aGVlbC5MZXZlbF9iaXRzLmNyZWF0ZV9leG4gbGV2ZWxfYml0cyB+ZXh0ZW5kX3RvX21heF9udW1fYml0czp0cnVlKVxuICAgICAgICAoKVxuICAgIDs7XG5cbiAgICBsZXQgY3JlYXRlIHN0YXRlID8odGltaW5nX3doZWVsX2NvbmZpZyA9IGRlZmF1bHRfdGltaW5nX3doZWVsX2NvbmZpZykgfnN0YXJ0ICgpID1cbiAgICAgICgqIE1ha2Ugc3VyZSBbc3RhcnRdIGlzIHJvdW5kZWQgdG8gdGhlIG5lYXJlc3QgbWljcm9zZWNvbmQuICBPdGhlcndpc2UsIGlmIHlvdVxuICAgICAgICAgZmVlZCBbQ2xvY2subm93ICgpXSB0byBhIHRpbWUgZnVuY3Rpb24sIGl0IGNhbiBiZSByb3VuZGVkIGRvd24gdG8gYSB0aW1lIGluXG4gICAgICAgICB0aGUgcGFzdCwgY2F1c2luZyBlcnJvcnMuICopXG4gICAgICBsZXQgc3RhcnQgPVxuICAgICAgICBUaW1lX25zLm9mX3RpbWVfZmxvYXRfcm91bmRfbmVhcmVzdF9taWNyb3NlY29uZFxuICAgICAgICAgIChUaW1lX25zLnRvX3RpbWVfZmxvYXRfcm91bmRfbmVhcmVzdF9taWNyb3NlY29uZCBzdGFydClcbiAgICAgIGluXG4gICAgICBTdGF0ZS5jcmVhdGVfY2xvY2sgc3RhdGUgfnRpbWluZ193aGVlbF9jb25maWcgfnN0YXJ0XG4gICAgOztcblxuICAgIGxldCBhbGFybV9wcmVjaXNpb24gdCA9IFRpbWluZ193aGVlbC5hbGFybV9wcmVjaXNpb24gdC50aW1pbmdfd2hlZWxcbiAgICBsZXQgdGltaW5nX3doZWVsX2xlbmd0aCA9IFN0YXRlLnRpbWluZ193aGVlbF9sZW5ndGhcbiAgICBsZXQgbm93ID0gU3RhdGUubm93XG4gICAgbGV0IHdhdGNoX25vdyB0ID0gdC5ub3cud2F0Y2hcbiAgICBsZXQgYXQgPSBTdGF0ZS5hdFxuICAgIGxldCBhZnRlciA9IFN0YXRlLmFmdGVyXG4gICAgbGV0IGF0X2ludGVydmFscyA9IFN0YXRlLmF0X2ludGVydmFsc1xuICAgIGxldCBhZHZhbmNlX2Nsb2NrID0gU3RhdGUuYWR2YW5jZV9jbG9ja1xuICAgIGxldCBhZHZhbmNlX2Nsb2NrX2J5IHQgc3BhbiA9IGFkdmFuY2VfY2xvY2sgdCB+dG9fOihUaW1lX25zLmFkZCAobm93IHQpIHNwYW4pXG4gICAgbGV0IGluY3JlbWVudGFsX3N0ZXBfZnVuY3Rpb24gPSBTdGF0ZS5pbmNyZW1lbnRhbF9zdGVwX2Z1bmN0aW9uXG5cbiAgICBsZXQgc3RlcF9mdW5jdGlvbiB0IH5pbml0IHN0ZXBzID1cbiAgICAgIGluY3JlbWVudGFsX3N0ZXBfZnVuY3Rpb25cbiAgICAgICAgdFxuICAgICAgICAoY29uc3QgKGluY3Jfc3RhdGUgdCkgKFN0ZXBfZnVuY3Rpb24uY3JlYXRlX2V4biB+aW5pdCB+c3RlcHMpKVxuICAgIDs7XG5cbiAgICBsZXQgc25hcHNob3QgPSBTdGF0ZS5zbmFwc2hvdFxuICBlbmRcblxuICBsZXQgZnJlZXplID8od2hlbl8gPSBmdW4gXyAtPiB0cnVlKSB0ID0gU3RhdGUuZnJlZXplIHQgfm9ubHlfZnJlZXplX3doZW46d2hlbl9cbiAgbGV0IGRlcGVuZF9vbiB0IH5kZXBlbmRfb24gPSBTdGF0ZS5kZXBlbmRfb24gdCB+ZGVwZW5kX29uXG4gIGxldCBuZWNlc3NhcnlfaWZfYWxpdmUgPSBTdGF0ZS5uZWNlc3NhcnlfaWZfYWxpdmVcblxuICBtb2R1bGUgVXBkYXRlID0gT25fdXBkYXRlX2hhbmRsZXIuTm9kZV91cGRhdGVcblxuICBsZXQgb25fdXBkYXRlID0gU3RhdGUubm9kZV9vbl91cGRhdGVcbiAgbGV0IHN0YWJpbGl6ZSBzdGF0ZSA9IFN0YXRlLnN0YWJpbGl6ZSBzdGF0ZVxuICBsZXQgYW1fc3RhYmlsaXppbmcgc3RhdGUgPSBTdGF0ZS5hbV9zdGFiaWxpemluZyBzdGF0ZVxuXG4gIGxldCBzYXZlX2RvdCA/KGVtaXRfYmluZF9lZGdlcyA9IHRydWUpIHQgb3V0ID1cbiAgICBQYWNrZWQuc2F2ZV9kb3QgfmVtaXRfYmluZF9lZGdlcyBvdXQgKFN0YXRlLmRpcmVjdGx5X29ic2VydmVkIHQpXG4gIDs7XG5cbiAgbGV0IHNhdmVfZG90X3RvX2ZpbGUgPyhlbWl0X2JpbmRfZWRnZXMgPSB0cnVlKSB0IGZpbGUgPVxuICAgIFBhY2tlZC5zYXZlX2RvdF90b19maWxlIH5lbWl0X2JpbmRfZWRnZXMgZmlsZSAoU3RhdGUuZGlyZWN0bHlfb2JzZXJ2ZWQgdClcbiAgOztcblxuICBtb2R1bGUgTm9kZV92YWx1ZSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB8IEludmFsaWRcbiAgICAgIHwgTmVjZXNzYXJ5X21heWJlX3N0YWxlIG9mICdhIG9wdGlvblxuICAgICAgfCBVbm5lY2Vzc2FyeV9tYXliZV9zdGFsZSBvZiAnYSBvcHRpb25cbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICBsZXQgbm9kZV92YWx1ZSB0IDogXyBOb2RlX3ZhbHVlLnQgPVxuICAgIGlmIG5vdCAoaXNfdmFsaWQgdClcbiAgICB0aGVuIEludmFsaWRcbiAgICBlbHNlIGlmIGlzX25lY2Vzc2FyeSB0XG4gICAgdGhlbiBOZWNlc3NhcnlfbWF5YmVfc3RhbGUgKFVvcHQudG9fb3B0aW9uIHQudmFsdWVfb3B0KVxuICAgIGVsc2UgVW5uZWNlc3NhcnlfbWF5YmVfc3RhbGUgKFVvcHQudG9fb3B0aW9uIHQudmFsdWVfb3B0KVxuICA7O1xuXG4gICgqIFdlIG92ZXJyaWRlIFtzZXhwX29mX3RdIHRvIHNob3cganVzdCB0aGUgdmFsdWUsIHJhdGhlciB0aGFuIHRoZSBpbnRlcm5hbFxuICAgICByZXByZXNlbnRhdGlvbi4gIFdlIG9ubHkgc2hvdyB0aGUgdmFsdWUgaWYgaXQgaXMgbmVjZXNzYXJ5IGFuZCB2YWxpZC4gKilcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9XG4gICAgaWYgbm90IChpc192YWxpZCB0KVxuICAgIHRoZW4gXCI8aW52YWxpZD5cIiB8PiBbJXNleHBfb2Y6IHN0cmluZ11cbiAgICBlbHNlIGlmIG5vdCAoaXNfbmVjZXNzYXJ5IHQpXG4gICAgdGhlbiBcIjx1bm5lY2Vzc2FyeT5cIiB8PiBbJXNleHBfb2Y6IHN0cmluZ11cbiAgICBlbHNlIGlmIFVvcHQuaXNfbm9uZSB0LnZhbHVlX29wdFxuICAgIHRoZW4gXCI8dW5jb21wdXRlZD5cIiB8PiBbJXNleHBfb2Y6IHN0cmluZ11cbiAgICBlbHNlIHVuc2FmZV92YWx1ZSB0IHw+IFslc2V4cF9vZjogYV1cbiAgOztcblxuICBtb2R1bGUgRXhwZXJ0ID0gRXhwZXJ0MVxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICAgIGxldCAoID4+PSApID0gKCA+Pj0gKVxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgbGV0IG1hcCA9IG1hcFxuICAgICAgbGV0IGJvdGggdDEgdDIgPSBtYXAyIHQxIHQyIH5mOihmdW4geDEgeDIgLT4geDEsIHgyKVxuXG4gICAgICBpbmNsdWRlIE5fYXJ5X21hcF9hbmRfYmluZFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3RcbiAgICAgICAgbGV0IHdhdGNoID0gVmFyLndhdGNoXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgbGV0IHdlYWtfbWVtb2l6ZV9mdW5fYnlfa2V5ID0gU3RhdGUud2Vha19tZW1vaXplX2Z1bl9ieV9rZXlcblxuICBsZXQgd2Vha19tZW1vaXplX2Z1biA/aW5pdGlhbF9zaXplIHN0YXRlIGhhc2hhYmxlIGYgPVxuICAgIHdlYWtfbWVtb2l6ZV9mdW5fYnlfa2V5ID9pbml0aWFsX3NpemUgc3RhdGUgaGFzaGFibGUgRm4uaWQgZlxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlX3dpdGhfY29uZmlnIChJbmNyZW1lbnRhbF9jb25maWcgOiBJbmNyZW1lbnRhbF9jb25maWcpICgpID0gc3RydWN0XG4gIHR5cGUgc3RhdGVfd2l0bmVzcyBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGluY2x1ZGUgR2VuZXJpY1xuXG4gIG1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgU3RhdGVcblxuICAgIGxldCB0ID0gY3JlYXRlX2ludGVybmFsIChtb2R1bGUgSW5jcmVtZW50YWxfY29uZmlnKSB+bWF4X2hlaWdodF9hbGxvd2VkOjEyOFxuICBlbmRcblxuICBtb2R1bGUgQ2xvY2sgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIENsb2NrXG5cbiAgICBsZXQgY3JlYXRlID90aW1pbmdfd2hlZWxfY29uZmlnIH5zdGFydCAoKSA9XG4gICAgICBjcmVhdGUgP3RpbWluZ193aGVlbF9jb25maWcgU3RhdGUudCB+c3RhcnQgKClcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRXhwZXJ0ID0gc3RydWN0XG4gICAgaW5jbHVkZSBFeHBlcnRcblxuICAgIG1vZHVsZSBOb2RlID0gc3RydWN0XG4gICAgICBpbmNsdWRlIE5vZGVcblxuICAgICAgbGV0IGNyZWF0ZSA/b25fb2JzZXJ2YWJpbGl0eV9jaGFuZ2UgZiA9IGNyZWF0ZSBTdGF0ZS50ID9vbl9vYnNlcnZhYmlsaXR5X2NoYW5nZSBmXG4gICAgZW5kXG5cbiAgICBtb2R1bGUgU3RlcF9yZXN1bHQgPSBTdGF0ZS5TdGVwX3Jlc3VsdFxuXG4gICAgbGV0IGRvX29uZV9zdGVwX29mX3N0YWJpbGl6ZSAoKSA9IFN0YXRlLmRvX29uZV9zdGVwX29mX3N0YWJpbGl6ZSBTdGF0ZS50XG4gIGVuZFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgaW5jbHVkZSBMZXRfc3ludGF4XG5cbiAgICBsZXQgcmV0dXJuIGEgPSByZXR1cm4gU3RhdGUudCBhXG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBMZXRfc3ludGF4XG5cbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIFNjb3BlID0gc3RydWN0XG4gICAgaW5jbHVkZSBTY29wZVxuXG4gICAgbGV0IGN1cnJlbnQgKCkgPSBjdXJyZW50IFN0YXRlLnQgKClcbiAgICBsZXQgd2l0aGluIHQgfmYgPSB3aXRoaW4gU3RhdGUudCB0IH5mXG4gIGVuZFxuXG4gIG1vZHVsZSBWYXIgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFZhclxuXG4gICAgbGV0IGNyZWF0ZSA/dXNlX2N1cnJlbnRfc2NvcGUgdmFsdWUgPSBjcmVhdGUgP3VzZV9jdXJyZW50X3Njb3BlIFN0YXRlLnQgdmFsdWVcbiAgZW5kXG5cbiAgbGV0IGNvbnN0IGEgPSBjb25zdCBTdGF0ZS50IGFcbiAgbGV0IHJldHVybiBhID0gcmV0dXJuIFN0YXRlLnQgYVxuICBsZXQgYWxsIHRzID0gYWxsIFN0YXRlLnQgdHNcbiAgbGV0IGV4aXN0cyB0cyA9IGV4aXN0cyBTdGF0ZS50IHRzXG4gIGxldCBmb3JfYWxsIHRzID0gZm9yX2FsbCBTdGF0ZS50IHRzXG4gIGxldCBsYXp5X2Zyb21fZnVuIHN0YXRlIGYgPSBTdGF0ZS5sYXp5X2Zyb21fZnVuIHN0YXRlIH5mXG5cbiAgbGV0IG1lbW9pemVfZnVuX2J5X2tleSA/aW5pdGlhbF9zaXplIGhhc2hhYmxlIHByb2plY3Rfa2V5IGYgPVxuICAgIG1lbW9pemVfZnVuX2J5X2tleSA/aW5pdGlhbF9zaXplIFN0YXRlLnQgaGFzaGFibGUgcHJvamVjdF9rZXkgZlxuICA7O1xuXG4gIGxldCBtZW1vaXplX2Z1biA/aW5pdGlhbF9zaXplIGhhc2hhYmxlIGYgPSBtZW1vaXplX2Z1biA/aW5pdGlhbF9zaXplIFN0YXRlLnQgaGFzaGFibGUgZlxuICBsZXQgYXJyYXlfZm9sZCB0cyB+aW5pdCB+ZiA9IGFycmF5X2ZvbGQgU3RhdGUudCB0cyB+aW5pdCB+ZlxuICBsZXQgcmVkdWNlX2JhbGFuY2VkIHRzIH5mIH5yZWR1Y2UgPSByZWR1Y2VfYmFsYW5jZWQgU3RhdGUudCB0cyB+ZiB+cmVkdWNlXG5cbiAgbGV0IHVub3JkZXJlZF9hcnJheV9mb2xkID9mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzIHRzIH5pbml0IH5mIH51cGRhdGUgPVxuICAgIHVub3JkZXJlZF9hcnJheV9mb2xkIFN0YXRlLnQgdHMgfmluaXQgfmYgfnVwZGF0ZSA/ZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlc1xuICA7O1xuXG4gIGxldCBvcHRfdW5vcmRlcmVkX2FycmF5X2ZvbGQgP2Z1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMgdHMgfmluaXQgfmYgfmZfaW52ZXJzZSA9XG4gICAgb3B0X3Vub3JkZXJlZF9hcnJheV9mb2xkID9mdWxsX2NvbXB1dGVfZXZlcnlfbl9jaGFuZ2VzIFN0YXRlLnQgdHMgfmluaXQgfmYgfmZfaW52ZXJzZVxuICA7O1xuXG4gIGxldCBzdW0gP2Z1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMgdHMgfnplcm8gfmFkZCB+c3ViID1cbiAgICBzdW0gP2Z1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMgU3RhdGUudCB0cyB+emVybyB+YWRkIH5zdWJcbiAgOztcblxuICBsZXQgb3B0X3N1bSA/ZnVsbF9jb21wdXRlX2V2ZXJ5X25fY2hhbmdlcyB0cyB+emVybyB+YWRkIH5zdWIgPVxuICAgIG9wdF9zdW0gP2Z1bGxfY29tcHV0ZV9ldmVyeV9uX2NoYW5nZXMgU3RhdGUudCB0cyB+emVybyB+YWRkIH5zdWJcbiAgOztcblxuICBsZXQgc3VtX2ludCB0cyA9IHN1bV9pbnQgU3RhdGUudCB0c1xuICBsZXQgc3VtX2Zsb2F0IHRzID0gc3VtX2Zsb2F0IFN0YXRlLnQgdHNcbiAgbGV0IHN0YWJpbGl6ZSAoKSA9IHN0YWJpbGl6ZSBTdGF0ZS50XG4gIGxldCBhbV9zdGFiaWxpemluZyAoKSA9IGFtX3N0YWJpbGl6aW5nIFN0YXRlLnRcbiAgbGV0IHNhdmVfZG90ID8oZW1pdF9iaW5kX2VkZ2VzID0gdHJ1ZSkgb3V0ID0gc2F2ZV9kb3QgfmVtaXRfYmluZF9lZGdlcyBTdGF0ZS50IG91dFxuXG4gIGxldCBzYXZlX2RvdF90b19maWxlID8oZW1pdF9iaW5kX2VkZ2VzID0gdHJ1ZSkgZmlsZSA9XG4gICAgT3V0X2NoYW5uZWwud2l0aF9maWxlIGZpbGUgfmY6KHNhdmVfZG90IH5lbWl0X2JpbmRfZWRnZXMpXG4gIDs7XG5cbiAgbGV0IGxhenlfZnJvbV9mdW4gZiA9IGxhenlfZnJvbV9mdW4gU3RhdGUudCBmXG5cbiAgbGV0IHdlYWtfbWVtb2l6ZV9mdW5fYnlfa2V5ID9pbml0aWFsX3NpemUgaGFzaGFibGUgcHJvamVjdF9rZXkgZiA9XG4gICAgd2Vha19tZW1vaXplX2Z1bl9ieV9rZXkgP2luaXRpYWxfc2l6ZSBTdGF0ZS50IGhhc2hhYmxlIHByb2plY3Rfa2V5IGZcbiAgOztcblxuICBsZXQgd2Vha19tZW1vaXplX2Z1biA/aW5pdGlhbF9zaXplIGhhc2hhYmxlIGYgPVxuICAgIHdlYWtfbWVtb2l6ZV9mdW4gP2luaXRpYWxfc2l6ZSBTdGF0ZS50IGhhc2hhYmxlIGZcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZSAoKSA9IE1ha2Vfd2l0aF9jb25maWcgKENvbmZpZy5EZWZhdWx0ICgpKSAoKVxuaW5jbHVkZSBHZW5lcmljXG5cbm1vZHVsZSBBZGRfd2l0bmVzczAgKE0gOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBJbnZhcmlhbnQuUyB3aXRoIHR5cGUgdCA6PSB0XG5lbmQpIDogc2lnXG4gIHR5cGUgJ3cgdCA9IE0udCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGluY2x1ZGUgSW52YXJpYW50LlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICd3IHQgPSBNLnRcblxuICBsZXQgaW52YXJpYW50IF8gdCA9IE0uaW52YXJpYW50IHRcbiAgbGV0IHNleHBfb2ZfdCBfIHQgPSBNLnNleHBfb2ZfdCB0XG5lbmRcblxubW9kdWxlIEFkZF93aXRuZXNzMSAoTSA6IHNpZ1xuICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBpbmNsdWRlIEludmFyaWFudC5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5lbmQpIDogc2lnXG4gIHR5cGUgKCdhLCAndykgdCA9ICdhIE0udCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGluY2x1ZGUgSW52YXJpYW50LlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ3cpIHQgPSAnYSBNLnRcblxuICBsZXQgaW52YXJpYW50IGludmFyaWFudF9hIF8gdCA9IE0uaW52YXJpYW50IGludmFyaWFudF9hIHRcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgXyB0ID0gTS5zZXhwX29mX3Qgc2V4cF9vZl9hIHRcbmVuZFxuXG5tb2R1bGUgQ2xvY2sgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBDbG9ja1xuICBpbmNsdWRlIEFkZF93aXRuZXNzMCAoQ2xvY2spXG5lbmRcblxubW9kdWxlIEV4cGVydCA9IHN0cnVjdFxuICBpbmNsdWRlIEV4cGVydFxuXG4gIG1vZHVsZSBEZXBlbmRlbmN5ID0gc3RydWN0XG4gICAgaW5jbHVkZSBEZXBlbmRlbmN5XG5cbiAgICBpbmNsdWRlIEFkZF93aXRuZXNzMSAoc3RydWN0XG4gICAgICBpbmNsdWRlIERlcGVuZGVuY3lcblxuICAgICAgbGV0IGludmFyaWFudCBfIF8gPSAoKVxuICAgIGVuZClcbiAgZW5kXG5cbiAgbW9kdWxlIE5vZGUgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIE5vZGVcblxuICAgIGluY2x1ZGUgQWRkX3dpdG5lc3MxIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTm9kZVxuXG4gICAgICBsZXQgaW52YXJpYW50IF8gXyA9ICgpXG4gICAgZW5kKVxuICBlbmRcblxuICBtb2R1bGUgU3RlcF9yZXN1bHQgPSBTdGF0ZS5TdGVwX3Jlc3VsdFxuXG4gIGxldCBkb19vbmVfc3RlcF9vZl9zdGFiaWxpemUgc3RhdGUgPSBTdGF0ZS5kb19vbmVfc3RlcF9vZl9zdGFiaWxpemUgc3RhdGVcbmVuZFxuXG5tb2R1bGUgTm9kZSA9IHN0cnVjdFxuICBpbmNsdWRlIE5vZGVcbiAgaW5jbHVkZSBBZGRfd2l0bmVzczEgKE5vZGUpXG5lbmRcblxudHlwZSAoJ2EsICd3KSB0ID0gKCdhLCAndykgTm9kZS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG50eXBlICgnYSwgJ3cpIGluY3JlbWVudGFsID0gKCdhLCAndykgdFxuXG5sZXQgaW52YXJpYW50ID0gTm9kZS5pbnZhcmlhbnRcblxubW9kdWxlIE9ic2VydmVyID0gc3RydWN0XG4gIGluY2x1ZGUgT2JzZXJ2ZXJcbiAgaW5jbHVkZSBBZGRfd2l0bmVzczEgKE9ic2VydmVyKVxuZW5kXG5cbm1vZHVsZSBTY29wZSA9IHN0cnVjdFxuICBpbmNsdWRlIFNjb3BlXG4gIGluY2x1ZGUgQWRkX3dpdG5lc3MwIChTY29wZSlcbmVuZFxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTdGF0ZVxuICBpbmNsdWRlIEFkZF93aXRuZXNzMCAoU3RhdGUpXG5lbmRcblxubW9kdWxlIFZhciA9IHN0cnVjdFxuICBpbmNsdWRlIFZhclxuICBpbmNsdWRlIEFkZF93aXRuZXNzMSAoVmFyKVxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSBzdGF0ZV93aXRuZXNzIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgaW5jbHVkZVxuICAgIFNfZ2VuXG4gICAgICB3aXRoIHR5cGUgJ2EgdCA9ICgnYSwgc3RhdGVfd2l0bmVzcykgaW5jcmVtZW50YWxcbiAgICAgIHdpdGggdHlwZSBCZWZvcmVfb3JfYWZ0ZXIudCA9IEJlZm9yZV9vcl9hZnRlci50XG4gICAgICB3aXRoIHR5cGUgQ2xvY2sudCA9IHN0YXRlX3dpdG5lc3MgQ2xvY2sudFxuICAgICAgd2l0aCB0eXBlICdhIEN1dG9mZi50ID0gJ2EgQ3V0b2ZmLnRcbiAgICAgIHdpdGggdHlwZSAnYSBFeHBlcnQuRGVwZW5kZW5jeS50ID0gKCdhLCBzdGF0ZV93aXRuZXNzKSBFeHBlcnQuRGVwZW5kZW5jeS50XG4gICAgICB3aXRoIHR5cGUgJ2EgRXhwZXJ0Lk5vZGUudCA9ICgnYSwgc3RhdGVfd2l0bmVzcykgRXhwZXJ0Lk5vZGUudFxuICAgICAgd2l0aCB0eXBlIEV4cGVydC5TdGVwX3Jlc3VsdC50ID0gRXhwZXJ0LlN0ZXBfcmVzdWx0LnRcbiAgICAgIHdpdGggdHlwZSAnYSBPYnNlcnZlci50ID0gKCdhLCBzdGF0ZV93aXRuZXNzKSBPYnNlcnZlci50XG4gICAgICB3aXRoIHR5cGUgJ2EgT2JzZXJ2ZXIuVXBkYXRlLnQgPSAnYSBPYnNlcnZlci5VcGRhdGUudFxuICAgICAgd2l0aCB0eXBlIFBhY2tlZC50ID0gUGFja2VkLnRcbiAgICAgIHdpdGggdHlwZSBTY29wZS50ID0gc3RhdGVfd2l0bmVzcyBTY29wZS50XG4gICAgICB3aXRoIHR5cGUgU3RhdGUudCA9IHN0YXRlX3dpdG5lc3MgU3RhdGUudFxuICAgICAgd2l0aCB0eXBlIFN0YXRlLlN0YXRzLnQgPSBTdGF0ZS5TdGF0cy50XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgVW5vcmRlcmVkX2FycmF5X2ZvbGRfdXBkYXRlLnQgPVxuICAgICAgICAoJ2EsICdiKSBVbm9yZGVyZWRfYXJyYXlfZm9sZF91cGRhdGUudFxuICAgICAgd2l0aCB0eXBlICdhIFVwZGF0ZS50ID0gJ2EgVXBkYXRlLnRcbiAgICAgIHdpdGggdHlwZSAnYSBWYXIudCA9ICgnYSwgc3RhdGVfd2l0bmVzcykgVmFyLnRcbmVuZFxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgZGVidWcgPSBkZWJ1Z1xuZW5kXG4iXX0=
