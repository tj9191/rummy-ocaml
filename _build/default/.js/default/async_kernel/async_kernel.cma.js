// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Async_kernel__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Async_kernel = [0],
    Async_kernel$0 = [0, Async_kernel];
   runtime.caml_register_global(0, Async_kernel$0, "Async_kernel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_ns
//# unitInfo: Requires: Core__Time_ns, Core__Time_ns_alternate_sexp, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Time_ns$0 = "Async_kernel__Time_ns",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Time_ns = global_data.Core__Time_ns,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Time_ns_alternate_sexp = global_data.Core__Time_ns_alternate_sexp;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_ns$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/time_ns.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "time_ns.ml");
   var
    typerep_of_t = Core_Time_ns_alternate_sexp[1],
    typename_of_t = Core_Time_ns_alternate_sexp[2],
    quickcheck_generator = Core_Time_ns_alternate_sexp[3],
    quickcheck_observer = Core_Time_ns_alternate_sexp[4],
    quickcheck_shrinker = Core_Time_ns_alternate_sexp[5],
    gen_incl = Core_Time_ns_alternate_sexp[6],
    gen_uniform_incl = Core_Time_ns_alternate_sexp[7],
    is_earlier = Core_Time_ns_alternate_sexp[8],
    is_later = Core_Time_ns_alternate_sexp[9],
    of_date_ofday = Core_Time_ns_alternate_sexp[10],
    of_date_ofday_precise = Core_Time_ns_alternate_sexp[11],
    to_date_ofday = Core_Time_ns_alternate_sexp[12],
    to_date_ofday_precise = Core_Time_ns_alternate_sexp[13],
    to_date = Core_Time_ns_alternate_sexp[14],
    to_ofday = Core_Time_ns_alternate_sexp[15],
    reset_date_cache = Core_Time_ns_alternate_sexp[16],
    convert = Core_Time_ns_alternate_sexp[17],
    utc_offset = Core_Time_ns_alternate_sexp[18],
    to_filename_string = Core_Time_ns_alternate_sexp[19],
    of_filename_string = Core_Time_ns_alternate_sexp[20],
    to_string_abs = Core_Time_ns_alternate_sexp[21],
    to_string_abs_trimmed = Core_Time_ns_alternate_sexp[22],
    to_string_abs_parts = Core_Time_ns_alternate_sexp[23],
    to_string_trimmed = Core_Time_ns_alternate_sexp[24],
    to_sec_string = Core_Time_ns_alternate_sexp[25],
    to_sec_string_with_zone = Core_Time_ns_alternate_sexp[26],
    of_localized_string = Core_Time_ns_alternate_sexp[27],
    of_string_gen = Core_Time_ns_alternate_sexp[28],
    to_string_iso8601_basic = Core_Time_ns_alternate_sexp[29],
    occurrence = Core_Time_ns_alternate_sexp[30],
    of_string = Core_Time_ns_alternate_sexp[31],
    of_string_with_utc_offset = Core_Time_ns_alternate_sexp[32],
    to_string = Core_Time_ns_alternate_sexp[33],
    to_string_utc = Core_Time_ns_alternate_sexp[34],
    epoch = Core_Time_ns_alternate_sexp[35],
    min_value_representable = Core_Time_ns_alternate_sexp[36],
    max_value_representable = Core_Time_ns_alternate_sexp[37],
    min_value_for_1us_rounding = Core_Time_ns_alternate_sexp[38],
    max_value_for_1us_rounding = Core_Time_ns_alternate_sexp[39],
    min_value = Core_Time_ns_alternate_sexp[40],
    max_value = Core_Time_ns_alternate_sexp[41],
    now = Core_Time_ns_alternate_sexp[42],
    add = Core_Time_ns_alternate_sexp[43],
    add_saturating = Core_Time_ns_alternate_sexp[44],
    sub_saturating = Core_Time_ns_alternate_sexp[45],
    sub = Core_Time_ns_alternate_sexp[46],
    next = Core_Time_ns_alternate_sexp[47],
    prev = Core_Time_ns_alternate_sexp[48],
    diff = Core_Time_ns_alternate_sexp[49],
    abs_diff = Core_Time_ns_alternate_sexp[50],
    to_span_since_epoch = Core_Time_ns_alternate_sexp[51],
    of_span_since_epoch = Core_Time_ns_alternate_sexp[52],
    to_int63_ns_since_epoch = Core_Time_ns_alternate_sexp[53],
    of_int63_ns_since_epoch = Core_Time_ns_alternate_sexp[54],
    to_int_ns_since_epoch = Core_Time_ns_alternate_sexp[55],
    of_int_ns_since_epoch = Core_Time_ns_alternate_sexp[56],
    next_multiple = Core_Time_ns_alternate_sexp[57],
    prev_multiple = Core_Time_ns_alternate_sexp[58],
    round_up_to_us = Core_Time_ns_alternate_sexp[59],
    round_up_to_ms = Core_Time_ns_alternate_sexp[60],
    round_up_to_sec = Core_Time_ns_alternate_sexp[61],
    round_down_to_us = Core_Time_ns_alternate_sexp[62],
    round_down_to_ms = Core_Time_ns_alternate_sexp[63],
    round_down_to_sec = Core_Time_ns_alternate_sexp[64],
    random = Core_Time_ns_alternate_sexp[65],
    of_time = Core_Time_ns_alternate_sexp[66],
    to_time = Core_Time_ns_alternate_sexp[67],
    to_time_float_round_nearest = Core_Time_ns_alternate_sexp[68],
    to_time_float_round_nearest_mi = Core_Time_ns_alternate_sexp[69],
    of_time_float_round_nearest = Core_Time_ns_alternate_sexp[70],
    of_time_float_round_nearest_mi = Core_Time_ns_alternate_sexp[71],
    arg_type = Core_Time_ns_alternate_sexp[72],
    get_sexp_zone = Core_Time_ns_alternate_sexp[73],
    interruptible_pause = Core_Time_ns_alternate_sexp[74],
    of_date_ofday_zoned = Core_Time_ns_alternate_sexp[75],
    of_string_abs = Core_Time_ns_alternate_sexp[76],
    of_string_fix_proto = Core_Time_ns_alternate_sexp[77],
    pause = Core_Time_ns_alternate_sexp[78],
    pause_forever = Core_Time_ns_alternate_sexp[79],
    pp = Core_Time_ns_alternate_sexp[80],
    set_sexp_zone = Core_Time_ns_alternate_sexp[81],
    sexp_of_t_abs = Core_Time_ns_alternate_sexp[82],
    t_of_sexp_abs = Core_Time_ns_alternate_sexp[83],
    to_date_ofday_zoned = Core_Time_ns_alternate_sexp[84],
    to_ofday_zoned = Core_Time_ns_alternate_sexp[85],
    to_string_fix_proto = Core_Time_ns_alternate_sexp[86],
    bin_size_t = Core_Time_ns_alternate_sexp[87],
    bin_write_t = Core_Time_ns_alternate_sexp[88],
    bin_read_t = Core_Time_ns_alternate_sexp[89],
    bin_read_t$0 = Core_Time_ns_alternate_sexp[90],
    bin_shape_t = Core_Time_ns_alternate_sexp[91],
    bin_writer_t = Core_Time_ns_alternate_sexp[92],
    bin_reader_t = Core_Time_ns_alternate_sexp[93],
    bin_t = Core_Time_ns_alternate_sexp[94],
    hash_fold_t = Core_Time_ns_alternate_sexp[95],
    hash = Core_Time_ns_alternate_sexp[96],
    t_of_sexp = Core_Time_ns_alternate_sexp[97],
    sexp_of_t = Core_Time_ns_alternate_sexp[98],
    t_sexp_grammar = Core_Time_ns_alternate_sexp[99],
    symbol = Core_Time_ns_alternate_sexp[100],
    symbol$0 = Core_Time_ns_alternate_sexp[101],
    symbol$1 = Core_Time_ns_alternate_sexp[102],
    symbol$2 = Core_Time_ns_alternate_sexp[103],
    symbol$3 = Core_Time_ns_alternate_sexp[104],
    symbol$4 = Core_Time_ns_alternate_sexp[105],
    equal = Core_Time_ns_alternate_sexp[106],
    compare = Core_Time_ns_alternate_sexp[107],
    min = Core_Time_ns_alternate_sexp[108],
    max = Core_Time_ns_alternate_sexp[109],
    ascending = Core_Time_ns_alternate_sexp[110],
    descending = Core_Time_ns_alternate_sexp[111],
    between = Core_Time_ns_alternate_sexp[112],
    clamp_exn = Core_Time_ns_alternate_sexp[113],
    clamp = Core_Time_ns_alternate_sexp[114],
    comparator = Core_Time_ns_alternate_sexp[115],
    validate_lbound = Core_Time_ns_alternate_sexp[116],
    validate_ubound = Core_Time_ns_alternate_sexp[117],
    validate_bound = Core_Time_ns_alternate_sexp[118],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Time_ns = cst_Async_kernel_Time_ns$0;
   function after(t, span){
    var result = caml_call2(add, t, span);
    if
     (caml_call2(Core_Time_ns[1][18], span, Core_Time_ns[1][76])
      && caml_call2(symbol$3, result, t))
     return max_value_for_1us_rounding;
    return result;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_ns);
   var
    Async_kernel_Time_ns =
      [0,
       typerep_of_t,
       typename_of_t,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       gen_incl,
       gen_uniform_incl,
       is_earlier,
       is_later,
       of_date_ofday,
       of_date_ofday_precise,
       to_date_ofday,
       to_date_ofday_precise,
       to_date,
       to_ofday,
       reset_date_cache,
       convert,
       utc_offset,
       to_filename_string,
       of_filename_string,
       to_string_abs,
       to_string_abs_trimmed,
       to_string_abs_parts,
       to_string_trimmed,
       to_sec_string,
       to_sec_string_with_zone,
       of_localized_string,
       of_string_gen,
       to_string_iso8601_basic,
       occurrence,
       of_string,
       of_string_with_utc_offset,
       to_string,
       to_string_utc,
       epoch,
       min_value_representable,
       max_value_representable,
       min_value_for_1us_rounding,
       max_value_for_1us_rounding,
       min_value,
       max_value,
       now,
       add,
       add_saturating,
       sub_saturating,
       sub,
       next,
       prev,
       diff,
       abs_diff,
       to_span_since_epoch,
       of_span_since_epoch,
       to_int63_ns_since_epoch,
       of_int63_ns_since_epoch,
       to_int_ns_since_epoch,
       of_int_ns_since_epoch,
       next_multiple,
       prev_multiple,
       round_up_to_us,
       round_up_to_ms,
       round_up_to_sec,
       round_down_to_us,
       round_down_to_ms,
       round_down_to_sec,
       random,
       of_time,
       to_time,
       to_time_float_round_nearest,
       to_time_float_round_nearest_mi,
       of_time_float_round_nearest,
       of_time_float_round_nearest_mi,
       arg_type,
       get_sexp_zone,
       interruptible_pause,
       of_date_ofday_zoned,
       of_string_abs,
       of_string_fix_proto,
       pause,
       pause_forever,
       pp,
       set_sexp_zone,
       sexp_of_t_abs,
       t_of_sexp_abs,
       to_date_ofday_zoned,
       to_ofday_zoned,
       to_string_fix_proto,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       after];
   runtime.caml_register_global
    (13, Async_kernel_Time_ns, cst_Async_kernel_Time_ns$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Debug
//# unitInfo: Requires: Async_kernel__Time_ns, Async_kernel_config, Core, Core__Sexp, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Debug$0 = "Async_kernel__Debug",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Core_Sexp = global_data.Core__Sexp,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Async_kernel_config = global_data.Async_kernel_config,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Debug$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/debug.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "debug.ml");
   var
    include = Async_kernel_config[16],
    clock = include[1],
    fd = include[2],
    file_descr_watcher = include[3],
    finalizers = include[4],
    interruptor = include[5],
    monitor = include[6],
    monitor_send_exn = include[7],
    parallel = include[8],
    reader = include[9],
    scheduler = include[10],
    shutdown = include[11],
    thread_pool = include[12],
    thread_safe = include[13],
    writer = include[14],
    _a_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Debug = cst_Async_kernel_Debug$0;
   function log(arg2_003, arg3_004, sexp_of_a){
    var
     arg1_002 = caml_call1(Async_kernel_Time_ns[42], 0),
     arg0_001 = caml_call1(Async_kernel_config[35][1], 0),
     res0_005 = caml_call1(Core_Sexp[93], arg0_001),
     res1_006 = caml_call1(Async_kernel_Time_ns[98], arg1_002),
     res2_007 = caml_call1(Core[558], arg2_003),
     res3_008 = caml_call1(sexp_of_a, arg3_004),
     _b_ =
       caml_call2
        (Core_Sexp[84],
         0,
         [1, [0, res0_005, [0, res1_006, [0, res2_007, [0, res3_008, 0]]]]]);
    return caml_call2(Core[243], _a_, _b_);
   }
   function log_string(message){return log(message, 0, Core[620]);}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Debug);
   var
    Async_kernel_Debug =
      [0,
       clock,
       fd,
       file_descr_watcher,
       finalizers,
       interruptor,
       monitor,
       monitor_send_exn,
       parallel,
       reader,
       scheduler,
       shutdown,
       thread_pool,
       thread_safe,
       writer,
       log,
       log_string];
   runtime.caml_register_global
    (16, Async_kernel_Debug, cst_Async_kernel_Debug$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Import
//# unitInfo: Requires: Core, Core__Debug, Core__Int, Core__Sexp, Core__String, Core__Time_ns, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Import$0 = "Async_kernel__Import",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Sexp = global_data.Core__Sexp,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Int = global_data.Core__Int,
    Core_String = global_data.Core__String,
    Core_Debug = global_data.Core__Debug,
    Core_Time_ns = global_data.Core__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Import$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/import.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "import.ml");
   var
    include = Core_Int[96],
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    concat = Core_String[46],
    eprint = Core_Debug[1],
    eprint_s = Core_Debug[3],
    eprints = Core_Debug[2],
    _a_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Import = cst_Async_kernel_Import$0;
   function print_s(sexp){
    var _b_ = caml_call2(Core_Sexp[84], 0, sexp);
    return caml_call2(Core[258], _a_, _b_);
   }
   var sec = Core_Time_ns[1][82], Thread = [0], Unix = [0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Import);
   var
    Async_kernel_Import =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       concat,
       eprint,
       eprint_s,
       eprints,
       print_s,
       sec,
       Thread,
       Unix];
   runtime.caml_register_global
    (18, Async_kernel_Import, cst_Async_kernel_Import$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Priority
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Priority$0 = "Async_kernel__Priority",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, 0]],
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Priority$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/priority.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "priority.ml");
   var
    _a_ = [0, "Low"],
    _b_ = [0, "Normal"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Priority = cst_Async_kernel_Priority$0;
   function sexp_of_t(param){return param ? _a_ : _b_;}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Priority);
   var Async_kernel_Priority = [0, sexp_of_t, all, 0, 1];
   runtime.caml_register_global
    (14, Async_kernel_Priority, cst_Async_kernel_Priority$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Types
//# unitInfo: Requires: CamlinternalMod, Core__Unique_id, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Types$0 = "Async_kernel__Types",
    cst_async_kernel$0 = "async_kernel",
    cst_src_types_ml = "src/types.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    CamlinternalMod = global_data.CamlinternalMod,
    Core_Unique_id = global_data.Core__Unique_id;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Types$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_types_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "types.ml");
   var
    Cell =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 37, 2], [0, [0]]),
    Handler =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 42, 2], [0, [0]]),
    Ivar =
      caml_call2
       (CamlinternalMod[1], [0, cst_src_types_ml, 51, 2], [0, [0, [0, [0]]]]),
    Deferred =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 56, 2], [0, [0]]),
    Execution_context =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 66, 2], [0, [0]]),
    Forwarding =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 74, 2], [0, [0]]),
    Monitor =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 88, 2], [0, [0]]),
    Tail =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 93, 2], [0, [0]]),
    Stream =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 102, 2], [0, [0]]);
   caml_call3(CamlinternalMod[2], [0, [0]], Cell, Cell);
   caml_call3(CamlinternalMod[2], [0, [0]], Handler, Handler);
   caml_call3(CamlinternalMod[2], [0, [0, [0, [0]]]], Ivar, Ivar);
   caml_call3(CamlinternalMod[2], [0, [0]], Deferred, Deferred);
   caml_call3
    (CamlinternalMod[2], [0, [0]], Execution_context, Execution_context);
   caml_call3(CamlinternalMod[2], [0, [0]], Forwarding, Forwarding);
   caml_call3(CamlinternalMod[2], [0, [0]], Monitor, Monitor);
   caml_call3(CamlinternalMod[2], [0, [0]], Tail, Tail);
   caml_call3(CamlinternalMod[2], [0, [0]], Stream, Stream);
   var
    _a_ = [0, [0, [0, [0]], [0, [0]]]],
    _b_ = [0, cst_src_types_ml, 155, 2],
    _c_ = [0, [0]],
    _d_ = [0, cst_src_types_ml, 160, 2],
    _e_ = [0, [0]],
    _f_ = [0, cst_src_types_ml, 166, 2],
    _g_ = [0, [0]],
    _h_ = [0, cst_src_types_ml, 171, 2],
    _i_ = [0, [0]],
    _j_ = [0, cst_src_types_ml, 176, 2],
    _k_ = [0, [0]],
    _l_ = [0, cst_src_types_ml, 189, 2],
    _m_ = [0, [0]],
    _n_ = [0, cst_src_types_ml, 199, 2],
    _o_ = [0, [0]],
    _p_ = [0, cst_src_types_ml, 233, 2],
    _q_ = [0, [0]],
    _r_ = [0, cst_src_types_ml, 238, 2],
    _s_ = [0, [0]],
    _t_ = [0, cst_src_types_ml, 256, 2],
    _u_ = [0, [0, [0, [0]]]],
    _v_ = [0, cst_src_types_ml, 270, 2],
    _w_ = [0, [0, [0, [0]], [0, [0]]]],
    _x_ = [0, [0]],
    _y_ = [0, [0]],
    _z_ = [0, [0]],
    _A_ = [0, [0]],
    _B_ = [0, [0]],
    _C_ = [0, [0]],
    _D_ = [0, [0]],
    _E_ = [0, [0]],
    _F_ = [0, [0]],
    _G_ = [0, [0, [0, [0]]]],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Types = cst_Async_kernel_Types$0;
   function to_repr(t){return t;}
   function of_repr(t){return t;}
   var
    Bvar = [0, of_repr, to_repr],
    Event = caml_call2(CamlinternalMod[1], _b_, _a_),
    External_job = caml_call2(CamlinternalMod[1], _d_, _c_),
    Job = caml_call2(CamlinternalMod[1], _f_, _e_),
    Job_or_event = caml_call2(CamlinternalMod[1], _h_, _g_),
    Job_pool = caml_call2(CamlinternalMod[1], _j_, _i_),
    Job_queue = caml_call2(CamlinternalMod[1], _l_, _k_),
    Jobs = caml_call2(CamlinternalMod[1], _n_, _m_),
    Scheduler = caml_call2(CamlinternalMod[1], _p_, _o_),
    Cycle_hook = caml_call2(CamlinternalMod[1], _r_, _q_),
    Time_source = caml_call2(CamlinternalMod[1], _t_, _s_),
    Very_low_priority_worker = caml_call2(CamlinternalMod[1], _v_, _u_),
    Cycle_hook_handle = caml_call1(Core_Unique_id[2], 0),
    Time_source_id = caml_call1(Core_Unique_id[2], 0);
   caml_call3(CamlinternalMod[2], _w_, Event, Event);
   caml_call3(CamlinternalMod[2], _x_, External_job, External_job);
   caml_call3(CamlinternalMod[2], _y_, Job, Job);
   caml_call3(CamlinternalMod[2], _z_, Job_or_event, Job_or_event);
   caml_call3(CamlinternalMod[2], _A_, Job_pool, Job_pool);
   caml_call3(CamlinternalMod[2], _B_, Job_queue, Job_queue);
   caml_call3(CamlinternalMod[2], _C_, Jobs, Jobs);
   caml_call3(CamlinternalMod[2], _D_, Scheduler, Scheduler);
   caml_call3(CamlinternalMod[2], _E_, Cycle_hook, Cycle_hook);
   caml_call3(CamlinternalMod[2], _F_, Time_source, Time_source);
   caml_call3
    (CamlinternalMod[2],
     _G_,
     Very_low_priority_worker,
     Very_low_priority_worker);
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Types);
   var
    Async_kernel_Types =
      [0,
       Cell,
       Handler,
       Ivar,
       Deferred,
       Execution_context,
       Forwarding,
       Monitor,
       Tail,
       Stream,
       Bvar,
       Event,
       External_job,
       Job,
       Job_or_event,
       Job_pool,
       Job_queue,
       Jobs,
       Scheduler,
       Cycle_hook,
       Cycle_hook_handle,
       Time_source_id,
       Time_source,
       Very_low_priority_worker];
   runtime.caml_register_global
    (73, Async_kernel_Types, cst_Async_kernel_Types$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monitor0
//# unitInfo: Requires: Async_kernel__Debug, Core, Core__Bag, Core__Info, Core__List, Core__Sexp, Core__Source_code_position, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexp_hidden_in_test
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Monitor0$0 = "Async_kernel__Monitor0",
    cst_async_kernel$0 = "async_kernel",
    cst_id$1 = "id";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Sexp_hidden_in_test = global_data.Sexp_hidden_in_test,
    Core_Info = global_data.Core__Info,
    Core_Bag = global_data.Core__Bag,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_Sexp = global_data.Core__Sexp,
    Core_List = global_data.Core__List,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monitor0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/monitor0.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "monitor0.ml");
   var
    debug = Async_kernel_Debug[6],
    cst_id$0 = cst_id$1,
    cst_created_monitor = "created monitor",
    cst_forwarding = "forwarding",
    cst_has_seen_error = "has_seen_error",
    cst_tails_for_all_errors = "tails_for_all_errors",
    cst_handlers_for_all_errors = "handlers_for_all_errors",
    cst_next_error = "next_error",
    cst_id = cst_id$1,
    cst_here = "here",
    cst_name = "name",
    _q_ = [0, "main"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Monitor0 = cst_Async_kernel_Monitor0$0;
   function forwarding(r){return r[8];}
   function set_forwarding(r, v){r[8] = v; return 0;}
   function has_seen_error(r){return r[7];}
   function set_has_seen_error(r, v){r[7] = v; return 0;}
   function tails_for_all_errors(r){return r[6];}
   function set_tails_for_all_errors(r, v){r[6] = v; return 0;}
   function handlers_for_all_errors(r){return r[5];}
   function set_handlers_for_all_errors(r, v){r[5] = v; return 0;}
   function next_error(r){return r[4];}
   function set_next_error(r, v){r[4] = v; return 0;}
   function id(r){return r[3];}
   function here(r){return r[2];}
   function name(r){return r[1];}
   function _a_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v];
   }
   var
    _b_ = [0, set_forwarding],
    forwarding$0 =
      [0, function(param){return 0;}, cst_forwarding, _b_, forwarding, _a_];
   function _c_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
   }
   var
    _d_ = [0, set_has_seen_error],
    has_seen_error$0 =
      [0,
       function(param){return 0;},
       cst_has_seen_error,
       _d_,
       has_seen_error,
       _c_];
   function _e_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
   }
   var
    _f_ = [0, set_tails_for_all_errors],
    tails_for_all_errors$0 =
      [0,
       function(param){return 0;},
       cst_tails_for_all_errors,
       _f_,
       tails_for_all_errors,
       _e_];
   function _g_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8]];
   }
   var
    _h_ = [0, set_handlers_for_all_errors],
    handlers_for_all_errors$0 =
      [0,
       function(param){return 0;},
       cst_handlers_for_all_errors,
       _h_,
       handlers_for_all_errors,
       _g_];
   function _i_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8]];
   }
   var
    _j_ = [0, set_next_error],
    next_error$0 =
      [0, function(param){return 0;}, cst_next_error, _j_, next_error, _i_];
   function _k_(r, v){
    return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8]];
   }
   var _l_ = 0, id$0 = [0, function(param){return 0;}, cst_id, _l_, id, _k_];
   function _m_(r, v){
    return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _n_ = 0,
    here$0 = [0, function(param){return 0;}, cst_here, _n_, here, _m_];
   function _o_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _p_ = 0,
    name$0 = [0, function(param){return 0;}, cst_name, _p_, name, _o_];
   function iter
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    caml_call1(name_fun, name$0);
    caml_call1(here_fun, here$0);
    caml_call1(id_fun, id$0);
    caml_call1(next_error_fun, next_error$0);
    caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0);
    caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0);
    caml_call1(has_seen_error_fun, has_seen_error$0);
    return caml_call1(forwarding_fun, forwarding$0);
   }
   var
    Fields =
      [0,
       forwarding$0,
       has_seen_error$0,
       tails_for_all_errors$0,
       handlers_for_all_errors$0,
       next_error$0,
       id$0,
       here$0,
       name$0,
       iter];
   function description(t){
    var match = t[2];
    if(! match) return caml_call1(Core_Info[9], t[1]);
    var
     here = match[1],
     _u_ = [0, caml_call1(Core_Source_code_position[1], here), 0];
    return [1, [0, caml_call1(Core_Info[9], t[1]), _u_]];
   }
   function descriptions(t$1){
    var t = t$1, ac = 0;
    for(;;){
     var ac$0 = [0, description(t), ac], match = t[8];
     if(typeof match === "number") return caml_call1(Core_List[59], ac$0);
     var t$0 = match[1], t = t$0, ac = ac$0;
    }
   }
   function sexp_of_t(t){
    var x_001 = descriptions(t);
    return caml_call2(Core[472], Core_Sexp[93], x_001);
   }
   var r = [0, 0];
   function next_id(param){r[1]++; return r[1];}
   function create_with_parent(here, info, name, parent){
    var id = next_id(0);
    if(info){
     var i = info[1];
     if(name)
      var s = name[1], _r_ = caml_call2(Core_Info[22], i, s);
     else
      var _r_ = i;
     var name$0 = _r_;
    }
    else if(name)
     var s$0 = name[1], name$0 = caml_call1(Core_Info[14], s$0);
    else
     var
      _t_ =
        function(x_002){
         return caml_call2(Sexp_hidden_in_test[11], Core[389], x_002);
        },
      name$0 = caml_call5(Core_Info[19], 0, 0, cst_id$0, id, _t_);
    if(parent)
     var parent$0 = parent[1], _s_ = [0, parent$0];
    else
     var _s_ = 1;
    var
     t = [0, name$0, here, id, [0, 0], caml_call1(Core_Bag[22], 0), 0, 0, _s_];
    if(debug)
     caml_call3(Async_kernel_Debug[15], cst_created_monitor, t, sexp_of_t);
    return t;
   }
   var main = create_with_parent(0, 0, _q_, 0);
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monitor0);
   var
    Async_kernel_Monitor0 =
      [0,
       debug,
       forwarding,
       set_forwarding,
       has_seen_error,
       set_has_seen_error,
       tails_for_all_errors,
       set_tails_for_all_errors,
       handlers_for_all_errors,
       set_handlers_for_all_errors,
       next_error,
       set_next_error,
       id,
       here,
       name,
       Fields,
       description,
       descriptions,
       sexp_of_t,
       next_id,
       create_with_parent,
       main];
   runtime.caml_register_global
    (30, Async_kernel_Monitor0, cst_Async_kernel_Monitor0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Execution_context
//# unitInfo: Requires: Async_kernel__Monitor0, Async_kernel__Priority, Base__Backtrace, Core, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Univ_map
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Execution_con$0 = "Async_kernel__Execution_context",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Backtrace = global_data.Base__Backtrace,
    Univ_map = global_data.Univ_map,
    Core_Option = global_data.Core__Option,
    Core = global_data.Core,
    Async_kernel_Priority = global_data.Async_kernel__Priority,
    Async_kernel_Monitor0 = global_data.Async_kernel__Monitor0,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Execution_con$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/execution_context.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "execution_context.ml");
   var
    _a_ = [0, "backtrace_history"],
    _b_ = [0, "local_storage"],
    _c_ = [0, "priority"],
    _d_ = [0, "monitor"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Execution_con = cst_Async_kernel_Execution_con$0;
   function backtrace_history(r){return r[4];}
   function local_storage(r){return r[3];}
   function priority(r){return r[2];}
   function monitor(r){return r[1];}
   function sexp_of_t(param){
    var
     backtrace_history_008 = param[4],
     local_storage_006 = param[3],
     priority_004 = param[2],
     monitor_002 = param[1],
     arg_009 = caml_call2(Core[472], Base_Backtrace[1], backtrace_history_008),
     bnds_001 = [0, [1, [0, _a_, [0, arg_009, 0]]], 0],
     arg_007 = caml_call1(Univ_map[2], local_storage_006),
     bnds_001$0 = [0, [1, [0, _b_, [0, arg_007, 0]]], bnds_001],
     arg_005 = caml_call1(Async_kernel_Priority[1], priority_004),
     bnds_001$1 = [0, [1, [0, _c_, [0, arg_005, 0]]], bnds_001$0],
     arg_003 = caml_call1(Async_kernel_Monitor0[18], monitor_002),
     bnds_001$2 = [0, [1, [0, _d_, [0, arg_003, 0]]], bnds_001$1];
    return [1, bnds_001$2];
   }
   function invariant(param){return 0;}
   var
    main =
      [0, Async_kernel_Monitor0[21], Async_kernel_Priority[3], Univ_map[4], 0];
   function create_like(monitor, priority, local_storage, t){
    if(! monitor && ! priority && ! local_storage) return t;
    var
     monitor$0 = caml_call2(Core_Option[39], monitor, t[1]),
     _k_ = t[4],
     _l_ = caml_call2(Core_Option[39], local_storage, t[3]);
    return [0,
            monitor$0,
            caml_call2(Core_Option[39], priority, t[2]),
            _l_,
            _k_];
   }
   function find_local(t, key){return caml_call2(Univ_map[10], t[3], key);}
   function with_local(t, key, data){
    if(data){
     var
      data$0 = data[1],
      _g_ = t[4],
      _h_ = caml_call3(Univ_map[7], t[3], key, data$0);
     return [0, t[1], t[2], _h_, _g_];
    }
    var _i_ = t[4], _j_ = caml_call2(Univ_map[17], t[3], key);
    return [0, t[1], t[2], _j_, _i_];
   }
   function record_backtrace(t){
    var _e_ = t[4], _f_ = [0, caml_call2(Base_Backtrace[2], 0, 0), _e_];
    return [0, t[1], t[2], t[3], _f_];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Execution_con);
   var
    Async_kernel_Execution_context =
      [0,
       backtrace_history,
       local_storage,
       priority,
       monitor,
       sexp_of_t,
       invariant,
       main,
       create_like,
       find_local,
       with_local,
       record_backtrace];
   runtime.caml_register_global
    (21, Async_kernel_Execution_context, cst_Async_kernel_Execution_con$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__External_job
//# unitInfo: Requires: Async_kernel__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_External_job$0 = "Async_kernel__External_job",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_External_job$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/external_job.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "external_job.ml");
   var
    _a_ = [0, "<job>"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_External_job = cst_Async_kernel_External_job$0;
   function sexp_of_t(param){return _a_;}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_External_job);
   var Async_kernel_External_job = [0, sexp_of_t];
   runtime.caml_register_global
    (12, Async_kernel_External_job, cst_Async_kernel_External_job$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_pool
//# unitInfo: Requires: Async_kernel__Execution_context, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_pool$0 = "Async_kernel__Job_pool",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Tuple_pool = global_data.Tuple_pool,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_pool$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/job_pool.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "job_pool.ml");
   var
    dummy_e = Async_kernel_Execution_context[7],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Job_pool = cst_Async_kernel_Job_pool$0;
   function dummy_f(_g_){return 0;}
   var dummy_a = 0;
   function sexp_of_slots(x_001){
    var _c_ = Sexplib0_Sexp_conv[23];
    function _d_(param){
     function _e_(_f_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _e_);
    }
    return caml_call4
            (Tuple_pool[1][5],
             Async_kernel_Execution_context[5],
             _d_,
             _c_,
             x_001);
   }
   function sexp_of_t(x_002){
    return caml_call2(Tuple_pool[4], sexp_of_slots, x_002);
   }
   function invariant(t){
    function _a_(_b_){return 0;}
    return caml_call2(Tuple_pool[5], _a_, t);
   }
   function create(param){
    return caml_call3
            (Tuple_pool[9],
             Tuple_pool[1][19],
             1,
             [0, dummy_e, dummy_f, dummy_a]);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_pool);
   var
    Async_kernel_Job_pool = [0, sexp_of_slots, sexp_of_t, invariant, create];
   runtime.caml_register_global
    (14, Async_kernel_Job_pool, cst_Async_kernel_Job_pool$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job
//# unitInfo: Requires: Async_kernel__Job_pool, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job$0 = "Async_kernel__Job",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Job_pool = global_data.Async_kernel__Job_pool,
    Tuple_pool = global_data.Tuple_pool,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/job.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "job.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Job = cst_Async_kernel_Job$0;
   function sexp_of_t(x_001){
    return caml_call2(Tuple_pool[3][1], Async_kernel_Job_pool[1], x_001);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job);
   var Async_kernel_Job = [0, sexp_of_t];
   runtime.caml_register_global(13, Async_kernel_Job, cst_Async_kernel_Job$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_or_event
//# unitInfo: Requires: Async_kernel__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_or_event$0 = "Async_kernel__Job_or_event",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_or_event$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/job_or_event.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "job_or_event.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Job_or_event = cst_Async_kernel_Job_or_event$0;
   function of_event(event){return event;}
   function of_job(job){return job;}
   function is_event(t){return caml_call1(Stdlib_Obj[1], t);}
   function is_job(t){return typeof t === "number" ? 1 : 0;}
   function kind(t){return is_event(t) ? 0 : 1;}
   function project(param, job_or_event){return job_or_event;}
   var Match = [0, kind, project];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_or_event);
   var
    Async_kernel_Job_or_event = [0, of_event, of_job, is_event, is_job, Match];
   runtime.caml_register_global
    (13, Async_kernel_Job_or_event, cst_Async_kernel_Job_or_event$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_or_event_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_or_event_ = "Async_kernel__Job_or_event_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_or_event_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/job_or_event_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel, "job_or_event_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_or_event_);
   var Async_kernel_Job_or_event_intf = [0];
   runtime.caml_register_global
    (11, Async_kernel_Job_or_event_intf, cst_Async_kernel_Job_or_event_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler0
//# unitInfo: Requires: Async_kernel__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler0$0 = "Async_kernel__Scheduler0",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/scheduler0.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "scheduler0.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Scheduler0 = cst_Async_kernel_Scheduler0$0;
   function events(t){return t[19][4];}
   function set_execution_context(t, execution_context){
    var
     _a_ = 1 - (t[7] === execution_context ? 1 : 0),
     _b_ = _a_ ? (t[7] = execution_context, 0) : _a_;
    return _b_;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler0);
   var Async_kernel_Scheduler0 = [0, events, set_execution_context];
   runtime.caml_register_global
    (11, Async_kernel_Scheduler0, cst_Async_kernel_Scheduler0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_queue
//# unitInfo: Requires: Async_kernel__Execution_context, Async_kernel__Import, Async_kernel__Scheduler0, Base__Backtrace, Base__Invariant, Core, Core__Int, Core__Uniform_array, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Thread_safe_queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_queue$0 = "Async_kernel__Job_queue",
    cst_async_kernel$0 = "async_kernel",
    cst_front$0 = "front",
    cst_jobs$0 = "jobs",
    cst_jobs_left_this_cycle$0 = "jobs_left_this_cycle",
    cst_length$0 = "length",
    cst_mask$0 = "mask",
    cst_num_jobs_run$0 = "num_jobs_run",
    cst_src_job_queue_ml = "src/job_queue.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Core_Uniform_array = global_data.Core__Uniform_array,
    Base_Backtrace = global_data.Base__Backtrace,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Assert_failure = global_data.Assert_failure,
    Core_Int = global_data.Core__Int,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_queue$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_job_queue_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "job_queue.ml");
   var
    dummy_e = Async_kernel_Execution_context[7],
    _F_ = [0, 0],
    _D_ = [0, "t"],
    _E_ = [0, "n"],
    cst_Jobs_set_jobs_left_this_cy =
      "Jobs.set_jobs_left_this_cycle got negative number",
    _C_ = [0, cst_src_job_queue_ml, 94, 15],
    _A_ = [0, cst_src_job_queue_ml, 43, 48],
    _z_ = [0, cst_src_job_queue_ml, 45, 44],
    _y_ = [0, cst_src_job_queue_ml, 55, 11],
    _x_ = [0, cst_src_job_queue_ml, 56, 11],
    _w_ = [0, cst_src_job_queue_ml, 60, 11],
    _v_ = [0, cst_src_job_queue_ml, 61, 11],
    _u_ = [0, cst_src_job_queue_ml, 64, 11],
    _t_ = [0, cst_src_job_queue_ml, 65, 11],
    _B_ = [0, cst_src_job_queue_ml, 40, 1651, 1673],
    _m_ = [0, "backtrace_of_first_enqueue"],
    _n_ = [0, cst_length$0],
    _o_ = [0, cst_front$0],
    _p_ = [0, cst_mask$0],
    _q_ = [0, cst_jobs$0],
    _r_ = [0, cst_jobs_left_this_cycle$0],
    _s_ = [0, cst_num_jobs_run$0],
    cst_length = cst_length$0,
    cst_front = cst_front$0,
    cst_mask = cst_mask$0,
    cst_jobs = cst_jobs$0,
    cst_jobs_left_this_cycle = cst_jobs_left_this_cycle$0,
    cst_num_jobs_run = cst_num_jobs_run$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Job_queue = cst_Async_kernel_Job_queue$0;
   function dummy_f(_X_){return 0;}
   var dummy_a = 0;
   function length(r){return r[6];}
   function set_length(r, v){r[6] = v; return 0;}
   function front(r){return r[5];}
   function set_front(r, v){r[5] = v; return 0;}
   function mask(r){return r[4];}
   function set_mask(r, v){r[4] = v; return 0;}
   function jobs(r){return r[3];}
   function set_jobs(r, v){r[3] = v; return 0;}
   function jobs_left_this_cycle(r){return r[2];}
   function set_jobs_left_this_cycle(r, v){r[2] = v; return 0;}
   function num_jobs_run(r){return r[1];}
   function set_num_jobs_run(r, v){r[1] = v; return 0;}
   function _a_(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v, r[7]];}
   var
    _b_ = [0, set_length],
    length$0 = [0, function(param){return 0;}, cst_length, _b_, length, _a_];
   function _c_(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6], r[7]];}
   var
    _d_ = [0, set_front],
    front$0 = [0, function(param){return 0;}, cst_front, _d_, front, _c_];
   function _e_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6], r[7]];}
   var
    _f_ = [0, set_mask],
    mask$0 = [0, function(param){return 0;}, cst_mask, _f_, mask, _e_];
   function _g_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6], r[7]];}
   var
    _h_ = [0, set_jobs],
    jobs$0 = [0, function(param){return 0;}, cst_jobs, _h_, jobs, _g_];
   function _i_(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6], r[7]];}
   var
    _j_ = [0, set_jobs_left_this_cycle],
    jobs_left_this_cycle$0 =
      [0,
       function(param){return 0;},
       cst_jobs_left_this_cycle,
       _j_,
       jobs_left_this_cycle,
       _i_];
   function _k_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6], r[7]];}
   var
    _l_ = [0, set_num_jobs_run],
    num_jobs_run$0 =
      [0,
       function(param){return 0;},
       cst_num_jobs_run,
       _l_,
       num_jobs_run,
       _k_];
   function sexp_of_t(param){
    var
     num_jobs_run_002 = param[1],
     jobs_left_this_cycle_004 = param[2],
     jobs_006 = param[3],
     mask_008 = param[4],
     front_010 = param[5],
     length_012 = param[6],
     backtrace_of_first_enqueue_014 = param[7],
     arg_015 =
       caml_call2
        (Core[515], Base_Backtrace[1], backtrace_of_first_enqueue_014),
     bnds_001 = [0, [1, [0, _m_, [0, arg_015, 0]]], 0],
     arg_013 = caml_call1(Core[389], length_012),
     bnds_001$0 = [0, [1, [0, _n_, [0, arg_013, 0]]], bnds_001],
     arg_011 = caml_call1(Core[389], front_010),
     bnds_001$1 = [0, [1, [0, _o_, [0, arg_011, 0]]], bnds_001$0],
     arg_009 = caml_call1(Core[389], mask_008),
     bnds_001$2 = [0, [1, [0, _p_, [0, arg_009, 0]]], bnds_001$1],
     arg_007 = caml_call1(Sexplib0_Sexp_conv[23], jobs_006),
     bnds_001$3 = [0, [1, [0, _q_, [0, arg_007, 0]]], bnds_001$2],
     arg_005 = caml_call1(Core[389], jobs_left_this_cycle_004),
     bnds_001$4 = [0, [1, [0, _r_, [0, arg_005, 0]]], bnds_001$3],
     arg_003 = caml_call1(Core[389], num_jobs_run_002),
     bnds_001$5 = [0, [1, [0, _s_, [0, arg_003, 0]]], bnds_001$4];
    return [1, bnds_001$5];
   }
   function offset(t, i){return ((t[5] + i | 0) & t[4]) * 3 | 0;}
   function capacity(t){return t[4] + 1 | 0;}
   function invariant(t){
    function _N_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      length_fun =
        check
         (function(length){
           if(! caml_call2(Async_kernel_Import[1], length, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
           var _W_ = capacity(t);
           if(caml_call2(Async_kernel_Import[2], length, _W_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
          }),
      front_fun =
        check
         (function(front){
           if(! caml_call2(Async_kernel_Import[1], front, 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
           var
            _U_ = capacity(t),
            _V_ = caml_call2(Async_kernel_Import[10], 1, _U_);
           if(caml_call2(Async_kernel_Import[5], front, _V_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
          }),
      mask_fun =
        check
         (function(mask){
           var capacity = mask + 1 | 0;
           if
            (!
             caml_call2(Async_kernel_Import[3], capacity, 0)
             && ! caml_call1(Core_Int[52], capacity))
            throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
           var _T_ = caml_call1(Core_Uniform_array[19], t[3]);
           if(caml_call2(Async_kernel_Import[3], capacity * 3 | 0, _T_))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _x_], 1);
          }),
      jobs_fun =
        check
         (function(jobs){
           var _P_ = t[6] - 1 | 0, _O_ = 0;
           if(_P_ >= 0){
            var i = _O_;
            for(;;){
             var
              _Q_ = offset(t, i),
              _R_ = caml_call2(Core_Uniform_array[20], jobs, _Q_);
             caml_call1(Async_kernel_Execution_context[6], _R_);
             var _S_ = i + 1 | 0;
             if(_P_ === i) break;
             var i = _S_;
            }
           }
           return 0;
          }),
      jobs_left_this_cycle_fun =
        check
         (function(jobs_left_this_cycle){
           if(caml_call2(Async_kernel_Import[1], jobs_left_this_cycle, 0))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
          }),
      num_jobs_run_fun =
        check
         (function(num_jobs_run){
           if(caml_call2(Async_kernel_Import[1], num_jobs_run, 0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
          });
     caml_call1(num_jobs_run_fun, num_jobs_run$0);
     caml_call1(jobs_left_this_cycle_fun, jobs_left_this_cycle$0);
     caml_call1(jobs_fun, jobs$0);
     caml_call1(mask_fun, mask$0);
     caml_call1(front_fun, front$0);
     caml_call1(length_fun, length$0);
     return 0;
    }
    return caml_call4(Base_Invariant[1], _B_, t, sexp_of_t, _N_);
   }
   function create_array(capacity){
    return caml_call1(Core_Uniform_array[71], capacity * 3 | 0);
   }
   function create(param){return [0, 0, 0, create_array(0), -1, 0, 0, 0];}
   function backtrace_of_first_enqueue(t){return t[7];}
   function clear(t){t[5] = 0; t[6] = 0; t[2] = 0; return 0;}
   function set(t, i, execution_context, f, a){
    var offset$0 = offset(t, i);
    caml_call3(Core_Uniform_array[24], t[3], offset$0, execution_context);
    caml_call3(Core_Uniform_array[24], t[3], offset$0 + 1 | 0, f);
    return caml_call3(Core_Uniform_array[24], t[3], offset$0 + 2 | 0, a);
   }
   function enqueue(t, execution_context, f, a){
    var _M_ = capacity(t);
    if(caml_call2(Async_kernel_Import[3], t[6], _M_)){
     if(t[7]){
      var _L_ = capacity(t);
      if(! caml_call2(Async_kernel_Import[4], _L_, 0))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
     }
     else
      t[7] = [0, caml_call2(Base_Backtrace[2], 0, 0)];
     var
      old_capacity = capacity(t),
      new_capacity =
        caml_call2(Async_kernel_Import[10], 1, old_capacity * 2 | 0),
      old_jobs = t[3],
      old_front = t[5],
      len1 =
        caml_call2(Core_Int[89], t[6], old_capacity - old_front | 0) * 3 | 0,
      len2 = (t[6] * 3 | 0) - len1 | 0,
      new_jobs = create_array(new_capacity);
     caml_call5
      (Core_Uniform_array[41], old_jobs, old_front * 3 | 0, new_jobs, 0, len1);
     caml_call5(Core_Uniform_array[41], old_jobs, 0, new_jobs, len1, len2);
     t[4] = new_capacity - 1 | 0;
     t[3] = new_jobs;
     t[5] = 0;
    }
    set(t, t[6], execution_context, f, a);
    t[6] = t[6] + 1 | 0;
    return 0;
   }
   function set_jobs_left_this_cycle$0(t, n){
    if(caml_call2(Async_kernel_Import[5], n, 0)){
     var
      _I_ = [0, [1, [0, _D_, [0, sexp_of_t(t), 0]]], 0],
      _J_ = [0, [1, [0, _E_, [0, caml_call1(Core[389], n), 0]]], _I_],
      _K_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Jobs_set_jobs_left_this_cy),
          _J_]];
     caml_call1(Core[261], _K_);
    }
    t[2] = n;
    return 0;
   }
   function can_run_a_job(t){
    var _H_ = caml_call2(Async_kernel_Import[4], t[6], 0);
    return _H_ ? caml_call2(Async_kernel_Import[4], t[2], 0) : _H_;
   }
   function run_job(t, scheduler, execution_context, f, a){
    t[1] = t[1] + 1 | 0;
    caml_call2(Async_kernel_Scheduler0[2], scheduler, execution_context);
    return caml_call1(f, a);
   }
   function run_external_jobs(t, scheduler){
    var external_jobs = scheduler[20];
    for(;;){
     var _G_ = caml_call1(Thread_safe_queue[4], external_jobs);
     if(! caml_call2(Async_kernel_Import[4], _G_, 0)) return;
     var
      match = caml_call1(Thread_safe_queue[6], external_jobs),
      a = match[3],
      f = match[2],
      execution_context = match[1];
     run_job(t, scheduler, execution_context, f, a);
    }
   }
   function run_jobs(t, scheduler){
    try{
     run_external_jobs(t, scheduler);
     for(;;){
      if(! can_run_a_job(t)) return _F_;
      var
       this_job = offset(t, 0),
       execution_context = caml_call2(Core_Uniform_array[21], t[3], this_job),
       f = caml_call2(Core_Uniform_array[21], t[3], this_job + 1 | 0),
       a = caml_call2(Core_Uniform_array[21], t[3], this_job + 2 | 0);
      set(t, 0, dummy_e, dummy_f, dummy_a);
      t[5] = (t[5] + 1 | 0) & t[4];
      t[6] = t[6] - 1 | 0;
      t[2] = t[2] - 1 | 0;
      run_job(t, scheduler, execution_context, f, a);
      run_external_jobs(t, scheduler);
     }
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      backtrace = caml_call1(Base_Backtrace[6][4], 0);
     return [1, [0, exn, backtrace]];
    }
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_queue);
   var
    Async_kernel_Job_queue =
      [0,
       sexp_of_t,
       invariant,
       create,
       enqueue,
       clear,
       set_jobs_left_this_cycle$0,
       can_run_a_job,
       length,
       run_jobs,
       num_jobs_run,
       backtrace_of_first_enqueue];
   runtime.caml_register_global
    (50, Async_kernel_Job_queue, cst_Async_kernel_Job_queue$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Synchronous_time_source0
//# unitInfo: Requires: Async_kernel__Job_or_event, Async_kernel__Scheduler0, Async_kernel__Time_ns, Base__Backtrace, Base__Invariant, Core, Core__Bool, Core__Error, Core__List, Core__Option, Core__Or_error, Core__Time_ns, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Synchronous_t$0 =
      "Async_kernel__Synchronous_time_source0",
    cst_async_kernel$0 = "async_kernel",
    cst_at$0 = "at",
    cst_events$0 = "events",
    cst_interval$0 = "interval",
    cst_now = "now",
    cst_src_synchronous_time_sourc$0 = "src/synchronous_time_source0.ml",
    cst_status$0 = "status",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos$3 = "src/synchronous_time_source0.ml:347:32",
    pos$2 = "src/synchronous_time_source0.ml:346:32",
    pos$1 = "src/synchronous_time_source0.ml:189:30",
    pos$0 = "src/synchronous_time_source0.ml:207:32",
    pos = "src/synchronous_time_source0.ml:217:32",
    Timing_wheel = global_data.Timing_wheel,
    Core_Error = global_data.Core__Error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Or_error = global_data.Core__Or_error,
    Core_Time_ns = global_data.Core__Time_ns,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_List = global_data.Core__List,
    Async_kernel_Job_or_event = global_data.Async_kernel__Job_or_event,
    Core_Option = global_data.Core__Option,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Synchronous_t$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_synchronous_time_sourc$0);
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_async_kernel$0,
     "synchronous_time_source0.ml");
   var
    typerep_of_t = Async_kernel_Time_ns[1],
    typename_of_t = Async_kernel_Time_ns[2],
    quickcheck_generator = Async_kernel_Time_ns[3],
    quickcheck_observer = Async_kernel_Time_ns[4],
    quickcheck_shrinker = Async_kernel_Time_ns[5],
    gen_incl = Async_kernel_Time_ns[6],
    gen_uniform_incl = Async_kernel_Time_ns[7],
    is_earlier = Async_kernel_Time_ns[8],
    is_later = Async_kernel_Time_ns[9],
    of_date_ofday = Async_kernel_Time_ns[10],
    of_date_ofday_precise = Async_kernel_Time_ns[11],
    to_date_ofday = Async_kernel_Time_ns[12],
    to_date_ofday_precise = Async_kernel_Time_ns[13],
    to_date = Async_kernel_Time_ns[14],
    to_ofday = Async_kernel_Time_ns[15],
    reset_date_cache = Async_kernel_Time_ns[16],
    convert = Async_kernel_Time_ns[17],
    utc_offset = Async_kernel_Time_ns[18],
    to_filename_string = Async_kernel_Time_ns[19],
    of_filename_string = Async_kernel_Time_ns[20],
    to_string_abs = Async_kernel_Time_ns[21],
    to_string_abs_trimmed = Async_kernel_Time_ns[22],
    to_string_abs_parts = Async_kernel_Time_ns[23],
    to_string_trimmed = Async_kernel_Time_ns[24],
    to_sec_string = Async_kernel_Time_ns[25],
    to_sec_string_with_zone = Async_kernel_Time_ns[26],
    of_localized_string = Async_kernel_Time_ns[27],
    of_string_gen = Async_kernel_Time_ns[28],
    to_string_iso8601_basic = Async_kernel_Time_ns[29],
    occurrence = Async_kernel_Time_ns[30],
    of_string = Async_kernel_Time_ns[31],
    of_string_with_utc_offset = Async_kernel_Time_ns[32],
    to_string = Async_kernel_Time_ns[33],
    to_string_utc = Async_kernel_Time_ns[34],
    epoch = Async_kernel_Time_ns[35],
    min_value_representable = Async_kernel_Time_ns[36],
    max_value_representable = Async_kernel_Time_ns[37],
    min_value_for_1us_rounding = Async_kernel_Time_ns[38],
    max_value_for_1us_rounding = Async_kernel_Time_ns[39],
    min_value = Async_kernel_Time_ns[40],
    max_value = Async_kernel_Time_ns[41],
    now = Async_kernel_Time_ns[42],
    add = Async_kernel_Time_ns[43],
    add_saturating = Async_kernel_Time_ns[44],
    sub_saturating = Async_kernel_Time_ns[45],
    sub = Async_kernel_Time_ns[46],
    next = Async_kernel_Time_ns[47],
    prev = Async_kernel_Time_ns[48],
    diff = Async_kernel_Time_ns[49],
    abs_diff = Async_kernel_Time_ns[50],
    to_span_since_epoch = Async_kernel_Time_ns[51],
    of_span_since_epoch = Async_kernel_Time_ns[52],
    to_int63_ns_since_epoch = Async_kernel_Time_ns[53],
    of_int63_ns_since_epoch = Async_kernel_Time_ns[54],
    to_int_ns_since_epoch = Async_kernel_Time_ns[55],
    of_int_ns_since_epoch = Async_kernel_Time_ns[56],
    next_multiple = Async_kernel_Time_ns[57],
    prev_multiple = Async_kernel_Time_ns[58],
    round_up_to_us = Async_kernel_Time_ns[59],
    round_up_to_ms = Async_kernel_Time_ns[60],
    round_up_to_sec = Async_kernel_Time_ns[61],
    round_down_to_us = Async_kernel_Time_ns[62],
    round_down_to_ms = Async_kernel_Time_ns[63],
    round_down_to_sec = Async_kernel_Time_ns[64],
    random = Async_kernel_Time_ns[65],
    of_time = Async_kernel_Time_ns[66],
    to_time = Async_kernel_Time_ns[67],
    to_time_float_round_nearest = Async_kernel_Time_ns[68],
    to_time_float_round_nearest_mi = Async_kernel_Time_ns[69],
    of_time_float_round_nearest = Async_kernel_Time_ns[70],
    of_time_float_round_nearest_mi = Async_kernel_Time_ns[71],
    arg_type = Async_kernel_Time_ns[72],
    get_sexp_zone = Async_kernel_Time_ns[73],
    interruptible_pause = Async_kernel_Time_ns[74],
    of_date_ofday_zoned = Async_kernel_Time_ns[75],
    of_string_abs = Async_kernel_Time_ns[76],
    of_string_fix_proto = Async_kernel_Time_ns[77],
    pause = Async_kernel_Time_ns[78],
    pause_forever = Async_kernel_Time_ns[79],
    pp = Async_kernel_Time_ns[80],
    set_sexp_zone = Async_kernel_Time_ns[81],
    sexp_of_t_abs = Async_kernel_Time_ns[82],
    t_of_sexp_abs = Async_kernel_Time_ns[83],
    to_date_ofday_zoned = Async_kernel_Time_ns[84],
    to_ofday_zoned = Async_kernel_Time_ns[85],
    to_string_fix_proto = Async_kernel_Time_ns[86],
    bin_size_t = Async_kernel_Time_ns[87],
    bin_write_t = Async_kernel_Time_ns[88],
    bin_read_t = Async_kernel_Time_ns[89],
    bin_read_t$0 = Async_kernel_Time_ns[90],
    bin_shape_t = Async_kernel_Time_ns[91],
    bin_writer_t = Async_kernel_Time_ns[92],
    bin_reader_t = Async_kernel_Time_ns[93],
    bin_t = Async_kernel_Time_ns[94],
    hash_fold_t = Async_kernel_Time_ns[95],
    hash = Async_kernel_Time_ns[96],
    t_of_sexp = Async_kernel_Time_ns[97],
    t_sexp_grammar = Async_kernel_Time_ns[99],
    symbol = Async_kernel_Time_ns[100],
    symbol$0 = Async_kernel_Time_ns[101],
    symbol$1 = Async_kernel_Time_ns[102],
    symbol$2 = Async_kernel_Time_ns[103],
    symbol$3 = Async_kernel_Time_ns[104],
    symbol$4 = Async_kernel_Time_ns[105],
    equal = Async_kernel_Time_ns[106],
    compare = Async_kernel_Time_ns[107],
    min = Async_kernel_Time_ns[108],
    max = Async_kernel_Time_ns[109],
    ascending = Async_kernel_Time_ns[110],
    descending = Async_kernel_Time_ns[111],
    between = Async_kernel_Time_ns[112],
    clamp_exn = Async_kernel_Time_ns[113],
    clamp = Async_kernel_Time_ns[114],
    comparator = Async_kernel_Time_ns[115],
    validate_lbound = Async_kernel_Time_ns[116],
    validate_ubound = Async_kernel_Time_ns[117],
    validate_bound = Async_kernel_Time_ns[118],
    after = Async_kernel_Time_ns[119],
    _ap_ = [0, 0],
    cst_cannot_call_advance_by_ala =
      "cannot call [advance_by_alarms] or [advance_directly] from callback",
    _ao_ = [0, cst_src_synchronous_time_sourc$0, 650, 63],
    _an_ = [0, 0],
    cst_cannot_schedule_an_event_w = "cannot schedule an event with status",
    _am_ = [0, "reason"],
    cst_Synchronous_time_source_ab =
      "[Synchronous_time_source.abort_exn] cannot abort event",
    _al_ = [0, cst_src_synchronous_time_sourc$0, 548, 17],
    _aj_ = [0, "Previously_unscheduled"],
    _ak_ = [0, "Ok"],
    _ah_ = [0, "alarm_precision"],
    _ai_ = [0, "span"],
    cst_interval_span_smaller_than =
      "interval span smaller than alarm precision",
    _af_ = [0, "_"],
    _ae_ = [0, cst_src_synchronous_time_sourc$0, 345, 17],
    _ad_ = [0, cst_src_synchronous_time_sourc$0, 352, 15],
    _ac_ = [0, cst_src_synchronous_time_sourc$0, 356, 17],
    _ab_ = [0, cst_src_synchronous_time_sourc$0, 368, 29],
    _ag_ = [0, cst_src_synchronous_time_sourc$0, 329, 11681, 11705],
    _$_ = [0, cst_events$0],
    _aa_ = [0, cst_now],
    ___ = [0, cst_now],
    cst_wall_clock = "wall_clock",
    cst_Job_t = "<Job.t>",
    _F_ = [0, "event"],
    _G_ = [0, "to_"],
    _H_ = [0, "from"],
    cst_bug_set_status_transition_ =
      "bug -- set_status transition not allowed",
    cst_src_synchronous_time_sourc = "src/synchronous_time_source0.ml:232:12",
    _D_ = [0, cst_src_synchronous_time_sourc$0, 208, 17],
    _C_ = [0, cst_src_synchronous_time_sourc$0, 218, 17],
    _B_ = [0, cst_src_synchronous_time_sourc$0, 222, 45],
    _E_ = [0, cst_src_synchronous_time_sourc$0, 184, 6180, 6206],
    cst_Synchronous_time_source_Ev =
      "[Synchronous_time_source.Event.Option.value_exn None]",
    _k_ = [1, 0],
    _h_ = [0, cst_interval$0],
    _i_ = [0, cst_at$0],
    _j_ = [0, cst_status$0],
    _d_ = [0, "Fired"],
    _e_ = [0, "Happening_periodic_event"],
    _f_ = [0, "Scheduled"],
    _g_ = [0, "Unscheduled"],
    _b_ = [0, 13, [0, 6, [0, 6, [0, 5, 0]]]],
    cst_status = cst_status$0,
    cst_prev_fired = "prev_fired",
    cst_next_fired = "next_fired",
    cst_interval = cst_interval$0,
    cst_execution_context = "execution_context",
    cst_callback = "callback",
    cst_at = cst_at$0,
    cst_alarm = "alarm",
    cst_scheduler = "scheduler",
    cst_is_wall_clock = "is_wall_clock",
    cst_handle_fired = "handle_fired",
    cst_most_recently_fired = "most_recently_fired",
    cst_fired_events = "fired_events",
    cst_events = cst_events$0,
    cst_am_advancing = "am_advancing",
    cst_advance_errors = "advance_errors",
    cst_id = "id",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Synchronous_t = cst_Async_kernel_Synchronous_t$0;
   function sexp_of_t(t){
    var
     _bM_ = caml_call1(to_span_since_epoch, t),
     _bN_ =
       runtime.core_time_ns_format
        (caml_call1(Core_Time_ns[1][89], _bM_), "%Y-%m-%dT%H:%M:%S%z");
    return caml_call1(Core[558], _bN_);
   }
   var
    Time_ns =
      [0,
       typerep_of_t,
       typename_of_t,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       gen_incl,
       gen_uniform_incl,
       is_earlier,
       is_later,
       of_date_ofday,
       of_date_ofday_precise,
       to_date_ofday,
       to_date_ofday_precise,
       to_date,
       to_ofday,
       reset_date_cache,
       convert,
       utc_offset,
       to_filename_string,
       of_filename_string,
       to_string_abs,
       to_string_abs_trimmed,
       to_string_abs_parts,
       to_string_trimmed,
       to_sec_string,
       to_sec_string_with_zone,
       of_localized_string,
       of_string_gen,
       to_string_iso8601_basic,
       occurrence,
       of_string,
       of_string_with_utc_offset,
       to_string,
       to_string_utc,
       epoch,
       min_value_representable,
       max_value_representable,
       min_value_for_1us_rounding,
       max_value_for_1us_rounding,
       min_value,
       max_value,
       now,
       add,
       add_saturating,
       sub_saturating,
       sub,
       next,
       prev,
       diff,
       abs_diff,
       to_span_since_epoch,
       of_span_since_epoch,
       to_int63_ns_since_epoch,
       of_int63_ns_since_epoch,
       to_int_ns_since_epoch,
       of_int_ns_since_epoch,
       next_multiple,
       prev_multiple,
       round_up_to_us,
       round_up_to_ms,
       round_up_to_sec,
       round_down_to_us,
       round_down_to_ms,
       round_down_to_sec,
       random,
       of_time,
       to_time,
       to_time_float_round_nearest,
       to_time_float_round_nearest_mi,
       of_time_float_round_nearest,
       of_time_float_round_nearest_mi,
       arg_type,
       get_sexp_zone,
       interruptible_pause,
       of_date_ofday_zoned,
       of_string_abs,
       of_string_fix_proto,
       pause,
       pause_forever,
       pp,
       set_sexp_zone,
       sexp_of_t_abs,
       t_of_sexp_abs,
       to_date_ofday_zoned,
       to_ofday_zoned,
       to_string_fix_proto,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       hash_fold_t,
       hash,
       t_of_sexp,
       t_sexp_grammar,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       after,
       sexp_of_t],
    include = Timing_wheel[5],
    sexp_of_t$0 = include[1],
    null$0 = include[2],
    at = include[3],
    interval_num = include[4],
    value = include[5];
   function is_null(t){return t === caml_call1(null$0, 0) ? 1 : 0;}
   var
    Alarm = [0, sexp_of_t$0, null$0, at, interval_num, value, is_null],
    _a_ = caml_call2(Timing_wheel[1][13], Timing_wheel[1][10], 3),
    _c_ = [0, caml_call2(Timing_wheel[7][5], 0, _b_)],
    default_timing_wheel_config =
      caml_call4(Timing_wheel[8][4], 0, _c_, _a_, 0),
    compare$0 = runtime.caml_int_compare;
   function equal$0(_bL_, _bK_){return _bL_ === _bK_ ? 1 : 0;}
   function sexp_of_t$1(param){
    switch(param){
      case 0:
       return _d_;
      case 1:
       return _e_;
      case 2:
       return _f_;
      default: return _g_;
    }
   }
   function transition_is_allowed(from, to){
    a:
    {
     switch(from){
       case 0:
        if(1 !== to && 3 > to) break a; break;
       case 1:
        if(2 > to) break a; break;
       case 2:
        if(1 >= to - 1 >>> 0) break a; break;
       default: if(1 === to || 3 <= to) break a;
     }
     return 1;
    }
    return 0;
   }
   var Status = [0, compare$0, equal$0, sexp_of_t$1, transition_is_allowed];
   function sexp_of_event(param){
    var at = param[2], interval = param[5], status = param[8], match = 0;
    if(interval)
     var
      v = interval[1],
      _bI_ =
        [0, [1, [0, _h_, [0, caml_call1(Core_Time_ns[1][10], v), 0]]], match];
    else
     var _bI_ = match;
    var _bJ_ = [0, [1, [0, _i_, [0, caml_call1(Time_ns[119], at), 0]]], _bI_];
    return [1,
            [0, [1, [0, _j_, [0, caml_call1(Status[3], status), 0]]], _bJ_]];
   }
   var Event_is_block = [0], none = 0;
   function some(_bH_){return _bH_;}
   function is_none(t){return t === 0 ? 1 : 0;}
   function is_some(t){return 1 - (t === 0 ? 1 : 0);}
   function first_some(t1, t2){return is_some(t1) ? t1 : t2;}
   function unsafe_value(_bG_){return _bG_;}
   var
    Optional_syntax = [0, is_none, unsafe_value],
    Optional_syntax$0 = [0, Optional_syntax];
   function sexp_of_t$2(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)) return _k_;
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return sexp_of_event(event);
   }
   function value$0(t, default$0){
    return runtime.caml_csel_value(t === 0 ? 1 : 0, default$0, t);
   }
   function value_exn(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)){
     var
      _bF_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Synchronous_time_source_Ev);
     return caml_call1(Core[261], _bF_);
    }
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return event;
   }
   function to_option(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)) return 0;
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return [0, event];
   }
   function of_option(param){
    if(! param) return none;
    var event = param[1];
    return event;
   }
   var
    Option =
      [0,
       Event_is_block,
       none,
       some,
       is_none,
       is_some,
       first_some,
       unsafe_value,
       Optional_syntax$0,
       sexp_of_t$2,
       value$0,
       value_exn,
       to_option,
       of_option];
   function status(r){return r[8];}
   function set_status(r, v){r[8] = v; return 0;}
   function prev_fired(r){return r[7];}
   function set_prev_fired(r, v){r[7] = v; return 0;}
   function next_fired(r){return r[6];}
   function set_next_fired(r, v){r[6] = v; return 0;}
   function interval(r){return r[5];}
   function set_interval(r, v){r[5] = v; return 0;}
   function execution_context(r){return r[4];}
   function callback(r){return r[3];}
   function at$0(r){return r[2];}
   function set_at(r, v){r[2] = v; return 0;}
   function alarm(r){return r[1];}
   function set_alarm(r, v){r[1] = v; return 0;}
   function _l_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v];
   }
   var
    _m_ = [0, set_status],
    status$0 = [0, function(param){return 0;}, cst_status, _m_, status, _l_];
   function _n_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
   }
   var
    _o_ = [0, set_prev_fired],
    prev_fired$0 =
      [0, function(param){return 0;}, cst_prev_fired, _o_, prev_fired, _n_];
   function _p_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
   }
   var
    _q_ = [0, set_next_fired],
    next_fired$0 =
      [0, function(param){return 0;}, cst_next_fired, _q_, next_fired, _p_];
   function _r_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8]];
   }
   var
    _s_ = [0, set_interval],
    interval$0 =
      [0, function(param){return 0;}, cst_interval, _s_, interval, _r_];
   function _t_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8]];
   }
   var
    _u_ = 0,
    execution_context$0 =
      [0,
       function(param){return 0;},
       cst_execution_context,
       _u_,
       execution_context,
       _t_];
   function _v_(r, v){
    return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _w_ = 0,
    callback$0 =
      [0, function(param){return 0;}, cst_callback, _w_, callback, _v_];
   function _x_(r, v){
    return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _y_ = [0, set_at],
    at$1 = [0, function(param){return 0;}, cst_at, _y_, at$0, _x_];
   function _z_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
   }
   var
    _A_ = [0, set_alarm],
    alarm$0 = [0, function(param){return 0;}, cst_alarm, _A_, alarm, _z_];
   function iter
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    caml_call1(alarm_fun, alarm$0);
    caml_call1(at_fun, at$1);
    caml_call1(callback_fun, callback$0);
    caml_call1(execution_context_fun, execution_context$0);
    caml_call1(interval_fun, interval$0);
    caml_call1(next_fired_fun, next_fired$0);
    caml_call1(prev_fired_fun, prev_fired$0);
    return caml_call1(status_fun, status$0);
   }
   var
    Fields =
      [0,
       status$0,
       prev_fired$0,
       next_fired$0,
       interval$0,
       execution_context$0,
       callback$0,
       at$1,
       alarm$0,
       iter];
   function invariant(t){
    function _bq_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      _br_ =
        check
         (function(status){
           if(1 !== status) return 0;
           if(caml_call1(Core_Option[62], t[5])) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
          }),
      _bs_ =
        check
         (function(ppx_optional_e_0){
           if(caml_call1(Option[8][1][1], ppx_optional_e_0)) return 0;
           var
            prev_fired = caml_call1(Option[8][1][2], ppx_optional_e_0),
            got = t[8],
            sexpifier = Status[3],
            expect = 0,
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_013, b_014){
            return caml_call2(Status[1], a_013, b_014);
           }
           caml_call8
            (Ppx_assert_lib_Runtime[3],
             pos,
             sexpifier,
             comparator,
             here,
             message,
             equal,
             expect,
             got);
           var _bE_ = prev_fired[6];
           if(caml_call1(Option[3], t) === _bE_) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
          }),
      _bt_ =
        check
         (function(ppx_optional_e_0){
           if(caml_call1(Option[8][1][1], ppx_optional_e_0)) return 0;
           var
            next_fired = caml_call1(Option[8][1][2], ppx_optional_e_0),
            got = t[8],
            sexpifier = Status[3],
            expect = 0,
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_009, b_010){
            return caml_call2(Status[1], a_009, b_010);
           }
           caml_call8
            (Ppx_assert_lib_Runtime[3],
             pos$0,
             sexpifier,
             comparator,
             here,
             message,
             equal,
             expect,
             got);
           var _bD_ = next_fired[7];
           if(caml_call1(Option[3], t) === _bD_) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
          });
     function _bu_(_bC_){return 0;}
     function _bv_(_bB_){return 0;}
     function _bw_(_bA_){return 0;}
     function _bx_(_bz_){return 0;}
     var
      _by_ =
        check
         (function(alarm){
           var
            got = caml_call1(Alarm[6], alarm),
            expect = 2 === t[8] ? 0 : 1,
            sexpifier = Core[323],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_005, b_006){
            return caml_call2(Core[316], a_005, b_006);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos$1,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    got);
          });
     return caml_call8
             (Fields[9], _by_, _bx_, _bw_, _bv_, _bu_, _bt_, _bs_, _br_);
    }
    return caml_call4(Base_Invariant[1], _E_, t, sexp_of_event, _bq_);
   }
   function set_status$0(t, to){
    var from = t[8];
    if(1 - caml_call2(Status[4], from, to)){
     var
      _bl_ = [0, [1, [0, _F_, [0, sexp_of_event(t), 0]]], 0],
      _bm_ = [0, [1, [0, _G_, [0, caml_call1(Status[3], to), 0]]], _bl_],
      _bn_ = [0, [1, [0, _H_, [0, caml_call1(Status[3], from), 0]]], _bm_],
      _bo_ =
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_bug_set_status_transition_),
         _bn_],
      _bp_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_src_synchronous_time_sourc),
          _bo_]];
     caml_call1(Core[261], _bp_);
    }
    t[8] = to;
    return 0;
   }
   function set_status_if(is, t, to){
    var _bk_ = caml_call2(Status[2], is, t[8]);
    return _bk_ ? set_status$0(t, to) : _bk_;
   }
   var
    Event =
      [0,
       Status,
       sexp_of_event,
       Option,
       status,
       prev_fired,
       set_prev_fired,
       next_fired,
       set_next_fired,
       interval,
       set_interval,
       execution_context,
       callback,
       at$0,
       set_at,
       alarm,
       set_alarm,
       Fields,
       sexp_of_event,
       invariant,
       set_status$0,
       set_status_if,
       at$0],
    of_event = Async_kernel_Job_or_event[1],
    of_job = Async_kernel_Job_or_event[2],
    is_event = Async_kernel_Job_or_event[3],
    is_job = Async_kernel_Job_or_event[4],
    Match = Async_kernel_Job_or_event[5];
   function sexp_of_t$3(t){
    var
     k = caml_call1(Async_kernel_Job_or_event[5][1], t),
     match = caml_call2(Async_kernel_Job_or_event[5][2], k, t);
    return k
            ? caml_call1(Sexplib0_Sexp_conv[7], cst_Job_t)
            : caml_call1(Event[18], match);
   }
   var
    Job_or_event = [0, of_event, of_job, is_event, is_job, Match, sexp_of_t$3];
   function scheduler(r){return r[9];}
   function is_wall_clock(r){return r[8];}
   function handle_fired(r){return r[7];}
   function most_recently_fired(r){return r[6];}
   function set_most_recently_fired(r, v){r[6] = v; return 0;}
   function fired_events(r){return r[5];}
   function set_fired_events(r, v){r[5] = v; return 0;}
   function events(r){return r[4];}
   function am_advancing(r){return r[3];}
   function set_am_advancing(r, v){r[3] = v; return 0;}
   function advance_errors(r){return r[2];}
   function set_advance_errors(r, v){r[2] = v; return 0;}
   function id(r){return r[1];}
   function _I_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], v];
   }
   var
    _J_ = 0,
    scheduler$0 =
      [0, function(param){return 0;}, cst_scheduler, _J_, scheduler, _I_];
   function _K_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v, r[9]];
   }
   var
    _L_ = 0,
    is_wall_clock$0 =
      [0,
       function(param){return 0;},
       cst_is_wall_clock,
       _L_,
       is_wall_clock,
       _K_];
   function _M_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8], r[9]];
   }
   var
    _N_ = 0,
    handle_fired$0 =
      [0,
       function(param){return 0;},
       cst_handle_fired,
       _N_,
       handle_fired,
       _M_];
   function _O_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8], r[9]];
   }
   var
    _P_ = [0, set_most_recently_fired],
    most_recently_fired$0 =
      [0,
       function(param){return 0;},
       cst_most_recently_fired,
       _P_,
       most_recently_fired,
       _O_];
   function _Q_(r, v){
    return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8], r[9]];
   }
   var
    _R_ = [0, set_fired_events],
    fired_events$0 =
      [0,
       function(param){return 0;},
       cst_fired_events,
       _R_,
       fired_events,
       _Q_];
   function _S_(r, v){
    return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8], r[9]];
   }
   var
    _T_ = 0,
    events$0 = [0, function(param){return 0;}, cst_events, _T_, events, _S_];
   function _U_(r, v){
    return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8], r[9]];
   }
   var
    _V_ = [0, set_am_advancing],
    am_advancing$0 =
      [0,
       function(param){return 0;},
       cst_am_advancing,
       _V_,
       am_advancing,
       _U_];
   function _W_(r, v){
    return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8], r[9]];
   }
   var
    _X_ = [0, set_advance_errors],
    advance_errors$0 =
      [0,
       function(param){return 0;},
       cst_advance_errors,
       _X_,
       advance_errors,
       _W_];
   function _Y_(r, v){
    return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9]];
   }
   var _Z_ = 0, id$0 = [0, function(param){return 0;}, cst_id, _Z_, id, _Y_];
   function iter$0
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    caml_call1(id_fun, id$0);
    caml_call1(advance_errors_fun, advance_errors$0);
    caml_call1(am_advancing_fun, am_advancing$0);
    caml_call1(events_fun, events$0);
    caml_call1(fired_events_fun, fired_events$0);
    caml_call1(most_recently_fired_fun, most_recently_fired$0);
    caml_call1(handle_fired_fun, handle_fired$0);
    caml_call1(is_wall_clock_fun, is_wall_clock$0);
    return caml_call1(scheduler_fun, scheduler$0);
   }
   var
    Fields$0 =
      [0,
       scheduler$0,
       is_wall_clock$0,
       handle_fired$0,
       most_recently_fired$0,
       fired_events$0,
       events$0,
       am_advancing$0,
       advance_errors$0,
       id$0,
       iter$0];
   function sexp_of_t$4(param, _a$_){
    var
     events = _a$_[4],
     is_wall_clock = _a$_[8],
     now = caml_call1(Timing_wheel[11], events);
    if(is_wall_clock){
     var _ba_ = [0, [1, [0, ___, [0, caml_call1(Time_ns[119], now), 0]]], 0];
     return [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_wall_clock), _ba_]];
    }
    var all_events = [0, 0];
    function _bb_(alarm){
     var _bi_ = all_events[1], _bj_ = caml_call2(Alarm[5], events, alarm);
     all_events[1] = [0, [0, caml_call2(Alarm[3], events, alarm), _bj_], _bi_];
     return 0;
    }
    caml_call2(Timing_wheel[15], events, _bb_);
    function _bc_(_bh_){return _bh_[2];}
    function _bd_(param, _bg_){
     var at2 = _bg_[1], at1 = param[1];
     return caml_call2(Time_ns[106], at1, at2);
    }
    var
     _be_ = caml_call2(Core_List[79], all_events[1], _bd_),
     events$0 = caml_call2(Core_List[51], _be_, _bc_),
     _bf_ =
       [0,
        [1,
         [0, _$_, [0, caml_call2(Core[472], Job_or_event[6], events$0), 0]]],
        0];
    return [1,
            [0, [1, [0, _aa_, [0, caml_call1(Time_ns[119], now), 0]]], _bf_]];
   }
   function timing_wheel_now(t){return caml_call1(Timing_wheel[11], t[4]);}
   function is_in_fired_events(t, target_event){
    var current$1 = t[5], ppx_optional_e_0 = current$1;
    for(;;){
     if(caml_call1(Event[3][8][1][1], ppx_optional_e_0)) return 0;
     var
      current = caml_call1(Event[3][8][1][2], ppx_optional_e_0),
      _a__ = current === target_event ? 1 : 0;
     if(_a__) return _a__;
     var current$0 = current[6], ppx_optional_e_0 = current$0;
    }
   }
   function invariant_with_jobs(job_invariant, t){
    function _aP_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     function _aR_(_a9_){return 0;}
     function _aS_(_a8_){return 0;}
     function _aT_(_a7_){return 0;}
     var
      _aU_ =
        check
         (function(most_recently_fired){
           if(caml_call1(Event[3][8][1][1], most_recently_fired)) return 0;
           var event = caml_call1(Event[3][8][1][2], most_recently_fired);
           if(is_in_fired_events(t, event)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _ab_], 1);
          }),
      _aV_ =
        check
         (function(ppx_optional_e_0){
           if(caml_call1(Event[3][8][1][1], ppx_optional_e_0)) return 0;
           var
            current$1 = caml_call1(Event[3][8][1][2], ppx_optional_e_0),
            current = current$1;
           for(;;){
            var _a6_ = timing_wheel_now(t);
            if(! caml_call2(Time_ns[100], current[2], _a6_))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _ad_], 1);
            var ppx_optional_e_0$0 = current[6];
            if(caml_call1(Event[3][8][1][1], ppx_optional_e_0$0)) return 0;
            var current$0 = caml_call1(Event[3][8][1][2], ppx_optional_e_0$0);
            if(! caml_call2(Time_ns[100], current[2], current$0[2]))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _ac_], 1);
            var current = current$0;
           }
          }),
      _aW_ =
        check
         (function(events){
           function _a3_(_a5_){return 0;}
           caml_call2(Timing_wheel[6], _a3_, events);
           function _a4_(alarm){
            var
             job_or_event = caml_call2(Alarm[5], events, alarm),
             k = caml_call1(Job_or_event[5][1], job_or_event),
             event = caml_call2(Job_or_event[5][2], k, job_or_event);
            if(k) return caml_call1(job_invariant, event);
            if(alarm !== event[1])
             throw caml_maybe_attach_backtrace([0, Assert_failure, _ae_], 1);
            var
             got = event[2],
             expect = caml_call2(Alarm[3], events, alarm),
             sexpifier = Time_ns[119],
             equal = 0,
             message = 0,
             here = 0;
            function comparator(a_017, b_018){
             return caml_call2(Time_ns[106], a_017, b_018);
            }
            caml_call8
             (Ppx_assert_lib_Runtime[3],
              pos$2,
              sexpifier,
              comparator,
              here,
              message,
              equal,
              expect,
              got);
            var
             got$0 = event[8],
             sexpifier$0 = Event[1][3],
             expect$0 = 2,
             equal$0 = 0,
             message$0 = 0,
             here$0 = 0;
            function comparator$0(a_019, b_020){
             return caml_call2(Event[1][1], a_019, b_020);
            }
            caml_call8
             (Ppx_assert_lib_Runtime[3],
              pos$3,
              sexpifier$0,
              comparator$0,
              here$0,
              message$0,
              equal$0,
              expect$0,
              got$0);
            return caml_call1(Event[19], event);
           }
           return caml_call2(Timing_wheel[15], events, _a4_);
          });
     function _aX_(_a2_){return 0;}
     function _aY_(_a1_){return 0;}
     function _aZ_(_a0_){return 0;}
     return caml_call9
             (Fields$0[10],
              _aZ_,
              _aY_,
              _aX_,
              _aW_,
              _aV_,
              _aU_,
              _aT_,
              _aS_,
              _aR_);
    }
    function _aQ_(x_016){
     return sexp_of_t$4(function(param){return _af_;}, x_016);
    }
    return caml_call4(Base_Invariant[1], _ag_, t, _aQ_, _aP_);
   }
   function invariant$0(t){
    return invariant_with_jobs(function(param){return 0;}, t);
   }
   var
    T1 =
      [0,
       Event,
       Job_or_event,
       scheduler,
       is_wall_clock,
       handle_fired,
       most_recently_fired,
       set_most_recently_fired,
       fired_events,
       set_fired_events,
       events,
       am_advancing,
       set_am_advancing,
       advance_errors,
       set_advance_errors,
       id,
       Fields$0,
       sexp_of_t$4,
       timing_wheel_now,
       is_in_fired_events,
       invariant_with_jobs,
       invariant$0];
   function sexp_of_t$5(x_021){return caml_call2(T1[17], Core[171], x_021);}
   var invariant$1 = T1[21], invariant_with_jobs$0 = T1[20];
   function sexp_of_t$6(x_022){return caml_call2(T1[17], Core[212], x_022);}
   var Read_write = [0, sexp_of_t$6, invariant$1, invariant_with_jobs$0];
   function id$1(t){return t[1];}
   function is_wall_clock$1(t){return t[8];}
   function length(t){return caml_call1(Timing_wheel[14], t[4]);}
   function max_allowed_alarm_time(t){
    return caml_call1(Timing_wheel[23], t[4]);
   }
   function read_only(t){return t;}
   function fire(t, event){
    caml_call2(T1[1][20], event, 0);
    event[1] = caml_call1(Alarm[2], 0);
    var ppx_optional_e_0 = t[6];
    a:
    {
     if(! caml_call1(T1[1][3][8][1][1], ppx_optional_e_0)){
      var
       most_recently_fired = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0);
      if(caml_call2(Time_ns[100], most_recently_fired[2], event[2])){
       var
        most_recently_fired$0 =
          caml_call1(T1[1][3][8][1][2], ppx_optional_e_0);
       event[7] = caml_call1(T1[1][3][3], most_recently_fired$0);
       event[6] = most_recently_fired$0[6];
       break a;
      }
     }
     event[7] = T1[1][3][2];
     event[6] = t[5];
    }
    t[6] = caml_call1(T1[1][3][3], event);
    for(;;){
     var ppx_optional_e_0$0 = event[6];
     if(caml_call1(T1[1][3][8][1][1], ppx_optional_e_0$0))
      var continue$0 = 0;
     else{
      var
       next$0 = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0$0),
       continue$1 = caml_call2(Time_ns[100], next$0[2], event[2]);
      if(continue$1){event[7] = event[6]; event[6] = next$0[6];}
      var continue$0 = continue$1;
     }
     if(! continue$0) break;
    }
    var ppx_optional_e_0$1 = event[6];
    if(! caml_call1(T1[1][3][8][1][1], ppx_optional_e_0$1)){
     var next = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0$1);
     next[7] = caml_call1(T1[1][3][3], event);
    }
    var ppx_optional_e_0$2 = event[7];
    if(caml_call1(T1[1][3][8][1][1], ppx_optional_e_0$2)){t[5] = caml_call1(T1[1][3][3], event); return 0;}
    var prev = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0$2);
    prev[6] = caml_call1(T1[1][3][3], event);
    return 0;
   }
   function alarm_precision(t){return caml_call1(Timing_wheel[10], t[4]);}
   function next_alarm_fires_at(t){return caml_call1(Timing_wheel[39], t[4]);}
   function next_alarm_runs_at(t){
    return caml_call1(T1[1][3][5], t[5])
            ? [0, caml_call1(T1[18], t)]
            : caml_call1(Timing_wheel[39], t[4]);
   }
   function now$0(t){
    return t[8] ? caml_call1(Time_ns[42], 0) : caml_call1(T1[18], t);
   }
   var timing_wheel_now$0 = T1[18];
   function schedule(t, event){
    caml_call2(T1[1][20], event, 2);
    var _aO_ = caml_call1(T1[2][1], event);
    event[1] = caml_call3(Timing_wheel[26], t[4], event[2], _aO_);
    return 0;
   }
   function remove_from_fired(t, event, new_status){
    var ppx_optional_e_0 = t[6];
    if(! caml_call1(T1[1][3][8][1][1], ppx_optional_e_0)){
     var
      most_recently_fired = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0);
     if(event === most_recently_fired)
      t[6] = caml_call2(T1[1][3][6], event[6], event[7]);
    }
    var ppx_optional_e_0$0 = event[7];
    if(caml_call1(T1[1][3][8][1][1], ppx_optional_e_0$0))
     t[5] = event[6];
    else{
     var prev = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0$0);
     prev[6] = event[6];
    }
    var ppx_optional_e_0$1 = event[6];
    if(! caml_call1(T1[1][3][8][1][1], ppx_optional_e_0$1)){
     var next = caml_call1(T1[1][3][8][1][2], ppx_optional_e_0$1);
     next[7] = event[7];
    }
    event[6] = T1[1][3][2];
    event[7] = T1[1][3][2];
    return caml_call2(T1[1][20], event, new_status);
   }
   var
    include$0 = T1[1],
    Status$0 = include$0[1],
    sexp_of_event$0 = include$0[2],
    Option$0 = include$0[3],
    status$1 = include$0[4],
    prev_fired$1 = include$0[5],
    set_prev_fired$0 = include$0[6],
    next_fired$1 = include$0[7],
    set_next_fired$0 = include$0[8],
    interval$1 = include$0[9],
    set_interval$0 = include$0[10],
    execution_context$1 = include$0[11],
    callback$1 = include$0[12],
    set_at$0 = include$0[14],
    alarm$1 = include$0[15],
    set_alarm$0 = include$0[16],
    Fields$1 = include$0[17],
    sexp_of_t$7 = include$0[18],
    invariant$2 = include$0[19],
    set_status$1 = include$0[20],
    set_status_if$0 = include$0[21],
    scheduled_at = include$0[22];
   function create_internal(t, at, interval, callback){
    var _aL_ = T1[1][3][2], _aM_ = T1[1][3][2], _aN_ = t[9][7];
    return [0,
            caml_call1(Alarm[2], 0),
            at,
            callback,
            _aN_,
            interval,
            _aM_,
            _aL_,
            3];
   }
   function add$0(t, event){
    var _aK_ = caml_call1(timing_wheel_now$0, t);
    return caml_call2(Time_ns[100], event[2], _aK_)
            ? fire(t, event)
            : schedule(t, event);
   }
   function create_and_add(t, at, interval, callback){
    var event = create_internal(t, at, interval, callback);
    add$0(t, event);
    return event;
   }
   function at$2(t, at, callback){return create_and_add(t, at, 0, callback);}
   function after$0(t, span, callback){
    var _aJ_ = now$0(t);
    return create_and_add
            (t, caml_call2(Time_ns[118], _aJ_, span), 0, callback);
   }
   function require_span_at_least_alarm_pr(t, span){
    var
     alarm_precision$0 = alarm_precision(t),
     _aF_ = caml_call2(Core_Time_ns[1][19], span, alarm_precision$0);
    if(! _aF_) return _aF_;
    var
     _aG_ =
       [0,
        [1,
         [0, _ah_, [0, caml_call1(Core_Time_ns[1][10], alarm_precision$0), 0]]],
        0],
     _aH_ =
       [0,
        [1, [0, _ai_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]],
        _aG_],
     _aI_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_interval_span_smaller_than),
         _aH_]];
    return caml_call1(Core[261], _aI_);
   }
   function at_intervals(start, t, span, callback){
    if(start) var at = start[1], at$0 = at; else var at$0 = now$0(t);
    require_span_at_least_alarm_pr(t, span);
    return create_and_add(t, at$0, [0, span], callback);
   }
   function sexp_of_t$8(param){return param ? _aj_ : _ak_;}
   var Abort_result = [0, sexp_of_t$8];
   function abort(t, event){
    switch(event[8]){
      case 0:
       remove_from_fired(t, event, 3); return 0;
      case 1:
       if(! event[5])
        throw caml_maybe_attach_backtrace([0, Assert_failure, _al_], 1);
       event[5] = 0;
       event[8] = 3;
       return 0;
      case 2:
       caml_call2(T1[1][20], event, 3);
       caml_call2(Timing_wheel[29], t[4], event[1]);
       event[1] = caml_call1(Alarm[2], 0);
       return 0;
      default: return 1;
    }
   }
   function abort_if_possible(t, event){abort(t, event); return 0;}
   function abort_exn(t, event){
    var reason = abort(t, event);
    if(! reason) return 0;
    var
     _aD_ =
       [0, [1, [0, _am_, [0, caml_call1(Abort_result[1], reason), 0]]], 0],
     _aE_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Synchronous_time_source_ab),
         _aD_]];
    return caml_call1(Core[261], _aE_);
   }
   function create(t, callback){
    return create_internal(t, Time_ns[35], 0, callback);
   }
   function is_scheduled(event){return 3 <= event[8] ? 0 : 1;}
   function schedule_at_internal(t, event, at, interval){
    var status = event[8];
    if(3 <= status){
     event[2] = at;
     event[5] = interval;
     add$0(t, event);
     return _an_;
    }
    var
     _aB_ = [0, caml_call1(T1[1][1][3], status), 0],
     _aC_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_schedule_an_event_w),
         _aB_]];
    return caml_call1(Core_Or_error[45], _aC_);
   }
   function schedule_at(t, event, at){
    return schedule_at_internal(t, event, at, 0);
   }
   function schedule_after(t, event, span){
    var _aA_ = now$0(t);
    return schedule_at(t, event, caml_call2(Time_ns[118], _aA_, span));
   }
   function schedule_at_intervals(t, event, span, starting_at){
    require_span_at_least_alarm_pr(t, span);
    return schedule_at_internal(t, event, starting_at, [0, span]);
   }
   function schedule_at_intervals$0(t, event, span){
    return schedule_at_intervals(t, event, span, now$0(t));
   }
   function reschedule_at(t, event, at){
    switch(event[8]){
      case 0:
       remove_from_fired(t, event, 3); event[2] = at; return add$0(t, event);
      case 1:
       event[2] = at; return add$0(t, event);
      case 2:
       event[2] = at;
       var _az_ = caml_call1(timing_wheel_now$0, t);
       return caml_call2(Time_ns[102], at, _az_)
               ? caml_call3(Timing_wheel[30], t[4], event[1], at)
               : (caml_call2
                  (Timing_wheel[29], t[4], event[1]),
                 fire(t, event));
      default: event[2] = at; event[5] = 0; return add$0(t, event);
    }
   }
   function reschedule_after(t, event, span){
    var _ay_ = now$0(t);
    return reschedule_at(t, event, caml_call2(Time_ns[118], _ay_, span));
   }
   var
    Event$0 =
      [0,
       Status$0,
       sexp_of_event$0,
       Option$0,
       status$1,
       prev_fired$1,
       set_prev_fired$0,
       next_fired$1,
       set_next_fired$0,
       interval$1,
       set_interval$0,
       execution_context$1,
       callback$1,
       set_at$0,
       alarm$1,
       set_alarm$0,
       Fields$1,
       sexp_of_t$7,
       invariant$2,
       set_status$1,
       set_status_if$0,
       scheduled_at,
       create_internal,
       add$0,
       create_and_add,
       at$2,
       after$0,
       require_span_at_least_alarm_pr,
       at_intervals,
       Abort_result,
       abort,
       abort_if_possible,
       abort_exn,
       create,
       is_scheduled,
       schedule_at_internal,
       schedule_at,
       schedule_after,
       schedule_at_intervals,
       schedule_at_intervals$0,
       reschedule_at,
       reschedule_after];
   function run_after(t, span, callback){
    caml_call3(Event$0[26], t, span, callback);
    return 0;
   }
   function run_at(t, at, callback){
    caml_call3(Event$0[25], t, at, callback);
    return 0;
   }
   function run_at_intervals(start, t, span, callback){
    caml_call4(Event$0[28], start, t, span, callback);
    return 0;
   }
   function run_fired_events(t, send_exn){
    var current_execution_context = t[9][7];
    for(;;){
     var ppx_optional_e_0 = t[5];
     if(caml_call1(Event$0[3][8][1][1], ppx_optional_e_0))
      var _av_ = 0;
     else{
      var event = caml_call1(Event$0[3][8][1][2], ppx_optional_e_0);
      if(event[8])
       throw caml_maybe_attach_backtrace([0, Assert_failure, _ao_], 1);
      var new_status = event[5] ? 1 : 3;
      remove_from_fired(t, event, new_status);
      caml_call2(Async_kernel_Scheduler0[2], t[9], event[4]);
      a:
      {
       try{caml_call1(event[3], 0);}
       catch(exn$0){
        var exn = caml_wrap_exception(exn$0);
        if(send_exn){
         var
          send_exn$0 = send_exn[1],
          backtrace = caml_call1(Base_Backtrace[6][4], 0);
         caml_call3
          (send_exn$0, event[4][1], [0, [0, 936718974, backtrace]], exn);
        }
        else{
         var _aw_ = t[2];
         t[2] = [0, caml_call2(Core_Error[27], 0, exn), _aw_];
        }
        caml_call3(Event$0[20], 1, event, 3);
        break a;
       }
       var match = event[5];
       if(match){
        var interval = match[1];
        if(caml_call2(Event$0[1][2], 1, event[8])){
         var _ax_ = caml_call1(timing_wheel_now$0, t);
         event[2] = caml_call5(Time_ns[57], 0, event[2], _ax_, interval, 0);
         schedule(t, event);
        }
       }
       else
        caml_call3(Event$0[20], 1, event, 3);
      }
      var _av_ = 1;
     }
     if(! _av_)
      return caml_call2
              (Async_kernel_Scheduler0[2], t[9], current_execution_context);
    }
   }
   function any_fired_events_to_run(t){
    return caml_call1(Event$0[3][5], t[5]);
   }
   function advance_clock(t, to, send_exn){
    caml_call3(Timing_wheel[20], t[4], to, t[7]);
    return run_fired_events(t, send_exn);
   }
   function advance_clock_stop_at_next_ala(t, to, send_exn){
    caml_call3(Timing_wheel[21], t[4], to, t[7]);
    return run_fired_events(t, send_exn);
   }
   function fire_past_alarms(t, send_exn){
    caml_call2(Timing_wheel[22], t[4], t[7]);
    return run_fired_events(t, send_exn);
   }
   function advance_internal(t, to, send_exn){
    advance_clock(t, to, send_exn);
    return fire_past_alarms(t, send_exn);
   }
   function advance_internal_stop_at_next_(t, to, send_exn){
    advance_clock_stop_at_next_ala(t, to, send_exn);
    return fire_past_alarms(t, send_exn);
   }
   function prepare_to_advance(t, send_exn){
    if(t[3]){
     var
      _au_ = caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_call_advance_by_ala);
     caml_call1(Core[261], _au_);
    }
    t[3] = 1;
    if(t[2]) t[2] = 0;
    return run_fired_events(t, send_exn);
   }
   function finish_advancing(t){
    t[3] = 0;
    var errors = t[2];
    return errors ? (t[2] = 0, [1, caml_call1(Core_Error[26], errors)]) : _ap_;
   }
   function advance_by_alarms(t, to){
    prepare_to_advance(t, 0);
    var send_exn = 0;
    for(;;){
     var _at_ = caml_call1(Timing_wheel[11], t[4]);
     if(! caml_call2(Time_ns[103], _at_, to)) return finish_advancing(t);
     advance_internal_stop_at_next_(t, to, send_exn);
    }
   }
   function advance_by_alarms_by(t, by){
    var _as_ = now$0(t);
    return advance_by_alarms(t, caml_call2(Time_ns[118], _as_, by));
   }
   function advance_by_max_alarms_in_each_(t, to){
    prepare_to_advance(t, 0);
    var continue$0 = [0, 1], send_exn = 0;
    for(;;){
     if(! continue$0[1]){
      advance_internal(t, to, send_exn);
      return finish_advancing(t);
     }
     if(caml_call1(Timing_wheel[13], t[4]))
      continue$0[1] = 0;
     else{
      var next_alarm_fires_at = caml_call1(Timing_wheel[40], t[4]);
      if(caml_call2(Time_ns[99], next_alarm_fires_at, to))
       continue$0[1] = 0;
      else
       advance_internal(t, caml_call1(Timing_wheel[37], t[4]), send_exn);
     }
    }
   }
   function advance_directly(t, to){
    prepare_to_advance(t, 0);
    advance_internal(t, to, 0);
    return finish_advancing(t);
   }
   function advance_directly_by(t, by){
    var _ar_ = now$0(t);
    return advance_directly(t, caml_call2(Time_ns[118], _ar_, by));
   }
   function duration_of(t, f){
    var
     start = now$0(t),
     result = caml_call1(f, 0),
     _aq_ = now$0(t),
     duration = caml_call2(Time_ns[49], _aq_, start);
    return [0, result, duration];
   }
   function max_alarm_time_in_min_timing_w(t){
    return caml_call1(Timing_wheel[35], t[4]);
   }
   function has_events_to_run(t){return caml_call1(Event$0[3][5], t[5]);}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Synchronous_t);
   var
    Async_kernel_Synchronous_time_ =
      [0,
       Time_ns,
       Alarm,
       default_timing_wheel_config,
       T1,
       sexp_of_t$5,
       invariant$1,
       invariant_with_jobs$0,
       Read_write,
       id$1,
       is_wall_clock$1,
       length,
       max_allowed_alarm_time,
       read_only,
       fire,
       alarm_precision,
       next_alarm_fires_at,
       next_alarm_runs_at,
       now$0,
       timing_wheel_now$0,
       schedule,
       remove_from_fired,
       Event$0,
       run_after,
       run_at,
       run_at_intervals,
       run_fired_events,
       any_fired_events_to_run,
       advance_clock,
       advance_clock_stop_at_next_ala,
       fire_past_alarms,
       advance_internal,
       advance_internal_stop_at_next_,
       prepare_to_advance,
       finish_advancing,
       advance_by_alarms,
       advance_by_alarms_by,
       advance_by_max_alarms_in_each_,
       advance_directly,
       advance_directly_by,
       duration_of,
       max_alarm_time_in_min_timing_w,
       has_events_to_run];
   runtime.caml_register_global
    (102, Async_kernel_Synchronous_time_, cst_Async_kernel_Synchronous_t$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler1
//# unitInfo: Requires: Async_kernel__Debug, Async_kernel__Execution_context, Async_kernel__External_job, Async_kernel__Import, Async_kernel__Job_pool, Async_kernel__Job_queue, Async_kernel__Scheduler0, Async_kernel__Synchronous_time_source0, Async_kernel__Time_ns, Async_kernel__Types, Async_kernel_config, Base__Exn, Base__Field, Base__Invariant, Core, Core__Array, Core__Deque, Core__Error, Core__Hashtbl, Core__Int, Core__List, Core__Option, Core__Result, Core__Sexp, Core__Time_ns, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Thread_safe_queue, Timing_wheel, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler1$0 = "Async_kernel__Scheduler1",
    cst_async_kernel$0 = "async_kernel",
    cst_check_access$0 = "check_access",
    cst_check_invariants$0 = "check_invariants",
    cst_current_execution_context$0 = "current_execution_context",
    cst_cycle_count$0 = "cycle_count",
    cst_cycle_start$0 = "cycle_start",
    cst_event_added_hook$0 = "event_added_hook",
    cst_exec$0 = "exec",
    cst_execution_context$0 = "execution_context",
    cst_external_jobs$0 = "external_jobs",
    cst_in_cycle$0 = "in_cycle",
    cst_job_pool$0 = "job_pool",
    cst_job_queued_hook$0 = "job_queued_hook",
    cst_last_cycle_num_jobs$0 = "last_cycle_num_jobs",
    cst_last_cycle_time$0 = "last_cycle_time",
    cst_low_priority_jobs$0 = "low_priority_jobs",
    cst_main_execution_context$0 = "main_execution_context",
    cst_max_num_jobs_per_priority_$0 = "max_num_jobs_per_priority_per_cycle",
    cst_normal_priority_jobs$0 = "normal_priority_jobs",
    cst_record_backtraces$0 = "record_backtraces",
    cst_run_every_cycle_end$0 = "run_every_cycle_end",
    cst_run_every_cycle_end_state$0 = "run_every_cycle_end_state",
    cst_run_every_cycle_start$0 = "run_every_cycle_start",
    cst_run_every_cycle_start_stat$0 = "run_every_cycle_start_state",
    cst_src_scheduler1_ml = "src/scheduler1.ml",
    cst_thread_safe_external_job_h$0 = "thread_safe_external_job_hook",
    cst_time_source$0 = "time_source",
    cst_total_cycle_time$0 = "total_cycle_time",
    cst_uncaught_exn$0 = "uncaught_exn",
    cst_very_low_priority_workers$0 = "very_low_priority_workers",
    cst_yield$0 = "yield",
    cst_yield_until_no_jobs_remain$0 = "yield_until_no_jobs_remain",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call28
   (f,
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21,
    a22,
    a23,
    a24,
    a25,
    a26,
    a27){
    return (f.l >= 0 ? f.l : f.l = f.length) == 28
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21,
               a22,
               a23,
               a24,
               a25,
               a26,
               a27)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15,
                a16,
                a17,
                a18,
                a19,
                a20,
                a21,
                a22,
                a23,
                a24,
                a25,
                a26,
                a27]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Job_queue = global_data.Async_kernel__Job_queue,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Timing_wheel = global_data.Timing_wheel,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Types = global_data.Async_kernel__Types,
    Core_Int = global_data.Core__Int,
    Base_Exn = global_data.Base__Exn,
    Core_Sexp = global_data.Core__Sexp,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_List = global_data.Core__List,
    Tuple_pool = global_data.Tuple_pool,
    Core = global_data.Core,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Core_Option = global_data.Core__Option,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Core_Deque = global_data.Core__Deque,
    Async_kernel_Job_pool = global_data.Async_kernel__Job_pool,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Assert_failure = global_data.Assert_failure,
    Base_Field = global_data.Base__Field,
    Core_Array = global_data.Core__Array,
    Core_Error = global_data.Core__Error,
    Async_kernel_External_job = global_data.Async_kernel__External_job,
    Core_Time_ns = global_data.Core__Time_ns,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Core_Result = global_data.Core__Result;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler1$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_scheduler1_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "scheduler1.ml");
   var
    events = Async_kernel_Scheduler0[1],
    set_execution_context = Async_kernel_Scheduler0[2],
    debug = Async_kernel_Debug[10],
    _aU_ = [0, 0],
    _aV_ = [0, 0],
    cst_got_uncaught_exn = "got_uncaught_exn",
    _aO_ = [0, "t"],
    _aP_ = [0, "exn"],
    cst_Scheduler_invariant_failed = "Scheduler.invariant failed",
    _aT_ = [0, cst_src_scheduler1_ml, 172, 40],
    _aS_ = [0, cst_src_scheduler1_ml, 173, 46],
    _aR_ = [0, cst_src_scheduler1_ml, 187, 43],
    _aQ_ = [0, cst_src_scheduler1_ml, 191, 14],
    _aN_ = [0, cst_src_scheduler1_ml, 155, 2],
    cst_unhandled_exception = "unhandled exception",
    _al_ = [0, cst_record_backtraces$0],
    _am_ = [0, cst_max_num_jobs_per_priority_$0],
    _an_ = [0, cst_check_invariants$0],
    _ao_ = [0, cst_yield_until_no_jobs_remain$0],
    _ap_ = [0, cst_yield$0],
    _aq_ = [0, cst_event_added_hook$0],
    _ar_ = [0, cst_job_queued_hook$0],
    _as_ = [0, cst_thread_safe_external_job_h$0],
    _at_ = [0, cst_external_jobs$0],
    _au_ = [0, cst_time_source$0],
    _av_ = [0, cst_total_cycle_time$0],
    _aw_ = [0, cst_last_cycle_num_jobs$0],
    _ax_ = [0, cst_last_cycle_time$0],
    _ay_ = [0, cst_run_every_cycle_end_state$0],
    _az_ = [0, cst_run_every_cycle_end$0],
    _aA_ = [0, cst_run_every_cycle_start_stat$0],
    _aB_ = [0, cst_run_every_cycle_start$0],
    _aC_ = [0, cst_in_cycle$0],
    _aD_ = [0, cst_cycle_start$0],
    _aE_ = [0, cst_cycle_count$0],
    _aF_ = [0, cst_uncaught_exn$0],
    _aG_ = [0, cst_current_execution_context$0],
    _aH_ = [0, cst_main_execution_context$0],
    _aI_ = [0, cst_very_low_priority_workers$0],
    _aJ_ = [0, cst_low_priority_jobs$0],
    _aK_ = [0, cst_normal_priority_jobs$0],
    _aL_ = [0, cst_job_pool$0],
    _aM_ = [0, cst_check_access$0],
    _i_ = [0, cst_src_scheduler1_ml, 51, 1661, 1685],
    _g_ = [0, cst_exec$0],
    _h_ = [0, cst_execution_context$0],
    _a_ = [0, "Not_finished"],
    _b_ = [0, "Finished"],
    cst_exec = cst_exec$0,
    cst_execution_context = cst_execution_context$0,
    cst_record_backtraces = cst_record_backtraces$0,
    cst_max_num_jobs_per_priority_ = cst_max_num_jobs_per_priority_$0,
    cst_check_invariants = cst_check_invariants$0,
    cst_yield_until_no_jobs_remain = cst_yield_until_no_jobs_remain$0,
    cst_yield = cst_yield$0,
    cst_event_added_hook = cst_event_added_hook$0,
    cst_job_queued_hook = cst_job_queued_hook$0,
    cst_thread_safe_external_job_h = cst_thread_safe_external_job_h$0,
    cst_external_jobs = cst_external_jobs$0,
    cst_time_source = cst_time_source$0,
    cst_total_cycle_time = cst_total_cycle_time$0,
    cst_last_cycle_num_jobs = cst_last_cycle_num_jobs$0,
    cst_last_cycle_time = cst_last_cycle_time$0,
    cst_run_every_cycle_end_state = cst_run_every_cycle_end_state$0,
    cst_run_every_cycle_end = cst_run_every_cycle_end$0,
    cst_run_every_cycle_start_stat = cst_run_every_cycle_start_stat$0,
    cst_run_every_cycle_start = cst_run_every_cycle_start$0,
    cst_in_cycle = cst_in_cycle$0,
    cst_cycle_start = cst_cycle_start$0,
    cst_cycle_count = cst_cycle_count$0,
    cst_uncaught_exn = cst_uncaught_exn$0,
    cst_current_execution_context = cst_current_execution_context$0,
    cst_main_execution_context = cst_main_execution_context$0,
    cst_very_low_priority_workers = cst_very_low_priority_workers$0,
    cst_low_priority_jobs = cst_low_priority_jobs$0,
    cst_normal_priority_jobs = cst_normal_priority_jobs$0,
    cst_job_pool = cst_job_pool$0,
    cst_check_access = cst_check_access$0,
    cst_Async_cannot_create_its_ra = "Async cannot create its raw scheduler",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Scheduler1 = cst_Async_kernel_Scheduler1$0;
   function create_with_cell(cell){return [0, cell];}
   function create(param){return [0, 0];}
   function create_full(a){return [0, [2, a]];}
   var Ivar = [0, create_with_cell, create, create_full];
   function create$0(param){
    var _c$_ = [0, 0, caml_call1(Ivar[2], 0)];
    return caml_call1(Async_kernel_Types[10][1], _c$_);
   }
   var Bvar = [0, create$0];
   function sexp_of_t(param){return param ? _a_ : _b_;}
   var Exec_result = [0, sexp_of_t];
   function exec(r){return r[2];}
   function execution_context(r){return r[1];}
   function _c_(r, v){return [0, r[1], v];}
   var
    _d_ = 0,
    exec$0 = [0, function(param){return 0;}, cst_exec, _d_, exec, _c_];
   function _e_(r, v){return [0, v, r[2]];}
   var
    _f_ = 0,
    execution_context$0 =
      [0,
       function(param){return 0;},
       cst_execution_context,
       _f_,
       execution_context,
       _e_];
   function iter(execution_context_fun, exec_fun){
    caml_call1(execution_context_fun, execution_context$0);
    return caml_call1(exec_fun, exec$0);
   }
   var Fields = [0, exec$0, execution_context$0, iter];
   function sexp_of_t$0(param){
    var execution_context_002 = param[1], bnds_001 = 0;
    function _c9_(_c__){return 0;}
    var
     arg_005 = caml_call1(Sexplib0_Sexp_conv[24], _c9_),
     bnds_001$0 = [0, [1, [0, _g_, [0, arg_005, 0]]], bnds_001],
     arg_003 =
       caml_call1(Async_kernel_Execution_context[5], execution_context_002),
     bnds_001$1 = [0, [1, [0, _h_, [0, arg_003, 0]]], bnds_001$0];
    return [1, bnds_001$1];
   }
   function invariant(t){
    function _c5_(param){
     function _c7_(_c8_){return 0;}
     var
      f = Async_kernel_Execution_context[6],
      _c6_ = caml_call2(Base_Invariant[2], t, f);
     return caml_call2(Fields[3], _c6_, _c7_);
    }
    return caml_call4(Base_Invariant[1], _i_, t, sexp_of_t$0, _c5_);
   }
   var
    Very_low_priority_worker =
      [0,
       Exec_result,
       exec,
       execution_context,
       Fields,
       sexp_of_t$0,
       invariant];
   function record_backtraces(r){return r[28];}
   function set_record_backtraces(r, v){r[28] = v; return 0;}
   function max_num_jobs_per_priority_per_(r){return r[27];}
   function set_max_num_jobs_per_priority_(r, v){r[27] = v; return 0;}
   function check_invariants(r){return r[26];}
   function set_check_invariants(r, v){r[26] = v; return 0;}
   function yield_until_no_jobs_remain(r){return r[25];}
   function set_yield_until_no_jobs_remain(r, v){r[25] = v; return 0;}
   function yield$0(r){return r[24];}
   function set_yield(r, v){r[24] = v; return 0;}
   function event_added_hook(r){return r[23];}
   function set_event_added_hook(r, v){r[23] = v; return 0;}
   function job_queued_hook(r){return r[22];}
   function set_job_queued_hook(r, v){r[22] = v; return 0;}
   function thread_safe_external_job_hook(r){return r[21];}
   function set_thread_safe_external_job_h(r, v){r[21] = v; return 0;}
   function external_jobs(r){return r[20];}
   function time_source(r){return r[19];}
   function set_time_source(r, v){r[19] = v; return 0;}
   function total_cycle_time(r){return r[18];}
   function set_total_cycle_time(r, v){r[18] = v; return 0;}
   function last_cycle_num_jobs(r){return r[17];}
   function set_last_cycle_num_jobs(r, v){r[17] = v; return 0;}
   function last_cycle_time(r){return r[16];}
   function set_last_cycle_time(r, v){r[16] = v; return 0;}
   function run_every_cycle_end_state(r){return r[15];}
   function run_every_cycle_end(r){return r[14];}
   function set_run_every_cycle_end(r, v){r[14] = v; return 0;}
   function run_every_cycle_start_state(r){return r[13];}
   function run_every_cycle_start(r){return r[12];}
   function set_run_every_cycle_start(r, v){r[12] = v; return 0;}
   function in_cycle(r){return r[11];}
   function set_in_cycle(r, v){r[11] = v; return 0;}
   function cycle_start(r){return r[10];}
   function set_cycle_start(r, v){r[10] = v; return 0;}
   function cycle_count(r){return r[9];}
   function set_cycle_count(r, v){r[9] = v; return 0;}
   function uncaught_exn_unwrapped(r){return r[8];}
   function set_uncaught_exn(r, v){r[8] = v; return 0;}
   function current_execution_context(r){return r[7];}
   function set_current_execution_context(r, v){r[7] = v; return 0;}
   function main_execution_context(r){return r[6];}
   function set_main_execution_context(r, v){r[6] = v; return 0;}
   function very_low_priority_workers(r){return r[5];}
   function low_priority_jobs(r){return r[4];}
   function normal_priority_jobs(r){return r[3];}
   function job_pool(r){return r[2];}
   function set_job_pool(r, v){r[2] = v; return 0;}
   function check_access(r){return r[1];}
   function set_check_access(r, v){r[1] = v; return 0;}
   function _j_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            v];
   }
   var
    _k_ = [0, set_record_backtraces],
    record_backtraces$0 =
      [0,
       function(param){return 0;},
       cst_record_backtraces,
       _k_,
       record_backtraces,
       _j_];
   function _l_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            v,
            r[28]];
   }
   var
    _m_ = [0, set_max_num_jobs_per_priority_],
    max_num_jobs_per_priority_per_$0 =
      [0,
       function(param){return 0;},
       cst_max_num_jobs_per_priority_,
       _m_,
       max_num_jobs_per_priority_per_,
       _l_];
   function _n_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            v,
            r[27],
            r[28]];
   }
   var
    _o_ = [0, set_check_invariants],
    check_invariants$0 =
      [0,
       function(param){return 0;},
       cst_check_invariants,
       _o_,
       check_invariants,
       _n_];
   function _p_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            v,
            r[26],
            r[27],
            r[28]];
   }
   var
    _q_ = [0, set_yield_until_no_jobs_remain],
    yield_until_no_jobs_remain$0 =
      [0,
       function(param){return 0;},
       cst_yield_until_no_jobs_remain,
       _q_,
       yield_until_no_jobs_remain,
       _p_];
   function _r_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            v,
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _s_ = [0, set_yield],
    yield$1 = [0, function(param){return 0;}, cst_yield, _s_, yield$0, _r_];
   function _t_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            v,
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _u_ = [0, set_event_added_hook],
    event_added_hook$0 =
      [0,
       function(param){return 0;},
       cst_event_added_hook,
       _u_,
       event_added_hook,
       _t_];
   function _v_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            v,
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _w_ = [0, set_job_queued_hook],
    job_queued_hook$0 =
      [0,
       function(param){return 0;},
       cst_job_queued_hook,
       _w_,
       job_queued_hook,
       _v_];
   function _x_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            v,
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _y_ = [0, set_thread_safe_external_job_h],
    thread_safe_external_job_hook$0 =
      [0,
       function(param){return 0;},
       cst_thread_safe_external_job_h,
       _y_,
       thread_safe_external_job_hook,
       _x_];
   function _z_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            v,
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _A_ = 0,
    external_jobs$0 =
      [0,
       function(param){return 0;},
       cst_external_jobs,
       _A_,
       external_jobs,
       _z_];
   function _B_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            v,
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _C_ = [0, set_time_source],
    time_source$0 =
      [0, function(param){return 0;}, cst_time_source, _C_, time_source, _B_];
   function _D_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            v,
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _E_ = [0, set_total_cycle_time],
    total_cycle_time$0 =
      [0,
       function(param){return 0;},
       cst_total_cycle_time,
       _E_,
       total_cycle_time,
       _D_];
   function _F_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            v,
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _G_ = [0, set_last_cycle_num_jobs],
    last_cycle_num_jobs$0 =
      [0,
       function(param){return 0;},
       cst_last_cycle_num_jobs,
       _G_,
       last_cycle_num_jobs,
       _F_];
   function _H_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            v,
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _I_ = [0, set_last_cycle_time],
    last_cycle_time$0 =
      [0,
       function(param){return 0;},
       cst_last_cycle_time,
       _I_,
       last_cycle_time,
       _H_];
   function _J_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            v,
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _K_ = 0,
    run_every_cycle_end_state$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_end_state,
       _K_,
       run_every_cycle_end_state,
       _J_];
   function _L_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            v,
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _M_ = [0, set_run_every_cycle_end],
    run_every_cycle_end$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_end,
       _M_,
       run_every_cycle_end,
       _L_];
   function _N_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            v,
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _O_ = 0,
    run_every_cycle_start_state$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_start_stat,
       _O_,
       run_every_cycle_start_state,
       _N_];
   function _P_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            v,
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _Q_ = [0, set_run_every_cycle_start],
    run_every_cycle_start$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_start,
       _Q_,
       run_every_cycle_start,
       _P_];
   function _R_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            v,
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _S_ = [0, set_in_cycle],
    in_cycle$0 =
      [0, function(param){return 0;}, cst_in_cycle, _S_, in_cycle, _R_];
   function _T_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            v,
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _U_ = [0, set_cycle_start],
    cycle_start$0 =
      [0, function(param){return 0;}, cst_cycle_start, _U_, cycle_start, _T_];
   function _V_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _W_ = [0, set_cycle_count],
    cycle_count$0 =
      [0, function(param){return 0;}, cst_cycle_count, _W_, cycle_count, _V_];
   function _X_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _Y_ = [0, set_uncaught_exn],
    uncaught_exn =
      [0,
       function(param){return 0;},
       cst_uncaught_exn,
       _Y_,
       uncaught_exn_unwrapped,
       _X_];
   function _Z_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    ___ = [0, set_current_execution_context],
    current_execution_context$0 =
      [0,
       function(param){return 0;},
       cst_current_execution_context,
       ___,
       current_execution_context,
       _Z_];
   function _$_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _aa_ = [0, set_main_execution_context],
    main_execution_context$0 =
      [0,
       function(param){return 0;},
       cst_main_execution_context,
       _aa_,
       main_execution_context,
       _$_];
   function _ab_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ac_ = 0,
    very_low_priority_workers$0 =
      [0,
       function(param){return 0;},
       cst_very_low_priority_workers,
       _ac_,
       very_low_priority_workers,
       _ab_];
   function _ad_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ae_ = 0,
    low_priority_jobs$0 =
      [0,
       function(param){return 0;},
       cst_low_priority_jobs,
       _ae_,
       low_priority_jobs,
       _ad_];
   function _af_(r, v){
    return [0,
            r[1],
            r[2],
            v,
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ag_ = 0,
    normal_priority_jobs$0 =
      [0,
       function(param){return 0;},
       cst_normal_priority_jobs,
       _ag_,
       normal_priority_jobs,
       _af_];
   function _ah_(r, v){
    return [0,
            r[1],
            v,
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ai_ = [0, set_job_pool],
    job_pool$0 =
      [0, function(param){return 0;}, cst_job_pool, _ai_, job_pool, _ah_];
   function _aj_(r, v){
    return [0,
            v,
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13],
            r[14],
            r[15],
            r[16],
            r[17],
            r[18],
            r[19],
            r[20],
            r[21],
            r[22],
            r[23],
            r[24],
            r[25],
            r[26],
            r[27],
            r[28]];
   }
   var
    _ak_ = [0, set_check_access],
    check_access$0 =
      [0,
       function(param){return 0;},
       cst_check_access,
       _ak_,
       check_access,
       _aj_];
   function iter$0
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    caml_call1(check_access_fun, check_access$0);
    caml_call1(job_pool_fun, job_pool$0);
    caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0);
    caml_call1(low_priority_jobs_fun, low_priority_jobs$0);
    caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0);
    caml_call1(main_execution_context_fun, main_execution_context$0);
    caml_call1(current_execution_context_fun, current_execution_context$0);
    caml_call1(uncaught_exn_fun, uncaught_exn);
    caml_call1(cycle_count_fun, cycle_count$0);
    caml_call1(cycle_start_fun, cycle_start$0);
    caml_call1(in_cycle_fun, in_cycle$0);
    caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0);
    caml_call1(run_every_cycle_start_state_fu, run_every_cycle_start_state$0);
    caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0);
    caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0);
    caml_call1(last_cycle_time_fun, last_cycle_time$0);
    caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0);
    caml_call1(total_cycle_time_fun, total_cycle_time$0);
    caml_call1(time_source_fun, time_source$0);
    caml_call1(external_jobs_fun, external_jobs$0);
    caml_call1
     (thread_safe_external_job_hook_, thread_safe_external_job_hook$0);
    caml_call1(job_queued_hook_fun, job_queued_hook$0);
    caml_call1(event_added_hook_fun, event_added_hook$0);
    caml_call1(yield_fun, yield$1);
    caml_call1(yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0);
    caml_call1(check_invariants_fun, check_invariants$0);
    caml_call1
     (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0);
    return caml_call1(record_backtraces_fun, record_backtraces$0);
   }
   var
    Fields$0 =
      [0,
       record_backtraces$0,
       max_num_jobs_per_priority_per_$0,
       check_invariants$0,
       yield_until_no_jobs_remain$0,
       yield$1,
       event_added_hook$0,
       job_queued_hook$0,
       thread_safe_external_job_hook$0,
       external_jobs$0,
       time_source$0,
       total_cycle_time$0,
       last_cycle_num_jobs$0,
       last_cycle_time$0,
       run_every_cycle_end_state$0,
       run_every_cycle_end$0,
       run_every_cycle_start_state$0,
       run_every_cycle_start$0,
       in_cycle$0,
       cycle_start$0,
       cycle_count$0,
       uncaught_exn,
       current_execution_context$0,
       main_execution_context$0,
       very_low_priority_workers$0,
       low_priority_jobs$0,
       normal_priority_jobs$0,
       job_pool$0,
       check_access$0,
       iter$0];
   function sexp_of_t$1(param){
    var
     check_access_007 = param[1],
     job_pool_009 = param[2],
     very_low_priority_workers_015 = param[5],
     low_priority_jobs_013 = param[4],
     normal_priority_jobs_011 = param[3],
     main_execution_context_017 = param[6],
     current_execution_context_019 = param[7],
     uncaught_exn_021 = param[8],
     cycle_count_027 = param[9],
     cycle_start_029 = param[10],
     in_cycle_031 = param[11],
     run_every_cycle_start_033 = param[12],
     run_every_cycle_start_state_03 = param[13],
     run_every_cycle_end_037 = param[14],
     run_every_cycle_end_state_039 = param[15],
     last_cycle_time_041 = param[16],
     last_cycle_num_jobs_043 = param[17],
     total_cycle_time_045 = param[18],
     time_source_047 = param[19],
     external_jobs_049 = param[20],
     job_queued_hook_053 = param[22],
     event_added_hook_055 = param[23],
     yield_057 = param[24],
     yield_until_no_jobs_remain_059 = param[25],
     check_invariants_061 = param[26],
     max_num_jobs_per_priority_per_ = param[27],
     record_backtraces_065 = param[28],
     arg_066 = caml_call1(Core[323], record_backtraces_065),
     bnds_006 = [0, [1, [0, _al_, [0, arg_066, 0]]], 0],
     arg_064 =
       caml_call1(Async_kernel_config[6][2], max_num_jobs_per_priority_per_),
     bnds_006$0 = [0, [1, [0, _am_, [0, arg_064, 0]]], bnds_006],
     arg_062 = caml_call1(Core[323], check_invariants_061),
     bnds_006$1 = [0, [1, [0, _an_, [0, arg_062, 0]]], bnds_006$0],
     arg_060 =
       caml_call1(Sexplib0_Sexp_conv[23], yield_until_no_jobs_remain_059),
     bnds_006$2 = [0, [1, [0, _ao_, [0, arg_060, 0]]], bnds_006$1],
     arg_058 = caml_call1(Sexplib0_Sexp_conv[23], yield_057),
     bnds_006$3 = [0, [1, [0, _ap_, [0, arg_058, 0]]], bnds_006$2];
    function _cT_(param){
     function _c3_(_c4_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _c3_);
    }
    var
     arg_056 = caml_call2(Core[515], _cT_, event_added_hook_055),
     bnds_006$4 = [0, [1, [0, _aq_, [0, arg_056, 0]]], bnds_006$3];
    function _cU_(param){
     function _c1_(_c2_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _c1_);
    }
    var
     arg_054 = caml_call2(Core[515], _cU_, job_queued_hook_053),
     bnds_006$5 = [0, [1, [0, _ar_, [0, arg_054, 0]]], bnds_006$4];
    function _cV_(_c0_){return 0;}
    var
     arg_052 = caml_call1(Sexplib0_Sexp_conv[24], _cV_),
     bnds_006$6 = [0, [1, [0, _as_, [0, arg_052, 0]]], bnds_006$5],
     arg_050 =
       caml_call2
        (Thread_safe_queue[1],
         Async_kernel_External_job[1],
         external_jobs_049),
     bnds_006$7 = [0, [1, [0, _at_, [0, arg_050, 0]]], bnds_006$6],
     arg_048 =
       caml_call2
        (Async_kernel_Synchronous_time_[4][17], Core[212], time_source_047),
     bnds_006$8 = [0, [1, [0, _au_, [0, arg_048, 0]]], bnds_006$7],
     arg_046 = caml_call1(Core_Time_ns[1][10], total_cycle_time_045),
     bnds_006$9 = [0, [1, [0, _av_, [0, arg_046, 0]]], bnds_006$8],
     arg_044 = caml_call1(Core[389], last_cycle_num_jobs_043),
     bnds_006$10 = [0, [1, [0, _aw_, [0, arg_044, 0]]], bnds_006$9],
     arg_042 = caml_call1(Core_Time_ns[1][10], last_cycle_time_041),
     bnds_006$11 = [0, [1, [0, _ax_, [0, arg_042, 0]]], bnds_006$10],
     arg_040 =
       caml_call3
        (Core_Hashtbl[3],
         Async_kernel_Types[20][10],
         Sexplib0_Sexp_conv[23],
         run_every_cycle_end_state_039),
     bnds_006$12 = [0, [1, [0, _ay_, [0, arg_040, 0]]], bnds_006$11],
     arg_038 =
       caml_call2(Core[301], Sexplib0_Sexp_conv[23], run_every_cycle_end_037),
     bnds_006$13 = [0, [1, [0, _az_, [0, arg_038, 0]]], bnds_006$12],
     arg_036 =
       caml_call3
        (Core_Hashtbl[3],
         Async_kernel_Types[20][10],
         Sexplib0_Sexp_conv[23],
         run_every_cycle_start_state_03),
     bnds_006$14 = [0, [1, [0, _aA_, [0, arg_036, 0]]], bnds_006$13],
     arg_034 =
       caml_call2
        (Core[301], Sexplib0_Sexp_conv[23], run_every_cycle_start_033),
     bnds_006$15 = [0, [1, [0, _aB_, [0, arg_034, 0]]], bnds_006$14],
     arg_032 = caml_call1(Core[323], in_cycle_031),
     bnds_006$16 = [0, [1, [0, _aC_, [0, arg_032, 0]]], bnds_006$15],
     arg_030 = caml_call1(Async_kernel_Time_ns[98], cycle_start_029),
     bnds_006$17 = [0, [1, [0, _aD_, [0, arg_030, 0]]], bnds_006$16],
     arg_028 = caml_call1(Core[389], cycle_count_027),
     bnds_006$18 = [0, [1, [0, _aE_, [0, arg_028, 0]]], bnds_006$17];
    function _cW_(param){
     var
      arg1_024 = param[2],
      arg0_023 = param[1],
      res0_025 = caml_call1(Base_Exn[1], arg0_023),
      res1_026 = caml_call1(Core_Sexp[93], arg1_024);
     return [1, [0, res0_025, [0, res1_026, 0]]];
    }
    var
     arg_022 = caml_call2(Core[515], _cW_, uncaught_exn_021),
     bnds_006$19 = [0, [1, [0, _aF_, [0, arg_022, 0]]], bnds_006$18],
     arg_020 =
       caml_call1
        (Async_kernel_Execution_context[5], current_execution_context_019),
     bnds_006$20 = [0, [1, [0, _aG_, [0, arg_020, 0]]], bnds_006$19],
     arg_018 =
       caml_call1
        (Async_kernel_Execution_context[5], main_execution_context_017),
     bnds_006$21 = [0, [1, [0, _aH_, [0, arg_018, 0]]], bnds_006$20],
     arg_016 =
       caml_call2
        (Core_Deque[10],
         Very_low_priority_worker[5],
         very_low_priority_workers_015),
     bnds_006$22 = [0, [1, [0, _aI_, [0, arg_016, 0]]], bnds_006$21],
     arg_014 = caml_call1(Async_kernel_Job_queue[1], low_priority_jobs_013),
     bnds_006$23 = [0, [1, [0, _aJ_, [0, arg_014, 0]]], bnds_006$22],
     arg_012 = caml_call1(Async_kernel_Job_queue[1], normal_priority_jobs_011),
     bnds_006$24 = [0, [1, [0, _aK_, [0, arg_012, 0]]], bnds_006$23],
     arg_010 = caml_call1(Async_kernel_Job_pool[2], job_pool_009),
     bnds_006$25 = [0, [1, [0, _aL_, [0, arg_010, 0]]], bnds_006$24];
    function _cX_(param){
     function _cY_(_cZ_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _cY_);
    }
    var
     arg_008 = caml_call2(Core[515], _cX_, check_access_007),
     bnds_006$26 = [0, [1, [0, _aM_, [0, arg_008, 0]]], bnds_006$25];
    return [1, bnds_006$26];
   }
   function uncaught_exn$0(t){
    var _cR_ = t[8];
    if(! _cR_) return 0;
    var match = _cR_[1], sexp = match[2], exn = match[1];
    function _cS_(param){
     var
      arg1_068 = param[2],
      arg0_067 = param[1],
      res0_069 = caml_call1(Base_Exn[1], arg0_067),
      res1_070 = caml_call1(Core_Sexp[93], arg1_068);
     return [1, [0, res0_069, [0, res1_070, 0]]];
    }
    return [0,
            caml_call5
             (Core_Error[19],
              0,
              0,
              cst_unhandled_exception,
              [0, exn, sexp],
              _cS_)];
   }
   function num_pending_jobs(t){
    var _cQ_ = caml_call1(Async_kernel_Job_queue[8], t[4]);
    return caml_call1(Async_kernel_Job_queue[8], t[3]) + _cQ_ | 0;
   }
   function num_jobs_run(t){
    var _cP_ = caml_call1(Async_kernel_Job_queue[10], t[4]);
    return caml_call1(Async_kernel_Job_queue[10], t[3]) + _cP_ | 0;
   }
   function last_cycle_num_jobs$1(t){return t[17];}
   function unordered_is_sublist(equal, small, large){
    var large$0 = caml_call1(Core_Array[45], large);
    function _cK_(acc, x){
     function _cM_(l$0){
      function _cN_(y){return 1 - caml_call2(equal, y, x);}
      var
       _cO_ = caml_call2(Core_List[138], l$0, _cN_),
       match = _cO_[2],
       l = _cO_[1];
      if(! match) return 0;
      var r = match[2];
      return [0, caml_call2(Core[156], l, r)];
     }
     return caml_call2(Core_Option[32], acc, _cM_);
    }
    var _cL_ = caml_call3(Core_List[20], small, [0, large$0], _cK_);
    return caml_call1(Core_Option[62], _cL_);
   }
   function check_hook_table_invariant(table, array){
    var _cH_ = caml_call1(Core_Hashtbl[68], table);
    if
     (unordered_is_sublist
       (function(_cJ_, _cI_){return _cJ_ === _cI_ ? 1 : 0;}, _cH_, array))
     return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _aN_], 1);
   }
   function invariant$0(t){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, t));
        },
      _bz_ = function(_cG_){return 0;},
      _bA_ = function(_cF_){return 0;},
      _bB_ = function(_cE_){return 0;},
      _bC_ = function(_cD_){return 0;},
      _bD_ = function(_cC_){return 0;},
      _bE_ = function(_cB_){return 0;},
      _bF_ = function(_cA_){return 0;},
      _bG_ = function(_cz_){return 0;},
      _bH_ = function(_cy_){return 0;},
      _bI_ =
        function(job){
         if(caml_call2(Tuple_pool[6], t[2], job)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aQ_], 1);
        },
      _bJ_ = caml_call1(Async_kernel_Synchronous_time_[8][3], _bI_),
      _bK_ = function(_cx_){return check(_bJ_, _cx_);},
      _bL_ = function(_cw_){return 0;},
      _bM_ =
        function(last_cycle_num_jobs){
         if(caml_call2(Async_kernel_Import[1], last_cycle_num_jobs, 0))
          return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aR_], 1);
        },
      _bN_ = function(_cv_){return check(_bM_, _cv_);},
      _bO_ = function(_cu_){return 0;},
      _bP_ =
        function(run_every_cycle_end_state){
         return check_hook_table_invariant(run_every_cycle_end_state, t[14]);
        },
      _bQ_ = function(_ct_){return check(_bP_, _ct_);},
      _bR_ = function(_cs_){return 0;},
      _bS_ =
        function(run_every_cycle_start_state){
         return check_hook_table_invariant(run_every_cycle_start_state, t[12]);
        },
      _bT_ = function(_cr_){return check(_bS_, _cr_);},
      _bU_ = function(_cq_){return 0;},
      _bV_ = function(_cp_){return 0;},
      _bW_ = function(_co_){return 0;},
      _bX_ =
        function(cycle_count){
         if(caml_call2(Async_kernel_Import[1], cycle_count, 0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aS_], 1);
        },
      _bY_ = function(_cn_){return check(_bX_, _cn_);},
      _bZ_ =
        function(uncaught_exn){
         var _cl_ = caml_call1(Core[253], uncaught_exn);
         if(! _cl_) return _cl_;
         var _cm_ = num_pending_jobs(t);
         if(caml_call2(Async_kernel_Import[3], _cm_, 0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _aT_], 1);
        },
      _b0_ = function(_ck_){return check(_bZ_, _ck_);},
      _b1_ = Async_kernel_Execution_context[6],
      _b2_ = function(_cj_){return check(_b1_, _cj_);},
      _b3_ = Async_kernel_Execution_context[6],
      _b4_ = function(_ci_){return check(_b3_, _ci_);},
      _b5_ =
        function(q){
         return caml_call2(Core_Deque[17], q, Very_low_priority_worker[6]);
        },
      _b6_ = function(_ch_){return check(_b5_, _ch_);},
      _b7_ = Async_kernel_Job_queue[2],
      _b8_ = function(_cg_){return check(_b7_, _cg_);},
      _b9_ = Async_kernel_Job_queue[2],
      _b__ = function(_cf_){return check(_b9_, _cf_);},
      _b$_ = Async_kernel_Job_pool[3],
      _ca_ = function(_ce_){return check(_b$_, _ce_);},
      _cb_ = function(_cd_){return 0;},
      _cc_ =
        caml_call28
         (Fields$0[29],
          _cb_,
          _ca_,
          _b__,
          _b8_,
          _b6_,
          _b4_,
          _b2_,
          _b0_,
          _bY_,
          _bW_,
          _bV_,
          _bU_,
          _bT_,
          _bR_,
          _bQ_,
          _bO_,
          _bN_,
          _bL_,
          _bK_,
          _bH_,
          _bG_,
          _bF_,
          _bE_,
          _bD_,
          _bC_,
          _bB_,
          _bA_,
          _bz_);
     return _cc_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _bw_ = [0, [1, [0, _aO_, [0, sexp_of_t$1(t), 0]]], 0],
      _bx_ = [0, [1, [0, _aP_, [0, caml_call1(Core[625], exn), 0]]], _bw_],
      _by_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_invariant_failed),
          _bx_]];
     return caml_call1(Core[261], _by_);
    }
   }
   function free_job(t, job){return caml_call2(Tuple_pool[15], t[2], job);}
   function enqueue(t, execution_context, f, a){
    var _bu_ = caml_call1(Core[252], t[8]);
    if(_bu_){
     var priority = execution_context[2], job_queue = priority ? t[4] : t[3];
     caml_call4(Async_kernel_Job_queue[4], job_queue, execution_context, f, a);
     var match = t[22];
     if(match){var f$0 = match[1]; return caml_call1(f$0, priority);}
     var _bv_ = 0;
    }
    else
     var _bv_ = _bu_;
    return _bv_;
   }
   function enqueue_job(t, job, free_job){
    var
     job_pool = t[2],
     _bs_ = caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][5]),
     _bt_ = caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][4]);
    enqueue
     (t,
      caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][3]),
      _bt_,
      _bs_);
    return free_job ? caml_call2(Tuple_pool[15], t[2], job) : free_job;
   }
   function handle_fired(time_source, job_or_event){
    var
     k = caml_call1(Async_kernel_Synchronous_time_[4][2][5][1], job_or_event),
     match =
       caml_call2(Async_kernel_Synchronous_time_[4][2][5][2], k, job_or_event);
    return k
            ? enqueue_job(time_source[9], match, 1)
            : caml_call2
              (Async_kernel_Synchronous_time_[14], time_source, match);
   }
   function create$1(param){
    var
     now = caml_call1(Async_kernel_Time_ns[42], 0),
     t = [],
     time_source = [],
     events = caml_call2(Timing_wheel[9], Async_kernel_config[33], now),
     _a5_ = Async_kernel_config[31],
     _a6_ = Async_kernel_config[27],
     _a7_ = Async_kernel_config[18],
     _a8_ = caml_call1(Bvar[1], 0),
     _a9_ = caml_call1(Bvar[1], 0),
     _a__ = 0,
     _a$_ = 0;
    function _ba_(_br_){return 0;}
    var
     _bb_ = caml_call1(Thread_safe_queue[3], 0),
     _bc_ = caml_call1(Async_kernel_Import[16], 0.),
     _bd_ = caml_call1(Async_kernel_Import[16], 0.),
     _be_ = Async_kernel_Types[20],
     _bf_ =
       caml_call3(Core_Hashtbl[4], 0, 0, [0, _be_[20], _be_[10], _be_[36]]),
     _bg_ = Async_kernel_Types[20],
     _bh_ =
       caml_call3(Core_Hashtbl[4], 0, 0, [0, _bg_[20], _bg_[10], _bg_[36]]),
     _bi_ = Async_kernel_Execution_context[7],
     _bj_ = Async_kernel_Execution_context[7],
     _bk_ = caml_call3(Core_Deque[31], 0, 0, 0),
     _bl_ = caml_call1(Async_kernel_Job_queue[3], 0),
     _bm_ = caml_call1(Async_kernel_Job_queue[3], 0);
    caml_update_dummy
     (t,
      [0,
       0,
       caml_call1(Async_kernel_Job_pool[4], 0),
       _bm_,
       _bl_,
       _bk_,
       _bj_,
       _bi_,
       0,
       0,
       now,
       0,
       [0],
       _bh_,
       [0],
       _bf_,
       _bd_,
       0,
       _bc_,
       time_source,
       _bb_,
       _ba_,
       _a$_,
       _a__,
       _a9_,
       _a8_,
       _a7_,
       _a6_,
       _a5_]);
    var _bn_ = 1;
    function _bo_(alarm){
     return handle_fired
             (time_source, caml_call2(Timing_wheel[5][5], events, alarm));
    }
    var
     _bp_ = Async_kernel_Synchronous_time_[22][3][2],
     _bq_ = Async_kernel_Synchronous_time_[22][3][2];
    caml_update_dummy
     (time_source,
      [0,
       caml_call1(Async_kernel_Types[21][45], 0),
       0,
       0,
       events,
       _bq_,
       _bp_,
       _bo_,
       _bn_,
       t]);
    return t;
   }
   function is_dead(t){return caml_call1(Core[253], t[8]);}
   function set_check_access$0(t, f){t[1] = f; return 0;}
   function backtrace_of_first_job(t){
    var
     _a3_ = caml_call1(Async_kernel_Job_queue[11], t[4]),
     _a4_ = caml_call1(Async_kernel_Job_queue[11], t[3]);
    return caml_call2(Core_Option[59], _a4_, _a3_);
   }
   var match = caml_call1(Core_Result[54], create$1);
   if(0 === match[0])
    var t = match[1], t_ref = [0, t];
   else{
    var exn = match[1];
    caml_call3
     (Async_kernel_Debug[15], cst_Async_cannot_create_its_ra, exn, Core[625]);
    var t_ref = caml_call1(Core[83], 1);
   }
   function check_access$1(t){
    var match = t[1];
    if(! match) return 0;
    var f = match[1];
    return caml_call1(f, 0);
   }
   function t$0(param){var t = t_ref[1]; check_access$1(t); return t;}
   function current_execution_context$1(t){
    return t[28] ? caml_call1(Async_kernel_Execution_context[11], t[7]) : t[7];
   }
   function with_execution_context1(t, tmp_context, f, x){
    var old_context = current_execution_context$1(t);
    caml_call2(set_execution_context, t, tmp_context);
    function _a2_(param){
     return caml_call2(set_execution_context, t, old_context);
    }
    return caml_call3(Core[260], f, x, _a2_);
   }
   function with_execution_context(t, tmp_context, f){
    return with_execution_context1(t, tmp_context, f, 0);
   }
   function create_job(t, execution_context, f, a){
    if(caml_call1(Tuple_pool[14], t[2]))
     t[2] = caml_call2(Tuple_pool[13], 0, t[2]);
    return caml_call4(Tuple_pool[19], t[2], execution_context, f, a);
   }
   function got_uncaught_exn(t, exn, sexp){
    if(debug){
     var
      _a1_ =
        function(param){
         var
          arg1_072 = param[2],
          arg0_071 = param[1],
          res0_073 = caml_call1(Base_Exn[1], arg0_071),
          res1_074 = caml_call1(Core_Sexp[93], arg1_072);
         return [1, [0, res0_073, [0, res1_074, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15], cst_got_uncaught_exn, [0, exn, sexp], _a1_);
    }
    caml_call2
     (Core_List[19], [0, t[3], [0, t[4], 0]], Async_kernel_Job_queue[5]);
    t[8] = [0, [0, exn, sexp]];
    return 0;
   }
   function start_cycle(t, max_num_jobs_per_priority){
    var n = caml_call1(Async_kernel_config[6][5], max_num_jobs_per_priority);
    caml_call2(Async_kernel_Job_queue[6], t[3], n);
    return caml_call2(Async_kernel_Job_queue[6], t[4], n);
   }
   function run_jobs(t){
    for(;;){
     var e = caml_call2(Async_kernel_Job_queue[9], t[3], t);
     if(0 !== e[0]) return e;
     var e$0 = caml_call2(Async_kernel_Job_queue[9], t[4], t);
     if(0 !== e$0[0]) return e$0;
     if
      (!
       caml_call1(Async_kernel_Job_queue[7], t[3])
       && ! caml_call1(Async_kernel_Job_queue[7], t[4]))
      return _aU_;
    }
   }
   function stabilize(t){
    start_cycle(t, caml_call1(Async_kernel_config[6][4], Core_Int[45]));
    var match = run_jobs(t);
    if(0 === match[0]) return _aV_;
    var exn = match[1][1];
    return [1, exn];
   }
   function create_time_source(opt, now, param){
    if(opt)
     var sth = opt[1], timing_wheel_config = sth;
    else
     var timing_wheel_config = Async_kernel_config[33];
    var
     t = t$0(0),
     events = caml_call2(Timing_wheel[9], timing_wheel_config, now),
     time_source = [],
     _aX_ = 0;
    function _aY_(alarm){
     return handle_fired
             (time_source, caml_call2(Timing_wheel[5][5], events, alarm));
    }
    var
     _aZ_ = Async_kernel_Synchronous_time_[22][3][2],
     _a0_ = Async_kernel_Synchronous_time_[22][3][2];
    caml_update_dummy
     (time_source,
      [0,
       caml_call1(Async_kernel_Types[21][45], 0),
       0,
       0,
       events,
       _a0_,
       _aZ_,
       _aY_,
       _aX_,
       t]);
    return time_source;
   }
   function wall_clock(param){
    var _aW_ = t$0(0)[19];
    return caml_call1(Async_kernel_Synchronous_time_[13], _aW_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler1);
   var
    Async_kernel_Scheduler1 =
      [0,
       events,
       set_execution_context,
       debug,
       Ivar,
       Bvar,
       Very_low_priority_worker,
       record_backtraces,
       set_record_backtraces,
       max_num_jobs_per_priority_per_,
       set_max_num_jobs_per_priority_,
       check_invariants,
       set_check_invariants,
       yield_until_no_jobs_remain,
       set_yield_until_no_jobs_remain,
       yield$0,
       set_yield,
       event_added_hook,
       set_event_added_hook,
       job_queued_hook,
       set_job_queued_hook,
       thread_safe_external_job_hook,
       set_thread_safe_external_job_h,
       external_jobs,
       time_source,
       set_time_source,
       total_cycle_time,
       set_total_cycle_time,
       set_last_cycle_num_jobs,
       last_cycle_time,
       set_last_cycle_time,
       run_every_cycle_end_state,
       run_every_cycle_end,
       set_run_every_cycle_end,
       run_every_cycle_start_state,
       run_every_cycle_start,
       set_run_every_cycle_start,
       in_cycle,
       set_in_cycle,
       cycle_start,
       set_cycle_start,
       cycle_count,
       set_cycle_count,
       set_uncaught_exn,
       set_current_execution_context,
       main_execution_context,
       set_main_execution_context,
       very_low_priority_workers,
       low_priority_jobs,
       normal_priority_jobs,
       job_pool,
       set_job_pool,
       Fields$0,
       sexp_of_t$1,
       uncaught_exn_unwrapped,
       uncaught_exn$0,
       num_pending_jobs,
       num_jobs_run,
       last_cycle_num_jobs$1,
       unordered_is_sublist,
       check_hook_table_invariant,
       invariant$0,
       free_job,
       enqueue,
       enqueue_job,
       handle_fired,
       create$1,
       is_dead,
       set_check_access$0,
       backtrace_of_first_job,
       t_ref,
       check_access$1,
       t$0,
       current_execution_context$1,
       with_execution_context1,
       with_execution_context,
       create_job,
       got_uncaught_exn,
       start_cycle,
       run_jobs,
       stabilize,
       create_time_source,
       wall_clock];
   runtime.caml_register_global
    (119, Async_kernel_Scheduler1, cst_Async_kernel_Scheduler1$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar0
//# unitInfo: Requires: Async_kernel__Execution_context, Async_kernel__Scheduler1, Core, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar0$0 = "Async_kernel__Ivar0",
    cst_async_kernel$0 = "async_kernel",
    cst_src_ivar0_ml = "src/ivar0.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_ivar0_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "ivar0.ml");
   var
    _q_ = [0, cst_src_ivar0_ml, 452, 21],
    _r_ = [0, cst_src_ivar0_ml, 448, 35],
    _p_ = [0, cst_src_ivar0_ml, 385, 15],
    _o_ = [0, cst_src_ivar0_ml, 364, 15],
    _n_ = [0, cst_src_ivar0_ml, 342, 15],
    _m_ = [0, cst_src_ivar0_ml, 323, 15],
    _j_ = [0, "_"],
    _k_ = [0, "t"],
    cst_Ivar_fill_exn_called_on_fu = "Ivar.fill_exn called on full ivar",
    _l_ = [0, cst_src_ivar0_ml, 306, 15],
    _i_ = [0, cst_src_ivar0_ml, 296, 15],
    cst_Ivar_value_exn_called_on_e = "Ivar.value_exn called on empty ivar",
    _h_ = [0, cst_src_ivar0_ml, 285, 15],
    _g_ = [0, cst_src_ivar0_ml, 277, 15],
    _e_ = [0, "Full"],
    _f_ = [0, cst_src_ivar0_ml, 269, 15],
    _d_ = [0, "Empty"],
    _c_ = [0, cst_src_ivar0_ml, 258, 15],
    _b_ = [0, "execution_context"],
    _a_ = [0, cst_src_ivar0_ml, 118, 6],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Ivar0 = cst_Async_kernel_Ivar0$0;
   function set_prev(param, x){param[3] = x; return 0;}
   function set_next(param, x){param[4] = x; return 0;}
   function create(run, execution_context){
    var t = [0, run, execution_context, 0, 0];
    set_prev(t, t);
    set_next(t, t);
    return t;
   }
   function create2(run1, execution_context1, run2, execution_context2){
    var
     t1 = [0, run1, execution_context1, 0, 0],
     t2 = [0, run2, execution_context2, t1, t1];
    set_prev(t1, t2);
    set_next(t1, t2);
    return t1;
   }
   function length(t){
    var n = [0, 1], r = [0, t[4]];
    for(;;){if(r[1] === t) return n[1]; n[1]++; r[1] = r[1][4];}
   }
   function enqueue(t, scheduler, v){
    return caml_call4(Async_kernel_Scheduler1[63], scheduler, t[2], t[1], v);
   }
   function schedule_jobs(t, v){
    var scheduler = caml_call1(Async_kernel_Scheduler1[72], 0);
    enqueue(t, scheduler, v);
    var r = [0, t[4]];
    for(;;){
     if(r[1] === t) return 0;
     enqueue(r[1], scheduler, v);
     r[1] = r[1][4];
    }
   }
   function add(t, run, execution_context){
    var result = [0, run, execution_context, t[3], t];
    set_next(t[3], result);
    set_prev(t, result);
    return result;
   }
   function of_list(l){
    if(! l) return 0;
    var
     l$0 = l[2],
     match = l[1],
     execution_context = match[2],
     run = match[1],
     first = create(run, execution_context),
     prev = first,
     l$1 = l$0;
    for(;;){
     if(! l$1){set_prev(first, prev); return [0, first];}
     var
      l$2 = l$1[2],
      match$0 = l$1[1],
      execution_context$0 = match$0[2],
      run$0 = match$0[1],
      prev$0 = [0, run$0, execution_context$0, prev, first];
     set_next(prev, prev$0);
     var prev = prev$0, l$1 = l$2;
    }
   }
   function to_list(first){
    var t$1 = first[3], t = t$1, acc = 0;
    for(;;){
     var acc$0 = [0, [0, t[1], t[2]], acc];
     if(t === first) return acc$0;
     var t$0 = t[3], t = t$0, acc = acc$0;
    }
   }
   function sexp_of_t(param, t){
    var execution_context = t[2];
    return [1,
            [0,
             _b_,
             [0,
              caml_call1(Async_kernel_Execution_context[5], execution_context),
              0]]];
   }
   function cell_of_handler(x){return x;}
   function equal(t$0, t){return t$0 === t ? 1 : 0;}
   function indir(t){return [0, [3, t]];}
   var
    include = Async_kernel_Scheduler1[4],
    create_with_cell = include[1],
    create$0 = include[2],
    create_full = include[3];
   function squash(t$3){
    var match$0 = t$3[1];
    if(typeof match$0 !== "number" && 3 === match$0[0]){
     var t$4 = match$0[1], indir$1 = t$4[1];
     if(typeof indir$1 !== "number" && 3 === indir$1[0]){
      var t$5 = indir$1[1];
      a:
      {
       var indir = indir$1, t = t$5;
       for(;;){
        var indir$0 = t[1];
        if(typeof indir$0 === "number") break;
        if(3 !== indir$0[0]) break a;
        var t$0 = indir$0[1], indir = indir$0, t = t$0;
       }
      }
      var t$1 = t$3;
      for(;;){
       var match = t$1[1];
       if(typeof match !== "number" && 3 === match[0]){
        var t$2 = match[1];
        t$1[1] = indir;
        var t$1 = t$2;
        continue;
       }
       return t$1;
      }
     }
     return t$4;
    }
    return t$3;
   }
   function invariant(a_invariant, t){
    var t$0 = squash(t), handler = t$0[1];
    if(typeof handler === "number") return 0;
    switch(handler[0]){
      case 0:
       caml_call1(Async_kernel_Execution_context[6], handler[2]);
       var r = [0, handler[4]];
       for(;;){
        if(r[1] === handler) return 0;
        var t1 = r[1];
        if(t1[4][3] !== t1)
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        caml_call1(Async_kernel_Execution_context[6], t1[2]);
        r[1] = r[1][4];
       }
       break;
      case 1:
       var execution_context = handler[2];
       return caml_call1(Async_kernel_Execution_context[6], execution_context);
      case 2:
       var a = handler[1]; return caml_call1(a_invariant, a);
      default: throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    }
   }
   function sexp_of_t$0(sexp_of_a, t){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1];
        return [1, [0, _e_, [0, caml_call1(sexp_of_a, a), 0]]];
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
    return _d_;
   }
   function peek(t){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1]; return [0, a];
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     }
    return 0;
   }
   function value(t, if_empty_then_failwith){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1]; return a;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     }
    return caml_call1(Core[6], if_empty_then_failwith);
   }
   function value_exn(t){return value(t, cst_Ivar_value_exn_called_on_e);}
   function is_empty(t){
    var t$0 = squash(t), _D_ = t$0[1];
    if(typeof _D_ !== "number")
     switch(_D_[0]){
       case 2:
        return 0;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
    return 1;
   }
   function is_full(t){return 1 - is_empty(t);}
   function fill_exn(t, v){
    var x_001 = squash(t), handler = x_001[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        x_001[1] = [2, v]; return schedule_jobs(handler, v);
       case 1:
        var execution_context = handler[2], run = handler[1];
        x_001[1] = [2, v];
        var _y_ = caml_call1(Async_kernel_Scheduler1[72], 0);
        return caml_call3
                (caml_call1(Async_kernel_Scheduler1[63], _y_),
                 execution_context,
                 run,
                 v);
       case 2:
        var
         _z_ = 0,
         _A_ = 0,
         _B_ =
           [0,
            [1,
             [0,
              _k_,
              [0, sexp_of_t$0(function(param){return _j_;}, x_001), _A_]]],
            _z_],
         _C_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_Ivar_fill_exn_called_on_fu),
             _B_]];
        return caml_call1(Core[261], _C_);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     }
    x_001[1] = [2, v];
    return 0;
   }
   function remove_handler(t, handler){
    function x(_x_){return 0;}
    handler[1] = x;
    var t$0 = squash(t), cell = t$0[1];
    if(typeof cell !== "number")
     switch(cell[0]){
       case 0:
        if(handler === handler[4]){t$0[1] = 0; return 0;}
        if(handler === cell) t$0[1] = handler[4];
        set_prev(handler[4], handler[3]);
        set_next(handler[3], handler[4]);
        set_prev(handler, handler);
        return set_next(handler, handler);
       case 2:
        return 0;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
     }
    return 0;
   }
   function add_handler(t, run, execution_context){
    var t$0 = squash(t), handler = t$0[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        return add(handler, run, execution_context);
       case 1:
        var
         execution_context$0 = handler[2],
         run$0 = handler[1],
         handler$1 =
           create2(run, execution_context, run$0, execution_context$0);
        t$0[1] = handler$1;
        return handler$1;
       case 2:
        var
         v = handler[1],
         handler$2 = create(run, execution_context),
         run$1 = function(v){return caml_call1(handler$2[1], v);},
         _w_ = caml_call1(Async_kernel_Scheduler1[72], 0);
        caml_call3
         (caml_call1(Async_kernel_Scheduler1[63], _w_),
          execution_context,
          run$1,
          v);
        return handler$2;
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
     }
    var handler$0 = create(run, execution_context);
    t$0[1] = handler$0;
    return handler$0;
   }
   function has_handlers(t){
    var t$0 = squash(t), _v_ = t$0[1];
    if(typeof _v_ !== "number")
     switch(_v_[0]){
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
       case 2: break;
       default: return 1;
     }
    return 0;
   }
   function upon(t, run){
    var _u_ = caml_call1(Async_kernel_Scheduler1[72], 0);
    return add_handler(t, run, caml_call1(Async_kernel_Scheduler1[73], _u_));
   }
   function upon$0(t, run){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], scheduler),
     t$0 = squash(t),
     handler = t$0[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        add(handler, run, execution_context); return 0;
       case 1:
        var execution_context$0 = handler[2], run$0 = handler[1];
        t$0[1] = create2(run, execution_context, run$0, execution_context$0);
        return 0;
       case 2:
        var v = handler[1];
        return caml_call4
                (Async_kernel_Scheduler1[63],
                 scheduler,
                 execution_context,
                 run,
                 v);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
     }
    t$0[1] = [1, run, execution_context];
    return 0;
   }
   function connect(bind_result, bind_rhs){
    var _s_ = 1 - (bind_result === bind_rhs ? 1 : 0);
    if(! _s_) return _s_;
    var bind_result$0 = squash(bind_result), indir = [3, bind_result$0];
    a:
    {
     b:
     c:
     {
      var ivar = bind_rhs;
      d:
      for(;;){
       var bind_rhs_contents = ivar[1];
       if(typeof bind_rhs_contents === "number") break c;
       switch(bind_rhs_contents[0]){
         case 2:
          break d;
         case 3:
          var ivar$0 = bind_rhs_contents[1];
          ivar[1] = indir;
          var ivar = ivar$0;
          break;
         default: break b;
       }
      }
      break a;
     }
     if(1 - (ivar === bind_result$0 ? 1 : 0)) ivar[1] = indir;
    }
    var t1 = bind_result$0[1];
    a:
    {
     b:
     {
      if(typeof t1 !== "number")
       switch(t1[0]){
         case 0:
          if(typeof bind_rhs_contents === "number") break a;
          switch(bind_rhs_contents[0]){
            case 0:
             var last1 = t1[3], last2 = bind_rhs_contents[3];
             set_next(last1, bind_rhs_contents);
             set_next(last2, t1);
             set_prev(t1, last2);
             return set_prev(bind_rhs_contents, last1);
            case 1:
             var
              execution_context2 = bind_rhs_contents[2],
              run2 = bind_rhs_contents[1];
             add(t1, run2, execution_context2);
             return 0;
            case 2:
             var v = bind_rhs_contents[1];
             bind_result$0[1] = bind_rhs_contents;
             return schedule_jobs(t1, v);
          }
          break;
         case 1:
          var execution_context = t1[2], run = t1[1];
          if(typeof bind_rhs_contents === "number") break a;
          switch(bind_rhs_contents[0]){
            case 0:
             var handler1 = add(bind_rhs_contents, run, execution_context);
             bind_result$0[1] = handler1;
             return 0;
            case 1:
             var
              execution_context2$0 = bind_rhs_contents[2],
              run2$0 = bind_rhs_contents[1],
              handler1$0 =
                create2(run, execution_context, run2$0, execution_context2$0);
             bind_result$0[1] = handler1$0;
             return 0;
            case 2:
             var v$0 = bind_rhs_contents[1];
             bind_result$0[1] = bind_rhs_contents;
             var _t_ = caml_call1(Async_kernel_Scheduler1[72], 0);
             return caml_call3
                     (caml_call1(Async_kernel_Scheduler1[63], _t_),
                      execution_context,
                      run,
                      v$0);
          }
          break;
         case 2: break;
         default: break b;
       }
      if(typeof bind_rhs_contents !== "number" && 3 === bind_rhs_contents[0])
       break b;
      if(typeof t1 === "number") break a;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
    }
    return typeof bind_rhs_contents === "number"
            ? 0
            : (bind_result$0[1] = bind_rhs_contents, 0);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar0);
   var
    Async_kernel_Ivar0 =
      [0,
       sexp_of_t$0,
       invariant,
       create$0,
       create_full,
       create_with_cell,
       peek,
       value_exn,
       value,
       is_empty,
       is_full,
       equal,
       connect,
       fill_exn,
       fill_exn,
       [0, sexp_of_t, length, of_list, to_list],
       cell_of_handler,
       add_handler,
       remove_handler,
       has_handlers,
       upon$0,
       upon,
       indir,
       squash];
   runtime.caml_register_global
    (36, Async_kernel_Ivar0, cst_Async_kernel_Ivar0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred0
//# unitInfo: Requires: Async_kernel__Ivar0, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred0$0 = "Async_kernel__Deferred0",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Ivar0 = global_data.Async_kernel__Ivar0,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred0$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred0.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred0.ml");
   var
    cst_Deferred_value_exn_called_ =
      "Deferred.value_exn called on undetermined deferred",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred0 = cst_Async_kernel_Deferred0$0;
   function of_ivar(ivar){return ivar;}
   function invariant(invariant_a, t){
    return caml_call2(Async_kernel_Ivar0[2], invariant_a, t);
   }
   function sexp_of_t(sexp_of_a, t){
    return caml_call2(Async_kernel_Ivar0[1], sexp_of_a, t);
   }
   function peek(t){return caml_call1(Async_kernel_Ivar0[6], t);}
   function return$0(a){return caml_call1(Async_kernel_Ivar0[4], a);}
   function is_determined(t){return caml_call1(Async_kernel_Ivar0[10], t);}
   function value_exn(t){
    return caml_call2
            (Async_kernel_Ivar0[8], t, cst_Deferred_value_exn_called_);
   }
   function upon(t, f){return caml_call2(Async_kernel_Ivar0[20], t, f);}
   function create(f){
    var result = caml_call1(Async_kernel_Ivar0[3], 0);
    caml_call1(f, result);
    return result;
   }
   function bind(t, f){
    var bind_result = caml_call1(Async_kernel_Ivar0[3], 0);
    upon
     (t,
      function(a){
       var _a_ = caml_call1(f, a);
       return caml_call2(Async_kernel_Ivar0[12], bind_result, _a_);
      });
    return bind_result;
   }
   function add_handler(t, f, execution_context){
    return caml_call3(Async_kernel_Ivar0[17], t, f, execution_context);
   }
   function remove_handler(t, h){
    return caml_call2(Async_kernel_Ivar0[18], t, h);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred0);
   var
    Async_kernel_Deferred0 =
      [0,
       sexp_of_t,
       invariant,
       of_ivar,
       create,
       peek,
       value_exn,
       is_determined,
       return$0,
       upon,
       bind,
       [0, Async_kernel_Ivar0[15][1]],
       add_handler,
       remove_handler];
   runtime.caml_register_global
    (13, Async_kernel_Deferred0, cst_Async_kernel_Deferred0$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar
//# unitInfo: Requires: Async_kernel__Deferred0, Async_kernel__Ivar0, Core__Binable, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar$0 = "Async_kernel__Ivar",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Ivar0 = global_data.Async_kernel__Ivar0,
    Async_kernel_Deferred0 = global_data.Async_kernel__Deferred0,
    Core_Option = global_data.Core__Option,
    Core_Binable = global_data.Core__Binable;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/ivar.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "ivar.ml");
   var
    sexp_of_t = Async_kernel_Ivar0[1],
    invariant = Async_kernel_Ivar0[2],
    create = Async_kernel_Ivar0[3],
    create_full = Async_kernel_Ivar0[4],
    peek = Async_kernel_Ivar0[6],
    value_exn = Async_kernel_Ivar0[7],
    is_empty = Async_kernel_Ivar0[9],
    is_full = Async_kernel_Ivar0[10],
    equal = Async_kernel_Ivar0[11],
    fill_exn = Async_kernel_Ivar0[13],
    fill = Async_kernel_Ivar0[14],
    has_handlers = Async_kernel_Ivar0[19],
    read = Async_kernel_Deferred0[3],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Ivar = cst_Async_kernel_Ivar$0;
   function fill_if_empty(t, v){
    var _a_ = caml_call1(is_empty, t);
    return _a_ ? caml_call2(fill_exn, t, v) : _a_;
   }
   function to_binable(t){return caml_call1(peek, t);}
   function of_binable(param){
    if(! param) return caml_call1(create, 0);
    var a = param[1];
    return caml_call1(create_full, a);
   }
   var
    include =
      caml_call1
       (caml_call1
         (Core_Binable[7],
          [0,
           Core_Option[1],
           Core_Option[2],
           Core_Option[3],
           Core_Option[4],
           Core_Option[5]]),
        [0, to_binable, of_binable]),
    bin_shape_t = include[1],
    bin_size_t = include[2],
    bin_write_t = include[3],
    bin_read_t = include[4],
    bin_read_t$0 = include[5],
    bin_writer_t = include[6],
    bin_reader_t = include[7],
    bin_t = include[8];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar);
   var
    Async_kernel_Ivar =
      [0,
       bin_shape_t,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       sexp_of_t,
       invariant,
       equal,
       create,
       create_full,
       fill_exn,
       fill,
       fill_if_empty,
       is_empty,
       is_full,
       read,
       peek,
       value_exn,
       has_handlers];
   runtime.caml_register_global
    (15, Async_kernel_Ivar, cst_Async_kernel_Ivar$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monad_sequence
//# unitInfo: Requires: Core, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Monad_sequenc$0 = "Async_kernel__Monad_sequence",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monad_sequenc$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/monad_sequence.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "monad_sequence.ml");
   var
    _a_ = [0, "Parallel"],
    _b_ = [0, "Sequential"],
    _c_ = [0, "Max_concurrent_jobs"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Monad_sequenc = cst_Async_kernel_Monad_sequenc$0;
   function sexp_of_how(param){
    if(typeof param === "number") return -676829465 <= param ? _a_ : _b_;
    var v_001 = param[2];
    return [1, [0, _c_, [0, caml_call1(Core[389], v_001), 0]]];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monad_sequenc);
   var Async_kernel_Monad_sequence = [0, sexp_of_how];
   runtime.caml_register_global
    (15, Async_kernel_Monad_sequence, cst_Async_kernel_Monad_sequenc$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred1
//# unitInfo: Requires: Async_kernel__Deferred0, Async_kernel__Ivar, Async_kernel__Monad_sequence, Async_kernel__Scheduler1, Base__Monad, CamlinternalLazy, Core, Core__List, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred1$0 = "Async_kernel__Deferred1",
    cst_async_kernel$0 = "async_kernel",
    cst_src_deferred1_ml = "src/deferred1.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Core_List = global_data.Core__List,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core = global_data.Core,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Async_kernel_Deferred0 = global_data.Async_kernel__Deferred0,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Monad = global_data.Base__Monad,
    Async_kernel_Monad_sequence = global_data.Async_kernel__Monad_sequence;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred1$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_deferred1_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred1.ml");
   var
    sexp_of_t = Async_kernel_Deferred0[1],
    invariant = Async_kernel_Deferred0[2],
    of_ivar = Async_kernel_Deferred0[3],
    create = Async_kernel_Deferred0[4],
    peek = Async_kernel_Deferred0[5],
    value_exn = Async_kernel_Deferred0[6],
    is_determined = Async_kernel_Deferred0[7],
    upon = Async_kernel_Deferred0[9],
    Handler = Async_kernel_Deferred0[11],
    add_handler = Async_kernel_Deferred0[12],
    remove_handler = Async_kernel_Deferred0[13],
    _a_ = [0, cst_src_deferred1_ml, 121, 22],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred1 = cst_Async_kernel_Deferred1$0;
   function never(param){
    var _$_ = caml_call1(Async_kernel_Ivar[12], 0);
    return caml_call1(Async_kernel_Ivar[19], _$_);
   }
   var
    of_ivar$0 = Async_kernel_Deferred0[3],
    return$0 = Async_kernel_Deferred0[8],
    upon$0 = Async_kernel_Deferred0[9],
    bind = Async_kernel_Deferred0[10],
    map =
      [0,
       -198771759,
       function(t, f){
        var result = caml_call1(Async_kernel_Ivar[12], 0);
        caml_call2
         (upon$0,
          t,
          function(a){
           var ___ = caml_call1(f, a);
           return caml_call2(Async_kernel_Ivar[14], result, ___);
          });
        return caml_call1(of_ivar$0, result);
       }],
    M = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = M[1],
    symbol_map = M[2],
    Monad_infix = M[3],
    bind$0 = M[4],
    map$0 = M[6],
    join = M[7],
    ignore_m = M[8],
    return$1 = Async_kernel_Deferred0[8],
    include = M[11],
    symbol_bind$0 = include[2],
    symbol_map$0 = include[3],
    return$2 = Async_kernel_Deferred0[8],
    include$0 = M[11][4],
    bind$1 = include$0[2],
    map$1 = include$0[3],
    both = include$0[4],
    Open_on_rhs = include$0[5],
    return$3 = Async_kernel_Deferred0[8],
    Let_syntax = [0, bind$1, map$1, both, Open_on_rhs, return$3],
    Let_syntax$0 = [0, symbol_bind$0, symbol_map$0, return$2, Let_syntax],
    unit = caml_call1(Let_syntax$0[3], 0);
   function both$0(t1, t2){
    return caml_call1
            (create,
             function(result){
              return caml_call2
                      (upon,
                       t1,
                       function(a1){
                        return caml_call2
                                (upon,
                                 t2,
                                 function(a2){
                                  return caml_call2
                                          (Async_kernel_Ivar[14], result, [0, a1, a2]);
                                 });
                       });
             });
   }
   var
    symbol_bind$1 = Monad_infix[1],
    symbol_map$1 = Monad_infix[2],
    Infix = [0, symbol_bind$1, symbol_map$1, upon, both$0];
   function don_t_wait_for(param){return 0;}
   function map$2(param, f2){
    var f1 = param[2], t = param[1];
    return [0, t, function(x){return caml_call1(f2, caml_call1(f1, x));}];
   }
   var Choice = [0, map$2];
   function process(param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var rest = param$0[4], handler = param$0[3], t = param$0[1];
     caml_call2(remove_handler, t, handler);
     var param$0 = rest;
    }
   }
   var Unregister = [0, process];
   function choice(t, f){return [0, t, f];}
   function enabled(choices){
    var result = caml_call1(Async_kernel_Ivar[12], 0), unregisters = [0, 0];
    function ready(param){
     var _W_ = caml_call1(Async_kernel_Ivar[17], result);
     if(! _W_) return _W_;
     caml_call1(Unregister[1], unregisters[1]);
     function _X_(param){
      function _Y_(ac, param){
       var f = param[2], t = param[1], match = caml_call1(peek, t);
       if(! match) return ac;
       var v = match[1];
       return [0, caml_call1(f, v), ac];
      }
      var _Z_ = caml_call3(Core_List[20], choices, 0, _Y_);
      return caml_call1(Core_List[59], _Z_);
     }
     return caml_call2(Async_kernel_Ivar[14], result, _X_);
    }
    var
     _U_ = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], _U_);
    function _V_(acc, param){
     var f = param[2], t = param[1];
     return [0,
             t,
             f,
             caml_call3
              (Async_kernel_Deferred0[12], t, ready, execution_context),
             acc];
    }
    unregisters[1] = caml_call3(Core_List[20], choices, 0, _V_);
    return caml_call1(Async_kernel_Ivar[19], result);
   }
   function choose_result(choices){
    var choices$0 = choices;
    for(;;){
     if(! choices$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var
      choices$1 = choices$0[4],
      f = choices$0[2],
      t = choices$0[1],
      match = caml_call1(peek, t);
     if(match){var v = match[1]; return caml_call1(f, v);}
     var choices$0 = choices$1;
    }
   }
   function generic_choose(choices){
    var
     result = caml_call1(Async_kernel_Ivar[12], 0),
     _K_ = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], _K_),
     unregisters = [],
     ready = function _T_(_S_){return _T_.fun(_S_);};
    caml_update_dummy
     (unregisters,
      [246,
       function(_P_){
        var _Q_ = 0;
        function _R_(param, acc){
         var f = param[2], t = param[1];
         return [0,
                 t,
                 f,
                 caml_call3
                  (Async_kernel_Deferred0[12], t, ready, execution_context),
                 acc];
        }
        return caml_call3(Core_List[101], choices, _R_, _Q_);
       }]);
    caml_update_dummy
     (ready,
      function(param){
       var _M_ = caml_call1(Async_kernel_Ivar[17], result);
       if(! _M_) return _M_;
       var _N_ = caml_obj_tag(unregisters);
       a:
       if(250 === _N_)
        var unregisters$0 = unregisters[1];
       else{
        if(246 !== _N_ && 244 !== _N_){
         var unregisters$0 = unregisters;
         break a;
        }
        var unregisters$0 = caml_call1(CamlinternalLazy[2], unregisters);
       }
       caml_call1(Unregister[1], unregisters$0);
       var _O_ = choose_result(unregisters$0);
       return caml_call2(Async_kernel_Ivar[14], result, _O_);
      });
    var _L_ = caml_obj_tag(unregisters);
    a:
    if(250 !== _L_){
     if(246 !== _L_ && 244 !== _L_) break a;
     caml_call1(CamlinternalLazy[2], unregisters);
    }
    return caml_call1(Async_kernel_Ivar[19], result);
   }
   function choose2(a, fa, b, fb){
    var
     result = caml_call1(Async_kernel_Ivar[12], 0),
     _w_ = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], _w_),
     a_handler = [],
     b_handler = [],
     ready = function _J_(_I_){return _J_.fun(_I_);};
    caml_update_dummy
     (a_handler,
      [246,
       function(_H_){
        return caml_call3
                (Async_kernel_Deferred0[12], a, ready, execution_context);
       }]);
    caml_update_dummy
     (b_handler,
      [246,
       function(_G_){
        return caml_call3
                (Async_kernel_Deferred0[12], b, ready, execution_context);
       }]);
    caml_update_dummy
     (ready,
      function(param){
       var _z_ = caml_call1(Async_kernel_Ivar[17], result);
       if(! _z_) return _z_;
       var _A_ = caml_obj_tag(a_handler);
       a:
       if(250 === _A_)
        var _B_ = a_handler[1];
       else{
        if(246 !== _A_ && 244 !== _A_){var _B_ = a_handler; break a;}
        var _B_ = caml_call1(CamlinternalLazy[2], a_handler);
       }
       caml_call2(remove_handler, a, _B_);
       var _C_ = caml_obj_tag(b_handler);
       a:
       if(250 === _C_)
        var _D_ = b_handler[1];
       else{
        if(246 !== _C_ && 244 !== _C_){var _D_ = b_handler; break a;}
        var _D_ = caml_call1(CamlinternalLazy[2], b_handler);
       }
       caml_call2(remove_handler, b, _D_);
       var match = caml_call1(peek, a);
       if(match){
        var av = match[1], _E_ = caml_call1(fa, av);
        return caml_call2(Async_kernel_Ivar[14], result, _E_);
       }
       var _F_ = caml_call1(fb, caml_call1(value_exn, b));
       return caml_call2(Async_kernel_Ivar[14], result, _F_);
      });
    var _x_ = caml_obj_tag(a_handler);
    a:
    if(250 !== _x_){
     if(246 !== _x_ && 244 !== _x_) break a;
     caml_call1(CamlinternalLazy[2], a_handler);
    }
    var _y_ = caml_obj_tag(b_handler);
    a:
    if(250 !== _y_){
     if(246 !== _y_ && 244 !== _y_) break a;
     caml_call1(CamlinternalLazy[2], b_handler);
    }
    return caml_call1(Async_kernel_Ivar[19], result);
   }
   function choose(choices){
    if(choices){
     var _u_ = choices[2];
     if(_u_ && ! _u_[2]){
      var
       _v_ = _u_[1],
       fb = _v_[2],
       b = _v_[1],
       match = choices[1],
       fa = match[2],
       a = match[1];
      return choose2(a, fa, b, fb);
     }
    }
    return generic_choose(choices);
   }
   function any_f(ts, f){
    function _t_(t){return [0, t, f];}
    return choose(caml_call2(Core_List[51], ts, _t_));
   }
   function any(ts){return any_f(ts, function(_s_){return _s_;});}
   function any_unit(ts){return any_f(ts, function(_r_){return 0;});}
   function for$0(start, to, do$0){
    if(caml_call2(Core[91], start, to)) return caml_call1(Let_syntax$0[3], 0);
    function loop(i){
     function _p_(param){
      return caml_call2(Core[88], i, to)
              ? caml_call1(Let_syntax$0[3], 0)
              : loop(i + 1 | 0);
     }
     var _q_ = caml_call1(do$0, i);
     return caml_call2(Let_syntax$0[4][1], _q_, _p_);
    }
    return loop(start);
   }
   function repeat_until_finished(state, f){
    return caml_call1
            (create,
             function(finished){
              function loop(state){
               function _n_(param){
                if(990972795 <= param[1]){
                 var state = param[2];
                 return loop(state);
                }
                var result = param[2];
                return caml_call2(Async_kernel_Ivar[14], finished, result);
               }
               var _o_ = caml_call1(f, state);
               return caml_call2(Infix[3], _o_, _n_);
              }
              return loop(state);
             });
   }
   function forever(state, f){
    var
     _j_ = Core[158],
     _k_ =
       repeat_until_finished
        (state,
         function(state){
          function _l_(state){return [0, 990972795, state];}
          var _m_ = caml_call1(f, state);
          return caml_call2(Let_syntax$0[4][2], _m_, _l_);
         });
    return caml_call2(Infix[3], _k_, _j_);
   }
   var sexp_of_how = Async_kernel_Monad_sequence[1];
   function fold(t, init, f){
    return caml_call1
            (create,
             function(result){
              function loop(t, b){
               if(! t) return caml_call2(Async_kernel_Ivar[14], result, b);
               var xs = t[2], x = t[1];
               function _h_(b){return loop(xs, b);}
               var _i_ = caml_call2(f, b, x);
               return caml_call2(Infix[3], _i_, _h_);
              }
              return loop(t, init);
             });
   }
   function seqmap(t, f){
    var
     _d_ = Core_List[59],
     _e_ =
       fold
        (t,
         0,
         function(bs, a){
          function _f_(b){return [0, b, bs];}
          var _g_ = caml_call1(f, a);
          return caml_call2(Infix[2], _g_, _f_);
         });
    return caml_call2(Infix[2], _e_, _d_);
   }
   function all(ds){return seqmap(ds, function(_c_){return _c_;});}
   function all_unit(ds){return fold(ds, 0, function(param, d){return d;});}
   function ok(x){
    function _b_(x){return [0, x];}
    return caml_call2(Infix[2], x, _b_);
   }
   var For_tests = [0, generic_choose];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred1);
   var
    Async_kernel_Deferred1 =
      [0,
       sexp_of_t,
       invariant,
       of_ivar,
       create,
       peek,
       value_exn,
       is_determined,
       upon,
       Handler,
       add_handler,
       remove_handler,
       never,
       M,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       map$0,
       join,
       ignore_m,
       return$1,
       Let_syntax$0,
       unit,
       both$0,
       Infix,
       don_t_wait_for,
       Choice,
       Unregister,
       choice,
       enabled,
       choose_result,
       generic_choose,
       choose2,
       choose,
       any_f,
       any,
       any_unit,
       for$0,
       repeat_until_finished,
       forever,
       sexp_of_how,
       fold,
       seqmap,
       all,
       all_unit,
       ok,
       For_tests];
   runtime.caml_register_global
    (21, Async_kernel_Deferred1, cst_Async_kernel_Deferred1$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_std
//# unitInfo: Requires: Async_kernel__Deferred1, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_std = "Async_kernel__Deferred_std",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_std);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_std.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel, "deferred_std.ml");
   var
    _a_ = Async_kernel_Deferred1[25],
    symbol = _a_[3],
    ppx_both = _a_[4],
    include = Async_kernel_Deferred1[22],
    symbol_bind = include[1],
    symbol_map = include[2],
    return$0 = include[3],
    Let_syntax = include[4],
    choice = Async_kernel_Deferred1[29],
    choose = Async_kernel_Deferred1[34],
    don_t_wait_for = Async_kernel_Deferred1[26],
    never = Async_kernel_Deferred1[12],
    upon = Async_kernel_Deferred1[8];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_std);
   var
    Async_kernel_Deferred_std =
      [0,
       symbol,
       ppx_both,
       symbol_bind,
       symbol_map,
       Let_syntax,
       choice,
       choose,
       don_t_wait_for,
       never,
       return$0,
       upon];
   runtime.caml_register_global
    (12, Async_kernel_Deferred_std, cst_Async_kernel_Deferred_std);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar_filler
//# unitInfo: Requires: Async_kernel__Ivar, Base__Invariant, Core, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar_filler$0 = "Async_kernel__Ivar_filler",
    cst_async_kernel$0 = "async_kernel",
    cst_src_ivar_filler_ml = "src/ivar_filler.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar_filler$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_ivar_filler_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "ivar_filler.ml");
   var
    cst_attempt_to_fill_full_ivar = "attempt to fill full ivar",
    _d_ = [0, "_"],
    _c_ = [0, cst_src_ivar_filler_ml, 15, 20],
    _e_ = [0, cst_src_ivar_filler_ml, 12, 154, 176],
    _a_ = [0, "Empty"],
    _b_ = [0, "Full"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Ivar_filler = cst_Async_kernel_Ivar_filler$0;
   function sexp_of_t(of_a_005, x_006){
    function _i_(param){
     if(! param) return _b_;
     var
      arg0_002 = param[1],
      res0_003 = caml_call2(Async_kernel_Ivar[9], of_a_005, arg0_002);
     return [1, [0, _a_, [0, res0_003, 0]]];
    }
    return caml_call2(Core[598], _i_, x_006);
   }
   function invariant(param, t){
    function _g_(param){
     var match = t[1];
     if(! match) return 0;
     var ivar = match[1];
     if(caml_call1(Async_kernel_Ivar[17], ivar)) return 0;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    }
    function _h_(x_007){
     return sexp_of_t(function(param){return _d_;}, x_007);
    }
    return caml_call4(Base_Invariant[1], _e_, t, _h_, _g_);
   }
   function create(param){
    var ivar = caml_call1(Async_kernel_Ivar[12], 0), t = [0, [0, ivar]];
    return [0, t, caml_call1(Async_kernel_Ivar[19], ivar)];
   }
   function is_empty(t){return t[1] ? 1 : 0;}
   function fill(t, a){
    var match = t[1];
    if(match){
     var i = match[1];
     t[1] = 0;
     return caml_call2(Async_kernel_Ivar[14], i, a);
    }
    var
     _f_ = caml_call1(Sexplib0_Sexp_conv[7], cst_attempt_to_fill_full_ivar);
    return caml_call1(Core[261], _f_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar_filler);
   var
    Async_kernel_Ivar_filler =
      [0, sexp_of_t, invariant, create, is_empty, fill];
   runtime.caml_register_global
    (22, Async_kernel_Ivar_filler, cst_Async_kernel_Ivar_filler$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Tail
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Ivar, Core, Core__List, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Tail$0 = "Async_kernel__Tail",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_List = global_data.Core__List,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Tail$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/tail.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "tail.ml");
   var
    cst_stream_is_closed = "stream is closed",
    cst_open_tail = "<open tail>",
    cst_closed_tail = "<closed tail>",
    _a_ = [0, "..."],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Tail = cst_Async_kernel_Tail$0;
   function sexp_of_t(sexp_of_a, t){
    var d = t, ac = 0;
    for(;;){
     var match = caml_call1(Async_kernel_Deferred1[5], d);
     if(! match) return [1, caml_call1(Core_List[59], [0, _a_, ac])];
     var match$0 = match[1];
     if(! match$0) return [1, caml_call1(Core_List[59], ac)];
     var
      t$0 = match$0[2],
      a = match$0[1],
      ac$0 = [0, caml_call1(sexp_of_a, a), ac],
      d = t$0,
      ac = ac$0;
    }
   }
   function next(t){return t;}
   var Stream = [0, sexp_of_t, next];
   function sexp_of_t$0(param, t){
    var
     _d_ =
       caml_call1(Async_kernel_Ivar[17], t[1])
        ? cst_open_tail
        : cst_closed_tail;
    return [0, _d_];
   }
   function create(param){return [0, caml_call1(Async_kernel_Ivar[12], 0)];}
   function collect(t){return caml_call1(Async_kernel_Ivar[19], t[1]);}
   function is_closed(t){return caml_call1(Async_kernel_Ivar[18], t[1]);}
   function fill_exn(t, v){
    if(! is_closed(t)) return caml_call2(Async_kernel_Ivar[14], t[1], v);
    var _c_ = caml_call1(Sexplib0_Sexp_conv[7], cst_stream_is_closed);
    return caml_call1(Core[261], _c_);
   }
   function close_exn(t){return fill_exn(t, 0);}
   function close_if_open(t){
    var _b_ = 1 - is_closed(t);
    return _b_ ? caml_call2(Async_kernel_Ivar[14], t[1], 0) : _b_;
   }
   function extend(t, v){
    var next = caml_call1(Async_kernel_Ivar[12], 0);
    fill_exn(t, [0, v, caml_call1(Async_kernel_Ivar[19], next)]);
    t[1] = next;
    return 0;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Tail);
   var
    Async_kernel_Tail =
      [0,
       sexp_of_t$0,
       create,
       extend,
       close_exn,
       close_if_open,
       is_closed,
       Stream,
       collect];
   runtime.caml_register_global
    (20, Async_kernel_Tail, cst_Async_kernel_Tail$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monitor
//# unitInfo: Requires: Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Execution_context, Async_kernel__Ivar, Async_kernel__Ivar_filler, Async_kernel__Monitor0, Async_kernel__Scheduler1, Async_kernel__Tail, Async_kernel_config, Base__Backtrace, Base__Exn, Base__Invariant, Core, Core__Bag, Core__Error, Core__Info, Core__List, Core__Or_error, Core__Result, Core__String, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib__Conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    cst_Async_kernel_Monitor$0 = "Async_kernel__Monitor",
    cst_Caught_by_monitor = "Caught by monitor ",
    cst_async_kernel$0 = "async_kernel",
    cst_exn = "exn",
    cst_file = "file ",
    cst_src_monitor_ml = "src/monitor.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    job_queue = "Called from Async_kernel__Job_queue",
    deferred0 = "Called from Async_kernel__Deferred0",
    deferred1 = "Called from Async_kernel__Deferred1",
    monitor = "Called from Async_kernel__Monitor",
    try_with = "Called from Base__Result.try_with",
    error = "Raised at Base__Error.raise",
    Core_Error = global_data.Core__Error,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Core_Or_error = global_data.Core__Or_error,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar_filler = global_data.Async_kernel__Ivar_filler,
    Base_Exn = global_data.Base__Exn,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Core_Result = global_data.Core__Result,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_Bag = global_data.Core__Bag,
    Core_List = global_data.Core__List,
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Info = global_data.Core__Info,
    Core_String = global_data.Core__String,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Monitor0 = global_data.Async_kernel__Monitor0,
    Sexplib_Conv = global_data.Sexplib__Conv;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monitor$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_monitor_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "monitor.ml");
   var
    has_seen_error = Async_kernel_Monitor0[4],
    name = Async_kernel_Monitor0[14],
    Fields = Async_kernel_Monitor0[15],
    sexp_of_t = Async_kernel_Monitor0[18],
    create_with_parent = Async_kernel_Monitor0[20],
    main = Async_kernel_Monitor0[21],
    cst_Monitor_catch_got_unexpect =
      "Monitor.catch got unexpected empty stream",
    _r_ = [0, "finally_exn"],
    _s_ = [0, cst_exn],
    cst_Async_finally = "Async finally",
    _t_ = [0, 523273847],
    _u_ = [0, 0],
    _v_ = [0, "finally"],
    cst_Monitor_protect = "Monitor.protect",
    cst_try_with_join_or_error = "try_with_join_or_error",
    cst_try_with_or_error = "try_with_or_error",
    _q_ = [0, 3903734],
    _p_ = [0, cst_src_monitor_ml, 402, 17],
    _o_ = [0, 3553398],
    _n_ = [0, cst_exn],
    cst_failed_to_set_Monitor_Expe =
      "failed to set [Monitor.Expert.try_with_log_exn]",
    _l_ = [0, 3553398],
    _m_ = [1, 0],
    cst_Monitor_send_exn_found_lis =
      "Monitor.send_exn found listening monitor",
    cst_Monitor_send_exn = "Monitor.send_exn",
    cst_monitor_ml_Error = "monitor.ml.Error",
    _k_ = [0, cst_src_monitor_ml, 181, 6],
    _d_ =
      [0,
       [11, cst_file, [3, 0, [11, ", line LINE, characters C1-C2", 0]]],
       "file %S, line LINE, characters C1-C2"],
    _i_ =
      [0,
       [11,
        cst_file,
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11, ", characters ", [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]]]]]]],
       "file %S, line %d, characters %d-%d"],
    _e_ =
      [0,
       [11, cst_Caught_by_monitor, [2, 0, [11, " at ", [2, 0, 0]]]],
       "Caught by monitor %s at %s"],
    _g_ =
      [0, [11, "Caught by monitor at ", [2, 0, 0]], "Caught by monitor at %s"],
    _h_ = [0, [11, cst_Caught_by_monitor, [2, 0, 0]], "Caught by monitor %s"],
    _f_ = [0, "backtrace_history"],
    _c_ = [0, cst_src_monitor_ml, 42, 23],
    _a_ = [0, cst_src_monitor_ml, 20, 44],
    _b_ = [0, cst_src_monitor_ml, 13, 226, 248],
    cst_Async_kernel_Monitor_Monit = "Async_kernel__Monitor.Monitor_exn",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Monitor = cst_Async_kernel_Monitor$0;
   function invariant(t){
    function _aA_(param){
     function _aC_(_aP_){return 0;}
     function _aD_(_aO_){return 0;}
     function _aE_(_aN_){return 0;}
     function _aF_(_aM_){return 0;}
     function f(next_error){
      if(caml_call1(Async_kernel_Ivar[17], next_error)) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     }
     var _aB_ = caml_call2(Base_Invariant[2], t, f);
     function _aG_(_aL_){return 0;}
     function _aH_(_aK_){return 0;}
     function _aI_(_aJ_){return 0;}
     return caml_call8
             (Fields[9], _aI_, _aH_, _aG_, _aB_, _aF_, _aE_, _aD_, _aC_);
    }
    return caml_call4(Base_Invariant[1], _b_, t, sexp_of_t, _aA_);
   }
   function current_execution_context(param){
    var _az_ = caml_call1(Async_kernel_Scheduler1[72], 0);
    return caml_call1(Async_kernel_Scheduler1[73], _az_);
   }
   function current(param){
    var _ay_ = current_execution_context(0);
    return caml_call1(Async_kernel_Execution_context[4], _ay_);
   }
   function detach(t){t[8] = 0; return 0;}
   function detach_and_iter_errors(t, f){
    detach(t);
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], scheduler),
     handler_state_ref = [0, 0];
    function run_f(exn){
     var match = handler_state_ref[1];
     if(typeof match === "number"){
      if(match) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     }
     var bag_elt = match[1];
     try{var _ax_ = caml_call1(f, exn); return _ax_;}
     catch(inner_exn$0){
      var inner_exn = caml_wrap_exception(inner_exn$0);
      handler_state_ref[1] = 1;
      caml_call2(Core_Bag[26], t[5], bag_elt);
      throw caml_maybe_attach_backtrace(inner_exn, 0);
     }
    }
    handler_state_ref[1] =
     [0, caml_call2(Core_Bag[23], t[5], [0, execution_context, run_f])];
    return 0;
   }
   function detach_and_get_error_stream(t){
    detach(t);
    var tail = caml_call1(Async_kernel_Tail[2], 0);
    t[6] = [0, tail, t[6]];
    return caml_call1(Async_kernel_Tail[8], tail);
   }
   function get_next_error(t){return caml_call1(Async_kernel_Ivar[19], t[4]);}
   function detach_and_get_next_error(t){detach(t); return get_next_error(t);}
   function create(here, info, name, param){
    var parent = current(0);
    return caml_call4(create_with_parent, here, info, name, [0, parent]);
   }
   function backtrace(t){return t[2];}
   function extract_exn(t){return t[1];}
   var
    Monitor_exn =
      [248, cst_Async_kernel_Monitor_Monit, runtime.caml_fresh_oo_id(0)];
   function _j_(param){
    if(param[1] !== Monitor_exn)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    var
     t = param[2],
     monitor$0 = t[4],
     backtrace_history = t[3],
     backtrace = t[2],
     exn = t[1],
     s = caml_call1(Core_Info[12], monitor$0[1]),
     name = runtime.caml_string_notequal(s, cst$0) ? [0, s] : 0,
     match = monitor$0[2];
    if(match)
     var
      here = match[1],
      column = here[4] - here[3] | 0,
      _ap_ =
        Core[628]
         ? caml_call2(Core[265], _d_, here[1])
         : caml_call5(Core[265], _i_, here[1], here[2], column, column),
      pos = [0, _ap_];
    else
     var pos = 0;
    if(pos){
     var pos$0 = pos[1];
     if(name)
      var
       name$0 = name[1],
       _aq_ = [0, caml_call3(Core[265], _e_, name$0, pos$0), 0];
     else
      var _aq_ = [0, caml_call2(Core[265], _g_, pos$0), 0];
     var monitor$1 = _aq_;
    }
    else if(name)
     var
      name$1 = name[1],
      monitor$1 = [0, caml_call2(Core[265], _h_, name$1), 0];
    else
     var monitor$1 = 0;
    if(backtrace)
     var
      backtrace$0 = backtrace[1],
      backtrace$1 = caml_call1(Base_Backtrace[4], backtrace$0);
    else
     var backtrace$1 = 0;
    function strip_prefixes(lines, prefixes){
     function _av_(line){
      function _aw_(prefix){return caml_call2(Core_String[73], line, prefix);}
      return caml_call2(Core_List[23], prefixes, _aw_);
     }
     return caml_call2(Core_List[137], lines, _av_);
    }
    var
     suffixes =
       [0,
        job_queue,
        [0, deferred0, [0, deferred1, [0, monitor, [0, try_with, 0]]]]],
     input = strip_prefixes(backtrace$1, [0, error, 0]),
     rev_input = caml_call1(Core_List[59], input),
     rev_output = strip_prefixes(rev_input, suffixes),
     _ar_ =
       rev_input === rev_output
        ? input
        : caml_call1(Core_List[59], rev_output),
     backtrace$2 = caml_call2(Core[156], _ar_, monitor$1);
    function list_if_not_empty(l){return l ? [0, l] : 0;}
    var
     match$0 = list_if_not_empty(backtrace$2),
     _as_ = list_if_not_empty(backtrace_history),
     match$1 = 0;
    if(_as_)
     var
      x_002 = _as_[1],
      match$2 =
        [0,
         [1,
          [0, _f_, [0, caml_call2(Core[472], Base_Backtrace[1], x_002), 0]]],
         match$1];
    else
     var match$2 = match$1;
    if(match$0)
     var
      x_001 = match$0[1],
      _at_ = [0, caml_call2(Core[472], Core[558], x_001), match$2];
    else
     var _at_ = match$2;
    var sexp = [1, [0, caml_call1(Core[625], exn), _at_]];
    if(0 === sexp[0]) var _au_ = [0, sexp, 0]; else var l = sexp[1], _au_ = l;
    return [1,
            [0, caml_call1(Sexplib0_Sexp_conv[7], cst_monitor_ml_Error), _au_]];
   }
   caml_call4(Sexplib_Conv[72][1], 0, 0, Monitor_exn, _j_);
   function extract_exn$0(exn){
    if(exn[1] !== Monitor_exn) return exn;
    var error = exn[2];
    return error[1];
   }
   function send_exn(t, opt, exn){
    if(opt) var sth = opt[1], backtrace = sth; else var backtrace = 3553398;
    if(exn[1] === Monitor_exn)
     var exn$0 = exn;
    else{
     if(typeof backtrace === "number")
      var backtrace$0 = caml_call1(Base_Backtrace[6][5], exn);
     else
      var b = backtrace[2], backtrace$0 = [0, b];
     var
      backtrace_history = current_execution_context(0)[4],
      exn$0 = [0, Monitor_exn, [0, exn, backtrace$0, backtrace_history, t]];
    }
    if(Async_kernel_Debug[7]){
     var
      _aj_ =
        function(param){
         var
          arg1_004 = param[2],
          arg0_003 = param[1],
          res0_005 = caml_call1(sexp_of_t, arg0_003),
          res1_006 = caml_call1(Core[625], arg1_004);
         return [1, [0, res0_005, [0, res1_006, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15], cst_Monitor_send_exn, [0, t, exn$0], _aj_);
    }
    var scheduler = caml_call1(Async_kernel_Scheduler1[72], 0), t$0 = t;
    for(;;){
     t$0[7] = 1;
     caml_call2(Async_kernel_Ivar[14], t$0[4], exn$0);
     t$0[4] = caml_call1(Async_kernel_Ivar[12], 0);
     var match = t$0[8];
     if(typeof match === "number") break;
     var parent = match[1], t$0 = parent;
    }
    if(match){
     var
      _ak_ = caml_call1(Async_kernel_config[35][1], 0),
      _al_ = caml_call1(Async_kernel_Scheduler1[72], 0);
     return caml_call2
             (caml_call1(Async_kernel_Scheduler1[77], _al_), exn$0, _ak_);
    }
    if(Async_kernel_Debug[7]){
     var
      _am_ =
        function(param){
         var
          arg1_008 = param[2],
          arg0_007 = param[1],
          res0_009 = caml_call1(sexp_of_t, arg0_007),
          res1_010 = caml_call1(Core[625], arg1_008);
         return [1, [0, res0_009, [0, res1_010, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_Monitor_send_exn_found_lis,
       [0, t$0, exn$0],
       _am_);
    }
    function _an_(param){
     var f = param[2], execution_context = param[1];
     return caml_call4
             (Async_kernel_Scheduler1[63],
              scheduler,
              execution_context,
              f,
              exn$0);
    }
    caml_call2(Core_Bag[7], t$0[5], _an_);
    function _ao_(tail){return caml_call2(Async_kernel_Tail[3], tail, exn$0);}
    return caml_call2(Core_List[19], t$0[6], _ao_);
   }
   function within_context(context, f){
    function _ah_(param){
     var match = caml_call1(Core_Result[54], f);
     if(0 === match[0]){var x = match[1]; return [0, x];}
     var exn = match[1];
     send_exn
      (caml_call1(Async_kernel_Execution_context[4], context), _l_, exn);
     return _m_;
    }
    var _ai_ = caml_call1(Async_kernel_Scheduler1[72], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler1[75], _ai_), context, _ah_);
   }
   function within_gen(monitor, priority, f){
    var
     _ag_ = current_execution_context(0),
     tmp_context =
       caml_call4
        (Async_kernel_Execution_context[8], monitor, priority, 0, _ag_);
    return within_context(tmp_context, f);
   }
   function within(monitor, priority, f){
    var match = within_gen(monitor, priority, f);
    if(0 !== match[0]) return caml_call1(Async_kernel_Deferred1[12], 0);
    var d = match[1];
    return d;
   }
   function within_v(monitor, priority, f){
    var match = within_gen(monitor, priority, f);
    if(0 !== match[0]) return 0;
    var x = match[1];
    return [0, x];
   }
   function within$0(monitor, priority, f){
    return 0 === within_gen(monitor, priority, f)[0] ? 0 : 0;
   }
   function schedule_with_data(monitor, priority, work, x){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[72], 0),
     _ae_ = caml_call1(Async_kernel_Scheduler1[73], scheduler),
     _af_ =
       caml_call4
        (Async_kernel_Execution_context[8], monitor, priority, 0, _ae_);
    return caml_call4(Async_kernel_Scheduler1[63], scheduler, _af_, work, x);
   }
   function schedule(monitor, priority, work){
    return schedule_with_data(monitor, priority, work, 0);
   }
   function upon_work_fill_i(param){
    var i = param[2], work = param[1];
    function _ac_(a){return caml_call2(Async_kernel_Ivar[14], i, a);}
    var _ad_ = caml_call1(work, 0);
    return caml_call2(Async_kernel_Deferred_std[11], _ad_, _ac_);
   }
   function schedule$0(monitor, priority, work){
    var i = caml_call1(Async_kernel_Ivar[12], 0);
    schedule_with_data(monitor, priority, upon_work_fill_i, [0, work, i]);
    return caml_call1(Async_kernel_Ivar[19], i);
   }
   function preserve_execution_context(f){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], scheduler);
    function _ab_(a){
     return caml_call4
             (Async_kernel_Scheduler1[63], scheduler, execution_context, f, a);
    }
    return caml_call1(Core[266], _ab_);
   }
   function preserve_execution_context$0(f){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[72], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[73], scheduler);
    function call_and_fill(param){
     var i = param[3], a = param[2], f = param[1];
     function _$_(r){return caml_call2(Async_kernel_Ivar[14], i, r);}
     var _aa_ = caml_call1(f, a);
     return caml_call2(Async_kernel_Deferred_std[11], _aa_, _$_);
    }
    function _Z_(a){
     function ___(i){
      return caml_call4
              (Async_kernel_Scheduler1[63],
               scheduler,
               execution_context,
               call_and_fill,
               [0, f, a, i]);
     }
     return caml_call1(Async_kernel_Deferred1[4], ___);
    }
    return caml_call1(Core[266], _Z_);
   }
   function stream_iter(stream, f){
    function loop(stream){
     function _X_(param){
      if(! param) return 0;
      var stream = param[2], v = param[1];
      loop(stream);
      return caml_call1(f, v);
     }
     var _Y_ = caml_call1(Async_kernel_Tail[7][2], stream);
     return caml_call2(Async_kernel_Deferred_std[1], _Y_, _X_);
    }
    return loop(stream);
   }
   function create$0(here, info, name, run, f){
    var
     monitor = caml_call4(create_with_parent, here, info, name, 0),
     exns = detach_and_get_error_stream(monitor),
     ok =
       523273847 <= run
        ? schedule$0([0, monitor], 0, f)
        : within([0, monitor], 0, f);
    return [0, ok, exns];
   }
   function fill_result_and_handle_backgro
   (result_filler, result, exns, handle_exns_after_result){
    var _W_ = caml_call1(Async_kernel_Ivar_filler[4], result_filler);
    return _W_
            ? (caml_call2
               (Async_kernel_Ivar_filler[5], result_filler, result),
              caml_call1(handle_exns_after_result, exns))
            : _W_;
   }
   var
    try_with_log_exn =
      [0,
       function(exn){
        var
         _U_ = [0, [1, [0, _n_, [0, caml_call1(Base_Exn[1], exn), 0]]], 0],
         _V_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_failed_to_set_Monitor_Expe),
             _U_]];
        return caml_call1(Core[261], _V_);
       }],
    Expert = [0, try_with_log_exn];
   function try_with$0(here, info, opt, _P_, _O_, _N_, f$0){
    if(opt) var sth = opt[1], name = sth; else var name = cst;
    if(_P_)
     var sth$0 = _P_[1], do_extract_exn = sth$0;
    else
     var do_extract_exn = 0;
    if(_O_) var sth$1 = _O_[1], run = sth$1; else var run = 3903734;
    if(_N_) var sth$2 = _N_[1], rest = sth$2; else var rest = -146189108;
    var
     match = create$0(here, info, [0, name], run, f$0),
     exns = match[2],
     ok = match[1];
    if(typeof rest === "number")
     if(3804260 <= rest)
      var handle_exn = Expert[1][1];
     else
      var
       parent = current(0),
       handle_exn = function(exn){return send_exn(parent, _o_, exn);};
    else
     var
      f = rest[2],
      parent$0 = current(0),
      handle_exn =
        function(exn){
         return within$0
                 ([0, parent$0],
                  0,
                  function(param){return caml_call1(f, exn);});
        };
    function handle_exns_after_result(exns){return stream_iter(exns, handle_exn);
    }
    return within
            ([0, main],
             0,
             function(param){
              if(caml_call1(Async_kernel_Deferred1[7], ok)){
               handle_exns_after_result(exns);
               var _Q_ = [0, caml_call1(Async_kernel_Deferred1[6], ok)];
               return caml_call1(Async_kernel_Deferred_std[10], _Q_);
              }
              var
               match = caml_call1(Async_kernel_Ivar_filler[3], 0),
               result = match[2],
               result_filler = match[1];
              function _R_(res){
               return fill_result_and_handle_backgro
                       (result_filler, [0, res], exns, handle_exns_after_result);
              }
              caml_call2(Async_kernel_Deferred_std[11], ok, _R_);
              function _S_(param){
               if(! param)
                throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
               var
                exns = param[2],
                exn = param[1],
                exn$0 = do_extract_exn ? extract_exn$0(exn) : exn;
               return fill_result_and_handle_backgro
                       (result_filler, [1, exn$0], exns, handle_exns_after_result);
              }
              var _T_ = caml_call1(Async_kernel_Tail[7][2], exns);
              caml_call2(Async_kernel_Deferred_std[11], _T_, _S_);
              return result;
             });
   }
   function try_with_or_error(here, info, opt, extract_exn, rest, f){
    if(opt)
     var sth = opt[1], name = sth;
    else
     var name = cst_try_with_or_error;
    var arg = Core_Or_error[42];
    function _L_(eta){return caml_call2(arg, 0, eta);}
    var _M_ = try_with$0(here, info, [0, name], extract_exn, _q_, rest, f);
    return caml_call2(Async_kernel_Deferred_std[4], _M_, _L_);
   }
   function try_with_join_or_error(here, info, opt, extract_exn, rest, f){
    if(opt)
     var sth = opt[1], name = sth;
    else
     var name = cst_try_with_join_or_error;
    var
     _J_ = Core_Or_error[31],
     _K_ = try_with_or_error(here, info, [0, name], extract_exn, rest, f);
    return caml_call2(Async_kernel_Deferred_std[4], _K_, _J_);
   }
   function protect(here, info, opt, extract_exn, run, rest, f, finally$0){
    if(opt) var sth = opt[1], name = sth; else var name = cst_Monitor_protect;
    function _C_(r){
     function _E_(fr){
      if(0 === r[0]){
       var r$0 = r[1];
       if(0 === fr[0]) return r$0;
       var e = fr[1];
      }
      else{
       var exn = r[1];
       if(0 !== fr[0]){
        var
         finally_exn = fr[1],
         _G_ =
           [0, [1, [0, _r_, [0, caml_call1(Core[625], finally_exn), 0]]], 0],
         _H_ = [0, [1, [0, _s_, [0, caml_call1(Core[625], exn), 0]]], _G_],
         _I_ =
           [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Async_finally), _H_]];
        return caml_call1(Core[261], _I_);
       }
       var e = exn;
      }
      throw caml_maybe_attach_backtrace(e, 0);
     }
     var _F_ = try_with$0(here, info, _v_, _u_, _t_, rest, finally$0);
     return caml_call2(Async_kernel_Deferred_std[5][2], _F_, _E_);
    }
    var _D_ = try_with$0(here, info, [0, name], extract_exn, run, rest, f);
    return caml_call2(Async_kernel_Deferred_std[5][1], _D_, _C_);
   }
   function handle_errors(here, info, name, f, handler){
    var
     match = create$0(here, info, name, 3903734, f),
     exns = match[2],
     ok = match[1];
    stream_iter(exns, handler);
    return ok;
   }
   function catch_stream(here, info, name, f){
    var
     exns =
       create$0
         (here,
          info,
          name,
          3903734,
          function(param){
           caml_call1(f, 0);
           return caml_call1(Async_kernel_Deferred_std[10], 0);
          })
        [2];
    return exns;
   }
   function catch$0(here, info, name, f){
    function _y_(param){
     if(param){var x = param[1]; return x;}
     var
      _B_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Monitor_catch_got_unexpect);
     return caml_call1(Core[261], _B_);
    }
    var
     _z_ = catch_stream(here, info, name, f),
     _A_ = caml_call1(Async_kernel_Tail[7][2], _z_);
    return caml_call2(Async_kernel_Deferred_std[5][2], _A_, _y_);
   }
   function catch_error(here, info, name, f){
    var arg = Core_Error[27];
    function _w_(eta){return caml_call2(arg, 0, eta);}
    var _x_ = catch$0(here, info, name, f);
    return caml_call2(Async_kernel_Deferred_std[4], _x_, _w_);
   }
   function parent(t){
    var match = t[8];
    if(typeof match === "number") return match ? 0 : 0;
    var parent = match[1];
    return [0, parent];
   }
   function depth(t){
    var t$0 = t, n = 0;
    for(;;){
     var match = parent(t$0);
     if(! match) return n;
     var t$1 = match[1], n$0 = n + 1 | 0, t$0 = t$1, n = n$0;
    }
   }
   var For_tests = [0, parent, depth];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monitor);
   var
    Async_kernel_Monitor =
      [0,
       sexp_of_t,
       invariant,
       create,
       name,
       current,
       detach,
       detach_and_iter_errors,
       detach_and_get_next_error,
       detach_and_get_error_stream,
       get_next_error,
       [0, extract_exn, backtrace],
       Monitor_exn,
       extract_exn$0,
       has_seen_error,
       send_exn,
       try_with$0,
       try_with_or_error,
       try_with_join_or_error,
       handle_errors,
       catch_stream,
       catch$0,
       catch_error,
       protect,
       main,
       Expert,
       [0,
        within,
        within$0,
        within_v,
        schedule$0,
        schedule,
        within_context,
        preserve_execution_context,
        preserve_execution_context$0],
       For_tests];
   runtime.caml_register_global
    (76, Async_kernel_Monitor, cst_Async_kernel_Monitor$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_stream
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Tail, Core, Core__List, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_stream$0 = "Async_kernel__Async_stream",
    cst_async_kernel$0 = "async_kernel",
    cst_src_async_stream_ml = "src/async_stream.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_stream$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_async_stream_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "async_stream.ml");
   var
    include = Async_kernel_Tail[7],
    sexp_of_t = include[1],
    next = include[2],
    _b_ = [0, -146189108],
    _c_ = [0, 523273847],
    _a_ = [0, cst_src_async_stream_ml, 177, 18],
    cst_Stream_first_of_empty_stre = "Stream.first of empty stream",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_stream = cst_Async_kernel_Async_stream$0;
   function first_exn(t){
    function _aD_(param){
     if(param){var x = param[1]; return x;}
     var
      _aF_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Stream_first_of_empty_stre);
     return caml_call1(Core[261], _aF_);
    }
    var _aE_ = caml_call1(next, t);
    return caml_call2(Async_kernel_Deferred_std[5][2], _aE_, _aD_);
   }
   function fold(t, init, f){
    function _ax_(result){
     function loop(t, b){
      function _ay_(param){
       if(! param) return caml_call2(Async_kernel_Ivar[14], result, b);
       var t = param[2], v = param[1];
       function _aA_(_aC_){return loop(t, _aC_);}
       var _aB_ = caml_call2(f, b, v);
       return caml_call2(Async_kernel_Deferred_std[11], _aB_, _aA_);
      }
      var _az_ = caml_call1(next, t);
      return caml_call2(Async_kernel_Deferred_std[11], _az_, _ay_);
     }
     return loop(t, init);
    }
    return caml_call1(Async_kernel_Deferred1[4], _ax_);
   }
   function fold$0(t, init, f){
    function _as_(result){
     function loop$0(counter, t, b){
      var
       _au_ = caml_call1(next, t),
       match = caml_call1(Async_kernel_Deferred1[5], _au_);
      if(! match){
       var
        _av_ = function(next){return loop_next(next, b);},
        _aw_ = caml_call1(next, t);
       return caml_call2(Async_kernel_Deferred_std[11], _aw_, _av_);
      }
      var next$0 = match[1];
      if(counter >= 50)
       return caml_trampoline_return(loop_next$0, [0, next$0, b]);
      var counter$0 = counter + 1 | 0;
      return loop_next$0(counter$0, next$0, b);
     }
     function loop_next$0(counter, next, b){
      if(! next) return caml_call2(Async_kernel_Ivar[14], result, b);
      var t = next[2], v = next[1], _at_ = caml_call2(f, b, v);
      if(counter >= 50) return caml_trampoline_return(loop$0, [0, t, _at_]);
      var counter$0 = counter + 1 | 0;
      return loop$0(counter$0, t, _at_);
     }
     function loop(t, b){return caml_trampoline(loop$0(0, t, b));}
     function loop_next(next, b){
      return caml_trampoline(loop_next$0(0, next, b));
     }
     return loop(t, init);
    }
    return caml_call1(Async_kernel_Deferred1[4], _as_);
   }
   function length(t){
    return fold$0(t, 0, function(n, param){return n + 1 | 0;});
   }
   function iter(t, f){
    return fold(t, 0, function(param, v){return caml_call1(f, v);});
   }
   function closed(t){
    var
     _ar_ = caml_call1(next, t),
     match = caml_call1(Async_kernel_Deferred1[5], _ar_);
    if(match && ! match[1])
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    return iter
            (t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function iter$0(t, f){
    var
     _aq_ =
       iter
        (t,
         function(a){
          caml_call1(f, a);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    return caml_call1(Async_kernel_Deferred_std[8], _aq_);
   }
   function create(f){
    var
     tail = caml_call1(Async_kernel_Tail[2], 0),
     t = caml_call1(Async_kernel_Tail[8], tail);
    caml_call1(f, tail);
    return t;
   }
   function unfold(b, f){
    return create
            (function(tail){
              function loop(b){
               function _ao_(param){
                if(! param) return caml_call1(Async_kernel_Tail[4], tail);
                var match = param[1], b = match[2], a = match[1];
                caml_call2(Async_kernel_Tail[3], tail, a);
                return loop(b);
               }
               var _ap_ = caml_call1(f, b);
               return caml_call2(Async_kernel_Deferred_std[11], _ap_, _ao_);
              }
              return loop(b);
             });
   }
   function of_list(l){
    return create
            (function(tail){
              function _an_(x){
               return caml_call2(Async_kernel_Tail[3], tail, x);
              }
              caml_call2(Core_List[19], l, _an_);
              return caml_call1(Async_kernel_Tail[4], tail);
             });
   }
   function to_list(s){
    var
     _al_ = Core_List[59],
     _am_ =
       fold
        (s,
         0,
         function(b, a){
          return caml_call1(Async_kernel_Deferred_std[10], [0, a, b]);
         });
    return caml_call2(Async_kernel_Deferred_std[4], _am_, _al_);
   }
   function copy_to_tail(t, tail){
    return iter
            (t,
             function(a){
              var _ak_ = caml_call2(Async_kernel_Tail[3], tail, a);
              return caml_call1(Async_kernel_Deferred_std[10], _ak_);
             });
   }
   function append(t1, t2){
    return create
            (function(tail){
              function _ag_(param){
               function _ai_(param){
                return caml_call1(Async_kernel_Tail[4], tail);
               }
               var _aj_ = copy_to_tail(t2, tail);
               return caml_call2(Async_kernel_Deferred_std[11], _aj_, _ai_);
              }
              var _ah_ = copy_to_tail(t1, tail);
              return caml_call2(Async_kernel_Deferred_std[11], _ah_, _ag_);
             });
   }
   function concat(t){
    return create
            (function(tail){
              function _ae_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var _af_ = iter(t, function(t){return copy_to_tail(t, tail);});
              return caml_call2(Async_kernel_Deferred_std[11], _af_, _ae_);
             });
   }
   function filter_deprecated(t, f){
    return create
            (function(tail){
              function _$_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var
               _aa_ =
                 iter
                  (t,
                   function(v){
                    function _ab_(param){
                     return param ? caml_call2(Async_kernel_Tail[3], tail, v) : 0;
                    }
                    var
                     _ac_ = caml_call1(f, v),
                     _ad_ = caml_call1(Async_kernel_Deferred_std[10], _ac_);
                    return caml_call2
                            (Async_kernel_Deferred_std[5][2], _ad_, _ab_);
                   });
              return caml_call2(Async_kernel_Deferred_std[11], _aa_, _$_);
             });
   }
   function filter_map_deprecated(t, f){
    return create
            (function(tail){
              function _W_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var
               _X_ =
                 iter
                  (t,
                   function(v){
                    function _Y_(param){
                     if(! param) return 0;
                     var v = param[1];
                     return caml_call2(Async_kernel_Tail[3], tail, v);
                    }
                    var
                     _Z_ = caml_call1(f, v),
                     ___ = caml_call1(Async_kernel_Deferred_std[10], _Z_);
                    return caml_call2(Async_kernel_Deferred_std[5][2], ___, _Y_);
                   });
              return caml_call2(Async_kernel_Deferred_std[11], _X_, _W_);
             });
   }
   function map(t, f){
    return create
            (function(tail){
              function _S_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var
               _T_ =
                 iter
                  (t,
                   function(v){
                    var
                     _U_ = caml_call1(Async_kernel_Tail[3], tail),
                     _V_ = caml_call1(f, v);
                    return caml_call2(Async_kernel_Deferred_std[4], _V_, _U_);
                   });
              return caml_call2(Async_kernel_Deferred_std[11], _T_, _S_);
             });
   }
   function map$0(t, f){
    return map
            (t,
             function(a){
              var _R_ = caml_call1(f, a);
              return caml_call1(Async_kernel_Deferred_std[10], _R_);
             });
   }
   function first_n(s, n){
    return create
            (function(tail){
              function loop(s, n){
               if(caml_call2(Core[90], n, 0))
                return caml_call1(Async_kernel_Tail[4], tail);
               function _P_(param){
                if(! param) return caml_call1(Async_kernel_Tail[4], tail);
                var t = param[2], x = param[1];
                caml_call2(Async_kernel_Tail[3], tail, x);
                return loop(t, n - 1 | 0);
               }
               var _Q_ = caml_call1(next, s);
               return caml_call2(Async_kernel_Deferred_std[11], _Q_, _P_);
              }
              return loop(s, n);
             });
   }
   function available_now(t){
    var t$0 = t, ac = 0;
    for(;;){
     var
      _O_ = caml_call1(next, t$0),
      match = caml_call1(Async_kernel_Deferred1[5], _O_);
     if(match){
      var match$0 = match[1];
      if(match$0){
       var
        t$1 = match$0[2],
        x = match$0[1],
        ac$0 = [0, x, ac],
        t$0 = t$1,
        ac = ac$0;
       continue;
      }
     }
     return [0, caml_call1(Core_List[59], ac), t$0];
    }
   }
   function split(opt, _E_, t){
    if(opt)
     var sth = opt[1], stop = sth;
    else
     var stop = caml_call1(Async_kernel_Deferred1[12], 0);
    if(_E_)
     var sth$0 = _E_[1], f = sth$0;
    else
     var f = function(param){return 192584839;};
    var
     reason_for_stopping = caml_call1(Async_kernel_Ivar[12], 0),
     prefix = caml_call1(Async_kernel_Tail[2], 0);
    function finish(v){
     caml_call1(Async_kernel_Tail[4], prefix);
     return caml_call2(Async_kernel_Ivar[14], reason_for_stopping, v);
    }
    function loop(t){
     function _G_(param){
      if(typeof param === "number") return finish([0, 280164845, t]);
      var o = param[2];
      if(! o) return finish(1144100);
      var t$0 = o[2], a = o[1], match = caml_call1(f, a);
      if(typeof match === "number"){
       caml_call2(Async_kernel_Tail[3], prefix, a);
       return loop(t$0);
      }
      var b = match[2];
      return finish([0, 398750242, [0, b, t$0]]);
     }
     var _H_ = 0;
     function _I_(o){return [0, 870035731, o];}
     var
      _J_ = caml_call1(next, t),
      _K_ = [0, caml_call2(Async_kernel_Deferred_std[6], _J_, _I_), _H_];
     function _L_(param){return 280164845;}
     var
      _M_ = [0, caml_call2(Async_kernel_Deferred_std[6], stop, _L_), _K_],
      _N_ = caml_call1(Async_kernel_Deferred_std[7], _M_);
     return caml_call2(Async_kernel_Deferred_std[1], _N_, _G_);
    }
    loop(t);
    var _F_ = caml_call1(Async_kernel_Ivar[19], reason_for_stopping);
    return [0, caml_call1(Async_kernel_Tail[8], prefix), _F_];
   }
   function find(t, f){
    var
     found =
       split
         (0,
          [0,
           function(a){
            return caml_call1(f, a) ? [0, 398750242, a] : 192584839;
           }],
          t)
        [2];
    function _D_(x){
     if(typeof x !== "number" && 398750242 > x[1])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     return x;
    }
    return caml_call2(Async_kernel_Deferred_std[5][2], found, _D_);
   }
   function ungroup(t){
    return create
            (function(tail){
              function _A_(param){
               return caml_call1(Async_kernel_Tail[4], tail);
              }
              var
               _B_ =
                 iter
                  (t,
                   function(l){
                    function _C_(x){
                     return caml_call2(Async_kernel_Tail[3], tail, x);
                    }
                    caml_call2(Core_List[19], l, _C_);
                    return caml_call1(Async_kernel_Deferred_std[10], 0);
                   });
              return caml_call2(Async_kernel_Deferred_std[11], _B_, _A_);
             });
   }
   function interleave(ts){
    return create
            (function(tail){
              var num_open = [0, 1];
              function close(param){
               num_open[1] = num_open[1] - 1 | 0;
               var _z_ = caml_call2(Core[90], num_open[1], 0);
               return _z_ ? caml_call1(Async_kernel_Tail[4], tail) : _z_;
              }
              var
               outer_closed =
                 iter
                  (ts,
                   function(t){
                    num_open[1] = num_open[1] + 1 | 0;
                    var _y_ = copy_to_tail(t, tail);
                    caml_call2(Async_kernel_Deferred_std[11], _y_, close);
                    return caml_call1(Async_kernel_Deferred_std[10], 0);
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[11], outer_closed, close);
             });
   }
   function take_until(t, d){
    return create
            (function(tail){
              function loop(t){
               function _q_(param){
                if(typeof param !== "number"){
                 var match = param[2];
                 if(match){
                  var t = match[2], x = match[1];
                  caml_call2(Async_kernel_Tail[3], tail, x);
                  return loop(t);
                 }
                }
                return caml_call1(Async_kernel_Tail[4], tail);
               }
               var _r_ = 0;
               function _s_(z){return [0, 870035731, z];}
               var
                _t_ = caml_call1(next, t),
                _u_ =
                  [0, caml_call2(Async_kernel_Deferred_std[6], _t_, _s_), _r_];
               function _v_(param){return 926227490;}
               var
                _w_ =
                  [0, caml_call2(Async_kernel_Deferred_std[6], d, _v_), _u_],
                _x_ = caml_call1(Async_kernel_Deferred_std[7], _w_);
               return caml_call2(Async_kernel_Deferred_std[11], _x_, _q_);
              }
              return loop(t);
             });
   }
   function iter_durably(t, f){
    function _j_(result){
     function loop(t){
      function _k_(param){
       if(! param) return caml_call2(Async_kernel_Ivar[14], result, 0);
       var t = param[2], x = param[1];
       function _m_(z){
        loop(t);
        if(0 === z[0]) return 0;
        var e = z[1], _p_ = caml_call1(Async_kernel_Monitor[5], 0);
        return caml_call3(Async_kernel_Monitor[15], _p_, 0, e);
       }
       function _n_(param){return caml_call1(f, x);}
       var
        _o_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _c_, _b_, _n_);
       return caml_call2(Async_kernel_Deferred_std[1], _o_, _m_);
      }
      var _l_ = caml_call1(next, t);
      return caml_call2(Async_kernel_Deferred_std[1], _l_, _k_);
     }
     return loop(t);
    }
    return caml_call1(Async_kernel_Deferred1[4], _j_);
   }
   function iter_durably_report_end(t, f){
    function _g_(result){
     function loop(t){
      function _h_(param){
       if(! param) return caml_call2(Async_kernel_Ivar[14], result, 0);
       var t = param[2], x = param[1];
       loop(t);
       return caml_call1(f, x);
      }
      var _i_ = caml_call1(next, t);
      return caml_call2(Async_kernel_Deferred_std[1], _i_, _h_);
     }
     return loop(t);
    }
    return caml_call1(Async_kernel_Deferred1[4], _g_);
   }
   function iter_durably$0(t, f){
    var _f_ = iter_durably_report_end(t, f);
    return caml_call1(Async_kernel_Deferred_std[8], _f_);
   }
   function of_fun(f){
    return unfold
            (0,
             function(param){
              function _d_(a){return [0, [0, a, 0]];}
              var _e_ = caml_call1(f, 0);
              return caml_call2(Async_kernel_Deferred_std[5][2], _e_, _d_);
             });
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_stream);
   var
    Async_kernel_Async_stream =
      [0,
       sexp_of_t,
       create,
       next,
       first_exn,
       of_list,
       to_list,
       of_fun,
       copy_to_tail,
       append,
       concat,
       available_now,
       filter_deprecated,
       filter_map_deprecated,
       fold,
       fold$0,
       iter,
       closed,
       iter$0,
       take_until,
       iter_durably,
       iter_durably$0,
       iter_durably_report_end,
       length,
       map,
       map$0,
       first_n,
       unfold,
       split,
       find,
       ungroup,
       interleave];
   runtime.caml_register_global
    (24, Async_kernel_Async_stream, cst_Async_kernel_Async_stream$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_source_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Time_source_i = "Async_kernel__Time_source_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_source_i);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/time_source_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel, "time_source_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_source_i);
   var Async_kernel_Time_source_intf = [0];
   runtime.caml_register_global
    (11, Async_kernel_Time_source_intf, cst_Async_kernel_Time_source_i);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Bvar
//# unitInfo: Requires: Async_kernel__Ivar, Async_kernel__Scheduler1, Async_kernel__Types, Base__Invariant, Core, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Bvar$0 = "Async_kernel__Bvar",
    cst_async_kernel$0 = "async_kernel",
    cst_has_any_waiters$0 = "has_any_waiters",
    cst_ivar$0 = "ivar",
    cst_src_bvar_ml = "src/bvar.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Types = global_data.Async_kernel__Types,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Bvar$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_bvar_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "bvar.ml");
   var
    _k_ = [0, cst_has_any_waiters$0],
    _i_ = [0, "_"],
    _h_ = [0, cst_src_bvar_ml, 19, 47],
    _g_ = [0, cst_src_bvar_ml, 23, 11],
    _j_ = [0, cst_src_bvar_ml, 14, 303, 325],
    _e_ = [0, cst_ivar$0],
    _f_ = [0, cst_has_any_waiters$0],
    cst_ivar = cst_ivar$0,
    cst_has_any_waiters = cst_has_any_waiters$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Bvar = cst_Async_kernel_Bvar$0;
   function ivar(r){return r[2];}
   function set_ivar(r, v){r[2] = v; return 0;}
   function has_any_waiters(r){return r[1];}
   function set_has_any_waiters(r, v){r[1] = v; return 0;}
   function _a_(r, v){return [0, r[1], v];}
   var
    _b_ = [0, set_ivar],
    ivar$0 = [0, function(param){return 0;}, cst_ivar, _b_, ivar, _a_];
   function _c_(r, v){return [0, v, r[2]];}
   var
    _d_ = [0, set_has_any_waiters],
    has_any_waiters$0 =
      [0,
       function(param){return 0;},
       cst_has_any_waiters,
       _d_,
       has_any_waiters,
       _c_];
   function invariant(invariant_a, param, t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    function _o_(param){
     function check(f){return caml_call2(Base_Invariant[2], repr, f);}
     var
      ivar_fun =
        check
         (function(ivar){
           caml_call2(Async_kernel_Ivar[10], invariant_a, ivar);
           if(caml_call1(Async_kernel_Ivar[17], ivar)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
          }),
      has_any_waiters_fun =
        check
         (function(has_any_waiters){
           var _q_ = caml_call1(Async_kernel_Ivar[22], repr[2]);
           if(! _q_) return _q_;
           if(has_any_waiters) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
          });
     caml_call1(has_any_waiters_fun, has_any_waiters$0);
     return caml_call1(ivar_fun, ivar$0);
    }
    function _p_(x_007){
     function of_a_001(param){return _i_;}
     var
      has_any_waiters_003 = x_007[1],
      ivar_005 = x_007[2],
      arg_006 = caml_call2(Async_kernel_Ivar[9], of_a_001, ivar_005),
      bnds_002 = [0, [1, [0, _e_, [0, arg_006, 0]]], 0],
      arg_004 = caml_call1(Core[323], has_any_waiters_003),
      bnds_002$0 = [0, [1, [0, _f_, [0, arg_004, 0]]], bnds_002];
     return [1, bnds_002$0];
    }
    return caml_call4(Base_Invariant[1], _j_, repr, _p_, _o_);
   }
   function sexp_of_t(param, _n_, t){
    var has_any_waiters = caml_call1(Async_kernel_Types[10][2], t)[1];
    return [1, [0, _k_, [0, caml_call1(Core[323], has_any_waiters), 0]]];
   }
   var include = Async_kernel_Scheduler1[5], create = include[1];
   function broadcast(t, a){
    var
     repr = caml_call1(Async_kernel_Types[10][2], t),
     _l_ = repr[1],
     _m_ =
       _l_
        ? (repr
           [1]
          = 0,
          caml_call2(Async_kernel_Ivar[14], repr[2], a),
          repr[2] = caml_call1(Async_kernel_Ivar[12], 0),
          0)
        : _l_;
    return _m_;
   }
   function wait(t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    repr[1] = 1;
    return caml_call1(Async_kernel_Ivar[19], repr[2]);
   }
   function has_any_waiters$1(t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    return repr[1];
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Bvar);
   var
    Async_kernel_Bvar =
      [0, sexp_of_t, invariant, create, wait, broadcast, has_any_waiters$1];
   runtime.caml_register_global
    (26, Async_kernel_Bvar, cst_Async_kernel_Bvar$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_source
//# unitInfo: Requires: Async_kernel__Bvar, Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Tail, Async_kernel__Time_ns, Async_kernel__Types, Base__Invariant, Core, Core__Error, Core__Time_ns, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Aborted = "Aborted",
    cst_Async_kernel_Time_source$0 = "Async_kernel__Time_source",
    cst_Happened = "Happened",
    cst_Ok = "Ok",
    cst_Previously_aborted = "Previously_aborted",
    cst_Previously_happened = "Previously_happened",
    cst = "_",
    cst_alarm$0 = "alarm",
    cst_async_kernel$0 = "async_kernel",
    cst_fired$0 = "fired",
    cst_num_fires_to_skip$0 = "num_fires_to_skip",
    cst_scheduled_at$0 = "scheduled_at",
    cst_src_time_source_ml = "src/time_source.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos = "src/time_source.ml:303:33",
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Timing_wheel = global_data.Timing_wheel,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Core_Error = global_data.Core__Error,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Types = global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_source$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_time_source_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "time_source.ml");
   var
    debug = Async_kernel_Debug[1],
    upon = Async_kernel_Deferred1[8],
    choose = Async_kernel_Deferred1[34],
    choice = Async_kernel_Deferred1[29],
    include = Async_kernel_Synchronous_time_[4],
    Job_or_event = include[2],
    invariant_with_jobs = include[20],
    invariant = include[21],
    cst_Time_source_with_timeout_b$0 =
      "Time_source.with_timeout bug: should only abort once",
    cst_Time_source_with_timeout_b =
      "Time_source.with_timeout bug: both completed and timed out",
    _Q_ = [0, 1],
    _P_ = [0, "span"],
    cst_Time_source_every_got_nonp = "Time_source.every got nonpositive span",
    _N_ = [0, -146189108],
    _O_ = [0, 3903734],
    cst_Time_source_Event_run_at = "Time_source.Event.run_at",
    _M_ = [0, cst],
    _L_ = [0, cst],
    cst_Time_source_Event_reschedu = "Time_source.Event.reschedule_at",
    _I_ = [0, cst_Ok],
    _J_ = [0, cst_Previously_aborted],
    _K_ = [0, cst_Previously_happened],
    cst_Clock_Event_abort_exn_fail$0 =
      "Clock.Event.abort_exn failed to abort event that previously happened",
    cst_Clock_Event_abort_exn_fail =
      "Clock.Event.abort_exn failed to abort event that previously aborted",
    _H_ = [0, cst],
    _G_ = [0, cst],
    cst_Time_source_Event_abort = "Time_source.Event.abort",
    _D_ = [0, cst_Ok],
    _E_ = [0, cst_Previously_aborted],
    _F_ = [0, cst_Previously_happened],
    _A_ = [0, cst_Aborted],
    _B_ = [0, cst_Happened],
    _C_ = [0, "Scheduled_at"],
    _y_ = [0, cst],
    _x_ = [0, cst],
    _v_ = [0, cst_src_time_source_ml, 288, 18],
    _w_ = [0, cst_src_time_source_ml, 290, 18],
    _u_ = [0, cst_src_time_source_ml, 299, 43],
    _z_ = [0, cst_src_time_source_ml, 281, 9656, 9680],
    _o_ = [0, "time_source"],
    _p_ = [0, cst_scheduled_at$0],
    _q_ = [0, cst_num_fires_to_skip$0],
    _r_ = [0, cst_fired$0],
    _s_ = [0, "fire"],
    _t_ = [0, cst_alarm$0],
    _e_ = [0, cst_Aborted],
    _f_ = [0, cst_Happened],
    _d_ = [0, cst_src_time_source_ml, 238, 5],
    _a_ = [0, cst],
    _b_ = [0, "events"],
    _c_ = [0, "is_wall_clock"],
    cst_wall_clock = "<wall_clock>",
    cst_scheduled_at = cst_scheduled_at$0,
    cst_num_fires_to_skip = cst_num_fires_to_skip$0,
    cst_fired = cst_fired$0,
    cst_alarm = cst_alarm$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Time_source = cst_Async_kernel_Time_source$0;
   function sexp_of_t(param, _a$_){
    var events = _a$_[4], is_wall_clock = _a$_[8];
    if(is_wall_clock)
     return caml_call1(Sexplib0_Sexp_conv[7], cst_wall_clock);
    var _ba_ = 0, _bb_ = 0;
    function _bc_(param){return _a_;}
    var
     _bd_ =
       [0,
        [1, [0, _b_, [0, caml_call2(Timing_wheel[2], _bc_, events), _bb_]]],
        _ba_];
    return [1,
            [0,
             [1, [0, _c_, [0, caml_call1(Core[323], is_wall_clock), 0]]],
             _bd_]];
   }
   function sexp_of_t$0(x_002){return sexp_of_t(Core[212], x_002);}
   var Read_write = [0, sexp_of_t$0, invariant, invariant_with_jobs];
   function sexp_of_t$1(x_003){return sexp_of_t(Core[171], x_003);}
   function read_only(t){return t;}
   var
    create = Async_kernel_Scheduler1[81],
    wall_clock = Async_kernel_Scheduler1[82];
   function alarm_precision(t){return caml_call1(Timing_wheel[10], t[4]);}
   function is_wall_clock(t){return t[8];}
   function next_alarm_fires_at(t){return caml_call1(Timing_wheel[39], t[4]);}
   function timing_wheel_now(t){return caml_call1(Timing_wheel[11], t[4]);}
   function id(t){return t[1];}
   function now(t){
    return t[8]
            ? caml_call1(Async_kernel_Time_ns[42], 0)
            : timing_wheel_now(t);
   }
   var send_exn = [0, Async_kernel_Monitor[15]];
   function advance_directly(t, to){
    return caml_call3(Async_kernel_Synchronous_time_[28], t, to, send_exn);
   }
   function advance_directly_by(t, by){
    var _a__ = now(t);
    return advance_directly
            (t, caml_call2(Async_kernel_Time_ns[119], _a__, by));
   }
   function fire_past_alarms(t){
    return caml_call2(Async_kernel_Synchronous_time_[30], t, send_exn);
   }
   function yield$0(t){
    var _a9_ = caml_call1(Async_kernel_Scheduler1[15], t[9]);
    return caml_call1(Async_kernel_Bvar[4], _a9_);
   }
   function bind_unit(t, f){
    if(caml_call1(Async_kernel_Deferred1[7], t)) return caml_call1(f, 0);
    function _a8_(param){return caml_call1(f, 0);}
    return caml_call2(Async_kernel_Deferred_std[5][1], t, _a8_);
   }
   function advance_by_alarms(wait_for, t, to){
    function run_queued_alarms(param){
     if(! wait_for) return yield$0(t);
     var f = wait_for[1];
     return caml_call1(f, 0);
    }
    function walk_alarms(param){
     var
      match =
        caml_call1(Async_kernel_Synchronous_time_[27], t)
         ? [0, now(t), 835248231]
         : [0, to, -53446108],
      next = match[2],
      advance_to = match[1];
     caml_call3(Async_kernel_Synchronous_time_[29], t, advance_to, send_exn);
     fire_past_alarms(t);
     function _a6_(param){
      if(835248231 <= next) return walk_alarms(0);
      var _a7_ = timing_wheel_now(t);
      return caml_call2(Async_kernel_Time_ns[104], _a7_, to)
              ? walk_alarms(0)
              : caml_call1(Async_kernel_Deferred_std[10], 0);
     }
     return bind_unit(run_queued_alarms(0), _a6_);
    }
    function _a4_(param){return walk_alarms(0);}
    var _a5_ = run_queued_alarms(0);
    return caml_call2(Async_kernel_Deferred_std[5][1], _a5_, _a4_);
   }
   function advance_by_max_alarms_in_each_(wait_for, t, to){
    function run_queued_alarms(param){
     if(! wait_for) return yield$0(t);
     var f = wait_for[1];
     return caml_call1(f, 0);
    }
    function finish(param){
     advance_directly(t, to);
     fire_past_alarms(t);
     return run_queued_alarms(0);
    }
    function walk_alarms(param){
     var match = next_alarm_fires_at(t);
     if(! match) return finish(0);
     var next_alarm_fires_at$0 = match[1];
     if(caml_call2(Async_kernel_Time_ns[100], next_alarm_fires_at$0, to))
      return finish(0);
     advance_directly(t, caml_call1(Timing_wheel[37], t[4]));
     fire_past_alarms(t);
     var queued_alarms_ran = run_queued_alarms(0);
     return bind_unit(queued_alarms_ran, walk_alarms);
    }
    fire_past_alarms(t);
    function _a2_(param){return walk_alarms(0);}
    var _a3_ = run_queued_alarms(0);
    return caml_call2(Async_kernel_Deferred_std[5][1], _a3_, _a2_);
   }
   function advance_by_alarms_by(wait_for, t, by){
    var _a1_ = now(t);
    return advance_by_alarms
            (wait_for, t, caml_call2(Async_kernel_Time_ns[119], _a1_, by));
   }
   function span_to_time(t, span){
    var _a0_ = now(t);
    return caml_call2(Async_kernel_Time_ns[119], _a0_, span);
   }
   function run_at_internal(t, time, f$0, a){
    var
     execution_context = caml_call1(Async_kernel_Scheduler1[73], t[9]),
     _aZ_ = caml_call1(Timing_wheel[11], t[4]);
    if(! caml_call2(Async_kernel_Time_ns[103], time, _aZ_)){
     caml_call4(Async_kernel_Scheduler1[63], t[9], execution_context, f$0, a);
     return caml_call1(Timing_wheel[5][2], 0);
    }
    var
     _aX_ =
       caml_call4
        (Async_kernel_Scheduler1[76], t[9], execution_context, f$0, a),
     _aY_ = caml_call1(Job_or_event[2], _aX_),
     alarm = caml_call3(Timing_wheel[26], t[4], time, _aY_),
     match = t[9][23];
    if(match){var f = match[1]; caml_call1(f, time);}
    return alarm;
   }
   function run_at(t, time, f, a){run_at_internal(t, time, f, a); return 0;}
   function run_after(t, span, f, a){
    return run_at(t, span_to_time(t, span), f, a);
   }
   function fill(result){return caml_call2(Async_kernel_Ivar[14], result, 0);}
   function at(t, time){
    var _aW_ = caml_call1(Timing_wheel[11], t[4]);
    if(caml_call2(Async_kernel_Time_ns[101], time, _aW_))
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    var result = caml_call1(Async_kernel_Ivar[12], 0);
    run_at_internal(t, time, fill, result);
    return caml_call1(Async_kernel_Ivar[19], result);
   }
   function after(t, span){return at(t, span_to_time(t, span));}
   function remove_alarm(t, alarm){
    var
     job_or_event = caml_call2(Timing_wheel[5][5], t[4], alarm),
     k = caml_call1(Job_or_event[5][1], job_or_event),
     match = caml_call2(Job_or_event[5][2], k, job_or_event);
    if(! k) throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    caml_call2(Async_kernel_Scheduler1[62], t[9], match);
    return caml_call2(Timing_wheel[29], t[4], alarm);
   }
   function sexp_of_t$2(of_a_007, of_h_008, param){
    if(0 === param[0]){
     var arg0_009 = param[1], res0_010 = caml_call1(of_a_007, arg0_009);
     return [1, [0, _e_, [0, res0_010, 0]]];
    }
    var arg0_011 = param[1], res0_012 = caml_call1(of_h_008, arg0_011);
    return [1, [0, _f_, [0, res0_012, 0]]];
   }
   var Fired = [0, sexp_of_t$2];
   function scheduled_at(r){return r[5];}
   function set_scheduled_at(r, v){r[5] = v; return 0;}
   function num_fires_to_skip(r){return r[4];}
   function set_num_fires_to_skip(r, v){r[4] = v; return 0;}
   function fired(r){return r[3];}
   function alarm(r){return r[1];}
   function set_alarm(r, v){r[1] = v; return 0;}
   function _g_(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6]];}
   var
    _h_ = [0, set_scheduled_at],
    scheduled_at$0 =
      [0,
       function(param){return 0;},
       cst_scheduled_at,
       _h_,
       scheduled_at,
       _g_];
   function _i_(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6]];}
   var
    _j_ = [0, set_num_fires_to_skip],
    num_fires_to_skip$0 =
      [0,
       function(param){return 0;},
       cst_num_fires_to_skip,
       _j_,
       num_fires_to_skip,
       _i_];
   function _k_(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6]];}
   var
    _l_ = 0,
    fired$0 = [0, function(param){return 0;}, cst_fired, _l_, fired, _k_];
   function _m_(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6]];}
   var
    _n_ = [0, set_alarm],
    alarm$0 = [0, function(param){return 0;}, cst_alarm, _n_, alarm, _m_];
   function sexp_of_t$3(of_a_015, of_h_016, param){
    var
     alarm_018 = param[1],
     fired_022 = param[3],
     num_fires_to_skip_024 = param[4],
     scheduled_at_026 = param[5],
     time_source_028 = param[6],
     arg_029 = caml_call1(Async_kernel_Synchronous_time_[5], time_source_028),
     bnds_017 = [0, [1, [0, _o_, [0, arg_029, 0]]], 0],
     arg_027 = caml_call1(Async_kernel_Time_ns[98], scheduled_at_026),
     bnds_017$0 = [0, [1, [0, _p_, [0, arg_027, 0]]], bnds_017],
     arg_025 = caml_call1(Core[389], num_fires_to_skip_024),
     bnds_017$1 = [0, [1, [0, _q_, [0, arg_025, 0]]], bnds_017$0],
     _aT_ = caml_call2(Fired[1], of_a_015, of_h_016),
     arg_023 = caml_call2(Async_kernel_Ivar[9], _aT_, fired_022),
     bnds_017$2 = [0, [1, [0, _r_, [0, arg_023, 0]]], bnds_017$1];
    function _aU_(_aV_){return 0;}
    var
     arg_021 = caml_call1(Sexplib0_Sexp_conv[24], _aU_),
     bnds_017$3 = [0, [1, [0, _s_, [0, arg_021, 0]]], bnds_017$2],
     arg_019 = caml_call2(Timing_wheel[5][1], Job_or_event[6], alarm_018),
     bnds_017$4 = [0, [1, [0, _t_, [0, arg_019, 0]]], bnds_017$3];
    return [1, bnds_017$4];
   }
   function sexp_of_t_unit(x_030){
    return sexp_of_t$3(Core[620], Core[620], x_030);
   }
   function fired$1(t){return caml_call1(Async_kernel_Ivar[19], t[3]);}
   function invariant$0(invariant_a, invariant_h, t){
    function _aM_(param){
     var events = t[6][4];
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      scheduled_at_fun =
        check
         (function(scheduled_at){
           var _aS_ = caml_call2(Timing_wheel[28], events, t[1]);
           if(! _aS_) return _aS_;
           var
            expect = caml_call2(Timing_wheel[5][3], events, t[1]),
            sexpifier = Async_kernel_Time_ns[98],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_032, b_033){
            return caml_call2(Async_kernel_Time_ns[107], a_032, b_033);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    scheduled_at);
          }),
      num_fires_to_skip_fun =
        check
         (function(num_fires_to_skip){
           if(caml_call2(Async_kernel_Import[1], num_fires_to_skip, 0))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
          }),
      fired_fun =
        check
         (function(fired){
           var
            _aR_ = caml_call1(Async_kernel_Ivar[19], fired),
            match = caml_call1(Async_kernel_Deferred1[5], _aR_);
           if(! match) return 0;
           var match$0 = match[1];
           if(0 === match$0[0]){
            var a = match$0[1];
            return caml_call1(invariant_a, a);
           }
           var h = match$0[1];
           return caml_call1(invariant_h, h);
          }),
      alarm_fun =
        check
         (function(alarm){
           if(caml_call1(Async_kernel_Ivar[18], t[3])){
            if(caml_call2(Timing_wheel[28], events, alarm))
             throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
            return 0;
           }
           var _aP_ = caml_call2(Timing_wheel[28], events, alarm);
           if(! _aP_) return _aP_;
           var _aQ_ = caml_call2(Timing_wheel[5][5], events, alarm);
           if(caml_call1(Job_or_event[4], _aQ_)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
          });
     caml_call1(alarm_fun, alarm$0);
     caml_call1(fired_fun, fired$0);
     caml_call1(num_fires_to_skip_fun, num_fires_to_skip$0);
     caml_call1(scheduled_at_fun, scheduled_at$0);
     return 0;
    }
    function _aN_(x_031){
     function _aO_(param){return _x_;}
     return sexp_of_t$3(function(param){return _y_;}, _aO_, x_031);
    }
    return caml_call4(Base_Invariant[1], _z_, t, _aN_, _aM_);
   }
   function sexp_of_t$4(of_a_034, of_h_035, param){
    switch(param[0]){
      case 0:
       var arg0_036 = param[1], res0_037 = caml_call1(of_a_034, arg0_036);
       return [1, [0, _A_, [0, res0_037, 0]]];
      case 1:
       var arg0_038 = param[1], res0_039 = caml_call1(of_h_035, arg0_038);
       return [1, [0, _B_, [0, res0_039, 0]]];
      default:
       var
        arg0_040 = param[1],
        res0_041 = caml_call1(Async_kernel_Time_ns[98], arg0_040);
       return [1, [0, _C_, [0, res0_041, 0]]];
    }
   }
   var Status = [0, sexp_of_t$4];
   function status(t){
    var
     _aL_ = caml_call1(Async_kernel_Ivar[19], t[3]),
     match = caml_call1(Async_kernel_Deferred1[5], _aL_);
    if(! match) return [2, t[5]];
    var match$0 = match[1];
    if(0 === match$0[0]){var a = match$0[1]; return [0, a];}
    var h = match$0[1];
    return [1, h];
   }
   function sexp_of_t$5(of_a_044, of_h_045, param){
    if(typeof param === "number") return _D_;
    if(0 === param[0]){
     var arg0_046 = param[1], res0_047 = caml_call1(of_a_044, arg0_046);
     return [1, [0, _E_, [0, res0_047, 0]]];
    }
    var arg0_048 = param[1], res0_049 = caml_call1(of_h_045, arg0_048);
    return [1, [0, _F_, [0, res0_049, 0]]];
   }
   var Abort_result = [0, sexp_of_t$5];
   function abort(t, a){
    if(debug){
     var
      _aI_ =
        function(x_052){
         function _aK_(param){return _G_;}
         return sexp_of_t$3(function(param){return _H_;}, _aK_, x_052);
        };
     caml_call3(Async_kernel_Debug[15], cst_Time_source_Event_abort, t, _aI_);
    }
    var
     _aJ_ = fired$1(t),
     match = caml_call1(Async_kernel_Deferred1[5], _aJ_);
    if(! match){
     caml_call2(Async_kernel_Ivar[14], t[3], [0, a]);
     var alarm = t[1], t$0 = t[6];
     if(caml_call2(Timing_wheel[28], t$0[4], alarm)) remove_alarm(t$0, alarm);
     return 0;
    }
    var match$0 = match[1];
    if(0 === match$0[0]){var a$0 = match$0[1]; return [0, a$0];}
    var h = match$0[1];
    return [1, h];
   }
   function abort_exn(t, a){
    var match = abort(t, a);
    if(typeof match === "number") return 0;
    if(0 === match[0]){
     var
      _aG_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Clock_Event_abort_exn_fail);
     return caml_call1(Core[261], _aG_);
    }
    var
     _aH_ =
       caml_call1(Sexplib0_Sexp_conv[7], cst_Clock_Event_abort_exn_fail$0);
    return caml_call1(Core[261], _aH_);
   }
   function abort_if_possible(t, a){abort(t, a); return 0;}
   function schedule(t){t[1] = run_at_internal(t[6], t[5], t[2], 0); return;}
   function sexp_of_t$6(of_a_053, of_h_054, param){
    if(typeof param === "number") return _I_;
    if(0 === param[0]){
     var arg0_055 = param[1], res0_056 = caml_call1(of_a_053, arg0_055);
     return [1, [0, _J_, [0, res0_056, 0]]];
    }
    var arg0_057 = param[1], res0_058 = caml_call1(of_h_054, arg0_057);
    return [1, [0, _K_, [0, res0_058, 0]]];
   }
   var Reschedule_result = [0, sexp_of_t$6];
   function reschedule_at(t, at){
    if(debug){
     var
      _aC_ =
        function(param){
         var arg1_062 = param[2], arg0_061 = param[1];
         function _aF_(param){return _L_;}
         var
          res0_063 = sexp_of_t$3(function(param){return _M_;}, _aF_, arg0_061),
          res1_064 = caml_call1(Async_kernel_Time_ns[98], arg1_062);
         return [1, [0, res0_063, [0, res1_064, 0]]];
        };
     caml_call3
      (Async_kernel_Debug[15],
       cst_Time_source_Event_reschedu,
       [0, t, at],
       _aC_);
    }
    var
     _aD_ = fired$1(t),
     match = caml_call1(Async_kernel_Deferred1[5], _aD_);
    if(match){
     var match$0 = match[1];
     if(0 === match$0[0]){var a = match$0[1]; return [0, a];}
     var h = match$0[1];
     return [1, h];
    }
    var
     events = t[6][4],
     is_in_timing_wheel = caml_call2(Timing_wheel[28], events, t[1]),
     _aE_ = caml_call1(Timing_wheel[11], events),
     am_trying_to_reschedule_in_the =
       caml_call2(Async_kernel_Time_ns[103], at, _aE_);
    t[5] = at;
    if(am_trying_to_reschedule_in_the)
     if(is_in_timing_wheel)
      caml_call3(Timing_wheel[30], events, t[1], at);
     else{t[4] = t[4] + 1 | 0; schedule(t);}
    else if(is_in_timing_wheel){
     caml_call1(t[6][7], t[1]);
     caml_call2(Timing_wheel[29], events, t[1]);
    }
    return 0;
   }
   function reschedule_after(t, span){
    return reschedule_at(t, span_to_time(t[6], span));
   }
   function run_at$0(time_source, scheduled_at, f, z){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_Time_source_Event_run_at,
       scheduled_at,
       Async_kernel_Time_ns[98]);
    var _av_ = 0, _aw_ = caml_call1(Async_kernel_Ivar[12], 0);
    function _ax_(_aB_){return 0;}
    var
     t =
       [0,
        caml_call1(Timing_wheel[5][2], 0),
        _ax_,
        _aw_,
        _av_,
        scheduled_at,
        time_source];
    function fire(param){
     var _ay_ = caml_call1(Async_kernel_Ivar[17], t[3]);
     if(_ay_){
      if(caml_call2(Async_kernel_Import[4], t[4], 0)){t[4] = t[4] - 1 | 0; return 0;}
      var
       result = caml_call1(f, z),
       _az_ = caml_call1(Async_kernel_Ivar[17], t[3]);
      if(_az_) return caml_call2(Async_kernel_Ivar[14], t[3], [1, result]);
      var _aA_ = _az_;
     }
     else
      var _aA_ = _ay_;
     return _aA_;
    }
    t[2] = fire;
    schedule(t);
    return t;
   }
   function at$0(time_source, time){
    var _at_ = 0;
    return run_at$0(time_source, time, function(_au_){return 0;}, _at_);
   }
   function run_after$0(time_source, span, f, a){
    return run_at$0(time_source, span_to_time(time_source, span), f, a);
   }
   function after$0(time_source, span){
    return at$0(time_source, span_to_time(time_source, span));
   }
   function at_times(opt, t, next_time){
    if(opt)
     var sth = opt[1], stop = sth;
    else
     var stop = caml_call1(Async_kernel_Deferred1[12], 0);
    var tail = caml_call1(Async_kernel_Tail[2], 0);
    function loop(param){
     function _ap_(param){
      return 936767357 <= param
              ? (caml_call2(Async_kernel_Tail[3], tail, 0), loop(0))
              : caml_call1(Async_kernel_Tail[4], tail);
     }
     var _aq_ = 0;
     function _ar_(param){return 936767357;}
     var
      _as_ =
        [0, caml_call2(choice, at(t, caml_call1(next_time, 0)), _ar_), _aq_];
     return caml_call2
             (upon,
              caml_call1
               (choose,
                [0,
                 caml_call2(choice, stop, function(param){return 926227490;}),
                 _as_]),
              _ap_);
    }
    loop(0);
    return caml_call1(Async_kernel_Tail[8], tail);
   }
   function at_varying_intervals(stop, t, compute_span){
    return at_times
            (stop,
             t,
             function(param){
              var _an_ = caml_call1(compute_span, 0), _ao_ = now(t);
              return caml_call2(Async_kernel_Time_ns[119], _ao_, _an_);
             });
   }
   function at_intervals(start, stop, t, interval){
    if(start) var x = start[1], start$0 = x; else var start$0 = now(t);
    return at_times
            (stop,
             t,
             function(param){
              var _am_ = now(t);
              return caml_call5
                      (Async_kernel_Time_ns[57], 0, start$0, _am_, interval, 0);
             });
   }
   var immediately = 0;
   function run_repeatedly(opt, stop, _ag_, _af_, time_source, f, continue$0){
    if(opt)
     var sth = opt[1], start = sth;
    else
     var start = caml_call1(Async_kernel_Deferred_std[10], 0);
    if(_ag_)
     var sth$0 = _ag_[1], continue_on_error = sth$0;
    else
     var continue_on_error = 1;
    if(_af_)
     var sth$1 = _af_[1], finished = sth$1;
    else
     var finished = caml_call1(Async_kernel_Ivar[12], 0);
    return caml_call2
            (upon,
             start,
             function(param){
              var alarm = [0, caml_call1(Timing_wheel[5][2], 0)];
              if(stop){
               var stop$0 = stop[1];
               caml_call2
                (upon,
                 stop$0,
                 function(param){
                  var
                   _al_ =
                     caml_call2(Timing_wheel[28], time_source[4], alarm[1]);
                  return _al_
                          ? (remove_alarm
                             (time_source, alarm[1]),
                            caml_call2(Async_kernel_Ivar[16], finished, 0))
                          : _al_;
                 });
               var stop$1 = stop$0;
              }
              else
               var stop$1 = caml_call1(Async_kernel_Deferred1[12], 0);
              function run_f(param){
               if(caml_call1(Async_kernel_Deferred1[7], stop$1))
                return caml_call2(Async_kernel_Ivar[16], finished, 0);
               if(continue_on_error)
                return caml_call2
                        (upon,
                         caml_call7
                          (Async_kernel_Monitor[16], 0, 0, 0, 0, _O_, _N_, f),
                         continue_try_with);
               var d = caml_call1(f, 0);
               return caml_call1(Async_kernel_Deferred1[7], d)
                       ? continue_f(0)
                       : caml_call2(upon, d, continue_f);
              }
              function continue_f(param){
               if(caml_call1(Async_kernel_Deferred1[7], stop$1))
                return caml_call2(Async_kernel_Ivar[16], finished, 0);
               var _aj_ = 0;
               if(typeof continue$0 === "number")
                var _ak_ = caml_call1(Timing_wheel[11], time_source[4]);
               else if(0 === continue$0[0])
                var
                 span = continue$0[1],
                 _ak_ = span_to_time(time_source, span);
               else
                var
                 interval = continue$0[2],
                 base = continue$0[1],
                 _ai_ = now(time_source),
                 _ak_ =
                   caml_call5
                    (Async_kernel_Time_ns[57], 0, base, _ai_, interval, 0);
               alarm[1] = run_at_internal(time_source, _ak_, run_f, _aj_);
               return 0;
              }
              function continue_try_with(or_error){
               if(0 !== or_error[0]){
                var
                 error = or_error[1],
                 _ah_ = caml_call1(Async_kernel_Monitor[5], 0);
                caml_call3(Async_kernel_Monitor[15], _ah_, 0, error);
               }
               return continue_f(0);
              }
              return run_f(0);
             });
   }
   function every(start, stop, continue_on_error, finished, t, span, f){
    if(caml_call2(Core_Time_ns[1][16], span, Core_Time_ns[1][76])){
     var
      _ad_ =
        [0, [1, [0, _P_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]], 0],
      _ae_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Time_source_every_got_nonp),
          _ad_]];
     caml_call1(Core[261], _ae_);
    }
    return run_repeatedly
            (start, stop, continue_on_error, finished, t, f, [0, span]);
   }
   function every$0(start, stop, continue_on_error, t, span, f){
    return every
            (start,
             stop,
             continue_on_error,
             0,
             t,
             span,
             function(param){
              caml_call1(f, 0);
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function run_at_intervals(start, stop, continue_on_error, t, interval, f){
    var now$0 = now(t);
    if(start)
     var
      start$0 = start[1],
      start$1 =
        [0,
         at
          (t,
           caml_call5
            (Async_kernel_Time_ns[57], _Q_, start$0, now$0, interval, 0))],
      base = start$0;
    else
     var start$1 = 0, base = now$0;
    return run_repeatedly
            (start$1, stop, continue_on_error, 0, t, f, [1, base, interval]);
   }
   function run_at_intervals$0(start, stop, continue_on_error, t, interval, f){
    return run_at_intervals
            (start,
             stop,
             continue_on_error,
             t,
             interval,
             function(param){
              caml_call1(f, 0);
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function with_timeout(t, span, d){
    var timeout = after$0(t, span), ___ = 0;
    function _$_(param){
     if(0 !== param[0]) return 642269825;
     var
      _ac_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Time_source_with_timeout_b);
     return caml_call1(Core[261], _ac_);
    }
    var _aa_ = [0, caml_call2(choice, fired$1(timeout), _$_), ___];
    return caml_call1
            (choose,
             [0,
              caml_call2
               (choice,
                d,
                function(v){
                 var match = abort(timeout, 0);
                 a:
                 if(typeof match !== "number" && 0 === match[0]){
                  var
                   _ab_ =
                     caml_call1
                      (Sexplib0_Sexp_conv[7], cst_Time_source_with_timeout_b$0);
                  caml_call1(Core[261], _ab_);
                  break a;
                 }
                 return [0, 1025039613, v];
                }),
              _aa_]);
   }
   function with_timeout_exn(t, span, d, error){
    function _Y_(param){
     if(typeof param === "number") return caml_call1(Core_Error[30], error);
     var result = param[2];
     return result;
    }
    var _Z_ = with_timeout(t, span, d);
    return caml_call2(Async_kernel_Deferred1[18], _Z_, _Y_);
   }
   function duration_of(t, f){
    var start = now(t);
    function f$0(result){
     var
      _X_ = now(t),
      duration = caml_call2(Async_kernel_Time_ns[49], _X_, start);
     return [0, result, duration];
    }
    var t$0 = caml_call1(f, 0);
    if(! caml_call1(Async_kernel_Deferred1[7], t$0))
     return caml_call2(Async_kernel_Deferred1[18], t$0, f$0);
    var _W_ = f$0(caml_call1(Async_kernel_Deferred1[6], t$0));
    return caml_call1(Async_kernel_Deferred_std[10], _W_);
   }
   function of_synchronous(t){return t;}
   function to_synchronous(t){return t;}
   function advance_directly_if_quiescent(t, time){
    var
     t$0 = t[9],
     _R_ = caml_call1(Async_kernel_Scheduler1[56], t$0),
     _S_ = caml_call2(Async_kernel_Import[4], _R_, 0),
     _T_ = _S_ || caml_call1(Async_kernel_Bvar[6], t$0[24]);
    if(_T_)
     var is_quescent = _T_;
    else{
     var _U_ = caml_call1(Async_kernel_Synchronous_time_[42], t);
     if(_U_)
      var is_quescent = _U_;
     else{
      var wheel = t[4];
      if(caml_call1(Timing_wheel[13], wheel))
       var _V_ = 0;
      else
       var
        next_alarm = caml_call1(Timing_wheel[40], wheel),
        _V_ = caml_call2(Async_kernel_Time_ns[101], next_alarm, time);
      var is_quescent = _V_;
     }
    }
    return is_quescent ? 0 : (advance_directly(t, time), 1);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_source);
   var
    Async_kernel_Time_source =
      [0,
       [0, sexp_of_t],
       Read_write,
       Async_kernel_Types[21],
       sexp_of_t$1,
       id,
       invariant,
       invariant_with_jobs,
       read_only,
       create,
       wall_clock,
       alarm_precision,
       is_wall_clock,
       next_alarm_fires_at,
       now,
       timing_wheel_now,
       advance_directly,
       advance_directly,
       advance_directly_by,
       advance_directly_by,
       fire_past_alarms,
       advance_by_alarms,
       advance_by_max_alarms_in_each_,
       advance_by_alarms_by,
       [0, immediately],
       run_repeatedly,
       run_at,
       run_after,
       at,
       after,
       with_timeout,
       with_timeout_exn,
       duration_of,
       [0,
        sexp_of_t$3,
        sexp_of_t_unit,
        invariant$0,
        scheduled_at,
        Status,
        status,
        run_at$0,
        run_after$0,
        Abort_result,
        abort,
        abort_exn,
        abort_if_possible,
        Fired,
        fired$1,
        Reschedule_result,
        reschedule_at,
        reschedule_after,
        at$0,
        after$0],
       at_varying_intervals,
       at_intervals,
       every,
       every$0,
       run_at_intervals,
       run_at_intervals$0,
       of_synchronous,
       to_synchronous,
       advance_directly_if_quiescent];
   runtime.caml_register_global
    (82, Async_kernel_Time_source, cst_Async_kernel_Time_source$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Cycle_hook
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Cycle_hook = "Async_kernel__Cycle_hook",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Cycle_hook);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/cycle_hook.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel, "cycle_hook.ml");
   var Handle = [0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Cycle_hook);
   var Async_kernel_Cycle_hook = [0, Handle];
   runtime.caml_register_global
    (11, Async_kernel_Cycle_hook, cst_Async_kernel_Cycle_hook);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler
//# unitInfo: Requires: Async_kernel__Async_stream, Async_kernel__Bvar, Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Execution_context, Async_kernel__Import, Async_kernel__Job_queue, Async_kernel__Monitor, Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Tail, Async_kernel__Time_ns, Async_kernel__Types, Async_kernel_config, Base__Backtrace, Core, Core__Array, Core__Deque, Core__Error, Core__Gc, Core__Hashtbl, Core__Option, Core__Time_ns, Heap_block, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stdlib, Stdlib__Gc, Thread_safe_queue, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler$0 = "Async_kernel__Scheduler",
    cst_async_kernel$0 = "async_kernel",
    cst_src_scheduler_ml = "src/scheduler.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Import = global_data.Async_kernel__Import,
    Core_Deque = global_data.Core__Deque,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Assert_failure = global_data.Assert_failure,
    Base_Backtrace = global_data.Base__Backtrace,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Core_Error = global_data.Core__Error,
    Core_Option = global_data.Core__Option,
    Core_Array = global_data.Core__Array,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Async_kernel_Job_queue = global_data.Async_kernel__Job_queue,
    Heap_block = global_data.Heap_block,
    Stdlib_Gc = global_data.Stdlib__Gc,
    Stdlib = global_data.Stdlib,
    Core_Gc = global_data.Core__Gc,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Async_stream = global_data.Async_kernel__Async_stream,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Async_kernel_Types = global_data.Async_kernel__Types,
    Timing_wheel = global_data.Timing_wheel,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_scheduler_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "scheduler.ml");
   var
    start_cycle = Async_kernel_Scheduler1[78],
    create_job = Async_kernel_Scheduler1[76],
    with_execution_context = Async_kernel_Scheduler1[75],
    with_execution_context1 = Async_kernel_Scheduler1[74],
    current_execution_context = Async_kernel_Scheduler1[73],
    check_access = Async_kernel_Scheduler1[71],
    t_ref = Async_kernel_Scheduler1[70],
    backtrace_of_first_job = Async_kernel_Scheduler1[69],
    set_check_access = Async_kernel_Scheduler1[68],
    is_dead = Async_kernel_Scheduler1[67],
    enqueue_job = Async_kernel_Scheduler1[64],
    enqueue = Async_kernel_Scheduler1[63],
    free_job = Async_kernel_Scheduler1[62],
    invariant = Async_kernel_Scheduler1[61],
    last_cycle_num_jobs = Async_kernel_Scheduler1[58],
    num_jobs_run = Async_kernel_Scheduler1[57],
    num_pending_jobs = Async_kernel_Scheduler1[56],
    uncaught_exn = Async_kernel_Scheduler1[55],
    uncaught_exn_unwrapped = Async_kernel_Scheduler1[54],
    sexp_of_t = Async_kernel_Scheduler1[53],
    last_cycle_time = Async_kernel_Scheduler1[29],
    Very_low_priority_worker = Async_kernel_Scheduler1[6],
    debug = Async_kernel_Scheduler1[3],
    set_execution_context = Async_kernel_Scheduler1[2],
    events = Async_kernel_Scheduler1[1],
    t = Async_kernel_Scheduler1[72],
    include = Async_kernel_Monitor[26],
    within = include[1],
    within$0 = include[2],
    within_v = include[3],
    schedule = include[4],
    schedule$0 = include[5],
    within_context = include[6],
    preserve_execution_context = include[7],
    preserve_execution_context$0 = include[8],
    _c_ = [0, cst_src_scheduler_ml, 345, 4],
    _d_ = [0, 1],
    _b_ = [0, "n"],
    cst_Scheduler_yield_every_got_ =
      "Scheduler.yield_every got nonpositive count",
    cst_reset_in_forked_process = "reset_in_forked_process",
    cst_Async_scheduler_is_unusabl =
      "Async scheduler is unusable due to [make_async_unusable]",
    _a_ = [0, "scheduler"],
    cst_run_cycles_until_no_jobs_r$0 =
      "run_cycles_until_no_jobs_remain cannot proceed -- scheduler is dead",
    cst_run_cycles_until_no_jobs_r =
      "run_cycles_until_no_jobs_remain starting",
    cst_run_cycles_until_no_jobs_r$1 =
      "run_cycles_until_no_jobs_remain finished",
    cst_run_cycle_starting = "run_cycle starting",
    cst_run_cycle_finished = "run_cycle finished",
    cst_enqueueing_finalizer_using =
      "enqueueing finalizer (using 'last' semantic)",
    cst_adding_finalizer_using_las =
      "adding finalizer (using 'last' semantic)",
    cst_enqueueing_finalizer = "enqueueing finalizer",
    cst_adding_finalizer = "adding finalizer",
    cst_Attempted_to_remove_a_cycl$0 =
      "Attempted to remove a cycle end hook which has already been removed.",
    cst_Attempted_to_remove_a_cycl =
      "Attempted to remove a cycle start hook which has already been removed.",
    cst_Scheduler_remove_single_cy =
      "Scheduler.remove_single_cycle_hook called with a hook that isn't registered",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Scheduler = cst_Async_kernel_Scheduler$0;
   function find_local(key){
    var _ah_ = caml_call1(current_execution_context, caml_call1(t, 0));
    return caml_call2(Async_kernel_Execution_context[9], _ah_, key);
   }
   function with_local(key, value, f){
    var
     t$0 = caml_call1(t, 0),
     _ag_ = caml_call1(current_execution_context, t$0),
     execution_context =
       caml_call3(Async_kernel_Execution_context[10], _ag_, key, value);
    return caml_call3(with_execution_context, t$0, execution_context, f);
   }
   var main_execution_context = caml_call1(t, 0)[6];
   function can_run_a_job(t){
    var
     _ac_ = caml_call1(num_pending_jobs, t),
     _ad_ = caml_call2(Async_kernel_Import[4], _ac_, 0);
    if(_ad_)
     var _ae_ = _ad_;
    else{
     var _af_ = caml_call1(Async_kernel_Bvar[6], t[24]);
     if(! _af_) return caml_call1(Async_kernel_Bvar[6], t[25]);
     var _ae_ = _af_;
    }
    return _ae_;
   }
   function has_upcoming_event(t){
    var _ab_ = caml_call1(events, t);
    return 1 - caml_call1(Timing_wheel[13], _ab_);
   }
   function next_upcoming_event(t){
    var _aa_ = caml_call1(events, t);
    return caml_call1(Timing_wheel[39], _aa_);
   }
   function next_upcoming_event_exn(t){
    var _$_ = caml_call1(events, t);
    return caml_call1(Timing_wheel[40], _$_);
   }
   function event_precision(t){
    var ___ = caml_call1(events, t);
    return caml_call1(Timing_wheel[10], ___);
   }
   function cycle_start(t){return t[10];}
   function run_every_cycle_start(t, f){
    t[12] = caml_call2(Core_Array[26], [0, f], t[12]);
    return 0;
   }
   function run_every_cycle_end(t, f){
    t[14] = caml_call2(Core_Array[26], [0, f], t[14]);
    return 0;
   }
   function add_every_cycle_start_hook(t, f){
    var handle = caml_call1(Async_kernel_Types[20][45], 0);
    caml_call3(Core_Hashtbl[39], t[13], handle, f);
    run_every_cycle_start(t, f);
    return handle;
   }
   function add_every_cycle_end_hook(t, f){
    var handle = caml_call1(Async_kernel_Types[20][45], 0);
    caml_call3(Core_Hashtbl[39], t[15], handle, f);
    run_every_cycle_end(t, f);
    return handle;
   }
   function remove_single_cycle_hook(arr, f){
    function f$0(param, g){return f === g ? 1 : 0;}
    var match = caml_call2(Core_Array[54], arr, f$0);
    if(match)
     var
      idx = match[1][1],
      _X_ =
        function(i){
         if(caml_call2(Async_kernel_Import[5], i, idx))
          return caml_check_bound(arr, i)[1 + i];
         var _Z_ = i + 1 | 0;
         return caml_check_bound(arr, _Z_)[1 + _Z_];
        },
      match$0 = [0, caml_call2(Core_Array[56], arr.length - 1 - 1 | 0, _X_)];
    else
     var match$0 = 0;
    if(match$0){var arr$0 = match$0[1]; return arr$0;}
    var
     _Y_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_remove_single_cy);
    return caml_call1(Core[261], _Y_);
   }
   function remove_every_cycle_start_hook_(t, handle){
    var match = caml_call2(Core_Hashtbl[64], t[13], handle);
    if(! match) return caml_call1(Core[6], cst_Attempted_to_remove_a_cycl);
    var f = match[1];
    t[12] = remove_single_cycle_hook(t[12], f);
    return 0;
   }
   function remove_every_cycle_end_hook_ex(t, handle){
    var match = caml_call2(Core_Hashtbl[64], t[15], handle);
    if(! match) return caml_call1(Core[6], cst_Attempted_to_remove_a_cycl$0);
    var f = match[1];
    t[14] = remove_single_cycle_hook(t[14], f);
    return 0;
   }
   function map_cycle_times(t, f){
    function _V_(tail){
     return run_every_cycle_start
             (t,
              function(param){
               var _W_ = caml_call1(f, t[16]);
               return caml_call2(Async_kernel_Tail[3], tail, _W_);
              });
    }
    return caml_call1(Async_kernel_Async_stream[2], _V_);
   }
   function long_cycles(t, at_least){
    function _T_(tail){
     return run_every_cycle_start
             (t,
              function(param){
               var _U_ = caml_call2(Core_Time_ns[1][15], t[16], at_least);
               return _U_
                       ? caml_call2(Async_kernel_Tail[3], tail, t[16])
                       : _U_;
              });
    }
    return caml_call1(Async_kernel_Async_stream[2], _T_);
   }
   function cycle_num_jobs(t){
    function _S_(tail){
     return run_every_cycle_start
             (t,
              function(param){
               return caml_call2(Async_kernel_Tail[3], tail, t[17]);
              });
    }
    return caml_call1(Async_kernel_Async_stream[2], _S_);
   }
   function cycle_count(t){return t[9];}
   function set_max_num_jobs_per_priority_(t, int$0){
    t[27] = caml_call1(Async_kernel_config[6][4], int$0);
    return 0;
   }
   function max_num_jobs_per_priority_per_(t){
    return caml_call1(Async_kernel_config[6][5], t[27]);
   }
   function set_thread_safe_external_job_h(t, f){t[21] = f; return 0;}
   function thread_safe_enqueue_external_j(t, execution_context, f, a){
    caml_call2(Thread_safe_queue[5], t[20], [0, execution_context, f, a]);
    return caml_call1(t[21], 0);
   }
   function set_event_added_hook(t, f){t[23] = [0, f]; return 0;}
   function set_job_queued_hook(t, f){t[22] = [0, f]; return 0;}
   function create_alarm(t, f){
    var execution_context = caml_call1(current_execution_context, t);
    function _R_(param){
     return thread_safe_enqueue_external_j(t, execution_context, f, 0);
    }
    return caml_call1(Core_Gc[15][6][2], _R_);
   }
   function add_finalizer(t, heap_block, f){
    var execution_context = caml_call1(current_execution_context, t);
    function finalizer(heap_block){
     if(Async_kernel_Debug[4])
      caml_call1(Async_kernel_Debug[16], cst_enqueueing_finalizer);
     return thread_safe_enqueue_external_j
             (t, execution_context, f, heap_block);
    }
    if(Async_kernel_Debug[4])
     caml_call1(Async_kernel_Debug[16], cst_adding_finalizer);
    try{var _P_ = caml_call2(Stdlib_Gc[3], finalizer, heap_block); return _P_;
    }
    catch(_Q_){
     var _O_ = caml_wrap_exception(_Q_);
     if(_O_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_O_, 0);
    }
   }
   function add_finalizer_exn(t, x, f){
    function _N_(heap_block){
     return caml_call1(f, caml_call1(Heap_block[4], heap_block));
    }
    return add_finalizer(t, caml_call1(Heap_block[3], x), _N_);
   }
   function add_finalizer_last(t, heap_block, f){
    var execution_context = caml_call1(current_execution_context, t);
    function finalizer(param){
     if(Async_kernel_Debug[4])
      caml_call1(Async_kernel_Debug[16], cst_enqueueing_finalizer_using);
     return thread_safe_enqueue_external_j(t, execution_context, f, 0);
    }
    if(Async_kernel_Debug[4])
     caml_call1(Async_kernel_Debug[16], cst_adding_finalizer_using_las);
    try{var _L_ = caml_call2(Stdlib_Gc[4], finalizer, heap_block); return _L_;
    }
    catch(_M_){
     var _K_ = caml_wrap_exception(_M_);
     if(_K_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_K_, 0);
    }
   }
   function add_finalizer_last_exn(t, x, f){
    return add_finalizer_last(t, caml_call1(Heap_block[3], x), f);
   }
   function force_current_cycle_to_end(t){
    return caml_call2(Async_kernel_Job_queue[6], t[3], 0);
   }
   var send_exn = [0, Async_kernel_Monitor[15]];
   function advance_clock(t, now){
    return caml_call3
            (Async_kernel_Synchronous_time_[31], t[19], now, send_exn);
   }
   function run_cycle(t){
    if(debug)
     caml_call3(Async_kernel_Debug[15], cst_run_cycle_starting, t, sexp_of_t);
    var now = caml_call1(Async_kernel_Time_ns[42], 0);
    t[9] = t[9] + 1 | 0;
    t[10] = now;
    t[11] = 1;
    caml_call2(Async_kernel_Bvar[5], t[24], 0);
    var num_jobs_run_at_start_of_cycle = caml_call1(num_jobs_run, t);
    function _y_(f){return caml_call1(f, 0);}
    caml_call2(Core_Array[35], t[12], _y_);
    advance_clock(t, now);
    caml_call2(start_cycle, t, t[27]);
    for(;;){
     var match = caml_call1(Async_kernel_Scheduler1[79], t);
     if(0 === match[0]) break;
     var
      match$0 = match[1],
      backtrace = match$0[2],
      exn = match$0[1],
      _z_ = caml_call1(Async_kernel_Monitor[5], 0);
     caml_call3
      (Async_kernel_Monitor[15], _z_, [0, [0, 936718974, backtrace]], exn);
    }
    var
     _A_ = t[10],
     _B_ = caml_call1(Async_kernel_Time_ns[42], 0),
     cycle_time = caml_call2(Async_kernel_Time_ns[49], _B_, _A_);
    t[16] = cycle_time;
    t[17] = caml_call1(num_jobs_run, t) - num_jobs_run_at_start_of_cycle | 0;
    t[18] = caml_call2(Core_Time_ns[1][101], t[18], cycle_time);
    var _C_ = caml_call1(Async_kernel_Bvar[6], t[25]);
    if(_C_)
     var
      _D_ = caml_call1(num_pending_jobs, t),
      _E_ = caml_call2(Async_kernel_Import[3], _D_, 0);
    else
     var _E_ = _C_;
    if(_E_) caml_call2(Async_kernel_Bvar[5], t[25], 0);
    function _F_(f){return caml_call1(f, 0);}
    caml_call2(Core_Array[35], t[14], _F_);
    t[11] = 0;
    if(! debug) return debug;
    function _G_(param){
     var
      arg1_002 = param[2],
      arg0_001 = param[1],
      res0_003 = caml_call2(Core[515], Core_Error[9], arg0_001),
      res1_004 = caml_call1(Core[323], arg1_002);
     return [1, [0, res0_003, [0, res1_004, 0]]];
    }
    var
     _H_ = next_upcoming_event(t),
     _I_ = caml_call1(Core[253], _H_),
     _J_ = [0, caml_call1(uncaught_exn, t), _I_];
    return caml_call3
            (Async_kernel_Debug[15], cst_run_cycle_finished, _J_, _G_);
   }
   function run_cycles_until_no_jobs_remai(param){
    if(debug)
     caml_call1(Async_kernel_Debug[16], cst_run_cycles_until_no_jobs_r);
    var t$0 = caml_call1(t, 0);
    if(caml_call1(is_dead, t$0)){
     var
      _u_ = [0, [1, [0, _a_, [0, caml_call1(sexp_of_t, t$0), 0]]], 0],
      _v_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_run_cycles_until_no_jobs_r$0),
          _u_]];
     caml_call1(Core[261], _v_);
    }
    for(;;){
     run_cycle(t$0);
     advance_clock(t$0, caml_call1(Async_kernel_Time_ns[42], 0));
     if(! can_run_a_job(t$0)){
      caml_call2(set_execution_context, t$0, t$0[6]);
      if(debug)
       caml_call1(Async_kernel_Debug[16], cst_run_cycles_until_no_jobs_r$1);
      var _w_ = Core_Error[30], _x_ = caml_call1(uncaught_exn, t$0);
      return caml_call2(Core_Option[46], _x_, _w_);
     }
    }
   }
   function make_async_unusable(param){
    var t = t_ref[1];
    t[1] =
     [0,
      function(param){
       var
        _t_ =
          caml_call1(Sexplib0_Sexp_conv[7], cst_Async_scheduler_is_unusabl);
       return caml_call1(Core[261], _t_);
      }];
    return 0;
   }
   function reset_in_forked_process(param){
    if(debug) caml_call1(Async_kernel_Debug[16], cst_reset_in_forked_process);
    var _s_ = caml_call1(Async_kernel_Scheduler1[66], 0);
    Async_kernel_Scheduler1[70][1] = _s_;
    return 0;
   }
   function check_invariants(t){return t[26];}
   function set_check_invariants(t, b){t[26] = b; return 0;}
   function recording_backtraces(t){return t[28];}
   function set_record_backtraces(t, b){t[28] = b; return 0;}
   function yield$0(t){return caml_call1(Async_kernel_Bvar[4], t[24]);}
   function yield_until_no_jobs_remain(opt, t){
    if(opt)
     var sth = opt[1], may_return_immediately = sth;
    else
     var may_return_immediately = 0;
    if(may_return_immediately){
     var _r_ = caml_call1(num_pending_jobs, t);
     if(caml_call2(Async_kernel_Import[3], _r_, 0))
      return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    return caml_call1(Async_kernel_Bvar[4], t[25]);
   }
   function yield_every(n){
    if(caml_call2(Async_kernel_Import[2], n, 0)){
     var
      _n_ = [0, [1, [0, _b_, [0, caml_call1(Core[389], n), 0]]], 0],
      _o_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_yield_every_got_),
          _n_]];
     return caml_call1(Core[261], _o_);
    }
    if(caml_call2(Async_kernel_Import[3], n, 1)){
     var _p_ = function(t){return yield$0(t);};
     return caml_call1(Core[266], _p_);
    }
    var count_until_yield = [0, n];
    function _q_(t){
     count_until_yield[1] += -1;
     return caml_call2(Async_kernel_Import[4], count_until_yield[1], 0)
             ? caml_call1(Async_kernel_Deferred_std[10], 0)
             : (count_until_yield[1] = n, yield$0(t));
    }
    return caml_call1(Core[266], _q_);
   }
   function total_cycle_time(t){
    if(! t[11]) return t[18];
    var
     _l_ = t[10],
     _m_ = caml_call1(Async_kernel_Time_ns[42], 0),
     this_cycle_time = caml_call2(Async_kernel_Time_ns[49], _m_, _l_);
    return caml_call2(Core_Time_ns[1][101], t[18], this_cycle_time);
   }
   function run(t){
    var num_execs_before_yielding = 1000;
    for(;;){
     if(caml_call2(Async_kernel_Import[3], num_execs_before_yielding, 0))
      return yield_then_run(t);
     var _j_ = 1 - caml_call1(Core_Deque[16], t[5]);
     if(! _j_) return _j_;
     var worker = caml_call1(Core_Deque[61], t[5]);
     caml_call2(set_execution_context, t, worker[1]);
     a:
     {
      var num_execs_before_yielding$0 = num_execs_before_yielding;
      for(;;){
       if(t[7] !== worker[1])
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       if(caml_call2(Async_kernel_Import[3], num_execs_before_yielding$0, 0)){caml_call2(Core_Deque[52], t[5], worker); return yield_then_run(t);}
       var num_execs_before_yielding$1 = num_execs_before_yielding$0 - 1 | 0;
       try{var val = caml_call1(worker[2], 0);}
       catch(exn$0){var exn = caml_wrap_exception(exn$0); break;}
       if(! val) break a;
       var num_execs_before_yielding$0 = num_execs_before_yielding$1;
      }
      var
       bt = caml_call1(Base_Backtrace[6][4], 0),
       _k_ = caml_call1(Async_kernel_Monitor[5], 0);
      caml_call3(Async_kernel_Monitor[15], _k_, [0, [0, 936718974, bt]], exn);
      var num_execs_before_yielding = num_execs_before_yielding$1;
      continue;
     }
     var num_execs_before_yielding = num_execs_before_yielding$1;
    }
   }
   function yield_then_run(t){
    var _g_ = 1 - caml_call1(Core_Deque[16], t[5]);
    if(! _g_) return _g_;
    function _h_(param){return run(t);}
    var _i_ = yield$0(t);
    return caml_call2(Async_kernel_Deferred1[8], _i_, _h_);
   }
   function enqueue$0(f){
    var
     t$0 = caml_call1(t, 0),
     queue = t$0[5],
     running = 1 - caml_call1(Core_Deque[16], queue),
     _e_ = caml_call1(current_execution_context, t$0),
     execution_context =
       caml_call4(Async_kernel_Execution_context[8], 0, _d_, 0, _e_);
    caml_call2(Core_Deque[53], queue, [0, execution_context, f]);
    var _f_ = 1 - running;
    return _f_ ? caml_call4(enqueue, t$0, execution_context, run, t$0) : _f_;
   }
   var For_bench = [0, advance_clock];
   function in_cycle(t){return t[11];}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler);
   var
    Async_kernel_Scheduler =
      [0,
       sexp_of_t,
       t,
       invariant,
       current_execution_context,
       with_execution_context,
       with_execution_context1,
       set_execution_context,
       enqueue,
       create_job,
       enqueue_job,
       free_job,
       main_execution_context,
       cycle_start,
       run_cycle,
       run_cycles_until_no_jobs_remai,
       has_upcoming_event,
       next_upcoming_event,
       next_upcoming_event_exn,
       event_precision,
       uncaught_exn,
       uncaught_exn_unwrapped,
       num_pending_jobs,
       num_jobs_run,
       last_cycle_num_jobs,
       map_cycle_times,
       cycle_num_jobs,
       cycle_count,
       total_cycle_time,
       max_num_jobs_per_priority_per_,
       set_max_num_jobs_per_priority_,
       set_check_access,
       check_access,
       check_invariants,
       set_check_invariants,
       recording_backtraces,
       set_record_backtraces,
       run_every_cycle_start,
       run_every_cycle_end,
       add_every_cycle_start_hook,
       add_every_cycle_end_hook,
       remove_every_cycle_start_hook_,
       remove_every_cycle_end_hook_ex,
       last_cycle_time,
       long_cycles,
       can_run_a_job,
       create_alarm,
       add_finalizer,
       add_finalizer_exn,
       add_finalizer_last,
       add_finalizer_last_exn,
       set_thread_safe_external_job_h,
       set_job_queued_hook,
       set_event_added_hook,
       backtrace_of_first_job,
       thread_safe_enqueue_external_j,
       force_current_cycle_to_end,
       within,
       within$0,
       within_v,
       schedule,
       schedule$0,
       preserve_execution_context,
       preserve_execution_context$0,
       within_context,
       find_local,
       with_local,
       make_async_unusable,
       reset_in_forked_process,
       yield$0,
       yield_every,
       yield_until_no_jobs_remain,
       [0, Very_low_priority_worker[1], enqueue$0],
       For_bench,
       in_cycle];
   runtime.caml_register_global
    (61, Async_kernel_Scheduler, cst_Async_kernel_Scheduler$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Throttled
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Execution_context, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Scheduler, Base__Applicative, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Throttled$0 = "Async_kernel__Throttled",
    cst_async_kernel$0 = "async_kernel",
    cst_src_throttled_ml = "src/throttled.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Core_Option = global_data.Core__Option,
    Assert_failure = global_data.Assert_failure,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Applicative = global_data.Base__Applicative;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Throttled$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_throttled_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "throttled.ml");
   var
    _b_ = [0, ""],
    _a_ = [0, cst_src_throttled_ml, 29, 8],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Throttled = cst_Async_kernel_Throttled$0;
   function return$0(x){
    return function(param, _s_, k){
     return caml_call1(k, caml_call1(Async_kernel_Deferred_std[10], x));};
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return function(exec_ctx, semaphore, k){
         return caml_call3
                 (t,
                  exec_ctx,
                  semaphore,
                  function(d){
                   function _r_(result){return caml_call1(f, result);}
                   return caml_call1
                           (k, caml_call2(Async_kernel_Deferred_std[5][2], d, _r_));
                  });};
       }];
   function apply(t_f, t){
    return function(exec_ctx, semaphore, k){
     return caml_call3
             (t_f,
              exec_ctx,
              semaphore,
              function(df){
               return caml_call3
                       (t,
                        exec_ctx,
                        semaphore,
                        function(dv){
                         function _p_(f){
                          function _q_(v){return caml_call1(f, v);}
                          return caml_call2(Async_kernel_Deferred_std[5][2], dv, _q_);
                         }
                         return caml_call1
                                 (k, caml_call2(Async_kernel_Deferred_std[5][1], df, _p_));
                        });
              });};
   }
   var
    include = caml_call1(Base_Applicative[7], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13];
   function job(f){
    return function(exec_ctx, semaphore, k){
     function _h_(param){
      var
       scheduler = caml_call1(Async_kernel_Scheduler[2], 0),
       ivar = caml_call1(Async_kernel_Ivar[12], 0),
       _j_ = 0;
      function _k_(param){
       var _l_ = caml_call1(Async_kernel_Ivar[14], ivar);
       function _m_(a){
        var max_concurrent_jobs = semaphore[1], waiter = semaphore[2];
        if(waiter){
         var ivar = waiter[1];
         caml_call2(Async_kernel_Ivar[14], ivar, 0);
         semaphore[2] = 0;
        }
        else
         semaphore[1] = max_concurrent_jobs + 1 | 0;
        return a;
       }
       var
        _n_ = caml_call1(f, 0),
        _o_ = caml_call2(Async_kernel_Deferred_std[5][2], _n_, _m_);
       return caml_call2(Async_kernel_Deferred_std[11], _o_, _l_);
      }
      caml_call4(Async_kernel_Scheduler[8], scheduler, exec_ctx, _k_, _j_);
      return caml_call1(k, caml_call1(Async_kernel_Ivar[19], ivar));
     }
     var
      max_concurrent_jobs = semaphore[1],
      waiter = semaphore[2],
      aborted = semaphore[3];
     if(aborted)
      var _i_ = caml_call1(Async_kernel_Deferred1[12], 0);
     else if(caml_call2(Async_kernel_Import[4], max_concurrent_jobs, 0)){
      semaphore[1] = max_concurrent_jobs - 1 | 0;
      var _i_ = caml_call1(Async_kernel_Deferred1[21], 0);
     }
     else{
      if(! caml_call1(Core_Option[61], waiter))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      var ivar = caml_call1(Async_kernel_Ivar[12], 0);
      semaphore[2] = [0, ivar];
      var _i_ = caml_call1(Async_kernel_Ivar[19], ivar);
     }
     return caml_call2(Async_kernel_Deferred1[8], _i_, _h_);};
   }
   function run(t, max_concurrent_jobs){
    var
     semaphore = [0, max_concurrent_jobs, 0, 0],
     monitor = caml_call4(Async_kernel_Monitor[3], 0, 0, _b_, 0),
     parent_monitor = caml_call1(Async_kernel_Monitor[5], 0);
    function _d_(err){
     semaphore[3] = 1;
     semaphore[2] = 0;
     return caml_call3(Async_kernel_Monitor[15], parent_monitor, 0, err);
    }
    caml_call2(Async_kernel_Monitor[7], monitor, _d_);
    var
     _e_ = caml_call1(Async_kernel_Scheduler[2], 0),
     _f_ = caml_call1(Async_kernel_Scheduler[4], _e_),
     exec_ctx =
       caml_call4(Async_kernel_Execution_context[8], [0, monitor], 0, 0, _f_),
     ivar = caml_call1(Async_kernel_Ivar[12], 0);
    caml_call3
     (t,
      exec_ctx,
      semaphore,
      function(r){
       var _g_ = caml_call1(Async_kernel_Ivar[14], ivar);
       return caml_call2(Async_kernel_Deferred1[8], r, _g_);
      });
    return caml_call1(Async_kernel_Ivar[19], ivar);
   }
   function of_thunk(thunk){
    return function(exec_ctx, semaphore, k){
     var t = caml_call1(thunk, 0);
     return caml_call3(t, exec_ctx, semaphore, k);};
   }
   function symbol$1(t1, t2){
    return function(exec_ctx, semaphore, k){
     return caml_call3
             (t1,
              exec_ctx,
              semaphore,
              function(d1){
               return caml_call3
                       (t2,
                        exec_ctx,
                        semaphore,
                        function(d2){
                         function _c_(param){return d2;}
                         return caml_call1
                                 (k, caml_call2(Async_kernel_Deferred_std[5][1], d1, _c_));
                        });
              });};
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Throttled);
   var
    Async_kernel_Throttled =
      [0,
       return$1,
       map$0,
       both,
       symbol,
       symbol$0,
       symbol$1,
       symbol_map,
       apply$0,
       map2,
       map3,
       all,
       all_unit,
       Applicative_infix,
       job,
       run,
       of_thunk,
       symbol$1];
   runtime.caml_register_global
    (23, Async_kernel_Throttled, cst_Async_kernel_Throttled$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Stack_or_counter
//# unitInfo: Requires: Base, Base__Stack, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Stack_or_coun$0 = "Async_kernel__Stack_or_counter",
    cst_async_kernel$0 = "async_kernel",
    cst_length = "length";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Stack = global_data.Base__Stack,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base = global_data.Base,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Stack_or_coun$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/stack_or_counter.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "stack_or_counter.ml");
   var
    cst_Stack_or_counter_pop_exn_o =
      "[Stack_or_counter.pop_exn] of empty stack",
    _d_ = [0, cst_length],
    cst_Stack_or_counter_create_co =
      "[Stack_or_counter.create_counter] got negative length",
    _a_ = [0, "Stack"],
    _b_ = [0, cst_length],
    _c_ = [0, "Counter"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Stack_or_coun = cst_Async_kernel_Stack_or_coun$0;
   function sexp_of_t(of_a_002, param){
    if(0 === param[0]){
     var
      arg0_003 = param[1],
      res0_004 = caml_call2(Base_Stack[2], of_a_002, arg0_003);
     return [1, [0, _a_, [0, res0_004, 0]]];
    }
    var
     length_006 = param[1],
     arg_007 = caml_call1(Base[136], length_006),
     bnds_005 = [0, [1, [0, _b_, [0, arg_007, 0]]], 0];
    return [1, [0, _c_, bnds_005]];
   }
   function of_list(list){return [0, caml_call1(Base_Stack[22], list)];}
   function create_counter(length){
    if(length < 0){
     var
      _i_ = [0, [1, [0, _d_, [0, caml_call1(Base[136], length), 0]]], 0],
      _j_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Stack_or_counter_create_co),
          _i_]];
     caml_call1(Base[246], _j_);
    }
    return [1, length];
   }
   function length(t){
    if(0 !== t[0]) return t[1];
    var s = t[1];
    return caml_call1(Base_Stack[6], s);
   }
   function clear(t){
    if(0 === t[0]){var s = t[1]; return caml_call1(Base_Stack[30], s);}
    t[1] = 0;
    return 0;
   }
   function push(t, a){
    if(0 === t[0]){var s = t[1]; return caml_call2(Base_Stack[25], s, a);}
    t[1] = t[1] + 1 | 0;
    return 0;
   }
   function pop_exn(t){
    if(0 === t[0]){var s = t[1]; return caml_call1(Base_Stack[27], s);}
    if(0 === t[1]){
     var
      _h_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Stack_or_counter_pop_exn_o);
     caml_call1(Base[246], _h_);
    }
    t[1] = t[1] - 1 | 0;
    return 0;
   }
   function iter(t, f){
    if(0 === t[0]){var s = t[1]; return caml_call2(Base_Stack[8], s, f);}
    var _f_ = t[1], _e_ = 1;
    if(_f_ >= 1){
     var for$0 = _e_;
     for(;;){
      caml_call1(f, 0);
      var _g_ = for$0 + 1 | 0;
      if(_f_ === for$0) break;
      var for$0 = _g_;
     }
    }
    return 0;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Stack_or_coun);
   var
    Async_kernel_Stack_or_counter =
      [0,
       sexp_of_t,
       clear,
       create_counter,
       iter,
       length,
       of_list,
       pop_exn,
       push];
   runtime.caml_register_global
    (20, Async_kernel_Stack_or_counter, cst_Async_kernel_Stack_or_coun$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Throttle
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Stack_or_counter, Base__Field, Core, Core__Int, Core__List, Core__Queue, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Aborted = "Aborted",
    cst_Async_kernel_Throttle$0 = "Async_kernel__Throttle",
    cst_Ok = "Ok",
    cst_Raised = "Raised",
    cst_async_kernel$0 = "async_kernel",
    cst_capacity_available$0 = "capacity_available",
    cst_cleaned$0 = "cleaned",
    cst_job_resources_not_in_use$0 = "job_resources_not_in_use",
    cst_jobs_waiting_to_start$0 = "jobs_waiting_to_start",
    cst_max_concurrent_jobs$0 = "max_concurrent_jobs",
    cst_num_jobs_running$0 = "num_jobs_running",
    cst_num_resources_not_cleaned$0 = "num_resources_not_cleaned",
    cst_src_throttle_ml = "src/throttle.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Stack_or_counter = global_data.Async_kernel__Stack_or_counter,
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core = global_data.Core,
    Core_Int = global_data.Core__Int,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core_List = global_data.Core__List,
    Base_Field = global_data.Base__Field,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Throttle$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_throttle_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "throttle.ml");
   var
    _aa_ = [0, cst_src_throttle_ml, 171, 2],
    _ac_ = [0, cst_src_throttle_ml, 172, 2],
    _ab_ = [0, cst_src_throttle_ml, 173, 2],
    cst_enqueue_exclusive_was_call =
      "[enqueue_exclusive] was called with a very large value of [max_concurrent_jobs]. This doesn't work.",
    _ae_ = [0, cst_src_throttle_ml, 292, 2],
    cst_throttle_aborted_job = "throttle aborted job",
    _ad_ = [0, cst_max_concurrent_jobs$0],
    cst_Throttle_create_requires_p =
      "Throttle.create requires positive max_concurrent_jobs, but got",
    _O_ = [0, "_"],
    _P_ = [0, "t"],
    _Q_ = [0, "exn"],
    cst_Throttle_invariant_failed = "Throttle.invariant failed",
    _$_ = [0, cst_src_throttle_ml, 102, 43],
    ___ = [0, cst_src_throttle_ml, 106, 11],
    _Z_ = [0, cst_src_throttle_ml, 111, 29],
    _Y_ = [0, cst_src_throttle_ml, 114, 11],
    _X_ = [0, cst_src_throttle_ml, 115, 11],
    _W_ = [0, cst_src_throttle_ml, 117, 16],
    _V_ = [0, cst_src_throttle_ml, 121, 25],
    _U_ = [0, cst_src_throttle_ml, 126, 11],
    _T_ = [0, cst_src_throttle_ml, 127, 11],
    _S_ = [0, cst_src_throttle_ml, 128, 69],
    _R_ = [0, cst_src_throttle_ml, 131, 40],
    _A_ = [0, cst_cleaned$0],
    _B_ = [0, cst_num_resources_not_cleaned$0],
    _C_ = [0, "cleans"],
    _D_ = [0, "is_dead"],
    _E_ = [0, cst_capacity_available$0],
    _F_ = [0, cst_num_jobs_running$0],
    _G_ = [0, cst_jobs_waiting_to_start$0],
    _H_ = [0, cst_job_resources_not_in_use$0],
    _I_ = [0, cst_max_concurrent_jobs$0],
    _J_ = [0, "Log"],
    _M_ = [0, "Raise"],
    _N_ = [0, "Call"],
    _K_ = [0, "rest"],
    _L_ = [0, "continue_on_error"],
    _l_ = [0, cst_src_throttle_ml, 55, 18],
    _k_ = [0, 523273847],
    _h_ = [0, "Abort"],
    _i_ = [0, "Start"],
    _e_ = [0, cst_Ok],
    _f_ = [0, cst_Raised],
    _d_ = [0, cst_Aborted],
    _g_ = [0, "outcome"],
    _j_ = [0, "start"],
    _a_ = [0, cst_Aborted],
    _b_ = [0, cst_Ok],
    _c_ = [0, cst_Raised],
    cst_cleaned = cst_cleaned$0,
    cst_num_resources_not_cleaned = cst_num_resources_not_cleaned$0,
    cst_capacity_available = cst_capacity_available$0,
    cst_num_jobs_running = cst_num_jobs_running$0,
    cst_jobs_waiting_to_start = cst_jobs_waiting_to_start$0,
    cst_job_resources_not_in_use = cst_job_resources_not_in_use$0,
    cst_max_concurrent_jobs = cst_max_concurrent_jobs$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Throttle = cst_Async_kernel_Throttle$0;
   function sexp_of_outcome(of_a_001, param){
    if(typeof param === "number") return _a_;
    if(17724 <= param[1]){
     var v_002 = param[2];
     return [1, [0, _b_, [0, caml_call1(of_a_001, v_002), 0]]];
    }
    var v_003 = param[2];
    return [1, [0, _c_, [0, caml_call1(Core[625], v_003), 0]]];
   }
   function abort(t){
    return caml_call2(Async_kernel_Ivar[14], t[1], 774323088);
   }
   function cleaned(r){return r[11];}
   function num_resources_not_cleaned(r){return r[10];}
   function set_num_resources_not_cleaned(r, v){r[10] = v; return 0;}
   function is_dead(r){return r[8];}
   function capacity_available(r){return r[7];}
   function set_capacity_available(r, v){r[7] = v; return 0;}
   function num_jobs_running(r){return r[6];}
   function set_num_jobs_running(r, v){r[6] = v; return 0;}
   function jobs_waiting_to_start(r){return r[5];}
   function job_resources_not_in_use(r){return r[4];}
   function max_concurrent_jobs(r){return r[3];}
   function _m_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], v];
   }
   var
    _n_ = 0,
    cleaned$0 =
      [0, function(param){return 0;}, cst_cleaned, _n_, cleaned, _m_];
   function _o_(r, v){
    return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], v, r[11]];
   }
   var
    _p_ = [0, set_num_resources_not_cleaned],
    num_resources_not_cleaned$0 =
      [0,
       function(param){return 0;},
       cst_num_resources_not_cleaned,
       _p_,
       num_resources_not_cleaned,
       _o_];
   function _q_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            v,
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _r_ = [0, set_capacity_available],
    capacity_available$0 =
      [0,
       function(param){return 0;},
       cst_capacity_available,
       _r_,
       capacity_available,
       _q_];
   function _s_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _t_ = [0, set_num_jobs_running],
    num_jobs_running$0 =
      [0,
       function(param){return 0;},
       cst_num_jobs_running,
       _t_,
       num_jobs_running,
       _s_];
   function _u_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _v_ = 0,
    jobs_waiting_to_start$0 =
      [0,
       function(param){return 0;},
       cst_jobs_waiting_to_start,
       _v_,
       jobs_waiting_to_start,
       _u_];
   function _w_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _x_ = 0,
    job_resources_not_in_use$0 =
      [0,
       function(param){return 0;},
       cst_job_resources_not_in_use,
       _x_,
       job_resources_not_in_use,
       _w_];
   function _y_(r, v){
    return [0,
            r[1],
            r[2],
            v,
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11]];
   }
   var
    _z_ = 0,
    max_concurrent_jobs$0 =
      [0,
       function(param){return 0;},
       cst_max_concurrent_jobs,
       _z_,
       max_concurrent_jobs,
       _y_];
   function sexp_of_t(of_a_011, param){
    var
     jobs_waiting_to_start_022 = param[5],
     job_resources_not_in_use_020 = param[4],
     max_concurrent_jobs_018 = param[3],
     rest_015 = param[2],
     continue_on_error_013 = param[1],
     num_jobs_running_024 = param[6],
     capacity_available_026 = param[7],
     is_dead_028 = param[8],
     cleans_030 = param[9],
     num_resources_not_cleaned_032 = param[10],
     cleaned_034 = param[11],
     arg_035 = caml_call2(Async_kernel_Ivar[9], Core[620], cleaned_034),
     bnds_012 = [0, [1, [0, _A_, [0, arg_035, 0]]], 0],
     arg_033 = caml_call1(Core[389], num_resources_not_cleaned_032),
     bnds_012$0 = [0, [1, [0, _B_, [0, arg_033, 0]]], bnds_012];
    function _a8_(param){
     function _be_(_bf_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _be_);
    }
    var
     arg_031 = caml_call2(Core[472], _a8_, cleans_030),
     bnds_012$1 = [0, [1, [0, _C_, [0, arg_031, 0]]], bnds_012$0],
     arg_029 = caml_call1(Core[323], is_dead_028),
     bnds_012$2 = [0, [1, [0, _D_, [0, arg_029, 0]]], bnds_012$1],
     _a9_ = caml_call1(Async_kernel_Ivar[9], Core[620]),
     arg_027 = caml_call2(Core[515], _a9_, capacity_available_026),
     bnds_012$3 = [0, [1, [0, _E_, [0, arg_027, 0]]], bnds_012$2],
     arg_025 = caml_call1(Core[389], num_jobs_running_024),
     bnds_012$4 = [0, [1, [0, _F_, [0, arg_025, 0]]], bnds_012$3];
    function _a__(param){
     var outcome_009 = param[2], start_006 = param[1], bnds_005 = 0;
     function _bc_(param){
      return -216426513 === param ? _d_ : 17724 <= param ? _e_ : _f_;
     }
     var
      arg_010 = caml_call2(Async_kernel_Deferred1[1], _bc_, outcome_009),
      bnds_005$0 = [0, [1, [0, _g_, [0, arg_010, 0]]], bnds_005];
     function _bd_(param){
      if(typeof param === "number") return _h_;
      var v_008 = param[2];
      return [1, [0, _i_, [0, caml_call1(of_a_011, v_008), 0]]];
     }
     var
      arg_007 = caml_call2(Async_kernel_Ivar[9], _bd_, start_006),
      bnds_005$1 = [0, [1, [0, _j_, [0, arg_007, 0]]], bnds_005$0];
     return [1, bnds_005$1];
    }
    var
     arg_023 = caml_call2(Core_Queue[13], _a__, jobs_waiting_to_start_022),
     bnds_012$5 = [0, [1, [0, _G_, [0, arg_023, 0]]], bnds_012$4],
     arg_021 =
       caml_call2
        (Async_kernel_Stack_or_counter[1],
         of_a_011,
         job_resources_not_in_use_020),
     bnds_012$6 = [0, [1, [0, _H_, [0, arg_021, 0]]], bnds_012$5],
     arg_019 = caml_call1(Core[389], max_concurrent_jobs_018),
     bnds_012$7 = [0, [1, [0, _I_, [0, arg_019, 0]]], bnds_012$6];
    if(typeof rest_015 === "number")
     var arg_016 = 3804260 <= rest_015 ? _J_ : _M_;
    else
     var
      _a$_ = 0,
      _ba_ = function(_bb_){return 0;},
      arg_016 =
        [1, [0, _N_, [0, caml_call1(Sexplib0_Sexp_conv[24], _ba_), _a$_]]];
    var
     bnds_012$8 = [0, [1, [0, _K_, [0, arg_016, 0]]], bnds_012$7],
     arg_014 = caml_call1(Core[323], continue_on_error_013),
     bnds_012$9 = [0, [1, [0, _L_, [0, arg_014, 0]]], bnds_012$8];
    return [1, bnds_012$9];
   }
   function invariant(invariant_a, x_036){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, x_036));
        },
      _aV_ =
        function(cleaned){
         var _a7_ = caml_call1(Async_kernel_Ivar[18], cleaned);
         if(! _a7_) return _a7_;
         if(caml_call2(Async_kernel_Import[3], x_036[10], 0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _R_], 1);
        },
      _aW_ =
        function(num_resources_not_cleaned){
         if
          (! caml_call2(Async_kernel_Import[1], num_resources_not_cleaned, 0))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _U_], 1);
         if
          (!
           caml_call2
            (Async_kernel_Import[2], num_resources_not_cleaned, x_036[3]))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
         var
          _a6_ =
            caml_call2
             (Async_kernel_Import[5], num_resources_not_cleaned, x_036[3]);
         if(! _a6_) return _a6_;
         if(x_036[8]) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _S_], 1);
        },
      _aX_ =
        function(param){
         if(! param) return 0;
         var ivar = param[1];
         if(caml_call1(Async_kernel_Ivar[17], ivar)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
        },
      _aY_ =
        function(num_jobs_running){
         if(! caml_call2(Async_kernel_Import[1], num_jobs_running, 0))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _Y_], 1);
         if(! caml_call2(Async_kernel_Import[2], num_jobs_running, x_036[3]))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
         var
          _a5_ =
            caml_call2(Async_kernel_Import[5], num_jobs_running, x_036[3]);
         if(! _a5_) return _a5_;
         if(caml_call1(Core_Queue[17], x_036[5])) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
        },
      _aZ_ =
        function(jobs_waiting_to_start){
         var _a4_ = x_036[8];
         if(! _a4_) return _a4_;
         if(caml_call1(Core_Queue[17], jobs_waiting_to_start)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _Z_], 1);
        },
      _a0_ =
        function(job_resources_not_in_use){
         caml_call2
          (Async_kernel_Stack_or_counter[4],
           job_resources_not_in_use,
           invariant_a);
         var
          _a2_ = x_036[8] ? 0 : x_036[3] - x_036[6] | 0,
          _a3_ =
            caml_call1
             (Async_kernel_Stack_or_counter[5], job_resources_not_in_use);
         if(caml_call2(Async_kernel_Import[3], _a3_, _a2_)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, ___], 1);
        };
     check
      (function(max_concurrent_jobs){
        if(caml_call2(Async_kernel_Import[4], max_concurrent_jobs, 0))
         return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _$_], 1);
       },
       max_concurrent_jobs$0);
     check(_a0_, job_resources_not_in_use$0);
     check(_aZ_, jobs_waiting_to_start$0);
     check(_aY_, num_jobs_running$0);
     check(_aX_, capacity_available$0);
     check(_aW_, num_resources_not_cleaned$0);
     var _a1_ = check(_aV_, cleaned$0);
     return _a1_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _aQ_ = 0,
      _aR_ = 0,
      _aS_ =
        [0,
         [1,
          [0, _P_, [0, sexp_of_t(function(param){return _O_;}, x_036), _aR_]]],
         _aQ_],
      _aT_ = [0, [1, [0, _Q_, [0, caml_call1(Core[625], exn), 0]]], _aS_],
      _aU_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Throttle_invariant_failed),
          _aT_]];
     return caml_call1(Core[261], _aU_);
    }
   }
   function sexp_of_t$0(of_a_037, of_kind_038, x_039){return sexp_of_t(of_a_037, x_039);
   }
   function invariant$0(invariant_a, param, t){return invariant(invariant_a, t);
   }
   var T2 = [0, sexp_of_t$0, invariant$0];
   function num_jobs_waiting_to_start(t){
    return caml_call1(Core_Queue[16], t[5]);
   }
   function clean_resource(t, a){
    function _aL_(param){
     t[10] = t[10] - 1 | 0;
     var _aP_ = caml_call2(Async_kernel_Import[3], t[10], 0);
     return _aP_ ? caml_call2(Async_kernel_Ivar[14], t[11], 0) : _aP_;
    }
    function _aM_(f){return caml_call1(f, a);}
    var
     _aN_ = caml_call2(Core_List[51], t[9], _aM_),
     _aO_ = caml_call1(Async_kernel_Deferred1[45], _aN_);
    return caml_call2(Async_kernel_Deferred_std[1], _aO_, _aL_);
   }
   function kill(t){
    var _aJ_ = 1 - t[8];
    if(! _aJ_) return _aJ_;
    t[8] = 1;
    caml_call2(Core_Queue[18], t[5], abort);
    caml_call1(Core_Queue[51], t[5]);
    function _aK_(a){return clean_resource(t, a);}
    caml_call2(Async_kernel_Stack_or_counter[4], t[4], _aK_);
    return caml_call1(Async_kernel_Stack_or_counter[2], t[4]);
   }
   function at_kill(t, f){
    var
     _aI_ = caml_call1(Async_kernel_Monitor[26][8], f),
     f$0 = caml_call1(Core[267], _aI_);
    t[9] = [0, f$0, t[9]];
    return 0;
   }
   function cleaned$1(t){return caml_call1(Async_kernel_Ivar[19], t[11]);}
   function start_job(t){
    if(t[8]) throw caml_maybe_attach_backtrace([0, Assert_failure, _aa_], 1);
    if(! caml_call2(Async_kernel_Import[5], t[6], t[3]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ac_], 1);
    if(caml_call1(Core_Queue[17], t[5]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ab_], 1);
    var job = caml_call1(Core_Queue[46], t[5]);
    t[6] = t[6] + 1 | 0;
    var job_resource = caml_call1(Async_kernel_Stack_or_counter[7], t[4]);
    function _aH_(res){
     t[6] = t[6] - 1 | 0;
     if(17724 > res && 1 - t[1]) kill(t);
     if(t[8]) return clean_resource(t, job_resource);
     caml_call2(Async_kernel_Stack_or_counter[8], t[4], job_resource);
     if(! caml_call1(Core_Queue[17], t[5])) return start_job(t);
     var match = t[7];
     if(! match) return 0;
     var ivar = match[1];
     caml_call2(Async_kernel_Ivar[14], ivar, 0);
     t[7] = 0;
     return 0;
    }
    caml_call2(Async_kernel_Ivar[14], job[1], [0, 389604418, job_resource]);
    function _aF_(x){
     if(-216426513 === x)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     return x;
    }
    var _aG_ = caml_call2(Async_kernel_Deferred_std[5][2], job[2], _aF_);
    return caml_call2(Async_kernel_Deferred_std[1], _aG_, _aH_);
   }
   function create_internal(continue_on_error, rest, job_resources){
    var
     max_concurrent_jobs =
       caml_call1(Async_kernel_Stack_or_counter[5], job_resources),
     _aE_ = caml_call1(Async_kernel_Ivar[12], 0);
    return [0,
            continue_on_error,
            rest,
            max_concurrent_jobs,
            job_resources,
            caml_call2(Core_Queue[66], 0, 0),
            0,
            0,
            0,
            0,
            max_concurrent_jobs,
            _aE_];
   }
   function create_with(rest, continue_on_error, job_resources){
    return create_internal
            (continue_on_error,
             rest,
             caml_call1(Async_kernel_Stack_or_counter[6], job_resources));
   }
   function create_with$0(continue_on_error, job_resources){
    return create_with(3804260, continue_on_error, job_resources);
   }
   function create(opt, _aD_, a){
    if(opt) var sth = opt[1], rest = sth; else var rest = 3804260;
    if(_aD_)
     var sth$0 = _aD_[1], continue_on_error = sth$0;
    else
     var continue_on_error = 0;
    return create_with(rest, continue_on_error, [0, a, 0]);
   }
   var Sequencer = [0, sexp_of_t, create];
   function create$0(rest, continue_on_error, max_concurrent_jobs){
    if(caml_call2(Async_kernel_Import[2], max_concurrent_jobs, 0)){
     var
      _aB_ =
        [0,
         [1, [0, _ad_, [0, caml_call1(Core[389], max_concurrent_jobs), 0]]],
         0],
      _aC_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Throttle_create_requires_p),
          _aB_]];
     caml_call1(Core[261], _aC_);
    }
    return create_internal
            (continue_on_error,
             rest,
             caml_call1(Async_kernel_Stack_or_counter[3], max_concurrent_jobs));
   }
   function create$1(continue_on_error, max_concurrent_jobs){
    return create$0(3804260, continue_on_error, max_concurrent_jobs);
   }
   function enqueue_internal(t, work, enqueue){
    var rest = t[2], start = caml_call1(Async_kernel_Ivar[12], 0);
    function _av_(param){
     if(typeof param === "number")
      return caml_call1(Async_kernel_Deferred_std[10], -216426513);
     var a = param[2];
     function _ay_(param){
      if(0 === param[0]){var a = param[1]; return [0, 17724, a];}
      var exn = param[1];
      return [0, -387916264, exn];
     }
     function _az_(param){return caml_call1(work, a);}
     var
      _aA_ =
        caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _k_, [0, rest], _az_);
     return caml_call2(Async_kernel_Deferred_std[5][2], _aA_, _ay_);
    }
    var
     _aw_ = caml_call1(Async_kernel_Ivar[19], start),
     result = caml_call2(Async_kernel_Deferred_std[5][1], _aw_, _av_);
    function _ax_(param){
     return typeof param === "number"
             ? -216426513
             : 17724 <= param[1] ? 17724 : -387916264;
    }
    var
     outcome = caml_call2(Async_kernel_Deferred_std[5][2], result, _ax_),
     internal_job = [0, start, outcome];
    if(t[8])
     abort(internal_job);
    else{
     caml_call2(enqueue, t[5], internal_job);
     if(caml_call2(Async_kernel_Import[5], t[6], t[3])) start_job(t);
    }
    return result;
   }
   function handle_enqueue_result(result){
    if(typeof result === "number"){
     var _au_ = caml_call1(Sexplib0_Sexp_conv[7], cst_throttle_aborted_job);
     return caml_call1(Core[261], _au_);
    }
    if(17724 <= result[1]){var a = result[2]; return a;}
    var exn = result[2];
    throw caml_maybe_attach_backtrace(exn, 0);
   }
   function enqueue(t, f){return enqueue_internal(t, f, Core_Queue[43]);}
   function enqueue$0(t, f){
    var _at_ = enqueue(t, f);
    return caml_call2
            (Async_kernel_Deferred_std[4], _at_, handle_enqueue_result);
   }
   function enqueue_front(t, f){
    return enqueue_internal(t, f, Core_Queue[69]);
   }
   function enqueue_front$0(t, f){
    var _as_ = enqueue_front(t, f);
    return caml_call2
            (Async_kernel_Deferred_std[4], _as_, handle_enqueue_result);
   }
   function enqueue_exclusive(t, f){
    var n = t[3];
    if(caml_call2(Core_Int[81], n, 1000000)){
     var
      _al_ = caml_call1(Sexplib0_Sexp_conv[7], cst_enqueue_exclusive_was_call);
     caml_call1(Core[261], _al_);
    }
    var done = caml_call1(Async_kernel_Ivar[12], 0);
    if(! caml_call2(Async_kernel_Import[4], n, 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ae_], 1);
    function f_placeholder(slot){
     return caml_call1(Async_kernel_Ivar[19], done);
    }
    var _an_ = n - 1 | 0, _am_ = 1;
    if(_an_ >= 1){
     var for$0 = _am_;
     for(;;){
      var _aq_ = enqueue$0(t, f_placeholder);
      caml_call1(Async_kernel_Deferred_std[8], _aq_);
      var _ar_ = for$0 + 1 | 0;
      if(_an_ === for$0) break;
      var for$0 = _ar_;
     }
    }
    function _ao_(result){
     caml_call2(Async_kernel_Ivar[14], done, 0);
     return handle_enqueue_result(result);
    }
    var _ap_ = enqueue(t, function(slot){return caml_call1(f, 0);});
    return caml_call2(Async_kernel_Deferred_std[5][2], _ap_, _ao_);
   }
   function monad_sequence_how(how, f){
    a:
    {
     if(typeof how === "number" && -676829465 <= how){var f$0 = f; break a;}
     if(typeof how === "number")
      var max_concurrent_jobs = 1;
     else
      var
       max_concurrent_jobs$0 = how[2],
       max_concurrent_jobs = max_concurrent_jobs$0;
     var
      t = create$1(0, max_concurrent_jobs),
      f$0 =
        function(a){
         return enqueue$0(t, function(param){return caml_call1(f, a);});
        };
    }
    return caml_call1(Core[266], f$0);
   }
   function monad_sequence_how2(how, f){
    a:
    {
     if(typeof how === "number" && -676829465 <= how){var f$0 = f; break a;}
     if(typeof how === "number")
      var max_concurrent_jobs = 1;
     else
      var
       max_concurrent_jobs$0 = how[2],
       max_concurrent_jobs = max_concurrent_jobs$0;
     var
      t = create$1(0, max_concurrent_jobs),
      f$0 =
        function(a1, a2){
         return enqueue$0(t, function(param){return caml_call2(f, a1, a2);});
        };
    }
    return caml_call1(Core[266], f$0);
   }
   function prior_jobs_done(t){
    function _ag_(all_dummy_jobs_running){
     var dummy_jobs_running = [0, 0], _ai_ = t[3], _ah_ = 1;
     if(_ai_ >= 1){
      var for$0 = _ah_;
      for(;;){
       var
        _aj_ =
          enqueue$0
           (t,
            function(param){
             dummy_jobs_running[1]++;
             if
              (caml_call2(Async_kernel_Import[3], dummy_jobs_running[1], t[3]))
              caml_call2(Async_kernel_Ivar[14], all_dummy_jobs_running, 0);
             return caml_call1(Async_kernel_Ivar[19], all_dummy_jobs_running);
            });
       caml_call1(Async_kernel_Deferred_std[8], _aj_);
       var _ak_ = for$0 + 1 | 0;
       if(_ai_ === for$0) break;
       var for$0 = _ak_;
      }
     }
     return 0;
    }
    return caml_call1(Async_kernel_Deferred1[4], _ag_);
   }
   function capacity_available$1(t){
    if(caml_call2(Async_kernel_Import[5], t[6], t[3]))
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    var match = t[7];
    if(match){
     var ivar = match[1];
     return caml_call1(Async_kernel_Ivar[19], ivar);
    }
    function _af_(ivar){t[7] = [0, ivar]; return 0;}
    return caml_call1(Async_kernel_Deferred1[4], _af_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Throttle);
   var
    Async_kernel_Throttle =
      [0,
       T2,
       sexp_of_t,
       invariant,
       create$0,
       create$1,
       create_with,
       create_with$0,
       sexp_of_outcome,
       enqueue,
       enqueue$0,
       enqueue_front,
       enqueue_front$0,
       enqueue_exclusive,
       monad_sequence_how,
       monad_sequence_how2,
       prior_jobs_done,
       max_concurrent_jobs,
       num_jobs_running,
       num_jobs_waiting_to_start,
       capacity_available$1,
       kill,
       is_dead,
       at_kill,
       cleaned$1,
       Sequencer];
   runtime.caml_register_global
    (84, Async_kernel_Throttle, cst_Async_kernel_Throttle$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Synchronous_time_source
//# unitInfo: Requires: Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Types, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Synchronous_t = "Async_kernel__Synchronous_time_source",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Types = global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Synchronous_t);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/synchronous_time_source.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel, "synchronous_time_source.ml");
   var
    default_timing_wheel_config = Async_kernel_Synchronous_time_[3],
    T1 = Async_kernel_Synchronous_time_[4],
    sexp_of_t = Async_kernel_Synchronous_time_[5],
    invariant = Async_kernel_Synchronous_time_[6],
    invariant_with_jobs = Async_kernel_Synchronous_time_[7],
    Read_write = Async_kernel_Synchronous_time_[8],
    id = Async_kernel_Synchronous_time_[9],
    is_wall_clock = Async_kernel_Synchronous_time_[10],
    length = Async_kernel_Synchronous_time_[11],
    max_allowed_alarm_time = Async_kernel_Synchronous_time_[12],
    read_only = Async_kernel_Synchronous_time_[13],
    alarm_precision = Async_kernel_Synchronous_time_[15],
    next_alarm_fires_at = Async_kernel_Synchronous_time_[16],
    next_alarm_runs_at = Async_kernel_Synchronous_time_[17],
    now = Async_kernel_Synchronous_time_[18],
    timing_wheel_now = Async_kernel_Synchronous_time_[19],
    Event = Async_kernel_Synchronous_time_[22],
    run_after = Async_kernel_Synchronous_time_[23],
    run_at = Async_kernel_Synchronous_time_[24],
    run_at_intervals = Async_kernel_Synchronous_time_[25],
    advance_by_alarms = Async_kernel_Synchronous_time_[35],
    advance_by_alarms_by = Async_kernel_Synchronous_time_[36],
    advance_by_max_alarms_in_each_ = Async_kernel_Synchronous_time_[37],
    advance_directly = Async_kernel_Synchronous_time_[38],
    advance_directly_by = Async_kernel_Synchronous_time_[39],
    duration_of = Async_kernel_Synchronous_time_[40],
    max_alarm_time_in_min_timing_w = Async_kernel_Synchronous_time_[41],
    has_events_to_run = Async_kernel_Synchronous_time_[42],
    create = Async_kernel_Scheduler1[81],
    wall_clock = Async_kernel_Scheduler1[82];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Synchronous_t);
   var
    _a_ = Event[3],
    Async_kernel_Synchronous_time_$0 =
      [0,
       [0, T1[17]],
       Read_write,
       Async_kernel_Types[21],
       sexp_of_t,
       invariant_with_jobs,
       invariant,
       id,
       read_only,
       create,
       alarm_precision,
       is_wall_clock,
       now,
       timing_wheel_now,
       run_at,
       run_after,
       run_at_intervals,
       max_allowed_alarm_time,
       duration_of,
       [0,
        Event[17],
        Event[18],
        [0,
         _a_[9],
         _a_[2],
         _a_[3],
         _a_[4],
         _a_[5],
         _a_[10],
         _a_[11],
         _a_[12],
         _a_[13],
         _a_[8]],
        Event[25],
        Event[26],
        Event[28],
        Event[29],
        Event[30],
        Event[32],
        Event[31],
        Event[33],
        Event[34],
        Event[36],
        Event[37],
        Event[39],
        Event[38],
        Event[40],
        Event[41],
        Event[21]],
       default_timing_wheel_config,
       wall_clock,
       length,
       next_alarm_runs_at,
       next_alarm_fires_at,
       advance_by_alarms,
       advance_by_alarms_by,
       advance_by_max_alarms_in_each_,
       advance_directly,
       advance_directly_by,
       max_alarm_time_in_min_timing_w,
       has_events_to_run];
   runtime.caml_register_global
    (14, Async_kernel_Synchronous_time_$0, cst_Async_kernel_Synchronous_t);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_kernel_scheduler
//# unitInfo: Requires: Async_kernel__Scheduler, Async_kernel__Time_ns, Base__Staged, Core, Core__Time_ns, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_kernel_$0 = "Async_kernel__Async_kernel_scheduler",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Staged = global_data.Base__Staged,
    Core = global_data.Core,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_kernel_$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/async_kernel_scheduler.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "async_kernel_scheduler.ml");
   var
    t = Async_kernel_Scheduler[2],
    with_execution_context = Async_kernel_Scheduler[5],
    with_execution_context1 = Async_kernel_Scheduler[6],
    set_execution_context = Async_kernel_Scheduler[7],
    enqueue = Async_kernel_Scheduler[8],
    run_cycles_until_no_jobs_remai = Async_kernel_Scheduler[15],
    last_cycle_num_jobs = Async_kernel_Scheduler[24],
    map_cycle_times = Async_kernel_Scheduler[25],
    run_every_cycle_start = Async_kernel_Scheduler[37],
    run_every_cycle_end = Async_kernel_Scheduler[38],
    add_every_cycle_start_hook = Async_kernel_Scheduler[39],
    add_every_cycle_end_hook = Async_kernel_Scheduler[40],
    remove_every_cycle_start_hook_ = Async_kernel_Scheduler[41],
    remove_every_cycle_end_hook_ex = Async_kernel_Scheduler[42],
    thread_safe_enqueue_external_j = Async_kernel_Scheduler[55],
    within = Async_kernel_Scheduler[57],
    within$0 = Async_kernel_Scheduler[58],
    within_v = Async_kernel_Scheduler[59],
    schedule = Async_kernel_Scheduler[60],
    schedule$0 = Async_kernel_Scheduler[61],
    preserve_execution_context = Async_kernel_Scheduler[62],
    preserve_execution_context$0 = Async_kernel_Scheduler[63],
    within_context = Async_kernel_Scheduler[64],
    find_local = Async_kernel_Scheduler[65],
    with_local = Async_kernel_Scheduler[66],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_kernel_ = cst_Async_kernel_Async_kernel_$0,
    _a_ = Async_kernel_Scheduler[4],
    _b_ = Async_kernel_Scheduler[13],
    _c_ = Async_kernel_Scheduler[19],
    _d_ = Async_kernel_Scheduler[22],
    _e_ = Async_kernel_Scheduler[23],
    _f_ = Async_kernel_Scheduler[27],
    _g_ = Async_kernel_Scheduler[28],
    _h_ = Async_kernel_Scheduler[29],
    _i_ = Async_kernel_Scheduler[30],
    _j_ = Async_kernel_Scheduler[35],
    _k_ = Async_kernel_Scheduler[36],
    _l_ = Async_kernel_Scheduler[43],
    _m_ = Async_kernel_Scheduler[44],
    _n_ = Async_kernel_Scheduler[56],
    _o_ = Async_kernel_Scheduler[69],
    _p_ = Async_kernel_Scheduler[70],
    _q_ = Async_kernel_Scheduler[71];
   function enqueue_job(execution_context, f, a){
    return caml_call4(enqueue, caml_call1(t, 0), execution_context, f, a);
   }
   function thread_safe_enqueue_job(execution_context, f, a){
    return caml_call4
            (thread_safe_enqueue_external_j,
             caml_call1(t, 0),
             execution_context,
             f,
             a);
   }
   function current_execution_context(param){
    return caml_call1(_a_, caml_call1(t, 0));
   }
   function cycle_count(param){return caml_call1(_f_, caml_call1(t, 0));}
   function cycle_start_ns(param){return caml_call1(_b_, caml_call1(t, 0));}
   function cycle_start(param){
    var _x_ = cycle_start_ns(0);
    return caml_call1(Async_kernel_Time_ns[68], _x_);
   }
   function cycle_times_ns(param){
    function _v_(_w_){return _w_;}
    return caml_call2(map_cycle_times, caml_call1(t, 0), _v_);
   }
   function cycle_times(param){
    var _u_ = Core_Time_ns[1][144];
    return caml_call2(map_cycle_times, caml_call1(t, 0), _u_);
   }
   function total_cycle_time(param){return caml_call1(_g_, caml_call1(t, 0));}
   function last_cycle_time(param){return caml_call1(_l_, caml_call1(t, 0));}
   function long_cycles(at_least){
    return caml_call2(_m_, caml_call1(t, 0), at_least);
   }
   function event_precision_ns(param){
    return caml_call1(_c_, caml_call1(t, 0));
   }
   function event_precision(param){
    var _t_ = event_precision_ns(0);
    return caml_call1(Core_Time_ns[1][144], _t_);
   }
   function set_max_num_jobs_per_priority_(i){
    return caml_call2(_i_, caml_call1(t, 0), i);
   }
   function max_num_jobs_per_priority_per_(param){return caml_call1(_h_, caml_call1(t, 0));
   }
   function set_record_backtraces(bool){
    return caml_call2(_k_, caml_call1(t, 0), bool);
   }
   function recording_backtraces(param){
    return caml_call1(_j_, caml_call1(t, 0));
   }
   function force_current_cycle_to_end(param){return caml_call1(_n_, caml_call1(t, 0));
   }
   function yield$0(param){return caml_call1(_o_, caml_call1(t, 0));}
   function yield_until_no_jobs_remain(may_return_immediately, param){return caml_call2(_q_, may_return_immediately, caml_call1(t, 0));
   }
   function yield_every(n){
    var
     _r_ = caml_call1(_p_, n),
     yield_every = caml_call1(Base_Staged[2], _r_),
     t$0 = caml_call1(t, 0);
    function _s_(param){return caml_call1(yield_every, t$0);}
    return caml_call1(Core[266], _s_);
   }
   function num_jobs_run(param){return caml_call1(_e_, caml_call1(t, 0));}
   function num_pending_jobs(param){return caml_call1(_d_, caml_call1(t, 0));}
   function set_execution_context$0(context){
    return caml_call2(set_execution_context, caml_call1(t, 0), context);
   }
   function last_cycle_num_jobs$0(param){
    return caml_call1(last_cycle_num_jobs, caml_call1(t, 0));
   }
   function run_every_cycle_start$0(f){
    return caml_call2(run_every_cycle_start, caml_call1(t, 0), f);
   }
   function run_every_cycle_end$0(f){
    return caml_call2(run_every_cycle_end, caml_call1(t, 0), f);
   }
   function add_every_cycle_start_hook$0(f){
    return caml_call2(add_every_cycle_start_hook, caml_call1(t, 0), f);
   }
   function add_every_cycle_end_hook$0(f){
    return caml_call2(add_every_cycle_end_hook, caml_call1(t, 0), f);
   }
   function remove_every_cycle_start_hook_$0(handle){
    return caml_call2
            (remove_every_cycle_start_hook_, caml_call1(t, 0), handle);
   }
   function remove_every_cycle_end_hook_ex$0(handle){
    return caml_call2
            (remove_every_cycle_end_hook_ex, caml_call1(t, 0), handle);
   }
   function with_execution_context$0(execution_context, f){
    return caml_call3
            (with_execution_context, caml_call1(t, 0), execution_context, f);
   }
   function with_execution_context1$0(execution_context, f, x){
    return caml_call4
            (with_execution_context1,
             caml_call1(t, 0),
             execution_context,
             f,
             x);
   }
   var
    Expert =
      [0,
       set_execution_context$0,
       run_cycles_until_no_jobs_remai,
       last_cycle_num_jobs$0,
       run_every_cycle_start$0,
       run_every_cycle_end$0,
       add_every_cycle_start_hook$0,
       add_every_cycle_end_hook$0,
       remove_every_cycle_start_hook_$0,
       remove_every_cycle_end_hook_ex$0,
       with_execution_context$0,
       with_execution_context1$0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_kernel_);
   var
    Async_kernel_Async_kernel_sche =
      [0,
       current_execution_context,
       within_context,
       within,
       within$0,
       within_v,
       with_local,
       find_local,
       schedule,
       schedule$0,
       enqueue_job,
       thread_safe_enqueue_job,
       preserve_execution_context,
       preserve_execution_context$0,
       cycle_start,
       cycle_start_ns,
       cycle_times,
       cycle_times_ns,
       last_cycle_time,
       long_cycles,
       cycle_count,
       total_cycle_time,
       event_precision,
       event_precision_ns,
       force_current_cycle_to_end,
       set_max_num_jobs_per_priority_,
       max_num_jobs_per_priority_per_,
       set_record_backtraces,
       recording_backtraces,
       yield$0,
       yield_until_no_jobs_remain,
       yield_every,
       num_jobs_run,
       num_pending_jobs,
       Expert];
   runtime.caml_register_global
    (16, Async_kernel_Async_kernel_sche, cst_Async_kernel_Async_kernel_$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Clock_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Clock_intf$0 = "Async_kernel__Clock_intf",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Clock_intf$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/clock_intf.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "clock_intf.ml");
   var
    _a_ = [0, "Timeout"],
    _b_ = [0, "Result"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Clock_intf = cst_Async_kernel_Clock_intf$0;
   function compare(cmp_a, a_001, b_002){
    if(a_001 === b_002) return 0;
    if(typeof a_001 === "number"){
     if(typeof b_002 === "number" && 642269825 === b_002) return 0;
    }
    else if(typeof b_002 !== "number" && 1025039613 === b_002[1]){
     var right_004 = b_002[2], left_003 = a_001[2];
     return caml_call2(cmp_a, left_003, right_004);
    }
    return runtime.caml_compare(a_001, b_002);
   }
   function sexp_of_t(of_a_005, param){
    if(typeof param === "number") return _a_;
    var v_006 = param[2];
    return [1, [0, _b_, [0, caml_call1(of_a_005, v_006), 0]]];
   }
   var Or_timeout = [0, compare, sexp_of_t];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Clock_intf);
   var Async_kernel_Clock_intf = [0, Or_timeout];
   runtime.caml_register_global
    (13, Async_kernel_Clock_intf, cst_Async_kernel_Clock_intf$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Clock_ns
//# unitInfo: Requires: Async_kernel__Scheduler1, Async_kernel__Time_source, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Clock_ns$0 = "Async_kernel__Clock_ns",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Time_source = global_data.Async_kernel__Time_source,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Clock_ns$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/clock_ns.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "clock_ns.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Clock_ns = cst_Async_kernel_Clock_ns$0;
   function time_source(param){
    var _r_ = caml_call1(Async_kernel_Scheduler1[72], 0)[19];
    return caml_call1(Async_kernel_Time_source[40], _r_);
   }
   function after(span){
    var _q_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[29], _q_, span);
   }
   function at(time){
    var _p_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[28], _p_, time);
   }
   function at_varying_intervals(stop, compute_span){
    var _o_ = time_source(0);
    return caml_call3(Async_kernel_Time_source[34], stop, _o_, compute_span);
   }
   function at_intervals(start, stop, interval){
    var _n_ = time_source(0);
    return caml_call4
            (Async_kernel_Time_source[35], start, stop, _n_, interval);
   }
   function every(start, stop, continue_on_error, finished, span, f){
    var _m_ = time_source(0);
    return caml_call7
            (Async_kernel_Time_source[36],
             start,
             stop,
             continue_on_error,
             finished,
             _m_,
             span,
             f);
   }
   function every$0(start, stop, continue_on_error, span, f){
    var _l_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[37],
             start,
             stop,
             continue_on_error,
             _l_,
             span,
             f);
   }
   function run_after(span, f, a){
    var _k_ = time_source(0);
    return caml_call4(Async_kernel_Time_source[27], _k_, span, f, a);
   }
   function run_at(time, f, a){
    var _j_ = time_source(0);
    return caml_call4(Async_kernel_Time_source[26], _j_, time, f, a);
   }
   function run_at_intervals(start, stop, continue_on_error, interval, f){
    var _i_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[39],
             start,
             stop,
             continue_on_error,
             _i_,
             interval,
             f);
   }
   function run_at_intervals$0(start, stop, continue_on_error, interval, f){
    var _h_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[38],
             start,
             stop,
             continue_on_error,
             _h_,
             interval,
             f);
   }
   function with_timeout(span, d){
    var _g_ = time_source(0);
    return caml_call3(Async_kernel_Time_source[30], _g_, span, d);
   }
   function with_timeout_exn(span, d, error){
    var _f_ = time_source(0);
    return caml_call4(Async_kernel_Time_source[31], _f_, span, d, error);
   }
   function duration_of(f){
    var _e_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[32], _e_, f);
   }
   var
    include = Async_kernel_Time_source[33],
    sexp_of_t = include[1],
    sexp_of_t_unit = include[2],
    invariant = include[3],
    scheduled_at = include[4],
    Status = include[5],
    status = include[6],
    abort = include[10],
    abort_exn = include[11],
    abort_if_possible = include[12],
    fired = include[14],
    reschedule_at = include[16],
    reschedule_after = include[17],
    _a_ = include[7],
    _b_ = include[8],
    _c_ = include[18],
    _d_ = include[19];
   function after$0(span){return caml_call2(_d_, time_source(0), span);}
   function run_after$0(span, f, a){
    return caml_call4(_b_, time_source(0), span, f, a);
   }
   function at$0(time){return caml_call2(_c_, time_source(0), time);}
   function run_at$0(time, f, z){
    return caml_call4(_a_, time_source(0), time, f, z);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Clock_ns);
   var
    Async_kernel_Clock_ns =
      [0,
       run_at,
       run_after,
       at,
       after,
       with_timeout,
       with_timeout_exn,
       [0,
        sexp_of_t,
        sexp_of_t_unit,
        invariant,
        scheduled_at,
        Status,
        status,
        run_at$0,
        run_after$0,
        abort,
        abort_exn,
        abort_if_possible,
        fired,
        reschedule_at,
        reschedule_after,
        at$0,
        after$0],
       at_varying_intervals,
       at_intervals,
       every,
       every$0,
       run_at_intervals$0,
       run_at_intervals,
       duration_of];
   runtime.caml_register_global
    (13, Async_kernel_Clock_ns, cst_Async_kernel_Clock_ns$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_array
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttle, Core, Core__Array, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_arra$0 = "Async_kernel__Deferred_array",
    cst_async_kernel$0 = "async_kernel",
    caml_check_bound = runtime.caml_check_bound;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Array = global_data.Core__Array,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core = global_data.Core,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_arra$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_array.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_array.ml");
   var
    _b_ = [0, 0],
    _a_ = [0, 0],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_arra = cst_Async_kernel_Deferred_arra$0;
   function foldi(t, init, f){
    function _J_(result){
     function loop(i, b){
      if(caml_call2(Core[90], i, t.length - 1))
       return caml_call2(Async_kernel_Ivar[14], result, b);
      function _K_(b){return loop(i + 1 | 0, b);}
      var _L_ = caml_call3(f, i, b, caml_check_bound(t, i)[1 + i]);
      return caml_call2(Async_kernel_Deferred_std[1], _L_, _K_);
     }
     return loop(0, init);
    }
    return caml_call1(Async_kernel_Deferred1[4], _J_);
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function seqmapi(t, f){
    function _G_(result){
     function loop(i, output){
      if(caml_call2(Core[90], i, t.length - 1))
       return caml_call2(Async_kernel_Ivar[14], result, output);
      function _H_(b){
       var
        output$0 =
          caml_call2(Core[90], i, 0)
           ? caml_call2(Core_Array[63], t.length - 1, b)
           : output;
       caml_check_bound(output$0, i)[1 + i] = b;
       return loop(i + 1 | 0, output$0);
      }
      var _I_ = caml_call2(f, i, caml_check_bound(t, i)[1 + i]);
      return caml_call2(Async_kernel_Deferred_std[1], _I_, _H_);
     }
     return loop(0, [0]);
    }
    return caml_call1(Async_kernel_Deferred1[4], _G_);
   }
   function all(ds){return seqmapi(ds, function(param, x){return x;});}
   function all_unit(ds){
    var _F_ = fold(ds, 0, function(param, d){return d;});
    return caml_call1(Async_kernel_Deferred1[20], _F_);
   }
   function iteri(how, t, f){
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _D_ = caml_call2(Async_kernel_Throttle[15], how, f),
     _E_ = caml_call1(Core[267], _D_);
    return all_unit(caml_call2(Core_Array[57], t, _E_));
   }
   function mapi(how, t, f){
    if(typeof how === "number" && -676829465 > how) return seqmapi(t, f);
    var
     _B_ = caml_call2(Async_kernel_Throttle[15], how, f),
     _C_ = caml_call1(Core[267], _B_);
    return all(caml_call2(Core_Array[57], t, _C_));
   }
   function filteri(how, t, f){
    function _x_(bools){
     function _z_(ac, x, b){return b ? [0, x, ac] : ac;}
     var _A_ = caml_call4(Core_Array[93], t, bools, 0, _z_);
     return caml_call1(Core_Array[99], _A_);
    }
    var _y_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[5][2], _y_, _x_);
   }
   function filter_mapi(how, t, f){
    var _v_ = Core_Array[90], _w_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _w_, _v_);
   }
   function concat_mapi(how, t, f){
    function _s_(t){
     var _u_ = caml_call1(Core_Array[45], t);
     return caml_call1(Core_Array[68], _u_);
    }
    var _t_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[5][2], _t_, _s_);
   }
   function find_mapi(t, f){
    function aux(i){
     if(caml_call2(Core[90], i, t.length - 1))
      return caml_call1(Async_kernel_Deferred_std[10], 0);
     function _q_(some){
      return some
              ? caml_call1(Async_kernel_Deferred_std[10], some)
              : aux(i + 1 | 0);
     }
     var _r_ = caml_call2(f, i, caml_check_bound(t, i)[1 + i]);
     return caml_call2(Async_kernel_Deferred_std[5][1], _r_, _q_);
    }
    return aux(0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              function _o_(b){return b ? [0, [0, i, elt]] : 0;}
              var _p_ = caml_call2(f, i, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _p_, _o_);
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              function _m_(b){return b ? [0, elt] : 0;}
              var _n_ = caml_call1(f, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _n_, _m_);
             });
   }
   function existsi(t, f){
    function _i_(param){return param ? 1 : 0;}
    var
     _j_ =
       find_mapi
        (t,
         function(i, elt){
          function _k_(b){return b ? _a_ : 0;}
          var _l_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _l_, _k_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _j_, _i_);
   }
   function for_alli(t, f){
    function _e_(param){return param ? 0 : 1;}
    var
     _f_ =
       find_mapi
        (t,
         function(i, elt){
          function _g_(b){return b ? 0 : _b_;}
          var _h_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _h_, _g_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _f_, _e_);
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    function _c_(_d_){return _d_;}
    return map(how, caml_call2(Core_Array[56], n, _c_), f);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_arra);
   var
    Async_kernel_Deferred_array =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (19, Async_kernel_Deferred_array, cst_Async_kernel_Deferred_arra$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_list
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttle, Async_kernel__Throttled, Core, Core__List, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_list$0 = "Async_kernel__Deferred_list",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_List = global_data.Core__List,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Throttled = global_data.Async_kernel__Throttled,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Core = global_data.Core,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_list$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_list.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_list.ml");
   var
    _b_ = [0, 0],
    _a_ = [0, 0],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_list = cst_Async_kernel_Deferred_list$0;
   function foldi(t, init, f){
    function _U_(result){
     function loop(t, i, b){
      if(! t) return caml_call2(Async_kernel_Ivar[14], result, b);
      var xs = t[2], x = t[1];
      function _V_(b){return loop(xs, i + 1 | 0, b);}
      var _W_ = caml_call3(f, i, b, x);
      return caml_call2(Async_kernel_Deferred_std[1], _W_, _V_);
     }
     return loop(t, 0, init);
    }
    return caml_call1(Async_kernel_Deferred1[4], _U_);
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function seqmapi(t, f){
    var
     _Q_ = Core_List[59],
     _R_ =
       foldi
        (t,
         0,
         function(i, bs, a){
          function _S_(b){return [0, b, bs];}
          var _T_ = caml_call2(f, i, a);
          return caml_call2(Async_kernel_Deferred_std[5][2], _T_, _S_);
         });
    return caml_call2(Async_kernel_Deferred_std[4], _R_, _Q_);
   }
   function all(ds){return seqmapi(ds, function(param, x){return x;});}
   function all_unit(ds){
    var _P_ = fold(ds, 0, function(param, d){return d;});
    return caml_call1(Async_kernel_Deferred1[20], _P_);
   }
   function iteri(how, t, f){
    if(typeof how !== "number"){
     var
      job_count = how[2],
      gen_computation =
        function(idx, param){
         if(! param) return caml_call1(Async_kernel_Throttled[1], 0);
         var xs = param[2], x = param[1];
         function _L_(param){
          var _M_ = gen_computation(idx + 1 | 0, xs);
          function _N_(param){return caml_call2(f, idx, x);}
          var _O_ = caml_call1(Async_kernel_Throttled[14], _N_);
          return caml_call2(Async_kernel_Throttled[17], _O_, _M_);
         }
         return caml_call1(Async_kernel_Throttled[16], _L_);
        },
      _K_ = gen_computation(0, t);
     return caml_call2(Async_kernel_Throttled[15], _K_, job_count);
    }
    if(-676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _I_ = caml_call2(Async_kernel_Throttle[15], how, f),
     _J_ = caml_call1(Core[267], _I_);
    return all_unit(caml_call2(Core_List[41], t, _J_));
   }
   function mapi(how, t, f){
    if(typeof how !== "number"){
     var
      job_count = how[2],
      gen_computation =
        function(idx, param){
         if(! param) return caml_call1(Async_kernel_Throttled[1], 0);
         var xs = param[2], x = param[1];
         function _D_(param){
          function _E_(y, ys){return [0, y, ys];}
          var _F_ = gen_computation(idx + 1 | 0, xs);
          function _G_(param){return caml_call2(f, idx, x);}
          var _H_ = caml_call1(Async_kernel_Throttled[14], _G_);
          return caml_call3(Async_kernel_Throttled[9], _H_, _F_, _E_);
         }
         return caml_call1(Async_kernel_Throttled[16], _D_);
        },
      _C_ = gen_computation(0, t);
     return caml_call2(Async_kernel_Throttled[15], _C_, job_count);
    }
    if(-676829465 > how) return seqmapi(t, f);
    var
     _A_ = caml_call2(Async_kernel_Throttle[15], how, f),
     _B_ = caml_call1(Core[267], _A_);
    return all(caml_call2(Core_List[41], t, _B_));
   }
   function filteri(how, t, f){
    function _w_(bools){
     function _y_(ac, x, b){return b ? [0, x, ac] : ac;}
     var _z_ = caml_call4(Core_List[67], t, bools, 0, _y_);
     return caml_call1(Core_List[59], _z_);
    }
    var _x_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[5][2], _x_, _w_);
   }
   function filter_mapi(how, t, f){
    var _u_ = Core_List[132], _v_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _v_, _u_);
   }
   function concat_mapi(how, t, f){
    var _s_ = Core_List[11], _t_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _t_, _s_);
   }
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     if(! t) return caml_call1(Async_kernel_Deferred_std[10], 0);
     var tl = t[2], hd = t[1];
     function _q_(some){
      return some
              ? caml_call1(Async_kernel_Deferred_std[10], some)
              : find_mapi(tl, f, i + 1 | 0);
     }
     var _r_ = caml_call2(f, i, hd);
     return caml_call2(Async_kernel_Deferred_std[5][1], _r_, _q_);
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              function _o_(b){return b ? [0, [0, i, elt]] : 0;}
              var _p_ = caml_call2(f, i, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _p_, _o_);
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              function _m_(b){return b ? [0, elt] : 0;}
              var _n_ = caml_call1(f, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _n_, _m_);
             });
   }
   function existsi(t, f){
    function _i_(param){return param ? 1 : 0;}
    var
     _j_ =
       find_mapi
        (t,
         function(i, elt){
          function _k_(b){return b ? _a_ : 0;}
          var _l_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _l_, _k_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _j_, _i_);
   }
   function for_alli(t, f){
    function _e_(param){return param ? 0 : 1;}
    var
     _f_ =
       find_mapi
        (t,
         function(i, elt){
          function _g_(b){return b ? 0 : _b_;}
          var _h_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _h_, _g_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _f_, _e_);
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    function _c_(_d_){return _d_;}
    return map(how, caml_call2(Core_List[40], n, _c_), f);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_list);
   var
    Async_kernel_Deferred_list =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (20, Async_kernel_Deferred_list, cst_Async_kernel_Deferred_list$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_map
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_list, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttled, Base__List, Base__Map, Core__Map, Core__Sequence, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_map$0 = "Async_kernel__Deferred_map",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Map = global_data.Core__Map,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Throttled = global_data.Async_kernel__Throttled,
    Base_List = global_data.Base__List,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Base_Map = global_data.Base__Map,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core_Sequence = global_data.Core__Sequence,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_map$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_map.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_map.ml");
   var
    Throttled_map =
      caml_call1
       (Core_Map[118],
        [0,
         Async_kernel_Throttled[1],
         Async_kernel_Throttled[2],
         Async_kernel_Throttled[3],
         Async_kernel_Throttled[4],
         Async_kernel_Throttled[5],
         Async_kernel_Throttled[6],
         Async_kernel_Throttled[7],
         Async_kernel_Throttled[8],
         Async_kernel_Throttled[9],
         Async_kernel_Throttled[10],
         Async_kernel_Throttled[11],
         Async_kernel_Throttled[12],
         Async_kernel_Throttled[13],
         Async_kernel_Throttled[16]]),
    _a_ = [0, -542431297],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_map = cst_Async_kernel_Deferred_map$0;
   function change(t, k, f){
    function _O_(opt){
     function _Q_(param){return opt;}
     return caml_call3(Core_Map[42], t, k, _Q_);
    }
    var _P_ = caml_call1(f, caml_call2(Core_Map[44], t, k));
    return caml_call2(Async_kernel_Deferred_std[5][2], _P_, _O_);
   }
   function update(t, k, f){
    function _M_(data){return caml_call3(Core_Map[38], t, k, data);}
    var _N_ = caml_call1(f, caml_call2(Core_Map[44], t, k));
    return caml_call2(Async_kernel_Deferred_std[5][2], _N_, _M_);
   }
   function iter_keys(how, t, f){
    var _L_ = caml_call1(Core_Map[79], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _L_, f);
   }
   function iter(how, t, f){
    var _K_ = caml_call1(Core_Map[80], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _K_, f);
   }
   function iteri(how, t, f){
    function _I_(param){
     var data = param[2], key = param[1];
     return caml_call2(f, key, data);
    }
    var _J_ = caml_call2(Core_Map[81], 0, t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _J_, _I_);
   }
   function fold(t, init, f){
    function _G_(key, data, alist){return [0, [0, key, data], alist];}
    var alist_in_increasing_key_order = caml_call3(Core_Map[63], t, 0, _G_);
    function _H_(ac, param){
     var data = param[2], key = param[1];
     return caml_call3(f, key, data, ac);
    }
    return caml_call3
            (Async_kernel_Deferred_list[2],
             alist_in_increasing_key_order,
             init,
             _H_);
   }
   function fold_right(t, init, f){
    function _E_(key, data, alist){return [0, [0, key, data], alist];}
    var alist_in_decreasing_key_order = caml_call3(Core_Map[61], t, 0, _E_);
    function _F_(ac, param){
     var data = param[2], key = param[1];
     return caml_call3(f, key, data, ac);
    }
    return caml_call3
            (Async_kernel_Deferred_list[2],
             alist_in_decreasing_key_order,
             init,
             _F_);
   }
   function result(r){return r[3];}
   function filter_mapi(how, t, f){
    if(typeof how !== "number"){
     var
      max_concurrent_jobs = how[2],
      _p_ =
        function(key, data){
         function _D_(param){return caml_call2(f, key, data);}
         return caml_call1(Async_kernel_Throttled[14], _D_);
        },
      computation = caml_call2(Throttled_map[2], t, _p_);
     return caml_call2
             (Async_kernel_Throttled[15], computation, max_concurrent_jobs);
    }
    if(-676829465 <= how){
     var
      jobs = [0, 0],
      _q_ =
        function(key, data){
         var job = [0, key, data, 0];
         jobs[1] = [0, job, jobs[1]];
         return job;
        },
      job_map = caml_call2(Core_Map[58], t, _q_),
      _r_ = function(param){return caml_call2(Core_Map[68], job_map, result);},
      _s_ =
        function(job){
         var data = job[2], key = job[1];
         function _B_(x){job[3] = x; return 0;}
         var _C_ = caml_call2(f, key, data);
         return caml_call2(Async_kernel_Deferred_std[5][2], _C_, _B_);
        },
      _t_ = caml_call1(Base_List[63], jobs[1]),
      _u_ = caml_call3(Async_kernel_Deferred_list[14], how, _t_, _s_);
     return caml_call2(Async_kernel_Deferred_std[5][2], _u_, _r_);
    }
    var
     comparator = caml_call1(Core_Map[2], t),
     sequence = caml_call4(Core_Map[114], _a_, 0, 0, t);
    function _o_(ivar){
     function _v_(x){
      var
       _z_ = caml_call1(Base_Map[118][3][110][3], x),
       _A_ = caml_call2(Core_Map[124][30], comparator, _z_);
      return caml_call2(Async_kernel_Ivar[14], ivar, _A_);
     }
     function _w_(s, param, k){
      var data = param[2], key = param[1];
      function _x_(param){
       if(! param) return caml_call1(k, s);
       var
        data = param[1],
        s$0 = caml_call4(Base_Map[118][3][110][2], s, comparator, key, data);
       return caml_call1(k, s$0);
      }
      var _y_ = caml_call2(f, key, data);
      return caml_call2(Async_kernel_Deferred_std[11], _y_, _x_);
     }
     return caml_call4
             (Core_Sequence[107],
              sequence,
              Base_Map[118][3][110][1],
              _w_,
              _v_);
    }
    return caml_call1(Async_kernel_Deferred1[4], _o_);
   }
   function filter_map(how, t, f){
    return filter_mapi
            (how, t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys(how, t, f){
    return filter_mapi
            (how,
             t,
             function(key, data){
              function _m_(b){return b ? [0, data] : 0;}
              var _n_ = caml_call1(f, key);
              return caml_call2(Async_kernel_Deferred_std[5][2], _n_, _m_);
             });
   }
   function filter(how, t, f){
    return filter_mapi
            (how,
             t,
             function(param, data){
              function _k_(b){return b ? [0, data] : 0;}
              var _l_ = caml_call1(f, data);
              return caml_call2(Async_kernel_Deferred_std[5][2], _l_, _k_);
             });
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(key, data){
              function _i_(b){return b ? [0, data] : 0;}
              var _j_ = caml_call2(f, key, data);
              return caml_call2(Async_kernel_Deferred_std[5][2], _j_, _i_);
             });
   }
   function mapi(how, t, f){
    if(typeof how === "number")
     return filter_mapi
             (how,
              t,
              function(key, data){
               function _g_(z){return [0, z];}
               var _h_ = caml_call2(f, key, data);
               return caml_call2(Async_kernel_Deferred_std[5][2], _h_, _g_);
              });
    var max_concurrent_jobs = how[2];
    function _e_(key, data){
     function _f_(param){return caml_call2(f, key, data);}
     return caml_call1(Async_kernel_Throttled[14], _f_);
    }
    var computation = caml_call2(Throttled_map[1], t, _e_);
    return caml_call2
            (Async_kernel_Throttled[15], computation, max_concurrent_jobs);
   }
   function map(how, t, f){
    return mapi(how, t, function(param, data){return caml_call1(f, data);});
   }
   function merge(how, t1, t2, f){
    function _c_(thunk){return caml_call1(thunk, 0);}
    function _d_(key, z){
     return [0, function(param){return caml_call2(f, key, z);}];
    }
    return filter_map(how, caml_call3(Core_Map[84], t1, t2, _d_), _c_);
   }
   function all(t){return map(-686623969, t, function(_b_){return _b_;});}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_map);
   var
    Async_kernel_Deferred_map =
      [0,
       change,
       update,
       iter_keys,
       iter,
       iteri,
       map,
       mapi,
       fold,
       fold_right,
       filter_keys,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       merge,
       all];
   runtime.caml_register_global
    (21, Async_kernel_Deferred_map, cst_Async_kernel_Deferred_map$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_memo_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_memo = "Async_kernel__Deferred_memo_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_memo);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_memo_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel, "deferred_memo_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_memo);
   var Async_kernel_Deferred_memo_int = [0];
   runtime.caml_register_global
    (11, Async_kernel_Deferred_memo_int, cst_Async_kernel_Deferred_memo);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_memo
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_memo_intf, Async_kernel__Monitor, Base__Exn, Base__Staged, Core, Core__Memo, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_memo$0 = "Async_kernel__Deferred_memo",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core_Memo = global_data.Core__Memo,
    Base_Staged = global_data.Base__Staged,
    Core = global_data.Core,
    Base_Exn = global_data.Base__Exn,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_memo$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_memo.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_memo.ml");
   var
    _b_ = [0, 3804260],
    _c_ = [0, 3903734],
    _a_ = [0, 3804260],
    cst_caught_exception_in_memoiz = "caught exception in memoized function",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_memo = cst_Async_kernel_Deferred_memo$0;
   function Make(M){
    function reraise(param){
     if(0 === param[0]){var x = param[1]; return x;}
     var exn = param[1];
     return caml_call2(Base_Exn[8], exn, cst_caught_exception_in_memoiz);
    }
    function general(run, hashable, f){
     function _h_(a){
      function _k_(param){return caml_call1(f, a);}
      return caml_call7
              (Async_kernel_Monitor[16], 0, 0, 0, 0, [0, run], _a_, _k_);
     }
     var f$0 = caml_call3(Core_Memo[1], [0, hashable[4]], 0, _h_);
     function _i_(a){
      var _j_ = caml_call1(f$0, a);
      return caml_call2(M[2], _j_, reraise);
     }
     return caml_call1(Base_Staged[1], _i_);
    }
    function general$0(hashable, f){return general(3903734, hashable, f);}
    function recursive(hashable, f_onestep){
     var memoized = [];
     runtime.caml_update_dummy
      (memoized,
       [246,
        function(param){
         return general
                 (523273847,
                  hashable,
                  caml_call1
                   (f_onestep,
                    function(x){
                     var _g_ = caml_call1(Core[248], memoized);
                     return caml_call1(caml_call1(Core[267], _g_), x);
                    }));
        }]);
     return caml_call1(Core[248], memoized);
    }
    function unit(f){
     function _d_(param){
      return caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _c_, _b_, f);
     }
     var f$0 = caml_call1(Core_Memo[3], _d_);
     function _e_(param){
      var _f_ = caml_call1(f$0, 0);
      return caml_call2(M[2], _f_, reraise);
     }
     return caml_call1(Base_Staged[1], _e_);
    }
    return [0, general$0, recursive, unit];
   }
   var
    include =
      Make([0, Async_kernel_Deferred1[14], Async_kernel_Deferred1[15]]),
    general = include[1],
    recursive = include[2],
    unit = include[3];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_memo);
   var Async_kernel_Deferred_memo = [0, Make, general, recursive, unit];
   runtime.caml_register_global
    (21, Async_kernel_Deferred_memo, cst_Async_kernel_Deferred_memo$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_option
//# unitInfo: Requires: Async_kernel__Deferred1, Base__Monad, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_opti$0 = "Async_kernel__Deferred_option",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_opti$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_option.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_option.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_opti = cst_Async_kernel_Deferred_opti$0;
   function return$0(a){
    return caml_call1(Async_kernel_Deferred1[21], [0, a]);
   }
   function bind(t, f){
    function _b_(param){
     if(! param) return caml_call1(Async_kernel_Deferred1[21], 0);
     var a = param[1];
     return caml_call1(f, a);
    }
    return caml_call2(Async_kernel_Deferred1[17], t, _b_);
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        function _a_(r){return caml_call2(Core_Option[34], r, f);}
        return caml_call2(Async_kernel_Deferred1[18], t, _a_);
       }],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_opti);
   var
    Async_kernel_Deferred_option =
      [0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax];
   runtime.caml_register_global
    (14, Async_kernel_Deferred_option, cst_Async_kernel_Deferred_opti$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_result
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Base__Monad, Core__Printf, Core__Result, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_resu$0 = "Async_kernel__Deferred_result",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Result = global_data.Core__Result,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_Printf = global_data.Core__Printf,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_resu$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_result.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_result.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_resu = cst_Async_kernel_Deferred_resu$0;
   function combine(t1, t2, ok, err){
    function _d_(param){
     var t2 = param[2], t1 = param[1];
     return caml_call4(Core_Result[48], t1, t2, ok, err);
    }
    var _e_ = caml_call2(Async_kernel_Deferred_std[5][3], t1, t2);
    return caml_call2(Async_kernel_Deferred_std[5][2], _e_, _d_);
   }
   function return$0(a){
    return caml_call1(Async_kernel_Deferred1[21], [0, a]);
   }
   function bind(t, f){
    function _c_(error){
     if(0 !== error[0]) return caml_call1(Async_kernel_Deferred1[21], error);
     var a = error[1];
     return caml_call1(f, a);
    }
    return caml_call2(Async_kernel_Deferred1[17], t, _c_);
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        function _b_(r){return caml_call2(Core_Result[46], r, f);}
        return caml_call2(Async_kernel_Deferred1[18], t, _b_);
       }],
    include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$1 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function fail(x){return caml_call1(Async_kernel_Deferred1[21], [1, x]);}
   function failf(format){return caml_call2(Core_Printf[4], fail, format);}
   function map_error(t, f){
    function _a_(r){return caml_call2(Core_Result[47], r, f);}
    return caml_call2(Async_kernel_Deferred1[18], t, _a_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_resu);
   var
    Async_kernel_Deferred_result =
      [0,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       fail,
       failf,
       map_error,
       combine];
   runtime.caml_register_global
    (16, Async_kernel_Deferred_result, cst_Async_kernel_Deferred_resu$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_or_error
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_result, Async_kernel__Monitor, Async_kernel__Throttle, Base__Applicative, Core, Core__Error, Core__List, Core__Or_error, Core__Result, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_or_e$0 = "Async_kernel__Deferred_or_error",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_List = global_data.Core__List,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Core = global_data.Core,
    Core_Or_error = global_data.Core__Or_error,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_Error = global_data.Core__Error,
    Core_Result = global_data.Core__Result,
    Async_kernel_Deferred_result = global_data.Async_kernel__Deferred_result,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Base_Applicative = global_data.Base__Applicative;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_or_e$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_or_error.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_or_error.ml");
   var
    try_with = Async_kernel_Monitor[16],
    ignore_m = Async_kernel_Deferred_result[9],
    join = Async_kernel_Deferred_result[8],
    return$0 = Async_kernel_Deferred_result[6],
    bind = Async_kernel_Deferred_result[5],
    Monad_infix = Async_kernel_Deferred_result[4],
    symbol_bind = Async_kernel_Deferred_result[1],
    _c_ = [0, 0],
    _b_ = [0, 0],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_or_e = cst_Async_kernel_Deferred_or_e$0,
    _a_ = Async_kernel_Deferred_result[7];
   function apply(f, x){
    function _aa_(e1, e2){
     return caml_call1(Core_Error[26], [0, e1, [0, e2, 0]]);
    }
    function _ab_(f, x){return caml_call1(f, x);}
    return caml_call4(Async_kernel_Deferred_result[15], f, x, _ab_, _aa_);
   }
   var
    map = [0, -198771759, _a_],
    include = caml_call1(Base_Applicative[7], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13],
    symbol_bind$0 = Monad_infix[1],
    symbol_map$0 = Monad_infix[2],
    Open_on_rhs = [0];
   function fail(error){
    var _$_ = caml_call1(Core_Result[35], error);
    return caml_call1(Async_kernel_Deferred1[21], _$_);
   }
   function ok_exn(t){
    return caml_call2(Async_kernel_Deferred1[18], t, Core_Or_error[40]);
   }
   function of_exn(backtrace, exn){
    var ___ = caml_call2(Core_Or_error[41], backtrace, exn);
    return caml_call1(Async_kernel_Deferred1[21], ___);
   }
   function of_exn_result(backtrace, t){
    var _Z_ = caml_call1(Core_Or_error[42], backtrace);
    return caml_call2(Async_kernel_Deferred1[18], t, _Z_);
   }
   function error(msg, v, sexp_of){
    var _Y_ = caml_call5(Core_Or_error[44], 0, 0, msg, v, sexp_of);
    return caml_call1(Async_kernel_Deferred1[21], _Y_);
   }
   function error_s(sexp){
    var _X_ = caml_call1(Core_Or_error[45], sexp);
    return caml_call1(Async_kernel_Deferred1[21], _X_);
   }
   function error_string(msg){
    var _W_ = caml_call1(Core_Or_error[46], msg);
    return caml_call1(Async_kernel_Deferred1[21], _W_);
   }
   function errorf(format){
    return caml_call2(Core[254], error_string, format);
   }
   function tag(t, tag){
    var _T_ = Core_Or_error[48];
    function _U_(_V_){return caml_call2(_T_, _V_, tag);}
    return caml_call2(Async_kernel_Deferred1[18], t, _U_);
   }
   function tag_s(t, tag){
    var _Q_ = Core_Or_error[49];
    function _R_(_S_){return caml_call2(_Q_, _S_, tag);}
    return caml_call2(Async_kernel_Deferred1[18], t, _R_);
   }
   function tag_s_lazy(t, tag){
    var _N_ = Core_Or_error[50];
    function _O_(_P_){return caml_call2(_N_, _P_, tag);}
    return caml_call2(Async_kernel_Deferred1[18], t, _O_);
   }
   function tag_arg(t, message, a, sexp_of_a){
    function _M_(t){
     return caml_call4(Core_Or_error[51], t, message, a, sexp_of_a);
    }
    return caml_call2(Async_kernel_Deferred1[18], t, _M_);
   }
   function unimplemented(msg){
    var _L_ = caml_call1(Core_Or_error[52], msg);
    return caml_call1(Async_kernel_Deferred1[21], _L_);
   }
   function combine_errors(l){
    var
     _J_ = Core_Or_error[56],
     _K_ = caml_call1(Async_kernel_Deferred1[44], l);
    return caml_call2(Async_kernel_Deferred1[18], _K_, _J_);
   }
   function combine_errors_unit(l){
    var
     _H_ = Core_Or_error[57],
     _I_ = caml_call1(Async_kernel_Deferred1[44], l);
    return caml_call2(Async_kernel_Deferred1[18], _I_, _H_);
   }
   function filter_ok_at_least_one(l){
    var
     _F_ = Core_Or_error[58],
     _G_ = caml_call1(Async_kernel_Deferred1[44], l);
    return caml_call2(Async_kernel_Deferred1[18], _G_, _F_);
   }
   function find_map_ok(l, f){
    function _B_(param){
     var errors = param[2], l = param[1];
     if(l){
      var
       tl = l[2],
       hd = l[1],
       _C_ =
         function(param){
          if(0 === param[0]){
           var result = param[1];
           return [0, -289386606, [0, result]];
          }
          var current_error = param[1];
          return [0, 990972795, [0, tl, [0, current_error, errors]]];
         },
       _D_ = caml_call1(f, hd);
      return caml_call2(Async_kernel_Deferred1[18], _D_, _C_);
     }
     var
      _E_ = caml_call1(Core_List[59], errors),
      errors$0 = caml_call1(Core_Error[26], _E_);
     return caml_call1
             (Async_kernel_Deferred1[21], [0, -289386606, [1, errors$0]]);
    }
    return caml_call2(Async_kernel_Deferred1[39], [0, l, 0], _B_);
   }
   var ok_unit = caml_call1(return$1, 0);
   function try_with$0(extract_exn, run, rest, here, name, f){
    function _z_(ok){
     if(0 === ok[0]) return ok;
     var exn = ok[1];
     return [1, caml_call2(Core_Error[27], 0, exn)];
    }
    var _A_ = caml_call7(try_with, here, 0, name, extract_exn, run, rest, f);
    return caml_call2(Async_kernel_Deferred1[18], _A_, _z_);
   }
   function try_with_join(extract_exn, run, rest, here, name, f){
    var
     _x_ = Core_Or_error[31],
     _y_ = try_with$0(extract_exn, run, rest, here, name, f);
    return caml_call2(Async_kernel_Deferred1[18], _y_, _x_);
   }
   function foldi(list, acc, f){
    function loop(i, acc, param){
     if(! param) return caml_call1(return$1, acc);
     var tl = param[2], hd = param[1];
     function _w_(acc){return loop(i + 1 | 0, acc, tl);}
     return caml_call2(bind, caml_call3(f, i, acc, hd), _w_);
    }
    return loop(0, acc, list);
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function iteri(how, t, f){
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _u_ = caml_call2(Async_kernel_Throttle[15], how, f),
     _v_ = caml_call1(Core[267], _u_);
    return caml_call1(all_unit, caml_call2(Core_List[41], t, _v_));
   }
   function mapi(how, t, f){
    if(typeof how === "number" && -676829465 > how){
     var _q_ = Core_List[59];
     return caml_call2
             (symbol_map$0,
              foldi
               (t,
                0,
                function(i, bs, a){
                 function _t_(b){return [0, b, bs];}
                 return caml_call2(map$0, caml_call2(f, i, a), _t_);
                }),
              _q_);
    }
    var
     _r_ = caml_call2(Async_kernel_Throttle[15], how, f),
     _s_ = caml_call1(Core[267], _r_);
    return caml_call1(all, caml_call2(Core_List[41], t, _s_));
   }
   function filter_mapi(how, t, f){
    var _p_ = Core_List[132];
    return caml_call2(symbol_map$0, mapi(how, t, f), _p_);
   }
   function concat_mapi(how, t, f){
    var _o_ = Core_List[11];
    return caml_call2(symbol_map$0, mapi(how, t, f), _o_);
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(i, x){
              function _n_(b){return b ? [0, x] : 0;}
              return caml_call2(map$0, caml_call2(f, i, x), _n_);
             });
   }
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     if(! t) return caml_call1(return$1, 0);
     var tl = t[2], hd = t[1];
     function _m_(some){
      return some ? caml_call1(return$1, some) : find_mapi(tl, f, i + 1 | 0);
     }
     return caml_call2(bind, caml_call2(f, i, hd), _m_);
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              function _l_(b){return b ? [0, [0, i, elt]] : 0;}
              return caml_call2(map$0, caml_call2(f, i, elt), _l_);
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              function _k_(b){return b ? [0, elt] : 0;}
              return caml_call2(map$0, caml_call1(f, elt), _k_);
             });
   }
   function existsi(t, f){
    function _i_(param){return param ? 1 : 0;}
    return caml_call2
            (map$0,
             find_mapi
              (t,
               function(i, elt){
                function _j_(b){return b ? _b_ : 0;}
                return caml_call2(map$0, caml_call2(f, i, elt), _j_);
               }),
             _i_);
   }
   function for_alli(t, f){
    function _g_(param){return param ? 0 : 1;}
    return caml_call2
            (map$0,
             find_mapi
              (t,
               function(i, elt){
                function _h_(b){return b ? 0 : _c_;}
                return caml_call2(map$0, caml_call2(f, i, elt), _h_);
               }),
             _g_);
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map$1(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    function _e_(_f_){return _f_;}
    return map$1(how, caml_call2(Core_List[40], n, _e_), f);
   }
   function repeat_until_finished(state, f){
    function _d_(param){
     if(990972795 <= param[1]){
      var state = param[2];
      return repeat_until_finished(state, f);
     }
     var state$0 = param[2];
     return caml_call1(return$1, state$0);
    }
    return caml_call2(bind, caml_call1(f, state), _d_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_or_e);
   var
    Async_kernel_Deferred_or_error =
      [0,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply$0,
       map2,
       map3,
       Applicative_infix,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$1,
        symbol_bind$0,
        symbol_map$0,
        [0, return$1, bind, map$0, both, Open_on_rhs]],
       fail,
       ok_exn,
       of_exn,
       of_exn_result,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       find_map_ok,
       ok_unit,
       try_with$0,
       try_with_join,
       [0,
        foldi,
        fold,
        find,
        findi,
        find_map,
        find_mapi,
        exists,
        existsi,
        for_all,
        for_alli,
        all,
        all_unit,
        init,
        iter,
        iteri,
        map$1,
        mapi,
        filter,
        filteri,
        filter_map,
        filter_mapi,
        concat_map,
        concat_mapi],
       repeat_until_finished];
   runtime.caml_register_global
    (23, Async_kernel_Deferred_or_error, cst_Async_kernel_Deferred_or_e$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_queue
//# unitInfo: Requires: Async_kernel__Deferred_list, Async_kernel__Deferred_std, Core__Queue, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_queu$0 = "Async_kernel__Deferred_queue",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_queu$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_queue.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_queue.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_queu = cst_Async_kernel_Deferred_queu$0;
   function foldi(t, init, f){
    var _V_ = caml_call1(Core_Queue[28], t);
    return caml_call3(Async_kernel_Deferred_list[1], _V_, init, f);
   }
   function fold(t, init, f){
    var _U_ = caml_call1(Core_Queue[28], t);
    return caml_call3(Async_kernel_Deferred_list[2], _U_, init, f);
   }
   function all(t){
    var
     _R_ = Core_Queue[40],
     _S_ = caml_call1(Core_Queue[28], t),
     _T_ = caml_call1(Async_kernel_Deferred_list[11], _S_);
    return caml_call2(Async_kernel_Deferred_std[4], _T_, _R_);
   }
   function all_unit(t){
    var _Q_ = caml_call1(Core_Queue[28], t);
    return caml_call1(Async_kernel_Deferred_list[12], _Q_);
   }
   function iter(how, t, f){
    var _P_ = caml_call1(Core_Queue[28], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _P_, f);
   }
   function iteri(how, t, f){
    var _O_ = caml_call1(Core_Queue[28], t);
    return caml_call3(Async_kernel_Deferred_list[15], how, _O_, f);
   }
   function map(how, t, f){
    var
     _L_ = Core_Queue[40],
     _M_ = caml_call1(Core_Queue[28], t),
     _N_ = caml_call3(Async_kernel_Deferred_list[16], how, _M_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _N_, _L_);
   }
   function mapi(how, t, f){
    var
     _I_ = Core_Queue[40],
     _J_ = caml_call1(Core_Queue[28], t),
     _K_ = caml_call3(Async_kernel_Deferred_list[17], how, _J_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _K_, _I_);
   }
   function init(how, n, f){
    var
     _G_ = Core_Queue[40],
     _H_ = caml_call3(Async_kernel_Deferred_list[13], how, n, f);
    return caml_call2(Async_kernel_Deferred_std[4], _H_, _G_);
   }
   function filter(how, t, f){
    var
     _D_ = Core_Queue[40],
     _E_ = caml_call1(Core_Queue[28], t),
     _F_ = caml_call3(Async_kernel_Deferred_list[18], how, _E_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _F_, _D_);
   }
   function filteri(how, t, f){
    var
     _A_ = Core_Queue[40],
     _B_ = caml_call1(Core_Queue[28], t),
     _C_ = caml_call3(Async_kernel_Deferred_list[19], how, _B_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _C_, _A_);
   }
   function filter_map(how, t, f){
    var
     _x_ = Core_Queue[40],
     _y_ = caml_call1(Core_Queue[28], t),
     _z_ = caml_call3(Async_kernel_Deferred_list[20], how, _y_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _z_, _x_);
   }
   function filter_mapi(how, t, f){
    var
     _u_ = Core_Queue[40],
     _v_ = caml_call1(Core_Queue[28], t),
     _w_ = caml_call3(Async_kernel_Deferred_list[21], how, _v_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _w_, _u_);
   }
   function concat_map(how, t, f){
    var _o_ = Core_Queue[40];
    function _p_(x){
     var _s_ = Core_Queue[28], _t_ = caml_call1(f, x);
     return caml_call2(Async_kernel_Deferred_std[4], _t_, _s_);
    }
    var
     _q_ = caml_call1(Core_Queue[28], t),
     _r_ = caml_call3(Async_kernel_Deferred_list[22], how, _q_, _p_);
    return caml_call2(Async_kernel_Deferred_std[4], _r_, _o_);
   }
   function concat_mapi(how, t, f){
    var _i_ = Core_Queue[40];
    function _j_(i, x){
     var _m_ = Core_Queue[28], _n_ = caml_call2(f, i, x);
     return caml_call2(Async_kernel_Deferred_std[4], _n_, _m_);
    }
    var
     _k_ = caml_call1(Core_Queue[28], t),
     _l_ = caml_call3(Async_kernel_Deferred_list[23], how, _k_, _j_);
    return caml_call2(Async_kernel_Deferred_std[4], _l_, _i_);
   }
   function find_map(t, f){
    var _h_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[5], _h_, f);
   }
   function find_mapi(t, f){
    var _g_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[6], _g_, f);
   }
   function find(t, f){
    var _f_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[3], _f_, f);
   }
   function findi(t, f){
    var _e_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[4], _e_, f);
   }
   function for_all(t, f){
    var _d_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[9], _d_, f);
   }
   function for_alli(t, f){
    var _c_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[10], _c_, f);
   }
   function exists(t, f){
    var _b_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[7], _b_, f);
   }
   function existsi(t, f){
    var _a_ = caml_call1(Core_Queue[28], t);
    return caml_call2(Async_kernel_Deferred_list[8], _a_, f);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_queu);
   var
    Async_kernel_Deferred_queue =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (14, Async_kernel_Deferred_queue, cst_Async_kernel_Deferred_queu$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_sequence
//# unitInfo: Requires: Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttle, Base__Sequence, Core__Bool, Core__List, Core__Sequence, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_sequ$0 = "Async_kernel__Deferred_sequence",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Bool = global_data.Core__Bool,
    Core_Sequence = global_data.Core__Sequence,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core_List = global_data.Core__List,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Base_Sequence = global_data.Base__Sequence,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_sequ$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_sequence.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_sequence.ml");
   var
    _b_ = [0, 0],
    _a_ = [0, 0],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_sequ = cst_Async_kernel_Deferred_sequ$0;
   function fold_mapi(opt, t, init, mapi_f, fold_f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    var
     match = caml_call1(Base_Sequence[115][4], t),
     next = match[2],
     state = match[1];
    if(typeof how !== "number"){
     var
      max_concurrent_jobs = how[2],
      throttle = caml_call2(Async_kernel_Throttle[5], 0, max_concurrent_jobs),
      loop$0 =
        function(i, t, c){
         function _Y_(param){
          var match = caml_call1(next, t);
          if(typeof match === "number") return c;
          if(0 === match[0]){
           var state = match[1];
           return loop$0(i, state, c);
          }
          var t$0 = match[2], a = match[1];
          function ___(b){
           function _ab_(c){return caml_call2(fold_f, c, b);}
           return caml_call2(Async_kernel_Deferred_std[5][2], c, _ab_);
          }
          function _$_(param){return caml_call2(mapi_f, i, a);}
          var _aa_ = caml_call2(Async_kernel_Throttle[10], throttle, _$_);
          return loop$0
                  (i + 1 | 0,
                   t$0,
                   caml_call2(Async_kernel_Deferred_std[5][1], _aa_, ___));
         }
         var _Z_ = caml_call1(Async_kernel_Throttle[20], throttle);
         return caml_call2(Async_kernel_Deferred_std[5][1], _Z_, _Y_);
        };
     return loop$0(0, state, caml_call1(Async_kernel_Deferred_std[10], init));
    }
    if(-676829465 > how){
     var
      result = caml_call1(Async_kernel_Ivar[12], 0),
      loop =
        function(i, state, c){
         var state$0 = state;
         for(;;){
          var match = caml_call1(next, state$0);
          if(typeof match === "number")
           return caml_call2(Async_kernel_Ivar[14], result, c);
          if(0 !== match[0]){
           var
            state$2 = match[2],
            a = match[1],
            _W_ =
              function(b){
               return loop(i + 1 | 0, state$2, caml_call2(fold_f, c, b));
              },
            _X_ = caml_call2(mapi_f, i, a);
           return caml_call2(Async_kernel_Deferred_std[11], _X_, _W_);
          }
          var state$1 = match[1], state$0 = state$1;
         }
        };
     loop(0, state, init);
     return caml_call1(Async_kernel_Ivar[19], result);
    }
    var
     c$1 = caml_call1(Async_kernel_Deferred_std[10], init),
     i = 0,
     t$0 = state,
     c = c$1;
    for(;;){
     var match$0 = caml_call1(next, t$0);
     if(typeof match$0 === "number") return c;
     if(0 === match$0[0])
      var state$0 = match$0[1], t$0 = state$0;
     else
      var
       t$1 = match$0[2],
       a = match$0[1],
       _T_ =
         function(c){
           return function(b){
            function _V_(c){return caml_call2(fold_f, c, b);}
            return caml_call2(Async_kernel_Deferred_std[5][2], c, _V_);};
          }
          (c),
       _U_ = caml_call2(mapi_f, i, a),
       c$0 = caml_call2(Async_kernel_Deferred_std[5][1], _U_, _T_),
       i$0 = i + 1 | 0,
       i = i$0,
       t$0 = t$1,
       c = c$0;
    }
   }
   function foldi(t, init, f){
    function _P_(param){
     var b = param[2];
     return caml_call1(Async_kernel_Deferred_std[10], b);
    }
    function _Q_(param, a, k){
     var b = param[2], i = param[1];
     function _R_(b){return caml_call1(k, [0, i + 1 | 0, b]);}
     var _S_ = caml_call3(f, i, b, a);
     return caml_call2(Async_kernel_Deferred_std[5][1], _S_, _R_);
    }
    return caml_call4(Core_Sequence[107], t, [0, 0, init], _Q_, _P_);
   }
   function fold(t, init, f){
    var _M_ = Async_kernel_Deferred_std[10];
    function _N_(b, a, k){
     var _O_ = caml_call2(f, b, a);
     return caml_call2(Async_kernel_Deferred_std[3], _O_, k);
    }
    return caml_call4(Core_Sequence[107], t, init, _N_, _M_);
   }
   function all(t){
    function _I_(res){
     var _L_ = caml_call1(Core_List[59], res);
     return caml_call1(Core_Sequence[111], _L_);
    }
    var
     _J_ =
       fold
        (t,
         0,
         function(accum, d){
          function _K_(a){return [0, a, accum];}
          return caml_call2(Async_kernel_Deferred_std[5][2], d, _K_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _J_, _I_);
   }
   function all_unit(t){return fold(t, 0, function(param, v){return v;});}
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     var match = caml_call1(Core_Sequence[50], t);
     if(! match) return caml_call1(Async_kernel_Deferred_std[10], 0);
     var match$0 = match[1], rest = match$0[2], v = match$0[1];
     function _G_(some){
      return some
              ? caml_call1(Async_kernel_Deferred_std[10], some)
              : find_mapi(rest, f, i + 1 | 0);
     }
     var _H_ = caml_call2(f, i, v);
     return caml_call2(Async_kernel_Deferred_std[5][1], _H_, _G_);
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              function _E_(b){return b ? [0, [0, i, elt]] : 0;}
              var _F_ = caml_call2(f, i, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _F_, _E_);
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              function _C_(b){return b ? [0, elt] : 0;}
              var _D_ = caml_call1(f, elt);
              return caml_call2(Async_kernel_Deferred_std[5][2], _D_, _C_);
             });
   }
   function existsi(t, f){
    function _y_(param){return param ? 1 : 0;}
    var
     _z_ =
       find_mapi
        (t,
         function(i, elt){
          function _A_(b){return b ? _a_ : 0;}
          var _B_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _B_, _A_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _z_, _y_);
   }
   function for_alli(t, f){
    function _u_(param){return param ? 0 : 1;}
    var
     _v_ =
       find_mapi
        (t,
         function(i, elt){
          function _w_(b){return b ? 0 : _b_;}
          var _x_ = caml_call2(f, i, elt);
          return caml_call2(Async_kernel_Deferred_std[5][2], _x_, _w_);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _v_, _u_);
   }
   function iteri(how, t, f){
    return fold_mapi([0, how], t, 0, f, function(param, _t_){return 0;});
   }
   function mapi(how, t, f){
    function _p_(bs){
     var _s_ = caml_call1(Core_List[59], bs);
     return caml_call1(Core_Sequence[111], _s_);
    }
    function _q_(bs, b){return [0, b, bs];}
    var
     _r_ =
       fold_mapi
        ([0, how], t, 0, function(i, a){return caml_call2(f, i, a);}, _q_);
    return caml_call2(Async_kernel_Deferred_std[5][2], _r_, _p_);
   }
   function filter_mapi(how, t, f){
    function _l_(bs){
     var _o_ = caml_call1(Core_List[59], bs);
     return caml_call1(Core_Sequence[111], _o_);
    }
    function _m_(bs, maybe_v){
     if(! maybe_v) return bs;
     var b = maybe_v[1];
     return [0, b, bs];
    }
    var
     _n_ =
       fold_mapi
        ([0, how], t, 0, function(i, a){return caml_call2(f, i, a);}, _m_);
    return caml_call2(Async_kernel_Deferred_std[5][2], _n_, _l_);
   }
   function concat_mapi(how, t, f){
    var _j_ = Core_Sequence[72], _k_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _k_, _j_);
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(i, a){
              function _h_(param){return param ? [0, a] : 0;}
              var _i_ = caml_call2(f, i, a);
              return caml_call2(Async_kernel_Deferred_std[5][2], _i_, _h_);
             });
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    function _f_(_g_){return _g_;}
    return map(how, caml_call2(Core_Sequence[85], n, _f_), f);
   }
   function count(how, t, f){
    function _e_(acc, c){return acc + caml_call1(Core_Bool[11], c) | 0;}
    return fold_mapi(how, t, 0, function(i, a){return caml_call1(f, a);}, _e_);
   }
   function sum(M, how, t, f){
    var _c_ = M[2];
    function _d_(i, a){return caml_call1(f, a);}
    return fold_mapi(how, t, M[1], _d_, _c_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_sequ);
   var
    Async_kernel_Deferred_sequence =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi,
       fold_mapi,
       count,
       sum];
   runtime.caml_register_global
    (20, Async_kernel_Deferred_sequence, cst_Async_kernel_Deferred_sequ$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_set
//# unitInfo: Requires: Async_kernel__Deferred_sequence, Async_kernel__Deferred_std, Core__Fn, Core__Set, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_set$0 = "Async_kernel__Deferred_set",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Set = global_data.Core__Set,
    Async_kernel_Deferred_sequence =
      global_data.Async_kernel__Deferred_sequence,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core_Fn = global_data.Core__Fn,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_set$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred_set.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "deferred_set.ml");
   var
    _a_ = [0, -128674501],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Deferred_set = cst_Async_kernel_Deferred_set$0;
   function for_all(t, f){
    var _s_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call2(Async_kernel_Deferred_sequence[9], _s_, f);
   }
   function find(t, f){
    var _r_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call2(Async_kernel_Deferred_sequence[3], _r_, f);
   }
   function find_map(t, f){
    var _q_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call2(Async_kernel_Deferred_sequence[5], _q_, f);
   }
   function fold(t, init, f){
    var _p_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call3(Async_kernel_Deferred_sequence[2], _p_, init, f);
   }
   function fold_right(t, init, f){
    var
     _n_ = caml_call1(Core_Fn[6], f),
     _o_ = caml_call4(Core_Set[68], _a_, 0, 0, t);
    return caml_call3(Async_kernel_Deferred_sequence[2], _o_, init, _n_);
   }
   function iter(how, t, f){
    var _m_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call3(Async_kernel_Deferred_sequence[14], how, _m_, f);
   }
   function filter_map(M, how, t, f){
    function _i_(acc, v){
     if(! v) return acc;
     var v$0 = v[1];
     return caml_call2(Core_Set[12], acc, v$0);
    }
    function _j_(i, a){return caml_call1(f, a);}
    var
     _k_ = caml_call1(Core_Set[3][1], M[1]),
     _l_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call5
            (Async_kernel_Deferred_sequence[24], [0, how], _l_, _k_, _j_, _i_);
   }
   function filter(how, t, f){
    function _f_(x){
     function _g_(param){return param ? [0, x] : 0;}
     var _h_ = caml_call1(f, x);
     return caml_call2(Async_kernel_Deferred_std[5][2], _h_, _g_);
    }
    return filter_map(caml_call1(Core_Set[5], t), how, t, _f_);
   }
   function map(comparator, how, t, f){
    return filter_map
            (comparator,
             how,
             t,
             function(x){
              function _d_(y){return [0, y];}
              var _e_ = caml_call1(f, x);
              return caml_call2(Async_kernel_Deferred_std[5][2], _e_, _d_);
             });
   }
   function count(how, t, f){
    var _c_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call3(Async_kernel_Deferred_sequence[25], [0, how], _c_, f);
   }
   function sum(M, how, t, f){
    var _b_ = caml_call4(Core_Set[68], 0, 0, 0, t);
    return caml_call4(Async_kernel_Deferred_sequence[26], M, [0, how], _b_, f);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_set);
   var
    Async_kernel_Deferred_set =
      [0,
       for_all,
       count,
       sum,
       find,
       find_map,
       map,
       filter_map,
       filter,
       fold,
       fold_right,
       iter];
   runtime.caml_register_global
    (16, Async_kernel_Deferred_set, cst_Async_kernel_Deferred_set$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred
//# unitInfo: Requires: Async_kernel__Deferred1, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred = "Async_kernel__Deferred",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/deferred.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel, "deferred.ml");
   var
    sexp_of_t = Async_kernel_Deferred1[1],
    invariant = Async_kernel_Deferred1[2],
    create = Async_kernel_Deferred1[4],
    peek = Async_kernel_Deferred1[5],
    value_exn = Async_kernel_Deferred1[6],
    is_determined = Async_kernel_Deferred1[7],
    upon = Async_kernel_Deferred1[8],
    never = Async_kernel_Deferred1[12],
    symbol_bind = Async_kernel_Deferred1[14],
    symbol_map = Async_kernel_Deferred1[15],
    Monad_infix = Async_kernel_Deferred1[16],
    bind = Async_kernel_Deferred1[17],
    map = Async_kernel_Deferred1[18],
    join = Async_kernel_Deferred1[19],
    ignore_m = Async_kernel_Deferred1[20],
    return$0 = Async_kernel_Deferred1[21],
    Let_syntax = Async_kernel_Deferred1[22],
    unit = Async_kernel_Deferred1[23],
    both = Async_kernel_Deferred1[24],
    Infix = Async_kernel_Deferred1[25],
    don_t_wait_for = Async_kernel_Deferred1[26],
    Choice = Async_kernel_Deferred1[27],
    choice = Async_kernel_Deferred1[29],
    enabled = Async_kernel_Deferred1[30],
    choose = Async_kernel_Deferred1[34],
    any = Async_kernel_Deferred1[36],
    any_unit = Async_kernel_Deferred1[37],
    for$0 = Async_kernel_Deferred1[38],
    repeat_until_finished = Async_kernel_Deferred1[39],
    forever = Async_kernel_Deferred1[40],
    all = Async_kernel_Deferred1[44],
    all_unit = Async_kernel_Deferred1[45],
    ok = Async_kernel_Deferred1[46],
    For_tests = Async_kernel_Deferred1[47];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred);
   var
    _a_ = Let_syntax[4],
    Async_kernel_Deferred =
      [0,
       sexp_of_t,
       invariant,
       create,
       upon,
       peek,
       value_exn,
       is_determined,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind,
       return$0,
       map,
       join,
       ignore_m,
       [0,
        Let_syntax[3],
        Let_syntax[1],
        Let_syntax[2],
        [0, _a_[5], _a_[1], _a_[2], _a_[3], _a_[4]]],
       [0, Infix[1], Infix[2], Infix[3]],
       unit,
       never,
       both,
       all,
       all_unit,
       any,
       any_unit,
       don_t_wait_for,
       Choice,
       choice,
       enabled,
       choose,
       for$0,
       repeat_until_finished,
       forever,
       ok,
       For_tests];
   runtime.caml_register_global
    (12, Async_kernel_Deferred, cst_Async_kernel_Deferred);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Require_explicit_time_source
//# unitInfo: Requires: Async_kernel__Async_kernel_scheduler, Async_kernel__Clock_ns, Async_kernel__Time_ns, Core__Date, Core__Time_float, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Require_expli =
      "Async_kernel__Require_explicit_time_source",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Core_Date = global_data.Core__Date,
    Async_kernel_Async_kernel_sche =
      global_data.Async_kernel__Async_kernel_scheduler,
    Core_Time_float = global_data.Core__Time_float,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Require_expli);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/require_explicit_time_source.ml");
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_async_kernel,
     "require_explicit_time_source.ml");
   var
    after = Async_kernel_Clock_ns[4],
    at = Async_kernel_Clock_ns[3],
    every = Async_kernel_Clock_ns[11],
    with_timeout = Async_kernel_Clock_ns[5];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Require_expli);
   var
    Async_kernel_Require_explicit_ =
      [0,
       Async_kernel_Clock_ns,
       [0,
        Async_kernel_Time_ns[1],
        Async_kernel_Time_ns[2],
        Async_kernel_Time_ns[3],
        Async_kernel_Time_ns[4],
        Async_kernel_Time_ns[5],
        Async_kernel_Time_ns[6],
        Async_kernel_Time_ns[7],
        Async_kernel_Time_ns[8],
        Async_kernel_Time_ns[9],
        Async_kernel_Time_ns[10],
        Async_kernel_Time_ns[11],
        Async_kernel_Time_ns[12],
        Async_kernel_Time_ns[13],
        Async_kernel_Time_ns[14],
        Async_kernel_Time_ns[15],
        Async_kernel_Time_ns[16],
        Async_kernel_Time_ns[17],
        Async_kernel_Time_ns[18],
        Async_kernel_Time_ns[19],
        Async_kernel_Time_ns[20],
        Async_kernel_Time_ns[21],
        Async_kernel_Time_ns[22],
        Async_kernel_Time_ns[23],
        Async_kernel_Time_ns[24],
        Async_kernel_Time_ns[25],
        Async_kernel_Time_ns[26],
        Async_kernel_Time_ns[27],
        Async_kernel_Time_ns[28],
        Async_kernel_Time_ns[29],
        Async_kernel_Time_ns[30],
        Async_kernel_Time_ns[31],
        Async_kernel_Time_ns[32],
        Async_kernel_Time_ns[33],
        Async_kernel_Time_ns[34],
        Async_kernel_Time_ns[35],
        Async_kernel_Time_ns[36],
        Async_kernel_Time_ns[37],
        Async_kernel_Time_ns[38],
        Async_kernel_Time_ns[39],
        Async_kernel_Time_ns[40],
        Async_kernel_Time_ns[41],
        Async_kernel_Time_ns[43],
        Async_kernel_Time_ns[44],
        Async_kernel_Time_ns[45],
        Async_kernel_Time_ns[46],
        Async_kernel_Time_ns[47],
        Async_kernel_Time_ns[48],
        Async_kernel_Time_ns[49],
        Async_kernel_Time_ns[50],
        Async_kernel_Time_ns[51],
        Async_kernel_Time_ns[52],
        Async_kernel_Time_ns[53],
        Async_kernel_Time_ns[54],
        Async_kernel_Time_ns[55],
        Async_kernel_Time_ns[56],
        Async_kernel_Time_ns[57],
        Async_kernel_Time_ns[58],
        Async_kernel_Time_ns[59],
        Async_kernel_Time_ns[60],
        Async_kernel_Time_ns[61],
        Async_kernel_Time_ns[62],
        Async_kernel_Time_ns[63],
        Async_kernel_Time_ns[64],
        Async_kernel_Time_ns[65],
        Async_kernel_Time_ns[66],
        Async_kernel_Time_ns[67],
        Async_kernel_Time_ns[68],
        Async_kernel_Time_ns[69],
        Async_kernel_Time_ns[70],
        Async_kernel_Time_ns[71],
        Async_kernel_Time_ns[72],
        Async_kernel_Time_ns[73],
        Async_kernel_Time_ns[74],
        Async_kernel_Time_ns[75],
        Async_kernel_Time_ns[76],
        Async_kernel_Time_ns[77],
        Async_kernel_Time_ns[78],
        Async_kernel_Time_ns[79],
        Async_kernel_Time_ns[80],
        Async_kernel_Time_ns[81],
        Async_kernel_Time_ns[82],
        Async_kernel_Time_ns[83],
        Async_kernel_Time_ns[84],
        Async_kernel_Time_ns[85],
        Async_kernel_Time_ns[86],
        Async_kernel_Time_ns[87],
        Async_kernel_Time_ns[88],
        Async_kernel_Time_ns[89],
        Async_kernel_Time_ns[90],
        Async_kernel_Time_ns[91],
        Async_kernel_Time_ns[92],
        Async_kernel_Time_ns[93],
        Async_kernel_Time_ns[94],
        Async_kernel_Time_ns[95],
        Async_kernel_Time_ns[96],
        Async_kernel_Time_ns[97],
        Async_kernel_Time_ns[98],
        Async_kernel_Time_ns[99],
        Async_kernel_Time_ns[100],
        Async_kernel_Time_ns[101],
        Async_kernel_Time_ns[102],
        Async_kernel_Time_ns[103],
        Async_kernel_Time_ns[104],
        Async_kernel_Time_ns[105],
        Async_kernel_Time_ns[106],
        Async_kernel_Time_ns[107],
        Async_kernel_Time_ns[108],
        Async_kernel_Time_ns[109],
        Async_kernel_Time_ns[110],
        Async_kernel_Time_ns[111],
        Async_kernel_Time_ns[112],
        Async_kernel_Time_ns[113],
        Async_kernel_Time_ns[114],
        Async_kernel_Time_ns[115],
        Async_kernel_Time_ns[116],
        Async_kernel_Time_ns[117],
        Async_kernel_Time_ns[118],
        Async_kernel_Time_ns[119],
        Async_kernel_Time_ns[42]],
       [0,
        Core_Time_float[1],
        Core_Time_float[2],
        Core_Time_float[3],
        Core_Time_float[4],
        Core_Time_float[5],
        Core_Time_float[6],
        Core_Time_float[7],
        Core_Time_float[8],
        Core_Time_float[9],
        Core_Time_float[10],
        Core_Time_float[11],
        Core_Time_float[12],
        Core_Time_float[14],
        Core_Time_float[15],
        Core_Time_float[16],
        Core_Time_float[17],
        Core_Time_float[18],
        Core_Time_float[19],
        Core_Time_float[20],
        Core_Time_float[21],
        Core_Time_float[22],
        Core_Time_float[23],
        Core_Time_float[24],
        Core_Time_float[25],
        Core_Time_float[26],
        Core_Time_float[27],
        Core_Time_float[28],
        Core_Time_float[29],
        Core_Time_float[30],
        Core_Time_float[31],
        Core_Time_float[32],
        Core_Time_float[33],
        Core_Time_float[34],
        Core_Time_float[35],
        Core_Time_float[36],
        Core_Time_float[37],
        Core_Time_float[38],
        Core_Time_float[39],
        Core_Time_float[40],
        Core_Time_float[41],
        Core_Time_float[42],
        Core_Time_float[43],
        Core_Time_float[45],
        Core_Time_float[46],
        Core_Time_float[48],
        Core_Time_float[49],
        Core_Time_float[50],
        Core_Time_float[51],
        Core_Time_float[52],
        Core_Time_float[53],
        Core_Time_float[54],
        Core_Time_float[55],
        Core_Time_float[56],
        Core_Time_float[57],
        Core_Time_float[58],
        Core_Time_float[59],
        Core_Time_float[60],
        Core_Time_float[61],
        Core_Time_float[62],
        Core_Time_float[63],
        Core_Time_float[64],
        Core_Time_float[65],
        Core_Time_float[66],
        Core_Time_float[67],
        Core_Time_float[68],
        Core_Time_float[69],
        Core_Time_float[70],
        Core_Time_float[71],
        Core_Time_float[72],
        Core_Time_float[73],
        Core_Time_float[74],
        Core_Time_float[75],
        Core_Time_float[76],
        Core_Time_float[77],
        Core_Time_float[78],
        Core_Time_float[79],
        Core_Time_float[80],
        Core_Time_float[81],
        Core_Time_float[82],
        Core_Time_float[93],
        Core_Time_float[94],
        Core_Time_float[95],
        Core_Time_float[96],
        Core_Time_float[97],
        Core_Time_float[98],
        Core_Time_float[99],
        Core_Time_float[100],
        Core_Time_float[101],
        Core_Time_float[102],
        Core_Time_float[103],
        Core_Time_float[104],
        Core_Time_float[105],
        Core_Time_float[106],
        Core_Time_float[107],
        Core_Time_float[108],
        Core_Time_float[109],
        Core_Time_float[110],
        Core_Time_float[111],
        Core_Time_float[112],
        Core_Time_float[113],
        Core_Time_float[114],
        Core_Time_float[115],
        Core_Time_float[47]],
       [0,
        Async_kernel_Async_kernel_sche[1],
        Async_kernel_Async_kernel_sche[2],
        Async_kernel_Async_kernel_sche[3],
        Async_kernel_Async_kernel_sche[4],
        Async_kernel_Async_kernel_sche[5],
        Async_kernel_Async_kernel_sche[6],
        Async_kernel_Async_kernel_sche[7],
        Async_kernel_Async_kernel_sche[8],
        Async_kernel_Async_kernel_sche[9],
        Async_kernel_Async_kernel_sche[10],
        Async_kernel_Async_kernel_sche[11],
        Async_kernel_Async_kernel_sche[12],
        Async_kernel_Async_kernel_sche[13],
        Async_kernel_Async_kernel_sche[16],
        Async_kernel_Async_kernel_sche[17],
        Async_kernel_Async_kernel_sche[18],
        Async_kernel_Async_kernel_sche[19],
        Async_kernel_Async_kernel_sche[20],
        Async_kernel_Async_kernel_sche[21],
        Async_kernel_Async_kernel_sche[22],
        Async_kernel_Async_kernel_sche[23],
        Async_kernel_Async_kernel_sche[24],
        Async_kernel_Async_kernel_sche[25],
        Async_kernel_Async_kernel_sche[26],
        Async_kernel_Async_kernel_sche[27],
        Async_kernel_Async_kernel_sche[28],
        Async_kernel_Async_kernel_sche[29],
        Async_kernel_Async_kernel_sche[30],
        Async_kernel_Async_kernel_sche[31],
        Async_kernel_Async_kernel_sche[32],
        Async_kernel_Async_kernel_sche[33],
        Async_kernel_Async_kernel_sche[14],
        Async_kernel_Async_kernel_sche[15]],
       [0,
        Core_Date[1],
        Core_Date[2],
        Core_Date[3],
        Core_Date[4],
        Core_Date[5],
        Core_Date[6],
        Core_Date[7],
        Core_Date[8],
        Core_Date[9],
        Core_Date[10],
        Core_Date[11],
        Core_Date[12],
        Core_Date[13],
        Core_Date[14],
        Core_Date[15],
        Core_Date[16],
        Core_Date[17],
        Core_Date[18],
        Core_Date[22],
        Core_Date[23],
        Core_Date[24],
        Core_Date[25],
        Core_Date[26],
        Core_Date[27],
        Core_Date[28],
        Core_Date[29],
        Core_Date[30],
        Core_Date[31],
        Core_Date[32],
        Core_Date[33],
        Core_Date[34],
        Core_Date[35],
        Core_Date[36],
        Core_Date[37],
        Core_Date[38],
        Core_Date[39],
        Core_Date[40],
        Core_Date[41],
        Core_Date[43],
        Core_Date[47],
        Core_Date[48],
        Core_Date[49],
        Core_Date[50],
        Core_Date[51],
        Core_Date[52],
        Core_Date[53],
        Core_Date[54],
        Core_Date[55],
        Core_Date[56],
        Core_Date[57],
        Core_Date[58],
        Core_Date[59],
        Core_Date[60],
        Core_Date[61],
        Core_Date[62],
        Core_Date[63],
        Core_Date[64],
        Core_Date[65],
        Core_Date[66],
        Core_Date[67],
        Core_Date[68],
        Core_Date[69],
        Core_Date[70],
        Core_Date[71],
        Core_Date[72],
        Core_Date[73],
        Core_Date[74],
        Core_Date[75],
        Core_Date[76],
        Core_Date[77],
        Core_Date[78],
        Core_Date[79],
        Core_Date[80],
        Core_Date[81],
        Core_Date[82],
        Core_Date[83],
        Core_Date[84],
        Core_Date[85],
        Core_Date[86],
        Core_Date[87],
        Core_Date[88],
        Core_Date[89],
        Core_Date[90],
        Core_Date[91],
        Core_Date[92],
        Core_Date[93],
        Core_Date[99],
        Core_Date[101],
        Core_Date[102],
        Core_Date[103],
        Core_Date[100]],
       at,
       after,
       every,
       with_timeout];
   runtime.caml_register_global
    (16, Async_kernel_Require_explicit_, cst_Async_kernel_Require_expli);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Pipe
//# unitInfo: Requires: Async_kernel__Async_stream, Async_kernel__Deferred, Async_kernel__Deferred_list, Async_kernel__Deferred_queue, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Tail, Base__Field, Core, Core__Bag, Core__Bool, Core__Hashtbl, Core__Int, Core__List, Core__Option, Core__Queue, Core__Sequence, Core__Sexp, Core__Source_code_position, Pairing_heap, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexp_hidden_in_test, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Pipe$0 = "Async_kernel__Pipe",
    cst_Eof = "Eof",
    cst_Ok = "Ok",
    cst_Reader_closed = "Reader_closed",
    cst = "_",
    cst_async_kernel$0 = "async_kernel",
    cst_blocked_flushes$0 = "blocked_flushes",
    cst_blocked_reads$0 = "blocked_reads",
    cst_consumer$0 = "consumer",
    cst_consumers$0 = "consumers",
    cst_exn = "exn",
    cst_n = "n",
    cst_pipe = "pipe",
    cst_pushback$0 = "pushback",
    cst_reserved_space$0 = "reserved_space",
    cst_size_budget$0 = "size_budget",
    cst_src_pipe_ml = "src/pipe.ml",
    cst_values_read$0 = "values_read",
    cst_wants$0 = "wants",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Core_List = global_data.Core__List,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Pairing_heap = global_data.Pairing_heap,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Sequence = global_data.Core__Sequence,
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred_queue = global_data.Async_kernel__Deferred_queue,
    Core_Sexp = global_data.Core__Sexp,
    Core_Option = global_data.Core__Option,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Async_stream = global_data.Async_kernel__Async_stream,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core = global_data.Core,
    Core_Int = global_data.Core__Int,
    Core_Bag = global_data.Core__Bag,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Core_Bool = global_data.Core__Bool,
    Base_Field = global_data.Base__Field,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Sexp_hidden_in_test = global_data.Sexp_hidden_in_test,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Pipe$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_pipe_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "pipe.ml");
   var
    show_debug_messages = [0, 0],
    check_invariant = [0, 0],
    cst_Pipe_interleave = "Pipe.interleave",
    _a3_ = [0, "Mapped"],
    _a2_ = [0, cst_src_pipe_ml, 978, 4],
    _a1_ = [0, "max_iterations_per_job"],
    cst_iter_without_pushback_got_ =
      "iter_without_pushback got non-positive max_iterations_per_job",
    _aZ_ = [0, 3804260],
    _a0_ = [0, 523273847],
    _aW_ = [0, "When_value_read"],
    _aX_ = [0, "When_value_processed"],
    _aY_ = [0, "Consumer"],
    _aV_ = [0, cst_src_pipe_ml, 708, 6],
    _aU_ = [0, "num_values"],
    cst_Pipe_read_exactly_got_num_ = "Pipe.read_exactly got num_values <= 0",
    cst_read_exactly = "read_exactly",
    _aT_ = [0, "here"],
    cst_Pipe_read_choice_single_co =
      "Pipe.read_choice_single_consumer_exn: choice was enabled but pipe is empty; this is likely due to a race condition with one or more other consumers",
    cst_values_available = "values_available",
    cst_Pipe_read_exn_received_EOF = "Pipe.read_exn: received EOF",
    cst_read$0 = "read",
    _aS_ = [0, cst_src_pipe_ml, 657, 4],
    cst_read = "read'",
    cst_Pipe_read_now_exn_nothing_ = "Pipe.read_now_exn: nothing available",
    cst_Pipe_read_now_exn_received = "Pipe.read_now_exn: received EOF",
    _aR_ = [0, "max_queue_length"],
    cst_max_queue_length_0 = "max_queue_length <= 0",
    cst_read_now = "read_now",
    _aQ_ = [0, cst_src_pipe_ml, 600, 4],
    _aP_ = [0, cst],
    _aO_ = [0, cst],
    _aL_ = [0, cst],
    _aM_ = [0, cst_pipe],
    _aN_ = [0, cst_consumer$0],
    cst_Attempt_to_use_consumer_wi = "Attempt to use consumer with wrong pipe",
    _aJ_ = [0, cst],
    _aI_ = [0, cst],
    _aK_ = [0, cst_pipe],
    cst_write_to_closed_pipe = "write to closed pipe",
    _aH_ = [0, cst],
    _aG_ = [0, cst],
    cst_write = "write",
    _aE_ = [0, cst_n],
    _aF_ = [0, "t.reserved_space"],
    cst_overflow_when_reserving_sp = "overflow when reserving space",
    _aD_ = [0, cst_n],
    cst_reserving_negative_space = "reserving negative space",
    _aC_ = [0, cst_src_pipe_ml, 478, 2],
    _aB_ = [0, cst_src_pipe_ml, 469, 2],
    _aA_ = [0, cst],
    _az_ = [0, cst],
    cst_close_read = "close_read",
    _ay_ = [0, cst],
    _ax_ = [0, cst],
    cst_close = "close",
    _aw_ = [0, cst_size_budget$0],
    cst_negative_size_budget = "negative size_budget",
    _av_ = [0, cst_src_pipe_ml, 319, 2],
    _au_ = [0, cst_src_pipe_ml, 312, 2],
    _ah_ = [0, cst],
    _ag_ = [0, cst],
    _ai_ = [0, cst_pipe],
    _aj_ = [0, cst_exn],
    cst_Pipe_invariant_failed = "Pipe.invariant failed",
    _at_ = [0, cst_src_pipe_ml, 269, 46],
    _as_ = [0, cst_src_pipe_ml, 270, 52],
    _ar_ = [0, cst_src_pipe_ml, 273, 11],
    _ao_ = [0, cst_src_pipe_ml, 281, 13],
    _aq_ = [0, cst_src_pipe_ml, 282, 11],
    _ap_ = [0, cst_src_pipe_ml, 288, 30],
    _al_ = [0, cst_src_pipe_ml, 296, 13],
    _an_ = [0, cst_src_pipe_ml, 293, 36],
    _am_ = [0, cst_src_pipe_ml, 298, 31],
    _ak_ = [0, cst_src_pipe_ml, 305, 13],
    _V_ = [0, "upstream_flusheds"],
    _W_ = [0, cst_consumers$0],
    _X_ = [0, "read_closed"],
    _Y_ = [0, "closed"],
    _Z_ = [0, cst_blocked_reads$0],
    ___ = [0, cst_blocked_flushes$0],
    _$_ = [0, "num_values_read"],
    _aa_ = [0, cst_pushback$0],
    _ab_ = [0, cst_reserved_space$0],
    _ac_ = [0, cst_size_budget$0],
    _ad_ = [0, "buffer"],
    _ae_ = [0, "info"],
    _af_ = [0, "id"],
    _F_ = [0, cst_Ok],
    _G_ = [0, cst_Reader_closed],
    _H_ = [0, "ready"],
    _I_ = [0, "fill_when_num_values_read"],
    _B_ = [0, cst],
    _C_ = [0, cst_pipe],
    _D_ = [0, cst_exn],
    cst_Pipe_Blocked_read_invarian = "Pipe.Blocked_read.invariant failed",
    _E_ = [0, cst_src_pipe_ml, 144, 32],
    _z_ = [0, cst_consumer$0],
    _A_ = [0, cst_wants$0],
    _s_ = [0, cst_Eof],
    _t_ = [0, cst_Ok],
    _p_ = [0, cst_Eof],
    _q_ = [0, cst_Ok],
    _m_ = [0, cst_Eof],
    _n_ = [0, cst_Ok],
    _o_ = [0, "Zero"],
    _r_ = [0, "One"],
    _u_ = [0, "At_most"],
    _j_ = [0, cst_pipe],
    _k_ = [0, cst_exn],
    cst_Pipe_Consumer_invariant_fa = "Pipe.Consumer.invariant failed",
    _l_ = [0, cst_src_pipe_ml, 83, 53],
    _e_ = [0, "downstream_flushed"],
    _f_ = [0, "Have_been_sent_downstream"],
    _i_ = [0, "Have_not_been_sent_downstream"],
    _g_ = [0, cst_values_read$0],
    _h_ = [0, "pipe_id"],
    _a_ = [0, cst_Ok],
    _b_ = [0, cst_Reader_closed],
    cst_values_read = cst_values_read$0,
    cst_consumer = cst_consumer$0,
    cst_wants = cst_wants$0,
    cst_consumers = cst_consumers$0,
    cst_blocked_reads = cst_blocked_reads$0,
    cst_blocked_flushes = cst_blocked_flushes$0,
    cst_pushback = cst_pushback$0,
    cst_reserved_space = cst_reserved_space$0,
    cst_size_budget = cst_size_budget$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Pipe = cst_Async_kernel_Pipe$0;
   function compare(a_001, b_002){
    if(a_001 === b_002) return 0;
    if(17724 <= a_001){
     if(typeof b_002 === "number" && 17724 === b_002) return 0;
    }
    else if(typeof b_002 === "number" && -402004920 === b_002) return 0;
    return runtime.caml_int_compare(a_001, b_002);
   }
   function sexp_of_t(param){return 17724 <= param ? _a_ : _b_;}
   function equal(x_003, x_004){return 0 === compare(x_003, x_004) ? 1 : 0;}
   function combine(l){
    if(l && ! l[2]){var x = l[1]; return x;}
    function _e8_(l){
     return caml_call3(Core_List[17], l, -402004920, equal)
             ? -402004920
             : 17724;
    }
    var _e9_ = caml_call1(Async_kernel_Deferred[21], l);
    return caml_call2(Async_kernel_Deferred_std[5][2], _e9_, _e8_);
   }
   function values_read(r){return r[2];}
   function set_values_read(r, v){r[2] = v; return 0;}
   function _c_(r, v){return [0, r[1], v, r[3]];}
   var
    _d_ = [0, set_values_read],
    values_read$0 =
      [0, function(param){return 0;}, cst_values_read, _d_, values_read, _c_];
   function sexp_of_t$0(param){
    var pipe_id_009 = param[1], values_read_011 = param[2], bnds_008 = 0;
    function _e6_(_e7_){return 0;}
    var
     arg_015 = caml_call1(Sexplib0_Sexp_conv[24], _e6_),
     bnds_008$0 = [0, [1, [0, _e_, [0, arg_015, 0]]], bnds_008];
    if(typeof values_read_011 === "number")
     var arg_012 = _f_;
    else
     var
      v_013 = values_read_011[2],
      arg_012 =
        [1,
         [0, _i_, [0, caml_call2(Async_kernel_Ivar[9], Core[620], v_013), 0]]];
    var
     bnds_008$1 = [0, [1, [0, _g_, [0, arg_012, 0]]], bnds_008$0],
     arg_010 = caml_call1(Core[389], pipe_id_009),
     bnds_008$2 = [0, [1, [0, _h_, [0, arg_010, 0]]], bnds_008$1];
    return [1, bnds_008$2];
   }
   function invariant(t){
    try{
     var param = caml_call2(Base_Field[3], values_read$0, t);
     if(typeof param !== "number"){
      var ivar = param[2];
      if(! caml_call1(Async_kernel_Ivar[17], ivar))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     }
     var _e2_ = 0;
     return _e2_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _e3_ = [0, [1, [0, _j_, [0, sexp_of_t$0(t), 0]]], 0],
      _e4_ = [0, [1, [0, _k_, [0, caml_call1(Core[625], exn), 0]]], _e3_],
      _e5_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_Consumer_invariant_fa),
          _e4_]];
     return caml_call1(Core[261], _e5_);
    }
   }
   function start(t){
    return typeof t[2] === "number"
            ? (t
               [2]
              = [0, -122467239, caml_call1(Async_kernel_Ivar[12], 0)],
              0)
            : 0;
   }
   function values_sent_downstream(t){
    var match = t[2];
    if(typeof match === "number") return 0;
    var ivar = match[2];
    caml_call2(Async_kernel_Ivar[14], ivar, 0);
    t[2] = -758792467;
    return 0;
   }
   function values_sent_downstream_and_flu(t){
    var match = t[2];
    if(typeof match === "number") return caml_call1(t[3], 0);
    var when_sent_downstream = match[2];
    function _e0_(param){return caml_call1(t[3], 0);}
    var _e1_ = caml_call1(Async_kernel_Ivar[19], when_sent_downstream);
    return caml_call2(Async_kernel_Deferred_std[5][1], _e1_, _e0_);
   }
   function consumer(r){return r[2];}
   function wants(r){return r[1];}
   function _v_(r, v){return [0, r[1], v];}
   var
    _w_ = 0,
    consumer$0 =
      [0, function(param){return 0;}, cst_consumer, _w_, consumer, _v_];
   function _x_(r, v){return [0, v, r[2]];}
   var
    _y_ = 0,
    wants$0 = [0, function(param){return 0;}, cst_wants, _y_, wants, _x_];
   function sexp_of_t$1(of_a_029, param){
    var
     consumer_033 = param[2],
     wants_031 = param[1],
     arg_034 = caml_call2(Core[515], sexp_of_t$0, consumer_033),
     bnds_030 = [0, [1, [0, _z_, [0, arg_034, 0]]], 0];
    switch(wants_031[0]){
      case 0:
       var
        arg0_018 = wants_031[1],
        _eX_ = function(param){return 3456156 <= param ? _m_ : _n_;},
        res0_019 = caml_call2(Async_kernel_Ivar[9], _eX_, arg0_018),
        arg_032 = [1, [0, _o_, [0, res0_019, 0]]];
       break;
      case 1:
       var
        arg0_021 = wants_031[1],
        _eY_ =
          function(param){
           if(typeof param === "number") return _p_;
           var v_020 = param[2];
           return [1, [0, _q_, [0, caml_call1(of_a_029, v_020), 0]]];
          },
        res0_022 = caml_call2(Async_kernel_Ivar[9], _eY_, arg0_021),
        arg_032 = [1, [0, _r_, [0, res0_022, 0]]];
       break;
      default:
       var
        arg1_025 = wants_031[2],
        arg0_024 = wants_031[1],
        res0_026 = caml_call1(Core[389], arg0_024),
        _eZ_ =
          function(param){
           if(typeof param === "number") return _s_;
           var v_023 = param[2];
           return [1,
                   [0,
                    _t_,
                    [0, caml_call2(Core_Queue[13], of_a_029, v_023), 0]]];
          },
        res1_027 = caml_call2(Async_kernel_Ivar[9], _eZ_, arg1_025),
        arg_032 = [1, [0, _u_, [0, res0_026, [0, res1_027, 0]]]];
    }
    var bnds_030$0 = [0, [1, [0, _A_, [0, arg_032, 0]]], bnds_030];
    return [1, bnds_030$0];
   }
   function fill_with_eof(t){
    var match = t[1];
    switch(match[0]){
      case 0:
       var i = match[1]; return caml_call2(Async_kernel_Ivar[14], i, 3456156);
      case 1:
       var i$0 = match[1];
       return caml_call2(Async_kernel_Ivar[14], i$0, 3456156);
      default:
       var i$1 = match[2];
       return caml_call2(Async_kernel_Ivar[14], i$1, 3456156);
    }
   }
   function fill_when_num_values_read(r){return r[1];}
   function sexp_of_t$2(param){
    var
     ready_039 = param[2],
     fill_when_num_values_read_037 = param[1],
     bnds_036 = 0;
    function _eW_(param){return 17724 <= param ? _F_ : _G_;}
    var
     arg_040 = caml_call2(Async_kernel_Ivar[9], _eW_, ready_039),
     bnds_036$0 = [0, [1, [0, _H_, [0, arg_040, 0]]], bnds_036],
     arg_038 = caml_call1(Core[389], fill_when_num_values_read_037),
     bnds_036$1 = [0, [1, [0, _I_, [0, arg_038, 0]]], bnds_036$0];
    return [1, bnds_036$1];
   }
   function fill(t, v){return caml_call2(Async_kernel_Ivar[14], t[2], v);}
   function consumers(r){return r[12];}
   function set_consumers(r, v){r[12] = v; return 0;}
   function blocked_reads(r){return r[9];}
   function blocked_flushes(r){return r[8];}
   function num_values_read(r){return r[7];}
   function pushback(r){return r[6];}
   function set_pushback(r, v){r[6] = v; return 0;}
   function reserved_space(r){return r[5];}
   function set_reserved_space(r, v){r[5] = v; return 0;}
   function size_budget(r){return r[4];}
   function set_size_budget(r, v){r[4] = v; return 0;}
   function _J_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            v,
            r[13]];
   }
   var
    _K_ = [0, set_consumers],
    consumers$0 =
      [0, function(param){return 0;}, cst_consumers, _K_, consumers, _J_];
   function _L_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            r[8],
            v,
            r[10],
            r[11],
            r[12],
            r[13]];
   }
   var
    _M_ = 0,
    blocked_reads$0 =
      [0,
       function(param){return 0;},
       cst_blocked_reads,
       _M_,
       blocked_reads,
       _L_];
   function _N_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            r[6],
            r[7],
            v,
            r[9],
            r[10],
            r[11],
            r[12],
            r[13]];
   }
   var
    _O_ = 0,
    blocked_flushes$0 =
      [0,
       function(param){return 0;},
       cst_blocked_flushes,
       _O_,
       blocked_flushes,
       _N_];
   function _P_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            r[5],
            v,
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13]];
   }
   var
    _Q_ = [0, set_pushback],
    pushback$0 =
      [0, function(param){return 0;}, cst_pushback, _Q_, pushback, _P_];
   function _R_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            r[4],
            v,
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13]];
   }
   var
    _S_ = [0, set_reserved_space],
    reserved_space$0 =
      [0,
       function(param){return 0;},
       cst_reserved_space,
       _S_,
       reserved_space,
       _R_];
   function _T_(r, v){
    return [0,
            r[1],
            r[2],
            r[3],
            v,
            r[5],
            r[6],
            r[7],
            r[8],
            r[9],
            r[10],
            r[11],
            r[12],
            r[13]];
   }
   var
    _U_ = [0, set_size_budget],
    size_budget$0 =
      [0, function(param){return 0;}, cst_size_budget, _U_, size_budget, _T_];
   function sexp_of_pipe(of_a_041, of_phantom_042, param){
    var
     id_044 = param[1],
     info_046 = param[2],
     buffer_050 = param[3],
     size_budget_052 = param[4],
     reserved_space_054 = param[5],
     pushback_056 = param[6],
     num_values_read_058 = param[7],
     read_closed_066 = param[11],
     closed_064 = param[10],
     blocked_reads_062 = param[9],
     blocked_flushes_060 = param[8],
     consumers_068 = param[12],
     upstream_flusheds_070 = param[13],
     bnds_043 = 0;
    function _eR_(param){
     function _eU_(_eV_){return 0;}
     return caml_call1(Sexplib0_Sexp_conv[24], _eU_);
    }
    var
     arg_071 = caml_call2(Core_Bag[3], _eR_, upstream_flusheds_070),
     bnds_043$0 = [0, [1, [0, _V_, [0, arg_071, 0]]], bnds_043],
     arg_069 = caml_call2(Core[472], sexp_of_t$0, consumers_068),
     bnds_043$1 = [0, [1, [0, _W_, [0, arg_069, 0]]], bnds_043$0],
     arg_067 = caml_call2(Async_kernel_Ivar[9], Core[620], read_closed_066),
     bnds_043$2 = [0, [1, [0, _X_, [0, arg_067, 0]]], bnds_043$1],
     arg_065 = caml_call2(Async_kernel_Ivar[9], Core[620], closed_064),
     bnds_043$3 = [0, [1, [0, _Y_, [0, arg_065, 0]]], bnds_043$2];
    function _eS_(_eT_){return sexp_of_t$1(of_a_041, _eT_);}
    var
     arg_063 = caml_call2(Core_Queue[13], _eS_, blocked_reads_062),
     bnds_043$4 = [0, [1, [0, _Z_, [0, arg_063, 0]]], bnds_043$3],
     arg_061 = caml_call2(Core_Queue[13], sexp_of_t$2, blocked_flushes_060),
     bnds_043$5 = [0, [1, [0, ___, [0, arg_061, 0]]], bnds_043$4],
     arg_059 = caml_call1(Core[389], num_values_read_058),
     bnds_043$6 = [0, [1, [0, _$_, [0, arg_059, 0]]], bnds_043$5],
     arg_057 = caml_call2(Async_kernel_Ivar[9], Core[620], pushback_056),
     bnds_043$7 = [0, [1, [0, _aa_, [0, arg_057, 0]]], bnds_043$6],
     arg_055 = caml_call1(Core[389], reserved_space_054),
     bnds_043$8 = [0, [1, [0, _ab_, [0, arg_055, 0]]], bnds_043$7],
     arg_053 = caml_call1(Core[389], size_budget_052),
     bnds_043$9 = [0, [1, [0, _ac_, [0, arg_053, 0]]], bnds_043$8],
     arg_051 = caml_call2(Core_Queue[13], of_a_041, buffer_050),
     bnds_043$10 = [0, [1, [0, _ad_, [0, arg_051, 0]]], bnds_043$9];
    if(info_046)
     var
      v_047 = info_046[1],
      arg_049 = caml_call1(Core_Sexp[93], v_047),
      bnd_048 = [1, [0, _ae_, [0, arg_049, 0]]],
      bnds_043$11 = [0, bnd_048, bnds_043$10];
    else
     var bnds_043$11 = bnds_043$10;
    var
     arg_045 = caml_call2(Sexp_hidden_in_test[11], Core[389], id_044),
     bnds_043$12 = [0, [1, [0, _af_, [0, arg_045, 0]]], bnds_043$11];
    return [1, bnds_043$12];
   }
   function effective_size_budget(t){return t[4] - t[5] | 0;}
   function hash(t){return caml_call1(Core_Hashtbl[1], t[1]);}
   function equal$0(t1, t2){return t1 === t2 ? 1 : 0;}
   function compare$0(t1, t2){return caml_call2(Core_Int[88], t1[1], t2[1]);}
   function is_closed(t){return caml_call1(Async_kernel_Ivar[18], t[10]);}
   function is_read_closed(t){
    return caml_call1(Async_kernel_Ivar[18], t[11]);
   }
   function closed(t){return caml_call1(Async_kernel_Ivar[19], t[10]);}
   function pushback$1(t){return caml_call1(Async_kernel_Ivar[19], t[6]);}
   function length(t){return caml_call1(Core_Queue[16], t[3]);}
   function is_empty(t){
    var _eQ_ = length(t);
    return caml_call2(Async_kernel_Import[3], _eQ_, 0);
   }
   function num_values_written(t){
    var _eP_ = t[7];
    return length(t) + _eP_ | 0;
   }
   function update_num_values_read(t, delta){t[7] = t[7] + delta | 0; return;}
   function invariant$0(x_075){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, x_075));
        },
      _eq_ =
        function(l){
         function _eO_(consumer){
          invariant(consumer);
          if(caml_call2(Async_kernel_Import[3], consumer[1], x_075[1]))
           return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _ak_], 1);
         }
         return caml_call2(Core_List[19], l, _eO_);
        },
      _er_ =
        function(blocked_reads){
         if
          (1 - is_empty(x_075) && ! caml_call1(Core_Queue[17], blocked_reads))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _an_], 1);
         function _eF_(x_035){
          try{
           var
            check =
              function(f, field){
               return caml_call1(f, caml_call2(Base_Field[3], field, x_035));
              },
            _eM_ =
              function(param){
               if(! param) return 0;
               var consumer = param[1];
               return invariant(consumer);
              };
           check
            (function(param){
              if(2 !== param[0]) return 0;
              var i = param[1];
              if(caml_call2(Async_kernel_Import[4], i, 0)) return 0;
              throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
             },
             wants$0);
           check(_eM_, consumer$0);
          }
          catch(exn$0){
           var
            exn = caml_wrap_exception(exn$0),
            _eH_ = 0,
            _eI_ = 0,
            _eJ_ =
              [0,
               [1,
                [0,
                 _C_,
                 [0, sexp_of_t$1(function(param){return _B_;}, x_035), _eI_]]],
               _eH_],
            _eK_ =
              [0, [1, [0, _D_, [0, caml_call1(Core[625], exn), 0]]], _eJ_],
            _eL_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_Pipe_Blocked_read_invarian),
                _eK_]];
           caml_call1(Core[261], _eL_);
          }
          var match = x_035[1];
          switch(match[0]){
            case 0:
             var i = match[1], _eN_ = caml_call1(Async_kernel_Ivar[17], i);
             break;
            case 1:
             var
              i$0 = match[1],
              _eN_ = caml_call1(Async_kernel_Ivar[17], i$0);
             break;
            default:
             var
              i$1 = match[2],
              _eN_ = caml_call1(Async_kernel_Ivar[17], i$1);
          }
          if(_eN_) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _al_], 1);
         }
         caml_call2(Core_Queue[18], blocked_reads, _eF_);
         var _eG_ = is_closed(x_075);
         if(! _eG_) return _eG_;
         if(caml_call1(Core_Queue[17], blocked_reads)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _am_], 1);
        },
      _es_ =
        function(blocked_flushes){
         function _eA_(f){
          if(caml_call2(Async_kernel_Import[4], f[1], x_075[7])) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, _ao_], 1);
         }
         caml_call2(Core_Queue[18], blocked_flushes, _eA_);
         var
          _eB_ = Core_Int[88],
          _eC_ = caml_call1(Core_Queue[28], blocked_flushes),
          _eD_ = caml_call2(Core_List[51], _eC_, fill_when_num_values_read);
         if(! caml_call2(Core_List[147], _eD_, _eB_))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aq_], 1);
         var _eE_ = is_empty(x_075);
         if(! _eE_) return _eE_;
         if(caml_call1(Core_Queue[17], blocked_flushes)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _ap_], 1);
        },
      _et_ =
        function(pushback){
         var
          _ev_ = effective_size_budget(x_075),
          _ew_ = length(x_075),
          _ex_ = caml_call2(Async_kernel_Import[2], _ew_, _ev_),
          _ey_ = _ex_ || is_closed(x_075),
          _ez_ = caml_call1(Async_kernel_Ivar[18], pushback);
         if(caml_call2(Core_Bool[32], _ez_, _ey_)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _ar_], 1);
        },
      _eu_ =
        function(reserved_space){
         if(caml_call2(Async_kernel_Import[1], reserved_space, 0)) return 0;
         throw caml_maybe_attach_backtrace([0, Assert_failure, _as_], 1);
        };
     check
      (function(size_budget){
        if(caml_call2(Async_kernel_Import[1], size_budget, 0)) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _at_], 1);
       },
       size_budget$0);
     check(_eu_, reserved_space$0);
     check(_et_, pushback$0);
     check(_es_, blocked_flushes$0);
     check(_er_, blocked_reads$0);
     check(_eq_, consumers$0);
     var _ej_ = 0;
     return _ej_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _ek_ = 0,
      _el_ = 0,
      _em_ = function(param){return _ag_;},
      _en_ =
        [0,
         [1,
          [0,
           _ai_,
           [0, sexp_of_pipe(function(param){return _ah_;}, _em_, x_075), _el_]]],
         _ek_],
      _eo_ = [0, [1, [0, _aj_, [0, caml_call1(Core[625], exn), 0]]], _en_],
      _ep_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_invariant_failed),
          _eo_]];
     return caml_call1(Core[261], _ep_);
    }
   }
   function sexp_of_phantom(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _au_], 1);
   }
   function sexp_of_t$3(of_a_076, x_077){
    return sexp_of_pipe(of_a_076, sexp_of_phantom, x_077);
   }
   function sexp_of_phantom$0(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _av_], 1);
   }
   function sexp_of_t$4(of_a_078, x_079){
    return sexp_of_pipe(of_a_078, sexp_of_phantom$0, x_079);
   }
   var id_ref = [0, 0];
   function create_internal(size_budget, info, initial_buffer){
    id_ref[1]++;
    var
     _ed_ = caml_call1(Core_Bag[22], 0),
     _ee_ = caml_call1(Async_kernel_Ivar[12], 0),
     _ef_ = caml_call1(Async_kernel_Ivar[12], 0),
     _eg_ = caml_call2(Core_Queue[66], 0, 0),
     _eh_ = caml_call2(Core_Queue[66], 0, 0),
     _ei_ = caml_call1(Async_kernel_Ivar[12], 0),
     t =
       [0,
        id_ref[1],
        info,
        initial_buffer,
        size_budget,
        0,
        _ei_,
        0,
        _eh_,
        _eg_,
        _ef_,
        _ee_,
        0,
        _ed_];
    return t;
   }
   function validate_size_budget(size_budget){
    if(! caml_call2(Async_kernel_Import[5], size_budget, 0))
     return size_budget;
    var
     _eb_ = [0, [1, [0, _aw_, [0, caml_call1(Core[389], size_budget), 0]]], 0],
     _ec_ =
       [1,
        [0, caml_call1(Sexplib0_Sexp_conv[7], cst_negative_size_budget), _eb_]];
    return caml_call1(Core[261], _ec_);
   }
   function create(size_budget, info, param){
    if(size_budget)
     var v = size_budget[1], size_budget$0 = validate_size_budget(v);
    else
     var size_budget$0 = 0;
    var
     t =
       create_internal(size_budget$0, info, caml_call2(Core_Queue[66], 0, 0));
    caml_call2(Async_kernel_Ivar[14], t[6], 0);
    if(check_invariant[1]) invariant$0(t);
    return [0, t, t];
   }
   function update_pushback(t){
    var _d9_ = effective_size_budget(t), _d__ = length(t);
    if(! caml_call2(Async_kernel_Import[2], _d__, _d9_) && ! is_closed(t)){
     var
      _d$_ = caml_call1(Async_kernel_Ivar[18], t[6]),
      _ea_ = _d$_ ? (t[6] = caml_call1(Async_kernel_Ivar[12], 0), 0) : _d$_;
     return _ea_;
    }
    return caml_call2(Async_kernel_Ivar[16], t[6], 0);
   }
   function close(t){
    if(show_debug_messages[1]){
     var
      _d6_ =
        function(x_080){
         function _d8_(param){return _ax_;}
         return sexp_of_pipe(function(param){return _ay_;}, _d8_, x_080);
        };
     caml_call3(Async_kernel_Import[14], cst_close, t, _d6_);
    }
    if(check_invariant[1]) invariant$0(t);
    var _d7_ = 1 - is_closed(t);
    if(! _d7_) return _d7_;
    caml_call2(Async_kernel_Ivar[14], t[10], 0);
    if(is_empty(t)){
     caml_call2(Core_Queue[18], t[9], fill_with_eof);
     caml_call1(Core_Queue[51], t[9]);
    }
    return update_pushback(t);
   }
   function close_read(t){
    if(show_debug_messages[1]){
     var
      _d2_ =
        function(x_081){
         function _d5_(param){return _az_;}
         return sexp_of_pipe(function(param){return _aA_;}, _d5_, x_081);
        };
     caml_call3(Async_kernel_Import[14], cst_close_read, t, _d2_);
    }
    if(check_invariant[1]) invariant$0(t);
    var _d3_ = 1 - is_read_closed(t);
    if(! _d3_) return _d3_;
    caml_call2(Async_kernel_Ivar[14], t[11], 0);
    function _d4_(flush){return fill(flush, -402004920);}
    caml_call2(Core_Queue[18], t[8], _d4_);
    caml_call1(Core_Queue[51], t[8]);
    caml_call1(Core_Queue[51], t[3]);
    t[5] = 0;
    update_pushback(t);
    return close(t);
   }
   function create_reader_not_close_on_exc(size_budget, f){
    var match = create(size_budget, 0, 0), w = match[2], r = match[1];
    function _d0_(param){return close(w);}
    var _d1_ = caml_call1(f, w);
    caml_call2(Async_kernel_Deferred_std[11], _d1_, _d0_);
    return r;
   }
   function create_reader(size_budget, close_on_exception, f){
    if(! close_on_exception)
     return create_reader_not_close_on_exc(size_budget, f);
    var match = create(size_budget, 0, 0), w = match[2], r = match[1];
    function _dX_(param){
     close(w);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    function _dY_(param){return caml_call1(f, w);}
    var
     _dZ_ = caml_call8(Async_kernel_Monitor[23], 0, 0, 0, 0, 0, 0, _dY_, _dX_);
    caml_call1(Async_kernel_Deferred_std[8], _dZ_);
    return r;
   }
   function create_writer(size_budget, f){
    var match = create(size_budget, 0, 0), w = match[2], r = match[1];
    function _dU_(param){
     close_read(r);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    function _dV_(param){return caml_call1(f, r);}
    var
     _dW_ = caml_call8(Async_kernel_Monitor[23], 0, 0, 0, 0, 0, 0, _dV_, _dU_);
    caml_call1(Async_kernel_Deferred_std[8], _dW_);
    return w;
   }
   function consumed_values_sent_downstrea(t){
    return caml_call1(Core_List[18], t[12])
            ? caml_call1(Async_kernel_Deferred_std[10], 17724)
            : combine
              (caml_call2
                (Core_List[51], t[12], values_sent_downstream_and_flu));
   }
   function values_were_read(t, consumer){
    caml_call2(Core_Option[46], consumer, start);
    var
     values_flushed =
       [246, function(_dT_){return consumed_values_sent_downstrea(t);}];
    function _dR_(flush){
     return caml_call2(Async_kernel_Import[1], t[7], flush[1]);
    }
    function _dS_(flush){
     function f(flush_result){return fill(flush, flush_result);}
     var
      d = caml_call1(Core[248], values_flushed),
      match = caml_call1(Async_kernel_Deferred[5], d);
     if(! match) return caml_call2(Async_kernel_Deferred_std[11], d, f);
     var v = match[1];
     return f(v);
    }
    return caml_call3(Core_Queue[48], t[8], _dS_, _dR_);
   }
   function consume_one(t, consumer){
    var _dQ_ = length(t);
    if(! caml_call2(Async_kernel_Import[1], _dQ_, 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _aB_], 1);
    var result = caml_call1(Core_Queue[46], t[3]);
    update_num_values_read(t, 1);
    values_were_read(t, consumer);
    update_pushback(t);
    return result;
   }
   function consume(t, max_queue_length, consumer){
    if(! caml_call2(Async_kernel_Import[1], max_queue_length, 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _aC_], 1);
    var _dP_ = length(t);
    if(caml_call2(Async_kernel_Import[1], max_queue_length, _dP_)){
     var result = t[3];
     t[3] = caml_call2(Core_Queue[66], 0, 0);
     update_num_values_read(t, caml_call1(Core_Queue[16], result));
     values_were_read(t, consumer);
     update_pushback(t);
     return result;
    }
    update_num_values_read(t, max_queue_length);
    values_were_read(t, consumer);
    var result$0 = caml_call2(Core_Queue[66], [0, max_queue_length], 0);
    caml_call4(Core_Queue[74], t[3], result$0, [0, max_queue_length], 0);
    update_pushback(t);
    return result$0;
   }
   function set_size_budget$0(t, size_budget){
    var size_budget$0 = validate_size_budget(size_budget);
    t[4] = size_budget$0;
    return update_pushback(t);
   }
   function reserve_space(t, n){
    if(caml_call2(Async_kernel_Import[5], n, 0)){
     var
      _dK_ = [0, [1, [0, _aD_, [0, caml_call1(Core[389], n), 0]]], 0],
      _dL_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_reserving_negative_space),
          _dK_]];
     caml_call1(Core[261], _dL_);
    }
    var reserved_space = t[5] + n | 0;
    if(caml_call2(Async_kernel_Import[5], reserved_space, 0)){
     var
      _dM_ = [0, [1, [0, _aE_, [0, caml_call1(Core[389], n), 0]]], 0],
      _dN_ = [0, [1, [0, _aF_, [0, caml_call1(Core[389], t[5]), 0]]], _dM_],
      _dO_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_overflow_when_reserving_sp),
          _dN_]];
     caml_call1(Core[261], _dO_);
    }
    t[5] = reserved_space;
    return update_pushback(t);
   }
   function decrease_reserved_space(t, n){
    t[5] = caml_call2(Core_Int[90], 0, t[5] - n | 0);
    return;
   }
   function start_write(x_083, size){
    if(show_debug_messages[1]){
     var
      _dD_ =
        function(x_082){
         function _dJ_(param){return _aG_;}
         return sexp_of_pipe(function(param){return _aH_;}, _dJ_, x_082);
        };
     caml_call3(Async_kernel_Import[14], cst_write, x_083, _dD_);
    }
    if(check_invariant[1]) invariant$0(x_083);
    if(is_closed(x_083)){
     var
      _dE_ = 0,
      _dF_ = 0,
      _dG_ = function(param){return _aI_;},
      _dH_ =
        [0,
         [1,
          [0,
           _aK_,
           [0, sexp_of_pipe(function(param){return _aJ_;}, _dG_, x_083), _dF_]]],
         _dE_],
      _dI_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_write_to_closed_pipe),
          _dH_]];
     caml_call1(Core[261], _dI_);
    }
    return decrease_reserved_space(x_083, size);
   }
   function finish_write(t){
    for(;;){
     if(! caml_call1(Core_Queue[17], t[9]) && ! is_empty(t)){
      var
       blocked_read = caml_call1(Core_Queue[46], t[9]),
       consumer = blocked_read[2],
       match = blocked_read[1];
      switch(match[0]){
        case 0:
         var ivar = match[1];
         caml_call2(Async_kernel_Ivar[14], ivar, 17724);
         break;
        case 1:
         var ivar$0 = match[1], _dB_ = [0, 17724, consume_one(t, consumer)];
         caml_call2(Async_kernel_Ivar[14], ivar$0, _dB_);
         break;
        default:
         var
          ivar$1 = match[2],
          max_queue_length = match[1],
          _dC_ = [0, 17724, consume(t, max_queue_length, consumer)];
         caml_call2(Async_kernel_Ivar[14], ivar$1, _dC_);
      }
      continue;
     }
     return update_pushback(t);
    }
   }
   function transfer_in_without_pushback(t, from){
    start_write(t, caml_call1(Core_Queue[16], from));
    caml_call4(Core_Queue[74], from, t[3], 0, 0);
    return finish_write(t);
   }
   function transfer_in(t, from){
    transfer_in_without_pushback(t, from);
    return pushback$1(t);
   }
   function write(t, q){return transfer_in(t, q);}
   function write_without_pushback(t, value){
    start_write(t, 1);
    caml_call2(Core_Queue[43], t[3], value);
    return finish_write(t);
   }
   function write$0(t, value){
    write_without_pushback(t, value);
    return pushback$1(t);
   }
   function write_when_ready(t, f){
    function _dz_(param){
     return is_closed(t)
             ? -1025106484
             : [0,
               17724,
               caml_call1
                (f, function(x){return write_without_pushback(t, x);})];
    }
    var _dA_ = pushback$1(t);
    return caml_call2(Async_kernel_Deferred_std[5][2], _dA_, _dz_);
   }
   function write_if_open(t, x){
    return is_closed(t)
            ? caml_call1(Async_kernel_Deferred_std[10], 0)
            : write$0(t, x);
   }
   function write_without_pushback_if_open(t, x){
    var _dy_ = 1 - is_closed(t);
    return _dy_ ? write_without_pushback(t, x) : _dy_;
   }
   function ensure_consumer_matches(consumer, x_085){
    if(! consumer) return;
    var
     consumer$0 = consumer[1],
     _ds_ = caml_call2(Async_kernel_Import[6], x_085[1], consumer$0[1]);
    if(! _ds_) return _ds_;
    var
     _dt_ = 0,
     _du_ = 0,
     _dv_ =
       [0,
        [1,
         [0,
          _aM_,
          [0, sexp_of_t$3(function(param){return _aL_;}, x_085), _du_]]],
        _dt_],
     _dw_ = [0, [1, [0, _aN_, [0, sexp_of_t$0(consumer$0), 0]]], _dv_],
     _dx_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Attempt_to_use_consumer_wi),
         _dw_]];
    return caml_call1(Core[261], _dx_);
   }
   function start_read(consumer, t, label){
    if(show_debug_messages[1]){
     var
      _dq_ =
        function(x_086){
         function _dr_(param){return _aO_;}
         return sexp_of_pipe(function(param){return _aP_;}, _dr_, x_086);
        };
     caml_call3(Async_kernel_Import[14], label, t, _dq_);
    }
    if(check_invariant[1]) invariant$0(t);
    return ensure_consumer_matches(consumer, t);
   }
   function gen_read_now(consumer, t, consume){
    start_read(consumer, t, cst_read_now);
    if(is_empty(t)) return is_closed(t) ? 3456156 : -445537353;
    if(caml_call1(Core_Queue[17], t[9]))
     return [0, 17724, caml_call2(consume, t, consumer)];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _aQ_], 1);
   }
   function get_max_queue_length(max_queue_length){
    if(! max_queue_length) return Core_Int[45];
    var max_queue_length$0 = max_queue_length[1];
    if(caml_call2(Async_kernel_Import[2], max_queue_length$0, 0)){
     var
      _do_ =
        [0,
         [1, [0, _aR_, [0, caml_call1(Core[389], max_queue_length$0), 0]]],
         0],
      _dp_ =
        [1,
         [0, caml_call1(Sexplib0_Sexp_conv[7], cst_max_queue_length_0), _do_]];
     caml_call1(Core[261], _dp_);
    }
    return max_queue_length$0;
   }
   function read_now(consumer, max_queue_length, t){
    var max_queue_length$0 = get_max_queue_length(max_queue_length);
    return gen_read_now
            (consumer,
             t,
             function(t, consumer){
              return consume(t, max_queue_length$0, consumer);
             });
   }
   function read_now$0(consumer, t){
    return gen_read_now(consumer, t, consume_one);
   }
   function read_now_exn(consumer, t){
    var match = read_now$0(consumer, t);
    if(typeof match !== "number"){var a = match[2]; return a;}
    if(3456156 <= match){
     var
      _dm_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_now_exn_received);
     return caml_call1(Core[261], _dm_);
    }
    var
     _dn_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_now_exn_nothing_);
    return caml_call1(Core[261], _dn_);
   }
   function peek(t){return caml_call1(Core_Queue[49], t[3]);}
   function clear(t){read_now(0, 0, t); return 0;}
   function read(consumer, max_queue_length, t){
    var max_queue_length$0 = get_max_queue_length(max_queue_length);
    start_read(consumer, t, cst_read);
    var r = read_now(consumer, [0, max_queue_length$0], t);
    if(typeof r === "number" && 3456156 > r){
     var
      _dl_ =
        function(ivar){
         return caml_call2
                 (Core_Queue[43],
                  t[9],
                  [0, [2, max_queue_length$0, ivar], consumer]);
        };
     return caml_call1(Async_kernel_Deferred[3], _dl_);
    }
    return caml_call1(Async_kernel_Deferred_std[10], r);
   }
   function read$0(consumer, t){
    start_read(consumer, t, cst_read$0);
    if(is_empty(t)){
     if(is_closed(t))
      return caml_call1(Async_kernel_Deferred_std[10], 3456156);
     var
      _dj_ =
        function(ivar){
         return caml_call2(Core_Queue[43], t[9], [0, [1, ivar], consumer]);
        };
     return caml_call1(Async_kernel_Deferred[3], _dj_);
    }
    if(! caml_call1(Core_Queue[17], t[9]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _aS_], 1);
    var _dk_ = [0, 17724, consume_one(t, consumer)];
    return caml_call1(Async_kernel_Deferred_std[10], _dk_);
   }
   function read_exn(consumer, t){
    function _dg_(param){
     if(typeof param === "number"){
      var
       _di_ =
         caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_exn_received_EOF);
      return caml_call1(Core[261], _di_);
     }
     var value = param[2];
     return value;
    }
    var _dh_ = read$0(consumer, t);
    return caml_call2(Async_kernel_Deferred_std[5][2], _dh_, _dg_);
   }
   function values_available(t){
    start_read(0, t, cst_values_available);
    if(! is_empty(t)) return caml_call1(Async_kernel_Deferred_std[10], 17724);
    if(is_closed(t))
     return caml_call1(Async_kernel_Deferred_std[10], 3456156);
    var match = caml_call1(Core_Queue[67], t[9]);
    if(match){
     var _dd_ = match[1], _de_ = _dd_[1];
     if(0 === _de_[0] && ! _dd_[2]){
      var ivar = _de_[1];
      return caml_call1(Async_kernel_Ivar[19], ivar);
     }
    }
    function _df_(ivar){
     return caml_call2(Core_Queue[43], t[9], [0, [0, ivar], 0]);
    }
    return caml_call1(Async_kernel_Deferred[3], _df_);
   }
   function read_choice(t){
    function _db_(param){return read_now$0(0, t);}
    var _dc_ = values_available(t);
    return caml_call2(Async_kernel_Deferred_std[6], _dc_, _db_);
   }
   function read_choice_single_consumer_ex(t, here){
    function _c9_(x){
     if(typeof x === "number" && 3456156 > x){
      var
       _c$_ =
         [0,
          [1,
           [0, _aT_, [0, caml_call1(Core_Source_code_position[1], here), 0]]],
          0],
       _da_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_choice_single_co),
           _c$_]];
      return caml_call1(Core[261], _da_);
     }
     return x;
    }
    var _c__ = read_choice(t);
    return caml_call2(Async_kernel_Deferred[26][1], _c__, _c9_);
   }
   function read_exactly(consumer, t, num_values){
    start_read(consumer, t, cst_read_exactly);
    if(caml_call2(Async_kernel_Import[2], num_values, 0)){
     var
      _c3_ = [0, [1, [0, _aU_, [0, caml_call1(Core[389], num_values), 0]]], 0],
      _c4_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_exactly_got_num_),
          _c3_]];
     caml_call1(Core[261], _c4_);
    }
    function _c5_(finish){
     var result = caml_call2(Core_Queue[66], 0, 0);
     function loop(param){
      var already_read = caml_call1(Core_Queue[16], result);
      if(! caml_call2(Async_kernel_Import[2], already_read, num_values))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _aV_], 1);
      if(caml_call2(Async_kernel_Import[3], already_read, num_values))
       return caml_call2
               (Async_kernel_Ivar[14], finish, [0, -876407060, result]);
      function _c6_(param){
       if(typeof param === "number"){
        var
         _c8_ =
           caml_call2(Async_kernel_Import[3], already_read, 0)
            ? 3456156
            : [0, 287952037, result];
        return caml_call2(Async_kernel_Ivar[14], finish, _c8_);
       }
       var q = param[2];
       caml_call4(Core_Queue[74], q, result, 0, 0);
       return loop(0);
      }
      var _c7_ = read(consumer, [0, num_values - already_read | 0], t);
      return caml_call2(Async_kernel_Deferred_std[1], _c7_, _c6_);
     }
     return loop(0);
    }
    return caml_call1(Async_kernel_Deferred[3], _c5_);
   }
   function downstream_flushed(t){
    if(is_empty(t)) return consumed_values_sent_downstrea(t);
    function _c1_(ready){
     var _c2_ = length(t);
     return caml_call2(Core_Queue[43], t[8], [0, t[7] + _c2_ | 0, ready]);
    }
    return caml_call1(Async_kernel_Deferred[3], _c1_);
   }
   function upstream_flushed(t){
    if(caml_call1(Core_Bag[6], t[13])) return downstream_flushed(t);
    function _cZ_(f){return caml_call1(f, 0);}
    var _c0_ = caml_call1(Core_Bag[17], t[13]);
    return combine(caml_call2(Core_List[51], _c0_, _cZ_));
   }
   function add_consumer(t, downstream_flushed){
    var
     pipe_id = t[1],
     consumer = [0, pipe_id, -758792467, downstream_flushed];
    t[12] = [0, consumer, t[12]];
    return consumer;
   }
   function consumer$1(param){var t = param[1]; return t[2];}
   function create$0(upstream, downstream){
    function upstream_flushed$0(param){return upstream_flushed(upstream);}
    var _cY_ = caml_call2(Core_Bag[23], downstream[13], upstream_flushed$0);
    return [0,
            [0,
             downstream,
             add_consumer
              (upstream,
               function(param){return downstream_flushed(downstream);}),
             _cY_]];
   }
   function sexp_of_t$5(param){
    if(typeof param === "number") return param ? _aW_ : _aX_;
    var arg0_087 = param[1], res0_088 = sexp_of_t$0(arg0_087);
    return [1, [0, _aY_, [0, res0_088, 0]]];
   }
   var Flushed = [0, sexp_of_t$5];
   function fold_gen(read_now, opt, t, init, f){
    if(opt) var sth = opt[1], flushed = sth; else var flushed = 1;
    if(typeof flushed === "number")
     var
      consumer =
        flushed
         ? 0
         : [0,
           add_consumer
            (t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 17724);
             })];
    else
     var consumer$0 = flushed[1], consumer = [0, consumer$0];
    if(check_invariant[1]) invariant$0(t);
    ensure_consumer_matches(consumer, t);
    function _cT_(finished){
     function _cU_(param){
      function loop(b){
       var match = caml_call2(read_now, consumer, t);
       if(typeof match !== "number"){
        var v = match[2];
        return caml_call3(f, b, v, continue$0);
       }
       if(3456156 <= match)
        return caml_call2(Async_kernel_Ivar[14], finished, b);
       function _cW_(param){return loop(b);}
       var _cX_ = values_available(t);
       return caml_call2(Async_kernel_Deferred_std[1], _cX_, _cW_);
      }
      function continue$0(b){
       caml_call2(Core_Option[46], consumer, values_sent_downstream);
       return loop(b);
      }
      return loop(init);
     }
     var _cV_ = values_available(t);
     return caml_call2(Async_kernel_Deferred_std[1], _cV_, _cU_);
    }
    return caml_call1(Async_kernel_Deferred[3], _cT_);
   }
   function fold(flushed, max_queue_length, t, init, f){
    function _cP_(b, q, loop){
     var _cS_ = caml_call2(f, b, q);
     return caml_call2(Async_kernel_Deferred_std[1], _cS_, loop);
    }
    return fold_gen
            (function(_cQ_){
              return function(_cR_){
               return read_now(_cQ_, max_queue_length, _cR_);};
             },
             flushed,
             t,
             init,
             _cP_);
   }
   function fold$0(flushed, t, init, f){
    return fold_gen
            (read_now$0,
             flushed,
             t,
             init,
             function(b, a, loop){
              var _cO_ = caml_call2(f, b, a);
              return caml_call2(Async_kernel_Deferred_std[1], _cO_, loop);
             });
   }
   function fold_without_pushback(consumer, t, init, f){
    function _cM_(b, a, loop){return caml_call1(loop, caml_call2(f, b, a));}
    if(consumer) var c = consumer[1], _cN_ = [0, [0, c]]; else var _cN_ = 0;
    return fold_gen(read_now$0, _cN_, t, init, _cM_);
   }
   function with_error_to_current_monitor(opt, f, a){
    if(opt)
     var sth = opt[1], continue_on_error = sth;
    else
     var continue_on_error = 0;
    if(! continue_on_error) return caml_call1(f, a);
    function _cH_(param){
     if(0 === param[0]) return 0;
     var
      exn = param[1],
      _cK_ = caml_call1(Async_kernel_Monitor[13], exn),
      _cL_ = caml_call1(Async_kernel_Monitor[5], 0);
     return caml_call3(Async_kernel_Monitor[15], _cL_, 0, _cK_);
    }
    function _cI_(param){return caml_call1(f, a);}
    var
     _cJ_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _a0_, _aZ_, _cI_);
    return caml_call2(Async_kernel_Deferred_std[5][2], _cJ_, _cH_);
   }
   function iter(continue_on_error, flushed, max_queue_length, t, f){
    return fold
            (flushed,
             max_queue_length,
             t,
             0,
             function(param, q){
              return with_error_to_current_monitor(continue_on_error, f, q);
             });
   }
   function iter$0(continue_on_error, flushed, t, f){
    return fold_gen
            (read_now$0,
             flushed,
             t,
             0,
             function(param, a, loop){
              function _cF_(param){return caml_call1(loop, 0);}
              var
               _cG_ = with_error_to_current_monitor(continue_on_error, f, a);
              return caml_call2(Async_kernel_Deferred_std[1], _cG_, _cF_);
             });
   }
   function iter_without_pushback(consumer, opt, max_iterations_per_job, t, f){
    if(opt)
     var sth = opt[1], continue_on_error = sth;
    else
     var continue_on_error = 0;
    ensure_consumer_matches(consumer, t);
    if(max_iterations_per_job){
     var max_iterations_per_job$0 = max_iterations_per_job[1];
     if(caml_call2(Async_kernel_Import[2], max_iterations_per_job$0, 0)){
      var
       _cv_ =
         [0,
          [1,
           [0, _a1_, [0, caml_call1(Core[389], max_iterations_per_job$0), 0]]],
          0],
       _cw_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_iter_without_pushback_got_),
           _cv_]];
      caml_call1(Core[261], _cw_);
     }
     var max_iterations_per_job$1 = max_iterations_per_job$0;
    }
    else
     var max_iterations_per_job$1 = Core_Int[45];
    var
     f$0 =
       continue_on_error
        ? function
         (a){
          try{caml_call1(f, a); return;}
          catch(exn$0){
           var
            exn = caml_wrap_exception(exn$0),
            _cE_ = caml_call1(Async_kernel_Monitor[5], 0);
           return caml_call3(Async_kernel_Monitor[15], _cE_, 0, exn);
          }
         }
        : f;
    function _cx_(finished){
     function _cy_(param){
      function start(param){
       var remaining = max_iterations_per_job$1;
       for(;;){
        if(caml_call2(Async_kernel_Import[3], remaining, 0)){
         var
          _cA_ = function(param){return start(0);},
          _cB_ = caml_call1(Async_kernel_Deferred_std[10], 0);
         return caml_call2(Async_kernel_Deferred_std[1], _cB_, _cA_);
        }
        var match = read_now$0(consumer, t);
        if(typeof match === "number"){
         if(3456156 <= match)
          return caml_call2(Async_kernel_Ivar[14], finished, 0);
         var
          _cC_ = function(param){return start(0);},
          _cD_ = values_available(t);
         return caml_call2(Async_kernel_Deferred_std[1], _cD_, _cC_);
        }
        var a = match[2];
        caml_call1(f$0, a);
        var remaining$0 = remaining - 1 | 0, remaining = remaining$0;
       }
      }
      return start(0);
     }
     var _cz_ = values_available(t);
     return caml_call2(Async_kernel_Deferred_std[1], _cz_, _cy_);
    }
    return caml_call1(Async_kernel_Deferred[3], _cx_);
   }
   function drain(t){
    return iter
            (0,
             0,
             0,
             t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function drain_and_count(t){
    return fold
            (0,
             0,
             t,
             0,
             function(sum, q){
              var _cu_ = sum + caml_call1(Core_Queue[16], q) | 0;
              return caml_call1(Async_kernel_Deferred_std[10], _cu_);
             });
   }
   function read_all(input){
    var result = caml_call2(Core_Queue[66], 0, 0);
    function _cs_(param){return result;}
    var
     _ct_ =
       iter
        (0,
         0,
         0,
         input,
         function(q){
          caml_call4(Core_Queue[74], q, result, 0, 0);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    return caml_call2(Async_kernel_Deferred_std[5][2], _ct_, _cs_);
   }
   function to_list(r){
    var _cq_ = Core_Queue[28], _cr_ = read_all(r);
    return caml_call2(Async_kernel_Deferred_std[4], _cr_, _cq_);
   }
   function to_stream_deprecated(t){
    function _cn_(tail){
     function _co_(param){return caml_call1(Async_kernel_Tail[4], tail);}
     var
      _cp_ =
        iter_without_pushback
         (0,
          0,
          0,
          t,
          function(x){return caml_call2(Async_kernel_Tail[3], tail, x);});
     return caml_call2(Async_kernel_Deferred_std[1], _cp_, _co_);
    }
    return caml_call1(Async_kernel_Async_stream[2], _cn_);
   }
   function of_stream_deprecated(s){
    var
     match = create(0, 0, 0),
     w = match[2],
     r = match[1],
     q = caml_call2(Core_Queue[66], 0, 0);
    function transfer(param){
     var _cl_ = 1 - caml_call1(Core_Queue[17], q);
     if(! _cl_) return _cl_;
     var _cm_ = write(w, q);
     return caml_call1(Async_kernel_Deferred_std[8], _cm_);
    }
    function loop$0(counter, s){
     if(is_closed(w))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a2_], 1);
     var
      next_deferred = caml_call1(Async_kernel_Async_stream[3], s),
      match = caml_call1(Async_kernel_Deferred[5], next_deferred);
     if(! match){
      transfer(0);
      return caml_call2
              (Async_kernel_Deferred_std[11],
               next_deferred,
               check_closed_loop_next);
     }
     var next = match[1];
     if(counter >= 50) return caml_trampoline_return(loop_next$0, [0, next]);
     var counter$0 = counter + 1 | 0;
     return loop_next$0(counter$0, next);
    }
    function loop_next$0(counter, param){
     if(! param){transfer(0); return close(w);}
     var s = param[2], x = param[1];
     caml_call2(Core_Queue[43], q, x);
     if(counter >= 50) return caml_trampoline_return(loop$0, [0, s]);
     var counter$0 = counter + 1 | 0;
     return loop$0(counter$0, s);
    }
    function loop(s){return caml_trampoline(loop$0(0, s));}
    function loop_next(param){return caml_trampoline(loop_next$0(0, param));}
    function check_closed_loop_next(next){
     var _ck_ = 1 - is_closed(w);
     return _ck_ ? loop_next(next) : _ck_;
    }
    loop(s);
    return r;
   }
   function transfer_gen(read_now, write, input, output, f){
    if(check_invariant[1]){invariant$0(input); invariant$0(output);}
    var link = create$0(input, output), consumer = consumer$1(link);
    function unlink(param){
     var t = link[1];
     return caml_call2(Core_Bag[26], t[1][13], t[3]);
    }
    function _b7_(result){
     function input_available_or_output_clos(param){
      var _cb_ = 0;
      function _cc_(_cj_){return 0;}
      var
       _cd_ = closed(output),
       _ce_ = [0, caml_call2(Async_kernel_Deferred_std[6], _cd_, _cc_), _cb_];
      function _cf_(_ci_){return 0;}
      var
       _cg_ = values_available(input),
       _ch_ = [0, caml_call2(Async_kernel_Deferred_std[6], _cg_, _cf_), _ce_];
      return caml_call1(Async_kernel_Deferred_std[7], _ch_);
     }
     function _b8_(param){
      function output_closed(param){
       close_read(input);
       unlink(0);
       return caml_call2(Async_kernel_Ivar[14], result, 0);
      }
      function loop(param){
       if(is_closed(output)) return output_closed(0);
       var match = caml_call2(read_now, [0, consumer], input);
       if(typeof match !== "number"){
        var x = match[2];
        return caml_call2(f, x, continue$0);
       }
       if(3456156 <= match){
        unlink(0);
        return caml_call2(Async_kernel_Ivar[14], result, 0);
       }
       function _b$_(param){return loop(0);}
       var _ca_ = input_available_or_output_clos(0);
       return caml_call2(Async_kernel_Deferred_std[1], _ca_, _b$_);
      }
      function continue$0(y){
       if(is_closed(output)) return output_closed(0);
       var pushback = caml_call2(write, output, y);
       values_sent_downstream(consumer);
       function _b__(param){return loop(0);}
       return caml_call2(Async_kernel_Deferred_std[1], pushback, _b__);
      }
      return loop(0);
     }
     var _b9_ = input_available_or_output_clos(0);
     return caml_call2(Async_kernel_Deferred_std[1], _b9_, _b8_);
    }
    return caml_call1(Async_kernel_Deferred[3], _b7_);
   }
   function transfer(max_queue_length, input, output, f){
    function _b3_(q, k){
     var _b6_ = caml_call1(f, q);
     return caml_call2(Async_kernel_Deferred_std[1], _b6_, k);
    }
    return transfer_gen
            (function(_b4_){
              return function(_b5_){
               return read_now(_b4_, max_queue_length, _b5_);};
             },
             write,
             input,
             output,
             _b3_);
   }
   function transfer$0(input, output, f){
    return transfer_gen
            (read_now$0,
             write$0,
             input,
             output,
             function(a, k){return caml_call1(k, caml_call1(f, a));});
   }
   function transfer_id(max_queue_length, input, output){
    function _b0_(q, k){return caml_call1(k, q);}
    return transfer_gen
            (function(_b1_){
              return function(_b2_){
               return read_now(_b1_, max_queue_length, _b2_);};
             },
             write,
             input,
             output,
             _b0_);
   }
   function map_gen(read, write, input, f){
    function _bX_(info){
     return [1, [0, _a3_, [0, caml_call1(Core_Sexp[93], info), 0]]];
    }
    var
     info = caml_call2(Core_Option[34], input[2], _bX_),
     match = create(0, info, 0),
     output = match[2],
     result = match[1];
    function _bY_(param){return close(output);}
    var _bZ_ = transfer_gen(read, write, input, output, f);
    caml_call2(Async_kernel_Deferred_std[11], _bZ_, _bY_);
    return result;
   }
   function map(max_queue_length, input, f){
    function _bT_(q, k){
     var _bW_ = caml_call1(f, q);
     return caml_call2(Async_kernel_Deferred_std[1], _bW_, k);
    }
    return map_gen
            (function(_bU_){
              return function(_bV_){
               return read_now(_bU_, max_queue_length, _bV_);};
             },
             write,
             input,
             _bT_);
   }
   function map$0(input, f){
    return map_gen
            (read_now$0,
             write$0,
             input,
             function(a, k){return caml_call1(k, caml_call1(f, a));});
   }
   function concat_map_list(max_queue_length, input, f){
    function _bQ_(q, k){
     return caml_call1(k, caml_call2(Core_Queue[55], q, f));
    }
    return map_gen
            (function(_bR_){
              return function(_bS_){
               return read_now(_bR_, max_queue_length, _bS_);};
             },
             write,
             input,
             _bQ_);
   }
   function filter_map(max_queue_length, input, f){
    return map
            (max_queue_length,
             input,
             function(q){
              return caml_call3
                      (Async_kernel_Deferred_queue[20], -686623969, q, f);
             });
   }
   function filter_map$0(max_queue_length, input, f){
    function _bM_(q, k){
     function _bP_(x){return is_read_closed(input) ? 0 : caml_call1(f, x);}
     return caml_call1(k, caml_call2(Core_Queue[57], q, _bP_));
    }
    return map_gen
            (function(_bN_){
              return function(_bO_){
               return read_now(_bN_, max_queue_length, _bO_);};
             },
             write,
             input,
             _bM_);
   }
   function folding_filter_map(max_queue_length, input, init, f){
    var accum = [0, init];
    return filter_map
            (max_queue_length,
             input,
             function(x){
              function _bK_(param){
               var x = param[2], a = param[1];
               accum[1] = a;
               return x;
              }
              var _bL_ = caml_call2(f, accum[1], x);
              return caml_call2(Async_kernel_Deferred_std[5][2], _bL_, _bK_);
             });
   }
   function folding_filter_map$0(max_queue_length, input, init, f){
    var accum = [0, init];
    return filter_map$0
            (max_queue_length,
             input,
             function(x){
              var
               match = caml_call2(f, accum[1], x),
               x$0 = match[2],
               a = match[1];
              accum[1] = a;
              return x$0;
             });
   }
   function folding_map(max_queue_length, input, init, f){
    return folding_filter_map$0
            (max_queue_length,
             input,
             init,
             function(accum, a){
              var
               match = caml_call2(f, accum, a),
               b = match[2],
               accum$0 = match[1];
              return [0, accum$0, [0, b]];
             });
   }
   function filter(input, f){
    return filter_map$0
            (0, input, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function of_queue_internal(queue){
    var t = create_internal(0, 0, queue);
    caml_call2(Async_kernel_Ivar[14], t[10], 0);
    update_pushback(t);
    return t;
   }
   function of_queue(queue){
    return of_queue_internal(caml_call1(Core_Queue[52], queue));
   }
   function of_list(l){
    return of_queue_internal(caml_call1(Core_Queue[40], l));
   }
   function empty(param){return of_list(0);}
   function singleton(x){
    var match = create(0, 0, 0), writer = match[2], reader = match[1];
    write_without_pushback(writer, x);
    close(writer);
    return reader;
   }
   function unfold(s, f){
    function symbol(d, f){
     var match = caml_call1(Async_kernel_Deferred[5], d);
     if(! match) return caml_call2(Async_kernel_Deferred_std[3], d, f);
     var x = match[1];
     return caml_call1(f, x);
    }
    return create_reader
            (0,
             0,
             function(writer){
              function loop(s){
               function _bI_(param){
                if(! param)
                 return caml_call1(Async_kernel_Deferred_std[10], 0);
                var match = param[1], s = match[2], a = match[1];
                if(is_closed(writer))
                 return caml_call1(Async_kernel_Deferred_std[10], 0);
                function _bJ_(param){return loop(s);}
                return symbol(write$0(writer, a), _bJ_);
               }
               return symbol(caml_call1(f, s), _bI_);
              }
              return loop(s);
             });
   }
   function of_sequence(sequence){
    return create_reader
            (0,
             0,
             function(writer){
              function loop(sequence$1){
               if
                (!
                 is_closed(writer)
                 && ! caml_call1(Core_Sequence[19], sequence$1)){
                start_write(writer, 0);
                var
                 _bF_ = length(writer),
                 i$1 = (1 + writer[4] | 0) - _bF_ | 0,
                 sequence = sequence$1,
                 i = i$1;
                for(;;){
                 if(! caml_call2(Async_kernel_Import[2], i, 0)){
                  var match = caml_call1(Core_Sequence[50], sequence);
                  if(match){
                   var
                    match$0 = match[1],
                    sequence$0 = match$0[2],
                    a = match$0[1];
                   decrease_reserved_space(writer, 1);
                   caml_call2(Core_Queue[43], writer[3], a);
                   var i$0 = i - 1 | 0, sequence = sequence$0, i = i$0;
                   continue;
                  }
                 }
                 finish_write(writer);
                 var
                  _bG_ = function(param){return loop(sequence);},
                  _bH_ = pushback$1(writer);
                 return caml_call2
                         (Async_kernel_Deferred_std[5][1], _bH_, _bG_);
                }
               }
               return caml_call1(Async_kernel_Deferred_std[10], 0);
              }
              return loop(sequence);
             });
   }
   function to_sequence(t){
    function _bE_(param){
     var match = read_now$0(0, t);
     if(typeof match === "number")
      return 3456156 <= match ? 0 : [0, [0, [1, values_available(t)], 0]];
     var a = match[2];
     return [0, [0, [0, a], 0]];
    }
    return caml_call2(Core_Sequence[52], 0, _bE_);
   }
   function interleave_pipe(opt, inputs){
    if(opt) var sth = opt[1], close_on = sth; else var close_on = -1005265340;
    var
     match =
       create
        (0, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_interleave)], 0),
     output_writer = match[2],
     output = match[1],
     num_pipes_remaining = [0, 1];
    function close_one_pipe(closed_pipe_kind){
     num_pipes_remaining[1] += -1;
     a:
     {
      if(-984089324 <= close_on && -500766471 > closed_pipe_kind){var should_close = 1; break a;}
      var
       should_close =
         caml_call2(Async_kernel_Import[3], num_pipes_remaining[1], 0);
     }
     return should_close ? close(output_writer) : should_close;
    }
    function _by_(param){return close_one_pipe(-500766471);}
    var
     _bz_ =
       iter_without_pushback
        (0,
         0,
         0,
         inputs,
         function(input){
          num_pipes_remaining[1]++;
          function _bB_(param){return close_one_pipe(-551064605);}
          var
           _bC_ = transfer_id(0, input, output_writer),
           _bD_ = caml_call2(Async_kernel_Deferred_std[5][2], _bC_, _bB_);
          return caml_call1(Async_kernel_Deferred_std[8], _bD_);
         }),
     _bA_ = caml_call2(Async_kernel_Deferred_std[5][2], _bz_, _by_);
    caml_call1(Async_kernel_Deferred_std[8], _bA_);
    return output;
   }
   function interleave(close_on, inputs){
    if(check_invariant[1]) caml_call2(Core_List[19], inputs, invariant$0);
    return interleave_pipe(close_on, of_list(inputs));
   }
   function merge(inputs, compare){
    if(! inputs) return empty(0);
    if(inputs[2]){
     var
      match = create(0, 0, 0),
      w = match[2],
      r = match[1],
      _bi_ =
        function(param){return caml_call2(Core_List[19], inputs, close_read);},
      _bj_ = closed(w);
     caml_call2(Async_kernel_Deferred_std[11], _bj_, _bi_);
     var
      _bk_ = 0,
      _bl_ =
        function(param, _bx_){
         var a2 = _bx_[1], a1 = param[1];
         return caml_call2(compare, a1, a2);
        },
      heap = caml_call3(Pairing_heap[20], 0, _bl_, _bk_),
      handle_read =
        function(input, eof_or_ok){
         if(typeof eof_or_ok === "number") return 0;
         var v = eof_or_ok[2];
         return caml_call2(Pairing_heap[25], heap, [0, v, input]);
        },
      pop_heap_and_loop =
        function(param){
         for(;;){
          var match = caml_call1(Pairing_heap[28], heap);
          if(! match) return close(w);
          var
           match$0 = match[1],
           input = match$0[2],
           v = match$0[1],
           _bp_ = 1 - is_closed(w);
          if(! _bp_) return _bp_;
          write_without_pushback(w, v);
          var _bq_ = caml_call1(Pairing_heap[3], heap);
          if(caml_call2(Async_kernel_Import[3], _bq_, 0)){
           var
            _br_ = function(param){return close(w);},
            _bs_ = transfer_id(0, input, w);
           return caml_call2(Async_kernel_Deferred_std[11], _bs_, _br_);
          }
          var x = read_now$0(0, input);
          if(typeof x === "number" && 3456156 > x){
           var
            _bt_ =
              function(param){
               function _bv_(x){
                handle_read(input, x);
                return pop_heap_and_loop(0);
               }
               var _bw_ = read$0(0, input);
               return caml_call2(Async_kernel_Deferred_std[1], _bw_, _bv_);
              },
            _bu_ = pushback$1(w);
           return caml_call2(Async_kernel_Deferred_std[1], _bu_, _bt_);
          }
          handle_read(input, x);
         }
        },
      _bm_ =
        function(input){
         function _bn_(x){return handle_read(input, x);}
         var _bo_ = read$0(0, input);
         return caml_call2(Async_kernel_Deferred_std[5][2], _bo_, _bn_);
        },
      initial_push =
        caml_call3(Async_kernel_Deferred_list[14], -686623969, inputs, _bm_);
     caml_call2
      (Async_kernel_Deferred_std[11], initial_push, pop_heap_and_loop);
     return r;
    }
    var input = inputs[1];
    return input;
   }
   function concat_pipe(inputs){
    var
     r =
       create_reader_not_close_on_exc
        (0,
         function(w){
          var link = create$0(inputs, w), consumer = consumer$1(link);
          return iter$0
                  (0,
                   [0, [0, consumer]],
                   inputs,
                   function(input){return transfer_id(0, input, w);});
         });
    function _bg_(param){return close(inputs);}
    var _bh_ = closed(r);
    caml_call2(Async_kernel_Deferred_std[11], _bh_, _bg_);
    return r;
   }
   function concat(inputs){
    return create_reader_not_close_on_exc
            (0,
             function(w){
              function _bf_(input){return transfer_id(0, input, w);}
              return caml_call3
                      (Async_kernel_Deferred_list[14], -686623969, inputs, _bf_);
             });
   }
   function fork(t, pushback_uses){
    var
     match = create(0, 0, 0),
     writer0 = match[2],
     reader0 = match[1],
     match$0 = create(0, 0, 0),
     writer1 = match$0[2],
     reader1 = match$0[1],
     some_reader_was_closed = [0, 0],
     consumer =
       add_consumer
        (t,
         function(param){
          var some_reader_was_closed$0 = some_reader_was_closed[1];
          function _bc_(param){
           return 17724 <= param
                   ? some_reader_was_closed$0 ? -402004920 : 17724
                   : -402004920;
          }
          var
           _bd_ = [0, downstream_flushed(writer1), 0],
           _be_ = combine([0, downstream_flushed(writer0), _bd_]);
          return caml_call2(Async_kernel_Deferred_std[5][2], _be_, _bc_);
         }),
     still_open = [0, writer0, [0, writer1, 0]];
    function filter_open(still_open){
     if(! caml_call2(Core_List[23], still_open, is_closed)) return still_open;
     some_reader_was_closed[1] = 1;
     function _bb_(w){return 1 - is_closed(w);}
     var still_open$0 = caml_call2(Core_List[12], still_open, _bb_);
     if(caml_call1(Core_List[18], still_open$0)) close(t);
     return still_open$0;
    }
    function _a4_(still_open){
     caml_call2(Core_List[19], still_open, close);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    var
     _a5_ =
       fold
        ([0, [0, consumer]],
         0,
         t,
         still_open,
         function(still_open, queue){
          var still_open$0 = filter_open(still_open);
          if(caml_call1(Core_List[18], still_open$0))
           return caml_call1(Async_kernel_Deferred_std[10], 0);
          function _a7_(param){
           var still_open = filter_open(still_open$0);
           function _a$_(w){
            start_write(w, caml_call1(Core_Queue[16], queue));
            function _ba_(x){return caml_call2(Core_Queue[43], w[3], x);}
            caml_call2(Core_Queue[18], queue, _ba_);
            return finish_write(w);
           }
           caml_call2(Core_List[19], still_open, _a$_);
           return still_open;
          }
          if(-648027566 <= pushback_uses)
           var
            _a8_ = caml_call2(Core_List[51], still_open$0, pushback$1),
            _a9_ = caml_call1(Async_kernel_Deferred[23], _a8_);
          else
           var
            _a__ = caml_call2(Core_List[51], still_open$0, pushback$1),
            _a9_ = caml_call1(Async_kernel_Deferred[22], _a__);
          return caml_call2(Async_kernel_Deferred_std[5][2], _a9_, _a7_);
         }),
     _a6_ = caml_call2(Async_kernel_Deferred_std[5][1], _a5_, _a4_);
    caml_call1(Async_kernel_Deferred_std[8], _a6_);
    return [0, reader0, reader1];
   }
   function set_info(t, info){var v = [0, info]; t[2] = v; return 0;}
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Pipe);
   var
    Async_kernel_Pipe =
      [0,
       sexp_of_pipe,
       sexp_of_pipe,
       [0, sexp_of_t$4, invariant$0],
       [0, sexp_of_t$3, invariant$0],
       create_reader,
       create_writer,
       create,
       empty,
       of_queue,
       of_list,
       singleton,
       unfold,
       of_sequence,
       to_sequence,
       close,
       close_read,
       is_closed,
       closed,
       [0, compare, equal, sexp_of_t],
       upstream_flushed,
       downstream_flushed,
       [0, values_sent_downstream],
       add_consumer,
       length,
       is_empty,
       num_values_read,
       num_values_written,
       pushback$1,
       write$0,
       write_without_pushback,
       transfer_in,
       transfer_in_without_pushback,
       write_when_ready,
       write_if_open,
       write_without_pushback_if_open,
       read,
       read$0,
       read_exn,
       read_exactly,
       read_now,
       read_now$0,
       read_now_exn,
       peek,
       clear,
       read_all,
       values_available,
       read_choice,
       read_choice_single_consumer_ex,
       Flushed,
       fold,
       fold$0,
       fold_without_pushback,
       iter,
       iter$0,
       iter_without_pushback,
       transfer,
       transfer$0,
       transfer_id,
       map,
       map$0,
       concat_map_list,
       folding_map,
       filter_map,
       filter_map$0,
       folding_filter_map,
       folding_filter_map$0,
       filter,
       interleave,
       interleave_pipe,
       merge,
       concat,
       concat_pipe,
       fork,
       to_stream_deprecated,
       of_stream_deprecated,
       drain,
       drain_and_count,
       to_list,
       hash,
       equal$0,
       compare$0,
       size_budget,
       set_size_budget$0,
       reserved_space,
       reserve_space,
       show_debug_messages,
       check_invariant,
       set_info];
   runtime.caml_register_global
    (170, Async_kernel_Pipe, cst_Async_kernel_Pipe$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Mvar
//# unitInfo: Requires: Async_kernel__Bvar, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Pipe, Base__Invariant, Core, Core__Unit, Moption, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Mvar$0 = "Async_kernel__Mvar",
    cst_async_kernel$0 = "async_kernel",
    cst_current_value$0 = "current_value",
    cst_src_mvar_ml = "src/mvar.ml",
    cst_taken$0 = "taken",
    cst_value_available$0 = "value_available",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/mvar.ml:23:26",
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Pipe = global_data.Async_kernel__Pipe,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Moption = global_data.Moption,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_Unit = global_data.Core__Unit,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Mvar$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_mvar_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "mvar.ml");
   var
    cst_Mvar_take_exn_called_on_em = "Mvar.take_exn called on empty mvar",
    _l_ = [0, cst_src_mvar_ml, 60, 2],
    cst_Mvar_peek_exn_called_on_em = "Mvar.peek_exn called on empty mvar",
    _j_ = [0, "_"],
    _k_ = [0, cst_src_mvar_ml, 16, 373, 395],
    _g_ = [0, cst_value_available$0],
    _h_ = [0, cst_taken$0],
    _i_ = [0, cst_current_value$0],
    cst_value_available = cst_value_available$0,
    cst_taken = cst_taken$0,
    cst_current_value = cst_current_value$0,
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Mvar = cst_Async_kernel_Mvar$0;
   function value_available(r){return r[3];}
   function set_value_available(r, v){r[3] = v; return 0;}
   function taken(r){return r[2];}
   function current_value(r){return r[1];}
   function _a_(r, v){return [0, r[1], r[2], v];}
   var
    _b_ = [0, set_value_available],
    value_available$0 =
      [0,
       function(param){return 0;},
       cst_value_available,
       _b_,
       value_available,
       _a_];
   function _c_(r, v){return [0, r[1], v, r[3]];}
   var
    _d_ = 0,
    taken$0 = [0, function(param){return 0;}, cst_taken, _d_, taken, _c_];
   function _e_(r, v){return [0, v, r[2], r[3]];}
   var
    _f_ = 0,
    current_value$0 =
      [0,
       function(param){return 0;},
       cst_current_value,
       _f_,
       current_value,
       _e_];
   function value_available$1(t){
    return caml_call1(Async_kernel_Ivar[19], t[3]);
   }
   function is_empty(t){return caml_call1(Moption[14], t[1]);}
   function invariant(invariant_a, param, t){
    function _C_(param){
     function check(f){return caml_call2(Base_Invariant[2], t, f);}
     var
      value_available_fun =
        check
         (function(value_available){
           var
            got = caml_call1(Async_kernel_Ivar[18], value_available),
            expect = caml_call1(Moption[15], t[1]),
            sexpifier = Core[323],
            equal = 0,
            message = 0,
            here = 0;
           function comparator(a_011, b_012){
            return caml_call2(Core[316], a_011, b_012);
           }
           return caml_call8
                   (Ppx_assert_lib_Runtime[3],
                    pos,
                    sexpifier,
                    comparator,
                    here,
                    message,
                    equal,
                    expect,
                    got);
          });
     function _E_(_F_){return 0;}
     var
      taken_fun = check(caml_call2(Async_kernel_Bvar[2], Core_Unit[8], _E_)),
      current_value_fun = check(caml_call1(Moption[11], invariant_a));
     caml_call1(current_value_fun, current_value$0);
     caml_call1(taken_fun, taken$0);
     return caml_call1(value_available_fun, value_available$0);
    }
    function _D_(x_010){
     function of_a_001(param){return _j_;}
     var
      taken_006 = x_010[2],
      current_value_004 = x_010[1],
      value_available_008 = x_010[3],
      arg_009 =
        caml_call2(Async_kernel_Ivar[9], Core[620], value_available_008),
      bnds_003 = [0, [1, [0, _g_, [0, arg_009, 0]]], 0],
      arg_007 =
        caml_call3(Async_kernel_Bvar[1], Core[620], Core[212], taken_006),
      bnds_003$0 = [0, [1, [0, _h_, [0, arg_007, 0]]], bnds_003],
      arg_005 = caml_call2(Moption[10], of_a_001, current_value_004),
      bnds_003$1 = [0, [1, [0, _i_, [0, arg_005, 0]]], bnds_003$0];
     return [1, bnds_003$1];
    }
    return caml_call4(Base_Invariant[1], _k_, t, _D_, _C_);
   }
   function peek(t){return caml_call1(Moption[16], t[1]);}
   function peek_exn(t){
    if(is_empty(t)){
     var
      _B_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Mvar_peek_exn_called_on_em);
     caml_call1(Core[261], _B_);
    }
    return caml_call1(Moption[17], t[1]);
   }
   function sexp_of_t(sexp_of_a, param, t){
    var x_013 = peek(t);
    return caml_call2(Core[515], sexp_of_a, x_013);
   }
   function sexp_of_t$0(of_a_014, x_015){
    return sexp_of_t(of_a_014, Core[212], x_015);
   }
   function invariant$0(invariant_a, t){
    return invariant(invariant_a, function(_A_){return 0;}, t);
   }
   var Read_write = [0, sexp_of_t$0, invariant$0];
   function sexp_of_t$1(of_a_016, x_017){
    return sexp_of_t(of_a_016, Core[171], x_017);
   }
   function invariant$1(invariant_a, t){
    return invariant(invariant_a, function(_z_){return 0;}, t);
   }
   var Read_only = [0, sexp_of_t$1, invariant$1];
   function read_only(t){return t;}
   function write_only(t){return t;}
   function create(param){
    var
     _x_ = caml_call1(Async_kernel_Ivar[12], 0),
     _y_ = caml_call1(Async_kernel_Bvar[3], 0);
    return [0, caml_call1(Moption[13], 0), _y_, _x_];
   }
   function take_nonempty(t){
    if(is_empty(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    var r = caml_call1(Moption[17], t[1]);
    caml_call1(Moption[20], t[1]);
    caml_call2(Async_kernel_Bvar[5], t[2], 0);
    t[3] = caml_call1(Async_kernel_Ivar[12], 0);
    return r;
   }
   function take_now_exn(t){
    if(is_empty(t)){
     var
      _w_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Mvar_take_exn_called_on_em);
     caml_call1(Core[261], _w_);
    }
    return take_nonempty(t);
   }
   function take_now(t){return is_empty(t) ? 0 : [0, take_nonempty(t)];}
   function take(t){
    if(is_empty(t)){
     var _t_ = function(param){return take(t);}, _u_ = value_available$1(t);
     return caml_call2(Async_kernel_Deferred_std[5][1], _u_, _t_);
    }
    var _v_ = take_nonempty(t);
    return caml_call1(Async_kernel_Deferred_std[10], _v_);
   }
   function set(t, v){
    caml_call2(Moption[21], t[1], v);
    return caml_call2(Async_kernel_Ivar[16], t[3], 0);
   }
   function update(t, f){return set(t, caml_call1(f, peek(t)));}
   function update_exn(t, f){return set(t, caml_call1(f, peek_exn(t)));}
   function taken$1(t){return caml_call1(Async_kernel_Bvar[4], t[2]);}
   function put(t, v){
    if(is_empty(t)){
     set(t, v);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    function _r_(param){return put(t, v);}
    var _s_ = taken$1(t);
    return caml_call2(Async_kernel_Deferred_std[5][1], _s_, _r_);
   }
   function pipe_when_ready(t){
    var
     match = caml_call3(Async_kernel_Pipe[7], 0, 0, 0),
     w = match[2],
     r = match[1];
    function loop(param){
     function _n_(param){
      if(caml_call1(Async_kernel_Pipe[17], w))
       return caml_call1(Async_kernel_Deferred_std[10], 0);
      var match = take_now(t);
      if(! match) return loop(0);
      var x = match[1];
      function _p_(param){return loop(0);}
      var _q_ = caml_call2(Async_kernel_Pipe[29], w, x);
      return caml_call2(Async_kernel_Deferred_std[5][1], _q_, _p_);
     }
     var _o_ = value_available$1(t);
     return caml_call2(Async_kernel_Deferred_std[5][1], _o_, _n_);
    }
    var _m_ = loop(0);
    caml_call1(Async_kernel_Deferred_std[8], _m_);
    return r;
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Mvar);
   var
    Async_kernel_Mvar =
      [0,
       sexp_of_t,
       Read_write,
       Read_only,
       create,
       is_empty,
       put,
       set,
       update,
       update_exn,
       read_only,
       write_only,
       value_available$1,
       take,
       take_now,
       take_now_exn,
       taken$1,
       peek,
       peek_exn,
       pipe_when_ready];
   runtime.caml_register_global
    (35, Async_kernel_Mvar, cst_Async_kernel_Mvar$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Lazy_deferred
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Monitor, Base__Monad, Core, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Lazy_deferred$0 = "Async_kernel__Lazy_deferred",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Lazy_deferred$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/lazy_deferred.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "lazy_deferred.ml");
   var
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Lazy_deferred = cst_Async_kernel_Lazy_deferred$0;
   function create(opt, f){
    if(opt) var sth = opt[1], rest_exn = sth; else var rest_exn = 3804260;
    var start = caml_call1(Async_kernel_Ivar[12], 0);
    function _j_(param){
     return caml_call6(Async_kernel_Monitor[17], 0, 0, 0, 0, [0, rest_exn], f);
    }
    var _k_ = caml_call1(Async_kernel_Ivar[19], start);
    return [0, start, caml_call2(Async_kernel_Deferred_std[5][1], _k_, _j_)];
   }
   function create_or_error(opt, f){
    if(opt) var sth = opt[1], rest_exn = sth; else var rest_exn = 3804260;
    var start = caml_call1(Async_kernel_Ivar[12], 0);
    function _h_(param){
     return caml_call6(Async_kernel_Monitor[18], 0, 0, 0, 0, [0, rest_exn], f);
    }
    var _i_ = caml_call1(Async_kernel_Ivar[19], start);
    return [0, start, caml_call2(Async_kernel_Deferred_std[5][1], _i_, _h_)];
   }
   function wait(t){return t[2];}
   function wait_exn(t){
    return caml_call2(Async_kernel_Deferred_std[4], t[2], Core[255]);
   }
   function force(t){caml_call2(Async_kernel_Ivar[16], t[1], 0); return t[2];}
   function force_exn(t){
    var _f_ = Core[255], _g_ = force(t);
    return caml_call2(Async_kernel_Deferred_std[4], _g_, _f_);
   }
   function return$0(a){
    return create
            (0,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], a);
             });
   }
   function bind(t, f){
    return create
            (0,
             function(param){
              function _d_(a){return force_exn(caml_call1(f, a));}
              var _e_ = force_exn(t);
              return caml_call2(Async_kernel_Deferred_std[5][1], _e_, _d_);
             });
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return create
                (0,
                 function(param){
                  var _c_ = force_exn(t);
                  return caml_call2(Async_kernel_Deferred_std[4], _c_, f);
                 });
       }],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function bind$1(t, f){
    return caml_call2
            (bind$0,
             t,
             function(a){
              return create(0, function(param){return caml_call1(f, a);});
             });
   }
   function is_forced(t){return caml_call1(Async_kernel_Ivar[18], t[1]);}
   function is_determined(t){
    return caml_call1(Async_kernel_Deferred[7], t[2]);
   }
   function peek(t){return caml_call1(Async_kernel_Deferred[5], t[2]);}
   function peek_exn(t){
    var _a_ = Core[255], _b_ = peek(t);
    return caml_call2(Core_Option[34], _b_, _a_);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Lazy_deferred);
   var
    Async_kernel_Lazy_deferred =
      [0,
       create,
       create_or_error,
       force,
       force_exn,
       wait,
       wait_exn,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       bind$1,
       peek,
       peek_exn,
       is_determined,
       is_forced];
   runtime.caml_register_global
    (18, Async_kernel_Lazy_deferred, cst_Async_kernel_Lazy_deferred$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_condition
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Ivar, Core__Option, Core__Queue, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_conditi$0 = "Async_kernel__Async_condition",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core_Queue = global_data.Core__Queue,
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_conditi$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/async_condition.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "async_condition.ml");
   var
    _a_ = [0, "waits"],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_conditi = cst_Async_kernel_Async_conditi$0;
   function sexp_of_t(of_a_001, param){
    var
     waits_003 = param[1],
     _f_ = caml_call1(Async_kernel_Ivar[9], of_a_001),
     arg_004 = caml_call2(Core_Queue[13], _f_, waits_003),
     bnds_002 = [0, [1, [0, _a_, [0, arg_004, 0]]], 0];
    return [1, bnds_002];
   }
   function create(param){return [0, caml_call2(Core_Queue[66], 0, 0)];}
   function wait(t){
    function _e_(ivar){return caml_call2(Core_Queue[43], t[1], ivar);}
    return caml_call1(Async_kernel_Deferred[3], _e_);
   }
   function signal(t, a){
    function _c_(ivar){return caml_call2(Async_kernel_Ivar[14], ivar, a);}
    var _d_ = caml_call1(Core_Queue[45], t[1]);
    return caml_call2(Core_Option[46], _d_, _c_);
   }
   function broadcast(t, a){
    function _b_(ivar){return caml_call2(Async_kernel_Ivar[14], ivar, a);}
    caml_call2(Core_Queue[18], t[1], _b_);
    return caml_call1(Core_Queue[51], t[1]);
   }
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_conditi);
   var
    Async_kernel_Async_condition =
      [0, sexp_of_t, create, signal, broadcast, wait];
   runtime.caml_register_global
    (16, Async_kernel_Async_condition, cst_Async_kernel_Async_conditi$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_gc
//# unitInfo: Requires: Async_kernel__Scheduler, Core__Gc, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_gc$0 = "Async_kernel__Async_gc",
    cst_async_kernel$0 = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Gc = global_data.Core__Gc;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_gc$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/async_gc.ml");
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "async_gc.ml");
   var
    Stat = Core_Gc[1],
    Control = Core_Gc[2],
    stat_size = Core_Gc[3],
    compactions = Core_Gc[4],
    heap_words = Core_Gc[5],
    heap_chunks = Core_Gc[6],
    top_heap_words = Core_Gc[7],
    print_stat = Core_Gc[8],
    allocated_bytes = Core_Gc[9],
    keep_alive = Core_Gc[10],
    Allocation_policy = Core_Gc[11],
    tune = Core_Gc[12],
    disable_compaction = Core_Gc[13],
    For_testing = Core_Gc[14],
    Stable = Core_Gc[16],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_gc = cst_Async_kernel_Async_gc$0;
   function add_finalizer(heap_block, f){
    var _e_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[47], _e_), heap_block, f);
   }
   function add_finalizer_exn(heap_block, f){
    var _d_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[48], _d_), heap_block, f);
   }
   function add_finalizer_last(heap_block, f){
    var _c_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[49], _c_), heap_block, f);
   }
   function add_finalizer_last_exn(heap_block, f){
    var _b_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[50], _b_), heap_block, f);
   }
   var sexp_of_t = Core_Gc[15][6][1];
   function create(f){
    var _a_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call1(caml_call1(Async_kernel_Scheduler[46], _a_), f);
   }
   var delete$0 = Core_Gc[15][6][3], Alarm = [0, sexp_of_t, create, delete$0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_gc);
   var
    Async_kernel_Async_gc =
      [0,
       Stat,
       Control,
       stat_size,
       compactions,
       heap_words,
       heap_chunks,
       top_heap_words,
       print_stat,
       allocated_bytes,
       keep_alive,
       Allocation_policy,
       tune,
       disable_compaction,
       For_testing,
       Stable,
       add_finalizer,
       add_finalizer_exn,
       add_finalizer_last,
       add_finalizer_last_exn,
       Alarm];
   runtime.caml_register_global
    (13, Async_kernel_Async_gc, cst_Async_kernel_Async_gc$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_invariant_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_invaria = "Async_kernel__Async_invariant_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_invaria);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][1], "src/async_invariant_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel, "async_invariant_intf.ml");
   var Async = [0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_invaria);
   var Async_kernel_Async_invariant_i = [0, Async];
   runtime.caml_register_global
    (11, Async_kernel_Async_invariant_i, cst_Async_kernel_Async_invaria);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_invariant
//# unitInfo: Requires: Async_kernel__Async_invariant_intf, Async_kernel__Deferred, Async_kernel__Monitor, Base__Field, Base__Invariant, Core, Core__Source_code_position, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_invaria$0 = "Async_kernel__Async_invariant",
    cst_async_kernel$0 = "async_kernel",
    cst_exn = "exn";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Field = global_data.Base__Field,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Base_Invariant = global_data.Base__Invariant;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_invaria$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], "src/async_invariant.ml");
   caml_call2
    (Ppx_inline_test_lib[6], cst_async_kernel$0, "async_invariant.ml");
   var
    invariant = Base_Invariant[1],
    check_field = Base_Invariant[2],
    _e_ = [0, cst_exn],
    _f_ = [0, "field"],
    cst_problem_with_field = "problem with field",
    _g_ = [0, 3804260],
    _h_ = [0, 523273847],
    _i_ = [0, 1],
    _a_ = [0, cst_exn],
    cst_invariant_failed = "invariant failed",
    _b_ = [0, 3804260],
    _c_ = [0, 523273847],
    _d_ = [0, 1],
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Async_invaria = cst_Async_kernel_Async_invaria$0;
   function invariant$0(here, t, sexp_of_t, f){
    function _r_(param){
     if(0 === param[0]) return 0;
     var
      exn = param[1],
      _t_ = [0, caml_call1(sexp_of_t, t), 0],
      _u_ = [0, [1, [0, _a_, [0, caml_call1(Core[625], exn), 0]]], _t_],
      _v_ = [0, caml_call1(Core_Source_code_position[1], here), _u_],
      _w_ =
        [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_invariant_failed), _v_]];
     return caml_call1(Core[261], _w_);
    }
    var _s_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, _d_, _c_, _b_, f);
    return caml_call2(Async_kernel_Deferred[16][4][3], _s_, _r_);
   }
   function check_field$0(t, f, wait_for_previous, field){
    function _j_(param){
     function _k_(param){
      if(0 === param[0]) return 0;
      var
       exn = param[1],
       _n_ = [0, [1, [0, _e_, [0, caml_call1(Core[625], exn), 0]]], 0],
       _o_ = caml_call1(Base_Field[2], field),
       _p_ = [0, [1, [0, _f_, [0, caml_call1(Core[558], _o_), 0]]], _n_],
       _q_ =
         [1,
          [0, caml_call1(Sexplib0_Sexp_conv[7], cst_problem_with_field), _p_]];
      return caml_call1(Core[261], _q_);
     }
     function _l_(param){
      return caml_call1(f, caml_call2(Base_Field[3], field, t));
     }
     var
      _m_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, _i_, _h_, _g_, _l_);
     return caml_call2(Async_kernel_Deferred[16][4][3], _m_, _k_);
    }
    return caml_call2(Async_kernel_Deferred[16][4][2], wait_for_previous, _j_);
   }
   var Async = [0, invariant$0, check_field$0];
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_invaria);
   var Async_kernel_Async_invariant = [0, invariant, check_field, Async];
   runtime.caml_register_global
    (29, Async_kernel_Async_invariant, cst_Async_kernel_Async_invaria$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel
//# unitInfo: Requires: Async_kernel__Async_gc, Async_kernel__Clock_ns, Async_kernel__Deferred, Async_kernel__Deferred_result, Async_kernel__Monitor, Async_kernel__Scheduler, Core, Inline_test_config, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel$0 = "Async_kernel",
    cst_async_kernel$0 = "async_kernel",
    cst_src_async_kernel_ml$0 = "src/async_kernel.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/async_kernel.ml:94:17",
    Core = global_data.Core,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Async_kernel_Deferred_result = global_data.Async_kernel__Deferred_result,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_async_kernel_ml$0);
   caml_call2(Ppx_inline_test_lib[6], cst_async_kernel$0, "async_kernel.ml");
   var
    after = Async_kernel_Clock_ns[4],
    at = Async_kernel_Clock_ns[3],
    catch$0 = Async_kernel_Monitor[21],
    choice = Async_kernel_Deferred[27],
    choose = Async_kernel_Deferred[29],
    don_t_wait_for = Async_kernel_Deferred[25],
    every = Async_kernel_Clock_ns[11],
    never = Async_kernel_Deferred[19],
    schedule = Async_kernel_Scheduler[61],
    schedule$0 = Async_kernel_Scheduler[60],
    try_with = Async_kernel_Monitor[16],
    upon = Async_kernel_Deferred[4],
    with_timeout = Async_kernel_Clock_ns[5],
    with_timeout_exn = Async_kernel_Clock_ns[6],
    within = Async_kernel_Scheduler[58],
    within$0 = Async_kernel_Scheduler[57],
    symbol = Async_kernel_Deferred[17][3],
    symbol$0 = Async_kernel_Deferred_result[1],
    symbol$1 = Async_kernel_Deferred_result[2],
    include = Async_kernel_Deferred[16],
    return$0 = include[1],
    symbol_bind = include[2],
    symbol_map = include[3],
    Let_syntax = include[4],
    Async_kernel_private = [0],
    cst_src_async_kernel_ml = cst_src_async_kernel_ml$0,
    cst_return_does_not_allocate = "[return ()] does not allocate",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel = cst_Async_kernel$0;
   function _a_(param){
    var expect = runtime.core_gc_minor_words(0);
    caml_call1(return$0, 0);
    caml_call1(Async_kernel_Deferred[12], 0);
    caml_call1(Async_kernel_Deferred[16][1], 0);
    caml_call1(Async_kernel_Deferred[16][4][1], 0);
    var
     got = runtime.core_gc_minor_words(0),
     sexpifier = Core[389],
     equal = 0,
     message = 0,
     here = 0;
    function comparator(a_001, b_002){
     return caml_call2(Core[382], a_001, b_002);
    }
    caml_call8
     (Ppx_assert_lib_Runtime[3],
      pos,
      sexpifier,
      comparator,
      here,
      message,
      equal,
      expect,
      got);
    return 0;
   }
   caml_call8
    (Ppx_inline_test_lib[9],
     Inline_test_config,
     cst_return_does_not_allocate,
     0,
     cst_src_async_kernel_ml,
     87,
     0,
     443,
     _a_);
   caml_call1(Ppx_inline_test_lib[7], cst_async_kernel);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel);
   var
    Async_kernel =
      [0,
       after,
       at,
       catch$0,
       choice,
       choose,
       don_t_wait_for,
       every,
       never,
       schedule,
       schedule$0,
       try_with,
       upon,
       with_timeout,
       with_timeout_exn,
       within,
       within$0,
       symbol,
       symbol$0,
       symbol$1,
       return$0,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Async_kernel_private];
   runtime.caml_register_global(22, Async_kernel, cst_Async_kernel$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhc3luY19rZXJuZWwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImFmdGVyIiwidCIsInNwYW4iLCJyZXN1bHQiLCJsb2ciLCJhcmcyXzAwMyIsImFyZzNfMDA0Iiwic2V4cF9vZl9hIiwiYXJnMV8wMDIiLCJhcmcwXzAwMSIsInJlczBfMDA1IiwicmVzMV8wMDYiLCJyZXMyXzAwNyIsInJlczNfMDA4IiwibG9nX3N0cmluZyIsIm1lc3NhZ2UiLCJjb25jYXQiLCJlcHJpbnQiLCJlcHJpbnRfcyIsImVwcmludHMiLCJwcmludF9zIiwic2V4cCIsInNlYyIsImFsbCIsInNleHBfb2ZfdCIsInRvX3JlcHIiLCJvZl9yZXByIiwiZGVidWciLCJmb3J3YXJkaW5nIiwiciIsInNldF9mb3J3YXJkaW5nIiwidiIsImhhc19zZWVuX2Vycm9yIiwic2V0X2hhc19zZWVuX2Vycm9yIiwidGFpbHNfZm9yX2FsbF9lcnJvcnMiLCJzZXRfdGFpbHNfZm9yX2FsbF9lcnJvcnMiLCJoYW5kbGVyc19mb3JfYWxsX2Vycm9ycyIsInNldF9oYW5kbGVyc19mb3JfYWxsX2Vycm9ycyIsIm5leHRfZXJyb3IiLCJzZXRfbmV4dF9lcnJvciIsImlkIiwiaGVyZSIsIm5hbWUiLCJmb3J3YXJkaW5nJDAiLCJoYXNfc2Vlbl9lcnJvciQwIiwidGFpbHNfZm9yX2FsbF9lcnJvcnMkMCIsImhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzJDAiLCJuZXh0X2Vycm9yJDAiLCJpZCQwIiwiaGVyZSQwIiwibmFtZSQwIiwiaXRlciIsIm5hbWVfZnVuIiwiaGVyZV9mdW4iLCJpZF9mdW4iLCJuZXh0X2Vycm9yX2Z1biIsImhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzX2Z1biIsInRhaWxzX2Zvcl9hbGxfZXJyb3JzX2Z1biIsImhhc19zZWVuX2Vycm9yX2Z1biIsImZvcndhcmRpbmdfZnVuIiwiZGVzY3JpcHRpb24iLCJkZXNjcmlwdGlvbnMiLCJ0JDEiLCJhYyIsImFjJDAiLCJ0JDAiLCJ4XzAwMSIsIm5leHRfaWQiLCJjcmVhdGVfd2l0aF9wYXJlbnQiLCJpbmZvIiwicGFyZW50IiwiaSIsInMiLCJzJDAiLCJ4XzAwMiIsInBhcmVudCQwIiwibWFpbiIsImJhY2t0cmFjZV9oaXN0b3J5IiwibG9jYWxfc3RvcmFnZSIsInByaW9yaXR5IiwibW9uaXRvciIsImJhY2t0cmFjZV9oaXN0b3J5XzAwOCIsImxvY2FsX3N0b3JhZ2VfMDA2IiwicHJpb3JpdHlfMDA0IiwibW9uaXRvcl8wMDIiLCJhcmdfMDA5IiwiYm5kc18wMDEiLCJhcmdfMDA3IiwiYm5kc18wMDEkMCIsImFyZ18wMDUiLCJibmRzXzAwMSQxIiwiYXJnXzAwMyIsImJuZHNfMDAxJDIiLCJpbnZhcmlhbnQiLCJjcmVhdGVfbGlrZSIsIm1vbml0b3IkMCIsImZpbmRfbG9jYWwiLCJrZXkiLCJ3aXRoX2xvY2FsIiwiZGF0YSIsImRhdGEkMCIsInJlY29yZF9iYWNrdHJhY2UiLCJkdW1teV9lIiwiZHVtbXlfZiIsImR1bW15X2EiLCJzZXhwX29mX3Nsb3RzIiwiY3JlYXRlIiwib2ZfZXZlbnQiLCJldmVudCIsIm9mX2pvYiIsImpvYiIsImlzX2V2ZW50IiwiaXNfam9iIiwia2luZCIsInByb2plY3QiLCJqb2Jfb3JfZXZlbnQiLCJldmVudHMiLCJzZXRfZXhlY3V0aW9uX2NvbnRleHQiLCJleGVjdXRpb25fY29udGV4dCIsImxlbmd0aCIsInNldF9sZW5ndGgiLCJmcm9udCIsInNldF9mcm9udCIsIm1hc2siLCJzZXRfbWFzayIsImpvYnMiLCJzZXRfam9icyIsImpvYnNfbGVmdF90aGlzX2N5Y2xlIiwic2V0X2pvYnNfbGVmdF90aGlzX2N5Y2xlIiwibnVtX2pvYnNfcnVuIiwic2V0X251bV9qb2JzX3J1biIsImxlbmd0aCQwIiwiZnJvbnQkMCIsIm1hc2skMCIsImpvYnMkMCIsImpvYnNfbGVmdF90aGlzX2N5Y2xlJDAiLCJudW1fam9ic19ydW4kMCIsIm51bV9qb2JzX3J1bl8wMDIiLCJqb2JzX2xlZnRfdGhpc19jeWNsZV8wMDQiLCJqb2JzXzAwNiIsIm1hc2tfMDA4IiwiZnJvbnRfMDEwIiwibGVuZ3RoXzAxMiIsImJhY2t0cmFjZV9vZl9maXJzdF9lbnF1ZXVlXzAxNCIsImFyZ18wMTUiLCJhcmdfMDEzIiwiYXJnXzAxMSIsImJuZHNfMDAxJDMiLCJibmRzXzAwMSQ0IiwiYm5kc18wMDEkNSIsIm9mZnNldCIsImNhcGFjaXR5IiwiY2hlY2siLCJmIiwibGVuZ3RoX2Z1biIsImZyb250X2Z1biIsIm1hc2tfZnVuIiwiam9ic19mdW4iLCJqb2JzX2xlZnRfdGhpc19jeWNsZV9mdW4iLCJudW1fam9ic19ydW5fZnVuIiwiY3JlYXRlX2FycmF5IiwiYmFja3RyYWNlX29mX2ZpcnN0X2VucXVldWUiLCJjbGVhciIsInNldCIsImEiLCJvZmZzZXQkMCIsImVucXVldWUiLCJvbGRfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkiLCJvbGRfam9icyIsIm9sZF9mcm9udCIsImxlbjEiLCJsZW4yIiwibmV3X2pvYnMiLCJzZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUkMCIsIm4iLCJjYW5fcnVuX2Ffam9iIiwicnVuX2pvYiIsInNjaGVkdWxlciIsInJ1bl9leHRlcm5hbF9qb2JzIiwiZXh0ZXJuYWxfam9icyIsInJ1bl9qb2JzIiwidGhpc19qb2IiLCJleG4kMCIsImV4biIsImJhY2t0cmFjZSIsInBvcyQzIiwicG9zJDIiLCJwb3MkMSIsInBvcyQwIiwicG9zIiwiaXNfbnVsbCIsImRlZmF1bHRfdGltaW5nX3doZWVsX2NvbmZpZyIsImNvbXBhcmUkMCIsImVxdWFsJDAiLCJzZXhwX29mX3QkMSIsInRyYW5zaXRpb25faXNfYWxsb3dlZCIsImZyb20iLCJ0byIsInNleHBfb2ZfZXZlbnQiLCJhdCIsImludGVydmFsIiwic3RhdHVzIiwibWF0Y2giLCJub25lIiwic29tZSIsImlzX25vbmUiLCJpc19zb21lIiwiZmlyc3Rfc29tZSIsInQxIiwidDIiLCJ1bnNhZmVfdmFsdWUiLCJzZXhwX29mX3QkMiIsInBweF9vcHRpb25hbF9lXzAiLCJ2YWx1ZSQwIiwiZGVmYXVsdCQwIiwidmFsdWVfZXhuIiwidG9fb3B0aW9uIiwib2Zfb3B0aW9uIiwic2V0X3N0YXR1cyIsInByZXZfZmlyZWQiLCJzZXRfcHJldl9maXJlZCIsIm5leHRfZmlyZWQiLCJzZXRfbmV4dF9maXJlZCIsInNldF9pbnRlcnZhbCIsImNhbGxiYWNrIiwiYXQkMCIsInNldF9hdCIsImFsYXJtIiwic2V0X2FsYXJtIiwic3RhdHVzJDAiLCJwcmV2X2ZpcmVkJDAiLCJuZXh0X2ZpcmVkJDAiLCJpbnRlcnZhbCQwIiwiZXhlY3V0aW9uX2NvbnRleHQkMCIsImNhbGxiYWNrJDAiLCJhdCQxIiwiYWxhcm0kMCIsImFsYXJtX2Z1biIsImF0X2Z1biIsImNhbGxiYWNrX2Z1biIsImV4ZWN1dGlvbl9jb250ZXh0X2Z1biIsImludGVydmFsX2Z1biIsIm5leHRfZmlyZWRfZnVuIiwicHJldl9maXJlZF9mdW4iLCJzdGF0dXNfZnVuIiwiZ290Iiwic2V4cGlmaWVyIiwiZXhwZWN0IiwiZXF1YWwiLCJjb21wYXJhdG9yIiwiYV8wMTMiLCJiXzAxNCIsImFfMDA5IiwiYl8wMTAiLCJhXzAwNSIsImJfMDA2Iiwic2V0X3N0YXR1cyQwIiwic2V0X3N0YXR1c19pZiIsImlzIiwic2V4cF9vZl90JDMiLCJrIiwiaXNfd2FsbF9jbG9jayIsImhhbmRsZV9maXJlZCIsIm1vc3RfcmVjZW50bHlfZmlyZWQiLCJzZXRfbW9zdF9yZWNlbnRseV9maXJlZCIsImZpcmVkX2V2ZW50cyIsInNldF9maXJlZF9ldmVudHMiLCJhbV9hZHZhbmNpbmciLCJzZXRfYW1fYWR2YW5jaW5nIiwiYWR2YW5jZV9lcnJvcnMiLCJzZXRfYWR2YW5jZV9lcnJvcnMiLCJzY2hlZHVsZXIkMCIsImlzX3dhbGxfY2xvY2skMCIsImhhbmRsZV9maXJlZCQwIiwibW9zdF9yZWNlbnRseV9maXJlZCQwIiwiZmlyZWRfZXZlbnRzJDAiLCJldmVudHMkMCIsImFtX2FkdmFuY2luZyQwIiwiYWR2YW5jZV9lcnJvcnMkMCIsIml0ZXIkMCIsImFkdmFuY2VfZXJyb3JzX2Z1biIsImFtX2FkdmFuY2luZ19mdW4iLCJldmVudHNfZnVuIiwiZmlyZWRfZXZlbnRzX2Z1biIsIm1vc3RfcmVjZW50bHlfZmlyZWRfZnVuIiwiaGFuZGxlX2ZpcmVkX2Z1biIsImlzX3dhbGxfY2xvY2tfZnVuIiwic2NoZWR1bGVyX2Z1biIsInNleHBfb2ZfdCQ0Iiwibm93IiwiYWxsX2V2ZW50cyIsImF0MiIsImF0MSIsInRpbWluZ193aGVlbF9ub3ciLCJpc19pbl9maXJlZF9ldmVudHMiLCJ0YXJnZXRfZXZlbnQiLCJjdXJyZW50JDEiLCJjdXJyZW50IiwiY3VycmVudCQwIiwiaW52YXJpYW50X3dpdGhfam9icyIsImpvYl9pbnZhcmlhbnQiLCJwcHhfb3B0aW9uYWxfZV8wJDAiLCJhXzAxNyIsImJfMDE4IiwiZ290JDAiLCJzZXhwaWZpZXIkMCIsImV4cGVjdCQwIiwibWVzc2FnZSQwIiwiY29tcGFyYXRvciQwIiwiYV8wMTkiLCJiXzAyMCIsInhfMDE2IiwiaW52YXJpYW50JDAiLCJzZXhwX29mX3QkNSIsInhfMDIxIiwiaW52YXJpYW50JDEiLCJpbnZhcmlhbnRfd2l0aF9qb2JzJDAiLCJzZXhwX29mX3QkNiIsInhfMDIyIiwiaWQkMSIsImlzX3dhbGxfY2xvY2skMSIsIm1heF9hbGxvd2VkX2FsYXJtX3RpbWUiLCJyZWFkX29ubHkiLCJmaXJlIiwiY29udGludWUkMCIsIm5leHQkMCIsImNvbnRpbnVlJDEiLCJwcHhfb3B0aW9uYWxfZV8wJDEiLCJuZXh0IiwicHB4X29wdGlvbmFsX2VfMCQyIiwicHJldiIsImFsYXJtX3ByZWNpc2lvbiIsIm5leHRfYWxhcm1fZmlyZXNfYXQiLCJuZXh0X2FsYXJtX3J1bnNfYXQiLCJub3ckMCIsInRpbWluZ193aGVlbF9ub3ckMCIsInNjaGVkdWxlIiwicmVtb3ZlX2Zyb21fZmlyZWQiLCJuZXdfc3RhdHVzIiwic2V4cF9vZl9ldmVudCQwIiwic3RhdHVzJDEiLCJwcmV2X2ZpcmVkJDEiLCJzZXRfcHJldl9maXJlZCQwIiwibmV4dF9maXJlZCQxIiwic2V0X25leHRfZmlyZWQkMCIsImludGVydmFsJDEiLCJzZXRfaW50ZXJ2YWwkMCIsImV4ZWN1dGlvbl9jb250ZXh0JDEiLCJjYWxsYmFjayQxIiwic2V0X2F0JDAiLCJhbGFybSQxIiwic2V0X2FsYXJtJDAiLCJzZXhwX29mX3QkNyIsImludmFyaWFudCQyIiwic2V0X3N0YXR1cyQxIiwic2V0X3N0YXR1c19pZiQwIiwic2NoZWR1bGVkX2F0IiwiY3JlYXRlX2ludGVybmFsIiwiYWRkJDAiLCJjcmVhdGVfYW5kX2FkZCIsImF0JDIiLCJhZnRlciQwIiwicmVxdWlyZV9zcGFuX2F0X2xlYXN0X2FsYXJtX3ByIiwiYWxhcm1fcHJlY2lzaW9uJDAiLCJhdF9pbnRlcnZhbHMiLCJzdGFydCIsInNleHBfb2ZfdCQ4IiwiYWJvcnQiLCJhYm9ydF9pZl9wb3NzaWJsZSIsImFib3J0X2V4biIsInJlYXNvbiIsImlzX3NjaGVkdWxlZCIsInNjaGVkdWxlX2F0X2ludGVybmFsIiwic2NoZWR1bGVfYXQiLCJzY2hlZHVsZV9hZnRlciIsInNjaGVkdWxlX2F0X2ludGVydmFscyIsInN0YXJ0aW5nX2F0Iiwic2NoZWR1bGVfYXRfaW50ZXJ2YWxzJDAiLCJyZXNjaGVkdWxlX2F0IiwicmVzY2hlZHVsZV9hZnRlciIsInJ1bl9hZnRlciIsInJ1bl9hdCIsInJ1bl9hdF9pbnRlcnZhbHMiLCJydW5fZmlyZWRfZXZlbnRzIiwic2VuZF9leG4iLCJjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0Iiwic2VuZF9leG4kMCIsImFueV9maXJlZF9ldmVudHNfdG9fcnVuIiwiYWR2YW5jZV9jbG9jayIsImFkdmFuY2VfY2xvY2tfc3RvcF9hdF9uZXh0X2FsYSIsImZpcmVfcGFzdF9hbGFybXMiLCJhZHZhbmNlX2ludGVybmFsIiwiYWR2YW5jZV9pbnRlcm5hbF9zdG9wX2F0X25leHRfIiwicHJlcGFyZV90b19hZHZhbmNlIiwiZmluaXNoX2FkdmFuY2luZyIsImVycm9ycyIsImFkdmFuY2VfYnlfYWxhcm1zIiwiYWR2YW5jZV9ieV9hbGFybXNfYnkiLCJieSIsImFkdmFuY2VfYnlfbWF4X2FsYXJtc19pbl9lYWNoXyIsImFkdmFuY2VfZGlyZWN0bHkiLCJhZHZhbmNlX2RpcmVjdGx5X2J5IiwiZHVyYXRpb25fb2YiLCJkdXJhdGlvbiIsIm1heF9hbGFybV90aW1lX2luX21pbl90aW1pbmdfdyIsImhhc19ldmVudHNfdG9fcnVuIiwiY3JlYXRlX3dpdGhfY2VsbCIsImNlbGwiLCJjcmVhdGVfZnVsbCIsImNyZWF0ZSQwIiwiZXhlYyIsImV4ZWMkMCIsImV4ZWNfZnVuIiwic2V4cF9vZl90JDAiLCJleGVjdXRpb25fY29udGV4dF8wMDIiLCJyZWNvcmRfYmFja3RyYWNlcyIsInNldF9yZWNvcmRfYmFja3RyYWNlcyIsIm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyXyIsInNldF9tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5XyIsImNoZWNrX2ludmFyaWFudHMiLCJzZXRfY2hlY2tfaW52YXJpYW50cyIsInlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluIiwic2V0X3lpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluIiwieWllbGQkMCIsInNldF95aWVsZCIsImV2ZW50X2FkZGVkX2hvb2siLCJzZXRfZXZlbnRfYWRkZWRfaG9vayIsImpvYl9xdWV1ZWRfaG9vayIsInNldF9qb2JfcXVldWVkX2hvb2siLCJ0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayIsInNldF90aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaCIsInRpbWVfc291cmNlIiwic2V0X3RpbWVfc291cmNlIiwidG90YWxfY3ljbGVfdGltZSIsInNldF90b3RhbF9jeWNsZV90aW1lIiwibGFzdF9jeWNsZV9udW1fam9icyIsInNldF9sYXN0X2N5Y2xlX251bV9qb2JzIiwibGFzdF9jeWNsZV90aW1lIiwic2V0X2xhc3RfY3ljbGVfdGltZSIsInJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUiLCJydW5fZXZlcnlfY3ljbGVfZW5kIiwic2V0X3J1bl9ldmVyeV9jeWNsZV9lbmQiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnQiLCJzZXRfcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IiwiaW5fY3ljbGUiLCJzZXRfaW5fY3ljbGUiLCJjeWNsZV9zdGFydCIsInNldF9jeWNsZV9zdGFydCIsImN5Y2xlX2NvdW50Iiwic2V0X2N5Y2xlX2NvdW50IiwidW5jYXVnaHRfZXhuX3Vud3JhcHBlZCIsInNldF91bmNhdWdodF9leG4iLCJzZXRfY3VycmVudF9leGVjdXRpb25fY29udGV4dCIsIm1haW5fZXhlY3V0aW9uX2NvbnRleHQiLCJzZXRfbWFpbl9leGVjdXRpb25fY29udGV4dCIsInZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMiLCJsb3dfcHJpb3JpdHlfam9icyIsIm5vcm1hbF9wcmlvcml0eV9qb2JzIiwiam9iX3Bvb2wiLCJzZXRfam9iX3Bvb2wiLCJjaGVja19hY2Nlc3MiLCJzZXRfY2hlY2tfYWNjZXNzIiwicmVjb3JkX2JhY2t0cmFjZXMkMCIsIm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyXyQwIiwiY2hlY2tfaW52YXJpYW50cyQwIiwieWllbGRfdW50aWxfbm9fam9ic19yZW1haW4kMCIsInlpZWxkJDEiLCJldmVudF9hZGRlZF9ob29rJDAiLCJqb2JfcXVldWVkX2hvb2skMCIsInRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rJDAiLCJleHRlcm5hbF9qb2JzJDAiLCJ0aW1lX3NvdXJjZSQwIiwidG90YWxfY3ljbGVfdGltZSQwIiwibGFzdF9jeWNsZV9udW1fam9icyQwIiwibGFzdF9jeWNsZV90aW1lJDAiLCJydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlJDAiLCJydW5fZXZlcnlfY3ljbGVfZW5kJDAiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUkMCIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydCQwIiwiaW5fY3ljbGUkMCIsImN5Y2xlX3N0YXJ0JDAiLCJjeWNsZV9jb3VudCQwIiwidW5jYXVnaHRfZXhuIiwiY3VycmVudF9leGVjdXRpb25fY29udGV4dCQwIiwibWFpbl9leGVjdXRpb25fY29udGV4dCQwIiwidmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycyQwIiwibG93X3ByaW9yaXR5X2pvYnMkMCIsIm5vcm1hbF9wcmlvcml0eV9qb2JzJDAiLCJqb2JfcG9vbCQwIiwiY2hlY2tfYWNjZXNzJDAiLCJjaGVja19hY2Nlc3NfZnVuIiwiam9iX3Bvb2xfZnVuIiwibm9ybWFsX3ByaW9yaXR5X2pvYnNfZnVuIiwibG93X3ByaW9yaXR5X2pvYnNfZnVuIiwidmVyeV9sb3dfcHJpb3JpdHlfd29ya2Vyc19mdW4iLCJtYWluX2V4ZWN1dGlvbl9jb250ZXh0X2Z1biIsImN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRfZnVuIiwidW5jYXVnaHRfZXhuX2Z1biIsImN5Y2xlX2NvdW50X2Z1biIsImN5Y2xlX3N0YXJ0X2Z1biIsImluX2N5Y2xlX2Z1biIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydF9mdW4iLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGVfZnUiLCJydW5fZXZlcnlfY3ljbGVfZW5kX2Z1biIsInJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGVfZnVuIiwibGFzdF9jeWNsZV90aW1lX2Z1biIsImxhc3RfY3ljbGVfbnVtX2pvYnNfZnVuIiwidG90YWxfY3ljbGVfdGltZV9mdW4iLCJ0aW1lX3NvdXJjZV9mdW4iLCJleHRlcm5hbF9qb2JzX2Z1biIsInRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rXyIsImpvYl9xdWV1ZWRfaG9va19mdW4iLCJldmVudF9hZGRlZF9ob29rX2Z1biIsInlpZWxkX2Z1biIsInlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluX2Z1biIsImNoZWNrX2ludmFyaWFudHNfZnVuIiwicmVjb3JkX2JhY2t0cmFjZXNfZnVuIiwiY2hlY2tfYWNjZXNzXzAwNyIsImpvYl9wb29sXzAwOSIsInZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnNfMDE1IiwibG93X3ByaW9yaXR5X2pvYnNfMDEzIiwibm9ybWFsX3ByaW9yaXR5X2pvYnNfMDExIiwibWFpbl9leGVjdXRpb25fY29udGV4dF8wMTciLCJjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0XzAxOSIsInVuY2F1Z2h0X2V4bl8wMjEiLCJjeWNsZV9jb3VudF8wMjciLCJjeWNsZV9zdGFydF8wMjkiLCJpbl9jeWNsZV8wMzEiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfMDMzIiwicnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlXzAzIiwicnVuX2V2ZXJ5X2N5Y2xlX2VuZF8wMzciLCJydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlXzAzOSIsImxhc3RfY3ljbGVfdGltZV8wNDEiLCJsYXN0X2N5Y2xlX251bV9qb2JzXzA0MyIsInRvdGFsX2N5Y2xlX3RpbWVfMDQ1IiwidGltZV9zb3VyY2VfMDQ3IiwiZXh0ZXJuYWxfam9ic18wNDkiLCJqb2JfcXVldWVkX2hvb2tfMDUzIiwiZXZlbnRfYWRkZWRfaG9va18wNTUiLCJ5aWVsZF8wNTciLCJ5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbl8wNTkiLCJjaGVja19pbnZhcmlhbnRzXzA2MSIsInJlY29yZF9iYWNrdHJhY2VzXzA2NSIsImFyZ18wNjYiLCJibmRzXzAwNiIsImFyZ18wNjQiLCJibmRzXzAwNiQwIiwiYXJnXzA2MiIsImJuZHNfMDA2JDEiLCJhcmdfMDYwIiwiYm5kc18wMDYkMiIsImFyZ18wNTgiLCJibmRzXzAwNiQzIiwiYXJnXzA1NiIsImJuZHNfMDA2JDQiLCJhcmdfMDU0IiwiYm5kc18wMDYkNSIsImFyZ18wNTIiLCJibmRzXzAwNiQ2IiwiYXJnXzA1MCIsImJuZHNfMDA2JDciLCJhcmdfMDQ4IiwiYm5kc18wMDYkOCIsImFyZ18wNDYiLCJibmRzXzAwNiQ5IiwiYXJnXzA0NCIsImJuZHNfMDA2JDEwIiwiYXJnXzA0MiIsImJuZHNfMDA2JDExIiwiYXJnXzA0MCIsImJuZHNfMDA2JDEyIiwiYXJnXzAzOCIsImJuZHNfMDA2JDEzIiwiYXJnXzAzNiIsImJuZHNfMDA2JDE0IiwiYXJnXzAzNCIsImJuZHNfMDA2JDE1IiwiYXJnXzAzMiIsImJuZHNfMDA2JDE2IiwiYXJnXzAzMCIsImJuZHNfMDA2JDE3IiwiYXJnXzAyOCIsImJuZHNfMDA2JDE4IiwiYXJnMV8wMjQiLCJhcmcwXzAyMyIsInJlczBfMDI1IiwicmVzMV8wMjYiLCJhcmdfMDIyIiwiYm5kc18wMDYkMTkiLCJhcmdfMDIwIiwiYm5kc18wMDYkMjAiLCJhcmdfMDE4IiwiYm5kc18wMDYkMjEiLCJhcmdfMDE2IiwiYm5kc18wMDYkMjIiLCJhcmdfMDE0IiwiYm5kc18wMDYkMjMiLCJhcmdfMDEyIiwiYm5kc18wMDYkMjQiLCJhcmdfMDEwIiwiYm5kc18wMDYkMjUiLCJhcmdfMDA4IiwiYm5kc18wMDYkMjYiLCJ1bmNhdWdodF9leG4kMCIsImFyZzFfMDY4IiwiYXJnMF8wNjciLCJyZXMwXzA2OSIsInJlczFfMDcwIiwibnVtX3BlbmRpbmdfam9icyIsImxhc3RfY3ljbGVfbnVtX2pvYnMkMSIsInVub3JkZXJlZF9pc19zdWJsaXN0Iiwic21hbGwiLCJsYXJnZSIsImxhcmdlJDAiLCJhY2MiLCJ4IiwibCQwIiwieSIsImwiLCJjaGVja19ob29rX3RhYmxlX2ludmFyaWFudCIsInRhYmxlIiwiYXJyYXkiLCJmaWVsZCIsInEiLCJmcmVlX2pvYiIsImpvYl9xdWV1ZSIsImYkMCIsImVucXVldWVfam9iIiwiY3JlYXRlJDEiLCJpc19kZWFkIiwic2V0X2NoZWNrX2FjY2VzcyQwIiwiYmFja3RyYWNlX29mX2ZpcnN0X2pvYiIsInRfcmVmIiwiY2hlY2tfYWNjZXNzJDEiLCJjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0JDEiLCJ3aXRoX2V4ZWN1dGlvbl9jb250ZXh0MSIsInRtcF9jb250ZXh0Iiwib2xkX2NvbnRleHQiLCJ3aXRoX2V4ZWN1dGlvbl9jb250ZXh0IiwiY3JlYXRlX2pvYiIsImdvdF91bmNhdWdodF9leG4iLCJhcmcxXzA3MiIsImFyZzBfMDcxIiwicmVzMF8wNzMiLCJyZXMxXzA3NCIsInN0YXJ0X2N5Y2xlIiwibWF4X251bV9qb2JzX3Blcl9wcmlvcml0eSIsImUiLCJlJDAiLCJzdGFiaWxpemUiLCJjcmVhdGVfdGltZV9zb3VyY2UiLCJvcHQiLCJzdGgiLCJ0aW1pbmdfd2hlZWxfY29uZmlnIiwid2FsbF9jbG9jayIsInNldF9wcmV2IiwicGFyYW0iLCJzZXRfbmV4dCIsInJ1biIsImNyZWF0ZTIiLCJydW4xIiwiZXhlY3V0aW9uX2NvbnRleHQxIiwicnVuMiIsImV4ZWN1dGlvbl9jb250ZXh0MiIsInNjaGVkdWxlX2pvYnMiLCJhZGQiLCJvZl9saXN0IiwiZmlyc3QiLCJsJDEiLCJsJDIiLCJydW4kMCIsInByZXYkMCIsInRvX2xpc3QiLCJhY2MkMCIsImNlbGxfb2ZfaGFuZGxlciIsImluZGlyIiwic3F1YXNoIiwidCQzIiwidCQ0IiwiaW5kaXIkMSIsInQkNSIsImluZGlyJDAiLCJ0JDIiLCJhX2ludmFyaWFudCIsImhhbmRsZXIiLCJwZWVrIiwidmFsdWUiLCJpZl9lbXB0eV90aGVuX2ZhaWx3aXRoIiwiaXNfZW1wdHkiLCJpc19mdWxsIiwiZmlsbF9leG4iLCJyZW1vdmVfaGFuZGxlciIsImFkZF9oYW5kbGVyIiwiaGFuZGxlciQxIiwiaGFuZGxlciQyIiwicnVuJDEiLCJoYW5kbGVyJDAiLCJoYXNfaGFuZGxlcnMiLCJ1cG9uIiwidXBvbiQwIiwiY29ubmVjdCIsImJpbmRfcmVzdWx0IiwiYmluZF9yaHMiLCJiaW5kX3Jlc3VsdCQwIiwiaXZhciIsImJpbmRfcmhzX2NvbnRlbnRzIiwiaXZhciQwIiwibGFzdDEiLCJsYXN0MiIsImhhbmRsZXIxIiwiZXhlY3V0aW9uX2NvbnRleHQyJDAiLCJydW4yJDAiLCJoYW5kbGVyMSQwIiwidiQwIiwib2ZfaXZhciIsImludmFyaWFudF9hIiwicmV0dXJuJDAiLCJpc19kZXRlcm1pbmVkIiwiYmluZCIsImgiLCJyZWFkIiwiZmlsbF9pZl9lbXB0eSIsInRvX2JpbmFibGUiLCJvZl9iaW5hYmxlIiwic2V4cF9vZl9ob3ciLCJ2XzAwMSIsIm5ldmVyIiwibWFwIiwicmV0dXJuJDEiLCJyZXR1cm4kMiIsInJldHVybiQzIiwidW5pdCIsImJvdGgkMCIsImExIiwiYTIiLCJkb25fdF93YWl0X2ZvciIsIm1hcCQyIiwiZjIiLCJmMSIsInByb2Nlc3MiLCJyZXN0IiwiY2hvaWNlIiwiZW5hYmxlZCIsImNob2ljZXMiLCJ1bnJlZ2lzdGVycyIsInJlYWR5IiwiY2hvb3NlX3Jlc3VsdCIsImNob2ljZXMkMCIsImNob2ljZXMkMSIsImdlbmVyaWNfY2hvb3NlIiwidW5yZWdpc3RlcnMkMCIsImNob29zZTIiLCJmYSIsImIiLCJmYiIsImFfaGFuZGxlciIsImJfaGFuZGxlciIsImF2IiwiY2hvb3NlIiwiYW55X2YiLCJ0cyIsImFueSIsImFueV91bml0IiwiZm9yJDAiLCJkbyQwIiwibG9vcCIsInJlcGVhdF91bnRpbF9maW5pc2hlZCIsInN0YXRlIiwiZmluaXNoZWQiLCJmb3JldmVyIiwiZm9sZCIsImluaXQiLCJ4cyIsInNlcW1hcCIsImJzIiwiZHMiLCJhbGxfdW5pdCIsImQiLCJvayIsIm9mX2FfMDA1IiwieF8wMDYiLCJhcmcwXzAwMiIsInJlczBfMDAzIiwieF8wMDciLCJmaWxsIiwiY29sbGVjdCIsImlzX2Nsb3NlZCIsImNsb3NlX2V4biIsImNsb3NlX2lmX29wZW4iLCJleHRlbmQiLCJkZWZlcnJlZDAiLCJkZWZlcnJlZDEiLCJ0cnlfd2l0aCIsImVycm9yIiwiZGV0YWNoIiwiZGV0YWNoX2FuZF9pdGVyX2Vycm9ycyIsImhhbmRsZXJfc3RhdGVfcmVmIiwicnVuX2YiLCJiYWdfZWx0IiwiaW5uZXJfZXhuJDAiLCJpbm5lcl9leG4iLCJkZXRhY2hfYW5kX2dldF9lcnJvcl9zdHJlYW0iLCJ0YWlsIiwiZ2V0X25leHRfZXJyb3IiLCJkZXRhY2hfYW5kX2dldF9uZXh0X2Vycm9yIiwiZXh0cmFjdF9leG4iLCJjb2x1bW4iLCJtb25pdG9yJDEiLCJuYW1lJDEiLCJiYWNrdHJhY2UkMCIsImJhY2t0cmFjZSQxIiwic3RyaXBfcHJlZml4ZXMiLCJsaW5lcyIsInByZWZpeGVzIiwibGluZSIsInByZWZpeCIsInN1ZmZpeGVzIiwiaW5wdXQiLCJyZXZfaW5wdXQiLCJyZXZfb3V0cHV0IiwiYmFja3RyYWNlJDIiLCJsaXN0X2lmX25vdF9lbXB0eSIsIm1hdGNoJDEiLCJtYXRjaCQyIiwiZXh0cmFjdF9leG4kMCIsImFyZzFfMDA0IiwiYXJnMF8wMDMiLCJhcmcxXzAwOCIsImFyZzBfMDA3IiwicmVzMF8wMDkiLCJyZXMxXzAxMCIsIndpdGhpbl9jb250ZXh0IiwiY29udGV4dCIsIndpdGhpbl9nZW4iLCJ3aXRoaW4iLCJ3aXRoaW5fdiIsIndpdGhpbiQwIiwic2NoZWR1bGVfd2l0aF9kYXRhIiwid29yayIsInVwb25fd29ya19maWxsX2kiLCJzY2hlZHVsZSQwIiwicHJlc2VydmVfZXhlY3V0aW9uX2NvbnRleHQiLCJwcmVzZXJ2ZV9leGVjdXRpb25fY29udGV4dCQwIiwiY2FsbF9hbmRfZmlsbCIsInN0cmVhbV9pdGVyIiwic3RyZWFtIiwiZXhucyIsImZpbGxfcmVzdWx0X2FuZF9oYW5kbGVfYmFja2dybyIsInJlc3VsdF9maWxsZXIiLCJoYW5kbGVfZXhuc19hZnRlcl9yZXN1bHQiLCJ0cnlfd2l0aF9sb2dfZXhuIiwidHJ5X3dpdGgkMCIsInN0aCQwIiwiZG9fZXh0cmFjdF9leG4iLCJzdGgkMSIsInN0aCQyIiwiaGFuZGxlX2V4biIsInJlcyIsInRyeV93aXRoX29yX2Vycm9yIiwidHJ5X3dpdGhfam9pbl9vcl9lcnJvciIsInByb3RlY3QiLCJmaW5hbGx5JDAiLCJmciIsInIkMCIsImZpbmFsbHlfZXhuIiwiaGFuZGxlX2Vycm9ycyIsImNhdGNoX3N0cmVhbSIsImNhdGNoJDAiLCJjYXRjaF9lcnJvciIsImRlcHRoIiwibiQwIiwiZmlyc3RfZXhuIiwiZm9sZCQwIiwibG9vcCQwIiwibG9vcF9uZXh0IiwibG9vcF9uZXh0JDAiLCJjbG9zZWQiLCJ1bmZvbGQiLCJjb3B5X3RvX3RhaWwiLCJhcHBlbmQiLCJmaWx0ZXJfZGVwcmVjYXRlZCIsImZpbHRlcl9tYXBfZGVwcmVjYXRlZCIsIm1hcCQwIiwiZmlyc3RfbiIsImF2YWlsYWJsZV9ub3ciLCJzcGxpdCIsInN0b3AiLCJyZWFzb25fZm9yX3N0b3BwaW5nIiwiZmluaXNoIiwibyIsImZpbmQiLCJmb3VuZCIsInVuZ3JvdXAiLCJpbnRlcmxlYXZlIiwibnVtX29wZW4iLCJjbG9zZSIsIm91dGVyX2Nsb3NlZCIsInRha2VfdW50aWwiLCJ6IiwiaXRlcl9kdXJhYmx5IiwiaXRlcl9kdXJhYmx5X3JlcG9ydF9lbmQiLCJpdGVyX2R1cmFibHkkMCIsIm9mX2Z1biIsInNldF9pdmFyIiwiaGFzX2FueV93YWl0ZXJzIiwic2V0X2hhc19hbnlfd2FpdGVycyIsImhhc19hbnlfd2FpdGVycyQwIiwicmVwciIsIml2YXJfZnVuIiwiaGFzX2FueV93YWl0ZXJzX2Z1biIsIm9mX2FfMDAxIiwiaGFzX2FueV93YWl0ZXJzXzAwMyIsIml2YXJfMDA1IiwiYXJnXzAwNiIsImJuZHNfMDAyIiwiYXJnXzAwNCIsImJuZHNfMDAyJDAiLCJicm9hZGNhc3QiLCJ3YWl0IiwiaGFzX2FueV93YWl0ZXJzJDEiLCJ4XzAwMyIsImJpbmRfdW5pdCIsIndhaXRfZm9yIiwicnVuX3F1ZXVlZF9hbGFybXMiLCJ3YWxrX2FsYXJtcyIsImFkdmFuY2VfdG8iLCJuZXh0X2FsYXJtX2ZpcmVzX2F0JDAiLCJxdWV1ZWRfYWxhcm1zX3JhbiIsInNwYW5fdG9fdGltZSIsInJ1bl9hdF9pbnRlcm5hbCIsInRpbWUiLCJyZW1vdmVfYWxhcm0iLCJvZl9hXzAwNyIsIm9mX2hfMDA4IiwiYXJnMF8wMDkiLCJyZXMwXzAxMCIsImFyZzBfMDExIiwicmVzMF8wMTIiLCJzZXRfc2NoZWR1bGVkX2F0IiwibnVtX2ZpcmVzX3RvX3NraXAiLCJzZXRfbnVtX2ZpcmVzX3RvX3NraXAiLCJmaXJlZCIsInNjaGVkdWxlZF9hdCQwIiwibnVtX2ZpcmVzX3RvX3NraXAkMCIsImZpcmVkJDAiLCJvZl9hXzAxNSIsIm9mX2hfMDE2IiwiYWxhcm1fMDE4IiwiZmlyZWRfMDIyIiwibnVtX2ZpcmVzX3RvX3NraXBfMDI0Iiwic2NoZWR1bGVkX2F0XzAyNiIsInRpbWVfc291cmNlXzAyOCIsImFyZ18wMjkiLCJibmRzXzAxNyIsImFyZ18wMjciLCJibmRzXzAxNyQwIiwiYXJnXzAyNSIsImJuZHNfMDE3JDEiLCJhcmdfMDIzIiwiYm5kc18wMTckMiIsImFyZ18wMjEiLCJibmRzXzAxNyQzIiwiYXJnXzAxOSIsImJuZHNfMDE3JDQiLCJzZXhwX29mX3RfdW5pdCIsInhfMDMwIiwiZmlyZWQkMSIsImludmFyaWFudF9oIiwic2NoZWR1bGVkX2F0X2Z1biIsImFfMDMyIiwiYl8wMzMiLCJudW1fZmlyZXNfdG9fc2tpcF9mdW4iLCJmaXJlZF9mdW4iLCJ4XzAzMSIsIm9mX2FfMDM0Iiwib2ZfaF8wMzUiLCJhcmcwXzAzNiIsInJlczBfMDM3IiwiYXJnMF8wMzgiLCJyZXMwXzAzOSIsImFyZzBfMDQwIiwicmVzMF8wNDEiLCJvZl9hXzA0NCIsIm9mX2hfMDQ1IiwiYXJnMF8wNDYiLCJyZXMwXzA0NyIsImFyZzBfMDQ4IiwicmVzMF8wNDkiLCJ4XzA1MiIsImEkMCIsIm9mX2FfMDUzIiwib2ZfaF8wNTQiLCJhcmcwXzA1NSIsInJlczBfMDU2IiwiYXJnMF8wNTciLCJyZXMwXzA1OCIsImFyZzFfMDYyIiwiYXJnMF8wNjEiLCJyZXMwXzA2MyIsInJlczFfMDY0IiwiaXNfaW5fdGltaW5nX3doZWVsIiwiYW1fdHJ5aW5nX3RvX3Jlc2NoZWR1bGVfaW5fdGhlIiwicnVuX2F0JDAiLCJydW5fYWZ0ZXIkMCIsImF0X3RpbWVzIiwibmV4dF90aW1lIiwiYXRfdmFyeWluZ19pbnRlcnZhbHMiLCJjb21wdXRlX3NwYW4iLCJzdGFydCQwIiwiaW1tZWRpYXRlbHkiLCJydW5fcmVwZWF0ZWRseSIsImNvbnRpbnVlX29uX2Vycm9yIiwic3RvcCQwIiwic3RvcCQxIiwiY29udGludWVfdHJ5X3dpdGgiLCJjb250aW51ZV9mIiwiYmFzZSIsIm9yX2Vycm9yIiwiZXZlcnkiLCJldmVyeSQwIiwic3RhcnQkMSIsInJ1bl9hdF9pbnRlcnZhbHMkMCIsIndpdGhfdGltZW91dCIsInRpbWVvdXQiLCJ3aXRoX3RpbWVvdXRfZXhuIiwib2Zfc3luY2hyb25vdXMiLCJ0b19zeW5jaHJvbm91cyIsImFkdmFuY2VfZGlyZWN0bHlfaWZfcXVpZXNjZW50IiwiaXNfcXVlc2NlbnQiLCJ3aGVlbCIsIm5leHRfYWxhcm0iLCJoYXNfdXBjb21pbmdfZXZlbnQiLCJuZXh0X3VwY29taW5nX2V2ZW50IiwibmV4dF91cGNvbWluZ19ldmVudF9leG4iLCJldmVudF9wcmVjaXNpb24iLCJhZGRfZXZlcnlfY3ljbGVfc3RhcnRfaG9vayIsImhhbmRsZSIsImFkZF9ldmVyeV9jeWNsZV9lbmRfaG9vayIsInJlbW92ZV9zaW5nbGVfY3ljbGVfaG9vayIsImFyciIsImciLCJpZHgiLCJhcnIkMCIsInJlbW92ZV9ldmVyeV9jeWNsZV9zdGFydF9ob29rXyIsInJlbW92ZV9ldmVyeV9jeWNsZV9lbmRfaG9va19leCIsIm1hcF9jeWNsZV90aW1lcyIsImxvbmdfY3ljbGVzIiwiYXRfbGVhc3QiLCJjeWNsZV9udW1fam9icyIsImludCQwIiwidGhyZWFkX3NhZmVfZW5xdWV1ZV9leHRlcm5hbF9qIiwiY3JlYXRlX2FsYXJtIiwiYWRkX2ZpbmFsaXplciIsImhlYXBfYmxvY2siLCJmaW5hbGl6ZXIiLCJhZGRfZmluYWxpemVyX2V4biIsImFkZF9maW5hbGl6ZXJfbGFzdCIsImFkZF9maW5hbGl6ZXJfbGFzdF9leG4iLCJmb3JjZV9jdXJyZW50X2N5Y2xlX3RvX2VuZCIsInJ1bl9jeWNsZSIsIm51bV9qb2JzX3J1bl9hdF9zdGFydF9vZl9jeWNsZSIsImN5Y2xlX3RpbWUiLCJyZXMxXzAwNCIsInJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haSIsIm1ha2VfYXN5bmNfdW51c2FibGUiLCJyZXNldF9pbl9mb3JrZWRfcHJvY2VzcyIsInJlY29yZGluZ19iYWNrdHJhY2VzIiwibWF5X3JldHVybl9pbW1lZGlhdGVseSIsInlpZWxkX2V2ZXJ5IiwiY291bnRfdW50aWxfeWllbGQiLCJ0aGlzX2N5Y2xlX3RpbWUiLCJudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nIiwieWllbGRfdGhlbl9ydW4iLCJ3b3JrZXIiLCJudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nJDAiLCJudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nJDEiLCJidCIsImVucXVldWUkMCIsInF1ZXVlIiwicnVubmluZyIsImV4ZWNfY3R4Iiwic2VtYXBob3JlIiwiYXBwbHkiLCJ0X2YiLCJkZiIsImR2IiwibWF4X2NvbmN1cnJlbnRfam9icyIsIndhaXRlciIsImFib3J0ZWQiLCJwYXJlbnRfbW9uaXRvciIsImVyciIsIm9mX3RodW5rIiwidGh1bmsiLCJzeW1ib2wkMSIsImQxIiwiZDIiLCJvZl9hXzAwMiIsInJlczBfMDA0IiwibGVuZ3RoXzAwNiIsImJuZHNfMDA1IiwibGlzdCIsImNyZWF0ZV9jb3VudGVyIiwicHVzaCIsInBvcF9leG4iLCJzZXhwX29mX291dGNvbWUiLCJ2XzAwMiIsInZfMDAzIiwiY2xlYW5lZCIsIm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQiLCJzZXRfbnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCIsImNhcGFjaXR5X2F2YWlsYWJsZSIsInNldF9jYXBhY2l0eV9hdmFpbGFibGUiLCJudW1fam9ic19ydW5uaW5nIiwic2V0X251bV9qb2JzX3J1bm5pbmciLCJqb2JzX3dhaXRpbmdfdG9fc3RhcnQiLCJqb2JfcmVzb3VyY2VzX25vdF9pbl91c2UiLCJjbGVhbmVkJDAiLCJudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkJDAiLCJjYXBhY2l0eV9hdmFpbGFibGUkMCIsIm51bV9qb2JzX3J1bm5pbmckMCIsImpvYnNfd2FpdGluZ190b19zdGFydCQwIiwiam9iX3Jlc291cmNlc19ub3RfaW5fdXNlJDAiLCJtYXhfY29uY3VycmVudF9qb2JzJDAiLCJvZl9hXzAxMSIsImpvYnNfd2FpdGluZ190b19zdGFydF8wMjIiLCJqb2JfcmVzb3VyY2VzX25vdF9pbl91c2VfMDIwIiwibWF4X2NvbmN1cnJlbnRfam9ic18wMTgiLCJyZXN0XzAxNSIsImNvbnRpbnVlX29uX2Vycm9yXzAxMyIsIm51bV9qb2JzX3J1bm5pbmdfMDI0IiwiY2FwYWNpdHlfYXZhaWxhYmxlXzAyNiIsImlzX2RlYWRfMDI4IiwiY2xlYW5zXzAzMCIsIm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWRfMDMyIiwiY2xlYW5lZF8wMzQiLCJhcmdfMDM1IiwiYm5kc18wMTIiLCJhcmdfMDMzIiwiYm5kc18wMTIkMCIsImFyZ18wMzEiLCJibmRzXzAxMiQxIiwiYm5kc18wMTIkMiIsImJuZHNfMDEyJDMiLCJibmRzXzAxMiQ0Iiwib3V0Y29tZV8wMDkiLCJzdGFydF8wMDYiLCJibmRzXzAwNSQwIiwidl8wMDgiLCJibmRzXzAwNSQxIiwiYm5kc18wMTIkNSIsImJuZHNfMDEyJDYiLCJibmRzXzAxMiQ3IiwiYm5kc18wMTIkOCIsImJuZHNfMDEyJDkiLCJ4XzAzNiIsIm9mX2FfMDM3Iiwib2Zfa2luZF8wMzgiLCJ4XzAzOSIsIm51bV9qb2JzX3dhaXRpbmdfdG9fc3RhcnQiLCJjbGVhbl9yZXNvdXJjZSIsImtpbGwiLCJhdF9raWxsIiwiY2xlYW5lZCQxIiwic3RhcnRfam9iIiwiam9iX3Jlc291cmNlIiwiam9iX3Jlc291cmNlcyIsImNyZWF0ZV93aXRoIiwiY3JlYXRlX3dpdGgkMCIsImVucXVldWVfaW50ZXJuYWwiLCJvdXRjb21lIiwiaW50ZXJuYWxfam9iIiwiaGFuZGxlX2VucXVldWVfcmVzdWx0IiwiZW5xdWV1ZV9mcm9udCIsImVucXVldWVfZnJvbnQkMCIsImVucXVldWVfZXhjbHVzaXZlIiwiZG9uZSIsImZfcGxhY2Vob2xkZXIiLCJzbG90IiwibW9uYWRfc2VxdWVuY2VfaG93IiwiaG93IiwibW9uYWRfc2VxdWVuY2VfaG93MiIsInByaW9yX2pvYnNfZG9uZSIsImFsbF9kdW1teV9qb2JzX3J1bm5pbmciLCJkdW1teV9qb2JzX3J1bm5pbmciLCJjYXBhY2l0eV9hdmFpbGFibGUkMSIsInRocmVhZF9zYWZlX2VucXVldWVfam9iIiwiY3ljbGVfc3RhcnRfbnMiLCJjeWNsZV90aW1lc19ucyIsImN5Y2xlX3RpbWVzIiwiZXZlbnRfcHJlY2lzaW9uX25zIiwiYm9vbCIsInNldF9leGVjdXRpb25fY29udGV4dCQwIiwiYWRkX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2skMCIsImFkZF9ldmVyeV9jeWNsZV9lbmRfaG9vayQwIiwicmVtb3ZlX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2tfJDAiLCJyZW1vdmVfZXZlcnlfY3ljbGVfZW5kX2hvb2tfZXgkMCIsIndpdGhfZXhlY3V0aW9uX2NvbnRleHQkMCIsIndpdGhfZXhlY3V0aW9uX2NvbnRleHQxJDAiLCJjb21wYXJlIiwiY21wX2EiLCJhXzAwMSIsImJfMDAyIiwicmlnaHRfMDA0IiwibGVmdF8wMDMiLCJ2XzAwNiIsImZvbGRpIiwic2VxbWFwaSIsIm91dHB1dCIsIm91dHB1dCQwIiwiaXRlcmkiLCJtYXBpIiwiZmlsdGVyaSIsImJvb2xzIiwiZmlsdGVyX21hcGkiLCJjb25jYXRfbWFwaSIsImZpbmRfbWFwaSIsImF1eCIsImZpbmRpIiwiZWx0IiwiZXhpc3RzaSIsImZvcl9hbGxpIiwiZmlsdGVyX21hcCIsImZpbHRlciIsImNvbmNhdF9tYXAiLCJmaW5kX21hcCIsImV4aXN0cyIsImZvcl9hbGwiLCJqb2JfY291bnQiLCJnZW5fY29tcHV0YXRpb24iLCJ5cyIsInRsIiwiaGQiLCJjaGFuZ2UiLCJ1cGRhdGUiLCJpdGVyX2tleXMiLCJhbGlzdCIsImFsaXN0X2luX2luY3JlYXNpbmdfa2V5X29yZGVyIiwiZm9sZF9yaWdodCIsImFsaXN0X2luX2RlY3JlYXNpbmdfa2V5X29yZGVyIiwiY29tcHV0YXRpb24iLCJqb2JfbWFwIiwic2VxdWVuY2UiLCJmaWx0ZXJfa2V5cyIsIm1lcmdlIiwicmVyYWlzZSIsImdlbmVyYWwiLCJoYXNoYWJsZSIsImdlbmVyYWwkMCIsInJlY3Vyc2l2ZSIsImZfb25lc3RlcCIsIm1lbW9pemVkIiwiY29tYmluZSIsImZhaWwiLCJmYWlsZiIsImZvcm1hdCIsIm1hcF9lcnJvciIsImlnbm9yZV9tIiwiam9pbiIsInN5bWJvbF9iaW5kIiwiZTEiLCJlMiIsInN5bWJvbF9iaW5kJDAiLCJzeW1ib2xfbWFwJDAiLCJva19leG4iLCJvZl9leG4iLCJvZl9leG5fcmVzdWx0IiwibXNnIiwic2V4cF9vZiIsImVycm9yX3MiLCJlcnJvcl9zdHJpbmciLCJlcnJvcmYiLCJ0YWciLCJ0YWdfcyIsInRhZ19zX2xhenkiLCJ0YWdfYXJnIiwidW5pbXBsZW1lbnRlZCIsImNvbWJpbmVfZXJyb3JzIiwiY29tYmluZV9lcnJvcnNfdW5pdCIsImZpbHRlcl9va19hdF9sZWFzdF9vbmUiLCJmaW5kX21hcF9vayIsImN1cnJlbnRfZXJyb3IiLCJlcnJvcnMkMCIsIm9rX3VuaXQiLCJ0cnlfd2l0aF9qb2luIiwibWFwJDEiLCJzdGF0ZSQwIiwiZm9sZF9tYXBpIiwibWFwaV9mIiwiZm9sZF9mIiwidGhyb3R0bGUiLCJjIiwic3RhdGUkMiIsInN0YXRlJDEiLCJjJDEiLCJjJDAiLCJpJDAiLCJhY2N1bSIsIm1heWJlX3YiLCJjb3VudCIsInN1bSIsIk0iLCJzaG93X2RlYnVnX21lc3NhZ2VzIiwiY2hlY2tfaW52YXJpYW50IiwieF8wMDQiLCJ2YWx1ZXNfcmVhZCIsInNldF92YWx1ZXNfcmVhZCIsInZhbHVlc19yZWFkJDAiLCJwaXBlX2lkXzAwOSIsInZhbHVlc19yZWFkXzAxMSIsImJuZHNfMDA4IiwiYm5kc18wMDgkMCIsInZfMDEzIiwiYm5kc18wMDgkMSIsImJuZHNfMDA4JDIiLCJ2YWx1ZXNfc2VudF9kb3duc3RyZWFtIiwidmFsdWVzX3NlbnRfZG93bnN0cmVhbV9hbmRfZmx1Iiwid2hlbl9zZW50X2Rvd25zdHJlYW0iLCJjb25zdW1lciIsIndhbnRzIiwiY29uc3VtZXIkMCIsIndhbnRzJDAiLCJvZl9hXzAyOSIsImNvbnN1bWVyXzAzMyIsIndhbnRzXzAzMSIsImJuZHNfMDMwIiwiYXJnMF8wMTgiLCJyZXMwXzAxOSIsImFyZzBfMDIxIiwidl8wMjAiLCJyZXMwXzAyMiIsImFyZzFfMDI1IiwiYXJnMF8wMjQiLCJyZXMwXzAyNiIsInZfMDIzIiwicmVzMV8wMjciLCJibmRzXzAzMCQwIiwiZmlsbF93aXRoX2VvZiIsImkkMSIsImZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQiLCJyZWFkeV8wMzkiLCJmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkXzAzNyIsImJuZHNfMDM2IiwiYm5kc18wMzYkMCIsImJuZHNfMDM2JDEiLCJjb25zdW1lcnMiLCJzZXRfY29uc3VtZXJzIiwiYmxvY2tlZF9yZWFkcyIsImJsb2NrZWRfZmx1c2hlcyIsIm51bV92YWx1ZXNfcmVhZCIsInB1c2hiYWNrIiwic2V0X3B1c2hiYWNrIiwicmVzZXJ2ZWRfc3BhY2UiLCJzZXRfcmVzZXJ2ZWRfc3BhY2UiLCJzaXplX2J1ZGdldCIsInNldF9zaXplX2J1ZGdldCIsImNvbnN1bWVycyQwIiwiYmxvY2tlZF9yZWFkcyQwIiwiYmxvY2tlZF9mbHVzaGVzJDAiLCJwdXNoYmFjayQwIiwicmVzZXJ2ZWRfc3BhY2UkMCIsInNpemVfYnVkZ2V0JDAiLCJzZXhwX29mX3BpcGUiLCJvZl9hXzA0MSIsIm9mX3BoYW50b21fMDQyIiwiaWRfMDQ0IiwiaW5mb18wNDYiLCJidWZmZXJfMDUwIiwic2l6ZV9idWRnZXRfMDUyIiwicmVzZXJ2ZWRfc3BhY2VfMDU0IiwicHVzaGJhY2tfMDU2IiwibnVtX3ZhbHVlc19yZWFkXzA1OCIsInJlYWRfY2xvc2VkXzA2NiIsImNsb3NlZF8wNjQiLCJibG9ja2VkX3JlYWRzXzA2MiIsImJsb2NrZWRfZmx1c2hlc18wNjAiLCJjb25zdW1lcnNfMDY4IiwidXBzdHJlYW1fZmx1c2hlZHNfMDcwIiwiYm5kc18wNDMiLCJhcmdfMDcxIiwiYm5kc18wNDMkMCIsImFyZ18wNjkiLCJibmRzXzA0MyQxIiwiYXJnXzA2NyIsImJuZHNfMDQzJDIiLCJhcmdfMDY1IiwiYm5kc18wNDMkMyIsImFyZ18wNjMiLCJibmRzXzA0MyQ0IiwiYXJnXzA2MSIsImJuZHNfMDQzJDUiLCJhcmdfMDU5IiwiYm5kc18wNDMkNiIsImFyZ18wNTciLCJibmRzXzA0MyQ3IiwiYXJnXzA1NSIsImJuZHNfMDQzJDgiLCJhcmdfMDUzIiwiYm5kc18wNDMkOSIsImFyZ18wNTEiLCJibmRzXzA0MyQxMCIsInZfMDQ3IiwiYXJnXzA0OSIsImJuZF8wNDgiLCJibmRzXzA0MyQxMSIsImFyZ18wNDUiLCJibmRzXzA0MyQxMiIsImVmZmVjdGl2ZV9zaXplX2J1ZGdldCIsImhhc2giLCJpc19yZWFkX2Nsb3NlZCIsInB1c2hiYWNrJDEiLCJudW1fdmFsdWVzX3dyaXR0ZW4iLCJ1cGRhdGVfbnVtX3ZhbHVlc19yZWFkIiwiZGVsdGEiLCJ4XzA3NSIsInhfMDM1Iiwic2V4cF9vZl9waGFudG9tIiwib2ZfYV8wNzYiLCJ4XzA3NyIsInNleHBfb2ZfcGhhbnRvbSQwIiwib2ZfYV8wNzgiLCJ4XzA3OSIsImlkX3JlZiIsImluaXRpYWxfYnVmZmVyIiwidmFsaWRhdGVfc2l6ZV9idWRnZXQiLCJ1cGRhdGVfcHVzaGJhY2siLCJ4XzA4MCIsImNsb3NlX3JlYWQiLCJ4XzA4MSIsImZsdXNoIiwiY3JlYXRlX3JlYWRlcl9ub3RfY2xvc2Vfb25fZXhjIiwidyIsImNyZWF0ZV9yZWFkZXIiLCJjbG9zZV9vbl9leGNlcHRpb24iLCJjcmVhdGVfd3JpdGVyIiwiY29uc3VtZWRfdmFsdWVzX3NlbnRfZG93bnN0cmVhIiwidmFsdWVzX3dlcmVfcmVhZCIsInZhbHVlc19mbHVzaGVkIiwiZmx1c2hfcmVzdWx0IiwiY29uc3VtZV9vbmUiLCJjb25zdW1lIiwibWF4X3F1ZXVlX2xlbmd0aCIsInJlc3VsdCQwIiwic2V0X3NpemVfYnVkZ2V0JDAiLCJyZXNlcnZlX3NwYWNlIiwiZGVjcmVhc2VfcmVzZXJ2ZWRfc3BhY2UiLCJzdGFydF93cml0ZSIsInhfMDgzIiwic2l6ZSIsInhfMDgyIiwiZmluaXNoX3dyaXRlIiwiYmxvY2tlZF9yZWFkIiwiaXZhciQxIiwidHJhbnNmZXJfaW5fd2l0aG91dF9wdXNoYmFjayIsInRyYW5zZmVyX2luIiwid3JpdGUiLCJ3cml0ZV93aXRob3V0X3B1c2hiYWNrIiwid3JpdGUkMCIsIndyaXRlX3doZW5fcmVhZHkiLCJ3cml0ZV9pZl9vcGVuIiwid3JpdGVfd2l0aG91dF9wdXNoYmFja19pZl9vcGVuIiwiZW5zdXJlX2NvbnN1bWVyX21hdGNoZXMiLCJ4XzA4NSIsInN0YXJ0X3JlYWQiLCJsYWJlbCIsInhfMDg2IiwiZ2VuX3JlYWRfbm93IiwiZ2V0X21heF9xdWV1ZV9sZW5ndGgiLCJtYXhfcXVldWVfbGVuZ3RoJDAiLCJyZWFkX25vdyIsInJlYWRfbm93JDAiLCJyZWFkX25vd19leG4iLCJyZWFkJDAiLCJyZWFkX2V4biIsInZhbHVlc19hdmFpbGFibGUiLCJyZWFkX2Nob2ljZSIsInJlYWRfY2hvaWNlX3NpbmdsZV9jb25zdW1lcl9leCIsInJlYWRfZXhhY3RseSIsIm51bV92YWx1ZXMiLCJhbHJlYWR5X3JlYWQiLCJkb3duc3RyZWFtX2ZsdXNoZWQiLCJ1cHN0cmVhbV9mbHVzaGVkIiwiYWRkX2NvbnN1bWVyIiwicGlwZV9pZCIsImNvbnN1bWVyJDEiLCJ1cHN0cmVhbSIsImRvd25zdHJlYW0iLCJ1cHN0cmVhbV9mbHVzaGVkJDAiLCJhcmcwXzA4NyIsInJlczBfMDg4IiwiZm9sZF9nZW4iLCJmbHVzaGVkIiwiZm9sZF93aXRob3V0X3B1c2hiYWNrIiwid2l0aF9lcnJvcl90b19jdXJyZW50X21vbml0b3IiLCJpdGVyX3dpdGhvdXRfcHVzaGJhY2siLCJtYXhfaXRlcmF0aW9uc19wZXJfam9iIiwibWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiQwIiwibWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiQxIiwicmVtYWluaW5nIiwicmVtYWluaW5nJDAiLCJkcmFpbiIsImRyYWluX2FuZF9jb3VudCIsInJlYWRfYWxsIiwidG9fc3RyZWFtX2RlcHJlY2F0ZWQiLCJvZl9zdHJlYW1fZGVwcmVjYXRlZCIsInRyYW5zZmVyIiwibmV4dF9kZWZlcnJlZCIsImNoZWNrX2Nsb3NlZF9sb29wX25leHQiLCJ0cmFuc2Zlcl9nZW4iLCJsaW5rIiwidW5saW5rIiwiaW5wdXRfYXZhaWxhYmxlX29yX291dHB1dF9jbG9zIiwib3V0cHV0X2Nsb3NlZCIsInRyYW5zZmVyJDAiLCJ0cmFuc2Zlcl9pZCIsIm1hcF9nZW4iLCJjb25jYXRfbWFwX2xpc3QiLCJmaWx0ZXJfbWFwJDAiLCJmb2xkaW5nX2ZpbHRlcl9tYXAiLCJmb2xkaW5nX2ZpbHRlcl9tYXAkMCIsIngkMCIsImZvbGRpbmdfbWFwIiwiYWNjdW0kMCIsIm9mX3F1ZXVlX2ludGVybmFsIiwib2ZfcXVldWUiLCJlbXB0eSIsInNpbmdsZXRvbiIsIndyaXRlciIsInJlYWRlciIsInN5bWJvbCIsIm9mX3NlcXVlbmNlIiwic2VxdWVuY2UkMSIsInNlcXVlbmNlJDAiLCJ0b19zZXF1ZW5jZSIsImludGVybGVhdmVfcGlwZSIsImlucHV0cyIsImNsb3NlX29uIiwib3V0cHV0X3dyaXRlciIsIm51bV9waXBlc19yZW1haW5pbmciLCJjbG9zZV9vbmVfcGlwZSIsImNsb3NlZF9waXBlX2tpbmQiLCJzaG91bGRfY2xvc2UiLCJoZWFwIiwiaGFuZGxlX3JlYWQiLCJlb2Zfb3Jfb2siLCJwb3BfaGVhcF9hbmRfbG9vcCIsImluaXRpYWxfcHVzaCIsImNvbmNhdF9waXBlIiwiZm9yayIsInB1c2hiYWNrX3VzZXMiLCJ3cml0ZXIwIiwicmVhZGVyMCIsIndyaXRlcjEiLCJyZWFkZXIxIiwic29tZV9yZWFkZXJfd2FzX2Nsb3NlZCIsInNvbWVfcmVhZGVyX3dhc19jbG9zZWQkMCIsInN0aWxsX29wZW4iLCJmaWx0ZXJfb3BlbiIsInN0aWxsX29wZW4kMCIsInNldF9pbmZvIiwidmFsdWVfYXZhaWxhYmxlIiwic2V0X3ZhbHVlX2F2YWlsYWJsZSIsInRha2VuIiwiY3VycmVudF92YWx1ZSIsInZhbHVlX2F2YWlsYWJsZSQwIiwidGFrZW4kMCIsImN1cnJlbnRfdmFsdWUkMCIsInZhbHVlX2F2YWlsYWJsZSQxIiwidmFsdWVfYXZhaWxhYmxlX2Z1biIsImFfMDExIiwiYl8wMTIiLCJ0YWtlbl9mdW4iLCJjdXJyZW50X3ZhbHVlX2Z1biIsInhfMDEwIiwidGFrZW5fMDA2IiwiY3VycmVudF92YWx1ZV8wMDQiLCJ2YWx1ZV9hdmFpbGFibGVfMDA4IiwiYm5kc18wMDMiLCJibmRzXzAwMyQwIiwiYm5kc18wMDMkMSIsInBlZWtfZXhuIiwieF8wMTMiLCJvZl9hXzAxNCIsInhfMDE1Iiwib2ZfYV8wMTYiLCJ4XzAxNyIsIndyaXRlX29ubHkiLCJ0YWtlX25vbmVtcHR5IiwidGFrZV9ub3dfZXhuIiwidGFrZV9ub3ciLCJ0YWtlIiwidXBkYXRlX2V4biIsInRha2VuJDEiLCJwdXQiLCJwaXBlX3doZW5fcmVhZHkiLCJyZXN0X2V4biIsImNyZWF0ZV9vcl9lcnJvciIsIndhaXRfZXhuIiwiZm9yY2UiLCJmb3JjZV9leG4iLCJiaW5kJDEiLCJpc19mb3JjZWQiLCJ3YWl0c18wMDMiLCJzaWduYWwiLCJkZWxldGUkMCIsImNoZWNrX2ZpZWxkJDAiLCJ3YWl0X2Zvcl9wcmV2aW91cyIsInN5bWJvbCQwIl0sInNvdXJjZXMiOlsiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC9hc3luY19rZXJuZWxfXy5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvdGltZV9ucy5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvZGVidWcubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL2ltcG9ydC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvcHJpb3JpdHkubWwiLCIvd29ya3NwYWNlX3Jvb3Qvc3JjL3R5cGVzLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC9tb25pdG9yMC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvZXhlY3V0aW9uX2NvbnRleHQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL2V4dGVybmFsX2pvYi5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvam9iX3Bvb2wubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL2pvYi5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvam9iX29yX2V2ZW50Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC9zY2hlZHVsZXIwLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC9qb2JfcXVldWUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL3N5bmNocm9ub3VzX3RpbWVfc291cmNlMC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvc2NoZWR1bGVyMS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvaXZhcjAubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkMC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvaXZhci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvbW9uYWRfc2VxdWVuY2UubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkMS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfc3RkLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC9pdmFyX2ZpbGxlci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvdGFpbC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvbW9uaXRvci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvYXN5bmNfc3RyZWFtLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC9idmFyLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC90aW1lX3NvdXJjZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvY3ljbGVfaG9vay5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvc2NoZWR1bGVyLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC90aHJvdHRsZWQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL3N0YWNrX29yX2NvdW50ZXIubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL3Rocm90dGxlLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC9zeW5jaHJvbm91c190aW1lX3NvdXJjZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvYXN5bmNfa2VybmVsX3NjaGVkdWxlci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvY2xvY2tfaW50Zi5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvY2xvY2tfbnMubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX2FycmF5Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9saXN0Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9tYXAubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX21lbW8ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX29wdGlvbi5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfcmVzdWx0Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9vcl9lcnJvci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfcXVldWUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX3NlcXVlbmNlLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9zZXQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL3JlcXVpcmVfZXhwbGljaXRfdGltZV9zb3VyY2UubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL3BpcGUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL212YXIubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL2xhenlfZGVmZXJyZWQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2NvbmRpdGlvbi5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hc3luY19rZXJuZWwvYXN5bmNfZ2MubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2ludmFyaWFudF9pbnRmLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FzeW5jX2tlcm5lbC9hc3luY19pbnZhcmlhbnQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2tlcm5lbC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztHQWdMd0I7O0lBQUE7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUN6S3BCQSxNQUFNQyxHQUFFQztJQUNHLElBQVRDLFNBQVMsZ0JBRExGLEdBQUVDO0lBRXNCO01BQTdCLGdDQUZPQTtTQUVzQixxQkFENUJDLFFBRElGOztJQUV3RSxPQUQ1RUU7R0FDa0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQUZwRkg7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7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QUNBeWY7T0FDQWhEO09BQ0E5RjtPQUNBb1U7T0FDQUU7T0FDQTlMO09BQ0FFO09BT0FvckI7T0FHQThFO09BR0FqZ0I7Ozs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuQXN5bmNfY29uZGl0aW9uICopXG5tb2R1bGUgQXN5bmNfY29uZGl0aW9uID0gQXN5bmNfa2VybmVsX19Bc3luY19jb25kaXRpb25cblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkFzeW5jX2djICopXG5tb2R1bGUgQXN5bmNfZ2MgPSBBc3luY19rZXJuZWxfX0FzeW5jX2djXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5Bc3luY19pbnZhcmlhbnQgKilcbm1vZHVsZSBBc3luY19pbnZhcmlhbnQgPSBBc3luY19rZXJuZWxfX0FzeW5jX2ludmFyaWFudFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuQXN5bmNfaW52YXJpYW50X2ludGYgKilcbm1vZHVsZSBBc3luY19pbnZhcmlhbnRfaW50ZiA9IEFzeW5jX2tlcm5lbF9fQXN5bmNfaW52YXJpYW50X2ludGZcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkFzeW5jX2tlcm5lbF9zY2hlZHVsZXIgKilcbm1vZHVsZSBBc3luY19rZXJuZWxfc2NoZWR1bGVyID0gQXN5bmNfa2VybmVsX19Bc3luY19rZXJuZWxfc2NoZWR1bGVyXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5Bc3luY19zdHJlYW0gKilcbm1vZHVsZSBBc3luY19zdHJlYW0gPSBBc3luY19rZXJuZWxfX0FzeW5jX3N0cmVhbVxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuQnZhciAqKVxubW9kdWxlIEJ2YXIgPSBBc3luY19rZXJuZWxfX0J2YXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkNsb2NrX2ludGYgKilcbm1vZHVsZSBDbG9ja19pbnRmID0gQXN5bmNfa2VybmVsX19DbG9ja19pbnRmXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5DbG9ja19ucyAqKVxubW9kdWxlIENsb2NrX25zID0gQXN5bmNfa2VybmVsX19DbG9ja19uc1xuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuQ3ljbGVfaG9vayAqKVxubW9kdWxlIEN5Y2xlX2hvb2sgPSBBc3luY19rZXJuZWxfX0N5Y2xlX2hvb2tcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkRlYnVnICopXG5tb2R1bGUgRGVidWcgPSBBc3luY19rZXJuZWxfX0RlYnVnXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5EZWZlcnJlZCAqKVxubW9kdWxlIERlZmVycmVkID0gQXN5bmNfa2VybmVsX19EZWZlcnJlZFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuRGVmZXJyZWQwICopXG5tb2R1bGUgRGVmZXJyZWQwID0gQXN5bmNfa2VybmVsX19EZWZlcnJlZDBcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkRlZmVycmVkMSAqKVxubW9kdWxlIERlZmVycmVkMSA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWQxXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5EZWZlcnJlZF9hcnJheSAqKVxubW9kdWxlIERlZmVycmVkX2FycmF5ID0gQXN5bmNfa2VybmVsX19EZWZlcnJlZF9hcnJheVxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuRGVmZXJyZWRfbGlzdCAqKVxubW9kdWxlIERlZmVycmVkX2xpc3QgPSBBc3luY19rZXJuZWxfX0RlZmVycmVkX2xpc3RcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkRlZmVycmVkX21hcCAqKVxubW9kdWxlIERlZmVycmVkX21hcCA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWRfbWFwXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5EZWZlcnJlZF9tZW1vICopXG5tb2R1bGUgRGVmZXJyZWRfbWVtbyA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWRfbWVtb1xuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuRGVmZXJyZWRfbWVtb19pbnRmICopXG5tb2R1bGUgRGVmZXJyZWRfbWVtb19pbnRmID0gQXN5bmNfa2VybmVsX19EZWZlcnJlZF9tZW1vX2ludGZcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkRlZmVycmVkX29wdGlvbiAqKVxubW9kdWxlIERlZmVycmVkX29wdGlvbiA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWRfb3B0aW9uXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5EZWZlcnJlZF9vcl9lcnJvciAqKVxubW9kdWxlIERlZmVycmVkX29yX2Vycm9yID0gQXN5bmNfa2VybmVsX19EZWZlcnJlZF9vcl9lcnJvclxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuRGVmZXJyZWRfcXVldWUgKilcbm1vZHVsZSBEZWZlcnJlZF9xdWV1ZSA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWRfcXVldWVcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkRlZmVycmVkX3Jlc3VsdCAqKVxubW9kdWxlIERlZmVycmVkX3Jlc3VsdCA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWRfcmVzdWx0XG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5EZWZlcnJlZF9zZXF1ZW5jZSAqKVxubW9kdWxlIERlZmVycmVkX3NlcXVlbmNlID0gQXN5bmNfa2VybmVsX19EZWZlcnJlZF9zZXF1ZW5jZVxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuRGVmZXJyZWRfc2V0ICopXG5tb2R1bGUgRGVmZXJyZWRfc2V0ID0gQXN5bmNfa2VybmVsX19EZWZlcnJlZF9zZXRcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkRlZmVycmVkX3N0ZCAqKVxubW9kdWxlIERlZmVycmVkX3N0ZCA9IEFzeW5jX2tlcm5lbF9fRGVmZXJyZWRfc3RkXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5FeGVjdXRpb25fY29udGV4dCAqKVxubW9kdWxlIEV4ZWN1dGlvbl9jb250ZXh0ID0gQXN5bmNfa2VybmVsX19FeGVjdXRpb25fY29udGV4dFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuRXh0ZXJuYWxfam9iICopXG5tb2R1bGUgRXh0ZXJuYWxfam9iID0gQXN5bmNfa2VybmVsX19FeHRlcm5hbF9qb2JcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkltcG9ydCAqKVxubW9kdWxlIEltcG9ydCA9IEFzeW5jX2tlcm5lbF9fSW1wb3J0XG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5JdmFyICopXG5tb2R1bGUgSXZhciA9IEFzeW5jX2tlcm5lbF9fSXZhclxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuSXZhcjAgKilcbm1vZHVsZSBJdmFyMCA9IEFzeW5jX2tlcm5lbF9fSXZhcjBcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkl2YXJfZmlsbGVyICopXG5tb2R1bGUgSXZhcl9maWxsZXIgPSBBc3luY19rZXJuZWxfX0l2YXJfZmlsbGVyXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5Kb2IgKilcbm1vZHVsZSBKb2IgPSBBc3luY19rZXJuZWxfX0pvYlxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuSm9iX29yX2V2ZW50ICopXG5tb2R1bGUgSm9iX29yX2V2ZW50ID0gQXN5bmNfa2VybmVsX19Kb2Jfb3JfZXZlbnRcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkpvYl9vcl9ldmVudF9pbnRmICopXG5tb2R1bGUgSm9iX29yX2V2ZW50X2ludGYgPSBBc3luY19rZXJuZWxfX0pvYl9vcl9ldmVudF9pbnRmXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5Kb2JfcG9vbCAqKVxubW9kdWxlIEpvYl9wb29sID0gQXN5bmNfa2VybmVsX19Kb2JfcG9vbFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuSm9iX3F1ZXVlICopXG5tb2R1bGUgSm9iX3F1ZXVlID0gQXN5bmNfa2VybmVsX19Kb2JfcXVldWVcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLkxhenlfZGVmZXJyZWQgKilcbm1vZHVsZSBMYXp5X2RlZmVycmVkID0gQXN5bmNfa2VybmVsX19MYXp5X2RlZmVycmVkXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5Nb25hZF9zZXF1ZW5jZSAqKVxubW9kdWxlIE1vbmFkX3NlcXVlbmNlID0gQXN5bmNfa2VybmVsX19Nb25hZF9zZXF1ZW5jZVxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuTW9uaXRvciAqKVxubW9kdWxlIE1vbml0b3IgPSBBc3luY19rZXJuZWxfX01vbml0b3JcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLk1vbml0b3IwICopXG5tb2R1bGUgTW9uaXRvcjAgPSBBc3luY19rZXJuZWxfX01vbml0b3IwXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5NdmFyICopXG5tb2R1bGUgTXZhciA9IEFzeW5jX2tlcm5lbF9fTXZhclxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuUGlwZSAqKVxubW9kdWxlIFBpcGUgPSBBc3luY19rZXJuZWxfX1BpcGVcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLlByaW9yaXR5ICopXG5tb2R1bGUgUHJpb3JpdHkgPSBBc3luY19rZXJuZWxfX1ByaW9yaXR5XG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5SZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlICopXG5tb2R1bGUgUmVxdWlyZV9leHBsaWNpdF90aW1lX3NvdXJjZSA9IEFzeW5jX2tlcm5lbF9fUmVxdWlyZV9leHBsaWNpdF90aW1lX3NvdXJjZVxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuU2NoZWR1bGVyICopXG5tb2R1bGUgU2NoZWR1bGVyID0gQXN5bmNfa2VybmVsX19TY2hlZHVsZXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLlNjaGVkdWxlcjAgKilcbm1vZHVsZSBTY2hlZHVsZXIwID0gQXN5bmNfa2VybmVsX19TY2hlZHVsZXIwXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5TY2hlZHVsZXIxICopXG5tb2R1bGUgU2NoZWR1bGVyMSA9IEFzeW5jX2tlcm5lbF9fU2NoZWR1bGVyMVxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuU3RhY2tfb3JfY291bnRlciAqKVxubW9kdWxlIFN0YWNrX29yX2NvdW50ZXIgPSBBc3luY19rZXJuZWxfX1N0YWNrX29yX2NvdW50ZXJcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLlN5bmNocm9ub3VzX3RpbWVfc291cmNlICopXG5tb2R1bGUgU3luY2hyb25vdXNfdGltZV9zb3VyY2UgPSBBc3luY19rZXJuZWxfX1N5bmNocm9ub3VzX3RpbWVfc291cmNlXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5TeW5jaHJvbm91c190aW1lX3NvdXJjZTAgKilcbm1vZHVsZSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAgPSBBc3luY19rZXJuZWxfX1N5bmNocm9ub3VzX3RpbWVfc291cmNlMFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuVGFpbCAqKVxubW9kdWxlIFRhaWwgPSBBc3luY19rZXJuZWxfX1RhaWxcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLlRocm90dGxlICopXG5tb2R1bGUgVGhyb3R0bGUgPSBBc3luY19rZXJuZWxfX1Rocm90dGxlXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5UaHJvdHRsZWQgKilcbm1vZHVsZSBUaHJvdHRsZWQgPSBBc3luY19rZXJuZWxfX1Rocm90dGxlZFxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuVGltZV9ucyAqKVxubW9kdWxlIFRpbWVfbnMgPSBBc3luY19rZXJuZWxfX1RpbWVfbnNcblxuKCoqIEBjYW5vbmljYWwgQXN5bmNfa2VybmVsLlRpbWVfc291cmNlICopXG5tb2R1bGUgVGltZV9zb3VyY2UgPSBBc3luY19rZXJuZWxfX1RpbWVfc291cmNlXG5cbigqKiBAY2Fub25pY2FsIEFzeW5jX2tlcm5lbC5UaW1lX3NvdXJjZV9pbnRmICopXG5tb2R1bGUgVGltZV9zb3VyY2VfaW50ZiA9IEFzeW5jX2tlcm5lbF9fVGltZV9zb3VyY2VfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBBc3luY19rZXJuZWwuVHlwZXMgKilcbm1vZHVsZSBUeXBlcyA9IEFzeW5jX2tlcm5lbF9fVHlwZXNcblxubW9kdWxlIEFzeW5jX2tlcm5lbF9fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCJpbmNsdWRlIENvcmUuQ29yZV9wcml2YXRlLlRpbWVfbnNfYWx0ZXJuYXRlX3NleHBcblxuKCogW2FmdGVyXSBpcyBsaWtlIFthZGRdLCBidXQgZGVhbHMgbmljZWx5IHdpdGggdGhlIGNhc2Ugb2Ygb3ZlcmZsb3cgYnkgaW5zdGVhZCByZXR1cm5pbmdcbiAgIFttYXhfdmFsdWVdLiAgVGltZS1zb3VyY2UgZnVuY3Rpb25zIHVzZSBbYWZ0ZXJdIHRvIGF2b2lkIGltbWVkaWF0ZWx5IGZpcmluZyBldmVudHMgdGhhdFxuICAgc2hvdWxkIG5ldmVyIGZpcmUsIGR1ZSB0byB0aGUgb3ZlcmZsb3cgbGVhZGluZyB0byBhIG5lZ2F0aXZlIHRpbWUgdGhhdCBhcHBlYXJzIHRvIGJlIGluXG4gICB0aGUgcGFzdC4gIFdlIGRvbid0IGNoZWNrIHVuZGVyZmxvdyBiZWNhdXNlIHRoYXQgaXMgdmVyeSB1bmxpa2VseSwgcmVxdWlyaW5nIGJvdGggYVxuICAgbmVnYXRpdmUgdGltZSBhbmQgYSBuZWdhdGl2ZSBzcGFuLiAqKVxubGV0IGFmdGVyIHQgc3BhbiA9XG4gIGxldCByZXN1bHQgPSBhZGQgdCBzcGFuIGluXG4gIGlmIFNwYW4uKCA+ICkgc3BhbiBTcGFuLnplcm8gJiYgcmVzdWx0IDwgdCB0aGVuIG1heF92YWx1ZV9mb3JfMXVzX3JvdW5kaW5nIGVsc2UgcmVzdWx0XG47O1xuIiwibW9kdWxlIFRpbWVfbnNfaW5fdGhpc19kaXJlY3RvcnkgPSBUaW1lX25zXG5vcGVuIENvcmVcbm1vZHVsZSBUaW1lX25zID0gVGltZV9uc19pbl90aGlzX2RpcmVjdG9yeVxuaW5jbHVkZSBBc3luY19rZXJuZWxfY29uZmlnLlByaW50X2RlYnVnX21lc3NhZ2VzX2ZvclxuXG5sZXQgbG9nIG1lc3NhZ2UgYSBzZXhwX29mX2EgPVxuICBlcHJpbnRmXG4gICAgXCIlc1xcbiUhXCJcbiAgICAoU2V4cC50b19zdHJpbmdfaHVtXG4gICAgICAgKFslc2V4cF9vZjogU2V4cC50ICogVGltZV9ucy50ICogc3RyaW5nICogYV1cbiAgICAgICAgICAoIUFzeW5jX2tlcm5lbF9jb25maWcudGFza19pZCAoKSwgVGltZV9ucy5ub3cgKCksIG1lc3NhZ2UsIGEpKSlcbjs7XG5cbmxldCBsb2dfc3RyaW5nIG1lc3NhZ2UgPSBsb2cgbWVzc2FnZSAoKSBbJXNleHBfb2Y6IHVuaXRdXG4iLCJtb2R1bGUgRGVidWdfaW5fdGhpc19kaXJlY3RvcnkgPSBEZWJ1Z1xubW9kdWxlIFRpbWVfbnNfaW5fdGhpc19kaXJlY3RvcnkgPSBUaW1lX25zXG5vcGVuISBDb3JlXG5pbmNsdWRlIEludC5SZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbm1vZHVsZSBEZWJ1ZyA9IERlYnVnX2luX3RoaXNfZGlyZWN0b3J5XG5tb2R1bGUgVGltZV9ucyA9IFRpbWVfbnNfaW5fdGhpc19kaXJlY3Rvcnlcbm1vZHVsZSBQb29sID0gVHVwbGVfcG9vbFxuXG5tb2R1bGUgTWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgPVxuICBBc3luY19rZXJuZWxfY29uZmlnLk1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlXG5cbmxldCBjb25jYXQgPSBTdHJpbmcuY29uY2F0XG5sZXQgZXByaW50ID0gQ29yZS5EZWJ1Zy5lcHJpbnRcbmxldCBlcHJpbnRfcyA9IENvcmUuRGVidWcuZXByaW50X3NcbmxldCBlcHJpbnRzID0gQ29yZS5EZWJ1Zy5lcHJpbnRzXG5sZXQgcHJpbnRfcyBzZXhwID0gcHJpbnRmIFwiJXNcXG4lIVwiIChzZXhwIHw+IFNleHAudG9fc3RyaW5nX2h1bSlcbmxldCBzZWMgPSBUaW1lX25zLlNwYW4ub2Zfc2VjXG5cbigqIFdlIGRvbid0IHdhbnQgdG8gdXNlIHRoZXNlIG1vZHVsZXMgaW4gQXN5bmNfa2VybmVsLCB0byBhdm9pZCBkaWZmaWN1bHRpZXMgd2l0aFxuICAgdXNpbmcgaXQgb24ganNfb2Zfb2NhbWwuICopXG5tb2R1bGUgVGhyZWFkID0gc3RydWN0IGVuZFxubW9kdWxlIFVuaXggPSBzdHJ1Y3QgZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxudHlwZSB0ID1cbiAgfCBOb3JtYWxcbiAgfCBMb3dcbltAQGRlcml2aW5nIHNleHBfb2YsIGVudW1lcmF0ZV1cblxubGV0IG5vcm1hbCA9IE5vcm1hbFxubGV0IGxvdyA9IExvd1xuIiwiKCogdHlwZXMubWwgKilcblxuKCogPT09PT09PT0gQ2FyZHMsIFBsYXllcnMsIE1lbGRzID09PT09PT09ICopXG5cbnR5cGUgc3VpdCA9IEhlYXJ0cyB8IFNwYWRlcyB8IERpYW1vbmRzIHwgQ2x1YnNcblxudHlwZSByYW5rID1cbiAgfCBUd28gfCBUaHJlZSB8IEZvdXIgfCBGaXZlIHwgU2l4IHwgU2V2ZW5cbiAgfCBFaWdodCB8IE5pbmUgfCBUZW4gfCBKYWNrIHwgUXVlZW4gfCBLaW5nIHwgQWNlXG5cbnR5cGUgY2FyZCA9IHsgc3VpdCA6IHN1aXQ7IHJhbmsgOiByYW5rIH1cblxudHlwZSBtZWxkX2tpbmQgPSBTZXQgfCBSdW5cbnR5cGUgbWVsZCA9IHsga2luZCA6IG1lbGRfa2luZDsgY2FyZHMgOiBjYXJkIGxpc3QgfVxuXG50eXBlIHBsYXllciA9IHtcbiAgaWQgOiBpbnQ7XG4gIG5hbWUgOiBzdHJpbmc7XG4gIGhhbmQgOiBjYXJkIGxpc3Q7XG59XG5cbigqID09PT09PT09IENvbmZpZyAvIFBvbGljeSA9PT09PT09PSAqKVxuXG50eXBlIGFjZV9wb2xpY3kgPSBMb3cgfCBIaWdoXG50eXBlIHNjb3JpbmcgPSB7XG4gIGRlYWR3b29kX3RocmVzaG9sZCA6IGludCBvcHRpb247XG59XG5cbigqID09PT09PT09IFR1cm4gUGhhc2VzICYgQWN0aW9ucyA9PT09PT09PSAqKVxuXG50eXBlIHBoYXNlID0gRHJhdyB8IFBsYXkgfCBEaXNjYXJkIHwgRW5kQ2hlY2tcblxudHlwZSBwbGF5X2FjdGlvbiA9XG4gIHwgTWFrZV9zZXQgb2YgY2FyZCBsaXN0XG4gIHwgTWFrZV9ydW4gb2YgY2FyZCBsaXN0XG4gIHwgTGF5X29mZiBvZiBjYXJkICogaW50ICAgKCogY2FyZCwgbWVsZCBpbmRleCAqKVxuICB8IFNraXBfdG9fZGlzY2FyZFxuXG50eXBlIGRpc2NhcmRfYWN0aW9uID0gRGlzY2FyZF9jYXJkIG9mIGNhcmRcblxuKCogPT09PT09PT0gV2hvbGUgR2FtZSBTdGF0ZSA9PT09PT09PSAqKVxuXG50eXBlIGRyYXdfc291cmNlID1cbiAgfCBGcm9tRGVja1xuICB8IEZyb21EaXNjYXJkXG4gIHwgRnJvbURpc2NhcmROIG9mIGludFxuXG50eXBlIHN0YXRlID0ge1xuICBkZWNrIDogY2FyZCBsaXN0O1xuICBkaXNjYXJkIDogY2FyZCBsaXN0O1xuICBtZWxkcyA6IG1lbGQgbGlzdDtcbiAgcGxheWVycyA6IHBsYXllciBhcnJheTtcbiAgY3VycmVudCA6IGludDtcbiAgcGhhc2UgOiBwaGFzZTtcbiAgYWNlX3BvbGljeSA6IGFjZV9wb2xpY3k7XG4gIHNjb3JpbmcgOiBzY29yaW5nO1xuICByZXF1aXJlZF90b191c2UgOiBjYXJkIG9wdGlvbjtcbiAgc2NvcmVzIDogaW50IGFycmF5O1xufVxuXG4oKiA9PT09PT09PSBQcmV0dHkgaGVscGVycyA9PT09PT09PSAqKVxuXG5sZXQgc3RyaW5nX29mX3N1aXQgPSBmdW5jdGlvblxuICB8IEhlYXJ0cyAtPiBcIuKZpVwiIHwgU3BhZGVzIC0+IFwi4pmgXCIgfCBEaWFtb25kcyAtPiBcIuKZplwiIHwgQ2x1YnMgLT4gXCLimaNcIlxuXG5sZXQgc3RyaW5nX29mX3JhbmsgPSBmdW5jdGlvblxuICB8IFR3by0+XCIyXCJ8VGhyZWUtPlwiM1wifEZvdXItPlwiNFwifEZpdmUtPlwiNVwifFNpeC0+XCI2XCJ8U2V2ZW4tPlwiN1wiXG4gIHwgRWlnaHQtPlwiOFwifE5pbmUtPlwiOVwifFRlbi0+XCIxMFwifEphY2stPlwiSlwifFF1ZWVuLT5cIlFcInxLaW5nLT5cIktcInxBY2UtPlwiQVwiXG5cbmxldCBzdHJpbmdfb2ZfY2FyZCBjID0gUHJpbnRmLnNwcmludGYgXCIlcyVzXCIgKHN0cmluZ19vZl9yYW5rIGMucmFuaykgKHN0cmluZ19vZl9zdWl0IGMuc3VpdCkiLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5cbmxldCBkZWJ1ZyA9IERlYnVnLm1vbml0b3JcblxubW9kdWxlIEZvcndhcmRpbmcgPSBUeXBlcy5Gb3J3YXJkaW5nXG5cbnR5cGUgdCA9IFR5cGVzLk1vbml0b3IudCA9XG4gIHsgbmFtZSA6IEluZm8udFxuICA7IGhlcmUgOiBTb3VyY2VfY29kZV9wb3NpdGlvbi50IG9wdGlvblxuICA7IGlkIDogaW50XG4gIDsgbXV0YWJsZSBuZXh0X2Vycm9yIDogZXhuIFR5cGVzLkl2YXIudFxuICA7ICgqIFtNb25pdG9yLnNlbmRfZXhuXSBzY2hlZHVsZXMgYSBqb2IgZm9yIGVhY2ggZWxlbWVudCBvZiBbaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnNdLiAqKVxuICAgIG11dGFibGUgaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnMgOiAoVHlwZXMuRXhlY3V0aW9uX2NvbnRleHQudCAqIChleG4gLT4gdW5pdCkpIEJhZy50XG4gIDsgKCogW01vbml0b3Iuc2VuZF9leG5dIGV4dGVuZHMgZWFjaCB0YWlsIGluIFt0YWlsc19mb3JfYWxsX2Vycm9yc10uICopXG4gICAgbXV0YWJsZSB0YWlsc19mb3JfYWxsX2Vycm9ycyA6IGV4biBUeXBlcy5UYWlsLnQgbGlzdFxuICA7IG11dGFibGUgaGFzX3NlZW5fZXJyb3IgOiBib29sXG4gIDsgbXV0YWJsZSBmb3J3YXJkaW5nIDogRm9yd2FyZGluZy50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycyB+aXRlcmF0b3JzOml0ZXJdXG5cbmxldCBkZXNjcmlwdGlvbiB0ID1cbiAgbWF0Y2ggdC5oZXJlIHdpdGhcbiAgfCBOb25lIC0+IFslc2V4cCAodC5uYW1lIDogSW5mby50KV1cbiAgfCBTb21lIGhlcmUgLT4gWyVzZXhwICh0Lm5hbWUgOiBJbmZvLnQpLCAoaGVyZSA6IFNvdXJjZV9jb2RlX3Bvc2l0aW9uLnQpXVxuOztcblxubGV0IGRlc2NyaXB0aW9ucyA9XG4gIGxldCByZWMgbG9vcCB0IGFjID1cbiAgICBsZXQgYWMgPSBkZXNjcmlwdGlvbiB0IDo6IGFjIGluXG4gICAgbWF0Y2ggdC5mb3J3YXJkaW5nIHdpdGhcbiAgICB8IERldGFjaGVkIHwgUmVwb3J0X3VuY2F1Z2h0X2V4biAtPiBMaXN0LnJldiBhY1xuICAgIHwgUGFyZW50IHQgLT4gbG9vcCB0IGFjXG4gIGluXG4gIGZ1biB0IC0+IGxvb3AgdCBbXVxuOztcblxubGV0IHNleHBfb2ZfdCB0ID0gWyVzZXhwIChkZXNjcmlwdGlvbnMgdCA6IFNleHAudCBsaXN0KV1cblxubGV0IG5leHRfaWQgPVxuICBsZXQgciA9IHJlZiAwIGluXG4gIGZ1biAoKSAtPlxuICAgIGluY3IgcjtcbiAgICAhclxuOztcblxubGV0IGNyZWF0ZV93aXRoX3BhcmVudCA/aGVyZSA/aW5mbyA/bmFtZSBwYXJlbnQgPVxuICBsZXQgaWQgPSBuZXh0X2lkICgpIGluXG4gIGxldCBuYW1lID1cbiAgICBtYXRjaCBpbmZvLCBuYW1lIHdpdGhcbiAgICB8IFNvbWUgaSwgTm9uZSAtPiBpXG4gICAgfCBTb21lIGksIFNvbWUgcyAtPiBJbmZvLnRhZyBpIH50YWc6c1xuICAgIHwgTm9uZSwgU29tZSBzIC0+IEluZm8ub2Zfc3RyaW5nIHNcbiAgICB8IE5vbmUsIE5vbmUgLT4gSW5mby5jcmVhdGUgXCJpZFwiIGlkIFslc2V4cF9vZjogaW50IFNleHBfaGlkZGVuX2luX3Rlc3QudF1cbiAgaW5cbiAgbGV0IHQgPVxuICAgIHsgbmFtZVxuICAgIDsgaGVyZVxuICAgIDsgZm9yd2FyZGluZyA9XG4gICAgICAgIChtYXRjaCBwYXJlbnQgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IFJlcG9ydF91bmNhdWdodF9leG5cbiAgICAgICAgIHwgU29tZSBwYXJlbnQgLT4gUGFyZW50IHBhcmVudClcbiAgICA7IGlkXG4gICAgOyBuZXh0X2Vycm9yID0geyBjZWxsID0gRW1wdHkgfVxuICAgIDsgaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnMgPSBCYWcuY3JlYXRlICgpXG4gICAgOyB0YWlsc19mb3JfYWxsX2Vycm9ycyA9IFtdXG4gICAgOyBoYXNfc2Vlbl9lcnJvciA9IGZhbHNlXG4gICAgfVxuICBpblxuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZyBcImNyZWF0ZWQgbW9uaXRvclwiIHQgWyVzZXhwX29mOiB0XTtcbiAgdFxuOztcblxubGV0IG1haW4gPSBjcmVhdGVfd2l0aF9wYXJlbnQgfm5hbWU6XCJtYWluXCIgTm9uZVxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgTW9uaXRvciA9IE1vbml0b3IwXG5cbnR5cGUgdCA9IFR5cGVzLkV4ZWN1dGlvbl9jb250ZXh0LnQgPVxuICB7IG1vbml0b3IgOiBNb25pdG9yLnRcbiAgOyBwcmlvcml0eSA6IFByaW9yaXR5LnRcbiAgOyBsb2NhbF9zdG9yYWdlIDogVW5pdl9tYXAudFxuICA7IGJhY2t0cmFjZV9oaXN0b3J5IDogQmFja3RyYWNlLnQgbGlzdFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMsIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5cbmxldCBtYWluID1cbiAgeyBtb25pdG9yID0gTW9uaXRvci5tYWluXG4gIDsgcHJpb3JpdHkgPSBQcmlvcml0eS5ub3JtYWxcbiAgOyBsb2NhbF9zdG9yYWdlID0gVW5pdl9tYXAuZW1wdHlcbiAgOyBiYWNrdHJhY2VfaGlzdG9yeSA9IFtdXG4gIH1cbjs7XG5cbmxldCBjcmVhdGVfbGlrZSA/bW9uaXRvciA/cHJpb3JpdHkgP2xvY2FsX3N0b3JhZ2UgdCA9XG4gIG1hdGNoIG1vbml0b3IsIHByaW9yaXR5LCBsb2NhbF9zdG9yYWdlIHdpdGhcbiAgfCBOb25lLCBOb25lLCBOb25lIC0+XG4gICAgKCogYXZvaWQgYWxsb2NhdGluZyBpbiB0aGUgdHJpdmlhbCBjYXNlLCB3aGljaCBlLmcuIGhhcHBlbnMgd2hlbiBjYWxsaW5nXG4gICAgICAgW0FzeW5jLnNjaGVkdWxlXSB3aXRob3V0IG9wdGlvbmFsIGFyZ3MgKilcbiAgICB0XG4gIHwgXyAtPlxuICAgIGxldCBtb25pdG9yID0gT3B0aW9uLnZhbHVlIG1vbml0b3IgfmRlZmF1bHQ6dC5tb25pdG9yIGluXG4gICAgeyBtb25pdG9yXG4gICAgOyBwcmlvcml0eSA9IE9wdGlvbi52YWx1ZSBwcmlvcml0eSB+ZGVmYXVsdDp0LnByaW9yaXR5XG4gICAgOyBsb2NhbF9zdG9yYWdlID0gT3B0aW9uLnZhbHVlIGxvY2FsX3N0b3JhZ2UgfmRlZmF1bHQ6dC5sb2NhbF9zdG9yYWdlXG4gICAgOyBiYWNrdHJhY2VfaGlzdG9yeSA9IHQuYmFja3RyYWNlX2hpc3RvcnlcbiAgICB9XG47O1xuXG5sZXQgZmluZF9sb2NhbCB0IGtleSA9IFVuaXZfbWFwLmZpbmQgdC5sb2NhbF9zdG9yYWdlIGtleVxuXG5sZXQgd2l0aF9sb2NhbCB0IGtleSBkYXRhID1cbiAgbWF0Y2ggZGF0YSB3aXRoXG4gIHwgU29tZSBkYXRhIC0+IHsgdCB3aXRoIGxvY2FsX3N0b3JhZ2UgPSBVbml2X21hcC5zZXQgdC5sb2NhbF9zdG9yYWdlIH5rZXkgfmRhdGEgfVxuICB8IE5vbmUgLT4geyB0IHdpdGggbG9jYWxfc3RvcmFnZSA9IFVuaXZfbWFwLnJlbW92ZSB0LmxvY2FsX3N0b3JhZ2Uga2V5IH1cbjs7XG5cbmxldCByZWNvcmRfYmFja3RyYWNlIHQgPVxuICB7IHQgd2l0aCBiYWNrdHJhY2VfaGlzdG9yeSA9IEJhY2t0cmFjZS5nZXQgKCkgOjogdC5iYWNrdHJhY2VfaGlzdG9yeSB9XG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIFR5cGVzLkV4dGVybmFsX2pvYlxuXG5sZXQgc2V4cF9vZl90IF8gPSBTZXhwLkF0b20gXCI8am9iPlwiXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4gUG9vbFxuXG5sZXQgZHVtbXlfZSA9IEV4ZWN1dGlvbl9jb250ZXh0Lm1haW5cbmxldCBkdW1teV9mIDogT2JqLnQgLT4gdW5pdCA9IGlnbm9yZVxubGV0IGR1bW15X2EgOiBPYmoudCA9IE9iai5yZXByICgpXG5cbnR5cGUgc2xvdHMgPSAoRXhlY3V0aW9uX2NvbnRleHQudCwgT2JqLnQgLT4gdW5pdCwgKE9iai50W0BzZXhwLm9wYXF1ZV0pKSBTbG90cy50M1xuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxudHlwZSB0ID0gc2xvdHMgUG9vbC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgdCA9IFBvb2wuaW52YXJpYW50IGlnbm9yZSB0XG5sZXQgY3JlYXRlICgpID0gY3JlYXRlIFNsb3RzLnQzIH5jYXBhY2l0eToxIH5kdW1teTooZHVtbXlfZSwgZHVtbXlfZiwgZHVtbXlfYSlcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPSBKb2JfcG9vbC5zbG90cyBQb29sLlBvaW50ZXIudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgRXZlbnQgPSBUeXBlcy5FdmVudFxubW9kdWxlIEpvYiA9IFR5cGVzLkpvYlxuaW5jbHVkZSBUeXBlcy5Kb2Jfb3JfZXZlbnRcblxuKCogVGhpcyByZWRlZmluaXRpb24gb2YgW0V2ZW50XSBpcyBoZXJlIHNvIHRoZSB0eXBlIGNoZWNrcyBhcmUgcmlnaHQgbmV4dCB0b1xuICAgW09iai5tYWdpY11zLiAqKVxubW9kdWxlIF8gOiBzaWcgZW5kID0gc3RydWN0XG4gIG9wZW4gVHlwZXNcbiAgb3BlbiBFdmVudFxuXG4gIHR5cGUgX3QgPSB0ID1cbiAgICB7ICgqIG11c3QgbmV2ZXIgYmUgaW1tZWRpYXRlICopXG4gICAgICBtdXRhYmxlIGFsYXJtIDogSm9iX29yX2V2ZW50LnQgVGltaW5nX3doZWVsLkFsYXJtLnRcbiAgICA7IG11dGFibGUgYXQgOiBUaW1lX25zLnRcbiAgICA7IGNhbGxiYWNrIDogdW5pdCAtPiB1bml0XG4gICAgOyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICA7IG11dGFibGUgaW50ZXJ2YWwgOiBUaW1lX25zLlNwYW4udCBvcHRpb25cbiAgICA7IG11dGFibGUgbmV4dF9maXJlZCA6IE9wdGlvbi50XG4gICAgOyBtdXRhYmxlIHByZXZfZmlyZWQgOiBPcHRpb24udFxuICAgIDsgbXV0YWJsZSBzdGF0dXMgOiBTdGF0dXMudFxuICAgIH1cbmVuZFxuXG5tb2R1bGUgXyA6IHNpZyBlbmQgPSBzdHJ1Y3RcbiAgbW9kdWxlIEVuc3VyZV9wcml2YXRlX2ludCAoTSA6IHNpZ1xuICAgIHR5cGUgdCA9IHByaXZhdGUgaW50XG4gIGVuZCkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIF90ID0gTS50XG4gIGVuZFxuXG4gIGluY2x1ZGUgRW5zdXJlX3ByaXZhdGVfaW50IChKb2IpXG5lbmRcblxubGV0IG9mX2V2ZW50IGV2ZW50IDogdCA9IE9iai5tYWdpYyAoZXZlbnQgOiBFdmVudC50KVxubGV0IG9mX2pvYiBqb2IgOiB0ID0gT2JqLm1hZ2ljIChqb2IgOiBKb2IudClcbmxldCBpc19ldmVudCAodCA6IHQpID0gT2JqLmlzX2Jsb2NrIChPYmoucmVwciB0KVxubGV0IGlzX2pvYiAodCA6IHQpID0gT2JqLmlzX2ludCAoT2JqLnJlcHIgdClcblxubW9kdWxlIE1hdGNoID0gc3RydWN0XG4gIHR5cGUgXyBraW5kID1cbiAgICB8IEV2ZW50IDogRXZlbnQudCBraW5kXG4gICAgfCBKb2IgOiBKb2IudCBraW5kXG5cbiAgdHlwZSBwYWNrZWQgPSBLIDogXyBraW5kIC0+IHBhY2tlZCBbQEB1bmJveGVkXVxuXG4gIGxldCBraW5kIHQgPSBpZiBpc19ldmVudCB0IHRoZW4gSyBFdmVudCBlbHNlIEsgSm9iXG4gIGxldCBwcm9qZWN0ICh0eXBlIGEpIChfIDogYSBraW5kKSBqb2Jfb3JfZXZlbnQgPSAoT2JqLm1hZ2ljIDogdCAtPiBhKSBqb2Jfb3JfZXZlbnRcbmVuZFxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIFR5cGVzLlNjaGVkdWxlclxuXG5sZXQgZXZlbnRzIHQgPSB0LnRpbWVfc291cmNlLmV2ZW50c1xuXG5sZXQgc2V0X2V4ZWN1dGlvbl9jb250ZXh0IHQgZXhlY3V0aW9uX2NvbnRleHQgPVxuICAoKiBBdm9pZCBhIGNhbWxfbW9kaWZ5IGluIG1vc3QgY2FzZXMuICopXG4gIGlmIG5vdCAocGh5c19lcXVhbCB0LmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgZXhlY3V0aW9uX2NvbnRleHQpXG4gIHRoZW4gdC5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IDwtIGV4ZWN1dGlvbl9jb250ZXh0XG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyMFxuXG5sZXQgZHVtbXlfZSA9IEV4ZWN1dGlvbl9jb250ZXh0Lm1haW5cbmxldCBkdW1teV9mIDogT2JqLnQgLT4gdW5pdCA9IGlnbm9yZVxubGV0IGR1bW15X2EgOiBPYmoudCA9IE9iai5yZXByICgpXG5sZXQgc2xvdHNfcGVyX2VsdCA9IDNcblxubW9kdWxlIEEgPSBVbmlmb3JtX2FycmF5XG5cbigqIFRoaXMgaXMgZXNzZW50aWFsbHkgYSBzcGVjaWFsaXplZCBbRmxhdF9xdWV1ZV0sIGRvbmUgZm9yIHJlYXNvbnMgb2Ygc3BlZWQuICopXG50eXBlIHQgPSBUeXBlcy5Kb2JfcXVldWUudCA9XG4gIHsgbXV0YWJsZSBudW1fam9ic19ydW4gOiBpbnRcbiAgOyBtdXRhYmxlIGpvYnNfbGVmdF90aGlzX2N5Y2xlIDogaW50XG4gIDsgKCogW2pvYnNdIGlzIGFuIGFycmF5IG9mIGxlbmd0aCBbY2FwYWNpdHkgdCAqIHNsb3RzX3Blcl9lbHRdLCB3aGVyZSBlYWNoIGVsdCBoYXMgdGhlXG4gICAgICAgdGhyZWUgY29tcG9uZW50cyBvZiBhIGpvYiAoW2V4ZWN1dGlvbl9jb250ZXh0XSwgW2ZdLCBbYV0pIGluIGNvbnNlY3V0aXZlIHNwb3RzIGluXG4gICAgICAgW2pvYnNdLiAgW2VucXVldWVdIGRvdWJsZXMgdGhlIGxlbmd0aCBvZiBbam9ic10gaWYgW2pvYnNdIGlzIGZ1bGwuICBbam9ic10gbmV2ZXJcbiAgICAgICBzaHJpbmtzLiAgW2pvYnNdIGlzIHNvbWV3aGF0IGxpa2UgYSBbQ29yZS5Qb29sXSBzcGVjaWFsaXplZCB0byAzLXR1cGxlczsgd2VcbiAgICAgICBkb24ndCB1c2UgW1Bvb2xdIGJlY2F1c2UgdGhhdCBpbXBsZW1lbnRzIGEgc2V0LCB3aGVyZSBbam9ic10gaXMgYSBxdWV1ZS4gKilcbiAgICBtdXRhYmxlIGpvYnMgOiAoT2JqLnQgQS50W0BzZXhwLm9wYXF1ZV0pXG4gIDsgKCogW21hc2tdIGlzIFtjYXBhY2l0eSB0IC0gMV0sIGFuZCBpcyB1c2VkIGZvciBxdWlja2x5IGNvbXB1dGluZyBbaSBtb2QgKGNhcGFjaXR5XG4gICAgICAgdCldLiBBIHNwZWNpYWwgY2FzZSB3aGVuIHRoZSBqb2IgcXVldWUgaGFzIGNhcGFjaXR5IDAgaXMgcmVwcmVzZW50ZWRcbiAgICAgICB3aXRoIFttYXNrID0gLTFdLiBUaGlzIHZhbHVlIGlzIG5vdCB1c2VmdWwgYXMgYSBiaXQtbWFzaywgYnV0IHdlIG9ubHkgdXNlXG4gICAgICAgdGhlIGJpdC1tYXNrIHdoZW4gdGhlcmUncyBjYXBhY2l0eSBpbiB0aGUgYXJyYXksIHNvIHRoYXQgaXMgbm90IGEgcHJvYmxlbS5cbiAgICAqKVxuICAgIG11dGFibGUgbWFzayA6IGludFxuICA7ICgqIFtmcm9udF0gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBqb2IgaW4gdGhlIHF1ZXVlLiAgVGhlIGFycmF5IGluZGV4IG9mIHRoYXQgam9iJ3NcbiAgICAgICBleGVjdXRpb24gY29udGV4dCBpcyBbZnJvbnQgKiBzbG90c19wZXJfZWx0XS4gKilcbiAgICBtdXRhYmxlIGZyb250IDogaW50XG4gIDsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgOyBtdXRhYmxlIGJhY2t0cmFjZV9vZl9maXJzdF9lbnF1ZXVlIDogQmFja3RyYWNlLnQgb3B0aW9uXG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbmxldCBvZmZzZXQgdCBpID0gKHQuZnJvbnQgKyBpKSBsYW5kIHQubWFzayAqIHNsb3RzX3Blcl9lbHRcbmxldCBjYXBhY2l0eSB0ID0gdC5tYXNrICsgMVxuXG5sZXQgaW52YXJpYW50IHQgOiB1bml0ID1cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5udW1fam9ic19ydW46KGNoZWNrIChmdW4gbnVtX2pvYnNfcnVuIC0+IGFzc2VydCAobnVtX2pvYnNfcnVuID49IDApKSlcbiAgICAgIH5qb2JzX2xlZnRfdGhpc19jeWNsZTpcbiAgICAgICAgKGNoZWNrIChmdW4gam9ic19sZWZ0X3RoaXNfY3ljbGUgLT4gYXNzZXJ0IChqb2JzX2xlZnRfdGhpc19jeWNsZSA+PSAwKSkpXG4gICAgICB+am9iczpcbiAgICAgICAgKGNoZWNrIChmdW4gam9icyAtPlxuICAgICAgICAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICAgICAgICAgRXhlY3V0aW9uX2NvbnRleHQuaW52YXJpYW50XG4gICAgICAgICAgICAgICAoT2JqLm9iaiAoQS5nZXQgam9icyAob2Zmc2V0IHQgaSkpIDogRXhlY3V0aW9uX2NvbnRleHQudClcbiAgICAgICAgICAgZG9uZSkpXG4gICAgICB+bWFzazpcbiAgICAgICAgKGNoZWNrIChmdW4gbWFzayAtPlxuICAgICAgICAgICBsZXQgY2FwYWNpdHkgPSBtYXNrICsgMSBpblxuICAgICAgICAgICBhc3NlcnQgKGNhcGFjaXR5ID0gMCB8fCBJbnQuaXNfcG93MiBjYXBhY2l0eSk7XG4gICAgICAgICAgIGFzc2VydCAoY2FwYWNpdHkgKiBzbG90c19wZXJfZWx0ID0gQS5sZW5ndGggdC5qb2JzKSkpXG4gICAgICB+YmFja3RyYWNlX29mX2ZpcnN0X2VucXVldWU6KGZ1biBfIC0+ICgpKVxuICAgICAgfmZyb250OlxuICAgICAgICAoY2hlY2sgKGZ1biBmcm9udCAtPlxuICAgICAgICAgICBhc3NlcnQgKGZyb250ID49IDApO1xuICAgICAgICAgICBhc3NlcnQgKGZyb250IDwgbWF4IDEgKGNhcGFjaXR5IHQpKSkpXG4gICAgICB+bGVuZ3RoOlxuICAgICAgICAoY2hlY2sgKGZ1biBsZW5ndGggLT5cbiAgICAgICAgICAgYXNzZXJ0IChsZW5ndGggPj0gMCk7XG4gICAgICAgICAgIGFzc2VydCAobGVuZ3RoIDw9IGNhcGFjaXR5IHQpKSkpXG47O1xuXG5sZXQgY3JlYXRlX2FycmF5IH5jYXBhY2l0eSA9IEEuY3JlYXRlX29ial9hcnJheSB+bGVuOihjYXBhY2l0eSAqIHNsb3RzX3Blcl9lbHQpXG5cbmxldCBjcmVhdGUgKCkgPVxuICAoKiBXZSBzdGFydCB3aXRoIFtjYXBhY2l0eSAgPSAwXSBzbyB0aGF0IHRoZSBmaXJzdCBqb2IgdGhhdCBpcyBhZGRlZCBjYWxscyBbZ3Jvd10gYW5kXG4gICAgIGZpbGxzIGluIHRoZSBbYmFja3RyYWNlX29mX2ZpcnN0X2VucXVldWVdLiAqKVxuICBsZXQgY2FwYWNpdHkgPSAwIGluXG4gIHsgbnVtX2pvYnNfcnVuID0gMFxuICA7IGpvYnNfbGVmdF90aGlzX2N5Y2xlID0gMFxuICA7IGpvYnMgPSBjcmVhdGVfYXJyYXkgfmNhcGFjaXR5XG4gIDsgbWFzayA9IGNhcGFjaXR5IC0gMVxuICA7IGZyb250ID0gMFxuICA7IGxlbmd0aCA9IDBcbiAgOyBiYWNrdHJhY2Vfb2ZfZmlyc3RfZW5xdWV1ZSA9IE5vbmVcbiAgfVxuOztcblxubGV0IGJhY2t0cmFjZV9vZl9maXJzdF9lbnF1ZXVlIHQgPSB0LmJhY2t0cmFjZV9vZl9maXJzdF9lbnF1ZXVlXG5cbmxldCBjbGVhciB0ID1cbiAgdC5mcm9udCA8LSAwO1xuICB0Lmxlbmd0aCA8LSAwO1xuICB0LmpvYnNfbGVmdF90aGlzX2N5Y2xlIDwtIDBcbjs7XG5cbmxldCBncm93IHQgPVxuICAobWF0Y2ggdC5iYWNrdHJhY2Vfb2ZfZmlyc3RfZW5xdWV1ZSB3aXRoXG4gICB8IFNvbWUgXyAtPiBhc3NlcnQgKGNhcGFjaXR5IHQgPiAwKVxuICAgfCBOb25lIC0+IHQuYmFja3RyYWNlX29mX2ZpcnN0X2VucXVldWUgPC0gU29tZSAoQmFja3RyYWNlLmdldCAoKSkpO1xuICBsZXQgb2xkX2NhcGFjaXR5ID0gY2FwYWNpdHkgdCBpblxuICBsZXQgbmV3X2NhcGFjaXR5ID0gbWF4IDEgKG9sZF9jYXBhY2l0eSAqIDIpIGluXG4gIGxldCBvbGRfam9icyA9IHQuam9icyBpblxuICBsZXQgb2xkX2Zyb250ID0gdC5mcm9udCBpblxuICBsZXQgbGVuMSA9IEludC5taW4gdC5sZW5ndGggKG9sZF9jYXBhY2l0eSAtIG9sZF9mcm9udCkgKiBzbG90c19wZXJfZWx0IGluXG4gIGxldCBsZW4yID0gKHQubGVuZ3RoICogc2xvdHNfcGVyX2VsdCkgLSBsZW4xIGluXG4gIGxldCBuZXdfam9icyA9IGNyZWF0ZV9hcnJheSB+Y2FwYWNpdHk6bmV3X2NhcGFjaXR5IGluXG4gIEEuYmxpdFxuICAgIH5sZW46bGVuMVxuICAgIH5zcmM6b2xkX2pvYnNcbiAgICB+c3JjX3Bvczoob2xkX2Zyb250ICogc2xvdHNfcGVyX2VsdClcbiAgICB+ZHN0Om5ld19qb2JzXG4gICAgfmRzdF9wb3M6MDtcbiAgQS5ibGl0IH5sZW46bGVuMiB+c3JjOm9sZF9qb2JzIH5zcmNfcG9zOjAgfmRzdDpuZXdfam9icyB+ZHN0X3BvczpsZW4xO1xuICB0Lm1hc2sgPC0gbmV3X2NhcGFjaXR5IC0gMTtcbiAgdC5qb2JzIDwtIG5ld19qb2JzO1xuICB0LmZyb250IDwtIDBcbjs7XG5cbmxldCBzZXQgKHR5cGUgYSkgdCBpIGV4ZWN1dGlvbl9jb250ZXh0IGYgYSA9XG4gIGxldCBvZmZzZXQgPSBvZmZzZXQgdCBpIGluXG4gIEEudW5zYWZlX3NldCB0LmpvYnMgb2Zmc2V0IChPYmoucmVwciAoZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50KSk7XG4gIEEudW5zYWZlX3NldCB0LmpvYnMgKG9mZnNldCArIDEpIChPYmoucmVwciAoZiA6IGEgLT4gdW5pdCkpO1xuICBBLnVuc2FmZV9zZXQgdC5qb2JzIChvZmZzZXQgKyAyKSAoT2JqLnJlcHIgKGEgOiBhKSlcbjs7XG5cbmxldCBlbnF1ZXVlIHQgZXhlY3V0aW9uX2NvbnRleHQgZiBhID1cbiAgaWYgdC5sZW5ndGggPSBjYXBhY2l0eSB0IHRoZW4gZ3JvdyB0O1xuICBzZXQgdCB0Lmxlbmd0aCBleGVjdXRpb25fY29udGV4dCBmIGE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuOztcblxubGV0IHNldF9qb2JzX2xlZnRfdGhpc19jeWNsZSB0IG4gPVxuICBpZiBuIDwgMFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlIFwiSm9icy5zZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUgZ290IG5lZ2F0aXZlIG51bWJlclwiIChuIDogaW50KSAodCA6IHQpXTtcbiAgdC5qb2JzX2xlZnRfdGhpc19jeWNsZSA8LSBuXG47O1xuXG5sZXQgY2FuX3J1bl9hX2pvYiB0ID0gdC5sZW5ndGggPiAwICYmIHQuam9ic19sZWZ0X3RoaXNfY3ljbGUgPiAwXG5cbmxldCBydW5fam9iIHQgKHNjaGVkdWxlciA6IFNjaGVkdWxlci50KSBleGVjdXRpb25fY29udGV4dCBmIGEgPVxuICB0Lm51bV9qb2JzX3J1biA8LSB0Lm51bV9qb2JzX3J1biArIDE7XG4gIFNjaGVkdWxlci5zZXRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0O1xuICBmIGFcbjs7XG5cbmxldCBydW5fZXh0ZXJuYWxfam9icyB0IChzY2hlZHVsZXIgOiBTY2hlZHVsZXIudCkgPVxuICBsZXQgZXh0ZXJuYWxfam9icyA9IHNjaGVkdWxlci5leHRlcm5hbF9qb2JzIGluXG4gIHdoaWxlIFRocmVhZF9zYWZlX3F1ZXVlLmxlbmd0aCBleHRlcm5hbF9qb2JzID4gMCBkb1xuICAgIGxldCAoRXh0ZXJuYWxfam9iLlQgKGV4ZWN1dGlvbl9jb250ZXh0LCBmLCBhKSkgPVxuICAgICAgVGhyZWFkX3NhZmVfcXVldWUuZGVxdWV1ZV9leG4gZXh0ZXJuYWxfam9ic1xuICAgIGluXG4gICAgcnVuX2pvYiB0IHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIGFcbiAgZG9uZVxuOztcblxubGV0IHJ1bl9qb2JzICh0eXBlIGEpIHQgc2NoZWR1bGVyID1cbiAgKCogV2UgZG8gdGhlIFt0cnktd2l0aF0gb3V0c2lkZSBvZiB0aGUgW3doaWxlXSBiZWNhdXNlIGl0IGlzIGNoZWFwZXIgdGhhbiBkb2luZyBhXG4gICAgIFt0cnktd2l0aF0gZm9yIGVhY2ggam9iLiAqKVxuICAoKiBbcnVuX2V4dGVybmFsX2pvYnNdIGJlZm9yZSBlbnRlcmluZyB0aGUgbG9vcCwgc2luY2UgaXQgbWlnaHQgZW5xdWV1ZSBhIGpvYixcbiAgICAgY2hhbmdpbmcgW3QubGVuZ3RoXS4gKilcbiAgdHJ5XG4gICAgcnVuX2V4dGVybmFsX2pvYnMgdCBzY2hlZHVsZXI7XG4gICAgd2hpbGUgY2FuX3J1bl9hX2pvYiB0IGRvXG4gICAgICBsZXQgdGhpc19qb2IgPSBvZmZzZXQgdCAwIGluXG4gICAgICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50ID1cbiAgICAgICAgT2JqLm9iaiAoQS51bnNhZmVfZ2V0IHQuam9icyB0aGlzX2pvYilcbiAgICAgIGluXG4gICAgICBsZXQgZiA6IGEgLT4gdW5pdCA9IE9iai5vYmogKEEudW5zYWZlX2dldCB0LmpvYnMgKHRoaXNfam9iICsgMSkpIGluXG4gICAgICBsZXQgYSA6IGEgPSBPYmoub2JqIChBLnVuc2FmZV9nZXQgdC5qb2JzICh0aGlzX2pvYiArIDIpKSBpblxuICAgICAgKCogV2UgY2xlYXIgb3V0IHRoZSBqb2IgcmlnaHQgbm93IHNvIHRoYXQgaXQgaXNuJ3QgbGl2ZSBhdCB0aGUgbmV4dCBtaW5vclxuICAgICAgICAgY29sbGVjdGlvbi4gIFdlIHRyaWVkIG5vdCBkb2luZyB0aGlzIGFuZCBzYXcgc2lnbmlmaWNhbnQgKDE1JSBvciBzbykgcGVyZm9ybWFuY2VcbiAgICAgICAgIGhpdHMgZHVlIHRvIHNwdXJpb3VzIHByb21vdGlvbi4gKilcbiAgICAgIHNldCB0IDAgZHVtbXlfZSBkdW1teV9mIGR1bW15X2E7XG4gICAgICB0LmZyb250IDwtICh0LmZyb250ICsgMSkgbGFuZCB0Lm1hc2s7XG4gICAgICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDE7XG4gICAgICB0LmpvYnNfbGVmdF90aGlzX2N5Y2xlIDwtIHQuam9ic19sZWZ0X3RoaXNfY3ljbGUgLSAxO1xuICAgICAgKCogSXQgaXMgT0sgaWYgW3J1bl9qb2JdIG9yIFtydW5fZXh0ZXJuYWxfam9ic10gcmFpc2VzLCBpbiB3aGljaCBjYXNlIHRoZSBleG4gaXNcbiAgICAgICAgIGhhbmRsZWQgYnkgdGhlIG91dGVyIHRyeS13aXRoLiAgVGhlIG9ubHkgc2lkZSBlZmZlY3RzIHdlIGhhdmUgZG9uZSBhcmUgdG8gdGFrZVxuICAgICAgICAgdGhlIGpvYiBvdXQgb2YgdGhlIHF1ZXVlIGFuZCBkZWNyZW1lbnQgW2pvYnNfbGVmdF90aGlzX2N5Y2xlXS4gIFtydW5fam9iXSBvclxuICAgICAgICAgW3J1bl9leHRlcm5hbF9qb2JzXSBtYXkgc2lkZSBlZmZlY3QgW3RdLCBlaXRoZXIgYnkgZW5xdWV1ZWluZyBqb2JzLCBvciBieVxuICAgICAgICAgY2xlYXJpbmcgW3RdLiAqKVxuICAgICAgcnVuX2pvYiB0IHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIGE7XG4gICAgICAoKiBbcnVuX2V4dGVybmFsX2pvYnNdIGF0IGVhY2ggaXRlcmF0aW9uIG9mIHRoZSBbd2hpbGVdIGxvb3AsIGZvciBmYWlybmVzcy4gKilcbiAgICAgIHJ1bl9leHRlcm5hbF9qb2JzIHQgc2NoZWR1bGVyXG4gICAgZG9uZTtcbiAgICBPayAoKVxuICB3aXRoXG4gIHwgZXhuIC0+XG4gICAgKCogV2UgY2FsbCBbRXhuLmJhY2t0cmFjZV0gaW1tZWRpYXRlbHkgYWZ0ZXIgY2F0Y2hpbmcgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbiwgdG9cbiAgICAgICBlbnN1cmUgdGhlcmUgaXMgbm8gaW50ZXJ2ZW5pbmcgY29kZSB0aGF0IGludGVyZmVyZXMgd2l0aCB0aGUgZ2xvYmFsIGJhY2t0cmFjZVxuICAgICAgIHN0YXRlLiAqKVxuICAgIGxldCBiYWNrdHJhY2UgPSBCYWNrdHJhY2UuRXhuLm1vc3RfcmVjZW50ICgpIGluXG4gICAgRXJyb3IgKGV4biwgYmFja3RyYWNlKVxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVGltZV9ucyA9IHN0cnVjdFxuICBpbmNsdWRlIFRpbWVfbnNcblxuICBleHRlcm5hbCBmb3JtYXQgOiBmbG9hdCAtPiBzdHJpbmcgLT4gc3RyaW5nID0gXCJjb3JlX3RpbWVfbnNfZm9ybWF0XCJcblxuICAoKiBXZSB1c2UgYSBtb3JlIHBsZWFzYW50IGZvcm1hdCB0aGFuIFtDb3JlLlRpbWVfbnMuc2V4cF9vZl90XSxcbiAgICAgd2hpY2ggaGFzIHRvIGJlIG1lc3NpZXIgZm9yIHJvdW5kIHRyaXBwYWJpbGl0eS4gKilcbiAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICBbJXNleHBcbiAgICAgIChmb3JtYXQgKHQgfD4gdG9fc3Bhbl9zaW5jZV9lcG9jaCB8PiBTcGFuLnRvX3NlYykgXCIlWS0lbS0lZFQlSDolTTolUyV6XCIgOiBzdHJpbmcpXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBBbGFybSA9IHN0cnVjdFxuICBpbmNsdWRlIFRpbWluZ193aGVlbC5BbGFybVxuXG4gIGxldCBpc19udWxsIHQgPSBwaHlzX2VxdWFsIHQgKG51bGwgKCkpXG5lbmRcblxubW9kdWxlIEFsYXJtX3ByZWNpc2lvbiA9IFRpbWluZ193aGVlbC5BbGFybV9wcmVjaXNpb25cblxubGV0IGRlZmF1bHRfdGltaW5nX3doZWVsX2NvbmZpZyA9XG4gICgqIDEvOHRoIG9mIGEgbWlsbGlzZWNvbmQgYWxhcm1fcHJlY2lzaW9uIHNlZW1zIHN1ZmZpY2llbnQgdG8gYXZvaWQgaGF2aW5nIG1hbnkgYWxhcm1zXG4gICAgIGluIHRoZSBzYW1lIGludGVydmFsLCB3aGljaCBhdm9pZHMgcXVhZHJhdGljIGluc2VydGlvbiBzb3J0IHdoZW4gZmlyaW5nIGFsYXJtcy4gIEFuZFxuICAgICB0aGUgbGV2ZWwgYml0cyBnaXZlIHVzIGxldmVscyBvZiA+MXMsID4xbSwgPjFoLCA+MWQuICBTZWUgdGVzdCBpblxuICAgICBbLi4vdGVzdC90ZXN0X3N5bmNocm9ub3VzX3RpbWVfc291cmNlLm1sXS4gKilcbiAgVGltaW5nX3doZWVsLkNvbmZpZy5jcmVhdGVcbiAgICB+YWxhcm1fcHJlY2lzaW9uOkFsYXJtX3ByZWNpc2lvbi4oZGl2IGFib3V0X29uZV9taWxsaXNlY29uZCB+cG93MjozKVxuICAgIH5sZXZlbF9iaXRzOihUaW1pbmdfd2hlZWwuTGV2ZWxfYml0cy5jcmVhdGVfZXhuIFsgMTM7IDY7IDY7IDUgXSlcbiAgICAoKVxuOztcblxudHlwZSBjYWxsYmFjayA9IHVuaXQgLT4gdW5pdFxuXG5tb2R1bGUgSWQgPSBUeXBlcy5UaW1lX3NvdXJjZV9pZFxuXG5tb2R1bGUgVDEgPSBzdHJ1Y3RcbiAgbW9kdWxlIEV2ZW50ID0gc3RydWN0XG4gICAgbW9kdWxlIFN0YXR1cyA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gVHlwZXMuRXZlbnQuU3RhdHVzLnQgPVxuICAgICAgICB8IEZpcmVkICgqIGluIFtmaXJlZF9ldmVudHNdLCByZWFkeSB0byBydW4gKilcbiAgICAgICAgfCBIYXBwZW5pbmdfcGVyaW9kaWNfZXZlbnRcbiAgICAgICAgKCogY3VycmVudGx5IHJ1bm5pbmcgdGhlIGNhbGxiYWNrIChmb3IgYSBwZXJpb2RpYyBldmVudCkgKilcbiAgICAgICAgfCBTY2hlZHVsZWQgKCogaW4gdGhlIHRpbWluZyB3aGVlbCAqKVxuICAgICAgICB8IFVuc2NoZWR1bGVkICgqIG5vdCBpbiB0aW1pbmcgd2hlZWwgb3IgW2ZpcmVkX2V2ZW50c10gKilcbiAgICAgIFtAQGRlcml2aW5nIGNvbXBhcmUsIGVxdWFsLCBzZXhwX29mXVxuXG4gICAgICBsZXQgdHJhbnNpdGlvbl9pc19hbGxvd2VkIH5mcm9tIH50b18gPVxuICAgICAgICBtYXRjaCBmcm9tLCB0b18gd2l0aFxuICAgICAgICB8ICggRmlyZWRcbiAgICAgICAgICAsIEhhcHBlbmluZ19wZXJpb2RpY19ldmVudCAoKiBzdGFydGVkIHJ1bm5pbmcgY2FsbGJhY2sgKGZvciBhIHBlcmlvZGljIGV2ZW50KSAqKVxuICAgICAgICAgIClcbiAgICAgICAgfCAoIEZpcmVkXG4gICAgICAgICAgLCBVbnNjaGVkdWxlZFxuICAgICAgICAgICAgKCogYWJvcnRlZCwgb3Igc3RhcnRlZCBydW5uaW5nIGNhbGxiYWNrIChmb3IgYSBub24tcGVyaW9kaWMgZXZlbnQpICopIClcbiAgICAgICAgKCogW3Jlc2NoZWR1bGVfKl0gZ29lcyB0aHJvdWdoIGFuIGludGVybWVkaWF0ZSBbRmlyZWQsIFVuc2NoZWR1bGVkXSBzdGF0ZSxcbiAgICAgICAgICAgc28gd2UgbmV2ZXIgdHJhbnNpdGlvbiBmcm9tIFtGaXJlZF0gZGlyZWN0bHkgdG8gW1NjaGVkdWxlZF0uICopXG4gICAgICAgIHwgKCBIYXBwZW5pbmdfcGVyaW9kaWNfZXZlbnRcbiAgICAgICAgICAsIFNjaGVkdWxlZCAoKiBzY2hlZHVsZWQgbmV4dCBpdGVyYXRpb24gb2YgYSBwZXJpb2RpYyBldmVudCAqKSApXG4gICAgICAgIHwgSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50LCBVbnNjaGVkdWxlZCAoKiBhYm9ydGVkICopXG4gICAgICAgIHwgU2NoZWR1bGVkLCBGaXJlZCAoKiBtb3ZlZCBmcm9tIHRpbWluZyB3aGVlbCB0byBbZmlyZWRfZXZlbnRzXSAqKVxuICAgICAgICB8IFNjaGVkdWxlZCwgVW5zY2hlZHVsZWQgKCogYWJvcnRlZCAqKVxuICAgICAgICB8IFVuc2NoZWR1bGVkLCBGaXJlZCAoKiBldmVudCBzY2hlZHVsZWQgaW4gdGhlIHBhc3QgKilcbiAgICAgICAgfCBVbnNjaGVkdWxlZCwgU2NoZWR1bGVkICgqIGV2ZW50IHNjaGVkdWxlZCBpbiB0aGUgZnV0dXJlICopIC0+IHRydWVcbiAgICAgICAgfCAoRmlyZWQgfCBIYXBwZW5pbmdfcGVyaW9kaWNfZXZlbnQgfCBTY2hlZHVsZWQgfCBVbnNjaGVkdWxlZCksIF8gLT4gZmFsc2VcbiAgICAgIDs7XG4gICAgZW5kXG5cbiAgICB0eXBlIGV2ZW50ID0gVHlwZXMuRXZlbnQudFxuXG4gICAgbGV0IHNleHBfb2ZfZXZlbnRcbiAgICAgICh7IGFsYXJtID0gX1xuICAgICAgIDsgYXRcbiAgICAgICA7IGNhbGxiYWNrID0gX1xuICAgICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgPSBfXG4gICAgICAgOyBpbnRlcnZhbFxuICAgICAgIDsgbmV4dF9maXJlZCA9IF9cbiAgICAgICA7IHByZXZfZmlyZWQgPSBfXG4gICAgICAgOyBzdGF0dXNcbiAgICAgICB9IDpcbiAgICAgICAgZXZlbnQpXG4gICAgICA9XG4gICAgICBbJXNleHBcbiAgICAgICAgeyBzdGF0dXMgOiBTdGF0dXMudFxuICAgICAgICA7IGF0IDogVGltZV9ucy50XG4gICAgICAgIDsgaW50ZXJ2YWwgOiAoVGltZV9ucy5TcGFuLnQgb3B0aW9uW0BzZXhwLm9wdGlvbl0pXG4gICAgICAgIH1dXG4gICAgOztcblxuICAgIG1vZHVsZSBPcHRpb24gPSBzdHJ1Y3RcbiAgICAgICgqIFRoaXMgcmVkZWZpbml0aW9uIG9mIFtFdmVudF0gaXMgaGVyZSBzbyB0aGUgdHlwZSBjaGVja3MgYXJlIHJpZ2h0IG5leHRcbiAgICAgICAgIHRvIFtPYmoubWFnaWNdcy4gKilcbiAgICAgIG1vZHVsZSBFdmVudF9pc19ibG9jayA6IHNpZyBlbmQgPSBzdHJ1Y3RcbiAgICAgICAgb3BlbiBUeXBlc1xuICAgICAgICBvcGVuIEV2ZW50XG5cbiAgICAgICAgdHlwZSBfdCA9IHQgPVxuICAgICAgICAgIHsgKCogbXVzdCBuZXZlciBiZSBpbW1lZGlhdGUgKilcbiAgICAgICAgICAgIG11dGFibGUgYWxhcm0gOiBKb2Jfb3JfZXZlbnQudCBUaW1pbmdfd2hlZWwuQWxhcm0udFxuICAgICAgICAgIDsgbXV0YWJsZSBhdCA6IFRpbWVfbnMudFxuICAgICAgICAgIDsgY2FsbGJhY2sgOiB1bml0IC0+IHVuaXRcbiAgICAgICAgICA7IGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICAgICAgICAgIDsgbXV0YWJsZSBpbnRlcnZhbCA6IFRpbWVfbnMuU3Bhbi50IG9wdGlvblxuICAgICAgICAgIDsgbXV0YWJsZSBuZXh0X2ZpcmVkIDogT3B0aW9uLnRcbiAgICAgICAgICA7IG11dGFibGUgcHJldl9maXJlZCA6IE9wdGlvbi50XG4gICAgICAgICAgOyBtdXRhYmxlIHN0YXR1cyA6IFN0YXR1cy50XG4gICAgICAgICAgfVxuICAgICAgZW5kXG5cbiAgICAgIHR5cGUgdCA9IFR5cGVzLkV2ZW50Lk9wdGlvbi50XG5cbiAgICAgICgqIFVzaW5nIGFuIGltbWVkaWF0ZSByYXRoZXIgdGhhbiBhIHN0YXRpY2FsbHktYWxsb2NhdGVkIHJlY29yZCBoZXJlIHNlZW1zIHRvXG4gICAgICAgICBpbXByb3ZlIHBlcmZvcm1hbmNlIG5vdGljZWFibHkgKFsuLi9iZW5jaC9iaW4vYmVuY2hfdGltZV9zb3VyY2UuZXhlXSBiZW5jaG1hcmtcbiAgICAgICAgIGlzIGZhc3RlciBieSB+MTBucyBwZXIgYWxhcm0pLCBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgYXZvaWRzIHRoZSBleHBlbnNpdmVcbiAgICAgICAgIHBhcnRzIG9mIGNhbWxfbW9kaWZ5LiAqKVxuICAgICAgbGV0IG5vbmUgPSAoT2JqLm1hZ2ljIE5vbmUgOiB0KSAoKiBhbiBhcmJpdHJhcnkgaW1tZWRpYXRlICopXG4gICAgICBsZXQgc29tZSA9IChPYmoubWFnaWMgOiBUeXBlcy5FdmVudC50IC0+IHQpXG4gICAgICBsZXQgaXNfbm9uZSB0ID0gcGh5c19lcXVhbCB0IG5vbmVcbiAgICAgIGxldCBpc19zb21lIHQgPSBub3QgKGlzX25vbmUgdClcbiAgICAgIGxldCBmaXJzdF9zb21lIHQxIHQyID0gaWYgaXNfc29tZSB0MSB0aGVuIHQxIGVsc2UgdDJcbiAgICAgIGxldCB1bnNhZmVfdmFsdWUgPSAoT2JqLm1hZ2ljIDogdCAtPiBUeXBlcy5FdmVudC50KVxuXG4gICAgICBtb2R1bGUgT3B0aW9uYWxfc3ludGF4ID0gc3RydWN0XG4gICAgICAgIG1vZHVsZSBPcHRpb25hbF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgICAgICBsZXQgaXNfbm9uZSA9IGlzX25vbmVcbiAgICAgICAgICBsZXQgdW5zYWZlX3ZhbHVlID0gdW5zYWZlX3ZhbHVlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIG9wZW4gT3B0aW9uYWxfc3ludGF4XG5cbiAgICAgIGxldCBzZXhwX29mX3QgdCA9XG4gICAgICAgIG1hdGNoJW9wdGlvbmFsIHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gWyVzZXhwICgpXVxuICAgICAgICB8IFNvbWUgZXZlbnQgLT4gWyVzZXhwIChldmVudCA6IGV2ZW50KV1cbiAgICAgIDs7XG5cbiAgICAgIGxldCB2YWx1ZSB0IH5kZWZhdWx0ID0gQm9vbC5zZWxlY3QgKGlzX25vbmUgdCkgZGVmYXVsdCAodW5zYWZlX3ZhbHVlIHQpXG5cbiAgICAgIGxldCB2YWx1ZV9leG4gdCA9XG4gICAgICAgIG1hdGNoJW9wdGlvbmFsIHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gcmFpc2VfcyBbJXNleHAgXCJbU3luY2hyb25vdXNfdGltZV9zb3VyY2UuRXZlbnQuT3B0aW9uLnZhbHVlX2V4biBOb25lXVwiXVxuICAgICAgICB8IFNvbWUgZXZlbnQgLT4gZXZlbnRcbiAgICAgIDs7XG5cbiAgICAgIGxldCB0b19vcHRpb24gdCA9XG4gICAgICAgIG1hdGNoJW9wdGlvbmFsIHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgZXZlbnQgLT4gU29tZSBldmVudFxuICAgICAgOztcblxuICAgICAgbGV0IG9mX29wdGlvbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgTm9uZSAtPiBub25lXG4gICAgICAgIHwgU29tZSBldmVudCAtPiBzb21lIGV2ZW50XG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgdHlwZSB0ID0gVHlwZXMuRXZlbnQudCA9XG4gICAgICB7ICgqIFthbGFybV0gaXMgbm9uLW51bGwgaWZmIHRoZSBldmVudCBpcyBpbiB0aGUgdGltaW5nIHdoZWVsLiAqKVxuICAgICAgICBtdXRhYmxlIGFsYXJtIDogSm9iX29yX2V2ZW50LnQgQWxhcm0udFxuICAgICAgOyBtdXRhYmxlIGF0IDogVGltZV9ucy50XG4gICAgICA7IGNhbGxiYWNrIDogdW5pdCAtPiB1bml0XG4gICAgICA7IGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICAgICAgOyAoKiBbaW50ZXJ2YWxdIGlzIHRoZSBwZXJpb2QgZm9yIHRoZSBwZXJpb2RpYyBldmVudHMuICopXG4gICAgICAgIG11dGFibGUgaW50ZXJ2YWwgOiBUaW1lX25zLlNwYW4udCBvcHRpb25cbiAgICAgIDsgKCogW25leHRfZmlyZWRdIGFuZCBbcHJldl9maXJlZF0gY3JlYXRlIGEgZG91Ymx5LWxpbmtlZCAobm9uLWNpcmN1bGFyKSBsaXN0IG9mXG4gICAgICAgICAgIGZpcmVkIGV2ZW50cywgbGlua2VkIHZpYSB0aGVzZSBmaWVsZHMuIEFuIGV2ZW50IGlzIGFkZGVkIHRvIHRoZSBsaXN0IHdoZW5cbiAgICAgICAgICAgaXQgZmlyZXMsIGVpdGhlciBiZWNhdXNlIGl0IGlzIGFkZGVkIHdpdGggYSB0aW1lIGluIHRoZSBwYXN0LCBvclxuICAgICAgICAgICBiZWNhdXNlIHRpbWUgYWR2YW5jZXMuIFthZHZhbmNlX2J5X2FsYXJtc10gaXRlcmF0ZXMgb3ZlciB0aGUgZXZlbnRzXG4gICAgICAgICAgIGluIFtuZXh0X2ZpcmVkXSBhbmQgcnVucyB0aGVtLCBlbXB0eWluZyB0aGUgbGlzdC4gW25vbmVdIGlzIHVzZWQgdG9cbiAgICAgICAgICAgaW5kaWNhdGUgdGhlIGVuZCBvZiB0aGUgbGlua2VkIGxpc3Qgb2YgZmlyZWQgZXZlbnRzLiAqKVxuICAgICAgICBtdXRhYmxlIG5leHRfZmlyZWQgOiBPcHRpb24udFxuICAgICAgOyBtdXRhYmxlIHByZXZfZmlyZWQgOiBPcHRpb24udFxuICAgICAgOyBtdXRhYmxlIHN0YXR1cyA6IFN0YXR1cy50XG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzIH5pdGVyYXRvcnM6aXRlcl1cblxuICAgIGxldCBzZXhwX29mX3QgPSBbJXNleHBfb2Y6IGV2ZW50XVxuXG4gICAgbGV0IGludmFyaWFudCB0ID1cbiAgICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgICB+YWxhcm06XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBhbGFybSAtPlxuICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogYm9vbF1cbiAgICAgICAgICAgICAgICAgKEFsYXJtLmlzX251bGwgYWxhcm0pXG4gICAgICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAgICAgKG1hdGNoIHQuc3RhdHVzIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgfCBGaXJlZCB8IEhhcHBlbmluZ19wZXJpb2RpY19ldmVudCB8IFVuc2NoZWR1bGVkIC0+IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfCBTY2hlZHVsZWQgLT4gZmFsc2UpKSlcbiAgICAgICAgICB+YXQ6aWdub3JlXG4gICAgICAgICAgfmNhbGxiYWNrOmlnbm9yZVxuICAgICAgICAgIH5leGVjdXRpb25fY29udGV4dDppZ25vcmVcbiAgICAgICAgICB+aW50ZXJ2YWw6aWdub3JlXG4gICAgICAgICAgfm5leHRfZmlyZWQ6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBuZXh0X2ZpcmVkIC0+XG4gICAgICAgICAgICAgICBtYXRjaCVvcHRpb25hbCAobmV4dF9maXJlZCA6IE9wdGlvbi50KSB3aXRoXG4gICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgKCogW25leHRfZmlyZWRdIGNhbiBiZSBbTm9uZV0gZXZlbiBpZiB0aGUgZXZlbnQgc3RhdHVzIGlzIEZpcmVkLCBhc3N1bWluZ1xuICAgICAgICAgICAgICAgICAgICBpdCdzIGF0IHRoZSBlbmQgb2YgdGhlIGZpcmVkIGV2ZW50cyBsaXN0ICopXG4gICAgICAgICAgICAgICAgICgpXG4gICAgICAgICAgICAgICB8IFNvbWUgbmV4dF9maXJlZCAtPlxuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBTdGF0dXMudF0gdC5zdGF0dXMgfmV4cGVjdDpGaXJlZDtcbiAgICAgICAgICAgICAgICAgYXNzZXJ0IChwaHlzX2VxdWFsIChPcHRpb24uc29tZSB0KSBuZXh0X2ZpcmVkLnByZXZfZmlyZWQpKSlcbiAgICAgICAgICB+cHJldl9maXJlZDpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIHByZXZfZmlyZWQgLT5cbiAgICAgICAgICAgICAgIG1hdGNoJW9wdGlvbmFsIChwcmV2X2ZpcmVkIDogT3B0aW9uLnQpIHdpdGhcbiAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAoKiBbcHJldl9maXJlZF0gY2FuIGJlIFtOb25lXSBldmVuIGlmIHRoZSBldmVudCBzdGF0dXMgaXMgRmlyZWQsIGFzc3VtaW5nXG4gICAgICAgICAgICAgICAgICAgIGl0J3MgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlyZWQgZXZlbnRzIGxpc3QgKilcbiAgICAgICAgICAgICAgICAgKClcbiAgICAgICAgICAgICAgIHwgU29tZSBwcmV2X2ZpcmVkIC0+XG4gICAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IFN0YXR1cy50XSB0LnN0YXR1cyB+ZXhwZWN0OkZpcmVkO1xuICAgICAgICAgICAgICAgICBhc3NlcnQgKHBoeXNfZXF1YWwgKE9wdGlvbi5zb21lIHQpIHByZXZfZmlyZWQubmV4dF9maXJlZCkpKVxuICAgICAgICAgIH5zdGF0dXM6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biAoc3RhdHVzIDogU3RhdHVzLnQpIC0+XG4gICAgICAgICAgICAgICBtYXRjaCBzdGF0dXMgd2l0aFxuICAgICAgICAgICAgICAgfCBIYXBwZW5pbmdfcGVyaW9kaWNfZXZlbnQgLT4gYXNzZXJ0IChDb3JlLk9wdGlvbi5pc19zb21lIHQuaW50ZXJ2YWwpXG4gICAgICAgICAgICAgICB8IEZpcmVkIHwgVW5zY2hlZHVsZWQgfCBTY2hlZHVsZWQgLT4gKCkpKSlcbiAgICA7O1xuXG4gICAgbGV0IHNldF9zdGF0dXMgdCB0b18gPVxuICAgICAgbGV0IGZyb20gPSB0LnN0YXR1cyBpblxuICAgICAgaWYgbm90IChTdGF0dXMudHJhbnNpdGlvbl9pc19hbGxvd2VkIH5mcm9tIH50b18pXG4gICAgICB0aGVuXG4gICAgICAgIHJhaXNlX3NcbiAgICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICAgIFslaGVyZV1cbiAgICAgICAgICAgICAgXCJidWcgLS0gc2V0X3N0YXR1cyB0cmFuc2l0aW9uIG5vdCBhbGxvd2VkXCJcbiAgICAgICAgICAgICAgKGZyb20gOiBTdGF0dXMudClcbiAgICAgICAgICAgICAgKHRvXyA6IFN0YXR1cy50KVxuICAgICAgICAgICAgICB+ZXZlbnQ6KHQgOiB0KV07XG4gICAgICB0LnN0YXR1cyA8LSB0b19cbiAgICA7O1xuXG4gICAgbGV0IHNldF9zdGF0dXNfaWYgfmlzIHQgdG9fID0gaWYgU3RhdHVzLmVxdWFsIGlzIHQuc3RhdHVzIHRoZW4gc2V0X3N0YXR1cyB0IHRvX1xuICAgIGxldCBzY2hlZHVsZWRfYXQgPSBhdFxuICBlbmRcblxuICBtb2R1bGUgSm9iX29yX2V2ZW50ID0gc3RydWN0XG4gICAgaW5jbHVkZSBKb2Jfb3JfZXZlbnRcblxuICAgIGxldCBzZXhwX29mX3QgdCA9XG4gICAgICBsZXQgb3BlbiBKb2Jfb3JfZXZlbnQuTWF0Y2ggaW5cbiAgICAgIGxldCAoSyBrKSA9IGtpbmQgdCBpblxuICAgICAgbWF0Y2ggaywgcHJvamVjdCBrIHQgd2l0aFxuICAgICAgfCBFdmVudCwgZXZlbnQgLT4gWyVzZXhwIChldmVudCA6IEV2ZW50LnQpXVxuICAgICAgfCBKb2IsIF8gLT5cbiAgICAgICAgKCogV2UgZG9uJ3QgZGlzcGxheSB0aGUgW0pvYi50XXMgaW4gW2V2ZW50c10gYmVjYXVzZSB0aG9zZSBhcmVcbiAgICAgICAgICAgcG9vbCBwb2ludGVycywgd2hpY2ggYXJlIHVuaW5mb3JtYXRpdmUuICopXG4gICAgICAgIFslbWVzc2FnZSBcIjxKb2IudD5cIl1cbiAgICA7O1xuICBlbmRcblxuICB0eXBlIC0ncncgdCA9ICdydyBUeXBlcy5UaW1lX3NvdXJjZS50MSA9XG4gICAgeyBpZCA6IElkLnRcbiAgICA7ICgqIFthZHZhbmNlX2Vycm9yc10gYWNjdW11bGF0ZXMgZXJyb3JzIHJhaXNlZCBieSBhbGFybXMgcnVuIGJ5XG4gICAgICAgICBbYWR2YW5jZV9ieV9hbGFybXNdLiAqKVxuICAgICAgbXV0YWJsZSBhZHZhbmNlX2Vycm9ycyA6IEVycm9yLnQgbGlzdFxuICAgIDsgKCogW2FtX2FkdmFuY2luZ10gaXMgdHJ1ZSBvbmx5IGR1cmluZyBbYWR2YW5jZV9ieV9hbGFybXNdLCBhbmQgaXMgdXNlZCB0byBjYXVzZVxuICAgICAgICAgY2FsbGJhY2tzIHRvIHJhaXNlIGlmIHRoZXkgY2FsbCBbYWR2YW5jZV9ieV9hbGFybXNdLiAqKVxuICAgICAgbXV0YWJsZSBhbV9hZHZhbmNpbmcgOiBib29sXG4gICAgOyBldmVudHMgOiBKb2Jfb3JfZXZlbnQudCBUaW1pbmdfd2hlZWwudFxuICAgIDsgKCogW2ZpcmVkX2V2ZW50c10gaXMgdGhlIGZyb250IG9mIHRoZSBkb3VibHktbGlua2VkIGxpc3Qgb2YgZmlyZWQgZXZlbnRzLFxuICAgICAgICAgd2hpY2ggaXMgc3RvcmVkIGluIGluY3JlYXNpbmcgb3JkZXIgb2YgW0V2ZW50LmF0XS4gKilcbiAgICAgIG11dGFibGUgZmlyZWRfZXZlbnRzIDogRXZlbnQuT3B0aW9uLnRcbiAgICA7ICgqIFttb3N0X3JlY2VudGx5X2ZpcmVkXSBpcyB0aGUgZXZlbnQgdGhhdCB3YXMgbW9zdCByZWNlbnRseSBpbnNlcnRlZCBpbnRvXG4gICAgICAgICBbZmlyZWRfZXZlbnRzXS4gSXQgaXMgdXNlZCBhcyBhbiBvcHRpbWl6YXRpb24gdG8gYWxsb3cgaW5zZXJ0aW9uIG9mXG4gICAgICAgICBzdWJzZXF1ZW50IGV2ZW50cyB0byBzdGFydCBsYXRlciBpbiB0aGUgbGlzdCByYXRoZXIgdGhhbiBhdCB0aGUgYmVnaW5uaW5nLlxuICAgICAgICAgSXQgc3BlY2lmaWNhbGx5IGF2b2lkcyBxdWFkcmF0aWMgYmVoYXZpb3Igd2hlbiBpbnNlcnRpbmcgbXVsdGlwbGUgZXZlbnRzXG4gICAgICAgICB0aGF0IGhhdmUgZXhhY3RseSB0aGUgc2FtZSB0aW1lIC0tIHRoZSB0aW1lIHNvdXJjZSBmaXJlcyBzdWNoIGV2ZW50cyBpblxuICAgICAgICAgdGhlIG9yZGVyIHRoZXkgd2VyZSBhZGRlZCwgYW5kIHdlIHdhbnQgdGhlbSB0byBiZSBpbiB0aGF0IHNhbWUgb3JkZXIgaW5cbiAgICAgICAgIFtmaXJlZF9ldmVudHNdLiAqKVxuICAgICAgbXV0YWJsZSBtb3N0X3JlY2VudGx5X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnRcbiAgICA7ICgqIFdlIHN0b3JlIFtoYW5kbGVfZmlyZWRdIGluIFt0XSB0byBhdm9pZCBhbGxvY2F0aW5nIGl0IGV2ZXJ5IHRpbWUgd2UgY2FsbFxuICAgICAgICAgW2FkdmFuY2VfY2xvY2tdLiAqKVxuICAgICAgaGFuZGxlX2ZpcmVkIDogSm9iX29yX2V2ZW50LnQgQWxhcm0udCAtPiB1bml0XG4gICAgOyBpc193YWxsX2Nsb2NrIDogYm9vbFxuICAgIDsgc2NoZWR1bGVyIDogU2NoZWR1bGVyMC50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMgfml0ZXJhdG9yczppdGVyXVxuXG4gICgqIFdlIGRvbid0IGluY2x1ZGUgdGhlIFtpZF0gaW4gdGhlIHNleHAgYmVjYXVzZSB0aGUgdXNlciAocmlnaHRseSkgY2FuJ3QgY29udHJvbCBpdCwgc29cbiAgICAgaXQncyBoYXJkIHRvIG1ha2UgaXQgZGV0ZXJtaW5pc3RpYyBpbiB0ZXN0cy4gKilcbiAgbGV0IHNleHBfb2ZfdFxuICAgIF9cbiAgICB7IGlkID0gX1xuICAgIDsgYWR2YW5jZV9lcnJvcnMgPSBfXG4gICAgOyBhbV9hZHZhbmNpbmcgPSBfXG4gICAgOyBldmVudHNcbiAgICA7IGZpcmVkX2V2ZW50cyA9IF9cbiAgICA7IGhhbmRsZV9maXJlZCA9IF9cbiAgICA7IGlzX3dhbGxfY2xvY2tcbiAgICA7IG1vc3RfcmVjZW50bHlfZmlyZWQgPSBfXG4gICAgOyBzY2hlZHVsZXIgPSBfXG4gICAgfVxuICAgID1cbiAgICBsZXQgbm93ID0gVGltaW5nX3doZWVsLm5vdyBldmVudHMgaW5cbiAgICBpZiBpc193YWxsX2Nsb2NrXG4gICAgdGhlbiBbJW1lc3NhZ2UgXCJ3YWxsX2Nsb2NrXCIgKG5vdyA6IFRpbWVfbnMudCldXG4gICAgZWxzZSAoXG4gICAgICBsZXQgYWxsX2V2ZW50cyA9IHJlZiBbXSBpblxuICAgICAgVGltaW5nX3doZWVsLml0ZXIgZXZlbnRzIH5mOihmdW4gYWxhcm0gLT5cbiAgICAgICAgYWxsX2V2ZW50cyA6PSAoQWxhcm0uYXQgZXZlbnRzIGFsYXJtLCBBbGFybS52YWx1ZSBldmVudHMgYWxhcm0pIDo6ICFhbGxfZXZlbnRzKTtcbiAgICAgIGxldCBldmVudHMgPVxuICAgICAgICBMaXN0LnNvcnQgIWFsbF9ldmVudHMgfmNvbXBhcmU6KGZ1biAoYXQxLCBfKSAoYXQyLCBfKSAtPiBUaW1lX25zLmNvbXBhcmUgYXQxIGF0MilcbiAgICAgICAgfD4gTGlzdC5tYXAgfmY6c25kXG4gICAgICBpblxuICAgICAgWyVtZXNzYWdlIFwiXCIgKG5vdyA6IFRpbWVfbnMudCkgKGV2ZW50cyA6IEpvYl9vcl9ldmVudC50IGxpc3QpXSlcbiAgOztcblxuICBsZXQgdGltaW5nX3doZWVsX25vdyB0ID0gVGltaW5nX3doZWVsLm5vdyB0LmV2ZW50c1xuXG4gIGxldCBpc19pbl9maXJlZF9ldmVudHMgPVxuICAgIGxldCByZWMgc2VhcmNoIGN1cnJlbnQgfnRhcmdldF9ldmVudCA9XG4gICAgICBtYXRjaCVvcHRpb25hbCAoY3VycmVudCA6IEV2ZW50Lk9wdGlvbi50KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICAgIHwgU29tZSBjdXJyZW50IC0+XG4gICAgICAgIHBoeXNfZXF1YWwgY3VycmVudCB0YXJnZXRfZXZlbnQgfHwgc2VhcmNoIGN1cnJlbnQubmV4dF9maXJlZCB+dGFyZ2V0X2V2ZW50XG4gICAgaW5cbiAgICBmdW4gdCB0YXJnZXRfZXZlbnQgLT4gc2VhcmNoIHQuZmlyZWRfZXZlbnRzIH50YXJnZXRfZXZlbnRcbiAgOztcblxuICBsZXQgaW52YXJpYW50X3dpdGhfam9icyAodHlwZSBydykgfmpvYjooam9iX2ludmFyaWFudCA6IEpvYi50IC0+IHVuaXQpICh0IDogcncgdCkgPVxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5pZDppZ25vcmVcbiAgICAgICAgfmFkdmFuY2VfZXJyb3JzOmlnbm9yZVxuICAgICAgICB+YW1fYWR2YW5jaW5nOmlnbm9yZVxuICAgICAgICB+ZXZlbnRzOlxuICAgICAgICAgIChjaGVjayAoZnVuIGV2ZW50cyAtPlxuICAgICAgICAgICAgIFRpbWluZ193aGVlbC5pbnZhcmlhbnQgaWdub3JlIGV2ZW50cztcbiAgICAgICAgICAgICBUaW1pbmdfd2hlZWwuaXRlciBldmVudHMgfmY6KGZ1biBhbGFybSAtPlxuICAgICAgICAgICAgICAgbGV0IGpvYl9vcl9ldmVudCA9IEFsYXJtLnZhbHVlIGV2ZW50cyBhbGFybSBpblxuICAgICAgICAgICAgICAgbGV0IG9wZW4gSm9iX29yX2V2ZW50Lk1hdGNoIGluXG4gICAgICAgICAgICAgICBsZXQgKEsgaykgPSBraW5kIGpvYl9vcl9ldmVudCBpblxuICAgICAgICAgICAgICAgbWF0Y2ggaywgcHJvamVjdCBrIGpvYl9vcl9ldmVudCB3aXRoXG4gICAgICAgICAgICAgICB8IEpvYiwgam9iIC0+IGpvYl9pbnZhcmlhbnQgam9iXG4gICAgICAgICAgICAgICB8IEV2ZW50LCBldmVudCAtPlxuICAgICAgICAgICAgICAgICBhc3NlcnQgKHBoeXNfZXF1YWwgYWxhcm0gZXZlbnQuYWxhcm0pO1xuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBUaW1lX25zLnRdIGV2ZW50LmF0IH5leHBlY3Q6KEFsYXJtLmF0IGV2ZW50cyBhbGFybSk7XG4gICAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEV2ZW50LlN0YXR1cy50XSBldmVudC5zdGF0dXMgfmV4cGVjdDpTY2hlZHVsZWQ7XG4gICAgICAgICAgICAgICAgIEV2ZW50LmludmFyaWFudCBldmVudCkpKVxuICAgICAgICB+ZmlyZWRfZXZlbnRzOlxuICAgICAgICAgIChjaGVjayAoZnVuIChmaXJlZF9ldmVudHMgOiBFdmVudC5PcHRpb24udCkgLT5cbiAgICAgICAgICAgICBsZXQgcmVjIGNoZWNrX2V2ZW50IChjdXJyZW50IDogRXZlbnQudCkgPVxuICAgICAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPD0gKSBjdXJyZW50LmF0ICh0aW1pbmdfd2hlZWxfbm93IHQpKTtcbiAgICAgICAgICAgICAgIG1hdGNoJW9wdGlvbmFsLkV2ZW50Lk9wdGlvbiBjdXJyZW50Lm5leHRfZmlyZWQgd2l0aFxuICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgICAgICB8IFNvbWUgbmV4dCAtPlxuICAgICAgICAgICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA8PSApIGN1cnJlbnQuYXQgbmV4dC5hdCk7XG4gICAgICAgICAgICAgICAgIGNoZWNrX2V2ZW50IG5leHRcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIG1hdGNoJW9wdGlvbmFsLkV2ZW50Lk9wdGlvbiBmaXJlZF9ldmVudHMgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgICAgIHwgU29tZSBldmVudCAtPiBjaGVja19ldmVudCBldmVudCkpXG4gICAgICAgIH5oYW5kbGVfZmlyZWQ6aWdub3JlXG4gICAgICAgIH5pc193YWxsX2Nsb2NrOmlnbm9yZVxuICAgICAgICB+bW9zdF9yZWNlbnRseV9maXJlZDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBtb3N0X3JlY2VudGx5X2ZpcmVkIC0+XG4gICAgICAgICAgICAgbWF0Y2glb3B0aW9uYWwgKG1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgICAgIHwgU29tZSBldmVudCAtPiBhc3NlcnQgKGlzX2luX2ZpcmVkX2V2ZW50cyB0IGV2ZW50KSkpXG4gICAgICAgIH5zY2hlZHVsZXI6aWdub3JlKVxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnQgdCA9IGludmFyaWFudF93aXRoX2pvYnMgfmpvYjooZnVuIF8gLT4gKCkpIHRcbmVuZFxuXG5vcGVuIFQxXG5cbnR5cGUgdCA9IHJlYWQgVDEudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG5sZXQgaW52YXJpYW50X3dpdGhfam9icyA9IGludmFyaWFudF93aXRoX2pvYnNcblxubW9kdWxlIFJlYWRfd3JpdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gcmVhZF93cml0ZSBUMS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuICBsZXQgaW52YXJpYW50X3dpdGhfam9icyA9IGludmFyaWFudF93aXRoX2pvYnNcbmVuZFxuXG5sZXQgaWQgdCA9IHQuaWRcbmxldCBpc193YWxsX2Nsb2NrIHQgPSB0LmlzX3dhbGxfY2xvY2tcbmxldCBsZW5ndGggdCA9IFRpbWluZ193aGVlbC5sZW5ndGggdC5ldmVudHNcbmxldCBtYXhfYWxsb3dlZF9hbGFybV90aW1lIHQgPSBUaW1pbmdfd2hlZWwubWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0LmV2ZW50c1xubGV0IHJlYWRfb25seSAodCA6IFs+IHJlYWQgXSBUMS50KSA9ICh0IDo+IHQpXG5cbigqIFtmaXJlIHQgZXZlbnRdIHNldHMgW2V2ZW50LnN0YXR1cyA9IEZpcmVkXSBhbmQgaW5zZXJ0cyBbZXZlbnRdIGludG9cbiAgIFt0LmZpcmVkX2V2ZW50c10gaW4gc29ydGVkIHRpbWUgb3JkZXIuICopXG5sZXQgZmlyZSB0IChldmVudCA6IEV2ZW50LnQpID1cbiAgRXZlbnQuc2V0X3N0YXR1cyBldmVudCBGaXJlZDtcbiAgZXZlbnQuYWxhcm0gPC0gQWxhcm0ubnVsbCAoKTtcbiAgbGV0ICgpID1cbiAgICAoKiBJZiBbZXZlbnRdIGJlbG9uZ3MgYWZ0ZXIgW3QubW9zdF9yZWNlbnRseV9maXJlZF0sIHRoZW4gd2Ugc3RhcnQgdGhlXG4gICAgICAgaW5zZXJ0aW9uIHRoZXJlIHJhdGhlciB0aGFuIGF0IHRoZSBmcm9udCBvZiBbdC5maXJlZF9ldmVudHNdLiBUaGlzIHdvcmtzXG4gICAgICAgbmljZWx5IGlmIHdlJ3JlIGdldHRpbmcgdGhlIGFsYXJtcyBpbiBub24tZGVjcmVhc2luZyB0aW1lIG9yZGVyLCB3aGljaCBpc1xuICAgICAgIGNsb3NlIHRvIHdoYXQgW1RpbWluZ193aGVlbF0gcHJvdmlkZXMgKGFsdGhvdWdoIFtUaW1pbmdfd2hlZWxdIGRvZXNuJ3RcbiAgICAgICBndWFyYW50ZWUgdGltZSBvcmRlcmluZyBmb3IgdGltZXMgaW4gdGhlIHNhbWUgaW50ZXJ2YWwpLiAqKVxuICAgIG1hdGNoJW9wdGlvbmFsICh0Lm1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgU29tZSBtb3N0X3JlY2VudGx5X2ZpcmVkIHdoZW4gVGltZV9ucy4oIDw9ICkgbW9zdF9yZWNlbnRseV9maXJlZC5hdCBldmVudC5hdCAtPlxuICAgICAgZXZlbnQucHJldl9maXJlZCA8LSBFdmVudC5PcHRpb24uc29tZSBtb3N0X3JlY2VudGx5X2ZpcmVkO1xuICAgICAgZXZlbnQubmV4dF9maXJlZCA8LSBtb3N0X3JlY2VudGx5X2ZpcmVkLm5leHRfZmlyZWRcbiAgICB8IF8gLT5cbiAgICAgIGV2ZW50LnByZXZfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLm5vbmU7XG4gICAgICBldmVudC5uZXh0X2ZpcmVkIDwtIHQuZmlyZWRfZXZlbnRzXG4gIGluXG4gIHQubW9zdF9yZWNlbnRseV9maXJlZCA8LSBFdmVudC5PcHRpb24uc29tZSBldmVudDtcbiAgKCogV2UgdXNlIFtUaW1lX25zLiggPD0gKV0gcmF0aGVyIHRoYW4gWzxdIHNvIHRoYXQgW2V2ZW50XSBpcyBhZGRlZCBhZnRlciBvdGhlclxuICAgICBldmVudHMgYXQgdGhlIHNhbWUgdGltZS4gU2luY2UgW1RpbWluZ193aGVlbF0gZmlyZXMgYWxhcm1zIGluIGEgYnVja2V0IGluXG4gICAgIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQsIHVzaW5nIFs8PV0ga2VlcHMgZXZlbnRzIGF0IHRoZSBzYW1lXG4gICAgIHRpbWUgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZC4gKilcbiAgd2hpbGVcbiAgICBtYXRjaCVvcHRpb25hbCAoZXZlbnQubmV4dF9maXJlZCA6IEV2ZW50Lk9wdGlvbi50KSB3aXRoXG4gICAgfCBOb25lIC0+IGZhbHNlXG4gICAgfCBTb21lIG5leHQgLT5cbiAgICAgIGxldCBjb250aW51ZSA9IFRpbWVfbnMuKCA8PSApIG5leHQuYXQgZXZlbnQuYXQgaW5cbiAgICAgIGlmIGNvbnRpbnVlXG4gICAgICB0aGVuIChcbiAgICAgICAgZXZlbnQucHJldl9maXJlZCA8LSBldmVudC5uZXh0X2ZpcmVkO1xuICAgICAgICBldmVudC5uZXh0X2ZpcmVkIDwtIG5leHQubmV4dF9maXJlZCk7XG4gICAgICBjb250aW51ZVxuICBkb1xuICAgICgpXG4gIGRvbmU7XG4gIGxldCAoKSA9XG4gICAgbWF0Y2glb3B0aW9uYWwgKGV2ZW50Lm5leHRfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBuZXh0IC0+IG5leHQucHJldl9maXJlZCA8LSBFdmVudC5PcHRpb24uc29tZSBldmVudFxuICBpblxuICBtYXRjaCVvcHRpb25hbCAoZXZlbnQucHJldl9maXJlZCA6IEV2ZW50Lk9wdGlvbi50KSB3aXRoXG4gIHwgTm9uZSAtPiB0LmZpcmVkX2V2ZW50cyA8LSBFdmVudC5PcHRpb24uc29tZSBldmVudFxuICB8IFNvbWUgcHJldiAtPiBwcmV2Lm5leHRfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLnNvbWUgZXZlbnRcbjs7XG5cbmxldCBhbGFybV9wcmVjaXNpb24gdCA9IFRpbWluZ193aGVlbC5hbGFybV9wcmVjaXNpb24gdC5ldmVudHNcbmxldCBuZXh0X2FsYXJtX2ZpcmVzX2F0IHQgPSBUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdCB0LmV2ZW50c1xuXG5sZXQgbmV4dF9hbGFybV9ydW5zX2F0IHQgPVxuICBpZiBFdmVudC5PcHRpb24uaXNfc29tZSB0LmZpcmVkX2V2ZW50c1xuICB0aGVuIFNvbWUgKHRpbWluZ193aGVlbF9ub3cgdClcbiAgZWxzZSBUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdCB0LmV2ZW50c1xuOztcblxubGV0IG5vdyB0ID0gaWYgdC5pc193YWxsX2Nsb2NrIHRoZW4gVGltZV9ucy5ub3cgKCkgZWxzZSB0aW1pbmdfd2hlZWxfbm93IHRcbmxldCB0aW1pbmdfd2hlZWxfbm93ID0gdGltaW5nX3doZWVsX25vd1xuXG5sZXQgc2NoZWR1bGUgdCAoZXZlbnQgOiBFdmVudC50KSA9XG4gIEV2ZW50LnNldF9zdGF0dXMgZXZlbnQgU2NoZWR1bGVkO1xuICBldmVudC5hbGFybSA8LSBUaW1pbmdfd2hlZWwuYWRkIHQuZXZlbnRzIH5hdDpldmVudC5hdCAoZXZlbnQgfD4gSm9iX29yX2V2ZW50Lm9mX2V2ZW50KVxuOztcblxubGV0IHJlbW92ZV9mcm9tX2ZpcmVkIHQgKGV2ZW50IDogRXZlbnQudCkgfm5ld19zdGF0dXMgPVxuICBsZXQgKCkgPVxuICAgIG1hdGNoJW9wdGlvbmFsICh0Lm1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBtb3N0X3JlY2VudGx5X2ZpcmVkIC0+XG4gICAgICBpZiBwaHlzX2VxdWFsIGV2ZW50IG1vc3RfcmVjZW50bHlfZmlyZWRcbiAgICAgIHRoZW5cbiAgICAgICAgdC5tb3N0X3JlY2VudGx5X2ZpcmVkIDwtIEV2ZW50Lk9wdGlvbi5maXJzdF9zb21lIGV2ZW50Lm5leHRfZmlyZWQgZXZlbnQucHJldl9maXJlZFxuICBpblxuICBsZXQgKCkgPVxuICAgIG1hdGNoJW9wdGlvbmFsIChldmVudC5wcmV2X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IE5vbmUgLT4gdC5maXJlZF9ldmVudHMgPC0gZXZlbnQubmV4dF9maXJlZFxuICAgIHwgU29tZSBwcmV2IC0+IHByZXYubmV4dF9maXJlZCA8LSBldmVudC5uZXh0X2ZpcmVkXG4gIGluXG4gIGxldCAoKSA9XG4gICAgbWF0Y2glb3B0aW9uYWwgKGV2ZW50Lm5leHRfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBuZXh0IC0+IG5leHQucHJldl9maXJlZCA8LSBldmVudC5wcmV2X2ZpcmVkXG4gIGluXG4gIGV2ZW50Lm5leHRfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLm5vbmU7XG4gIGV2ZW50LnByZXZfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLm5vbmU7XG4gIEV2ZW50LnNldF9zdGF0dXMgZXZlbnQgbmV3X3N0YXR1c1xuOztcblxubW9kdWxlIEV2ZW50ID0gc3RydWN0XG4gIGluY2x1ZGUgRXZlbnRcblxuICBsZXQgY3JlYXRlX2ludGVybmFsIHQgfmF0IH5pbnRlcnZhbCB+Y2FsbGJhY2sgPVxuICAgIHsgYWxhcm0gPSBBbGFybS5udWxsICgpXG4gICAgOyBhdFxuICAgIDsgY2FsbGJhY2tcbiAgICA7IGV4ZWN1dGlvbl9jb250ZXh0ID0gdC5zY2hlZHVsZXIuY3VycmVudF9leGVjdXRpb25fY29udGV4dFxuICAgIDsgaW50ZXJ2YWxcbiAgICA7IG5leHRfZmlyZWQgPSBFdmVudC5PcHRpb24ubm9uZVxuICAgIDsgcHJldl9maXJlZCA9IEV2ZW50Lk9wdGlvbi5ub25lXG4gICAgOyBzdGF0dXMgPSBVbnNjaGVkdWxlZFxuICAgIH1cbiAgOztcblxuICBsZXQgYWRkIHQgZXZlbnQgPVxuICAgIGlmIFRpbWVfbnMuKCA8PSApIGV2ZW50LmF0ICh0aW1pbmdfd2hlZWxfbm93IHQpXG4gICAgdGhlbiBmaXJlIHQgZXZlbnRcbiAgICBlbHNlIHNjaGVkdWxlIHQgZXZlbnRcbiAgOztcblxuICBsZXQgY3JlYXRlX2FuZF9hZGQgdCB+YXQgfmludGVydmFsIH5jYWxsYmFjayA9XG4gICAgbGV0IGV2ZW50ID0gY3JlYXRlX2ludGVybmFsIHQgfmF0IH5pbnRlcnZhbCB+Y2FsbGJhY2sgaW5cbiAgICBhZGQgdCBldmVudDtcbiAgICBldmVudFxuICA7O1xuXG4gIGxldCBhdCB0IGF0IGNhbGxiYWNrID0gY3JlYXRlX2FuZF9hZGQgdCB+YXQgfmludGVydmFsOk5vbmUgfmNhbGxiYWNrXG5cbiAgbGV0IGFmdGVyIHQgc3BhbiBjYWxsYmFjayA9XG4gICAgY3JlYXRlX2FuZF9hZGQgdCB+YXQ6KFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSBzcGFuKSB+aW50ZXJ2YWw6Tm9uZSB+Y2FsbGJhY2tcbiAgOztcblxuICBsZXQgcmVxdWlyZV9zcGFuX2F0X2xlYXN0X2FsYXJtX3ByZWNpc2lvbiB0IHNwYW4gPVxuICAgIGxldCBhbGFybV9wcmVjaXNpb24gPSBhbGFybV9wcmVjaXNpb24gdCBpblxuICAgIGlmIFRpbWVfbnMuU3Bhbi4oIDwgKSBzcGFuIGFsYXJtX3ByZWNpc2lvblxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJpbnRlcnZhbCBzcGFuIHNtYWxsZXIgdGhhbiBhbGFybSBwcmVjaXNpb25cIlxuICAgICAgICAgICAgKHNwYW4gOiBUaW1lX25zLlNwYW4udClcbiAgICAgICAgICAgIChhbGFybV9wcmVjaXNpb24gOiBUaW1lX25zLlNwYW4udCldXG4gIDs7XG5cbiAgbGV0IGF0X2ludGVydmFscyA/c3RhcnQgdCBzcGFuIGNhbGxiYWNrID1cbiAgICBsZXQgYXQgPVxuICAgICAgbWF0Y2ggc3RhcnQgd2l0aFxuICAgICAgfCBOb25lIC0+IG5vdyB0XG4gICAgICB8IFNvbWUgYXQgLT4gYXRcbiAgICBpblxuICAgIHJlcXVpcmVfc3Bhbl9hdF9sZWFzdF9hbGFybV9wcmVjaXNpb24gdCBzcGFuO1xuICAgIGNyZWF0ZV9hbmRfYWRkIHQgfmF0IH5pbnRlcnZhbDooU29tZSBzcGFuKSB+Y2FsbGJhY2tcbiAgOztcblxuICBtb2R1bGUgQWJvcnRfcmVzdWx0ID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgT2tcbiAgICAgIHwgUHJldmlvdXNseV91bnNjaGVkdWxlZFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIGxldCBhYm9ydCB0IChldmVudCA6IHQpIDogQWJvcnRfcmVzdWx0LnQgPVxuICAgIG1hdGNoIGV2ZW50LnN0YXR1cyB3aXRoXG4gICAgfCBIYXBwZW5pbmdfcGVyaW9kaWNfZXZlbnQgLT5cbiAgICAgIChtYXRjaCBldmVudC5pbnRlcnZhbCB3aXRoXG4gICAgICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICAgICAgIHwgU29tZSAoXyA6IFRpbWVfbnMuU3Bhbi50KSAtPlxuICAgICAgICAgZXZlbnQuaW50ZXJ2YWwgPC0gTm9uZTtcbiAgICAgICAgIGV2ZW50LnN0YXR1cyA8LSBVbnNjaGVkdWxlZDtcbiAgICAgICAgIE9rKVxuICAgIHwgRmlyZWQgLT5cbiAgICAgIHJlbW92ZV9mcm9tX2ZpcmVkIHQgZXZlbnQgfm5ld19zdGF0dXM6VW5zY2hlZHVsZWQ7XG4gICAgICBPa1xuICAgIHwgU2NoZWR1bGVkIC0+XG4gICAgICBFdmVudC5zZXRfc3RhdHVzIGV2ZW50IFVuc2NoZWR1bGVkO1xuICAgICAgVGltaW5nX3doZWVsLnJlbW92ZSB0LmV2ZW50cyBldmVudC5hbGFybTtcbiAgICAgIGV2ZW50LmFsYXJtIDwtIEFsYXJtLm51bGwgKCk7XG4gICAgICBPa1xuICAgIHwgVW5zY2hlZHVsZWQgLT4gUHJldmlvdXNseV91bnNjaGVkdWxlZFxuICA7O1xuXG4gIGxldCBhYm9ydF9pZl9wb3NzaWJsZSB0IGV2ZW50ID0gaWdub3JlIChhYm9ydCB0IGV2ZW50IDogQWJvcnRfcmVzdWx0LnQpXG5cbiAgbGV0IGFib3J0X2V4biB0IGV2ZW50ID1cbiAgICBtYXRjaCBhYm9ydCB0IGV2ZW50IHdpdGhcbiAgICB8IE9rIC0+ICgpXG4gICAgfCByZWFzb24gLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJbU3luY2hyb25vdXNfdGltZV9zb3VyY2UuYWJvcnRfZXhuXSBjYW5ub3QgYWJvcnQgZXZlbnRcIlxuICAgICAgICAgICAgKHJlYXNvbiA6IEFib3J0X3Jlc3VsdC50KV1cbiAgOztcblxuICBsZXQgY3JlYXRlIHQgY2FsbGJhY2sgPSBjcmVhdGVfaW50ZXJuYWwgdCB+YXQ6VGltZV9ucy5lcG9jaCB+aW50ZXJ2YWw6Tm9uZSB+Y2FsbGJhY2tcblxuICBsZXQgaXNfc2NoZWR1bGVkIChldmVudCA6IHQpID1cbiAgICBtYXRjaCBldmVudC5zdGF0dXMgd2l0aFxuICAgIHwgSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50IHwgU2NoZWR1bGVkIHwgRmlyZWQgLT4gdHJ1ZVxuICAgIHwgVW5zY2hlZHVsZWQgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgc2NoZWR1bGVfYXRfaW50ZXJuYWwgdCAoZXZlbnQgOiB0KSBhdCB+aW50ZXJ2YWwgPVxuICAgIG1hdGNoIGV2ZW50LnN0YXR1cyB3aXRoXG4gICAgfCAoSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50IHwgU2NoZWR1bGVkIHwgRmlyZWQpIGFzIHN0YXR1cyAtPlxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICBbJXNleHAgXCJjYW5ub3Qgc2NoZWR1bGUgYW4gZXZlbnQgd2l0aCBzdGF0dXNcIiwgKHN0YXR1cyA6IEV2ZW50LlN0YXR1cy50KV1cbiAgICB8IFVuc2NoZWR1bGVkIC0+XG4gICAgICBldmVudC5hdCA8LSBhdDtcbiAgICAgIGV2ZW50LmludGVydmFsIDwtIGludGVydmFsO1xuICAgICAgYWRkIHQgZXZlbnQ7XG4gICAgICBPayAoKVxuICA7O1xuXG4gIGxldCBzY2hlZHVsZV9hdCB0IGV2ZW50IGF0ID0gc2NoZWR1bGVfYXRfaW50ZXJuYWwgdCBldmVudCBhdCB+aW50ZXJ2YWw6Tm9uZVxuICBsZXQgc2NoZWR1bGVfYWZ0ZXIgdCBldmVudCBzcGFuID0gc2NoZWR1bGVfYXQgdCBldmVudCAoVGltZV9ucy5hZnRlciAobm93IHQpIHNwYW4pXG5cbiAgbGV0IHNjaGVkdWxlX2F0X2ludGVydmFscycgdCBldmVudCBzcGFuIH5zdGFydGluZ19hdCA9XG4gICAgcmVxdWlyZV9zcGFuX2F0X2xlYXN0X2FsYXJtX3ByZWNpc2lvbiB0IHNwYW47XG4gICAgc2NoZWR1bGVfYXRfaW50ZXJuYWwgdCBldmVudCBzdGFydGluZ19hdCB+aW50ZXJ2YWw6KFNvbWUgc3BhbilcbiAgOztcblxuICBsZXQgc2NoZWR1bGVfYXRfaW50ZXJ2YWxzIHQgZXZlbnQgc3BhbiA9XG4gICAgc2NoZWR1bGVfYXRfaW50ZXJ2YWxzJyB0IGV2ZW50IHNwYW4gfnN0YXJ0aW5nX2F0Oihub3cgdClcbiAgOztcblxuICBsZXQgcmVzY2hlZHVsZV9hdCB0IGV2ZW50IGF0IDogdW5pdCA9XG4gICAgbWF0Y2ggZXZlbnQuc3RhdHVzIHdpdGhcbiAgICB8IEZpcmVkIC0+XG4gICAgICByZW1vdmVfZnJvbV9maXJlZCB0IGV2ZW50IH5uZXdfc3RhdHVzOlVuc2NoZWR1bGVkO1xuICAgICAgZXZlbnQuYXQgPC0gYXQ7XG4gICAgICBhZGQgdCBldmVudFxuICAgIHwgSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50IC0+XG4gICAgICAoKiBIYXBwZW5pbmdfcGVyaW9kaWNfZXZlbnQgZXZlbnRzIGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZnJvbSBbZmlyZWRdLiAqKVxuICAgICAgZXZlbnQuYXQgPC0gYXQ7XG4gICAgICBhZGQgdCBldmVudFxuICAgIHwgU2NoZWR1bGVkIC0+XG4gICAgICBldmVudC5hdCA8LSBhdDtcbiAgICAgIGlmIFRpbWVfbnMuKCA+ICkgYXQgKHRpbWluZ193aGVlbF9ub3cgdClcbiAgICAgIHRoZW4gVGltaW5nX3doZWVsLnJlc2NoZWR1bGUgdC5ldmVudHMgZXZlbnQuYWxhcm0gfmF0XG4gICAgICBlbHNlIChcbiAgICAgICAgVGltaW5nX3doZWVsLnJlbW92ZSB0LmV2ZW50cyBldmVudC5hbGFybTtcbiAgICAgICAgZmlyZSB0IGV2ZW50KVxuICAgIHwgVW5zY2hlZHVsZWQgLT5cbiAgICAgIGV2ZW50LmF0IDwtIGF0O1xuICAgICAgZXZlbnQuaW50ZXJ2YWwgPC0gTm9uZTtcbiAgICAgIGFkZCB0IGV2ZW50XG4gIDs7XG5cbiAgbGV0IHJlc2NoZWR1bGVfYWZ0ZXIgdCBldmVudCBzcGFuID0gcmVzY2hlZHVsZV9hdCB0IGV2ZW50IChUaW1lX25zLmFmdGVyIChub3cgdCkgc3BhbilcbmVuZFxuXG5sZXQgcnVuX2FmdGVyIHQgc3BhbiBjYWxsYmFjayA9IGlnbm9yZSAoRXZlbnQuYWZ0ZXIgdCBzcGFuIGNhbGxiYWNrIDogRXZlbnQudClcbmxldCBydW5fYXQgdCBhdCBjYWxsYmFjayA9IGlnbm9yZSAoRXZlbnQuYXQgdCBhdCBjYWxsYmFjayA6IEV2ZW50LnQpXG5cbmxldCBydW5fYXRfaW50ZXJ2YWxzID9zdGFydCB0IHNwYW4gY2FsbGJhY2sgPVxuICBpZ25vcmUgKEV2ZW50LmF0X2ludGVydmFscyA/c3RhcnQgdCBzcGFuIGNhbGxiYWNrIDogRXZlbnQudClcbjs7XG5cbnR5cGUgc2VuZF9leG4gPSBNb25pdG9yMC50IC0+ID9iYWNrdHJhY2U6WyBgR2V0IHwgYFRoaXMgb2YgQmFja3RyYWNlLnQgXSAtPiBleG4gLT4gdW5pdFxuXG5sZXQgcnVuX2ZpcmVkX2V2ZW50cyB0IH4oc2VuZF9leG4gOiBzZW5kX2V4biBvcHRpb24pID1cbiAgbGV0IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgPSB0LnNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IGluXG4gIHdoaWxlXG4gICAgbWF0Y2glb3B0aW9uYWwgKHQuZmlyZWRfZXZlbnRzIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICB8IFNvbWUgZXZlbnQgLT5cbiAgICAgIChtYXRjaCBldmVudC5zdGF0dXMgd2l0aFxuICAgICAgIHwgSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50IHwgU2NoZWR1bGVkIHwgVW5zY2hlZHVsZWQgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgfCBGaXJlZCAtPlxuICAgICAgICAgbGV0IG5ld19zdGF0dXMgPVxuICAgICAgICAgICBtYXRjaCBldmVudC5pbnRlcnZhbCB3aXRoXG4gICAgICAgICAgIHwgTm9uZSAtPiAoVW5zY2hlZHVsZWQgOiBFdmVudC5TdGF0dXMudClcbiAgICAgICAgICAgfCBTb21lIF8gLT4gKEhhcHBlbmluZ19wZXJpb2RpY19ldmVudCA6IEV2ZW50LlN0YXR1cy50KVxuICAgICAgICAgaW5cbiAgICAgICAgIHJlbW92ZV9mcm9tX2ZpcmVkIHQgZXZlbnQgfm5ld19zdGF0dXM7XG4gICAgICAgICAoKiBXZSBzZXQgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IHNvIHRoYXQgW2V2ZW50LmNhbGxiYWNrXSBydW5zIGluIHRoZSBzYW1lIGNvbnRleHRcbiAgICAgICAgICAgIHRoYXQgd2FzIGluIHBsYWNlIHdoZW4gW2V2ZW50XSB3YXMgY3JlYXRlZC4gKilcbiAgICAgICAgIFNjaGVkdWxlcjAuc2V0X2V4ZWN1dGlvbl9jb250ZXh0IHQuc2NoZWR1bGVyIGV2ZW50LmV4ZWN1dGlvbl9jb250ZXh0O1xuICAgICAgICAgKCogQW55IG1vZGlmaWNhdGlvbiBvZiBbc3RhdHVzXSBiZWxvdyBuZWVkcyB0byBmaXJzdCBjaGVjayB0aGF0IHRoZSBldmVudCBpc1xuICAgICAgICAgICAgc3RpbGwgW0hhcHBlbmluZ19wZXJpb2RpY19ldmVudF0uIElmIHRoZSBldmVudCBzdGF0dXMgaXMgbm90XG4gICAgICAgICAgICBbSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50XSB0aGVuIHRoZSBldmVudCdzIGNhbGxiYWNrIG11c3QgaGF2ZSByZXNjaGVkdWxlZCB0aGVcbiAgICAgICAgICAgIGV2ZW50LiBJbiB0aGF0IGNhc2UsIGRvIG5vdCBzZXQgdGhlIHN0YXR1cyBvciBhdHRlbXB0IHRvIHJlc2NoZWR1bGUgYVxuICAgICAgICAgICAgcmVwZWF0aW5nIGV2ZW50LlxuXG4gICAgICAgICAgICBUaGlzIGNvZGUgY291bGQgYmUgbXVjaCBzaW1wbGVyIGlmIHdlIGltbWVkaWF0ZWx5IHJlc2NoZWR1bGVkIHRoZSBldmVudCBiZWZvcmVcbiAgICAgICAgICAgIHJ1bm5pbmcgdGhlIGNhbGxiYWNrIChubyBuZWVkIGZvciB0aGUgSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50IHN0YXRlIHRoZW4pLlxuICAgICAgICAgICAgT25lIHJlYXNvbiB3ZSBkb24ndCBkbyB0aGF0IGlzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlc2NoZWR1bGVcbiAgICAgICAgICAgIGEgcGVyaW9kaWMgZXZlbnQgaWYgaXRzIGNhbGxiYWNrIHJhaXNlcy4gKilcbiAgICAgICAgIChtYXRjaCBldmVudC5jYWxsYmFjayAoKSB3aXRoXG4gICAgICAgICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICAgICAgICAobWF0Y2ggc2VuZF9leG4gd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiB0LmFkdmFuY2VfZXJyb3JzIDwtIEVycm9yLm9mX2V4biBleG4gOjogdC5hZHZhbmNlX2Vycm9yc1xuICAgICAgICAgICAgIHwgU29tZSBzZW5kX2V4biAtPlxuICAgICAgICAgICAgICAgbGV0IGJhY2t0cmFjZSA9IEJhY2t0cmFjZS5FeG4ubW9zdF9yZWNlbnQgKCkgaW5cbiAgICAgICAgICAgICAgIHNlbmRfZXhuIGV2ZW50LmV4ZWN1dGlvbl9jb250ZXh0Lm1vbml0b3IgZXhuIH5iYWNrdHJhY2U6KGBUaGlzIGJhY2t0cmFjZSkpO1xuICAgICAgICAgICAgRXZlbnQuc2V0X3N0YXR1c19pZiB+aXM6SGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50IGV2ZW50IFVuc2NoZWR1bGVkXG4gICAgICAgICAgfCAoKSAtPlxuICAgICAgICAgICAgKG1hdGNoIGV2ZW50LmludGVydmFsIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gRXZlbnQuc2V0X3N0YXR1c19pZiB+aXM6SGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50IGV2ZW50IFVuc2NoZWR1bGVkXG4gICAgICAgICAgICAgfCBTb21lIGludGVydmFsIC0+XG4gICAgICAgICAgICAgICBpZiBFdmVudC5TdGF0dXMuZXF1YWwgSGFwcGVuaW5nX3BlcmlvZGljX2V2ZW50IGV2ZW50LnN0YXR1c1xuICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgICgqIFRoZSBldmVudCdzIGNhbGxiYWNrIGRpZCBub3QgcmVzY2hlZHVsZSB0aGUgZXZlbnQuIFNvIHJlc2NoZWR1bGUgdGhlXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdGluZyB0aW1lciBiYXNlZCBvbiB0aGUgbGFzdCBbYXRdIHRpbWUuICopXG4gICAgICAgICAgICAgICAgIGV2ZW50LmF0XG4gICAgICAgICAgICAgICAgICAgPC0gVGltZV9ucy5uZXh0X211bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfmJhc2U6ZXZlbnQuYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIH5hZnRlcjoodGltaW5nX3doZWVsX25vdyB0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfmludGVydmFsO1xuICAgICAgICAgICAgICAgICBzY2hlZHVsZSB0IGV2ZW50KSkpO1xuICAgICAgICAgdHJ1ZSlcbiAgZG9cbiAgICAoKVxuICBkb25lO1xuICBTY2hlZHVsZXIwLnNldF9leGVjdXRpb25fY29udGV4dCB0LnNjaGVkdWxlciBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0XG47O1xuXG5sZXQgYW55X2ZpcmVkX2V2ZW50c190b19ydW4gdCA9IEV2ZW50Lk9wdGlvbi5pc19zb21lICh0LmZpcmVkX2V2ZW50cyA6IEV2ZW50Lk9wdGlvbi50KVxuXG5sZXQgYWR2YW5jZV9jbG9jayB0IH50b18gfnNlbmRfZXhuID1cbiAgVGltaW5nX3doZWVsLmFkdmFuY2VfY2xvY2sgdC5ldmVudHMgfnRvXyB+aGFuZGxlX2ZpcmVkOnQuaGFuZGxlX2ZpcmVkO1xuICBydW5fZmlyZWRfZXZlbnRzIHQgfnNlbmRfZXhuXG47O1xuXG5sZXQgYWR2YW5jZV9jbG9ja19zdG9wX2F0X25leHRfYWxhcm0gdCB+dG9fIH5zZW5kX2V4biA9XG4gIFRpbWluZ193aGVlbC5hZHZhbmNlX2Nsb2NrX3N0b3BfYXRfbmV4dF9hbGFybSB0LmV2ZW50cyB+dG9fIH5oYW5kbGVfZmlyZWQ6dC5oYW5kbGVfZmlyZWQ7XG4gIHJ1bl9maXJlZF9ldmVudHMgdCB+c2VuZF9leG5cbjs7XG5cbmxldCBmaXJlX3Bhc3RfYWxhcm1zIHQgfnNlbmRfZXhuID1cbiAgVGltaW5nX3doZWVsLmZpcmVfcGFzdF9hbGFybXMgdC5ldmVudHMgfmhhbmRsZV9maXJlZDp0LmhhbmRsZV9maXJlZDtcbiAgcnVuX2ZpcmVkX2V2ZW50cyB0IH5zZW5kX2V4blxuOztcblxubGV0IGFkdmFuY2VfaW50ZXJuYWwgdCB+dG9fIH5zZW5kX2V4biA9XG4gIGFkdmFuY2VfY2xvY2sgdCB+dG9fIH5zZW5kX2V4bjtcbiAgZmlyZV9wYXN0X2FsYXJtcyB0IH5zZW5kX2V4blxuOztcblxubGV0IGFkdmFuY2VfaW50ZXJuYWxfc3RvcF9hdF9uZXh0X2FsYXJtIHQgfnRvXyB+c2VuZF9leG4gPVxuICBhZHZhbmNlX2Nsb2NrX3N0b3BfYXRfbmV4dF9hbGFybSB0IH50b18gfnNlbmRfZXhuO1xuICBmaXJlX3Bhc3RfYWxhcm1zIHQgfnNlbmRfZXhuXG47O1xuXG5sZXQgcHJlcGFyZV90b19hZHZhbmNlIHQgfnNlbmRfZXhuID1cbiAgaWYgdC5hbV9hZHZhbmNpbmdcbiAgdGhlblxuICAgIHJhaXNlX3MgWyVzZXhwIFwiY2Fubm90IGNhbGwgW2FkdmFuY2VfYnlfYWxhcm1zXSBvciBbYWR2YW5jZV9kaXJlY3RseV0gZnJvbSBjYWxsYmFja1wiXTtcbiAgdC5hbV9hZHZhbmNpbmcgPC0gdHJ1ZTtcbiAgKG1hdGNoIHQuYWR2YW5jZV9lcnJvcnMgd2l0aFxuICAgfCBbXSAtPiAoKVxuICAgfCBfIC0+IHQuYWR2YW5jZV9lcnJvcnMgPC0gW10pO1xuICBydW5fZmlyZWRfZXZlbnRzIHQgfnNlbmRfZXhuXG47O1xuXG5sZXQgZmluaXNoX2FkdmFuY2luZyB0ID1cbiAgdC5hbV9hZHZhbmNpbmcgPC0gZmFsc2U7XG4gIG1hdGNoIHQuYWR2YW5jZV9lcnJvcnMgd2l0aFxuICB8IFtdIC0+IE9rICgpXG4gIHwgZXJyb3JzIC0+XG4gICAgdC5hZHZhbmNlX2Vycm9ycyA8LSBbXTtcbiAgICBFcnJvciAoRXJyb3Iub2ZfbGlzdCBlcnJvcnMpXG47O1xuXG5sZXQgYWR2YW5jZV9ieV9hbGFybXMgdCB+dG9fID1cbiAgbGV0IHNlbmRfZXhuID0gTm9uZSBpblxuICBwcmVwYXJlX3RvX2FkdmFuY2UgdCB+c2VuZF9leG47XG4gIHdoaWxlIFRpbWVfbnMuKCA8ICkgKFRpbWluZ193aGVlbC5ub3cgdC5ldmVudHMpIHRvXyBkb1xuICAgIGFkdmFuY2VfaW50ZXJuYWxfc3RvcF9hdF9uZXh0X2FsYXJtIHQgfnRvXyB+c2VuZF9leG5cbiAgZG9uZTtcbiAgZmluaXNoX2FkdmFuY2luZyB0XG47O1xuXG5sZXQgYWR2YW5jZV9ieV9hbGFybXNfYnkgdCBieSA9IGFkdmFuY2VfYnlfYWxhcm1zIHQgfnRvXzooVGltZV9ucy5hZnRlciAobm93IHQpIGJ5KVxuXG5sZXQgYWR2YW5jZV9ieV9tYXhfYWxhcm1zX2luX2VhY2hfdGltaW5nX3doZWVsX2ludGVydmFsIHQgfnRvXyA9XG4gIGxldCBzZW5kX2V4biA9IE5vbmUgaW5cbiAgcHJlcGFyZV90b19hZHZhbmNlIHQgfnNlbmRfZXhuO1xuICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhY29udGludWUgZG9cbiAgICBpZiBUaW1pbmdfd2hlZWwuaXNfZW1wdHkgdC5ldmVudHNcbiAgICB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlXG4gICAgZWxzZSAoXG4gICAgICBsZXQgbmV4dF9hbGFybV9maXJlc19hdCA9IFRpbWluZ193aGVlbC5uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biB0LmV2ZW50cyBpblxuICAgICAgaWYgVGltZV9ucy4oID49ICkgbmV4dF9hbGFybV9maXJlc19hdCB0b19cbiAgICAgIHRoZW4gY29udGludWUgOj0gZmFsc2VcbiAgICAgIGVsc2VcbiAgICAgICAgKCogV2UgdXNlIHRoZSBhY3R1YWwgYWxhcm0gdGltZSwgcmF0aGVyIHRoYW4gW25leHRfYWxhcm1fZmlyZXNfYXRdLCBzbyBhcyBub3QgdG9cbiAgICAgICAgICAgZXhwb3NlIChvciBhY2N1bXVsYXRlIGVycm9ycyBhc3NvY2lhdGVkIHdpdGgpIHRoZSBwcmVjaXNpb24gb2ZcbiAgICAgICAgICAgW1RpbWluZ193aGVlbF0uICopXG4gICAgICAgIGFkdmFuY2VfaW50ZXJuYWxcbiAgICAgICAgICB0XG4gICAgICAgICAgfnRvXzooVGltaW5nX3doZWVsLm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF9leG4gdC5ldmVudHMpXG4gICAgICAgICAgfnNlbmRfZXhuKVxuICBkb25lO1xuICBhZHZhbmNlX2ludGVybmFsIHQgfnRvXyB+c2VuZF9leG47XG4gIGZpbmlzaF9hZHZhbmNpbmcgdFxuOztcblxubGV0IGFkdmFuY2VfZGlyZWN0bHkgdCB+dG9fID1cbiAgbGV0IHNlbmRfZXhuID0gTm9uZSBpblxuICBwcmVwYXJlX3RvX2FkdmFuY2UgdCB+c2VuZF9leG47XG4gIGFkdmFuY2VfaW50ZXJuYWwgdCB+dG9fIH5zZW5kX2V4bjtcbiAgZmluaXNoX2FkdmFuY2luZyB0XG47O1xuXG5sZXQgYWR2YW5jZV9kaXJlY3RseV9ieSB0IGJ5ID0gYWR2YW5jZV9kaXJlY3RseSB0IH50b186KFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSBieSlcblxubGV0IGR1cmF0aW9uX29mIHQgZiA9XG4gIGxldCBzdGFydCA9IG5vdyB0IGluXG4gIGxldCByZXN1bHQgPSBmICgpIGluXG4gIGxldCBkdXJhdGlvbiA9IFRpbWVfbnMuZGlmZiAobm93IHQpIHN0YXJ0IGluXG4gIHJlc3VsdCwgZHVyYXRpb25cbjs7XG5cbmxldCBtYXhfYWxhcm1fdGltZV9pbl9taW5fdGltaW5nX3doZWVsX2ludGVydmFsIHQgPVxuICBUaW1pbmdfd2hlZWwubWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIHQuZXZlbnRzXG47O1xuXG5sZXQgaGFzX2V2ZW50c190b19ydW4gdCA9IEV2ZW50Lk9wdGlvbi5pc19zb21lIHQuZmlyZWRfZXZlbnRzXG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5pbmNsdWRlIFNjaGVkdWxlcjBcbm1vZHVsZSBTeW5jaHJvbm91c190aW1lX3NvdXJjZSA9IFN5bmNocm9ub3VzX3RpbWVfc291cmNlMFxubW9kdWxlIEV2ZW50ID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2UuRXZlbnRcbm1vZHVsZSBBbGFybSA9IFRpbWluZ193aGVlbC5BbGFybVxubW9kdWxlIEpvYl9vcl9ldmVudCA9IFN5bmNocm9ub3VzX3RpbWVfc291cmNlLlQxLkpvYl9vcl9ldmVudFxuXG5sZXQgZGVidWcgPSBEZWJ1Zy5zY2hlZHVsZXJcblxubW9kdWxlIEl2YXIgPSBzdHJ1Y3RcbiAgb3BlbiBUeXBlcy5JdmFyXG5cbiAgbGV0IGNyZWF0ZV93aXRoX2NlbGwgY2VsbCA9IHsgY2VsbCB9XG4gIGxldCBjcmVhdGUgKCkgPSBjcmVhdGVfd2l0aF9jZWxsIEVtcHR5XG5cbiAgbGV0IGNyZWF0ZV9mdWxsICh0eXBlIGEpIChhIDogYSkgPVxuICAgICgqIFdlIGFsbG9jYXRlIGFuIGltbXV0YWJsZSBpdmFyIGFuZCB0aGVuIGNhc3QgaXQgdG8gYSBtdXRhYmxlIGl2YXIuICBUaGUgaW1tdXRhYmlsaXR5XG4gICAgICAgYWxsb3dzIE9DYW1sIHRvIHN0YXRpY2FsbHkgYWxsb2NhdGUgdGhlIGl2YXIgaWYgW2FdIGlzIGNvbnN0YW50LiAgVGhpcyBjYXN0IGlzIHNhZmVcbiAgICAgICBiZWNhdXNlIGEgZnVsbCBpdmFyIGlzIG5ldmVyIG11dGF0ZWQuICBXZSBhbHNvIGJlbGlldmUgdGhhdCB3ZSB3aWxsIG5vdCB0cmlnZ2VyXG4gICAgICAgZmxhbWJkYSB0byBzcHVyaW91c2x5IHJlcG9yIHdhcm5pbmcgNTksIG11dGF0aW9uIG9mIGtub3duIGltbXV0YWJsZSBkYXRhLiAgQWxsXG4gICAgICAgbXV0YXRpb25zIG9mIGFuIGl2YXIgY2VsbCwgaS5lLiBbZm9vLmNlbGwgPC0gLi4uXSwgYXJlIGRpcmVjdGx5IHByZWNlZGVkIGJ5IGFcbiAgICAgICBbbWF0Y2ggZm9vLmNlbGxdIHRoYXQgcHJldmVudHMgdGhlIFtGdWxsXSBjYXNlIGZyb20gcmVhY2hpbmcgdGhlIG1vZGlmaWNhdGlvbi4gIFNvXG4gICAgICAgZmxhbWJkYSBzaG91bGQgYWx3YXlzIGVsaW1pbmF0ZSB0aGUgW2Zvby5jZWxsIDwtIC4uLl0gb2YgYSBjb25zdGFudCBbRnVsbF0gaXZhcixcbiAgICAgICBhbmQgbm90IHdhcm4uICopXG4gICAgKE9iai5tYWdpYyA6IGEgSW1tdXRhYmxlLnQgLT4gYSB0KSB7IGNlbGwgPSBGdWxsIGEgfVxuICA7O1xuZW5kXG5cbm1vZHVsZSBCdmFyID0gc3RydWN0XG4gIG9wZW4gVHlwZXMuQnZhclxuXG4gIGxldCBjcmVhdGUgKCkgPSBvZl9yZXByIHsgaGFzX2FueV93YWl0ZXJzID0gZmFsc2U7IGl2YXIgPSBJdmFyLmNyZWF0ZSAoKSB9XG5lbmRcblxubW9kdWxlIFZlcnlfbG93X3ByaW9yaXR5X3dvcmtlciA9IHN0cnVjdFxuICBtb2R1bGUgRXhlY19yZXN1bHQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBUeXBlcy5WZXJ5X2xvd19wcmlvcml0eV93b3JrZXIuRXhlY19yZXN1bHQudCA9XG4gICAgICB8IEZpbmlzaGVkXG4gICAgICB8IE5vdF9maW5pc2hlZFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIHR5cGUgdCA9IFR5cGVzLlZlcnlfbG93X3ByaW9yaXR5X3dvcmtlci50ID1cbiAgICB7IGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICAgIDsgZXhlYyA6IHVuaXQgLT4gRXhlY19yZXN1bHQudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IHQgPVxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICBGaWVsZHMuaXRlciB+ZXhlY3V0aW9uX2NvbnRleHQ6KGNoZWNrIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudCkgfmV4ZWM6aWdub3JlKVxuICA7O1xuZW5kXG5cbnR5cGUgdCA9IFNjaGVkdWxlcjAudCA9XG4gIHsgKCogW2NoZWNrX2FjY2Vzc10gb3B0aW9uYWxseSBob2xkcyBhIGZ1bmN0aW9uIHRvIHJ1biB0byBjaGVjayB3aGV0aGVyIGFjY2VzcyB0byBbdF0gaXNcbiAgICAgICBjdXJyZW50bHkgYWxsb3dlZC4gIEl0IGlzIHVzZWQgdG8gZGV0ZWN0IGludmFsaWQgYWNjZXNzIHRvIHRoZSBzY2hlZHVsZXIgZnJvbSBhXG4gICAgICAgdGhyZWFkLiAqKVxuICAgIG11dGFibGUgY2hlY2tfYWNjZXNzIDogKHVuaXQgLT4gdW5pdCkgb3B0aW9uXG4gIDsgbXV0YWJsZSBqb2JfcG9vbCA6IEpvYl9wb29sLnRcbiAgOyBub3JtYWxfcHJpb3JpdHlfam9icyA6IEpvYl9xdWV1ZS50XG4gIDsgbG93X3ByaW9yaXR5X2pvYnMgOiBKb2JfcXVldWUudFxuICA7IHZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMgOiBWZXJ5X2xvd19wcmlvcml0eV93b3JrZXIudCBEZXF1ZS50XG4gIDsgbXV0YWJsZSBtYWluX2V4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICA7IG11dGFibGUgY3VycmVudF9leGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgICgqIFRoZSBzY2hlZHVsZXIgY2FsbHMgW2dvdF91bmNhdWdodF9leG5dIHdoZW4gYW4gZXhjZXB0aW9uIGJ1YmJsZXMgdG8gdGhlIHRvcCBvZiB0aGVcbiAgICAgbW9uaXRvciB0cmVlIHdpdGhvdXQgYmVpbmcgaGFuZGxlZC4gIFRoaXMgZnVuY3Rpb24gZ3VhcmFudGVlcyB0byBuZXZlciBydW4gYW5vdGhlclxuICAgICBqb2IgYWZ0ZXIgdGhpcyBieSBjYWxsaW5nIFtjbGVhcl0gYW5kIGJlY2F1c2UgW2VucXVldWVfam9iXSB3aWxsIG5ldmVyIGFkZCBhbm90aGVyXG4gICAgIGpvYi4gKilcbiAgOyBtdXRhYmxlIHVuY2F1Z2h0X2V4biA6IChFeG4udCAqIFNleHAudCkgb3B0aW9uXG4gIDsgbXV0YWJsZSBjeWNsZV9jb3VudCA6IGludFxuICA7IG11dGFibGUgY3ljbGVfc3RhcnQgOiBUaW1lX25zLnRcbiAgOyBtdXRhYmxlIGluX2N5Y2xlIDogYm9vbFxuICA7IG11dGFibGUgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IDogKFR5cGVzLkN5Y2xlX2hvb2sudFtAc2V4cC5vcGFxdWVdKSBhcnJheVxuICA7IHJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZSA6XG4gICAgICAoVHlwZXMuQ3ljbGVfaG9va19oYW5kbGUudCwgKFR5cGVzLkN5Y2xlX2hvb2sudFtAc2V4cC5vcGFxdWVdKSkgSGFzaHRibC50XG4gIDsgbXV0YWJsZSBydW5fZXZlcnlfY3ljbGVfZW5kIDogKFR5cGVzLkN5Y2xlX2hvb2sudFtAc2V4cC5vcGFxdWVdKSBhcnJheVxuICA7IHJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUgOlxuICAgICAgKFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlLnQsIChUeXBlcy5DeWNsZV9ob29rLnRbQHNleHAub3BhcXVlXSkpIEhhc2h0YmwudFxuICA7IG11dGFibGUgbGFzdF9jeWNsZV90aW1lIDogVGltZV9ucy5TcGFuLnRcbiAgOyBtdXRhYmxlIGxhc3RfY3ljbGVfbnVtX2pvYnMgOiBpbnRcbiAgOyBtdXRhYmxlIHRvdGFsX2N5Y2xlX3RpbWUgOiBUaW1lX25zLlNwYW4udFxuICA7IG11dGFibGUgdGltZV9zb3VyY2UgOiByZWFkX3dyaXRlIFN5bmNocm9ub3VzX3RpbWVfc291cmNlLlQxLnRcbiAgICAgICgqIFtleHRlcm5hbF9qb2JzXSBpcyBhIHF1ZXVlIG9mIGFjdGlvbnMgc2VudCBmcm9tIG91dHNpZGUgb2YgYXN5bmMuICBUaGlzIGlzIGZvciB0aGVcbiAgICAgY2FzZSB3aGVyZSB3ZSB3YW50IHRvIHNjaGVkdWxlIGEgam9iIG9yIGZpbGwgYW4gaXZhciBmcm9tIGEgY29udGV4dCB3aGVyZSBpdCBpcyBub3RcbiAgICAgc2FmZSB0byBydW4gYXN5bmMgY29kZSwgYmVjYXVzZSB0aGUgYXN5bmMgbG9jayBpc24ndCBoZWxkLiAgRm9yIGluc3RhbmNlOiAtIGluIGFuXG4gICAgIE9DYW1sIGZpbmFsaXplciwgYXMgdGhleSBjYW4gcnVuIGF0IGFueSB0aW1lIGluIGFueSB0aHJlYWQuXG5cbiAgICAgVGhlIHdheSB0byBkbyBpdCBpcyB0byBxdWV1ZSBhIHRodW5rIGluIFtleHRlcm5hbF9qb2JzXSBhbmQgY2FsbFxuICAgICBbdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2tdLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3Igbm90aWZ5aW5nIHRoZSBzY2hlZHVsZXJcbiAgICAgdGhhdCBuZXcgYWN0aW9ucyBhcmUgYXZhaWxhYmxlLlxuXG4gICAgIFdoZW4gdXNpbmcgQXN5bmMgb24gdW5peCwgW3RocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rXSBpcyBzZXQgaW4gW0FzeW5jX3VuaXhdXG4gICAgIHRvIGNhbGwgW0ludGVycnVwdG9yLnRocmVhZF9zYWZlX2ludGVycnVwdF0sIHdoaWNoIHdpbGwgd2FrZSB1cCB0aGVcbiAgICAgW0FzeW5jX3VuaXhdIHNjaGVkdWxlciBhbmQgcnVuIGEgY3ljbGUuXG5cbiAgICAgTm90ZSB0aGF0IHRoaXMgaG9vayBtaWdodCBiZSB1c2VkIGluIG90aGVyIGNvbnRleHQgKGpzX29mX29jYW1sLCBtaXJhZ2UpLlxuXG4gICAgIFdoZW4gcnVubmluZyBhIGN5Y2xlLCB3ZSBwdWxsIGV4dGVybmFsIGFjdGlvbnMgYXQgZXZlcnkgam9iIGFuZCBwZXJmb3JtIHRoZW1cbiAgICAgaW1tZWRpYXRlbHkuICopXG4gIDsgZXh0ZXJuYWxfam9icyA6IEV4dGVybmFsX2pvYi50IFRocmVhZF9zYWZlX3F1ZXVlLnRcbiAgOyBtdXRhYmxlIHRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rIDogdW5pdCAtPiB1bml0XG4gICAgICAoKiBbam9iX3F1ZXVlZF9ob29rXSBhbmQgW2V2ZW50X2FkZGVkX2hvb2tdIGFpbSB0byBiZSB1c2VkIGJ5IGpzX29mX29jYW1sLiAqKVxuICAgICAgKCogV2UgdXNlIFtfIG9wdGlvbl0gaGVyZSBiZWNhdXNlIHRob3NlIGhvb2tzIHdpbGwgbm90IGJlIHNldCBpbiB0aGUgY29tbW9uIGNhc2VcbiAgICAgYW5kIHdlIHdhbnQgdG8gYXZvaWQgZXh0cmEgZnVuY3Rpb24gY2FsbHMuICopXG4gIDsgbXV0YWJsZSBqb2JfcXVldWVkX2hvb2sgOiAoUHJpb3JpdHkudCAtPiB1bml0KSBvcHRpb25cbiAgOyBtdXRhYmxlIGV2ZW50X2FkZGVkX2hvb2sgOiAoVGltZV9ucy50IC0+IHVuaXQpIG9wdGlvblxuICA7IG11dGFibGUgeWllbGQgOiAoKHVuaXQsIHJlYWRfd3JpdGUpIFR5cGVzLkJ2YXIudFtAc2V4cC5vcGFxdWVdKVxuICA7IG11dGFibGVcbiAgICAgIHlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluIDpcbiAgICAgICgodW5pdCwgcmVhZF93cml0ZSkgVHlwZXMuQnZhci50W0BzZXhwLm9wYXF1ZV0gKCogY29uZmlndXJhdGlvbiopKVxuICA7IG11dGFibGUgY2hlY2tfaW52YXJpYW50cyA6IGJvb2xcbiAgOyBtdXRhYmxlIG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlIDogTWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUudFxuICA7IG11dGFibGUgcmVjb3JkX2JhY2t0cmFjZXMgOiBib29sXG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbmxldCB1bmNhdWdodF9leG5fdW53cmFwcGVkID0gdW5jYXVnaHRfZXhuXG5cbmxldCB1bmNhdWdodF9leG4gdCA9XG4gIG1hdGNoIHQudW5jYXVnaHRfZXhuIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIChleG4sIHNleHApIC0+XG4gICAgU29tZSAoRXJyb3IuY3JlYXRlIFwidW5oYW5kbGVkIGV4Y2VwdGlvblwiIChleG4sIHNleHApIFslc2V4cF9vZjogRXhuLnQgKiBTZXhwLnRdKVxuOztcblxubGV0IG51bV9wZW5kaW5nX2pvYnMgdCA9XG4gIEpvYl9xdWV1ZS5sZW5ndGggdC5ub3JtYWxfcHJpb3JpdHlfam9icyArIEpvYl9xdWV1ZS5sZW5ndGggdC5sb3dfcHJpb3JpdHlfam9ic1xuOztcblxubGV0IG51bV9qb2JzX3J1biB0ID1cbiAgSm9iX3F1ZXVlLm51bV9qb2JzX3J1biB0Lm5vcm1hbF9wcmlvcml0eV9qb2JzXG4gICsgSm9iX3F1ZXVlLm51bV9qb2JzX3J1biB0Lmxvd19wcmlvcml0eV9qb2JzXG47O1xuXG5sZXQgbGFzdF9jeWNsZV9udW1fam9icyB0ID0gdC5sYXN0X2N5Y2xlX251bV9qb2JzXG5cbmxldCB1bm9yZGVyZWRfaXNfc3VibGlzdCB+ZXF1YWwgfnN1Ymxpc3Q6c21hbGwgbGFyZ2UgPVxuICBsZXQgbGFyZ2UgPSBBcnJheS50b19saXN0IGxhcmdlIGluXG4gIGxldCByZW1vdmUgYSB4ID1cbiAgICBtYXRjaCBMaXN0LnNwbGl0X3doaWxlIGEgfmY6KGZ1biB5IC0+IG5vdCAoZXF1YWwgeSB4KSkgd2l0aFxuICAgIHwgXywgW10gLT4gTm9uZVxuICAgIHwgbCwgXyA6OiByIC0+IFNvbWUgKGwgQCByKVxuICBpblxuICBPcHRpb24uaXNfc29tZVxuICAgIChMaXN0LmZvbGQgc21hbGwgfmluaXQ6KFNvbWUgbGFyZ2UpIH5mOihmdW4gYWNjIHggLT5cbiAgICAgICBPcHRpb24uYmluZCBhY2MgfmY6KGZ1biBsIC0+IHJlbW92ZSBsIHgpKSlcbjs7XG5cbmxldCBjaGVja19ob29rX3RhYmxlX2ludmFyaWFudCB0YWJsZSBhcnJheSA9XG4gICgqIFlvdSBjYW4gaW4gZmFjdCBoYXZlIGhvb2tzIGluIHRoZSBsaXN0IGZvciB3aGljaCB0aGVyZSBpcyBubyBjb3JyZXNwb25kaW5nIGVudHJ5IGluXG4gICAgIHRoZSB0YWJsZS4gU3VjaCBob29rcyBjYW4gbmV2ZXIgYmUgcmVtb3ZlZC4gKilcbiAgYXNzZXJ0ICh1bm9yZGVyZWRfaXNfc3VibGlzdCB+ZXF1YWw6cGh5c19lcXVhbCB+c3VibGlzdDooSGFzaHRibC5kYXRhIHRhYmxlKSBhcnJheSlcbjs7XG5cbmxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICB0cnlcbiAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+Y2hlY2tfYWNjZXNzOmlnbm9yZVxuICAgICAgfmpvYl9wb29sOihjaGVjayBKb2JfcG9vbC5pbnZhcmlhbnQpXG4gICAgICB+bm9ybWFsX3ByaW9yaXR5X2pvYnM6KGNoZWNrIEpvYl9xdWV1ZS5pbnZhcmlhbnQpXG4gICAgICB+bG93X3ByaW9yaXR5X2pvYnM6KGNoZWNrIEpvYl9xdWV1ZS5pbnZhcmlhbnQpXG4gICAgICB+dmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyczpcbiAgICAgICAgKGNoZWNrIChmdW4gcSAtPiBEZXF1ZS5pdGVyIHEgfmY6VmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyLmludmFyaWFudCkpXG4gICAgICB+bWFpbl9leGVjdXRpb25fY29udGV4dDooY2hlY2sgRXhlY3V0aW9uX2NvbnRleHQuaW52YXJpYW50KVxuICAgICAgfmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQ6KGNoZWNrIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudClcbiAgICAgIH51bmNhdWdodF9leG46XG4gICAgICAgIChjaGVjayAoZnVuIHVuY2F1Z2h0X2V4biAtPlxuICAgICAgICAgICBpZiBpc19zb21lIHVuY2F1Z2h0X2V4biB0aGVuIGFzc2VydCAobnVtX3BlbmRpbmdfam9icyB0ID0gMCkpKVxuICAgICAgfmN5Y2xlX2NvdW50OihjaGVjayAoZnVuIGN5Y2xlX2NvdW50IC0+IGFzc2VydCAoY3ljbGVfY291bnQgPj0gMCkpKVxuICAgICAgfmN5Y2xlX3N0YXJ0Omlnbm9yZVxuICAgICAgfmluX2N5Y2xlOmlnbm9yZVxuICAgICAgfnJ1bl9ldmVyeV9jeWNsZV9zdGFydDppZ25vcmVcbiAgICAgIH5ydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGU6XG4gICAgICAgIChjaGVjayAoZnVuIHJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZSAtPlxuICAgICAgICAgICBjaGVja19ob29rX3RhYmxlX2ludmFyaWFudCBydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgdC5ydW5fZXZlcnlfY3ljbGVfc3RhcnQpKVxuICAgICAgfnJ1bl9ldmVyeV9jeWNsZV9lbmQ6aWdub3JlXG4gICAgICB+cnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZTpcbiAgICAgICAgKGNoZWNrIChmdW4gcnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZSAtPlxuICAgICAgICAgICBjaGVja19ob29rX3RhYmxlX2ludmFyaWFudCBydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlIHQucnVuX2V2ZXJ5X2N5Y2xlX2VuZCkpXG4gICAgICB+bGFzdF9jeWNsZV90aW1lOmlnbm9yZVxuICAgICAgfnRvdGFsX2N5Y2xlX3RpbWU6aWdub3JlXG4gICAgICB+bGFzdF9jeWNsZV9udW1fam9iczpcbiAgICAgICAgKGNoZWNrIChmdW4gbGFzdF9jeWNsZV9udW1fam9icyAtPiBhc3NlcnQgKGxhc3RfY3ljbGVfbnVtX2pvYnMgPj0gMCkpKVxuICAgICAgfnRpbWVfc291cmNlOlxuICAgICAgICAoY2hlY2tcbiAgICAgICAgICAgKFN5bmNocm9ub3VzX3RpbWVfc291cmNlLlJlYWRfd3JpdGUuaW52YXJpYW50X3dpdGhfam9icyB+am9iOihmdW4gam9iIC0+XG4gICAgICAgICAgICAgIGFzc2VydCAoUG9vbC5wb2ludGVyX2lzX3ZhbGlkIHQuam9iX3Bvb2wgam9iKSkpKVxuICAgICAgfmV4dGVybmFsX2pvYnM6aWdub3JlXG4gICAgICB+dGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2s6aWdub3JlXG4gICAgICB+am9iX3F1ZXVlZF9ob29rOmlnbm9yZVxuICAgICAgfmV2ZW50X2FkZGVkX2hvb2s6aWdub3JlXG4gICAgICB+eWllbGQ6aWdub3JlXG4gICAgICB+eWllbGRfdW50aWxfbm9fam9ic19yZW1haW46aWdub3JlXG4gICAgICB+Y2hlY2tfaW52YXJpYW50czppZ25vcmVcbiAgICAgIH5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZTppZ25vcmVcbiAgICAgIH5yZWNvcmRfYmFja3RyYWNlczppZ25vcmVcbiAgd2l0aFxuICB8IGV4biAtPiByYWlzZV9zIFslbWVzc2FnZSBcIlNjaGVkdWxlci5pbnZhcmlhbnQgZmFpbGVkXCIgKGV4biA6IGV4bikgKHQgOiB0KV1cbjs7XG5cbmxldCBmcmVlX2pvYiB0IGpvYiA9IFBvb2wuZnJlZSB0LmpvYl9wb29sIGpvYlxuXG5sZXQgZW5xdWV1ZSB0IChleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnQpIGYgYSA9XG4gICgqIElmIHRoZXJlJ3MgYmVlbiBhbiB1bmNhdWdodCBleG4sIHdlIGRvbid0IGFkZCB0aGUgam9iLCBzaW5jZSB3ZSBkb24ndCB3YW50IGFueSBqb2JzXG4gICAgIHRvIHJ1biBvbmNlIHRoZXJlJ3MgYmVlbiBhbiB1bmNhdWdodCBleG4uICopXG4gIGlmIGlzX25vbmUgdC51bmNhdWdodF9leG5cbiAgdGhlbiAoXG4gICAgbGV0IHByaW9yaXR5ID0gZXhlY3V0aW9uX2NvbnRleHQucHJpb3JpdHkgaW5cbiAgICBsZXQgam9iX3F1ZXVlID1cbiAgICAgIG1hdGNoIHByaW9yaXR5IHdpdGhcbiAgICAgIHwgTm9ybWFsIC0+IHQubm9ybWFsX3ByaW9yaXR5X2pvYnNcbiAgICAgIHwgTG93IC0+IHQubG93X3ByaW9yaXR5X2pvYnNcbiAgICBpblxuICAgIEpvYl9xdWV1ZS5lbnF1ZXVlIGpvYl9xdWV1ZSBleGVjdXRpb25fY29udGV4dCBmIGE7XG4gICAgbWF0Y2ggdC5qb2JfcXVldWVkX2hvb2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBmIC0+IGYgcHJpb3JpdHkpXG47O1xuXG5sZXQgZW5xdWV1ZV9qb2IgdCBqb2IgfmZyZWVfam9iID1cbiAgbGV0IGpvYl9wb29sID0gdC5qb2JfcG9vbCBpblxuICBlbnF1ZXVlXG4gICAgdFxuICAgIChQb29sLmdldCBqb2JfcG9vbCBqb2IgUG9vbC5TbG90LnQwKVxuICAgIChQb29sLmdldCBqb2JfcG9vbCBqb2IgUG9vbC5TbG90LnQxKVxuICAgIChQb29sLmdldCBqb2JfcG9vbCBqb2IgUG9vbC5TbG90LnQyKTtcbiAgaWYgZnJlZV9qb2IgdGhlbiBQb29sLmZyZWUgdC5qb2JfcG9vbCBqb2Jcbjs7XG5cbmxldCBoYW5kbGVfZmlyZWQgKHRpbWVfc291cmNlIDogXyBTeW5jaHJvbm91c190aW1lX3NvdXJjZS5UMS50KSBqb2Jfb3JfZXZlbnQgPVxuICBsZXQgb3BlbiBKb2Jfb3JfZXZlbnQuTWF0Y2ggaW5cbiAgbGV0IChLIGspID0ga2luZCBqb2Jfb3JfZXZlbnQgaW5cbiAgbWF0Y2ggaywgcHJvamVjdCBrIGpvYl9vcl9ldmVudCB3aXRoXG4gIHwgSm9iLCBqb2IgLT4gZW5xdWV1ZV9qb2IgdGltZV9zb3VyY2Uuc2NoZWR1bGVyIGpvYiB+ZnJlZV9qb2I6dHJ1ZVxuICB8IEV2ZW50LCBldmVudCAtPiBTeW5jaHJvbm91c190aW1lX3NvdXJjZS5maXJlIHRpbWVfc291cmNlIGV2ZW50XG47O1xuXG5sZXQgY3JlYXRlICgpID1cbiAgbGV0IG5vdyA9IFRpbWVfbnMubm93ICgpIGluXG4gIGxldCByZWMgdCA9XG4gICAgeyBjaGVja19hY2Nlc3MgPSBOb25lXG4gICAgOyBqb2JfcG9vbCA9IEpvYl9wb29sLmNyZWF0ZSAoKVxuICAgIDsgbm9ybWFsX3ByaW9yaXR5X2pvYnMgPSBKb2JfcXVldWUuY3JlYXRlICgpXG4gICAgOyBsb3dfcHJpb3JpdHlfam9icyA9IEpvYl9xdWV1ZS5jcmVhdGUgKClcbiAgICA7IHZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMgPSBEZXF1ZS5jcmVhdGUgKClcbiAgICA7IG1haW5fZXhlY3V0aW9uX2NvbnRleHQgPSBFeGVjdXRpb25fY29udGV4dC5tYWluXG4gICAgOyBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ID0gRXhlY3V0aW9uX2NvbnRleHQubWFpblxuICAgIDsgdW5jYXVnaHRfZXhuID0gTm9uZVxuICAgIDsgY3ljbGVfc3RhcnQgPSBub3dcbiAgICA7IGN5Y2xlX2NvdW50ID0gMFxuICAgIDsgaW5fY3ljbGUgPSBmYWxzZVxuICAgIDsgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0ID0gW3x8XVxuICAgIDsgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlID0gSGFzaHRibC5jcmVhdGUgKG1vZHVsZSBUeXBlcy5DeWNsZV9ob29rX2hhbmRsZSlcbiAgICA7IHJ1bl9ldmVyeV9jeWNsZV9lbmQgPSBbfHxdXG4gICAgOyBydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlID0gSGFzaHRibC5jcmVhdGUgKG1vZHVsZSBUeXBlcy5DeWNsZV9ob29rX2hhbmRsZSlcbiAgICA7IGxhc3RfY3ljbGVfdGltZSA9IHNlYyAwLlxuICAgIDsgbGFzdF9jeWNsZV9udW1fam9icyA9IDBcbiAgICA7IHRvdGFsX2N5Y2xlX3RpbWUgPSBzZWMgMC5cbiAgICA7IHRpbWVfc291cmNlXG4gICAgOyBleHRlcm5hbF9qb2JzID0gVGhyZWFkX3NhZmVfcXVldWUuY3JlYXRlICgpXG4gICAgOyB0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayA9IGlnbm9yZVxuICAgIDsgam9iX3F1ZXVlZF9ob29rID0gTm9uZVxuICAgIDsgZXZlbnRfYWRkZWRfaG9vayA9IE5vbmVcbiAgICA7IHlpZWxkID0gQnZhci5jcmVhdGUgKClcbiAgICA7IHlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluID0gQnZhci5jcmVhdGUgKCkgKCogY29uZmlndXJhdGlvbiAqKVxuICAgIDsgY2hlY2tfaW52YXJpYW50cyA9IEFzeW5jX2tlcm5lbF9jb25maWcuY2hlY2tfaW52YXJpYW50c1xuICAgIDsgbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgPVxuICAgICAgICBBc3luY19rZXJuZWxfY29uZmlnLm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlXG4gICAgOyByZWNvcmRfYmFja3RyYWNlcyA9IEFzeW5jX2tlcm5lbF9jb25maWcucmVjb3JkX2JhY2t0cmFjZXNcbiAgICB9XG4gIGFuZCBldmVudHMgPVxuICAgIFRpbWluZ193aGVlbC5jcmVhdGUgfmNvbmZpZzpBc3luY19rZXJuZWxfY29uZmlnLnRpbWluZ193aGVlbF9jb25maWcgfnN0YXJ0Om5vd1xuICBhbmQgdGltZV9zb3VyY2UgOiBfIFN5bmNocm9ub3VzX3RpbWVfc291cmNlLlQxLnQgPVxuICAgIHsgaWQgPSBUeXBlcy5UaW1lX3NvdXJjZV9pZC5jcmVhdGUgKClcbiAgICA7IGFkdmFuY2VfZXJyb3JzID0gW11cbiAgICA7IGFtX2FkdmFuY2luZyA9IGZhbHNlXG4gICAgOyBldmVudHNcbiAgICA7IGhhbmRsZV9maXJlZCA9IChmdW4gYWxhcm0gLT4gaGFuZGxlX2ZpcmVkIHRpbWVfc291cmNlIChBbGFybS52YWx1ZSBldmVudHMgYWxhcm0pKVxuICAgIDsgZmlyZWRfZXZlbnRzID0gRXZlbnQuT3B0aW9uLm5vbmVcbiAgICA7IGlzX3dhbGxfY2xvY2sgPSB0cnVlXG4gICAgOyBtb3N0X3JlY2VudGx5X2ZpcmVkID0gRXZlbnQuT3B0aW9uLm5vbmVcbiAgICA7IHNjaGVkdWxlciA9IHRcbiAgICB9XG4gIGluXG4gIHRcbjs7XG5cbmxldCBpc19kZWFkIHQgPSBpc19zb21lIHQudW5jYXVnaHRfZXhuXG5sZXQgc2V0X2NoZWNrX2FjY2VzcyB0IGYgPSB0LmNoZWNrX2FjY2VzcyA8LSBmXG5cbmxldCBiYWNrdHJhY2Vfb2ZfZmlyc3Rfam9iIHQgPVxuICBPcHRpb24uZmlyc3Rfc29tZVxuICAgIChKb2JfcXVldWUuYmFja3RyYWNlX29mX2ZpcnN0X2VucXVldWUgdC5ub3JtYWxfcHJpb3JpdHlfam9icylcbiAgICAoSm9iX3F1ZXVlLmJhY2t0cmFjZV9vZl9maXJzdF9lbnF1ZXVlIHQubG93X3ByaW9yaXR5X2pvYnMpXG47O1xuXG5sZXQgdF9yZWYgPVxuICBtYXRjaCBSZXN1bHQudHJ5X3dpdGggY3JlYXRlIHdpdGhcbiAgfCBPayB0IC0+IHJlZiB0XG4gIHwgRXJyb3IgZXhuIC0+XG4gICAgRGVidWcubG9nIFwiQXN5bmMgY2Fubm90IGNyZWF0ZSBpdHMgcmF3IHNjaGVkdWxlclwiIGV4biBbJXNleHBfb2Y6IGV4bl07XG4gICAgZXhpdCAxXG47O1xuXG5sZXQgY2hlY2tfYWNjZXNzIHQgPVxuICBtYXRjaCB0LmNoZWNrX2FjY2VzcyB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgZiAtPiBmICgpXG47O1xuXG5sZXQgdCAoKSA9XG4gIGxldCB0ID0gIXRfcmVmIGluXG4gIGNoZWNrX2FjY2VzcyB0O1xuICB0XG47O1xuXG5sZXQgY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0ID1cbiAgaWYgdC5yZWNvcmRfYmFja3RyYWNlc1xuICB0aGVuIEV4ZWN1dGlvbl9jb250ZXh0LnJlY29yZF9iYWNrdHJhY2UgdC5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0XG4gIGVsc2UgdC5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0XG47O1xuXG5sZXQgd2l0aF9leGVjdXRpb25fY29udGV4dDEgdCB0bXBfY29udGV4dCB+ZiB4ID1cbiAgbGV0IG9sZF9jb250ZXh0ID0gY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0IGluXG4gIHNldF9leGVjdXRpb25fY29udGV4dCB0IHRtcF9jb250ZXh0O1xuICBwcm90ZWN0eCB+ZiB4IH5maW5hbGx5OihmdW4gXyAtPiBzZXRfZXhlY3V0aW9uX2NvbnRleHQgdCBvbGRfY29udGV4dClcbjs7XG5cbmxldCB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0IHQgdG1wX2NvbnRleHQgfmYgPSB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0MSB0IHRtcF9jb250ZXh0IH5mICgpXG5cbmxldCBjcmVhdGVfam9iICh0eXBlIGEpIHQgZXhlY3V0aW9uX2NvbnRleHQgZiBhID1cbiAgaWYgUG9vbC5pc19mdWxsIHQuam9iX3Bvb2wgdGhlbiB0LmpvYl9wb29sIDwtIFBvb2wuZ3JvdyB0LmpvYl9wb29sO1xuICBQb29sLm5ldzNcbiAgICB0LmpvYl9wb29sXG4gICAgZXhlY3V0aW9uX2NvbnRleHRcbiAgICAoT2JqLm1hZ2ljIChmIDogYSAtPiB1bml0KSA6IE9iai50IC0+IHVuaXQpXG4gICAgKE9iai5yZXByIChhIDogYSkpXG47O1xuXG5sZXQgZ290X3VuY2F1Z2h0X2V4biB0IGV4biBzZXhwID1cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJnb3RfdW5jYXVnaHRfZXhuXCIgKGV4biwgc2V4cCkgWyVzZXhwX29mOiBFeG4udCAqIFNleHAudF07XG4gIExpc3QuaXRlciBbIHQubm9ybWFsX3ByaW9yaXR5X2pvYnM7IHQubG93X3ByaW9yaXR5X2pvYnMgXSB+ZjpKb2JfcXVldWUuY2xlYXI7XG4gIHQudW5jYXVnaHRfZXhuIDwtIFNvbWUgKGV4biwgc2V4cClcbjs7XG5cbigqIFtzdGFydF9jeWNsZSB0IH5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5XSBlbmFibGVzIHN1YnNlcXVlbnQgY2FsbHMgb2YgW3J1bl9qb2JzXVxuICAgdG8gcnVuIHVwIHRvIFttYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5XSBqb2JzIG9mIGVhY2ggcHJpb3JpdHkgbGV2ZWwuICopXG5sZXQgc3RhcnRfY3ljbGUgdCB+bWF4X251bV9qb2JzX3Blcl9wcmlvcml0eSA9XG4gIGxldCBuID0gTWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUucmF3IG1heF9udW1fam9ic19wZXJfcHJpb3JpdHkgaW5cbiAgSm9iX3F1ZXVlLnNldF9qb2JzX2xlZnRfdGhpc19jeWNsZSB0Lm5vcm1hbF9wcmlvcml0eV9qb2JzIG47XG4gIEpvYl9xdWV1ZS5zZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUgdC5sb3dfcHJpb3JpdHlfam9icyBuXG47O1xuXG4oKiBbcnVuX2pvYnMgdF0gcmVtb3ZlcyBqb2JzIGZyb20gW3RdIG9uZSBhdCBhIHRpbWUgYW5kIHJ1bnMgdGhlbSwgc3RvcHBpbmcgYXMgc29vblxuICAgYXMgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbiBpcyByYWlzZWQsIG9yIHdoZW4gbm8gbW9yZSBqb2JzIGNhbiBiZSBydW4gYXQgYW55IHByaW9yaXR5LFxuICAgYXMgcGVyIFt+bWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV0uICopXG5sZXQgcmVjIHJ1bl9qb2JzIHQgPVxuICBtYXRjaCBKb2JfcXVldWUucnVuX2pvYnMgdC5ub3JtYWxfcHJpb3JpdHlfam9icyB0IHdpdGhcbiAgfCBFcnJvciBfIGFzIGUgLT4gZVxuICB8IE9rICgpIC0+XG4gICAgKG1hdGNoIEpvYl9xdWV1ZS5ydW5fam9icyB0Lmxvd19wcmlvcml0eV9qb2JzIHQgd2l0aFxuICAgICB8IEVycm9yIF8gYXMgZSAtPiBlXG4gICAgIHwgT2sgKCkgLT5cbiAgICAgICBpZiBKb2JfcXVldWUuY2FuX3J1bl9hX2pvYiB0Lm5vcm1hbF9wcmlvcml0eV9qb2JzXG4gICAgICAgICAgfHwgSm9iX3F1ZXVlLmNhbl9ydW5fYV9qb2IgdC5sb3dfcHJpb3JpdHlfam9ic1xuICAgICAgIHRoZW4gcnVuX2pvYnMgdFxuICAgICAgIGVsc2UgT2sgKCkpXG47O1xuXG5sZXQgc3RhYmlsaXplIHQgPVxuICBzdGFydF9jeWNsZVxuICAgIHRcbiAgICB+bWF4X251bV9qb2JzX3Blcl9wcmlvcml0eTpcbiAgICAgIChNYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZS5jcmVhdGVfZXhuIEludC5tYXhfdmFsdWUpO1xuICBtYXRjaCBydW5fam9icyB0IHdpdGhcbiAgfCBPayAoKSAtPiBPayAoKVxuICB8IEVycm9yIChleG4sIF9iYWNrdHJhY2UpIC0+IEVycm9yIGV4blxuOztcblxubGV0IGNyZWF0ZV90aW1lX3NvdXJjZVxuICA/KHRpbWluZ193aGVlbF9jb25maWcgPSBBc3luY19rZXJuZWxfY29uZmlnLnRpbWluZ193aGVlbF9jb25maWcpXG4gIH5ub3dcbiAgKClcbiAgPVxuICBsZXQgdCA9IHQgKCkgaW5cbiAgbGV0IGV2ZW50cyA9IFRpbWluZ193aGVlbC5jcmVhdGUgfmNvbmZpZzp0aW1pbmdfd2hlZWxfY29uZmlnIH5zdGFydDpub3cgaW5cbiAgbGV0IHJlYyB0aW1lX3NvdXJjZSA6IF8gU3luY2hyb25vdXNfdGltZV9zb3VyY2UuVDEudCA9XG4gICAgeyBpZCA9IFR5cGVzLlRpbWVfc291cmNlX2lkLmNyZWF0ZSAoKVxuICAgIDsgYWR2YW5jZV9lcnJvcnMgPSBbXVxuICAgIDsgYW1fYWR2YW5jaW5nID0gZmFsc2VcbiAgICA7IGV2ZW50c1xuICAgIDsgaGFuZGxlX2ZpcmVkID0gKGZ1biBhbGFybSAtPiBoYW5kbGVfZmlyZWQgdGltZV9zb3VyY2UgKEFsYXJtLnZhbHVlIGV2ZW50cyBhbGFybSkpXG4gICAgOyBmaXJlZF9ldmVudHMgPSBFdmVudC5PcHRpb24ubm9uZVxuICAgIDsgaXNfd2FsbF9jbG9jayA9IGZhbHNlXG4gICAgOyBtb3N0X3JlY2VudGx5X2ZpcmVkID0gRXZlbnQuT3B0aW9uLm5vbmVcbiAgICA7IHNjaGVkdWxlciA9IHRcbiAgICB9XG4gIGluXG4gIHRpbWVfc291cmNlXG47O1xuXG5sZXQgd2FsbF9jbG9jayAoKSA9IFN5bmNocm9ub3VzX3RpbWVfc291cmNlLnJlYWRfb25seSAodCAoKSkudGltZV9zb3VyY2VcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIFNjaGVkdWxlciA9IFNjaGVkdWxlcjFcbm1vZHVsZSBDZWxsID0gVHlwZXMuQ2VsbFxuXG50eXBlIGFueSA9XG4gIFsgYEVtcHR5XG4gIHwgYEVtcHR5X29uZV9oYW5kbGVyXG4gIHwgYEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzXG4gIHwgYEZ1bGxcbiAgfCBgSW5kaXJcbiAgXVxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5JdmFyLnQgPSB7IG11dGFibGUgY2VsbCA6ICgnYSwgYW55KSBjZWxsIH1cblxuKCogVGhlIFsnYl0gaXMgdXNlZCB0byBlbmNvZGUgdGhlIGNvbnN0cnVjdG9yLiAgVGhpcyBhbGxvd3MgdXMgdG8gd3JpdGUgZnVuY3Rpb25zIHRoYXRcbiAgIHRha2Ugb25seSBvbmUgb2YgdGhlIGNvbnN0cnVjdG9ycywgd2l0aCBubyBydW50aW1lIHRlc3QuXG5cbiAgIFdlIG1haW50YWluIHRoZSBpbnZhcmlhbnQgdGhhdCB0aGUgZGlyZWN0ZWQgZ3JhcGggd2l0aCBpdmFycyBhcyBub2RlcyBhbmQgW0luZGlyXXMgYXNcbiAgIGVkZ2VzIGlzIGFjeWNsaWMuICBUaGUgb25seSBmdW5jdGlvbnMgdGhhdCBjcmVhdGUgYW4gW0luZGlyXSBhcmUgW3NxdWFzaF0gYW5kXG4gICBbY29ubmVjdF0sIGFuZCBmb3IgdGhvc2UsIHRoZSB0YXJnZXQgb2YgdGhlIFtJbmRpcl0gaXMgYWx3YXlzIGEgbm9uLVtJbmRpcl0uICBUaHVzLCB0aGVcbiAgIG5ld2x5IGFkZGVkIGVkZ2VzIGFyZSBuZXZlciBwYXJ0IG9mIGEgY3ljbGUuICopXG5hbmQgKCdhLCAnYikgY2VsbCA9ICgnYSwgJ2IpIFR5cGVzLkNlbGwudCA9XG4gIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgOlxuICAgICAgeyAoKiBbcnVuXSBpcyBtdXRhYmxlIHNvIHdlIGNhbiBzZXQgaXQgdG8gW2lnbm9yZV0gd2hlbiB0aGUgaGFuZGxlciBpcyByZW1vdmVkLlxuICAgICAgICAgICBUaGlzIGlzIHVzZWQgd2hlbiB3ZSBpbnN0YWxsIGEgaGFuZGxlciBvbiBhIGZ1bGwgaXZhciBzaW5jZSBpdCBpcyBpbW1lZGlhdGVseVxuICAgICAgICAgICBhZGRlZCB0byB0aGUgc2NoZWR1bGVyLiAqKVxuICAgICAgICBtdXRhYmxlIHJ1biA6ICdhIC0+IHVuaXRcbiAgICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgICA7ICgqIFtwcmV2XSBhbmQgW25leHRdIGNpcmN1bGFybHkgZG91Ymx5IGxpbmsgYWxsIGhhbmRsZXJzIG9mIHRoZSBzYW1lIGl2YXIuICopXG4gICAgICAgIG11dGFibGUgcHJldiA6ICgnYSwgWyBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXSkgY2VsbFxuICAgICAgOyBtdXRhYmxlIG5leHQgOiAoJ2EsIFsgYEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF0pIGNlbGxcbiAgICAgIH1cbiAgICAgIC0+ICgnYSwgWz4gYEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF0pIGNlbGxcbiAgfCBFbXB0eV9vbmVfaGFuZGxlciA6XG4gICAgICAoJ2EgLT4gdW5pdCkgKiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgICAtPiAoJ2EsIFs+IGBFbXB0eV9vbmVfaGFuZGxlciBdKSBjZWxsXG4gIHwgRW1wdHkgOiAoJ2EsIFs+IGBFbXB0eSBdKSBjZWxsXG4gIHwgRnVsbCA6ICdhIC0+ICgnYSwgWz4gYEZ1bGwgXSkgY2VsbFxuICB8IEluZGlyIDogJ2EgdCAtPiAoJ2EsIFs+IGBJbmRpciBdKSBjZWxsXG5cbm1vZHVsZSBIYW5kbGVyID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICgnYSwgWyBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXSkgY2VsbFxuXG4gIGxldCBydW4gKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHQgOiBfIHQpID0gdC5ydW5cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB0IDogXyB0KSA9IHQuZXhlY3V0aW9uX2NvbnRleHRcbiAgbGV0IHByZXYgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHQgOiBfIHQpID0gdC5wcmV2XG4gIGxldCBuZXh0IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB0IDogXyB0KSA9IHQubmV4dFxuICBsZXQgc2V0X3J1biAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgdCA6IF8gdCkgeCA9IHQucnVuIDwtIHhcbiAgbGV0IHNldF9wcmV2IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB0IDogXyB0KSB4ID0gdC5wcmV2IDwtIHhcbiAgbGV0IHNldF9uZXh0IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB0IDogXyB0KSB4ID0gdC5uZXh0IDwtIHhcblxuICBsZXQgY3JlYXRlIHJ1biBleGVjdXRpb25fY29udGV4dCA9XG4gICAgKCogQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIG9mOlxuXG4gICAgICAge1tcbiAgICAgICAgIGxldCByZWMgdCA9XG4gICAgICAgICAgIEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzXG4gICAgICAgICAgICAgeyBydW5cbiAgICAgICAgICAgICA7IGV4ZWN1dGlvbl9jb250ZXh0XG4gICAgICAgICAgICAgOyBwcmV2ICAgICAgICAgICAgICA9IHRcbiAgICAgICAgICAgICA7IG5leHQgICAgICAgICAgICAgID0gdCB9XG4gICAgICAgICBpblxuICAgICAgICAgaDEgXX1cblxuICAgICAgIEhvd2V2ZXIgdGhlIGNvbXBpbGF0aW9uIG9mIHJlY3Vyc2l2ZSB2YWx1ZSBpbiBPQ2FtbCBpcyBub3Qgb3B0aW1hbDogdGhlIHZhbHVlIGlzXG4gICAgICAgYWxsb2NhdGVkIHR3aWNlIGFuZCBjb3BpZWQgb25jZSAod2l0aCBhIGxvb3AgY2FsbGluZyBjYW1sX21vZGlmeSkuICBUaGlzIGlzIG5vdFxuICAgICAgIG5lY2Vzc2FyeSBmb3Igc2ltcGxlIHJlY3Vyc2l2ZSBkZWZpbml0aW9ucyBsaWtlIHRoaXMgb25lLlxuXG4gICAgICAgSW5zdGVhZCB3ZSBhbGxvY2F0ZSB0aGUgdmFsdWUgd2l0aCBkdW1teSBmaWVsZHMgYW5kIHVwZGF0ZSB0aGVtIGFmdGVyLiAqKVxuICAgIGxldCB0ID1cbiAgICAgIEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzXG4gICAgICAgIHsgcnVuOyBleGVjdXRpb25fY29udGV4dDsgcHJldiA9IE9iai5tYWdpYyBOb25lOyBuZXh0ID0gT2JqLm1hZ2ljIE5vbmUgfVxuICAgIGluXG4gICAgc2V0X3ByZXYgdCB0O1xuICAgIHNldF9uZXh0IHQgdDtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGNyZWF0ZTIgcnVuMSBleGVjdXRpb25fY29udGV4dDEgcnVuMiBleGVjdXRpb25fY29udGV4dDIgPVxuICAgICgqIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBvZjpcblxuICAgICAgIHtbXG4gICAgICAgICBsZXQgcmVjIHQxID1cbiAgICAgICAgICAgeyBydW4gICAgICAgICAgICAgICA9IHJ1bjFcbiAgICAgICAgICAgOyBleGVjdXRpb25fY29udGV4dCA9IGV4ZWN1dGlvbl9jb250ZXh0MVxuICAgICAgICAgICA7IHByZXYgICAgICAgICAgICAgID0gdDJcbiAgICAgICAgICAgOyBuZXh0ICAgICAgICAgICAgICA9IHQyIH1cbiAgICAgICAgIGFuZCB0MiA9XG4gICAgICAgICAgIHsgcnVuICAgICAgICAgICAgICAgPSBydW4yXG4gICAgICAgICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgPSBleGVjdXRpb25fY29udGV4dDJcbiAgICAgICAgICAgOyBwcmV2ICAgICAgICAgICAgICA9IHQxXG4gICAgICAgICAgIDsgbmV4dCAgICAgICAgICAgICAgPSB0MSB9XG4gICAgICAgICBpblxuICAgICAgICAgdDEgXX0gKilcbiAgICBsZXQgdDEgPVxuICAgICAgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnNcbiAgICAgICAgeyBydW4gPSBydW4xXG4gICAgICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgPSBleGVjdXRpb25fY29udGV4dDFcbiAgICAgICAgOyBwcmV2ID0gT2JqLm1hZ2ljIE5vbmVcbiAgICAgICAgOyBuZXh0ID0gT2JqLm1hZ2ljIE5vbmVcbiAgICAgICAgfVxuICAgIGluXG4gICAgbGV0IHQyID1cbiAgICAgIEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzXG4gICAgICAgIHsgcnVuID0gcnVuMjsgZXhlY3V0aW9uX2NvbnRleHQgPSBleGVjdXRpb25fY29udGV4dDI7IHByZXYgPSB0MTsgbmV4dCA9IHQxIH1cbiAgICBpblxuICAgIHNldF9wcmV2IHQxIHQyO1xuICAgIHNldF9uZXh0IHQxIHQyO1xuICAgIHQxXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudCB0ID1cbiAgICBFeGVjdXRpb25fY29udGV4dC5pbnZhcmlhbnQgKGV4ZWN1dGlvbl9jb250ZXh0IHQpO1xuICAgIGxldCByID0gcmVmIChuZXh0IHQpIGluXG4gICAgd2hpbGUgbm90IChwaHlzX2VxdWFsICFyIHQpIGRvXG4gICAgICBsZXQgdDEgPSAhciBpblxuICAgICAgYXNzZXJ0IChwaHlzX2VxdWFsIChwcmV2IChuZXh0IHQxKSkgdDEpO1xuICAgICAgRXhlY3V0aW9uX2NvbnRleHQuaW52YXJpYW50IChleGVjdXRpb25fY29udGV4dCB0MSk7XG4gICAgICByIDo9IG5leHQgIXJcbiAgICBkb25lXG4gIDs7XG5cbiAgbGV0IGlzX3NpbmdsZXRvbiB0ID0gcGh5c19lcXVhbCB0IChuZXh0IHQpXG5cbiAgbGV0IGxlbmd0aCB0ID1cbiAgICBsZXQgbiA9IHJlZiAxIGluXG4gICAgbGV0IHIgPSByZWYgKG5leHQgdCkgaW5cbiAgICB3aGlsZSBub3QgKHBoeXNfZXF1YWwgIXIgdCkgZG9cbiAgICAgIGluY3IgbjtcbiAgICAgIHIgOj0gbmV4dCAhclxuICAgIGRvbmU7XG4gICAgIW5cbiAgOztcblxuICBsZXQgZW5xdWV1ZSB0IHNjaGVkdWxlciB2ID0gU2NoZWR1bGVyLmVucXVldWUgc2NoZWR1bGVyIChleGVjdXRpb25fY29udGV4dCB0KSAocnVuIHQpIHZcblxuICBsZXQgc2NoZWR1bGVfam9icyB0IHYgPVxuICAgIGxldCBzY2hlZHVsZXIgPSBTY2hlZHVsZXIudCAoKSBpblxuICAgIGVucXVldWUgdCBzY2hlZHVsZXIgdjtcbiAgICBsZXQgciA9IHJlZiAobmV4dCB0KSBpblxuICAgIHdoaWxlIG5vdCAocGh5c19lcXVhbCAhciB0KSBkb1xuICAgICAgZW5xdWV1ZSAhciBzY2hlZHVsZXIgdjtcbiAgICAgIHIgOj0gbmV4dCAhclxuICAgIGRvbmVcbiAgOztcblxuICBsZXQgdW5saW5rIHQgPVxuICAgIHNldF9wcmV2IChuZXh0IHQpIChwcmV2IHQpO1xuICAgIHNldF9uZXh0IChwcmV2IHQpIChuZXh0IHQpO1xuICAgIHNldF9wcmV2IHQgdDtcbiAgICBzZXRfbmV4dCB0IHRcbiAgOztcblxuICBsZXQgYWRkIHQgcnVuIGV4ZWN1dGlvbl9jb250ZXh0ID1cbiAgICBsZXQgcmVzdWx0ID1cbiAgICAgIEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHsgcnVuOyBleGVjdXRpb25fY29udGV4dDsgcHJldiA9IHByZXYgdDsgbmV4dCA9IHQgfVxuICAgIGluXG4gICAgc2V0X25leHQgKHByZXYgdCkgcmVzdWx0O1xuICAgIHNldF9wcmV2IHQgcmVzdWx0O1xuICAgIHJlc3VsdFxuICA7O1xuXG4gICgqIFtzcGxpY2UgdDEgdDJdIGNyZWF0ZXM6XG5cbiAgICAge3ZcbiAgICAgICAtLT4gdDEgPC0tPiAuLi4gPC0tPiBsYXN0MSA8LS0+IHQyIDwtLT4gLi4uIDwtLT4gbGFzdDIgPC0tXG4gICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgdn0gKilcbiAgbGV0IHNwbGljZSB0MSB0MiA9XG4gICAgbGV0IGxhc3QxID0gcHJldiB0MSBpblxuICAgIGxldCBsYXN0MiA9IHByZXYgdDIgaW5cbiAgICBzZXRfbmV4dCBsYXN0MSB0MjtcbiAgICBzZXRfbmV4dCBsYXN0MiB0MTtcbiAgICBzZXRfcHJldiB0MSBsYXN0MjtcbiAgICBzZXRfcHJldiB0MiBsYXN0MVxuICA7O1xuXG4gIGxldCBvZl9saXN0IGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgKHJ1biwgZXhlY3V0aW9uX2NvbnRleHQpIDo6IGwgLT5cbiAgICAgIGxldCBmaXJzdCA9IGNyZWF0ZSBydW4gZXhlY3V0aW9uX2NvbnRleHQgaW5cbiAgICAgIGxldCByZWMgbG9vcCBwcmV2IGwgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBbXSAtPiBzZXRfcHJldiBmaXJzdCBwcmV2XG4gICAgICAgIHwgKHJ1biwgZXhlY3V0aW9uX2NvbnRleHQpIDo6IGwgLT5cbiAgICAgICAgICBsZXQgdCA9XG4gICAgICAgICAgICBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB7IHJ1bjsgZXhlY3V0aW9uX2NvbnRleHQ7IHByZXY7IG5leHQgPSBmaXJzdCB9XG4gICAgICAgICAgaW5cbiAgICAgICAgICBzZXRfbmV4dCBwcmV2IHQ7XG4gICAgICAgICAgbG9vcCB0IGxcbiAgICAgIGluXG4gICAgICBsb29wIGZpcnN0IGw7XG4gICAgICBTb21lIGZpcnN0XG4gIDs7XG5cbiAgbGV0IHRvX2xpc3QgZmlyc3QgPVxuICAgIGxldCByZWMgbG9vcCB0IGFjYyA9XG4gICAgICBsZXQgYWNjID0gKHJ1biB0LCBleGVjdXRpb25fY29udGV4dCB0KSA6OiBhY2MgaW5cbiAgICAgIGlmIHBoeXNfZXF1YWwgdCBmaXJzdCB0aGVuIGFjYyBlbHNlIGxvb3AgKHByZXYgdCkgYWNjXG4gICAgaW5cbiAgICBsb29wIChwcmV2IGZpcnN0KSBbXVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgXyAodCA6IF8gdCkgPVxuICAgIGxldCAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgeyBydW4gPSBfOyBleGVjdXRpb25fY29udGV4dDsgbmV4dCA9IF87IHByZXYgPSBfIH0pID1cbiAgICAgIHRcbiAgICBpblxuICAgIFslbWVzc2FnZSAoZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50KV1cbiAgOztcbmVuZFxuXG50eXBlICdhIGl2YXIgPSAnYSB0XG5cbigqIENvbXBpbGVkIGFzIHRoZSBpZGVudGl0eS4gKilcbmxldCBjZWxsX29mX2hhbmRsZXIgOiBfIEhhbmRsZXIudCAtPiBfID0gZnVuY3Rpb25cbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIHggLT4gKHggOj4gKF8sIGFueSkgY2VsbClcbjs7XG5cbmxldCBlcXVhbCAodCA6IF8gdCkgdCcgPSBwaHlzX2VxdWFsIHQgdCdcbmxldCBpbmRpciB0ID0geyBjZWxsID0gSW5kaXIgdCB9XG5cbmluY2x1ZGUgU2NoZWR1bGVyLkl2YXJcblxuKCogW3NxdWFzaCB0XSByZXR1cm5zIHRoZSBub24tW0luZGlyXSBpdmFyIGF0IHRoZSBlbmQgb2YgdGhlIChwb3NzaWJseSBlbXB0eSkgY2hhaW4gb2ZcbiAgIFtJbmRpcl1zIHN0YXJ0aW5nIHdpdGggW3RdIGFuZCBlbnN1cmVzIHRoYXQgYWxsIFtJbmRpcl1zIGFsb25nIHRoYXQgY2hhaW4gYXJlIHJlcGxhY2VkXG4gICB3aXRoIGFuIFtJbmRpcl0gcG9pbnRpbmcgdG8gdGhlIGVuZCBvZiB0aGUgY2hhaW4uICopXG5sZXQgc3F1YXNoID1cbiAgbGV0IHJlYyBmb2xsb3cgaW5kaXIgdCA9XG4gICAgKCogW2luZGlyID0gSW5kaXIgdF0gKilcbiAgICBtYXRjaCB0LmNlbGwgd2l0aFxuICAgIHwgSW5kaXIgdCcgYXMgaW5kaXInIC0+IGZvbGxvdyBpbmRpcicgdCdcbiAgICB8IF8gLT4gaW5kaXJcbiAgaW5cbiAgbGV0IHJlYyB1cGRhdGUgdCBpbmRpciA9XG4gICAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgICB8IEluZGlyIHQnIC0+XG4gICAgICB0LmNlbGwgPC0gaW5kaXI7XG4gICAgICB1cGRhdGUgdCcgaW5kaXJcbiAgICB8IF8gLT4gdFxuICBpblxuICBmdW4gdCAtPlxuICAgIG1hdGNoIHQuY2VsbCB3aXRoXG4gICAgfCBJbmRpciB0JyAtPlxuICAgICAgKG1hdGNoIHQnLmNlbGwgd2l0aFxuICAgICAgIHwgSW5kaXIgdCcnIGFzIGluZGlyIC0+IHVwZGF0ZSB0IChmb2xsb3cgaW5kaXIgdCcnKVxuICAgICAgIHwgXyAtPiB0JyAoKiBub3RoaW5nIHRvIGRvLCBzaW5jZSBbdF0gaXMgYSBjaGFpbiB3aXRoIGEgc2luZ2xlIFtJbmRpcl0gKikpXG4gICAgfCBfIC0+IHRcbjs7XG5cbigqIG5vdGhpbmcgdG8gZG8sIHNpbmNlIFt0XSBpc24ndCBhbiBbSW5kaXJdLiAqKVxuXG5sZXQgaW52YXJpYW50IGFfaW52YXJpYW50IHQgPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCBhIC0+IGFfaW52YXJpYW50IGFcbiAgfCBFbXB0eSAtPiAoKVxuICB8IEVtcHR5X29uZV9oYW5kbGVyIChfLCBleGVjdXRpb25fY29udGV4dCkgLT5cbiAgICBFeGVjdXRpb25fY29udGV4dC5pbnZhcmlhbnQgZXhlY3V0aW9uX2NvbnRleHRcbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIgLT4gSGFuZGxlci5pbnZhcmlhbnQgaGFuZGxlclxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA6IFNleHAudCA9XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBGdWxsIGEgLT4gTGlzdCBbIEF0b20gXCJGdWxsXCI7IHNleHBfb2ZfYSBhIF1cbiAgfCBFbXB0eSB8IEVtcHR5X29uZV9oYW5kbGVyIF8gfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIC0+IEF0b20gXCJFbXB0eVwiXG47O1xuXG5sZXQgcGVlayB0ID1cbiAgbGV0IHQgPSBzcXVhc2ggdCBpblxuICBtYXRjaCB0LmNlbGwgd2l0aFxuICB8IEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSAqKVxuICB8IEZ1bGwgYSAtPiBTb21lIGFcbiAgfCBFbXB0eSB8IEVtcHR5X29uZV9oYW5kbGVyIF8gfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIC0+IE5vbmVcbjs7XG5cbmxldCB2YWx1ZSB0IH5pZl9lbXB0eV90aGVuX2ZhaWx3aXRoID1cbiAgbGV0IHQgPSBzcXVhc2ggdCBpblxuICBtYXRjaCB0LmNlbGwgd2l0aFxuICB8IEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSAqKVxuICB8IEZ1bGwgYSAtPiBhXG4gIHwgRW1wdHkgfCBFbXB0eV9vbmVfaGFuZGxlciBfIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyAtPlxuICAgIGZhaWx3aXRoIGlmX2VtcHR5X3RoZW5fZmFpbHdpdGhcbjs7XG5cbmxldCB2YWx1ZV9leG4gdCA9IHZhbHVlIHQgfmlmX2VtcHR5X3RoZW5fZmFpbHdpdGg6XCJJdmFyLnZhbHVlX2V4biBjYWxsZWQgb24gZW1wdHkgaXZhclwiXG5cbmxldCBpc19lbXB0eSB0ID1cbiAgbGV0IHQgPSBzcXVhc2ggdCBpblxuICBtYXRjaCB0LmNlbGwgd2l0aFxuICB8IEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSAqKVxuICB8IEZ1bGwgXyAtPiBmYWxzZVxuICB8IEVtcHR5IHwgRW1wdHlfb25lX2hhbmRsZXIgXyB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gLT4gdHJ1ZVxuOztcblxubGV0IGlzX2Z1bGwgdCA9IG5vdCAoaXNfZW1wdHkgdClcblxubGV0IGZpbGxfZXhuIHQgdiA9XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBGdWxsIF8gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJJdmFyLmZpbGxfZXhuIGNhbGxlZCBvbiBmdWxsIGl2YXJcIiAodCA6IF8gdCldXG4gIHwgRW1wdHkgLT4gdC5jZWxsIDwtIEZ1bGwgdlxuICB8IEVtcHR5X29uZV9oYW5kbGVyIChydW4sIGV4ZWN1dGlvbl9jb250ZXh0KSAtPlxuICAgIHQuY2VsbCA8LSBGdWxsIHY7XG4gICAgU2NoZWR1bGVyLihlbnF1ZXVlICh0ICgpKSkgZXhlY3V0aW9uX2NvbnRleHQgcnVuIHZcbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIgLT5cbiAgICB0LmNlbGwgPC0gRnVsbCB2O1xuICAgIEhhbmRsZXIuc2NoZWR1bGVfam9icyBoYW5kbGVyIHZcbjs7XG5cbmxldCBmaWxsID0gZmlsbF9leG5cblxubGV0IHJlbW92ZV9oYW5kbGVyIHQgKGhhbmRsZXIgOiBfIEhhbmRsZXIudCkgPVxuICBIYW5kbGVyLnNldF9ydW4gaGFuZGxlciBpZ25vcmU7XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBFbXB0eSB8IEVtcHR5X29uZV9oYW5kbGVyIF8gLT5cbiAgICAoKiBUaGVzZSBhcmUgb25seSBwb3NzaWJsZSBpZiBbaGFuZGxlcl0gd2FzIGFscmVhZHkgcmVtb3ZlZC4gICopXG4gICAgKClcbiAgfCBGdWxsIF8gLT5cbiAgICAoKiBUaGlzIGlzIHBvc3NpYmxlIGlmIFt0XSB3YXMgZmlsbGVkIGJlZm9yZSB3ZSB0cnkgdG8gcmVtb3ZlIHRoZSBoYW5kbGVyLiAgRS5nLlxuICAgICAgIFtEZWZlcnJlZC5jaG9vc2VdIHdpbGwgZG8gdGhpcy4gKilcbiAgICAoKVxuICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgY2VsbCAtPlxuICAgIGlmIEhhbmRsZXIuaXNfc2luZ2xldG9uIGhhbmRsZXJcbiAgICB0aGVuIHQuY2VsbCA8LSBFbXB0eVxuICAgIGVsc2UgKFxuICAgICAgaWYgcGh5c19lcXVhbCBoYW5kbGVyIGNlbGwgdGhlbiB0LmNlbGwgPC0gY2VsbF9vZl9oYW5kbGVyIChIYW5kbGVyLm5leHQgaGFuZGxlcik7XG4gICAgICBIYW5kbGVyLnVubGluayBoYW5kbGVyKVxuOztcblxubGV0IGFkZF9oYW5kbGVyIHQgcnVuIGV4ZWN1dGlvbl9jb250ZXh0ID1cbiAgbGV0IHQgPSBzcXVhc2ggdCBpblxuICBtYXRjaCB0LmNlbGwgd2l0aFxuICB8IEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSAqKVxuICB8IEVtcHR5IC0+XG4gICAgbGV0IGhhbmRsZXIgPSBIYW5kbGVyLmNyZWF0ZSBydW4gZXhlY3V0aW9uX2NvbnRleHQgaW5cbiAgICB0LmNlbGwgPC0gY2VsbF9vZl9oYW5kbGVyIGhhbmRsZXI7XG4gICAgaGFuZGxlclxuICB8IEVtcHR5X29uZV9oYW5kbGVyIChydW4nLCBleGVjdXRpb25fY29udGV4dCcpIC0+XG4gICAgbGV0IGhhbmRsZXIgPSBIYW5kbGVyLmNyZWF0ZTIgcnVuIGV4ZWN1dGlvbl9jb250ZXh0IHJ1bicgZXhlY3V0aW9uX2NvbnRleHQnIGluXG4gICAgdC5jZWxsIDwtIGNlbGxfb2ZfaGFuZGxlciBoYW5kbGVyO1xuICAgIGhhbmRsZXJcbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIgLT4gSGFuZGxlci5hZGQgaGFuZGxlciBydW4gZXhlY3V0aW9uX2NvbnRleHRcbiAgfCBGdWxsIHYgLT5cbiAgICBsZXQgaGFuZGxlciA9IEhhbmRsZXIuY3JlYXRlIHJ1biBleGVjdXRpb25fY29udGV4dCBpblxuICAgICgqIFtydW5dIGNhbGxzIFtoYW5kbGVyLnJ1bl0sIHdoaWNoLCBpZiBbaGFuZGxlcl0gaGFzIGJlZW4gcmVtb3ZlZCwgaGFzIGJlZW4gY2hhbmdlZFxuICAgICAgIHRvIFtpZ25vcmVdLiAqKVxuICAgIGxldCBydW4gdiA9IEhhbmRsZXIucnVuIGhhbmRsZXIgdiBpblxuICAgIFNjaGVkdWxlci4oZW5xdWV1ZSAodCAoKSkpIGV4ZWN1dGlvbl9jb250ZXh0IHJ1biB2O1xuICAgIGhhbmRsZXJcbjs7XG5cbmxldCBoYXNfaGFuZGxlcnMgdCA9XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBFbXB0eV9vbmVfaGFuZGxlciBfIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyAtPiB0cnVlXG4gIHwgRW1wdHkgfCBGdWxsIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCB1cG9uJyB0IHJ1biA9IGFkZF9oYW5kbGVyIHQgcnVuIFNjaGVkdWxlci4oY3VycmVudF9leGVjdXRpb25fY29udGV4dCAodCAoKSkpXG5cbigqIFt1cG9uXSBpcyBjb25jZXB0dWFsbHkgdGhlIHNhbWUgYXM6XG5cbiAgIHtbXG4gICAgIGxldCB1cG9uIHQgZiA9IGlnbm9yZSAodXBvbicgdCBydW4pIF19XG5cbiAgIEhvd2V2ZXIsIGJlbG93IGlzIGEgbW9yZSBlZmZpY2llbnQgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHdvcnRoIGRvaW5nIGJlY2F1c2UgW3Vwb25dXG4gICBpcyB2ZXJ5IHdpZGVseSB1c2VkIGFuZCBpcyBzbyBtdWNoIG1vcmUgY29tbW9uIHRoYW4gW3Vwb24nXS4gIFRoZSBiZWxvdyBpbXBsZW1lbnRhdGlvblxuICAgYXZvaWRzIHRoZSB1c2Ugb2YgdGhlIGJhZyBvZiBoYW5kbGVycyBpbiB0aGUgZXh0cmVtZWx5IGNvbW1vbiBjYXNlIG9mIG9uZSBoYW5kbGVyIGZvclxuICAgdGhlIGRlZmVycmVkLiAqKVxubGV0IHVwb24gdCBydW4gPVxuICBsZXQgc2NoZWR1bGVyID0gU2NoZWR1bGVyLnQgKCkgaW5cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyIGluXG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBGdWxsIHYgLT4gU2NoZWR1bGVyLmVucXVldWUgc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0IHJ1biB2XG4gIHwgRW1wdHkgLT4gdC5jZWxsIDwtIEVtcHR5X29uZV9oYW5kbGVyIChydW4sIGV4ZWN1dGlvbl9jb250ZXh0KVxuICB8IEVtcHR5X29uZV9oYW5kbGVyIChydW4nLCBleGVjdXRpb25fY29udGV4dCcpIC0+XG4gICAgdC5jZWxsXG4gICAgICA8LSBjZWxsX29mX2hhbmRsZXIgKEhhbmRsZXIuY3JlYXRlMiBydW4gZXhlY3V0aW9uX2NvbnRleHQgcnVuJyBleGVjdXRpb25fY29udGV4dCcpXG4gIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyBhcyBoYW5kbGVyIC0+XG4gICAgaWdub3JlIChIYW5kbGVyLmFkZCBoYW5kbGVyIHJ1biBleGVjdXRpb25fY29udGV4dCA6IF8gSGFuZGxlci50KVxuOztcblxuKCogW2Nvbm5lY3RdIHRha2VzIGl2YXJzIFtiaW5kX3Jlc3VsdF0gYW5kIFtiaW5kX3Joc10sIGFuZCBtYWtlcyBbYmluZF9yaHNdXG4gICBiZSBhbiBbSW5kaXJdIHBvaW50aW5nIHRvIHRoZSBub24taW5kaXIgY2VsbCByZWFjaGFibGUgZnJvbSBbYmluZF9yZXN1bHRdLiAgT24gZW50cnlcbiAgIHRvIFtjb25uZWN0XSwgW2JpbmRfcmVzdWx0XSBhbmQgW2JpbmRfcmhzXSBtYXkgYmUgY2hhaW5zLCBzaW5jZSBbYmluZF9yaHNdIGlzIGFuXG4gICBhcmJpdHJhcnkgdXNlci1zdXBwbGllZCBkZWZlcnJlZCwgYW5kIFtiaW5kX3Jlc3VsdF0gaXMgcmV0dXJuZWQgdG8gdGhlIHVzZXIgcHJpb3IgdG9cbiAgIGJlaW5nIFtjb25uZWN0XWVkLCBhbmQgbWF5IGhhdmUgYmVlbiBjb252ZXJ0ZWQgdG8gYW4gaW5kaXJlY3Rpb24gaW4gdGhlIGNhc2Ugb2ZcbiAgIHJpZ2h0LW5lc3RlZCBiaW5kcy5cblxuICAgVGhlIHB1cnBvc2Ugb2YgW2Nvbm5lY3RdIGlzIHRvIG1ha2UgdGFpbC1yZWN1cnNpdmUgYmluZCBsb29wcyB1c2UgY29uc3RhbnQgc3BhY2UuXG4gICBFLmcuOlxuXG4gICB7W1xuICAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICAgaWYgaSA9IDBcbiAgICAgICB0aGVuIHJldHVybiAoKVxuICAgICAgIGVsc2UgKFxuICAgICAgICAgbGV0JWJpbmQgKCkgPSBhZnRlciAoc2VjIDEuKSBpblxuICAgICAgICAgbG9vcCAoaSAtIDEpKSBdfVxuXG4gICBbY29ubmVjdF0gbWFrZXMgaW50ZXJtZWRpYXRlIGJpbmQgcmVzdWx0cyBhbGwgYmUgW0luZGlyXXMgcG9pbnRpbmcgYXQgdGhlIG91dGVybW9zdFxuICAgYmluZCwgcmF0aGVyIHRoYW4gYmVpbmcgYSBsaW5lYXItbGVuZ3RoIGNoYWluLCB3aXRoIGVhY2ggcG9pbnRpbmcgdG8gdGhlIHByZXZpb3VzIG9uZS5cbiAgIFRoZW4sIHNpbmNlIHRoZSBwcm9ncmFtIGlzIG9ubHkgaG9sZGluZyBvbiB0byB0aGUgaW5uZXJtb3N0IGFuZCBvdXRlcm1vc3QgYmluZHMgYWxsIHRoZVxuICAgaW50ZXJtZWRpYXRlIG9uZXMgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuXG4gICBbY29ubmVjdF0gd29ya3MgYnkgc3F1YXNoaW5nIGl0cyBhcmd1bWVudHMgc28gdGhhdCB0aGUgW2JpbmRfcmhzXSBhbHdheXMgcG9pbnRzIGF0IHRoZVxuICAgdWx0aW1hdGUgcmVzdWx0LiAqKVxubGV0IGNvbm5lY3QgPVxuICAoKiBbcmVwb2ludF9pbmRpcnMgfml2YXIgfmluZGlyIH5iaW5kX3Jlc3VsdF0gcmVwb2ludHMgdG8gW2luZGlyXSBhbGwgdGhlIGl2YXJzIGluIHRoZVxuICAgICBjaGFpbiByZWFjaGFibGUgZnJvbSBbaXZhcl0sIGFuZCByZXR1cm5zIHRoZSBub24tW0luZGlyXSBjZWxsIGF0IHRoZSBlbmQgb2YgdGhlXG4gICAgIGNoYWluLiAgQWZ0ZXIgcmVwb2ludGluZywgd2Ugd2lsbCBtZXJnZSB0aGUgaGFuZGxlcnMgaW4gdGhhdCBjZWxsIHdpdGggdGhlIGhhbmRsZXJzXG4gICAgIGluIFtiaW5kX3Jlc3VsdF0sIGFuZCBwdXQgdGhlIG1lcmdlZCBzZXQgb2YgaGFuZGxlcnMgaW4gW2JpbmRfcmVzdWx0XS4gKilcbiAgbGV0IHJlYyByZXBvaW50X2luZGlycyB+aXZhciB+aW5kaXIgfmJpbmRfcmVzdWx0ID1cbiAgICBsZXQgY2VsbCA9IGl2YXIuY2VsbCBpblxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgSW5kaXIgaXZhcicgLT5cbiAgICAgIGl2YXIuY2VsbCA8LSBpbmRpcjtcbiAgICAgIHJlcG9pbnRfaW5kaXJzIH5pdmFyOml2YXInIH5pbmRpciB+YmluZF9yZXN1bHRcbiAgICB8IEZ1bGwgXyAtPiBjZWxsXG4gICAgfCBFbXB0eSB8IEVtcHR5X29uZV9oYW5kbGVyIF8gfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIC0+XG4gICAgICAoKiBJdCBpcyBwb3NzaWJsZSB0aGF0IFtiaW5kX3Jlc3VsdF0gYW5kIFtiaW5kX3Joc10gYXJlIG5vdCBlcXVhbCwgYnV0IHRoZWlyIGNoYWluc1xuICAgICAgICAgb2YgaW5kaXJzIGxlYWQgdG8gdGhlIHNhbWUgbm9uLVtJbmRpcl0gY2VsbCwgaW4gd2hpY2ggY2FzZSB3ZSBjYW5ub3Qgc2V0IHRoYXRcbiAgICAgICAgIGNlbGwgdG8gcG9pbnQgdG8gaXRzZWxmLCBiZWNhdXNlIHRoYXQgd291bGQgaW50cm9kdWNlIGEgY3ljbGUuICopXG4gICAgICBpZiBub3QgKHBoeXNfZXF1YWwgaXZhciBiaW5kX3Jlc3VsdCkgdGhlbiBpdmFyLmNlbGwgPC0gaW5kaXI7XG4gICAgICBjZWxsXG4gIGluXG4gIGZ1biB+YmluZF9yZXN1bHQgfmJpbmRfcmhzIC0+XG4gICAgaWYgbm90IChwaHlzX2VxdWFsIGJpbmRfcmVzdWx0IGJpbmRfcmhzKVxuICAgIHRoZW4gKFxuICAgICAgbGV0IGJpbmRfcmVzdWx0ID0gc3F1YXNoIGJpbmRfcmVzdWx0IGluXG4gICAgICBsZXQgaW5kaXIgPSBJbmRpciBiaW5kX3Jlc3VsdCBpblxuICAgICAgbGV0IGJpbmRfcmhzX2NvbnRlbnRzID0gcmVwb2ludF9pbmRpcnMgfml2YXI6YmluZF9yaHMgfmluZGlyIH5iaW5kX3Jlc3VsdCBpblxuICAgICAgKCogdXBkYXRlIFtiaW5kX3Jlc3VsdF0gd2l0aCB0aGUgdW5pb24gb2YgaGFuZGxlcnMgaW4gW2JpbmRfcmVzdWx0XSBhbmRcbiAgICAgICAgIFtiaW5kX3Joc10gKilcbiAgICAgIG1hdGNoIGJpbmRfcmVzdWx0LmNlbGwsIGJpbmRfcmhzX2NvbnRlbnRzIHdpdGhcbiAgICAgIHwgSW5kaXIgXywgXyB8IF8sIEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gYW5kIFtyZXBvaW50X2luZGlyc10gKilcbiAgICAgICgqIFtjb25uZWN0XSBpcyBvbmx5IHVzZWQgaW4gYmluZCwgd2hvc2UgaXZhciBpcyBvbmx5IGV2ZXIgZXhwb3J0ZWQgYXMgYSByZWFkLW9ubHlcbiAgICAgICAgIGRlZmVycmVkLiAgVGh1cywgW2JpbmRfcmVzdWx0XSBtdXN0IGJlIGVtcHR5LiAqKVxuICAgICAgfCBGdWxsIF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IF8sIEVtcHR5IC0+ICgpXG4gICAgICB8IEVtcHR5LCBfIC0+IGJpbmRfcmVzdWx0LmNlbGwgPC0gYmluZF9yaHNfY29udGVudHNcbiAgICAgIHwgRW1wdHlfb25lX2hhbmRsZXIgKHJ1biwgZXhlY3V0aW9uX2NvbnRleHQpLCBGdWxsIHYgLT5cbiAgICAgICAgYmluZF9yZXN1bHQuY2VsbCA8LSBiaW5kX3Joc19jb250ZW50cztcbiAgICAgICAgU2NoZWR1bGVyLihlbnF1ZXVlICh0ICgpKSkgZXhlY3V0aW9uX2NvbnRleHQgcnVuIHZcbiAgICAgIHwgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlciksIEZ1bGwgdiAtPlxuICAgICAgICBiaW5kX3Jlc3VsdC5jZWxsIDwtIGJpbmRfcmhzX2NvbnRlbnRzO1xuICAgICAgICBIYW5kbGVyLnNjaGVkdWxlX2pvYnMgaGFuZGxlciB2XG4gICAgICB8ICggRW1wdHlfb25lX2hhbmRsZXIgKHJ1bjEsIGV4ZWN1dGlvbl9jb250ZXh0MSlcbiAgICAgICAgLCBFbXB0eV9vbmVfaGFuZGxlciAocnVuMiwgZXhlY3V0aW9uX2NvbnRleHQyKSApIC0+XG4gICAgICAgIGxldCBoYW5kbGVyMSA9IEhhbmRsZXIuY3JlYXRlMiBydW4xIGV4ZWN1dGlvbl9jb250ZXh0MSBydW4yIGV4ZWN1dGlvbl9jb250ZXh0MiBpblxuICAgICAgICBiaW5kX3Jlc3VsdC5jZWxsIDwtIGNlbGxfb2ZfaGFuZGxlciBoYW5kbGVyMVxuICAgICAgfCAoIChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIxKVxuICAgICAgICAsIEVtcHR5X29uZV9oYW5kbGVyIChydW4yLCBleGVjdXRpb25fY29udGV4dDIpICkgLT5cbiAgICAgICAgaWdub3JlIChIYW5kbGVyLmFkZCBoYW5kbGVyMSBydW4yIGV4ZWN1dGlvbl9jb250ZXh0MiA6IF8gSGFuZGxlci50KVxuICAgICAgfCAoIEVtcHR5X29uZV9oYW5kbGVyIChydW4xLCBleGVjdXRpb25fY29udGV4dDEpXG4gICAgICAgICwgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlcjIpICkgLT5cbiAgICAgICAgbGV0IGhhbmRsZXIxID0gSGFuZGxlci5hZGQgaGFuZGxlcjIgcnVuMSBleGVjdXRpb25fY29udGV4dDEgaW5cbiAgICAgICAgYmluZF9yZXN1bHQuY2VsbCA8LSBjZWxsX29mX2hhbmRsZXIgaGFuZGxlcjFcbiAgICAgIHwgKCAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyBhcyBoYW5kbGVyMSlcbiAgICAgICAgLCAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyBhcyBoYW5kbGVyMikgKSAtPiBIYW5kbGVyLnNwbGljZSBoYW5kbGVyMSBoYW5kbGVyMilcbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBJdmFyID0gSXZhcjBcbm1vZHVsZSBIYW5kbGVyID0gSXZhci5IYW5kbGVyXG5cbigqIERlZmVycmVkcyBwcmVzZW50IGEgY292YXJpYW50IHZpZXcgb2YgaXZhcnMuICBXZSBjb3VsZCBhY3R1YWxseSBpbXBsZW1lbnQgZGVmZXJyZWRzXG4gICB1c2luZyBhIHJlY29yZCBvZiBjbG9zdXJlcywgYXMgaW4gdGhlIFtlc3NlbmNlX29mX2RlZmVycmVkXSByZWNvcmQgYmVsb3csIGZvciB3aGljaCB0aGVcbiAgIE9DYW1sIHR5cGUgY2hlY2tlciBjYW4gaW5mZXIgY292YXJpYW5jZS4gIEhvd2V2ZXIsIGRvaW5nIHNvIHdvdWxkIG1ha2UgW0l2YXIucmVhZF0gdmVyeVxuICAgY29zdGx5LCBiZWNhdXNlIGl0IHdvdWxkIGhhdmUgdG8gYWxsb2NhdGUgbG90cyBvZiBjbG9zdXJlcyBhbmQgYSByZWNvcmQuICBJbnN0ZWFkIG9mXG4gICBkb2luZyB0aGlzLCB3ZSBtYWtlIGRlZmVycmVkcyBhbiBhYnN0cmFjdCBjb3ZhcmlhbnQgdHlwZSwgd2hpY2ggY29uY3JldGVseSBpcyBqdXN0IHRoZVxuICAgaXZhciwgYW5kIHVzZSBbT2JqLm1hZ2ljXSB0byBjb252ZXJ0IGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gYSBkZWZlcnJlZCBhbmQgaXRzIGNvbmNyZXRlXG4gICByZXByZXNlbnRhdGlvbiBhcyBhbiBpdmFyLiAgVGhpcyBbT2JqLm1hZ2ljXSBpcyBzYWZlIGJlY2F1c2UgdGhlIHJlcHJlc2VudGF0aW9uIGlzXG4gICBhbHdheXMganVzdCBhbiBpdmFyLCBhbmQgdGhlIGNvdmFyaWFuY2UgZm9sbG93cyBmcm9tIHRoZSBmYWN0IHRoYXQgYWxsIHRoZSBkZWZlcnJlZFxuICAgb3BlcmF0aW9ucyBhcmUgZXF1aXZhbGVudCB0byB0aG9zZSBpbXBsZW1lbnRlZCBkaXJlY3RseSBvbiB0b3Agb2YgdGhlXG4gICBbZXNzZW5jZV9vZl9kZWZlcnJlZF0uXG5cbiAgIHtbXG4gICAgIHR5cGUgKCsnYSwgJ2V4ZWN1dGlvbl9jb250ZXh0KSBlc3NlbmNlX29mX2RlZmVycmVkID1cbiAgICAgICB7IHBlZWsgICAgICAgICAgICAgICAgICAgICAgOiB1bml0IC0+ICdhIG9wdGlvblxuICAgICAgIDsgaXNfZGV0ZXJtaW5lZCAgICAgICAgICAgICA6IHVuaXQgLT4gYm9vbFxuICAgICAgIDsgdXBvbiAgICAgICAgICAgICAgICAgICAgICA6ICgnYSAtPiB1bml0KSAtPiB1bml0XG4gICAgICAgOyB1cG9uJyAgICAgICAgICAgICAgICAgICAgIDogKCdhIC0+IHVuaXQpIC0+IFVucmVnaXN0ZXIudFxuICAgICAgIDsgaW5zdGFsbF9yZW1vdmFibGVfaGFuZGxlciA6ICgnYSwgJ2V4ZWN1dGlvbl9jb250ZXh0KSBSYXdfaGFuZGxlci50IC0+IFVucmVnaXN0ZXIudDsgfSBdfSAqKVxuXG50eXBlICsnYSB0ID0gJ2EgVHlwZXMuRGVmZXJyZWQudFxuXG4oKiB0aGUgYWJzdHJhY3QgY292YXJpYW50IHR5cGUsIGVxdWl2YWxlbnQgdG8gaXZhciAqKVxuXG5sZXQgb2ZfaXZhciAodHlwZSBhKSAoaXZhciA6IGEgSXZhci50KSA6IGEgdCA9IE9iai5tYWdpYyBpdmFyXG5sZXQgdG9faXZhciAodHlwZSBhKSB0IDogYSBJdmFyLnQgPSBPYmoubWFnaWMgKHQgOiBhIHQpXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPSBJdmFyLmludmFyaWFudCBpbnZhcmlhbnRfYSAodG9faXZhciB0KVxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IEl2YXIuc2V4cF9vZl90IHNleHBfb2ZfYSAodG9faXZhciB0KVxubGV0IHBlZWsgdCA9IEl2YXIucGVlayAodG9faXZhciB0KVxubGV0IHJldHVybiBhID0gb2ZfaXZhciAoSXZhci5jcmVhdGVfZnVsbCBhKVxubGV0IGlzX2RldGVybWluZWQgdCA9IEl2YXIuaXNfZnVsbCAodG9faXZhciB0KVxuXG5sZXQgdmFsdWVfZXhuIHQgPVxuICBJdmFyLnZhbHVlXG4gICAgKHRvX2l2YXIgdClcbiAgICB+aWZfZW1wdHlfdGhlbl9mYWlsd2l0aDpcIkRlZmVycmVkLnZhbHVlX2V4biBjYWxsZWQgb24gdW5kZXRlcm1pbmVkIGRlZmVycmVkXCJcbjs7XG5cbmxldCB1cG9uIHQgZiA9IEl2YXIudXBvbiAodG9faXZhciB0KSBmXG5cbmxldCBjcmVhdGUgZiA9XG4gIGxldCByZXN1bHQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICBmIHJlc3VsdDtcbiAgb2ZfaXZhciByZXN1bHRcbjs7XG5cbigqIGRvbid0IHVzZSBbY3JlYXRlXSBoZXJlIGFzIGl0IHdvdWxkIGFsbG9jYXRlIG9uZSBtb3JlIGNsb3N1cmUgKilcbmxldCBiaW5kIHQgfmYgPVxuICBsZXQgYmluZF9yZXN1bHQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICB1cG9uIHQgKGZ1biBhIC0+IEl2YXIuY29ubmVjdCB+YmluZF9yZXN1bHQgfmJpbmRfcmhzOih0b19pdmFyIChmIGEpKSk7XG4gIG9mX2l2YXIgYmluZF9yZXN1bHRcbjs7XG5cbmxldCBhZGRfaGFuZGxlciB0IGYgZXhlY3V0aW9uX2NvbnRleHQgPSBJdmFyLmFkZF9oYW5kbGVyICh0b19pdmFyIHQpIGYgZXhlY3V0aW9uX2NvbnRleHRcbmxldCByZW1vdmVfaGFuZGxlciB0IGggPSBJdmFyLnJlbW92ZV9oYW5kbGVyICh0b19pdmFyIHQpIGhcbiIsIm9wZW4gQ29yZVxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQwXG5pbmNsdWRlIEl2YXIwXG5cbmxldCByZWFkID0gRGVmZXJyZWQub2ZfaXZhclxubGV0IGZpbGxfaWZfZW1wdHkgdCB2ID0gaWYgaXNfZW1wdHkgdCB0aGVuIGZpbGxfZXhuIHQgdlxuXG5pbmNsdWRlXG4gIEJpbmFibGUuT2ZfYmluYWJsZTFfd2l0aG91dF91dWlkIFtAYWxlcnQgXCItbGVnYWN5XCJdXG4gICAgKE9wdGlvbilcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgdG9fYmluYWJsZSB0ID0gcGVlayB0XG5cbiAgICAgIGxldCBvZl9iaW5hYmxlID0gZnVuY3Rpb25cbiAgICAgICAgfCBOb25lIC0+IGNyZWF0ZSAoKVxuICAgICAgICB8IFNvbWUgYSAtPiBjcmVhdGVfZnVsbCBhXG4gICAgICA7O1xuICAgIGVuZClcbiIsIigqKiBbTW9uYWRfc2VxdWVuY2UuU10gaXMgYSBnZW5lcmljIGludGVyZmFjZSBzcGVjaWZ5aW5nIGZ1bmN0aW9ucyB0aGF0IGRlYWwgd2l0aCBhXG4gICAgY29udGFpbmVyIGFuZCBhIG1vbmFkLiAgSXQgaXMgc3BlY2lhbGl6ZWQgdG8gdGhlIFtEZWZlcnJlZF0gbW9uYWQgYW5kIHVzZWQgd2l0aFxuICAgIHZhcmlvdXMgY29udGFpbmVycyBpbiBtb2R1bGVzIFtEZWZlcnJlZC5BcnJheV0sIFtEZWZlcnJlZC5MaXN0XSwgW0RlZmVycmVkLlF1ZXVlXSwgYW5kXG4gICAgW0RlZmVycmVkLlNlcXVlbmNlXS4gIFRoZSBbTW9uYWRfc2VxdWVuY2UuaG93XSB0eXBlIHNwZWNpZmllcyB0aGUgcGFyYWxsZWxpc20gb2ZcbiAgICBjb250YWluZXIgaXRlcmF0b3JzLiAqKVxuXG5vcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxudHlwZSBob3cgPVxuICBbIGBQYXJhbGxlbCAoKiogbGlrZSBbYE1heF9jb25jdXJyZW50X2pvYnMgSW50Lm1heF92YWx1ZV0gKilcbiAgfCBgU2VxdWVudGlhbFxuICAgICgqKiBbYFNlcXVlbnRpYWxdIGlzIG9mdGVuIGJ1dCBub3QgYWx3YXlzIHRoZSBzYW1lIGFzIFtgTWF4X2NvbmN1cnJlbnRfam9icyAxXVxuICAgICAgKGZvciBleGFtcGxlLCB0aGV5IGRpZmZlciBpbiB0aGUgW09yX2Vycm9yXSBtb25hZCkuICopXG4gIHwgYE1heF9jb25jdXJyZW50X2pvYnMgb2YgaW50XG4gIF1cbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSBtb25hZFxuICB0eXBlICdhIHRcblxuICB2YWwgZm9sZGkgOiAnYSB0IC0+IGluaXQ6J2IgLT4gZjooaW50IC0+ICdiIC0+ICdhIC0+ICdiIG1vbmFkKSAtPiAnYiBtb25hZFxuICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYiAtPiBmOignYiAtPiAnYSAtPiAnYiBtb25hZCkgLT4gJ2IgbW9uYWRcbiAgdmFsIGZpbmQgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wgbW9uYWQpIC0+ICdhIG9wdGlvbiBtb25hZFxuICB2YWwgZmluZGkgOiAnYSB0IC0+IGY6KGludCAtPiAnYSAtPiBib29sIG1vbmFkKSAtPiAoaW50ICogJ2EpIG9wdGlvbiBtb25hZFxuICB2YWwgZmluZF9tYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbiBtb25hZCkgLT4gJ2Igb3B0aW9uIG1vbmFkXG4gIHZhbCBmaW5kX21hcGkgOiAnYSB0IC0+IGY6KGludCAtPiAnYSAtPiAnYiBvcHRpb24gbW9uYWQpIC0+ICdiIG9wdGlvbiBtb25hZFxuICB2YWwgZXhpc3RzIDogJ2EgdCAtPiBmOignYSAtPiBib29sIG1vbmFkKSAtPiBib29sIG1vbmFkXG4gIHZhbCBleGlzdHNpIDogJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gYm9vbCBtb25hZCkgLT4gYm9vbCBtb25hZFxuICB2YWwgZm9yX2FsbCA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCBtb25hZCkgLT4gYm9vbCBtb25hZFxuICB2YWwgZm9yX2FsbGkgOiAnYSB0IC0+IGY6KGludCAtPiAnYSAtPiBib29sIG1vbmFkKSAtPiBib29sIG1vbmFkXG4gIHZhbCBhbGwgOiAnYSBtb25hZCB0IC0+ICdhIHQgbW9uYWRcbiAgdmFsIGFsbF91bml0IDogdW5pdCBtb25hZCB0IC0+IHVuaXQgbW9uYWRcblxuICAoKiogezIgRGVmZXJyZWQgaXRlcmF0b3JzfSAqKVxuXG4gIHZhbCBpbml0IDogaG93OmhvdyAtPiBpbnQgLT4gZjooaW50IC0+ICdhIG1vbmFkKSAtPiAnYSB0IG1vbmFkXG4gIHZhbCBpdGVyIDogaG93OmhvdyAtPiAnYSB0IC0+IGY6KCdhIC0+IHVuaXQgbW9uYWQpIC0+IHVuaXQgbW9uYWRcbiAgdmFsIGl0ZXJpIDogaG93OmhvdyAtPiAnYSB0IC0+IGY6KGludCAtPiAnYSAtPiB1bml0IG1vbmFkKSAtPiB1bml0IG1vbmFkXG4gIHZhbCBtYXAgOiBob3c6aG93IC0+ICdhIHQgLT4gZjooJ2EgLT4gJ2IgbW9uYWQpIC0+ICdiIHQgbW9uYWRcbiAgdmFsIG1hcGkgOiBob3c6aG93IC0+ICdhIHQgLT4gZjooaW50IC0+ICdhIC0+ICdiIG1vbmFkKSAtPiAnYiB0IG1vbmFkXG4gIHZhbCBmaWx0ZXIgOiBob3c6aG93IC0+ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCBtb25hZCkgLT4gJ2EgdCBtb25hZFxuICB2YWwgZmlsdGVyaSA6IGhvdzpob3cgLT4gJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gYm9vbCBtb25hZCkgLT4gJ2EgdCBtb25hZFxuICB2YWwgZmlsdGVyX21hcCA6IGhvdzpob3cgLT4gJ2EgdCAtPiBmOignYSAtPiAnYiBvcHRpb24gbW9uYWQpIC0+ICdiIHQgbW9uYWRcbiAgdmFsIGZpbHRlcl9tYXBpIDogaG93OmhvdyAtPiAnYSB0IC0+IGY6KGludCAtPiAnYSAtPiAnYiBvcHRpb24gbW9uYWQpIC0+ICdiIHQgbW9uYWRcbiAgdmFsIGNvbmNhdF9tYXAgOiBob3c6aG93IC0+ICdhIHQgLT4gZjooJ2EgLT4gJ2IgdCBtb25hZCkgLT4gJ2IgdCBtb25hZFxuICB2YWwgY29uY2F0X21hcGkgOiBob3c6aG93IC0+ICdhIHQgLT4gZjooaW50IC0+ICdhIC0+ICdiIHQgbW9uYWQpIC0+ICdiIHQgbW9uYWRcbmVuZFxuIiwib3BlbiBDb3JlXG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyMVxuaW5jbHVkZSBEZWZlcnJlZDBcblxuKCogVG8gYXZvaWQgYSBzcGFjZSBsZWFrLCBpdCBpcyBuZWNlc3NhcnkgdGhhdCBbbmV2ZXJdIGFsbG9jYXRlcyBhIG5ldyBpdmFyIHdoZW5ldmVyIGl0IGlzXG4gICBjYWxsZWQuICBDb2RlIGNhbiBiaW5kIG9uIFtuZXZlciAoKV0sIHNvIGlmIHdlIHJlLXVzZWQgdGhlIGl2YXIsIHdlIGNvdWxkIGVuZGxlc3NseVxuICAgYWNjdW11bGF0ZSBoYW5kbGVycy4gKilcbmxldCBuZXZlciAoKSA9IEl2YXIucmVhZCAoSXZhci5jcmVhdGUgKCkpXG5cbm1vZHVsZSBNID0gTW9uYWQuTWFrZSAoc3RydWN0XG4gIGluY2x1ZGUgRGVmZXJyZWQwXG5cbiAgbGV0IG1hcCB0IH5mID1cbiAgICAoKiBXZSBtYW51YWxseSBpbmxpbmUgW0RlZmVycmVkLmNyZWF0ZV0gaGVyZSwgYmVjYXVzZSB0aGUgbm9uLWZsYW1iZGEgY29tcGlsZXIgaXNuJ3RcbiAgICAgICAgIGFibGUgdG8gb3B0aW1pemUgYXdheSB0aGUgY2xvc3VyZSB0aGF0IHdvdWxkIGJlIGJlIGNyZWF0ZWQuICopXG4gICAgbGV0IHJlc3VsdCA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgdXBvbiB0IChmdW4gYSAtPiBJdmFyLmZpbGxfZXhuIHJlc3VsdCAoZiBhKSk7XG4gICAgb2ZfaXZhciByZXN1bHRcbiAgOztcblxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbmVuZClcblxuaW5jbHVkZSBNXG5cbigqIFdlIHJlYmluZCBhbGwgdGhlIHZhcmlvdXMgW3JldHVybl1zIGJlY2F1c2UgdGhlIHVzZSBvZiB0aGUgW01vbmFkLk1ha2VdIGZ1bmN0b3JcbiAgIGNhdXNlcyB0aGUgY29tcGlsZXIgdG8gbm90IGlubGluZSBbcmV0dXJuXSwgYW5kIGhlbmNlIG1ha2VzIGl0IGltcG9zc2libGUgdG9cbiAgIHN0YXRpY2FsbHkgYWxsb2NhdGUgY29uc3RhbnRzIGxpa2UgW3JldHVybiAoKV0uICBCeSByZWJpbmRpbmcgW3JldHVybl0gYXNcbiAgIFtEZWZlcnJlZDAucmV0dXJuXSwgdGhlIGNvbXBpbGVyIGNhbiBzZWUgdGhhdDpcblxuICAge1tcbiAgICAgcmV0dXJuIGEgPSB7IEl2YXIuSW1tdXRhYmxlLiBjZWxsID0gRnVsbCBhIH0gXX1cblxuICAgQW5kIGhlbmNlLCBpZiBbYV0gaXMgY29uc3RhbnQsIHRoZW4gdGhlIHJldHVybiBpcyBjb25zdGFudCBhbmQgY2FuIGJlIHN0YXRpY2FsbHlcbiAgIGFsbG9jYXRlZC4gIFdoZW4gY29tcGlsaW5nIHdpdGggZmxhbWJkYSwgdGhlIGNvbXBpbGVyIGlubGluZXMgW3JldHVybl0gYW5kIHRoaXMgbWFudWFsXG4gICByZWJpbmRpbmcgd291bGQgbm90IGhlbHA7IHdlJ3ZlIGRlY2lkZWQgdG8gZG8gaXQgYW55d2F5IHNvIHRoYXQgbm9uLWZsYW1iZGEgYnVpbGRzXG4gICBnZXQgdGhlIG9wdGltaXphdGlvbi4gKilcbmxldCByZXR1cm4gPSBEZWZlcnJlZDAucmV0dXJuXG5cbm1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gIGluY2x1ZGUgTS5MZXRfc3ludGF4XG5cbiAgbGV0IHJldHVybiA9IERlZmVycmVkMC5yZXR1cm5cblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgTS5MZXRfc3ludGF4LkxldF9zeW50YXhcblxuICAgIGxldCByZXR1cm4gPSBEZWZlcnJlZDAucmV0dXJuXG4gIGVuZFxuZW5kXG5cbm9wZW4gTGV0X3N5bnRheFxuXG4oKiBXZSBzaGFkb3cgW2FsbF0gb24tcHVycG9zZSBoZXJlLCBzaW5jZSB0aGUgZGVmYXVsdCBkZWZpbml0aW9uIGludHJvZHVjZXMgYSBjaGFpbiBvZlxuICAgYmluZHMgYXMgbG9uZyBhcyB0aGUgbGlzdC4gKilcbmxldCBhbGwgPSBgTWFrZV9zdXJlX3RvX2RlZmluZV9hbGxfZWxzZXdoZXJlXG5sZXQgXyA9IGFsbFxubGV0IHVuaXQgPSByZXR1cm4gKClcblxubGV0IGJvdGggdDEgdDIgPVxuICBjcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICB1cG9uIHQxIChmdW4gYTEgLT4gdXBvbiB0MiAoZnVuIGEyIC0+IEl2YXIuZmlsbF9leG4gcmVzdWx0IChhMSwgYTIpKSkpXG47O1xuXG5tb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gIGxldCAoID4+PiApID0gdXBvblxuICBsZXQgcHB4X2JvdGggPSBib3RoXG5lbmRcblxub3BlbiBJbmZpeFxuXG5sZXQgZG9uJ3Rfd2FpdF9mb3IgKF8gOiB1bml0IHQpID0gKClcblxubW9kdWxlIENob2ljZSA9IHN0cnVjdFxuICB0eXBlICsnYSB0ID0gVCA6ICdiIERlZmVycmVkMC50ICogKCdiIC0+ICdhKSAtPiAnYSB0XG5cbiAgbGV0IG1hcCAoVCAodCwgZjEpKSB+ZjpmMiA9IFQgKHQsIGZ1biB4IC0+IGYyIChmMSB4KSlcbmVuZFxuXG5tb2R1bGUgVW5yZWdpc3RlciA9IHN0cnVjdFxuICAoKiBUaGlzIHJlcHJlc2VudGF0aW9uIHNhdmVzIDJuIHdvcmRzIGZvciBhIGxpc3Qgb2YgbiBjaG9pY2VzLiAqKVxuICB0eXBlICdyIHQgPVxuICAgIHwgTmlsIDogJ3IgdFxuICAgIHwgQ29ucyA6ICdhIERlZmVycmVkMC50ICogKCdhIC0+ICdyKSAqICdhIERlZmVycmVkMC5IYW5kbGVyLnQgKiAnciB0IC0+ICdyIHRcblxuICBsZXQgcmVjIHByb2Nlc3MgPSBmdW5jdGlvblxuICAgIHwgTmlsIC0+ICgpXG4gICAgfCBDb25zICh0LCBfZiwgaGFuZGxlciwgcmVzdCkgLT5cbiAgICAgIHJlbW92ZV9oYW5kbGVyIHQgaGFuZGxlcjtcbiAgICAgIHByb2Nlc3MgcmVzdFxuICA7O1xuZW5kXG5cbmxldCBjaG9pY2UgdCBmID0gQ2hvaWNlLlQgKHQsIGYpXG5cbmxldCBlbmFibGVkIGNob2ljZXMgPVxuICBsZXQgcmVzdWx0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbGV0IHVucmVnaXN0ZXJzID0gcmVmIFVucmVnaXN0ZXIuTmlsIGluXG4gIGxldCByZWFkeSBfID1cbiAgICBpZiBJdmFyLmlzX2VtcHR5IHJlc3VsdFxuICAgIHRoZW4gKFxuICAgICAgVW5yZWdpc3Rlci5wcm9jZXNzICF1bnJlZ2lzdGVycztcbiAgICAgIEl2YXIuZmlsbF9leG4gcmVzdWx0IChmdW4gKCkgLT5cbiAgICAgICAgTGlzdC5yZXZcbiAgICAgICAgICAoTGlzdC5mb2xkIGNob2ljZXMgfmluaXQ6W10gfmY6KGZ1biBhYyAoQ2hvaWNlLlQgKHQsIGYpKSAtPlxuICAgICAgICAgICAgIG1hdGNoIHBlZWsgdCB3aXRoXG4gICAgICAgICAgICAgfCBOb25lIC0+IGFjXG4gICAgICAgICAgICAgfCBTb21lIHYgLT4gZiB2IDo6IGFjKSkpKVxuICBpblxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBTY2hlZHVsZXIuKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpKSBpblxuICB1bnJlZ2lzdGVyc1xuICAgIDo9IExpc3QuZm9sZCBjaG9pY2VzIH5pbml0OlVucmVnaXN0ZXIuTmlsIH5mOihmdW4gYWNjIChDaG9pY2UuVCAodCwgZikpIC0+XG4gICAgICAgICBDb25zICh0LCBmLCBEZWZlcnJlZDAuYWRkX2hhbmRsZXIgdCByZWFkeSBleGVjdXRpb25fY29udGV4dCwgYWNjKSk7XG4gIEl2YXIucmVhZCByZXN1bHRcbjs7XG5cbmxldCByZWMgY2hvb3NlX3Jlc3VsdCBjaG9pY2VzID1cbiAgbWF0Y2ggY2hvaWNlcyB3aXRoXG4gIHwgVW5yZWdpc3Rlci5OaWwgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgVW5yZWdpc3Rlci5Db25zICh0LCBmLCBfLCByZXN0KSAtPlxuICAgIChtYXRjaCBwZWVrIHQgd2l0aFxuICAgICB8IE5vbmUgLT4gY2hvb3NlX3Jlc3VsdCByZXN0XG4gICAgIHwgU29tZSB2IC0+IGYgdilcbjs7XG5cbmxldCBnZW5lcmljX2Nob29zZSBjaG9pY2VzID1cbiAgbGV0IHJlc3VsdCA9IEl2YXIuY3JlYXRlICgpIGluXG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9IFNjaGVkdWxlci4oY3VycmVudF9leGVjdXRpb25fY29udGV4dCAodCAoKSkpIGluXG4gICgqIEEgYmFjay1wYXRjaGVkIHJlZiBjb3VsZCBiZSB1c2VkIGhlcmUsIGJ1dCB1c2luZyBsYXp5IHNhdmVzIHNvbWUgbWVtb3J5XG4gICAgIGJlY2F1c2UgdGhlIEdDIGV2ZW50dWFsbHkgcmVtb3ZlcyB0aGUgZXh0cmEgaW5kaXJlY3Rpb24uICopXG4gIGxldCByZWMgdW5yZWdpc3RlcnMgPVxuICAgIGxhenlcbiAgICAgIChMaXN0LmZvbGRfcmlnaHQgY2hvaWNlcyB+aW5pdDpVbnJlZ2lzdGVyLk5pbCB+ZjooZnVuIChDaG9pY2UuVCAodCwgZikpIGFjYyAtPlxuICAgICAgICAgVW5yZWdpc3Rlci5Db25zICh0LCBmLCBEZWZlcnJlZDAuYWRkX2hhbmRsZXIgdCByZWFkeSBleGVjdXRpb25fY29udGV4dCwgYWNjKSkpXG4gIGFuZCByZWFkeSA6ICdhLiAnYSAtPiB1bml0ID1cbiAgICBmdW4gXyAtPlxuICAgIGlmIEl2YXIuaXNfZW1wdHkgcmVzdWx0XG4gICAgdGhlbiAoXG4gICAgICBsZXQgdW5yZWdpc3RlcnMgPSBMYXp5LmZvcmNlIHVucmVnaXN0ZXJzIGluXG4gICAgICBVbnJlZ2lzdGVyLnByb2Nlc3MgdW5yZWdpc3RlcnM7XG4gICAgICBJdmFyLmZpbGxfZXhuIHJlc3VsdCAoY2hvb3NlX3Jlc3VsdCB1bnJlZ2lzdGVycykpXG4gIGluXG4gIGxldCAoXyA6IF8pID0gTGF6eS5mb3JjZSB1bnJlZ2lzdGVycyBpblxuICBJdmFyLnJlYWQgcmVzdWx0XG47O1xuXG4oKiBbY2hvb3NlMl0gaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBbY2hvb3NlXSB0aGF0IGhhcyBiZXR0ZXIgbWVtb3J5IHVzYWdlLlxuICAgQXQgdGhlIHRpbWUgb2Ygd3JpdGluZywgW2Nob29zZTJdIGtlZXBzIDIyIGV4dHJhIHdvcmRzIGFsaXZlXG4gICBmb3IgdGhlIGR1cmF0aW9uIG9mIGNob2ljZSBzdGF5aW5nIHVuZGV0ZXJtaW5lZCwgd2hpbGUgdGhlIGVxdWl2YWxlbnQgZ2VuZXJpY1xuICAgW2Nob29zZV0ga2VlcHMgMjcgKHNlZSB0aGUgYmVuY2htYXJrIGluIC4uL2JlbmNoL2Jpbi9iZW5jaF9jaG9vc2VfbWVtb3J5X3VzYWdlLm1sKS4gKilcbmxldCBjaG9vc2UyIGEgZmEgYiBmYiA9XG4gIGxldCByZXN1bHQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBTY2hlZHVsZXIuKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpKSBpblxuICBsZXQgcmVjIGFfaGFuZGxlciA9IGxhenkgKERlZmVycmVkMC5hZGRfaGFuZGxlciBhIHJlYWR5IGV4ZWN1dGlvbl9jb250ZXh0KVxuICBhbmQgYl9oYW5kbGVyID0gbGF6eSAoRGVmZXJyZWQwLmFkZF9oYW5kbGVyIGIgcmVhZHkgZXhlY3V0aW9uX2NvbnRleHQpXG4gIGFuZCByZWFkeSA6ICdhLiAnYSAtPiB1bml0ID1cbiAgICBmdW4gXyAtPlxuICAgIGlmIEl2YXIuaXNfZW1wdHkgcmVzdWx0XG4gICAgdGhlbiAoXG4gICAgICAoKiBUaGUgb3JkZXIgb2YgdGhlc2Ugb3BlcmF0aW9ucyBtYXR0ZXJzOlxuICAgICAgICAgaWYgd2UgY2FsbCBbZmJdIG9yIFtmYV0gZmlyc3QgYW5kIFtyZW1vdmVfaGFuZGxlcl0gYWZ0ZXIsIHRoZW5cbiAgICAgICAgIGFueSBleGNlcHRpb25zIHJhaXNlZCB3aWxsIGNhdXNlIHRoZSBoYW5kbGVycyB0byByZW1haW4gYW5kIHRoZW5cbiAgICAgICAgIHRoZSBcInNlY29uZCBjaG9pY2VcIiBnZXRzIGEgY2hhbmNlIHRvIHJ1bi5cbiAgICAgICopXG4gICAgICByZW1vdmVfaGFuZGxlciBhIChMYXp5LmZvcmNlIGFfaGFuZGxlcik7XG4gICAgICByZW1vdmVfaGFuZGxlciBiIChMYXp5LmZvcmNlIGJfaGFuZGxlcik7XG4gICAgICBtYXRjaCBwZWVrIGEgd2l0aFxuICAgICAgfCBTb21lIGF2IC0+IEl2YXIuZmlsbF9leG4gcmVzdWx0IChmYSBhdilcbiAgICAgIHwgTm9uZSAtPiBJdmFyLmZpbGxfZXhuIHJlc3VsdCAoZmIgKHZhbHVlX2V4biBiKSkpXG4gIGluXG4gIGxldCAoXyA6IF8pID0gTGF6eS5mb3JjZSBhX2hhbmRsZXIgaW5cbiAgbGV0IChfIDogXykgPSBMYXp5LmZvcmNlIGJfaGFuZGxlciBpblxuICBJdmFyLnJlYWQgcmVzdWx0XG47O1xuXG5sZXQgY2hvb3NlIGNob2ljZXMgPVxuICBtYXRjaCBjaG9pY2VzIHdpdGhcbiAgfCBbIENob2ljZS5UIChhLCBmYSk7IENob2ljZS5UIChiLCBmYikgXSAtPiBjaG9vc2UyIGEgZmEgYiBmYlxuICB8IGNob2ljZXMgLT4gZ2VuZXJpY19jaG9vc2UgY2hvaWNlc1xuOztcblxubGV0IGFueV9mIHRzIGYgPSBjaG9vc2UgKExpc3QubWFwIHRzIH5mOihmdW4gdCAtPiBjaG9pY2UgdCBmKSlcbmxldCBhbnkgdHMgPSBhbnlfZiB0cyBGbi5pZFxubGV0IGFueV91bml0IHRzID0gYW55X2YgdHMgKEZuLmlnbm9yZSA6IHVuaXQgLT4gdW5pdClcblxubGV0IGZvcl8gc3RhcnQgfnRvXyB+ZG9fID1cbiAgaWYgc3RhcnQgPiB0b19cbiAgdGhlbiByZXR1cm4gKClcbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgbGV0JWJpbmQgKCkgPSBkb18gaSBpblxuICAgICAgaWYgaSA+PSB0b18gdGhlbiByZXR1cm4gKCkgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3Agc3RhcnQpXG47O1xuXG5sZXQgcmVwZWF0X3VudGlsX2ZpbmlzaGVkIHN0YXRlIGYgPVxuICBjcmVhdGUgKGZ1biBmaW5pc2hlZCAtPlxuICAgIGxldCByZWMgbG9vcCBzdGF0ZSA9XG4gICAgICBmIHN0YXRlXG4gICAgICA+Pj4gZnVuY3Rpb25cbiAgICAgIHwgYFJlcGVhdCBzdGF0ZSAtPiBsb29wIHN0YXRlXG4gICAgICB8IGBGaW5pc2hlZCByZXN1bHQgLT4gSXZhci5maWxsX2V4biBmaW5pc2hlZCByZXN1bHRcbiAgICBpblxuICAgIGxvb3Agc3RhdGUpXG47O1xuXG5sZXQgZm9yZXZlciBzdGF0ZSBmID1cbiAgcmVwZWF0X3VudGlsX2ZpbmlzaGVkIHN0YXRlIChmdW4gc3RhdGUgLT5cbiAgICBsZXQlbWFwIHN0YXRlID0gZiBzdGF0ZSBpblxuICAgIGBSZXBlYXQgc3RhdGUpXG4gID4+PiBuZXZlcl9yZXR1cm5zXG47O1xuXG50eXBlIGhvdyA9IE1vbmFkX3NlcXVlbmNlLmhvdyBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5tb2R1bGUgdHlwZSBNb25hZF9zZXF1ZW5jZSA9IE1vbmFkX3NlcXVlbmNlLlMgd2l0aCB0eXBlICdhIG1vbmFkIDo9ICdhIHRcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgIGxldCByZWMgbG9vcCB0IGIgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IEl2YXIuZmlsbF9leG4gcmVzdWx0IGJcbiAgICAgIHwgeCA6OiB4cyAtPiBmIGIgeCA+Pj4gZnVuIGIgLT4gbG9vcCB4cyBiXG4gICAgaW5cbiAgICBsb29wIHQgaW5pdClcbjs7XG5cbmxldCBzZXFtYXAgdCB+ZiA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIGJzIGEgLT4gZiBhID4+fCBmdW4gYiAtPiBiIDo6IGJzKSA+PnwgTGlzdC5yZXZcbmxldCBhbGwgZHMgPSBzZXFtYXAgZHMgfmY6Rm4uaWRcbmxldCBhbGxfdW5pdCBkcyA9IGZvbGQgZHMgfmluaXQ6KCkgfmY6KGZ1biAoKSBkIC0+IGQpXG5sZXQgb2sgeCA9IHggPj58IGZ1biB4IC0+IE9rIHhcblxubW9kdWxlIEZvcl90ZXN0cyA9IHN0cnVjdFxuICBsZXQgZ2VuZXJpY19jaG9vc2UgPSBnZW5lcmljX2Nob29zZVxuZW5kXG4iLCJvcGVuIERlZmVycmVkMVxuaW5jbHVkZSBJbmZpeFxuaW5jbHVkZSBMZXRfc3ludGF4XG5cbmxldCBjaG9pY2UgPSBjaG9pY2VcbmxldCBjaG9vc2UgPSBjaG9vc2VcbmxldCBkb24ndF93YWl0X2ZvciA9IGRvbid0X3dhaXRfZm9yXG5sZXQgbmV2ZXIgPSBuZXZlclxubGV0IHJldHVybiA9IHJldHVyblxubGV0IHVwb24gPSB1cG9uXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxudHlwZSAnYSB1ID1cbiAgfCBFbXB0eSBvZiAnYSBJdmFyLnRcbiAgfCBGdWxsXG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG50eXBlICdhIHQgPSAnYSB1IHJlZiBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IF8gdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgbWF0Y2ggIXQgd2l0aFxuICAgIHwgRnVsbCAtPiAoKVxuICAgIHwgRW1wdHkgaXZhciAtPiBhc3NlcnQgKEl2YXIuaXNfZW1wdHkgaXZhcikpXG47O1xuXG5sZXQgY3JlYXRlICgpID1cbiAgbGV0IGl2YXIgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICBsZXQgdCA9IHJlZiAoRW1wdHkgaXZhcikgaW5cbiAgdCwgSXZhci5yZWFkIGl2YXJcbjs7XG5cbmxldCBpc19lbXB0eSB0ID1cbiAgbWF0Y2ggIXQgd2l0aFxuICB8IEVtcHR5IF8gLT4gdHJ1ZVxuICB8IEZ1bGwgLT4gZmFsc2Vcbjs7XG5cbmxldCBmaWxsIHQgYSA9XG4gIG1hdGNoICF0IHdpdGhcbiAgfCBFbXB0eSBpIC0+XG4gICAgdCA6PSBGdWxsO1xuICAgIEl2YXIuZmlsbF9leG4gaSBhXG4gIHwgRnVsbCAtPiByYWlzZV9zIFslbWVzc2FnZSBcImF0dGVtcHQgdG8gZmlsbCBmdWxsIGl2YXJcIl1cbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5tb2R1bGUgU3RyZWFtID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIG5leHQgRGVmZXJyZWQudFxuXG4gIGFuZCAnYSBuZXh0ID0gJ2EgVHlwZXMuU3RyZWFtLm5leHQgPVxuICAgIHwgTmlsXG4gICAgfCBDb25zIG9mICdhICogJ2EgdFxuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgIGxldCByZWMgbG9vcCBkIGFjIDogU2V4cC50ID1cbiAgICAgIG1hdGNoIERlZmVycmVkLnBlZWsgZCB3aXRoXG4gICAgICB8IE5vbmUgLT4gTGlzdCAoTGlzdC5yZXYgKFNleHAuQXRvbSBcIi4uLlwiIDo6IGFjKSlcbiAgICAgIHwgU29tZSBOaWwgLT4gTGlzdCAoTGlzdC5yZXYgYWMpXG4gICAgICB8IFNvbWUgKENvbnMgKGEsIHQpKSAtPiBsb29wIHQgKHNleHBfb2ZfYSBhIDo6IGFjKVxuICAgIGluXG4gICAgbG9vcCB0IFtdXG4gIDs7XG5cbiAgbGV0IG5leHQgdCA9IHRcbmVuZFxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5UYWlsLnQgPVxuICB7ICgqIFtuZXh0XSBwb2ludHMgYXQgdGhlIHRhaWwgb2YgdGhlIHN0cmVhbSAqKSBtdXRhYmxlIG5leHQgOiAnYSBTdHJlYW0ubmV4dCBJdmFyLnQgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzXVxuXG5sZXQgc2V4cF9vZl90IF8gdCA6IFNleHAudCA9XG4gIEF0b20gKGlmIEl2YXIuaXNfZW1wdHkgdC5uZXh0IHRoZW4gXCI8b3BlbiB0YWlsPlwiIGVsc2UgXCI8Y2xvc2VkIHRhaWw+XCIpXG47O1xuXG5sZXQgY3JlYXRlICgpID0geyBuZXh0ID0gSXZhci5jcmVhdGUgKCkgfVxubGV0IGNvbGxlY3QgdCA9IEl2YXIucmVhZCAobmV4dCB0KVxubGV0IGlzX2Nsb3NlZCB0ID0gSXZhci5pc19mdWxsIChuZXh0IHQpXG5cbmxldCBmaWxsX2V4biB0IHYgPVxuICBpZiBpc19jbG9zZWQgdCB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwic3RyZWFtIGlzIGNsb3NlZFwiXSBlbHNlIEl2YXIuZmlsbF9leG4gKG5leHQgdCkgdlxuOztcblxubGV0IGNsb3NlX2V4biB0ID0gZmlsbF9leG4gdCBOaWxcbmxldCBjbG9zZV9pZl9vcGVuIHQgPSBpZiBub3QgKGlzX2Nsb3NlZCB0KSB0aGVuIEl2YXIuZmlsbF9leG4gKG5leHQgdCkgTmlsXG5cbmxldCBleHRlbmQgdCB2ID1cbiAgbGV0IG5leHQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICBmaWxsX2V4biB0IChDb25zICh2LCBJdmFyLnJlYWQgbmV4dCkpO1xuICB0Lm5leHQgPC0gbmV4dFxuOztcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcbm1vZHVsZSBTY2hlZHVsZXIgPSBTY2hlZHVsZXIxXG5tb2R1bGUgU3RyZWFtID0gVGFpbC5TdHJlYW1cbm1vZHVsZSBNb25pdG9yID0gTW9uaXRvcjBcbmluY2x1ZGUgTW9uaXRvclxuXG50eXBlIG1vbml0b3IgPSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+bmFtZTppZ25vcmVcbiAgICAgIH5oZXJlOmlnbm9yZVxuICAgICAgfmlkOmlnbm9yZVxuICAgICAgfmZvcndhcmRpbmc6aWdub3JlXG4gICAgICB+bmV4dF9lcnJvcjooY2hlY2sgKGZ1biBuZXh0X2Vycm9yIC0+IGFzc2VydCAoSXZhci5pc19lbXB0eSBuZXh0X2Vycm9yKSkpXG4gICAgICB+aGFuZGxlcnNfZm9yX2FsbF9lcnJvcnM6aWdub3JlXG4gICAgICB+dGFpbHNfZm9yX2FsbF9lcnJvcnM6aWdub3JlXG4gICAgICB+aGFzX3NlZW5fZXJyb3I6aWdub3JlKVxuOztcblxubGV0IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKCkgPSBTY2hlZHVsZXIuKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpKVxubGV0IGN1cnJlbnQgKCkgPSBFeGVjdXRpb25fY29udGV4dC5tb25pdG9yIChjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICgpKVxubGV0IGRldGFjaCB0ID0gdC5mb3J3YXJkaW5nIDwtIERldGFjaGVkXG5cbnR5cGUgaGFuZGxlcl9zdGF0ZSA9XG4gIHwgVW5pbml0aWFsaXplZFxuICB8IFJ1bm5pbmcgb2YgKEV4ZWN1dGlvbl9jb250ZXh0LnQgKiAoZXhuIC0+IHVuaXQpKSBCYWcuRWx0LnRcbiAgfCBUZXJtaW5hdGVkXG5cbmxldCBkZXRhY2hfYW5kX2l0ZXJfZXJyb3JzIHQgfmYgPVxuICBkZXRhY2ggdDtcbiAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9IFNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHNjaGVkdWxlciBpblxuICBsZXQgaGFuZGxlcl9zdGF0ZV9yZWYgPSByZWYgVW5pbml0aWFsaXplZCBpblxuICBsZXQgcnVuX2YgZXhuID1cbiAgICBtYXRjaCAhaGFuZGxlcl9zdGF0ZV9yZWYgd2l0aFxuICAgIHwgVW5pbml0aWFsaXplZCAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IFRlcm1pbmF0ZWQgLT4gKClcbiAgICB8IFJ1bm5pbmcgYmFnX2VsdCAtPlxuICAgICAgKHRyeSBmIGV4biB3aXRoXG4gICAgICAgfCBpbm5lcl9leG4gLT5cbiAgICAgICAgIGhhbmRsZXJfc3RhdGVfcmVmIDo9IFRlcm1pbmF0ZWQ7XG4gICAgICAgICBCYWcucmVtb3ZlIHQuaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnMgYmFnX2VsdDtcbiAgICAgICAgICgqIFtydW5fZl0gYWx3YXlzIHJ1bnMgaW4gW2V4ZWN1dGlvbl9jb250ZXh0XS4gIEhlbmNlLCBbcmFpc2UgaW5uZXJfZXhuXSBzZW5kc1xuICAgICAgICAgICAgW2lubmVyX2V4bl0gdG8gW2V4ZWN1dGlvbl9jb250ZXh0XSdzIG1vbml0b3IsIGkuZS4gdGhlIG1vbml0b3IgaW4gZWZmZWN0IHdoZW5cbiAgICAgICAgICAgIFtkZXRhY2hfYW5kX2l0ZXJfZXJyb3JzXSB3YXMgY2FsbGVkLiAqKVxuICAgICAgICAgcmFpc2UgaW5uZXJfZXhuKVxuICBpblxuICBoYW5kbGVyX3N0YXRlX3JlZlxuICAgIDo9IFJ1bm5pbmcgKEJhZy5hZGQgdC5oYW5kbGVyc19mb3JfYWxsX2Vycm9ycyAoZXhlY3V0aW9uX2NvbnRleHQsIHJ1bl9mKSlcbjs7XG5cbmxldCBkZXRhY2hfYW5kX2dldF9lcnJvcl9zdHJlYW0gdCA9XG4gIGRldGFjaCB0O1xuICBsZXQgdGFpbCA9IFRhaWwuY3JlYXRlICgpIGluXG4gIHQudGFpbHNfZm9yX2FsbF9lcnJvcnMgPC0gdGFpbCA6OiB0LnRhaWxzX2Zvcl9hbGxfZXJyb3JzO1xuICBUYWlsLmNvbGxlY3QgdGFpbFxuOztcblxubGV0IGdldF9uZXh0X2Vycm9yIHQgPSBJdmFyLnJlYWQgdC5uZXh0X2Vycm9yXG5cbmxldCBkZXRhY2hfYW5kX2dldF9uZXh0X2Vycm9yIHQgPVxuICBkZXRhY2ggdDtcbiAgZ2V0X25leHRfZXJyb3IgdFxuOztcblxubGV0IGNyZWF0ZSA/aGVyZSA/aW5mbyA/bmFtZSAoKSA9XG4gIGxldCBwYXJlbnQgPSBjdXJyZW50ICgpIGluXG4gIGNyZWF0ZV93aXRoX3BhcmVudCA/aGVyZSA/aW5mbyA/bmFtZSAoU29tZSBwYXJlbnQpXG47O1xuXG5tb2R1bGUgTW9uaXRvcl9leG4gPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGV4biA6IGV4blxuICAgIDsgYmFja3RyYWNlIDogQmFja3RyYWNlLnQgb3B0aW9uXG4gICAgOyBiYWNrdHJhY2VfaGlzdG9yeSA6IEJhY2t0cmFjZS50IGxpc3RcbiAgICA7IG1vbml0b3IgOiBNb25pdG9yLnRcbiAgICB9XG5cbiAgbGV0IGJhY2t0cmFjZSB0ID0gdC5iYWNrdHJhY2VcbiAgbGV0IGV4dHJhY3RfZXhuIHQgPSB0LmV4blxuXG4gIGxldCBiYWNrdHJhY2VfdHJ1bmNhdGlvbl9oZXVyaXN0aWNzID1cbiAgICBsZXQgam9iX3F1ZXVlID0gXCJDYWxsZWQgZnJvbSBBc3luY19rZXJuZWxfX0pvYl9xdWV1ZVwiIGluXG4gICAgbGV0IGRlZmVycmVkMCA9IFwiQ2FsbGVkIGZyb20gQXN5bmNfa2VybmVsX19EZWZlcnJlZDBcIiBpblxuICAgIGxldCBkZWZlcnJlZDEgPSBcIkNhbGxlZCBmcm9tIEFzeW5jX2tlcm5lbF9fRGVmZXJyZWQxXCIgaW5cbiAgICBsZXQgbW9uaXRvciA9IFwiQ2FsbGVkIGZyb20gQXN5bmNfa2VybmVsX19Nb25pdG9yXCIgaW5cbiAgICBsZXQgdHJ5X3dpdGggPSBcIkNhbGxlZCBmcm9tIEJhc2VfX1Jlc3VsdC50cnlfd2l0aFwiIGluXG4gICAgbGV0IGVycm9yID0gXCJSYWlzZWQgYXQgQmFzZV9fRXJyb3IucmFpc2VcIiBpblxuICAgIGZ1biB0cmFjZXMgLT5cbiAgICAgICgqIC4uL3Rlc3QvdGVzdF90cnlfd2l0aF9lcnJvcl9kaXNwbGF5Lm1sIG1ha2VzIHN1cmUgdGhpcyBzdGF5cyB1cC10by1kYXRlLiAqKVxuICAgICAgbGV0IHN0cmlwX3ByZWZpeGVzIGxpbmVzIH5wcmVmaXhlcyA9XG4gICAgICAgIExpc3QuZHJvcF93aGlsZSBsaW5lcyB+ZjooZnVuIGxpbmUgLT5cbiAgICAgICAgICBMaXN0LmV4aXN0cyBwcmVmaXhlcyB+ZjooZnVuIHByZWZpeCAtPiBTdHJpbmcuaXNfcHJlZml4IGxpbmUgfnByZWZpeCkpXG4gICAgICBpblxuICAgICAgbGV0IHN0cmlwX3N1ZmZpeGVzIGlucHV0IH5zdWZmaXhlcyA9XG4gICAgICAgIGxldCByZXZfaW5wdXQgPSBMaXN0LnJldiBpbnB1dCBpblxuICAgICAgICBsZXQgcmV2X291dHB1dCA9IHN0cmlwX3ByZWZpeGVzIHJldl9pbnB1dCB+cHJlZml4ZXM6c3VmZml4ZXMgaW5cbiAgICAgICAgaWYgbm90IChwaHlzX2VxdWFsIHJldl9pbnB1dCByZXZfb3V0cHV0KSB0aGVuIExpc3QucmV2IHJldl9vdXRwdXQgZWxzZSBpbnB1dFxuICAgICAgaW5cbiAgICAgIHRyYWNlc1xuICAgICAgfD4gc3RyaXBfcHJlZml4ZXMgfnByZWZpeGVzOlsgZXJyb3IgXVxuICAgICAgfD4gc3RyaXBfc3VmZml4ZXMgfnN1ZmZpeGVzOlsgam9iX3F1ZXVlOyBkZWZlcnJlZDA7IGRlZmVycmVkMTsgbW9uaXRvcjsgdHJ5X3dpdGggXVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgeyBleG47IGJhY2t0cmFjZTsgYmFja3RyYWNlX2hpc3Rvcnk7IG1vbml0b3IgfSA9XG4gICAgbGV0IG1vbml0b3IgPVxuICAgICAgbGV0IG5hbWUgPVxuICAgICAgICBtYXRjaCBJbmZvLnRvX3N0cmluZ19odW0gbW9uaXRvci5uYW1lIHdpdGhcbiAgICAgICAgfCBcIlwiIC0+IE5vbmVcbiAgICAgICAgfCBzIC0+IFNvbWUgc1xuICAgICAgaW5cbiAgICAgIGxldCBwb3MgPVxuICAgICAgICBtYXRjaCBtb25pdG9yLmhlcmUgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgaGVyZSAtPlxuICAgICAgICAgICgqIFdlIGRpc3BsYXkgdGhlIGZ1bGwgZmlsZW5hbWUsIHdoZXJlYXMgYmFja3RyYWNlcyBvbmx5IGhhdmUgYmFzZW5hbWVzLCBidXRcbiAgICAgICAgICAgICBwZXJoYXBzIHRoYXQncyB3aGF0IHNob3VsZCBjaGFuZ2UuICopXG4gICAgICAgICAgbGV0IGNvbHVtbiA9IGhlcmUucG9zX2NudW0gLSBoZXJlLnBvc19ib2wgaW5cbiAgICAgICAgICBTb21lXG4gICAgICAgICAgICAoKiBXZSBoaWRlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzIHdoZW4gW2FtX3J1bm5pbmdfdGVzdF0gdG8gbWFrZSB0ZXN0IG91dHB1dFxuICAgICAgICAgICAgICAgbW9yZSByb2J1c3QuICBUaGlzIHNhdmVzIHBlb3BsZSBtYW51YWxseSBoaWRpbmcgdGhlIG51bWJlcnMgb3IgZXZlbiB3b3JzZSxcbiAgICAgICAgICAgICAgIGxlYXZpbmcgdGhlbSBpbiB0ZXN0IG91dHB1dC4gIEhpZGluZyBpbiB0ZXN0IGlzIGRpZmZlcmVudCBjaG9pY2UgZm9yXG4gICAgICAgICAgICAgICBiZWhhdmlvciB0aGFuIG91ciBjb2RlYmFzZSBtYWtlcyBmb3IgW0JhY2t0cmFjZS5lbGlkZV0sIHdoaWNoIGhhcyBkZWZhdWx0XG4gICAgICAgICAgICAgICBbZmFsc2VdLCBhbmQgdGh1cyBzaG93cyBiYWNrdHJhY2VzIGluIHRlc3QuICBUaGVyZSBhcmUgYSBjb3VwbGUgcmVhc29ucyBmb3JcbiAgICAgICAgICAgICAgIHRoaXMgZGlmZmVyZW50IGNob2ljZS4gIEZpcnN0LCBleHBlY3QtdGVzdCBtYWNoaW5lcnkgaGFzIGNoZWNrIHRvIHByZXZlbnRcbiAgICAgICAgICAgICAgIGJhY2t0cmFjZXMgZnJvbSBhcHBlYXJpbmcgaW4gdGVzdCBvdXRwdXQuICBJdCBoYXMgbm8gc3VjaCBjaGVja3MgZm9yIGxpbmVcbiAgICAgICAgICAgICAgIGFuZCBjb2x1bW4gbnVtYmVycy4gIFNlY29uZCwgd2hlbiB0aGVyZSBpcyBhIHJlYWwgZXJyb3IgYW5kIHlvdSB3YW50IHRvIHNlZVxuICAgICAgICAgICAgICAgdGhlIGJhY2t0cmFjZSwgdGhyb3dpbmcgYXdheSB0aGUgd2hvbGUgYmFja3RyYWNlIGxvc2VzIGEgbG90IG9mIHBvdGVudGlhbGx5XG4gICAgICAgICAgICAgICB1c2VmdWwgaW5mb3JtYXRpb24gdGhhdCBtYXkgYmUgaGFyZCB0byByZWNvdmVyLiAgV2hlcmVhcyB3ZSdyZSBqdXN0XG4gICAgICAgICAgICAgICB0aHJvd2luZyBhIHdheSBhIGxpbmUgbnVtYmVyIGFuZCBjb2x1bW4sIHdoaWNoIGFyZSBhIG1pbm9yIGNvbnZlbmllbmNlXG4gICAgICAgICAgICAgICBnaXZlbiB0aGF0IHRoZSBmaWxlbmFtZSBoYXMgbW9zdCBvZiB0aGUgaW5mb3JtYXRpb24uICopXG4gICAgICAgICAgICAoaWYgYW1fcnVubmluZ190ZXN0XG4gICAgICAgICAgICAgdGhlbiBzcHJpbnRmIFwiZmlsZSAlUywgbGluZSBMSU5FLCBjaGFyYWN0ZXJzIEMxLUMyXCIgaGVyZS5wb3NfZm5hbWVcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICBzcHJpbnRmXG4gICAgICAgICAgICAgICAgIFwiZmlsZSAlUywgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZFwiXG4gICAgICAgICAgICAgICAgIGhlcmUucG9zX2ZuYW1lXG4gICAgICAgICAgICAgICAgIGhlcmUucG9zX2xudW1cbiAgICAgICAgICAgICAgICAgY29sdW1uXG4gICAgICAgICAgICAgICAgIGNvbHVtbilcbiAgICAgIGluXG4gICAgICBtYXRjaCBwb3MsIG5hbWUgd2l0aFxuICAgICAgfCBOb25lLCBOb25lIC0+IFtdXG4gICAgICB8IFNvbWUgcG9zLCBOb25lIC0+IFsgc3ByaW50ZiBcIkNhdWdodCBieSBtb25pdG9yIGF0ICVzXCIgcG9zIF1cbiAgICAgIHwgTm9uZSwgU29tZSBuYW1lIC0+IFsgc3ByaW50ZiBcIkNhdWdodCBieSBtb25pdG9yICVzXCIgbmFtZSBdXG4gICAgICB8IFNvbWUgcG9zLCBTb21lIG5hbWUgLT4gWyBzcHJpbnRmIFwiQ2F1Z2h0IGJ5IG1vbml0b3IgJXMgYXQgJXNcIiBuYW1lIHBvcyBdXG4gICAgaW5cbiAgICBsZXQgYmFja3RyYWNlID1cbiAgICAgIGxldCBiYWNrdHJhY2UgPVxuICAgICAgICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgfCBTb21lIGJhY2t0cmFjZSAtPiBCYWNrdHJhY2UudG9fc3RyaW5nX2xpc3QgYmFja3RyYWNlXG4gICAgICBpblxuICAgICAgYmFja3RyYWNlX3RydW5jYXRpb25faGV1cmlzdGljcyBiYWNrdHJhY2UgQCBtb25pdG9yXG4gICAgaW5cbiAgICBsZXQgbGlzdF9pZl9ub3RfZW1wdHkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBOb25lXG4gICAgICB8IF8gOjogXyBhcyBsIC0+IFNvbWUgbFxuICAgIGluXG4gICAgWyVzZXhwXG4gICAgICAoZXhuIDogZXhuKVxuICAgICAgLCAobGlzdF9pZl9ub3RfZW1wdHkgYmFja3RyYWNlIDogKHN0cmluZyBsaXN0IG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAgICwgYGJhY2t0cmFjZV9oaXN0b3J5XG4gICAgICAgICAgKGxpc3RfaWZfbm90X2VtcHR5IGJhY2t0cmFjZV9oaXN0b3J5IDogKEJhY2t0cmFjZS50IGxpc3Qgb3B0aW9uW0BzZXhwLm9wdGlvbl0pKV1cbiAgOztcbmVuZFxuXG5leGNlcHRpb24gTW9uaXRvcl9leG4gb2YgTW9uaXRvcl9leG4udFxuXG5sZXQgKCkgPVxuICBTZXhwbGliLkNvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgTW9uaXRvcl9leG5dIChmdW5jdGlvblxuICAgIHwgTW9uaXRvcl9leG4gdCAtPiBbJXNleHAgXCJtb25pdG9yLm1sLkVycm9yXCIgOjogKHQgOiBNb25pdG9yX2V4bi50KV1cbiAgICB8IF8gLT5cbiAgICAgICgqIFJlYWNoaW5nIHRoaXMgYnJhbmNoIGluZGljYXRlcyBhIGJ1ZyBpbiBzZXhwbGliLiAqKVxuICAgICAgYXNzZXJ0IGZhbHNlKVxuOztcblxubGV0IGV4dHJhY3RfZXhuIGV4biA9XG4gIG1hdGNoIGV4biB3aXRoXG4gIHwgTW9uaXRvcl9leG4gZXJyb3IgLT4gZXJyb3IuZXhuXG4gIHwgZXhuIC0+IGV4blxuOztcblxubGV0IHNlbmRfZXhuIHQgPyhiYWNrdHJhY2UgPSBgR2V0KSBleG4gPVxuICBsZXQgZXhuID1cbiAgICBtYXRjaCBleG4gd2l0aFxuICAgIHwgTW9uaXRvcl9leG4gXyAtPiBleG5cbiAgICB8IF8gLT5cbiAgICAgIGxldCBiYWNrdHJhY2UgPVxuICAgICAgICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICAgICAgICB8IGBHZXQgLT4gQmFja3RyYWNlLkV4bi5tb3N0X3JlY2VudF9mb3JfZXhuIGV4blxuICAgICAgICB8IGBUaGlzIGIgLT4gU29tZSBiXG4gICAgICBpblxuICAgICAgbGV0IGJhY2t0cmFjZV9oaXN0b3J5ID0gKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKCkpLmJhY2t0cmFjZV9oaXN0b3J5IGluXG4gICAgICBNb25pdG9yX2V4biB7IE1vbml0b3JfZXhuLmV4bjsgYmFja3RyYWNlOyBiYWNrdHJhY2VfaGlzdG9yeTsgbW9uaXRvciA9IHQgfVxuICBpblxuICBpZiBEZWJ1Zy5tb25pdG9yX3NlbmRfZXhuIHRoZW4gRGVidWcubG9nIFwiTW9uaXRvci5zZW5kX2V4blwiICh0LCBleG4pIFslc2V4cF9vZjogdCAqIGV4bl07XG4gIGxldCBzY2hlZHVsZXIgPSBTY2hlZHVsZXIudCAoKSBpblxuICBsZXQgcmVjIGxvb3AgdCA9XG4gICAgdC5oYXNfc2Vlbl9lcnJvciA8LSB0cnVlO1xuICAgIEl2YXIuZmlsbF9leG4gdC5uZXh0X2Vycm9yIGV4bjtcbiAgICB0Lm5leHRfZXJyb3IgPC0gSXZhci5jcmVhdGUgKCk7XG4gICAgbWF0Y2ggdC5mb3J3YXJkaW5nIHdpdGhcbiAgICB8IERldGFjaGVkIC0+XG4gICAgICBpZiBEZWJ1Zy5tb25pdG9yX3NlbmRfZXhuXG4gICAgICB0aGVuXG4gICAgICAgIERlYnVnLmxvZyBcIk1vbml0b3Iuc2VuZF9leG4gZm91bmQgbGlzdGVuaW5nIG1vbml0b3JcIiAodCwgZXhuKSBbJXNleHBfb2Y6IHQgKiBleG5dO1xuICAgICAgQmFnLml0ZXIgdC5oYW5kbGVyc19mb3JfYWxsX2Vycm9ycyB+ZjooZnVuIChleGVjdXRpb25fY29udGV4dCwgZikgLT5cbiAgICAgICAgU2NoZWR1bGVyLmVucXVldWUgc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0IGYgZXhuKTtcbiAgICAgIExpc3QuaXRlciB0LnRhaWxzX2Zvcl9hbGxfZXJyb3JzIH5mOihmdW4gdGFpbCAtPiBUYWlsLmV4dGVuZCB0YWlsIGV4bilcbiAgICB8IFBhcmVudCBwYXJlbnQgLT4gbG9vcCBwYXJlbnRcbiAgICB8IFJlcG9ydF91bmNhdWdodF9leG4gLT5cbiAgICAgICgqIERvIG5vdCBjaGFuZ2UgdGhpcyBicmFuY2ggdG8gcHJpbnQgdGhlIGV4Y2VwdGlvbiBvciB0byBleGl0LiAgSGF2aW5nIHRoZVxuICAgICAgICAgc2NoZWR1bGVyIHJhaXNlIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbiBpcyB0aGUgbmVjZXNzYXJ5IGJlaGF2aW9yIGZvciBwcm9ncmFtc1xuICAgICAgICAgdGhhdCBjYWxsIFtTY2hlZHVsZXIuZ29dIGFuZCB3YW50IHRvIGhhbmRsZSBpdC4gKilcbiAgICAgIFNjaGVkdWxlci4oZ290X3VuY2F1Z2h0X2V4biAodCAoKSkpIGV4biAoIUFzeW5jX2tlcm5lbF9jb25maWcudGFza19pZCAoKSlcbiAgaW5cbiAgbG9vcCB0XG47O1xuXG5tb2R1bGUgRXhwb3J0ZWRfZm9yX3NjaGVkdWxlciA9IHN0cnVjdFxuICBsZXQgd2l0aGluX2NvbnRleHQgY29udGV4dCBmID1cbiAgICBTY2hlZHVsZXIuKHdpdGhfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpKSBjb250ZXh0IH5mOihmdW4gKCkgLT5cbiAgICAgIG1hdGNoIFJlc3VsdC50cnlfd2l0aCBmIHdpdGhcbiAgICAgIHwgT2sgeCAtPiBPayB4XG4gICAgICB8IEVycm9yIGV4biAtPlxuICAgICAgICBzZW5kX2V4biAoRXhlY3V0aW9uX2NvbnRleHQubW9uaXRvciBjb250ZXh0KSBleG4gfmJhY2t0cmFjZTpgR2V0O1xuICAgICAgICBFcnJvciAoKSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCB3aXRoaW5fZ2VuID9tb25pdG9yID9wcmlvcml0eSBmID1cbiAgICBsZXQgdG1wX2NvbnRleHQgPVxuICAgICAgRXhlY3V0aW9uX2NvbnRleHQuY3JlYXRlX2xpa2UgKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKCkpID9tb25pdG9yID9wcmlvcml0eVxuICAgIGluXG4gICAgd2l0aGluX2NvbnRleHQgdG1wX2NvbnRleHQgZlxuICA7O1xuXG4gIGxldCB3aXRoaW4nID9tb25pdG9yID9wcmlvcml0eSBmID1cbiAgICBtYXRjaCB3aXRoaW5fZ2VuID9tb25pdG9yID9wcmlvcml0eSBmIHdpdGhcbiAgICB8IEVycm9yICgpIC0+IERlZmVycmVkLm5ldmVyICgpXG4gICAgfCBPayBkIC0+IGRcbiAgOztcblxuICBsZXQgd2l0aGluX3YgP21vbml0b3IgP3ByaW9yaXR5IGYgPVxuICAgIG1hdGNoIHdpdGhpbl9nZW4gP21vbml0b3IgP3ByaW9yaXR5IGYgd2l0aFxuICAgIHwgRXJyb3IgKCkgLT4gTm9uZVxuICAgIHwgT2sgeCAtPiBTb21lIHhcbiAgOztcblxuICBsZXQgd2l0aGluID9tb25pdG9yID9wcmlvcml0eSBmID1cbiAgICBtYXRjaCB3aXRoaW5fZ2VuID9tb25pdG9yID9wcmlvcml0eSBmIHdpdGhcbiAgICB8IEVycm9yICgpIC0+ICgpXG4gICAgfCBPayAoKSAtPiAoKVxuICA7O1xuXG4gIGxldCBzY2hlZHVsZV93aXRoX2RhdGEgP21vbml0b3IgP3ByaW9yaXR5IHdvcmsgeCA9XG4gICAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gICAgU2NoZWR1bGVyLmVucXVldWVcbiAgICAgIHNjaGVkdWxlclxuICAgICAgKEV4ZWN1dGlvbl9jb250ZXh0LmNyZWF0ZV9saWtlXG4gICAgICAgICAoU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyKVxuICAgICAgICAgP21vbml0b3JcbiAgICAgICAgID9wcmlvcml0eSlcbiAgICAgIHdvcmtcbiAgICAgIHhcbiAgOztcblxuICBsZXQgc2NoZWR1bGUgP21vbml0b3IgP3ByaW9yaXR5IHdvcmsgPSBzY2hlZHVsZV93aXRoX2RhdGEgP21vbml0b3IgP3ByaW9yaXR5IHdvcmsgKClcblxuICBsZXQgc2NoZWR1bGUnID1cbiAgICAoKiBGb3IgcGVyZm9ybWFuY2UsIHdlIHVzZSBbc2NoZWR1bGVfd2l0aF9kYXRhXSB3aXRoIGEgY2xvc2VkIGZ1bmN0aW9uLCBhbmQgaW5saW5lXG4gICAgICAgW0RlZmVycmVkLmNyZWF0ZV0uICopXG4gICAgbGV0IHVwb25fd29ya19maWxsX2kgKHdvcmssIGkpID0gdXBvbiAod29yayAoKSkgKGZ1biBhIC0+IEl2YXIuZmlsbF9leG4gaSBhKSBpblxuICAgIGZ1biA/bW9uaXRvciA/cHJpb3JpdHkgd29yayAtPlxuICAgICAgbGV0IGkgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICAgICAgc2NoZWR1bGVfd2l0aF9kYXRhID9tb25pdG9yID9wcmlvcml0eSB1cG9uX3dvcmtfZmlsbF9pICh3b3JrLCBpKTtcbiAgICAgIEl2YXIucmVhZCBpXG4gIDs7XG5cbiAgbGV0IHByZXNlcnZlX2V4ZWN1dGlvbl9jb250ZXh0IGYgPVxuICAgIGxldCBzY2hlZHVsZXIgPSBTY2hlZHVsZXIudCAoKSBpblxuICAgIGxldCBleGVjdXRpb25fY29udGV4dCA9IFNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHNjaGVkdWxlciBpblxuICAgIHN0YWdlIChmdW4gYSAtPiBTY2hlZHVsZXIuZW5xdWV1ZSBzY2hlZHVsZXIgZXhlY3V0aW9uX2NvbnRleHQgZiBhKVxuICA7O1xuXG4gIGxldCBwcmVzZXJ2ZV9leGVjdXRpb25fY29udGV4dCcgZiA9XG4gICAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gICAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyIGluXG4gICAgbGV0IGNhbGxfYW5kX2ZpbGwgKGYsIGEsIGkpID0gdXBvbiAoZiBhKSAoZnVuIHIgLT4gSXZhci5maWxsX2V4biBpIHIpIGluXG4gICAgc3RhZ2UgKGZ1biBhIC0+XG4gICAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpIC0+XG4gICAgICAgIFNjaGVkdWxlci5lbnF1ZXVlIHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBjYWxsX2FuZF9maWxsIChmLCBhLCBpKSkpXG4gIDs7XG5lbmRcblxub3BlbiBFeHBvcnRlZF9mb3Jfc2NoZWR1bGVyXG5cbmxldCBzdHJlYW1faXRlciBzdHJlYW0gfmYgPVxuICBsZXQgcmVjIGxvb3Agc3RyZWFtID1cbiAgICBTdHJlYW0ubmV4dCBzdHJlYW1cbiAgICA+Pj4gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyAodiwgc3RyZWFtKSAtPlxuICAgICAgbG9vcCBzdHJlYW07XG4gICAgICBmIHZcbiAgaW5cbiAgbG9vcCBzdHJlYW1cbjs7XG5cbigqIEFuIFsnYSBPa19hbmRfZXhucy50XSByZXByZXNlbnRzIHRoZSBvdXRwdXQgb2YgYSBjb21wdXRhdGlvbiBydW5uaW5nIGluIGEgZGV0YWNoZWRcbiAgIG1vbml0b3IuICopXG5tb2R1bGUgT2tfYW5kX2V4bnMgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB7IG9rIDogJ2EgRGVmZXJyZWQudFxuICAgIDsgZXhucyA6IGV4biBTdHJlYW0udFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgY3JlYXRlID9oZXJlID9pbmZvID9uYW1lIH5ydW4gZiA9XG4gICAgKCogV2UgY2FsbCBbY3JlYXRlX3dpdGhfcGFyZW50IE5vbmVdIGJlY2F1c2UgW21vbml0b3JdIGRvZXMgbm90IG5lZWQgYSBwYXJlbnQuICBJdFxuICAgICAgIGRvZXMgbm90IGJlY2F1c2Ugd2UgY2FsbCBbZGV0YWNoX2FuZF9nZXRfZXJyb3Jfc3RyZWFtIG1vbml0b3JdIGFuZCBkZWFsIHdpdGggdGhlXG4gICAgICAgZXJyb3JzIGV4cGxpY2l0bHksIHRodXMgW3NlbmRfZXhuXSB3b3VsZCBuZXZlciBwcm9wYWdhdGUgYW4gZXhuIHBhc3QgW21vbml0b3JdLiAqKVxuICAgIGxldCBtb25pdG9yID0gY3JlYXRlX3dpdGhfcGFyZW50ID9oZXJlID9pbmZvID9uYW1lIE5vbmUgaW5cbiAgICBsZXQgZXhucyA9IGRldGFjaF9hbmRfZ2V0X2Vycm9yX3N0cmVhbSBtb25pdG9yIGluXG4gICAgbGV0IG9rID1cbiAgICAgIG1hdGNoIHJ1biB3aXRoXG4gICAgICB8IGBOb3cgLT4gd2l0aGluJyB+bW9uaXRvciBmXG4gICAgICB8IGBTY2hlZHVsZSAtPiBzY2hlZHVsZScgfm1vbml0b3IgZlxuICAgIGluXG4gICAgeyBvazsgZXhucyB9XG4gIDs7XG5lbmRcblxubGV0IGZpbGxfcmVzdWx0X2FuZF9oYW5kbGVfYmFja2dyb3VuZF9lcnJvcnNcbiAgcmVzdWx0X2ZpbGxlclxuICByZXN1bHRcbiAgZXhuc1xuICBoYW5kbGVfZXhuc19hZnRlcl9yZXN1bHRcbiAgPVxuICBpZiBJdmFyX2ZpbGxlci5pc19lbXB0eSByZXN1bHRfZmlsbGVyXG4gIHRoZW4gKFxuICAgIEl2YXJfZmlsbGVyLmZpbGwgcmVzdWx0X2ZpbGxlciByZXN1bHQ7XG4gICAgaGFuZGxlX2V4bnNfYWZ0ZXJfcmVzdWx0IGV4bnMpXG47O1xuXG5tb2R1bGUgRXhwZXJ0ID0gc3RydWN0XG4gIGxldCB0cnlfd2l0aF9sb2dfZXhuIDogKGV4biAtPiB1bml0KSByZWYgPVxuICAgIHJlZiAoZnVuIGV4biAtPlxuICAgICAgcmFpc2VfcyBbJW1lc3NhZ2UgXCJmYWlsZWQgdG8gc2V0IFtNb25pdG9yLkV4cGVydC50cnlfd2l0aF9sb2dfZXhuXVwiIChleG4gOiBFeG4udCldKVxuICA7O1xuZW5kXG5cbmxldCBtYWtlX2hhbmRsZV9leG4gcmVzdCA9XG4gIG1hdGNoIHJlc3Qgd2l0aFxuICB8IGBMb2cgLT5cbiAgICAoKiBXZSBhcmUgY2FyZWZ1bCB0byBub3QgY2xvc2Ugb3ZlciBjdXJyZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCBuZWVkZWQuICopXG4gICAgIUV4cGVydC50cnlfd2l0aF9sb2dfZXhuXG4gIHwgYFJhaXNlIC0+XG4gICAgbGV0IHBhcmVudCA9IGN1cnJlbnQgKCkgaW5cbiAgICBmdW4gZXhuIC0+IHNlbmRfZXhuIHBhcmVudCBleG4gfmJhY2t0cmFjZTpgR2V0XG4gIHwgYENhbGwgZiAtPlxuICAgIGxldCBwYXJlbnQgPSBjdXJyZW50ICgpIGluXG4gICAgZnVuIGV4biAtPiB3aXRoaW4gfm1vbml0b3I6cGFyZW50IChmdW4gKCkgLT4gZiBleG4pXG47O1xuXG5sZXQgdHJ5X3dpdGhcbiAgP2hlcmVcbiAgP2luZm9cbiAgPyhuYW1lID0gXCJcIilcbiAgP2V4dHJhY3RfZXhuOihkb19leHRyYWN0X2V4biA9IGZhbHNlKVxuICA/KHJ1biA9IGBOb3cpXG4gID8ocmVzdCA9IGBSYWlzZSlcbiAgZlxuICA9XG4gIGxldCB7IE9rX2FuZF9leG5zLm9rOyBleG5zIH0gPSBPa19hbmRfZXhucy5jcmVhdGUgP2hlcmUgP2luZm8gfm5hbWUgfnJ1biBmIGluXG4gIGxldCBoYW5kbGVfZXhuID0gbWFrZV9oYW5kbGVfZXhuIHJlc3QgaW5cbiAgbGV0IGhhbmRsZV9leG5zX2FmdGVyX3Jlc3VsdCBleG5zID0gc3RyZWFtX2l0ZXIgZXhucyB+ZjpoYW5kbGVfZXhuIGluXG4gICgqIFdlIHJ1biBbd2l0aGluJyB+bW9uaXRvcjptYWluXSB0byBhdm9pZCBob2xkaW5nIG9uIHRvIHJlZmVyZW5jZXMgdG8gdGhlIGV2YWx1YXRpb25cbiAgICAgY29udGV4dCBpbiB3aGljaCBbdHJ5X3dpdGhdIHdhcyBjYWxsZWQuICBUaGlzIGF2b2lkcyBhIHNwYWNlIGxlYWsgd2hlbiBhIGNoYWluIG9mXG4gICAgIFt0cnlfd2l0aF0ncyBhcmUgcnVuIGVhY2ggbmVzdGVkIHdpdGhpbiB0aGUgcHJldmlvdXMgb25lLiAgV2l0aG91dCB0aGUgW3dpdGhpbiddLCB0aGVcbiAgICAgZXJyb3IgaGFuZGxpbmcgZm9yIHRoZSBpbm5lcm1vc3QgW3RyeV93aXRoXSB3b3VsZCBrZWVwIGFsaXZlIHRoZSBlbnRpcmUgY2hhaW4uICopXG4gIHdpdGhpbicgfm1vbml0b3I6bWFpbiAoZnVuICgpIC0+XG4gICAgaWYgRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCBva1xuICAgIHRoZW4gKFxuICAgICAgaGFuZGxlX2V4bnNfYWZ0ZXJfcmVzdWx0IGV4bnM7XG4gICAgICByZXR1cm4gKE9rIChEZWZlcnJlZC52YWx1ZV9leG4gb2spKSlcbiAgICBlbHNlIChcbiAgICAgIGxldCByZXN1bHRfZmlsbGVyLCByZXN1bHQgPSBJdmFyX2ZpbGxlci5jcmVhdGUgKCkgaW5cbiAgICAgIHVwb24gb2sgKGZ1biByZXMgLT5cbiAgICAgICAgZmlsbF9yZXN1bHRfYW5kX2hhbmRsZV9iYWNrZ3JvdW5kX2Vycm9yc1xuICAgICAgICAgIHJlc3VsdF9maWxsZXJcbiAgICAgICAgICAoT2sgcmVzKVxuICAgICAgICAgIGV4bnNcbiAgICAgICAgICBoYW5kbGVfZXhuc19hZnRlcl9yZXN1bHQpO1xuICAgICAgdXBvbiAoU3RyZWFtLm5leHQgZXhucykgKGZ1bmN0aW9uXG4gICAgICAgIHwgTmlsIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICB8IENvbnMgKGV4biwgZXhucykgLT5cbiAgICAgICAgICBsZXQgZXhuID0gaWYgZG9fZXh0cmFjdF9leG4gdGhlbiBleHRyYWN0X2V4biBleG4gZWxzZSBleG4gaW5cbiAgICAgICAgICBmaWxsX3Jlc3VsdF9hbmRfaGFuZGxlX2JhY2tncm91bmRfZXJyb3JzXG4gICAgICAgICAgICByZXN1bHRfZmlsbGVyXG4gICAgICAgICAgICAoRXJyb3IgZXhuKVxuICAgICAgICAgICAgZXhuc1xuICAgICAgICAgICAgaGFuZGxlX2V4bnNfYWZ0ZXJfcmVzdWx0KTtcbiAgICAgIHJlc3VsdCkpXG47O1xuXG5sZXQgdHJ5X3dpdGhfb3JfZXJyb3IgP2hlcmUgP2luZm8gPyhuYW1lID0gXCJ0cnlfd2l0aF9vcl9lcnJvclwiKSA/ZXh0cmFjdF9leG4gP3Jlc3QgZiA9XG4gIHRyeV93aXRoIGYgP2hlcmUgP2luZm8gfm5hbWUgP2V4dHJhY3RfZXhuIH5ydW46YE5vdyA/cmVzdCA+PnwgT3JfZXJyb3Iub2ZfZXhuX3Jlc3VsdFxuOztcblxubGV0IHRyeV93aXRoX2pvaW5fb3JfZXJyb3JcbiAgP2hlcmVcbiAgP2luZm9cbiAgPyhuYW1lID0gXCJ0cnlfd2l0aF9qb2luX29yX2Vycm9yXCIpXG4gID9leHRyYWN0X2V4blxuICA/cmVzdFxuICBmXG4gID1cbiAgdHJ5X3dpdGhfb3JfZXJyb3IgZiA/aGVyZSA/aW5mbyB+bmFtZSA/ZXh0cmFjdF9leG4gP3Jlc3QgPj58IE9yX2Vycm9yLmpvaW5cbjs7XG5cbmxldCBwcm90ZWN0ID9oZXJlID9pbmZvID8obmFtZSA9IFwiTW9uaXRvci5wcm90ZWN0XCIpID9leHRyYWN0X2V4biA/cnVuID9yZXN0IGYgfmZpbmFsbHkgPVxuICBsZXQlYmluZCByID0gdHJ5X3dpdGggP2V4dHJhY3RfZXhuID9oZXJlID9pbmZvID9ydW4gP3Jlc3Qgfm5hbWUgZiBpblxuICBsZXQlbWFwIGZyID1cbiAgICB0cnlfd2l0aFxuICAgICAgfmV4dHJhY3RfZXhuOmZhbHNlXG4gICAgICA/aGVyZVxuICAgICAgP2luZm9cbiAgICAgIH5ydW46YFNjaGVkdWxlICgqIGNvbnNpZGVyIFt+cnVuOmBOb3ddICopXG4gICAgICA/cmVzdFxuICAgICAgfm5hbWU6XCJmaW5hbGx5XCJcbiAgICAgIGZpbmFsbHlcbiAgaW5cbiAgbWF0Y2ggciwgZnIgd2l0aFxuICB8IEVycm9yIGV4biwgRXJyb3IgZmluYWxseV9leG4gLT5cbiAgICByYWlzZV9zIFslbWVzc2FnZSBcIkFzeW5jIGZpbmFsbHlcIiAoZXhuIDogZXhuKSAoZmluYWxseV9leG4gOiBleG4pXVxuICB8IEVycm9yIGUsIE9rICgpIHwgT2sgXywgRXJyb3IgZSAtPiByYWlzZSBlXG4gIHwgT2sgciwgT2sgKCkgLT4gclxuOztcblxubGV0IGhhbmRsZV9lcnJvcnMgP2hlcmUgP2luZm8gP25hbWUgZiBoYW5kbGVyID1cbiAgbGV0IHsgT2tfYW5kX2V4bnMub2s7IGV4bnMgfSA9IE9rX2FuZF9leG5zLmNyZWF0ZSA/aGVyZSA/aW5mbyA/bmFtZSB+cnVuOmBOb3cgZiBpblxuICBzdHJlYW1faXRlciBleG5zIH5mOmhhbmRsZXI7XG4gIG9rXG47O1xuXG5sZXQgY2F0Y2hfc3RyZWFtID9oZXJlID9pbmZvID9uYW1lIGYgPVxuICBsZXQgeyBPa19hbmRfZXhucy5leG5zOyBfIH0gPVxuICAgIE9rX2FuZF9leG5zLmNyZWF0ZSA/aGVyZSA/aW5mbyA/bmFtZSB+cnVuOmBOb3cgKGZ1biAoKSAtPlxuICAgICAgZiAoKTtcbiAgICAgIHJldHVybiAoKSlcbiAgaW5cbiAgZXhuc1xuOztcblxubGV0IGNhdGNoID9oZXJlID9pbmZvID9uYW1lIGYgPVxuICBtYXRjaCVtYXAgU3RyZWFtLm5leHQgKGNhdGNoX3N0cmVhbSA/aGVyZSA/aW5mbyA/bmFtZSBmKSB3aXRoXG4gIHwgQ29ucyAoeCwgXykgLT4geFxuICB8IE5pbCAtPiByYWlzZV9zIFslbWVzc2FnZSBcIk1vbml0b3IuY2F0Y2ggZ290IHVuZXhwZWN0ZWQgZW1wdHkgc3RyZWFtXCJdXG47O1xuXG5sZXQgY2F0Y2hfZXJyb3IgP2hlcmUgP2luZm8gP25hbWUgZiA9IGNhdGNoID9oZXJlID9pbmZvID9uYW1lIGYgPj58IEVycm9yLm9mX2V4blxuXG5tb2R1bGUgRm9yX3Rlc3RzID0gc3RydWN0XG4gIGxldCBwYXJlbnQgdCA9XG4gICAgbWF0Y2ggdC5mb3J3YXJkaW5nIHdpdGhcbiAgICB8IFJlcG9ydF91bmNhdWdodF9leG4gLT4gTm9uZVxuICAgIHwgUGFyZW50IHBhcmVudCAtPiBTb21lIHBhcmVudFxuICAgIHwgRGV0YWNoZWQgLT4gTm9uZVxuICA7O1xuXG4gIGxldCBkZXB0aCB0ID1cbiAgICBsZXQgcmVjIGxvb3AgdCBuID1cbiAgICAgIG1hdGNoIHBhcmVudCB0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBuXG4gICAgICB8IFNvbWUgdCAtPiBsb29wIHQgKG4gKyAxKVxuICAgIGluXG4gICAgbG9vcCB0IDBcbiAgOztcbmVuZFxuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5pbmNsdWRlIFRhaWwuU3RyZWFtXG5cbmxldCBmaXJzdF9leG4gdCA9XG4gIG1hdGNoJW1hcCBuZXh0IHQgd2l0aFxuICB8IE5pbCAtPiByYWlzZV9zIFslbWVzc2FnZSBcIlN0cmVhbS5maXJzdCBvZiBlbXB0eSBzdHJlYW1cIl1cbiAgfCBDb25zICh4LCBfKSAtPiB4XG47O1xuXG5sZXQgZm9sZCcgdCB+aW5pdCB+ZiA9XG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgIGxldCByZWMgbG9vcCB0IGIgPVxuICAgICAgdXBvbiAobmV4dCB0KSAoZnVuY3Rpb25cbiAgICAgICAgfCBOaWwgLT4gSXZhci5maWxsX2V4biByZXN1bHQgYlxuICAgICAgICB8IENvbnMgKHYsIHQpIC0+IHVwb24gKGYgYiB2KSAobG9vcCB0KSlcbiAgICBpblxuICAgIGxvb3AgdCBpbml0KVxuOztcblxuKCogW2ZvbGRdIGlzIGltcGxlbWVudGVkIHRvIGF2b2lkIHBlci1zdHJlYW0tZWxlbWVudCBkZWZlcnJlZCBvdmVyaGVhZCBpbiB0aGUgY2FzZSB3aGVuXG4gICBtdWx0aXBsZSBzdHJlYW0gZWxlbWVudHMgYXJlIGF2YWlsYWJsZSBzaW11bHRhbmVvdXNseS4gKilcbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCBiID1cbiAgICAgIG1hdGNoIERlZmVycmVkLnBlZWsgKG5leHQgdCkgd2l0aFxuICAgICAgfCBOb25lIC0+IHVwb24gKG5leHQgdCkgKGZ1biBuZXh0IC0+IGxvb3BfbmV4dCBuZXh0IGIpXG4gICAgICB8IFNvbWUgbmV4dCAtPiBsb29wX25leHQgbmV4dCBiXG4gICAgYW5kIGxvb3BfbmV4dCBuZXh0IGIgPVxuICAgICAgbWF0Y2ggbmV4dCB3aXRoXG4gICAgICB8IE5pbCAtPiBJdmFyLmZpbGxfZXhuIHJlc3VsdCBiXG4gICAgICB8IENvbnMgKHYsIHQpIC0+IGxvb3AgdCAoZiBiIHYpXG4gICAgaW5cbiAgICBsb29wIHQgaW5pdClcbjs7XG5cbmxldCBsZW5ndGggdCA9IGZvbGQgdCB+aW5pdDowIH5mOihmdW4gbiBfIC0+IG4gKyAxKVxubGV0IGl0ZXInIHQgfmYgPSBmb2xkJyB0IH5pbml0OigpIH5mOihmdW4gKCkgdiAtPiBmIHYpXG5cbmxldCBjbG9zZWQgdCA9XG4gIG1hdGNoIERlZmVycmVkLnBlZWsgKG5leHQgdCkgd2l0aFxuICB8IFNvbWUgTmlsIC0+IHJldHVybiAoKVxuICB8IF8gLT4gaXRlcicgdCB+ZjooZnVuIF8gLT4gcmV0dXJuICgpKVxuOztcblxubGV0IGl0ZXIgdCB+ZiA9XG4gIGRvbid0X3dhaXRfZm9yXG4gICAgKGl0ZXInIHQgfmY6KGZ1biBhIC0+XG4gICAgICAgZiBhO1xuICAgICAgIHJldHVybiAoKSkpXG47O1xuXG5sZXQgY3JlYXRlIGYgPVxuICBsZXQgdGFpbCA9IFRhaWwuY3JlYXRlICgpIGluXG4gICgqIGNvbGxlY3QgYmVmb3JlIGNhbGxpbmcgW2ZdLCBpbiBjYXNlIFtmXSBpbW1lZGlhdGVseSBleHRlbmRzLiAqKVxuICBsZXQgdCA9IFRhaWwuY29sbGVjdCB0YWlsIGluXG4gIGYgdGFpbDtcbiAgdFxuOztcblxubGV0IHVuZm9sZCBiIH5mID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIGxldCByZWMgbG9vcCBiID1cbiAgICAgIHVwb24gKGYgYikgKGZ1bmN0aW9uXG4gICAgICAgIHwgTm9uZSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsXG4gICAgICAgIHwgU29tZSAoYSwgYikgLT5cbiAgICAgICAgICBUYWlsLmV4dGVuZCB0YWlsIGE7XG4gICAgICAgICAgbG9vcCBiKVxuICAgIGluXG4gICAgbG9vcCBiKVxuOztcblxubGV0IG9mX2xpc3QgbCA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBMaXN0Lml0ZXIgbCB+ZjooZnVuIHggLT4gVGFpbC5leHRlbmQgdGFpbCB4KTtcbiAgICBUYWlsLmNsb3NlX2V4biB0YWlsKVxuOztcblxubGV0IHRvX2xpc3QgcyA9IGZvbGQnIHMgfmluaXQ6W10gfmY6KGZ1biBiIGEgLT4gcmV0dXJuIChhIDo6IGIpKSA+PnwgTGlzdC5yZXZcbmxldCBjb3B5X3RvX3RhaWwgdCB0YWlsID0gaXRlcicgdCB+ZjooZnVuIGEgLT4gcmV0dXJuIChUYWlsLmV4dGVuZCB0YWlsIGEpKVxuXG5sZXQgYXBwZW5kIHQxIHQyID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIHVwb24gKGNvcHlfdG9fdGFpbCB0MSB0YWlsKSAoZnVuICgpIC0+XG4gICAgICB1cG9uIChjb3B5X3RvX3RhaWwgdDIgdGFpbCkgKGZ1biAoKSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsKSkpXG47O1xuXG5sZXQgY29uY2F0IHQgPVxuICBjcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgdXBvbiAoaXRlcicgdCB+ZjooZnVuIHQgLT4gY29weV90b190YWlsIHQgdGFpbCkpIChmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbCkpXG47O1xuXG5sZXQgZmlsdGVyJyB0IH5mID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIHVwb25cbiAgICAgIChpdGVyJyB0IH5mOihmdW4gdiAtPlxuICAgICAgICAgbWF0Y2glbWFwIGYgdiB3aXRoXG4gICAgICAgICB8IGZhbHNlIC0+ICgpXG4gICAgICAgICB8IHRydWUgLT4gVGFpbC5leHRlbmQgdGFpbCB2KSlcbiAgICAgIChmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbCkpXG47O1xuXG5sZXQgZmlsdGVyX2RlcHJlY2F0ZWQgdCB+ZiA9IGZpbHRlcicgdCB+ZjooZnVuIGEgLT4gcmV0dXJuIChmIGEpKVxuXG5sZXQgZmlsdGVyX21hcCcgdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICB1cG9uXG4gICAgICAoaXRlcicgdCB+ZjooZnVuIHYgLT5cbiAgICAgICAgIG1hdGNoJW1hcCBmIHYgd2l0aFxuICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICB8IFNvbWUgdiAtPiBUYWlsLmV4dGVuZCB0YWlsIHYpKVxuICAgICAgKGZ1biAoKSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsKSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwX2RlcHJlY2F0ZWQgdCB+ZiA9IGZpbHRlcl9tYXAnIHQgfmY6KGZ1biBhIC0+IHJldHVybiAoZiBhKSlcblxubGV0IG1hcCcgdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICB1cG9uIChpdGVyJyB0IH5mOihmdW4gdiAtPiBmIHYgPj58IFRhaWwuZXh0ZW5kIHRhaWwpKSAoZnVuICgpIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWwpKVxuOztcblxubGV0IG1hcCB0IH5mID0gbWFwJyB0IH5mOihmdW4gYSAtPiByZXR1cm4gKGYgYSkpXG5cbmxldCBmaXJzdF9uIHMgbiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBsZXQgcmVjIGxvb3AgcyBuID1cbiAgICAgIGlmIG4gPSAwXG4gICAgICB0aGVuIFRhaWwuY2xvc2VfZXhuIHRhaWxcbiAgICAgIGVsc2VcbiAgICAgICAgdXBvbiAobmV4dCBzKSAoZnVuY3Rpb25cbiAgICAgICAgICB8IE5pbCAtPiBUYWlsLmNsb3NlX2V4biB0YWlsXG4gICAgICAgICAgfCBDb25zICh4LCB0KSAtPlxuICAgICAgICAgICAgVGFpbC5leHRlbmQgdGFpbCB4O1xuICAgICAgICAgICAgbG9vcCB0IChuIC0gMSkpXG4gICAgaW5cbiAgICBsb29wIHMgbilcbjs7XG5cbmxldCBhdmFpbGFibGVfbm93IHQgPVxuICBsZXQgcmVjIGxvb3AgdCBhYyA9XG4gICAgbWF0Y2ggRGVmZXJyZWQucGVlayAobmV4dCB0KSB3aXRoXG4gICAgfCBOb25lIHwgU29tZSBOaWwgLT4gTGlzdC5yZXYgYWMsIHRcbiAgICB8IFNvbWUgKENvbnMgKHgsIHQpKSAtPiBsb29wIHQgKHggOjogYWMpXG4gIGluXG4gIGxvb3AgdCBbXVxuOztcblxubGV0IHNwbGl0ID8oc3RvcCA9IERlZmVycmVkLm5ldmVyICgpKSA/KGYgPSBmdW4gXyAtPiBgQ29udGludWUpIHQgPVxuICBsZXQgcmVhc29uX2Zvcl9zdG9wcGluZyA9IEl2YXIuY3JlYXRlICgpIGluXG4gIGxldCBwcmVmaXggPSBUYWlsLmNyZWF0ZSAoKSBpblxuICBsZXQgZmluaXNoIHYgPVxuICAgIFRhaWwuY2xvc2VfZXhuIHByZWZpeDtcbiAgICBJdmFyLmZpbGxfZXhuIHJlYXNvbl9mb3Jfc3RvcHBpbmcgdlxuICBpblxuICBsZXQgcmVjIGxvb3AgdCA9XG4gICAgY2hvb3NlIFsgY2hvaWNlIHN0b3AgKGZ1biAoKSAtPiBgU3RvcHBlZCk7IGNob2ljZSAobmV4dCB0KSAoZnVuIG8gLT4gYE5leHQgbykgXVxuICAgID4+PiBmdW5jdGlvblxuICAgIHwgYFN0b3BwZWQgLT4gZmluaXNoIChgU3RvcHBlZCB0KVxuICAgIHwgYE5leHQgbyAtPlxuICAgICAgKG1hdGNoIG8gd2l0aFxuICAgICAgIHwgTmlsIC0+IGZpbmlzaCBgRW5kX29mX3N0cmVhbVxuICAgICAgIHwgQ29ucyAoYSwgdCkgLT5cbiAgICAgICAgIChtYXRjaCBmIGEgd2l0aFxuICAgICAgICAgIHwgYENvbnRpbnVlIC0+XG4gICAgICAgICAgICBUYWlsLmV4dGVuZCBwcmVmaXggYTtcbiAgICAgICAgICAgIGxvb3AgdFxuICAgICAgICAgIHwgYEZvdW5kIGIgLT4gZmluaXNoIChgRm91bmQgKGIsIHQpKSkpXG4gIGluXG4gIGxvb3AgdDtcbiAgVGFpbC5jb2xsZWN0IHByZWZpeCwgSXZhci5yZWFkIHJlYXNvbl9mb3Jfc3RvcHBpbmdcbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBsZXQgXywgZm91bmQgPSBzcGxpdCB0IH5mOihmdW4gYSAtPiBpZiBmIGEgdGhlbiBgRm91bmQgYSBlbHNlIGBDb250aW51ZSkgaW5cbiAgbWF0Y2glbWFwIGZvdW5kIHdpdGhcbiAgfCBgU3RvcHBlZCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IChgRW5kX29mX3N0cmVhbSB8IGBGb3VuZCBfKSBhcyB4IC0+IHhcbjs7XG5cbmxldCB1bmdyb3VwIHQgPVxuICBjcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgdXBvblxuICAgICAgKGl0ZXInIHQgfmY6KGZ1biBsIC0+XG4gICAgICAgICBMaXN0Lml0ZXIgbCB+ZjooZnVuIHggLT4gVGFpbC5leHRlbmQgdGFpbCB4KTtcbiAgICAgICAgIHJldHVybiAoKSkpXG4gICAgICAoZnVuICgpIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWwpKVxuOztcblxubGV0IGludGVybGVhdmUgdHMgPVxuICBjcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgKCogVGhlIGludGVybGVhdmVkIHN0cmVhbSBzaG91bGQgYmUgY2xvc2VkIHdoZW4gdGhlIG91dGVyIHN0cmVhbSBhbmQgYWxsIG9mXG4gICAgICAgdGhlIGlubmVyIHN0cmVhbXMgaGF2ZSBiZWVuIGNsb3NlZC4gIEtlZXAgYSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIG9wZW5cbiAgICAgICBzdHJlYW1zIGFuZCBjbG9zZSB0aGUgaW50ZXJsZWF2ZWQgc3RyZWFtIHdoZW4gdGhhdCBjb3VudCBiZWNvbWVzXG4gICAgICAgemVyby4gKilcbiAgICBsZXQgbnVtX29wZW4gPSByZWYgMSBpblxuICAgICgqIDEgZm9yIHRoZSBvdXRlciBzdHJlYW0gdGhhdCBpcyBvcGVuICopXG4gICAgbGV0IGNsb3NlICgpID1cbiAgICAgIG51bV9vcGVuIDo9ICFudW1fb3BlbiAtIDE7XG4gICAgICBpZiAhbnVtX29wZW4gPSAwIHRoZW4gVGFpbC5jbG9zZV9leG4gdGFpbFxuICAgIGluXG4gICAgbGV0IG91dGVyX2Nsb3NlZCA9XG4gICAgICBpdGVyJyB0cyB+ZjooZnVuIHQgLT5cbiAgICAgICAgbnVtX29wZW4gOj0gIW51bV9vcGVuICsgMTtcbiAgICAgICAgdXBvbiAoY29weV90b190YWlsIHQgdGFpbCkgY2xvc2U7XG4gICAgICAgIHJldHVybiAoKSlcbiAgICBpblxuICAgIHVwb24gb3V0ZXJfY2xvc2VkIGNsb3NlKVxuOztcblxubGV0IHRha2VfdW50aWwgdCBkID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIGxldCByZWMgbG9vcCB0ID1cbiAgICAgIHVwb25cbiAgICAgICAgKGNob29zZSBbIGNob2ljZSBkIChmdW4gKCkgLT4gYFN0b3ApOyBjaG9pY2UgKG5leHQgdCkgKGZ1biB6IC0+IGBOZXh0IHopIF0pXG4gICAgICAgIChmdW5jdGlvblxuICAgICAgICAgfCBgU3RvcCB8IGBOZXh0IE5pbCAtPiBUYWlsLmNsb3NlX2V4biB0YWlsXG4gICAgICAgICB8IGBOZXh0IChDb25zICh4LCB0KSkgLT5cbiAgICAgICAgICAgVGFpbC5leHRlbmQgdGFpbCB4O1xuICAgICAgICAgICBsb29wIHQpXG4gICAgaW5cbiAgICBsb29wIHQpXG47O1xuXG5sZXQgaXRlcl9kdXJhYmx5JyB0IH5mID1cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgbGV0IHJlYyBsb29wIHQgPVxuICAgICAgbmV4dCB0XG4gICAgICA+Pj4gZnVuY3Rpb25cbiAgICAgIHwgTmlsIC0+IEl2YXIuZmlsbF9leG4gcmVzdWx0ICgpXG4gICAgICB8IENvbnMgKHgsIHQpIC0+XG4gICAgICAgIE1vbml0b3IudHJ5X3dpdGggfnJ1bjpgU2NoZWR1bGUgfnJlc3Q6YFJhaXNlIChmdW4gKCkgLT4gZiB4KVxuICAgICAgICA+Pj4gZnVuIHogLT5cbiAgICAgICAgbG9vcCB0O1xuICAgICAgICAobWF0Y2ggeiB3aXRoXG4gICAgICAgICB8IE9rICgpIC0+ICgpXG4gICAgICAgICB8IEVycm9yIGUgLT4gTW9uaXRvci5zZW5kX2V4biAoTW9uaXRvci5jdXJyZW50ICgpKSBlKVxuICAgIGluXG4gICAgbG9vcCB0KVxuOztcblxubGV0IGl0ZXJfZHVyYWJseV9yZXBvcnRfZW5kIHQgfmYgPVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCA9XG4gICAgICBuZXh0IHRcbiAgICAgID4+PiBmdW5jdGlvblxuICAgICAgfCBOaWwgLT4gSXZhci5maWxsX2V4biByZXN1bHQgKClcbiAgICAgIHwgQ29ucyAoeCwgdCkgLT5cbiAgICAgICAgKCogV2UgaW1tZWRpYXRlbHkgY2FsbCBbbG9vcF0sIHRodXMgbWFraW5nIHRoZSBpdGVyIGR1cmFibGUuICBBbnkgZXhjZXB0aW9uc1xuICAgICAgICAgICByYWlzZWQgYnkgW2ZdIHdpbGwgbm90IHByZXZlbnQgdGhlIGxvb3AgZnJvbSBjb250aW51aW5nLCBhbmQgd2lsbCBnbyB0byB0aGVcbiAgICAgICAgICAgbW9uaXRvciBvZiB3aG9tZXZlciBjYWxsZWQgW2l0ZXJfZHVyYWJseV9yZXBvcnRfZW5kXS4gKilcbiAgICAgICAgbG9vcCB0O1xuICAgICAgICBmIHhcbiAgICBpblxuICAgIGxvb3AgdClcbjs7XG5cbmxldCBpdGVyX2R1cmFibHkgdCB+ZiA9IGRvbid0X3dhaXRfZm9yIChpdGVyX2R1cmFibHlfcmVwb3J0X2VuZCB0IH5mKVxuXG5sZXQgb2ZfZnVuIGYgPVxuICB1bmZvbGQgKCkgfmY6KGZ1biAoKSAtPlxuICAgIGxldCVtYXAgYSA9IGYgKCkgaW5cbiAgICBTb21lIChhLCAoKSkpXG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgKCdhLCAncGVybWlzc2lvbikgdCA9ICgnYSwgJ3Blcm1pc3Npb24pIFR5cGVzLkJ2YXIudFxuXG50eXBlICdhIHJlcHIgPSAnYSBUeXBlcy5CdmFyLnJlcHIgPVxuICB7IG11dGFibGUgaGFzX2FueV93YWl0ZXJzIDogYm9vbFxuICA7IG11dGFibGUgaXZhciA6ICdhIEl2YXIudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIF8gdCA9XG4gIGxldCByZXByID0gVHlwZXMuQnZhci50b19yZXByIHQgaW5cbiAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHJlcHIgWyVzZXhwX29mOiBfIHJlcHJdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCByZXByIGYgaW5cbiAgICBGaWVsZHNfb2ZfcmVwci5pdGVyXG4gICAgICB+aGFzX2FueV93YWl0ZXJzOlxuICAgICAgICAoY2hlY2sgKGZ1biBoYXNfYW55X3dhaXRlcnMgLT5cbiAgICAgICAgICAgaWYgSXZhci5oYXNfaGFuZGxlcnMgcmVwci5pdmFyIHRoZW4gYXNzZXJ0IGhhc19hbnlfd2FpdGVycykpXG4gICAgICB+aXZhcjpcbiAgICAgICAgKGNoZWNrIChmdW4gaXZhciAtPlxuICAgICAgICAgICBJdmFyLmludmFyaWFudCBpbnZhcmlhbnRfYSBpdmFyO1xuICAgICAgICAgICBhc3NlcnQgKEl2YXIuaXNfZW1wdHkgaXZhcikpKSlcbjs7XG5cbmxldCBzZXhwX29mX3QgXyBfIHQgPVxuICBsZXQgeyBoYXNfYW55X3dhaXRlcnM7IGl2YXIgPSBfIH0gPSBUeXBlcy5CdmFyLnRvX3JlcHIgdCBpblxuICAoKiBXZSBkb24ndCBzaG93IFtpdmFyXSBiZWNhdXNlIGl0J3MgYWx3YXlzIGVtcHR5LiAqKVxuICBbJW1lc3NhZ2UgKGhhc19hbnlfd2FpdGVycyA6IGJvb2wpXVxuOztcblxuaW5jbHVkZSBTY2hlZHVsZXIxLkJ2YXJcblxubGV0IGJyb2FkY2FzdCB0IGEgPVxuICBsZXQgcmVwciA9IFR5cGVzLkJ2YXIudG9fcmVwciB0IGluXG4gIGlmIHJlcHIuaGFzX2FueV93YWl0ZXJzXG4gIHRoZW4gKFxuICAgIHJlcHIuaGFzX2FueV93YWl0ZXJzIDwtIGZhbHNlO1xuICAgIEl2YXIuZmlsbF9leG4gcmVwci5pdmFyIGE7XG4gICAgcmVwci5pdmFyIDwtIEl2YXIuY3JlYXRlICgpKVxuOztcblxubGV0IHdhaXQgdCA9XG4gIGxldCByZXByID0gVHlwZXMuQnZhci50b19yZXByIHQgaW5cbiAgcmVwci5oYXNfYW55X3dhaXRlcnMgPC0gdHJ1ZTtcbiAgSXZhci5yZWFkIHJlcHIuaXZhclxuOztcblxubGV0IGhhc19hbnlfd2FpdGVycyB0ID1cbiAgbGV0IHJlcHIgPSBUeXBlcy5CdmFyLnRvX3JlcHIgdCBpblxuICByZXByLmhhc19hbnlfd2FpdGVyc1xuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiEgRGVmZXJyZWRfc3RkXG5cbmxldCBkZWJ1ZyA9IERlYnVnLmNsb2NrXG5cbm1vZHVsZSBBbGFybSA9IFRpbWluZ193aGVlbC5BbGFybVxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyMVxuXG5sZXQgdXBvbiA9IERlZmVycmVkLnVwb25cbmxldCBjaG9vc2UgPSBEZWZlcnJlZC5jaG9vc2VcbmxldCBjaG9pY2UgPSBEZWZlcnJlZC5jaG9pY2VcbmxldCAoID4+PiApID0gdXBvblxuXG5tb2R1bGUgVDEgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAuVDFcblxuICAoKiBXZSBkb24ndCBpbmNsdWRlIHRoZSBbaWRdIGluIHRoZSBzZXhwIGJlY2F1c2UgdGhlIHVzZXIgKHJpZ2h0bHkpIGNhbid0IGNvbnRyb2wgaXQsIHNvXG4gICAgIGl0J3MgaGFyZCB0byBtYWtlIGl0IGRldGVybWluaXN0aWMgaW4gdGVzdHMuICopXG4gIGxldCBzZXhwX29mX3RcbiAgICBfXG4gICAgeyBpZCA9IF9cbiAgICA7IGFkdmFuY2VfZXJyb3JzID0gX1xuICAgIDsgYW1fYWR2YW5jaW5nID0gX1xuICAgIDsgZXZlbnRzXG4gICAgOyBmaXJlZF9ldmVudHMgPSBfXG4gICAgOyBoYW5kbGVfZmlyZWQgPSBfXG4gICAgOyBpc193YWxsX2Nsb2NrXG4gICAgOyBtb3N0X3JlY2VudGx5X2ZpcmVkID0gX1xuICAgIDsgc2NoZWR1bGVyID0gX1xuICAgIH1cbiAgICA9XG4gICAgaWYgaXNfd2FsbF9jbG9ja1xuICAgIHRoZW4gWyVtZXNzYWdlIFwiPHdhbGxfY2xvY2s+XCJdXG4gICAgZWxzZVxuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIChpc193YWxsX2Nsb2NrIDogYm9vbClcbiAgICAgICAgICAoKiBXZSBkb24ndCBkaXNwbGF5IHRoZSBbSm9iLnRdcyBpbiBbZXZlbnRzXSBiZWNhdXNlIHRob3NlIGFyZVxuICAgICAgICAgICAgIHBvb2wgcG9pbnRlcnMsIHdoaWNoIGFyZSB1bmluZm9ybWF0aXZlLiAqKVxuICAgICAgICAgIChldmVudHMgOiBfIFRpbWluZ193aGVlbC50KV1cbiAgOztcbmVuZFxuXG5vcGVuIFQxXG5cbm1vZHVsZSBSZWFkX3dyaXRlID0gc3RydWN0XG4gIHR5cGUgdCA9IHJlYWRfd3JpdGUgVDEudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgPSBpbnZhcmlhbnRcbiAgbGV0IGludmFyaWFudF93aXRoX2pvYnMgPSBpbnZhcmlhbnRfd2l0aF9qb2JzXG5lbmRcblxudHlwZSB0ID0gcmVhZCBUMS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgPSBpbnZhcmlhbnRcbmxldCBpbnZhcmlhbnRfd2l0aF9qb2JzID0gaW52YXJpYW50X3dpdGhfam9ic1xubGV0IHJlYWRfb25seSAodCA6IFs+IHJlYWQgXSBUMS50KSA9ICh0IDo+IHQpXG5sZXQgY3JlYXRlID0gU2NoZWR1bGVyLmNyZWF0ZV90aW1lX3NvdXJjZVxubGV0IHdhbGxfY2xvY2sgPSBTY2hlZHVsZXIud2FsbF9jbG9ja1xubGV0IGFsYXJtX3ByZWNpc2lvbiB0ID0gVGltaW5nX3doZWVsLmFsYXJtX3ByZWNpc2lvbiB0LmV2ZW50c1xubGV0IGlzX3dhbGxfY2xvY2sgdCA9IHQuaXNfd2FsbF9jbG9ja1xubGV0IG5leHRfYWxhcm1fZmlyZXNfYXQgdCA9IFRpbWluZ193aGVlbC5uZXh0X2FsYXJtX2ZpcmVzX2F0IHQuZXZlbnRzXG5sZXQgdGltaW5nX3doZWVsX25vdyB0ID0gVGltaW5nX3doZWVsLm5vdyB0LmV2ZW50c1xubGV0IGlkIHQgPSB0LmlkXG5cbm1vZHVsZSBJZCA9IFN5bmNocm9ub3VzX3RpbWVfc291cmNlMC5JZFxuXG5sZXQgbm93IHQgPVxuICBpZiB0LmlzX3dhbGxfY2xvY2tcbiAgdGhlblxuICAgICgqIEZvciB0aGUgd2FsbC1jbG9jayB0aW1lLXNvdXJjZSwgd2UgdXNlIFtUaW1lX25zLm5vdyAoKV0gcmF0aGVyIHRoYW5cbiAgICAgICBbVGltaW5nX3doZWVsLm5vdyB0LmV2ZW50c10uICBUaGUgbGF0dGVyIGlzIG9ubHkgdXBkYXRlZCBhdCB0aGUgc3RhcnQgb2YgZWFjaFxuICAgICAgIGN5Y2xlLiAgVGhlcmUgY2FuIGJlIHN1YnN0YW50aWFsIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIHdoZW4gcGVvcGxlIGRvIGxvbmdcbiAgICAgICBydW5uaW5nIGNvbXB1dGF0aW9ucyBvciBtaXggYmxvY2tpbmcgY29kZSB3aXRoIGFzeW5jLiAgQW5kIGh1bWFucyBleHBlY3QgdGhhdFxuICAgICAgIHdhbGwtY2xvY2sgdGltZSBpcyBiYXNlZCBvbiBbVGltZS5ub3ddLCBub3Qgc29tZSBhcnRpZmFjdCBvZiBhc3luY1xuICAgICAgIGltcGxlbWVudGF0aW9uLiAqKVxuICAgIFRpbWVfbnMubm93ICgpXG4gIGVsc2UgdGltaW5nX3doZWVsX25vdyB0XG47O1xuXG4oKiBXZSBwcmVhbGxvY2F0ZSBbc2VuZF9leG5dIHRvIGF2b2lkIGFsbG9jYXRpbmcgaXQgb24gZWFjaCBjYWxsIHRvIFthZHZhbmNlX2Nsb2NrXS4gKilcbmxldCBzZW5kX2V4biA9IFNvbWUgTW9uaXRvci5zZW5kX2V4blxubGV0IGFkdmFuY2VfZGlyZWN0bHkgdCB+dG9fID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLmFkdmFuY2VfY2xvY2sgdCB+dG9fIH5zZW5kX2V4blxuXG5sZXQgYWR2YW5jZV9kaXJlY3RseV9zdG9wX29uX25leHRfYWxhcm0gdCB+dG9fID1cbiAgU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLmFkdmFuY2VfY2xvY2tfc3RvcF9hdF9uZXh0X2FsYXJtIHQgfnRvXyB+c2VuZF9leG5cbjs7XG5cbmxldCBhZHZhbmNlX2RpcmVjdGx5X2J5IHQgYnkgPSBhZHZhbmNlX2RpcmVjdGx5IHQgfnRvXzooVGltZV9ucy5hZnRlciAobm93IHQpIGJ5KVxubGV0IGFkdmFuY2UgPSBhZHZhbmNlX2RpcmVjdGx5XG5sZXQgYWR2YW5jZV9ieSA9IGFkdmFuY2VfZGlyZWN0bHlfYnlcbmxldCBmaXJlX3Bhc3RfYWxhcm1zIHQgPSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAuZmlyZV9wYXN0X2FsYXJtcyB0IH5zZW5kX2V4blxubGV0IHlpZWxkIHQgPSBCdmFyLndhaXQgKFNjaGVkdWxlci55aWVsZCB0LnNjaGVkdWxlcilcbmxldCBjYW5fcnVuX2Ffam9iIHQgPSBTY2hlZHVsZXIubnVtX3BlbmRpbmdfam9icyB0ID4gMCB8fCBCdmFyLmhhc19hbnlfd2FpdGVycyB0LnlpZWxkXG5cbm1vZHVsZSBFYWdlcl9kZWZlcnJlZCA9IHN0cnVjdFxuICBsZXQgYmluZF91bml0IHQgfmYgPVxuICAgIGlmIERlZmVycmVkLmlzX2RldGVybWluZWQgdFxuICAgIHRoZW4gZiAoKVxuICAgIGVsc2UgKFxuICAgICAgbGV0JWJpbmQgKCkgPSB0IGluXG4gICAgICBmICgpKVxuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiA9XG4gICAgaWYgRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCB0XG4gICAgdGhlbiByZXR1cm4gKGYgKERlZmVycmVkLnZhbHVlX2V4biB0KSlcbiAgICBlbHNlIERlZmVycmVkLm1hcCB0IH5mXG4gIDs7XG5lbmRcblxubGV0IGFkdmFuY2VfYnlfYWxhcm1zID93YWl0X2ZvciB0IH50b18gPVxuICBsZXQgcnVuX3F1ZXVlZF9hbGFybXMgKCkgPVxuICAgICgqIEV2ZXJ5IHRpbWUgd2Ugd2FudCB0byBydW4gcXVldWVkIGFsYXJtcyB3ZSBuZWVkIHRvIHlpZWxkIGNvbnRyb2wgYmFjayB0byB0aGVcbiAgICAgICBbQXN5bmMuU2NoZWR1bGVyXSBhbmQgW3dhaXRfZm9yXSBhbnkgbG9naWMgdGhhdCBpcyBzdXBwb3NlZCB0byBmaW5pc2ggYXQgdGhpcyB0aW1lXG4gICAgICAgYmVmb3JlIGFkdmFuY2luZy4gIElmIG5vIFt3YWl0X2Zvcl0gbG9naWMgaXMgc3BlY2lmaWVkIHdlIGNhbiBzaW1wbHkgeWllbGQgY29udHJvbFxuICAgICAgIGJ5IGludm9raW5nIFt5aWVsZCB0XSwgd2hpY2ggZW5xdWV1ZXMgYW5vdGhlciBqb2IgYXQgdGhlIGVuZCBvZiB0aGUgc2NoZWR1bGVyIGpvYlxuICAgICAgIHF1ZXVlIHNvIGFsYXJtIGpvYnMgaGF2ZSB0aGUgb3Bwb3J0dW5pdHkgdG8gcnVuIGJlZm9yZSB3ZSBhZHZhbmNlLiAqKVxuICAgIG1hdGNoIHdhaXRfZm9yIHdpdGhcbiAgICB8IE5vbmUgLT4geWllbGQgdFxuICAgIHwgU29tZSBmIC0+IGYgKClcbiAgaW5cbiAgbGV0IG9uZV9zdGVwICgpID1cbiAgICBpZiBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAuYW55X2ZpcmVkX2V2ZW50c190b19ydW4gdFxuICAgIHRoZW4gbm93IHQsIGBjb250aW51ZVxuICAgIGVsc2UgdG9fLCBgY2hlY2tfdGltZVxuICBpblxuICBsZXQgcmVjIHdhbGtfYWxhcm1zICgpID1cbiAgICBsZXQgYWR2YW5jZV90bywgbmV4dCA9IG9uZV9zdGVwICgpIGluXG4gICAgYWR2YW5jZV9kaXJlY3RseV9zdG9wX29uX25leHRfYWxhcm0gdCB+dG9fOmFkdmFuY2VfdG87XG4gICAgZmlyZV9wYXN0X2FsYXJtcyB0O1xuICAgIEVhZ2VyX2RlZmVycmVkLmJpbmRfdW5pdCAocnVuX3F1ZXVlZF9hbGFybXMgKCkpIH5mOihmdW4gKCkgLT5cbiAgICAgIG1hdGNoIG5leHQgd2l0aFxuICAgICAgfCBgY2hlY2tfdGltZSAtPlxuICAgICAgICBpZiBUaW1lX25zLiggPCApICh0aW1pbmdfd2hlZWxfbm93IHQpIHRvXyB0aGVuIHdhbGtfYWxhcm1zICgpIGVsc2UgcmV0dXJuICgpXG4gICAgICB8IGBjb250aW51ZSAtPiB3YWxrX2FsYXJtcyAoKSlcbiAgaW5cbiAgKCogVGhpcyBmaXJzdCBbcnVuX3F1ZXVlZF9hbGFybXNdIGNhbGwgYWxsb3dzIFtDbG9ja19ucy5ldmVyeV0gdGhlIG9wcG9ydHVuaXR5IHRvIHJ1blxuICAgICBpdHMgY29udGludWF0aW9uIGRlZmVycmVkcyBzbyB0aGF0IHRoZXkgY2FuIHJlc2NoZWR1bGUgYWxhcm1zLiAgVGhpcyBpcyBwYXJ0aWN1bGFybHlcbiAgICAgdXNlZnVsIGluIG91ciBcImFkdmFuY2UgaGl0cyBpbnRlcm1lZGlhdGUgYWxhcm1zXCIgdW5pdCB0ZXN0IGJlbG93LCBidXQgbGlrZWx5IHVzZWZ1bFxuICAgICBpbiBvdGhlciBjYXNlcyB3aGVyZSBbZXZlcnldIGlzIHN5bmNocm9ub3VzbHkgZm9sbG93ZWQgYnkgW2FkdmFuY2VdLiAqKVxuICBsZXQlYmluZCAoKSA9IHJ1bl9xdWV1ZWRfYWxhcm1zICgpIGluXG4gIHdhbGtfYWxhcm1zICgpXG47O1xuXG5sZXQgYWR2YW5jZV9ieV9tYXhfYWxhcm1zX2luX2VhY2hfdGltaW5nX3doZWVsX2ludGVydmFsID93YWl0X2ZvciB0IH50b18gPVxuICBsZXQgcnVuX3F1ZXVlZF9hbGFybXMgKCkgPVxuICAgICgqIEV2ZXJ5IHRpbWUgd2Ugd2FudCB0byBydW4gcXVldWVkIGFsYXJtcyB3ZSBuZWVkIHRvIHlpZWxkIGNvbnRyb2wgYmFjayB0byB0aGVcbiAgICAgICBbQXN5bmMuU2NoZWR1bGVyXSBhbmQgW3dhaXRfZm9yXSBhbnkgbG9naWMgdGhhdCBpcyBzdXBwb3NlZCB0byBmaW5pc2ggYXQgdGhpcyB0aW1lXG4gICAgICAgYmVmb3JlIGFkdmFuY2luZy4gIElmIG5vIFt3YWl0X2Zvcl0gbG9naWMgaXMgc3BlY2lmaWVkIHdlIGNhbiBzaW1wbHkgeWllbGQgY29udHJvbFxuICAgICAgIGJ5IGludm9raW5nIFt5aWVsZCB0XSwgd2hpY2ggZW5xdWV1ZXMgYW5vdGhlciBqb2IgYXQgdGhlIGVuZCBvZiB0aGUgc2NoZWR1bGVyIGpvYlxuICAgICAgIHF1ZXVlIHNvIGFsYXJtIGpvYnMgaGF2ZSB0aGUgb3Bwb3J0dW5pdHkgdG8gcnVuIGJlZm9yZSB3ZSBhZHZhbmNlLiAqKVxuICAgIG1hdGNoIHdhaXRfZm9yIHdpdGhcbiAgICB8IE5vbmUgLT4geWllbGQgdFxuICAgIHwgU29tZSBmIC0+IGYgKClcbiAgaW5cbiAgbGV0IGZpbmlzaCAoKSA9XG4gICAgYWR2YW5jZV9kaXJlY3RseSB0IH50b187XG4gICAgZmlyZV9wYXN0X2FsYXJtcyB0O1xuICAgICgqIHNvIHRoYXQgYWxhcm1zIHNjaGVkdWxlZCBhdCBvciBiZWZvcmUgW3RvX10gZmlyZSAqKVxuICAgIHJ1bl9xdWV1ZWRfYWxhcm1zICgpXG4gIGluXG4gIGxldCByZWMgd2Fsa19hbGFybXMgKCkgPVxuICAgIG1hdGNoIG5leHRfYWxhcm1fZmlyZXNfYXQgdCB3aXRoXG4gICAgfCBOb25lIC0+IGZpbmlzaCAoKVxuICAgIHwgU29tZSBuZXh0X2FsYXJtX2ZpcmVzX2F0IC0+XG4gICAgICBpZiBUaW1lX25zLiggPj0gKSBuZXh0X2FsYXJtX2ZpcmVzX2F0IHRvX1xuICAgICAgdGhlbiBmaW5pc2ggKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBhZHZhbmNlX2RpcmVjdGx5IHQgfnRvXzooVGltaW5nX3doZWVsLm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF9leG4gdC5ldmVudHMpO1xuICAgICAgICBmaXJlX3Bhc3RfYWxhcm1zIHQ7XG4gICAgICAgIGxldCBxdWV1ZWRfYWxhcm1zX3JhbiA9IHJ1bl9xdWV1ZWRfYWxhcm1zICgpIGluXG4gICAgICAgIEVhZ2VyX2RlZmVycmVkLmJpbmRfdW5pdCBxdWV1ZWRfYWxhcm1zX3JhbiB+Zjp3YWxrX2FsYXJtcylcbiAgaW5cbiAgZmlyZV9wYXN0X2FsYXJtcyB0O1xuICAoKiBUaGlzIGZpcnN0IFtydW5fcXVldWVkX2FsYXJtc10gY2FsbCBhbGxvd3MgW0Nsb2NrX25zLmV2ZXJ5XSB0aGUgb3Bwb3J0dW5pdHkgdG8gcnVuXG4gICAgIGl0cyBjb250aW51YXRpb24gZGVmZXJyZWRzIHNvIHRoYXQgdGhleSBjYW4gcmVzY2hlZHVsZSBhbGFybXMuICBUaGlzIGlzIHBhcnRpY3VsYXJseVxuICAgICB1c2VmdWwgaW4gb3VyIFwiYWR2YW5jZSBoaXRzIGludGVybWVkaWF0ZSBhbGFybXNcIiB1bml0IHRlc3QgYmVsb3csIGJ1dCBsaWtlbHkgdXNlZnVsXG4gICAgIGluIG90aGVyIGNhc2VzIHdoZXJlIFtldmVyeV0gaXMgc3luY2hyb25vdXNseSBmb2xsb3dlZCBieSBbYWR2YW5jZV0uICopXG4gIGxldCViaW5kICgpID0gcnVuX3F1ZXVlZF9hbGFybXMgKCkgaW5cbiAgd2Fsa19hbGFybXMgKClcbjs7XG5cbmxldCBhZHZhbmNlX2J5X2FsYXJtc19ieSA/d2FpdF9mb3IgdCBieSA9XG4gIGFkdmFuY2VfYnlfYWxhcm1zID93YWl0X2ZvciB0IH50b186KFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSBieSlcbjs7XG5cbmxldCBzcGFuX3RvX3RpbWUgdCBzcGFuID0gVGltZV9ucy5hZnRlciAobm93IHQpIHNwYW5cblxubGV0IHNjaGVkdWxlX2pvYiB0IH5hdCBleGVjdXRpb25fY29udGV4dCBmIGEgPVxuICBsZXQgYWxhcm0gPVxuICAgIFRpbWluZ193aGVlbC5hZGRcbiAgICAgIHQuZXZlbnRzXG4gICAgICB+YXRcbiAgICAgIChKb2Jfb3JfZXZlbnQub2Zfam9iIChTY2hlZHVsZXIuY3JlYXRlX2pvYiB0LnNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIGEpKVxuICBpblxuICAobWF0Y2ggdC5zY2hlZHVsZXIuZXZlbnRfYWRkZWRfaG9vayB3aXRoXG4gICB8IE5vbmUgLT4gKClcbiAgIHwgU29tZSBmIC0+IGYgYXQpO1xuICBhbGFybVxuOztcblxubGV0IHJ1bl9hdF9pbnRlcm5hbCB0IHRpbWUgZiBhID1cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdC5zY2hlZHVsZXIgaW5cbiAgaWYgVGltZV9ucy4oID4gKSB0aW1lIChUaW1pbmdfd2hlZWwubm93IHQuZXZlbnRzKVxuICB0aGVuIHNjaGVkdWxlX2pvYiB0IH5hdDp0aW1lIGV4ZWN1dGlvbl9jb250ZXh0IGYgYVxuICBlbHNlIChcbiAgICBTY2hlZHVsZXIuZW5xdWV1ZSB0LnNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIGE7XG4gICAgQWxhcm0ubnVsbCAoKSlcbjs7XG5cbmxldCBydW5fYXQgdCB0aW1lIGYgYSA9IGlnbm9yZSAocnVuX2F0X2ludGVybmFsIHQgdGltZSBmIGEgOiBfIEFsYXJtLnQpXG5sZXQgcnVuX2FmdGVyIHQgc3BhbiBmIGEgPSBydW5fYXQgdCAoc3Bhbl90b190aW1lIHQgc3BhbikgZiBhXG5cbmxldCBhdCA9XG4gIGxldCBmaWxsIHJlc3VsdCA9IEl2YXIuZmlsbF9leG4gcmVzdWx0ICgpIGluXG4gIGZ1biB0IHRpbWUgLT5cbiAgICBpZiBUaW1lX25zLiggPD0gKSB0aW1lIChUaW1pbmdfd2hlZWwubm93IHQuZXZlbnRzKVxuICAgIHRoZW4gcmV0dXJuICgpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVzdWx0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgICAgIGlnbm9yZSAocnVuX2F0X2ludGVybmFsIHQgdGltZSBmaWxsIHJlc3VsdCA6IF8gQWxhcm0udCk7XG4gICAgICBJdmFyLnJlYWQgcmVzdWx0KVxuOztcblxubGV0IGFmdGVyIHQgc3BhbiA9IGF0IHQgKHNwYW5fdG9fdGltZSB0IHNwYW4pXG5cbmxldCByZW1vdmVfYWxhcm0gdCBhbGFybSA6IHVuaXQgPVxuICBsZXQgam9iX29yX2V2ZW50ID0gQWxhcm0udmFsdWUgdC5ldmVudHMgYWxhcm0gaW5cbiAgKGxldCBvcGVuIEpvYl9vcl9ldmVudC5NYXRjaCBpblxuICAgbGV0IChLIGspID0ga2luZCBqb2Jfb3JfZXZlbnQgaW5cbiAgIG1hdGNoIGssIHByb2plY3QgayBqb2Jfb3JfZXZlbnQgd2l0aFxuICAgfCBKb2IsIGpvYiAtPiBTY2hlZHVsZXIuZnJlZV9qb2IgdC5zY2hlZHVsZXIgam9iXG4gICB8IEV2ZW50LCBfIC0+XG4gICAgICgqIFRoaXMgaXMgdW5yZWFjaGFibGUgYmVjYXVzZSBbYWxhcm1dIG9ubHkgZXZlciBjb21lcyBmcm9tIFtFdmVudC5hbGFybV0gd2hpY2ggb25seVxuICAgICAgICBldmVyIGdldHMgcG9wdWxhdGVkIGJ5IGEgY2FsbCB0byBbc2NoZWR1bGVfam9iXS4gKilcbiAgICAgYXNzZXJ0IGZhbHNlKTtcbiAgVGltaW5nX3doZWVsLnJlbW92ZSB0LmV2ZW50cyBhbGFybVxuOztcblxubGV0IHJlbW92ZV9hbGFybV9pZl9zY2hlZHVsZWQgdCBhbGFybSA9XG4gIGlmIFRpbWluZ193aGVlbC5tZW0gdC5ldmVudHMgYWxhcm0gdGhlbiByZW1vdmVfYWxhcm0gdCBhbGFybVxuOztcblxubW9kdWxlIEV2ZW50ID0gc3RydWN0XG4gIG1vZHVsZSBGaXJlZCA9IHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnaCkgdCA9XG4gICAgICB8IEFib3J0ZWQgb2YgJ2FcbiAgICAgIHwgSGFwcGVuZWQgb2YgJ2hcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICB0eXBlICgnYSwgJ2gpIHQgPVxuICAgIHsgbXV0YWJsZSBhbGFybSA6IEpvYl9vcl9ldmVudC50IEFsYXJtLnRcbiAgICA7IG11dGFibGUgZmlyZSA6IHVuaXQgLT4gdW5pdFxuICAgIDsgKCogQXMgbG9uZyBhcyBbSXZhci5pc19lbXB0eSBmaXJlZF0sIHdlIGhhdmUgbm90IHlldCBjb21taXR0ZWQgdG8gd2hldGhlciB0aGUgZXZlbnRcbiAgICAgICAgIHdpbGwgaGFwcGVuIG9yIGJlIGFib3J0ZWQuICBXaGVuIFtJdmFyLmlzX2VtcHR5IGZpcmVkXSwgdGhlIGFsYXJtIG1heSBvciBtYXkgbm90XG4gICAgICAgICBiZSBpbiB0aGUgdGltaW5nIHdoZWVsIC0tIGlmIGl0IGlzbid0LCB0aGVuIHRoZXJlJ3MgYSBqb2IgaW4gQXN5bmMncyBqb2IgcXVldWVcbiAgICAgICAgIHRoYXQgd2lsbCBmaXJlIHRoZSBldmVudCwgdW5sZXNzIGl0IGlzIGFib3J0ZWQgYmVmb3JlIHRoYXQgam9iIGNhbiBydW4uICopXG4gICAgICBmaXJlZCA6ICgnYSwgJ2gpIEZpcmVkLnQgSXZhci50XG4gICAgOyAoKiBbbnVtX2ZpcmVzX3RvX3NraXBdIGlzIHVzZWQgdG8gcmVzY2hlZHVsZSBldmVudHMgdGhhdCBoYXZlIGZpcmVkIGFuZCBlbnRlcmVkIHRoZVxuICAgICAgICAgQXN5bmMgam9iIHF1ZXVlLCBidXQgaGF2ZSBub3QgeWV0IHJ1bi4gIFRob3NlIGpvYnMgb25seSBydW4gaWYgW251bV9maXJlc190b19za2lwXG4gICAgICAgICA9IDBdLCBhbmQgb3RoZXJ3aXNlIGp1c3QgZGVjcmVtZW50IGl0LiAgU28sIHRvIHJlc2NoZWR1bGUgYW4gZXZlbnQgaW4gc3VjaCBhXG4gICAgICAgICBzdGF0ZSwgd2UgaW5jcmVtZW50IFtudW1fZmlyZXNfdG9fc2tpcF0gYW5kIGFkZCBhIG5ldyBhbGFybSB0byB0aGUgdGltaW5nXG4gICAgICAgICB3aGVlbC4gKilcbiAgICAgIG11dGFibGUgbnVtX2ZpcmVzX3RvX3NraXAgOiBpbnRcbiAgICA7ICgqIFtzY2hlZHVsZWRfYXRdIGlzIHRoZSB0aW1lIGF0IHdoaWNoIFt0XSBoYXMgbW9zdCByZWNlbnRseSBiZWVuIHNjaGVkdWxlZCB0byBmaXJlLlxuICAgICAgICAgV2hpbGUgW3QuYWxhcm1dIGlzIHN0aWxsIGluIHRoZSB0aW1pbmcgd2hlZWwsIHRoaXMgaXMgdGhlIHNhbWUgYXMgW0FsYXJtLmF0XG4gICAgICAgICB0LmFsYXJtXS4gKilcbiAgICAgIG11dGFibGUgc2NoZWR1bGVkX2F0IDogVGltZV9ucy50XG4gICAgOyB0aW1lX3NvdXJjZSA6IFN5bmNocm9ub3VzX3RpbWVfc291cmNlMC50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG4gIHR5cGUgdF91bml0ID0gKHVuaXQsIHVuaXQpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgZmlyZWQgdCA9IEl2YXIucmVhZCB0LmZpcmVkXG5cbiAgbGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSBpbnZhcmlhbnRfaCB0ID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IChfLCBfKSB0XSAoZnVuICgpIC0+XG4gICAgICBsZXQgZXZlbnRzID0gdC50aW1lX3NvdXJjZS5ldmVudHMgaW5cbiAgICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgfmFsYXJtOlxuICAgICAgICAgIChjaGVjayAoZnVuIGFsYXJtIC0+XG4gICAgICAgICAgICAgaWYgSXZhci5pc19mdWxsIHQuZmlyZWRcbiAgICAgICAgICAgICB0aGVuIGFzc2VydCAobm90IChUaW1pbmdfd2hlZWwubWVtIGV2ZW50cyBhbGFybSkpXG4gICAgICAgICAgICAgZWxzZSBpZiBUaW1pbmdfd2hlZWwubWVtIGV2ZW50cyBhbGFybVxuICAgICAgICAgICAgIHRoZW4gYXNzZXJ0IChKb2Jfb3JfZXZlbnQuaXNfam9iIChBbGFybS52YWx1ZSBldmVudHMgYWxhcm0pKSkpXG4gICAgICAgIH5maXJlOmlnbm9yZVxuICAgICAgICB+ZmlyZWQ6XG4gICAgICAgICAgKGNoZWNrIChmdW4gKGZpcmVkIDogXyBGaXJlZC50IEl2YXIudCkgLT5cbiAgICAgICAgICAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChJdmFyLnJlYWQgZmlyZWQpIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgICB8IFNvbWUgKEFib3J0ZWQgYSkgLT4gaW52YXJpYW50X2EgYVxuICAgICAgICAgICAgIHwgU29tZSAoSGFwcGVuZWQgaCkgLT4gaW52YXJpYW50X2ggaCkpXG4gICAgICAgIH5udW1fZmlyZXNfdG9fc2tpcDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBudW1fZmlyZXNfdG9fc2tpcCAtPiBhc3NlcnQgKG51bV9maXJlc190b19za2lwID49IDApKSlcbiAgICAgICAgfnNjaGVkdWxlZF9hdDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBzY2hlZHVsZWRfYXQgLT5cbiAgICAgICAgICAgICBpZiBUaW1pbmdfd2hlZWwubWVtIGV2ZW50cyB0LmFsYXJtXG4gICAgICAgICAgICAgdGhlbiBbJXRlc3RfcmVzdWx0OiBUaW1lX25zLnRdIHNjaGVkdWxlZF9hdCB+ZXhwZWN0OihBbGFybS5hdCBldmVudHMgdC5hbGFybSkpKVxuICAgICAgICB+dGltZV9zb3VyY2U6aWdub3JlKVxuICA7O1xuXG4gIG1vZHVsZSBTdGF0dXMgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2gpIHQgPVxuICAgICAgfCBBYm9ydGVkIG9mICdhXG4gICAgICB8IEhhcHBlbmVkIG9mICdoXG4gICAgICB8IFNjaGVkdWxlZF9hdCBvZiBUaW1lX25zLnRcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICBsZXQgc3RhdHVzIHQgOiBfIFN0YXR1cy50ID1cbiAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChJdmFyLnJlYWQgdC5maXJlZCkgd2l0aFxuICAgIHwgTm9uZSAtPiBTY2hlZHVsZWRfYXQgdC5zY2hlZHVsZWRfYXRcbiAgICB8IFNvbWUgKEFib3J0ZWQgYSkgLT4gQWJvcnRlZCBhXG4gICAgfCBTb21lIChIYXBwZW5lZCBoKSAtPiBIYXBwZW5lZCBoXG4gIDs7XG5cbiAgbW9kdWxlIEFib3J0X3Jlc3VsdCA9IHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnaCkgdCA9XG4gICAgICB8IE9rXG4gICAgICB8IFByZXZpb3VzbHlfYWJvcnRlZCBvZiAnYVxuICAgICAgfCBQcmV2aW91c2x5X2hhcHBlbmVkIG9mICdoXG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgbGV0IGFib3J0IHQgYSA6IF8gQWJvcnRfcmVzdWx0LnQgPVxuICAgIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nIFwiVGltZV9zb3VyY2UuRXZlbnQuYWJvcnRcIiB0IFslc2V4cF9vZjogKF8sIF8pIHRdO1xuICAgIG1hdGNoIERlZmVycmVkLnBlZWsgKGZpcmVkIHQpIHdpdGhcbiAgICB8IFNvbWUgKEFib3J0ZWQgYSkgLT4gUHJldmlvdXNseV9hYm9ydGVkIGFcbiAgICB8IFNvbWUgKEhhcHBlbmVkIGgpIC0+IFByZXZpb3VzbHlfaGFwcGVuZWQgaFxuICAgIHwgTm9uZSAtPlxuICAgICAgSXZhci5maWxsX2V4biB0LmZpcmVkIChBYm9ydGVkIGEpO1xuICAgICAgcmVtb3ZlX2FsYXJtX2lmX3NjaGVkdWxlZCB0LnRpbWVfc291cmNlIHQuYWxhcm07XG4gICAgICBPa1xuICA7O1xuXG4gIGxldCBhYm9ydF9leG4gdCBhID1cbiAgICBtYXRjaCBhYm9ydCB0IGEgd2l0aFxuICAgIHwgT2sgLT4gKClcbiAgICB8IFByZXZpb3VzbHlfaGFwcGVuZWQgXyAtPlxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2UgXCJDbG9jay5FdmVudC5hYm9ydF9leG4gZmFpbGVkIHRvIGFib3J0IGV2ZW50IHRoYXQgcHJldmlvdXNseSBoYXBwZW5lZFwiXVxuICAgIHwgUHJldmlvdXNseV9hYm9ydGVkIF8gLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlIFwiQ2xvY2suRXZlbnQuYWJvcnRfZXhuIGZhaWxlZCB0byBhYm9ydCBldmVudCB0aGF0IHByZXZpb3VzbHkgYWJvcnRlZFwiXVxuICA7O1xuXG4gIGxldCBhYm9ydF9pZl9wb3NzaWJsZSB0IGEgPSBpZ25vcmUgKGFib3J0IHQgYSA6IF8gQWJvcnRfcmVzdWx0LnQpXG4gIGxldCBzY2hlZHVsZSB0ID0gdC5hbGFybSA8LSBydW5fYXRfaW50ZXJuYWwgdC50aW1lX3NvdXJjZSB0LnNjaGVkdWxlZF9hdCB0LmZpcmUgKClcblxuICBtb2R1bGUgUmVzY2hlZHVsZV9yZXN1bHQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2gpIHQgPVxuICAgICAgfCBPa1xuICAgICAgfCBQcmV2aW91c2x5X2Fib3J0ZWQgb2YgJ2FcbiAgICAgIHwgUHJldmlvdXNseV9oYXBwZW5lZCBvZiAnaFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIGxldCByZXNjaGVkdWxlX2F0IHQgYXQgOiBfIFJlc2NoZWR1bGVfcmVzdWx0LnQgPVxuICAgIGlmIGRlYnVnXG4gICAgdGhlblxuICAgICAgRGVidWcubG9nIFwiVGltZV9zb3VyY2UuRXZlbnQucmVzY2hlZHVsZV9hdFwiICh0LCBhdCkgWyVzZXhwX29mOiAoXywgXykgdCAqIFRpbWVfbnMudF07XG4gICAgbWF0Y2ggRGVmZXJyZWQucGVlayAoZmlyZWQgdCkgd2l0aFxuICAgIHwgU29tZSAoQWJvcnRlZCBhKSAtPiBQcmV2aW91c2x5X2Fib3J0ZWQgYVxuICAgIHwgU29tZSAoSGFwcGVuZWQgaCkgLT4gUHJldmlvdXNseV9oYXBwZW5lZCBoXG4gICAgfCBOb25lIC0+XG4gICAgICBsZXQgZXZlbnRzID0gdC50aW1lX3NvdXJjZS5ldmVudHMgaW5cbiAgICAgIGxldCBpc19pbl90aW1pbmdfd2hlZWwgPSBUaW1pbmdfd2hlZWwubWVtIGV2ZW50cyB0LmFsYXJtIGluXG4gICAgICBsZXQgYW1fdHJ5aW5nX3RvX3Jlc2NoZWR1bGVfaW5fdGhlX2Z1dHVyZSA9XG4gICAgICAgIFRpbWVfbnMuKCA+ICkgYXQgKFRpbWluZ193aGVlbC5ub3cgZXZlbnRzKVxuICAgICAgaW5cbiAgICAgIHQuc2NoZWR1bGVkX2F0IDwtIGF0O1xuICAgICAgKG1hdGNoIGFtX3RyeWluZ190b19yZXNjaGVkdWxlX2luX3RoZV9mdXR1cmUsIGlzX2luX3RpbWluZ193aGVlbCB3aXRoXG4gICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gKClcbiAgICAgICB8IGZhbHNlLCB0cnVlIC0+XG4gICAgICAgICB0LnRpbWVfc291cmNlLmhhbmRsZV9maXJlZCB0LmFsYXJtO1xuICAgICAgICAgVGltaW5nX3doZWVsLnJlbW92ZSBldmVudHMgdC5hbGFybVxuICAgICAgIHwgdHJ1ZSwgZmFsc2UgLT5cbiAgICAgICAgIHQubnVtX2ZpcmVzX3RvX3NraXAgPC0gdC5udW1fZmlyZXNfdG9fc2tpcCArIDE7XG4gICAgICAgICBzY2hlZHVsZSB0XG4gICAgICAgfCB0cnVlLCB0cnVlIC0+IFRpbWluZ193aGVlbC5yZXNjaGVkdWxlIGV2ZW50cyB0LmFsYXJtIH5hdCk7XG4gICAgICBPa1xuICA7O1xuXG4gIGxldCByZXNjaGVkdWxlX2FmdGVyIHQgc3BhbiA9IHJlc2NoZWR1bGVfYXQgdCAoc3Bhbl90b190aW1lIHQudGltZV9zb3VyY2Ugc3BhbilcblxuICBsZXQgcnVuX2F0IHRpbWVfc291cmNlIHNjaGVkdWxlZF9hdCBmIHogPVxuICAgIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nIFwiVGltZV9zb3VyY2UuRXZlbnQucnVuX2F0XCIgc2NoZWR1bGVkX2F0IFslc2V4cF9vZjogVGltZV9ucy50XTtcbiAgICBsZXQgdCA9XG4gICAgICB7IGFsYXJtID0gQWxhcm0ubnVsbCAoKVxuICAgICAgOyBmaXJlID0gaWdub3JlICgqIHNldCBiZWxvdyAqKVxuICAgICAgOyBmaXJlZCA9IEl2YXIuY3JlYXRlICgpXG4gICAgICA7IG51bV9maXJlc190b19za2lwID0gMFxuICAgICAgOyBzY2hlZHVsZWRfYXRcbiAgICAgIDsgdGltZV9zb3VyY2UgPSByZWFkX29ubHkgdGltZV9zb3VyY2VcbiAgICAgIH1cbiAgICBpblxuICAgIGxldCBmaXJlICgpID1cbiAgICAgICgqIFtmaXJlXSBydW5zIGluIGFuIEFzeW5jIGpvYi4gIFRoZSBldmVudCBtYXkgaGF2ZSBiZWVuIGFib3J0ZWQgYWZ0ZXIgdGhlIGpvYlxuICAgICAgICAgd2FzIGVucXVldWVkLCBzbyBbZmlyZV0gbXVzdCBjaGVjayBbZmlyZWRdLiAqKVxuICAgICAgaWYgSXZhci5pc19lbXB0eSB0LmZpcmVkXG4gICAgICB0aGVuXG4gICAgICAgIGlmIHQubnVtX2ZpcmVzX3RvX3NraXAgPiAwXG4gICAgICAgIHRoZW4gdC5udW1fZmlyZXNfdG9fc2tpcCA8LSB0Lm51bV9maXJlc190b19za2lwIC0gMVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZiB6IGluXG4gICAgICAgICAgKCogW2Ygel0gbWF5IGhhdmUgYWJvcnRlZCB0aGUgZXZlbnQsIHNvIHdlIG11c3QgY2hlY2sgW2ZpcmVkXSBhZ2Fpbi4gKilcbiAgICAgICAgICBpZiBJdmFyLmlzX2VtcHR5IHQuZmlyZWQgdGhlbiBJdmFyLmZpbGxfZXhuIHQuZmlyZWQgKEhhcHBlbmVkIHJlc3VsdCkpXG4gICAgaW5cbiAgICB0LmZpcmUgPC0gZmlyZTtcbiAgICBzY2hlZHVsZSB0O1xuICAgIHRcbiAgOztcblxuICBsZXQgYXQgdGltZV9zb3VyY2UgdGltZSA9IHJ1bl9hdCB0aW1lX3NvdXJjZSB0aW1lIGlnbm9yZSAoKVxuXG4gIGxldCBydW5fYWZ0ZXIgdGltZV9zb3VyY2Ugc3BhbiBmIGEgPVxuICAgIHJ1bl9hdCB0aW1lX3NvdXJjZSAoc3Bhbl90b190aW1lIHRpbWVfc291cmNlIHNwYW4pIGYgYVxuICA7O1xuXG4gIGxldCBhZnRlciB0aW1lX3NvdXJjZSBzcGFuID0gYXQgdGltZV9zb3VyY2UgKHNwYW5fdG9fdGltZSB0aW1lX3NvdXJjZSBzcGFuKVxuZW5kXG5cbmxldCBhdF90aW1lcyA/KHN0b3AgPSBEZWZlcnJlZC5uZXZlciAoKSkgdCBuZXh0X3RpbWUgPVxuICBsZXQgdGFpbCA9IFRhaWwuY3JlYXRlICgpIGluXG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgY2hvb3NlXG4gICAgICBbIGNob2ljZSBzdG9wIChmdW4gKCkgLT4gYFN0b3ApOyBjaG9pY2UgKGF0IHQgKG5leHRfdGltZSAoKSkpIChmdW4gKCkgLT4gYFRpY2spIF1cbiAgICA+Pj4gZnVuY3Rpb25cbiAgICB8IGBTdG9wIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWxcbiAgICB8IGBUaWNrIC0+XG4gICAgICBUYWlsLmV4dGVuZCB0YWlsICgpO1xuICAgICAgbG9vcCAoKVxuICBpblxuICBsb29wICgpO1xuICBUYWlsLmNvbGxlY3QgdGFpbFxuOztcblxubGV0IGF0X3ZhcnlpbmdfaW50ZXJ2YWxzID9zdG9wIHQgY29tcHV0ZV9zcGFuID1cbiAgYXRfdGltZXMgdCA/c3RvcCAoZnVuICgpIC0+IFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSAoY29tcHV0ZV9zcGFuICgpKSlcbjs7XG5cbmxldCBhdF9pbnRlcnZhbHMgP3N0YXJ0ID9zdG9wIHQgaW50ZXJ2YWwgPVxuICBsZXQgc3RhcnQgPVxuICAgIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICB8IFNvbWUgeCAtPiB4XG4gICAgfCBOb25lIC0+IG5vdyB0XG4gIGluXG4gIGF0X3RpbWVzIHQgP3N0b3AgKGZ1biAoKSAtPlxuICAgIFRpbWVfbnMubmV4dF9tdWx0aXBsZSB+YmFzZTpzdGFydCB+YWZ0ZXI6KG5vdyB0KSB+aW50ZXJ2YWwgKCkpXG47O1xuXG5tb2R1bGUgQ29udGludWUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEltbWVkaWF0ZWx5XG4gICAgfCBBZnRlciBvZiBUaW1lX25zLlNwYW4udFxuICAgIHwgTmV4dF9tdWx0aXBsZSBvZiBUaW1lX25zLnQgKiBUaW1lX25zLlNwYW4udFxuXG4gIGxldCBpbW1lZGlhdGVseSA9IEltbWVkaWF0ZWx5XG5cbiAgbGV0IGF0IHQgdGltZV9zb3VyY2UgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgSW1tZWRpYXRlbHkgLT4gVGltaW5nX3doZWVsLm5vdyB0aW1lX3NvdXJjZS5ldmVudHNcbiAgICB8IEFmdGVyIHNwYW4gLT4gc3Bhbl90b190aW1lIHRpbWVfc291cmNlIHNwYW5cbiAgICB8IE5leHRfbXVsdGlwbGUgKGJhc2UsIGludGVydmFsKSAtPlxuICAgICAgVGltZV9ucy5uZXh0X211bHRpcGxlIH5iYXNlIH5hZnRlcjoobm93IHRpbWVfc291cmNlKSB+aW50ZXJ2YWwgKClcbiAgOztcbmVuZFxuXG5sZXQgcnVuX3JlcGVhdGVkbHlcbiAgPyhzdGFydCA9IHJldHVybiAoKSlcbiAgP3N0b3BcbiAgPyhjb250aW51ZV9vbl9lcnJvciA9IHRydWUpXG4gID8oZmluaXNoZWQgPSBJdmFyLmNyZWF0ZSAoKSlcbiAgdFxuICB+ZlxuICB+Y29udGludWVcbiAgPVxuICBzdGFydFxuICA+Pj4gZnVuICgpIC0+XG4gIGxldCBhbGFybSA9IHJlZiAoQWxhcm0ubnVsbCAoKSkgaW5cbiAgbGV0IHN0b3AgPVxuICAgIG1hdGNoIHN0b3Agd2l0aFxuICAgIHwgTm9uZSAtPiBEZWZlcnJlZC5uZXZlciAoKVxuICAgIHwgU29tZSBzdG9wIC0+XG4gICAgICB1cG9uIHN0b3AgKGZ1biAoKSAtPlxuICAgICAgICBpZiBUaW1pbmdfd2hlZWwubWVtIHQuZXZlbnRzICFhbGFybVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICByZW1vdmVfYWxhcm0gdCAhYWxhcm07XG4gICAgICAgICAgSXZhci5maWxsX2lmX2VtcHR5IGZpbmlzaGVkICgpKSk7XG4gICAgICBzdG9wXG4gIGluXG4gICgqIFtydW5fZl0sIFtjb250aW51ZV9mXSwgYW5kIFtjb250aW51ZV90cnlfd2l0aF0gYXJlIGRlZmluZWQgc28gdGhhdCB3ZSBhbGxvY2F0ZSB0aGVpclxuICAgICBjbG9zdXJlcyBvbmNlLCBub3Qgb25jZSBwZXIgaXRlcmF0aW9uLiAqKVxuICBsZXQgcmVjIHJ1bl9mICgpID1cbiAgICAoKiBCZWZvcmUgY2FsbGluZyBbZl0sIHdlIHN5bmNocm9ub3VzbHkgY2hlY2sgd2hldGhlciBbc3RvcF0gaXMgZGV0ZXJtaW5lZC4gKilcbiAgICBpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIHN0b3BcbiAgICB0aGVuIEl2YXIuZmlsbF9pZl9lbXB0eSBmaW5pc2hlZCAoKVxuICAgIGVsc2UgaWYgY29udGludWVfb25fZXJyb3JcbiAgICB0aGVuIE1vbml0b3IudHJ5X3dpdGggZiB+cnVuOmBOb3cgfnJlc3Q6YFJhaXNlID4+PiBjb250aW51ZV90cnlfd2l0aFxuICAgIGVsc2UgKFxuICAgICAgbGV0IGQgPSBmICgpIGluXG4gICAgICBpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIGQgdGhlbiBjb250aW51ZV9mICgpIGVsc2UgZCA+Pj4gY29udGludWVfZilcbiAgYW5kIGNvbnRpbnVlX2YgKCkgPVxuICAgIGlmIERlZmVycmVkLmlzX2RldGVybWluZWQgc3RvcFxuICAgIHRoZW4gSXZhci5maWxsX2lmX2VtcHR5IGZpbmlzaGVkICgpXG4gICAgZWxzZSBhbGFybSA6PSBydW5fYXRfaW50ZXJuYWwgdCAoQ29udGludWUuYXQgY29udGludWUgdCkgcnVuX2YgKClcbiAgYW5kIGNvbnRpbnVlX3RyeV93aXRoIG9yX2Vycm9yID1cbiAgICAobWF0Y2ggb3JfZXJyb3Igd2l0aFxuICAgICB8IE9rICgpIC0+ICgpXG4gICAgIHwgRXJyb3IgZXJyb3IgLT4gTW9uaXRvci5zZW5kX2V4biAoTW9uaXRvci5jdXJyZW50ICgpKSBlcnJvcik7XG4gICAgY29udGludWVfZiAoKVxuICBpblxuICBydW5fZiAoKVxuOztcblxubGV0IGV2ZXJ5JyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yID9maW5pc2hlZCB0IHNwYW4gZiA9XG4gIGlmIFRpbWVfbnMuU3Bhbi4oIDw9ICkgc3BhbiBUaW1lX25zLlNwYW4uemVyb1xuICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiVGltZV9zb3VyY2UuZXZlcnkgZ290IG5vbnBvc2l0aXZlIHNwYW5cIiAoc3BhbiA6IFRpbWVfbnMuU3Bhbi50KV07XG4gIHJ1bl9yZXBlYXRlZGx5IHQgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciA/ZmluaXNoZWQgfmYgfmNvbnRpbnVlOihBZnRlciBzcGFuKVxuOztcblxubGV0IGV2ZXJ5ID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgdCBzcGFuIGYgPVxuICBldmVyeScgdCA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yID9maW5pc2hlZDpOb25lIHNwYW4gKGZ1biAoKSAtPlxuICAgIGYgKCk7XG4gICAgcmV0dXJuICgpKVxuOztcblxubGV0IHJ1bl9hdF9pbnRlcnZhbHMnID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgdCBpbnRlcnZhbCBmID1cbiAgbGV0IG5vdyA9IG5vdyB0IGluXG4gIGxldCBiYXNlLCBzdGFydCA9XG4gICAgbWF0Y2ggc3RhcnQgd2l0aFxuICAgIHwgTm9uZSAtPiBub3csIE5vbmVcbiAgICB8IFNvbWUgc3RhcnQgLT5cbiAgICAgICggc3RhcnRcbiAgICAgICwgU29tZVxuICAgICAgICAgIChhdFxuICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAoVGltZV9ucy5uZXh0X211bHRpcGxlXG4gICAgICAgICAgICAgICAgKClcbiAgICAgICAgICAgICAgICB+YmFzZTpzdGFydFxuICAgICAgICAgICAgICAgIH5hZnRlcjpub3dcbiAgICAgICAgICAgICAgICB+Y2FuX2VxdWFsX2FmdGVyOnRydWVcbiAgICAgICAgICAgICAgICB+aW50ZXJ2YWwpKSApXG4gIGluXG4gIHJ1bl9yZXBlYXRlZGx5XG4gICAgdFxuICAgID9zdGFydFxuICAgID9zdG9wXG4gICAgP2NvbnRpbnVlX29uX2Vycm9yXG4gICAgfmZcbiAgICB+Y29udGludWU6KE5leHRfbXVsdGlwbGUgKGJhc2UsIGludGVydmFsKSlcbjs7XG5cbmxldCBydW5fYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgdCBpbnRlcnZhbCBmID1cbiAgcnVuX2F0X2ludGVydmFscycgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciB0IGludGVydmFsIChmdW4gKCkgLT5cbiAgICBmICgpO1xuICAgIHJldHVybiAoKSlcbjs7XG5cbmxldCB3aXRoX3RpbWVvdXQgdCBzcGFuIGQgPVxuICBsZXQgdGltZW91dCA9IEV2ZW50LmFmdGVyIHQgc3BhbiBpblxuICBjaG9vc2VcbiAgICAoKiBUaGUgY29kZSBiZWxvdyBkb2VzIGV4aGF1c3RpdmUgY2FzZSBhbmFseXNpcyBpbiBib3RoIFtjaG9pY2Vdcy4gIEJlY2F1c2UgW3RpbWVvdXRdXG4gICAgICAgZG9lcyBub3QgZXNjYXBlIHRoZSBzY29wZSBvZiB0aGlzIGZ1bmN0aW9uLCBjZXJ0YWluIGNhc2VzIHNob3VsZCBiZSBpbXBvc3NpYmxlLCBhbmRcbiAgICAgICBhcmUgbWFya2VkIGFzIHN1Y2ggd2l0aCBleGNlcHRpb25zLiAgV2UgZG8gbm90IGV4cGVjdCB0aG9zZSBleGNlcHRpb25zIHRvIG9jY3VyLFxuICAgICAgIGJ1dCBpZiB0aGV5IGRvLCBpdCBsaWtlbHkgaW5kaWNhdGVzIGEgYnVnIGluIFtjaG9vc2VdIHJhdGhlciB0aGFuXG4gICAgICAgW3dpdGhfdGltZW91dF0uICopXG4gICAgWyBjaG9pY2UgZCAoZnVuIHYgLT5cbiAgICAgICAgKG1hdGNoIEV2ZW50LmFib3J0IHRpbWVvdXQgKCkgd2l0aFxuICAgICAgICAgKCogW1ByZXZpb3VzbHlfaGFwcGVuZWRdIGNhbiBvY2N1ciBpZiBib3RoIFtkXSBhbmQgW3dhaXRdIGJlY29tZSBkZXRlcm1pbmVkIGF0XG4gICAgICAgICAgICB0aGUgc2FtZSB0aW1lLCBlLmcuIFt3aXRoX3RpbWVvdXQgKHNlYyAwLikgKHJldHVybiAoKSldLiAqKVxuICAgICAgICAgfCBPayB8IFByZXZpb3VzbHlfaGFwcGVuZWQgKCkgLT4gKClcbiAgICAgICAgIHwgUHJldmlvdXNseV9hYm9ydGVkICgpIC0+XG4gICAgICAgICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiVGltZV9zb3VyY2Uud2l0aF90aW1lb3V0IGJ1Zzogc2hvdWxkIG9ubHkgYWJvcnQgb25jZVwiXSk7XG4gICAgICAgIGBSZXN1bHQgdilcbiAgICA7IGNob2ljZSAoRXZlbnQuZmlyZWQgdGltZW91dCkgKGZ1bmN0aW9uXG4gICAgICAgIHwgSGFwcGVuZWQgKCkgLT4gYFRpbWVvdXRcbiAgICAgICAgfCBBYm9ydGVkICgpIC0+XG4gICAgICAgICAgcmFpc2VfcyBbJW1lc3NhZ2UgXCJUaW1lX3NvdXJjZS53aXRoX3RpbWVvdXQgYnVnOiBib3RoIGNvbXBsZXRlZCBhbmQgdGltZWQgb3V0XCJdKVxuICAgIF1cbjs7XG5cbmxldCB3aXRoX3RpbWVvdXRfZXhuIHQgc3BhbiBkIH5lcnJvciA9XG4gIERlZmVycmVkLm1hcCAod2l0aF90aW1lb3V0IHQgc3BhbiBkKSB+ZjooZnVuY3Rpb25cbiAgICB8IGBSZXN1bHQgcmVzdWx0IC0+IHJlc3VsdFxuICAgIHwgYFRpbWVvdXQgLT4gRXJyb3IucmFpc2UgZXJyb3IpXG47O1xuXG5sZXQgZHVyYXRpb25fb2YgdCBmID1cbiAgbGV0IHN0YXJ0ID0gbm93IHQgaW5cbiAgKCogRWFnZXIgbWFwIHRvIHByb3ZpZGUgbW9yZSBhY2N1cmF0ZSB0aW1pbmdzIHdoZW4gW2ZdIGlzIHN5bmNocm9ub3VzLiAqKVxuICBFYWdlcl9kZWZlcnJlZC5tYXAgKGYgKCkpIH5mOihmdW4gcmVzdWx0IC0+XG4gICAgbGV0IGR1cmF0aW9uID0gVGltZV9ucy5kaWZmIChub3cgdCkgc3RhcnQgaW5cbiAgICByZXN1bHQsIGR1cmF0aW9uKVxuOztcblxubGV0IG9mX3N5bmNocm9ub3VzIHQgPSB0XG5sZXQgdG9fc3luY2hyb25vdXMgdCA9IHRcblxubGV0IHRpbWluZ193aGVlbF9oYXNfZXZlbnRfYXRfb3JfYmVmb3JlIHdoZWVsIHRpbWUgPVxuICBpZiBUaW1pbmdfd2hlZWwuaXNfZW1wdHkgd2hlZWxcbiAgdGhlbiBmYWxzZVxuICBlbHNlIChcbiAgICBsZXQgbmV4dF9hbGFybSA9IFRpbWluZ193aGVlbC5uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biB3aGVlbCBpblxuICAgIFRpbWVfbnNfaW5fdGhpc19kaXJlY3RvcnkuKG5leHRfYWxhcm0gPD0gdGltZSkpXG47O1xuXG5sZXQgYWR2YW5jZV9kaXJlY3RseV9pZl9xdWllc2NlbnQgdCB+dG9fID1cbiAgbGV0IGlzX3F1ZXNjZW50ID1cbiAgICAoKiBTaW5jZSB0aGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIHRvIGJlIGp1c3QgYSBmYXN0IGNhc2Ugb2YgW2FkdmFuY2VfYnlfYWxhcm1zXSxcbiAgICAgICB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBjYWxsIHRvIFtTY2hlZHVsZXIueWllbGQgKCldIGNhbiBiZSBlbGlkZWQsXG4gICAgICAgaGVuY2UgdGhlIFtjYW5fcnVuX2Ffam9iXSBjaGVjay5cblxuICAgICAgIFdlJ3JlIG5vdCBjaGVja2luZyBlcG9sbCwgYW5kIHdlJ3JlIG5vdCBjaGVja2luZyB0aGUgW2V4dGVybmFsX2pvYnNdLiAgVGhhdCBpcyBhblxuICAgICAgIG9ic2VydmFibGUgZGlmZmVyZW5jZSwgYnV0IHNpbmNlIFthZHZhbmNlX2J5X2FsYXJtcyA/d2FpdF9mb3I6Tm9uZV0gaXMgYWxyZWFkeVxuICAgICAgIHByZXR0eSBicm9rZW4gd2hlbiB3YWl0aW5nIGZvciBleHRlcm5hbCBldmVudHMsIGl0J3Mgbm90IGdvaW5nIHRvIGJlIG1lYW5pbmdmdWwuXG4gICAgKilcbiAgICBjYW5fcnVuX2Ffam9iIHQuc2NoZWR1bGVyXG4gICAgfHwgU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLmhhc19ldmVudHNfdG9fcnVuIHRcbiAgICB8fCB0aW1pbmdfd2hlZWxfaGFzX2V2ZW50X2F0X29yX2JlZm9yZSB0LmV2ZW50cyB0b19cbiAgaW5cbiAgaWYgaXNfcXVlc2NlbnRcbiAgdGhlbiBmYWxzZVxuICBlbHNlIChcbiAgICBhZHZhbmNlX2RpcmVjdGx5IHQgfnRvXztcbiAgICB0cnVlKVxuOztcbiIsInR5cGUgdCA9IHVuaXQgLT4gdW5pdFxuXG5tb2R1bGUgSGFuZGxlID0gc3RydWN0XG4gIHR5cGUgdCA9IFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlLnRcbmVuZFxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuISBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxubW9kdWxlIFNjaGVkdWxlciA9IFNjaGVkdWxlcjFcbm1vZHVsZSBTdHJlYW0gPSBBc3luY19zdHJlYW1cbmluY2x1ZGUgKFNjaGVkdWxlciA6IG1vZHVsZSB0eXBlIG9mIFNjaGVkdWxlciB3aXRoIG1vZHVsZSBCdmFyIDo9IFNjaGVkdWxlci5CdmFyKVxuXG5sZXQgdCA9IFNjaGVkdWxlci50XG5cbmluY2x1ZGUgTW9uaXRvci5FeHBvcnRlZF9mb3Jfc2NoZWR1bGVyXG5cbmxldCBmaW5kX2xvY2FsIGtleSA9IEV4ZWN1dGlvbl9jb250ZXh0LmZpbmRfbG9jYWwgKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpKSBrZXlcblxubGV0IHdpdGhfbG9jYWwga2V5IHZhbHVlIH5mID1cbiAgbGV0IHQgPSB0ICgpIGluXG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9XG4gICAgRXhlY3V0aW9uX2NvbnRleHQud2l0aF9sb2NhbCAoY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0KSBrZXkgdmFsdWVcbiAgaW5cbiAgd2l0aF9leGVjdXRpb25fY29udGV4dCB0IGV4ZWN1dGlvbl9jb250ZXh0IH5mXG47O1xuXG5sZXQgbWFpbl9leGVjdXRpb25fY29udGV4dCA9ICh0ICgpKS5tYWluX2V4ZWN1dGlvbl9jb250ZXh0XG5cbmxldCBjYW5fcnVuX2Ffam9iIHQgPVxuICBudW1fcGVuZGluZ19qb2JzIHQgPiAwXG4gIHx8IEJ2YXIuaGFzX2FueV93YWl0ZXJzIHQueWllbGRcbiAgfHwgQnZhci5oYXNfYW55X3dhaXRlcnMgdC55aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpblxuOztcblxubGV0IGhhc191cGNvbWluZ19ldmVudCB0ID0gbm90IChUaW1pbmdfd2hlZWwuaXNfZW1wdHkgKGV2ZW50cyB0KSlcbmxldCBuZXh0X3VwY29taW5nX2V2ZW50IHQgPSBUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdCAoZXZlbnRzIHQpXG5sZXQgbmV4dF91cGNvbWluZ19ldmVudF9leG4gdCA9IFRpbWluZ193aGVlbC5uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4biAoZXZlbnRzIHQpXG5sZXQgZXZlbnRfcHJlY2lzaW9uIHQgPSBUaW1pbmdfd2hlZWwuYWxhcm1fcHJlY2lzaW9uIChldmVudHMgdClcbmxldCBjeWNsZV9zdGFydCB0ID0gdC5jeWNsZV9zdGFydFxuXG5sZXQgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IHQgfmYgPVxuICAoKiBVc2luZyBhbiBhcnJheSByYXRoZXIgdGhhbiBhIGxpc3QgZm9yIGNhY2hlIGVmZmljaWVuY3kuIFRoaXMgYW5kXG4gICAgIFtydW5fZXZlcnlfY3ljbGVfZW5kXSBzaG91bGQgb25seSBiZSBjYWxsZWQgZHVyaW5nIHByb2dyYW0gaW5pdGlhbGl6YXRpb24sIHNvIHRoZVxuICAgICBhbGxvY2F0aW9uIGFuZCBnYXJiYWdlIGNyZWF0aW9uIHNob3VsZCBub3QgYmUgYW4gaXNzdWUuXG5cbiAgICAgTm90ZSB0aGF0IGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBOIHRpbWVzIHRha2VzIE8oTl4yKSB0aW1lLCBidXQgdGhpcyBzaG91bGQgYmUgZmluZVxuICAgICBiZWNhdXNlIE4gaXMgc21hbGwuIFNhbWUgZm9yIFtydW5fZXZlcnlfY3ljbGVfZW5kXS4gKilcbiAgdC5ydW5fZXZlcnlfY3ljbGVfc3RhcnQgPC0gQXJyYXkuYXBwZW5kIFt8IGYgfF0gdC5ydW5fZXZlcnlfY3ljbGVfc3RhcnRcbjs7XG5cbmxldCBydW5fZXZlcnlfY3ljbGVfZW5kIHQgfmYgPVxuICB0LnJ1bl9ldmVyeV9jeWNsZV9lbmQgPC0gQXJyYXkuYXBwZW5kIFt8IGYgfF0gdC5ydW5fZXZlcnlfY3ljbGVfZW5kXG47O1xuXG5sZXQgYWRkX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2sgdCB+ZiA9XG4gIGxldCBoYW5kbGUgPSBUeXBlcy5DeWNsZV9ob29rX2hhbmRsZS5jcmVhdGUgKCkgaW5cbiAgSGFzaHRibC5hZGRfZXhuIHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0X3N0YXRlIH5rZXk6aGFuZGxlIH5kYXRhOmY7XG4gIHJ1bl9ldmVyeV9jeWNsZV9zdGFydCB0IH5mO1xuICBoYW5kbGVcbjs7XG5cbmxldCBhZGRfZXZlcnlfY3ljbGVfZW5kX2hvb2sgdCB+ZiA9XG4gIGxldCBoYW5kbGUgPSBUeXBlcy5DeWNsZV9ob29rX2hhbmRsZS5jcmVhdGUgKCkgaW5cbiAgSGFzaHRibC5hZGRfZXhuIHQucnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZSB+a2V5OmhhbmRsZSB+ZGF0YTpmO1xuICBydW5fZXZlcnlfY3ljbGVfZW5kIHQgfmY7XG4gIGhhbmRsZVxuOztcblxubGV0IGFycmF5X3JlbW92ZV9maXJzdCBhcnIgfmYgPVxuICBtYXRjaCBBcnJheS5maW5kaSBhcnIgfmYgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgKGlkeCwgXykgLT5cbiAgICBTb21lXG4gICAgICAoQXJyYXkuaW5pdFxuICAgICAgICAgKEFycmF5Lmxlbmd0aCBhcnIgLSAxKVxuICAgICAgICAgfmY6KGZ1biBpIC0+IGlmIGkgPCBpZHggdGhlbiBhcnIuKGkpIGVsc2UgYXJyLihpICsgMSkpKVxuOztcblxubGV0IHJlbW92ZV9zaW5nbGVfY3ljbGVfaG9vayBhcnIgZiA9XG4gICgqIFJlbW92ZSBhIHNpbmdsZSBpbnN0YW5jZSBvZiBbZl0gZnJvbSBbYXJyXS4gTW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBtYXkgYmUgcHJlc2VudCxcbiAgICAgYnV0IHJlbW92YWwgaXMgcmVmZXJlbmNlLWNvdW50ZWQgYnkgW3J1bl9ldmVyeV9jeWNsZV8oc3RhcnR8ZW5kKV9zdGF0ZV0gdGFibGVzLiAqKVxuICBtYXRjaCBhcnJheV9yZW1vdmVfZmlyc3QgfmY6KGZ1biBfIGcgLT4gcGh5c19lcXVhbCBmIGcpIGFyciB3aXRoXG4gIHwgU29tZSBhcnIgLT4gYXJyXG4gIHwgTm9uZSAtPlxuICAgICgqIFRoaXMgc2hvdWxkIGJlIHVucmVhY2hhYmxlLCBzZWUgdGhlIFtpbnZhcmlhbnRdIGluIFtzY2hlZHVsZXIxLm1sXS4gKilcbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJTY2hlZHVsZXIucmVtb3ZlX3NpbmdsZV9jeWNsZV9ob29rIGNhbGxlZCB3aXRoIGEgaG9vayB0aGF0IGlzbid0IHJlZ2lzdGVyZWRcIl1cbjs7XG5cbmxldCByZW1vdmVfZXZlcnlfY3ljbGVfc3RhcnRfaG9va19leG4gdCBoYW5kbGUgPVxuICBtYXRjaCBIYXNodGJsLmZpbmRfYW5kX3JlbW92ZSB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZSBoYW5kbGUgd2l0aFxuICB8IE5vbmUgLT5cbiAgICBmYWlsd2l0aCBcIkF0dGVtcHRlZCB0byByZW1vdmUgYSBjeWNsZSBzdGFydCBob29rIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cIlxuICB8IFNvbWUgZiAtPlxuICAgIHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IDwtIHJlbW92ZV9zaW5nbGVfY3ljbGVfaG9vayB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydCBmXG47O1xuXG5sZXQgcmVtb3ZlX2V2ZXJ5X2N5Y2xlX2VuZF9ob29rX2V4biB0IGhhbmRsZSA9XG4gIG1hdGNoIEhhc2h0YmwuZmluZF9hbmRfcmVtb3ZlIHQucnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZSBoYW5kbGUgd2l0aFxuICB8IE5vbmUgLT5cbiAgICBmYWlsd2l0aCBcIkF0dGVtcHRlZCB0byByZW1vdmUgYSBjeWNsZSBlbmQgaG9vayB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXCJcbiAgfCBTb21lIGYgLT4gdC5ydW5fZXZlcnlfY3ljbGVfZW5kIDwtIHJlbW92ZV9zaW5nbGVfY3ljbGVfaG9vayB0LnJ1bl9ldmVyeV9jeWNsZV9lbmQgZlxuOztcblxubGV0IG1hcF9jeWNsZV90aW1lcyB0IH5mID1cbiAgU3RyZWFtLmNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBydW5fZXZlcnlfY3ljbGVfc3RhcnQgdCB+ZjooZnVuICgpIC0+IFRhaWwuZXh0ZW5kIHRhaWwgKGYgdC5sYXN0X2N5Y2xlX3RpbWUpKSlcbjs7XG5cbmxldCBsb25nX2N5Y2xlcyB0IH5hdF9sZWFzdCA9XG4gIFN0cmVhbS5jcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IHQgfmY6KGZ1biAoKSAtPlxuICAgICAgaWYgVGltZV9ucy5TcGFuLiggPj0gKSB0Lmxhc3RfY3ljbGVfdGltZSBhdF9sZWFzdFxuICAgICAgdGhlbiBUYWlsLmV4dGVuZCB0YWlsIHQubGFzdF9jeWNsZV90aW1lKSlcbjs7XG5cbmxldCBjeWNsZV9udW1fam9icyB0ID1cbiAgU3RyZWFtLmNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBydW5fZXZlcnlfY3ljbGVfc3RhcnQgdCB+ZjooZnVuICgpIC0+IFRhaWwuZXh0ZW5kIHRhaWwgdC5sYXN0X2N5Y2xlX251bV9qb2JzKSlcbjs7XG5cbmxldCBjeWNsZV9jb3VudCB0ID0gdC5jeWNsZV9jb3VudFxuXG5sZXQgc2V0X21heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlIHQgaW50ID1cbiAgdC5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZVxuICAgIDwtIE1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlLmNyZWF0ZV9leG4gaW50XG47O1xuXG5sZXQgbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgdCA9XG4gIE1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlLnJhdyB0Lm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlXG47O1xuXG5sZXQgc2V0X3RocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rIHQgZiA9IHQudGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2sgPC0gZlxuXG5sZXQgdGhyZWFkX3NhZmVfZW5xdWV1ZV9leHRlcm5hbF9qb2IgdCBleGVjdXRpb25fY29udGV4dCBmIGEgPVxuICBUaHJlYWRfc2FmZV9xdWV1ZS5lbnF1ZXVlIHQuZXh0ZXJuYWxfam9icyAoRXh0ZXJuYWxfam9iLlQgKGV4ZWN1dGlvbl9jb250ZXh0LCBmLCBhKSk7XG4gIHQudGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2sgKClcbjs7XG5cbmxldCBzZXRfZXZlbnRfYWRkZWRfaG9vayB0IGYgPSB0LmV2ZW50X2FkZGVkX2hvb2sgPC0gU29tZSBmXG5sZXQgc2V0X2pvYl9xdWV1ZWRfaG9vayB0IGYgPSB0LmpvYl9xdWV1ZWRfaG9vayA8LSBTb21lIGZcblxubGV0IGNyZWF0ZV9hbGFybSB0IGYgPVxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHQgaW5cbiAgR2MuRXhwZXJ0LkFsYXJtLmNyZWF0ZSAoZnVuICgpIC0+XG4gICAgdGhyZWFkX3NhZmVfZW5xdWV1ZV9leHRlcm5hbF9qb2IgdCBleGVjdXRpb25fY29udGV4dCBmICgpKVxuOztcblxubGV0IGFkZF9maW5hbGl6ZXIgdCBoZWFwX2Jsb2NrIGYgPVxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHQgaW5cbiAgbGV0IGZpbmFsaXplciBoZWFwX2Jsb2NrID1cbiAgICAoKiBIZXJlIHdlIGNhbiBiZSBpbiBhbnkgdGhyZWFkLCBhbmQgbWF5IG5vdCBiZSBob2xkaW5nIHRoZSBhc3luYyBsb2NrLiAgU28sIHdlIGNhblxuICAgICAgIG9ubHkgZG8gdGhyZWFkLXNhZmUgdGhpbmdzLlxuXG4gICAgICAgQnkgcHV0dGluZyBbaGVhcF9ibG9ja10gaW4gW2V4dGVybmFsX2pvYnNdLCB3ZSBhcmUga2VlcGluZyBpdCBhbGl2ZSB1bnRpbCB0aGUgbmV4dFxuICAgICAgIHRpbWUgdGhlIGFzeW5jIHNjaGVkdWxlciBnZXRzIGFyb3VuZCB0byBkZXF1ZXVlaW5nIGl0LiAgQ2FsbGluZ1xuICAgICAgIFt0LnRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rXSBlbnN1cmVzIHRoYXQgd2lsbCBoYXBwZW4gaW4gc2hvcnQgb3JkZXIuICBUaHVzLFxuICAgICAgIHdlIGFyZSBub3QgZHJhbWF0aWNhbGx5IGluY3JlYXNpbmcgdGhlIGxpZmV0aW1lIG9mIFtoZWFwX2Jsb2NrXSwgc2luY2UgdGhlIE9DYW1sXG4gICAgICAgcnVudGltZSBhbHJlYWR5IHJlc3VycmVjdGVkIFtoZWFwX2Jsb2NrXSBzbyB0aGF0IHdlIGNvdWxkIHJlZmVyIHRvIGl0IGhlcmUuICBUaGVcbiAgICAgICBPQ2FtbCBydW50aW1lIGFscmVhZHkgcmVtb3ZlZCB0aGUgZmluYWxpemVyIGZ1bmN0aW9uIHdoZW4gaXQgbm90aWNlZCBbaGVhcF9ibG9ja11cbiAgICAgICBjb3VsZCBiZSBmaW5hbGl6ZWQsIHNvIHRoZXJlIGlzIG5vIGluZmluaXRlIGxvb3AgaW4gd2hpY2ggd2UgYXJlIGNhdXNpbmcgdGhlXG4gICAgICAgZmluYWxpemVyIHRvIHJ1biBhZ2Fpbi4gIEFsc28sIE9DYW1sIGRvZXMgbm90IGltcG9zZSBhbnkgcmVxdWlyZW1lbnQgb24gZmluYWxpemVyXG4gICAgICAgZnVuY3Rpb25zIHRoYXQgdGhleSBuZWVkIHRvIGRpc3Bvc2Ugb2YgdGhlIGJsb2NrLCBzbyBpdCdzIGZpbmUgdGhhdCB3ZSBrZWVwXG4gICAgICAgW2hlYXBfYmxvY2tdIGFyb3VuZCB1bnRpbCBsYXRlci4gKilcbiAgICBpZiBEZWJ1Zy5maW5hbGl6ZXJzIHRoZW4gRGVidWcubG9nX3N0cmluZyBcImVucXVldWVpbmcgZmluYWxpemVyXCI7XG4gICAgdGhyZWFkX3NhZmVfZW5xdWV1ZV9leHRlcm5hbF9qb2IgdCBleGVjdXRpb25fY29udGV4dCBmIGhlYXBfYmxvY2tcbiAgaW5cbiAgaWYgRGVidWcuZmluYWxpemVycyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJhZGRpbmcgZmluYWxpemVyXCI7XG4gICgqIFdlIHVzZSBbQ2FtbC5HYy5maW5hbGlzZV0gaW5zdGVhZCBvZiBbQ29yZS5HYy5hZGRfZmluYWxpemVyXSBiZWNhdXNlIHRoZSBsYXR0ZXJcbiAgICAgaGFzIGl0cyBvd24gd3JhcHBlciBhcm91bmQgW0NhbWwuR2MuZmluYWxpc2VdIHRvIHJ1biBmaW5hbGl6ZXJzIHN5bmNocm9ub3VzbHkuICopXG4gIHRyeSBTdGRsaWIuR2MuZmluYWxpc2UgZmluYWxpemVyIGhlYXBfYmxvY2sgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPlxuICAgICgqIFtIZWFwX2Jsb2NrXSBlbnN1cmVzIHRoYXQgdGhpcyB3aWxsIG9ubHkgZmFpbCBmb3Igc3RhdGljIGRhdGEsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICAgICBjYW4gZHJvcCB0aGUgZmluYWxpemVyIHNpbmNlIHRoZSBibG9jayB3aWxsIG5ldmVyIGJlIGNvbGxlY3RlZC4qKVxuICAgICgpXG47O1xuXG5sZXQgYWRkX2ZpbmFsaXplcl9leG4gdCB4IGYgPVxuICBhZGRfZmluYWxpemVyIHQgKEhlYXBfYmxvY2suY3JlYXRlX2V4biB4KSAoZnVuIGhlYXBfYmxvY2sgLT5cbiAgICBmIChIZWFwX2Jsb2NrLnZhbHVlIGhlYXBfYmxvY2spKVxuOztcblxubGV0IGFkZF9maW5hbGl6ZXJfbGFzdCB0IGhlYXBfYmxvY2sgZiA9XG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdCBpblxuICBsZXQgZmluYWxpemVyICgpID1cbiAgICAoKiBIZXJlIHdlIGNhbiBiZSBpbiBhbnkgdGhyZWFkLCBhbmQgbWF5IG5vdCBiZSBob2xkaW5nIHRoZSBhc3luYyBsb2NrLiAgU28sIHdlIGNhblxuICAgICAgIG9ubHkgZG8gdGhyZWFkLXNhZmUgdGhpbmdzLiAqKVxuICAgIGlmIERlYnVnLmZpbmFsaXplcnNcbiAgICB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJlbnF1ZXVlaW5nIGZpbmFsaXplciAodXNpbmcgJ2xhc3QnIHNlbWFudGljKVwiO1xuICAgIHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iIHQgZXhlY3V0aW9uX2NvbnRleHQgZiAoKVxuICBpblxuICBpZiBEZWJ1Zy5maW5hbGl6ZXJzIHRoZW4gRGVidWcubG9nX3N0cmluZyBcImFkZGluZyBmaW5hbGl6ZXIgKHVzaW5nICdsYXN0JyBzZW1hbnRpYylcIjtcbiAgKCogV2UgdXNlIFtDYW1sLkdjLmZpbmFsaXNlX2xhc3RdIGluc3RlYWQgb2YgW0NvcmUuR2MuYWRkX2ZpbmFsaXplcl9sYXN0XSBiZWNhdXNlXG4gICAgIHRoZSBsYXR0ZXIgaGFzIGl0cyBvd24gd3JhcHBlciBhcm91bmQgW0NhbWwuR2MuZmluYWxpc2VfbGFzdF0gdG8gcnVuIGZpbmFsaXplcnNcbiAgICAgc3luY2hyb25vdXNseS4gKilcbiAgdHJ5IFN0ZGxpYi5HYy5maW5hbGlzZV9sYXN0IGZpbmFsaXplciBoZWFwX2Jsb2NrIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT5cbiAgICAoKiBbSGVhcF9ibG9ja10gZW5zdXJlcyB0aGF0IHRoaXMgd2lsbCBvbmx5IGZhaWwgZm9yIHN0YXRpYyBkYXRhLCBpbiB3aGljaCBjYXNlIHdlXG4gICAgICAgY2FuIGRyb3AgdGhlIGZpbmFsaXplciBzaW5jZSB0aGUgYmxvY2sgd2lsbCBuZXZlciBiZSBjb2xsZWN0ZWQuKilcbiAgICAoKVxuOztcblxubGV0IGFkZF9maW5hbGl6ZXJfbGFzdF9leG4gdCB4IGYgPSBhZGRfZmluYWxpemVyX2xhc3QgdCAoSGVhcF9ibG9jay5jcmVhdGVfZXhuIHgpIGZcblxuKCoqIFtmb3JjZV9jdXJyZW50X2N5Y2xlX3RvX2VuZF0gc2V0cyB0aGUgbnVtYmVyIG9mIG5vcm1hbCBqb2JzIGFsbG93ZWQgdG8gcnVuIGluIHRoaXNcbiAgICBjeWNsZSB0byB6ZXJvLiAgVGh1cywgYWZ0ZXIgdGhlIGN1cnJlbnRseSBydW5uaW5nIGpvYiBjb21wbGV0ZXMsIHRoZSBzY2hlZHVsZXIgd2lsbFxuICAgIHN3aXRjaCB0byBsb3cgcHJpb3JpdHkgam9icyBhbmQgdGhlbiBlbmQgdGhlIGN1cnJlbnQgY3ljbGUuICopXG5sZXQgZm9yY2VfY3VycmVudF9jeWNsZV90b19lbmQgdCA9XG4gIEpvYl9xdWV1ZS5zZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUgdC5ub3JtYWxfcHJpb3JpdHlfam9icyAwXG47O1xuXG4oKiBXZSBwcmVhbGxvY2F0ZSBbc2VuZF9leG5dIHRvIGF2b2lkIGFsbG9jYXRpbmcgaXQgb24gZWFjaCBjYWxsIHRvIFthZHZhbmNlX2Nsb2NrXS4gKilcbmxldCBzZW5kX2V4biA9IFNvbWUgTW9uaXRvci5zZW5kX2V4blxuXG5sZXQgYWR2YW5jZV9jbG9jayB0IH5ub3cgPVxuICBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAuYWR2YW5jZV9pbnRlcm5hbCB0LnRpbWVfc291cmNlIH50b186bm93IH5zZW5kX2V4blxuOztcblxubGV0IHJ1bl9jeWNsZSB0ID1cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJydW5fY3ljbGUgc3RhcnRpbmdcIiB0IFslc2V4cF9vZjogdF07XG4gIGxldCBub3cgPSBUaW1lX25zLm5vdyAoKSBpblxuICB0LmN5Y2xlX2NvdW50IDwtIHQuY3ljbGVfY291bnQgKyAxO1xuICB0LmN5Y2xlX3N0YXJ0IDwtIG5vdztcbiAgdC5pbl9jeWNsZSA8LSB0cnVlO1xuICBCdmFyLmJyb2FkY2FzdCB0LnlpZWxkICgpO1xuICBsZXQgbnVtX2pvYnNfcnVuX2F0X3N0YXJ0X29mX2N5Y2xlID0gbnVtX2pvYnNfcnVuIHQgaW5cbiAgQXJyYXkuaXRlciB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydCB+ZjooZnVuIGYgLT4gZiAoKSk7XG4gIGFkdmFuY2VfY2xvY2sgdCB+bm93O1xuICBzdGFydF9jeWNsZSB0IH5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5OnQubWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGU7XG4gIGxldCByZWMgcnVuX2pvYnMgdCA9XG4gICAgbWF0Y2ggU2NoZWR1bGVyLnJ1bl9qb2JzIHQgd2l0aFxuICAgIHwgT2sgKCkgLT4gKClcbiAgICB8IEVycm9yIChleG4sIGJhY2t0cmFjZSkgLT5cbiAgICAgIE1vbml0b3Iuc2VuZF9leG4gKE1vbml0b3IuY3VycmVudCAoKSkgZXhuIH5iYWNrdHJhY2U6KGBUaGlzIGJhY2t0cmFjZSk7XG4gICAgICAoKiBbcnVuX2pvYnNdIHN0b3BwZWQgZHVlIHRvIGFuIGV4bi4gIFRoZXJlIG1heSBzdGlsbCBiZSBqb2JzIHRoYXQgY291bGQgYmVcbiAgICAgICAgIHJ1biB0aGlzIGN5Y2xlLCBzbyBbcnVuX2pvYnNdIGFnYWluLiAqKVxuICAgICAgcnVuX2pvYnMgdFxuICBpblxuICBydW5fam9icyB0O1xuICBsZXQgY3ljbGVfdGltZSA9IFRpbWVfbnMuZGlmZiAoVGltZV9ucy5ub3cgKCkpIHQuY3ljbGVfc3RhcnQgaW5cbiAgdC5sYXN0X2N5Y2xlX3RpbWUgPC0gY3ljbGVfdGltZTtcbiAgdC5sYXN0X2N5Y2xlX251bV9qb2JzIDwtIG51bV9qb2JzX3J1biB0IC0gbnVtX2pvYnNfcnVuX2F0X3N0YXJ0X29mX2N5Y2xlO1xuICB0LnRvdGFsX2N5Y2xlX3RpbWUgPC0gVGltZV9ucy5TcGFuLih0LnRvdGFsX2N5Y2xlX3RpbWUgKyBjeWNsZV90aW1lKTtcbiAgaWYgQnZhci5oYXNfYW55X3dhaXRlcnMgdC55aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiAmJiBudW1fcGVuZGluZ19qb2JzIHQgPSAwXG4gIHRoZW4gQnZhci5icm9hZGNhc3QgdC55aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiAoKTtcbiAgQXJyYXkuaXRlciB0LnJ1bl9ldmVyeV9jeWNsZV9lbmQgfmY6KGZ1biBmIC0+IGYgKCkpO1xuICB0LmluX2N5Y2xlIDwtIGZhbHNlO1xuICBpZiBkZWJ1Z1xuICB0aGVuXG4gICAgRGVidWcubG9nXG4gICAgICBcInJ1bl9jeWNsZSBmaW5pc2hlZFwiXG4gICAgICAodW5jYXVnaHRfZXhuIHQsIGlzX3NvbWUgKG5leHRfdXBjb21pbmdfZXZlbnQgdCkpXG4gICAgICBbJXNleHBfb2Y6IEVycm9yLnQgb3B0aW9uICogYm9vbF1cbjs7XG5cbmxldCBydW5fY3ljbGVzX3VudGlsX25vX2pvYnNfcmVtYWluICgpID1cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2dfc3RyaW5nIFwicnVuX2N5Y2xlc191bnRpbF9ub19qb2JzX3JlbWFpbiBzdGFydGluZ1wiO1xuICBsZXQgdCA9IHQgKCkgaW5cbiAgaWYgaXNfZGVhZCB0XG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJydW5fY3ljbGVzX3VudGlsX25vX2pvYnNfcmVtYWluIGNhbm5vdCBwcm9jZWVkIC0tIHNjaGVkdWxlciBpcyBkZWFkXCJcbiAgICAgICAgICB+c2NoZWR1bGVyOih0IDogdCldO1xuICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgIHJ1bl9jeWNsZSB0O1xuICAgIGFkdmFuY2VfY2xvY2sgdCB+bm93OihUaW1lX25zLm5vdyAoKSk7XG4gICAgaWYgY2FuX3J1bl9hX2pvYiB0IHRoZW4gbG9vcCAoKVxuICBpblxuICBsb29wICgpO1xuICAoKiBSZXNldCB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dCB0byBtYWludGFpbiB0aGUgaW52YXJpYW50IHRoYXQgd2hlbiB3ZSdyZSBub3QgaW5cbiAgICAgYSBqb2IsIFtjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ID0gbWFpbl9leGVjdXRpb25fY29udGV4dF0uICopXG4gIHNldF9leGVjdXRpb25fY29udGV4dCB0IHQubWFpbl9leGVjdXRpb25fY29udGV4dDtcbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2dfc3RyaW5nIFwicnVuX2N5Y2xlc191bnRpbF9ub19qb2JzX3JlbWFpbiBmaW5pc2hlZFwiO1xuICBPcHRpb24uaXRlciAodW5jYXVnaHRfZXhuIHQpIH5mOkVycm9yLnJhaXNlXG47O1xuXG5sZXQgbWFrZV9hc3luY191bnVzYWJsZSAoKSA9XG4gIGxldCB0ID0gIXRfcmVmIGluXG4gIHQuY2hlY2tfYWNjZXNzXG4gICAgPC0gU29tZVxuICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICByYWlzZV9zIFslc2V4cCBcIkFzeW5jIHNjaGVkdWxlciBpcyB1bnVzYWJsZSBkdWUgdG8gW21ha2VfYXN5bmNfdW51c2FibGVdXCJdKVxuOztcblxubGV0IHJlc2V0X2luX2ZvcmtlZF9wcm9jZXNzICgpID1cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2dfc3RyaW5nIFwicmVzZXRfaW5fZm9ya2VkX3Byb2Nlc3NcIjtcbiAgKCogVGhlcmUgaXMgbm8gbmVlZCB0byBlbXB0eSBbbWFpbl9tb25pdG9yX2hvbGVdLiAqKVxuICBTY2hlZHVsZXIuKHRfcmVmIDo9IGNyZWF0ZSAoKSlcbjs7XG5cbmxldCBjaGVja19pbnZhcmlhbnRzIHQgPSB0LmNoZWNrX2ludmFyaWFudHNcbmxldCBzZXRfY2hlY2tfaW52YXJpYW50cyB0IGIgPSB0LmNoZWNrX2ludmFyaWFudHMgPC0gYlxubGV0IHJlY29yZGluZ19iYWNrdHJhY2VzIHQgPSB0LnJlY29yZF9iYWNrdHJhY2VzXG5sZXQgc2V0X3JlY29yZF9iYWNrdHJhY2VzIHQgYiA9IHQucmVjb3JkX2JhY2t0cmFjZXMgPC0gYlxubGV0IHlpZWxkIHQgPSBCdmFyLndhaXQgdC55aWVsZFxuXG5sZXQgeWllbGRfdW50aWxfbm9fam9ic19yZW1haW4gPyhtYXlfcmV0dXJuX2ltbWVkaWF0ZWx5ID0gZmFsc2UpIHQgPVxuICBpZiBtYXlfcmV0dXJuX2ltbWVkaWF0ZWx5ICYmIG51bV9wZW5kaW5nX2pvYnMgdCA9IDBcbiAgdGhlbiByZXR1cm4gKClcbiAgZWxzZSBCdmFyLndhaXQgdC55aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpblxuOztcblxubGV0IHlpZWxkX2V2ZXJ5IH5uID1cbiAgaWYgbiA8PSAwXG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJTY2hlZHVsZXIueWllbGRfZXZlcnkgZ290IG5vbnBvc2l0aXZlIGNvdW50XCIgKG4gOiBpbnQpXVxuICBlbHNlIGlmIG4gPSAxXG4gIHRoZW4gc3RhZ2UgKGZ1biB0IC0+IHlpZWxkIHQpXG4gIGVsc2UgKFxuICAgIGxldCBjb3VudF91bnRpbF95aWVsZCA9IHJlZiBuIGluXG4gICAgc3RhZ2UgKGZ1biB0IC0+XG4gICAgICBkZWNyIGNvdW50X3VudGlsX3lpZWxkO1xuICAgICAgaWYgIWNvdW50X3VudGlsX3lpZWxkID4gMFxuICAgICAgdGhlbiByZXR1cm4gKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBjb3VudF91bnRpbF95aWVsZCA6PSBuO1xuICAgICAgICB5aWVsZCB0KSkpXG47O1xuXG5sZXQgdG90YWxfY3ljbGVfdGltZSB0ID1cbiAgKCogQWRqdXN0IGZvciB0aGUgZmFjdCB0aGUgY2FsbGVyJ3MgcHJvYmFibHkgYW4gQXN5bmMgam9iLiAqKVxuICBpZiB0LmluX2N5Y2xlXG4gIHRoZW4gKFxuICAgIGxldCB0aGlzX2N5Y2xlX3RpbWUgPSBUaW1lX25zLihkaWZmIChub3cgKCkpIHQuY3ljbGVfc3RhcnQpIGluXG4gICAgVGltZV9ucy5TcGFuLih0LnRvdGFsX2N5Y2xlX3RpbWUgKyB0aGlzX2N5Y2xlX3RpbWUpKVxuICBlbHNlIHQudG90YWxfY3ljbGVfdGltZVxuOztcblxubW9kdWxlIFZlcnlfbG93X3ByaW9yaXR5X3dvcmsgPSBzdHJ1Y3RcbiAgbW9kdWxlIFdvcmtlcl9yZXN1bHQgPSBWZXJ5X2xvd19wcmlvcml0eV93b3JrZXIuRXhlY19yZXN1bHRcblxuICBsZXQgcmVjIHJ1biB0ID0gcnVuX3dvcmtlcnMgdCB+bnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZzoxXzAwMFxuXG4gIGFuZCBydW5fd29ya2VycyB0IH5udW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nID1cbiAgICBpZiBudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nID0gMFxuICAgIHRoZW4geWllbGRfdGhlbl9ydW4gdFxuICAgIGVsc2UgaWYgbm90IChEZXF1ZS5pc19lbXB0eSB0LnZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMpXG4gICAgdGhlbiAoXG4gICAgICBsZXQgd29ya2VyID0gRGVxdWUuZGVxdWV1ZV9mcm9udF9leG4gdC52ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzIGluXG4gICAgICBzZXRfZXhlY3V0aW9uX2NvbnRleHQgdCB3b3JrZXIuZXhlY3V0aW9uX2NvbnRleHQ7XG4gICAgICBydW5fd29ya2VyIHQgd29ya2VyIH5udW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nKVxuXG4gIGFuZCB5aWVsZF90aGVuX3J1biB0ID1cbiAgICBpZiBub3QgKERlcXVlLmlzX2VtcHR5IHQudmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycylcbiAgICB0aGVuIERlZmVycmVkLnVwb24gKHlpZWxkIHQpIChmdW4gKCkgLT4gcnVuIHQpXG5cbiAgYW5kIHJ1bl93b3JrZXIgdCB3b3JrZXIgfm51bV9leGVjc19iZWZvcmVfeWllbGRpbmcgPVxuICAgIGFzc2VydCAocGh5c19lcXVhbCB0LmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgd29ya2VyLmV4ZWN1dGlvbl9jb250ZXh0KTtcbiAgICBpZiBudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nID0gMFxuICAgIHRoZW4gKFxuICAgICAgRGVxdWUuZW5xdWV1ZV9mcm9udCB0LnZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMgd29ya2VyO1xuICAgICAgeWllbGRfdGhlbl9ydW4gdClcbiAgICBlbHNlIChcbiAgICAgIGxldCBudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nID0gbnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyAtIDEgaW5cbiAgICAgIG1hdGNoIHdvcmtlci5leGVjICgpIHdpdGhcbiAgICAgIHwgRmluaXNoZWQgLT4gcnVuX3dvcmtlcnMgdCB+bnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZ1xuICAgICAgfCBOb3RfZmluaXNoZWQgLT4gcnVuX3dvcmtlciB0IHdvcmtlciB+bnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZ1xuICAgICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICAgIGxldCBidCA9IEJhY2t0cmFjZS5FeG4ubW9zdF9yZWNlbnQgKCkgaW5cbiAgICAgICAgTW9uaXRvci5zZW5kX2V4biAoTW9uaXRvci5jdXJyZW50ICgpKSBleG4gfmJhY2t0cmFjZTooYFRoaXMgYnQpO1xuICAgICAgICBydW5fd29ya2VycyB0IH5udW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nKVxuICA7O1xuXG4gIGxldCBlbnF1ZXVlIH5mID1cbiAgICBsZXQgdCA9IHQgKCkgaW5cbiAgICBsZXQgcXVldWUgPSB0LnZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMgaW5cbiAgICBsZXQgcnVubmluZyA9IG5vdCAoRGVxdWUuaXNfZW1wdHkgcXVldWUpIGluXG4gICAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID1cbiAgICAgIEV4ZWN1dGlvbl9jb250ZXh0LmNyZWF0ZV9saWtlIChjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHQpIH5wcmlvcml0eTpMb3dcbiAgICBpblxuICAgIERlcXVlLmVucXVldWVfYmFjayBxdWV1ZSB7IGV4ZWN1dGlvbl9jb250ZXh0OyBleGVjID0gZiB9O1xuICAgIGlmIG5vdCBydW5uaW5nIHRoZW4gZW5xdWV1ZSB0IGV4ZWN1dGlvbl9jb250ZXh0IHJ1biB0XG4gIDs7XG5lbmRcblxubW9kdWxlIEZvcl9iZW5jaCA9IHN0cnVjdFxuICBsZXQgYWR2YW5jZV9jbG9jayA9IGFkdmFuY2VfY2xvY2tcbmVuZFxuXG5sZXQgaW5fY3ljbGUgdCA9IHQuaW5fY3ljbGVcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiEgRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxubW9kdWxlIENvdW50aW5nX3NlbWFwaG9yZSA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgd2FpdF90b19hY3F1aXJlX2pvYl90b2tlbiA6IHQgLT4gdW5pdCBEZWZlcnJlZC50XG4gIHZhbCByZWxlYXNlX2pvYl90b2tlbiA6IHQgLT4gdW5pdFxuICB2YWwgYWJvcnQgOiB0IC0+IHVuaXRcbiAgdmFsIGNyZWF0ZSA6IG1heF9jb25jdXJyZW50X2pvYnM6aW50IC0+IHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgbXV0YWJsZSBtYXhfY29uY3VycmVudF9qb2JzIDogaW50XG4gICAgOyBtdXRhYmxlIHdhaXRlciA6IHVuaXQgSXZhci50IG9wdGlvblxuICAgIDsgbXV0YWJsZSBhYm9ydGVkIDogYm9vbFxuICAgIH1cblxuICBsZXQgd2FpdF90b19hY3F1aXJlX2pvYl90b2tlbiAoeyBtYXhfY29uY3VycmVudF9qb2JzOyB3YWl0ZXI7IGFib3J0ZWQgfSBhcyB0KSA9XG4gICAgbWF0Y2ggYWJvcnRlZCB3aXRoXG4gICAgfCB0cnVlIC0+IERlZmVycmVkLm5ldmVyICgpXG4gICAgfCBmYWxzZSAtPlxuICAgICAgaWYgbWF4X2NvbmN1cnJlbnRfam9icyA+IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICB0Lm1heF9jb25jdXJyZW50X2pvYnMgPC0gbWF4X2NvbmN1cnJlbnRfam9icyAtIDE7XG4gICAgICAgIERlZmVycmVkLnJldHVybiAoKSlcbiAgICAgIGVsc2UgKFxuICAgICAgICBhc3NlcnQgKE9wdGlvbi5pc19ub25lIHdhaXRlcik7XG4gICAgICAgIGxldCBpdmFyID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgICAgICAgdC53YWl0ZXIgPC0gU29tZSBpdmFyO1xuICAgICAgICBJdmFyLnJlYWQgaXZhcilcbiAgOztcblxuICBsZXQgcmVsZWFzZV9qb2JfdG9rZW4gKHsgbWF4X2NvbmN1cnJlbnRfam9iczsgd2FpdGVyOyBhYm9ydGVkID0gXyB9IGFzIHQpID1cbiAgICBtYXRjaCB3YWl0ZXIgd2l0aFxuICAgIHwgU29tZSBpdmFyIC0+XG4gICAgICBJdmFyLmZpbGxfZXhuIGl2YXIgKCk7XG4gICAgICB0LndhaXRlciA8LSBOb25lXG4gICAgfCBOb25lIC0+IHQubWF4X2NvbmN1cnJlbnRfam9icyA8LSBtYXhfY29uY3VycmVudF9qb2JzICsgMVxuICA7O1xuXG4gIGxldCBhYm9ydCB0ID1cbiAgICB0LmFib3J0ZWQgPC0gdHJ1ZTtcbiAgICB0LndhaXRlciA8LSBOb25lXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSB+bWF4X2NvbmN1cnJlbnRfam9icyA9XG4gICAgeyBtYXhfY29uY3VycmVudF9qb2JzOyB3YWl0ZXIgPSBOb25lOyBhYm9ydGVkID0gZmFsc2UgfVxuICA7O1xuZW5kXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBjb21wdXRlIDpcbiAgICAgICAgRXhlY3V0aW9uX2NvbnRleHQudCAtPiBDb3VudGluZ19zZW1hcGhvcmUudCAtPiAoJ2EgRGVmZXJyZWQudCAtPiB1bml0KSAtPiB1bml0XG4gICAgfVxuICBbQEB1bmJveGVkXVxuXG4gIGxldCByZXR1cm4geCA9IHsgY29tcHV0ZSA9IChmdW4gXyBfIGsgLT4gayAocmV0dXJuIHgpKSB9XG5cbiAgbGV0IG1hcCA9XG4gICAgYEN1c3RvbVxuICAgICAgKGZ1biB0IH5mIC0+XG4gICAgICAgIHsgY29tcHV0ZSA9XG4gICAgICAgICAgICAoZnVuIGV4ZWNfY3R4IHNlbWFwaG9yZSBrIC0+XG4gICAgICAgICAgICAgIHQuY29tcHV0ZSBleGVjX2N0eCBzZW1hcGhvcmUgKGZ1biBkIC0+XG4gICAgICAgICAgICAgICAga1xuICAgICAgICAgICAgICAgICAgKGxldCVtYXAgcmVzdWx0ID0gZCBpblxuICAgICAgICAgICAgICAgICAgIGYgcmVzdWx0KSkpXG4gICAgICAgIH0pXG4gIDs7XG5cbiAgbGV0IGFwcGx5IHRfZiB0ID1cbiAgICB7IGNvbXB1dGUgPVxuICAgICAgICAoZnVuIGV4ZWNfY3R4IHNlbWFwaG9yZSBrIC0+XG4gICAgICAgICAgdF9mLmNvbXB1dGUgZXhlY19jdHggc2VtYXBob3JlIChmdW4gZGYgLT5cbiAgICAgICAgICAgIHQuY29tcHV0ZSBleGVjX2N0eCBzZW1hcGhvcmUgKGZ1biBkdiAtPlxuICAgICAgICAgICAgICBrXG4gICAgICAgICAgICAgICAgKGxldCViaW5kIGYgPSBkZiBpblxuICAgICAgICAgICAgICAgICBsZXQlbWFwIHYgPSBkdiBpblxuICAgICAgICAgICAgICAgICBmIHYpKSkpXG4gICAgfVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBBcHBsaWNhdGl2ZS5NYWtlIChUKVxuXG5sZXQgZW5xdWV1ZScgc2NoZWR1bGVyIGN0eCBmID1cbiAgbGV0IGl2YXIgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICBTY2hlZHVsZXIuZW5xdWV1ZSBzY2hlZHVsZXIgY3R4IChmdW4gKCkgLT4gdXBvbiAoZiAoKSkgKEl2YXIuZmlsbF9leG4gaXZhcikpICgpO1xuICBJdmFyLnJlYWQgaXZhclxuOztcblxubGV0IGpvYiBmID1cbiAgeyBjb21wdXRlID1cbiAgICAgIChmdW4gZXhlY19jdHggc2VtYXBob3JlIGsgLT5cbiAgICAgICAgRGVmZXJyZWQudXBvbiAoQ291bnRpbmdfc2VtYXBob3JlLndhaXRfdG9fYWNxdWlyZV9qb2JfdG9rZW4gc2VtYXBob3JlKSAoZnVuICgpIC0+XG4gICAgICAgICAga1xuICAgICAgICAgICAgKGVucXVldWUnIChTY2hlZHVsZXIudCAoKSkgZXhlY19jdHggKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgbGV0JW1hcCBhID0gZiAoKSBpblxuICAgICAgICAgICAgICAgQ291bnRpbmdfc2VtYXBob3JlLnJlbGVhc2Vfam9iX3Rva2VuIHNlbWFwaG9yZTtcbiAgICAgICAgICAgICAgIGEpKSkpXG4gIH1cbjs7XG5cbmxldCBydW4gdCB+bWF4X2NvbmN1cnJlbnRfam9icyA9XG4gIGxldCBzZW1hcGhvcmUgPSBDb3VudGluZ19zZW1hcGhvcmUuY3JlYXRlIH5tYXhfY29uY3VycmVudF9qb2JzIGluXG4gICgqIFRoZSBuYW1lIGlzIHNldCB0byB0aGUgZW1wdHkgc3RyaW5nIGluIG9yZGVyIHRvIHByZXZlbnQgW01vbml0b3Iuc2VuZF9leG5dXG4gICAgIGZyb20gYXBwZW5kaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgbW9uaXRvciB0byB0aGUgZXhjZXB0aW9ucyB3ZSBmb3J3YXJkLlxuICAgICBUaGlzIG1hdHRlcnMgYmVjYXVzZSB3ZSB3YW50IHNpbWxpYXIgYmVoYXZpb3IgdG8gW1Rocm90dGxlXSBhbmQgbm90IGJyZWFrXG4gICAgIGV4aXN0aW5nIHRlc3RzLiAqKVxuICBsZXQgbW9uaXRvciA9IE1vbml0b3IuY3JlYXRlIH5uYW1lOlwiXCIgKCkgaW5cbiAgbGV0IHBhcmVudF9tb25pdG9yID0gTW9uaXRvci5jdXJyZW50ICgpIGluXG4gIE1vbml0b3IuZGV0YWNoX2FuZF9pdGVyX2Vycm9ycyBtb25pdG9yIH5mOihmdW4gZXJyIC0+XG4gICAgQ291bnRpbmdfc2VtYXBob3JlLmFib3J0IHNlbWFwaG9yZTtcbiAgICBNb25pdG9yLnNlbmRfZXhuIHBhcmVudF9tb25pdG9yIGVycik7XG4gIGxldCBleGVjX2N0eCA9XG4gICAgRXhlY3V0aW9uX2NvbnRleHQuY3JlYXRlX2xpa2VcbiAgICAgIH5tb25pdG9yXG4gICAgICAoU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKFNjaGVkdWxlci50ICgpKSlcbiAgaW5cbiAgbGV0IGl2YXIgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICB0LmNvbXB1dGUgZXhlY19jdHggc2VtYXBob3JlIChmdW4gciAtPiBEZWZlcnJlZC51cG9uIHIgKEl2YXIuZmlsbF9leG4gaXZhcikpO1xuICBJdmFyLnJlYWQgaXZhclxuOztcblxubGV0IG9mX3RodW5rIHRodW5rID1cbiAgeyBjb21wdXRlID1cbiAgICAgIChmdW4gZXhlY19jdHggc2VtYXBob3JlIGsgLT5cbiAgICAgICAgbGV0IHQgPSB0aHVuayAoKSBpblxuICAgICAgICB0LmNvbXB1dGUgZXhlY19jdHggc2VtYXBob3JlIGspXG4gIH1cbjs7XG5cbmxldCAoICo+ICkgdDEgdDIgPVxuICB7IGNvbXB1dGUgPVxuICAgICAgKGZ1biBleGVjX2N0eCBzZW1hcGhvcmUgayAtPlxuICAgICAgICB0MS5jb21wdXRlIGV4ZWNfY3R4IHNlbWFwaG9yZSAoZnVuIGQxIC0+XG4gICAgICAgICAgdDIuY29tcHV0ZSBleGVjX2N0eCBzZW1hcGhvcmUgKGZ1biBkMiAtPlxuICAgICAgICAgICAga1xuICAgICAgICAgICAgICAobGV0JWJpbmQgKCkgPSBkMSBpblxuICAgICAgICAgICAgICAgZDIpKSkpXG4gIH1cbjs7XG5cbmxldCBib3RoX3VuaXQgPSAoICo+IClcbiIsIm9wZW4hIEJhc2VcblxudHlwZSBfIHQgPVxuICB8IFN0YWNrIDogJ2EgU3RhY2sudCAtPiAnYSB0XG4gIHwgQ291bnRlciA6IHsgbXV0YWJsZSBsZW5ndGggOiBpbnQgfSAtPiB1bml0IHRcbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBvZl9saXN0IGxpc3QgPSBTdGFjayAoU3RhY2sub2ZfbGlzdCBsaXN0KVxuXG5sZXQgY3JlYXRlX2NvdW50ZXIgfmxlbmd0aCA9XG4gIGlmIGxlbmd0aCA8IDBcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZSBcIltTdGFja19vcl9jb3VudGVyLmNyZWF0ZV9jb3VudGVyXSBnb3QgbmVnYXRpdmUgbGVuZ3RoXCIgKGxlbmd0aCA6IGludCldO1xuICBDb3VudGVyIHsgbGVuZ3RoIH1cbjs7XG5cbmxldCBsZW5ndGggKHR5cGUgYSkgKHQgOiBhIHQpID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU3RhY2sgcyAtPiBTdGFjay5sZW5ndGggc1xuICB8IENvdW50ZXIgciAtPiByLmxlbmd0aFxuOztcblxubGV0IGNsZWFyICh0eXBlIGEpICh0IDogYSB0KSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFN0YWNrIHMgLT4gU3RhY2suY2xlYXIgc1xuICB8IENvdW50ZXIgciAtPiByLmxlbmd0aCA8LSAwXG47O1xuXG5sZXQgcHVzaCAodHlwZSBhKSAodCA6IGEgdCkgYSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFN0YWNrIHMgLT4gU3RhY2sucHVzaCBzIGFcbiAgfCBDb3VudGVyIHIgLT4gci5sZW5ndGggPC0gci5sZW5ndGggKyAxXG47O1xuXG5sZXQgcG9wX2V4biAodHlwZSBhKSAodCA6IGEgdCkgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTdGFjayBzIC0+IFN0YWNrLnBvcF9leG4gc1xuICB8IENvdW50ZXIgciAtPlxuICAgIGlmIHIubGVuZ3RoID0gMCB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiW1N0YWNrX29yX2NvdW50ZXIucG9wX2V4bl0gb2YgZW1wdHkgc3RhY2tcIl07XG4gICAgci5sZW5ndGggPC0gci5sZW5ndGggLSAxXG47O1xuXG5sZXQgaXRlciAodHlwZSBhKSAodCA6IGEgdCkgfihmIDogYSAtPiB1bml0KSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFN0YWNrIHMgLT4gU3RhY2suaXRlciBzIH5mXG4gIHwgQ291bnRlciByIC0+XG4gICAgZm9yIF8gPSAxIHRvIHIubGVuZ3RoIGRvXG4gICAgICBmICgpXG4gICAgZG9uZVxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiEgRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxudHlwZSAnYSBvdXRjb21lID1cbiAgWyBgT2sgb2YgJ2FcbiAgfCBgQWJvcnRlZFxuICB8IGBSYWlzZWQgb2YgZXhuXG4gIF1cbltAQGRlcml2aW5nIHNleHBfb2ZdXG5cbm1vZHVsZSBJbnRlcm5hbF9qb2IgOiBzaWdcbiAgdHlwZSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgdmFsIGNyZWF0ZVxuICAgIDogIHJlc3Q6WyBgTG9nIHwgYFJhaXNlIHwgYENhbGwgb2YgZXhuIC0+IHVuaXQgXVxuICAgIC0+ICgnYSAtPiAnYiBEZWZlcnJlZC50KVxuICAgIC0+ICdhIHQgKiAnYiBvdXRjb21lIERlZmVycmVkLnRcblxuICAoKiBFdmVyeSBpbnRlcm5hbCBqb2Igd2lsbCBldmVudHVhbGx5IGJlIGVpdGhlciBbcnVuXSBvciBbYWJvcnRdZWQsIGJ1dCBub3QgYm90aC4gKilcblxuICB2YWwgcnVuIDogJ2EgdCAtPiAnYSAtPiBbIGBPayB8IGBSYWlzZWQgXSBEZWZlcnJlZC50XG4gIHZhbCBhYm9ydCA6IF8gdCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB7IHN0YXJ0IDogWyBgQWJvcnQgfCBgU3RhcnQgb2YgJ2EgXSBJdmFyLnRcbiAgICA7IG91dGNvbWUgOiBbIGBPayB8IGBBYm9ydGVkIHwgYFJhaXNlZCBdIERlZmVycmVkLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGNyZWF0ZSB+cmVzdCB3b3JrID1cbiAgICBsZXQgc3RhcnQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICAgIGxldCByZXN1bHQgPVxuICAgICAgbWF0Y2glYmluZCBJdmFyLnJlYWQgc3RhcnQgd2l0aFxuICAgICAgfCBgQWJvcnQgLT4gcmV0dXJuIGBBYm9ydGVkXG4gICAgICB8IGBTdGFydCBhIC0+XG4gICAgICAgIChtYXRjaCVtYXAgTW9uaXRvci50cnlfd2l0aCB+cnVuOmBTY2hlZHVsZSB+cmVzdCAoZnVuICgpIC0+IHdvcmsgYSkgd2l0aFxuICAgICAgICAgfCBPayBhIC0+IGBPayBhXG4gICAgICAgICB8IEVycm9yIGV4biAtPiBgUmFpc2VkIGV4bilcbiAgICBpblxuICAgIGxldCBvdXRjb21lID1cbiAgICAgIG1hdGNoJW1hcCByZXN1bHQgd2l0aFxuICAgICAgfCBgT2sgXyAtPiBgT2tcbiAgICAgIHwgYEFib3J0ZWQgLT4gYEFib3J0ZWRcbiAgICAgIHwgYFJhaXNlZCBfIC0+IGBSYWlzZWRcbiAgICBpblxuICAgIGxldCB0ID0geyBzdGFydDsgb3V0Y29tZSB9IGluXG4gICAgdCwgcmVzdWx0XG4gIDs7XG5cbiAgbGV0IHJ1biB0IGEgPVxuICAgIEl2YXIuZmlsbF9leG4gdC5zdGFydCAoYFN0YXJ0IGEpO1xuICAgIG1hdGNoJW1hcCB0Lm91dGNvbWUgd2l0aFxuICAgIHwgYEFib3J0ZWQgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCAoYE9rIHwgYFJhaXNlZCkgYXMgeCAtPiB4XG4gIDs7XG5cbiAgbGV0IGFib3J0IHQgPSBJdmFyLmZpbGxfZXhuIHQuc3RhcnQgYEFib3J0XG5lbmRcblxudHlwZSAnYSB0ID1cbiAgeyBjb250aW51ZV9vbl9lcnJvciA6IGJvb2xcbiAgOyByZXN0IDogWyBgTG9nIHwgYFJhaXNlIHwgYENhbGwgb2YgZXhuIC0+IHVuaXQgXVxuICA7IG1heF9jb25jdXJyZW50X2pvYnMgOiBpbnRcbiAgOyAoKiBbam9iX3Jlc291cmNlc19ub3RfaW5fdXNlXSBob2xkcyByZXNvdXJjZXMgdGhhdCBhcmUgbm90IGN1cnJlbnRseSBpbiB1c2UgYnkgYVxuICAgICAgIHJ1bm5pbmcgam9iLiAqKVxuICAgIGpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSA6ICdhIFN0YWNrX29yX2NvdW50ZXIudFxuICA7ICgqIFtqb2JzX3dhaXRpbmdfdG9fc3RhcnRdIGlzIHRoZSBxdWV1ZSBvZiBqb2JzIHRoYXQgaGF2ZW4ndCB5ZXQgc3RhcnRlZC4gKilcbiAgICBqb2JzX3dhaXRpbmdfdG9fc3RhcnQgOiAnYSBJbnRlcm5hbF9qb2IudCBRdWV1ZS50XG4gIDsgKCogWzAgPD0gbnVtX2pvYnNfcnVubmluZyA8PSBtYXhfY29uY3VycmVudF9qb2JzXS4gKilcbiAgICBtdXRhYmxlIG51bV9qb2JzX3J1bm5pbmcgOiBpbnRcbiAgOyAoKiBbY2FwYWNpdHlfYXZhaWxhYmxlXSBpcyBbU29tZSBpdmFyXSBpZiB1c2VyIGNvZGUgaGFzIGNhbGxlZCBbY2FwYWNpdHlfYXZhaWxhYmxlIHRdXG4gICAgICAgYW5kIGlzIHdhaXRpbmcgdG8gYmUgbm90aWZpZWQgd2hlbiBjYXBhY2l0eSBpcyBhdmFpbGFibGUgaW4gdGhlIHRocm90dGxlLlxuICAgICAgIFttYXliZV9zdGFydF9qb2JdIHdpbGwgZmlsbCBbaXZhcl0gd2hlbiBjYXBhY2l0eSBiZWNvbWVzIGF2YWlsYWJsZSwgaS5lLiB3aGVuXG4gICAgICAgW2pvYnNfd2FpdGluZ190b19zdGFydF0gaXMgZW1wdHkgYW5kIFtudW1fam9ic19ydW5uaW5nIDwgbWF4X2NvbmN1cnJlbnRfam9ic10uICopXG4gICAgbXV0YWJsZSBjYXBhY2l0eV9hdmFpbGFibGUgOiB1bml0IEl2YXIudCBvcHRpb25cbiAgOyAoKiBbaXNfZGVhZF0gaXMgdHJ1ZSBpZiBbdF0gd2FzIGtpbGxlZCBkdWUgdG8gYSBqb2IgcmFpc2luZyBhbiBleGNlcHRpb24gb3IgW2tpbGwgdF1cbiAgICAgICBiZWluZyBjYWxsZWQuICopXG4gICAgbXV0YWJsZSBpc19kZWFkIDogYm9vbFxuICA7ICgqIFtjbGVhbnNdIGhvbGRzIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIGNsZWFuIGVhY2ggcmVzb3VyY2Ugd2hlbiBbdF0gaXNcbiAgICAgICBraWxsZWQuICopXG4gICAgbXV0YWJsZSBjbGVhbnMgOiAoJ2EgLT4gdW5pdCBEZWZlcnJlZC50KSBsaXN0XG4gIDsgKCogW251bV9yZXNvdXJjZXNfbm90X2NsZWFuZWRdIGlzIHRoZSBudW1iZXIgb2YgcmVzb3VyY2VzIHdob3NlIGNsZWFuIGZ1bmN0aW9ucyBoYXZlXG4gICAgICAgbm90IHlldCBjb21wbGV0ZWQuICBXaGlsZSBbdF0gaXMgYWxpdmUsIFtudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkID1cbiAgICAgICBtYXhfY29uY3VycmVudF9qb2JzXS4gIE9uY2UgW3RdIGlzIGtpbGxlZCwgW251bV9yZXNvdXJjZXNfbm90X2NsZWFuZWRdIGRlY3JlYXNlcyB0b1xuICAgICAgIHplcm8gb3ZlciB0aW1lIGFzIHRoZSBjbGVhbiBmdW5jdGlvbnMgY29tcGxldGUuICopXG4gICAgbXV0YWJsZSBudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIDogaW50XG4gIDsgKCogW2NsZWFuZWRdIGJlY29tZXMgZGV0ZXJtaW5lZCB3aGVuIFtudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkXSByZWFjaGVzIHplcm8sXG4gICAgICAgaS5lLiBhZnRlciBbdF0gaXMga2lsbGVkIGFuZCBhbGwgaXRzIGNsZWFuIGZ1bmN0aW9ucyBjb21wbGV0ZS4gKilcbiAgICBjbGVhbmVkIDogdW5pdCBJdmFyLnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzIH5pdGVyYXRvcnM6aXRlciwgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0IDogdW5pdCA9XG4gIHRyeVxuICAgIGxldCBjaGVjayBmIGZpZWxkID0gZiAoRmllbGQuZ2V0IGZpZWxkIHQpIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5jb250aW51ZV9vbl9lcnJvcjppZ25vcmVcbiAgICAgIH5yZXN0Omlnbm9yZVxuICAgICAgfm1heF9jb25jdXJyZW50X2pvYnM6XG4gICAgICAgIChjaGVjayAoZnVuIG1heF9jb25jdXJyZW50X2pvYnMgLT4gYXNzZXJ0IChtYXhfY29uY3VycmVudF9qb2JzID4gMCkpKVxuICAgICAgfmpvYl9yZXNvdXJjZXNfbm90X2luX3VzZTpcbiAgICAgICAgKGNoZWNrIChmdW4gam9iX3Jlc291cmNlc19ub3RfaW5fdXNlIC0+XG4gICAgICAgICAgIFN0YWNrX29yX2NvdW50ZXIuaXRlciBqb2JfcmVzb3VyY2VzX25vdF9pbl91c2UgfmY6aW52YXJpYW50X2E7XG4gICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgU3RhY2tfb3JfY291bnRlci5sZW5ndGggam9iX3Jlc291cmNlc19ub3RfaW5fdXNlXG4gICAgICAgICAgICAgPSBpZiB0LmlzX2RlYWQgdGhlbiAwIGVsc2UgdC5tYXhfY29uY3VycmVudF9qb2JzIC0gdC5udW1fam9ic19ydW5uaW5nKSkpXG4gICAgICB+am9ic193YWl0aW5nX3RvX3N0YXJ0OlxuICAgICAgICAoY2hlY2sgKGZ1bmN0aW9uIGpvYnNfd2FpdGluZ190b19zdGFydCAtPlxuICAgICAgICAgICBpZiB0LmlzX2RlYWQgdGhlbiBhc3NlcnQgKFF1ZXVlLmlzX2VtcHR5IGpvYnNfd2FpdGluZ190b19zdGFydCkpKVxuICAgICAgfm51bV9qb2JzX3J1bm5pbmc6XG4gICAgICAgIChjaGVjayAoZnVuIG51bV9qb2JzX3J1bm5pbmcgLT5cbiAgICAgICAgICAgYXNzZXJ0IChudW1fam9ic19ydW5uaW5nID49IDApO1xuICAgICAgICAgICBhc3NlcnQgKG51bV9qb2JzX3J1bm5pbmcgPD0gdC5tYXhfY29uY3VycmVudF9qb2JzKTtcbiAgICAgICAgICAgaWYgbnVtX2pvYnNfcnVubmluZyA8IHQubWF4X2NvbmN1cnJlbnRfam9ic1xuICAgICAgICAgICB0aGVuIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgdC5qb2JzX3dhaXRpbmdfdG9fc3RhcnQpKSlcbiAgICAgIH5jYXBhY2l0eV9hdmFpbGFibGU6XG4gICAgICAgIChjaGVjayAoZnVuY3Rpb25cbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgaXZhciAtPiBhc3NlcnQgKEl2YXIuaXNfZW1wdHkgaXZhcikpKVxuICAgICAgfmlzX2RlYWQ6aWdub3JlXG4gICAgICB+Y2xlYW5zOmlnbm9yZVxuICAgICAgfm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQ6XG4gICAgICAgIChjaGVjayAoZnVuIG51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgLT5cbiAgICAgICAgICAgYXNzZXJ0IChudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkID49IDApO1xuICAgICAgICAgICBhc3NlcnQgKG51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPD0gdC5tYXhfY29uY3VycmVudF9qb2JzKTtcbiAgICAgICAgICAgaWYgbnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCA8IHQubWF4X2NvbmN1cnJlbnRfam9icyB0aGVuIGFzc2VydCB0LmlzX2RlYWQpKVxuICAgICAgfmNsZWFuZWQ6XG4gICAgICAgIChjaGVjayAoZnVuIGNsZWFuZWQgLT5cbiAgICAgICAgICAgaWYgSXZhci5pc19mdWxsIGNsZWFuZWQgdGhlbiBhc3NlcnQgKHQubnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCA9IDApKSlcbiAgd2l0aFxuICB8IGV4biAtPiByYWlzZV9zIFslbWVzc2FnZSBcIlRocm90dGxlLmludmFyaWFudCBmYWlsZWRcIiAoZXhuIDogZXhuKSAodCA6IF8gdCldXG47O1xuXG5tb2R1bGUgVDIgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdhLCAna2luZCkgdCA9ICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IGludmFyaWFudF9hIF8gdCA9IGludmFyaWFudCBpbnZhcmlhbnRfYSB0XG5lbmRcblxubGV0IG51bV9qb2JzX3dhaXRpbmdfdG9fc3RhcnQgdCA9IFF1ZXVlLmxlbmd0aCB0LmpvYnNfd2FpdGluZ190b19zdGFydFxuXG5sZXQgY2xlYW5fcmVzb3VyY2UgdCBhID1cbiAgRGVmZXJyZWQuYWxsX3VuaXQgKExpc3QubWFwIHQuY2xlYW5zIH5mOihmdW4gZiAtPiBmIGEpKVxuICA+Pj4gZnVuICgpIC0+XG4gIHQubnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCA8LSB0Lm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgLSAxO1xuICBpZiB0Lm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPSAwIHRoZW4gSXZhci5maWxsX2V4biB0LmNsZWFuZWQgKClcbjs7XG5cbmxldCBraWxsIHQgPVxuICBpZiBub3QgdC5pc19kZWFkXG4gIHRoZW4gKFxuICAgIHQuaXNfZGVhZCA8LSB0cnVlO1xuICAgIFF1ZXVlLml0ZXIgdC5qb2JzX3dhaXRpbmdfdG9fc3RhcnQgfmY6SW50ZXJuYWxfam9iLmFib3J0O1xuICAgIFF1ZXVlLmNsZWFyIHQuam9ic193YWl0aW5nX3RvX3N0YXJ0O1xuICAgIFN0YWNrX29yX2NvdW50ZXIuaXRlciB0LmpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSB+ZjooZnVuIGEgLT4gY2xlYW5fcmVzb3VyY2UgdCBhKTtcbiAgICBTdGFja19vcl9jb3VudGVyLmNsZWFyIHQuam9iX3Jlc291cmNlc19ub3RfaW5fdXNlKVxuOztcblxubGV0IGF0X2tpbGwgdCBmID1cbiAgKCogV2UgcHJlc2VydmUgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IHNvIHRoYXQgZXhjZXB0aW9ucyByYWlzZWQgYnkgW2ZdIGdvIHRvIHRoZSBtb25pdG9yXG4gICAgIGluIGVmZmVjdCB3aGVuIFthdF9raWxsXSB3YXMgY2FsbGVkLiAqKVxuICBsZXQgZiA9IHVuc3RhZ2UgKE1vbml0b3IuRXhwb3J0ZWRfZm9yX3NjaGVkdWxlci5wcmVzZXJ2ZV9leGVjdXRpb25fY29udGV4dCcgZikgaW5cbiAgdC5jbGVhbnMgPC0gZiA6OiB0LmNsZWFuc1xuOztcblxubGV0IGNsZWFuZWQgdCA9IEl2YXIucmVhZCB0LmNsZWFuZWRcblxubGV0IHJlYyBzdGFydF9qb2IgdCA9XG4gIGFzc2VydCAobm90IHQuaXNfZGVhZCk7XG4gIGFzc2VydCAodC5udW1fam9ic19ydW5uaW5nIDwgdC5tYXhfY29uY3VycmVudF9qb2JzKTtcbiAgYXNzZXJ0IChub3QgKFF1ZXVlLmlzX2VtcHR5IHQuam9ic193YWl0aW5nX3RvX3N0YXJ0KSk7XG4gIGxldCBqb2IgPSBRdWV1ZS5kZXF1ZXVlX2V4biB0LmpvYnNfd2FpdGluZ190b19zdGFydCBpblxuICB0Lm51bV9qb2JzX3J1bm5pbmcgPC0gdC5udW1fam9ic19ydW5uaW5nICsgMTtcbiAgbGV0IGpvYl9yZXNvdXJjZSA9IFN0YWNrX29yX2NvdW50ZXIucG9wX2V4biB0LmpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSBpblxuICBJbnRlcm5hbF9qb2IucnVuIGpvYiBqb2JfcmVzb3VyY2VcbiAgPj4+IGZ1biByZXMgLT5cbiAgdC5udW1fam9ic19ydW5uaW5nIDwtIHQubnVtX2pvYnNfcnVubmluZyAtIDE7XG4gIChtYXRjaCByZXMgd2l0aFxuICAgfCBgT2sgLT4gKClcbiAgIHwgYFJhaXNlZCAtPiBpZiBub3QgdC5jb250aW51ZV9vbl9lcnJvciB0aGVuIGtpbGwgdCk7XG4gIGlmIHQuaXNfZGVhZFxuICB0aGVuIGNsZWFuX3Jlc291cmNlIHQgam9iX3Jlc291cmNlXG4gIGVsc2UgKFxuICAgIFN0YWNrX29yX2NvdW50ZXIucHVzaCB0LmpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSBqb2JfcmVzb3VyY2U7XG4gICAgaWYgbm90IChRdWV1ZS5pc19lbXB0eSB0LmpvYnNfd2FpdGluZ190b19zdGFydClcbiAgICB0aGVuIHN0YXJ0X2pvYiB0XG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCB0LmNhcGFjaXR5X2F2YWlsYWJsZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBpdmFyIC0+XG4gICAgICAgIEl2YXIuZmlsbF9leG4gaXZhciAoKTtcbiAgICAgICAgdC5jYXBhY2l0eV9hdmFpbGFibGUgPC0gTm9uZSkpXG47O1xuXG5sZXQgY3JlYXRlX2ludGVybmFsIH5jb250aW51ZV9vbl9lcnJvciB+cmVzdCBqb2JfcmVzb3VyY2VzID1cbiAgbGV0IG1heF9jb25jdXJyZW50X2pvYnMgPSBTdGFja19vcl9jb3VudGVyLmxlbmd0aCBqb2JfcmVzb3VyY2VzIGluXG4gIHsgY29udGludWVfb25fZXJyb3JcbiAgOyByZXN0XG4gIDsgbWF4X2NvbmN1cnJlbnRfam9ic1xuICA7IGpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSA9IGpvYl9yZXNvdXJjZXNcbiAgOyBqb2JzX3dhaXRpbmdfdG9fc3RhcnQgPSBRdWV1ZS5jcmVhdGUgKClcbiAgOyBudW1fam9ic19ydW5uaW5nID0gMFxuICA7IGNhcGFjaXR5X2F2YWlsYWJsZSA9IE5vbmVcbiAgOyBpc19kZWFkID0gZmFsc2VcbiAgOyBjbGVhbnMgPSBbXVxuICA7IG51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPSBtYXhfY29uY3VycmVudF9qb2JzXG4gIDsgY2xlYW5lZCA9IEl2YXIuY3JlYXRlICgpXG4gIH1cbjs7XG5cbmxldCBjcmVhdGVfd2l0aCcgfnJlc3QgfmNvbnRpbnVlX29uX2Vycm9yIGpvYl9yZXNvdXJjZXMgPVxuICBjcmVhdGVfaW50ZXJuYWwgfnJlc3QgfmNvbnRpbnVlX29uX2Vycm9yIChTdGFja19vcl9jb3VudGVyLm9mX2xpc3Qgam9iX3Jlc291cmNlcylcbjs7XG5cbmxldCBjcmVhdGVfd2l0aCB+Y29udGludWVfb25fZXJyb3Igam9iX3Jlc291cmNlcyA9XG4gIGNyZWF0ZV93aXRoJyB+cmVzdDpgTG9nIH5jb250aW51ZV9vbl9lcnJvciBqb2JfcmVzb3VyY2VzXG47O1xuXG5tb2R1bGUgU2VxdWVuY2VyID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGNyZWF0ZSA/KHJlc3QgPSBgTG9nKSA/KGNvbnRpbnVlX29uX2Vycm9yID0gZmFsc2UpIGEgPVxuICAgIGNyZWF0ZV93aXRoJyB+cmVzdCB+Y29udGludWVfb25fZXJyb3IgWyBhIF1cbiAgOztcbmVuZFxuXG5sZXQgY3JlYXRlJyB+cmVzdCB+Y29udGludWVfb25fZXJyb3Igfm1heF9jb25jdXJyZW50X2pvYnMgPVxuICBpZiBtYXhfY29uY3VycmVudF9qb2JzIDw9IDBcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlRocm90dGxlLmNyZWF0ZSByZXF1aXJlcyBwb3NpdGl2ZSBtYXhfY29uY3VycmVudF9qb2JzLCBidXQgZ290XCJcbiAgICAgICAgICAobWF4X2NvbmN1cnJlbnRfam9icyA6IGludCldO1xuICBjcmVhdGVfaW50ZXJuYWxcbiAgICB+cmVzdFxuICAgIH5jb250aW51ZV9vbl9lcnJvclxuICAgIChTdGFja19vcl9jb3VudGVyLmNyZWF0ZV9jb3VudGVyIH5sZW5ndGg6bWF4X2NvbmN1cnJlbnRfam9icylcbjs7XG5cbmxldCBjcmVhdGUgfmNvbnRpbnVlX29uX2Vycm9yIH5tYXhfY29uY3VycmVudF9qb2JzID1cbiAgY3JlYXRlJyB+cmVzdDpgTG9nIH5jb250aW51ZV9vbl9lcnJvciB+bWF4X2NvbmN1cnJlbnRfam9ic1xuOztcblxubW9kdWxlIEpvYiA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgIHsgaW50ZXJuYWxfam9iIDogJ2EgSW50ZXJuYWxfam9iLnRcbiAgICA7IHJlc3VsdCA6IFsgYE9rIG9mICdiIHwgYEFib3J0ZWQgfCBgUmFpc2VkIG9mIGV4biBdIERlZmVycmVkLnRcbiAgICB9XG5cbiAgbGV0IHJlc3VsdCB0ID0gdC5yZXN1bHRcbiAgbGV0IGFib3J0IHQgPSBJbnRlcm5hbF9qb2IuYWJvcnQgdC5pbnRlcm5hbF9qb2JcblxuICBsZXQgY3JlYXRlIH5yZXN0IGYgPVxuICAgIGxldCBpbnRlcm5hbF9qb2IsIHJlc3VsdCA9IEludGVybmFsX2pvYi5jcmVhdGUgfnJlc3QgZiBpblxuICAgIHsgaW50ZXJuYWxfam9iOyByZXN1bHQgfVxuICA7O1xuZW5kXG5cbmxldCBlbnF1ZXVlX2ludGVybmFsIHQgZiBlbnF1ZXVlID1cbiAgbGV0IGpvYiA9IEpvYi5jcmVhdGUgfnJlc3Q6dC5yZXN0IGYgaW5cbiAgaWYgdC5pc19kZWFkXG4gIHRoZW4gSm9iLmFib3J0IGpvYlxuICBlbHNlIChcbiAgICBlbnF1ZXVlIHQuam9ic193YWl0aW5nX3RvX3N0YXJ0IGpvYi5pbnRlcm5hbF9qb2I7XG4gICAgaWYgdC5udW1fam9ic19ydW5uaW5nIDwgdC5tYXhfY29uY3VycmVudF9qb2JzIHRoZW4gc3RhcnRfam9iIHQpO1xuICBKb2IucmVzdWx0IGpvYlxuOztcblxubGV0IGhhbmRsZV9lbnF1ZXVlX3Jlc3VsdCByZXN1bHQgPVxuICBtYXRjaCByZXN1bHQgd2l0aFxuICB8IGBPayBhIC0+IGFcbiAgfCBgQWJvcnRlZCAtPiByYWlzZV9zIFslbWVzc2FnZSBcInRocm90dGxlIGFib3J0ZWQgam9iXCJdXG4gIHwgYFJhaXNlZCBleG4gLT4gcmFpc2UgZXhuXG47O1xuXG5sZXQgZW5xdWV1ZScgdCBmID0gKGVucXVldWVfaW50ZXJuYWwgW0BpbmxpbmVkXSkgdCBmIFF1ZXVlLmVucXVldWVcbmxldCBlbnF1ZXVlIHQgZiA9IGVucXVldWUnIHQgZiA+PnwgaGFuZGxlX2VucXVldWVfcmVzdWx0XG5sZXQgZW5xdWV1ZV9mcm9udCcgdCBmID0gKGVucXVldWVfaW50ZXJuYWwgW0BpbmxpbmVkXSkgdCBmIFF1ZXVlLmVucXVldWVfZnJvbnRcbmxldCBlbnF1ZXVlX2Zyb250IHQgZiA9IGVucXVldWVfZnJvbnQnIHQgZiA+PnwgaGFuZGxlX2VucXVldWVfcmVzdWx0XG5cbmxldCBlbnF1ZXVlX2V4Y2x1c2l2ZSB0IGYgPVxuICBsZXQgbiA9IHQubWF4X2NvbmN1cnJlbnRfam9icyBpblxuICBpZiBJbnQuKCA+PSApIG4gMV8wMDBfMDAwXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJXNleHBcbiAgICAgICAgXCJbZW5xdWV1ZV9leGNsdXNpdmVdIHdhcyBjYWxsZWQgd2l0aCBhIHZlcnkgbGFyZ2UgdmFsdWUgb2YgXFxcbiAgICAgICAgIFttYXhfY29uY3VycmVudF9qb2JzXS4gVGhpcyBkb2Vzbid0IHdvcmsuXCJdO1xuICBsZXQgZG9uZV8gPSBJdmFyLmNyZWF0ZSAoKSBpblxuICBhc3NlcnQgKG4gPiAwKTtcbiAgbGV0IGZfcGxhY2Vob2xkZXIgX3Nsb3QgPSBJdmFyLnJlYWQgZG9uZV8gaW5cbiAgZm9yIF8gPSAxIHRvIG4gLSAxIGRvXG4gICAgZG9uJ3Rfd2FpdF9mb3IgKGVucXVldWUgdCBmX3BsYWNlaG9sZGVyKVxuICBkb25lO1xuICBsZXQlbWFwIHJlc3VsdCA9IGVucXVldWUnIHQgKGZ1biBfc2xvdCAtPiBmICgpKSBpblxuICBJdmFyLmZpbGxfZXhuIGRvbmVfICgpO1xuICBoYW5kbGVfZW5xdWV1ZV9yZXN1bHQgcmVzdWx0XG47O1xuXG5sZXQgbW9uYWRfc2VxdWVuY2VfaG93IH5ob3cgfmYgPVxuICBzdGFnZVxuICAgIChtYXRjaCBob3cgd2l0aFxuICAgICB8IGBQYXJhbGxlbCAtPiBmXG4gICAgIHwgKGBTZXF1ZW50aWFsIHwgYE1heF9jb25jdXJyZW50X2pvYnMgXykgYXMgaG93IC0+XG4gICAgICAgbGV0IG1heF9jb25jdXJyZW50X2pvYnMgPVxuICAgICAgICAgbWF0Y2ggaG93IHdpdGhcbiAgICAgICAgIHwgYFNlcXVlbnRpYWwgLT4gMVxuICAgICAgICAgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBtYXhfY29uY3VycmVudF9qb2JzIC0+IG1heF9jb25jdXJyZW50X2pvYnNcbiAgICAgICBpblxuICAgICAgIGxldCB0ID0gY3JlYXRlIH5jb250aW51ZV9vbl9lcnJvcjpmYWxzZSB+bWF4X2NvbmN1cnJlbnRfam9icyBpblxuICAgICAgIGZ1biBhIC0+IGVucXVldWUgdCAoZnVuICgpIC0+IGYgYSkpXG47O1xuXG5sZXQgbW9uYWRfc2VxdWVuY2VfaG93MiB+aG93IH5mID1cbiAgc3RhZ2VcbiAgICAobWF0Y2ggaG93IHdpdGhcbiAgICAgfCBgUGFyYWxsZWwgLT4gZlxuICAgICB8IChgU2VxdWVudGlhbCB8IGBNYXhfY29uY3VycmVudF9qb2JzIF8pIGFzIGhvdyAtPlxuICAgICAgIGxldCBtYXhfY29uY3VycmVudF9qb2JzID1cbiAgICAgICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgICAgICB8IGBTZXF1ZW50aWFsIC0+IDFcbiAgICAgICAgIHwgYE1heF9jb25jdXJyZW50X2pvYnMgbWF4X2NvbmN1cnJlbnRfam9icyAtPiBtYXhfY29uY3VycmVudF9qb2JzXG4gICAgICAgaW5cbiAgICAgICBsZXQgdCA9IGNyZWF0ZSB+Y29udGludWVfb25fZXJyb3I6ZmFsc2Ugfm1heF9jb25jdXJyZW50X2pvYnMgaW5cbiAgICAgICBmdW4gYTEgYTIgLT4gZW5xdWV1ZSB0IChmdW4gKCkgLT4gZiBhMSBhMikpXG47O1xuXG5sZXQgcHJpb3Jfam9ic19kb25lIHQgPVxuICAoKiBXZSBxdWV1ZSBbdC5tYXhfY29uY3VycmVudF9qb2JzXSBkdW1teSBqb2JzIGFuZCB3aGVuIHRoZXkgYXJlIGFsbCBzdGFydGVkIHdlIGtub3dcbiAgICAgdGhhdCBhbGwgcHJpb3Igam9icyBmaW5pc2hlZC4gIFdlIG1ha2Ugc3VyZSB0aGF0IGFsbCBkdW1teSBqb2JzIHdhaXQgZm9yIHRoZSBsYXN0IG9uZVxuICAgICB0byBnZXQgc3RhcnRlZCBiZWZvcmUgZmluaXNoaW5nLiAqKVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBhbGxfZHVtbXlfam9ic19ydW5uaW5nIC0+XG4gICAgbGV0IGR1bW15X2pvYnNfcnVubmluZyA9IHJlZiAwIGluXG4gICAgZm9yIF8gPSAxIHRvIHQubWF4X2NvbmN1cnJlbnRfam9icyBkb1xuICAgICAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAgICAgKGVucXVldWUgdCAoZnVuIF8gLT5cbiAgICAgICAgICAgaW5jciBkdW1teV9qb2JzX3J1bm5pbmc7XG4gICAgICAgICAgIGlmICFkdW1teV9qb2JzX3J1bm5pbmcgPSB0Lm1heF9jb25jdXJyZW50X2pvYnNcbiAgICAgICAgICAgdGhlbiBJdmFyLmZpbGxfZXhuIGFsbF9kdW1teV9qb2JzX3J1bm5pbmcgKCk7XG4gICAgICAgICAgIEl2YXIucmVhZCBhbGxfZHVtbXlfam9ic19ydW5uaW5nKSlcbiAgICBkb25lKVxuOztcblxubGV0IGNhcGFjaXR5X2F2YWlsYWJsZSB0ID1cbiAgaWYgbnVtX2pvYnNfcnVubmluZyB0IDwgbWF4X2NvbmN1cnJlbnRfam9icyB0XG4gIHRoZW4gcmV0dXJuICgpXG4gIGVsc2UgKFxuICAgIG1hdGNoIHQuY2FwYWNpdHlfYXZhaWxhYmxlIHdpdGhcbiAgICB8IFNvbWUgaXZhciAtPiBJdmFyLnJlYWQgaXZhclxuICAgIHwgTm9uZSAtPiBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+IHQuY2FwYWNpdHlfYXZhaWxhYmxlIDwtIFNvbWUgaXZhcikpXG47O1xuIiwib3BlbiEgQ29yZVxuaW5jbHVkZSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTBcblxubGV0IGNyZWF0ZSA9IFNjaGVkdWxlcjEuY3JlYXRlX3RpbWVfc291cmNlXG5sZXQgd2FsbF9jbG9jayA9IFNjaGVkdWxlcjEud2FsbF9jbG9ja1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIFNjaGVkdWxlclxuXG5sZXQgZW5xdWV1ZV9qb2IgZXhlY3V0aW9uX2NvbnRleHQgZiBhID0gZW5xdWV1ZSAodCAoKSkgZXhlY3V0aW9uX2NvbnRleHQgZiBhXG5cbmxldCB0aHJlYWRfc2FmZV9lbnF1ZXVlX2pvYiBleGVjdXRpb25fY29udGV4dCBmIGEgPVxuICB0aHJlYWRfc2FmZV9lbnF1ZXVlX2V4dGVybmFsX2pvYiAodCAoKSkgZXhlY3V0aW9uX2NvbnRleHQgZiBhXG47O1xuXG5sZXQgY3VycmVudF9leGVjdXRpb25fY29udGV4dCAoKSA9IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpXG5sZXQgY3ljbGVfY291bnQgKCkgPSBjeWNsZV9jb3VudCAodCAoKSlcbmxldCBjeWNsZV9zdGFydF9ucyAoKSA9IGN5Y2xlX3N0YXJ0ICh0ICgpKVxubGV0IGN5Y2xlX3N0YXJ0ICgpID0gVGltZV9ucy50b190aW1lX2Zsb2F0X3JvdW5kX25lYXJlc3QgKGN5Y2xlX3N0YXJ0X25zICgpKVxubGV0IGN5Y2xlX3RpbWVzX25zICgpID0gbWFwX2N5Y2xlX3RpbWVzICh0ICgpKSB+ZjpGbi5pZFxubGV0IGN5Y2xlX3RpbWVzICgpID0gbWFwX2N5Y2xlX3RpbWVzICh0ICgpKSB+ZjpUaW1lX25zLlNwYW4udG9fc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0XG5sZXQgdG90YWxfY3ljbGVfdGltZSAoKSA9IHRvdGFsX2N5Y2xlX3RpbWUgKHQgKCkpXG5sZXQgbGFzdF9jeWNsZV90aW1lICgpID0gbGFzdF9jeWNsZV90aW1lICh0ICgpKVxubGV0IGxvbmdfY3ljbGVzIH5hdF9sZWFzdCA9IGxvbmdfY3ljbGVzICh0ICgpKSB+YXRfbGVhc3RcbmxldCBldmVudF9wcmVjaXNpb25fbnMgKCkgPSBldmVudF9wcmVjaXNpb24gKHQgKCkpXG5sZXQgZXZlbnRfcHJlY2lzaW9uICgpID0gVGltZV9ucy5TcGFuLnRvX3NwYW5fZmxvYXRfcm91bmRfbmVhcmVzdCAoZXZlbnRfcHJlY2lzaW9uX25zICgpKVxuXG5sZXQgc2V0X21heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlIGkgPVxuICBzZXRfbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgKHQgKCkpIGlcbjs7XG5cbmxldCBtYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZSAoKSA9IG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlICh0ICgpKVxubGV0IHNldF9yZWNvcmRfYmFja3RyYWNlcyBib29sID0gc2V0X3JlY29yZF9iYWNrdHJhY2VzICh0ICgpKSBib29sXG5sZXQgcmVjb3JkaW5nX2JhY2t0cmFjZXMgKCkgPSByZWNvcmRpbmdfYmFja3RyYWNlcyAodCAoKSlcbmxldCBmb3JjZV9jdXJyZW50X2N5Y2xlX3RvX2VuZCAoKSA9IGZvcmNlX2N1cnJlbnRfY3ljbGVfdG9fZW5kICh0ICgpKVxubGV0IHlpZWxkICgpID0geWllbGQgKHQgKCkpXG5cbmxldCB5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiA/bWF5X3JldHVybl9pbW1lZGlhdGVseSAoKSA9XG4gIHlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluID9tYXlfcmV0dXJuX2ltbWVkaWF0ZWx5ICh0ICgpKVxuOztcblxubGV0IHlpZWxkX2V2ZXJ5IH5uID1cbiAgbGV0IHlpZWxkX2V2ZXJ5ID0gU3RhZ2VkLnVuc3RhZ2UgKHlpZWxkX2V2ZXJ5IH5uKSBpblxuICBsZXQgdCA9IHQgKCkgaW5cbiAgc3RhZ2UgKGZ1biAoKSAtPiB5aWVsZF9ldmVyeSB0KVxuOztcblxubGV0IG51bV9qb2JzX3J1biAoKSA9IG51bV9qb2JzX3J1biAodCAoKSlcbmxldCBudW1fcGVuZGluZ19qb2JzICgpID0gbnVtX3BlbmRpbmdfam9icyAodCAoKSlcblxubW9kdWxlIEV4cGVydCA9IHN0cnVjdFxuICBsZXQgc2V0X2V4ZWN1dGlvbl9jb250ZXh0IGNvbnRleHQgPSBzZXRfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpIGNvbnRleHRcbiAgbGV0IHJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haW4gPSBydW5fY3ljbGVzX3VudGlsX25vX2pvYnNfcmVtYWluXG4gIGxldCBsYXN0X2N5Y2xlX251bV9qb2JzICgpID0gbGFzdF9jeWNsZV9udW1fam9icyAodCAoKSlcbiAgbGV0IHJ1bl9ldmVyeV9jeWNsZV9zdGFydCBmID0gcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0ICh0ICgpKSB+ZlxuICBsZXQgcnVuX2V2ZXJ5X2N5Y2xlX2VuZCBmID0gcnVuX2V2ZXJ5X2N5Y2xlX2VuZCAodCAoKSkgfmZcbiAgbGV0IGFkZF9ldmVyeV9jeWNsZV9zdGFydF9ob29rIH5mID0gYWRkX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2sgKHQgKCkpIH5mXG4gIGxldCBhZGRfZXZlcnlfY3ljbGVfZW5kX2hvb2sgfmYgPSBhZGRfZXZlcnlfY3ljbGVfZW5kX2hvb2sgKHQgKCkpIH5mXG5cbiAgbGV0IHJlbW92ZV9ldmVyeV9jeWNsZV9zdGFydF9ob29rX2V4biBoYW5kbGUgPVxuICAgIHJlbW92ZV9ldmVyeV9jeWNsZV9zdGFydF9ob29rX2V4biAodCAoKSkgaGFuZGxlXG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9ldmVyeV9jeWNsZV9lbmRfaG9va19leG4gaGFuZGxlID1cbiAgICByZW1vdmVfZXZlcnlfY3ljbGVfZW5kX2hvb2tfZXhuICh0ICgpKSBoYW5kbGVcbiAgOztcblxuICBsZXQgd2l0aF9leGVjdXRpb25fY29udGV4dCBleGVjdXRpb25fY29udGV4dCBmID1cbiAgICB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSBleGVjdXRpb25fY29udGV4dCB+ZlxuICA7O1xuXG4gIGxldCB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0MSBleGVjdXRpb25fY29udGV4dCB+ZiB4ID1cbiAgICB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0MSAodCAoKSkgZXhlY3V0aW9uX2NvbnRleHQgfmYgeFxuICA7O1xuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gU2NoZWR1bGVyXG4iLCIoKiogU2NoZWR1bGUgam9icyB0byBydW4gYXQgYSB0aW1lIGluIHRoZSBmdXR1cmUuXG5cbiAgICBUaGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbiB1c2VzIGEgaGVhcCBvZiBldmVudHMsIG9uZSBmb3IgZWFjaCBqb2IgdGhhdCBuZWVkcyB0b1xuICAgIHJ1biBpbiB0aGUgZnV0dXJlLiAgVGhlIEFzeW5jIHNjaGVkdWxlciBpcyByZXNwb25zaWJsZSBmb3Igd2FraW5nIHVwIGF0IHRoZSByaWdodCB0aW1lXG4gICAgdG8gcnVuIHRoZSBqb2JzLiAqKVxuXG5vcGVuIENvcmVcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5tb2R1bGUgT3JfdGltZW91dCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIFsgYFJlc3VsdCBvZiAnYVxuICAgIHwgYFRpbWVvdXRcbiAgICBdXG4gIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5lbmRcblxubW9kdWxlIHR5cGUgQ2xvY2sgPSBzaWdcbiAgbW9kdWxlIE9yX3RpbWVvdXQgPSBPcl90aW1lb3V0XG5cbiAgbW9kdWxlIFRpbWUgOiBzaWdcbiAgICBtb2R1bGUgU3BhbiA6IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgZW5kXG5cbiAgICB0eXBlIHRcbiAgZW5kXG5cbiAgKCoqIFtydW5fYXQgdGltZSBmIGFdIHJ1bnMgW2YgYV0gYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciBbdGltZV0uICBJZiBbdGltZV0gaXMgaW4gdGhlXG4gICAgICBwYXN0LCB0aGVuIFtydW5fYXRdIHdpbGwgaW1tZWRpYXRlbHkgc2NoZWR1bGUgYSBqb2IgW3RdIHRoYXQgd2lsbCBydW4gW2YgYV0uICBJbiBub1xuICAgICAgc2l0dWF0aW9uIHdpbGwgW3J1bl9hdF0gYWN0dWFsbHkgY2FsbCBbZl0gaXRzZWxmLiAgVGhlIGNhbGwgdG8gW2ZdIHdpbGwgYWx3YXlzIGJlIGluXG4gICAgICBhbm90aGVyIGpvYi4gKilcbiAgdmFsIHJ1bl9hdCA6IFRpbWUudCAtPiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdFxuXG4gICgqKiBbcnVuX2FmdGVyXSBpcyBsaWtlIFtydW5fYXRdLCBleGNlcHQgdGhhdCBvbmUgc3BlY2lmaWVzIGEgdGltZSBzcGFuIHJhdGhlciB0aGFuIGFuXG4gICAgICBhYnNvbHV0ZSB0aW1lLiAqKVxuICB2YWwgcnVuX2FmdGVyIDogVGltZS5TcGFuLnQgLT4gKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXRcblxuICAoKiogW2F0IHRpbWVdIHJldHVybnMgYSBkZWZlcnJlZCBbZF0gdGhhdCB3aWxsIGJlY29tZSBkZXRlcm1pbmVkIGFzIHNvb24gYXMgcG9zc2libGVcbiAgICAgIGFmdGVyIFt0aW1lXS4gKilcbiAgdmFsIGF0IDogVGltZS50IC0+IHVuaXQgRGVmZXJyZWQudFxuXG4gICgqKiBbYWZ0ZXJdIGlzIGxpa2UgW2F0XSwgZXhjZXB0IHRoYXQgb25lIHNwZWNpZmllcyBhIHRpbWUgc3BhbiByYXRoZXIgdGhhbiBhbiBhYnNvbHV0ZVxuICAgICAgdGltZS4gKilcbiAgdmFsIGFmdGVyIDogVGltZS5TcGFuLnQgLT4gdW5pdCBEZWZlcnJlZC50XG5cbiAgKCoqIFt3aXRoX3RpbWVvdXQgc3BhbiBkXSByZXR1cm5zIGEgZGVmZXJyZWQgdGhhdCB3aWxsIGJlY29tZSBkZXRlcm1pbmVkIGFmdGVyIGVpdGhlclxuICAgICAgW3NwYW5dIGVsYXBzZXMgb3IgW2RdIGlzIGRldGVybWluZWQsIHJldHVybmluZyBlaXRoZXIgW2BUaW1lb3V0XSBvciBbYFJlc3VsdF1cbiAgICAgIGRlcGVuZGluZyBvbiB3aGljaCBvbmUgc3VjY2VlZGVkIGZpcnN0LiAgQXQgdGhlIHRpbWUgdGhlIHJldHVybmVkIGRlZmVycmVkIGJlY29tZXNcbiAgICAgIGRldGVybWluZWQsIGJvdGggdGhpbmdzIG1heSBoYXZlIGhhcHBlbmVkLCBpbiB3aGljaCBjYXNlIFtgUmVzdWx0XSBpcyBnaXZlblxuICAgICAgcHJlZmVyZW5jZS4gKilcbiAgdmFsIHdpdGhfdGltZW91dCA6IFRpbWUuU3Bhbi50IC0+ICdhIERlZmVycmVkLnQgLT4gJ2EgT3JfdGltZW91dC50IERlZmVycmVkLnRcblxuICAoKiogW3dpdGhfdGltZW91dF9leG4gc3BhbiBkIH5lcnJvcl0gaXMgbGlrZSBbd2l0aF90aW1lb3V0XSwgYnV0IHJhaXNlcyBpZiB0aGUgdGltZW91dFxuICAgICAgb2NjdXJzLiBZb3Ugc2hvdWxkIGJlIGNhcmVmdWwgd2l0aCB0aGUgW0Vycm9yLnRdIHlvdSBwYXNzIGJlY2F1c2UgaXRzIGVhc3kgdG9cbiAgICAgIGFsbG9jYXRlIGEgbGFyZ2UgdmFsdWUgdGhhdCB3aWxsIGJlIHVudXNlZC4gVG8gYXZvaWQgdGhpcywgeW91IHNob3VsZCB1c2Ugb25lIG9mIHRoZVxuICAgICAgbGF6eS1jcmVhdGlvbiBmdW5jdGlvbnMgaW4gdGhlIFtFcnJvcl0gbW9kdWxlLiAqKVxuICB2YWwgd2l0aF90aW1lb3V0X2V4biA6IFRpbWUuU3Bhbi50IC0+ICdhIERlZmVycmVkLnQgLT4gZXJyb3I6RXJyb3IudCAtPiAnYSBEZWZlcnJlZC50XG5cbiAgKCoqIEV2ZW50cyBwcm92aWRlIHZhcmlhbnRzIG9mIFtydW5fYXRdIGFuZCBbcnVuX2FmdGVyXSB3aXRoIHRoZSBhYmlsaXR5IHRvIGFib3J0IG9yXG4gICAgICByZXNjaGVkdWxlIGFuIGV2ZW50IHRoYXQgaGFzbid0IHlldCBoYXBwZW5lZC4gIE9uY2UgYW4gZXZlbnQgaGFwcGVucyBvciBpcyBhYm9ydGVkLFxuICAgICAgQXN5bmMgZG9lc24ndCB1c2UgYW55IHNwYWNlIGZvciB0cmFja2luZyBpdC4gKilcbiAgbW9kdWxlIEV2ZW50IDogc2lnXG4gICAgdHlwZSAoJ2EsICdoKSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gICAgdHlwZSB0X3VuaXQgPSAodW5pdCwgdW5pdCkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBJbnZhcmlhbnQuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICAgdmFsIHNjaGVkdWxlZF9hdCA6IChfLCBfKSB0IC0+IFRpbWUudFxuXG4gICAgbW9kdWxlIFN0YXR1cyA6IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICAgICAgfCBBYm9ydGVkIG9mICdhXG4gICAgICAgIHwgSGFwcGVuZWQgb2YgJ2hcbiAgICAgICAgfCBTY2hlZHVsZWRfYXQgb2YgVGltZS50XG4gICAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIGVuZFxuXG4gICAgKCoqIElmIFtzdGF0dXNdIHJldHVybnMgW1NjaGVkdWxlZF9hdCB0aW1lXSwgaXQgaXMgcG9zc2libGUgdGhhdCBbdGltZSA8IFRpbWUubm93ICgpXVxuICAgICAgICBpZiBBc3luYydzIHNjaGVkdWxlciBoYXNuJ3QgeWV0IGdvdHRlbiB0aGUgY2hhbmNlIHRvIHVwZGF0ZSBpdHMgY2xvY2ssIGUuZy4sIGR1ZVxuICAgICAgICB0byB1c2VyIGpvYnMgcnVubmluZy4gKilcbiAgICB2YWwgc3RhdHVzIDogKCdhLCAnaCkgdCAtPiAoJ2EsICdoKSBTdGF0dXMudFxuXG4gICAgKCoqIExldCBbdCA9IHJ1bl9hdCB0aW1lIGYgel0uICBBdCBbdGltZV0sIHRoaXMgcnVucyBbZiB6XSBhbmQgdHJhbnNpdGlvbnMgW3N0YXR1cyB0XVxuICAgICAgICB0byBbSGFwcGVuZWQgaF0sIHdoZXJlIFtoXSBpcyByZXN1bHQgb2YgW2Ygel0uXG5cbiAgICAgICAgTW9yZSBwcmVjaXNlbHksIGF0IFt0aW1lXSwgcHJvdmlkZWQgW2Fib3J0IHQgYV0gaGFzIG5vdCBwcmV2aW91c2x5IGJlZW4gY2FsbGVkLFxuICAgICAgICB0aGlzIHdpbGwgY2FsbCBbZiB6XSwgd2l0aCB0aGUgZ3VhcmFudGVlIHRoYXQgW3N0YXR1cyB0ID0gU2NoZWR1bGVkX2F0IHRpbWVdLiAgSWZcbiAgICAgICAgW2Ygel0gcmV0dXJucyBbaF0gYW5kIGRpZCBub3QgY2FsbCBbYWJvcnQgdCBhXSwgdGhlbiBbc3RhdHVzIHRdIGJlY29tZXMgW0hhcHBlbmVkXG4gICAgICAgIGhdLiAgSWYgW2Ygel0gY2FsbHMgW2Fib3J0IHQgYV0sIHRoZW4gdGhlIHJlc3VsdCBvZiBbZl0gaXMgaWdub3JlZCwgYW5kIFtzdGF0dXMgdF1cbiAgICAgICAgaXMgW0Fib3J0ZWQgYV0uXG5cbiAgICAgICAgSWYgW2Ygel0gcmFpc2VzLCB0aGVuIFtzdGF0dXMgdF0gZG9lcyBub3QgdHJhbnNpdGlvbiBhbmQgcmVtYWlucyBbU2NoZWR1bGVkX2F0XG4gICAgICAgIHRpbWVdLCBhbmQgdGhlIGV4Y2VwdGlvbiBpcyBzZW50IHRvIHRoZSBtb25pdG9yIGluIGVmZmVjdCB3aGVuIFtydW5fYXRdIHdhc1xuICAgICAgICBjYWxsZWQuICopXG4gICAgdmFsIHJ1bl9hdCA6IFRpbWUudCAtPiAoJ3ogLT4gJ2gpIC0+ICd6IC0+IChfLCAnaCkgdFxuXG4gICAgdmFsIHJ1bl9hZnRlciA6IFRpbWUuU3Bhbi50IC0+ICgneiAtPiAnaCkgLT4gJ3ogLT4gKF8sICdoKSB0XG5cbiAgICBtb2R1bGUgQWJvcnRfcmVzdWx0ID0gVGltZV9zb3VyY2UuRXZlbnQuQWJvcnRfcmVzdWx0XG5cbiAgICAoKiogW2Fib3J0IHRdIGNoYW5nZXMgW3N0YXR1cyB0XSB0byBbQWJvcnRlZF0gYW5kIHJldHVybnMgW09rXSwgdW5sZXNzIFt0XVxuICAgICAgICBwcmV2aW91c2x5IGhhcHBlbmVkIG9yIHdhcyBwcmV2aW91c2x5IGFib3J0ZWQuICopXG4gICAgdmFsIGFib3J0IDogKCdhLCAnaCkgdCAtPiAnYSAtPiAoJ2EsICdoKSBBYm9ydF9yZXN1bHQudFxuXG4gICAgKCoqIFthYm9ydF9leG4gdCBhXSByZXR1cm5zIFt1bml0XSBpZiBbYWJvcnQgdCBhID0gYE9rXSwgYW5kIG90aGVyd2lzZSByYWlzZXMuICopXG4gICAgdmFsIGFib3J0X2V4biA6ICgnYSwgJ2gpIHQgLT4gJ2EgLT4gdW5pdFxuXG4gICAgKCoqIFthYm9ydF9pZl9wb3NzaWJsZSB0IGEgPSBpZ25vcmUgKGFib3J0IHQgYSldLiAqKVxuICAgIHZhbCBhYm9ydF9pZl9wb3NzaWJsZSA6ICgnYSwgXykgdCAtPiAnYSAtPiB1bml0XG5cbiAgICBtb2R1bGUgRmlyZWQgPSBUaW1lX3NvdXJjZS5FdmVudC5GaXJlZFxuXG4gICAgdmFsIGZpcmVkIDogKCdhLCAnaCkgdCAtPiAoJ2EsICdoKSBGaXJlZC50IERlZmVycmVkLnRcblxuICAgIG1vZHVsZSBSZXNjaGVkdWxlX3Jlc3VsdCA9IFRpbWVfc291cmNlLkV2ZW50LlJlc2NoZWR1bGVfcmVzdWx0XG5cbiAgICAoKiogW3Jlc2NoZWR1bGVfYXQgdF0gYW5kIFtyZXNjaGVkdWxlX2FmdGVyIHRdIGNoYW5nZSB0aGUgdGltZSB0aGF0IFt0XSB3aWxsIGZpcmUsIGlmXG4gICAgICAgIHBvc3NpYmxlLCBhbmQgaWYgbm90LCBnaXZlIGEgcmVhc29uIHdoeS4gIExpa2UgW3J1bl9hdF0sIGlmIHRoZSByZXF1ZXN0ZWQgdGltZSBpc1xuICAgICAgICBpbiB0aGUgcGFzdCwgdGhlIGV2ZW50IHdpbGwgYmUgc2NoZWR1bGVkIHRvIHJ1biBpbW1lZGlhdGVseS4gIElmIFtyZXNjaGVkdWxlX2F0IHRcbiAgICAgICAgdGltZSA9IE9rXSwgdGhlbiBzdWJzZXF1ZW50bHkgW3NjaGVkdWxlZF9hdCB0ID0gdGltZV0uICAqKVxuICAgIHZhbCByZXNjaGVkdWxlX2F0IDogKCdhLCAnaCkgdCAtPiBUaW1lLnQgLT4gKCdhLCAnaCkgUmVzY2hlZHVsZV9yZXN1bHQudFxuXG4gICAgdmFsIHJlc2NoZWR1bGVfYWZ0ZXIgOiAoJ2EsICdoKSB0IC0+IFRpbWUuU3Bhbi50IC0+ICgnYSwgJ2gpIFJlc2NoZWR1bGVfcmVzdWx0LnRcblxuICAgICgqKiBbYXQgdGltZV0gICAgaXMgW3J1bl9hdCAgICB0aW1lIGlnbm9yZSAoKV0uXG4gICAgICAgIFthZnRlciB0aW1lXSBpcyBbcnVuX2FmdGVyIHRpbWUgaWdub3JlICgpXS5cblxuICAgICAgICBZb3Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIHRoZSBbcnVuXypdIGZ1bmN0aW9ucywgd2hpY2ggYWxsb3cgeW91IHRvXG4gICAgICAgIHN5bmNocm9ub3VzbHkgdXBkYXRlIHN0YXRlIHZpYSBhIHVzZXItc3VwcGxpZWQgZnVuY3Rpb24gd2hlbiB0aGUgZXZlbnRcbiAgICAgICAgdHJhbnNpdGlvbnMgdG8gW0hhcHBlbmVkXS4gIFRoYXQgaXMsIHRoZXJlIGlzIGFuIGltcG9ydGFudCBkaWZmZXJlbmNlIGJldHdlZW46XG5cbiAgICAgICAge1tcbiAgICAgICAgICBsZXQgdCA9IHJ1bl9hdCB0aW1lIGYgKCkgXX1cblxuICAgICAgICBhbmQ6XG5cbiAgICAgICAge1tcbiAgICAgICAgICBsZXQgdCA9IGF0IHRpbWUgaW5cbiAgICAgICAgICBmaXJlZCB0XG4gICAgICAgICAgPj4+IGZ1bmN0aW9uXG4gICAgICAgICAgfCBIYXBwZW5lZCAoKSAtPiBmICgpXG4gICAgICAgICAgfCBBYm9ydGVkICgpIC0+ICgpIF19XG5cbiAgICAgICAgV2l0aCBbcnVuX2F0XSwgaWYgW3N0YXR1cyB0ID0gSGFwcGVuZWRdLCBvbmUga25vd3MgdGhhdCBbZl0gaGFzIHJ1bi4gIFdpdGggW2F0XVxuICAgICAgICBhbmQgW2ZpcmVkXSwgb25lIGRvZXMgbm90IGtub3cgd2hldGhlciBbZl0gaGFzIHlldCBydW47IGl0IG1heSBzdGlsbCBiZSBzY2hlZHVsZWRcbiAgICAgICAgdG8gcnVuLiAgVGh1cywgd2l0aCBbYXRdIGFuZCBbZmlyZWRdLCBpdCBpcyBlYXN5IHRvIGludHJvZHVjZSBhIHJhY2UuICBGb3JcbiAgICAgICAgZXhhbXBsZSwgY29uc2lkZXIgdGhlc2UgdHdvIGNvZGUgc25pcHBldHM6XG5cbiAgICAgICAge1tcbiAgICAgICAgICBsZXQgdCA9IEV2ZW50LmFmdGVyIChzZWMgMi4pIGluXG4gICAgICAgICAgdXBvbiAoRXZlbnQuZmlyZWQgdCkgKGZ1bmN0aW9uXG4gICAgICAgICAgICB8IEFib3J0ZWQgKCkgLT4gKClcbiAgICAgICAgICAgIHwgSGFwcGVuZWQgKCkgLT4gcHJpbnRmIFwiVGltZXIgZmlyZWRcIik7XG4gICAgICAgICAgdXBvbiBkZWZlcnJlZF9ldmVudCAoZnVuICgpIC0+XG4gICAgICAgICAgICBtYXRjaCBFdmVudC5hYm9ydCB0ICgpIHdpdGhcbiAgICAgICAgICAgIHwgT2sgLT4gcHJpbnRmIFwiRXZlbnQgb2NjdXJyZWRcIlxuICAgICAgICAgICAgfCBQcmV2aW91c2x5X2Fib3J0ZWQgKCkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB8IFByZXZpb3VzbHlfaGFwcGVuZWQgKCkgLT4gcHJpbnRmIFwiRXZlbnQgb2NjdXJyZWQgYWZ0ZXIgdGltZXIgZmlyZWRcIik7IF19XG5cbiAgICAgICAge1tcbiAgICAgICAgICBsZXQgdCA9IEV2ZW50LnJ1bl9hZnRlciAoc2VjIDIuKSBwcmludGYgXCJUaW1lciBmaXJlZFwiIGluXG4gICAgICAgICAgdXBvbiBkZWZlcnJlZF9ldmVudCAoZnVuICgpIC0+XG4gICAgICAgICAgICBtYXRjaCBFdmVudC5hYm9ydCB0ICgpIHdpdGhcbiAgICAgICAgICAgIHwgT2sgLT4gcHJpbnRmIFwiRXZlbnQgb2NjdXJyZWRcIlxuICAgICAgICAgICAgfCBQcmV2aW91c2x5X2Fib3J0ZWQgKCkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB8IFByZXZpb3VzbHlfaGFwcGVuZWQgKCkgLT4gcHJpbnRmIFwiRXZlbnQgb2NjdXJyZWQgYWZ0ZXIgdGltZXIgZmlyZWRcIik7IF19XG5cbiAgICAgICAgSW4gYm90aCBzbmlwcGV0cywgaWYgW0V2ZW50LmFib3J0XSByZXR1cm5zIFtPa10sIFwiVGltZXIgZmlyZWRcIiBpcyBuZXZlciBwcmludGVkLlxuICAgICAgICBIb3dldmVyLCB0aGUgZmlyc3Qgc25pcHBldCBtaWdodCBwcmludCBcIkV2ZW50IG9jY3VycmVkIGFmdGVyIHRpbWVyIGZpcmVkXCIgYW5kIHRoZW5cbiAgICAgICAgXCJUaW1lciBmaXJlZFwiLiAgVGhpcyBjb25mdXNlZCBvcmRlcmluZyBjYW5ub3QgaGFwcGVuIHdpdGggW0V2ZW50LnJ1bl9hZnRlcl0uICopXG4gICAgdmFsIGF0IDogVGltZS50IC0+IChfLCB1bml0KSB0XG5cbiAgICB2YWwgYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiAoXywgdW5pdCkgdFxuICBlbmRcblxuICAoKiogW2F0X3ZhcnlpbmdfaW50ZXJ2YWxzIGYgP3N0b3BdIHJldHVybnMgYSBzdHJlYW0gd2hvc2UgbmV4dCBlbGVtZW50IGJlY29tZXNcbiAgICAgIGRldGVybWluZWQgYnkgY2FsbGluZyBbZiAoKV0gYW5kIHdhaXRpbmcgZm9yIHRoYXQgYW1vdW50IG9mIHRpbWUsIGFuZCB0aGVuIGxvb3BpbmdcbiAgICAgIHRvIGRldGVybWluZSBzdWJzZXF1ZW50IGVsZW1lbnRzLiAgVGhlIHN0cmVhbSB3aWxsIGVuZCBhZnRlciBbc3RvcF0gYmVjb21lc1xuICAgICAgZGV0ZXJtaW5lZC4gKilcbiAgdmFsIGF0X3ZhcnlpbmdfaW50ZXJ2YWxzXG4gICAgOiAgP3N0b3A6dW5pdCBEZWZlcnJlZC50XG4gICAgLT4gKHVuaXQgLT4gVGltZS5TcGFuLnQpXG4gICAgLT4gdW5pdCBBc3luY19zdHJlYW0udFxuXG4gICgqKiBbYXRfaW50ZXJ2YWxzIGludGVydmFsID9zdGFydCA/c3RvcF0gcmV0dXJucyBhIHN0cmVhbSB3aG9zZSBlbGVtZW50cyB3aWxsIGJlY29tZVxuICAgICAgZGV0ZXJtaW5lZCBhdCBub25uZWdhdGl2ZSBpbnRlZ2VyIG11bHRpcGxlcyBvZiBbaW50ZXJ2YWxdIGFmdGVyIHRoZSBbc3RhcnRdIHRpbWUsXG4gICAgICB1bnRpbCBbc3RvcF0gYmVjb21lcyBkZXRlcm1pbmVkOlxuXG4gICAgICB7dlxuICAgICAgICBzdGFydCArIDAgKiBpbnRlcnZhbFxuICAgICAgICBzdGFydCArIDEgKiBpbnRlcnZhbFxuICAgICAgICBzdGFydCArIDIgKiBpbnRlcnZhbFxuICAgICAgICBzdGFydCArIDMgKiBpbnRlcnZhbFxuICAgICAgICAuLi5cbiAgICAgIHZ9XG5cbiAgICAgIE5vdGUgdGhhdCBvbmx5IGVsZW1lbnRzIHRoYXQgYXJlIHN0cmljdGx5IGluIHRoZSBmdXR1cmUgZXZlciBiZWNvbWUgZGV0ZXJtaW5lZC5cbiAgICAgIEluIHBhcnRpY3VsYXIsIGlmIFtzdGFydF0gaXMgbm90IGluIHRoZSBmdXR1cmUsIG9yIFtzdGFydF0gaXMgbm90IHByb3ZpZGVkLFxuICAgICAgdGhlbiB0aGVyZSB3aWxsIGJlIG5vIGVsZW1lbnQgYmVmb3JlIHRoZSBbaW50ZXJ2YWxdIGhhcyBwYXNzZWQuXG5cbiAgICAgIElmIHRoZSBpbnRlcnZhbCBpcyB0b28gc21hbGwgb3IgdGhlIENQVSBpcyB0b28gbG9hZGVkLCBbYXRfaW50ZXJ2YWxzXSB3aWxsIHNraXBcbiAgICAgIHVudGlsIHRoZSBuZXh0IHVwY29taW5nIG11bHRpcGxlIG9mIFtpbnRlcnZhbF0gYWZ0ZXIgW3N0YXJ0XS4gKilcbiAgdmFsIGF0X2ludGVydmFsc1xuICAgIDogID9zdGFydDpUaW1lLnRcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnRcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+IHVuaXQgQXN5bmNfc3RyZWFtLnRcblxuICAoKiogW2V2ZXJ5JyA/c3RhcnQgP3N0b3Agc3BhbiBmXSBydW5zIFtmICgpXSBldmVyeSBbc3Bhbl0gYW1vdW50IG9mIHRpbWUgc3RhcnRpbmcgd2hlblxuICAgICAgW3N0YXJ0XSBiZWNvbWVzIGRldGVybWluZWQgYW5kIHN0b3BwaW5nIHdoZW4gW3N0b3BdIGJlY29tZXMgZGV0ZXJtaW5lZC4gIFtldmVyeSddXG4gICAgICB3YWl0cyB1bnRpbCB0aGUgb3V0Y29tZSBvZiBbZiAoKV0gYmVjb21lcyBkZXRlcm1pbmVkIGJlZm9yZSB3YWl0aW5nIGZvciB0aGUgbmV4dFxuICAgICAgW3NwYW5dLlxuXG4gICAgICBJdCBpcyBndWFyYW50ZWVkIHRoYXQgaWYgW3N0b3BdIGJlY29tZXMgZGV0ZXJtaW5lZCwgZXZlbiBkdXJpbmcgZXZhbHVhdGlvbiBvZiBbZl0sXG4gICAgICB0aGVuIFtmXSB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW4gYnkgYSBzdWJzZXF1ZW50IGl0ZXJhdGlvbiBvZiB0aGUgbG9vcC5cblxuICAgICAgSXQgaXMgYW4gZXJyb3IgZm9yIFtzcGFuXSB0byBiZSBub25wb3NpdGl2ZS5cblxuICAgICAgW2NvbnRpbnVlX29uX2Vycm9yXSBjb250cm9scyB3aGF0IHNob3VsZCBoYXBwZW4gaWYgW2ZdIHJhaXNlcyBhbiBleGNlcHRpb24uXG4gICAgICBXaXRoIFt+Y29udGludWVfb25fZXJyb3I6ZmFsc2VdLCBpdGVyYXRpb24gb25seSBjb250aW51ZXMgaWYgW2ZdIHN1Y2Nlc3NmdWxseVxuICAgICAgcmV0dXJucyBhIGRlZmVycmVkIGFuZCB0aGF0IGRlZmVycmVkIGlzIGRldGVybWluZWQuXG4gICAgICBXaXRoIFt+Y29udGludWVfb25fZXJyb3I6dHJ1ZV0sIGl0ZXJhdGlvbiBhbHNvIGNvbnRpbnVlcyBpZiBbZl0gcmFpc2VzIGFuIGV4Y2VwdGlvbi5cbiAgICAgIElmIFtmXSByYWlzZXMgYW4gZXhjZXB0aW9uIGFzeW5jaHJvbm91c2x5LCB0aGlzIG1heSBjYXVzZSB1cyB0byBwcm9jZWVkIHdpdGggdGhlXG4gICAgICBuZXh0IGl0ZXJhdGlvbiB3aGlsZSB0aGUgcHJldmlvdXMgY2FsbCB0byBbZl0gaXMgc3RpbGwgcnVubmluZy5cblxuICAgICAgRXhjZXB0aW9ucyByYWlzZWQgYnkgW2ZdIGFyZSBhbHdheXMgc2VudCB0byB0aGUgbW9uaXRvciBpbiBlZmZlY3Qgd2hlbiBbZXZlcnknXSB3YXNcbiAgICAgIGNhbGxlZCwgZXZlbiB3aXRoIFt+Y29udGludWVfb25fZXJyb3I6dHJ1ZV0uXG5cbiAgICAgIElmIFtmaW5pc2hlZF0gaXMgc3VwcGxpZWQsIFtldmVyeSddIHdpbGwgZmlsbCBpdCBvbmNlIGFsbCBvZiB0aGUgZm9sbG93aW5nIGJlY29tZVxuICAgICAgZGV0ZXJtaW5lZDogW3N0YXJ0XSwgW3N0b3BdLCBhbmQgdGhlIG91dGNvbWUgb2YgdGhlIGZpbmFsIGNhbGwgdG8gW2ZdLiAqKVxuICB2YWwgZXZlcnknXG4gICAgOiAgP3N0YXJ0OnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbcmV0dXJuICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gP2ZpbmlzaGVkOnVuaXQgSXZhci50XG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0IERlZmVycmVkLnQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBbZXZlcnkgP3N0YXJ0ID9zdG9wIHNwYW4gZl0gaXNcbiAgICAgIFtldmVyeScgP3N0YXJ0ID9zdG9wIHNwYW4gKGZ1biAoKSAtPiBmICgpOyByZXR1cm4gKCkpXS4gKilcbiAgdmFsIGV2ZXJ5XG4gICAgOiAgP3N0YXJ0OnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbcmV0dXJuICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICAoKiogW3J1bl9hdF9pbnRlcnZhbHMnID9zdGFydCA/c3RvcCBzcGFuIGZdIHJ1bnMgW2YoKV0gYXQgaW5jcmVtZW50cyBvZiBbc3RhcnQgKyBpICpcbiAgICAgIHNwYW5dIGZvciBub25uZWdhdGl2ZSBpbnRlZ2VycyBbaV0sIHVudGlsIFtzdG9wXSBiZWNvbWVzIGRldGVybWluZWQuXG4gICAgICBJZiB0aGUgcmVzdWx0IG9mIFtmXSBpcyBub3QgZGV0ZXJtaW5lZCBmYXN0IGVub3VnaCB0aGVuIHRoZSBuZXh0IGludGVydmFsKHMpXG4gICAgICBhcmUgc2tpcHBlZCBzbyB0aGF0IHRoZXJlIGFyZSBuZXZlciBtdWx0aXBsZSBjb25jdXJyZW50IGludm9jYXRpb25zIG9mIFtmXSBpblxuICAgICAgZmxpZ2h0LlxuXG4gICAgICBFeGNlcHRpb25zIHJhaXNlZCBieSBbZl0gYXJlIGFsd2F5cyBzZW50IHRvIG1vbml0b3IgaW4gZWZmZWN0IHdoZW5cbiAgICAgIFtydW5fYXRfaW50ZXJ2YWxzJ10gd2FzIGNhbGxlZCwgZXZlbiB3aXRoIFt+Y29udGludWVfb25fZXJyb3I6dHJ1ZV0uICopXG4gIHZhbCBydW5fYXRfaW50ZXJ2YWxzJ1xuICAgIDogID9zdGFydDpUaW1lLnQgKCoqIGRlZmF1bHQgaXMgW1RpbWUubm93ICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0IERlZmVycmVkLnQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBbcnVuX2F0X2ludGVydmFscyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yIHNwYW4gZl0gaXMgZXF1aXZhbGVudCB0bzpcblxuICAgICAge1tcbiAgICAgICAgcnVuX2F0X2ludGVydmFscycgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciBzcGFuXG4gICAgICAgICAgKGZ1biAoKSAtPiBmICgpOyByZXR1cm4gKCkpIF19ICopXG4gIHZhbCBydW5fYXRfaW50ZXJ2YWxzXG4gICAgOiAgP3N0YXJ0OlRpbWUudCAoKiogZGVmYXVsdCBpcyBbVGltZS5ub3cgKCldICopXG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtEZWZlcnJlZC5uZXZlciAoKV0gKilcbiAgICAtPiA/Y29udGludWVfb25fZXJyb3I6Ym9vbCAoKiogZGVmYXVsdCBpcyBbdHJ1ZV0gKilcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+ICh1bml0IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBbZHVyYXRpb25fb2YgZl0gaW52b2tlcyBbZiAoKV0gYW5kIG1lYXN1cmVzIGhvdyBsb25nIGl0IHRha2VzIGZyb20gdGhlIGludm9jYXRpb25cbiAgICAgIHRvIGFmdGVyIHRoZSBkZWZlcnJlZCBpcyBkZXRlcm1pbmVkLlxuXG4gICAgICBOb3RlIHRoYXQgdGhlIG1lYXN1cmVtZW50IGlzIG5vdCBleGFjdDsgYmVjYXVzZSBpdCBpbnZvbHZlcyBhbiBhZGRpdGlvbmFsIG1hcCBvbiB0aGVcbiAgICAgIGRlZmVycmVkLCB0aGUgdGltaW5nIGFsc28gaW5jbHVkZXMgdGhlIGR1cmF0aW9uIG9mIGpvYnMgaW4gdGhlIGpvYiBxdWV1ZSB3aGVuIFtmICgpXVxuICAgICAgaXMgZGV0ZXJtaW5lZC4gKilcbiAgdmFsIGR1cmF0aW9uX29mIDogKHVuaXQgLT4gJ2EgRGVmZXJyZWQudCkgLT4gKCdhICogVGltZS5TcGFuLnQpIERlZmVycmVkLnRcbmVuZFxuXG4oKiogW0Nsb2NrX2RlcHJlY2F0ZWRdIGlzIHVzZWQgaW4gW1JlcXVpcmVfZXhwbGljaXRfdGltZV9zb3VyY2VdIHRvIGNyZWF0ZSBhIGNsb2NrXG4gICAgbW9kdWxlIGluIHdoaWNoIGFsbCBmdW5jdGlvbnMgYXJlIGRlcHJlY2F0ZWQuICopXG5tb2R1bGUgdHlwZSBDbG9ja19kZXByZWNhdGVkID0gc2lnXG4gIG1vZHVsZSBPcl90aW1lb3V0ID0gT3JfdGltZW91dFxuXG4gIG1vZHVsZSBUaW1lIDogc2lnXG4gICAgbW9kdWxlIFNwYW4gOiBzaWdcbiAgICAgIHR5cGUgdFxuICAgIGVuZFxuXG4gICAgdHlwZSB0XG4gIGVuZFxuXG4gIHZhbCBydW5fYXQgOiBUaW1lLnQgLT4gKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIHJ1bl9hZnRlciA6IFRpbWUuU3Bhbi50IC0+ICgnYSAtPiB1bml0KSAtPiAnYSAtPiB1bml0XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBhdCA6IFRpbWUudCAtPiB1bml0IERlZmVycmVkLnQgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBhZnRlciA6IFRpbWUuU3Bhbi50IC0+IHVuaXQgRGVmZXJyZWQudFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgd2l0aF90aW1lb3V0IDogVGltZS5TcGFuLnQgLT4gJ2EgRGVmZXJyZWQudCAtPiAnYSBPcl90aW1lb3V0LnQgRGVmZXJyZWQudFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgd2l0aF90aW1lb3V0X2V4biA6IFRpbWUuU3Bhbi50IC0+ICdhIERlZmVycmVkLnQgLT4gZXJyb3I6RXJyb3IudCAtPiAnYSBEZWZlcnJlZC50XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDIzLTExXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIG1vZHVsZSBFdmVudCA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnaCkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIHR5cGUgdF91bml0ID0gKHVuaXQsIHVuaXQpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIHZhbCBpbnZhcmlhbnQgOiAnYSBJbnZhcmlhbnQudCAtPiAnYiBJbnZhcmlhbnQudCAtPiAoJ2EsICdiKSB0IEludmFyaWFudC50XG4gICAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgc2NoZWR1bGVkX2F0IDogKF8sIF8pIHQgLT4gVGltZS50XG4gICAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICBtb2R1bGUgU3RhdHVzIDogc2lnXG4gICAgICB0eXBlICgnYSwgJ2gpIHQgPVxuICAgICAgICB8IEFib3J0ZWQgb2YgJ2FcbiAgICAgICAgfCBIYXBwZW5lZCBvZiAnaFxuICAgICAgICB8IFNjaGVkdWxlZF9hdCBvZiBUaW1lLnRcbiAgICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gICAgZW5kXG5cbiAgICB2YWwgc3RhdHVzIDogKCdhLCAnaCkgdCAtPiAoJ2EsICdoKSBTdGF0dXMudFxuICAgICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIHJ1bl9hdCA6IFRpbWUudCAtPiAoJ3ogLT4gJ2gpIC0+ICd6IC0+IChfLCAnaCkgdFxuICAgICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIHJ1bl9hZnRlciA6IFRpbWUuU3Bhbi50IC0+ICgneiAtPiAnaCkgLT4gJ3ogLT4gKF8sICdoKSB0XG4gICAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICBtb2R1bGUgQWJvcnRfcmVzdWx0ID0gVGltZV9zb3VyY2UuRXZlbnQuQWJvcnRfcmVzdWx0XG5cbiAgICB2YWwgYWJvcnQgOiAoJ2EsICdoKSB0IC0+ICdhIC0+ICgnYSwgJ2gpIEFib3J0X3Jlc3VsdC50XG4gICAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgYWJvcnRfZXhuIDogKCdhLCAnaCkgdCAtPiAnYSAtPiB1bml0XG4gICAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgYWJvcnRfaWZfcG9zc2libGUgOiAoJ2EsIF8pIHQgLT4gJ2EgLT4gdW5pdFxuICAgICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgbW9kdWxlIEZpcmVkID0gVGltZV9zb3VyY2UuRXZlbnQuRmlyZWRcblxuICAgIHZhbCBmaXJlZCA6ICgnYSwgJ2gpIHQgLT4gKCdhLCAnaCkgRmlyZWQudCBEZWZlcnJlZC50XG4gICAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICBtb2R1bGUgUmVzY2hlZHVsZV9yZXN1bHQgPSBUaW1lX3NvdXJjZS5FdmVudC5SZXNjaGVkdWxlX3Jlc3VsdFxuXG4gICAgdmFsIHJlc2NoZWR1bGVfYXQgOiAoJ2EsICdoKSB0IC0+IFRpbWUudCAtPiAoJ2EsICdoKSBSZXNjaGVkdWxlX3Jlc3VsdC50XG4gICAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgcmVzY2hlZHVsZV9hZnRlciA6ICgnYSwgJ2gpIHQgLT4gVGltZS5TcGFuLnQgLT4gKCdhLCAnaCkgUmVzY2hlZHVsZV9yZXN1bHQudFxuICAgICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIGF0IDogVGltZS50IC0+IChfLCB1bml0KSB0IFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIHZhbCBhZnRlciA6IFRpbWUuU3Bhbi50IC0+IChfLCB1bml0KSB0XG4gICAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG4gIGVuZFxuXG4gIHZhbCBhdF92YXJ5aW5nX2ludGVydmFsc1xuICAgIDogID9zdG9wOnVuaXQgRGVmZXJyZWQudFxuICAgIC0+ICh1bml0IC0+IFRpbWUuU3Bhbi50KVxuICAgIC0+IHVuaXQgQXN5bmNfc3RyZWFtLnRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIGF0X2ludGVydmFsc1xuICAgIDogID9zdGFydDpUaW1lLnRcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnRcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+IHVuaXQgQXN5bmNfc3RyZWFtLnRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIGV2ZXJ5J1xuICAgIDogID9zdGFydDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW3JldHVybiAoKV0gKilcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW0RlZmVycmVkLm5ldmVyICgpXSAqKVxuICAgIC0+ID9jb250aW51ZV9vbl9lcnJvcjpib29sICgqKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICAgIC0+ID9maW5pc2hlZDp1bml0IEl2YXIudFxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gKHVuaXQgLT4gdW5pdCBEZWZlcnJlZC50KVxuICAgIC0+IHVuaXRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIGV2ZXJ5XG4gICAgOiAgP3N0YXJ0OnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbcmV0dXJuICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0KVxuICAgIC0+IHVuaXRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIHJ1bl9hdF9pbnRlcnZhbHMnXG4gICAgOiAgP3N0YXJ0OlRpbWUudCAoKiogZGVmYXVsdCBpcyBbVGltZS5ub3cgKCldICopXG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtEZWZlcnJlZC5uZXZlciAoKV0gKilcbiAgICAtPiA/Y29udGludWVfb25fZXJyb3I6Ym9vbCAoKiogZGVmYXVsdCBpcyBbdHJ1ZV0gKilcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+ICh1bml0IC0+IHVuaXQgRGVmZXJyZWQudClcbiAgICAtPiB1bml0XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBydW5fYXRfaW50ZXJ2YWxzXG4gICAgOiAgP3N0YXJ0OlRpbWUudCAoKiogZGVmYXVsdCBpcyBbVGltZS5ub3cgKCldICopXG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtEZWZlcnJlZC5uZXZlciAoKV0gKilcbiAgICAtPiA/Y29udGludWVfb25fZXJyb3I6Ym9vbCAoKiogZGVmYXVsdCBpcyBbdHJ1ZV0gKilcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+ICh1bml0IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgZHVyYXRpb25fb2YgOiAodW5pdCAtPiAnYSBEZWZlcnJlZC50KSAtPiAoJ2EgKiBUaW1lLlNwYW4udCkgRGVmZXJyZWQudFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cbmVuZFxuXG4oKiogQGlubGluZSAqKVxuaW5jbHVkZSAoXG4gIHN0cnVjdFxuICAgIFtAQEB3YXJuaW5nIFwiLTNcIl1cblxuICAgIG1vZHVsZSBfIChDIDogQ2xvY2spIDogQ2xvY2tfZGVwcmVjYXRlZCA9IENcbiAgICBtb2R1bGUgXyAoQyA6IENsb2NrX2RlcHJlY2F0ZWQpIDogQ2xvY2sgPSBDXG4gIGVuZCA6XG4gICAgc2lnIGVuZClcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgdHlwZSBDbG9jayA9IENsb2NrX2ludGYuQ2xvY2tcbm1vZHVsZSB0eXBlIENsb2NrX2RlcHJlY2F0ZWQgPSBDbG9ja19pbnRmLkNsb2NrX2RlcHJlY2F0ZWRcblxubW9kdWxlIE9yX3RpbWVvdXQgPSBDbG9ja19pbnRmLk9yX3RpbWVvdXRcbm1vZHVsZSBTY2hlZHVsZXIgPSBTY2hlZHVsZXIxXG5cbmxldCB0aW1lX3NvdXJjZSAoKSA9IChTY2hlZHVsZXIudCAoKSkudGltZV9zb3VyY2UgfD4gVGltZV9zb3VyY2Uub2Zfc3luY2hyb25vdXNcbmxldCBhZnRlciBzcGFuID0gVGltZV9zb3VyY2UuYWZ0ZXIgKHRpbWVfc291cmNlICgpKSBzcGFuXG5sZXQgYXQgdGltZSA9IFRpbWVfc291cmNlLmF0ICh0aW1lX3NvdXJjZSAoKSkgdGltZVxuXG5sZXQgYXRfdmFyeWluZ19pbnRlcnZhbHMgP3N0b3AgY29tcHV0ZV9zcGFuID1cbiAgVGltZV9zb3VyY2UuYXRfdmFyeWluZ19pbnRlcnZhbHMgP3N0b3AgKHRpbWVfc291cmNlICgpKSBjb21wdXRlX3NwYW5cbjs7XG5cbmxldCBhdF9pbnRlcnZhbHMgP3N0YXJ0ID9zdG9wIGludGVydmFsID1cbiAgVGltZV9zb3VyY2UuYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCAodGltZV9zb3VyY2UgKCkpIGludGVydmFsXG47O1xuXG5sZXQgZXZlcnknID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgP2ZpbmlzaGVkIHNwYW4gZiA9XG4gIFRpbWVfc291cmNlLmV2ZXJ5JyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yID9maW5pc2hlZCAodGltZV9zb3VyY2UgKCkpIHNwYW4gZlxuOztcblxubGV0IGV2ZXJ5ID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3Igc3BhbiBmID1cbiAgVGltZV9zb3VyY2UuZXZlcnkgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciAodGltZV9zb3VyY2UgKCkpIHNwYW4gZlxuOztcblxubGV0IHJ1bl9hZnRlciBzcGFuIGYgYSA9IFRpbWVfc291cmNlLnJ1bl9hZnRlciAodGltZV9zb3VyY2UgKCkpIHNwYW4gZiBhXG5sZXQgcnVuX2F0IHRpbWUgZiBhID0gVGltZV9zb3VyY2UucnVuX2F0ICh0aW1lX3NvdXJjZSAoKSkgdGltZSBmIGFcblxubGV0IHJ1bl9hdF9pbnRlcnZhbHMgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciBpbnRlcnZhbCBmID1cbiAgVGltZV9zb3VyY2UucnVuX2F0X2ludGVydmFscyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yICh0aW1lX3NvdXJjZSAoKSkgaW50ZXJ2YWwgZlxuOztcblxubGV0IHJ1bl9hdF9pbnRlcnZhbHMnID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgaW50ZXJ2YWwgZiA9XG4gIFRpbWVfc291cmNlLnJ1bl9hdF9pbnRlcnZhbHMnXG4gICAgP3N0YXJ0XG4gICAgP3N0b3BcbiAgICA/Y29udGludWVfb25fZXJyb3JcbiAgICAodGltZV9zb3VyY2UgKCkpXG4gICAgaW50ZXJ2YWxcbiAgICBmXG47O1xuXG5sZXQgd2l0aF90aW1lb3V0IHNwYW4gZCA9IFRpbWVfc291cmNlLndpdGhfdGltZW91dCAodGltZV9zb3VyY2UgKCkpIHNwYW4gZFxuXG5sZXQgd2l0aF90aW1lb3V0X2V4biBzcGFuIGQgfmVycm9yID1cbiAgVGltZV9zb3VyY2Uud2l0aF90aW1lb3V0X2V4biAodGltZV9zb3VyY2UgKCkpIHNwYW4gZCB+ZXJyb3Jcbjs7XG5cbmxldCBkdXJhdGlvbl9vZiBmID0gVGltZV9zb3VyY2UuZHVyYXRpb25fb2YgKHRpbWVfc291cmNlICgpKSBmXG5cbm1vZHVsZSBFdmVudCA9IHN0cnVjdFxuICBpbmNsdWRlIFRpbWVfc291cmNlLkV2ZW50XG5cbiAgbGV0IGFmdGVyIHNwYW4gPSBhZnRlciAodGltZV9zb3VyY2UgKCkpIHNwYW5cbiAgbGV0IHJ1bl9hZnRlciBzcGFuIGYgYSA9IHJ1bl9hZnRlciAodGltZV9zb3VyY2UgKCkpIHNwYW4gZiBhXG4gIGxldCBhdCB0aW1lID0gYXQgKHRpbWVfc291cmNlICgpKSB0aW1lXG4gIGxldCBydW5fYXQgdGltZSBmIHogPSBydW5fYXQgKHRpbWVfc291cmNlICgpKSB0aW1lIGYgelxuZW5kXG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgaSBiID1cbiAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdFxuICAgICAgdGhlbiBJdmFyLmZpbGxfZXhuIHJlc3VsdCBiXG4gICAgICBlbHNlIGYgaSBiIHQuKGkpID4+PiBmdW4gYiAtPiBsb29wIChpICsgMSkgYlxuICAgIGluXG4gICAgbG9vcCAwIGluaXQpXG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH5mID0gZm9sZGkgdCB+aW5pdCB+ZjooZnVuIF8gYSB4IC0+IGYgYSB4KVxuXG5sZXQgc2VxbWFwaSB0IH5mID1cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgbGV0IHJlYyBsb29wIGkgb3V0cHV0ID1cbiAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdFxuICAgICAgdGhlbiBJdmFyLmZpbGxfZXhuIHJlc3VsdCBvdXRwdXRcbiAgICAgIGVsc2VcbiAgICAgICAgZiBpIChBcnJheS5nZXQgdCBpKVxuICAgICAgICA+Pj4gZnVuIGIgLT5cbiAgICAgICAgbGV0IG91dHB1dCA9IGlmIGkgPSAwIHRoZW4gQXJyYXkuY3JlYXRlIH5sZW46KEFycmF5Lmxlbmd0aCB0KSBiIGVsc2Ugb3V0cHV0IGluXG4gICAgICAgIEFycmF5LnNldCBvdXRwdXQgaSBiO1xuICAgICAgICBsb29wIChpICsgMSkgb3V0cHV0XG4gICAgaW5cbiAgICBsb29wIDAgW3x8XSlcbjs7XG5cbmxldCBhbGwgZHMgPSBzZXFtYXBpIGRzIH5mOihmdW4gXyB4IC0+IHgpXG5sZXQgYWxsX3VuaXQgZHMgPSBEZWZlcnJlZC5pZ25vcmVfbSAoZm9sZCBkcyB+aW5pdDooKSB+ZjooZnVuICgpIGQgLT4gZCkpXG5cbmxldCBpdGVyaSB+aG93IHQgfmYgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IChgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICBhbGxfdW5pdCAoQXJyYXkubWFwaSB0IH5mOih1bnN0YWdlIChUaHJvdHRsZS5tb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYpKSlcbiAgfCBgU2VxdWVudGlhbCAtPiBmb2xkaSB0IH5pbml0OigpIH5mOihmdW4gaSAoKSB4IC0+IGYgaSB4KVxuOztcblxubGV0IG1hcGkgfmhvdyB0IH5mID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCAoYFBhcmFsbGVsIHwgYE1heF9jb25jdXJyZW50X2pvYnMgXykgYXMgaG93IC0+XG4gICAgYWxsIChBcnJheS5tYXBpIHQgfmY6KHVuc3RhZ2UgKFRocm90dGxlLm1vbmFkX3NlcXVlbmNlX2hvdzIgfmhvdyB+ZikpKVxuICB8IGBTZXF1ZW50aWFsIC0+IHNlcW1hcGkgdCB+ZlxuOztcblxubGV0IGZpbHRlcmkgfmhvdyB0IH5mID1cbiAgbGV0JW1hcCBib29scyA9IG1hcGkgdCB+aG93IH5mIGluXG4gIEFycmF5Lm9mX2xpc3RfcmV2XG4gICAgKEFycmF5LmZvbGQyX2V4biB0IGJvb2xzIH5pbml0OltdIH5mOihmdW4gYWMgeCBiIC0+IGlmIGIgdGhlbiB4IDo6IGFjIGVsc2UgYWMpKVxuOztcblxubGV0IGZpbHRlcl9tYXBpIH5ob3cgdCB+ZiA9IG1hcGkgdCB+aG93IH5mID4+fCBBcnJheS5maWx0ZXJfb3B0XG5cbmxldCBjb25jYXRfbWFwaSB+aG93IHQgfmYgPVxuICBsZXQlbWFwIHQgPSBtYXBpIHQgfmhvdyB+ZiBpblxuICBBcnJheS5jb25jYXQgKEFycmF5LnRvX2xpc3QgdClcbjs7XG5cbmxldCBmaW5kX21hcGkgdCB+ZiA9XG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdFxuICAgIHRoZW4gcmV0dXJuIE5vbmVcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoJWJpbmQgZiBpIHQuKGkpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBhdXggKGkgKyAxKVxuICAgICAgfCBTb21lIF8gYXMgc29tZSAtPiByZXR1cm4gc29tZSlcbiAgaW5cbiAgYXV4IDBcbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICBpZiBiIHRoZW4gU29tZSAoaSwgZWx0KSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgZmluZF9tYXBpIHQgfmY6KGZ1biBfIGVsdCAtPlxuICAgIGxldCVtYXAgYiA9IGYgZWx0IGluXG4gICAgaWYgYiB0aGVuIFNvbWUgZWx0IGVsc2UgTm9uZSlcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBtYXRjaCVtYXBcbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gIHdpdGhcbiAgfCBTb21lICgpIC0+IHRydWVcbiAgfCBOb25lIC0+IGZhbHNlXG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIG1hdGNoJW1hcFxuICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgIGlmIG5vdCBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gIHdpdGhcbiAgfCBTb21lICgpIC0+IGZhbHNlXG4gIHwgTm9uZSAtPiB0cnVlXG47O1xuXG5sZXQgaXRlciB+aG93IHQgfmYgPSBpdGVyaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IG1hcCB+aG93IHQgfmYgPSBtYXBpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZmlsdGVyX21hcCB+aG93IHQgfmYgPSBmaWx0ZXJfbWFwaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbHRlciB+aG93IHQgfmYgPSBmaWx0ZXJpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgY29uY2F0X21hcCB+aG93IHQgfmYgPSBjb25jYXRfbWFwaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZXhpc3RzIHQgfmYgPSBleGlzdHNpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZvcl9hbGwgdCB+ZiA9IGZvcl9hbGxpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGluaXQgfmhvdyBuIH5mID0gbWFwIH5ob3cgKEFycmF5LmluaXQgbiB+ZjpGbi5pZCkgfmZcbiIsIm9wZW4gQ29yZVxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgIGxldCByZWMgbG9vcCB0IGkgYiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgW10gLT4gSXZhci5maWxsX2V4biByZXN1bHQgYlxuICAgICAgfCB4IDo6IHhzIC0+IGYgaSBiIHggPj4+IGZ1biBiIC0+IGxvb3AgeHMgKGkgKyAxKSBiXG4gICAgaW5cbiAgICBsb29wIHQgMCBpbml0KVxuOztcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9IGZvbGRpIHQgfmluaXQgfmY6KGZ1biBfIGEgeCAtPiBmIGEgeClcblxubGV0IHNlcW1hcGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6W10gfmY6KGZ1biBpIGJzIGEgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGkgYSBpblxuICAgIGIgOjogYnMpXG4gID4+fCBMaXN0LnJldlxuOztcblxubGV0IGFsbCBkcyA9IHNlcW1hcGkgZHMgfmY6KGZ1biBfIHggLT4geClcbmxldCBhbGxfdW5pdCBkcyA9IERlZmVycmVkLmlnbm9yZV9tIChmb2xkIGRzIH5pbml0OigpIH5mOihmdW4gKCkgZCAtPiBkKSlcblxubGV0IGl0ZXJpIH5ob3cgdCB+ZiA9XG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgYFBhcmFsbGVsIGFzIGhvdyAtPlxuICAgIGFsbF91bml0IChMaXN0Lm1hcGkgdCB+ZjoodW5zdGFnZSAoVGhyb3R0bGUubW9uYWRfc2VxdWVuY2VfaG93MiB+aG93IH5mKSkpXG4gIHwgYE1heF9jb25jdXJyZW50X2pvYnMgam9iX2NvdW50IC0+XG4gICAgbGV0IHJlYyBnZW5fY29tcHV0YXRpb24gaWR4ID0gZnVuY3Rpb25cbiAgICAgIHwgeCA6OiB4cyAtPlxuICAgICAgICBUaHJvdHRsZWQub2ZfdGh1bmsgKGZ1biAoKSAtPlxuICAgICAgICAgIFRocm90dGxlZC5ib3RoX3VuaXRcbiAgICAgICAgICAgIChUaHJvdHRsZWQuam9iIChmdW4gKCkgLT4gZiBpZHggeCkpXG4gICAgICAgICAgICAoZ2VuX2NvbXB1dGF0aW9uIChpZHggKyAxKSB4cykpXG4gICAgICB8IFtdIC0+IFRocm90dGxlZC5yZXR1cm4gKClcbiAgICBpblxuICAgIFRocm90dGxlZC5ydW4gKGdlbl9jb21wdXRhdGlvbiAwIHQpIH5tYXhfY29uY3VycmVudF9qb2JzOmpvYl9jb3VudFxuICB8IGBTZXF1ZW50aWFsIC0+IGZvbGRpIHQgfmluaXQ6KCkgfmY6KGZ1biBpICgpIHggLT4gZiBpIHgpXG47O1xuXG5sZXQgbWFwaSB+aG93IHQgfmYgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IGBQYXJhbGxlbCBhcyBob3cgLT5cbiAgICBhbGwgKExpc3QubWFwaSB0IH5mOih1bnN0YWdlIChUaHJvdHRsZS5tb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYpKSlcbiAgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBqb2JfY291bnQgLT5cbiAgICBsZXQgcmVjIGdlbl9jb21wdXRhdGlvbiBpZHggPSBmdW5jdGlvblxuICAgICAgfCB4IDo6IHhzIC0+XG4gICAgICAgIFRocm90dGxlZC5vZl90aHVuayAoZnVuICgpIC0+XG4gICAgICAgICAgVGhyb3R0bGVkLm1hcDJcbiAgICAgICAgICAgIChUaHJvdHRsZWQuam9iIChmdW4gKCkgLT4gZiBpZHggeCkpXG4gICAgICAgICAgICAoZ2VuX2NvbXB1dGF0aW9uIChpZHggKyAxKSB4cylcbiAgICAgICAgICAgIH5mOihmdW4geSB5cyAtPiB5IDo6IHlzKSlcbiAgICAgIHwgW10gLT4gVGhyb3R0bGVkLnJldHVybiBbXVxuICAgIGluXG4gICAgVGhyb3R0bGVkLnJ1biAoZ2VuX2NvbXB1dGF0aW9uIDAgdCkgfm1heF9jb25jdXJyZW50X2pvYnM6am9iX2NvdW50XG4gIHwgYFNlcXVlbnRpYWwgLT4gc2VxbWFwaSB0IH5mXG47O1xuXG5sZXQgZmlsdGVyaSB+aG93IHQgfmYgPVxuICBsZXQlbWFwIGJvb2xzID0gbWFwaSB0IH5ob3cgfmYgaW5cbiAgTGlzdC5yZXYgKExpc3QuZm9sZDJfZXhuIHQgYm9vbHMgfmluaXQ6W10gfmY6KGZ1biBhYyB4IGIgLT4gaWYgYiB0aGVuIHggOjogYWMgZWxzZSBhYykpXG47O1xuXG5sZXQgZmlsdGVyX21hcGkgfmhvdyB0IH5mID0gbWFwaSB0IH5ob3cgfmYgPj58IExpc3QuZmlsdGVyX29wdFxubGV0IGNvbmNhdF9tYXBpIH5ob3cgdCB+ZiA9IG1hcGkgdCB+aG93IH5mID4+fCBMaXN0LmNvbmNhdFxuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGZpbmRfbWFwaSB0IH5mIGkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gcmV0dXJuIE5vbmVcbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAobWF0Y2glYmluZCBmIGkgaGQgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcGkgdGwgfmYgKGkgKyAxKVxuICAgICAgIHwgU29tZSBfIGFzIHNvbWUgLT4gcmV0dXJuIHNvbWUpXG4gIGluXG4gIGZpbmRfbWFwaSB0IH5mIDBcbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICBpZiBiIHRoZW4gU29tZSAoaSwgZWx0KSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgZmluZF9tYXBpIHQgfmY6KGZ1biBfIGVsdCAtPlxuICAgIGxldCVtYXAgYiA9IGYgZWx0IGluXG4gICAgaWYgYiB0aGVuIFNvbWUgZWx0IGVsc2UgTm9uZSlcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBtYXRjaCVtYXBcbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gIHdpdGhcbiAgfCBTb21lICgpIC0+IHRydWVcbiAgfCBOb25lIC0+IGZhbHNlXG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIG1hdGNoJW1hcFxuICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgIGlmIG5vdCBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gIHdpdGhcbiAgfCBTb21lICgpIC0+IGZhbHNlXG4gIHwgTm9uZSAtPiB0cnVlXG47O1xuXG5sZXQgaXRlciB+aG93IHQgfmYgPSBpdGVyaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IG1hcCB+aG93IHQgfmYgPSBtYXBpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZmlsdGVyIH5ob3cgdCB+ZiA9IGZpbHRlcmkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaWx0ZXJfbWFwIH5ob3cgdCB+ZiA9IGZpbHRlcl9tYXBpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgY29uY2F0X21hcCB+aG93IHQgfmYgPSBjb25jYXRfbWFwaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZXhpc3RzIHQgfmYgPSBleGlzdHNpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZvcl9hbGwgdCB+ZiA9IGZvcl9hbGxpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGluaXQgfmhvdyBuIH5mID0gbWFwIH5ob3cgKExpc3QuaW5pdCBuIH5mOkZuLmlkKSB+ZlxuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5tb2R1bGUgTGlzdCA9IERlZmVycmVkX2xpc3Rcbm1vZHVsZSBUaHJvdHRsZWRfbWFwID0gTWFwLk1ha2VfYXBwbGljYXRpdmVfdHJhdmVyc2FscyAoVGhyb3R0bGVkKVxuXG50eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE1hcC50XG5cbmxldCBjaGFuZ2UgdCBrIH5mID1cbiAgbGV0JW1hcCBvcHQgPSBmIChNYXAuZmluZCB0IGspIGluXG4gIE1hcC5jaGFuZ2UgdCBrIH5mOihmdW4gXyAtPiBvcHQpXG47O1xuXG5sZXQgdXBkYXRlIHQgayB+ZiA9XG4gIGxldCVtYXAgZGF0YSA9IGYgKE1hcC5maW5kIHQgaykgaW5cbiAgTWFwLnNldCB0IH5rZXk6ayB+ZGF0YVxuOztcblxubGV0IGl0ZXJfa2V5cyB+aG93IHQgfmYgPSBMaXN0Lml0ZXIgfmhvdyAoTWFwLmtleXMgdCkgfmZcbmxldCBpdGVyIH5ob3cgdCB+ZiA9IExpc3QuaXRlciB+aG93IChNYXAuZGF0YSB0KSB+ZlxubGV0IGl0ZXJpIH5ob3cgdCB+ZiA9IExpc3QuaXRlciB+aG93IChNYXAudG9fYWxpc3QgdCkgfmY6KGZ1biAoa2V5LCBkYXRhKSAtPiBmIH5rZXkgfmRhdGEpXG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgYWxpc3RfaW5faW5jcmVhc2luZ19rZXlfb3JkZXIgPVxuICAgIE1hcC5mb2xkX3JpZ2h0IHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIGFsaXN0IC0+IChrZXksIGRhdGEpIDo6IGFsaXN0KVxuICBpblxuICBMaXN0LmZvbGQgYWxpc3RfaW5faW5jcmVhc2luZ19rZXlfb3JkZXIgfmluaXQgfmY6KGZ1biBhYyAoa2V5LCBkYXRhKSAtPiBmIH5rZXkgfmRhdGEgYWMpXG47O1xuXG5sZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID1cbiAgbGV0IGFsaXN0X2luX2RlY3JlYXNpbmdfa2V5X29yZGVyID1cbiAgICBNYXAuZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSBhbGlzdCAtPiAoa2V5LCBkYXRhKSA6OiBhbGlzdClcbiAgaW5cbiAgTGlzdC5mb2xkIGFsaXN0X2luX2RlY3JlYXNpbmdfa2V5X29yZGVyIH5pbml0IH5mOihmdW4gYWMgKGtleSwgZGF0YSkgLT4gZiB+a2V5IH5kYXRhIGFjKVxuOztcblxubW9kdWxlIEpvYiA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID1cbiAgICB7IGtleSA6ICdhXG4gICAgOyBkYXRhIDogJ2JcbiAgICA7IG11dGFibGUgcmVzdWx0IDogJ2Mgb3B0aW9uXG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMgfmdldHRlcnNdXG5lbmRcblxubGV0IGZpbHRlcl9tYXBpX3NlcXVlbnRpYWwgdCB+ZiA9XG4gIGxldCBjb21wYXJhdG9yID0gTWFwLmNvbXBhcmF0b3IgdCBpblxuICBsZXQgc2VxdWVuY2UgPSBNYXAudG9fc2VxdWVuY2Ugfm9yZGVyOmBJbmNyZWFzaW5nX2tleSB0IGluXG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIGl2YXIgLT5cbiAgICBTZXF1ZW5jZS5kZWxheWVkX2ZvbGRcbiAgICAgIHNlcXVlbmNlXG4gICAgICB+aW5pdDpCYXNlLk1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUuQnVpbGRfaW5jcmVhc2luZy5lbXB0eVxuICAgICAgfmY6KGZ1biBzIChrZXksIGRhdGEpIH5rIC0+XG4gICAgICAgIHVwb24gKGYgfmtleSB+ZGF0YSkgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IGsgc1xuICAgICAgICAgIHwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgICAgIEJhc2UuTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5CdWlsZF9pbmNyZWFzaW5nLmFkZF9leG5cbiAgICAgICAgICAgICAgICBzXG4gICAgICAgICAgICAgICAgfmNvbXBhcmF0b3JcbiAgICAgICAgICAgICAgICB+a2V5XG4gICAgICAgICAgICAgICAgfmRhdGFcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBrIHMpKVxuICAgICAgfmZpbmlzaDooZnVuIHggLT5cbiAgICAgICAgSXZhci5maWxsX2V4blxuICAgICAgICAgIGl2YXJcbiAgICAgICAgICAoTWFwLlVzaW5nX2NvbXBhcmF0b3Iub2ZfdHJlZVxuICAgICAgICAgICAgIH5jb21wYXJhdG9yXG4gICAgICAgICAgICAgKEJhc2UuTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5CdWlsZF9pbmNyZWFzaW5nLnRvX3RyZWUgeCkpKSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaV9tYXhfY29uY3VycmVudCB0IH5mIH5tYXhfY29uY3VycmVudF9qb2JzID1cbiAgbGV0IGNvbXB1dGF0aW9uID1cbiAgICBUaHJvdHRsZWRfbWFwLmZpbHRlcl9tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICBUaHJvdHRsZWQuam9iIChmdW4gKCkgLT4gZiB+a2V5IH5kYXRhKSlcbiAgaW5cbiAgVGhyb3R0bGVkLnJ1biBjb21wdXRhdGlvbiB+bWF4X2NvbmN1cnJlbnRfam9ic1xuOztcblxubGV0IGZpbHRlcl9tYXBpIH5ob3cgdCB+ZiA9XG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgYFNlcXVlbnRpYWwgLT4gZmlsdGVyX21hcGlfc2VxdWVudGlhbCB0IH5mXG4gIHwgYE1heF9jb25jdXJyZW50X2pvYnMgbWF4X2NvbmN1cnJlbnRfam9icyAtPlxuICAgIGZpbHRlcl9tYXBpX21heF9jb25jdXJyZW50IHQgfmYgfm1heF9jb25jdXJyZW50X2pvYnNcbiAgfCBgUGFyYWxsZWwgLT5cbiAgICBsZXQgam9icyA9IHJlZiBbXSBpblxuICAgIGxldCBqb2JfbWFwID1cbiAgICAgIE1hcC5tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgIGxldCBqb2IgPSB7IEpvYi5rZXk7IGRhdGE7IHJlc3VsdCA9IE5vbmUgfSBpblxuICAgICAgICBqb2JzIDo9IGpvYiA6OiAham9icztcbiAgICAgICAgam9iKVxuICAgIGluXG4gICAgbGV0JW1hcCAoKSA9XG4gICAgICBMaXN0Lml0ZXIgfmhvdyAoQmFzZS5MaXN0LnJldiAham9icykgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgeyBKb2Iua2V5OyBkYXRhOyByZXN1bHQgPSBfIH0gYXMgam9iIC0+XG4gICAgICAgIGxldCVtYXAgeCA9IGYgfmtleSB+ZGF0YSBpblxuICAgICAgICBqb2IucmVzdWx0IDwtIHgpXG4gICAgaW5cbiAgICBNYXAuZmlsdGVyX21hcCBqb2JfbWFwIH5mOkpvYi5yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIH5ob3cgdCB+ZiA9IGZpbHRlcl9tYXBpIH5ob3cgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBmaWx0ZXJfa2V5cyB+aG93IHQgfmYgPVxuICBmaWx0ZXJfbWFwaSB+aG93IHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbGV0JW1hcCBiID0gZiBrZXkgaW5cbiAgICBpZiBiIHRoZW4gU29tZSBkYXRhIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBmaWx0ZXIgfmhvdyB0IH5mID1cbiAgZmlsdGVyX21hcGkgfmhvdyB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+XG4gICAgbGV0JW1hcCBiID0gZiBkYXRhIGluXG4gICAgaWYgYiB0aGVuIFNvbWUgZGF0YSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZmlsdGVyaSB+aG93IHQgfmYgPVxuICBmaWx0ZXJfbWFwaSB+aG93IHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbGV0JW1hcCBiID0gZiB+a2V5IH5kYXRhIGluXG4gICAgaWYgYiB0aGVuIFNvbWUgZGF0YSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgbWFwaV9tYXhfY29uY3VycmVudCB0IH5mIH5tYXhfY29uY3VycmVudF9qb2JzID1cbiAgbGV0IGNvbXB1dGF0aW9uID1cbiAgICBUaHJvdHRsZWRfbWFwLm1hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gVGhyb3R0bGVkLmpvYiAoZnVuICgpIC0+IGYgfmtleSB+ZGF0YSkpXG4gIGluXG4gIFRocm90dGxlZC5ydW4gY29tcHV0YXRpb24gfm1heF9jb25jdXJyZW50X2pvYnNcbjs7XG5cbmxldCBtYXBpIH5ob3cgdCB+ZiA9XG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgYFNlcXVlbnRpYWwgfCBgUGFyYWxsZWwgLT5cbiAgICBmaWx0ZXJfbWFwaSB+aG93IHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICBsZXQlbWFwIHogPSBmIH5rZXkgfmRhdGEgaW5cbiAgICAgIFNvbWUgeilcbiAgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBtYXhfY29uY3VycmVudF9qb2JzIC0+XG4gICAgbWFwaV9tYXhfY29uY3VycmVudCB0IH5mIH5tYXhfY29uY3VycmVudF9qb2JzXG47O1xuXG5sZXQgbWFwIH5ob3cgdCB+ZiA9IG1hcGkgfmhvdyB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxubGV0IG1lcmdlIH5ob3cgdDEgdDIgfmYgPVxuICBmaWx0ZXJfbWFwXG4gICAgfmhvd1xuICAgIChNYXAubWVyZ2UgdDEgdDIgfmY6KGZ1biB+a2V5IHogLT4gU29tZSAoZnVuICgpIC0+IGYgfmtleSB6KSkpXG4gICAgfmY6KGZ1biB0aHVuayAtPiB0aHVuayAoKSlcbjs7XG5cbmxldCBhbGwgdCA9IG1hcCB0IH5mOkZuLmlkIH5ob3c6YFNlcXVlbnRpYWxcbiIsIm9wZW4hIENvcmVcbm9wZW4hIERlZmVycmVkX3N0ZFxuaW5jbHVkZSBEZWZlcnJlZF9tZW1vX2ludGZcblxubW9kdWxlIE1ha2UgKE0gOiBNb25hZC5JbmZpeCB3aXRoIHR5cGUgJ2EgdCA9ICdhIERlZmVycmVkMS50KSA6XG4gIFMgd2l0aCB0eXBlICdhIGRlZmVycmVkIDo9ICdhIE0udCA9IHN0cnVjdFxuICBvcGVuISBNXG5cbiAgbGV0IHJlcmFpc2UgPSBmdW5jdGlvblxuICAgIHwgT2sgeCAtPiB4XG4gICAgfCBFcnJvciBleG4gLT4gRXhuLnJlcmFpc2UgZXhuIFwiY2F1Z2h0IGV4Y2VwdGlvbiBpbiBtZW1vaXplZCBmdW5jdGlvblwiXG4gIDs7XG5cbiAgbGV0IGdlbmVyYWwnICh0eXBlIGEpIH5ydW4gKGhhc2hhYmxlIDogKG1vZHVsZSBIYXNoYWJsZS5TX3BsYWluIHdpdGggdHlwZSB0ID0gYSkpIGYgPVxuICAgIGxldCBtb2R1bGUgSGFzaGFibGUgPSAodmFsIGhhc2hhYmxlKSBpblxuICAgIGxldCBmID1cbiAgICAgIE1lbW8uZ2VuZXJhbCB+aGFzaGFibGU6SGFzaGFibGUuaGFzaGFibGUgKGZ1biBhIC0+XG4gICAgICAgIE1vbml0b3IudHJ5X3dpdGggfnJlc3Q6YExvZyB+cnVuIChmdW4gKCkgLT4gZiBhKSlcbiAgICBpblxuICAgIFN0YWdlZC5zdGFnZSAoZnVuIGEgLT4gZiBhID4+fCByZXJhaXNlKVxuICA7O1xuXG4gIGxldCBnZW5lcmFsIGhhc2hhYmxlIGYgPSBnZW5lcmFsJyB+cnVuOmBOb3cgaGFzaGFibGUgZlxuXG4gIGxldCByZWN1cnNpdmUgKHR5cGUgYSkgKGhhc2hhYmxlIDogKG1vZHVsZSBIYXNoYWJsZS5TX3BsYWluIHdpdGggdHlwZSB0ID0gYSkpIGZfb25lc3RlcCA9XG4gICAgbGV0IHJlYyBtZW1vaXplZCA9XG4gICAgICBsYXp5XG4gICAgICAgIChnZW5lcmFsJ1xuICAgICAgICAgICB+cnVuOmBTY2hlZHVsZVxuICAgICAgICAgICBoYXNoYWJsZVxuICAgICAgICAgICAoZl9vbmVzdGVwIChmdW4geCAtPiAodW5zdGFnZSAoZm9yY2UgbWVtb2l6ZWQpKSB4KSkpXG4gICAgaW5cbiAgICBmb3JjZSBtZW1vaXplZFxuICA7O1xuXG4gIGxldCB1bml0IGYgPVxuICAgIGxldCBmID0gTWVtby51bml0IChmdW4gKCkgLT4gTW9uaXRvci50cnlfd2l0aCB+cmVzdDpgTG9nIH5ydW46YE5vdyBmKSBpblxuICAgIFN0YWdlZC5zdGFnZSAoZnVuICgpIC0+IGYgKCkgPj58IHJlcmFpc2UpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBNYWtlIChEZWZlcnJlZDEpXG4iLCJvcGVuIENvcmVcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBPcHRpb24udCBEZWZlcnJlZC50XG5lbmRcblxuaW5jbHVkZSBUXG5cbmluY2x1ZGUgTW9uYWQuTWFrZSAoc3RydWN0XG4gIGluY2x1ZGUgVFxuXG4gIGxldCByZXR1cm4gYSA9IERlZmVycmVkLnJldHVybiAoU29tZSBhKVxuXG4gIGxldCBiaW5kIHQgfmYgPVxuICAgIERlZmVycmVkLmJpbmQgdCB+ZjooZnVuY3Rpb25cbiAgICAgIHwgU29tZSBhIC0+IGYgYVxuICAgICAgfCBOb25lIC0+IERlZmVycmVkLnJldHVybiBOb25lKVxuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiA9IERlZmVycmVkLm1hcCB0IH5mOihmdW4gciAtPiBPcHRpb24ubWFwIHIgfmYpXG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuZW5kKVxuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnZXJyb3IpIHQgPSAoJ2EsICdlcnJvcikgUmVzdWx0LnQgRGVmZXJyZWQudFxuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgY29tYmluZSB0MSB0MiB+b2sgfmVyciA9XG4gIGxldCVtYXAgdDEgPSB0MVxuICBhbmQgdDIgPSB0MiBpblxuICBSZXN1bHQuY29tYmluZSB0MSB0MiB+b2sgfmVyclxuOztcblxuaW5jbHVkZSBNb25hZC5NYWtlMiAoc3RydWN0XG4gIGluY2x1ZGUgVFxuXG4gIGxldCByZXR1cm4gYSA9IERlZmVycmVkLnJldHVybiAoT2sgYSlcblxuICBsZXQgYmluZCB0IH5mID1cbiAgICBEZWZlcnJlZC5iaW5kIHQgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE9rIGEgLT4gZiBhXG4gICAgICB8IEVycm9yIF8gYXMgZXJyb3IgLT4gRGVmZXJyZWQucmV0dXJuIGVycm9yKVxuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiA9IERlZmVycmVkLm1hcCB0IH5mOihmdW4gciAtPiBSZXN1bHQubWFwIHIgfmYpXG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuZW5kKVxuXG5sZXQgZmFpbCB4ID0gRGVmZXJyZWQucmV0dXJuIChFcnJvciB4KVxubGV0IGZhaWxmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBmYWlsIGZvcm1hdFxubGV0IG1hcF9lcnJvciB0IH5mID0gRGVmZXJyZWQubWFwIHQgfmY6KGZ1biByIC0+IFJlc3VsdC5tYXBfZXJyb3IgciB+ZilcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbm1vZHVsZSBNb25pdG9yID0gc3RydWN0XG4gIGxldCB0cnlfd2l0aCA9IE1vbml0b3IudHJ5X3dpdGhcbmVuZFxuXG4oKiBDb3BpZWQgdG8gW2VhZ2VyX2RlZmVycmVkX29yX2Vycm9yLm1sXS4gIFRoZXJlIHNob3VsZCBiZSBubyBkaWZmcyBiZWxvdyB0aGlzIGxpbmUuICopXG5cbmluY2x1ZGUgKERlZmVycmVkX3Jlc3VsdCA6IE1vbmFkLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIERlZmVycmVkX3Jlc3VsdC50KVxuXG50eXBlICdhIHQgPSAnYSBPcl9lcnJvci50IERlZmVycmVkLnRcblxuaW5jbHVkZSBBcHBsaWNhdGl2ZS5NYWtlIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgcmV0dXJuID0gcmV0dXJuXG5cbiAgbGV0IGFwcGx5IGYgeCA9XG4gICAgRGVmZXJyZWRfcmVzdWx0LmNvbWJpbmVcbiAgICAgIGZcbiAgICAgIHhcbiAgICAgIH5vazooZnVuIGYgeCAtPiBmIHgpXG4gICAgICB+ZXJyOihmdW4gZTEgZTIgLT4gRXJyb3Iub2ZfbGlzdCBbIGUxOyBlMiBdKVxuICA7O1xuXG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuZW5kKVxuXG5tb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICBsZXQgcmV0dXJuID0gcmV0dXJuXG5cbiAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBtYXAgPSBtYXBcbiAgICBsZXQgYmluZCA9IGJpbmRcbiAgICBsZXQgYm90aCA9IGJvdGhcblxuICAgICgqIGZyb20gQXBwbGljYXRpdmUuTWFrZSAqKVxuICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgZW5kXG5lbmRcblxub3BlbiBMZXRfc3ludGF4XG5cbmxldCBmYWlsIGVycm9yID0gRGVmZXJyZWQucmV0dXJuIChSZXN1bHQuZmFpbCBlcnJvcilcbmxldCBva19leG4gdCA9IERlZmVycmVkLm1hcCB0IH5mOk9yX2Vycm9yLm9rX2V4blxubGV0IG9mX2V4biA/YmFja3RyYWNlIGV4biA9IERlZmVycmVkLnJldHVybiAoT3JfZXJyb3Iub2ZfZXhuID9iYWNrdHJhY2UgZXhuKVxubGV0IG9mX2V4bl9yZXN1bHQgP2JhY2t0cmFjZSB0ID0gRGVmZXJyZWQubWFwIHQgfmY6KE9yX2Vycm9yLm9mX2V4bl9yZXN1bHQgP2JhY2t0cmFjZSlcbmxldCBlcnJvciBtc2cgdiBzZXhwX29mID0gRGVmZXJyZWQucmV0dXJuIChPcl9lcnJvci5lcnJvciBtc2cgdiBzZXhwX29mKVxubGV0IGVycm9yX3Mgc2V4cCA9IERlZmVycmVkLnJldHVybiAoT3JfZXJyb3IuZXJyb3JfcyBzZXhwKVxubGV0IGVycm9yX3N0cmluZyBtc2cgPSBEZWZlcnJlZC5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBtc2cpXG5sZXQgZXJyb3JmIGZvcm1hdCA9IGtzcHJpbnRmIGVycm9yX3N0cmluZyBmb3JtYXRcbmxldCB0YWcgdCB+dGFnID0gRGVmZXJyZWQubWFwIHQgfmY6KE9yX2Vycm9yLnRhZyB+dGFnKVxubGV0IHRhZ19zIHQgfnRhZyA9IERlZmVycmVkLm1hcCB0IH5mOihPcl9lcnJvci50YWdfcyB+dGFnKVxubGV0IHRhZ19zX2xhenkgdCB+dGFnID0gRGVmZXJyZWQubWFwIHQgfmY6KE9yX2Vycm9yLnRhZ19zX2xhenkgfnRhZylcblxubGV0IHRhZ19hcmcgdCBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgRGVmZXJyZWQubWFwIHQgfmY6KGZ1biB0IC0+IE9yX2Vycm9yLnRhZ19hcmcgdCBtZXNzYWdlIGEgc2V4cF9vZl9hKVxuOztcblxubGV0IHVuaW1wbGVtZW50ZWQgbXNnID0gRGVmZXJyZWQucmV0dXJuIChPcl9lcnJvci51bmltcGxlbWVudGVkIG1zZylcbmxldCBjb21iaW5lX2Vycm9ycyBsID0gRGVmZXJyZWQubWFwIChEZWZlcnJlZC5hbGwgbCkgfmY6T3JfZXJyb3IuY29tYmluZV9lcnJvcnNcbmxldCBjb21iaW5lX2Vycm9yc191bml0IGwgPSBEZWZlcnJlZC5tYXAgKERlZmVycmVkLmFsbCBsKSB+ZjpPcl9lcnJvci5jb21iaW5lX2Vycm9yc191bml0XG5cbmxldCBmaWx0ZXJfb2tfYXRfbGVhc3Rfb25lIGwgPVxuICBEZWZlcnJlZC5tYXAgKERlZmVycmVkLmFsbCBsKSB+ZjpPcl9lcnJvci5maWx0ZXJfb2tfYXRfbGVhc3Rfb25lXG47O1xuXG5sZXQgZmluZF9tYXBfb2sgbCB+ZiA9XG4gIERlZmVycmVkLnJlcGVhdF91bnRpbF9maW5pc2hlZCAobCwgW10pIChmdW4gKGwsIGVycm9ycykgLT5cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBsZXQgZXJyb3JzID0gRXJyb3Iub2ZfbGlzdCAoTGlzdC5yZXYgZXJyb3JzKSBpblxuICAgICAgRGVmZXJyZWQucmV0dXJuIChgRmluaXNoZWQgKEVycm9yIGVycm9ycykpXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgRGVmZXJyZWQubWFwIChmIGhkKSB+ZjooZnVuY3Rpb25cbiAgICAgICAgfCBFcnJvciBjdXJyZW50X2Vycm9yIC0+IGBSZXBlYXQgKHRsLCBjdXJyZW50X2Vycm9yIDo6IGVycm9ycylcbiAgICAgICAgfCBPayByZXN1bHQgLT4gYEZpbmlzaGVkIChPayByZXN1bHQpKSlcbjs7XG5cbmxldCBva191bml0ID0gcmV0dXJuICgpXG5cbmxldCB0cnlfd2l0aCA/ZXh0cmFjdF9leG4gP3J1biA/cmVzdCA/aGVyZSA/bmFtZSBmID1cbiAgRGVmZXJyZWQubWFwIChNb25pdG9yLnRyeV93aXRoID9leHRyYWN0X2V4biA/cnVuID9yZXN0ID9oZXJlID9uYW1lIGYpIH5mOihmdW5jdGlvblxuICAgIHwgRXJyb3IgZXhuIC0+IEVycm9yIChFcnJvci5vZl9leG4gZXhuKVxuICAgIHwgT2sgXyBhcyBvayAtPiBvaylcbjs7XG5cbmxldCB0cnlfd2l0aF9qb2luID9leHRyYWN0X2V4biA/cnVuID9yZXN0ID9oZXJlID9uYW1lIGYgPVxuICBEZWZlcnJlZC5tYXAgKHRyeV93aXRoID9leHRyYWN0X2V4biA/cnVuID9yZXN0ID9oZXJlID9uYW1lIGYpIH5mOk9yX2Vycm9yLmpvaW5cbjs7XG5cbm1vZHVsZSBMaXN0ID0gc3RydWN0XG4gIGxldCBmb2xkaSBsaXN0IH5pbml0OmFjYyB+ZiA9XG4gICAgbGV0IHJlYyBsb29wIGkgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIGFjY1xuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICBsZXQlYmluZCBhY2MgPSBmIGkgYWNjIGhkIGluXG4gICAgICAgIGxvb3AgKGkgKyAxKSBhY2MgdGxcbiAgICBpblxuICAgIGxvb3AgMCBhY2MgbGlzdFxuICA7O1xuXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBmb2xkaSB0IH5pbml0IH5mOihmdW4gXyBhIHggLT4gZiBhIHgpXG5cbiAgbGV0IHNlcW1hcGkgdCB+ZiA9XG4gICAgZm9sZGkgdCB+aW5pdDpbXSB+ZjooZnVuIGkgYnMgYSAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGEgaW5cbiAgICAgIGIgOjogYnMpXG4gICAgPj58IExpc3QucmV2XG4gIDs7XG5cbiAgbGV0IGFsbCA9IGFsbFxuICBsZXQgYWxsX3VuaXQgPSBhbGxfdW5pdFxuXG4gIGxldCBpdGVyaSB+aG93IHQgfmYgPVxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCAoYFBhcmFsbGVsIHwgYE1heF9jb25jdXJyZW50X2pvYnMgXykgYXMgaG93IC0+XG4gICAgICBhbGxfdW5pdCAoTGlzdC5tYXBpIHQgfmY6KHVuc3RhZ2UgKFRocm90dGxlLm1vbmFkX3NlcXVlbmNlX2hvdzIgfmhvdyB+ZikpKVxuICAgIHwgYFNlcXVlbnRpYWwgLT4gZm9sZGkgdCB+aW5pdDooKSB+ZjooZnVuIGkgKCkgeCAtPiBmIGkgeClcbiAgOztcblxuICBsZXQgbWFwaSB+aG93IHQgfmYgPVxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCAoYFBhcmFsbGVsIHwgYE1heF9jb25jdXJyZW50X2pvYnMgXykgYXMgaG93IC0+XG4gICAgICBhbGwgKExpc3QubWFwaSB0IH5mOih1bnN0YWdlIChUaHJvdHRsZS5tb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYpKSlcbiAgICB8IGBTZXF1ZW50aWFsIC0+IHNlcW1hcGkgdCB+ZlxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwaSB+aG93IHQgfmYgPSBtYXBpIHQgfmhvdyB+ZiA+PnwgTGlzdC5maWx0ZXJfb3B0XG4gIGxldCBjb25jYXRfbWFwaSB+aG93IHQgfmYgPSBtYXBpIHQgfmhvdyB+ZiA+PnwgTGlzdC5jb25jYXRcblxuICBsZXQgZmlsdGVyaSB+aG93IHQgfmYgPVxuICAgIGZpbHRlcl9tYXBpIH5ob3cgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIHggaW5cbiAgICAgIGlmIGIgdGhlbiBTb21lIHggZWxzZSBOb25lKVxuICA7O1xuXG4gIGxldCBmaW5kX21hcGkgdCB+ZiA9XG4gICAgbGV0IHJlYyBmaW5kX21hcGkgdCB+ZiBpID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiByZXR1cm4gTm9uZVxuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2glYmluZCBmIGkgaGQgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IGZpbmRfbWFwaSB0bCB+ZiAoaSArIDEpXG4gICAgICAgICB8IFNvbWUgXyBhcyBzb21lIC0+IHJldHVybiBzb21lKVxuICAgIGluXG4gICAgZmluZF9tYXBpIHQgfmYgMFxuICA7O1xuXG4gIGxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXBpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuXG4gIGxldCBmaW5kaSB0IH5mID1cbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBiIHRoZW4gU29tZSAoaSwgZWx0KSBlbHNlIE5vbmUpXG4gIDs7XG5cbiAgbGV0IGZpbmQgdCB+ZiA9XG4gICAgZmluZF9tYXAgdCB+ZjooZnVuIGVsdCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBlbHQgaW5cbiAgICAgIGlmIGIgdGhlbiBTb21lIGVsdCBlbHNlIE5vbmUpXG4gIDs7XG5cbiAgbGV0IGV4aXN0c2kgdCB+ZiA9XG4gICAgbWF0Y2glbWFwXG4gICAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgICAgaWYgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICAgIHdpdGhcbiAgICB8IFNvbWUgKCkgLT4gdHJ1ZVxuICAgIHwgTm9uZSAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBmb3JfYWxsaSB0IH5mID1cbiAgICBtYXRjaCVtYXBcbiAgICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgICBpZiBub3QgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICAgIHdpdGhcbiAgICB8IFNvbWUgKCkgLT4gZmFsc2VcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICA7O1xuXG4gIGxldCBpdGVyIH5ob3cgdCB+ZiA9IGl0ZXJpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBtYXAgfmhvdyB0IH5mID0gbWFwaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgZmlsdGVyIH5ob3cgdCB+ZiA9IGZpbHRlcmkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGZpbHRlcl9tYXAgfmhvdyB0IH5mID0gZmlsdGVyX21hcGkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGNvbmNhdF9tYXAgfmhvdyB0IH5mID0gY29uY2F0X21hcGkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBleGlzdHMgdCB+ZiA9IGV4aXN0c2kgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBmb3JfYWxsaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGluaXQgfmhvdyBuIH5mID0gbWFwIH5ob3cgKExpc3QuaW5pdCBuIH5mOkZuLmlkKSB+ZlxuZW5kXG5cbmxldCByZWMgcmVwZWF0X3VudGlsX2ZpbmlzaGVkIHN0YXRlIGYgPVxuICBtYXRjaCViaW5kIGYgc3RhdGUgd2l0aFxuICB8IGBSZXBlYXQgc3RhdGUgLT4gcmVwZWF0X3VudGlsX2ZpbmlzaGVkIHN0YXRlIGZcbiAgfCBgRmluaXNoZWQgc3RhdGUgLT4gcmV0dXJuIHN0YXRlXG47O1xuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIExpc3QgPSBEZWZlcnJlZF9saXN0XG5cbigqIFdlIGltcGxlbWVudCBhbGwgb2YgdGhlIFtRdWV1ZV0gb3BlcmF0aW9ucyBieSBjb252ZXJ0aW5nIHRoZSBxdWV1ZSB0byBhIGxpc3QgYW5kIHRoZW5cbiAgIHVzaW5nIHRoZSBjb3JyZXNwb25kaW5nIFtMaXN0XSBvcGVyYXRpb24uICBXZSB1c2UgbGlzdHMgcmF0aGVyIHRoYW4gYXJyYXlzIGJlY2F1c2VcbiAgIGFycmF5cyBsb25nZXIgdGhhbiBhIGNlcnRhaW4gbGVuZ3RoIGFyZSBhbGxvY2F0ZWQgaW4gdGhlIG1ham9yIGhlYXAsIHdoaWNoIGNhbiBjYXVzZVxuICAgdW5uZWNlc3NhcnkgcHJvbW90aW9uIG9mIHRoZSBlbGVtZW50cyBpbiB0aGUgcXVldWUuICBBbHNvLCB3aGVuIG9uZSBpcyBmb2xkaW5nIG9yXG4gICBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSwgdGhlIGVudGlyZSBhcnJheSBtdXN0IGJlIGtlcHQgYWxpdmUuICBXaGVuIGZvbGRpbmcgb3JcbiAgIGl0ZXJhdGluZyBvdmVyIGEgbGlzdCwgb25seSB0aGUgcmVtYWluaW5nIHRhaWwgb2YgdGhlIGxpc3QgaXMga2VwdCBhbGl2ZS4gIFNvLCB1c2luZ1xuICAgYXJyYXlzIHJhdGhlciB0aGFuIGxpc3RzIHdvdWxkIGluY3JlYXNlIHRoZSBsaXZlLXNwYWNlIG5lZWRlZCBieSB0aGUgcHJvZ3JhbS4gKilcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPSBMaXN0LmZvbGRpIChRdWV1ZS50b19saXN0IHQpIH5pbml0IH5mXG5sZXQgZm9sZCB0IH5pbml0IH5mID0gTGlzdC5mb2xkIChRdWV1ZS50b19saXN0IHQpIH5pbml0IH5mXG5sZXQgYWxsIHQgPSBMaXN0LmFsbCAoUXVldWUudG9fbGlzdCB0KSA+PnwgUXVldWUub2ZfbGlzdFxubGV0IGFsbF91bml0IHQgPSBMaXN0LmFsbF91bml0IChRdWV1ZS50b19saXN0IHQpXG5sZXQgaXRlciB+aG93IHQgfmYgPSBMaXN0Lml0ZXIgfmhvdyAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGl0ZXJpIH5ob3cgdCB+ZiA9IExpc3QuaXRlcmkgfmhvdyAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IG1hcCB+aG93IHQgfmYgPSBMaXN0Lm1hcCB+aG93IChRdWV1ZS50b19saXN0IHQpIH5mID4+fCBRdWV1ZS5vZl9saXN0XG5sZXQgbWFwaSB+aG93IHQgfmYgPSBMaXN0Lm1hcGkgfmhvdyAoUXVldWUudG9fbGlzdCB0KSB+ZiA+PnwgUXVldWUub2ZfbGlzdFxubGV0IGluaXQgfmhvdyBuIH5mID0gTGlzdC5pbml0IH5ob3cgbiB+ZiA+PnwgUXVldWUub2ZfbGlzdFxubGV0IGZpbHRlciB+aG93IHQgfmYgPSBMaXN0LmZpbHRlciB+aG93IChRdWV1ZS50b19saXN0IHQpIH5mID4+fCBRdWV1ZS5vZl9saXN0XG5sZXQgZmlsdGVyaSB+aG93IHQgfmYgPSBMaXN0LmZpbHRlcmkgfmhvdyAoUXVldWUudG9fbGlzdCB0KSB+ZiA+PnwgUXVldWUub2ZfbGlzdFxubGV0IGZpbHRlcl9tYXAgfmhvdyB0IH5mID0gTGlzdC5maWx0ZXJfbWFwIH5ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmYgPj58IFF1ZXVlLm9mX2xpc3RcbmxldCBmaWx0ZXJfbWFwaSB+aG93IHQgfmYgPSBMaXN0LmZpbHRlcl9tYXBpIH5ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmYgPj58IFF1ZXVlLm9mX2xpc3RcblxubGV0IGNvbmNhdF9tYXAgfmhvdyB0IH5mID1cbiAgTGlzdC5jb25jYXRfbWFwIH5ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmY6KGZ1biB4IC0+IGYgeCA+PnwgUXVldWUudG9fbGlzdClcbiAgPj58IFF1ZXVlLm9mX2xpc3Rcbjs7XG5cbmxldCBjb25jYXRfbWFwaSB+aG93IHQgfmYgPVxuICBMaXN0LmNvbmNhdF9tYXBpIH5ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmY6KGZ1biBpIHggLT4gZiBpIHggPj58IFF1ZXVlLnRvX2xpc3QpXG4gID4+fCBRdWV1ZS5vZl9saXN0XG47O1xuXG5sZXQgZmluZF9tYXAgdCB+ZiA9IExpc3QuZmluZF9tYXAgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBmaW5kX21hcGkgdCB+ZiA9IExpc3QuZmluZF9tYXBpIChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgZmluZCB0IH5mID0gTGlzdC5maW5kIChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgZmluZGkgdCB+ZiA9IExpc3QuZmluZGkgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBmb3JfYWxsIHQgfmYgPSBMaXN0LmZvcl9hbGwgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBmb3JfYWxsaSB0IH5mID0gTGlzdC5mb3JfYWxsaSAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGV4aXN0cyB0IH5mID0gTGlzdC5leGlzdHMgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBleGlzdHNpIHQgfmYgPSBMaXN0LmV4aXN0c2kgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbiIsIm9wZW4gQ29yZVxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG4oKiBbZm9sZF9tYXBpIH5ob3cgdCB+aW5pdCB+bWFwaV9mIH5mb2xkX2ZdIGlzIGEgbW9yZSBlZmZpY2llbnQgdmVyc2lvbiBvZjpcblxuICAge1tcbiAgICAgZm9sZCB+aW5pdCB+ZjooZnVuIGIgYSAtPiByZXR1cm4gKGZvbGRfZiBiIGEpKSAobWFwaSB0IH5ob3cgfmY6bWFwaV9mKSBdfVxuXG4gICBJdCBhdm9pZHMgY3JlYXRpbmcgdGhlIGludGVybWVkaWF0ZSBzZXF1ZW5jZSB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIFttYXBpXSwgYW5kXG4gICBhbGxvd3MgdGhlIFtmb2xkXSB0byBwcm9jZWVkIGNvbmN1cnJlbnRseSB3aXRoIHRoZSBbbWFwaV0sIHNvIHRoYXQgb25lIGNhbiBhY2N1bXVsYXRlXG4gICB0aGUgcmVzdWx0IGFzIHNvb24gYXMgcG9zc2libGUsIHBvc3NpYmx5IGF2b2lkaW5nIGNyZWF0aW5nIGFuIGludGVybWVkaWF0ZSBzdHJ1Y3R1cmVcbiAgIChlLmcuIFtpdGVyaV0gYW5kIFtmaWx0ZXJfbWFwXSB1c2VzIFtmb2xkX21hcGldIHRvIGRvIHRoaXMpLiAqKVxubGV0IGZvbGRfbWFwaVxuICAodHlwZSBhIGIgYylcbiAgPyhob3cgPSBgU2VxdWVudGlhbClcbiAgKHQgOiBhIFNlcXVlbmNlLnQpXG4gIH4oaW5pdCA6IGMpXG4gIH4obWFwaV9mIDogaW50IC0+IGEgLT4gYiBEZWZlcnJlZC50KVxuICB+KGZvbGRfZiA6IGMgLT4gYiAtPiBjKVxuICA6IGMgRGVmZXJyZWQudFxuICA9XG4gIGxldCV0eWRpIChTZXF1ZW5jZSB7IHN0YXRlOyBuZXh0IH0pID0gU2VxdWVuY2UuRXhwZXJ0LnZpZXcgdCBpblxuICBtYXRjaCBob3cgd2l0aFxuICB8IGBTZXF1ZW50aWFsIC0+XG4gICAgbGV0IHJlc3VsdCA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgbGV0IHJlYyBsb29wIGkgc3RhdGUgKGMgOiBjKSA9XG4gICAgICBtYXRjaCBuZXh0IHN0YXRlIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBJdmFyLmZpbGxfZXhuIHJlc3VsdCBjXG4gICAgICB8IFNraXAgeyBzdGF0ZSB9IC0+IGxvb3AgaSBzdGF0ZSAoYyA6IGMpXG4gICAgICB8IFlpZWxkIHsgc3RhdGU7IHZhbHVlID0gYSB9IC0+XG4gICAgICAgIHVwb24gKG1hcGlfZiBpIGEpIChmdW4gYiAtPiBsb29wIChpICsgMSkgc3RhdGUgKGZvbGRfZiBjIGIpKVxuICAgIGluXG4gICAgbG9vcCAwIHN0YXRlIGluaXQ7XG4gICAgSXZhci5yZWFkIHJlc3VsdFxuICB8IGBQYXJhbGxlbCAtPlxuICAgIGxldCByZWMgbG9vcCBpIHQgKGMgOiBjIERlZmVycmVkLnQpID1cbiAgICAgIG1hdGNoIG5leHQgdCB3aXRoXG4gICAgICB8IERvbmUgLT4gY1xuICAgICAgfCBTa2lwIHsgc3RhdGUgfSAtPiBsb29wIGkgc3RhdGUgY1xuICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSB0IH0gLT5cbiAgICAgICAgbG9vcFxuICAgICAgICAgIChpICsgMSlcbiAgICAgICAgICB0XG4gICAgICAgICAgKGxldCViaW5kIGIgPSBtYXBpX2YgaSBhIGluXG4gICAgICAgICAgIGxldCVtYXAgYyA9IGMgaW5cbiAgICAgICAgICAgZm9sZF9mIGMgYilcbiAgICBpblxuICAgIGxvb3AgMCBzdGF0ZSAocmV0dXJuIGluaXQpXG4gIHwgYE1heF9jb25jdXJyZW50X2pvYnMgbWF4X2NvbmN1cnJlbnRfam9icyAtPlxuICAgIGxldCB0aHJvdHRsZSA9IFRocm90dGxlLmNyZWF0ZSB+bWF4X2NvbmN1cnJlbnRfam9icyB+Y29udGludWVfb25fZXJyb3I6ZmFsc2UgaW5cbiAgICAoKiBbbG9vcF0gZm9yY2VzIHRoZSBpbnB1dCBzZXF1ZW5jZSBhbmQgZW5xdWV1ZXMgYSB0aHJvdHRsZSBqb2Igb25seSBpZiB0aGVyZSBpc1xuICAgICAgIGNhcGFjaXR5IGF2YWlsYWJsZS4gKilcbiAgICBsZXQgcmVjIGxvb3AgaSB0IChjIDogYyBEZWZlcnJlZC50KSA9XG4gICAgICBsZXQlYmluZCAoKSA9IFRocm90dGxlLmNhcGFjaXR5X2F2YWlsYWJsZSB0aHJvdHRsZSBpblxuICAgICAgbWF0Y2ggbmV4dCB0IHdpdGhcbiAgICAgIHwgRG9uZSAtPiBjXG4gICAgICB8IFNraXAgeyBzdGF0ZSB9IC0+IGxvb3AgaSBzdGF0ZSBjXG4gICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHQgfSAtPlxuICAgICAgICBsb29wXG4gICAgICAgICAgKGkgKyAxKVxuICAgICAgICAgIHRcbiAgICAgICAgICAobGV0JWJpbmQgYiA9IFRocm90dGxlLmVucXVldWUgdGhyb3R0bGUgKGZ1biAoKSAtPiBtYXBpX2YgaSBhKSBpblxuICAgICAgICAgICBsZXQlbWFwIGMgPSBjIGluXG4gICAgICAgICAgIGZvbGRfZiBjIGIpXG4gICAgaW5cbiAgICBsb29wIDAgc3RhdGUgKHJldHVybiBpbml0KVxuOztcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBTZXF1ZW5jZS5kZWxheWVkX2ZvbGRcbiAgICB0XG4gICAgfmluaXQ6KDAsIGluaXQpXG4gICAgfmY6KGZ1biAoaSwgYikgYSB+ayAtPlxuICAgICAgbGV0JWJpbmQgYiA9IGYgaSBiIGEgaW5cbiAgICAgIGsgKGkgKyAxLCBiKSlcbiAgICB+ZmluaXNoOihmdW4gKF8sIGIpIC0+IHJldHVybiBiKVxuOztcblxuKCogW2ZvbGRdIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0ZXJtcyBvZiBbZm9sZGldIHRvIHNhdmUgdGhlIGludGVybWVkaWF0ZSBjbG9zdXJlXG4gICBhbGxvY2F0aW9uLiAqKVxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIFNlcXVlbmNlLmRlbGF5ZWRfZm9sZCB0IH5pbml0IH5mOihmdW4gYiBhIH5rIC0+IGYgYiBhID4+PSBrKSB+ZmluaXNoOnJldHVyblxuOztcblxubGV0IGFsbCB0ID1cbiAgbGV0JW1hcCByZXMgPVxuICAgIGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIGFjY3VtIGQgLT5cbiAgICAgIGxldCVtYXAgYSA9IGQgaW5cbiAgICAgIGEgOjogYWNjdW0pXG4gIGluXG4gIFNlcXVlbmNlLm9mX2xpc3QgKExpc3QucmV2IHJlcylcbjs7XG5cbmxldCBhbGxfdW5pdCB0ID0gZm9sZCB0IH5pbml0OigpIH5mOihmdW4gKCkgdiAtPiB2KVxuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGZpbmRfbWFwaSB0IH5mIGkgPVxuICAgIG1hdGNoIFNlcXVlbmNlLm5leHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJldHVybiBOb25lXG4gICAgfCBTb21lICh2LCByZXN0KSAtPlxuICAgICAgKG1hdGNoJWJpbmQgZiBpIHYgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcGkgcmVzdCB+ZiAoaSArIDEpXG4gICAgICAgfCBTb21lIF8gYXMgc29tZSAtPiByZXR1cm4gc29tZSlcbiAgaW5cbiAgZmluZF9tYXBpIHQgfmYgMFxuOztcblxubGV0IGZpbmRpIHQgfmYgPVxuICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgIGlmIGIgdGhlbiBTb21lIChpLCBlbHQpIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBmaW5kX21hcGkgdCB+ZjooZnVuIF8gZWx0IC0+XG4gICAgbGV0JW1hcCBiID0gZiBlbHQgaW5cbiAgICBpZiBiIHRoZW4gU29tZSBlbHQgZWxzZSBOb25lKVxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIG1hdGNoJW1hcFxuICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgIGlmIGIgdGhlbiBTb21lICgpIGVsc2UgTm9uZSlcbiAgd2l0aFxuICB8IFNvbWUgKCkgLT4gdHJ1ZVxuICB8IE5vbmUgLT4gZmFsc2Vcbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbWF0Y2glbWFwXG4gICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgaWYgbm90IGIgdGhlbiBTb21lICgpIGVsc2UgTm9uZSlcbiAgd2l0aFxuICB8IFNvbWUgKCkgLT4gZmFsc2VcbiAgfCBOb25lIC0+IHRydWVcbjs7XG5cbmxldCBpdGVyaSB+aG93IHQgfmYgOiB1bml0IERlZmVycmVkLnQgPVxuICBmb2xkX21hcGkgfmhvdyB0IH5tYXBpX2Y6ZiB+aW5pdDooKSB+Zm9sZF9mOihmdW4gKCkgKCkgLT4gKCkpXG47O1xuXG5sZXQgbWFwaSB+aG93IHQgfmYgPVxuICBsZXQlbWFwIGJzID1cbiAgICBmb2xkX21hcGkgfmhvdyB0IH5tYXBpX2Y6KGZ1biBpIGEgLT4gZiBpIGEpIH5pbml0OltdIH5mb2xkX2Y6KGZ1biBicyBiIC0+IGIgOjogYnMpXG4gIGluXG4gIFNlcXVlbmNlLm9mX2xpc3QgKExpc3QucmV2IGJzKVxuOztcblxuKCogW2ZpbHRlcl9tYXBpXSBpcyBpbXBsZW1lbnRlZCB1c2luZyBbZm9sZF9tYXBpXSByYXRoZXIgdGhhbiBbbWFwXSBzbyB0aGF0IHdlIG5ldmVyIG5lZWRcbiAgIHRvIGtlZXAgYSBsb25nIHN0cmVhbSBvZiBpbnRlcm1lZGlhdGUgW05vbmVdIHJlc3VsdHMgaW4gdGhlIGFjY3VtdWxhdG9yLCBvbmx5IHRvIGxhdGVyXG4gICBmaWx0ZXIgdGhlbSBhbGwgb3V0LiAqKVxubGV0IGZpbHRlcl9tYXBpIH5ob3cgdCB+ZiA9XG4gIGxldCVtYXAgYnMgPVxuICAgIGZvbGRfbWFwaVxuICAgICAgdFxuICAgICAgfmhvd1xuICAgICAgfm1hcGlfZjooZnVuIGkgYSAtPiBmIGkgYSlcbiAgICAgIH5pbml0OltdXG4gICAgICB+Zm9sZF9mOihmdW4gYnMgbWF5YmVfdiAtPlxuICAgICAgICBtYXRjaCBtYXliZV92IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGJzXG4gICAgICAgIHwgU29tZSBiIC0+IGIgOjogYnMpXG4gIGluXG4gIFNlcXVlbmNlLm9mX2xpc3QgKExpc3QucmV2IGJzKVxuOztcblxubGV0IGNvbmNhdF9tYXBpIH5ob3cgdCB+ZiA9IG1hcGkgfmhvdyB0IH5mID4+fCBTZXF1ZW5jZS5jb25jYXRcblxubGV0IGZpbHRlcmkgfmhvdyB0IH5mID1cbiAgZmlsdGVyX21hcGkgfmhvdyB0IH5mOihmdW4gaSBhIC0+XG4gICAgbWF0Y2glbWFwIGYgaSBhIHdpdGhcbiAgICB8IHRydWUgLT4gU29tZSBhXG4gICAgfCBmYWxzZSAtPiBOb25lKVxuOztcblxubGV0IGl0ZXIgfmhvdyB0IH5mID0gaXRlcmkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBtYXAgfmhvdyB0IH5mID0gbWFwaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbHRlciB+aG93IHQgfmYgPSBmaWx0ZXJpIH5ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZmlsdGVyX21hcCB+aG93IHQgfmYgPSBmaWx0ZXJfbWFwaSB+aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGNvbmNhdF9tYXAgfmhvdyB0IH5mID0gY29uY2F0X21hcGkgfmhvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXBpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmb3JfYWxsIHQgfmYgPSBmb3JfYWxsaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBpbml0IH5ob3cgbiB+ZiA9IG1hcCB+aG93IChTZXF1ZW5jZS5pbml0IG4gfmY6Rm4uaWQpIH5mXG5cbmxldCBjb3VudCA/aG93IHQgfmYgPVxuICBmb2xkX21hcGlcbiAgICA/aG93XG4gICAgdFxuICAgIH5tYXBpX2Y6KGZ1biBfaSBhIC0+IGYgYSlcbiAgICB+aW5pdDowXG4gICAgfmZvbGRfZjooZnVuIGFjYyBjIC0+IGFjYyArIEJvb2wudG9faW50IGMpXG47O1xuXG5sZXQgc3VtICh0eXBlIGEpIChtb2R1bGUgTSA6IEJhc2UuQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gYSkgP2hvdyB0IH5mID1cbiAgZm9sZF9tYXBpID9ob3cgdCB+bWFwaV9mOihmdW4gX2kgYSAtPiBmIGEpIH5pbml0Ok0uemVybyB+Zm9sZF9mOk0uKCArIClcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgU2VxdWVuY2UgPSBEZWZlcnJlZF9zZXF1ZW5jZVxuXG5sZXQgZm9yX2FsbCB0IH5mID0gU2V0LnRvX3NlcXVlbmNlIHQgfD4gU2VxdWVuY2UuZm9yX2FsbCB+ZlxubGV0IGZpbmQgdCB+ZiA9IFNldC50b19zZXF1ZW5jZSB0IHw+IFNlcXVlbmNlLmZpbmQgfmZcbmxldCBmaW5kX21hcCB0IH5mID0gU2V0LnRvX3NlcXVlbmNlIHQgfD4gU2VxdWVuY2UuZmluZF9tYXAgfmZcbmxldCBmb2xkIHQgfmluaXQgfmYgPSBTZXQudG9fc2VxdWVuY2UgdCB8PiBTZXF1ZW5jZS5mb2xkIH5pbml0IH5mXG5cbmxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPVxuICBTZXQudG9fc2VxdWVuY2Ugfm9yZGVyOmBEZWNyZWFzaW5nIHQgfD4gU2VxdWVuY2UuZm9sZCB+aW5pdCB+ZjooRm4uZmxpcCBmKVxuOztcblxubGV0IGl0ZXIgfmhvdyB0IH5mID0gU2V0LnRvX3NlcXVlbmNlIHQgfD4gU2VxdWVuY2UuaXRlciB+aG93IH5mXG5cbmxldCBmaWx0ZXJfbWFwICh0eXBlIGVsdCBjbXApICgobW9kdWxlIE0pIDogKGVsdCwgY21wKSBDb21wYXJhdG9yLk1vZHVsZS50KSB+aG93IHQgfmYgPVxuICBTZXQudG9fc2VxdWVuY2UgdFxuICB8PiBTZXF1ZW5jZS5mb2xkX21hcGlcbiAgICAgICB+aW5pdDooU2V0LlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3I6TS5jb21wYXJhdG9yKVxuICAgICAgIH5ob3dcbiAgICAgICB+bWFwaV9mOihmdW4gX2kgYSAtPiBmIGEpXG4gICAgICAgfmZvbGRfZjooZnVuIGFjYyB2IC0+XG4gICAgICAgICBtYXRjaCB2IHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiBhY2NcbiAgICAgICAgIHwgU29tZSB2IC0+IFNldC5hZGQgYWNjIHYpXG47O1xuXG5sZXQgZmlsdGVyIH5ob3cgdCB+ZiA9XG4gIGZpbHRlcl9tYXAgKFNldC5jb21wYXJhdG9yX3MgdCkgfmhvdyB0IH5mOihmdW4geCAtPiBpZiVtYXAgZiB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSlcbjs7XG5cbmxldCBtYXAgY29tcGFyYXRvciB+aG93IHQgfmYgPVxuICBmaWx0ZXJfbWFwIGNvbXBhcmF0b3IgfmhvdyB0IH5mOihmdW4geCAtPlxuICAgIGxldCVtYXAgeSA9IGYgeCBpblxuICAgIFNvbWUgeSlcbjs7XG5cbmxldCBjb3VudCB+aG93IHQgfmYgPSBTZXQudG9fc2VxdWVuY2UgdCB8PiBTZXF1ZW5jZS5jb3VudCB+aG93IH5mXG5cbmxldCBzdW0gKHR5cGUgYSkgKG1vZHVsZSBNIDogQmFzZS5Db250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSBhKSB+aG93IHQgfmYgPVxuICBTZXQudG9fc2VxdWVuY2UgdCB8PiBTZXF1ZW5jZS5zdW0gKG1vZHVsZSBNKSB+aG93IH5mXG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgQ2xvY2tfbnMgPSBDbG9ja19uc1xubW9kdWxlIFRpbWVfbnMgPSBUaW1lX25zXG5tb2R1bGUgVGltZSA9IFRpbWVfZmxvYXRcbm1vZHVsZSBBc3luY19rZXJuZWxfc2NoZWR1bGVyID0gQXN5bmNfa2VybmVsX3NjaGVkdWxlclxubW9kdWxlIERhdGUgPSBEYXRlXG5cbmxldCBhZnRlciA9IENsb2NrX25zLmFmdGVyXG5sZXQgYXQgPSBDbG9ja19ucy5hdFxubGV0IGV2ZXJ5ID0gQ2xvY2tfbnMuZXZlcnlcbmxldCB3aXRoX3RpbWVvdXQgPSBDbG9ja19ucy53aXRoX3RpbWVvdXRcbiIsIm9wZW4gQ29yZVxub3BlbiBJbXBvcnRcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgU3RyZWFtID0gQXN5bmNfc3RyZWFtXG5cbmxldCBzaG93X2RlYnVnX21lc3NhZ2VzID0gcmVmIGZhbHNlXG5sZXQgY2hlY2tfaW52YXJpYW50ID0gcmVmIGZhbHNlXG5cbm1vZHVsZSBGbHVzaGVkX3Jlc3VsdCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIFsgYE9rXG4gICAgfCBgUmVhZGVyX2Nsb3NlZFxuICAgIF1cbiAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICBsZXQgZXF1YWwgPSBbJWNvbXBhcmUuZXF1YWw6IHRdXG5cbiAgbGV0IGNvbWJpbmUgKGwgOiB0IERlZmVycmVkLnQgbGlzdCkgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgWyB4IF0gLT4geFxuICAgIHwgbCAtPlxuICAgICAgbGV0JW1hcCBsID0gRGVmZXJyZWQuYWxsIGwgaW5cbiAgICAgIChtYXRjaCBMaXN0Lm1lbSBsIGBSZWFkZXJfY2xvc2VkIH5lcXVhbCB3aXRoXG4gICAgICAgfCB0cnVlIC0+IGBSZWFkZXJfY2xvc2VkXG4gICAgICAgfCBmYWxzZSAtPiBgT2spXG4gIDs7XG5lbmRcblxuKCogQSBbQ29uc3VtZXIudF0gYWN0cyBhcyB0aGUgbW9uaXRvciBvZiBzb21lIHByb2Nlc3MgdGhhdCByZWFkcyB2YWx1ZXMgZnJvbSBhIHBpcGUgYW5kXG4gICBwcm9jZXNzZXMgdGhlbSwgYWxsb3dpbmcgdGhhdCBwcm9jZXNzOlxuICAgLSB0byBjb21tdW5pY2F0ZSB0aGF0IGl0IGhhcyB0YWtlbiByZXNwb25zaWJpbGl0eSBmb3IgdGhlIHZhbHVlc1xuICAgLSB0byBzaWduYWwgd2hlbiBpdCBoYXMgZmluaXNoZWQgd2l0aCB0aGUgdmFsdWVzIHRvIGludGVyZXN0ZWQgcGFydGllcyAodmlhXG4gICAgIFtkb3duc3RyZWFtX2ZsdXNoZWRdKVxuXG4gICBJdCBpcyB1c2VkIGluIHR3byBzdGVwczpcblxuICAgMS4gY2FsbGluZyBbQ29uc3VtZXIuc3RhcnRdIGF0IHRoZSBwb2ludCB3aGVyZSB0aGUgY29uc3VtZXIgdGFrZXMgdmFsdWVzIG91dCBvZiB0aGVcbiAgIFBpcGUgdmlhIFtyZWFkXSBvciBbcmVhZCddLlxuXG4gICAyLiBjYWxsaW5nIFtDb25zdW1lci52YWx1ZXNfc2VudF9kb3duc3RyZWFtXS5cblxuICAgQnkgY2FsbGluZyBbdmFsdWVzX3NlbnRfZG93bnN0cmVhbV0gb25lIGFzc2VydHMgdGhhdCB0aGUgW2Rvd25zdHJlYW1fZmx1c2hlZF0gZnVuY3Rpb25cbiAgIHN1cHBsaWVkIHRvIFtjcmVhdGVdIHdpbGwgbm93IHdhaXQgZm9yIHRoaXMgdmFsdWUuXG5cbiAgIElmIG5vIFtDb25zdW1lci50XSBpcyBzdXBwbGllZCB3aGVuIGEgdmFsdWUgaXMgcmVhZCB0aGVuIHRoZSB2YWx1ZSBpcyBkZWZpbmVkIHRvIGJlXG4gICBmbHVzaGVkIGF0IHRoYXQgdGltZS4gKilcbm1vZHVsZSBDb25zdW1lciA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBpbmNsdWRlIEludmFyaWFudC5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgY3JlYXRlXG4gICAgOiAgcGlwZV9pZDppbnRcbiAgICAtPiBkb3duc3RyZWFtX2ZsdXNoZWQ6KHVuaXQgLT4gRmx1c2hlZF9yZXN1bHQudCBEZWZlcnJlZC50KVxuICAgIC0+IHRcblxuICB2YWwgcGlwZV9pZCA6IHQgLT4gaW50XG4gIHZhbCBzdGFydCA6IHQgLT4gdW5pdFxuICB2YWwgdmFsdWVzX3NlbnRfZG93bnN0cmVhbSA6IHQgLT4gdW5pdFxuICB2YWwgdmFsdWVzX3NlbnRfZG93bnN0cmVhbV9hbmRfZmx1c2hlZCA6IHQgLT4gRmx1c2hlZF9yZXN1bHQudCBEZWZlcnJlZC50XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHBpcGVfaWQgOiBpbnRcbiAgICA7ICgqIFt2YWx1ZXNfcmVhZF0gcmVmbGVjdHMgd2hldGhlciB2YWx1ZXMgdGhlIGNvbnN1bWVyIGhhcyByZWFkIGZyb20gdGhlIHBpcGUgaGF2ZSBiZWVuXG4gICAgICAgICBzZW50IGRvd25zdHJlYW0gb3IgaWYgbm90LCBob2xkcyBhbiBpdmFyIHRoYXQgaXMgdG8gYmUgZmlsbGVkIHdoZW4gdGhleSBhcmUuICopXG4gICAgICBtdXRhYmxlXG4gICAgICAgIHZhbHVlc19yZWFkIDpcbiAgICAgICAgWyBgSGF2ZV9iZWVuX3NlbnRfZG93bnN0cmVhbSB8IGBIYXZlX25vdF9iZWVuX3NlbnRfZG93bnN0cmVhbSBvZiB1bml0IEl2YXIudCBdXG4gICAgOyAoKiBbZG93bnN0cmVhbV9mbHVzaGVkICgpXSByZXR1cm5zIHdoZW4gYWxsIHByaW9yIHZhbHVlcyB0aGF0IHRoZSBjb25zdW1lciBoYXNcbiAgICAgICAgIHBhc3NlZCBkb3duc3RyZWFtIGhhdmUgYmVlbiBmbHVzaGVkIGFsbCB0aGUgd2F5IGRvd24gdGhlIGNoYWluIG9mIHBpcGVzLiAqKVxuICAgICAgZG93bnN0cmVhbV9mbHVzaGVkIDogdW5pdCAtPiBGbHVzaGVkX3Jlc3VsdC50IERlZmVycmVkLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCB0IDogdW5pdCA9XG4gICAgdHJ5XG4gICAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgfnBpcGVfaWQ6aWdub3JlXG4gICAgICAgIH52YWx1ZXNfcmVhZDpcbiAgICAgICAgICAoY2hlY2sgKGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGBIYXZlX2JlZW5fc2VudF9kb3duc3RyZWFtIC0+ICgpXG4gICAgICAgICAgICB8IGBIYXZlX25vdF9iZWVuX3NlbnRfZG93bnN0cmVhbSBpdmFyIC0+IGFzc2VydCAoSXZhci5pc19lbXB0eSBpdmFyKSkpXG4gICAgICAgIH5kb3duc3RyZWFtX2ZsdXNoZWQ6aWdub3JlXG4gICAgd2l0aFxuICAgIHwgZXhuIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiUGlwZS5Db25zdW1lci5pbnZhcmlhbnQgZmFpbGVkXCIgKGV4biA6IGV4bikgfnBpcGU6KHQgOiB0KV1cbiAgOztcblxuICBsZXQgY3JlYXRlIH5waXBlX2lkIH5kb3duc3RyZWFtX2ZsdXNoZWQgPVxuICAgIHsgcGlwZV9pZDsgdmFsdWVzX3JlYWQgPSBgSGF2ZV9iZWVuX3NlbnRfZG93bnN0cmVhbTsgZG93bnN0cmVhbV9mbHVzaGVkIH1cbiAgOztcblxuICBsZXQgc3RhcnQgdCA9XG4gICAgbWF0Y2ggdC52YWx1ZXNfcmVhZCB3aXRoXG4gICAgfCBgSGF2ZV9ub3RfYmVlbl9zZW50X2Rvd25zdHJlYW0gXyAtPiAoKVxuICAgIHwgYEhhdmVfYmVlbl9zZW50X2Rvd25zdHJlYW0gLT5cbiAgICAgIHQudmFsdWVzX3JlYWQgPC0gYEhhdmVfbm90X2JlZW5fc2VudF9kb3duc3RyZWFtIChJdmFyLmNyZWF0ZSAoKSlcbiAgOztcblxuICBsZXQgdmFsdWVzX3NlbnRfZG93bnN0cmVhbSB0ID1cbiAgICBtYXRjaCB0LnZhbHVlc19yZWFkIHdpdGhcbiAgICB8IGBIYXZlX2JlZW5fc2VudF9kb3duc3RyZWFtIC0+ICgpXG4gICAgfCBgSGF2ZV9ub3RfYmVlbl9zZW50X2Rvd25zdHJlYW0gaXZhciAtPlxuICAgICAgSXZhci5maWxsX2V4biBpdmFyICgpO1xuICAgICAgdC52YWx1ZXNfcmVhZCA8LSBgSGF2ZV9iZWVuX3NlbnRfZG93bnN0cmVhbVxuICA7O1xuXG4gIGxldCB2YWx1ZXNfc2VudF9kb3duc3RyZWFtX2FuZF9mbHVzaGVkIHQgPVxuICAgIG1hdGNoIHQudmFsdWVzX3JlYWQgd2l0aFxuICAgIHwgYEhhdmVfYmVlbl9zZW50X2Rvd25zdHJlYW0gLT4gdC5kb3duc3RyZWFtX2ZsdXNoZWQgKClcbiAgICB8IGBIYXZlX25vdF9iZWVuX3NlbnRfZG93bnN0cmVhbSB3aGVuX3NlbnRfZG93bnN0cmVhbSAtPlxuICAgICAgbGV0JWJpbmQgKCkgPSBJdmFyLnJlYWQgd2hlbl9zZW50X2Rvd25zdHJlYW0gaW5cbiAgICAgIHQuZG93bnN0cmVhbV9mbHVzaGVkICgpXG4gIDs7XG5lbmRcblxubW9kdWxlIEJsb2NrZWRfcmVhZCA9IHN0cnVjdFxuICAoKiBBIFtCbG9ja2VkX3JlYWQudF0gcmVwcmVzZW50cyBhIGJsb2NrZWQgcmVhZCBhdHRlbXB0LiAgSWYgc29tZW9uZSByZWFkcyBmcm9tIGFuIGVtcHR5XG4gICAgIHBpcGUsIHRoZXkgZW5xdWV1ZSBhIFtCbG9ja2VkX3JlYWQudF0gaW4gdGhlIHF1ZXVlIG9mIFtibG9ja2VkX3JlYWRzXS4gIExhdGVyLCB3aGVuXG4gICAgIHZhbHVlcyBhcmUgd3JpdHRlbiB0byBhIHBpcGUsIHRoYXQgd2lsbCBjYXVzZSBzb21lIG51bWJlciBvZiBibG9ja2VkIHJlYWRzIHRvIGJlXG4gICAgIGZpbGxlZCwgZmlyc3QgY29tZSBmaXJzdCBzZXJ2ZS4gIFRoZSBibG9ja2VkLXJlYWQgY29uc3RydWN0b3Igc3BlY2lmaWVzIGhvdyBtYW55XG4gICAgIHZhbHVlcyBhIHJlYWQgc2hvdWxkIGNvbnN1bWUgZnJvbSB0aGUgcGlwZSB3aGVuIGl0IGdldHMgaXRzIHR1cm4uXG5cbiAgICAgSWYgYSBwaXBlIGlzIGNsb3NlZCwgdGhlbiBhbGwgYmxvY2tlZCByZWFkcyB3aWxsIGJlIGZpbGxlZCB3aXRoIFtgRW9mXS4gKilcbiAgdHlwZSAnYSB3YW50cyA9XG4gICAgfCBaZXJvIG9mIFsgYEVvZiB8IGBPayBdIEl2YXIudFxuICAgIHwgT25lIG9mIFsgYEVvZiB8IGBPayBvZiAnYSBdIEl2YXIudFxuICAgIHwgQXRfbW9zdCBvZiBpbnQgKiBbIGBFb2YgfCBgT2sgb2YgJ2EgUXVldWUudCBdIEl2YXIudFxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgJ2EgdCA9XG4gICAgeyB3YW50cyA6ICdhIHdhbnRzXG4gICAgOyBjb25zdW1lciA6IENvbnN1bWVyLnQgb3B0aW9uXG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMgfml0ZXJhdG9yczppdGVyLCBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICAgIHRyeVxuICAgICAgbGV0IGNoZWNrIGYgZmllbGQgPSBmIChGaWVsZC5nZXQgZmllbGQgdCkgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH53YW50czpcbiAgICAgICAgICAoY2hlY2sgKGZ1bmN0aW9uXG4gICAgICAgICAgICB8IFplcm8gXyB8IE9uZSBfIC0+ICgpXG4gICAgICAgICAgICB8IEF0X21vc3QgKGksIF8pIC0+IGFzc2VydCAoaSA+IDApKSlcbiAgICAgICAgfmNvbnN1bWVyOlxuICAgICAgICAgIChjaGVjayAoZnVuY3Rpb25cbiAgICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgICAgfCBTb21lIGNvbnN1bWVyIC0+IENvbnN1bWVyLmludmFyaWFudCBjb25zdW1lcikpXG4gICAgd2l0aFxuICAgIHwgZXhuIC0+XG4gICAgICByYWlzZV9zIFslbWVzc2FnZSBcIlBpcGUuQmxvY2tlZF9yZWFkLmludmFyaWFudCBmYWlsZWRcIiAoZXhuIDogZXhuKSB+cGlwZToodCA6IF8gdCldXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSB3YW50cyBjb25zdW1lciA9IHsgd2FudHM7IGNvbnN1bWVyIH1cblxuICBsZXQgaXNfZW1wdHkgdCA9XG4gICAgbWF0Y2ggdC53YW50cyB3aXRoXG4gICAgfCBaZXJvIGkgLT4gSXZhci5pc19lbXB0eSBpXG4gICAgfCBPbmUgaSAtPiBJdmFyLmlzX2VtcHR5IGlcbiAgICB8IEF0X21vc3QgKF8sIGkpIC0+IEl2YXIuaXNfZW1wdHkgaVxuICA7O1xuXG4gIGxldCBmaWxsX3dpdGhfZW9mIHQgPVxuICAgIG1hdGNoIHQud2FudHMgd2l0aFxuICAgIHwgWmVybyBpIC0+IEl2YXIuZmlsbF9leG4gaSBgRW9mXG4gICAgfCBPbmUgaSAtPiBJdmFyLmZpbGxfZXhuIGkgYEVvZlxuICAgIHwgQXRfbW9zdCAoXywgaSkgLT4gSXZhci5maWxsX2V4biBpIGBFb2ZcbiAgOztcbmVuZFxuXG5tb2R1bGUgQmxvY2tlZF9mbHVzaCA9IHN0cnVjdFxuICAoKiBBIFtCbG9ja2VkX2ZsdXNoLnRdIHJlcHJlc2VudHMgYSBibG9ja2VkIGZsdXNoIG9wZXJhdGlvbiwgd2hpY2ggY2FuIGJlIGVuYWJsZWQgYnkgYVxuICAgICBmdXR1cmUgcmVhZC4gIElmIHNvbWVvbmUgZG9lcyBbZmx1c2hlZCBwXSBvbiBhIHBpcGUsIHRoYXQgYmxvY2tzIHVudGlsIGV2ZXJ5dGhpbmdcbiAgICAgdGhhdCdzIGN1cnJlbnRseSBpbiB0aGUgcGlwZSBhdCB0aGF0IHBvaW50IGhhcyBkcmFpbmVkIG91dCBvZiB0aGUgcGlwZS4gIFdoZW4gd2UgY2FsbFxuICAgICBbZmx1c2hlZF0sIGl0IHJlY29yZHMgdGhlIHRvdGFsIGFtb3VudCBvZiBkYXRhIHRoYXQgaGFzIGJlZW4gd3JpdHRlbiBzbyBmYXIgaW5cbiAgICAgW2ZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWRdLiAgV2UgZmlsbCB0aGUgW0ZsdXNoLnRdIHdpdGggW2BPa10gd2hlbiB0aGlzIGFtb3VudCBvZlxuICAgICBkYXRhIGhhcyBiZWVuIHJlYWQgZnJvbSB0aGUgcGlwZS5cblxuICAgICBBIFtCbG9ja2VkX2ZsdXNoLnRdIGNhbiBhbHNvIGJlIGZpbGxlZCB3aXRoIFtgUmVhZGVyX2Nsb3NlZF0sIHdoaWNoIGhhcHBlbnMgd2hlbiB0aGVcbiAgICAgcmVhZGVyIGVuZCBvZiB0aGUgcGlwZSBpcyBjbG9zZWQsIGFuZCB3ZSBhcmUgdGh1cyBzdXJlIHRoYXQgdGhlIHVucmVhZCBlbGVtZW50cyBwcmVjZWRpbmcgdGhlIGZsdXNoIHdpbGwgbmV2ZXIgYmUgcmVhZC4gKilcbiAgdHlwZSB0ID1cbiAgICB7IGZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQgOiBpbnRcbiAgICA7IHJlYWR5IDogWyBgT2sgfCBgUmVhZGVyX2Nsb3NlZCBdIEl2YXIudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzIH5nZXR0ZXJzLCBzZXhwX29mXVxuXG4gIGxldCBmaWxsIHQgdiA9IEl2YXIuZmlsbF9leG4gdC5yZWFkeSB2XG5lbmRcblxudHlwZSAoJ2EsICdwaGFudG9tKSB0ID1cbiAgeyAoKiBbaWRdIGlzIGFuIGludGVnZXIgdXNlZCB0byBkaXN0aW5ndWlzaCBwaXBlcyB3aGVuIGRlYnVnZ2luZy4gKilcbiAgICBpZCA6IGludCBTZXhwX2hpZGRlbl9pbl90ZXN0LnRcbiAgOyAoKiBbaW5mb10gaXMgdXNlci1wcm92aWRlZCBhcmJpdHJhcnkgc2V4cCwgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy4gKilcbiAgICBtdXRhYmxlIGluZm8gOiBTZXhwLnQgb3B0aW9uIFtAc2V4cC5vcHRpb25dXG4gIDsgKCogW2J1ZmZlcl0gaG9sZHMgdmFsdWVzIHdyaXR0ZW4gdG8gdGhlIHBpcGUgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiByZWFkLiAqKVxuICAgIG11dGFibGUgYnVmZmVyIDogJ2EgUXVldWUudFxuICA7ICgqIFtzaXplX2J1ZGdldF0gZ292ZXJucyBwdXNoYmFjayBvbiB3cml0ZXJzIHRvIHRoZSBwaXBlLlxuXG4gICAgICAgVGhlcmUgaXMgKm5vKiBpbnZhcmlhbnQgdGhhdCBbUXVldWUubGVuZ3RoIGJ1ZmZlciA8PSBzaXplX2J1ZGdldF0uXG4gICAgICAgVGhlcmUgaXMgbm8gaGFyZCB1cHBlciBib3VuZCBvbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRoYXQgY2FuIGJlIHN0dWZmZWQgaW50byB0aGVcbiAgICAgICBbYnVmZmVyXS4gVGhpcyBpcyBkdWUgdG8gdGhlIHdheSB3ZSBoYW5kbGUgd3JpdGVzLiBXaGVuIHdlIGRvIGEgd3JpdGUsIGFsbCBvZiB0aGVcbiAgICAgICB2YWx1ZXMgd3JpdHRlbiBhcmUgaW1tZWRpYXRlbHkgZW5xdWV1ZWQgaW50byBbYnVmZmVyXS4gQWZ0ZXIgdGhlIHdyaXRlLCBpZlxuICAgICAgIFtRdWV1ZS5sZW5ndGggYnVmZmVyIDw9IHQuc2l6ZV9idWRnZXRdLCB0aGVuIHRoZSB3cml0ZXIgd2lsbCBiZSBub3RpZmllZCB0b1xuICAgICAgIGNvbnRpbnVlIHdyaXRpbmcuIEFmdGVyIHRoZSB3cml0ZSwgaWYgW2xlbmd0aCB0ID4gdC5zaXplX2J1ZGdldF0sIHRoZW4gdGhlIHdyaXRlXG4gICAgICAgd2lsbCBibG9jayB1bnRpbCB0aGUgcGlwZSBpcyB1bmRlciBidWRnZXQuICopXG4gICAgbXV0YWJsZSBzaXplX2J1ZGdldCA6IGludFxuICA7ICgqIFtyZXNlcnZlZF9zcGFjZV0gY291bnRzIGFnYWluc3QgW3NpemVfYnVkZ2V0XSB3aXRob3V0IGFjdHVhbGx5IGJ1ZmZlcmluZyBhbnl0aGluZ1xuICAgICAgIHlldC4gV2hlbiBpdCdzIHBvc2l0aXZlLCB3cml0ZXMgZGVjcmVtZW50IGl0LiAqKVxuICAgIG11dGFibGUgcmVzZXJ2ZWRfc3BhY2UgOiBpbnRcbiAgOyAoKiBbcHVzaGJhY2tdIGlzIHVzZWQgdG8gZ2l2ZSBmZWVkYmFjayB0byB3cml0ZXJzIGFib3V0IHdoZXRoZXIgdGhleSBzaG91bGQgd3JpdGUgdG9cbiAgICAgICB0aGUgcGlwZS4gW3B1c2hiYWNrXSBpcyBmdWxsIGlmZiBbbGVuZ3RoIHQgKyByZXNlcnZlZF9zcGFjZSB0IDw9IHQuc2l6ZV9idWRnZXQgfHxcbiAgICAgICBpc19jbG9zZWQgdF0uICopXG4gICAgbXV0YWJsZSBwdXNoYmFjayA6IHVuaXQgSXZhci50XG4gIDsgKCogW251bV92YWx1ZXNfcmVhZF0ga2VlcHMgdHJhY2sgb2YgdGhlIHRvdGFsIG51bWJlciBvZiB2YWx1ZXMgdGhhdCBoYXZlIGJlZW4gcmVhZFxuICAgICAgIGZyb20gdGhlIHBpcGUuICBXZSBkbyBub3QgaGF2ZSB0byB3b3JyeSBhYm91dCBvdmVyZmxvdyBpbiBbbnVtX3ZhbHVlc19yZWFkXS4gIFlvdSdkXG4gICAgICAgbmVlZCB0byB3cml0ZSAyXjYyIGVsZW1lbnRzIHRvIHRoZSBwaXBlLCB3aGljaCB3b3VsZCB0YWtlIGFib3V0IDE0NiB5ZWFycywgYXQgYVxuICAgICAgIGZsb3cgcmF0ZSBvZiAxIHNpemUtdW5pdC9uYW5vc2Vjb25kLiAqKVxuICAgIG11dGFibGUgbnVtX3ZhbHVlc19yZWFkIDogaW50XG4gICAgICAoKiBbYmxvY2tlZF9mbHVzaGVzXSBob2xkcyBmbHVzaGVzIHdob3NlIHByZWNlZGluZyBlbGVtZW50cyBoYXZlIG5vdCBiZWVuIGNvbXBsZXRlbHlcbiAgICAgcmVhZC4gIEZvciBlYWNoIGJsb2NrZWQgZmx1c2gsIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGJlIHJlYWQgZnJvbSB0aGVcbiAgICAgcGlwZSBpbiBvcmRlciB0byBmaWxsIHRoZSBmbHVzaCBpcyAgICAgICAgICAgICAgICAgICAgICAgIDpcblxuICAgICBmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkIC0gbnVtX3ZhbHVlc19yZWFkXG5cbiAgICAgS2VlcGluZyB0aGUgZGF0YSBpbiB0aGlzIGZvcm0gYWxsb3dzIHVzIHRvIGNoYW5nZSBhIHNpbmdsZSBmaWVsZChudW1fdmFsdWVzX3JlYWQpXG4gICAgIHdoZW4gd2UgY29uc3VtZSB2YWx1ZXMgaW5zdGVhZCBvZiBoYXZpbmcgdG8gaXRlcmF0ZSBvdmVyIHRoZSB3aG9sZSBxdWV1ZSBvZlxuICAgICBmbHVzaGVzLiAqKVxuICA7IGJsb2NrZWRfZmx1c2hlcyA6IEJsb2NrZWRfZmx1c2gudCBRdWV1ZS50XG4gIDsgKCogW2Jsb2NrZWRfcmVhZHNdIGhvbGRzIHJlYWRzIHRoYXQgYXJlIHdhaXRpbmcgb24gZGF0YSB0byBiZSB3cml0dGVuIHRvIHRoZSBwaXBlLiAqKVxuICAgIGJsb2NrZWRfcmVhZHMgOiAnYSBCbG9ja2VkX3JlYWQudCBRdWV1ZS50XG4gIDsgKCogW2Nsb3NlZF0gaXMgZmlsbGVkIHdoZW4gd2UgY2xvc2UgdGhlIHdyaXRlIGVuZCBvZiB0aGUgcGlwZS4gKilcbiAgICBjbG9zZWQgOiB1bml0IEl2YXIudFxuICA7ICgqIFtyZWFkX2Nsb3NlZF0gaXMgZmlsbGVkIHdoZW4gd2UgY2xvc2UgdGhlIHJlYWQgZW5kIG9mIHRoZSBwaXBlLiAqKVxuICAgIHJlYWRfY2xvc2VkIDogdW5pdCBJdmFyLnRcbiAgOyAoKiBbY29uc3VtZXJzXSBpcyBhIGxpc3Qgb2YgYWxsIGNvbnN1bWVycyB0aGF0IG1heSBiZSBoYW5kbGluZyB2YWx1ZXMgcmVhZCBmcm9tIHRoZVxuICAgICAgIHBpcGUuICopXG4gICAgbXV0YWJsZSBjb25zdW1lcnMgOiBDb25zdW1lci50IGxpc3RcbiAgOyAoKiBbdXBzdHJlYW1fZmx1c2hlZHNdIGhhcyBhIGZ1bmN0aW9uIGZvciBlYWNoIHBpcGUgaW1tZWRpYXRlbHkgdXBzdHJlYW0gb2YgdGhpcyBvbmUuXG4gICAgICAgVGhhdCBmdW5jdGlvbiB3YWxrcyB0byB0aGUgaGVhZChzKSBvZiB0aGUgdXBzdHJlYW0gcGlwZSwgYW5kIGNhbGxzXG4gICAgICAgW2Rvd25zdHJlYW1fZmx1c2hlZF0gb24gdGhlIGhlYWQocykuICBTZWUgdGhlIGRlZmluaXRpb24gb2YgW3Vwc3RyZWFtX2ZsdXNoZWRdXG4gICAgICAgYmVsb3cuICopXG4gICAgdXBzdHJlYW1fZmx1c2hlZHMgOiAodW5pdCAtPiBGbHVzaGVkX3Jlc3VsdC50IERlZmVycmVkLnQpIEJhZy50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+Z2V0dGVycyB+c2V0dGVycyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbmxldCBlZmZlY3RpdmVfc2l6ZV9idWRnZXQgdCA9IHQuc2l6ZV9idWRnZXQgLSB0LnJlc2VydmVkX3NwYWNlXG5cbnR5cGUgKCdhLCAncGhhbnRvbSkgcGlwZSA9ICgnYSwgJ3BoYW50b20pIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGhhc2ggdCA9IEhhc2h0YmwuaGFzaCB0LmlkXG5sZXQgZXF1YWwgKHQxIDogKF8sIF8pIHQpIHQyID0gcGh5c19lcXVhbCB0MSB0MlxubGV0IGNvbXBhcmUgdDEgdDIgPSBJbnQuY29tcGFyZSB0MS5pZCB0Mi5pZFxubGV0IGlzX2Nsb3NlZCB0ID0gSXZhci5pc19mdWxsIHQuY2xvc2VkXG5sZXQgaXNfcmVhZF9jbG9zZWQgdCA9IEl2YXIuaXNfZnVsbCB0LnJlYWRfY2xvc2VkXG5sZXQgY2xvc2VkIHQgPSBJdmFyLnJlYWQgdC5jbG9zZWRcbmxldCBwdXNoYmFjayB0ID0gSXZhci5yZWFkIHQucHVzaGJhY2tcbmxldCBsZW5ndGggdCA9IFF1ZXVlLmxlbmd0aCB0LmJ1ZmZlclxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcbmxldCBudW1fdmFsdWVzX3dyaXR0ZW4gdCA9IGxlbmd0aCB0ICsgbnVtX3ZhbHVlc19yZWFkIHRcbmxldCB1cGRhdGVfbnVtX3ZhbHVlc19yZWFkIHQgfmRlbHRhID0gdC5udW1fdmFsdWVzX3JlYWQgPC0gdC5udW1fdmFsdWVzX3JlYWQgKyBkZWx0YVxuXG5sZXQgaW52YXJpYW50IHQgOiB1bml0ID1cbiAgdHJ5XG4gICAgbGV0IGNoZWNrIGYgZmllbGQgPSBmIChGaWVsZC5nZXQgZmllbGQgdCkgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfmlkOmlnbm9yZVxuICAgICAgfmluZm86aWdub3JlXG4gICAgICB+YnVmZmVyOmlnbm9yZVxuICAgICAgfnNpemVfYnVkZ2V0OihjaGVjayAoZnVuIHNpemVfYnVkZ2V0IC0+IGFzc2VydCAoc2l6ZV9idWRnZXQgPj0gMCkpKVxuICAgICAgfnJlc2VydmVkX3NwYWNlOihjaGVjayAoZnVuIHJlc2VydmVkX3NwYWNlIC0+IGFzc2VydCAocmVzZXJ2ZWRfc3BhY2UgPj0gMCkpKVxuICAgICAgfnB1c2hiYWNrOlxuICAgICAgICAoY2hlY2sgKGZ1biBwdXNoYmFjayAtPlxuICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgIEJvb2wuZXF1YWxcbiAgICAgICAgICAgICAgIChJdmFyLmlzX2Z1bGwgcHVzaGJhY2spXG4gICAgICAgICAgICAgICAobGVuZ3RoIHQgPD0gZWZmZWN0aXZlX3NpemVfYnVkZ2V0IHQgfHwgaXNfY2xvc2VkIHQpKSkpXG4gICAgICB+bnVtX3ZhbHVlc19yZWFkOmlnbm9yZVxuICAgICAgfmJsb2NrZWRfZmx1c2hlczpcbiAgICAgICAgKGNoZWNrIChmdW4gYmxvY2tlZF9mbHVzaGVzIC0+XG4gICAgICAgICAgIFF1ZXVlLml0ZXIgYmxvY2tlZF9mbHVzaGVzIH5mOihmdW4gKGYgOiBCbG9ja2VkX2ZsdXNoLnQpIC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChmLmZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQgPiB0Lm51bV92YWx1ZXNfcmVhZCkpO1xuICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgIExpc3QuaXNfc29ydGVkXG4gICAgICAgICAgICAgICB+Y29tcGFyZTpJbnQuY29tcGFyZVxuICAgICAgICAgICAgICAgKExpc3QubWFwXG4gICAgICAgICAgICAgICAgICAoUXVldWUudG9fbGlzdCBibG9ja2VkX2ZsdXNoZXMpXG4gICAgICAgICAgICAgICAgICB+ZjpCbG9ja2VkX2ZsdXNoLmZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQpKTtcbiAgICAgICAgICAgaWYgaXNfZW1wdHkgdCB0aGVuIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgYmxvY2tlZF9mbHVzaGVzKSkpXG4gICAgICB+YmxvY2tlZF9yZWFkczpcbiAgICAgICAgKGNoZWNrIChmdW4gYmxvY2tlZF9yZWFkcyAtPlxuICAgICAgICAgICAoKiBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgbm8gb25lIGlzIHdhaXRpbmcgZm9yIGl0LiAgVGhpcyB3b3VsZCBuZWVkIHRvIGNoYW5nZSBpZlxuICAgICAgICAgICAgICB3ZSBldmVyIGltcGxlbWVudCBbcmVhZF9leGFjdGx5XSBhcyBhbiBhdG9taWMgb3BlcmF0aW9uLiAqKVxuICAgICAgICAgICBpZiBub3QgKGlzX2VtcHR5IHQpIHRoZW4gYXNzZXJ0IChRdWV1ZS5pc19lbXB0eSBibG9ja2VkX3JlYWRzKTtcbiAgICAgICAgICAgUXVldWUuaXRlciBibG9ja2VkX3JlYWRzIH5mOihmdW4gcmVhZCAtPlxuICAgICAgICAgICAgIEJsb2NrZWRfcmVhZC5pbnZhcmlhbnQgcmVhZDtcbiAgICAgICAgICAgICBhc3NlcnQgKEJsb2NrZWRfcmVhZC5pc19lbXB0eSByZWFkKSk7XG4gICAgICAgICAgICgqIFlvdSBuZXZlciBibG9jayB0cnlpbmcgdG8gcmVhZCBhIGNsb3NlZCBwaXBlLiAqKVxuICAgICAgICAgICBpZiBpc19jbG9zZWQgdCB0aGVuIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgYmxvY2tlZF9yZWFkcykpKVxuICAgICAgfmNsb3NlZDppZ25vcmVcbiAgICAgIH5yZWFkX2Nsb3NlZDppZ25vcmVcbiAgICAgIH5jb25zdW1lcnM6XG4gICAgICAgIChjaGVjayAoZnVuIGwgLT5cbiAgICAgICAgICAgTGlzdC5pdGVyIGwgfmY6KGZ1biBjb25zdW1lciAtPlxuICAgICAgICAgICAgIENvbnN1bWVyLmludmFyaWFudCBjb25zdW1lcjtcbiAgICAgICAgICAgICBhc3NlcnQgKENvbnN1bWVyLnBpcGVfaWQgY29uc3VtZXIgPSB0LmlkKSkpKVxuICAgICAgfnVwc3RyZWFtX2ZsdXNoZWRzOmlnbm9yZVxuICB3aXRoXG4gIHwgZXhuIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiUGlwZS5pbnZhcmlhbnQgZmFpbGVkXCIgKGV4biA6IGV4bikgfnBpcGU6KHQgOiAoXywgXykgdCldXG47O1xuXG5tb2R1bGUgUmVhZGVyID0gc3RydWN0XG4gIHR5cGUgcGhhbnRvbSBbQEBkZXJpdmluZyBzZXhwX29mXVxuICB0eXBlICdhIHQgPSAoJ2EsIHBoYW50b20pIHBpcGUgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG5lbmRcblxubW9kdWxlIFdyaXRlciA9IHN0cnVjdFxuICB0eXBlIHBoYW50b20gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAnYSB0ID0gKCdhLCBwaGFudG9tKSBwaXBlIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuZW5kXG5cbmxldCBpZF9yZWYgPSByZWYgMFxuXG5sZXQgY3JlYXRlX2ludGVybmFsIH5zaXplX2J1ZGdldCB+aW5mbyB+aW5pdGlhbF9idWZmZXIgPVxuICBpbmNyIGlkX3JlZjtcbiAgbGV0IHQgPVxuICAgIHsgaWQgPSAhaWRfcmVmXG4gICAgOyBpbmZvXG4gICAgOyBjbG9zZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgIDsgcmVhZF9jbG9zZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgIDsgc2l6ZV9idWRnZXRcbiAgICA7IHJlc2VydmVkX3NwYWNlID0gMFxuICAgIDsgcHVzaGJhY2sgPSBJdmFyLmNyZWF0ZSAoKVxuICAgIDsgYnVmZmVyID0gaW5pdGlhbF9idWZmZXJcbiAgICA7IG51bV92YWx1ZXNfcmVhZCA9IDBcbiAgICA7IGJsb2NrZWRfZmx1c2hlcyA9IFF1ZXVlLmNyZWF0ZSAoKVxuICAgIDsgYmxvY2tlZF9yZWFkcyA9IFF1ZXVlLmNyZWF0ZSAoKVxuICAgIDsgY29uc3VtZXJzID0gW11cbiAgICA7IHVwc3RyZWFtX2ZsdXNoZWRzID0gQmFnLmNyZWF0ZSAoKVxuICAgIH1cbiAgaW5cbiAgdFxuOztcblxubGV0IHZhbGlkYXRlX3NpemVfYnVkZ2V0IHNpemVfYnVkZ2V0ID1cbiAgaWYgc2l6ZV9idWRnZXQgPCAwXG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJuZWdhdGl2ZSBzaXplX2J1ZGdldFwiIChzaXplX2J1ZGdldCA6IGludCldXG4gIGVsc2Ugc2l6ZV9idWRnZXRcbjs7XG5cbmxldCBjcmVhdGUgP3NpemVfYnVkZ2V0ID9pbmZvICgpID1cbiAgbGV0IHNpemVfYnVkZ2V0ID1cbiAgICBtYXRjaCBzaXplX2J1ZGdldCB3aXRoXG4gICAgfCBTb21lIHYgLT4gdmFsaWRhdGVfc2l6ZV9idWRnZXQgdlxuICAgIHwgTm9uZSAtPiAwXG4gIGluXG4gIGxldCB0ID0gY3JlYXRlX2ludGVybmFsIH5zaXplX2J1ZGdldCB+aW5mbyB+aW5pdGlhbF9idWZmZXI6KFF1ZXVlLmNyZWF0ZSAoKSkgaW5cbiAgKCogaW5pdGlhbGx5LCB0aGUgcGlwZSBkb2VzIG5vdCBwdXNoYmFjayAqKVxuICBJdmFyLmZpbGxfZXhuIHQucHVzaGJhY2sgKCk7XG4gIGlmICFjaGVja19pbnZhcmlhbnQgdGhlbiBpbnZhcmlhbnQgdDtcbiAgdCwgdFxuOztcblxubGV0IHVwZGF0ZV9wdXNoYmFjayB0ID1cbiAgaWYgbGVuZ3RoIHQgPD0gZWZmZWN0aXZlX3NpemVfYnVkZ2V0IHQgfHwgaXNfY2xvc2VkIHRcbiAgdGhlbiBJdmFyLmZpbGxfaWZfZW1wdHkgdC5wdXNoYmFjayAoKVxuICBlbHNlIGlmIEl2YXIuaXNfZnVsbCB0LnB1c2hiYWNrXG4gIHRoZW4gdC5wdXNoYmFjayA8LSBJdmFyLmNyZWF0ZSAoKVxuOztcblxubGV0IGNsb3NlIHQgPVxuICBpZiAhc2hvd19kZWJ1Z19tZXNzYWdlcyB0aGVuIGVwcmludHMgXCJjbG9zZVwiIHQgWyVzZXhwX29mOiAoXywgXykgdF07XG4gIGlmICFjaGVja19pbnZhcmlhbnQgdGhlbiBpbnZhcmlhbnQgdDtcbiAgaWYgbm90IChpc19jbG9zZWQgdClcbiAgdGhlbiAoXG4gICAgSXZhci5maWxsX2V4biB0LmNsb3NlZCAoKTtcbiAgICBpZiBpc19lbXB0eSB0XG4gICAgdGhlbiAoXG4gICAgICBRdWV1ZS5pdGVyIHQuYmxvY2tlZF9yZWFkcyB+ZjpCbG9ja2VkX3JlYWQuZmlsbF93aXRoX2VvZjtcbiAgICAgIFF1ZXVlLmNsZWFyIHQuYmxvY2tlZF9yZWFkcyk7XG4gICAgdXBkYXRlX3B1c2hiYWNrIHQpXG47O1xuXG5sZXQgY2xvc2VfcmVhZCB0ID1cbiAgaWYgIXNob3dfZGVidWdfbWVzc2FnZXMgdGhlbiBlcHJpbnRzIFwiY2xvc2VfcmVhZFwiIHQgWyVzZXhwX29mOiAoXywgXykgdF07XG4gIGlmICFjaGVja19pbnZhcmlhbnQgdGhlbiBpbnZhcmlhbnQgdDtcbiAgaWYgbm90IChpc19yZWFkX2Nsb3NlZCB0KVxuICB0aGVuIChcbiAgICBJdmFyLmZpbGxfZXhuIHQucmVhZF9jbG9zZWQgKCk7XG4gICAgUXVldWUuaXRlciB0LmJsb2NrZWRfZmx1c2hlcyB+ZjooZnVuIGZsdXNoIC0+IEJsb2NrZWRfZmx1c2guZmlsbCBmbHVzaCBgUmVhZGVyX2Nsb3NlZCk7XG4gICAgUXVldWUuY2xlYXIgdC5ibG9ja2VkX2ZsdXNoZXM7XG4gICAgUXVldWUuY2xlYXIgdC5idWZmZXI7XG4gICAgdC5yZXNlcnZlZF9zcGFjZSA8LSAwO1xuICAgIHVwZGF0ZV9wdXNoYmFjayB0O1xuICAgICgqIHdlIGp1c3QgY2xlYXJlZCB0aGUgYnVmZmVyLCBzbyBtYXkgbmVlZCB0byBmaWxsIFt0LnB1c2hiYWNrXSAqKVxuICAgIGNsb3NlIHQpXG47O1xuXG5sZXQgY3JlYXRlX3JlYWRlcl9ub3RfY2xvc2Vfb25fZXhjZXB0aW9uID9zaXplX2J1ZGdldCBmID1cbiAgbGV0IHIsIHcgPSBjcmVhdGUgP3NpemVfYnVkZ2V0ICgpIGluXG4gIHVwb24gKGYgdykgKGZ1biAoKSAtPiBjbG9zZSB3KTtcbiAgclxuOztcblxubGV0IGNyZWF0ZV9yZWFkZXIgP3NpemVfYnVkZ2V0IH5jbG9zZV9vbl9leGNlcHRpb24gZiA9XG4gIGlmIG5vdCBjbG9zZV9vbl9leGNlcHRpb25cbiAgdGhlbiBjcmVhdGVfcmVhZGVyX25vdF9jbG9zZV9vbl9leGNlcHRpb24gP3NpemVfYnVkZ2V0IGZcbiAgZWxzZSAoXG4gICAgbGV0IHIsIHcgPSBjcmVhdGUgP3NpemVfYnVkZ2V0ICgpIGluXG4gICAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAgIChNb25pdG9yLnByb3RlY3RcbiAgICAgICAgIChmdW4gKCkgLT4gZiB3KVxuICAgICAgICAgfmZpbmFsbHk6KGZ1biAoKSAtPlxuICAgICAgICAgICBjbG9zZSB3O1xuICAgICAgICAgICByZXR1cm4gKCkpKTtcbiAgICByKVxuOztcblxubGV0IGNyZWF0ZV93cml0ZXIgP3NpemVfYnVkZ2V0IGYgPVxuICBsZXQgciwgdyA9IGNyZWF0ZSA/c2l6ZV9idWRnZXQgKCkgaW5cbiAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAoTW9uaXRvci5wcm90ZWN0XG4gICAgICAgKGZ1biAoKSAtPiBmIHIpXG4gICAgICAgfmZpbmFsbHk6KGZ1biAoKSAtPlxuICAgICAgICAgY2xvc2VfcmVhZCByO1xuICAgICAgICAgcmV0dXJuICgpKSk7XG4gIHdcbjs7XG5cbmxldCBjb25zdW1lZF92YWx1ZXNfc2VudF9kb3duc3RyZWFtX2FuZF9mbHVzaGVkIHQgPVxuICBpZiBMaXN0LmlzX2VtcHR5IHQuY29uc3VtZXJzXG4gIHRoZW4gcmV0dXJuIGBPa1xuICBlbHNlXG4gICAgRmx1c2hlZF9yZXN1bHQuY29tYmluZVxuICAgICAgKExpc3QubWFwIHQuY29uc3VtZXJzIH5mOkNvbnN1bWVyLnZhbHVlc19zZW50X2Rvd25zdHJlYW1fYW5kX2ZsdXNoZWQpXG47O1xuXG5sZXQgZWFnZXJfdXBvbiBkIGYgPVxuICBtYXRjaCBEZWZlcnJlZC5wZWVrIGQgd2l0aFxuICB8IFNvbWUgdiAtPiBmIHZcbiAgfCBOb25lIC0+IHVwb24gZCBmXG47O1xuXG5sZXQgdmFsdWVzX3dlcmVfcmVhZCB0IGNvbnN1bWVyID1cbiAgT3B0aW9uLml0ZXIgY29uc3VtZXIgfmY6Q29uc3VtZXIuc3RhcnQ7XG4gIGxldCB2YWx1ZXNfZmx1c2hlZCA9IGxhenkgKGNvbnN1bWVkX3ZhbHVlc19zZW50X2Rvd25zdHJlYW1fYW5kX2ZsdXNoZWQgdCkgaW5cbiAgUXVldWUuZHJhaW5cbiAgICB0LmJsb2NrZWRfZmx1c2hlc1xuICAgIH53aGlsZV86KGZ1biBmbHVzaCAtPiB0Lm51bV92YWx1ZXNfcmVhZCA+PSBmbHVzaC5maWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkKVxuICAgIH5mOihmdW4gZmx1c2ggLT5cbiAgICAgIGVhZ2VyX3Vwb24gKGZvcmNlIHZhbHVlc19mbHVzaGVkKSAoZnVuIGZsdXNoX3Jlc3VsdCAtPlxuICAgICAgICBCbG9ja2VkX2ZsdXNoLmZpbGwgZmx1c2ggZmx1c2hfcmVzdWx0KSlcbjs7XG5cbigqIFtjb25zdW1lX2FsbCB0XSByZWFkcyBhbGwgdGhlIGVsZW1lbnRzIGluIFt0XS4gKilcbmxldCBjb25zdW1lX2FsbCB0IGNvbnN1bWVyID1cbiAgbGV0IHJlc3VsdCA9IHQuYnVmZmVyIGluXG4gIHQuYnVmZmVyIDwtIFF1ZXVlLmNyZWF0ZSAoKTtcbiAgdXBkYXRlX251bV92YWx1ZXNfcmVhZCB0IH5kZWx0YTooUXVldWUubGVuZ3RoIHJlc3VsdCk7XG4gIHZhbHVlc193ZXJlX3JlYWQgdCBjb25zdW1lcjtcbiAgdXBkYXRlX3B1c2hiYWNrIHQ7XG4gIHJlc3VsdFxuOztcblxubGV0IGNvbnN1bWVfb25lIHQgY29uc3VtZXIgPVxuICBhc3NlcnQgKGxlbmd0aCB0ID49IDEpO1xuICBsZXQgcmVzdWx0ID0gUXVldWUuZGVxdWV1ZV9leG4gdC5idWZmZXIgaW5cbiAgdXBkYXRlX251bV92YWx1ZXNfcmVhZCB0IH5kZWx0YToxO1xuICB2YWx1ZXNfd2VyZV9yZWFkIHQgY29uc3VtZXI7XG4gIHVwZGF0ZV9wdXNoYmFjayB0O1xuICByZXN1bHRcbjs7XG5cbmxldCBjb25zdW1lIHQgfm1heF9xdWV1ZV9sZW5ndGggY29uc3VtZXIgPVxuICBhc3NlcnQgKG1heF9xdWV1ZV9sZW5ndGggPj0gMCk7XG4gIGlmIG1heF9xdWV1ZV9sZW5ndGggPj0gbGVuZ3RoIHRcbiAgdGhlbiBjb25zdW1lX2FsbCB0IGNvbnN1bWVyXG4gIGVsc2UgKFxuICAgIHVwZGF0ZV9udW1fdmFsdWVzX3JlYWQgdCB+ZGVsdGE6bWF4X3F1ZXVlX2xlbmd0aDtcbiAgICB2YWx1ZXNfd2VyZV9yZWFkIHQgY29uc3VtZXI7XG4gICAgbGV0IHJlc3VsdCA9IFF1ZXVlLmNyZWF0ZSB+Y2FwYWNpdHk6bWF4X3F1ZXVlX2xlbmd0aCAoKSBpblxuICAgIFF1ZXVlLmJsaXRfdHJhbnNmZXIgfnNyYzp0LmJ1ZmZlciB+ZHN0OnJlc3VsdCB+bGVuOm1heF9xdWV1ZV9sZW5ndGggKCk7XG4gICAgdXBkYXRlX3B1c2hiYWNrIHQ7XG4gICAgcmVzdWx0KVxuOztcblxubGV0IHNldF9zaXplX2J1ZGdldCB0IHNpemVfYnVkZ2V0ID1cbiAgbGV0IHNpemVfYnVkZ2V0ID0gdmFsaWRhdGVfc2l6ZV9idWRnZXQgc2l6ZV9idWRnZXQgaW5cbiAgdC5zaXplX2J1ZGdldCA8LSBzaXplX2J1ZGdldDtcbiAgdXBkYXRlX3B1c2hiYWNrIHRcbjs7XG5cbmxldCByZXNlcnZlX3NwYWNlIHQgbiA9XG4gIGlmIG4gPCAwIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJyZXNlcnZpbmcgbmVnYXRpdmUgc3BhY2VcIiAobiA6IGludCldO1xuICBsZXQgcmVzZXJ2ZWRfc3BhY2UgPSB0LnJlc2VydmVkX3NwYWNlICsgbiBpblxuICBpZiByZXNlcnZlZF9zcGFjZSA8IDBcbiAgdGhlblxuICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwib3ZlcmZsb3cgd2hlbiByZXNlcnZpbmcgc3BhY2VcIiAodC5yZXNlcnZlZF9zcGFjZSA6IGludCkgKG4gOiBpbnQpXTtcbiAgdC5yZXNlcnZlZF9zcGFjZSA8LSByZXNlcnZlZF9zcGFjZTtcbiAgdXBkYXRlX3B1c2hiYWNrIHRcbjs7XG5cbmxldCBmaWxsX2Jsb2NrZWRfcmVhZHMgdCA9XG4gIHdoaWxlIChub3QgKFF1ZXVlLmlzX2VtcHR5IHQuYmxvY2tlZF9yZWFkcykpICYmIG5vdCAoaXNfZW1wdHkgdCkgZG9cbiAgICBsZXQgYmxvY2tlZF9yZWFkID0gUXVldWUuZGVxdWV1ZV9leG4gdC5ibG9ja2VkX3JlYWRzIGluXG4gICAgbGV0IGNvbnN1bWVyID0gYmxvY2tlZF9yZWFkLmNvbnN1bWVyIGluXG4gICAgbWF0Y2ggYmxvY2tlZF9yZWFkLndhbnRzIHdpdGhcbiAgICB8IFplcm8gaXZhciAtPiBJdmFyLmZpbGxfZXhuIGl2YXIgYE9rXG4gICAgfCBPbmUgaXZhciAtPiBJdmFyLmZpbGxfZXhuIGl2YXIgKGBPayAoY29uc3VtZV9vbmUgdCBjb25zdW1lcikpXG4gICAgfCBBdF9tb3N0IChtYXhfcXVldWVfbGVuZ3RoLCBpdmFyKSAtPlxuICAgICAgSXZhci5maWxsX2V4biBpdmFyIChgT2sgKGNvbnN1bWUgdCB+bWF4X3F1ZXVlX2xlbmd0aCBjb25zdW1lcikpXG4gIGRvbmVcbjs7XG5cbmxldCBkZWNyZWFzZV9yZXNlcnZlZF9zcGFjZSB0IG4gPSB0LnJlc2VydmVkX3NwYWNlIDwtIEludC5tYXggMCAodC5yZXNlcnZlZF9zcGFjZSAtIG4pXG5cbigqIGNoZWNrcyBhbGwgaW52YXJpYW50cywgY2FsbHMgYSBwYXNzZWQgaW4gZiB0byBoYW5kbGUgYSB3cml0ZSwgdGhlbiB1cGRhdGVzIHJlYWRzIGFuZFxuICAgcHVzaGJhY2sgKilcbmxldCBzdGFydF93cml0ZSB0IH5zaXplID1cbiAgaWYgIXNob3dfZGVidWdfbWVzc2FnZXMgdGhlbiBlcHJpbnRzIFwid3JpdGVcIiB0IFslc2V4cF9vZjogKF8sIF8pIHRdO1xuICBpZiAhY2hlY2tfaW52YXJpYW50IHRoZW4gaW52YXJpYW50IHQ7XG4gIGlmIGlzX2Nsb3NlZCB0IHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJ3cml0ZSB0byBjbG9zZWQgcGlwZVwiIH5waXBlOih0IDogKF8sIF8pIHQpXTtcbiAgZGVjcmVhc2VfcmVzZXJ2ZWRfc3BhY2UgdCBzaXplXG47O1xuXG5sZXQgZmluaXNoX3dyaXRlIHQgPVxuICBmaWxsX2Jsb2NrZWRfcmVhZHMgdDtcbiAgdXBkYXRlX3B1c2hiYWNrIHRcbjs7XG5cbmxldCB0cmFuc2Zlcl9pbl93aXRob3V0X3B1c2hiYWNrIHQgfmZyb20gPVxuICBzdGFydF93cml0ZSB0IH5zaXplOihRdWV1ZS5sZW5ndGggZnJvbSk7XG4gIFF1ZXVlLmJsaXRfdHJhbnNmZXIgfnNyYzpmcm9tIH5kc3Q6dC5idWZmZXIgKCk7XG4gIGZpbmlzaF93cml0ZSB0XG47O1xuXG5sZXQgdHJhbnNmZXJfaW4gdCB+ZnJvbSA9XG4gIHRyYW5zZmVyX2luX3dpdGhvdXRfcHVzaGJhY2sgdCB+ZnJvbTtcbiAgcHVzaGJhY2sgdFxuOztcblxubGV0IGNvcHlfaW5fd2l0aG91dF9wdXNoYmFjayB0IH5mcm9tID1cbiAgc3RhcnRfd3JpdGUgdCB+c2l6ZTooUXVldWUubGVuZ3RoIGZyb20pO1xuICBRdWV1ZS5pdGVyIGZyb20gfmY6KGZ1biB4IC0+IFF1ZXVlLmVucXVldWUgdC5idWZmZXIgeCk7XG4gIGZpbmlzaF93cml0ZSB0XG47O1xuXG4oKiBbd3JpdGUnXSBpcyB1c2VkIGludGVybmFsbHkgKilcbmxldCB3cml0ZScgdCBxID0gdHJhbnNmZXJfaW4gdCB+ZnJvbTpxXG5cbmxldCB3cml0ZV93aXRob3V0X3B1c2hiYWNrIHQgdmFsdWUgPVxuICBzdGFydF93cml0ZSB0IH5zaXplOjE7XG4gIFF1ZXVlLmVucXVldWUgdC5idWZmZXIgdmFsdWU7XG4gIGZpbmlzaF93cml0ZSB0XG47O1xuXG5sZXQgd3JpdGUgdCB2YWx1ZSA9XG4gIHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgdCB2YWx1ZTtcbiAgcHVzaGJhY2sgdFxuOztcblxubGV0IHdyaXRlX3doZW5fcmVhZHkgdCB+ZiA9XG4gIGxldCVtYXAgKCkgPSBwdXNoYmFjayB0IGluXG4gIGlmIGlzX2Nsb3NlZCB0IHRoZW4gYENsb3NlZCBlbHNlIGBPayAoZiAoZnVuIHggLT4gd3JpdGVfd2l0aG91dF9wdXNoYmFjayB0IHgpKVxuOztcblxubGV0IHdyaXRlX2lmX29wZW4gdCB4ID0gaWYgbm90IChpc19jbG9zZWQgdCkgdGhlbiB3cml0ZSB0IHggZWxzZSByZXR1cm4gKClcblxubGV0IHdyaXRlX3dpdGhvdXRfcHVzaGJhY2tfaWZfb3BlbiB0IHggPVxuICBpZiBub3QgKGlzX2Nsb3NlZCB0KSB0aGVuIHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgdCB4XG47O1xuXG5sZXQgZW5zdXJlX2NvbnN1bWVyX21hdGNoZXMgP2NvbnN1bWVyIHQgPVxuICBtYXRjaCBjb25zdW1lciB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgY29uc3VtZXIgLT5cbiAgICBpZiB0LmlkIDw+IENvbnN1bWVyLnBpcGVfaWQgY29uc3VtZXJcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiQXR0ZW1wdCB0byB1c2UgY29uc3VtZXIgd2l0aCB3cm9uZyBwaXBlXCJcbiAgICAgICAgICAgIChjb25zdW1lciA6IENvbnN1bWVyLnQpXG4gICAgICAgICAgICB+cGlwZToodCA6IF8gUmVhZGVyLnQpXVxuOztcblxubGV0IHN0YXJ0X3JlYWQgP2NvbnN1bWVyIHQgbGFiZWwgPVxuICBpZiAhc2hvd19kZWJ1Z19tZXNzYWdlcyB0aGVuIGVwcmludHMgbGFiZWwgdCBbJXNleHBfb2Y6IChfLCBfKSB0XTtcbiAgaWYgIWNoZWNrX2ludmFyaWFudCB0aGVuIGludmFyaWFudCB0O1xuICBlbnN1cmVfY29uc3VtZXJfbWF0Y2hlcyB0ID9jb25zdW1lclxuOztcblxubGV0IGdlbl9yZWFkX25vdyA/Y29uc3VtZXIgdCBjb25zdW1lID1cbiAgc3RhcnRfcmVhZCB0IFwicmVhZF9ub3dcIiA/Y29uc3VtZXI7XG4gIGlmIGlzX2VtcHR5IHRcbiAgdGhlbiBpZiBpc19jbG9zZWQgdCB0aGVuIGBFb2YgZWxzZSBgTm90aGluZ19hdmFpbGFibGVcbiAgZWxzZSAoXG4gICAgYXNzZXJ0IChRdWV1ZS5pc19lbXB0eSB0LmJsb2NrZWRfcmVhZHMpO1xuICAgICgqIGZyb20gW2ludmFyaWFudF0gYW5kIFtub3QgKGlzX2VtcHR5IHQpXSAqKVxuICAgIGBPayAoY29uc3VtZSB0IGNvbnN1bWVyKSlcbjs7XG5cbmxldCBnZXRfbWF4X3F1ZXVlX2xlbmd0aCB+bWF4X3F1ZXVlX2xlbmd0aCA9XG4gIG1hdGNoIG1heF9xdWV1ZV9sZW5ndGggd2l0aFxuICB8IE5vbmUgLT4gSW50Lm1heF92YWx1ZVxuICB8IFNvbWUgbWF4X3F1ZXVlX2xlbmd0aCAtPlxuICAgIGlmIG1heF9xdWV1ZV9sZW5ndGggPD0gMFxuICAgIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJtYXhfcXVldWVfbGVuZ3RoIDw9IDBcIiAobWF4X3F1ZXVlX2xlbmd0aCA6IGludCldO1xuICAgIG1heF9xdWV1ZV9sZW5ndGhcbjs7XG5cbmxldCByZWFkX25vdycgP2NvbnN1bWVyID9tYXhfcXVldWVfbGVuZ3RoIHQgPVxuICBsZXQgbWF4X3F1ZXVlX2xlbmd0aCA9IGdldF9tYXhfcXVldWVfbGVuZ3RoIH5tYXhfcXVldWVfbGVuZ3RoIGluXG4gIGdlbl9yZWFkX25vdyB0ID9jb25zdW1lciAoZnVuIHQgY29uc3VtZXIgLT4gY29uc3VtZSB0IH5tYXhfcXVldWVfbGVuZ3RoIGNvbnN1bWVyKVxuOztcblxubGV0IHJlYWRfbm93ID9jb25zdW1lciB0ID0gZ2VuX3JlYWRfbm93IHQgP2NvbnN1bWVyIGNvbnN1bWVfb25lXG5cbmxldCByZWFkX25vd19leG4gP2NvbnN1bWVyIHQgPVxuICBtYXRjaCByZWFkX25vdyA/Y29uc3VtZXIgdCB3aXRoXG4gIHwgYE9rIGEgLT4gYVxuICB8IGBFb2YgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJQaXBlLnJlYWRfbm93X2V4bjogcmVjZWl2ZWQgRU9GXCJdXG4gIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiUGlwZS5yZWFkX25vd19leG46IG5vdGhpbmcgYXZhaWxhYmxlXCJdXG47O1xuXG5sZXQgcGVlayB0ID0gUXVldWUucGVlayB0LmJ1ZmZlclxuXG5sZXQgY2xlYXIgdCA9XG4gIG1hdGNoIHJlYWRfbm93JyB0IHdpdGhcbiAgfCBgRW9mIHwgYE5vdGhpbmdfYXZhaWxhYmxlIHwgYE9rIF8gLT4gKClcbjs7XG5cbmxldCByZWFkJyA/Y29uc3VtZXIgP21heF9xdWV1ZV9sZW5ndGggdCA9XG4gIGxldCBtYXhfcXVldWVfbGVuZ3RoID0gZ2V0X21heF9xdWV1ZV9sZW5ndGggfm1heF9xdWV1ZV9sZW5ndGggaW5cbiAgc3RhcnRfcmVhZCB0IFwicmVhZCdcIiA/Y29uc3VtZXI7XG4gIG1hdGNoIHJlYWRfbm93JyB0ID9jb25zdW1lciB+bWF4X3F1ZXVlX2xlbmd0aCB3aXRoXG4gIHwgKGBPayBfIHwgYEVvZikgYXMgciAtPiByZXR1cm4gclxuICB8IGBOb3RoaW5nX2F2YWlsYWJsZSAtPlxuICAgIERlZmVycmVkLmNyZWF0ZSAoZnVuIGl2YXIgLT5cbiAgICAgIFF1ZXVlLmVucXVldWVcbiAgICAgICAgdC5ibG9ja2VkX3JlYWRzXG4gICAgICAgIChCbG9ja2VkX3JlYWQuY3JlYXRlIChBdF9tb3N0IChtYXhfcXVldWVfbGVuZ3RoLCBpdmFyKSkgY29uc3VtZXIpKVxuOztcblxubGV0IHJlYWQgP2NvbnN1bWVyIHQgPVxuICBzdGFydF9yZWFkIHQgXCJyZWFkXCIgP2NvbnN1bWVyO1xuICBpZiBpc19lbXB0eSB0XG4gIHRoZW5cbiAgICBpZiBpc19jbG9zZWQgdFxuICAgIHRoZW4gcmV0dXJuIGBFb2ZcbiAgICBlbHNlXG4gICAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+XG4gICAgICAgIFF1ZXVlLmVucXVldWUgdC5ibG9ja2VkX3JlYWRzIChCbG9ja2VkX3JlYWQuKGNyZWF0ZSAoT25lIGl2YXIpKSBjb25zdW1lcikpXG4gIGVsc2UgKFxuICAgIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgdC5ibG9ja2VkX3JlYWRzKTtcbiAgICByZXR1cm4gKGBPayAoY29uc3VtZV9vbmUgdCBjb25zdW1lcikpKVxuOztcblxubGV0IHJlYWRfZXhuID9jb25zdW1lciB0ID1cbiAgbWF0Y2glbWFwIHJlYWQgP2NvbnN1bWVyIHQgd2l0aFxuICB8IGBPayB2YWx1ZSAtPiB2YWx1ZVxuICB8IGBFb2YgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJQaXBlLnJlYWRfZXhuOiByZWNlaXZlZCBFT0ZcIl1cbjs7XG5cbmxldCB2YWx1ZXNfYXZhaWxhYmxlIHQgPVxuICBzdGFydF9yZWFkIHQgXCJ2YWx1ZXNfYXZhaWxhYmxlXCI7XG4gIGlmIG5vdCAoaXNfZW1wdHkgdClcbiAgdGhlbiByZXR1cm4gYE9rXG4gIGVsc2UgaWYgaXNfY2xvc2VkIHRcbiAgdGhlbiByZXR1cm4gYEVvZlxuICBlbHNlIChcbiAgICBtYXRjaCBRdWV1ZS5sYXN0IHQuYmxvY2tlZF9yZWFkcyB3aXRoXG4gICAgfCBTb21lIHsgY29uc3VtZXIgPSBOb25lOyB3YW50cyA9IFplcm8gaXZhciB9IC0+XG4gICAgICAoKiBUaGlzIGNhc2UgaXMgYW4gb3B0aW1pemF0aW9uIGZvciBtdWx0aXBsZSBjYWxscyB0byBbdmFsdWVzX2F2YWlsYWJsZV0gaW5cbiAgICAgICAgIHNlcXVlbmNlLiAgSXQgY2F1c2VzIHRoZW0gdG8gYWxsIHNoYXJlIHRoZSBzYW1lIGl2YXIsIHJhdGhlciB0aGFuIGFsbG9jYXRlXG4gICAgICAgICBhbiBpdmFyIHBlciBjYWxsLiAqKVxuICAgICAgSXZhci5yZWFkIGl2YXJcbiAgICB8IF8gLT5cbiAgICAgIERlZmVycmVkLmNyZWF0ZSAoZnVuIGl2YXIgLT5cbiAgICAgICAgUXVldWUuZW5xdWV1ZSB0LmJsb2NrZWRfcmVhZHMgKEJsb2NrZWRfcmVhZC4oY3JlYXRlIChaZXJvIGl2YXIpKSBOb25lKSkpXG47O1xuXG5sZXQgcmVhZF9jaG9pY2UgdCA9IGNob2ljZSAodmFsdWVzX2F2YWlsYWJsZSB0KSAoZnVuIChfIDogWyBgT2sgfCBgRW9mIF0pIC0+IHJlYWRfbm93IHQpXG5cbmxldCByZWFkX2Nob2ljZV9zaW5nbGVfY29uc3VtZXJfZXhuIHQgaGVyZSA9XG4gIERlZmVycmVkLkNob2ljZS5tYXAgKHJlYWRfY2hvaWNlIHQpIH5mOihmdW5jdGlvblxuICAgIHwgKGBPayBfIHwgYEVvZikgYXMgeCAtPiB4XG4gICAgfCBgTm90aGluZ19hdmFpbGFibGUgLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJQaXBlLnJlYWRfY2hvaWNlX3NpbmdsZV9jb25zdW1lcl9leG46IGNob2ljZSB3YXMgZW5hYmxlZCBidXQgcGlwZSBpcyBlbXB0eTsgXFxcbiAgICAgICAgICAgdGhpcyBpcyBsaWtlbHkgZHVlIHRvIGEgcmFjZSBjb25kaXRpb24gd2l0aCBvbmUgb3IgbW9yZSBvdGhlciBjb25zdW1lcnNcIlxuICAgICAgICAgICAgKGhlcmUgOiBTb3VyY2VfY29kZV9wb3NpdGlvbi50KV0pXG47O1xuXG4oKiBbcmVhZF9leGFjdGx5IHQgfm51bV92YWx1ZXNdIGxvb3BzLCBnZXR0aW5nIHlvdSBhbGwgW251bV92YWx1ZXNdIGl0ZW1zLCB1cFxuICAgdG8gRU9GLiAqKVxubGV0IHJlYWRfZXhhY3RseSA/Y29uc3VtZXIgdCB+bnVtX3ZhbHVlcyA9XG4gIHN0YXJ0X3JlYWQgdCBcInJlYWRfZXhhY3RseVwiID9jb25zdW1lcjtcbiAgaWYgbnVtX3ZhbHVlcyA8PSAwXG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJQaXBlLnJlYWRfZXhhY3RseSBnb3QgbnVtX3ZhbHVlcyA8PSAwXCIgKG51bV92YWx1ZXMgOiBpbnQpXTtcbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gZmluaXNoIC0+XG4gICAgbGV0IHJlc3VsdCA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICBsZXQgYWxyZWFkeV9yZWFkID0gUXVldWUubGVuZ3RoIHJlc3VsdCBpblxuICAgICAgYXNzZXJ0IChhbHJlYWR5X3JlYWQgPD0gbnVtX3ZhbHVlcyk7XG4gICAgICBpZiBhbHJlYWR5X3JlYWQgPSBudW1fdmFsdWVzXG4gICAgICB0aGVuIEl2YXIuZmlsbF9leG4gZmluaXNoIChgRXhhY3RseSByZXN1bHQpXG4gICAgICBlbHNlXG4gICAgICAgIHJlYWQnID9jb25zdW1lciB0IH5tYXhfcXVldWVfbGVuZ3RoOihudW1fdmFsdWVzIC0gYWxyZWFkeV9yZWFkKVxuICAgICAgICA+Pj4gZnVuY3Rpb25cbiAgICAgICAgfCBgRW9mIC0+IEl2YXIuZmlsbF9leG4gZmluaXNoIChpZiBhbHJlYWR5X3JlYWQgPSAwIHRoZW4gYEVvZiBlbHNlIGBGZXdlciByZXN1bHQpXG4gICAgICAgIHwgYE9rIHEgLT5cbiAgICAgICAgICBRdWV1ZS5ibGl0X3RyYW5zZmVyIH5zcmM6cSB+ZHN0OnJlc3VsdCAoKTtcbiAgICAgICAgICBsb29wICgpXG4gICAgaW5cbiAgICBsb29wICgpKVxuOztcblxubGV0IGRvd25zdHJlYW1fZmx1c2hlZCB0ID1cbiAgaWYgaXNfZW1wdHkgdFxuICB0aGVuIGNvbnN1bWVkX3ZhbHVlc19zZW50X2Rvd25zdHJlYW1fYW5kX2ZsdXNoZWQgdFxuICBlbHNlXG4gICAgKCogW3RdIG1pZ2h0IGJlIGNsb3NlZC4gIEJ1dCB0aGUgcmVhZCBlbmQgY2FuJ3QgYmUgY2xvc2VkLCBiZWNhdXNlIGlmIGl0IHdlcmUsIHRoZW5cbiAgICAgICBbdF0gd291bGQgYmUgZW1wdHkuICBJZiB0aGUgd3JpdGUgZW5kIGlzIGNsb3NlZCBidXQgbm90IHRoZSByZWFkIGVuZCwgdGhlbiB3ZSB3YW50XG4gICAgICAgdG8gZW5xdWV1ZSBhIGJsb2NrZWQgZmx1c2ggYmVjYXVzZSB0aGUgZW5xdWV1ZWQgdmFsdWVzIG1heSBnZXQgcmVhZC4gKilcbiAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZWFkeSAtPlxuICAgICAgUXVldWUuZW5xdWV1ZVxuICAgICAgICB0LmJsb2NrZWRfZmx1c2hlc1xuICAgICAgICB7IGZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQgPSB0Lm51bV92YWx1ZXNfcmVhZCArIGxlbmd0aCB0OyByZWFkeSB9KVxuOztcblxuKCogSW4gcHJhY3RpY2UsIGFsb25nIHdpdGggW0xpbmsuY3JlYXRlXSBhbmQgW2FkZF91cHN0cmVhbV9mbHVzaGVkXSwgW3Vwc3RyZWFtX2ZsdXNoZWRdXG4gICB0cmF2ZXJzZXMgdGhlIGdyYXBoIG9mIGxpbmtlZCBwaXBlcyB1cCB0byB0aGUgaGVhZHMgYW5kIHRoZW4gY2FsbHMgW2Rvd25zdHJlYW1fZmx1c2hlZF1cbiAgIG9uIHRoZW0uICopXG5sZXQgdXBzdHJlYW1fZmx1c2hlZCB0ID1cbiAgaWYgQmFnLmlzX2VtcHR5IHQudXBzdHJlYW1fZmx1c2hlZHNcbiAgdGhlbiBkb3duc3RyZWFtX2ZsdXNoZWQgdFxuICBlbHNlXG4gICAgQmFnLnRvX2xpc3QgdC51cHN0cmVhbV9mbHVzaGVkc1xuICAgIHw+IExpc3QubWFwIH5mOihmdW4gZiAtPiBmICgpKVxuICAgIHw+IEZsdXNoZWRfcmVzdWx0LmNvbWJpbmVcbjs7XG5cbmxldCBhZGRfdXBzdHJlYW1fZmx1c2hlZCB0IHVwc3RyZWFtX2ZsdXNoZWQgPSBCYWcuYWRkIHQudXBzdHJlYW1fZmx1c2hlZHMgdXBzdHJlYW1fZmx1c2hlZFxuXG5sZXQgYWRkX2NvbnN1bWVyIHQgfmRvd25zdHJlYW1fZmx1c2hlZCA9XG4gIGxldCBjb25zdW1lciA9IENvbnN1bWVyLmNyZWF0ZSB+cGlwZV9pZDp0LmlkIH5kb3duc3RyZWFtX2ZsdXNoZWQgaW5cbiAgdC5jb25zdW1lcnMgPC0gY29uc3VtZXIgOjogdC5jb25zdW1lcnM7XG4gIGNvbnN1bWVyXG47O1xuXG4oKiBBIFtMaW5rLnRdIGxpbmtzIGZsdXNoaW5nIG9mIHR3byBwaXBlcyB0b2dldGhlci4gKilcbm1vZHVsZSBMaW5rIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBjcmVhdGUgOiB1cHN0cmVhbTooXywgXykgcGlwZSAtPiBkb3duc3RyZWFtOihfLCBfKSBwaXBlIC0+IHRcbiAgdmFsIGNvbnN1bWVyIDogdCAtPiBDb25zdW1lci50XG5cbiAgKCogW3VubGlua191cHN0cmVhbV0gcmVtb3ZlcyBkb3duc3RyZWFtJ3MgcmVmZXJlbmNlIHRvIHVwc3RyZWFtLiAqKVxuXG4gIHZhbCB1bmxpbmtfdXBzdHJlYW0gOiB0IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHVucGFja2VkID1cbiAgICB7IGRvd25zdHJlYW0gOiAoJ2EsICdiKSB0XG4gICAgOyBjb25zdW1lciA6IENvbnN1bWVyLnRcbiAgICA7IHVwc3RyZWFtX2ZsdXNoZWRzX2JhZ19lbHQgOiAodW5pdCAtPiBGbHVzaGVkX3Jlc3VsdC50IERlZmVycmVkLnQpIEJhZy5FbHQudFxuICAgIH1cblxuICB0eXBlIHQgPSBUIDogKF8sIF8pIHVucGFja2VkIC0+IHRcblxuICBsZXQgY29uc3VtZXIgKFQgdCkgPSB0LmNvbnN1bWVyXG5cbiAgbGV0IGNyZWF0ZSB+dXBzdHJlYW0gfmRvd25zdHJlYW0gPVxuICAgIFRcbiAgICAgIHsgZG93bnN0cmVhbVxuICAgICAgOyBjb25zdW1lciA9XG4gICAgICAgICAgYWRkX2NvbnN1bWVyIHVwc3RyZWFtIH5kb3duc3RyZWFtX2ZsdXNoZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgICAgZG93bnN0cmVhbV9mbHVzaGVkIGRvd25zdHJlYW0pXG4gICAgICA7IHVwc3RyZWFtX2ZsdXNoZWRzX2JhZ19lbHQgPVxuICAgICAgICAgIGFkZF91cHN0cmVhbV9mbHVzaGVkIGRvd25zdHJlYW0gKGZ1biAoKSAtPiB1cHN0cmVhbV9mbHVzaGVkIHVwc3RyZWFtKVxuICAgICAgfVxuICA7O1xuXG4gIGxldCB1bmxpbmtfdXBzdHJlYW0gKFQgdCkgPVxuICAgIEJhZy5yZW1vdmUgdC5kb3duc3RyZWFtLnVwc3RyZWFtX2ZsdXNoZWRzIHQudXBzdHJlYW1fZmx1c2hlZHNfYmFnX2VsdFxuICA7O1xuZW5kXG5cbm1vZHVsZSBGbHVzaGVkID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBDb25zdW1lciBvZiBDb25zdW1lci50XG4gICAgfCBXaGVuX3ZhbHVlX3Byb2Nlc3NlZFxuICAgIHwgV2hlbl92YWx1ZV9yZWFkXG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubGV0IGZvbGRfZ2VuXG4gIChyZWFkX25vdyA6ID9jb25zdW1lcjpDb25zdW1lci50IC0+IF8gUmVhZGVyLnQgLT4gXylcbiAgPyhmbHVzaGVkID0gRmx1c2hlZC5XaGVuX3ZhbHVlX3JlYWQpXG4gIHRcbiAgfmluaXRcbiAgfmZcbiAgPVxuICBsZXQgY29uc3VtZXIgPVxuICAgIG1hdGNoIGZsdXNoZWQgd2l0aFxuICAgIHwgV2hlbl92YWx1ZV9yZWFkIC0+IE5vbmVcbiAgICB8IENvbnN1bWVyIGNvbnN1bWVyIC0+IFNvbWUgY29uc3VtZXJcbiAgICB8IFdoZW5fdmFsdWVfcHJvY2Vzc2VkIC0+XG4gICAgICAoKiBUaGUgZmFjdCB0aGF0IFwibm8gY29uc3VtZXJcIiBiZWhhdmVzIGRpZmZlcmVudCBmcm9tIFwidHJpdmlhbCBjb25zdW1lclwiIGlzIHdlaXJkLFxuICAgICAgICAgYnV0IHRoYXQncyBob3cgdGhlIGNvbnN1bWVyIG1hY2hpbmVyeSB3b3Jrcy4gKilcbiAgICAgIFNvbWUgKGFkZF9jb25zdW1lciB0IH5kb3duc3RyZWFtX2ZsdXNoZWQ6KGZ1biAoKSAtPiByZXR1cm4gYE9rKSlcbiAgaW5cbiAgaWYgIWNoZWNrX2ludmFyaWFudCB0aGVuIGludmFyaWFudCB0O1xuICBlbnN1cmVfY29uc3VtZXJfbWF0Y2hlcyB0ID9jb25zdW1lcjtcbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gZmluaXNoZWQgLT5cbiAgICAoKiBXZSBkbyBbdmFsdWVzX2F2YWlsYWJsZSB0ID4+Pl0gdG8gZW5zdXJlIHRoYXQgW2ZdIGlzIG9ubHkgY2FsbGVkIGFzeW5jaHJvbm91c2x5LlxuICAgICAgIFNlZSBbMV0gZm9yIG1vcmUgZGV0YWlscy4gKilcbiAgICAoKiBbMV0gRm9yIG5ldyBlbXB0eSBwaXBlcyBjcmVhdGVkIGF0IHRvcC1sZXZlbCB3ZSB3YW50IHRvIGF2b2lkIGltbWVkaWF0ZWx5XG4gICAgICAgc2NoZWR1bGluZyBhIGpvYiBvbiB0aGUgc2NoZWR1bGVyIChzZWUgW1NjaGVkdWxlci5yYWlzZV9pZl9hbnlfam9ic193ZXJlX3NjaGVkdWxlZF0pLlxuICAgICAgIEp1c3QgW3JldHVybiAoKSA+Pj5dIGRvZXNuJ3Qgd29yazogW3JldHVybiAoKV0gY3JlYXRlcyBhIGZ1bGwgaXZhciB0aGF0IGNhdXNlc1xuICAgICAgIFs+Pj5dIHRvIHNjaGVkdWxlIGEgam9iLiAqKVxuICAgIHZhbHVlc19hdmFpbGFibGUgdFxuICAgID4+PiBmdW4gKF8gOiBbIGBPayB8IGBFb2YgXSkgLT5cbiAgICBsZXQgcmVjIGxvb3AgYiA9XG4gICAgICBtYXRjaCByZWFkX25vdyB0ID9jb25zdW1lciB3aXRoXG4gICAgICB8IGBFb2YgLT4gSXZhci5maWxsX2V4biBmaW5pc2hlZCBiXG4gICAgICB8IGBPayB2IC0+IGYgYiB2IGNvbnRpbnVlXG4gICAgICB8IGBOb3RoaW5nX2F2YWlsYWJsZSAtPiB2YWx1ZXNfYXZhaWxhYmxlIHQgPj4+IGZ1biBfIC0+IGxvb3AgYlxuICAgIGFuZCBjb250aW51ZSBiID1cbiAgICAgIE9wdGlvbi5pdGVyIGNvbnN1bWVyIH5mOkNvbnN1bWVyLnZhbHVlc19zZW50X2Rvd25zdHJlYW07XG4gICAgICBsb29wIGJcbiAgICBpblxuICAgIGxvb3AgaW5pdClcbjs7XG5cbmxldCBmb2xkJyA/Zmx1c2hlZCA/bWF4X3F1ZXVlX2xlbmd0aCB0IH5pbml0IH5mID1cbiAgZm9sZF9nZW4gKHJlYWRfbm93JyA/bWF4X3F1ZXVlX2xlbmd0aCkgP2ZsdXNoZWQgdCB+aW5pdCB+ZjooZnVuIGIgcSBsb29wIC0+XG4gICAgZiBiIHEgPj4+IGxvb3ApXG47O1xuXG5sZXQgZm9sZCA/Zmx1c2hlZCB0IH5pbml0IH5mID1cbiAgZm9sZF9nZW4gcmVhZF9ub3cgP2ZsdXNoZWQgdCB+aW5pdCB+ZjooZnVuIGIgYSBsb29wIC0+IGYgYiBhID4+PiBsb29wKVxuOztcblxubGV0IGZvbGRfd2l0aG91dF9wdXNoYmFjayA/Y29uc3VtZXIgdCB+aW5pdCB+ZiA9XG4gIGZvbGRfZ2VuXG4gICAgcmVhZF9ub3dcbiAgICB0XG4gICAgfmluaXRcbiAgICB+ZjooZnVuIGIgYSBsb29wIC0+IGxvb3AgKGYgYiBhKSlcbiAgICA/Zmx1c2hlZDpcbiAgICAgIChtYXRjaCBjb25zdW1lciB3aXRoXG4gICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICB8IFNvbWUgYyAtPiBTb21lIChDb25zdW1lciBjKSlcbjs7XG5cbmxldCB3aXRoX2Vycm9yX3RvX2N1cnJlbnRfbW9uaXRvciA/KGNvbnRpbnVlX29uX2Vycm9yID0gZmFsc2UpIGYgYSA9XG4gIGlmIG5vdCBjb250aW51ZV9vbl9lcnJvclxuICB0aGVuIGYgYVxuICBlbHNlIChcbiAgICBtYXRjaCVtYXAgTW9uaXRvci50cnlfd2l0aCB+cnVuOmBTY2hlZHVsZSB+cmVzdDpgTG9nIChmdW4gKCkgLT4gZiBhKSB3aXRoXG4gICAgfCBPayAoKSAtPiAoKVxuICAgIHwgRXJyb3IgZXhuIC0+IE1vbml0b3Iuc2VuZF9leG4gKE1vbml0b3IuY3VycmVudCAoKSkgKE1vbml0b3IuZXh0cmFjdF9leG4gZXhuKSlcbjs7XG5cbmxldCBpdGVyJyA/Y29udGludWVfb25fZXJyb3IgP2ZsdXNoZWQgP21heF9xdWV1ZV9sZW5ndGggdCB+ZiA9XG4gIGZvbGQnID9tYXhfcXVldWVfbGVuZ3RoID9mbHVzaGVkIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSBxIC0+XG4gICAgd2l0aF9lcnJvcl90b19jdXJyZW50X21vbml0b3IgP2NvbnRpbnVlX29uX2Vycm9yIGYgcSlcbjs7XG5cbmxldCBpdGVyID9jb250aW51ZV9vbl9lcnJvciA/Zmx1c2hlZCB0IH5mID1cbiAgZm9sZF9nZW4gcmVhZF9ub3cgP2ZsdXNoZWQgdCB+aW5pdDooKSB+ZjooZnVuICgpIGEgbG9vcCAtPlxuICAgIHdpdGhfZXJyb3JfdG9fY3VycmVudF9tb25pdG9yID9jb250aW51ZV9vbl9lcnJvciBmIGEgPj4+IGZ1biAoKSAtPiBsb29wICgpKVxuOztcblxuKCogW2l0ZXJfd2l0aG91dF9wdXNoYmFja10gaXMgYSBjb21tb24gY2FzZSwgc28gd2UgaW1wbGVtZW50IGl0IGluIGFuIG9wdGltaXplZCBtYW5uZXIsXG4gICByYXRoZXIgdGhhbiB2aWEgW2l0ZXJdLiAgVGhlIGltcGxlbWVudGF0aW9uIHJlYWRzIG9ubHkgb25lIGVsZW1lbnQgYXQgYSB0aW1lLCBzbyB0aGF0XG4gICBpZiBbZl0gY2xvc2VzIFt0XSBvciByYWlzZXMsIG5vIG1vcmUgZWxlbWVudHMgd2lsbCBiZSByZWFkLiAqKVxubGV0IGl0ZXJfd2l0aG91dF9wdXNoYmFja1xuICA/Y29uc3VtZXJcbiAgPyhjb250aW51ZV9vbl9lcnJvciA9IGZhbHNlKVxuICA/bWF4X2l0ZXJhdGlvbnNfcGVyX2pvYlxuICB0XG4gIH5mXG4gID1cbiAgZW5zdXJlX2NvbnN1bWVyX21hdGNoZXMgdCA/Y29uc3VtZXI7XG4gIGxldCBtYXhfaXRlcmF0aW9uc19wZXJfam9iID1cbiAgICBtYXRjaCBtYXhfaXRlcmF0aW9uc19wZXJfam9iIHdpdGhcbiAgICB8IE5vbmUgLT4gSW50Lm1heF92YWx1ZVxuICAgIHwgU29tZSBtYXhfaXRlcmF0aW9uc19wZXJfam9iIC0+XG4gICAgICBpZiBtYXhfaXRlcmF0aW9uc19wZXJfam9iIDw9IDBcbiAgICAgIHRoZW5cbiAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgXCJpdGVyX3dpdGhvdXRfcHVzaGJhY2sgZ290IG5vbi1wb3NpdGl2ZSBtYXhfaXRlcmF0aW9uc19wZXJfam9iXCJcbiAgICAgICAgICAgICAgKG1heF9pdGVyYXRpb25zX3Blcl9qb2IgOiBpbnQpXTtcbiAgICAgIG1heF9pdGVyYXRpb25zX3Blcl9qb2JcbiAgaW5cbiAgbGV0IGYgPVxuICAgIGlmIG5vdCBjb250aW51ZV9vbl9lcnJvclxuICAgIHRoZW4gZlxuICAgIGVsc2VcbiAgICAgIGZ1biBhIC0+XG4gICAgICB0cnkgZiBhIHdpdGhcbiAgICAgIHwgZXhuIC0+IE1vbml0b3Iuc2VuZF9leG4gKE1vbml0b3IuY3VycmVudCAoKSkgZXhuXG4gIGluXG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIGZpbmlzaGVkIC0+XG4gICAgKCogV2UgZG8gW3ZhbHVlc19hdmFpbGFibGUgdCA+Pj5dIHRvIGVuc3VyZSB0aGF0IFtmXSBpcyBvbmx5IGNhbGxlZCBhc3luY2hyb25vdXNseS5cbiAgICAgICBTZWUgWzFdIGZvciBtb3JlIGRldGFpbHMuICopXG4gICAgdmFsdWVzX2F2YWlsYWJsZSB0XG4gICAgPj4+IGZ1biAoXyA6IFsgYE9rIHwgYEVvZiBdKSAtPlxuICAgIGxldCByZWMgc3RhcnQgKCkgPSBsb29wIH5yZW1haW5pbmc6bWF4X2l0ZXJhdGlvbnNfcGVyX2pvYlxuICAgIGFuZCBsb29wIH5yZW1haW5pbmcgPVxuICAgICAgaWYgcmVtYWluaW5nID0gMFxuICAgICAgdGhlbiByZXR1cm4gKCkgPj4+IGZ1biAoKSAtPiBzdGFydCAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHJlYWRfbm93IHQgP2NvbnN1bWVyIHdpdGhcbiAgICAgICAgfCBgRW9mIC0+IEl2YXIuZmlsbF9leG4gZmluaXNoZWQgKClcbiAgICAgICAgfCBgT2sgYSAtPlxuICAgICAgICAgIGYgYTtcbiAgICAgICAgICBsb29wIH5yZW1haW5pbmc6KHJlbWFpbmluZyAtIDEpXG4gICAgICAgIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+IHZhbHVlc19hdmFpbGFibGUgdCA+Pj4gZnVuIF8gLT4gc3RhcnQgKCkpXG4gICAgaW5cbiAgICBzdGFydCAoKSlcbjs7XG5cbmxldCBkcmFpbiB0ID0gaXRlcicgdCB+ZjooZnVuIF8gLT4gcmV0dXJuICgpKVxubGV0IGRyYWluX2FuZF9jb3VudCB0ID0gZm9sZCcgdCB+aW5pdDowIH5mOihmdW4gc3VtIHEgLT4gcmV0dXJuIChzdW0gKyBRdWV1ZS5sZW5ndGggcSkpXG5cbmxldCByZWFkX2FsbCBpbnB1dCA9XG4gIGxldCByZXN1bHQgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgbGV0JW1hcCAoKSA9XG4gICAgaXRlcicgaW5wdXQgfmY6KGZ1biBxIC0+XG4gICAgICBRdWV1ZS5ibGl0X3RyYW5zZmVyIH5zcmM6cSB+ZHN0OnJlc3VsdCAoKTtcbiAgICAgIHJldHVybiAoKSlcbiAgaW5cbiAgcmVzdWx0XG47O1xuXG5sZXQgdG9fbGlzdCByID0gcmVhZF9hbGwgciA+PnwgUXVldWUudG9fbGlzdFxuXG5sZXQgdG9fc3RyZWFtX2RlcHJlY2F0ZWQgdCA9XG4gIFN0cmVhbS5jcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgaXRlcl93aXRob3V0X3B1c2hiYWNrIHQgfmY6KGZ1biB4IC0+IFRhaWwuZXh0ZW5kIHRhaWwgeClcbiAgICA+Pj4gZnVuICgpIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWwpXG47O1xuXG4oKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgW29mX3N0cmVhbV9kZXByZWNhdGVkXSBkb2VzIGFzIG11Y2ggYmF0Y2hpbmcgYXMgcG9zc2libGUuICBJdFxuICAgZ3JhYnMgYXMgbWFueSBpdGVtcyBhcyBhcmUgYXZhaWxhYmxlIGludG8gYW4gaW50ZXJuYWwgcXVldWUuICBPbmNlIGl0IGhhcyBncmFiYmVkXG4gICBldmVyeXRoaW5nLCBpdCB3cml0ZXMgaXQgdG8gdGhlIHBpcGUgYW5kIHRoZW4gYmxvY2tzIHdhaXRpbmcgZm9yIHRoZSBuZXh0IGVsZW1lbnQgZnJvbVxuICAgdGhlIHN0cmVhbS5cblxuICAgVGhlcmUncyBubyBwb3NzaWJpbGl0eSB0aGF0IHdlJ2xsIHN0YXJ2ZSB0aGUgcGlwZSByZWFkaW5nIGFuIGVuZGxlc3Mgc3RyZWFtLCBqdXN0XG4gICBhY2N1bXVsYXRpbmcgdGhlIGVsZW1lbnRzIGludG8gb3VyIHByaXZhdGUgcXVldWUgZm9yZXZlciB3aXRob3V0IGV2ZXIgd3JpdGluZyB0aGVtXG4gICBkb3duc3RyZWFtIHRvIHRoZSBwaXBlLiAgV2h5PyBiZWNhdXNlIHdoaWxlIHdlJ3JlIHJ1bm5pbmcsIHRoZSBzdHJlYW0tcHJvZHVjZXIgKmlzbid0KlxuICAgcnVubmluZyAtLSB0aGVyZSBhcmUgbm8gQXN5bmMgYmxvY2sgcG9pbnRzIGluIHRoZSBxdWV1ZS1hY2N1bXVsYXRvciBsb29wLiAgU28gdGhlXG4gICBxdWV1ZS1hY2N1bXVsYXRvciBsb29wIHdpbGwgZXZlbnR1YWxseSBjYXRjaCB1cCB0byB0aGUgY3VycmVudCBzdHJlYW0gdGFpbCwgYXQgd2hpY2hcbiAgIHBvaW50IHdlJ2xsIGRvIHRoZSBwaXBlLXdyaXRlIGFuZCB0aGVuIGJsb2NrIG9uIHRoZSBzdHJlYW0uLi4gdGh1cyBnaXZpbmcgdGhlXG4gICBzdHJlYW0tcHJvZHVjZXIgYSBjaGFuY2UgdG8gbWFrZSBtb3JlIGVsZW1lbnRzLlxuXG4gICBPbmUgY2FuJ3QgaW1wbGVtZW50IFtvZl9zdHJlYW1dIHVzaW5nIFtTdHJlYW0uaXRlcl0gb3IgW1N0cmVhbS5pdGVyJ10gYmVjYXVzZSB5b3VcbiAgIG5lZWQgdG8gYmUgYWJsZSB0byBzdG9wIGVhcmx5IHdoZW4gdGhlIGNvbnN1bWVyIGNsb3NlcyB0aGUgcGlwZS4gIEFsc28sIHVzaW5nIGVpdGhlclxuICAgb2YgdGhvc2Ugd291bGQgZW50YWlsIHNpZ25pZmljYW50bHkgbW9yZSBkZWZlcnJlZCBvdmVyaGVhZCwgd2hlcmVhcyB0aGUgYmVsb3dcbiAgIGltcGxlbWVudGF0aW9uIHVzZXMgYSBkZWZlcnJlZCBvbmx5IHdoZW4gaXQgbmVlZHMgdG8gd2FpdCBmb3IgZGF0YSBmcm9tIHRoZSBzdHJlYW0uICopXG5sZXQgb2Zfc3RyZWFtX2RlcHJlY2F0ZWQgcyA9XG4gIGxldCByLCB3ID0gY3JlYXRlICgpIGluXG4gIGxldCBxID0gUXVldWUuY3JlYXRlICgpIGluXG4gIGxldCB0cmFuc2ZlciAoKSA9XG4gICAgaWYgbm90IChRdWV1ZS5pc19lbXB0eSBxKVxuICAgIHRoZW5cbiAgICAgICgqIENhbiBub3QgcHVzaGJhY2sgb24gdGhlIHN0cmVhbSwgc28gaWdub3JlIHRoZSBwdXNoYmFjayBvbiB0aGUgcGlwZS4gKilcbiAgICAgIGRvbid0X3dhaXRfZm9yICh3cml0ZScgdyBxKVxuICBpblxuICBsZXQgcmVjIGxvb3AgcyA9XG4gICAgYXNzZXJ0IChub3QgKGlzX2Nsb3NlZCB3KSk7XG4gICAgbGV0IG5leHRfZGVmZXJyZWQgPSBTdHJlYW0ubmV4dCBzIGluXG4gICAgbWF0Y2ggRGVmZXJyZWQucGVlayBuZXh0X2RlZmVycmVkIHdpdGhcbiAgICB8IFNvbWUgbmV4dCAtPiBsb29wX25leHQgbmV4dFxuICAgIHwgTm9uZSAtPlxuICAgICAgdHJhbnNmZXIgKCk7XG4gICAgICB1cG9uIG5leHRfZGVmZXJyZWQgY2hlY2tfY2xvc2VkX2xvb3BfbmV4dFxuICBhbmQgY2hlY2tfY2xvc2VkX2xvb3BfbmV4dCBuZXh0ID0gaWYgbm90IChpc19jbG9zZWQgdykgdGhlbiBsb29wX25leHQgbmV4dFxuICBhbmQgbG9vcF9uZXh0ID0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPlxuICAgICAgdHJhbnNmZXIgKCk7XG4gICAgICBjbG9zZSB3XG4gICAgfCBDb25zICh4LCBzKSAtPlxuICAgICAgUXVldWUuZW5xdWV1ZSBxIHg7XG4gICAgICBsb29wIHNcbiAgaW5cbiAgbG9vcCBzO1xuICByXG47O1xuXG5sZXQgdHJhbnNmZXJfZ2VuXG4gIChyZWFkX25vdyA6ID9jb25zdW1lcjpDb25zdW1lci50IC0+IF8gUmVhZGVyLnQgLT4gXylcbiAgd3JpdGVcbiAgaW5wdXRcbiAgb3V0cHV0XG4gIH5mXG4gID1cbiAgaWYgIWNoZWNrX2ludmFyaWFudFxuICB0aGVuIChcbiAgICBpbnZhcmlhbnQgaW5wdXQ7XG4gICAgaW52YXJpYW50IG91dHB1dCk7XG4gIGxldCBsaW5rID0gTGluay5jcmVhdGUgfnVwc3RyZWFtOmlucHV0IH5kb3duc3RyZWFtOm91dHB1dCBpblxuICBsZXQgY29uc3VtZXIgPSBMaW5rLmNvbnN1bWVyIGxpbmsgaW5cbiAgKCogV2hlbiB3ZSdyZSBkb25lIHdpdGggW2lucHV0XSwgd2UgdW5saW5rIHRvIHJlbW92ZSBwb2ludGVycyBmcm9tXG4gICAgIFtvdXRwdXRdIHRvIFtpbnB1dF0sIHdoaWNoIHdvdWxkIGNhdXNlIGEgc3BhY2UgbGVhayBpZiB3ZSBoYWQgc2luZ2xlIGxvbmctbGl2ZWRcbiAgICAgb3V0cHV0IGludG8gd2hpY2ggd2UgdHJhbnNmZXIgbG90cyBvZiBzaG9ydC1saXZlZCBpbnB1dHMuICopXG4gIGxldCB1bmxpbmsgKCkgPSBMaW5rLnVubGlua191cHN0cmVhbSBsaW5rIGluXG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgIGxldCBpbnB1dF9hdmFpbGFibGVfb3Jfb3V0cHV0X2Nsb3NlZCAoKSA9XG4gICAgICBjaG9vc2UgWyBjaG9pY2UgKHZhbHVlc19hdmFpbGFibGUgaW5wdXQpIGlnbm9yZTsgY2hvaWNlIChjbG9zZWQgb3V0cHV0KSBpZ25vcmUgXVxuICAgIGluXG4gICAgKCogV2UgZG8gW2lucHV0X2F2YWlsYWJsZV9vcl9vdXRwdXRfY2xvc2VkICgpID4+Pl0gdG8gZW5zdXJlIHRoYXQgW2ZdIGlzIG9ubHkgY2FsbGVkXG4gICAgICAgYXN5bmNocm9ub3VzbHkuIFNlZSBbMV0gZm9yIG1vcmUgZGV0YWlscy4gKilcbiAgICBpbnB1dF9hdmFpbGFibGVfb3Jfb3V0cHV0X2Nsb3NlZCAoKVxuICAgID4+PiBmdW4gKCkgLT5cbiAgICBsZXQgb3V0cHV0X2Nsb3NlZCAoKSA9XG4gICAgICBjbG9zZV9yZWFkIGlucHV0O1xuICAgICAgdW5saW5rICgpO1xuICAgICAgSXZhci5maWxsX2V4biByZXN1bHQgKClcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICBpZiBpc19jbG9zZWQgb3V0cHV0XG4gICAgICB0aGVuIG91dHB1dF9jbG9zZWQgKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCByZWFkX25vdyBpbnB1dCB+Y29uc3VtZXIgd2l0aFxuICAgICAgICB8IGBFb2YgLT5cbiAgICAgICAgICB1bmxpbmsgKCk7XG4gICAgICAgICAgSXZhci5maWxsX2V4biByZXN1bHQgKClcbiAgICAgICAgfCBgT2sgeCAtPiBmIHggY29udGludWVcbiAgICAgICAgfCBgTm90aGluZ19hdmFpbGFibGUgLT4gaW5wdXRfYXZhaWxhYmxlX29yX291dHB1dF9jbG9zZWQgKCkgPj4+IGZ1biAoKSAtPiBsb29wICgpKVxuICAgIGFuZCBjb250aW51ZSB5ID1cbiAgICAgIGlmIGlzX2Nsb3NlZCBvdXRwdXRcbiAgICAgIHRoZW4gb3V0cHV0X2Nsb3NlZCAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBwdXNoYmFjayA9IHdyaXRlIG91dHB1dCB5IGluXG4gICAgICAgIENvbnN1bWVyLnZhbHVlc19zZW50X2Rvd25zdHJlYW0gY29uc3VtZXI7XG4gICAgICAgIHB1c2hiYWNrID4+PiBmdW4gKCkgLT4gbG9vcCAoKSlcbiAgICBpblxuICAgIGxvb3AgKCkpXG47O1xuXG5sZXQgdHJhbnNmZXInID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IG91dHB1dCB+ZiA9XG4gIHRyYW5zZmVyX2dlbiAocmVhZF9ub3cnID9tYXhfcXVldWVfbGVuZ3RoKSB3cml0ZScgaW5wdXQgb3V0cHV0IH5mOihmdW4gcSBrIC0+IGYgcSA+Pj4gaylcbjs7XG5cbmxldCB0cmFuc2ZlciBpbnB1dCBvdXRwdXQgfmYgPVxuICB0cmFuc2Zlcl9nZW4gcmVhZF9ub3cgd3JpdGUgaW5wdXQgb3V0cHV0IH5mOihmdW4gYSBrIC0+IGsgKGYgYSkpXG47O1xuXG5sZXQgdHJhbnNmZXJfaWQgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgb3V0cHV0ID1cbiAgdHJhbnNmZXJfZ2VuIChyZWFkX25vdycgP21heF9xdWV1ZV9sZW5ndGgpIHdyaXRlJyBpbnB1dCBvdXRwdXQgfmY6KGZ1biBxIGsgLT4gayBxKVxuOztcblxubGV0IG1hcF9nZW4gcmVhZCB3cml0ZSBpbnB1dCB+ZiA9XG4gIGxldCBpbmZvID0gT3B0aW9uLm1hcCBpbnB1dC5pbmZvIH5mOihmdW4gaW5mbyAtPiBbJXNleHAgTWFwcGVkIChpbmZvIDogU2V4cC50KV0pIGluXG4gIGxldCByZXN1bHQsIG91dHB1dCA9IGNyZWF0ZSA/aW5mbyAoKSBpblxuICB1cG9uICh0cmFuc2Zlcl9nZW4gcmVhZCB3cml0ZSBpbnB1dCBvdXRwdXQgfmYpIChmdW4gKCkgLT4gY2xvc2Ugb3V0cHV0KTtcbiAgcmVzdWx0XG47O1xuXG5sZXQgbWFwJyA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+ZiA9XG4gIG1hcF9nZW4gKHJlYWRfbm93JyA/bWF4X3F1ZXVlX2xlbmd0aCkgd3JpdGUnIGlucHV0IH5mOihmdW4gcSBrIC0+IGYgcSA+Pj4gaylcbjs7XG5cbmxldCBtYXAgaW5wdXQgfmYgPSBtYXBfZ2VuIHJlYWRfbm93IHdyaXRlIGlucHV0IH5mOihmdW4gYSBrIC0+IGsgKGYgYSkpXG5cbmxldCBjb25jYXRfbWFwX2xpc3QgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmYgPVxuICBtYXBfZ2VuIChyZWFkX25vdycgP21heF9xdWV1ZV9sZW5ndGgpIHdyaXRlJyBpbnB1dCB+ZjooZnVuIHEgayAtPlxuICAgIGsgKFF1ZXVlLmNvbmNhdF9tYXAgcSB+ZikpXG47O1xuXG5sZXQgZmlsdGVyX21hcCcgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmYgPVxuICBtYXAnID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5mOihmdW4gcSAtPlxuICAgIERlZmVycmVkLlF1ZXVlLmZpbHRlcl9tYXAgfmhvdzpgU2VxdWVudGlhbCBxIH5mKVxuOztcblxubGV0IGZpbHRlcl9tYXAgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmYgPVxuICBtYXBfZ2VuIChyZWFkX25vdycgP21heF9xdWV1ZV9sZW5ndGgpIHdyaXRlJyBpbnB1dCB+ZjooZnVuIHEgayAtPlxuICAgIGsgKFF1ZXVlLmZpbHRlcl9tYXAgcSB+ZjooZnVuIHggLT4gaWYgaXNfcmVhZF9jbG9zZWQgaW5wdXQgdGhlbiBOb25lIGVsc2UgZiB4KSkpXG47O1xuXG5sZXQgZm9sZGluZ19maWx0ZXJfbWFwJyA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+aW5pdCB+ZiA9XG4gIGxldCBhY2N1bSA9IHJlZiBpbml0IGluXG4gIGZpbHRlcl9tYXAnID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5mOihmdW4geCAtPlxuICAgIGxldCVtYXAgYSwgeCA9IGYgIWFjY3VtIHggaW5cbiAgICBhY2N1bSA6PSBhO1xuICAgIHgpXG47O1xuXG5sZXQgZm9sZGluZ19maWx0ZXJfbWFwID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5pbml0IH5mID1cbiAgbGV0IGFjY3VtID0gcmVmIGluaXQgaW5cbiAgZmlsdGVyX21hcCA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+ZjooZnVuIHggLT5cbiAgICBsZXQgYSwgeCA9IGYgIWFjY3VtIHggaW5cbiAgICBhY2N1bSA6PSBhO1xuICAgIHgpXG47O1xuXG5sZXQgZm9sZGluZ19tYXAgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmluaXQgfmYgPVxuICBmb2xkaW5nX2ZpbHRlcl9tYXAgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmluaXQgfmY6KGZ1biBhY2N1bSBhIC0+XG4gICAgbGV0IGFjY3VtLCBiID0gZiBhY2N1bSBhIGluXG4gICAgYWNjdW0sIFNvbWUgYilcbjs7XG5cbmxldCBmaWx0ZXIgaW5wdXQgfmYgPSBmaWx0ZXJfbWFwIGlucHV0IH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBOb25lKVxuXG5sZXQgb2ZfcXVldWVfaW50ZXJuYWwgcXVldWUgPVxuICBsZXQgdCA9IGNyZWF0ZV9pbnRlcm5hbCB+c2l6ZV9idWRnZXQ6MCB+aW5mbzpOb25lIH5pbml0aWFsX2J1ZmZlcjpxdWV1ZSBpblxuICBJdmFyLmZpbGxfZXhuIHQuY2xvc2VkICgpO1xuICB1cGRhdGVfcHVzaGJhY2sgdDtcbiAgdFxuOztcblxubGV0IG9mX3F1ZXVlIHF1ZXVlID0gb2ZfcXVldWVfaW50ZXJuYWwgKFF1ZXVlLmNvcHkgcXVldWUpXG5sZXQgb2ZfbGlzdCBsID0gb2ZfcXVldWVfaW50ZXJuYWwgKFF1ZXVlLm9mX2xpc3QgbClcbmxldCBlbXB0eSAoKSA9IG9mX2xpc3QgW11cblxubGV0IHNpbmdsZXRvbiB4ID1cbiAgbGV0IHJlYWRlciwgd3JpdGVyID0gY3JlYXRlICgpIGluXG4gIHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgd3JpdGVyIHg7XG4gIGNsb3NlIHdyaXRlcjtcbiAgcmVhZGVyXG47O1xuXG5sZXQgdW5mb2xkIH5pbml0OnMgfmYgPVxuICAoKiBUbyBnZXQgc29tZSBiYXRjaGluZywgd2UgcnVuIHRoZSBjb250aW51YXRpb24gaW1tZWRpYXRlbHkgaWYgdGhlIGRlZmVycmVkIGlzXG4gICAgIGRldGVybWluZWQuICBIb3dldmVyLCB3ZSBhbHdheXMgY2hlY2sgZm9yIHB1c2hiYWNrLiAgQmVjYXVzZSBzaXplIGJ1ZGdldCBjYW4ndCBiZVxuICAgICBpbmZpbml0ZSwgdGhlIGJlbG93IGxvb3AgaXMgZ3VhcmFudGVlZCB0byBldmVudHVhbGx5IHlpZWxkIHRvIHRoZSBzY2hlZHVsZXIuICopXG4gIGxldCAoID4+PX4gKSBkIGYgPVxuICAgIG1hdGNoIERlZmVycmVkLnBlZWsgZCB3aXRoXG4gICAgfCBOb25lIC0+IGQgPj49IGZcbiAgICB8IFNvbWUgeCAtPiBmIHhcbiAgaW5cbiAgY3JlYXRlX3JlYWRlciB+Y2xvc2Vfb25fZXhjZXB0aW9uOmZhbHNlIChmdW4gd3JpdGVyIC0+XG4gICAgbGV0IHJlYyBsb29wIHMgPVxuICAgICAgZiBzXG4gICAgICA+Pj1+IGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gcmV0dXJuICgpXG4gICAgICB8IFNvbWUgKGEsIHMpIC0+XG4gICAgICAgIGlmIGlzX2Nsb3NlZCB3cml0ZXIgdGhlbiByZXR1cm4gKCkgZWxzZSB3cml0ZSB3cml0ZXIgYSA+Pj1+IGZ1biAoKSAtPiBsb29wIHNcbiAgICBpblxuICAgIGxvb3Agcylcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZSBzZXF1ZW5jZSA9XG4gIGNyZWF0ZV9yZWFkZXIgfmNsb3NlX29uX2V4Y2VwdGlvbjpmYWxzZSAoZnVuIHdyaXRlciAtPlxuICAgIGxldCByZWMgZW5xdWV1ZV9uIHNlcXVlbmNlIGkgPVxuICAgICAgaWYgaSA8PSAwXG4gICAgICB0aGVuIHNlcXVlbmNlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggU2VxdWVuY2UubmV4dCBzZXF1ZW5jZSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBzZXF1ZW5jZVxuICAgICAgICB8IFNvbWUgKGEsIHNlcXVlbmNlKSAtPlxuICAgICAgICAgIGRlY3JlYXNlX3Jlc2VydmVkX3NwYWNlIHdyaXRlciAxO1xuICAgICAgICAgIFF1ZXVlLmVucXVldWUgd3JpdGVyLmJ1ZmZlciBhO1xuICAgICAgICAgIGVucXVldWVfbiBzZXF1ZW5jZSAoaSAtIDEpKVxuICAgIGluXG4gICAgbGV0IHJlYyBsb29wIHNlcXVlbmNlID1cbiAgICAgIGlmIGlzX2Nsb3NlZCB3cml0ZXIgfHwgU2VxdWVuY2UuaXNfZW1wdHkgc2VxdWVuY2VcbiAgICAgIHRoZW4gcmV0dXJuICgpXG4gICAgICBlbHNlIChcbiAgICAgICAgKCogW3NpemU6MF0gaGVyZSBhcyB3ZSBkb24ndCBrbm93IHRoZSBzaXplIG9mIHRoZSBzZXF1ZW5jZSBzdGF0aWNhbGx5LiBXZSdsbFxuICAgICAgICAgICBjYWxsIFtkZWNyZWFzZV9yZXNlcnZlZF9zcGFjZV0gYXMgd2UgZ28uXG4gICAgICAgICAgIChhbHRob3VnaCByZWFsaXN0aWNhbGx5LCBpdCdzIGltcG9zc2libGUgZm9yIHRoZSB1c2VyIHRvIHJlc2VydmUgc3BhY2UgaW5cbiAgICAgICAgICAgdGhpcyBwaXBlIGJlY2F1c2UgeW91IG5lZWQgYSBwaXBlIHdyaXRlciBmb3IgdGhhdCwgYnV0IFtvZl9zZXF1ZW5jZV0gcmV0dXJuc1xuICAgICAgICAgICBhIHJlYWRlcikgKilcbiAgICAgICAgc3RhcnRfd3JpdGUgd3JpdGVyIH5zaXplOjA7XG4gICAgICAgIGxldCBzZXF1ZW5jZSA9IGVucXVldWVfbiBzZXF1ZW5jZSAoMSArIHdyaXRlci5zaXplX2J1ZGdldCAtIGxlbmd0aCB3cml0ZXIpIGluXG4gICAgICAgIGZpbmlzaF93cml0ZSB3cml0ZXI7XG4gICAgICAgIGxldCViaW5kICgpID0gcHVzaGJhY2sgd3JpdGVyIGluXG4gICAgICAgIGxvb3Agc2VxdWVuY2UpXG4gICAgaW5cbiAgICBsb29wIHNlcXVlbmNlKVxuOztcblxudHlwZSAnYSB0b19zZXF1ZW5jZV9lbHQgPVxuICB8IFZhbHVlIG9mICdhXG4gIHwgV2FpdF9mb3IgOiBfIERlZmVycmVkLnQgLT4gXyB0b19zZXF1ZW5jZV9lbHRcblxubGV0IHRvX3NlcXVlbmNlIHQgPVxuICBTZXF1ZW5jZS51bmZvbGQgfmluaXQ6KCkgfmY6KGZ1biAoKSAtPlxuICAgIG1hdGNoIHJlYWRfbm93IHQgd2l0aFxuICAgIHwgYEVvZiAtPiBOb25lXG4gICAgfCBgT2sgYSAtPiBTb21lIChWYWx1ZSBhLCAoKSlcbiAgICB8IGBOb3RoaW5nX2F2YWlsYWJsZSAtPiBTb21lIChXYWl0X2ZvciAodmFsdWVzX2F2YWlsYWJsZSB0KSwgKCkpKVxuOztcblxubGV0IGludGVybGVhdmVfcGlwZSA/KGNsb3NlX29uID0gYEFsbF9pbnB1dHNfY2xvc2VkKSBpbnB1dHMgPVxuICBsZXQgb3V0cHV0LCBvdXRwdXRfd3JpdGVyID0gY3JlYXRlIH5pbmZvOlslc2V4cCBcIlBpcGUuaW50ZXJsZWF2ZVwiXSAoKSBpblxuICAoKiBXZSBrZWVwIGEgcmVmZXJlbmNlIGNvdW50IG9mIGFsbCB0aGUgcGlwZXMgdGhhdCBbaW50ZXJsZWF2ZV9waXBlXSBpcyBtYW5hZ2luZztcbiAgICAgW2lucHV0c10gY291bnRzIGFzIG9uZS4gIFdoZW4gdGhlIHJlZmVyZW5jZSBjb3VudCBkcm9wcyB0byB6ZXJvLCB3ZSBrbm93IHRoYXQgYWxsXG4gICAgIHBpcGVzIGFyZSBjbG9zZWQgYW5kIHdlIGNhbiBjbG9zZSBbb3V0cHV0X3dyaXRlcl0uICopXG4gIGxldCBudW1fcGlwZXNfcmVtYWluaW5nID0gcmVmIDEgaW5cbiAgbGV0IGNsb3NlX29uZV9waXBlIGNsb3NlZF9waXBlX2tpbmQgPVxuICAgIGRlY3IgbnVtX3BpcGVzX3JlbWFpbmluZztcbiAgICBsZXQgc2hvdWxkX2Nsb3NlID1cbiAgICAgIG1hdGNoIGNsb3NlX29uLCBjbG9zZWRfcGlwZV9raW5kIHdpdGhcbiAgICAgIHwgYEFueV9pbnB1dF9jbG9zZWQsIGBJbnB1dF9waXBlIC0+IHRydWVcbiAgICAgIHwgYEFueV9pbnB1dF9jbG9zZWQsIGBQaXBlX29mX2lucHV0X3BpcGVzXG4gICAgICB8IGBBbGxfaW5wdXRzX2Nsb3NlZCwgKGBJbnB1dF9waXBlIHwgYFBpcGVfb2ZfaW5wdXRfcGlwZXMpIC0+XG4gICAgICAgICFudW1fcGlwZXNfcmVtYWluaW5nID0gMFxuICAgIGluXG4gICAgaWYgc2hvdWxkX2Nsb3NlIHRoZW4gY2xvc2Ugb3V0cHV0X3dyaXRlclxuICBpblxuICBkb24ndF93YWl0X2ZvclxuICAgIChsZXQlbWFwICgpID1cbiAgICAgICBpdGVyX3dpdGhvdXRfcHVzaGJhY2sgaW5wdXRzIH5mOihmdW4gaW5wdXQgLT5cbiAgICAgICAgIGluY3IgbnVtX3BpcGVzX3JlbWFpbmluZztcbiAgICAgICAgIGRvbid0X3dhaXRfZm9yXG4gICAgICAgICAgIChsZXQlbWFwICgpID0gdHJhbnNmZXJfaWQgaW5wdXQgb3V0cHV0X3dyaXRlciBpblxuICAgICAgICAgICAgY2xvc2Vfb25lX3BpcGUgYElucHV0X3BpcGUpKVxuICAgICBpblxuICAgICBjbG9zZV9vbmVfcGlwZSBgUGlwZV9vZl9pbnB1dF9waXBlcyk7XG4gICgqIGZvciBbaW5wdXRzXSAqKVxuICBvdXRwdXRcbjs7XG5cbmxldCBpbnRlcmxlYXZlID9jbG9zZV9vbiBpbnB1dHMgPVxuICBpZiAhY2hlY2tfaW52YXJpYW50IHRoZW4gTGlzdC5pdGVyIGlucHV0cyB+ZjppbnZhcmlhbnQ7XG4gIGludGVybGVhdmVfcGlwZSA/Y2xvc2Vfb24gKG9mX2xpc3QgaW5wdXRzKVxuOztcblxubGV0IG1lcmdlIGlucHV0cyB+Y29tcGFyZSA9XG4gIG1hdGNoIGlucHV0cyB3aXRoXG4gIHwgW10gLT4gZW1wdHkgKClcbiAgfCBbIGlucHV0IF0gLT4gaW5wdXRcbiAgfCBpbnB1dHMgLT5cbiAgICBsZXQgbW9kdWxlIEhlYXAgPSBQYWlyaW5nX2hlYXAgaW5cbiAgICBsZXQgciwgdyA9IGNyZWF0ZSAoKSBpblxuICAgIHVwb24gKGNsb3NlZCB3KSAoZnVuICgpIC0+IExpc3QuaXRlciBpbnB1dHMgfmY6Y2xvc2VfcmVhZCk7XG4gICAgbGV0IGhlYXAgPSBIZWFwLmNyZWF0ZSB+Y21wOihmdW4gKGExLCBfKSAoYTIsIF8pIC0+IGNvbXBhcmUgYTEgYTIpICgpIGluXG4gICAgbGV0IGhhbmRsZV9yZWFkIGlucHV0IGVvZl9vcl9vayA9XG4gICAgICBtYXRjaCBlb2Zfb3Jfb2sgd2l0aFxuICAgICAgfCBgRW9mIC0+ICgpXG4gICAgICB8IGBPayB2IC0+IEhlYXAuYWRkIGhlYXAgKHYsIGlucHV0KVxuICAgIGluXG4gICAgbGV0IHJlYyBwb3BfaGVhcF9hbmRfbG9vcCAoKSA9XG4gICAgICAoKiBBdCB0aGlzIHBvaW50LCBhbGwgaW5wdXRzIG5vdCBhdCBFb2Ygb2NjdXIgaW4gW2hlYXBdIGV4YWN0bHkgb25jZSwgc28gd2Uga25vd1xuICAgICAgICAgd2hhdCB0aGUgbmV4dCBvdXRwdXQgZWxlbWVudCBpcy4gIFtwb3BfaGVhcF9hbmRfbG9vcF0gcmVwZWF0ZWRseSB0YWtlcyBlbGVtZW50c1xuICAgICAgICAgZnJvbSB0aGUgaW5wdXRzIGFzIGxvbmcgYXMgaXQgaGFzIG9uZSBmcm9tIGVhY2ggaW5wdXQuICBUaGlzIGlzIGRvbmVcbiAgICAgICAgIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgdGhlIGNvc3Qgb2YgYSBkZWZlcnJlZCBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBvdXRwdXQgLS1cbiAgICAgICAgIHRoZXJlJ3Mgbm8gbmVlZCB0byBwdXNoYmFjayBzaW5jZSB0aGF0IGlzIG9ubHkgbW92aW5nIGVsZW1lbnRzIGZyb20gb25lIHBpcGUgdG9cbiAgICAgICAgIGFub3RoZXIuICBBcyBzb29uIGFzIFtwb3BfaGVhcF9hbmRfbG9vcF0gY2FuJ3QgZ2V0IGFuIGVsZW1lbnQgZnJvbSBzb21lIGlucHV0LCBpdFxuICAgICAgICAgd2FpdHMgb24gcHVzaGJhY2sgZnJvbSB0aGUgb3V0cHV0LCBzaW5jZSBpdCBoYXMgdG8gd2FpdCBvbiB0aGUgaW5wdXQgYW55d2F5LlxuICAgICAgICAgVGhpcyBhbHNvIHByZXZlbnRzIFttZXJnZV0gZnJvbSBjb25zdW1pbmcgaW5wdXRzIGF0IGEgcmF0ZSBmYXN0ZXIgdGhhbiBpdHMgb3V0cHV0XG4gICAgICAgICBpcyBjb25zdW1lZC4gKilcbiAgICAgIG1hdGNoIEhlYXAucG9wIGhlYXAgd2l0aFxuICAgICAgfCBOb25lIC0+IGNsb3NlIHdcbiAgICAgIHwgU29tZSAodiwgaW5wdXQpIC0+XG4gICAgICAgIGlmIG5vdCAoaXNfY2xvc2VkIHcpXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgdyB2O1xuICAgICAgICAgIGlmIEhlYXAubGVuZ3RoIGhlYXAgPSAwXG4gICAgICAgICAgdGhlbiB1cG9uICh0cmFuc2Zlcl9pZCBpbnB1dCB3KSAoZnVuICgpIC0+IGNsb3NlIHcpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBtYXRjaCByZWFkX25vdyBpbnB1dCB3aXRoXG4gICAgICAgICAgICB8IChgRW9mIHwgYE9rIF8pIGFzIHggLT5cbiAgICAgICAgICAgICAgaGFuZGxlX3JlYWQgaW5wdXQgeDtcbiAgICAgICAgICAgICAgcG9wX2hlYXBfYW5kX2xvb3AgKClcbiAgICAgICAgICAgIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+XG4gICAgICAgICAgICAgIHB1c2hiYWNrIHdcbiAgICAgICAgICAgICAgPj4+IGZ1biAoKSAtPlxuICAgICAgICAgICAgICByZWFkIGlucHV0XG4gICAgICAgICAgICAgID4+PiBmdW4geCAtPlxuICAgICAgICAgICAgICBoYW5kbGVfcmVhZCBpbnB1dCB4O1xuICAgICAgICAgICAgICBwb3BfaGVhcF9hbmRfbG9vcCAoKSkpXG4gICAgaW5cbiAgICBsZXQgaW5pdGlhbF9wdXNoID1cbiAgICAgIERlZmVycmVkLkxpc3QuaXRlciB+aG93OmBTZXF1ZW50aWFsIGlucHV0cyB+ZjooZnVuIGlucHV0IC0+XG4gICAgICAgIGxldCVtYXAgeCA9IHJlYWQgaW5wdXQgaW5cbiAgICAgICAgaGFuZGxlX3JlYWQgaW5wdXQgeClcbiAgICBpblxuICAgIHVwb24gaW5pdGlhbF9wdXNoIHBvcF9oZWFwX2FuZF9sb29wO1xuICAgIHJcbjs7XG5cbmxldCBjb25jYXRfcGlwZSBpbnB1dHMgPVxuICBsZXQgciA9XG4gICAgY3JlYXRlX3JlYWRlcl9ub3RfY2xvc2Vfb25fZXhjZXB0aW9uIChmdW4gdyAtPlxuICAgICAgbGV0IGxpbmsgPSBMaW5rLmNyZWF0ZSB+dXBzdHJlYW06aW5wdXRzIH5kb3duc3RyZWFtOncgaW5cbiAgICAgIGxldCBjb25zdW1lciA9IExpbmsuY29uc3VtZXIgbGluayBpblxuICAgICAgaXRlciB+Zmx1c2hlZDooQ29uc3VtZXIgY29uc3VtZXIpIGlucHV0cyB+ZjooZnVuIGlucHV0IC0+IHRyYW5zZmVyX2lkIGlucHV0IHcpKVxuICBpblxuICB1cG9uIChjbG9zZWQgcikgKGZ1biAoKSAtPiBjbG9zZSBpbnB1dHMpO1xuICByXG47O1xuXG5sZXQgY29uY2F0IGlucHV0cyA9XG4gIGNyZWF0ZV9yZWFkZXJfbm90X2Nsb3NlX29uX2V4Y2VwdGlvbiAoZnVuIHcgLT5cbiAgICBEZWZlcnJlZC5MaXN0Lml0ZXIgfmhvdzpgU2VxdWVudGlhbCBpbnB1dHMgfmY6KGZ1biBpbnB1dCAtPiB0cmFuc2Zlcl9pZCBpbnB1dCB3KSlcbjs7XG5cbmxldCBmb3JrIHQgfnB1c2hiYWNrX3VzZXMgPVxuICBsZXQgcmVhZGVyMCwgd3JpdGVyMCA9IGNyZWF0ZSAoKSBpblxuICBsZXQgcmVhZGVyMSwgd3JpdGVyMSA9IGNyZWF0ZSAoKSBpblxuICBsZXQgc29tZV9yZWFkZXJfd2FzX2Nsb3NlZCA9IHJlZiBmYWxzZSBpblxuICBsZXQgY29uc3VtZXIgPVxuICAgIGFkZF9jb25zdW1lciB0IH5kb3duc3RyZWFtX2ZsdXNoZWQ6KGZ1biAoKSAtPlxuICAgICAgbGV0IHNvbWVfcmVhZGVyX3dhc19jbG9zZWQgPSAhc29tZV9yZWFkZXJfd2FzX2Nsb3NlZCBpblxuICAgICAgbWF0Y2glbWFwXG4gICAgICAgIEZsdXNoZWRfcmVzdWx0LmNvbWJpbmUgWyBkb3duc3RyZWFtX2ZsdXNoZWQgd3JpdGVyMDsgZG93bnN0cmVhbV9mbHVzaGVkIHdyaXRlcjEgXVxuICAgICAgd2l0aFxuICAgICAgfCBgUmVhZGVyX2Nsb3NlZCAtPiBgUmVhZGVyX2Nsb3NlZFxuICAgICAgfCBgT2sgLT5cbiAgICAgICAgKCogSW4gdGhpcyBjYXNlLCB0aGVyZSBjb3VsZCBoYXZlIGJlZW4gbm8gcGVuZGluZyBpdGVtcyBpbiBbd3JpdGVyMF0gbm9yIGluXG4gICAgICAgICAgIFt3cml0ZXIxXSwgaW4gd2hpY2ggY2FzZSB3ZSBjb3VsZCBoYXZlIGhhZCBhIGNsb3NlZCBwaXBlIHRoYXQgbWlzc2VkIHNvbWVcbiAgICAgICAgICAgd3JpdGVzLCBidXQgW0ZsdXNoZWRfcmVzdWx0LmNvbWJpbmVdIHdvdWxkIHN0aWxsIGhhdmUgcmV0dXJuZWQgW2BPa10gKilcbiAgICAgICAgaWYgc29tZV9yZWFkZXJfd2FzX2Nsb3NlZCB0aGVuIGBSZWFkZXJfY2xvc2VkIGVsc2UgYE9rKVxuICBpblxuICBkb24ndF93YWl0X2ZvclxuICAgIChsZXQgc3RpbGxfb3BlbiA9IFsgd3JpdGVyMDsgd3JpdGVyMSBdIGluXG4gICAgIGxldCBmaWx0ZXJfb3BlbiBzdGlsbF9vcGVuID1cbiAgICAgICAoKiBPbmx5IGNhbGwgW2ZpbHRlcl0gYW5kIHJlYWxsb2NhdGUgbGlzdCBpZiBzb21ldGhpbmcgd2lsbCBnZXQgZmlsdGVyZWQgKilcbiAgICAgICBpZiBub3QgKExpc3QuZXhpc3RzIHN0aWxsX29wZW4gfmY6aXNfY2xvc2VkKVxuICAgICAgIHRoZW4gc3RpbGxfb3BlblxuICAgICAgIGVsc2UgKFxuICAgICAgICAgc29tZV9yZWFkZXJfd2FzX2Nsb3NlZCA6PSB0cnVlO1xuICAgICAgICAgbGV0IHN0aWxsX29wZW4gPSBMaXN0LmZpbHRlciBzdGlsbF9vcGVuIH5mOihmdW4gdyAtPiBub3QgKGlzX2Nsb3NlZCB3KSkgaW5cbiAgICAgICAgIGlmIExpc3QuaXNfZW1wdHkgc3RpbGxfb3BlbiB0aGVuIGNsb3NlIHQ7XG4gICAgICAgICBzdGlsbF9vcGVuKVxuICAgICBpblxuICAgICBsZXQlYmluZCBzdGlsbF9vcGVuID1cbiAgICAgICBmb2xkJyB0IH5mbHVzaGVkOihDb25zdW1lciBjb25zdW1lcikgfmluaXQ6c3RpbGxfb3BlbiB+ZjooZnVuIHN0aWxsX29wZW4gcXVldWUgLT5cbiAgICAgICAgIGxldCBzdGlsbF9vcGVuID0gZmlsdGVyX29wZW4gc3RpbGxfb3BlbiBpblxuICAgICAgICAgaWYgTGlzdC5pc19lbXB0eSBzdGlsbF9vcGVuXG4gICAgICAgICB0aGVuIHJldHVybiBbXVxuICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgIGxldCVtYXAgKCkgPVxuICAgICAgICAgICAgIG1hdGNoIHB1c2hiYWNrX3VzZXMgd2l0aFxuICAgICAgICAgICAgIHwgYEZhc3RfY29uc3VtZXJfb25seSAtPiBEZWZlcnJlZC5hbnkgKExpc3QubWFwIHN0aWxsX29wZW4gfmY6cHVzaGJhY2spXG4gICAgICAgICAgICAgfCBgQm90aF9jb25zdW1lcnMgLT4gRGVmZXJyZWQuYWxsX3VuaXQgKExpc3QubWFwIHN0aWxsX29wZW4gfmY6cHVzaGJhY2spXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIGxldCBzdGlsbF9vcGVuID0gZmlsdGVyX29wZW4gc3RpbGxfb3BlbiBpblxuICAgICAgICAgICBMaXN0Lml0ZXIgc3RpbGxfb3BlbiB+ZjooZnVuIHcgLT4gY29weV9pbl93aXRob3V0X3B1c2hiYWNrIHcgfmZyb206cXVldWUpO1xuICAgICAgICAgICBzdGlsbF9vcGVuKSlcbiAgICAgaW5cbiAgICAgTGlzdC5pdGVyIHN0aWxsX29wZW4gfmY6Y2xvc2U7XG4gICAgIHJldHVybiAoKSk7XG4gIHJlYWRlcjAsIHJlYWRlcjFcbjs7XG5cbmxldCBzZXRfaW5mbyB0IGluZm8gPSBzZXRfaW5mbyB0IChTb21lIGluZm8pXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4hIERlZmVycmVkX3N0ZFxuXG50eXBlICgnYSwgJ3BoYW50b20pIHQgPVxuICB7IGN1cnJlbnRfdmFsdWUgOiAnYSBNb3B0aW9uLnRcbiAgOyB0YWtlbiA6ICh1bml0LCByZWFkX3dyaXRlKSBCdmFyLnRcbiAgOyBtdXRhYmxlIHZhbHVlX2F2YWlsYWJsZSA6IHVuaXQgSXZhci50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcyB+aXRlcmF0b3JzOml0ZXIsIHNleHBfb2ZdXG5cbmxldCB2YWx1ZV9hdmFpbGFibGUgdCA9IEl2YXIucmVhZCB0LnZhbHVlX2F2YWlsYWJsZVxubGV0IGlzX2VtcHR5IHQgPSBNb3B0aW9uLmlzX25vbmUgdC5jdXJyZW50X3ZhbHVlXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgXyAodCA6IF8gdCkgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IChfLCBfKSB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5jdXJyZW50X3ZhbHVlOihjaGVjayAoTW9wdGlvbi5pbnZhcmlhbnQgaW52YXJpYW50X2EpKVxuICAgICAgfnRha2VuOihjaGVjayAoQnZhci5pbnZhcmlhbnQgVW5pdC5pbnZhcmlhbnQgaWdub3JlKSlcbiAgICAgIH52YWx1ZV9hdmFpbGFibGU6XG4gICAgICAgIChjaGVjayAoZnVuIHZhbHVlX2F2YWlsYWJsZSAtPlxuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBib29sXVxuICAgICAgICAgICAgIChJdmFyLmlzX2Z1bGwgdmFsdWVfYXZhaWxhYmxlKVxuICAgICAgICAgICAgIH5leHBlY3Q6KE1vcHRpb24uaXNfc29tZSB0LmN1cnJlbnRfdmFsdWUpKSkpXG47O1xuXG5sZXQgcGVlayB0ID0gTW9wdGlvbi5nZXQgdC5jdXJyZW50X3ZhbHVlXG5cbmxldCBwZWVrX2V4biB0ID1cbiAgaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiTXZhci5wZWVrX2V4biBjYWxsZWQgb24gZW1wdHkgbXZhclwiXTtcbiAgTW9wdGlvbi5nZXRfc29tZV9leG4gdC5jdXJyZW50X3ZhbHVlXG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBfIHQgPSBbJXNleHAgKHBlZWsgdCA6IGEgb3B0aW9uKV1cblxubW9kdWxlIFJlYWRfd3JpdGUgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICgnYSwgcmVhZF93cml0ZSkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9IGludmFyaWFudCBpbnZhcmlhbnRfYSBpZ25vcmUgdFxuZW5kXG5cbm1vZHVsZSBSZWFkX29ubHkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICgnYSwgcmVhZCkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9IGludmFyaWFudCBpbnZhcmlhbnRfYSBpZ25vcmUgdFxuZW5kXG5cbmxldCByZWFkX29ubHkgKHQgOiAoJ2EsIFs+IHJlYWQgXSkgdCkgPSAodCA6PiAoJ2EsIHJlYWQpIHQpXG5sZXQgd3JpdGVfb25seSAodCA6ICgnYSwgWz4gd3JpdGUgXSkgdCkgPSAodCA6PiAoJ2EsIHdyaXRlKSB0KVxuXG5sZXQgY3JlYXRlICgpID1cbiAgeyBjdXJyZW50X3ZhbHVlID0gTW9wdGlvbi5jcmVhdGUgKClcbiAgOyB0YWtlbiA9IEJ2YXIuY3JlYXRlICgpXG4gIDsgdmFsdWVfYXZhaWxhYmxlID0gSXZhci5jcmVhdGUgKClcbiAgfVxuOztcblxubGV0IHRha2Vfbm9uZW1wdHkgdCA9XG4gIGFzc2VydCAobm90IChpc19lbXB0eSB0KSk7XG4gIGxldCByID0gTW9wdGlvbi5nZXRfc29tZV9leG4gdC5jdXJyZW50X3ZhbHVlIGluXG4gIE1vcHRpb24uc2V0X25vbmUgdC5jdXJyZW50X3ZhbHVlO1xuICBCdmFyLmJyb2FkY2FzdCB0LnRha2VuICgpO1xuICB0LnZhbHVlX2F2YWlsYWJsZSA8LSBJdmFyLmNyZWF0ZSAoKTtcbiAgclxuOztcblxubGV0IHRha2Vfbm93X2V4biB0ID1cbiAgaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiTXZhci50YWtlX2V4biBjYWxsZWQgb24gZW1wdHkgbXZhclwiXTtcbiAgdGFrZV9ub25lbXB0eSB0XG47O1xuXG5sZXQgdGFrZV9ub3cgdCA9IGlmIG5vdCAoaXNfZW1wdHkgdCkgdGhlbiBTb21lICh0YWtlX25vbmVtcHR5IHQpIGVsc2UgTm9uZVxuXG5sZXQgcmVjIHRha2UgdCA9XG4gIGlmIG5vdCAoaXNfZW1wdHkgdClcbiAgdGhlbiByZXR1cm4gKHRha2Vfbm9uZW1wdHkgdClcbiAgZWxzZSAoXG4gICAgbGV0JWJpbmQgKCkgPSB2YWx1ZV9hdmFpbGFibGUgdCBpblxuICAgIHRha2UgdClcbjs7XG5cbmxldCBzZXQgdCB2ID1cbiAgTW9wdGlvbi5zZXRfc29tZSB0LmN1cnJlbnRfdmFsdWUgdjtcbiAgSXZhci5maWxsX2lmX2VtcHR5IHQudmFsdWVfYXZhaWxhYmxlICgpXG47O1xuXG5sZXQgdXBkYXRlIHQgfmYgPSBzZXQgdCAoZiAocGVlayB0KSlcbmxldCB1cGRhdGVfZXhuIHQgfmYgPSBzZXQgdCAoZiAocGVla19leG4gdCkpXG5sZXQgdGFrZW4gdCA9IEJ2YXIud2FpdCB0LnRha2VuXG5cbmxldCByZWMgcHV0IHQgdiA9XG4gIGlmIGlzX2VtcHR5IHRcbiAgdGhlbiAoXG4gICAgc2V0IHQgdjtcbiAgICByZXR1cm4gKCkpXG4gIGVsc2UgKFxuICAgIGxldCViaW5kICgpID0gdGFrZW4gdCBpblxuICAgIHB1dCB0IHYpXG47O1xuXG5sZXQgcGlwZV93aGVuX3JlYWR5IHQgPVxuICBsZXQgciwgdyA9IFBpcGUuY3JlYXRlICgpIGluXG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgbGV0JWJpbmQgKCkgPSB2YWx1ZV9hdmFpbGFibGUgdCBpblxuICAgIGlmIG5vdCAoUGlwZS5pc19jbG9zZWQgdylcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIHRha2Vfbm93IHQgd2l0aFxuICAgICAgfCBOb25lIC0+IGxvb3AgKClcbiAgICAgIHwgU29tZSB4IC0+XG4gICAgICAgIGxldCViaW5kICgpID0gUGlwZS53cml0ZSB3IHggaW5cbiAgICAgICAgbG9vcCAoKSlcbiAgICBlbHNlIHJldHVybiAoKVxuICBpblxuICBkb24ndF93YWl0X2ZvciAobG9vcCAoKSk7XG4gIHJcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBzdGFydCA6IHVuaXQgSXZhci50XG4gICAgOyByZXN1bHQgOiAnYSBPcl9lcnJvci50IERlZmVycmVkLnRcbiAgICB9XG5cbiAgbGV0IGNyZWF0ZSA/KHJlc3RfZXhuID0gYExvZykgZiA9XG4gICAgbGV0IHN0YXJ0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgICB7IHN0YXJ0XG4gICAgOyByZXN1bHQgPVxuICAgICAgICAobGV0JWJpbmQgKCkgPSBJdmFyLnJlYWQgc3RhcnQgaW5cbiAgICAgICAgIE1vbml0b3IudHJ5X3dpdGhfb3JfZXJyb3IgfnJlc3Q6cmVzdF9leG4gZilcbiAgICB9XG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV9vcl9lcnJvciA/KHJlc3RfZXhuID0gYExvZykgZiA9XG4gICAgbGV0IHN0YXJ0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgICB7IHN0YXJ0XG4gICAgOyByZXN1bHQgPVxuICAgICAgICAobGV0JWJpbmQgKCkgPSBJdmFyLnJlYWQgc3RhcnQgaW5cbiAgICAgICAgIE1vbml0b3IudHJ5X3dpdGhfam9pbl9vcl9lcnJvciB+cmVzdDpyZXN0X2V4biBmKVxuICAgIH1cbiAgOztcblxuICBsZXQgd2FpdCB0ID0gdC5yZXN1bHRcbiAgbGV0IHdhaXRfZXhuIHQgPSB3YWl0IHQgPj58IG9rX2V4blxuICBsZXQgc3RhcnQgdCA9IEl2YXIuZmlsbF9pZl9lbXB0eSB0LnN0YXJ0ICgpXG5cbiAgbGV0IGZvcmNlIHQgPVxuICAgIHN0YXJ0IHQ7XG4gICAgd2FpdCB0XG4gIDs7XG5cbiAgbGV0IGZvcmNlX2V4biB0ID0gZm9yY2UgdCA+Pnwgb2tfZXhuXG4gIGxldCByZXR1cm4gYSA9IGNyZWF0ZSAoZnVuICgpIC0+IHJldHVybiBhKVxuXG4gIGxldCBiaW5kIHQgfmYgPVxuICAgIGNyZWF0ZSAoZnVuICgpIC0+XG4gICAgICBsZXQlYmluZCBhID0gZm9yY2VfZXhuIHQgaW5cbiAgICAgIGZvcmNlX2V4biAoZiBhKSlcbiAgOztcblxuICBsZXQgbWFwIHQgfmYgPSBjcmVhdGUgKGZ1biAoKSAtPiBmb3JjZV9leG4gdCA+PnwgZilcbiAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIE1vbmFkLk1ha2UgKFQpXG5cbmxldCBiaW5kJyB0IGYgPSBiaW5kIHQgfmY6KGZ1biBhIC0+IGNyZWF0ZSAoZnVuICgpIC0+IGYgYSkpXG5sZXQgaXNfZm9yY2VkIHQgPSBJdmFyLmlzX2Z1bGwgdC5zdGFydFxubGV0IGlzX2RldGVybWluZWQgdCA9IERlZmVycmVkLmlzX2RldGVybWluZWQgdC5yZXN1bHRcbmxldCBwZWVrIHQgPSBEZWZlcnJlZC5wZWVrIHQucmVzdWx0XG5sZXQgcGVla19leG4gdCA9IE9wdGlvbi5tYXAgKHBlZWsgdCkgfmY6b2tfZXhuXG4iLCJvcGVuIENvcmVcblxudHlwZSAnYSB0ID0geyB3YWl0cyA6ICdhIEl2YXIudCBRdWV1ZS50IH0gW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGNyZWF0ZSAoKSA9IHsgd2FpdHMgPSBRdWV1ZS5jcmVhdGUgKCkgfVxubGV0IHdhaXQgdCA9IERlZmVycmVkLmNyZWF0ZSAoZnVuIGl2YXIgLT4gUXVldWUuZW5xdWV1ZSB0LndhaXRzIGl2YXIpXG5sZXQgc2lnbmFsIHQgYSA9IE9wdGlvbi5pdGVyIChRdWV1ZS5kZXF1ZXVlIHQud2FpdHMpIH5mOihmdW4gaXZhciAtPiBJdmFyLmZpbGxfZXhuIGl2YXIgYSlcblxubGV0IGJyb2FkY2FzdCB0IGEgPVxuICBRdWV1ZS5pdGVyIHQud2FpdHMgfmY6KGZ1biBpdmFyIC0+IEl2YXIuZmlsbF9leG4gaXZhciBhKTtcbiAgUXVldWUuY2xlYXIgdC53YWl0c1xuOztcbiIsIm9wZW4gQ29yZVxuaW5jbHVkZSBHY1xuXG4oKiogW2FkZF9maW5hbGl6ZXIgZiB4XSBpcyBsaWtlIFtHYy5maW5hbGlzZSBmIHhdLCBleGNlcHQgdGhhdCB0aGUgZmluYWxpemVyIGlzIGd1YXJhbnRlZWRcbiAgICB0byBydW4gYXMgYW4gQXN5bmMgam9iIChpLmUuIHdpdGhvdXQgaW50ZXJydXB0aW5nIG90aGVyIEFzeW5jIGpvYnMpLiAgVW5wcm90ZWN0ZWQgdXNlXG4gICAgb2YgW0NhbWwuR2MuZmluYWxpc2VdIG9yIFtDb3JlLkdjLmFkZF9maW5hbGl6ZXJdIGluIEFzeW5jIHByb2dyYW1zIGlzIHdyb25nLCBiZWNhdXNlXG4gICAgdGhlIGZpbmFsaXplcnMgd29uJ3QgaG9sZCB0aGUgYXN5bmMgbG9jaywgYW5kIHRodXMgY291bGQgaW50ZXJsZWF2ZSBhcmJpdHJhcmlseSB3aXRoXG4gICAgYXN5bmMgam9icy4gKilcbmxldCBhZGRfZmluYWxpemVyIGhlYXBfYmxvY2sgZiA9IFNjaGVkdWxlci4oYWRkX2ZpbmFsaXplciAodCAoKSkpIGhlYXBfYmxvY2sgZlxuXG5sZXQgYWRkX2ZpbmFsaXplcl9leG4gaGVhcF9ibG9jayBmID0gU2NoZWR1bGVyLihhZGRfZmluYWxpemVyX2V4biAodCAoKSkpIGhlYXBfYmxvY2sgZlxubGV0IGFkZF9maW5hbGl6ZXJfbGFzdCBoZWFwX2Jsb2NrIGYgPSBTY2hlZHVsZXIuKGFkZF9maW5hbGl6ZXJfbGFzdCAodCAoKSkpIGhlYXBfYmxvY2sgZlxuXG5sZXQgYWRkX2ZpbmFsaXplcl9sYXN0X2V4biBoZWFwX2Jsb2NrIGYgPVxuICBTY2hlZHVsZXIuKGFkZF9maW5hbGl6ZXJfbGFzdF9leG4gKHQgKCkpKSBoZWFwX2Jsb2NrIGZcbjs7XG5cbm1vZHVsZSBBbGFybSA9IHN0cnVjdFxuICBtb2R1bGUgQWxhcm0gPSBHYy5FeHBlcnQuQWxhcm1cblxuICB0eXBlIHQgPSBBbGFybS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGNyZWF0ZSBmID0gU2NoZWR1bGVyLihjcmVhdGVfYWxhcm0gKHQgKCkpKSBmXG4gIGxldCBkZWxldGUgPSBBbGFybS5kZWxldGVcbmVuZFxuIiwiKCoqIFRoaXMgbW9kdWxlIGRlZmluZXMgc2lnbmF0dXJlcyB0aGF0IGV4dGVuZCBbQ29yZS5JbnZhcmlhbnRdIHdpdGggYW4gW0FzeW5jXVxuICAgIHN1Ym1vZHVsZSBmb3IgaW52YXJpYW50cyB0aGF0IHVzZSBhc3luYyBjb21wdXRhdGlvbiBhbmQgcmV0dXJuIFt1bml0IERlZmVycmVkLnRdLiAqKVxuXG5vcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIEFzeW5jID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIC0+IHVuaXQgRGVmZXJyZWQudFxuICB0eXBlICdhIGludiA9ICdhIHRcblxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgaW52YXJpYW50IDogdCBpbnZcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBpbnZhcmlhbnQgOiAnYSBpbnYgLT4gJ2EgdCBpbnZcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBpbnZhcmlhbnQgOiAnYSBpbnYgLT4gJ2IgaW52IC0+ICgnYSwgJ2IpIHQgaW52XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGludmFyaWFudCA6ICdhIGludiAtPiAnYiBpbnYgLT4gJ2MgaW52IC0+ICgnYSwgJ2IsICdjKSB0IGludlxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBc3luY19pbnZhcmlhbnQgPSBzaWdcbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBDb3JlLkludmFyaWFudFxuXG4gIG1vZHVsZSBBc3luYyA6IHNpZ1xuICAgIG9wZW4gQXN5bmNcblxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSBBc3luYy50XG5cbiAgICBtb2R1bGUgdHlwZSBTID0gU1xuICAgIG1vZHVsZSB0eXBlIFMxID0gUzFcbiAgICBtb2R1bGUgdHlwZSBTMiA9IFMyXG4gICAgbW9kdWxlIHR5cGUgUzMgPSBTM1xuXG4gICAgdmFsIGludmFyaWFudFxuICAgICAgOiAgU291cmNlX2NvZGVfcG9zaXRpb24udFxuICAgICAgLT4gJ2FcbiAgICAgIC0+ICgnYSAtPiBTZXhwLnQpXG4gICAgICAtPiAodW5pdCAtPiB1bml0IERlZmVycmVkLnQpXG4gICAgICAtPiB1bml0IERlZmVycmVkLnRcblxuICAgICgqKiBbY2hlY2tfZmllbGRdIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHJlY29yZCBmaWVsZHMgd2hlbiB1c2luZyBbW0BAZGVyaXZpbmcgZmllbGRzXV0uXG4gICAgICAgIElkaW9tYXRpYyB1c2FnZSBsb29rcyBsaWtlOlxuXG4gICAgICAgIHtbXG4gICAgICAgICAgdHlwZSB0ID0geyBmb28gOiBGb28udCA7IGJhciA6IEJhci50IH1cbiAgICAgICAgICBbQEBkZXJpdmluZyBmaWVsZHNdXG5cbiAgICAgICAgICBsZXQgaW52YXJpYW50IHQgPVxuICAgICAgICAgICAgSW52YXJpYW50LkFzeW5jLmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgICAgICAgICAgIGxldCBjaGVjayBpbnYgPSBJbnZhcmlhbnQuQXN5bmMuY2hlY2tfZmllbGQgdCBpbnYgaW5cbiAgICAgICAgICAgICAgRmllbGRzLmZvbGQgfmluaXQ6KHJldHVybiAoKSlcbiAgICAgICAgICAgICAgICB+Zm9vOiAoY2hlY2sgRm9vLmludmFyaWFudClcbiAgICAgICAgICAgICAgICB+YmFyOiAoY2hlY2sgQmFyLmludmFyaWFudCkgXX1cblxuICAgICAgICBXaGVuIHNvbWUgZmllbGRzIGhhdmUgc3luY2hyb25vdXMgaW52YXJpYW50cywgb3IgZG8gbm90IG5lZWQgdG8gYmUgY2hlY2tlZCwgaXRcbiAgICAgICAgbWF5IGJlIHVzZWZ1bCB0byBkZWZpbmUgYSBzZWNvbmQgd3JhcHBlciBhcm91bmQgW2NoZWNrX2ZpZWxkXTpcblxuICAgICAgICB7W1xuICAgICAgICAgIHR5cGUgdCA9IHsgZm9vIDogRm9vLnQgOyBiYXIgOiBCYXIudCA7IHF1dXggOiBRdXV4LnQgfVxuICAgICAgICAgIFtAQGRlcml2aW5nIGZpZWxkc11cblxuICAgICAgICAgIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgICAgICAgICBJbnZhcmlhbnQuQXN5bmMuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgbGV0IGNoZWNrJyBpbnYgPSBJbnZhcmlhbnQuQXN5bmMuY2hlY2tfZmllbGQgdCBpbnYgaW5cbiAgICAgICAgICAgICAgbGV0IGNoZWNrIGludiA9IGNoZWNrJyAoZnVuIHggLT4gaW52IHg7IHJldHVybiAoKSkgaW5cbiAgICAgICAgICAgICAgRmllbGRzLmZvbGQgfmluaXQ6KHJldHVybiAoKSlcbiAgICAgICAgICAgICAgICB+Zm9vOiAgKGNoZWNrJyBGb28uaW52YXJpYW50KVxuICAgICAgICAgICAgICAgIH5iYXI6ICAoY2hlY2sgIEJhci5pbnZhcmlhbnQpXG4gICAgICAgICAgICAgICAgfnF1dXg6IChjaGVjayAgaWdub3JlKSBdfSAqKVxuICAgIHZhbCBjaGVja19maWVsZCA6ICdhIC0+ICdiIHQgLT4gdW5pdCBEZWZlcnJlZC50IC0+ICgnYSwgJ2IpIEZpZWxkLnQgLT4gdW5pdCBEZWZlcnJlZC50XG4gIGVuZFxuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBEZWZlcnJlZC5MZXRfc3ludGF4XG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgQ29yZS5JbnZhcmlhbnRcblxubW9kdWxlIEFzeW5jID0gc3RydWN0XG4gIGluY2x1ZGUgQXN5bmNfaW52YXJpYW50X2ludGYuQXN5bmNcblxuICBsZXQgaW52YXJpYW50IGhlcmUgdCBzZXhwX29mX3QgZiA9XG4gICAgbWF0Y2glbWFwIE1vbml0b3IudHJ5X3dpdGggfnJ1bjpgU2NoZWR1bGUgfnJlc3Q6YExvZyBmIH5leHRyYWN0X2V4bjp0cnVlIHdpdGhcbiAgICB8IE9rICgpIC0+ICgpXG4gICAgfCBFcnJvciBleG4gLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJpbnZhcmlhbnQgZmFpbGVkXCIgfl86KGhlcmUgOiBTb3VyY2VfY29kZV9wb3NpdGlvbi50KSAoZXhuIDogZXhuKSB+XzoodCA6IHQpXVxuICA7O1xuXG4gIGxldCBjaGVja19maWVsZCB0IGYgd2FpdF9mb3JfcHJldmlvdXMgZmllbGQgPVxuICAgIGxldCViaW5kICgpID0gd2FpdF9mb3JfcHJldmlvdXMgaW5cbiAgICBtYXRjaCVtYXBcbiAgICAgIE1vbml0b3IudHJ5X3dpdGggfnJ1bjpgU2NoZWR1bGUgfnJlc3Q6YExvZyB+ZXh0cmFjdF9leG46dHJ1ZSAoZnVuICgpIC0+XG4gICAgICAgIGYgKEZpZWxkLmdldCBmaWVsZCB0KSlcbiAgICB3aXRoXG4gICAgfCBPayAoKSAtPiAoKVxuICAgIHwgRXJyb3IgZXhuIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcInByb2JsZW0gd2l0aCBmaWVsZFwiIH5maWVsZDooRmllbGQubmFtZSBmaWVsZCA6IHN0cmluZykgKGV4biA6IGV4bildXG4gIDs7XG5lbmRcbiIsIigqKiBDb250YWlucyBBc3luYydzIGNvcmUgZGF0YSBzdHJ1Y3R1cmVzLCBsaWtlIHt7IUFzeW5jX2tlcm5lbC5EZWZlcnJlZH1bRGVmZXJyZWRdfSxcbiAgICB7eyFBc3luY19rZXJuZWwuSXZhcn1bSXZhcl19LCBhbmQge3shQXN5bmNfa2VybmVsLkNsb2NrX2ludGYuQ2xvY2t9W0Nsb2NrXX0uXG5cbiAgICBbQXN5bmNfa2VybmVsXSBpcyBkZXNpZ25lZCB0byBkZXBlbmQgb25seSBvbiB7eyFDb3JlfVtDb3JlXX0gYW5kIHNvIGlzIG1vcmVcbiAgICBwbGF0Zm9ybS1pbmRlcGVuZGVudC4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgQXN5bmNfa2VybmVsX2NvbmZpZyA9IEFzeW5jX2tlcm5lbF9jb25maWdcbm1vZHVsZSBBc3luY19rZXJuZWxfcmVxdWlyZV9leHBsaWNpdF90aW1lX3NvdXJjZSA9IFJlcXVpcmVfZXhwbGljaXRfdGltZV9zb3VyY2Vcbm1vZHVsZSBBc3luY19rZXJuZWxfc2NoZWR1bGVyID0gQXN5bmNfa2VybmVsX3NjaGVkdWxlclxubW9kdWxlIEJ2YXIgPSBCdmFyXG5tb2R1bGUgQ2xvY2tfbnMgPSBDbG9ja19uc1xubW9kdWxlIENvbmRpdGlvbiA9IEFzeW5jX2NvbmRpdGlvblxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWRcbm1vZHVsZSBFeGVjdXRpb25fY29udGV4dCA9IEV4ZWN1dGlvbl9jb250ZXh0XG5tb2R1bGUgR2MgPSBBc3luY19nY1xubW9kdWxlIEludmFyaWFudCA9IEFzeW5jX2ludmFyaWFudFxubW9kdWxlIEl2YXIgPSBJdmFyXG5tb2R1bGUgTGF6eV9kZWZlcnJlZCA9IExhenlfZGVmZXJyZWRcbm1vZHVsZSBNb25hZF9zZXF1ZW5jZSA9IE1vbmFkX3NlcXVlbmNlXG5tb2R1bGUgTW9uaXRvciA9IE1vbml0b3Jcbm1vZHVsZSBNdmFyID0gTXZhclxubW9kdWxlIFBpcGUgPSBQaXBlXG5tb2R1bGUgUHJpb3JpdHkgPSBQcmlvcml0eVxubW9kdWxlIFNlcXVlbmNlciA9IFRocm90dGxlLlNlcXVlbmNlclxubW9kdWxlIFN0cmVhbSA9IEFzeW5jX3N0cmVhbVxubW9kdWxlIFN5bmNocm9ub3VzX3RpbWVfc291cmNlID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2Vcbm1vZHVsZSBUYWlsID0gVGFpbFxubW9kdWxlIFRocm90dGxlID0gVGhyb3R0bGVcbm1vZHVsZSBUaHJvdHRsZWQgPSBUaHJvdHRsZWRcbm1vZHVsZSBUaW1lX3NvdXJjZSA9IFRpbWVfc291cmNlXG5cbigqKiB7MiBUb3BsZXZlbCBmdW5jdGlvbnMgfVxuXG4gICAgVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgYnJvYWRseSB1c2VmdWwgd2hlbiB3cml0aW5nIEFzeW5jIHByb2dyYW1zLCBhbmQgc28gYXJlIG1hZGVcbiAgICBhdmFpbGFibGUgYXQgdGhlIHRvcGxldmVsLiAqKVxuXG5sZXQgYWZ0ZXIgPSBDbG9ja19ucy5hZnRlclxubGV0IGF0ID0gQ2xvY2tfbnMuYXRcbmxldCBjYXRjaCA9IE1vbml0b3IuY2F0Y2hcbmxldCBjaG9pY2UgPSBEZWZlcnJlZC5jaG9pY2VcbmxldCBjaG9vc2UgPSBEZWZlcnJlZC5jaG9vc2VcbmxldCBkb24ndF93YWl0X2ZvciA9IERlZmVycmVkLmRvbid0X3dhaXRfZm9yXG5sZXQgZXZlcnkgPSBDbG9ja19ucy5ldmVyeVxubGV0IG5ldmVyID0gRGVmZXJyZWQubmV2ZXJcbmxldCBzY2hlZHVsZSA9IFNjaGVkdWxlci5zY2hlZHVsZVxubGV0IHNjaGVkdWxlJyA9IFNjaGVkdWxlci5zY2hlZHVsZSdcbmxldCB0cnlfd2l0aCA9IE1vbml0b3IudHJ5X3dpdGhcbmxldCB1cG9uID0gRGVmZXJyZWQudXBvblxubGV0IHdpdGhfdGltZW91dCA9IENsb2NrX25zLndpdGhfdGltZW91dFxubGV0IHdpdGhfdGltZW91dF9leG4gPSBDbG9ja19ucy53aXRoX3RpbWVvdXRfZXhuXG5sZXQgd2l0aGluID0gU2NoZWR1bGVyLndpdGhpblxubGV0IHdpdGhpbicgPSBTY2hlZHVsZXIud2l0aGluJ1xuXG4oKiogezIgSW5maXggb3BlcmF0b3JzIGFuZCBbTGV0X3N5bnRheF0gc3VwcG9ydH0gKilcblxuaW5jbHVkZSAoRGVmZXJyZWQgOiBNb25hZC5JbmZpeCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBEZWZlcnJlZC50KVxuXG4oKiogZXF1aXZhbGVudCB0byB7IURlZmVycmVkLnVwb259LiAqKVxubGV0ICggPj4+ICkgPSBEZWZlcnJlZC5JbmZpeC4oID4+PiApXG5cbigqKiBlcXVpdmFsZW50IHRvIHshRGVmZXJyZWQuUmVzdWx0LmJpbmR9LiAqKVxubGV0ICggPj49PyApID0gRGVmZXJyZWQuUmVzdWx0LiggPj49IClcblxuKCoqIGVxdWl2YWxlbnQgdG8geyFEZWZlcnJlZC5SZXN1bHQubWFwfS4gKilcbmxldCAoID4+fD8gKSA9IERlZmVycmVkLlJlc3VsdC4oID4+fCApXG5cbmluY2x1ZGUgRGVmZXJyZWQuTGV0X3N5bnRheFxuXG4oKiovKiopXG5cbigqKiBUaGUgbW9kdWxlcyBpbiBbQXN5bmNfa2VybmVsX3ByaXZhdGVdIGFyZSB1c2VkIGZvciBjb25zdHJ1Y3RpbmcgYW5kIHRlc3RpbmcgQXN5bmMsIGFuZFxuICAgIHNob3VsZCBub3Qgb3RoZXJ3aXNlIGJlIHVzZWQuICopXG5tb2R1bGUgQXN5bmNfa2VybmVsX3ByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIERlYnVnID0gRGVidWdcbiAgbW9kdWxlIEl2YXIwID0gSXZhcjBcbiAgbW9kdWxlIEl2YXJfZmlsbGVyID0gSXZhcl9maWxsZXJcbiAgbW9kdWxlIEpvYiA9IEpvYlxuICBtb2R1bGUgU3RhY2tfb3JfY291bnRlciA9IFN0YWNrX29yX2NvdW50ZXJcbmVuZFxuXG4oKiovKiopXG5cbigqIFRoaXMgdGVzdCBtdXN0IGJlIGluIHRoaXMgbGlicmFyeSwgYmVjYXVzZSBpdCByZXF1aXJlcyBbcmV0dXJuXSB0byBiZSBpbmxpbmVkLiAgTW92aW5nXG4gICBpdCB0byBhbm90aGVyIGxpYnJhcnkgd2lsbCBjYXVzZSBpdCB0byBicmVhayB3aXRoIFtYX0xJQlJBUllfSU5MSU5JTkc9ZmFsc2VdLiAqKVxubGV0JXRlc3RfdW5pdCBcIltyZXR1cm4gKCldIGRvZXMgbm90IGFsbG9jYXRlXCIgPVxuICBsZXQgdzEgPSBHYy5taW5vcl93b3JkcyAoKSBpblxuICBpZ25vcmUgKFN5cy5vcGFxdWVfaWRlbnRpdHkgKHJldHVybiAoKSkgOiBfIERlZmVycmVkLnQpO1xuICBpZ25vcmUgKFN5cy5vcGFxdWVfaWRlbnRpdHkgKERlZmVycmVkLnJldHVybiAoKSkgOiBfIERlZmVycmVkLnQpO1xuICBpZ25vcmUgKFN5cy5vcGFxdWVfaWRlbnRpdHkgKERlZmVycmVkLkxldF9zeW50YXgucmV0dXJuICgpKSA6IF8gRGVmZXJyZWQudCk7XG4gIGlnbm9yZSAoU3lzLm9wYXF1ZV9pZGVudGl0eSAoRGVmZXJyZWQuTGV0X3N5bnRheC5MZXRfc3ludGF4LnJldHVybiAoKSkgOiBfIERlZmVycmVkLnQpO1xuICBsZXQgdzIgPSBHYy5taW5vcl93b3JkcyAoKSBpblxuICBbJXRlc3RfcmVzdWx0OiBpbnRdIHcyIH5leHBlY3Q6dzFcbjs7XG4iXX0=
