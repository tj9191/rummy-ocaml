// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Protocol_version_header__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Protocol_version_header = [0],
    Protocol_version_header$0 = [0, Protocol_version_header];
   runtime.caml_register_global
    (0, Protocol_version_header$0, "Protocol_version_header__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header__Known_protocol
//# unitInfo: Requires: Bin_prot__Common, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Write, Bin_shape, Core, Core__Char, Core__Int, Core__List, Core__String, Inline_test_config, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Krb = "Krb",
    cst_Krb_test_mode = "Krb_test_mode",
    cst_Protocol_version_header_Kn$0 =
      "Protocol_version_header__Known_protocol",
    cst_Rpc = "Rpc",
    cst_krb = "krb",
    cst_krb_test_mode = "krb_test_mode",
    cst_protocol_version_header$0 = "protocol_version_header",
    cst_rpc = "rpc",
    cst_src_known_protocol_ml$0 = "src/known_protocol.ml",
    cst_t$1 = "t",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, [0, 2, 0]]],
    error_source_005 = "src/known_protocol.ml.t",
    retired_krb_word = "KRB",
    Core_List = global_data.Core__List,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Core_Char = global_data.Core__Char,
    Core_String = global_data.Core__String;
   global_data.Bin_prot__Read;
   global_data.Bin_prot__Common;
   global_data.Bin_prot__Write;
   var
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Bin_shape = global_data.Bin_shape,
    Core_Int = global_data.Core__Int,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header_Kn$0);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_known_protocol_ml$0);
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_protocol_version_header$0,
     "known_protocol.ml");
   var
    compare = runtime.caml_int_compare,
    _o_ = [0, cst_src_known_protocol_ml$0, 29, 2],
    _n_ = [0, cst_src_known_protocol_ml$0, 30, 2],
    _m_ = [0, cst_src_known_protocol_ml$0, 31, 2],
    _l_ = [0, cst_src_known_protocol_ml$0, 32, 2],
    cst_KRB2 = "KRB2",
    cst_KBT = "KBT",
    cst_RPC = "RPC",
    _a_ = [0, cst_Krb],
    _b_ = [0, cst_Krb_test_mode],
    _c_ = [0, cst_Rpc],
    _d_ =
      [0,
       [0, cst_Krb, 0],
       [0, [0, cst_Krb_test_mode, 0], [0, [0, cst_Rpc, 0], 0]]],
    cst_t = cst_t$1,
    cst_src_known_protocol_ml_3_0 = "src/known_protocol.ml:3:0",
    cst_t$0 = cst_t$1,
    cst_src_known_protocol_ml = cst_src_known_protocol_ml$0,
    cst_magic_numbers = "magic numbers",
    cst_protocol_version_header = cst_protocol_version_header$0,
    cst_Protocol_version_header_Kn = cst_Protocol_version_header_Kn$0;
   function t_of_sexp(sexp_006){
    a:
    {
     if(0 === sexp_006[0]){
      var _w_ = sexp_006[1];
      b:
      if(caml_string_notequal(_w_, cst_Krb)){
       c:
       if(caml_string_notequal(_w_, cst_Krb_test_mode)){
        if(caml_string_notequal(_w_, cst_Rpc)){
         if(! caml_string_notequal(_w_, cst_krb)) break b;
         if(! caml_string_notequal(_w_, cst_krb_test_mode)) break c;
         if(caml_string_notequal(_w_, cst_rpc)) break a;
        }
        return 2;
       }
       return 1;
      }
      return 0;
     }
     var _x_ = sexp_006[1];
     if(! _x_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_005, sexp_006);
     var _y_ = _x_[1];
     if(0 !== _y_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_005, sexp_006);
     var _z_ = _y_[1];
     b:
     if(caml_string_notequal(_z_, cst_Krb)){
      c:
      if(caml_string_notequal(_z_, cst_Krb_test_mode)){
       if(caml_string_notequal(_z_, cst_Rpc)){
        if(! caml_string_notequal(_z_, cst_krb)) break b;
        if(! caml_string_notequal(_z_, cst_krb_test_mode)) break c;
        if(caml_string_notequal(_z_, cst_rpc)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_005, sexp_006);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var
    _e_ = caml_call1(Bin_prot_Shape[5], _d_),
    _f_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), 0, _e_], 0],
    _g_ = caml_call1(Bin_shape[4][1], cst_src_known_protocol_ml_3_0),
    group = caml_call2(Bin_prot_Shape[2], _g_, _f_),
    _h_ = caml_call1(Bin_shape[2][1], cst_t$0);
   caml_call1(caml_call2(Bin_prot_Shape[10], group, _h_), 0);
   function magic_word(param){
    switch(param){
      case 0:
       return cst_KRB2;
      case 1:
       return cst_KBT;
      default: return cst_RPC;
    }
   }
   function gen_magic_number(word){
    function _u_(acc, c){
     return (acc * 256 | 0) + caml_call1(Core_Char[11], c) | 0;
    }
    var _v_ = caml_call1(Core_String[70], word);
    return caml_call3(Core_List[20], _v_, 0, _u_);
   }
   function magic_number(t){return gen_magic_number(magic_word(t));}
   function _i_(p){return [0, magic_number(p), p];}
   var
    _j_ = caml_call2(Core_List[51], all, _i_),
    by_magic_number = caml_call1(Core_Int[98][15], _j_);
   function _k_(param){
    var _q_ = gen_magic_number(retired_krb_word);
    if(! caml_call2(Core[90], _q_, 4346443))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
    var _r_ = magic_number(0);
    if(! caml_call2(Core[90], _r_, 843207243))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    var _s_ = magic_number(1);
    if(! caml_call2(Core[90], _s_, 5521995))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    var _t_ = magic_number(2);
    if(caml_call2(Core[90], _t_, 4411474)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
   }
   caml_call8
    (Ppx_inline_test_lib[9],
     Inline_test_config,
     cst_magic_numbers,
     0,
     cst_src_known_protocol_ml,
     28,
     0,
     223,
     _k_);
   var
    all_magic_numbers_including_re =
      [246,
       function(param){
        var
         _p_ =
           [0, retired_krb_word, caml_call2(Core_List[51], all, magic_word)];
        return caml_call2(Core_List[51], _p_, gen_magic_number);
       }],
    For_test = [0, all_magic_numbers_including_re];
   caml_call1(Ppx_inline_test_lib[7], cst_protocol_version_header);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header_Kn);
   var
    Protocol_version_header_Known_ =
      [0,
       compare,
       all,
       t_of_sexp,
       sexp_of_t,
       magic_number,
       by_magic_number,
       For_test];
   runtime.caml_register_global
    (57, Protocol_version_header_Known_, cst_Protocol_version_header_Kn$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header__List_with_max_len_intf
//# unitInfo: Requires: Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Protocol_version_header_Li =
      "Protocol_version_header__List_with_max_len_intf",
    cst_protocol_version_header = "protocol_version_header";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header_Li);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header);
   caml_call1(Ppx_expect_runtime[1][1], "src/list_with_max_len_intf.ml");
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_protocol_version_header,
     "list_with_max_len_intf.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_protocol_version_header);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header_Li);
   var Protocol_version_header_List_w = [0];
   runtime.caml_register_global
    (11, Protocol_version_header_List_w, cst_Protocol_version_header_Li);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header__List_with_max_len
//# unitInfo: Requires: Base__Exn, Bin_prot__Read, Bin_prot__Shape, Bin_shape, Core, Core__Info, Core__List, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Protocol_version_header__List_with_max_len_intf, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Protocol_version_header_Li =
      "Protocol_version_header__List_with_max_len",
    cst_a$1 = "a",
    cst_protocol_version_header = "protocol_version_header",
    cst_t$1 = "t",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_List = global_data.Core__List,
    Core = global_data.Core,
    Core_Info = global_data.Core__Info,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Bin_prot_Read = global_data.Bin_prot__Read,
    Base_Exn = global_data.Base__Exn,
    Bin_shape = global_data.Bin_shape,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header_Li);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header);
   caml_call1(Ppx_expect_runtime[1][1], "src/list_with_max_len.ml");
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_protocol_version_header,
     "list_with_max_len.ml");
   caml_call1(Ppx_inline_test_lib[7], cst_protocol_version_header);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header_Li);
   var
    _a_ = [0, "max_len"],
    _b_ = [0, "len"],
    _c_ = [0, "context"],
    cst_List_is_too_large = "List is too large",
    cst_t$0 = cst_t$1,
    cst_a = cst_a$1,
    cst_src_list_with_max_len_ml_7 = "src/list_with_max_len.ml:7:14",
    cst_a$0 = cst_a$1,
    cst_t = cst_t$1,
    cst_src_list_with_max_len_ml_7$0 = "src/list_with_max_len.ml:7:2",
    Protocol_version_header_List_w =
      [0,
       function(Config){
        var
         max_len = Config[1],
         context = Config[2],
         _d_ = caml_call1(Bin_shape[3][1], cst_a),
         _e_ = caml_call1(Bin_shape[4][1], cst_src_list_with_max_len_ml_7),
         _f_ = caml_call2(Bin_prot_Shape[11], _e_, _d_),
         _g_ = caml_call1(Core[456], _f_),
         _h_ = [0, caml_call1(Bin_shape[3][1], cst_a$0), 0],
         _i_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), _h_, _g_], 0],
         _j_ = caml_call1(Bin_shape[4][1], cst_src_list_with_max_len_ml_7$0),
         group = caml_call2(Bin_prot_Shape[2], _j_, _i_);
        function bin_shape_t(a){
         var _A_ = caml_call1(Bin_shape[2][1], cst_t$0);
         return caml_call1
                 (caml_call2(Bin_prot_Shape[10], group, _A_), [0, a, 0]);
        }
        function bin_size_t(size_of_a, v){
         return caml_call2(Core[457], size_of_a, v);
        }
        function bin_write_t(write_a, buf, pos, v){
         return caml_call4(Core[459], write_a, buf, pos, v);
        }
        function bin_writer_t(bin_writer_a){
         function _w_(v){
          var _x_ = bin_writer_a[2];
          return function(_y_, _z_){return bin_write_t(_x_, v, _y_, _z_);};
         }
         return [0, function(v){return bin_size_t(bin_writer_a[1], v);}, _w_];
        }
        var bin_read_t = Core_List[158];
        function bin_read_t$0(bin_read_el, buf, pos_ref){
         try{
          var
           _v_ =
             caml_call4(Bin_prot_Read[40], max_len, bin_read_el, buf, pos_ref);
          return _v_;
         }
         catch(exn$0){
          var
           exn = caml_wrap_exception(exn$0),
           _u_ = caml_call1(Core_Info[12], context);
          return caml_call2(Base_Exn[8], exn, _u_);
         }
        }
        function bin_reader_t(bin_reader_a){
         var
          _q_ = caml_call1(bin_read_t, bin_reader_a[1]),
          _r_ = bin_reader_a[1];
         return [0,
                 function(_s_, _t_){return bin_read_t$0(_r_, _s_, _t_);},
                 _q_];
        }
        function bin_t(bin_a){
         var _o_ = bin_reader_t(bin_a[3]), _p_ = bin_writer_t(bin_a[2]);
         return [0, bin_shape_t(bin_a[1]), _p_, _o_];
        }
        function of_list_exn(l){
         var len = caml_call1(Core_List[45], l);
         if(caml_call2(Core[91], len, max_len)){
          var
           _k_ = [0, [1, [0, _a_, [0, caml_call1(Core[389], max_len), 0]]], 0],
           _l_ = [0, [1, [0, _b_, [0, caml_call1(Core[389], len), 0]]], _k_],
           _m_ =
             [0,
              [1, [0, _c_, [0, caml_call1(Core_Info[9], context), 0]]],
              _l_],
           _n_ =
             [1,
              [0,
               caml_call1(Sexplib0_Sexp_conv[7], cst_List_is_too_large),
               _m_]];
          caml_call1(Core[261], _n_);
         }
         return l;
        }
        var sexp_of_t = Core_List[6];
        function t_of_sexp(t_of_a, sexp){
         var t = caml_call2(Core_List[5], t_of_a, sexp);
         return of_list_exn(t);
        }
        return [0,
                bin_shape_t,
                bin_size_t,
                bin_write_t,
                bin_read_t$0,
                bin_read_t,
                bin_writer_t,
                bin_reader_t,
                bin_t,
                t_of_sexp,
                sexp_of_t,
                of_list_exn,
                max_len];
       }];
   runtime.caml_register_global
    (29, Protocol_version_header_List_w, cst_Protocol_version_header_Li);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header
//# unitInfo: Requires: Base__Or_error, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Type_class, Bin_shape, Core, Core__Fn, Core__Info, Core__Int, Core__List, Core__Map, Core__Or_error, Core__Set, Inline_test_config, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Protocol_version_header__Known_protocol, Protocol_version_header__List_with_max_len, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Protocol_version_header$1 = "Protocol_version_header",
    cst_Protocol_version_header_ne$3 =
      "[Protocol_version_header.negotiate]: conflicting magic protocol numbers",
    cst_additional_magic_numbers = "additional_magic_numbers",
    cst_max_supported_version = "max_supported_version",
    cst_peer_protocol = "peer_protocol",
    cst_protocol_version_header$0 = "protocol_version_header",
    cst_src_protocol_version_heade$2 = "src/protocol_version_header.ml",
    cst_t$3 = "t",
    cst_us_protocol = "us_protocol",
    cst_us_versions = "us_versions",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Core_Int = global_data.Core__Int,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Protocol_version_header_Known_ =
      global_data.Protocol_version_header__Known_protocol,
    Core_Map = global_data.Core__Map,
    Bin_prot_Read = global_data.Bin_prot__Read,
    Core_List = global_data.Core__List,
    Bin_prot_Type_class = global_data.Bin_prot__Type_class,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Or_error = global_data.Core__Or_error,
    Core_Set = global_data.Core__Set,
    Base_Or_error = global_data.Base__Or_error,
    Core_Fn = global_data.Core__Fn,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Info = global_data.Core__Info,
    Protocol_version_header_List_w =
      global_data.Protocol_version_header__List_with_max_len,
    Bin_shape = global_data.Bin_shape,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header$1);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_src_protocol_version_heade$2);
   caml_call2
    (Ppx_inline_test_lib[6],
     cst_protocol_version_header$0,
     "protocol_version_header.ml");
   var
    _D_ = [0, cst_src_protocol_version_heade$2, 202, 2],
    _C_ = [0, cst_src_protocol_version_heade$2, 203, 2],
    _B_ = [0, cst_src_protocol_version_heade$2, 204, 2],
    _u_ = [0, cst_us_versions],
    cst_No_magic_numbers_seen = "No magic numbers seen",
    _r_ = [0, "Unknown"],
    _s_ = [0, cst_peer_protocol],
    _t_ = [0, cst_us_protocol],
    cst_Protocol_version_header_ne$2 = cst_Protocol_version_header_ne$3,
    _m_ = [0, "protocol"],
    _n_ = [0, "peer_versions"],
    _o_ = [0, cst_us_versions],
    cst_Protocol_version_header_ne$0 =
      "[Protocol_version_header.negotiate]: no shared version numbers",
    _p_ = [0, cst_peer_protocol],
    _q_ = [0, cst_us_protocol],
    cst_Protocol_version_header_ne$1 = cst_Protocol_version_header_ne$3,
    _k_ = [0, "versions"],
    _l_ = [0, "protocols"],
    cst_Protocol_version_header_ne =
      "[Protocol_version_header.negotiate]: multiple magic numbers seen.",
    _i_ = [0, "known_protocol_magic_numbers"],
    _j_ = [0, cst_additional_magic_numbers],
    cst_additional_magic_numbers_s$0 =
      "[additional_magic_numbers] shouldn't be overlapping with potential [protocol_magic_number]s",
    _g_ = [0, cst_additional_magic_numbers],
    _h_ = [0, cst_max_supported_version],
    cst_additional_magic_numbers_s =
      "[additional_magic_numbers] shouldn't be within [max_supported_version] range",
    _e_ = [0, "supported_versions"],
    _f_ = [0, cst_max_supported_version],
    cst_Unable_to_advertise_versio =
      "Unable to advertise versions larger than max supported version",
    cst_Protocol_version_header = cst_Protocol_version_header$1,
    cst_t = cst_t$3,
    cst_src_protocol_version_heade = "src/protocol_version_header.ml:14:2",
    cst_t$0 = cst_t$3,
    cst_t$1 = cst_t$3,
    cst_src_protocol_version_heade$0 = "src/protocol_version_header.ml:135:2",
    cst_t$2 = cst_t$3,
    cst_src_protocol_version_heade$1 = cst_src_protocol_version_heade$2,
    cst_bin_sizes_are_not_changed_ = "bin sizes are not changed by accident",
    cst_protocol_version_header = cst_protocol_version_header$0,
    cst_Protocol_version_header$0 = cst_Protocol_version_header$1,
    max_supported_version = 1000000;
   function outside_max_supported_version_(num){
    return caml_call2(Core[91], num, max_supported_version);
   }
   var
    context = caml_call1(Core_Info[14], cst_Protocol_version_header),
    Bounded_list_in_case_someone_s =
      caml_call1(Protocol_version_header_List_w[1], [0, 100, context]),
    _a_ = caml_call1(Bounded_list_in_case_someone_s[1], Core[372]),
    _b_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), 0, _a_], 0],
    _c_ = caml_call1(Bin_shape[4][1], cst_src_protocol_version_heade),
    group = caml_call2(Bin_prot_Shape[2], _c_, _b_),
    _d_ = caml_call1(Bin_shape[2][1], cst_t$0),
    bin_shape_t = caml_call1(caml_call2(Bin_prot_Shape[10], group, _d_), 0);
   function bin_size_t(v){
    return caml_call2(Bounded_list_in_case_someone_s[2], Core[373], v);
   }
   function bin_write_t(buf, pos, v){
    return caml_call4
            (Bounded_list_in_case_someone_s[3], Core[375], buf, pos, v);
   }
   var bin_writer_t = [0, bin_size_t, bin_write_t];
   function bin_read_t(buf, pos_ref, vint){
    return caml_call3
            (caml_call1(Bounded_list_in_case_someone_s[5], Core[378]),
             buf,
             pos_ref,
             vint);
   }
   function bin_read_t$0(buf, pos_ref){
    return caml_call2
            (caml_call1(Bounded_list_in_case_someone_s[4], Core[378]),
             buf,
             pos_ref);
   }
   var
    bin_reader_t = [0, bin_read_t$0, bin_read_t],
    bin_t = [0, bin_shape_t, bin_writer_t, bin_reader_t];
   function t_of_sexp(x_002){
    return caml_call2(Bounded_list_in_case_someone_s[9], Core[390], x_002);
   }
   function sexp_of_t(x_003){
    return caml_call2(Bounded_list_in_case_someone_s[10], Core[389], x_003);
   }
   var
    known_protocol_magic_numbers =
      [246,
       function(_at_){
        return caml_call1(Core_Map[120], Protocol_version_header_Known_[6]);
       }];
   function create_exn(opt, protocol, supported_versions, param){
    if(opt)
     var sth = opt[1], additional_magic_numbers = sth;
    else
     var additional_magic_numbers = 0;
    var
     protocol_magic_number =
       caml_call1(Protocol_version_header_Known_[5], protocol);
    if
     (caml_call2
       (Core_List[23], supported_versions, outside_max_supported_version_)){
     var
      _af_ =
        [0,
         [1,
          [0,
           _e_,
           [0, caml_call2(Core[472], Core[389], supported_versions), 0]]],
         0],
      _ag_ =
        [0,
         [1, [0, _f_, [0, caml_call1(Core[389], max_supported_version), 0]]],
         _af_],
      _ah_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Unable_to_advertise_versio),
          _ag_]];
     caml_call1(Core[261], _ah_);
    }
    var _ai_ = caml_call1(Core_Fn[2], outside_max_supported_version_);
    if(caml_call2(Core_List[23], additional_magic_numbers, _ai_)){
     var
      _aj_ =
        [0,
         [1,
          [0,
           _g_,
           [0, caml_call2(Core[472], Core[389], additional_magic_numbers), 0]]],
         0],
      _ak_ =
        [0,
         [1, [0, _h_, [0, caml_call1(Core[389], max_supported_version), 0]]],
         _aj_],
      _al_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_additional_magic_numbers_s),
          _ak_]];
     caml_call1(Core[261], _al_);
    }
    var
     _am_ = caml_call1(Core[248], known_protocol_magic_numbers),
     _an_ = caml_call1(Core_Set[11], _am_);
    if(caml_call2(Core_List[23], additional_magic_numbers, _an_)){
     var
      _ao_ = caml_call1(Core[248], known_protocol_magic_numbers),
      _ap_ = [0, [1, [0, _i_, [0, caml_call1(Core_Int[99][28], _ao_), 0]]], 0],
      _aq_ =
        [0,
         [1,
          [0,
           _j_,
           [0, caml_call2(Core[472], Core[389], additional_magic_numbers), 0]]],
         _ap_],
      _ar_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_additional_magic_numbers_s$0),
          _aq_]];
     caml_call1(Core[261], _ar_);
    }
    var
     _as_ =
       [0,
        protocol_magic_number,
        caml_call2(Core[156], additional_magic_numbers, supported_versions)];
    return caml_call1(Bounded_list_in_case_someone_s[11], _as_);
   }
   function raw_version_list(t){return t;}
   function get_protocol(t){
    function _ab_(v){
     var
      match = caml_call2(Core_Map[44], Protocol_version_header_Known_[6], v);
     if(! match)
      return outside_max_supported_version_(v)
              ? [0, 4202758, v]
              : [0, 4152137, v];
     var p = match[1];
     return [0, 3506791, p];
    }
    var
     match = caml_call2(Core_List[76], t, _ab_),
     versions = match[2],
     protocols = match[1];
    if(! protocols) return [0, [0, 0, caml_call1(Core_Int[99][8], versions)]];
    if(protocols[2]){
     var
      _ac_ =
        [0,
         [1, [0, _k_, [0, caml_call2(Core[472], Core[389], versions), 0]]],
         0],
      _ad_ =
        [0,
         [1,
          [0,
           _l_,
           [0,
            caml_call2
             (Core[472], Protocol_version_header_Known_[4], protocols),
            0]]],
         _ac_],
      _ae_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne),
          _ad_]];
     return caml_call1(Core_Or_error[45], _ae_);
    }
    var p = protocols[1];
    return [0, [0, [0, p], caml_call1(Core_Int[99][8], versions)]];
   }
   function negotiate(allow_legacy_peer, us, peer){
    function _I_(param){
     var us_versions = param[2], us_protocol = param[1];
     function _K_(param){
      var peer_versions = param[2], peer_protocol = param[1];
      function _M_(us_protocol){
       function _Q_(peer_protocol){
        var
         _U_ =
           0
            ===
             caml_call2
              (Protocol_version_header_Known_[1], us_protocol, peer_protocol)
            ? 1
            : 0;
        if(! _U_){
         var
          ___ =
            [0,
             [1,
              [0,
               _p_,
               [0,
                caml_call1(Protocol_version_header_Known_[4], peer_protocol),
                0]]],
             0],
          _$_ =
            [0,
             [1,
              [0,
               _q_,
               [0,
                caml_call1(Protocol_version_header_Known_[4], us_protocol),
                0]]],
             ___],
          _aa_ =
            [1,
             [0,
              caml_call1
               (Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne$1),
              _$_]];
         return caml_call1(Core_Or_error[45], _aa_);
        }
        var
         _V_ = caml_call2(Core_Set[16], us_versions, peer_versions),
         match = caml_call1(Core_Set[60], _V_);
        if(match){var version = match[1]; return [0, version];}
        var
         _W_ =
           [0,
            [1,
             [0,
              _m_,
              [0,
               caml_call1(Protocol_version_header_Known_[4], us_protocol),
               0]]],
            0],
         _X_ =
           [0,
            [1, [0, _n_, [0, caml_call1(Core_Int[99][28], peer_versions), 0]]],
            _W_],
         _Y_ =
           [0,
            [1, [0, _o_, [0, caml_call1(Core_Int[99][28], us_versions), 0]]],
            _X_],
         _Z_ =
           [1,
            [0,
             caml_call1
              (Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne$0),
             _Y_]];
        return caml_call1(Core_Or_error[45], _Z_);
       }
       if(peer_protocol)
        var x = peer_protocol[1], _R_ = caml_call1(Base_Or_error[28][1], x);
       else if(allow_legacy_peer)
        var _R_ = caml_call1(Base_Or_error[28][1], us_protocol);
       else
        var
         _S_ =
           [0,
            [1,
             [0,
              _t_,
              [0,
               caml_call1(Protocol_version_header_Known_[4], us_protocol),
               0]]],
            [0, [1, [0, _s_, [0, _r_, 0]]], 0]],
         _T_ =
           [1,
            [0,
             caml_call1
              (Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne$2),
             _S_]],
         _R_ = caml_call1(Core_Or_error[45], _T_);
       return caml_call2(Base_Or_error[28][4][2], _R_, _Q_);
      }
      if(us_protocol)
       var x = us_protocol[1], _N_ = caml_call1(Base_Or_error[28][1], x);
      else
       var
        _O_ =
          [0,
           [1, [0, _u_, [0, caml_call1(Core_Int[99][28], us_versions), 0]]],
           0],
        _P_ =
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7], cst_No_magic_numbers_seen),
            _O_]],
        _N_ = caml_call1(Core[245], _P_);
      return caml_call2(Base_Or_error[28][4][2], _N_, _M_);
     }
     var _L_ = get_protocol(peer);
     return caml_call2(Base_Or_error[28][4][2], _L_, _K_);
    }
    var _J_ = get_protocol(us);
    return caml_call2(Base_Or_error[28][4][2], _J_, _I_);
   }
   function matches_magic_prefix(t, protocol){
    var
     magic_number = caml_call1(Protocol_version_header_Known_[5], protocol);
    return caml_call3(Core_List[17], t, magic_number, Core_Int[87]);
   }
   function contains_magic_prefix(protocol){
    var _F_ = bin_t[3];
    function _G_(_H_){return matches_magic_prefix(_H_, protocol);}
    return caml_call2(Bin_prot_Type_class[151], _G_, _F_);
   }
   function f(t){
    function _E_(protocol){return matches_magic_prefix(t, protocol);}
    return caml_call2(Core_List[27], Protocol_version_header_Known_[2], _E_);
   }
   var
    any_magic_prefix = caml_call2(Bin_prot_Type_class[151], f, bin_t[3]),
    _v_ = Core[372],
    _w_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$1), 0, _v_], 0],
    _x_ = caml_call1(Bin_shape[4][1], cst_src_protocol_version_heade$0),
    group$0 = caml_call2(Bin_prot_Shape[2], _x_, _w_),
    _y_ = caml_call1(Bin_shape[2][1], cst_t$2);
   caml_call1(caml_call2(Bin_prot_Shape[10], group$0, _y_), 0);
   var
    bin_size_t$0 = Core[373],
    any_magic_prefix_from_six_byte =
      caml_call1(bin_size_t$0, Bounded_list_in_case_someone_s[12]) + 5 | 0,
    magic_number_bin_size = 5;
   function bin_read_t$1(buf, pos_ref){
    caml_call2(Bin_prot_Read[7], buf, pos_ref);
    return caml_call2(Bin_prot_Read[6], buf, pos_ref);
   }
   var bin_reader_t$0 = [0, bin_read_t$1, Core_Int[124]];
   function _z_(magic_number){
    return caml_call1
            (caml_call1(Core_Map[44], Protocol_version_header_Known_[6]),
             magic_number);
   }
   var
    any_magic_prefix_from_six_byte$0 =
      caml_call2(Bin_prot_Type_class[151], _z_, bin_reader_t$0),
    Pair = [0],
    none = caml_call1(Bounded_list_in_case_someone_s[11], 0);
   function is_none(t){return t ? 0 : 1;}
   var Expert = [0, raw_version_list, none, is_none];
   function _A_(param){
    var
     bounded_list_bin_size =
       caml_call1(Core_Int[121], Bounded_list_in_case_someone_s[12]);
    if(! caml_call2(Core[90], bounded_list_bin_size, 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
    if(! caml_call2(Core[90], 6, 5 + bounded_list_bin_size | 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
    if
     (caml_call2
       (Core[90],
        any_magic_prefix_from_six_byte,
        5 + bounded_list_bin_size | 0))
     return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
   }
   caml_call8
    (Ppx_inline_test_lib[9],
     Inline_test_config,
     cst_bin_sizes_are_not_changed_,
     0,
     cst_src_protocol_version_heade$1,
     194,
     0,
     707,
     _A_);
   caml_call1(Ppx_inline_test_lib[7], cst_protocol_version_header);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header$0);
   var
    Protocol_version_header =
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t$0,
       bin_read_t,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       t_of_sexp,
       sexp_of_t,
       create_exn,
       negotiate,
       contains_magic_prefix,
       any_magic_prefix,
       any_magic_prefix_from_six_byte$0,
       any_magic_prefix_from_six_byte,
       Pair,
       Expert,
       [0,
        Protocol_version_header_List_w[1],
        magic_number_bin_size,
        max_supported_version]];
   runtime.caml_register_global
    (66, Protocol_version_header, cst_Protocol_version_header$1);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcm90b2NvbF92ZXJzaW9uX2hlYWRlci5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiYWxsIiwiZXJyb3Jfc291cmNlXzAwNSIsInJldGlyZWRfa3JiX3dvcmQiLCJjb21wYXJlIiwidF9vZl9zZXhwIiwic2V4cF8wMDYiLCJzZXhwX29mX3QiLCJncm91cCIsIm1hZ2ljX3dvcmQiLCJnZW5fbWFnaWNfbnVtYmVyIiwid29yZCIsImFjYyIsImMiLCJtYWdpY19udW1iZXIiLCJ0IiwicCIsImJ5X21hZ2ljX251bWJlciIsImFsbF9tYWdpY19udW1iZXJzX2luY2x1ZGluZ19yZSIsImJpbl9zaGFwZV90IiwiYSIsImJpbl9zaXplX3QiLCJzaXplX29mX2EiLCJ2IiwiYmluX3dyaXRlX3QiLCJ3cml0ZV9hIiwiYnVmIiwicG9zIiwiYmluX3dyaXRlcl90IiwiYmluX3dyaXRlcl9hIiwiYmluX3JlYWRfdCIsImJpbl9yZWFkX3QkMCIsImJpbl9yZWFkX2VsIiwicG9zX3JlZiIsImV4biQwIiwiZXhuIiwiYmluX3JlYWRlcl90IiwiYmluX3JlYWRlcl9hIiwiYmluX3QiLCJiaW5fYSIsIm9mX2xpc3RfZXhuIiwibCIsImxlbiIsInRfb2ZfYSIsInNleHAiLCJtYXhfc3VwcG9ydGVkX3ZlcnNpb24iLCJvdXRzaWRlX21heF9zdXBwb3J0ZWRfdmVyc2lvbl8iLCJudW0iLCJjb250ZXh0IiwidmludCIsInhfMDAyIiwieF8wMDMiLCJrbm93bl9wcm90b2NvbF9tYWdpY19udW1iZXJzIiwiY3JlYXRlX2V4biIsIm9wdCIsInByb3RvY29sIiwic3VwcG9ydGVkX3ZlcnNpb25zIiwic3RoIiwiYWRkaXRpb25hbF9tYWdpY19udW1iZXJzIiwicHJvdG9jb2xfbWFnaWNfbnVtYmVyIiwicmF3X3ZlcnNpb25fbGlzdCIsImdldF9wcm90b2NvbCIsInZlcnNpb25zIiwicHJvdG9jb2xzIiwibmVnb3RpYXRlIiwiYWxsb3dfbGVnYWN5X3BlZXIiLCJ1cyIsInBlZXIiLCJ1c192ZXJzaW9ucyIsInVzX3Byb3RvY29sIiwicGVlcl92ZXJzaW9ucyIsInBlZXJfcHJvdG9jb2wiLCJ2ZXJzaW9uIiwieCIsIm1hdGNoZXNfbWFnaWNfcHJlZml4IiwiY29udGFpbnNfbWFnaWNfcHJlZml4IiwiZiIsImFueV9tYWdpY19wcmVmaXgiLCJncm91cCQwIiwiYmluX3NpemVfdCQwIiwiYW55X21hZ2ljX3ByZWZpeF9mcm9tX3NpeF9ieXRlIiwibWFnaWNfbnVtYmVyX2Jpbl9zaXplIiwiYmluX3JlYWRfdCQxIiwiYmluX3JlYWRlcl90JDAiLCJhbnlfbWFnaWNfcHJlZml4X2Zyb21fc2l4X2J5dGUkMCIsIm5vbmUiLCJpc19ub25lIiwiYm91bmRlZF9saXN0X2Jpbl9zaXplIl0sInNvdXJjZXMiOlsiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL3Byb3RvY29sX3ZlcnNpb25faGVhZGVyL3Byb3RvY29sX3ZlcnNpb25faGVhZGVyX18ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvcHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIva25vd25fcHJvdG9jb2wubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvcHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIvbGlzdF93aXRoX21heF9sZW4ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvcHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIvcHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0FXbUM7O0lBQUE7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUNUbkNBO0lBQUFDO0lBc0JJQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXRCSjtJQUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQUFBLFNBQUFDLFVBQUFDO0lBQUE7O2NBQUFBO2dCQUFBQTs7Ozs7Ozs7OztRQUdFOztPQURBOztNQURBOztlQURGQTs7TUFBQSxPQUFBOzZDQUFBSixrQkFBQUk7OztNQUFBLE9BQUE7NkNBQUFKLGtCQUFBSTs7Ozs7Ozs7Ozs7T0FBQSxPQUFBOzZDQUFBSixrQkFBQUk7O01BQUEsT0FBQTs0Q0FBQUosa0JBQUFJOztLQUFBLE9BQUE7MkNBQUFKLGtCQUFBSTs7SUFBQSxPQUFBOzJDQUFBSixrQkFBQUk7R0FJNkM7WUFKN0NDO0lBQUEsc0JBQ0UsbUJBQ0Esb0JBQ0E7O0dBQzJDO0dBSnhDO0lBQUEsTUFBQTtJQUFMLGNBQUs7SUFBTCxNQUFBO0lBQUFDLFFBQUE7SUFBQSxNQUFBO0dBQUEsV0FBQSwrQkFBQUE7WUFNSUM7SUFBYTs7T0FDTjs7T0FDVTtlQUNWOztHQUFLO1lBR1pDLGlCQUFpQkM7SUFDbkIsYUFDNkJDLEtBQUlDO0tBQUssUUFBVEQsaUJBQXVCLDBCQUFuQkM7SUFBZ0M7SUFEakUsVUFBQSw0QkFEbUJGO0lBRUssT0FBQTtHQUEwQztZQUdoRUcsYUFBYUMsR0FBSSxPQUxqQkwsaUJBTkFELFdBV2FNLElBQW1DO2dCQUNhQyxHQUFLLFdBRGxFRixhQUM2REUsSUFBQUEsR0FBc0I7R0FBNUM7SUFBQSxNQUFBLDBCQWxCM0NmO0lBa0JJZ0Isa0JBQWtCOztJQVFaLFVBZE5QLGlCQVVBUDtJQUlLLEtBQUE7S0FBUCxNQUFBO0lBQ1EsVUFWTlc7SUFVSyxLQUFBO0tBQVAsTUFBQTtJQUNRLFVBWE5BO0lBV0ssS0FBQTtLQUFQLE1BQUE7SUFDUSxVQVpOQTtJQVlLLEdBQUE7SUFBUCxNQUFBOzs7Ozs7Ozs7Ozs7R0FLTztJQURISTs7O1FBQ0k7O2VBWk5mLGtCQVkwQiwwQkFsQzlCRixLQU1JUTs4Q0FNQUM7O0lBb0JjLGVBQ1pROzs7Ozs7OztPQWpDTmQ7T0FBQUg7T0FBQUk7T0FBQUU7T0FpQklPO09BQ0FHOzs7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FDZE07Ozs7Ozs7U0FBQSxVQUFBO1NBQVIsY0FBUTtTQUFSLE1BQUE7U0FBQVQsUUFBQTtRQUFRLFNBQUFXLFlBQUFDO1NBQVIsVUFBQTtTQUFBLE9BQUE7a0JBQUEsK0JBQUFaLGlCQUFRWTtRQUE2QztpQkFBckRDLFdBQUtDLFdBQUxDO1MsNkJBQUtELFdBQUxDOztpQkFBQUMsWUFBS0MsU0FBTEMsS0FBQUMsS0FBQUo7Uyw2QkFBS0UsU0FBTEMsS0FBQUMsS0FBQUo7O2lCQUFBSyxhQUFLQztzQkFBTE47VUFBQSxVQUFLTTtVQUFMLDBCLE9BQUFMLGlCQUFBRDtTQUFxRDtTQUFyRCxvQkFBQUEsR0FBQSxPQUFBRixXQUFLUSxpQkFBTE4sR0FBcUQ7UUFBQTtZQUVqRE87aUJBRUFDLGFBQVdDLGFBQVlOLEtBQUtPO1NBQzlCO1VBQUk7O2FBQUEsdUNBRFNELGFBQVlOLEtBQUtPO1VBQzFCOztlQUNGQztVQUF1QjtXQUF2QkMsMEJBQUFEO1dBQXVCLE1BQUE7VUFBQSxPQUFBLHdCQUF2QkM7O1FBQW1EO2lCQUduREMsYUFBY0M7U0FDaEI7VUFDYyxNQUFBLFdBVFpQLFlBT2NPO2dCQUFBQTtTQUNoQjtvQyxPQU5FTjs7UUFRRDtpQkFHQ08sTUFBT0M7U0FDVCxJQUVXLE1BVFRILGFBTU9HLFdBRUUsTUFqQmJYLGFBZVdXO1NBQ1QsV0FoQk1wQixZQWVHb0I7UUFJUjtpQkFHQ0MsWUFBWUM7U0FDSixJQUFOQyxNQUFNLDBCQURJRDtTQUVYLEdBQUEscUJBRENDOzs7NERBQUFBOzs7Ozs7Ozs7O1VBR0Y7O1NBQUEsT0FKWUQ7UUFNYjtZQUdDbEM7aUJBRUFGLFVBQVVzQyxRQUFPQztTQUNYLElBQUo3QixJQUFJLHlCQURJNEIsUUFBT0M7U0FFbkIsT0FiRUosWUFZRXpCO1FBQ1M7O2dCQW5DUEk7Z0JBQVJFO2dCQUFBRztnQkFJSU87Z0JBRkFEO2dCQUZKRjtnQkFTSVE7Z0JBTUFFO2dCQWtCQWpDO2dCQUZBRTtnQkFUQWlDOzs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDekJGSztZQUNBQywrQkFBb0NDO0lBQU0sNEJBQU5BLEtBRHBDRjtHQUNxRTtHQUt6RDtJQUFWRyxVQUFVOzs2REFBVkE7O0lBSUosY0FBSztJQUFMLE1BQUE7SUFBQXhDLFFBQUE7SUFBQSxNQUFBO0lBQUtXLGNBQUwsV0FBQSwrQkFBQVg7WUFBQWEsV0FBQUU7SSxnRUFBQUE7O1lBQUFDLFlBQUFFLEtBQUFDLEtBQUFKO0k7MkRBQUFHLEtBQUFDLEtBQUFKOztHQUFBLElBQUFLLG1CQUFBUCxZQUFBRztZQUFBTSxXQUFhSixLQUFBTyxTQUFBZ0I7STs7YUFBQXZCO2FBQUFPO2FBQUFnQjs7WUFBYmxCLGFBQUFMLEtBQUFPO0lBQUEsT0FBQTs7YUFBQVA7YUFBQU87R0FDeUI7R0FEekI7SUFBQUcsbUJBQUFMLGNBQUFEO0lBQUFRLFlBQUtuQixhQUFMUyxjQUFBUTtZQUFBL0IsVUFBQTZDO0lBQUEsT0FBQSx5REFBQUE7R0FDeUI7WUFEekIzQyxVQUFBNEM7SUFBQSxPQUFBLDBEQUFBQTtHQUN5QjtHQUdhO0lBQXBDQzs7O1E7O1lBRUFDLFdBQWFDLEtBQWdDQyxVQUFVQztJQUN6RCxHQURlRjtTQUEyQkcsTUFBM0JILFFBQUFJLDJCQUEyQkQ7O1NBQTNCQztJQUNhO0tBQXhCQztPQUF3Qiw4Q0FEbUJKO0lBRTVDO01BQUE7dUJBRnNEQyxvQkFmdkRWOzs7Ozs7O2dEQWV1RFU7Ozs7Z0RBaEJ2RFg7Ozs7Ozs7S0FvQkE7O0lBS3lDLFdBQUEsdUJBeEJ6Q0M7SUF3QkMsR0FBQSwwQkFUWVk7Ozs7Ozs7Z0RBQUFBOzs7O2dEQWhCYmI7Ozs7Ozs7S0EyQkE7O0lBT2U7S0FBQSxPQUFBLHNCQXBCZk87S0FvQk0sT0FBQTtJQUZMLEdBQUEsMEJBaEJZTTtLQXlCd0I7TUFBQSxPQUFBLHNCQTNCckNOOzs7Ozs7O2dEQUVhTTs7Ozs7OztLQW9CYjs7SUFNRjs7O1FBekJJQztRQXlCcUIsc0JBMUJWRCwwQkFBMENGO0lBMEJ6RCxPQUFBO0dBQ3FFO1lBR25FSSxpQkFBa0I3QyxHQUFVLE9BQVZBLEVBQVc7WUFFN0I4QyxhQUFjOUM7a0JBSUpRO0tBQ0E7Y0FBQSw0REFEQUE7O01BR08sT0F0RGpCdUIsK0JBbURVdkI7NkJBQUFBOzZCQUFBQTtTQUVDUDtLQUFLLG9CQUFMQTtJQUNtRTtJQUw5RTtLQUFBLFFBQUEsMEJBRmNEO0tBQ0QrQztLQUFYQztJQVFKLEtBUklBLFdBU0ksa0JBQVUsNEJBVEhEO09BQVhDOzs7OzJEQUFXRDs7Ozs7Ozs7OzREQUFYQzs7Ozs7Ozs7OztRQVVBL0MsSUFWQStDO0lBVU8sbUJBQVAvQyxJQUFtQiw0QkFWUjhDO0dBZ0JlO1lBRzVCRSxVQUFXQyxtQkFBb0JDLElBQVVDOztTQUVyQkMsd0JBQWJDOztVQUNlQywwQkFBZkM7bUJBQ0FGO29CQUtBRTtRQWVUOzs7O2FBQXlCO2tEQXBCaEJGLGFBS0FFOzs7UUFlRjs7Ozs7Ozs7OERBZkVBOzs7Ozs7Ozs7OERBTEFGOzs7Ozs7Ozs7OztRQTZCVztTQUFBLE1BQUEseUJBL0JFRCxhQUNFRTtTQThCaEIsUUFBQTtzQkFDQ0Usb0JBQVcsV0FBWEE7Ozs7Ozs7OzZEQTlCQUg7Ozs7OzBEQURlQzs7OzswREFERkY7Ozs7Ozs7OztPQXVDbUI7VUF0Q2hDRztZQVFBRSxJQVJBRix3QkFRSyxpQ0FBTEU7ZUFYSVI7a0JBZUosaUNBWEFJOzs7Ozs7Ozs7NkRBQUFBOzs7Ozs7Ozs7ZUFjSDs7O1NBaEJHQTtXQUlBSSxJQUpBSixzQkFJSyxpQ0FBTEk7Ozs7O3lEQUphTDs7Ozs7OztjQUtWOzs7S0FKNEIsVUF2QnRDUCxhQW9CeUNNOzs7SUFFUCxVQXRCbENOLGFBb0IrQks7O0dBeUNRO1lBR3ZDUSxxQkFBc0IzRCxHQUFRd0M7SUFDYjtLQUFmekMsZUFBZSw4Q0FEYXlDO0lBRWhDLE9BQUEsMEJBRndCeEMsR0FDcEJEO0dBQ3VEO1lBR3pENkQsc0JBQXVCcEI7SUFDekIsVUE1R0FqQjtzQixPQXNHRW9DLDBCQUt1Qm5CO0lBQ00sT0FBQTtHQUE2QztZQUl4RXFCLEVBQUU3RDtpQkFDaUN3QyxVQUFZLE9BWGpEbUIscUJBVUkzRCxHQUNpQ3dDLFVBQTRDO0lBQWpELE9BQUE7R0FBa0Q7R0FFcEY7SUFKRXNCLG1CQUlGLHFDQUhJRCxHQWhISnRDOztJQXlIQSxjQUFLO0lBQUwsTUFBQTtJQUFBd0MsVUFBQTtJQUFBLE1BQUE7R0FBQSxXQUFBLCtCQUFBQTtHQVlFO0lBWkZDO0lBZ0NFQztNQXBCQSxXQVpGRDtJQUhFRTtZQW1CRUMsYUFBV3hELEtBQUtPO0lBQ3FCLDZCQUQxQlAsS0FBS087SUFFbEIsT0FBQSw2QkFGYVAsS0FBS087R0FFcUI7R0FJdkMsSUFERWtELHFCQUxBRDtnQkFZR3BFO0lBQWdCLE9BQUE7YUFBQTthQUFoQkE7R0FBc0U7R0FEN0U7SUFERXNFO01BQ0YsMENBTklEO0lBYVE7SUFTUkUsT0FBTztZQUVQQyxRQUFTdkUsR0FDWCxPQURXQSxVQUdNO0dBUEwsaUJBOUhaNkMsa0JBZ0lFeUIsTUFFQUM7O0lBb0JGO0tBREVDO09BQ0Y7SUFFSyxLQUFBLHFCQUhIQTtLQUdKLE1BQUE7SUFDTyxLQUFBLDRCQUpIQTtLQUlKLE1BQUE7SUFDTztNQUFBOztRQXJDTFA7WUFnQ0VPOztJQUtKLE1BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E5TEFsRTtPQUFBRztPQUFBTztPQUFBRDtPQUFLWDtPQUFMUztPQUFBUTtPQUFBRTtPQUFBakM7T0FBQUU7T0FNRThDO09Bb0RBVztPQWlEQVc7T0FJQUU7T0FvQ0FPO09BTUFKOzs7OztRQW5DQUM7UUFoSUFwQzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIuS25vd25fcHJvdG9jb2wgKilcbm1vZHVsZSBLbm93bl9wcm90b2NvbCA9IFByb3RvY29sX3ZlcnNpb25faGVhZGVyX19Lbm93bl9wcm90b2NvbFxuXG4oKiogQGNhbm9uaWNhbCBQcm90b2NvbF92ZXJzaW9uX2hlYWRlci5MaXN0X3dpdGhfbWF4X2xlbiAqKVxubW9kdWxlIExpc3Rfd2l0aF9tYXhfbGVuID0gUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXJfX0xpc3Rfd2l0aF9tYXhfbGVuXG5cbigqKiBAY2Fub25pY2FsIFByb3RvY29sX3ZlcnNpb25faGVhZGVyLkxpc3Rfd2l0aF9tYXhfbGVuX2ludGYgKilcbm1vZHVsZSBMaXN0X3dpdGhfbWF4X2xlbl9pbnRmID0gUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXJfX0xpc3Rfd2l0aF9tYXhfbGVuX2ludGZcblxubW9kdWxlIFByb3RvY29sX3ZlcnNpb25faGVhZGVyX18gPSBzdHJ1Y3QgZW5kXG5bQEBkZXByZWNhdGVkIFwidGhpcyBtb2R1bGUgaXMgc2hhZG93ZWRcIl1cbiIsIm9wZW4hIENvcmVcblxudHlwZSB0ID1cbiAgfCBLcmJcbiAgfCBLcmJfdGVzdF9tb2RlXG4gIHwgUnBjXG5bQEBkZXJpdmluZyBjb21wYXJlLCBlbnVtZXJhdGUsIHNleHAsIGJpbl9pb11cblxubGV0IG1hZ2ljX3dvcmQgPSBmdW5jdGlvblxuICB8IEtyYiAtPiBcIktSQjJcIlxuICB8IEtyYl90ZXN0X21vZGUgLT4gXCJLQlRcIlxuICB8IFJwYyAtPiBcIlJQQ1wiXG47O1xuXG5sZXQgZ2VuX21hZ2ljX251bWJlciB3b3JkID1cbiAgU3RyaW5nLnRvX2xpc3RfcmV2IHdvcmRcbiAgfD4gTGlzdC5mb2xkIH5pbml0OjAgfmY6KGZ1biBhY2MgYyAtPiAoYWNjICogMjU2KSArIENoYXIudG9faW50IGMpXG47O1xuXG5sZXQgbWFnaWNfbnVtYmVyIHQgPSBnZW5fbWFnaWNfbnVtYmVyIChtYWdpY193b3JkIHQpXG5sZXQgYnlfbWFnaWNfbnVtYmVyID0gSW50Lk1hcC5vZl9hbGlzdF9leG4gKExpc3QubWFwIGFsbCB+ZjooZnVuIHAgLT4gbWFnaWNfbnVtYmVyIHAsIHApKVxuXG4oKiBXZSBvbmNlIG1pbnRlZCBhIG5ldyBtYWdpYyBudW1iZXIgZm9yIEtyYiBpbiBvcmRlciB0byBjaGFuZ2UgdGhlIHByb3RvY29sXG4gICBuZWdvdGlhdGlvbi4gIExldCdzIGJlIGNhcmVmdWwgdGhhdCB3ZSBkb24ndCByZXVzZSB0aGUgb2xkIG1hZ2ljIG51bWJlciAqKVxubGV0IHJldGlyZWRfa3JiX3dvcmQgPSBcIktSQlwiXG5cbigqIEVuc3VyZSB0ZXN0cyBicmVhayBpZiB0aGUgbWFnaWMgbnVtYmVycyBhcmUgY2hhbmdlZCAqKVxubGV0JXRlc3RfdW5pdCBcIm1hZ2ljIG51bWJlcnNcIiA9XG4gIGFzc2VydCAoZ2VuX21hZ2ljX251bWJlciByZXRpcmVkX2tyYl93b3JkID0gNF8zNDZfNDQzKTtcbiAgYXNzZXJ0IChtYWdpY19udW1iZXIgS3JiID0gODQzXzIwN18yNDMpO1xuICBhc3NlcnQgKG1hZ2ljX251bWJlciBLcmJfdGVzdF9tb2RlID0gNV81MjFfOTk1KTtcbiAgYXNzZXJ0IChtYWdpY19udW1iZXIgUnBjID0gNF80MTFfNDc0KVxuOztcblxubW9kdWxlIEZvcl90ZXN0ID0gc3RydWN0XG4gIGxldCBhbGxfbWFnaWNfbnVtYmVyc19pbmNsdWRpbmdfcmV0aXJlZCA9XG4gICAgbGF6eSAocmV0aXJlZF9rcmJfd29yZCA6OiBMaXN0Lm1hcCBhbGwgfmY6bWFnaWNfd29yZCB8PiBMaXN0Lm1hcCB+ZjpnZW5fbWFnaWNfbnVtYmVyKVxuICA7O1xuZW5kXG4iLCJvcGVuISBDb3JlXG5pbmNsdWRlIExpc3Rfd2l0aF9tYXhfbGVuX2ludGZcblxubW9kdWxlIE1ha2UgKENvbmZpZyA6IENvbmZpZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBDb25maWdcblxuICB0eXBlICdhIHQgPSAnYSBsaXN0IFtAQGRlcml2aW5nIGJpbl9zaGFwZSwgYmluX3dyaXRlXVxuXG4gIGxldCBfX2Jpbl9yZWFkX3RfXyA9IExpc3QuX19iaW5fcmVhZF90X19cblxuICBsZXQgYmluX3JlYWRfdCBiaW5fcmVhZF9lbCBidWYgfnBvc19yZWYgPVxuICAgIHRyeSBCaW5fcHJvdC5SZWFkLmJpbl9yZWFkX2xpc3Rfd2l0aF9tYXhfbGVuIH5tYXhfbGVuIGJpbl9yZWFkX2VsIGJ1ZiB+cG9zX3JlZiB3aXRoXG4gICAgfCBleG4gLT4gRXhuLnJlcmFpc2UgZXhuIChJbmZvLnRvX3N0cmluZ19odW0gY29udGV4dClcbiAgOztcblxuICBsZXQgYmluX3JlYWRlcl90IChiaW5fcmVhZGVyX2EgOiAnYSBCaW5fcHJvdC5UeXBlX2NsYXNzLnJlYWRlcikgPVxuICAgIHsgQmluX3Byb3QuVHlwZV9jbGFzcy5yZWFkID0gYmluX3JlYWRfdCBiaW5fcmVhZGVyX2EucmVhZFxuICAgIDsgdnRhZ19yZWFkID0gX19iaW5fcmVhZF90X18gYmluX3JlYWRlcl9hLnJlYWRcbiAgICB9XG4gIDs7XG5cbiAgbGV0IGJpbl90IChiaW5fYSA6ICdhIEJpbl9wcm90LlR5cGVfY2xhc3MudCkgPVxuICAgIHsgQmluX3Byb3QuVHlwZV9jbGFzcy5zaGFwZSA9IGJpbl9zaGFwZV90IGJpbl9hLnNoYXBlXG4gICAgOyB3cml0ZXIgPSBiaW5fd3JpdGVyX3QgYmluX2Eud3JpdGVyXG4gICAgOyByZWFkZXIgPSBiaW5fcmVhZGVyX3QgYmluX2EucmVhZGVyXG4gICAgfVxuICA7O1xuXG4gIGxldCBvZl9saXN0X2V4biBsID1cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICAgIGlmIGxlbiA+IG1heF9sZW5cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcIkxpc3QgaXMgdG9vIGxhcmdlXCIgKGNvbnRleHQgOiBJbmZvLnQpIChsZW4gOiBpbnQpIChtYXhfbGVuIDogaW50KV07XG4gICAgbFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgPSBMaXN0LnNleHBfb2ZfdFxuXG4gIGxldCB0X29mX3NleHAgdF9vZl9hIHNleHAgPVxuICAgIGxldCB0ID0gTGlzdC50X29mX3NleHAgdF9vZl9hIHNleHAgaW5cbiAgICBvZl9saXN0X2V4biB0XG4gIDs7XG5lbmRcbiIsIm9wZW4hIENvcmVcbm1vZHVsZSBLbm93bl9wcm90b2NvbCA9IEtub3duX3Byb3RvY29sXG5cbmxldCBtYXhfc3VwcG9ydGVkX3ZlcnNpb24gPSAxXzAwMF8wMDBcbmxldCBvdXRzaWRlX21heF9zdXBwb3J0ZWRfdmVyc2lvbl9yYW5nZSBudW0gPSBudW0gPiBtYXhfc3VwcG9ydGVkX3ZlcnNpb25cblxubW9kdWxlIEJvdW5kZWRfbGlzdF9pbl9jYXNlX3NvbWVvbmVfc2VuZHNfZ2FyYmFnZV9vbl90aGVfd2lyZSA9XG5MaXN0X3dpdGhfbWF4X2xlbi5NYWtlIChzdHJ1Y3RcbiAgbGV0IG1heF9sZW4gPSAxMDBcbiAgbGV0IGNvbnRleHQgPSBJbmZvLm9mX3N0cmluZyBcIlByb3RvY29sX3ZlcnNpb25faGVhZGVyXCJcbmVuZClcblxuaW5jbHVkZSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50IEJvdW5kZWRfbGlzdF9pbl9jYXNlX3NvbWVvbmVfc2VuZHNfZ2FyYmFnZV9vbl90aGVfd2lyZS50XG4gIFtAQGRlcml2aW5nIGJpbl9pbywgc2V4cF1cbmVuZFxuXG5sZXQga25vd25fcHJvdG9jb2xfbWFnaWNfbnVtYmVycyA9IGxhenkgKE1hcC5rZXlfc2V0IEtub3duX3Byb3RvY29sLmJ5X21hZ2ljX251bWJlcilcblxubGV0IGNyZWF0ZV9leG4gPyhhZGRpdGlvbmFsX21hZ2ljX251bWJlcnMgPSBbXSkgfnByb3RvY29sIH5zdXBwb3J0ZWRfdmVyc2lvbnMgKCkgPVxuICBsZXQgcHJvdG9jb2xfbWFnaWNfbnVtYmVyID0gS25vd25fcHJvdG9jb2wubWFnaWNfbnVtYmVyIHByb3RvY29sIGluXG4gIGlmIExpc3QuZXhpc3RzIHN1cHBvcnRlZF92ZXJzaW9ucyB+ZjpvdXRzaWRlX21heF9zdXBwb3J0ZWRfdmVyc2lvbl9yYW5nZVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiVW5hYmxlIHRvIGFkdmVydGlzZSB2ZXJzaW9ucyBsYXJnZXIgdGhhbiBtYXggc3VwcG9ydGVkIHZlcnNpb25cIlxuICAgICAgICAgIChtYXhfc3VwcG9ydGVkX3ZlcnNpb24gOiBpbnQpXG4gICAgICAgICAgKHN1cHBvcnRlZF92ZXJzaW9ucyA6IGludCBsaXN0KV07XG4gIGlmIExpc3QuZXhpc3RzIGFkZGl0aW9uYWxfbWFnaWNfbnVtYmVycyB+ZjooRm4ubm9uIG91dHNpZGVfbWF4X3N1cHBvcnRlZF92ZXJzaW9uX3JhbmdlKVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiW2FkZGl0aW9uYWxfbWFnaWNfbnVtYmVyc10gc2hvdWxkbid0IGJlIHdpdGhpbiBbbWF4X3N1cHBvcnRlZF92ZXJzaW9uXSByYW5nZVwiXG4gICAgICAgICAgKG1heF9zdXBwb3J0ZWRfdmVyc2lvbiA6IGludClcbiAgICAgICAgICAoYWRkaXRpb25hbF9tYWdpY19udW1iZXJzIDogaW50IGxpc3QpXTtcbiAgaWYgTGlzdC5leGlzdHNcbiAgICAgICBhZGRpdGlvbmFsX21hZ2ljX251bWJlcnNcbiAgICAgICB+ZjooU2V0Lm1lbSAoZm9yY2Uga25vd25fcHJvdG9jb2xfbWFnaWNfbnVtYmVycykpXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJbYWRkaXRpb25hbF9tYWdpY19udW1iZXJzXSBzaG91bGRuJ3QgYmUgb3ZlcmxhcHBpbmcgd2l0aCBwb3RlbnRpYWwgXFxcbiAgICAgICAgIFtwcm90b2NvbF9tYWdpY19udW1iZXJdc1wiXG4gICAgICAgICAgKGFkZGl0aW9uYWxfbWFnaWNfbnVtYmVycyA6IGludCBsaXN0KVxuICAgICAgICAgIH5rbm93bl9wcm90b2NvbF9tYWdpY19udW1iZXJzOihmb3JjZSBrbm93bl9wcm90b2NvbF9tYWdpY19udW1iZXJzIDogSW50LlNldC50KV07XG4gIHByb3RvY29sX21hZ2ljX251bWJlciA6OiAoYWRkaXRpb25hbF9tYWdpY19udW1iZXJzIEAgc3VwcG9ydGVkX3ZlcnNpb25zKVxuICB8PiBCb3VuZGVkX2xpc3RfaW5fY2FzZV9zb21lb25lX3NlbmRzX2dhcmJhZ2Vfb25fdGhlX3dpcmUub2ZfbGlzdF9leG5cbjs7XG5cbmxldCByYXdfdmVyc2lvbl9saXN0ICh0IDogdCkgPSAodCA6PiBpbnQgbGlzdClcblxubGV0IGdldF9wcm90b2NvbCAodCA6IHQpID1cbiAgbGV0IHByb3RvY29scywgdmVyc2lvbnMsIF9hZGRpdGlvbmFsX21hZ2ljX251bWJlcnMgPVxuICAgIExpc3QucGFydGl0aW9uM19tYXBcbiAgICAgICh0IDo+IGludCBsaXN0KVxuICAgICAgfmY6KGZ1biB2IC0+XG4gICAgICAgIG1hdGNoIE1hcC5maW5kIEtub3duX3Byb3RvY29sLmJ5X21hZ2ljX251bWJlciB2IHdpdGhcbiAgICAgICAgfCBTb21lIHAgLT4gYEZzdCBwXG4gICAgICAgIHwgTm9uZSAtPiBpZiBvdXRzaWRlX21heF9zdXBwb3J0ZWRfdmVyc2lvbl9yYW5nZSB2IHRoZW4gYFRyZCB2IGVsc2UgYFNuZCB2KVxuICBpblxuICBtYXRjaCBwcm90b2NvbHMgd2l0aFxuICB8IFtdIC0+IE9rIChOb25lLCBJbnQuU2V0Lm9mX2xpc3QgdmVyc2lvbnMpXG4gIHwgWyBwIF0gLT4gT2sgKFNvbWUgcCwgSW50LlNldC5vZl9saXN0IHZlcnNpb25zKVxuICB8IF8gLT5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJbUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIubmVnb3RpYXRlXTogbXVsdGlwbGUgbWFnaWMgbnVtYmVycyBzZWVuLlwiXG4gICAgICAgICAgKHByb3RvY29scyA6IEtub3duX3Byb3RvY29sLnQgbGlzdClcbiAgICAgICAgICAodmVyc2lvbnMgOiBpbnQgbGlzdCldXG47O1xuXG5sZXQgbmVnb3RpYXRlIH5hbGxvd19sZWdhY3lfcGVlciB+KHVzIDogdCkgfihwZWVyIDogdCkgPVxuICBsZXQgb3BlbiBPcl9lcnJvci5MZXRfc3ludGF4IGluXG4gIGxldCViaW5kIHVzX3Byb3RvY29sLCB1c192ZXJzaW9ucyA9IGdldF9wcm90b2NvbCB1cyBpblxuICBsZXQlYmluZCBwZWVyX3Byb3RvY29sLCBwZWVyX3ZlcnNpb25zID0gZ2V0X3Byb3RvY29sIHBlZXIgaW5cbiAgbGV0JWJpbmQgdXNfcHJvdG9jb2wgPVxuICAgIG1hdGNoIHVzX3Byb3RvY29sIHdpdGhcbiAgICB8IFNvbWUgeCAtPiByZXR1cm4geFxuICAgIHwgTm9uZSAtPiBlcnJvcl9zIFslbWVzc2FnZSBcIk5vIG1hZ2ljIG51bWJlcnMgc2VlblwiICh1c192ZXJzaW9ucyA6IEludC5TZXQudCldXG4gIGluXG4gIGxldCViaW5kIHBlZXJfcHJvdG9jb2wgPVxuICAgIG1hdGNoIHBlZXJfcHJvdG9jb2wgd2l0aFxuICAgIHwgU29tZSB4IC0+IHJldHVybiB4XG4gICAgfCBOb25lIC0+XG4gICAgICAoKiB3ZSBhc3N1bWUgcGVlciBpcyBzcGVha2luZyBvdXIgcHJvdG9jb2wgaWYgW2FsbG93X2xlZ2FjeV9wZWVyXSAqKVxuICAgICAgaWYgYWxsb3dfbGVnYWN5X3BlZXJcbiAgICAgIHRoZW4gcmV0dXJuIHVzX3Byb3RvY29sXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHBlZXJfcHJvdG9jb2wgPSBgVW5rbm93biBpblxuICAgICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICBcIltQcm90b2NvbF92ZXJzaW9uX2hlYWRlci5uZWdvdGlhdGVdOiBjb25mbGljdGluZyBtYWdpYyBwcm90b2NvbCBudW1iZXJzXCJcbiAgICAgICAgICAgICAgKHVzX3Byb3RvY29sIDogS25vd25fcHJvdG9jb2wudClcbiAgICAgICAgICAgICAgKHBlZXJfcHJvdG9jb2wgOiBbIGBVbmtub3duIF0pXSlcbiAgaW5cbiAgaWYgbm90IChbJWNvbXBhcmUuZXF1YWw6IEtub3duX3Byb3RvY29sLnRdIHVzX3Byb3RvY29sIHBlZXJfcHJvdG9jb2wpXG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJbUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIubmVnb3RpYXRlXTogY29uZmxpY3RpbmcgbWFnaWMgcHJvdG9jb2wgbnVtYmVyc1wiXG4gICAgICAgICAgKHVzX3Byb3RvY29sIDogS25vd25fcHJvdG9jb2wudClcbiAgICAgICAgICAocGVlcl9wcm90b2NvbCA6IEtub3duX3Byb3RvY29sLnQpXVxuICBlbHNlIChcbiAgICBsZXQgcHJvdG9jb2wgPSB1c19wcm90b2NvbCBpblxuICAgIG1hdGNoIFNldC5tYXhfZWx0IChTZXQuaW50ZXIgdXNfdmVyc2lvbnMgcGVlcl92ZXJzaW9ucykgd2l0aFxuICAgIHwgU29tZSB2ZXJzaW9uIC0+IE9rIHZlcnNpb25cbiAgICB8IE5vbmUgLT5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJbUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIubmVnb3RpYXRlXTogbm8gc2hhcmVkIHZlcnNpb24gbnVtYmVyc1wiXG4gICAgICAgICAgICAodXNfdmVyc2lvbnMgOiBJbnQuU2V0LnQpXG4gICAgICAgICAgICAocGVlcl92ZXJzaW9ucyA6IEludC5TZXQudClcbiAgICAgICAgICAgIChwcm90b2NvbCA6IEtub3duX3Byb3RvY29sLnQpXSlcbjs7XG5cbmxldCBtYXRjaGVzX21hZ2ljX3ByZWZpeCAodCA6IHQpIH5wcm90b2NvbCA9XG4gIGxldCBtYWdpY19udW1iZXIgPSBLbm93bl9wcm90b2NvbC5tYWdpY19udW1iZXIgcHJvdG9jb2wgaW5cbiAgTGlzdC5tZW0gfmVxdWFsOkludC5lcXVhbCAocmF3X3ZlcnNpb25fbGlzdCB0KSBtYWdpY19udW1iZXJcbjs7XG5cbmxldCBjb250YWluc19tYWdpY19wcmVmaXggfnByb3RvY29sID1cbiAgQmluX3Byb3QuVHlwZV9jbGFzcy5jbnZfcmVhZGVyIChtYXRjaGVzX21hZ2ljX3ByZWZpeCB+cHJvdG9jb2wpIGJpbl90LnJlYWRlclxuOztcblxubGV0IGFueV9tYWdpY19wcmVmaXggPVxuICBsZXQgZiB0ID1cbiAgICBMaXN0LmZpbmQgS25vd25fcHJvdG9jb2wuYWxsIH5mOihmdW4gcHJvdG9jb2wgLT4gbWF0Y2hlc19tYWdpY19wcmVmaXggfnByb3RvY29sIHQpXG4gIGluXG4gIEJpbl9wcm90LlR5cGVfY2xhc3MuY252X3JlYWRlciBmIGJpbl90LnJlYWRlclxuOztcblxubGV0IG1hZ2ljX251bWJlcl9iaW5fc2l6ZSA9IDVcblxubW9kdWxlIE1hZ2ljX3ByZWZpeF9iaW5fcmVwciA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQgW0BAZGVyaXZpbmcgYmluX3NoYXBlLCBiaW5fd3JpdGVdXG5cbiAgKCogVGhlIGJpbiBwcm90IHJlcHJlc2VudGF0aW9uIG9mIGEgcHJvdG9jb2wgdmVyc2lvbiBoZWFkZXIgaXMgdGhlIHN0YW5kYXJkXG4gICAgIHJlcHJlc2VudGF0aW9uIGZvciBhbiBpbnQgbGlzdDpcblxuICAgICB8IG5hdDAgaW5kaWNhdGluZyBzaXplIHwgZWxlbWVudCAwIHwgZWxlbWVudCAxIHwgLi4uXG5cbiAgICAgW2NyZWF0ZV9leG5dIHdpbGwgYWx3YXlzIHB1dCB0aGUga25vd24gcHJvdG9jb2wgbWFnaWMgbnVtYmVyIGFzIFwiZWxlbWVudCAwXCIuXG5cbiAgICAgVGhlIGJpbiBzaXplIG9mIFwibmF0MCBpbmRpY2F0aW5nIHNpemVcIiBhbmQgXCJlbGVtZW50IDBcIiBpcyBmaXhlZCAodGhlcmUgYXJlIGV4cGVjdFxuICAgICB0ZXN0cyB0byBtYWtlIHN1cmUgd2UgbmV2ZXIgY2hhbmdlIHRoZW0pLiAqKVxuICBsZXQgYmluX3NpemUgPVxuICAgIGJpbl9zaXplX3QgQm91bmRlZF9saXN0X2luX2Nhc2Vfc29tZW9uZV9zZW5kc19nYXJiYWdlX29uX3RoZV93aXJlLm1heF9sZW5cbiAgICArIG1hZ2ljX251bWJlcl9iaW5fc2l6ZVxuICA7O1xuXG4gIGxldCBiaW5fcmVhZF90IGJ1ZiB+cG9zX3JlZiA9XG4gICAgbGV0IChfbGlzdF9sZW5ndGggOiBCaW5fcHJvdC5OYXQwLnQpID0gQmluX3Byb3QuUmVhZC5iaW5fcmVhZF9uYXQwIGJ1ZiB+cG9zX3JlZiBpblxuICAgIEJpbl9wcm90LlJlYWQuYmluX3JlYWRfaW50IGJ1ZiB+cG9zX3JlZlxuICA7O1xuXG4gIGxldCBiaW5fcmVhZGVyX3QgPVxuICAgIHsgQmluX3Byb3QuVHlwZV9jbGFzcy5yZWFkID0gYmluX3JlYWRfdDsgdnRhZ19yZWFkID0gSW50Ll9fYmluX3JlYWRfdF9fIH1cbiAgOztcbmVuZFxuXG5sZXQgYW55X21hZ2ljX3ByZWZpeF9mcm9tX3NpeF9ieXRlcyA9XG4gIEJpbl9wcm90LlR5cGVfY2xhc3MuY252X3JlYWRlclxuICAgIChmdW4gbWFnaWNfbnVtYmVyIC0+IChNYXAuZmluZCBLbm93bl9wcm90b2NvbC5ieV9tYWdpY19udW1iZXIpIG1hZ2ljX251bWJlcilcbiAgICBNYWdpY19wcmVmaXhfYmluX3JlcHIuYmluX3JlYWRlcl90XG47O1xuXG5sZXQgYW55X21hZ2ljX3ByZWZpeF9mcm9tX3NpeF9ieXRlc19iaW5fc2l6ZSA9IE1hZ2ljX3ByZWZpeF9iaW5fcmVwci5iaW5fc2l6ZVxuXG5tb2R1bGUgUGFpciA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID1cbiAgICB7IHVzIDogdFxuICAgIDsgcGVlciA6IHRcbiAgICB9XG5lbmRcblxubW9kdWxlIEV4cGVydCA9IHN0cnVjdFxuICBsZXQgcmF3X3ZlcnNpb25fbGlzdCA9IHJhd192ZXJzaW9uX2xpc3RcbiAgbGV0IG5vbmUgPSBCb3VuZGVkX2xpc3RfaW5fY2FzZV9zb21lb25lX3NlbmRzX2dhcmJhZ2Vfb25fdGhlX3dpcmUub2ZfbGlzdF9leG4gW11cblxuICBsZXQgaXNfbm9uZSAodCA6IHQpID1cbiAgICBtYXRjaCAodCA6PiBpbnQgbGlzdCkgd2l0aFxuICAgIHwgW10gLT4gdHJ1ZVxuICAgIHwgXyA6OiBfIC0+IGZhbHNlXG4gIDs7XG5lbmRcblxubW9kdWxlIEZvcl90ZXN0ID0gc3RydWN0XG4gIG1vZHVsZSBNYWtlX2xpc3Rfd2l0aF9tYXhfbGVuID0gTGlzdF93aXRoX21heF9sZW4uTWFrZVxuXG4gIGxldCBtYWdpY19udW1iZXJfYmluX3NpemUgPSBtYWdpY19udW1iZXJfYmluX3NpemVcbiAgbGV0IG1heF9zdXBwb3J0ZWRfdmVyc2lvbiA9IG1heF9zdXBwb3J0ZWRfdmVyc2lvblxuZW5kXG5cbmxldCV0ZXN0X3VuaXQgXCJiaW4gc2l6ZXMgYXJlIG5vdCBjaGFuZ2VkIGJ5IGFjY2lkZW50XCIgPVxuICAoKiBFbnN1cmUgdGhlIGJpbl9zaXplIG9mIEJvdW5kZWRfbGlzdF9pbl9jYXNlX3NvbWVvbmVfc2VuZHNfZ2FyYmFnZV9vbl90aGVfd2lyZS5tYXhfbGVuXG4gICAgIGlzIGFsd2F5cyAxLiBUaGlzIG1lYW5zIHRoYXQgcmVnYXJkbGVzcyBvZiBob3cgbG9uZyB0aGUgbGlzdCBvZiB2ZXJzaW9ucyBpbiB0aGVcbiAgICAgcHJvdG9jb2wgaGVhZGVyIGlzLCB0aGUgcmVwcmVzZW50YXRpb24gd2lsbCBiZSB0aGUgc2FtZSBudW1iZXIgb2YgYnl0ZXMuIFRoZVxuICAgICByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnQganVtcHMgdG8gMyBieXRlcyBhdCB0aGUgdmFsdWUgMTI4LiAqKVxuICBsZXQgYm91bmRlZF9saXN0X2Jpbl9zaXplID1cbiAgICBJbnQuYmluX3NpemVfdCBCb3VuZGVkX2xpc3RfaW5fY2FzZV9zb21lb25lX3NlbmRzX2dhcmJhZ2Vfb25fdGhlX3dpcmUubWF4X2xlblxuICBpblxuICBhc3NlcnQgKGJvdW5kZWRfbGlzdF9iaW5fc2l6ZSA9IDEpO1xuICBhc3NlcnQgKDYgPSBtYWdpY19udW1iZXJfYmluX3NpemUgKyBib3VuZGVkX2xpc3RfYmluX3NpemUpO1xuICBhc3NlcnQgKFxuICAgIGFueV9tYWdpY19wcmVmaXhfZnJvbV9zaXhfYnl0ZXNfYmluX3NpemVcbiAgICA9IG1hZ2ljX251bWJlcl9iaW5fc2l6ZSArIGJvdW5kZWRfbGlzdF9iaW5fc2l6ZSlcbjs7XG4iXX0=
