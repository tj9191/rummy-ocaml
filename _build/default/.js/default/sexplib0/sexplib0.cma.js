// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Sexplib0__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Sexplib0 = [0],
    Sexplib0$0 = [0, Sexplib0];
   runtime.caml_register_global(0, Sexplib0$0, "Sexplib0__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp
//# unitInfo: Requires: Stdlib__Buffer, Stdlib__Bytes, Stdlib__BytesLabels, Stdlib__Char, Stdlib__Format, Stdlib__ListLabels, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "(",
    cst$12 = "()",
    cst$13 = ")",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$2 = cst$11,
    cst$3 = cst$12,
    cst$4 = cst$13,
    cst$5 = " ",
    cst$6 = cst$11,
    cst$7 = cst$12,
    cst$8 = cst$13,
    cst$10 = cst$12,
    cst$9 = cst$12,
    cst = "\\",
    cst$0 = ' "',
    cst$1 = '"',
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    _b_ = [0, [15, [17, 2, 0]], "%a@?"],
    _a_ = [0, 0, 0],
    cst_n = "\\n",
    cst_Sexplib0_Sexp_Not_found_s = "Sexplib0__Sexp.Not_found_s",
    cst_Sexplib0_Sexp_Of_sexp_erro = "Sexplib0__Sexp.Of_sexp_error";
   function sexp_of_t(t){return t;}
   function t_of_sexp(t){return t;}
   function compare(a$0, b$0){
    if(a$0 === b$0) return 0;
    if(0 === a$0[0]){
     var a$1 = a$0[1];
     if(0 !== b$0[0]) return -1;
     var b$1 = b$0[1];
     return caml_call2(Stdlib_StringLabels[10], a$1, b$1);
    }
    var a$2 = a$0[1];
    if(0 === b$0[0]) return 1;
    var b$2 = b$0[1], a = a$2, b = b$2;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], res = compare(x, y);
     if(0 !== res) return res;
     var a = xs, b = ys;
    }
   }
   function equal(a, b){
    var _E_ = a === b ? 1 : 0;
    if(_E_)
     var _F_ = _E_;
    else{
     if(0 === a[0]){
      var a$0 = a[1];
      if(0 === b[0]){
       var b$0 = b[1];
       return caml_call2(Stdlib_StringLabels[9], a$0, b$0);
      }
     }
     else{
      var a$1 = a[1];
      if(0 !== b[0]){
       var b$1 = b[1];
       return caml_call3(Stdlib_ListLabels[16], equal, a$1, b$1);
      }
     }
     var _F_ = 0;
    }
    return _F_;
   }
   var
    Not_found_s = [248, cst_Sexplib0_Sexp_Not_found_s, caml_fresh_oo_id(0)],
    Of_sexp_error = [248, cst_Sexplib0_Sexp_Of_sexp_erro, caml_fresh_oo_id(0)],
    default_indent = [0, 1];
   function must_escape(str){
    var len = caml_ml_string_length(str), _u_ = 0 === len ? 1 : 0;
    if(_u_) return _u_;
    var ix$1 = len - 1 | 0, ix = ix$1;
    for(;;){
     var match = caml_string_get(str, ix);
     a:
     {
      b:
      {
       if(92 <= match){
        var switcher = match - 93 | 0;
        if(33 < switcher >>> 0){if(0 <= switcher) break a; break b;}
        if(31 === switcher){
         var _v_ = 0 < ix ? 1 : 0;
         if(_v_){
          var
           next = ix - 1 | 0,
           _w_ = caml_string_get(str, next),
           _x_ = caml_call2(Stdlib_Char[6], _w_, 35);
          if(! _x_){var ix = next; continue;}
          var _y_ = _x_;
         }
         else
          var _y_ = _v_;
         return _y_;
        }
       }
       else
        if(42 <= match){
         if(59 === match) break b;
        }
        else{
         if(33 > match) break a;
         switch(match - 33 | 0){
           case 2:
            var _A_ = 0 < ix ? 1 : 0;
            if(_A_){
             var
              next$0 = ix - 1 | 0,
              _B_ = caml_string_get(str, next$0),
              _C_ = caml_call2(Stdlib_Char[6], _B_, 124);
             if(! _C_){var ix = next$0; continue;}
             var _D_ = _C_;
            }
            else
             var _D_ = _A_;
            return _D_;
           case 1:
           case 7:
           case 8:
            break b;
         }
        }
       var _z_ = 0 < ix ? 1 : 0;
       if(! _z_) return _z_;
       var ix$0 = ix - 1 | 0, ix = ix$0;
       continue;
      }
      return 1;
     }
     return 1;
    }
   }
   function escaped(s){
    var n = [0, 0], _k_ = caml_ml_string_length(s) - 1 | 0, _j_ = 0;
    if(_k_ >= 0){
     var i$0 = _j_;
     for(;;){
      var match = caml_string_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var _r_ = match - 34 | 0;
          if(58 < _r_ >>> 0){
           if(93 <= _r_) break c;
          }
          else if(56 < _r_ - 1 >>> 0) break b;
          var _s_ = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var _s_ = 4;
        break a;
       }
       var _s_ = 2;
      }
      n[1] = n[1] + _s_ | 0;
      var _t_ = i$0 + 1 | 0;
      if(_k_ === i$0) break;
      var i$0 = _t_;
     }
    }
    if(n[1] === caml_ml_string_length(s)) return s;
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _m_ = caml_ml_string_length(s) - 1 | 0, _l_ = 0;
    if(_m_ >= 0){
     var i = _l_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break c; break b;}
         }
         else{
          if(32 > c){
           if(14 <= c) break c;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break c;
           }
          }
          if(34 > c) break b;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], 92);
        n[1]++;
        var _o_ = caml_call1(Stdlib_Char[1], 48 + (c / 100 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _o_);
        n[1]++;
        var
         _p_ = caml_call1(Stdlib_Char[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _p_);
        n[1]++;
        var _q_ = caml_call1(Stdlib_Char[1], 48 + (c % 10 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _q_);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], c);
      }
      n[1]++;
      var _n_ = i + 1 | 0;
      if(_m_ === i) break;
      var i = _n_;
     }
    }
    return caml_call1(Stdlib_BytesLabels[44], s$0);
   }
   function esc_str(str){
    var
     estr = escaped(str),
     elen = caml_ml_string_length(estr),
     res = caml_create_bytes(elen + 2 | 0);
    caml_call5(Stdlib_Bytes[12], estr, 0, res, 1, elen);
    caml_bytes_unsafe_set(res, 0, 34);
    caml_bytes_unsafe_set(res, elen + 1 | 0, 34);
    return caml_call1(Stdlib_BytesLabels[44], res);
   }
   function index_of_newline(str, start){
    return caml_call3(Stdlib_StringLabels[33], str, start, 10);
   }
   function mach_maybe_esc_str(str){
    return must_escape(str) ? esc_str(str) : str;
   }
   function pp_hum_indent(indent, ppf, param){
    if(0 === param[0]){
     var str = param[1];
     if(! must_escape(str)) return caml_call2(Stdlib_Format[13], ppf, str);
     var match = index_of_newline(str, 0);
     if(match)
      var
       index = match[1],
       _g_ = (index + 1 | 0) === caml_ml_string_length(str) ? 1 : 0;
     else
      var _g_ = 1;
     if(_g_){
      var _h_ = esc_str(str);
      return caml_call2(Stdlib_Format[13], ppf, _h_);
     }
     caml_call2(Stdlib_Format[1], ppf, 0);
     caml_call2(Stdlib_Format[13], ppf, cst$0);
     var index$0 = 0;
     for(;;){
      var next_newline = index_of_newline(str, index$0);
      if(next_newline)
       var end_pos = next_newline[1], end_pos$0 = end_pos;
      else
       var end_pos$0 = caml_ml_string_length(str);
      var
       next_line =
         caml_call3
          (Stdlib_StringLabels[16], str, index$0, end_pos$0 - index$0 | 0),
       _i_ = escaped(next_line);
      caml_call2(Stdlib_Format[13], ppf, _i_);
      if(! next_newline){
       caml_call2(Stdlib_Format[13], ppf, cst$1);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var newline_index = next_newline[1];
      caml_call2(Stdlib_Format[13], ppf, cst);
      caml_call2(Stdlib_Format[34], ppf, 0);
      caml_call2(Stdlib_Format[13], ppf, cst_n);
      var index$1 = newline_index + 1 | 0, index$0 = index$1;
     }
    }
    else{
     var match$0 = param[1];
     if(! match$0) return caml_call2(Stdlib_Format[13], ppf, cst$3);
     var t = match$0[2], h = match$0[1];
     caml_call2(Stdlib_Format[1], ppf, indent);
     caml_call2(Stdlib_Format[13], ppf, cst$2);
     pp_hum_indent(indent, ppf, h);
     var param$0 = t;
     for(;;){
      if(! param$0){
       caml_call2(Stdlib_Format[13], ppf, cst$4);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var t$0 = param$0[2], h$0 = param$0[1];
      caml_call2(Stdlib_Format[27], ppf, 0);
      pp_hum_indent(indent, ppf, h$0);
      var param$0 = t$0;
     }
    }
   }
   function pp_mach_internal(may_need_space, ppf, param){
    if(0 === param[0]){
     var
      str = param[1],
      str$0 = mach_maybe_esc_str(str),
      new_may_need_space = str$0 === str ? 1 : 0,
      new_may_need_space$0 =
        may_need_space ? new_may_need_space : may_need_space;
     if(new_may_need_space$0) caml_call2(Stdlib_Format[13], ppf, cst$5);
     caml_call2(Stdlib_Format[13], ppf, str$0);
     return new_may_need_space;
    }
    var match = param[1];
    if(! match){caml_call2(Stdlib_Format[13], ppf, cst$7); return 0;}
    var t = match[2], h = match[1];
    caml_call2(Stdlib_Format[13], ppf, cst$6);
    var
     may_need_space$0 = pp_mach_internal(0, ppf, h),
     may_need_space$1 = may_need_space$0,
     param$0 = t;
    for(;;){
     if(! param$0){caml_call2(Stdlib_Format[13], ppf, cst$8); return 0;}
     var
      t$0 = param$0[2],
      h$0 = param$0[1],
      may_need_space$2 = pp_mach_internal(may_need_space$1, ppf, h$0),
      may_need_space$1 = may_need_space$2,
      param$0 = t$0;
    }
   }
   function pp_hum(ppf, sexp){
    return pp_hum_indent(default_indent[1], ppf, sexp);
   }
   function pp_mach(ppf, sexp){pp_mach_internal(0, ppf, sexp); return 0;}
   function size_loop(acc, param){
    var c = acc[2], v = acc[1];
    if(0 === param[0]){
     var str = param[1];
     return [0, v + 1 | 0, c + caml_ml_string_length(str) | 0];
    }
    var lst = param[1];
    return caml_call3(Stdlib_ListLabels[26], size_loop, acc, lst);
   }
   function size(sexp){return size_loop(_a_, sexp);}
   function to_buffer_hum(buf, opt, sexp){
    if(opt)
     var sth = opt[1], indent = sth;
    else
     var indent = default_indent[1];
    var ppf = caml_call1(Stdlib_Format[114], buf);
    function _d_(_e_, _f_){return pp_hum_indent(indent, _e_, _f_);}
    return caml_call4(Stdlib_Format[137], ppf, _b_, _d_, sexp);
   }
   function to_buffer_mach(buf, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(Stdlib_Buffer[12], buf, 32);
      caml_call2(Stdlib_Buffer[16], buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(Stdlib_Buffer[16], buf, cst$9); return 0;}
     var t = match[2], h = match[1];
     caml_call2(Stdlib_Buffer[12], buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(Stdlib_Buffer[12], buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0),
       may_need_space$1 = may_need_space$2,
       param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function to_buffer_gen(buf, add_char, add_string, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(add_char, buf, 32);
      caml_call2(add_string, buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(add_string, buf, cst$10); return 0;}
     var t = match[2], h = match[1];
     caml_call2(add_char, buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(add_char, buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0),
       may_need_space$1 = may_need_space$2,
       param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function buffer(param){return caml_call1(Stdlib_Buffer[1], 1024);}
   function to_string_hum(indent, sexp){
    if(0 === sexp[0]){
     var str = sexp[1], _c_ = index_of_newline(str, 0) ? 0 : 1;
     if(_c_) return mach_maybe_esc_str(str);
    }
    var buf = buffer(0);
    to_buffer_hum(buf, indent, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function to_string_mach(sexp){
    if(0 === sexp[0]){var str = sexp[1]; return mach_maybe_esc_str(str);}
    var buf = buffer(0);
    to_buffer_mach(buf, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   var of_float_style = [0, 1009018843], of_int_style = [0, 1009018843];
   function message(name, fields){
    function conv_fields(param){
     if(! param) return 0;
     var
      rest = param[2],
      match = param[1],
      fsexp = match[2],
      fname = match[1];
     return runtime.caml_string_notequal(fname, "")
             ? [0, [1, [0, [0, fname], [0, fsexp, 0]]], conv_fields(rest)]
             : [0, fsexp, conv_fields(rest)];
    }
    return [1, [0, [0, name], conv_fields(fields)]];
   }
   var
    Sexplib0_Sexp =
      [0,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp_mach,
       to_string_hum,
       to_string_mach,
       to_string_mach,
       of_float_style,
       of_int_style,
       [0,
        size,
        buffer,
        to_buffer_mach,
        to_buffer_hum,
        to_buffer_mach,
        to_buffer_gen,
        mach_maybe_esc_str,
        must_escape,
        esc_str]];
   runtime.caml_register_global(25, Sexplib0_Sexp, "Sexplib0__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_grammar
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    doc_comment_tag = "sexp_grammar.doc_comment",
    type_name_tag = "sexp_grammar.type_name",
    assoc_tag = "sexp_grammar.assoc",
    assoc_key_tag = "sexp_grammar.assoc.key",
    assoc_value_tag = "sexp_grammar.assoc.value",
    completion_suggested = "sexp_grammar.completion-suggested";
   function coerce(t){return t;}
   function tag(param, key, value){return [5, [0, key, value, param]];}
   var
    Sexplib0_Sexp_grammar =
      [0,
       coerce,
       tag,
       doc_comment_tag,
       type_name_tag,
       assoc_tag,
       assoc_key_tag,
       assoc_value_tag,
       completion_suggested];
   runtime.caml_register_global
    (6, Sexplib0_Sexp_grammar, "Sexplib0__Sexp_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_grammar
//# unitInfo: Requires: Sexplib0__Sexp_grammar, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    unit_sexp_grammar = [2, 0],
    sexp_t_sexp_grammar = [0, "Sexp.t"],
    empty_sexp_grammar = [4, 0],
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels;
   function sexp_grammar_with_tags(grammar, tags){
    function _b_(param, grammar){
     var value = param[2], key = param[1];
     return [5, [0, key, value, grammar]];
    }
    return caml_call3(Stdlib_ListLabels[27], _b_, tags, grammar);
   }
   function sexp_grammar_with_tag_list(x, tags){
    function _a_(param, grammar){
     var value = param[2], key = param[1];
     return [0, [0, key, value, grammar]];
    }
    return caml_call3(Stdlib_ListLabels[27], _a_, tags, x);
   }
   var
    bool_sexp_grammar = 0,
    string_sexp_grammar = 4,
    bytes_sexp_grammar = 4,
    char_sexp_grammar = 1,
    int_sexp_grammar = 2,
    float_sexp_grammar = 3,
    int32_sexp_grammar = 2,
    int64_sexp_grammar = 2,
    nativeint_sexp_grammar = 2;
   function ref_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function lazy_t_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function option_sexp_grammar(param){return [1, param];}
   function list_sexp_grammar(param){return [2, [1, param]];}
   function array_sexp_grammar(param){return [2, [1, param]];}
   var
    Sexplib0_Sexp_conv_grammar =
      [0,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       empty_sexp_grammar,
       empty_sexp_grammar];
   runtime.caml_register_global
    (5, Sexplib0_Sexp_conv_grammar, "Sexplib0__Sexp_conv_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv
//# unitInfo: Requires: CamlinternalLazy, Sexplib0__Sexp, Sexplib0__Sexp_conv_grammar, Stdlib, Stdlib__Arg, Stdlib__ArrayLabels, Stdlib__BytesLabels, Stdlib__Ephemeron, Stdlib__Int32, Stdlib__Int64, Stdlib__Lazy, Stdlib__ListLabels, Stdlib__MoreLabels, Stdlib__Nativeint, Stdlib__Obj, Stdlib__Parsing, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue, Stdlib__Scanf, Stdlib__Stack, Stdlib__StringLabels, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Assert_failure$0 = "Assert_failure",
    cst_None = "None",
    cst_Some = "Some",
    cst_none = "none",
    cst_option_of_sexp_only_none_c$1 = "option_of_sexp: only none can be atom",
    cst_some = "some",
    cst_src_sexp_conv_ml = "src/sexp_conv.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_format_float = runtime.caml_format_float,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Parsing = global_data.Stdlib__Parsing,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Stack = global_data.Stdlib__Stack,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Obj = global_data.Stdlib__Obj,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Ephemeron = global_data.Stdlib__Ephemeron,
    Sexplib0_Sexp_conv_grammar = global_data.Sexplib0__Sexp_conv_grammar,
    _aF_ = [0, 0],
    _aG_ = [0, 1],
    _aB_ = [0, "Sexplib.Conv.Of_sexp_error"],
    _aC_ = [0, cst_src_sexp_conv_ml, 406, 15],
    _ay_ = [0, 0],
    _az_ = [0, 0],
    cst_Assert_failure = cst_Assert_failure$0,
    _av_ = [0, cst_src_sexp_conv_ml, 330, 15],
    _ar_ = [0, "Exit"],
    _as_ = [0, cst_src_sexp_conv_ml, 334, 15],
    _an_ = [0, "End_of_file"],
    _ao_ = [0, cst_src_sexp_conv_ml, 338, 15],
    _aj_ = [0, "Failure"],
    _ak_ = [0, cst_src_sexp_conv_ml, 342, 15],
    _af_ = [0, "Not_found"],
    _ag_ = [0, cst_src_sexp_conv_ml, 346, 15],
    _ab_ = [0, "Invalid_argument"],
    _ac_ = [0, cst_src_sexp_conv_ml, 350, 15],
    cst_Match_failure = "Match_failure",
    ___ = [0, cst_src_sexp_conv_ml, 354, 15],
    _W_ = [0, "Not_found_s"],
    _X_ = [0, cst_src_sexp_conv_ml, 358, 15],
    _S_ = [0, "Sys_error"],
    _T_ = [0, cst_src_sexp_conv_ml, 362, 15],
    _O_ = [0, "Arg.Help"],
    _P_ = [0, cst_src_sexp_conv_ml, 366, 15],
    _K_ = [0, "Arg.Bad"],
    _L_ = [0, cst_src_sexp_conv_ml, 370, 15],
    _G_ = [0, "Lazy.Undefined"],
    _H_ = [0, cst_src_sexp_conv_ml, 374, 15],
    _C_ = [0, "Parsing.Parse_error"],
    _D_ = [0, cst_src_sexp_conv_ml, 378, 15],
    _y_ = [0, "Queue.Empty"],
    _z_ = [0, cst_src_sexp_conv_ml, 382, 15],
    _u_ = [0, "Scanf.Scan_failure"],
    _v_ = [0, cst_src_sexp_conv_ml, 386, 15],
    _q_ = [0, "Stack.Empty"],
    _r_ = [0, cst_src_sexp_conv_ml, 390, 15],
    _m_ = [0, "Sys.Break"],
    _n_ = [0, cst_src_sexp_conv_ml, 394, 15],
    _j_ =
      [0,
       [2,
        0,
        [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, [12, 58, [4, 0, 0, 0, 0]]]]]]],
       "%s %s:%d:%d"],
    cst_fun_of_sexp_cannot_convert =
      "fun_of_sexp: cannot convert function values",
    cst_opaque_of_sexp_cannot_conv =
      "opaque_of_sexp: cannot convert opaque values",
    cst_hashtbl_of_sexp_tuple_list = "hashtbl_of_sexp: tuple list needed",
    cst_hashtbl_of_sexp_list_neede = "hashtbl_of_sexp: list needed",
    cst_array_of_sexp_list_needed = "array_of_sexp: list needed",
    cst_list_of_sexp_list_needed = "list_of_sexp: list needed",
    cst_triple_of_sexp_list_needed = "triple_of_sexp: list needed",
    cst_triple_of_sexp_list_must_c =
      "triple_of_sexp: list must contain exactly three elements only",
    cst_pair_of_sexp_list_needed = "pair_of_sexp: list needed",
    cst_pair_of_sexp_list_must_con =
      "pair_of_sexp: list must contain exactly two elements only",
    cst_option_of_sexp_only_none_c = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_r =
      "option_of_sexp: list must represent optional value",
    cst_option_of_sexp_only_none_c$0 = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_b = "option_of_sexp: list must be (some el)",
    cst_nativeint_of_sexp = "nativeint_of_sexp: ",
    cst_nativeint_of_sexp_atom_nee = "nativeint_of_sexp: atom needed",
    cst_int64_of_sexp = "int64_of_sexp: ",
    cst_int64_of_sexp_atom_needed = "int64_of_sexp: atom needed",
    cst_int32_of_sexp = "int32_of_sexp: ",
    cst_int32_of_sexp_atom_needed = "int32_of_sexp: atom needed",
    cst_float_of_sexp = "float_of_sexp: ",
    cst_float_of_sexp_atom_needed = "float_of_sexp: atom needed",
    cst_int_of_sexp = "int_of_sexp: ",
    cst_int_of_sexp_atom_needed = "int_of_sexp: atom needed",
    cst_char_of_sexp_atom_string_m =
      "char_of_sexp: atom string must contain one character only",
    cst_char_of_sexp_atom_needed = "char_of_sexp: atom needed",
    cst_bytes_of_sexp_atom_needed = "bytes_of_sexp: atom needed",
    cst_string_of_sexp_atom_needed = "string_of_sexp: atom needed",
    cst_bool_of_sexp_unknown_strin = "bool_of_sexp: unknown string",
    cst_bool_of_sexp_atom_needed = "bool_of_sexp: atom needed",
    cst_unit_of_sexp_empty_list_ne = "unit_of_sexp: empty list needed",
    _i_ = [0, 2],
    _h_ = [0, 2],
    _f_ = [0, "<fun>"],
    _e_ = [0, "<opaque>"],
    _b_ = [0, cst_some],
    _c_ = [1, 0],
    _d_ = [0, cst_none],
    _a_ = [1, 0],
    default_string_of_float =
      [0,
       function(x){
        var y = caml_format_float("%.15G", x);
        return caml_float_of_string(y) == x
                ? y
                : caml_format_float("%.17G", x);
       }],
    read_old_option_format = [0, 1],
    write_old_option_format = [0, 1];
   function list_map(f, l){return caml_call2(Stdlib_ListLabels[20], f, l);}
   function sexp_of_unit(param){return _a_;}
   function sexp_of_bool(b){return [0, caml_call1(Stdlib[30], b)];}
   function sexp_of_string(str){return [0, str];}
   function sexp_of_bytes(bytes){
    return [0, caml_call1(Stdlib_BytesLabels[6], bytes)];
   }
   function sexp_of_char(c){
    return [0, caml_call2(Stdlib_StringLabels[1], 1, c)];
   }
   function sexp_of_int(n){return [0, caml_call1(Stdlib[33], n)];}
   function sexp_of_float(n){
    return [0, caml_call1(default_string_of_float[1], n)];
   }
   function sexp_of_int32(n){return [0, caml_call1(Stdlib_Int32[14], n)];}
   function sexp_of_int64(n){return [0, caml_call1(Stdlib_Int64[14], n)];}
   function sexp_of_nativeint(n){
    return [0, caml_call1(Stdlib_Nativeint[15], n)];
   }
   function sexp_of_ref(sexp_of_a, rf){return caml_call1(sexp_of_a, rf[1]);}
   function sexp_of_lazy_t(sexp_of_a, lv){
    var _bl_ = runtime.caml_obj_tag(lv);
    a:
    if(250 === _bl_)
     var _bm_ = lv[1];
    else{
     if(246 !== _bl_ && 244 !== _bl_){var _bm_ = lv; break a;}
     var _bm_ = caml_call1(CamlinternalLazy[2], lv);
    }
    return caml_call1(sexp_of_a, _bm_);
   }
   function sexp_of_option(sexp_of_a, param){
    if(! param) return write_old_option_format[1] ? _c_ : _d_;
    var x = param[1];
    return write_old_option_format[1]
            ? [1, [0, caml_call1(sexp_of_a, x), 0]]
            : [1, [0, _b_, [0, caml_call1(sexp_of_a, x), 0]]];
   }
   function sexp_of_pair(sexp_of_a, sexp_of_b, param){
    var b = param[2], a = param[1], _bk_ = [0, caml_call1(sexp_of_b, b), 0];
    return [1, [0, caml_call1(sexp_of_a, a), _bk_]];
   }
   function sexp_of_triple(sexp_of_a, sexp_of_b, sexp_of_c, param){
    var
     c = param[3],
     b = param[2],
     a = param[1],
     _bi_ = [0, caml_call1(sexp_of_c, c), 0],
     _bj_ = [0, caml_call1(sexp_of_b, b), _bi_];
    return [1, [0, caml_call1(sexp_of_a, a), _bj_]];
   }
   function sexp_of_list(sexp_of_a, lst){
    return [1, caml_call2(Stdlib_ListLabels[20], sexp_of_a, lst)];
   }
   function sexp_of_array(sexp_of_a, ar){
    var lst_ref = [0, 0], _bf_ = ar.length - 1 - 1 | 0;
    if(_bf_ >= 0){
     var i = _bf_;
     for(;;){
      var _bg_ = lst_ref[1];
      lst_ref[1] =
       [0, caml_call1(sexp_of_a, caml_check_bound(ar, i)[1 + i]), _bg_];
      var _bh_ = i - 1 | 0;
      if(0 === i) break;
      var i = _bh_;
     }
    }
    return [1, lst_ref[1]];
   }
   function sexp_of_hashtbl(sexp_of_key, sexp_of_val, htbl){
    function coll(k, v, acc){
     var _be_ = [0, caml_call1(sexp_of_val, v), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, k), _be_]], acc];
    }
    return [1, caml_call3(Stdlib_MoreLabels[1][14], coll, htbl, 0)];
   }
   function sexp_of_opaque(param){return _e_;}
   function sexp_of_fun(param){return _f_;}
   function equal(_bd_, _bc_){return _bd_ === _bc_ ? 1 : 0;}
   var
    hash = Stdlib_Obj[23][3],
    Exn_table = caml_call1(Stdlib_Ephemeron[1][3], [0, equal, hash]),
    the_exn_table = caml_call1(Exn_table[1], 17);
   function add(opt, param, extension_constructor, sexp_of_exn){
    if(opt) var sth = opt[1], printexc = sth; else var printexc = 1;
    return caml_call3
            (Exn_table[5],
             the_exn_table,
             extension_constructor,
             [0, sexp_of_exn, printexc]);
   }
   function find_auto(for_printexc, exn){
    var
     extension_constructor = caml_call1(Stdlib_Obj[23][1], exn),
     match = caml_call2(Exn_table[8], the_exn_table, extension_constructor);
    if(! match) return 0;
    var match$0 = match[1], printexc = match$0[2], sexp_of_exn = match$0[1];
    if(for_printexc && ! printexc) return 0;
    return [0, caml_call1(sexp_of_exn, exn)];
   }
   function size(param){return caml_call1(Exn_table[18], the_exn_table)[1];}
   var For_unit_tests_only = [0, size];
   function sexp_of_exn_opt(exn){return find_auto(0, exn);}
   function sexp_of_exn(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return [1, [0, [0, caml_call1(Stdlib_Printexc[1], exn)], 0]];
    var sexp = match[1];
    return sexp;
   }
   function exn_to_string(e){
    var _bb_ = sexp_of_exn(e);
    return caml_call2(Sexplib0_Sexp[13], 0, _bb_);
   }
   function _g_(exn){
    var match = find_auto(1, exn);
    if(! match) return 0;
    var sexp = match[1];
    return [0, caml_call2(Sexplib0_Sexp[13], _h_, sexp)];
   }
   caml_call1(Stdlib_Printexc[9], _g_);
   function printexc_prefer_sexp(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return caml_call1(Stdlib_Printexc[1], exn);
    var sexp = match[1];
    return caml_call2(Sexplib0_Sexp[13], _i_, sexp);
   }
   var Of_sexp_error = Sexplib0_Sexp[6], record_check_extra_fields = [0, 1];
   function of_sexp_error_exn(exc, sexp){
    throw caml_maybe_attach_backtrace([0, Of_sexp_error, exc, sexp], 1);
   }
   function of_sexp_error(what, sexp){
    throw caml_maybe_attach_backtrace
           ([0, Of_sexp_error, [0, Stdlib[7], what], sexp], 1);
   }
   function unit_of_sexp(sexp){
    if(1 === sexp[0] && ! sexp[1]) return 0;
    return of_sexp_error(cst_unit_of_sexp_empty_list_ne, sexp);
   }
   function bool_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bool_of_sexp_atom_needed, sexp);
    var _ba_ = sexp[1];
    a:
    if(caml_string_notequal(_ba_, "False")){
     if(caml_string_notequal(_ba_, "True")){
      if(! caml_string_notequal(_ba_, "false")) break a;
      if(caml_string_notequal(_ba_, "true"))
       return of_sexp_error(cst_bool_of_sexp_unknown_strin, sexp);
     }
     return 1;
    }
    return 0;
   }
   function string_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_string_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return str;
   }
   function bytes_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bytes_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return caml_call1(Stdlib_BytesLabels[5], str);
   }
   function char_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_char_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    if(1 !== runtime.caml_ml_string_length(str))
     of_sexp_error(cst_char_of_sexp_atom_string_m, sexp);
    return runtime.caml_string_get(str, 0);
   }
   function int_of_sexp(sexp){
    if(0 !== sexp[0]) return of_sexp_error(cst_int_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a$_ = caml_int_of_string(str); return _a$_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a__ = exn_to_string(exc);
     return of_sexp_error(caml_call2(Stdlib[28], cst_int_of_sexp, _a__), sexp);
    }
   }
   function float_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_float_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a9_ = caml_float_of_string(str); return _a9_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a8_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_float_of_sexp, _a8_), sexp);
    }
   }
   function int32_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int32_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a7_ = caml_int_of_string(str); return _a7_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a6_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int32_of_sexp, _a6_), sexp);
    }
   }
   function int64_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int64_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a5_ = runtime.caml_int64_of_string(str); return _a5_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a4_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int64_of_sexp, _a4_), sexp);
    }
   }
   function nativeint_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_nativeint_of_sexp_atom_nee, sexp);
    var str = sexp[1];
    try{var _a3_ = caml_int_of_string(str); return _a3_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a2_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_nativeint_of_sexp, _a2_), sexp);
    }
   }
   function ref_of_sexp(a_of_sexp, sexp){
    return [0, caml_call1(a_of_sexp, sexp)];
   }
   function lazy_t_of_sexp(a_of_sexp, sexp){
    var _a1_ = caml_call1(a_of_sexp, sexp);
    return caml_call1(Stdlib_Lazy[4], _a1_);
   }
   function option_of_sexp(a_of_sexp, sexp){
    if(! read_old_option_format[1]){
     if(0 === sexp[0]){
      var _aW_ = sexp[1];
      if
       (caml_string_notequal(_aW_, cst_None)
        && caml_string_notequal(_aW_, cst_none))
       return of_sexp_error(cst_option_of_sexp_only_none_c$0, sexp);
      return 0;
     }
     var _aX_ = sexp[1];
     a:
     if(_aX_){
      var _aY_ = _aX_[1];
      if(0 === _aY_[0]){
       var _aZ_ = _aY_[1];
       if
        (caml_string_notequal(_aZ_, cst_Some)
         && caml_string_notequal(_aZ_, cst_some))
        break a;
       var _a0_ = _aX_[2];
       if(_a0_ && ! _a0_[2]){
        var el$0 = _a0_[1];
        return [0, caml_call1(a_of_sexp, el$0)];
       }
      }
     }
     return of_sexp_error(cst_option_of_sexp_list_must_b, sexp);
    }
    if(0 === sexp[0]){
     var _aR_ = sexp[1];
     if
      (caml_string_notequal(_aR_, cst_None)
       && caml_string_notequal(_aR_, cst_none))
      return of_sexp_error(cst_option_of_sexp_only_none_c, sexp);
    }
    else{
     var _aS_ = sexp[1];
     if(_aS_){
      var _aT_ = _aS_[1];
      a:
      {
       if(_aS_[2]){
        b:
        if(0 === _aT_[0]){
         var _aU_ = _aT_[1];
         if
          (caml_string_notequal(_aU_, cst_Some)
           && caml_string_notequal(_aU_, cst_some))
          break b;
         var _aV_ = _aS_[2];
         if(! _aV_[2]){var el = _aV_[1]; break a;}
        }
        return of_sexp_error(cst_option_of_sexp_list_must_r, sexp);
       }
       var el = _aT_;
      }
      return [0, caml_call1(a_of_sexp, el)];
     }
    }
    return 0;
   }
   function pair_of_sexp(a_of_sexp, b_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_pair_of_sexp_list_needed, sexp);
    var _aP_ = sexp[1];
    if(_aP_){
     var _aQ_ = _aP_[2];
     if(_aQ_ && ! _aQ_[2]){
      var
       b_sexp = _aQ_[1],
       a_sexp = _aP_[1],
       a = caml_call1(a_of_sexp, a_sexp),
       b = caml_call1(b_of_sexp, b_sexp);
      return [0, a, b];
     }
    }
    return of_sexp_error(cst_pair_of_sexp_list_must_con, sexp);
   }
   function triple_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_triple_of_sexp_list_needed, sexp);
    var _aM_ = sexp[1];
    if(_aM_){
     var _aN_ = _aM_[2];
     if(_aN_){
      var _aO_ = _aN_[2];
      if(_aO_ && ! _aO_[2]){
       var
        c_sexp = _aO_[1],
        b_sexp = _aN_[1],
        a_sexp = _aM_[1],
        a = caml_call1(a_of_sexp, a_sexp),
        b = caml_call1(b_of_sexp, b_sexp),
        c = caml_call1(c_of_sexp, c_sexp);
       return [0, a, b, c];
      }
     }
    }
    return of_sexp_error(cst_triple_of_sexp_list_must_c, sexp);
   }
   function list_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_list_of_sexp_list_needed, sexp);
    var lst = sexp[1];
    return caml_call2(Stdlib_ListLabels[20], a_of_sexp, lst);
   }
   function array_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_array_of_sexp_list_needed, sexp);
    var match = sexp[1];
    if(! match) return [0];
    var
     t = match[2],
     h = match[1],
     len = caml_call1(Stdlib_ListLabels[1], t) + 1 | 0,
     res = runtime.caml_make_vect(len, caml_call1(a_of_sexp, h)),
     i = 1,
     param = t;
    for(;;){
     if(! param) return res;
     var t$0 = param[2], h$0 = param[1], _aL_ = caml_call1(a_of_sexp, h$0);
     caml_check_bound(res, i)[1 + i] = _aL_;
     var i$0 = i + 1 | 0, i = i$0, param = t$0;
    }
   }
   function hashtbl_of_sexp(key_of_sexp, val_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_hashtbl_of_sexp_list_neede, sexp);
    var lst = sexp[1], htbl = caml_call2(Stdlib_MoreLabels[1][1], 0, 0);
    function act(param){
     if(1 === param[0]){
      var _aH_ = param[1];
      if(_aH_){
       var _aI_ = _aH_[2];
       if(_aI_ && ! _aI_[2]){
        var
         v_sexp = _aI_[1],
         k_sexp = _aH_[1],
         _aJ_ = caml_call1(val_of_sexp, v_sexp),
         _aK_ = caml_call1(key_of_sexp, k_sexp);
        return caml_call3(Stdlib_MoreLabels[1][5], htbl, _aK_, _aJ_);
       }
      }
     }
     return of_sexp_error(cst_hashtbl_of_sexp_tuple_list, sexp);
    }
    caml_call2(Stdlib_ListLabels[18], act, lst);
    return htbl;
   }
   function opaque_of_sexp(sexp){
    return of_sexp_error(cst_opaque_of_sexp_cannot_conv, sexp);
   }
   function fun_of_sexp(sexp){
    return of_sexp_error(cst_fun_of_sexp_cannot_convert, sexp);
   }
   var
    sexp_grammar_with_tags = Sexplib0_Sexp_conv_grammar[1],
    sexp_grammar_with_tag_list = Sexplib0_Sexp_conv_grammar[2],
    unit_sexp_grammar = Sexplib0_Sexp_conv_grammar[3],
    bool_sexp_grammar = Sexplib0_Sexp_conv_grammar[4],
    string_sexp_grammar = Sexplib0_Sexp_conv_grammar[5],
    bytes_sexp_grammar = Sexplib0_Sexp_conv_grammar[6],
    char_sexp_grammar = Sexplib0_Sexp_conv_grammar[7],
    int_sexp_grammar = Sexplib0_Sexp_conv_grammar[8],
    float_sexp_grammar = Sexplib0_Sexp_conv_grammar[9],
    int32_sexp_grammar = Sexplib0_Sexp_conv_grammar[10],
    int64_sexp_grammar = Sexplib0_Sexp_conv_grammar[11],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv_grammar[12],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[13],
    ref_sexp_grammar = Sexplib0_Sexp_conv_grammar[14],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[15],
    option_sexp_grammar = Sexplib0_Sexp_conv_grammar[16],
    list_sexp_grammar = Sexplib0_Sexp_conv_grammar[17],
    array_sexp_grammar = Sexplib0_Sexp_conv_grammar[18],
    opaque_sexp_grammar = Sexplib0_Sexp_conv_grammar[19],
    fun_sexp_grammar = Sexplib0_Sexp_conv_grammar[20];
   function get_flc_error(name, param){
    var chr = param[3], line = param[2], file = param[1];
    return [0, caml_call5(Stdlib_Printf[4], _j_, name, file, line, chr)];
   }
   var _k_ = 0;
   function _l_(param){
    if(param === Stdlib_Sys[44]) return _m_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
   }
   var _o_ = [0, [0, Stdlib_Sys[44], _l_], _k_];
   function _p_(param){
    if(param === Stdlib_Stack[1]) return _q_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
   }
   var _s_ = [0, [0, Stdlib_Stack[1], _p_], _o_];
   function _t_(param){
    if(param[1] !== Stdlib_Scanf[2])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
    var arg = param[2];
    return [1, [0, _u_, [0, [0, arg], 0]]];
   }
   var _w_ = [0, [0, Stdlib_Scanf[2], _t_], _s_];
   function _x_(param){
    if(param === Stdlib_Queue[1]) return _y_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
   }
   var _A_ = [0, [0, Stdlib_Queue[1], _x_], _w_];
   function _B_(param){
    if(param === Stdlib_Parsing[10]) return _C_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
   }
   var _E_ = [0, [0, Stdlib_Parsing[10], _B_], _A_];
   function _F_(param){
    if(param === Stdlib_Lazy[1]) return _G_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
   }
   var _I_ = [0, [0, Stdlib_Lazy[1], _F_], _E_];
   function _J_(param){
    if(param[1] !== Stdlib_Arg[8])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
    var arg = param[2];
    return [1, [0, _K_, [0, [0, arg], 0]]];
   }
   var _M_ = [0, [0, Stdlib_Arg[8], _J_], _I_];
   function _N_(param){
    if(param[1] !== Stdlib_Arg[7])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
    var arg = param[2];
    return [1, [0, _O_, [0, [0, arg], 0]]];
   }
   var _Q_ = [0, [0, Stdlib_Arg[7], _N_], _M_];
   function _R_(param){
    if(param[1] !== Stdlib[11])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
    var arg = param[2];
    return [1, [0, _S_, [0, [0, arg], 0]]];
   }
   var _U_ = [0, [0, Stdlib[11], _R_], _Q_];
   function _V_(param){
    if(param[1] !== Sexplib0_Sexp[5])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
    var arg = param[2];
    return [1, [0, _W_, [0, arg, 0]]];
   }
   var _Y_ = [0, [0, Sexplib0_Sexp[5], _V_], _U_];
   function _Z_(param){
    if(param[1] !== Stdlib[4])
     throw caml_maybe_attach_backtrace([0, Assert_failure, ___], 1);
    var arg = param[2];
    return get_flc_error(cst_Match_failure, arg);
   }
   var _$_ = [0, [0, Stdlib[4], _Z_], _Y_];
   function _aa_(param){
    if(param[1] !== Stdlib[6])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ac_], 1);
    var arg = param[2];
    return [1, [0, _ab_, [0, [0, arg], 0]]];
   }
   var _ad_ = [0, [0, Stdlib[6], _aa_], _$_];
   function _ae_(param){
    if(param === Stdlib[8]) return _af_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ag_], 1);
   }
   var _ah_ = [0, [0, Stdlib[8], _ae_], _ad_];
   function _ai_(param){
    if(param[1] !== Stdlib[7])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ak_], 1);
    var arg = param[2];
    return [1, [0, _aj_, [0, [0, arg], 0]]];
   }
   var _al_ = [0, [0, Stdlib[7], _ai_], _ah_];
   function _am_(param){
    if(param === Stdlib[12]) return _an_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ao_], 1);
   }
   var _ap_ = [0, [0, Stdlib[12], _am_], _al_];
   function _aq_(param){
    if(param === Stdlib[3]) return _ar_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _as_], 1);
   }
   var _at_ = [0, [0, Stdlib[3], _aq_], _ap_];
   function _au_(param){
    if(param[1] !== Stdlib[5])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _av_], 1);
    var arg = param[2];
    return get_flc_error(cst_Assert_failure, arg);
   }
   var _aw_ = [0, [0, Stdlib[5], _au_], _at_];
   function _ax_(param){
    var handler = param[2], extension_constructor = param[1];
    return add(_az_, _ay_, extension_constructor, handler);
   }
   caml_call2(Stdlib_ListLabels[18], _ax_, _aw_);
   var
    _aA_ = 0,
    _aD_ =
      [0,
       [0,
        Of_sexp_error,
        function(param){
         if(param[1] !== Of_sexp_error)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aC_], 1);
         var sexp = param[3], exc = param[2];
         return [1, [0, _aB_, [0, sexp_of_exn(exc), [0, sexp, 0]]]];
        }],
       _aA_];
   function _aE_(param){
    var handler = param[2], extension_constructor = param[1];
    return add(_aG_, _aF_, extension_constructor, handler);
   }
   caml_call2(Stdlib_ListLabels[18], _aE_, _aD_);
   var
    Sexplib0_Sexp_conv =
      [0,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       [0, add, For_unit_tests_only]];
   runtime.caml_register_global
    (117, Sexplib0_Sexp_conv, "Sexplib0__Sexp_conv");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_error
//# unitInfo: Requires: Sexplib0__Sexp_conv, Stdlib__ListLabels, Stdlib__Printf, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = " ",
    cst_has_incorrect_number_of_ar = " has incorrect number of arguments",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    _h_ =
      [0,
       [11,
        "polymorphic variant tag ",
        [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]],
       "polymorphic variant tag %S has incorrect number of arguments"],
    _g_ =
      [0,
       [11, "the following record elements were undefined: ", [2, 0, 0]],
       "the following record elements were undefined: %s"],
    cst_extra_fields = "extra fields",
    cst_duplicate_fields = "duplicate fields",
    _f_ = [0, [2, 0, [11, ": ", [2, 0, 0]]], "%s: %s"],
    _e_ =
      [0,
       [11, "sum tag ", [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]],
       "sum tag %S has incorrect number of arguments"],
    _d_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: incorrect label for element ",
         [2, 0, [11, " at position ", [4, 3, 0, 0, 0]]]]],
       "%s_of_sexp: incorrect label for element %s at position %i"],
    _c_ =
      [0,
       [2,
        0,
        [11, "_of_sexp: expected a pair beginning with label ", [2, 0, 0]]],
       "%s_of_sexp: expected a pair beginning with label %s"],
    _b_ =
      [0,
       [11, "tuple of size ", [4, 0, 0, 0, [11, " expected", 0]]],
       "tuple of size %d expected"],
    _a_ = [0, [2, 0, [11, "_of_sexp: ", [2, 0, 0]]], "%s_of_sexp: %s"],
    cst_this_constructor_does_not_ =
      "this constructor does not take arguments",
    cst_this_constructor_requires_ = "this constructor requires arguments",
    cst_expected_a_variant_type_sa =
      "expected a variant type, saw a nested list",
    cst_expected_a_variant_type_sa$0 =
      "expected a variant type, saw an empty list",
    cst_unexpected_variant_constru = "unexpected variant constructor",
    cst_record_conversion_a_sexp_b =
      "record conversion: a [sexp.bool] field was given a payload.",
    cst_record_conversion_only_pai =
      "record conversion: only pairs expected, their first element must be an atom",
    cst_list_instead_of_atom_for_r =
      "list instead of atom for record expected",
    cst_cannot_convert_values_of_t =
      "cannot convert values of types resulting from polymorphic record fields",
    cst_Sexplib0_Sexp_conv_error_N =
      "Sexplib0__Sexp_conv_error.No_variant_match",
    cst_no_matching_variant_found = "no matching variant found",
    cst_polymorphic_variant_does_n =
      "polymorphic variant does not take arguments",
    cst_polymorphic_variant_tag_ta =
      "polymorphic variant tag takes an argument",
    cst_a_nested_list_is_an_invali =
      "a nested list is an invalid polymorphic variant",
    cst_the_empty_list_is_an_inval =
      "the empty list is an invalid polymorphic variant",
    cst_trying_to_convert_an_empty = "trying to convert an empty type";
   function error(loc, sexp, msg){
    var _O_ = caml_call3(Stdlib_Printf[4], _a_, loc, msg);
    return caml_call2(Sexplib0_Sexp_conv[27], _O_, sexp);
   }
   function simple_error(msg, loc, sexp){return error(loc, sexp, msg);}
   function tuple_of_size_n_expected(loc, n, sexp){
    return error(loc, sexp, caml_call2(Stdlib_Printf[4], _b_, n));
   }
   function tuple_pair_expected(loc, name, sexp){
    var msg = caml_call3(Stdlib_Printf[4], _c_, loc, name);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function tuple_incorrect_label(loc, name, pos, sexp){
    var msg = caml_call4(Stdlib_Printf[4], _d_, loc, name, pos);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function stag_no_args(_M_, _N_){
    return simple_error(cst_this_constructor_does_not_, _M_, _N_);
   }
   function stag_incorrect_n_args(loc, tag, sexp){
    return error(loc, sexp, caml_call2(Stdlib_Printf[4], _e_, tag));
   }
   function stag_takes_args(_K_, _L_){
    return simple_error(cst_this_constructor_requires_, _K_, _L_);
   }
   function nested_list_invalid_sum(_I_, _J_){
    return simple_error(cst_expected_a_variant_type_sa, _I_, _J_);
   }
   function empty_list_invalid_sum(_G_, _H_){
    return simple_error(cst_expected_a_variant_type_sa$0, _G_, _H_);
   }
   function unexpected_stag(_E_, _F_){
    return simple_error(cst_unexpected_variant_constru, _E_, _F_);
   }
   function record_sexp_bool_with_payload(_C_, _D_){
    return simple_error(cst_record_conversion_a_sexp_b, _C_, _D_);
   }
   function record_only_pairs_expected(_A_, _B_){
    return simple_error(cst_record_conversion_only_pai, _A_, _B_);
   }
   function record_invalid_fields(what, loc, fld_names, sexp){
    var fld_names_str = caml_call2(Stdlib_StringLabels[7], cst, fld_names);
    return error
            (loc,
             sexp,
             caml_call3(Stdlib_Printf[4], _f_, what, fld_names_str));
   }
   function record_duplicate_fields(loc, fld_names, sexp){
    return record_invalid_fields(cst_duplicate_fields, loc, fld_names, sexp);
   }
   function record_extra_fields(loc, fld_names, sexp){
    return record_invalid_fields(cst_extra_fields, loc, fld_names, sexp);
   }
   function record_get_undefined_loop(fields, param){
    var fields$0 = fields, param$0 = param;
    for(;;){
     if(! param$0){
      var _z_ = caml_call1(Stdlib_ListLabels[10], fields$0);
      return caml_call2(Stdlib_StringLabels[7], cst$0, _z_);
     }
     var _y_ = param$0[1];
     if(_y_[1])
      var
       rest = param$0[2],
       field = _y_[2],
       fields$1 = [0, field, fields$0],
       fields$0 = fields$1,
       param$0 = rest;
     else
      var rest$0 = param$0[2], param$0 = rest$0;
    }
   }
   function record_undefined_elements(loc, sexp, lst){
    var
     undefined$0 = record_get_undefined_loop(0, lst),
     msg = caml_call2(Stdlib_Printf[4], _g_, undefined$0);
    return error(loc, sexp, msg);
   }
   function record_list_instead_atom(_w_, _x_){
    return simple_error(cst_list_instead_of_atom_for_r, _w_, _x_);
   }
   function record_poly_field_value(_u_, _v_){
    return simple_error(cst_cannot_convert_values_of_t, _u_, _v_);
   }
   var
    No_variant_match =
      [248, cst_Sexplib0_Sexp_conv_error_N, runtime.caml_fresh_oo_id(0)];
   function no_variant_match(param){
    throw caml_maybe_attach_backtrace(No_variant_match, 1);
   }
   function no_matching_variant_found(_s_, _t_){
    return simple_error(cst_no_matching_variant_found, _s_, _t_);
   }
   function ptag_no_args(_q_, _r_){
    return simple_error(cst_polymorphic_variant_does_n, _q_, _r_);
   }
   function ptag_incorrect_n_args(loc, cnstr, sexp){
    return error(loc, sexp, caml_call2(Stdlib_Printf[4], _h_, cnstr));
   }
   function ptag_takes_args(_o_, _p_){
    return simple_error(cst_polymorphic_variant_tag_ta, _o_, _p_);
   }
   function nested_list_invalid_poly_var(_m_, _n_){
    return simple_error(cst_a_nested_list_is_an_invali, _m_, _n_);
   }
   function empty_list_invalid_poly_var(_k_, _l_){
    return simple_error(cst_the_empty_list_is_an_inval, _k_, _l_);
   }
   function empty_type(_i_, _j_){
    return simple_error(cst_trying_to_convert_an_empty, _i_, _j_);
   }
   var
    Sexplib0_Sexp_conv_error =
      [0,
       Of_sexp_error,
       error,
       simple_error,
       tuple_of_size_n_expected,
       tuple_pair_expected,
       tuple_incorrect_label,
       stag_no_args,
       stag_incorrect_n_args,
       stag_takes_args,
       nested_list_invalid_sum,
       empty_list_invalid_sum,
       unexpected_stag,
       record_sexp_bool_with_payload,
       record_only_pairs_expected,
       record_invalid_fields,
       record_duplicate_fields,
       record_extra_fields,
       record_get_undefined_loop,
       record_undefined_elements,
       record_list_instead_atom,
       record_poly_field_value,
       No_variant_match,
       no_variant_match,
       no_matching_variant_found,
       ptag_no_args,
       ptag_incorrect_n_args,
       ptag_takes_args,
       nested_list_invalid_poly_var,
       empty_list_invalid_poly_var,
       empty_type];
   runtime.caml_register_global
    (32, Sexplib0_Sexp_conv_error, "Sexplib0__Sexp_conv_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_labeled_tuple
//# unitInfo: Requires: Sexplib0__Sexp_conv_error, Stdlib__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error;
   function labeled_tuple_of_sexp(caller, fields$2, create, original_sexp){
    var t = fields$2, acc = 0;
    for(;;){
     if(! t) break;
     var acc$0 = acc + 1 | 0, t$0 = t[3], t = t$0, acc = acc$0;
    }
    if(0 === original_sexp[0])
     return caml_call3
             (Sexplib0_Sexp_conv_error[4], caller, acc, original_sexp);
    var list$2 = original_sexp[1];
    a:
    {
     var pos$1 = 0;
     if(fields$2){
      var fields = fields$2[3], conv = fields$2[2], name = fields$2[1];
      if(list$2){
       var list = list$2[2], sexp = list$2[1];
       if(1 === sexp[0]){
        var _a_ = sexp[1];
        if(_a_){
         var _b_ = _a_[1];
         if(0 === _b_[0]){
          var _c_ = _a_[2];
          if(_c_ && ! _c_[2]){
           var sexp$0 = _c_[1], atom = _b_[1];
           if(! caml_call2(Stdlib_String[9], atom, name)){
            var
             _g_ =
               caml_call4
                (Sexplib0_Sexp_conv_error[6],
                 caller,
                 name,
                 pos$1,
                 original_sexp);
            break a;
           }
           var
            block = [0, caml_call1(conv, sexp$0), 24029],
            dst = block,
            offset = 1,
            fields$0 = fields,
            pos = 1,
            list$0 = list;
           for(;;){
            b:
            if(fields$0){
             var
              fields$1 = fields$0[3],
              conv$0 = fields$0[2],
              name$0 = fields$0[1];
             if(list$0){
              var list$1 = list$0[2], sexp$1 = list$0[1];
              if(1 === sexp$1[0]){
               var _d_ = sexp$1[1];
               if(_d_){
                var _e_ = _d_[1];
                if(0 === _e_[0]){
                 var _f_ = _d_[2];
                 if(_f_ && ! _f_[2]){
                  var sexp$2 = _f_[1], atom$0 = _e_[1];
                  if(caml_call2(Stdlib_String[9], atom$0, name$0)){
                   var dst$0 = [0, caml_call1(conv$0, sexp$2), 24029];
                   dst[1 + offset] = dst$0;
                   var
                    pos$0 = pos + 1 | 0,
                    dst = dst$0,
                    offset = 1,
                    fields$0 = fields$1,
                    pos = pos$0,
                    list$0 = list$1;
                   continue;
                  }
                  dst[1 + offset] =
                   caml_call4
                    (Sexplib0_Sexp_conv_error[6],
                     caller,
                     name$0,
                     pos,
                     original_sexp);
                  break b;
                 }
                }
               }
              }
              dst[1 + offset] =
               caml_call3(Sexplib0_Sexp_conv_error[5], caller, name$0, sexp$1);
             }
             else
              dst[1 + offset] =
               caml_call3
                (Sexplib0_Sexp_conv_error[4], caller, acc, original_sexp);
            }
            else if(list$0)
             dst[1 + offset] =
              caml_call3
               (Sexplib0_Sexp_conv_error[4], caller, acc, original_sexp);
            else
             dst[1 + offset] = 0;
            var _g_ = block;
            break a;
           }
          }
         }
        }
       }
       var _g_ = caml_call3(Sexplib0_Sexp_conv_error[5], caller, name, sexp);
      }
      else
       var
        _g_ =
          caml_call3(Sexplib0_Sexp_conv_error[4], caller, acc, original_sexp);
     }
     else
      var
       _g_ =
         list$2
          ? caml_call3
            (Sexplib0_Sexp_conv_error[4], caller, acc, original_sexp)
          : 0;
    }
    return caml_call1(create, _g_);
   }
   var Sexplib0_Sexp_conv_labeled_tup = [0, [0], labeled_tuple_of_sexp];
   runtime.caml_register_global
    (2, Sexplib0_Sexp_conv_labeled_tup, "Sexplib0__Sexp_conv_labeled_tuple");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_record
//# unitInfo: Requires: Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Stdlib, Stdlib__ArrayLabels, Stdlib__ListLabels, Stdlib__Option, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    absent = [0, ""],
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib = global_data.Stdlib,
    Kind = [0],
    _a_ = [1, 0],
    _b_ = [3, 0],
    cst_Sexplib0_Sexp_conv_record_ = "Sexplib0__Sexp_conv_record.Malformed";
   function combine(a, b){
    a:
    if(typeof a !== "number"){
     b:
     {
      c:
      {
       d:
       {
        e:
        switch(a[0]){
          case 0:
           var a$0 = a[1];
           if(typeof b !== "number")
            switch(b[0]){
              case 3: break;
              case 0:
               var b$0 = b[1]; return [0, caml_call2(Stdlib[37], a$0, b$0)];
              case 1:
               break d;
              default: var t$0 = a; break e;
            }
           break b;
          case 1:
           var a$1 = a[1];
           if(typeof b !== "number")
            switch(b[0]){
              case 3: break;
              case 1:
               var b$1 = b[1]; return [1, caml_call2(Stdlib[37], a$1, b$1)];
              default: var t = a; break c;
            }
           break b;
          case 2:
           var a$2 = a[1];
           if(typeof b !== "number")
            switch(b[0]){
              case 3: break;
              case 0:
               var t$0 = b; break e;
              case 1:
               break d;
              default:
               var b$2 = b[1]; return [2, caml_call2(Stdlib[37], a$2, b$2)];
            }
           break b;
          default: break a;
        }
        return t$0;
       }
       var t = b;
      }
      return t;
     }
     return b;
    }
    return a;
   }
   var
    Malformed =
      [248, cst_Sexplib0_Sexp_conv_record_, runtime.caml_fresh_oo_id(0)];
   function parse_value_malformed(malformed, fields, state, pos){
    try{
     parse_values(fields[4], state, pos + 1 | 0);
     var malformed$0 = malformed;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var other = exn[2], malformed$0 = combine(malformed, other);
    }
    throw caml_maybe_attach_backtrace([0, Malformed, malformed$0], 1);
   }
   function parse_values(fields, state, pos){
    if(! fields) return 0;
    var
     rest = fields[4],
     conv = fields[3],
     kind = fields[2],
     name = fields[1],
     sexp = state[1 + pos];
    a:
    {
     b:
     {
      if(typeof kind !== "number"){
       var default$0 = kind[1];
       if(0 === sexp[0])
        var _F_ = caml_call1(default$0, 0);
       else{
        var _G_ = sexp[1];
        if(! _G_) break b;
        var _H_ = _G_[2];
        if(! _H_) break b;
        if(_H_[2]) break b;
        var sexp$5 = _H_[1], _F_ = caml_call1(conv, sexp$5);
       }
       var value = _F_;
       break a;
      }
      switch(kind){
        case 0:
         if(0 === sexp[0]){var value = caml_call1(conv, _a_); break a;}
         var _r_ = sexp[1];
         if(_r_){
          var _s_ = _r_[2];
          if(_s_ && ! _s_[2]){
           var sexp$0 = _s_[1], value = caml_call1(conv, sexp$0);
           break a;
          }
         }
         break;
        case 1:
         if(0 === sexp[0]){
          var
           value =
             parse_value_malformed([2, [0, name, 0]], fields, state, pos);
          break a;
         }
         var _v_ = sexp[1];
         if(_v_){
          var _w_ = _v_[2];
          if(_w_ && ! _w_[2]){
           var sexp$1 = _w_[1], value = caml_call1(conv, sexp$1);
           break a;
          }
         }
         break;
        case 2:
         if(0 === sexp[0]){var value = [0]; break a;}
         var _x_ = sexp[1];
         if(_x_){
          var _y_ = _x_[2];
          if(_y_ && ! _y_[2]){
           var
            sexp$2 = _y_[1],
            value = caml_call2(Sexplib0_Sexp_conv[45], conv, sexp$2);
           break a;
          }
         }
         break;
        case 3:
         if(0 === sexp[0]){var value = 0; break a;}
         var _z_ = sexp[1];
         c:
         {
          if(_z_ && ! _z_[2]){var _A_ = 1; break c;}
          var _A_ = parse_value_malformed(0, fields, state, pos);
         }
         var value = _A_;
         break a;
        case 4:
         if(0 === sexp[0]){var value = 0; break a;}
         var _B_ = sexp[1];
         if(_B_){
          var _C_ = _B_[2];
          if(_C_ && ! _C_[2]){
           var
            sexp$3 = _C_[1],
            value = caml_call2(Sexplib0_Sexp_conv[44], conv, sexp$3);
           break a;
          }
         }
         break;
        default:
         if(0 === sexp[0]){var value = 0; break a;}
         var _D_ = sexp[1];
         if(_D_){
          var _E_ = _D_[2];
          if(_E_ && ! _E_[2]){
           var sexp$4 = _E_[1], value = [0, caml_call1(conv, sexp$4)];
           break a;
          }
         }
      }
     }
     var _t_ = sexp[1];
     b:
     {
      if(_t_ && _t_[2]){
       var _u_ = parse_value_malformed([3, [0, sexp]], fields, state, pos);
       break b;
      }
      var _u_ = parse_value_malformed(_b_, fields, state, pos);
     }
     var value = _u_;
    }
    return [0, value, parse_values(rest, state, pos + 1 | 0)];
   }
   function parse_spine_malformed
   (malformed, index, extra, seen, state, len, sexps){
    try{
     parse_spine_slow(index, extra, seen, state, len, sexps);
     var malformed$0 = malformed;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var other = exn[2], malformed$0 = combine(malformed, other);
    }
    throw caml_maybe_attach_backtrace([0, Malformed, malformed$0], 1);
   }
   function parse_spine_slow(index, extra, seen, state, len, sexps){
    var sexps$0 = sexps;
    for(;;){
     if(! sexps$0) return;
     var field = sexps$0[1];
     if(1 === field[0]){
      var _m_ = field[1];
      if(_m_){
       var match = _m_[1];
       if(0 === match[0]){
        var
         sexps$2 = sexps$0[2],
         name = match[1],
         i = caml_call1(index, name),
         _n_ = seen <= i ? 1 : 0,
         _o_ = _n_ ? i < len ? 1 : 0 : _n_;
        if(_o_){
         var pos = i - seen | 0;
         if(0 !== state[1 + pos][0])
          return parse_spine_malformed
                  ([1, [0, name, 0]], index, extra, seen, state, len, sexps$2);
         state[1 + pos] = field;
         var sexps$0 = sexps$2;
         continue;
        }
        var _p_ = 0 <= i ? 1 : 0, _q_ = _p_ ? i < seen ? 1 : 0 : _p_;
        if(_q_)
         return parse_spine_malformed
                 ([1, [0, name, 0]], index, extra, seen, state, len, sexps$2);
        if(! extra)
         return parse_spine_malformed
                 ([0, [0, name, 0]], index, extra, seen, state, len, sexps$2);
        var sexps$0 = sexps$2;
        continue;
       }
      }
     }
     var sexps$1 = sexps$0[2];
     return parse_spine_malformed
             ([3, [0, field]], index, extra, seen, state, len, sexps$1);
    }
   }
   function parse_record_slow(fields, index, extra, seen, sexps){
    var t = fields, unseen = 0;
    for(;;){
     if(! t){
      var
       state = runtime.caml_make_vect(unseen, absent),
       len = seen + unseen | 0;
      parse_spine_slow(index, extra, seen, state, len, sexps);
      return parse_values(fields, state, 0);
     }
     var rest = t[4], acc = unseen + 1 | 0, t = rest, unseen = acc;
    }
   }
   function parse_spine_fast(fields, index, extra, seen, sexps){
    if(! fields)
     return sexps ? parse_record_slow(fields, index, extra, seen, sexps) : 0;
    var
     rest = fields[4],
     conv = fields[3],
     kind = fields[2],
     name = fields[1];
    if(sexps){
     var _e_ = sexps[1];
     if(0 !== _e_[0]){
      var _f_ = _e_[1];
      if(_f_){
       var match = _f_[1];
       if(0 === match[0]){
        var others = sexps[2], args = _f_[2], atom = match[1];
        if(caml_call2(Stdlib_StringLabels[9], atom, name)){
         if(typeof kind === "number")
          switch(kind){
            case 0:
             if(args && ! args[2]){
              var
               sexp = args[1],
               _g_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, caml_call1(conv, sexp), _g_];
             }
             break;
            case 1:
             if(args && ! args[2]){
              var
               sexp$0 = args[1],
               _h_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, caml_call1(conv, sexp$0), _h_];
             }
             break;
            case 2:
             if(args && ! args[2]){
              var
               sexp$1 = args[1],
               _i_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0,
                      caml_call2(Sexplib0_Sexp_conv[45], conv, sexp$1),
                      _i_];
             }
             break;
            case 3:
             if(! args)
              return [0,
                      1,
                      parse_spine_fast(rest, index, extra, seen + 1 | 0, others)];
             break;
            case 4:
             if(args && ! args[2]){
              var
               sexp$2 = args[1],
               _j_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0,
                      caml_call2(Sexplib0_Sexp_conv[44], conv, sexp$2),
                      _j_];
             }
             break;
            default:
             if(args && ! args[2]){
              var
               sexp$3 = args[1],
               _k_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, [0, caml_call1(conv, sexp$3)], _k_];
             }
          }
         else if(args && ! args[2]){
          var
           sexp$4 = args[1],
           _l_ = parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
          return [0, caml_call1(conv, sexp$4), _l_];
         }
         return parse_record_slow(fields, index, extra, seen, sexps);
        }
       }
      }
     }
    }
    return parse_record_slow(fields, index, extra, seen, sexps);
   }
   function record_of_sexps
   (caller,
    context$0,
    fields,
    index_of_field,
    allow_extra_fields,
    create,
    sexps){
    var
     allow_extra_fields$0 =
       allow_extra_fields || 1 - Sexplib0_Sexp_conv[26][1];
    try{
     var
      value =
        parse_spine_fast
         (fields, index_of_field, allow_extra_fields$0, 0, sexps);
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var malformed = exn[2];
     if(typeof malformed === "number")
      return caml_call2(Sexplib0_Sexp_conv_error[13], caller, context$0);
     switch(malformed[0]){
       case 0:
        var names = malformed[1];
        return caml_call3
                (Sexplib0_Sexp_conv_error[17], caller, names, context$0);
       case 1:
        var names$0 = malformed[1];
        return caml_call3
                (Sexplib0_Sexp_conv_error[16], caller, names$0, context$0);
       case 2:
        var
         names$1 = malformed[1],
         _c_ = function(name){return [0, 1, name];},
         _d_ = caml_call2(Stdlib_ListLabels[20], _c_, names$1);
        return caml_call1
                (caml_call2(Sexplib0_Sexp_conv_error[19], caller, context$0),
                 _d_);
       default:
        var
         maybe_context = malformed[1],
         context = caml_call2(Stdlib_Option[3], maybe_context, context$0);
        return caml_call2(Sexplib0_Sexp_conv_error[14], caller, context);
     }
    }
    return caml_call1(create, value);
   }
   function record_of_sexp
   (caller, fields, index_of_field, allow_extra_fields, create, sexp){
    if(0 === sexp[0])
     return caml_call2(Sexplib0_Sexp_conv_error[20], caller, sexp);
    var sexps = sexp[1];
    return record_of_sexps
            (caller,
             sexp,
             fields,
             index_of_field,
             allow_extra_fields,
             create,
             sexps);
   }
   var
    Sexplib0_Sexp_conv_record =
      [0, Kind, [0], record_of_sexp, record_of_sexps];
   runtime.caml_register_global
    (10, Sexplib0_Sexp_conv_record, "Sexplib0__Sexp_conv_record");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexpable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0_Sexpable = [0];
   runtime.caml_register_global(0, Sexplib0_Sexpable, "Sexplib0__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0 = [0];
   runtime.caml_register_global(0, Sexplib0, "Sexplib0");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzZXhwbGliMC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic2V4cF9vZl90IiwidCIsInRfb2Zfc2V4cCIsImNvbXBhcmUiLCJhJDAiLCJiJDAiLCJhJDEiLCJiJDEiLCJhJDIiLCJiJDIiLCJhIiwiYiIsInlzIiwieSIsInhzIiwieCIsInJlcyIsImVxdWFsIiwiZGVmYXVsdF9pbmRlbnQiLCJtdXN0X2VzY2FwZSIsInN0ciIsImxlbiIsIml4JDEiLCJpeCIsIm5leHQiLCJuZXh0JDAiLCJpeCQwIiwiZXNjYXBlZCIsInMiLCJuIiwiaSQwIiwicyQwIiwiaSIsImMiLCJlc2Nfc3RyIiwiZXN0ciIsImVsZW4iLCJpbmRleF9vZl9uZXdsaW5lIiwic3RhcnQiLCJtYWNoX21heWJlX2VzY19zdHIiLCJwcF9odW1faW5kZW50IiwiaW5kZW50IiwicHBmIiwiaW5kZXgiLCJpbmRleCQwIiwibmV4dF9uZXdsaW5lIiwiZW5kX3BvcyIsImVuZF9wb3MkMCIsIm5leHRfbGluZSIsIm5ld2xpbmVfaW5kZXgiLCJpbmRleCQxIiwiaCIsInQkMCIsImgkMCIsInBwX21hY2hfaW50ZXJuYWwiLCJtYXlfbmVlZF9zcGFjZSIsInN0ciQwIiwibmV3X21heV9uZWVkX3NwYWNlIiwibmV3X21heV9uZWVkX3NwYWNlJDAiLCJtYXlfbmVlZF9zcGFjZSQwIiwibWF5X25lZWRfc3BhY2UkMSIsIm1heV9uZWVkX3NwYWNlJDIiLCJwcF9odW0iLCJzZXhwIiwicHBfbWFjaCIsInNpemVfbG9vcCIsImFjYyIsInYiLCJsc3QiLCJzaXplIiwidG9fYnVmZmVyX2h1bSIsImJ1ZiIsIm9wdCIsInN0aCIsInRvX2J1ZmZlcl9tYWNoIiwibG9vcCIsInRvX2J1ZmZlcl9nZW4iLCJhZGRfY2hhciIsImFkZF9zdHJpbmciLCJidWZmZXIiLCJ0b19zdHJpbmdfaHVtIiwidG9fc3RyaW5nX21hY2giLCJvZl9mbG9hdF9zdHlsZSIsIm9mX2ludF9zdHlsZSIsIm1lc3NhZ2UiLCJuYW1lIiwiZmllbGRzIiwiY29udl9maWVsZHMiLCJyZXN0IiwiZnNleHAiLCJmbmFtZSIsImRvY19jb21tZW50X3RhZyIsInR5cGVfbmFtZV90YWciLCJhc3NvY190YWciLCJhc3NvY19rZXlfdGFnIiwiYXNzb2NfdmFsdWVfdGFnIiwiY29tcGxldGlvbl9zdWdnZXN0ZWQiLCJjb2VyY2UiLCJ0YWciLCJwYXJhbSIsImtleSIsInZhbHVlIiwidW5pdF9zZXhwX2dyYW1tYXIiLCJzZXhwX3Rfc2V4cF9ncmFtbWFyIiwiZW1wdHlfc2V4cF9ncmFtbWFyIiwic2V4cF9ncmFtbWFyX3dpdGhfdGFncyIsImdyYW1tYXIiLCJ0YWdzIiwic2V4cF9ncmFtbWFyX3dpdGhfdGFnX2xpc3QiLCJib29sX3NleHBfZ3JhbW1hciIsInN0cmluZ19zZXhwX2dyYW1tYXIiLCJieXRlc19zZXhwX2dyYW1tYXIiLCJjaGFyX3NleHBfZ3JhbW1hciIsImludF9zZXhwX2dyYW1tYXIiLCJmbG9hdF9zZXhwX2dyYW1tYXIiLCJpbnQzMl9zZXhwX2dyYW1tYXIiLCJpbnQ2NF9zZXhwX2dyYW1tYXIiLCJuYXRpdmVpbnRfc2V4cF9ncmFtbWFyIiwicmVmX3NleHBfZ3JhbW1hciIsImxhenlfdF9zZXhwX2dyYW1tYXIiLCJvcHRpb25fc2V4cF9ncmFtbWFyIiwibGlzdF9zZXhwX2dyYW1tYXIiLCJhcnJheV9zZXhwX2dyYW1tYXIiLCJkZWZhdWx0X3N0cmluZ19vZl9mbG9hdCIsInJlYWRfb2xkX29wdGlvbl9mb3JtYXQiLCJ3cml0ZV9vbGRfb3B0aW9uX2Zvcm1hdCIsImxpc3RfbWFwIiwiZiIsImwiLCJzZXhwX29mX3VuaXQiLCJzZXhwX29mX2Jvb2wiLCJzZXhwX29mX3N0cmluZyIsInNleHBfb2ZfYnl0ZXMiLCJieXRlcyIsInNleHBfb2ZfY2hhciIsInNleHBfb2ZfaW50Iiwic2V4cF9vZl9mbG9hdCIsInNleHBfb2ZfaW50MzIiLCJzZXhwX29mX2ludDY0Iiwic2V4cF9vZl9uYXRpdmVpbnQiLCJzZXhwX29mX3JlZiIsInNleHBfb2ZfYSIsInJmIiwic2V4cF9vZl9sYXp5X3QiLCJsdiIsInNleHBfb2Zfb3B0aW9uIiwic2V4cF9vZl9wYWlyIiwic2V4cF9vZl9iIiwic2V4cF9vZl90cmlwbGUiLCJzZXhwX29mX2MiLCJzZXhwX29mX2xpc3QiLCJzZXhwX29mX2FycmF5IiwiYXIiLCJsc3RfcmVmIiwic2V4cF9vZl9oYXNodGJsIiwic2V4cF9vZl9rZXkiLCJzZXhwX29mX3ZhbCIsImh0YmwiLCJjb2xsIiwiayIsInNleHBfb2Zfb3BhcXVlIiwic2V4cF9vZl9mdW4iLCJoYXNoIiwidGhlX2V4bl90YWJsZSIsImFkZCIsImV4dGVuc2lvbl9jb25zdHJ1Y3RvciIsInNleHBfb2ZfZXhuIiwicHJpbnRleGMiLCJmaW5kX2F1dG8iLCJmb3JfcHJpbnRleGMiLCJleG4iLCJzZXhwX29mX2V4bl9vcHQiLCJleG5fdG9fc3RyaW5nIiwiZSIsInByaW50ZXhjX3ByZWZlcl9zZXhwIiwicmVjb3JkX2NoZWNrX2V4dHJhX2ZpZWxkcyIsIm9mX3NleHBfZXJyb3JfZXhuIiwiZXhjIiwib2Zfc2V4cF9lcnJvciIsIndoYXQiLCJ1bml0X29mX3NleHAiLCJib29sX29mX3NleHAiLCJzdHJpbmdfb2Zfc2V4cCIsImJ5dGVzX29mX3NleHAiLCJjaGFyX29mX3NleHAiLCJpbnRfb2Zfc2V4cCIsImV4YyQwIiwiZmxvYXRfb2Zfc2V4cCIsImludDMyX29mX3NleHAiLCJpbnQ2NF9vZl9zZXhwIiwibmF0aXZlaW50X29mX3NleHAiLCJyZWZfb2Zfc2V4cCIsImFfb2Zfc2V4cCIsImxhenlfdF9vZl9zZXhwIiwib3B0aW9uX29mX3NleHAiLCJlbCQwIiwiZWwiLCJwYWlyX29mX3NleHAiLCJiX29mX3NleHAiLCJiX3NleHAiLCJhX3NleHAiLCJ0cmlwbGVfb2Zfc2V4cCIsImNfb2Zfc2V4cCIsImNfc2V4cCIsImxpc3Rfb2Zfc2V4cCIsImFycmF5X29mX3NleHAiLCJoYXNodGJsX29mX3NleHAiLCJrZXlfb2Zfc2V4cCIsInZhbF9vZl9zZXhwIiwiYWN0Iiwidl9zZXhwIiwia19zZXhwIiwib3BhcXVlX29mX3NleHAiLCJmdW5fb2Zfc2V4cCIsImdldF9mbGNfZXJyb3IiLCJjaHIiLCJsaW5lIiwiZmlsZSIsImFyZyIsImhhbmRsZXIiLCJlcnJvciIsImxvYyIsIm1zZyIsInNpbXBsZV9lcnJvciIsInR1cGxlX29mX3NpemVfbl9leHBlY3RlZCIsInR1cGxlX3BhaXJfZXhwZWN0ZWQiLCJ0dXBsZV9pbmNvcnJlY3RfbGFiZWwiLCJwb3MiLCJzdGFnX25vX2FyZ3MiLCJzdGFnX2luY29ycmVjdF9uX2FyZ3MiLCJzdGFnX3Rha2VzX2FyZ3MiLCJuZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSIsImVtcHR5X2xpc3RfaW52YWxpZF9zdW0iLCJ1bmV4cGVjdGVkX3N0YWciLCJyZWNvcmRfc2V4cF9ib29sX3dpdGhfcGF5bG9hZCIsInJlY29yZF9vbmx5X3BhaXJzX2V4cGVjdGVkIiwicmVjb3JkX2ludmFsaWRfZmllbGRzIiwiZmxkX25hbWVzIiwiZmxkX25hbWVzX3N0ciIsInJlY29yZF9kdXBsaWNhdGVfZmllbGRzIiwicmVjb3JkX2V4dHJhX2ZpZWxkcyIsInJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AiLCJmaWVsZHMkMCIsImZpZWxkIiwicmVzdCQwIiwicmVjb3JkX3VuZGVmaW5lZF9lbGVtZW50cyIsInVuZGVmaW5lZCQwIiwicmVjb3JkX2xpc3RfaW5zdGVhZF9hdG9tIiwicmVjb3JkX3BvbHlfZmllbGRfdmFsdWUiLCJub192YXJpYW50X21hdGNoIiwibm9fbWF0Y2hpbmdfdmFyaWFudF9mb3VuZCIsInB0YWdfbm9fYXJncyIsInB0YWdfaW5jb3JyZWN0X25fYXJncyIsImNuc3RyIiwicHRhZ190YWtlc19hcmdzIiwibmVzdGVkX2xpc3RfaW52YWxpZF9wb2x5X3ZhciIsImVtcHR5X2xpc3RfaW52YWxpZF9wb2x5X3ZhciIsImVtcHR5X3R5cGUiLCJsYWJlbGVkX3R1cGxlX29mX3NleHAiLCJjYWxsZXIiLCJmaWVsZHMkMiIsImNyZWF0ZSIsIm9yaWdpbmFsX3NleHAiLCJhY2MkMCIsImxpc3QkMiIsInBvcyQxIiwiY29udiIsImxpc3QiLCJzZXhwJDAiLCJhdG9tIiwiYWJzZW50IiwiY29tYmluZSIsInBhcnNlX3ZhbHVlX21hbGZvcm1lZCIsIm1hbGZvcm1lZCIsInN0YXRlIiwicGFyc2VfdmFsdWVzIiwibWFsZm9ybWVkJDAiLCJvdGhlciIsImtpbmQiLCJkZWZhdWx0JDAiLCJzZXhwJDUiLCJzZXhwJDEiLCJzZXhwJDIiLCJzZXhwJDMiLCJzZXhwJDQiLCJwYXJzZV9zcGluZV9tYWxmb3JtZWQiLCJleHRyYSIsInNlZW4iLCJzZXhwcyIsInBhcnNlX3NwaW5lX3Nsb3ciLCJzZXhwcyQwIiwic2V4cHMkMiIsInNleHBzJDEiLCJwYXJzZV9yZWNvcmRfc2xvdyIsInVuc2VlbiIsInBhcnNlX3NwaW5lX2Zhc3QiLCJvdGhlcnMiLCJhcmdzIiwicmVjb3JkX29mX3NleHBzIiwiY29udGV4dCQwIiwiaW5kZXhfb2ZfZmllbGQiLCJhbGxvd19leHRyYV9maWVsZHMiLCJhbGxvd19leHRyYV9maWVsZHMkMCIsIm5hbWVzIiwibmFtZXMkMCIsIm5hbWVzJDEiLCJtYXliZV9jb250ZXh0IiwiY29udGV4dCIsInJlY29yZF9vZl9zZXhwIl0sInNvdXJjZXMiOlsiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL3NleHBsaWIwL3NleHBsaWIwX18ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvc2V4cGxpYjAvc2V4cC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9zZXhwbGliMC9zZXhwX2dyYW1tYXIubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvc2V4cGxpYjAvc2V4cF9jb252X2dyYW1tYXIubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvc2V4cGxpYjAvc2V4cF9jb252Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL3NleHBsaWIwL3NleHBfY29udl9lcnJvci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9zZXhwbGliMC9zZXhwX2NvbnZfbGFiZWxlZF90dXBsZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9zZXhwbGliMC9zZXhwX2NvbnZfcmVjb3JkLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0dBMEJvQjs7SUFBQTs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNYaEJBLFVBQVVDLEdBQUksT0FBSkEsRUFBSztZQUNmQyxVQUFVRCxHQUFJLE9BQUpBLEVBQUs7WUFXZkUsUUFBUUMsS0FBRUM7SUFDWixHQURVRCxRQUFFQyxLQUVQO2FBRktEO1NBS0RFLE1BTENGO2NBQUVDLFFBTUs7U0FEQUUsTUFMTEY7S0FLVSxPQUFBLG9DQUFiQyxLQUFRQzs7UUFHUkMsTUFSQ0o7YUFBRUMsUUFPSztRQWhCSUksTUFTVEosUUFUT0ssSUFpQlZGLEtBakJZRyxJQUFBRjtJQUNyQjtVQURtQkMsVUFBRUM7VUFBQUEsR0FJVjtLQUVDLElBTlNDLEtBQUFELE1BS1ZFLElBTFVGLE1BQUZHLEtBQUFKLE1BS2pCSyxJQUxpQkwsTUFNYk0sTUFHSmIsUUFKQVksR0FBU0Y7S0FFVCxTQURJRyxLQUNhLE9BRGJBO1NBTmFOLElBQUFJLElBQUVILElBQUFDOztHQWlCa0I7WUFHakNLLE1BQU1QLEdBQUVDO0lBQ2QsVUFEWUQsTUFBRUM7Ozs7Y0FBRkQ7VUFJTE4sTUFKS007ZUFBRUM7V0FJQ04sTUFKRE07T0FJTSxPQUFBLG1DQUFiUCxLQUFRQzs7OztVQUVSQyxNQU5LSTtlQUFFQztXQU1DSixNQU5ESTtPQU1NLE9BQUEsa0NBTmRNLE9BTUNYLEtBQVFDOzs7Ozs7R0FBNkI7R0FHOUM7SUFBQTtJQUNBO0lBS01XO1lBSUFDLFlBSVdDO0lBSGIsSUFBSUMsNEJBR1NELGtCQUhUQzs7SUFtQkosSUFo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UTZDLFNBeU1STDs7UUF2TUc7U0FEUU0sVUFMRmhDO3dCQU1pQjVMLE1BQVEsY0FBUkEsTUFBa0I7U0FBekMsTUFBQSx1Q0FEUTROO1FBQ1IsT0FBQTtpQkFDRyx5Q0FxTU45QyxRQUNBd0M7OztRQXBNaUI7U0FETE8sZ0JBUkhqQztTQVNGa0MsVUFBVSw2QkFETEQsZUFxTVpQO1FBbk1HLE9BQUEseUNBa01IeEMsUUFuTU9nRDs7O0lBaU5HLE9BQUEsV0FUVjlDLFFBU0NoSztHQUMyRTtZQUczRStNO0lBQWdCakQsUUFBUTdLLFFBQVFzTixnQkFBZ0JDLG9CQUFvQnhDLFFBQU90TTtJQUM3RSxTQUQ2RUE7S0FFdEQsT0FBQSx5Q0FGTG9NLFFBQTJEcE07UUFHdEVpTyxRQUhzRWpPO0lBSTNFLE9BdkJBMk87YUFtQmdCdkM7YUFBMkRwTTthQUFuRHVCO2FBQVFzTjthQUFnQkM7YUFBb0J4QzthQUcvRDJCO0dBUUU7OztxQkFYUG9CLGdCQW5CQVY7Ozs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGJ5IGR1bmUgKilcblxuKCoqIEBjYW5vbmljYWwgU2V4cGxpYjAuU2V4cCAqKVxubW9kdWxlIFNleHAgPSBTZXhwbGliMF9fU2V4cFxuXG4oKiogQGNhbm9uaWNhbCBTZXhwbGliMC5TZXhwX2NvbnYgKilcbm1vZHVsZSBTZXhwX2NvbnYgPSBTZXhwbGliMF9fU2V4cF9jb252XG5cbigqKiBAY2Fub25pY2FsIFNleHBsaWIwLlNleHBfY29udl9lcnJvciAqKVxubW9kdWxlIFNleHBfY29udl9lcnJvciA9IFNleHBsaWIwX19TZXhwX2NvbnZfZXJyb3JcblxuKCoqIEBjYW5vbmljYWwgU2V4cGxpYjAuU2V4cF9jb252X2dyYW1tYXIgKilcbm1vZHVsZSBTZXhwX2NvbnZfZ3JhbW1hciA9IFNleHBsaWIwX19TZXhwX2NvbnZfZ3JhbW1hclxuXG4oKiogQGNhbm9uaWNhbCBTZXhwbGliMC5TZXhwX2NvbnZfbGFiZWxlZF90dXBsZSAqKVxubW9kdWxlIFNleHBfY29udl9sYWJlbGVkX3R1cGxlID0gU2V4cGxpYjBfX1NleHBfY29udl9sYWJlbGVkX3R1cGxlXG5cbigqKiBAY2Fub25pY2FsIFNleHBsaWIwLlNleHBfY29udl9yZWNvcmQgKilcbm1vZHVsZSBTZXhwX2NvbnZfcmVjb3JkID0gU2V4cGxpYjBfX1NleHBfY29udl9yZWNvcmRcblxuKCoqIEBjYW5vbmljYWwgU2V4cGxpYjAuU2V4cF9ncmFtbWFyICopXG5tb2R1bGUgU2V4cF9ncmFtbWFyID0gU2V4cGxpYjBfX1NleHBfZ3JhbW1hclxuXG4oKiogQGNhbm9uaWNhbCBTZXhwbGliMC5TZXhwYWJsZSAqKVxubW9kdWxlIFNleHBhYmxlID0gU2V4cGxpYjBfX1NleHBhYmxlXG5cbm1vZHVsZSBTZXhwbGliMF9fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCJbQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5cbigqIGJsaXRfc3RyaW5nIGRvZXNuJ3QgZXhpc3QgaW4gW1N0ZExhYmVscy5CeXRlc10uLi4gICopXG5sZXQgYnl0ZXNfYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICBCeXRlcy5ibGl0X3N0cmluZyBzcmMgc3JjX3BvcyBkc3QgZHN0X3BvcyBsZW5cbjs7XG5cbm9wZW4gU3RkTGFiZWxzXG5vcGVuIEZvcm1hdFxuXG4oKiogVHlwZSBvZiBTLWV4cHJlc3Npb25zICopXG50eXBlIHQgPVxuICB8IEF0b20gb2Ygc3RyaW5nXG4gIHwgTGlzdCBvZiB0IGxpc3RcblxubGV0IHNleHBfb2ZfdCB0ID0gdFxubGV0IHRfb2Zfc2V4cCB0ID0gdFxuXG5sZXQgcmVjIGNvbXBhcmVfbGlzdCBhIGIgPVxuICBtYXRjaCBhLCBiIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfIC0+IC0xXG4gIHwgXywgW10gLT4gMVxuICB8IHggOjogeHMsIHkgOjogeXMgLT5cbiAgICBsZXQgcmVzID0gY29tcGFyZSB4IHkgaW5cbiAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGNvbXBhcmVfbGlzdCB4cyB5c1xuXG5hbmQgY29tcGFyZSBhIGIgPVxuICBpZiBhID09IGJcbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgQXRvbSBhLCBBdG9tIGIgLT4gU3RyaW5nLmNvbXBhcmUgYSBiXG4gICAgfCBBdG9tIF8sIF8gLT4gLTFcbiAgICB8IF8sIEF0b20gXyAtPiAxXG4gICAgfCBMaXN0IGEsIExpc3QgYiAtPiBjb21wYXJlX2xpc3QgYSBiKVxuOztcblxubGV0IHJlYyBlcXVhbCBhIGIgPVxuICBhID09IGJcbiAgfHxcbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgQXRvbSBhLCBBdG9tIGIgLT4gU3RyaW5nLmVxdWFsIGEgYlxuICB8IEF0b20gXywgXyB8IF8sIEF0b20gXyAtPiBmYWxzZVxuICB8IExpc3QgYSwgTGlzdCBiIC0+IExpc3QuZXF1YWwgfmVxOmVxdWFsIGEgYlxuOztcblxuZXhjZXB0aW9uIE5vdF9mb3VuZF9zIG9mIHRcbmV4Y2VwdGlvbiBPZl9zZXhwX2Vycm9yIG9mIGV4biAqIHRcblxubW9kdWxlIFByaW50aW5nID0gc3RydWN0XG4gICgqIERlZmF1bHQgaW5kZW50YXRpb24gbGV2ZWwgZm9yIGh1bWFuLXJlYWRhYmxlIGNvbnZlcnNpb25zICopXG5cbiAgbGV0IGRlZmF1bHRfaW5kZW50ID0gcmVmIDFcblxuICAoKiBFc2NhcGluZyBvZiBzdHJpbmdzIHVzZWQgYXMgYXRvbXMgaW4gUy1leHByZXNzaW9ucyAqKVxuXG4gIGxldCBtdXN0X2VzY2FwZSBzdHIgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxlbiA9IDBcbiAgICB8fFxuICAgIGxldCByZWMgbG9vcCBzdHIgaXggPVxuICAgICAgbWF0Y2ggc3RyLltpeF0gd2l0aFxuICAgICAgfCAnXCInIHwgJygnIHwgJyknIHwgJzsnIHwgJ1xcXFwnIC0+IHRydWVcbiAgICAgIHwgJ3wnIC0+XG4gICAgICAgIGl4ID4gMFxuICAgICAgICAmJlxuICAgICAgICBsZXQgbmV4dCA9IGl4IC0gMSBpblxuICAgICAgICBDaGFyLmVxdWFsIHN0ci5bbmV4dF0gJyMnIHx8IGxvb3Agc3RyIG5leHRcbiAgICAgIHwgJyMnIC0+XG4gICAgICAgIGl4ID4gMFxuICAgICAgICAmJlxuICAgICAgICBsZXQgbmV4dCA9IGl4IC0gMSBpblxuICAgICAgICBDaGFyLmVxdWFsIHN0ci5bbmV4dF0gJ3wnIHx8IGxvb3Agc3RyIG5leHRcbiAgICAgIHwgJ1xcMDAwJyAuLiAnXFwwMzInIHwgJ1xcMTI3JyAuLiAnXFwyNTUnIC0+IHRydWVcbiAgICAgIHwgXyAtPiBpeCA+IDAgJiYgbG9vcCBzdHIgKGl4IC0gMSlcbiAgICBpblxuICAgIGxvb3Agc3RyIChsZW4gLSAxKVxuICA7O1xuXG4gIGxldCBlc2NhcGVkIHMgPVxuICAgIGxldCBuID0gcmVmIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgblxuICAgICAgICA6PSAhblxuICAgICAgICAgICArXG4gICAgICAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcbicgfCAnXFx0JyB8ICdcXHInIHwgJ1xcYicgLT4gMlxuICAgICAgICAgICB8ICcgJyAuLiAnficgLT4gMVxuICAgICAgICAgICB8IF8gLT4gNFxuICAgIGRvbmU7XG4gICAgaWYgIW4gPSBTdHJpbmcubGVuZ3RoIHNcbiAgICB0aGVuIHNcbiAgICBlbHNlIChcbiAgICAgIGxldCBzJyA9IEJ5dGVzLmNyZWF0ZSAhbiBpblxuICAgICAgbiA6PSAwO1xuICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgKG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgICB8ICgnXFxcIicgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICAgICB8ICdcXG4nIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ24nXG4gICAgICAgICB8ICdcXHQnIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ3QnXG4gICAgICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ3InXG4gICAgICAgICB8ICdcXGInIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ2InXG4gICAgICAgICB8ICcgJyAuLiAnficgYXMgYyAtPiBCeXRlcy51bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgICAgIHwgYyAtPlxuICAgICAgICAgICBsZXQgYSA9IENoYXIuY29kZSBjIGluXG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gKENoYXIuY2hyICg0OCArIChhIC8gMTAwKSkpO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gKENoYXIuY2hyICg0OCArIChhIC8gMTAgbW9kIDEwKSkpO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gKENoYXIuY2hyICg0OCArIChhIG1vZCAxMCkpKSk7XG4gICAgICAgIGluY3IgblxuICAgICAgZG9uZTtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcycpXG4gIDs7XG5cbiAgbGV0IGVzY19zdHIgc3RyID1cbiAgICBsZXQgZXN0ciA9IGVzY2FwZWQgc3RyIGluXG4gICAgbGV0IGVsZW4gPSBTdHJpbmcubGVuZ3RoIGVzdHIgaW5cbiAgICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIChlbGVuICsgMikgaW5cbiAgICBieXRlc19ibGl0X3N0cmluZyB+c3JjOmVzdHIgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3BvczoxIH5sZW46ZWxlbjtcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlcyAwICdcIic7XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXMgKGVsZW4gKyAxKSAnXCInO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIDs7XG5cbiAgbGV0IGluZGV4X29mX25ld2xpbmUgc3RyIHN0YXJ0ID0gU3RyaW5nLmluZGV4X2Zyb21fb3B0IHN0ciBzdGFydCAnXFxuJ1xuXG4gIGxldCBnZXRfc3Vic3RyaW5nIHN0ciBpbmRleCBlbmRfcG9zX29wdCA9XG4gICAgbGV0IGVuZF9wb3MgPVxuICAgICAgbWF0Y2ggZW5kX3Bvc19vcHQgd2l0aFxuICAgICAgfCBOb25lIC0+IFN0cmluZy5sZW5ndGggc3RyXG4gICAgICB8IFNvbWUgZW5kX3BvcyAtPiBlbmRfcG9zXG4gICAgaW5cbiAgICBTdHJpbmcuc3ViIHN0ciB+cG9zOmluZGV4IH5sZW46KGVuZF9wb3MgLSBpbmRleClcbiAgOztcblxuICBsZXQgaXNfb25lX2xpbmUgc3RyID1cbiAgICBtYXRjaCBpbmRleF9vZl9uZXdsaW5lIHN0ciAwIHdpdGhcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgIHwgU29tZSBpbmRleCAtPiBpbmRleCArIDEgPSBTdHJpbmcubGVuZ3RoIHN0clxuICA7O1xuXG4gIGxldCBwcF9odW1fbWF5YmVfZXNjX3N0ciBwcGYgc3RyID1cbiAgICBpZiBub3QgKG11c3RfZXNjYXBlIHN0cilcbiAgICB0aGVuIHBwX3ByaW50X3N0cmluZyBwcGYgc3RyXG4gICAgZWxzZSBpZiBpc19vbmVfbGluZSBzdHJcbiAgICB0aGVuIHBwX3ByaW50X3N0cmluZyBwcGYgKGVzY19zdHIgc3RyKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlYyBsb29wIGluZGV4ID1cbiAgICAgICAgbGV0IG5leHRfbmV3bGluZSA9IGluZGV4X29mX25ld2xpbmUgc3RyIGluZGV4IGluXG4gICAgICAgIGxldCBuZXh0X2xpbmUgPSBnZXRfc3Vic3RyaW5nIHN0ciBpbmRleCBuZXh0X25ld2xpbmUgaW5cbiAgICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoZXNjYXBlZCBuZXh0X2xpbmUpO1xuICAgICAgICBtYXRjaCBuZXh0X25ld2xpbmUgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgfCBTb21lIG5ld2xpbmVfaW5kZXggLT5cbiAgICAgICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiXFxcXFwiO1xuICAgICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpO1xuICAgICAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCJcXFxcblwiO1xuICAgICAgICAgIGxvb3AgKG5ld2xpbmVfaW5kZXggKyAxKVxuICAgICAgaW5cbiAgICAgIHBwX29wZW5fYm94IHBwZiAwO1xuICAgICAgKCogdGhlIGxlYWRpbmcgc3BhY2UgaXMgdG8gbGluZSB1cCB0aGUgbGluZXMgKilcbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIgXFxcIlwiO1xuICAgICAgbG9vcCAwO1xuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIlxcXCJcIjtcbiAgICAgIHBwX2Nsb3NlX2JveCBwcGYgKCkpXG4gIDs7XG5cbiAgbGV0IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHIgPSBpZiBtdXN0X2VzY2FwZSBzdHIgdGhlbiBlc2Nfc3RyIHN0ciBlbHNlIHN0clxuXG4gICgqIE91dHB1dCBvZiBTLWV4cHJlc3Npb25zIHRvIGZvcm1hdHRlcnMgKilcblxuICBsZXQgcmVjIHBwX2h1bV9pbmRlbnQgaW5kZW50IHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPiBwcF9odW1fbWF5YmVfZXNjX3N0ciBwcGYgc3RyXG4gICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICBwcF9vcGVuX2JveCBwcGYgaW5kZW50O1xuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIihcIjtcbiAgICAgIHBwX2h1bV9pbmRlbnQgaW5kZW50IHBwZiBoO1xuICAgICAgcHBfaHVtX3Jlc3QgaW5kZW50IHBwZiB0XG4gICAgfCBMaXN0IFtdIC0+IHBwX3ByaW50X3N0cmluZyBwcGYgXCIoKVwiXG5cbiAgYW5kIHBwX2h1bV9yZXN0IGluZGVudCBwcGYgPSBmdW5jdGlvblxuICAgIHwgaCA6OiB0IC0+XG4gICAgICBwcF9wcmludF9zcGFjZSBwcGYgKCk7XG4gICAgICBwcF9odW1faW5kZW50IGluZGVudCBwcGYgaDtcbiAgICAgIHBwX2h1bV9yZXN0IGluZGVudCBwcGYgdFxuICAgIHwgW10gLT5cbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIpXCI7XG4gICAgICBwcF9jbG9zZV9ib3ggcHBmICgpXG4gIDs7XG5cbiAgbGV0IHJlYyBwcF9tYWNoX2ludGVybmFsIG1heV9uZWVkX3NwYWNlIHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPlxuICAgICAgbGV0IHN0cicgPSBtYWNoX21heWJlX2VzY19zdHIgc3RyIGluXG4gICAgICBsZXQgbmV3X21heV9uZWVkX3NwYWNlID0gc3RyJyA9PSBzdHIgaW5cbiAgICAgIGlmIG1heV9uZWVkX3NwYWNlICYmIG5ld19tYXlfbmVlZF9zcGFjZSB0aGVuIHBwX3ByaW50X3N0cmluZyBwcGYgXCIgXCI7XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIHN0cic7XG4gICAgICBuZXdfbWF5X25lZWRfc3BhY2VcbiAgICB8IExpc3QgKGggOjogdCkgLT5cbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIoXCI7XG4gICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBwcF9tYWNoX2ludGVybmFsIGZhbHNlIHBwZiBoIGluXG4gICAgICBwcF9tYWNoX3Jlc3QgbWF5X25lZWRfc3BhY2UgcHBmIHQ7XG4gICAgICBmYWxzZVxuICAgIHwgTGlzdCBbXSAtPlxuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIigpXCI7XG4gICAgICBmYWxzZVxuXG4gIGFuZCBwcF9tYWNoX3Jlc3QgbWF5X25lZWRfc3BhY2UgcHBmID0gZnVuY3Rpb25cbiAgICB8IGggOjogdCAtPlxuICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gcHBfbWFjaF9pbnRlcm5hbCBtYXlfbmVlZF9zcGFjZSBwcGYgaCBpblxuICAgICAgcHBfbWFjaF9yZXN0IG1heV9uZWVkX3NwYWNlIHBwZiB0XG4gICAgfCBbXSAtPiBwcF9wcmludF9zdHJpbmcgcHBmIFwiKVwiXG4gIDs7XG5cbiAgbGV0IHBwX2h1bSBwcGYgc2V4cCA9IHBwX2h1bV9pbmRlbnQgIWRlZmF1bHRfaW5kZW50IHBwZiBzZXhwXG4gIGxldCBwcF9tYWNoIHBwZiBzZXhwID0gaWdub3JlIChwcF9tYWNoX2ludGVybmFsIGZhbHNlIHBwZiBzZXhwKVxuICBsZXQgcHAgPSBwcF9tYWNoXG5cbiAgKCogU2V4cCBzaXplICopXG5cbiAgbGV0IHJlYyBzaXplX2xvb3AgKCh2LCBjKSBhcyBhY2MpID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyIC0+IHYgKyAxLCBjICsgU3RyaW5nLmxlbmd0aCBzdHJcbiAgICB8IExpc3QgbHN0IC0+IExpc3QuZm9sZF9sZWZ0IGxzdCB+aW5pdDphY2MgfmY6c2l6ZV9sb29wXG4gIDs7XG5cbiAgbGV0IHNpemUgc2V4cCA9IHNpemVfbG9vcCAoMCwgMCkgc2V4cFxuXG4gICgqIEJ1ZmZlciBjb252ZXJzaW9ucyAqKVxuXG4gIGxldCB0b19idWZmZXJfaHVtIH5idWYgPyhpbmRlbnQgPSAhZGVmYXVsdF9pbmRlbnQpIHNleHAgPVxuICAgIGxldCBwcGYgPSBGb3JtYXQuZm9ybWF0dGVyX29mX2J1ZmZlciBidWYgaW5cbiAgICBGb3JtYXQuZnByaW50ZiBwcGYgXCIlYUA/XCIgKHBwX2h1bV9pbmRlbnQgaW5kZW50KSBzZXhwXG4gIDs7XG5cbiAgbGV0IHRvX2J1ZmZlcl9tYWNoIH5idWYgc2V4cCA9XG4gICAgbGV0IHJlYyBsb29wIG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgQXRvbSBzdHIgLT5cbiAgICAgICAgbGV0IHN0cicgPSBtYWNoX21heWJlX2VzY19zdHIgc3RyIGluXG4gICAgICAgIGxldCBuZXdfbWF5X25lZWRfc3BhY2UgPSBzdHInID09IHN0ciBpblxuICAgICAgICBpZiBtYXlfbmVlZF9zcGFjZSAmJiBuZXdfbWF5X25lZWRfc3BhY2UgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmICcgJztcbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIHN0cic7XG4gICAgICAgIG5ld19tYXlfbmVlZF9zcGFjZVxuICAgICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJygnO1xuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIGZhbHNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHQ7XG4gICAgICAgIGZhbHNlXG4gICAgICB8IExpc3QgW10gLT5cbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiKClcIjtcbiAgICAgICAgZmFsc2VcbiAgICBhbmQgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgaCA6OiB0IC0+XG4gICAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IGxvb3AgbWF5X25lZWRfc3BhY2UgaCBpblxuICAgICAgICBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgdFxuICAgICAgfCBbXSAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmICcpJ1xuICAgIGluXG4gICAgaWdub3JlIChsb29wIGZhbHNlIHNleHApXG4gIDs7XG5cbiAgbGV0IHRvX2J1ZmZlciA9IHRvX2J1ZmZlcl9tYWNoXG5cbiAgbGV0IHRvX2J1ZmZlcl9nZW4gfmJ1ZiB+YWRkX2NoYXIgfmFkZF9zdHJpbmcgc2V4cCA9XG4gICAgbGV0IHJlYyBsb29wIG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgQXRvbSBzdHIgLT5cbiAgICAgICAgbGV0IHN0cicgPSBtYWNoX21heWJlX2VzY19zdHIgc3RyIGluXG4gICAgICAgIGxldCBuZXdfbWF5X25lZWRfc3BhY2UgPSBzdHInID09IHN0ciBpblxuICAgICAgICBpZiBtYXlfbmVlZF9zcGFjZSAmJiBuZXdfbWF5X25lZWRfc3BhY2UgdGhlbiBhZGRfY2hhciBidWYgJyAnO1xuICAgICAgICBhZGRfc3RyaW5nIGJ1ZiBzdHInO1xuICAgICAgICBuZXdfbWF5X25lZWRfc3BhY2VcbiAgICAgIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgICAgICBhZGRfY2hhciBidWYgJygnO1xuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIGZhbHNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHQ7XG4gICAgICAgIGZhbHNlXG4gICAgICB8IExpc3QgW10gLT5cbiAgICAgICAgYWRkX3N0cmluZyBidWYgXCIoKVwiO1xuICAgICAgICBmYWxzZVxuICAgIGFuZCBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgPSBmdW5jdGlvblxuICAgICAgfCBoIDo6IHQgLT5cbiAgICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gbG9vcCBtYXlfbmVlZF9zcGFjZSBoIGluXG4gICAgICAgIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSB0XG4gICAgICB8IFtdIC0+IGFkZF9jaGFyIGJ1ZiAnKSdcbiAgICBpblxuICAgIGlnbm9yZSAobG9vcCBmYWxzZSBzZXhwKVxuICA7O1xuXG4gICgqIFRoZSBtYXhpbXVtIHNpemUgb2YgYSB0aGluZyBvbiB0aGUgbWlub3IgaGVhcCBpcyAyNTYgd29yZHMuXG4gICAgIFByZXZpb3VzbHksIHRoaXMgc2l6ZSBvZiB0aGUgcmV0dXJuZWQgYnVmZmVyIGhlcmUgd2FzIDQwOTYgYnl0ZXMsIHdoaWNoXG4gICAgIGNhdXNlZCB0aGUgQnVmZmVyIHRvIGJlIGFsbG9jYXRlZCBvbiB0aGUgKm1ham9yKiBoZWFwIGV2ZXJ5IHRpbWUuXG5cbiAgICAgQWNjb3JkaW5nIHRvIGEgc2ltcGxlIGJlbmNobWFyayBieSBSb24sIHdlIGNhbiBpbXByb3ZlIHBlcmZvcm1hbmNlIGZvclxuICAgICBzbWFsbCBzLWV4cHJlc3Npb25zIGJ5IGEgZmFjdG9yIG9mIH40IGlmIHdlIG9ubHkgYWxsb2NhdGUgMTAyNCBieXRlc1xuICAgICAoMTI4IHdvcmRzICsgc29tZSBzbWFsbCBvdmVyaGVhZCkgd29ydGggb2YgYnVmZmVyIGluaXRpYWxseS4gIEFuZCBvbmVcbiAgICAgY2FuIGFyZ3VlIHRoYXQgaWYgaXQncyBmcmVlIHRvIGFsbG9jYXRlIHN0cmluZ3Mgc21hbGxlciB0aGFuIDI1NiB3b3JkcyxcbiAgICAgbGFyZ2Ugcy1leHByZXNzaW9ucyByZXF1aXJpbmcgbGFyZ2VyIGV4cGVuc2l2ZSBidWZmZXJzIHdvbid0IG5vdGljZVxuICAgICB0aGUgZXh0cmEgdHdvIGRvdWJsaW5ncyBmcm9tIDEwMjQgYnl0ZXMgdG8gMjA0OCBhbmQgNDA5Ni4gQW5kIGVzcGVjaWFsbHlcbiAgICAgcGVyZm9ybWFuY2Utc2Vuc2l0aXZlIGFwcGxpY2F0aW9ucyB0byBhbHdheXMgcGFzcyBpbiBhIGxhcmdlciBidWZmZXIgdG9cbiAgICAgdXNlLiAqKVxuICBsZXQgYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSAxMDI0XG5cbiAgKCogU3RyaW5nIGNvbnZlcnNpb25zICopXG5cbiAgbGV0IHRvX3N0cmluZ19odW0gP2luZGVudCA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0clxuICAgICAgd2hlbiBtYXRjaCBpbmRleF9vZl9uZXdsaW5lIHN0ciAwIHdpdGhcbiAgICAgICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICAgICAgfCBTb21lIF8gLT4gZmFsc2UgLT4gbWFjaF9tYXliZV9lc2Nfc3RyIHN0clxuICAgIHwgc2V4cCAtPlxuICAgICAgbGV0IGJ1ZiA9IGJ1ZmZlciAoKSBpblxuICAgICAgdG9fYnVmZmVyX2h1bSA/aW5kZW50IHNleHAgfmJ1ZjtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nX21hY2ggPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHIgLT4gbWFjaF9tYXliZV9lc2Nfc3RyIHN0clxuICAgIHwgc2V4cCAtPlxuICAgICAgbGV0IGJ1ZiA9IGJ1ZmZlciAoKSBpblxuICAgICAgdG9fYnVmZmVyX21hY2ggc2V4cCB+YnVmO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdfbWFjaFxuZW5kXG5cbmluY2x1ZGUgUHJpbnRpbmdcblxubGV0IG9mX2Zsb2F0X3N0eWxlIDogWyBgVW5kZXJzY29yZXMgfCBgTm9fdW5kZXJzY29yZXMgXSByZWYgPSByZWYgYE5vX3VuZGVyc2NvcmVzXG5sZXQgb2ZfaW50X3N0eWxlIDogWyBgVW5kZXJzY29yZXMgfCBgTm9fdW5kZXJzY29yZXMgXSByZWYgPSByZWYgYE5vX3VuZGVyc2NvcmVzXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGluY2x1ZGUgUHJpbnRpbmdcbmVuZFxuXG5sZXQgbWVzc2FnZSBuYW1lIGZpZWxkcyA9XG4gIGxldCByZWMgY29udl9maWVsZHMgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IChmbmFtZSwgZnNleHApIDo6IHJlc3QgLT5cbiAgICAgIChtYXRjaCBmbmFtZSB3aXRoXG4gICAgICAgfCBcIlwiIC0+IGZzZXhwIDo6IGNvbnZfZmllbGRzIHJlc3RcbiAgICAgICB8IF8gLT4gTGlzdCBbIEF0b20gZm5hbWU7IGZzZXhwIF0gOjogY29udl9maWVsZHMgcmVzdClcbiAgaW5cbiAgTGlzdCAoQXRvbSBuYW1lIDo6IGNvbnZfZmllbGRzIGZpZWxkcylcbjs7XG4iLCIoKiogUmVwcmVzZW50YXRpb24gb2YgUy1leHByZXNzaW9uIGdyYW1tYXJzICopXG5cbigqKiBUaGlzIG1vZHVsZSBkZWZpbmVzIGEgcmVwcmVzZW50YXRpb24gZm9yIHMtZXhwcmVzc2lvbiBncmFtbWFycy4gVXNpbmcgcHB4X3NleHBfY29udlxuICAgIGFuZCBbW0BAZGVyaXZpbmcgc2V4cF9ncmFtbWFyXV0gcHJvZHVjZXMgYSBncmFtbWFyIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBkZXJpdmVkXG4gICAgW29mX3NleHBdIGZvciBhIGdpdmVuIHR5cGUuXG5cbiAgICBBcyB3aXRoIG90aGVyIGRlcml2ZWQgZGVmaW5pdGlvbnMsIHBvbHltb3JwaGljIHR5cGVzIGRlcml2ZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYVxuICAgIGdyYW1tYXIgZm9yIGVhY2ggdHlwZSBhcmd1bWVudCBhbmQgcHJvZHVjZXMgYSBncmFtbWFyIGZvciB0aGUgbW9ub21vcnBoaXplZCB0eXBlLlxuXG4gICAgTW9ub21vcnBoaWMgdHlwZXMgZGVyaXZlIGEgZ3JhbW1hciBkaXJlY3RseS4gVG8gYXZvaWQgdG9wLWxldmVsIHNpZGUgZWZmZWN0cyxcbiAgICBbW0BAZGVyaXZpbmcgc2V4cF9ncmFtbWFyXV0gd3JhcHMgZ3JhbW1hcnMgaW4gdGhlIFtMYXp5XSBjb25zdHJ1Y3RvciBhcyBuZWVkZWQuXG5cbiAgICBUaGlzIHR5cGUgbWF5IGNoYW5nZSBvdmVyIHRpbWUgYXMgb3VyIG5lZWRzIGZvciBleHByZXNzaXZlIGdyYW1tYXJzIGNoYW5nZS4gV2Ugd2lsbFxuICAgIGF0dGVtcHQgdG8gbWFrZSBjaGFuZ2VzIGJhY2t3YXJkLWNvbXBhdGlibGUsIG9yIGF0IGxlYXN0IHByb3ZpZGUgYSByZWFzb25hYmxlIHVwZ3JhZGVcbiAgICBwYXRoLiAqKVxuXG5bQEBAd2FybmluZyBcIi0zMFwiXSAoKiBhbGxvdyBkdXBsaWNhdGUgZmllbGQgbmFtZXMgKilcblxuKCoqIEdyYW1tYXIgb2YgYSBzZXhwLiAqKVxudHlwZSBncmFtbWFyID1cbiAgfCBBbnkgb2Ygc3RyaW5nICgqKiBhY2NlcHRzIGFueSBzZXhwOyBzdHJpbmcgaXMgYSB0eXBlIG5hbWUgZm9yIGh1bWFuIHJlYWRhYmlsaXR5ICopXG4gIHwgQm9vbCAoKiogYWNjZXB0cyB0aGUgYXRvbXMgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiLCBtb2R1bG8gY2FwaXRhbGl6YXRpb24gKilcbiAgfCBDaGFyICgqKiBhY2NlcHRzIGFueSBzaW5nbGUtY2hhcmFjdGVyIGF0b20gKilcbiAgfCBJbnRlZ2VyICgqKiBhY2NlcHRzIGFueSBhdG9tIG1hdGNoaW5nIG9jYW1sIGludGVnZXIgc3ludGF4LCByZWdhcmRsZXNzIG9mIGJpdCB3aWR0aCAqKVxuICB8IEZsb2F0ICgqKiBhY2NlcHRzIGFueSBhdG9tIG1hdGNoaW5nIG9jYW1sIGZsb2F0IHN5bnRheCAqKVxuICB8IFN0cmluZyAoKiogYWNjZXB0cyBhbnkgYXRvbSAqKVxuICB8IE9wdGlvbiBvZiBncmFtbWFyICgqKiBhY2NlcHRzIGFuIG9wdGlvbiwgYm90aCBbTm9uZV0gdnMgW1NvbWUgX10gYW5kIFsoKV0gdnMgWyhfKV0uICopXG4gIHwgTGlzdCBvZiBsaXN0X2dyYW1tYXIgKCoqIGFjY2VwdHMgYSBsaXN0ICopXG4gIHwgVmFyaWFudCBvZiB2YXJpYW50ICgqKiBhY2NlcHRzIGNsYXVzZXMga2V5ZWQgYnkgYSBsZWFkaW5nIG9yIHNvbGUgYXRvbSAqKVxuICB8IFVuaW9uIG9mIGdyYW1tYXIgbGlzdCAoKiogYWNjZXB0cyBhIHNleHAgaWYgYW55IG9mIHRoZSBsaXN0ZWQgZ3JhbW1hcnMgYWNjZXB0cyBpdCAqKVxuICB8IFRhZ2dlZCBvZiBncmFtbWFyIHdpdGhfdGFnXG4gICAgICAoKiogYW5ub3RhdGVzIGEgZ3JhbW1hciB3aXRoIGEgY2xpZW50LXNwZWNpZmljIGtleS92YWx1ZSBwYWlyICopXG4gIHwgVHl2YXIgb2Ygc3RyaW5nXG4gICAgICAoKiogTmFtZSBvZiBhIHR5cGUgdmFyaWFibGUsIGUuZy4gW1R5dmFyIFwiYVwiXSBmb3IgWydhXS4gT25seSBtZWFuaW5nZnVsIHdoZW4gdGhlIGJvZHkgb2ZcbiAgICAgIHRoZSBpbm5lcm1vc3QgZW5jbG9zaW5nIFtkZWZuXSBkZWZpbmVzIGEgY29ycmVzcG9uZGluZyB0eXBlIHZhcmlhYmxlLiAqKVxuICB8IFR5Y29uIG9mIHN0cmluZyAqIGdyYW1tYXIgbGlzdCAqIGRlZm4gbGlzdFxuICAgICAgKCoqIFR5cGUgY29uc3RydWN0b3IgYXBwbGllZCB0byBhcmd1bWVudHMsIGFuZCBpdHMgZGVmaW5pdGlvbi5cblxuICAgICAgRm9yIGV4YW1wbGUsIHdyaXRpbmcgW1R5Y29uIChcInRyZWVcIiwgWyBJbnRlZ2VyIF0sIGRlZm5zKV0gcmVwcmVzZW50cyBbaW50IHRyZWVdLCBmb3JcbiAgICAgIHdoYXRldmVyIFt0cmVlXSBpcyBkZWZpbmVkIGFzIGluIFtkZWZuc10uIFRoZSBmb2xsb3dpbmcgZGVmaW5lcyBbdHJlZV0gYXMgYSBiaW5hcnlcbiAgICAgIHRyZWUgd2l0aCB0aGUgcGFyYW1ldGVyIHR5cGUgc3RvcmVkIGF0IHRoZSBsZWF2ZXMuXG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBkZWZucyA9XG4gICAgICAgICAgWyB7IHR5Y29uID0gXCJ0cmVlXCJcbiAgICAgICAgICAgIDsgdHl2YXJzID0gW1wiYVwiXVxuICAgICAgICAgICAgOyBncmFtbWFyID1cbiAgICAgICAgICAgICAgICBWYXJpYW50XG4gICAgICAgICAgICAgICAgICB7IG5hbWVfa2luZCA9IENhcGl0YWxpemVkXG4gICAgICAgICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgICAgICAgIFsgeyBuYW1lID0gXCJOb2RlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFJlY3Vyc2l2ZSAoXCJub2RlXCIsIFtUeXZhciBcImFcIl0pLCBFbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICA7IHsgbmFtZSA9IFwiTGVhZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChSZWN1cnNpdmUgKFwibGVhZlwiLCBbVHl2YXIgXCJhXCJdKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDsgeyB0eWNvbiA9IFwibm9kZVwiXG4gICAgICAgICAgICA7IHR5dmFycyA9IFtcImFcIl1cbiAgICAgICAgICAgIDsgZ3JhbW1hciA9IExpc3QgKE1hbnkgKFJlY3Vyc2l2ZSBcInRyZWVcIiwgW1R5dmFyIFwiYVwiXSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOyB7IHR5Y29uID0gXCJsZWFmXCJcbiAgICAgICAgICAgIDsgdHl2YXJzID0gW1wiYVwiXVxuICAgICAgICAgICAgOyBncmFtbWFyID0gW1R5dmFyIFwiYVwiXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgOztcbiAgICAgIF19XG5cbiAgICAgIFRvIGlsbHVzdHJhdGUgdGhlIG1lYW5pbmcgb2YgW1R5Y29uXSB3aXRoIHJlc3BlY3QgdG8gW2RlZm5zXSwgYW5kIHRvIGRlbW9uc3RyYXRlIG9uZVxuICAgICAgd2F5IHRvIGFjY2VzcyB0aGVtLCBpdCBpcyBlcXVpdmFsZW50IHRvIGV4cGFuZCB0aGUgZGVmaW5pdGlvbiBvZiBcInRyZWVcIiBvbmUgbGV2ZWxcbiAgICAgIGFuZCBtb3ZlIHRoZSBbZGVmbnNdIHRvIGVuY2xvc2VkIHJlY3Vyc2l2ZSByZWZlcmVuY2VzOlxuXG4gICAgICB7W1xuICAgICAgICBUeWNvbiAoXCJ0cmVlXCIsIFsgSW50ZWdlciBdLCBkZWZucylcbiAgICAgICAgLS0+XG4gICAgICAgIFZhcmlhbnRcbiAgICAgICAgICB7IG5hbWVfa2luZCA9IENhcGl0YWxpemVkXG4gICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgWyB7IG5hbWUgPSBcIk5vZGVcIlxuICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFR5Y29uIChcIm5vZGVcIiwgW1R5dmFyIFwiYVwiXSwgZGVmbnMpLCBFbXB0eSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDsgeyBuYW1lID0gXCJMZWFmXCJcbiAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChUeWNvbiAoXCJsZWFmXCIsIFtUeXZhciBcImFcIl0sIGRlZm5zKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgXX1cblxuICAgICAgVGhpcyB0cmFuc2Zvcm1hdGlvbiBleHBvc2VzIHRoZSBzdHJ1Y3R1cmUgb2YgYSBncmFtbWFyIHdpdGggcmVjdXJzaXZlIHJlZmVyZW5jZXMsXG4gICAgICB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBtZWFuaW5nIG9mIHJlY3Vyc2l2ZWx5LWRlZmluZWQgZWxlbWVudHMuICopXG4gIHwgUmVjdXJzaXZlIG9mIHN0cmluZyAqIGdyYW1tYXIgbGlzdFxuICAgICAgKCoqIFR5cGUgY29uc3RydWN0b3IgYXBwbGllZCB0byBhcmd1bWVudHMuIFVzZWQgdG8gZGVub3RlIHJlY3Vyc2l2ZSB0eXBlIHJlZmVyZW5jZXMuXG4gICAgICBPbmx5IG1lYW5pbmdmdWwgd2hlbiB1c2VkIGluc2lkZSB0aGUgW2RlZm5dcyBvZiBhIFtUeWNvbl0gZ3JhbW1hciwgdG8gcmVmZXIgdG8gYVxuICAgICAgdHlwZSBjb25zdHJ1Y3RvciBpbiB0aGUgbmVhcmVzdCBlbmNsb3NpbmcgW2RlZm5dIGxpc3QuICopXG4gIHwgTGF6eSBvZiBncmFtbWFyIGxhenlfdFxuICAgICAgKCoqIExhemlseSBjb21wdXRlZCBncmFtbWFyLiBVc2UgW0xhenldIHRvIGF2b2lkIHRvcC1sZXZlbCBzaWRlIGVmZmVjdHMuIFRvIGRlZmluZVxuICAgICAgcmVjdXJzaXZlIGdyYW1tYXJzLCB1c2UgW1JlY3Vyc2l2ZV0gaW5zdGVhZC4gKilcblxuKCoqIEdyYW1tYXIgb2YgYSBsaXN0IG9mIHNleHBzLiAqKVxuYW5kIGxpc3RfZ3JhbW1hciA9XG4gIHwgRW1wdHkgKCoqIGFjY2VwdHMgYW4gZW1wdHkgbGlzdCBvZiBzZXhwcyAqKVxuICB8IENvbnMgb2YgZ3JhbW1hciAqIGxpc3RfZ3JhbW1hclxuICAgICAgKCoqIGFjY2VwdHMgYSBub24tZW1wdHkgbGlzdCB3aXRoIGhlYWQgYW5kIHRhaWwgbWF0Y2hpbmcgdGhlIGdpdmVuIGdyYW1tYXJzICopXG4gIHwgTWFueSBvZiBncmFtbWFyICgqKiBhY2NlcHRzIHplcm8gb3IgbW9yZSBzZXhwcywgZWFjaCBtYXRjaGluZyB0aGUgZ2l2ZW4gZ3JhbW1hciAqKVxuICB8IEZpZWxkcyBvZiByZWNvcmQgKCoqIGFjY2VwdHMgc2V4cHMgcmVwcmVzZW50aW5nIGZpZWxkcyBvZiBhIHJlY29yZCAqKVxuXG4oKiogQ2FzZSBzZW5zaXRpdml0eSBvcHRpb25zIGZvciBuYW1lcyBvZiB2YXJpYW50IGNvbnN0cnVjdG9ycy4gKilcbmFuZCBjYXNlX3NlbnNpdGl2aXR5ID1cbiAgfCBDYXNlX2luc2Vuc2l0aXZlICgqKiBDb21wYXJpc29uIGlzIGNhc2UgaW5zZW5zaXRpdmUuIFVzZWQgZm9yIGN1c3RvbSBwYXJzZXJzLiAqKVxuICB8IENhc2Vfc2Vuc2l0aXZlICgqKiBDb21wYXJpc29uIGlzIGNhc2Ugc2Vuc2l0aXZlLiBVc2VkIGZvciBwb2x5bW9ycGhpYyB2YXJpYW50cy4gKilcbiAgfCBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAoKiogQ29tcGFyaXNvbiBpcyBjYXNlIGluc2Vuc2l0aXZlIGZvciB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBjYXNlIHNlbnNpdGl2ZSBhZnRlcndhcmQuXG4gICAgICBVc2VkIGZvciByZWd1bGFyIHZhcmlhbnRzLiAqKVxuXG4oKiogR3JhbW1hciBvZiB2YXJpYW50cy4gQWNjZXB0cyBhbnkgc2V4cCBtYXRjaGluZyBvbmUgb2YgdGhlIGNsYXVzZXMuICopXG5hbmQgdmFyaWFudCA9XG4gIHsgY2FzZV9zZW5zaXRpdml0eSA6IGNhc2Vfc2Vuc2l0aXZpdHlcbiAgOyBjbGF1c2VzIDogY2xhdXNlIHdpdGhfdGFnX2xpc3QgbGlzdFxuICB9XG5cbigqKiBHcmFtbWFyIG9mIGEgc2luZ2xlIHZhcmlhbnQgY2xhdXNlLiBBY2NlcHRzIHNleHBzIGJhc2VkIG9uIHRoZSBbY2xhdXNlX2tpbmRdLiAqKVxuYW5kIGNsYXVzZSA9XG4gIHsgbmFtZSA6IHN0cmluZ1xuICA7IGNsYXVzZV9raW5kIDogY2xhdXNlX2tpbmRcbiAgfVxuXG4oKiogR3JhbW1hciBvZiBhIHNpbmdsZSB2YXJpYW50IGNsYXVzZSdzIGNvbnRlbnRzLiBbQXRvbV9jbGF1c2VdIGFjY2VwdHMgYW4gYXRvbSBtYXRjaGluZ1xuICAgIHRoZSBjbGF1c2UncyBuYW1lLiBbTGlzdF9jbGF1c2VdIGFjY2VwdHMgYSBsaXN0IHdob3NlIGhlYWQgaXMgYW4gYXRvbSBtYXRjaGluZyB0aGVcbiAgICBjbGF1c2UncyBuYW1lIGFuZCB3aG9zZSB0YWlsIG1hdGNoZXMgW2FyZ3NdLiBUaGUgY2xhdXNlJ3MgbmFtZSBpcyBtYXRjaGVkIG1vZHVsbyB0aGVcbiAgICB2YXJpYW50J3MgW25hbWVfa2luZF0uICopXG5hbmQgY2xhdXNlX2tpbmQgPVxuICB8IEF0b21fY2xhdXNlXG4gIHwgTGlzdF9jbGF1c2Ugb2YgeyBhcmdzIDogbGlzdF9ncmFtbWFyIH1cblxuKCoqIEdyYW1tYXIgb2YgYSByZWNvcmQuIEFjY2VwdHMgYW55IGxpc3Qgb2Ygc2V4cHMgc3BlY2lmeWluZyBlYWNoIG9mIHRoZSBmaWVsZHMsXG4gICAgcmVnYXJkbGVzcyBvZiBvcmRlci4gSWYgW2FsbG93X2V4dHJhX2ZpZWxkc10gaXMgc3BlY2lmaWVkLCBpZ25vcmVzIHNleHBzIHdpdGggbmFtZXNcbiAgICBub3QgZm91bmQgaW4gW2ZpZWxkc10uICopXG5hbmQgcmVjb3JkID1cbiAgeyBhbGxvd19leHRyYV9maWVsZHMgOiBib29sXG4gIDsgZmllbGRzIDogZmllbGQgd2l0aF90YWdfbGlzdCBsaXN0XG4gIH1cblxuKCoqIEdyYW1tYXIgb2YgYSByZWNvcmQgZmllbGQuIEEgZmllbGQgbXVzdCBzaG93IHVwIGV4YWN0bHkgb25jZSBpbiBhIHJlY29yZCBpZlxuICAgIFtyZXF1aXJlZF0sIG9yIGF0IG1vc3Qgb25jZSBvdGhlcndpc2UuIEFjY2VwdHMgYSBsaXN0IGhlYWRlZCBieSBbbmFtZV0gYXMgYW4gYXRvbSxcbiAgICBmb2xsb3dlZCBieSBzZXhwcyBtYXRjaGluZyBbYXJnc10uICopXG5hbmQgZmllbGQgPVxuICB7IG5hbWUgOiBzdHJpbmdcbiAgOyByZXF1aXJlZCA6IGJvb2xcbiAgOyBhcmdzIDogbGlzdF9ncmFtbWFyXG4gIH1cblxuKCoqIEdyYW1tYXIgdGFnZ2VkIHdpdGggY2xpZW50LXNwZWNpZmljIGtleS92YWx1ZSBwYWlyLiAqKVxuYW5kICdhIHdpdGhfdGFnID1cbiAgeyBrZXkgOiBzdHJpbmdcbiAgOyB2YWx1ZSA6IFNleHAudFxuICA7IGdyYW1tYXIgOiAnYVxuICB9XG5cbmFuZCAnYSB3aXRoX3RhZ19saXN0ID1cbiAgfCBUYWcgb2YgJ2Egd2l0aF90YWdfbGlzdCB3aXRoX3RhZ1xuICB8IE5vX3RhZyBvZiAnYVxuXG4oKiogR3JhbW1hciBvZiBhIHJlY3Vyc2l2ZSB0eXBlIGRlZmluaXRpb24uIE5hbWVzIHRoZSBbdHljb25dIGJlaW5nIGRlZmluZWQsIGFuZCB0aGVcbiAgICBbdHl2YXJzXSBpdCB0YWtlcyBhcyBwYXJhbWV0ZXJzLiBTcGVjaWZpZXMgdGhlIFtncmFtbWFyXSBvZiB0aGUgW3R5Y29uXS4gVGhlIGdyYW1tYXJcbiAgICBtYXkgcmVmZXIgdG8gYW55IG9mIHRoZSBbdHl2YXJzXSwgYW5kIHRvIGFueSBvZiB0aGUgW3R5Y29uXXMgZnJvbSB0aGUgc2FtZSBzZXQgb2ZcbiAgICBbUmVjdXJzaXZlXSBkZWZpbml0aW9ucy4gKilcbmFuZCBkZWZuID1cbiAgeyB0eWNvbiA6IHN0cmluZ1xuICA7IHR5dmFycyA6IHN0cmluZyBsaXN0XG4gIDsgZ3JhbW1hciA6IGdyYW1tYXJcbiAgfVxuXG4oKiogVG9wLWxldmVsIGdyYW1tYXIgdHlwZS4gSGFzIGEgcGhhbnRvbSB0eXBlIHBhcmFtZXRlciB0byBhc3NvY2lhdGUgZWFjaCBncmFtbWFyIHdpdGhcbiAgICB0aGUgdHlwZSBpdHMgc2V4cHMgcmVwcmVzZW50LiBUaGlzIG1ha2VzIGl0IGhhcmRlciB0byBhcHBseSBncmFtbWFycyB0byB0aGUgd3JvbmdcbiAgICB0eXBlLCB3aGlsZSBncmFtbWFycyBjYW4gc3RpbGwgYmUgZWFzaWx5IGNvZXJjZWQgdG8gYSBuZXcgdHlwZSBpZiBuZWVkZWQuICopXG50eXBlIF8gdCA9IHsgdW50eXBlZCA6IGdyYW1tYXIgfSBbQEB1bmJveGVkXVxuXG5sZXQgY29lcmNlICh0eXBlIGEgYikgKHsgdW50eXBlZCA9IF8gfSBhcyB0IDogYSB0KSA6IGIgdCA9IHRcblxubGV0IHRhZyAodHlwZSBhKSAoeyB1bnR5cGVkID0gZ3JhbW1hciB9IDogYSB0KSB+a2V5IH52YWx1ZSA6IGEgdCA9XG4gIHsgdW50eXBlZCA9IFRhZ2dlZCB7IGtleTsgdmFsdWU7IGdyYW1tYXIgfSB9XG47O1xuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgaXMgdXNlZCBmb3IgYWxsIHRhZ3MgZ2VuZXJhdGVkIGZyb20gZG9jIGNvbW1lbnRzLiAqKVxubGV0IGRvY19jb21tZW50X3RhZyA9IFwic2V4cF9ncmFtbWFyLmRvY19jb21tZW50XCJcblxuKCoqIFRoaXMgcmVzZXJ2ZWQga2V5IGNhbiBiZSB1c2VkIHRvIGFzc29jaWF0ZSBhIHR5cGUgbmFtZSB3aXRoIGEgZ3JhbW1hci4gKilcbmxldCB0eXBlX25hbWVfdGFnID0gXCJzZXhwX2dyYW1tYXIudHlwZV9uYW1lXCJcblxuKCoqIFRoaXMgcmVzZXJ2ZWQga2V5IGluZGljYXRlcyB0aGF0IGEgc2V4cCByZXByZXNlbnRzIGEga2V5L3ZhbHVlIGFzc29jaWF0aW9uLiBUaGUgdGFnJ3NcbiAgICB2YWx1ZSBpcyBpZ25vcmVkLiAqKVxubGV0IGFzc29jX3RhZyA9IFwic2V4cF9ncmFtbWFyLmFzc29jXCJcblxuKCoqIFRoaXMgcmVzZXJ2ZWQga2V5IGluZGljYXRlcyB0aGF0IGEgc2V4cCBpcyBhIGtleSBpbiBhIGtleS92YWx1ZSBhc3NvY2lhdGlvbi4gVGhlIHRhZydzXG4gICAgdmFsdWUgaXMgaWdub3JlZC4gKilcbmxldCBhc3NvY19rZXlfdGFnID0gXCJzZXhwX2dyYW1tYXIuYXNzb2Mua2V5XCJcblxuKCoqIFRoaXMgcmVzZXJ2ZWQga2V5IGluZGljYXRlcyB0aGF0IGEgc2V4cCBpcyBhIHZhbHVlIGluIGEga2V5L3ZhbHVlIGFzc29jaWF0aW9uLiBUaGVcbiAgICB0YWcncyB2YWx1ZSBpcyBpZ25vcmVkLiAqKVxubGV0IGFzc29jX3ZhbHVlX3RhZyA9IFwic2V4cF9ncmFtbWFyLmFzc29jLnZhbHVlXCJcblxuKCoqIFdoZW4gdGhlIGtleSBpcyBzZXQgdG8gW0F0b20gXCJmYWxzZVwiXSBmb3IgYSB2YXJpYW50IGNsYXVzZSwgdGhhdCBjbGF1c2Ugc2hvdWxkIG5vdCBiZVxuICAgIHN1Z2dlc3RlZCBpbiBhdXRvLWNvbXBsZXRpb24gYmFzZWQgb24gdGhlIHNleHAgZ3JhbW1hci4gKilcbmxldCBjb21wbGV0aW9uX3N1Z2dlc3RlZCA9IFwic2V4cF9ncmFtbWFyLmNvbXBsZXRpb24tc3VnZ2VzdGVkXCJcbiIsIm9wZW4gU3RkTGFiZWxzXG5cbmxldCBzZXhwX2dyYW1tYXJfd2l0aF90YWdzIGdyYW1tYXIgfnRhZ3MgPVxuICBMaXN0LmZvbGRfcmlnaHQgdGFncyB+aW5pdDpncmFtbWFyIH5mOihmdW4gKGtleSwgdmFsdWUpIGdyYW1tYXIgLT5cbiAgICBTZXhwX2dyYW1tYXIuVGFnZ2VkIHsga2V5OyB2YWx1ZTsgZ3JhbW1hciB9KVxuOztcblxubGV0IHNleHBfZ3JhbW1hcl93aXRoX3RhZ19saXN0IHggfnRhZ3MgPVxuICBMaXN0LmZvbGRfcmlnaHQgdGFncyB+aW5pdDp4IH5mOihmdW4gKGtleSwgdmFsdWUpIGdyYW1tYXIgLT5cbiAgICBTZXhwX2dyYW1tYXIuVGFnIHsga2V5OyB2YWx1ZTsgZ3JhbW1hciB9KVxuOztcblxubGV0IHVuaXRfc2V4cF9ncmFtbWFyIDogdW5pdCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IExpc3QgRW1wdHkgfVxubGV0IGJvb2xfc2V4cF9ncmFtbWFyIDogYm9vbCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEJvb2wgfVxubGV0IHN0cmluZ19zZXhwX2dyYW1tYXIgOiBzdHJpbmcgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBTdHJpbmcgfVxubGV0IGJ5dGVzX3NleHBfZ3JhbW1hciA6IGJ5dGVzIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gU3RyaW5nIH1cbmxldCBjaGFyX3NleHBfZ3JhbW1hciA6IGNoYXIgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBDaGFyIH1cbmxldCBpbnRfc2V4cF9ncmFtbWFyIDogaW50IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgZmxvYXRfc2V4cF9ncmFtbWFyIDogZmxvYXQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBGbG9hdCB9XG5sZXQgaW50MzJfc2V4cF9ncmFtbWFyIDogaW50MzIgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBJbnRlZ2VyIH1cbmxldCBpbnQ2NF9zZXhwX2dyYW1tYXIgOiBpbnQ2NCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IG5hdGl2ZWludF9zZXhwX2dyYW1tYXIgOiBuYXRpdmVpbnQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBJbnRlZ2VyIH1cbmxldCBzZXhwX3Rfc2V4cF9ncmFtbWFyIDogU2V4cC50IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gQW55IFwiU2V4cC50XCIgfVxubGV0IHJlZl9zZXhwX2dyYW1tYXIgZ3JhbW1hciA9IFNleHBfZ3JhbW1hci5jb2VyY2UgZ3JhbW1hclxubGV0IGxhenlfdF9zZXhwX2dyYW1tYXIgZ3JhbW1hciA9IFNleHBfZ3JhbW1hci5jb2VyY2UgZ3JhbW1hclxuXG5sZXQgb3B0aW9uX3NleHBfZ3JhbW1hciAoeyB1bnR5cGVkIH0gOiBfIFNleHBfZ3JhbW1hci50KSA6IF8gb3B0aW9uIFNleHBfZ3JhbW1hci50ID1cbiAgeyB1bnR5cGVkID0gT3B0aW9uIHVudHlwZWQgfVxuOztcblxubGV0IGxpc3Rfc2V4cF9ncmFtbWFyICh7IHVudHlwZWQgfSA6IF8gU2V4cF9ncmFtbWFyLnQpIDogXyBsaXN0IFNleHBfZ3JhbW1hci50ID1cbiAgeyB1bnR5cGVkID0gTGlzdCAoTWFueSB1bnR5cGVkKSB9XG47O1xuXG5sZXQgYXJyYXlfc2V4cF9ncmFtbWFyICh7IHVudHlwZWQgfSA6IF8gU2V4cF9ncmFtbWFyLnQpIDogXyBhcnJheSBTZXhwX2dyYW1tYXIudCA9XG4gIHsgdW50eXBlZCA9IExpc3QgKE1hbnkgdW50eXBlZCkgfVxuOztcblxubGV0IGVtcHR5X3NleHBfZ3JhbW1hciA6IF8gU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBVbmlvbiBbXSB9XG5sZXQgb3BhcXVlX3NleHBfZ3JhbW1hciA9IGVtcHR5X3NleHBfZ3JhbW1hclxubGV0IGZ1bl9zZXhwX2dyYW1tYXIgPSBlbXB0eV9zZXhwX2dyYW1tYXJcbiIsIigqIFV0aWxpdHkgTW9kdWxlIGZvciBTLWV4cHJlc3Npb24gQ29udmVyc2lvbnMgKilcblxub3BlbiBTdGRMYWJlbHNcbm9wZW4gTW9yZUxhYmVsc1xub3BlbiBQcmludGZcbm9wZW4gU2V4cFxuXG4oKiBDb252ZXJzaW9uIG9mIE9DYW1sLXZhbHVlcyB0byBTLWV4cHJlc3Npb25zICopXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbigqICclLjE3ZycgaXMgZ3VhcmFudGVlZCB0byBiZSByb3VuZC10cmlwcGFibGUuXG5cbiAgICclLjE1Zycgd2lsbCBiZSByb3VuZC10cmlwcGFibGUgYW5kIG5vdCBoYXZlIG5vaXNlIGF0IHRoZSBsYXN0IGRpZ2l0IG9yIHR3byBmb3IgYSBmbG9hdFxuICAgd2hpY2ggd2FzIGNvbnZlcnRlZCBmcm9tIGEgZGVjaW1hbCAoc3RyaW5nKSB3aXRoIDw9IDE1IHNpZ25pZmljYW50IGRpZ2l0cy4gIFNvIGl0J3NcbiAgIHdvcnRoIHRyeWluZyBmaXJzdCB0byBhdm9pZCB0aGluZ3MgbGlrZSBcIjMuMTQwMDAwMDAwMDAwMDAwMVwiLlxuXG4gICBTZWUgY29tbWVudCBhYm92ZSBbdG9fc3RyaW5nX3JvdW5kX3RyaXBwYWJsZV0gaW4geyFDb3JlLkZsb2F0fSBmb3JcbiAgIGRldGFpbGVkIGV4cGxhbmF0aW9uIGFuZCBleGFtcGxlcy4gKilcbmxldCBkZWZhdWx0X3N0cmluZ19vZl9mbG9hdCA9XG4gIHJlZiAoZnVuIHggLT5cbiAgICBsZXQgeSA9IGZvcm1hdF9mbG9hdCBcIiUuMTVHXCIgeCBpblxuICAgIGlmIGZsb2F0X29mX3N0cmluZyB5ID0geCB0aGVuIHkgZWxzZSBmb3JtYXRfZmxvYXQgXCIlLjE3R1wiIHgpXG47O1xuXG5sZXQgcmVhZF9vbGRfb3B0aW9uX2Zvcm1hdCA9IHJlZiB0cnVlXG5sZXQgd3JpdGVfb2xkX29wdGlvbl9mb3JtYXQgPSByZWYgdHJ1ZVxubGV0IGxpc3RfbWFwIGYgbCA9IExpc3QubWFwIGwgfmZcbmxldCBzZXhwX29mX3VuaXQgKCkgPSBMaXN0IFtdXG5sZXQgc2V4cF9vZl9ib29sIGIgPSBBdG9tIChzdHJpbmdfb2ZfYm9vbCBiKVxubGV0IHNleHBfb2Zfc3RyaW5nIHN0ciA9IEF0b20gc3RyXG5sZXQgc2V4cF9vZl9ieXRlcyBieXRlcyA9IEF0b20gKEJ5dGVzLnRvX3N0cmluZyBieXRlcylcbmxldCBzZXhwX29mX2NoYXIgYyA9IEF0b20gKFN0cmluZy5tYWtlIDEgYylcbmxldCBzZXhwX29mX2ludCBuID0gQXRvbSAoc3RyaW5nX29mX2ludCBuKVxubGV0IHNleHBfb2ZfZmxvYXQgbiA9IEF0b20gKCFkZWZhdWx0X3N0cmluZ19vZl9mbG9hdCBuKVxubGV0IHNleHBfb2ZfaW50MzIgbiA9IEF0b20gKEludDMyLnRvX3N0cmluZyBuKVxubGV0IHNleHBfb2ZfaW50NjQgbiA9IEF0b20gKEludDY0LnRvX3N0cmluZyBuKVxubGV0IHNleHBfb2ZfbmF0aXZlaW50IG4gPSBBdG9tIChOYXRpdmVpbnQudG9fc3RyaW5nIG4pXG5sZXQgc2V4cF9vZl9yZWYgc2V4cF9vZl9fYSByZiA9IHNleHBfb2ZfX2EgIXJmXG5sZXQgc2V4cF9vZl9sYXp5X3Qgc2V4cF9vZl9fYSBsdiA9IHNleHBfb2ZfX2EgKExhenkuZm9yY2UgbHYpXG5cbmxldCBzZXhwX29mX29wdGlvbiBzZXhwX29mX19hID0gZnVuY3Rpb25cbiAgfCBTb21lIHggd2hlbiAhd3JpdGVfb2xkX29wdGlvbl9mb3JtYXQgLT4gTGlzdCBbIHNleHBfb2ZfX2EgeCBdXG4gIHwgU29tZSB4IC0+IExpc3QgWyBBdG9tIFwic29tZVwiOyBzZXhwX29mX19hIHggXVxuICB8IE5vbmUgd2hlbiAhd3JpdGVfb2xkX29wdGlvbl9mb3JtYXQgLT4gTGlzdCBbXVxuICB8IE5vbmUgLT4gQXRvbSBcIm5vbmVcIlxuOztcblxubGV0IHNleHBfb2ZfcGFpciBzZXhwX29mX19hIHNleHBfb2ZfX2IgKGEsIGIpID0gTGlzdCBbIHNleHBfb2ZfX2EgYTsgc2V4cF9vZl9fYiBiIF1cblxubGV0IHNleHBfb2ZfdHJpcGxlIHNleHBfb2ZfX2Egc2V4cF9vZl9fYiBzZXhwX29mX19jIChhLCBiLCBjKSA9XG4gIExpc3QgWyBzZXhwX29mX19hIGE7IHNleHBfb2ZfX2IgYjsgc2V4cF9vZl9fYyBjIF1cbjs7XG5cbmxldCBzZXhwX29mX2xpc3Qgc2V4cF9vZl9fYSBsc3QgPSBMaXN0IChMaXN0Lm1hcCBsc3QgfmY6c2V4cF9vZl9fYSlcblxubGV0IHNleHBfb2ZfYXJyYXkgc2V4cF9vZl9fYSBhciA9XG4gIGxldCBsc3RfcmVmID0gcmVmIFtdIGluXG4gIGZvciBpID0gQXJyYXkubGVuZ3RoIGFyIC0gMSBkb3dudG8gMCBkb1xuICAgIGxzdF9yZWYgOj0gc2V4cF9vZl9fYSBhci4oaSkgOjogIWxzdF9yZWZcbiAgZG9uZTtcbiAgTGlzdCAhbHN0X3JlZlxuOztcblxubGV0IHNleHBfb2ZfaGFzaHRibCBzZXhwX29mX2tleSBzZXhwX29mX3ZhbCBodGJsID1cbiAgbGV0IGNvbGwgfmtleTprIH5kYXRhOnYgYWNjID0gTGlzdCBbIHNleHBfb2Zfa2V5IGs7IHNleHBfb2ZfdmFsIHYgXSA6OiBhY2MgaW5cbiAgTGlzdCAoSGFzaHRibC5mb2xkIGh0YmwgfmluaXQ6W10gfmY6Y29sbClcbjs7XG5cbmxldCBzZXhwX29mX29wYXF1ZSBfID0gQXRvbSBcIjxvcGFxdWU+XCJcbmxldCBzZXhwX29mX2Z1biBfID0gQXRvbSBcIjxmdW4+XCJcblxuKCogRXhjZXB0aW9uIGNvbnZlcnRlciByZWdpc3RyYXRpb24gYW5kIGxvb2t1cCAqKVxuXG5tb2R1bGUgRXhuX2NvbnZlcnRlciA9IHN0cnVjdFxuICAoKiBUaGVzZSBleGNlcHRpb24gcmVnaXN0cmF0aW9uIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCBjb250ZXh0LXN3aXRjaGVzXG4gICAgIGNhbm5vdCBoYXBwZW4gdW5sZXNzIHRoZXJlIGlzIGFuIGFsbG9jYXRpb24uICBJdCBpcyByZWFzb25hYmxlIHRvIGV4cGVjdFxuICAgICB0aGF0IHRoaXMgd2lsbCByZW1haW4gdHJ1ZSBmb3IgdGhlIGZvcmVzZWVhYmxlIGZ1dHVyZS4gIFRoYXQgd2F5IHdlXG4gICAgIGF2b2lkIHVzaW5nIG11dGV4ZXMgYW5kIHRodXMgYSBkZXBlbmRlbmN5IG9uIHRoZSB0aHJlYWRzIGxpYnJhcnkuICopXG5cbiAgKCogRmFzdCBhbmQgYXV0b21hdGljIGV4Y2VwdGlvbiByZWdpc3RyYXRpb24gKilcblxuICBtb2R1bGUgUmVnaXN0cmF0aW9uID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHsgc2V4cF9vZl9leG4gOiBleG4gLT4gU2V4cC50XG4gICAgICA7ICgqIElmIFtwcmludGV4YyA9IHRydWVdIHRoZW4gdGhpcyBzZXhwIGNvbnZlcnRlciBpcyB1c2VkIGZvciBQcmludGV4Yy50b19zdHJpbmcgKilcbiAgICAgICAgcHJpbnRleGMgOiBib29sXG4gICAgICB9XG4gIGVuZFxuXG4gIG1vZHVsZSBFeG5fdGFibGUgPSBFcGhlbWVyb24uSzEuTWFrZSAoc3RydWN0XG4gICAgdHlwZSB0ID0gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXG5cbiAgICBsZXQgZXF1YWwgPSAoID09IClcbiAgICBsZXQgaGFzaCA9IE9iai5FeHRlbnNpb25fY29uc3RydWN0b3IuaWRcbiAgZW5kKVxuXG4gIGxldCB0aGVfZXhuX3RhYmxlIDogUmVnaXN0cmF0aW9uLnQgRXhuX3RhYmxlLnQgPSBFeG5fdGFibGUuY3JlYXRlIDE3XG5cbiAgKCogRXBoZW1lcm9ucyBhcmUgdXNlZCBzbyB0aGF0IFtzZXhwX29mX2V4bl0gY2xvc3VyZSBkb24ndCBrZWVwIHRoZVxuICAgICBleHRlbnNpb25fY29uc3RydWN0b3IgbGl2ZS4gKilcbiAgbGV0IGFkZCA/KHByaW50ZXhjID0gdHJ1ZSkgP2ZpbmFsaXNlOl8gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHNleHBfb2ZfZXhuID1cbiAgICBFeG5fdGFibGUuYWRkIHRoZV9leG5fdGFibGUgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHsgc2V4cF9vZl9leG47IHByaW50ZXhjIH1cbiAgOztcblxuICBsZXQgZmluZF9hdXRvIH5mb3JfcHJpbnRleGMgZXhuID1cbiAgICBsZXQgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yID0gT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWwgZXhuIGluXG4gICAgbWF0Y2ggRXhuX3RhYmxlLmZpbmRfb3B0IHRoZV9leG5fdGFibGUgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSB7IHNleHBfb2ZfZXhuOyBwcmludGV4YyB9IC0+XG4gICAgICAobWF0Y2ggZm9yX3ByaW50ZXhjLCBwcmludGV4YyB3aXRoXG4gICAgICAgfCBmYWxzZSwgXyB8IF8sIHRydWUgLT4gU29tZSAoc2V4cF9vZl9leG4gZXhuKVxuICAgICAgIHwgdHJ1ZSwgZmFsc2UgLT4gTm9uZSlcbiAgOztcblxuICBtb2R1bGUgRm9yX3VuaXRfdGVzdHNfb25seSA9IHN0cnVjdFxuICAgIGxldCBzaXplICgpID0gKEV4bl90YWJsZS5zdGF0c19hbGl2ZSB0aGVfZXhuX3RhYmxlKS5udW1fYmluZGluZ3NcbiAgZW5kXG5lbmRcblxubGV0IHNleHBfb2ZfZXhuX29wdF9mb3JfcHJpbnRleGMgZXhuID0gRXhuX2NvbnZlcnRlci5maW5kX2F1dG8gfmZvcl9wcmludGV4Yzp0cnVlIGV4blxubGV0IHNleHBfb2ZfZXhuX29wdCBleG4gPSBFeG5fY29udmVydGVyLmZpbmRfYXV0byB+Zm9yX3ByaW50ZXhjOmZhbHNlIGV4blxuXG5sZXQgc2V4cF9vZl9leG4gZXhuID1cbiAgbWF0Y2ggc2V4cF9vZl9leG5fb3B0IGV4biB3aXRoXG4gIHwgTm9uZSAtPiBMaXN0IFsgQXRvbSAoUHJpbnRleGMudG9fc3RyaW5nIGV4bikgXVxuICB8IFNvbWUgc2V4cCAtPiBzZXhwXG47O1xuXG5sZXQgZXhuX3RvX3N0cmluZyBlID0gU2V4cC50b19zdHJpbmdfaHVtIChzZXhwX29mX2V4biBlKVxuXG4oKiB7W2V4Y2VwdGlvbiBCbGFoIFtAQGRlcml2aW5nIHNleHBdXX0gZ2VuZXJhdGVzIGEgY2FsbCB0byB0aGUgZnVuY3Rpb25cbiAgIFtFeG5fY29udmVydGVyLmFkZF0gZGVmaW5lZCBpbiB0aGlzIGZpbGUuICBTbyB3ZSBhcmUgZ3VhcmFudGVkIHRoYXQgYXMgc29vbiBhcyB3ZVxuICAgbWFyayBhbiBleGNlcHRpb24gYXMgc2V4cGFibGUsIHRoaXMgbW9kdWxlIHdpbGwgYmUgbGlua2VkIGluIGFuZCB0aGlzIHByaW50ZXIgd2lsbCBiZVxuICAgcmVnaXN0ZXJlZCwgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LiAqKVxubGV0ICgpID1cbiAgUHJpbnRleGMucmVnaXN0ZXJfcHJpbnRlciAoZnVuIGV4biAtPlxuICAgIG1hdGNoIHNleHBfb2ZfZXhuX29wdF9mb3JfcHJpbnRleGMgZXhuIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBzZXhwIC0+IFNvbWUgKFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgc2V4cCkpXG47O1xuXG5sZXQgcHJpbnRleGNfcHJlZmVyX3NleHAgZXhuID1cbiAgbWF0Y2ggc2V4cF9vZl9leG5fb3B0IGV4biB3aXRoXG4gIHwgTm9uZSAtPiBQcmludGV4Yy50b19zdHJpbmcgZXhuXG4gIHwgU29tZSBzZXhwIC0+IFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgc2V4cFxuOztcblxuKCogQ29udmVyc2lvbiBvZiBTLWV4cHJlc3Npb25zIHRvIE9DYW1sLXZhbHVlcyAqKVxuXG5leGNlcHRpb24gT2Zfc2V4cF9lcnJvciA9IFNleHAuT2Zfc2V4cF9lcnJvclxuXG5sZXQgcmVjb3JkX2NoZWNrX2V4dHJhX2ZpZWxkcyA9IHJlZiB0cnVlXG5sZXQgb2Zfc2V4cF9lcnJvcl9leG4gZXhjIHNleHAgPSByYWlzZSAoT2Zfc2V4cF9lcnJvciAoZXhjLCBzZXhwKSlcbmxldCBvZl9zZXhwX2Vycm9yIHdoYXQgc2V4cCA9IHJhaXNlIChPZl9zZXhwX2Vycm9yIChGYWlsdXJlIHdoYXQsIHNleHApKVxuXG5sZXQgdW5pdF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFtdIC0+ICgpXG4gIHwgQXRvbSBfIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJ1bml0X29mX3NleHA6IGVtcHR5IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGJvb2xfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSAoXCJ0cnVlXCIgfCBcIlRydWVcIikgLT4gdHJ1ZVxuICB8IEF0b20gKFwiZmFsc2VcIiB8IFwiRmFsc2VcIikgLT4gZmFsc2VcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImJvb2xfb2Zfc2V4cDogdW5rbm93biBzdHJpbmdcIiBzZXhwXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJib29sX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IHN0cmluZ19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPiBzdHJcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcInN0cmluZ19vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBieXRlc19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPiBCeXRlcy5vZl9zdHJpbmcgc3RyXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJieXRlc19vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBjaGFyX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgaWYgU3RyaW5nLmxlbmd0aCBzdHIgPD4gMVxuICAgIHRoZW4gb2Zfc2V4cF9lcnJvciBcImNoYXJfb2Zfc2V4cDogYXRvbSBzdHJpbmcgbXVzdCBjb250YWluIG9uZSBjaGFyYWN0ZXIgb25seVwiIHNleHA7XG4gICAgc3RyLlswXVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiY2hhcl9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBpbnRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IGludF9vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJpbnRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImludF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBmbG9hdF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgZmxvYXRfb2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiZmxvYXRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImZsb2F0X29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGludDMyX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBJbnQzMi5vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJpbnQzMl9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiaW50MzJfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaW50NjRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IEludDY0Lm9mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcImludDY0X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJpbnQ2NF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBuYXRpdmVpbnRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IE5hdGl2ZWludC5vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJuYXRpdmVpbnRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcIm5hdGl2ZWludF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCByZWZfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPSByZWYgKGFfX29mX3NleHAgc2V4cClcbmxldCBsYXp5X3Rfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPSBMYXp5LmZyb21fdmFsIChhX19vZl9zZXhwIHNleHApXG5cbmxldCBvcHRpb25fb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPVxuICBpZiAhcmVhZF9vbGRfb3B0aW9uX2Zvcm1hdFxuICB0aGVuIChcbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IExpc3QgW10gfCBBdG9tIChcIm5vbmVcIiB8IFwiTm9uZVwiKSAtPiBOb25lXG4gICAgfCBMaXN0IFsgZWwgXSB8IExpc3QgWyBBdG9tIChcInNvbWVcIiB8IFwiU29tZVwiKTsgZWwgXSAtPiBTb21lIChhX19vZl9zZXhwIGVsKVxuICAgIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogbGlzdCBtdXN0IHJlcHJlc2VudCBvcHRpb25hbCB2YWx1ZVwiIHNleHBcbiAgICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwib3B0aW9uX29mX3NleHA6IG9ubHkgbm9uZSBjYW4gYmUgYXRvbVwiIHNleHApXG4gIGVsc2UgKFxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgQXRvbSAoXCJub25lXCIgfCBcIk5vbmVcIikgLT4gTm9uZVxuICAgIHwgTGlzdCBbIEF0b20gKFwic29tZVwiIHwgXCJTb21lXCIpOyBlbCBdIC0+IFNvbWUgKGFfX29mX3NleHAgZWwpXG4gICAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBvbmx5IG5vbmUgY2FuIGJlIGF0b21cIiBzZXhwXG4gICAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBsaXN0IG11c3QgYmUgKHNvbWUgZWwpXCIgc2V4cClcbjs7XG5cbmxldCBwYWlyX29mX3NleHAgYV9fb2Zfc2V4cCBiX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFsgYV9zZXhwOyBiX3NleHAgXSAtPlxuICAgIGxldCBhID0gYV9fb2Zfc2V4cCBhX3NleHAgaW5cbiAgICBsZXQgYiA9IGJfX29mX3NleHAgYl9zZXhwIGluXG4gICAgYSwgYlxuICB8IExpc3QgXyAtPlxuICAgIG9mX3NleHBfZXJyb3IgXCJwYWlyX29mX3NleHA6IGxpc3QgbXVzdCBjb250YWluIGV4YWN0bHkgdHdvIGVsZW1lbnRzIG9ubHlcIiBzZXhwXG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJwYWlyX29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IHRyaXBsZV9vZl9zZXhwIGFfX29mX3NleHAgYl9fb2Zfc2V4cCBjX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFsgYV9zZXhwOyBiX3NleHA7IGNfc2V4cCBdIC0+XG4gICAgbGV0IGEgPSBhX19vZl9zZXhwIGFfc2V4cCBpblxuICAgIGxldCBiID0gYl9fb2Zfc2V4cCBiX3NleHAgaW5cbiAgICBsZXQgYyA9IGNfX29mX3NleHAgY19zZXhwIGluXG4gICAgYSwgYiwgY1xuICB8IExpc3QgXyAtPlxuICAgIG9mX3NleHBfZXJyb3IgXCJ0cmlwbGVfb2Zfc2V4cDogbGlzdCBtdXN0IGNvbnRhaW4gZXhhY3RseSB0aHJlZSBlbGVtZW50cyBvbmx5XCIgc2V4cFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwidHJpcGxlX29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGxpc3Rfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IGxzdCAtPiBMaXN0Lm1hcCBsc3QgfmY6YV9fb2Zfc2V4cFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwibGlzdF9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBhcnJheV9vZl9zZXhwIGFfX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgW10gLT4gW3x8XVxuICB8IExpc3QgKGggOjogdCkgLT5cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggdCArIDEgaW5cbiAgICBsZXQgcmVzID0gQXJyYXkubWFrZSBsZW4gKGFfX29mX3NleHAgaCkgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJlc1xuICAgICAgfCBoIDo6IHQgLT5cbiAgICAgICAgcmVzLihpKSA8LSBhX19vZl9zZXhwIGg7XG4gICAgICAgIGxvb3AgKGkgKyAxKSB0XG4gICAgaW5cbiAgICBsb29wIDEgdFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiYXJyYXlfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaGFzaHRibF9vZl9zZXhwIGtleV9vZl9zZXhwIHZhbF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IGxzdCAtPlxuICAgIGxldCBodGJsID0gSGFzaHRibC5jcmVhdGUgMCBpblxuICAgIGxldCBhY3QgPSBmdW5jdGlvblxuICAgICAgfCBMaXN0IFsga19zZXhwOyB2X3NleHAgXSAtPlxuICAgICAgICBIYXNodGJsLmFkZCBodGJsIH5rZXk6KGtleV9vZl9zZXhwIGtfc2V4cCkgfmRhdGE6KHZhbF9vZl9zZXhwIHZfc2V4cClcbiAgICAgIHwgTGlzdCBfIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJoYXNodGJsX29mX3NleHA6IHR1cGxlIGxpc3QgbmVlZGVkXCIgc2V4cFxuICAgIGluXG4gICAgTGlzdC5pdGVyIGxzdCB+ZjphY3Q7XG4gICAgaHRibFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiaGFzaHRibF9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBvcGFxdWVfb2Zfc2V4cCBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciBcIm9wYXF1ZV9vZl9zZXhwOiBjYW5ub3QgY29udmVydCBvcGFxdWUgdmFsdWVzXCIgc2V4cFxuOztcblxubGV0IGZ1bl9vZl9zZXhwIHNleHAgPSBvZl9zZXhwX2Vycm9yIFwiZnVuX29mX3NleHA6IGNhbm5vdCBjb252ZXJ0IGZ1bmN0aW9uIHZhbHVlc1wiIHNleHBcblxuKCogU2V4cCBHcmFtbWFycyAqKVxuXG5pbmNsdWRlIFNleHBfY29udl9ncmFtbWFyXG5cbigqIFJlZ2lzdGVyaW5nIGRlZmF1bHQgZXhjZXB0aW9uIHByaW50ZXJzICopXG5cbmxldCBnZXRfZmxjX2Vycm9yIG5hbWUgKGZpbGUsIGxpbmUsIGNocikgPSBBdG9tIChzcHJpbnRmIFwiJXMgJXM6JWQ6JWRcIiBuYW1lIGZpbGUgbGluZSBjaHIpXG5cbmxldCAoKSA9XG4gIExpc3QuaXRlclxuICAgIH5mOihmdW4gKGV4dGVuc2lvbl9jb25zdHJ1Y3RvciwgaGFuZGxlcikgLT5cbiAgICAgIEV4bl9jb252ZXJ0ZXIuYWRkIH5wcmludGV4YzpmYWxzZSB+ZmluYWxpc2U6ZmFsc2UgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIGhhbmRsZXIpXG4gICAgWyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEFzc2VydF9mYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEFzc2VydF9mYWlsdXJlIGFyZyAtPiBnZXRfZmxjX2Vycm9yIFwiQXNzZXJ0X2ZhaWx1cmVcIiBhcmdcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEV4aXRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgRXhpdCAtPiBBdG9tIFwiRXhpdFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBFbmRfb2ZfZmlsZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBFbmRfb2ZfZmlsZSAtPiBBdG9tIFwiRW5kX29mX2ZpbGVcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgRmFpbHVyZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBGYWlsdXJlIGFyZyAtPiBMaXN0IFsgQXRvbSBcIkZhaWx1cmVcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgTm90X2ZvdW5kXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE5vdF9mb3VuZCAtPiBBdG9tIFwiTm90X2ZvdW5kXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEludmFsaWRfYXJndW1lbnRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgSW52YWxpZF9hcmd1bWVudCBhcmcgLT4gTGlzdCBbIEF0b20gXCJJbnZhbGlkX2FyZ3VtZW50XCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE1hdGNoX2ZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgTWF0Y2hfZmFpbHVyZSBhcmcgLT4gZ2V0X2ZsY19lcnJvciBcIk1hdGNoX2ZhaWx1cmVcIiBhcmdcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE5vdF9mb3VuZF9zXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE5vdF9mb3VuZF9zIGFyZyAtPiBMaXN0IFsgQXRvbSBcIk5vdF9mb3VuZF9zXCI7IGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTeXNfZXJyb3JdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU3lzX2Vycm9yIGFyZyAtPiBMaXN0IFsgQXRvbSBcIlN5c19lcnJvclwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBBcmcuSGVscF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBBcmcuSGVscCBhcmcgLT4gTGlzdCBbIEF0b20gXCJBcmcuSGVscFwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBBcmcuQmFkXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEFyZy5CYWQgYXJnIC0+IExpc3QgWyBBdG9tIFwiQXJnLkJhZFwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBMYXp5LlVuZGVmaW5lZF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBMYXp5LlVuZGVmaW5lZCAtPiBBdG9tIFwiTGF6eS5VbmRlZmluZWRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgUGFyc2luZy5QYXJzZV9lcnJvcl1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBQYXJzaW5nLlBhcnNlX2Vycm9yIC0+IEF0b20gXCJQYXJzaW5nLlBhcnNlX2Vycm9yXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFF1ZXVlLkVtcHR5XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFF1ZXVlLkVtcHR5IC0+IEF0b20gXCJRdWV1ZS5FbXB0eVwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTY2FuZi5TY2FuX2ZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU2NhbmYuU2Nhbl9mYWlsdXJlIGFyZyAtPiBMaXN0IFsgQXRvbSBcIlNjYW5mLlNjYW5fZmFpbHVyZVwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTdGFjay5FbXB0eV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBTdGFjay5FbXB0eSAtPiBBdG9tIFwiU3RhY2suRW1wdHlcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU3lzLkJyZWFrXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFN5cy5CcmVhayAtPiBBdG9tIFwiU3lzLkJyZWFrXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgXVxuOztcblxubGV0ICgpID1cbiAgTGlzdC5pdGVyXG4gICAgfmY6KGZ1biAoZXh0ZW5zaW9uX2NvbnN0cnVjdG9yLCBoYW5kbGVyKSAtPlxuICAgICAgRXhuX2NvbnZlcnRlci5hZGQgfnByaW50ZXhjOnRydWUgfmZpbmFsaXNlOmZhbHNlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBoYW5kbGVyKVxuICAgIFsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBPZl9zZXhwX2Vycm9yXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE9mX3NleHBfZXJyb3IgKGV4Yywgc2V4cCkgLT5cbiAgICAgICAgICBMaXN0IFsgQXRvbSBcIlNleHBsaWIuQ29udi5PZl9zZXhwX2Vycm9yXCI7IHNleHBfb2ZfZXhuIGV4Yzsgc2V4cCBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIF1cbjs7XG5cbmV4dGVybmFsIGlnbm9yZSA6IF8gLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG4iLCIoKiBDb252X2Vycm9yOiBNb2R1bGUgZm9yIEhhbmRsaW5nIEVycm9ycyBkdXJpbmcgQXV0b21hdGVkIFMtZXhwcmVzc2lvblxuICAgQ29udmVyc2lvbnMgKilcblxub3BlbiBTdGRMYWJlbHNcbm9wZW4gUHJpbnRmXG5vcGVuIFNleHBfY29udlxuXG5leGNlcHRpb24gT2Zfc2V4cF9lcnJvciA9IE9mX3NleHBfZXJyb3JcblxubGV0IGVycm9yIH5sb2MgfnNleHAgbXNnID0gb2Zfc2V4cF9lcnJvciAoc3ByaW50ZiBcIiVzX29mX3NleHA6ICVzXCIgbG9jIG1zZykgc2V4cFxubGV0IHNpbXBsZV9lcnJvciBtc2cgbG9jIHNleHAgPSBlcnJvciB+bG9jIH5zZXhwIG1zZ1xuXG4oKiBFcnJvcnMgY29uY2VybmluZyB0dXBsZXMgKilcblxubGV0IHR1cGxlX29mX3NpemVfbl9leHBlY3RlZCBsb2MgbiBzZXhwID1cbiAgZXJyb3IgfmxvYyB+c2V4cCAoc3ByaW50ZiBcInR1cGxlIG9mIHNpemUgJWQgZXhwZWN0ZWRcIiBuKVxuOztcblxubGV0IHR1cGxlX3BhaXJfZXhwZWN0ZWQgbG9jIG5hbWUgc2V4cCA9XG4gIGxldCBtc2cgPSBzcHJpbnRmIFwiJXNfb2Zfc2V4cDogZXhwZWN0ZWQgYSBwYWlyIGJlZ2lubmluZyB3aXRoIGxhYmVsICVzXCIgbG9jIG5hbWUgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHR1cGxlX2luY29ycmVjdF9sYWJlbCBsb2MgbmFtZSBwb3Mgc2V4cCA9XG4gIGxldCBtc2cgPVxuICAgIHNwcmludGYgXCIlc19vZl9zZXhwOiBpbmNvcnJlY3QgbGFiZWwgZm9yIGVsZW1lbnQgJXMgYXQgcG9zaXRpb24gJWlcIiBsb2MgbmFtZSBwb3NcbiAgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgc3VtIHR5cGVzICopXG5cbmxldCBzdGFnX25vX2FyZ3MgPSBzaW1wbGVfZXJyb3IgXCJ0aGlzIGNvbnN0cnVjdG9yIGRvZXMgbm90IHRha2UgYXJndW1lbnRzXCJcblxubGV0IHN0YWdfaW5jb3JyZWN0X25fYXJncyBsb2MgdGFnIHNleHAgPVxuICBlcnJvciB+bG9jIH5zZXhwIChzcHJpbnRmIFwic3VtIHRhZyAlUyBoYXMgaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHNcIiB0YWcpXG47O1xuXG5sZXQgc3RhZ190YWtlc19hcmdzID0gc2ltcGxlX2Vycm9yIFwidGhpcyBjb25zdHJ1Y3RvciByZXF1aXJlcyBhcmd1bWVudHNcIlxubGV0IG5lc3RlZF9saXN0X2ludmFsaWRfc3VtID0gc2ltcGxlX2Vycm9yIFwiZXhwZWN0ZWQgYSB2YXJpYW50IHR5cGUsIHNhdyBhIG5lc3RlZCBsaXN0XCJcbmxldCBlbXB0eV9saXN0X2ludmFsaWRfc3VtID0gc2ltcGxlX2Vycm9yIFwiZXhwZWN0ZWQgYSB2YXJpYW50IHR5cGUsIHNhdyBhbiBlbXB0eSBsaXN0XCJcbmxldCB1bmV4cGVjdGVkX3N0YWcgPSBzaW1wbGVfZXJyb3IgXCJ1bmV4cGVjdGVkIHZhcmlhbnQgY29uc3RydWN0b3JcIlxuXG4oKiBFcnJvcnMgY29uY2VybmluZyByZWNvcmRzICopXG5cbmxldCByZWNvcmRfc2V4cF9ib29sX3dpdGhfcGF5bG9hZCA9XG4gIHNpbXBsZV9lcnJvciBcInJlY29yZCBjb252ZXJzaW9uOiBhIFtzZXhwLmJvb2xdIGZpZWxkIHdhcyBnaXZlbiBhIHBheWxvYWQuXCJcbjs7XG5cbmxldCByZWNvcmRfb25seV9wYWlyc19leHBlY3RlZCA9XG4gIHNpbXBsZV9lcnJvclxuICAgIFwicmVjb3JkIGNvbnZlcnNpb246IG9ubHkgcGFpcnMgZXhwZWN0ZWQsIHRoZWlyIGZpcnN0IGVsZW1lbnQgbXVzdCBiZSBhbiBhdG9tXCJcbjs7XG5cbmxldCByZWNvcmRfaW52YWxpZF9maWVsZHMgfndoYXQgfmxvYyBmbGRfbmFtZXMgc2V4cCA9XG4gIGxldCBmbGRfbmFtZXNfc3RyID0gU3RyaW5nLmNvbmNhdCBmbGRfbmFtZXMgfnNlcDpcIiBcIiBpblxuICBlcnJvciB+bG9jIH5zZXhwIChzcHJpbnRmIFwiJXM6ICVzXCIgd2hhdCBmbGRfbmFtZXNfc3RyKVxuOztcblxubGV0IHJlY29yZF9kdXBsaWNhdGVfZmllbGRzIGxvYyBmbGRfbmFtZXMgc2V4cCA9XG4gIHJlY29yZF9pbnZhbGlkX2ZpZWxkcyB+d2hhdDpcImR1cGxpY2F0ZSBmaWVsZHNcIiB+bG9jIGZsZF9uYW1lcyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX2V4dHJhX2ZpZWxkcyBsb2MgZmxkX25hbWVzIHNleHAgPVxuICByZWNvcmRfaW52YWxpZF9maWVsZHMgfndoYXQ6XCJleHRyYSBmaWVsZHNcIiB+bG9jIGZsZF9uYW1lcyBzZXhwXG47O1xuXG5sZXQgcmVjIHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgZmllbGRzID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBTdHJpbmcuY29uY2F0IChMaXN0LnJldiBmaWVsZHMpIH5zZXA6XCIgXCJcbiAgfCAodHJ1ZSwgZmllbGQpIDo6IHJlc3QgLT4gcmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCAoZmllbGQgOjogZmllbGRzKSByZXN0XG4gIHwgXyA6OiByZXN0IC0+IHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgZmllbGRzIHJlc3Rcbjs7XG5cbmxldCByZWNvcmRfdW5kZWZpbmVkX2VsZW1lbnRzIGxvYyBzZXhwIGxzdCA9XG4gIGxldCB1bmRlZmluZWQgPSByZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIFtdIGxzdCBpblxuICBsZXQgbXNnID0gc3ByaW50ZiBcInRoZSBmb2xsb3dpbmcgcmVjb3JkIGVsZW1lbnRzIHdlcmUgdW5kZWZpbmVkOiAlc1wiIHVuZGVmaW5lZCBpblxuICBlcnJvciB+bG9jIH5zZXhwIG1zZ1xuOztcblxubGV0IHJlY29yZF9saXN0X2luc3RlYWRfYXRvbSA9IHNpbXBsZV9lcnJvciBcImxpc3QgaW5zdGVhZCBvZiBhdG9tIGZvciByZWNvcmQgZXhwZWN0ZWRcIlxuXG5sZXQgcmVjb3JkX3BvbHlfZmllbGRfdmFsdWUgPVxuICBzaW1wbGVfZXJyb3IgXCJjYW5ub3QgY29udmVydCB2YWx1ZXMgb2YgdHlwZXMgcmVzdWx0aW5nIGZyb20gcG9seW1vcnBoaWMgcmVjb3JkIGZpZWxkc1wiXG47O1xuXG4oKiBFcnJvcnMgY29uY2VybmluZyBwb2x5bW9ycGhpYyB2YXJpYW50cyAqKVxuXG5leGNlcHRpb24gTm9fdmFyaWFudF9tYXRjaFxuXG5sZXQgbm9fdmFyaWFudF9tYXRjaCAoKSA9IHJhaXNlIE5vX3ZhcmlhbnRfbWF0Y2hcbmxldCBub19tYXRjaGluZ192YXJpYW50X2ZvdW5kID0gc2ltcGxlX2Vycm9yIFwibm8gbWF0Y2hpbmcgdmFyaWFudCBmb3VuZFwiXG5sZXQgcHRhZ19ub19hcmdzID0gc2ltcGxlX2Vycm9yIFwicG9seW1vcnBoaWMgdmFyaWFudCBkb2VzIG5vdCB0YWtlIGFyZ3VtZW50c1wiXG5cbmxldCBwdGFnX2luY29ycmVjdF9uX2FyZ3MgbG9jIGNuc3RyIHNleHAgPVxuICBlcnJvclxuICAgIH5sb2NcbiAgICB+c2V4cFxuICAgIChzcHJpbnRmIFwicG9seW1vcnBoaWMgdmFyaWFudCB0YWcgJVMgaGFzIGluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzXCIgY25zdHIpXG47O1xuXG5sZXQgcHRhZ190YWtlc19hcmdzID0gc2ltcGxlX2Vycm9yIFwicG9seW1vcnBoaWMgdmFyaWFudCB0YWcgdGFrZXMgYW4gYXJndW1lbnRcIlxuXG5sZXQgbmVzdGVkX2xpc3RfaW52YWxpZF9wb2x5X3ZhciA9XG4gIHNpbXBsZV9lcnJvciBcImEgbmVzdGVkIGxpc3QgaXMgYW4gaW52YWxpZCBwb2x5bW9ycGhpYyB2YXJpYW50XCJcbjs7XG5cbmxldCBlbXB0eV9saXN0X2ludmFsaWRfcG9seV92YXIgPVxuICBzaW1wbGVfZXJyb3IgXCJ0aGUgZW1wdHkgbGlzdCBpcyBhbiBpbnZhbGlkIHBvbHltb3JwaGljIHZhcmlhbnRcIlxuOztcblxubGV0IGVtcHR5X3R5cGUgPSBzaW1wbGVfZXJyb3IgXCJ0cnlpbmcgdG8gY29udmVydCBhbiBlbXB0eSB0eXBlXCJcbiIsIm1vZHVsZSBGaWVsZHMgPSBzdHJ1Y3RcbiAgdHlwZSBfIHQgPVxuICAgIHwgRmllbGQgOlxuICAgICAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICAgICAgOyBjb252IDogU2V4cC50IC0+ICdhXG4gICAgICAgIDsgcmVzdCA6ICdiIHRcbiAgICAgICAgfVxuICAgICAgICAtPiAoJ2EgKiAnYikgdFxuICAgIHwgRW1wdHkgOiB1bml0IHRcblxuICBsZXQgcmVjIGxlbmd0aF9sb29wIDogdHlwZSBhLiBhIHQgLT4gaW50IC0+IGludCA9XG4gICAgZnVuIHQgYWNjIC0+XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2NcbiAgICB8IEZpZWxkIGZpZWxkIC0+IGxlbmd0aF9sb29wIGZpZWxkLnJlc3QgKGFjYyArIDEpXG4gIDs7XG5cbiAgbGV0IGxlbmd0aCB0ID0gbGVuZ3RoX2xvb3AgdCAwXG5lbmRcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgb2ZfbGlzdFxuICA6IHR5cGUgYS5cbiAgICBjYWxsZXI6c3RyaW5nXG4gICAgLT4gZmllbGRzOmEgRmllbGRzLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gb3JpZ2luYWxfc2V4cDpTZXhwLnRcbiAgICAtPiBwb3M6aW50XG4gICAgLT4gU2V4cC50IGxpc3RcbiAgICAtPiBhXG4gID1cbiAgZnVuIH5jYWxsZXIgfmZpZWxkcyB+bGVuIH5vcmlnaW5hbF9zZXhwIH5wb3MgbGlzdCAtPlxuICBtYXRjaCBmaWVsZHMgd2l0aFxuICB8IEVtcHR5IC0+XG4gICAgKG1hdGNoIGxpc3Qgd2l0aFxuICAgICB8IFtdIC0+ICgpXG4gICAgIHwgXyA6OiBfIC0+IFNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQgY2FsbGVyIGxlbiBvcmlnaW5hbF9zZXhwKVxuICB8IEZpZWxkIHsgbmFtZTsgY29udjsgcmVzdCB9IC0+XG4gICAgKG1hdGNoIGxpc3Qgd2l0aFxuICAgICB8IFtdIC0+IFNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQgY2FsbGVyIGxlbiBvcmlnaW5hbF9zZXhwXG4gICAgIHwgc2V4cCA6OiBsaXN0IC0+XG4gICAgICAgKG1hdGNoIHNleHAgd2l0aFxuICAgICAgICB8IExpc3QgWyBBdG9tIGF0b207IHNleHAgXSAtPlxuICAgICAgICAgIGlmIFN0cmluZy5lcXVhbCBhdG9tIG5hbWVcbiAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAoIGNvbnYgc2V4cFxuICAgICAgICAgICAgLCBvZl9saXN0IH5jYWxsZXIgfmZpZWxkczpyZXN0IH5sZW4gfm9yaWdpbmFsX3NleHAgfnBvczoocG9zICsgMSkgbGlzdCApXG4gICAgICAgICAgZWxzZSBTZXhwX2NvbnZfZXJyb3IudHVwbGVfaW5jb3JyZWN0X2xhYmVsIGNhbGxlciBuYW1lIHBvcyBvcmlnaW5hbF9zZXhwXG4gICAgICAgIHwgXyAtPiBTZXhwX2NvbnZfZXJyb3IudHVwbGVfcGFpcl9leHBlY3RlZCBjYWxsZXIgbmFtZSBzZXhwKSlcbjs7XG5cbmxldCBsYWJlbGVkX3R1cGxlX29mX3NleHAgfmNhbGxlciB+ZmllbGRzIH5jcmVhdGUgb3JpZ2luYWxfc2V4cCA9XG4gIGxldCBsZW4gPSBGaWVsZHMubGVuZ3RoIGZpZWxkcyBpblxuICBtYXRjaCAob3JpZ2luYWxfc2V4cCA6IFNleHAudCkgd2l0aFxuICB8IEF0b20gXyAtPiBTZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkIGNhbGxlciBsZW4gb3JpZ2luYWxfc2V4cFxuICB8IExpc3QgbGlzdCAtPiBjcmVhdGUgKG9mX2xpc3QgfmNhbGxlciB+ZmllbGRzIH5sZW4gfm9yaWdpbmFsX3NleHAgfnBvczowIGxpc3QpXG47O1xuIiwib3BlbiEgU3RkTGFiZWxzXG5vcGVuISBTZXhwX2NvbnZcbm9wZW4hIFNleHBfY29udl9lcnJvclxuXG5tb2R1bGUgS2luZCA9IHN0cnVjdFxuICB0eXBlIChfLCBfKSB0ID1cbiAgICB8IERlZmF1bHQgOiAodW5pdCAtPiAnYSkgLT4gKCdhLCBTZXhwLnQgLT4gJ2EpIHRcbiAgICB8IE9taXRfbmlsIDogKCdhLCBTZXhwLnQgLT4gJ2EpIHRcbiAgICB8IFJlcXVpcmVkIDogKCdhLCBTZXhwLnQgLT4gJ2EpIHRcbiAgICB8IFNleHBfYXJyYXkgOiAoJ2EgYXJyYXksIFNleHAudCAtPiAnYSkgdFxuICAgIHwgU2V4cF9ib29sIDogKGJvb2wsIHVuaXQpIHRcbiAgICB8IFNleHBfbGlzdCA6ICgnYSBsaXN0LCBTZXhwLnQgLT4gJ2EpIHRcbiAgICB8IFNleHBfb3B0aW9uIDogKCdhIG9wdGlvbiwgU2V4cC50IC0+ICdhKSB0XG5lbmRcblxubW9kdWxlIEZpZWxkcyA9IHN0cnVjdFxuICB0eXBlIF8gdCA9XG4gICAgfCBFbXB0eSA6IHVuaXQgdFxuICAgIHwgRmllbGQgOlxuICAgICAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICAgICAgOyBraW5kIDogKCdhLCAnY29udikgS2luZC50XG4gICAgICAgIDsgY29udiA6ICdjb252XG4gICAgICAgIDsgcmVzdCA6ICdiIHRcbiAgICAgICAgfVxuICAgICAgICAtPiAoJ2EgKiAnYikgdFxuXG4gIGxldCBsZW5ndGggPVxuICAgIGxldCByZWMgbGVuZ3RoX2xvb3AgOiB0eXBlIGEuIGEgdCAtPiBpbnQgLT4gaW50ID1cbiAgICAgIGZ1biB0IGFjYyAtPlxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEZpZWxkIHsgcmVzdDsgXyB9IC0+IGxlbmd0aF9sb29wIHJlc3QgKGFjYyArIDEpXG4gICAgICB8IEVtcHR5IC0+IGFjY1xuICAgIGluXG4gICAgZnVuIHQgLT4gbGVuZ3RoX2xvb3AgdCAwXG4gIDs7XG5lbmRcblxubW9kdWxlIE1hbGZvcm1lZCA9IHN0cnVjdFxuICAoKiBSZXByZXNlbnRzIGVycm9ycyB0aGF0IGNhbiBvY2N1ciBkdWUgdG8gbWFsZm9ybWVkIHJlY29yZCBzZXhwcy4gQWNjdW11bGF0ZWQgYXMgYVxuICAgICB2YWx1ZSBzbyB3ZSBjYW4gcmVwb3J0IG11bHRpcGxlIG5hbWVzIGF0IG9uY2UgZm9yIGV4dHJhIGZpZWxkcywgZHVwbGljYXRlIGZpZWxkcywgb3JcbiAgICAgbWlzc2luZyBmaWVsZHMuICopXG4gIHR5cGUgdCA9XG4gICAgfCBCb29sX3BheWxvYWRcbiAgICB8IEV4dHJhcyBvZiBzdHJpbmcgbGlzdFxuICAgIHwgRHVwcyBvZiBzdHJpbmcgbGlzdFxuICAgIHwgTWlzc2luZyBvZiBzdHJpbmcgbGlzdFxuICAgIHwgTm9uX3BhaXIgb2YgU2V4cC50IG9wdGlvblxuXG4gIGxldCBjb21iaW5lIGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgKCogY2hvb3NlIHRoZSBmaXJzdCBib29sLXBheWxvYWQgb3Igbm9uLXBhaXIgZXJyb3IgdGhhdCBvY2N1cnMgKilcbiAgICB8ICgoQm9vbF9wYXlsb2FkIHwgTm9uX3BhaXIgXykgYXMgdCksIF8gLT4gdFxuICAgIHwgXywgKChCb29sX3BheWxvYWQgfCBOb25fcGFpciBfKSBhcyB0KSAtPiB0XG4gICAgKCogY29tYmluZSBsaXN0cyBvZiBzaW1pbGFyIGVycm9ycyAqKVxuICAgIHwgRXh0cmFzIGEsIEV4dHJhcyBiIC0+IEV4dHJhcyAoYSBAIGIpXG4gICAgfCBEdXBzIGEsIER1cHMgYiAtPiBEdXBzIChhIEAgYilcbiAgICB8IE1pc3NpbmcgYSwgTWlzc2luZyBiIC0+IE1pc3NpbmcgKGEgQCBiKVxuICAgICgqIG90aGVyd2lzZSwgZHVwcyA+IGV4dHJhcyA+IG1pc3NpbmcgKilcbiAgICB8IChEdXBzIF8gYXMgdCksIF8gfCBfLCAoRHVwcyBfIGFzIHQpIC0+IHRcbiAgICB8IChFeHRyYXMgXyBhcyB0KSwgXyB8IF8sIChFeHRyYXMgXyBhcyB0KSAtPiB0XG4gIDs7XG5cbiAgbGV0IHJhaXNlIHQgfmNhbGxlciB+Y29udGV4dCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBCb29sX3BheWxvYWQgLT4gcmVjb3JkX3NleHBfYm9vbF93aXRoX3BheWxvYWQgY2FsbGVyIGNvbnRleHRcbiAgICB8IEV4dHJhcyBuYW1lcyAtPiByZWNvcmRfZXh0cmFfZmllbGRzIGNhbGxlciBuYW1lcyBjb250ZXh0XG4gICAgfCBEdXBzIG5hbWVzIC0+IHJlY29yZF9kdXBsaWNhdGVfZmllbGRzIGNhbGxlciBuYW1lcyBjb250ZXh0XG4gICAgfCBNaXNzaW5nIG5hbWVzIC0+XG4gICAgICBMaXN0Lm1hcCBuYW1lcyB+ZjooZnVuIG5hbWUgLT4gdHJ1ZSwgbmFtZSlcbiAgICAgIHw+IHJlY29yZF91bmRlZmluZWRfZWxlbWVudHMgY2FsbGVyIGNvbnRleHRcbiAgICB8IE5vbl9wYWlyIG1heWJlX2NvbnRleHQgLT5cbiAgICAgIGxldCBjb250ZXh0ID0gT3B0aW9uLnZhbHVlIG1heWJlX2NvbnRleHQgfmRlZmF1bHQ6Y29udGV4dCBpblxuICAgICAgcmVjb3JkX29ubHlfcGFpcnNfZXhwZWN0ZWQgY2FsbGVyIGNvbnRleHRcbiAgOztcbmVuZFxuXG5leGNlcHRpb24gTWFsZm9ybWVkIG9mIE1hbGZvcm1lZC50XG5cbm1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuICAoKiBTdG9yZXMgc2V4cHMgY29ycmVzcG9uZGluZyB0byByZWNvcmQgZmllbGRzLCBpbiB0aGUgb3JkZXIgdGhlIGZpZWxkcyB3ZXJlIGRlY2xhcmVkLlxuICAgICBFeGNsdWRlcyBmaWVsZHMgYWxyZWFkeSBwYXJzZWQgaW4gdGhlIGZhc3QgcGF0aC5cblxuICAgICBMaXN0IHNleHBzIHJlcHJlc2VudCBhIGZpZWxkIHRoYXQgaXMgcHJlc2VudCwgc3VjaCBhcyAoeCAxKSBmb3IgYSBmaWVsZCBuYW1lZCBcInhcIi5cbiAgICAgQXRvbSBzZXhwcyByZXByZXNlbnQgYSBmaWVsZCB0aGF0IGlzIGFic2VudCwgb3IgYXQgbGVhc3Qgbm90IHlldCBzZWVuLiAqKVxuICB0eXBlIHQgPSB7IHN0YXRlIDogU2V4cC50IGFycmF5IH0gW0BAdW5ib3hlZF1cblxuICBsZXQgdW5zYWZlX2dldCB0IHBvcyA9IEFycmF5LnVuc2FmZV9nZXQgdC5zdGF0ZSBwb3NcbiAgbGV0IHVuc2FmZV9zZXQgdCBwb3Mgc2V4cCA9IEFycmF5LnVuc2FmZV9zZXQgdC5zdGF0ZSBwb3Mgc2V4cFxuICBsZXQgYWJzZW50ID0gU2V4cC5BdG9tIFwiXCJcbiAgbGV0IGNyZWF0ZSBsZW4gPSB7IHN0YXRlID0gQXJyYXkubWFrZSBsZW4gYWJzZW50IH1cbmVuZFxuXG4oKiBQYXJzaW5nIGZpZWxkIHZhbHVlcyBmcm9tIHN0YXRlLiAqKVxuXG5sZXQgcmVjIHBhcnNlX3ZhbHVlX21hbGZvcm1lZFxuICA6IHR5cGUgYSBiLiBNYWxmb3JtZWQudCAtPiBmaWVsZHM6KGEgKiBiKSBGaWVsZHMudCAtPiBzdGF0ZTpTdGF0ZS50IC0+IHBvczppbnQgLT4gYVxuICA9XG4gIGZ1biBtYWxmb3JtZWQgfmZpZWxkcyB+c3RhdGUgfnBvcyAtPlxuICBsZXQgKEZpZWxkIGZpZWxkKSA9IGZpZWxkcyBpblxuICBsZXQgbWFsZm9ybWVkID1cbiAgICBtYXRjaCBwYXJzZV92YWx1ZXMgfmZpZWxkczpmaWVsZC5yZXN0IH5zdGF0ZSB+cG9zOihwb3MgKyAxKSB3aXRoXG4gICAgfCAoXyA6IGIpIC0+IG1hbGZvcm1lZFxuICAgIHwgZXhjZXB0aW9uIE1hbGZvcm1lZCBvdGhlciAtPiBNYWxmb3JtZWQuY29tYmluZSBtYWxmb3JtZWQgb3RoZXJcbiAgaW5cbiAgcmFpc2UgKE1hbGZvcm1lZCBtYWxmb3JtZWQpXG5cbmFuZCBwYXJzZV92YWx1ZSA6IHR5cGUgYSBiLiBmaWVsZHM6KGEgKiBiKSBGaWVsZHMudCAtPiBzdGF0ZTpTdGF0ZS50IC0+IHBvczppbnQgLT4gYSAqIGIgPVxuICBmdW4gfmZpZWxkcyB+c3RhdGUgfnBvcyAtPlxuICBsZXQgKEZpZWxkIHsgbmFtZTsga2luZDsgY29udjsgcmVzdCB9KSA9IGZpZWxkcyBpblxuICBsZXQgdmFsdWUgOiBhID1cbiAgICBtYXRjaCBraW5kLCBTdGF0ZS51bnNhZmVfZ2V0IHN0YXRlIHBvcyB3aXRoXG4gICAgKCogd2VsbC1mb3JtZWQgKilcbiAgICB8IFJlcXVpcmVkLCBMaXN0IFsgXzsgc2V4cCBdIC0+IGNvbnYgc2V4cFxuICAgIHwgRGVmYXVsdCBfLCBMaXN0IFsgXzsgc2V4cCBdIC0+IGNvbnYgc2V4cFxuICAgIHwgT21pdF9uaWwsIExpc3QgWyBfOyBzZXhwIF0gLT4gY29udiBzZXhwXG4gICAgfCBTZXhwX29wdGlvbiwgTGlzdCBbIF87IHNleHAgXSAtPiBTb21lIChjb252IHNleHApXG4gICAgfCBTZXhwX2xpc3QsIExpc3QgWyBfOyBzZXhwIF0gLT4gbGlzdF9vZl9zZXhwIGNvbnYgc2V4cFxuICAgIHwgU2V4cF9hcnJheSwgTGlzdCBbIF87IHNleHAgXSAtPiBhcnJheV9vZl9zZXhwIGNvbnYgc2V4cFxuICAgIHwgU2V4cF9ib29sLCBMaXN0IFsgXyBdIC0+IHRydWVcbiAgICAoKiBpbGwtZm9ybWVkICopXG4gICAgfCAoIChSZXF1aXJlZCB8IERlZmF1bHQgXyB8IE9taXRfbmlsIHwgU2V4cF9vcHRpb24gfCBTZXhwX2xpc3QgfCBTZXhwX2FycmF5KVxuICAgICAgLCAoTGlzdCAoXyA6OiBfIDo6IF8gOjogXykgYXMgc2V4cCkgKSAtPlxuICAgICAgcGFyc2VfdmFsdWVfbWFsZm9ybWVkIChOb25fcGFpciAoU29tZSBzZXhwKSkgfmZpZWxkcyB+c3RhdGUgfnBvc1xuICAgIHwgKCAoUmVxdWlyZWQgfCBEZWZhdWx0IF8gfCBPbWl0X25pbCB8IFNleHBfb3B0aW9uIHwgU2V4cF9saXN0IHwgU2V4cF9hcnJheSlcbiAgICAgICwgTGlzdCAoW10gfCBbIF8gXSkgKSAtPiBwYXJzZV92YWx1ZV9tYWxmb3JtZWQgKE5vbl9wYWlyIE5vbmUpIH5maWVsZHMgfnN0YXRlIH5wb3NcbiAgICB8IFNleHBfYm9vbCwgTGlzdCAoW10gfCBfIDo6IF8gOjogXykgLT5cbiAgICAgIHBhcnNlX3ZhbHVlX21hbGZvcm1lZCBCb29sX3BheWxvYWQgfmZpZWxkcyB+c3RhdGUgfnBvc1xuICAgICgqIGFic2VudCAqKVxuICAgIHwgUmVxdWlyZWQsIEF0b20gXyAtPiBwYXJzZV92YWx1ZV9tYWxmb3JtZWQgKE1pc3NpbmcgWyBuYW1lIF0pIH5maWVsZHMgfnN0YXRlIH5wb3NcbiAgICB8IERlZmF1bHQgZGVmYXVsdCwgQXRvbSBfIC0+IGRlZmF1bHQgKClcbiAgICB8IE9taXRfbmlsLCBBdG9tIF8gLT4gY29udiAoTGlzdCBbXSlcbiAgICB8IFNleHBfb3B0aW9uLCBBdG9tIF8gLT4gTm9uZVxuICAgIHwgU2V4cF9saXN0LCBBdG9tIF8gLT4gW11cbiAgICB8IFNleHBfYXJyYXksIEF0b20gXyAtPiBbfHxdXG4gICAgfCBTZXhwX2Jvb2wsIEF0b20gXyAtPiBmYWxzZVxuICBpblxuICB2YWx1ZSwgcGFyc2VfdmFsdWVzIH5maWVsZHM6cmVzdCB+c3RhdGUgfnBvczoocG9zICsgMSlcblxuYW5kIHBhcnNlX3ZhbHVlcyA6IHR5cGUgYS4gZmllbGRzOmEgRmllbGRzLnQgLT4gc3RhdGU6U3RhdGUudCAtPiBwb3M6aW50IC0+IGEgPVxuICBmdW4gfmZpZWxkcyB+c3RhdGUgfnBvcyAtPlxuICBtYXRjaCBmaWVsZHMgd2l0aFxuICB8IEZpZWxkIF8gLT4gcGFyc2VfdmFsdWUgfmZpZWxkcyB+c3RhdGUgfnBvc1xuICB8IEVtcHR5IC0+ICgpXG47O1xuXG4oKiBQb3B1bGF0aW5nIHN0YXRlLiBIYW5kbGVzIHNsb3cgcGF0aCBjYXNlcyB3aGVyZSB0aGVyZSBtYXkgYmUgcmVvcmRlcmVkLCBkdXBsaWNhdGVkLFxuICAgbWlzc2luZywgb3IgZXh0cmEgZmllbGRzLiAqKVxuXG5sZXQgcmVjIHBhcnNlX3NwaW5lX21hbGZvcm1lZCBtYWxmb3JtZWQgfmluZGV4IH5leHRyYSB+c2VlbiB+c3RhdGUgfmxlbiBzZXhwcyA9XG4gIGxldCBtYWxmb3JtZWQgPVxuICAgIG1hdGNoIHBhcnNlX3NwaW5lX3Nsb3cgfmluZGV4IH5leHRyYSB+c2VlbiB+c3RhdGUgfmxlbiBzZXhwcyB3aXRoXG4gICAgfCAoKSAtPiBtYWxmb3JtZWRcbiAgICB8IGV4Y2VwdGlvbiBNYWxmb3JtZWQgb3RoZXIgLT4gTWFsZm9ybWVkLmNvbWJpbmUgbWFsZm9ybWVkIG90aGVyXG4gIGluXG4gIHJhaXNlIChNYWxmb3JtZWQgbWFsZm9ybWVkKVxuXG5hbmQgcGFyc2Vfc3BpbmVfc2xvdyB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzID1cbiAgbWF0Y2ggKHNleHBzIDogU2V4cC50IGxpc3QpIHdpdGhcbiAgfCBbXSAtPiAoKVxuICB8IChMaXN0IChBdG9tIG5hbWUgOjogXykgYXMgZmllbGQpIDo6IHNleHBzIC0+XG4gICAgbGV0IGkgPSBpbmRleCBuYW1lIGluXG4gICAgKG1hdGNoIHNlZW4gPD0gaSAmJiBpIDwgbGVuIHdpdGhcbiAgICAgfCB0cnVlIC0+XG4gICAgICAgKCogdmFsaWQgZmllbGQgZm9yIHNsb3ctcGF0aCBwYXJzaW5nICopXG4gICAgICAgbGV0IHBvcyA9IGkgLSBzZWVuIGluXG4gICAgICAgKG1hdGNoIFN0YXRlLnVuc2FmZV9nZXQgc3RhdGUgcG9zIHdpdGhcbiAgICAgICAgfCBBdG9tIF8gLT5cbiAgICAgICAgICAoKiBmaWVsZCBub3Qgc2VlbiB5ZXQgKilcbiAgICAgICAgICBTdGF0ZS51bnNhZmVfc2V0IHN0YXRlIHBvcyBmaWVsZDtcbiAgICAgICAgICBwYXJzZV9zcGluZV9zbG93IH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHNcbiAgICAgICAgfCBMaXN0IF8gLT5cbiAgICAgICAgICAoKiBmaWVsZCBhbHJlYWR5IHNlZW4gKilcbiAgICAgICAgICBwYXJzZV9zcGluZV9tYWxmb3JtZWQgKER1cHMgWyBuYW1lIF0pIH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHMpXG4gICAgIHwgZmFsc2UgLT5cbiAgICAgICAobWF0Y2ggMCA8PSBpICYmIGkgPCBzZWVuIHdpdGhcbiAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgKCogZmllbGQgc2VlbiBpbiBmYXN0IHBhdGggKilcbiAgICAgICAgICBwYXJzZV9zcGluZV9tYWxmb3JtZWQgKER1cHMgWyBuYW1lIF0pIH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHNcbiAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgICgqIGV4dHJhIGZpZWxkICopXG4gICAgICAgICAgKG1hdGNoIGV4dHJhIHdpdGhcbiAgICAgICAgICAgfCB0cnVlIC0+IHBhcnNlX3NwaW5lX3Nsb3cgfmluZGV4IH5leHRyYSB+c2VlbiB+c3RhdGUgfmxlbiBzZXhwc1xuICAgICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgICAgcGFyc2Vfc3BpbmVfbWFsZm9ybWVkIChFeHRyYXMgWyBuYW1lIF0pIH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHMpKSlcbiAgfCBzZXhwIDo6IHNleHBzIC0+XG4gICAgcGFyc2Vfc3BpbmVfbWFsZm9ybWVkIChOb25fcGFpciAoU29tZSBzZXhwKSkgfmluZGV4IH5leHRyYSB+c2VlbiB+c3RhdGUgfmxlbiBzZXhwc1xuOztcblxuKCogU2xvdyBwYXRoIGZvciByZWNvcmQgcGFyc2luZy4gVXNlcyBzdGF0ZSB0byBzdG9yZSBmaWVsZHMgYXMgdGhleSBhcmUgZGlzY292ZXJlZC4gKilcblxubGV0IHBhcnNlX3JlY29yZF9zbG93IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwcyA9XG4gIGxldCB1bnNlZW4gPSBGaWVsZHMubGVuZ3RoIGZpZWxkcyBpblxuICBsZXQgc3RhdGUgPSBTdGF0ZS5jcmVhdGUgdW5zZWVuIGluXG4gIGxldCBsZW4gPSBzZWVuICsgdW5zZWVuIGluXG4gICgqIHBvcHVsYXRlIHN0YXRlICopXG4gIHBhcnNlX3NwaW5lX3Nsb3cgfmluZGV4IH5leHRyYSB+c2VlbiB+c3RhdGUgfmxlbiBzZXhwcztcbiAgKCogcGFyc2UgdmFsdWVzIGZyb20gc3RhdGUgKilcbiAgcGFyc2VfdmFsdWVzIH5maWVsZHMgfnN0YXRlIH5wb3M6MFxuOztcblxuKCogRmFzdCBwYXRoIGZvciByZWNvcmQgcGFyc2luZy4gRGlyZWN0bHkgcGFyc2VzIGFuZCByZXR1cm5zIGZpZWxkcyBpbiB0aGUgb3JkZXIgdGhleSBhcmVcbiAgIGRlY2xhcmVkLiBGYWxscyBiYWNrIG9uIHNsb3cgcGF0aCBpZiBhbnkgZmllbGRzIGFyZSBhYnNlbnQsIHJlb3JkZXJlZCwgb3IgbWFsZm9ybWVkLiAqKVxuXG5sZXQgcmVjIHBhcnNlX2ZpZWxkX2Zhc3RcbiAgOiB0eXBlIGEgYi5cbiAgICBmaWVsZHM6KGEgKiBiKSBGaWVsZHMudFxuICAgIC0+IGluZGV4OihzdHJpbmcgLT4gaW50KVxuICAgIC0+IGV4dHJhOmJvb2xcbiAgICAtPiBzZWVuOmludFxuICAgIC0+IFNleHAudCBsaXN0XG4gICAgLT4gYSAqIGJcbiAgPVxuICBmdW4gfmZpZWxkcyB+aW5kZXggfmV4dHJhIH5zZWVuIHNleHBzIC0+XG4gIGxldCAoRmllbGQgeyBuYW1lOyBraW5kOyBjb252OyByZXN0IH0pID0gZmllbGRzIGluXG4gIG1hdGNoIHNleHBzIHdpdGhcbiAgfCBMaXN0IChBdG9tIGF0b20gOjogYXJncykgOjogb3RoZXJzIHdoZW4gU3RyaW5nLmVxdWFsIGF0b20gbmFtZSAtPlxuICAgIChtYXRjaCBraW5kLCBhcmdzIHdpdGhcbiAgICAgfCBSZXF1aXJlZCwgWyBzZXhwIF0gLT5cbiAgICAgICBjb252IHNleHAsIHBhcnNlX3NwaW5lX2Zhc3QgfmZpZWxkczpyZXN0IH5pbmRleCB+ZXh0cmEgfnNlZW46KHNlZW4gKyAxKSBvdGhlcnNcbiAgICAgfCBEZWZhdWx0IF8sIFsgc2V4cCBdIC0+XG4gICAgICAgY29udiBzZXhwLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzXG4gICAgIHwgT21pdF9uaWwsIFsgc2V4cCBdIC0+XG4gICAgICAgY29udiBzZXhwLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzXG4gICAgIHwgU2V4cF9vcHRpb24sIFsgc2V4cCBdIC0+XG4gICAgICAgKCBTb21lIChjb252IHNleHApXG4gICAgICAgLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzIClcbiAgICAgfCBTZXhwX2xpc3QsIFsgc2V4cCBdIC0+XG4gICAgICAgKCBsaXN0X29mX3NleHAgY29udiBzZXhwXG4gICAgICAgLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzIClcbiAgICAgfCBTZXhwX2FycmF5LCBbIHNleHAgXSAtPlxuICAgICAgICggYXJyYXlfb2Zfc2V4cCBjb252IHNleHBcbiAgICAgICAsIHBhcnNlX3NwaW5lX2Zhc3QgfmZpZWxkczpyZXN0IH5pbmRleCB+ZXh0cmEgfnNlZW46KHNlZW4gKyAxKSBvdGhlcnMgKVxuICAgICB8IFNleHBfYm9vbCwgW10gLT5cbiAgICAgICB0cnVlLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzXG4gICAgICgqIG1hbGZvcm1lZCBmaWVsZCBvZiBzb21lIGtpbmQsIGRpc3BhdGNoIHRvIHNsb3cgcGF0aCAqKVxuICAgICB8IF8sIF8gLT4gcGFyc2VfcmVjb3JkX3Nsb3cgfmZpZWxkcyB+aW5kZXggfmV4dHJhIH5zZWVuIHNleHBzKVxuICAoKiBtYWxmb3JtZWQgb3Igb3V0LW9mLW9yZGVyIGZpZWxkLCBkaXNwYXRjaCB0byBzbG93IHBhdGggKilcbiAgfCBfIC0+IHBhcnNlX3JlY29yZF9zbG93IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwc1xuXG5hbmQgcGFyc2Vfc3BpbmVfZmFzdFxuICA6IHR5cGUgYS5cbiAgICBmaWVsZHM6YSBGaWVsZHMudFxuICAgIC0+IGluZGV4OihzdHJpbmcgLT4gaW50KVxuICAgIC0+IGV4dHJhOmJvb2xcbiAgICAtPiBzZWVuOmludFxuICAgIC0+IFNleHAudCBsaXN0XG4gICAgLT4gYVxuICA9XG4gIGZ1biB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW4gc2V4cHMgLT5cbiAgbWF0Y2ggZmllbGRzIHdpdGhcbiAgfCBGaWVsZCBfIC0+IHBhcnNlX2ZpZWxkX2Zhc3QgfmZpZWxkcyB+aW5kZXggfmV4dHJhIH5zZWVuIHNleHBzXG4gIHwgRW1wdHkgLT5cbiAgICAobWF0Y2ggc2V4cHMgd2l0aFxuICAgICB8IFtdIC0+ICgpXG4gICAgIHwgXyA6OiBfIC0+XG4gICAgICAgKCogZXh0cmEgc2V4cHMsIGRpc3BhdGNoIHRvIHNsb3cgcGF0aCAqKVxuICAgICAgIHBhcnNlX3JlY29yZF9zbG93IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwcylcbjs7XG5cbmxldCBwYXJzZV9yZWNvcmRfZmFzdCB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgc2V4cHMgPVxuICBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbjowIHNleHBzXG47O1xuXG4oKiBFbnRyeSBwb2ludHMuICopXG5cbmxldCByZWNvcmRfb2Zfc2V4cHNcbiAgfmNhbGxlclxuICB+Y29udGV4dFxuICB+ZmllbGRzXG4gIH5pbmRleF9vZl9maWVsZFxuICB+YWxsb3dfZXh0cmFfZmllbGRzXG4gIH5jcmVhdGVcbiAgc2V4cHNcbiAgPVxuICBsZXQgYWxsb3dfZXh0cmFfZmllbGRzID1cbiAgICBhbGxvd19leHRyYV9maWVsZHMgfHwgbm90ICFTZXhwX2NvbnYucmVjb3JkX2NoZWNrX2V4dHJhX2ZpZWxkc1xuICBpblxuICBtYXRjaFxuICAgIHBhcnNlX3JlY29yZF9mYXN0IH5maWVsZHMgfmluZGV4OmluZGV4X29mX2ZpZWxkIH5leHRyYTphbGxvd19leHRyYV9maWVsZHMgc2V4cHNcbiAgd2l0aFxuICB8IHZhbHVlIC0+IGNyZWF0ZSB2YWx1ZVxuICB8IGV4Y2VwdGlvbiBNYWxmb3JtZWQgbWFsZm9ybWVkIC0+IE1hbGZvcm1lZC5yYWlzZSBtYWxmb3JtZWQgfmNhbGxlciB+Y29udGV4dFxuOztcblxubGV0IHJlY29yZF9vZl9zZXhwIH5jYWxsZXIgfmZpZWxkcyB+aW5kZXhfb2ZfZmllbGQgfmFsbG93X2V4dHJhX2ZpZWxkcyB+Y3JlYXRlIHNleHAgPVxuICBtYXRjaCAoc2V4cCA6IFNleHAudCkgd2l0aFxuICB8IEF0b20gXyBhcyBjb250ZXh0IC0+IHJlY29yZF9saXN0X2luc3RlYWRfYXRvbSBjYWxsZXIgY29udGV4dFxuICB8IExpc3Qgc2V4cHMgYXMgY29udGV4dCAtPlxuICAgIHJlY29yZF9vZl9zZXhwc1xuICAgICAgfmNhbGxlclxuICAgICAgfmNvbnRleHRcbiAgICAgIH5maWVsZHNcbiAgICAgIH5pbmRleF9vZl9maWVsZFxuICAgICAgfmFsbG93X2V4dHJhX2ZpZWxkc1xuICAgICAgfmNyZWF0ZVxuICAgICAgc2V4cHNcbjs7XG4iXX0=
