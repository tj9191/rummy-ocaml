// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Base__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base = [0], Base$0 = [0, Base];
   runtime.caml_register_global(0, Base$0, "Base__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bool0
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Bool0 = [0];
   runtime.caml_register_global(0, Base_Bool0, "Base__Bool0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Globalize
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_dup = runtime.caml_obj_dup;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function globalize_bool(b){return b;}
   function globalize_char(c){return c;}
   function globalize_unit(u){return u;}
   function globalize_array(param, a){return a.slice();}
   function globalize_list(f, param){
    if(! param) return 0;
    var xs = param[2], x = param[1], _g_ = globalize_list(f, xs);
    return [0, caml_call1(f, x), _g_];
   }
   function globalize_option(f, param){
    if(! param) return 0;
    var x = param[1];
    return [0, caml_call1(f, x)];
   }
   function globalize_result(globalize_a, globalize_b, t){
    if(0 === t[0]){var a = t[1]; return [0, caml_call1(globalize_a, a)];}
    var b = t[1];
    return [1, caml_call1(globalize_b, b)];
   }
   function globalize_ref(param, r){return [0, r[1]];}
   function globalize_lazy_t(param, t){return t;}
   var
    _a_ = caml_obj_dup,
    _b_ = caml_obj_dup,
    _c_ = caml_obj_dup,
    _d_ = caml_obj_dup,
    _e_ = caml_obj_dup,
    Base_Globalize =
      [0,
       globalize_bool,
       globalize_char,
       caml_obj_dup,
       function(_f_){return _f_;},
       _e_,
       _d_,
       _c_,
       _b_,
       _a_,
       globalize_unit,
       globalize_array,
       globalize_lazy_t,
       globalize_list,
       globalize_option,
       globalize_result,
       globalize_ref];
   runtime.caml_register_global(0, Base_Globalize, "Base__Globalize");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Poly0
//# unitInfo: Requires: Base__Bool0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_compare = runtime.caml_compare;
   function descending(x, y){return caml_compare(y, x);}
   function max(x, y){
    return runtime.caml_csel_value(runtime.caml_greaterequal(x, y), x, y);
   }
   function min(x, y){
    return runtime.caml_csel_value(runtime.caml_lessequal(x, y), x, y);
   }
   var Base_Poly0 = [0, caml_compare, descending, min, max];
   runtime.caml_register_global(0, Base_Poly0, "Base__Poly0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import0
//# unitInfo: Requires: Base__Bool0, Base__Poly0, Shadow_stdlib, Stdlib, Stdlib__MoreLabels, Stdlib__StdLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_compare = runtime.caml_bytes_compare,
    caml_bytes_equal = runtime.caml_bytes_equal,
    caml_bytes_greaterequal = runtime.caml_bytes_greaterequal,
    caml_bytes_lessequal = runtime.caml_bytes_lessequal,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int_compare = runtime.caml_int_compare,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_notequal = runtime.caml_notequal,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_greaterequal = runtime.caml_string_greaterequal,
    caml_string_lessequal = runtime.caml_string_lessequal;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Poly0 = global_data.Base__Poly0,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Stdlib = global_data.Stdlib,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Exit = Shadow_stdlib[3],
    Not_found = Shadow_stdlib[4],
    max_int = Shadow_stdlib[8],
    min_int = Shadow_stdlib[9],
    infinity = Shadow_stdlib[11],
    neg_infinity = Shadow_stdlib[12],
    nan = Shadow_stdlib[13],
    max_float = Shadow_stdlib[14],
    min_float = Shadow_stdlib[15],
    epsilon_float = Shadow_stdlib[16],
    char_of_int = Shadow_stdlib[18],
    string_of_bool = Shadow_stdlib[19],
    bool_of_string_opt = Shadow_stdlib[20],
    bool_of_string = Shadow_stdlib[21],
    string_of_int = Shadow_stdlib[22],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_float = Shadow_stdlib[24],
    float_of_string_opt = Shadow_stdlib[25],
    stdin = Shadow_stdlib[27],
    stdout = Shadow_stdlib[28],
    stderr = Shadow_stdlib[29],
    print_char = Shadow_stdlib[30],
    print_string = Shadow_stdlib[31],
    print_bytes = Shadow_stdlib[32],
    print_int = Shadow_stdlib[33],
    print_float = Shadow_stdlib[34],
    print_endline = Shadow_stdlib[35],
    print_newline = Shadow_stdlib[36],
    prerr_char = Shadow_stdlib[37],
    prerr_string = Shadow_stdlib[38],
    prerr_bytes = Shadow_stdlib[39],
    prerr_int = Shadow_stdlib[40],
    prerr_float = Shadow_stdlib[41],
    prerr_endline = Shadow_stdlib[42],
    prerr_newline = Shadow_stdlib[43],
    read_line = Shadow_stdlib[44],
    read_int_opt = Shadow_stdlib[45],
    read_int = Shadow_stdlib[46],
    read_float_opt = Shadow_stdlib[47],
    read_float = Shadow_stdlib[48],
    open_out = Shadow_stdlib[49],
    open_out_bin = Shadow_stdlib[50],
    open_out_gen = Shadow_stdlib[51],
    flush = Shadow_stdlib[52],
    flush_all = Shadow_stdlib[53],
    output_char = Shadow_stdlib[54],
    output_string = Shadow_stdlib[55],
    output_bytes = Shadow_stdlib[56],
    output = Shadow_stdlib[57],
    output_substring = Shadow_stdlib[58],
    output_byte = Shadow_stdlib[59],
    output_binary_int = Shadow_stdlib[60],
    output_value = Shadow_stdlib[61],
    seek_out = Shadow_stdlib[62],
    pos_out = Shadow_stdlib[63],
    out_channel_length = Shadow_stdlib[64],
    close_out = Shadow_stdlib[65],
    close_out_noerr = Shadow_stdlib[66],
    set_binary_mode_out = Shadow_stdlib[67],
    open_in = Shadow_stdlib[68],
    open_in_bin = Shadow_stdlib[69],
    open_in_gen = Shadow_stdlib[70],
    input_char = Shadow_stdlib[71],
    input_line = Shadow_stdlib[72],
    input = Shadow_stdlib[73],
    really_input = Shadow_stdlib[74],
    really_input_string = Shadow_stdlib[75],
    input_byte = Shadow_stdlib[76],
    input_binary_int = Shadow_stdlib[77],
    input_value = Shadow_stdlib[78],
    seek_in = Shadow_stdlib[79],
    pos_in = Shadow_stdlib[80],
    in_channel_length = Shadow_stdlib[81],
    close_in = Shadow_stdlib[82],
    close_in_noerr = Shadow_stdlib[83],
    set_binary_mode_in = Shadow_stdlib[84],
    string_of_format = Shadow_stdlib[85],
    symbol = Shadow_stdlib[86],
    exit = Shadow_stdlib[87],
    at_exit = Shadow_stdlib[88],
    valid_float_lexem = Shadow_stdlib[89],
    unsafe_really_input = Shadow_stdlib[90],
    do_at_exit = Shadow_stdlib[91],
    do_domain_local_at_exit = Shadow_stdlib[92],
    invalid_arg = Stdlib[1],
    failwith = Stdlib[2],
    Exit$0 = Stdlib[3],
    Match_failure = Stdlib[4],
    Assert_failure = Stdlib[5],
    Invalid_argument = Stdlib[6],
    Failure = Stdlib[7],
    Not_found$0 = Stdlib[8],
    Out_of_memory = Stdlib[9],
    Stack_overflow = Stdlib[10],
    Sys_error = Stdlib[11],
    End_of_file = Stdlib[12],
    Division_by_zero = Stdlib[13],
    Sys_blocked_io = Stdlib[14],
    Undefined_recursive_module = Stdlib[15],
    min = Stdlib[16],
    max = Stdlib[17],
    abs = Stdlib[18],
    max_int$0 = Stdlib[19],
    min_int$0 = Stdlib[20],
    lnot = Stdlib[21],
    infinity$0 = Stdlib[22],
    neg_infinity$0 = Stdlib[23],
    nan$0 = Stdlib[24],
    max_float$0 = Stdlib[25],
    min_float$0 = Stdlib[26],
    epsilon_float$0 = Stdlib[27],
    symbol$0 = Stdlib[28],
    char_of_int$0 = Stdlib[29],
    string_of_bool$0 = Stdlib[30],
    bool_of_string_opt$0 = Stdlib[31],
    bool_of_string$0 = Stdlib[32],
    string_of_int$0 = Stdlib[33],
    int_of_string_opt$0 = Stdlib[34],
    string_of_float$0 = Stdlib[35],
    float_of_string_opt$0 = Stdlib[36],
    symbol$1 = Stdlib[37],
    stdin$0 = Stdlib[38],
    stdout$0 = Stdlib[39],
    stderr$0 = Stdlib[40],
    print_char$0 = Stdlib[41],
    print_string$0 = Stdlib[42],
    print_bytes$0 = Stdlib[43],
    print_int$0 = Stdlib[44],
    print_float$0 = Stdlib[45],
    print_endline$0 = Stdlib[46],
    print_newline$0 = Stdlib[47],
    prerr_char$0 = Stdlib[48],
    prerr_string$0 = Stdlib[49],
    prerr_bytes$0 = Stdlib[50],
    prerr_int$0 = Stdlib[51],
    prerr_float$0 = Stdlib[52],
    prerr_endline$0 = Stdlib[53],
    prerr_newline$0 = Stdlib[54],
    read_line$0 = Stdlib[55],
    read_int_opt$0 = Stdlib[56],
    read_int$0 = Stdlib[57],
    read_float_opt$0 = Stdlib[58],
    read_float$0 = Stdlib[59],
    open_out$0 = Stdlib[60],
    open_out_bin$0 = Stdlib[61],
    open_out_gen$0 = Stdlib[62],
    flush$0 = Stdlib[63],
    flush_all$0 = Stdlib[64],
    output_char$0 = Stdlib[65],
    output_string$0 = Stdlib[66],
    output_bytes$0 = Stdlib[67],
    output$0 = Stdlib[68],
    output_substring$0 = Stdlib[69],
    output_byte$0 = Stdlib[70],
    output_binary_int$0 = Stdlib[71],
    output_value$0 = Stdlib[72],
    seek_out$0 = Stdlib[73],
    pos_out$0 = Stdlib[74],
    out_channel_length$0 = Stdlib[75],
    close_out$0 = Stdlib[76],
    close_out_noerr$0 = Stdlib[77],
    set_binary_mode_out$0 = Stdlib[78],
    open_in$0 = Stdlib[79],
    open_in_bin$0 = Stdlib[80],
    open_in_gen$0 = Stdlib[81],
    input_char$0 = Stdlib[82],
    input_line$0 = Stdlib[83],
    input$0 = Stdlib[84],
    really_input$0 = Stdlib[85],
    really_input_string$0 = Stdlib[86],
    input_byte$0 = Stdlib[87],
    input_binary_int$0 = Stdlib[88],
    input_value$0 = Stdlib[89],
    seek_in$0 = Stdlib[90],
    pos_in$0 = Stdlib[91],
    in_channel_length$0 = Stdlib[92],
    close_in$0 = Stdlib[93],
    close_in_noerr$0 = Stdlib[94],
    set_binary_mode_in$0 = Stdlib[95],
    LargeFile = Stdlib[96],
    string_of_format$0 = Stdlib[97],
    symbol$2 = Stdlib[98],
    exit$0 = Stdlib[99],
    at_exit$0 = Stdlib[100],
    valid_float_lexem$0 = Stdlib[101],
    unsafe_really_input$0 = Stdlib[102],
    do_at_exit$0 = Stdlib[103],
    do_domain_local_at_exit$0 = Stdlib[104],
    Hashtbl = Stdlib_MoreLabels[1],
    Map = Stdlib_MoreLabels[2],
    Set = Stdlib_MoreLabels[3],
    Stdlib$0 =
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found$0,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int$0,
       min_int$0,
       lnot,
       infinity$0,
       neg_infinity$0,
       nan$0,
       max_float$0,
       min_float$0,
       epsilon_float$0,
       symbol$0,
       char_of_int$0,
       string_of_bool$0,
       bool_of_string_opt$0,
       bool_of_string$0,
       string_of_int$0,
       int_of_string_opt$0,
       string_of_float$0,
       float_of_string_opt$0,
       symbol$1,
       stdin$0,
       stdout$0,
       stderr$0,
       print_char$0,
       print_string$0,
       print_bytes$0,
       print_int$0,
       print_float$0,
       print_endline$0,
       print_newline$0,
       prerr_char$0,
       prerr_string$0,
       prerr_bytes$0,
       prerr_int$0,
       prerr_float$0,
       prerr_endline$0,
       prerr_newline$0,
       read_line$0,
       read_int_opt$0,
       read_int$0,
       read_float_opt$0,
       read_float$0,
       open_out$0,
       open_out_bin$0,
       open_out_gen$0,
       flush$0,
       flush_all$0,
       output_char$0,
       output_string$0,
       output_bytes$0,
       output$0,
       output_substring$0,
       output_byte$0,
       output_binary_int$0,
       output_value$0,
       seek_out$0,
       pos_out$0,
       out_channel_length$0,
       close_out$0,
       close_out_noerr$0,
       set_binary_mode_out$0,
       open_in$0,
       open_in_bin$0,
       open_in_gen$0,
       input_char$0,
       input_line$0,
       input$0,
       really_input$0,
       really_input_string$0,
       input_byte$0,
       input_binary_int$0,
       input_value$0,
       seek_in$0,
       pos_in$0,
       in_channel_length$0,
       close_in$0,
       close_in_noerr$0,
       set_binary_mode_in$0,
       LargeFile,
       string_of_format$0,
       symbol$2,
       exit$0,
       at_exit$0,
       valid_float_lexem$0,
       unsafe_really_input$0,
       do_at_exit$0,
       do_domain_local_at_exit$0,
       Hashtbl,
       Map,
       Set];
   function bool_to_int(x){return x;}
   function symbol$3(_F_, _E_){return _F_ !== _E_ ? 1 : 0;}
   var symbol$4 = runtime.caml_mul;
   function symbol$5(_D_, _C_){return Math.pow(_D_, _C_);}
   function symbol$6(_B_, _A_){return _B_ * _A_;}
   function symbol$7(_z_, _y_){return _z_ + _y_ | 0;}
   function symbol$8(_x_, _w_){return _x_ + _w_;}
   function symbol$9(_v_, _u_){return _v_ - _u_ | 0;}
   function symbol$10(_t_, _s_){return _t_ - _s_;}
   var symbol$11 = runtime.caml_div;
   function symbol$12(_r_, _q_){return _r_ / _q_;}
   var ascending = caml_int_compare;
   function descending(x, y){return caml_int_compare(y, x);}
   function max$0(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$0(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Int_replace_polymorphic_compar = [0, ascending, descending, max$0, min$0],
    ascending$0 = Int_replace_polymorphic_compar[1],
    descending$0 = Int_replace_polymorphic_compar[2],
    max$1 = Int_replace_polymorphic_compar[3],
    min$1 = Int_replace_polymorphic_compar[4],
    symbol$13 = caml_lessthan,
    symbol$14 = caml_lessequal,
    symbol$15 = caml_notequal,
    symbol$16 = caml_equal,
    symbol$17 = caml_greaterthan,
    symbol$18 = caml_greaterequal;
   function ascending$1(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$1(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var
    compare = caml_int_compare,
    compare_local = caml_int_compare,
    equal = caml_equal,
    equal_local = caml_equal;
   function max$2(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   function min$2(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   var
    Int32_replace_polymorphic_comp =
      [0,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       ascending$1,
       descending$1,
       compare,
       compare_local,
       equal,
       equal_local,
       max$2,
       min$2];
   function ascending$2(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$2(x, y){return caml_call2(Base_Poly0[2], x, y);}
   function max$3(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   function min$3(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   var
    Int64_replace_polymorphic_comp =
      [0, ascending$2, descending$2, max$3, min$3],
    symbol$19 = caml_lessthan,
    symbol$20 = caml_lessequal,
    symbol$21 = caml_notequal,
    symbol$22 = caml_equal,
    symbol$23 = caml_greaterthan,
    symbol$24 = caml_greaterequal;
   function ascending$3(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$3(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var
    compare$0 = caml_int_compare,
    compare_local$0 = caml_int_compare,
    equal$0 = caml_equal,
    equal_local$0 = caml_equal;
   function max$4(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   function min$4(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   var
    Nativeint_replace_polymorphic_ =
      [0,
       symbol$19,
       symbol$20,
       symbol$21,
       symbol$22,
       symbol$23,
       symbol$24,
       ascending$3,
       descending$3,
       compare$0,
       compare_local$0,
       equal$0,
       equal_local$0,
       max$4,
       min$4];
   function symbol$25(x, y){return x < y ? 1 : 0;}
   function symbol$26(x, y){return x <= y ? 1 : 0;}
   function symbol$27(x, y){return x !== y ? 1 : 0;}
   function symbol$28(x, y){return x === y ? 1 : 0;}
   function symbol$29(x, y){return y < x ? 1 : 0;}
   function symbol$30(x, y){return y <= x ? 1 : 0;}
   function ascending$4(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$4(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$1 = caml_int_compare, compare_local$1 = caml_int_compare;
   function equal$1(x, y){return x === y ? 1 : 0;}
   function equal_local$1(x, y){return x === y ? 1 : 0;}
   function max$5(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$5(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Bool_replace_polymorphic_compa =
      [0,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       symbol$30,
       ascending$4,
       descending$4,
       compare$1,
       compare_local$1,
       equal$1,
       equal_local$1,
       max$5,
       min$5];
   function symbol$31(x, y){return x < y ? 1 : 0;}
   function symbol$32(x, y){return x <= y ? 1 : 0;}
   function symbol$33(x, y){return x !== y ? 1 : 0;}
   function symbol$34(x, y){return x === y ? 1 : 0;}
   function symbol$35(x, y){return y < x ? 1 : 0;}
   function symbol$36(x, y){return y <= x ? 1 : 0;}
   function ascending$5(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$5(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$2 = caml_int_compare, compare_local$2 = caml_int_compare;
   function equal$2(x, y){return x === y ? 1 : 0;}
   function equal_local$2(x, y){return x === y ? 1 : 0;}
   function max$6(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$6(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Char_replace_polymorphic_compa =
      [0,
       symbol$31,
       symbol$32,
       symbol$33,
       symbol$34,
       symbol$35,
       symbol$36,
       ascending$5,
       descending$5,
       compare$2,
       compare_local$2,
       equal$2,
       equal_local$2,
       max$6,
       min$6];
   function symbol$37(x, y){return x < y ? 1 : 0;}
   function symbol$38(x, y){return x <= y ? 1 : 0;}
   function symbol$39(x, y){return x !== y ? 1 : 0;}
   function symbol$40(x, y){return x === y ? 1 : 0;}
   function symbol$41(x, y){return y < x ? 1 : 0;}
   function symbol$42(x, y){return y <= x ? 1 : 0;}
   function ascending$6(x, y){
    return caml_call2(Int_replace_polymorphic_compar[1], x, y);
   }
   function descending$6(x, y){
    return caml_call2(Int_replace_polymorphic_compar[2], x, y);
   }
   var compare$3 = caml_int_compare;
   function equal$3(x, y){return x === y ? 1 : 0;}
   var compare_local$3 = caml_int_compare;
   function equal_local$3(x, y){return x === y ? 1 : 0;}
   function max$7(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$7(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Uchar_replace_polymorphic_comp =
      [0,
       symbol$37,
       symbol$38,
       symbol$39,
       symbol$40,
       symbol$41,
       symbol$42,
       ascending$6,
       descending$6,
       compare$3,
       equal$3,
       compare_local$3,
       equal_local$3,
       max$7,
       min$7];
   function ascending$7(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$7(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare_local$4 = runtime.caml_float_compare;
   function equal_local$4(x, y){return x == y ? 1 : 0;}
   function max$8(x, y){return runtime.caml_csel_value(y <= x ? 1 : 0, x, y);}
   function min$8(x, y){return runtime.caml_csel_value(x <= y ? 1 : 0, x, y);}
   var
    Float_replace_polymorphic_comp =
      [0,
       ascending$7,
       descending$7,
       compare_local$4,
       equal_local$4,
       max$8,
       min$8],
    symbol$43 = runtime.caml_string_lessthan,
    symbol$44 = caml_string_lessequal,
    symbol$45 = runtime.caml_string_notequal,
    symbol$46 = caml_string_equal,
    symbol$47 = runtime.caml_string_greaterthan,
    symbol$48 = caml_string_greaterequal;
   function ascending$8(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$8(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var
    compare$4 = caml_string_compare,
    compare_local$5 = caml_string_compare,
    equal$4 = caml_string_equal,
    equal_local$5 = caml_string_equal;
   function max$9(x, y){
    return runtime.caml_csel_value(caml_string_greaterequal(x, y), x, y);
   }
   function min$9(x, y){
    return runtime.caml_csel_value(caml_string_lessequal(x, y), x, y);
   }
   var
    String_replace_polymorphic_com =
      [0,
       symbol$43,
       symbol$44,
       symbol$45,
       symbol$46,
       symbol$47,
       symbol$48,
       ascending$8,
       descending$8,
       compare$4,
       compare_local$5,
       equal$4,
       equal_local$5,
       max$9,
       min$9],
    symbol$49 = runtime.caml_bytes_lessthan,
    symbol$50 = caml_bytes_lessequal,
    symbol$51 = runtime.caml_bytes_notequal,
    symbol$52 = caml_bytes_equal,
    symbol$53 = runtime.caml_bytes_greaterthan,
    symbol$54 = caml_bytes_greaterequal;
   function ascending$9(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$9(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var
    compare$5 = caml_bytes_compare,
    compare_local$6 = caml_bytes_compare,
    equal$5 = caml_bytes_equal,
    equal_local$6 = caml_bytes_equal;
   function max$10(x, y){
    return runtime.caml_csel_value(caml_bytes_greaterequal(x, y), x, y);
   }
   function min$10(x, y){
    return runtime.caml_csel_value(caml_bytes_lessequal(x, y), x, y);
   }
   var
    Bytes_replace_polymorphic_comp =
      [0,
       symbol$49,
       symbol$50,
       symbol$51,
       symbol$52,
       symbol$53,
       symbol$54,
       ascending$9,
       descending$9,
       compare$5,
       compare_local$6,
       equal$5,
       equal_local$6,
       max$10,
       min$10],
    symbol$55 = Stdlib$0[37],
    symbol$56 = Stdlib$0[28];
   function symbol$57(_p_){return - _p_ | 0;}
   function symbol$58(_o_){return - _o_;}
   function asr(_n_, _m_){return _n_ >> _m_;}
   function land(_l_, _k_){return _l_ & _k_;}
   var lnot$0 = Stdlib$0[21];
   function lor(_j_, _i_){return _j_ | _i_;}
   function lsl(_h_, _g_){return _h_ << _g_;}
   function lsr(_f_, _e_){return _f_ >>> _e_ | 0;}
   function lxor(_d_, _c_){return _d_ ^ _c_;}
   var mod = runtime.caml_mod, abs$0 = Stdlib$0[18], failwith$0 = Stdlib$0[2];
   function fst(_b_){return _b_[1];}
   var invalid_arg$0 = Stdlib$0[1];
   function snd(_a_){return _a_[2];}
   var
    float_of_string = runtime.caml_float_of_string,
    am_testing = runtime.Base_am_testing(0),
    Base_Import0 =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Stdlib$0,
       bool_to_int,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       Int_replace_polymorphic_compar,
       ascending$0,
       descending$0,
       max$1,
       min$1,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$55,
       symbol$56,
       symbol$57,
       symbol$58,
       asr,
       land,
       lnot$0,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs$0,
       failwith$0,
       fst,
       invalid_arg$0,
       snd,
       float_of_string,
       am_testing];
   runtime.caml_register_global(4, Base_Import0, "Base__Import0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int0
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    to_string = Stdlib[33],
    of_string = runtime.caml_int_of_string,
    of_string_opt = Stdlib[34];
   function to_float(_d_){return _d_;}
   function of_float(_c_){return _c_ | 0;}
   var max_value = Stdlib[19], min_value = Stdlib[20];
   function succ(_b_){return _b_ + 1 | 0;}
   function pred(_a_){return _a_ - 1 | 0;}
   var
    Base_Int0 =
      [0,
       to_string,
       of_string,
       of_string_opt,
       to_float,
       of_float,
       max_value,
       min_value,
       succ,
       pred];
   runtime.caml_register_global(1, Base_Int0, "Base__Int0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Printf
//# unitInfo: Requires: Base__Import0, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Stdlib_Printf = global_data.Stdlib__Printf,
    sprintf = Stdlib_Printf[4],
    bprintf = Stdlib_Printf[5],
    ifprintf = Stdlib_Printf[6],
    ksprintf = Stdlib_Printf[10],
    kbprintf = Stdlib_Printf[11];
   function failwithf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[124], s);},
             fmt);
   }
   function invalid_argf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[126], s);},
             fmt);
   }
   var
    Base_Printf =
      [0,
       ifprintf,
       sprintf,
       bprintf,
       ksprintf,
       kbprintf,
       failwithf,
       invalid_argf];
   runtime.caml_register_global(2, Base_Printf, "Base__Printf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys0
//# unitInfo: Requires: Base__Import0, Base__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Sys = global_data.Stdlib__Sys,
    backend_type = Stdlib_Sys[5],
    interactive = Stdlib_Sys[3],
    os_type = Stdlib_Sys[4],
    unix = Stdlib_Sys[6],
    win32 = Stdlib_Sys[7],
    cygwin = Stdlib_Sys[8],
    word_size_in_bits = Stdlib_Sys[9],
    int_size_in_bits = Stdlib_Sys[10],
    big_endian = Stdlib_Sys[11],
    max_string_length = Stdlib_Sys[12],
    max_array_length = Stdlib_Sys[13],
    runtime_variant = runtime.caml_runtime_variant,
    runtime_parameters = runtime.caml_runtime_parameters,
    argv = caml_sys_argv(0),
    _a_ =
      [0,
       [11,
        "Sys.getenv_exn: environment variable ",
        [2, 0, [11, " is not set", 0]]],
       "Sys.getenv_exn: environment variable %s is not set"];
   function get_argv(param){return caml_sys_argv(0);}
   var
    ocaml_version = Stdlib_Sys[46],
    enable_runtime_warnings = Stdlib_Sys[49],
    runtime_warnings_enabled = Stdlib_Sys[50];
   function Make_immediate64(_h_, _g_){
    return caml_call1(caml_call1(Stdlib_Sys[51][1], _h_), _g_);
   }
   function getenv_exn(var$0){
    try{var _e_ = caml_sys_getenv(var$0); return _e_;}
    catch(_f_){
     var _d_ = caml_wrap_exception(_f_);
     if(_d_ === Base_Import0[85][8])
      return caml_call3(Base_Printf[6], _a_, var$0, 0);
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function getenv(var$0){
    try{var x = caml_sys_getenv(var$0);}
    catch(_c_){
     var _b_ = caml_wrap_exception(_c_);
     if(_b_ === Base_Import0[85][8]) return 0;
     throw caml_maybe_attach_backtrace(_b_, 0);
    }
    return [0, x];
   }
   var
    Break = Stdlib_Sys[44],
    Base_Sys0 =
      [0,
       backend_type,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       argv,
       get_argv,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       Make_immediate64,
       getenv_exn,
       getenv,
       Break];
   runtime.caml_register_global(4, Base_Sys0, "Base__Sys0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array0
//# unitInfo: Requires: Base__Import0, Base__Int0, Base__Printf, Base__Sys0, Stdlib, Stdlib__ArrayLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_ArrayLabels = global_data.Stdlib__ArrayLabels,
    Base_Import0 = global_data.Base__Import0,
    Base_Int0 = global_data.Base__Int0;
   global_data.Stdlib;
   var
    Base_Printf = global_data.Base__Printf,
    Base_Sys0 = global_data.Base__Sys0,
    invalid_argf = Base_Printf[7],
    Array = [0],
    max_length = Base_Sys0[11],
    cst_Array_init = "Array.init";
   function create(len, x){return caml_make_vect(len, x);}
   function create_local(len, x){return caml_make_vect(len, x);}
   function create_float_uninitialized(len){
    return runtime.caml_make_float_vect(len);
   }
   var
    append = Stdlib_ArrayLabels[3],
    blit = Stdlib_ArrayLabels[8],
    concat = Stdlib_ArrayLabels[4],
    copy = Stdlib_ArrayLabels[6],
    fill = Stdlib_ArrayLabels[7];
   function init(len, f){
    if(0 === len) return [0];
    if(0 > len) return caml_call1(Base_Import0[126], cst_Array_init);
    var
     res = caml_make_vect(len, caml_call1(f, 0)),
     _s_ = caml_call1(Base_Int0[9], len),
     _r_ = 1;
    if(_s_ >= 1){
     var i = _r_;
     for(;;){
      res[1 + i] = caml_call1(f, i);
      var _t_ = i + 1 | 0;
      if(_s_ === i) break;
      var i = _t_;
     }
    }
    return res;
   }
   var
    make_matrix = Stdlib_ArrayLabels[2],
    of_list = Stdlib_ArrayLabels[10],
    sub = Stdlib_ArrayLabels[5],
    to_list = Stdlib_ArrayLabels[9];
   function fold(t, init, f){
    var
     r = [0, init],
     _p_ = caml_call2(Base_Import0[93], t.length - 1, 1),
     _o_ = 0;
    if(_p_ >= 0){
     var i = _o_;
     for(;;){
      r[1] = caml_call2(f, r[1], t[1 + i]);
      var _q_ = i + 1 | 0;
      if(_p_ === i) break;
      var i = _q_;
     }
    }
    return r[1];
   }
   function fold_right(t, f, init){
    var r = [0, init], _m_ = caml_call2(Base_Import0[93], t.length - 1, 1);
    if(_m_ >= 0){
     var i = _m_;
     for(;;){
      r[1] = caml_call2(f, t[1 + i], r[1]);
      var _n_ = i - 1 | 0;
      if(0 === i) break;
      var i = _n_;
     }
    }
    return r[1];
   }
   function iter(t, f){
    var _k_ = caml_call2(Base_Import0[93], t.length - 1, 1), _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      caml_call1(f, t[1 + i]);
      var _l_ = i + 1 | 0;
      if(_k_ === i) break;
      var i = _l_;
     }
    }
    return 0;
   }
   function iteri(t, f){
    var _h_ = caml_call2(Base_Import0[93], t.length - 1, 1), _g_ = 0;
    if(_h_ >= 0){
     var i = _g_;
     for(;;){
      caml_call2(f, i, t[1 + i]);
      var _i_ = i + 1 | 0;
      if(_h_ === i) break;
      var i = _i_;
     }
    }
    return 0;
   }
   function map(t, f){
    var len = t.length - 1;
    if(0 === len) return [0];
    var
     r = caml_make_vect(len, caml_call1(f, t[1])),
     _e_ = caml_call2(Base_Import0[93], len, 1),
     _d_ = 1;
    if(_e_ >= 1){
     var i = _d_;
     for(;;){
      r[1 + i] = caml_call1(f, t[1 + i]);
      var _f_ = i + 1 | 0;
      if(_e_ === i) break;
      var i = _f_;
     }
    }
    return r;
   }
   function mapi(t, f){
    var len = t.length - 1;
    if(0 === len) return [0];
    var
     r = caml_make_vect(len, caml_call2(f, 0, t[1])),
     _b_ = caml_call2(Base_Import0[93], len, 1),
     _a_ = 1;
    if(_b_ >= 1){
     var i = _a_;
     for(;;){
      r[1 + i] = caml_call2(f, i, t[1 + i]);
      var _c_ = i + 1 | 0;
      if(_b_ === i) break;
      var i = _c_;
     }
    }
    return r;
   }
   function stable_sort(t, compare){
    return caml_call2(Stdlib_ArrayLabels[35], compare, t);
   }
   function swap(t, i, j){
    var
     elt_i = caml_check_bound(t, i)[1 + i],
     elt_j = caml_check_bound(t, j)[1 + j];
    t[1 + i] = elt_j;
    t[1 + j] = elt_i;
    return 0;
   }
   var
    Base_Array0 =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_local,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap];
   runtime.caml_register_global(10, Base_Array0, "Base__Array0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char0
//# unitInfo: Requires: Base__Printf, Stdlib__Char
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Printf = global_data.Base__Printf,
    Stdlib_Char = global_data.Stdlib__Char,
    failwithf = Base_Printf[6],
    escaped = Stdlib_Char[2],
    lowercase = Stdlib_Char[3],
    _a_ =
      [0,
       [11, "Char.of_int_exn got integer out of range: ", [4, 0, 0, 0, 0]],
       "Char.of_int_exn got integer out of range: %d"];
   function to_int(_e_){return _e_;}
   function unsafe_of_int(_d_){return _d_;}
   var uppercase = Stdlib_Char[4];
   function int_is_ok(i){
    var _b_ = 0 <= i ? 1 : 0, _c_ = _b_ ? i <= 255 ? 1 : 0 : _b_;
    return _c_;
   }
   var min_value = 0, max_value = 255;
   function of_int(i){return int_is_ok(i) ? [0, i] : 0;}
   function of_int_exn(i){
    return int_is_ok(i) ? i : caml_call3(failwithf, _a_, i, 0);
   }
   function equal(t1, t2){return t1 === t2 ? 1 : 0;}
   var
    Base_Char0 =
      [0,
       failwithf,
       escaped,
       lowercase,
       to_int,
       unsafe_of_int,
       uppercase,
       int_is_ok,
       min_value,
       max_value,
       of_int,
       of_int_exn,
       equal];
   runtime.caml_register_global(3, Base_Char0, "Base__Char0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_intf = [0];
   runtime.caml_register_global(0, Base_Hash_intf, "Base__Hash_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List0
//# unitInfo: Requires: Base__Import0, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    hd_exn = Stdlib_ListLabels[6],
    rev_append = Stdlib_ListLabels[13],
    tl_exn = Stdlib_ListLabels[7],
    unzip = Stdlib_ListLabels[57],
    cst_List_exists2 = "List.exists2",
    cst_List_fold_left2 = "List.fold_left2",
    cst_List_for_all2 = "List.for_all2",
    cst_List_iter2 = "List.iter2",
    cst_List_rev_map2 = "List.rev_map2";
   function length(l$0){
    var len = 0, param = l$0;
    for(;;){
     if(! param) return len;
     var
      l = param[2],
      len$0 = caml_call2(Base_Import0[91], len, 1),
      len = len$0,
      param = l;
    }
   }
   function exists(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var xs = t$0[2], x = t$0[1];
     if(caml_call1(f, x)) return 1;
     var t$0 = xs;
    }
   }
   function exists2_ok(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _e_ = caml_call2(f, a1, a2);
       if(_e_) return _e_;
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Base_Import0[126], cst_List_exists2);
    }
   }
   function fold(t, init, f){
    var t$0 = t, init$0 = init;
    for(;;){
     if(! t$0) return init$0;
     var
      l = t$0[2],
      a = t$0[1],
      init$1 = caml_call2(f, init$0, a),
      t$0 = l,
      init$0 = init$1;
    }
   }
   function fold2_ok(l1, l2, init, f){
    var l1$0 = l1, l2$0 = l2, init$0 = init;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        init$1 = caml_call3(f, init$0, a1, a2),
        l1$0 = l1$1,
        l2$0 = l2$1,
        init$0 = init$1;
       continue;
      }
     }
     else if(! l2$0) return init$0;
     return caml_call1(Base_Import0[126], cst_List_fold_left2);
    }
   }
   function for_all(t, f){
    return 1 - exists(t, function(x){return 1 - caml_call1(f, x);});
   }
   function for_all2_ok(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        l2$1 = l2$0[2],
        a2 = l2$0[1],
        l1$1 = l1$0[2],
        a1 = l1$0[1],
        _d_ = caml_call2(f, a1, a2);
       if(! _d_) return _d_;
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return caml_call1(Base_Import0[126], cst_List_for_all2);
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], a = t$0[1];
     caml_call1(f, a);
     var t$0 = l;
    }
   }
   function iter2_ok(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1];
       caml_call2(f, a1, a2);
       var l1$0 = l1$1, l2$0 = l2$1;
       continue;
      }
     }
     else if(! l2$0) return 0;
     return caml_call1(Base_Import0[126], cst_List_iter2);
    }
   }
   function nontail_map(t, f){
    if(! t) return 0;
    var xs = t[2], x = t[1], y = caml_call1(f, x);
    return [0, y, nontail_map(xs, f)];
   }
   function nontail_mapi(t, f){
    return caml_call2(Stdlib_ListLabels[21], f, t);
   }
   function partition(t, f){return caml_call2(Stdlib_ListLabels[47], f, t);}
   function rev_map(l$0, f){
    var accu = 0, param = l$0;
    for(;;){
     if(! param) return accu;
     var
      l = param[2],
      a = param[1],
      accu$0 = [0, caml_call1(f, a), accu],
      accu = accu$0,
      param = l;
    }
   }
   function rev_map2_ok(l1$1, l2$1, f){
    var accu = 0, l1 = l1$1, l2 = l2$1;
    for(;;){
     if(l1){
      if(l2){
       var
        l2$0 = l2[2],
        a2 = l2[1],
        l1$0 = l1[2],
        a1 = l1[1],
        accu$0 = [0, caml_call2(f, a1, a2), accu],
        accu = accu$0,
        l1 = l1$0,
        l2 = l2$0;
       continue;
      }
     }
     else if(! l2) return accu;
     return caml_call1(Base_Import0[126], cst_List_rev_map2);
    }
   }
   function rev(res){
    if(res){
     var match = res[2];
     if(match){
      var rest = match[2], y = match[1], x = res[1];
      return caml_call2(rev_append, rest, [0, y, [0, x, 0]]);
     }
    }
    return res;
   }
   function fold_right(l, f, init){
    if(! l) return init;
    function _c_(a, b){return caml_call2(f, b, a);}
    return fold(rev(l), init, _c_);
   }
   function fold_right2_ok(l1, l2, f, init){
    if(! l1 && ! l2) return init;
    function _a_(a, b, c){return caml_call3(f, b, c, a);}
    var _b_ = rev(l2);
    return fold2_ok(rev(l1), _b_, init, _a_);
   }
   var
    Base_List0 =
      [0,
       hd_exn,
       rev_append,
       tl_exn,
       unzip,
       length,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       rev,
       fold_right,
       fold_right2_ok];
   runtime.caml_register_global(7, Base_List0, "Base__List0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash
//# unitInfo: Requires: Base__Char0, Base__Hash_intf, Base__Import0, Base__Int0, Base__List0, Base_internalhash_types, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    description = "internalhash",
    Base_Import0 = global_data.Base__Import0,
    Base_Int0 = global_data.Base__Int0,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_List0 = global_data.Base__List0,
    Base_Char0 = global_data.Base__Char0;
   function Folding(Hash){
    function hash_fold_unit(s, param){return s;}
    var
     hash_fold_int = Hash[2],
     hash_fold_int64 = Hash[3],
     hash_fold_float = Hash[4],
     hash_fold_string = Hash[5];
    function as_int(f, s, x){
     return caml_call2(hash_fold_int, s, caml_call1(f, x));
    }
    function _Q_(_ar_){return _ar_;}
    function hash_fold_int32(_ap_, _aq_){return as_int(_Q_, _ap_, _aq_);}
    var _R_ = Base_Char0[4];
    function hash_fold_char(_an_, _ao_){return as_int(_R_, _an_, _ao_);}
    function _S_(param){return param ? 1 : 0;}
    function hash_fold_bool(_al_, _am_){return as_int(_S_, _al_, _am_);}
    function hash_fold_nativeint(s, x){
     return caml_call2(hash_fold_int64, s, runtime.caml_int64_of_int32(x));
    }
    function hash_fold_option(hash_fold_elem, s, param){
     if(! param) return caml_call2(hash_fold_int, s, 0);
     var x = param[1];
     return caml_call2(hash_fold_elem, caml_call2(hash_fold_int, s, 1), x);
    }
    function hash_fold_list(hash_fold_elem, s$1, list$1){
     var
      s$2 = caml_call2(hash_fold_int, s$1, caml_call1(Base_List0[5], list$1)),
      s = s$2,
      list = list$1;
     for(;;){
      if(! list) return s;
      var
       list$0 = list[2],
       x = list[1],
       s$0 = caml_call2(hash_fold_elem, s, x),
       s = s$0,
       list = list$0;
     }
    }
    function hash_fold_lazy_t(hash_fold_elem, s, x){
     var _aj_ = runtime.caml_obj_tag(x);
     a:
     if(250 === _aj_)
      var _ak_ = x[1];
     else{
      if(246 !== _aj_ && 244 !== _aj_){var _ak_ = x; break a;}
      var _ak_ = caml_call1(CamlinternalLazy[2], x);
     }
     return caml_call2(hash_fold_elem, s, _ak_);
    }
    function hash_fold_ref_frozen(hash_fold_elem, s, x){return caml_call2(hash_fold_elem, s, x[1]);
    }
    function hash_fold_array_frozen(hash_fold_elem, s$1, array){
     var
      s$2 = caml_call2(hash_fold_int, s$1, array.length - 1),
      s = s$2,
      i = 0;
     for(;;){
      if(i === array.length - 1) return s;
      var
       e = array[1 + i],
       i$0 = caml_call2(Base_Import0[91], i, 1),
       s$0 = caml_call2(hash_fold_elem, s, e),
       s = s$0,
       i = i$0;
     }
    }
    function hash_nativeint(x){
     var
      _ah_ = caml_call1(Hash[6], 0),
      _ai_ = hash_fold_nativeint(caml_call2(Hash[7], 0, _ah_), x);
     return caml_call1(Hash[8], _ai_);
    }
    function hash_int64(x){
     var
      _af_ = caml_call1(Hash[6], 0),
      _ag_ = caml_call2(hash_fold_int64, caml_call2(Hash[7], 0, _af_), x);
     return caml_call1(Hash[8], _ag_);
    }
    function hash_int32(x){
     var
      _ad_ = caml_call1(Hash[6], 0),
      _ae_ = hash_fold_int32(caml_call2(Hash[7], 0, _ad_), x);
     return caml_call1(Hash[8], _ae_);
    }
    function hash_char(x){
     var
      _ab_ = caml_call1(Hash[6], 0),
      _ac_ = hash_fold_char(caml_call2(Hash[7], 0, _ab_), x);
     return caml_call1(Hash[8], _ac_);
    }
    function hash_int(x){
     var
      _$_ = caml_call1(Hash[6], 0),
      _aa_ = caml_call2(hash_fold_int, caml_call2(Hash[7], 0, _$_), x);
     return caml_call1(Hash[8], _aa_);
    }
    function hash_bool(x){
     var
      _Z_ = caml_call1(Hash[6], 0),
      ___ = hash_fold_bool(caml_call2(Hash[7], 0, _Z_), x);
     return caml_call1(Hash[8], ___);
    }
    function hash_string(x){
     var
      _X_ = caml_call1(Hash[6], 0),
      _Y_ = caml_call2(hash_fold_string, caml_call2(Hash[7], 0, _X_), x);
     return caml_call1(Hash[8], _Y_);
    }
    function hash_float(x){
     var
      _V_ = caml_call1(Hash[6], 0),
      _W_ = caml_call2(hash_fold_float, caml_call2(Hash[7], 0, _V_), x);
     return caml_call1(Hash[8], _W_);
    }
    function hash_unit(x){
     var _T_ = caml_call1(Hash[6], 0), _U_ = caml_call2(Hash[7], 0, _T_);
     return caml_call1(Hash[8], _U_);
    }
    return [0,
            hash_fold_nativeint,
            hash_fold_int64,
            hash_fold_int32,
            hash_fold_char,
            hash_fold_int,
            hash_fold_bool,
            hash_fold_string,
            hash_fold_float,
            hash_fold_unit,
            hash_fold_option,
            hash_fold_list,
            hash_fold_lazy_t,
            hash_fold_ref_frozen,
            hash_fold_array_frozen,
            hash_nativeint,
            hash_int64,
            hash_int32,
            hash_char,
            hash_int,
            hash_bool,
            hash_string,
            hash_float,
            hash_unit];
   }
   function F(Hash){
    var
     description = Hash[1],
     fold_int = Hash[2],
     fold_int64 = Hash[3],
     fold_float = Hash[4],
     fold_string = Hash[5],
     alloc = Hash[6],
     reset = Hash[7],
     get_hash_value = Hash[8],
     For_tests = Hash[9];
    function create(seed, param){
     return caml_call2(reset, seed, caml_call1(alloc, 0));
    }
    function of_fold(hash_fold_t, t){
     return caml_call1
             (get_hash_value, caml_call2(hash_fold_t, create(0, 0), t));
    }
    var Builtin = Folding(Hash);
    function run(seed, folder, x){
     var
      _O_ = caml_call1(Hash[6], 0),
      _P_ = caml_call2(folder, caml_call2(Hash[7], seed, _O_), x);
     return caml_call1(Hash[8], _P_);
    }
    return [0,
            description,
            fold_int,
            fold_int64,
            fold_float,
            fold_string,
            alloc,
            reset,
            get_hash_value,
            For_tests,
            create,
            of_fold,
            Builtin,
            run];
   }
   function alloc(param){return 0;}
   function reset(opt, t){
    if(opt) var sth = opt[1], seed = sth; else var seed = 0;
    return seed;
   }
   var compare_state = runtime.caml_int_compare;
   function state_to_string(state){return caml_call1(Base_Int0[1], state);}
   var For_tests = [0, compare_state, state_to_string];
   function create(seed, param){return reset(seed, 0);}
   function run(seed, folder, x){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(folder, reset(seed, 0), x));
   }
   function of_fold(hash_fold_t, t){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(hash_fold_t, create(0, 0), t));
   }
   function _a_(_N_){return runtime.Base_internalhash_get_hash_value(_N_);}
   function _b_(_M_, _L_){
    return runtime.Base_internalhash_fold_string(_M_, _L_);
   }
   function _c_(_K_, _J_){
    return runtime.Base_internalhash_fold_float(_K_, _J_);
   }
   function _d_(_I_, _H_){
    return runtime.Base_internalhash_fold_int64(_I_, _H_);
   }
   var
    Folding$0 =
      Folding
       ([0,
         description,
         function(_G_, _F_){
          return runtime.Base_internalhash_fold_int(_G_, _F_);
         },
         _d_,
         _c_,
         _b_,
         alloc,
         reset,
         _a_,
         For_tests]),
    hash_fold_nativeint = Folding$0[1],
    hash_fold_int64 = Folding$0[2],
    hash_fold_int32 = Folding$0[3],
    hash_fold_char = Folding$0[4],
    hash_fold_int = Folding$0[5],
    hash_fold_bool = Folding$0[6],
    hash_fold_string = Folding$0[7],
    hash_fold_float = Folding$0[8],
    hash_fold_unit = Folding$0[9],
    hash_fold_option = Folding$0[10],
    hash_fold_list = Folding$0[11],
    hash_fold_lazy_t = Folding$0[12],
    hash_fold_ref_frozen = Folding$0[13],
    hash_fold_array_frozen = Folding$0[14],
    hash_nativeint = Folding$0[15],
    hash_int64 = Folding$0[16],
    hash_int32 = Folding$0[17],
    hash_string = Folding$0[21],
    hash_char = Base_Char0[4];
   function hash_int(t){
    var
     _t_ = caml_call2(Base_Import0[119], t, 21),
     _u_ = caml_call1(Base_Import0[117], t),
     t$0 = caml_call2(Base_Import0[91], _u_, _t_),
     _v_ = caml_call2(Base_Import0[120], t$0, 24),
     t$1 = caml_call2(Base_Import0[121], t$0, _v_),
     _w_ = caml_call2(Base_Import0[119], t$1, 8),
     _x_ = caml_call2(Base_Import0[119], t$1, 3),
     _y_ = caml_call2(Base_Import0[91], t$1, _x_),
     t$2 = caml_call2(Base_Import0[91], _y_, _w_),
     _z_ = caml_call2(Base_Import0[120], t$2, 14),
     t$3 = caml_call2(Base_Import0[121], t$2, _z_),
     _A_ = caml_call2(Base_Import0[119], t$3, 4),
     _B_ = caml_call2(Base_Import0[119], t$3, 2),
     _C_ = caml_call2(Base_Import0[91], t$3, _B_),
     t$4 = caml_call2(Base_Import0[91], _C_, _A_),
     _D_ = caml_call2(Base_Import0[120], t$4, 28),
     t$5 = caml_call2(Base_Import0[121], t$4, _D_),
     _E_ = caml_call2(Base_Import0[119], t$5, 31);
    return caml_call2(Base_Import0[91], t$5, _E_);
   }
   function hash_bool(x){return x ? 1 : 0;}
   function hash_unit(param){return 0;}
   var
    _e_ =
      [0,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       hash_char,
       hash_int,
       hash_bool,
       hash_string,
       function(_s_){return runtime.Base_hash_double(_s_);},
       hash_unit];
   function _f_(_r_){return runtime.Base_internalhash_get_hash_value(_r_);}
   function _g_(_q_, _p_){
    return runtime.Base_internalhash_fold_string(_q_, _p_);
   }
   function _h_(_o_, _n_){
    return runtime.Base_internalhash_fold_float(_o_, _n_);
   }
   function _i_(_m_, _l_){
    return runtime.Base_internalhash_fold_int64(_m_, _l_);
   }
   var
    Base_Hash =
      [0,
       F,
       description,
       function(_k_, _j_){
        return runtime.Base_internalhash_fold_int(_k_, _j_);
       },
       _i_,
       _h_,
       _g_,
       alloc,
       reset,
       _f_,
       For_tests,
       create,
       of_fold,
       _e_,
       run];
   runtime.caml_register_global(6, Base_Hash, "Base__Hash");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_compare_lib
//# unitInfo: Requires: Base__Import0, Base__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_which_is_abstract_in_an_im =
      ", which is abstract in an implementation.",
    caml_bytes_compare = runtime.caml_bytes_compare,
    caml_bytes_equal = runtime.caml_bytes_equal,
    caml_equal = runtime.caml_equal,
    caml_float_compare = runtime.caml_float_compare,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int_compare = runtime.caml_int_compare,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_equal = runtime.caml_string_equal;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    _b_ =
      [0,
       [11,
        "Equal called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Equal called on the type %s, which is abstract in an implementation."],
    _a_ =
      [0,
       [11,
        "Compare called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Compare called on the type %s, which is abstract in an implementation."];
   function compare_abstract(type_name, param, _F_){
    return caml_call3(Base_Printf[4], Base_Import0[124], _a_, type_name);
   }
   function equal_abstract(type_name, param, _E_){
    return caml_call3(Base_Printf[4], Base_Import0[124], _b_, type_name);
   }
   var
    Comparable = [0],
    Equal = [0],
    compare_bool = caml_int_compare,
    compare_bool_local = caml_int_compare,
    compare_char = caml_int_compare,
    compare_char_local = caml_int_compare,
    compare_float = caml_float_compare,
    compare_float_local = caml_float_compare,
    compare_int = caml_int_compare,
    compare_int_local = caml_int_compare,
    compare_int32 = caml_int_compare,
    compare_int32_local = caml_int_compare;
   function compare_int64(_D_, _C_){return caml_int64_compare(_D_, _C_);}
   function compare_int64_local(_B_, _A_){return caml_int64_compare(_B_, _A_);
   }
   var
    compare_nativeint = caml_int_compare,
    compare_nativeint_local = caml_int_compare,
    compare_string = caml_string_compare,
    compare_string_local = caml_string_compare,
    compare_bytes = caml_bytes_compare,
    compare_bytes_local = caml_bytes_compare,
    compare_unit = caml_int_compare,
    compare_unit_local = caml_int_compare;
   function compare_array_local(compare_elt, a, b){
    if(a === b) return 0;
    var
     len_a = a.length - 1,
     len_b = b.length - 1,
     ret = caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var l = a[1 + i], r = b[1 + i], res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import0[91], i, 1), i = i$0;
    }
   }
   function compare_array(compare_elt, a, b){
    return compare_array_local(compare_elt, a, b);
   }
   function compare_list(compare_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      res = caml_call2(compare_elt, x, y);
     if(0 !== res) return res;
     var a$0 = xs, b$0 = ys;
    }
   }
   function compare_list_local(compare_elt_local, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      res = caml_call2(compare_elt_local, x, y);
     if(0 !== res) return res;
     var a$0 = xs, b$0 = ys;
    }
   }
   function compare_option(compare_elt, a, b){
    if(! a) return b ? -1 : 0;
    var a$0 = a[1];
    if(! b) return 1;
    var b$0 = b[1];
    return caml_call2(compare_elt, a$0, b$0);
   }
   function compare_option_local(compare_elt_local, a, b){
    if(! a) return b ? -1 : 0;
    var a$0 = a[1];
    if(! b) return 1;
    var b$0 = b[1];
    return caml_call2(compare_elt_local, a$0, b$0);
   }
   function compare_ref(compare_elt, a, b){
    return caml_call2(compare_elt, a[1], b[1]);
   }
   function compare_ref_local(compare_elt, a, b){return caml_call2(compare_elt, a[1], b[1]);
   }
   function equal_bool(_z_, _y_){return _z_ === _y_ ? 1 : 0;}
   function equal_bool_local(_x_, _w_){return _x_ === _w_ ? 1 : 0;}
   function equal_char(_v_, _u_){return _v_ === _u_ ? 1 : 0;}
   function equal_char_local(_t_, _s_){return _t_ === _s_ ? 1 : 0;}
   function equal_int(_r_, _q_){return _r_ === _q_ ? 1 : 0;}
   function equal_int_local(_p_, _o_){return _p_ === _o_ ? 1 : 0;}
   var
    equal_int32 = caml_equal,
    equal_int32_local = caml_equal,
    equal_int64 = caml_equal,
    equal_int64_local = caml_equal,
    equal_nativeint = caml_equal,
    equal_nativeint_local = caml_equal,
    equal_string = caml_string_equal,
    equal_string_local = caml_string_equal,
    equal_bytes = caml_bytes_equal,
    equal_bytes_local = caml_bytes_equal;
   function equal_unit(_n_, _m_){return _n_ === _m_ ? 1 : 0;}
   function equal_unit_local(_l_, _k_){return _l_ === _k_ ? 1 : 0;}
   function equal_float(x, y){return caml_float_compare(x, y) === 0 ? 1 : 0;}
   function equal_float_local(x, y){
    return caml_float_compare(x, y) === 0 ? 1 : 0;
   }
   function equal_array_local(equal_elt, a, b){
    var _e_ = a === b ? 1 : 0;
    if(_e_)
     var _f_ = _e_;
    else{
     var
      len_a = a.length - 1,
      len_b = b.length - 1,
      _g_ = len_a === len_b ? 1 : 0;
     if(_g_){
      var i = 0;
      for(;;){
       var _h_ = i === len_a ? 1 : 0;
       if(_h_)
        var _i_ = _h_;
       else{
        var l = a[1 + i], r = b[1 + i], _j_ = caml_call2(equal_elt, l, r);
        if(_j_){
         var i$0 = caml_call2(Base_Import0[91], i, 1), i = i$0;
         continue;
        }
        var _i_ = _j_;
       }
       return _i_;
      }
     }
     var _f_ = _g_;
    }
    return _f_;
   }
   function equal_array(equal_elt, a, b){
    return equal_array_local(equal_elt, a, b);
   }
   function equal_list(equal_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(a$0){
      if(b$0){
       var
        ys = b$0[2],
        y = b$0[1],
        xs = a$0[2],
        x = a$0[1],
        _d_ = caml_call2(equal_elt, x, y);
       if(! _d_) return _d_;
       var a$0 = xs, b$0 = ys;
       continue;
      }
     }
     else if(! b$0) return 1;
     return 0;
    }
   }
   function equal_list_local(equal_elt_local, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(a$0){
      if(b$0){
       var
        ys = b$0[2],
        y = b$0[1],
        xs = a$0[2],
        x = a$0[1],
        _c_ = caml_call2(equal_elt_local, x, y);
       if(! _c_) return _c_;
       var a$0 = xs, b$0 = ys;
       continue;
      }
     }
     else if(! b$0) return 1;
     return 0;
    }
   }
   function equal_option(equal_elt, a, b){
    if(a){
     if(b){
      var b$0 = b[1], a$0 = a[1];
      return caml_call2(equal_elt, a$0, b$0);
     }
    }
    else if(! b) return 1;
    return 0;
   }
   function equal_option_local(equal_elt_local, a, b){
    if(a){
     if(b){
      var b$0 = b[1], a$0 = a[1];
      return caml_call2(equal_elt_local, a$0, b$0);
     }
    }
    else if(! b) return 1;
    return 0;
   }
   function equal_ref(equal_elt, a, b){
    return caml_call2(equal_elt, a[1], b[1]);
   }
   function equal_ref_local(equal_elt, a, b){
    return caml_call2(equal_elt, a[1], b[1]);
   }
   var
    Base_Ppx_compare_lib =
      [0,
       compare_abstract,
       equal_abstract,
       Comparable,
       Equal,
       [0,
        compare_bool,
        compare_char,
        compare_float,
        compare_int,
        compare_int32,
        compare_int64,
        compare_nativeint,
        compare_string,
        compare_bytes,
        compare_unit,
        compare_array,
        compare_list,
        compare_option,
        compare_ref,
        equal_bool,
        equal_char,
        equal_float,
        equal_int,
        equal_int32,
        equal_int64,
        equal_nativeint,
        equal_string,
        equal_bytes,
        equal_unit,
        equal_array,
        equal_list,
        equal_option,
        equal_ref,
        compare_bool_local,
        compare_char_local,
        compare_float_local,
        compare_int_local,
        compare_int32_local,
        compare_int64_local,
        compare_nativeint_local,
        compare_string_local,
        compare_bytes_local,
        compare_unit_local,
        compare_array_local,
        compare_list_local,
        compare_option_local,
        compare_ref_local,
        equal_bool_local,
        equal_char_local,
        equal_float_local,
        equal_int_local,
        equal_int32_local,
        equal_int64_local,
        equal_nativeint_local,
        equal_string_local,
        equal_bytes_local,
        equal_unit_local,
        equal_array_local,
        equal_list_local,
        equal_option_local,
        equal_ref_local]];
   runtime.caml_register_global
    (4, Base_Ppx_compare_lib, "Base__Ppx_compare_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_hash_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Std = [0],
    Hashable = [0],
    Base_Ppx_hash_lib = [0, Std, Hashable];
   runtime.caml_register_global(0, Base_Ppx_hash_lib, "Base__Ppx_hash_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp
//# unitInfo: Requires: Base__Globalize, Base__Hash, Base__Ppx_compare_lib, Sexplib0__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Globalize = global_data.Base__Globalize,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    t_of_sexp = Sexplib0_Sexp[1],
    sexp_of_t = Sexplib0_Sexp[2],
    equal = Sexplib0_Sexp[3],
    Not_found_s = Sexplib0_Sexp[5],
    Of_sexp_error = Sexplib0_Sexp[6],
    message = Sexplib0_Sexp[7],
    default_indent = Sexplib0_Sexp[8],
    pp_hum = Sexplib0_Sexp[9],
    pp_hum_indent = Sexplib0_Sexp[10],
    pp_mach = Sexplib0_Sexp[11],
    pp = Sexplib0_Sexp[12],
    to_string_hum = Sexplib0_Sexp[13],
    to_string_mach = Sexplib0_Sexp[14],
    to_string = Sexplib0_Sexp[15],
    of_float_style = Sexplib0_Sexp[16],
    of_int_style = Sexplib0_Sexp[17],
    Private = Sexplib0_Sexp[18];
   function compare_local(a_001, b_002){
    if(a_001 === b_002) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(Base_Ppx_compare_lib[5][36], a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call3
            (Base_Ppx_compare_lib[5][40], compare_local, a_005, b_006);
   }
   function compare(a, b){return compare_local(a, b);}
   function globalize(x_009){
    if(0 === x_009[0]){
     var arg_010 = x_009[1];
     return [0, caml_call1(Base_Globalize[9], arg_010)];
    }
    var arg_011 = x_009[1];
    return [1, caml_call2(Base_Globalize[13], globalize, arg_011)];
   }
   var
    hash_fold_t = function _f_(_d_, _e_){return _f_.fun(_d_, _e_);},
    hash = function _c_(_b_){return _c_.fun(_b_);};
   caml_update_dummy
    (hash_fold_t,
     function(hsv, arg){
      if(0 === arg[0]){
       var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
       return caml_call2(Base_Hash[13][7], hsv$0, a0);
      }
      var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
      return caml_call3(Base_Hash[13][11], hash_fold_t, hsv$1, a0$0);
     });
   caml_update_dummy
    (hash,
     function(arg){
      var
       hsv = caml_call2(Base_Hash[11], 0, 0),
       _a_ = caml_call2(hash_fold_t, hsv, arg);
      return caml_call1(Base_Hash[9], _a_);
     });
   var t_sexp_grammar = Sexplib0_Sexp_conv[61], of_string = 0;
   function invariant(param){return 0;}
   function equal_local(a, b){return 0 === compare_local(a, b) ? 1 : 0;}
   var
    Base_Sexp =
      [0,
       globalize,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       Private,
       equal_local,
       compare_local,
       t_sexp_grammar,
       invariant,
       of_string];
   runtime.caml_register_global(5, Base_Sexp, "Base__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import
//# unitInfo: Requires: Base__Globalize, Base__Hash, Base__Import0, Base__Ppx_compare_lib, Base__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Globalize = global_data.Base__Globalize,
    Base_Sexp = global_data.Base__Sexp,
    Exit = Base_Import0[1],
    Not_found = Base_Import0[2],
    max_int = Base_Import0[3],
    min_int = Base_Import0[4],
    infinity = Base_Import0[5],
    neg_infinity = Base_Import0[6],
    nan = Base_Import0[7],
    max_float = Base_Import0[8],
    min_float = Base_Import0[9],
    epsilon_float = Base_Import0[10],
    char_of_int = Base_Import0[11],
    string_of_bool = Base_Import0[12],
    bool_of_string_opt = Base_Import0[13],
    bool_of_string = Base_Import0[14],
    string_of_int = Base_Import0[15],
    int_of_string_opt = Base_Import0[16],
    string_of_float = Base_Import0[17],
    float_of_string_opt = Base_Import0[18],
    stdin = Base_Import0[19],
    stdout = Base_Import0[20],
    stderr = Base_Import0[21],
    print_char = Base_Import0[22],
    print_string = Base_Import0[23],
    print_bytes = Base_Import0[24],
    print_int = Base_Import0[25],
    print_float = Base_Import0[26],
    print_endline = Base_Import0[27],
    print_newline = Base_Import0[28],
    prerr_char = Base_Import0[29],
    prerr_string = Base_Import0[30],
    prerr_bytes = Base_Import0[31],
    prerr_int = Base_Import0[32],
    prerr_float = Base_Import0[33],
    prerr_endline = Base_Import0[34],
    prerr_newline = Base_Import0[35],
    read_line = Base_Import0[36],
    read_int_opt = Base_Import0[37],
    read_int = Base_Import0[38],
    read_float_opt = Base_Import0[39],
    read_float = Base_Import0[40],
    open_out = Base_Import0[41],
    open_out_bin = Base_Import0[42],
    open_out_gen = Base_Import0[43],
    flush = Base_Import0[44],
    flush_all = Base_Import0[45],
    output_char = Base_Import0[46],
    output_string = Base_Import0[47],
    output_bytes = Base_Import0[48],
    output = Base_Import0[49],
    output_substring = Base_Import0[50],
    output_byte = Base_Import0[51],
    output_binary_int = Base_Import0[52],
    output_value = Base_Import0[53],
    seek_out = Base_Import0[54],
    pos_out = Base_Import0[55],
    out_channel_length = Base_Import0[56],
    close_out = Base_Import0[57],
    close_out_noerr = Base_Import0[58],
    set_binary_mode_out = Base_Import0[59],
    open_in = Base_Import0[60],
    open_in_bin = Base_Import0[61],
    open_in_gen = Base_Import0[62],
    input_char = Base_Import0[63],
    input_line = Base_Import0[64],
    input = Base_Import0[65],
    really_input = Base_Import0[66],
    really_input_string = Base_Import0[67],
    input_byte = Base_Import0[68],
    input_binary_int = Base_Import0[69],
    input_value = Base_Import0[70],
    seek_in = Base_Import0[71],
    pos_in = Base_Import0[72],
    in_channel_length = Base_Import0[73],
    close_in = Base_Import0[74],
    close_in_noerr = Base_Import0[75],
    set_binary_mode_in = Base_Import0[76],
    string_of_format = Base_Import0[77],
    symbol = Base_Import0[78],
    exit = Base_Import0[79],
    at_exit = Base_Import0[80],
    valid_float_lexem = Base_Import0[81],
    unsafe_really_input = Base_Import0[82],
    do_at_exit = Base_Import0[83],
    do_domain_local_at_exit = Base_Import0[84],
    Stdlib = Base_Import0[85],
    bool_to_int = Base_Import0[86],
    symbol$0 = Base_Import0[87],
    symbol$1 = Base_Import0[88],
    symbol$2 = Base_Import0[89],
    symbol$3 = Base_Import0[90],
    symbol$4 = Base_Import0[91],
    symbol$5 = Base_Import0[92],
    symbol$6 = Base_Import0[93],
    symbol$7 = Base_Import0[94],
    symbol$8 = Base_Import0[95],
    symbol$9 = Base_Import0[96],
    Int_replace_polymorphic_compar = Base_Import0[97],
    ascending = Base_Import0[98],
    descending = Base_Import0[99],
    max = Base_Import0[100],
    min = Base_Import0[101],
    Int32_replace_polymorphic_comp = Base_Import0[102],
    Int64_replace_polymorphic_comp = Base_Import0[103],
    Nativeint_replace_polymorphic_ = Base_Import0[104],
    Bool_replace_polymorphic_compa = Base_Import0[105],
    Char_replace_polymorphic_compa = Base_Import0[106],
    Uchar_replace_polymorphic_comp = Base_Import0[107],
    Float_replace_polymorphic_comp = Base_Import0[108],
    String_replace_polymorphic_com = Base_Import0[109],
    Bytes_replace_polymorphic_comp = Base_Import0[110],
    symbol$10 = Base_Import0[111],
    symbol$11 = Base_Import0[112],
    symbol$12 = Base_Import0[113],
    symbol$13 = Base_Import0[114],
    asr = Base_Import0[115],
    land = Base_Import0[116],
    lnot = Base_Import0[117],
    lor = Base_Import0[118],
    lsl = Base_Import0[119],
    lsr = Base_Import0[120],
    lxor = Base_Import0[121],
    mod = Base_Import0[122],
    abs = Base_Import0[123],
    failwith = Base_Import0[124],
    fst = Base_Import0[125],
    invalid_arg = Base_Import0[126],
    snd = Base_Import0[127],
    float_of_string = Base_Import0[128],
    am_testing = Base_Import0[129],
    default_string_of_float = Sexplib0_Sexp_conv[1],
    write_old_option_format = Sexplib0_Sexp_conv[2],
    read_old_option_format = Sexplib0_Sexp_conv[3],
    list_map = Sexplib0_Sexp_conv[4],
    sexp_of_unit = Sexplib0_Sexp_conv[5],
    sexp_of_bool = Sexplib0_Sexp_conv[6],
    sexp_of_string = Sexplib0_Sexp_conv[7],
    sexp_of_bytes = Sexplib0_Sexp_conv[8],
    sexp_of_char = Sexplib0_Sexp_conv[9],
    sexp_of_int = Sexplib0_Sexp_conv[10],
    sexp_of_float = Sexplib0_Sexp_conv[11],
    sexp_of_int32 = Sexplib0_Sexp_conv[12],
    sexp_of_int64 = Sexplib0_Sexp_conv[13],
    sexp_of_nativeint = Sexplib0_Sexp_conv[14],
    sexp_of_ref = Sexplib0_Sexp_conv[15],
    sexp_of_lazy_t = Sexplib0_Sexp_conv[16],
    sexp_of_option = Sexplib0_Sexp_conv[17],
    sexp_of_pair = Sexplib0_Sexp_conv[18],
    sexp_of_triple = Sexplib0_Sexp_conv[19],
    sexp_of_list = Sexplib0_Sexp_conv[20],
    sexp_of_array = Sexplib0_Sexp_conv[21],
    sexp_of_hashtbl = Sexplib0_Sexp_conv[22],
    sexp_of_opaque = Sexplib0_Sexp_conv[23],
    sexp_of_fun = Sexplib0_Sexp_conv[24],
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    record_check_extra_fields = Sexplib0_Sexp_conv[26],
    of_sexp_error = Sexplib0_Sexp_conv[27],
    of_sexp_error_exn = Sexplib0_Sexp_conv[28],
    unit_of_sexp = Sexplib0_Sexp_conv[29],
    bool_of_sexp = Sexplib0_Sexp_conv[30],
    string_of_sexp = Sexplib0_Sexp_conv[31],
    bytes_of_sexp = Sexplib0_Sexp_conv[32],
    char_of_sexp = Sexplib0_Sexp_conv[33],
    int_of_sexp = Sexplib0_Sexp_conv[34],
    float_of_sexp = Sexplib0_Sexp_conv[35],
    int32_of_sexp = Sexplib0_Sexp_conv[36],
    int64_of_sexp = Sexplib0_Sexp_conv[37],
    nativeint_of_sexp = Sexplib0_Sexp_conv[38],
    ref_of_sexp = Sexplib0_Sexp_conv[39],
    lazy_t_of_sexp = Sexplib0_Sexp_conv[40],
    option_of_sexp = Sexplib0_Sexp_conv[41],
    pair_of_sexp = Sexplib0_Sexp_conv[42],
    triple_of_sexp = Sexplib0_Sexp_conv[43],
    list_of_sexp = Sexplib0_Sexp_conv[44],
    array_of_sexp = Sexplib0_Sexp_conv[45],
    hashtbl_of_sexp = Sexplib0_Sexp_conv[46],
    opaque_of_sexp = Sexplib0_Sexp_conv[47],
    fun_of_sexp = Sexplib0_Sexp_conv[48],
    sexp_grammar_with_tags = Sexplib0_Sexp_conv[49],
    sexp_grammar_with_tag_list = Sexplib0_Sexp_conv[50],
    unit_sexp_grammar = Sexplib0_Sexp_conv[51],
    bool_sexp_grammar = Sexplib0_Sexp_conv[52],
    string_sexp_grammar = Sexplib0_Sexp_conv[53],
    bytes_sexp_grammar = Sexplib0_Sexp_conv[54],
    char_sexp_grammar = Sexplib0_Sexp_conv[55],
    int_sexp_grammar = Sexplib0_Sexp_conv[56],
    float_sexp_grammar = Sexplib0_Sexp_conv[57],
    int32_sexp_grammar = Sexplib0_Sexp_conv[58],
    int64_sexp_grammar = Sexplib0_Sexp_conv[59],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv[60],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv[61],
    ref_sexp_grammar = Sexplib0_Sexp_conv[62],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv[63],
    option_sexp_grammar = Sexplib0_Sexp_conv[64],
    list_sexp_grammar = Sexplib0_Sexp_conv[65],
    array_sexp_grammar = Sexplib0_Sexp_conv[66],
    opaque_sexp_grammar = Sexplib0_Sexp_conv[67],
    fun_sexp_grammar = Sexplib0_Sexp_conv[68],
    sexp_of_exn = Sexplib0_Sexp_conv[69],
    printexc_prefer_sexp = Sexplib0_Sexp_conv[70],
    sexp_of_exn_opt = Sexplib0_Sexp_conv[71],
    Exn_converter = Sexplib0_Sexp_conv[72],
    _a_ = Base_Hash[13],
    hash_fold_nativeint = _a_[1],
    hash_fold_int64 = _a_[2],
    hash_fold_int32 = _a_[3],
    hash_fold_char = _a_[4],
    hash_fold_int = _a_[5],
    hash_fold_bool = _a_[6],
    hash_fold_string = _a_[7],
    hash_fold_float = _a_[8],
    hash_fold_unit = _a_[9],
    hash_fold_option = _a_[10],
    hash_fold_list = _a_[11],
    hash_fold_lazy_t = _a_[12],
    hash_fold_ref_frozen = _a_[13],
    hash_fold_array_frozen = _a_[14],
    hash_nativeint = _a_[15],
    hash_int64 = _a_[16],
    hash_int32 = _a_[17],
    hash_char = _a_[18],
    hash_int = _a_[19],
    hash_bool = _a_[20],
    hash_string = _a_[21],
    hash_float = _a_[22],
    hash_unit = _a_[23],
    _b_ = Base_Ppx_compare_lib[5],
    compare_bool = _b_[1],
    compare_char = _b_[2],
    compare_float = _b_[3],
    compare_int = _b_[4],
    compare_int32 = _b_[5],
    compare_int64 = _b_[6],
    compare_nativeint = _b_[7],
    compare_string = _b_[8],
    compare_bytes = _b_[9],
    compare_unit = _b_[10],
    compare_array = _b_[11],
    compare_list = _b_[12],
    compare_option = _b_[13],
    compare_ref = _b_[14],
    equal_bool = _b_[15],
    equal_char = _b_[16],
    equal_float = _b_[17],
    equal_int = _b_[18],
    equal_int32 = _b_[19],
    equal_int64 = _b_[20],
    equal_nativeint = _b_[21],
    equal_string = _b_[22],
    equal_bytes = _b_[23],
    equal_unit = _b_[24],
    equal_array = _b_[25],
    equal_list = _b_[26],
    equal_option = _b_[27],
    equal_ref = _b_[28],
    compare_bool_local = _b_[29],
    compare_char_local = _b_[30],
    compare_float_local = _b_[31],
    compare_int_local = _b_[32],
    compare_int32_local = _b_[33],
    compare_int64_local = _b_[34],
    compare_nativeint_local = _b_[35],
    compare_string_local = _b_[36],
    compare_bytes_local = _b_[37],
    compare_unit_local = _b_[38],
    compare_array_local = _b_[39],
    compare_list_local = _b_[40],
    compare_option_local = _b_[41],
    compare_ref_local = _b_[42],
    equal_bool_local = _b_[43],
    equal_char_local = _b_[44],
    equal_float_local = _b_[45],
    equal_int_local = _b_[46],
    equal_int32_local = _b_[47],
    equal_int64_local = _b_[48],
    equal_nativeint_local = _b_[49],
    equal_string_local = _b_[50],
    equal_bytes_local = _b_[51],
    equal_unit_local = _b_[52],
    equal_array_local = _b_[53],
    equal_list_local = _b_[54],
    equal_option_local = _b_[55],
    equal_ref_local = _b_[56],
    globalize_bool = Base_Globalize[1],
    globalize_char = Base_Globalize[2],
    globalize_float = Base_Globalize[3],
    globalize_int = Base_Globalize[4],
    globalize_int32 = Base_Globalize[5],
    globalize_int64 = Base_Globalize[6],
    globalize_nativeint = Base_Globalize[7],
    globalize_bytes = Base_Globalize[8],
    globalize_string = Base_Globalize[9],
    globalize_unit = Base_Globalize[10],
    globalize_array = Base_Globalize[11],
    globalize_lazy_t = Base_Globalize[12],
    globalize_list = Base_Globalize[13],
    globalize_option = Base_Globalize[14],
    globalize_result = Base_Globalize[15],
    globalize_ref = Base_Globalize[16],
    Not_found_s = Base_Sexp[8],
    Base_Import =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Stdlib,
       bool_to_int,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       Int_replace_polymorphic_compar,
       ascending,
       descending,
       max,
       min,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$10,
       symbol$11,
       symbol$12,
       symbol$13,
       asr,
       land,
       lnot,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs,
       failwith,
       fst,
       invalid_arg,
       snd,
       float_of_string,
       am_testing,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       Exn_converter,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       hash_char,
       hash_int,
       hash_bool,
       hash_string,
       hash_float,
       hash_unit,
       compare_bool,
       compare_char,
       compare_float,
       compare_int,
       compare_int32,
       compare_int64,
       compare_nativeint,
       compare_string,
       compare_bytes,
       compare_unit,
       compare_array,
       compare_list,
       compare_option,
       compare_ref,
       equal_bool,
       equal_char,
       equal_float,
       equal_int,
       equal_int32,
       equal_int64,
       equal_nativeint,
       equal_string,
       equal_bytes,
       equal_unit,
       equal_array,
       equal_list,
       equal_option,
       equal_ref,
       compare_bool_local,
       compare_char_local,
       compare_float_local,
       compare_int_local,
       compare_int32_local,
       compare_int64_local,
       compare_nativeint_local,
       compare_string_local,
       compare_bytes_local,
       compare_unit_local,
       compare_array_local,
       compare_list_local,
       compare_option_local,
       compare_ref_local,
       equal_bool_local,
       equal_char_local,
       equal_float_local,
       equal_int_local,
       equal_int32_local,
       equal_int64_local,
       equal_nativeint_local,
       equal_string_local,
       equal_bytes_local,
       equal_unit_local,
       equal_array_local,
       equal_list_local,
       equal_option_local,
       equal_ref_local,
       globalize_bool,
       globalize_char,
       globalize_float,
       globalize_int,
       globalize_int32,
       globalize_int64,
       globalize_nativeint,
       globalize_bytes,
       globalize_string,
       globalize_unit,
       globalize_array,
       globalize_lazy_t,
       globalize_list,
       globalize_option,
       globalize_result,
       globalize_ref,
       Not_found_s];
   runtime.caml_register_global(6, Base_Import, "Base__Import");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Word_size
//# unitInfo: Requires: Base__Import, Base__Sys0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    Base_Import = global_data.Base__Import,
    _a_ = [0, "W64"],
    _b_ = [0, "W32"],
    cst_unknown_word_size = "unknown word size";
   function sexp_of_t(param){return param ? _a_ : _b_;}
   function num_bits(param){return param ? 64 : 32;}
   var
    _c_ = Base_Sys0[7],
    word_size =
      32 === _c_
       ? 0
       : 64 === _c_ ? 1 : caml_call1(Base_Import[124], cst_unknown_word_size),
    Base_Word_size = [0, sexp_of_t, num_bits, word_size];
   runtime.caml_register_global(5, Base_Word_size, "Base__Word_size");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Formatter
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Formatter = [0];
   runtime.caml_register_global(0, Base_Formatter, "Base__Formatter");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pretty_printer
//# unitInfo: Requires: Base__Import, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Import = global_data.Base__Import,
    r = [0, [0, "Base.Sexp.pp_hum", 0]],
    cst_pp = ".pp";
   function all(param){return r[1];}
   function register(p){r[1] = [0, p, r[1]]; return 0;}
   function Register_pp(M){
    var pp = M[1];
    register(caml_call2(Base_Import[112], M[2], cst_pp));
    return [0, pp];
   }
   function _a_(_c_){return [0, Register_pp(_c_)[1]];}
   var
    Base_Pretty_printer =
      [0,
       all,
       function(M){
        var module_name = M[1];
        function pp(formatter, t){
         var _b_ = caml_call1(M[2], t);
         return caml_call2(Stdlib_Format[13], formatter, _b_);
        }
        return [0, Register_pp([0, pp, module_name])[1]];
       },
       _a_,
       register];
   runtime.caml_register_global
    (4, Base_Pretty_printer, "Base__Pretty_printer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Exn
//# unitInfo: Requires: Base__Import, Base__Pretty_printer, Base__Printf, Base__Sexp, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_2 = "<2>",
    cst_src_exn_ml = "src/exn.ml",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Exn",
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Import = global_data.Base__Import,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Sexp = global_data.Base__Sexp,
    Base_Printf = global_data.Base__Printf,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    sexp_of_t = Base_Import[198],
    exit = Base_Import[85][99],
    Finally = [248, "Base__Exn.Finally", caml_fresh_oo_id(0)],
    _k_ =
      [0,
       [11, "Exn.handle_uncaught could not print; exiting anyway\n", [10, 0]],
       "Exn.handle_uncaught could not print; exiting anyway\n%!"],
    _j_ =
      [0,
       [18,
        [1, [0, [11, cst_2, 0], cst_2]],
        [11,
         "Uncaught exception:",
         [17,
          3,
          [17,
           3,
           [18, [1, [0, 0, ""]], [15, [17, 0, [17, 0, [17, 3, [17, 4, 0]]]]]]]]]],
       "@[<2>Uncaught exception:@\n@\n@[%a@]@]@\n@."],
    _i_ = [0, 2],
    _h_ = [0, cst_src_exn_ml, 53, 6],
    _e_ = [0, "exn.ml.Reraised"],
    _f_ = [0, cst_src_exn_ml, 32, 11],
    _b_ = [0, "exn.ml.Finally"],
    _c_ = [0, cst_src_exn_ml, 19, 11],
    cst_Base_Exn_Reraised = "Base__Exn.Reraised",
    cst_Base_Exn_Sexp = "Base__Exn.Sexp";
   function _a_(param){
    if(param[1] !== Finally)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    var
     arg1_002 = param[3],
     arg0_001 = param[2],
     res0_003 = caml_call1(sexp_of_t, arg0_001),
     res1_004 = caml_call1(sexp_of_t, arg1_002);
    return [1, [0, _b_, [0, res0_003, [0, res1_004, 0]]]];
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, Finally, _a_);
   var Reraised = [248, cst_Base_Exn_Reraised, caml_fresh_oo_id(0)];
   function _d_(param){
    if(param[1] !== Reraised)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var
     arg1_006 = param[3],
     arg0_005 = param[2],
     res0_007 = caml_call1(Base_Import[136], arg0_005),
     res1_008 = caml_call1(sexp_of_t, arg1_006);
    return [1, [0, _e_, [0, res0_007, [0, res1_008, 0]]]];
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, Reraised, _d_);
   var Sexp = [248, cst_Base_Exn_Sexp, caml_fresh_oo_id(0)];
   function _g_(param){
    if(param[1] !== Sexp)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var t = param[2];
    return t;
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, Sexp, _g_);
   function create_s(sexp){return [0, Sexp, sexp];}
   function raise_with_original_backtrace(t, backtrace){
    runtime.caml_restore_raw_backtrace(t, backtrace);
    throw caml_maybe_attach_backtrace(t, 0);
   }
   function reraise(exn, str){
    var exn$0 = [0, Reraised, str, exn];
    if(! runtime.Base_caml_exn_is_most_recent_exn(exn))
     throw caml_maybe_attach_backtrace(exn$0, 1);
    var bt = caml_call1(Stdlib_Printexc[12], 0);
    return raise_with_original_backtrace(exn$0, bt);
   }
   function reraisef(exc, format){
    function _y_(str, param){return reraise(exc, str);}
    return caml_call2(Base_Printf[4], _y_, format);
   }
   function to_string(exc){
    var _x_ = caml_call1(Base_Import[198], exc);
    return caml_call2(Base_Sexp[16], _i_, _x_);
   }
   function to_string_mach(exc){
    var _w_ = caml_call1(Base_Import[198], exc);
    return caml_call1(Base_Sexp[17], _w_);
   }
   var sexp_of_t$0 = Base_Import[198];
   function protectx(f, x, finally$0){
    try{var res = caml_call1(f, x);}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     try{caml_call1(finally$0, x);}
     catch(final_exn$0){
      var final_exn = caml_wrap_exception(final_exn$0);
      return raise_with_original_backtrace([0, Finally, exn, final_exn], bt);
     }
     return raise_with_original_backtrace(exn, bt);
    }
    caml_call1(finally$0, x);
    return res;
   }
   function protect(f, finally$0){return protectx(f, 0, finally$0);}
   function does_raise(f){
    try{caml_call1(f, 0); var _u_ = 0; return _u_;}catch(_v_){return 1;}
   }
   function pp(ppf, t){
    var match = caml_call1(Base_Import[200], t);
    if(match){
     var sexp = match[1];
     return caml_call2(Base_Sexp[12], ppf, sexp);
    }
    var _t_ = caml_call1(Stdlib_Printexc[1], t);
    return caml_call2(Stdlib_Format[13], ppf, _t_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1];
   function print_with_backtrace(exc, raw_backtrace){
    caml_call3(Stdlib_Format[139], _j_, pp$0, exc);
    if(caml_call1(Stdlib_Printexc[8], 0))
     caml_call2(Stdlib_Printexc[13], Base_Import[85][40], raw_backtrace);
    return caml_call1(Base_Import[85][63], Base_Import[85][40]);
   }
   function handle_uncaught_aux(do_at_exit, exit, f){
    try{var _p_ = caml_call1(f, 0); return _p_;}
    catch(exc$0){
     var
      exc = caml_wrap_exception(exc$0),
      raw_backtrace = caml_call1(Stdlib_Printexc[12], 0);
     if(do_at_exit) try{caml_call1(Base_Import[85][103], 0);}catch(_s_){}
     try{print_with_backtrace(exc, raw_backtrace);}
     catch(_q_){try{caml_call1(Stdlib_Printf[3], _k_);}catch(_r_){}}
     return caml_call1(exit, 1);
    }
   }
   function handle_uncaught_and_exit(f){
    return handle_uncaught_aux(1, exit, f);
   }
   function handle_uncaught(must_exit, f){
    var exit$0 = must_exit ? exit : function(_o_){return 0;};
    return handle_uncaught_aux(must_exit, exit$0, f);
   }
   function reraise_uncaught(str, func){
    try{var _n_ = caml_call1(func, 0); return _n_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     return raise_with_original_backtrace([0, Reraised, str, exn], bt);
    }
   }
   function raise_without_backtrace(e){
    runtime.Base_clear_caml_backtrace_pos(0);
    throw e;
   }
   function initialize_module(param){
    return caml_call1(Stdlib_Printexc[16], print_with_backtrace);
   }
   function clear_backtrace(_m_){
    return runtime.Base_clear_caml_backtrace_pos(_m_);
   }
   var
    Private = [0, clear_backtrace],
    Base_Exn =
      [0,
       sexp_of_t$0,
       pp$0,
       Finally,
       Reraised,
       create_s,
       raise_without_backtrace,
       raise_with_original_backtrace,
       reraise,
       reraisef,
       to_string,
       to_string_mach,
       protectx,
       protect,
       handle_uncaught,
       handle_uncaught_and_exit,
       reraise_uncaught,
       does_raise,
       function(_l_){return runtime.Base_caml_exn_is_most_recent_exn(_l_);},
       initialize_module,
       Private];
   runtime.caml_register_global(21, Base_Exn, "Base__Exn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__With_return
//# unitInfo: Requires: Base__Exn, Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Exn = global_data.Base__Exn,
    cst_use_of_return_from_a_with_ =
      "use of [return] from a [with_return] that already returned",
    cst_Return = "Return";
   function with_return(f){
    var
     Return = [248, cst_Return, runtime.caml_fresh_oo_id(0)],
     is_alive = [0, 1];
    function return$0(a){
     if(1 - is_alive[1])
      caml_call1(Base_Import[124], cst_use_of_return_from_a_with_);
     return caml_call1(Base_Exn[6], [0, Return, a]);
    }
    try{var a$0 = caml_call1(f, return$0); is_alive[1] = 0; return a$0;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     is_alive[1] = 0;
     if(exn[1] !== Return) throw caml_maybe_attach_backtrace(exn, 0);
     var a = exn[2];
     return a;
    }
   }
   function with_return_option(f){
    return with_return
            (function(return$0){
              caml_call1(f, function(a){return caml_call1(return$0, [0, a]);});
              return 0;
             });
   }
   function prepend(param, f){
    return function(x){return caml_call1(param, caml_call1(f, x));};
   }
   var Base_With_return = [0, with_return, with_return_option, prepend];
   runtime.caml_register_global(4, Base_With_return, "Base__With_return");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variant
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variant = [0];
   runtime.caml_register_global(0, Base_Variant, "Base__Variant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variantslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variantslib = [0];
   runtime.caml_register_global(0, Base_Variantslib, "Base__Variantslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fn
//# unitInfo: Requires: Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import;
   function const$0(c, param){return c;}
   function non(f, x){return 1 - caml_call1(f, x);}
   function forever(f){
    try{for(;;) caml_call1(f, 0);}
    catch(e$0){var e = caml_wrap_exception(e$0); return e;}
   }
   function compose(f, g, x){return caml_call1(f, caml_call1(g, x));}
   function flip(f, x, y){return caml_call2(f, y, x);}
   function apply_n_times(n, f, x){
    var n$0 = n, x$0 = x;
    for(;;){
     if(0 >= n$0) return x$0;
     var
      x$1 = caml_call1(f, x$0),
      n$1 = caml_call2(Base_Import[93], n$0, 1),
      n$0 = n$1,
      x$0 = x$1;
    }
   }
   var Base_Fn = [0, const$0, non, forever, apply_n_times, compose, flip];
   runtime.caml_register_global(1, Base_Fn, "Base__Fn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function S_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S3(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_to_S_indexed(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit,
            Let_syntax];
   }
   function S3_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_indexed_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   var
    Base_Monad_intf =
      [0,
       S_to_S2,
       S2_to_S3,
       S_to_S_indexed,
       S2_to_S,
       S3_to_S2,
       S_indexed_to_S2];
   runtime.caml_register_global(0, Base_Monad_intf, "Base__Monad_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad
//# unitInfo: Requires: Base__List0, Base__Monad_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0;
   function Make_general(_M_){
    var bind = _M_[1], return$0 = _M_[3];
    function map_via_bind(ma, f){
     function _N_(a){
      var _O_ = caml_call1(f, a);
      return caml_call1(_M_[3], _O_);
     }
     return caml_call2(_M_[1], ma, _N_);
    }
    var match = _M_[2];
    if(typeof match === "number")
     var map = map_via_bind;
    else
     var x = match[2], map = x;
    function symbol_bind(t, f){return caml_call2(bind, t, f);}
    function symbol_map(t, f){return caml_call2(map, t, f);}
    var
     Monad_infix = [0, symbol_bind, symbol_map],
     symbol_bind$0 = Monad_infix[1],
     symbol_map$0 = Monad_infix[2],
     symbol_bind$1 = Monad_infix[1],
     symbol_map$1 = Monad_infix[2];
    function both(a, b){
     return caml_call2
             (symbol_bind$1,
              a,
              function(a){
               return caml_call2
                       (symbol_map$1, b, function(b){return [0, a, b];});
              });
    }
    var
     Open_on_rhs = [0],
     Let_syntax = [0, return$0, bind, map, both, Open_on_rhs],
     Let_syntax$0 = [0, return$0, symbol_bind$1, symbol_map$1, Let_syntax];
    function join(t){
     return caml_call2(symbol_bind$0, t, function(t){return t;});
    }
    function ignore_m(t){
     return caml_call2(map, t, function(param){return 0;});
    }
    function loop(vs, param){
     if(! param) return caml_call1(return$0, caml_call1(Base_List0[19], vs));
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(v){return loop([0, v, vs], ts);});
    }
    function all(ts){return loop(0, ts);}
    function all_unit(param){
     if(! param) return caml_call1(return$0, 0);
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(param){return all_unit(ts);});
    }
    return [0,
            bind,
            return$0,
            ,
            map,
            Monad_infix,
            symbol_bind$0,
            symbol_map$0,
            Let_syntax$0,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function Make_indexed(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _L_ = Make_general([0, bind, map, return$0]);
    return [0,
            _L_[6],
            _L_[7],
            _L_[8],
            _L_[5],
            _L_[1],
            _L_[2],
            _L_[4],
            _L_[9],
            _L_[10],
            _L_[11],
            _L_[12]];
   }
   function Make3(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _K_ = Make_general([0, bind, map, return$0]);
    return [0,
            _K_[6],
            _K_[7],
            _K_[8],
            _K_[5],
            _K_[1],
            _K_[2],
            _K_[4],
            _K_[9],
            _K_[10],
            _K_[11],
            _K_[12]];
   }
   function Make2(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _J_ = Make_general([0, bind, map, return$0]);
    return [0,
            _J_[6],
            _J_[7],
            _J_[8],
            _J_[5],
            _J_[1],
            _J_[2],
            _J_[4],
            _J_[9],
            _J_[10],
            _J_[11],
            _J_[12]];
   }
   function Make(M){
    var
     bind = M[1],
     return$0 = M[2],
     map = M[3],
     _I_ = Make_general([0, bind, map, return$0]);
    return [0,
            _I_[6],
            _I_[7],
            _I_[5],
            _I_[1],
            _I_[2],
            _I_[4],
            _I_[9],
            _I_[10],
            _I_[11],
            _I_[12],
            _I_[8]];
   }
   function Make2_local(_E_){
    var bind = _E_[1], return$0 = _E_[3];
    function map_via_bind(ma, f){
     function _G_(a){
      var _H_ = caml_call1(f, a);
      return caml_call1(_E_[3], _H_);
     }
     var res = caml_call2(_E_[1], ma, _G_);
     return res;
    }
    var match = _E_[2];
    if(typeof match === "number")
     var map = map_via_bind;
    else
     var x = match[2], map = x;
    function symbol_bind(t, f){return caml_call2(bind, t, f);}
    function symbol_map(t, f){return caml_call2(map, t, f);}
    var
     Monad_infix = [0, symbol_bind, symbol_map],
     symbol_bind$0 = Monad_infix[1],
     symbol_map$0 = Monad_infix[2],
     symbol_bind$1 = Monad_infix[1],
     symbol_map$1 = Monad_infix[2];
    function both(a, b){
     var
      res =
        caml_call2
         (bind,
          a,
          function(a){
           var res = caml_call2(map, b, function(b){return [0, a, b];});
           return res;
          });
     return res;
    }
    var
     Open_on_rhs = [0],
     Let_syntax = [0, return$0, bind, map, both, Open_on_rhs],
     Let_syntax$0 = [0, return$0, symbol_bind$1, symbol_map$1, Let_syntax];
    function join(t){
     return caml_call2(symbol_bind$0, t, function(_F_){return _F_;});
    }
    function ignore_m(t){
     var res = caml_call2(map, t, function(param){return 0;});
     return res;
    }
    function loop(vs, param){
     if(! param) return caml_call1(return$0, caml_call1(Base_List0[19], vs));
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(v){return loop([0, v, vs], ts);});
    }
    function all(ts){return loop(0, ts);}
    function all_unit(param){
     if(! param) return caml_call1(return$0, 0);
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(param){return all_unit(ts);});
    }
    return [0,
            bind,
            return$0,
            ,
            map,
            Monad_infix,
            symbol_bind$0,
            symbol_map$0,
            Let_syntax$0,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function Make_local(M){
    var
     bind = M[1],
     return$0 = M[2],
     map = M[3],
     _D_ = Make2_local([0, bind, map, return$0]);
    return [0,
            _D_[6],
            _D_[7],
            _D_[5],
            _D_[1],
            _D_[2],
            _D_[4],
            _D_[9],
            _D_[10],
            _D_[11],
            _D_[12],
            _D_[8]];
   }
   function Of_monad_general(Monad, M){
    function return$0(a){
     var _C_ = caml_call1(Monad[3], a);
     return caml_call1(M[2], _C_);
    }
    function bind(t, f){
     function _y_(a){
      var _B_ = caml_call1(f, a);
      return caml_call1(M[1], _B_);
     }
     var _z_ = caml_call1(M[1], t), _A_ = caml_call2(Monad[1], _z_, _y_);
     return caml_call1(M[2], _A_);
    }
    var
     map =
       [0,
        -198771759,
        function(t, f){
         var _w_ = caml_call1(M[1], t), _x_ = caml_call2(Monad[2], _w_, f);
         return caml_call1(M[2], _x_);
        }];
    return Make_general([0, bind, map, return$0]);
   }
   function bind(a, f){return caml_call1(f, a);}
   function map(a, f){return caml_call1(f, a);}
   function symbol_map(a, f){return map(a, f);}
   function symbol_bind(a, f){return bind(a, f);}
   function return$0(_v_){return _v_;}
   function both(a, b){return [0, a, b];}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, bind, map, both, Open_on_rhs],
    _a_ = [0, return$0, symbol_bind, symbol_map, Let_syntax];
   function _b_(_u_){return 0;}
   function _c_(_t_){return _t_;}
   function _d_(_s_){return 0;}
   function _e_(_r_){return _r_;}
   var
    _f_ =
      [0,
       symbol_bind,
       symbol_map,
       [0, symbol_bind, symbol_map],
       bind,
       function(_q_){return _q_;},
       map,
       _e_,
       _d_,
       _c_,
       _b_,
       _a_];
   function _g_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[5],
     return$0 = Monad[6],
     map = Monad[7],
     _p_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _p_[6],
            _p_[7],
            _p_[8],
            _p_[5],
            _p_[1],
            _p_[2],
            _p_[4],
            _p_[9],
            _p_[10],
            _p_[11],
            _p_[12]];
   }
   function _h_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[5],
     return$0 = Monad[6],
     map = Monad[7],
     _o_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _o_[6],
            _o_[7],
            _o_[8],
            _o_[5],
            _o_[1],
            _o_[2],
            _o_[4],
            _o_[9],
            _o_[10],
            _o_[11],
            _o_[12]];
   }
   function _i_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[5],
     return$0 = Monad[6],
     map = Monad[7],
     _n_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _n_[6],
            _n_[7],
            _n_[8],
            _n_[5],
            _n_[1],
            _n_[2],
            _n_[4],
            _n_[9],
            _n_[10],
            _n_[11],
            _n_[12]];
   }
   function _j_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[4],
     return$0 = Monad[5],
     map = Monad[6],
     _m_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _m_[6],
            _m_[7],
            _m_[5],
            _m_[1],
            _m_[2],
            _m_[4],
            _m_[9],
            _m_[10],
            _m_[11],
            _m_[12],
            _m_[8]];
   }
   var
    Base_Monad =
      [0,
       Make,
       Make2,
       Make3,
       Make_indexed,
       Make_local,
       function(_k_){
        var _l_ = Make2_local(_k_);
        return [0,
                _l_[6],
                _l_[7],
                _l_[8],
                _l_[5],
                _l_[1],
                _l_[2],
                _l_[4],
                _l_[9],
                _l_[10],
                _l_[11],
                _l_[12]];
       },
       _j_,
       _i_,
       _h_,
       _g_,
       _f_];
   runtime.caml_register_global(1, Base_Monad, "Base__Monad");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__T
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_T = [0];
   runtime.caml_register_global(0, Base_T, "Base__T");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Applicative_intf = [0];
   runtime.caml_register_global
    (0, Base_Applicative_intf, "Base__Applicative_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative
//# unitInfo: Requires: Base__Applicative_intf, Base__Import, Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_List0 = global_data.Base__List0;
   function S_to_S2(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S(T, X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S3(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S3_to_S2(T, X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S3_to_S(T1, T2, X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Make3(_X_){
    var return$0 = _X_[1], symbol = _X_[2];
    function derived_map(t, f){
     return caml_call2(symbol, caml_call1(return$0, f), t);
    }
    var match = _X_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function map2(ta, tb, f){
     return caml_call2(symbol, caml_call2(map, ta, f), tb);
    }
    function map3(ta, tb, tc, f){
     return caml_call2
             (symbol, caml_call2(symbol, caml_call2(map, ta, f), tb), tc);
    }
    function all(ts){
     var _Z_ = caml_call1(return$0, 0);
     function ___(x, xs){return [0, x, xs];}
     function _$_(_aa_){return function(_ab_){return map2(_aa_, _ab_, ___);};}
     return caml_call3(Base_List0[20], ts, _$_, _Z_);
    }
    function both(ta, tb){
     return map2(ta, tb, function(a, b){return [0, a, b];});
    }
    function symbol$0(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(param, y){return y;}),
                u),
              v);
    }
    function symbol$1(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(x, param){return x;}),
                u),
              v);
    }
    function all_unit(ts){
     var _Y_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _Y_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make3([0, return$0, apply, map]);
   }
   function Make(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make2([0, return$0, apply, map]);
   }
   function Make_let_syntax3(X, Intf, Impl){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     return$1 = X[1],
     map$0 = X[2],
     both$0 = X[3],
     symbol$2 = X[4],
     symbol$3 = X[5],
     symbol$4 = X[6],
     symbol_map$0 = X[7],
     Let_syntax =
       [0,
        return$1,
        map$0,
        both$0,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol_map$0,
        Impl],
     Let_syntax$0 =
       [0,
        return$0,
        map,
        both,
        symbol,
        symbol$0,
        symbol$1,
        symbol_map,
        Let_syntax];
    return [0, Let_syntax$0];
   }
   function Make_let_syntax2(X, Intf, Impl){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7];
    return Make_let_syntax3
            ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
             Intf,
             Impl);
   }
   function Make3_using_map2(_O_){
    var return$0 = _O_[1], map2 = _O_[2];
    function symbol(tf, ta){
     return caml_call3(map2, tf, ta, function(f, a){return caml_call1(f, a);});
    }
    function derived_map(t, f){return symbol(caml_call1(return$0, f), t);}
    var match = _O_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function both(ta, tb){
     return caml_call3(map2, ta, tb, function(a, b){return [0, a, b];});
    }
    function map3(ta, tb, tc, f){
     function _W_(fab, c){return caml_call1(fab, c);}
     return caml_call3(map2, caml_call3(map2, ta, tb, f), tc, _W_);
    }
    function all(ts){
     var _Q_ = caml_call1(return$0, 0);
     function _R_(x, xs){return [0, x, xs];}
     function _S_(_T_){
      var _U_ = caml_call1(map2, _T_);
      return function(_V_){return caml_call2(_U_, _V_, _R_);};
     }
     return caml_call3(Base_List0[20], ts, _S_, _Q_);
    }
    function symbol$0(u, v){
     return caml_call3(map2, u, v, function(param, y){return y;});
    }
    function symbol$1(u, v){
     return caml_call3(map2, u, v, function(x, param){return x;});
    }
    function all_unit(ts){
     var _P_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _P_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make3_using_map2([0, return$0, map2, map]);
   }
   function Make_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make2_using_map2([0, return$0, map2, map]);
   }
   function Make3_using_map2_local(_E_){
    var return$0 = _E_[1], map2 = _E_[2];
    function symbol(tf, ta){
     return caml_call3(map2, tf, ta, function(f, a){return caml_call1(f, a);});
    }
    function derived_map(t, f){
     function _N_(param){return f;}
     return caml_call3(map2, caml_call1(return$0, 0), t, _N_);
    }
    var match = _E_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var map$0 = match[2], map = map$0;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function both(ta, tb){
     return caml_call3(map2, ta, tb, function(a, b){return [0, a, b];});
    }
    function map3(ta, tb, tc, f){
     function _M_(param, c){
      var b = param[2], a = param[1];
      return caml_call3(f, a, b, c);
     }
     var res = caml_call3(map2, both(ta, tb), tc, _M_);
     return res;
    }
    function all(ts){
     var _G_ = caml_call1(return$0, 0);
     function _H_(x, xs){return [0, x, xs];}
     function _I_(_J_){
      var _K_ = caml_call1(map2, _J_);
      return function(_L_){return caml_call2(_K_, _L_, _H_);};
     }
     return caml_call3(Base_List0[20], ts, _I_, _G_);
    }
    function symbol$0(u, v){
     return caml_call3(map2, u, v, function(param, y){return y;});
    }
    function symbol$1(u, v){
     return caml_call3(map2, u, v, function(x, param){return x;});
    }
    function all_unit(ts){
     var _F_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _F_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2_using_map2_local(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make3_using_map2_local([0, return$0, map2, map]);
   }
   function Make_using_map2_local(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make2_using_map2_local([0, return$0, map2, map]);
   }
   function Of_monad2(M){
    var return$0 = M[6];
    function apply(mf, mx){
     function _D_(f){return caml_call2(M[7], mx, f);}
     return caml_call2(M[5], mf, _D_);
    }
    var map = [0, -198771759, M[7]];
    return Make2([0, return$0, apply, map]);
   }
   function Of_monad(M){
    var
     symbol_bind = M[1],
     symbol_map = M[2],
     Monad_infix = M[3],
     bind = M[4],
     return$0 = M[5],
     map = M[6],
     join = M[7],
     ignore_m = M[8],
     all = M[9],
     all_unit = M[10],
     Let_syntax = M[11];
    return Of_monad2
            ([0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]);
   }
   function Compose(F, G){
    function return$0(a){
     var _C_ = caml_call1(F[1], a);
     return caml_call1(G[1], _C_);
    }
    function apply(tf, tx){
     var _B_ = caml_call2(G[2], tf, F[8]);
     return caml_call2(G[8], _B_, tx);
    }
    function custom_map(t, f){
     var _y_ = F[2];
     function _z_(_A_){return caml_call2(_y_, _A_, f);}
     return caml_call2(G[2], t, _z_);
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Pair(F, G){
    function return$0(a){
     var _x_ = caml_call1(G[1], a);
     return [0, caml_call1(F[1], a), _x_];
    }
    function apply(tf, tx){
     var
      _s_ = caml_call1(Base_Import[127], tx),
      _t_ = caml_call1(Base_Import[127], tf),
      _u_ = caml_call2(G[8], _t_, _s_),
      _v_ = caml_call1(Base_Import[125], tx),
      _w_ = caml_call1(Base_Import[125], tf);
     return [0, caml_call2(F[8], _w_, _v_), _u_];
    }
    function custom_map(t, f){
     var
      _p_ = caml_call1(Base_Import[127], t),
      _q_ = caml_call2(G[2], _p_, f),
      _r_ = caml_call1(Base_Import[125], t);
     return [0, caml_call2(F[2], _r_, f), _q_];
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function return$0(_o_){return _o_;}
   function map2(a, b, f){return caml_call2(f, a, b);}
   var
    map = [0, -198771759, function(a, f){return caml_call1(f, a);}],
    include = Make_using_map2_local([0, return$0, map2, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply = include[8],
    map2$0 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13],
    Ident =
      [0,
       return$1,
       map$0,
       both,
       symbol,
       symbol$0,
       symbol$1,
       symbol_map,
       apply,
       map2$0,
       map3,
       all,
       all_unit,
       Applicative_infix];
   function _a_(_l_, _k_, _j_){
    var _m_ = Make_let_syntax3(_l_, _k_, _j_)[1], _n_ = _m_[8];
    return [0,
            [0,
             _m_[1],
             _m_[4],
             _m_[5],
             _m_[6],
             _m_[7],
             [0, _n_[1], _n_[2], _n_[3], _n_[8]]]];
   }
   function _b_(_g_, _f_, _e_){
    var _h_ = Make_let_syntax2(_g_, _f_, _e_)[1], _i_ = _h_[8];
    return [0,
            [0,
             _h_[1],
             _h_[4],
             _h_[5],
             _h_[6],
             _h_[7],
             [0, _i_[1], _i_[2], _i_[3], _i_[8]]]];
   }
   var
    Base_Applicative =
      [0,
       Ident,
       S2_to_S,
       S_to_S2,
       S3_to_S2,
       S3_to_S,
       S2_to_S3,
       Make,
       Make2,
       Make3,
       function(X, Intf, Impl){
        var
         return$0 = X[1],
         map = X[2],
         both = X[3],
         symbol = X[4],
         symbol$0 = X[5],
         symbol$1 = X[6],
         symbol_map = X[7],
         _c_ =
           Make_let_syntax2
             ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
              Intf,
              Impl)
            [1],
         _d_ = _c_[8];
        return [0,
                [0,
                 _c_[1],
                 _c_[4],
                 _c_[5],
                 _c_[6],
                 _c_[7],
                 [0, _d_[1], _d_[2], _d_[3], _d_[8]]]];
       },
       _b_,
       _a_,
       Make_using_map2,
       Make2_using_map2,
       Make3_using_map2,
       Make_using_map2_local,
       Make2_using_map2_local,
       Make3_using_map2_local,
       Of_monad,
       Of_monad2,
       Compose,
       Pair];
   runtime.caml_register_global(2, Base_Applicative, "Base__Applicative");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparator
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var Module = [0], _a_ = [0, "_"];
   function of_module(M){return M[1];}
   function to_module(t){return [0, t];}
   function make(compare, sexp_of_t){
    var comparator = [0, compare, sexp_of_t];
    return [0, comparator];
   }
   function S_to_S1(S){var comparator = S[1]; return [0, comparator];}
   function Make1(M){
    var comparator = [0, M[1], M[2]];
    return [0, comparator];
   }
   var compare = runtime.caml_compare;
   function sexp_of_t(param){return _a_;}
   var
    include = Make1([0, compare, sexp_of_t]),
    comparator = include[1],
    Poly = [0, comparator];
   function Derived(M){
    function comparator(a){
     var _e_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _e_];
    }
    return [0, comparator];
   }
   function Derived2(M){
    function comparator(a, b){
     var _d_ = caml_call2(M[2], a[2], b[2]);
     return [0, caml_call2(M[1], a[1], b[1]), _d_];
    }
    return [0, comparator];
   }
   function Derived_phantom(M){
    function comparator(a){
     var _c_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _c_];
    }
    return [0, comparator];
   }
   function Derived2_phantom(M){
    function comparator(a, b){
     var _b_ = caml_call2(M[2], a[2], b[2]);
     return [0, caml_call2(M[1], a[1], b[1]), _b_];
    }
    return [0, comparator];
   }
   var
    Base_Comparator =
      [0,
       make,
       Poly,
       Module,
       of_module,
       to_module,
       S_to_S1,
       function(M){var comparator = [0, M[1], M[2]]; return [0, comparator];},
       Make1,
       Derived,
       Derived2,
       Derived_phantom,
       Derived2_phantom];
   runtime.caml_register_global(1, Base_Comparator, "Base__Comparator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparisons
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparisons = [0];
   runtime.caml_register_global(0, Base_Comparisons, "Base__Comparisons");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either0
//# unitInfo: Requires: Base__Hash, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_First$0 = "First",
    cst_Second$0 = "Second",
    cst_first = "first",
    cst_second = "second",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_017 = "either0.ml.t",
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    cst_Second = cst_Second$0,
    cst_First = cst_First$0,
    _a_ = [0, cst_First$0],
    _b_ = [0, cst_Second$0];
   function compare_local(cmp_f, cmp_s, a_007, b_008){
    if(a_007 === b_008) return 0;
    if(0 === a_007[0]){
     var a_009 = a_007[1];
     if(0 !== b_008[0]) return -1;
     var b_010 = b_008[1];
     return caml_call2(cmp_f, a_009, b_010);
    }
    var a_011 = a_007[1];
    if(0 === b_008[0]) return 1;
    var b_012 = b_008[1];
    return caml_call2(cmp_s, a_011, b_012);
   }
   function compare(cmp_f, cmp_s, a_001, b_002){
    if(a_001 === b_002) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(cmp_f, a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call2(cmp_s, a_005, b_006);
   }
   function hash_fold_t(hash_fold_f, hash_fold_s, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_f, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_s, hsv$1, a0$0);
   }
   function t_of_sexp(of_f_013, of_s_014, sexp_019){
    a:
    {
     if(0 === sexp_019[0]){
      var _c_ = sexp_019[1];
      b:
      if(caml_string_notequal(_c_, cst_First$0)){
       if(caml_string_notequal(_c_, cst_Second$0)){
        if(! caml_string_notequal(_c_, cst_first)) break b;
        if(caml_string_notequal(_c_, cst_second)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_017, sexp_019);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_017, sexp_019);
     }
     var _d_ = sexp_019[1];
     if(! _d_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_017, sexp_019);
     var _e_ = _d_[1];
     if(0 !== _e_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_017, sexp_019);
     var tag_020 = _e_[1];
     b:
     if(caml_string_notequal(tag_020, cst_First$0)){
      if(caml_string_notequal(tag_020, cst_Second$0)){
       if(! caml_string_notequal(tag_020, cst_first)) break b;
       if(caml_string_notequal(tag_020, cst_second)) break a;
      }
      var sexp_args_026 = _d_[2];
      if(sexp_args_026 && ! sexp_args_026[2]){
       var
        arg0_027 = sexp_args_026[1],
        res0_028 = caml_call1(of_s_014, arg0_027);
       return [1, res0_028];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_017,
               tag_020,
               sexp_019);
     }
     var sexp_args_021 = _d_[2];
     if(sexp_args_021 && ! sexp_args_021[2]){
      var
       arg0_022 = sexp_args_021[1],
       res0_023 = caml_call1(of_f_013, arg0_022);
      return [0, res0_023];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_017,
              tag_020,
              sexp_019);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_017, sexp_019);
   }
   function sexp_of_t(of_f_031, of_s_032, param){
    if(0 === param[0]){
     var arg0_033 = param[1], res0_034 = caml_call1(of_f_031, arg0_033);
     return [1, [0, _a_, [0, res0_034, 0]]];
    }
    var arg0_035 = param[1], res0_036 = caml_call1(of_s_032, arg0_035);
    return [1, [0, _b_, [0, res0_036, 0]]];
   }
   function t_sexp_grammar(f_sexp_grammar, s_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_First, [0, [0, f_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Second, [0, [0, s_sexp_grammar, 0]]]], 0]]]];
   }
   var
    Base_Either0 =
      [0,
       compare_local,
       compare,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar];
   runtime.caml_register_global(15, Base_Either0, "Base__Either0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Field
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function opaque_identity(_b_){return _b_;}
   var For_generated_code = [0, opaque_identity];
   function name(param){return param[2];}
   function get(param, r){return caml_call1(param[4], r);}
   function fset(param, r, v){return caml_call2(param[5], r, v);}
   function setter(param){return param[3];}
   function map(param, r, f){
    var _a_ = caml_call1(f, caml_call1(param[4], r));
    return caml_call2(param[5], r, _a_);
   }
   function updater(field){
    var match = field[3];
    if(! match) return 0;
    var setter = match[1];
    return [0,
            function(r, f){
             return caml_call2
                     (setter, r, caml_call1(f, caml_call1(field[4], r)));
            }];
   }
   var
    Base_Field =
      [0, For_generated_code, name, get, fset, setter, map, updater];
   runtime.caml_register_global(0, Base_Field, "Base__Field");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_conversions
//# unitInfo: Requires: Base__Import, Base__Int0, Base__Printf, Base__Sys0, Base__Word_size, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_int$3 = "int",
    cst_int32$3 = "int32",
    cst_int64$3 = "int64",
    cst_nativeint$2 = "nativeint",
    cst_src_int_conversions_ml = "src/int_conversions.ml",
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Word_size = global_data.Base__Word_size,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Int0 = global_data.Base__Int0,
    cst_int63 = "int63",
    cst_int64$2 = cst_int64$3,
    cst_nativeint$1 = cst_nativeint$2,
    cst_int64$1 = cst_int64$3,
    cst_int32$2 = cst_int32$3,
    cst_nativeint$0 = cst_nativeint$2,
    cst_int32$1 = cst_int32$3,
    cst_int64$0 = cst_int64$3,
    cst_int$2 = cst_int$3,
    cst_nativeint = cst_nativeint$2,
    cst_int$1 = cst_int$3,
    cst_int64 = cst_int64$3,
    _d_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_int$0 = cst_int$3,
    cst_int32$0 = cst_int32$3,
    cst_int32 = cst_int32$3,
    cst_int = cst_int$3,
    _a_ =
      [0,
       [11,
        "conversion from ",
        [2,
         0,
         [11,
          " to ",
          [2, 0, [11, " failed: ", [2, 0, [11, " is out of range", 0]]]]]]],
       "conversion from %s to %s failed: %s is out of range"],
    _k_ = [0, cst_src_int_conversions_ml, 19, 9],
    _j_ = [0, cst_src_int_conversions_ml, 82, 9],
    _i_ = [0, cst_src_int_conversions_ml, 103, 9],
    _h_ = [0, cst_src_int_conversions_ml, 155, 9],
    _g_ = [0, cst_src_int_conversions_ml, 183, 9];
   function convert_failure(x, a, b, to_string){
    var _H_ = caml_call1(to_string, x);
    return caml_call5(Base_Printf[6], _a_, a, b, _H_, 0);
   }
   var
    num_bits_int = Base_Sys0[8],
    num_bits_nativeint = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    num_bits_int32 = 32,
    num_bits_int64 = 64;
   if(63 !== num_bits_int && 31 !== num_bits_int && 32 !== num_bits_int)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   var
    min_int32 = Stdlib_Int32[10],
    max_int32 = Stdlib_Int32[9],
    min_int64 = Stdlib_Int64[10],
    max_int64 = Stdlib_Int64[9],
    min_nativeint = Stdlib_Nativeint[11],
    max_nativeint = Stdlib_Nativeint[10],
    int64_to_string = Stdlib_Int64[14],
    nativeint_to_string = Stdlib_Nativeint[15],
    _b_ = Base_Import[85][33],
    _c_ = Stdlib_Int32[14];
   function int32_to_int_trunc(_G_){return _G_;}
   function int_to_int32_trunc(_F_){return _F_;}
   var
    int_is_representable_as_int32 =
      num_bits_int <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _D_ = caml_call2(Base_Import[228], min_int32, x) <= 0 ? 1 : 0,
          _E_ =
            _D_
             ? caml_call2(Base_Import[228], x, max_int32) <= 0 ? 1 : 0
             : _D_;
         return _E_;
        };
   if(32 <= num_bits_int)
    var int32_is_representable_as_int = function(param){return 1;};
   else
    var
     min$4 = Base_Int0[7],
     max$4 = Base_Int0[6],
     int32_is_representable_as_int =
       function(x){
        var
         _B_ = caml_call2(Base_Import[229], min$4, x) <= 0 ? 1 : 0,
         _C_ = _B_ ? caml_call2(Base_Import[229], x, max$4) <= 0 ? 1 : 0 : _B_;
        return _C_;
       };
   function int_to_int32(x){
    return int_is_representable_as_int32(x) ? [0, x] : 0;
   }
   function int32_to_int(x){
    return int32_is_representable_as_int(x) ? [0, x] : 0;
   }
   function int_to_int32_exn(x){
    return int_is_representable_as_int32(x)
            ? x
            : convert_failure(x, cst_int, cst_int32, _b_);
   }
   function int32_to_int_exn(x){
    return int32_is_representable_as_int(x)
            ? x
            : convert_failure(x, cst_int32$0, cst_int$0, _c_);
   }
   if(num_bits_int >= 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   var
    int_to_int64 = caml_int64_of_int32,
    int64_to_int_trunc = caml_int64_to_int32,
    min = caml_int64_of_int32(Base_Int0[7]),
    max = caml_int64_of_int32(Base_Int0[6]);
   function int64_is_representable_as_int(x){
    var
     _z_ = caml_call2(Base_Import[230], min, x) <= 0 ? 1 : 0,
     _A_ = _z_ ? caml_call2(Base_Import[230], x, max) <= 0 ? 1 : 0 : _z_;
    return _A_;
   }
   function int64_to_int(x){
    return int64_is_representable_as_int(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int_exn(x){
    return int64_is_representable_as_int(x)
            ? caml_int64_to_int32(x)
            : convert_failure
              (runtime.caml_int64_add(x, _d_),
               cst_int64,
               cst_int$1,
               int64_to_string);
   }
   if(num_bits_int > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   function int_to_nativeint(_y_){return _y_;}
   function nativeint_to_int_trunc(_x_){return _x_;}
   if(num_bits_nativeint <= num_bits_int)
    var _e_ = function(param){return 1;};
   else
    var
     min$3 = Base_Int0[7],
     max$3 = Base_Int0[6],
     _e_ =
       function(x){
        var
         _v_ = caml_call2(Base_Import[231], min$3, x) <= 0 ? 1 : 0,
         _w_ = _v_ ? caml_call2(Base_Import[231], x, max$3) <= 0 ? 1 : 0 : _v_;
        return _w_;
       };
   function nativeint_to_int(x){return _e_(x) ? [0, x] : 0;}
   function nativeint_to_int_exn(x){
    return _e_(x)
            ? x
            : convert_failure
              (x, cst_nativeint, cst_int$2, nativeint_to_string);
   }
   var
    int32_to_int64 = caml_int64_of_int32,
    int64_to_int32_trunc = caml_int64_to_int32,
    min$0 = caml_int64_of_int32(min_int32),
    max$0 = caml_int64_of_int32(max_int32);
   function int64_is_representable_as_int3(x){
    var
     _t_ = caml_call2(Base_Import[230], min$0, x) <= 0 ? 1 : 0,
     _u_ = _t_ ? caml_call2(Base_Import[230], x, max$0) <= 0 ? 1 : 0 : _t_;
    return _u_;
   }
   function int64_to_int32(x){
    return int64_is_representable_as_int3(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int32_exn(x){
    return int64_is_representable_as_int3(x)
            ? caml_int64_to_int32(x)
            : convert_failure(x, cst_int64$0, cst_int32$1, int64_to_string);
   }
   if(32 > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   function int32_to_nativeint(_s_){return _s_;}
   function nativeint_to_int32_trunc(_r_){return _r_;}
   var
    _f_ =
      num_bits_nativeint <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _p_ = caml_call2(Base_Import[231], min_int32, x) <= 0 ? 1 : 0,
          _q_ =
            _p_
             ? caml_call2(Base_Import[231], x, max_int32) <= 0 ? 1 : 0
             : _p_;
         return _q_;
        };
   function nativeint_to_int32(x){return _f_(x) ? [0, x] : 0;}
   function nativeint_to_int32_exn(x){
    return _f_(x)
            ? x
            : convert_failure
              (x, cst_nativeint$0, cst_int32$2, nativeint_to_string);
   }
   if(num_bits_nativeint > 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   var
    int64_to_nativeint_trunc = caml_int64_to_int32,
    nativeint_to_int64 = caml_int64_of_int32;
   if(64 <= num_bits_nativeint)
    var int64_is_representable_as_nati = function(param){return 1;};
   else
    var
     min$2 = caml_int64_of_int32(min_nativeint),
     max$2 = caml_int64_of_int32(max_nativeint),
     int64_is_representable_as_nati =
       function(x){
        var
         _n_ = caml_call2(Base_Import[230], min$2, x) <= 0 ? 1 : 0,
         _o_ = _n_ ? caml_call2(Base_Import[230], x, max$2) <= 0 ? 1 : 0 : _n_;
        return _o_;
       };
   function int64_to_nativeint(x){
    return int64_is_representable_as_nati(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_nativeint_exn(x){
    return int64_is_representable_as_nati(x)
            ? caml_int64_to_int32(x)
            : convert_failure
              (x, cst_int64$1, cst_nativeint$1, int64_to_string);
   }
   var
    min$1 = caml_int64_shift_right(min_int64, 1),
    max$1 = caml_int64_shift_right(max_int64, 1);
   function int64_is_representable_as_int6(x){
    var
     _l_ = caml_call2(Base_Import[230], min$1, x) <= 0 ? 1 : 0,
     _m_ = _l_ ? caml_call2(Base_Import[230], x, max$1) <= 0 ? 1 : 0 : _l_;
    return _m_;
   }
   function int64_fit_on_int63_exn(x){
    return int64_is_representable_as_int6(x)
            ? 0
            : convert_failure(x, cst_int64$2, cst_int63, int64_to_string);
   }
   var
    Base_Int_conversions =
      [0,
       int_to_int32,
       int_to_int32_exn,
       int_to_int32_trunc,
       int_to_int64,
       int_to_nativeint,
       int32_to_int,
       int32_to_int_exn,
       int32_to_int_trunc,
       int32_to_int64,
       int32_to_nativeint,
       int32_is_representable_as_int,
       int64_to_int,
       int64_to_int_exn,
       int64_to_int_trunc,
       int64_to_int32,
       int64_to_int32_exn,
       int64_to_int32_trunc,
       int64_to_nativeint,
       int64_to_nativeint_exn,
       int64_to_nativeint_trunc,
       int64_fit_on_int63_exn,
       int64_is_representable_as_int6,
       nativeint_to_int,
       nativeint_to_int_exn,
       nativeint_to_int_trunc,
       nativeint_to_int32,
       nativeint_to_int32_exn,
       nativeint_to_int32_trunc,
       nativeint_to_int64,
       num_bits_int,
       num_bits_int32,
       num_bits_int64,
       num_bits_nativeint];
   runtime.caml_register_global
    (33, Base_Int_conversions, "Base__Int_conversions");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar0
//# unitInfo: Requires: Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    succ = Stdlib_Uchar[5],
    pred = Stdlib_Uchar[6],
    is_valid = Stdlib_Uchar[7],
    is_char = Stdlib_Uchar[11],
    unsafe_to_char = Stdlib_Uchar[14],
    unsafe_of_int = Stdlib_Uchar[9],
    of_int = Stdlib_Uchar[8],
    to_int = Stdlib_Uchar[10],
    of_char = Stdlib_Uchar[12],
    compare = Stdlib_Uchar[16],
    equal = Stdlib_Uchar[15],
    min_value = Stdlib_Uchar[1],
    max_value = Stdlib_Uchar[2],
    byte_order_mark = Stdlib_Uchar[3],
    replacement_char = Stdlib_Uchar[4],
    utf_8_byte_length = Stdlib_Uchar[23],
    utf_16_byte_length = Stdlib_Uchar[24],
    utf_decode_is_valid = Stdlib_Uchar[18],
    utf_decode_uchar = Stdlib_Uchar[19],
    utf_decode_length = Stdlib_Uchar[20],
    utf_decode = Stdlib_Uchar[21],
    utf_decode_invalid = Stdlib_Uchar[22],
    Base_Uchar0 =
      [0,
       succ,
       pred,
       is_valid,
       is_char,
       unsafe_to_char,
       unsafe_of_int,
       of_int,
       to_int,
       of_char,
       compare,
       equal,
       min_value,
       max_value,
       byte_order_mark,
       replacement_char,
       utf_8_byte_length,
       utf_16_byte_length,
       utf_decode_is_valid,
       utf_decode_uchar,
       utf_decode_length,
       utf_decode,
       utf_decode_invalid];
   runtime.caml_register_global(1, Base_Uchar0, "Base__Uchar0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String0
//# unitInfo: Requires: Base__Char0, Base__Import0, Base__Int_conversions, Base__Sys0, Base__Uchar0, Stdlib, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Base_Import0 = global_data.Base__Import0,
    Base_Char0 = global_data.Base__Char0,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Uchar0 = global_data.Base__Uchar0,
    Stdlib = global_data.Stdlib,
    Base_Sys0 = global_data.Base__Sys0,
    String = [0],
    max_length = Base_Sys0[10],
    symbol = Base_Import0[112],
    capitalize = Stdlib_StringLabels[28],
    compare = Stdlib_StringLabels[10],
    escaped = Stdlib_StringLabels[25],
    lowercase = Stdlib_StringLabels[27],
    make = Stdlib_StringLabels[1],
    sub = Stdlib_StringLabels[16],
    uncapitalize = Stdlib_StringLabels[29],
    uppercase = Stdlib_StringLabels[26],
    is_valid_utf_8 = Stdlib_StringLabels[44],
    is_valid_utf_16le = Stdlib_StringLabels[48],
    is_valid_utf_16be = Stdlib_StringLabels[46],
    cst_index_out_of_bounds = "index out of bounds";
   function get_utf_8_uchar(t, byte_pos){
    return caml_call2(Stdlib_StringLabels[43], t, byte_pos);
   }
   function get_utf_16le_uchar(t, byte_pos){
    return caml_call2(Stdlib_StringLabels[47], t, byte_pos);
   }
   function get_utf_16be_uchar(t, byte_pos){
    return caml_call2(Stdlib_StringLabels[45], t, byte_pos);
   }
   function get_utf_32_uchar(get_int32, t, byte_pos){
    var
     len = caml_ml_string_length(t),
     _j_ = 0 <= byte_pos ? 1 : 0,
     _k_ = _j_ ? byte_pos < len ? 1 : 0 : _j_;
    if(! _k_)
     throw caml_maybe_attach_backtrace
            ([0, Stdlib[6], cst_index_out_of_bounds], 1);
    var bytes_read = caml_call2(Base_Import0[93], len, byte_pos);
    if(2 >= bytes_read - 1 >>> 0)
     return caml_call1(Base_Uchar0[22], bytes_read);
    var int32 = caml_call2(get_int32, t, byte_pos);
    if(! caml_call1(Base_Int_conversions[11], int32))
     return caml_call1(Base_Uchar0[22], 4);
    var int$0 = caml_call1(Base_Int_conversions[8], int32);
    if(! caml_call1(Base_Uchar0[3], int$0))
     return caml_call1(Base_Uchar0[22], 4);
    var _l_ = caml_call1(Base_Uchar0[6], int$0);
    return caml_call2(Base_Uchar0[21], 4, _l_);
   }
   function get_utf_32le_uchar(t, byte_pos){
    return get_utf_32_uchar(Stdlib_StringLabels[61], t, byte_pos);
   }
   function get_utf_32be_uchar(t, byte_pos){
    return get_utf_32_uchar(Stdlib_StringLabels[60], t, byte_pos);
   }
   function concat(opt, l){
    if(opt) var sth = opt[1], sep = sth; else var sep = cst$0;
    if(! l) return cst;
    if(l[2]) return caml_call2(Stdlib_StringLabels[7], sep, l);
    var x = l[1];
    return x;
   }
   function iter(t, f){
    var
     _h_ = caml_call2(Base_Import0[93], caml_ml_string_length(t), 1),
     _g_ = 0;
    if(_h_ >= 0){
     var i = _g_;
     for(;;){
      caml_call1(f, runtime.caml_string_unsafe_get(t, i));
      var _i_ = i + 1 | 0;
      if(_h_ === i) break;
      var i = _i_;
     }
    }
    return 0;
   }
   function back_up_at_newline(t, pos, eol){
    a:
    {
     if(0 < pos[1]){
      var _e_ = caml_string_get(t, caml_call2(Base_Import0[93], pos[1], 1));
      if(caml_call2(Base_Char0[12], _e_, 13)){var _f_ = 2; break a;}
     }
     var _f_ = 1;
    }
    pos[1] = caml_call2(Base_Import0[93], pos[1], _f_);
    eol[1] = caml_call2(Base_Import0[91], pos[1], 1);
    return;
   }
   function split_lines(t){
    var n = caml_ml_string_length(t);
    if(0 === n) return 0;
    var
     pos = [0, caml_call2(Base_Import0[93], n, 1)],
     eol = [0, n],
     ac = [0, 0],
     _a_ = caml_string_get(t, pos[1]);
    if(caml_call2(Base_Char0[12], _a_, 10)) back_up_at_newline(t, pos, eol);
    for(;;){
     if(0 > pos[1]){
      var _d_ = ac[1];
      return [0, caml_call3(sub, t, 0, eol[1]), _d_];
     }
     var _b_ = caml_string_get(t, pos[1]);
     if(caml_call2(Base_Char0[12], _b_, 10)){
      var start = caml_call2(Base_Import0[91], pos[1], 1), _c_ = ac[1];
      ac[1] =
       [0,
        caml_call3(sub, t, start, caml_call2(Base_Import0[93], eol[1], start)),
        _c_];
      back_up_at_newline(t, pos, eol);
     }
     else
      pos[1] += -1;
    }
   }
   var
    Base_String0 =
      [0,
       String,
       max_length,
       symbol,
       capitalize,
       compare,
       escaped,
       lowercase,
       make,
       sub,
       uncapitalize,
       uppercase,
       is_valid_utf_8,
       is_valid_utf_16le,
       is_valid_utf_16be,
       get_utf_8_uchar,
       get_utf_16le_uchar,
       get_utf_16be_uchar,
       get_utf_32le_uchar,
       get_utf_32be_uchar,
       concat,
       iter,
       split_lines];
   runtime.caml_register_global(10, Base_String0, "Base__String0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position0
//# unitInfo: Requires: Base__Comparator, Base__Hash, Base__Import, Base__Int0, Base__String0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = ":";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Import = global_data.Base__Import,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Base_Hash = global_data.Base__Hash,
    Base_Comparator = global_data.Base__Comparator,
    _a_ = [0, "pos_cnum"],
    _b_ = [0, "pos_bol"],
    _c_ = [0, "pos_lnum"],
    _d_ = [0, "pos_fname"];
   function compare_local(a_001, b_002){
    if(a_001 === b_002) return 0;
    var n = caml_call2(Base_Import[260], a_001[1], b_002[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Base_Import[256], a_001[2], b_002[2]);
    if(0 !== n$0) return n$0;
    var n$1 = caml_call2(Base_Import[256], a_001[3], b_002[3]);
    return 0 === n$1 ? caml_call2(Base_Import[256], a_001[4], b_002[4]) : n$1;
   }
   function compare(a, b){return compare_local(a, b);}
   function hash_fold_t(hsv, arg){
    var
     hsv$0 = caml_call2(Base_Import[208], hsv, arg[1]),
     hsv$1 = caml_call2(Base_Import[206], hsv$0, arg[2]),
     hsv$2 = caml_call2(Base_Import[206], hsv$1, arg[3]);
    return caml_call2(Base_Import[206], hsv$2, arg[4]);
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function sexp_of_t(param){
    var
     pos_cnum_010 = param[4],
     pos_bol_008 = param[3],
     pos_lnum_006 = param[2],
     pos_fname_004 = param[1],
     arg_011 = caml_call1(Base_Import[139], pos_cnum_010),
     bnds_003 = [0, [1, [0, _a_, [0, arg_011, 0]]], 0],
     arg_009 = caml_call1(Base_Import[139], pos_bol_008),
     bnds_003$0 = [0, [1, [0, _b_, [0, arg_009, 0]]], bnds_003],
     arg_007 = caml_call1(Base_Import[139], pos_lnum_006),
     bnds_003$1 = [0, [1, [0, _c_, [0, arg_007, 0]]], bnds_003$0],
     arg_005 = caml_call1(Base_Import[136], pos_fname_004),
     bnds_003$2 = [0, [1, [0, _d_, [0, arg_005, 0]]], bnds_003$1];
    return [1, bnds_003$2];
   }
   var
    T = [0, compare_local, compare, hash_fold_t, hash, sexp_of_t],
    compare_local$0 = T[1],
    compare$0 = T[2],
    hash_fold_t$0 = T[3],
    hash$0 = T[4],
    include = caml_call1(Base_Comparator[7], [0, T[2], T[5]]),
    comparator = include[1];
   function make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol){
    var
     _e_ = caml_call2(Base_Import[93], pos_cnum, pos_bol),
     _f_ = [0, cst, [0, caml_call1(Base_Int0[1], _e_), 0]],
     _g_ =
       [0,
        pos_fname,
        [0, cst$0, [0, caml_call1(Base_Int0[1], pos_lnum), _f_]]];
    return caml_call2(Base_String0[20], 0, _g_);
   }
   function to_string(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1];
    return make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol);
   }
   function sexp_of_t$0(t){return [0, to_string(t)];}
   var
    Base_Source_code_position0 =
      [0,
       T,
       compare_local$0,
       compare$0,
       hash_fold_t$0,
       hash$0,
       comparator,
       make_location_string,
       to_string,
       sexp_of_t$0];
   runtime.caml_register_global
    (11, Base_Source_code_position0, "Base__Source_code_position0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Invariant_intf = [0];
   runtime.caml_register_global
    (0, Base_Invariant_intf, "Base__Invariant_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List1
//# unitInfo: Requires: Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0,
    hd_exn = Base_List0[1],
    rev_append = Base_List0[2],
    tl_exn = Base_List0[3],
    unzip = Base_List0[4],
    length = Base_List0[5],
    exists = Base_List0[6],
    exists2_ok = Base_List0[7],
    fold = Base_List0[8],
    fold2_ok = Base_List0[9],
    for_all = Base_List0[10],
    for_all2_ok = Base_List0[11],
    iter = Base_List0[12],
    iter2_ok = Base_List0[13],
    nontail_map = Base_List0[14],
    nontail_mapi = Base_List0[15],
    partition = Base_List0[16],
    rev_map = Base_List0[17],
    rev_map2_ok = Base_List0[18],
    rev = Base_List0[19],
    fold_right = Base_List0[20],
    fold_right2_ok = Base_List0[21];
   function is_empty(param){return param ? 0 : 1;}
   function partition_map(t, f){
    var t$0 = t, fst = 0, snd = 0;
    for(;;){
     if(! t$0){
      var _a_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _a_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x);
     if(0 === match[0])
      var y = match[1], fst$0 = [0, y, fst], t$0 = t$1, fst = fst$0;
     else
      var y$0 = match[1], snd$0 = [0, y$0, snd], t$0 = t$1, snd = snd$0;
    }
   }
   var
    Base_List1 =
      [0,
       hd_exn,
       rev_append,
       tl_exn,
       unzip,
       length,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       rev,
       fold_right,
       fold_right2_ok,
       is_empty,
       partition_map];
   runtime.caml_register_global(1, Base_List1, "Base__List1");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Result
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Printf, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Error$0 = "Error",
    cst_Ok$0 = "Ok",
    cst_error = "error",
    cst_ok = "ok",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_005 = "result.ml.t",
    Base_List1 = global_data.Base__List1,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Monad = global_data.Base__Monad,
    _c_ = [0, 0],
    cst_Error = cst_Error$0,
    cst_Ok = cst_Ok$0,
    _a_ = [0, cst_Ok$0],
    _b_ = [0, cst_Error$0];
   function t_of_sexp(of_a_001, of_b_002, sexp_007){
    a:
    {
     if(0 === sexp_007[0]){
      var _f_ = sexp_007[1];
      b:
      if(caml_string_notequal(_f_, cst_Error$0)){
       if(caml_string_notequal(_f_, cst_Ok$0)){
        if(! caml_string_notequal(_f_, cst_error)) break b;
        if(caml_string_notequal(_f_, cst_ok)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_005, sexp_007);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_005, sexp_007);
     }
     var _g_ = sexp_007[1];
     if(! _g_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_005, sexp_007);
     var _h_ = _g_[1];
     if(0 !== _h_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_005, sexp_007);
     var tag_008 = _h_[1];
     b:
     if(caml_string_notequal(tag_008, cst_Error$0)){
      if(caml_string_notequal(tag_008, cst_Ok$0)){
       if(! caml_string_notequal(tag_008, cst_error)) break b;
       if(caml_string_notequal(tag_008, cst_ok)) break a;
      }
      var sexp_args_009 = _g_[2];
      if(sexp_args_009 && ! sexp_args_009[2]){
       var
        arg0_010 = sexp_args_009[1],
        res0_011 = caml_call1(of_a_001, arg0_010);
       return [0, res0_011];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_005,
               tag_008,
               sexp_007);
     }
     var sexp_args_014 = _g_[2];
     if(sexp_args_014 && ! sexp_args_014[2]){
      var
       arg0_015 = sexp_args_014[1],
       res0_016 = caml_call1(of_b_002, arg0_015);
      return [1, res0_016];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_005,
              tag_008,
              sexp_007);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_005, sexp_007);
   }
   function sexp_of_t(of_a_019, of_b_020, param){
    if(0 === param[0]){
     var arg0_021 = param[1], res0_022 = caml_call1(of_a_019, arg0_021);
     return [1, [0, _a_, [0, res0_022, 0]]];
    }
    var arg0_023 = param[1], res0_024 = caml_call1(of_b_020, arg0_023);
    return [1, [0, _b_, [0, res0_024, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Ok, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Error, [0, [0, b_sexp_grammar, 0]]]], 0]]]];
   }
   function compare_local(cmp_a, cmp_b, a_033, b_034){
    if(a_033 === b_034) return 0;
    if(0 === a_033[0]){
     var a_035 = a_033[1];
     if(0 !== b_034[0]) return -1;
     var b_036 = b_034[1];
     return caml_call2(cmp_a, a_035, b_036);
    }
    var a_037 = a_033[1];
    if(0 === b_034[0]) return 1;
    var b_038 = b_034[1];
    return caml_call2(cmp_b, a_037, b_038);
   }
   function compare(cmp_a, cmp_b, a_027, b_028){
    if(a_027 === b_028) return 0;
    if(0 === a_027[0]){
     var a_029 = a_027[1];
     if(0 !== b_028[0]) return -1;
     var b_030 = b_028[1];
     return caml_call2(cmp_a, a_029, b_030);
    }
    var a_031 = a_027[1];
    if(0 === b_028[0]) return 1;
    var b_032 = b_028[1];
    return caml_call2(cmp_b, a_031, b_032);
   }
   function equal_local(cmp_a, cmp_b, a_045, b_046){
    if(a_045 === b_046) return 1;
    if(0 === a_045[0]){
     var a_047 = a_045[1];
     if(0 !== b_046[0]) return 0;
     var b_048 = b_046[1];
     return caml_call2(cmp_a, a_047, b_048);
    }
    var a_049 = a_045[1];
    if(0 === b_046[0]) return 0;
    var b_050 = b_046[1];
    return caml_call2(cmp_b, a_049, b_050);
   }
   function equal(cmp_a, cmp_b, a_039, b_040){
    if(a_039 === b_040) return 1;
    if(0 === a_039[0]){
     var a_041 = a_039[1];
     if(0 !== b_040[0]) return 0;
     var b_042 = b_040[1];
     return caml_call2(cmp_a, a_041, b_042);
    }
    var a_043 = a_039[1];
    if(0 === b_040[0]) return 0;
    var b_044 = b_040[1];
    return caml_call2(cmp_b, a_043, b_044);
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_a, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_b, hsv$1, a0$0);
   }
   var globalize = Base_Import[295];
   function bind(x, f){
    if(0 !== x[0]) return x;
    var x$0 = x[1];
    return caml_call1(f, x$0);
   }
   var
    map =
      [0,
       -198771759,
       function(x, f){
        if(0 !== x[0]) return x;
        var x$0 = x[1];
        return [0, caml_call1(f, x$0)];
       }];
   function return$0(x){return [0, x];}
   var
    include = caml_call1(Base_Monad[6], [0, bind, map, return$0]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$1 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function invariant(check_ok, check_error, t){
    if(0 === t[0]){var ok = t[1]; return caml_call1(check_ok, ok);}
    var error = t[1];
    return caml_call1(check_error, error);
   }
   function fail(x){return [1, x];}
   function failf(format){return caml_call2(Base_Printf[4], fail, format);}
   function map_error(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return [1, caml_call1(f, x)];
   }
   function bind$1(x, f){
    if(0 === x[0]) return x;
    var e = x[1];
    return caml_call1(f, e);
   }
   var map$1 = [0, -198771759, map_error];
   function return$2(e){return [1, e];}
   var Error = caml_call1(Base_Monad[6], [0, bind$1, map$1, return$2]);
   function is_ok(param){return 0 === param[0] ? 1 : 0;}
   function is_error(param){return 0 === param[0] ? 0 : 1;}
   function ok(param){
    if(0 !== param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function error(param){
    if(0 === param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function of_option(opt, error){
    if(! opt) return [1, error];
    var x = opt[1];
    return [0, x];
   }
   function iter(v, f){
    if(0 !== v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function iter_error(v, f){
    if(0 === v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function to_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function of_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function ok_if_true(bool, error){return bool ? _c_ : [1, error];}
   function try_with(f){
    try{var _e_ = [0, caml_call1(f, 0)]; return _e_;}
    catch(exn$0){var exn = caml_wrap_exception(exn$0); return [1, exn];}
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var exn = param[1];
    throw caml_maybe_attach_backtrace(exn, 1);
   }
   function ok_or_failwith(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var str = param[1];
    return caml_call1(Base_Import[124], str);
   }
   function combine(t1, t2, ok, err){
    if(0 === t1[0]){
     var ok1 = t1[1];
     if(0 === t2[0]){var ok2 = t2[1]; return [0, caml_call2(ok, ok1, ok2)];}
     var e = t2[1];
    }
    else{
     var err1 = t1[1];
     if(0 !== t2[0]){
      var err2 = t2[1];
      return [1, caml_call2(err, err1, err2)];
     }
     var e = err1;
    }
    return [1, e];
   }
   function combine_errors(l){
    var
     match = caml_call2(Base_List1[23], l, to_either),
     errs = match[2],
     ok = match[1];
    return errs ? [1, errs] : [0, ok];
   }
   function combine_errors_unit(l){
    function _d_(param){return 0;}
    return caml_call2(map$0, combine_errors(l), _d_);
   }
   var
    Base_Result =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       compare_local,
       equal,
       equal_local,
       hash_fold_t,
       globalize,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$1,
       join,
       ignore_m,
       all,
       all_unit,
       Error,
       invariant,
       fail,
       failf,
       is_ok,
       is_error,
       ok,
       ok_exn,
       ok_or_failwith,
       error,
       of_option,
       iter,
       iter_error,
       map$0,
       map_error,
       combine,
       combine_errors,
       combine_errors_unit,
       to_either,
       of_either,
       ok_if_true,
       try_with,
       [0, is_ok, is_error]];
   runtime.caml_register_global(20, Base_Result, "Base__Result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Continue_or_stop = [0],
    Export = [0, Continue_or_stop],
    Continue_or_stop$0 = Export[1],
    Base_Container_intf = [0, Export, Continue_or_stop$0];
   runtime.caml_register_global
    (0, Base_Container_intf, "Base__Container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container
//# unitInfo: Requires: Base__Array0, Base__Container_intf, Base__Import, Base__List0, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array0 = global_data.Base__Array0,
    Base_List0 = global_data.Base__List0,
    Base_Import = global_data.Base__Import,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iter(fold, t, f){
    return caml_call3
            (fold, t, 0, function(param, a){return caml_call1(f, a);});
   }
   function count(fold, t, f){
    return caml_call3
            (fold,
             t,
             0,
             function(n, a){
              return caml_call1(f, a) ? caml_call2(Base_Import[91], n, 1) : n;
             });
   }
   function sum(fold, M, t, f){
    function _u_(n, a){
     var _v_ = caml_call1(f, a);
     return caml_call2(M[2], n, _v_);
    }
    return caml_call3(fold, t, M[1], _u_);
   }
   function fold_result(fold, init, f, t){
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      caml_call3
                       (fold,
                        t,
                        init,
                        function(acc, item){
                         var e = caml_call2(f, acc, item);
                         if(0 !== e[0]) return caml_call1(param, e);
                         var x = e[1];
                         return x;
                        })];
             });
   }
   function fold_until(fold, init, f, finish, t){
    return caml_call1
            (with_return,
             function(param){
              return caml_call1
                      (finish,
                       caml_call3
                        (fold,
                         t,
                         init,
                         function(acc, item){
                          var match = caml_call2(f, acc, item);
                          if(0 === match[0]){var x = match[1]; return x;}
                          var x$0 = match[1];
                          return caml_call1(param, x$0);
                         }));
             });
   }
   function min_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var min = acc[1];
              return 0 < caml_call2(compare, min, elt) ? [0, elt] : acc;
             });
   }
   function max_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var max = acc[1];
              return 0 <= caml_call2(compare, max, elt) ? acc : [0, elt];
             });
   }
   function length(fold, c){
    return caml_call3
            (fold,
             c,
             0,
             function(acc, param){return caml_call2(Base_Import[91], acc, 1);});
   }
   function is_empty(iter, c){
    return caml_call1
            (with_return,
             function(r){
              caml_call2(iter, c, function(param){return caml_call1(r, 0);});
              return 1;
             });
   }
   function mem(iter, c, x, equal){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(y){
                 var _t_ = caml_call2(equal, x, y);
                 return _t_ ? caml_call1(r, 1) : _t_;
                });
              return 0;
             });
   }
   function exists(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _s_ = caml_call1(f, x);
                 return _s_ ? caml_call1(r, 1) : _s_;
                });
              return 0;
             });
   }
   function for_all(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _r_ = 1 - caml_call1(f, x);
                 return _r_ ? caml_call1(r, 0) : _r_;
                });
              return 1;
             });
   }
   function find_map(iter, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                t,
                function(x){
                 var res = caml_call1(f, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function find(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _q_ = caml_call1(f, x);
                 return _q_ ? caml_call1(r, [0, x]) : _q_;
                });
              return 0;
             });
   }
   function to_list(fold, c){
    var _p_ = caml_call3(fold, c, 0, function(acc, x){return [0, x, acc];});
    return caml_call1(Base_List0[19], _p_);
   }
   function to_array(length, iter, c){
    var array = [0, [0]], i = [0, 0];
    caml_call2
     (iter,
      c,
      function(x){
       if(0 === i[1]){
        var _n_ = caml_call1(length, c);
        array[1] = caml_call2(Base_Array0[4], _n_, x);
       }
       var _o_ = i[1];
       runtime.caml_check_bound(array[1], _o_)[1 + _o_] = x;
       i[1]++;
       return 0;
      });
    return array[1];
   }
   function Make_gen(T){
    var fold = T[1], match = T[2];
    if(typeof match === "number")
     var iter$0 = function(t, f){return iter(fold, t, f);};
    else
     var iter$1 = match[2], iter$0 = iter$1;
    var match$0 = T[3];
    if(typeof match$0 === "number")
     var length$0 = function(t){return length(fold, t);};
    else
     var length$1 = match$0[2], length$0 = length$1;
    function is_empty$0(t){return is_empty(iter$0, t);}
    function mem$0(t, x, equal){return mem(iter$0, t, x, equal);}
    function sum$0(m, t){return function(_m_){return sum(fold, m, t, _m_);};}
    function count$0(t, f){return count(fold, t, f);}
    function exists$0(t, f){return exists(iter$0, t, f);}
    function for_all$0(t, f){return for_all(iter$0, t, f);}
    function find_map$0(t, f){return find_map(iter$0, t, f);}
    function find$0(t, f){return find(iter$0, t, f);}
    function to_list$0(t){return to_list(fold, t);}
    function to_array$0(t){return to_array(length$0, iter$0, t);}
    function min_elt$0(t, compare){return min_elt(fold, t, compare);}
    function max_elt$0(t, compare){return max_elt(fold, t, compare);}
    function fold_result$0(t, init, f){return fold_result(fold, init, f, t);}
    function fold_until$0(t, init, f, finish){
     return fold_until(fold, init, f, finish, t);
    }
    return [0,
            length$0,
            is_empty$0,
            mem$0,
            iter$0,
            fold,
            fold_result$0,
            fold_until$0,
            exists$0,
            for_all$0,
            count$0,
            sum$0,
            find$0,
            find_map$0,
            to_list$0,
            to_array$0,
            min_elt$0,
            max_elt$0];
   }
   function Make_gen_with_creators(T){
    var
     include = Make_gen([0, T[1], T[2], T[3]]),
     length = include[1],
     is_empty = include[2],
     mem = include[3],
     iter = include[4],
     fold = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     of_list = T[4],
     of_array = T[5],
     concat = T[6],
     concat_of_array = T[7];
    function append(a, b){
     return caml_call1(concat, caml_call1(concat_of_array, [0, a, b]));
    }
    function concat_map(t, f){
     var _l_ = caml_call1(to_array, t);
     return caml_call1
             (concat,
              caml_call1(concat_of_array, caml_call2(Base_Array0[21], _l_, f)));
    }
    function filter_map(t, f){
     return concat_map
             (t,
              function(x){
               var match = caml_call1(f, x);
               if(! match) return caml_call1(of_array, [0]);
               var y = match[1];
               return caml_call1(of_array, [0, y]);
              });
    }
    function map(t, f){
     return filter_map(t, function(x){return [0, caml_call1(f, x)];});
    }
    function filter(t, f){
     return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
    }
    function partition_map(t, f){
     var
      _f_ = caml_call1(to_array, t),
      array = caml_call2(Base_Array0[21], _f_, f),
      _g_ = 0;
     function _h_(either, acc){
      if(0 !== either[0]) return acc;
      var x = either[1];
      return [0, x, acc];
     }
     var xs = caml_call3(Base_Array0[18], array, _h_, _g_), _i_ = 0;
     function _j_(either, acc){
      if(0 === either[0]) return acc;
      var x = either[1];
      return [0, x, acc];
     }
     var
      ys = caml_call3(Base_Array0[18], array, _j_, _i_),
      _k_ = caml_call1(of_list, ys);
     return [0, caml_call1(of_list, xs), _k_];
    }
    function partition_tf(t, f){
     return partition_map
             (t, function(x){return caml_call1(f, x) ? [0, x] : [1, x];});
    }
    return [0,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            of_list,
            of_array,
            append,
            concat,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map];
   }
   function _a_(T){
    var
     fold = T[2],
     iter = T[3],
     length = T[4],
     of_list = T[5],
     of_array = T[6],
     concat = T[7],
     concat_of_array = Base_Array0[16],
     include =
       Make_gen_with_creators
        ([0, fold, iter, length, of_list, of_array, concat, concat_of_array]),
     length$0 = include[1],
     is_empty = include[2],
     iter$0 = include[4],
     fold$0 = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     of_list$0 = include[18],
     of_array$0 = include[19],
     append = include[20],
     concat$0 = include[21],
     map = include[22],
     filter = include[23],
     filter_map = include[24],
     concat_map = include[25],
     partition_tf = include[26],
     partition_map = include[27],
     _e_ = include[3];
    function mem(t, x){return caml_call3(_e_, t, x, T[1][1]);}
    return [0,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            of_list$0,
            of_array$0,
            append,
            concat$0,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map];
   }
   function _b_(T){
    var
     fold = T[1],
     iter = T[2],
     length = T[3],
     of_list = T[4],
     of_array = T[5],
     concat = T[6],
     include =
       Make_gen_with_creators
        ([0, fold, iter, length, of_list, of_array, concat, of_array]),
     length$0 = include[1],
     is_empty = include[2],
     mem = include[3],
     iter$0 = include[4],
     fold$0 = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     of_list$0 = include[18],
     of_array$0 = include[19],
     append = include[20],
     concat$0 = include[21],
     map = include[22],
     filter = include[23],
     filter_map = include[24],
     concat_map = include[25],
     partition_tf = include[26],
     partition_map = include[27];
    return [0,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            of_list$0,
            of_array$0,
            append,
            concat$0,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map];
   }
   function _c_(T){
    var
     fold = T[2],
     iter = T[3],
     length = T[4],
     include = Make_gen([0, fold, iter, length]),
     length$0 = include[1],
     is_empty = include[2],
     iter$0 = include[4],
     fold$0 = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     _d_ = include[3];
    function mem(t, x){return caml_call3(_d_, t, x, T[1][1]);}
    return [0,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt];
   }
   var
    Base_Container =
      [0,
       iter,
       count,
       min_elt,
       max_elt,
       length,
       to_list,
       sum,
       fold_result,
       fold_until,
       is_empty,
       mem,
       exists,
       for_all,
       find,
       find_map,
       to_array,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         include = Make_gen([0, fold, iter, length]),
         length$0 = include[1],
         is_empty = include[2],
         mem = include[3],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt];
       },
       _c_,
       Make_gen,
       _b_,
       _a_,
       Make_gen_with_creators];
   runtime.caml_register_global(4, Base_Container, "Base__Container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Indexed_container_intf = [0];
   runtime.caml_register_global
    (0, Base_Indexed_container_intf, "Base__Indexed_container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container
//# unitInfo: Requires: Base__Array0, Base__Container, Base__Import, Base__Indexed_container_intf, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array0 = global_data.Base__Array0,
    Base_Container = global_data.Base__Container,
    Base_Import = global_data.Base__Import,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iteri(fold, t, f){
    caml_call3
     (fold,
      t,
      0,
      function(i, x){
       caml_call2(f, i, x);
       return caml_call2(Base_Import[91], i, 1);
      });
    return 0;
   }
   function foldi(fold, t, init, f){
    var i = [0, 0];
    return caml_call3
            (fold,
             t,
             init,
             function(acc, v){
              var acc$0 = caml_call3(f, i[1], acc, v);
              i[1] = caml_call2(Base_Import[91], i[1], 1);
              return acc$0;
             });
   }
   function counti(foldi, t, f){
    return caml_call3
            (foldi,
             t,
             0,
             function(i, n, a){
              return caml_call2(f, i, a)
                      ? caml_call2(Base_Import[91], n, 1)
                      : n;
             });
   }
   function existsi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _k_ = caml_call2(f, i, x);
                 return _k_ ? caml_call1(r, 1) : _k_;
                });
              return 0;
             });
   }
   function for_alli(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _j_ = 1 - caml_call2(f, i, x);
                 return _j_ ? caml_call1(r, 0) : _j_;
                });
              return 1;
             });
   }
   function find_mapi(iteri, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                t,
                function(i, x){
                 var res = caml_call2(f, i, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function findi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _i_ = caml_call2(f, i, x);
                 return _i_ ? caml_call1(r, [0, [0, i, x]]) : _i_;
                });
              return 0;
             });
   }
   function Make_gen_with_container(T, _h_){
    var
     length = _h_[1],
     is_empty = _h_[2],
     mem = _h_[3],
     iter = _h_[4],
     fold = _h_[5],
     fold_result = _h_[6],
     fold_until = _h_[7],
     exists = _h_[8],
     for_all = _h_[9],
     count = _h_[10],
     sum = _h_[11],
     find = _h_[12],
     find_map = _h_[13],
     to_list = _h_[14],
     to_array = _h_[15],
     min_elt = _h_[16],
     max_elt = _h_[17],
     match = T[4];
    if(typeof match === "number")
     var iteri$0 = function(t, f){return iteri(fold, t, f);};
    else
     var iteri$1 = match[2], iteri$0 = iteri$1;
    var match$0 = T[5];
    if(typeof match$0 === "number")
     var foldi$0 = function(t, init, f){return foldi(fold, t, init, f);};
    else
     var foldi$1 = match$0[2], foldi$0 = foldi$1;
    function counti$0(t, f){return counti(foldi$0, t, f);}
    function existsi$0(t, f){return existsi(iteri$0, t, f);}
    function for_alli$0(t, f){return for_alli(iteri$0, t, f);}
    function find_mapi$0(t, f){return find_mapi(iteri$0, t, f);}
    function findi$0(t, f){return findi(iteri$0, t, f);}
    return [0,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi$0,
            for_alli$0,
            counti$0,
            findi$0,
            find_mapi$0];
   }
   function Make_gen(T){
    var
     C = caml_call1(Base_Container[19], [0, T[1], T[2], T[3]]),
     include = Make_gen_with_container(T, C),
     length = include[1],
     is_empty = include[2],
     mem = include[3],
     iter = include[4],
     fold = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     foldi = include[18],
     iteri = include[19],
     existsi = include[20],
     for_alli = include[21],
     counti = include[22],
     findi = include[23],
     find_mapi = include[24];
    return [0,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi,
            iteri,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi];
   }
   function Make_gen_with_creators(T){
    var
     C =
       caml_call1
        (Base_Container[22], [0, T[5], T[6], T[7], T[2], T[3], T[4], T[1]]),
     of_list = C[18],
     of_array = C[19],
     append = C[20],
     concat = C[21],
     map = C[22],
     filter = C[23],
     filter_map = C[24],
     concat_map = C[25],
     partition_tf = C[26],
     partition_map = C[27],
     include =
       Make_gen_with_container
        ([0, T[5], T[6], T[7], T[8], T[9]],
         [0,
          C[1],
          C[2],
          C[3],
          C[4],
          C[5],
          C[6],
          C[7],
          C[8],
          C[9],
          C[10],
          C[11],
          C[12],
          C[13],
          C[14],
          C[15],
          C[16],
          C[17]]),
     length = include[1],
     is_empty = include[2],
     mem = include[3],
     iter = include[4],
     fold = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     foldi = include[18],
     iteri = include[19],
     existsi = include[20],
     for_alli = include[21],
     counti = include[22],
     findi = include[23],
     find_mapi = include[24];
    function derived_init(n, f){
     return caml_call1(of_array, caml_call2(Base_Array0[12], n, f));
    }
    var match = T[10];
    if(typeof match === "number")
     var derived_init$0 = derived_init;
    else
     var init = match[2], derived_init$0 = init;
    function derived_concat_mapi(t, f){
     var
      _f_ = caml_call1(to_array, t),
      _g_ = caml_call2(Base_Array0[22], _f_, f);
     return caml_call1(concat, caml_call1(T[1], _g_));
    }
    var match$0 = T[11];
    if(typeof match$0 === "number")
     var concat_mapi = derived_concat_mapi;
    else
     var concat_mapi$0 = match$0[2], concat_mapi = concat_mapi$0;
    function filter_mapi(t, f){
     return caml_call2
             (concat_mapi,
              t,
              function(i, x){
               var match = caml_call2(f, i, x);
               if(! match) return caml_call1(of_array, [0]);
               var y = match[1];
               return caml_call1(of_array, [0, y]);
              });
    }
    function mapi(t, f){
     return filter_mapi(t, function(i, x){return [0, caml_call2(f, i, x)];});
    }
    function filteri(t, f){
     return filter_mapi
             (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
    }
    return [0,
            of_list,
            of_array,
            append,
            concat,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map,
            length,
            is_empty,
            mem,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi,
            iteri,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi,
            derived_init$0,
            mapi,
            filteri,
            filter_mapi,
            concat_mapi];
   }
   function _a_(T){
    var
     of_list = T[2],
     of_array = T[3],
     concat = T[4],
     fold = T[5],
     iter = T[6],
     length = T[7],
     iteri = T[8],
     foldi = T[9],
     init = T[10],
     concat_mapi = T[11],
     concat_of_array = Base_Array0[16],
     include =
       Make_gen_with_creators
        ([0,
          concat_of_array,
          of_list,
          of_array,
          concat,
          fold,
          iter,
          length,
          iteri,
          foldi,
          init,
          concat_mapi]),
     of_list$0 = include[1],
     of_array$0 = include[2],
     append = include[3],
     concat$0 = include[4],
     map = include[5],
     filter = include[6],
     filter_map = include[7],
     concat_map = include[8],
     partition_tf = include[9],
     partition_map = include[10],
     length$0 = include[11],
     is_empty = include[12],
     iter$0 = include[14],
     fold$0 = include[15],
     fold_result = include[16],
     fold_until = include[17],
     exists = include[18],
     for_all = include[19],
     count = include[20],
     sum = include[21],
     find = include[22],
     find_map = include[23],
     to_list = include[24],
     to_array = include[25],
     min_elt = include[26],
     max_elt = include[27],
     foldi$0 = include[28],
     iteri$0 = include[29],
     existsi = include[30],
     for_alli = include[31],
     counti = include[32],
     findi = include[33],
     find_mapi = include[34],
     init$0 = include[35],
     mapi = include[36],
     filteri = include[37],
     filter_mapi = include[38],
     concat_mapi$0 = include[39],
     _e_ = include[13];
    function mem(t, x){return caml_call3(_e_, t, x, T[1][1]);}
    return [0,
            of_list$0,
            of_array$0,
            append,
            concat$0,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi,
            init$0,
            mapi,
            filteri,
            filter_mapi,
            concat_mapi$0];
   }
   function _b_(T){
    var
     of_list = T[1],
     of_array = T[2],
     concat = T[3],
     fold = T[4],
     iter = T[5],
     length = T[6],
     iteri = T[7],
     foldi = T[8],
     init = T[9],
     concat_mapi = T[10],
     include =
       Make_gen_with_creators
        ([0,
          of_array,
          of_list,
          of_array,
          concat,
          fold,
          iter,
          length,
          iteri,
          foldi,
          init,
          concat_mapi]),
     of_list$0 = include[1],
     of_array$0 = include[2],
     append = include[3],
     concat$0 = include[4],
     map = include[5],
     filter = include[6],
     filter_map = include[7],
     concat_map = include[8],
     partition_tf = include[9],
     partition_map = include[10],
     length$0 = include[11],
     is_empty = include[12],
     mem = include[13],
     iter$0 = include[14],
     fold$0 = include[15],
     fold_result = include[16],
     fold_until = include[17],
     exists = include[18],
     for_all = include[19],
     count = include[20],
     sum = include[21],
     find = include[22],
     find_map = include[23],
     to_list = include[24],
     to_array = include[25],
     min_elt = include[26],
     max_elt = include[27],
     foldi$0 = include[28],
     iteri$0 = include[29],
     existsi = include[30],
     for_alli = include[31],
     counti = include[32],
     findi = include[33],
     find_mapi = include[34],
     init$0 = include[35],
     mapi = include[36],
     filteri = include[37],
     filter_mapi = include[38],
     concat_mapi$0 = include[39];
    return [0,
            of_list$0,
            of_array$0,
            append,
            concat$0,
            map,
            filter,
            filter_map,
            concat_map,
            partition_tf,
            partition_map,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi,
            init$0,
            mapi,
            filteri,
            filter_mapi,
            concat_mapi$0];
   }
   function _c_(T){
    var
     fold = T[2],
     iter = T[3],
     length = T[4],
     iteri = T[5],
     foldi = T[6],
     include = Make_gen([0, fold, iter, length, iteri, foldi]),
     length$0 = include[1],
     is_empty = include[2],
     iter$0 = include[4],
     fold$0 = include[5],
     fold_result = include[6],
     fold_until = include[7],
     exists = include[8],
     for_all = include[9],
     count = include[10],
     sum = include[11],
     find = include[12],
     find_map = include[13],
     to_list = include[14],
     to_array = include[15],
     min_elt = include[16],
     max_elt = include[17],
     foldi$0 = include[18],
     iteri$0 = include[19],
     existsi = include[20],
     for_alli = include[21],
     counti = include[22],
     findi = include[23],
     find_mapi = include[24],
     _d_ = include[3];
    function mem(t, x){return caml_call3(_d_, t, x, T[1][1]);}
    return [0,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi];
   }
   var
    Base_Indexed_container =
      [0,
       foldi,
       iteri,
       counti,
       existsi,
       for_alli,
       findi,
       find_mapi,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         iteri = T[4],
         foldi = T[5],
         include = Make_gen([0, fold, iter, length, iteri, foldi]),
         length$0 = include[1],
         is_empty = include[2],
         mem = include[3],
         iter$0 = include[4],
         fold$0 = include[5],
         fold_result = include[6],
         fold_until = include[7],
         exists = include[8],
         for_all = include[9],
         count = include[10],
         sum = include[11],
         find = include[12],
         find_map = include[13],
         to_list = include[14],
         to_array = include[15],
         min_elt = include[16],
         max_elt = include[17],
         foldi$0 = include[18],
         iteri$0 = include[19],
         existsi = include[20],
         for_alli = include[21],
         counti = include[22],
         findi = include[23],
         find_mapi = include[24];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi];
       },
       _c_,
       Make_gen,
       _b_,
       _a_,
       Make_gen_with_creators];
   runtime.caml_register_global
    (4, Base_Indexed_container, "Base__Indexed_container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Lazy
//# unitInfo: Requires: Base__Globalize, Base__Hash, Base__Import, Base__Monad, CamlinternalLazy, Stdlib__Lazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Import = global_data.Base__Import,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base_Globalize = global_data.Base__Globalize,
    Base_Hash = global_data.Base__Hash,
    Base_Monad = global_data.Base__Monad,
    Undefined = Stdlib_Lazy[1],
    is_val = Stdlib_Lazy[3],
    from_val = Stdlib_Lazy[4],
    from_fun = Stdlib_Lazy[6],
    force_val = Stdlib_Lazy[7],
    t_of_sexp = Base_Import[169],
    sexp_of_t = Base_Import[145],
    cst_unforced_lazy = "<unforced lazy>";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[192], a_sexp_grammar);
   }
   var globalize = Base_Globalize[12];
   function _a_(t, f){
    return [246,
            function(_s_){
             var _t_ = caml_obj_tag(t);
             a:
             if(250 === _t_)
              var _u_ = t[1];
             else{
              if(246 !== _t_ && 244 !== _t_){var _u_ = t; break a;}
              var _u_ = caml_call1(CamlinternalLazy[2], t);
             }
             return caml_call1(f, _u_);
            }];
   }
   function compare_local(compare_a, t1, t2){
    if(t1 === t2) return 0;
    var _o_ = caml_obj_tag(t2);
    a:
    if(250 === _o_)
     var _p_ = t2[1];
    else{
     if(246 !== _o_ && 244 !== _o_){var _p_ = t2; break a;}
     var _p_ = caml_call1(CamlinternalLazy[2], t2);
    }
    var _q_ = caml_obj_tag(t1);
    a:
    if(250 === _q_)
     var _r_ = t1[1];
    else{
     if(246 !== _q_ && 244 !== _q_){var _r_ = t1; break a;}
     var _r_ = caml_call1(CamlinternalLazy[2], t1);
    }
    return caml_call2(compare_a, _r_, _p_);
   }
   function compare(compare_a, t1, t2){
    return compare_local(compare_a, t1, t2);
   }
   function equal_local(equal_a, t1, t2){
    if(t1 === t2) return 1;
    var _k_ = caml_obj_tag(t2);
    a:
    if(250 === _k_)
     var _l_ = t2[1];
    else{
     if(246 !== _k_ && 244 !== _k_){var _l_ = t2; break a;}
     var _l_ = caml_call1(CamlinternalLazy[2], t2);
    }
    var _m_ = caml_obj_tag(t1);
    a:
    if(250 === _m_)
     var _n_ = t1[1];
    else{
     if(246 !== _m_ && 244 !== _m_){var _n_ = t1; break a;}
     var _n_ = caml_call1(CamlinternalLazy[2], t1);
    }
    return caml_call2(equal_a, _n_, _l_);
   }
   function equal(equal_a, t1, t2){return equal_local(equal_a, t1, t2);}
   var hash_fold_t = Base_Hash[13][12];
   function peek(t){
    if(! caml_call1(is_val, t)) return 0;
    var _i_ = caml_obj_tag(t);
    a:
    if(250 === _i_)
     var _j_ = t[1];
    else{
     if(246 !== _i_ && 244 !== _i_){var _j_ = t; break a;}
     var _j_ = caml_call1(CamlinternalLazy[2], t);
    }
    return [0, _j_];
   }
   function return$0(x){return caml_call1(from_val, x);}
   function bind(t, f){
    return [246,
            function(_d_){
             var _e_ = caml_obj_tag(t);
             a:
             if(250 === _e_)
              var _f_ = t[1];
             else{
              if(246 !== _e_ && 244 !== _e_){var _f_ = t; break a;}
              var _f_ = caml_call1(CamlinternalLazy[2], t);
             }
             var _g_ = caml_call1(f, _f_), _h_ = caml_obj_tag(_g_);
             if(250 === _h_) return _g_[1];
             if(246 !== _h_ && 244 !== _h_) return _g_;
             return caml_call1(CamlinternalLazy[2], _g_);
            }];
   }
   var
    map = [0, -198771759, _a_],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function sexp_of_t$0(sexp_of_a, t){
    if(! caml_call1(is_val, t))
     return caml_call1(Base_Import[136], cst_unforced_lazy);
    var _b_ = caml_obj_tag(t);
    a:
    if(250 === _b_)
     var _c_ = t[1];
    else{
     if(246 !== _b_ && 244 !== _b_){var _c_ = t; break a;}
     var _c_ = caml_call1(CamlinternalLazy[2], t);
    }
    return caml_call1(sexp_of_a, _c_);
   }
   var
    T_unforcing = [0, sexp_of_t$0],
    Base_Lazy =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       peek,
       T_unforcing];
   runtime.caml_register_global(7, Base_Lazy, "Base__Lazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Info_intf = [0];
   runtime.caml_register_global(0, Base_Info_intf, "Base__Info_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common0
//# unitInfo: Requires: Base__Import, Base__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    invalid_argf = Base_Printf[7],
    _a_ =
      [0,
       [11, "Negative position: ", [4, 0, 0, 0, 0]],
       "Negative position: %d"],
    _b_ =
      [0, [11, "Negative length: ", [4, 0, 0, 0, 0]], "Negative length: %d"],
    _c_ =
      [0,
       [11,
        "pos + len past end: ",
        [4, 0, 0, 0, [11, " + ", [4, 0, 0, 0, [11, " > ", [4, 0, 0, 0, 0]]]]]],
       "pos + len past end: %d + %d > %d"];
   function slow_check_pos_len_exn(pos, len, total_length){
    if(pos < 0) caml_call3(invalid_argf, _a_, pos, 0);
    if(len < 0) caml_call3(invalid_argf, _b_, len, 0);
    var _h_ = caml_call2(Base_Import[93], total_length, len) < pos ? 1 : 0;
    return _h_
            ? caml_call5(invalid_argf, _c_, pos, len, total_length, 0)
            : _h_;
   }
   function check_pos_len_exn(pos, len, total_length){
    var
     stop = caml_call2(Base_Import[91], pos, len),
     _d_ = caml_call2(Base_Import[93], total_length, stop),
     _e_ = caml_call2(Base_Import[118], pos, len),
     _f_ = caml_call2(Base_Import[118], _e_, stop),
     _g_ = caml_call2(Base_Import[118], _f_, _d_) < 0 ? 1 : 0;
    return _g_ ? slow_check_pos_len_exn(pos, len, total_length) : _g_;
   }
   function get_pos_len_exn(opt, len, param, total_length){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(len)
     var i = len[1], len$0 = i;
    else
     var len$0 = caml_call2(Base_Import[93], total_length, pos);
    check_pos_len_exn(pos, len$0, total_length);
    return [0, pos, len$0];
   }
   var
    Private = [0, slow_check_pos_len_exn],
    Base_Ordered_collection_common =
      [0, get_pos_len_exn, check_pos_len_exn, Private];
   runtime.caml_register_global
    (5, Base_Ordered_collection_common, "Base__Ordered_collection_common0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random_repr
//# unitInfo: Requires: Stdlib__Bigarray, Stdlib__Domain, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Domain = global_data.Stdlib__Domain,
    Stdlib_Random = global_data.Stdlib__Random;
   function of_state(_c_){return _c_;}
   var Repr = [0, of_state];
   function assign(t, state){
    var
     _b_ = caml_call1(Stdlib_Domain[10][2], t),
     dst = caml_call1(Repr[1], _b_),
     src = caml_call1(Repr[1], state);
    return runtime.caml_ba_blit(src, dst);
   }
   function make(state){
    function split_from_parent(v){
     return caml_call1(Stdlib_Random[15][15], v);
    }
    function _a_(param){return state;}
    var t = caml_call2(Stdlib_Domain[10][1], [0, split_from_parent], _a_);
    caml_call1(Stdlib_Domain[10][2], t);
    return t;
   }
   function make_lazy(f){
    function split_from_parent(v){
     return caml_call1(Stdlib_Random[15][15], v);
    }
    return caml_call2(Stdlib_Domain[10][1], [0, split_from_parent], f);
   }
   function get_state(t){return caml_call1(Stdlib_Domain[10][2], t);}
   var Base_Random_repr = [0, Repr, assign, make, make_lazy, get_state];
   runtime.caml_register_global(2, Base_Random_repr, "Base__Random_repr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random
//# unitInfo: Requires: Base__Char0, Base__Import, Base__Int0, Base__Printf, Base__Random_repr, Base__Word_size, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_int64_xor = runtime.caml_int64_xor;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Random_repr = global_data.Base__Random_repr,
    Base_Import = global_data.Base__Import,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Int0 = global_data.Base__Int0,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Char0 = global_data.Base__Char0,
    Base_Word_size = global_data.Base__Word_size,
    cst_float = "float",
    cst_int64 = "int64",
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_nativeint = "nativeint",
    cst_int32 = "int32",
    cst_int = "int",
    _a_ =
      [0,
       [11,
        "Random.",
        [2,
         0,
         [11, ": crossed bounds [", [2, 0, [11, " > ", [2, 0, [12, 93, 0]]]]]]],
       "Random.%s: crossed bounds [%s > %s]"],
    cst_initializing_Random_with_a =
      "initializing Random with a nondeterministic seed is forbidden in inline tests";
   function forbid_nondeterminism_in_tests(allow_in_tests){
    var _D_ = Base_Import[129];
    if(! _D_) return _D_;
    if(allow_in_tests && allow_in_tests[1]) return;
    return caml_call1(Base_Import[124], cst_initializing_Random_with_a);
   }
   function bits(t){
    var _C_ = caml_call1(Base_Random_repr[5], t);
    return caml_call1(Stdlib_Random[15][4], _C_);
   }
   function bits64(t){
    var _B_ = caml_call1(Base_Random_repr[5], t);
    return caml_call1(Stdlib_Random[15][13], _B_);
   }
   function bool(t){
    var _A_ = caml_call1(Base_Random_repr[5], t);
    return caml_call1(Stdlib_Random[15][11], _A_);
   }
   function int$0(t, x){
    var _z_ = caml_call1(Base_Random_repr[5], t);
    return caml_call2(Stdlib_Random[15][5], _z_, x);
   }
   function int32(t, x){
    var _y_ = caml_call1(Base_Random_repr[5], t);
    return caml_call2(Stdlib_Random[15][7], _y_, x);
   }
   function int64(t, x){
    var _x_ = caml_call1(Base_Random_repr[5], t);
    return caml_call2(Stdlib_Random[15][9], _x_, x);
   }
   function nativeint(t, x){
    var _w_ = caml_call1(Base_Random_repr[5], t);
    return caml_call2(Stdlib_Random[15][8], _w_, x);
   }
   function make(seed){
    var _v_ = caml_call1(Stdlib_Random[15][1], seed);
    return caml_call1(Base_Random_repr[3], _v_);
   }
   function copy(t){
    var
     _t_ = caml_call1(Base_Random_repr[5], t),
     _u_ = caml_call1(Stdlib_Random[15][3], _t_);
    return caml_call1(Base_Random_repr[3], _u_);
   }
   function char$0(t){
    var _s_ = int$0(t, 256);
    return caml_call1(Base_Char0[5], _s_);
   }
   function ascii(t){
    var _r_ = int$0(t, 128);
    return caml_call1(Base_Char0[5], _r_);
   }
   function make_self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    return caml_call1(Base_Random_repr[4], Stdlib_Random[15][2]);
   }
   var assign = Base_Random_repr[2];
   if(Base_Import[129]){
    var t = caml_call1(Stdlib_Random[16], 0);
    caml_call1(Stdlib_Random[1], 137);
    var default$0 = caml_call1(Base_Random_repr[3], t);
   }
   else
    var default$0 = make_self_init(0, 0);
   function int_on_64bits(t, bound){
    return 1073741823 < bound
            ? caml_int64_to_int32(int64(t, caml_int64_of_int32(bound)))
            : int$0(t, bound);
   }
   function int_on_32bits(t, bound){
    return 1073741823 < bound ? int32(t, bound) : int$0(t, bound);
   }
   var int$1 = Base_Word_size[3] ? int_on_64bits : int_on_32bits;
   function bits$0(state){return caml_int64_of_int32(bits(state));}
   function full_range_int64(state){
    var
     _p_ = caml_int64_shift_left(bits$0(state), 60),
     _q_ = caml_int64_xor(caml_int64_shift_left(bits$0(state), 30), _p_);
    return caml_int64_xor(bits$0(state), _q_);
   }
   function bits$1(state){return bits(state);}
   function full_range_int32(state){
    var _o_ = bits$1(state) << 30;
    return bits$1(state) ^ _o_;
   }
   function full_range_int_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_int_on_32bits(state){return full_range_int32(state);}
   var
    full_range_int_on_64bits$0 =
      Base_Word_size[3] ? full_range_int_on_64bits : full_range_int_on_32bits;
   function full_range_nativeint_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_nativeint_on_32bits(state){return full_range_int32(state);
   }
   var
    full_range_nativeint =
      Base_Word_size[3]
       ? full_range_nativeint_on_64bits
       : full_range_nativeint_on_32bits;
   function raise_crossed_bounds
   (name, lower_bound, upper_bound, string_of_bound){
    var
     _m_ = caml_call1(string_of_bound, upper_bound),
     _n_ = caml_call1(string_of_bound, lower_bound);
    return caml_call5(Base_Printf[6], _a_, name, _n_, _m_, 0);
   }
   function int_incl(state, lo, hi){
    if(hi < lo) raise_crossed_bounds(cst_int, lo, hi, Base_Int0[1]);
    var diff = caml_call2(Base_Import[93], hi, lo);
    if(diff === Base_Int0[6]){
     var
      _i_ = Base_Int0[6],
      _j_ = full_range_int_on_64bits$0(state),
      _k_ = caml_call2(Base_Import[116], _j_, _i_);
     return caml_call2(Base_Import[91], lo, _k_);
    }
    if(0 <= diff){
     var _l_ = int$1(state, caml_call1(Base_Int0[8], diff));
     return caml_call2(Base_Import[91], lo, _l_);
    }
    for(;;){
     var int$0 = full_range_int_on_64bits$0(state);
     if(lo <= int$0 && int$0 <= hi) return int$0;
    }
   }
   function int32_incl(state, lo, hi){
    if(caml_call2(Base_Import[102][5], lo, hi))
     raise_crossed_bounds(cst_int32, lo, hi, Stdlib_Int32[14]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[102][4], diff, Stdlib_Int32[9])){
     var _h_ = Stdlib_Int32[9];
     return lo + (full_range_int32(state) & _h_) | 0;
    }
    if(caml_call2(Base_Import[102][6], diff, 0))
     return lo + int32(state, caml_call1(Stdlib_Int32[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_int32(state);
     if
      (caml_call2(Base_Import[102][6], int$0, lo)
       && caml_call2(Base_Import[102][2], int$0, hi))
      return int$0;
    }
   }
   function nativeint_incl(state, lo, hi){
    if(caml_call2(Base_Import[104][5], lo, hi))
     raise_crossed_bounds(cst_nativeint, lo, hi, Stdlib_Nativeint[15]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[104][4], diff, Stdlib_Nativeint[10])){
     var _g_ = Stdlib_Nativeint[10];
     return lo + (full_range_nativeint(state) & _g_) | 0;
    }
    if(caml_call2(Base_Import[104][6], diff, 0))
     return lo + nativeint(state, caml_call1(Stdlib_Nativeint[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_nativeint(state);
     if
      (caml_call2(Base_Import[104][6], int$0, lo)
       && caml_call2(Base_Import[104][2], int$0, hi))
      return int$0;
    }
   }
   function int64_incl(state, lo, hi){
    if(runtime.caml_greaterthan(lo, hi))
     raise_crossed_bounds(cst_int64, lo, hi, Stdlib_Int64[14]);
    var diff = runtime.caml_int64_sub(hi, lo);
    if(runtime.caml_equal(diff, Stdlib_Int64[9])){
     var _f_ = Stdlib_Int64[9];
     return caml_int64_add
             (lo, runtime.caml_int64_and(full_range_int64(state), _f_));
    }
    if(caml_greaterequal(diff, _b_))
     return caml_int64_add
             (lo, int64(state, caml_call1(Stdlib_Int64[6], diff)));
    for(;;){
     var int$0 = full_range_int64(state);
     if(caml_greaterequal(int$0, lo) && runtime.caml_lessequal(int$0, hi))
      return int$0;
    }
   }
   function float$0(state, hi){
    for(;;){
     var
      r1 = bits(state),
      r2 = bits(state),
      _d_ = caml_call2(Base_Import[90], r1, 9.313225746154785e-10),
      _e_ = caml_call2(Base_Import[92], _d_, r2),
      result = caml_call2(Base_Import[90], _e_, 9.313225746154785e-10);
     if(result < 1.) return caml_call2(Base_Import[90], result, hi);
    }
   }
   function float_range(state, lo, hi){
    if(hi < lo) raise_crossed_bounds(cst_float, lo, hi, Base_Import[85][35]);
    var _c_ = float$0(state, caml_call2(Base_Import[94], hi, lo));
    return caml_call2(Base_Import[92], lo, _c_);
   }
   function bits$2(param){return bits(default$0);}
   function bits64$0(param){return bits64(default$0);}
   function int$2(x){return int$1(default$0, x);}
   function int32$0(x){return int32(default$0, x);}
   function nativeint$0(x){return nativeint(default$0, x);}
   function int64$0(x){return int64(default$0, x);}
   function float$1(x){return float$0(default$0, x);}
   function int_incl$0(x, y){return int_incl(default$0, x, y);}
   function int32_incl$0(x, y){return int32_incl(default$0, x, y);}
   function nativeint_incl$0(x, y){return nativeint_incl(default$0, x, y);}
   function int64_incl$0(x, y){return int64_incl(default$0, x, y);}
   function float_range$0(x, y){return float_range(default$0, x, y);}
   function bool$0(param){return bool(default$0);}
   function char$1(param){return char$0(default$0);}
   function ascii$0(param){return ascii(default$0);}
   function full_init(seed){
    return caml_call2
            (assign, default$0, caml_call1(Stdlib_Random[15][1], seed));
   }
   function init(seed){return full_init([0, seed]);}
   function self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    return full_init(runtime.caml_sys_random_seed(0));
   }
   function set_state(s){
    return caml_call2(assign, default$0, caml_call1(Base_Random_repr[5], s));
   }
   var
    Base_Random =
      [0,
       init,
       full_init,
       self_init,
       bits$2,
       bits64$0,
       int$2,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       int_incl$0,
       int32_incl$0,
       nativeint_incl$0,
       int64_incl$0,
       float_range$0,
       bool$0,
       char$1,
       ascii$0,
       [0,
        default$0,
        make,
        make_self_init,
        copy,
        bits,
        bits64,
        int$1,
        int32,
        nativeint,
        int64,
        float$0,
        int_incl,
        int32_incl,
        nativeint_incl,
        int64_incl,
        float_range,
        bool,
        char$0,
        ascii],
       set_state];
   runtime.caml_register_global(22, Base_Random, "Base__Random");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array_permute
//# unitInfo: Requires: Base__Array0, Base__Import, Base__Ordered_collection_common0, Base__Random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    Base_Array0 = global_data.Base__Array0,
    invalid_argf = Base_Array0[1],
    Array = Base_Array0[2],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_local = Base_Array0[5],
    create_float_uninitialized = Base_Array0[6],
    append = Base_Array0[7],
    blit = Base_Array0[8],
    concat = Base_Array0[9],
    copy = Base_Array0[10],
    fill = Base_Array0[11],
    init = Base_Array0[12],
    make_matrix = Base_Array0[13],
    of_list = Base_Array0[14],
    sub = Base_Array0[15],
    to_list = Base_Array0[16],
    fold = Base_Array0[17],
    fold_right = Base_Array0[18],
    iter = Base_Array0[19],
    iteri = Base_Array0[20],
    map = Base_Array0[21],
    mapi = Base_Array0[22],
    stable_sort = Base_Array0[23],
    swap = Base_Array0[24];
   function permute(opt, _a_, len, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    if(_a_) var sth$0 = _a_[1], pos = sth$0; else var pos = 0;
    var total_length = t.length - 1;
    if(len)
     var l = len[1], len$0 = l;
    else
     var len$0 = caml_call2(Base_Import[93], total_length, pos);
    caml_call3(Base_Ordered_collection_common[2], pos, len$0, total_length);
    var num_swaps = caml_call2(Base_Import[93], len$0, 1);
    if(num_swaps >= 1){
     var i = num_swaps;
     for(;;){
      var
       this_i = caml_call2(Base_Import[91], pos, i),
       _b_ = caml_call2(Base_Import[91], i, 1),
       _c_ = caml_call2(Base_Random[19][7], random_state, _b_),
       random_i = caml_call2(Base_Import[91], pos, _c_);
      caml_call3(swap, t, this_i, random_i);
      var _d_ = i - 1 | 0;
      if(1 === i) break;
      var i = _d_;
     }
    }
    return 0;
   }
   var
    Base_Array_permute =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_local,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap,
       permute];
   runtime.caml_register_global(4, Base_Array_permute, "Base__Array_permute");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Equal
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Equal = [0];
   runtime.caml_register_global(0, Base_Equal, "Base__Equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordering
//# unitInfo: Requires: Base__Hash, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Equal = "Equal",
    cst_Greater = "Greater",
    cst_Less = "Less",
    cst_equal = "equal",
    cst_greater = "greater",
    cst_less = "less",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, [0, 2, 0]]],
    error_source_005 = "ordering.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Less, 0]],
         [0, [1, [0, cst_Equal, 0]], [0, [1, [0, cst_Greater, 0]], 0]]]]],
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    compare_local = caml_int_compare,
    compare = caml_int_compare,
    _a_ = [0, cst_Less],
    _b_ = [0, cst_Equal],
    _c_ = [0, cst_Greater];
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       var _i_ = 0; break;
      case 1:
       var _i_ = 1; break;
      default: var _i_ = 2;
    }
    return caml_call2(Base_Hash[3], hsv, _i_);
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function t_of_sexp(sexp_006){
    a:
    {
     if(0 === sexp_006[0]){
      var _d_ = sexp_006[1];
      b:
      if(caml_string_notequal(_d_, cst_Equal)){
       c:
       if(caml_string_notequal(_d_, cst_Greater)){
        if(caml_string_notequal(_d_, cst_Less)){
         if(! caml_string_notequal(_d_, cst_equal)) break b;
         if(! caml_string_notequal(_d_, cst_greater)) break c;
         if(caml_string_notequal(_d_, cst_less)) break a;
        }
        return 0;
       }
       return 2;
      }
      return 1;
     }
     var _e_ = sexp_006[1];
     if(! _e_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_005, sexp_006);
     var _f_ = _e_[1];
     if(0 !== _f_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_005, sexp_006);
     var _g_ = _f_[1];
     b:
     if(caml_string_notequal(_g_, cst_Equal)){
      c:
      if(caml_string_notequal(_g_, cst_Greater)){
       if(caml_string_notequal(_g_, cst_Less)){
        if(! caml_string_notequal(_g_, cst_equal)) break b;
        if(! caml_string_notequal(_g_, cst_greater)) break c;
        if(caml_string_notequal(_g_, cst_less)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_005, sexp_006);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   function equal(a, b){return 0 === caml_int_compare(a, b) ? 1 : 0;}
   function equal_local(a, b){return 0 === caml_int_compare(a, b) ? 1 : 0;}
   var Export = [0];
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   var
    Base_Ordering =
      [0,
       compare,
       compare_local,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       all,
       equal,
       equal_local,
       of_int,
       to_int,
       Export];
   runtime.caml_register_global(20, Base_Ordering, "Base__Ordering");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List
//# unitInfo: Requires: Base__Applicative, Base__Array0, Base__Array_permute, Base__Container, Base__Import, Base__List1, Base__Monad, Base__Ordering, Base__Printf, Base__Random, Base__Result, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = " <> ",
    cst$0 = ": ",
    cst_List_map2$1 = "List.map2",
    cst_List_map3$1 = "List.map3",
    cst_List_range_stride_function$2 =
      "List.range': stride function cannot change direction",
    cst_length_mismatch_in = "length mismatch in ",
    cst_src_list_ml = "src/list.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    error_source_036 = "list.ml.Assoc.t",
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Random = global_data.Base__Random,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Result = global_data.Base__Result,
    Base_Ordering = global_data.Base__Ordering,
    Base_List1 = global_data.Base__List1,
    Base_Printf = global_data.Base__Printf,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    hd_exn = Base_List1[1],
    rev_append = Base_List1[2],
    tl_exn = Base_List1[3],
    length = Base_List1[5],
    exists = Base_List1[6],
    exists2_ok = Base_List1[7],
    fold = Base_List1[8],
    fold2_ok = Base_List1[9],
    for_all = Base_List1[10],
    for_all2_ok = Base_List1[11],
    iter = Base_List1[12],
    iter2_ok = Base_List1[13],
    rev_map = Base_List1[17],
    rev_map2_ok = Base_List1[18],
    rev = Base_List1[19],
    fold_right = Base_List1[20],
    fold_right2_ok = Base_List1[21],
    is_empty = Base_List1[22],
    partition_map = Base_List1[23],
    invalid_argf = Base_Printf[7],
    globalize = Base_Import[293],
    t_of_sexp = Base_Import[173],
    sexp_of_t = Base_Import[149],
    cst_List_map2 = cst_List_map2$1,
    cst_List_map2$0 = cst_List_map2$1,
    cst_List_map3 = cst_List_map3$1,
    cst_List_map3$0 = cst_List_map3$1,
    cst_List_last = "List.last",
    _v_ = [0, "list.ml.Transpose_got_lists_of_different_lengths"],
    _w_ = [0, cst_src_list_ml, 1588, 11],
    cst_List_random_element_exn_em = "List.random_element_exn: empty list",
    cst_List_drop_last_exn_empty_l = "List.drop_last_exn: empty list",
    _t_ =
      [0,
       [11, "List.chunks_of: Expected length > 0, got ", [4, 0, 0, 0, 0]],
       "List.chunks_of: Expected length > 0, got %d"],
    cst_List_sub = "List.sub",
    _r_ = [0, cst_src_list_ml, 1305, 12],
    _q_ = [1, 0],
    _p_ = [1, 0],
    _o_ = [1, 0],
    _n_ = [0, cst_src_list_ml, 1111, 4],
    _m_ = [0, [11, "List.init ", [4, 0, 0, 0, 0]], "List.init %d"],
    cst_List_reduce_balanced_exn = "List.reduce_balanced_exn",
    _l_ = [0, cst_src_list_ml, 626, 14],
    cst_List_reduce_exn = "List.reduce_exn",
    _k_ =
      [0,
       [11,
        "length mismatch in zip_exn: ",
        [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]],
       "length mismatch in zip_exn: %d <> %d"],
    cst_map3_exn = "map3_exn",
    cst_rev_map3_exn = "rev_map3_exn",
    _j_ = [0, cst_src_list_ml, 476, 11],
    cst_map2_exn = "map2_exn",
    cst_exists2_exn = "exists2_exn",
    cst_for_all2_exn = "for_all2_exn",
    cst_fold_right2_exn = "fold_right2_exn",
    cst_fold2_exn = "fold2_exn",
    cst_rev_map2_exn = "rev_map2_exn",
    cst_iter2_exn = "iter2_exn",
    _e_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2,
         0,
         [11,
          cst$0,
          [4,
           0,
           0,
           0,
           [11,
            cst,
            [4,
             0,
             0,
             0,
             [11, " || ", [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]]]]]],
       "length mismatch in %s: %d <> %d || %d <> %d"],
    _d_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2, 0, [11, cst$0, [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    _c_ =
      [0,
       [11,
        "List.nth_exn ",
        [4, 0, 0, 0, [11, " called on list of length ", [4, 0, 0, 0, 0]]]],
       "List.nth_exn %d called on list of length %d"],
    cst_List_range_stride_must_be_ = "List.range: stride must be non-zero",
    cst_List_range_stride_function$0 = cst_List_range_stride_function$2,
    cst_List_range_stride_function$1 = cst_List_range_stride_function$2,
    cst_List_range_stride_function =
      "List.range': stride function cannot return the same value",
    _a_ = [0, "Ok"],
    _b_ = [0, "Unequal_lengths"],
    _f_ = [0, "List.find_map_exn: not found"],
    _g_ = [0, "List.find_exn: not found"],
    _h_ = [0, "List.findi_exn: not found"],
    _i_ = [0, "List.find_mapi_exn: not found"],
    _s_ = [0, "List.Assoc.find_exn: not found"],
    cst_Base_List_Transpose_got_li =
      "Base__List.Transpose_got_lists_of_different_lengths";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[194], a_sexp_grammar);
   }
   function compare_local(cmp_a, a_014, b_015){
    if(a_014 === b_015) return 0;
    if(! a_014) return b_015 ? 1 : 0;
    var a_016 = a_014[1];
    if(! b_015) return -1;
    var b_017 = b_015[1];
    return caml_call2(cmp_a, a_016, b_017);
   }
   function compare(cmp_a, a_010, b_011){
    if(a_010 === b_011) return 0;
    if(! a_010) return b_011 ? 1 : 0;
    var a_012 = a_010[1];
    if(! b_011) return -1;
    var b_013 = b_011[1];
    return caml_call2(cmp_a, a_012, b_013);
   }
   function sexp_of_t$0(of_a_018, param){
    if(! param) return _b_;
    var arg0_019 = param[1], res0_020 = caml_call1(of_a_018, arg0_019);
    return [1, [0, _a_, [0, res0_020, 0]]];
   }
   function invariant(f, t){return caml_call2(iter, t, f);}
   function of_list(t){return t;}
   function singleton(x){return [0, x, 0];}
   function range(compare, stride, opt, _bI_, start_i, stop_i){
    if(opt) var sth = opt[1], start = sth; else var start = 104758188;
    if(_bI_) var sth$0 = _bI_[1], stop = sth$0; else var stop = -160346914;
    var next_i = caml_call1(stride, start_i);
    function order(x, y){
     var _bJ_ = caml_call2(compare, x, y);
     return caml_call1(Base_Ordering[11], _bJ_);
    }
    function raise_stride_cannot_return_sam(param){
     return caml_call1(Base_Import[126], cst_List_range_stride_function);
    }
    switch(order(start_i, next_i)){
      case 0:
       var initial_stride_order = 847855481; break;
      case 1:
       var initial_stride_order = raise_stride_cannot_return_sam(0); break;
      default: var initial_stride_order = 85047514;
    }
    var
     start_i$0 = 104758188 <= start ? start_i : next_i,
     i_to_stop_order = order(start_i$0, stop_i);
    a:
    {
     switch(i_to_stop_order){
       case 0:
        if(847855481 > initial_stride_order) break a; break;
       case 1:
        return 104758188 <= stop ? [0, start_i$0, 0] : 0;
       default: if(847855481 <= initial_stride_order) break a;
     }
     var next_i$0 = caml_call1(stride, start_i$0);
     b:
     {
      switch(order(start_i$0, next_i$0)){
        case 0:
         if(847855481 > initial_stride_order) break b; break;
        case 1:
         return raise_stride_cannot_return_sam(0);
        default: if(847855481 <= initial_stride_order) break b;
      }
      var
       block = [0, start_i$0, 24029],
       dst = block,
       offset = 1,
       i = next_i$0;
      for(;;){
       var i_to_stop_order$0 = order(i, stop_i);
       c:
       {
        d:
        {
         switch(i_to_stop_order$0){
           case 0:
            if(847855481 <= initial_stride_order) break d; break;
           case 1:
            if(104758188 <= stop){dst[1 + offset] = [0, i, 0]; break c;}
            dst[1 + offset] = 0;
            break c;
           default: if(847855481 > initial_stride_order) break d;
         }
         dst[1 + offset] = 0;
         break c;
        }
        var next_i$1 = caml_call1(stride, i);
        d:
        {
         switch(order(i, next_i$1)){
           case 0:
            if(847855481 <= initial_stride_order) break d; break;
           case 1:
            dst[1 + offset] = raise_stride_cannot_return_sam(0); break c;
           default: if(847855481 > initial_stride_order) break d;
         }
         dst[1 + offset] =
          caml_call1(Base_Import[126], cst_List_range_stride_function$1);
         break c;
        }
        var dst$0 = [0, i, 24029];
        dst[1 + offset] = dst$0;
        var dst = dst$0, offset = 1, i = next_i$1;
        continue;
       }
       return block;
      }
     }
     return caml_call1(Base_Import[126], cst_List_range_stride_function$0);
    }
    return 0;
   }
   function range$0(opt, _bF_, _bE_, start_i, stop_i){
    if(opt) var sth = opt[1], stride = sth; else var stride = 1;
    if(_bF_) var sth$0 = _bF_[1], start = sth$0; else var start = 104758188;
    if(_bE_) var sth$1 = _bE_[1], stop = sth$1; else var stop = -160346914;
    if(0 === stride)
     caml_call1(Base_Import[126], cst_List_range_stride_must_be_);
    var _bG_ = [0, stop], _bH_ = [0, start];
    return range
            (runtime.caml_int_compare,
             function(x){return caml_call2(Base_Import[91], x, stride);},
             _bH_,
             _bG_,
             start_i,
             stop_i);
   }
   function hd(t){if(! t) return 0; var x = t[1]; return [0, x];}
   function tl(t){if(! t) return 0; var t$0 = t[2]; return [0, t$0];}
   function nth(t, n){
    if(0 > n) return 0;
    var t$0 = t, n$0 = n;
    for(;;){
     if(! t$0) return 0;
     var t$1 = t$0[2], a = t$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = caml_call2(Base_Import[93], n$0, 1), t$0 = t$1, n$0 = n$1;
    }
   }
   function nth_exn(t, n){
    var match = nth(t, n);
    if(! match)
     return caml_call4(invalid_argf, _c_, n, caml_call1(length, t), 0);
    var a = match[1];
    return a;
   }
   function unordered_append(l1, l2){
    if(l1){
     if(l2) return caml_call2(rev_append, l1, l2);
     var l = l1;
    }
    else
     var l = l2;
    return l;
   }
   function of_lists(l1, l2){
    var a = l1, b = l2, shared_length = 0;
    for(;;){
     if(a){
      if(b){
       var
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[91], shared_length, 1),
        a = a$0,
        b = b$0,
        shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b) return [0, shared_length];
     return [1, shared_length, a, b];
    }
   }
   function check_length2_exn(name, l1, l2){
    var match = of_lists(l1, l2);
    if(0 === match[0]) return;
    var
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _bB_ = caml_call1(length, tail_of_b),
     _bC_ = caml_call2(Base_Import[91], shared_length, _bB_),
     _bD_ = caml_call1(length, tail_of_a);
    return caml_call5
            (invalid_argf,
             _d_,
             name,
             caml_call2(Base_Import[91], shared_length, _bD_),
             _bC_,
             0);
   }
   function check_length2(l1, l2, f){
    return 0 === of_lists(l1, l2)[0] ? [0, caml_call2(f, l1, l2)] : 0;
   }
   function of_lists$0(l1, l2, l3){
    var a = l1, b = l2, c = l3, shared_length = 0;
    for(;;){
     if(a){
      if(b && c){
       var
        c$0 = c[2],
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[91], shared_length, 1),
        a = a$0,
        b = b$0,
        c = c$0,
        shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b && ! c) return [0, shared_length];
     return [1, shared_length, a, b, c];
    }
   }
   function check_length3_exn(name, l1, l2, l3){
    var match = of_lists$0(l1, l2, l3);
    if(0 === match[0]) return;
    var
     tail_of_c = match[4],
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _by_ = caml_call1(length, tail_of_a),
     n1 = caml_call2(Base_Import[91], shared_length, _by_),
     _bz_ = caml_call1(length, tail_of_b),
     n2 = caml_call2(Base_Import[91], shared_length, _bz_),
     _bA_ = caml_call1(length, tail_of_c),
     n3 = caml_call2(Base_Import[91], shared_length, _bA_);
    return caml_call7(invalid_argf, _e_, name, n1, n2, n2, n3, 0);
   }
   function check_length3(l1, l2, l3, f){
    return 0 === of_lists$0(l1, l2, l3)[0]
            ? [0, caml_call3(f, l1, l2, l3)]
            : 0;
   }
   function iter2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_bv_){
              var _bw_ = caml_call1(iter2_ok, _bv_);
              return function(_bx_){return caml_call2(_bw_, _bx_, f);};
             });
   }
   function iter2_exn(l1, l2, f){
    check_length2_exn(cst_iter2_exn, l1, l2);
    return caml_call3(iter2_ok, l1, l2, f);
   }
   function rev_map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_bs_){
              var _bt_ = caml_call1(rev_map2_ok, _bs_);
              return function(_bu_){return caml_call2(_bt_, _bu_, f);};
             });
   }
   function rev_map2_exn(l1, l2, f){
    check_length2_exn(cst_rev_map2_exn, l1, l2);
    return caml_call3(rev_map2_ok, l1, l2, f);
   }
   function fold2(l1, l2, init, f){
    return check_length2
            (l1,
             l2,
             function(_bp_){
              var _bq_ = caml_call1(fold2_ok, _bp_);
              return function(_br_){return caml_call3(_bq_, _br_, init, f);};
             });
   }
   function fold2_exn(l1, l2, init, f){
    check_length2_exn(cst_fold2_exn, l1, l2);
    return caml_call4(fold2_ok, l1, l2, init, f);
   }
   function fold_right2(l1, l2, f, init){
    return check_length2
            (l1,
             l2,
             function(_bm_){
              var _bn_ = caml_call1(fold_right2_ok, _bm_);
              return function(_bo_){return caml_call3(_bn_, _bo_, f, init);};
             });
   }
   function fold_right2_exn(l1, l2, f, init){
    check_length2_exn(cst_fold_right2_exn, l1, l2);
    return caml_call4(fold_right2_ok, l1, l2, f, init);
   }
   function for_all2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_bj_){
              var _bk_ = caml_call1(for_all2_ok, _bj_);
              return function(_bl_){return caml_call2(_bk_, _bl_, f);};
             });
   }
   function for_all2_exn(l1, l2, f){
    check_length2_exn(cst_for_all2_exn, l1, l2);
    return caml_call3(for_all2_ok, l1, l2, f);
   }
   function exists2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_bg_){
              var _bh_ = caml_call1(exists2_ok, _bg_);
              return function(_bi_){return caml_call2(_bh_, _bi_, f);};
             });
   }
   function exists2_exn(l1, l2, f){
    check_length2_exn(cst_exists2_exn, l1, l2);
    return caml_call3(exists2_ok, l1, l2, f);
   }
   function mem(t, a, equal){
    var param = t;
    for(;;){
     if(! param) return 0;
     var bs = param[2], b = param[1], _bf_ = caml_call2(equal, a, b);
     if(_bf_) return _bf_;
     var param = bs;
    }
   }
   function rev_filter(t, f){
    var accu = 0, param = t;
    for(;;){
     if(! param) return accu;
     var l = param[2], x = param[1];
     if(caml_call1(f, x))
      var accu$0 = [0, x, accu], accu = accu$0, param = l;
     else
      var param = l;
    }
   }
   function filter(l, f){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1];
     if(caml_call1(f, hd)){
      var block = [0, hd, 24029], dst = block, offset = 1, l$1 = tl;
      for(;;){
       if(! l$1){dst[1 + offset] = 0; return block;}
       var tl$0 = l$1[2], hd$0 = l$1[1];
       if(caml_call1(f, hd$0)){
        var dst$0 = [0, hd$0, 24029];
        dst[1 + offset] = dst$0;
        var dst = dst$0, offset = 1, l$1 = tl$0;
       }
       else
        var l$1 = tl$0;
      }
     }
     else
      var l$0 = tl;
    }
   }
   function find_map(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1], r = caml_call1(f, x);
     if(r) return r;
     var param = l;
    }
   }
   var not_found = [0, Base_Import[297], _f_];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1];
     if(caml_call1(f, x)) return [0, x];
     var param = l;
    }
   }
   var not_found$0 = [0, Base_Import[297], _g_];
   function find_exn(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) throw caml_maybe_attach_backtrace(not_found$0, 1);
     var t$1 = t$0[2], x = t$0[1];
     if(caml_call1(f, x)) return x;
     var t$0 = t$1;
    }
   }
   function findi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1];
     if(caml_call2(f, i, x)) return [0, [0, i, x]];
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, t$0 = l;
    }
   }
   var not_found$1 = [0, Base_Import[297], _h_];
   function findi_exn(t, f){
    var match = findi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$1, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1], result = caml_call2(f, i, x);
     if(result) return result;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, t$0 = l;
    }
   }
   var not_found$2 = [0, Base_Import[297], _i_];
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$2, 1);
    var x = match[1];
    return x;
   }
   function for_alli(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 1;
     var tl = t$0[2], hd = t$0[1], _be_ = caml_call2(f, i, hd);
     if(! _be_) return _be_;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, t$0 = tl;
    }
   }
   function existsi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var tl = t$0[2], hd = t$0[1], _bd_ = caml_call2(f, i, hd);
     if(_bd_) return _bd_;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, t$0 = tl;
    }
   }
   var of_array = Base_Array0[16], to_array = Base_Array0[14];
   function to_list(t){return t;}
   function append(l1$0, l2){
    if(! l2) return l1$0;
    if(! l1$0) return l2;
    var _a9_ = l1$0[2], x1 = l1$0[1];
    if(! _a9_) return [0, x1, l2];
    var _a__ = _a9_[2], x2 = _a9_[1];
    if(! _a__) return [0, x1, [0, x2, l2]];
    var _a$_ = _a__[2], x3 = _a__[1];
    if(! _a$_) return [0, x1, [0, x2, [0, x3, l2]]];
    var match = _a$_[2], x4 = _a$_[1];
    if(! match) return [0, x1, [0, x2, [0, x3, [0, x4, l2]]]];
    var
     tl = match[2],
     x5 = match[1],
     block = [0, x5, 24029],
     dst = block,
     offset = 1,
     l1 = tl;
    for(;;){
     if(l1){
      var _ba_ = l1[2], x1$0 = l1[1];
      if(_ba_){
       var _bb_ = _ba_[2], x2$0 = _ba_[1];
       if(_bb_){
        var _bc_ = _bb_[2], x3$0 = _bb_[1];
        if(_bc_){
         var match$0 = _bc_[2], x4$0 = _bc_[1];
         if(match$0){
          var tl$0 = match$0[2], x5$0 = match$0[1], dst$0 = [0, x5$0, 24029];
          dst[1 + offset] = [0, x1$0, [0, x2$0, [0, x3$0, [0, x4$0, dst$0]]]];
          var dst = dst$0, offset = 1, l1 = tl$0;
          continue;
         }
         dst[1 + offset] = [0, x1$0, [0, x2$0, [0, x3$0, [0, x4$0, l2]]]];
        }
        else
         dst[1 + offset] = [0, x1$0, [0, x2$0, [0, x3$0, l2]]];
       }
       else
        dst[1 + offset] = [0, x1$0, [0, x2$0, l2]];
      }
      else
       dst[1 + offset] = [0, x1$0, l2];
     }
     else
      dst[1 + offset] = l2;
     return [0, x1, [0, x2, [0, x3, [0, x4, block]]]];
    }
   }
   function map(l, f){
    if(! l) return 0;
    var
     tl = l[2],
     x = l[1],
     block = [0, caml_call1(f, x), 24029],
     dst = block,
     offset = 1,
     l$0 = tl;
    for(;;){
     if(! l$0){dst[1 + offset] = 0; return block;}
     var tl$0 = l$0[2], x$0 = l$0[1], dst$0 = [0, caml_call1(f, x$0), 24029];
     dst[1 + offset] = dst$0;
     var dst = dst$0, offset = 1, l$0 = tl$0;
    }
   }
   function folding_map(t, init, f){
    var acc = [0, init];
    return map
            (t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       map
        (t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function symbol_map(l, f){return map(l, f);}
   function map2_ok(l1, l2, f){
    if(l1){
     if(l2){
      var
       l2$0 = l2[2],
       x2 = l2[1],
       l1$0 = l1[2],
       x1 = l1[1],
       block = [0, caml_call2(f, x1, x2), 24029],
       dst = block,
       offset = 1,
       l1$1 = l1$0,
       l2$1 = l2$0;
      for(;;){
       a:
       {
        if(l1$1){
         if(l2$1){
          var
           l2$2 = l2$1[2],
           x2$0 = l2$1[1],
           l1$2 = l1$1[2],
           x1$0 = l1$1[1],
           dst$0 = [0, caml_call2(f, x1$0, x2$0), 24029];
          dst[1 + offset] = dst$0;
          var dst = dst$0, offset = 1, l1$1 = l1$2, l2$1 = l2$2;
          continue;
         }
        }
        else if(! l2$1){dst[1 + offset] = 0; break a;}
        dst[1 + offset] = caml_call1(Base_Import[126], cst_List_map2$0);
       }
       return block;
      }
     }
    }
    else if(! l2) return 0;
    return caml_call1(Base_Import[126], cst_List_map2);
   }
   function map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_a7_){
              return function(_a8_){return map2_ok(_a7_, _a8_, f);};
             });
   }
   function map2_exn(l1, l2, f){
    check_length2_exn(cst_map2_exn, l1, l2);
    return map2_ok(l1, l2, f);
   }
   function rev_map3_ok(l1, l2, l3, f){
    var l1$0 = l1, l2$0 = l2, l3$0 = l3, ac = 0;
    for(;;){
     if(l1$0){
      if(l2$0 && l3$0){
       var
        l3$1 = l3$0[2],
        x3 = l3$0[1],
        l2$1 = l2$0[2],
        x2 = l2$0[1],
        l1$1 = l1$0[2],
        x1 = l1$0[1],
        ac$0 = [0, caml_call3(f, x1, x2, x3), ac],
        l1$0 = l1$1,
        l2$0 = l2$1,
        l3$0 = l3$1,
        ac = ac$0;
       continue;
      }
     }
     else if(! l2$0 && ! l3$0) return ac;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    }
   }
   function rev_map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_a4_){
              return function(_a5_){
               return function(_a6_){
                return rev_map3_ok(_a4_, _a5_, _a6_, f);};};
             });
   }
   function rev_map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_rev_map3_exn, l1, l2, l3);
    return rev_map3_ok(l1, l2, l3, f);
   }
   function map3_ok(l1, l2, l3, f){
    if(l1){
     if(l2 && l3){
      var
       l3$0 = l3[2],
       x3 = l3[1],
       l2$0 = l2[2],
       x2 = l2[1],
       l1$0 = l1[2],
       x1 = l1[1],
       block = [0, caml_call3(f, x1, x2, x3), 24029],
       dst = block,
       offset = 1,
       l1$1 = l1$0,
       l2$1 = l2$0,
       l3$1 = l3$0;
      for(;;){
       a:
       {
        if(l1$1){
         if(l2$1 && l3$1){
          var
           l3$2 = l3$1[2],
           x3$0 = l3$1[1],
           l2$2 = l2$1[2],
           x2$0 = l2$1[1],
           l1$2 = l1$1[2],
           x1$0 = l1$1[1],
           dst$0 = [0, caml_call3(f, x1$0, x2$0, x3$0), 24029];
          dst[1 + offset] = dst$0;
          var dst = dst$0, offset = 1, l1$1 = l1$2, l2$1 = l2$2, l3$1 = l3$2;
          continue;
         }
        }
        else if(! l2$1 && ! l3$1){dst[1 + offset] = 0; break a;}
        dst[1 + offset] = caml_call1(Base_Import[126], cst_List_map3$0);
       }
       return block;
      }
     }
    }
    else if(! l2 && ! l3) return 0;
    return caml_call1(Base_Import[126], cst_List_map3);
   }
   function map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_a1_){
              return function(_a2_){
               return function(_a3_){return map3_ok(_a1_, _a2_, _a3_, f);};};
             });
   }
   function map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_map3_exn, l1, l2, l3);
    return map3_ok(l1, l2, l3, f);
   }
   function rev_map_append(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var
      l1$1 = l1$0[2],
      h = l1$0[1],
      l2$1 = [0, caml_call1(f, h), l2$0],
      l1$0 = l1$1,
      l2$0 = l2$1;
    }
   }
   function unzip(list){
    var list$2 = caml_call1(rev, list), list$0 = list$2, l1 = 0, l2 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2];
     var
      list$1 = list$0[2],
      match = list$0[1],
      y = match[2],
      x = match[1],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1],
      list$0 = list$1,
      l1 = l1$0,
      l2 = l2$0;
    }
   }
   function unzip3(list){
    var
     list$2 = caml_call1(rev, list),
     list$0 = list$2,
     l1 = 0,
     l2 = 0,
     l3 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2, l3];
     var
      list$1 = list$0[2],
      match = list$0[1],
      z = match[3],
      y = match[2],
      x = match[1],
      l3$0 = [0, z, l3],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1],
      list$0 = list$1,
      l1 = l1$0,
      l2 = l2$0,
      l3 = l3$0;
    }
   }
   function zip_exn(l1, l2){
    try{
     var _aZ_ = map2_ok(l1, l2, function(a, b){return [0, a, b];});
     return _aZ_;
    }
    catch(_a0_){
     var _aY_ = caml_call1(length, l2);
     return caml_call4(invalid_argf, _k_, caml_call1(length, l1), _aY_, 0);
    }
   }
   function zip(l1, l2){
    return map2(l1, l2, function(a, b){return [0, a, b];});
   }
   function rev_mapi(l, f){
    var i = 0, acc = 0, param = l;
    for(;;){
     if(! param) return acc;
     var
      t = param[2],
      h = param[1],
      acc$0 = [0, caml_call2(f, i, h), acc],
      i$0 = caml_call2(Base_Import[91], i, 1),
      i = i$0,
      acc = acc$0,
      param = t;
    }
   }
   function mapi(l, f){
    var i$2 = 0;
    if(! l) return 0;
    var
     t = l[2],
     h = l[1],
     block = [0, caml_call2(f, i$2, h), 24029],
     i = caml_call2(Base_Import[91], i$2, 1),
     dst = block,
     offset = 1,
     i$0 = i,
     param = t;
    for(;;){
     if(! param){dst[1 + offset] = 0; return block;}
     var
      t$0 = param[2],
      h$0 = param[1],
      block0_arg0 = caml_call2(f, i$0, h$0),
      block$0 = [0, block0_arg0, 24029];
     dst[1 + offset] = block$0;
     var
      i$1 = caml_call2(Base_Import[91], i$0, 1),
      dst = block$0,
      offset = 1,
      i$0 = i$1,
      param = t$0;
    }
   }
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return mapi
            (t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       mapi
        (t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function iteri(l, f){
    caml_call3
     (fold,
      l,
      0,
      function(i, x){
       caml_call2(f, i, x);
       return caml_call2(Base_Import[91], i, 1);
      });
    return 0;
   }
   function foldi(t, init, f){
    var
     _aW_ =
       caml_call3
        (fold,
         t,
         [0, 0, init],
         function(param, v){
          var acc = param[2], i = param[1], _aX_ = caml_call3(f, i, acc, v);
          return [0, caml_call2(Base_Import[91], i, 1), _aX_];
         });
    return caml_call1(Base_Import[127], _aW_);
   }
   function filteri(l, f){
    var pos = 0, l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1];
     if(caml_call2(f, pos, hd)) break;
     var pos$1 = caml_call2(Base_Import[91], pos, 1), pos = pos$1, l$0 = tl;
    }
    var
     block = [0, hd, 24029],
     pos$0 = caml_call2(Base_Import[91], pos, 1),
     dst = block,
     offset = 1,
     pos$2 = pos$0,
     l$1 = tl;
    for(;;){
     if(! l$1){dst[1 + offset] = 0; return block;}
     var tl$0 = l$1[2], hd$0 = l$1[1];
     if(caml_call2(f, pos$2, hd$0)){
      var block$0 = [0, hd$0, 24029];
      dst[1 + offset] = block$0;
      var
       pos$3 = caml_call2(Base_Import[91], pos$2, 1),
       dst = block$0,
       offset = 1,
       pos$2 = pos$3,
       l$1 = tl$0;
     }
     else
      var
       pos$4 = caml_call2(Base_Import[91], pos$2, 1),
       pos$2 = pos$4,
       l$1 = tl$0;
    }
   }
   function reduce(l, f){
    if(! l) return 0;
    var tl = l[2], hd = l[1];
    return [0, caml_call3(fold, tl, hd, f)];
   }
   function reduce_exn(l, f){
    var match = reduce(l, f);
    if(! match) return caml_call1(Base_Import[126], cst_List_reduce_exn);
    var v = match[1];
    return v;
   }
   function reduce_balanced(l, f){
    function step_accum(num, acc, x){
     var num$0 = num, acc$0 = acc, x$0 = x;
     for(;;){
      if(0 === caml_call2(Base_Import[116], num$0, 1)) return [0, x$0, acc$0];
      if(! acc$0)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
      var
       acc$1 = acc$0[2],
       y = acc$0[1],
       x$1 = caml_call2(f, y, x$0),
       num$1 = caml_call2(Base_Import[115], num$0, 1),
       num$0 = num$1,
       acc$0 = acc$1,
       x$0 = x$1;
     }
    }
    var match = foldi(l, 0, step_accum);
    if(! match) return 0;
    var xs = match[2], x = match[1];
    return [0,
            caml_call3
             (fold, xs, x, function(x, y){return caml_call2(f, y, x);})];
   }
   function reduce_balanced_exn(l, f){
    var match = reduce_balanced(l, f);
    if(! match)
     return caml_call1(Base_Import[126], cst_List_reduce_balanced_exn);
    var v = match[1];
    return v;
   }
   function groupi(l, break$0){
    var pos = [0, 0], l$0 = [0, l];
    function take_group(param){
     var group = l$0[1];
     if(group){
      var tl = group[2];
      if(tl){
       var y = tl[1], x = group[1];
       pos[1] = caml_call2(Base_Import[91], pos[1], 1);
       l$0[1] = tl;
       if(caml_call3(break$0, pos[1], x, y)) return [0, x, 0];
       var block = [0, x, 24029], dst = block, offset = 1;
       for(;;){
        var group$0 = l$0[1];
        a:
        {
         if(group$0){
          var tl$0 = group$0[2];
          if(tl$0){
           var y$0 = tl$0[1], x$0 = group$0[1];
           pos[1] = caml_call2(Base_Import[91], pos[1], 1);
           l$0[1] = tl$0;
           if(caml_call3(break$0, pos[1], x$0, y$0)){dst[1 + offset] = [0, x$0, 0]; break a;}
           var dst$0 = [0, x$0, 24029];
           dst[1 + offset] = dst$0;
           var dst = dst$0, offset = 1;
           continue;
          }
         }
         l$0[1] = 0;
         dst[1 + offset] = group$0;
        }
        return block;
       }
      }
     }
     l$0[1] = 0;
     return group;
    }
    if(caml_call1(is_empty, l$0[1])) return 0;
    var
     group = take_group(0),
     block = [0, group, 24029],
     dst = block,
     offset = 1;
    for(;;){
     if(caml_call1(is_empty, l$0[1])){dst[1 + offset] = 0; return block;}
     var group$0 = take_group(0), dst$0 = [0, group$0, 24029];
     dst[1 + offset] = dst$0;
     var dst = dst$0, offset = 1;
    }
   }
   function group(l, break$0){
    return groupi(l, function(param, x, y){return caml_call2(break$0, x, y);});
   }
   function merge(l1, l2, compare){
    if(! l1) return l2;
    if(! l2) return l1;
    var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
    if(0 < caml_call2(compare, h1, h2)){
     var block = [0, h2, 24029];
     merge_dps(block, 1, l1, t2, compare);
     return block;
    }
    var block$0 = [0, h1, 24029];
    merge_dps(block$0, 1, t1, l2, compare);
    return block$0;
   }
   function merge_dps(dst, offset, l1, l2, compare){
    var dst$0 = dst, offset$0 = offset, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0){dst$0[1 + offset$0] = l2$0; return;}
     if(! l2$0){dst$0[1 + offset$0] = l1$0; return;}
     var t2 = l2$0[2], h2 = l2$0[1], t1 = l1$0[2], h1 = l1$0[1];
     if(0 < caml_call2(compare, h1, h2)){
      var dst$1 = [0, h2, 24029];
      dst$0[1 + offset$0] = dst$1;
      var dst$0 = dst$1, offset$0 = 1, l2$0 = t2;
     }
     else{
      var dst$2 = [0, h1, 24029];
      dst$0[1 + offset$0] = dst$2;
      var dst$0 = dst$2, offset$0 = 1, l1$0 = t1;
     }
    }
   }
   function stable_sort(l, cmp){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x2, [0, x1, 0]]
            : [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _aV_ = l[2];
      if(_aV_){
       var match$2 = _aV_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _aV_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x1$0, x3)
              ? 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                : [0, x2$0, [0, x3, [0, x1$0, 0]]]
              : [0, x2$0, [0, x1$0, [0, x3, 0]]]
            : 0
              < caml_call2(cmp, x2$0, x3)
              ? 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x1$0, [0, x3, [0, x2$0, 0]]]
              : [0, x1$0, [0, x2$0, [0, x3, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = caml_call2(Base_Import[115], n, 1),
      n2 = caml_call2(Base_Import[93], n, n1),
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h1, accu], l1 = t1, accu = accu$0;
         continue;
        }
        var accu$1 = [0, h2, accu], l2 = t2, accu = accu$1;
        continue;
       }
       var _aU_ = caml_call2(rev_append, l1, accu);
      }
      else
       var _aU_ = caml_call2(rev_append, l2, accu);
      return [0, _aU_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         s =
           0 < caml_call2(cmp, x1, x2)
            ? [0, x1, [0, x2, 0]]
            : [0, x2, [0, x1, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _aT_ = l[2];
      if(_aT_){
       var match$2 = _aT_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _aT_[1],
         x1$0 = l[1],
         s$0 =
           0 < caml_call2(cmp, x1$0, x2$0)
            ? 0
              < caml_call2(cmp, x2$0, x3)
              ? [0, x1$0, [0, x2$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x1$0, x3)
                ? [0, x1$0, [0, x3, [0, x2$0, 0]]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]]
            : 0
              < caml_call2(cmp, x1$0, x3)
              ? [0, x2$0, [0, x1$0, [0, x3, 0]]]
              : 0
                < caml_call2(cmp, x2$0, x3)
                ? [0, x2$0, [0, x3, [0, x1$0, 0]]]
                : [0, x3, [0, x2$0, [0, x1$0, 0]]];
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = caml_call2(Base_Import[115], n, 1),
      n2 = caml_call2(Base_Import[93], n, n1),
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        if(0 < caml_call2(cmp, h1, h2)){
         var accu$0 = [0, h2, accu], l2 = t2, accu = accu$0;
         continue;
        }
        var accu$1 = [0, h1, accu], l1 = t1, accu = accu$1;
        continue;
       }
       var _aS_ = caml_call2(rev_append, l1, accu);
      }
      else
       var _aS_ = caml_call2(rev_append, l2, accu);
      return [0, _aS_, tl$0];
     }
    }
    var len = caml_call1(length, l);
    if(2 > len) return l;
    var _aR_ = sort(len, l);
    return caml_call1(Base_Import[125], _aR_);
   }
   function sort_and_group(l, compare){
    var _aQ_ = stable_sort(l, compare);
    return group
            (_aQ_,
             function(x, y){return 0 !== caml_call2(compare, x, y) ? 1 : 0;});
   }
   function dedup_and_sort(l, cmp){
    function sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2);
        if(0 <= c$0)
         var _aC_ = 0 < c$0 ? [0, x2, [0, x1, 0]] : [0, x2, 0], s = _aC_;
        else
         var s = [0, x1, [0, x2, 0]];
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _aE_ = l[2];
      if(_aE_){
       var match$2 = _aE_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _aE_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 <= c$1){
         if(0 < c$1){
          var c$2 = caml_call2(cmp, x1$0, x3);
          if(0 <= c$2){
           if(0 < c$2){
            var c$3 = caml_call2(cmp, x2$0, x3);
            if(0 <= c$3)
             var
              _aF_ =
                0 < c$3
                 ? [0, x3, [0, x2$0, [0, x1$0, 0]]]
                 : [0, x3, [0, x1$0, 0]],
              _aG_ = _aF_;
            else
             var _aG_ = [0, x2$0, [0, x3, [0, x1$0, 0]]];
            var _aH_ = _aG_;
           }
           else
            var _aH_ = [0, x2$0, [0, x3, 0]];
           var _aI_ = _aH_;
          }
          else
           var _aI_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
          var _aJ_ = _aI_;
         }
         else{
          var c$4 = caml_call2(cmp, x2$0, x3);
          if(0 <= c$4)
           var
            _aK_ = 0 < c$4 ? [0, x3, [0, x2$0, 0]] : [0, x3, 0],
            _aL_ = _aK_;
          else
           var _aL_ = [0, x2$0, [0, x3, 0]];
          var _aJ_ = _aL_;
         }
         var s$0 = _aJ_;
        }
        else{
         var c$5 = caml_call2(cmp, x2$0, x3);
         if(0 <= c$5){
          if(0 < c$5){
           var c$6 = caml_call2(cmp, x1$0, x3);
           if(0 <= c$6)
            var
             _aM_ =
               0 < c$6
                ? [0, x3, [0, x1$0, [0, x2$0, 0]]]
                : [0, x3, [0, x2$0, 0]],
             _aN_ = _aM_;
           else
            var _aN_ = [0, x1$0, [0, x3, [0, x2$0, 0]]];
           var _aO_ = _aN_;
          }
          else
           var _aO_ = [0, x1$0, [0, x3, 0]];
          var _aP_ = _aO_;
         }
         else
          var _aP_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         var s$0 = _aP_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = caml_call2(Base_Import[115], n, 1),
      n2 = caml_call2(Base_Import[93], n, n1),
      match$0 = rev_sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = rev_sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 < c){
         var accu$0 = [0, h1, accu], l1 = t1, accu = accu$0;
         continue;
        }
        if(0 <= c){var l1 = t1; continue;}
        var accu$1 = [0, h2, accu], l2 = t2, accu = accu$1;
        continue;
       }
       var _aD_ = caml_call2(rev_append, l1, accu);
      }
      else
       var _aD_ = caml_call2(rev_append, l2, accu);
      return [0, _aD_, tl$0];
     }
    }
    function rev_sort(n, l){
     if(2 === n){
      if(l){
       var match = l[2];
       if(match){
        var
         tl = match[2],
         x2 = match[1],
         x1 = l[1],
         c$0 = caml_call2(cmp, x1, x2);
        if(0 < c$0)
         var s = [0, x1, [0, x2, 0]];
        else
         var _ao_ = 0 <= c$0 ? [0, x2, 0] : [0, x2, [0, x1, 0]], s = _ao_;
        return [0, s, tl];
       }
      }
     }
     else if(3 === n && l){
      var _aq_ = l[2];
      if(_aq_){
       var match$2 = _aq_[2];
       if(match$2){
        var
         tl$1 = match$2[2],
         x3 = match$2[1],
         x2$0 = _aq_[1],
         x1$0 = l[1],
         c$1 = caml_call2(cmp, x1$0, x2$0);
        if(0 < c$1){
         var c$2 = caml_call2(cmp, x2$0, x3);
         if(0 < c$2)
          var _ar_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
         else{
          if(0 <= c$2)
           var _as_ = [0, x1$0, [0, x3, 0]];
          else{
           var c$3 = caml_call2(cmp, x1$0, x3);
           if(0 < c$3)
            var _at_ = [0, x1$0, [0, x3, [0, x2$0, 0]]];
           else
            var
             _au_ =
               0 <= c$3
                ? [0, x3, [0, x2$0, 0]]
                : [0, x3, [0, x1$0, [0, x2$0, 0]]],
             _at_ = _au_;
           var _as_ = _at_;
          }
          var _ar_ = _as_;
         }
         var s$0 = _ar_;
        }
        else{
         if(0 <= c$1){
          var c$4 = caml_call2(cmp, x2$0, x3);
          if(0 < c$4)
           var _av_ = [0, x2$0, [0, x3, 0]];
          else
           var
            _ax_ = 0 <= c$4 ? [0, x3, 0] : [0, x3, [0, x2$0, 0]],
            _av_ = _ax_;
          var _aw_ = _av_;
         }
         else{
          var c$5 = caml_call2(cmp, x1$0, x3);
          if(0 < c$5)
           var _ay_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
          else{
           if(0 <= c$5)
            var _az_ = [0, x2$0, [0, x3, 0]];
           else{
            var c$6 = caml_call2(cmp, x2$0, x3);
            if(0 < c$6)
             var _aA_ = [0, x2$0, [0, x3, [0, x1$0, 0]]];
            else
             var
              _aB_ =
                0 <= c$6
                 ? [0, x3, [0, x1$0, 0]]
                 : [0, x3, [0, x2$0, [0, x1$0, 0]]],
              _aA_ = _aB_;
            var _az_ = _aA_;
           }
           var _ay_ = _az_;
          }
          var _aw_ = _ay_;
         }
         var s$0 = _aw_;
        }
        return [0, s$0, tl$1];
       }
      }
     }
     var
      n1 = caml_call2(Base_Import[115], n, 1),
      n2 = caml_call2(Base_Import[93], n, n1),
      match$0 = sort(n1, l),
      l2$0 = match$0[2],
      s1 = match$0[1],
      match$1 = sort(n2, l2$0),
      tl$0 = match$1[2],
      s2 = match$1[1],
      l1 = s1,
      l2 = s2,
      accu = 0;
     for(;;){
      if(l1){
       if(l2){
        var
         t2 = l2[2],
         h2 = l2[1],
         t1 = l1[2],
         h1 = l1[1],
         c = caml_call2(cmp, h1, h2);
        if(0 > c){
         var accu$1 = [0, h1, accu], l1 = t1, accu = accu$1;
         continue;
        }
        if(0 < c){
         var accu$0 = [0, h2, accu], l2 = t2, accu = accu$0;
         continue;
        }
        var l1 = t1;
        continue;
       }
       var _ap_ = caml_call2(rev_append, l1, accu);
      }
      else
       var _ap_ = caml_call2(rev_append, l2, accu);
      return [0, _ap_, tl$0];
     }
    }
    var len = caml_call1(length, l);
    if(2 > len) return l;
    var _an_ = sort(len, l);
    return caml_call1(Base_Import[125], _an_);
   }
   function stable_dedup(list, compare){
    if(list && list[2]){
     var
      dedups = caml_call2(rev_map, list, function(elt){return [0, elt, 1];}),
      unique =
        dedup_and_sort
         (dedups, function(x, y){return caml_call2(compare, x[1], y[1]);});
     caml_call2(iter, unique, function(dedup){dedup[2] = 0; return 0;});
     return caml_call3
             (fold,
              dedups,
              0,
              function(acc, dedup){
               return dedup[2] ? acc : [0, dedup[1], acc];
              });
    }
    return list;
   }
   function concat_mapi(l, f){
    function outer_loop_dps$0(counter, dst, offset, pos, param){
     if(! param){dst[1 + offset] = 0; return;}
     var tl = param[2], hd = param[1];
     if(! tl){dst[1 + offset] = caml_call2(f, pos, hd); return;}
     var
      _al_ = caml_call2(f, pos, hd),
      _am_ = caml_call2(Base_Import[91], pos, 1);
     if(counter >= 50)
      return caml_trampoline_return
              (inner_loop_dps$0, [0, dst, offset, _am_, _al_, tl]);
     var counter$0 = counter + 1 | 0;
     return inner_loop_dps$0(counter$0, dst, offset, _am_, _al_, tl);
    }
    function inner_loop_dps$0(counter, dst, offset, pos, l1, l2){
     var dst$0 = dst, offset$0 = offset, l1$0 = l1;
     for(;;){
      if(! l1$0){
       if(counter >= 50)
        return caml_trampoline_return
                (outer_loop_dps$0, [0, dst$0, offset$0, pos, l2]);
       var counter$4 = counter + 1 | 0;
       return outer_loop_dps$0(counter$4, dst$0, offset$0, pos, l2);
      }
      var _aa_ = l1$0[2], x1 = l1$0[1];
      if(! _aa_){
       var _aj_ = [0, x1, 24029];
       dst$0[1 + offset$0] = _aj_;
       var _ak_ = 1;
       if(counter >= 50)
        return caml_trampoline_return
                (outer_loop_dps$0, [0, _aj_, _ak_, pos, l2]);
       var counter$3 = counter + 1 | 0;
       return outer_loop_dps$0(counter$3, _aj_, _ak_, pos, l2);
      }
      var _ab_ = _aa_[2], x2 = _aa_[1];
      if(! _ab_){
       var _ah_ = [0, x2, 24029];
       dst$0[1 + offset$0] = [0, x1, _ah_];
       var _ai_ = 1;
       if(counter >= 50)
        return caml_trampoline_return
                (outer_loop_dps$0, [0, _ah_, _ai_, pos, l2]);
       var counter$2 = counter + 1 | 0;
       return outer_loop_dps$0(counter$2, _ah_, _ai_, pos, l2);
      }
      var _ac_ = _ab_[2], x3 = _ab_[1];
      if(! _ac_){
       var _af_ = [0, x3, 24029];
       dst$0[1 + offset$0] = [0, x1, [0, x2, _af_]];
       var _ag_ = 1;
       if(counter >= 50)
        return caml_trampoline_return
                (outer_loop_dps$0, [0, _af_, _ag_, pos, l2]);
       var counter$1 = counter + 1 | 0;
       return outer_loop_dps$0(counter$1, _af_, _ag_, pos, l2);
      }
      var match = _ac_[2], x4 = _ac_[1];
      if(! match){
       var _ad_ = [0, x4, 24029];
       dst$0[1 + offset$0] = [0, x1, [0, x2, [0, x3, _ad_]]];
       var _ae_ = 1;
       if(counter >= 50)
        return caml_trampoline_return
                (outer_loop_dps$0, [0, _ad_, _ae_, pos, l2]);
       var counter$0 = counter + 1 | 0;
       return outer_loop_dps$0(counter$0, _ad_, _ae_, pos, l2);
      }
      var tl = match[2], x5 = match[1], dst$1 = [0, x5, 24029];
      dst$0[1 + offset$0] = [0, x1, [0, x2, [0, x3, [0, x4, dst$1]]]];
      var dst$0 = dst$1, offset$0 = 1, l1$0 = tl;
     }
    }
    function outer_loop_dps(dst, offset, pos, param){
     return caml_trampoline(outer_loop_dps$0(0, dst, offset, pos, param));
    }
    function inner_loop_dps(dst, offset, pos, l1, l2){
     return caml_trampoline(inner_loop_dps$0(0, dst, offset, pos, l1, l2));
    }
    var pos = 0, param = l;
    for(;;){
     if(! param) return 0;
     var tl = param[2], hd = param[1];
     if(! tl) return caml_call2(f, pos, hd);
     var
      l1 = caml_call2(f, pos, hd),
      pos$0 = caml_call2(Base_Import[91], pos, 1);
     if(l1) break;
     var pos = pos$0, param = tl;
    }
    var _Z_ = l1[2], x1 = l1[1];
    if(! _Z_){
     var block$3 = [0, x1, 24029];
     outer_loop_dps(block$3, 1, pos$0, tl);
     return block$3;
    }
    var ___ = _Z_[2], x2 = _Z_[1];
    if(! ___){
     var block$2 = [0, x2, 24029];
     outer_loop_dps(block$2, 1, pos$0, tl);
     return [0, x1, block$2];
    }
    var _$_ = ___[2], x3 = ___[1];
    if(! _$_){
     var block$1 = [0, x3, 24029];
     outer_loop_dps(block$1, 1, pos$0, tl);
     return [0, x1, [0, x2, block$1]];
    }
    var match = _$_[2], x4 = _$_[1];
    if(match){
     var tl$0 = match[2], x5 = match[1], block = [0, x5, 24029];
     inner_loop_dps(block, 1, pos$0, tl$0, tl);
     return [0, x1, [0, x2, [0, x3, [0, x4, block]]]];
    }
    var block$0 = [0, x4, 24029];
    outer_loop_dps(block$0, 1, pos$0, tl);
    return [0, x1, [0, x2, [0, x3, block$0]]];
   }
   function concat_map(l, f){
    return concat_mapi(l, function(param, x){return caml_call1(f, x);});
   }
   function map2$0(a, b, f){
    return concat_map
            (a,
             function(x){
              return map(b, function(y){return caml_call2(f, x, y);});
             });
   }
   function symbol_bind(t, f){return concat_map(t, f);}
   var
    map$0 = [0, -198771759, map],
    Applicative =
      caml_call1(Base_Applicative[13], [0, singleton, map2$0, map$0]),
    map$1 = [0, -198771759, map],
    Monad = caml_call1(Base_Monad[1], [0, concat_map, singleton, map$1]),
    all = Monad[9],
    all_unit = Monad[10],
    ignore_m = Monad[8],
    join = Monad[7],
    apply = Applicative[8],
    both = Applicative[3],
    map3$0 = Applicative[10],
    symbol = Applicative[4],
    symbol$0 = Applicative[6],
    symbol$1 = Applicative[5],
    symbol$2 = Applicative[4],
    symbol$3 = Applicative[6],
    symbol$4 = Applicative[5],
    Open_on_rhs = [0],
    Let_syntax = [0, singleton, concat_map, map, both, Open_on_rhs],
    Let_syntax$0 = [0, singleton, symbol_bind, symbol_map, Let_syntax],
    Monad_infix = [0, symbol_bind, symbol_map];
   function last_exn(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return caml_call1(Base_Import[126], cst_List_last);
     var x = list$0[1];
     if(! list$0[2]) return x;
     var list$1 = list$0[2], list$0 = list$1;
    }
   }
   function last(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return 0;
     var x = list$0[1];
     if(! list$0[2]) return [0, x];
     var list$1 = list$0[2], list$0 = list$1;
    }
   }
   function is_prefix(list, prefix, equal){
    var list$0 = list, prefix$0 = prefix;
    for(;;){
     if(! prefix$0) return 1;
     var prefix$1 = prefix$0[2], hd = prefix$0[1];
     if(! list$0) return 0;
     var
      list$1 = list$0[2],
      hd$0 = list$0[1],
      _Y_ = caml_call2(equal, hd, hd$0);
     if(! _Y_) return _Y_;
     var list$0 = list$1, prefix$0 = prefix$1;
    }
   }
   function find_consecutive_duplicate(t, equal){
    if(! t) return 0;
    var t$0 = t[2], a1 = t[1], a1$0 = a1, t$1 = t$0;
    for(;;){
     if(! t$1) return 0;
     var t$2 = t$1[2], a2 = t$1[1];
     if(caml_call2(equal, a1$0, a2)) return [0, [0, a1$0, a2]];
     var a1$0 = a2, t$1 = t$2;
    }
   }
   function remove_consecutive_duplicates(opt, list, equal){
    if(opt)
     var sth = opt[1], which_to_keep = sth;
    else
     var which_to_keep = 847656566;
    if(! list) return 0;
    var
     tl$0 = list[2],
     to_keep$2 = list[1],
     to_keep = to_keep$2,
     accum = 0,
     param = tl$0;
    for(;;){
     if(! param) return caml_call1(rev, [0, to_keep, accum]);
     var tl = param[2], to_keep$0 = param[1];
     if(caml_call2(equal, to_keep$0, to_keep))
      var
       to_keep$1 = 847656566 <= which_to_keep ? to_keep$0 : to_keep,
       to_keep = to_keep$1,
       param = tl;
     else
      var
       accum$0 = [0, to_keep, accum],
       to_keep = to_keep$0,
       accum = accum$0,
       param = tl;
    }
   }
   function find_a_dup(l, compare){
    var sorted = stable_sort(l, compare), l$0 = sorted;
    for(;;){
     if(l$0){
      var tl = l$0[2];
      if(tl){
       var hd2 = tl[1], hd1 = l$0[1];
       if(0 === caml_call2(compare, hd1, hd2)) return [0, hd1];
       var l$0 = tl;
       continue;
      }
     }
     return 0;
    }
   }
   function contains_dup(lst, compare){
    return find_a_dup(lst, compare) ? 1 : 0;
   }
   function find_all_dups(l, compare){
    var sorted = stable_sort(l, compare);
    if(! sorted) return 0;
    var
     sorted$4 = sorted[2],
     prev$3 = sorted[1],
     sorted$0 = sorted$4,
     prev = prev$3,
     already_recorded = 0;
    for(;;){
     if(! sorted$0) return 0;
     var sorted$1 = sorted$0[2], prev$0 = sorted$0[1];
     if(0 === caml_call2(compare, prev, prev$0)){
      if(! already_recorded) break;
      var sorted$0 = sorted$1, prev = prev$0, already_recorded = 1;
     }
     else
      var sorted$0 = sorted$1, prev = prev$0, already_recorded = 0;
    }
    var
     block = [0, prev$0, 24029],
     dst = block,
     offset = 1,
     sorted$2 = sorted$1,
     prev$1 = prev$0,
     already_recorded$0 = 1;
    for(;;){
     if(! sorted$2){dst[1 + offset] = 0; return block;}
     var sorted$3 = sorted$2[2], prev$2 = sorted$2[1];
     if(0 === caml_call2(compare, prev$1, prev$2))
      if(already_recorded$0)
       var sorted$2 = sorted$3, prev$1 = prev$2, already_recorded$0 = 1;
      else{
       var dst$0 = [0, prev$2, 24029];
       dst[1 + offset] = dst$0;
       var
        dst = dst$0,
        offset = 1,
        sorted$2 = sorted$3,
        prev$1 = prev$2,
        already_recorded$0 = 1;
      }
     else
      var sorted$2 = sorted$3, prev$1 = prev$2, already_recorded$0 = 0;
    }
   }
   function all_equal(t$0, equal){
    if(! t$0) return 0;
    var xs$0 = t$0[2], x$0 = t$0[1], t = xs$0;
    for(;;){
     if(t){
      var xs = t[2], x = t[1], _W_ = caml_call2(equal, x, x$0);
      if(_W_){var t = xs; continue;}
      var _X_ = _W_;
     }
     else
      var _X_ = 1;
     return _X_ ? [0, x$0] : 0;
    }
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(idx, count, a){
              return caml_call2(f, idx, a)
                      ? caml_call2(Base_Import[91], count, 1)
                      : count;
             });
   }
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _m_, n, 0);
    var i = n, accum = 0;
    for(;;){
     if(0 > i) throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
     if(0 === i) return accum;
     var
      accum$0 = [0, caml_call1(f, caml_call2(Base_Import[93], i, 1)), accum],
      i$0 = caml_call2(Base_Import[93], i, 1),
      i = i$0,
      accum = accum$0;
    }
   }
   function rev_filter_map(l, f){
    var l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call1(f, hd);
     if(match)
      var x = match[1], accum$0 = [0, x, accum], l$0 = tl, accum = accum$0;
     else
      var l$0 = tl;
    }
   }
   function filter_map(l, f){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1], match = caml_call1(f, hd);
     if(match){
      var
       x = match[1],
       block = [0, x, 24029],
       dst = block,
       offset = 1,
       l$1 = tl;
      for(;;){
       if(! l$1){dst[1 + offset] = 0; return block;}
       var tl$0 = l$1[2], hd$0 = l$1[1], match$0 = caml_call1(f, hd$0);
       if(match$0){
        var x$0 = match$0[1], dst$0 = [0, x$0, 24029];
        dst[1 + offset] = dst$0;
        var dst = dst$0, offset = 1, l$1 = tl$0;
       }
       else
        var l$1 = tl$0;
      }
     }
     else
      var l$0 = tl;
    }
   }
   function rev_filter_mapi(l, f){
    var i = 0, l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call2(f, i, hd);
     if(match)
      var
       x = match[1],
       accum$0 = [0, x, accum],
       i$0 = caml_call2(Base_Import[91], i, 1),
       i = i$0,
       l$0 = tl,
       accum = accum$0;
     else
      var i$1 = caml_call2(Base_Import[91], i, 1), i = i$1, l$0 = tl;
    }
   }
   function filter_mapi(l, f){
    var pos = 0, l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1], match = caml_call2(f, pos, hd);
     if(match) break;
     var pos$1 = caml_call2(Base_Import[91], pos, 1), pos = pos$1, l$0 = tl;
    }
    var
     x = match[1],
     block = [0, x, 24029],
     pos$0 = caml_call2(Base_Import[91], pos, 1),
     dst = block,
     offset = 1,
     pos$2 = pos$0,
     l$1 = tl;
    for(;;){
     if(! l$1){dst[1 + offset] = 0; return block;}
     var tl$0 = l$1[2], hd$0 = l$1[1], match$0 = caml_call2(f, pos$2, hd$0);
     if(match$0){
      var x$0 = match$0[1], block$0 = [0, x$0, 24029];
      dst[1 + offset] = block$0;
      var
       pos$3 = caml_call2(Base_Import[91], pos$2, 1),
       dst = block$0,
       offset = 1,
       pos$2 = pos$3,
       l$1 = tl$0;
     }
     else
      var
       pos$4 = caml_call2(Base_Import[91], pos$2, 1),
       pos$2 = pos$4,
       l$1 = tl$0;
    }
   }
   function filter_opt(l){return filter_map(l, function(_V_){return _V_;});}
   function partition3_map(t, f){
    var t$0 = t, fst = 0, snd = 0, trd = 0;
    for(;;){
     if(! t$0){
      var _T_ = caml_call1(rev, trd), _U_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _U_, _T_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x), _S_ = match[1];
     if(4152137 === _S_)
      var y = match[2], snd$0 = [0, y, snd], t$0 = t$1, snd = snd$0;
     else if(4202758 <= _S_)
      var y$0 = match[2], trd$0 = [0, y$0, trd], t$0 = t$1, trd = trd$0;
     else
      var y$1 = match[2], fst$0 = [0, y$1, fst], t$0 = t$1, fst = fst$0;
    }
   }
   function partition_tf(t, f){
    function f$0(x){return caml_call1(f, x) ? [0, x] : [1, x];}
    return caml_call2(partition_map, t, f$0);
   }
   function partition_result(t){
    return caml_call2(partition_map, t, Base_Result[38]);
   }
   function t_of_sexp$0(of_a_028, of_b_029, x_037){
    function _P_(sexp_035){
     if(1 === sexp_035[0]){
      var _Q_ = sexp_035[1];
      if(_Q_){
       var _R_ = _Q_[2];
       if(_R_ && ! _R_[2]){
        var
         arg1_032 = _R_[1],
         arg0_031 = _Q_[1],
         res0_033 = caml_call1(of_a_028, arg0_031),
         res1_034 = caml_call1(of_b_029, arg1_032);
        return [0, res0_033, res1_034];
       }
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4], error_source_036, 2, sexp_035);
    }
    return caml_call2(Base_Import[173], _P_, x_037);
   }
   function sexp_of_t$1(of_a_038, of_b_039, x_044){
    function _O_(param){
     var
      arg1_041 = param[2],
      arg0_040 = param[1],
      res0_042 = caml_call1(of_a_038, arg0_040),
      res1_043 = caml_call1(of_b_039, arg1_041);
     return [1, [0, res0_042, [0, res1_043, 0]]];
    }
    return caml_call2(Base_Import[149], _O_, x_044);
   }
   function t_sexp_grammar$0(a_sexp_grammar, b_sexp_grammar){
    var
     _N_ =
       caml_call1
        (Base_Import[194],
         [2,
          [0,
           [5, [0, Sexplib0_Sexp_grammar[6], _o_, a_sexp_grammar]],
           [0, [5, [0, Sexplib0_Sexp_grammar[7], _p_, b_sexp_grammar]], 0]]]);
    return [5, [0, Sexplib0_Sexp_grammar[5], _q_, _N_]];
   }
   function pair_of_group(list){
    if(! list) throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
    var k = list[1][1];
    return [0, k, map(list, Base_Import[127])];
   }
   function group$0(alist, equal){
    return map
            (group
              (alist,
               function(param, _M_){
                var y = _M_[1], x = param[1];
                return 1 - caml_call2(equal, x, y);
               }),
             pair_of_group);
   }
   function sort_and_group$0(alist, compare){
    return map
            (sort_and_group
              (alist,
               function(param, _L_){
                var y = _L_[1], x = param[1];
                return caml_call2(compare, x, y);
               }),
             pair_of_group);
   }
   function find$0(t, equal, key){
    var
     match =
       find
        (t,
         function(param){
          var key$0 = param[1];
          return caml_call2(equal, key, key$0);
         });
    if(! match) return 0;
    var x = match[1];
    return [0, caml_call1(Base_Import[127], x)];
   }
   var not_found$3 = [0, Base_Import[297], _s_];
   function find_exn$0(t, equal, key){
    var t$0 = t;
    for(;;){
     if(! t$0) throw caml_maybe_attach_backtrace(not_found$3, 1);
     var t$1 = t$0[2], match = t$0[1], value = match[2], key$0 = match[1];
     if(caml_call2(equal, key, key$0)) return value;
     var t$0 = t$1;
    }
   }
   function mem$0(t, equal, key){return find$0(t, equal, key) ? 1 : 0;}
   function remove(t, equal, key){
    return filter
            (t,
             function(param){
              var key$0 = param[1];
              return 1 - caml_call2(equal, key, key$0);
             });
   }
   function add(t, equal, key, value){
    return [0, [0, key, value], remove(t, equal, key)];
   }
   function inverse(t){
    return map
            (t,
             function(param){
              var y = param[2], x = param[1];
              return [0, y, x];
             });
   }
   function map$2(t, f){
    return map
            (t,
             function(param){
              var value = param[2], key = param[1];
              return [0, key, caml_call1(f, value)];
             });
   }
   function sub(l, pos, len){
    var _H_ = pos < 0 ? 1 : 0;
    if(_H_)
     var _I_ = _H_;
    else{
     var _J_ = len < 0 ? 1 : 0;
     if(_J_)
      var _I_ = _J_;
     else
      var
       _K_ = caml_call1(length, l),
       _I_ = caml_call2(Base_Import[93], _K_, len) < pos ? 1 : 0;
    }
    if(_I_) caml_call1(Base_Import[126], cst_List_sub);
    var stop = caml_call2(Base_Import[91], pos, len), i = 0, l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1];
     if(i >= pos) break;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, l$0 = tl;
    }
    if(i >= stop) return 0;
    var
     block = [0, hd, 24029],
     i$1 = caml_call2(Base_Import[91], i, 1),
     dst = block,
     offset = 1,
     i$2 = i$1,
     l$1 = tl;
    for(;;){
     if(l$1){
      var tl$0 = l$1[2], hd$0 = l$1[1];
      if(i$2 < pos){
       var i$3 = caml_call2(Base_Import[91], i$2, 1), i$2 = i$3, l$1 = tl$0;
       continue;
      }
      if(i$2 < stop){
       var block$0 = [0, hd$0, 24029];
       dst[1 + offset] = block$0;
       var
        i$4 = caml_call2(Base_Import[91], i$2, 1),
        dst = block$0,
        offset = 1,
        i$2 = i$4,
        l$1 = tl$0;
       continue;
      }
      dst[1 + offset] = 0;
     }
     else
      dst[1 + offset] = 0;
     return block;
    }
   }
   function split_n(t_orig, n){
    if(0 >= n) return [0, 0, t_orig];
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(! t) return [0, t_orig, 0];
     var tl = t[2], hd = t[1];
     if(0 === n$0) return [0, caml_call1(rev, accum), t];
     var
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[93], n$0, 1),
      n$0 = n$1,
      t = tl,
      accum = accum$0;
    }
   }
   function take(t_orig, n){
    if(0 >= n) return 0;
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(! t) return t_orig;
     var tl = t[2], hd = t[1];
     if(0 === n$0) return caml_call1(rev, accum);
     var
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[93], n$0, 1),
      n$0 = n$1,
      t = tl,
      accum = accum$0;
    }
   }
   function drop(t, n){
    var t$0 = t, n$0 = n;
    for(;;){
     if(t$0){
      var tl = t$0[2];
      if(0 < n$0){
       var n$1 = caml_call2(Base_Import[93], n$0, 1), t$0 = tl, n$0 = n$1;
       continue;
      }
     }
     return t$0;
    }
   }
   function chunks_of(l, length){
    if(length <= 0) caml_call3(invalid_argf, _t_, length, 0);
    var acc = 0, l$0 = l;
    for(;;){
     if(! l$0) return caml_call1(rev, acc);
     var
      match = split_n(l$0, length),
      l$1 = match[2],
      sublist = match[1],
      acc$0 = [0, sublist, acc],
      acc = acc$0,
      l$0 = l$1;
    }
   }
   function split_while(xs, f){
    var acc = 0, t = xs;
    for(;;){
     if(t){
      var tl = t[2], hd = t[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc], acc = acc$0, t = tl;
       continue;
      }
     }
     return [0, caml_call1(rev, acc), t];
    }
   }
   function take_while(xs, f){
    var acc = 0, param = xs;
    for(;;){
     if(param){
      var tl = param[2], hd = param[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc], acc = acc$0, param = tl;
       continue;
      }
     }
     return caml_call1(rev, acc);
    }
   }
   function drop_while(t, f){
    var t$0 = t;
    for(;;){
     if(t$0){
      var tl = t$0[2], hd = t$0[1];
      if(caml_call1(f, hd)){var t$0 = tl; continue;}
     }
     return t$0;
    }
   }
   function drop_last(t){
    var match = caml_call1(rev, t);
    if(! match) return 0;
    var lst = match[2];
    return [0, caml_call1(rev, lst)];
   }
   function drop_last_exn(t){
    var match = drop_last(t);
    if(! match)
     return caml_call1(Base_Import[124], cst_List_drop_last_exn_empty_l);
    var lst = match[1];
    return lst;
   }
   function cartesian_product(list1, list2){
    if(caml_call1(is_empty, list2)) return 0;
    var l1 = list1;
    for(;;){
     if(! l1) return 0;
     var l1$0 = l1[2], x1 = l1[1];
     if(list2) break;
     var l1 = l1$0;
    }
    var
     l2 = list2[2],
     x2 = list2[1],
     block = [0, [0, x1, x2], 24029],
     dst = block,
     offset = 1,
     x1$1 = x1,
     l1$2 = l1$0,
     l2$0 = l2;
    for(;;)
     if(l2$0){
      var l2$1 = l2$0[2], x2$0 = l2$0[1], dst$0 = [0, [0, x1$1, x2$0], 24029];
      dst[1 + offset] = dst$0;
      var dst = dst$0, offset = 1, l2$0 = l2$1;
     }
     else{
      if(! l1$2){dst[1 + offset] = 0; return block;}
      var
       l1$1 = l1$2[2],
       x1$0 = l1$2[1],
       x1$1 = x1$0,
       l1$2 = l1$1,
       l2$0 = list2;
     }
   }
   function concat(l){return caml_call3(fold_right, l, append, 0);}
   function concat_no_order(l){
    return caml_call3
            (fold,
             l,
             0,
             function(acc, l){return caml_call2(rev_append, l, acc);});
   }
   function cons(x, l){return [0, x, l];}
   function is_sorted(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _G_ = caml_call2(compare, x1, x2) <= 0 ? 1 : 0;
       if(! _G_) return _G_;
       var l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   function is_sorted_strictly(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _F_ = caml_call2(compare, x1, x2) < 0 ? 1 : 0;
       if(! _F_) return _F_;
       var l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   var Infix = [0, append];
   function permute(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    if(list){
     var _E_ = list[2];
     if(_E_){
      if(_E_[2]){
       var arr = caml_call1(Base_Array0[14], list);
       caml_call4(Base_Array_permute[25], [0, random_state], 0, 0, arr);
       return caml_call1(Base_Array0[16], arr);
      }
      var y = _E_[1], x = list[1];
      return caml_call1(Base_Random[19][17], random_state)
              ? [0, y, [0, x, 0]]
              : list;
     }
    }
    return list;
   }
   function random_element_exn(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    if(caml_call1(is_empty, list))
     return caml_call1(Base_Import[124], cst_List_random_element_exn_em);
    var _D_ = caml_call1(length, list);
    return nth_exn(list, caml_call2(Base_Random[19][7], random_state, _D_));
   }
   function random_element(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    try{
     var _B_ = [0, random_element_exn([0, random_state], list)];
     return _B_;
    }
    catch(_C_){return 0;}
   }
   function compare$0(cmp, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      n = caml_call2(cmp, x, y);
     if(0 !== n) return n;
     var a$0 = xs, b$0 = ys;
    }
   }
   function compare_local$0(cmp, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      n = caml_call2(cmp, x, y);
     if(0 !== n) return n;
     var a$0 = xs, b$0 = ys;
    }
   }
   var hash_fold_t = Base_Import[212];
   function equal_with_local_closure(equal, t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     if(t1$0){
      if(t2$0){
       var
        t2$1 = t2$0[2],
        x2 = t2$0[1],
        t1$1 = t1$0[2],
        x1 = t1$0[1],
        _A_ = caml_call2(equal, x1, x2);
       if(! _A_) return _A_;
       var t1$0 = t1$1, t2$0 = t2$1;
       continue;
      }
     }
     else if(! t2$0) return 1;
     return 0;
    }
   }
   function equal(f, x, y){return equal_with_local_closure(f, x, y);}
   function equal_local(equal_a_local, t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     if(t1$0){
      if(t2$0){
       var
        t2$1 = t2$0[2],
        x2 = t2$0[1],
        t1$1 = t1$0[2],
        x1 = t1$0[1],
        _z_ = caml_call2(equal_a_local, x1, x2);
       if(! _z_) return _z_;
       var t1$0 = t1$1, t2$0 = t2$1;
       continue;
      }
     }
     else if(! t2$0) return 1;
     return 0;
    }
   }
   function transpose(rows$0){
    var rows = rows$0, columns = 0, do_rev = 1;
    for(;;){
     var t = rows, column_acc = 0, trimmed_rows = 0, found_empty = 0;
     for(;;){
      if(! t) break;
      var match = t[1];
      if(match)
       var
        tl = t[2],
        xs = match[2],
        x = match[1],
        trimmed = [0, xs, trimmed_rows],
        column_acc$0 = [0, x, column_acc],
        t = tl,
        column_acc = column_acc$0,
        trimmed_rows = trimmed;
      else
       var tl$0 = t[2], t = tl$0, found_empty = 1;
     }
     if(! column_acc && ! trimmed_rows) return [0, caml_call1(rev, columns)];
     if(found_empty) return 0;
     var
      column = do_rev ? caml_call1(rev, column_acc) : column_acc,
      do_rev$0 = 1 - do_rev,
      columns$0 = [0, column, columns],
      rows = trimmed_rows,
      columns = columns$0,
      do_rev = do_rev$0;
    }
   }
   var
    Transpose_got_lists_of_differe =
      [248, cst_Base_List_Transpose_got_li, runtime.caml_fresh_oo_id(0)];
   function _u_(param){
    if(param[1] !== Transpose_got_lists_of_differe)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
    var
     arg0_045 = param[2],
     res0_046 = caml_call2(Base_Import[149], Base_Import[139], arg0_045);
    return [1, [0, _v_, [0, res0_046, 0]]];
   }
   caml_call4
    (Sexplib0_Sexp_conv[72][1], 0, 0, Transpose_got_lists_of_differe, _u_);
   function transpose_exn(l){
    var match = transpose(l);
    if(! match)
     throw caml_maybe_attach_backtrace
            ([0, Transpose_got_lists_of_differe, map(l, length)], 1);
    var l$0 = match[1];
    return l$0;
   }
   function intersperse(t, sep){
    if(! t) return 0;
    var xs = t[2], x = t[1], _y_ = 0;
    return [0,
            x,
            caml_call3
             (fold_right,
              xs,
              function(y, acc){return [0, sep, [0, y, acc]];},
              _y_)];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return caml_call5(Base_Container[9], fold, init, f, finish, t);
   }
   function is_suffix(list, suffix, equal_elt){
    var
     list_len = caml_call1(length, list),
     suffix_len = caml_call1(length, suffix),
     _x_ = suffix_len <= list_len ? 1 : 0;
    return _x_
            ? equal_with_local_closure
              (equal_elt,
               drop(list, caml_call2(Base_Import[93], list_len, suffix_len)),
               suffix)
            : _x_;
   }
   var
    Base_List =
      [0,
       compare$0,
       compare_local$0,
       globalize,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       of_list,
       of_array,
       append,
       concat,
       filter,
       filter_map,
       concat_map,
       partition_tf,
       partition_map,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init,
       mapi,
       filteri,
       filter_mapi,
       concat_mapi,
       length,
       invariant,
       [0,
        both,
        symbol,
        symbol$1,
        symbol$0,
        apply,
        map2$0,
        map3$0,
        [0, symbol$2, symbol$4, symbol$3, symbol_map],
        symbol_bind,
        symbol_map,
        [0, symbol_bind, symbol_map],
        concat_map,
        singleton,
        map,
        join,
        ignore_m,
        all,
        all_unit,
        [0, singleton, symbol_bind, symbol_map, Let_syntax]],
       symbol_bind,
       symbol_map,
       Monad_infix,
       concat_map,
       singleton,
       map,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax$0,
       [0, compare, compare_local, sexp_of_t$0],
       singleton,
       nth,
       nth_exn,
       rev,
       rev_append,
       unordered_append,
       rev_map,
       iter2_exn,
       iter2,
       rev_map2_exn,
       rev_map2,
       fold2_exn,
       fold2,
       fold_right2_exn,
       fold_right2,
       for_all2_exn,
       for_all2,
       exists2_exn,
       exists2,
       rev_filter,
       partition3_map,
       partition_result,
       split_n,
       stable_sort,
       stable_sort,
       merge,
       hd,
       tl,
       hd_exn,
       tl_exn,
       findi_exn,
       find_exn,
       find_map_exn,
       find_mapi_exn,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       map2_exn,
       map2,
       rev_map3_exn,
       rev_map3,
       map3_exn,
       map3,
       rev_map_append,
       fold_right,
       fold,
       unzip,
       unzip3,
       zip,
       zip_exn,
       rev_mapi,
       reduce_exn,
       reduce,
       reduce_balanced,
       reduce_balanced_exn,
       group,
       groupi,
       sort_and_group,
       chunks_of,
       last,
       last_exn,
       is_prefix,
       is_suffix,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       dedup_and_sort,
       stable_dedup,
       find_a_dup,
       contains_dup,
       find_all_dups,
       all_equal,
       range$0,
       range,
       rev_filter_map,
       rev_filter_mapi,
       filter_opt,
       [0,
        t_of_sexp$0,
        sexp_of_t$1,
        t_sexp_grammar$0,
        add,
        find$0,
        find_exn$0,
        mem$0,
        remove,
        map$2,
        inverse,
        group$0,
        sort_and_group$0],
       sub,
       take,
       drop,
       take_while,
       drop_while,
       split_while,
       drop_last,
       drop_last_exn,
       concat_no_order,
       cons,
       cartesian_product,
       permute,
       random_element,
       random_element_exn,
       is_sorted,
       is_sorted_strictly,
       equal,
       equal_local,
       Infix,
       transpose,
       transpose_exn,
       intersperse];
   runtime.caml_register_global(62, Base_List, "Base__List");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info
//# unitInfo: Requires: Base__Exn, Base__Hash, Base__Import, Base__Info_intf, Base__List, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Source_code_position0, Base__String0, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    _j_ = [0, [0, "cycle while computing message"]],
    t_sexp_grammar = [0, "Info.t"],
    module_name = "Base.Info",
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Base_List = global_data.Base__List,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_String0 = global_data.Base__String0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    _l_ = [0, "src/info.ml", 261, 6],
    _a_ = [0, "Could_not_construct"],
    _b_ = [0, "String"],
    _c_ = [0, "Exn"],
    _d_ = [0, "Sexp"],
    _e_ = [0, "Tag_sexp"],
    _f_ = [0, "Tag_t"],
    _g_ = [0, "Tag_arg"],
    _h_ = [0, "Of_list"],
    _i_ = [0, "With_backtrace"],
    cst_Base_Info_Exn = "Base__Info.Exn";
   function sexp_of_t(param){
    switch(param[0]){
      case 0:
       var arg0_001 = param[1], res0_002 = caml_call1(Base_Sexp[5], arg0_001);
       return [1, [0, _a_, [0, res0_002, 0]]];
      case 1:
       var
        arg0_003 = param[1],
        res0_004 = caml_call1(Base_Import[136], arg0_003);
       return [1, [0, _b_, [0, res0_004, 0]]];
      case 2:
       var
        arg0_005 = param[1],
        res0_006 = caml_call1(Base_Import[198], arg0_005);
       return [1, [0, _c_, [0, res0_006, 0]]];
      case 3:
       var arg0_007 = param[1], res0_008 = caml_call1(Base_Sexp[5], arg0_007);
       return [1, [0, _d_, [0, res0_008, 0]]];
      case 4:
       var
        arg2_011 = param[3],
        arg1_010 = param[2],
        arg0_009 = param[1],
        res0_012 = caml_call1(Base_Import[136], arg0_009),
        res1_013 = caml_call1(Base_Sexp[5], arg1_010),
        res2_014 =
          caml_call2
           (Base_Import[146], Base_Source_code_position0[9], arg2_011);
       return [1, [0, _e_, [0, res0_012, [0, res1_013, [0, res2_014, 0]]]]];
      case 5:
       var
        arg1_016 = param[2],
        arg0_015 = param[1],
        res0_017 = caml_call1(Base_Import[136], arg0_015),
        res1_018 = sexp_of_t(arg1_016);
       return [1, [0, _f_, [0, res0_017, [0, res1_018, 0]]]];
      case 6:
       var
        arg2_021 = param[3],
        arg1_020 = param[2],
        arg0_019 = param[1],
        res0_022 = caml_call1(Base_Import[136], arg0_019),
        res1_023 = caml_call1(Base_Sexp[5], arg1_020),
        res2_024 = sexp_of_t(arg2_021);
       return [1, [0, _g_, [0, res0_022, [0, res1_023, [0, res2_024, 0]]]]];
      case 7:
       var
        arg1_026 = param[2],
        arg0_025 = param[1],
        res0_027 = caml_call2(Base_Import[146], Base_Import[139], arg0_025),
        res1_028 = caml_call2(Base_Import[149], sexp_of_t, arg1_026);
       return [1, [0, _h_, [0, res0_027, [0, res1_028, 0]]]];
      default:
       var
        arg1_030 = param[2],
        arg0_029 = param[1],
        res0_031 = sexp_of_t(arg0_029),
        res1_032 = caml_call1(Base_Import[136], arg1_030);
       return [1, [0, _i_, [0, res0_031, [0, res1_032, 0]]]];
    }
   }
   function to_sexps_hum(t, ac){
    switch(t[0]){
      case 0:
       return [0, sexp_of_t(t), ac];
      case 1:
       var string = t[1]; return [0, [0, string], ac];
      case 2:
       var exn = t[1]; return [0, caml_call1(Base_Exn[1], exn), ac];
      case 3:
       var sexp = t[1]; return [0, sexp, ac];
      case 4:
       var here = t[3], sexp$0 = t[2], tag = t[1];
       if(here)
        var
         here$0 = here[1],
         _T_ = [0, caml_call1(Base_Source_code_position0[9], here$0), 0];
       else
        var _T_ = 0;
       return [0, [1, [0, [0, tag], [0, sexp$0, _T_]]], ac];
      case 5:
       var t$0 = t[2], tag$0 = t[1];
       return [0, [1, [0, [0, tag$0], to_sexps_hum(t$0, 0)]], ac];
      case 6:
       var
        t$1 = t[3],
        sexp$1 = t[2],
        tag$1 = t[1],
        body = [0, sexp$1, to_sexps_hum(t$1, 0)];
       return 0 === runtime.caml_ml_string_length(tag$1)
               ? [0, [1, body], ac]
               : [0, [1, [0, [0, tag$1], body]], ac];
      case 7:
       var
        ts = t[2],
        _U_ = function(ac, t){return to_sexps_hum(t, ac);},
        _V_ = caml_call1(Base_List[63], ts);
       return caml_call3(Base_List[20], _V_, ac, _U_);
      default:
       var
        backtrace = t[2],
        t$2 = t[1],
        _W_ = caml_call1(Base_String0[22], backtrace),
        _X_ = [0, caml_call2(Base_Import[149], Base_Import[136], _W_), 0];
       return [0, [1, [0, to_sexp_hum(t$2), _X_]], ac];
    }
   }
   function to_sexp_hum(t){
    var sexps = to_sexps_hum(t, 0);
    if(sexps && ! sexps[2]){var sexp = sexps[1]; return sexp;}
    return [1, sexps];
   }
   function globalize_info(param){return param;}
   function compute_info$0(counter, info, stack){
    var info$0 = info, stack$0 = stack;
    for(;;){
     var match = info$0[1];
     if(typeof match === "number"){
      if(counter >= 50)
       return caml_trampoline_return(compute_message, [0, _j_, stack$0]);
      var counter$1 = counter + 1 | 0;
      return compute_message(counter$1, _j_, stack$0);
     }
     if(0 !== match[0]){
      var message = match[1];
      if(counter >= 50)
       return caml_trampoline_return(compute_message, [0, message, stack$0]);
      var counter$2 = counter + 1 | 0;
      return compute_message(counter$2, message, stack$0);
     }
     var cons = match[1];
     info$0[1] = 0;
     var stack$1 = [0, [0, info$0], stack$0];
     switch(cons[0]){
       case 0:
        var lazy_info = cons[1];
        try{
         var _R_ = caml_obj_tag(lazy_info);
         a:
         if(250 === _R_)
          var info$1 = lazy_info[1];
         else{
          if(246 !== _R_ && 244 !== _R_){var info$1 = lazy_info; break a;}
          var info$1 = caml_call1(CamlinternalLazy[2], lazy_info);
         }
        }
        catch(exn$0){
         var
          exn = caml_wrap_exception(exn$0),
          _Q_ = [0, caml_call1(Base_Exn[1], exn)];
         if(counter >= 50)
          return caml_trampoline_return(compute_message, [0, _Q_, stack$1]);
         var counter$3 = counter + 1 | 0;
         return compute_message(counter$3, _Q_, stack$1);
        }
        var info$0 = info$1, stack$0 = stack$1;
        break;
       case 1:
        var infos = cons[1], _S_ = 0;
        if(counter >= 50)
         return caml_trampoline_return
                 (compute_info_list, [0, infos, _S_, stack$1]);
        var counter$0 = counter + 1 | 0;
        return compute_info_list(counter$0, infos, _S_, stack$1);
       case 2:
        var
         info$2 = cons[3],
         arg = cons[2],
         tag = cons[1],
         stack$2 = [0, [1, tag, arg], stack$1],
         info$0 = info$2,
         stack$0 = stack$2;
        break;
       default:
        var
         info$3 = cons[2],
         tag$0 = cons[1],
         stack$3 = [0, [2, tag$0], stack$1],
         info$0 = info$3,
         stack$0 = stack$3;
     }
    }
   }
   function compute_info_list(counter, fwd_prefix, rev_suffix, stack){
    if(fwd_prefix){
     var
      fwd_prefix$0 = fwd_prefix[2],
      info = fwd_prefix[1],
      _N_ = [0, [3, fwd_prefix$0, rev_suffix], stack];
     if(counter >= 50)
      return caml_trampoline_return(compute_info$0, [0, info, _N_]);
     var counter$0 = counter + 1 | 0;
     return compute_info$0(counter$0, info, _N_);
    }
    function _O_(tail, message){
     if(7 !== message[0]) return [0, message, tail];
     var messages = message[2];
     return caml_call2(Base_Import[111], messages, tail);
    }
    var
     infos = caml_call3(Base_List[20], rev_suffix, 0, _O_),
     _P_ = [7, 0, infos];
    if(counter >= 50)
     return caml_trampoline_return(compute_message, [0, _P_, stack]);
    var counter$1 = counter + 1 | 0;
    return compute_message(counter$1, _P_, stack);
   }
   function compute_message(counter, message, stack){
    var message$0 = message, stack$0 = stack;
    for(;;){
     if(! stack$0) return message$0;
     var match = stack$0[1];
     switch(match[0]){
       case 0:
        var stack$1 = stack$0[2], info = match[1];
        info[1] = [1, message$0];
        var stack$0 = stack$1;
        break;
       case 1:
        var
         stack$2 = stack$0[2],
         arg = match[2],
         tag = match[1],
         message$1 = [6, tag, arg, message$0],
         message$0 = message$1,
         stack$0 = stack$2;
        break;
       case 2:
        var
         stack$3 = stack$0[2],
         tag$0 = match[1],
         message$2 = [5, tag$0, message$0],
         message$0 = message$2,
         stack$0 = stack$3;
        break;
       default:
        var
         stack$4 = stack$0[2],
         rev_suffix = match[2],
         fwd_prefix = match[1],
         _M_ = [0, message$0, rev_suffix];
        if(counter >= 50)
         return caml_trampoline_return
                 (compute_info_list, [0, fwd_prefix, _M_, stack$4]);
        var counter$0 = counter + 1 | 0;
        return compute_info_list(counter$0, fwd_prefix, _M_, stack$4);
     }
    }
   }
   function compute_info(info, stack){
    return caml_trampoline(compute_info$0(0, info, stack));
   }
   function to_message(info){return compute_info(info, 0);}
   function of_message(message){return [0, [1, message]];}
   function of_cons(cons){return [0, [0, cons]];}
   function of_lazy_cons(lazy_cons){
    return of_cons
            ([0,
              [246,
               function(_J_){
                var _K_ = caml_obj_tag(lazy_cons);
                a:
                if(250 === _K_)
                 var _L_ = lazy_cons[1];
                else{
                 if(246 !== _K_ && 244 !== _K_){var _L_ = lazy_cons; break a;}
                 var _L_ = caml_call1(CamlinternalLazy[2], lazy_cons);
                }
                return of_cons(_L_);
               }]]);
   }
   function of_lazy_message(lazy_message){
    return of_cons
            ([0,
              [246,
               function(_G_){
                var _H_ = caml_obj_tag(lazy_message);
                a:
                if(250 === _H_)
                 var _I_ = lazy_message[1];
                else{
                 if(246 !== _H_ && 244 !== _H_){
                  var _I_ = lazy_message;
                  break a;
                 }
                 var _I_ = caml_call1(CamlinternalLazy[2], lazy_message);
                }
                return of_message(_I_);
               }]]);
   }
   function invariant(param){return 0;}
   function sexp_of_t$0(t){return to_sexp_hum(to_message(t));}
   function t_of_sexp(sexp){return of_message([3, sexp]);}
   function compare(t1, t2){
    var _E_ = sexp_of_t$0(t2), _F_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[7], _F_, _E_);
   }
   function compare_local(t1, t2){return compare(t1, t2);}
   function equal(t1, t2){
    var _C_ = sexp_of_t$0(t2), _D_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[6], _D_, _C_);
   }
   function equal_local(t1, t2){return equal(t1, t2);}
   function hash_fold_t(state, t){
    var _B_ = sexp_of_t$0(t);
    return caml_call2(Base_Sexp[2], state, _B_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string_hum(t){
    var message = to_message(t);
    if(1 === message[0]){var s = message[1]; return s;}
    var _A_ = to_sexp_hum(message);
    return caml_call2(Base_Sexp[16], 0, _A_);
   }
   function to_string_mach(t){
    var _z_ = sexp_of_t$0(t);
    return caml_call1(Base_Sexp[17], _z_);
   }
   function of_lazy(l){
    return of_lazy_message
            ([246,
              function(_w_){
               var _x_ = caml_obj_tag(l);
               a:
               if(250 === _x_)
                var _y_ = l[1];
               else{
                if(246 !== _x_ && 244 !== _x_){var _y_ = l; break a;}
                var _y_ = caml_call1(CamlinternalLazy[2], l);
               }
               return [1, _y_];
              }]);
   }
   function of_lazy_sexp(l){
    return of_lazy_message
            ([246,
              function(_t_){
               var _u_ = caml_obj_tag(l);
               a:
               if(250 === _u_)
                var _v_ = l[1];
               else{
                if(246 !== _u_ && 244 !== _u_){var _v_ = l; break a;}
                var _v_ = caml_call1(CamlinternalLazy[2], l);
               }
               return [3, _v_];
              }]);
   }
   function of_lazy_t(lazy_info){return of_cons([0, lazy_info]);}
   function of_string(message){return of_message([1, message]);}
   function createf(format){
    return caml_call2(Base_Printf[4], of_string, format);
   }
   function of_thunk(f){
    return of_lazy_message
            ([246, function(param){return [1, caml_call1(f, 0)];}]);
   }
   function create(here, strict, tag, x, sexp_of_x){
    return strict
            ? of_message([4, tag, caml_call1(sexp_of_x, x), here])
            : of_lazy_message
              ([246,
                function(param){
                 return [4, tag, caml_call1(sexp_of_x, x), here];
                }]);
   }
   function create_s(sexp){return of_message([3, sexp]);}
   function tag(t, tag){return of_cons([3, tag, t]);}
   function tag_s_lazy(t, tag){
    return of_lazy_cons
            ([246,
              function(_q_){
               var _r_ = caml_obj_tag(tag);
               a:
               if(250 === _r_)
                var _s_ = tag[1];
               else{
                if(246 !== _r_ && 244 !== _r_){var _s_ = tag; break a;}
                var _s_ = caml_call1(CamlinternalLazy[2], tag);
               }
               return [2, cst, _s_, t];
              }]);
   }
   function tag_s(t, tag){return of_cons([2, cst$0, tag, t]);}
   function tag_arg(t, tag, x, sexp_of_x){
    return of_lazy_cons
            ([246,
              function(param){return [2, tag, caml_call1(sexp_of_x, x), t];}]);
   }
   function of_list(ts){return of_cons([1, ts]);}
   var Exn = [248, cst_Base_Info_Exn, runtime.caml_fresh_oo_id(0)];
   function _k_(param){
    if(param[1] !== Exn)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    var t = param[2];
    return sexp_of_t$0(t);
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, Exn, _k_);
   function to_exn(info){
    var _o_ = info[1];
    a:
    {
     if(typeof _o_ !== "number" && 1 === _o_[0]){var _p_ = 1; break a;}
     var _p_ = 0;
    }
    if(! _p_) return [0, Exn, info];
    var match = to_message(info);
    if(2 !== match[0]) return [0, Exn, info];
    var exn = match[1];
    return exn;
   }
   function of_exn(backtrace, exn){
    if(backtrace){
     var match = backtrace[1];
     if(typeof match === "number")
      var _n_ = [0, caml_call1(Stdlib_Printexc[6], 0)];
     else
      var s = match[2], _n_ = [0, s];
     var backtrace$0 = _n_;
    }
    else
     var backtrace$0 = 0;
    if(exn[1] === Exn){
     var t = exn[2];
     if(! backtrace$0) return t;
     var backtrace$1 = backtrace$0[1];
     return of_lazy_message
             ([246, function(param){return [8, to_message(t), backtrace$1];}]);
    }
    if(! backtrace$0) return of_message([2, exn]);
    var backtrace$2 = backtrace$0[1];
    return of_lazy_message
            ([246,
              function(param){
               return [8, [3, caml_call1(Base_Exn[1], exn)], backtrace$2];
              }]);
   }
   function pp(ppf, t){
    var _m_ = to_string_hum(t);
    return caml_call2(Stdlib_Format[13], ppf, _m_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Info =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize_info,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       [0, sexp_of_t, to_message, of_message]];
   runtime.caml_register_global(30, Base_Info, "Base__Info");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Error
//# unitInfo: Requires: Base__Info, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [0, "Error.t"],
    module_name = "Base.Error",
    Base_Info = global_data.Base__Info,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    compare = Base_Info[1],
    compare_local = Base_Info[2],
    equal = Base_Info[3],
    equal_local = Base_Info[4],
    globalize = Base_Info[5],
    hash_fold_t = Base_Info[6],
    hash = Base_Info[7],
    t_of_sexp = Base_Info[8],
    sexp_of_t = Base_Info[9],
    invariant = Base_Info[11],
    to_string_hum = Base_Info[12],
    to_string_mach = Base_Info[13],
    of_string = Base_Info[14],
    of_lazy = Base_Info[15],
    of_lazy_sexp = Base_Info[16],
    of_thunk = Base_Info[17],
    of_lazy_t = Base_Info[18],
    create = Base_Info[19],
    create_s = Base_Info[20],
    createf = Base_Info[21],
    tag = Base_Info[22],
    tag_s = Base_Info[23],
    tag_s_lazy = Base_Info[24],
    tag_arg = Base_Info[25],
    of_list = Base_Info[26],
    of_exn = Base_Info[27],
    to_exn = Base_Info[28],
    pp = Base_Info[29],
    Internal_repr = Base_Info[30];
   function raise(t){
    throw caml_maybe_attach_backtrace(caml_call1(to_exn, t), 1);
   }
   function raise_s(sexp){return raise(caml_call1(create_s, sexp));}
   function to_info(t){return t;}
   function of_info(t){return t;}
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Error =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       Internal_repr,
       raise,
       raise_s,
       to_info,
       of_info];
   runtime.caml_register_global(4, Base_Error, "Base__Error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant
//# unitInfo: Requires: Base__Error, Base__Field, Base__Import, Base__Invariant_intf, Base__Sexp, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_exn$1 = "exn",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Field = global_data.Base__Field,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[32],
    cst_exn$0 = cst_exn$1,
    cst_field = "field",
    cst_problem_with_field = "problem with field",
    cst_exn = cst_exn$1,
    cst_invariant_failed = "invariant failed";
   function invariant(here, t, sexp_of_t, f){
    try{var _h_ = caml_call1(f, 0); return _h_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _e_ = [0, [0, cst, caml_call1(sexp_of_t, t)], 0],
      _f_ = [0, [0, cst_exn, caml_call1(Base_Import[198], exn)], _e_],
      _g_ =
        [0, [0, cst$0, caml_call1(Base_Source_code_position0[9], here)], _f_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[10], cst_invariant_failed, _g_));
    }
   }
   function check_field(t, f, field){
    try{
     var _d_ = caml_call1(f, caml_call2(Base_Field[3], field, t));
     return _d_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _a_ = [0, [0, cst_exn$0, caml_call1(Base_Import[198], exn)], 0],
      _b_ = caml_call1(Base_Field[2], field),
      _c_ = [0, [0, cst_field, caml_call1(Base_Import[136], _b_)], _a_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[10], cst_problem_with_field, _c_));
    }
   }
   var Base_Invariant = [0, invariant, check_field];
   runtime.caml_register_global(12, Base_Invariant, "Base__Invariant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Or_error
//# unitInfo: Requires: Base__Applicative, Base__Error, Base__Import, Base__List, Base__Printf, Base__Result, Base__With_return
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Base_Error = global_data.Base__Error,
    Base_With_return = global_data.Base__With_return,
    Assert_failure = global_data.Assert_failure,
    Base_Result = global_data.Base__Result,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Applicative = global_data.Base__Applicative,
    _b_ = [0, "src/or_error.ml", 192, 21],
    cst_unimplemented = "unimplemented",
    _a_ = [0, 3553398];
   function compare_local(cmp_a, a_007, b_008){
    return caml_call4(Base_Result[5], cmp_a, Base_Error[2], a_007, b_008);
   }
   function compare(cmp_a, a_001, b_002){
    return caml_call4(Base_Result[4], cmp_a, Base_Error[1], a_001, b_002);
   }
   function equal_local(cmp_a, a_019, b_020){
    return caml_call4(Base_Result[7], cmp_a, Base_Error[4], a_019, b_020);
   }
   function equal(cmp_a, a_013, b_014){
    return caml_call4(Base_Result[6], cmp_a, Base_Error[3], a_013, b_014);
   }
   function globalize(globalize_a_026, x_027){
    return caml_call3(Base_Result[9], globalize_a_026, Base_Error[5], x_027);
   }
   function hash_fold_t(hash_fold_a, hsv, arg){
    return caml_call4(Base_Result[8], hash_fold_a, Base_Error[6], hsv, arg);
   }
   function t_of_sexp(of_a_030, x_032){
    return caml_call3(Base_Result[1], of_a_030, Base_Error[8], x_032);
   }
   function sexp_of_t(of_a_033, x_034){
    return caml_call3(Base_Result[2], of_a_033, Base_Error[9], x_034);
   }
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call2(Base_Result[3], a_sexp_grammar, Base_Error[10]);
   }
   var
    symbol_bind = Base_Result[10],
    symbol_map = Base_Result[11],
    bind = Base_Result[14],
    ignore_m = Base_Result[17],
    join = Base_Result[16],
    map = Base_Result[33],
    return$0 = Base_Result[15];
   function invariant(invariant_a, t){
    if(0 === t[0]){var a = t[1]; return caml_call1(invariant_a, a);}
    var error = t[1];
    return caml_call1(Base_Error[11], error);
   }
   function map2(a, b, f){
    if(0 === a[0]){
     var x = a[1];
     if(0 === b[0]){var y = b[1]; return [0, caml_call2(f, x, y)];}
     var e = b;
    }
    else{
     var e1 = a[1];
     if(0 !== b[0]){
      var e2 = b[1];
      return [1, caml_call1(Base_Error[26], [0, e1, [0, e2, 0]])];
     }
     var e = a;
    }
    return e;
   }
   var
    map$0 = [0, -198771759, map],
    For_applicative =
      caml_call1(Base_Applicative[16], [0, return$0, map2, map$0]),
    symbol = For_applicative[6],
    symbol$0 = For_applicative[5],
    symbol$1 = For_applicative[4],
    apply = For_applicative[8],
    both = For_applicative[3],
    map3 = For_applicative[10],
    include = Base_Result[13],
    symbol_bind$0 = include[1],
    symbol_map$0 = include[2],
    Open_on_rhs = [0],
    ok = Base_Result[26],
    is_ok = Base_Result[24],
    is_error = Base_Result[25];
   function try_with(opt, f){
    if(opt) var sth = opt[1], backtrace = sth; else var backtrace = 0;
    try{var _v_ = [0, caml_call1(f, 0)]; return _v_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), _u_ = backtrace ? _a_ : 0;
     return [1, caml_call2(Base_Error[27], _u_, exn)];
    }
   }
   function try_with_join(backtrace, f){
    return caml_call1(join, try_with(backtrace, f));
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var err = param[1];
    return caml_call1(Base_Error[31], err);
   }
   function of_exn(backtrace, exn){
    return [1, caml_call2(Base_Error[27], backtrace, exn)];
   }
   function of_exn_result(backtrace, z){
    if(0 === z[0]) return z;
    var exn = z[1];
    return of_exn(backtrace, exn);
   }
   var of_option = Base_Result[30];
   function error(here, strict, message, a, sexp_of_a){
    return [1,
            caml_call5(Base_Error[19], here, strict, message, a, sexp_of_a)];
   }
   function error_s(sexp){return [1, caml_call1(Base_Error[20], sexp)];}
   function error_string(message){
    return [1, caml_call1(Base_Error[14], message)];
   }
   function errorf(format){
    return caml_call2(Base_Printf[4], error_string, format);
   }
   function tag(t, tag){
    var _r_ = Base_Error[22];
    function _s_(_t_){return caml_call2(_r_, _t_, tag);}
    return caml_call2(Base_Result[34], t, _s_);
   }
   function tag_s(t, tag){
    var _o_ = Base_Error[23];
    function _p_(_q_){return caml_call2(_o_, _q_, tag);}
    return caml_call2(Base_Result[34], t, _p_);
   }
   function tag_s_lazy(t, tag){
    var _l_ = Base_Error[24];
    function _m_(_n_){return caml_call2(_l_, _n_, tag);}
    return caml_call2(Base_Result[34], t, _m_);
   }
   function tag_arg(t, message, a, sexp_of_a){
    function _k_(e){
     return caml_call4(Base_Error[25], e, message, a, sexp_of_a);
    }
    return caml_call2(Base_Result[34], t, _k_);
   }
   function unimplemented(s){
    return error(0, 0, cst_unimplemented, s, Base_Import[136]);
   }
   function combine_internal(list, on_ok, on_error){
    var match = caml_call1(Base_Result[36], list);
    if(0 === match[0]){var x = match[1]; return [0, caml_call1(on_ok, x)];}
    var errs = match[1];
    return [1, caml_call1(on_error, errs)];
   }
   function ignore_unit_list(param){return 0;}
   function error_of_list_if_necessary(list){
    if(list && ! list[2]){var e = list[1]; return e;}
    return caml_call1(Base_Error[26], list);
   }
   function all(list){
    return combine_internal
            (list, function(_j_){return _j_;}, error_of_list_if_necessary);
   }
   function all_unit(list){
    return combine_internal
            (list, ignore_unit_list, error_of_list_if_necessary);
   }
   function combine_errors(list){
    var _h_ = Base_Error[26];
    return combine_internal(list, function(_i_){return _i_;}, _h_);
   }
   function combine_errors_unit(list){
    return combine_internal(list, ignore_unit_list, Base_Error[26]);
   }
   function filter_ok_at_least_one(l){
    var
     match = caml_call2(Base_List[16], l, Base_Result[38]),
     errs = match[2],
     ok = match[1];
    return ok ? [0, ok] : [1, caml_call1(Base_Error[26], errs)];
   }
   function find_ok(l){
    var match = caml_call2(Base_List[28], l, Base_Result[26]);
    if(match){var x = match[1]; return [0, x];}
    function _f_(param){
     if(0 === param[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     var err = param[1];
     return err;
    }
    var _g_ = caml_call2(Base_List[53], l, _f_);
    return [1, caml_call1(Base_Error[26], _g_)];
   }
   function find_map_ok(l, f){
    function _c_(param){
     function _d_(elt){
      var x = caml_call1(f, elt);
      if(0 === x[0]) return caml_call1(param, x);
      var err = x[1];
      return err;
     }
     var _e_ = caml_call2(Base_List[53], l, _d_);
     return [1, caml_call1(Base_Error[26], _e_)];
    }
    return caml_call1(Base_With_return[1], _c_);
   }
   var
    map$1 = Base_Result[33],
    iter = Base_Result[31],
    iter_error = Base_Result[32],
    Base_Or_error =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       both,
       symbol$1,
       symbol$0,
       symbol,
       apply,
       map2,
       map3,
       For_applicative[13],
       invariant,
       symbol_bind,
       symbol_map,
       Base_Result[13],
       bind,
       return$0,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$0,
        symbol_bind$0,
        symbol_map$0,
        [0, return$0, bind, map, both, Open_on_rhs]],
       is_ok,
       is_error,
       try_with,
       try_with_join,
       ok,
       ok_exn,
       of_exn,
       of_exn_result,
       of_option,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       map$1,
       iter,
       iter_error,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       find_ok,
       find_map_ok];
   runtime.caml_register_global(11, Base_Or_error, "Base__Or_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign0
//# unitInfo: Requires: Base__Hash, Base__Import, Base__Poly0, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero = "zero",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign0.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0, [1, [0, cst_Zero, 0]], [0, [1, [0, cst_Pos, 0]], 0]]]]],
    all = [0, 0, [0, 1, [0, 2, 0]]],
    module_name = "Base.Sign",
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _f_ = sexp_004[1];
      b:
      if(caml_string_notequal(_f_, cst_Neg)){
       c:
       if(caml_string_notequal(_f_, cst_Pos)){
        if(caml_string_notequal(_f_, cst_Zero)){
         if(! caml_string_notequal(_f_, cst_neg)) break b;
         if(! caml_string_notequal(_f_, cst_pos)) break c;
         if(caml_string_notequal(_f_, cst_zero)) break a;
        }
        return 1;
       }
       return 2;
      }
      return 0;
     }
     var _g_ = sexp_004[1];
     if(! _g_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_003, sexp_004);
     var _h_ = _g_[1];
     if(0 !== _h_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_003, sexp_004);
     var _i_ = _h_[1];
     b:
     if(caml_string_notequal(_i_, cst_Neg)){
      c:
      if(caml_string_notequal(_i_, cst_Pos)){
       if(caml_string_notequal(_i_, cst_Zero)){
        if(! caml_string_notequal(_i_, cst_neg)) break b;
        if(! caml_string_notequal(_i_, cst_pos)) break c;
        if(caml_string_notequal(_i_, cst_zero)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var compare_local = caml_int_compare, compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       var _e_ = 0; break;
      case 1:
       var _e_ = 1; break;
      default: var _e_ = 2;
    }
    return caml_call2(Base_Hash[3], hsv, _e_);
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function equal_local(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    Replace_polymorphic_compare =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       ascending,
       descending,
       compare$0,
       equal,
       equal_local,
       max,
       min];
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[136], s));}
   function to_string(t){
    var _d_ = sexp_of_t(t);
    return caml_call1(Base_Import[160], _d_);
   }
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   var
    Base_Sign0 =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare_local,
       compare,
       hash_fold_t,
       all,
       Replace_polymorphic_compare,
       of_string,
       to_string,
       to_int,
       to_int,
       module_name,
       of_int];
   runtime.caml_register_global(23, Base_Sign0, "Base__Sign0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparable_intf = [0];
   runtime.caml_register_global
    (0, Base_Comparable_intf, "Base__Comparable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable
//# unitInfo: Requires: Base__Comparable_intf, Base__Comparator, Base__Or_error, Base__Poly0, Base__Sexp, Base__Sign0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_clamp_requires_min_max$1 = "clamp requires [min <= max]",
    cst_max$1 = "max",
    cst_min$1 = "min",
    cst_src_comparable_ml = "src/comparable.ml",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparator = global_data.Base__Comparator,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Sign0 = global_data.Base__Sign0,
    cst_max$0 = cst_max$1,
    cst_min$0 = cst_min$1,
    cst_clamp_requires_min_max$0 = cst_clamp_requires_min_max$1,
    _b_ = [0, cst_src_comparable_ml, 135, 4],
    cst_max = cst_max$1,
    cst_min = cst_min$1,
    cst_clamp_requires_min_max = cst_clamp_requires_min_max$1,
    _a_ = [0, cst_src_comparable_ml, 47, 4];
   function geq(cmp, a, b){return 0 <= caml_call2(cmp, a, b) ? 1 : 0;}
   function leq(cmp, a, b){return caml_call2(cmp, a, b) <= 0 ? 1 : 0;}
   function equal(cmp, a, b){return 0 === caml_call2(cmp, a, b) ? 1 : 0;}
   function min(cmp, t$0, t){return leq(cmp, t$0, t) ? t$0 : t;}
   function max(cmp, t$0, t){return geq(cmp, t$0, t) ? t$0 : t;}
   function Infix(T){
    function symbol(a, b){
     var cmp = T[1];
     return 0 < caml_call2(cmp, a, b) ? 1 : 0;
    }
    function symbol$0(a, b){
     var cmp = T[1];
     return caml_call2(cmp, a, b) < 0 ? 1 : 0;
    }
    function symbol$1(a, b){return geq(T[1], a, b);}
    function symbol$2(a, b){return leq(T[1], a, b);}
    function symbol$3(a, b){return equal(T[1], a, b);}
    function symbol$4(a, b){
     var cmp = T[1];
     return 0 !== caml_call2(cmp, a, b) ? 1 : 0;
    }
    return [0, symbol$1, symbol$2, symbol$3, symbol, symbol$0, symbol$4];
   }
   function Comparisons(T){
    var
     include = Infix(T),
     symbol = include[1],
     symbol$0 = include[2],
     symbol$1 = include[3],
     symbol$2 = include[4],
     symbol$3 = include[5],
     symbol$4 = include[6],
     compare = T[1];
    function min$0(t$0, t){return min(compare, t$0, t);}
    function max$0(t$0, t){return max(compare, t$0, t);}
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            symbol$1,
            compare,
            min$0,
            max$0];
   }
   function Make_using_comparator(T){
    var
     sexp_of_t = T[1],
     comparator = T[2],
     compare = comparator[1],
     Replace_polymorphic_compare = Comparisons([0, compare]),
     symbol = Replace_polymorphic_compare[1],
     symbol$0 = Replace_polymorphic_compare[2],
     symbol$1 = Replace_polymorphic_compare[3],
     symbol$2 = Replace_polymorphic_compare[4],
     symbol$3 = Replace_polymorphic_compare[5],
     symbol$4 = Replace_polymorphic_compare[6],
     equal = Replace_polymorphic_compare[7],
     compare$0 = Replace_polymorphic_compare[8],
     min = Replace_polymorphic_compare[9],
     max = Replace_polymorphic_compare[10];
    function descending(t$0, t){return caml_call2(compare$0, t, t$0);}
    function between(t, low, high){
     var _s_ = caml_call2(symbol$0, low, t);
     return _s_ ? caml_call2(symbol$0, t, high) : _s_;
    }
    function clamp_unchecked(t, min, max){
     return caml_call2(symbol$3, t, min)
             ? min
             : caml_call2(symbol$0, t, max) ? t : max;
    }
    function clamp_exn(t, min, max){
     if(caml_call2(symbol$0, min, max)) return clamp_unchecked(t, min, max);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    }
    function clamp(t, min, max){
     if(! caml_call2(symbol$2, min, max))
      return [0, clamp_unchecked(t, min, max)];
     var
      _p_ = [0, [0, cst_max$0, caml_call1(sexp_of_t, max)], 0],
      _q_ = [0, [0, cst_min$0, caml_call1(sexp_of_t, min)], _p_],
      _r_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max$0, _q_);
     return caml_call1(Base_Or_error[39], _r_);
    }
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare$0,
            min,
            max,
            compare$0,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator];
   }
   function Make(T){
    var
     sexp_of_t = T[2],
     include = caml_call1(Base_Comparator[7], T),
     comparator = include[1];
    return Make_using_comparator([0, sexp_of_t, comparator]);
   }
   function Inherit(C, T){
    var sexp_of_t = T[1];
    function compare(t$0, t){
     var _n_ = caml_call1(T[2], t), _o_ = caml_call1(T[2], t$0);
     return caml_call2(C[1], _o_, _n_);
    }
    return Make([0, compare, sexp_of_t]);
   }
   function lexicographic(cmps, x, y){
    var param = cmps;
    for(;;){
     if(! param) return 0;
     var cmps$0 = param[2], cmp = param[1], res = caml_call2(cmp, x, y);
     if(0 !== res) return res;
     var param = cmps$0;
    }
   }
   function lift(cmp, f, x, y){
    var _m_ = caml_call1(f, y);
    return caml_call2(cmp, caml_call1(f, x), _m_);
   }
   function reverse(cmp, x, y){return caml_call2(cmp, y, x);}
   function compare_reversed(cmp, x, y){return caml_call2(cmp, y, x);}
   function _c_(_i_){
    var _j_ = _i_[3], _k_ = _i_[1];
    function is_positive(t){return 0 < caml_call2(_k_, t, _j_) ? 1 : 0;}
    function is_non_negative(t){return 0 <= caml_call2(_k_, t, _j_) ? 1 : 0;}
    function is_negative(t){return caml_call2(_k_, t, _j_) < 0 ? 1 : 0;}
    function is_non_positive(t){return caml_call2(_k_, t, _j_) <= 0 ? 1 : 0;}
    function sign(t){
     var _l_ = caml_call2(_k_, t, _j_);
     return caml_call1(Base_Sign0[14], _l_);
    }
    return [0,
            is_positive,
            is_non_negative,
            is_negative,
            is_non_positive,
            sign];
   }
   var
    Base_Comparable =
      [0,
       lexicographic,
       lift,
       reverse,
       compare_reversed,
       equal,
       max,
       min,
       Infix,
       Comparisons,
       Inherit,
       Make,
       Make_using_comparator,
       function(T){
        var
         sexp_of_t = T[1],
         ascending = Base_Poly0[1],
         descending = Base_Poly0[2],
         min = Base_Poly0[3],
         max = Base_Poly0[4];
        function between(t, low, high){
         var
          _g_ = caml_lessequal(low, t),
          _h_ = _g_ ? caml_lessequal(t, high) : _g_;
         return _h_;
        }
        function clamp_unchecked(t, min, max){
         return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
        }
        function clamp_exn(t, min, max){
         if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        }
        function clamp(t, min, max){
         if(! caml_greaterthan(min, max))
          return [0, clamp_unchecked(t, min, max)];
         var
          _d_ = [0, [0, cst_max, caml_call1(T[1], max)], 0],
          _e_ = [0, [0, cst_min, caml_call1(T[1], min)], _d_],
          _f_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _e_);
         return caml_call1(Base_Or_error[39], _f_);
        }
        var
         include =
           caml_call1(Base_Comparator[7], [0, caml_compare, sexp_of_t]),
         comparator = include[1];
        return [0,
                runtime.caml_greaterequal,
                caml_lessequal,
                caml_equal,
                caml_greaterthan,
                caml_lessthan,
                runtime.caml_notequal,
                caml_equal,
                caml_compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator];
       },
       _c_];
   runtime.caml_register_global(14, Base_Comparable, "Base__Comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable_intf
//# unitInfo: Requires: Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    _a_ = [0, "_"];
   function equal(a, b){
    var _b_ = a === b ? 1 : 0;
    if(_b_)
     var _c_ = _b_;
    else{
     var _d_ = a[1] === b[1] ? 1 : 0;
     if(_d_)
      var
       _e_ = a[2] === b[2] ? 1 : 0,
       _c_ = _e_ ? a[3] === b[3] ? 1 : 0 : _e_;
     else
      var _c_ = _d_;
    }
    return _c_;
   }
   var
    hash_param = Base_Import[85][105][30],
    hash = Base_Import[85][105][28],
    poly = [0, hash, runtime.caml_compare, function(param){return _a_;}];
   function of_key(Key){return [0, Key[3], Key[1], Key[2]];}
   function to_key(param){
    var sexp_of_t = param[3], compare = param[2], hash = param[1];
    return [0, compare, sexp_of_t, hash];
   }
   var
    Hashable = [0, equal, hash_param, hash, poly, of_key, to_key],
    equal$0 = Hashable[1],
    hash_param$0 = Hashable[2],
    hash$0 = Hashable[3],
    poly$0 = Hashable[4],
    of_key$0 = Hashable[5],
    to_key$0 = Hashable[6],
    Base_Hashable_intf =
      [0, Hashable, equal$0, hash_param$0, hash$0, poly$0, of_key$0, to_key$0];
   runtime.caml_register_global(2, Base_Hashable_intf, "Base__Hashable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable
//# unitInfo: Requires: Base__Hashable_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Hashable_intf = global_data.Base__Hashable_intf,
    equal = Base_Hashable_intf[2],
    hash_param = Base_Hashable_intf[3],
    hash = Base_Hashable_intf[4],
    poly = Base_Hashable_intf[5],
    of_key = Base_Hashable_intf[6],
    to_key = Base_Hashable_intf[7],
    Base_Hashable = [0, equal, poly, of_key, to_key, hash_param, hash];
   runtime.caml_register_global(1, Base_Hashable, "Base__Hashable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stringable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stringable = [0];
   runtime.caml_register_global(0, Base_Stringable, "Base__Stringable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Identifiable_intf = [0];
   runtime.caml_register_global
    (0, Base_Identifiable_intf, "Base__Identifiable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable
//# unitInfo: Requires: Base__Comparable, Base__Identifiable_intf, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer;
   function _a_(T){
    var
     hash_fold_t = T[2],
     hash = T[3],
     t_of_sexp = T[4],
     sexp_of_t = T[5],
     of_string = T[6],
     to_string = T[7],
     _c_ = caml_call1(Base_Comparable[12], [0, T[5], T[9]]),
     symbol = _c_[1],
     symbol$0 = _c_[2],
     symbol$1 = _c_[3],
     symbol$2 = _c_[4],
     symbol$3 = _c_[5],
     symbol$4 = _c_[6],
     equal = _c_[7],
     compare = _c_[8],
     min = _c_[9],
     max = _c_[10],
     ascending = _c_[11],
     descending = _c_[12],
     between = _c_[13],
     clamp_exn = _c_[14],
     clamp = _c_[15],
     comparator = _c_[16],
     include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
     pp = include[1],
     hashable = [0, hash, compare, sexp_of_t];
    return [0,
            hash_fold_t,
            hash,
            t_of_sexp,
            sexp_of_t,
            of_string,
            to_string,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare,
            min,
            max,
            ascending,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator,
            pp,
            hashable];
   }
   var
    Base_Identifiable =
      [0,
       function(T){
        var
         hash_fold_t = T[2],
         hash = T[3],
         t_of_sexp = T[4],
         sexp_of_t = T[5],
         of_string = T[6],
         to_string = T[7],
         _b_ = caml_call1(Base_Comparable[11], [0, T[1], T[5]]),
         symbol = _b_[1],
         symbol$0 = _b_[2],
         symbol$1 = _b_[3],
         symbol$2 = _b_[4],
         symbol$3 = _b_[5],
         symbol$4 = _b_[6],
         equal = _b_[7],
         compare = _b_[8],
         min = _b_[9],
         max = _b_[10],
         ascending = _b_[11],
         descending = _b_[12],
         between = _b_[13],
         clamp_exn = _b_[14],
         clamp = _b_[15],
         comparator = _b_[16],
         include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
         pp = include[1],
         hashable = [0, hash, compare, sexp_of_t];
        return [0,
                hash_fold_t,
                hash,
                t_of_sexp,
                sexp_of_t,
                of_string,
                to_string,
                symbol,
                symbol$0,
                symbol$1,
                symbol$2,
                symbol$3,
                symbol$4,
                equal,
                compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator,
                pp,
                hashable];
       },
       _a_];
   runtime.caml_register_global(2, Base_Identifiable, "Base__Identifiable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Unit
//# unitInfo: Requires: Base__Identifiable, Base__Import
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$0 = "()";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    all = [0, 0, 0],
    module_name = "Base.Unit",
    Base_Import = global_data.Base__Import,
    Base_Identifiable = global_data.Base__Identifiable,
    globalize = Base_Import[290],
    hash_fold_t = Base_Import[210],
    func = Base_Import[224],
    cst_Base_Unit_of_string_expect = "Base.Unit.of_string: () expected";
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[158],
    sexp_of_t = Base_Import[134],
    t_sexp_grammar = Base_Import[180];
   function compare(param, _c_){return 0;}
   function compare_local(param, _b_){return 0;}
   function equal_local(param, _a_){return 1;}
   function of_string(param){
    return runtime.caml_string_notequal(param, cst$0)
            ? caml_call1(Base_Import[124], cst_Base_Unit_of_string_expect)
            : 0;
   }
   function to_string(param){return cst;}
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24];
   function invariant(param){return 0;}
   var
    Base_Unit =
      [0,
       all,
       globalize,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       equal_local,
       compare_local,
       invariant];
   runtime.caml_register_global(7, Base_Unit, "Base__Unit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common
//# unitInfo: Requires: Base__Error, Base__Ordered_collection_common0, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Base_Error = global_data.Base__Error,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    get_pos_len_exn = Base_Ordered_collection_common[1],
    check_pos_len_exn = Base_Ordered_collection_common[2],
    Private = Base_Ordered_collection_common[3];
   function get_pos_len(pos, len, param, total_length){
    try{
     var _a_ = [0, caml_call4(get_pos_len_exn, pos, len, 0, total_length)];
     return _a_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var s = exn[2];
     return [1, caml_call1(Base_Error[14], s)];
    }
   }
   var
    Base_Ordered_collection_common$0 =
      [0, get_pos_len_exn, check_pos_len_exn, Private, get_pos_len];
   runtime.caml_register_global
    (3, Base_Ordered_collection_common$0, "Base__Ordered_collection_common");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_search
//# unitInfo: Requires: Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common;
   function find_first_satisfying(pos, len, t, get, length, pred){
    var
     _e_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _e_),
     len$0 = match[2],
     pos$0 = match[1],
     _f_ = caml_call2(Base_Import[91], pos$0, len$0),
     hi$0 = caml_call2(Base_Import[93], _f_, 1),
     lo$1 = pos$0,
     hi = hi$0;
    for(;;){
     if(8 >= caml_call2(Base_Import[93], hi, lo$1)) break;
     var
      _c_ = caml_call2(Base_Import[93], hi, lo$1),
      _d_ = caml_call2(Base_Import[95], _c_, 2),
      mid = caml_call2(Base_Import[91], lo$1, _d_);
     if(caml_call1(pred, caml_call2(get, t, mid)))
      var hi = mid;
     else
      var lo$2 = caml_call2(Base_Import[91], mid, 1), lo$1 = lo$2;
    }
    var lo = lo$1;
    for(;;){
     if(hi < lo) return 0;
     if(caml_call1(pred, caml_call2(get, t, lo))) return [0, lo];
     var lo$0 = caml_call2(Base_Import[91], lo, 1), lo = lo$0;
    }
   }
   function find_last_satisfying(pos, len, t, pred, get, length){
    var
     _a_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _a_),
     len$0 = match[2],
     pos$0 = match[1];
    if(0 === len$0) return 0;
    var
     match$0 =
       find_first_satisfying
        ([0, pos$0],
         [0, len$0],
         t,
         get,
         length,
         function(x){return 1 - caml_call1(pred, x);});
    if(match$0){
     var i = match$0[1];
     return i === pos$0 ? 0 : [0, caml_call2(Base_Import[93], i, 1)];
    }
    var _b_ = caml_call2(Base_Import[91], pos$0, len$0);
    return [0, caml_call2(Base_Import[93], _b_, 1)];
   }
   function binary_search(pos, len, t, length, get, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;},
                  get,
                  length)
             : -253007807
               <= how
               ? find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
                  get,
                  length)
               : find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      match =
        find_last_satisfying
         (pos,
          len,
          t,
          function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
          get,
          length);
     if(match){
      var x = match[1];
      if(0 === caml_call2(compare, caml_call2(get, t, x), v)) return [0, x];
     }
     return 0;
    }
    var
     match$0 =
       find_first_satisfying
        (pos,
         len,
         t,
         get,
         length,
         function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(match$0){
     var x$0 = match$0[1];
     if(0 === caml_call2(compare, caml_call2(get, t, x$0), v))
      return [0, x$0];
    }
    return 0;
   }
   function binary_search_segmented(pos, len, t, length, get, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(pos, len, t, is_left, get, length)
            : find_first_satisfying(pos, len, t, get, length, is_right);
   }
   var Base_Binary_search = [0, binary_search, binary_search_segmented];
   runtime.caml_register_global(2, Base_Binary_search, "Base__Binary_search");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    all =
      [0,
       200870407,
       [0,
        -253007807,
        [0, -1055410545, [0, -1056898635, [0, 926943384, [0, -839473056, 0]]]]]],
    all$0 = [0, 125585502, [0, -63348021, 0]],
    Which_target_by_key = [0, all],
    Which_target_by_segment = [0, all$0],
    Base_Binary_searchable_intf =
      [0, Which_target_by_key, Which_target_by_segment];
   runtime.caml_register_global
    (2, Base_Binary_searchable_intf, "Base__Binary_searchable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable
//# unitInfo: Requires: Base__Binary_search, Base__Binary_searchable_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Binary_search = global_data.Base__Binary_search;
   function Make_gen(T){
    var get = T[1], length = T[2];
    function binary_search(pos, len, t, compare, how, v){
     return caml_call8
             (Base_Binary_search[1],
              pos,
              len,
              t,
              length,
              get,
              compare,
              how,
              v);
    }
    function binary_search_segmented(pos, len, t, segment_of, how){
     return caml_call7
             (Base_Binary_search[2],
              pos,
              len,
              t,
              length,
              get,
              segment_of,
              how);
    }
    return [0, , , binary_search, binary_search_segmented];
   }
   function _a_(T){
    var get = T[1], length = T[2], _c_ = Make_gen([0, get, length]);
    return [0, _c_[3], _c_[4]];
   }
   var
    Base_Binary_searchable =
      [0,
       function(T){
        var get = T[1], length = T[2], _b_ = Make_gen([0, get, length]);
        return [0, _b_[3], _b_[4]];
       },
       _a_];
   runtime.caml_register_global
    (1, Base_Binary_searchable, "Base__Binary_searchable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Blit_intf = [0];
   runtime.caml_register_global(0, Base_Blit_intf, "Base__Blit_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes0
//# unitInfo: Requires: Base__Import0, Base__Int_conversions, Base__Sys0, Base__Uchar0, Stdlib__BytesLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Uchar0 = global_data.Base__Uchar0,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Primitives = [0],
    max_length = Base_Sys0[10],
    blit = Stdlib_BytesLabels[11],
    blit_string = Stdlib_BytesLabels[12],
    compare = Stdlib_BytesLabels[40],
    copy = Stdlib_BytesLabels[4],
    create = caml_create_bytes,
    set_uchar_utf_8 = Stdlib_BytesLabels[51],
    set_uchar_utf_16le = Stdlib_BytesLabels[57],
    set_uchar_utf_16be = Stdlib_BytesLabels[54],
    cst_Bytes_create_local = "Bytes.create_local";
   function set_utf_32_uchar(set_int32, bytes, idx, uchar){
    var
     _o_ = caml_call1(Base_Uchar0[8], uchar),
     _p_ = caml_call1(Base_Int_conversions[3], _o_);
    caml_call1(caml_call2(set_int32, bytes, idx), _p_);
    return 4;
   }
   var _a_ = Stdlib_BytesLabels[83];
   function set_uchar_utf_32le(_l_, _m_, _n_){
    return set_utf_32_uchar(_a_, _l_, _m_, _n_);
   }
   var _b_ = Stdlib_BytesLabels[82];
   function set_uchar_utf_32be(_i_, _j_, _k_){
    return set_utf_32_uchar(_b_, _i_, _j_, _k_);
   }
   function create_local(len){
    if(Base_Sys0[10] < len)
     caml_call1(Base_Import0[126], cst_Bytes_create_local);
    return runtime.Base_unsafe_create_local_bytes(len);
   }
   var fill = Stdlib_BytesLabels[10], make = Stdlib_BytesLabels[1];
   function map(t, f){
    var l = caml_ml_bytes_length(t);
    if(0 === l) return t;
    var
     r = caml_create_bytes(l),
     _g_ = caml_call2(Base_Import0[93], l, 1),
     _f_ = 0;
    if(_g_ >= 0){
     var i = _f_;
     for(;;){
      caml_bytes_unsafe_set(r, i, caml_call1(f, caml_bytes_unsafe_get(t, i)));
      var _h_ = i + 1 | 0;
      if(_g_ === i) break;
      var i = _h_;
     }
    }
    return r;
   }
   function mapi(t, f){
    var l = caml_ml_bytes_length(t);
    if(0 === l) return t;
    var
     r = caml_create_bytes(l),
     _d_ = caml_call2(Base_Import0[93], l, 1),
     _c_ = 0;
    if(_d_ >= 0){
     var i = _c_;
     for(;;){
      caml_bytes_unsafe_set
       (r, i, caml_call2(f, i, caml_bytes_unsafe_get(t, i)));
      var _e_ = i + 1 | 0;
      if(_d_ === i) break;
      var i = _e_;
     }
    }
    return r;
   }
   var
    sub = Stdlib_BytesLabels[7],
    to_string = Stdlib_BytesLabels[6],
    of_string = Stdlib_BytesLabels[5],
    Base_Bytes0 =
      [0,
       Primitives,
       max_length,
       blit,
       blit_string,
       compare,
       copy,
       create,
       set_uchar_utf_8,
       set_uchar_utf_16le,
       set_uchar_utf_16be,
       set_utf_32_uchar,
       set_uchar_utf_32le,
       set_uchar_utf_32be,
       create_local,
       fill,
       make,
       map,
       mapi,
       sub,
       to_string,
       of_string];
   runtime.caml_register_global(6, Base_Bytes0, "Base__Bytes0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit
//# unitInfo: Requires: Base__Blit_intf, Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_string_of_bytes = runtime.caml_string_of_bytes;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common;
   function Make_gen(Src, Dst){
    var unsafe_blit = Dst[3];
    function blit(src, src_pos, dst, dst_pos, len){
     var _o_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], src_pos, len, _o_);
     var _p_ = caml_call1(Dst[1], dst);
     caml_call3(Base_Ordered_collection_common[2], dst_pos, len, _p_);
     var _q_ = 0 < len ? 1 : 0;
     return _q_
             ? caml_call5(unsafe_blit, src, src_pos, dst, dst_pos, len)
             : _q_;
    }
    function blito(src, opt, _m_, dst, _l_, param){
     if(opt) var sth = opt[1], src_pos = sth; else var src_pos = 0;
     if(_m_)
      var sth$0 = _m_[1], src_len = sth$0;
     else
      var
       _n_ = caml_call1(Src[1], src),
       src_len = caml_call2(Base_Import[93], _n_, src_pos);
     if(_l_) var sth$1 = _l_[1], dst_pos = sth$1; else var dst_pos = 0;
     return blit(src, src_pos, dst, dst_pos, src_len);
    }
    function sub(src, pos, len){
     var _k_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], pos, len, _k_);
     var dst = caml_call2(Dst[2], len, src);
     if(0 < len) caml_call5(unsafe_blit, src, pos, dst, 0, len);
     return dst;
    }
    function subo(opt, len, src){
     if(opt) var sth = opt[1], pos = sth; else var pos = 0;
     if(len)
      var i = len[1], i$0 = i;
     else
      var
       _j_ = caml_call1(Src[1], src),
       i$0 = caml_call2(Base_Import[93], _j_, pos);
     return sub(src, pos, i$0);
    }
    return [0, unsafe_blit, blit, blito, sub, subo];
   }
   function Make_to_string(T, To_bytes){
    function sub(src, pos, len){
     return caml_string_of_bytes(caml_call3(To_bytes[4], src, pos, len));
    }
    function subo(pos, len, src){
     return caml_string_of_bytes(caml_call3(To_bytes[5], pos, len, src));
    }
    return [0, sub, subo];
   }
   function _a_(_h_){
    var _i_ = Make_gen([0, _h_[2]], [0, _h_[2], _h_[1], _h_[3]]);
    return [0, _i_[2], _i_[3], _i_[1], _i_[4], _i_[5]];
   }
   function _b_(_e_){
    var _f_ = [0, _e_[2], _e_[1], _e_[3]], _g_ = Make_gen([0, _f_[1]], _f_);
    return [0, _g_[2], _g_[3], _g_[1], _g_[4], _g_[5]];
   }
   function _c_(Src, Dst){
    var length = Dst[1];
    function create_like(len, param){return caml_call1(Dst[2], len);}
    var
     unsafe_blit = Dst[3],
     length$0 = Src[1],
     _d_ = Make_gen([0, length$0], [0, length, create_like, unsafe_blit]);
    return [0, _d_[2], _d_[3], _d_[1], _d_[4], _d_[5]];
   }
   var
    Base_Blit =
      [0,
       function(Sequence){
        function create_like(len, param){return caml_call1(Sequence[2], len);}
        var
         length = Sequence[1],
         unsafe_blit = Sequence[3],
         include =
           Make_gen([0, length], [0, length, create_like, unsafe_blit]),
         unsafe_blit$0 = include[1],
         blit = include[2],
         blito = include[3],
         sub = include[4],
         subo = include[5];
        return [0, blit, blito, unsafe_blit$0, sub, subo];
       },
       _c_,
       Make_to_string,
       _b_,
       _a_];
   runtime.caml_register_global(2, Base_Blit, "Base__Blit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bool
//# unitInfo: Requires: Base__Bool0, Base__Comparator, Base__Import, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_bool_ml = "src/bool.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, 0]],
    module_name = "Base.Bool",
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Printf = global_data.Base__Printf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    invalid_argf = Base_Printf[7],
    compare = Base_Import[225],
    globalize = Base_Import[281],
    hash_fold_t = Base_Import[207],
    func = Base_Import[221],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _b_ = [0, cst_src_bool_ml, 59, 2],
    _a_ =
      [0,
       [11, "Bool.of_string: expected true or false but got ", [2, 0, 0]],
       "Bool.of_string: expected true or false but got %s"],
    _c_ = [0, cst_src_bool_ml, 86, 9];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[159],
    sexp_of_t = Base_Import[135],
    t_sexp_grammar = Base_Import[181],
    hashable = [0, hash, compare, sexp_of_t];
   function of_string(s){
    return caml_string_notequal(s, "false")
            ? caml_string_notequal
               (s, "true")
              ? caml_call3(invalid_argf, _a_, s, 0)
              : 1
            : 0;
   }
   var
    to_string = Base_Import[85][30],
    include = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t]),
    comparator = include[1],
    include$0 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$0[1];
   function invariant(param){return 0;}
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[105][2], low, t);
    return _k_ ? caml_call2(Base_Import[105][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[105][1], t, min)
            ? min
            : caml_call2(Base_Import[105][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[105][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[105][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[39], _j_);
   }
   function to_int(x){return caml_call1(Base_Import[86], x);}
   function symbol(a, b){
    var _f_ = to_int(b), _g_ = to_int(a);
    return caml_call2(Base_Import[118], _g_, _f_);
   }
   function symbol$0(a, b){
    var _d_ = to_int(b), _e_ = to_int(a);
    return caml_call2(Base_Import[116], _e_, _d_);
   }
   if(1 === to_int(1) && 0 === to_int(0)){
    var
     include$1 = Base_Import[105],
     symbol$1 = include$1[1],
     symbol$2 = include$1[2],
     symbol$3 = include$1[3],
     symbol$4 = include$1[4],
     symbol$5 = include$1[5],
     symbol$6 = include$1[6],
     ascending = include$1[7],
     descending = include$1[8],
     compare$0 = include$1[9],
     compare_local = include$1[10],
     equal = include$1[11],
     equal_local = include$1[12],
     max = include$1[13],
     min = include$1[14],
     Base_Bool =
       [0,
        all,
        globalize,
        t_sexp_grammar,
        hash_fold_t,
        hash,
        t_of_sexp,
        sexp_of_t,
        of_string,
        to_string,
        symbol$6,
        symbol$2,
        symbol$4,
        symbol$5,
        symbol$1,
        symbol$3,
        equal,
        compare$0,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        pp,
        hashable,
        compare_local,
        equal_local,
        invariant,
        to_int,
        [0, symbol$0, symbol]];
    runtime.caml_register_global(17, Base_Bool, "Base__Bool");
    return;
   }
   throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
  }
  (globalThis));

//# unitInfo: Provides: Base__Either_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Either_intf = [0];
   runtime.caml_register_global(0, Base_Either_intf, "Base__Either_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either
//# unitInfo: Requires: Base__Applicative, Base__Either0, Base__Either_intf, Base__List0, Base__Monad, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_With_return = global_data.Base__With_return,
    Base_List0 = global_data.Base__List0,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    Base_Either0 = global_data.Base__Either0,
    compare_local = Base_Either0[1],
    compare = Base_Either0[2],
    hash_fold_t = Base_Either0[3],
    t_of_sexp = Base_Either0[4],
    sexp_of_t = Base_Either0[5],
    t_sexp_grammar = Base_Either0[6];
   function swap(param){
    if(0 === param[0]){var x = param[1]; return [1, x];}
    var x$0 = param[1];
    return [0, x$0];
   }
   function is_first(param){return 0 === param[0] ? 1 : 0;}
   function is_second(param){return 0 === param[0] ? 0 : 1;}
   function value(param){var x = param[1]; return x;}
   function value_map(t, first, second){
    if(0 === t[0]){var x = t[1]; return caml_call1(first, x);}
    var x$0 = t[1];
    return caml_call1(second, x$0);
   }
   function map(t, first, second){
    if(0 === t[0]){var x = t[1]; return [0, caml_call1(first, x)];}
    var x$0 = t[1];
    return [1, caml_call1(second, x$0)];
   }
   function first(x){return [0, x];}
   function second(x){return [1, x];}
   function equal(eq1, eq2, t1, t2){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return caml_call2(eq1, x, y);}
    }
    else{
     var x$0 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return caml_call2(eq2, x$0, y$0);}
    }
    return 0;
   }
   function local_equal(eq1, eq2, t1, t2){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return caml_call2(eq1, x, y);}
    }
    else{
     var x$0 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return caml_call2(eq2, x$0, y$0);}
    }
    return 0;
   }
   function invariant(f, s, param){
    if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
    var y = param[1];
    return caml_call1(s, y);
   }
   function Make_focused(M){
    var
     return$0 = M[1],
     other = M[2],
     focus = M[3],
     combine = M[4],
     bind = M[5],
     map =
       [0,
        -198771759,
        function(t, f){
         var
          res =
            caml_call2
             (bind,
              t,
              function(x){return caml_call1(return$0, caml_call1(f, x));});
         return res;
        }],
     include = caml_call1(Base_Monad[6], [0, bind, map, return$0]),
     symbol_bind = include[1],
     Let_syntax = include[3],
     Monad_infix = include[4],
     bind$0 = include[5],
     return$1 = include[6],
     join = include[8],
     ignore_m = include[9],
     map$0 = [0, -198771759, include[7]];
    function map2(t1, t2, f){
     return caml_call2
             (bind$0,
              t1,
              function(x){
               return caml_call2
                       (bind$0,
                        t2,
                        function(y){
                         return caml_call1(return$1, caml_call2(f, x, y));
                        });
              });
    }
    var
     App = caml_call1(Base_Applicative[17], [0, return$1, map2, map$0]),
     return$2 = App[1],
     map$1 = App[2],
     both = App[3],
     symbol = App[4],
     symbol$0 = App[5],
     symbol$1 = App[6],
     symbol_map = App[7],
     apply = App[8],
     map2$0 = App[9],
     map3 = App[10],
     all = App[11],
     all_unit = App[12],
     Applicative_infix = App[13];
    function combine_all(ts$1, f){
     var acc$1 = 0, param$0 = ts$1;
     for(;;){
      if(! param$0)
       return caml_call1(return$2, caml_call1(Base_List0[19], acc$1));
      var
       ts$0 = param$0[2],
       t$0 = param$0[1],
       match$0 = caml_call1(focus, t$0);
      if(0 !== match$0[0]) break;
      var acc$2 = [0, match$0[1], acc$1], acc$1 = acc$2, param$0 = ts$0;
     }
     var acc$3 = match$0[1], acc = acc$3, param = ts$0;
     for(;;){
      if(! param) return caml_call1(other, acc);
      var ts = param[2], t = param[1], match = caml_call1(focus, t);
      if(0 === match[0])
       var param = ts;
      else
       var acc$0 = caml_call2(f, acc, match[1]), acc = acc$0, param = ts;
     }
    }
    function combine_all_unit(ts$1, f){
     var param$0 = ts$1;
     for(;;){
      if(! param$0) return caml_call1(return$2, 0);
      var
       ts$0 = param$0[2],
       t$0 = param$0[1],
       match$0 = caml_call1(focus, t$0);
      if(0 !== match$0[0]) break;
      var param$0 = ts$0;
     }
     var acc$1 = match$0[1], acc = acc$1, param = ts$0;
     for(;;){
      if(! param) return caml_call1(other, acc);
      var ts = param[2], t = param[1], match = caml_call1(focus, t);
      if(0 === match[0])
       var param = ts;
      else
       var acc$0 = caml_call2(f, acc, match[1]), acc = acc$0, param = ts;
     }
    }
    function to_option(t){
     var match = caml_call1(focus, t);
     return 0 === match[0] ? [0, match[1]] : 0;
    }
    function value(t, default$0){
     var match = caml_call1(focus, t);
     return 0 === match[0] ? match[1] : default$0;
    }
    function with_return(f){
     function _a_(ret){
      return caml_call1
              (other,
               caml_call1(f, caml_call2(Base_With_return[3], ret, return$2)));
     }
     return caml_call1(Base_With_return[1], _a_);
    }
    return [0,
            ,
            ,
            combine,
            symbol_bind,
            Let_syntax,
            Monad_infix,
            bind$0,
            join,
            ignore_m,
            ,
            return$2,
            map$1,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2$0,
            map3,
            all,
            all_unit,
            Applicative_infix,
            combine_all,
            combine_all_unit,
            to_option,
            value,
            with_return];
   }
   function focus(t){
    if(0 === t[0]){var x = t[1]; return [0, x];}
    var y = t[1];
    return [1, y];
   }
   function combine(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(f, x, y)];}
     var x$0 = t2[1];
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){
      var y$0 = t2[1];
      return [1, caml_call2(other, x$1, y$0)];
     }
     var x$0 = x$1;
    }
    return [1, x$0];
   }
   function bind(t, f){
    if(0 !== t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var First = Make_focused([0, first, second, focus, combine, bind]);
   function focus$0(t){
    if(0 === t[0]){var y = t[1]; return [1, y];}
    var x = t[1];
    return [0, x];
   }
   function combine$0(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(other, x, y)];}
     var x$0 = x;
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return [1, caml_call2(f, x$1, y$0)];}
     var x$0 = t2[1];
    }
    return [0, x$0];
   }
   function bind$0(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var
    Second = Make_focused([0, second, first, focus$0, combine$0, bind$0]),
    Export = [0],
    Base_Either =
      [0,
       compare,
       compare_local,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       swap,
       value,
       value_map,
       value_map,
       map,
       equal,
       local_equal,
       [0,
        First[4],
        First[5],
        First[6],
        First[7],
        First[8],
        First[9],
        First[11],
        First[12],
        First[13],
        First[14],
        First[15],
        First[16],
        First[17],
        First[18],
        First[19],
        First[20],
        First[21],
        First[22],
        First[23],
        First[27],
        First[26],
        First[28],
        First[3],
        First[24],
        First[25]],
       [0,
        Second[4],
        Second[5],
        Second[6],
        Second[7],
        Second[8],
        Second[9],
        Second[11],
        Second[12],
        Second[13],
        Second[14],
        Second[15],
        Second[16],
        Second[17],
        Second[18],
        Second[19],
        Second[20],
        Second[21],
        Second[22],
        Second[23],
        Second[27],
        Second[26],
        Second[28],
        Second[3],
        Second[24],
        Second[25]],
       is_first,
       is_second,
       first,
       second,
       Export];
   runtime.caml_register_global(5, Base_Either, "Base__Either");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option
//# unitInfo: Requires: Base__Applicative, Base__Error, Base__Import, Base__Monad, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    Base_Import = global_data.Base__Import,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    compare_local = Base_Import[265],
    compare = Base_Import[237],
    globalize = Base_Import[294],
    hash_fold_t = Base_Import[211],
    t_of_sexp = Base_Import[170],
    sexp_of_t = Base_Import[146],
    cst_Option_value_exn = "Option.value_exn",
    cst_Option_value_exn_None = "Option.value_exn None";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[193], a_sexp_grammar);
   }
   function is_none(param){return param ? 0 : 1;}
   function is_some(param){return param ? 1 : 0;}
   function value_map(o, default$0, f){
    if(! o) return default$0;
    var x = o[1];
    return caml_call1(f, x);
   }
   function iter(o, f){
    if(! o) return 0;
    var a = o[1];
    return caml_call1(f, a);
   }
   function invariant(f, t){return iter(t, f);}
   function call(x, f){
    if(! f) return 0;
    var f$0 = f[1];
    return caml_call1(f$0, x);
   }
   function value(t, default$0){
    if(! t) return default$0;
    var x = t[1];
    return x;
   }
   function value_exn(here, error, message, t){
    if(t){var x = t[1]; return x;}
    if(here){
     var p = here[1];
     if(error)
      var
       e = error[1],
       _e_ =
         caml_call2
          (Base_Import[147], Base_Error[9], Base_Source_code_position0[9]),
       _f_ = value(message, cst),
       _g_ = caml_call5(Base_Error[19], 0, 0, _f_, [0, e, p], _e_);
     else if(message)
      var
       m = message[1],
       _g_ =
         caml_call5(Base_Error[19], 0, 0, m, p, Base_Source_code_position0[9]);
     else
      var
       _g_ =
         caml_call5
          (Base_Error[19],
           0,
           0,
           cst_Option_value_exn,
           p,
           Base_Source_code_position0[9]);
     var error$0 = _g_;
    }
    else if(error){
     var e$0 = error[1];
     if(message)
      var m$0 = message[1], _h_ = caml_call2(Base_Error[22], e$0, m$0);
     else
      var _h_ = e$0;
     var error$0 = _h_;
    }
    else if(message)
     var m$1 = message[1], error$0 = caml_call1(Base_Error[14], m$1);
    else
     var error$0 = caml_call1(Base_Error[14], cst_Option_value_exn_None);
    return caml_call1(Base_Error[31], error$0);
   }
   function value_or_thunk(o, default$0){
    if(! o) return caml_call1(default$0, 0);
    var x = o[1];
    return x;
   }
   function to_array(t){if(! t) return [0]; var x = t[1]; return [0, x];}
   function to_list(t){if(! t) return 0; var x = t[1]; return [0, x, 0];}
   function for_all(t, f){
    if(! t) return 1;
    var x = t[1];
    return caml_call1(f, x);
   }
   function exists(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x);
   }
   function mem(t, a, equal){
    if(! t) return 0;
    var a$0 = t[1];
    return caml_call2(equal, a, a$0);
   }
   function length(t){return t ? 1 : 0;}
   function fold(t, init, f){
    if(! t) return init;
    var x = t[1];
    return caml_call2(f, init, x);
   }
   function find(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x) ? t : 0;
   }
   function find_map(t, f){
    if(! t) return 0;
    var a = t[1];
    return caml_call1(f, a);
   }
   function equal(f, t$0, t){
    if(t$0){
     if(t){var x = t[1], x$0 = t$0[1]; return caml_call2(f, x$0, x);}
    }
    else if(! t) return 1;
    return 0;
   }
   function equal_local(f, t$0, t){
    if(t$0){
     if(t){var x = t[1], x$0 = t$0[1]; return caml_call2(f, x$0, x);}
    }
    else if(! t) return 1;
    return 0;
   }
   function some(x){return [0, x];}
   function first_some(x, y){return x ? x : y;}
   function some_if(cond, x){return cond ? [0, x] : 0;}
   function merge(a, b, f){
    if(a){
     if(b){var b$0 = b[1], a$0 = a[1]; return [0, caml_call2(f, a$0, b$0)];}
     var x = a;
    }
    else
     var x = b;
    return x;
   }
   function filter(t, f){
    if(t){var v = t[1]; if(caml_call1(f, v)) return t;}
    return 0;
   }
   function try_with(f){
    try{var x = caml_call1(f, 0);}catch(_d_){return 0;}
    return [0, x];
   }
   function try_with_join(f){
    try{var x = caml_call1(f, 0); return x;}catch(_c_){return 0;}
   }
   function _a_(t, f){
    if(! t) return 0;
    var a = t[1];
    return [0, caml_call1(f, a)];
   }
   function return$0(x){return [0, x];}
   var map = [0, -198771759, _a_];
   function bind(o, f){
    if(! o) return 0;
    var x = o[1];
    return caml_call1(f, x);
   }
   var
    include = caml_call1(Base_Monad[5], [0, bind, return$0, map]),
    symbol_bind = include[1],
    Monad_infix = include[3],
    bind$0 = include[4],
    join = include[7],
    ignore_m = include[8],
    Let_syntax = include[11],
    _b_ = include[6];
   function return$1(x){return [0, x];}
   var map$0 = [0, -198771759, _b_];
   function map2(x, y, f){
    if(x && y){
     var y$0 = y[1], x$0 = x[1];
     return [0, caml_call2(f, x$0, y$0)];
    }
    return 0;
   }
   var
    include$0 = caml_call1(Base_Applicative[16], [0, return$1, map2, map$0]),
    return$2 = include$0[1],
    map$1 = include$0[2],
    both = include$0[3],
    symbol = include$0[4],
    symbol$0 = include$0[5],
    symbol$1 = include$0[6],
    symbol_map = include$0[7],
    apply = include$0[8],
    map2$0 = include$0[9],
    map3 = include$0[10],
    all = include$0[11],
    all_unit = include$0[12],
    Applicative_infix = include$0[13],
    Base_Option =
      [0,
       compare,
       compare_local,
       globalize,
       hash_fold_t,
       t_sexp_grammar,
       equal,
       equal_local,
       invariant,
       t_of_sexp,
       sexp_of_t,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply,
       map2$0,
       map3,
       Applicative_infix,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$2,
       map$1,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       value,
       value_exn,
       value_map,
       value_or_thunk,
       fold,
       mem,
       length,
       iter,
       exists,
       for_all,
       find,
       find_map,
       to_list,
       to_array,
       call,
       merge,
       filter,
       try_with,
       try_with_join,
       some,
       first_some,
       some_if,
       is_none,
       is_some];
   runtime.caml_register_global(8, Base_Option, "Base__Option");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_enumerate_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Enumerable = [0],
    Base_Ppx_enumerate_lib = [0, Enumerable];
   runtime.caml_register_global
    (0, Base_Ppx_enumerate_lib, "Base__Ppx_enumerate_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sequence
//# unitInfo: Requires: Base__Array0, Base__Bool, Base__Container, Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Result, CamlinternalLazy, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Both$0 = "Both",
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Sequence_nth$1 = "Sequence.nth",
    cst_both = "both",
    cst_left = "left",
    cst_right = "right",
    cst_state = "state",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_057 = "sequence.ml.Merge_with_duplicates_element.t",
    Base_List1 = global_data.Base__List1,
    Base_Import = global_data.Base__Import,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Result = global_data.Base__Result,
    Base_Container = global_data.Base__Container,
    Base_Bool = global_data.Base__Bool,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    Base_Monad = global_data.Base__Monad,
    _m_ = [0, 0],
    cst_Bug_This_branch_should_be_ = "Bug: This branch should be unreachable",
    cst_Sequence_cycle_list_exn = "Sequence.cycle_list_exn",
    cst_Sequence_drop = "Sequence.drop",
    cst_Sequence_take = "Sequence.take",
    cst_Sequence_sub = "Sequence.sub",
    cst_Sequence_reduce_exn = "Sequence.reduce_exn",
    cst_Sequence_find_exn = "Sequence.find_exn",
    cst_Sequence_chunks_exn = "Sequence.chunks_exn",
    cst_Sequence_tl_exn = "Sequence.tl_exn",
    cst_hd_exn = "hd_exn",
    cst_Both = cst_Both$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0,
    _j_ = [0, cst_Left$0],
    _k_ = [0, cst_Right$0],
    _l_ = [0, cst_Both$0],
    cst_Sequence_nth$0 = cst_Sequence_nth$1,
    cst_Sequence_nth = cst_Sequence_nth$1,
    _i_ = [0, "src/sequence.ml", 304, 14],
    _h_ = [0, 0, 0],
    _a_ = [0, "Done"],
    _b_ = [0, cst_state],
    _c_ = [0, "Skip"],
    _d_ = [0, cst_state],
    _e_ = [0, "value"],
    _f_ = [0, "Yield"];
   function sexp_of_t(of_a_001, of_s_002, param){
    if(typeof param === "number") return _a_;
    if(0 === param[0]){
     var
      state_004 = param[1],
      arg_005 = caml_call1(of_s_002, state_004),
      bnds_003 = [0, [1, [0, _b_, [0, arg_005, 0]]], 0];
     return [1, [0, _c_, bnds_003]];
    }
    var
     state_009 = param[2],
     value_007 = param[1],
     arg_010 = caml_call1(of_s_002, state_009),
     bnds_006 = [0, [1, [0, _d_, [0, arg_010, 0]]], 0],
     arg_008 = caml_call1(of_a_001, value_007),
     bnds_006$0 = [0, [1, [0, _e_, [0, arg_008, 0]]], bnds_006];
    return [1, [0, _f_, bnds_006$0]];
   }
   var Step = [0, sexp_of_t], T = [0];
   function globalize(param, _ac_){
    var next = _ac_[2], state = _ac_[1];
    return [0, state, next];
   }
   function view(t){return t;}
   function next_step(param){
    var f = param[2], s = param[1], match = caml_call1(f, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, s$0, f]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, s$1, f]];
   }
   function delayed_fold_step(s, init, f, finish){
    function loop(s, next, finish, f, acc){
     var match = caml_call1(next, s);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0]){
      var s$0 = match[1];
      return caml_call3
              (f,
               acc,
               0,
               function(_ab_){return loop(s$0, next, finish, f, _ab_);});
     }
     var s$1 = match[2], a = match[1];
     return caml_call3
             (f,
              acc,
              [0, a],
              function(_aa_){return loop(s$1, next, finish, f, _aa_);});
    }
    var next = s[2], s$0 = s[1];
    return loop(s$0, next, finish, f, init);
   }
   function unfold_step(init, f){return [0, init, f];}
   function unfold(init, f){
    return [0,
            init,
            function(s){
             var match = caml_call1(f, s);
             if(! match) return 0;
             var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
             return [1, a, s$0];
            }];
   }
   function unfold_with(s, init, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, init, s$0],
            function(param){
             var s = param[2], seed = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$0 = match[1];
              return [0, [0, seed, s$0]];
             }
             var
              s$1 = match[2],
              a = match[1],
              match$0 = caml_call2(f, seed, a);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var seed$0 = match$0[1];
              return [0, [0, seed$0, s$1]];
             }
             var seed$1 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, seed$1, s$1]];
            }];
   }
   function unfold_with_and_finish
   (s, init, running_step, inner_finished, finishing_step){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -172306698, [0, init, s$0]],
            function(state){
             if(301075099 <= state[1]){
              var
               state$0 = state[2],
               match = caml_call1(finishing_step, state$0);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var state$1 = match[1];
               return [0, [0, 301075099, state$1]];
              }
              var state$2 = match[2], y = match[1];
              return [1, y, [0, 301075099, state$2]];
             }
             var
              match$0 = state[2],
              inner_state = match$0[2],
              state$3 = match$0[1],
              match$1 = caml_call1(next, inner_state);
             if(typeof match$1 === "number")
              return [0, [0, 301075099, caml_call1(inner_finished, state$3)]];
             if(0 === match$1[0]){
              var inner_state$0 = match$1[1];
              return [0, [0, -172306698, [0, state$3, inner_state$0]]];
             }
             var
              inner_state$1 = match$1[2],
              x = match$1[1],
              match$2 = caml_call2(running_step, state$3, x);
             if(typeof match$2 === "number") return 0;
             if(0 === match$2[0]){
              var state$4 = match$2[1];
              return [0, [0, -172306698, [0, state$4, inner_state$1]]];
             }
             var state$5 = match$2[2], y$0 = match$2[1];
             return [1, y$0, [0, -172306698, [0, state$5, inner_state$1]]];
            }];
   }
   function of_list(l){
    return [0,
            l,
            function(param){
             if(! param) return 0;
             var l = param[2], x = param[1];
             return [1, x, l];
            }];
   }
   function fold(t, init, f){
    var next = t[2], seed$2 = t[1], seed = seed$2, v = init;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return v;
     if(0 === match[0])
      var seed$0 = match[1], seed = seed$0;
     else
      var
       seed$1 = match[2],
       a = match[1],
       v$0 = caml_call2(f, v, a),
       seed = seed$1,
       v = v$0;
    }
   }
   function to_list_rev(t){
    return fold(t, 0, function(l, x){return [0, x, l];});
   }
   function to_list(param){
    var next = param[2], s = param[1], s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]) break;
     var s$1 = match[1], s$0 = s$1;
    }
    var
     s$2 = match[2],
     a = match[1],
     block = [0, a, 24029],
     dst = block,
     offset = 1,
     s$3 = s$2;
    for(;;){
     var match$0 = caml_call1(next, s$3);
     if(typeof match$0 === "number"){dst[1 + offset] = 0; return block;}
     if(0 === match$0[0])
      var s$4 = match$0[1], s$3 = s$4;
     else{
      var s$5 = match$0[2], a$0 = match$0[1], dst$0 = [0, a$0, 24029];
      dst[1 + offset] = dst$0;
      var dst = dst$0, offset = 1, s$3 = s$5;
     }
    }
   }
   function sexp_of_t$0(sexp_of_a, t){
    var _$_ = to_list(t);
    return caml_call2(Base_Import[149], sexp_of_a, _$_);
   }
   function range(opt, ___, _Z_, start_v, stop_v){
    if(opt) var sth = opt[1], stride = sth; else var stride = 1;
    if(___) var sth$0 = ___[1], start = sth$0; else var start = 104758188;
    if(_Z_) var sth$1 = _Z_[1], stop = sth$1; else var stop = -160346914;
    var
     step =
       104758188 <= stop
        ? 0
          <= stride
          ? function
           (i){
            return stop_v < i
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           }
          : function
           (i){
            return i < stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           }
        : 0
          <= stride
          ? function
           (i){
            return stop_v <= i
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           }
          : function
           (i){
            return i <= stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[91], i, stride)];
           },
     init =
       104758188 <= start
        ? start_v
        : caml_call2(Base_Import[91], start_v, stride);
    return [0, init, step];
   }
   function of_lazy(t_lazy){
    return [0,
            t_lazy,
            function(t_lazy){
             var _Y_ = caml_obj_tag(t_lazy);
             a:
             if(250 === _Y_)
              var match = t_lazy[1];
             else{
              if(246 !== _Y_ && 244 !== _Y_){var match = t_lazy; break a;}
              var match = caml_call1(CamlinternalLazy[2], t_lazy);
             }
             var next = match[2], s = match[1], match$0 = caml_call1(next, s);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s$0 = match$0[1], v = [0, s$0, next];
              return [0, v];
             }
             var s$1 = match$0[2], x = match$0[1], v$0 = [0, s$1, next];
             return [1, x, v$0];
            }];
   }
   function _g_(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var s$0 = match[2], a = match[1];
             return [1, caml_call1(f, a), s$0];
            }];
   }
   function mapi(t, f){
    var next = t[2], s = t[1];
    return [0,
            [0, 0, s],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var
              s$1 = match[2],
              a = match[1],
              _X_ = [0, caml_call2(Base_Import[91], i, 1), s$1];
             return [1, caml_call2(f, i, a), _X_];
            }];
   }
   function folding_map(t, init, f){
    return unfold_with
            (t,
             init,
             function(acc, x){
              var
               match = caml_call2(f, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, acc$0];
             });
   }
   function folding_mapi(t, init, f){
    return unfold_with
            (t,
             [0, 0, init],
             function(param, x){
              var
               acc = param[2],
               i = param[1],
               match = caml_call3(f, i, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, [0, caml_call2(Base_Import[91], i, 1), acc$0]];
             });
   }
   function filter(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var a = match[1], s$0 = match[2];
             if(caml_call1(f, a)) return [1, a, s$0];
             var s$1 = match[2];
             return [0, s$1];
            }];
   }
   function filteri(t, f){
    var _V_ = Base_Import[127];
    function _W_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return _g_(filter(mapi(t, function(i, s){return [0, i, s];}), _W_), _V_);
   }
   function length(t){
    var next = t[2], seed = t[1], i = 0, s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return i;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else
      var
       s$1 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       i = i$0,
       s = s$1;
    }
   }
   function to_array(t){
    var
     match =
       fold
        (t,
         _h_,
         function(param, x){
          var i = param[2], l = param[1];
          return [0, [0, x, l], caml_call2(Base_Import[91], i, 1)];
         }),
     len = match[2],
     l = match[1];
    if(! l) return [0];
    var
     l$0 = l[2],
     x = l[1],
     a = caml_call2(Base_Array0[4], len, x),
     i$1 = caml_call2(Base_Import[93], len, 2),
     i = i$1,
     l$1 = l$0;
    for(;;){
     if(! l$1){
      if(-1 === i) return a;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
     var l$2 = l$1[2], x$0 = l$1[1];
     runtime.caml_check_bound(a, i)[1 + i] = x$0;
     var i$0 = caml_call2(Base_Import[93], i, 1), i = i$0, l$1 = l$2;
    }
   }
   function find(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(caml_call1(f, a)) return [0, a];
      var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   function find_map(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call1(f, a);
      if(some_b) return some_b;
      var s = s$1;
     }
    }
   }
   function find_mapi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call2(f, i, a);
      if(some_b) return some_b;
      var i$0 = caml_call2(Base_Import[91], i, 1), s = s$1, i = i$0;
     }
    }
   }
   function for_all(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(! caml_call1(f, a)) return 0;
      var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   function for_alli(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var a = match[1];
      if(! caml_call2(f, i, a)) return 0;
      var
       s$1 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       s = s$1,
       i = i$0;
     }
    }
   }
   function exists(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{var a = match[1]; if(caml_call1(f, a)) return 1; var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   function existsi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var a = match[1];
      if(caml_call2(f, i, a)) return 1;
      var
       s$1 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       s = s$1,
       i = i$0;
     }
    }
   }
   function iter(t, f){
    var next = t[2], seed$2 = t[1], seed = seed$2;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var seed$0 = match[1], seed = seed$0;
     else{
      var seed$1 = match[2], a = match[1];
      caml_call1(f, a);
      var seed = seed$1;
     }
    }
   }
   function is_empty(t){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 !== match[0]) return 0;
     var s$0 = match[1], s = s$0;
    }
   }
   function mem(t, a, equal){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var b = match[1];
      if(caml_call2(equal, a, b)) return 1;
      var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   var empty = [0, 0, function(param){return 0;}];
   function bind(t, f){
    return [0,
            [0, empty, t],
            function(param){
             var
              rest = param[2],
              match = param[1],
              next = match[2],
              seed = match[1],
              match$0 = caml_call1(next, seed);
             if(typeof match$0 === "number"){
              var
               next$0 = rest[2],
               seed$0 = rest[1],
               match$1 = caml_call1(next$0, seed$0);
              if(typeof match$1 === "number") return 0;
              if(0 === match$1[0]){
               var s = match$1[1];
               return [0, [0, empty, [0, s, next$0]]];
              }
              var s$0 = match$1[2], a = match$1[1];
              return [0, [0, caml_call1(f, a), [0, s$0, next$0]]];
             }
             if(0 === match$0[0]){
              var s$1 = match$0[1];
              return [0, [0, [0, s$1, next], rest]];
             }
             var s$2 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, [0, s$2, next], rest]];
            }];
   }
   function return$0(x){
    return [0,
            [0, x],
            function(param){
             if(! param) return 0;
             var x = param[1];
             return [1, x, 0];
            }];
   }
   var
    map = [0, -198771759, _g_],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function nth(s, n){
    if(0 > n) return 0;
    var next = s[2], s$3 = s[1], i = n, s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], a = match[1];
      if(0 === i) return [0, a];
      var i$0 = caml_call2(Base_Import[93], i, 1), i = i$0, s$0 = s$2;
     }
    }
   }
   function nth_exn(s, n){
    if(0 > n) return caml_call1(Base_Import[126], cst_Sequence_nth$0);
    var match = nth(s, n);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_nth);
    var x = match[1];
    return x;
   }
   function compare_local(cmp_a, cmp_b, a_023, b_024){
    if(a_023 === b_024) return 0;
    switch(a_023[0]){
      case 0:
       var a_025 = a_023[1];
       if(0 !== b_024[0]) return -1;
       var b_026 = b_024[1];
       return caml_call2(cmp_a, a_025, b_026);
      case 1:
       var a_027 = a_023[1];
       switch(b_024[0]){
         case 0: break;
         case 1:
          var b_028 = b_024[1]; return caml_call2(cmp_b, a_027, b_028);
         default: return -1;
       }
       break;
      default:
       var a_031 = a_023[2], a_029 = a_023[1];
       switch(b_024[0]){
         case 0: break;
         case 1:
          return 1;
         default:
          var
           b_032 = b_024[2],
           b_030 = b_024[1],
           n = caml_call2(cmp_a, a_029, b_030);
          return 0 === n ? caml_call2(cmp_b, a_031, b_032) : n;
       }
    }
    return 1;
   }
   function compare(cmp_a, cmp_b, a_013, b_014){
    if(a_013 === b_014) return 0;
    switch(a_013[0]){
      case 0:
       var a_015 = a_013[1];
       if(0 !== b_014[0]) return -1;
       var b_016 = b_014[1];
       return caml_call2(cmp_a, a_015, b_016);
      case 1:
       var a_017 = a_013[1];
       switch(b_014[0]){
         case 0: break;
         case 1:
          var b_018 = b_014[1]; return caml_call2(cmp_b, a_017, b_018);
         default: return -1;
       }
       break;
      default:
       var a_021 = a_013[2], a_019 = a_013[1];
       switch(b_014[0]){
         case 0: break;
         case 1:
          return 1;
         default:
          var
           b_022 = b_014[2],
           b_020 = b_014[1],
           n = caml_call2(cmp_a, a_019, b_020);
          return 0 === n ? caml_call2(cmp_b, a_021, b_022) : n;
       }
    }
    return 1;
   }
   function equal_local(cmp_a, cmp_b, a_043, b_044){
    if(a_043 === b_044) return 1;
    switch(a_043[0]){
      case 0:
       var a_045 = a_043[1];
       if(0 !== b_044[0]) return 0;
       var b_046 = b_044[1];
       return caml_call2(cmp_a, a_045, b_046);
      case 1:
       var a_047 = a_043[1];
       switch(b_044[0]){
         case 0: break;
         case 1:
          var b_048 = b_044[1]; return caml_call2(cmp_b, a_047, b_048);
         default: return 0;
       }
       break;
      default:
       var a_051 = a_043[2], a_049 = a_043[1];
       switch(b_044[0]){
         case 0: break;
         case 1:
          return 0;
         default:
          var
           b_052 = b_044[2],
           b_050 = b_044[1],
           _U_ = caml_call2(cmp_a, a_049, b_050);
          return _U_ ? caml_call2(cmp_b, a_051, b_052) : _U_;
       }
    }
    return 0;
   }
   function equal(cmp_a, cmp_b, a_033, b_034){
    if(a_033 === b_034) return 1;
    switch(a_033[0]){
      case 0:
       var a_035 = a_033[1];
       if(0 !== b_034[0]) return 0;
       var b_036 = b_034[1];
       return caml_call2(cmp_a, a_035, b_036);
      case 1:
       var a_037 = a_033[1];
       switch(b_034[0]){
         case 0: break;
         case 1:
          var b_038 = b_034[1]; return caml_call2(cmp_b, a_037, b_038);
         default: return 0;
       }
       break;
      default:
       var a_041 = a_033[2], a_039 = a_033[1];
       switch(b_034[0]){
         case 0: break;
         case 1:
          return 0;
         default:
          var
           b_042 = b_034[2],
           b_040 = b_034[1],
           _T_ = caml_call2(cmp_a, a_039, b_040);
          return _T_ ? caml_call2(cmp_b, a_041, b_042) : _T_;
       }
    }
    return 0;
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    switch(arg[0]){
      case 0:
       var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
       return caml_call2(hash_fold_a, hsv$0, a0);
      case 1:
       var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
       return caml_call2(hash_fold_b, hsv$1, a0$0);
      default:
       var
        a1 = arg[2],
        a0$1 = arg[1],
        hsv$2 = caml_call2(Base_Hash[3], hsv, 2),
        hsv$3 = caml_call2(hash_fold_a, hsv$2, a0$1);
       return caml_call2(hash_fold_b, hsv$3, a1);
    }
   }
   function t_of_sexp(of_a_053, of_b_054, sexp_059){
    a:
    {
     if(0 === sexp_059[0]){
      var _P_ = sexp_059[1];
      b:
      if(caml_string_notequal(_P_, cst_Both$0)){
       c:
       if(caml_string_notequal(_P_, cst_Left$0)){
        if(caml_string_notequal(_P_, cst_Right$0)){
         if(! caml_string_notequal(_P_, cst_both)) break b;
         if(! caml_string_notequal(_P_, cst_left)) break c;
         if(caml_string_notequal(_P_, cst_right)) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[9], error_source_057, sexp_059);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_057, sexp_059);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_057, sexp_059);
     }
     var _Q_ = sexp_059[1];
     if(! _Q_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_057, sexp_059);
     var _R_ = _Q_[1];
     if(0 !== _R_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_057, sexp_059);
     var tag_060 = _R_[1];
     b:
     if(caml_string_notequal(tag_060, cst_Both$0)){
      c:
      if(caml_string_notequal(tag_060, cst_Left$0)){
       if(caml_string_notequal(tag_060, cst_Right$0)){
        if(! caml_string_notequal(tag_060, cst_both)) break b;
        if(! caml_string_notequal(tag_060, cst_left)) break c;
        if(caml_string_notequal(tag_060, cst_right)) break a;
       }
       var sexp_args_066 = _Q_[2];
       if(sexp_args_066 && ! sexp_args_066[2]){
        var
         arg0_067 = sexp_args_066[1],
         res0_068 = caml_call1(of_b_054, arg0_067);
        return [1, res0_068];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[8],
                error_source_057,
                tag_060,
                sexp_059);
      }
      var sexp_args_061 = _Q_[2];
      if(sexp_args_061 && ! sexp_args_061[2]){
       var
        arg0_062 = sexp_args_061[1],
        res0_063 = caml_call1(of_a_053, arg0_062);
       return [0, res0_063];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_057,
               tag_060,
               sexp_059);
     }
     var sexp_args_071 = _Q_[2];
     if(sexp_args_071){
      var _S_ = sexp_args_071[2];
      if(_S_ && ! _S_[2]){
       var
        arg1_073 = _S_[1],
        arg0_072 = sexp_args_071[1],
        res0_074 = caml_call1(of_a_053, arg0_072),
        res1_075 = caml_call1(of_b_054, arg1_073);
       return [2, res0_074, res1_075];
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_057,
              tag_060,
              sexp_059);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_057, sexp_059);
   }
   function sexp_of_t$1(of_a_078, of_b_079, param){
    switch(param[0]){
      case 0:
       var arg0_080 = param[1], res0_081 = caml_call1(of_a_078, arg0_080);
       return [1, [0, _j_, [0, res0_081, 0]]];
      case 1:
       var arg0_082 = param[1], res0_083 = caml_call1(of_b_079, arg0_082);
       return [1, [0, _k_, [0, res0_083, 0]]];
      default:
       var
        arg1_085 = param[2],
        arg0_084 = param[1],
        res0_086 = caml_call1(of_a_078, arg0_084),
        res1_087 = caml_call1(of_b_079, arg1_085);
       return [1, [0, _l_, [0, res0_086, [0, res1_087, 0]]]];
    }
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Left, [0, [0, a_sexp_grammar, 0]]]],
              [0,
               [1, [0, cst_Right, [0, [0, b_sexp_grammar, 0]]]],
               [0,
                [1,
                 [0,
                  cst_Both,
                  [0, [0, a_sexp_grammar, [0, b_sexp_grammar, 0]]]]],
                0]]]]];
   }
   function merge_with_duplicates(param, _O_, compare){
    var next2 = _O_[2], s2 = _O_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [1, b], [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, [0, a], [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 <= comparison
               ? 0
                 === comparison
                 ? [1, [2, a, b$0], [0, [0, s1$1], [0, s2$3]]]
                 : [1, [1, b$0], [0, s1, [0, s2$3]]]
               : [1, [0, a], [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function merge_deduped_and_sorted(s1, s2, compare){
    function _N_(param){var x = param[1]; return x;}
    return caml_call2(map$0, merge_with_duplicates(s1, s2, compare), _N_);
   }
   function merge_sorted(param, _M_, compare){
    var next2 = _M_[2], s2 = _M_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, b, [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, a, [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 < comparison
               ? [1, b$0, [0, s1, [0, s2$3]]]
               : [1, a, [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function hd(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){var a = match[1]; return [0, a];}
     var s$1 = match[1], s$0 = s$1;
    }
   }
   function hd_exn(s){
    var match = hd(s);
    if(! match) return caml_call1(Base_Import[124], cst_hd_exn);
    var a = match[1];
    return a;
   }
   function tl(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      var match$0 = 0;
     else{
      if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
      var a = match[2], match$0 = [0, a];
     }
     if(! match$0) return 0;
     var s$3 = match$0[1];
     return [0, [0, s$3, next]];
    }
   }
   function tl_eagerly_exn(s){
    var match = tl(s);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_tl_exn);
    var s$0 = match[1];
    return s$0;
   }
   function lift_identity(next, s){
    var match = caml_call1(next, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, 316735838, s$0]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, 316735838, s$1]];
   }
   function next(s){
    var next = s[2], s$3 = s[1], s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){
      var s$2 = match[2], a = match[1];
      return [0, [0, a, [0, s$2, next]]];
     }
     var s$1 = match[1], s$0 = s$1;
    }
   }
   function filter_opt(s){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var match$0 = match[1];
             if(match$0){
              var s$1 = match[2], a = match$0[1];
              return [1, a, s$1];
             }
             var s$2 = match[2];
             return [0, s$2];
            }];
   }
   function filter_map(s, f){return filter_opt(caml_call2(map$0, s, f));}
   function filter_mapi(s, f){
    function _L_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return filter_map(mapi(s, function(i, s){return [0, i, s];}), _L_);
   }
   function split_n(s, n){
    var next = s[2], s$3 = s[1], s$0 = s$3, i = n, accum = 0;
    for(;;){
     if(0 >= i) return [0, caml_call1(Base_List1[19], accum), [0, s$0, next]];
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      return [0, caml_call1(Base_List1[19], accum), empty];
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else
      var
       s$2 = match[2],
       a = match[1],
       accum$0 = [0, a, accum],
       i$0 = caml_call2(Base_Import[93], i, 1),
       s$0 = s$2,
       i = i$0,
       accum = accum$0;
    }
   }
   function chunks_exn(t, n){
    return 0 < n
            ? [0,
              t,
              function(t){
               var match = split_n(t, n), xs = match[1];
               if(! xs) return 0;
               var t$0 = match[2];
               return [1, xs, t$0];
              }]
            : caml_call1(Base_Import[126], cst_Sequence_chunks_exn);
   }
   function findi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1], s = s$0;
     else{
      var a = match[1];
      if(caml_call2(f, i, a)) return [0, [0, i, a]];
      var
       s$1 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       s = s$1,
       i = i$0;
     }
    }
   }
   function find_exn(s, f){
    var match = find(s, f);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_find_exn);
    var x = match[1];
    return x;
   }
   function append(s1, s2){
    var next2 = s2[2], s2$0 = s2[1], next1 = s1[2], s1$0 = s1[1];
    return [0,
            [0, 472258093, s1$0],
            function(param){
             if(472258093 <= param[1]){
              var s1 = param[2], match = caml_call1(next1, s1);
              if(typeof match === "number") return [0, [0, -630817751, s2$0]];
              if(0 === match[0]){
               var s1$0 = match[1];
               return [0, [0, 472258093, s1$0]];
              }
              var s1$1 = match[2], a = match[1];
              return [1, a, [0, 472258093, s1$1]];
             }
             var s2 = param[2], match$0 = caml_call1(next2, s2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s2$1 = match$0[1];
              return [0, [0, -630817751, s2$1]];
             }
             var s2$2 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, -630817751, s2$2]];
            }];
   }
   function concat_map(s, f){return caml_call2(bind$0, s, f);}
   function concat(s){return concat_map(s, function(_K_){return _K_;});}
   function concat_mapi(s, f){
    function _J_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return concat_map(mapi(s, function(i, s){return [0, i, s];}), _J_);
   }
   function zip(param, _H_){
    var next2 = _H_[2], s2 = _H_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var _I_ = param[1];
     if(typeof _I_ !== "number"){
      if(1 === _I_[0]){
       var match = param[2], s1$0 = _I_[2], a = _I_[1];
       if(typeof match !== "number"){
        if(0 === match[0]){
         var s2$0 = param[2][1];
         return [0, [0, _I_, caml_call1(next2, s2$0)]];
        }
        var s2$1 = match[2], b = match[1];
        return [1, [0, a, b], [0, [0, s1$0], [0, s2$1]]];
       }
      }
      if(typeof param[2] !== "number"){
       var s2 = param[2], s1 = _I_[1];
       return [0, [0, caml_call1(next1, s1), s2]];
      }
     }
     return 0;
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function zip_full(param, _G_){
    var next2 = _G_[2], s2 = _G_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [0, -57574468, b], [0, 0, caml_call1(next2, s2$0)]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var match$0 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof match$0 === "number")
       return [1, [0, 847852583, a], [0, caml_call1(next1, s1$1), 0]];
      if(0 !== match$0[0]){
       var s2$2 = match$0[2], b$0 = match$0[1];
       return [1, [0, 737457313, [0, a, b$0]], [0, [0, s1$1], [0, s2$2]]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function bounded_length(param, at_most){
    var next = param[2], seed = param[1], i = 0, seed$0 = seed;
    for(;;){
     if(at_most < i) return 85047514;
     var match = caml_call1(next, seed$0);
     if(typeof match === "number") return [0, 16394, i];
     if(0 === match[0])
      var seed$1 = match[1], seed$0 = seed$1;
     else
      var
       seed$2 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       i = i$0,
       seed$0 = seed$2;
    }
   }
   function length_is_bounded_by(opt, max, t){
    if(opt) var sth = opt[1], min = sth; else var min = -1;
    if(max){
     var max$0 = max[1], match$0 = bounded_length(t, max$0);
     if(typeof match$0 !== "number" && 16394 === match$0[1]){var len = match$0[2]; if(min <= len) return 1;}
     return 0;
    }
    var next = t[2], s = t[1], s$0 = s, acc = 0;
    for(;;){
     if(min <= acc) return 1;
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else
      var
       s$2 = match[2],
       acc$0 = caml_call2(Base_Import[91], acc, 1),
       s$0 = s$2,
       acc = acc$0;
    }
   }
   function iteri(s, f){
    function _F_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return iter(mapi(s, function(i, s){return [0, i, s];}), _F_);
   }
   function foldi(s, init, f){
    function _E_(acc, param){
     var s = param[2], i = param[1];
     return caml_call3(f, i, acc, s);
    }
    return fold(mapi(s, function(i, s){return [0, i, s];}), init, _E_);
   }
   function reduce(s, f){
    var match = next(s);
    if(! match) return 0;
    var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
    return [0, fold(s$0, a, f)];
   }
   function reduce_exn(s, f){
    var match = reduce(s, f);
    if(! match) return caml_call1(Base_Import[124], cst_Sequence_reduce_exn);
    var res = match[1];
    return res;
   }
   function group(param, break$0){
    var next = param[2], s = param[1];
    return [0,
            [0, [0, 0, s]],
            function(param){
             if(! param) return 0;
             var
              match = param[1],
              s = match[2],
              acc = match[1],
              match$0 = caml_call1(next, s);
             if(typeof match$0 !== "number" && 0 === match$0[0]){
              var s$2 = match$0[1];
              return [0, [0, [0, acc, s$2]]];
             }
             if(acc){
              if(typeof match$0 === "number")
               return [1, caml_call1(Base_List1[19], acc), 0];
              var s$0 = match$0[2], cur = match$0[1], prev = acc[1];
              return caml_call2(break$0, prev, cur)
                      ? [1,
                        caml_call1(Base_List1[19], acc),
                        [0, [0, [0, cur, 0], s$0]]]
                      : [0, [0, [0, [0, cur, acc], s$0]]];
             }
             if(typeof match$0 === "number") return 0;
             var s$1 = match$0[2], cur$0 = match$0[1];
             return [0, [0, [0, [0, cur$0, 0], s$1]]];
            }];
   }
   function find_consecutive_duplicate(param, equal){
    var next = param[2], s = param[1], last_elt = 0, s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], a = match[1];
      if(last_elt){
       var b = last_elt[1];
       if(caml_call2(equal, a, b)) return [0, [0, b, a]];
      }
      var last_elt$0 = [0, a], last_elt = last_elt$0, s$0 = s$2;
     }
    }
   }
   function remove_consecutive_duplicates(s, equal){
    return unfold_with
            (s,
             0,
             function(prev, a){
              if(prev){
               var b = prev[1];
               if(caml_call2(equal, a, b)) return [0, [0, a]];
              }
              return [1, a, [0, a]];
             });
   }
   function count(s, f){
    return fold
            (s,
             0,
             function(acc, elt){
              var
               _C_ = caml_call1(f, elt),
               _D_ = caml_call1(Base_Bool[31], _C_);
              return caml_call2(Base_Import[91], acc, _D_);
             });
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(i, acc, elt){
              var
               _A_ = caml_call2(f, i, elt),
               _B_ = caml_call1(Base_Bool[31], _A_);
              return caml_call2(Base_Import[91], acc, _B_);
             });
   }
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function init(n, f){
    return [0,
            0,
            function(i){
             if(n <= i) return 0;
             var _z_ = caml_call2(Base_Import[91], i, 1);
             return [1, caml_call1(f, i), _z_];
            }];
   }
   function sub(s, pos, len){
    var _x_ = pos < 0 ? 1 : 0, _y_ = _x_ || (len < 0 ? 1 : 0);
    if(_y_) caml_call1(Base_Import[124], cst_Sequence_sub);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= caml_call2(Base_Import[93], i, pos)) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(pos <= i)
              return [1, a, [0, caml_call2(Base_Import[91], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[91], i, 1), s$2]];
            }];
   }
   function take(s, len){
    if(len < 0) caml_call1(Base_Import[124], cst_Sequence_take);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= i) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var s$1 = match[2], a = match[1];
             return [1, a, [0, caml_call2(Base_Import[91], i, 1), s$1]];
            }];
   }
   function drop(s, len){
    if(len < 0) caml_call1(Base_Import[124], cst_Sequence_drop);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(len <= i)
              return [1, a, [0, caml_call2(Base_Import[91], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[91], i, 1), s$2]];
            }];
   }
   function take_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var a = match[1], s$1 = match[2];
             return caml_call1(f, a) ? [1, a, s$1] : 0;
            }];
   }
   function drop_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -557110719, s$0],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var s$0 = param[2], match = caml_call1(next, s$0);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$1 = match[1];
              return [0, [0, -557110719, s$1]];
             }
             var a = match[1], s$2 = match[2];
             if(caml_call1(f, a)) return [0, [0, -557110719, s$2]];
             var s$3 = match[2];
             return [1, a, [0, 316735838, s$3]];
            }];
   }
   function shift_right(s, x){
    var next = s[2], seed = s[1];
    return [0,
            [0, -433944719, [0, seed, x]],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var match = param[2], x = match[2], seed = match[1];
             return [1, x, [0, 316735838, seed]];
            }];
   }
   function shift_right_with_list(s, l){return append(of_list(l), s);}
   var Infix = [0, append];
   function intersperse(s, sep){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 815032112, s$0],
            function(param){
             var _w_ = param[1];
             if(815032112 === _w_){
              var s = param[2], match = caml_call1(next, s);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var s$0 = match[1];
               return [0, [0, 815032112, s$0]];
              }
              var s$1 = match[2], a = match[1];
              return [1, a, [0, 951752159, s$1]];
             }
             if(951752159 > _w_){
              var match$1 = param[2], s$5 = match$1[2], a$1 = match$1[1];
              return [1, a$1, [0, 951752159, s$5]];
             }
             var s$2 = param[2], match$0 = caml_call1(next, s$2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s$3 = match$0[1];
              return [0, [0, 951752159, s$3]];
             }
             var s$4 = match$0[2], a$0 = match$0[1];
             return [1, sep, [0, -571577571, [0, a$0, s$4]]];
            }];
   }
   function repeat(x){return [0, x, function(x){return [1, x, x];}];}
   function cycle_list_exn(xs){
    if(caml_call1(Base_List1[22], xs))
     caml_call1(Base_Import[126], cst_Sequence_cycle_list_exn);
    var s = of_list(xs);
    function _v_(param){return s;}
    return concat_map(repeat(0), _v_);
   }
   function cartesian_product(sa, sb){
    return concat_map(sa, function(a){return zip(repeat(a), sb);});
   }
   function singleton(x){return caml_call1(return$1, x);}
   function delayed_fold(s, init, f, finish){
    return delayed_fold_step
            (s,
             init,
             function(acc, option, k){
              if(! option) return caml_call1(k, acc);
              var a = option[1];
              return caml_call3(f, acc, a, k);
             },
             finish);
   }
   function fold_m(bind, return$0, t, init, f){
    return delayed_fold_step
            (t,
             init,
             function(acc, option, k){
              if(! option)
               return caml_call2(bind, caml_call1(return$0, acc), k);
              var a = option[1];
              return caml_call2(bind, caml_call2(f, acc, a), k);
             },
             return$0);
   }
   function iter_m(bind, return$0, t, f){
    return delayed_fold_step
            (t,
             0,
             function(param, option, k){
              if(! option)
               return caml_call2(bind, caml_call1(return$0, 0), k);
              var a = option[1];
              return caml_call2(bind, caml_call1(f, a), k);
             },
             return$0);
   }
   function fold_until(s, init, f, finish){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], a = match[1], match$0 = caml_call2(f, acc, a);
      if(0 !== match$0[0]){var x = match$0[1]; return x;}
      var acc$0 = match$0[1], s$0 = s$2, acc = acc$0;
     }
    }
   }
   function fold_result(s, init, f){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(Base_Result[15], acc);
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], a = match[1], e = caml_call2(f, acc, a);
      if(0 !== e[0]) return e;
      var acc$0 = e[1], s$0 = s$2, acc = acc$0;
     }
    }
   }
   function force_eagerly(t){return of_list(to_list(t));}
   function memoize(param){
    var next = param[2], s = param[1];
    function memoize(s){
     return [0,
             [246,
              function(_u_){
               var s$0 = s;
               for(;;){
                var match = caml_call1(next, s$0);
                if(typeof match === "number") return 0;
                if(0 !== match[0]){
                 var s$2 = match[2], a = match[1];
                 return [1, a, memoize(s$2)];
                }
                var s$1 = match[1], s$0 = s$1;
               }
              }]];
    }
    function _s_(param){
     var l = param[1], _t_ = caml_obj_tag(l);
     if(250 === _t_) return l[1];
     if(246 !== _t_ && 244 !== _t_) return l;
     return caml_call1(CamlinternalLazy[2], l);
    }
    return [0, memoize(s), _s_];
   }
   function drop_eagerly(s, len){
    var next = s[2], s$3 = s[1], i = 0, s$0 = s$3;
    for(;;){
     if(len <= i) return [0, s$0, next];
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return empty;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else
      var
       s$2 = match[2],
       i$0 = caml_call2(Base_Import[91], i, 1),
       i = i$0,
       s$0 = s$2;
    }
   }
   function drop_while_option(param, f){
    var next = param[2], s = param[1], s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$1 = match[1], s$0 = s$1;
     else{
      var s$2 = match[2], x = match[1];
      if(! caml_call1(f, x)) return [0, [0, x, [0, s$2, next]]];
      var s$0 = s$2;
     }
    }
   }
   function skip_loop(s, next){
    var s$0 = s;
    for(;;){
     var next$0 = caml_call1(next, s$0);
     if(typeof next$0 !== "number" && 0 === next$0[0]){var state = next$0[1], s$0 = state; continue;}
     return next$0;
    }
   }
   function compare$0(compare_a, param, r){
    var
     next_r = r[2],
     s_r$1 = r[1],
     next_l = param[2],
     s_l$1 = param[1],
     s_l = s_l$1,
     s_r = s_r$1;
    for(;;){
     var l = skip_loop(s_l, next_l), r$0 = skip_loop(s_r, next_r);
     if(typeof l === "number"){
      if(typeof r$0 === "number") return 0;
      if(1 === r$0[0]) return -1;
     }
     else if(1 === l[0]){
      if(typeof r$0 === "number") return 1;
      if(1 === r$0[0]){
       var c = caml_call2(compare_a, l[1], r$0[1]);
       if(0 !== c) return c;
       var s_r$0 = r$0[2], s_l$0 = l[2], s_l = s_l$0, s_r = s_r$0;
       continue;
      }
     }
     return caml_call1(Base_Import[124], cst_Bug_This_branch_should_be_);
    }
   }
   function compare_local$0(compare_a_local, t1, t2){
    var _q_ = globalize(0, t2), _r_ = globalize(0, t1);
    return compare$0
            (function(x, y){return caml_call2(compare_a_local, x, y);},
             _r_,
             _q_);
   }
   function equal$0(equal_a, t1, t2){
    function _p_(param){
     if(737457313 !== param[1]) return 0;
     var match = param[2], a2 = match[2], a1 = match[1];
     return caml_call2(equal_a, a1, a2);
    }
    return for_all(zip_full(t1, t2), _p_);
   }
   function equal_local$0(equal_a_local, t1, t2){
    var _n_ = globalize(0, t2), _o_ = globalize(0, t1);
    return equal$0
            (function(x, y){return caml_call2(equal_a_local, x, y);},
             _o_,
             _n_);
   }
   function round_robin(list){
    function next(param){
     var done_stack = param[2], todo_stack = param[1];
     if(! todo_stack)
      return caml_call1(Base_List1[22], done_stack)
              ? 0
              : [0, [0, caml_call1(Base_List1[19], done_stack), 0]];
     var
      todo_stack$0 = todo_stack[2],
      match = todo_stack[1],
      f = match[2],
      s = match[1],
      match$0 = caml_call1(f, s);
     if(typeof match$0 === "number")
      return [0, [0, todo_stack$0, done_stack]];
     if(0 === match$0[0]){
      var s$0 = match$0[1];
      return [0, [0, [0, [0, s$0, f], todo_stack$0], done_stack]];
     }
     var s$1 = match$0[2], x = match$0[1];
     return [1, x, [0, todo_stack$0, [0, [0, s$1, f], done_stack]]];
    }
    var state = [0, list, 0];
    return [0, state, next];
   }
   function interleave(param){
    var f1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[3], done_stack = param[2], todo_stack = param[1];
     if(todo_stack){
      var
       todo_stack$0 = todo_stack[2],
       match = todo_stack[1],
       f2 = match[2],
       s2 = match[1],
       match$0 = caml_call1(f2, s2);
      if(typeof match$0 === "number")
       return [0, [0, todo_stack$0, done_stack, s1]];
      if(0 === match$0[0]){
       var s2$0 = match$0[1];
       return [0, [0, todo_stack$0, [0, [0, s2$0, f2], done_stack], s1]];
      }
      var s2$1 = match$0[2], x = match$0[1];
      return [1, x, [0, todo_stack$0, [0, [0, s2$1, f2], done_stack], s1]];
     }
     var match$1 = caml_call1(f1, s1);
     if(typeof match$1 === "number")
      return done_stack
              ? [0, [0, caml_call1(Base_List1[19], done_stack), 0, s1]]
              : 0;
     if(0 === match$1[0]){
      var s1$0 = match$1[1];
      return [0, [0, caml_call1(Base_List1[19], done_stack), 0, s1$0]];
     }
     var s1$1 = match$1[2], t = match$1[1];
     return [0, [0, caml_call1(Base_List1[19], [0, t, done_stack]), 0, s1$1]];
    }
    var state = [0, 0, 0, s1];
    return [0, state, next];
   }
   function interleaved_cartesian_product(s1, s2){
    return interleave
            (caml_call2
              (map$0,
               s1,
               function(x1){
                return caml_call2
                        (map$0, s2, function(x2){return [0, x1, x2];});
               }));
   }
   function of_seq(seq){
    return [0,
            seq,
            function(seq){
             var match = caml_call1(seq, 0);
             if(! match) return 0;
             var tl = match[2], hd = match[1];
             return [1, hd, tl];
            }];
   }
   function to_seq(param){
    var next = param[2], state = param[1];
    function loop(state){
     var state$0 = state;
     for(;;){
      var match = caml_call1(next, state$0);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var state$2 = match[2], hd = match[1];
       return [0, hd, function(param){return loop(state$2);}];
      }
      var state$1 = match[1], state$0 = state$1;
     }
    }
    return function(param){return loop(state);};
   }
   function return$2(x, k){return caml_call1(k, x);}
   function bind$1(m, f, k){
    return caml_call1
            (m,
             function(a){var m = caml_call1(f, a); return caml_call1(m, k);});
   }
   var
    map$1 =
      [0,
       -198771759,
       function(m, f, k){
        return caml_call1
                (m, function(a){return caml_call1(k, caml_call1(f, a));});
       }],
    include$0 = caml_call1(Base_Monad[2], [0, bind$1, map$1, return$2]),
    symbol_bind$0 = include$0[1],
    symbol_map$0 = include$0[2],
    Let_syntax$0 = include$0[3],
    Monad_infix$0 = include$0[4],
    bind$2 = include$0[5],
    return$3 = include$0[6],
    map$2 = include$0[7],
    join$0 = include$0[8],
    ignore_m$0 = include$0[9],
    all$0 = include$0[10],
    all_unit$0 = include$0[11];
   function yield$0(e, k){return [0, [1, e, k]];}
   function of_sequence(sequence){
    return delayed_fold
            (sequence,
             0,
             function(param, x, k, f){
              return [0, [1, x, function(param){return caml_call2(k, 0, f);}]];
             },
             return$3);
   }
   function run(t){
    function init(param){return caml_call1(t, function(param){return _m_;});}
    function f(thunk){return caml_call1(thunk, 0)[1];}
    return [0, init, f];
   }
   var
    Base_Sequence =
      [0,
       globalize,
       sexp_of_t$0,
       equal$0,
       equal_local$0,
       compare$0,
       compare_local$0,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       counti,
       findi,
       find_mapi,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       empty,
       next,
       Step,
       unfold_step,
       unfold,
       unfold_with,
       unfold_with_and_finish,
       nth,
       nth_exn,
       folding_map,
       folding_mapi,
       mapi,
       filteri,
       filter,
       merge_deduped_and_sorted,
       merge_sorted,
       [0,
        compare,
        compare_local,
        equal,
        equal_local,
        hash_fold_t,
        t_of_sexp,
        sexp_of_t$1,
        t_sexp_grammar],
       merge_with_duplicates,
       hd,
       hd_exn,
       tl,
       tl_eagerly_exn,
       find_exn,
       for_alli,
       append,
       concat,
       concat_map,
       concat_mapi,
       interleave,
       round_robin,
       zip,
       zip_full,
       reduce_exn,
       reduce,
       group,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       range,
       init,
       filter_map,
       filter_mapi,
       filter_opt,
       sub,
       take,
       drop,
       drop_eagerly,
       take_while,
       drop_while,
       drop_while_option,
       split_n,
       chunks_exn,
       shift_right,
       shift_right_with_list,
       drop,
       Infix,
       cartesian_product,
       interleaved_cartesian_product,
       intersperse,
       cycle_list_exn,
       repeat,
       singleton,
       delayed_fold,
       fold_m,
       iter_m,
       to_list_rev,
       of_list,
       of_lazy,
       memoize,
       force_eagerly,
       bounded_length,
       length_is_bounded_by,
       of_seq,
       to_seq,
       [0,
        symbol_bind$0,
        symbol_map$0,
        Let_syntax$0,
        Monad_infix$0,
        bind$2,
        return$3,
        map$2,
        join$0,
        ignore_m$0,
        all$0,
        all_unit$0,
        yield$0,
        of_sequence,
        run],
       [0, next_step, delayed_fold_step, T, view]];
   runtime.caml_register_global(51, Base_Sequence, "Base__Sequence");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexpable
//# unitInfo: Requires: Base__Import, Sexplib0__Sexp_grammar, Sexplib0__Sexpable
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    cst_Sexpable_Of_stringable_t_o =
      "Sexpable.Of_stringable.t_of_sexp expected an atom, but got a list";
   function Of_sexpable(Sexpable, M){
    function t_of_sexp(sexp){
     var s = caml_call1(Sexpable[1], sexp);
     try{var _i_ = caml_call1(M[2], s); return _i_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[157], exn, sexp);
     }
    }
    function sexp_of_t(t){
     var _h_ = caml_call1(M[1], t);
     return caml_call1(Sexpable[2], _h_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable1(Sexpable, M){
    function t_of_sexp(a_of_sexp, sexp){
     var s = caml_call2(Sexpable[1], a_of_sexp, sexp);
     try{var _g_ = caml_call1(M[2], s); return _g_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[157], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, t){
     var _f_ = caml_call1(M[1], t);
     return caml_call2(Sexpable[2], sexp_of_a, _f_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable2(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, sexp){
     var s = caml_call3(Sexpable[1], a_of_sexp, b_of_sexp, sexp);
     try{var _e_ = caml_call1(M[2], s); return _e_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[157], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, t){
     var _d_ = caml_call1(M[1], t);
     return caml_call3(Sexpable[2], sexp_of_a, sexp_of_b, _d_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable3(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
     var s = caml_call4(Sexpable[1], a_of_sexp, b_of_sexp, c_of_sexp, sexp);
     try{var _c_ = caml_call1(M[2], s); return _c_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[157], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, sexp_of_c, t){
     var _b_ = caml_call1(M[1], t);
     return caml_call4(Sexpable[2], sexp_of_a, sexp_of_b, sexp_of_c, _b_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_stringable(M){
    function t_of_sexp(sexp){
     if(0 !== sexp[0])
      return caml_call2
              (Base_Import[156], cst_Sexpable_Of_stringable_t_o, sexp);
     var s = sexp[1];
     try{var _a_ = caml_call1(M[1], s); return _a_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[157], exn, sexp);
     }
    }
    function sexp_of_t(t){return [0, caml_call1(M[2], t)];}
    var
     t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_Import[182]);
    return [0, t_sexp_grammar, t_of_sexp, sexp_of_t];
   }
   var
    Base_Sexpable =
      [0,
       Of_sexpable,
       Of_sexpable1,
       Of_sexpable2,
       Of_sexpable3,
       Of_stringable];
   runtime.caml_register_global(3, Base_Sexpable, "Base__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array
//# unitInfo: Requires: Base__Array0, Base__Array_permute, Base__Binary_searchable, Base__Blit, Base__Bool, Base__Container, Base__Import, Base__List, Base__Option, Base__Ordered_collection_common, Base__Random, Base__Sequence
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_array_ml = "src/array.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Sequence = global_data.Base__Sequence,
    Base_Random = global_data.Base__Random,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Bool = global_data.Base__Bool,
    Base_Container = global_data.Base__Container,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Base_Binary_searchable = global_data.Base__Binary_searchable,
    Base_Blit = global_data.Base__Blit,
    invalid_argf = Base_Array0[1],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_local = Base_Array0[5],
    create_float_uninitialized = Base_Array0[6],
    append = Base_Array0[7],
    concat = Base_Array0[9],
    copy = Base_Array0[10],
    fill = Base_Array0[11],
    init = Base_Array0[12],
    make_matrix = Base_Array0[13],
    of_list = Base_Array0[14],
    sub = Base_Array0[15],
    to_list = Base_Array0[16],
    fold = Base_Array0[17],
    fold_right = Base_Array0[18],
    iter = Base_Array0[19],
    iteri = Base_Array0[20],
    map = Base_Array0[21],
    mapi = Base_Array0[22],
    stable_sort = Base_Array0[23],
    swap = Base_Array0[24],
    compare_local = Base_Import[263],
    compare = Base_Import[235],
    globalize = Base_Import[291],
    t_of_sexp = Base_Import[174],
    sexp_of_t = Base_Import[150],
    _g_ = [0, cst_src_array_ml, 917, 6],
    cst_Array_transpose_exn = "Array.transpose_exn",
    cst_Array_zip_exn = "Array.zip_exn",
    cst_Array_random_element_exn_e = "Array.random_element_exn: empty array",
    cst_Array_reduce_exn = "Array.reduce_exn",
    _d_ = [0, "Array.find_exn: not found"],
    _c_ = [0, "Array.findi_exn: not found"],
    cst_Array_for_all2_exn = "Array.for_all2_exn",
    cst_Array_exists2_exn = "Array.exists2_exn",
    cst_Array_fold2_exn = "Array.fold2_exn",
    cst_Array_map2_exn = "Array.map2_exn",
    cst_Array_iter2_exn = "Array.iter2_exn",
    _b_ =
      [0,
       [11,
        "length mismatch in ",
        [2, 0, [11, ": ", [4, 0, 0, 0, [11, " <> ", [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    _a_ = [0, cst_src_array_ml, 486, 14],
    _e_ = [0, "Array.find_map_exn: not found"],
    _f_ = [0, "Array.find_mapi_exn: not found"];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[195], a_sexp_grammar);
   }
   function Sorter(S){
    var get = S[1], set = S[2], length = S[3];
    function swap(arr, i, j){
     var tmp = caml_call2(get, arr, i);
     caml_call3(set, arr, i, caml_call2(get, arr, j));
     return caml_call3(set, arr, j, tmp);
    }
    function sort(arr, compare, left, right){
     var _a0_ = caml_call2(Base_Import[91], left, 1);
     if(right >= _a0_){
      var pos = _a0_;
      for(;;){
       var v = caml_call2(get, arr, pos), final_pos = pos;
       for(;;){
        var i_next = caml_call2(Base_Import[93], final_pos, 1);
        if(left > i_next) break;
        if(0 >= caml_call2(compare, caml_call2(get, arr, i_next), v)) break;
        caml_call3(set, arr, final_pos, caml_call2(get, arr, i_next));
        var final_pos = i_next;
       }
       caml_call3(set, arr, final_pos, v);
       var _a1_ = pos + 1 | 0;
       if(right === pos) break;
       var pos = _a1_;
      }
     }
     return 0;
    }
    var Insertion_sort = [0, sort];
    function heapify(arr, compare, root, left, right){
     var root$0 = root;
     for(;;){
      var
       relative_root = caml_call2(Base_Import[93], root$0, left),
       _aT_ = caml_call2(Base_Import[88], 2, relative_root),
       _aU_ = caml_call2(Base_Import[91], _aT_, left),
       left_child = caml_call2(Base_Import[91], _aU_, 1),
       _aV_ = caml_call2(Base_Import[88], 2, relative_root),
       _aW_ = caml_call2(Base_Import[91], _aV_, left),
       right_child = caml_call2(Base_Import[91], _aW_, 2);
      a:
      {
       if(left_child <= right){
        var _aX_ = caml_call2(get, arr, root$0);
        if(0 < caml_call2(compare, caml_call2(get, arr, left_child), _aX_)){var largest = left_child; break a;}
       }
       var largest = root$0;
      }
      a:
      {
       if(right_child <= right){
        var _aY_ = caml_call2(get, arr, largest);
        if(0 < caml_call2(compare, caml_call2(get, arr, right_child), _aY_)){var largest$0 = right_child; break a;}
       }
       var largest$0 = largest;
      }
      var _aZ_ = largest$0 !== root$0 ? 1 : 0;
      if(! _aZ_) return _aZ_;
      swap(arr, root$0, largest$0);
      var root$0 = largest$0;
     }
    }
    function sort$0(arr, compare, left, right){
     var
      _aO_ = caml_call2(Base_Import[91], left, right),
      _aP_ = caml_call2(Base_Import[95], _aO_, 2);
     if(_aP_ >= left){
      var i = _aP_;
      for(;;){
       heapify(arr, compare, i, left, right);
       var _aQ_ = i - 1 | 0;
       if(left === i) break;
       var i = _aQ_;
      }
     }
     var _aR_ = caml_call2(Base_Import[91], left, 1);
     if(right >= _aR_){
      var i$0 = right;
      for(;;){
       swap(arr, left, i$0);
       heapify(arr, compare, left, left, caml_call2(Base_Import[93], i$0, 1));
       var _aS_ = i$0 - 1 | 0;
       if(_aR_ === i$0) break;
       var i$0 = _aS_;
      }
     }
     return 0;
    }
    var Heap_sort = [0, sort$0];
    function five_element_sort(arr, compare, m1, m2, m3, m4, m5){
     function compare_and_swap(i, j){
      var
       _aM_ = caml_call2(get, arr, j),
       _aN_ = 0 < caml_call2(compare, caml_call2(get, arr, i), _aM_) ? 1 : 0;
      return _aN_ ? swap(arr, i, j) : _aN_;
     }
     compare_and_swap(m1, m2);
     compare_and_swap(m4, m5);
     compare_and_swap(m1, m3);
     compare_and_swap(m2, m3);
     compare_and_swap(m1, m4);
     compare_and_swap(m3, m4);
     compare_and_swap(m2, m5);
     compare_and_swap(m2, m3);
     return compare_and_swap(m4, m5);
    }
    function intro_sort(arr, max_depth, compare, left, right){
     var max_depth$0 = max_depth, left$0 = left;
     for(;;){
      var
       _aL_ = caml_call2(Base_Import[93], right, left$0),
       len = caml_call2(Base_Import[91], _aL_, 1);
      if(32 >= len)
       return caml_call4(Insertion_sort[1], arr, compare, left$0, right);
      if(0 > max_depth$0)
       return caml_call4(Heap_sort[1], arr, compare, left$0, right);
      var
       max_depth$1 = caml_call2(Base_Import[93], max_depth$0, 1),
       _aK_ = caml_call2(Base_Import[93], right, left$0),
       sixth = caml_call2(Base_Import[95], _aK_, 6),
       m1 = caml_call2(Base_Import[91], left$0, sixth),
       m2 = caml_call2(Base_Import[91], m1, sixth),
       m3 = caml_call2(Base_Import[91], m2, sixth),
       m4 = caml_call2(Base_Import[91], m3, sixth),
       m5 = caml_call2(Base_Import[91], m4, sixth);
      five_element_sort(arr, compare, m1, m2, m3, m4, m5);
      var
       m2_val = caml_call2(get, arr, m2),
       m3_val = caml_call2(get, arr, m3),
       m4_val = caml_call2(get, arr, m4),
       match =
         0 === caml_call2(compare, m2_val, m3_val)
          ? [0, m2_val, m3_val, 1]
          : 0
            === caml_call2(compare, m3_val, m4_val)
            ? [0, m3_val, m4_val, 1]
            : [0, m2_val, m4_val, 0],
       middle_sorted = match[3],
       pivot2 = match[2],
       pivot1 = match[1],
       l$0 = left$0,
       p$1 = left$0,
       r$2 = right;
      for(;;){
       if(r$2 < p$1) break;
       var pv = caml_call2(get, arr, p$1);
       if(0 <= caml_call2(compare, pv, pivot1))
        if(0 < caml_call2(compare, pv, pivot2)){
         var r = r$2;
         for(;;){
          if(p$1 >= r) break;
          if(0 >= caml_call2(compare, caml_call2(get, arr, r), pivot2)) break;
          var r$0 = caml_call2(Base_Import[93], r, 1), r = r$0;
         }
         swap(arr, r, p$1);
         var r$1 = caml_call2(Base_Import[93], r, 1), r$2 = r$1;
        }
        else
         var p = caml_call2(Base_Import[91], p$1, 1), p$1 = p;
       else{
        swap(arr, p$1, l$0);
        var
         p$0 = caml_call2(Base_Import[91], p$1, 1),
         l = caml_call2(Base_Import[91], l$0, 1),
         l$0 = l,
         p$1 = p$0;
       }
      }
      intro_sort
       (arr,
        max_depth$1,
        compare,
        left$0,
        caml_call2(Base_Import[93], l$0, 1));
      if(1 - middle_sorted) intro_sort(arr, max_depth$1, compare, l$0, r$2);
      var
       left$1 = caml_call2(Base_Import[91], r$2, 1),
       max_depth$0 = max_depth$1,
       left$0 = left$1;
     }
    }
    function sort$1(arr, compare, left, right){
     return intro_sort(arr, 32, compare, left, right);
    }
    var Intro_sort = [0, sort$1, five_element_sort];
    function sort$2(pos, len, arr, compare){
     var
      _aH_ = caml_call1(length, arr),
      match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _aH_),
      len$0 = match[2],
      pos$0 = match[1],
      _aI_ = caml_call2(Base_Import[91], pos$0, len$0),
      _aJ_ = caml_call2(Base_Import[93], _aI_, 1);
     return caml_call4(Intro_sort[1], arr, compare, pos$0, _aJ_);
    }
    return [0, , , , , Insertion_sort, Heap_sort, Intro_sort, sort$2];
   }
   function get(_aG_, _aF_){return _aG_[1 + _aF_];}
   function set(_aE_, _aD_, _aC_){_aE_[1 + _aD_] = _aC_; return 0;}
   function length(_aB_){return _aB_.length - 1;}
   var Sort = Sorter([0, get, set, length]), sort = Sort[8];
   function of_array(t){return t;}
   function to_array(t){return t;}
   function is_empty(t){return 0 === t.length - 1 ? 1 : 0;}
   function is_sorted(t, compare){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[93], i[1], 1)];
      if(0 < caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function is_sorted_strictly(t, compare){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[93], i[1], 1)];
      if(0 <= caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function merge(a1, a2, compare){
    var l1 = a1.length - 1, l2 = a2.length - 1;
    if(0 === l1) return caml_call1(copy, a2);
    if(0 === l2) return caml_call1(copy, a1);
    var _aw_ = a1[1 + caml_call2(Base_Import[93], l1, 1)];
    if(0 <= caml_call2(compare, a2[1], _aw_))
     return caml_call2(append, a1, a2);
    var _ax_ = a2[1 + caml_call2(Base_Import[93], l2, 1)];
    if(0 < caml_call2(compare, a1[1], _ax_))
     return caml_call2(append, a2, a1);
    var
     len = caml_call2(Base_Import[91], l1, l2),
     merged = caml_call2(create, len, a1[1]),
     a1_index = [0, 0],
     a2_index = [0, 0],
     _az_ = caml_call2(Base_Import[93], len, 1),
     _ay_ = 0;
    if(_az_ >= 0){
     var i = _ay_;
     for(;;){
      var
       use_a1 =
         l1 === a1_index[1]
          ? 0
          : l2
            === a2_index[1]
            ? 1
            : caml_call2
               (compare, a1[1 + a1_index[1]], a2[1 + a2_index[1]])
              <= 0
              ? 1
              : 0;
      if(use_a1){
       merged[1 + i] = a1[1 + a1_index[1]];
       a1_index[1] = caml_call2(Base_Import[91], a1_index[1], 1);
      }
      else{
       merged[1 + i] = a2[1 + a2_index[1]];
       a2_index[1] = caml_call2(Base_Import[91], a2_index[1], 1);
      }
      var _aA_ = i + 1 | 0;
      if(_az_ === i) break;
      var i = _aA_;
     }
    }
    return merged;
   }
   function copy_matrix(_av_){return caml_call2(map, _av_, copy);}
   function folding_map(t, init, f){
    var acc = [0, init];
    return caml_call2
            (map,
             t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (map,
         t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return caml_call5(Base_Container[9], fold, init, f, finish, t);
   }
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function extremal_element(t, compare, keep_left_if){
    if(is_empty(t)) return 0;
    var
     result = [0, t[1]],
     _as_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _ar_ = 1;
    if(_as_ >= 1){
     var i = _ar_;
     for(;;){
      var x = t[1 + i], _at_ = result[1];
      result[1] =
       runtime.caml_csel_value
        (caml_call1(keep_left_if, caml_call2(compare, x, result[1])), x, _at_);
      var _au_ = i + 1 | 0;
      if(_as_ === i) break;
      var i = _au_;
     }
    }
    return [0, result[1]];
   }
   function min_elt(t, compare){
    return extremal_element
            (t,
             compare,
             function(compare_result){return compare_result < 0 ? 1 : 0;});
   }
   function max_elt(t, compare){
    return extremal_element
            (t,
             compare,
             function(compare_result){return 0 < compare_result ? 1 : 0;});
   }
   function foldi(t, init, f){
    var
     acc = [0, init],
     _ap_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _ao_ = 0;
    if(_ap_ >= 0){
     var i = _ao_;
     for(;;){
      acc[1] = caml_call3(f, i, acc[1], t[1 + i]);
      var _aq_ = i + 1 | 0;
      if(_ap_ === i) break;
      var i = _aq_;
     }
    }
    return acc[1];
   }
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return caml_call2
            (mapi,
             t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (mapi,
         t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function count(t, f){
    var
     result = [0, 0],
     _ak_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _aj_ = 0;
    if(_ak_ >= 0){
     var i = _aj_;
     for(;;){
      var
       _al_ = caml_call1(f, t[1 + i]),
       _am_ = caml_call1(Base_Bool[31], _al_);
      result[1] = caml_call2(Base_Import[91], result[1], _am_);
      var _an_ = i + 1 | 0;
      if(_ak_ === i) break;
      var i = _an_;
     }
    }
    return result[1];
   }
   function counti(t, f){
    var
     result = [0, 0],
     _af_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _ae_ = 0;
    if(_af_ >= 0){
     var i = _ae_;
     for(;;){
      var
       _ag_ = caml_call2(f, i, t[1 + i]),
       _ah_ = caml_call1(Base_Bool[31], _ag_);
      result[1] = caml_call2(Base_Import[91], result[1], _ah_);
      var _ai_ = i + 1 | 0;
      if(_af_ === i) break;
      var i = _ai_;
     }
    }
    return result[1];
   }
   function concat_map(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(map, t, f)));
   }
   function concat_mapi(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(mapi, t, f)));
   }
   function rev_inplace(t){
    var i = [0, 0], j = [0, caml_call2(Base_Import[93], t.length - 1, 1)];
    for(;;){
     if(i[1] >= j[1]) return 0;
     caml_call3(swap, t, i[1], j[1]);
     i[1]++;
     j[1] += -1;
    }
   }
   function rev(t){
    var t$0 = caml_call1(copy, t);
    rev_inplace(t$0);
    return t$0;
   }
   function of_list_rev(l){
    if(! l) return [0];
    var
     l$0 = l[2],
     a = l[1],
     _ab_ = caml_call1(Base_List[45], l$0),
     len = caml_call2(Base_Import[91], 1, _ab_),
     t = caml_call2(create, len, a),
     r = [0, l$0],
     _ac_ = caml_call2(Base_Import[93], len, 2);
    if(_ac_ >= 0){
     var i = _ac_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      var l$1 = match[2], a$0 = match[1];
      caml_check_bound(t, i)[1 + i] = a$0;
      r[1] = l$1;
      var _ad_ = i - 1 | 0;
      if(0 === i) break;
      var i = _ad_;
     }
    }
    return t;
   }
   function of_list_map(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _$_ = caml_call1(f, hd),
     _aa_ = caml_call1(Base_List[45], tl),
     a = caml_call2(create, caml_call2(Base_Import[91], 1, _aa_), _$_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call1(f, hd$0);
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, param = tl$0;
    }
   }
   function of_list_mapi(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _Z_ = caml_call2(f, 0, hd),
     ___ = caml_call1(Base_List[45], tl),
     a = caml_call2(create, caml_call2(Base_Import[91], 1, ___), _Z_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call2(f, i, hd$0);
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0, param = tl$0;
    }
   }
   function of_list_rev_map(xs, f){
    var t = of_list_map(xs, f);
    rev_inplace(t);
    return t;
   }
   function of_list_rev_mapi(xs, f){
    var t = of_list_mapi(xs, f);
    rev_inplace(t);
    return t;
   }
   function filter_mapi(t, f){
    var
     r = [0, [0]],
     k = [0, 0],
     _X_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      var match = caml_call2(f, i, t[1 + i]);
      if(match){
       var a = match[1];
       if(0 === k[1]) r[1] = caml_call2(create, t.length - 1, a);
       r[1][1 + k[1]] = a;
       k[1]++;
      }
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      var i = _Y_;
     }
    }
    return k[1] === t.length - 1
            ? r[1]
            : 0 < k[1] ? caml_call3(sub, r[1], 0, k[1]) : [0];
   }
   function filter_map(t, f){
    return filter_mapi(t, function(i, a){return caml_call1(f, a);});
   }
   function filter_opt(t){return filter_map(t, function(_V_){return _V_;});}
   function check_length2_exn(name, t1, t2){
    var n1 = t1.length - 1, n2 = t2.length - 1, _U_ = n1 !== n2 ? 1 : 0;
    return _U_ ? caml_call5(invalid_argf, _b_, name, n1, n2, 0) : _U_;
   }
   function iter2_exn(t1, t2, f){
    check_length2_exn(cst_Array_iter2_exn, t1, t2);
    return caml_call2
            (iteri, t1, function(i, x1){return caml_call2(f, x1, t2[1 + i]);});
   }
   function map2_exn(t1, t2, f){
    check_length2_exn(cst_Array_map2_exn, t1, t2);
    return caml_call2
            (init,
             t1.length - 1,
             function(i){return caml_call2(f, t1[1 + i], t2[1 + i]);});
   }
   function fold2_exn(t1, t2, init, f){
    check_length2_exn(cst_Array_fold2_exn, t1, t2);
    return foldi
            (t1,
             init,
             function(i, ac, x){return caml_call3(f, ac, x, t2[1 + i]);});
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function filteri(t, f){
    return filter_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
   }
   function exists(t, f){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call1(f, t[1 + i[1]])){result[1] = 1; continue;}
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function existsi(t, f){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){result[1] = 1; continue;}
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function mem(t, a, equal){return exists(t, caml_call1(equal, a));}
   function for_all(t, f){
    var
     i = [0, caml_call2(Base_Import[93], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call1(f, t[1 + i[1]])){i[1] += -1; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_alli(t, f){
    var
     length = t.length - 1,
     i = [0, caml_call2(Base_Import[93], length, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){i[1] += -1; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function exists2_exn(t1, t2, f){
    check_length2_exn(cst_Array_exists2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[93], t1.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){result[1] = 1; continue;}
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function for_all2_local_exn(t1, t2, f){
    check_length2_exn(cst_Array_for_all2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[93], t1.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){i[1] += -1; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_all2_exn(t1, t2, f){return for_all2_local_exn(t1, t2, f);}
   function equal_local(equal, t1, t2){
    var _T_ = t1.length - 1 === t2.length - 1 ? 1 : 0;
    return _T_ ? for_all2_local_exn(t1, t2, equal) : _T_;
   }
   function equal(equal, t1, t2){return equal_local(equal, t1, t2);}
   function map_inplace(t, f){
    var _R_ = caml_call2(Base_Import[93], t.length - 1, 1), _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      t[1 + i] = caml_call1(f, t[1 + i]);
      var _S_ = i + 1 | 0;
      if(_R_ === i) break;
      var i = _S_;
     }
    }
    return 0;
   }
   function findi_internal(t, f, if_found, if_not_found){
    var length = t.length - 1;
    if(0 === length) return caml_call1(if_not_found, 0);
    var i = [0, 0], found = [0, 0], value_found = [0, t[1]];
    for(;;){
     if(! found[1] && i[1] < length){
      var value = t[1 + i[1]];
      if(caml_call2(f, i[1], value)){
       value_found[1] = value;
       found[1] = 1;
      }
      else
       i[1]++;
      continue;
     }
     return found[1]
             ? caml_call2(if_found, i[1], value_found[1])
             : caml_call1(if_not_found, 0);
    }
   }
   function findi(t, f){
    function _P_(param){return 0;}
    return findi_internal
            (t, f, function(i, value){return [0, [0, i, value]];}, _P_);
   }
   function findi_exn(t, f){
    function _O_(param){
     throw caml_maybe_attach_backtrace([0, Base_Import[297], _c_], 1);
    }
    return findi_internal
            (t, f, function(i, value){return [0, i, value];}, _O_);
   }
   function find_exn(t, f){
    function _M_(param){
     throw caml_maybe_attach_backtrace([0, Base_Import[297], _d_], 1);
    }
    function _N_(param, value){return value;}
    return findi_internal
            (t, function(i, x){return caml_call1(f, x);}, _N_, _M_);
   }
   function find(t, f){
    function _K_(param){var x = param[2]; return x;}
    var _L_ = findi(t, function(i, x){return caml_call1(f, x);});
    return caml_call2(Base_Option[24], _L_, _K_);
   }
   function find_map(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[52], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call1(f, value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   var not_found = [0, Base_Import[297], _e_];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[52], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call2(f, i[1], value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   var not_found$0 = [0, Base_Import[297], _f_];
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$0, 1);
    var x = match[1];
    return x;
   }
   function find_consecutive_duplicate(t, equal){
    var n = t.length - 1;
    if(1 >= n) return 0;
    var result = [0, 0], i = [0, 1], prev = [0, t[1]];
    for(;;){
     if(i[1] >= n) return result[1];
     var cur = t[1 + i[1]];
     if(caml_call2(equal, cur, prev[1])){
      result[1] = [0, [0, prev[1], cur]];
      i[1] = n;
     }
     else{prev[1] = cur; i[1]++;}
    }
   }
   function reduce(t, f){
    if(0 === t.length - 1) return 0;
    var
     r = [0, t[1]],
     _I_ = caml_call2(Base_Import[93], t.length - 1, 1),
     _H_ = 1;
    if(_I_ >= 1){
     var i = _H_;
     for(;;){
      r[1] = caml_call2(f, r[1], t[1 + i]);
      var _J_ = i + 1 | 0;
      if(_I_ === i) break;
      var i = _J_;
     }
    }
    return [0, r[1]];
   }
   function reduce_exn(t, f){
    var match = reduce(t, f);
    if(! match) return caml_call1(Base_Import[126], cst_Array_reduce_exn);
    var v = match[1];
    return v;
   }
   var permute = Base_Array_permute[25];
   function random_element_exn(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    if(is_empty(t))
     return caml_call1(Base_Import[124], cst_Array_random_element_exn_e);
    var _G_ = caml_call2(Base_Random[19][7], random_state, t.length - 1);
    return caml_check_bound(t, _G_)[1 + _G_];
   }
   function random_element(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    try{var _E_ = [0, random_element_exn([0, random_state], t)]; return _E_;}
    catch(_F_){return 0;}
   }
   function zip(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? 0
            : [0, map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];})];
   }
   function zip_exn(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? caml_call1(Base_Import[124], cst_Array_zip_exn)
            : map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];});
   }
   function unzip(t){
    var n = t.length - 1;
    if(0 === n) return [0, [0], [0]];
    var
     match = caml_check_bound(t, 0)[1],
     y = match[2],
     x = match[1],
     res1 = caml_call2(create, n, x),
     res2 = caml_call2(create, n, y),
     _C_ = caml_call2(Base_Import[93], n, 1),
     _B_ = 1;
    if(_C_ >= 1){
     var i = _B_;
     for(;;){
      var
       match$0 = caml_check_bound(t, i)[1 + i],
       y$0 = match$0[2],
       x$0 = match$0[1];
      caml_check_bound(res1, i)[1 + i] = x$0;
      caml_check_bound(res2, i)[1 + i] = y$0;
      var _D_ = i + 1 | 0;
      if(_C_ === i) break;
      var i = _D_;
     }
    }
    return [0, res1, res2];
   }
   function sorted_copy(t, compare){
    var t1 = caml_call1(copy, t);
    sort(0, 0, t1, compare);
    return t1;
   }
   function partition_mapi(t, f){
    var
     both = caml_call2(mapi, t, f),
     firsts =
       filter_map
        (both,
         function(param){
          if(0 !== param[0]) return 0;
          var x = param[1];
          return [0, x];
         }),
     seconds =
       filter_map
        (both,
         function(param){
          if(0 === param[0]) return 0;
          var x = param[1];
          return [0, x];
         });
    return [0, firsts, seconds];
   }
   function partitioni_tf(t, f){
    return partition_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : [1, x];});
   }
   function partition_map(t, f){
    return partition_mapi(t, function(param, x){return caml_call1(f, x);});
   }
   function partition_tf(t, f){
    return partitioni_tf(t, function(param, x){return caml_call1(f, x);});
   }
   function last(t){
    var _A_ = caml_call2(Base_Import[93], t.length - 1, 1);
    return caml_check_bound(t, _A_)[1 + _A_];
   }
   function to_sequence_mutable(t){
    function _y_(i){
     if(t.length - 1 <= i) return 0;
     var _z_ = caml_call2(Base_Import[91], i, 1);
     return [1, caml_check_bound(t, i)[1 + i], _z_];
    }
    return caml_call2(Base_Sequence[44], 0, _y_);
   }
   function to_sequence(t){return to_sequence_mutable(caml_call1(copy, t));}
   function cartesian_product(t1, t2){
    if(! is_empty(t1) && ! is_empty(t2)){
     var
      n1 = t1.length - 1,
      n2 = t2.length - 1,
      _n_ = caml_check_bound(t2, 0)[1],
      _o_ = [0, caml_check_bound(t1, 0)[1], _n_],
      t = caml_call2(create, caml_call2(Base_Import[88], n1, n2), _o_),
      r = [0, 0],
      _q_ = caml_call2(Base_Import[93], n1, 1),
      _p_ = 0;
     if(_q_ >= 0){
      var i1 = _p_;
      for(;;){
       var _s_ = caml_call2(Base_Import[93], n2, 1), _r_ = 0;
       if(_s_ >= 0){
        var i2 = _r_;
        for(;;){
         var
          _u_ = caml_check_bound(t2, i2)[1 + i2],
          _v_ = [0, caml_check_bound(t1, i1)[1 + i1], _u_],
          _w_ = r[1];
         caml_check_bound(t, _w_)[1 + _w_] = _v_;
         r[1]++;
         var _x_ = i2 + 1 | 0;
         if(_s_ === i2) break;
         var i2 = _x_;
        }
       }
       var _t_ = i1 + 1 | 0;
       if(_q_ === i1) break;
       var i1 = _t_;
      }
     }
     return t;
    }
    return [0];
   }
   function transpose(tt){
    if(0 === tt.length - 1) return [0, [0]];
    var width = tt.length - 1, depth = caml_check_bound(tt, 0)[1].length - 1;
    return exists(tt, function(t){return t.length - 1 !== depth ? 1 : 0;})
            ? 0
            : [0,
              caml_call2
               (init,
                depth,
                function(d){
                 return caml_call2
                         (init,
                          width,
                          function(w){
                           return caml_check_bound(caml_check_bound(tt, w)[1 + w], d)
                                   [1 + d];
                          });
                })];
   }
   function transpose_exn(tt){
    var match = transpose(tt);
    if(! match) return caml_call1(Base_Import[126], cst_Array_transpose_exn);
    var tt$0 = match[1];
    return tt$0;
   }
   function get$0(_m_, _l_){return caml_check_bound(_m_, _l_)[1 + _l_];}
   function length$0(_k_){return _k_.length - 1;}
   var
    include = caml_call1(Base_Binary_searchable[2], [0, get$0, length$0]),
    binary_search = include[1],
    binary_search_segmented = include[2];
   function length$1(_j_){return _j_.length - 1;}
   function create_like(len, t){
    if(0 === len) return [0];
    if(0 < t.length - 1)
     return caml_call2(create, len, caml_check_bound(t, 0)[1]);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   }
   var
    unsafe_blit = runtime.caml_array_blit,
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length$1, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub$0 = include$0[4],
    subo = include$0[5];
   function invariant(invariant_a, t){
    return caml_call2(iter, t, invariant_a);
   }
   function _h_(_i_){return [0, Sorter(_i_)[8]];}
   var
    Base_Array =
      [0,
       compare,
       compare_local,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       binary_search,
       binary_search_segmented,
       of_list,
       of_array,
       append,
       map,
       filter,
       filter_map,
       concat_map,
       partition_tf,
       partition_map,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init,
       mapi,
       filteri,
       filter_mapi,
       concat_mapi,
       invariant,
       max_length,
       create,
       create_local,
       create_float_uninitialized,
       make_matrix,
       copy_matrix,
       concat,
       copy,
       fill,
       blit,
       blito,
       unsafe_blit$0,
       sub$0,
       subo,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       fold_right,
       sort,
       stable_sort,
       is_sorted,
       is_sorted_strictly,
       merge,
       partitioni_tf,
       cartesian_product,
       transpose,
       transpose_exn,
       filter_opt,
       iter2_exn,
       map2_exn,
       fold2_exn,
       for_all2_exn,
       exists2_exn,
       swap,
       rev_inplace,
       rev,
       of_list_rev,
       of_list_map,
       of_list_mapi,
       of_list_rev_map,
       of_list_rev_mapi,
       map_inplace,
       find_exn,
       find_map_exn,
       findi_exn,
       find_mapi_exn,
       find_consecutive_duplicate,
       reduce,
       reduce_exn,
       permute,
       random_element,
       random_element_exn,
       zip,
       zip_exn,
       unzip,
       sorted_copy,
       last,
       equal,
       equal_local,
       to_sequence,
       to_sequence_mutable,
       [0, [0, Sort[5], Sort[6], Sort[7]], _h_]];
   runtime.caml_register_global(29, Base_Array, "Base__Array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Floatable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Floatable = [0];
   runtime.caml_register_global(0, Base_Floatable, "Base__Floatable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float0
//# unitInfo: Requires: Base__Import, Base__Import0, Base__Option, Base__Printf, Ocaml_intrinsics_kernel__Float, Stdlib__Float, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_float0_ml = "src/float0.ml",
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Assert_failure = global_data.Assert_failure,
    Base_Option = global_data.Base__Option,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Float = global_data.Stdlib__Float,
    _g_ = [0, cst_src_float0_ml, 186, 4],
    _f_ = [0, cst_src_float0_ml, 190, 4],
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _e_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _b_ = [0, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)],
    _a_ =
      [0,
       [8,
        [0, 0, 0],
        0,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [8,
            [0, 0, 0],
            0,
            0,
            [11, " in float0.ml: modulus should be positive", 0]]]]]],
       "%f %% %f in float0.ml: modulus should be positive"];
   function ceil(_p_){return Math.ceil(_p_);}
   function floor(_o_){return Math.floor(_o_);}
   function mod_float(_n_, _m_){return _n_ % _m_;}
   var
    modf = runtime.caml_modf_float,
    float_of_string = runtime.caml_float_of_string,
    float_of_string_opt = Base_Import[85][36],
    nan = Base_Import[85][24],
    infinity = Base_Import[85][22],
    neg_infinity = Base_Import[85][23],
    max_finite_value = Base_Import[85][25],
    epsilon_float = Base_Import[85][27],
    classify_float = runtime.caml_classify_float;
   function abs_float(_l_){return Math.abs(_l_);}
   var is_integer = Stdlib_Float[18];
   function symbol(_k_, _j_){return Math.pow(_k_, _j_);}
   function symbol$0(a, b){
    if(b < 0.) caml_call4(Base_Printf[7], _a_, a, b, 0);
    var m = a % b;
    return m < 0. ? caml_call2(Base_Import[92], m, b) : m;
   }
   var frexp = runtime.caml_frexp_float, ldexp = runtime.caml_ldexp_float;
   function is_nan(x){return x != x ? 1 : 0;}
   function to_int64_preserve_order(t){
    return t != t
            ? 0
            : t
              == 0.
              ? _b_
              : 0.
                < t
                ? [0, caml_int64_bits_of_float(t)]
                : [0,
                  caml_int64_neg
                   (caml_int64_bits_of_float(caml_call1(Base_Import[114], t)))];
   }
   function to_int64_preserve_order_exn(x){
    var _i_ = to_int64_preserve_order(x);
    return caml_call4(Base_Option[31], 0, 0, 0, _i_);
   }
   function of_int64_preserve_order(x){
    return runtime.caml_greaterequal(x, _c_)
            ? caml_int64_float_of_bits(x)
            : caml_call1
              (Base_Import[114], caml_int64_float_of_bits(caml_int64_neg(x)));
   }
   function one_ulp(dir, t){
    var match = to_int64_preserve_order(t);
    if(! match) return Base_Import[85][24];
    var x = match[1], _h_ = 759637122 <= dir ? _d_ : _e_;
    return of_int64_preserve_order(runtime.caml_int64_add(x, _h_));
   }
   function upper_bound_for_int(num_bits){
    var exp = caml_call2(Base_Import[93], num_bits, 1);
    return one_ulp(759637122, Math.pow(2., exp));
   }
   function is_x_minus_one_exact(x){
    return 1
           -
            runtime.caml_equal
             (caml_int64_bits_of_float(x),
              caml_int64_bits_of_float(caml_call2(Base_Import[94], x, 1.)));
   }
   function lower_bound_for_int(num_bits){
    var
     exp = caml_call2(Base_Import[93], num_bits, 1),
     min_int_as_float = caml_call1(Base_Import[114], Math.pow(2., exp));
    if(53 <= caml_call2(Base_Import[93], num_bits, 1)){
     if(is_x_minus_one_exact(min_int_as_float))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     return min_int_as_float;
    }
    if(is_x_minus_one_exact(min_int_as_float))
     return one_ulp(19067, caml_call2(Base_Import[94], min_int_as_float, 1.));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   }
   function min(a, b){return runtime.caml_sse2_float64_min_bytecode(a, b);}
   function max(a, b){return runtime.caml_sse2_float64_max_bytecode(a, b);}
   var Intrinsics_with_weird_nan_beha = [0, min, max];
   function clamp_unchecked
   (to_clamp_maybe_nan, min_which_is_not_nan, max_which_is_not_nan){
    var
     t_maybe_nan =
       caml_call2
        (Intrinsics_with_weird_nan_beha[2],
         min_which_is_not_nan,
         to_clamp_maybe_nan);
    return caml_call2
            (Intrinsics_with_weird_nan_beha[1],
             max_which_is_not_nan,
             t_maybe_nan);
   }
   var x = 0.;
   function box(f){return caml_call2(Base_Import[92], f, x);}
   var
    include = Base_Import[108],
    ascending = include[1],
    descending = include[2],
    compare_local = include[3],
    equal_local = include[4],
    max$0 = include[5],
    min$0 = include[6],
    Base_Float0 =
      [0,
       ceil,
       floor,
       mod_float,
       modf,
       float_of_string,
       float_of_string_opt,
       nan,
       infinity,
       neg_infinity,
       max_finite_value,
       epsilon_float,
       classify_float,
       abs_float,
       is_integer,
       symbol,
       symbol$0,
       frexp,
       ldexp,
       is_nan,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       upper_bound_for_int,
       is_x_minus_one_exact,
       lower_bound_for_int,
       Intrinsics_with_weird_nan_beha,
       clamp_unchecked,
       box,
       ascending,
       descending,
       compare_local,
       equal_local,
       max$0,
       min$0];
   runtime.caml_register_global(21, Base_Float0, "Base__Float0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Intable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Intable = [0];
   runtime.caml_register_global(0, Base_Intable, "Base__Intable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Int_intf = [0];
   runtime.caml_register_global(0, Base_Int_intf, "Base__Int_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pow_overflow_bounds
//# unitInfo: Requires: Base__Array0, Base__Import, Base__Int_conversions
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    overflow_bound_max_int63_on_in =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    overflow_bound_max_int64_value =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Base_Import = global_data.Base__Import,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    int32_positive_overflow_bounds =
      [0,
        2147483647,
        2147483647,
        46340,
        1290,
        215,
        73,
        35,
        21,
        14,
        10,
        8,
        7,
        5,
        5,
        4,
        4,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1].slice
       (),
    overflow_bound_max_int_value = caml_call2(Base_Import[120], -1, 1),
    switcher = Base_Int_conversions[30] - 31 | 0,
    _g_ = [0, "src/pow_overflow_bounds.ml", 216, 9],
    _a_ = runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _c_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _i_ =
      [0,
       1073741823,
       1073741823,
       32767,
       1023,
       181,
       63,
       31,
       19,
       13,
       10,
       7,
       6,
       5,
       4,
       4,
       3,
       3,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1],
    _d_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
       runtime.caml_int64_create_lo_mi_hi(1664510, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(46340, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5404, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1290, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(463, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(215, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(118, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(73, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(49, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(35, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(27, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(21, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(17, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(14, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(12, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(10, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _e_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(324403, 181, 0),
       runtime.caml_int64_create_lo_mi_hi(2097151, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(55108, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6208, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1448, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(511, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(234, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(127, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(78, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(52, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(38, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(28, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(22, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(18, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(15, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(13, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(11, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _f_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(16452813, 16777034, 65535),
       runtime.caml_int64_create_lo_mi_hi(14680065, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16722108, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16771008, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16775768, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776705, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776982, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777089, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777138, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777164, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777178, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777188, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777194, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777198, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777201, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777203, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777205, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777207, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777208, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535)],
    overflow_bound_max_int32_value = 2147483647;
   if(1 < switcher >>> 0){
    if(32 !== switcher)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    var
     int_positive_overflow_bounds =
       [0,
        caml_int64_to_int32(_c_),
        caml_int64_to_int32(_b_),
        caml_int64_to_int32(_a_),
        1664510,
        46340,
        5404,
        1290,
        463,
        215,
        118,
        73,
        49,
        35,
        27,
        21,
        17,
        14,
        12,
        10,
        9,
        8,
        7,
        7,
        6,
        5,
        5,
        5,
        4,
        4,
        4,
        4,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1];
   }
   else if(switcher)
    var
     _h_ = function(_j_){return _j_;},
     int_positive_overflow_bounds =
       caml_call2(Base_Array0[21], int32_positive_overflow_bounds, _h_);
   else
    var int_positive_overflow_bounds = _i_.slice();
   var
    int63_on_int64_positive_overfl = _d_.slice(),
    int64_positive_overflow_bounds = _e_.slice(),
    int64_negative_overflow_bounds = _f_.slice(),
    Base_Pow_overflow_bounds =
      [0,
       overflow_bound_max_int32_value,
       int32_positive_overflow_bounds,
       overflow_bound_max_int_value,
       int_positive_overflow_bounds,
       overflow_bound_max_int63_on_in,
       int63_on_int64_positive_overfl,
       overflow_bound_max_int64_value,
       int64_positive_overflow_bounds,
       int64_negative_overflow_bounds];
   runtime.caml_register_global
    (16, Base_Pow_overflow_bounds, "Base__Pow_overflow_bounds");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_math
//# unitInfo: Requires: Base__Import, Base__Pow_overflow_bounds, Base__Printf, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_exponent_can_not_be_negati = "exponent can not be negative",
    cst_integer_overflow_in_pow = "integer overflow in pow",
    caml_check_bound = runtime.caml_check_bound,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessthan = runtime.caml_lessthan;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Pow_overflow_bounds = global_data.Base__Pow_overflow_bounds,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    invalid_argf = Base_Printf[7],
    _m_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"],
    _l_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    _i_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _j_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _k_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _h_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _e_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0),
    _f_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _b_ =
      [0, [11, cst_integer_overflow_in_pow, 0], cst_integer_overflow_in_pow],
    _a_ =
      [0,
       [11, cst_exponent_can_not_be_negati, 0],
       cst_exponent_can_not_be_negati];
   function negative_exponent(param){
    return caml_call2(Base_Printf[7], _a_, 0);
   }
   function overflow(param){return caml_call2(Base_Printf[7], _b_, 0);}
   function int_pow(base, exponent){
    if(exponent < 0) negative_exponent(0);
    var _J_ = 1 < caml_call1(Base_Import[123], base) ? 1 : 0;
    if(_J_){
     var _K_ = 63 < exponent ? 1 : 0;
     if(_K_)
      var _L_ = _K_;
     else
      var
       _M_ =
         caml_check_bound(Base_Pow_overflow_bounds[4], exponent)[1 + exponent],
       _L_ = _M_ < caml_call1(Base_Import[123], base) ? 1 : 0;
    }
    else
     var _L_ = _J_;
    if(_L_) overflow(0);
    return runtime.Base_int_math_int_pow_stub(base, exponent);
   }
   var abs = Stdlib_Int64[8];
   function int64_pow(base, exponent){
    if(caml_lessthan(exponent, _c_)) negative_exponent(0);
    var
     _A_ = caml_greaterthan(base, _d_),
     _B_ = _A_ || caml_lessthan(base, _h_);
    if(_B_){
     var _C_ = caml_greaterthan(exponent, _e_);
     if(_C_)
      var _D_ = _C_;
     else{
      var _E_ = runtime.caml_greaterequal(base, _f_);
      if(_E_)
       var
        _F_ = caml_int64_to_int32(exponent),
        _G_ =
          caml_greaterthan
           (base, caml_check_bound(Base_Pow_overflow_bounds[8], _F_)[1 + _F_]);
      else
       var _G_ = _E_;
      if(_G_)
       var _D_ = _G_;
      else{
       var _H_ = caml_lessthan(base, _g_);
       if(_H_)
        var
         _I_ = caml_int64_to_int32(exponent),
         _D_ =
           caml_lessthan
            (base,
             caml_check_bound(Base_Pow_overflow_bounds[9], _I_)[1 + _I_]);
       else
        var _D_ = _H_;
      }
     }
    }
    else
     var _D_ = _B_;
    if(_D_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   function int63_pow_on_int64(base, exponent){
    if(caml_lessthan(exponent, _i_)) negative_exponent(0);
    var _v_ = caml_greaterthan(caml_call1(abs, base), _j_);
    if(_v_){
     var _w_ = caml_greaterthan(exponent, _k_);
     if(_w_)
      var _x_ = _w_;
     else
      var
       _y_ = caml_int64_to_int32(exponent),
       _z_ = caml_check_bound(Base_Pow_overflow_bounds[6], _y_)[1 + _y_],
       _x_ = caml_greaterthan(caml_call1(abs, base), _z_);
    }
    else
     var _x_ = _v_;
    if(_x_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   var
    Private = [0, int_pow, int64_pow, int63_pow_on_int64],
    Base_Int_math =
      [0,
       function(X){
        function symbol(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _u_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _l_, caml_call1(X[4], x), _u_, 0);
         }
         var rval = caml_call2(X[20], x, y);
         return caml_call2(X[14], rval, X[18])
                 ? caml_call2(X[5], rval, y)
                 : rval;
        }
        var one = caml_call1(X[19], 1);
        function symbol$0(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _r_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _m_, caml_call1(X[4], x), _r_, 0);
         }
         if(! caml_call2(X[14], x, X[18])) return caml_call2(X[8], x, y);
         var _s_ = caml_call2(X[5], x, one), _t_ = caml_call2(X[8], _s_, y);
         return caml_call2(X[6], _t_, one);
        }
        function symbol$1(x, y){
         var _p_ = caml_call1(X[2], y), _q_ = caml_call1(X[2], x);
         return caml_call2(Base_Import[96], _q_, _p_);
        }
        function round_down(i, modulus){
         var _o_ = symbol(i, modulus);
         return caml_call2(X[6], i, _o_);
        }
        function round_up(i, modulus){
         var remainder = symbol(i, modulus);
         if(caml_call2(X[12], remainder, X[18])) return i;
         var _n_ = caml_call2(X[5], i, modulus);
         return caml_call2(X[6], _n_, remainder);
        }
        function round_towards_zero(i, to_multiple_of){
         return caml_call2(X[12], i, X[18])
                 ? X[18]
                 : caml_call2
                    (X[13], i, X[18])
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        function round_nearest(i, modulus){
         var
          remainder = symbol(i, modulus),
          modulus_minus_remainder = caml_call2(X[6], modulus, remainder);
         return caml_call2(X[11], modulus_minus_remainder, remainder)
                 ? caml_call2(X[5], i, modulus_minus_remainder)
                 : caml_call2(X[6], i, remainder);
        }
        function round(opt, i, to_multiple_of){
         if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
         return 857423934 <= dir
                 ? 1003109192
                   <= dir
                   ? round_towards_zero(i, to_multiple_of)
                   : round_nearest(i, to_multiple_of)
                 : 759637122
                   <= dir
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        return [0,
                symbol,
                symbol$0,
                symbol$1,
                round,
                round_towards_zero,
                round_down,
                round_up,
                round_nearest];
       },
       Private];
   runtime.caml_register_global(17, Base_Int_math, "Base__Int_math");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Staged
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function stage(_b_){return _b_;}
   function unstage(_a_){return _a_;}
   var Base_Staged = [0, stage, unstage];
   runtime.caml_register_global(0, Base_Staged, "Base__Staged");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Bytes_intf = [0];
   runtime.caml_register_global(0, Base_Bytes_intf, "Base__Bytes_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char
//# unitInfo: Requires: Base__Array0, Base__Char0, Base__Comparable, Base__Error, Base__Hash, Base__Identifiable, Base__Import, Base__Sexp, Base__String0, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Char",
    Base_Import = global_data.Base__Import,
    Base_Hash = global_data.Base__Hash,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_String0 = global_data.Base__String0,
    Base_Char0 = global_data.Base__Char0,
    Base_Identifiable = global_data.Base__Identifiable,
    Base_Array0 = global_data.Base__Array0,
    Base_Comparable = global_data.Base__Comparable,
    failwithf = Base_Char0[1],
    escaped = Base_Char0[2],
    lowercase = Base_Char0[3],
    to_int = Base_Char0[4],
    unsafe_of_int = Base_Char0[5],
    uppercase = Base_Char0[6],
    min_value = Base_Char0[8],
    max_value = Base_Char0[9],
    of_int = Base_Char0[10],
    of_int_exn = Base_Char0[11],
    compare = Base_Import[226],
    hash_fold_t = Base_Import[205],
    func = Base_Import[219],
    cst_char = "char",
    cst_Char_get_hex_digit_exn_not =
      "Char.get_hex_digit_exn: not a hexadecimal digit",
    _d_ =
      [0,
       [11, "Char.get_digit_exn ", [1, [11, ": not a digit", 0]]],
       "Char.get_digit_exn %C: not a digit"],
    _b_ = [0, [1, 0], "%C"],
    _a_ = [0, [11, "Char.of_string: ", [3, 0, 0]], "Char.of_string: %S"];
   function hash(x){return caml_call1(func, x);}
   var
    globalize = Base_Import[282],
    t_of_sexp = Base_Import[162],
    sexp_of_t = Base_Import[138],
    t_sexp_grammar = Base_Import[184];
   function to_string(t){return caml_call2(Base_String0[8], 1, t);}
   function of_string(s){
    return 1 === runtime.caml_ml_string_length(s)
            ? runtime.caml_string_get(s, 0)
            : caml_call3(failwithf, _a_, s, 0);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    hashable = include[24];
   function pp(fmt, c){return caml_call3(Stdlib_Format[137], fmt, _b_, c);}
   function invariant(param){return 0;}
   var
    _c_ = caml_call2(Base_Array0[12], 256, unsafe_of_int),
    all = caml_call1(Base_Array0[16], _c_);
   function is_lowercase(param){return 25 < param - 97 >>> 0 ? 0 : 1;}
   function is_uppercase(param){return 25 < param - 65 >>> 0 ? 0 : 1;}
   function is_print(param){return 94 < param - 32 >>> 0 ? 0 : 1;}
   function is_whitespace(param){
    a:
    {
     if(14 <= param){if(32 === param) break a;} else if(9 <= param) break a;
     return 0;
    }
    return 1;
   }
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   function is_alpha(param){
    a:
    {
     if(91 <= param){
      if(25 < param - 97 >>> 0) break a;
     }
     else if(65 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_alphanum(param){
    var _v_ = param - 48 | 0;
    a:
    {
     if(42 < _v_ >>> 0){
      if(25 < _v_ - 49 >>> 0) break a;
     }
     else if(6 >= _v_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function get_digit_unsafe(t){
    var _t_ = caml_call1(to_int, 48), _u_ = caml_call1(to_int, t);
    return caml_call2(Base_Import[93], _u_, _t_);
   }
   function get_digit_exn(t){
    return is_digit(t)
            ? get_digit_unsafe(t)
            : caml_call3(failwithf, _d_, t, 0);
   }
   function get_digit(t){return is_digit(t) ? [0, get_digit_unsafe(t)] : 0;}
   function is_hex_digit(param){
    var _s_ = param - 48 | 0;
    a:
    {
     if(22 < _s_ >>> 0){
      if(5 < _s_ - 49 >>> 0) break a;
     }
     else if(6 >= _s_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_lower(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 97 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_upper(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 65 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function get_hex_digit_exn(t){
    if(65 <= t){
     if(97 <= t){
      if(103 > t){
       var
        _k_ = caml_call1(to_int, 97),
        _l_ = caml_call1(to_int, t),
        _m_ = caml_call2(Base_Import[93], _l_, _k_);
       return caml_call2(Base_Import[91], _m_, 10);
      }
     }
     else if(71 > t){
      var
       _n_ = caml_call1(to_int, 65),
       _o_ = caml_call1(to_int, t),
       _p_ = caml_call2(Base_Import[93], _o_, _n_);
      return caml_call2(Base_Import[91], _p_, 10);
     }
    }
    else if(9 >= t - 48 >>> 0){
     var _q_ = caml_call1(to_int, 48), _r_ = caml_call1(to_int, t);
     return caml_call2(Base_Import[93], _r_, _q_);
    }
    var
     _i_ = [0, [0, cst_char, caml_call1(sexp_of_t$0, t)], 0],
     _j_ = caml_call2(Base_Sexp[10], cst_Char_get_hex_digit_exn_not, _i_);
    return caml_call1(Base_Error[32], _j_);
   }
   function get_hex_digit(t){
    return is_hex_digit(t) ? [0, get_hex_digit_exn(t)] : 0;
   }
   var
    symbol = Base_Import[106][6],
    symbol$0 = Base_Import[106][2],
    symbol$1 = Base_Import[106][4],
    symbol$2 = Base_Import[106][5],
    symbol$3 = Base_Import[106][1],
    symbol$4 = Base_Import[106][3],
    O = [0, symbol, symbol$0, symbol$1, symbol$2, symbol$3, symbol$4],
    t_of_sexp$1 = Base_Import[162],
    sexp_of_t$1 = Base_Import[138],
    t_sexp_grammar$0 = Base_Import[184];
   function compare$0(c1, c2){
    var _g_ = caml_call1(lowercase, c2), _h_ = caml_call1(lowercase, c1);
    return caml_call2(Base_Import[106][9], _h_, _g_);
   }
   function compare_local(c1, c2){return compare$0(c1, c2);}
   function hash_fold_t$1(state, t){
    var _f_ = caml_call1(lowercase, t);
    return caml_call2(Base_Import[205], state, _f_);
   }
   function hash$1(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$1, t);}
   var
    include$0 = caml_call1(Base_Comparable[11], [0, compare$0, sexp_of_t$1]),
    symbol$5 = include$0[1],
    symbol$6 = include$0[2],
    symbol$7 = include$0[3],
    symbol$8 = include$0[4],
    symbol$9 = include$0[5],
    symbol$10 = include$0[6],
    equal = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between$0 = include$0[13],
    clamp_exn$0 = include$0[14],
    clamp$0 = include$0[15],
    comparator$0 = include$0[16];
   function equal_local(t1, t2){
    var _e_ = compare_local(t1, t2);
    return caml_call2(Base_Import[242], _e_, 0);
   }
   var
    include$1 = Base_Import[106],
    symbol$11 = include$1[1],
    symbol$12 = include$1[2],
    symbol$13 = include$1[3],
    symbol$14 = include$1[4],
    symbol$15 = include$1[5],
    symbol$16 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    compare_local$0 = include$1[10],
    equal$0 = include$1[11],
    equal_local$0 = include$1[12],
    max$0 = include$1[13],
    min$0 = include$1[14],
    Base_Char =
      [0,
       all,
       globalize,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$16,
       symbol$12,
       symbol$14,
       symbol$15,
       symbol$11,
       symbol$13,
       equal$0,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       equal_local$0,
       compare_local$0,
       invariant,
       O,
       to_int,
       of_int,
       of_int_exn,
       unsafe_of_int,
       escaped,
       lowercase,
       uppercase,
       is_digit,
       is_lowercase,
       is_uppercase,
       is_alpha,
       is_alphanum,
       is_print,
       is_whitespace,
       get_digit,
       get_digit_exn,
       is_hex_digit,
       is_hex_digit_lower,
       is_hex_digit_upper,
       get_hex_digit,
       get_hex_digit_exn,
       min_value,
       max_value,
       [0,
        hash_fold_t$1,
        hash$1,
        t_of_sexp$1,
        sexp_of_t$1,
        t_sexp_grammar$0,
        symbol$5,
        symbol$6,
        symbol$7,
        symbol$8,
        symbol$9,
        symbol$10,
        equal,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between$0,
        clamp_exn$0,
        clamp$0,
        comparator$0,
        equal_local,
        compare_local]];
   runtime.caml_register_global(16, Base_Char, "Base__Char");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes_tr
//# unitInfo: Requires: Base__Bytes0, Base__Char, Base__Import0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Char = global_data.Base__Char,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Import0 = global_data.Base__Import0;
   function tr_create_map(target, replacement){
    var tr_map = caml_call1(Base_Bytes0[7], 256), i$3 = 0;
    for(;;){
     caml_bytes_unsafe_set(tr_map, i$3, caml_call1(Base_Char[34], i$3));
     var _j_ = i$3 + 1 | 0;
     if(255 === i$3) break;
     var i$3 = _j_;
    }
    var
     _b_ =
       caml_call2
        (Base_Import0[97][4],
         caml_ml_string_length(target),
         caml_ml_string_length(replacement))
       - 1
       | 0,
     _a_ = 0;
    if(_b_ >= 0){
     var i$2 = _a_;
     for(;;){
      var
       index$0 =
         caml_call1(Base_Char[32], caml_string_unsafe_get(target, i$2));
      caml_bytes_unsafe_set
       (tr_map, index$0, caml_string_unsafe_get(replacement, i$2));
      var _i_ = i$2 + 1 | 0;
      if(_b_ === i$2) break;
      var i$2 = _i_;
     }
    }
    var
     last_replacement =
       caml_string_unsafe_get
        (replacement, caml_ml_string_length(replacement) - 1 | 0),
     _c_ =
       caml_call2
        (Base_Import0[97][4],
         caml_ml_string_length(target),
         caml_ml_string_length(replacement)),
     _d_ = caml_ml_string_length(target) - 1 | 0;
    if(_d_ >= _c_){
     var i$1 = _c_;
     for(;;){
      var
       index = caml_call1(Base_Char[32], caml_string_unsafe_get(target, i$1));
      caml_bytes_unsafe_set(tr_map, index, last_replacement);
      var _h_ = i$1 + 1 | 0;
      if(_d_ === i$1) break;
      var i$1 = _h_;
     }
    }
    var
     first_target = runtime.caml_string_get(target, 0),
     _f_ =
       caml_bytes_unsafe_get(tr_map, caml_call1(Base_Char[32], first_target));
    if(! caml_call2(Base_Char[15], _f_, first_target)){
     var i = 0;
     for(;;){
      if(256 === i)
       var _g_ = 0;
      else{
       var _e_ = caml_call1(Base_Char[34], i);
       if(! caml_call2(Base_Char[15], caml_bytes_unsafe_get(tr_map, i), _e_)){var i$0 = i + 1 | 0, i = i$0; continue;}
       var _g_ = 1;
      }
      if(_g_) break;
      return 0;
     }
    }
    return [0, runtime.caml_string_of_bytes(tr_map)];
   }
   var Base_Bytes_tr = [0, tr_create_map];
   runtime.caml_register_global(3, Base_Bytes_tr, "Base__Bytes_tr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_String_intf = [0];
   runtime.caml_register_global(0, Base_String_intf, "Base__String_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String
//# unitInfo: Requires: Base__Array0, Base__Bytes0, Base__Bytes_tr, Base__Char, Base__Comparable, Base__Comparator, Base__Container, Base__Error, Base__Hash, Base__Identifiable, Base__Import, Base__Indexed_container, Base__Int0, Base__List, Base__Option, Base__Or_error, Base__Ordered_collection_common, Base__Printf, Base__Sequence, Base__Sexp, Base__Sexpable, Base__Staged, Base__String0, Base__String_intf, Base__Uchar0, CamlinternalLazy, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$15 = "",
    cst_case_sensitive = "case_sensitive",
    cst_char$1 = "char",
    cst_escape_char$1 = "escape_char",
    cst_pattern = "pattern",
    cst_pos$2 = "pos",
    cst_src_string_ml = "src/string.ml",
    cst_str$1 = "str",
    caml_blit_string = runtime.caml_blit_string,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_of_bytes = runtime.caml_string_of_bytes,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$14 = cst$15,
    cst$13 = cst$15,
    cst$12 = cst$15,
    cst$11 = cst$15,
    cst$10 = cst$15,
    cst$8 = cst$15,
    cst$9 = cst$15,
    cst$6 = cst$15,
    cst$7 = cst$15,
    cst$5 = cst$15,
    cst$4 = cst$15,
    cst$3 = cst$15,
    cst$2 = cst$15,
    cst$1 = cst$15,
    cst$0 = cst$15,
    cst = cst$15,
    codec_name = "UTF-8",
    module_name = "Base.String.Utf8",
    codec_name$0 = "UTF-16LE",
    module_name$0 = "Base.String.Utf16le",
    codec_name$1 = "UTF-16BE",
    module_name$1 = "Base.String.Utf16be",
    codec_name$2 = "UTF-32LE",
    module_name$2 = "Base.String.Utf32le",
    codec_name$3 = "UTF-32BE",
    module_name$3 = "Base.String.Utf32be",
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Uchar0 = global_data.Base__Uchar0,
    Base_Bytes0 = global_data.Base__Bytes0,
    Assert_failure = global_data.Assert_failure,
    Base_List = global_data.Base__List,
    Base_Sequence = global_data.Base__Sequence,
    Base_Sexp = global_data.Base__Sexp,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Printf = global_data.Base__Printf,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Identifiable = global_data.Base__Identifiable,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Or_error = global_data.Base__Or_error,
    Base_Option = global_data.Base__Option,
    Base_Array0 = global_data.Base__Array0,
    Base_Int0 = global_data.Base__Int0,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Container = global_data.Base__Container,
    Base_Hash = global_data.Base__Hash,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_String0 = global_data.Base__String0,
    Base_Error = global_data.Base__Error,
    Base_Staged = global_data.Base__Staged,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    max_length = Base_String0[2],
    symbol = Base_String0[3],
    capitalize = Base_String0[4],
    compare = Base_String0[5],
    escaped = Base_String0[6],
    lowercase = Base_String0[7],
    make = Base_String0[8],
    uncapitalize = Base_String0[10],
    uppercase = Base_String0[11],
    is_valid_utf_8 = Base_String0[12],
    is_valid_utf_16le = Base_String0[13],
    is_valid_utf_16be = Base_String0[14],
    get_utf_8_uchar = Base_String0[15],
    get_utf_16le_uchar = Base_String0[16],
    get_utf_16be_uchar = Base_String0[17],
    get_utf_32le_uchar = Base_String0[18],
    get_utf_32be_uchar = Base_String0[19],
    concat = Base_String0[20],
    iter = Base_String0[21],
    split_lines = Base_String0[22],
    invalid_argf = Base_Printf[7],
    raise_s = Base_Error[32],
    stage = Base_Staged[1],
    globalize = Base_Import[289],
    hash_fold_t = Base_Import[208],
    func = Base_Import[222],
    _N_ = [0, cst$15],
    _M_ = [0, cst_src_string_ml, 2020, 4],
    _L_ = [0, cst_src_string_ml, 2006, 4],
    _K_ = [0, cst_src_string_ml, 1996, 4],
    cst_pos$1 = cst_pos$2,
    _J_ =
      [0,
       [2,
        0,
        [11, ".get: invalid ", [2, 0, [11, " encoding at given position", 0]]]],
       "%s.get: invalid %s encoding at given position"],
    cst_of_string_invalid = ".of_string: invalid ",
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _I_ = [0, cst_src_string_ml, 1872, 2],
    _H_ = [0, cst_src_string_ml, 1858, 19],
    cst_char$0 = cst_char$1,
    cst_pos$0 = cst_pos$2,
    cst_escape_char$0 = cst_escape_char$1,
    cst_str$0 = cst_str$1,
    cst_rindex_from_exn_not_found = "rindex_from_exn: not found",
    cst_rindex_from = "rindex_from",
    cst_char = cst_char$1,
    cst_pos = cst_pos$2,
    cst_escape_char = cst_escape_char$1,
    cst_str = cst_str$1,
    cst_index_from_exn_not_found = "index_from_exn: not found",
    cst_index_from = "index_from",
    cst_is_char_literal = "is_char_literal",
    cst_is_char_escaped = "is_char_escaped",
    cst_is_char_escaping = "is_char_escaping",
    _G_ = [0, [2, 0, [11, ": out of bounds", 0]], "%s: out of bounds"],
    cst_escapeworthy_map = "escapeworthy_map",
    cst_c_to = "c_to",
    cst_c_from = "c_from",
    cst_escapeworthy_map_not_one_t = "escapeworthy_map not one-to-one",
    _F_ = [0, cst$15, cst$15],
    _E_ = [0, [3, 0, 0], "%S"],
    _D_ =
      [0,
       [11, "String.chop_suffix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_suffix_exn %S %S"],
    _C_ =
      [0,
       [11, "String.chop_prefix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_prefix_exn %S %S"],
    _B_ = [0, cst_src_string_ml, 925, 4],
    cst_tr_multi_replacement_is_em = "tr_multi replacement is empty string",
    _A_ = [0, cst_src_string_ml, 761, 17],
    cst_suffix = "suffix",
    cst_prefix = "prefix",
    cst_drop_suffix = "drop_suffix",
    cst_drop_prefix = "drop_prefix",
    cst_expecting_nonnegative_argu = " expecting nonnegative argument",
    _z_ = [0, "String.rsplit2_exn: not found"],
    _y_ = [0, "String.lsplit2_exn: not found"],
    _x_ = [0, [11, "String.init ", [4, 0, 0, 0, 0]], "String.init %d"],
    _p_ =
      [0,
       [11,
        "String.is_substring_at: invalid index ",
        [4, 0, 0, 0, [11, " for string of length ", [4, 0, 0, 0, 0]]]],
       "String.is_substring_at: invalid index %d for string of length %d"],
    _g_ = [0, "kmp_array"],
    _h_ = [0, cst_case_sensitive],
    _i_ = [0, cst_pattern],
    cst_substring = "substring",
    cst_Substring_not_found = "Substring not found",
    _e_ = [0, cst_case_sensitive],
    _f_ = [0, cst_pattern],
    cst_String_rindex_from_exn = "String.rindex_from_exn",
    _d_ = [0, "String.rindex_from_exn: not found"],
    _c_ = [0, "String.rindex_exn: not found"],
    cst_String_index_from_exn = "String.index_from_exn",
    _b_ = [0, "String.index_from_exn: not found"],
    _a_ = [0, "String.index_exn: not found"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[160],
    sexp_of_t = Base_Import[136],
    t_sexp_grammar = Base_Import[182],
    hashable = [0, hash, compare, sexp_of_t],
    include = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t]),
    comparator = include[1];
   function invariant(param){return 0;}
   function unsafe_sub(src, pos, len){
    if(0 === len) return cst;
    var dst = caml_call1(Base_Bytes0[7], len);
    caml_blit_string(src, pos, dst, 0, len);
    return caml_string_of_bytes(dst);
   }
   function sub(src, pos, len){
    if(0 === pos && len === caml_ml_string_length(src)) return src;
    caml_call3
     (Base_Ordered_collection_common[2], pos, len, caml_ml_string_length(src));
    return unsafe_sub(src, pos, len);
   }
   function subo(opt, len, src){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(len)
     var i = len[1], i$0 = i;
    else
     var i$0 = caml_call2(Base_Import[93], caml_ml_string_length(src), pos);
    return sub(src, pos, i$0);
   }
   function contains(opt, len, t, char$0){
    if(opt) var sth = opt[1], pos$1 = sth; else var pos$1 = 0;
    var
     total_length = caml_ml_string_length(t),
     _eG_ = caml_call2(Base_Import[93], total_length, pos$1),
     len$0 = caml_call2(Base_Option[30], len, _eG_);
    caml_call3(Base_Ordered_collection_common[2], pos$1, len$0, total_length);
    var end = caml_call2(Base_Import[91], pos$1, len$0), pos = pos$1;
    for(;;){
     var _eD_ = pos < end ? 1 : 0;
     if(_eD_){
      var
       _eE_ =
         caml_call2(Base_Char[16], caml_string_unsafe_get(t, pos), char$0);
      if(! _eE_){
       var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
       continue;
      }
      var _eF_ = _eE_;
     }
     else
      var _eF_ = _eD_;
     return _eF_;
    }
   }
   function is_empty(t){return 0 === caml_ml_string_length(t) ? 1 : 0;}
   function index_from_internal(string, len, not_found, found, char$0, pos){
    var pos$0 = pos;
    for(;;){
     if(len <= pos$0) return caml_call1(not_found, 0);
     if
      (caml_call2
        (Base_Char[16], caml_string_unsafe_get(string, pos$0), char$0))
      return caml_call1(found, pos$0);
     var pos$1 = caml_call2(Base_Import[91], pos$0, 1), pos$0 = pos$1;
    }
   }
   function index(t, char$0){
    var _eB_ = 0, _eC_ = Base_Option[49];
    return index_from_internal
            (t,
             caml_ml_string_length(t),
             function(param){return 0;},
             _eC_,
             char$0,
             _eB_);
   }
   function index_exn(t, char$0){
    var _ey_ = 0;
    function _ez_(_eA_){return _eA_;}
    return index_from_internal
            (t,
             caml_ml_string_length(t),
             function(param){
              throw caml_maybe_attach_backtrace([0, Base_Import[297], _a_], 1);
             },
             _ez_,
             char$0,
             _ey_);
   }
   function index_from(t, pos, char$0){
    var _ex_ = Base_Option[49];
    return index_from_internal
            (t,
             caml_ml_string_length(t),
             function(param){return 0;},
             _ex_,
             char$0,
             pos);
   }
   function not_found(param){
    throw caml_maybe_attach_backtrace([0, Base_Import[297], _b_], 1);
   }
   function index_from_exn(t, pos, char$0){
    var len = caml_ml_string_length(t);
    if(0 <= pos && len >= pos)
     return index_from_internal
             (t, len, not_found, function(_ew_){return _ew_;}, char$0, pos);
    return caml_call1(Base_Import[126], cst_String_index_from_exn);
   }
   function rindex_from_internal(string, char$0, found, not_found, pos){
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) return caml_call1(not_found, 0);
     if
      (caml_call2
        (Base_Char[16], caml_string_unsafe_get(string, pos$0), char$0))
      return caml_call1(found, pos$0);
     var pos$1 = caml_call2(Base_Import[93], pos$0, 1), pos$0 = pos$1;
    }
   }
   function rindex(t, char$0){
    var _eu_ = caml_call2(Base_Import[93], caml_ml_string_length(t), 1);
    function _ev_(param){return 0;}
    return rindex_from_internal(t, char$0, Base_Option[49], _ev_, _eu_);
   }
   function rindex_exn(t, char$0){
    var _er_ = caml_call2(Base_Import[93], caml_ml_string_length(t), 1);
    function _es_(param){
     throw caml_maybe_attach_backtrace([0, Base_Import[297], _c_], 1);
    }
    return rindex_from_internal
            (t, char$0, function(_et_){return _et_;}, _es_, _er_);
   }
   function rindex_from(t, pos, char$0){
    function _eq_(param){return 0;}
    return rindex_from_internal(t, char$0, Base_Option[49], _eq_, pos);
   }
   function not_found$0(param){
    throw caml_maybe_attach_backtrace([0, Base_Import[297], _d_], 1);
   }
   function rindex_from_exn(t, pos, char$0){
    if(-1 <= pos && caml_ml_string_length(t) > pos)
     return rindex_from_internal
             (t, char$0, function(_ep_){return _ep_;}, not_found$0, pos);
    return caml_call1(Base_Import[126], cst_String_rindex_from_exn);
   }
   function sexp_of_t$0(param){
    var
     case_sensitive = param[2],
     pattern = param[1],
     _eo_ =
       [0,
        [1, [0, _e_, [0, caml_call1(Base_Import[135], case_sensitive), 0]]],
        0];
    return [1,
            [0,
             [1, [0, _f_, [0, caml_call1(Base_Import[136], pattern), 0]]],
             _eo_]];
   }
   function pattern(t){return t[1];}
   function case_sensitive(t){return t[2];}
   function kmp_internal_loop
   (matched_chars, next_text_char, pattern, kmp_array, char_equal){
    var matched_chars$0 = [0, matched_chars];
    for(;;){
     if
      (0 < matched_chars$0[1]
       &&
        !
        caml_call2
         (char_equal,
          next_text_char,
          caml_string_unsafe_get(pattern, matched_chars$0[1]))){
      matched_chars$0[1] =
       kmp_array[1 + caml_call2(Base_Import[93], matched_chars$0[1], 1)];
      continue;
     }
     if
      (caml_call2
        (char_equal,
         next_text_char,
         caml_string_unsafe_get(pattern, matched_chars$0[1])))
      matched_chars$0[1] = caml_call2(Base_Import[91], matched_chars$0[1], 1);
     return matched_chars$0[1];
    }
   }
   function get_char_equal(case_sensitive){
    return case_sensitive ? Base_Char[16] : Base_Char[55][12];
   }
   function create(pattern, case_sensitive){
    var
     n = caml_ml_string_length(pattern),
     kmp_array = caml_call2(Base_Array0[4], n, -1);
    if(0 < n){
     var char_equal = get_char_equal(case_sensitive);
     kmp_array[1] = 0;
     var
      matched_chars = [0, 0],
      _em_ = caml_call2(Base_Import[93], n, 1),
      _el_ = 1;
     if(_em_ >= 1){
      var i = _el_;
      for(;;){
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1],
          caml_string_unsafe_get(pattern, i),
          pattern,
          kmp_array,
          char_equal);
       kmp_array[1 + i] = matched_chars[1];
       var _en_ = i + 1 | 0;
       if(_em_ === i) break;
       var i = _en_;
      }
     }
    }
    return [0, pattern, case_sensitive, kmp_array];
   }
   function index_internal(opt, param){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    return function(text){
     if
      (0 <= pos
       &&
        caml_call2
         (Base_Import[93],
          caml_ml_string_length(text),
          caml_ml_string_length(pattern))
        >= pos){
      var
       char_equal = get_char_equal(case_sensitive),
       j = [0, pos],
       matched_chars = [0, 0],
       k = caml_ml_string_length(pattern),
       n = caml_ml_string_length(text);
      for(;;){
       if(j[1] < n && matched_chars[1] < k){
        var next_text_char = caml_string_unsafe_get(text, j[1]);
        matched_chars[1] =
         kmp_internal_loop
          (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
        j[1] = caml_call2(Base_Import[91], j[1], 1);
        continue;
       }
       return matched_chars[1] === k
               ? caml_call2(Base_Import[93], j[1], k)
               : -1;
      }
     }
     return -1;};
   }
   function matches(t, str){return 0 <= index_internal(0, t)(str) ? 1 : 0;}
   function index$0(pos, t, in$0){
    var p = index_internal(pos, t)(in$0);
    return 0 <= p ? [0, p] : 0;
   }
   function index_exn$0(pos, t, in$0){
    var p = index_internal(pos, t)(in$0);
    if(0 <= p) return p;
    var _ek_ = [0, [0, cst_substring, caml_call1(Base_Import[136], t[1])], 0];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[10], cst_Substring_not_found, _ek_));
   }
   function index_all(param, may_overlap, text){
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    if(0 === caml_ml_string_length(pattern)){
     var
      _ee_ = function(_ej_){return _ej_;},
      _ef_ = caml_call2(Base_Import[91], 1, caml_ml_string_length(text));
     return caml_call2(Base_List[40], _ef_, _ee_);
    }
    var
     char_equal = get_char_equal(case_sensitive),
     matched_chars = [0, 0],
     k = caml_ml_string_length(pattern),
     n = caml_ml_string_length(text),
     found = [0, 0],
     _eg_ = 0;
    if(n >= 0){
     var j = _eg_;
     for(;;){
      if(matched_chars[1] === k){
       var _eh_ = found[1];
       found[1] = [0, caml_call2(Base_Import[93], j, k), _eh_];
       matched_chars[1] =
        may_overlap ? kmp_array[1 + caml_call2(Base_Import[93], k, 1)] : 0;
      }
      if(j < n){
       var next_text_char = caml_string_unsafe_get(text, j);
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
      }
      var _ei_ = j + 1 | 0;
      if(n === j) break;
      var j = _ei_;
     }
    }
    return caml_call1(Base_List[63], found[1]);
   }
   function replace_first(pos, t, s, with$0){
    var match = index$0(pos, t, s);
    if(! match) return s;
    var
     i = match[1],
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     _d__ = caml_call2(Base_Import[91], len_s, len_with),
     _d$_ = caml_call2(Base_Import[93], _d__, len_t),
     dst = caml_call1(Base_Bytes0[7], _d$_);
    caml_call5(Base_Bytes0[4], s, 0, dst, 0, i);
    caml_call5(Base_Bytes0[4], with$0, 0, dst, i, len_with);
    var
     _ea_ = caml_call2(Base_Import[93], len_s, i),
     _eb_ = caml_call2(Base_Import[93], _ea_, len_t),
     _ec_ = caml_call2(Base_Import[91], i, len_with),
     _ed_ = caml_call2(Base_Import[91], i, len_t);
    caml_call5(Base_Bytes0[4], s, _ed_, dst, _ec_, _eb_);
    return caml_string_of_bytes(dst);
   }
   function replace_all(t, s, with$0){
    var matches = index_all(t, 0, s);
    if(! matches) return s;
    var
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     num_matches = caml_call1(Base_List[45], matches),
     _d2_ = caml_call2(Base_Import[93], len_with, len_t),
     _d3_ = caml_call2(Base_Import[88], _d2_, num_matches),
     _d4_ = caml_call2(Base_Import[91], len_s, _d3_),
     dst = caml_call1(Base_Bytes0[7], _d4_),
     next_dst_pos = [0, 0],
     next_src_pos = [0, 0];
    function _d5_(i){
     var len = caml_call2(Base_Import[93], i, next_src_pos[1]);
     caml_call5(Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], len);
     var _d7_ = caml_call2(Base_Import[91], next_dst_pos[1], len);
     caml_call5(Base_Bytes0[4], with$0, 0, dst, _d7_, len_with);
     var _d8_ = caml_call2(Base_Import[91], next_dst_pos[1], len);
     next_dst_pos[1] = caml_call2(Base_Import[91], _d8_, len_with);
     var _d9_ = caml_call2(Base_Import[91], next_src_pos[1], len);
     next_src_pos[1] = caml_call2(Base_Import[91], _d9_, len_t);
     return 0;
    }
    caml_call2(Base_List[19], matches, _d5_);
    var _d6_ = caml_call2(Base_Import[93], len_s, next_src_pos[1]);
    caml_call5(Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], _d6_);
    return caml_string_of_bytes(dst);
   }
   function split_on(t, s){
    var
     pattern_len = caml_ml_string_length(t[1]),
     matches = index_all(t, 0, s);
    function _dX_(i, j){
     var
      _d0_ = caml_call2(Base_Import[93], j, i),
      _d1_ = caml_call2(Base_Import[93], _d0_, pattern_len);
     return sub(s, caml_call2(Base_Import[91], i, pattern_len), _d1_);
    }
    var
     _dY_ =
       caml_call2(Base_Import[111], matches, [0, caml_ml_string_length(s), 0]),
     _dZ_ = [0, caml_call1(Base_Import[113], pattern_len), matches];
    return caml_call3(Base_List[98], _dZ_, _dY_, _dX_);
   }
   function equal_local(a_003, b_004){
    if(a_003 === b_004) return 1;
    var _dU_ = caml_call2(Base_Import[274], a_003[1], b_004[1]);
    if(_dU_){
     var _dV_ = caml_call2(Base_Import[267], a_003[2], b_004[2]);
     if(_dV_)
      return caml_call3
              (Base_Import[277], Base_Import[270], a_003[3], b_004[3]);
     var _dW_ = _dV_;
    }
    else
     var _dW_ = _dU_;
    return _dW_;
   }
   function equal(a, b){return equal_local(a, b);}
   function sexp_of_t$1(param){
    var
     kmp_array_012 = param[3],
     case_sensitive_010 = param[2],
     pattern_008 = param[1],
     arg_013 = caml_call2(Base_Import[150], Base_Import[139], kmp_array_012),
     bnds_007 = [0, [1, [0, _g_, [0, arg_013, 0]]], 0],
     arg_011 = caml_call1(Base_Import[135], case_sensitive_010),
     bnds_007$0 = [0, [1, [0, _h_, [0, arg_011, 0]]], bnds_007],
     arg_009 = caml_call1(Base_Import[136], pattern_008),
     bnds_007$1 = [0, [1, [0, _i_, [0, arg_009, 0]]], bnds_007$0];
    return [1, bnds_007$1];
   }
   function representation(_dT_){return _dT_;}
   function substr_index_gen(case_sensitive, pos, t, pattern){return index$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_exn_gen(case_sensitive, pos, t, pattern){return index_exn$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_all_gen(case_sensitive, t, may_overlap, pattern){return index_all(create(pattern, case_sensitive), may_overlap, t);
   }
   function substr_replace_first_gen(case_sensitive, pos, t, pattern){
    var _dR_ = create(pattern, case_sensitive);
    return function(_dS_){return replace_first(pos, _dR_, t, _dS_);};
   }
   function substr_replace_all_gen(case_sensitive, t, pattern){
    var _dP_ = create(pattern, case_sensitive);
    return function(_dQ_){return replace_all(_dP_, t, _dQ_);};
   }
   function is_substring_gen(case_sensitive, t, substring){
    var _dO_ = substr_index_gen(case_sensitive, 0, t, substring);
    return caml_call1(Base_Option[53], _dO_);
   }
   var _j_ = 1;
   function substr_index(_dL_, _dM_, _dN_){
    return substr_index_gen(_j_, _dL_, _dM_, _dN_);
   }
   var _k_ = 1;
   function substr_index_exn(_dI_, _dJ_, _dK_){
    return substr_index_exn_gen(_k_, _dI_, _dJ_, _dK_);
   }
   var _l_ = 1;
   function substr_index_all(_dF_, _dG_, _dH_){
    return substr_index_all_gen(_l_, _dF_, _dG_, _dH_);
   }
   var _m_ = 1;
   function substr_replace_first(_dC_, _dD_, _dE_){
    return substr_replace_first_gen(_m_, _dC_, _dD_, _dE_);
   }
   var _n_ = 1;
   function substr_replace_all(_dA_, _dB_){
    return substr_replace_all_gen(_n_, _dA_, _dB_);
   }
   var _o_ = 1;
   function is_substring(_dy_, _dz_){
    return is_substring_gen(_o_, _dy_, _dz_);
   }
   function is_substring_at_gen(str, str_pos$1, sub, char_equal){
    var
     str_len = caml_ml_string_length(str),
     sub_len = caml_ml_string_length(sub),
     _dv_ = str_pos$1 < 0 ? 1 : 0,
     _dw_ = _dv_ || (str_len < str_pos$1 ? 1 : 0);
    if(_dw_) caml_call4(invalid_argf, _p_, str_pos$1, str_len, 0);
    var
     _dx_ = caml_call2(Base_Import[91], str_pos$1, sub_len) <= str_len ? 1 : 0;
    if(! _dx_) return _dx_;
    var str_pos = str_pos$1, sub_pos = 0;
    for(;;){
     if(sub_pos === sub_len) return 1;
     if
      (!
       caml_call2
        (char_equal,
         caml_string_unsafe_get(str, str_pos),
         caml_string_unsafe_get(sub, sub_pos)))
      return 0;
     var
      sub_pos$0 = caml_call2(Base_Import[91], sub_pos, 1),
      str_pos$0 = caml_call2(Base_Import[91], str_pos, 1),
      str_pos = str_pos$0,
      sub_pos = sub_pos$0;
    }
   }
   function is_suffix_gen(string, suffix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     suffix_len = caml_ml_string_length(suffix),
     _du_ = suffix_len <= string_len ? 1 : 0;
    return _du_
            ? is_substring_at_gen
              (string,
               caml_call2(Base_Import[93], string_len, suffix_len),
               suffix,
               char_equal)
            : _du_;
   }
   function is_prefix_gen(string, prefix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     prefix_len = caml_ml_string_length(prefix),
     _dt_ = prefix_len <= string_len ? 1 : 0;
    return _dt_ ? is_substring_at_gen(string, 0, prefix, char_equal) : _dt_;
   }
   var
    t_of_sexp$0 = Base_Import[160],
    sexp_of_t$2 = Base_Import[136],
    t_sexp_grammar$0 = Base_Import[182];
   function compare_local(string1, string2){
    if(string1 === string2) return 0;
    var
     len2 = caml_ml_string_length(string2),
     len1 = caml_ml_string_length(string1),
     pos = 0;
    for(;;){
     if(pos === len1) return pos === len2 ? 0 : -1;
     if(pos === len2) return 1;
     var
      c2 = caml_string_unsafe_get(string2, pos),
      c1 = caml_string_unsafe_get(string1, pos),
      _dr_ = caml_call1(Base_Char[37], c2),
      _ds_ = caml_call1(Base_Char[37], c1),
      c = caml_call2(Base_Char[17], _ds_, _dr_);
     if(0 !== c) return c;
     var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
    }
   }
   function compare$0(a, b){return compare_local(a, b);}
   function hash_fold_t$0(state, t){
    var
     len = caml_ml_string_length(t),
     state$0 = [0, caml_call2(Base_Import[206], state, len)],
     _do_ = caml_call2(Base_Import[93], len, 1),
     _dn_ = 0;
    if(_do_ >= 0){
     var pos = _dn_;
     for(;;){
      var _dp_ = caml_call1(Base_Char[37], caml_string_unsafe_get(t, pos));
      state$0[1] = caml_call2(Base_Import[205], state$0[1], _dp_);
      var _dq_ = pos + 1 | 0;
      if(_do_ === pos) break;
      var pos = _dq_;
     }
    }
    return state$0[1];
   }
   function hash$0(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$0, t);}
   function is_suffix(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[55][12]);
   }
   function is_prefix(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[55][12]);
   }
   var _q_ = 0;
   function substr_index$0(_dk_, _dl_, _dm_){
    return substr_index_gen(_q_, _dk_, _dl_, _dm_);
   }
   var _r_ = 0;
   function substr_index_exn$0(_dh_, _di_, _dj_){
    return substr_index_exn_gen(_r_, _dh_, _di_, _dj_);
   }
   var _s_ = 0;
   function substr_index_all$0(_de_, _df_, _dg_){
    return substr_index_all_gen(_s_, _de_, _df_, _dg_);
   }
   var _t_ = 0;
   function substr_replace_first$0(_db_, _dc_, _dd_){
    return substr_replace_first_gen(_t_, _db_, _dc_, _dd_);
   }
   var _u_ = 0;
   function substr_replace_all$0(_c$_, _da_){
    return substr_replace_all_gen(_u_, _c$_, _da_);
   }
   var _v_ = 0;
   function is_substring$0(_c9_, _c__){
    return is_substring_gen(_v_, _c9_, _c__);
   }
   var _w_ = Base_Char[55][12];
   function is_substring_at(_c6_){
    return function(_c7_){
     return function(_c8_){
      return is_substring_at_gen(_c6_, _c7_, _c8_, _w_);};};
   }
   var
    include$0 = caml_call1(Base_Comparable[11], [0, compare$0, sexp_of_t$2]),
    symbol$0 = include$0[1],
    symbol$1 = include$0[2],
    symbol$2 = include$0[3],
    symbol$3 = include$0[4],
    symbol$4 = include$0[5],
    symbol$5 = include$0[6],
    equal$0 = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator$0 = include$0[16];
   function of_string(_c5_){return _c5_;}
   function to_string(_c4_){return _c4_;}
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _x_, n, 0);
    var
     t = caml_call1(Base_Bytes0[7], n),
     _c2_ = caml_call2(Base_Import[93], n, 1),
     _c1_ = 0;
    if(_c2_ >= 0){
     var i = _c1_;
     for(;;){
      caml_bytes_set(t, i, caml_call1(f, i));
      var _c3_ = i + 1 | 0;
      if(_c2_ === i) break;
      var i = _c3_;
     }
    }
    return caml_string_of_bytes(t);
   }
   function to_list(s){
    var
     i$1 = caml_call2(Base_Import[93], caml_ml_string_length(s), 1),
     acc = 0,
     i = i$1;
    for(;;){
     if(0 > i) return acc;
     var
      i$0 = caml_call2(Base_Import[93], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc],
      acc = acc$0,
      i = i$0;
    }
   }
   function to_list_rev(s){
    var len = caml_ml_string_length(s), acc = 0, i = 0;
    for(;;){
     if(i === len) return acc;
     var
      i$0 = caml_call2(Base_Import[91], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc],
      acc = acc$0,
      i = i$0;
    }
   }
   function rev(t){
    var
     len = caml_ml_string_length(t),
     res = caml_call1(Base_Bytes0[7], len),
     _cY_ = caml_call2(Base_Import[93], len, 1),
     _cX_ = 0;
    if(_cY_ >= 0){
     var i = _cX_;
     for(;;){
      var _cZ_ = caml_call2(Base_Import[93], len, 1);
      caml_bytes_unsafe_set
       (res,
        i,
        caml_string_unsafe_get(t, caml_call2(Base_Import[93], _cZ_, i)));
      var _c0_ = i + 1 | 0;
      if(_cY_ === i) break;
      var i = _c0_;
     }
    }
    return caml_string_of_bytes(res);
   }
   function not_found$1(param){
    throw caml_maybe_attach_backtrace([0, Base_Import[297], _y_], 1);
   }
   function lsplit2_exn(line, delim){
    var
     len = caml_ml_string_length(line),
     _cS_ = 0,
     pos =
       index_from_internal
        (line, len, not_found$1, function(_cW_){return _cW_;}, delim, _cS_),
     _cT_ = caml_call2(Base_Import[93], len, pos),
     _cU_ = caml_call2(Base_Import[93], _cT_, 1),
     _cV_ = sub(line, caml_call2(Base_Import[91], pos, 1), _cU_);
    return [0, sub(line, 0, pos), _cV_];
   }
   function not_found$2(param){
    throw caml_maybe_attach_backtrace([0, Base_Import[297], _z_], 1);
   }
   function rsplit2_exn(line, delim){
    var
     len = caml_ml_string_length(line),
     _cN_ = caml_call2(Base_Import[93], len, 1),
     pos =
       rindex_from_internal
        (line, delim, function(_cR_){return _cR_;}, not_found$2, _cN_),
     _cO_ = caml_call2(Base_Import[93], len, pos),
     _cP_ = caml_call2(Base_Import[93], _cO_, 1),
     _cQ_ = sub(line, caml_call2(Base_Import[91], pos, 1), _cP_);
    return [0, sub(line, 0, pos), _cQ_];
   }
   function lsplit2(line, on){
    try{var _cL_ = [0, lsplit2_exn(line, on)]; return _cL_;}
    catch(_cM_){
     var _cK_ = caml_wrap_exception(_cM_);
     if(_cK_[1] !== Base_Import[297] && _cK_ !== Base_Import[85][8])
      throw caml_maybe_attach_backtrace(_cK_, 0);
     return 0;
    }
   }
   function rsplit2(line, on){
    try{var _cI_ = [0, rsplit2_exn(line, on)]; return _cI_;}
    catch(_cJ_){
     var _cH_ = caml_wrap_exception(_cJ_);
     if(_cH_[1] !== Base_Import[297] && _cH_ !== Base_Import[85][8])
      throw caml_maybe_attach_backtrace(_cH_, 0);
     return 0;
    }
   }
   function char_list_mem(l, c){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1], _cG_ = caml_call2(Base_Char[16], hd, c);
     if(_cG_) return _cG_;
     var l$0 = tl;
    }
   }
   function split_gen(str, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[16], c$0, c);};
    var
     last_pos = caml_ml_string_length(str),
     pos$1 = caml_call2(Base_Import[93], last_pos, 1),
     acc = 0,
     last_pos$1 = last_pos,
     last_pos$0 = pos$1;
    for(;;){
     if(-1 === last_pos$0) return [0, sub(str, 0, last_pos$1), acc];
     if(is_delim(caml_string_get(str, last_pos$0)))
      var
       pos1 = caml_call2(Base_Import[91], last_pos$0, 1),
       sub_str = sub(str, pos1, caml_call2(Base_Import[93], last_pos$1, pos1)),
       pos = caml_call2(Base_Import[93], last_pos$0, 1),
       acc$0 = [0, sub_str, acc],
       acc = acc$0,
       last_pos$1 = last_pos$0,
       last_pos$0 = pos;
     else
      var
       pos$0 = caml_call2(Base_Import[93], last_pos$0, 1),
       last_pos$0 = pos$0;
    }
   }
   function split(str, on){return split_gen(str, [0, -1044422954, on]);}
   function split_on_chars(str, chars){
    return split_gen(str, [0, 552554919, chars]);
   }
   function is_suffix$0(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[16]);
   }
   function is_prefix$0(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[16]);
   }
   function is_substring_at$0(s, pos, substring){
    return is_substring_at_gen(s, pos, substring, Base_Char[16]);
   }
   function wrap_sub_n(t, n, name, pos, len, on_error){
    if(0 <= n)
     try{var _cD_ = sub(t, pos, len); return _cD_;}
     catch(_cF_){return on_error;}
    var _cE_ = caml_call2(symbol, name, cst_expecting_nonnegative_argu);
    return caml_call1(Base_Import[126], _cE_);
   }
   function drop_prefix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_prefix,
             n,
             caml_call2(Base_Import[93], caml_ml_string_length(t), n),
             cst$0);
   }
   function drop_suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_suffix,
             0,
             caml_call2(Base_Import[93], caml_ml_string_length(t), n),
             cst$1);
   }
   function prefix(t, n){return wrap_sub_n(t, n, cst_prefix, 0, n, t);}
   function suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_suffix,
             caml_call2(Base_Import[93], caml_ml_string_length(t), n),
             n,
             t);
   }
   function lfindi(opt, t, f){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var n = caml_ml_string_length(t), i = pos;
    for(;;){
     if(i === n) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   function find(t, f){
    var match = lfindi(0, t, function(param, c){return caml_call1(f, c);});
    if(! match) return 0;
    var i = match[1];
    return [0, caml_string_get(t, i)];
   }
   function find_map(t, f){
    var n = caml_ml_string_length(t), i = 0;
    for(;;){
     if(i === n) return 0;
     var res = caml_call1(f, caml_string_get(t, i));
     if(res) return res;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   function rfindi(pos, t, f){
    if(pos)
     var pos$0 = pos[1], pos$1 = pos$0;
    else
     var pos$1 = caml_call2(Base_Import[93], caml_ml_string_length(t), 1);
    var i = pos$1;
    for(;;){
     if(0 > i) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[93], i, 1), i = i$0;
    }
   }
   function last_non_drop(drop, t){
    return rfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function rstrip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[45];
    var match = last_non_drop(drop, t);
    if(! match) return cst$2;
    var i = match[1];
    return i === caml_call2(Base_Import[93], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[91], i, 1));
   }
   function first_non_drop(drop, t){
    return lfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function lstrip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[45];
    var match = first_non_drop(drop, t);
    if(! match) return cst$3;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[45];
    var length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[93], length, 1))))
      break a;
     var match = first_non_drop(drop, t);
     if(! match) return cst$4;
     var first = match[1], match$0 = last_non_drop(drop, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     var last = match$0[1], _cC_ = caml_call2(Base_Import[93], last, first);
     return sub(t, first, caml_call2(Base_Import[91], _cC_, 1));
    }
    return t;
   }
   function mapi(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _cA_ = caml_call2(Base_Import[93], l, 1),
     _cz_ = 0;
    if(_cA_ >= 0){
     var i = _cz_;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call2(f, i, caml_string_get(t, i)));
      var _cB_ = i + 1 | 0;
      if(_cA_ === i) break;
      var i = _cB_;
     }
    }
    return caml_string_of_bytes(t$0);
   }
   function map(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _cx_ = caml_call2(Base_Import[93], l, 1),
     _cw_ = 0;
    if(_cx_ >= 0){
     var i = _cw_;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call1(f, caml_string_get(t, i)));
      var _cy_ = i + 1 | 0;
      if(_cx_ === i) break;
      var i = _cy_;
     }
    }
    return caml_string_of_bytes(t$0);
   }
   function to_array(s){
    function _cv_(i){return caml_string_get(s, i);}
    return caml_call2(Base_Array0[12], caml_ml_string_length(s), _cv_);
   }
   function exists(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _cs_ = i < len ? 1 : 0;
     if(_cs_){
      var _ct_ = caml_call1(f, caml_string_get(s, i));
      if(! _ct_){
       var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
       continue;
      }
      var _cu_ = _ct_;
     }
     else
      var _cu_ = _cs_;
     return _cu_;
    }
   }
   function for_all(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _cp_ = i === len ? 1 : 0;
     if(_cp_)
      var _cq_ = _cp_;
     else{
      var _cr_ = caml_call1(f, caml_string_get(s, i));
      if(_cr_){
       var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
       continue;
      }
      var _cq_ = _cr_;
     }
     return _cq_;
    }
   }
   function fold(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call2(f, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[91], i, 1),
      i = i$0,
      ac = ac$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call3(f, i, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[91], i, 1),
      i = i$0,
      ac = ac$0;
    }
   }
   function iteri(t, f){
    var
     _cn_ = caml_call2(Base_Import[93], caml_ml_string_length(t), 1),
     _cm_ = 0;
    if(_cn_ >= 0){
     var i = _cm_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(t, i));
      var _co_ = i + 1 | 0;
      if(_cn_ === i) break;
      var i = _co_;
     }
    }
    return 0;
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t){return caml_call2(Base_Container[3], fold, t);}
   function max_elt(t){return caml_call2(Base_Container[4], fold, t);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return caml_call5(Base_Container[9], fold, init, f, finish, t);
   }
   function find_mapi(t, f){
    return caml_call3(Base_Indexed_container[7], iteri, t, f);
   }
   function findi(t, f){
    return caml_call3(Base_Indexed_container[6], iteri, t, f);
   }
   function counti(t, f){
    return caml_call3(Base_Indexed_container[3], foldi, t, f);
   }
   function for_alli(t, f){
    return caml_call3(Base_Indexed_container[5], iteri, t, f);
   }
   function existsi(t, f){
    return caml_call3(Base_Indexed_container[4], iteri, t, f);
   }
   function mem(t, c){
    var len = caml_ml_string_length(t), i = 0;
    for(;;){
     var _cj_ = i < len ? 1 : 0;
     if(_cj_){
      var _ck_ = caml_call2(Base_Char[16], c, caml_string_unsafe_get(t, i));
      if(! _ck_){
       var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
       continue;
      }
      var _cl_ = _ck_;
     }
     else
      var _cl_ = _cj_;
     return _cl_;
    }
   }
   function tr(target, replacement, s){
    return caml_call2(Base_Char[16], target, replacement)
            ? s
            : mem
               (s, target)
              ? map
                (s,
                 function(c){
                  return caml_call2(Base_Char[16], c, target)
                          ? replacement
                          : c;
                 })
              : s;
   }
   function tr_multi(target, replacement){
    if(is_empty(target))
     return caml_call1(stage, function(_ci_){return _ci_;});
    if(is_empty(replacement))
     return caml_call1(Base_Import[126], cst_tr_multi_replacement_is_em);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_ch_){return _ch_;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              return exists
                       (s,
                        function(c){
                         var
                          _cg_ =
                            caml_string_unsafe_get(tr_map, caml_call1(Base_Char[32], c));
                         return caml_call2(Base_Char[15], c, _cg_);
                        })
                      ? map
                        (s,
                         function(c){
                          return caml_string_unsafe_get
                                  (tr_map, caml_call1(Base_Char[32], c));
                         })
                      : s;
             });
   }
   function concat_array(sep, ar){
    return caml_call2(concat, sep, caml_call1(Base_Array0[16], ar));
   }
   function concat_map(sep, s, f){
    var _cf_ = to_array(s);
    return concat_array(sep, caml_call2(Base_Array0[21], _cf_, f));
   }
   function concat_mapi(sep, t, f){
    var _ce_ = to_array(t);
    return concat_array(sep, caml_call2(Base_Array0[22], _ce_, f));
   }
   function concat_lines(opt, lines$3){
    if(opt) var sth = opt[1], crlf = sth; else var crlf = 0;
    var newline_len = crlf ? 2 : 1, lines = lines$3, sum = 0;
    for(;;){
     if(! lines) break;
     var
      lines$0 = lines[2],
      line = lines[1],
      _cd_ = caml_call2(Base_Import[91], sum, caml_ml_string_length(line)),
      sum$0 = caml_call2(Base_Import[91], _cd_, newline_len),
      lines = lines$0,
      sum = sum$0;
    }
    var buf = caml_call1(Base_Bytes0[7], sum), lines$1 = lines$3, written = 0;
    for(;;){
     if(! lines$1){
      if(written === sum) return caml_string_of_bytes(buf);
      throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
     }
     var lines$2 = lines$1[2], line$0 = lines$1[1];
     caml_blit_string(line$0, 0, buf, written, caml_ml_string_length(line$0));
     var
      pos =
        caml_call2(Base_Import[91], written, caml_ml_string_length(line$0)),
      pos$0 =
        crlf
         ? (caml_bytes_unsafe_set
            (buf, pos, 13),
           caml_call2(Base_Import[91], pos, 1))
         : pos;
     caml_bytes_unsafe_set(buf, pos$0, 10);
     var
      pos$1 = caml_call2(Base_Import[91], pos$0, 1),
      lines$1 = lines$2,
      written = pos$1;
    }
   }
   function filter(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     if(! caml_call1(f, caml_string_get(t, i[1]))) break;
     i[1]++;
    }
    if(i[1] === n) return t;
    var
     _cb_ = caml_call2(Base_Import[93], n, 1),
     out = caml_call1(Base_Bytes0[7], _cb_);
    caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    i[1]++;
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_string_of_bytes(out),
       _cc_ = caml_call2(Base_Import[93], n, 1);
      return out_pos[1] === _cc_ ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call1(f, c)){caml_bytes_set(out, out_pos[1], c); out_pos[1]++;}
     i[1]++;
    }
   }
   function filteri(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     var _b__ = caml_string_get(t, i[1]);
     if(! caml_call2(f, i[1], _b__)) break;
     i[1]++;
    }
    if(i[1] === n) return t;
    var
     _b$_ = caml_call2(Base_Import[93], n, 1),
     out = caml_call1(Base_Bytes0[7], _b$_);
    caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    i[1]++;
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_string_of_bytes(out),
       _ca_ = caml_call2(Base_Import[93], n, 1);
      return out_pos[1] === _ca_ ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call2(f, i[1], c)){
      caml_bytes_set(out, out_pos[1], c);
      out_pos[1]++;
     }
     i[1]++;
    }
   }
   function chop_prefix(s, prefix){
    return is_prefix$0(s, prefix)
            ? [0, drop_prefix(s, caml_ml_string_length(prefix))]
            : 0;
   }
   function chop_prefix_if_exists(s, prefix){
    return is_prefix$0(s, prefix)
            ? drop_prefix(s, caml_ml_string_length(prefix))
            : s;
   }
   function chop_prefix_exn(s, prefix){
    var match = chop_prefix(s, prefix);
    if(! match) return caml_call4(invalid_argf, _C_, s, prefix, 0);
    var str = match[1];
    return str;
   }
   function chop_suffix(s, suffix){
    return is_suffix$0(s, suffix)
            ? [0, drop_suffix(s, caml_ml_string_length(suffix))]
            : 0;
   }
   function chop_suffix_if_exists(s, suffix){
    return is_suffix$0(s, suffix)
            ? drop_suffix(s, caml_ml_string_length(suffix))
            : s;
   }
   function chop_suffix_exn(s, suffix){
    var match = chop_suffix(s, suffix);
    if(! match) return caml_call4(invalid_argf, _D_, s, suffix, 0);
    var str = match[1];
    return str;
   }
   function shorter(a, b){
    return caml_ml_string_length(a) <= caml_ml_string_length(b) ? a : b;
   }
   function shortest(list){
    if(! list) return cst$5;
    var rest = list[2], first = list[1];
    return caml_call3(Base_List[20], rest, first, shorter);
   }
   function pos_from_left(param, i){return i;}
   function pos_from_right(t, i){
    var _b9_ = caml_call2(Base_Import[93], caml_ml_string_length(t), i);
    return caml_call2(Base_Import[93], _b9_, 1);
   }
   function common_generic2_length_loop(a, b, get_pos, max_len, len_so_far){
    var len_so_far$0 = len_so_far;
    for(;;){
     if(max_len <= len_so_far$0) return max_len;
     var
      _b7_ = caml_string_unsafe_get(b, caml_call2(get_pos, b, len_so_far$0)),
      _b8_ = caml_string_unsafe_get(a, caml_call2(get_pos, a, len_so_far$0));
     if(! caml_call2(Base_Char[16], _b8_, _b7_)) return len_so_far$0;
     var
      len_so_far$1 = caml_call2(Base_Import[91], len_so_far$0, 1),
      len_so_far$0 = len_so_far$1;
    }
   }
   function common_generic2_length(a, b, get_pos){
    var
     max_len =
       caml_call2
        (Base_Import[101], caml_ml_string_length(a), caml_ml_string_length(b));
    return common_generic2_length_loop(a, b, get_pos, max_len, 0);
   }
   function common_generic_length_loop(first, list, get_pos, max_len){
    var first$0 = first, list$0 = list, max_len$0 = max_len;
    for(;;){
     if(! list$0) return max_len$0;
     var
      rest = list$0[2],
      second = list$0[1],
      max_len$1 =
        common_generic2_length_loop(first$0, second, get_pos, max_len$0, 0),
      first$0 = second,
      list$0 = rest,
      max_len$0 = max_len$1;
    }
   }
   function common_generic_length(list, get_pos){
    if(! list) return 0;
    var
     rest = list[2],
     first = list[1],
     max_len = caml_ml_string_length(shortest(list));
    return common_generic_length_loop(first, rest, get_pos, max_len);
   }
   function common_generic2(a, b, get_pos, take){
    var len = common_generic2_length(a, b, get_pos);
    return caml_call2(take, shorter(a, b), len);
   }
   function common_generic(list, get_pos, take){
    if(! list) return cst$7;
    var
     rest = list[2],
     first = list[1],
     s = shortest(list),
     max_len = caml_ml_string_length(s);
    if(0 === max_len) return cst$6;
    var len = common_generic_length_loop(first, rest, get_pos, max_len);
    return caml_call2(take, s, len);
   }
   function common_prefix(list){
    return common_generic(list, pos_from_left, prefix);
   }
   function common_suffix(list){
    return common_generic(list, pos_from_right, suffix);
   }
   function common_prefix2(a, b){
    return common_generic2(a, b, pos_from_left, prefix);
   }
   function common_suffix2(a, b){
    return common_generic2(a, b, pos_from_right, suffix);
   }
   function common_prefix_length(list){
    return common_generic_length(list, pos_from_left);
   }
   function common_suffix_length(list){
    return common_generic_length(list, pos_from_right);
   }
   function common_prefix2_length(a, b){
    return common_generic2_length(a, b, pos_from_left);
   }
   function common_suffix2_length(a, b){
    return common_generic2_length(a, b, pos_from_right);
   }
   function pp(ppf, string){
    return caml_call3(Stdlib_Format[137], ppf, _E_, string);
   }
   function of_char(c){return caml_call2(make, 1, c);}
   function of_char_list(l){
    var
     _b5_ = caml_call1(Base_List[45], l),
     t = caml_call1(Base_Bytes0[7], _b5_);
    function _b6_(i, c){return caml_bytes_set(t, i, c);}
    caml_call2(Base_List[34], l, _b6_);
    return caml_string_of_bytes(t);
   }
   function of_array(a){
    return init
            (a.length - 1,
             function(_b4_){return caml_check_bound(a, _b4_)[1 + _b4_];});
   }
   function to_sequence(t){
    var len = caml_ml_string_length(t);
    function _b3_(pos){
     return len <= pos
             ? 0
             : [1,
               caml_string_unsafe_get(t, pos),
               caml_call2(Base_Import[91], pos, 1)];
    }
    return caml_call2(Base_Sequence[44], 0, _b3_);
   }
   function of_sequence(s){
    return of_char_list(caml_call1(Base_Sequence[20], s));
   }
   function pad_right(opt, s, len){
    if(opt) var sth = opt[1], char$0 = sth; else var char$0 = 32;
    var src_len = caml_ml_string_length(s);
    if(len <= src_len) return s;
    var res = caml_call1(Base_Bytes0[7], len);
    caml_call5(Base_Bytes0[4], s, 0, res, 0, src_len);
    var _b2_ = caml_call2(Base_Import[93], len, src_len);
    caml_call4(Base_Bytes0[15], res, src_len, _b2_, char$0);
    return caml_string_of_bytes(res);
   }
   function pad_left(opt, s, len){
    if(opt) var sth = opt[1], char$0 = sth; else var char$0 = 32;
    var src_len = caml_ml_string_length(s);
    if(len <= src_len) return s;
    var
     res = caml_call1(Base_Bytes0[7], len),
     _b0_ = caml_call2(Base_Import[93], len, src_len);
    caml_call5(Base_Bytes0[4], s, 0, res, _b0_, src_len);
    var _b1_ = caml_call2(Base_Import[93], len, src_len);
    caml_call4(Base_Bytes0[15], res, 0, _b1_, char$0);
    return caml_string_of_bytes(res);
   }
   function local_copy_prefix(src, prefix_len, buffer_len){
    var dst = caml_call1(Base_Bytes0[14], buffer_len);
    caml_blit_string(src, 0, dst, 0, prefix_len);
    return dst;
   }
   function local_copy_to_string(buf, pos){
    var str = caml_string_of_bytes(buf);
    return unsafe_sub(str, 0, pos);
   }
   function filter_mapi(src, f){
    var src_len = caml_ml_string_length(src);
    a:
    {
     var pos = 0;
     for(;;){
      if(pos === src_len) return src;
      var
       c1 = caml_string_unsafe_get(src, pos),
       src_pos$0 = caml_call1(Base_Int0[8], pos),
       option = caml_call2(f, pos, c1);
      if(! option) break a;
      var c2 = option[1];
      if(! caml_call2(Base_Char[16], c1, c2)) break;
      var pos = src_pos$0;
     }
    }
    var copy = local_copy_prefix(src, pos, src_len);
    if(option){
     var c$0 = option[1];
     caml_bytes_unsafe_set(copy, pos, c$0);
     var dst_pos$0 = src_pos$0;
    }
    else
     var dst_pos$0 = pos;
    var
     dst_pos = [0, dst_pos$0],
     _bY_ = caml_call2(Base_Import[93], src_len, 1);
    if(_bY_ >= src_pos$0){
     var src_pos = src_pos$0;
     for(;;){
      var
       match = caml_call2(f, src_pos, caml_string_unsafe_get(src, src_pos));
      if(match){
       var c = match[1];
       caml_bytes_unsafe_set(copy, dst_pos[1], c);
       dst_pos[1]++;
      }
      var _bZ_ = src_pos + 1 | 0;
      if(_bY_ === src_pos) break;
      var src_pos = _bZ_;
     }
    }
    return local_copy_to_string(copy, dst_pos[1]);
   }
   function filter_map(t, f){
    return filter_mapi(t, function(param, c){return caml_call1(f, c);});
   }
   function partition_map_difference
   (src, f, len, src_pos$0, fst_pos$0, snd_pos$0, either){
    var
     fsts = local_copy_prefix(src, fst_pos$0, len),
     snds = local_copy_prefix(src, snd_pos$0, len);
    if(0 === either[0]){
     var c$1 = either[1];
     caml_bytes_unsafe_set(fsts, fst_pos$0, c$1);
     var
      snd_pos$1 = snd_pos$0,
      fst_pos$1 = caml_call2(Base_Import[91], fst_pos$0, 1);
    }
    else{
     var c$2 = either[1];
     caml_bytes_unsafe_set(snds, snd_pos$0, c$2);
     var
      snd_pos$2 = caml_call2(Base_Import[91], snd_pos$0, 1),
      snd_pos$1 = snd_pos$2,
      fst_pos$1 = fst_pos$0;
    }
    var
     src_pos$1 = caml_call2(Base_Import[91], src_pos$0, 1),
     fst_pos = [0, fst_pos$1],
     snd_pos = [0, snd_pos$1],
     _bV_ = caml_call2(Base_Import[93], len, 1);
    if(_bV_ >= src_pos$1){
     var src_pos = src_pos$1;
     for(;;){
      var match = caml_call1(f, caml_string_unsafe_get(src, src_pos));
      if(0 === match[0]){
       var c = match[1];
       caml_bytes_unsafe_set(fsts, fst_pos[1], c);
       fst_pos[1]++;
      }
      else{
       var c$0 = match[1];
       caml_bytes_unsafe_set(snds, snd_pos[1], c$0);
       snd_pos[1]++;
      }
      var _bX_ = src_pos + 1 | 0;
      if(_bV_ === src_pos) break;
      var src_pos = _bX_;
     }
    }
    var _bW_ = local_copy_to_string(snds, snd_pos[1]);
    return [0, local_copy_to_string(fsts, fst_pos[1]), _bW_];
   }
   function partition_map(src, f){
    var len = caml_ml_string_length(src);
    if(0 === len) return _F_;
    var c1$1 = caml_string_unsafe_get(src, 0), either$1 = caml_call1(f, c1$1);
    if(0 === either$1[0]){
     var c2$1 = either$1[1];
     if(caml_call2(Base_Char[16], c1$1, c2$1)){
      var pos = 1;
      for(;;){
       if(pos === len) return [0, src, cst$8];
       var c1 = caml_string_unsafe_get(src, pos), either = caml_call1(f, c1);
       if(0 === either[0]){
        var c2 = either[1];
        if(caml_call2(Base_Char[16], c1, c2)){
         var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
         continue;
        }
       }
       return partition_map_difference(src, f, len, pos, pos, 0, either);
      }
     }
    }
    else{
     var c2$2 = either$1[1];
     if(caml_call2(Base_Char[16], c1$1, c2$2)){
      var pos$1 = 1;
      for(;;){
       if(pos$1 === len) return [0, cst$9, src];
       var
        c1$0 = caml_string_unsafe_get(src, pos$1),
        either$0 = caml_call1(f, c1$0);
       if(1 === either$0[0]){
        var c2$0 = either$0[1];
        if(caml_call2(Base_Char[16], c1$0, c2$0)){
         var pos$2 = caml_call2(Base_Import[91], pos$1, 1), pos$1 = pos$2;
         continue;
        }
       }
       return partition_map_difference(src, f, len, pos$1, 0, pos$1, either$0);
      }
     }
    }
    return partition_map_difference(src, f, len, 0, 0, 0, either$1);
   }
   function partition_tf(t, f){
    return partition_map
            (t, function(c){return caml_call1(f, c) ? [0, c] : [1, c];});
   }
   function edit_distance(s1, s2){
    if(caml_ml_string_length(s1) <= caml_ml_string_length(s2))
     var s2$0 = s2, s1$0 = s1;
    else
     var s2$0 = s1, s1$0 = s2;
    var
     _br_ = caml_call2(Base_Import[91], 1, caml_ml_string_length(s1$0)),
     _bs_ = caml_call2(Base_Import[88], 2, _br_),
     table = caml_call2(Base_Array0[5], _bs_, 0);
    function at(i, j){
     var
      _bT_ = caml_call2(Base_Import[122], j, 2),
      _bU_ = caml_call2(Base_Import[88], i, 2);
     return caml_call2(Base_Import[91], _bU_, _bT_);
    }
    var _bu_ = caml_ml_string_length(s1$0), _bt_ = 1;
    if(_bu_ >= 1){
     var i$0 = _bt_;
     for(;;){
      var _bR_ = at(i$0, 0);
      caml_check_bound(table, _bR_)[1 + _bR_] = i$0;
      var _bS_ = i$0 + 1 | 0;
      if(_bu_ === i$0) break;
      var i$0 = _bS_;
     }
    }
    var _bw_ = caml_ml_string_length(s2$0), _bv_ = 1;
    if(_bw_ >= 1){
     var j = _bv_;
     for(;;){
      var _by_ = at(0, j);
      caml_check_bound(table, _by_)[1 + _by_] = j;
      var _bA_ = caml_ml_string_length(s1$0), _bz_ = 1;
      if(_bA_ >= 1){
       var i = _bz_;
       for(;;){
        var
         _bC_ = caml_string_get(s2$0, caml_call2(Base_Import[93], j, 1)),
         _bD_ = caml_string_get(s1$0, caml_call2(Base_Import[93], i, 1));
        if(caml_call2(Base_Char[16], _bD_, _bC_)){
         var
          _bE_ = caml_call2(Base_Import[93], j, 1),
          _bF_ = at(caml_call2(Base_Import[93], i, 1), _bE_),
          _bG_ = caml_check_bound(table, _bF_)[1 + _bF_],
          _bH_ = at(i, j);
         caml_check_bound(table, _bH_)[1 + _bH_] = _bG_;
        }
        else{
         var
          _bJ_ = caml_call2(Base_Import[93], j, 1),
          _bK_ = at(caml_call2(Base_Import[93], i, 1), _bJ_),
          sub = caml_check_bound(table, _bK_)[1 + _bK_],
          _bL_ = at(caml_call2(Base_Import[93], i, 1), j),
          add = caml_check_bound(table, _bL_)[1 + _bL_],
          _bM_ = at(i, caml_call2(Base_Import[93], j, 1)),
          del = caml_check_bound(table, _bM_)[1 + _bM_],
          _bN_ = caml_call2(Base_Import[101], add, del),
          _bO_ = caml_call2(Base_Import[101], sub, _bN_),
          _bP_ = caml_call2(Base_Import[91], 1, _bO_),
          _bQ_ = at(i, j);
         caml_check_bound(table, _bQ_)[1 + _bQ_] = _bP_;
        }
        var _bI_ = i + 1 | 0;
        if(_bA_ === i) break;
        var i = _bI_;
       }
      }
      var _bB_ = j + 1 | 0;
      if(_bw_ === j) break;
      var j = _bB_;
     }
    }
    var _bx_ = at(caml_ml_string_length(s1$0), caml_ml_string_length(s2$0));
    return caml_check_bound(table, _bx_)[1 + _bx_];
   }
   function build_and_validate_escapeworth
   (escapeworthy_map, escape_char, func){
    var
     escapeworthy_map$0 =
       caml_call3
         (Base_List[137][7], escapeworthy_map, Base_Char[16], escape_char)
        ? escapeworthy_map
        : [0, [0, escape_char, escape_char], escapeworthy_map],
     arr = caml_call2(Base_Array0[4], 256, -1),
     vals = caml_call2(Base_Array0[4], 256, 0),
     param = escapeworthy_map$0;
    for(;;){
     if(! param) return [0, arr];
     var l = param[2], match = param[1], c_to = match[2], c_from = match[1];
     if(919809722 <= func)
      var v = c_from, k = caml_call1(Base_Char[32], c_to);
     else
      var k$0 = caml_call1(Base_Char[32], c_from), v = c_to, k = k$0;
     if(-1 !== caml_check_bound(arr, k)[1 + k]) break;
     var _bj_ = caml_call1(Base_Char[32], v);
     if(caml_check_bound(vals, _bj_)[1 + _bj_]) break;
     var _bp_ = caml_call1(Base_Char[32], v);
     caml_check_bound(arr, k)[1 + k] = _bp_;
     var _bq_ = caml_call1(Base_Char[32], v);
     caml_check_bound(vals, _bq_)[1 + _bq_] = 1;
     var param = l;
    }
    var
     _bk_ = caml_call2(Base_Import[147], Base_Import[138], Base_Import[138]),
     _bl_ =
       [0,
        [0,
         cst_escapeworthy_map,
         caml_call2(Base_Import[149], _bk_, escapeworthy_map$0)],
        0],
     _bm_ = [0, [0, cst_c_to, caml_call1(Base_Import[138], c_to)], _bl_],
     _bn_ = [0, [0, cst_c_from, caml_call1(Base_Import[138], c_from)], _bm_],
     _bo_ = caml_call2(Base_Sexp[10], cst_escapeworthy_map_not_one_t, _bn_);
    return caml_call1(Base_Or_error[39], _bo_);
   }
   function escape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 258914209);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var
              to_escape_len = [0, 0],
              to_escape =
                foldi
                 (src,
                  0,
                  function(i, acc, c){
                   var
                    _bi_ = caml_call1(Base_Char[32], c),
                    n = caml_check_bound(escapeworthy, _bi_)[1 + _bi_];
                   return -1 === n
                           ? acc
                           : (to_escape_len
                              [1]++,
                             [0, [0, i, caml_call1(Base_Char[35], n)], acc]);
                  });
             if(! to_escape) return src;
             var
              last_idx = caml_ml_string_length(src),
              last_dst_pos =
                caml_call2(Base_Import[91], last_idx, to_escape_len[1]),
              dst = caml_call1(Base_Bytes0[7], last_dst_pos),
              last_idx$0 = last_idx,
              last_dst_pos$0 = last_dst_pos,
              param = to_escape;
             for(;;){
              if(! param){
               caml_call5(Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
               return caml_string_of_bytes(dst);
              }
              var
               to_escape$0 = param[2],
               match = param[1],
               escaped_char = match[2],
               last_idx$1 = match[1],
               _bg_ = caml_call2(Base_Import[93], last_idx$0, last_idx$1),
               len = caml_call2(Base_Import[93], _bg_, 1),
               dst_pos = caml_call2(Base_Import[93], last_dst_pos$0, len),
               _bh_ = caml_call2(Base_Import[91], last_idx$1, 1);
              caml_call5(Base_Bytes0[4], src, _bh_, dst, dst_pos, len);
              var last_dst_pos$1 = caml_call2(Base_Import[93], dst_pos, 2);
              caml_bytes_set(dst, last_dst_pos$1, escape_char);
              caml_bytes_set
               (dst,
                caml_call2(Base_Import[91], last_dst_pos$1, 1),
                escaped_char);
              var
               last_idx$0 = last_idx$1,
               last_dst_pos$0 = last_dst_pos$1,
               param = to_escape$0;
             }
            }];
   }
   function escape_gen_exn(escapeworthy_map, escape_char){
    var _bf_ = escape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[34], _bf_));
   }
   function escape(escapeworthy, escape_char){
    var
     _bd_ = caml_call2(Base_List[126], escapeworthy, Base_Char[17]),
     _be_ = Base_List[53],
     escapeworthy_map = caml_call2(_be_, _bd_, function(c){return [0, c, c];});
    return escape_gen_exn(escapeworthy_map, escape_char);
   }
   function unescape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 919809722);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var i = 0, status = -512962225, to_unescape = 0;
             for(;;){
              if(caml_ml_string_length(src) <= i) break;
              if(-512962225 <= status)
               var
                _a7_ = caml_string_get(src, i),
                status$0 =
                  caml_call2(Base_Char[16], _a7_, escape_char)
                   ? -767030498
                   : -512962225;
              else
               var status$0 = -244189789;
              var
               acc =
                 -512962225 <= status$0 ? to_unescape : [0, i, to_unescape],
               i$0 = caml_call2(Base_Import[91], i, 1),
               i = i$0,
               status = status$0,
               to_unescape = acc;
             }
             if(! to_unescape) return src;
             var
              to_unescape$0 = to_unescape[2],
              idx = to_unescape[1],
              _a8_ = caml_call1(Base_List[45], to_unescape),
              _a9_ =
                caml_call2(Base_Import[93], caml_ml_string_length(src), _a8_),
              dst = caml_call1(Base_Bytes0[7], _a9_);
             function loop(last_idx, last_dst_pos, param){
              var
               last_idx$0 = last_idx,
               last_dst_pos$0 = last_dst_pos,
               param$0 = param;
              for(;;){
               if(! param$0)
                return caml_call5(Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
               var
                to_unescape = param$0[2],
                last_idx$1 = param$0[1],
                _a__ = caml_call2(Base_Import[93], last_idx$0, last_idx$1),
                len = caml_call2(Base_Import[93], _a__, 2),
                dst_pos = caml_call2(Base_Import[93], last_dst_pos$0, len),
                _a$_ = caml_call2(Base_Import[91], last_idx$1, 2);
               caml_call5(Base_Bytes0[4], src, _a$_, dst, dst_pos, len);
               var
                last_dst_pos$1 = caml_call2(Base_Import[93], dst_pos, 1),
                _ba_ =
                  caml_string_get
                   (src, caml_call2(Base_Import[91], last_idx$1, 1)),
                _bb_ = caml_call1(Base_Char[32], _ba_),
                n = caml_check_bound(escapeworthy, _bb_)[1 + _bb_],
                _bc_ =
                  -1 === n
                   ? caml_string_get
                     (src, caml_call2(Base_Import[91], last_idx$1, 1))
                   : caml_call1(Base_Char[35], n);
               caml_bytes_set(dst, last_dst_pos$1, _bc_);
               var
                last_idx$0 = last_idx$1,
                last_dst_pos$0 = last_dst_pos$1,
                param$0 = to_unescape;
              }
             }
             if
              (idx
               < caml_call2(Base_Import[93], caml_ml_string_length(src), 1))
              loop
               (caml_ml_string_length(src),
                caml_ml_bytes_length(dst),
                to_unescape);
             else
              loop
               (caml_call2(Base_Import[93], caml_ml_string_length(src), 1),
                caml_ml_bytes_length(dst),
                to_unescape$0);
             return caml_string_of_bytes(dst);
            }];
   }
   function unescape_gen_exn(escapeworthy_map, escape_char){
    var _a6_ = unescape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[34], _a6_));
   }
   function unescape(escape_char){return unescape_gen_exn(0, escape_char);}
   function preceding_escape_chars(str, escape_char, pos){
    var p$1 = caml_call2(Base_Import[93], pos, 1), p = p$1, cnt = 0;
    for(;;){
     if(0 <= p){
      var _a5_ = caml_string_get(str, p);
      if(! caml_call2(Base_Char[15], _a5_, escape_char)){
       var
        cnt$0 = caml_call2(Base_Import[91], cnt, 1),
        p$0 = caml_call2(Base_Import[93], p, 1),
        p = p$0,
        cnt = cnt$0;
       continue;
      }
     }
     return cnt;
    }
   }
   function update_escape_status(str, escape_char, i, param){
    if(-512962225 > param) return -244189789;
    var _a4_ = caml_string_get(str, i);
    return caml_call2(Base_Char[16], _a4_, escape_char)
            ? -767030498
            : -512962225;
   }
   function escape_status(str, escape_char, pos){
    var
     _a2_ = preceding_escape_chars(str, escape_char, pos),
     odd = 1 === caml_call2(Base_Import[122], _a2_, 2) ? 1 : 0,
     _a3_ = caml_string_get(str, pos),
     match = caml_call2(Base_Char[16], _a3_, escape_char);
    return odd ? -244189789 : match ? -767030498 : -512962225;
   }
   function check_bound(str, pos, function_name){
    var
     _a0_ = caml_ml_string_length(str) <= pos ? 1 : 0,
     _a1_ = _a0_ || (pos < 0 ? 1 : 0);
    return _a1_ ? caml_call3(invalid_argf, _G_, function_name, 0) : _a1_;
   }
   function is_char_escaping(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaping);
    return -512962225 <= escape_status(str, escape_char, pos) ? 0 : 1;
   }
   function is_char_escaped(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaped);
    return -244189789 <= escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function is_char_literal(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_literal);
    return -512962225 === escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function index_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_index_from);
    var
     status$1 = escape_status(str, escape_char, pos),
     i = pos,
     status = status$1;
    for(;;){
     if(pos <= i){
      var _aY_ = -512962225 === status ? 1 : 0;
      if(_aY_){
       var _aZ_ = caml_string_get(str, i);
       if(caml_call2(Base_Char[16], _aZ_, char$0)) return [0, i];
      }
     }
     var i$0 = caml_call2(Base_Import[91], i, 1);
     if(caml_ml_string_length(str) <= i$0) return 0;
     var
      status$0 = update_escape_status(str, escape_char, i$0, status),
      i = i$0,
      status = status$0;
    }
   }
   function index_from_exn$0(str, escape_char, pos, char$0){
    var match = index_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _aU_ = [0, [0, cst_char, caml_call1(Base_Import[138], char$0)], 0],
     _aV_ = [0, [0, cst_pos, caml_call1(Base_Import[139], pos)], _aU_],
     _aW_ =
       [0,
        [0, cst_escape_char, caml_call1(Base_Import[138], escape_char)],
        _aV_],
     _aX_ = [0, [0, cst_str, caml_call1(sexp_of_t, str)], _aW_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[10], cst_index_from_exn_not_found, _aX_));
   }
   function index$1(str, escape_char, char$0){
    return index_from$0(str, escape_char, 0, char$0);
   }
   function index_exn$1(str, escape_char, char$0){
    return index_from_exn$0(str, escape_char, 0, char$0);
   }
   function rindex_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_rindex_from);
    if(caml_call2(Base_Char[16], char$0, escape_char)) return 0;
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) return 0;
     var escape_chars = preceding_escape_chars(str, escape_char, pos$0);
     if(0 === caml_call2(Base_Import[122], escape_chars, 2)){
      var _aS_ = caml_string_get(str, pos$0);
      if(caml_call2(Base_Char[16], _aS_, char$0)) return [0, pos$0];
     }
     var
      _aT_ = caml_call2(Base_Import[93], pos$0, escape_chars),
      pos$1 = caml_call2(Base_Import[93], _aT_, 1),
      pos$0 = pos$1;
    }
   }
   function rindex_from_exn$0(str, escape_char, pos, char$0){
    var match = rindex_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _aO_ = [0, [0, cst_char$0, caml_call1(Base_Import[138], char$0)], 0],
     _aP_ = [0, [0, cst_pos$0, caml_call1(Base_Import[139], pos)], _aO_],
     _aQ_ =
       [0,
        [0, cst_escape_char$0, caml_call1(Base_Import[138], escape_char)],
        _aP_],
     _aR_ = [0, [0, cst_str$0, caml_call1(sexp_of_t, str)], _aQ_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[10], cst_rindex_from_exn_not_found, _aR_));
   }
   function rindex$0(str, escape_char, char$0){
    return is_empty(str)
            ? 0
            : rindex_from$0
              (str,
               escape_char,
               caml_call2(Base_Import[93], caml_ml_string_length(str), 1),
               char$0);
   }
   function rindex_exn$0(str, escape_char, char$0){
    return rindex_from_exn$0
            (str,
             escape_char,
             caml_call2(Base_Import[93], caml_ml_string_length(str), 1),
             char$0);
   }
   function split_gen$0(str, escape_char, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[16], c$0, c);};
    var
     len = caml_ml_string_length(str),
     acc = 0,
     status = -512962225,
     last_pos = 0,
     pos = 0;
    for(;;){
     if(pos === len){
      var
       _aM_ =
         [0,
          sub(str, last_pos, caml_call2(Base_Import[93], len, last_pos)),
          acc];
      return caml_call1(Base_List[63], _aM_);
     }
     var
      status$0 = update_escape_status(str, escape_char, pos, status),
      _aN_ = -512962225 === status$0 ? 1 : 0;
     if(_aN_ && is_delim(caml_string_get(str, pos))){
      var
       sub_str =
         sub(str, last_pos, caml_call2(Base_Import[93], pos, last_pos)),
       pos$0 = caml_call2(Base_Import[91], pos, 1),
       last_pos$0 = caml_call2(Base_Import[91], pos, 1),
       acc$0 = [0, sub_str, acc],
       acc = acc$0,
       status = status$0,
       last_pos = last_pos$0,
       pos = pos$0;
      continue;
     }
     var
      pos$1 = caml_call2(Base_Import[91], pos, 1),
      status = status$0,
      pos = pos$1;
    }
   }
   function split$0(str, on){
    var _aK_ = [0, -1044422954, on];
    return function(_aL_){return split_gen$0(str, _aL_, _aK_);};
   }
   function split_on_chars$0(str, chars){
    var _aI_ = [0, 552554919, chars];
    return function(_aJ_){return split_gen$0(str, _aJ_, _aI_);};
   }
   function split_at(str, pos){
    var
     _aF_ = caml_call2(Base_Import[93], caml_ml_string_length(str), pos),
     _aG_ = caml_call2(Base_Import[93], _aF_, 1),
     _aH_ = sub(str, caml_call2(Base_Import[91], pos, 1), _aG_);
    return [0, sub(str, 0, pos), _aH_];
   }
   function lsplit2$0(str, on, escape_char){
    function _aD_(x){return split_at(str, x);}
    var _aE_ = index$1(str, escape_char, on);
    return caml_call2(Base_Option[24], _aE_, _aD_);
   }
   function rsplit2$0(str, on, escape_char){
    function _aB_(x){return split_at(str, x);}
    var _aC_ = rindex$0(str, escape_char, on);
    return caml_call2(Base_Option[24], _aC_, _aB_);
   }
   function lsplit2_exn$0(str, on, escape_char){
    return split_at(str, index_exn$1(str, escape_char, on));
   }
   function rsplit2_exn$0(str, on, escape_char){
    return split_at(str, rindex_exn$0(str, escape_char, on));
   }
   function last_non_drop_literal(drop, escape_char, t){
    return rfindi
            (0,
             t,
             function(i, c){
              var _ay_ = 1 - caml_call1(drop, c);
              if(_ay_)
               var _az_ = _ay_;
              else{
               var _aA_ = is_char_escaping(t, escape_char, i);
               if(! _aA_) return is_char_escaped(t, escape_char, i);
               var _az_ = _aA_;
              }
              return _az_;
             });
   }
   function first_non_drop_literal(drop, escape_char, t){
    return lfindi
            (0,
             t,
             function(i, c){
              var _av_ = 1 - caml_call1(drop, c);
              if(_av_)
               var _aw_ = _av_;
              else{
               var _ax_ = is_char_escaping(t, escape_char, i);
               if(! _ax_) return is_char_escaped(t, escape_char, i);
               var _aw_ = _ax_;
              }
              return _aw_;
             });
   }
   function rstrip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[45];
    var match = last_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$10;
    var i = match[1];
    return i === caml_call2(Base_Import[93], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[91], i, 1));
   }
   function lstrip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[45];
    var match = first_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$11;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[45];
    var length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[93], length, 1))))
      break a;
     var match = first_non_drop_literal(drop, escape_char, t);
     if(! match) return cst$12;
     var
      first = match[1],
      match$0 = last_non_drop_literal(drop, escape_char, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
     var last = match$0[1], _au_ = caml_call2(Base_Import[93], last, first);
     return sub(t, first, caml_call2(Base_Import[91], _au_, 1));
    }
    return t;
   }
   function between$0(t, low, high){
    var _at_ = caml_call2(Base_Import[109][2], low, t);
    return _at_ ? caml_call2(Base_Import[109][2], t, high) : _at_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[109][1], t, min)
            ? min
            : caml_call2(Base_Import[109][2], t, max) ? t : max;
   }
   function clamp_exn$0(t, min, max){
    if(caml_call2(Base_Import[109][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _I_], 1);
   }
   function clamp$0(t, min, max){
    if(! caml_call2(Base_Import[109][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _aq_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _ar_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _aq_],
     _as_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _ar_);
    return caml_call1(Base_Or_error[39], _as_);
   }
   function create$0(opt, pattern){
    if(opt)
     var sth = opt[1], case_sensitive = sth;
    else
     var case_sensitive = 1;
    return create(pattern, case_sensitive);
   }
   function Make_utf(Format){
    var
     codec_name = Format[1],
     is_valid = Format[3],
     raise_get_message =
       [246,
        function(_ap_){
         return caml_call3(Base_Printf[2], _J_, Format[2], Format[1]);
        }];
    function raise_get(t, pos){
     var
      _am_ =
        [0,
         [0, cst$13, [0, t]],
         [0, [0, cst_pos$1, caml_call1(Base_Import[139], pos)], 0]],
      _an_ = runtime.caml_obj_tag(raise_get_message);
     a:
     if(250 === _an_)
      var _ao_ = raise_get_message[1];
     else{
      if(246 !== _an_ && 244 !== _an_){var _ao_ = raise_get_message; break a;}
      var _ao_ = caml_call1(CamlinternalLazy[2], raise_get_message);
     }
     return caml_call1(raise_s, caml_call2(Base_Sexp[10], _ao_, _am_));
    }
    function get(t, byte_pos){
     var decode = caml_call2(Format[5], t, byte_pos);
     return caml_call1(Base_Uchar0[18], decode)
             ? caml_call1(Base_Uchar0[19], decode)
             : raise_get(t, byte_pos);
    }
    function to_string(_al_){return _al_;}
    function of_string_unchecked(_ak_){return _ak_;}
    var
     raise_of_string_message =
       caml_call2
        (concat,
         0,
         [0, Format[2], [0, cst_of_string_invalid, [0, codec_name, 0]]]);
    function raise_of_string(string){
     return caml_call1
             (raise_s,
              caml_call2
               (Base_Sexp[10],
                raise_of_string_message,
                [0, [0, cst$14, [0, string]], 0]));
    }
    function of_string(string){
     return caml_call1(is_valid, string) ? string : raise_of_string(string);
    }
    var
     include = caml_call1(Base_Sexpable[5], [0, of_string, to_string]),
     t_sexp_grammar = include[1],
     t_of_sexp = include[2],
     sexp_of_t = include[3],
     compare = Base_Import[109][9];
    function hash(_aj_){return runtime.Base_hash_string(_aj_);}
    var
     module_name = Format[2],
     include$0 =
       caml_call1
        (Base_Identifiable[1],
         [0,
          compare,
          hash_fold_t,
          hash,
          t_of_sexp,
          sexp_of_t,
          of_string,
          to_string,
          module_name]),
     hash_fold_t$0 = include$0[1],
     hash$0 = include$0[2],
     t_of_sexp$0 = include$0[3],
     sexp_of_t$0 = include$0[4],
     of_string$0 = include$0[5],
     to_string$0 = include$0[6],
     symbol = include$0[7],
     symbol$0 = include$0[8],
     symbol$1 = include$0[9],
     symbol$2 = include$0[10],
     symbol$3 = include$0[11],
     symbol$4 = include$0[12],
     equal = include$0[13],
     compare$0 = include$0[14],
     min = include$0[15],
     max = include$0[16],
     ascending = include$0[17],
     descending = include$0[18],
     between = include$0[19],
     clamp_exn = include$0[20],
     clamp = include$0[21],
     comparator = include$0[22],
     pp = include$0[23],
     hashable = include$0[24];
    function to_sequence(t){
     var len = caml_ml_string_length(t);
     function _ag_(byte_pos){
      if(len <= byte_pos) return 0;
      var
       decode = caml_call2(Format[5], t, byte_pos),
       _ah_ = caml_call1(Base_Uchar0[20], decode),
       _ai_ = caml_call2(Base_Import[91], byte_pos, _ah_);
      return [0, [0, caml_call1(Base_Uchar0[19], decode), _ai_]];
     }
     return caml_call2(Base_Sequence[45], 0, _ag_);
    }
    function fold(t, acc, f){
     var len = caml_ml_string_length(t), byte_pos = 0, acc$0 = acc;
     for(;;){
      if(byte_pos === len) return acc$0;
      var
       decode = caml_call2(Format[5], t, byte_pos),
       acc$1 = caml_call2(f, acc$0, caml_call1(Base_Uchar0[19], decode)),
       _af_ = caml_call1(Base_Uchar0[20], decode),
       byte_pos$0 = caml_call2(Base_Import[91], byte_pos, _af_),
       byte_pos = byte_pos$0,
       acc$0 = acc$1;
     }
    }
    function sanitize(t){
     var
      len =
        fold
         (t,
          0,
          function(pos, uchar){
           var _ae_ = caml_call1(Format[4], uchar);
           return caml_call2(Base_Import[91], pos, _ae_);
          }),
      bytes = caml_call1(Base_Bytes0[7], len),
      pos =
        fold
         (t,
          0,
          function(pos, uchar){
           var _ad_ = caml_call3(Format[6], bytes, pos, uchar);
           return caml_call2(Base_Import[91], pos, _ad_);
          });
     if(pos === len) return caml_string_of_bytes(bytes);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _K_], 1);
    }
    function of_list(uchars){
     function _$_(n, u){
      var _ac_ = caml_call1(Format[4], u);
      return caml_call2(Base_Import[91], n, _ac_);
     }
     var
      len = caml_call3(Base_List[20], uchars, 0, _$_),
      bytes = caml_call1(Base_Bytes0[7], len);
     function _aa_(pos, uchar){
      var _ab_ = caml_call3(Format[6], bytes, pos, uchar);
      return caml_call2(Base_Import[91], pos, _ab_);
     }
     var pos = caml_call3(Base_List[20], uchars, 0, _aa_);
     if(pos === len) return caml_string_of_bytes(bytes);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
    }
    function of_array(uchars){
     var
      len = [0, 0],
      _S_ = caml_call2(Base_Import[93], uchars.length - 1, 1),
      _R_ = 0;
     if(_S_ >= 0){
      var i$0 = _R_;
      for(;;){
       var
        _Y_ = caml_check_bound(uchars, i$0)[1 + i$0],
        _Z_ = caml_call1(Format[4], _Y_);
       len[1] = caml_call2(Base_Import[91], len[1], _Z_);
       var ___ = i$0 + 1 | 0;
       if(_S_ === i$0) break;
       var i$0 = ___;
      }
     }
     var
      bytes = caml_call1(Base_Bytes0[7], len[1]),
      pos = [0, 0],
      _U_ = caml_call2(Base_Import[93], uchars.length - 1, 1),
      _T_ = 0;
     if(_U_ >= 0){
      var i = _T_;
      for(;;){
       var
        _V_ = caml_check_bound(uchars, i)[1 + i],
        _W_ = caml_call3(Format[6], bytes, pos[1], _V_);
       pos[1] = caml_call2(Base_Import[91], pos[1], _W_);
       var _X_ = i + 1 | 0;
       if(_U_ === i) break;
       var i = _X_;
      }
     }
     if(pos[1] === len[1]) return caml_string_of_bytes(bytes);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
    }
    function concat$0(list){return caml_call2(concat, _N_, list);}
    function split(t, on){
     var len = caml_ml_string_length(t), until = 0, start$1 = 0;
     for(;;){
      if(until === len)
       return [0,
               sub(t, start$1, caml_call2(Base_Import[93], until, start$1)),
               0];
      var
       uchar = get(t, until),
       _P_ = caml_call1(Format[4], uchar),
       until$0 = caml_call2(Base_Import[91], until, _P_);
      if(caml_call2(Base_Uchar0[11], uchar, on)) break;
      var until = until$0;
     }
     var
      block =
        [0,
         sub(t, start$1, caml_call2(Base_Import[93], until, start$1)),
         24029],
      dst = block,
      offset = 1,
      start = until$0,
      until$1 = until$0;
     for(;;){
      if(until$1 === len){
       dst[1 + offset] =
        [0, sub(t, start, caml_call2(Base_Import[93], until$1, start)), 0];
       return block;
      }
      var
       uchar$0 = get(t, until$1),
       _Q_ = caml_call1(Format[4], uchar$0),
       start$0 = caml_call2(Base_Import[91], until$1, _Q_);
      if(caml_call2(Base_Uchar0[11], uchar$0, on)){
       var
        dst$0 =
          [0,
           sub(t, start, caml_call2(Base_Import[93], until$1, start)),
           24029];
       dst[1 + offset] = dst$0;
       var dst = dst$0, offset = 1, start = start$0, until$1 = start$0;
      }
      else
       var until$1 = start$0;
     }
    }
    var
     C =
       caml_call1
        (Base_Indexed_container[12],
         [0,
          [0, Base_Uchar0[11]],
          of_list,
          of_array,
          concat$0,
          fold,
          -304398144,
          -304398144,
          -304398144,
          -304398144,
          348729712,
          -637740141]),
     append = C[3],
     concat_map = C[8],
     concat_mapi = C[39],
     count = C[20],
     counti = C[32],
     exists = C[18],
     existsi = C[30],
     filter = C[6],
     filter_map = C[7],
     filter_mapi = C[38],
     filteri = C[37],
     find = C[22],
     find_map = C[23],
     find_mapi = C[34],
     findi = C[33],
     fold_result = C[16],
     fold_until = C[17],
     foldi = C[28],
     for_all = C[19],
     for_alli = C[31],
     init = C[35],
     is_empty = C[13],
     iter = C[14],
     iteri = C[29],
     length = C[12],
     map = C[5],
     mapi = C[36],
     max_elt = C[27],
     mem = C[11],
     min_elt = C[26],
     partition_map = C[10],
     partition_tf = C[9],
     sum = C[21],
     to_array = C[25],
     to_list = C[24];
    return [0,
            codec_name,
            is_valid,
            ,
            ,
            get,
            of_string_unchecked,
            ,
            ,
            t_sexp_grammar,
            hash_fold_t$0,
            hash$0,
            t_of_sexp$0,
            sexp_of_t$0,
            of_string$0,
            to_string$0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare$0,
            min,
            max,
            ascending,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator,
            pp,
            hashable,
            to_sequence,
            fold,
            sanitize,
            of_list,
            of_array,
            concat$0,
            split,
            ,
            append,
            concat_map,
            concat_mapi,
            count,
            counti,
            exists,
            existsi,
            filter,
            filter_map,
            filter_mapi,
            filteri,
            find,
            find_map,
            find_mapi,
            findi,
            fold_result,
            fold_until,
            foldi,
            for_all,
            for_alli,
            init,
            is_empty,
            iter,
            iteri,
            length,
            map,
            mapi,
            max_elt,
            mem,
            min_elt,
            partition_map,
            partition_tf,
            sum,
            to_array,
            to_list,
            length];
   }
   var
    byte_length = Base_Uchar0[16],
    set = Base_Bytes0[8],
    Utf8 =
      Make_utf
       ([0,
         codec_name,
         module_name,
         is_valid_utf_8,
         byte_length,
         get_utf_8_uchar,
         set]),
    byte_length$0 = Base_Uchar0[17],
    set$0 = Base_Bytes0[9],
    Utf16le =
      Make_utf
       ([0,
         codec_name$0,
         module_name$0,
         is_valid_utf_16le,
         byte_length$0,
         get_utf_16le_uchar,
         set$0]),
    byte_length$1 = Base_Uchar0[17],
    set$1 = Base_Bytes0[10],
    Utf16be =
      Make_utf
       ([0,
         codec_name$1,
         module_name$1,
         is_valid_utf_16be,
         byte_length$1,
         get_utf_16be_uchar,
         set$1]);
   function Make_utf32(Format){
    function byte_length(param){return 4;}
    var
     codec_name = Format[1],
     module_name = Format[2],
     set = Format[4],
     get_decode_result = Format[3];
    function is_valid(t){
     var len = caml_ml_string_length(t);
     if(0 !== caml_call2(Base_Import[122], len, 4)) return 0;
     var byte_pos = 0;
     for(;;){
      if(byte_pos >= len) return 1;
      var
       result = caml_call2(Format[3], t, byte_pos),
       _O_ = caml_call1(Base_Uchar0[18], result);
      if(! _O_) return _O_;
      var
       byte_pos$0 = caml_call2(Base_Import[91], byte_pos, 4),
       byte_pos = byte_pos$0;
     }
    }
    return Make_utf
            ([0,
              codec_name,
              module_name,
              is_valid,
              byte_length,
              get_decode_result,
              set]);
   }
   var
    set$2 = Base_Bytes0[12],
    Utf32le =
      Make_utf32([0, codec_name$2, module_name$2, get_utf_32le_uchar, set$2]),
    set$3 = Base_Bytes0[13],
    Utf32be =
      Make_utf32([0, codec_name$3, module_name$3, get_utf_32be_uchar, set$3]),
    include$1 = Base_Import[109],
    symbol$6 = include$1[1],
    symbol$7 = include$1[2],
    symbol$8 = include$1[3],
    symbol$9 = include$1[4],
    symbol$10 = include$1[5],
    symbol$11 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    compare_local$0 = include$1[10],
    equal$1 = include$1[11],
    equal_local$0 = include$1[12],
    max$0 = include$1[13],
    min$0 = include$1[14],
    Base_String =
      [0,
       globalize,
       t_sexp_grammar,
       sub,
       unsafe_sub,
       subo,
       of_char_list,
       of_array,
       symbol,
       map,
       filter,
       filter_map,
       partition_tf,
       partition_map,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init,
       mapi,
       filteri,
       filter_mapi,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$11,
       symbol$7,
       symbol$9,
       symbol$10,
       symbol$6,
       symbol$8,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator,
       pp,
       hashable,
       compare_local$0,
       invariant,
       max_length,
       mem,
       make,
       symbol,
       concat,
       escaped,
       contains,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       [0,
        hash_fold_t$0,
        hash$0,
        t_of_sexp$0,
        sexp_of_t$2,
        t_sexp_grammar$0,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$5,
        equal$0,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator$0,
        compare_local,
        is_suffix,
        is_prefix,
        is_substring$0,
        is_substring_at,
        substr_index$0,
        substr_index_exn$0,
        substr_index_all$0,
        substr_replace_first$0,
        substr_replace_all$0],
       index,
       index_exn,
       index_from,
       index_from_exn,
       rindex,
       rindex_exn,
       rindex_from,
       rindex_from_exn,
       to_sequence,
       of_sequence,
       [0,
        sexp_of_t$0,
        create$0,
        pattern,
        case_sensitive,
        matches,
        index$0,
        index_exn$0,
        index_all,
        replace_first,
        replace_all,
        split_on,
        [0, equal, equal_local, sexp_of_t$1, representation]],
       substr_index,
       substr_index_exn,
       substr_index_all,
       substr_replace_first,
       substr_replace_all,
       is_substring,
       is_substring_at$0,
       to_list_rev,
       rev,
       is_suffix$0,
       is_prefix$0,
       lsplit2_exn,
       rsplit2_exn,
       lsplit2,
       rsplit2,
       split,
       split_on_chars,
       split_lines,
       lfindi,
       rfindi,
       lstrip,
       rstrip,
       strip,
       concat_map,
       concat_mapi,
       tr,
       tr_multi,
       chop_suffix_exn,
       chop_prefix_exn,
       chop_suffix,
       chop_prefix,
       chop_suffix_if_exists,
       chop_prefix_if_exists,
       suffix,
       prefix,
       drop_suffix,
       drop_prefix,
       common_suffix,
       common_prefix,
       common_suffix_length,
       common_prefix_length,
       common_suffix2,
       common_prefix2,
       common_suffix2_length,
       common_prefix2_length,
       concat_array,
       concat_lines,
       equal$1,
       equal_local$0,
       of_char,
       of_char_list,
       pad_left,
       pad_right,
       edit_distance,
       [0,
        escape_gen_exn,
        escape_gen,
        escape,
        unescape_gen_exn,
        unescape_gen,
        unescape,
        is_char_escaping,
        is_char_escaped,
        is_char_literal,
        index$1,
        index_exn$1,
        rindex$0,
        rindex_exn$0,
        index_from$0,
        index_from_exn$0,
        rindex_from$0,
        rindex_from_exn$0,
        split$0,
        split_on_chars$0,
        lsplit2$0,
        lsplit2_exn$0,
        rsplit2$0,
        rsplit2_exn$0,
        lstrip_literal,
        rstrip_literal,
        strip_literal],
       [0,
        Utf8[9],
        Utf8[10],
        Utf8[11],
        Utf8[12],
        Utf8[13],
        Utf8[14],
        Utf8[15],
        Utf8[16],
        Utf8[17],
        Utf8[18],
        Utf8[19],
        Utf8[20],
        Utf8[21],
        Utf8[22],
        Utf8[23],
        Utf8[24],
        Utf8[25],
        Utf8[26],
        Utf8[27],
        Utf8[28],
        Utf8[29],
        Utf8[30],
        Utf8[31],
        Utf8[32],
        Utf8[33],
        Utf8[37],
        Utf8[38],
        Utf8[42],
        Utf8[39],
        Utf8[67],
        Utf8[49],
        Utf8[50],
        Utf8[43],
        Utf8[73],
        Utf8[72],
        Utf8[70],
        Utf8[63],
        Utf8[64],
        Utf8[35],
        Utf8[57],
        Utf8[58],
        Utf8[47],
        Utf8[60],
        Utf8[45],
        Utf8[74],
        Utf8[53],
        Utf8[54],
        Utf8[76],
        Utf8[75],
        Utf8[71],
        Utf8[69],
        Utf8[59],
        Utf8[65],
        Utf8[48],
        Utf8[61],
        Utf8[46],
        Utf8[56],
        Utf8[55],
        Utf8[62],
        Utf8[68],
        Utf8[52],
        Utf8[51],
        Utf8[44],
        Utf8[34],
        Utf8[2],
        Utf8[36],
        Utf8[5],
        Utf8[6],
        Utf8[40],
        Utf8[1],
        Utf8[77],
        Utf8[66]],
       [0,
        Utf16le[9],
        Utf16le[10],
        Utf16le[11],
        Utf16le[12],
        Utf16le[13],
        Utf16le[14],
        Utf16le[15],
        Utf16le[16],
        Utf16le[17],
        Utf16le[18],
        Utf16le[19],
        Utf16le[20],
        Utf16le[21],
        Utf16le[22],
        Utf16le[23],
        Utf16le[24],
        Utf16le[25],
        Utf16le[26],
        Utf16le[27],
        Utf16le[28],
        Utf16le[29],
        Utf16le[30],
        Utf16le[31],
        Utf16le[32],
        Utf16le[33],
        Utf16le[37],
        Utf16le[38],
        Utf16le[42],
        Utf16le[39],
        Utf16le[67],
        Utf16le[49],
        Utf16le[50],
        Utf16le[43],
        Utf16le[73],
        Utf16le[72],
        Utf16le[70],
        Utf16le[63],
        Utf16le[64],
        Utf16le[35],
        Utf16le[57],
        Utf16le[58],
        Utf16le[47],
        Utf16le[60],
        Utf16le[45],
        Utf16le[74],
        Utf16le[53],
        Utf16le[54],
        Utf16le[76],
        Utf16le[75],
        Utf16le[71],
        Utf16le[69],
        Utf16le[59],
        Utf16le[65],
        Utf16le[48],
        Utf16le[61],
        Utf16le[46],
        Utf16le[56],
        Utf16le[55],
        Utf16le[62],
        Utf16le[68],
        Utf16le[52],
        Utf16le[51],
        Utf16le[44],
        Utf16le[34],
        Utf16le[2],
        Utf16le[36],
        Utf16le[5],
        Utf16le[6],
        Utf16le[40],
        Utf16le[1],
        Utf16le[77],
        Utf16le[66]],
       [0,
        Utf16be[9],
        Utf16be[10],
        Utf16be[11],
        Utf16be[12],
        Utf16be[13],
        Utf16be[14],
        Utf16be[15],
        Utf16be[16],
        Utf16be[17],
        Utf16be[18],
        Utf16be[19],
        Utf16be[20],
        Utf16be[21],
        Utf16be[22],
        Utf16be[23],
        Utf16be[24],
        Utf16be[25],
        Utf16be[26],
        Utf16be[27],
        Utf16be[28],
        Utf16be[29],
        Utf16be[30],
        Utf16be[31],
        Utf16be[32],
        Utf16be[33],
        Utf16be[37],
        Utf16be[38],
        Utf16be[42],
        Utf16be[39],
        Utf16be[67],
        Utf16be[49],
        Utf16be[50],
        Utf16be[43],
        Utf16be[73],
        Utf16be[72],
        Utf16be[70],
        Utf16be[63],
        Utf16be[64],
        Utf16be[35],
        Utf16be[57],
        Utf16be[58],
        Utf16be[47],
        Utf16be[60],
        Utf16be[45],
        Utf16be[74],
        Utf16be[53],
        Utf16be[54],
        Utf16be[76],
        Utf16be[75],
        Utf16be[71],
        Utf16be[69],
        Utf16be[59],
        Utf16be[65],
        Utf16be[48],
        Utf16be[61],
        Utf16be[46],
        Utf16be[56],
        Utf16be[55],
        Utf16be[62],
        Utf16be[68],
        Utf16be[52],
        Utf16be[51],
        Utf16be[44],
        Utf16be[34],
        Utf16be[2],
        Utf16be[36],
        Utf16be[5],
        Utf16be[6],
        Utf16be[40],
        Utf16be[1],
        Utf16be[77],
        Utf16be[66]],
       [0,
        Utf32le[9],
        Utf32le[10],
        Utf32le[11],
        Utf32le[12],
        Utf32le[13],
        Utf32le[14],
        Utf32le[15],
        Utf32le[16],
        Utf32le[17],
        Utf32le[18],
        Utf32le[19],
        Utf32le[20],
        Utf32le[21],
        Utf32le[22],
        Utf32le[23],
        Utf32le[24],
        Utf32le[25],
        Utf32le[26],
        Utf32le[27],
        Utf32le[28],
        Utf32le[29],
        Utf32le[30],
        Utf32le[31],
        Utf32le[32],
        Utf32le[33],
        Utf32le[37],
        Utf32le[38],
        Utf32le[42],
        Utf32le[39],
        Utf32le[67],
        Utf32le[49],
        Utf32le[50],
        Utf32le[43],
        Utf32le[73],
        Utf32le[72],
        Utf32le[70],
        Utf32le[63],
        Utf32le[64],
        Utf32le[35],
        Utf32le[57],
        Utf32le[58],
        Utf32le[47],
        Utf32le[60],
        Utf32le[45],
        Utf32le[74],
        Utf32le[53],
        Utf32le[54],
        Utf32le[76],
        Utf32le[75],
        Utf32le[71],
        Utf32le[69],
        Utf32le[59],
        Utf32le[65],
        Utf32le[48],
        Utf32le[61],
        Utf32le[46],
        Utf32le[56],
        Utf32le[55],
        Utf32le[62],
        Utf32le[68],
        Utf32le[52],
        Utf32le[51],
        Utf32le[44],
        Utf32le[34],
        Utf32le[2],
        Utf32le[36],
        Utf32le[5],
        Utf32le[6],
        Utf32le[40],
        Utf32le[1],
        Utf32le[77],
        Utf32le[66]],
       [0,
        Utf32be[9],
        Utf32be[10],
        Utf32be[11],
        Utf32be[12],
        Utf32be[13],
        Utf32be[14],
        Utf32be[15],
        Utf32be[16],
        Utf32be[17],
        Utf32be[18],
        Utf32be[19],
        Utf32be[20],
        Utf32be[21],
        Utf32be[22],
        Utf32be[23],
        Utf32be[24],
        Utf32be[25],
        Utf32be[26],
        Utf32be[27],
        Utf32be[28],
        Utf32be[29],
        Utf32be[30],
        Utf32be[31],
        Utf32be[32],
        Utf32be[33],
        Utf32be[37],
        Utf32be[38],
        Utf32be[42],
        Utf32be[39],
        Utf32be[67],
        Utf32be[49],
        Utf32be[50],
        Utf32be[43],
        Utf32be[73],
        Utf32be[72],
        Utf32be[70],
        Utf32be[63],
        Utf32be[64],
        Utf32be[35],
        Utf32be[57],
        Utf32be[58],
        Utf32be[47],
        Utf32be[60],
        Utf32be[45],
        Utf32be[74],
        Utf32be[53],
        Utf32be[54],
        Utf32be[76],
        Utf32be[75],
        Utf32be[71],
        Utf32be[69],
        Utf32be[59],
        Utf32be[65],
        Utf32be[48],
        Utf32be[61],
        Utf32be[46],
        Utf32be[56],
        Utf32be[55],
        Utf32be[62],
        Utf32be[68],
        Utf32be[52],
        Utf32be[51],
        Utf32be[44],
        Utf32be[34],
        Utf32be[2],
        Utf32be[36],
        Utf32be[5],
        Utf32be[6],
        Utf32be[40],
        Utf32be[1],
        Utf32be[77],
        Utf32be[66]]];
   runtime.caml_register_global(114, Base_String, "Base__String");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes
//# unitInfo: Requires: Base__Array0, Base__Blit, Base__Bytes0, Base__Bytes_intf, Base__Bytes_tr, Base__Char, Base__Comparator, Base__Import, Base__List, Base__Or_error, Base__Ordered_collection_common, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Staged, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Bytes",
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Array0 = global_data.Base__Array0,
    Base_List = global_data.Base__List,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Staged = global_data.Base__Staged,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Blit = global_data.Base__Blit,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    stage = Base_Staged[1],
    globalize = Base_Import[288],
    t_of_sexp = Base_Import[161],
    sexp_of_t = Base_Import[137],
    t_sexp_grammar = Base_Import[183],
    max_length = Base_Bytes0[2],
    compare = Base_Bytes0[5],
    copy = Base_Bytes0[6],
    create = Base_Bytes0[7],
    set_uchar_utf_8 = Base_Bytes0[8],
    set_uchar_utf_16le = Base_Bytes0[9],
    set_uchar_utf_16be = Base_Bytes0[10],
    set_uchar_utf_32le = Base_Bytes0[12],
    set_uchar_utf_32be = Base_Bytes0[13],
    create_local = Base_Bytes0[14],
    fill = Base_Bytes0[15],
    make = Base_Bytes0[16],
    map = Base_Bytes0[17],
    mapi = Base_Bytes0[18],
    to_string = Base_Bytes0[20],
    of_string = Base_Bytes0[21],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _c_ = [0, "src/bytes.ml", 130, 2],
    cst_tr_multi_replacement_is_th =
      "tr_multi: replacement is the empty string",
    _b_ = [0, [11, "Bytes.init ", [4, 0, 0, 0, 0]], "Bytes.init %d"],
    _a_ = [0, [3, 0, 0], "%S"];
   function pp(fmt, t){
    var _y_ = caml_call1(to_string, t);
    return caml_call3(Stdlib_Format[137], fmt, _a_, _y_);
   }
   function create$0(len){return caml_call1(create, len);}
   var
    To_bytes =
      caml_call1
       (Base_Blit[1],
        [0, caml_ml_bytes_length, create$0, runtime.caml_blit_bytes]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    comparator = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t])[1],
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes);
   function create$1(len){return caml_call1(create, len);}
   var
    length = caml_ml_bytes_length,
    unsafe_blit$0 = runtime.caml_blit_string,
    length$0 = caml_ml_string_length,
    From_string =
      caml_call1
       (caml_call1(Base_Blit[2], [0, length$0]),
        [0, length, create$1, unsafe_blit$0]);
   function invariant(param){return 0;}
   function init(n, f){
    if(n < 0) caml_call3(Base_Printf[7], _b_, n, 0);
    var
     t = caml_call1(create, n),
     _w_ = caml_call2(Base_Import[93], n, 1),
     _v_ = 0;
    if(_w_ >= 0){
     var i = _v_;
     for(;;){
      caml_bytes_unsafe_set(t, i, caml_call1(f, i));
      var _x_ = i + 1 | 0;
      if(_w_ === i) break;
      var i = _x_;
     }
    }
    return t;
   }
   function of_char_list(l){
    var t = caml_call1(create, caml_call1(Base_List[45], l));
    function _u_(i, c){return runtime.caml_bytes_set(t, i, c);}
    caml_call2(Base_List[34], l, _u_);
    return t;
   }
   function to_list(t){
    var
     i$1 = caml_call2(Base_Import[93], caml_ml_bytes_length(t), 1),
     i = i$1,
     acc = 0;
    for(;;){
     if(0 > i) return acc;
     var
      acc$0 = [0, caml_bytes_unsafe_get(t, i), acc],
      i$0 = caml_call2(Base_Import[93], i, 1),
      i = i$0,
      acc = acc$0;
    }
   }
   function to_array(t){
    function _t_(i){return caml_bytes_unsafe_get(t, i);}
    return caml_call2(Base_Array0[12], caml_ml_bytes_length(t), _t_);
   }
   function map$0(t, f){return caml_call2(map, t, f);}
   function mapi$0(t, f){return caml_call2(mapi, t, f);}
   function fold(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call2(f, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[91], pos, 1),
      pos = pos$0,
      acc = acc$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call3(f, pos, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[91], pos, 1),
      pos = pos$0,
      acc = acc$0;
    }
   }
   function tr(target, replacement, s){
    var
     _r_ = caml_call2(Base_Import[93], caml_ml_bytes_length(s), 1),
     _q_ = 0;
    if(_r_ >= 0){
     var i = _q_;
     for(;;){
      if(caml_call2(Base_Char[16], caml_bytes_unsafe_get(s, i), target))
       caml_bytes_unsafe_set(s, i, replacement);
      var _s_ = i + 1 | 0;
      if(_r_ === i) break;
      var i = _s_;
     }
    }
    return 0;
   }
   function tr_multi(target, replacement){
    if(0 === caml_ml_string_length(target))
     return caml_call1(stage, function(_p_){return 0;});
    if(0 === caml_ml_string_length(replacement))
     return caml_call1(Base_Import[126], cst_tr_multi_replacement_is_th);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_o_){return 0;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              var
               _m_ = caml_call2(Base_Import[93], caml_ml_bytes_length(s), 1),
               _l_ = 0;
              if(_m_ >= 0){
               var i = _l_;
               for(;;){
                caml_bytes_unsafe_set
                 (s,
                  i,
                  runtime.caml_string_unsafe_get
                   (tr_map,
                    caml_call1(Base_Char[32], caml_bytes_unsafe_get(s, i))));
                var _n_ = i + 1 | 0;
                if(_m_ === i) break;
                var i = _n_;
               }
              }
              return 0;
             });
   }
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[110][2], low, t);
    return _k_ ? caml_call2(Base_Import[110][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[110][1], t, min)
            ? min
            : caml_call2(Base_Import[110][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[110][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[110][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[39], _j_);
   }
   function contains(pos, len, t, char$0){
    var
     match =
       caml_call4
        (Base_Ordered_collection_common[1],
         pos,
         len,
         0,
         caml_ml_bytes_length(t)),
     len$0 = match[2],
     pos$0 = match[1],
     last = caml_call2(Base_Import[91], pos$0, len$0),
     i = pos$0;
    for(;;){
     var _d_ = i < last ? 1 : 0;
     if(_d_){
      var
       _e_ = caml_bytes_get(t, i),
       _f_ = caml_call2(Base_Char[16], _e_, char$0);
      if(! _f_){
       var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
       continue;
      }
      var _g_ = _f_;
     }
     else
      var _g_ = _d_;
     return _g_;
    }
   }
   var
    Utf8 = [0, set_uchar_utf_8],
    Utf16le = [0, set_uchar_utf_16le],
    Utf16be = [0, set_uchar_utf_16be],
    Utf32le = [0, set_uchar_utf_32le],
    Utf32be = [0, set_uchar_utf_32be],
    include$0 = Base_Import[110],
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    ascending = include$0[7],
    descending = include$0[8],
    compare$0 = include$0[9],
    compare_local = include$0[10],
    equal = include$0[11],
    equal_local = include$0[12],
    max = include$0[13],
    min = include$0[14],
    Base_Bytes =
      [0,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       blit,
       blito,
       unsafe_blit,
       sub,
       subo,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       compare_local,
       equal_local,
       of_string,
       to_string,
       pp$0,
       invariant,
       To_string,
       From_string,
       create,
       create_local,
       make,
       map$0,
       mapi$0,
       copy,
       init,
       of_char_list,
       caml_bytes_get,
       fill,
       tr,
       tr_multi,
       to_list,
       to_array,
       fold,
       foldi,
       contains,
       max_length,
       Utf8,
       Utf16le,
       Utf16be,
       Utf32le,
       Utf32be];
   runtime.caml_register_global(24, Base_Bytes, "Base__Bytes");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hex_lexer
//# unitInfo: Requires: Stdlib__Lexing
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    ocaml_lex_tables =
      [0,
       "\0\0\0\0\x01\0\x01\0\x02\0\x1b\0R\0i\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x01\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\x01\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\x06\0\x04\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\x04\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\x02\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\x01\0\x03\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\0\x03\0\x05\0\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       cst,
       cst,
       cst,
       cst,
       cst,
       cst],
    Stdlib_Lexing = global_data.Stdlib__Lexing;
   function parse_hex(lexbuf){
    var ocaml_lex_state = 0;
    for(;;){
     var
      ocaml_lex_state$0 =
        caml_call3
         (Stdlib_Lexing[20], ocaml_lex_tables, ocaml_lex_state, lexbuf);
     if(0 === ocaml_lex_state$0){
      var
       body =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 3 | 0, lexbuf[6]);
      return [0, body];
     }
     if(1 === ocaml_lex_state$0){
      var
       body$0 =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 2 | 0, lexbuf[6]);
      return [1, body$0];
     }
     caml_call1(lexbuf[1], lexbuf);
     var ocaml_lex_state = ocaml_lex_state$0;
    }
   }
   var Base_Hex_lexer = [0, parse_hex];
   runtime.caml_register_global(2, Base_Hex_lexer, "Base__Hex_lexer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_string_conversions
//# unitInfo: Requires: Base__Bytes, Base__Char, Base__Hex_lexer, Base__Import, Base__Option, Base__Printf, Base__Sexp, Base__Sexpable, Base__String, Stdlib__Lexing
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_0b$1 = "0b",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Base_Hex_lexer = global_data.Base__Hex_lexer,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    Base_Option = global_data.Base__Option,
    Base_Printf = global_data.Base__Printf,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Bytes = global_data.Base__Bytes,
    Base_Sexp = global_data.Base__Sexp,
    cst_0b$0 = cst_0b$1,
    cst_0b = cst_0b$1,
    cst_0 = "0",
    _a_ =
      [0,
       [2, 0, [11, ".of_string: invalid input ", [3, 0, 0]]],
       "%s.of_string: invalid input %S"],
    cst_0x = "-0x",
    cst_0x$0 = "0x";
   function insert_delimiter_every(input, delimiter, chars_per_delimiter){
    var input_length = runtime.caml_ml_string_length(input);
    if(input_length <= chars_per_delimiter) return input;
    var match = caml_string_get(input, 0);
    a:
    {
     if(43 !== match && 45 !== match){var has_sign = 0; break a;}
     var has_sign = 1;
    }
    var
     num_digits =
       has_sign ? caml_call2(Base_Import[93], input_length, 1) : input_length,
     _A_ = caml_call2(Base_Import[93], num_digits, 1),
     num_delimiters = caml_call2(Base_Import[95], _A_, chars_per_delimiter),
     output_length = caml_call2(Base_Import[91], input_length, num_delimiters),
     output = caml_call1(Base_Bytes[34], output_length),
     input_pos = [0, caml_call2(Base_Import[93], input_length, 1)],
     output_pos = [0, caml_call2(Base_Import[93], output_length, 1)],
     num_chars_until_delimiter = [0, chars_per_delimiter],
     first_digit_pos = has_sign ? 1 : 0;
    for(;;){
     if(first_digit_pos > input_pos[1]){
      if(has_sign) caml_bytes_set(output, 0, caml_string_get(input, 0));
      return runtime.caml_string_of_bytes(output);
     }
     if(0 === num_chars_until_delimiter[1]){
      caml_bytes_set(output, output_pos[1], delimiter);
      output_pos[1] += -1;
      num_chars_until_delimiter[1] = chars_per_delimiter;
     }
     var _B_ = caml_string_get(input, input_pos[1]);
     caml_bytes_set(output, output_pos[1], _B_);
     input_pos[1] += -1;
     output_pos[1] += -1;
     num_chars_until_delimiter[1] += -1;
    }
   }
   function insert_delimiter(input, delimiter){
    return insert_delimiter_every(input, delimiter, 3);
   }
   function insert_underscores(input){return insert_delimiter(input, 95);}
   var sexp_of_int_style = Base_Sexp[20];
   function _b_(_j_){
    var
     func = _j_[6],
     hash_fold_t = _j_[5],
     compare_local = _j_[2],
     _k_ = _j_[12],
     _l_ = _j_[13],
     _m_ = _j_[11],
     _n_ = _j_[10],
     _o_ = _j_[9],
     _p_ = _j_[8],
     _q_ = _j_[7],
     _r_ = _j_[4];
    function compare(a, b){return caml_call2(compare_local, a, b);}
    function hash(x){return caml_call1(func, x);}
    function to_string_suffix(t){
     if(caml_call2(_r_, t, _l_))
      var bits = 0;
     else
      var
       _u_ = caml_call1(_q_, t),
       bits = caml_call2(Base_Import[93], _m_, _u_);
     if(0 === bits) return cst_0;
     function _v_(char_index){
      var
       _w_ = caml_call2(Base_Import[93], bits, char_index),
       bit_index = caml_call2(Base_Import[93], _w_, 1),
       bit = caml_call2(_o_, caml_call2(_p_, t, bit_index), _k_),
       _x_ = caml_call1(_n_, bit),
       _y_ = caml_call1(Base_Char[32], 48),
       _z_ = caml_call2(Base_Import[91], _y_, _x_);
      return caml_call1(Base_Char[35], _z_);
     }
     return caml_call2(Base_String[36], bits, _v_);
    }
    function to_string(t){
     var _t_ = to_string_suffix(t);
     return caml_call2(Base_Import[112], cst_0b, _t_);
    }
    function to_string_hum(opt, t){
     if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
     var _s_ = insert_delimiter_every(to_string_suffix(t), delimiter, 4);
     return caml_call2(Base_Import[112], cst_0b$0, _s_);
    }
    function sexp_of_t(t){return [0, to_string_hum(0, t)];}
    return [0,
            [0,
             sexp_of_t,
             compare,
             compare_local,
             hash_fold_t,
             hash,
             to_string,
             to_string_hum]];
   }
   function _c_(I){
    var compare_local = I[2];
    function compare(a, b){return caml_call2(compare_local, a, b);}
    var hash_fold_t = I[3], func = I[4];
    function hash(x){return caml_call1(func, x);}
    var chars_per_delimiter = 4;
    function to_string(delimiter, t){
     if(delimiter)
      var
       delimiter$0 = delimiter[1],
       make_suffix =
         function(t){
          return insert_delimiter_every
                  (caml_call1(I[5], t), delimiter$0, chars_per_delimiter);
         };
     else
      var make_suffix = I[5];
     if(caml_call2(I[8], t, I[7])){
      var _h_ = caml_call1(make_suffix, caml_call1(I[9], t));
      return caml_call2(Base_Import[112], cst_0x, _h_);
     }
     var _i_ = caml_call1(make_suffix, t);
     return caml_call2(Base_Import[112], cst_0x$0, _i_);
    }
    function to_string$0(t){return to_string(0, t);}
    function to_string_hum(opt, t){
     if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
     return to_string([0, delimiter], t);
    }
    function invalid(str){
     return caml_call4(Base_Printf[6], _a_, I[10], str, 0);
    }
    function of_string_with_delimiter(str){
     function _f_(c){return caml_call2(Base_Char[15], c, 95);}
     var _g_ = caml_call2(Base_String[10], str, _f_);
     return caml_call1(I[6], _g_);
    }
    function of_string(str){
     var lex = caml_call2(Stdlib_Lexing[3], 0, str);
     function _d_(param){return caml_call1(Base_Hex_lexer[1], lex);}
     var result = caml_call1(Base_Option[47], _d_);
     if(lex[6] !== lex[3]) return invalid(str);
     if(! result) return invalid(str);
     var match = result[1];
     if(0 === match[0]){
      var body = match[1], _e_ = of_string_with_delimiter(body);
      return caml_call1(I[9], _e_);
     }
     var body$0 = match[1];
     return of_string_with_delimiter(body$0);
    }
    var
     include = caml_call1(Base_Sexpable[5], [0, of_string, to_string$0]),
     t_sexp_grammar = include[1],
     t_of_sexp = include[2],
     sexp_of_t = include[3];
    return [0,
            [0,
             t_of_sexp,
             sexp_of_t,
             t_sexp_grammar,
             compare,
             compare_local,
             hash_fold_t,
             hash,
             of_string,
             to_string$0,
             to_string_hum]];
   }
   var
    Base_Int_string_conversions =
      [0,
       function(I){
        var chars_per_delimiter = 3;
        function to_string_hum(opt, t){
         if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
         return insert_delimiter_every
                 (caml_call1(I[1], t), delimiter, chars_per_delimiter);
        }
        function sexp_of_t(t){
         var
          s = caml_call1(I[1], t),
          s$0 =
            1009018843 <= sexp_of_int_style[1]
             ? s
             : insert_delimiter_every(s, 95, chars_per_delimiter);
         return [0, s$0];
        }
        return [0, to_string_hum, sexp_of_t];
       },
       _c_,
       _b_,
       sexp_of_int_style,
       insert_delimiter_every,
       insert_delimiter,
       insert_underscores];
   runtime.caml_register_global
    (16, Base_Int_string_conversions, "Base__Int_string_conversions");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Popcount
//# unitInfo: Requires: Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    m1 = runtime.caml_int64_create_lo_mi_hi(5592405, 5592405, 21845),
    m2 = runtime.caml_int64_create_lo_mi_hi(3355443, 3355443, 13107),
    m4 = runtime.caml_int64_create_lo_mi_hi(986895, 986895, 3855),
    h01 = runtime.caml_int64_create_lo_mi_hi(65793, 65793, 257),
    mask = runtime.caml_int64_create_lo_mi_hi(16777215, 255, 0),
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Assert_failure = global_data.Assert_failure,
    _b_ = [0, "src/popcount.ml", 45, 9];
   function int64_popcount(x){
    var
     x$0 =
       runtime.caml_int64_sub
        (x, caml_int64_and(caml_int64_shift_right_unsigne(x, 1), m1)),
     x$1 =
       caml_int64_add
        (caml_int64_and(x$0, m2),
         caml_int64_and(caml_int64_shift_right_unsigne(x$0, 2), m2)),
     x$2 =
       caml_int64_and
        (caml_int64_add(x$1, caml_int64_shift_right_unsigne(x$1, 4)), m4);
    return runtime.caml_int64_to_int32
            (caml_int64_shift_right_unsigne
              (runtime.caml_int64_mul(x$2, h01), 56));
   }
   function int32_popcount(x){
    return int64_popcount(caml_int64_and(caml_int64_of_int32(x), mask));
   }
   var _a_ = Stdlib_Nativeint[9];
   if(32 === _a_)
    var nativeint_popcount = function(x){return int32_popcount(x);};
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var
     nativeint_popcount =
       function(x){return int64_popcount(caml_int64_of_int32(x));};
   }
   var
    Base_Popcount =
      [0,
       function(_c_){return runtime.Base_int_math_int_popcount(_c_);},
       int32_popcount,
       int64_popcount,
       nativeint_popcount];
   runtime.caml_register_global(8, Base_Popcount, "Base__Popcount");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign
//# unitInfo: Requires: Base__Identifiable, Base__Import, Base__Sign0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Sign0 = global_data.Base__Sign0,
    Base_Identifiable = global_data.Base__Identifiable,
    t_sexp_grammar = Base_Sign0[3],
    compare_local = Base_Sign0[4],
    all = Base_Sign0[7],
    Replace_polymorphic_compare = Base_Sign0[8],
    to_int = Base_Sign0[11],
    of_int = Base_Sign0[14],
    _a_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         Base_Sign0[5],
         Base_Sign0[6],
         Base_Sign0[12],
         Base_Sign0[1],
         Base_Sign0[2],
         Base_Sign0[9],
         Base_Sign0[10],
         Base_Sign0[13]]),
    hash_fold_t = _a_[1],
    hash = _a_[2],
    t_of_sexp = _a_[3],
    sexp_of_t = _a_[4],
    of_string = _a_[5],
    to_string = _a_[6],
    between = _a_[19],
    clamp_exn = _a_[20],
    clamp = _a_[21],
    comparator = _a_[22],
    pp = _a_[23],
    hashable = _a_[24],
    cst_negative = "negative",
    cst_zero = "zero",
    cst_positive = "positive";
   function to_string_hum(param){
    switch(param){
      case 0:
       return cst_negative;
      case 1:
       return cst_zero;
      default: return cst_positive;
    }
   }
   function to_float(param){
    switch(param){case 0: return -1.;case 1: return 0.;default: return 1.;
    }
   }
   function flip(param){
    switch(param){case 0: return 2;case 1: return 1;default: return 0;
    }
   }
   function symbol(t$0, t){
    var _b_ = caml_call1(to_int, t), _c_ = caml_call1(to_int, t$0);
    return caml_call1(of_int, caml_call2(Base_Import[88], _c_, _b_));
   }
   var
    symbol$0 = Replace_polymorphic_compare[1],
    symbol$1 = Replace_polymorphic_compare[2],
    symbol$2 = Replace_polymorphic_compare[3],
    symbol$3 = Replace_polymorphic_compare[4],
    symbol$4 = Replace_polymorphic_compare[5],
    symbol$5 = Replace_polymorphic_compare[6],
    ascending = Replace_polymorphic_compare[7],
    descending = Replace_polymorphic_compare[8],
    compare = Replace_polymorphic_compare[9],
    equal = Replace_polymorphic_compare[10],
    equal_local = Replace_polymorphic_compare[11],
    max = Replace_polymorphic_compare[12],
    min = Replace_polymorphic_compare[13],
    Base_Sign =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$5,
       symbol$1,
       symbol$3,
       symbol$4,
       symbol$0,
       symbol$2,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       compare_local,
       equal_local,
       to_string_hum,
       of_int,
       to_int,
       to_float,
       flip,
       symbol];
   runtime.caml_register_global(9, Base_Sign, "Base__Sign");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int0, Base__Int_conversions, Base__Int_intf, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Sign, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_x = "%x",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_div = runtime.caml_div,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int.Hex",
    module_name$0 = "Base.Int",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Float0 = global_data.Base__Float0,
    Base_Int0 = global_data.Base__Int0,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Int_math = global_data.Base__Int_math,
    Base_Error = global_data.Base__Error,
    Base_Sign = global_data.Base__Sign,
    Base_Popcount = global_data.Base__Popcount,
    to_string = Base_Int0[1],
    of_string = Base_Int0[2],
    of_string_opt = Base_Int0[3],
    globalize = Base_Import[284],
    hash_fold_t = Base_Import[206],
    func = Base_Import[220],
    _u_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"],
    _t_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    cst_Int_ceil_log2_got_invalid_ = "[Int.ceil_log2] got invalid input",
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    _g_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _f_ = [0, "src/int.ml", 111, 2],
    _e_ = [0, [4, 6, 0, 0, 0], cst_x],
    _d_ = [0, [4, 6, 0, 0, 0], cst_x],
    _b_ =
      [0,
       [11,
        "Int.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int.of_float: argument (%f) is out of range or NaN"],
    _a_ = [0, [11, "Int.of_string: ", [3, 0, 0]], "Int.of_string: %S"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[163],
    sexp_of_t = Base_Import[139],
    t_sexp_grammar = Base_Import[185],
    hashable = [0, hash, caml_int_compare, sexp_of_t],
    compare = caml_int_compare;
   function of_string$0(s){
    try{var _aL_ = caml_call1(of_string, s); return _aL_;}
    catch(_aM_){return caml_call3(Base_Printf[6], _a_, s, 0);}
   }
   var
    num_bits = Base_Int_conversions[30],
    float_lower_bound = caml_call1(Base_Float0[26], num_bits),
    float_upper_bound = caml_call1(Base_Float0[24], num_bits);
   function to_float(_aK_){return _aK_;}
   function of_float_unchecked(_aJ_){return _aJ_ | 0;}
   function of_float(f){
    if(float_lower_bound <= f && f <= float_upper_bound) return f | 0;
    var _aI_ = caml_call1(Base_Float0[29], f);
    return caml_call3(Base_Printf[7], _b_, _aI_, 0);
   }
   var
    comparator = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t])[1],
    _c_ = caml_call1(Base_Comparable[14], [0, compare, sexp_of_t, 0]),
    is_positive = _c_[1],
    is_non_negative = _c_[2],
    is_negative = _c_[3],
    is_non_positive = _c_[4],
    include = caml_call1(Base_Int_string_conversions[1], [0, to_string]),
    to_string_hum = include[1],
    sexp_of_t$0 = include[2],
    compare_local = Base_Import[256],
    zero = 0,
    one = 1,
    minus_one = -1;
   function compare$0(a, b){return caml_call2(compare_local, a, b);}
   var hash_fold_t$0 = Base_Import[206], func$0 = Base_Import[220];
   function hash$0(x){return caml_call1(func$0, x);}
   var neg = Base_Import[113];
   function symbol(_aH_, _aG_){return _aH_ < _aG_ ? 1 : 0;}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$1(s){
    function _aE_(_aF_){return _aF_;}
    return caml_call3(Stdlib_Scanf[5], s, _e_, _aE_);
   }
   var
    include$0 =
      caml_call1
       (Base_Int_string_conversions[2],
        [0,
         compare$0,
         compare_local,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$1,
         zero,
         symbol,
         neg,
         module_name]),
    Hex = include$0[1],
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$1[1];
   function invariant(param){return 0;}
   function between(t, low, high){
    var _aC_ = low <= t ? 1 : 0, _aD_ = _aC_ ? t <= high ? 1 : 0 : _aC_;
    return _aD_;
   }
   function clamp_unchecked(t, min, max){
    var _aB_ = caml_call2(Base_Import[97][4], t, max);
    return caml_call1(caml_call1(Base_Import[97][3], min), _aB_);
   }
   function clamp_exn(t, min, max){
    if(min <= max) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(max >= min) return [0, clamp_unchecked(t, min, max)];
    var
     _ay_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _az_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _ay_],
     _aA_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _az_);
    return caml_call1(Base_Or_error[39], _aA_);
   }
   function pred(i){return caml_call2(Base_Import[93], i, 1);}
   function succ(i){return caml_call2(Base_Import[91], i, 1);}
   function to_int(i){return i;}
   function of_int_exn(i){return i;}
   var
    max_value = Base_Import[85][19],
    min_value = Base_Import[85][20],
    of_int32 = Base_Int_conversions[6],
    of_int32_exn = Base_Int_conversions[7],
    to_int32 = Base_Int_conversions[1],
    to_int32_exn = Base_Int_conversions[2],
    of_int64 = Base_Int_conversions[12],
    of_int64_exn = Base_Int_conversions[13],
    to_int64 = Base_Int_conversions[4],
    of_nativeint = Base_Int_conversions[23],
    of_nativeint_exn = Base_Int_conversions[24],
    to_nativeint = Base_Int_conversions[5],
    max_value_30_bits = 1073741823;
   function abs(x){return caml_call1(Base_Import[123], x);}
   function rem(a, b){return caml_call2(Base_Import[122], a, b);}
   function incr(_ax_){_ax_[1]++; return 0;}
   function decr(_aw_){_aw_[1] += -1; return 0;}
   function shift_right(a, b){return caml_call2(Base_Import[115], a, b);}
   function shift_right_logical(a, b){
    return caml_call2(Base_Import[120], a, b);
   }
   function shift_left(a, b){return caml_call2(Base_Import[119], a, b);}
   function bit_not(a){return caml_call1(Base_Import[117], a);}
   function bit_or(a, b){return caml_call2(Base_Import[118], a, b);}
   function bit_and(a, b){return caml_call2(Base_Import[116], a, b);}
   function bit_xor(a, b){return caml_call2(Base_Import[121], a, b);}
   var pow = Base_Int_math[2][1];
   function symbol$0(b, e){return caml_call2(pow, b, e);}
   var raise_s = Base_Error[32];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _g_, 0);
   }
   function ceil_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     x$0 = caml_call2(Base_Import[93], x, 1),
     _aq_ = caml_call2(Base_Import[120], x$0, 1),
     x$1 = caml_call2(Base_Import[118], x$0, _aq_),
     _ar_ = caml_call2(Base_Import[120], x$1, 2),
     x$2 = caml_call2(Base_Import[118], x$1, _ar_),
     _as_ = caml_call2(Base_Import[120], x$2, 4),
     x$3 = caml_call2(Base_Import[118], x$2, _as_),
     _at_ = caml_call2(Base_Import[120], x$3, 8),
     x$4 = caml_call2(Base_Import[118], x$3, _at_),
     _au_ = caml_call2(Base_Import[120], x$4, 16),
     x$5 = caml_call2(Base_Import[118], x$4, _au_),
     _av_ = caml_call2(Base_Import[120], x$5, 32),
     x$6 = caml_call2(Base_Import[118], x$5, _av_);
    return caml_call2(Base_Import[91], x$6, 1);
   }
   function floor_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     _aj_ = caml_call2(Base_Import[120], x, 1),
     x$0 = caml_call2(Base_Import[118], x, _aj_),
     _ak_ = caml_call2(Base_Import[120], x$0, 2),
     x$1 = caml_call2(Base_Import[118], x$0, _ak_),
     _al_ = caml_call2(Base_Import[120], x$1, 4),
     x$2 = caml_call2(Base_Import[118], x$1, _al_),
     _am_ = caml_call2(Base_Import[120], x$2, 8),
     x$3 = caml_call2(Base_Import[118], x$2, _am_),
     _an_ = caml_call2(Base_Import[120], x$3, 16),
     x$4 = caml_call2(Base_Import[118], x$3, _an_),
     _ao_ = caml_call2(Base_Import[120], x$4, 32),
     x$5 = caml_call2(Base_Import[118], x$4, _ao_),
     _ap_ = caml_call2(Base_Import[120], x$5, 1);
    return caml_call2(Base_Import[93], x$5, _ap_);
   }
   function is_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var _ai_ = caml_call2(Base_Import[93], x, 1);
    return 0 === caml_call2(Base_Import[116], x, _ai_) ? 1 : 0;
   }
   function floor_log2(i){
    if(i <= 0){
     var _af_ = [0, [0, cst, caml_call1(Base_Import[139], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int_floor_log2_got_invalid, _af_));
    }
    var
     _ag_ = runtime.Base_int_math_int_clz(i),
     _ah_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _ah_, _ag_);
   }
   function ceil_log2(i){
    if(i <= 0){
     var _ad_ = [0, [0, cst$0, caml_call1(Base_Import[139], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int_ceil_log2_got_invalid_, _ad_));
    }
    if(1 === i) return 0;
    var
     _ae_ = runtime.Base_int_math_int_clz(caml_call2(Base_Import[93], i, 1));
    return caml_call2(Base_Import[93], num_bits, _ae_);
   }
   var
    sign = Base_Sign[30],
    popcount = Base_Popcount[1],
    compare_local$0 = Base_Import[256];
   function compare$1(a, b){return caml_call2(compare_local$0, a, b);}
   var equal_local = Base_Import[270];
   function equal(a, b){return caml_call2(equal_local, a, b);}
   var hash_fold_t$1 = Base_Import[206], func$1 = Base_Import[220];
   function hash$1(x){return caml_call1(func$1, x);}
   var land = Base_Import[116], lsr = Base_Import[120];
   function clz(_ac_){return runtime.Base_int_math_int_clz(_ac_);}
   var
    Binary =
      caml_call1
        (Base_Int_string_conversions[3],
         [0,
          compare$1,
          compare_local$0,
          equal,
          equal_local,
          hash_fold_t$1,
          hash$1,
          clz,
          lsr,
          land,
          to_int,
          num_bits,
          one,
          zero])
       [1];
   function _h_(_ab_){return - _ab_ | 0;}
   function _i_(_aa_, _$_){return _aa_ !== _$_ ? 1 : 0;}
   function _j_(___, _Z_){return ___ < _Z_ ? 1 : 0;}
   function _k_(_Y_, _X_){return _X_ < _Y_ ? 1 : 0;}
   function _l_(_W_, _V_){return _W_ === _V_ ? 1 : 0;}
   function _m_(_U_, _T_){return _U_ <= _T_ ? 1 : 0;}
   function _n_(_S_, _R_){return _R_ <= _S_ ? 1 : 0;}
   function _o_(_Q_){return - _Q_ | 0;}
   var _p_ = caml_div, _q_ = runtime.caml_mul;
   function _r_(_P_, _O_){return _P_ - _O_ | 0;}
   var
    _s_ =
      [0,
       of_float,
       to_float,
       of_string$0,
       to_string,
       function(_N_, _M_){return _N_ + _M_ | 0;},
       _r_,
       _q_,
       _p_,
       _o_,
       _n_,
       _m_,
       _l_,
       _k_,
       _j_,
       _i_,
       abs,
       _h_,
       zero,
       of_int_exn,
       rem],
    F = caml_call1(Base_Int_math[1], _s_),
    round = F[4],
    round_towards_zero = F[5],
    round_down = F[6],
    round_up = F[7],
    round_nearest = F[8];
   function symbol$1(x, y){
    if(y <= 0){
     var _K_ = caml_call1(to_string, y), _L_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _t_, _L_, _K_, 0);
    }
    var rval = rem(x, y);
    return rval < 0 ? rval + y | 0 : rval;
   }
   function symbol$2(x, y){
    if(y <= 0){
     var _I_ = caml_call1(to_string, y), _J_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _u_, _J_, _I_, 0);
    }
    return x < 0 ? caml_div(x + 1 | 0, y) - 1 | 0 : caml_div(x, y);
   }
   function symbol$3(x, y){return caml_call2(Base_Import[96], x, y);}
   var
    lnot = Base_Import[117],
    include$2 = Base_Import[97],
    ascending = include$2[1],
    descending = include$2[2],
    max = include$2[3],
    min = include$2[4],
    _v_ = [0, [0, F[1], F[2], F[3]]],
    _w_ = [0, symbol$0, lnot, abs, zero, symbol$1, symbol$2, symbol$3];
   function _x_(_H_){return runtime.Base_int_math_int_ctz(_H_);}
   function _y_(_G_){return runtime.Base_int_math_int_clz(_G_);}
   function _z_(_F_, _E_){return _F_ === _E_ ? 1 : 0;}
   var
    _A_ = caml_int_compare,
    _B_ = caml_int_compare,
    Base_Int =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string$0,
       to_string,
       function(_D_, _C_){return _D_ === _C_ ? 1 : 0;},
       _B_,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       _A_,
       _z_,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       _y_,
       _x_,
       _w_,
       symbol$0,
       lnot,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       max_value_30_bits,
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_int64,
       of_nativeint,
       to_nativeint,
       _v_];
   runtime.caml_register_global(34, Base_Int, "Base__Int");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys
//# unitInfo: Requires: Base__Sys0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    backend_type = Base_Sys0[1],
    interactive = Base_Sys0[2],
    os_type = Base_Sys0[3],
    unix = Base_Sys0[4],
    win32 = Base_Sys0[5],
    cygwin = Base_Sys0[6],
    word_size_in_bits = Base_Sys0[7],
    int_size_in_bits = Base_Sys0[8],
    big_endian = Base_Sys0[9],
    max_string_length = Base_Sys0[10],
    max_array_length = Base_Sys0[11],
    runtime_variant = Base_Sys0[12],
    runtime_parameters = Base_Sys0[13],
    argv = Base_Sys0[14],
    get_argv = Base_Sys0[15],
    ocaml_version = Base_Sys0[16],
    enable_runtime_warnings = Base_Sys0[17],
    runtime_warnings_enabled = Base_Sys0[18],
    getenv_exn = Base_Sys0[20],
    getenv = Base_Sys0[21],
    Base_Sys =
      [0,
       get_argv,
       argv,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       backend_type,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv,
       getenv_exn];
   runtime.caml_register_global(1, Base_Sys, "Base__Sys");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Obj_local
//# unitInfo: Requires: Base__Sys, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Heap = "Heap",
    cst_Immediate = "Immediate",
    cst_Stack = "Stack",
    cst_heap = "heap",
    cst_immediate = "immediate",
    cst_stack = "stack",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "obj_local.ml.stack_or_heap",
    Base_Sys = global_data.Base__Sys,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _a_ = [0, cst_Immediate],
    _b_ = [0, cst_Stack],
    _c_ = [0, cst_Heap];
   function size(t){return t.length - 1;}
   function stack_or_heap_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _e_ = sexp_004[1];
      b:
      if(caml_string_notequal(_e_, cst_Heap)){
       c:
       if(caml_string_notequal(_e_, cst_Immediate)){
        if(caml_string_notequal(_e_, cst_Stack)){
         if(! caml_string_notequal(_e_, cst_heap)) break b;
         if(! caml_string_notequal(_e_, cst_immediate)) break c;
         if(caml_string_notequal(_e_, cst_stack)) break a;
        }
        return 1;
       }
       return 0;
      }
      return 2;
     }
     var _f_ = sexp_004[1];
     if(! _f_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_003, sexp_004);
     var _g_ = _f_[1];
     if(0 !== _g_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_003, sexp_004);
     var _h_ = _g_[1];
     b:
     if(caml_string_notequal(_h_, cst_Heap)){
      c:
      if(caml_string_notequal(_h_, cst_Immediate)){
       if(caml_string_notequal(_h_, cst_Stack)){
        if(! caml_string_notequal(_h_, cst_heap)) break b;
        if(! caml_string_notequal(_h_, cst_immediate)) break c;
        if(caml_string_notequal(_h_, cst_stack)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_003, sexp_004);
   }
   function sexp_of_stack_or_heap(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var compare_stack_or_heap = runtime.caml_int_compare;
   function stack_or_heap(repr){
    if(typeof repr === "number") return 0;
    var _d_ = Base_Sys[8];
    return typeof _d_ === "number"
            ? _d_ ? 2 : runtime.caml_dummy_obj_is_stack(repr) ? 1 : 2
            : 2;
   }
   var
    Base_Obj_local =
      [0,
       size,
       sexp_of_stack_or_heap,
       stack_or_heap_of_sexp,
       compare_stack_or_heap,
       stack_or_heap];
   runtime.caml_register_global(18, Base_Obj_local, "Base__Obj_local");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Obj_array
//# unitInfo: Requires: Base__Array0, Base__Blit, Base__Import, Base__Int0, Base__String0, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Array0 = global_data.Base__Array0,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Assert_failure = global_data.Assert_failure,
    Base_Blit = global_data.Base__Blit,
    _b_ = [0, ">", 0],
    cst_Obj_array_t_of_length = "<Obj_array.t of length ",
    _c_ = [0, ""],
    _a_ = [0, "src/obj_array.ml", 12, 2];
   function invariant(t){
    var _t_ = Stdlib_Obj[17];
    if(caml_obj_tag(t) !== _t_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function length(_s_){return _s_.length - 1;}
   function sexp_of_t(t){
    var
     _r_ =
       [0,
        cst_Obj_array_t_of_length,
        [0, caml_call1(Base_Int0[1], t.length - 1), _b_]];
    return [0, caml_call2(Base_String0[20], _c_, _r_)];
   }
   var zero_obj = 0;
   function create_zero(len){
    return caml_call2(Base_Array0[4], len, zero_obj);
   }
   var empty = [0];
   function get(t, i){return caml_check_bound(t, i)[1 + i];}
   function unsafe_get(t, i){return t[1 + i];}
   function unsafe_set_with_caml_modify(t, i, obj){t[1 + i] = obj; return 0;}
   function set_with_caml_modify(t, i, obj){
    caml_check_bound(t, i)[1 + i] = obj;
    return 0;
   }
   function unsafe_set_int_assuming_curren(t, i, int$0){t[1 + i] = int$0; return 0;
   }
   function set(t, i, obj){
    var old_obj = get(t, i);
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _q_ = 1 - (old_obj === obj ? 1 : 0);
    return _q_ ? unsafe_set_with_caml_modify(t, i, obj) : _q_;
   }
   function unsafe_set(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _p_ = 1 - (old_obj === obj ? 1 : 0);
    return _p_ ? unsafe_set_with_caml_modify(t, i, obj) : _p_;
   }
   function unsafe_set_omit_phys_equal_che(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    return unsafe_set_with_caml_modify(t, i, obj);
   }
   function swap(t, i, j){
    var a = get(t, i), b = get(t, j);
    unsafe_set(t, i, b);
    return unsafe_set(t, j, a);
   }
   function create(len, x){
    if(typeof x !== "number"){
     var _l_ = Stdlib_Obj[16];
     if(caml_obj_tag(x) === _l_){
      var
       t = create_zero(len),
       _n_ = caml_call2(Base_Import[93], len, 1),
       _m_ = 0;
      if(_n_ >= 0){
       var i = _m_;
       for(;;){
        unsafe_set_with_caml_modify(t, i, x);
        var _o_ = i + 1 | 0;
        if(_n_ === i) break;
        var i = _o_;
       }
      }
      return t;
     }
    }
    return caml_call2(Base_Array0[4], len, x);
   }
   function singleton(obj){return create(1, obj);}
   function unsafe_set_assuming_currently_(t, i, obj){
    return typeof obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, obj)
            : unsafe_set_with_caml_modify(t, i, obj);
   }
   function unsafe_set_int(t, i, int$0){
    var old_obj = t[1 + i];
    return typeof old_obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, int$0)
            : unsafe_set_with_caml_modify(t, i, int$0);
   }
   function unsafe_clear_if_pointer(t, i){
    var old_obj = t[1 + i], _k_ = 1 - (typeof old_obj === "number" ? 1 : 0);
    return _k_ ? unsafe_set_with_caml_modify(t, i, 0) : _k_;
   }
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    if(dst_pos < src_pos){
     var _e_ = caml_call2(Base_Import[93], len, 1), _d_ = 0;
     if(_e_ >= 0){
      var i = _d_;
      for(;;){
       var _f_ = src[1 + caml_call2(Base_Import[91], src_pos, i)];
       unsafe_set(dst, caml_call2(Base_Import[91], dst_pos, i), _f_);
       var _g_ = i + 1 | 0;
       if(_e_ === i) break;
       var i = _g_;
      }
     }
     return 0;
    }
    var _h_ = caml_call2(Base_Import[93], len, 1);
    if(_h_ >= 0){
     var i$0 = _h_;
     for(;;){
      var _i_ = src[1 + caml_call2(Base_Import[91], src_pos, i$0)];
      unsafe_set(dst, caml_call2(Base_Import[91], dst_pos, i$0), _i_);
      var _j_ = i$0 - 1 | 0;
      if(0 === i$0) break;
      var i$0 = _j_;
     }
    }
    return 0;
   }
   var
    include = caml_call1(Base_Blit[1], [0, length, create_zero, unsafe_blit]),
    blit = include[1],
    blito = include[2],
    unsafe_blit$0 = include[3],
    subo = include[5];
   function copy(src){
    var dst = create_zero(src.length - 1);
    caml_call6(blito, src, 0, 0, dst, 0, 0);
    return dst;
   }
   var
    sub = Base_Array0[15],
    Base_Obj_array =
      [0,
       sexp_of_t,
       blit,
       blito,
       unsafe_blit$0,
       subo,
       invariant,
       create,
       create_zero,
       copy,
       singleton,
       empty,
       length,
       get,
       unsafe_get,
       set,
       unsafe_set,
       swap,
       set_with_caml_modify,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       unsafe_clear_if_pointer,
       sub];
   runtime.caml_register_global(12, Base_Obj_array, "Base__Obj_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uniform_array
//# unitInfo: Requires: Base__Array, Base__Binary_searchable, Base__Blit, Base__Container, Base__Import, Base__Int, Base__List, Base__Obj_array, Base__Option, Base__Sexpable, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_uniform_array_ml = "src/uniform_array.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Int = global_data.Base__Int,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Obj_array = global_data.Base__Obj_array,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Blit = global_data.Base__Blit,
    Base_Binary_searchable = global_data.Base__Binary_searchable,
    empty = Base_Obj_array[11],
    _b_ = [0, cst_src_uniform_array_ml, 347, 6],
    cst_Array_map2_exn = "Array.map2_exn",
    cst_Array_fold2_exn = "Array.fold2_exn",
    cst_Uniform_array_init = "Uniform_array.init",
    _a_ = [0, cst_src_uniform_array_ml, 80, 2];
   function unsafe_create_uninitialized(len){
    return caml_call1(Base_Obj_array[8], len);
   }
   function create_obj_array(len){return caml_call1(Base_Obj_array[8], len);}
   function create(len, x){return caml_call2(Base_Obj_array[7], len, x);}
   function singleton(x){return caml_call1(Base_Obj_array[10], x);}
   function swap(t, i, j){return caml_call3(Base_Obj_array[17], t, i, j);}
   function get(arr, i){return caml_call2(Base_Obj_array[13], arr, i);}
   function set(arr, i, x){return caml_call3(Base_Obj_array[15], arr, i, x);}
   function unsafe_get_local(arr, i){
    return caml_call2(Base_Obj_array[14], arr, i);
   }
   function unsafe_get(arr, i){return unsafe_get_local(arr, i);}
   function unsafe_set(arr, i, x){
    return caml_call3(Base_Obj_array[16], arr, i, x);
   }
   function unsafe_set_int(arr, i, x){
    return caml_call3(Base_Obj_array[21], arr, i, x);
   }
   function unsafe_set_int_assuming_curren(arr, i, x){return caml_call3(Base_Obj_array[20], arr, i, x);
   }
   function unsafe_set_assuming_currently_(arr, i, x){return caml_call3(Base_Obj_array[19], arr, i, x);
   }
   function unsafe_to_array_inplace_promis(arr){return arr;}
   var
    length = Base_Obj_array[12],
    unsafe_blit = Base_Obj_array[4],
    copy = Base_Obj_array[9];
   function unsafe_set_omit_phys_equal_che(t, i, x){return caml_call3(Base_Obj_array[22], t, i, x);
   }
   function unsafe_set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[23], t, i, x);
   }
   function set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[18], t, i, x);
   }
   var unsafe_clear_if_pointer = Base_Obj_array[24], sub = Base_Obj_array[25];
   function invariant(t){
    var _aq_ = Stdlib_Obj[17];
    if(runtime.caml_obj_tag(t) !== _aq_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function init(l, f){
    if(0 > l) return caml_call1(Base_Import[126], cst_Uniform_array_init);
    var
     res = unsafe_create_uninitialized(l),
     _ao_ = caml_call2(Base_Import[93], l, 1),
     _an_ = 0;
    if(_ao_ >= 0){
     var i = _an_;
     for(;;){
      unsafe_set(res, i, caml_call1(f, i));
      var _ap_ = i + 1 | 0;
      if(_ao_ === i) break;
      var i = _ap_;
     }
    }
    return res;
   }
   function of_array(arr){
    return init(arr.length - 1, function(_am_){return arr[1 + _am_];});
   }
   function map(a, f){
    function _al_(i){return caml_call1(f, unsafe_get(a, i));}
    return init(caml_call1(length, a), _al_);
   }
   function mapi(a, f){
    function _ak_(i){return caml_call2(f, i, unsafe_get(a, i));}
    return init(caml_call1(length, a), _ak_);
   }
   function iter(a, f){
    var
     _ah_ = caml_call1(length, a),
     _ai_ = caml_call2(Base_Import[93], _ah_, 1),
     _ag_ = 0;
    if(_ai_ >= 0){
     var i = _ag_;
     for(;;){
      caml_call1(f, unsafe_get(a, i));
      var _aj_ = i + 1 | 0;
      if(_ai_ === i) break;
      var i = _aj_;
     }
    }
    return 0;
   }
   function iteri(a, f){
    var
     _ad_ = caml_call1(length, a),
     _ae_ = caml_call2(Base_Import[93], _ad_, 1),
     _ac_ = 0;
    if(_ae_ >= 0){
     var i = _ac_;
     for(;;){
      caml_call2(f, i, unsafe_get(a, i));
      var _af_ = i + 1 | 0;
      if(_ae_ === i) break;
      var i = _af_;
     }
    }
    return 0;
   }
   function foldi(a, init, f){
    var
     acc = [0, init],
     ___ = caml_call1(length, a),
     _$_ = caml_call2(Base_Import[93], ___, 1),
     _Z_ = 0;
    if(_$_ >= 0){
     var i = _Z_;
     for(;;){
      var _aa_ = unsafe_get(a, i);
      acc[1] = caml_call3(f, i, acc[1], _aa_);
      var _ab_ = i + 1 | 0;
      if(_$_ === i) break;
      var i = _ab_;
     }
    }
    return acc[1];
   }
   function fold(t, init, f){
    var
     r = [0, init],
     _V_ = caml_call1(length, t),
     _W_ = caml_call2(Base_Import[93], _V_, 1),
     _U_ = 0;
    if(_W_ >= 0){
     var i = _U_;
     for(;;){
      var _X_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _X_);
      var _Y_ = i + 1 | 0;
      if(_W_ === i) break;
      var i = _Y_;
     }
    }
    return r[1];
   }
   function to_list(t){
    function _R_(_T_){return get(t, _T_);}
    var _S_ = caml_call1(length, t);
    return caml_call2(Base_List[40], _S_, _R_);
   }
   function of_list(l){
    var
     len = caml_call1(Base_List[45], l),
     res = unsafe_create_uninitialized(len);
    function _Q_(i, x){return set(res, i, x);}
    caml_call2(Base_List[34], l, _Q_);
    return res;
   }
   function of_list_rev(l){
    var
     len = caml_call1(Base_List[45], l),
     res = unsafe_create_uninitialized(len);
    function _O_(i, x){
     var _P_ = caml_call2(Base_Import[93], len, i);
     return set(res, caml_call2(Base_Import[93], _P_, 1), x);
    }
    caml_call2(Base_List[34], l, _O_);
    return res;
   }
   function to_array(t){
    function _M_(i){return unsafe_get(t, i);}
    var _N_ = caml_call1(length, t);
    return caml_call2(Base_Array[41], _N_, _M_);
   }
   function exists(t, f){
    var
     _L_ = caml_call1(length, t),
     i = [0, caml_call2(Base_Import[93], _L_, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call1(f, unsafe_get(t, i[1]))){result[1] = 1; continue;}
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function existsi(t, f){
    var
     _J_ = caml_call1(length, t),
     i = [0, caml_call2(Base_Import[93], _J_, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      var _K_ = unsafe_get(t, i[1]);
      if(caml_call2(f, i[1], _K_)){result[1] = 1; continue;}
      i[1] += -1;
      continue;
     }
     return result[1];
    }
   }
   function for_all(t, f){
    var
     _I_ = caml_call1(length, t),
     i = [0, caml_call2(Base_Import[93], _I_, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call1(f, unsafe_get(t, i[1]))){i[1] += -1; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_alli(t, f){
    var
     length$0 = caml_call1(length, t),
     i = [0, caml_call2(Base_Import[93], length$0, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      var _H_ = unsafe_get(t, i[1]);
      if(caml_call2(f, i[1], _H_)){i[1] += -1; continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function filter_mapi(t, f){
    var
     r = [0, empty],
     k = [0, 0],
     _D_ = caml_call1(length, t),
     _E_ = caml_call2(Base_Import[93], _D_, 1),
     _C_ = 0;
    if(_E_ >= 0){
     var i = _C_;
     for(;;){
      var match = caml_call2(f, i, unsafe_get(t, i));
      if(match){
       var a = match[1];
       if(0 === k[1]) r[1] = create(caml_call1(length, t), a);
       unsafe_set(r[1], k[1], a);
       k[1]++;
      }
      var _G_ = i + 1 | 0;
      if(_E_ === i) break;
      var i = _G_;
     }
    }
    var _F_ = caml_call1(length, t);
    return k[1] === _F_
            ? r[1]
            : 0 < k[1] ? caml_call3(sub, r[1], 0, k[1]) : empty;
   }
   function filteri(t, f){
    return filter_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
   }
   function filter_map(t, f){
    return filter_mapi(t, function(i, a){return caml_call1(f, a);});
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function fold2_exn(t1, t2, init, f){
    var len = caml_call1(length, t1);
    if(caml_call1(length, t2) !== len)
     caml_call1(Base_Import[126], cst_Array_fold2_exn);
    var acc = [0, init], _y_ = caml_call2(Base_Import[93], len, 1), _x_ = 0;
    if(_y_ >= 0){
     var i = _x_;
     for(;;){
      var _z_ = unsafe_get(t2, i), _A_ = unsafe_get(t1, i);
      acc[1] = caml_call3(f, acc[1], _A_, _z_);
      var _B_ = i + 1 | 0;
      if(_y_ === i) break;
      var i = _B_;
     }
    }
    return acc[1];
   }
   function map2_exn(t1, t2, f){
    var len = caml_call1(length, t1);
    if(caml_call1(length, t2) !== len)
     caml_call1(Base_Import[126], cst_Array_map2_exn);
    return init
            (len,
             function(i){
              var _w_ = unsafe_get(t2, i);
              return caml_call2(f, unsafe_get(t1, i), _w_);
             });
   }
   function concat(ts){
    function _n_(t){return caml_call1(length, t);}
    function _o_(_v_, _u_){return _v_ + _u_ | 0;}
    var
     total_len = caml_call3(Base_List[26], [0, Base_Int[79], _o_], ts, _n_),
     res = unsafe_create_uninitialized(total_len);
    function _p_(so_far, t){
     var
      len = caml_call1(length, t),
      _r_ = caml_call2(Base_Import[93], len, 1),
      _q_ = 0;
     if(_r_ >= 0){
      var i = _q_;
      for(;;){
       var _s_ = get(t, i);
       set(res, caml_call2(Base_Import[91], so_far, i), _s_);
       var _t_ = i + 1 | 0;
       if(_r_ === i) break;
       var i = _t_;
      }
     }
     return caml_call2(Base_Import[91], so_far, len);
    }
    caml_call3(Base_List[20], ts, 0, _p_);
    return res;
   }
   function concat_mapi(t, f){
    var _m_ = to_list(t);
    return concat(caml_call2(Base_List[41], _m_, f));
   }
   function concat_map(t, f){
    var _l_ = to_list(t);
    return concat(caml_call2(Base_List[53], _l_, f));
   }
   function partition_map(t, f){
    var
     right = [0, empty],
     left = [0, empty],
     right_idx = [0, 0],
     left_idx = [0, 0];
    function append(data, idx, value){
     if(0 === idx[1]) data[1] = create(caml_call1(length, t), value);
     unsafe_set(data[1], idx[1], value);
     idx[1]++;
     return;
    }
    var
     _g_ = caml_call1(length, t),
     _h_ = caml_call2(Base_Import[93], _g_, 1),
     _f_ = 0;
    if(_h_ >= 0){
     var i = _f_;
     for(;;){
      var match = caml_call1(f, unsafe_get(t, i));
      if(0 === match[0]){
       var a = match[1];
       append(left, left_idx, a);
      }
      else{var a$0 = match[1]; append(right, right_idx, a$0);}
      var _j_ = i + 1 | 0;
      if(_h_ === i) break;
      var i = _j_;
     }
    }
    function trim(data, idx){
     var _k_ = caml_call1(length, t);
     return idx[1] === _k_
             ? data[1]
             : 0 < idx[1] ? caml_call3(sub, data[1], 0, idx[1]) : empty;
    }
    var _i_ = trim(right, right_idx);
    return [0, trim(left, left_idx), _i_];
   }
   function find_map(t, f){
    var length$0 = caml_call1(length, t);
    if(0 === length$0) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[52], value_found[1]) && i[1] < length$0){
      var value = unsafe_get(t, i[1]);
      value_found[1] = caml_call1(f, value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   function find_mapi(t, f){
    var length$0 = caml_call1(length, t);
    if(0 === length$0) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[52], value_found[1]) && i[1] < length$0){
      var value = unsafe_get(t, i[1]);
      value_found[1] = caml_call2(f, i[1], value);
      i[1]++;
      continue;
     }
     return value_found[1];
    }
   }
   function find(t, f){
    function _d_(param){var x = param[2]; return x;}
    var length$0 = caml_call1(length, t);
    if(0 === length$0)
     var _e_ = 0;
    else{
     var i = [0, 0], found = [0, 0], value_found = [0, unsafe_get(t, 0)];
     for(;;){
      if(! found[1] && i[1] < length$0){
       var value = unsafe_get(t, i[1]);
       if(caml_call1(f, value)){
        value_found[1] = value;
        found[1] = 1;
       }
       else
        i[1]++;
       continue;
      }
      if(found[1]){var _e_ = [0, [0, i[1], value_found[1]]]; break;}
      var _e_ = 0;
      break;
     }
    }
    return caml_call2(Base_Option[24], _e_, _d_);
   }
   function findi(t, f){
    var len = caml_call1(length, t), i = 0;
    for(;;){
     if(len <= i) return 0;
     var x = unsafe_get(t, i);
     if(caml_call2(f, i, x)) return [0, [0, i, x]];
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   function t_sexp_grammar(grammar){
    var _c_ = caml_call1(Base_Array[6], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _c_);
   }
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Array[4], Base_Array[5]]),
        [0, to_array, of_array]),
    t_of_sexp = include[1],
    sexp_of_t = include[2];
   function create_like(len, t){
    if(0 === len) return empty;
    if(0 < caml_call1(length, t)) return create(len, get(t, 0));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   var
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub$0 = include$0[4],
    subo = include$0[5];
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function compare_local(compare_elt, a, b){
    if(a === b) return 0;
    var
     len_a = caml_call1(length, a),
     len_b = caml_call1(length, b),
     ret = runtime.caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var
      l = unsafe_get_local(a, i),
      r = unsafe_get_local(b, i),
      res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   function compare(compare_elt, a, b){
    return compare_local(compare_elt, a, b);
   }
   var
    Sort = caml_call1(Base_Array[109][2], [0, unsafe_get, unsafe_set, length]),
    sort = Sort[1],
    include$1 = caml_call1(Base_Binary_searchable[2], [0, unsafe_get, length]),
    binary_search = include$1[1],
    binary_search_segmented = include$1[2],
    Base_Uniform_array =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       compare_local,
       invariant,
       empty,
       create,
       singleton,
       init,
       length,
       get,
       unsafe_get,
       unsafe_get_local,
       set,
       unsafe_set,
       swap,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       set_with_caml_modify,
       map,
       mapi,
       iter,
       iteri,
       fold,
       foldi,
       unsafe_to_array_inplace_promis,
       of_array,
       to_array,
       of_list,
       of_list_rev,
       to_list,
       blit,
       blito,
       unsafe_blit$0,
       sub$0,
       subo,
       copy,
       exists,
       existsi,
       for_all,
       for_alli,
       concat,
       concat_map,
       concat_mapi,
       partition_map,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       find,
       findi,
       find_map,
       find_mapi,
       map2_exn,
       fold2_exn,
       min_elt,
       max_elt,
       sort,
       binary_search,
       binary_search_segmented,
       unsafe_create_uninitialized,
       create_obj_array,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_clear_if_pointer];
   runtime.caml_register_global(18, Base_Uniform_array, "Base__Uniform_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Uchar_intf = [0];
   runtime.caml_register_global(0, Base_Uchar_intf, "Base__Uchar_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar
//# unitInfo: Requires: Base__Bytes0, Base__Comparable, Base__Error, Base__Hash, Base__Hashable, Base__Import, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String0, Base__Uchar0, Base__Uchar_intf, Sexplib0__Sexp_grammar, Stdlib, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_U = "U+",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Uchar",
    codec_name = "UTF-8",
    module_name$0 = "Base.Uchar.Utf8",
    codec_name$0 = "UTF-16LE",
    module_name$1 = "Base.Uchar.Utf16le",
    codec_name$1 = "UTF-16BE",
    module_name$2 = "Base.Uchar.Utf16be",
    codec_name$2 = "UTF-32LE",
    module_name$3 = "Base.Uchar.Utf32le",
    codec_name$3 = "UTF-32BE",
    module_name$4 = "Base.Uchar.Utf32be",
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Base_Bytes0 = global_data.Base__Bytes0,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Hashable = global_data.Base__Hashable,
    Base_Uchar0 = global_data.Base__Uchar0,
    Stdlib = global_data.Stdlib,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Comparable = global_data.Base__Comparable,
    Base_String0 = global_data.Base__String0,
    failwithf = Base_Printf[6],
    is_valid = Base_Uchar0[3],
    is_char = Base_Uchar0[4],
    unsafe_to_char = Base_Uchar0[5],
    unsafe_of_int = Base_Uchar0[6],
    to_int = Base_Uchar0[8],
    of_char = Base_Uchar0[9],
    compare = Base_Uchar0[10],
    min_value = Base_Uchar0[12],
    max_value = Base_Uchar0[13],
    byte_order_mark = Base_Uchar0[14],
    replacement_char = Base_Uchar0[15],
    utf_8_byte_length = Base_Uchar0[16],
    utf_16_byte_length = Base_Uchar0[17],
    cst_string = "string",
    _h_ = [0, "src/uchar.ml", 134, 4],
    cst_of_string_expected_a_singl =
      ".of_string: expected a single Unicode character",
    _g_ =
      [0,
       "Uchar.Decode_result.uchar_exn was called on an invalid decode result"],
    _f_ =
      [0,
       [11,
        "Uchar.to_char_exn got a non latin-1 character: U+",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.to_char_exn got a non latin-1 character: U+%04X"],
    _e_ =
      [0,
       [11,
        "Uchar.of_int_exn got a invalid Unicode scalar value: ",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.of_int_exn got a invalid Unicode scalar value: %04X"],
    _d_ = [0, [11, "Uchar.pred_exn: ", [2, 0, 0]], "Uchar.pred_exn: %s"],
    _c_ = [0, [11, "Uchar.succ_exn: ", [2, 0, 0]], "Uchar.succ_exn: %s"],
    _b_ = [0, [11, cst_U, [4, 8, 0, 0, 0]], "U+%X"],
    cst_Uchar_t_of_sexp_atom_of_th =
      "Uchar.t_of_sexp: atom of the form U+XXXX needed",
    cst_Uchar_t_of_sexp_atom_neede = "Uchar.t_of_sexp: atom needed",
    _a_ = [0, [11, cst_U, [4, 8, [0, 2, 4], 0, 0]], "U+%04X"];
   function hash_fold_t(state, t){
    var _y_ = caml_call1(to_int, t);
    return caml_call2(Base_Hash[3], state, _y_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string_internal(t){
    var _x_ = caml_call1(to_int, t);
    return caml_call2(Base_Printf[2], _a_, _x_);
   }
   function sexp_of_t(t){return [0, to_string_internal(t)];}
   function t_of_sexp(sexp){
    if(0 !== sexp[0])
     return caml_call2(Base_Import[156], cst_Uchar_t_of_sexp_atom_neede, sexp);
    var s = sexp[1];
    try{
     var
      _u_ = function(i){return caml_call1(Base_Uchar0[7], i);},
      _v_ = caml_call3(Stdlib_Scanf[5], s, _b_, _u_);
     return _v_;
    }
    catch(_w_){
     return caml_call2(Base_Import[156], cst_Uchar_t_of_sexp_atom_of_th, sexp);
    }
   }
   var
    t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_Import[182]),
    include =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string_internal]),
    pp = include[1],
    include$0 = caml_call1(Base_Comparable[11], [0, compare, sexp_of_t]),
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator = include$0[16];
   function invariant(param){return 0;}
   function succ_exn(c){
    try{var _t_ = caml_call1(Base_Uchar0[1], c); return _t_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _c_, msg, 0);
    }
   }
   function succ(c){
    try{var _r_ = [0, caml_call1(Base_Uchar0[1], c)]; return _r_;}
    catch(_s_){
     var _q_ = caml_wrap_exception(_s_);
     if(_q_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_q_, 0);
    }
   }
   function pred_exn(c){
    try{var _p_ = caml_call1(Base_Uchar0[2], c); return _p_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _d_, msg, 0);
    }
   }
   function pred(c){
    try{var _n_ = [0, caml_call1(Base_Uchar0[2], c)]; return _n_;}
    catch(_o_){
     var _m_ = caml_wrap_exception(_o_);
     if(_m_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_m_, 0);
    }
   }
   function of_scalar(i){
    return caml_call1(is_valid, i) ? [0, caml_call1(unsafe_of_int, i)] : 0;
   }
   function of_scalar_exn(i){
    return caml_call1(is_valid, i)
            ? caml_call1(unsafe_of_int, i)
            : caml_call3(failwithf, _e_, i, 0);
   }
   function to_scalar(t){return caml_call1(Base_Uchar0[8], t);}
   function to_char(c){
    return caml_call1(is_char, c) ? [0, caml_call1(unsafe_to_char, c)] : 0;
   }
   function to_char_exn(c){
    return caml_call1(is_char, c)
            ? caml_call1(unsafe_to_char, c)
            : caml_call3(failwithf, _f_, caml_call1(to_int, c), 0);
   }
   var compare$0 = runtime.caml_int_compare;
   function equal(_l_, _k_){return _l_ === _k_ ? 1 : 0;}
   function hash_fold_t$0(state, t){
    var _j_ = caml_call1(Base_Hashable[6], t);
    return caml_call2(Base_Import[206], state, _j_);
   }
   var
    hash$0 = Base_Hashable[6],
    is_valid$0 = Base_Uchar0[18],
    bytes_consumed = Base_Uchar0[20],
    uchar_or_replacement_char = Base_Uchar0[19];
   function sexp_of_t$0(t){
    return sexp_of_t(caml_call1(uchar_or_replacement_char, t));
   }
   function uchar(t){
    return caml_call1(is_valid$0, t)
            ? [0, caml_call1(uchar_or_replacement_char, t)]
            : 0;
   }
   function uchar_exn(t){
    return caml_call1(is_valid$0, t)
            ? caml_call1(uchar_or_replacement_char, t)
            : caml_call1(Base_Error[32], _g_);
   }
   function Make_utf(Format){
    var codec_name = Format[1], byte_length = Format[3];
    function to_string(t){
     var
      len = caml_call1(byte_length, t),
      bytes = caml_call1(Base_Bytes0[7], len),
      pos = caml_call3(Format[5], bytes, 0, t);
     if(pos === len) return runtime.caml_string_of_bytes(bytes);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    }
    var
     of_string_message =
       caml_call2(Base_Import[112], Format[2], cst_of_string_expected_a_singl);
    function of_string(string){
     var
      decode = caml_call2(Format[4], string, 0),
      string_len = runtime.caml_ml_string_length(string),
      decode_len = caml_call1(bytes_consumed, decode);
     if(string_len === decode_len && caml_call1(is_valid$0, decode))
      return caml_call1(uchar_or_replacement_char, decode);
     var
      _i_ =
        caml_call2
         (Base_Sexp[10],
          of_string_message,
          [0, [0, cst_string, [0, string]], 0]);
     return caml_call1(Base_Error[32], _i_);
    }
    return [0, of_string, to_string, byte_length, codec_name];
   }
   var
    get_decode_result = Base_String0[15],
    set = Base_Bytes0[8],
    Utf8 =
      Make_utf
       ([0,
         codec_name,
         module_name$0,
         utf_8_byte_length,
         get_decode_result,
         set]),
    get_decode_result$0 = Base_String0[16],
    set$0 = Base_Bytes0[9],
    Utf16le =
      Make_utf
       ([0,
         codec_name$0,
         module_name$1,
         utf_16_byte_length,
         get_decode_result$0,
         set$0]),
    get_decode_result$1 = Base_String0[17],
    set$1 = Base_Bytes0[10],
    Utf16be =
      Make_utf
       ([0,
         codec_name$1,
         module_name$2,
         utf_16_byte_length,
         get_decode_result$1,
         set$1]);
   function byte_length(param){return 4;}
   var
    get_decode_result$2 = Base_String0[18],
    set$2 = Base_Bytes0[12],
    Utf32le =
      Make_utf
       ([0,
         codec_name$2,
         module_name$3,
         byte_length,
         get_decode_result$2,
         set$2]);
   function byte_length$0(param){return 4;}
   var
    get_decode_result$3 = Base_String0[19],
    set$3 = Base_Bytes0[13],
    Utf32be =
      Make_utf
       ([0,
         codec_name$3,
         module_name$4,
         byte_length$0,
         get_decode_result$3,
         set$3]),
    include$1 = Base_Import[107],
    symbol = include$1[1],
    symbol$0 = include$1[2],
    symbol$1 = include$1[3],
    symbol$2 = include$1[4],
    symbol$3 = include$1[5],
    symbol$4 = include$1[6],
    ascending = include$1[7],
    descending = include$1[8],
    compare$1 = include$1[9],
    equal$0 = include$1[10],
    compare_local = include$1[11],
    equal_local = include$1[12],
    max = include$1[13],
    min = include$1[14],
    Base_Uchar =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal$0,
       compare$1,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       compare_local,
       equal_local,
       pp,
       invariant,
       succ,
       succ_exn,
       pred,
       pred_exn,
       is_char,
       to_char,
       to_char_exn,
       of_char,
       is_valid,
       of_scalar,
       of_scalar_exn,
       to_scalar,
       utf_8_byte_length,
       utf_16_byte_length,
       min_value,
       max_value,
       byte_order_mark,
       replacement_char,
       [0,
        compare$0,
        equal,
        hash_fold_t$0,
        hash$0,
        sexp_of_t$0,
        is_valid$0,
        bytes_consumed,
        uchar,
        uchar_exn,
        uchar_or_replacement_char],
       Utf8,
       Utf16le,
       Utf16be,
       Utf32le,
       Utf32be];
   runtime.caml_register_global(38, Base_Uchar, "Base__Uchar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Type_equal_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function Type_equal_defns(Type_equal){
    function Composition_preserves_injectiv(M1, M2){
     function strip(e){
      var _a_ = caml_call1(M2[1], e);
      return caml_call1(M1[1], _a_);
     }
     return [0, strip];
    }
    return [0, Composition_preserves_injectiv];
   }
   function Type_equal_id_defns(Id){return [0];}
   var Base_Type_equal_intf = [0, Type_equal_defns, Type_equal_id_defns];
   runtime.caml_register_global
    (0, Base_Type_equal_intf, "Base__Type_equal_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Type_equal
//# unitInfo: Requires: Base__Comparable, Base__Error, Base__Hash, Base__Import, Base__Sexp, Base__Type_equal_intf, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_T = "T",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Hash = global_data.Base__Hash,
    Base_Type_equal_intf = global_data.Base__Type_equal_intf,
    Base_Comparable = global_data.Base__Comparable,
    _g_ = [0, 0],
    cst_Base_Type_equal_Id_Create3 = "Base__Type_equal.Id.Create3(T).T3",
    _f_ = [0, 0],
    cst_Base_Type_equal_Id_Create2 = "Base__Type_equal.Id.Create2(T).T2",
    _e_ = [0, 0],
    cst_Base_Type_equal_Id_Create1 = "Base__Type_equal.Id.Create1(T).T1",
    _d_ = [0, 0],
    cst_Base_Type_equal_Id_Create0 = "Base__Type_equal.Id.Create0(T).T0",
    cst_Type_equal_Id_same_witness =
      "Type_equal.Id.same_witness_exn got different ids",
    _c_ = [0, cst_T],
    _b_ = [0, 0, 0],
    _a_ = [0, cst_T];
   function sexp_of_t(of_a_001, of_b_002, param){return _a_;}
   var
    include = caml_call1(Base_Type_equal_intf[1], [0]),
    Composition_preserves_injectiv = include[1],
    refl = 0;
   function sym(param){return 0;}
   function trans(param, _E_){return 0;}
   function conv(param, a){return a;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   function Lift2(X){function lift(param, _D_){return 0;} return [0, lift];}
   function Lift3(X){
    function lift(param, _C_, _B_){return 0;}
    return [0, lift];
   }
   function detuple2(param){return _b_;}
   function tuple2(param, _A_){return 0;}
   function compare(a_005, b_006){
    if(a_005 === b_006) return 0;
    var
     b_010 = b_006[2],
     b_008 = b_006[1],
     a_009 = a_005[2],
     a_007 = a_005[1],
     n = caml_call2(Base_Import[228], a_007, b_008);
    return 0 === n ? caml_call3(Base_Import[236], compare, a_009, b_010) : n;
   }
   var
    hash_fold_t = function _z_(_x_, _y_){return _z_.fun(_x_, _y_);},
    hash = function _w_(_v_){return _w_.fun(_v_);};
   caml_update_dummy
    (hash_fold_t,
     function(hsv, arg){
      var
       a1 = arg[2],
       a0 = arg[1],
       hsv$0 = caml_call2(Base_Import[206], hsv, a0);
      return caml_call3(Base_Import[212], hash_fold_t, hsv$0, a1);
     });
   caml_update_dummy
    (hash,
     function(arg){
      var
       hsv = caml_call2(Base_Hash[11], 0, 0),
       _u_ = caml_call2(hash_fold_t, hsv, arg);
      return caml_call1(Base_Hash[9], _u_);
     });
   function sexp_of_t$0(param){
    var
     arg1_014 = param[2],
     arg0_013 = param[1],
     res0_015 = caml_call1(Base_Import[139], arg0_013),
     res1_016 = caml_call2(Base_Import[149], sexp_of_t$0, arg1_014);
    return [1, [0, _c_, [0, res0_015, [0, res1_016, 0]]]];
   }
   var
    include$0 = caml_call1(Base_Comparable[11], [0, compare, sexp_of_t$0]),
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    equal = include$0[7],
    compare$0 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator = include$0[16];
   function create(key, args){
    var
     _t_ = caml_call1(Stdlib_Obj[23][1], key),
     tag = caml_call1(Stdlib_Obj[23][3], _t_);
    return [0, tag, args];
   }
   function uid(A){return A[2];}
   function name(A){return A[3];}
   function sexp_of_t$1(param, A){return A[4];}
   function to_sexp(A){return A[1];}
   function hash$0(t){return caml_call1(hash, t[2]);}
   function hash_fold_t$0(state, t){
    return caml_call2(hash_fold_t, state, t[2]);
   }
   function same_witness(A, B){return caml_call1(A[6], B[5]);}
   function same_witness_exn(t1, t2){
    var match = same_witness(t1, t2);
    if(match){var equal = match[1]; return equal;}
    var _l_ = 0, _m_ = [0, t1, t2];
    function _n_(_s_){return _s_[4];}
    function _o_(_r_){return _r_[4];}
    var
     _p_ = [0, [0, cst, caml_call3(Base_Import[147], _o_, _n_, _m_)], _l_],
     _q_ = caml_call2(Base_Sexp[10], cst_Type_equal_Id_same_witness, _p_);
    return caml_call1(Base_Error[32], _q_);
   }
   function same(t1, t2){return same_witness(t1, t2) ? 1 : 0;}
   caml_call1(Base_Type_equal_intf[2], [0]);
   function Create0(T){
    var
     T0 = [248, cst_Base_Type_equal_Id_Create0, caml_fresh_oo_id(0)],
     id_name = T[2],
     id_sexp = [0, id_name],
     sexp_of_t = T[1],
     uid = create(T0, 0);
    function type_equal(otherkey){return otherkey === T0 ? _d_ : 0;}
    var type_equal_id = [0, sexp_of_t, uid, id_name, id_sexp, T0, type_equal];
    return [0, , type_equal_id];
   }
   function create$0(name, sexp_of_t){
    return Create0([0, sexp_of_t, name])[2];
   }
   function _h_(T){
    var T3 = [248, cst_Base_Type_equal_Id_Create3, caml_fresh_oo_id(0)];
    function type_equal_id(A, B, C){
     var
      id_name = T[2],
      id_sexp = [1, [0, [0, id_name], [0, A[4], [0, B[4], [0, C[4], 0]]]]];
     function sexp_of_t(t){return caml_call4(T[1], A[1], B[1], C[1], t);}
     var
      type_key = [0, T3, A[5], B[5], C[5]],
      uid = create(type_key, [0, A[2], [0, B[2], [0, C[2], 0]]]);
     function type_equal(otherkey){
      if(otherkey[1] !== T3) return 0;
      var
       ckey = otherkey[4],
       bkey = otherkey[3],
       akey = otherkey[2],
       match = caml_call1(A[6], akey),
       match$0 = caml_call1(B[6], bkey),
       match$1 = caml_call1(C[6], ckey);
      if(match && match$0 && match$1) return _g_;
      return 0;
     }
     return [0, sexp_of_t, uid, id_name, id_sexp, type_key, type_equal];
    }
    return [0, type_equal_id];
   }
   function _i_(T){
    var T2 = [248, cst_Base_Type_equal_Id_Create2, caml_fresh_oo_id(0)];
    function type_equal_id(A, B){
     var
      id_name = T[2],
      id_sexp = [1, [0, [0, id_name], [0, A[4], [0, B[4], 0]]]];
     function sexp_of_t(t){return caml_call3(T[1], A[1], B[1], t);}
     var
      type_key = [0, T2, A[5], B[5]],
      uid = create(type_key, [0, A[2], [0, B[2], 0]]);
     function type_equal(otherkey){
      if(otherkey[1] !== T2) return 0;
      var
       bkey = otherkey[3],
       akey = otherkey[2],
       match = caml_call1(A[6], akey),
       match$0 = caml_call1(B[6], bkey);
      if(match && match$0) return _f_;
      return 0;
     }
     return [0, sexp_of_t, uid, id_name, id_sexp, type_key, type_equal];
    }
    return [0, type_equal_id];
   }
   function _j_(T){
    var T1 = [248, cst_Base_Type_equal_Id_Create1, caml_fresh_oo_id(0)];
    function type_equal_id(A){
     var id_name = T[2], id_sexp = [1, [0, [0, id_name], [0, A[4], 0]]];
     function sexp_of_t(t){return caml_call2(T[1], A[1], t);}
     var type_key = [0, T1, A[5]], uid = create(type_key, [0, A[2], 0]);
     function type_equal(otherkey){
      if(otherkey[1] !== T1) return 0;
      var akey = otherkey[2];
      return caml_call1(A[6], akey) ? _e_ : 0;
     }
     return [0, sexp_of_t, uid, id_name, id_sexp, type_key, type_equal];
    }
    return [0, type_equal_id];
   }
   var
    Base_Type_equal =
      [0,
       sexp_of_t,
       Composition_preserves_injectiv,
       refl,
       sym,
       trans,
       conv,
       Lift,
       Lift2,
       Lift3,
       detuple2,
       tuple2,
       [0,
        sexp_of_t$1,
        [0,
         hash_fold_t,
         hash,
         sexp_of_t$0,
         symbol,
         symbol$0,
         symbol$1,
         symbol$2,
         symbol$3,
         symbol$4,
         equal,
         compare$0,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator],
        uid,
        create$0,
        hash$0,
        name,
        to_sexp,
        hash_fold_t$0,
        same,
        same_witness,
        same_witness_exn,
        function(_k_){return [0, Create0(_k_)[2]];},
        _j_,
        _i_,
        _h_]];
   runtime.caml_register_global(20, Base_Type_equal, "Base__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stack_intf = [0];
   runtime.caml_register_global(0, Base_Stack_intf, "Base__Stack_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option_array
//# unitInfo: Requires: Base__Array, Base__Blit, Base__Import, Base__Indexed_container, Base__Option, Base__Sexpable, Base__Uniform_array, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array = global_data.Base__Array,
    Base_Import = global_data.Base__Import,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Option = global_data.Base__Option,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Blit = global_data.Base__Blit,
    none_substitute = runtime.caml_obj_block(Stdlib_Obj[14], 1),
    cst_Option_array_get_some_exn_ =
      "Option_array.get_some_exn: the element is [None]",
    none = 24791911;
   function is_none(x){return x === 24791911 ? 1 : 0;}
   function is_some(x){return 1 - (x === 24791911 ? 1 : 0);}
   function some(x){return x === 24791911 ? none_substitute : x;}
   function value_unsafe(x){return x === none_substitute ? none : x;}
   function value_exn(x){
    return is_some(x)
            ? value_unsafe(x)
            : caml_call1(Base_Import[124], cst_Option_array_get_some_exn_);
   }
   function of_sexpable(param){
    if(! param) return none;
    var x = param[1];
    return some(x);
   }
   function to_sexpable(x){return is_some(x) ? [0, value_unsafe(x)] : 0;}
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Option[9], Base_Option[10]]),
        [0, to_sexpable, of_sexpable]),
    t_of_sexp = include[1],
    sexp_of_t = include[2];
   function t_of_sexp$0(of_a_001, x_003){
    var _A_ = caml_call1(t_of_sexp, of_a_001);
    return caml_call2(Base_Uniform_array[1], _A_, x_003);
   }
   function sexp_of_t$0(of_a_004, x_005){
    var _z_ = caml_call1(sexp_of_t, of_a_004);
    return caml_call2(Base_Uniform_array[2], _z_, x_005);
   }
   function t_sexp_grammar(a_sexp_grammar){
    var
     _x_ = caml_call1(Base_Option[5], a_sexp_grammar),
     _y_ = caml_call1(Sexplib0_Sexp_grammar[1], _x_);
    return caml_call1(Base_Uniform_array[3], _y_);
   }
   var empty = Base_Uniform_array[7];
   function create(len){return caml_call2(Base_Uniform_array[8], len, none);}
   function init(n, f){
    function _w_(i){return of_sexpable(caml_call1(f, i));}
    return caml_call2(Base_Uniform_array[10], n, _w_);
   }
   function init_some(n, f){
    function _v_(i){return some(caml_call1(f, i));}
    return caml_call2(Base_Uniform_array[10], n, _v_);
   }
   var _a_ = Base_Uniform_array[11];
   function get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[12], t, i));
   }
   function get_local(t, i){
    var x = caml_call2(Base_Uniform_array[12], t, i);
    return is_some(x) ? [0, value_unsafe(x)] : 0;
   }
   function get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[12], t, i));
   }
   function is_none$0(t, i){
    return caml_call2(Base_Uniform_array[12], t, i) === 24791911 ? 1 : 0;
   }
   function is_some$0(t, i){
    return is_some(caml_call2(Base_Uniform_array[12], t, i));
   }
   function set(t, i, x){
    var _u_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[15], t, i, _u_);
   }
   function set_some(t, i, x){
    var _t_ = some(x);
    return caml_call3(Base_Uniform_array[15], t, i, _t_);
   }
   function set_none(t, i){
    return caml_call3(Base_Uniform_array[15], t, i, none);
   }
   function swap(t, i, j){return caml_call3(Base_Uniform_array[17], t, i, j);}
   function unsafe_get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[13], t, i));
   }
   function unsafe_get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[13], t, i));
   }
   function unsafe_get_some_assuming_some(t, i){
    return value_unsafe(caml_call2(Base_Uniform_array[13], t, i));
   }
   function unsafe_is_some(t, i){
    return is_some(caml_call2(Base_Uniform_array[13], t, i));
   }
   function unsafe_set(t, i, x){
    var _s_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[16], t, i, _s_);
   }
   function unsafe_set_some(t, i, x){
    var _r_ = some(x);
    return caml_call3(Base_Uniform_array[16], t, i, _r_);
   }
   function unsafe_set_none(t, i){
    return caml_call3(Base_Uniform_array[16], t, i, none);
   }
   function clear(t){
    var
     _o_ = caml_call1(_a_, t),
     _p_ = caml_call2(Base_Import[93], _o_, 1),
     _n_ = 0;
    if(_p_ >= 0){
     var i = _n_;
     for(;;){
      unsafe_set_none(t, i);
      var _q_ = i + 1 | 0;
      if(_p_ === i) break;
      var i = _q_;
     }
    }
    return 0;
   }
   function _b_(input, f){
    var
     _k_ = caml_call1(_a_, input),
     _l_ = caml_call2(Base_Import[93], _k_, 1),
     _j_ = 0;
    if(_l_ >= 0){
     var i = _j_;
     for(;;){
      caml_call2(f, i, unsafe_get(input, i));
      var _m_ = i + 1 | 0;
      if(_l_ === i) break;
      var i = _m_;
     }
    }
    return 0;
   }
   function _c_(input, f){
    return _b_(input, function(param, x){return caml_call1(f, x);});
   }
   function _d_(input, init, f){
    var acc = [0, init];
    _b_
     (input,
      function(i, elem){acc[1] = caml_call3(f, i, acc[1], elem); return 0;});
    return acc[1];
   }
   function fold(input, init, f){
    return _d_
            (input,
             init,
             function(param, acc, x){return caml_call2(f, acc, x);});
   }
   var
    foldi = [0, -198771759, _d_],
    iter = [0, -198771759, _c_],
    iteri = [0, -198771759, _b_],
    length = [0, -198771759, _a_],
    include$0 =
      caml_call1
       (Base_Indexed_container[10], [0, fold, iter, length, iteri, foldi]),
    is_empty = include$0[2],
    mem = include$0[3],
    iter$0 = include$0[4],
    fold$0 = include$0[5],
    fold_result = include$0[6],
    fold_until = include$0[7],
    exists = include$0[8],
    for_all = include$0[9],
    count = include$0[10],
    sum = include$0[11],
    find = include$0[12],
    find_map = include$0[13],
    to_list = include$0[14],
    min_elt = include$0[16],
    max_elt = include$0[17],
    foldi$0 = include$0[18],
    iteri$0 = include$0[19],
    existsi = include$0[20],
    for_alli = include$0[21],
    counti = include$0[22],
    findi = include$0[23],
    find_mapi = include$0[24],
    length$0 = Base_Uniform_array[11];
   function map(input, f){
    var output = create(caml_call1(length$0, input));
    caml_call2
     (iteri$0,
      input,
      function(i, elem){return unsafe_set(output, i, caml_call1(f, elem));});
    return output;
   }
   function map_some(input, f){
    var
     len = caml_call1(length$0, input),
     output = create(len),
     _h_ = caml_call2(Base_Import[93], len, 1),
     _g_ = 0;
    if(_h_ >= 0){
     var i = _g_;
     for(;;){
      var opt = caml_call2(Base_Uniform_array[13], input, i);
      if(is_some(opt)){
       var x = value_unsafe(opt);
       unsafe_set_some(output, i, caml_call1(f, x));
      }
      var _i_ = i + 1 | 0;
      if(_h_ === i) break;
      var i = _i_;
     }
    }
    return output;
   }
   function of_array(array){
    return init(array.length - 1, function(i){return array[1 + i];});
   }
   function of_array_some(array){
    return init_some(array.length - 1, function(i){return array[1 + i];});
   }
   function to_array(t){
    function _e_(i){return unsafe_get(t, i);}
    var _f_ = caml_call1(length$0, t);
    return caml_call2(Base_Array[41], _f_, _e_);
   }
   function create_like(len, param){return create(len);}
   var
    unsafe_blit = Base_Uniform_array[35],
    include$1 =
      caml_call1(Base_Blit[5], [0, create_like, length$0, unsafe_blit]),
    blit = include$1[1],
    blito = include$1[2],
    unsafe_blit$0 = include$1[3],
    sub = include$1[4],
    subo = include$1[5],
    copy = Base_Uniform_array[38],
    Base_Option_array =
      [0,
       t_of_sexp$0,
       sexp_of_t$0,
       t_sexp_grammar,
       empty,
       create,
       is_empty,
       mem,
       iter$0,
       fold$0,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       min_elt,
       max_elt,
       foldi$0,
       iteri$0,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       length$0,
       init_some,
       init,
       of_array,
       of_array_some,
       to_array,
       get,
       get_local,
       get_some_exn,
       is_none$0,
       is_some$0,
       unsafe_get,
       unsafe_get_some_exn,
       unsafe_get_some_assuming_some,
       unsafe_is_some,
       set,
       set_some,
       set_none,
       swap,
       clear,
       map,
       map_some,
       unsafe_set,
       unsafe_set_some,
       unsafe_set_none,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       copy,
       [0,
        [0,
         t_of_sexp,
         sexp_of_t,
         none,
         some,
         is_none,
         is_some,
         value_exn,
         value_unsafe,
         to_sexpable,
         of_sexpable]]];
   runtime.caml_register_global(10, Base_Option_array, "Base__Option_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack
//# unitInfo: Requires: Base__Container, Base__Error, Base__Exn, Base__Import, Base__List, Base__Option_array, Base__Sexp, Base__Stack_intf, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_stack_ml = "src/stack.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Exn = global_data.Base__Exn,
    Base_Error = global_data.Base__Error,
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Sexp = global_data.Base__Sexp,
    Base_Container = global_data.Base__Container,
    raise_s = Base_Error[32],
    _e_ = [0, cst_src_stack_ml, 109, 14],
    _d_ = [0, cst_src_stack_ml, 41, 4],
    _c_ = [0, cst_src_stack_ml, 48, 6],
    cst_stack = "stack",
    cst_exn = "exn",
    cst_Stack_invariant_failed = "Stack.invariant failed",
    _a_ = [0, "elts"],
    _b_ = [0, "length"],
    cst_Stack_pop_of_empty_stack = "Stack.pop of empty stack",
    cst_Stack_top_of_empty_stack = "Stack.top of empty stack";
   function capacity(t){return caml_call1(Base_Option_array[28], t[2]);}
   function invariant(invariant_a, t){
    var length = t[1], elts = t[2];
    try{
     if(0 <= length && length <= caml_call1(Base_Option_array[28], elts)){
      var _P_ = caml_call2(Base_Import[93], length, 1), _O_ = 0;
      if(_P_ >= 0){
       var i$0 = _O_;
       for(;;){
        caml_call1(invariant_a, caml_call2(Base_Option_array[36], elts, i$0));
        var _U_ = i$0 + 1 | 0;
        if(_P_ === i$0) break;
        var i$0 = _U_;
       }
      }
      var
       _Q_ = caml_call1(Base_Option_array[28], elts),
       _R_ = caml_call2(Base_Import[93], _Q_, 1);
      if(_R_ >= length){
       var i = length;
       for(;;){
        if(caml_call2(Base_Option_array[38], elts, i))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        var _T_ = i + 1 | 0;
        if(_R_ === i) break;
        var i = _T_;
       }
      }
      var _S_ = 0;
      return _S_;
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      of_a_001 = Base_Import[152],
      length_003 = t[1],
      elts_005 = t[2],
      arg_006 = caml_call2(Base_Option_array[2], of_a_001, elts_005),
      bnds_002 = [0, [1, [0, _a_, [0, arg_006, 0]]], 0],
      arg_004 = caml_call1(Base_Import[139], length_003),
      bnds_002$0 = [0, [1, [0, _b_, [0, arg_004, 0]]], bnds_002],
      _N_ =
        [0,
         [0, cst_exn, caml_call1(Base_Exn[1], exn)],
         [0, [0, cst_stack, [1, bnds_002$0]], 0]];
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[10], cst_Stack_invariant_failed, _N_));
    }
   }
   function create(param){return [0, 0, Base_Option_array[4]];}
   function length(t){return t[1];}
   function is_empty(t){return 0 === t[1] ? 1 : 0;}
   function fold(t, init, f){
    var r = [0, init], _K_ = caml_call2(Base_Import[93], t[1], 1);
    if(_K_ >= 0){
     var i = _K_;
     for(;;){
      var _L_ = caml_call2(Base_Option_array[36], t[2], i);
      r[1] = caml_call2(f, r[1], _L_);
      var _M_ = i - 1 | 0;
      if(0 === i) break;
      var i = _M_;
     }
    }
    return r[1];
   }
   function iter(t, f){
    var _I_ = caml_call2(Base_Import[93], t[1], 1);
    if(_I_ >= 0){
     var i = _I_;
     for(;;){
      caml_call1(f, caml_call2(Base_Option_array[36], t[2], i));
      var _J_ = i - 1 | 0;
      if(0 === i) break;
      var i = _J_;
     }
    }
    return 0;
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C = caml_call1(Base_Container[17], [0, fold, iter$0, length$0]),
    mem = C[1],
    exists = C[8],
    for_all = C[9],
    count = C[10],
    sum = C[11],
    find = C[12],
    find_map = C[13],
    to_list = C[14],
    to_array = C[15],
    min_elt = C[16],
    max_elt = C[17],
    fold_result = C[6],
    fold_until = C[7];
   function of_list(l){
    if(caml_call1(Base_List[18], l)) return create(0);
    var
     length = caml_call1(Base_List[45], l),
     _F_ = caml_call2(Base_Import[88], 2, length),
     elts = caml_call1(Base_Option_array[5], _F_),
     r = [0, l],
     _G_ = caml_call2(Base_Import[93], length, 1);
    if(_G_ >= 0){
     var i = _G_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var l$0 = match[2], a = match[1];
      caml_call3(Base_Option_array[44], elts, i, a);
      r[1] = l$0;
      var _H_ = i - 1 | 0;
      if(0 === i) break;
      var i = _H_;
     }
    }
    return [0, length, elts];
   }
   function sexp_of_t(sexp_of_a, t){
    var _E_ = caml_call1(to_list, t);
    return caml_call2(Base_List[6], sexp_of_a, _E_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[5], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _D_ = caml_call1(Base_List[7], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _D_);
   }
   function resize(t, size){
    var arr = caml_call1(Base_Option_array[5], size);
    caml_call5(Base_Option_array[53], t[2], 0, arr, 0, t[1]);
    t[2] = arr;
    return 0;
   }
   function set_capacity(t, new_capacity){
    var
     new_capacity$0 = caml_call2(Base_Import[100], new_capacity, t[1]),
     _C_ = new_capacity$0 !== capacity(t) ? 1 : 0;
    return _C_ ? resize(t, new_capacity$0) : _C_;
   }
   function push(t, a){
    var _A_ = caml_call1(Base_Option_array[28], t[2]);
    if(t[1] === _A_){
     var _B_ = caml_call2(Base_Import[91], t[1], 1);
     resize(t, caml_call2(Base_Import[88], 2, _B_));
    }
    caml_call3(Base_Option_array[44], t[2], t[1], a);
    t[1] = caml_call2(Base_Import[91], t[1], 1);
    return 0;
   }
   function pop_nonempty(t){
    var
     i = caml_call2(Base_Import[93], t[1], 1),
     result = caml_call2(Base_Option_array[36], t[2], i);
    caml_call2(Base_Option_array[45], t[2], i);
    t[1] = i;
    return result;
   }
   var pop_error = caml_call1(Base_Error[14], cst_Stack_pop_of_empty_stack);
   function pop(t){return is_empty(t) ? 0 : [0, pop_nonempty(t)];}
   function pop_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[31], pop_error)
            : pop_nonempty(t);
   }
   function top_nonempty(t){
    var _z_ = caml_call2(Base_Import[93], t[1], 1);
    return caml_call2(Base_Option_array[36], t[2], _z_);
   }
   var top_error = caml_call1(Base_Error[14], cst_Stack_top_of_empty_stack);
   function top(t){return is_empty(t) ? 0 : [0, top_nonempty(t)];}
   function top_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[31], top_error)
            : top_nonempty(t);
   }
   function copy(param){
    var length = param[1], elts = param[2];
    return [0, length, caml_call1(Base_Option_array[58], elts)];
   }
   function clear(t){
    var _u_ = 0 < t[1] ? 1 : 0;
    if(_u_){
     var _w_ = caml_call2(Base_Import[93], t[1], 1), _v_ = 0;
     if(_w_ >= 0){
      var i = _v_;
      for(;;){
       caml_call2(Base_Option_array[45], t[2], i);
       var _y_ = i + 1 | 0;
       if(_w_ === i) break;
       var i = _y_;
      }
     }
     t[1] = 0;
     var _x_ = 0;
    }
    else
     var _x_ = _u_;
    return _x_;
   }
   function until_empty(t, f){
    for(;;){
     var _t_ = 0 < t[1] ? 1 : 0;
     if(! _t_) return _t_;
     caml_call1(f, pop_nonempty(t));
    }
   }
   function filter_map(t, f){
    var
     t_result = create(0),
     _r_ = caml_call2(Base_Import[93], t[1], 1),
     _q_ = 0;
    if(_r_ >= 0){
     var i = _q_;
     for(;;){
      var match = caml_call1(f, caml_call2(Base_Option_array[36], t[2], i));
      if(match){var x = match[1]; push(t_result, x);}
      var _s_ = i + 1 | 0;
      if(_r_ === i) break;
      var i = _s_;
     }
    }
    return t_result;
   }
   function filter(t, f){
    var
     t_result = create(0),
     _o_ = caml_call2(Base_Import[93], t[1], 1),
     _n_ = 0;
    if(_o_ >= 0){
     var i = _n_;
     for(;;){
      var x = caml_call2(Base_Option_array[36], t[2], i);
      if(caml_call1(f, x)) push(t_result, x);
      var _p_ = i + 1 | 0;
      if(_o_ === i) break;
      var i = _p_;
     }
    }
    return t_result;
   }
   function filter_inplace(t, f){
    var write_index = [0, 0];
    function _f_(param){
     var _k_ = write_index[1], _l_ = caml_call2(Base_Import[93], t[1], 1);
     if(_l_ >= _k_){
      var i = _k_;
      for(;;){
       caml_call2(Base_Option_array[52], t[2], i);
       var _m_ = i + 1 | 0;
       if(_l_ === i) break;
       var i = _m_;
      }
     }
     t[1] = write_index[1];
     return 0;
    }
    function _g_(param){
     var _i_ = caml_call2(Base_Import[93], t[1], 1), _h_ = 0;
     if(_i_ >= 0){
      var read_index = _h_;
      for(;;){
       var x = caml_call2(Base_Option_array[41], t[2], read_index);
       if(caml_call1(f, x)){
        if(write_index[1] < read_index)
         caml_call3(Base_Option_array[51], t[2], write_index[1], x);
        write_index[1]++;
       }
       var _j_ = read_index + 1 | 0;
       if(_i_ === read_index) break;
       var read_index = _j_;
      }
     }
     return 0;
    }
    return caml_call2(Base_Exn[13], _g_, _f_);
   }
   function singleton(x){var t = create(0); push(t, x); return t;}
   var
    Base_Stack =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       of_list,
       create,
       singleton,
       push,
       pop,
       pop_exn,
       top,
       top_exn,
       clear,
       copy,
       until_empty,
       filter_map,
       filter,
       filter_inplace,
       capacity,
       set_capacity];
   runtime.caml_register_global(19, Base_Stack, "Base__Stack");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position
//# unitInfo: Requires: Base__Comparable, Base__Import, Base__Int, Base__Source_code_position0, Base__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Int = global_data.Base__Int,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Comparable = global_data.Base__Comparable;
   function hash_override(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1],
     _b_ = caml_call1(Base_Int[8], pos_cnum),
     _c_ = caml_call1(Base_Int[8], pos_bol),
     _d_ = caml_call1(Base_Int[8], pos_lnum),
     _e_ = runtime.Base_hash_string(pos_fname),
     _f_ = caml_call2(Base_Import[121], _e_, _d_),
     _g_ = caml_call2(Base_Import[121], _f_, _c_);
    return caml_call2(Base_Import[121], _g_, _b_);
   }
   var
    compare_local = Base_Source_code_position0[2],
    hash_fold_t = Base_Source_code_position0[4],
    comparator = Base_Source_code_position0[6],
    to_string = Base_Source_code_position0[8],
    sexp_of_t = Base_Source_code_position0[9],
    include = caml_call1(Base_Comparable[12], [0, sexp_of_t, comparator]),
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    ascending = include[11],
    descending = include[12],
    between = include[13],
    clamp_exn = include[14],
    clamp = include[15],
    comparator$0 = include[16];
   function equal_local(a, b){
    var _a_ = caml_call2(compare_local, a, b);
    return caml_call2(Base_Import[242], _a_, 0);
   }
   function of_pos(param){
    var pos_cnum = param[3], pos_lnum = param[2], pos_fname = param[1];
    return [0, pos_fname, pos_lnum, 0, pos_cnum];
   }
   var
    Base_Source_code_position =
      [0,
       hash_fold_t,
       hash_override,
       sexp_of_t,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator$0,
       equal_local,
       compare_local,
       to_string,
       of_pos];
   runtime.caml_register_global
    (4, Base_Source_code_position, "Base__Source_code_position");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign_or_nan
//# unitInfo: Requires: Base__Hash, Base__Identifiable, Base__Import, Base__Poly0, Base__Sign, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Nan = "Nan",
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_nan = "nan",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero$0 = "zero",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign_or_nan.ml.T.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0,
          [1, [0, cst_Zero, 0]],
          [0, [1, [0, cst_Pos, 0]], [0, [1, [0, cst_Nan, 0]], 0]]]]]],
    all = [0, 0, [0, 1, [0, 2, [0, 3, 0]]]],
    module_name = "Base.Sign_or_nan",
    Base_Sign = global_data.Base__Sign,
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Identifiable = global_data.Base__Identifiable,
    cst_negative = "negative",
    cst_zero = cst_zero$0,
    cst_positive = "positive",
    cst_not_a_number = "not-a-number",
    cst_Base_Sign_or_nan_to_sign_e = "Base.Sign_or_nan.to_sign_exn: Nan",
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos],
    _d_ = [0, cst_Nan];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _l_ = sexp_004[1];
      b:
      if(caml_string_notequal(_l_, cst_Nan)){
       c:
       if(caml_string_notequal(_l_, cst_Neg)){
        d:
        if(caml_string_notequal(_l_, cst_Pos)){
         if(caml_string_notequal(_l_, cst_Zero)){
          if(! caml_string_notequal(_l_, cst_nan)) break b;
          if(! caml_string_notequal(_l_, cst_neg)) break c;
          if(! caml_string_notequal(_l_, cst_pos)) break d;
          if(caml_string_notequal(_l_, cst_zero$0)) break a;
         }
         return 1;
        }
        return 2;
       }
       return 0;
      }
      return 3;
     }
     var _m_ = sexp_004[1];
     if(! _m_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_003, sexp_004);
     var _n_ = _m_[1];
     if(0 !== _n_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_003, sexp_004);
     var _o_ = _n_[1];
     b:
     if(caml_string_notequal(_o_, cst_Nan)){
      c:
      if(caml_string_notequal(_o_, cst_Neg)){
       d:
       if(caml_string_notequal(_o_, cst_Pos)){
        if(caml_string_notequal(_o_, cst_Zero)){
         if(! caml_string_notequal(_o_, cst_nan)) break b;
         if(! caml_string_notequal(_o_, cst_neg)) break c;
         if(! caml_string_notequal(_o_, cst_pos)) break d;
         if(caml_string_notequal(_o_, cst_zero$0)) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){
      case 0:
       return _a_;
      case 1:
       return _b_;
      case 2:
       return _c_;
      default: return _d_;
    }
   }
   var compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       var _k_ = 0; break;
      case 1:
       var _k_ = 1; break;
      case 2:
       var _k_ = 2; break;
      default: var _k_ = 3;
    }
    return caml_call2(Base_Hash[3], hsv, _k_);
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _j_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _j_);
   }
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[136], s));}
   function to_string(t){
    var _i_ = sexp_of_t(t);
    return caml_call1(Base_Import[160], _i_);
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare, compare_local = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function equal_local(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    _e_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = _e_[1],
    hash$0 = _e_[2],
    t_of_sexp$0 = _e_[3],
    sexp_of_t$0 = _e_[4],
    of_string$0 = _e_[5],
    to_string$0 = _e_[6],
    between = _e_[19],
    clamp_exn = _e_[20],
    clamp = _e_[21],
    comparator = _e_[22],
    pp = _e_[23],
    hashable = _e_[24];
   function of_sign(param){
    switch(param){case 0: return 0;case 1: return 1;default: return 2;
    }
   }
   function to_sign_exn(param){
    switch(param){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      default:
       return caml_call1(Base_Import[126], cst_Base_Sign_or_nan_to_sign_e);
    }
   }
   function of_int(n){return of_sign(caml_call1(Base_Sign[30], n));}
   function to_int_exn(t){
    var _h_ = to_sign_exn(t);
    return caml_call1(Base_Sign[31], _h_);
   }
   function flip(param){
    switch(param){
      case 0:
       return 2;
      case 1:
       return 1;
      case 2:
       return 0;
      default: return 3;
    }
   }
   function symbol$5(t$0, t){
    if(3 > t$0 && 3 > t){
     var _f_ = to_sign_exn(t), _g_ = to_sign_exn(t$0);
     return of_sign(caml_call2(Base_Sign[34], _g_, _f_));
    }
    return 3;
   }
   function to_string_hum(param){
    switch(param){
      case 0:
       return cst_negative;
      case 1:
       return cst_zero;
      case 2:
       return cst_positive;
      default: return cst_not_a_number;
    }
   }
   var
    Base_Sign_or_nan =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       compare_local,
       equal_local,
       to_string_hum,
       of_int,
       to_int_exn,
       of_sign,
       to_sign_exn,
       flip,
       symbol$5];
   runtime.caml_register_global(35, Base_Sign_or_nan, "Base__Sign_or_nan");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp_with_comparable
//# unitInfo: Requires: Base__Comparable, Base__Sexp
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Base_Comparable = global_data.Base__Comparable,
    _a_ = caml_call1(Base_Comparable[11], [0, Base_Sexp[7], Base_Sexp[5]]),
    symbol = _a_[1],
    symbol$0 = _a_[2],
    symbol$1 = _a_[3],
    symbol$2 = _a_[4],
    symbol$3 = _a_[5],
    symbol$4 = _a_[6],
    min = _a_[9],
    max = _a_[10],
    ascending = _a_[11],
    descending = _a_[12],
    between = _a_[13],
    clamp_exn = _a_[14],
    clamp = _a_[15],
    comparator = _a_[16],
    globalize = Base_Sexp[1],
    hash_fold_t = Base_Sexp[2],
    hash = Base_Sexp[3],
    t_of_sexp = Base_Sexp[4],
    sexp_of_t = Base_Sexp[5],
    equal = Base_Sexp[6],
    compare = Base_Sexp[7],
    Not_found_s = Base_Sexp[8],
    Of_sexp_error = Base_Sexp[9],
    message = Base_Sexp[10],
    default_indent = Base_Sexp[11],
    pp_hum = Base_Sexp[12],
    pp_hum_indent = Base_Sexp[13],
    pp_mach = Base_Sexp[14],
    pp = Base_Sexp[15],
    to_string_hum = Base_Sexp[16],
    to_string_mach = Base_Sexp[17],
    to_string = Base_Sexp[18],
    of_float_style = Base_Sexp[19],
    of_int_style = Base_Sexp[20],
    equal_local = Base_Sexp[22],
    compare_local = Base_Sexp[23],
    t_sexp_grammar = Base_Sexp[24],
    invariant = Base_Sexp[25],
    of_string = Base_Sexp[26],
    Base_Sexp_with_comparable =
      [0,
       globalize,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       compare_local,
       equal_local];
   runtime.caml_register_global
    (2, Base_Sexp_with_comparable, "Base__Sexp_with_comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Dictionary_immutable_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Definitions = [0],
    Base_Dictionary_immutable_intf = [0, Definitions];
   runtime.caml_register_global
    (0, Base_Dictionary_immutable_intf, "Base__Dictionary_immutable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Dictionary_immutable
//# unitInfo: Requires: Base__Dictionary_immutable_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Dictionary_immutable = [0];
   runtime.caml_register_global
    (0, Base_Dictionary_immutable, "Base__Dictionary_immutable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hasher
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hasher = [0];
   runtime.caml_register_global(0, Base_Hasher, "Base__Hasher");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Maybe_bound
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Above_upper_bound = "Above_upper_bound",
    cst_Below_lower_bound = "Below_lower_bound",
    cst_Excl$0 = "Excl",
    cst_In_range = "In_range",
    cst_Incl$0 = "Incl",
    cst_Unbounded = "Unbounded",
    cst_above_upper_bound = "above_upper_bound",
    cst_below_lower_bound = "below_lower_bound",
    cst_excl = "excl",
    cst_in_range = "in_range",
    cst_incl = "incl",
    cst_unbounded = "unbounded",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_006 = "maybe_bound.ml.t",
    error_source_033 = "maybe_bound.ml.interval_comparison",
    interval_comparison_sexp_gramm =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Below_lower_bound, 0]],
         [0,
          [1, [0, cst_In_range, 0]],
          [0, [1, [0, cst_Above_upper_bound, 0]], 0]]]]],
    Base_Import = global_data.Base__Import,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_List = global_data.Base__List,
    cst_Maybe_bound_compare_to_int =
      "Maybe_bound.compare_to_interval_exn: lower bound > upper bound",
    _f_ = [0, cst_Below_lower_bound],
    _g_ = [0, cst_In_range],
    _h_ = [0, cst_Above_upper_bound],
    _e_ = [0, [1, [0, cst_Unbounded, 0]], 0],
    cst_Excl = cst_Excl$0,
    cst_Incl = cst_Incl$0,
    _b_ = [0, cst_Unbounded],
    _c_ = [0, cst_Incl$0],
    _d_ = [0, cst_Excl$0],
    _a_ = [0, 0, 0];
   function all(all_of_a){
    var l = all_of_a, acc = 0;
    for(;;){
     if(! l) break;
     var
      l$0 = l[2],
      enumerate_002 = l[1],
      acc$0 = [0, [1, enumerate_002], acc],
      l = l$0,
      acc = acc$0;
    }
    var
     _r_ = caml_call1(Base_List[63], acc),
     l$1 = all_of_a,
     acc$1 = 0,
     _s_ = caml_call2(Base_List[10], _r_, _a_);
    for(;;){
     if(! l$1){
      var _t_ = caml_call1(Base_List[63], acc$1);
      return caml_call2(Base_List[10], _t_, _s_);
     }
     var
      l$2 = l$1[2],
      enumerate_001 = l$1[1],
      acc$2 = [0, [0, enumerate_001], acc$1],
      l$1 = l$2,
      acc$1 = acc$2;
    }
   }
   function t_of_sexp(of_a_003, sexp_008){
    a:
    {
     if(0 === sexp_008[0]){
      var _o_ = sexp_008[1];
      b:
      if(caml_string_notequal(_o_, cst_Excl$0)){
       c:
       if(caml_string_notequal(_o_, cst_Incl$0)){
        if(caml_string_notequal(_o_, cst_Unbounded)){
         if(! caml_string_notequal(_o_, cst_excl)) break b;
         if(! caml_string_notequal(_o_, cst_incl)) break c;
         if(caml_string_notequal(_o_, cst_unbounded)) break a;
        }
        return 0;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[9], error_source_006, sexp_008);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[9], error_source_006, sexp_008);
     }
     var _p_ = sexp_008[1];
     if(! _p_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_006, sexp_008);
     var _q_ = _p_[1];
     if(0 !== _q_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_006, sexp_008);
     var tag_009 = _q_[1];
     b:
     if(caml_string_notequal(tag_009, cst_Excl$0)){
      c:
      if(caml_string_notequal(tag_009, cst_Incl$0)){
       if(caml_string_notequal(tag_009, cst_Unbounded)){
        if(! caml_string_notequal(tag_009, cst_excl)) break b;
        if(! caml_string_notequal(tag_009, cst_incl)) break c;
        if(caml_string_notequal(tag_009, cst_unbounded)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_006, sexp_008);
      }
      var sexp_args_010 = _p_[2];
      if(sexp_args_010 && ! sexp_args_010[2]){
       var
        arg0_011 = sexp_args_010[1],
        res0_012 = caml_call1(of_a_003, arg0_011);
       return [0, res0_012];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[8],
               error_source_006,
               tag_009,
               sexp_008);
     }
     var sexp_args_015 = _p_[2];
     if(sexp_args_015 && ! sexp_args_015[2]){
      var
       arg0_016 = sexp_args_015[1],
       res0_017 = caml_call1(of_a_003, arg0_016);
      return [1, res0_017];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[8],
              error_source_006,
              tag_009,
              sexp_008);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_006, sexp_008);
   }
   function sexp_of_t(of_a_019, param){
    if(typeof param === "number") return _b_;
    if(0 === param[0]){
     var arg0_020 = param[1], res0_021 = caml_call1(of_a_019, arg0_020);
     return [1, [0, _c_, [0, res0_021, 0]]];
    }
    var arg0_022 = param[1], res0_023 = caml_call1(of_a_019, arg0_022);
    return [1, [0, _d_, [0, res0_023, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Incl, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Excl, [0, [0, a_sexp_grammar, 0]]]], _e_]]]];
   }
   function globalize(globalize_a_026, x_027){
    if(typeof x_027 === "number") return x_027;
    if(0 === x_027[0]){
     var arg_029 = x_027[1];
     return [0, caml_call1(globalize_a_026, arg_029)];
    }
    var arg_030 = x_027[1];
    return [1, caml_call1(globalize_a_026, arg_030)];
   }
   function interval_comparison_of_sexp(sexp_034){
    a:
    {
     if(0 === sexp_034[0]){
      var _k_ = sexp_034[1];
      b:
      if(caml_string_notequal(_k_, cst_Above_upper_bound)){
       c:
       if(caml_string_notequal(_k_, cst_Below_lower_bound)){
        if(caml_string_notequal(_k_, cst_In_range)){
         if(! caml_string_notequal(_k_, cst_above_upper_bound)) break b;
         if(! caml_string_notequal(_k_, cst_below_lower_bound)) break c;
         if(caml_string_notequal(_k_, cst_in_range)) break a;
        }
        return 1;
       }
       return 0;
      }
      return 2;
     }
     var _l_ = sexp_034[1];
     if(! _l_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_033, sexp_034);
     var _m_ = _l_[1];
     if(0 !== _m_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_033, sexp_034);
     var _n_ = _m_[1];
     b:
     if(caml_string_notequal(_n_, cst_Above_upper_bound)){
      c:
      if(caml_string_notequal(_n_, cst_Below_lower_bound)){
       if(caml_string_notequal(_n_, cst_In_range)){
        if(! caml_string_notequal(_n_, cst_above_upper_bound)) break b;
        if(! caml_string_notequal(_n_, cst_below_lower_bound)) break c;
        if(caml_string_notequal(_n_, cst_in_range)) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_033, sexp_034);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_033, sexp_034);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_033, sexp_034);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_033, sexp_034);
   }
   function sexp_of_interval_comparison(param){
    switch(param){case 0: return _f_;case 1: return _g_;default: return _h_;
    }
   }
   var
    compare_interval_comparison_lo = caml_int_compare,
    compare_interval_comparison = caml_int_compare;
   function hash_fold_interval_comparison(hsv, arg){
    switch(arg){
      case 0:
       var _j_ = 0; break;
      case 1:
       var _j_ = 1; break;
      default: var _j_ = 2;
    }
    return caml_call2(Base_Hash[3], hsv, _j_);
   }
   function hash_interval_comparison(arg){
    var
     hsv = caml_call2(Base_Hash[11], 0, 0),
     _i_ = hash_fold_interval_comparison(hsv, arg);
    return caml_call1(Base_Hash[9], _i_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var incl = t[1]; return [0, caml_call1(f, incl)];}
    var excl = t[1];
    return [1, caml_call1(f, excl)];
   }
   function is_lower_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, incl, a) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, excl, a) < 0 ? 1 : 0;
   }
   function is_upper_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, a, incl) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, a, excl) < 0 ? 1 : 0;
   }
   function bounds_crossed(lower, upper, compare){
    if(typeof lower === "number") return 0;
    var lower$0 = lower[1];
    if(typeof upper === "number") return 0;
    var upper$0 = upper[1];
    return 0 < caml_call2(compare, lower$0, upper$0) ? 1 : 0;
   }
   function compare_to_interval_exn(lower, upper, a, compare){
    if(bounds_crossed(lower, upper, compare))
     caml_call1(Base_Import[124], cst_Maybe_bound_compare_to_int);
    return is_lower_bound(lower, a, compare)
            ? is_upper_bound(upper, a, compare) ? 1 : 2
            : 0;
   }
   function interval_contains_exn(lower, upper, a, compare){
    return 1 === compare_to_interval_exn(lower, upper, a, compare) ? 1 : 0;
   }
   var
    Base_Maybe_bound =
      [0,
       all,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       globalize,
       map,
       is_lower_bound,
       is_upper_bound,
       interval_contains_exn,
       bounds_crossed,
       sexp_of_interval_comparison,
       interval_comparison_of_sexp,
       interval_comparison_sexp_gramm,
       compare_interval_comparison,
       compare_interval_comparison_lo,
       hash_fold_interval_comparison,
       hash_interval_comparison,
       compare_to_interval_exn];
   runtime.caml_register_global(42, Base_Maybe_bound, "Base__Maybe_bound");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map_intf
//# unitInfo: Requires: Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Unequal$0 = "Unequal",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_057 = "map_intf.ml.Symmetric_diff_element.t",
    all = [0, 0, [0, 1, 0]],
    all$0 = [0, 0, [0, 1, 0]],
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _k_ = [0, "Unfinished"],
    _l_ = [0, "Finished"],
    _i_ = [0, "Stop"],
    _j_ = [0, "Continue"],
    _g_ = [0, cst_Left$0],
    _h_ = [0, cst_Right$0],
    _f_ = [0, "Both"],
    cst_Unequal = cst_Unequal$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0,
    _d_ = [0, cst_Unequal$0],
    _e_ = [0, cst_Right$0],
    _c_ = [0, cst_Left$0],
    _a_ = [0, "Duplicate"],
    _b_ = [0, "Ok"];
   function compare(cmp_a, a_001, b_002){
    if(a_001 === b_002) return 0;
    if(typeof a_001 === "number"){
     if(typeof b_002 === "number" && -1024851605 === b_002) return 0;
    }
    else if(typeof b_002 !== "number" && 17724 === b_002[1]){
     var right_004 = b_002[2], left_003 = a_001[2];
     return caml_call2(cmp_a, left_003, right_004);
    }
    return caml_compare(a_001, b_002);
   }
   function equal(cmp_a, a_005, b_006){
    if(a_005 === b_006) return 1;
    if(typeof a_005 === "number"){
     if(typeof b_006 === "number" && -1024851605 === b_006) return 1;
    }
    else if(typeof b_006 !== "number" && 17724 === b_006[1]){
     var right_008 = b_006[2], left_007 = a_005[2];
     return caml_call2(cmp_a, left_007, right_008);
    }
    return caml_equal(a_005, b_006);
   }
   function sexp_of_t(of_a_009, param){
    if(typeof param === "number") return _a_;
    var v_010 = param[2];
    return [1, [0, _b_, [0, caml_call1(of_a_009, v_010), 0]]];
   }
   var
    Or_duplicate = [0, compare, equal, sexp_of_t],
    Without_comparator = [0],
    With_comparator = [0],
    With_first_class_module = [0];
   function compare$0(cmp_k, cmp_v, a_011, b_012){
    var
     t_014 = a_011[2],
     t_013 = a_011[1],
     t_016 = b_012[2],
     t_015 = b_012[1],
     n = caml_call2(cmp_k, t_013, t_015);
    if(0 !== n) return n;
    if(t_014 === t_016) return 0;
    var _O_ = t_014[1];
    if(847852583 === _O_){
     if(typeof t_016 !== "number" && 847852583 === t_016[1]){
      var right_018 = t_016[2], left_017 = t_014[2];
      return caml_call2(cmp_v, left_017, right_018);
     }
    }
    else
     if(1013247643 <= _O_){
      if(typeof t_016 !== "number" && 1013247643 === t_016[1]){
       var
        right_022 = t_016[2],
        left_021 = t_014[2],
        t_024 = left_021[2],
        t_023 = left_021[1],
        t_026 = right_022[2],
        t_025 = right_022[1],
        n$0 = caml_call2(cmp_v, t_023, t_025);
       return 0 === n$0 ? caml_call2(cmp_v, t_024, t_026) : n$0;
      }
     }
     else if(typeof t_016 !== "number" && -57574468 === t_016[1]){
      var right_020 = t_016[2], left_019 = t_014[2];
      return caml_call2(cmp_v, left_019, right_020);
     }
    return caml_compare(t_014, t_016);
   }
   function equal$0(cmp_k, cmp_v, a_027, b_028){
    var
     t_030 = a_027[2],
     t_029 = a_027[1],
     t_032 = b_028[2],
     t_031 = b_028[1],
     _K_ = caml_call2(cmp_k, t_029, t_031);
    if(_K_){
     if(t_030 === t_032) return 1;
     var _L_ = t_030[1];
     if(847852583 === _L_){
      if(typeof t_032 !== "number" && 847852583 === t_032[1]){
       var right_034 = t_032[2], left_033 = t_030[2];
       return caml_call2(cmp_v, left_033, right_034);
      }
     }
     else
      if(1013247643 <= _L_){
       if(typeof t_032 !== "number" && 1013247643 === t_032[1]){
        var
         right_038 = t_032[2],
         left_037 = t_030[2],
         t_040 = left_037[2],
         t_039 = left_037[1],
         t_042 = right_038[2],
         t_041 = right_038[1],
         _N_ = caml_call2(cmp_v, t_039, t_041);
        return _N_ ? caml_call2(cmp_v, t_040, t_042) : _N_;
       }
      }
      else if(typeof t_032 !== "number" && -57574468 === t_032[1]){
       var right_036 = t_032[2], left_035 = t_030[2];
       return caml_call2(cmp_v, left_035, right_036);
      }
     var _M_ = caml_equal(t_030, t_032);
    }
    else
     var _M_ = _K_;
    return _M_;
   }
   function t_of_sexp(of_k_043, of_v_044, sexp_071){
    if(1 === sexp_071[0]){
     var _v_ = sexp_071[1];
     if(_v_){
      var _w_ = _v_[2];
      if(_w_ && ! _w_[2]){
       var
        arg1_068 = _w_[1],
        arg0_067 = _v_[1],
        res0_069 = caml_call1(of_k_043, arg0_067);
       try{
        if(0 === arg1_068[0])
         var
          atom_047 = arg1_068[1],
          _y_ =
            caml_string_notequal(atom_047, cst_Left$0)
             ? caml_string_notequal
                (atom_047, cst_Right$0)
               ? caml_string_notequal
                  (atom_047, cst_Unequal$0)
                 ? caml_call1(Sexplib0_Sexp_conv_error[23], 0)
                 : caml_call2
                   (Sexplib0_Sexp_conv_error[27], error_source_057, arg1_068)
               : caml_call2
                 (Sexplib0_Sexp_conv_error[27], error_source_057, arg1_068)
             : caml_call2
               (Sexplib0_Sexp_conv_error[27], error_source_057, arg1_068),
          _z_ = _y_;
        else{
         var _A_ = arg1_068[1];
         if(_A_){
          var match = _A_[1];
          if(0 === match[0]){
           var sexp_args_050 = _A_[2], atom_047$0 = match[1];
           if(caml_string_notequal(atom_047$0, cst_Left$0))
            if(caml_string_notequal(atom_047$0, cst_Right$0))
             if(caml_string_notequal(atom_047$0, cst_Unequal$0))
              var _B_ = caml_call1(Sexplib0_Sexp_conv_error[23], 0);
             else{
              a:
              {
               if(sexp_args_050 && ! sexp_args_050[2]){
                var arg0_058 = sexp_args_050[1];
                b:
                {
                 if(1 === arg0_058[0]){
                  var _F_ = arg0_058[1];
                  if(_F_){
                   var _G_ = _F_[2];
                   if(_G_ && ! _G_[2]){
                    var
                     arg1_053 = _G_[1],
                     arg0_052 = _F_[1],
                     res0_054 = caml_call1(of_v_044, arg0_052),
                     res1_055 = caml_call1(of_v_044, arg1_053),
                     res0_059 = [0, res0_054, res1_055];
                    break b;
                   }
                  }
                 }
                 var
                  res0_059 =
                    caml_call3
                     (Sexplib0_Sexp_conv_error[4], error_source_057, 2, arg0_058);
                }
                var _E_ = [0, 1013247643, res0_059];
                break a;
               }
               var
                _E_ =
                  caml_call3
                   (Sexplib0_Sexp_conv_error[26],
                    error_source_057,
                    atom_047$0,
                    arg1_068);
              }
              var _B_ = _E_;
             }
            else{
             a:
             {
              if(sexp_args_050 && ! sexp_args_050[2]){
               var
                arg0_061 = sexp_args_050[1],
                res0_062 = caml_call1(of_v_044, arg0_061),
                _H_ = [0, -57574468, res0_062];
               break a;
              }
              var
               _H_ =
                 caml_call3
                  (Sexplib0_Sexp_conv_error[26],
                   error_source_057,
                   atom_047$0,
                   arg1_068);
             }
             var _B_ = _H_;
            }
           else{
            a:
            {
             if(sexp_args_050 && ! sexp_args_050[2]){
              var
               arg0_064 = sexp_args_050[1],
               res0_065 = caml_call1(of_v_044, arg0_064),
               _I_ = [0, 847852583, res0_065];
              break a;
             }
             var
              _I_ =
                caml_call3
                 (Sexplib0_Sexp_conv_error[26],
                  error_source_057,
                  atom_047$0,
                  arg1_068);
            }
            var _B_ = _I_;
           }
           var _C_ = _B_;
          }
          else
           var
            _C_ =
              caml_call2
               (Sexplib0_Sexp_conv_error[28], error_source_057, arg1_068);
          var _D_ = _C_;
         }
         else
          var
           _D_ =
             caml_call2
              (Sexplib0_Sexp_conv_error[29], error_source_057, arg1_068);
         var _z_ = _D_;
        }
        var res1_070 = _z_;
       }
       catch(_J_){
        var _x_ = caml_wrap_exception(_J_);
        if(_x_ !== Sexplib0_Sexp_conv_error[22])
         throw caml_maybe_attach_backtrace(_x_, 0);
        var
         res1_070 =
           caml_call2
            (Sexplib0_Sexp_conv_error[24], error_source_057, arg1_068);
       }
       return [0, res0_069, res1_070];
      }
     }
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[4], error_source_057, 2, sexp_071);
   }
   function sexp_of_t$0(of_k_072, of_v_073, param){
    var
     arg1_082 = param[2],
     arg0_081 = param[1],
     res0_083 = caml_call1(of_k_072, arg0_081),
     _u_ = arg1_082[1];
    if(847852583 === _u_)
     var
      v_074 = arg1_082[2],
      res1_084 = [1, [0, _c_, [0, caml_call1(of_v_073, v_074), 0]]];
    else if(1013247643 <= _u_)
     var
      v_076 = arg1_082[2],
      arg1_078 = v_076[2],
      arg0_077 = v_076[1],
      res0_079 = caml_call1(of_v_073, arg0_077),
      res1_080 = caml_call1(of_v_073, arg1_078),
      res1_084 = [1, [0, _d_, [0, [1, [0, res0_079, [0, res1_080, 0]]], 0]]];
    else
     var
      v_075 = arg1_082[2],
      res1_084 = [1, [0, _e_, [0, caml_call1(of_v_073, v_075), 0]]];
    return [1, [0, res0_083, [0, res1_084, 0]]];
   }
   function t_sexp_grammar(k_sexp_grammar, v_sexp_grammar){
    return [2,
            [0,
             k_sexp_grammar,
             [0,
              [3,
               [0,
                1,
                [0,
                 [1, [0, cst_Left, [0, [0, v_sexp_grammar, 0]]]],
                 [0,
                  [1, [0, cst_Right, [0, [0, v_sexp_grammar, 0]]]],
                  [0,
                   [1,
                    [0,
                     cst_Unequal,
                     [0,
                      [0, [2, [0, v_sexp_grammar, [0, v_sexp_grammar, 0]]], 0]]]],
                   0]]]]],
              0]]];
   }
   var
    Symmetric_diff_element =
      [0, compare$0, equal$0, t_of_sexp, sexp_of_t$0, t_sexp_grammar];
   function compare$1(cmp_left, cmp_right, a_085, b_086){
    if(a_085 === b_086) return 0;
    var _t_ = a_085[1];
    if(737457313 === _t_){
     if(typeof b_086 !== "number" && 737457313 === b_086[1]){
      var
       right_092 = b_086[2],
       left_091 = a_085[2],
       t_094 = left_091[2],
       t_093 = left_091[1],
       t_096 = right_092[2],
       t_095 = right_092[1],
       n = caml_call2(cmp_left, t_093, t_095);
      return 0 === n ? caml_call2(cmp_right, t_094, t_096) : n;
     }
    }
    else
     if(847852583 <= _t_){
      if(typeof b_086 !== "number" && 847852583 === b_086[1]){
       var right_088 = b_086[2], left_087 = a_085[2];
       return caml_call2(cmp_left, left_087, right_088);
      }
     }
     else if(typeof b_086 !== "number" && -57574468 === b_086[1]){
      var right_090 = b_086[2], left_089 = a_085[2];
      return caml_call2(cmp_right, left_089, right_090);
     }
    return caml_compare(a_085, b_086);
   }
   function equal$1(cmp_left, cmp_right, a_097, b_098){
    if(a_097 === b_098) return 1;
    var _r_ = a_097[1];
    if(737457313 === _r_){
     if(typeof b_098 !== "number" && 737457313 === b_098[1]){
      var
       right_104 = b_098[2],
       left_103 = a_097[2],
       t_106 = left_103[2],
       t_105 = left_103[1],
       t_108 = right_104[2],
       t_107 = right_104[1],
       _s_ = caml_call2(cmp_left, t_105, t_107);
      return _s_ ? caml_call2(cmp_right, t_106, t_108) : _s_;
     }
    }
    else
     if(847852583 <= _r_){
      if(typeof b_098 !== "number" && 847852583 === b_098[1]){
       var right_100 = b_098[2], left_099 = a_097[2];
       return caml_call2(cmp_left, left_099, right_100);
      }
     }
     else if(typeof b_098 !== "number" && -57574468 === b_098[1]){
      var right_102 = b_098[2], left_101 = a_097[2];
      return caml_call2(cmp_right, left_101, right_102);
     }
    return caml_equal(a_097, b_098);
   }
   function sexp_of_t$1(of_left_109, of_right_110, param){
    var _q_ = param[1];
    if(737457313 === _q_){
     var
      v_113 = param[2],
      arg1_115 = v_113[2],
      arg0_114 = v_113[1],
      res0_116 = caml_call1(of_left_109, arg0_114),
      res1_117 = caml_call1(of_right_110, arg1_115);
     return [1, [0, _f_, [0, [1, [0, res0_116, [0, res1_117, 0]]], 0]]];
    }
    if(847852583 <= _q_){
     var v_111 = param[2];
     return [1, [0, _g_, [0, caml_call1(of_left_109, v_111), 0]]];
    }
    var v_112 = param[2];
    return [1, [0, _h_, [0, caml_call1(of_right_110, v_112), 0]]];
   }
   var
    Merge_element = [0, compare$1, equal$1, sexp_of_t$1],
    compare$2 = caml_int_compare;
   function equal$2(_p_, _o_){return _p_ === _o_ ? 1 : 0;}
   function sexp_of_t$2(param){return param ? _i_ : _j_;}
   var
    Continue_or_stop = [0, compare$2, all, equal$2, sexp_of_t$2],
    compare$3 = caml_int_compare;
   function equal$3(_n_, _m_){return _n_ === _m_ ? 1 : 0;}
   function sexp_of_t$3(param){return param ? _k_ : _l_;}
   var
    Finished_or_unfinished = [0, compare$3, all$0, equal$3, sexp_of_t$3],
    Base_Map_intf =
      [0,
       Or_duplicate,
       Without_comparator,
       With_comparator,
       With_first_class_module,
       Symmetric_diff_element,
       Merge_element,
       Continue_or_stop,
       Finished_or_unfinished];
   runtime.caml_register_global(25, Base_Map_intf, "Base__Map_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Named = [0],
    Base_Set_intf = [0, Named];
   runtime.caml_register_global(0, Base_Set_intf, "Base__Set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set
//# unitInfo: Requires: Base__Array, Base__Comparator, Base__Container, Base__Exn, Base__Fn, Base__Hash, Base__Import, Base__List, Base__Option, Base__Or_error, Base__Sequence, Base__Set_intf, Base__Sexp, Base__With_return, Sexplib0__Sexp_conv, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_set_ml = "src/set.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Or_error = global_data.Base__Or_error,
    Base_Container = global_data.Base__Container,
    Base_List = global_data.Base__List,
    Base_Comparator = global_data.Base__Comparator,
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Fn = global_data.Base__Fn,
    Base_Option = global_data.Base__Option,
    Base_Exn = global_data.Base__Exn,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    with_return = Base_With_return[1],
    _v_ = [0, "_"],
    cst_Set_remove_min_elt = "Set.remove_min_elt",
    _p_ = [0, 0, 0],
    _q_ = [0, 0, 0],
    _u_ = [0, 0],
    cst_invalid_elements = "invalid_elements",
    cst_is_not_a_subset_of = " is not a subset of ",
    cst_Set_t_of_sexp_duplicate_el = "Set.t_of_sexp: duplicate element in set",
    cst_Set_t_of_sexp_list_needed = "Set.t_of_sexp: list needed",
    _t_ = [0, cst_src_set_ml, 1120, 8],
    cst_Set_find_exn_failed_to_fin =
      "Set.find_exn failed to find a matching element",
    _r_ = [0, 0, 0],
    _o_ = [0, 0, 0, 0],
    _m_ = [0, "set.ml.Tree0.Set_max_elt_exn_of_empty_set"],
    _n_ = [0, cst_src_set_ml, 289, 13],
    _j_ = [0, "set.ml.Tree0.Set_min_elt_exn_of_empty_set"],
    _k_ = [0, cst_src_set_ml, 276, 13],
    _a_ = [0, cst_src_set_ml, 169, 17],
    _b_ = [0, cst_src_set_ml, 170, 28],
    _c_ = [0, cst_src_set_ml, 176, 21],
    _d_ = [0, cst_src_set_ml, 178, 12],
    _e_ = [0, cst_src_set_ml, 185, 17],
    _f_ = [0, cst_src_set_ml, 186, 28],
    _g_ = [0, cst_src_set_ml, 192, 21],
    _h_ = [0, cst_src_set_ml, 194, 12],
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    cst_Base_Set_Tree0_Same = "Base__Set.Tree0.Same",
    cst_Base_Set_Tree0_Set_min_elt =
      "Base__Set.Tree0.Set_min_elt_exn_of_empty_set",
    cst_Base_Set_Tree0_Set_max_elt =
      "Base__Set.Tree0.Set_max_elt_exn_of_empty_set",
    _s_ = [0, "Set.choose_exn: empty set"];
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[4];
    return h;
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var s = param[5];
    return s;
   }
   function in_range(lower, upper, compare_elt, v){
    if(lower)
     var
      lower$0 = lower[1],
      _bM_ = caml_call2(compare_elt, lower$0, v) < 0 ? 1 : 0;
    else
     var _bM_ = 1;
    if(_bM_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_elt, v, upper$0) < 0 ? 1 : 0;
     }
     var _bN_ = 1;
    }
    else
     var _bN_ = _bM_;
    return _bN_;
   }
   function loop(lower, upper, compare_elt, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var v = t$0[1];
      return in_range(lower$0, upper, compare_elt, v);
     }
     var
      n = t$0[5],
      h = t$0[4],
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _bB_ = caml_call2(Base_Import[93], hl, hr),
      _bC_ = caml_call1(Base_Import[123], _bB_) <= 2 ? 1 : 0;
     if(_bC_){
      var
       _bD_ = caml_call2(Base_Import[100], hl, hr),
       _bE_ = h === caml_call2(Base_Import[91], _bD_, 1) ? 1 : 0;
      if(_bE_){
       var
        _bF_ = length(r),
        _bG_ = length(l),
        _bH_ = caml_call2(Base_Import[91], _bG_, _bF_),
        _bI_ = n === caml_call2(Base_Import[91], _bH_, 1) ? 1 : 0;
       if(_bI_){
        var _bJ_ = in_range(lower$0, upper, compare_elt, v$0);
        if(_bJ_){
         var _bK_ = loop(lower$0, [0, v$0], compare_elt, l);
         if(_bK_){
          var lower$1 = [0, v$0], lower$0 = lower$1, t$0 = r;
          continue;
         }
         var _bL_ = _bK_;
        }
        else
         var _bL_ = _bJ_;
       }
       else
        var _bL_ = _bI_;
      }
      else
       var _bL_ = _bE_;
     }
     else
      var _bL_ = _bC_;
     return _bL_;
    }
   }
   function invariants(t, compare_elt){return loop(0, 0, compare_elt, t);}
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function create(l, v, r){
    var
     hl = height(l),
     hr = height(r),
     h =
       hr <= hl
        ? caml_call2(Base_Import[91], hl, 1)
        : caml_call2(Base_Import[91], hr, 1);
    if(1 === h) return [0, v];
    var
     sl = length(l),
     sr = length(r),
     _bA_ = caml_call2(Base_Import[91], sl, sr);
    return [1, l, v, r, h, caml_call2(Base_Import[91], _bA_, 1)];
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var k$0 = caml_call1(f, i); return [0, k$0];
        case 2:
         var
          kl = caml_call1(f, i),
          k$1 = caml_call1(f, caml_call2(Base_Import[91], i, 1));
         return create([0, kl], k$1, 0);
        default:
         var
          kl$0 = caml_call1(f, i),
          k$2 = caml_call1(f, caml_call2(Base_Import[91], i, 1)),
          kr = caml_call1(f, caml_call2(Base_Import[91], i, 2));
         return create([0, kl$0], k$2, [0, kr]);
      }
     var
      left_length = caml_call2(Base_Import[120], n, 1),
      _by_ = caml_call2(Base_Import[93], n, left_length),
      right_length = caml_call2(Base_Import[93], _by_, 1),
      left = loop(left_length, f, i),
      k = caml_call1(f, caml_call2(Base_Import[91], i, left_length)),
      _bz_ = caml_call2(Base_Import[91], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[91], _bz_, 1));
     return create(left, k, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_elt){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var _bv_ = caml_check_bound(array, 1)[2];
      if(0 <= caml_call2(compare_elt, caml_check_bound(array, 0)[1], _bv_)){
       var
        next =
          function(i){
           var
            _bw_ = caml_call2(Base_Import[93], array_length, 1),
            _bx_ = caml_call2(Base_Import[93], _bw_, i);
           return caml_check_bound(array, _bx_)[1 + _bx_];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    }
    return of_increasing_iterator_uncheck(array_length, next);
   }
   function of_sorted_array(array, compare_elt){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _bp_ = caml_check_bound(array, 1)[2],
                i =
                  caml_call2(compare_elt, caml_check_bound(array, 0)[1], _bp_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[40], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _br_ = caml_call2(Base_Import[93], array.length - 1, 2),
                _bq_ = 1;
               if(_br_ >= 1){
                var i$0 = _bq_;
                for(;;){
                 var
                  _bs_ = caml_call2(Base_Import[91], i$0, 1),
                  _bt_ = caml_check_bound(array, _bs_)[1 + _bs_],
                  i$1 =
                    caml_call2
                     (compare_elt, caml_check_bound(array, i$0)[1 + i$0], _bt_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[40], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[40], cst_of_sorted_array_elements_a));
                 var _bu_ = i$0 + 1 | 0;
                 if(_br_ === i$0) break;
                 var i$0 = _bu_;
                }
               }
               return [0, of_sorted_array_unchecked(array, compare_elt)];
              });
    return [0, of_sorted_array_unchecked(array, compare_elt)];
   }
   function bal(l, v, r){
    var hl = height(l), hr = height(r);
    if(caml_call2(Base_Import[91], hr, 2) < hl){
     if(typeof l === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     var lr = l[3], lv = l[2], ll = l[1], _bj_ = height(lr);
     if(_bj_ <= height(ll)) return create(ll, lv, create(lr, v, r));
     if(typeof lr === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     if(0 !== lr[0]){
      var lrr = lr[3], lrv$0 = lr[2], lrl = lr[1], _bl_ = create(lrr, v, r);
      return create(create(ll, lv, lrl), lrv$0, _bl_);
     }
     var lrv = lr[1];
     if(! is_empty(ll))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     var _bk_ = create(0, v, r);
     return create(create(ll, lv, 0), lrv, _bk_);
    }
    if(caml_call2(Base_Import[91], hl, 2) >= hr) return create(l, v, r);
    if(typeof r === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
    if(0 === r[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var rr = r[3], rv = r[2], rl = r[1], _bm_ = height(rl);
    if(_bm_ <= height(rr)) return create(create(l, v, rl), rv, rr);
    if(typeof rl === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    if(0 !== rl[0]){
     var rlr = rl[3], rlv$0 = rl[2], rll = rl[1], _bo_ = create(rlr, rv, rr);
     return create(create(l, v, rll), rlv$0, _bo_);
    }
    var rlv = rl[1];
    if(! is_empty(rr))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var _bn_ = create(0, rv, rr);
    return create(create(l, v, 0), rlv, _bn_);
   }
   var Same = [248, cst_Base_Set_Tree0_Same, caml_fresh_oo_id(0)];
   function add(t, x, compare_elt){
    function aux(param){
     if(typeof param === "number") return [0, x];
     if(0 === param[0]){
      var v = param[1], c = caml_call2(compare_elt, x, v);
      return 0 === c
              ? caml_call1(Base_Exn[6], Same)
              : 0 <= c ? create(0, v, [0, x]) : create([0, x], v, 0);
     }
     var
      r = param[3],
      v$0 = param[2],
      l = param[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     return 0 === c$0
             ? caml_call1(Base_Exn[6], Same)
             : 0 <= c$0 ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
    }
    try{var _bh_ = aux(t); return _bh_;}
    catch(_bi_){
     var _bg_ = caml_wrap_exception(_bi_);
     if(_bg_ === Same) return t;
     throw caml_maybe_attach_backtrace(_bg_, 0);
    }
   }
   function add_min(x, t){
    if(typeof t === "number") return [0, x];
    if(0 === t[0]) return [1, 0, x, t, 2, 2];
    var r = t[3], v = t[2], l = t[1];
    return bal(add_min(x, l), v, r);
   }
   function add_max(t, x){
    if(typeof t === "number") return [0, x];
    if(0 === t[0]) return [1, t, x, 0, 2, 2];
    var r = t[3], v = t[2], l = t[1];
    return bal(l, v, add_max(r, x));
   }
   function join(l, v, r){
    if(typeof l === "number") return add_min(v, r);
    if(1 === l[0]){
     var lh = l[4], lr = l[3], lv$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){var rv = r[1]; return add_max(add_max(l, v), rv);}
      var rh = r[4], rr = r[3], rv$0 = r[2], rl = r[1];
      return caml_call2(Base_Import[91], rh, 2) < lh
              ? bal(ll, lv$0, join(lr, v, r))
              : caml_call2
                 (Base_Import[91], lh, 2)
                < rh
                ? bal(join(l, v, rl), rv$0, rr)
                : create(l, v, r);
     }
    }
    if(typeof r === "number") return add_max(l, v);
    var lv = l[1];
    return add_min(lv, add_min(v, r));
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      var l = param$0[1];
      if(typeof l !== "number"){var param$0 = l; continue;}
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   var
    Set_min_elt_exn_of_empty_set =
      [248, cst_Base_Set_Tree0_Set_min_elt, caml_fresh_oo_id(0)];
   function _i_(param){
    if(param === Set_min_elt_exn_of_empty_set) return _j_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[72][1], 0, 0, Set_min_elt_exn_of_empty_set, _i_);
   var
    Set_max_elt_exn_of_empty_set =
      [248, cst_Base_Set_Tree0_Set_max_elt, caml_fresh_oo_id(0)];
   function _l_(param){
    if(param === Set_max_elt_exn_of_empty_set) return _m_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[72][1], 0, 0, Set_max_elt_exn_of_empty_set, _l_);
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_min_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function fold_until(t, init, f, finish){
    function fold_until_helper(f, t, acc){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var value = t$0[1];
       return caml_call2(f, acc$0, value);
      }
      var
       right = t$0[3],
       value$0 = t$0[2],
       left = t$0[1],
       x = fold_until_helper(f, left, acc$0);
      if(0 !== x[0]) return x;
      var acc$1 = x[1], x$0 = caml_call2(f, acc$1, value$0);
      if(0 !== x$0[0]) return x$0;
      var acc$2 = x$0[1], t$0 = right, acc$0 = acc$2;
     }
    }
    var match = fold_until_helper(f, t, init);
    if(0 === match[0]){var x = match[1]; return caml_call1(finish, x);}
    var x$0 = match[1];
    return x$0;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      if(typeof param$0[3] !== "number"){
       var r = param$0[3], param$0 = r;
       continue;
      }
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_max_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(param){
    if(typeof param === "number")
     return caml_call1(Base_Import[126], cst_Set_remove_min_elt);
    if(0 === param[0]) return 0;
    var l = param[1];
    if(typeof l === "number"){var r = param[3]; return r;}
    var r$0 = param[3], v = param[2];
    return bal(remove_min_elt(l), v, r$0);
   }
   function merge(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var _bf_ = remove_min_elt(t2);
    return bal(t1, min_elt_exn(t2), _bf_);
   }
   function concat(t1, t2){
    if(typeof t1 === "number")
     var t = t2;
    else{
     if(typeof t2 !== "number"){
      var _be_ = remove_min_elt(t2);
      return join(t1, min_elt_exn(t2), _be_);
     }
     var t = t1;
    }
    return t;
   }
   function split(t, x, compare_elt){
    function split(t){
     if(typeof t === "number") return _o_;
     if(0 === t[0]){
      var v = t[1], c = caml_call2(compare_elt, x, v);
      return 0 === c
              ? [0, 0, [0, v], 0]
              : 0 <= c ? [0, [0, v], 0, 0] : [0, 0, 0, [0, v]];
     }
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     if(0 === c$0) return [0, l, [0, v$0], r];
     if(0 <= c$0){
      var
       match = split(r),
       rr = match[3],
       maybe_elt = match[2],
       lr = match[1];
      return [0, join(l, v$0, lr), maybe_elt, rr];
     }
     var
      match$0 = split(l),
      rl = match$0[3],
      maybe_elt$0 = match$0[2],
      ll = match$0[1];
     return [0, ll, maybe_elt$0, join(rl, v$0, r)];
    }
    return split(t);
   }
   function split_le_gt(t, x, compare_elt){
    if(typeof t === "number") return _p_;
    if(0 === t[0]){
     var v = t[1];
     return 0 <= caml_call2(compare_elt, x, v)
             ? [0, [0, v], 0]
             : [0, 0, [0, v]];
    }
    var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
    if(0 === c) return [0, add_max(l, v$0), r];
    if(0 <= c){
     var match = split_le_gt(r, x, compare_elt), rr = match[2], lr = match[1];
     return [0, join(l, v$0, lr), rr];
    }
    var
     match$0 = split_le_gt(l, x, compare_elt),
     rl = match$0[2],
     ll = match$0[1];
    return [0, ll, join(rl, v$0, r)];
   }
   function split_lt_ge(t, x, compare_elt){
    if(typeof t === "number") return _q_;
    if(0 === t[0]){
     var v = t[1];
     return 0 < caml_call2(compare_elt, x, v)
             ? [0, [0, v], 0]
             : [0, 0, [0, v]];
    }
    var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
    if(0 === c) return [0, l, add_min(v$0, r)];
    if(0 <= c){
     var match = split_lt_ge(r, x, compare_elt), rr = match[2], lr = match[1];
     return [0, join(l, v$0, lr), rr];
    }
    var
     match$0 = split_lt_ge(l, x, compare_elt),
     rl = match$0[2],
     ll = match$0[1];
    return [0, ll, join(rl, v$0, r)];
   }
   var empty_without_value_restrictio = 0;
   function mem(t, x, compare_elt){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[1], c = caml_call2(compare_elt, x, v);
      return 0 === c ? 1 : 0;
     }
     var
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c$0 = caml_call2(compare_elt, x, v$0),
      _bd_ = 0 === c$0 ? 1 : 0;
     if(_bd_) return _bd_;
     var r$0 = 0 <= c$0 ? r : l, t$0 = r$0;
    }
   }
   function remove(t, x, compare_elt){
    function aux(t){
     if(typeof t === "number") return caml_call1(Base_Exn[6], Same);
     if(0 === t[0]){
      var v = t[1];
      return 0 === caml_call2(compare_elt, x, v)
              ? 0
              : caml_call1(Base_Exn[6], Same);
     }
     var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
     return 0 === c
             ? merge(l, r)
             : 0 <= c ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
    }
    try{var _bb_ = aux(t); return _bb_;}
    catch(_bc_){
     var _ba_ = caml_wrap_exception(_bc_);
     if(_ba_ === Same) return t;
     throw caml_maybe_attach_backtrace(_ba_, 0);
    }
   }
   function remove_index(t, i, param){
    function aux(t, i){
     if(typeof t === "number") return caml_call1(Base_Exn[6], Same);
     if(0 === t[0]) return 0 === i ? 0 : caml_call1(Base_Exn[6], Same);
     var
      r = t[3],
      v = t[2],
      l = t[1],
      l_size = length(l),
      c = caml_int_compare(i, l_size);
     if(0 === c) return merge(l, r);
     if(0 > c) return bal(aux(l, i), v, r);
     var _a$_ = caml_call2(Base_Import[93], i, l_size);
     return bal(l, v, aux(r, caml_call2(Base_Import[93], _a$_, 1)));
    }
    try{var _a9_ = aux(t, i); return _a9_;}
    catch(_a__){
     var _a8_ = caml_wrap_exception(_a__);
     if(_a8_ === Same) return t;
     throw caml_maybe_attach_backtrace(_a8_, 0);
    }
   }
   function union(s1, s2, compare_elt){
    function union(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(s1$0 === s2$0) return s1$0;
      if(typeof s1$0 === "number")
       var t = s2$0;
      else{
       if(1 === s1$0[0]){
        var h1 = s1$0[4], r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
        if(typeof s2$0 !== "number"){
         if(0 === s2$0[0]){
          var v2 = s2$0[1], s2$1 = [1, 0, v2, 0, 1, 1], s2$0 = s2$1;
          continue;
         }
         var h2 = s2$0[4], r2 = s2$0[3], v2$0 = s2$0[2], l2 = s2$0[1];
         if(h2 <= h1){
          if(1 === h2) return add(s1$0, v2$0, compare_elt);
          var
           match = split(s2$0, v1$0, compare_elt),
           r2$0 = match[3],
           l2$0 = match[1],
           _a6_ = union(r1, r2$0);
          return join(union(l1, l2$0), v1$0, _a6_);
         }
         if(1 === h1) return add(s2$0, v1$0, compare_elt);
         var
          match$0 = split(s1$0, v2$0, compare_elt),
          r1$0 = match$0[3],
          l1$0 = match$0[1],
          _a7_ = union(r1$0, r2);
         return join(union(l1$0, l2), v2$0, _a7_);
        }
       }
       if(typeof s2$0 !== "number"){
        var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1], s1$0 = s1$1;
        continue;
       }
       var t = s1$0;
      }
      return t;
     }
    }
    return union(s1, s2);
   }
   function union_list(comparator, to_tree, xs){
    var compare_elt = comparator[1];
    function _a5_(ac, x){
     return union(ac, caml_call1(to_tree, x), compare_elt);
    }
    return caml_call3(Base_List[20], xs, empty_without_value_restrictio, _a5_);
   }
   function inter(s1, s2, compare_elt){
    function inter(s1, s2){
     if(s1 === s2) return s1;
     if(typeof s1 !== "number" && typeof s2 !== "number"){
      a:
      {
       if(typeof s1 !== "number" && 0 !== s1[0]){
        if(typeof s2 !== "number" && 0 !== s2[0]){
         var
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1],
          _a2_ = split(s2, v1, compare_elt),
          match = _a2_[2],
          l2 = _a2_[1];
         if(match){
          var r2 = _a2_[3], v1$0 = match[1], _a3_ = inter(r1, r2);
          return join(inter(l1, l2), v1$0, _a3_);
         }
         var r2$0 = _a2_[3], _a4_ = inter(r1, r2$0);
         return concat(inter(l1, l2), _a4_);
        }
        var other_set = s1, singleton = s2, elt = s2[1];
        break a;
       }
       var other_set = s2, singleton = s1, elt = s1[1];
      }
      return mem(other_set, elt, compare_elt) ? singleton : 0;
     }
     return 0;
    }
    return inter(s1, s2);
   }
   function diff(s1, s2, compare_elt){
    function diff(s1, s2){
     var s1$0 = s1;
     for(;;){
      if(s1$0 === s2) return 0;
      if(typeof s1$0 === "number") return 0;
      if(typeof s2 === "number") return s1$0;
      if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
       var
        r1 = s1$0[3],
        v1$0 = s1$0[2],
        l1 = s1$0[1],
        _aZ_ = split(s2, v1$0, compare_elt),
        l2 = _aZ_[1];
       if(_aZ_[2]){
        var r2 = _aZ_[3], _a0_ = diff(r1, r2);
        return concat(diff(l1, l2), _a0_);
       }
       var r2$0 = _aZ_[3], _a1_ = diff(r1, r2$0);
       return join(diff(l1, l2), v1$0, _a1_);
      }
      var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1], s1$0 = s1$1;
     }
    }
    return diff(s1, s2);
   }
   function cons(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      e$1 = [0, v$0, r, e$0],
      s$0 = l,
      e$0 = e$1;
    }
   }
   function cons_right(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      e$1 = [0, v$0, l, e$0],
      s$0 = r,
      e$0 = e$1;
    }
   }
   function of_set(s){return cons(s, 0);}
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var enum$0 = param$0[3], tree = param$0[2], a = param$0[1];
     caml_call1(f, a);
     var param$0 = cons(tree, enum$0);
    }
   }
   function symmetric_diff(t1, t2, compare_elt){
    function step(state){
     var left = state[1];
     if(! left){
      var match = state[2];
      if(! match) return 0;
      var enum$0 = match[3], tree = match[2], elt$0 = match[1];
      return [1, [1, elt$0], [0, 0, cons(tree, enum$0)]];
     }
     var right = state[2], enum1 = left[3], tree1 = left[2], elt = left[1];
     if(! right) return [1, [0, elt], [0, cons(tree1, enum1), 0]];
     var
      enum2 = right[3],
      tree2 = right[2],
      a2 = right[1],
      compare_result = caml_call2(compare_elt, elt, a2);
     if(0 !== compare_result)
      return 0 <= compare_result
              ? [1, [1, a2], [0, left, cons(tree2, enum2)]]
              : [1, [0, elt], [0, cons(tree1, enum1), right]];
     if(tree1 === tree2)
      var next_state = [0, enum1, enum2];
     else
      var
       _aY_ = cons(tree2, enum2),
       next_state = [0, cons(tree1, enum1), _aY_];
     return [0, next_state];
    }
    var _aW_ = of_set(t2), _aX_ = [0, of_set(t1), _aW_];
    return caml_call2(Base_Sequence[44], _aX_, step);
   }
   function to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$3){
    if(opt) var sth = opt[1], order = sth; else var order = 608542111;
    function inclusive_bound(side, t, bound){
     var
      compare_elt = comparator[1],
      match = split(t, bound, compare_elt),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var elt = maybe[1];
     return add(t$0, elt, compare_elt);
    }
    if(608542111 <= order){
     var
      _aO_ = Base_Import[125],
      _aP_ = function(_aU_, _aV_){return inclusive_bound(_aO_, _aU_, _aV_);},
      t$4 = caml_call3(Base_Option[34], less_or_equal_to, t$3, _aP_),
      next =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[3], t = enum$0[2], k = enum$0[1];
         return [1, k, cons(t, e)];
        };
     if(greater_or_equal_to){
      var
       key = greater_or_equal_to[1],
       compare = comparator[1],
       t = t$4,
       e = 0;
      for(;;){
       if(typeof t === "number"){var init = e; break;}
       if(0 === t[0])
        var v = t[1], t$0 = [1, 0, v, 0, 1, 1], t = t$0;
       else{
        var l = t[1], r = t[3], v$0 = t[2];
        if(0 <= caml_call2(compare, v$0, key))
         var r$0 = t[3], v$1 = t[2], e$0 = [0, v$1, r$0, e], t = l, e = e$0;
        else
         var t = r;
       }
      }
     }
     else
      var init = of_set(t$4);
     return caml_call2(Base_Sequence[44], init, next);
    }
    var _aQ_ = Base_Import[127];
    function _aR_(_aS_, _aT_){return inclusive_bound(_aQ_, _aS_, _aT_);}
    var t$5 = caml_call3(Base_Option[34], greater_or_equal_to, t$3, _aR_);
    function next$0(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[3], t = enum$0[2], k = enum$0[1];
     return [1, k, cons_right(t, e)];
    }
    if(less_or_equal_to){
     var
      key$0 = less_or_equal_to[1],
      compare$0 = comparator[1],
      t$1 = t$5,
      e$1 = 0;
     for(;;){
      if(typeof t$1 === "number"){var init$0 = e$1; break;}
      if(0 === t$1[0])
       var v$2 = t$1[1], t$2 = [1, 0, v$2, 0, 1, 1], t$1 = t$2;
      else{
       var l$0 = t$1[1], v$3 = t$1[2];
       if(0 < caml_call2(compare$0, v$3, key$0))
        var t$1 = l$0;
       else
        var
         r$1 = t$1[3],
         v$4 = t$1[2],
         e$2 = [0, v$4, l$0, e$1],
         t$1 = r$1,
         e$1 = e$2;
      }
     }
    }
    else
     var init$0 = cons_right(t$5, 0);
    return caml_call2(Base_Sequence[44], init$0, next$0);
   }
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, v$0];
     }
     var t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, v$0];
     }
     var t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;})
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;})
               : find_first_satisfying
                 (t,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      elt =
        find_last_satisfying
         (t, function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;});
     if(elt){var x = elt[1]; if(0 === caml_call2(compare, x, v)) return elt;}
     return 0;
    }
    var
     elt$0 =
       find_first_satisfying
        (t, function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(elt$0){
     var x$0 = elt$0[1];
     if(0 === caml_call2(compare, x$0, v)) return elt$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function merge_to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$0, t){
    if(opt) var sth = opt[1], order = sth; else var order = 608542111;
    var
     _aL_ =
       608542111 <= order
        ? comparator[1]
        : caml_call1(Base_Fn[6], comparator[1]),
     _aM_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t),
     _aN_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t$0);
    return caml_call3(Base_Sequence[58], _aN_, _aM_, _aL_);
   }
   function compare(compare_elt, s1, s2){
    var e2$2 = of_set(s2), e1$2 = of_set(s1), e1 = e1$2, e2 = e2$2;
    for(;;){
     if(! e1) return e2 ? -1 : 0;
     if(! e2) return 1;
     var
      e2$0 = e2[3],
      r2 = e2[2],
      v2 = e2[1],
      e1$0 = e1[3],
      r1 = e1[2],
      v1 = e1[1],
      c = caml_call2(compare_elt, v1, v2);
     if(0 !== c) return c;
     if(r1 === r2)
      var e1 = e1$0, e2 = e2$0;
     else
      var e2$1 = cons(r2, e2$0), e1$1 = cons(r1, e1$0), e1 = e1$1, e2 = e2$1;
    }
   }
   function iter2(s1, s2, compare_elt, f){
    var t2$2 = of_set(s2), t1$2 = of_set(s1), t1 = t1$2, t2 = t2$2;
    for(;;){
     if(! t1)
      return t2
              ? iter
                (function(a){return caml_call1(f, [0, -57574468, a]);}, t2)
              : 0;
     if(! t2)
      return iter(function(a){return caml_call1(f, [0, 847852583, a]);}, t1);
     var
      enum2 = t2[3],
      tree2 = t2[2],
      a2 = t2[1],
      enum1 = t1[3],
      tree1 = t1[2],
      a1 = t1[1],
      compare_result = caml_call2(compare_elt, a1, a2);
     if(0 === compare_result){
      caml_call1(f, [0, 737457313, [0, a1, a2]]);
      var
       t2$0 = cons(tree2, enum2),
       t1$0 = cons(tree1, enum1),
       t1 = t1$0,
       t2 = t2$0;
     }
     else if(0 <= compare_result){
      caml_call1(f, [0, -57574468, a2]);
      var t2$1 = cons(tree2, enum2), t2 = t2$1;
     }
     else{
      caml_call1(f, [0, 847852583, a1]);
      var t1$1 = cons(tree1, enum1), t1 = t1$1;
     }
    }
   }
   function equal(s1, s2, compare_elt){
    return 0 === compare(compare_elt, s1, s2) ? 1 : 0;
   }
   function is_subset(s1, s2, compare_elt){
    function is_subset(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(typeof s1$0 === "number") return 1;
      if(1 === s1$0[0]){
       var r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
       if(typeof s2$0 !== "number"){
        if(0 === s2$0[0]){
         var v2 = s2$0[1];
         if(typeof l1 === "number" && typeof r1 === "number")
          return 0 === caml_call2(compare_elt, v1$0, v2) ? 1 : 0;
         return 0;
        }
        var
         r2 = s2$0[3],
         v2$0 = s2$0[2],
         l2 = s2$0[1],
         c = caml_call2(compare_elt, v1$0, v2$0);
        if(0 !== c){
         if(0 <= c){
          var _aJ_ = is_subset([1, 0, v1$0, r1, 0, 0], r2);
          if(! _aJ_) return _aJ_;
          var s1$0 = l1;
          continue;
         }
         var _aK_ = is_subset([1, l1, v1$0, 0, 0, 0], l2);
         if(! _aK_) return _aK_;
         var s1$0 = r1;
         continue;
        }
        var _aG_ = s1$0 === s2$0 ? 1 : 0;
        if(_aG_)
         var _aH_ = _aG_;
        else{
         var _aI_ = is_subset(l1, l2);
         if(_aI_){var s1$0 = r1, s2$0 = r2; continue;}
         var _aH_ = _aI_;
        }
        return _aH_;
       }
      }
      if(typeof s2$0 === "number") return 0;
      var v1 = s1$0[1];
      return mem(s2$0, v1, compare_elt);
     }
    }
    return is_subset(s1, s2);
   }
   function are_disjoint(s1, s2, compare_elt){
    var s1$0 = s1, s2$0 = s2;
    for(;;){
     if(typeof s1$0 !== "number" && typeof s2$0 !== "number"){
      a:
      {
       if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
        if(typeof s2$0 !== "number" && 0 !== s2$0[0]){
         var r1 = s1$0[3], v1 = s1$0[2], l1 = s1$0[1];
         if(s1$0 === s2$0) return 0;
         var _aE_ = split(s2$0, v1, compare_elt), l2 = _aE_[1];
         if(_aE_[2]) return 0;
         var r2 = _aE_[3], _aF_ = are_disjoint(l1, l2, compare_elt);
         if(! _aF_) return _aF_;
         var s1$0 = r1, s2$0 = r2;
         continue;
        }
        var other_set = s1$0, elt = s2$0[1];
        break a;
       }
       var other_set = s2$0, elt = s1$0[1];
      }
      return 1 - mem(other_set, elt, compare_elt);
     }
     return 1;
    }
   }
   function iter$0(t, f){
    function iter(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return 0;
      if(0 === param$0[0]){var v = param$0[1]; return caml_call1(f, v);}
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      iter(l);
      caml_call1(f, v$0);
      var param$0 = r;
     }
    }
    return iter(t);
   }
   function fold(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, accu$0, v);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, fold(l, accu$0, f), v$0),
      s$0 = r,
      accu$0 = accu$1;
    }
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function fold_right(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, v, accu$0);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, v$0, fold_right(r, accu$0, f)),
      s$0 = l,
      accu$0 = accu$1;
    }
   }
   function for_all(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _aB_ = caml_call1(p, v$0);
     if(_aB_){
      var _aC_ = for_all(l, p);
      if(_aC_){var t$0 = r; continue;}
      var _aD_ = _aC_;
     }
     else
      var _aD_ = _aB_;
     return _aD_;
    }
   }
   function exists(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _ay_ = caml_call1(p, v$0);
     if(_ay_)
      var _az_ = _ay_;
     else{
      var _aA_ = exists(l, p);
      if(! _aA_){var t$0 = r; continue;}
      var _az_ = _aA_;
     }
     return _az_;
    }
   }
   function filter(s, p){
    function filt(t){
     if(typeof t === "number") return 0;
     if(0 === t[0]){var v = t[1]; return caml_call1(p, v) ? t : 0;}
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      l$0 = filt(l),
      keep_v = caml_call1(p, v$0),
      r$0 = filt(r);
     if(keep_v && l === l$0 && r === r$0) return t;
     return keep_v ? join(l$0, v$0, r$0) : concat(l$0, r$0);
    }
    return filt(s);
   }
   function filter_map(s, p, compare_elt){
    function filt(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1], match = caml_call1(p, v);
       if(! match) return accu$0;
       var v$0 = match[1];
       return add(accu$0, v$0, compare_elt);
      }
      var
       r = param$0[3],
       v$1 = param$0[2],
       l = param$0[1],
       match$0 = caml_call1(p, v$1);
      if(match$0)
       var v$2 = match$0[1], _ax_ = add(accu$0, v$2, compare_elt);
      else
       var _ax_ = accu$0;
      var accu$1 = filt(_ax_, l), accu$0 = accu$1, param$0 = r;
     }
    }
    return filt(0, s);
   }
   function partition_tf(s, p){
    function loop(t){
     if(typeof t === "number") return _r_;
     if(0 === t[0]){
      var v = t[1];
      return caml_call1(p, v) ? [0, t, 0] : [0, 0, t];
     }
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      match = loop(l),
      l_f = match[2],
      l_t = match[1],
      keep_v_t = caml_call1(p, v$0),
      match$0 = loop(r),
      r_f = match$0[2],
      r_t = match$0[1];
     function mk(keep_v, l$0, r$0){
      if(keep_v && l === l$0 && r === r$0) return t;
      return keep_v ? join(l$0, v$0, r$0) : concat(l$0, r$0);
     }
     var _aw_ = mk(1 - keep_v_t, l_f, r_f);
     return [0, mk(keep_v_t, l_t, r_t), _aw_];
    }
    return loop(s);
   }
   function elements_aux(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return accu$0;
     if(0 === param$0[0]){var v = param$0[1]; return [0, v, accu$0];}
     var
      r = param$0[3],
      v$0 = param$0[2],
      l = param$0[1],
      accu$1 = [0, v$0, elements_aux(accu$0, r)],
      accu$0 = accu$1,
      param$0 = l;
    }
   }
   function elements(s){return elements_aux(0, s);}
   function choose(t){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var v = t[1]; return [0, v];}
    var v$0 = t[2];
    return [0, v$0];
   }
   var not_found = [0, Base_Import[297], _s_];
   function choose_exn(t){
    var match = choose(t);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var v = match[1];
    return v;
   }
   function of_list(lst, compare_elt){
    function _av_(t, x){return add(t, x, compare_elt);}
    return caml_call3
            (Base_List[20], lst, empty_without_value_restrictio, _av_);
   }
   function of_sequence(sequence, compare_elt){
    function _au_(t, x){return add(t, x, compare_elt);}
    return caml_call3
            (Base_Sequence[11],
             sequence,
             empty_without_value_restrictio,
             _au_);
   }
   function to_list(s){return elements(s);}
   function of_array(a, compare_elt){
    function _at_(t, x){return add(t, x, compare_elt);}
    return caml_call3(Base_Array[21], a, empty_without_value_restrictio, _at_);
   }
   function to_array(param){
    if(typeof param === "number") return [0];
    if(0 === param[0]){var v = param[1]; return [0, v];}
    var
     s = param[5],
     r = param[3],
     v$0 = param[2],
     l = param[1],
     res = caml_call2(Base_Array[48], s, v$0),
     pos_ref = [0, 0];
    function loop(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return;
      if(0 === param$0[0]){
       var v = param$0[1], _ar_ = pos_ref[1];
       caml_check_bound(res, _ar_)[1 + _ar_] = v;
       pos_ref[1]++;
       return;
      }
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      loop(l);
      var _as_ = pos_ref[1];
      caml_check_bound(res, _as_)[1 + _as_] = v$0;
      pos_ref[1]++;
      var param$0 = r;
     }
    }
    loop(l);
    pos_ref[1]++;
    loop(r);
    return res;
   }
   function map(t, f, compare_elt){
    return fold
            (t,
             empty_without_value_restrictio,
             function(t, x){return add(t, caml_call1(f, x), compare_elt);});
   }
   function group_by(set, equiv){
    var set$0 = set, equiv_classes = 0;
    for(;;){
     if(is_empty(set$0)) return equiv_classes;
     var
      x = choose_exn(set$0),
      match =
        partition_tf
         (set$0,
          function(x){
            return function(elt){
             var _aq_ = x === elt ? 1 : 0;
             return _aq_ ? _aq_ : caml_call2(equiv, x, elt);};
           }
           (x)),
      not_equiv_x = match[2],
      equiv_x = match[1],
      equiv_classes$0 = [0, equiv_x, equiv_classes],
      set$0 = not_equiv_x,
      equiv_classes = equiv_classes$0;
    }
   }
   function find(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)) return [0, v$0];
     var r$0 = find(l, f);
     if(r$0) return r$0;
     var t$0 = r;
    }
   }
   function find_map(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], r$0 = caml_call1(f, v$0);
     if(r$0) return r$0;
     var r$1 = find_map(l, f);
     if(r$1) return r$1;
     var t$0 = r;
    }
   }
   function find_exn(t, f){
    var match = find(t, f);
    if(! match)
     return caml_call1(Base_Import[124], cst_Set_find_exn_failed_to_fin);
    var e = match[1];
    return e;
   }
   function nth(t, i){
    var t$0 = t, i$0 = i;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return 0 === i$0 ? [0, v] : 0;}
     var s = t$0[5], r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(s <= i$0) return 0;
     var l_size = length(l), c = caml_int_compare(i$0, l_size);
     if(0 <= c){
      if(0 === c) return [0, v$0];
      var
       _ap_ = caml_call2(Base_Import[93], i$0, l_size),
       i$1 = caml_call2(Base_Import[93], _ap_, 1),
       t$0 = r,
       i$0 = i$1;
     }
     else
      var t$0 = l;
    }
   }
   function stable_dedup_list(xs, compare_elt){
    var
     xs$0 = xs,
     leftovers = 0,
     already_seen = empty_without_value_restrictio;
    for(;;){
     if(! xs$0) return caml_call1(Base_List[63], leftovers);
     var tl = xs$0[2], hd = xs$0[1];
     if(mem(already_seen, hd, compare_elt))
      var xs$0 = tl;
     else
      var
       already_seen$0 = add(already_seen, hd, compare_elt),
       leftovers$0 = [0, hd, leftovers],
       xs$0 = tl,
       leftovers = leftovers$0,
       already_seen = already_seen$0;
    }
   }
   function t_of_sexp_direct(a_of_sexp, sexp, compare_elt){
    if(0 === sexp[0])
     return caml_call2(Base_Import[156], cst_Set_t_of_sexp_list_needed, sexp);
    var
     lst = sexp[1],
     elt_lst = caml_call2(Base_List[53], lst, a_of_sexp),
     set = of_list(elt_lst, compare_elt),
     _an_ = caml_call1(Base_List[45], lst);
    if(length(set) === _an_) return set;
    var set$0 = [0, empty_without_value_restrictio];
    function _ao_(el_sexp, el){
     return mem(set$0[1], el, compare_elt)
             ? caml_call2
               (Base_Import[156], cst_Set_t_of_sexp_duplicate_el, el_sexp)
             : (set$0[1] = add(set$0[1], el, compare_elt), 0);
    }
    caml_call3(Base_List[67], lst, elt_lst, _ao_);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
   }
   function sexp_of_t(sexp_of_a, t){
    return [1,
            fold_right
             (t,
              0,
              function(el, acc){return [0, caml_call1(sexp_of_a, el), acc];})];
   }
   function is_subset$0(subset, superset, sexp_of_elt, compare_elt){
    var invalid_elements = diff(subset[1], superset[1], compare_elt);
    if(is_empty(invalid_elements)) return _u_;
    var
     invalid_elements_sexp = sexp_of_t(sexp_of_elt, invalid_elements),
     _ak_ = caml_call2(Base_Import[112], cst_is_not_a_subset_of, superset[2]),
     _al_ = caml_call2(Base_Import[112], subset[2], _ak_),
     _am_ =
       caml_call2
        (Base_Sexp[10],
         _al_,
         [0, [0, cst_invalid_elements, invalid_elements_sexp], 0]);
    return caml_call1(Base_Or_error[39], _am_);
   }
   function like(param, tree){
    var comparator = param[1];
    return [0, comparator, tree];
   }
   function like_maybe_no_op(old_t, tree){
    var old_tree = old_t[2], comparator = old_t[1];
    return old_tree === tree ? old_t : [0, comparator, tree];
   }
   function compare_elt(t){return t[1][1];}
   function comparator(t){return t[1];}
   function comparator_s(t){return caml_call1(Base_Comparator[5], t[1]);}
   function invariants$0(t){
    var _aj_ = compare_elt(t);
    return invariants(t[2], _aj_);
   }
   function length$0(t){return length(t[2]);}
   function is_empty$0(t){return is_empty(t[2]);}
   function elements$0(t){return elements(t[2]);}
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function choose$0(t){return choose(t[2]);}
   function choose_exn$0(t){return choose_exn(t[2]);}
   function to_list$0(t){return to_list(t[2]);}
   function to_array$0(t){return to_array(t[2]);}
   function fold$0(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f, finish){
    return fold_until(t[2], init, f, finish);
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold$0, init, f, t);
   }
   function iter$1(t, f){return iter$0(t[2], f);}
   function iter2$0(a, b, f){
    var _ai_ = compare_elt(a);
    return iter2(a[2], b[2], _ai_, f);
   }
   function exists$0(t, f){return exists(t[2], f);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function sum$0(m, t, f){return sum(m, t[2], f);}
   function find$0(t, f){return find(t[2], f);}
   function find_exn$0(t, f){return find_exn(t[2], f);}
   function find_map$0(t, f){return find_map(t[2], f);}
   function mem$0(t, a){var _ah_ = compare_elt(t); return mem(t[2], a, _ah_);}
   function filter$0(t, f){return like_maybe_no_op(t, filter(t[2], f));}
   function add$0(t, a){
    var _ag_ = compare_elt(t);
    return like(t, add(t[2], a, _ag_));
   }
   function remove$0(t, a){
    var _af_ = compare_elt(t);
    return like(t, remove(t[2], a, _af_));
   }
   function union$0(t1, t2){
    var _ae_ = compare_elt(t1);
    return like(t1, union(t1[2], t2[2], _ae_));
   }
   function inter$0(t1, t2){
    var _ad_ = compare_elt(t1);
    return like(t1, inter(t1[2], t2[2], _ad_));
   }
   function diff$0(t1, t2){
    var _ac_ = compare_elt(t1);
    return like(t1, diff(t1[2], t2[2], _ac_));
   }
   function symmetric_diff$0(t1, t2){
    var _ab_ = compare_elt(t1);
    return symmetric_diff(t1[2], t2[2], _ab_);
   }
   function compare_direct(t1, t2){
    var _$_ = t2[2], _aa_ = t1[2];
    return compare(compare_elt(t1), _aa_, _$_);
   }
   function equal$0(t1, t2){
    var ___ = compare_elt(t1);
    return equal(t1[2], t2[2], ___);
   }
   function is_subset$1(t, of){
    var _Z_ = compare_elt(t);
    return is_subset(t[2], of[2], _Z_);
   }
   function are_disjoint$0(t1, t2){
    var _Y_ = compare_elt(t1);
    return are_disjoint(t1[2], t2[2], _Y_);
   }
   function to_named_tree(named){return [0, named[1][2], named[2]];}
   function is_subset$2(subset, superset){
    var
     _V_ = compare_elt(subset[1]),
     _W_ = subset[1][1][2],
     _X_ = to_named_tree(superset);
    return is_subset$0(to_named_tree(subset), _X_, _W_, _V_);
   }
   function equal$1(t1, t2){
    var
     _T_ = [0, is_subset$2(t2, t1), 0],
     _U_ = [0, is_subset$2(t1, t2), _T_];
    return caml_call1(Base_Or_error[51], _U_);
   }
   function partition_tf$0(t, f){
    var
     match = partition_tf(t[2], f),
     tree_f = match[2],
     tree_t = match[1],
     _S_ = like_maybe_no_op(t, tree_f);
    return [0, like_maybe_no_op(t, tree_t), _S_];
   }
   function split$0(t, a){
    var
     _Q_ = compare_elt(t),
     match = split(t[2], a, _Q_),
     tree2 = match[3],
     b = match[2],
     tree1 = match[1],
     _R_ = like(t, tree2);
    return [0, like(t, tree1), b, _R_];
   }
   function split_le_gt$0(t, a){
    var
     _O_ = compare_elt(t),
     match = split_le_gt(t[2], a, _O_),
     tree2 = match[2],
     tree1 = match[1],
     _P_ = like(t, tree2);
    return [0, like(t, tree1), _P_];
   }
   function split_lt_ge$0(t, a){
    var
     _M_ = compare_elt(t),
     match = split_lt_ge(t[2], a, _M_),
     tree2 = match[2],
     tree1 = match[1],
     _N_ = like(t, tree2);
    return [0, like(t, tree1), _N_];
   }
   function group_by$0(t, equiv){
    function _J_(_L_){return like(t, _L_);}
    var _K_ = group_by(t[2], equiv);
    return caml_call2(Base_List[53], _K_, _J_);
   }
   function nth$0(t, i){return nth(t[2], i);}
   function remove_index$0(t, i){
    var _I_ = compare_elt(t);
    return like(t, remove_index(t[2], i, _I_));
   }
   function sexp_of_t$0(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t[2]);
   }
   function to_sequence$0(order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (t[1], order, greater_or_equal_to, less_or_equal_to, t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function merge_to_sequence$0
   (order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (t$0[1],
             order,
             greater_or_equal_to,
             less_or_equal_to,
             t$0[2],
             t[2]);
   }
   function hash_fold_direct(hash_fold_elem, state, t){
    var t$0 = t[2], _H_ = length(t$0);
    return fold(t$0, caml_call2(Base_Import[206], state, _H_), hash_fold_elem);
   }
   function compare$0(param, _G_, t1, t2){return compare_direct(t1, t2);}
   function t_of_sexp_direct$0(comparator, a_of_sexp, sexp){
    return t_of_sexp_direct(a_of_sexp, sexp, comparator[1]);
   }
   function empty(param){return empty_without_value_restrictio;}
   function singleton(param, e){return [0, e];}
   function length$1(t){return length(t);}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function elements$1(t){return elements(t);}
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function choose$1(t){return choose(t);}
   function choose_exn$1(t){return choose_exn(t);}
   function to_list$1(t){return to_list(t);}
   function to_array$1(t){return to_array(t);}
   function iter$2(t, f){return iter$0(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function for_all$1(t, f){return for_all(t, f);}
   function count$1(t, f){return count(t, f);}
   function sum$1(m, t, f){return sum(m, t, f);}
   function find$1(t, f){return find(t, f);}
   function find_exn$1(t, f){return find_exn(t, f);}
   function find_map$1(t, f){return find_map(t, f);}
   function fold$1(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f, finish){return fold_until(t, init, f, finish);
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function map$0(comparator, t, f){return map(t, f, comparator[1]);}
   function filter$1(t, f){return filter(t, f);}
   function filter_map$0(comparator, t, f){
    return filter_map(t, f, comparator[1]);
   }
   function partition_tf$1(t, f){return partition_tf(t, f);}
   function iter2$1(comparator, a, b, f){
    return iter2(a, b, comparator[1], f);
   }
   function mem$1(comparator, t, a){return mem(t, a, comparator[1]);}
   function add$1(comparator, t, a){return add(t, a, comparator[1]);}
   function remove$1(comparator, t, a){return remove(t, a, comparator[1]);}
   function union$1(comparator, t1, t2){return union(t1, t2, comparator[1]);}
   function inter$1(comparator, t1, t2){return inter(t1, t2, comparator[1]);}
   function diff$1(comparator, t1, t2){return diff(t1, t2, comparator[1]);}
   function symmetric_diff$1(comparator, t1, t2){
    return symmetric_diff(t1, t2, comparator[1]);
   }
   function compare_direct$0(comparator, t1, t2){return compare(comparator[1], t1, t2);
   }
   function equal$2(comparator, t1, t2){return equal(t1, t2, comparator[1]);}
   function is_subset$3(comparator, t, of){
    return is_subset(t, of, comparator[1]);
   }
   function are_disjoint$1(comparator, t1, t2){
    return are_disjoint(t1, t2, comparator[1]);
   }
   function of_list$0(comparator, l){return of_list(l, comparator[1]);}
   function of_sequence$0(comparator, s){
    return of_sequence(s, comparator[1]);
   }
   function of_array$0(comparator, a){return of_array(a, comparator[1]);}
   function of_sorted_array_unchecked$0(comparator, a){
    return of_sorted_array_unchecked(a, comparator[1]);
   }
   function of_increasing_iterator_uncheck$0(param, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_sorted_array$0(comparator, a){
    return of_sorted_array(a, comparator[1]);
   }
   function union_list$0(comparator, l){
    return union_list(comparator, function(_F_){return _F_;}, l);
   }
   function stable_dedup_list$0(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function group_by$1(t, equiv){return group_by(t, equiv);}
   function split$1(comparator, t, a){return split(t, a, comparator[1]);}
   function split_le_gt$1(comparator, t, a){
    return split_le_gt(t, a, comparator[1]);
   }
   function split_lt_ge$1(comparator, t, a){
    return split_lt_ge(t, a, comparator[1]);
   }
   function nth$1(t, i){return nth(t, i);}
   function remove_index$1(comparator, t, i){
    return remove_index(t, i, comparator[1]);
   }
   function sexp_of_t$1(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t);}
   function to_tree(t){return t;}
   function of_tree(param, t){return t;}
   function to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function merge_to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t);
   }
   function fold_result$0(t, init, f){
    return caml_call4(Base_Container[8], fold$1, init, f, t);
   }
   function is_subset$4(comparator, t1, t2){
    return is_subset$0(t1, t2, comparator[2], comparator[1]);
   }
   function equal$3(comparator, t1, t2){
    var
     compare_elt = comparator[1],
     sexp_of_elt = comparator[2],
     _D_ = [0, is_subset$0(t2, t1, sexp_of_elt, compare_elt), 0],
     _E_ = [0, is_subset$0(t1, t2, sexp_of_elt, compare_elt), _D_];
    return caml_call1(Base_Or_error[51], _E_);
   }
   var Named = [0, is_subset$4, equal$3];
   function to_tree$0(t){return t[2];}
   function of_tree$0(comparator, tree){return [0, comparator, tree];}
   function t_of_sexp_direct$1(comparator, a_of_sexp, sexp){
    return [0, comparator, t_of_sexp_direct(a_of_sexp, sexp, comparator[1])];
   }
   function empty$0(comparator){
    return [0, comparator, empty_without_value_restrictio];
   }
   function Empty_without_value_restrictio(Elt){
    var empty = [0, Elt[1], empty_without_value_restrictio];
    return [0, empty];
   }
   function singleton$0(comparator, e){return [0, comparator, [0, e]];}
   function union_list$1(comparator, l){
    return [0, comparator, union_list(comparator, to_tree$0, l)];
   }
   function of_sorted_array_unchecked$1(comparator, array){
    var tree = of_sorted_array_unchecked(array, comparator[1]);
    return [0, comparator, tree];
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    return [0, comparator, of_increasing_iterator_uncheck(len, f)];
   }
   function of_sorted_array$1(comparator, array){
    function _B_(tree){return [0, comparator, tree];}
    var _C_ = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[21][2], _C_, _B_);
   }
   function of_list$1(comparator, l){
    return [0, comparator, of_list(l, comparator[1])];
   }
   function of_sequence$1(comparator, s){
    return [0, comparator, of_sequence(s, comparator[1])];
   }
   function of_array$1(comparator, a){
    return [0, comparator, of_array(a, comparator[1])];
   }
   function stable_dedup_list$1(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function map$1(comparator, t, f){
    return [0, comparator, map(t[2], f, comparator[1])];
   }
   function filter_map$1(comparator, t, f){
    return [0, comparator, filter_map(t[2], f, comparator[1])];
   }
   var to_comparator = Base_Comparator[4];
   function empty$1(m){return empty$0(caml_call1(to_comparator, m));}
   function singleton$1(m, a){
    return singleton$0(caml_call1(to_comparator, m), a);
   }
   function union_list$2(m, a){
    return union_list$1(caml_call1(to_comparator, m), a);
   }
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(caml_call1(to_comparator, m), a);
   }
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1
            (caml_call1(to_comparator, m), len, f);
   }
   function of_sorted_array$2(m, a){
    return of_sorted_array$1(caml_call1(to_comparator, m), a);
   }
   function of_list$2(m, a){
    return of_list$1(caml_call1(to_comparator, m), a);
   }
   function of_sequence$2(m, a){
    return of_sequence$1(caml_call1(to_comparator, m), a);
   }
   function of_array$2(m, a){
    return of_array$1(caml_call1(to_comparator, m), a);
   }
   function stable_dedup_list$2(m, a){
    return stable_dedup_list$1(caml_call1(to_comparator, m), a);
   }
   function map$2(m, a, f){return map$1(caml_call1(to_comparator, m), a, f);}
   function filter_map$2(m, a, f){
    return filter_map$1(caml_call1(to_comparator, m), a, f);
   }
   function of_tree$1(m, t){return [0, caml_call1(to_comparator, m), t];}
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt, t){
    function _A_(param){return _v_;}
    return sexp_of_t$0(Elt[1], _A_, t);
   }
   function m_t_of_sexp(Elt, sexp){
    return t_of_sexp_direct$1(Elt[2], Elt[1], sexp);
   }
   function m_t_sexp_grammar(Elt){
    var _z_ = caml_call1(Base_Import[194], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _z_);
   }
   function compare_m_t(param, t1, t2){return compare_direct(t1, t2);}
   function equal_m_t(param, t1, t2){return equal$0(t1, t2);}
   function hash_fold_m_t(Elt, state){
    var _x_ = Elt[1];
    return function(_y_){return hash_fold_direct(_x_, state, _y_);};
   }
   function hash_m_t(folder, t){
    var state = hash_fold_m_t(folder, caml_call2(Base_Hash[11], 0, 0))(t);
    return caml_call1(Base_Hash[9], state);
   }
   var
    comparator$0 = Base_Comparator[2][1],
    include = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$2 = include[1];
   function singleton$2(a){return singleton$0(comparator$0, a);}
   function union_list$3(a){return union_list$1(comparator$0, a);}
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_list$3(a){return of_list$1(comparator$0, a);}
   function of_sequence$3(a){return of_sequence$1(comparator$0, a);}
   function of_array$3(a){return of_array$1(comparator$0, a);}
   function stable_dedup_list$3(a){
    return stable_dedup_list$1(comparator$0, a);
   }
   function map$3(a, f){return map$1(comparator$0, a, f);}
   function filter_map$3(a, f){return filter_map$1(comparator$0, a, f);}
   function of_tree$2(tree){return [0, comparator$0, tree];}
   function to_tree$1(t){return t[2];}
   var
    _w_ = Base_Sequence[57],
    Base_Set =
      [0,
       compare$0,
       invariants$0,
       comparator_s,
       comparator,
       empty$1,
       singleton$1,
       length$0,
       is_empty$0,
       mem$0,
       add$0,
       remove$0,
       union$0,
       union_list$2,
       inter$0,
       diff$0,
       symmetric_diff$0,
       compare_direct,
       hash_fold_direct,
       equal$0,
       exists$0,
       for_all$0,
       count$0,
       sum$0,
       find$0,
       find_map$0,
       find_exn$0,
       nth$0,
       remove_index$0,
       is_subset$1,
       are_disjoint$0,
       [0, is_subset$2, equal$1],
       of_list$2,
       of_sequence$2,
       of_array$2,
       to_list$0,
       to_array$0,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       stable_dedup_list$2,
       map$2,
       filter_map$2,
       filter$0,
       fold$0,
       fold_result,
       fold_until$0,
       fold_right$0,
       iter$1,
       iter2$0,
       partition_tf$0,
       elements$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       choose$0,
       choose_exn$0,
       split$0,
       split_le_gt$0,
       split_lt_ge$0,
       group_by$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       [0, _w_[1], _w_[6], _w_[7]],
       merge_to_sequence$0,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       hash_m_t,
       [0,
        sexp_of_t$0,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$1,
         t_of_sexp_direct$0,
         length$1,
         is_empty$1,
         iter$2,
         fold$1,
         fold_result$0,
         exists$1,
         for_all$1,
         count$1,
         sum$1,
         find$1,
         find_map$1,
         to_list$1,
         to_array$1,
         invariants$1,
         mem$1,
         add$1,
         remove$1,
         union$1,
         inter$1,
         diff$1,
         symmetric_diff$1,
         compare_direct$0,
         equal$2,
         is_subset$3,
         are_disjoint$1,
         Named,
         fold_until$1,
         fold_right$1,
         iter2$1,
         filter$1,
         partition_tf$1,
         elements$1,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         choose$1,
         choose_exn$1,
         split$1,
         split_le_gt$1,
         split_lt_ge$1,
         group_by$1,
         find_exn$1,
         nth$1,
         remove_index$1,
         to_tree,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         merge_to_sequence$1,
         empty,
         singleton,
         union_list$0,
         of_list$0,
         of_sequence$0,
         of_array$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         stable_dedup_list$0,
         map$0,
         filter_map$0,
         of_tree,
         empty_without_value_restrictio],
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list$0,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        split_le_gt$0,
        split_lt_ge$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$0,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$0,
        singleton$0,
        union_list$1,
        of_list$1,
        of_sequence$1,
        of_array$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        stable_dedup_list$1,
        map$1,
        filter_map$1,
        of_tree$0,
        comparator_s,
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio],
       to_tree$0,
       of_tree$1,
       [0,
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list$0,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        split_le_gt$0,
        split_lt_ge$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$1,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$2,
        singleton$2,
        union_list$3,
        of_list$3,
        of_sequence$3,
        of_array$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        stable_dedup_list$3,
        map$3,
        filter_map$3,
        of_tree$2]];
   runtime.caml_register_global(48, Base_Set, "Base__Set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ref
//# unitInfo: Requires: Base__Exn, Base__Import, Base__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Exn = global_data.Base__Exn,
    Base_List = global_data.Base__List,
    Base_Import = global_data.Base__Import,
    compare_local = Base_Import[266],
    compare = Base_Import[238],
    equal_local = Base_Import[280],
    equal = Base_Import[252],
    globalize = Base_Import[296],
    t_of_sexp = Base_Import[168],
    sexp_of_t = Base_Import[144];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[191], a_sexp_grammar);
   }
   function swap(t1, t2){
    var tmp = t1[1];
    t1[1] = t2[1];
    t2[1] = tmp;
    return 0;
   }
   function replace(t, f){t[1] = caml_call1(f, t[1]); return 0;}
   function set_temporarily(t, a, f){
    var restore_to = t[1];
    t[1] = a;
    function _b_(param){t[1] = restore_to; return 0;}
    return caml_call2(Base_Exn[13], f, _b_);
   }
   function set(param){var a = param[2], r = param[1]; r[1] = a; return 0;}
   function sets(ts){return caml_call2(Base_List[19], ts, set);}
   function snapshot(param){var r = param[1]; return [0, r, r[1]];}
   function sets_temporarily(and_values, f){
    var restore_to = caml_call2(Base_List[53], and_values, snapshot);
    sets(and_values);
    function _a_(param){return sets(restore_to);}
    return caml_call2(Base_Exn[13], f, _a_);
   }
   var
    Base_Ref =
      [0,
       compare,
       compare_local,
       equal,
       equal_local,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       swap,
       replace,
       set_temporarily,
       [0, set, sets, snapshot],
       sets_temporarily];
   runtime.caml_register_global(3, Base_Ref, "Base__Ref");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Queue_intf = [0];
   runtime.caml_register_global(0, Base_Queue_intf, "Base__Queue_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue
//# unitInfo: Requires: Base__Array, Base__Error, Base__Import, Base__Indexed_container, Base__Int, Base__List, Base__Option_array, Base__Sexp, Sexplib0__Sexp_grammar, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_length$2 = "length",
    cst_src_queue_ml = "src/queue.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Array = global_data.Base__Array,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Base_Indexed_container = global_data.Base__Indexed_container,
    _q_ = [0, 1],
    cst_length$1 = cst_length$2,
    cst_Queue_init_negative_length = "Queue.init: negative length",
    _p_ = [0, cst_src_queue_ml, 507, 2],
    cst_length$0 = cst_length$2,
    cst_Queue_blit_transfer_negati = "Queue.blit_transfer: negative length",
    _o_ = [0, cst_src_queue_ml, 212, 2],
    cst_capacity = "capacity",
    cst_cannot_have_queue_with_neg =
      "cannot have queue with negative capacity",
    _n_ = [0, cst_src_queue_ml, 171, 2],
    _m_ = [0, cst_src_queue_ml, 172, 2],
    _l_ = [0, cst_src_queue_ml, 174, 2],
    _k_ = [0, cst_src_queue_ml, 175, 2],
    _j_ = [0, cst_src_queue_ml, 176, 2],
    _i_ = [0, cst_src_queue_ml, 177, 2],
    _h_ = [0, cst_src_queue_ml, 178, 2],
    _g_ = [0, cst_src_queue_ml, 184, 9],
    _f_ = [0, "_"],
    cst_mutation_of_queue_during_i = "mutation of queue during iteration",
    cst_length = cst_length$2,
    cst_index = "index",
    cst_Queue_index_out_of_bounds = "Queue index out of bounds",
    _a_ = [0, "elts"],
    _b_ = [0, cst_length$2],
    _c_ = [0, "mask"],
    _d_ = [0, "front"],
    _e_ = [0, "num_mutations"];
   function globalize(param, t){
    var _a9_ = caml_call1(Base_Option_array[58], t[5]);
    return [0, t[1], t[2], t[3], t[4], _a9_];
   }
   function inc_num_mutations(t){
    t[1] = caml_call2(Base_Import[91], t[1], 1);
    return;
   }
   function capacity(t){return caml_call2(Base_Import[91], t[3], 1);}
   function elts_index(t, i){
    var _a7_ = t[3], _a8_ = caml_call2(Base_Import[91], t[2], i);
    return caml_call2(Base_Import[116], _a8_, _a7_);
   }
   function unsafe_get(t, i){
    var _a6_ = elts_index(t, i);
    return caml_call2(Base_Option_array[40], t[5], _a6_);
   }
   function unsafe_set(t, i, a){
    var _a5_ = elts_index(t, i);
    return caml_call3(Base_Option_array[51], t[5], _a5_, a);
   }
   function check_index_exn(t, i){
    var _a0_ = i < 0 ? 1 : 0, _a1_ = _a0_ || (t[4] <= i ? 1 : 0);
    if(! _a1_) return _a1_;
    var
     _a2_ = [0, [0, cst_length, caml_call1(Base_Int[10], t[4])], 0],
     _a3_ = [0, [0, cst_index, caml_call1(Base_Int[10], i)], _a2_],
     _a4_ = caml_call2(Base_Sexp[10], cst_Queue_index_out_of_bounds, _a3_);
    return caml_call1(Base_Error[32], _a4_);
   }
   function get(t, i){check_index_exn(t, i); return unsafe_get(t, i);}
   function set(t, i, a){
    check_index_exn(t, i);
    inc_num_mutations(t);
    return unsafe_set(t, i, a);
   }
   function is_empty(t){return 0 === t[4] ? 1 : 0;}
   function length(param){var length = param[4]; return length;}
   function ensure_no_mutation(t, num_mutations){
    var _aZ_ = t[1] !== num_mutations ? 1 : 0;
    if(! _aZ_) return _aZ_;
    var param = globalize(0, t), _aX_ = 0;
    function of_a_001(param){return _f_;}
    var
     num_mutations_003 = param[1],
     front_005 = param[2],
     mask_007 = param[3],
     length_009 = param[4],
     elts_011 = param[5],
     arg_012 = caml_call2(Base_Option_array[2], of_a_001, elts_011),
     bnds_002 = [0, [1, [0, _a_, [0, arg_012, 0]]], 0],
     arg_010 = caml_call1(Base_Import[139], length_009),
     bnds_002$0 = [0, [1, [0, _b_, [0, arg_010, 0]]], bnds_002],
     arg_008 = caml_call1(Base_Import[139], mask_007),
     bnds_002$1 = [0, [1, [0, _c_, [0, arg_008, 0]]], bnds_002$0],
     arg_006 = caml_call1(Base_Import[139], front_005),
     bnds_002$2 = [0, [1, [0, _d_, [0, arg_006, 0]]], bnds_002$1],
     arg_004 = caml_call1(Base_Import[139], num_mutations_003),
     bnds_002$3 = [0, [1, [0, _e_, [0, arg_004, 0]]], bnds_002$2],
     _aY_ =
       caml_call2
        (Base_Sexp[10],
         cst_mutation_of_queue_during_i,
         [0, [0, cst, [1, bnds_002$3]], _aX_]);
    return caml_call1(Base_Error[32], _aY_);
   }
   function compare_local(compare_elt, t1, t2){
    if(t1 === t2) return 0;
    var mut2 = t2[1], mut1 = t1[1], len2 = t2[4], len1 = t1[4], pos = 0;
    for(;;){
     var match = pos === len2 ? 1 : 0;
     if(pos === len1) return match ? 0 : -1;
     if(match) return 1;
     var
      _aW_ = unsafe_get(t2, pos),
      x = caml_call2(compare_elt, unsafe_get(t1, pos), _aW_);
     ensure_no_mutation(t1, mut1);
     ensure_no_mutation(t2, mut2);
     if(0 !== x) return x;
     var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
    }
   }
   function compare(compare_elt, t1, t2){
    return compare_local(compare_elt, t1, t2);
   }
   function equal_local(equal_elt, t1, t2){
    var _aT_ = t1 === t2 ? 1 : 0;
    if(_aT_)
     var _aU_ = _aT_;
    else{
     var len1 = t1[4], len2 = t2[4], _aV_ = len1 === len2 ? 1 : 0;
     if(_aV_){
      var mut2 = t2[1], mut1 = t1[1], pos = 0;
      for(;;){
       var _aQ_ = pos === len1 ? 1 : 0;
       if(_aQ_)
        var _aR_ = _aQ_;
       else{
        var
         _aS_ = unsafe_get(t2, pos),
         b = caml_call2(equal_elt, unsafe_get(t1, pos), _aS_);
        ensure_no_mutation(t1, mut1);
        ensure_no_mutation(t2, mut2);
        if(b){
         var pos$0 = caml_call2(Base_Import[91], pos, 1), pos = pos$0;
         continue;
        }
        var _aR_ = b;
       }
       return _aR_;
      }
     }
     var _aU_ = _aV_;
    }
    return _aU_;
   }
   function equal(equal_elt, t1, t2){return equal_local(equal_elt, t1, t2);}
   function invariant(invariant_a, t){
    var num_mutations = t[1], front = t[2], length = t[4], elts = t[5];
    if(0 > front)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    if(front >= capacity(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    var capacity$0 = capacity(t);
    if(capacity$0 !== caml_call1(Base_Option_array[28], elts))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    if(1 > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    if(! caml_call1(Base_Int[72], capacity$0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    if(0 > length)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
    if(length > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var _aO_ = caml_call2(Base_Import[93], capacity$0, 1), _aN_ = 0;
    if(_aO_ >= 0){
     var i = _aN_;
     for(;;){
      if(i < t[4]){
       caml_call1(invariant_a, unsafe_get(t, i));
       ensure_no_mutation(t, num_mutations);
      }
      else{
       var _aM_ = elts_index(t, i);
       if(caml_call2(Base_Option_array[42], t[5], _aM_))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      var _aP_ = i + 1 | 0;
      if(_aO_ === i) break;
      var i = _aP_;
     }
    }
    return 0;
   }
   function create(capacity, param){
    if(capacity){
     var capacity$0 = capacity[1];
     if(0 <= capacity$0)
      var _aI_ = 0 === capacity$0 ? 1 : caml_call1(Base_Int[68], capacity$0);
     else
      var
       _aK_ = [0, [0, cst_capacity, caml_call1(Base_Int[10], capacity$0)], 0],
       _aL_ = caml_call2(Base_Sexp[10], cst_cannot_have_queue_with_neg, _aK_),
       _aI_ = caml_call1(Base_Error[32], _aL_);
     var capacity$1 = _aI_;
    }
    else
     var capacity$1 = 2;
    var _aJ_ = caml_call1(Base_Option_array[5], capacity$1);
    return [0, 0, 0, caml_call2(Base_Import[93], capacity$1, 1), 0, _aJ_];
   }
   function blit_to_array(src, dst){
    var _aE_ = caml_call1(Base_Option_array[28], dst);
    if(src[4] > _aE_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
    var
     _aF_ = src[2],
     _aG_ = capacity(src),
     _aH_ = caml_call2(Base_Import[93], _aG_, _aF_),
     front_len = caml_call2(Base_Int[15], src[4], _aH_),
     rest_len = caml_call2(Base_Import[93], src[4], front_len);
    caml_call5(Base_Option_array[53], src[5], src[2], dst, 0, front_len);
    return caml_call5
            (Base_Option_array[53], src[5], 0, dst, front_len, rest_len);
   }
   function set_capacity_internal(t, new_capacity){
    var dst = caml_call1(Base_Option_array[5], new_capacity);
    blit_to_array(t, dst);
    t[2] = 0;
    t[3] = caml_call2(Base_Import[93], new_capacity, 1);
    t[5] = dst;
    return 0;
   }
   function set_capacity(t, desired_capacity){
    inc_num_mutations(t);
    var
     _aB_ = caml_call2(Base_Import[100], desired_capacity, t[4]),
     _aC_ = caml_call2(Base_Import[100], 1, _aB_),
     new_capacity = caml_call1(Base_Int[68], _aC_),
     _aD_ = new_capacity !== capacity(t) ? 1 : 0;
    return _aD_ ? set_capacity_internal(t, new_capacity) : _aD_;
   }
   function enqueue(t, a){
    inc_num_mutations(t);
    var _aA_ = capacity(t);
    if(t[4] === _aA_)
     set_capacity_internal(t, caml_call2(Base_Import[88], 2, t[4]));
    unsafe_set(t, t[4], a);
    t[4] = caml_call2(Base_Import[91], t[4], 1);
    return 0;
   }
   function enqueue_front(t, a){
    inc_num_mutations(t);
    var _ax_ = capacity(t);
    if(t[4] === _ax_)
     set_capacity_internal(t, caml_call2(Base_Import[88], 2, t[4]));
    var
     _ay_ = t[3],
     _az_ = caml_call2(Base_Import[93], t[2], 1),
     front = caml_call2(Base_Import[116], _az_, _ay_);
    t[2] = front;
    t[4] = caml_call2(Base_Import[91], t[4], 1);
    return unsafe_set(t, 0, a);
   }
   function dequeue_nonempty(t){
    inc_num_mutations(t);
    var
     elts = t[5],
     front = t[2],
     res = caml_call2(Base_Option_array[36], elts, front);
    caml_call2(Base_Option_array[45], elts, front);
    t[2] = elts_index(t, 1);
    t[4] = caml_call2(Base_Import[93], t[4], 1);
    return res;
   }
   function back_index(t){
    return elts_index(t, caml_call2(Base_Import[93], t[4], 1));
   }
   function dequeue_back_nonempty(t){
    inc_num_mutations(t);
    var
     elts = t[5],
     back = back_index(t),
     res = caml_call2(Base_Option_array[36], elts, back);
    caml_call2(Base_Option_array[45], elts, back);
    t[4] = caml_call2(Base_Import[93], t[4], 1);
    return res;
   }
   function dequeue_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return dequeue_nonempty(t);
   }
   function dequeue(t){return is_empty(t) ? 0 : [0, dequeue_nonempty(t)];}
   function dequeue_and_ignore_exn(t){dequeue_exn(t); return 0;}
   function dequeue_back_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return dequeue_back_nonempty(t);
   }
   function dequeue_back(t){
    return is_empty(t) ? 0 : [0, dequeue_back_nonempty(t)];
   }
   function front_nonempty(t){
    return caml_call2(Base_Option_array[40], t[5], t[2]);
   }
   function back_nonempty(t){
    var _aw_ = back_index(t);
    return caml_call2(Base_Option_array[40], t[5], _aw_);
   }
   function last_nonempty(t){
    return unsafe_get(t, caml_call2(Base_Import[93], t[4], 1));
   }
   function peek(t){return is_empty(t) ? 0 : [0, front_nonempty(t)];}
   function peek_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return front_nonempty(t);
   }
   function peek_back(t){return is_empty(t) ? 0 : [0, back_nonempty(t)];}
   function peek_back_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return back_nonempty(t);
   }
   function last(t){return is_empty(t) ? 0 : [0, last_nonempty(t)];}
   function last_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return last_nonempty(t);
   }
   function drain(t, f, while$0){
    for(;;){
     if(! is_empty(t) && caml_call1(while$0, front_nonempty(t))){caml_call1(f, dequeue_nonempty(t)); continue;}
     return 0;
    }
   }
   function clear(t){
    inc_num_mutations(t);
    var _ar_ = 0 < t[4] ? 1 : 0;
    if(_ar_){
     var _at_ = caml_call2(Base_Import[93], t[4], 1), _as_ = 0;
     if(_at_ >= 0){
      var i = _as_;
      for(;;){
       var _aq_ = elts_index(t, i);
       caml_call2(Base_Option_array[52], t[5], _aq_);
       var _av_ = i + 1 | 0;
       if(_at_ === i) break;
       var i = _av_;
      }
     }
     t[4] = 0;
     t[2] = 0;
     var _au_ = 0;
    }
    else
     var _au_ = _ar_;
    return _au_;
   }
   function blit_transfer(src, dst, len, param){
    inc_num_mutations(src);
    inc_num_mutations(dst);
    if(len){
     var len$0 = len[1];
     if(len$0 < 0){
      var
       _aa_ = [0, [0, cst_length$0, caml_call1(Base_Int[10], len$0)], 0],
       _ab_ = caml_call2(Base_Sexp[10], cst_Queue_blit_transfer_negati, _aa_);
      caml_call1(Base_Error[32], _ab_);
     }
     var len$1 = caml_call2(Base_Import[101], len$0, src[4]);
    }
    else
     var len$1 = src[4];
    var _ac_ = 0 < len$1 ? 1 : 0;
    if(_ac_){
     var
      _ad_ = caml_call2(Base_Import[91], dst[4], len$1),
      _ae_ = capacity(dst);
     set_capacity(dst, caml_call2(Base_Import[100], _ae_, _ad_));
     var
      dst_start = caml_call2(Base_Import[91], dst[2], dst[4]),
      _ag_ = caml_call2(Base_Import[93], len$1, 1),
      _af_ = 0;
     if(_ag_ >= 0){
      var i = _af_;
      for(;;){
       var
        _ak_ = src[3],
        _al_ = caml_call2(Base_Import[91], src[2], i),
        src_i = caml_call2(Base_Import[116], _al_, _ak_),
        _am_ = dst[3],
        _an_ = caml_call2(Base_Import[91], dst_start, i),
        dst_i = caml_call2(Base_Import[116], _an_, _am_),
        _ao_ = caml_call2(Base_Option_array[40], src[5], src_i);
       caml_call3(Base_Option_array[51], dst[5], dst_i, _ao_);
       caml_call2(Base_Option_array[52], src[5], src_i);
       var _ap_ = i + 1 | 0;
       if(_ag_ === i) break;
       var i = _ap_;
      }
     }
     dst[4] = caml_call2(Base_Import[91], dst[4], len$1);
     var _ah_ = src[3], _ai_ = caml_call2(Base_Import[91], src[2], len$1);
     src[2] = caml_call2(Base_Import[116], _ai_, _ah_);
     src[4] = caml_call2(Base_Import[93], src[4], len$1);
     var _aj_ = 0;
    }
    else
     var _aj_ = _ac_;
    return _aj_;
   }
   function enqueue_all(t, l){
    var
     _Y_ = caml_call1(Base_List[45], l),
     _Z_ = caml_call2(Base_Import[91], t[4], _Y_),
     ___ = capacity(t);
    set_capacity(t, caml_call2(Base_Int[16], ___, _Z_));
    function _$_(x){return enqueue(t, x);}
    return caml_call2(Base_List[19], l, _$_);
   }
   function fold(t, init, f){
    if(0 === t[4]) return init;
    var
     num_mutations = t[1],
     r = [0, init],
     _V_ = caml_call2(Base_Import[93], t[4], 1),
     _U_ = 0;
    if(_V_ >= 0){
     var i = _U_;
     for(;;){
      var _W_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _W_);
      ensure_no_mutation(t, num_mutations);
      var _X_ = i + 1 | 0;
      if(_V_ === i) break;
      var i = _X_;
     }
    }
    return r[1];
   }
   function foldi(t, init, f){
    var i = [0, 0];
    return fold
            (t,
             init,
             function(acc, a){
              var acc$0 = caml_call3(f, i[1], acc, a);
              i[1] = caml_call2(Base_Import[91], i[1], 1);
              return acc$0;
             });
   }
   function iter(t, f){
    var
     num_mutations = t[1],
     _S_ = caml_call2(Base_Import[93], t[4], 1),
     _R_ = 0;
    if(_S_ >= 0){
     var i = _R_;
     for(;;){
      caml_call1(f, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _T_ = i + 1 | 0;
      if(_S_ === i) break;
      var i = _T_;
     }
    }
    return 0;
   }
   function iteri(t, f){
    var
     num_mutations = t[1],
     _P_ = caml_call2(Base_Import[93], t[4], 1),
     _O_ = 0;
    if(_P_ >= 0){
     var i = _O_;
     for(;;){
      caml_call2(f, i, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _Q_ = i + 1 | 0;
      if(_P_ === i) break;
      var i = _Q_;
     }
    }
    return 0;
   }
   function to_list(t){
    var result = [0, 0], _L_ = caml_call2(Base_Import[93], t[4], 1);
    if(_L_ >= 0){
     var i = _L_;
     for(;;){
      var _M_ = result[1];
      result[1] = [0, unsafe_get(t, i), _M_];
      var _N_ = i - 1 | 0;
      if(0 === i) break;
      var i = _N_;
     }
    }
    return result[1];
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    foldi$0 = [0, -198771759, foldi],
    iteri$0 = [0, -198771759, iteri],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, iteri$0, foldi$0]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    for_alli = C[21];
   function concat_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       function _J_(b){return enqueue(t_result, b);}
       var _K_ = caml_call1(f, a);
       return caml_call2(Base_List[19], _K_, _J_);
      });
    return t_result;
   }
   function concat_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       function _H_(b){return enqueue(t_result, b);}
       var _I_ = caml_call2(f, i, a);
       return caml_call2(Base_List[19], _I_, _H_);
      });
    return t_result;
   }
   function filter_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var _G_ = caml_call1(f, a);
       return _G_ ? enqueue(t_result, a) : _G_;
      });
    return t_result;
   }
   function filteri(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var _F_ = caml_call2(f, i, a);
       return _F_ ? enqueue(t_result, a) : _F_;
      });
    return t_result;
   }
   function filter_inplace(t, f){
    var t2 = filter(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function filteri_inplace(t, f){
    var t2 = filteri(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function copy(src){
    var dst = create([0, src[4]], 0);
    blit_to_array(src, dst[5]);
    dst[4] = src[4];
    return dst;
   }
   function of_list(l){
    var t = create([0, caml_call1(Base_List[45], l)], 0);
    function _E_(x){return enqueue(t, x);}
    caml_call2(Base_List[19], l, _E_);
    return t;
   }
   function init(len, f){
    if(len < 0){
     var
      _y_ = [0, [0, cst_length$1, caml_call1(Base_Int[10], len)], 0],
      _z_ = caml_call2(Base_Sexp[10], cst_Queue_init_negative_length, _y_);
     caml_call1(Base_Error[32], _z_);
    }
    var t = create([0, len], 0);
    if(len > caml_call1(Base_Option_array[28], t[5]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var _B_ = caml_call2(Base_Import[93], len, 1), _A_ = 0;
    if(_B_ >= 0){
     var i = _A_;
     for(;;){
      var _C_ = caml_call1(f, i);
      caml_call3(Base_Option_array[51], t[5], i, _C_);
      var _D_ = i + 1 | 0;
      if(_B_ === i) break;
      var i = _D_;
     }
    }
    t[4] = len;
    return t;
   }
   function of_array(a){
    return init(a.length - 1, function(_x_){return a[1 + _x_];});
   }
   function to_array(t){
    function _w_(i){return unsafe_get(t, i);}
    return caml_call2(Base_Array[41], t[4], _w_);
   }
   function map(ta, f){
    var num_mutations = ta[1], tb = create([0, ta[4]], 0);
    tb[4] = ta[4];
    var _u_ = caml_call2(Base_Import[93], ta[4], 1), _t_ = 0;
    if(_u_ >= 0){
     var i = _t_;
     for(;;){
      var b = caml_call1(f, unsafe_get(ta, i));
      ensure_no_mutation(ta, num_mutations);
      caml_call3(Base_Option_array[51], tb[5], i, b);
      var _v_ = i + 1 | 0;
      if(_u_ === i) break;
      var i = _v_;
     }
    }
    return tb;
   }
   function mapi(t, f){
    var i = [0, 0];
    return map
            (t,
             function(a){
              var result = caml_call2(f, i[1], a);
              i[1] = caml_call2(Base_Import[91], i[1], 1);
              return result;
             });
   }
   function singleton(x){var t = create(_q_, 0); enqueue(t, x); return t;}
   function sexp_of_t(sexp_of_a, t){
    var _s_ = to_list(t);
    return caml_call1(caml_call1(Base_List[6], sexp_of_a), _s_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[5], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _r_ = caml_call1(Base_List[7], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _r_);
   }
   function start(q){return q[1];}
   function assert_no_mutation_since_start(t, q){return ensure_no_mutation(q, t);
   }
   var
    Iteration = [0, start, assert_no_mutation_since_start],
    Base_Queue =
      [0,
       compare,
       compare_local,
       globalize,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       dequeue_and_ignore_exn,
       drain,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       equal,
       equal_local,
       invariant,
       create,
       last,
       last_exn,
       enqueue_front,
       dequeue_back,
       dequeue_back_exn,
       peek_back,
       peek_back_exn,
       blit_transfer,
       get,
       set,
       capacity,
       set_capacity,
       Iteration];
   runtime.caml_register_global(39, Base_Queue, "Base__Queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nothing
//# unitInfo: Requires: Base__Identifiable, Base__Import, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [4, 0],
    module_name = "Base.Nothing",
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Match_failure = global_data.Match_failure,
    Base_Identifiable = global_data.Base__Identifiable,
    cst_Base_Nothing_of_string_not = "Base.Nothing.of_string: not supported",
    cst_Base_Nothing_t = "Base.Nothing.t",
    _a_ = [0, "src/nothing.ml", 6, 31];
   function unreachable_code_local(param){
    throw caml_maybe_attach_backtrace([0, Match_failure, _a_], 1);
   }
   function unreachable_code(x){return unreachable_code_local(x);}
   var all = 0;
   function hash_fold_t(param, t){return unreachable_code(t);}
   function compare(a, param){return unreachable_code(a);}
   function compare_local(a, param){return unreachable_code(a);}
   function equal_local(a, param){return unreachable_code(a);}
   function t_of_sexp(sexp){
    return caml_call2(Sexplib0_Sexp_conv_error[30], cst_Base_Nothing_t, sexp);
   }
   function of_string(param){
    return caml_call1(Base_Import[124], cst_Base_Nothing_of_string_not);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         unreachable_code,
         t_of_sexp,
         unreachable_code,
         of_string,
         unreachable_code,
         module_name]),
    hash_fold_t$0 = include[1],
    hash = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t = include[4],
    of_string$0 = include[5],
    to_string = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24];
   function must_be_none(param){return 0;}
   function must_be_empty(param){return 0;}
   function must_be_ok(param){var ok = param[1]; return ok;}
   function must_be_error(param){var error = param[1]; return error;}
   function must_be_first(param){var first = param[1]; return first;}
   function must_be_second(param){var second = param[1]; return second;}
   var
    Base_Nothing =
      [0,
       all,
       unreachable_code,
       t_sexp_grammar,
       unreachable_code,
       unreachable_code_local,
       hash_fold_t$0,
       hash,
       t_of_sexp$0,
       sexp_of_t,
       of_string$0,
       to_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       equal_local,
       compare_local,
       must_be_none,
       must_be_empty,
       must_be_ok,
       must_be_error,
       must_be_first,
       must_be_second];
   runtime.caml_register_global(9, Base_Nothing, "Base__Nothing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nativeint
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Word_size, Stdlib__Nativeint, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_nx = "%nx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_lessequal = runtime.caml_lessequal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Nativeint.Hex",
    module_name$0 = "Base.Nativeint",
    Base_Int_math = global_data.Base__Int_math,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Printf = global_data.Base__Printf,
    Base_Float0 = global_data.Base__Float0,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Word_size = global_data.Base__Word_size,
    Base_Error = global_data.Base__Error,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    include = Base_Import[104],
    compare = include[9],
    globalize = Base_Import[287],
    hash_fold_t = Base_Import[202],
    func = Base_Import[216],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _f_ = [0, "src/nativeint.ml", 206, 2],
    cst_Nativeint_ceil_log2_got_in = "[Nativeint.ceil_log2] got invalid input",
    cst_Nativeint_floor_log2_got_i =
      "[Nativeint.floor_log2] got invalid input",
    _e_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    _d_ =
      [0,
       [11,
        "Nativeint.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Nativeint.of_float: argument (%f) is out of range or NaN"],
    _c_ = [0, [6, 6, 0, 0, 0], cst_nx],
    _b_ = [0, [6, 6, 0, 0, 0], cst_nx];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[167],
    sexp_of_t = Base_Import[143],
    t_sexp_grammar = Base_Import[189],
    hashable = [0, hash, compare, sexp_of_t],
    compare$0 = Base_Import[104][9],
    to_string = Stdlib_Nativeint[15],
    of_string = runtime.caml_int_of_string,
    of_string_opt = Stdlib_Nativeint[14],
    comparator = caml_call1(Base_Comparator[7], [0, compare$0, sexp_of_t])[1],
    zero = Stdlib_Nativeint[1],
    _a_ = caml_call1(Base_Comparable[14], [0, compare$0, sexp_of_t, zero]),
    is_positive = _a_[1],
    is_non_negative = _a_[2],
    is_negative = _a_[3],
    is_non_positive = _a_[4],
    sign = _a_[5],
    include$0 = caml_call1(Base_Int_string_conversions[1], [0, to_string]),
    to_string_hum = include$0[1],
    sexp_of_t$0 = include$0[2],
    compare_local = Base_Import[259];
   function compare$1(a, b){return caml_call2(compare_local, a, b);}
   var hash_fold_t$0 = Base_Import[202], func$0 = Base_Import[216];
   function hash$0(x){return caml_call1(func$0, x);}
   var zero$0 = Stdlib_Nativeint[1];
   function neg(___){return - ___ | 0;}
   var symbol = Base_Import[104][1];
   function to_string$0(i){return caml_call2(Base_Printf[2], _b_, i);}
   function of_string$0(s){
    function _Y_(_Z_){return _Z_;}
    return caml_call3(Stdlib_Scanf[5], s, _c_, _Y_);
   }
   var
    include$1 =
      caml_call1
       (Base_Int_string_conversions[2],
        [0,
         compare$1,
         compare_local,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero$0,
         symbol,
         neg,
         module_name]),
    Hex = include$1[1],
    include$2 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$2[1];
   function invariant(param){return 0;}
   var
    num_bits = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    float_lower_bound = caml_call1(Base_Float0[26], num_bits),
    float_upper_bound = caml_call1(Base_Float0[24], num_bits);
   function shift_right_logical(_X_, _W_){return _X_ >>> _W_ | 0;}
   function shift_right(_V_, _U_){return _V_ >> _U_;}
   function shift_left(_T_, _S_){return _T_ << _S_;}
   var bit_not = Stdlib_Nativeint[12];
   function bit_xor(_R_, _Q_){return _R_ ^ _Q_;}
   function bit_or(_P_, _O_){return _P_ | _O_;}
   function bit_and(_N_, _M_){return _N_ & _M_;}
   var
    min_value = Stdlib_Nativeint[11],
    max_value = Stdlib_Nativeint[10],
    abs = Stdlib_Nativeint[8],
    pred = Stdlib_Nativeint[7],
    succ = Stdlib_Nativeint[6],
    rem = runtime.caml_mod;
   function symbol$0(_L_){return - _L_ | 0;}
   var
    minus_one = Stdlib_Nativeint[3],
    one = Stdlib_Nativeint[2],
    zero$1 = Stdlib_Nativeint[1];
   function to_float(_K_){return _K_;}
   function of_float_unchecked(_J_){return _J_ | 0;}
   function of_float(f){
    if(float_lower_bound <= f && f <= float_upper_bound) return f | 0;
    var _I_ = caml_call1(Base_Float0[29], f);
    return caml_call3(Base_Printf[7], _d_, _I_, 0);
   }
   var raise_s = Base_Error[32];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _e_, 0);
   }
   function lsr(_H_, _G_){return _H_ >>> _G_ | 0;}
   function land(_F_, _E_){return _F_ & _E_;}
   function ceil_pow2(x){
    if(caml_call2(Base_Import[104][2], x, 0)) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Nativeint[7], x),
     x$1 = x$0 | x$0 >>> 1 | 0,
     x$2 = x$1 | x$1 >>> 2 | 0,
     x$3 = x$2 | x$2 >>> 4 | 0,
     x$4 = x$3 | x$3 >>> 8 | 0,
     x$5 = x$4 | x$4 >>> 16 | 0,
     x$6 = x$5 | x$5 >>> 32 | 0;
    return caml_call1(Stdlib_Nativeint[6], x$6);
   }
   function floor_pow2(x){
    if(caml_call2(Base_Import[104][2], x, 0)) non_positive_argument(0);
    var
     x$0 = x | x >>> 1 | 0,
     x$1 = x$0 | x$0 >>> 2 | 0,
     x$2 = x$1 | x$1 >>> 4 | 0,
     x$3 = x$2 | x$2 >>> 8 | 0,
     x$4 = x$3 | x$3 >>> 16 | 0,
     x$5 = x$4 | x$4 >>> 32 | 0;
    return x$5 - (x$5 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[104][2], x, 0)) non_positive_argument(0);
    var _D_ = x & caml_call1(Stdlib_Nativeint[7], x);
    return caml_call2(Base_Import[104][4], _D_, 0);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _A_ = [0, [0, cst, caml_call1(Base_Import[143], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Nativeint_floor_log2_got_i, _A_));
    }
    var
     _B_ = runtime.Base_int_math_nativeint_clz(i),
     _C_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _C_, _B_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _y_ = [0, [0, cst$0, caml_call1(Base_Import[143], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Nativeint_ceil_log2_got_in, _y_));
    }
    if(caml_call2(Stdlib_Nativeint[18], i, Stdlib_Nativeint[2])) return 0;
    var
     _z_ =
       runtime.Base_int_math_nativeint_clz(caml_call1(Stdlib_Nativeint[7], i));
    return caml_call2(Base_Import[93], num_bits, _z_);
   }
   function between(t, low, high){
    var _x_ = caml_call2(Base_Import[104][2], low, t);
    return _x_ ? caml_call2(Base_Import[104][2], t, high) : _x_;
   }
   function clamp_unchecked(t, min, max){
    var _w_ = caml_call2(Base_Import[104][14], t, max);
    return caml_call1(caml_call1(Base_Import[104][13], min), _w_);
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[104][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[104][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _t_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _u_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _t_],
     _v_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _u_);
    return caml_call1(Base_Or_error[39], _v_);
   }
   var symbol$1 = runtime.caml_div, symbol$2 = runtime.caml_mul;
   function symbol$3(_s_, _r_){return _s_ - _r_ | 0;}
   function symbol$4(_q_, _p_){return _q_ + _p_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_nativeint(t){return t;}
   function to_nativeint(t){return t;}
   var
    popcount = Base_Popcount[4],
    of_int_exn = Base_Int_conversions[5],
    to_int = Base_Int_conversions[23],
    to_int_exn = Base_Int_conversions[24],
    to_int_trunc = Base_Int_conversions[25],
    of_int32 = Base_Int_conversions[10],
    to_int32 = Base_Int_conversions[26],
    to_int32_exn = Base_Int_conversions[27],
    of_int64 = Base_Int_conversions[18],
    of_int64_exn = Base_Int_conversions[19],
    of_int64_trunc = Base_Int_conversions[20],
    to_int64 = Base_Int_conversions[29];
   function pow(b, e){
    var _n_ = caml_call1(to_int_exn, e), _o_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _o_, _n_));
   }
   function symbol$5(b, e){return pow(b, e);}
   var compare_local$0 = Base_Import[259];
   function compare$2(a, b){return caml_call2(compare_local$0, a, b);}
   var equal_local = Base_Import[273];
   function equal(a, b){return caml_call2(equal_local, a, b);}
   var hash_fold_t$1 = Base_Import[202], func$1 = Base_Import[216];
   function hash$1(x){return caml_call1(func$1, x);}
   function clz(_m_){return runtime.Base_int_math_nativeint_clz(_m_);}
   var
    Binary =
      caml_call1
        (Base_Int_string_conversions[3],
         [0,
          compare$2,
          compare_local$0,
          equal,
          equal_local,
          hash_fold_t$1,
          hash$1,
          clz,
          lsr,
          land,
          to_int_exn,
          num_bits,
          one,
          zero$1])
       [1],
    _g_ = Base_Import[104],
    symbol$6 = _g_[3],
    symbol$7 = _g_[1],
    symbol$8 = _g_[5],
    symbol$9 = _g_[4],
    symbol$10 = _g_[2],
    symbol$11 = _g_[6],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$4,
         symbol$3,
         symbol$2,
         symbol$1,
         symbol$0,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$0,
         zero$1,
         of_int_exn,
         rem]),
    symbol$12 = include$3[1],
    symbol$13 = include$3[2],
    symbol$14 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    include$4 = Base_Import[104],
    symbol$15 = include$4[1],
    symbol$16 = include$4[2],
    symbol$17 = include$4[3],
    symbol$18 = include$4[4],
    symbol$19 = include$4[5],
    symbol$20 = include$4[6],
    ascending = include$4[7],
    descending = include$4[8],
    compare$3 = include$4[9],
    compare_local$1 = include$4[10],
    equal$0 = include$4[11],
    equal_local$0 = include$4[12],
    max = include$4[13],
    min = include$4[14],
    _h_ = runtime.caml_int32_bswap,
    _i_ =
      [0,
       symbol$4,
       symbol$3,
       symbol$2,
       symbol$1,
       symbol$0,
       symbol$5,
       symbol$11,
       symbol$10,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$6,
       abs,
       symbol$0,
       zero$1,
       symbol$12,
       symbol$13,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       shift_right_logical];
   function _j_(_l_){return runtime.Base_int_math_nativeint_ctz(_l_);}
   var
    Base_Nativeint =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$20,
       symbol$16,
       symbol$18,
       symbol$19,
       symbol$15,
       symbol$17,
       equal$0,
       compare$3,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       compare_local$1,
       equal_local$0,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       zero$1,
       one,
       minus_one,
       symbol$4,
       symbol$3,
       symbol$2,
       symbol$5,
       symbol$0,
       symbol$0,
       symbol$13,
       symbol$12,
       symbol$1,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_k_){return runtime.Base_int_math_nativeint_clz(_k_);},
       _j_,
       _i_,
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       to_int_trunc,
       of_int64_trunc,
       _h_];
   runtime.caml_register_global(35, Base_Nativeint, "Base__Nativeint");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map
//# unitInfo: Requires: Base__Comparator, Base__Error, Base__Exn, Base__Import, Base__List0, Base__Map_intf, Base__Maybe_bound, Base__Option, Base__Or_error, Base__Result, Base__Sequence, Base__Sexp, Base__Uniform_array, Base__With_return, Sexplib0__Sexp_conv, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    cst_Map_of$1 = "Map.of_",
    cst_key$1 = "key",
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_map_ml = "src/map.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    name = "alist",
    name$0 = "sequence",
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Comparator = global_data.Base__Comparator,
    Base_Result = global_data.Base__Result,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Base_Import = global_data.Base__Import,
    Base_Exn = global_data.Base__Exn,
    Base_Sexp = global_data.Base__Sexp,
    Base_List0 = global_data.Base__List0,
    Assert_failure = global_data.Assert_failure,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Maybe_bound = global_data.Base__Maybe_bound,
    Base_Map_intf = global_data.Base__Map_intf,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Symmetric_diff_element = Base_Map_intf[5],
    include = Base_Map_intf[8],
    compare = include[1],
    all = include[2],
    equal = include[3],
    sexp_of_t = include[4],
    _x_ = [1, 0],
    _y_ = [1, 0],
    _z_ = [1, 0],
    _w_ = [0, "_"],
    _v_ = [0, "Map.Build_increasing.add: non-increasing key"],
    _h_ = [0, 0, 0, 0],
    cst_Map_remove_min_elt = "Map.remove_min_elt",
    _s_ = [0, 0],
    cst_key$0 = cst_key$1,
    cst_Map_map_keys_exn_duplicate = "Map.map_keys_exn: duplicate key",
    cst_Map_t_of_sexp_direct_dupli = "Map.t_of_sexp_direct: duplicate key",
    _u_ = [0, cst_src_map_ml, 1967, 6],
    cst_Map_of_iteri_exn_duplicate = "Map.of_iteri_exn: duplicate key",
    _t_ = [0, 0],
    cst_Map_merge_disjoint_exn_dup = "Map.merge_disjoint_exn: duplicate key",
    cst_Map_of_list_with_key_exn_d = "Map.of_list_with_key_exn: duplicate key",
    cst_Map_of_list_with_key_or_er =
      "Map.of_list_with_key_or_error: duplicate key",
    cst_exn_duplicate_key = "_exn: duplicate key",
    cst_Map_of$0 = cst_Map_of$1,
    cst_or_error_duplicate_key = "_or_error: duplicate key",
    cst_Map_of = cst_Map_of$1,
    _r_ = [0, cst_src_map_ml, 1145, 17],
    _q_ = [0, 0, 0],
    _o_ = [0, "map.ml.Tree0.Map_max_elt_exn_of_empty_map"],
    _p_ = [0, cst_src_map_ml, 677, 13],
    _l_ = [0, "map.ml.Tree0.Map_min_elt_exn_of_empty_map"],
    _m_ = [0, cst_src_map_ml, 664, 13],
    _j_ = [0, "Map.find_exn: not found"],
    _i_ = [0, cst_src_map_ml, 578, 4],
    cst_of_increasing_sequence_non =
      "of_increasing_sequence: non-increasing key",
    _g_ = [0, cst_src_map_ml, 480, 21],
    _f_ = [1, 0],
    cst_key = cst_key$1,
    cst_Map_add_exn_got_key_alread = "[Map.add_exn] got key already present",
    cst_Map_bal = cst_Map_bal$3,
    _d_ = [0, cst_src_map_ml, 248, 18],
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    _e_ = [0, cst_src_map_ml, 263, 18],
    cst_Map_bal$2 = cst_Map_bal$3,
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    _b_ = [0, "map.ml.Duplicate"],
    _c_ = [0, cst_src_map_ml, 67, 11],
    cst_Base_Map_Duplicate = "Base__Map.Duplicate",
    cst_Base_Map_Tree0_Map_min_elt =
      "Base__Map.Tree0.Map_min_elt_exn_of_empty_map",
    cst_Base_Map_Tree0_Map_max_elt =
      "Base__Map.Tree0.Map_max_elt_exn_of_empty_map";
   function of_continue_or_stop(_dV_){return _dV_;}
   function to_continue_or_stop(_dU_){return _dU_;}
   var
    Finished_or_unfinished =
      [0,
       compare,
       all,
       equal,
       sexp_of_t,
       of_continue_or_stop,
       to_continue_or_stop],
    include$0 = Base_Map_intf[6],
    compare$0 = include$0[1],
    equal$0 = include$0[2],
    sexp_of_t$0 = include$0[3];
   function left(param){
    var _dT_ = param[1];
    if(737457313 === _dT_)
     var left = param[2][1];
    else{if(847852583 > _dT_) return 0; var left = param[2];}
    return [0, left];
   }
   function right(param){
    var _dS_ = param[1];
    if(737457313 === _dS_)
     var right = param[2][2];
    else{if(847852583 <= _dS_) return 0; var right = param[2];}
    return [0, right];
   }
   function left_value(t, default$0){
    var _dR_ = t[1];
    if(737457313 === _dR_)
     var left = t[2][1];
    else{if(847852583 > _dR_) return default$0; var left = t[2];}
    return left;
   }
   function right_value(t, default$0){
    var _dQ_ = t[1];
    if(737457313 === _dQ_)
     var right = t[2][2];
    else{if(847852583 <= _dQ_) return default$0; var right = t[2];}
    return right;
   }
   function values(t, left_default, right_default){
    var _dP_ = t[1];
    if(737457313 === _dP_){
     var match = t[2], right = match[2], left = match[1];
     return [0, left, right];
    }
    if(847852583 <= _dP_){
     var left$0 = t[2];
     return [0, left$0, right_default];
    }
    var right$0 = t[2];
    return [0, left_default, right$0];
   }
   var
    Merge_element =
      [0,
       compare$0,
       equal$0,
       sexp_of_t$0,
       left,
       right,
       left_value,
       right_value,
       values],
    with_return = Base_With_return[1],
    Duplicate = [248, cst_Base_Map_Duplicate, caml_fresh_oo_id(0)];
   function _a_(param){
    if(param === Duplicate) return _b_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   caml_call4(Sexplib0_Sexp_conv[72][1], 0, 0, Duplicate, _a_);
   function globalize(param){
    var length = param[2], tree = param[1];
    return [0, tree, length];
   }
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[5];
    return h;
   }
   function in_range(lower, upper, compare_key, k){
    if(lower)
     var
      lower$0 = lower[1],
      _dN_ = caml_call2(compare_key, lower$0, k) < 0 ? 1 : 0;
    else
     var _dN_ = 1;
    if(_dN_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_key, k, upper$0) < 0 ? 1 : 0;
     }
     var _dO_ = 1;
    }
    else
     var _dO_ = _dN_;
    return _dO_;
   }
   function loop(lower, upper, compare_key, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var k = t$0[1];
      return in_range(lower$0, upper, compare_key, k);
     }
     var
      h = t$0[5],
      r = t$0[4],
      k$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _dG_ = caml_call2(Base_Import[93], hl, hr),
      _dH_ = caml_call1(Base_Import[123], _dG_) <= 2 ? 1 : 0;
     if(_dH_){
      var
       _dI_ = caml_call2(Base_Import[100], hl, hr),
       _dJ_ = h === caml_call2(Base_Import[91], _dI_, 1) ? 1 : 0;
      if(_dJ_){
       var _dK_ = in_range(lower$0, upper, compare_key, k$0);
       if(_dK_){
        var _dL_ = loop(lower$0, [0, k$0], compare_key, l);
        if(_dL_){
         var lower$1 = [0, k$0], lower$0 = lower$1, t$0 = r;
         continue;
        }
        var _dM_ = _dL_;
       }
       else
        var _dM_ = _dK_;
      }
      else
       var _dM_ = _dJ_;
     }
     else
      var _dM_ = _dH_;
     return _dM_;
    }
   }
   function invariants(t, compare_key){return loop(0, 0, compare_key, t);}
   function create_with_heights(hl, hr, l, x, d, r){
    if(0 === hl && 0 === hr) return [0, x, d];
    var
     _dF_ =
       hr <= hl
        ? caml_call2(Base_Import[91], hl, 1)
        : caml_call2(Base_Import[91], hr, 1);
    return [1, l, x, d, r, _dF_];
   }
   function create(l, x, d, r){
    var _dE_ = height(r);
    return create_with_heights(height(l), _dE_, l, x, d, r);
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var match$0 = caml_call1(f, i), v$0 = match$0[2], k$0 = match$0[1];
         return [0, k$0, v$0];
        case 2:
         var
          match$1 = caml_call1(f, i),
          vl = match$1[2],
          kl = match$1[1],
          match$2 = caml_call1(f, caml_call2(Base_Import[91], i, 1)),
          v$1 = match$2[2],
          k$1 = match$2[1];
         return [1, [0, kl, vl], k$1, v$1, 0, 2];
        default:
         var
          match$3 = caml_call1(f, i),
          vl$0 = match$3[2],
          kl$0 = match$3[1],
          match$4 = caml_call1(f, caml_call2(Base_Import[91], i, 1)),
          v$2 = match$4[2],
          k$2 = match$4[1],
          match$5 = caml_call1(f, caml_call2(Base_Import[91], i, 2)),
          vr = match$5[2],
          kr = match$5[1];
         return [1, [0, kl$0, vl$0], k$2, v$2, [0, kr, vr], 2];
      }
     var
      left_length = caml_call2(Base_Import[120], n, 1),
      _dC_ = caml_call2(Base_Import[93], n, left_length),
      right_length = caml_call2(Base_Import[93], _dC_, 1),
      left = loop(left_length, f, i),
      match = caml_call1(f, caml_call2(Base_Import[91], i, left_length)),
      v = match[2],
      k = match[1],
      _dD_ = caml_call2(Base_Import[91], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[91], _dD_, 1));
     return create(left, k, v, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_key){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var
       k0 = caml_check_bound(array, 0)[1][1],
       k1 = caml_check_bound(array, 1)[2][1];
      if(caml_call2(compare_key, k0, k1) >= 0){
       var
        next =
          function(i){
           var
            _dA_ = caml_call2(Base_Import[93], array_length, 1),
            _dB_ = caml_call2(Base_Import[93], _dA_, i);
           return caml_check_bound(array, _dB_)[1 + _dB_];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    }
    return [0,
            of_increasing_iterator_uncheck(array_length, next),
            array_length];
   }
   function of_sorted_array(array, compare_key){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _dq_ = caml_check_bound(array, 1)[2],
                _dr_ = caml_call1(Base_Import[125], _dq_),
                _ds_ = caml_check_bound(array, 0)[1],
                i =
                  caml_call2
                   (compare_key, caml_call1(Base_Import[125], _ds_), _dr_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[40], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _du_ = caml_call2(Base_Import[93], array.length - 1, 2),
                _dt_ = 1;
               if(_du_ >= 1){
                var i$0 = _dt_;
                for(;;){
                 var
                  _dv_ = caml_call2(Base_Import[91], i$0, 1),
                  _dw_ = caml_check_bound(array, _dv_)[1 + _dv_],
                  _dx_ = caml_call1(Base_Import[125], _dw_),
                  _dy_ = caml_check_bound(array, i$0)[1 + i$0],
                  i$1 =
                    caml_call2
                     (compare_key, caml_call1(Base_Import[125], _dy_), _dx_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[40], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[40], cst_of_sorted_array_elements_a));
                 var _dz_ = i$0 + 1 | 0;
                 if(_du_ === i$0) break;
                 var i$0 = _dz_;
                }
               }
               return [0,
                       globalize(of_sorted_array_unchecked(array, compare_key))];
              });
    return [0, globalize(of_sorted_array_unchecked(array, compare_key))];
   }
   function bal(l, x, d, r){
    var hl = height(l), hr = height(r);
    if(caml_call2(Base_Import[91], hr, 2) < hl){
     if(typeof l === "number")
      return caml_call1(Base_Import[126], cst_Map_bal);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _dk_ = height(lr);
     if(_dk_ <= height(ll)) return create(ll, lv, ld, create(lr, x, d, r));
     if(typeof lr === "number")
      return caml_call1(Base_Import[126], cst_Map_bal$0);
     if(0 === lr[0]){
      var lrd = lr[2], lrv = lr[1], _dl_ = create(0, x, d, r);
      return create(create(ll, lv, ld, 0), lrv, lrd, _dl_);
     }
     var
      lrr = lr[4],
      lrd$0 = lr[3],
      lrv$0 = lr[2],
      lrl = lr[1],
      _dm_ = create(lrr, x, d, r);
     return create(create(ll, lv, ld, lrl), lrv$0, lrd$0, _dm_);
    }
    if(caml_call2(Base_Import[91], hl, 2) >= hr)
     return create_with_heights(hl, hr, l, x, d, r);
    if(typeof r === "number")
     return caml_call1(Base_Import[126], cst_Map_bal$1);
    if(0 === r[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
    var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _dn_ = height(rl);
    if(_dn_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
    if(typeof rl === "number")
     return caml_call1(Base_Import[126], cst_Map_bal$2);
    if(0 === rl[0]){
     var rld = rl[2], rlv = rl[1], _do_ = create(0, rv, rd, rr);
     return create(create(l, x, d, 0), rlv, rld, _do_);
    }
    var
     rlr = rl[4],
     rld$0 = rl[3],
     rlv$0 = rl[2],
     rll = rl[1],
     _dp_ = create(rlr, rv, rd, rr);
    return create(create(l, x, d, rll), rlv$0, rld$0, _dp_);
   }
   var empty_without_value_restrictio = 0;
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function raise_key_already_present(key, sexp_of_key){
    var
     _di_ = [0, [0, cst_key, caml_call1(sexp_of_key, key)], 0],
     _dj_ = caml_call2(Base_Sexp[10], cst_Map_add_exn_got_key_alread, _di_);
    return caml_call1(Base_Error[32], _dj_);
   }
   function find_and_add_or_set
   (t, length, x, data, compare_key, sexp_of_key, add_or_set){
    if(typeof t === "number")
     return [0, [0, x, data], caml_call2(Base_Import[91], length, 1)];
    if(0 === t[0]){
     var d = t[2], v = t[1], c = caml_call2(compare_key, x, v);
     if(0 === c)
      switch(add_or_set){
        case 0:
         return caml_call1(Base_Exn[6], Duplicate);
        case 1:
         return raise_key_already_present(x, sexp_of_key);
        default: return [0, [0, x, data], length];
      }
     return 0 <= c
             ? [0,
               [1, 0, v, d, [0, x, data], 2],
               caml_call2(Base_Import[91], length, 1)]
             : [0,
               [1, [0, x, data], v, d, 0, 2],
               caml_call2(Base_Import[91], length, 1)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     c$0 = caml_call2(compare_key, x, v$0);
    if(0 === c$0)
     switch(add_or_set){
       case 0:
        return caml_call1(Base_Exn[6], Duplicate);
       case 1:
        return raise_key_already_present(x, sexp_of_key);
       default: return [0, [1, l, x, data, r, h], length];
     }
    if(0 <= c$0)
     var
      match =
        find_and_add_or_set
         (r, length, x, data, compare_key, sexp_of_key, add_or_set),
      length$0 = match[2],
      r$0 = match[1],
      length$1 = length$0,
      r$1 = r$0,
      l$0 = l;
    else
     var
      match$0 =
        find_and_add_or_set
         (l, length, x, data, compare_key, sexp_of_key, add_or_set),
      length$2 = match$0[2],
      l$1 = match$0[1],
      length$1 = length$2,
      r$1 = r,
      l$0 = l$1;
    return [0, bal(l$0, v$0, d$0, r$1), length$1];
   }
   function set_min(key, data, t){
    if(typeof t === "number") return [0, key, data];
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [1, [0, key, data], v, d, 0, 2];
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = set_min(key, data, l);
    return bal(l$0, v$0, d$0, r);
   }
   function set_max(t, key, data){
    if(typeof t === "number") return [0, key, data];
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [1, 0, v, d, [0, key, data], 2];
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     r$0 = set_max(r, key, data);
    return bal(l, v$0, d$0, r$0);
   }
   function add_exn(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 1);
   }
   function add_exn_internal(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 0);
   }
   function set(t, length, key, data, compare_key){
    var _dh_ = 2;
    return find_and_add_or_set
            (t,
             length,
             key,
             data,
             compare_key,
             function(param){return _f_;},
             _dh_);
   }
   var empty = 0;
   function max_key(param){
    if(! param) return 0;
    var key = param[1][1];
    return [0, key];
   }
   function add_unchecked(t, key, data){return [0, [0, key, data], t];}
   function to_tree_unchecked(list){
    if(! list) return 0;
    if(list[2]){
     var
      len = caml_call1(Base_List0[5], list),
      list$0 = [0, list],
      loop =
        function(len){
         var _c__ = list$0[1], switcher = len - 1 | 0;
         if(2 >= switcher >>> 0)
          switch(switcher){
            case 0:
             if(_c__){
              var
               tail$0 = _c__[2],
               match$0 = _c__[1],
               data = match$0[2],
               key = match$0[1];
              list$0[1] = tail$0;
              return [0, key, data];
             }
             break;
            case 1:
             if(_c__){
              var _db_ = _c__[2];
              if(_db_){
               var
                tail$1 = _db_[2],
                _dc_ = _db_[1],
                d1 = _dc_[2],
                k1 = _dc_[1],
                match$1 = _c__[1],
                d2 = match$1[2],
                k2 = match$1[1];
               list$0[1] = tail$1;
               return [1, 0, k1, d1, [0, k2, d2], 2];
              }
             }
             break;
            default:
             if(_c__){
              var _dd_ = _c__[2];
              if(_dd_){
               var _de_ = _dd_[2];
               if(_de_){
                var
                 tail$2 = _de_[2],
                 _df_ = _de_[1],
                 d1$0 = _df_[2],
                 k1$0 = _df_[1],
                 _dg_ = _dd_[1],
                 d2$0 = _dg_[2],
                 k2$0 = _dg_[1],
                 match$2 = _c__[1],
                 d3 = match$2[2],
                 k3 = match$2[1];
                list$0[1] = tail$2;
                return [1, [0, k1$0, d1$0], k2$0, d2$0, [0, k3, d3], 2];
               }
              }
             }
          }
         var
          nr = caml_call2(Base_Import[95], len, 2),
          _c$_ = caml_call2(Base_Import[93], len, nr),
          nl = caml_call2(Base_Import[93], _c$_, 1),
          r = loop(nr),
          _da_ = list$0[1];
         if(! _da_)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
         var tail = _da_[2], match = _da_[1], d = match[2], k = match[1];
         list$0[1] = tail;
         var l = loop(nl);
         return create(l, k, d, r);
        };
     return loop(len);
    }
    var match = list[1], data = match[2], key = match[1];
    return [0, key, data];
   }
   function of_increasing_sequence(seq, compare_key){
    return caml_call1
            (with_return,
             function(param){
              function _c7_(param$0, _c8_){
               var
                data = _c8_[2],
                key = _c8_[1],
                length = param$0[2],
                builder = param$0[1],
                match = max_key(builder);
               if(match){
                var prev_key = match[1];
                if(0 <= caml_call2(compare_key, prev_key, key))
                 return caml_call1
                         (param,
                          caml_call1
                           (Base_Or_error[40], cst_of_increasing_sequence_non));
               }
               var _c9_ = caml_call2(Base_Import[91], length, 1);
               return [0, add_unchecked(builder, key, data), _c9_];
              }
              var
               match = caml_call3(Base_Sequence[11], seq, [0, empty, 0], _c7_),
               length = match[2],
               builder = match[1];
              return [0, [0, to_tree_unchecked(builder), length]];
             });
   }
   function join(l, k, d, r){
    if(typeof l === "number") return set_min(k, d, r);
    if(1 === l[0]){
     var lh = l[5], lr = l[4], ld$0 = l[3], lk$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){
       var rd = r[2], rk = r[1];
       return set_max(set_max(l, k, d), rk, rd);
      }
      var rh = r[5], rr = r[4], rd$0 = r[3], rk$0 = r[2], rl = r[1];
      if(caml_call2(Base_Import[91], rh, 3) < lh)
       var r$0 = join(lr, k, d, r), d$0 = ld$0, k$0 = lk$0, l$0 = ll;
      else if(caml_call2(Base_Import[91], lh, 3) < rh)
       var r$0 = rr, d$0 = rd$0, k$0 = rk$0, l$0 = join(l, k, d, rl);
      else
       var r$0 = r, d$0 = d, k$0 = k, l$0 = l;
      return bal(l$0, k$0, d$0, r$0);
     }
    }
    if(typeof r === "number") return set_max(l, k, d);
    var ld = l[2], lk = l[1];
    return set_min(lk, ld, set_min(k, d, r));
   }
   function split_gen(t, x, compare_key){
    if(typeof t === "number") return _h_;
    if(0 === t[0]){
     var d = t[2], k = t[1], cmp = caml_call1(compare_key, k);
     return 0 === cmp
             ? [0, 0, [0, [0, k, d]], 0]
             : 0 <= cmp ? [0, t, 0, 0] : [0, 0, 0, t];
    }
    var
     r = t[4],
     d$0 = t[3],
     k$0 = t[2],
     l = t[1],
     cmp$0 = caml_call1(compare_key, k$0);
    if(0 === cmp$0) return [0, l, [0, [0, k$0, d$0]], r];
    if(0 <= cmp$0){
     var
      match = split_gen(r, x, compare_key),
      rr = match[3],
      maybe = match[2],
      rl = match[1];
     return [0, join(l, k$0, d$0, rl), maybe, rr];
    }
    var
     match$0 = split_gen(l, x, compare_key),
     lr = match$0[3],
     maybe$0 = match$0[2],
     ll = match$0[1];
    return [0, ll, maybe$0, join(lr, k$0, d$0, r)];
   }
   function split(t, x, compare_key){
    return split_gen(t, x, function(y){return caml_call2(compare_key, x, y);});
   }
   function split_and_reinsert_boundary(t, into, x, compare_key){
    var
     _c6_ =
       847852583 <= into
        ? function
         (y){
          var res = caml_call2(compare_key, x, y);
          return 0 === res ? 1 : res;
         }
        : function
         (y){
          var res = caml_call2(compare_key, x, y);
          return 0 === res ? -1 : res;
         },
     match = split_gen(t, x, _c6_),
     right = match[3],
     boundary_opt = match[2],
     left = match[1];
    if(caml_call1(Base_Option[52], boundary_opt)) return [0, left, right];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   }
   function split_range(t, lower_bound, upper_bound, compare_key){
    if
     (caml_call3(Base_Maybe_bound[10], lower_bound, upper_bound, compare_key))
     return [0,
             empty_without_value_restrictio,
             empty_without_value_restrictio,
             empty_without_value_restrictio];
    if(typeof lower_bound === "number")
     var mid_and_right = t, left = empty_without_value_restrictio;
    else if(0 === lower_bound[0])
     var
      lb$1 = lower_bound[1],
      _c4_ = split_and_reinsert_boundary(t, -57574468, lb$1, compare_key),
      mid_and_right = _c4_[2],
      left = _c4_[1];
    else
     var
      lb$2 = lower_bound[1],
      _c5_ = split_and_reinsert_boundary(t, 847852583, lb$2, compare_key),
      mid_and_right$0 = _c5_[2],
      left$0 = _c5_[1],
      mid_and_right = mid_and_right$0,
      left = left$0;
    if(typeof upper_bound === "number")
     var right = empty_without_value_restrictio, mid = mid_and_right;
    else if(0 === upper_bound[0])
     var
      lb = upper_bound[1],
      _c2_ =
        split_and_reinsert_boundary(mid_and_right, 847852583, lb, compare_key),
      right = _c2_[2],
      mid = _c2_[1];
    else
     var
      lb$0 = upper_bound[1],
      _c3_ =
        split_and_reinsert_boundary
         (mid_and_right, -57574468, lb$0, compare_key),
      right$0 = _c3_[2],
      mid$0 = _c3_[1],
      right = right$0,
      mid = mid$0;
    return [0, left, mid, right];
   }
   function find(t, x, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v) ? [0, d] : 0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return [0, d$0];
     var r$0 = 0 <= c ? r : l, t$0 = r$0;
    }
   }
   function add_multi(t, length, key, data, compare_key){
    var
     _c1_ = find(t, key, compare_key),
     data$0 = [0, data, caml_call2(Base_Option[30], _c1_, 0)];
    return set(t, length, key, data$0, compare_key);
   }
   function find_multi(t, x, compare_key){
    var match = find(t, x, compare_key);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function if_not_found(key, sexp_of_key){
    var _c0_ = [1, [0, _j_, [0, caml_call1(sexp_of_key, key), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[297], _c0_], 1);
   }
   function find_exn(t, x, compare_key, sexp_of_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return if_not_found(x, sexp_of_key);
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v)
              ? d
              : if_not_found(x, sexp_of_key);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return d$0;
     var r$0 = 0 <= c ? r : l, t$0 = r$0;
    }
   }
   function mem(t, x, compare_key){
    var _cZ_ = find(t, x, compare_key);
    return caml_call1(Base_Option[53], _cZ_);
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     var l = param$0[1];
     if(typeof l === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     var param$0 = l;
    }
   }
   var
    Map_min_elt_exn_of_empty_map =
      [248, cst_Base_Map_Tree0_Map_min_elt, caml_fresh_oo_id(0)];
   function _k_(param){
    if(param === Map_min_elt_exn_of_empty_map) return _l_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[72][1], 0, 0, Map_min_elt_exn_of_empty_map, _k_);
   var
    Map_max_elt_exn_of_empty_map =
      [248, cst_Base_Map_Tree0_Map_max_elt, caml_fresh_oo_id(0)];
   function _n_(param){
    if(param === Map_max_elt_exn_of_empty_map) return _o_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[72][1], 0, 0, Map_max_elt_exn_of_empty_map, _n_);
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_min_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     if(typeof param$0[4] === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     var r = param$0[4], param$0 = r;
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_max_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(t){
    if(typeof t === "number")
     return caml_call1(Base_Import[126], cst_Map_remove_min_elt);
    if(0 === t[0]) return 0;
    var l = t[1];
    if(typeof l === "number"){var r = t[4]; return r;}
    var r$0 = t[4], d = t[3], x = t[2];
    return bal(remove_min_elt(l), x, d, r$0);
   }
   function append(lower_part, upper_part, compare_key){
    var match = max_elt(lower_part), match$0 = min_elt(upper_part);
    if(! match) return [0, 17724, upper_part];
    if(! match$0) return [0, 17724, lower_part];
    var
     _cY_ = match$0[1],
     v = _cY_[2],
     min_upper = _cY_[1],
     max_lower = match[1][1];
    if(0 <= caml_call2(compare_key, max_lower, min_upper)) return 838882908;
    var upper_part_without_min = remove_min_elt(upper_part);
    return [0, 17724, join(lower_part, min_upper, v, upper_part_without_min)];
   }
   function go(t, min, max, init, f, compare_key){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 === t$0[0]){
      var d = t$0[2], k = t$0[1];
      if
       (0 <= caml_call2(compare_key, k, min)
        && 0 >= caml_call2(compare_key, k, max))
       return caml_call3(f, k, d, init$0);
      return init$0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      k$0 = t$0[2],
      l = t$0[1],
      c_min = caml_call2(compare_key, k$0, min);
     if(0 <= c_min)
      if(0 === c_min)
       var init$1 = caml_call3(f, k$0, d$0, init$0), t$0 = r, init$0 = init$1;
      else{
       var
        z = go(l, min, max, init$0, f, compare_key),
        c_max = caml_call2(compare_key, k$0, max);
       if(0 < c_max) return z;
       var init$2 = caml_call3(f, k$0, d$0, z);
       if(0 === c_max) return init$2;
       var t$0 = r, init$0 = init$2;
      }
     else
      var t$0 = r;
    }
   }
   function fold_range_inclusive(t, min, max, init, f, compare_key){
    return 0 < caml_call2(compare_key, min, max)
            ? init
            : go(t, min, max, init, f, compare_key);
   }
   function range_to_alist(t, min, max, compare_key){
    var
     _cX_ =
       fold_range_inclusive
        (t,
         min,
         max,
         0,
         function(key, data, l){return [0, [0, key, data], l];},
         compare_key);
    return caml_call1(Base_List0[19], _cX_);
   }
   function concat_unchecked(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var match = min_elt_exn(t2), d = match[2], x = match[1];
    return bal(t1, x, d, remove_min_elt(t2));
   }
   function concat_and_balance_unchecked(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var match = min_elt_exn(t2), d = match[2], x = match[1];
    return join(t1, x, d, remove_min_elt(t2));
   }
   function remove(t, x, length, compare_key){
    if(typeof t === "number") return [0, t, length];
    if(0 === t[0]){
     var v = t[1];
     return 0 === caml_call2(compare_key, x, v)
             ? [0, 0, caml_call2(Base_Import[93], length, 1)]
             : [0, t, length];
    }
    var
     r = t[4],
     d = t[3],
     v$0 = t[2],
     l = t[1],
     c = caml_call2(compare_key, x, v$0);
    if(0 === c){
     var _cW_ = caml_call2(Base_Import[93], length, 1);
     return [0, concat_unchecked(l, r), _cW_];
    }
    if(0 <= c)
     var
      match = remove(r, x, length, compare_key),
      length$0 = match[2],
      r$0 = match[1],
      length$1 = length$0,
      r$1 = r$0,
      l$0 = l;
    else
     var
      match$0 = remove(l, x, length, compare_key),
      length$2 = match$0[2],
      l$1 = match$0[1],
      length$1 = length$2,
      r$1 = r,
      l$0 = l$1;
    return length === length$1
            ? [0, t, length]
            : [0, bal(l$0, v$0, d, r$1), length$1];
   }
   function change(t, key, f, length, compare_key){
    if(typeof t === "number"){
     var match = caml_call1(f, 0);
     if(! match) return [0, 0, length];
     var data = match[1];
     return [0, [0, key, data], caml_call2(Base_Import[91], length, 1)];
    }
    if(0 === t[0]){
     var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
     if(0 === c){
      var match$0 = caml_call1(f, [0, d]);
      if(! match$0) return [0, 0, caml_call2(Base_Import[93], length, 1)];
      var d$0 = match$0[1];
      return [0, [0, v, d$0], length];
     }
     if(0 <= c){
      var
       match$1 = change(0, key, f, length, compare_key),
       length$0 = match$1[2],
       r = match$1[1];
      return r === t ? [0, t, length$0] : [0, bal(0, v, d, r), length$0];
     }
     var
      match$2 = change(0, key, f, length, compare_key),
      length$1 = match$2[2],
      l = match$2[1];
     return l === t ? [0, t, length$1] : [0, bal(l, v, d, 0), length$1];
    }
    var
     h = t[5],
     r$0 = t[4],
     d$1 = t[3],
     v$0 = t[2],
     l$0 = t[1],
     c$0 = caml_call2(compare_key, key, v$0);
    if(0 === c$0){
     var match$3 = caml_call1(f, [0, d$1]);
     if(match$3){
      var data$0 = match$3[1];
      return [0, [1, l$0, key, data$0, r$0, h], length];
     }
     var _cV_ = caml_call2(Base_Import[93], length, 1);
     return [0, concat_unchecked(l$0, r$0), _cV_];
    }
    if(0 <= c$0){
     var
      match$4 = change(r$0, key, f, length, compare_key),
      length$2 = match$4[2],
      r$1 = match$4[1];
     return r$1 === r$0
             ? [0, t, length$2]
             : [0, bal(l$0, v$0, d$1, r$1), length$2];
    }
    var
     match$5 = change(l$0, key, f, length, compare_key),
     length$3 = match$5[2],
     l$1 = match$5[1];
    return l$1 === l$0
            ? [0, t, length$3]
            : [0, bal(l$1, v$0, d$1, r$0), length$3];
   }
   function update(t, key, f, length, compare_key){
    if(typeof t === "number"){
     var data = caml_call1(f, 0);
     return [0, [0, key, data], caml_call2(Base_Import[91], length, 1)];
    }
    if(0 === t[0]){
     var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
     if(0 === c){
      var d$0 = caml_call1(f, [0, d]);
      return [0, [0, v, d$0], length];
     }
     if(0 <= c){
      var
       match = update(0, key, f, length, compare_key),
       length$0 = match[2],
       r = match[1];
      return [0, bal(0, v, d, r), length$0];
     }
     var
      match$0 = update(0, key, f, length, compare_key),
      length$1 = match$0[2],
      l = match$0[1];
     return [0, bal(l, v, d, 0), length$1];
    }
    var
     h = t[5],
     r$0 = t[4],
     d$1 = t[3],
     v$0 = t[2],
     l$0 = t[1],
     c$0 = caml_call2(compare_key, key, v$0);
    if(0 === c$0){
     var data$0 = caml_call1(f, [0, d$1]);
     return [0, [1, l$0, key, data$0, r$0, h], length];
    }
    if(0 <= c$0){
     var
      match$1 = update(r$0, key, f, length, compare_key),
      length$2 = match$1[2],
      r$1 = match$1[1];
     return [0, bal(l$0, v$0, d$1, r$1), length$2];
    }
    var
     match$2 = update(l$0, key, f, length, compare_key),
     length$3 = match$2[2],
     l$1 = match$2[1];
    return [0, bal(l$1, v$0, d$1, r$0), length$3];
   }
   function remove_multi(t, key, length, compare_key){
    return change
            (t,
             key,
             function(param){
              if(param){
               var _cU_ = param[1];
               if(_cU_){
                var non_empty_tail = _cU_[2];
                if(non_empty_tail) return [0, non_empty_tail];
               }
              }
              return 0;
             },
             length,
             compare_key);
   }
   function iter_keys(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[4], v$0 = t$0[2], l = t$0[1];
     iter_keys(l, f);
     caml_call1(f, v$0);
     var t$0 = r;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2]; return caml_call1(f, d);}
     var r = t$0[4], d$0 = t$0[3], l = t$0[1];
     iter(l, f);
     caml_call1(f, d$0);
     var t$0 = r;
    }
   }
   function iteri(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     iteri(l, f);
     caml_call2(f, v$0, d$0);
     var t$0 = r;
    }
   }
   function iteri_until_loop(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(iteri_until_loop(l, f)) return 1;
     if(caml_call2(f, v$0, d$0)) return 1;
     var t$0 = r;
    }
   }
   function iteri_until(t, f){
    var _cT_ = iteri_until_loop(t, f);
    return caml_call1(Finished_or_unfinished[5], _cT_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var d = t[2], v = t[1]; return [0, v, caml_call1(f, d)];}
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = map(l, f),
     d$1 = caml_call1(f, d$0),
     r$0 = map(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function mapi(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [0, v, caml_call2(f, v, d)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = mapi(l, f),
     d$1 = caml_call2(f, v$0, d$0),
     r$0 = mapi(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function fold(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold(l, accu$0, f)),
      t$0 = r,
      accu$0 = accu$1;
    }
   }
   function fold_until(t, init, f, finish){
    function fold_until_loop(t, acc, f){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var d = t$0[2], v = t$0[1];
       return caml_call3(f, v, d, acc$0);
      }
      var
       r = t$0[4],
       d$0 = t$0[3],
       v$0 = t$0[2],
       l = t$0[1],
       match = fold_until_loop(l, acc$0, f);
      if(0 !== match[0]){var final$1 = match[1]; return [1, final$1];}
      var acc$1 = match[1], match$0 = caml_call3(f, v$0, d$0, acc$1);
      if(0 !== match$0[0]){var final$0 = match$0[1]; return [1, final$0];}
      var acc$2 = match$0[1], t$0 = r, acc$0 = acc$2;
     }
    }
    var match = fold_until_loop(t, init, f);
    if(0 === match[0]){var acc = match[1]; return caml_call1(finish, acc);}
    var stop = match[1];
    return stop;
   }
   function fold_right(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold_right(r, accu$0, f)),
      t$0 = l,
      accu$0 = accu$1;
    }
   }
   function filter_mapi(t, f, len){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1], match = caml_call2(f, v, d);
     if(match){var new_data = match[1]; return [0, v, new_data];}
     len[1] += -1;
     return 0;
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = filter_mapi(l, f, len),
     new_data$0 = caml_call2(f, v$0, d$0),
     r$0 = filter_mapi(r, f, len);
    if(new_data$0){
     var new_data$1 = new_data$0[1];
     return join(l$0, v$0, new_data$1, r$0);
    }
    len[1] += -1;
    return concat_and_balance_unchecked(l$0, r$0);
   }
   function filteri(t, f, len){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return caml_call2(f, v, d) ? t : (len[1] += -1, 0);
    }
    var
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = filteri(l, f, len),
     keep_data = caml_call2(f, v$0, d$0),
     r$0 = filteri(r, f, len);
    if(l === l$0 && keep_data && r === r$0) return t;
    return keep_data
            ? join(l$0, v$0, d$0, r$0)
            : (len[1] += -1, concat_and_balance_unchecked(l$0, r$0));
   }
   function filter(t, f, len){
    return filteri(t, function(param, data){return caml_call1(f, data);}, len);
   }
   function filter_keys(t, f, len){
    return filteri(t, function(key, param){return caml_call1(f, key);}, len);
   }
   function filter_map(t, f, len){
    return filter_mapi
            (t, function(param, data){return caml_call1(f, data);}, len);
   }
   function partition_mapi(t, f){
    var
     match =
       fold
        (t,
         [0, empty, empty],
         function(key, data, param){
          var t2 = param[2], t1 = param[1], match = caml_call2(f, key, data);
          if(0 === match[0]){
           var x = match[1];
           return [0, add_unchecked(t1, key, x), t2];
          }
          var y = match[1];
          return [0, t1, add_unchecked(t2, key, y)];
         }),
     t2 = match[2],
     t1 = match[1],
     _cS_ = to_tree_unchecked(t2);
    return [0, to_tree_unchecked(t1), _cS_];
   }
   function partition_map(t, f){
    return partition_mapi
            (t, function(param, data){return caml_call1(f, data);});
   }
   function partitioni_tf(t, f){
    function loop(t, f){
     if(typeof t === "number") return _q_;
     if(0 === t[0]){
      var d = t[2], v = t[1];
      return caml_call2(f, v, d) ? [0, t, 0] : [0, 0, t];
     }
     var
      r = t[4],
      d$0 = t[3],
      v$0 = t[2],
      l = t[1],
      match = loop(l, f),
      l_f = match[2],
      l_t = match[1],
      keep_data_t = caml_call2(f, v$0, d$0),
      match$0 = loop(r, f),
      r_f = match$0[2],
      r_t = match$0[1];
     function mk(l$0, keep_data, r$0){
      if(l === l$0 && keep_data && r === r$0) return t;
      return keep_data
              ? join(l$0, v$0, d$0, r$0)
              : concat_and_balance_unchecked(l$0, r$0);
     }
     var _cR_ = mk(l_f, 1 - keep_data_t, r_f);
     return [0, mk(l_t, keep_data_t, r_t), _cR_];
    }
    return loop(t, f);
   }
   function partition_tf(t, f){
    return partitioni_tf
            (t, function(param, data){return caml_call1(f, data);});
   }
   function cons(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, r, e$0],
      t$0 = l,
      e$0 = e$1;
    }
   }
   function cons_right(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, l, e$0],
      t$0 = r,
      e$0 = e$1;
    }
   }
   function of_tree(tree){return cons(tree, 0);}
   function step_deeper_exn(tree, e){
    if(typeof tree === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
    if(0 === tree[0]){
     var d = tree[2], v = tree[1];
     return [0, 0, [0, v, d, 0, e]];
    }
    var r = tree[4], d$0 = tree[3], v$0 = tree[2], l = tree[1];
    return [0, l, [0, v$0, d$0, r, e]];
   }
   function drop_phys_equal_prefix(tree1, acc1, tree2, acc2){
    var tree1$0 = tree1, acc1$0 = acc1, tree2$0 = tree2, acc2$0 = acc2;
    for(;;){
     if(tree1$0 === tree2$0) return [0, acc1$0, acc2$0];
     var h2 = height(tree2$0), h1 = height(tree1$0);
     if(h2 === h1)
      var
       match = step_deeper_exn(tree1$0, acc1$0),
       acc1$1 = match[2],
       tree1$1 = match[1],
       match$0 = step_deeper_exn(tree2$0, acc2$0),
       acc2$1 = match$0[2],
       tree2$1 = match$0[1],
       tree1$0 = tree1$1,
       acc1$0 = acc1$1,
       tree2$0 = tree2$1,
       acc2$0 = acc2$1;
     else if(h1 < h2)
      var
       match$1 = step_deeper_exn(tree2$0, acc2$0),
       acc2$2 = match$1[2],
       tree2$2 = match$1[1],
       tree2$0 = tree2$2,
       acc2$0 = acc2$2;
     else
      var
       match$2 = step_deeper_exn(tree1$0, acc1$0),
       acc1$2 = match$2[2],
       tree1$2 = match$2[1],
       tree1$0 = tree1$2,
       acc1$0 = acc1$2;
    }
   }
   function fold$0(init, f, param){
    var init$0 = init, param$0 = param;
    for(;;){
     if(! param$0) return init$0;
     var
      enum$0 = param$0[4],
      tree = param$0[3],
      data = param$0[2],
      key = param$0[1],
      next = caml_call3(f, key, data, init$0),
      init$0 = next,
      param$0 = cons(tree, enum$0);
    }
   }
   function fold2(compare_key, t1, t2, init, f){
    var t1$0 = t1, t2$0 = t2, curr = init;
    for(;;){
     if(! t1$0)
      return t2$0
              ? fold$0
                (curr,
                 function(key, data, acc){
                  return caml_call3(f, key, [0, -57574468, data], acc);
                 },
                 t2$0)
              : curr;
     if(! t2$0)
      return fold$0
              (curr,
               function(key, data, acc){
                return caml_call3(f, key, [0, 847852583, data], acc);
               },
               t1$0);
     var
      enum2 = t2$0[4],
      tree2 = t2$0[3],
      v2 = t2$0[2],
      k2 = t2$0[1],
      enum1 = t1$0[4],
      tree1 = t1$0[3],
      v1 = t1$0[2],
      k1 = t1$0[1],
      compare_result = caml_call2(compare_key, k1, k2);
     if(0 === compare_result)
      var
       next = caml_call3(f, k1, [0, 737457313, [0, v1, v2]], curr),
       t2$1 = cons(tree2, enum2),
       t1$1 = cons(tree1, enum1),
       t1$0 = t1$1,
       t2$0 = t2$1,
       curr = next;
     else if(0 <= compare_result)
      var
       next$0 = caml_call3(f, k2, [0, -57574468, v2], curr),
       t2$2 = cons(tree2, enum2),
       t2$0 = t2$2,
       curr = next$0;
     else
      var
       next$1 = caml_call3(f, k1, [0, 847852583, v1], curr),
       t1$2 = cons(tree1, enum1),
       t1$0 = t1$2,
       curr = next$1;
    }
   }
   function symmetric_diff(t1, t2, compare_key, data_equal){
    function step(state){
     var left = state[1];
     if(left){
      var
       right = state[2],
       enum1 = left[4],
       tree1 = left[3],
       data = left[2],
       key = left[1];
      if(! right)
       return [1, [0, key, [0, 847852583, data]], [0, cons(tree1, enum1), 0]];
      var
       enum2 = right[4],
       tree2 = right[3],
       v2 = right[2],
       k2 = right[1],
       compare_result = caml_call2(compare_key, key, k2);
      if(0 !== compare_result)
       return 0 <= compare_result
               ? [1,
                 [0, k2, [0, -57574468, v2]],
                 [0, left, cons(tree2, enum2)]]
               : [1,
                 [0, key, [0, 847852583, data]],
                 [0, cons(tree1, enum1), right]];
      var next_state = drop_phys_equal_prefix(tree1, enum1, tree2, enum2);
      return caml_call2(data_equal, data, v2)
              ? [0, next_state]
              : [1, [0, key, [0, 1013247643, [0, data, v2]]], next_state];
     }
     var match = state[2];
     if(! match) return 0;
     var
      enum$0 = match[4],
      tree = match[3],
      data$0 = match[2],
      key$0 = match[1];
     return [1,
             [0, key$0, [0, -57574468, data$0]],
             [0, 0, cons(tree, enum$0)]];
    }
    var _cQ_ = drop_phys_equal_prefix(t1, 0, t2, 0);
    return caml_call2(Base_Sequence[44], _cQ_, step);
   }
   function to_sequence
   (comparator, opt, keys_greater_or_equal_to, keys_less_or_equal_to, t$3){
    if(opt) var sth = opt[1], order = sth; else var order = -542431297;
    function inclusive_bound(side, t, bound){
     var
      compare_key = comparator[1],
      match = split(t, bound, compare_key),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var match$0 = maybe[1], data = match$0[2], key = match$0[1];
     return set(t$0, 0, key, data, compare_key)[1];
    }
    if(511974747 <= order){
     var
      _cI_ = Base_Import[127],
      _cJ_ = function(_cO_, _cP_){return inclusive_bound(_cI_, _cO_, _cP_);},
      tree = caml_call3(Base_Option[34], keys_greater_or_equal_to, t$3, _cJ_),
      next$0 =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
         return [1, [0, k, v], cons_right(t, e)];
        };
     if(keys_less_or_equal_to){
      var
       key$0 = keys_less_or_equal_to[1],
       compare$0 = comparator[1],
       t$1 = tree,
       e$1 = 0;
      for(;;){
       if(typeof t$1 === "number"){var init$0 = e$1; break;}
       if(0 === t$1[0])
        var
         d$1 = t$1[2],
         v$2 = t$1[1],
         t$2 = [1, 0, v$2, d$1, 0, 1],
         t$1 = t$2;
       else{
        var l$0 = t$1[1], v$3 = t$1[2];
        if(0 < caml_call2(compare$0, v$3, key$0))
         var t$1 = l$0;
        else
         var
          r$1 = t$1[4],
          d$2 = t$1[3],
          v$4 = t$1[2],
          e$2 = [0, v$4, d$2, l$0, e$1],
          t$1 = r$1,
          e$1 = e$2;
       }
      }
     }
     else
      var init$0 = cons_right(tree, 0);
     return caml_call2(Base_Sequence[44], init$0, next$0);
    }
    var _cK_ = Base_Import[125];
    function _cL_(_cM_, _cN_){return inclusive_bound(_cK_, _cM_, _cN_);}
    var t$4 = caml_call3(Base_Option[34], keys_less_or_equal_to, t$3, _cL_);
    function next(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
     return [1, [0, k, v], cons(t, e)];
    }
    if(keys_greater_or_equal_to){
     var
      key = keys_greater_or_equal_to[1],
      compare = comparator[1],
      t = t$4,
      e = 0;
     for(;;){
      if(typeof t === "number"){var init = e; break;}
      if(0 === t[0])
       var d = t[2], v = t[1], t$0 = [1, 0, v, d, 0, 1], t = t$0;
      else{
       var l = t[1], r = t[4], v$0 = t[2];
       if(0 <= caml_call2(compare, v$0, key))
        var
         r$0 = t[4],
         d$0 = t[3],
         v$1 = t[2],
         e$0 = [0, v$1, d$0, r$0, e],
         t = l,
         e = e$0;
       else
        var t = r;
      }
     }
    }
    else
     var init = of_tree(t$4);
    return caml_call2(Base_Sequence[44], init, next);
   }
   function compare$1(compare_key, compare_data, t1$0, t2$0){
    var
     match$0 = drop_phys_equal_prefix(t1$0, 0, t2$0, 0),
     e2$1 = match$0[2],
     e1$1 = match$0[1],
     t1 = e1$1,
     t2 = e2$1;
    for(;;){
     if(! t1) return t2 ? -1 : 0;
     if(! t2) return 1;
     var
      e2 = t2[4],
      r2 = t2[3],
      d2 = t2[2],
      v2 = t2[1],
      e1 = t1[4],
      r1 = t1[3],
      d1 = t1[2],
      v1 = t1[1],
      c = caml_call2(compare_key, v1, v2);
     if(0 !== c) return c;
     var c$0 = caml_call2(compare_data, d1, d2);
     if(0 !== c$0) return c$0;
     var
      match = drop_phys_equal_prefix(r1, e1, r2, e2),
      e2$0 = match[2],
      e1$0 = match[1],
      t1 = e1$0,
      t2 = e2$0;
    }
   }
   function equal$1(compare_key, compare_data, t1$0, t2$0){
    var
     match$0 = drop_phys_equal_prefix(t1$0, 0, t2$0, 0),
     e2$1 = match$0[2],
     e1$1 = match$0[1],
     t1 = e1$1,
     t2 = e2$1;
    for(;;){
     if(t1){
      if(t2){
       var
        e2 = t2[4],
        r2 = t2[3],
        d2 = t2[2],
        v2 = t2[1],
        e1 = t1[4],
        r1 = t1[3],
        d1 = t1[2],
        v1 = t1[1],
        _cF_ = 0 === caml_call2(compare_key, v1, v2) ? 1 : 0;
       if(_cF_){
        var _cG_ = caml_call2(compare_data, d1, d2);
        if(_cG_){
         var
          match = drop_phys_equal_prefix(r1, e1, r2, e2),
          e2$0 = match[2],
          e1$0 = match[1],
          t1 = e1$0,
          t2 = e2$0;
         continue;
        }
        var _cH_ = _cG_;
       }
       else
        var _cH_ = _cF_;
       return _cH_;
      }
     }
     else if(! t2) return 1;
     return 0;
    }
   }
   function iter2(t1, t2, f, compare_key){
    function _cD_(key, data, param){return caml_call2(f, key, data);}
    var _cE_ = of_tree(t2);
    return fold2(compare_key, of_tree(t1), _cE_, 0, _cD_);
   }
   function fold2$0(t1, t2, init, f, compare_key){
    var _cC_ = of_tree(t2);
    return fold2(compare_key, of_tree(t1), _cC_, init, f);
   }
   function fold_symmetric_diff(t1, t2, compare_key, data_equal, init, f){
    function add(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
    }
    function remove(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
    }
    function delta(acc, k, v$0, v){
     return caml_call2(data_equal, v$0, v)
             ? acc
             : caml_call2(f, acc, [0, k, [0, 1013247643, [0, v$0, v]]]);
    }
    function loop(t$0, t, acc$3){
     var t1 = t$0, t2 = t, init = acc$3;
     for(;;){
      if(t1 === t2) return init;
      if(typeof t1 === "number")
       return fold
               (t2,
                init,
                function(key, data, acc){return add(acc, key, data);});
      a:
      {
       if(0 === t1[0]){
        var v = t1[2], k = t1[1];
        if(typeof t2 === "number") break a;
        if(0 === t2[0]){
         var v$0 = t2[2], k$0 = t2[1], x = caml_call2(compare_key, k, k$0);
         if(0 === x) return delta(init, k, v, v$0);
         if(0 <= x){
          var acc$4 = add(init, k$0, v$0);
          return remove(acc$4, k, v);
         }
         var acc$5 = remove(init, k, v);
         return add(acc$5, k$0, v$0);
        }
       }
       else{
        var r = t1[4], v$1 = t1[3], k$1 = t1[2], l = t1[1];
        if(typeof t2 === "number") break a;
        if(0 !== t2[0]){
         var r$0 = t2[4], v$2 = t2[3], k$2 = t2[2], l$0 = t2[1];
         if(0 === caml_call2(compare_key, k$1, k$2)){
          var
           acc$6 = loop(l, l$0, init),
           acc$7 = delta(acc$6, k$1, v$1, v$2),
           t1 = r,
           t2 = r$0,
           init = acc$7;
          continue;
         }
        }
       }
       var
        add$0 =
          function(acc, k, v){
           return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
          },
        remove$0 =
          function(acc, k, v){
           return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
          },
        match$0 = drop_phys_equal_prefix(t1, 0, t2, 0),
        right$1 = match$0[2],
        left$1 = match$0[1],
        left = left$1,
        right = right$1,
        acc = init;
       for(;;){
        if(! left)
         return fold$0
                 (acc,
                  function(key, data, acc){return add$0(acc, key, data);},
                  right);
        if(! right)
         return fold$0
                 (acc,
                  function(key, data, acc){return remove$0(acc, key, data);},
                  left);
        var
         enum2 = right[4],
         tree2 = right[3],
         v2 = right[2],
         k2 = right[1],
         enum1 = left[4],
         tree1 = left[3],
         v1 = left[2],
         k1 = left[1],
         compare_result = caml_call2(compare_key, k1, k2);
        if(0 === compare_result)
         var
          acc$0 =
            caml_call2(data_equal, v1, v2)
             ? acc
             : caml_call2(f, acc, [0, k1, [0, 1013247643, [0, v1, v2]]]),
          match = drop_phys_equal_prefix(tree1, enum1, tree2, enum2),
          enum2$0 = match[2],
          enum1$0 = match[1],
          left = enum1$0,
          right = enum2$0,
          acc = acc$0;
        else if(0 <= compare_result)
         var
          acc$1 = add$0(acc, k2, v2),
          right$0 = cons(tree2, enum2),
          right = right$0,
          acc = acc$1;
        else
         var
          acc$2 = remove$0(acc, k1, v1),
          left$0 = cons(tree1, enum1),
          left = left$0,
          acc = acc$2;
       }
      }
      return fold
              (t1,
               init,
               function(key, data, acc){return remove(acc, key, data);});
     }
    }
    return loop(t1, t2, init);
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var
     r = param[4],
     l = param[1],
     _cz_ = length(r),
     _cA_ = length(l),
     _cB_ = caml_call2(Base_Import[91], _cA_, _cz_);
    return caml_call2(Base_Import[91], _cB_, 1);
   }
   function keys(t){
    return fold_right
            (t, 0, function(key, param, list){return [0, key, list];});
   }
   function data(t){
    return fold_right
            (t, 0, function(param, data, list){return [0, data, list];});
   }
   function of_foldable(fold, foldable, init, f, compare_key){
    return caml_call3
            (fold,
             foldable,
             [0, empty_without_value_restrictio, 0],
             function(param, _cy_){
              var
               data = _cy_[2],
               key = _cy_[1],
               length = param[2],
               accum = param[1],
               match = find(accum, key, compare_key);
              if(match)
               var prev = match[1], prev_data = prev;
              else
               var prev_data = init;
              var data$0 = caml_call2(f, prev_data, data);
              return globalize(set(accum, length, key, data$0, compare_key));
             });
   }
   function Of_foldable(M){
    function of_foldable_fold(foldable, init, f, compare_key){
     return of_foldable(M[2], foldable, init, f, compare_key);
    }
    function of_foldable_reduce(foldable, f, compare_key){
     function _cw_(param, _cx_){
      var
       data = _cx_[2],
       key = _cx_[1],
       length = param[2],
       accum = param[1],
       match = find(accum, key, compare_key);
      if(match)
       var prev = match[1], new_data = caml_call2(f, prev, data);
      else
       var new_data = data;
      return globalize(set(accum, length, key, new_data, compare_key));
     }
     return caml_call3
             (M[2], foldable, [0, empty_without_value_restrictio, 0], _cw_);
    }
    function of_foldable$0(foldable, compare_key){
     return caml_call1
             (with_return,
              function(r){
               function _cu_(param, _cv_){
                var
                 data = _cv_[2],
                 key = _cv_[1],
                 length = param[2],
                 t = param[1],
                 acc = set(t, length, key, data, compare_key),
                 length$0 = acc[2];
                return length === length$0
                        ? caml_call1(r, [0, -1048878709, key])
                        : globalize(acc);
               }
               var
                map =
                  caml_call3
                   (M[2],
                    foldable,
                    [0, empty_without_value_restrictio, 0],
                    _cu_);
               return [0, 17724, map];
              });
    }
    function of_foldable_or_error(foldable, comparator){
     var match = of_foldable$0(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return [0, x];}
     var
      key = match[2],
      _cr_ = comparator[2],
      _cs_ = caml_call2(Base_Import[112], M[1], cst_or_error_duplicate_key),
      _ct_ = caml_call2(Base_Import[112], cst_Map_of, _cs_);
     return caml_call5(Base_Or_error[38], 0, 0, _ct_, key, _cr_);
    }
    function of_foldable_exn(foldable, comparator){
     var match = of_foldable$0(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return x;}
     var
      key = match[2],
      _cn_ = comparator[2],
      _co_ = caml_call2(Base_Import[112], M[1], cst_exn_duplicate_key),
      _cp_ = caml_call2(Base_Import[112], cst_Map_of$0, _co_),
      _cq_ = caml_call5(Base_Error[19], 0, 0, _cp_, key, _cn_);
     return caml_call1(Base_Error[31], _cq_);
    }
    function of_foldable_multi(foldable, compare_key){
     function _cl_(l, x){return [0, x, l];}
     var alist = caml_call3(M[2], foldable, 0, _cl_);
     function _cm_(l, x){return [0, x, l];}
     return of_foldable(Base_List0[8], alist, 0, _cm_, compare_key);
    }
    return [0,
            of_foldable_fold,
            of_foldable_reduce,
            of_foldable$0,
            of_foldable_or_error,
            of_foldable_exn,
            of_foldable_multi];
   }
   var
    fold$1 = Base_List0[8],
    Of_alist = Of_foldable([0, name, fold$1]),
    of_alist_fold = Of_alist[1],
    of_alist_reduce = Of_alist[2],
    of_alist = Of_alist[3],
    of_alist_or_error = Of_alist[4],
    of_alist_exn = Of_alist[5],
    of_alist_multi = Of_alist[6],
    fold$2 = Base_Sequence[11],
    Of_sequence = Of_foldable([0, name$0, fold$2]),
    of_sequence_fold = Of_sequence[1],
    of_sequence_reduce = Of_sequence[2],
    of_sequence = Of_sequence[3],
    of_sequence_or_error = Of_sequence[4],
    of_sequence_exn = Of_sequence[5],
    of_sequence_multi = Of_sequence[6];
   function of_list_with_key(list, get_key, compare_key){
    return caml_call1
            (with_return,
             function(r){
              function _ck_(param, data){
               var
                length = param[2],
                t = param[1],
                key = caml_call1(get_key, data),
                acc = set(t, length, key, data, compare_key),
                new_length = acc[2];
               return length === new_length
                       ? caml_call1(r, [0, -1048878709, key])
                       : globalize(acc);
              }
              var
               map =
                 caml_call3
                  (Base_List0[8],
                   list,
                   [0, empty_without_value_restrictio, 0],
                   _ck_);
              return [0, 17724, map];
             });
   }
   function of_list_with_key_or_error(list, get_key, comparator){
    var match = of_list_with_key(list, get_key, comparator[1]);
    if(17724 <= match[1]){var x = match[2]; return [0, x];}
    var key = match[2];
    return caml_call5
            (Base_Or_error[38],
             0,
             0,
             cst_Map_of_list_with_key_or_er,
             key,
             comparator[2]);
   }
   function of_list_with_key_exn(list, get_key, comparator){
    var match = of_list_with_key(list, get_key, comparator[1]);
    if(17724 <= match[1]){var x = match[2]; return x;}
    var
     key = match[2],
     _cj_ =
       caml_call5
        (Base_Error[19],
         0,
         0,
         cst_Map_of_list_with_key_exn_d,
         key,
         comparator[2]);
    return caml_call1(Base_Error[31], _cj_);
   }
   function of_list_with_key_multi(list, get_key, compare_key){
    var list$0 = caml_call1(Base_List0[19], list);
    function _ci_(param, data){
     var length = param[2], t = param[1], key = caml_call1(get_key, data);
     return globalize
             (update
               (t,
                key,
                function(option){
                 var list = caml_call2(Base_Option[30], option, 0);
                 return [0, data, list];
                },
                length,
                compare_key));
    }
    return caml_call3
            (Base_List0[8],
             list$0,
             [0, empty_without_value_restrictio, 0],
             _ci_);
   }
   function of_list_with_key_fold(list, get_key, init, f, compare_key){
    function _ch_(param, data){
     var length = param[2], t = param[1], key = caml_call1(get_key, data);
     return globalize
             (update
               (t,
                key,
                function(param){
                 if(! param) return caml_call2(f, init, data);
                 var prev = param[1];
                 return caml_call2(f, prev, data);
                },
                length,
                compare_key));
    }
    return caml_call3
            (Base_List0[8],
             list,
             [0, empty_without_value_restrictio, 0],
             _ch_);
   }
   function of_list_with_key_reduce(list, get_key, f, compare_key){
    function _cg_(param, data){
     var length = param[2], t = param[1], key = caml_call1(get_key, data);
     return globalize
             (update
               (t,
                key,
                function(param){
                 if(! param) return data;
                 var prev = param[1];
                 return caml_call2(f, prev, data);
                },
                length,
                compare_key));
    }
    return caml_call3
            (Base_List0[8],
             list,
             [0, empty_without_value_restrictio, 0],
             _cg_);
   }
   function for_all(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _cf_ = 1 - caml_call1(f, data);
                 return _cf_ ? caml_call1(r, 0) : _cf_;
                });
              return 1;
             });
   }
   function for_alli(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _ce_ = 1 - caml_call2(f, key, data);
                 return _ce_ ? caml_call1(r, 0) : _ce_;
                });
              return 1;
             });
   }
   function exists(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _cd_ = caml_call1(f, data);
                 return _cd_ ? caml_call1(r, 1) : _cd_;
                });
              return 0;
             });
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _cc_ = caml_call2(f, key, data);
                 return _cc_ ? caml_call1(r, 1) : _cc_;
                });
              return 0;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function sum(M, t, f){
    function _ca_(param, data, acc){
     var _cb_ = caml_call1(f, data);
     return caml_call2(M[2], _cb_, acc);
    }
    return fold(t, M[1], _ca_);
   }
   function sumi(M, t, f){
    function _b__(key, data, acc){
     var _b$_ = caml_call2(f, key, data);
     return caml_call2(M[2], _b$_, acc);
    }
    return fold(t, M[1], _b__);
   }
   function to_alist(opt, t){
    if(opt) var sth = opt[1], key_order = sth; else var key_order = 608542111;
    return 608542111 <= key_order
            ? fold_right
              (t, 0, function(key, data, x){return [0, [0, key, data], x];})
            : fold
              (t, 0, function(key, data, x){return [0, [0, key, data], x];});
   }
   function merge(t1, t2, f, compare_key){
    var
     _b7_ = length(t2),
     _b8_ = length(t1),
     _b9_ = caml_call2(Base_Import[91], _b8_, _b7_),
     elts = caml_call1(Base_Uniform_array[62], _b9_),
     i = [0, 0];
    iter2
     (t1,
      t2,
      function(key, values){
       var match = caml_call2(f, key, values);
       if(! match) return 0;
       var value = match[1];
       caml_call3(Base_Uniform_array[15], elts, i[1], [0, key, value]);
       i[1]++;
       return 0;
      },
      compare_key);
    var len = i[1];
    function get(i){return caml_call2(Base_Uniform_array[12], elts, i);}
    var tree = of_increasing_iterator_uncheck(len, get);
    return [0, tree, len];
   }
   function merge_large_first
   (length_large, t_large, t_small, call, combine, compare_key){
    return fold
            (t_small,
             [0, t_large, length_large],
             function(key, data, param){
              var length = param[2], t = param[1];
              return globalize
                      (update
                        (t,
                         key,
                         function(param){
                          if(! param) return data;
                          var data$0 = param[1];
                          return caml_call4(call, combine, key, data$0, data);
                         },
                         length,
                         compare_key));
             });
   }
   function call(f, key, x, y){return caml_call3(f, key, x, y);}
   function swap(f, key, x, y){return caml_call3(f, key, y, x);}
   function merge_skewed(t1, t2, length1, length2, combine, compare_key){
    return length2 <= length1
            ? merge_large_first(length1, t1, t2, call, combine, compare_key)
            : merge_large_first(length2, t2, t1, swap, combine, compare_key);
   }
   function merge_disjoint_exn(t1, t2, length1, length2, comparator){
    var _b4_ = comparator[1];
    return merge_skewed
            (t1,
             t2,
             length1,
             length2,
             function(key, param, _b5_){
              var
               _b6_ =
                 caml_call5
                  (Base_Error[19],
                   0,
                   0,
                   cst_Map_merge_disjoint_exn_dup,
                   key,
                   comparator[2]);
              return caml_call1(Base_Error[31], _b6_);
             },
             _b4_);
   }
   function repackage(marker, k, v){return marker ? [0, [0, k, v]] : 0;}
   function closest_key(t$0, dir, k$0, compare_key){
    var t = t$0, found_marker = 0, found_key = 0, found_value = 0;
    for(;;){
     if(typeof t === "number")
      return repackage(found_marker, found_key, found_value);
     if(0 === t[0]) break;
     var
      r = t[4],
      found_value$0 = t[3],
      found_key$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_key, found_key$0, k$0);
     if(0 === c$0)
      return -640801497 === dir
              ? is_empty
                 (l)
                ? repackage(found_marker, found_key, found_value)
                : max_elt(l)
              : -779285465
                <= dir
                ? [0, [0, found_key$0, found_value$0]]
                : is_empty
                   (r)
                  ? repackage(found_marker, found_key, found_value)
                  : min_elt(r);
     if(-640801497 !== dir && 927731004 > dir){
      if(0 < c$0){
       var
        t = l,
        found_marker = 1,
        found_key = found_key$0,
        found_value = found_value$0;
       continue;
      }
      var t = r;
      continue;
     }
     if(0 <= c$0)
      var t = l;
     else
      var
       t = r,
       found_marker = 1,
       found_key = found_key$0,
       found_value = found_value$0;
    }
    var
     v = t[2],
     k = t[1],
     c = caml_call2(compare_key, k, k$0),
     _b3_ =
       521507869 <= dir
        ? 927731004 <= dir ? c <= 0 ? 1 : 0 : 0 <= c ? 1 : 0
        : -640801497 <= dir ? c < 0 ? 1 : 0 : 0 < c ? 1 : 0;
    return _b3_
            ? [0, [0, k, v]]
            : repackage(found_marker, found_key, found_value);
   }
   function rank(t, k, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var k$0 = t$0[1];
      return 0 === caml_call2(compare_key, k$0, k) ? _s_ : 0;
     }
     var
      r = t$0[4],
      k$1 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, k$1, k);
     if(0 === c) return [0, length(l)];
     if(0 >= c){
      var
       _bZ_ =
         function(rank){
          var _b1_ = length(l), _b2_ = caml_call2(Base_Import[91], rank, 1);
          return caml_call2(Base_Import[91], _b2_, _b1_);
         },
       _b0_ = rank(r, k, compare_key);
      return caml_call2(Base_Option[24], _b0_, _bZ_);
     }
     var t$0 = l;
    }
   }
   function nth(num_to_search, param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var v = param$0[2], k = param$0[1];
      return 0 === num_to_search[1]
              ? [0, [0, k, v]]
              : (num_to_search[1] += -1, 0);
     }
     var
      r = param$0[4],
      v$0 = param$0[3],
      k$0 = param$0[2],
      l = param$0[1],
      some = nth(num_to_search, l);
     if(some) return some;
     if(0 === num_to_search[1]) return [0, [0, k$0, v$0]];
     num_to_search[1] += -1;
     var param$0 = r;
    }
   }
   function nth$0(t, n){return nth([0, n], t);}
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     var t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     var t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
                  })
               : find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) < 0 ? 1 : 0;
                  })
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
                  })
               : find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 < caml_call3(compare, key, data, v) ? 1 : 0;
                  });
    if(-1055410545 <= how){
     var
      pair =
        find_last_satisfying
         (t,
          function(key, data){
           return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
          });
     if(pair){
      var match = pair[1], data = match[2], key = match[1];
      if(0 === caml_call3(compare, key, data, v)) return pair;
     }
     return 0;
    }
    var
     pair$0 =
       find_first_satisfying
        (t,
         function(key, data){
          return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
         });
    if(pair$0){
     var match$0 = pair$0[1], data$0 = match$0[2], key$0 = match$0[1];
     if(0 === caml_call3(compare, key$0, data$0, v)) return pair$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(key, data){
     return 847852583 <= caml_call2(segment_of, key, data) ? 1 : 0;
    }
    function is_right(key, data){return 1 - is_left(key, data);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function binary_search_one_sided_bound
   (t, maybe_bound, compare, if_exclusive, if_inclusive){
    function find_bound(t, how, bound, compare){
     var match = binary_search(t, compare, how, bound);
     if(! match) return 0;
     var bound$0 = match[1][1];
     return [0, [0, bound$0]];
    }
    if(typeof maybe_bound === "number") return _t_;
    if(0 === maybe_bound[0]){
     var bound = maybe_bound[1];
     return find_bound(t, if_inclusive, bound, compare);
    }
    var bound$0 = maybe_bound[1];
    return find_bound(t, if_exclusive, bound$0, compare);
   }
   function binary_search_two_sided_bounds
   (t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_one_sided_bound
        (t, lower_bound, compare, -839473056, 926943384);
    if(! match) return 0;
    var
     lower_bound$0 = match[1],
     match$0 =
       binary_search_one_sided_bound
        (t, upper_bound, compare, 200870407, -253007807);
    if(! match$0) return 0;
    var upper_bound$0 = match$0[1];
    return [0, [0, lower_bound$0, upper_bound$0]];
   }
   function of_iteri(iteri, compare_key){
    var acc = [0, 0, [0, empty_without_value_restrictio, 0]];
    caml_call1
     (iteri,
      function(key, data){
       var
        match = acc[2],
        length = match[2],
        map = match[1],
        pair = set(map, length, key, data, compare_key),
        length$0 = pair[2];
       if(length === length$0 && caml_call1(Base_Option[52], acc[1])){acc[1] = [0, key]; return 0;}
       acc[2] = globalize(pair);
       return 0;
      });
    var match = acc[1];
    if(! match) return [0, 17724, acc[2]];
    var key = match[1];
    return [0, -1048878709, key];
   }
   function of_iteri_exn(iteri, comparator){
    var match = of_iteri(iteri, comparator[1]);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var
     key = match[2],
     _bY_ =
       caml_call5
        (Base_Error[19],
         0,
         0,
         cst_Map_of_iteri_exn_duplicate,
         key,
         comparator[2]);
    return caml_call1(Base_Error[31], _bY_);
   }
   function t_of_sexp_direct(key_of_sexp, value_of_sexp, sexp, comparator){
    var
     _bO_ = caml_call2(Base_Import[171], key_of_sexp, value_of_sexp),
     alist = caml_call2(Base_Import[173], _bO_, sexp),
     compare_key = comparator[1],
     match = of_alist(alist, compare_key);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var k = match[2];
    function _bP_(_bX_){return _bX_;}
    function _bQ_(_bW_){return _bW_;}
    var
     _bR_ = caml_call2(Base_Import[171], _bQ_, _bP_),
     alist_sexps = caml_call2(Base_Import[173], _bR_, sexp),
     found_first_k = [0, 0];
    function _bS_(param, _bT_){
     var
      k2_sexp = _bT_[1],
      k2 = param[1],
      _bU_ = 0 === caml_call2(compare_key, k, k2) ? 1 : 0;
     if(_bU_){
      if(found_first_k[1])
       return caml_call2
               (Base_Import[156], cst_Map_t_of_sexp_direct_dupli, k2_sexp);
      found_first_k[1] = 1;
      var _bV_ = 0;
     }
     else
      var _bV_ = _bU_;
     return _bV_;
    }
    caml_call3(Base_List0[13], alist, alist_sexps, _bS_);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
   }
   function sexp_of_t$1(sexp_of_key, sexp_of_value, t){
    function f(key, data, acc){
     var _bN_ = [0, caml_call1(sexp_of_value, data), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, key), _bN_]], acc];
    }
    return [1, fold_right(t, 0, f)];
   }
   function combine_errors(t, sexp_of_key){
    var
     match = partition_map(t, Base_Result[38]),
     errors = match[2],
     oks = match[1];
    if(is_empty(errors)) return [0, oks];
    var _bM_ = sexp_of_t$1(sexp_of_key, Base_Error[9], errors);
    return caml_call1(Base_Or_error[39], _bM_);
   }
   function unzip(t){
    var _bL_ = map(t, Base_Import[127]);
    return [0, map(t, Base_Import[125]), _bL_];
   }
   function map_keys(t1, f, param){
    var sexp_of_key = param[2], compare_key = param[1];
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      17724,
                      fold
                       (t1,
                        [0, empty_without_value_restrictio, 0],
                        function(key, data, param$0){
                         var
                          length = param$0[2],
                          t2 = param$0[1],
                          key$0 = caml_call1(f, key);
                         try{
                          var
                           _bJ_ =
                             globalize
                              (add_exn_internal
                                (t2, length, key$0, data, compare_key, sexp_of_key));
                          return _bJ_;
                         }
                         catch(_bK_){
                          var _bI_ = caml_wrap_exception(_bK_);
                          if(_bI_ === Duplicate)
                           return caml_call1(param, [0, -1048878709, key$0]);
                          throw caml_maybe_attach_backtrace(_bI_, 0);
                         }
                        })];
             });
   }
   function map_keys_exn(t, f, comparator){
    var match = map_keys(t, f, comparator);
    if(17724 <= match[1]){var result = match[2]; return result;}
    var
     key = match[2],
     sexp_of_key = comparator[2],
     _bG_ = [0, [0, cst_key$0, caml_call1(sexp_of_key, key)], 0],
     _bH_ = caml_call2(Base_Sexp[10], cst_Map_map_keys_exn_duplicate, _bG_);
    return caml_call1(Base_Error[32], _bH_);
   }
   function transpose_keys(outer_comparator, inner_comparator, outer_t){
    return fold
            (outer_t,
             [0, empty_without_value_restrictio, 0],
             function(outer_key, inner_t, acc){
              return fold
                      (inner_t,
                       acc,
                       function(inner_key, data, param){
                        var
                         acc_len = param[2],
                         acc = param[1],
                         _bF_ = inner_comparator[1];
                        return globalize
                                (update
                                  (acc,
                                   inner_key,
                                   function(param){
                                    if(! param) return [0, [0, outer_key, data], 1];
                                    var match = param[1], elt_len = match[2], elt = match[1];
                                    return globalize
                                            (set(elt, elt_len, outer_key, data, outer_comparator[1]));
                                   },
                                   acc_len,
                                   _bF_));
                       });
             });
   }
   function Make_applicative_traversals(A){
    function mapi(t, f){
     if(typeof t === "number") return caml_call1(A[1], 0);
     if(0 === t[0]){
      var
       d = t[2],
       v = t[1],
       _bA_ = function(new_data){return [0, v, new_data];},
       _bB_ = caml_call2(f, v, d);
      return caml_call2(A[2], _bB_, _bA_);
     }
     var h = t[5], r = t[4], d$0 = t[3], v$0 = t[2], l = t[1];
     function _bC_(param){return mapi(l, f);}
     var l$0 = caml_call1(A[14], _bC_), d$1 = caml_call2(f, v$0, d$0);
     function _bD_(param){return mapi(r, f);}
     var r$0 = caml_call1(A[14], _bD_);
     function _bE_(l, d, r){return [1, l, v$0, d, r, h];}
     return caml_call4(A[10], l$0, d$1, r$0, _bE_);
    }
    function filter_mapi(t, f){
     function tree_filter_mapi(t, f){
      if(typeof t === "number") return caml_call1(A[1], [0, 0, 0]);
      if(0 === t[0]){
       var
        d = t[2],
        v = t[1],
        _bo_ =
          function(param){
           if(! param) return [0, 0, 0];
           var new_data = param[1];
           return [0, [0, v, new_data], 1];
          },
        _bp_ = caml_call2(f, v, d);
       return caml_call2(A[2], _bp_, _bo_);
      }
      var r = t[4], d$0 = t[3], v$0 = t[2], l = t[1];
      function _bq_(param, new_data, _bw_){
       var r_len = _bw_[2], r = _bw_[1], l_len = param[2], l = param[1];
       if(new_data){
        var
         new_data$0 = new_data[1],
         _bx_ = caml_call2(Base_Import[91], l_len, r_len),
         _by_ = caml_call2(Base_Import[91], _bx_, 1);
        return [0, join(l, v$0, new_data$0, r), _by_];
       }
       var _bz_ = caml_call2(Base_Import[91], l_len, r_len);
       return [0, concat_and_balance_unchecked(l, r), _bz_];
      }
      function _br_(param){return tree_filter_mapi(r, f);}
      var _bs_ = caml_call1(A[14], _br_), _bt_ = caml_call2(f, v$0, d$0);
      function _bu_(param){return tree_filter_mapi(l, f);}
      var _bv_ = caml_call1(A[14], _bu_);
      return caml_call4(A[10], _bv_, _bt_, _bs_, _bq_);
     }
     return tree_filter_mapi(t, f);
    }
    return [0, mapi, filter_mapi];
   }
   function compare_key(t){return t[1][1];}
   function like(param, _bn_){
    var length = _bn_[2], tree = _bn_[1], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function like_maybe_no_op(old_t, param){
    var
     length = param[2],
     tree = param[1],
     old_tree = old_t[2],
     comparator = old_t[1];
    return old_tree === tree ? old_t : [0, comparator, tree, length];
   }
   function with_same_length(param, tree){
    var length = param[3], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function of_like_tree(t, tree){
    var _bm_ = length(tree);
    return [0, t[1], tree, _bm_];
   }
   function of_like_tree_maybe_no_op(t, tree){
    if(t[2] === tree) return t;
    var _bl_ = length(tree);
    return [0, t[1], tree, _bl_];
   }
   function of_tree$0(comparator, tree){
    return [0, comparator, tree, length(tree)];
   }
   function comparator(t){return t[1];}
   function to_tree(t){return t[2];}
   function invariants$0(t){
    var _bh_ = compare_key(t), _bi_ = invariants(t[2], _bh_);
    if(_bi_)
     var _bj_ = t[3], _bk_ = length(t[2]) === _bj_ ? 1 : 0;
    else
     var _bk_ = _bi_;
    return _bk_;
   }
   function is_empty$0(t){return is_empty(t[2]);}
   function length$0(t){return t[3];}
   function set$0(t, key, data){
    var _bg_ = compare_key(t);
    return like(t, set(t[2], t[3], key, data, _bg_));
   }
   function add_exn$0(t, key, data){
    var _be_ = t[1][2], _bf_ = compare_key(t);
    return like(t, add_exn(t[2], t[3], key, data, _bf_, _be_));
   }
   function add(t, key, data){
    try{
     var
      _ba_ = t[1][2],
      _bb_ = compare_key(t),
      result = like(t, add_exn_internal(t[2], t[3], key, data, _bb_, _ba_));
    }
    catch(_bd_){
     var _bc_ = caml_wrap_exception(_bd_);
     if(_bc_ === Duplicate) return -1024851605;
     throw caml_maybe_attach_backtrace(_bc_, 0);
    }
    return [0, 17724, result];
   }
   function add_multi$0(t, key, data){
    var _a$_ = compare_key(t);
    return like(t, add_multi(t[2], t[3], key, data, _a$_));
   }
   function remove_multi$0(t, key){
    var _a__ = compare_key(t);
    return like(t, remove_multi(t[2], key, t[3], _a__));
   }
   function find_multi$0(t, key){
    var _a9_ = compare_key(t);
    return find_multi(t[2], key, _a9_);
   }
   function change$0(t, key, f){
    var _a8_ = compare_key(t);
    return like(t, change(t[2], key, f, t[3], _a8_));
   }
   function update$0(t, key, f){
    var _a7_ = compare_key(t);
    return like(t, update(t[2], key, f, t[3], _a7_));
   }
   function find_exn$0(t, key){
    var _a5_ = t[1][2], _a6_ = compare_key(t);
    return find_exn(t[2], key, _a6_, _a5_);
   }
   function find$0(t, key){
    var _a4_ = compare_key(t);
    return find(t[2], key, _a4_);
   }
   function remove$0(t, key){
    var _a3_ = compare_key(t);
    return like_maybe_no_op(t, remove(t[2], key, t[3], _a3_));
   }
   function mem$0(t, key){
    var _a2_ = compare_key(t);
    return mem(t[2], key, _a2_);
   }
   function iter_keys$0(t, f){return iter_keys(t[2], f);}
   function iter$0(t, f){return iter(t[2], f);}
   function iteri$0(t, f){return iteri(t[2], f);}
   function iteri_until$0(t, f){return iteri_until(t[2], f);}
   function iter2$0(t1, t2, f){
    var _a1_ = compare_key(t1);
    return iter2(t1[2], t2[2], f, _a1_);
   }
   function map$0(t, f){return with_same_length(t, map(t[2], f));}
   function mapi$0(t, f){return with_same_length(t, mapi(t[2], f));}
   function fold$3(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f, finish){
    return fold_until(t[2], init, f, finish);
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold2$1(t1, t2, init, f){
    var _a0_ = compare_key(t1);
    return fold2$0(t1[2], t2[2], init, f, _a0_);
   }
   function filter_keys$0(t, f){
    var len = [0, t[3]], tree = filter_keys(t[2], f, len);
    return like_maybe_no_op(t, [0, tree, len[1]]);
   }
   function filter$0(t, f){
    var len = [0, t[3]], tree = filter(t[2], f, len);
    return like_maybe_no_op(t, [0, tree, len[1]]);
   }
   function filteri$0(t, f){
    var len = [0, t[3]], tree = filteri(t[2], f, len);
    return like_maybe_no_op(t, [0, tree, len[1]]);
   }
   function filter_map$0(t, f){
    var len = [0, t[3]], tree = filter_map(t[2], f, len);
    return like(t, [0, tree, len[1]]);
   }
   function filter_mapi$0(t, f){
    var len = [0, t[3]], tree = filter_mapi(t[2], f, len);
    return like(t, [0, tree, len[1]]);
   }
   function of_like_tree2(t, param){
    var t2 = param[2], t1 = param[1], _aZ_ = of_like_tree(t, t2);
    return [0, of_like_tree(t, t1), _aZ_];
   }
   function of_like_tree2_maybe_no_op(t, param){
    var t2 = param[2], t1 = param[1], _aY_ = of_like_tree_maybe_no_op(t, t2);
    return [0, of_like_tree_maybe_no_op(t, t1), _aY_];
   }
   function partition_mapi$0(t, f){
    return of_like_tree2(t, partition_mapi(t[2], f));
   }
   function partition_map$0(t, f){
    return of_like_tree2(t, partition_map(t[2], f));
   }
   function partitioni_tf$0(t, f){
    return of_like_tree2_maybe_no_op(t, partitioni_tf(t[2], f));
   }
   function partition_tf$0(t, f){
    return of_like_tree2_maybe_no_op(t, partition_tf(t[2], f));
   }
   function combine_errors$0(t){
    function _aV_(_aX_){return of_like_tree(t, _aX_);}
    var _aW_ = combine_errors(t[2], t[1][2]);
    return caml_call2(Base_Or_error[47], _aW_, _aV_);
   }
   function unzip$0(t){return of_like_tree2(t, unzip(t[2]));}
   function compare_direct(compare_data, t1, t2){
    var _aT_ = t2[2], _aU_ = t1[2];
    return compare$1(compare_key(t1), compare_data, _aU_, _aT_);
   }
   function equal$2(compare_data, t1, t2){
    var _aR_ = t2[2], _aS_ = t1[2];
    return equal$1(compare_key(t1), compare_data, _aS_, _aR_);
   }
   function keys$0(t){return keys(t[2]);}
   function data$0(t){return data(t[2]);}
   function to_alist$0(key_order, t){return to_alist(key_order, t[2]);}
   function symmetric_diff$0(t1, t2, data_equal){
    var _aQ_ = compare_key(t1);
    return symmetric_diff(t1[2], t2[2], _aQ_, data_equal);
   }
   function fold_symmetric_diff$0(t1, t2, data_equal, init, f){
    var _aP_ = compare_key(t1);
    return fold_symmetric_diff(t1[2], t2[2], _aP_, data_equal, init, f);
   }
   function merge$0(t1, t2, f){
    var _aO_ = compare_key(t1);
    return like(t1, merge(t1[2], t2[2], f, _aO_));
   }
   function merge_disjoint_exn$0(t1, t2){
    return like(t1, merge_disjoint_exn(t1[2], t2[2], t1[3], t2[3], t1[1]));
   }
   function merge_skewed$0(t1, t2, combine){
    var
     _aM_ = compare_key(t1),
     _aN_ = merge_skewed(t1[2], t2[2], t1[3], t2[3], combine, _aM_),
     t1$0 = t2[3] <= t1[3] ? t1 : t2;
    return like_maybe_no_op(t1$0, _aN_);
   }
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function for_alli$0(t, f){return for_alli(t[2], f);}
   function exists$0(t, f){return exists(t[2], f);}
   function existsi$0(t, f){return existsi(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function counti$0(t, f){return counti(t[2], f);}
   function sum$0(m, t, f){return sum(m, t[2], f);}
   function sumi$0(m, t, f){return sumi(m, t[2], f);}
   function split$0(t, k){
    var
     _aK_ = compare_key(t),
     match = split(t[2], k, _aK_),
     r = match[3],
     maybe = match[2],
     l = match[1],
     comparator = t[1],
     both_len =
       caml_call1(Base_Option[53], maybe)
        ? caml_call2(Base_Import[93], t[3], 1)
        : t[3],
     _aL_ = height(r);
    if(height(l) < _aL_){
     var l$0 = of_tree$0(comparator, l);
     return [0,
             l$0,
             maybe,
             [0, comparator, r, caml_call2(Base_Import[93], both_len, l$0[3])]];
    }
    var r$0 = of_tree$0(comparator, r);
    return [0,
            [0, comparator, l, caml_call2(Base_Import[93], both_len, r$0[3])],
            maybe,
            r$0];
   }
   function split_and_reinsert_boundary$0(t, into, k){
    var
     _aI_ = compare_key(t),
     match = split_and_reinsert_boundary(t[2], into, k, _aI_),
     r = match[2],
     l = match[1],
     comparator = t[1],
     _aJ_ = height(r);
    if(height(l) < _aJ_){
     var l$0 = of_tree$0(comparator, l);
     return [0,
             l$0,
             [0, comparator, r, caml_call2(Base_Import[93], t[3], l$0[3])]];
    }
    var r$0 = of_tree$0(comparator, r);
    return [0,
            [0, comparator, l, caml_call2(Base_Import[93], t[3], r$0[3])],
            r$0];
   }
   function split_le_gt(t, k){
    return split_and_reinsert_boundary$0(t, 847852583, k);
   }
   function split_lt_ge(t, k){
    return split_and_reinsert_boundary$0(t, -57574468, k);
   }
   function subrange(t, lower_bound, upper_bound){
    var
     _aE_ = compare_key(t),
     match = split_range(t[2], lower_bound, upper_bound, _aE_),
     right = match[3],
     mid = match[2],
     left = match[1],
     h_l = height(left),
     h_r = height(right),
     outer_joined_height =
       h_l === h_r
        ? caml_call2(Base_Import[91], h_l, 1)
        : caml_call2(Base_Import[100], h_l, h_r);
    if(outer_joined_height >= height(mid)) return of_tree$0(t[1], mid);
    var
     _aF_ = length(right),
     _aG_ = length(left),
     _aH_ = caml_call2(Base_Import[91], _aG_, _aF_),
     mid_length = caml_call2(Base_Import[93], t[3], _aH_);
    return [0, t[1], mid, mid_length];
   }
   function append$0(lower_part, upper_part){
    var
     _aC_ = compare_key(lower_part),
     match = append(lower_part[2], upper_part[2], _aC_);
    if(typeof match === "number") return 838882908;
    var
     tree = match[2],
     _aD_ = caml_call2(Base_Import[91], lower_part[3], upper_part[3]);
    return [0, 17724, [0, lower_part[1], tree, _aD_]];
   }
   function fold_range_inclusive$0(t, min, max, init, f){
    var _aB_ = compare_key(t);
    return fold_range_inclusive(t[2], min, max, init, f, _aB_);
   }
   function range_to_alist$0(t, min, max){
    var _aA_ = compare_key(t);
    return range_to_alist(t[2], min, max, _aA_);
   }
   function closest_key$0(t, dir, key){
    var _az_ = compare_key(t);
    return closest_key(t[2], dir, key, _az_);
   }
   function nth$1(t, n){return nth$0(t[2], n);}
   function nth_exn(t, n){
    var _ay_ = nth$1(t, n);
    return caml_call4(Base_Option[31], 0, 0, 0, _ay_);
   }
   function rank$0(t, key){
    var _ax_ = compare_key(t);
    return rank(t[2], key, _ax_);
   }
   function sexp_of_t$2(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t[2]);
   }
   function to_sequence$0
   (order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (t[1],
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function hash_fold_direct(hash_fold_key, hash_fold_data, state, t){
    var t$0 = t[2];
    function _av_(key, data, state){
     return caml_call2
             (hash_fold_data, caml_call2(hash_fold_key, state, key), data);
    }
    var _aw_ = length(t$0);
    return fold(t$0, caml_call2(Base_Import[206], state, _aw_), _av_);
   }
   function binary_search_subrange(t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t[2], compare, lower_bound, upper_bound);
    if(! match) return like_maybe_no_op(t, [0, 0, 0]);
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange(t, lower_bound$0, upper_bound$0);
   }
   function Make_applicative_traversals$0(A){
    var Tree_traversals = Make_applicative_traversals(A);
    function mapi(t, f){
     function _at_(new_tree){return with_same_length(t, new_tree);}
     var _au_ = Tree_traversals[1].call(null, t[2], f);
     return caml_call2(A[2], _au_, _at_);
    }
    function filter_mapi(t, f){
     function _ar_(new_tree_with_length){
      return like(t, new_tree_with_length);
     }
     var _as_ = Tree_traversals[2].call(null, t[2], f);
     return caml_call2(A[2], _as_, _ar_);
    }
    return [0, , mapi, filter_mapi];
   }
   function empty$0(param){return empty_without_value_restrictio;}
   function of_tree$1(param, tree){return tree;}
   function singleton(param, k, v){return [0, k, v];}
   function of_sorted_array_unchecked$0(comparator, array){
    return of_sorted_array_unchecked(array, comparator[1])[1];
   }
   function of_sorted_array$0(comparator, array){
    var
     _ap_ = of_sorted_array(array, comparator[1]),
     _aq_ = Base_Or_error[47];
    return caml_call2(_aq_, _ap_, function(x){return x[1];});
   }
   function of_alist$0(comparator, alist){
    var d = of_alist(alist, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_alist_or_error$0(comparator, alist){
    var _an_ = of_alist_or_error(alist, comparator), _ao_ = Base_Or_error[47];
    return caml_call2(_ao_, _an_, function(x){return x[1];});
   }
   function of_alist_exn$0(comparator, alist){
    return of_alist_exn(alist, comparator)[1];
   }
   function of_alist_multi$0(comparator, alist){
    return of_alist_multi(alist, comparator[1])[1];
   }
   function of_alist_fold$0(comparator, alist, init, f){
    return of_alist_fold(alist, init, f, comparator[1])[1];
   }
   function of_alist_reduce$0(comparator, alist, f){
    return of_alist_reduce(alist, f, comparator[1])[1];
   }
   function of_iteri$0(comparator, iteri){
    var d = of_iteri(iteri, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_iteri_exn$0(comparator, iteri){
    return of_iteri_exn(iteri, comparator)[1];
   }
   function of_increasing_iterator_uncheck$0(required_by_intf, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_increasing_sequence$0(comparator, seq){
    function _al_(x){return x[1];}
    var _am_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2(Base_Or_error[47], _am_, _al_);
   }
   function of_sequence$0(comparator, seq){
    var d = of_sequence(seq, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_sequence_or_error$0(comparator, seq){
    var
     _aj_ = of_sequence_or_error(seq, comparator),
     _ak_ = Base_Or_error[47];
    return caml_call2(_ak_, _aj_, function(x){return x[1];});
   }
   function of_sequence_exn$0(comparator, seq){
    return of_sequence_exn(seq, comparator)[1];
   }
   function of_sequence_multi$0(comparator, seq){
    return of_sequence_multi(seq, comparator[1])[1];
   }
   function of_sequence_fold$0(comparator, seq, init, f){
    return of_sequence_fold(seq, init, f, comparator[1])[1];
   }
   function of_sequence_reduce$0(comparator, seq, f){
    return of_sequence_reduce(seq, f, comparator[1])[1];
   }
   function of_list_with_key$0(comparator, list, get_key){
    var d = of_list_with_key(list, get_key, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_list_with_key_or_error$0(comparator, list, get_key){
    var
     _ah_ = of_list_with_key_or_error(list, get_key, comparator),
     _ai_ = Base_Or_error[47];
    return caml_call2(_ai_, _ah_, function(x){return x[1];});
   }
   function of_list_with_key_exn$0(comparator, list, get_key){
    return of_list_with_key_exn(list, get_key, comparator)[1];
   }
   function of_list_with_key_multi$0(comparator, list, get_key){
    return of_list_with_key_multi(list, get_key, comparator[1])[1];
   }
   function of_list_with_key_fold$0(comparator, list, get_key, init, f){
    return of_list_with_key_fold(list, get_key, init, f, comparator[1])[1];
   }
   function of_list_with_key_reduce$0(comparator, list, get_key, f){
    return of_list_with_key_reduce(list, get_key, f, comparator[1])[1];
   }
   function to_tree$0(t){return t;}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function length$1(t){return length(t);}
   function set$1(comparator, t, key, data){
    return set(t, 0, key, data, comparator[1])[1];
   }
   function add_exn$1(comparator, t, key, data){
    return add_exn(t, 0, key, data, comparator[1], comparator[2])[1];
   }
   function add$0(comparator, t, key, data){
    try{
     var
      _af_ =
        [0,
         17724,
         add_exn_internal(t, 0, key, data, comparator[1], comparator[2])[1]];
     return _af_;
    }
    catch(_ag_){return -1024851605;}
   }
   function add_multi$1(comparator, t, key, data){
    return add_multi(t, 0, key, data, comparator[1])[1];
   }
   function remove_multi$1(comparator, t, key){
    return remove_multi(t, key, 0, comparator[1])[1];
   }
   function find_multi$1(comparator, t, key){
    return find_multi(t, key, comparator[1]);
   }
   function change$1(comparator, t, key, f){
    return change(t, key, f, 0, comparator[1])[1];
   }
   function update$1(comparator, t, key, f){
    return change$1
            (comparator,
             t,
             key,
             function(data){return [0, caml_call1(f, data)];});
   }
   function find_exn$1(comparator, t, key){
    return find_exn(t, key, comparator[1], comparator[2]);
   }
   function find$1(comparator, t, key){return find(t, key, comparator[1]);}
   function remove$1(comparator, t, key){
    return remove(t, key, 0, comparator[1])[1];
   }
   function mem$1(comparator, t, key){return mem(t, key, comparator[1]);}
   function iter_keys$1(t, f){return iter_keys(t, f);}
   function iter$1(t, f){return iter(t, f);}
   function iteri$1(t, f){return iteri(t, f);}
   function iteri_until$1(t, f){return iteri_until(t, f);}
   function iter2$1(comparator, t1, t2, f){
    return iter2(t1, t2, f, comparator[1]);
   }
   function map$1(t, f){return map(t, f);}
   function mapi$1(t, f){return mapi(t, f);}
   function fold$4(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f, finish){return fold_until(t, init, f, finish);
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function fold2$2(comparator, t1, t2, init, f){
    return fold2$0(t1, t2, init, f, comparator[1]);
   }
   function filter_keys$1(t, f){return filter_keys(t, f, [0, 0]);}
   function filter$1(t, f){return filter(t, f, [0, 0]);}
   function filteri$1(t, f){return filteri(t, f, [0, 0]);}
   function filter_map$1(t, f){return filter_map(t, f, [0, 0]);}
   function filter_mapi$1(t, f){return filter_mapi(t, f, [0, 0]);}
   function partition_mapi$1(t, f){return partition_mapi(t, f);}
   function partition_map$1(t, f){return partition_map(t, f);}
   function partitioni_tf$1(t, f){return partitioni_tf(t, f);}
   function partition_tf$1(t, f){return partition_tf(t, f);}
   function combine_errors$1(comparator, t){
    return combine_errors(t, comparator[2]);
   }
   function compare_direct$0(comparator, compare_data, t1, t2){return compare$1(comparator[1], compare_data, t1, t2);
   }
   function equal$3(comparator, compare_data, t1, t2){
    return equal$1(comparator[1], compare_data, t1, t2);
   }
   function keys$1(t){return keys(t);}
   function data$1(t){return data(t);}
   function to_alist$1(key_order, t){return to_alist(key_order, t);}
   function symmetric_diff$1(comparator, t1, t2, data_equal){
    return symmetric_diff(t1, t2, comparator[1], data_equal);
   }
   function fold_symmetric_diff$1(comparator, t1, t2, data_equal, init, f){
    return fold_symmetric_diff(t1, t2, comparator[1], data_equal, init, f);
   }
   function merge$1(comparator, t1, t2, f){
    return merge(t1, t2, f, comparator[1])[1];
   }
   function merge_disjoint_exn$1(comparator, t1, t2){
    var _ae_ = length$1(t2);
    return merge_disjoint_exn(t1, t2, length$1(t1), _ae_, comparator)[1];
   }
   function merge_skewed$1(comparator, t1, t2, combine){
    var _ac_ = comparator[1], _ad_ = length$1(t2);
    return merge_skewed(t1, t2, length$1(t1), _ad_, combine, _ac_)[1];
   }
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function for_all$1(t, f){return for_all(t, f);}
   function for_alli$1(t, f){return for_alli(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function existsi$1(t, f){return existsi(t, f);}
   function count$1(t, f){return count(t, f);}
   function counti$1(t, f){return counti(t, f);}
   function sum$1(m, t, f){return sum(m, t, f);}
   function sumi$1(m, t, f){return sumi(m, t, f);}
   function split$1(comparator, t, k){return split(t, k, comparator[1]);}
   function split_le_gt$0(comparator, t, k){
    return split_and_reinsert_boundary(t, 847852583, k, comparator[1]);
   }
   function split_lt_ge$0(comparator, t, k){
    return split_and_reinsert_boundary(t, -57574468, k, comparator[1]);
   }
   function append$1(comparator, lower_part, upper_part){
    return append(lower_part, upper_part, comparator[1]);
   }
   function subrange$0(comparator, t, lower_bound, upper_bound){
    var ret = split_range(t, lower_bound, upper_bound, comparator[1])[2];
    return ret;
   }
   function fold_range_inclusive$1(comparator, t, min, max, init, f){
    return fold_range_inclusive(t, min, max, init, f, comparator[1]);
   }
   function range_to_alist$1(comparator, t, min, max){
    return range_to_alist(t, min, max, comparator[1]);
   }
   function closest_key$1(comparator, t, dir, key){
    return closest_key(t, dir, key, comparator[1]);
   }
   function nth$2(t, n){return nth$0(t, n);}
   function nth_exn$0(t, n){
    var _ab_ = nth$2(t, n);
    return caml_call4(Base_Option[31], 0, 0, 0, _ab_);
   }
   function rank$1(comparator, t, key){return rank(t, key, comparator[1]);}
   function sexp_of_t$3(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t);
   }
   function t_of_sexp_direct$0(comparator, k_of_sexp, v_of_sexp, sexp){
    return t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator)[1];
   }
   function to_sequence$1
   (comparator, order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (comparator,
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function binary_search_subrange$0
   (comparator, t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t, compare, lower_bound, upper_bound);
    if(! match) return 0;
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange$0(comparator, t, lower_bound$0, upper_bound$0);
   }
   function map_keys$0(comparator, t, f){
    var dup = map_keys(t, f, comparator);
    if(17724 > dup[1]) return dup;
    var t$0 = dup[2][1];
    return [0, 17724, t$0];
   }
   function map_keys_exn$0(comparator, t, f){
    return map_keys_exn(t, f, comparator)[1];
   }
   function transpose_keys$0(outer_comparator, inner_comparator, t){
    var _aa_ = transpose_keys(outer_comparator, inner_comparator, t)[1];
    return map$1(_aa_, function(x){return x[1];});
   }
   function add_exn$2(t, comparator, key, data){
    var match = max_key(t);
    if(match){
     var prev_key = match[1];
     if(0 <= caml_call2(comparator[1], prev_key, key))
      return caml_call1(Base_Error[32], _v_);
    }
    return add_unchecked(t, key, data);
   }
   function to_tree$1(t){return to_tree_unchecked(t);}
   var Build_increasing = [0, empty, add_exn$2, to_tree$1];
   function empty$1(comparator){
    return [0, comparator, empty_without_value_restrictio, 0];
   }
   function singleton$0(comparator, k, v){return [0, comparator, [0, k, v], 1];
   }
   function of_tree0(comparator, param){
    var length = param[2], tree = param[1];
    return [0, comparator, tree, length];
   }
   function of_tree$2(comparator, tree){
    return of_tree0(comparator, [0, tree, length(tree)]);
   }
   function of_sorted_array_unchecked$1(comparator, array){
    return of_tree0
            (comparator, of_sorted_array_unchecked(array, comparator[1]));
   }
   function of_sorted_array$1(comparator, array){
    function ___(tree){return of_tree0(comparator, tree);}
    var _$_ = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[47], _$_, ___);
   }
   function of_alist$1(comparator, alist){
    var z = of_alist(alist, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_alist_or_error$1(comparator, alist){
    function _Y_(tree){return of_tree0(comparator, tree);}
    var _Z_ = of_alist_or_error(alist, comparator);
    return caml_call2(Base_Result[33], _Z_, _Y_);
   }
   function of_alist_exn$1(comparator, alist){
    return of_tree0(comparator, of_alist_exn(alist, comparator));
   }
   function of_alist_multi$1(comparator, alist){
    return of_tree0(comparator, of_alist_multi(alist, comparator[1]));
   }
   function of_alist_fold$1(comparator, alist, init, f){
    return of_tree0(comparator, of_alist_fold(alist, init, f, comparator[1]));
   }
   function of_alist_reduce$1(comparator, alist, f){
    return of_tree0(comparator, of_alist_reduce(alist, f, comparator[1]));
   }
   function of_iteri$1(comparator, iteri){
    var z = of_iteri(iteri, comparator[1]);
    if(17724 > z[1]) return z;
    var tree_length = z[2];
    return [0, 17724, of_tree0(comparator, tree_length)];
   }
   function of_iteri_exn$1(comparator, iteri){
    return of_tree0(comparator, of_iteri_exn(iteri, comparator));
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    return of_tree0
            (comparator, [0, of_increasing_iterator_uncheck(len, f), len]);
   }
   function of_increasing_sequence$1(comparator, seq){
    function _W_(x){return of_tree0(comparator, x);}
    var _X_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2(Base_Or_error[47], _X_, _W_);
   }
   function of_sequence$1(comparator, seq){
    var z = of_sequence(seq, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_sequence_or_error$1(comparator, seq){
    function _U_(tree){return of_tree0(comparator, tree);}
    var _V_ = of_sequence_or_error(seq, comparator);
    return caml_call2(Base_Result[33], _V_, _U_);
   }
   function of_sequence_exn$1(comparator, seq){
    return of_tree0(comparator, of_sequence_exn(seq, comparator));
   }
   function of_sequence_multi$1(comparator, seq){
    return of_tree0(comparator, of_sequence_multi(seq, comparator[1]));
   }
   function of_sequence_fold$1(comparator, seq, init, f){
    return of_tree0(comparator, of_sequence_fold(seq, init, f, comparator[1]));
   }
   function of_sequence_reduce$1(comparator, seq, f){
    return of_tree0(comparator, of_sequence_reduce(seq, f, comparator[1]));
   }
   function of_list_with_key$1(comparator, list, get_key){
    var z = of_list_with_key(list, get_key, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_list_with_key_or_error$1(comparator, list, get_key){
    function _S_(tree){return of_tree0(comparator, tree);}
    var _T_ = of_list_with_key_or_error(list, get_key, comparator);
    return caml_call2(Base_Result[33], _T_, _S_);
   }
   function of_list_with_key_exn$1(comparator, list, get_key){
    return of_tree0
            (comparator, of_list_with_key_exn(list, get_key, comparator));
   }
   function of_list_with_key_multi$1(comparator, list, get_key){
    return of_tree0
            (comparator, of_list_with_key_multi(list, get_key, comparator[1]));
   }
   function of_list_with_key_fold$1(comparator, list, get_key, init, f){
    return of_tree0
            (comparator,
             of_list_with_key_fold(list, get_key, init, f, comparator[1]));
   }
   function of_list_with_key_reduce$1(comparator, list, get_key, f){
    return of_tree0
            (comparator,
             of_list_with_key_reduce(list, get_key, f, comparator[1]));
   }
   function t_of_sexp_direct$1(comparator, k_of_sexp, v_of_sexp, sexp){
    return of_tree0
            (comparator,
             t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator));
   }
   function map_keys$1(comparator, t, f){
    var dup = map_keys(t[2], f, comparator);
    if(17724 > dup[1]) return dup;
    var pair = dup[2];
    return [0, 17724, of_tree0(comparator, pair)];
   }
   function map_keys_exn$1(comparator, t, f){
    return of_tree0(comparator, map_keys_exn(t[2], f, comparator));
   }
   function transpose_keys$1(inner_comparator, t){
    var
     outer_comparator = t[1],
     _R_ =
       of_tree0
        (inner_comparator,
         transpose_keys
          (outer_comparator, inner_comparator, map(t[2], to_tree)));
    return map$0(_R_, function(x){return of_tree0(outer_comparator, x);});
   }
   function Empty_without_value_restrictio(K){
    var empty = [0, K[1], empty_without_value_restrictio, 0];
    return [0, empty];
   }
   function comparator_s(t){return caml_call1(Base_Comparator[5], t[1]);}
   var to_comparator = Base_Comparator[4];
   function of_tree$3(m, tree){
    return of_tree$0(caml_call1(to_comparator, m), tree);
   }
   function empty$2(m){return empty$1(caml_call1(to_comparator, m));}
   function singleton$1(m, a){
    var _P_ = caml_call1(to_comparator, m);
    return function(_Q_){return singleton$0(_P_, a, _Q_);};
   }
   function of_alist$2(m, a){
    return of_alist$1(caml_call1(to_comparator, m), a);
   }
   function of_alist_or_error$2(m, a){
    return of_alist_or_error$1(caml_call1(to_comparator, m), a);
   }
   function of_alist_exn$2(m, a){
    return of_alist_exn$1(caml_call1(to_comparator, m), a);
   }
   function of_alist_multi$2(m, a){
    return of_alist_multi$1(caml_call1(to_comparator, m), a);
   }
   function of_alist_fold$2(m, a, init, f){
    return of_alist_fold$1(caml_call1(to_comparator, m), a, init, f);
   }
   function of_alist_reduce$2(m, a, f){
    return of_alist_reduce$1(caml_call1(to_comparator, m), a, f);
   }
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(caml_call1(to_comparator, m), a);
   }
   function of_sorted_array$2(m, a){
    return of_sorted_array$1(caml_call1(to_comparator, m), a);
   }
   function of_iteri$2(m, iteri){
    return of_iteri$1(caml_call1(to_comparator, m), iteri);
   }
   function of_iteri_exn$2(m, iteri){
    return of_iteri_exn$1(caml_call1(to_comparator, m), iteri);
   }
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1
            (caml_call1(to_comparator, m), len, f);
   }
   function of_increasing_sequence$2(m, seq){
    return of_increasing_sequence$1(caml_call1(to_comparator, m), seq);
   }
   function of_sequence$2(m, s){
    return of_sequence$1(caml_call1(to_comparator, m), s);
   }
   function of_sequence_or_error$2(m, s){
    return of_sequence_or_error$1(caml_call1(to_comparator, m), s);
   }
   function of_sequence_exn$2(m, s){
    return of_sequence_exn$1(caml_call1(to_comparator, m), s);
   }
   function of_sequence_multi$2(m, s){
    return of_sequence_multi$1(caml_call1(to_comparator, m), s);
   }
   function of_sequence_fold$2(m, s, init, f){
    return of_sequence_fold$1(caml_call1(to_comparator, m), s, init, f);
   }
   function of_sequence_reduce$2(m, s, f){
    return of_sequence_reduce$1(caml_call1(to_comparator, m), s, f);
   }
   function of_list_with_key$2(m, l, get_key){
    return of_list_with_key$1(caml_call1(to_comparator, m), l, get_key);
   }
   function of_list_with_key_or_error$2(m, l, get_key){
    return of_list_with_key_or_error$1
            (caml_call1(to_comparator, m), l, get_key);
   }
   function of_list_with_key_exn$2(m, l, get_key){
    return of_list_with_key_exn$1(caml_call1(to_comparator, m), l, get_key);
   }
   function of_list_with_key_multi$2(m, l, get_key){
    return of_list_with_key_multi$1(caml_call1(to_comparator, m), l, get_key);
   }
   function of_list_with_key_fold$2(m, l, get_key, init, f){
    return of_list_with_key_fold$1
            (caml_call1(to_comparator, m), l, get_key, init, f);
   }
   function of_list_with_key_reduce$2(m, l, get_key, f){
    return of_list_with_key_reduce$1
            (caml_call1(to_comparator, m), l, get_key, f);
   }
   function map_keys$2(m, t, f){
    return map_keys$1(caml_call1(to_comparator, m), t, f);
   }
   function map_keys_exn$2(m, t, f){
    return map_keys_exn$1(caml_call1(to_comparator, m), t, f);
   }
   function transpose_keys$2(m, t){
    return transpose_keys$1(caml_call1(to_comparator, m), t);
   }
   function M(K){return [0];}
   function sexp_of_m_t(K, sexp_of_v, t){
    function _O_(param){return _w_;}
    return sexp_of_t$2(K[1], sexp_of_v, _O_, t);
   }
   function m_t_of_sexp(K, v_of_sexp, sexp){
    return t_of_sexp_direct$1(K[2], K[1], v_of_sexp, sexp);
   }
   function m_t_sexp_grammar(K, v_grammar){
    return [5,
            [0,
             Sexplib0_Sexp_grammar[5],
             _z_,
             [2,
              [1,
               [2,
                [0,
                 [5, [0, Sexplib0_Sexp_grammar[6], _y_, K[1]]],
                 [0, [5, [0, Sexplib0_Sexp_grammar[7], _x_, v_grammar]], 0]]]]]]];
   }
   function compare_m_t(param, compare_v, t1, t2){return compare_direct(compare_v, t1, t2);
   }
   function equal_m_t(param, equal_v, t1, t2){return equal$2(equal_v, t1, t2);
   }
   function hash_fold_m_t(K, hash_fold_v, state){
    var _M_ = K[1];
    return function(_N_){
     return hash_fold_direct(_M_, hash_fold_v, state, _N_);};
   }
   var comparator$0 = Base_Comparator[2][1];
   function of_tree$4(tree){return [0, comparator$0, tree, length(tree)];}
   var
    include$1 = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$3 = include$1[1];
   function singleton$2(a){
    return function(_L_){return singleton$0(comparator$0, a, _L_);};
   }
   function of_alist$3(a){return of_alist$1(comparator$0, a);}
   function of_alist_or_error$3(a){
    return of_alist_or_error$1(comparator$0, a);
   }
   function of_alist_exn$3(a){return of_alist_exn$1(comparator$0, a);}
   function of_alist_multi$3(a){return of_alist_multi$1(comparator$0, a);}
   function of_alist_fold$3(a, init, f){
    return of_alist_fold$1(comparator$0, a, init, f);
   }
   function of_alist_reduce$3(a, f){
    return of_alist_reduce$1(comparator$0, a, f);
   }
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_iteri$3(iteri){return of_iteri$1(comparator$0, iteri);}
   function of_iteri_exn$3(iteri){return of_iteri_exn$1(comparator$0, iteri);}
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_increasing_sequence$3(seq){
    return of_increasing_sequence$1(comparator$0, seq);
   }
   function of_sequence$3(s){return of_sequence$1(comparator$0, s);}
   function of_sequence_or_error$3(s){
    return of_sequence_or_error$1(comparator$0, s);
   }
   function of_sequence_exn$3(s){return of_sequence_exn$1(comparator$0, s);}
   function of_sequence_multi$3(s){
    return of_sequence_multi$1(comparator$0, s);
   }
   function of_sequence_fold$3(s, init, f){
    return of_sequence_fold$1(comparator$0, s, init, f);
   }
   function of_sequence_reduce$3(s, f){
    return of_sequence_reduce$1(comparator$0, s, f);
   }
   function of_list_with_key$3(l, get_key){
    return of_list_with_key$1(comparator$0, l, get_key);
   }
   function of_list_with_key_or_error$3(l, get_key){
    return of_list_with_key_or_error$1(comparator$0, l, get_key);
   }
   function of_list_with_key_exn$3(l, get_key){
    return of_list_with_key_exn$1(comparator$0, l, get_key);
   }
   function of_list_with_key_multi$3(l, get_key){
    return of_list_with_key_multi$1(comparator$0, l, get_key);
   }
   function of_list_with_key_fold$3(l, get_key, init, f){
    return of_list_with_key_fold$1(comparator$0, l, get_key, init, f);
   }
   function of_list_with_key_reduce$3(l, get_key, f){
    return of_list_with_key_reduce$1(comparator$0, l, get_key, f);
   }
   function map_keys$3(t, f){return map_keys$1(comparator$0, t, f);}
   function map_keys_exn$3(t, f){return map_keys_exn$1(comparator$0, t, f);}
   function transpose_keys$3(t){return transpose_keys$1(comparator$0, t);}
   var
    _A_ =
      [0,
       empty$3,
       singleton$2,
       map_keys$3,
       map_keys_exn$3,
       transpose_keys$3,
       of_sorted_array$3,
       of_sorted_array_unchecked$3,
       of_increasing_iterator_uncheck$3,
       of_alist$3,
       of_alist_or_error$3,
       of_alist_exn$3,
       of_alist_multi$3,
       of_alist_fold$3,
       of_alist_reduce$3,
       of_increasing_sequence$3,
       of_sequence$3,
       of_sequence_or_error$3,
       of_sequence_exn$3,
       of_sequence_multi$3,
       of_sequence_fold$3,
       of_sequence_reduce$3,
       of_list_with_key$3,
       of_list_with_key_or_error$3,
       of_list_with_key_exn$3,
       of_list_with_key_multi$3,
       of_list_with_key_fold$3,
       of_list_with_key_reduce$3,
       of_iteri$3,
       of_iteri_exn$3,
       of_tree$4,
       invariants$0,
       is_empty$0,
       length$0,
       add,
       add_exn$0,
       set$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$0,
       find_exn$0,
       remove$0,
       mem$0,
       iter_keys$0,
       iter$0,
       iteri$0,
       iteri_until$0,
       iter2$0,
       map$0,
       mapi$0,
       fold$3,
       fold_until$0,
       fold_right$0,
       fold2$1,
       filter_keys$0,
       filter$0,
       filteri$0,
       filter_map$0,
       filter_mapi$0,
       partition_mapi$0,
       partition_map$0,
       partitioni_tf$0,
       partition_tf$0,
       combine_errors$0,
       unzip$0,
       compare_direct,
       equal$2,
       keys$0,
       data$0,
       to_alist$0,
       merge$0,
       merge_disjoint_exn$0,
       merge_skewed$0,
       symmetric_diff$0,
       fold_symmetric_diff$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       for_all$0,
       for_alli$0,
       exists$0,
       existsi$0,
       count$0,
       counti$0,
       sum$0,
       sumi$0,
       split$0,
       split_le_gt,
       split_lt_ge,
       append$0,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$1,
       nth_exn,
       rank$0,
       to_tree,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       binary_search_subrange,
       function(_J_){
        var _K_ = Make_applicative_traversals$0(_J_);
        return [0, _K_[2], _K_[3]];
       }];
   function _B_(_H_){
    var _I_ = Make_applicative_traversals$0(_H_);
    return [0, _I_[2], _I_[3]];
   }
   var
    _C_ =
      [0,
       sexp_of_t$2,
       t_of_sexp_direct$1,
       [0,
        sexp_of_t$3,
        t_of_sexp_direct$0,
        empty$0,
        singleton,
        map_keys$0,
        map_keys_exn$0,
        transpose_keys$0,
        of_sorted_array$0,
        of_sorted_array_unchecked$0,
        of_increasing_iterator_uncheck$0,
        of_alist$0,
        of_alist_or_error$0,
        of_alist_exn$0,
        of_alist_multi$0,
        of_alist_fold$0,
        of_alist_reduce$0,
        of_increasing_sequence$0,
        of_sequence$0,
        of_sequence_or_error$0,
        of_sequence_exn$0,
        of_sequence_multi$0,
        of_sequence_fold$0,
        of_sequence_reduce$0,
        of_list_with_key$0,
        of_list_with_key_or_error$0,
        of_list_with_key_exn$0,
        of_list_with_key_multi$0,
        of_list_with_key_fold$0,
        of_list_with_key_reduce$0,
        of_iteri$0,
        of_iteri_exn$0,
        of_tree$1,
        invariants$1,
        is_empty$1,
        length$1,
        add$0,
        add_exn$1,
        set$1,
        add_multi$1,
        remove_multi$1,
        find_multi$1,
        change$1,
        update$1,
        find$1,
        find_exn$1,
        remove$1,
        mem$1,
        iter_keys$1,
        iter$1,
        iteri$1,
        iteri_until$1,
        iter2$1,
        map$1,
        mapi$1,
        fold$4,
        fold_until$1,
        fold_right$1,
        fold2$2,
        filter_keys$1,
        filter$1,
        filteri$1,
        filter_map$1,
        filter_mapi$1,
        partition_mapi$1,
        partition_map$1,
        partitioni_tf$1,
        partition_tf$1,
        combine_errors$1,
        unzip,
        compare_direct$0,
        equal$3,
        keys$1,
        data$1,
        to_alist$1,
        merge$1,
        merge_disjoint_exn$1,
        merge_skewed$1,
        symmetric_diff$1,
        fold_symmetric_diff$1,
        min_elt$1,
        min_elt_exn$1,
        max_elt$1,
        max_elt_exn$1,
        for_all$1,
        for_alli$1,
        exists$1,
        existsi$1,
        count$1,
        counti$1,
        sum$1,
        sumi$1,
        split$1,
        split_le_gt$0,
        split_lt_ge$0,
        append$1,
        subrange$0,
        fold_range_inclusive$1,
        range_to_alist$1,
        closest_key$1,
        nth$2,
        nth_exn$0,
        rank$1,
        to_tree$0,
        to_sequence$1,
        binary_search$1,
        binary_search_segmented$1,
        binary_search_subrange$0,
        function(A){
         var Tree0_traversals = Make_applicative_traversals(A);
         function mapi(t, f){return Tree0_traversals[1].call(null, t, f);}
         function filter_mapi(t, f){
          function _F_(x){return x[1];}
          var _G_ = Tree0_traversals[2].call(null, t, f);
          return caml_call2(A[2], _G_, _F_);
         }
         return [0, mapi, filter_mapi];
        },
        empty_without_value_restrictio,
        Build_increasing],
       empty$1,
       singleton$0,
       map_keys$1,
       map_keys_exn$1,
       transpose_keys$1,
       of_sorted_array$1,
       of_sorted_array_unchecked$1,
       of_increasing_iterator_uncheck$1,
       of_alist$1,
       of_alist_or_error$1,
       of_alist_exn$1,
       of_alist_multi$1,
       of_alist_fold$1,
       of_alist_reduce$1,
       of_increasing_sequence$1,
       of_sequence$1,
       of_sequence_or_error$1,
       of_sequence_exn$1,
       of_sequence_multi$1,
       of_sequence_fold$1,
       of_sequence_reduce$1,
       of_list_with_key$1,
       of_list_with_key_or_error$1,
       of_list_with_key_exn$1,
       of_list_with_key_multi$1,
       of_list_with_key_fold$1,
       of_list_with_key_reduce$1,
       of_iteri$1,
       of_iteri_exn$1,
       of_tree$2,
       invariants$0,
       is_empty$0,
       length$0,
       add,
       add_exn$0,
       set$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$0,
       find_exn$0,
       remove$0,
       mem$0,
       iter_keys$0,
       iter$0,
       iteri$0,
       iteri_until$0,
       iter2$0,
       map$0,
       mapi$0,
       fold$3,
       fold_until$0,
       fold_right$0,
       fold2$1,
       filter_keys$0,
       filter$0,
       filteri$0,
       filter_map$0,
       filter_mapi$0,
       partition_mapi$0,
       partition_map$0,
       partitioni_tf$0,
       partition_tf$0,
       combine_errors$0,
       unzip$0,
       compare_direct,
       equal$2,
       keys$0,
       data$0,
       to_alist$0,
       merge$0,
       merge_disjoint_exn$0,
       merge_skewed$0,
       symmetric_diff$0,
       fold_symmetric_diff$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       for_all$0,
       for_alli$0,
       exists$0,
       existsi$0,
       count$0,
       counti$0,
       sum$0,
       sumi$0,
       split$0,
       split_le_gt,
       split_lt_ge,
       append$0,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$1,
       nth_exn,
       rank$0,
       to_tree,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       binary_search_subrange,
       _B_,
       comparator,
       hash_fold_direct,
       Empty_without_value_restrictio],
    Base_Map =
      [0,
       Finished_or_unfinished,
       Merge_element,
       invariants$0,
       comparator_s,
       comparator,
       empty$2,
       singleton$1,
       of_alist$2,
       of_alist_or_error$2,
       of_alist_exn$2,
       of_alist_multi$2,
       of_alist_fold$2,
       of_alist_reduce$2,
       of_iteri$2,
       of_iteri_exn$2,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       of_increasing_sequence$2,
       of_sequence$2,
       of_sequence_or_error$2,
       of_sequence_exn$2,
       of_sequence_multi$2,
       of_sequence_fold$2,
       of_sequence_reduce$2,
       of_list_with_key$2,
       of_list_with_key_or_error$2,
       of_list_with_key_exn$2,
       of_list_with_key_multi$2,
       of_list_with_key_fold$2,
       of_list_with_key_reduce$2,
       is_empty$0,
       length$0,
       set$0,
       add,
       add_exn$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$0,
       find_exn$0,
       remove$0,
       mem$0,
       iter_keys$0,
       iter$0,
       iteri$0,
       iteri_until$0,
       iter2$0,
       map$0,
       mapi$0,
       map_keys$2,
       map_keys_exn$2,
       fold$3,
       fold_until$0,
       fold_right$0,
       fold2$1,
       filter_keys$0,
       filter$0,
       filteri$0,
       filter_map$0,
       filter_mapi$0,
       partition_mapi$0,
       partition_map$0,
       partitioni_tf$0,
       partition_tf$0,
       combine_errors$0,
       unzip$0,
       compare_direct,
       hash_fold_direct,
       equal$2,
       keys$0,
       data$0,
       to_alist$0,
       merge$0,
       merge_disjoint_exn$0,
       merge_skewed$0,
       Symmetric_diff_element,
       symmetric_diff$0,
       fold_symmetric_diff$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       transpose_keys$2,
       for_all$0,
       for_alli$0,
       exists$0,
       existsi$0,
       count$0,
       counti$0,
       sum$0,
       sumi$0,
       split$0,
       split_le_gt,
       split_lt_ge,
       append$0,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$1,
       nth_exn,
       rank$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       binary_search_subrange,
       function(_D_){
        var _E_ = Make_applicative_traversals$0(_D_);
        return [0, _E_[2], _E_[3]];
       },
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       _C_,
       _A_,
       of_tree$3,
       to_tree];
   runtime.caml_register_global(67, Base_Map, "Base__Map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue0
//# unitInfo: Requires: Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Queue = global_data.Stdlib__Queue,
    create = Stdlib_Queue[2],
    clear = Stdlib_Queue[11],
    copy = Stdlib_Queue[12],
    is_empty = Stdlib_Queue[13],
    length = Stdlib_Queue[14],
    peek = Stdlib_Queue[8],
    pop = Stdlib_Queue[7],
    push = Stdlib_Queue[4],
    transfer = Stdlib_Queue[17];
   function iter(t, f){
    var caml_iter = Stdlib_Queue[15];
    return caml_call2(caml_iter, f, t);
   }
   function fold(t, init, f){
    var caml_fold = Stdlib_Queue[16];
    return caml_call3(caml_fold, f, init, t);
   }
   var
    Base_Linked_queue0 =
      [0,
       create,
       clear,
       copy,
       is_empty,
       length,
       peek,
       pop,
       push,
       transfer,
       iter,
       fold];
   runtime.caml_register_global(1, Base_Linked_queue0, "Base__Linked_queue0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue
//# unitInfo: Requires: Base__Array, Base__Import, Base__Indexed_container, Base__Linked_queue0, Base__List, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Array = global_data.Base__Array,
    Base_Linked_queue0 = global_data.Base__Linked_queue0,
    Base_Indexed_container = global_data.Base__Indexed_container,
    create = Base_Linked_queue0[1],
    clear = Base_Linked_queue0[2],
    copy = Base_Linked_queue0[3],
    is_empty = Base_Linked_queue0[4],
    length = Base_Linked_queue0[5],
    iter = Base_Linked_queue0[10],
    fold = Base_Linked_queue0[11];
   function enqueue(t, x){return caml_call2(Base_Linked_queue0[8], x, t);}
   function dequeue(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[7], t)];
   }
   var dequeue_exn = Base_Linked_queue0[7];
   function dequeue_and_ignore_exn(t){caml_call1(dequeue_exn, t); return 0;}
   function peek(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[6], t)];
   }
   var peek_exn = Base_Linked_queue0[6];
   function drain(t, f, while$0){
    for(;;){
     if
      (!
       caml_call1(is_empty, t)
       && caml_call1(while$0, caml_call1(peek_exn, t))){
      caml_call1(f, caml_call1(dequeue_exn, t));
      continue;
     }
     return 0;
    }
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, -304398144, -304398144]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    to_list = C[14],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    foldi = C[18],
    for_alli = C[21],
    iteri = C[19];
   function transfer(src, dst){
    return caml_call2(Base_Linked_queue0[9], src, dst);
   }
   function concat_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       function _o_(b){return enqueue(res, b);}
       var _p_ = caml_call1(f, a);
       return caml_call2(Base_List[19], _p_, _o_);
      });
    return res;
   }
   function concat_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       function _m_(b){return enqueue(res, b);}
       var _n_ = caml_call2(f, i, a);
       return caml_call2(Base_List[19], _n_, _m_);
      });
    return res;
   }
   function filter_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var _l_ = caml_call1(f, a);
       return _l_ ? enqueue(res, a) : _l_;
      });
    return res;
   }
   function filteri(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var _k_ = caml_call2(f, i, a);
       return _k_ ? enqueue(res, a) : _k_;
      });
    return res;
   }
   function map(t, f){
    var res = caml_call1(create, 0);
    caml_call2(iter, t, function(a){return enqueue(res, caml_call1(f, a));});
    return res;
   }
   function mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri, t, function(i, a){return enqueue(res, caml_call2(f, i, a));});
    return res;
   }
   function filter_inplace(q, f){
    var q$0 = filter(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function filteri_inplace(q, f){
    var q$0 = filteri(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function enqueue_all(t, list){
    function _j_(x){return enqueue(t, x);}
    return caml_call2(Base_List[19], list, _j_);
   }
   function of_list(list){
    var t = caml_call1(create, 0);
    function _i_(x){return enqueue(t, x);}
    caml_call2(Base_List[19], list, _i_);
    return t;
   }
   function of_array(array){
    var t = caml_call1(create, 0);
    function _h_(x){return enqueue(t, x);}
    caml_call2(Base_Array[20], array, _h_);
    return t;
   }
   function init(len, f){
    var
     t = caml_call1(create, 0),
     _f_ = caml_call2(Base_Import[93], len, 1),
     _e_ = 0;
    if(_f_ >= 0){
     var i = _e_;
     for(;;){
      enqueue(t, caml_call1(f, i));
      var _g_ = i + 1 | 0;
      if(_f_ === i) break;
      var i = _g_;
     }
    }
    return t;
   }
   function to_array(t){
    var len = caml_call1(length, t);
    if(0 === len) return [0];
    var
     _c_ = caml_call1(peek_exn, t),
     arr = caml_call2(Base_Array[48], len, _c_),
     i = [0, 0];
    caml_call2
     (iter,
      t,
      function(v){
       var _d_ = i[1];
       runtime.caml_check_bound(arr, _d_)[1 + _d_] = v;
       i[1]++;
       return 0;
      });
    return arr;
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_Import[173], a_of_sexp, sexp));
   }
   function sexp_of_t(sexp_of_a, t){
    var _b_ = caml_call1(to_list, t);
    return caml_call2(Base_Import[149], sexp_of_a, _b_);
   }
   function t_sexp_grammar(grammar){
    var _a_ = caml_call1(Base_List[7], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _a_);
   }
   function singleton(a){
    var t = caml_call1(create, 0);
    enqueue(t, a);
    return t;
   }
   var
    Base_Linked_queue =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       dequeue_and_ignore_exn,
       drain,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       create,
       transfer];
   runtime.caml_register_global(6, Base_Linked_queue, "Base__Linked_queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int64
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int64, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Lx = "%Lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int64.Hex",
    module_name$0 = "Base.Int64",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    globalize = Base_Import[286],
    hash_fold_t = Base_Import[203],
    func = Base_Import[217],
    _e_ = [0, [7, 6, 0, 0, 0], cst_Lx],
    _d_ = [0, [7, 6, 0, 0, 0], cst_Lx],
    cst_Int64_ceil_log2_got_invali = "[Int64.ceil_log2] got invalid input",
    cst_Int64_floor_log2_got_inval = "[Int64.floor_log2] got invalid input",
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _b_ = [0, "src/int64.ml", 115, 2],
    _a_ =
      [0,
       [11,
        "Int64.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int64.of_float: argument (%f) is out of range or NaN"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[166],
    sexp_of_t = Base_Import[142],
    t_sexp_grammar = Base_Import[188],
    hashable = [0, hash, Stdlib_Int64[15], sexp_of_t];
   function compare(_I_, _H_){return caml_int64_compare(_I_, _H_);}
   var
    to_string = Stdlib_Int64[14],
    of_string = runtime.caml_int64_of_string,
    of_string_opt = Stdlib_Int64[13],
    include = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t]),
    comparator = include[1],
    float_lower_bound = caml_call1(Base_Float0[26], 64),
    float_upper_bound = caml_call1(Base_Float0[24], 64),
    shift_right_logical = caml_int64_shift_right_unsigne,
    shift_right = runtime.caml_int64_shift_right,
    shift_left = runtime.caml_int64_shift_left,
    bit_not = Stdlib_Int64[11],
    bit_xor = runtime.caml_int64_xor,
    bit_or = caml_int64_or,
    bit_and = caml_int64_and,
    min_value = Stdlib_Int64[10],
    max_value = Stdlib_Int64[9],
    abs = Stdlib_Int64[8],
    pred = Stdlib_Int64[7],
    succ = Stdlib_Int64[6],
    symbol = Base_Int_math[2][2],
    rem = runtime.caml_int64_mod,
    neg = caml_int64_neg,
    minus_one = Stdlib_Int64[3],
    one = Stdlib_Int64[2],
    zero = Stdlib_Int64[1],
    to_float = runtime.caml_int64_to_float,
    of_float_unchecked = caml_int64_of_float,
    num_bits = 64;
   function of_float(f){
    if(float_lower_bound <= f && f <= float_upper_bound)
     return caml_int64_of_float(f);
    var _G_ = caml_call1(Base_Float0[29], f);
    return caml_call3(Base_Printf[7], _a_, _G_, 0);
   }
   function bswap16(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 48);
   }
   function bswap32(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 32);
   }
   function bswap48(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 16);
   }
   var
    include$0 = caml_call1(Base_Comparable[14], [0, compare, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5];
   function invariant(param){return 0;}
   function between(t, low, high){
    var
     _E_ = caml_lessequal(low, t),
     _F_ = _E_ ? caml_lessequal(t, high) : _E_;
    return _F_;
   }
   function clamp_unchecked(t, min, max){
    var _D_ = caml_call2(Base_Import[103][4], t, max);
    return caml_call1(caml_call1(Base_Import[103][3], min), _D_);
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _A_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _B_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _A_],
     _C_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _B_);
    return caml_call1(Base_Or_error[39], _C_);
   }
   function incr(r){r[1] = caml_int64_add(r[1], one); return 0;}
   function decr(r){r[1] = caml_int64_sub(r[1], one); return 0;}
   function of_int64_exn(_z_){return _z_;}
   function to_int64(t){return t;}
   var
    popcount = Base_Popcount[3],
    of_int_exn = caml_int64_of_int32,
    to_int = Base_Int_conversions[12],
    to_int_exn = Base_Int_conversions[13],
    of_int32_exn = caml_int64_of_int32,
    to_int32 = Base_Int_conversions[15],
    to_int32_exn = Base_Int_conversions[16],
    of_nativeint_exn = caml_int64_of_int32,
    to_nativeint = Base_Int_conversions[18],
    to_nativeint_exn = Base_Int_conversions[19],
    raise_s = Base_Error[32];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   var lsr = caml_int64_shift_right_unsigne, land = caml_int64_and;
   function ceil_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int64[7], x),
     x$1 = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 1)),
     x$2 = caml_int64_or(x$1, caml_int64_shift_right_unsigne(x$1, 2)),
     x$3 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 4)),
     x$4 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 8)),
     x$5 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 16)),
     x$6 = caml_int64_or(x$5, caml_int64_shift_right_unsigne(x$5, 32));
    return caml_call1(Stdlib_Int64[6], x$6);
   }
   function floor_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x$0 = caml_int64_or(x, caml_int64_shift_right_unsigne(x, 1)),
     x$1 = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 2)),
     x$2 = caml_int64_or(x$1, caml_int64_shift_right_unsigne(x$1, 4)),
     x$3 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 8)),
     x$4 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 16)),
     x$5 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 32));
    return caml_int64_sub(x$5, caml_int64_shift_right_unsigne(x$5, 1));
   }
   function is_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var _y_ = Stdlib_Int64[1];
    return caml_equal(caml_int64_and(x, caml_call1(Stdlib_Int64[7], x)), _y_);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _v_ = [0, [0, cst, caml_call1(Base_Import[142], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int64_floor_log2_got_inval, _v_));
    }
    var
     _w_ = runtime.Base_int_math_int64_clz(i),
     _x_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _x_, _w_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _t_ = [0, [0, cst$0, caml_call1(Base_Import[142], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int64_ceil_log2_got_invali, _t_));
    }
    if(caml_call2(Stdlib_Int64[17], i, Stdlib_Int64[2])) return 0;
    var _u_ = runtime.Base_int_math_int64_clz(caml_call1(Stdlib_Int64[7], i));
    return caml_call2(Base_Import[93], num_bits, _u_);
   }
   var
    include$1 = caml_call1(Base_Int_string_conversions[1], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare_local = Base_Import[258];
   function compare$0(a, b){return caml_call2(compare_local, a, b);}
   var hash_fold_t$0 = Base_Import[203], func$0 = Base_Import[217];
   function hash$0(x){return caml_call1(func$0, x);}
   var symbol$0 = caml_lessthan;
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    function _r_(_s_){return _s_;}
    return caml_call3(Stdlib_Scanf[5], s, _e_, _r_);
   }
   var
    include$2 =
      caml_call1
       (Base_Int_string_conversions[2],
        [0,
         compare$0,
         compare_local,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$0,
         neg,
         module_name]),
    Hex = include$2[1],
    compare_local$0 = Base_Import[258];
   function compare$1(a, b){return caml_call2(compare_local$0, a, b);}
   var equal_local = Base_Import[272];
   function equal(a, b){return caml_call2(equal_local, a, b);}
   var hash_fold_t$1 = Base_Import[203], func$1 = Base_Import[217];
   function hash$1(x){return caml_call1(func$1, x);}
   function clz(_q_){return runtime.Base_int_math_int64_clz(_q_);}
   var
    include$3 =
      caml_call1
       (Base_Int_string_conversions[3],
        [0,
         compare$1,
         compare_local$0,
         equal,
         equal_local,
         hash_fold_t$1,
         hash$1,
         clz,
         lsr,
         land,
         to_int_exn,
         num_bits,
         one,
         zero]),
    Binary = include$3[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$4 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         caml_int64_add,
         caml_int64_sub,
         runtime.caml_int64_mul,
         runtime.caml_int64_div,
         caml_int64_neg,
         runtime.caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         runtime.caml_notequal,
         abs,
         caml_int64_neg,
         zero,
         of_int_exn,
         rem]),
    symbol$1 = include$4[1],
    symbol$2 = include$4[2],
    symbol$3 = include$4[3],
    round = include$4[4],
    round_towards_zero = include$4[5],
    round_down = include$4[6],
    round_up = include$4[7],
    round_nearest = include$4[8],
    include$5 = Base_Import[103],
    ascending = include$5[1],
    descending = include$5[2],
    max = include$5[3],
    min = include$5[4],
    _f_ = [0, symbol, bit_not, abs, zero, symbol$1, symbol$2, symbol$3];
   function _g_(_p_){return runtime.Base_int_math_int64_ctz(_p_);}
   function _h_(_o_){return runtime.Base_int_math_int64_clz(_o_);}
   var _i_ = caml_equal;
   function _j_(_n_, _m_){return caml_int64_compare(_n_, _m_);}
   var
    Base_Int64 =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       caml_equal,
       function(_l_, _k_){return caml_int64_compare(_l_, _k_);},
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       _j_,
       _i_,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       symbol,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       _h_,
       _g_,
       _f_,
       symbol,
       bit_not,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       to_int,
       to_int32,
       to_nativeint,
       bswap16,
       bswap32,
       bswap48];
   runtime.caml_register_global(30, Base_Int64, "Base__Int64");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63_emul
//# unitInfo: Requires: Base__Comparable, Base__Comparator, Base__Float0, Base__Import, Base__Int64, Base__Int_conversions, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_int63_emul_ml = "src/int63_emul.ml",
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_string = runtime.caml_int64_of_string,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    mask = runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
    module_name = "Base.Int63.Hex",
    module_name$0 = "Base.Int63",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Int64 = global_data.Base__Int64,
    Base_String = global_data.Base__String,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Popcount = global_data.Base__Popcount,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    include = Base_Import[103],
    max = include[3],
    min = include[4],
    compare_local = Base_Import[258],
    cst_0x = "0x",
    _l_ = [0, [7, 6, 0, 0, 0], "%Lx"],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _k_ = [0, cst_src_int63_emul_ml, 334, 2],
    _i_ =
      [0,
       [11,
        "Int63.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int63.of_float: argument (%f) is out of range or NaN"],
    _h_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ =
      [0,
       [11, "Int63.of_string: invalid input ", [3, 0, 0]],
       "Int63.of_string: invalid input %S"],
    _e_ = [0, cst_src_int63_emul_ml, 117, 20],
    _d_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _a_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _f_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0);
   function compare(a, b){return caml_call2(compare_local, a, b);}
   var
    globalize = Base_Import[286],
    hash_fold_t = Base_Import[203],
    sexp_of_t = Base_Import[142],
    t_sexp_grammar = Base_Import[188],
    include$0 = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t]),
    comparator = include$0[1];
   function wrap_exn(x){
    caml_call1(Base_Int_conversions[21], x);
    return caml_int64_mul(x, _a_);
   }
   function wrap_modulo(x){return caml_int64_mul(x, _c_);}
   function unwrap(x){return caml_int64_shift_right(x, 1);}
   function m(x){return caml_int64_and(x, mask);}
   function invariant(t){
    if(caml_equal(m(t), t)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   var
    symbol = caml_int64_add,
    symbol$0 = caml_int64_sub,
    symbol$1 = caml_int64_neg;
   function abs(x){return caml_call1(Stdlib_Int64[8], x);}
   var one = wrap_exn(_f_);
   function succ(a){return caml_int64_add(a, one);}
   function pred(a){return caml_int64_sub(a, one);}
   var min_value = m(Stdlib_Int64[10]), max_value = m(Stdlib_Int64[9]);
   function bit_not(x){return m(caml_call1(Stdlib_Int64[11], x));}
   var
    bit_and = caml_int64_and,
    bit_xor = runtime.caml_int64_xor,
    bit_or = runtime.caml_int64_or,
    shift_left = runtime.caml_int64_shift_left;
   function shift_right(x, i){return m(caml_int64_shift_right(x, i));}
   function shift_right_logical(x, i){
    return m(caml_int64_shift_right_unsigne(x, i));
   }
   var f = Base_Int_math[2][3];
   function pow(a, b){
    return caml_int64_mul
            (caml_call2
              (f, caml_int64_shift_right(a, 1), caml_int64_shift_right(b, 1)),
             _d_);
   }
   function symbol$2(a, b){
    return caml_int64_mul(a, caml_int64_shift_right(b, 1));
   }
   function symbol$3(a, b){return wrap_modulo(runtime.caml_int64_div(a, b));}
   var rem = runtime.caml_int64_mod;
   function popcount(x){return caml_call1(Base_Popcount[3], x);}
   function to_int64(t){return caml_int64_shift_right(t, 1);}
   function of_int64(t){
    return caml_call1(Base_Int_conversions[22], t)
            ? [0, caml_int64_mul(t, _b_)]
            : 0;
   }
   function of_int64_exn(t){return wrap_exn(t);}
   function of_int64_trunc(t){return wrap_modulo(t);}
   function t_of_sexp(x){return wrap_exn(caml_call1(Base_Import[166], x));}
   function sexp_of_t$0(x){
    return caml_call1(Base_Import[142], caml_int64_shift_right(x, 1));
   }
   function compare$0(x, y){return compare(x, y);}
   function compare_local$0(x, y){return caml_call2(compare_local, x, y);}
   var equal_local = caml_equal;
   function is_pow2(x){
    return caml_call1(Base_Int64[72], caml_int64_shift_right(x, 1));
   }
   function clz(x){return caml_call1(Base_Int64[73], x);}
   function ctz(x){
    return caml_call1(Base_Int64[74], caml_int64_shift_right(x, 1));
   }
   function floor_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[69], caml_int64_shift_right(x, 1)));
   }
   function ceil_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[69], caml_int64_shift_right(x, 1)));
   }
   function floor_log2(x){
    return caml_call1(Base_Int64[71], caml_int64_shift_right(x, 1));
   }
   function ceil_log2(x){
    return caml_call1(Base_Int64[70], caml_int64_shift_right(x, 1));
   }
   function hash(x){return caml_call1(Base_Import[85][105][28], x);}
   var hashable = [0, hash, compare$0, sexp_of_t$0];
   function invalid_str(x){return caml_call3(Base_Printf[6], _g_, x, 0);}
   function to_string(x){
    return caml_call1(Stdlib_Int64[14], caml_int64_shift_right(x, 1));
   }
   function of_string_raw(str){
    var len = caml_ml_string_length(str);
    a:
    if(0 < len){
     var switcher = caml_string_get(str, 0) - 43 | 0;
     if(2 >= switcher >>> 0)
      switch(switcher){
        case 0:
         var sign = 4003188, pos = 1; break a;
        case 1: break;
        default: var sign = 3901488, pos = 1; break a;
      }
     var sign = 4003188, pos = 0;
    }
    else
     var sign = 4003188, pos = 0;
    if(caml_call2(Base_Import[91], pos, 2) < len)
     var
      c1 = caml_string_get(str, pos),
      c2 = caml_string_get(str, caml_call2(Base_Import[91], pos, 1)),
      match = 48 === c1 ? 9 < c2 - 48 >>> 0 ? [0, , 0] : [0, , 1] : [0, , 1];
    else
     var match = [0, , 1];
    var signedness = match[2];
    if(signedness) return of_int64_exn(caml_int64_of_string(str));
    if(4003188 <= sign)
     var pos_str = str;
    else
     var
      _E_ = caml_call2(Base_Import[93], caml_ml_string_length(str), 1),
      pos_str = caml_call3(Base_String[3], str, 1, _E_);
    var int64 = caml_int64_of_string(pos_str);
    if(caml_lessthan(int64, _h_)) invalid_str(str);
    var int63 = wrap_modulo(int64);
    return 4003188 <= sign ? int63 : caml_int64_neg(int63);
   }
   function of_string(str){
    try{var _C_ = of_string_raw(str); return _C_;}
    catch(_D_){return invalid_str(str);}
   }
   function of_string_opt(str){
    try{var t = of_string_raw(str);}catch(_B_){return 0;}
    return [0, t];
   }
   function bswap16(t){
    return wrap_modulo
            (caml_call1(Base_Int64[86], caml_int64_shift_right(t, 1)));
   }
   function bswap32(t){
    return wrap_modulo
            (caml_call1(Base_Int64[87], caml_int64_shift_right(t, 1)));
   }
   function bswap48(t){
    return wrap_modulo
            (caml_call1(Base_Int64[88], caml_int64_shift_right(t, 1)));
   }
   var
    float_lower_bound = caml_call1(Base_Float0[26], 63),
    float_upper_bound = caml_call1(Base_Float0[24], 63),
    minus_one = wrap_exn(Stdlib_Int64[3]),
    one$0 = wrap_exn(Stdlib_Int64[2]),
    zero = wrap_exn(Stdlib_Int64[1]),
    num_bits = 63;
   function to_float(x){
    return runtime.caml_int64_to_float(caml_int64_shift_right(x, 1));
   }
   function of_float_unchecked(x){return wrap_modulo(caml_int64_of_float(x));}
   function of_float(t){
    if(float_lower_bound <= t && t <= float_upper_bound)
     return wrap_modulo(caml_int64_of_float(t));
    var _A_ = caml_call1(Base_Float0[29], t);
    return caml_call3(Base_Printf[7], _i_, _A_, 0);
   }
   var
    _j_ = caml_call1(Base_Comparable[14], [0, compare$0, sexp_of_t$0, zero]),
    is_positive = _j_[1],
    is_non_negative = _j_[2],
    is_negative = _j_[3],
    is_non_positive = _j_[4],
    sign = _j_[5];
   function between(t, low, high){
    var
     _y_ = caml_lessequal(low, t),
     _z_ = _y_ ? caml_lessequal(t, high) : _y_;
    return _z_;
   }
   function clamp_unchecked(t, min$0, max$0){
    var _x_ = caml_call2(min, t, max$0);
    return caml_call1(caml_call1(max, min$0), _x_);
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _u_ = [0, [0, cst_max, sexp_of_t$0(max)], 0],
     _v_ = [0, [0, cst_min, sexp_of_t$0(min)], _u_],
     _w_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _v_);
    return caml_call1(Base_Or_error[39], _w_);
   }
   function symbol$4(b, e){return pow(b, e);}
   function incr(r){r[1] = caml_int64_add(r[1], one$0); return 0;}
   function decr(r){r[1] = caml_int64_sub(r[1], one$0); return 0;}
   function of_int(x){
    return wrap_exn(caml_call1(Base_Int_conversions[4], x));
   }
   function of_int_exn(x){return of_int(x);}
   function to_int(x){
    return caml_call1(Base_Int_conversions[12], caml_int64_shift_right(x, 1));
   }
   function to_int_exn(x){
    return caml_call1(Base_Int_conversions[13], caml_int64_shift_right(x, 1));
   }
   function to_int_trunc(x){
    return caml_call1(Base_Int_conversions[14], caml_int64_shift_right(x, 1));
   }
   function of_int32(x){
    return wrap_exn(caml_call1(Base_Int_conversions[9], x));
   }
   function of_int32_exn(x){return of_int32(x);}
   function to_int32(x){
    return caml_call1(Base_Int_conversions[15], caml_int64_shift_right(x, 1));
   }
   function to_int32_exn(x){
    return caml_call1(Base_Int_conversions[16], caml_int64_shift_right(x, 1));
   }
   function to_int32_trunc(x){
    return caml_call1(Base_Int_conversions[17], caml_int64_shift_right(x, 1));
   }
   function of_nativeint(x){
    return of_int64(caml_call1(Base_Int_conversions[29], x));
   }
   function of_nativeint_exn(x){
    return wrap_exn(caml_call1(Base_Int_conversions[29], x));
   }
   function of_nativeint_trunc(x){
    return of_int64_trunc(caml_call1(Base_Int_conversions[29], x));
   }
   function to_nativeint(x){
    return caml_call1(Base_Int_conversions[18], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_exn(x){
    return caml_call1(Base_Int_conversions[19], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_trunc(x){
    return caml_call1(Base_Int_conversions[20], caml_int64_shift_right(x, 1));
   }
   var
    include$1 = caml_call1(Base_Int_string_conversions[1], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$1 = include$1[2];
   function compare$1(a, b){return compare_local$0(a, b);}
   function hash$0(x){return hash(x);}
   var symbol$5 = caml_lessthan;
   function to_string$0(i){
    return caml_call2
            (Base_Printf[2], _l_, caml_int64_shift_right_unsigne(i, 1));
   }
   function of_string$0(s){
    return of_string(caml_call2(Base_Import[112], cst_0x, s));
   }
   var
    include$2 =
      caml_call1
       (Base_Int_string_conversions[2],
        [0,
         compare$1,
         compare_local$0,
         hash_fold_t,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$5,
         symbol$1,
         module_name]),
    Hex = include$2[1];
   function to_string$1(x){return to_string(x);}
   var
    pp =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string$1])[1],
    symbol$6 = caml_notequal,
    symbol$7 = caml_lessthan,
    symbol$8 = caml_greaterthan,
    symbol$9 = caml_equal,
    symbol$10 = caml_lessequal,
    symbol$11 = caml_greaterequal,
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol,
         symbol$0,
         symbol$2,
         symbol$3,
         symbol$1,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$1,
         zero,
         of_int_exn,
         rem]),
    symbol$12 = include$3[1],
    symbol$13 = include$3[2],
    symbol$14 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8];
   function compare$2(a, b){return compare_local$0(a, b);}
   var equal = caml_equal;
   function hash$1(x){return hash(x);}
   var
    include$4 =
      caml_call1
       (Base_Int_string_conversions[3],
        [0,
         compare$2,
         compare_local$0,
         equal,
         equal_local,
         hash_fold_t,
         hash$1,
         clz,
         shift_right_logical,
         bit_and,
         to_int_exn,
         num_bits,
         one$0,
         zero]),
    Binary = include$4[1],
    Repr = [0],
    include$5 = Base_Import[103],
    ascending = include$5[1],
    descending = include$5[2],
    max$0 = include$5[3],
    min$0 = include$5[4],
    repr = 1,
    _m_ = [0, wrap_exn, unwrap],
    _n_ =
      [0,
       symbol,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol$1,
       symbol$4,
       symbol$11,
       symbol$10,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$6,
       abs,
       symbol$1,
       zero,
       symbol$12,
       symbol$13,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       shift_right_logical],
    _o_ = caml_equal;
   function _p_(_t_, _s_){return caml_int64_compare(_t_, _s_);}
   var
    Base_Int63_emul =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       to_string,
       caml_greaterequal,
       caml_lessequal,
       caml_equal,
       caml_greaterthan,
       caml_lessthan,
       caml_notequal,
       caml_equal,
       function(_r_, _q_){return caml_int64_compare(_r_, _q_);},
       min$0,
       max$0,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       _p_,
       _o_,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       zero,
       one$0,
       minus_one,
       symbol,
       symbol$0,
       symbol$2,
       symbol$4,
       symbol$1,
       symbol$1,
       symbol$13,
       symbol$12,
       symbol$3,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       clz,
       ctz,
       _n_,
       of_int,
       to_int,
       to_int_trunc,
       of_int32,
       to_int32,
       to_int32_trunc,
       of_int64,
       of_int64_trunc,
       of_nativeint,
       to_nativeint,
       of_nativeint_trunc,
       to_nativeint_trunc,
       bswap16,
       bswap32,
       bswap48,
       _m_,
       Repr,
       repr];
   runtime.caml_register_global(34, Base_Int63_emul, "Base__Int63_emul");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int32
//# unitInfo: Requires: Base__Bool0, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Int_string_conversions, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int32, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_lx = "%lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_lessequal = runtime.caml_lessequal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int32.Hex",
    module_name$0 = "Base.Int32",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Int_math = global_data.Base__Int_math,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    globalize = Base_Import[285],
    hash_fold_t = Base_Import[204],
    func = Base_Import[218],
    _e_ = [0, [5, 6, 0, 0, 0], cst_lx],
    _d_ = [0, [5, 6, 0, 0, 0], cst_lx],
    cst_Int32_ceil_log2_got_invali = "[Int32.ceil_log2] got invalid input",
    cst_Int32_floor_log2_got_inval = "[Int32.floor_log2] got invalid input",
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _b_ = [0, "src/int32.ml", 103, 4],
    _a_ =
      [0,
       [11,
        "Int32.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int32.of_float: argument (%f) is out of range or NaN"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[165],
    sexp_of_t = Base_Import[141],
    t_sexp_grammar = Base_Import[187],
    hashable = [0, hash, Stdlib_Int32[15], sexp_of_t];
   function ascending(x, y){return caml_call2(Stdlib_Int32[15], x, y);}
   var
    to_string = Stdlib_Int32[14],
    of_string = runtime.caml_int_of_string,
    of_string_opt = Stdlib_Int32[13],
    include = caml_call1(Base_Comparator[7], [0, ascending, sexp_of_t]),
    comparator = include[1],
    float_lower_bound = caml_call1(Base_Float0[26], 32),
    float_upper_bound = caml_call1(Base_Float0[24], 32),
    float_of_bits = runtime.caml_int32_float_of_bits,
    bits_of_float = runtime.caml_int32_bits_of_float,
    num_bits = 32;
   function shift_right_logical(_X_, _W_){return _X_ >>> _W_ | 0;}
   function shift_right(_V_, _U_){return _V_ >> _U_;}
   function shift_left(_T_, _S_){return _T_ << _S_;}
   var bit_not = Stdlib_Int32[11];
   function bit_xor(_R_, _Q_){return _R_ ^ _Q_;}
   function bit_or(_P_, _O_){return _P_ | _O_;}
   function bit_and(_N_, _M_){return _N_ & _M_;}
   var
    min_value = Stdlib_Int32[10],
    max_value = Stdlib_Int32[9],
    abs = Stdlib_Int32[8],
    pred = Stdlib_Int32[7],
    succ = Stdlib_Int32[6],
    rem = runtime.caml_mod;
   function symbol(_L_){return - _L_ | 0;}
   var
    minus_one = Stdlib_Int32[3],
    one = Stdlib_Int32[2],
    zero = Stdlib_Int32[1],
    compare_local = runtime.caml_compare;
   function to_float(_K_){return _K_;}
   function of_float_unchecked(_J_){return _J_ | 0;}
   function of_float(f){
    if(float_lower_bound <= f && f <= float_upper_bound) return f | 0;
    var _I_ = caml_call1(Base_Float0[29], f);
    return caml_call3(Base_Printf[7], _a_, _I_, 0);
   }
   var
    include$0 =
      caml_call1(Base_Comparable[14], [0, ascending, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5],
    symbol$0 = caml_greaterequal,
    symbol$1 = caml_lessequal,
    symbol$2 = caml_equal,
    symbol$3 = caml_greaterthan,
    symbol$4 = runtime.caml_lessthan,
    symbol$5 = runtime.caml_notequal;
   function descending(x, y){return ascending(y, x);}
   function min(x, y){
    return runtime.caml_csel_value(caml_lessequal(x, y), x, y);
   }
   function max(x, y){
    return runtime.caml_csel_value(caml_greaterequal(x, y), x, y);
   }
   var equal = caml_equal, equal_local = caml_equal;
   function between(t, low, high){
    var _H_ = caml_lessequal(low, t);
    return _H_ ? caml_lessequal(t, high) : _H_;
   }
   function clamp_unchecked(t, min$0, max$0){return max(min$0, min(t, max$0));
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _E_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _F_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _E_],
     _G_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _F_);
    return caml_call1(Base_Or_error[39], _G_);
   }
   function invariant(param){return 0;}
   var symbol$6 = runtime.caml_div, symbol$7 = runtime.caml_mul;
   function symbol$8(_D_, _C_){return _D_ - _C_ | 0;}
   function symbol$9(_B_, _A_){return _B_ + _A_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_int32(t){return t;}
   function to_int32(t){return t;}
   var
    popcount = Base_Popcount[2],
    of_int = Base_Int_conversions[1],
    of_int_exn = Base_Int_conversions[2],
    of_int_trunc = Base_Int_conversions[3],
    to_int = Base_Int_conversions[6],
    to_int_exn = Base_Int_conversions[7],
    to_int_trunc = Base_Int_conversions[8],
    of_int64 = Base_Int_conversions[15],
    of_int64_exn = Base_Int_conversions[16],
    of_int64_trunc = Base_Int_conversions[17],
    to_int64 = Base_Int_conversions[9],
    of_nativeint = Base_Int_conversions[26],
    of_nativeint_exn = Base_Int_conversions[27],
    of_nativeint_trunc = Base_Int_conversions[28],
    to_nativeint = Base_Int_conversions[10];
   function pow(b, e){
    var _y_ = caml_call1(to_int_exn, e), _z_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _z_, _y_));
   }
   function symbol$10(b, e){return pow(b, e);}
   function bswap16(x){return caml_int32_bswap(x) >>> 16 | 0;}
   var raise_s = Base_Error[32];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   function lsr(_x_, _w_){return _x_ >>> _w_ | 0;}
   function land(_v_, _u_){return _v_ & _u_;}
   function ceil_pow2(x){
    if(caml_call2(Base_Import[102][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int32[7], x),
     x$1 = x$0 | x$0 >>> 1 | 0,
     x$2 = x$1 | x$1 >>> 2 | 0,
     x$3 = x$2 | x$2 >>> 4 | 0,
     x$4 = x$3 | x$3 >>> 8 | 0,
     x$5 = x$4 | x$4 >>> 16 | 0;
    return caml_call1(Stdlib_Int32[6], x$5);
   }
   function floor_pow2(x){
    if(caml_call2(Base_Import[102][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x$0 = x | x >>> 1 | 0,
     x$1 = x$0 | x$0 >>> 2 | 0,
     x$2 = x$1 | x$1 >>> 4 | 0,
     x$3 = x$2 | x$2 >>> 8 | 0,
     x$4 = x$3 | x$3 >>> 16 | 0;
    return x$4 - (x$4 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[102][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var _s_ = Stdlib_Int32[1], _t_ = x & caml_call1(Stdlib_Int32[7], x);
    return caml_call2(Base_Import[102][4], _t_, _s_);
   }
   function floor_log2(i){
    if(caml_call2(Base_Import[102][2], i, Stdlib_Int32[1])){
     var _p_ = [0, [0, cst, caml_call1(Base_Import[141], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int32_floor_log2_got_inval, _p_));
    }
    var
     _q_ = runtime.Base_int_math_int32_clz(i),
     _r_ = caml_call2(Base_Import[93], num_bits, 1);
    return caml_call2(Base_Import[93], _r_, _q_);
   }
   function ceil_log2(i){
    if(caml_call2(Base_Import[102][2], i, Stdlib_Int32[1])){
     var _n_ = [0, [0, cst$0, caml_call1(Base_Import[141], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int32_ceil_log2_got_invali, _n_));
    }
    if(caml_call2(Stdlib_Int32[17], i, Stdlib_Int32[2])) return 0;
    var _o_ = runtime.Base_int_math_int32_clz(caml_call1(Stdlib_Int32[7], i));
    return caml_call2(Base_Import[93], num_bits, _o_);
   }
   var
    include$1 = caml_call1(Base_Int_string_conversions[1], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare_local$0 = Base_Import[257];
   function compare(a, b){return caml_call2(compare_local$0, a, b);}
   var hash_fold_t$0 = Base_Import[204], func$0 = Base_Import[218];
   function hash$0(x){return caml_call1(func$0, x);}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    function _l_(_m_){return _m_;}
    return caml_call3(Stdlib_Scanf[5], s, _e_, _l_);
   }
   var
    include$2 =
      caml_call1
       (Base_Int_string_conversions[2],
        [0,
         compare,
         compare_local$0,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$4,
         symbol,
         module_name]),
    Hex = include$2[1],
    compare_local$1 = Base_Import[257];
   function compare$0(a, b){return caml_call2(compare_local$1, a, b);}
   var equal_local$0 = Base_Import[271];
   function equal$0(a, b){return caml_call2(equal_local$0, a, b);}
   var hash_fold_t$1 = Base_Import[204], func$1 = Base_Import[218];
   function hash$1(x){return caml_call1(func$1, x);}
   function clz(_k_){return runtime.Base_int_math_int32_clz(_k_);}
   var
    include$3 =
      caml_call1
       (Base_Int_string_conversions[3],
        [0,
         compare$0,
         compare_local$1,
         equal$0,
         equal_local$0,
         hash_fold_t$1,
         hash$1,
         clz,
         lsr,
         land,
         to_int_exn,
         num_bits,
         one,
         zero]),
    Binary = include$3[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$4 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         symbol,
         symbol$0,
         symbol$1,
         symbol$2,
         symbol$3,
         symbol$4,
         symbol$5,
         abs,
         symbol,
         zero,
         of_int_exn,
         rem]),
    symbol$11 = include$4[1],
    symbol$12 = include$4[2],
    symbol$13 = include$4[3],
    round = include$4[4],
    round_towards_zero = include$4[5],
    round_down = include$4[6],
    round_up = include$4[7],
    round_nearest = include$4[8],
    _f_ = caml_int32_bswap,
    _g_ =
      [0,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$6,
       symbol,
       symbol$10,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       abs,
       symbol,
       zero,
       symbol$11,
       symbol$12,
       symbol$13,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       shift_right_logical];
   function _h_(_j_){return runtime.Base_int_math_int32_ctz(_j_);}
   var
    Base_Int32 =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       ascending,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       compare_local,
       equal_local,
       invariant,
       Hex,
       Binary,
       of_string_opt,
       to_string_hum,
       zero,
       one,
       minus_one,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$10,
       symbol,
       symbol,
       symbol$12,
       symbol$11,
       symbol$6,
       rem,
       symbol$13,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_i_){return runtime.Base_int_math_int32_clz(_i_);},
       _h_,
       _g_,
       of_int,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       of_int_trunc,
       to_int_trunc,
       of_nativeint_trunc,
       of_int64_trunc,
       bits_of_float,
       float_of_bits,
       bswap16,
       _f_];
   runtime.caml_register_global(30, Base_Int32, "Base__Int32");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63
//# unitInfo: Requires: Base__Bool, Base__Error, Base__Import, Base__Int, Base__Int63_emul, Base__Int64, Base__Random, Base__Sexp, Base__Sys0, Base__Word_size
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_product$1 = "product",
    cst_t$3 = "t",
    cst_u$3 = "u",
    caml_div = runtime.caml_div,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Word_size = global_data.Base__Word_size,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Int64 = global_data.Base__Int64,
    Base_Error = global_data.Base__Error,
    Base_Int63_emul = global_data.Base__Int63_emul,
    Base_Sys0 = global_data.Base__Sys0,
    Assert_failure = global_data.Assert_failure,
    raise_s = Base_Error[32],
    include = caml_call1(caml_call1(Base_Sys0[19], [0]), [0]),
    t_sexp_grammar = Base_Int[2],
    of_float = Base_Int[3],
    to_float = Base_Int[4],
    of_int_exn = Base_Int[5],
    to_int_exn = Base_Int[6],
    hash_fold_t = Base_Int[7],
    hash = Base_Int[8],
    t_of_sexp = Base_Int[9],
    sexp_of_t = Base_Int[10],
    of_string = Base_Int[11],
    to_string = Base_Int[12],
    equal = Base_Int[13],
    compare = Base_Int[14],
    min = Base_Int[15],
    max = Base_Int[16],
    ascending = Base_Int[17],
    descending = Base_Int[18],
    between = Base_Int[19],
    clamp_exn = Base_Int[20],
    clamp = Base_Int[21],
    comparator = Base_Int[22],
    pp = Base_Int[23],
    hashable = Base_Int[24],
    is_positive = Base_Int[25],
    is_non_negative = Base_Int[26],
    is_negative = Base_Int[27],
    is_non_positive = Base_Int[28],
    sign = Base_Int[29],
    compare_local = Base_Int[30],
    equal_local = Base_Int[31],
    invariant = Base_Int[32],
    Hex = Base_Int[33],
    Binary = Base_Int[34],
    of_string_opt = Base_Int[35],
    to_string_hum = Base_Int[36],
    one = Base_Int[37],
    minus_one = Base_Int[38],
    rem = Base_Int[39],
    round = Base_Int[40],
    round_towards_zero = Base_Int[41],
    round_down = Base_Int[42],
    round_up = Base_Int[43],
    round_nearest = Base_Int[44],
    succ = Base_Int[45],
    pred = Base_Int[46],
    pow = Base_Int[47],
    bit_and = Base_Int[48],
    bit_or = Base_Int[49],
    bit_xor = Base_Int[50],
    bit_not = Base_Int[51],
    popcount = Base_Int[52],
    shift_left = Base_Int[53],
    shift_right = Base_Int[54],
    decr = Base_Int[55],
    incr = Base_Int[56],
    of_int32_exn = Base_Int[57],
    to_int32_exn = Base_Int[58],
    of_int64_exn = Base_Int[59],
    to_int64 = Base_Int[60],
    of_nativeint_exn = Base_Int[61],
    to_nativeint_exn = Base_Int[62],
    of_float_unchecked = Base_Int[63],
    num_bits = Base_Int[64],
    max_value = Base_Int[65],
    min_value = Base_Int[66],
    shift_right_logical = Base_Int[67],
    ceil_pow2 = Base_Int[68],
    floor_pow2 = Base_Int[69],
    ceil_log2 = Base_Int[70],
    is_pow2 = Base_Int[72],
    clz = Base_Int[73],
    ctz = Base_Int[74],
    O = Base_Int[75],
    symbol = Base_Int[76],
    lnot = Base_Int[77],
    abs = Base_Int[78],
    zero = Base_Int[79],
    symbol$0 = Base_Int[80],
    symbol$1 = Base_Int[81],
    symbol$2 = Base_Int[82],
    of_int = Base_Int[84],
    to_int32 = Base_Int[87],
    of_int64 = Base_Int[88],
    of_nativeint = Base_Int[89],
    _b_ = Base_Int[90],
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    cst_neg_overflow = "neg overflow",
    cst_abs_overflow = "abs overflow",
    cst_product$0 = cst_product$1,
    cst_u$2 = cst_u$3,
    cst_t$2 = cst_t$3,
    cst_overflow$2 = "( / ) overflow",
    cst_product = cst_product$1,
    cst_u$1 = cst_u$3,
    cst_t$1 = cst_t$3,
    cst_overflow$1 = "( * ) overflow",
    cst_diff = "diff",
    cst_u$0 = cst_u$3,
    cst_t$0 = cst_t$3,
    cst_overflow$0 = "( - ) overflow",
    cst_sum = "sum",
    cst_u = cst_u$3,
    cst_t = cst_t$3,
    cst_overflow = "( + ) overflow",
    _c_ = [0, "src/int63.ml", 110, 9],
    _a_ = include[1];
   function to_int(x){return [0, x];}
   function to_int_trunc(x){return x;}
   function to_nativeint_trunc(x){return caml_call1(_b_, x);}
   function to_nativeint(x){return [0, caml_call1(_b_, x)];}
   var repr = 0;
   function bswap32(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[87], caml_int64_of_int32(t)));
   }
   function bswap48(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[88], caml_int64_of_int32(t)));
   }
   if(_a_)
    var
     include$0 =
       [0,
        Base_Int63_emul[2],
        Base_Int63_emul[3],
        Base_Int63_emul[4],
        Base_Int63_emul[5],
        Base_Int63_emul[6],
        Base_Int63_emul[7],
        Base_Int63_emul[8],
        Base_Int63_emul[9],
        Base_Int63_emul[10],
        Base_Int63_emul[11],
        Base_Int63_emul[12],
        Base_Int63_emul[13],
        Base_Int63_emul[14],
        Base_Int63_emul[15],
        Base_Int63_emul[16],
        Base_Int63_emul[17],
        Base_Int63_emul[18],
        Base_Int63_emul[19],
        Base_Int63_emul[20],
        Base_Int63_emul[21],
        Base_Int63_emul[22],
        Base_Int63_emul[23],
        Base_Int63_emul[24],
        Base_Int63_emul[25],
        Base_Int63_emul[26],
        Base_Int63_emul[27],
        Base_Int63_emul[28],
        Base_Int63_emul[29],
        Base_Int63_emul[30],
        Base_Int63_emul[31],
        Base_Int63_emul[32],
        Base_Int63_emul[33],
        Base_Int63_emul[34],
        Base_Int63_emul[35],
        Base_Int63_emul[36],
        Base_Int63_emul[37],
        Base_Int63_emul[38],
        Base_Int63_emul[39],
        Base_Int63_emul[40],
        Base_Int63_emul[41],
        Base_Int63_emul[42],
        Base_Int63_emul[43],
        Base_Int63_emul[44],
        Base_Int63_emul[45],
        Base_Int63_emul[46],
        Base_Int63_emul[47],
        Base_Int63_emul[48],
        Base_Int63_emul[49],
        Base_Int63_emul[50],
        Base_Int63_emul[51],
        Base_Int63_emul[52],
        Base_Int63_emul[53],
        Base_Int63_emul[54],
        Base_Int63_emul[55],
        Base_Int63_emul[56],
        Base_Int63_emul[57],
        Base_Int63_emul[58],
        Base_Int63_emul[59],
        Base_Int63_emul[60],
        Base_Int63_emul[61],
        Base_Int63_emul[62],
        Base_Int63_emul[63],
        Base_Int63_emul[64],
        Base_Int63_emul[65],
        Base_Int63_emul[66],
        Base_Int63_emul[67],
        Base_Int63_emul[68],
        Base_Int63_emul[69],
        Base_Int63_emul[70],
        Base_Int63_emul[71],
        Base_Int63_emul[72],
        Base_Int63_emul[73],
        Base_Int63_emul[74],
        Base_Int63_emul[75],
        Base_Int63_emul[76],
        Base_Int63_emul[77],
        Base_Int63_emul[78],
        Base_Int63_emul[79],
        Base_Int63_emul[80],
        Base_Int63_emul[81],
        Base_Int63_emul[82],
        Base_Int63_emul[83],
        Base_Int63_emul[84],
        Base_Int63_emul[85],
        Base_Int63_emul[86],
        Base_Int63_emul[88],
        Base_Int63_emul[89],
        Base_Int63_emul[90],
        Base_Int63_emul[91],
        Base_Int63_emul[92],
        Base_Int63_emul[93],
        Base_Int63_emul[94],
        Base_Int63_emul[95],
        ,
        Base_Int63_emul[97],
        Base_Int63_emul[98],
        Base_Int63_emul[99],
        Base_Int63_emul[100],
        Base_Int63_emul[101],
        Base_Int63_emul[102],
        Base_Int63_emul[103],
        Base_Int63_emul[104],
        Base_Int63_emul[105],
        Base_Int63_emul[106],
        Base_Int63_emul[107],
        Base_Int63_emul[108],
        Base_Int63_emul[109],
        Base_Int63_emul[110],
        Base_Int63_emul[111],
        Base_Int63_emul[112],
        Base_Int63_emul[87],
        Base_Int63_emul[118],
        Base_Int63_emul[113],
        Base_Int63_emul[114],
        Base_Int63_emul[115]];
   else
    var
     _d_ = runtime.caml_bswap16,
     _e_ = function(_bp_){return _bp_;},
     _f_ = caml_int64_to_int32,
     _g_ = function(_bo_){return _bo_;},
     _h_ = function(_bn_, _bm_){return _bn_ >>> _bm_ | 0;},
     _i_ = function(_bl_, _bk_){return _bl_ >> _bk_;},
     _j_ = function(_bj_, _bi_){return _bj_ << _bi_;},
     _k_ = O[2],
     _l_ = function(_bh_, _bg_){return _bh_ ^ _bg_;},
     _m_ = function(_bf_, _be_){return _bf_ | _be_;},
     _n_ = function(_bd_, _bc_){return _bd_ & _bc_;},
     _o_ = O[7],
     _p_ = O[6],
     _q_ = O[5],
     _r_ = O[4],
     _s_ = function(_bb_){return - _bb_ | 0;},
     _t_ = O[3],
     _u_ = function(_ba_, _a$_){return _ba_ !== _a$_ ? 1 : 0;},
     _v_ = function(_a__, _a9_){return _a__ < _a9_ ? 1 : 0;},
     _w_ = function(_a8_, _a7_){return _a7_ < _a8_ ? 1 : 0;},
     _x_ = function(_a6_, _a5_){return _a6_ === _a5_ ? 1 : 0;},
     _y_ = function(_a4_, _a3_){return _a4_ <= _a3_ ? 1 : 0;},
     _z_ = function(_a2_, _a1_){return _a1_ <= _a2_ ? 1 : 0;},
     _A_ = O[1],
     _B_ = function(_a0_){return - _a0_ | 0;},
     _C_ = caml_div,
     _D_ = caml_mul,
     _E_ = function(_aZ_, _aY_){return _aZ_ - _aY_ | 0;},
     _F_ =
       [0,
        function(_aX_, _aW_){return _aX_ + _aW_ | 0;},
        _E_,
        _D_,
        _C_,
        _B_,
        _A_,
        _z_,
        _y_,
        _x_,
        _w_,
        _v_,
        _u_,
        _t_,
        _s_,
        _r_,
        _q_,
        _p_,
        _o_,
        _n_,
        _m_,
        _l_,
        _k_,
        _j_,
        _i_,
        _h_],
     _G_ = function(_aV_, _aU_){return _aV_ >>> _aU_ | 0;},
     _H_ = function(_aT_, _aS_){return _aT_ >> _aS_;},
     _I_ = function(_aR_, _aQ_){return _aR_ << _aQ_;},
     _J_ = function(_aP_, _aO_){return _aP_ ^ _aO_;},
     _K_ = function(_aN_, _aM_){return _aN_ | _aM_;},
     _L_ = function(_aL_, _aK_){return _aL_ & _aK_;},
     _M_ = caml_div,
     _N_ = function(_aJ_){return - _aJ_ | 0;},
     _O_ = function(_aI_){return - _aI_ | 0;},
     _P_ = caml_mul,
     _Q_ = function(_aH_, _aG_){return _aH_ - _aG_ | 0;},
     _R_ = function(_aF_, _aE_){return _aF_ + _aE_ | 0;},
     _S_ = function(_aD_, _aC_){return _aD_ !== _aC_ ? 1 : 0;},
     _T_ = function(_aB_, _aA_){return _aB_ < _aA_ ? 1 : 0;},
     _U_ = function(_az_, _ay_){return _ay_ < _az_ ? 1 : 0;},
     _V_ = function(_ax_, _aw_){return _ax_ === _aw_ ? 1 : 0;},
     _W_ = function(_av_, _au_){return _av_ <= _au_ ? 1 : 0;},
     include$0 =
       [0,
        t_sexp_grammar,
        of_float,
        to_float,
        of_int_exn,
        to_int_exn,
        hash_fold_t,
        hash,
        t_of_sexp,
        sexp_of_t,
        of_string,
        to_string,
        function(_at_, _as_){return _as_ <= _at_ ? 1 : 0;},
        _W_,
        _V_,
        _U_,
        _T_,
        _S_,
        equal,
        compare,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        pp,
        hashable,
        is_positive,
        is_non_negative,
        is_negative,
        is_non_positive,
        sign,
        compare_local,
        equal_local,
        invariant,
        Hex,
        Binary,
        of_string_opt,
        to_string_hum,
        zero,
        one,
        minus_one,
        _R_,
        _Q_,
        _P_,
        symbol,
        _O_,
        _N_,
        symbol$1,
        symbol$0,
        _M_,
        rem,
        symbol$2,
        _L_,
        _K_,
        _J_,
        lnot,
        _I_,
        _H_,
        round,
        round_towards_zero,
        round_down,
        round_up,
        round_nearest,
        abs,
        succ,
        pred,
        pow,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        popcount,
        shift_left,
        shift_right,
        decr,
        incr,
        of_int32_exn,
        to_int32_exn,
        of_int64_exn,
        to_int64,
        of_nativeint_exn,
        to_nativeint_exn,
        num_bits,
        max_value,
        min_value,
        _G_,
        shift_right_logical,
        ceil_pow2,
        floor_pow2,
        ceil_log2,
        ,
        is_pow2,
        clz,
        ctz,
        _F_,
        of_int,
        to_int,
        to_int_trunc,
        of_int32_exn,
        to_int32,
        _g_,
        of_int64,
        _f_,
        of_nativeint,
        to_nativeint,
        _e_,
        to_nativeint_trunc,
        of_float_unchecked,
        repr,
        _d_,
        bswap32,
        bswap48];
   var
    t_sexp_grammar$0 = include$0[1],
    of_float$0 = include$0[2],
    to_float$0 = include$0[3],
    of_int_exn$0 = include$0[4],
    to_int_exn$0 = include$0[5],
    hash_fold_t$0 = include$0[6],
    hash$0 = include$0[7],
    t_of_sexp$0 = include$0[8],
    sexp_of_t$0 = include$0[9],
    of_string$0 = include$0[10],
    to_string$0 = include$0[11],
    symbol$3 = include$0[12],
    symbol$4 = include$0[13],
    symbol$5 = include$0[14],
    symbol$6 = include$0[15],
    symbol$7 = include$0[16],
    symbol$8 = include$0[17],
    equal$0 = include$0[18],
    compare$0 = include$0[19],
    min$0 = include$0[20],
    max$0 = include$0[21],
    ascending$0 = include$0[22],
    descending$0 = include$0[23],
    between$0 = include$0[24],
    clamp_exn$0 = include$0[25],
    clamp$0 = include$0[26],
    comparator$0 = include$0[27],
    pp$0 = include$0[28],
    hashable$0 = include$0[29],
    is_positive$0 = include$0[30],
    is_non_negative$0 = include$0[31],
    is_negative$0 = include$0[32],
    is_non_positive$0 = include$0[33],
    sign$0 = include$0[34],
    compare_local$0 = include$0[35],
    equal_local$0 = include$0[36],
    invariant$0 = include$0[37],
    Hex$0 = include$0[38],
    Binary$0 = include$0[39],
    of_string_opt$0 = include$0[40],
    to_string_hum$0 = include$0[41],
    zero$0 = include$0[42],
    one$0 = include$0[43],
    minus_one$0 = include$0[44],
    symbol$9 = include$0[45],
    symbol$10 = include$0[46],
    symbol$11 = include$0[47],
    symbol$12 = include$0[48],
    neg = include$0[49],
    symbol$13 = include$0[50],
    symbol$14 = include$0[51],
    symbol$15 = include$0[52],
    symbol$16 = include$0[53],
    rem$0 = include$0[54],
    symbol$17 = include$0[55],
    land = include$0[56],
    lor = include$0[57],
    lxor = include$0[58],
    lnot$0 = include$0[59],
    lsl = include$0[60],
    asr = include$0[61],
    round$0 = include$0[62],
    round_towards_zero$0 = include$0[63],
    round_down$0 = include$0[64],
    round_up$0 = include$0[65],
    round_nearest$0 = include$0[66],
    abs$0 = include$0[67],
    succ$0 = include$0[68],
    pred$0 = include$0[69],
    pow$0 = include$0[70],
    bit_and$0 = include$0[71],
    bit_or$0 = include$0[72],
    bit_xor$0 = include$0[73],
    bit_not$0 = include$0[74],
    popcount$0 = include$0[75],
    shift_left$0 = include$0[76],
    shift_right$0 = include$0[77],
    decr$0 = include$0[78],
    incr$0 = include$0[79],
    of_int32_exn$0 = include$0[80],
    to_int32_exn$0 = include$0[81],
    of_int64_exn$0 = include$0[82],
    to_int64$0 = include$0[83],
    of_nativeint_exn$0 = include$0[84],
    to_nativeint_exn$0 = include$0[85],
    num_bits$0 = include$0[86],
    max_value$0 = include$0[87],
    min_value$0 = include$0[88],
    lsr = include$0[89],
    shift_right_logical$0 = include$0[90],
    ceil_pow2$0 = include$0[91],
    floor_pow2$0 = include$0[92],
    ceil_log2$0 = include$0[93],
    is_pow2$0 = include$0[95],
    clz$0 = include$0[96],
    ctz$0 = include$0[97],
    O$0 = include$0[98],
    of_int$0 = include$0[99],
    to_int$0 = include$0[100],
    to_int_trunc$0 = include$0[101],
    of_int32 = include$0[102],
    to_int32$0 = include$0[103],
    to_int32_trunc = include$0[104],
    of_int64$0 = include$0[105],
    of_int64_trunc = include$0[106],
    of_nativeint$0 = include$0[107],
    to_nativeint$0 = include$0[108],
    of_nativeint_trunc = include$0[109],
    to_nativeint_trunc$0 = include$0[110],
    of_float_unchecked$0 = include$0[111],
    repr$0 = include$0[112],
    bswap16 = include$0[113],
    bswap32$0 = include$0[114],
    bswap48$0 = include$0[115];
   function symbol$18(t, u){
    var
     sum = caml_call2(symbol$9, t, u),
     _ao_ = caml_call2(bit_xor$0, t, caml_call1(bit_not$0, sum));
    if
     (caml_call2
       (symbol$7,
        caml_call2(bit_or$0, caml_call2(bit_xor$0, t, u), _ao_),
        zero$0))
     return sum;
    var
     _ap_ = [0, [0, cst_sum, caml_call1(sexp_of_t$0, sum)], 0],
     _aq_ = [0, [0, cst_u, caml_call1(sexp_of_t$0, u)], _ap_],
     _ar_ = [0, [0, cst_t, caml_call1(sexp_of_t$0, t)], _aq_];
    return caml_call1(raise_s, caml_call2(Base_Sexp[10], cst_overflow, _ar_));
   }
   function symbol$19(t, u){
    var
     diff = caml_call2(symbol$10, t, u),
     pos_diff = caml_call2(symbol$6, t, u);
    if(caml_call2(symbol$8, t, u)){
     var _ak_ = caml_call1(is_positive$0, diff);
     if(caml_call2(Base_Bool[15], pos_diff, _ak_)){
      var
       _al_ = [0, [0, cst_diff, caml_call1(sexp_of_t$0, diff)], 0],
       _am_ = [0, [0, cst_u$0, caml_call1(sexp_of_t$0, u)], _al_],
       _an_ = [0, [0, cst_t$0, caml_call1(sexp_of_t$0, t)], _am_];
      return caml_call1
              (raise_s, caml_call2(Base_Sexp[10], cst_overflow$0, _an_));
     }
    }
    return diff;
   }
   var negative_one = caml_call1(of_int$0, -1);
   function div_would_overflow(t, u){
    var _aj_ = caml_call2(symbol$5, t, min_value$0);
    return _aj_ ? caml_call2(symbol$5, u, negative_one) : _aj_;
   }
   function symbol$20(t, u){
    var product = caml_call2(symbol$11, t, u);
    a:
    if(caml_call2(symbol$8, u, zero$0)){
     if
      (!
       div_would_overflow(product, u)
       && ! caml_call2(symbol$8, caml_call2(symbol$16, product, u), t))
      break a;
     var
      _ag_ = [0, [0, cst_product, caml_call1(sexp_of_t$0, product)], 0],
      _ah_ = [0, [0, cst_u$1, caml_call1(sexp_of_t$0, u)], _ag_],
      _ai_ = [0, [0, cst_t$1, caml_call1(sexp_of_t$0, t)], _ah_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[10], cst_overflow$1, _ai_));
    }
    return product;
   }
   function symbol$21(t, u){
    if(! div_would_overflow(t, u)) return caml_call2(symbol$16, t, u);
    var
     _ad_ =
       [0,
        [0,
         cst_product$0,
         caml_call1(sexp_of_t$0, caml_call2(symbol$16, t, u))],
        0],
     _ae_ = [0, [0, cst_u$2, caml_call1(sexp_of_t$0, u)], _ad_],
     _af_ = [0, [0, cst_t$2, caml_call1(sexp_of_t$0, t)], _ae_];
    return caml_call1
            (raise_s, caml_call2(Base_Sexp[10], cst_overflow$2, _af_));
   }
   function abs$1(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[124], cst_abs_overflow)
            : caml_call1(abs$0, t);
   }
   function neg$0(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[124], cst_neg_overflow)
            : caml_call1(neg, t);
   }
   if(63 !== num_bits$0)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   function random_of_int(opt, bound){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[19][1];
    var _ac_ = caml_call1(to_int_exn$0, bound);
    return caml_call1(of_int$0, caml_call2(Base_Random[19][7], state, _ac_));
   }
   function random_of_int64(opt, bound){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[19][1];
    var _ab_ = caml_call1(to_int64$0, bound);
    return caml_call1
            (of_int64_exn$0, caml_call2(Base_Random[19][10], state, _ab_));
   }
   var random_of_int$0 = Base_Word_size[3] ? random_of_int : random_of_int64;
   function random_incl_of_int(opt, lo, hi){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[19][1];
    var
     _$_ = caml_call1(to_int_exn$0, hi),
     _aa_ = caml_call1(to_int_exn$0, lo);
    return caml_call1
            (of_int$0, caml_call3(Base_Random[19][12], state, _aa_, _$_));
   }
   function random_incl_of_int64(opt, lo, hi){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[19][1];
    var _Z_ = caml_call1(to_int64$0, hi), ___ = caml_call1(to_int64$0, lo);
    return caml_call1
            (of_int64_exn$0, caml_call3(Base_Random[19][15], state, ___, _Z_));
   }
   var
    random_incl =
      Base_Word_size[3] ? random_incl_of_int : random_incl_of_int64;
   function floor_log2(t){
    if(Base_Word_size[3]){
     var _X_ = caml_call1(to_int_exn$0, t);
     return caml_call1(Base_Int[71], _X_);
    }
    if(caml_call2(symbol$4, t, zero$0)){
     var _Y_ = [0, [0, cst, caml_call1(sexp_of_t$0, t)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[10], cst_Int_floor_log2_got_invalid, _Y_));
    }
    var floor_log2 = [0, num_bits$0 - 2 | 0];
    for(;;){
     if
      (!
       caml_call2
        (equal$0,
         zero$0,
         caml_call2
          (bit_and$0, t, caml_call2(shift_left$0, one$0, floor_log2[1]))))
      return floor_log2[1];
     floor_log2[1] = floor_log2[1] - 1 | 0;
    }
   }
   var
    Base_Int63 =
      [0,
       t_sexp_grammar$0,
       of_float$0,
       to_float$0,
       of_int_exn$0,
       to_int_exn$0,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       equal$0,
       compare$0,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       pp$0,
       hashable$0,
       is_positive$0,
       is_non_negative$0,
       is_negative$0,
       is_non_positive$0,
       sign$0,
       compare_local$0,
       equal_local$0,
       invariant$0,
       Hex$0,
       Binary$0,
       of_string_opt$0,
       to_string_hum$0,
       zero$0,
       one$0,
       minus_one$0,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       neg,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       rem$0,
       symbol$17,
       land,
       lor,
       lxor,
       lnot$0,
       lsl,
       asr,
       round$0,
       round_towards_zero$0,
       round_down$0,
       round_up$0,
       round_nearest$0,
       abs$0,
       succ$0,
       pred$0,
       pow$0,
       bit_and$0,
       bit_or$0,
       bit_xor$0,
       bit_not$0,
       popcount$0,
       shift_left$0,
       shift_right$0,
       decr$0,
       incr$0,
       of_int32_exn$0,
       to_int32_exn$0,
       of_int64_exn$0,
       to_int64$0,
       of_nativeint_exn$0,
       to_nativeint_exn$0,
       of_float_unchecked$0,
       num_bits$0,
       max_value$0,
       min_value$0,
       lsr,
       shift_right_logical$0,
       ceil_pow2$0,
       floor_pow2$0,
       ceil_log2$0,
       is_pow2$0,
       clz$0,
       ctz$0,
       O$0,
       [0, symbol$18, symbol$19, symbol$20, symbol$21, abs$1, neg$0],
       of_int$0,
       to_int$0,
       of_int32,
       to_int32$0,
       of_int64$0,
       of_nativeint$0,
       to_nativeint$0,
       to_int_trunc$0,
       to_int32_trunc,
       of_int64_trunc,
       of_nativeint_trunc,
       to_nativeint_trunc$0,
       bswap16,
       bswap32$0,
       bswap48$0,
       random_of_int$0,
       random_incl,
       floor_log2,
       [0, Base_Int63_emul[117], repr$0]];
   runtime.caml_register_global(32, Base_Int63, "Base__Int63");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Dictionary_mutable_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Merge_into_action = [0],
    Definitions = [0, Merge_into_action],
    Base_Dictionary_mutable_intf = [0, Definitions];
   runtime.caml_register_global
    (0, Base_Dictionary_mutable_intf, "Base__Dictionary_mutable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Dictionary_mutable
//# unitInfo: Requires: Base__Dictionary_mutable_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Dictionary_mutable = [0];
   runtime.caml_register_global
    (0, Base_Dictionary_mutable, "Base__Dictionary_mutable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Key = [0],
    Base_Hashtbl_intf = [0, Key];
   runtime.caml_register_global(0, Base_Hashtbl_intf, "Base__Hashtbl_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Avltree
//# unitInfo: Requires: Base__Error, Base__Import, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_avltree_ml = "src/avltree.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[32],
    cst_Avltree_choose_exn_of_empt = "[Avltree.choose_exn] of empty hashtbl",
    _j_ = [0, cst_src_avltree_ml, 389, 15],
    _k_ = [0, cst_src_avltree_ml, 406, 20],
    _g_ = [0, cst_src_avltree_ml, 129, 30],
    _f_ = [0, cst_src_avltree_ml, 110, 26],
    _i_ = [0, cst_src_avltree_ml, 163, 30],
    _h_ = [0, cst_src_avltree_ml, 145, 26],
    _e_ = [0, cst_src_avltree_ml, 87, 22],
    _d_ = [0, cst_src_avltree_ml, 66, 6],
    _c_ = [0, cst_src_avltree_ml, 67, 6],
    _b_ = [0, cst_src_avltree_ml, 56, 6],
    _a_ = [0, cst_src_avltree_ml, 50, 6];
   function max(x, y){return y < x ? x : y;}
   var empty = 0;
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function height(param){
    if(typeof param === "number") return 0;
    if(0 !== param[0]) return 1;
    var height = param[4];
    return height;
   }
   function invariant(t, compare){
    function inv(param){
     if(typeof param !== "number" && 0 === param[0]){
      var
       left = param[1],
       key = param[2],
       h = param[4],
       right = param[5],
       hr = height(right),
       hl = height(left);
      inv(left);
      inv(right);
      if(typeof left !== "number"){
       var left_key = 0 === left[0] ? left[2] : left[1];
       if(0 <= caml_call2(compare, left_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      }
      if(typeof right !== "number"){
       var right_key = 0 === right[0] ? right[2] : right[1];
       if(0 >= caml_call2(compare, right_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      }
      var _E_ = max(hl, hr);
      if(h !== caml_call2(Base_Import[91], _E_, 1))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      var _F_ = caml_call2(Base_Import[93], hl, hr);
      if(2 < caml_call1(Base_Import[123], _F_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
      return 0;
     }
     return 0;
    }
    return inv(t);
   }
   function update_height(x){
    if(typeof x !== "number" && 0 === x[0]){
     var
      left = x[1],
      old_height = x[4],
      right = x[5],
      _C_ = height(right),
      _D_ = max(height(left), _C_),
      new_height = caml_call2(Base_Import[91], _D_, 1);
     if(new_height !== old_height) x[4] = new_height;
     return;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function balance(root_node){
    if(typeof root_node !== "number" && 0 === root_node[0]){
     var
      left_node = root_node[1],
      right_node = root_node[5],
      hl = height(left_node),
      hr = height(right_node);
     if(caml_call2(Base_Import[91], hr, 2) < hl){
      if(typeof left_node !== "number" && 0 === left_node[0]){
       var
        left_node_left = left_node[1],
        left_node_right = left_node[5],
        _A_ = height(left_node_right);
       if(_A_ <= height(left_node_left)){
        root_node[1] = left_node_right;
        left_node[5] = root_node;
        update_height(root_node);
        update_height(left_node);
        return left_node;
       }
       if(typeof left_node_right !== "number" && 0 === left_node_right[0]){
        var lr_left = left_node_right[1], lr_right = left_node_right[5];
        left_node[5] = lr_left;
        root_node[1] = lr_right;
        left_node_right[5] = root_node;
        left_node_right[1] = left_node;
        update_height(left_node);
        update_height(root_node);
        update_height(left_node_right);
        return left_node_right;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
     if(caml_call2(Base_Import[91], hl, 2) >= hr){update_height(root_node); return root_node;
     }
     if(typeof right_node !== "number" && 0 === right_node[0]){
      var
       right_node_left = right_node[1],
       right_node_right = right_node[5],
       _B_ = height(right_node_left);
      if(_B_ <= height(right_node_right)){
       root_node[5] = right_node_left;
       right_node[1] = root_node;
       update_height(root_node);
       update_height(right_node);
       return right_node;
      }
      if(typeof right_node_left !== "number" && 0 === right_node_left[0]){
       var rl_left = right_node_left[1], rl_right = right_node_left[5];
       right_node[1] = rl_right;
       root_node[5] = rl_left;
       right_node_left[1] = root_node;
       right_node_left[5] = right_node;
       update_height(right_node);
       update_height(root_node);
       update_height(right_node_left);
       return right_node_left;
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    }
    return root_node;
   }
   function add(t, replace, compare, added, k, v){
    if(typeof t === "number"){added[1] = 1; return [1, k, v];}
    if(0 !== t[0]){
     var k$1 = t[1], c$0 = caml_call2(compare, k$1, k);
     if(0 !== c$0){
      added[1] = 1;
      return 0 <= c$0 ? [0, 0, k, v, 2, t] : [0, t, k, v, 2, 0];
     }
     added[1] = 0;
     if(replace) t[2] = v;
     return t;
    }
    var
     left = t[1],
     k$0 = t[2],
     right = t[5],
     c = caml_call2(compare, k, k$0);
    if(0 === c){added[1] = 0; if(replace) t[3] = v; return t;}
    if(0 <= c){
     var right$0 = add(right, replace, compare, added, k, v);
     if(1 - (right$0 === right ? 1 : 0)) t[5] = right$0;
    }
    else{
     var left$0 = add(left, replace, compare, added, k, v);
     if(1 - (left$0 === left ? 1 : 0)) t[1] = left$0;
    }
    return added[1] ? balance(t) : t;
   }
   function first(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var l = t$0[1];
      if(typeof l !== "number"){var t$0 = l; continue;}
      var v = t$0[3], k = t$0[2];
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function last(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var _y_ = t$0[2], _z_ = t$0[3];
      if(typeof t$0[5] !== "number"){var r = t$0[5], t$0 = r; continue;}
      var v = _z_, k = _y_;
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function findi_and_call_impl
   (t,
    compare,
    k,
    arg1,
    arg2,
    call_if_found,
    call_if_not_found,
    if_found,
    if_not_found){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number")
      return caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     if(0 !== t$0[0]){
      var k$1 = t$0[1], v$0 = t$0[2];
      return 0 === caml_call2(compare, k, k$1)
              ? caml_call5(call_if_found, if_found, k$1, v$0, arg1, arg2)
              : caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     }
     var
      left = t$0[1],
      k$0 = t$0[2],
      v = t$0[3],
      right = t$0[5],
      c = caml_call2(compare, k, k$0);
     if(0 === c)
      return caml_call5(call_if_found, if_found, k$0, v, arg1, arg2);
     var right$0 = 0 <= c ? right : left, t$0 = right$0;
    }
   }
   function call_if_found(if_found, param, data, _x_, _w_){return caml_call1(if_found, data);
   }
   function call_if_not_found(if_not_found, key, param, _v_){return caml_call1(if_not_found, key);
   }
   function find_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found,
             call_if_not_found,
             if_found,
             if_not_found);
   }
   function call_if_found$0(if_found, key, data, param, _u_){return caml_call2(if_found, key, data);
   }
   function call_if_not_found$0(if_not_found, key, param, _t_){return caml_call1(if_not_found, key);
   }
   function findi_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found$0,
             call_if_not_found$0,
             if_found,
             if_not_found);
   }
   function call_if_found$1(if_found, param, data, arg, _s_){return caml_call2(if_found, data, arg);
   }
   function call_if_not_found$1(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function find_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$1,
             call_if_not_found$1,
             if_found,
             if_not_found);
   }
   function call_if_found$2(if_found, key, data, arg, param){return caml_call3(if_found, key, data, arg);
   }
   function call_if_not_found$2(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function findi_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$2,
             call_if_not_found$2,
             if_found,
             if_not_found);
   }
   function call_if_found$3(if_found, param, data, arg1, arg2){return caml_call3(if_found, data, arg1, arg2);
   }
   function call_if_not_found$3(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function find_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$3,
             call_if_not_found$3,
             if_found,
             if_not_found);
   }
   function call_if_found$4(if_found, key, data, arg1, arg2){return caml_call4(if_found, key, data, arg1, arg2);
   }
   function call_if_not_found$4(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function findi_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$4,
             call_if_not_found$4,
             if_found,
             if_not_found);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, compare, k){
    return find_and_call(t, compare, k, if_found, if_not_found);
   }
   function if_found$0(param){return 1;}
   function if_not_found$0(param){return 0;}
   function mem(t, compare, k){
    return find_and_call(t, compare, k, if_found$0, if_not_found$0);
   }
   var
    remove =
      function _r_(_n_, _o_, _p_, _q_){return _r_.fun(_n_, _o_, _p_, _q_);};
   function remove_min_elt(tree){
    if(typeof tree === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    if(0 !== tree[0]) return 0;
    var left = tree[1];
    if(typeof left === "number"){var right = tree[5]; return right;}
    if(1 === left[0]){
     var k = tree[2], v = tree[3];
     if(typeof tree[5] === "number") return [1, k, v];
    }
    tree[1] = remove_min_elt(left);
    return balance(tree);
   }
   runtime.caml_update_dummy
    (remove,
     function(t, removed, compare, k$0){
      if(typeof t === "number"){removed[1] = 0; return 0;}
      if(0 !== t[0]){
       var k$2 = t[1];
       return 0 === caml_call2(compare, k$0, k$2)
               ? (removed[1] = 1, 0)
               : (removed[1] = 0, t);
      }
      var
       left$0 = t[1],
       k$1 = t[2],
       right = t[5],
       c = caml_call2(compare, k$0, k$1);
      if(0 !== c){
       if(0 <= c){
        var right$0 = caml_call4(remove, right, removed, compare, k$0);
        if(1 - (right$0 === right ? 1 : 0)) t[5] = right$0;
       }
       else{
        var left$1 = caml_call4(remove, left$0, removed, compare, k$0);
        if(1 - (left$1 === left$0 ? 1 : 0)) t[1] = left$1;
       }
       return removed[1] ? balance(t) : t;
      }
      removed[1] = 1;
      if(typeof left$0 === "number") return right;
      if(typeof right === "number") return left$0;
      var tree = right;
      for(;;){
       if(typeof tree === "number")
        var tree$0 = 0;
       else if(0 === tree[0]){
        var left = tree[1];
        if(typeof left !== "number"){var tree = left; continue;}
        var tree$0 = tree;
       }
       else
        var tree$0 = tree;
       if(typeof tree$0 === "number")
        throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
       if(0 === tree$0[0]){
        tree$0[5] = remove_min_elt(right);
        tree$0[1] = left$0;
        var tree$1 = tree$0;
       }
       else
        var
         k = tree$0[1],
         v = tree$0[2],
         t2 = remove_min_elt(right),
         _l_ = height(t2),
         _m_ = max(height(left$0), _l_),
         tree$1 = [0, left$0, k, v, caml_call2(Base_Import[91], _m_, 1), t2];
       return balance(tree$1);
      }
     });
   function fold(t, init, f){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 !== t$0[0]){
      var key$4 = t$0[1], data$4 = t$0[2];
      return caml_call3(f, key$4, data$4, init$0);
     }
     var left = t$0[1];
     if(typeof left === "number"){
      var key = t$0[2], data = t$0[3], match = t$0[5];
      if(typeof match !== "number" && 0 !== match[0]){
       var rkey = match[1], rdata = match[2];
       return caml_call3(f, rkey, rdata, caml_call3(f, key, data, init$0));
      }
     }
     else{
      if(0 === left[0]){
       var key$1 = t$0[2], data$1 = t$0[3], match$0 = t$0[5];
       if(typeof match$0 !== "number" && 0 !== match$0[0]){
        var rkey$0 = match$0[1], rdata$0 = match$0[2];
        return caml_call3
                (f,
                 rkey$0,
                 rdata$0,
                 caml_call3(f, key$1, data$1, fold(left, init$0, f)));
       }
      }
      else{
       var
        lkey$0 = left[1],
        ldata$0 = left[2],
        key$3 = t$0[2],
        data$3 = t$0[3],
        match$1 = t$0[5];
       if(typeof match$1 === "number")
        return caml_call3
                (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0));
       if(0 !== match$1[0]){
        var rkey$1 = match$1[1], rdata$1 = match$1[2];
        return caml_call3
                (f,
                 rkey$1,
                 rdata$1,
                 caml_call3
                  (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0)));
       }
      }
      if(typeof left !== "number" && 1 === left[0]){
       var
        lkey = left[1],
        ldata = left[2],
        key$2 = t$0[2],
        data$2 = t$0[3],
        right$0 = t$0[5],
        init$2 =
          caml_call3(f, key$2, data$2, caml_call3(f, lkey, ldata, init$0)),
        t$0 = right$0,
        init$0 = init$2;
       continue;
      }
     }
     var
      key$0 = t$0[2],
      data$0 = t$0[3],
      right = t$0[5],
      init$1 = caml_call3(f, key$0, data$0, fold(left, init$0, f)),
      t$0 = right,
      init$0 = init$1;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 !== t$0[0]){
      var key$0 = t$0[1], data$0 = t$0[2];
      return caml_call2(f, key$0, data$0);
     }
     var left = t$0[1], key = t$0[2], data = t$0[3], right = t$0[5];
     iter(left, f);
     caml_call2(f, key, data);
     var t$0 = right;
    }
   }
   function mapi_inplace(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 !== t$0[0]){
      var key$0 = t$0[1], value$0 = t$0[2];
      t$0[2] = caml_call2(f, key$0, value$0);
      return 0;
     }
     var left = t$0[1], key = t$0[2], value = t$0[3], right = t$0[5];
     mapi_inplace(left, f);
     t$0[3] = caml_call2(f, key, value);
     var t$0 = right;
    }
   }
   function choose_exn(param){
    if(typeof param === "number")
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[10], cst_Avltree_choose_exn_of_empt, 0));
    if(0 === param[0])
     var value = param[3], key = param[2];
    else
     var key$0 = param[1], value$0 = param[2], value = value$0, key = key$0;
    return [0, key, value];
   }
   var
    Base_Avltree =
      [0,
       empty,
       is_empty,
       invariant,
       add,
       first,
       last,
       find,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       mem,
       remove,
       fold,
       iter,
       mapi_inplace,
       choose_exn];
   runtime.caml_register_global(16, Base_Avltree, "Base__Avltree");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl
//# unitInfo: Requires: Base__Array, Base__Avltree, Base__Error, Base__Hashable, Base__Hashtbl_intf, Base__Import, Base__Int, Base__List, Base__Option, Base__Or_error, Base__Random, Base__Sexp, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_hashtbl_ml = "src/hashtbl.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Avltree = global_data.Base__Avltree,
    Base_Import = global_data.Base__Import,
    Base_Hashable = global_data.Base__Hashable,
    Base_Array = global_data.Base__Array,
    Base_List = global_data.Base__List,
    Base_Or_error = global_data.Base__Or_error,
    Base_Sexp = global_data.Base__Sexp,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Base_Random = global_data.Base__Random,
    Base_Int = global_data.Base__Int,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1],
    hash_param = Base_Hashable[5],
    hash = Base_Hashable[6],
    raise_s = Base_Error[32],
    cst_Hashtbl_merge_different_ha =
      "Hashtbl.merge: different 'hashable' values",
    cst_keys = "keys",
    cst_Hashtbl_create_with_key_du = "Hashtbl.create_with_key: duplicate keys",
    cst_Hashtbl_t_of_sexp_duplicat = "Hashtbl.t_of_sexp: duplicate key",
    _c_ = [0, cst_src_hashtbl_ml, 582, 4],
    cst_Hashtbl_of_alist_exn_dupli = "Hashtbl.of_alist_exn: duplicate key",
    _b_ = [0, "Hashtbl.find_exn: not found"],
    _a_ = [0, cst_src_hashtbl_ml, 333, 2],
    cst_Hashtbl_choose_randomly_ex =
      "[Hashtbl.choose_randomly_exn] of empty hashtbl",
    cst_Hashtbl_choose_exn_of_empt = "[Hashtbl.choose_exn] of empty hashtbl",
    cst_Hashtbl_add_exn_got_key_al = "Hashtbl.add_exn got key already present",
    cst_Hashtbl_mutation_not_allow =
      "Hashtbl: mutation not allowed during iteration";
   function sexp_of_key(t){return t[4][3];}
   function compare_key(t){return t[4][2];}
   function ensure_mutation_allowed(t){
    var _aM_ = 1 - t[5];
    return _aM_
            ? caml_call1(Base_Import[124], cst_Hashtbl_mutation_not_allow)
            : _aM_;
   }
   function without_mutating(t, f){
    if(! t[5]) return caml_call1(f, 0);
    t[5] = 0;
    try{var x = caml_call1(f, 0);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[5] = 1;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[5] = 1;
    return x;
   }
   var max_table_length = caml_call1(Base_Int[69], Base_Array[47]);
   function create(opt, _aK_, hashable, param){
    if(opt)
     var sth = opt[1], growth_allowed = sth;
    else
     var growth_allowed = 1;
    if(_aK_) var sth$0 = _aK_[1], size = sth$0; else var size = 0;
    var
     _aL_ = caml_call2(Base_Int[16], 1, size),
     size$0 = caml_call2(Base_Int[15], _aL_, max_table_length),
     size$1 = caml_call1(Base_Int[68], size$0);
    return [0,
            caml_call2(Base_Array[48], size$1, Base_Avltree[1]),
            0,
            growth_allowed,
            hashable,
            1];
   }
   function slot(t, key){
    var
     hash = caml_call1(t[4][1], key),
     _aJ_ = caml_call2(Base_Import[93], t[1].length - 1, 1);
    return caml_call2(Base_Import[116], hash, _aJ_);
   }
   function add_worker(t, replace, key, data){
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     added = [0, 0],
     _aI_ = compare_key(t),
     new_root =
       caml_call6(Base_Avltree[4], root, replace, _aI_, added, key, data);
    if(added[1]) t[2] = caml_call2(Base_Import[91], t[2], 1);
    if(1 - (new_root === root ? 1 : 0))
     caml_check_bound(t[1], i)[1 + i] = new_root;
    return added[1];
   }
   function maybe_resize_table(t){
    var
     len = t[1].length - 1,
     should_grow = len < t[2] ? 1 : 0,
     _az_ = should_grow ? t[3] : should_grow;
    if(_az_){
     var
      _aA_ = caml_call2(Base_Import[88], len, 2),
      new_array_length = caml_call2(Base_Int[15], _aA_, max_table_length),
      _aB_ = len < new_array_length ? 1 : 0;
     if(_aB_){
      var
       new_table =
         caml_call2(Base_Array[48], new_array_length, Base_Avltree[1]),
       old_table = t[1];
      t[1] = new_table;
      t[2] = 0;
      var
       f = function(key, data){add_worker(t, 1, key, data); return 0;},
       _aD_ = caml_call2(Base_Import[93], old_table.length - 1, 1),
       _aC_ = 0;
      if(_aD_ >= 0){
       var i = _aC_;
       for(;;){
        var _aG_ = caml_check_bound(old_table, i)[1 + i];
        caml_call2(Base_Avltree[17], _aG_, f);
        var _aH_ = i + 1 | 0;
        if(_aD_ === i) break;
        var i = _aH_;
       }
      }
      var _aE_ = 0;
     }
     else
      var _aE_ = _aB_;
     var _aF_ = _aE_;
    }
    else
     var _aF_ = _az_;
    return _aF_;
   }
   function capacity(t){return t[1].length - 1;}
   function set(t, key, data){
    ensure_mutation_allowed(t);
    add_worker(t, 1, key, data);
    return maybe_resize_table(t);
   }
   function add(t, key, data){
    ensure_mutation_allowed(t);
    var added = add_worker(t, 0, key, data);
    return added ? (maybe_resize_table(t), 17724) : -1024851605;
   }
   function add_exn(t, key, data){
    if(17724 <= add(t, key, data)) return 0;
    var
     sexp_of_key$0 = sexp_of_key(t),
     error =
       caml_call5
        (Base_Error[19],
         0,
         0,
         cst_Hashtbl_add_exn_got_key_al,
         key,
         sexp_of_key$0);
    return caml_call1(Base_Error[31], error);
   }
   function clear(t){
    ensure_mutation_allowed(t);
    var _aw_ = caml_call2(Base_Import[93], t[1].length - 1, 1), _av_ = 0;
    if(_aw_ >= 0){
     var i = _av_;
     for(;;){
      var _ax_ = Base_Avltree[1];
      caml_check_bound(t[1], i)[1 + i] = _ax_;
      var _ay_ = i + 1 | 0;
      if(_aw_ === i) break;
      var i = _ay_;
     }
    }
    t[2] = 0;
    return 0;
   }
   function find_and_call(t, key, if_found, if_not_found){
    var _at_ = slot(t, key), tree = caml_check_bound(t[1], _at_)[1 + _at_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _au_ = compare_key(t);
     return caml_call5
             (Base_Avltree[8], tree, _au_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call1(if_found, v)
            : caml_call1(if_not_found, key);
   }
   function find_and_call1(t, key, a, if_found, if_not_found){
    var _ar_ = slot(t, key), tree = caml_check_bound(t[1], _ar_)[1 + _ar_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _as_ = compare_key(t);
     return caml_call6
             (Base_Avltree[9], tree, _as_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function find_and_call2(t, key, a, b, if_found, if_not_found){
    var _ap_ = slot(t, key), tree = caml_check_bound(t[1], _ap_)[1 + _ap_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var _aq_ = compare_key(t);
     return caml_call7
             (Base_Avltree[10], tree, _aq_, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function findi_and_call(t, key, if_found, if_not_found){
    var _an_ = slot(t, key), tree = caml_check_bound(t[1], _an_)[1 + _an_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _ao_ = compare_key(t);
     return caml_call5
             (Base_Avltree[11], tree, _ao_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, k, v)
            : caml_call1(if_not_found, key);
   }
   function findi_and_call1(t, key, a, if_found, if_not_found){
    var _al_ = slot(t, key), tree = caml_check_bound(t[1], _al_)[1 + _al_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _am_ = compare_key(t);
     return caml_call6
             (Base_Avltree[12], tree, _am_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, k, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function findi_and_call2(t, key, a, b, if_found, if_not_found){
    var _aj_ = slot(t, key), tree = caml_check_bound(t[1], _aj_)[1 + _aj_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var _ak_ = compare_key(t);
     return caml_call7
             (Base_Avltree[13], tree, _ak_, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call4(if_found, k, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, key){
    return find_and_call(t, key, if_found, if_not_found);
   }
   function mem(t, key){
    var _ah_ = slot(t, key), tree = caml_check_bound(t[1], _ah_)[1 + _ah_];
    if(typeof tree === "number") return 0;
    if(0 === tree[0]){
     var _ai_ = compare_key(t);
     return caml_call3(Base_Avltree[14], tree, _ai_, key);
    }
    var k = tree[1];
    return 0 === caml_call2(compare_key(t), k, key) ? 1 : 0;
   }
   function remove(t, key){
    ensure_mutation_allowed(t);
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     removed = [0, 0],
     _ae_ = compare_key(t),
     new_root = caml_call4(Base_Avltree[15], root, removed, _ae_, key);
    if(1 - (root === new_root ? 1 : 0))
     caml_check_bound(t[1], i)[1 + i] = new_root;
    var
     _af_ = removed[1],
     _ag_ = _af_ ? (t[2] = caml_call2(Base_Import[93], t[2], 1), 0) : _af_;
    return _ag_;
   }
   function length(t){return t[2];}
   function is_empty(t){return 0 === t[2] ? 1 : 0;}
   function fold(t, init, f){
    if(0 === t[2]) return init;
    var n = t[1].length - 1, acc = [0, init], m = t[5];
    try{
     t[5] = 0;
     var _ac_ = caml_call2(Base_Import[93], n, 1), _ab_ = 0;
     if(_ac_ >= 0){
      var i = _ab_;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         acc[1] = caml_call3(Base_Avltree[16], bucket, acc[1], f);
        else{
         var key = bucket[1], data = bucket[2];
         acc[1] = caml_call3(f, key, data, acc[1]);
        }
       var _ad_ = i + 1 | 0;
       if(_ac_ === i) break;
       var i = _ad_;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[5] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[5] = m;
    return acc[1];
   }
   function iteri(t, f){
    if(0 === t[2]) return 0;
    var n = t[1].length - 1, m = t[5];
    try{
     t[5] = 0;
     var _$_ = caml_call2(Base_Import[93], n, 1), ___ = 0;
     if(_$_ >= 0){
      var i = ___;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         caml_call2(Base_Avltree[17], bucket, f);
        else{var key = bucket[1], data = bucket[2]; caml_call2(f, key, data);}
       var _aa_ = i + 1 | 0;
       if(_$_ === i) break;
       var i = _aa_;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[5] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[5] = m;
    return 0;
   }
   function iter(t, f){
    return iteri(t, function(param, data){return caml_call1(f, data);});
   }
   function iter_keys(t, f){
    return iteri(t, function(key, param){return caml_call1(f, key);});
   }
   function choose_nonempty(table, i){
    var i$0 = i;
    for(;;){
     var avltree = table[1 + i$0];
     if(! caml_call1(Base_Avltree[2], avltree))
      return caml_call1(Base_Avltree[19], avltree);
     var
      _Y_ = caml_call2(Base_Import[93], table.length - 1, 1),
      _Z_ = caml_call2(Base_Import[91], i$0, 1),
      i$1 = caml_call2(Base_Import[116], _Z_, _Y_),
      i$0 = i$1;
    }
   }
   function choose_exn(t){
    if(0 === t[2])
     caml_call1
      (raise_s, caml_call2(Base_Sexp[10], cst_Hashtbl_choose_exn_of_empt, 0));
    return choose_nonempty(t[1], 0);
   }
   function choose(t){return is_empty(t) ? 0 : [0, choose_nonempty(t[1], 0)];}
   function choose_randomly_nonempty(random_state, t){
    var
     start_idx = caml_call2(Base_Random[19][7], random_state, t[1].length - 1);
    return choose_nonempty(t[1], start_idx);
   }
   function choose_randomly(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    return is_empty(t) ? 0 : [0, choose_randomly_nonempty(random_state, t)];
   }
   function choose_randomly_exn(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[19][1];
    if(0 === t[2])
     caml_call1
      (raise_s, caml_call2(Base_Sexp[10], cst_Hashtbl_choose_randomly_ex, 0));
    return choose_randomly_nonempty(random_state, t);
   }
   function invariant(invariant_key, invariant_data, t){
    var _U_ = caml_call2(Base_Import[93], t[1].length - 1, 1), _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      var _V_ = compare_key(t), _W_ = caml_check_bound(t[1], i)[1 + i];
      caml_call2(Base_Avltree[3], _W_, _V_);
      var _X_ = i + 1 | 0;
      if(_U_ === i) break;
      var i = _X_;
     }
    }
    var
     real_len =
       fold
        (t,
         0,
         function(key, data, i){
          caml_call1(invariant_key, key);
          caml_call1(invariant_data, data);
          return caml_call2(Base_Import[91], i, 1);
         });
    if(real_len === t[2]) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function if_found$0(v, param){return v;}
   function if_not_found$0(k, t){
    var _S_ = [1, [0, _b_, [0, caml_call1(t[4][3], k), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[297], _S_], 1);
   }
   function find_exn(t, key){
    return find_and_call1(t, key, t, if_found$0, if_not_found$0);
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _R_ = caml_call2(f, key, data);
                 return _R_ ? caml_call1(r, 1) : _R_;
                });
              return 0;
             });
   }
   function exists(t, f){
    return existsi(t, function(param, data){return caml_call1(f, data);});
   }
   function for_alli(t, f){
    return 1
           -
            existsi
             (t, function(key, data){return 1 - caml_call2(f, key, data);});
   }
   function for_all(t, f){
    return 1
           -
            existsi(t, function(param, data){return 1 - caml_call1(f, data);});
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[91], acc, 1)
                      : acc;
             });
   }
   function mapi(t, f){
    var new_t = create([0, t[3]], [0, t[2]], t[4], 0);
    iteri
     (t,
      function(key, data){return set(new_t, key, caml_call2(f, key, data));});
    return new_t;
   }
   function map(t, f){
    return mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function copy(t){return map(t, function(_Q_){return _Q_;});}
   function filter_mapi(t, f){
    var new_t = create([0, t[3]], [0, t[2]], t[4], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(! match) return 0;
       var new_data = match[1];
       return set(new_t, key, new_data);
      });
    return new_t;
   }
   function filter_map(t, f){
    return filter_mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function filteri(t, f){
    return filter_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : 0;
             });
   }
   function filter(t, f){
    return filteri(t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys(t, f){
    return filteri(t, function(key, param){return caml_call1(f, key);});
   }
   function partition_mapi(t, f){
    var
     t0 = create([0, t[3]], [0, t[2]], t[4], 0),
     t1 = create([0, t[3]], [0, t[2]], t[4], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(0 === match[0]){
        var new_data = match[1];
        return set(t0, key, new_data);
       }
       var new_data$0 = match[1];
       return set(t1, key, new_data$0);
      });
    return [0, t0, t1];
   }
   function partition_map(t, f){
    return partition_mapi
            (t, function(param, data){return caml_call1(f, data);});
   }
   function partitioni_tf(t, f){
    return partition_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : [1, data];
             });
   }
   function partition_tf(t, f){
    return partitioni_tf
            (t, function(param, data){return caml_call1(f, data);});
   }
   function find_or_add(t, id, default$0){
    function _P_(key){
     var default$1 = caml_call1(default$0, 0);
     set(t, key, default$1);
     return default$1;
    }
    return find_and_call(t, id, function(data){return data;}, _P_);
   }
   function findi_or_add(t, id, default$0){
    function _O_(key){
     var default$1 = caml_call1(default$0, key);
     set(t, key, default$1);
     return default$1;
    }
    return find_and_call(t, id, function(data){return data;}, _O_);
   }
   function find_and_remove(t, id){
    var result = find(t, id);
    if(caml_call1(Base_Option[53], result)) remove(t, id);
    return result;
   }
   function change(t, id, f){
    var match = caml_call1(f, find(t, id));
    if(! match) return remove(t, id);
    var data = match[1];
    return set(t, id, data);
   }
   function update_and_return(t, id, f){
    var data = caml_call1(f, find(t, id));
    set(t, id, data);
    return data;
   }
   function update(t, id, f){update_and_return(t, id, f); return 0;}
   function incr_by(remove_if_zero, t, key, by){
    return remove_if_zero
            ? change
              (t,
               key,
               function(opt){
                var
                 _N_ = caml_call2(Base_Option[30], opt, 0),
                 n = caml_call2(Base_Import[91], by, _N_);
                return 0 === n ? 0 : [0, n];
               })
            : update
              (t,
               key,
               function(param){
                if(! param) return by;
                var i = param[1];
                return caml_call2(Base_Import[91], by, i);
               });
   }
   function incr(opt, _M_, t, key){
    if(opt) var sth = opt[1], by = sth; else var by = 1;
    if(_M_)
     var sth$0 = _M_[1], remove_if_zero = sth$0;
    else
     var remove_if_zero = 0;
    return incr_by(remove_if_zero, t, key, by);
   }
   function decr(opt, _L_, t, key){
    if(opt) var sth = opt[1], by = sth; else var by = 1;
    if(_L_)
     var sth$0 = _L_[1], remove_if_zero = sth$0;
    else
     var remove_if_zero = 0;
    return incr_by(remove_if_zero, t, key, caml_call1(Base_Import[113], by));
   }
   function add_multi(t, key, data){
    return update
            (t,
             key,
             function(param){
              if(! param) return [0, data, 0];
              var l = param[1];
              return [0, data, l];
             });
   }
   function remove_multi(t, key){
    var match = find(t, key);
    if(! match) return 0;
    var _K_ = match[1];
    if(_K_ && _K_[2]){var tl = _K_[2]; return set(t, key, tl);}
    return remove(t, key);
   }
   function find_multi(t, key){
    var match = find(t, key);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function create_mapped
   (growth_allowed, size, hashable, get_key, get_data, rows){
    if(size)
     var s = size[1], size$0 = s;
    else
     var size$0 = caml_call1(Base_List[45], rows);
    var
     res = create(growth_allowed, [0, size$0], hashable, 0),
     dupes = [0, 0];
    function _J_(r){
     var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
     return mem(res, key)
             ? (dupes[1] = [0, key, dupes[1]], 0)
             : set(res, key, data);
    }
    caml_call2(Base_List[19], rows, _J_);
    var keys = dupes[1];
    return keys
            ? [0, 175765640, caml_call2(Base_List[126], keys, hashable[2])]
            : [0, 17724, res];
   }
   function of_alist(growth_allowed, size, hashable, lst){
    var
     match =
       create_mapped
        (growth_allowed,
         size,
         hashable,
         Base_Import[125],
         Base_Import[127],
         lst);
    if(175765640 <= match[1]){
     var k = match[2];
     return [0, -1048878709, caml_call1(Base_List[88], k)];
    }
    var t = match[2];
    return [0, 17724, t];
   }
   function of_alist_report_all_dups(growth_allowed, size, hashable, lst){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             Base_Import[125],
             Base_Import[127],
             lst);
   }
   function of_alist_or_error(growth_allowed, size, hashable, lst){
    var match = of_alist(growth_allowed, size, hashable, lst);
    if(17724 <= match[1]){var v = match[2]; return [0, v];}
    var key = match[2], sexp_of_key = hashable[3];
    return caml_call5
            (Base_Or_error[38],
             0,
             0,
             cst_Hashtbl_of_alist_exn_dupli,
             key,
             sexp_of_key);
   }
   function of_alist_exn(growth_allowed, size, hashable, lst){
    var match = of_alist_or_error(growth_allowed, size, hashable, lst);
    if(0 === match[0]){var v = match[1]; return v;}
    var e = match[1];
    return caml_call1(Base_Error[31], e);
   }
   function of_alist_multi(growth_allowed, size$0, hashable, rows){
    var get_data = Base_Import[127], get_key = Base_Import[125];
    if(size$0)
     var s = size$0[1], size = s;
    else
     var size = caml_call1(Base_List[45], rows);
    var res = create(growth_allowed, [0, size], hashable, 0);
    function _I_(r){
     var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
     return add_multi(res, key, data);
    }
    caml_call2(Base_List[19], rows, _I_);
    return res;
   }
   function to_alist(t){
    return fold
            (t,
             0,
             function(key, data, list){return [0, [0, key, data], list];});
   }
   function sexp_of_t(sexp_of_key, sexp_of_data, t){
    var
     _D_ = to_alist(t),
     _E_ = Base_List[83],
     _F_ =
       caml_call2
        (_E_,
         _D_,
         function(param, _H_){
          var k2 = _H_[1], k1 = param[1];
          return caml_call2(t[4][2], k1, k2);
         }),
     _G_ = caml_call2(Base_Import[147], sexp_of_key, sexp_of_data);
    return caml_call1(caml_call1(Base_Import[149], _G_), _F_);
   }
   function t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp){
    var
     _t_ = caml_call2(Base_Import[171], k_of_sexp, d_of_sexp),
     alist = caml_call2(Base_Import[173], _t_, sexp),
     match =
       of_alist(0, [0, caml_call1(Base_List[45], alist)], hashable, alist);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var k = match[2];
    function _u_(_C_){return _C_;}
    function _v_(_B_){return _B_;}
    var
     _w_ = caml_call2(Base_Import[171], _v_, _u_),
     alist_sexps = caml_call2(Base_Import[173], _w_, sexp),
     found_first_k = [0, 0];
    function _x_(param, _y_){
     var
      k2_sexp = _y_[1],
      k2 = param[1],
      _z_ = 0 === caml_call2(hashable[2], k, k2) ? 1 : 0;
     if(_z_){
      if(found_first_k[1])
       return caml_call2
               (Base_Import[156], cst_Hashtbl_t_of_sexp_duplicat, k2_sexp);
      found_first_k[1] = 1;
      var _A_ = 0;
     }
     else
      var _A_ = _z_;
     return _A_;
    }
    caml_call3(Base_List[67], alist, alist_sexps, _x_);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function t_sexp_grammar(k_grammar, v_grammar){
    var _s_ = caml_call2(Base_List[137][3], k_grammar, v_grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _s_);
   }
   function keys(t){
    return fold(t, 0, function(key, param, acc){return [0, key, acc];});
   }
   function data(t){
    return fold(t, 0, function(param, data, list){return [0, data, list];});
   }
   function group
   (growth_allowed, size, hashable, get_key, get_data, combine, rows){
    var groups = create(growth_allowed, size, hashable, 0);
    function _r_(row){
     var
      key = caml_call1(get_key, row),
      data = caml_call1(get_data, row),
      match = find(groups, key);
     if(match)
      var old = match[1], data$0 = caml_call2(combine, old, data);
     else
      var data$0 = data;
     return set(groups, key, data$0);
    }
    caml_call2(Base_List[19], rows, _r_);
    return groups;
   }
   function create_with_key(growth_allowed, size, hashable, get_key, rows){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             get_key,
             function(_q_){return _q_;},
             rows);
   }
   function create_with_key_or_error
   (growth_allowed, size, hashable, get_key, rows){
    var
     match = create_with_key(growth_allowed, size, hashable, get_key, rows);
    if(175765640 <= match[1]){
     var
      keys = match[2],
      sexp_of_key = hashable[3],
      _o_ =
        [0, [0, cst_keys, caml_call2(Base_Import[149], sexp_of_key, keys)], 0],
      _p_ = caml_call2(Base_Sexp[10], cst_Hashtbl_create_with_key_du, _o_);
     return caml_call1(Base_Or_error[39], _p_);
    }
    var t = match[2];
    return [0, t];
   }
   function create_with_key_exn(growth_allowed, size, hashable, get_key, rows){
    var
     _n_ =
       create_with_key_or_error(growth_allowed, size, hashable, get_key, rows);
    return caml_call1(Base_Or_error[34], _n_);
   }
   function maybe_set(t, key, f, d){
    var match = caml_call2(f, key, d);
    if(! match) return 0;
    var v = match[1];
    return set(t, key, v);
   }
   function merge(t_left, t_right, f){
    if(1 - caml_call2(Base_Hashable[1], t_left[4], t_right[4]))
     caml_call1(Base_Import[126], cst_Hashtbl_merge_different_ha);
    var new_t = create([0, t_left[3]], [0, t_left[2]], t_left[4], 0);
    without_mutating
     (t_left,
      function(param){
       return without_mutating
               (t_right,
                function(param){
                 iteri
                  (t_left,
                   function(key, left){
                    var match = find(t_right, key);
                    if(! match)
                     return maybe_set(new_t, key, f, [0, 847852583, left]);
                    var right = match[1];
                    return maybe_set
                            (new_t, key, f, [0, 737457313, [0, left, right]]);
                   });
                 return iteri
                         (t_right,
                          function(key, right){
                           return find(t_left, key)
                                   ? 0
                                   : maybe_set(new_t, key, f, [0, -57574468, right]);
                          });
                });
      });
    return new_t;
   }
   function merge_into(src, dst, f){
    return iteri
            (src,
             function(key, data){
              var
               dst_data = find(dst, key),
               action =
                 without_mutating
                  (dst,
                   function(param){return caml_call3(f, key, data, dst_data);});
              if(! action) return remove(dst, key);
              var data$0 = action[1];
              if(! dst_data) return set(dst, key, data$0);
              var
               dst_data$0 = dst_data[1],
               _m_ = 1 - (dst_data$0 === data$0 ? 1 : 0);
              return _m_ ? set(dst, key, data$0) : _m_;
             });
   }
   function filteri_inplace(t, f){
    var
     to_remove =
       fold
        (t,
         0,
         function(key, data, ac){
          return caml_call2(f, key, data) ? ac : [0, key, ac];
         });
    function _l_(key){return remove(t, key);}
    return caml_call2(Base_List[19], to_remove, _l_);
   }
   function filter_inplace(t, f){
    return filteri_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys_inplace(t, f){
    return filteri_inplace
            (t, function(key, param){return caml_call1(f, key);});
   }
   function filter_mapi_inplace(t, f){
    var
     map_results =
       fold
        (t,
         0,
         function(key, data, ac){
          return [0, [0, key, caml_call2(f, key, data)], ac];
         });
    function _k_(param){
     var result = param[2], key = param[1];
     if(! result) return remove(t, key);
     var data = result[1];
     return set(t, key, data);
    }
    return caml_call2(Base_List[19], map_results, _k_);
   }
   function filter_map_inplace(t, f){
    return filter_mapi_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function mapi_inplace(t, f){
    ensure_mutation_allowed(t);
    return without_mutating
            (t,
             function(param){
              var _h_ = Base_Avltree[18];
              function _i_(_j_){return caml_call2(_h_, _j_, f);}
              return caml_call2(Base_Array[20], t[1], _i_);
             });
   }
   function map_inplace(t, f){
    return mapi_inplace(t, function(param, data){return caml_call1(f, data);});
   }
   function similar(equal, t$0, t){
    var _f_ = t$0[2] === t[2] ? 1 : 0;
    return _f_
            ? caml_call1
              (with_return,
               function(r){
                without_mutating
                 (t,
                  function(param){
                   return iteri
                           (t$0,
                            function(key, data){
                             var match = find(t, key);
                             if(! match) return caml_call1(r, 0);
                             var
                              data$0 = match[1],
                              _g_ = 1 - caml_call2(equal, data, data$0);
                             return _g_ ? caml_call1(r, 0) : _g_;
                            });
                  });
                return 1;
               })
            : _f_;
   }
   function Creators(Key){
    var hashable = Key[1];
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, hashable, 0);
    }
    function of_alist$0(growth_allowed, size, l){
     return of_alist(growth_allowed, size, hashable, l);
    }
    function of_alist_report_all_dups$0(growth_allowed, size, l){
     return of_alist_report_all_dups(growth_allowed, size, hashable, l);
    }
    function of_alist_or_error$0(growth_allowed, size, l){
     return of_alist_or_error(growth_allowed, size, hashable, l);
    }
    function of_alist_exn$0(growth_allowed, size, l){
     return of_alist_exn(growth_allowed, size, hashable, l);
    }
    function t_of_sexp$0(k_of_sexp, d_of_sexp, sexp){
     return t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp);
    }
    function of_alist_multi$0(growth_allowed, size, l){
     return of_alist_multi(growth_allowed, size, hashable, l);
    }
    function create_mapped$0(growth_allowed, size, get_key, get_data, l){
     return create_mapped
             (growth_allowed, size, hashable, get_key, get_data, l);
    }
    function create_with_key$0(growth_allowed, size, get_key, l){
     return create_with_key(growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_or_error$0(growth_allowed, size, get_key, l){
     return create_with_key_or_error
             (growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_exn$0(growth_allowed, size, get_key, l){
     return create_with_key_exn(growth_allowed, size, hashable, get_key, l);
    }
    function group$0(growth_allowed, size, get_key, get_data, combine, l){
     return group
             (growth_allowed, size, hashable, get_key, get_data, combine, l);
    }
    return [0,
            t_of_sexp$0,
            create$0,
            of_alist$0,
            of_alist_report_all_dups$0,
            of_alist_or_error$0,
            of_alist_exn$0,
            of_alist_multi$0,
            create_mapped$0,
            create_with_key$0,
            create_with_key_or_error$0,
            create_with_key_exn$0,
            group$0];
   }
   var
    hashable = Base_Hashable[2],
    _d_ = Creators([0, hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_alist$0 = _d_[3],
    of_alist_report_all_dups$0 = _d_[4],
    of_alist_or_error$0 = _d_[5],
    of_alist_exn$0 = _d_[6],
    of_alist_multi$0 = _d_[7],
    create_mapped$0 = _d_[8],
    create_with_key$0 = _d_[9],
    create_with_key_or_error$0 = _d_[10],
    create_with_key_exn$0 = _d_[11],
    group$0 = _d_[12];
   function hashable$0(t){return t[4];}
   var Private = [0, hashable$0];
   function create$1(growth_allowed, size, m){
    return create(growth_allowed, size, caml_call1(Base_Hashable[3], m), 0);
   }
   function of_alist$1(growth_allowed, size, m, l){
    return of_alist(growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_report_all_dups$1(growth_allowed, size, m, l){
    return of_alist_report_all_dups
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_or_error$1(growth_allowed, size, m, l){
    return of_alist_or_error
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_exn$1(growth_allowed, size, m, l){
    return of_alist_exn
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_multi$1(growth_allowed, size, m, l){
    return of_alist_multi
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function create_mapped$1(growth_allowed, size, m, get_key, get_data, l){
    return create_mapped
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             l);
   }
   function create_with_key$1(growth_allowed, size, m, get_key, l){
    return create_with_key
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_or_error$1(growth_allowed, size, m, get_key, l){
    return create_with_key_or_error
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_exn$1(growth_allowed, size, m, get_key, l){
    return create_with_key_exn
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function group$1(growth_allowed, size, m, get_key, get_data, combine, l){
    return group
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             combine,
             l);
   }
   function hashable_s(t){return caml_call1(Base_Hashable[4], t[4]);}
   function M(K){return [0];}
   function sexp_of_m_t(K, sexp_of_v, t){
    return sexp_of_t(K[1], sexp_of_v, t);
   }
   function m_t_of_sexp(K, v_of_sexp, sexp){
    var _e_ = K[1];
    return t_of_sexp
            (caml_call1(Base_Hashable[3], [0, K[2], K[3], K[4]]),
             _e_,
             v_of_sexp,
             sexp);
   }
   function m_t_sexp_grammar(K, v_grammar){
    return t_sexp_grammar(K[1], v_grammar);
   }
   function equal_m_t(param, equal_v, t1, t2){return similar(equal_v, t1, t2);
   }
   var
    Base_Hashtbl =
      [0,
       hash,
       hash_param,
       sexp_of_t,
       create$1,
       of_alist$1,
       of_alist_report_all_dups$1,
       of_alist_or_error$1,
       of_alist_exn$1,
       of_alist_multi$1,
       create_mapped$1,
       create_with_key$1,
       create_with_key_or_error$1,
       create_with_key_exn$1,
       group$1,
       sexp_of_key,
       clear,
       copy,
       fold,
       iter_keys,
       iter,
       iteri,
       existsi,
       exists,
       for_alli,
       for_all,
       counti,
       count,
       length,
       capacity,
       is_empty,
       mem,
       remove,
       choose,
       choose_exn,
       choose_randomly,
       choose_randomly_exn,
       set,
       add,
       add_exn,
       change,
       update,
       update_and_return,
       map,
       mapi,
       filter_map,
       filter_mapi,
       filter_keys,
       filter,
       filteri,
       partition_map,
       partition_mapi,
       partition_tf,
       partitioni_tf,
       find_or_add,
       findi_or_add,
       find,
       find_exn,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       find_and_remove,
       merge,
       merge_into,
       keys,
       data,
       filter_keys_inplace,
       filter_inplace,
       filteri_inplace,
       map_inplace,
       mapi_inplace,
       filter_map_inplace,
       filter_mapi_inplace,
       similar,
       similar,
       to_alist,
       incr,
       decr,
       add_multi,
       remove_multi,
       find_multi,
       hashable_s,
       invariant,
       Creators,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        hashable,
        invariant,
        create$0,
        of_alist$0,
        of_alist_report_all_dups$0,
        of_alist_or_error$0,
        of_alist_exn$0,
        of_alist_multi$0,
        create_mapped$0,
        create_with_key$0,
        create_with_key_or_error$0,
        create_with_key_exn$0,
        group$0,
        sexp_of_key,
        clear,
        copy,
        fold,
        iter_keys,
        iter,
        iteri,
        existsi,
        exists,
        for_alli,
        for_all,
        counti,
        count,
        length,
        capacity,
        is_empty,
        mem,
        remove,
        choose,
        choose_exn,
        choose_randomly,
        choose_randomly_exn,
        set,
        add,
        add_exn,
        change,
        update,
        update_and_return,
        map,
        mapi,
        filter_map,
        filter_mapi,
        filter_keys,
        filter,
        filteri,
        partition_map,
        partition_mapi,
        partition_tf,
        partitioni_tf,
        find_or_add,
        findi_or_add,
        find,
        find_exn,
        find_and_call,
        find_and_call1,
        find_and_call2,
        findi_and_call,
        findi_and_call1,
        findi_and_call2,
        find_and_remove,
        merge,
        merge_into,
        keys,
        data,
        filter_keys_inplace,
        filter_inplace,
        filteri_inplace,
        map_inplace,
        mapi_inplace,
        filter_map_inplace,
        filter_mapi_inplace,
        similar,
        similar,
        to_alist,
        incr,
        decr,
        add_multi,
        remove_multi,
        find_multi],
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(26, Base_Hashtbl, "Base__Hashtbl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_set_intf = [0];
   runtime.caml_register_global(0, Base_Hash_set_intf, "Base__Hash_set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set
//# unitInfo: Requires: Base__Array, Base__Container, Base__Hash_set_intf, Base__Hashable, Base__Hashtbl, Base__Import, Base__List, Base__Or_error, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_List = global_data.Base__List,
    Base_Hashable = global_data.Base__Hashable,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Base_Array = global_data.Base__Array,
    Base_Container = global_data.Base__Container,
    Base_Or_error = global_data.Base__Or_error,
    Base_With_return = global_data.Base__With_return,
    hashable_s = Base_Hashtbl[84],
    hashable = Base_Hashtbl[93][1],
    poly_hashable = Base_Hashtbl[87][4],
    with_return = Base_With_return[1],
    clear = Base_Hashtbl[16],
    length = Base_Hashtbl[28],
    mem = Base_Hashtbl[31],
    cst_Hash_set_t_of_sexp_got_a_d =
      "Hash_set.t_of_sexp got a duplicate element",
    cst_Hash_set_t_of_sexp_require = "Hash_set.t_of_sexp requires a list",
    _c_ = [0, 0],
    _b_ = [0, 0],
    cst_element_not_in_set = "element not in set",
    cst_element_already_exists = "element already exists",
    _a_ = [0, 0];
   function is_empty(t){return caml_call1(Base_Hashtbl[30], t);}
   function find_map(t, f){
    return caml_call1
            (with_return,
             function(r){
              function _C_(elt){
               var o = caml_call1(f, elt);
               return o ? caml_call1(r, o) : 0;
              }
              caml_call2(Base_Hashtbl[19], t, _C_);
              return 0;
             });
   }
   function find(t, f){
    return find_map(t, function(a){return caml_call1(f, a) ? [0, a] : 0;});
   }
   function add(t, k){return caml_call3(Base_Hashtbl[37], t, k, 0);}
   function strict_add(t, k){
    return caml_call2(mem, t, k)
            ? caml_call1(Base_Or_error[40], cst_element_already_exists)
            : (caml_call3(Base_Hashtbl[37], t, k, 0), _a_);
   }
   function strict_add_exn(t, k){
    var _B_ = strict_add(t, k);
    return caml_call1(Base_Or_error[34], _B_);
   }
   var remove = Base_Hashtbl[32];
   function strict_remove(t, k){
    if(caml_call2(mem, t, k)){caml_call2(remove, t, k); return _b_;}
    var _A_ = caml_call1(Base_Hashtbl[15], t);
    return caml_call5(Base_Or_error[38], 0, 0, cst_element_not_in_set, k, _A_);
   }
   function strict_remove_exn(t, k){
    var _z_ = strict_remove(t, k);
    return caml_call1(Base_Or_error[34], _z_);
   }
   function fold(t, init, f){
    function _y_(key, param, acc){return caml_call2(f, acc, key);}
    return caml_call3(Base_Hashtbl[18], t, init, _y_);
   }
   function iter(t, f){return caml_call2(Base_Hashtbl[19], t, f);}
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f, finish){
    return caml_call5(Base_Container[9], fold, init, f, finish, t);
   }
   var to_list = Base_Hashtbl[67];
   function sexp_of_t(sexp_of_e, t){
    var
     _w_ = caml_call1(to_list, t),
     func = Base_List[83],
     _x_ = caml_call2(func, _w_, caml_call1(hashable, t)[2]);
    return caml_call2(Base_Import[149], sexp_of_e, _x_);
   }
   function to_array(t){
    var
     len = caml_call1(length, t),
     index = [0, caml_call2(Base_Import[93], len, 1)];
    return fold
            (t,
             [0],
             function(acc, key){
              if(0 === acc.length - 1)
               return caml_call2(Base_Array[48], len, key);
              index[1] = caml_call2(Base_Import[93], index[1], 1);
              var _v_ = index[1];
              runtime.caml_check_bound(acc, _v_)[1 + _v_] = key;
              return acc;
             });
   }
   function exists(t, f){
    function _u_(key, param){return caml_call1(f, key);}
    return caml_call2(Base_Hashtbl[22], t, _u_);
   }
   function for_all(t, f){
    function _t_(key, param){return 1 - caml_call1(f, key);}
    return 1 - caml_call2(Base_Hashtbl[22], t, _t_);
   }
   function equal(t1, t2){
    function _r_(param, _s_){return 1;}
    return caml_call3(Base_Hashtbl[76], _r_, t1, t2);
   }
   function copy(t){return caml_call1(Base_Hashtbl[17], t);}
   function filter(t, f){
    function _q_(key, param){return caml_call1(f, key);}
    return caml_call2(Base_Hashtbl[49], t, _q_);
   }
   function union(t1, t2){
    function _o_(param, _p_){return _c_;}
    return caml_call3(Base_Hashtbl[65], t1, t2, _o_);
   }
   function diff(t1, t2){
    return filter
            (t1,
             function(key){return 1 - caml_call2(Base_Hashtbl[31], t2, key);});
   }
   function inter(t1, t2){
    var _m_ = caml_call1(length, t2);
    if(_m_ < caml_call1(length, t1))
     var larger = t1, smaller = t2;
    else
     var larger = t2, smaller = t1;
    function _n_(key, param){
     return caml_call2(Base_Hashtbl[31], larger, key);
    }
    return caml_call2(Base_Hashtbl[49], smaller, _n_);
   }
   function filter_inplace(t, f){
    var
     to_remove =
       fold(t, 0, function(ac, x){return caml_call1(f, x) ? ac : [0, x, ac];});
    function _l_(x){return caml_call2(remove, t, x);}
    return caml_call2(Base_List[19], to_remove, _l_);
   }
   function of_hashtbl_keys(hashtbl){
    function _j_(_k_){return 0;}
    return caml_call2(Base_Hashtbl[43], hashtbl, _j_);
   }
   function to_hashtbl(t, f){
    function _i_(key, param){return caml_call1(f, key);}
    return caml_call2(Base_Hashtbl[44], t, _i_);
   }
   function create(growth_allowed, size, m){
    return caml_call3(Base_Hashtbl[4], growth_allowed, size, m);
   }
   function of_list(growth_allowed, size, m, l){
    if(size)
     var x = size[1], size$0 = x;
    else
     var size$0 = caml_call1(Base_List[45], l);
    var t = caml_call3(Base_Hashtbl[4], growth_allowed, [0, size$0], m);
    function _h_(k){return add(t, k);}
    caml_call2(Base_List[19], l, _h_);
    return t;
   }
   function t_of_sexp(m, e_of_sexp, sexp){
    if(0 === sexp[0])
     return caml_call2(Base_Import[156], cst_Hash_set_t_of_sexp_require, sexp);
    var
     list = sexp[1],
     t = create(0, [0, caml_call1(Base_List[45], list)], m);
    function _g_(sexp){
     var e = caml_call1(e_of_sexp, sexp);
     return 0 === strict_add(t, e)[0]
             ? 0
             : caml_call2
               (Base_Import[156], cst_Hash_set_t_of_sexp_got_a_d, sexp);
    }
    caml_call2(Base_List[19], list, _g_);
    return t;
   }
   function Creators(Elt){
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]));
    }
    function of_list$0(growth_allowed, size, l){
     return of_list
             (growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]), l);
    }
    function t_of_sexp$0(e_of_sexp, sexp){
     return t_of_sexp(caml_call1(Base_Hashable[4], Elt[1]), e_of_sexp, sexp);
    }
    return [0, t_of_sexp$0, create$0, of_list$0];
   }
   var
    _d_ = Creators([0, poly_hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_list$0 = _d_[3];
   function t_sexp_grammar(grammar){
    var _f_ = caml_call1(Base_List[7], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _f_);
   }
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt, t){return sexp_of_t(Elt[1], t);}
   function m_t_of_sexp(Elt, sexp){
    return t_of_sexp([0, Elt[2], Elt[3], Elt[4]], Elt[1], sexp);
   }
   function m_t_sexp_grammar(Elt){
    var _e_ = caml_call1(Base_Import[194], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _e_);
   }
   function equal_m_t(param, t1, t2){return equal(t1, t2);}
   var
    hashable$0 = Base_Hashtbl[93][1],
    Private = [0, hashable$0],
    Base_Hash_set =
      [0,
       sexp_of_t,
       create,
       of_list,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       mem,
       copy,
       add,
       strict_add,
       strict_add_exn,
       remove,
       strict_remove,
       strict_remove_exn,
       clear,
       equal,
       filter,
       filter_inplace,
       inter,
       union,
       diff,
       of_hashtbl_keys,
       to_hashtbl,
       hashable_s,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        create$0,
        of_list$0,
        length,
        is_empty,
        iter,
        fold,
        fold_result,
        fold_until,
        exists,
        for_all,
        count,
        sum,
        find,
        find_map,
        to_list,
        to_array,
        min_elt,
        max_elt,
        mem,
        copy,
        add,
        strict_add,
        strict_add_exn,
        remove,
        strict_remove,
        strict_remove_exn,
        clear,
        equal,
        filter,
        filter_inplace,
        inter,
        union,
        diff,
        of_hashtbl_keys,
        to_hashtbl],
       Creators,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(16, Base_Hash_set, "Base__Hash_set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float
//# unitInfo: Requires: Base__Bytes0, Base__Char, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int, Base__Int63, Base__Int64, Base__Int_string_conversions, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Base__Word_size, Sexplib0__Sexp_conv_error, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_out_of_range_0 = " out of range [0, ",
    cst_s_1e = "%s%.1e",
    cst_is_too_large = ") is too large",
    cst_is_too_small_or_NaN = ") is too small or NaN",
    cst$5 = ".",
    cst_Float_int63_round_down_exn = "Float.int63_round_down_exn: argument (",
    cst_Float_int63_round_nearest_ =
      "Float.int63_round_nearest_portable_alloc_exn: argument (",
    cst_Float_int63_round_up_exn_a = "Float.int63_round_up_exn: argument (",
    cst_Float_iround_down_exn_argu = "Float.iround_down_exn: argument (",
    cst_Float_iround_nearest_exn_a = "Float.iround_nearest_exn: argument (",
    cst_Float_iround_nearest_exn_a$0 =
      "Float.iround_nearest_exn: argument (%f) is too large",
    cst_Float_iround_up_exn_argume = "Float.iround_up_exn: argument (",
    cst_Infinite = "Infinite",
    cst_Nan = "Nan",
    cst_Normal = "Normal",
    cst_Subnormal = "Subnormal",
    cst_Zero = "Zero",
    cst_infinite = "infinite",
    cst_nan$1 = "nan",
    cst_normal = "normal",
    cst_src_float_ml = "src/float.ml",
    cst_subnormal = "subnormal",
    cst_zero = "zero",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_float_compare = runtime.caml_float_compare,
    caml_format_float = runtime.caml_format_float,
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_or = runtime.caml_int64_or,
    caml_int_compare = runtime.caml_int_compare,
    caml_log10_float = runtime.caml_log10_float,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$4,
    cst$2 = cst$4,
    cst$1 = "-",
    cst$0 = cst$5,
    cst = cst$5,
    all = [0, 0, [0, 1, [0, 2, [0, 3, [0, 4, 0]]]]],
    error_source_007 = "float.ml.Class.t",
    t_sexp_grammar$0 =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Infinite, 0]],
         [0,
          [1, [0, cst_Nan, 0]],
          [0,
           [1, [0, cst_Normal, 0]],
           [0, [1, [0, cst_Subnormal, 0]], [0, [1, [0, cst_Zero, 0]], 0]]]]]]],
    module_name = "Base.Float",
    Base_Printf = global_data.Base__Printf,
    Base_Or_error = global_data.Base__Or_error,
    Base_Int = global_data.Base__Int,
    Base_Int63 = global_data.Base__Int63,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Int64 = global_data.Base__Int64,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_String = global_data.Base__String,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Char = global_data.Base__Char,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Word_size = global_data.Base__Word_size,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    round_up = Base_Float0[1],
    round_down = Base_Float0[2],
    mod_float = Base_Float0[3],
    modf = Base_Float0[4],
    float_of_string = Base_Float0[5],
    float_of_string_opt = Base_Float0[6],
    nan = Base_Float0[7],
    max_value = Base_Float0[8],
    neg_infinity = Base_Float0[9],
    max_finite_value = Base_Float0[10],
    epsilon_float = Base_Float0[11],
    classify_float = Base_Float0[12],
    abs_float = Base_Float0[13],
    is_integer = Base_Float0[14],
    symbol = Base_Float0[15],
    symbol$0 = Base_Float0[16],
    frexp = Base_Float0[17],
    ldexp = Base_Float0[18],
    is_nan = Base_Float0[19],
    to_int64_preserve_order = Base_Float0[20],
    to_int64_preserve_order_exn = Base_Float0[21],
    of_int64_preserve_order = Base_Float0[22],
    one_ulp = Base_Float0[23],
    upper_bound_for_int = Base_Float0[24],
    lower_bound_for_int = Base_Float0[26],
    clamp_unchecked = Base_Float0[28],
    box = Base_Float0[29],
    raise_s = Base_Error[32],
    hash_fold_t = Base_Import[209],
    func = Base_Import[223],
    _R_ = [0, [8, [0, 0, 4], 0, [0, 8], 0], "%.8G"],
    _P_ =
      [0,
       [11,
        "exponent ",
        [4, 0, 0, 0, [11, cst_out_of_range_0, [4, 0, 0, 0, [12, 93, 0]]]]],
       "exponent %d out of range [0, %d]"],
    _Q_ =
      [0,
       [11,
        "mantissa ",
        [2, 0, [11, cst_out_of_range_0, [2, 0, [12, 93, 0]]]]],
       "mantissa %s out of range [0, %s]"],
    cst_Float_sign_exn_of_NAN = "Float.sign_exn of NAN",
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _L_ = [0, cst_src_float_ml, 865, 2],
    _K_ =
      [0,
       [11,
        "Float.round_significant: invalid argument significant_digits:",
        [4, 0, 0, 0, 0]],
       "Float.round_significant: invalid argument significant_digits:%d"],
    _J_ = [0, [8, [0, 0, 3], 0, 1, 0], "%.*g"],
    _I_ = [0, "p"],
    cst_t = "t",
    cst_g = "g",
    cst_m = "m",
    cst_k = "k",
    _F_ = [0, cst_src_float_ml, 703, 8],
    _E_ = [0, cst_src_float_ml, 706, 8],
    _A_ = [0, cst_src_float_ml, 713, 8],
    _B_ = [0, cst_src_float_ml, 714, 8],
    _C_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [12, 32, 0]]]], "%s%d%s "],
    _D_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [4, 0, 0, 0, 0]]]], "%s%d%s%d"],
    _z_ = [0, cst_src_float_ml, 690, 8],
    cst_0 = ".0",
    _G_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    _H_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    cst_inf$1 = "-inf  ",
    cst_inf$2 = "inf  ",
    cst_nan$0 = "nan  ",
    cst_sexp = "sexp",
    cst_sexp_of_float_produced_str = "[sexp_of_float] produced strange sexp",
    _w_ =
      [0,
       [11, "to_string_hum: invalid argument ~decimals=", [4, 0, 0, 0, 0]],
       "to_string_hum: invalid argument ~decimals=%d"],
    _x_ = [0, [8, [0, 1, 0], 0, 1, 0], "%+.*f"],
    _y_ = [0, [8, [0, 0, 0], 0, 1, 0], "%.*f"],
    cst_inf = "inf",
    cst_inf$0 = "-inf",
    cst_nan = cst_nan$1,
    _r_ = [0, cst_Infinite],
    _s_ = [0, cst_Nan],
    _t_ = [0, cst_Normal],
    _u_ = [0, cst_Subnormal],
    _v_ = [0, cst_Zero],
    _p_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too large"],
    _q_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too small or NaN"],
    _n_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too large"],
    _o_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too small or NaN"],
    _l_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too large"],
    _m_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too small or NaN"],
    _j_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _k_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small or NaN"],
    _h_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _i_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, ") is too small", 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small"],
    _f_ =
      [0,
       [11,
        "Float.iround_towards_zero_exn: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Float.iround_towards_zero_exn: argument (%f) is out of range or NaN"],
    _d_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_down_exn: argument (%f) is too large"],
    _e_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_down_exn: argument (%f) is too small or NaN"],
    _b_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_up_exn: argument (%f) is too large"],
    _c_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_up_exn: argument (%f) is too small or NaN"],
    _a_ = [0, [11, "Float.of_string ", [2, 0, 0]], "Float.of_string %s"];
   function hash(x){return caml_call1(func, x);}
   var
    globalize = Base_Import[283],
    t_of_sexp = Base_Import[164],
    sexp_of_t = Base_Import[140],
    t_sexp_grammar = Base_Import[186],
    hashable = [0, hash, caml_float_compare, sexp_of_t],
    compare = caml_float_compare,
    include = caml_call1(Base_Comparator[7], [0, compare, sexp_of_t]),
    comparator = include[1];
   function invariant(param){return 0;}
   function to_float(x){return x;}
   function of_float(x){return x;}
   function of_string(s){
    try{var _a3_ = caml_call1(float_of_string, s); return _a3_;}
    catch(_a4_){return caml_call3(Base_Printf[7], _a_, s, 0);}
   }
   function to_string(x){
    var
     y = caml_format_float("%.15g", x),
     y$0 =
       caml_call1(float_of_string, y) == x ? y : caml_format_float("%.17g", x),
     l = runtime.caml_ml_string_length(y$0),
     i = 0;
    for(;;){
     if(l <= i) return caml_call2(Base_Import[112], y$0, cst);
     var match = runtime.caml_string_get(y$0, i);
     a:
     {
      if(48 <= match){if(58 > match) break a;} else if(45 === match) break a;
      return y$0;
     }
     var i$0 = caml_call2(Base_Import[91], i, 1), i = i$0;
    }
   }
   var
    min_positive_subnormal_value = caml_call2(symbol, 2., -1074.),
    min_positive_normal_value = caml_call2(symbol, 2., -1022.),
    of_int = Base_Int[4],
    to_int = Base_Int[3],
    zero = 0.,
    one = 1.,
    minus_one = -1.,
    pi = 3.141592653589793,
    sqrt_pi = 1.772453850905516,
    sqrt_2pi = 2.5066282746310007,
    euler = 0.5772156649015329;
   function of_int63(i){return caml_call1(Base_Int63[3], i);}
   var
    of_int64 = runtime.caml_int64_to_float,
    to_int64 = runtime.caml_int64_of_float,
    iround_lbound = caml_call1(lower_bound_for_int, Base_Int[64]),
    iround_ubound = caml_call1(upper_bound_for_int, Base_Int[64]);
   function iround_up(t){
    if(! (0. < t))
     return iround_lbound <= t ? [0, caml_call1(Base_Int[63], t)] : 0;
    var t$0 = caml_call1(round_up, t);
    return t$0 <= iround_ubound ? [0, caml_call1(Base_Int[63], t$0)] : 0;
   }
   function iround_up_exn(t){
    if(0. < t){
     var t$0 = caml_call1(round_up, t);
     if(t$0 <= iround_ubound) return caml_call1(Base_Int[63], t$0);
     var _a1_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _b_, _a1_, 0);
    }
    if(iround_lbound <= t) return caml_call1(Base_Int[63], t);
    var _a2_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _c_, _a2_, 0);
   }
   function iround_down(t){
    if(0. <= t)
     return t <= iround_ubound ? [0, caml_call1(Base_Int[63], t)] : 0;
    var t$0 = caml_call1(round_down, t);
    return iround_lbound <= t$0 ? [0, caml_call1(Base_Int[63], t$0)] : 0;
   }
   function iround_down_exn(t){
    if(0. <= t){
     if(t <= iround_ubound) return caml_call1(Base_Int[63], t);
     var _aZ_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _d_, _aZ_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(iround_lbound <= t$0) return caml_call1(Base_Int[63], t$0);
    var _a0_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _e_, _a0_, 0);
   }
   function iround_towards_zero(t){
    if(iround_lbound <= t && t <= iround_ubound)
     return [0, caml_call1(Base_Int[63], t)];
    return 0;
   }
   function iround_towards_zero_exn(t){
    if(iround_lbound <= t && t <= iround_ubound)
     return caml_call1(Base_Int[63], t);
    var _aY_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _f_, _aY_, 0);
   }
   var
    _g_ = caml_call2(symbol, 2., 52.),
    round_nearest_lb = caml_call1(Base_Import[114], _g_),
    round_nearest_ub = caml_call2(symbol, 2., 52.),
    one_ulp_less_than_half = caml_call2(one_ulp, 759637122, 0.5);
   function add_half_for_round_nearest(t){
    var _aX_ = t == one_ulp_less_than_half ? one_ulp_less_than_half : 0.5;
    return caml_call2(Base_Import[92], t, _aX_);
   }
   function iround_nearest_32(t){
    if(0. <= t){
     var t$0 = add_half_for_round_nearest(t);
     return t$0 <= iround_ubound ? [0, caml_call1(Base_Int[63], t$0)] : 0;
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
    return iround_lbound <= t$1 ? [0, caml_call1(Base_Int[63], t$1)] : 0;
   }
   function iround_nearest_64(t){
    if(0. <= t){
     if(! (t < round_nearest_ub))
      return t <= iround_ubound ? [0, caml_call1(Base_Int[63], t)] : 0;
     var _aV_ = add_half_for_round_nearest(t);
     return [0, caml_call1(Base_Int[63], _aV_)];
    }
    if(! (round_nearest_lb < t))
     return iround_lbound <= t ? [0, caml_call1(Base_Int[63], t)] : 0;
    var _aW_ = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
    return [0, caml_call1(Base_Int[63], _aW_)];
   }
   var
    iround_nearest_64$0 =
      Base_Word_size[3] ? iround_nearest_64 : iround_nearest_32;
   function iround_nearest_exn_32(t){
    if(0. <= t){
     var t$0 = add_half_for_round_nearest(t);
     if(t$0 <= iround_ubound) return caml_call1(Base_Int[63], t$0);
     var _aT_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _h_, _aT_, 0);
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
    if(iround_lbound <= t$1) return caml_call1(Base_Int[63], t$1);
    var _aU_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _i_, _aU_, 0);
   }
   function iround_nearest_exn_64(t){
    if(0. <= t){
     if(t < round_nearest_ub){
      var _aP_ = add_half_for_round_nearest(t);
      return caml_call1(Base_Int[63], _aP_);
     }
     if(t <= iround_ubound) return caml_call1(Base_Int[63], t);
     var _aQ_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _j_, _aQ_, 0);
    }
    if(round_nearest_lb < t){
     var _aR_ = caml_call1(round_down, caml_call2(Base_Import[92], t, 0.5));
     return caml_call1(Base_Int[63], _aR_);
    }
    if(iround_lbound <= t) return caml_call1(Base_Int[63], t);
    var _aS_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _k_, _aS_, 0);
   }
   var
    iround_nearest_exn =
      Base_Word_size[3] ? iround_nearest_exn_64 : iround_nearest_exn_32;
   function iround_exn(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    return 857423934 <= dir
            ? 1003109192
              <= dir
              ? iround_towards_zero_exn(t)
              : iround_nearest_exn(t)
            : 759637122 <= dir ? iround_down_exn(t) : iround_up_exn(t);
   }
   function iround(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    try{var _aN_ = [0, iround_exn([0, dir], t)]; return _aN_;}
    catch(_aO_){return 0;}
   }
   function is_inf(t){
    return caml_call2(Base_Import[96], 1., t) == 0. ? 1 : 0;
   }
   function is_finite(t){
    return caml_call2(Base_Import[94], t, t) == 0. ? 1 : 0;
   }
   function min_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1(is_nan, x) ? y : x < y ? x : y;
   }
   function max_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1(is_nan, x) ? y : y < x ? x : y;
   }
   var
    add = Base_Import[92],
    sub = Base_Import[94],
    neg = Base_Import[114],
    scale = Base_Import[90];
   function square(x){return caml_call2(Base_Import[90], x, x);}
   function fractional(t){return caml_call1(Base_Import[125], t);}
   function integral(t){return caml_call1(Base_Import[127], t);}
   function round_towards_zero(t){
    return 0. <= t ? caml_call1(round_down, t) : caml_call1(round_up, t);
   }
   function round_nearest_inline(t){
    if(round_nearest_lb < t && t < round_nearest_ub)
     return caml_call1(round_down, add_half_for_round_nearest(t));
    return caml_call2(Base_Import[92], t, 0.);
   }
   function round_nearest(t){return round_nearest_inline(t);}
   function round_nearest_half_to_even(t){
    if(! (t <= round_nearest_lb) && ! (round_nearest_ub <= t)){
     var
      floor = caml_call1(round_down, t),
      ceil_or_succ = caml_call2(Base_Import[92], floor, 1.),
      diff_floor = caml_call2(Base_Import[94], t, floor),
      diff_ceil = caml_call2(Base_Import[94], ceil_or_succ, t);
     return diff_floor < diff_ceil
             ? floor
             : diff_ceil
               < diff_floor
               ? ceil_or_succ
               : caml_call2(mod_float, floor, 2.) == 0. ? floor : ceil_or_succ;
    }
    return caml_call2(Base_Import[92], t, 0.);
   }
   var
    int63_round_lbound = caml_call1(lower_bound_for_int, Base_Int63[87]),
    int63_round_ubound = caml_call1(upper_bound_for_int, Base_Int63[87]);
   function int63_round_up_exn(t){
    if(0. < t){
     var t$0 = caml_call1(round_up, t);
     if(t$0 <= int63_round_ubound) return caml_call1(Base_Int63[86], t$0);
     var _aL_ = caml_call1(Base_Float0[29], t);
     return caml_call3(Base_Printf[7], _l_, _aL_, 0);
    }
    if(int63_round_lbound <= t) return caml_call1(Base_Int63[86], t);
    var _aM_ = caml_call1(Base_Float0[29], t);
    return caml_call3(Base_Printf[7], _m_, _aM_, 0);
   }
   function int63_round_down_exn(t){
    if(0. <= t){
     if(t <= int63_round_ubound) return caml_call1(Base_Int63[86], t);
     var _aJ_ = caml_call1(Base_Float0[29], t);
     return caml_call3(Base_Printf[7], _n_, _aJ_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(int63_round_lbound <= t$0) return caml_call1(Base_Int63[86], t$0);
    var _aK_ = caml_call1(Base_Float0[29], t);
    return caml_call3(Base_Printf[7], _o_, _aK_, 0);
   }
   function int63_round_nearest_portable_a(t0){
    var t = round_nearest_inline(t0);
    if(0. < t){
     if(t <= int63_round_ubound) return caml_call1(Base_Int63[86], t);
     var _aH_ = caml_call1(box, t0);
     return caml_call3(Base_Printf[7], _p_, _aH_, 0);
    }
    if(int63_round_lbound <= t) return caml_call1(Base_Int63[86], t);
    var _aI_ = caml_call1(box, t0);
    return caml_call3(Base_Printf[7], _q_, _aI_, 0);
   }
   function int63_round_nearest_arch64_noa(f){
    var _aG_ = iround_nearest_exn(f);
    return caml_call1(Base_Int63[100], _aG_);
   }
   var
    int63_round_nearest_exn =
      Base_Word_size[3]
       ? int63_round_nearest_arch64_noa
       : int63_round_nearest_portable_a;
   function round(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    return 857423934 <= dir
            ? 1003109192 <= dir ? round_towards_zero(t) : round_nearest(t)
            : 759637122
              <= dir
              ? caml_call1(round_down, t)
              : caml_call1(round_up, t);
   }
   var compare_local = caml_int_compare, compare$0 = caml_int_compare;
   function t_of_sexp$0(sexp_008){
    a:
    {
     if(0 === sexp_008[0]){
      var _aA_ = sexp_008[1], _aB_ = caml_string_compare(_aA_, cst_infinite);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          if(0 <= _aB_){
           if(0 < _aB_){
            if(! caml_string_notequal(_aA_, cst_nan$1)) break e;
            if(! caml_string_notequal(_aA_, cst_normal)) break d;
            if(! caml_string_notequal(_aA_, cst_subnormal)) break c;
            if(caml_string_notequal(_aA_, cst_zero)) break a;
            break b;
           }
          }
          else if(caml_string_notequal(_aA_, cst_Infinite)){
           if(! caml_string_notequal(_aA_, cst_Nan)) break e;
           if(! caml_string_notequal(_aA_, cst_Normal)) break d;
           if(! caml_string_notequal(_aA_, cst_Subnormal)) break c;
           if(caml_string_notequal(_aA_, cst_Zero)) break a;
           break b;
          }
          return 0;
         }
         return 1;
        }
        return 2;
       }
       return 3;
      }
      return 4;
     }
     var _aC_ = sexp_008[1];
     if(! _aC_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[11], error_source_007, sexp_008);
     var _aD_ = _aC_[1];
     if(0 !== _aD_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_007, sexp_008);
     var _aE_ = _aD_[1], _aF_ = caml_string_compare(_aE_, cst_infinite);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         if(0 <= _aF_){
          if(0 < _aF_){
           if(! caml_string_notequal(_aE_, cst_nan$1)) break e;
           if(! caml_string_notequal(_aE_, cst_normal)) break d;
           if(! caml_string_notequal(_aE_, cst_subnormal)) break c;
           if(caml_string_notequal(_aE_, cst_zero)) break a;
           break b;
          }
         }
         else if(caml_string_notequal(_aE_, cst_Infinite)){
          if(! caml_string_notequal(_aE_, cst_Nan)) break e;
          if(! caml_string_notequal(_aE_, cst_Normal)) break d;
          if(! caml_string_notequal(_aE_, cst_Subnormal)) break c;
          if(caml_string_notequal(_aE_, cst_Zero)) break a;
          break b;
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[7], error_source_007, sexp_008);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[7], error_source_007, sexp_008);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[7], error_source_007, sexp_008);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_007, sexp_008);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[7], error_source_007, sexp_008);
    }
    return caml_call2
            (Sexplib0_Sexp_conv_error[12], error_source_007, sexp_008);
   }
   function sexp_of_t$0(param){
    switch(param){
      case 0:
       return _r_;
      case 1:
       return _s_;
      case 2:
       return _t_;
      case 3:
       return _u_;
      default: return _v_;
    }
   }
   function to_string$0(t){
    var _az_ = sexp_of_t$0(t);
    return caml_call1(Base_Import[160], _az_);
   }
   function of_string$0(s){
    return t_of_sexp$0(caml_call1(Base_Import[136], s));
   }
   function classify(t){
    switch(caml_call1(classify_float, t)){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      case 3:
       return 0;
      default: return 1;
    }
   }
   function insert_underscores(opt, _aw_, string){
    if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
    if(_aw_) var sth$0 = _aw_[1], strip_zero = sth$0; else var strip_zero = 0;
    var match = caml_call2(Base_String[100], string, 46);
    if(! match)
     return caml_call2(Base_Int_string_conversions[6], string, delimiter);
    var
     match$0 = match[1],
     right = match$0[2],
     left = match$0[1],
     left$0 = caml_call2(Base_Int_string_conversions[6], left, delimiter);
    if(strip_zero)
     var
      _ax_ = [0, function(c){return caml_call2(Base_Char[12], c, 48);}],
      right$0 = caml_call2(Base_String[108], _ax_, right);
    else
     var right$0 = right;
    if(! caml_string_notequal(right$0, cst$4)) return left$0;
    var _ay_ = caml_call2(Base_Import[112], cst$0, right$0);
    return caml_call2(Base_Import[112], left$0, _ay_);
   }
   function to_string_hum(delimiter, opt, strip_zero, _av_, f){
    if(opt) var sth = opt[1], decimals = sth; else var decimals = 3;
    if(_av_)
     var sth$0 = _av_[1], explicit_plus = sth$0;
    else
     var explicit_plus = 0;
    if(decimals < 0) caml_call3(Base_Printf[7], _w_, decimals, 0);
    var match = classify(f);
    if(1 === match) return cst_nan;
    if(! match) return 0. < f ? cst_inf : cst_inf$0;
    var
     s =
       explicit_plus
        ? caml_call3(Base_Printf[2], _x_, decimals, f)
        : caml_call3(Base_Printf[2], _y_, decimals, f);
    return insert_underscores(delimiter, strip_zero, s);
   }
   function sexp_of_t$1(t){
    var sexp = caml_call1(sexp_of_t, t);
    if(1009018843 <= Base_Sexp[19][1]) return sexp;
    if(0 === sexp[0]){
     var string = sexp[1];
     return caml_call4(Base_String[70], 0, 0, string, 69)
             ? sexp
             : [0, insert_underscores(0, 0, string)];
    }
    var _au_ = [0, [0, cst_sexp, caml_call1(Base_Sexp[5], sexp)], 0];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[10], cst_sexp_of_float_produced_str, _au_));
   }
   function to_padded_compact_string_custo
   (t, opt, kilo, mega, giga, tera, peta, param){
    if(opt) var sth = opt[1], prefix = sth; else var prefix = cst$2;
    var match = classify(t);
    if(1 === match) return cst_nan$0;
    if(! match) return t < 0. ? cst_inf$1 : cst_inf$2;
    function go(t){
     function conv(mag, numerator, denominator){
      a:
      {
       if(denominator == 100. && 999.95 <= numerator) break a;
       if
        (100000. <= denominator
         &&
          round_nearest(caml_call2(Base_Import[90], denominator, 9.9995))
          <= numerator)
        break a;
       throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
      }
      if
       (!
        (numerator
        < round_nearest(caml_call2(Base_Import[90], denominator, 9999.5))))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
      var
       k =
         caml_call1
          (round_down, caml_call2(Base_Import[96], numerator, denominator)),
       lower = caml_call2(Base_Import[90], denominator, k),
       _at_ = caml_call2(Base_Import[92], k, 1.),
       higher = caml_call2(Base_Import[90], denominator, _at_),
       diff_right = caml_call2(Base_Import[94], higher, numerator),
       diff_left = caml_call2(Base_Import[94], numerator, lower),
       k$0 = iround_nearest_exn(k),
       k$1 =
         diff_right < diff_left
          ? caml_call2(Base_Import[91], k$0, 1)
          : diff_left
            < diff_right
            ? k$0
            : 0
              === caml_call2(Base_Import[122], k$0, 2)
              ? k$0
              : caml_call2(Base_Import[91], k$0, 1),
       d = caml_call2(Base_Import[122], k$1, 10),
       i = caml_call2(Base_Import[95], k$1, 10);
      if(0 <= i && 1000 > i){
       if(0 <= d && 10 > d)
        return 0 === d
                ? caml_call4(Base_Printf[2], _C_, prefix, i, mag)
                : caml_call5(Base_Printf[2], _D_, prefix, i, mag, d);
       throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     }
     if(! (t < 999.95)){
      if(t < 999950.) return conv(kilo, t, 100.);
      if(t < 999950000.) return conv(mega, t, 100000.);
      if(t < 999950000000.) return conv(giga, t, 100000000.);
      if(t < 999950000000000.) return conv(tera, t, 100000000000.);
      if(! peta) return caml_call3(Base_Printf[2], _H_, prefix, t);
      var peta$0 = peta[1];
      return t < 999950000000000000.
              ? conv(peta$0, t, 100000000000000.)
              : caml_call3(Base_Printf[2], _G_, prefix, t);
     }
     if(0. <= t && t < 999.95){
      var
       x = caml_call2(Base_Import[112], prefix, caml_format_float("%.1f", t));
      if(! caml_call2(Base_String[96], x, cst_0)) return x;
      var
       x$0 = caml_call1(Base_Bytes0[21], x),
       n = runtime.caml_ml_bytes_length(x$0);
      caml_bytes_set(x$0, caml_call2(Base_Import[93], n, 1), 32);
      caml_bytes_set(x$0, caml_call2(Base_Import[93], n, 2), 32);
      return runtime.caml_string_of_bytes(x$0);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
    }
    if(0. <= t) return go(t);
    var _as_ = go(caml_call1(Base_Import[114], t));
    return caml_call2(Base_Import[112], cst$1, _as_);
   }
   function to_padded_compact_string(t){
    return to_padded_compact_string_custo
            (t, 0, cst_k, cst_m, cst_g, cst_t, _I_, 0);
   }
   function int_pow(x, n){
    if(0 === n) return 1.;
    var
     x$0 = [0, caml_call2(Base_Import[92], x, -0.)],
     n$0 = [0, n],
     accum = [0, 1.];
    if(n$0[1] < 0){
     x$0[1] = caml_call2(Base_Import[96], 1., x$0[1]);
     n$0[1] = caml_call1(Base_Import[113], n$0[1]);
     if(n$0[1] < 0){accum[1] = x$0[1]; n$0[1] += -1;}
    }
    for(;;){
     if(1 >= n$0[1]) return caml_call2(Base_Import[90], x$0[1], accum[1]);
     if(0 !== caml_call2(Base_Import[116], n$0[1], 1))
      accum[1] = caml_call2(Base_Import[90], x$0[1], accum[1]);
     x$0[1] = caml_call2(Base_Import[90], x$0[1], x$0[1]);
     n$0[1] = caml_call2(Base_Import[120], n$0[1], 1);
    }
   }
   function round_gen(x, how){
    if(x == 0.) return 0.;
    if(! is_finite(x)) return x;
    if(555917426 <= how[1])
     var
      sd = how[2],
      _ao_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      dd = caml_call2(Base_Import[93], sd, _ao_),
      dd$0 = dd,
      sd$0 = sd;
    else
     var
      dd$1 = how[2],
      _ar_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      sd$1 = caml_call2(Base_Import[91], dd$1, _ar_),
      dd$0 = dd$1,
      sd$0 = sd$1;
    if(0 > sd$0) return 0.;
    if(17 <= sd$0) return x;
    var abs_dd = caml_call1(Base_Int[78], dd$0);
    if(22 >= abs_dd && 16 > sd$0){
     var order = int_pow(10., abs_dd);
     if(0 <= dd$0){
      var
       _ap_ =
         round_nearest_half_to_even(caml_call2(Base_Import[90], x, order));
      return caml_call2(Base_Import[96], _ap_, order);
     }
     var
      _aq_ = round_nearest_half_to_even(caml_call2(Base_Import[96], x, order));
     return caml_call2(Base_Import[90], _aq_, order);
    }
    return of_string(caml_call3(Base_Printf[2], _J_, sd$0, x));
   }
   function round_significant(x, significant_digits){
    return 0 < significant_digits
            ? round_gen(x, [0, 555917426, significant_digits])
            : caml_call3(Base_Printf[7], _K_, significant_digits, 0);
   }
   function round_decimal(x, decimal_digits){
    return round_gen(x, [0, -352548012, decimal_digits]);
   }
   function between(t, low, high){
    var _am_ = low <= t ? 1 : 0, _an_ = _am_ ? t <= high ? 1 : 0 : _am_;
    return _an_;
   }
   function clamp_exn(t, min, max){
    if(min <= max) return caml_call3(clamp_unchecked, t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
   }
   function clamp(t, min, max){
    if(min <= max) return [0, caml_call3(clamp_unchecked, t, min, max)];
    var
     _aj_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _ak_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _aj_],
     _al_ = caml_call2(Base_Sexp[10], cst_clamp_requires_min_max, _ak_);
    return caml_call1(Base_Or_error[39], _al_);
   }
   var
    symbol$1 = Base_Import[92],
    symbol$2 = Base_Import[94],
    symbol$3 = Base_Import[90],
    symbol$4 = Base_Import[96],
    symbol$5 = Base_Import[114];
   function sign_exn(t){
    if(0. < t) return 2;
    if(t < 0.) return 0;
    if(t == 0.) return 1;
    var
     _ah_ = [0, [0, cst$3, sexp_of_t$1(t)], 0],
     _ai_ = caml_call2(Base_Sexp[10], cst_Float_sign_exn_of_NAN, _ah_);
    return caml_call1(Base_Error[32], _ai_);
   }
   function sign_or_nan(t){return 0. < t ? 2 : t < 0. ? 0 : t == 0. ? 1 : 3;}
   function ieee_negative(t){
    var bits = caml_int64_bits_of_float(t);
    return runtime.caml_lessthan(bits, Stdlib_Int64[1]);
   }
   var
    _M_ = Base_Int64[37],
    exponent_mask64 =
      runtime.caml_int64_sub
       (caml_call2(Base_Int64[53], Base_Int64[37], 11), _M_),
    exponent_mask = caml_call1(Base_Int64[6], exponent_mask64),
    _N_ = Base_Int63[43],
    _O_ = caml_call2(Base_Int63[76], Base_Int63[43], 52),
    mantissa_mask = caml_call2(Base_Int63[46], _O_, _N_),
    mantissa_mask64 = caml_call1(Base_Int63[83], mantissa_mask),
    mantissa_bits = 52;
   function ieee_exponent(t){
    var
     bits = caml_int64_bits_of_float(t),
     _ag_ = caml_call2(Base_Int64[67], bits, mantissa_bits);
    return runtime.caml_int64_to_int32
            (caml_call2(Base_Int64[48], _ag_, exponent_mask64));
   }
   function ieee_mantissa(t){
    var bits = caml_int64_bits_of_float(t);
    return caml_call1
            (Base_Int63[109], runtime.caml_int64_and(bits, mantissa_mask64));
   }
   function create_ieee_exn(negative, exponent, mantissa){
    if(caml_call2(Base_Int[48], exponent, exponent_mask) !== exponent)
     return caml_call4(Base_Printf[6], _P_, exponent, exponent_mask, 0);
    var _ad_ = caml_call2(Base_Int63[71], mantissa, mantissa_mask);
    if(caml_call2(Base_Int63[17], _ad_, mantissa)){
     var
      _ae_ = caml_call1(Base_Int63[11], mantissa_mask),
      _af_ = caml_call1(Base_Int63[11], mantissa);
     return caml_call4(Base_Printf[6], _Q_, _af_, _ae_, 0);
    }
    var
     sign_bits = negative ? Stdlib_Int64[10] : Stdlib_Int64[1],
     expt_bits =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_of_int32(exponent), 52),
     mant_bits = caml_call1(Base_Int63[83], mantissa),
     bits = caml_int64_or(sign_bits, caml_int64_or(expt_bits, mant_bits));
    return runtime.caml_int64_float_of_bits(bits);
   }
   function create_ieee(negative, exponent, mantissa){
    function _ac_(param){
     return create_ieee_exn(negative, exponent, mantissa);
    }
    return caml_call2(Base_Or_error[31], 0, _ac_);
   }
   function to_string$1(x){return caml_call2(Base_Printf[2], _R_, x);}
   function sexp_of_t$2(x){return [0, to_string$1(x)];}
   function of_string$1(x){return of_string(x);}
   var
    include$0 = caml_call1(Base_Comparable[14], [0, compare, sexp_of_t, zero]),
    sign = include$0[5];
   function is_positive(t){return 0. < t ? 1 : 0;}
   function is_non_negative(t){return 0. <= t ? 1 : 0;}
   function is_negative(t){return t < 0. ? 1 : 0;}
   function is_non_positive(t){return t <= 0. ? 1 : 0;}
   var
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$1[1];
   function symbol$6(_ab_, _aa_){return _ab_ != _aa_ ? 1 : 0;}
   function symbol$7(_$_, ___){return _$_ < ___ ? 1 : 0;}
   function symbol$8(_Z_, _Y_){return _Y_ < _Z_ ? 1 : 0;}
   function symbol$9(_X_, _W_){return _X_ == _W_ ? 1 : 0;}
   function symbol$10(_V_, _U_){return _V_ <= _U_ ? 1 : 0;}
   function symbol$11(_T_, _S_){return _S_ <= _T_ ? 1 : 0;}
   function of_float$0(x){return x;}
   var
    specialized_hash = Base_Import[223],
    Private =
      [0,
       box,
       clamp_unchecked,
       lower_bound_for_int,
       upper_bound_for_int,
       specialized_hash,
       one_ulp_less_than_half,
       int63_round_nearest_portable_a,
       int63_round_nearest_arch64_noa,
       iround_nearest_exn_64],
    include$2 = Base_Import[108],
    ascending = include$2[1],
    descending = include$2[2],
    compare_local$0 = include$2[3],
    equal_local = include$2[4];
   function min(x, y){
    if(! (x < y) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   function max(x, y){
    if(! (y < x) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   var
    Base_Float =
      [0,
       globalize,
       t_sexp_grammar,
       of_float,
       to_float,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       float_of_string_opt,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       equal_local,
       compare_local$0,
       invariant,
       min,
       max,
       nan,
       max_value,
       neg_infinity,
       max_value,
       neg_infinity,
       zero,
       one,
       minus_one,
       pi,
       sqrt_pi,
       sqrt_2pi,
       euler,
       epsilon_float,
       max_finite_value,
       min_positive_subnormal_value,
       min_positive_normal_value,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       of_int,
       to_int,
       of_int63,
       of_int64,
       to_int64,
       round,
       iround,
       iround_exn,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       round_nearest_half_to_even,
       iround_towards_zero,
       iround_down,
       iround_up,
       iround_nearest_64$0,
       iround_towards_zero_exn,
       iround_down_exn,
       iround_up_exn,
       iround_nearest_exn,
       int63_round_down_exn,
       int63_round_up_exn,
       int63_round_nearest_exn,
       iround_lbound,
       iround_ubound,
       int63_round_lbound,
       int63_round_ubound,
       round_significant,
       round_decimal,
       is_nan,
       is_inf,
       is_finite,
       is_integer,
       min_inan,
       max_inan,
       symbol$1,
       symbol$2,
       symbol$4,
       symbol$0,
       symbol$3,
       symbol,
       symbol$5,
       [0, fractional, integral],
       modf,
       mod_float,
       add,
       sub,
       neg,
       scale,
       abs_float,
       [0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$0,
        symbol,
        symbol$5,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs_float,
        neg,
        zero,
        of_int,
        of_float$0],
       [0, symbol$1, symbol$2, symbol$3, symbol$4, symbol$0, symbol, symbol$5],
       to_string,
       to_string_hum,
       to_padded_compact_string,
       to_padded_compact_string_custo,
       int_pow,
       square,
       ldexp,
       frexp,
       [0,
        compare$0,
        compare_local,
        all,
        t_of_sexp$0,
        sexp_of_t$0,
        t_sexp_grammar$0,
        of_string$0,
        to_string$0],
       classify,
       sign,
       sign_exn,
       sign_or_nan,
       create_ieee,
       create_ieee_exn,
       ieee_negative,
       ieee_exponent,
       ieee_mantissa,
       [0, t_of_sexp, sexp_of_t$2, t_sexp_grammar, of_string$1, to_string$1],
       Private];
   runtime.caml_register_global(191, Base_Float, "Base__Float");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fieldslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Fieldslib = [0];
   runtime.caml_register_global(0, Base_Fieldslib, "Base__Fieldslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Buffer_intf = [0];
   runtime.caml_register_global(0, Base_Buffer_intf, "Base__Buffer_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer
//# unitInfo: Requires: Base__Blit, Base__Buffer_intf, Base__Bytes, Base__Import, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Bytes = global_data.Base__Bytes,
    Base_Import = global_data.Base__Import,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Base_Blit = global_data.Base__Blit,
    create = Stdlib_Buffer[1],
    contents = Stdlib_Buffer[2],
    to_bytes = Stdlib_Buffer[3],
    nth = Stdlib_Buffer[6],
    length = Stdlib_Buffer[7],
    clear = Stdlib_Buffer[8],
    reset = Stdlib_Buffer[9],
    add_char = Stdlib_Buffer[12],
    add_string = Stdlib_Buffer[16],
    add_bytes = Stdlib_Buffer[17],
    add_buffer = Stdlib_Buffer[21],
    _a_ = Stdlib_Buffer[18],
    _b_ = Stdlib_Buffer[19];
   function add_substring(t, s, pos, len){
    return caml_call4(_a_, t, s, pos, len);
   }
   function add_subbytes(t, s, pos, len){
    return caml_call4(_b_, t, s, pos, len);
   }
   function sexp_of_t(t){
    var _c_ = caml_call1(contents, t);
    return caml_call1(Base_Import[136], _c_);
   }
   var
    caml_buffer_length = Stdlib_Buffer[7],
    caml_buffer_blit = Stdlib_Buffer[5];
   function create$0(len){return caml_call1(Base_Bytes[34], len);}
   var length$0 = runtime.caml_ml_bytes_length;
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    return caml_call5(caml_buffer_blit, src, src_pos, dst, dst_pos, len);
   }
   var
    To_bytes =
      caml_call1
       (caml_call1(Base_Blit[2], [0, caml_buffer_length]),
        [0, length$0, create$0, unsafe_blit]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit$0 = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes),
    Base_Buffer =
      [0,
       sexp_of_t,
       create,
       contents,
       to_bytes,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       To_string,
       nth,
       length,
       clear,
       reset,
       add_char,
       add_string,
       add_substring,
       add_bytes,
       add_subbytes,
       add_buffer];
   runtime.caml_register_global(4, Base_Buffer, "Base__Buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Backtrace
//# unitInfo: Requires: Base__Exn, Base__Int, Base__List, Base__String, Base__Sys0, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    elided_message = "<backtrace elided in test>",
    Base_Exn = global_data.Base__Exn,
    Base_Sys0 = global_data.Base__Sys0,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int = global_data.Base__Int,
    elide = [0, 0],
    cst_b = "b",
    cst_OCAMLRUNPARAM = "OCAMLRUNPARAM";
   function get(opt, param){
    if(opt)
     var sth = opt[1], at_most_num_frames = sth;
    else
     var at_most_num_frames = Base_Int[65];
    return runtime.caml_get_current_callstack(at_most_num_frames);
   }
   function to_string(t){
    return elide[1] ? elided_message : caml_call1(Stdlib_Printexc[14], t);
   }
   function to_string_list(t){
    var _i_ = to_string(t);
    return caml_call1(Base_String[104], _i_);
   }
   function sexp_of_t(t){
    function _g_(x){return [0, x];}
    var _h_ = to_string_list(t);
    return [1, caml_call2(Base_List[53], _h_, _g_)];
   }
   var set_recording = Stdlib_Printexc[7], am_recording = Stdlib_Printexc[8];
   function most_recent(param){return caml_call1(Stdlib_Printexc[12], 0);}
   function most_recent_for_exn(exn){
    return caml_call1(Base_Exn[18], exn) ? [0, most_recent(0)] : 0;
   }
   function with_recording(b, f){
    var saved = caml_call1(am_recording, 0);
    caml_call1(set_recording, b);
    function _f_(param){return caml_call1(set_recording, saved);}
    return caml_call2(Base_Exn[13], f, _f_);
   }
   function initialize_module(param){
    var match = caml_call1(Base_Sys0[21], cst_OCAMLRUNPARAM);
    if(match)
     var
      x = match[1],
      _a_ = Base_String[97],
      _b_ = function(_e_){return caml_call2(_a_, _e_, cst_b);},
      _c_ = caml_call2(Base_String[102], x, 44),
      ocamlrunparam_mentions_backtra = caml_call2(Base_List[23], _c_, _b_);
    else
     var ocamlrunparam_mentions_backtra = 0;
    var _d_ = 1 - ocamlrunparam_mentions_backtra;
    return _d_ ? caml_call1(set_recording, 1) : _d_;
   }
   var
    Base_Backtrace =
      [0,
       sexp_of_t,
       get,
       to_string,
       to_string_list,
       elide,
       [0,
        am_recording,
        set_recording,
        with_recording,
        most_recent,
        most_recent_for_exn],
       initialize_module];
   runtime.caml_register_global(9, Base_Backtrace, "Base__Backtrace");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base
//# unitInfo: Requires: Base__Array, Base__Backtrace, Base__Bool, Base__Bytes, Base__Char, Base__Container_intf, Base__Error, Base__Exn, Base__Float, Base__Import, Base__Int, Base__Int32, Base__Int64, Base__Int_conversions, Base__Int_string_conversions, Base__List, Base__Nativeint, Base__Option, Base__Ref, Base__Sexp_with_comparable, Base__String, Base__T, Base__Unit, Shadow_stdlib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ref = global_data.Base__Ref,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Array = global_data.Base__Array,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Base_Sexp_with_comparable = global_data.Base__Sexp_with_comparable,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Int_string_conversions = global_data.Base__Int_string_conversions,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Exn = global_data.Base__Exn,
    Base_Float = global_data.Base__Float,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes,
    Base_Unit = global_data.Base__Unit,
    Base_Error = global_data.Base__Error,
    Base_Container_intf = global_data.Base__Container_intf,
    Base_Backtrace = global_data.Base__Backtrace,
    Exit = Shadow_stdlib[3],
    Not_found = Shadow_stdlib[4],
    max_int = Shadow_stdlib[8],
    min_int = Shadow_stdlib[9],
    infinity = Shadow_stdlib[11],
    neg_infinity = Shadow_stdlib[12],
    nan = Shadow_stdlib[13],
    max_float = Shadow_stdlib[14],
    min_float = Shadow_stdlib[15],
    epsilon_float = Shadow_stdlib[16],
    char_of_int = Shadow_stdlib[18],
    string_of_bool = Shadow_stdlib[19],
    bool_of_string_opt = Shadow_stdlib[20],
    bool_of_string = Shadow_stdlib[21],
    string_of_int = Shadow_stdlib[22],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_float = Shadow_stdlib[24],
    float_of_string_opt = Shadow_stdlib[25],
    stdin = Shadow_stdlib[27],
    stdout = Shadow_stdlib[28],
    stderr = Shadow_stdlib[29],
    print_char = Shadow_stdlib[30],
    print_string = Shadow_stdlib[31],
    print_bytes = Shadow_stdlib[32],
    print_int = Shadow_stdlib[33],
    print_float = Shadow_stdlib[34],
    print_endline = Shadow_stdlib[35],
    print_newline = Shadow_stdlib[36],
    prerr_char = Shadow_stdlib[37],
    prerr_string = Shadow_stdlib[38],
    prerr_bytes = Shadow_stdlib[39],
    prerr_int = Shadow_stdlib[40],
    prerr_float = Shadow_stdlib[41],
    prerr_endline = Shadow_stdlib[42],
    prerr_newline = Shadow_stdlib[43],
    read_line = Shadow_stdlib[44],
    read_int_opt = Shadow_stdlib[45],
    read_int = Shadow_stdlib[46],
    read_float_opt = Shadow_stdlib[47],
    read_float = Shadow_stdlib[48],
    open_out = Shadow_stdlib[49],
    open_out_bin = Shadow_stdlib[50],
    open_out_gen = Shadow_stdlib[51],
    flush = Shadow_stdlib[52],
    flush_all = Shadow_stdlib[53],
    output_char = Shadow_stdlib[54],
    output_string = Shadow_stdlib[55],
    output_bytes = Shadow_stdlib[56],
    output = Shadow_stdlib[57],
    output_substring = Shadow_stdlib[58],
    output_byte = Shadow_stdlib[59],
    output_binary_int = Shadow_stdlib[60],
    output_value = Shadow_stdlib[61],
    seek_out = Shadow_stdlib[62],
    pos_out = Shadow_stdlib[63],
    out_channel_length = Shadow_stdlib[64],
    close_out = Shadow_stdlib[65],
    close_out_noerr = Shadow_stdlib[66],
    set_binary_mode_out = Shadow_stdlib[67],
    open_in = Shadow_stdlib[68],
    open_in_bin = Shadow_stdlib[69],
    open_in_gen = Shadow_stdlib[70],
    input_char = Shadow_stdlib[71],
    input_line = Shadow_stdlib[72],
    input = Shadow_stdlib[73],
    really_input = Shadow_stdlib[74],
    really_input_string = Shadow_stdlib[75],
    input_byte = Shadow_stdlib[76],
    input_binary_int = Shadow_stdlib[77],
    input_value = Shadow_stdlib[78],
    seek_in = Shadow_stdlib[79],
    pos_in = Shadow_stdlib[80],
    in_channel_length = Shadow_stdlib[81],
    close_in = Shadow_stdlib[82],
    close_in_noerr = Shadow_stdlib[83],
    set_binary_mode_in = Shadow_stdlib[84],
    string_of_format = Shadow_stdlib[85],
    symbol = Shadow_stdlib[86],
    exit = Shadow_stdlib[87],
    at_exit = Shadow_stdlib[88],
    valid_float_lexem = Shadow_stdlib[89],
    unsafe_really_input = Shadow_stdlib[90],
    do_at_exit = Shadow_stdlib[91],
    do_domain_local_at_exit = Shadow_stdlib[92],
    globalize = Base_Sexp_with_comparable[1],
    hash_fold_t = Base_Sexp_with_comparable[2],
    hash = Base_Sexp_with_comparable[3],
    t_of_sexp = Base_Sexp_with_comparable[4],
    sexp_of_t = Base_Sexp_with_comparable[5],
    Not_found_s = Base_Sexp_with_comparable[6],
    Of_sexp_error = Base_Sexp_with_comparable[7],
    message = Base_Sexp_with_comparable[8],
    default_indent = Base_Sexp_with_comparable[9],
    pp_hum = Base_Sexp_with_comparable[10],
    pp_hum_indent = Base_Sexp_with_comparable[11],
    pp_mach = Base_Sexp_with_comparable[12],
    pp = Base_Sexp_with_comparable[13],
    to_string_hum = Base_Sexp_with_comparable[14],
    to_string_mach = Base_Sexp_with_comparable[15],
    to_string = Base_Sexp_with_comparable[16],
    of_float_style = Base_Sexp_with_comparable[17],
    of_int_style = Base_Sexp_with_comparable[18],
    t_sexp_grammar = Base_Sexp_with_comparable[19],
    invariant = Base_Sexp_with_comparable[20],
    of_string = Base_Sexp_with_comparable[21],
    symbol$0 = Base_Sexp_with_comparable[22],
    symbol$1 = Base_Sexp_with_comparable[23],
    symbol$2 = Base_Sexp_with_comparable[24],
    symbol$3 = Base_Sexp_with_comparable[25],
    symbol$4 = Base_Sexp_with_comparable[26],
    symbol$5 = Base_Sexp_with_comparable[27],
    equal = Base_Sexp_with_comparable[28],
    compare = Base_Sexp_with_comparable[29],
    min = Base_Sexp_with_comparable[30],
    max = Base_Sexp_with_comparable[31],
    ascending = Base_Sexp_with_comparable[32],
    descending = Base_Sexp_with_comparable[33],
    between = Base_Sexp_with_comparable[34],
    clamp_exn = Base_Sexp_with_comparable[35],
    clamp = Base_Sexp_with_comparable[36],
    comparator = Base_Sexp_with_comparable[37],
    compare_local = Base_Sexp_with_comparable[38],
    equal_local = Base_Sexp_with_comparable[39],
    Sexp =
      [0,
       globalize,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       compare_local,
       equal_local],
    int_to_int32 = Base_Int_conversions[1],
    int_to_int32_exn = Base_Int_conversions[2],
    int_to_int32_trunc = Base_Int_conversions[3],
    int_to_int64 = Base_Int_conversions[4],
    int_to_nativeint = Base_Int_conversions[5],
    int32_to_int = Base_Int_conversions[6],
    int32_to_int_exn = Base_Int_conversions[7],
    int32_to_int_trunc = Base_Int_conversions[8],
    int32_to_int64 = Base_Int_conversions[9],
    int32_to_nativeint = Base_Int_conversions[10],
    int32_is_representable_as_int = Base_Int_conversions[11],
    int64_to_int = Base_Int_conversions[12],
    int64_to_int_exn = Base_Int_conversions[13],
    int64_to_int_trunc = Base_Int_conversions[14],
    int64_to_int32 = Base_Int_conversions[15],
    int64_to_int32_exn = Base_Int_conversions[16],
    int64_to_int32_trunc = Base_Int_conversions[17],
    int64_to_nativeint = Base_Int_conversions[18],
    int64_to_nativeint_exn = Base_Int_conversions[19],
    int64_to_nativeint_trunc = Base_Int_conversions[20],
    int64_fit_on_int63_exn = Base_Int_conversions[21],
    int64_is_representable_as_int6 = Base_Int_conversions[22],
    nativeint_to_int = Base_Int_conversions[23],
    nativeint_to_int_exn = Base_Int_conversions[24],
    nativeint_to_int_trunc = Base_Int_conversions[25],
    nativeint_to_int32 = Base_Int_conversions[26],
    nativeint_to_int32_exn = Base_Int_conversions[27],
    nativeint_to_int32_trunc = Base_Int_conversions[28],
    nativeint_to_int64 = Base_Int_conversions[29],
    num_bits_int = Base_Int_conversions[30],
    num_bits_int32 = Base_Int_conversions[31],
    num_bits_int64 = Base_Int_conversions[32],
    num_bits_nativeint = Base_Int_conversions[33],
    Make = Base_Int_string_conversions[1],
    Make_hex = Base_Int_string_conversions[2],
    Make_binary = Base_Int_string_conversions[3],
    sexp_of_int_style = Base_Int_string_conversions[4],
    insert_delimiter_every = Base_Int_string_conversions[5],
    insert_delimiter = Base_Int_string_conversions[6],
    insert_underscores = Base_Int_string_conversions[7],
    Int_conversions =
      [0,
       int_to_int32,
       int_to_int32_exn,
       int_to_int32_trunc,
       int_to_int64,
       int_to_nativeint,
       int32_to_int,
       int32_to_int_exn,
       int32_to_int_trunc,
       int32_to_int64,
       int32_to_nativeint,
       int32_is_representable_as_int,
       int64_to_int,
       int64_to_int_exn,
       int64_to_int_trunc,
       int64_to_int32,
       int64_to_int32_exn,
       int64_to_int32_trunc,
       int64_to_nativeint,
       int64_to_nativeint_exn,
       int64_to_nativeint_trunc,
       int64_fit_on_int63_exn,
       int64_is_representable_as_int6,
       nativeint_to_int,
       nativeint_to_int_exn,
       nativeint_to_int_trunc,
       nativeint_to_int32,
       nativeint_to_int32_exn,
       nativeint_to_int32_trunc,
       nativeint_to_int64,
       num_bits_int,
       num_bits_int32,
       num_bits_int64,
       num_bits_nativeint,
       Make,
       Make_hex,
       Make_binary,
       sexp_of_int_style,
       insert_delimiter_every,
       insert_delimiter,
       insert_underscores],
    am_testing = Base_Import[129],
    Exported_for_specific_uses = [0, am_testing],
    compare_array_local = Base_Array[2],
    compare_array = Base_Array[1],
    equal_array_local = Base_Array[106],
    equal_array = Base_Array[105],
    globalize_array = Base_Array[3],
    array_of_sexp = Base_Array[4],
    sexp_of_array = Base_Array[5];
   function array_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Array[6], a_sexp_grammar);
   }
   var compare_bool_local = Base_Bool[28];
   function compare_bool(a, b){return caml_call2(compare_bool_local, a, b);}
   var equal_bool_local = Base_Bool[29];
   function equal_bool(a, b){return caml_call2(equal_bool_local, a, b);}
   var
    globalize_bool = Base_Bool[2],
    hash_fold_bool = Base_Bool[4],
    func = Base_Bool[5];
   function hash_bool(x){return caml_call1(func, x);}
   var
    bool_of_sexp = Base_Bool[6],
    sexp_of_bool = Base_Bool[7],
    bool_sexp_grammar = Base_Bool[3],
    compare_char_local = Base_Char[29];
   function compare_char(a, b){return caml_call2(compare_char_local, a, b);}
   var equal_char_local = Base_Char[28];
   function equal_char(a, b){return caml_call2(equal_char_local, a, b);}
   var
    globalize_char = Base_Char[2],
    hash_fold_char = Base_Char[4],
    func$0 = Base_Char[5];
   function hash_char(x){return caml_call1(func$0, x);}
   var
    char_of_sexp = Base_Char[6],
    sexp_of_char = Base_Char[7],
    char_sexp_grammar = Base_Char[3],
    sexp_of_exn = Base_Exn[1],
    compare_float_local = Base_Float[24];
   function compare_float(a, b){return caml_call2(compare_float_local, a, b);}
   var equal_float_local = Base_Float[23];
   function equal_float(a, b){return caml_call2(equal_float_local, a, b);}
   var
    globalize_float = Base_Float[1],
    hash_fold_float = Base_Float[5],
    func$1 = Base_Float[6];
   function hash_float(x){return caml_call1(func$1, x);}
   var
    float_of_sexp = Base_Float[7],
    sexp_of_float = Base_Float[8],
    float_sexp_grammar = Base_Float[2],
    compare_int_local = Base_Int[30];
   function compare_int(a, b){return caml_call2(compare_int_local, a, b);}
   var equal_int_local = Base_Int[31];
   function equal_int(a, b){return caml_call2(equal_int_local, a, b);}
   var
    globalize_int = Base_Int[1],
    hash_fold_int = Base_Int[7],
    func$2 = Base_Int[8];
   function hash_int(x){return caml_call1(func$2, x);}
   var
    int_of_sexp = Base_Int[9],
    sexp_of_int = Base_Int[10],
    int_sexp_grammar = Base_Int[2],
    compare_int32_local = Base_Int32[36];
   function compare_int32(a, b){return caml_call2(compare_int32_local, a, b);}
   var equal_int32_local = Base_Int32[37];
   function equal_int32(a, b){return caml_call2(equal_int32_local, a, b);}
   var
    globalize_int32 = Base_Int32[1],
    hash_fold_int32 = Base_Int32[7],
    func$3 = Base_Int32[8];
   function hash_int32(x){return caml_call1(func$3, x);}
   var
    int32_of_sexp = Base_Int32[9],
    sexp_of_int32 = Base_Int32[10],
    int32_sexp_grammar = Base_Int32[2],
    compare_int64_local = Base_Int64[30];
   function compare_int64(a, b){return caml_call2(compare_int64_local, a, b);}
   var equal_int64_local = Base_Int64[31];
   function equal_int64(a, b){return caml_call2(equal_int64_local, a, b);}
   var
    globalize_int64 = Base_Int64[1],
    hash_fold_int64 = Base_Int64[7],
    func$4 = Base_Int64[8];
   function hash_int64(x){return caml_call1(func$4, x);}
   var
    int64_of_sexp = Base_Int64[9],
    sexp_of_int64 = Base_Int64[10],
    int64_sexp_grammar = Base_Int64[2],
    compare_list_local = Base_List[2],
    compare_list = Base_List[1],
    equal_list_local = Base_List[155],
    equal_list = Base_List[154],
    globalize_list = Base_List[3],
    hash_fold_list = Base_List[4],
    list_of_sexp = Base_List[5],
    sexp_of_list = Base_List[6];
   function list_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_List[7], a_sexp_grammar);
   }
   var compare_nativeint_local = Base_Nativeint[36];
   function compare_nativeint(a, b){
    return caml_call2(compare_nativeint_local, a, b);
   }
   var equal_nativeint_local = Base_Nativeint[37];
   function equal_nativeint(a, b){
    return caml_call2(equal_nativeint_local, a, b);
   }
   var
    globalize_nativeint = Base_Nativeint[1],
    hash_fold_nativeint = Base_Nativeint[7],
    func$5 = Base_Nativeint[8];
   function hash_nativeint(x){return caml_call1(func$5, x);}
   var
    nativeint_of_sexp = Base_Nativeint[9],
    sexp_of_nativeint = Base_Nativeint[10],
    nativeint_sexp_grammar = Base_Nativeint[2],
    compare_option_local = Base_Option[2],
    compare_option = Base_Option[1],
    equal_option_local = Base_Option[7],
    equal_option = Base_Option[6],
    globalize_option = Base_Option[3],
    hash_fold_option = Base_Option[4],
    option_of_sexp = Base_Option[9],
    sexp_of_option = Base_Option[10];
   function option_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Option[5], a_sexp_grammar);
   }
   var
    compare_ref_local = Base_Ref[2],
    compare_ref = Base_Ref[1],
    equal_ref_local = Base_Ref[4],
    equal_ref = Base_Ref[3],
    globalize_ref = Base_Ref[5],
    ref_of_sexp = Base_Ref[6],
    sexp_of_ref = Base_Ref[7];
   function ref_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Ref[8], a_sexp_grammar);
   }
   var compare_string_local = Base_String[62];
   function compare_string(a, b){
    return caml_call2(compare_string_local, a, b);
   }
   var equal_string_local = Base_String[135];
   function equal_string(a, b){return caml_call2(equal_string_local, a, b);}
   var globalize_string = Base_String[1], hash_fold_string = Base_String[40];
   function hash_string(x){return runtime.Base_hash_string(x);}
   var
    string_of_sexp = Base_String[41],
    sexp_of_string = Base_String[42],
    string_sexp_grammar = Base_String[2],
    compare_bytes_local = Base_Bytes[26];
   function compare_bytes(a, b){return caml_call2(compare_bytes_local, a, b);}
   var equal_bytes_local = Base_Bytes[27];
   function equal_bytes(a, b){return caml_call2(equal_bytes_local, a, b);}
   var
    globalize_bytes = Base_Bytes[1],
    bytes_of_sexp = Base_Bytes[2],
    sexp_of_bytes = Base_Bytes[3],
    bytes_sexp_grammar = Base_Bytes[4],
    compare_unit_local = Base_Unit[29];
   function compare_unit(a, b){return caml_call2(compare_unit_local, a, b);}
   var equal_unit_local = Base_Unit[28];
   function equal_unit(a, b){return caml_call2(equal_unit_local, a, b);}
   var
    globalize_unit = Base_Unit[2],
    hash_fold_unit = Base_Unit[4],
    func$6 = Base_Unit[5];
   function hash_unit(x){return caml_call1(func$6, x);}
   var
    unit_of_sexp = Base_Unit[6],
    sexp_of_unit = Base_Unit[7],
    unit_sexp_grammar = Base_Unit[3],
    symbol$6 = Base_List[156][1],
    _a_ = Base_Int[75],
    symbol$7 = _a_[1],
    lnot = _a_[2],
    abs = _a_[3],
    zero = _a_[4],
    symbol$8 = _a_[5],
    symbol$9 = _a_[6],
    symbol$10 = _a_[7],
    _b_ = Base_Import[97],
    ascending$0 = _b_[1],
    descending$0 = _b_[2],
    max$0 = _b_[3],
    min$0 = _b_[4],
    include = Base_Float[100],
    symbol$11 = include[1],
    symbol$12 = include[2],
    symbol$13 = include[3],
    symbol$14 = include[4],
    symbol$15 = include[5],
    symbol$16 = include[6],
    symbol$17 = include[7],
    symbol$18 = Base_String[67],
    fst = Base_Import[125],
    snd = Base_Import[127],
    failwith = Base_Import[124],
    invalid_arg = Base_Import[126],
    raise_s = Base_Error[32],
    Export =
      [0,
       compare_array_local,
       compare_array,
       equal_array_local,
       equal_array,
       globalize_array,
       array_of_sexp,
       sexp_of_array,
       array_sexp_grammar,
       compare_bool_local,
       compare_bool,
       equal_bool_local,
       equal_bool,
       globalize_bool,
       hash_fold_bool,
       hash_bool,
       bool_of_sexp,
       sexp_of_bool,
       bool_sexp_grammar,
       compare_char_local,
       compare_char,
       equal_char_local,
       equal_char,
       globalize_char,
       hash_fold_char,
       hash_char,
       char_of_sexp,
       sexp_of_char,
       char_sexp_grammar,
       sexp_of_exn,
       compare_float_local,
       compare_float,
       equal_float_local,
       equal_float,
       globalize_float,
       hash_fold_float,
       hash_float,
       float_of_sexp,
       sexp_of_float,
       float_sexp_grammar,
       compare_int_local,
       compare_int,
       equal_int_local,
       equal_int,
       globalize_int,
       hash_fold_int,
       hash_int,
       int_of_sexp,
       sexp_of_int,
       int_sexp_grammar,
       compare_int32_local,
       compare_int32,
       equal_int32_local,
       equal_int32,
       globalize_int32,
       hash_fold_int32,
       hash_int32,
       int32_of_sexp,
       sexp_of_int32,
       int32_sexp_grammar,
       compare_int64_local,
       compare_int64,
       equal_int64_local,
       equal_int64,
       globalize_int64,
       hash_fold_int64,
       hash_int64,
       int64_of_sexp,
       sexp_of_int64,
       int64_sexp_grammar,
       compare_list_local,
       compare_list,
       equal_list_local,
       equal_list,
       globalize_list,
       hash_fold_list,
       list_of_sexp,
       sexp_of_list,
       list_sexp_grammar,
       compare_nativeint_local,
       compare_nativeint,
       equal_nativeint_local,
       equal_nativeint,
       globalize_nativeint,
       hash_fold_nativeint,
       hash_nativeint,
       nativeint_of_sexp,
       sexp_of_nativeint,
       nativeint_sexp_grammar,
       compare_option_local,
       compare_option,
       equal_option_local,
       equal_option,
       globalize_option,
       hash_fold_option,
       option_of_sexp,
       sexp_of_option,
       option_sexp_grammar,
       compare_ref_local,
       compare_ref,
       equal_ref_local,
       equal_ref,
       globalize_ref,
       ref_of_sexp,
       sexp_of_ref,
       ref_sexp_grammar,
       compare_string_local,
       compare_string,
       equal_string_local,
       equal_string,
       globalize_string,
       hash_fold_string,
       hash_string,
       string_of_sexp,
       sexp_of_string,
       string_sexp_grammar,
       compare_bytes_local,
       compare_bytes,
       equal_bytes_local,
       equal_bytes,
       globalize_bytes,
       bytes_of_sexp,
       sexp_of_bytes,
       bytes_sexp_grammar,
       compare_unit_local,
       compare_unit,
       equal_unit_local,
       equal_unit,
       globalize_unit,
       hash_fold_unit,
       hash_unit,
       unit_of_sexp,
       sexp_of_unit,
       unit_sexp_grammar,
       symbol$6,
       symbol$7,
       lnot,
       abs,
       zero,
       symbol$8,
       symbol$9,
       symbol$10,
       ascending$0,
       descending$0,
       max$0,
       min$0,
       symbol$11,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       fst,
       snd,
       failwith,
       invalid_arg,
       raise_s],
    compare_array_local$0 = Export[1],
    compare_array$0 = Export[2],
    equal_array_local$0 = Export[3],
    equal_array$0 = Export[4],
    globalize_array$0 = Export[5],
    array_of_sexp$0 = Export[6],
    sexp_of_array$0 = Export[7],
    array_sexp_grammar$0 = Export[8],
    compare_bool_local$0 = Export[9],
    compare_bool$0 = Export[10],
    equal_bool_local$0 = Export[11],
    equal_bool$0 = Export[12],
    globalize_bool$0 = Export[13],
    hash_fold_bool$0 = Export[14],
    hash_bool$0 = Export[15],
    bool_of_sexp$0 = Export[16],
    sexp_of_bool$0 = Export[17],
    bool_sexp_grammar$0 = Export[18],
    compare_char_local$0 = Export[19],
    compare_char$0 = Export[20],
    equal_char_local$0 = Export[21],
    equal_char$0 = Export[22],
    globalize_char$0 = Export[23],
    hash_fold_char$0 = Export[24],
    hash_char$0 = Export[25],
    char_of_sexp$0 = Export[26],
    sexp_of_char$0 = Export[27],
    char_sexp_grammar$0 = Export[28],
    sexp_of_exn$0 = Export[29],
    compare_float_local$0 = Export[30],
    compare_float$0 = Export[31],
    equal_float_local$0 = Export[32],
    equal_float$0 = Export[33],
    globalize_float$0 = Export[34],
    hash_fold_float$0 = Export[35],
    hash_float$0 = Export[36],
    float_of_sexp$0 = Export[37],
    sexp_of_float$0 = Export[38],
    float_sexp_grammar$0 = Export[39],
    compare_int_local$0 = Export[40],
    compare_int$0 = Export[41],
    equal_int_local$0 = Export[42],
    equal_int$0 = Export[43],
    globalize_int$0 = Export[44],
    hash_fold_int$0 = Export[45],
    hash_int$0 = Export[46],
    int_of_sexp$0 = Export[47],
    sexp_of_int$0 = Export[48],
    int_sexp_grammar$0 = Export[49],
    compare_int32_local$0 = Export[50],
    compare_int32$0 = Export[51],
    equal_int32_local$0 = Export[52],
    equal_int32$0 = Export[53],
    globalize_int32$0 = Export[54],
    hash_fold_int32$0 = Export[55],
    hash_int32$0 = Export[56],
    int32_of_sexp$0 = Export[57],
    sexp_of_int32$0 = Export[58],
    int32_sexp_grammar$0 = Export[59],
    compare_int64_local$0 = Export[60],
    compare_int64$0 = Export[61],
    equal_int64_local$0 = Export[62],
    equal_int64$0 = Export[63],
    globalize_int64$0 = Export[64],
    hash_fold_int64$0 = Export[65],
    hash_int64$0 = Export[66],
    int64_of_sexp$0 = Export[67],
    sexp_of_int64$0 = Export[68],
    int64_sexp_grammar$0 = Export[69],
    compare_list_local$0 = Export[70],
    compare_list$0 = Export[71],
    equal_list_local$0 = Export[72],
    equal_list$0 = Export[73],
    globalize_list$0 = Export[74],
    hash_fold_list$0 = Export[75],
    list_of_sexp$0 = Export[76],
    sexp_of_list$0 = Export[77],
    list_sexp_grammar$0 = Export[78],
    compare_nativeint_local$0 = Export[79],
    compare_nativeint$0 = Export[80],
    equal_nativeint_local$0 = Export[81],
    equal_nativeint$0 = Export[82],
    globalize_nativeint$0 = Export[83],
    hash_fold_nativeint$0 = Export[84],
    hash_nativeint$0 = Export[85],
    nativeint_of_sexp$0 = Export[86],
    sexp_of_nativeint$0 = Export[87],
    nativeint_sexp_grammar$0 = Export[88],
    compare_option_local$0 = Export[89],
    compare_option$0 = Export[90],
    equal_option_local$0 = Export[91],
    equal_option$0 = Export[92],
    globalize_option$0 = Export[93],
    hash_fold_option$0 = Export[94],
    option_of_sexp$0 = Export[95],
    sexp_of_option$0 = Export[96],
    option_sexp_grammar$0 = Export[97],
    compare_ref_local$0 = Export[98],
    compare_ref$0 = Export[99],
    equal_ref_local$0 = Export[100],
    equal_ref$0 = Export[101],
    globalize_ref$0 = Export[102],
    ref_of_sexp$0 = Export[103],
    sexp_of_ref$0 = Export[104],
    ref_sexp_grammar$0 = Export[105],
    compare_string_local$0 = Export[106],
    compare_string$0 = Export[107],
    equal_string_local$0 = Export[108],
    equal_string$0 = Export[109],
    globalize_string$0 = Export[110],
    hash_fold_string$0 = Export[111],
    hash_string$0 = Export[112],
    string_of_sexp$0 = Export[113],
    sexp_of_string$0 = Export[114],
    string_sexp_grammar$0 = Export[115],
    compare_bytes_local$0 = Export[116],
    compare_bytes$0 = Export[117],
    equal_bytes_local$0 = Export[118],
    equal_bytes$0 = Export[119],
    globalize_bytes$0 = Export[120],
    bytes_of_sexp$0 = Export[121],
    sexp_of_bytes$0 = Export[122],
    bytes_sexp_grammar$0 = Export[123],
    compare_unit_local$0 = Export[124],
    compare_unit$0 = Export[125],
    equal_unit_local$0 = Export[126],
    equal_unit$0 = Export[127],
    globalize_unit$0 = Export[128],
    hash_fold_unit$0 = Export[129],
    hash_unit$0 = Export[130],
    unit_of_sexp$0 = Export[131],
    sexp_of_unit$0 = Export[132],
    unit_sexp_grammar$0 = Export[133],
    symbol$19 = Export[134],
    symbol$20 = Export[135],
    lnot$0 = Export[136],
    abs$0 = Export[137],
    zero$0 = Export[138],
    symbol$21 = Export[139],
    symbol$22 = Export[140],
    symbol$23 = Export[141],
    ascending$1 = Export[142],
    descending$1 = Export[143],
    max$1 = Export[144],
    min$1 = Export[145],
    symbol$24 = Export[146],
    symbol$25 = Export[147],
    symbol$26 = Export[148],
    symbol$27 = Export[149],
    symbol$28 = Export[150],
    symbol$29 = Export[151],
    symbol$30 = Export[152],
    symbol$31 = Export[153],
    fst$0 = Export[154],
    snd$0 = Export[155],
    failwith$0 = Export[156],
    invalid_arg$0 = Export[157],
    raise_s$0 = Export[158],
    include$0 = Base_Container_intf[1],
    Continue_or_stop = include$0[1],
    Not_found_s$0 = Base_Import[297];
   caml_call1(Base_Backtrace[7], 0);
   var
    Caml = [0],
    Base =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       do_domain_local_at_exit,
       Sexp,
       Int_conversions,
       Exported_for_specific_uses,
       Export,
       compare_array_local$0,
       compare_array$0,
       equal_array_local$0,
       equal_array$0,
       globalize_array$0,
       array_of_sexp$0,
       sexp_of_array$0,
       array_sexp_grammar$0,
       compare_bool_local$0,
       compare_bool$0,
       equal_bool_local$0,
       equal_bool$0,
       globalize_bool$0,
       hash_fold_bool$0,
       hash_bool$0,
       bool_of_sexp$0,
       sexp_of_bool$0,
       bool_sexp_grammar$0,
       compare_char_local$0,
       compare_char$0,
       equal_char_local$0,
       equal_char$0,
       globalize_char$0,
       hash_fold_char$0,
       hash_char$0,
       char_of_sexp$0,
       sexp_of_char$0,
       char_sexp_grammar$0,
       sexp_of_exn$0,
       compare_float_local$0,
       compare_float$0,
       equal_float_local$0,
       equal_float$0,
       globalize_float$0,
       hash_fold_float$0,
       hash_float$0,
       float_of_sexp$0,
       sexp_of_float$0,
       float_sexp_grammar$0,
       compare_int_local$0,
       compare_int$0,
       equal_int_local$0,
       equal_int$0,
       globalize_int$0,
       hash_fold_int$0,
       hash_int$0,
       int_of_sexp$0,
       sexp_of_int$0,
       int_sexp_grammar$0,
       compare_int32_local$0,
       compare_int32$0,
       equal_int32_local$0,
       equal_int32$0,
       globalize_int32$0,
       hash_fold_int32$0,
       hash_int32$0,
       int32_of_sexp$0,
       sexp_of_int32$0,
       int32_sexp_grammar$0,
       compare_int64_local$0,
       compare_int64$0,
       equal_int64_local$0,
       equal_int64$0,
       globalize_int64$0,
       hash_fold_int64$0,
       hash_int64$0,
       int64_of_sexp$0,
       sexp_of_int64$0,
       int64_sexp_grammar$0,
       compare_list_local$0,
       compare_list$0,
       equal_list_local$0,
       equal_list$0,
       globalize_list$0,
       hash_fold_list$0,
       list_of_sexp$0,
       sexp_of_list$0,
       list_sexp_grammar$0,
       compare_nativeint_local$0,
       compare_nativeint$0,
       equal_nativeint_local$0,
       equal_nativeint$0,
       globalize_nativeint$0,
       hash_fold_nativeint$0,
       hash_nativeint$0,
       nativeint_of_sexp$0,
       sexp_of_nativeint$0,
       nativeint_sexp_grammar$0,
       compare_option_local$0,
       compare_option$0,
       equal_option_local$0,
       equal_option$0,
       globalize_option$0,
       hash_fold_option$0,
       option_of_sexp$0,
       sexp_of_option$0,
       option_sexp_grammar$0,
       compare_ref_local$0,
       compare_ref$0,
       equal_ref_local$0,
       equal_ref$0,
       globalize_ref$0,
       ref_of_sexp$0,
       sexp_of_ref$0,
       ref_sexp_grammar$0,
       compare_string_local$0,
       compare_string$0,
       equal_string_local$0,
       equal_string$0,
       globalize_string$0,
       hash_fold_string$0,
       hash_string$0,
       string_of_sexp$0,
       sexp_of_string$0,
       string_sexp_grammar$0,
       compare_bytes_local$0,
       compare_bytes$0,
       equal_bytes_local$0,
       equal_bytes$0,
       globalize_bytes$0,
       bytes_of_sexp$0,
       sexp_of_bytes$0,
       bytes_sexp_grammar$0,
       compare_unit_local$0,
       compare_unit$0,
       equal_unit_local$0,
       equal_unit$0,
       globalize_unit$0,
       hash_fold_unit$0,
       hash_unit$0,
       unit_of_sexp$0,
       sexp_of_unit$0,
       unit_sexp_grammar$0,
       symbol$19,
       symbol$20,
       lnot$0,
       abs$0,
       zero$0,
       symbol$21,
       symbol$22,
       symbol$23,
       ascending$1,
       descending$1,
       max$1,
       min$1,
       symbol$24,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       symbol$30,
       symbol$31,
       fst$0,
       snd$0,
       failwith$0,
       invalid_arg$0,
       raise_s$0,
       Continue_or_stop,
       Not_found_s$0,
       Caml];
   runtime.caml_register_global(23, Base, "Base");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJnbG9iYWxpemVfYm9vbCIsImIiLCJnbG9iYWxpemVfY2hhciIsImMiLCJnbG9iYWxpemVfdW5pdCIsInUiLCJnbG9iYWxpemVfYXJyYXkiLCJhIiwiZ2xvYmFsaXplX2xpc3QiLCJmIiwieHMiLCJ4IiwiZ2xvYmFsaXplX29wdGlvbiIsImdsb2JhbGl6ZV9yZXN1bHQiLCJnbG9iYWxpemVfYSIsImdsb2JhbGl6ZV9iIiwidCIsImdsb2JhbGl6ZV9yZWYiLCJyIiwiZ2xvYmFsaXplX2xhenlfdCIsImRlc2NlbmRpbmciLCJ5IiwibWF4IiwibWluIiwibWF4X2ludCIsIm1pbl9pbnQiLCJpbmZpbml0eSIsIm5lZ19pbmZpbml0eSIsIm5hbiIsIm1heF9mbG9hdCIsIm1pbl9mbG9hdCIsImVwc2lsb25fZmxvYXQiLCJjaGFyX29mX2ludCIsInN0cmluZ19vZl9ib29sIiwiYm9vbF9vZl9zdHJpbmdfb3B0IiwiYm9vbF9vZl9zdHJpbmciLCJzdHJpbmdfb2ZfaW50IiwiaW50X29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfZmxvYXQiLCJmbG9hdF9vZl9zdHJpbmdfb3B0Iiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJwcmludF9jaGFyIiwicHJpbnRfc3RyaW5nIiwicHJpbnRfYnl0ZXMiLCJwcmludF9pbnQiLCJwcmludF9mbG9hdCIsInByaW50X2VuZGxpbmUiLCJwcmludF9uZXdsaW5lIiwicHJlcnJfY2hhciIsInByZXJyX3N0cmluZyIsInByZXJyX2J5dGVzIiwicHJlcnJfaW50IiwicHJlcnJfZmxvYXQiLCJwcmVycl9lbmRsaW5lIiwicHJlcnJfbmV3bGluZSIsInJlYWRfbGluZSIsInJlYWRfaW50X29wdCIsInJlYWRfaW50IiwicmVhZF9mbG9hdF9vcHQiLCJyZWFkX2Zsb2F0Iiwib3Blbl9vdXQiLCJvcGVuX291dF9iaW4iLCJvcGVuX291dF9nZW4iLCJmbHVzaCIsImZsdXNoX2FsbCIsIm91dHB1dF9jaGFyIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dF9ieXRlcyIsIm91dHB1dCIsIm91dHB1dF9zdWJzdHJpbmciLCJvdXRwdXRfYnl0ZSIsIm91dHB1dF9iaW5hcnlfaW50Iiwib3V0cHV0X3ZhbHVlIiwic2Vla19vdXQiLCJwb3Nfb3V0Iiwib3V0X2NoYW5uZWxfbGVuZ3RoIiwiY2xvc2Vfb3V0IiwiY2xvc2Vfb3V0X25vZXJyIiwic2V0X2JpbmFyeV9tb2RlX291dCIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsIm9wZW5faW5fZ2VuIiwiaW5wdXRfY2hhciIsImlucHV0X2xpbmUiLCJpbnB1dCIsInJlYWxseV9pbnB1dCIsInJlYWxseV9pbnB1dF9zdHJpbmciLCJpbnB1dF9ieXRlIiwiaW5wdXRfYmluYXJ5X2ludCIsImlucHV0X3ZhbHVlIiwic2Vla19pbiIsInBvc19pbiIsImluX2NoYW5uZWxfbGVuZ3RoIiwiY2xvc2VfaW4iLCJjbG9zZV9pbl9ub2VyciIsInNldF9iaW5hcnlfbW9kZV9pbiIsInN0cmluZ19vZl9mb3JtYXQiLCJzeW1ib2wiLCJleGl0IiwiYXRfZXhpdCIsInZhbGlkX2Zsb2F0X2xleGVtIiwidW5zYWZlX3JlYWxseV9pbnB1dCIsImRvX2F0X2V4aXQiLCJkb19kb21haW5fbG9jYWxfYXRfZXhpdCIsImJvb2xfdG9faW50Iiwic3ltYm9sJDMiLCJzeW1ib2wkNCIsInN5bWJvbCQ1Iiwic3ltYm9sJDYiLCJzeW1ib2wkNyIsInN5bWJvbCQ4Iiwic3ltYm9sJDkiLCJzeW1ib2wkMTAiLCJzeW1ib2wkMTEiLCJzeW1ib2wkMTIiLCJhc2NlbmRpbmciLCJtYXgkMCIsIm1pbiQwIiwiYXNjZW5kaW5nJDAiLCJkZXNjZW5kaW5nJDAiLCJtYXgkMSIsIm1pbiQxIiwic3ltYm9sJDEzIiwic3ltYm9sJDE0Iiwic3ltYm9sJDE1Iiwic3ltYm9sJDE2Iiwic3ltYm9sJDE3Iiwic3ltYm9sJDE4IiwiYXNjZW5kaW5nJDEiLCJkZXNjZW5kaW5nJDEiLCJjb21wYXJlIiwiY29tcGFyZV9sb2NhbCIsImVxdWFsIiwiZXF1YWxfbG9jYWwiLCJtYXgkMiIsIm1pbiQyIiwiYXNjZW5kaW5nJDIiLCJkZXNjZW5kaW5nJDIiLCJtYXgkMyIsIm1pbiQzIiwic3ltYm9sJDE5Iiwic3ltYm9sJDIwIiwic3ltYm9sJDIxIiwic3ltYm9sJDIyIiwic3ltYm9sJDIzIiwic3ltYm9sJDI0IiwiYXNjZW5kaW5nJDMiLCJkZXNjZW5kaW5nJDMiLCJjb21wYXJlJDAiLCJjb21wYXJlX2xvY2FsJDAiLCJlcXVhbCQwIiwiZXF1YWxfbG9jYWwkMCIsIm1heCQ0IiwibWluJDQiLCJzeW1ib2wkMjUiLCJzeW1ib2wkMjYiLCJzeW1ib2wkMjciLCJzeW1ib2wkMjgiLCJzeW1ib2wkMjkiLCJzeW1ib2wkMzAiLCJhc2NlbmRpbmckNCIsImRlc2NlbmRpbmckNCIsImNvbXBhcmUkMSIsImNvbXBhcmVfbG9jYWwkMSIsImVxdWFsJDEiLCJlcXVhbF9sb2NhbCQxIiwibWF4JDUiLCJtaW4kNSIsInN5bWJvbCQzMSIsInN5bWJvbCQzMiIsInN5bWJvbCQzMyIsInN5bWJvbCQzNCIsInN5bWJvbCQzNSIsInN5bWJvbCQzNiIsImFzY2VuZGluZyQ1IiwiZGVzY2VuZGluZyQ1IiwiY29tcGFyZSQyIiwiY29tcGFyZV9sb2NhbCQyIiwiZXF1YWwkMiIsImVxdWFsX2xvY2FsJDIiLCJtYXgkNiIsIm1pbiQ2Iiwic3ltYm9sJDM3Iiwic3ltYm9sJDM4Iiwic3ltYm9sJDM5Iiwic3ltYm9sJDQwIiwic3ltYm9sJDQxIiwic3ltYm9sJDQyIiwiYXNjZW5kaW5nJDYiLCJkZXNjZW5kaW5nJDYiLCJjb21wYXJlJDMiLCJlcXVhbCQzIiwiY29tcGFyZV9sb2NhbCQzIiwiZXF1YWxfbG9jYWwkMyIsIm1heCQ3IiwibWluJDciLCJhc2NlbmRpbmckNyIsImRlc2NlbmRpbmckNyIsImNvbXBhcmVfbG9jYWwkNCIsImVxdWFsX2xvY2FsJDQiLCJtYXgkOCIsIm1pbiQ4Iiwic3ltYm9sJDQzIiwic3ltYm9sJDQ0Iiwic3ltYm9sJDQ1Iiwic3ltYm9sJDQ2Iiwic3ltYm9sJDQ3Iiwic3ltYm9sJDQ4IiwiYXNjZW5kaW5nJDgiLCJkZXNjZW5kaW5nJDgiLCJjb21wYXJlJDQiLCJjb21wYXJlX2xvY2FsJDUiLCJlcXVhbCQ0IiwiZXF1YWxfbG9jYWwkNSIsIm1heCQ5IiwibWluJDkiLCJzeW1ib2wkNDkiLCJzeW1ib2wkNTAiLCJzeW1ib2wkNTEiLCJzeW1ib2wkNTIiLCJzeW1ib2wkNTMiLCJzeW1ib2wkNTQiLCJhc2NlbmRpbmckOSIsImRlc2NlbmRpbmckOSIsImNvbXBhcmUkNSIsImNvbXBhcmVfbG9jYWwkNiIsImVxdWFsJDUiLCJlcXVhbF9sb2NhbCQ2IiwibWF4JDEwIiwibWluJDEwIiwic3ltYm9sJDU1Iiwic3ltYm9sJDU2Iiwic3ltYm9sJDU3Iiwic3ltYm9sJDU4IiwiYXNyIiwibGFuZCIsImxub3QkMCIsImxvciIsImxzbCIsImxzciIsImx4b3IiLCJtb2QiLCJhYnMkMCIsImZhaWx3aXRoJDAiLCJmc3QiLCJpbnZhbGlkX2FyZyQwIiwic25kIiwiZmxvYXRfb2Zfc3RyaW5nIiwiYW1fdGVzdGluZyIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsIm9mX3N0cmluZ19vcHQiLCJ0b19mbG9hdCIsIm9mX2Zsb2F0IiwibWF4X3ZhbHVlIiwibWluX3ZhbHVlIiwic3VjYyIsInByZWQiLCJmYWlsd2l0aGYiLCJmbXQiLCJzIiwiaW52YWxpZF9hcmdmIiwiYmFja2VuZF90eXBlIiwiaW50ZXJhY3RpdmUiLCJvc190eXBlIiwidW5peCIsIndpbjMyIiwiY3lnd2luIiwid29yZF9zaXplX2luX2JpdHMiLCJpbnRfc2l6ZV9pbl9iaXRzIiwiYmlnX2VuZGlhbiIsIm1heF9zdHJpbmdfbGVuZ3RoIiwibWF4X2FycmF5X2xlbmd0aCIsInJ1bnRpbWVfdmFyaWFudCIsInJ1bnRpbWVfcGFyYW1ldGVycyIsImFyZ3YiLCJnZXRfYXJndiIsIm9jYW1sX3ZlcnNpb24iLCJlbmFibGVfcnVudGltZV93YXJuaW5ncyIsInJ1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCIsImdldGVudl9leG4iLCJ2YXIkMCIsImdldGVudiIsIm1heF9sZW5ndGgiLCJjcmVhdGUiLCJsZW4iLCJjcmVhdGVfbG9jYWwiLCJjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCIsImFwcGVuZCIsImJsaXQiLCJjb25jYXQiLCJjb3B5IiwiZmlsbCIsImluaXQiLCJyZXMiLCJpIiwibWFrZV9tYXRyaXgiLCJvZl9saXN0Iiwic3ViIiwidG9fbGlzdCIsImZvbGQiLCJmb2xkX3JpZ2h0IiwiaXRlciIsIml0ZXJpIiwibWFwIiwibWFwaSIsInN0YWJsZV9zb3J0Iiwic3dhcCIsImoiLCJlbHRfaSIsImVsdF9qIiwiZXNjYXBlZCIsImxvd2VyY2FzZSIsInRvX2ludCIsInVuc2FmZV9vZl9pbnQiLCJ1cHBlcmNhc2UiLCJpbnRfaXNfb2siLCJvZl9pbnQiLCJvZl9pbnRfZXhuIiwidDEiLCJ0MiIsImhkX2V4biIsInJldl9hcHBlbmQiLCJ0bF9leG4iLCJ1bnppcCIsImxlbmd0aCIsImwkMCIsImwiLCJleGlzdHMiLCJ0JDAiLCJleGlzdHMyX29rIiwibDEiLCJsMiIsImwxJDAiLCJsMiQwIiwibDIkMSIsImEyIiwibDEkMSIsImExIiwiaW5pdCQwIiwiaW5pdCQxIiwiZm9sZDJfb2siLCJmb3JfYWxsIiwiZm9yX2FsbDJfb2siLCJpdGVyMl9vayIsIm5vbnRhaWxfbWFwIiwibm9udGFpbF9tYXBpIiwicGFydGl0aW9uIiwicmV2X21hcCIsImFjY3UiLCJyZXZfbWFwMl9vayIsImFjY3UkMCIsInJldiIsInJlc3QiLCJmb2xkX3JpZ2h0Ml9vayIsImhhc2hfZm9sZF91bml0IiwiaGFzaF9mb2xkX2ludCIsImhhc2hfZm9sZF9pbnQ2NCIsImhhc2hfZm9sZF9mbG9hdCIsImhhc2hfZm9sZF9zdHJpbmciLCJhc19pbnQiLCJoYXNoX2ZvbGRfaW50MzIiLCJoYXNoX2ZvbGRfY2hhciIsImhhc2hfZm9sZF9ib29sIiwiaGFzaF9mb2xkX25hdGl2ZWludCIsImhhc2hfZm9sZF9vcHRpb24iLCJoYXNoX2ZvbGRfZWxlbSIsImhhc2hfZm9sZF9saXN0IiwicyQxIiwibGlzdCQxIiwicyQyIiwibGlzdCIsImxpc3QkMCIsInMkMCIsImhhc2hfZm9sZF9sYXp5X3QiLCJoYXNoX2ZvbGRfcmVmX2Zyb3plbiIsImhhc2hfZm9sZF9hcnJheV9mcm96ZW4iLCJhcnJheSIsImUiLCJpJDAiLCJoYXNoX25hdGl2ZWludCIsImhhc2hfaW50NjQiLCJoYXNoX2ludDMyIiwiaGFzaF9jaGFyIiwiaGFzaF9pbnQiLCJoYXNoX2Jvb2wiLCJoYXNoX3N0cmluZyIsImhhc2hfZmxvYXQiLCJoYXNoX3VuaXQiLCJzZWVkIiwib2ZfZm9sZCIsImhhc2hfZm9sZF90IiwicnVuIiwiZm9sZGVyIiwib3B0Iiwic3RoIiwiY29tcGFyZV9zdGF0ZSIsInN0YXRlX3RvX3N0cmluZyIsInN0YXRlIiwidCQxIiwidCQyIiwidCQzIiwidCQ0IiwidCQ1IiwiY29tcGFyZV9hYnN0cmFjdCIsInR5cGVfbmFtZSIsImVxdWFsX2Fic3RyYWN0IiwiY29tcGFyZV9ib29sIiwiY29tcGFyZV9ib29sX2xvY2FsIiwiY29tcGFyZV9jaGFyIiwiY29tcGFyZV9jaGFyX2xvY2FsIiwiY29tcGFyZV9mbG9hdCIsImNvbXBhcmVfZmxvYXRfbG9jYWwiLCJjb21wYXJlX2ludCIsImNvbXBhcmVfaW50X2xvY2FsIiwiY29tcGFyZV9pbnQzMiIsImNvbXBhcmVfaW50MzJfbG9jYWwiLCJjb21wYXJlX2ludDY0IiwiY29tcGFyZV9pbnQ2NF9sb2NhbCIsImNvbXBhcmVfbmF0aXZlaW50IiwiY29tcGFyZV9uYXRpdmVpbnRfbG9jYWwiLCJjb21wYXJlX3N0cmluZyIsImNvbXBhcmVfc3RyaW5nX2xvY2FsIiwiY29tcGFyZV9ieXRlcyIsImNvbXBhcmVfYnl0ZXNfbG9jYWwiLCJjb21wYXJlX3VuaXQiLCJjb21wYXJlX3VuaXRfbG9jYWwiLCJjb21wYXJlX2FycmF5X2xvY2FsIiwiY29tcGFyZV9lbHQiLCJsZW5fYSIsImxlbl9iIiwicmV0IiwiY29tcGFyZV9hcnJheSIsImNvbXBhcmVfbGlzdCIsImEkMCIsImIkMCIsInlzIiwiY29tcGFyZV9saXN0X2xvY2FsIiwiY29tcGFyZV9lbHRfbG9jYWwiLCJjb21wYXJlX29wdGlvbiIsImNvbXBhcmVfb3B0aW9uX2xvY2FsIiwiY29tcGFyZV9yZWYiLCJjb21wYXJlX3JlZl9sb2NhbCIsImVxdWFsX2Jvb2wiLCJlcXVhbF9ib29sX2xvY2FsIiwiZXF1YWxfY2hhciIsImVxdWFsX2NoYXJfbG9jYWwiLCJlcXVhbF9pbnQiLCJlcXVhbF9pbnRfbG9jYWwiLCJlcXVhbF9pbnQzMiIsImVxdWFsX2ludDMyX2xvY2FsIiwiZXF1YWxfaW50NjQiLCJlcXVhbF9pbnQ2NF9sb2NhbCIsImVxdWFsX25hdGl2ZWludCIsImVxdWFsX25hdGl2ZWludF9sb2NhbCIsImVxdWFsX3N0cmluZyIsImVxdWFsX3N0cmluZ19sb2NhbCIsImVxdWFsX2J5dGVzIiwiZXF1YWxfYnl0ZXNfbG9jYWwiLCJlcXVhbF91bml0IiwiZXF1YWxfdW5pdF9sb2NhbCIsImVxdWFsX2Zsb2F0IiwiZXF1YWxfZmxvYXRfbG9jYWwiLCJlcXVhbF9hcnJheV9sb2NhbCIsImVxdWFsX2VsdCIsImVxdWFsX2FycmF5IiwiZXF1YWxfbGlzdCIsImVxdWFsX2xpc3RfbG9jYWwiLCJlcXVhbF9lbHRfbG9jYWwiLCJlcXVhbF9vcHRpb24iLCJlcXVhbF9vcHRpb25fbG9jYWwiLCJlcXVhbF9yZWYiLCJlcXVhbF9yZWZfbG9jYWwiLCJhXzAwMSIsImJfMDAyIiwiYV8wMDMiLCJiXzAwNCIsImFfMDA1IiwiYl8wMDYiLCJnbG9iYWxpemUiLCJ4XzAwOSIsImFyZ18wMTAiLCJhcmdfMDExIiwiaGFzaCIsImhzdiIsImFyZyIsImEwIiwiaHN2JDAiLCJhMCQwIiwiaHN2JDEiLCJ0X3NleHBfZ3JhbW1hciIsImludmFyaWFudCIsInNleHBfb2ZfdCIsIm51bV9iaXRzIiwid29yZF9zaXplIiwiYWxsIiwicmVnaXN0ZXIiLCJwIiwicHAiLCJtb2R1bGVfbmFtZSIsImZvcm1hdHRlciIsImFyZzFfMDAyIiwiYXJnMF8wMDEiLCJyZXMwXzAwMyIsInJlczFfMDA0IiwiYXJnMV8wMDYiLCJhcmcwXzAwNSIsInJlczBfMDA3IiwicmVzMV8wMDgiLCJjcmVhdGVfcyIsInNleHAiLCJyYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSIsImJhY2t0cmFjZSIsInJlcmFpc2UiLCJleG4iLCJzdHIiLCJleG4kMCIsImJ0IiwicmVyYWlzZWYiLCJleGMiLCJmb3JtYXQiLCJ0b19zdHJpbmdfbWFjaCIsInNleHBfb2ZfdCQwIiwicHJvdGVjdHgiLCJmaW5hbGx5JDAiLCJmaW5hbF9leG4kMCIsImZpbmFsX2V4biIsInByb3RlY3QiLCJkb2VzX3JhaXNlIiwicHBmIiwicHJpbnRfd2l0aF9iYWNrdHJhY2UiLCJyYXdfYmFja3RyYWNlIiwiaGFuZGxlX3VuY2F1Z2h0X2F1eCIsImV4YyQwIiwiaGFuZGxlX3VuY2F1Z2h0X2FuZF9leGl0IiwiaGFuZGxlX3VuY2F1Z2h0IiwibXVzdF9leGl0IiwiZXhpdCQwIiwicmVyYWlzZV91bmNhdWdodCIsImZ1bmMiLCJyYWlzZV93aXRob3V0X2JhY2t0cmFjZSIsImluaXRpYWxpemVfbW9kdWxlIiwiY2xlYXJfYmFja3RyYWNlIiwid2l0aF9yZXR1cm4iLCJpc19hbGl2ZSIsInJldHVybiQwIiwid2l0aF9yZXR1cm5fb3B0aW9uIiwicHJlcGVuZCIsInBhcmFtIiwiY29uc3QkMCIsIm5vbiIsImZvcmV2ZXIiLCJlJDAiLCJjb21wb3NlIiwiZyIsImZsaXAiLCJhcHBseV9uX3RpbWVzIiwibiIsIm4kMCIsIngkMCIsIngkMSIsIm4kMSIsInN5bWJvbF9iaW5kIiwic3ltYm9sX21hcCIsImJpbmQiLCJqb2luIiwiaWdub3JlX20iLCJhbGxfdW5pdCIsIm1hcF92aWFfYmluZCIsIm1hIiwic3ltYm9sX2JpbmQkMCIsInN5bWJvbF9tYXAkMCIsInN5bWJvbF9iaW5kJDEiLCJzeW1ib2xfbWFwJDEiLCJib3RoIiwibG9vcCIsInZzIiwidHMiLCJ2IiwidG9fbW9uYWQiLCJvZl9tb25hZCIsImRlcml2ZWRfbWFwIiwibWFwMiIsInRhIiwidGIiLCJtYXAzIiwidGMiLCJzeW1ib2wkMCIsInN5bWJvbCQxIiwidGYiLCJmYWIiLCJtYXAkMCIsImFwcGx5IiwibWYiLCJteCIsInR4IiwiY3VzdG9tX21hcCIsInJldHVybiQxIiwiYXBwbHkkMCIsIm1hcDIkMCIsIm9mX21vZHVsZSIsIk0iLCJ0b19tb2R1bGUiLCJtYWtlIiwiY29tcGFyYXRvciIsImVycm9yX3NvdXJjZV8wMTciLCJjbXBfZiIsImNtcF9zIiwiYV8wMDciLCJiXzAwOCIsImFfMDA5IiwiYl8wMTAiLCJhXzAxMSIsImJfMDEyIiwiaGFzaF9mb2xkX2YiLCJoYXNoX2ZvbGRfcyIsInRfb2Zfc2V4cCIsIm9mX2ZfMDEzIiwib2Zfc18wMTQiLCJzZXhwXzAxOSIsInRhZ18wMjAiLCJzZXhwX2FyZ3NfMDI2IiwiYXJnMF8wMjciLCJyZXMwXzAyOCIsInNleHBfYXJnc18wMjEiLCJhcmcwXzAyMiIsInJlczBfMDIzIiwib2ZfZl8wMzEiLCJvZl9zXzAzMiIsImFyZzBfMDMzIiwicmVzMF8wMzQiLCJhcmcwXzAzNSIsInJlczBfMDM2IiwiZl9zZXhwX2dyYW1tYXIiLCJzX3NleHBfZ3JhbW1hciIsIm9wYXF1ZV9pZGVudGl0eSIsIm5hbWUiLCJnZXQiLCJmc2V0Iiwic2V0dGVyIiwidXBkYXRlciIsImZpZWxkIiwiY29udmVydF9mYWlsdXJlIiwibnVtX2JpdHNfaW50IiwibnVtX2JpdHNfbmF0aXZlaW50IiwibnVtX2JpdHNfaW50MzIiLCJudW1fYml0c19pbnQ2NCIsIm1pbl9pbnQzMiIsIm1heF9pbnQzMiIsIm1pbl9pbnQ2NCIsIm1heF9pbnQ2NCIsIm1pbl9uYXRpdmVpbnQiLCJtYXhfbmF0aXZlaW50IiwiaW50NjRfdG9fc3RyaW5nIiwibmF0aXZlaW50X3RvX3N0cmluZyIsImludDMyX3RvX2ludF90cnVuYyIsImludF90b19pbnQzMl90cnVuYyIsImludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIiwiaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQiLCJpbnRfdG9faW50MzIiLCJpbnQzMl90b19pbnQiLCJpbnRfdG9faW50MzJfZXhuIiwiaW50MzJfdG9faW50X2V4biIsImludF90b19pbnQ2NCIsImludDY0X3RvX2ludF90cnVuYyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IiwiaW50NjRfdG9faW50IiwiaW50NjRfdG9faW50X2V4biIsImludF90b19uYXRpdmVpbnQiLCJuYXRpdmVpbnRfdG9faW50X3RydW5jIiwibmF0aXZlaW50X3RvX2ludCIsIm5hdGl2ZWludF90b19pbnRfZXhuIiwiaW50MzJfdG9faW50NjQiLCJpbnQ2NF90b19pbnQzMl90cnVuYyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MyIsImludDY0X3RvX2ludDMyIiwiaW50NjRfdG9faW50MzJfZXhuIiwiaW50MzJfdG9fbmF0aXZlaW50IiwibmF0aXZlaW50X3RvX2ludDMyX3RydW5jIiwibmF0aXZlaW50X3RvX2ludDMyIiwibmF0aXZlaW50X3RvX2ludDMyX2V4biIsImludDY0X3RvX25hdGl2ZWludF90cnVuYyIsIm5hdGl2ZWludF90b19pbnQ2NCIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aSIsImludDY0X3RvX25hdGl2ZWludCIsImludDY0X3RvX25hdGl2ZWludF9leG4iLCJpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYiLCJpbnQ2NF9maXRfb25faW50NjNfZXhuIiwiY2FwaXRhbGl6ZSIsInVuY2FwaXRhbGl6ZSIsImlzX3ZhbGlkX3V0Zl84IiwiaXNfdmFsaWRfdXRmXzE2bGUiLCJpc192YWxpZF91dGZfMTZiZSIsImdldF91dGZfOF91Y2hhciIsImJ5dGVfcG9zIiwiZ2V0X3V0Zl8xNmxlX3VjaGFyIiwiZ2V0X3V0Zl8xNmJlX3VjaGFyIiwiZ2V0X3V0Zl8zMl91Y2hhciIsImdldF9pbnQzMiIsImJ5dGVzX3JlYWQiLCJpbnQzMiIsImludCQwIiwiZ2V0X3V0Zl8zMmxlX3VjaGFyIiwiZ2V0X3V0Zl8zMmJlX3VjaGFyIiwic2VwIiwiYmFja191cF9hdF9uZXdsaW5lIiwicG9zIiwiZW9sIiwic3BsaXRfbGluZXMiLCJhYyIsInN0YXJ0IiwiaHN2JDIiLCJwb3NfY251bV8wMTAiLCJwb3NfYm9sXzAwOCIsInBvc19sbnVtXzAwNiIsInBvc19mbmFtZV8wMDQiLCJibmRzXzAwMyIsImFyZ18wMDkiLCJibmRzXzAwMyQwIiwiYXJnXzAwNyIsImJuZHNfMDAzJDEiLCJhcmdfMDA1IiwiYm5kc18wMDMkMiIsImhhc2hfZm9sZF90JDAiLCJoYXNoJDAiLCJtYWtlX2xvY2F0aW9uX3N0cmluZyIsInBvc19mbmFtZSIsInBvc19sbnVtIiwicG9zX2NudW0iLCJwb3NfYm9sIiwiaXNfZW1wdHkiLCJwYXJ0aXRpb25fbWFwIiwiZnN0JDAiLCJ5JDAiLCJzbmQkMCIsImVycm9yX3NvdXJjZV8wMDUiLCJvZl9hXzAwMSIsIm9mX2JfMDAyIiwic2V4cF8wMDciLCJ0YWdfMDA4Iiwic2V4cF9hcmdzXzAwOSIsImFyZzBfMDEwIiwicmVzMF8wMTEiLCJzZXhwX2FyZ3NfMDE0IiwiYXJnMF8wMTUiLCJyZXMwXzAxNiIsIm9mX2FfMDE5Iiwib2ZfYl8wMjAiLCJhcmcwXzAyMSIsInJlczBfMDIyIiwiYXJnMF8wMjMiLCJyZXMwXzAyNCIsImFfc2V4cF9ncmFtbWFyIiwiYl9zZXhwX2dyYW1tYXIiLCJjbXBfYSIsImNtcF9iIiwiYV8wMzMiLCJiXzAzNCIsImFfMDM1IiwiYl8wMzYiLCJhXzAzNyIsImJfMDM4IiwiYV8wMjciLCJiXzAyOCIsImFfMDI5IiwiYl8wMzAiLCJhXzAzMSIsImJfMDMyIiwiYV8wNDUiLCJiXzA0NiIsImFfMDQ3IiwiYl8wNDgiLCJhXzA0OSIsImJfMDUwIiwiYV8wMzkiLCJiXzA0MCIsImFfMDQxIiwiYl8wNDIiLCJhXzA0MyIsImJfMDQ0IiwiaGFzaF9mb2xkX2EiLCJoYXNoX2ZvbGRfYiIsImNoZWNrX29rIiwiY2hlY2tfZXJyb3IiLCJvayIsImVycm9yIiwiZmFpbCIsImZhaWxmIiwibWFwX2Vycm9yIiwiYmluZCQxIiwibWFwJDEiLCJyZXR1cm4kMiIsImlzX29rIiwiaXNfZXJyb3IiLCJvZl9vcHRpb24iLCJpdGVyX2Vycm9yIiwidG9fZWl0aGVyIiwib2ZfZWl0aGVyIiwib2tfaWZfdHJ1ZSIsImJvb2wiLCJ0cnlfd2l0aCIsIm9rX2V4biIsIm9rX29yX2ZhaWx3aXRoIiwiY29tYmluZSIsImVyciIsIm9rMSIsIm9rMiIsImVycjEiLCJlcnIyIiwiY29tYmluZV9lcnJvcnMiLCJlcnJzIiwiY29tYmluZV9lcnJvcnNfdW5pdCIsImNvdW50Iiwic3VtIiwiZm9sZF9yZXN1bHQiLCJhY2MiLCJpdGVtIiwiZm9sZF91bnRpbCIsImZpbmlzaCIsIm1pbl9lbHQiLCJlbHQiLCJtYXhfZWx0IiwibWVtIiwiZmluZF9tYXAiLCJmaW5kIiwidG9fYXJyYXkiLCJpdGVyJDAiLCJpdGVyJDEiLCJsZW5ndGgkMCIsImxlbmd0aCQxIiwiaXNfZW1wdHkkMCIsIm1lbSQwIiwic3VtJDAiLCJtIiwiY291bnQkMCIsImV4aXN0cyQwIiwiZm9yX2FsbCQwIiwiZmluZF9tYXAkMCIsImZpbmQkMCIsInRvX2xpc3QkMCIsInRvX2FycmF5JDAiLCJtaW5fZWx0JDAiLCJtYXhfZWx0JDAiLCJmb2xkX3Jlc3VsdCQwIiwiZm9sZF91bnRpbCQwIiwib2ZfYXJyYXkiLCJjb25jYXRfb2ZfYXJyYXkiLCJjb25jYXRfbWFwIiwiZmlsdGVyX21hcCIsImZpbHRlciIsImVpdGhlciIsInBhcnRpdGlvbl90ZiIsImZvbGQkMCIsIm9mX2xpc3QkMCIsIm9mX2FycmF5JDAiLCJjb25jYXQkMCIsImZvbGRpIiwiYWNjJDAiLCJjb3VudGkiLCJleGlzdHNpIiwiZm9yX2FsbGkiLCJmaW5kX21hcGkiLCJmaW5kaSIsIml0ZXJpJDAiLCJpdGVyaSQxIiwiZm9sZGkkMCIsImZvbGRpJDEiLCJjb3VudGkkMCIsImV4aXN0c2kkMCIsImZvcl9hbGxpJDAiLCJmaW5kX21hcGkkMCIsImZpbmRpJDAiLCJkZXJpdmVkX2luaXQiLCJkZXJpdmVkX2luaXQkMCIsImRlcml2ZWRfY29uY2F0X21hcGkiLCJjb25jYXRfbWFwaSIsImNvbmNhdF9tYXBpJDAiLCJmaWx0ZXJfbWFwaSIsImZpbHRlcmkiLCJjb21wYXJlX2EiLCJlcXVhbF9hIiwicGVlayIsInNleHBfb2ZfYSIsInNsb3dfY2hlY2tfcG9zX2xlbl9leG4iLCJ0b3RhbF9sZW5ndGgiLCJjaGVja19wb3NfbGVuX2V4biIsInN0b3AiLCJnZXRfcG9zX2xlbl9leG4iLCJsZW4kMCIsIm9mX3N0YXRlIiwiYXNzaWduIiwiZHN0Iiwic3JjIiwic3BsaXRfZnJvbV9wYXJlbnQiLCJtYWtlX2xhenkiLCJnZXRfc3RhdGUiLCJmb3JiaWRfbm9uZGV0ZXJtaW5pc21faW5fdGVzdHMiLCJhbGxvd19pbl90ZXN0cyIsImJpdHMiLCJiaXRzNjQiLCJpbnQ2NCIsIm5hdGl2ZWludCIsImNoYXIkMCIsImFzY2lpIiwibWFrZV9zZWxmX2luaXQiLCJkZWZhdWx0JDAiLCJpbnRfb25fNjRiaXRzIiwiYm91bmQiLCJpbnRfb25fMzJiaXRzIiwiaW50JDEiLCJiaXRzJDAiLCJmdWxsX3JhbmdlX2ludDY0IiwiYml0cyQxIiwiZnVsbF9yYW5nZV9pbnQzMiIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzMyYml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyQwIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fNjRiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fMzJiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnQiLCJyYWlzZV9jcm9zc2VkX2JvdW5kcyIsImxvd2VyX2JvdW5kIiwidXBwZXJfYm91bmQiLCJzdHJpbmdfb2ZfYm91bmQiLCJpbnRfaW5jbCIsImxvIiwiaGkiLCJkaWZmIiwiaW50MzJfaW5jbCIsIm5hdGl2ZWludF9pbmNsIiwiaW50NjRfaW5jbCIsImZsb2F0JDAiLCJyMSIsInIyIiwicmVzdWx0IiwiZmxvYXRfcmFuZ2UiLCJiaXRzJDIiLCJiaXRzNjQkMCIsImludCQyIiwiaW50MzIkMCIsIm5hdGl2ZWludCQwIiwiaW50NjQkMCIsImZsb2F0JDEiLCJpbnRfaW5jbCQwIiwiaW50MzJfaW5jbCQwIiwibmF0aXZlaW50X2luY2wkMCIsImludDY0X2luY2wkMCIsImZsb2F0X3JhbmdlJDAiLCJib29sJDAiLCJjaGFyJDEiLCJhc2NpaSQwIiwiZnVsbF9pbml0Iiwic2VsZl9pbml0Iiwic2V0X3N0YXRlIiwicGVybXV0ZSIsInJhbmRvbV9zdGF0ZSIsInN0aCQwIiwibnVtX3N3YXBzIiwidGhpc19pIiwicmFuZG9tX2kiLCJzZXhwXzAwNiIsImVycm9yX3NvdXJjZV8wMzYiLCJhXzAxNCIsImJfMDE1IiwiYV8wMTYiLCJiXzAxNyIsImFfMDEwIiwiYl8wMTEiLCJhXzAxMiIsImJfMDEzIiwib2ZfYV8wMTgiLCJhcmcwXzAxOSIsInJlczBfMDIwIiwic2luZ2xldG9uIiwicmFuZ2UiLCJzdHJpZGUiLCJzdGFydF9pIiwic3RvcF9pIiwibmV4dF9pIiwib3JkZXIiLCJyYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW0iLCJpbml0aWFsX3N0cmlkZV9vcmRlciIsInN0YXJ0X2kkMCIsImlfdG9fc3RvcF9vcmRlciIsIm5leHRfaSQwIiwicmFuZ2UkMCIsInN0aCQxIiwiaGQiLCJ0bCIsIm50aCIsIm50aF9leG4iLCJ1bm9yZGVyZWRfYXBwZW5kIiwib2ZfbGlzdHMiLCJzaGFyZWRfbGVuZ3RoIiwic2hhcmVkX2xlbmd0aCQwIiwiY2hlY2tfbGVuZ3RoMl9leG4iLCJ0YWlsX29mX2IiLCJ0YWlsX29mX2EiLCJjaGVja19sZW5ndGgyIiwib2ZfbGlzdHMkMCIsImwzIiwiYyQwIiwiY2hlY2tfbGVuZ3RoM19leG4iLCJ0YWlsX29mX2MiLCJuMSIsIm4yIiwibjMiLCJjaGVja19sZW5ndGgzIiwiaXRlcjIiLCJpdGVyMl9leG4iLCJyZXZfbWFwMiIsInJldl9tYXAyX2V4biIsImZvbGQyIiwiZm9sZDJfZXhuIiwiZm9sZF9yaWdodDIiLCJmb2xkX3JpZ2h0Ml9leG4iLCJmb3JfYWxsMiIsImZvcl9hbGwyX2V4biIsImV4aXN0czIiLCJleGlzdHMyX2V4biIsImJzIiwicmV2X2ZpbHRlciIsIm5vdF9mb3VuZCIsImZpbmRfbWFwX2V4biIsIm5vdF9mb3VuZCQwIiwiZmluZF9leG4iLCJub3RfZm91bmQkMSIsImZpbmRpX2V4biIsIm5vdF9mb3VuZCQyIiwiZmluZF9tYXBpX2V4biIsIngxIiwieDIiLCJ4MyIsIng0IiwieDUiLCJmb2xkaW5nX21hcCIsIm5ld19hY2MiLCJmb2xkX21hcCIsIm1hcDJfb2siLCJtYXAyX2V4biIsInJldl9tYXAzX29rIiwibDMkMCIsImwzJDEiLCJhYyQwIiwicmV2X21hcDMiLCJyZXZfbWFwM19leG4iLCJtYXAzX29rIiwibWFwM19leG4iLCJyZXZfbWFwX2FwcGVuZCIsImgiLCJsaXN0JDIiLCJ1bnppcDMiLCJ6IiwiemlwX2V4biIsInppcCIsInJldl9tYXBpIiwiaSQyIiwiZm9sZGluZ19tYXBpIiwiZm9sZF9tYXBpIiwicG9zJDEiLCJyZWR1Y2UiLCJyZWR1Y2VfZXhuIiwicmVkdWNlX2JhbGFuY2VkIiwic3RlcF9hY2N1bSIsIm51bSIsIm51bSQwIiwiYWNjJDEiLCJudW0kMSIsInJlZHVjZV9iYWxhbmNlZF9leG4iLCJncm91cGkiLCJicmVhayQwIiwidGFrZV9ncm91cCIsImdyb3VwIiwibWVyZ2UiLCJoMiIsImgxIiwiY21wIiwic29ydCIsInRsJDEiLCJ4MiQwIiwieDEkMCIsInJldl9zb3J0IiwiczEiLCJ0bCQwIiwiczIiLCJhY2N1JDEiLCJzb3J0X2FuZF9ncm91cCIsImRlZHVwX2FuZF9zb3J0IiwiYyQxIiwiYyQyIiwiYyQzIiwiYyQ0IiwiYyQ1IiwiYyQ2Iiwic3RhYmxlX2RlZHVwIiwiZGVkdXBzIiwidW5pcXVlIiwiZGVkdXAiLCJwb3MkMCIsIm1hcDMkMCIsInN5bWJvbCQyIiwibGFzdF9leG4iLCJsYXN0IiwiaXNfcHJlZml4IiwicHJlZml4IiwicHJlZml4JDAiLCJwcmVmaXgkMSIsImhkJDAiLCJmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSIsImExJDAiLCJyZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyIsIndoaWNoX3RvX2tlZXAiLCJ0b19rZWVwJDIiLCJ0b19rZWVwIiwiYWNjdW0iLCJ0b19rZWVwJDAiLCJ0b19rZWVwJDEiLCJmaW5kX2FfZHVwIiwic29ydGVkIiwiaGQyIiwiaGQxIiwiY29udGFpbnNfZHVwIiwibHN0IiwiZmluZF9hbGxfZHVwcyIsInNvcnRlZCQ0IiwicHJldiQzIiwic29ydGVkJDAiLCJwcmV2IiwiYWxyZWFkeV9yZWNvcmRlZCIsInNvcnRlZCQxIiwicHJldiQwIiwiYWxsX2VxdWFsIiwieHMkMCIsImlkeCIsImFjY3VtJDAiLCJyZXZfZmlsdGVyX21hcCIsInJldl9maWx0ZXJfbWFwaSIsImkkMSIsImZpbHRlcl9vcHQiLCJwYXJ0aXRpb24zX21hcCIsInRyZCIsInRyZCQwIiwieSQxIiwiZiQwIiwicGFydGl0aW9uX3Jlc3VsdCIsInRfb2Zfc2V4cCQwIiwib2ZfYV8wMjgiLCJvZl9iXzAyOSIsInhfMDM3Iiwic2V4cF8wMzUiLCJhcmcxXzAzMiIsImFyZzBfMDMxIiwicmVzMF8wMzMiLCJyZXMxXzAzNCIsInNleHBfb2ZfdCQxIiwib2ZfYV8wMzgiLCJvZl9iXzAzOSIsInhfMDQ0IiwiYXJnMV8wNDEiLCJhcmcwXzA0MCIsInJlczBfMDQyIiwicmVzMV8wNDMiLCJ0X3NleHBfZ3JhbW1hciQwIiwicGFpcl9vZl9ncm91cCIsImsiLCJncm91cCQwIiwiYWxpc3QiLCJzb3J0X2FuZF9ncm91cCQwIiwia2V5Iiwia2V5JDAiLCJub3RfZm91bmQkMyIsImZpbmRfZXhuJDAiLCJ2YWx1ZSIsInJlbW92ZSIsImFkZCIsImludmVyc2UiLCJtYXAkMiIsInNwbGl0X24iLCJ0X29yaWciLCJ0YWtlIiwiZHJvcCIsImNodW5rc19vZiIsImwkMSIsInN1Ymxpc3QiLCJzcGxpdF93aGlsZSIsInRha2Vfd2hpbGUiLCJkcm9wX3doaWxlIiwiZHJvcF9sYXN0IiwiZHJvcF9sYXN0X2V4biIsImNhcnRlc2lhbl9wcm9kdWN0IiwibGlzdDEiLCJsaXN0MiIsImNvbmNhdF9ub19vcmRlciIsImNvbnMiLCJpc19zb3J0ZWQiLCJpc19zb3J0ZWRfc3RyaWN0bHkiLCJhcnIiLCJyYW5kb21fZWxlbWVudF9leG4iLCJyYW5kb21fZWxlbWVudCIsImVxdWFsX3dpdGhfbG9jYWxfY2xvc3VyZSIsInQxJDAiLCJ0MiQwIiwidDIkMSIsInQxJDEiLCJlcXVhbF9hX2xvY2FsIiwidHJhbnNwb3NlIiwicm93cyQwIiwicm93cyIsImNvbHVtbnMiLCJkb19yZXYiLCJjb2x1bW5fYWNjIiwidHJpbW1lZF9yb3dzIiwiZm91bmRfZW1wdHkiLCJ0cmltbWVkIiwiY29sdW1uX2FjYyQwIiwiY29sdW1uIiwiZG9fcmV2JDAiLCJjb2x1bW5zJDAiLCJhcmcwXzA0NSIsInJlczBfMDQ2IiwidHJhbnNwb3NlX2V4biIsImludGVyc3BlcnNlIiwiaXNfc3VmZml4Iiwic3VmZml4IiwibGlzdF9sZW4iLCJzdWZmaXhfbGVuIiwicmVzMF8wMDIiLCJhcmcwXzAwMyIsInJlczBfMDA0IiwicmVzMF8wMDYiLCJhcmcwXzAwNyIsInJlczBfMDA4IiwiYXJnMl8wMTEiLCJhcmcxXzAxMCIsImFyZzBfMDA5IiwicmVzMF8wMTIiLCJyZXMxXzAxMyIsInJlczJfMDE0IiwiYXJnMV8wMTYiLCJyZXMwXzAxNyIsInJlczFfMDE4IiwiYXJnMl8wMjEiLCJhcmcxXzAyMCIsInJlczFfMDIzIiwicmVzMl8wMjQiLCJhcmcxXzAyNiIsImFyZzBfMDI1IiwicmVzMF8wMjciLCJyZXMxXzAyOCIsImFyZzFfMDMwIiwiYXJnMF8wMjkiLCJyZXMwXzAzMSIsInJlczFfMDMyIiwidG9fc2V4cHNfaHVtIiwic3RyaW5nIiwiaGVyZSIsInNleHAkMCIsInRhZyIsImhlcmUkMCIsInRhZyQwIiwic2V4cCQxIiwidGFnJDEiLCJib2R5IiwidG9fc2V4cF9odW0iLCJzZXhwcyIsImdsb2JhbGl6ZV9pbmZvIiwiY29tcHV0ZV9pbmZvJDAiLCJpbmZvIiwic3RhY2siLCJpbmZvJDAiLCJzdGFjayQwIiwiY29tcHV0ZV9tZXNzYWdlIiwibWVzc2FnZSIsInN0YWNrJDEiLCJsYXp5X2luZm8iLCJpbmZvJDEiLCJpbmZvcyIsImNvbXB1dGVfaW5mb19saXN0IiwiaW5mbyQyIiwic3RhY2skMiIsImluZm8kMyIsInN0YWNrJDMiLCJmd2RfcHJlZml4IiwicmV2X3N1ZmZpeCIsImZ3ZF9wcmVmaXgkMCIsInRhaWwiLCJtZXNzYWdlcyIsIm1lc3NhZ2UkMCIsIm1lc3NhZ2UkMSIsIm1lc3NhZ2UkMiIsInN0YWNrJDQiLCJjb21wdXRlX2luZm8iLCJ0b19tZXNzYWdlIiwib2ZfbWVzc2FnZSIsIm9mX2NvbnMiLCJvZl9sYXp5X2NvbnMiLCJsYXp5X2NvbnMiLCJvZl9sYXp5X21lc3NhZ2UiLCJsYXp5X21lc3NhZ2UiLCJ0b19zdHJpbmdfaHVtIiwib2ZfbGF6eSIsIm9mX2xhenlfc2V4cCIsIm9mX2xhenlfdCIsImNyZWF0ZWYiLCJvZl90aHVuayIsInN0cmljdCIsInNleHBfb2ZfeCIsInRhZ19zX2xhenkiLCJ0YWdfcyIsInRhZ19hcmciLCJ0b19leG4iLCJvZl9leG4iLCJiYWNrdHJhY2UkMCIsImJhY2t0cmFjZSQxIiwiYmFja3RyYWNlJDIiLCJyYWlzZSIsInJhaXNlX3MiLCJ0b19pbmZvIiwib2ZfaW5mbyIsImNoZWNrX2ZpZWxkIiwiYV8wMTkiLCJiXzAyMCIsImFfMDEzIiwiYl8wMTQiLCJnbG9iYWxpemVfYV8wMjYiLCJ4XzAyNyIsIm9mX2FfMDMwIiwieF8wMzIiLCJvZl9hXzAzMyIsInhfMDM0IiwiaW52YXJpYW50X2EiLCJlMSIsImUyIiwidHJ5X3dpdGhfam9pbiIsIm9mX2V4bl9yZXN1bHQiLCJlcnJvcl9zIiwiZXJyb3Jfc3RyaW5nIiwiZXJyb3JmIiwidW5pbXBsZW1lbnRlZCIsImNvbWJpbmVfaW50ZXJuYWwiLCJvbl9vayIsIm9uX2Vycm9yIiwiaWdub3JlX3VuaXRfbGlzdCIsImVycm9yX29mX2xpc3RfaWZfbmVjZXNzYXJ5IiwiZmlsdGVyX29rX2F0X2xlYXN0X29uZSIsImZpbmRfb2siLCJmaW5kX21hcF9vayIsImVycm9yX3NvdXJjZV8wMDMiLCJzZXhwXzAwNCIsImdlcSIsImxlcSIsImJldHdlZW4iLCJsb3ciLCJoaWdoIiwiY2xhbXBfdW5jaGVja2VkIiwiY2xhbXBfZXhuIiwiY2xhbXAiLCJsZXhpY29ncmFwaGljIiwiY21wcyIsImNtcHMkMCIsImxpZnQiLCJyZXZlcnNlIiwiY29tcGFyZV9yZXZlcnNlZCIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJzaWduIiwiaGFzaF9wYXJhbSIsInBvbHkiLCJvZl9rZXkiLCJLZXkiLCJ0b19rZXkiLCJoYXNoX3BhcmFtJDAiLCJwb2x5JDAiLCJvZl9rZXkkMCIsInRvX2tleSQwIiwiaGFzaGFibGUiLCJnZXRfcG9zX2xlbiIsImZpbmRfZmlyc3Rfc2F0aXNmeWluZyIsImhpJDAiLCJsbyQxIiwibWlkIiwibG8kMiIsImxvJDAiLCJmaW5kX2xhc3Rfc2F0aXNmeWluZyIsImJpbmFyeV9zZWFyY2giLCJob3ciLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCIsInNlZ21lbnRfb2YiLCJpc19sZWZ0IiwiaXNfcmlnaHQiLCJhbGwkMCIsImJsaXRfc3RyaW5nIiwic2V0X3VjaGFyX3V0Zl84Iiwic2V0X3VjaGFyX3V0Zl8xNmxlIiwic2V0X3VjaGFyX3V0Zl8xNmJlIiwic2V0X3V0Zl8zMl91Y2hhciIsInNldF9pbnQzMiIsImJ5dGVzIiwidWNoYXIiLCJzZXRfdWNoYXJfdXRmXzMybGUiLCJzZXRfdWNoYXJfdXRmXzMyYmUiLCJ1bnNhZmVfYmxpdCIsInNyY19wb3MiLCJkc3RfcG9zIiwiYmxpdG8iLCJzcmNfbGVuIiwic3VibyIsImNyZWF0ZV9saWtlIiwidW5zYWZlX2JsaXQkMCIsImlzX2ZpcnN0IiwiaXNfc2Vjb25kIiwidmFsdWVfbWFwIiwiZmlyc3QiLCJzZWNvbmQiLCJlcTEiLCJlcTIiLCJsb2NhbF9lcXVhbCIsIm90aGVyIiwiZm9jdXMiLCJjb21iaW5lX2FsbCIsInRzJDEiLCJ0cyQwIiwibWF0Y2gkMCIsIm1hdGNoIiwiY29tYmluZV9hbGxfdW5pdCIsInRvX29wdGlvbiIsImZvY3VzJDAiLCJjb21iaW5lJDAiLCJiaW5kJDAiLCJpc19ub25lIiwiaXNfc29tZSIsIm8iLCJjYWxsIiwidmFsdWVfZXhuIiwiZXJyb3IkMCIsIm0kMCIsIm0kMSIsInZhbHVlX29yX3RodW5rIiwic29tZSIsImZpcnN0X3NvbWUiLCJzb21lX2lmIiwiY29uZCIsImVycm9yX3NvdXJjZV8wNTciLCJvZl9zXzAwMiIsInN0YXRlXzAwNCIsInN0YXRlXzAwOSIsInZhbHVlXzAwNyIsImJuZHNfMDA2IiwiYXJnXzAwOCIsImJuZHNfMDA2JDAiLCJuZXh0IiwidmlldyIsIm5leHRfc3RlcCIsImRlbGF5ZWRfZm9sZF9zdGVwIiwidW5mb2xkX3N0ZXAiLCJ1bmZvbGQiLCJ1bmZvbGRfd2l0aCIsInNlZWQkMCIsInNlZWQkMSIsInVuZm9sZF93aXRoX2FuZF9maW5pc2giLCJydW5uaW5nX3N0ZXAiLCJpbm5lcl9maW5pc2hlZCIsImZpbmlzaGluZ19zdGVwIiwic3RhdGUkMCIsInN0YXRlJDEiLCJzdGF0ZSQyIiwiaW5uZXJfc3RhdGUiLCJzdGF0ZSQzIiwiaW5uZXJfc3RhdGUkMCIsImlubmVyX3N0YXRlJDEiLCJzdGF0ZSQ0Iiwic3RhdGUkNSIsInNlZWQkMiIsInYkMCIsInRvX2xpc3RfcmV2Iiwic3RhcnRfdiIsInN0b3BfdiIsInN0ZXAiLCJ0X2xhenkiLCJsJDIiLCJzb21lX2IiLCJlbXB0eSIsIm5leHQkMCIsInMkMyIsImFfMDIzIiwiYl8wMjQiLCJhXzAyNSIsImJfMDI2IiwiYV8wMTUiLCJiXzAxNiIsImFfMDE3IiwiYl8wMTgiLCJhXzAyMSIsImJfMDIyIiwiYV8wNTEiLCJiXzA1MiIsImEwJDEiLCJoc3YkMyIsIm9mX2FfMDUzIiwib2ZfYl8wNTQiLCJzZXhwXzA1OSIsInRhZ18wNjAiLCJzZXhwX2FyZ3NfMDY2IiwiYXJnMF8wNjciLCJyZXMwXzA2OCIsInNleHBfYXJnc18wNjEiLCJhcmcwXzA2MiIsInJlczBfMDYzIiwic2V4cF9hcmdzXzA3MSIsImFyZzFfMDczIiwiYXJnMF8wNzIiLCJyZXMwXzA3NCIsInJlczFfMDc1Iiwib2ZfYV8wNzgiLCJvZl9iXzA3OSIsImFyZzBfMDgwIiwicmVzMF8wODEiLCJhcmcwXzA4MiIsInJlczBfMDgzIiwiYXJnMV8wODUiLCJhcmcwXzA4NCIsInJlczBfMDg2IiwicmVzMV8wODciLCJtZXJnZV93aXRoX2R1cGxpY2F0ZXMiLCJuZXh0MiIsIm5leHQxIiwiczIkMCIsInMyJDEiLCJzMSQwIiwiczIkMiIsInMxJDEiLCJzMiQzIiwiY29tcGFyaXNvbiIsIm1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZCIsIm1lcmdlX3NvcnRlZCIsInRsX2VhZ2VybHlfZXhuIiwibGlmdF9pZGVudGl0eSIsImNodW5rc19leG4iLCJ6aXBfZnVsbCIsImJvdW5kZWRfbGVuZ3RoIiwiYXRfbW9zdCIsImxlbmd0aF9pc19ib3VuZGVkX2J5IiwiY3VyIiwiY3VyJDAiLCJsYXN0X2VsdCIsImxhc3RfZWx0JDAiLCJzaGlmdF9yaWdodCIsInNoaWZ0X3JpZ2h0X3dpdGhfbGlzdCIsInMkNSIsImEkMSIsInMkNCIsInJlcGVhdCIsImN5Y2xlX2xpc3RfZXhuIiwic2EiLCJzYiIsImRlbGF5ZWRfZm9sZCIsIm9wdGlvbiIsImZvbGRfbSIsIml0ZXJfbSIsImZvcmNlX2VhZ2VybHkiLCJtZW1vaXplIiwiZHJvcF9lYWdlcmx5IiwiZHJvcF93aGlsZV9vcHRpb24iLCJza2lwX2xvb3AiLCJuZXh0X3IiLCJzX3IkMSIsIm5leHRfbCIsInNfbCQxIiwic19sIiwic19yIiwiciQwIiwic19yJDAiLCJzX2wkMCIsImNvbXBhcmVfYV9sb2NhbCIsInJvdW5kX3JvYmluIiwiZG9uZV9zdGFjayIsInRvZG9fc3RhY2siLCJ0b2RvX3N0YWNrJDAiLCJpbnRlcmxlYXZlIiwiZjEiLCJmMiIsImludGVybGVhdmVkX2NhcnRlc2lhbl9wcm9kdWN0Iiwib2Zfc2VxIiwic2VxIiwidG9fc2VxIiwieWllbGQkMCIsIm9mX3NlcXVlbmNlIiwic2VxdWVuY2UiLCJ0aHVuayIsImFfb2Zfc2V4cCIsImJfb2Zfc2V4cCIsInNleHBfb2ZfYiIsImNfb2Zfc2V4cCIsInNleHBfb2ZfYyIsInNldCIsInRtcCIsImxlZnQiLCJyaWdodCIsImZpbmFsX3BvcyIsImlfbmV4dCIsImhlYXBpZnkiLCJyb290Iiwicm9vdCQwIiwicmVsYXRpdmVfcm9vdCIsImxlZnRfY2hpbGQiLCJyaWdodF9jaGlsZCIsImxhcmdlc3QiLCJsYXJnZXN0JDAiLCJzb3J0JDAiLCJmaXZlX2VsZW1lbnRfc29ydCIsIm0xIiwibTIiLCJtMyIsIm00IiwibTUiLCJjb21wYXJlX2FuZF9zd2FwIiwiaW50cm9fc29ydCIsIm1heF9kZXB0aCIsIm1heF9kZXB0aCQwIiwibGVmdCQwIiwibWF4X2RlcHRoJDEiLCJzaXh0aCIsIm0yX3ZhbCIsIm0zX3ZhbCIsIm00X3ZhbCIsIm1pZGRsZV9zb3J0ZWQiLCJwaXZvdDIiLCJwaXZvdDEiLCJwJDEiLCJyJDIiLCJwdiIsInIkMSIsInAkMCIsImxlZnQkMSIsInNvcnQkMSIsInNvcnQkMiIsImVsdF9pX21pbnVzXzEiLCJtZXJnZWQiLCJhMV9pbmRleCIsImEyX2luZGV4IiwidXNlX2ExIiwiY29weV9tYXRyaXgiLCJleHRyZW1hbF9lbGVtZW50Iiwia2VlcF9sZWZ0X2lmIiwiY29tcGFyZV9yZXN1bHQiLCJyZXZfaW5wbGFjZSIsIm9mX2xpc3RfcmV2Iiwib2ZfbGlzdF9tYXAiLCJvZl9saXN0X21hcGkiLCJvZl9saXN0X3Jldl9tYXAiLCJvZl9saXN0X3Jldl9tYXBpIiwiZm9yX2FsbDJfbG9jYWxfZXhuIiwibWFwX2lucGxhY2UiLCJmaW5kaV9pbnRlcm5hbCIsImlmX2ZvdW5kIiwiaWZfbm90X2ZvdW5kIiwiZm91bmQiLCJ2YWx1ZV9mb3VuZCIsInJlczEiLCJyZXMyIiwic29ydGVkX2NvcHkiLCJwYXJ0aXRpb25fbWFwaSIsImZpcnN0cyIsInNlY29uZHMiLCJwYXJ0aXRpb25pX3RmIiwidG9fc2VxdWVuY2VfbXV0YWJsZSIsInRvX3NlcXVlbmNlIiwiaTEiLCJpMiIsInR0Iiwid2lkdGgiLCJkZXB0aCIsImQiLCJ3IiwidHQkMCIsImdldCQwIiwiY2VpbCIsImZsb29yIiwibW9kX2Zsb2F0IiwibW9kZiIsIm1heF9maW5pdGVfdmFsdWUiLCJjbGFzc2lmeV9mbG9hdCIsImFic19mbG9hdCIsImlzX2ludGVnZXIiLCJmcmV4cCIsImxkZXhwIiwiaXNfbmFuIiwidG9faW50NjRfcHJlc2VydmVfb3JkZXIiLCJ0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlcl9leG4iLCJvZl9pbnQ2NF9wcmVzZXJ2ZV9vcmRlciIsIm9uZV91bHAiLCJkaXIiLCJ1cHBlcl9ib3VuZF9mb3JfaW50IiwiZXhwIiwiaXNfeF9taW51c19vbmVfZXhhY3QiLCJsb3dlcl9ib3VuZF9mb3JfaW50IiwibWluX2ludF9hc19mbG9hdCIsInRvX2NsYW1wX21heWJlX25hbiIsIm1pbl93aGljaF9pc19ub3RfbmFuIiwibWF4X3doaWNoX2lzX25vdF9uYW4iLCJ0X21heWJlX25hbiIsImJveCIsIm92ZXJmbG93X2JvdW5kX21heF9pbnQ2M19vbl9pbiIsIm92ZXJmbG93X2JvdW5kX21heF9pbnQ2NF92YWx1ZSIsImludDMyX3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsIm92ZXJmbG93X2JvdW5kX21heF9pbnRfdmFsdWUiLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50MzJfdmFsdWUiLCJpbnRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIiwiaW50NjNfb25faW50NjRfcG9zaXRpdmVfb3ZlcmZsIiwiaW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIiwiaW50NjRfbmVnYXRpdmVfb3ZlcmZsb3dfYm91bmRzIiwibmVnYXRpdmVfZXhwb25lbnQiLCJvdmVyZmxvdyIsImludF9wb3ciLCJiYXNlIiwiZXhwb25lbnQiLCJpbnQ2NF9wb3ciLCJpbnQ2M19wb3dfb25faW50NjQiLCJydmFsIiwib25lIiwicm91bmRfZG93biIsIm1vZHVsdXMiLCJyb3VuZF91cCIsInJlbWFpbmRlciIsInJvdW5kX3Rvd2FyZHNfemVybyIsInRvX211bHRpcGxlX29mIiwicm91bmRfbmVhcmVzdCIsIm1vZHVsdXNfbWludXNfcmVtYWluZGVyIiwicm91bmQiLCJzdGFnZSIsInVuc3RhZ2UiLCJpc19sb3dlcmNhc2UiLCJpc191cHBlcmNhc2UiLCJpc19wcmludCIsImlzX3doaXRlc3BhY2UiLCJpc19kaWdpdCIsImlzX2FscGhhIiwiaXNfYWxwaGFudW0iLCJnZXRfZGlnaXRfdW5zYWZlIiwiZ2V0X2RpZ2l0X2V4biIsImdldF9kaWdpdCIsImlzX2hleF9kaWdpdCIsImlzX2hleF9kaWdpdF9sb3dlciIsImlzX2hleF9kaWdpdF91cHBlciIsImdldF9oZXhfZGlnaXRfZXhuIiwiZ2V0X2hleF9kaWdpdCIsInRfb2Zfc2V4cCQxIiwiYzEiLCJjMiIsImhhc2hfZm9sZF90JDEiLCJoYXNoJDEiLCJ0cl9jcmVhdGVfbWFwIiwidGFyZ2V0IiwicmVwbGFjZW1lbnQiLCJ0cl9tYXAiLCJpJDMiLCJpbmRleCQwIiwibGFzdF9yZXBsYWNlbWVudCIsImluZGV4IiwiZmlyc3RfdGFyZ2V0IiwiY29kZWNfbmFtZSIsImNvZGVjX25hbWUkMCIsIm1vZHVsZV9uYW1lJDAiLCJjb2RlY19uYW1lJDEiLCJtb2R1bGVfbmFtZSQxIiwiY29kZWNfbmFtZSQyIiwibW9kdWxlX25hbWUkMiIsImNvZGVjX25hbWUkMyIsIm1vZHVsZV9uYW1lJDMiLCJ1bnNhZmVfc3ViIiwiY29udGFpbnMiLCJlbmQiLCJpbmRleF9mcm9tX2ludGVybmFsIiwiaW5kZXhfZXhuIiwiaW5kZXhfZnJvbSIsImluZGV4X2Zyb21fZXhuIiwicmluZGV4X2Zyb21faW50ZXJuYWwiLCJyaW5kZXgiLCJyaW5kZXhfZXhuIiwicmluZGV4X2Zyb20iLCJyaW5kZXhfZnJvbV9leG4iLCJjYXNlX3NlbnNpdGl2ZSIsInBhdHRlcm4iLCJrbXBfaW50ZXJuYWxfbG9vcCIsIm1hdGNoZWRfY2hhcnMiLCJuZXh0X3RleHRfY2hhciIsImttcF9hcnJheSIsImNoYXJfZXF1YWwiLCJtYXRjaGVkX2NoYXJzJDAiLCJnZXRfY2hhcl9lcXVhbCIsImluZGV4X2ludGVybmFsIiwidGV4dCIsIm1hdGNoZXMiLCJpbiQwIiwiaW5kZXhfZXhuJDAiLCJpbmRleF9hbGwiLCJtYXlfb3ZlcmxhcCIsInJlcGxhY2VfZmlyc3QiLCJ3aXRoJDAiLCJsZW5fcyIsImxlbl90IiwibGVuX3dpdGgiLCJyZXBsYWNlX2FsbCIsIm51bV9tYXRjaGVzIiwibmV4dF9kc3RfcG9zIiwibmV4dF9zcmNfcG9zIiwic3BsaXRfb24iLCJwYXR0ZXJuX2xlbiIsImttcF9hcnJheV8wMTIiLCJjYXNlX3NlbnNpdGl2ZV8wMTAiLCJwYXR0ZXJuXzAwOCIsImFyZ18wMTMiLCJibmRzXzAwNyIsImJuZHNfMDA3JDAiLCJibmRzXzAwNyQxIiwicmVwcmVzZW50YXRpb24iLCJzdWJzdHJfaW5kZXhfZ2VuIiwic3Vic3RyX2luZGV4X2V4bl9nZW4iLCJzdWJzdHJfaW5kZXhfYWxsX2dlbiIsInN1YnN0cl9yZXBsYWNlX2ZpcnN0X2dlbiIsInN1YnN0cl9yZXBsYWNlX2FsbF9nZW4iLCJpc19zdWJzdHJpbmdfZ2VuIiwic3Vic3RyaW5nIiwic3Vic3RyX2luZGV4Iiwic3Vic3RyX2luZGV4X2V4biIsInN1YnN0cl9pbmRleF9hbGwiLCJzdWJzdHJfcmVwbGFjZV9maXJzdCIsInN1YnN0cl9yZXBsYWNlX2FsbCIsImlzX3N1YnN0cmluZyIsImlzX3N1YnN0cmluZ19hdF9nZW4iLCJzdHJfcG9zJDEiLCJzdHJfbGVuIiwic3ViX2xlbiIsInN0cl9wb3MiLCJzdWJfcG9zIiwic3ViX3BvcyQwIiwic3RyX3BvcyQwIiwiaXNfc3VmZml4X2dlbiIsInN0cmluZ19sZW4iLCJpc19wcmVmaXhfZ2VuIiwicHJlZml4X2xlbiIsInNleHBfb2ZfdCQyIiwic3RyaW5nMSIsInN0cmluZzIiLCJsZW4yIiwibGVuMSIsInN1YnN0cl9pbmRleCQwIiwic3Vic3RyX2luZGV4X2V4biQwIiwic3Vic3RyX2luZGV4X2FsbCQwIiwic3Vic3RyX3JlcGxhY2VfZmlyc3QkMCIsInN1YnN0cl9yZXBsYWNlX2FsbCQwIiwiaXNfc3Vic3RyaW5nJDAiLCJpc19zdWJzdHJpbmdfYXQiLCJsc3BsaXQyX2V4biIsImxpbmUiLCJkZWxpbSIsInJzcGxpdDJfZXhuIiwibHNwbGl0MiIsIm9uIiwicnNwbGl0MiIsImNoYXJfbGlzdF9tZW0iLCJzcGxpdF9nZW4iLCJpc19kZWxpbSIsImxhc3RfcG9zIiwibGFzdF9wb3MkMSIsImxhc3RfcG9zJDAiLCJwb3MxIiwic3ViX3N0ciIsInNwbGl0Iiwic3BsaXRfb25fY2hhcnMiLCJjaGFycyIsImlzX3N1ZmZpeCQwIiwiaXNfcHJlZml4JDAiLCJpc19zdWJzdHJpbmdfYXQkMCIsIndyYXBfc3ViX24iLCJkcm9wX3ByZWZpeCIsImRyb3Bfc3VmZml4IiwibGZpbmRpIiwicmZpbmRpIiwibGFzdF9ub25fZHJvcCIsInJzdHJpcCIsImZpcnN0X25vbl9kcm9wIiwibHN0cmlwIiwic3RyaXAiLCJ0ciIsInRyX211bHRpIiwiY29uY2F0X2FycmF5IiwiYXIiLCJjb25jYXRfbGluZXMiLCJsaW5lcyQzIiwiY3JsZiIsIm5ld2xpbmVfbGVuIiwibGluZXMiLCJsaW5lcyQwIiwiYnVmIiwibGluZXMkMSIsIndyaXR0ZW4iLCJsaW5lcyQyIiwibGluZSQwIiwib3V0Iiwib3V0X3BvcyIsIm91dCQwIiwiY2hvcF9wcmVmaXgiLCJjaG9wX3ByZWZpeF9pZl9leGlzdHMiLCJjaG9wX3ByZWZpeF9leG4iLCJjaG9wX3N1ZmZpeCIsImNob3Bfc3VmZml4X2lmX2V4aXN0cyIsImNob3Bfc3VmZml4X2V4biIsInNob3J0ZXIiLCJzaG9ydGVzdCIsInBvc19mcm9tX2xlZnQiLCJwb3NfZnJvbV9yaWdodCIsImNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCIsImdldF9wb3MiLCJtYXhfbGVuIiwibGVuX3NvX2ZhciIsImxlbl9zb19mYXIkMCIsImxlbl9zb19mYXIkMSIsImNvbW1vbl9nZW5lcmljMl9sZW5ndGgiLCJjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCIsImZpcnN0JDAiLCJtYXhfbGVuJDAiLCJtYXhfbGVuJDEiLCJjb21tb25fZ2VuZXJpY19sZW5ndGgiLCJjb21tb25fZ2VuZXJpYzIiLCJjb21tb25fZ2VuZXJpYyIsImNvbW1vbl9wcmVmaXgiLCJjb21tb25fc3VmZml4IiwiY29tbW9uX3ByZWZpeDIiLCJjb21tb25fc3VmZml4MiIsImNvbW1vbl9wcmVmaXhfbGVuZ3RoIiwiY29tbW9uX3N1ZmZpeF9sZW5ndGgiLCJjb21tb25fcHJlZml4Ml9sZW5ndGgiLCJjb21tb25fc3VmZml4Ml9sZW5ndGgiLCJvZl9jaGFyIiwib2ZfY2hhcl9saXN0IiwicGFkX3JpZ2h0IiwicGFkX2xlZnQiLCJsb2NhbF9jb3B5X3ByZWZpeCIsImJ1ZmZlcl9sZW4iLCJsb2NhbF9jb3B5X3RvX3N0cmluZyIsInNyY19wb3MkMCIsImRzdF9wb3MkMCIsInBhcnRpdGlvbl9tYXBfZGlmZmVyZW5jZSIsImZzdF9wb3MkMCIsInNuZF9wb3MkMCIsImZzdHMiLCJzbmRzIiwic25kX3BvcyQxIiwiZnN0X3BvcyQxIiwic25kX3BvcyQyIiwic3JjX3BvcyQxIiwiZnN0X3BvcyIsInNuZF9wb3MiLCJjMSQxIiwiZWl0aGVyJDEiLCJjMiQxIiwiYzIkMiIsImMxJDAiLCJlaXRoZXIkMCIsImMyJDAiLCJwb3MkMiIsImVkaXRfZGlzdGFuY2UiLCJ0YWJsZSIsImF0IiwiZGVsIiwiYnVpbGRfYW5kX3ZhbGlkYXRlX2VzY2FwZXdvcnRoIiwiZXNjYXBld29ydGh5X21hcCIsImVzY2FwZV9jaGFyIiwiZXNjYXBld29ydGh5X21hcCQwIiwidmFscyIsImNfdG8iLCJjX2Zyb20iLCJrJDAiLCJlc2NhcGVfZ2VuIiwiZXNjYXBld29ydGh5IiwidG9fZXNjYXBlX2xlbiIsInRvX2VzY2FwZSIsImxhc3RfaWR4IiwibGFzdF9kc3RfcG9zIiwibGFzdF9pZHgkMCIsImxhc3RfZHN0X3BvcyQwIiwidG9fZXNjYXBlJDAiLCJlc2NhcGVkX2NoYXIiLCJsYXN0X2lkeCQxIiwibGFzdF9kc3RfcG9zJDEiLCJlc2NhcGVfZ2VuX2V4biIsImVzY2FwZSIsInVuZXNjYXBlX2dlbiIsInN0YXR1cyIsInRvX3VuZXNjYXBlIiwic3RhdHVzJDAiLCJ0b191bmVzY2FwZSQwIiwidW5lc2NhcGVfZ2VuX2V4biIsInVuZXNjYXBlIiwicHJlY2VkaW5nX2VzY2FwZV9jaGFycyIsImNudCIsImNudCQwIiwidXBkYXRlX2VzY2FwZV9zdGF0dXMiLCJlc2NhcGVfc3RhdHVzIiwib2RkIiwiY2hlY2tfYm91bmQiLCJmdW5jdGlvbl9uYW1lIiwiaXNfY2hhcl9lc2NhcGluZyIsImlzX2NoYXJfZXNjYXBlZCIsImlzX2NoYXJfbGl0ZXJhbCIsImluZGV4X2Zyb20kMCIsInN0YXR1cyQxIiwiaW5kZXhfZnJvbV9leG4kMCIsImluZGV4JDEiLCJpbmRleF9leG4kMSIsInJpbmRleF9mcm9tJDAiLCJlc2NhcGVfY2hhcnMiLCJyaW5kZXhfZnJvbV9leG4kMCIsInJpbmRleCQwIiwicmluZGV4X2V4biQwIiwic3BsaXRfZ2VuJDAiLCJzcGxpdCQwIiwic3BsaXRfb25fY2hhcnMkMCIsInNwbGl0X2F0IiwibHNwbGl0MiQwIiwicnNwbGl0MiQwIiwibHNwbGl0Ml9leG4kMCIsInJzcGxpdDJfZXhuJDAiLCJsYXN0X25vbl9kcm9wX2xpdGVyYWwiLCJmaXJzdF9ub25fZHJvcF9saXRlcmFsIiwicnN0cmlwX2xpdGVyYWwiLCJsc3RyaXBfbGl0ZXJhbCIsInN0cmlwX2xpdGVyYWwiLCJiZXR3ZWVuJDAiLCJjbGFtcF9leG4kMCIsImNsYW1wJDAiLCJjcmVhdGUkMCIsImlzX3ZhbGlkIiwicmFpc2VfZ2V0X21lc3NhZ2UiLCJyYWlzZV9nZXQiLCJkZWNvZGUiLCJvZl9zdHJpbmdfdW5jaGVja2VkIiwicmFpc2Vfb2Zfc3RyaW5nX21lc3NhZ2UiLCJyYWlzZV9vZl9zdHJpbmciLCJieXRlX3BvcyQwIiwic2FuaXRpemUiLCJ1Y2hhcnMiLCJ1bnRpbCIsInN0YXJ0JDEiLCJ1bnRpbCQwIiwiYnl0ZV9sZW5ndGgiLCJieXRlX2xlbmd0aCQwIiwic2V0JDAiLCJieXRlX2xlbmd0aCQxIiwic2V0JDEiLCJnZXRfZGVjb2RlX3Jlc3VsdCIsInNldCQyIiwic2V0JDMiLCJjcmVhdGUkMSIsIm1hcGkkMCIsIm9jYW1sX2xleF90YWJsZXMiLCJwYXJzZV9oZXgiLCJsZXhidWYiLCJvY2FtbF9sZXhfc3RhdGUiLCJvY2FtbF9sZXhfc3RhdGUkMCIsImluc2VydF9kZWxpbWl0ZXJfZXZlcnkiLCJkZWxpbWl0ZXIiLCJjaGFyc19wZXJfZGVsaW1pdGVyIiwiaW5wdXRfbGVuZ3RoIiwiaGFzX3NpZ24iLCJudW1fZGlnaXRzIiwibnVtX2RlbGltaXRlcnMiLCJvdXRwdXRfbGVuZ3RoIiwiaW5wdXRfcG9zIiwib3V0cHV0X3BvcyIsIm51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXIiLCJmaXJzdF9kaWdpdF9wb3MiLCJpbnNlcnRfZGVsaW1pdGVyIiwiaW5zZXJ0X3VuZGVyc2NvcmVzIiwic2V4cF9vZl9pbnRfc3R5bGUiLCJ0b19zdHJpbmdfc3VmZml4IiwiY2hhcl9pbmRleCIsImJpdF9pbmRleCIsImJpdCIsImRlbGltaXRlciQwIiwibWFrZV9zdWZmaXgiLCJ0b19zdHJpbmckMCIsImludmFsaWQiLCJvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIiLCJsZXgiLCJib2R5JDAiLCJoMDEiLCJtYXNrIiwiaW50NjRfcG9wY291bnQiLCJ4JDIiLCJpbnQzMl9wb3Bjb3VudCIsIm5hdGl2ZWludF9wb3Bjb3VudCIsIm9mX3N0cmluZyQwIiwiZmxvYXRfbG93ZXJfYm91bmQiLCJmbG9hdF91cHBlcl9ib3VuZCIsIm9mX2Zsb2F0X3VuY2hlY2tlZCIsInplcm8iLCJtaW51c19vbmUiLCJmdW5jJDAiLCJuZWciLCJvZl9zdHJpbmckMSIsIm9mX2ludDMyIiwib2ZfaW50MzJfZXhuIiwidG9faW50MzIiLCJ0b19pbnQzMl9leG4iLCJvZl9pbnQ2NCIsIm9mX2ludDY0X2V4biIsInRvX2ludDY0Iiwib2ZfbmF0aXZlaW50Iiwib2ZfbmF0aXZlaW50X2V4biIsInRvX25hdGl2ZWludCIsIm1heF92YWx1ZV8zMF9iaXRzIiwiYWJzIiwicmVtIiwiaW5jciIsImRlY3IiLCJzaGlmdF9yaWdodF9sb2dpY2FsIiwic2hpZnRfbGVmdCIsImJpdF9ub3QiLCJiaXRfb3IiLCJiaXRfYW5kIiwiYml0X3hvciIsInBvdyIsIm5vbl9wb3NpdGl2ZV9hcmd1bWVudCIsImNlaWxfcG93MiIsIngkMyIsIngkNCIsIngkNSIsIngkNiIsImZsb29yX3BvdzIiLCJpc19wb3cyIiwiZmxvb3JfbG9nMiIsImNlaWxfbG9nMiIsInBvcGNvdW50IiwiZnVuYyQxIiwiY2x6IiwibG5vdCIsInNpemUiLCJzdGFja19vcl9oZWFwX29mX3NleHAiLCJzZXhwX29mX3N0YWNrX29yX2hlYXAiLCJjb21wYXJlX3N0YWNrX29yX2hlYXAiLCJzdGFja19vcl9oZWFwIiwicmVwciIsInplcm9fb2JqIiwiY3JlYXRlX3plcm8iLCJ1bnNhZmVfZ2V0IiwidW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5Iiwib2JqIiwic2V0X3dpdGhfY2FtbF9tb2RpZnkiLCJ1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW4iLCJvbGRfb2JqIiwidW5zYWZlX3NldCIsInVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZSIsInVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5XyIsInVuc2FmZV9zZXRfaW50IiwidW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIiLCJ1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQiLCJjcmVhdGVfb2JqX2FycmF5IiwidW5zYWZlX2dldF9sb2NhbCIsInVuc2FmZV90b19hcnJheV9pbnBsYWNlX3Byb21pcyIsInRvdGFsX2xlbiIsInNvX2ZhciIsInJpZ2h0X2lkeCIsImxlZnRfaWR4IiwiZGF0YSIsInRyaW0iLCJncmFtbWFyIiwibW9kdWxlX25hbWUkNCIsInRvX3N0cmluZ19pbnRlcm5hbCIsInN1Y2NfZXhuIiwibXNnIiwicHJlZF9leG4iLCJvZl9zY2FsYXIiLCJvZl9zY2FsYXJfZXhuIiwidG9fc2NhbGFyIiwidG9fY2hhciIsInRvX2NoYXJfZXhuIiwiaXNfdmFsaWQkMCIsImJ5dGVzX2NvbnN1bWVkIiwidWNoYXJfb3JfcmVwbGFjZW1lbnRfY2hhciIsInVjaGFyX2V4biIsIm9mX3N0cmluZ19tZXNzYWdlIiwiZGVjb2RlX2xlbiIsImdldF9kZWNvZGVfcmVzdWx0JDAiLCJnZXRfZGVjb2RlX3Jlc3VsdCQxIiwiZ2V0X2RlY29kZV9yZXN1bHQkMiIsImdldF9kZWNvZGVfcmVzdWx0JDMiLCJyZWZsIiwic3ltIiwidHJhbnMiLCJjb252IiwiZGV0dXBsZTIiLCJ0dXBsZTIiLCJhcmcxXzAxNCIsImFyZzBfMDEzIiwicmVzMF8wMTUiLCJyZXMxXzAxNiIsImFyZ3MiLCJ1aWQiLCJBIiwidG9fc2V4cCIsInNhbWVfd2l0bmVzcyIsIkIiLCJzYW1lX3dpdG5lc3NfZXhuIiwic2FtZSIsIlQwIiwiaWRfbmFtZSIsImlkX3NleHAiLCJ0eXBlX2VxdWFsIiwib3RoZXJrZXkiLCJ0eXBlX2VxdWFsX2lkIiwiQyIsInR5cGVfa2V5IiwiY2tleSIsImJrZXkiLCJha2V5Iiwibm9uZV9zdWJzdGl0dXRlIiwibm9uZSIsInZhbHVlX3Vuc2FmZSIsIm9mX3NleHBhYmxlIiwidG9fc2V4cGFibGUiLCJ4XzAwMyIsIm9mX2FfMDA0IiwieF8wMDUiLCJpbml0X3NvbWUiLCJnZXRfbG9jYWwiLCJnZXRfc29tZV9leG4iLCJpc19ub25lJDAiLCJpc19zb21lJDAiLCJzZXRfc29tZSIsInNldF9ub25lIiwidW5zYWZlX2dldF9zb21lX2V4biIsInVuc2FmZV9nZXRfc29tZV9hc3N1bWluZ19zb21lIiwidW5zYWZlX2lzX3NvbWUiLCJ1bnNhZmVfc2V0X3NvbWUiLCJ1bnNhZmVfc2V0X25vbmUiLCJjbGVhciIsImVsZW0iLCJtYXBfc29tZSIsIm9mX2FycmF5X3NvbWUiLCJjYXBhY2l0eSIsImVsdHMiLCJsZW5ndGhfMDAzIiwiZWx0c18wMDUiLCJhcmdfMDA2IiwiYm5kc18wMDIiLCJhcmdfMDA0IiwiYm5kc18wMDIkMCIsInJlc2l6ZSIsInNldF9jYXBhY2l0eSIsIm5ld19jYXBhY2l0eSIsIm5ld19jYXBhY2l0eSQwIiwicHVzaCIsInBvcF9ub25lbXB0eSIsInBvcF9lcnJvciIsInBvcCIsInBvcF9leG4iLCJ0b3Bfbm9uZW1wdHkiLCJ0b3BfZXJyb3IiLCJ0b3AiLCJ0b3BfZXhuIiwidW50aWxfZW1wdHkiLCJ0X3Jlc3VsdCIsImZpbHRlcl9pbnBsYWNlIiwid3JpdGVfaW5kZXgiLCJyZWFkX2luZGV4IiwiaGFzaF9vdmVycmlkZSIsIm9mX3BvcyIsIm9mX3NpZ24iLCJ0b19zaWduX2V4biIsInRvX2ludF9leG4iLCJlcnJvcl9zb3VyY2VfMDA2IiwiZXJyb3Jfc291cmNlXzAzMyIsImludGVydmFsX2NvbXBhcmlzb25fc2V4cF9ncmFtbSIsImFsbF9vZl9hIiwiZW51bWVyYXRlXzAwMiIsImVudW1lcmF0ZV8wMDEiLCJhY2MkMiIsIm9mX2FfMDAzIiwic2V4cF8wMDgiLCJ0YWdfMDA5Iiwic2V4cF9hcmdzXzAxMCIsImFyZzBfMDExIiwic2V4cF9hcmdzXzAxNSIsImFyZzBfMDE2IiwiYXJnMF8wMjAiLCJyZXMwXzAyMSIsImFyZ18wMjkiLCJhcmdfMDMwIiwiaW50ZXJ2YWxfY29tcGFyaXNvbl9vZl9zZXhwIiwic2V4cF8wMzQiLCJzZXhwX29mX2ludGVydmFsX2NvbXBhcmlzb24iLCJjb21wYXJlX2ludGVydmFsX2NvbXBhcmlzb25fbG8iLCJjb21wYXJlX2ludGVydmFsX2NvbXBhcmlzb24iLCJoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImhhc2hfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImluY2wiLCJleGNsIiwiaXNfbG93ZXJfYm91bmQiLCJpc191cHBlcl9ib3VuZCIsImJvdW5kc19jcm9zc2VkIiwibG93ZXIiLCJ1cHBlciIsImxvd2VyJDAiLCJ1cHBlciQwIiwiY29tcGFyZV90b19pbnRlcnZhbF9leG4iLCJpbnRlcnZhbF9jb250YWluc19leG4iLCJyaWdodF8wMDQiLCJsZWZ0XzAwMyIsInJpZ2h0XzAwOCIsImxlZnRfMDA3Iiwib2ZfYV8wMDkiLCJ2XzAxMCIsImNtcF9rIiwiY21wX3YiLCJ0XzAxNCIsInRfMDEzIiwidF8wMTYiLCJ0XzAxNSIsInJpZ2h0XzAxOCIsImxlZnRfMDE3IiwicmlnaHRfMDIyIiwibGVmdF8wMjEiLCJ0XzAyNCIsInRfMDIzIiwidF8wMjYiLCJ0XzAyNSIsInJpZ2h0XzAyMCIsImxlZnRfMDE5IiwidF8wMzAiLCJ0XzAyOSIsInRfMDMyIiwidF8wMzEiLCJyaWdodF8wMzQiLCJsZWZ0XzAzMyIsInJpZ2h0XzAzOCIsImxlZnRfMDM3IiwidF8wNDAiLCJ0XzAzOSIsInRfMDQyIiwidF8wNDEiLCJyaWdodF8wMzYiLCJsZWZ0XzAzNSIsIm9mX2tfMDQzIiwib2Zfdl8wNDQiLCJzZXhwXzA3MSIsImFyZzFfMDY4IiwicmVzMF8wNjkiLCJhdG9tXzA0NyIsInNleHBfYXJnc18wNTAiLCJhdG9tXzA0NyQwIiwiYXJnMF8wNTgiLCJhcmcxXzA1MyIsImFyZzBfMDUyIiwicmVzMF8wNTQiLCJyZXMxXzA1NSIsInJlczBfMDU5IiwiYXJnMF8wNjEiLCJyZXMwXzA2MiIsImFyZzBfMDY0IiwicmVzMF8wNjUiLCJyZXMxXzA3MCIsIm9mX2tfMDcyIiwib2Zfdl8wNzMiLCJhcmcxXzA4MiIsImFyZzBfMDgxIiwidl8wNzQiLCJyZXMxXzA4NCIsInZfMDc2IiwiYXJnMV8wNzgiLCJhcmcwXzA3NyIsInJlczBfMDc5IiwicmVzMV8wODAiLCJ2XzA3NSIsImtfc2V4cF9ncmFtbWFyIiwidl9zZXhwX2dyYW1tYXIiLCJjbXBfbGVmdCIsImNtcF9yaWdodCIsImFfMDg1IiwiYl8wODYiLCJyaWdodF8wOTIiLCJsZWZ0XzA5MSIsInRfMDk0IiwidF8wOTMiLCJ0XzA5NiIsInRfMDk1IiwicmlnaHRfMDg4IiwibGVmdF8wODciLCJyaWdodF8wOTAiLCJsZWZ0XzA4OSIsImFfMDk3IiwiYl8wOTgiLCJyaWdodF8xMDQiLCJsZWZ0XzEwMyIsInRfMTA2IiwidF8xMDUiLCJ0XzEwOCIsInRfMTA3IiwicmlnaHRfMTAwIiwibGVmdF8wOTkiLCJyaWdodF8xMDIiLCJsZWZ0XzEwMSIsIm9mX2xlZnRfMTA5Iiwib2ZfcmlnaHRfMTEwIiwidl8xMTMiLCJhcmcxXzExNSIsImFyZzBfMTE0IiwicmVzMF8xMTYiLCJyZXMxXzExNyIsInZfMTExIiwidl8xMTIiLCJzZXhwX29mX3QkMyIsImhlaWdodCIsImluX3JhbmdlIiwiaGwiLCJociIsImxvd2VyJDEiLCJpbnZhcmlhbnRzIiwic2wiLCJzciIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayIsImtsIiwiayQxIiwia2wkMCIsImskMiIsImtyIiwibGVmdF9sZW5ndGgiLCJyaWdodF9sZW5ndGgiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIiwiYXJyYXlfbGVuZ3RoIiwib2Zfc29ydGVkX2FycmF5IiwiaW5jcmVhc2luZyIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiQwIiwibHJsIiwibHJ2IiwicnIiLCJydiIsInJsIiwicmxyIiwicmx2JDAiLCJybGwiLCJybHYiLCJhdXgiLCJhZGRfbWluIiwiYWRkX21heCIsImxoIiwibHYkMCIsInJoIiwicnYkMCIsIm1pbl9lbHRfZXhuIiwiZm9sZF91bnRpbF9oZWxwZXIiLCJ2YWx1ZSQwIiwibWF4X2VsdF9leG4iLCJyZW1vdmVfbWluX2VsdCIsIm1heWJlX2VsdCIsIm1heWJlX2VsdCQwIiwic3BsaXRfbGVfZ3QiLCJzcGxpdF9sdF9nZSIsImVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3RpbyIsInJlbW92ZV9pbmRleCIsImxfc2l6ZSIsInVuaW9uIiwidjEkMCIsInYyIiwidjIkMCIsInIyJDAiLCJyMSQwIiwidjEiLCJ1bmlvbl9saXN0IiwidG9fdHJlZSIsImludGVyIiwib3RoZXJfc2V0IiwiZSQxIiwiY29uc19yaWdodCIsIm9mX3NldCIsImVudW0kMCIsInRyZWUiLCJzeW1tZXRyaWNfZGlmZiIsImVsdCQwIiwiZW51bTEiLCJ0cmVlMSIsImVudW0yIiwidHJlZTIiLCJuZXh0X3N0YXRlIiwiZ3JlYXRlcl9vcl9lcXVhbF90byIsImxlc3Nfb3JfZXF1YWxfdG8iLCJpbmNsdXNpdmVfYm91bmQiLCJzaWRlIiwibWF5YmUiLCJ2JDEiLCJ2JDIiLCJ2JDMiLCJ2JDQiLCJlJDIiLCJtZXJnZV90b19zZXF1ZW5jZSIsImUyJDIiLCJlMSQyIiwiZTIkMCIsImUxJDAiLCJlMiQxIiwiZTEkMSIsInQyJDIiLCJ0MSQyIiwiaXNfc3Vic2V0IiwiYXJlX2Rpc2pvaW50IiwiZmlsdCIsImtlZXBfdiIsImxfZiIsImxfdCIsImtlZXBfdl90Iiwicl9mIiwicl90IiwibWsiLCJlbGVtZW50c19hdXgiLCJlbGVtZW50cyIsImNob29zZSIsImNob29zZV9leG4iLCJwb3NfcmVmIiwiZ3JvdXBfYnkiLCJlcXVpdiIsImVxdWl2X2NsYXNzZXMiLCJub3RfZXF1aXZfeCIsImVxdWl2X3giLCJlcXVpdl9jbGFzc2VzJDAiLCJzdGFibGVfZGVkdXBfbGlzdCIsImxlZnRvdmVycyIsImFscmVhZHlfc2VlbiIsImFscmVhZHlfc2VlbiQwIiwibGVmdG92ZXJzJDAiLCJ0X29mX3NleHBfZGlyZWN0IiwiZWx0X2xzdCIsImVsX3NleHAiLCJlbCIsImlzX3N1YnNldCQwIiwic3Vic2V0Iiwic3VwZXJzZXQiLCJzZXhwX29mX2VsdCIsImludmFsaWRfZWxlbWVudHMiLCJpbnZhbGlkX2VsZW1lbnRzX3NleHAiLCJsaWtlIiwibGlrZV9tYXliZV9ub19vcCIsIm9sZF90Iiwib2xkX3RyZWUiLCJjb21wYXJhdG9yX3MiLCJpbnZhcmlhbnRzJDAiLCJlbGVtZW50cyQwIiwibWluX2VsdF9leG4kMCIsIm1heF9lbHRfZXhuJDAiLCJjaG9vc2UkMCIsImNob29zZV9leG4kMCIsImZvbGRfcmlnaHQkMCIsIml0ZXIyJDAiLCJmaWx0ZXIkMCIsImFkZCQwIiwicmVtb3ZlJDAiLCJ1bmlvbiQwIiwiaW50ZXIkMCIsImRpZmYkMCIsInN5bW1ldHJpY19kaWZmJDAiLCJjb21wYXJlX2RpcmVjdCIsImlzX3N1YnNldCQxIiwib2YiLCJhcmVfZGlzam9pbnQkMCIsInRvX25hbWVkX3RyZWUiLCJuYW1lZCIsImlzX3N1YnNldCQyIiwicGFydGl0aW9uX3RmJDAiLCJ0cmVlX2YiLCJ0cmVlX3QiLCJzcGxpdF9sZV9ndCQwIiwic3BsaXRfbHRfZ2UkMCIsImdyb3VwX2J5JDAiLCJudGgkMCIsInJlbW92ZV9pbmRleCQwIiwidG9fc2VxdWVuY2UkMCIsImJpbmFyeV9zZWFyY2gkMCIsImJpbmFyeV9zZWFyY2hfc2VnbWVudGVkJDAiLCJtZXJnZV90b19zZXF1ZW5jZSQwIiwiaGFzaF9mb2xkX2RpcmVjdCIsInRfb2Zfc2V4cF9kaXJlY3QkMCIsImludmFyaWFudHMkMSIsImlzX2VtcHR5JDEiLCJlbGVtZW50cyQxIiwibWluX2VsdCQxIiwibWluX2VsdF9leG4kMSIsIm1heF9lbHQkMSIsIm1heF9lbHRfZXhuJDEiLCJjaG9vc2UkMSIsImNob29zZV9leG4kMSIsInRvX2xpc3QkMSIsInRvX2FycmF5JDEiLCJpdGVyJDIiLCJleGlzdHMkMSIsImZvcl9hbGwkMSIsImNvdW50JDEiLCJzdW0kMSIsImZpbmQkMSIsImZpbmRfZXhuJDEiLCJmaW5kX21hcCQxIiwiZm9sZCQxIiwiZm9sZF91bnRpbCQxIiwiZm9sZF9yaWdodCQxIiwiZmlsdGVyJDEiLCJmaWx0ZXJfbWFwJDAiLCJwYXJ0aXRpb25fdGYkMSIsIml0ZXIyJDEiLCJtZW0kMSIsImFkZCQxIiwicmVtb3ZlJDEiLCJ1bmlvbiQxIiwiaW50ZXIkMSIsImRpZmYkMSIsInN5bW1ldHJpY19kaWZmJDEiLCJjb21wYXJlX2RpcmVjdCQwIiwiaXNfc3Vic2V0JDMiLCJhcmVfZGlzam9pbnQkMSIsIm9mX3NlcXVlbmNlJDAiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDAiLCJvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2skMCIsIm9mX3NvcnRlZF9hcnJheSQwIiwidW5pb25fbGlzdCQwIiwic3RhYmxlX2RlZHVwX2xpc3QkMCIsImdyb3VwX2J5JDEiLCJzcGxpdCQxIiwic3BsaXRfbGVfZ3QkMSIsInNwbGl0X2x0X2dlJDEiLCJudGgkMSIsInJlbW92ZV9pbmRleCQxIiwib2ZfdHJlZSIsInRvX3NlcXVlbmNlJDEiLCJiaW5hcnlfc2VhcmNoJDEiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQxIiwibWVyZ2VfdG9fc2VxdWVuY2UkMSIsImlzX3N1YnNldCQ0IiwidG9fdHJlZSQwIiwib2ZfdHJlZSQwIiwidF9vZl9zZXhwX2RpcmVjdCQxIiwiZW1wdHkkMCIsInNpbmdsZXRvbiQwIiwidW5pb25fbGlzdCQxIiwib2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCQxIiwib2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrJDEiLCJvZl9zb3J0ZWRfYXJyYXkkMSIsIm9mX2xpc3QkMSIsIm9mX3NlcXVlbmNlJDEiLCJvZl9hcnJheSQxIiwic3RhYmxlX2RlZHVwX2xpc3QkMSIsImZpbHRlcl9tYXAkMSIsInRvX2NvbXBhcmF0b3IiLCJlbXB0eSQxIiwic2luZ2xldG9uJDEiLCJ1bmlvbl9saXN0JDIiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkJDIiLCJvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2skMiIsIm9mX3NvcnRlZF9hcnJheSQyIiwib2ZfbGlzdCQyIiwib2Zfc2VxdWVuY2UkMiIsIm9mX2FycmF5JDIiLCJzdGFibGVfZGVkdXBfbGlzdCQyIiwiZmlsdGVyX21hcCQyIiwib2ZfdHJlZSQxIiwic2V4cF9vZl9tX3QiLCJFbHQiLCJtX3Rfb2Zfc2V4cCIsIm1fdF9zZXhwX2dyYW1tYXIiLCJjb21wYXJlX21fdCIsImVxdWFsX21fdCIsImhhc2hfZm9sZF9tX3QiLCJoYXNoX21fdCIsImNvbXBhcmF0b3IkMCIsImVtcHR5JDIiLCJzaW5nbGV0b24kMiIsInVuaW9uX2xpc3QkMyIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkMyIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQzIiwib2Zfc29ydGVkX2FycmF5JDMiLCJvZl9saXN0JDMiLCJvZl9zZXF1ZW5jZSQzIiwib2ZfYXJyYXkkMyIsInN0YWJsZV9kZWR1cF9saXN0JDMiLCJtYXAkMyIsImZpbHRlcl9tYXAkMyIsIm9mX3RyZWUkMiIsInRvX3RyZWUkMSIsInJlcGxhY2UiLCJzZXRfdGVtcG9yYXJpbHkiLCJyZXN0b3JlX3RvIiwic2V0cyIsInNuYXBzaG90Iiwic2V0c190ZW1wb3JhcmlseSIsImFuZF92YWx1ZXMiLCJpbmNfbnVtX211dGF0aW9ucyIsImVsdHNfaW5kZXgiLCJjaGVja19pbmRleF9leG4iLCJlbnN1cmVfbm9fbXV0YXRpb24iLCJudW1fbXV0YXRpb25zIiwibnVtX211dGF0aW9uc18wMDMiLCJmcm9udF8wMDUiLCJtYXNrXzAwNyIsImxlbmd0aF8wMDkiLCJlbHRzXzAxMSIsImFyZ18wMTIiLCJibmRzXzAwMiQxIiwiYm5kc18wMDIkMiIsImJuZHNfMDAyJDMiLCJtdXQyIiwibXV0MSIsImZyb250IiwiY2FwYWNpdHkkMCIsImNhcGFjaXR5JDEiLCJibGl0X3RvX2FycmF5IiwiZnJvbnRfbGVuIiwicmVzdF9sZW4iLCJzZXRfY2FwYWNpdHlfaW50ZXJuYWwiLCJkZXNpcmVkX2NhcGFjaXR5IiwiZW5xdWV1ZSIsImVucXVldWVfZnJvbnQiLCJkZXF1ZXVlX25vbmVtcHR5IiwiYmFja19pbmRleCIsImRlcXVldWVfYmFja19ub25lbXB0eSIsImJhY2siLCJkZXF1ZXVlX2V4biIsImRlcXVldWUiLCJkZXF1ZXVlX2FuZF9pZ25vcmVfZXhuIiwiZGVxdWV1ZV9iYWNrX2V4biIsImRlcXVldWVfYmFjayIsImZyb250X25vbmVtcHR5IiwiYmFja19ub25lbXB0eSIsImxhc3Rfbm9uZW1wdHkiLCJwZWVrX2V4biIsInBlZWtfYmFjayIsInBlZWtfYmFja19leG4iLCJkcmFpbiIsIndoaWxlJDAiLCJibGl0X3RyYW5zZmVyIiwibGVuJDEiLCJkc3Rfc3RhcnQiLCJzcmNfaSIsImRzdF9pIiwiZW5xdWV1ZV9hbGwiLCJmaWx0ZXJpX2lucGxhY2UiLCJxIiwiYXNzZXJ0X25vX211dGF0aW9uX3NpbmNlX3N0YXJ0IiwidW5yZWFjaGFibGVfY29kZV9sb2NhbCIsInVucmVhY2hhYmxlX2NvZGUiLCJtdXN0X2JlX25vbmUiLCJtdXN0X2JlX2VtcHR5IiwibXVzdF9iZV9vayIsIm11c3RfYmVfZXJyb3IiLCJtdXN0X2JlX2ZpcnN0IiwibXVzdF9iZV9zZWNvbmQiLCJ6ZXJvJDAiLCJ6ZXJvJDEiLCJ0b19pbnRfdHJ1bmMiLCJvZl9pbnQ2NF90cnVuYyIsIm5hbWUkMCIsIm9mX2NvbnRpbnVlX29yX3N0b3AiLCJ0b19jb250aW51ZV9vcl9zdG9wIiwibGVmdF92YWx1ZSIsInJpZ2h0X3ZhbHVlIiwidmFsdWVzIiwibGVmdF9kZWZhdWx0IiwicmlnaHRfZGVmYXVsdCIsInJpZ2h0JDAiLCJjb21wYXJlX2tleSIsImNyZWF0ZV93aXRoX2hlaWdodHMiLCJ2bCIsInZsJDAiLCJ2ciIsImswIiwiazEiLCJsZCIsImxyZCIsImxyZCQwIiwicmQiLCJybGQiLCJybGQkMCIsInJhaXNlX2tleV9hbHJlYWR5X3ByZXNlbnQiLCJzZXhwX29mX2tleSIsImZpbmRfYW5kX2FkZF9vcl9zZXQiLCJhZGRfb3Jfc2V0IiwiZCQwIiwibGVuZ3RoJDIiLCJzZXRfbWluIiwic2V0X21heCIsImFkZF9leG4iLCJhZGRfZXhuX2ludGVybmFsIiwibWF4X2tleSIsImFkZF91bmNoZWNrZWQiLCJ0b190cmVlX3VuY2hlY2tlZCIsInRhaWwkMCIsInRhaWwkMSIsImQxIiwiZDIiLCJrMiIsInRhaWwkMiIsImQxJDAiLCJrMSQwIiwiZDIkMCIsImsyJDAiLCJkMyIsImszIiwibnIiLCJubCIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UiLCJidWlsZGVyIiwicHJldl9rZXkiLCJsZCQwIiwibGskMCIsInJrIiwicmQkMCIsInJrJDAiLCJsayIsImNtcCQwIiwibWF5YmUkMCIsInNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSIsImludG8iLCJib3VuZGFyeV9vcHQiLCJzcGxpdF9yYW5nZSIsIm1pZF9hbmRfcmlnaHQiLCJsYiQxIiwibGIkMiIsIm1pZF9hbmRfcmlnaHQkMCIsImxiIiwibGIkMCIsIm1pZCQwIiwiYWRkX211bHRpIiwiZGF0YSQwIiwiZmluZF9tdWx0aSIsImxvd2VyX3BhcnQiLCJ1cHBlcl9wYXJ0IiwibWluX3VwcGVyIiwibWF4X2xvd2VyIiwidXBwZXJfcGFydF93aXRob3V0X21pbiIsImdvIiwiY19taW4iLCJjX21heCIsImluaXQkMiIsImZvbGRfcmFuZ2VfaW5jbHVzaXZlIiwicmFuZ2VfdG9fYWxpc3QiLCJjb25jYXRfdW5jaGVja2VkIiwiY29uY2F0X2FuZF9iYWxhbmNlX3VuY2hlY2tlZCIsImNoYW5nZSIsImQkMSIsImxlbmd0aCQzIiwidXBkYXRlIiwicmVtb3ZlX211bHRpIiwibm9uX2VtcHR5X3RhaWwiLCJpdGVyX2tleXMiLCJpdGVyaV91bnRpbF9sb29wIiwiaXRlcmlfdW50aWwiLCJmb2xkX3VudGlsX2xvb3AiLCJmaW5hbCQxIiwiZmluYWwkMCIsIm5ld19kYXRhIiwibmV3X2RhdGEkMCIsIm5ld19kYXRhJDEiLCJrZWVwX2RhdGEiLCJmaWx0ZXJfa2V5cyIsImtlZXBfZGF0YV90Iiwic3RlcF9kZWVwZXJfZXhuIiwiZHJvcF9waHlzX2VxdWFsX3ByZWZpeCIsImFjYzEiLCJhY2MyIiwidHJlZTEkMCIsImFjYzEkMCIsInRyZWUyJDAiLCJhY2MyJDAiLCJhY2MxJDEiLCJ0cmVlMSQxIiwiYWNjMiQxIiwidHJlZTIkMSIsImFjYzIkMiIsInRyZWUyJDIiLCJhY2MxJDIiLCJ0cmVlMSQyIiwiY3VyciIsIm5leHQkMSIsImRhdGFfZXF1YWwiLCJrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8iLCJrZXlzX2xlc3Nfb3JfZXF1YWxfdG8iLCJkJDIiLCJjb21wYXJlX2RhdGEiLCJmb2xkMiQwIiwiZm9sZF9zeW1tZXRyaWNfZGlmZiIsImRlbHRhIiwiYWNjJDMiLCJhY2MkNCIsImFjYyQ1IiwiYWNjJDYiLCJhY2MkNyIsInJpZ2h0JDEiLCJlbnVtMiQwIiwiZW51bTEkMCIsImtleXMiLCJvZl9mb2xkYWJsZSIsImZvbGRhYmxlIiwicHJldl9kYXRhIiwib2ZfZm9sZGFibGVfZm9sZCIsIm9mX2ZvbGRhYmxlX3JlZHVjZSIsIm9mX2ZvbGRhYmxlJDAiLCJvZl9mb2xkYWJsZV9vcl9lcnJvciIsIm9mX2ZvbGRhYmxlX2V4biIsIm9mX2ZvbGRhYmxlX211bHRpIiwib2ZfYWxpc3RfZm9sZCIsIm9mX2FsaXN0X3JlZHVjZSIsIm9mX2FsaXN0Iiwib2ZfYWxpc3Rfb3JfZXJyb3IiLCJvZl9hbGlzdF9leG4iLCJvZl9hbGlzdF9tdWx0aSIsImZvbGQkMiIsIm9mX3NlcXVlbmNlX2ZvbGQiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UiLCJvZl9zZXF1ZW5jZV9vcl9lcnJvciIsIm9mX3NlcXVlbmNlX2V4biIsIm9mX3NlcXVlbmNlX211bHRpIiwib2ZfbGlzdF93aXRoX2tleSIsImdldF9rZXkiLCJuZXdfbGVuZ3RoIiwib2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciIsIm9mX2xpc3Rfd2l0aF9rZXlfZXhuIiwib2ZfbGlzdF93aXRoX2tleV9tdWx0aSIsIm9mX2xpc3Rfd2l0aF9rZXlfZm9sZCIsIm9mX2xpc3Rfd2l0aF9rZXlfcmVkdWNlIiwic3VtaSIsInRvX2FsaXN0Iiwia2V5X29yZGVyIiwibWVyZ2VfbGFyZ2VfZmlyc3QiLCJsZW5ndGhfbGFyZ2UiLCJ0X2xhcmdlIiwidF9zbWFsbCIsIm1lcmdlX3NrZXdlZCIsImxlbmd0aDEiLCJsZW5ndGgyIiwibWVyZ2VfZGlzam9pbnRfZXhuIiwicmVwYWNrYWdlIiwibWFya2VyIiwiY2xvc2VzdF9rZXkiLCJmb3VuZF9tYXJrZXIiLCJmb3VuZF9rZXkiLCJmb3VuZF92YWx1ZSIsImZvdW5kX3ZhbHVlJDAiLCJmb3VuZF9rZXkkMCIsInJhbmsiLCJudW1fdG9fc2VhcmNoIiwicGFpciIsInBhaXIkMCIsImJpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kIiwibWF5YmVfYm91bmQiLCJpZl9leGNsdXNpdmUiLCJpZl9pbmNsdXNpdmUiLCJmaW5kX2JvdW5kIiwiYm91bmQkMCIsImJpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kcyIsImxvd2VyX2JvdW5kJDAiLCJ1cHBlcl9ib3VuZCQwIiwib2ZfaXRlcmkiLCJvZl9pdGVyaV9leG4iLCJrZXlfb2Zfc2V4cCIsInZhbHVlX29mX3NleHAiLCJhbGlzdF9zZXhwcyIsImZvdW5kX2ZpcnN0X2siLCJrMl9zZXhwIiwic2V4cF9vZl92YWx1ZSIsImVycm9ycyIsIm9rcyIsIm1hcF9rZXlzIiwibWFwX2tleXNfZXhuIiwidHJhbnNwb3NlX2tleXMiLCJvdXRlcl9jb21wYXJhdG9yIiwiaW5uZXJfY29tcGFyYXRvciIsIm91dGVyX3QiLCJvdXRlcl9rZXkiLCJpbm5lcl90IiwiaW5uZXJfa2V5IiwiYWNjX2xlbiIsImVsdF9sZW4iLCJ0cmVlX2ZpbHRlcl9tYXBpIiwicl9sZW4iLCJsX2xlbiIsIndpdGhfc2FtZV9sZW5ndGgiLCJvZl9saWtlX3RyZWUiLCJvZl9saWtlX3RyZWVfbWF5YmVfbm9fb3AiLCJhZGRfZXhuJDAiLCJhZGRfbXVsdGkkMCIsInJlbW92ZV9tdWx0aSQwIiwiZmluZF9tdWx0aSQwIiwiY2hhbmdlJDAiLCJ1cGRhdGUkMCIsIml0ZXJfa2V5cyQwIiwiaXRlcmlfdW50aWwkMCIsImZvbGQkMyIsImZvbGQyJDEiLCJmaWx0ZXJfa2V5cyQwIiwiZmlsdGVyaSQwIiwiZmlsdGVyX21hcGkkMCIsIm9mX2xpa2VfdHJlZTIiLCJvZl9saWtlX3RyZWUyX21heWJlX25vX29wIiwicGFydGl0aW9uX21hcGkkMCIsInBhcnRpdGlvbl9tYXAkMCIsInBhcnRpdGlvbmlfdGYkMCIsImNvbWJpbmVfZXJyb3JzJDAiLCJ1bnppcCQwIiwia2V5cyQwIiwidG9fYWxpc3QkMCIsImZvbGRfc3ltbWV0cmljX2RpZmYkMCIsIm1lcmdlJDAiLCJtZXJnZV9kaXNqb2ludF9leG4kMCIsIm1lcmdlX3NrZXdlZCQwIiwic3VtaSQwIiwiYm90aF9sZW4iLCJzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkkMCIsInN1YnJhbmdlIiwiaF9sIiwiaF9yIiwib3V0ZXJfam9pbmVkX2hlaWdodCIsIm1pZF9sZW5ndGgiLCJhcHBlbmQkMCIsImZvbGRfcmFuZ2VfaW5jbHVzaXZlJDAiLCJyYW5nZV90b19hbGlzdCQwIiwiY2xvc2VzdF9rZXkkMCIsInJhbmskMCIsInNleHBfb2ZfayIsInNleHBfb2ZfdiIsImhhc2hfZm9sZF9rZXkiLCJoYXNoX2ZvbGRfZGF0YSIsImJpbmFyeV9zZWFyY2hfc3VicmFuZ2UiLCJuZXdfdHJlZSIsIm5ld190cmVlX3dpdGhfbGVuZ3RoIiwib2ZfYWxpc3QkMCIsIm9mX2FsaXN0X29yX2Vycm9yJDAiLCJvZl9hbGlzdF9leG4kMCIsIm9mX2FsaXN0X211bHRpJDAiLCJvZl9hbGlzdF9mb2xkJDAiLCJvZl9hbGlzdF9yZWR1Y2UkMCIsIm9mX2l0ZXJpJDAiLCJvZl9pdGVyaV9leG4kMCIsInJlcXVpcmVkX2J5X2ludGYiLCJvZl9pbmNyZWFzaW5nX3NlcXVlbmNlJDAiLCJvZl9zZXF1ZW5jZV9vcl9lcnJvciQwIiwib2Zfc2VxdWVuY2VfZXhuJDAiLCJvZl9zZXF1ZW5jZV9tdWx0aSQwIiwib2Zfc2VxdWVuY2VfZm9sZCQwIiwib2Zfc2VxdWVuY2VfcmVkdWNlJDAiLCJvZl9saXN0X3dpdGhfa2V5JDAiLCJvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yJDAiLCJvZl9saXN0X3dpdGhfa2V5X2V4biQwIiwib2ZfbGlzdF93aXRoX2tleV9tdWx0aSQwIiwib2ZfbGlzdF93aXRoX2tleV9mb2xkJDAiLCJvZl9saXN0X3dpdGhfa2V5X3JlZHVjZSQwIiwiYWRkX2V4biQxIiwiYWRkX211bHRpJDEiLCJyZW1vdmVfbXVsdGkkMSIsImZpbmRfbXVsdGkkMSIsImNoYW5nZSQxIiwidXBkYXRlJDEiLCJpdGVyX2tleXMkMSIsIml0ZXJpX3VudGlsJDEiLCJtYXBpJDEiLCJmb2xkJDQiLCJmb2xkMiQyIiwiZmlsdGVyX2tleXMkMSIsImZpbHRlcmkkMSIsImZpbHRlcl9tYXBpJDEiLCJwYXJ0aXRpb25fbWFwaSQxIiwicGFydGl0aW9uX21hcCQxIiwicGFydGl0aW9uaV90ZiQxIiwiY29tYmluZV9lcnJvcnMkMSIsImtleXMkMSIsImRhdGEkMSIsInRvX2FsaXN0JDEiLCJmb2xkX3N5bW1ldHJpY19kaWZmJDEiLCJtZXJnZSQxIiwibWVyZ2VfZGlzam9pbnRfZXhuJDEiLCJtZXJnZV9za2V3ZWQkMSIsImZvcl9hbGxpJDEiLCJleGlzdHNpJDEiLCJjb3VudGkkMSIsInN1bWkkMSIsImFwcGVuZCQxIiwic3VicmFuZ2UkMCIsImZvbGRfcmFuZ2VfaW5jbHVzaXZlJDEiLCJyYW5nZV90b19hbGlzdCQxIiwiY2xvc2VzdF9rZXkkMSIsIm50aCQyIiwibnRoX2V4biQwIiwicmFuayQxIiwia19vZl9zZXhwIiwidl9vZl9zZXhwIiwiYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSQwIiwibWFwX2tleXMkMCIsImR1cCIsIm1hcF9rZXlzX2V4biQwIiwidHJhbnNwb3NlX2tleXMkMCIsImFkZF9leG4kMiIsIm9mX3RyZWUwIiwib2ZfYWxpc3QkMSIsIm9mX2FsaXN0X29yX2Vycm9yJDEiLCJvZl9hbGlzdF9leG4kMSIsIm9mX2FsaXN0X211bHRpJDEiLCJvZl9hbGlzdF9mb2xkJDEiLCJvZl9hbGlzdF9yZWR1Y2UkMSIsIm9mX2l0ZXJpJDEiLCJ0cmVlX2xlbmd0aCIsIm9mX2l0ZXJpX2V4biQxIiwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSQxIiwib2Zfc2VxdWVuY2Vfb3JfZXJyb3IkMSIsIm9mX3NlcXVlbmNlX2V4biQxIiwib2Zfc2VxdWVuY2VfbXVsdGkkMSIsIm9mX3NlcXVlbmNlX2ZvbGQkMSIsIm9mX3NlcXVlbmNlX3JlZHVjZSQxIiwib2ZfbGlzdF93aXRoX2tleSQxIiwib2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciQxIiwib2ZfbGlzdF93aXRoX2tleV9leG4kMSIsIm9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkkMSIsIm9mX2xpc3Rfd2l0aF9rZXlfZm9sZCQxIiwib2ZfbGlzdF93aXRoX2tleV9yZWR1Y2UkMSIsIm1hcF9rZXlzJDEiLCJtYXBfa2V5c19leG4kMSIsInRyYW5zcG9zZV9rZXlzJDEiLCJvZl90cmVlJDMiLCJvZl9hbGlzdCQyIiwib2ZfYWxpc3Rfb3JfZXJyb3IkMiIsIm9mX2FsaXN0X2V4biQyIiwib2ZfYWxpc3RfbXVsdGkkMiIsIm9mX2FsaXN0X2ZvbGQkMiIsIm9mX2FsaXN0X3JlZHVjZSQyIiwib2ZfaXRlcmkkMiIsIm9mX2l0ZXJpX2V4biQyIiwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSQyIiwib2Zfc2VxdWVuY2Vfb3JfZXJyb3IkMiIsIm9mX3NlcXVlbmNlX2V4biQyIiwib2Zfc2VxdWVuY2VfbXVsdGkkMiIsIm9mX3NlcXVlbmNlX2ZvbGQkMiIsIm9mX3NlcXVlbmNlX3JlZHVjZSQyIiwib2ZfbGlzdF93aXRoX2tleSQyIiwib2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciQyIiwib2ZfbGlzdF93aXRoX2tleV9leG4kMiIsIm9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkkMiIsIm9mX2xpc3Rfd2l0aF9rZXlfZm9sZCQyIiwib2ZfbGlzdF93aXRoX2tleV9yZWR1Y2UkMiIsIm1hcF9rZXlzJDIiLCJtYXBfa2V5c19leG4kMiIsInRyYW5zcG9zZV9rZXlzJDIiLCJLIiwidl9ncmFtbWFyIiwiY29tcGFyZV92IiwiZXF1YWxfdiIsImhhc2hfZm9sZF92Iiwib2ZfdHJlZSQ0IiwiZW1wdHkkMyIsIm9mX2FsaXN0JDMiLCJvZl9hbGlzdF9vcl9lcnJvciQzIiwib2ZfYWxpc3RfZXhuJDMiLCJvZl9hbGlzdF9tdWx0aSQzIiwib2ZfYWxpc3RfZm9sZCQzIiwib2ZfYWxpc3RfcmVkdWNlJDMiLCJvZl9pdGVyaSQzIiwib2ZfaXRlcmlfZXhuJDMiLCJvZl9pbmNyZWFzaW5nX3NlcXVlbmNlJDMiLCJvZl9zZXF1ZW5jZV9vcl9lcnJvciQzIiwib2Zfc2VxdWVuY2VfZXhuJDMiLCJvZl9zZXF1ZW5jZV9tdWx0aSQzIiwib2Zfc2VxdWVuY2VfZm9sZCQzIiwib2Zfc2VxdWVuY2VfcmVkdWNlJDMiLCJvZl9saXN0X3dpdGhfa2V5JDMiLCJvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yJDMiLCJvZl9saXN0X3dpdGhfa2V5X2V4biQzIiwib2ZfbGlzdF93aXRoX2tleV9tdWx0aSQzIiwib2ZfbGlzdF93aXRoX2tleV9mb2xkJDMiLCJvZl9saXN0X3dpdGhfa2V5X3JlZHVjZSQzIiwibWFwX2tleXMkMyIsIm1hcF9rZXlzX2V4biQzIiwidHJhbnNwb3NlX2tleXMkMyIsInRyYW5zZmVyIiwiY2FtbF9pdGVyIiwiY2FtbF9mb2xkIiwicSQwIiwiYnN3YXAxNiIsImJzd2FwMzIiLCJic3dhcDQ4IiwidG9fbmF0aXZlaW50X2V4biIsIndyYXBfZXhuIiwid3JhcF9tb2R1bG8iLCJ1bndyYXAiLCJjdHoiLCJpbnZhbGlkX3N0ciIsIm9mX3N0cmluZ19yYXciLCJzaWduZWRuZXNzIiwicG9zX3N0ciIsImludDYzIiwib25lJDAiLCJ0b19pbnQzMl90cnVuYyIsIm9mX25hdGl2ZWludF90cnVuYyIsInRvX25hdGl2ZWludF90cnVuYyIsInRvX3N0cmluZyQxIiwiZmxvYXRfb2ZfYml0cyIsImJpdHNfb2ZfZmxvYXQiLCJvZl9pbnRfdHJ1bmMiLCJpbmNsdWRlJDAiLCJvZl9mbG9hdCQwIiwidG9fZmxvYXQkMCIsIm9mX2ludF9leG4kMCIsInRvX2ludF9leG4kMCIsInBwJDAiLCJoYXNoYWJsZSQwIiwiaXNfcG9zaXRpdmUkMCIsImlzX25vbl9uZWdhdGl2ZSQwIiwiaXNfbmVnYXRpdmUkMCIsImlzX25vbl9wb3NpdGl2ZSQwIiwic2lnbiQwIiwiaW52YXJpYW50JDAiLCJvZl9zdHJpbmdfb3B0JDAiLCJ0b19zdHJpbmdfaHVtJDAiLCJtaW51c19vbmUkMCIsInJlbSQwIiwicm91bmQkMCIsInJvdW5kX3Rvd2FyZHNfemVybyQwIiwicm91bmRfZG93biQwIiwicm91bmRfdXAkMCIsInJvdW5kX25lYXJlc3QkMCIsInN1Y2MkMCIsInByZWQkMCIsInBvdyQwIiwiYml0X2FuZCQwIiwiYml0X29yJDAiLCJiaXRfeG9yJDAiLCJiaXRfbm90JDAiLCJwb3Bjb3VudCQwIiwic2hpZnRfbGVmdCQwIiwic2hpZnRfcmlnaHQkMCIsImRlY3IkMCIsImluY3IkMCIsIm9mX2ludDMyX2V4biQwIiwidG9faW50MzJfZXhuJDAiLCJvZl9pbnQ2NF9leG4kMCIsInRvX2ludDY0JDAiLCJvZl9uYXRpdmVpbnRfZXhuJDAiLCJ0b19uYXRpdmVpbnRfZXhuJDAiLCJudW1fYml0cyQwIiwibWF4X3ZhbHVlJDAiLCJtaW5fdmFsdWUkMCIsInNoaWZ0X3JpZ2h0X2xvZ2ljYWwkMCIsImNlaWxfcG93MiQwIiwiZmxvb3JfcG93MiQwIiwiY2VpbF9sb2cyJDAiLCJpc19wb3cyJDAiLCJjbHokMCIsImN0eiQwIiwib2ZfaW50JDAiLCJ0b19pbnQkMCIsInRvX2ludF90cnVuYyQwIiwidG9faW50MzIkMCIsIm9mX2ludDY0JDAiLCJvZl9uYXRpdmVpbnQkMCIsInRvX25hdGl2ZWludCQwIiwidG9fbmF0aXZlaW50X3RydW5jJDAiLCJvZl9mbG9hdF91bmNoZWNrZWQkMCIsInJlcHIkMCIsImJzd2FwMzIkMCIsImJzd2FwNDgkMCIsInBvc19kaWZmIiwibmVnYXRpdmVfb25lIiwiZGl2X3dvdWxkX292ZXJmbG93IiwicHJvZHVjdCIsImFicyQxIiwibmVnJDAiLCJyYW5kb21fb2ZfaW50IiwicmFuZG9tX29mX2ludDY0IiwicmFuZG9tX29mX2ludCQwIiwicmFuZG9tX2luY2xfb2ZfaW50IiwicmFuZG9tX2luY2xfb2ZfaW50NjQiLCJyYW5kb21faW5jbCIsImludiIsImxlZnRfa2V5IiwicmlnaHRfa2V5IiwidXBkYXRlX2hlaWdodCIsIm9sZF9oZWlnaHQiLCJuZXdfaGVpZ2h0IiwiYmFsYW5jZSIsInJvb3Rfbm9kZSIsImxlZnRfbm9kZSIsInJpZ2h0X25vZGUiLCJsZWZ0X25vZGVfbGVmdCIsImxlZnRfbm9kZV9yaWdodCIsImxyX2xlZnQiLCJscl9yaWdodCIsInJpZ2h0X25vZGVfbGVmdCIsInJpZ2h0X25vZGVfcmlnaHQiLCJybF9sZWZ0IiwicmxfcmlnaHQiLCJhZGRlZCIsImZpbmRpX2FuZF9jYWxsX2ltcGwiLCJhcmcxIiwiYXJnMiIsImNhbGxfaWZfZm91bmQiLCJjYWxsX2lmX25vdF9mb3VuZCIsImZpbmRfYW5kX2NhbGwiLCJjYWxsX2lmX2ZvdW5kJDAiLCJjYWxsX2lmX25vdF9mb3VuZCQwIiwiZmluZGlfYW5kX2NhbGwiLCJjYWxsX2lmX2ZvdW5kJDEiLCJjYWxsX2lmX25vdF9mb3VuZCQxIiwiZmluZF9hbmRfY2FsbDEiLCJjYWxsX2lmX2ZvdW5kJDIiLCJjYWxsX2lmX25vdF9mb3VuZCQyIiwiZmluZGlfYW5kX2NhbGwxIiwiY2FsbF9pZl9mb3VuZCQzIiwiY2FsbF9pZl9ub3RfZm91bmQkMyIsImZpbmRfYW5kX2NhbGwyIiwiY2FsbF9pZl9mb3VuZCQ0IiwiY2FsbF9pZl9ub3RfZm91bmQkNCIsImZpbmRpX2FuZF9jYWxsMiIsImlmX2ZvdW5kJDAiLCJpZl9ub3RfZm91bmQkMCIsInJlbW92ZWQiLCJ0cmVlJDAiLCJ0cmVlJDEiLCJrZXkkNCIsImRhdGEkNCIsInJrZXkiLCJyZGF0YSIsImtleSQxIiwicmtleSQwIiwicmRhdGEkMCIsImxrZXkkMCIsImxkYXRhJDAiLCJrZXkkMyIsImRhdGEkMyIsInJrZXkkMSIsInJkYXRhJDEiLCJsa2V5IiwibGRhdGEiLCJrZXkkMiIsImRhdGEkMiIsIm1hcGlfaW5wbGFjZSIsImVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIiwid2l0aG91dF9tdXRhdGluZyIsIm1heF90YWJsZV9sZW5ndGgiLCJncm93dGhfYWxsb3dlZCIsInNpemUkMCIsInNpemUkMSIsInNsb3QiLCJhZGRfd29ya2VyIiwibmV3X3Jvb3QiLCJtYXliZV9yZXNpemVfdGFibGUiLCJzaG91bGRfZ3JvdyIsIm5ld19hcnJheV9sZW5ndGgiLCJuZXdfdGFibGUiLCJvbGRfdGFibGUiLCJzZXhwX29mX2tleSQwIiwiYnVja2V0IiwiY2hvb3NlX25vbmVtcHR5IiwiYXZsdHJlZSIsImNob29zZV9yYW5kb21seV9ub25lbXB0eSIsInN0YXJ0X2lkeCIsImNob29zZV9yYW5kb21seSIsImNob29zZV9yYW5kb21seV9leG4iLCJpbnZhcmlhbnRfa2V5IiwiaW52YXJpYW50X2RhdGEiLCJyZWFsX2xlbiIsIm5ld190IiwidDAiLCJmaW5kX29yX2FkZCIsImlkIiwiZGVmYXVsdCQxIiwiZmluZGlfb3JfYWRkIiwiZmluZF9hbmRfcmVtb3ZlIiwidXBkYXRlX2FuZF9yZXR1cm4iLCJpbmNyX2J5IiwicmVtb3ZlX2lmX3plcm8iLCJieSIsImNyZWF0ZV9tYXBwZWQiLCJnZXRfZGF0YSIsImR1cGVzIiwib2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzIiwic2V4cF9vZl9kYXRhIiwiZF9vZl9zZXhwIiwia19ncmFtbWFyIiwiZ3JvdXBzIiwicm93Iiwib2xkIiwiY3JlYXRlX3dpdGhfa2V5IiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yIiwiY3JlYXRlX3dpdGhfa2V5X2V4biIsIm1heWJlX3NldCIsInRfbGVmdCIsInRfcmlnaHQiLCJtZXJnZV9pbnRvIiwiZHN0X2RhdGEiLCJhY3Rpb24iLCJkc3RfZGF0YSQwIiwidG9fcmVtb3ZlIiwiZmlsdGVyX2tleXNfaW5wbGFjZSIsImZpbHRlcl9tYXBpX2lucGxhY2UiLCJtYXBfcmVzdWx0cyIsImZpbHRlcl9tYXBfaW5wbGFjZSIsInNpbWlsYXIiLCJvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMkMCIsImNyZWF0ZV9tYXBwZWQkMCIsImNyZWF0ZV93aXRoX2tleSQwIiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yJDAiLCJjcmVhdGVfd2l0aF9rZXlfZXhuJDAiLCJvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMkMSIsImNyZWF0ZV9tYXBwZWQkMSIsImNyZWF0ZV93aXRoX2tleSQxIiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yJDEiLCJjcmVhdGVfd2l0aF9rZXlfZXhuJDEiLCJncm91cCQxIiwiaGFzaGFibGVfcyIsInBvbHlfaGFzaGFibGUiLCJzdHJpY3RfYWRkIiwic3RyaWN0X2FkZF9leG4iLCJzdHJpY3RfcmVtb3ZlIiwic3RyaWN0X3JlbW92ZV9leG4iLCJzZXhwX29mX2UiLCJsYXJnZXIiLCJzbWFsbGVyIiwib2ZfaGFzaHRibF9rZXlzIiwiaGFzaHRibCIsInRvX2hhc2h0YmwiLCJlX29mX3NleHAiLCJlcnJvcl9zb3VyY2VfMDA3IiwibWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZSIsIm1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWUiLCJwaSIsInNxcnRfcGkiLCJzcXJ0XzJwaSIsImV1bGVyIiwib2ZfaW50NjMiLCJpcm91bmRfbGJvdW5kIiwiaXJvdW5kX3Vib3VuZCIsImlyb3VuZF91cCIsImlyb3VuZF91cF9leG4iLCJpcm91bmRfZG93biIsImlyb3VuZF9kb3duX2V4biIsImlyb3VuZF90b3dhcmRzX3plcm8iLCJpcm91bmRfdG93YXJkc196ZXJvX2V4biIsInJvdW5kX25lYXJlc3RfbGIiLCJyb3VuZF9uZWFyZXN0X3ViIiwib25lX3VscF9sZXNzX3RoYW5faGFsZiIsImFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IiwiaXJvdW5kX25lYXJlc3RfMzIiLCJpcm91bmRfbmVhcmVzdF82NCIsImlyb3VuZF9uZWFyZXN0XzY0JDAiLCJpcm91bmRfbmVhcmVzdF9leG5fMzIiLCJpcm91bmRfbmVhcmVzdF9leG5fNjQiLCJpcm91bmRfbmVhcmVzdF9leG4iLCJpcm91bmRfZXhuIiwiaXJvdW5kIiwiaXNfaW5mIiwiaXNfZmluaXRlIiwibWluX2luYW4iLCJtYXhfaW5hbiIsInNjYWxlIiwic3F1YXJlIiwiZnJhY3Rpb25hbCIsImludGVncmFsIiwicm91bmRfbmVhcmVzdF9pbmxpbmUiLCJyb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiIsImNlaWxfb3Jfc3VjYyIsImRpZmZfZmxvb3IiLCJkaWZmX2NlaWwiLCJpbnQ2M19yb3VuZF9sYm91bmQiLCJpbnQ2M19yb3VuZF91Ym91bmQiLCJpbnQ2M19yb3VuZF91cF9leG4iLCJpbnQ2M19yb3VuZF9kb3duX2V4biIsImludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYSIsImludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYSIsImludDYzX3JvdW5kX25lYXJlc3RfZXhuIiwiY2xhc3NpZnkiLCJzdHJpcF96ZXJvIiwiZGVjaW1hbHMiLCJleHBsaWNpdF9wbHVzIiwidG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nX2N1c3RvIiwia2lsbyIsIm1lZ2EiLCJnaWdhIiwidGVyYSIsInBldGEiLCJtYWciLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsImhpZ2hlciIsImRpZmZfcmlnaHQiLCJkaWZmX2xlZnQiLCJwZXRhJDAiLCJ0b19wYWRkZWRfY29tcGFjdF9zdHJpbmciLCJyb3VuZF9nZW4iLCJzZCIsImRkIiwiZGQkMCIsInNkJDAiLCJkZCQxIiwic2QkMSIsImFic19kZCIsInJvdW5kX3NpZ25pZmljYW50Iiwic2lnbmlmaWNhbnRfZGlnaXRzIiwicm91bmRfZGVjaW1hbCIsImRlY2ltYWxfZGlnaXRzIiwic2lnbl9leG4iLCJzaWduX29yX25hbiIsImllZWVfbmVnYXRpdmUiLCJleHBvbmVudF9tYXNrNjQiLCJleHBvbmVudF9tYXNrIiwibWFudGlzc2FfbWFzayIsIm1hbnRpc3NhX21hc2s2NCIsIm1hbnRpc3NhX2JpdHMiLCJpZWVlX2V4cG9uZW50IiwiaWVlZV9tYW50aXNzYSIsImNyZWF0ZV9pZWVlX2V4biIsIm5lZ2F0aXZlIiwibWFudGlzc2EiLCJzaWduX2JpdHMiLCJleHB0X2JpdHMiLCJtYW50X2JpdHMiLCJjcmVhdGVfaWVlZSIsInNwZWNpYWxpemVkX2hhc2giLCJhZGRfc3Vic3RyaW5nIiwiYWRkX3N1YmJ5dGVzIiwiY2FtbF9idWZmZXJfbGVuZ3RoIiwiY2FtbF9idWZmZXJfYmxpdCIsImVsaWRlZF9tZXNzYWdlIiwiZWxpZGUiLCJhdF9tb3N0X251bV9mcmFtZXMiLCJ0b19zdHJpbmdfbGlzdCIsInNldF9yZWNvcmRpbmciLCJhbV9yZWNvcmRpbmciLCJtb3N0X3JlY2VudCIsIm1vc3RfcmVjZW50X2Zvcl9leG4iLCJ3aXRoX3JlY29yZGluZyIsInNhdmVkIiwib2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhIiwiYXJyYXlfb2Zfc2V4cCIsInNleHBfb2ZfYXJyYXkiLCJhcnJheV9zZXhwX2dyYW1tYXIiLCJib29sX29mX3NleHAiLCJzZXhwX29mX2Jvb2wiLCJib29sX3NleHBfZ3JhbW1hciIsImNoYXJfb2Zfc2V4cCIsInNleHBfb2ZfY2hhciIsImNoYXJfc2V4cF9ncmFtbWFyIiwic2V4cF9vZl9leG4iLCJnbG9iYWxpemVfZmxvYXQiLCJmbG9hdF9vZl9zZXhwIiwic2V4cF9vZl9mbG9hdCIsImZsb2F0X3NleHBfZ3JhbW1hciIsImdsb2JhbGl6ZV9pbnQiLCJmdW5jJDIiLCJpbnRfb2Zfc2V4cCIsInNleHBfb2ZfaW50IiwiaW50X3NleHBfZ3JhbW1hciIsImdsb2JhbGl6ZV9pbnQzMiIsImZ1bmMkMyIsImludDMyX29mX3NleHAiLCJzZXhwX29mX2ludDMyIiwiaW50MzJfc2V4cF9ncmFtbWFyIiwiZ2xvYmFsaXplX2ludDY0IiwiZnVuYyQ0IiwiaW50NjRfb2Zfc2V4cCIsInNleHBfb2ZfaW50NjQiLCJpbnQ2NF9zZXhwX2dyYW1tYXIiLCJsaXN0X29mX3NleHAiLCJzZXhwX29mX2xpc3QiLCJsaXN0X3NleHBfZ3JhbW1hciIsImdsb2JhbGl6ZV9uYXRpdmVpbnQiLCJmdW5jJDUiLCJuYXRpdmVpbnRfb2Zfc2V4cCIsInNleHBfb2ZfbmF0aXZlaW50IiwibmF0aXZlaW50X3NleHBfZ3JhbW1hciIsIm9wdGlvbl9vZl9zZXhwIiwic2V4cF9vZl9vcHRpb24iLCJvcHRpb25fc2V4cF9ncmFtbWFyIiwicmVmX29mX3NleHAiLCJzZXhwX29mX3JlZiIsInJlZl9zZXhwX2dyYW1tYXIiLCJnbG9iYWxpemVfc3RyaW5nIiwic3RyaW5nX29mX3NleHAiLCJzZXhwX29mX3N0cmluZyIsInN0cmluZ19zZXhwX2dyYW1tYXIiLCJnbG9iYWxpemVfYnl0ZXMiLCJieXRlc19vZl9zZXhwIiwic2V4cF9vZl9ieXRlcyIsImJ5dGVzX3NleHBfZ3JhbW1hciIsImZ1bmMkNiIsInVuaXRfb2Zfc2V4cCIsInNleHBfb2ZfdW5pdCIsInVuaXRfc2V4cF9ncmFtbWFyIiwiZmFpbHdpdGgiLCJpbnZhbGlkX2FyZyIsImNvbXBhcmVfYXJyYXlfbG9jYWwkMCIsImNvbXBhcmVfYXJyYXkkMCIsImVxdWFsX2FycmF5X2xvY2FsJDAiLCJlcXVhbF9hcnJheSQwIiwiZ2xvYmFsaXplX2FycmF5JDAiLCJhcnJheV9vZl9zZXhwJDAiLCJzZXhwX29mX2FycmF5JDAiLCJhcnJheV9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfYm9vbF9sb2NhbCQwIiwiY29tcGFyZV9ib29sJDAiLCJlcXVhbF9ib29sX2xvY2FsJDAiLCJlcXVhbF9ib29sJDAiLCJnbG9iYWxpemVfYm9vbCQwIiwiaGFzaF9mb2xkX2Jvb2wkMCIsImhhc2hfYm9vbCQwIiwiYm9vbF9vZl9zZXhwJDAiLCJzZXhwX29mX2Jvb2wkMCIsImJvb2xfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX2NoYXJfbG9jYWwkMCIsImNvbXBhcmVfY2hhciQwIiwiZXF1YWxfY2hhcl9sb2NhbCQwIiwiZXF1YWxfY2hhciQwIiwiZ2xvYmFsaXplX2NoYXIkMCIsImhhc2hfZm9sZF9jaGFyJDAiLCJoYXNoX2NoYXIkMCIsImNoYXJfb2Zfc2V4cCQwIiwic2V4cF9vZl9jaGFyJDAiLCJjaGFyX3NleHBfZ3JhbW1hciQwIiwic2V4cF9vZl9leG4kMCIsImNvbXBhcmVfZmxvYXRfbG9jYWwkMCIsImNvbXBhcmVfZmxvYXQkMCIsImVxdWFsX2Zsb2F0X2xvY2FsJDAiLCJlcXVhbF9mbG9hdCQwIiwiZ2xvYmFsaXplX2Zsb2F0JDAiLCJoYXNoX2ZvbGRfZmxvYXQkMCIsImhhc2hfZmxvYXQkMCIsImZsb2F0X29mX3NleHAkMCIsInNleHBfb2ZfZmxvYXQkMCIsImZsb2F0X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9pbnRfbG9jYWwkMCIsImNvbXBhcmVfaW50JDAiLCJlcXVhbF9pbnRfbG9jYWwkMCIsImVxdWFsX2ludCQwIiwiZ2xvYmFsaXplX2ludCQwIiwiaGFzaF9mb2xkX2ludCQwIiwiaGFzaF9pbnQkMCIsImludF9vZl9zZXhwJDAiLCJzZXhwX29mX2ludCQwIiwiaW50X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9pbnQzMl9sb2NhbCQwIiwiY29tcGFyZV9pbnQzMiQwIiwiZXF1YWxfaW50MzJfbG9jYWwkMCIsImVxdWFsX2ludDMyJDAiLCJnbG9iYWxpemVfaW50MzIkMCIsImhhc2hfZm9sZF9pbnQzMiQwIiwiaGFzaF9pbnQzMiQwIiwiaW50MzJfb2Zfc2V4cCQwIiwic2V4cF9vZl9pbnQzMiQwIiwiaW50MzJfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX2ludDY0X2xvY2FsJDAiLCJjb21wYXJlX2ludDY0JDAiLCJlcXVhbF9pbnQ2NF9sb2NhbCQwIiwiZXF1YWxfaW50NjQkMCIsImdsb2JhbGl6ZV9pbnQ2NCQwIiwiaGFzaF9mb2xkX2ludDY0JDAiLCJoYXNoX2ludDY0JDAiLCJpbnQ2NF9vZl9zZXhwJDAiLCJzZXhwX29mX2ludDY0JDAiLCJpbnQ2NF9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfbGlzdF9sb2NhbCQwIiwiY29tcGFyZV9saXN0JDAiLCJlcXVhbF9saXN0X2xvY2FsJDAiLCJlcXVhbF9saXN0JDAiLCJnbG9iYWxpemVfbGlzdCQwIiwiaGFzaF9mb2xkX2xpc3QkMCIsImxpc3Rfb2Zfc2V4cCQwIiwic2V4cF9vZl9saXN0JDAiLCJsaXN0X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9uYXRpdmVpbnRfbG9jYWwkMCIsImNvbXBhcmVfbmF0aXZlaW50JDAiLCJlcXVhbF9uYXRpdmVpbnRfbG9jYWwkMCIsImVxdWFsX25hdGl2ZWludCQwIiwiZ2xvYmFsaXplX25hdGl2ZWludCQwIiwiaGFzaF9mb2xkX25hdGl2ZWludCQwIiwiaGFzaF9uYXRpdmVpbnQkMCIsIm5hdGl2ZWludF9vZl9zZXhwJDAiLCJzZXhwX29mX25hdGl2ZWludCQwIiwibmF0aXZlaW50X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9vcHRpb25fbG9jYWwkMCIsImNvbXBhcmVfb3B0aW9uJDAiLCJlcXVhbF9vcHRpb25fbG9jYWwkMCIsImVxdWFsX29wdGlvbiQwIiwiZ2xvYmFsaXplX29wdGlvbiQwIiwiaGFzaF9mb2xkX29wdGlvbiQwIiwib3B0aW9uX29mX3NleHAkMCIsInNleHBfb2Zfb3B0aW9uJDAiLCJvcHRpb25fc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX3JlZl9sb2NhbCQwIiwiY29tcGFyZV9yZWYkMCIsImVxdWFsX3JlZl9sb2NhbCQwIiwiZXF1YWxfcmVmJDAiLCJnbG9iYWxpemVfcmVmJDAiLCJyZWZfb2Zfc2V4cCQwIiwic2V4cF9vZl9yZWYkMCIsInJlZl9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfc3RyaW5nX2xvY2FsJDAiLCJjb21wYXJlX3N0cmluZyQwIiwiZXF1YWxfc3RyaW5nX2xvY2FsJDAiLCJlcXVhbF9zdHJpbmckMCIsImdsb2JhbGl6ZV9zdHJpbmckMCIsImhhc2hfZm9sZF9zdHJpbmckMCIsImhhc2hfc3RyaW5nJDAiLCJzdHJpbmdfb2Zfc2V4cCQwIiwic2V4cF9vZl9zdHJpbmckMCIsInN0cmluZ19zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfYnl0ZXNfbG9jYWwkMCIsImNvbXBhcmVfYnl0ZXMkMCIsImVxdWFsX2J5dGVzX2xvY2FsJDAiLCJlcXVhbF9ieXRlcyQwIiwiZ2xvYmFsaXplX2J5dGVzJDAiLCJieXRlc19vZl9zZXhwJDAiLCJzZXhwX29mX2J5dGVzJDAiLCJieXRlc19zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfdW5pdF9sb2NhbCQwIiwiY29tcGFyZV91bml0JDAiLCJlcXVhbF91bml0X2xvY2FsJDAiLCJlcXVhbF91bml0JDAiLCJnbG9iYWxpemVfdW5pdCQwIiwiaGFzaF9mb2xkX3VuaXQkMCIsImhhc2hfdW5pdCQwIiwidW5pdF9vZl9zZXhwJDAiLCJzZXhwX29mX3VuaXQkMCIsInVuaXRfc2V4cF9ncmFtbWFyJDAiLCJyYWlzZV9zJDAiXSwic291cmNlcyI6WyIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9iYXNlX18ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9nbG9iYWxpemUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9wb2x5MC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2ltcG9ydDAubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9pbnQwLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvcHJpbnRmLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2Uvc3lzMC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2FycmF5MC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2NoYXIwLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvbGlzdDAubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9oYXNoLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvcHB4X2NvbXBhcmVfbGliLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvcHB4X2hhc2hfbGliLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2Uvc2V4cC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL3dvcmRfc2l6ZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL3ByZXR0eV9wcmludGVyLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvZXhuLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2Uvd2l0aF9yZXR1cm4ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9mbi5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL21vbmFkX2ludGYubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9tb25hZC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2FwcGxpY2F0aXZlLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvY29tcGFyYXRvci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2VpdGhlcjAubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9maWVsZC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2ludF9jb252ZXJzaW9ucy5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL3N0cmluZzAubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9zb3VyY2VfY29kZV9wb3NpdGlvbjAubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9saXN0MS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL3Jlc3VsdC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2NvbnRhaW5lcl9pbnRmLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvY29udGFpbmVyLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvaW5kZXhlZF9jb250YWluZXIubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9sYXp5Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2Uvb3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjAubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9yYW5kb21fcmVwci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL3JhbmRvbS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2FycmF5X3Blcm11dGUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9vcmRlcmluZy5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2xpc3QubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9pbmZvLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvZXJyb3IubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9pbnZhcmlhbnQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9vcl9lcnJvci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL3NpZ24wLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvY29tcGFyYWJsZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2hhc2hhYmxlX2ludGYubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9pZGVudGlmaWFibGUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS91bml0Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2Uvb3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2JpbmFyeV9zZWFyY2gubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9iaW5hcnlfc2VhcmNoYWJsZV9pbnRmLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvYmluYXJ5X3NlYXJjaGFibGUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9ieXRlczAubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9ibGl0Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvYm9vbC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2VpdGhlci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL29wdGlvbi5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL3BweF9lbnVtZXJhdGVfbGliLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2Uvc2VxdWVuY2UubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9zZXhwYWJsZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2FycmF5Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvZmxvYXQwLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvcG93X292ZXJmbG93X2JvdW5kcy5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2ludF9tYXRoLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2Uvc3RhZ2VkLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvY2hhci5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2J5dGVzX3RyLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2Uvc3RyaW5nLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvYnl0ZXMubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9oZXhfbGV4ZXIubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9pbnRfc3RyaW5nX2NvbnZlcnNpb25zLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvcG9wY291bnQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9zaWduLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvaW50Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2Uvb2JqX2xvY2FsLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2Uvb2JqX2FycmF5Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvdW5pZm9ybV9hcnJheS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL3VjaGFyLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvdHlwZV9lcXVhbF9pbnRmLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvdHlwZV9lcXVhbC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL29wdGlvbl9hcnJheS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL3N0YWNrLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2Uvc291cmNlX2NvZGVfcG9zaXRpb24ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9zaWduX29yX25hbi5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2RpY3Rpb25hcnlfaW1tdXRhYmxlX2ludGYubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9tYXliZV9ib3VuZC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL21hcF9pbnRmLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2Uvc2V0X2ludGYubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9zZXQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9yZWYubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9xdWV1ZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL25vdGhpbmcubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9uYXRpdmVpbnQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9tYXAubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9saW5rZWRfcXVldWUwLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvbGlua2VkX3F1ZXVlLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvaW50NjQubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9pbnQ2M19lbXVsLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvaW50MzIubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9pbnQ2My5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2RpY3Rpb25hcnlfbXV0YWJsZV9pbnRmLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvaGFzaHRibF9pbnRmLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvYXZsdHJlZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2hhc2h0YmwubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYmFzZS9oYXNoX3NldC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9iYXNlL2Zsb2F0Lm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvYnVmZmVyLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvYmFja3RyYWNlLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2Jhc2UvYmFzZS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztHQWtiZ0IsdUNBQUE7OztFOzs7Ozs7Ozs7RTs7Ozs7OztHOzs7OztZQzdhWkEsZUFDQUMsR0FBdUIsT0FBdkJBLEVBQXdCO1lBR3hCQyxlQUNBQyxHQUF5QixPQUF6QkEsRUFBMEI7WUFXMUJDLGVBQWVDLEdBQVksT0FBWkEsRUFBYTtZQUk1QkMsdUJBQWtCQyxHQUFJLE9BQUpBLFVBQXNCO1lBRXBDQyxlQUFlQztJ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O0lBQ0FDO0lBQ0NDO0lBTURDO0lBUUFDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0NDO0lBRUFDO0lBS0FDO0lBS0RDO0lBQ0FDO0lBQ0NDO0lBUURDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0NDO0lBRUFDO0lBR0FDO0lBS0RDO0lBQ0FDO0lBQ0NDO0lBUURDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0NDO0lBRUFDO0lBS0FDO0lBS0RDO0lBQ0FDO0lBQ0NDO0lBUURDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0NDO0lBRUFDO0lBS0FDO0lBS0RDO0lBQ0FDO0lBQ0NDO0lBUURDO0lBSUFDO0lBRUFDO0lBSUFDO0lBRUFDO0lBS0FDO0lBVUFDO0lBSUFDO0lBSUFDO0lBWUFDO0lBSUFDO0lBSUFDO0lBRUFDO0lBSUNDO0lBSUFDO0lBS0FDO0lBS0RDO0lBQ0FDO0lBRUNDO0lBVURDO0lBSUFDO0lBSUFDO0lBSUFDO0lBSUFDO0lBS0FDO0lBVUFDO0lBSUFDO0lBSUFDO0lBV0FDO0lBSUFDO0lBRUFDO0lBSUFDO0lBRUFDO0lBS0FDO0lBSUFDO0lBSUFDO0lBVUFDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0NDO0lBRUFDO0lBS0FDO0lBS0RDO0lBQ0FDO0lBQ0NDO0lBT0RDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0NDO0lBQ0RDO0lBQ0FDO0lBQ0NDO0lBUURDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0NDO0lBRUFDO0lBS0FDO0lBS0RDO0lBQ0FDO0lBQ0NDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTBDRDErRztJQVlBb2pCO0lBQ0FFO0lBT0EzZTtJQUNBRTtJQUNBODVHOzs7O0dBbUJHO0dBRUs7SUFBQTs7Ozs7T0F2cUJWN25IO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDOzs7OztPQXNLRXU2RztPQUlBQztPQUVBQztPQUlBQztPQUVBQztPQUtBQztPQUlBQztPQUlBQztPQVlBQztPQUNBQztPQUNBQztPQUNBQztPQUNDQztPQUVBQztPQUtBQztPQUtEQztPQUNBQztPQUNDQztPQVFEQztPQUNBQztPQUNBQztPQUNBQztPQUNDQztPQUVBQztPQUtBQztPQUtEQztPQUNBQztPQUNDQztPQU1EQztPQVFBQztPQUNBQztPQUNBQztPQUNBQztPQUNDQztPQUVBQztPQUtBQztPQUtEQztPQUNBQztPQUNDQztPQVFEQztPQUNBQztPQUNBQztPQUNBQztPQUNDQztPQUVBQztPQUdBQztPQUtEQztPQUNBQztPQUNDQztPQVFEQztPQUNBQztPQUNBQztPQUNBQztPQUNDQztPQUVBQztPQUtBQztPQUtEQztPQUNBQztPQUNDQztPQVFEQztPQUNBQztPQUNBQztPQUNBQztPQUNDQztPQUVBQztPQUtBQztPQUtEQztPQUNBQztPQUNDQztPQVFEQztPQUlBQztPQUVBQztPQUlBQztPQUVBQztPQUtBQztPQVVBQztPQUlBQztPQUlBQztPQVlBQztPQUlBQztPQUlBQztPQUVBQztPQUlDQztPQUlBQztPQUtBQztPQUtEQztPQUNBQztPQUVDQztPQVVEQztPQUlBQztPQUlBQztPQUlBQztPQUlBQztPQUtBQztPQVVBQztPQUlBQztPQUlBQztPQVdBQztPQUlBQztPQUVBQztPQUlBQztPQUVBQztPQUtBQztPQUlBQztPQUlBQztPQVVBQztPQUNBQztPQUNBQztPQUNBQztPQUNDQztPQUVBQztPQUtBQztPQUtEQztPQUNBQztPQUNDQztPQU9EQztPQUNBQztPQUNBQztPQUNBQztPQUNDQztPQUNEQztPQUNBQztPQUNDQztPQVFEQztPQUNBQztPQUNBQztPQUNBQztPQUNDQztPQUVBQztPQUtBQztPQUtEQztPQUNBQztPQUNDQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EwQ0QxK0c7T0FZQW9qQjtPQUNBRTtPQU9BM2U7T0FDQUU7T0FDQTg1Rzs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkFwcGxpY2F0aXZlICopXG5tb2R1bGUgQXBwbGljYXRpdmUgPSBCYXNlX19BcHBsaWNhdGl2ZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkFwcGxpY2F0aXZlX2ludGYgKilcbm1vZHVsZSBBcHBsaWNhdGl2ZV9pbnRmID0gQmFzZV9fQXBwbGljYXRpdmVfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkFycmF5ICopXG5tb2R1bGUgQXJyYXkgPSBCYXNlX19BcnJheVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkFycmF5MCAqKVxubW9kdWxlIEFycmF5MCA9IEJhc2VfX0FycmF5MFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkFycmF5X3Blcm11dGUgKilcbm1vZHVsZSBBcnJheV9wZXJtdXRlID0gQmFzZV9fQXJyYXlfcGVybXV0ZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkF2bHRyZWUgKilcbm1vZHVsZSBBdmx0cmVlID0gQmFzZV9fQXZsdHJlZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJhY2t0cmFjZSAqKVxubW9kdWxlIEJhY2t0cmFjZSA9IEJhc2VfX0JhY2t0cmFjZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJpbmFyeV9zZWFyY2ggKilcbm1vZHVsZSBCaW5hcnlfc2VhcmNoID0gQmFzZV9fQmluYXJ5X3NlYXJjaFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJpbmFyeV9zZWFyY2hhYmxlICopXG5tb2R1bGUgQmluYXJ5X3NlYXJjaGFibGUgPSBCYXNlX19CaW5hcnlfc2VhcmNoYWJsZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJpbmFyeV9zZWFyY2hhYmxlX2ludGYgKilcbm1vZHVsZSBCaW5hcnlfc2VhcmNoYWJsZV9pbnRmID0gQmFzZV9fQmluYXJ5X3NlYXJjaGFibGVfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJsaXQgKilcbm1vZHVsZSBCbGl0ID0gQmFzZV9fQmxpdFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJsaXRfaW50ZiAqKVxubW9kdWxlIEJsaXRfaW50ZiA9IEJhc2VfX0JsaXRfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJvb2wgKilcbm1vZHVsZSBCb29sID0gQmFzZV9fQm9vbFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJvb2wwICopXG5tb2R1bGUgQm9vbDAgPSBCYXNlX19Cb29sMFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJ1ZmZlciAqKVxubW9kdWxlIEJ1ZmZlciA9IEJhc2VfX0J1ZmZlclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJ1ZmZlcl9pbnRmICopXG5tb2R1bGUgQnVmZmVyX2ludGYgPSBCYXNlX19CdWZmZXJfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJ5dGVzICopXG5tb2R1bGUgQnl0ZXMgPSBCYXNlX19CeXRlc1xuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJ5dGVzMCAqKVxubW9kdWxlIEJ5dGVzMCA9IEJhc2VfX0J5dGVzMFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJ5dGVzX2ludGYgKilcbm1vZHVsZSBCeXRlc19pbnRmID0gQmFzZV9fQnl0ZXNfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkJ5dGVzX3RyICopXG5tb2R1bGUgQnl0ZXNfdHIgPSBCYXNlX19CeXRlc190clxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkNoYXIgKilcbm1vZHVsZSBDaGFyID0gQmFzZV9fQ2hhclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkNoYXIwICopXG5tb2R1bGUgQ2hhcjAgPSBCYXNlX19DaGFyMFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkNvbXBhcmFibGUgKilcbm1vZHVsZSBDb21wYXJhYmxlID0gQmFzZV9fQ29tcGFyYWJsZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkNvbXBhcmFibGVfaW50ZiAqKVxubW9kdWxlIENvbXBhcmFibGVfaW50ZiA9IEJhc2VfX0NvbXBhcmFibGVfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkNvbXBhcmF0b3IgKilcbm1vZHVsZSBDb21wYXJhdG9yID0gQmFzZV9fQ29tcGFyYXRvclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkNvbXBhcmlzb25zICopXG5tb2R1bGUgQ29tcGFyaXNvbnMgPSBCYXNlX19Db21wYXJpc29uc1xuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkNvbnRhaW5lciAqKVxubW9kdWxlIENvbnRhaW5lciA9IEJhc2VfX0NvbnRhaW5lclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkNvbnRhaW5lcl9pbnRmICopXG5tb2R1bGUgQ29udGFpbmVyX2ludGYgPSBCYXNlX19Db250YWluZXJfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkRpY3Rpb25hcnlfaW1tdXRhYmxlICopXG5tb2R1bGUgRGljdGlvbmFyeV9pbW11dGFibGUgPSBCYXNlX19EaWN0aW9uYXJ5X2ltbXV0YWJsZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkRpY3Rpb25hcnlfaW1tdXRhYmxlX2ludGYgKilcbm1vZHVsZSBEaWN0aW9uYXJ5X2ltbXV0YWJsZV9pbnRmID0gQmFzZV9fRGljdGlvbmFyeV9pbW11dGFibGVfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkRpY3Rpb25hcnlfbXV0YWJsZSAqKVxubW9kdWxlIERpY3Rpb25hcnlfbXV0YWJsZSA9IEJhc2VfX0RpY3Rpb25hcnlfbXV0YWJsZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkRpY3Rpb25hcnlfbXV0YWJsZV9pbnRmICopXG5tb2R1bGUgRGljdGlvbmFyeV9tdXRhYmxlX2ludGYgPSBCYXNlX19EaWN0aW9uYXJ5X211dGFibGVfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkVpdGhlciAqKVxubW9kdWxlIEVpdGhlciA9IEJhc2VfX0VpdGhlclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkVpdGhlcjAgKilcbm1vZHVsZSBFaXRoZXIwID0gQmFzZV9fRWl0aGVyMFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkVpdGhlcl9pbnRmICopXG5tb2R1bGUgRWl0aGVyX2ludGYgPSBCYXNlX19FaXRoZXJfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkVxdWFsICopXG5tb2R1bGUgRXF1YWwgPSBCYXNlX19FcXVhbFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkVycm9yICopXG5tb2R1bGUgRXJyb3IgPSBCYXNlX19FcnJvclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkV4biAqKVxubW9kdWxlIEV4biA9IEJhc2VfX0V4blxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkZpZWxkICopXG5tb2R1bGUgRmllbGQgPSBCYXNlX19GaWVsZFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkZpZWxkc2xpYiAqKVxubW9kdWxlIEZpZWxkc2xpYiA9IEJhc2VfX0ZpZWxkc2xpYlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkZsb2F0ICopXG5tb2R1bGUgRmxvYXQgPSBCYXNlX19GbG9hdFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkZsb2F0MCAqKVxubW9kdWxlIEZsb2F0MCA9IEJhc2VfX0Zsb2F0MFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkZsb2F0YWJsZSAqKVxubW9kdWxlIEZsb2F0YWJsZSA9IEJhc2VfX0Zsb2F0YWJsZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkZuICopXG5tb2R1bGUgRm4gPSBCYXNlX19GblxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkZvcm1hdHRlciAqKVxubW9kdWxlIEZvcm1hdHRlciA9IEJhc2VfX0Zvcm1hdHRlclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkdsb2JhbGl6ZSAqKVxubW9kdWxlIEdsb2JhbGl6ZSA9IEJhc2VfX0dsb2JhbGl6ZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2ggKilcbm1vZHVsZSBIYXNoID0gQmFzZV9fSGFzaFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2hfaW50ZiAqKVxubW9kdWxlIEhhc2hfaW50ZiA9IEJhc2VfX0hhc2hfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2hfc2V0ICopXG5tb2R1bGUgSGFzaF9zZXQgPSBCYXNlX19IYXNoX3NldFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2hfc2V0X2ludGYgKilcbm1vZHVsZSBIYXNoX3NldF9pbnRmID0gQmFzZV9fSGFzaF9zZXRfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2hhYmxlICopXG5tb2R1bGUgSGFzaGFibGUgPSBCYXNlX19IYXNoYWJsZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2hhYmxlX2ludGYgKilcbm1vZHVsZSBIYXNoYWJsZV9pbnRmID0gQmFzZV9fSGFzaGFibGVfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2hlciAqKVxubW9kdWxlIEhhc2hlciA9IEJhc2VfX0hhc2hlclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2h0YmwgKilcbm1vZHVsZSBIYXNodGJsID0gQmFzZV9fSGFzaHRibFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2h0YmxfaW50ZiAqKVxubW9kdWxlIEhhc2h0YmxfaW50ZiA9IEJhc2VfX0hhc2h0YmxfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhleF9sZXhlciAqKVxubW9kdWxlIEhleF9sZXhlciA9IEJhc2VfX0hleF9sZXhlclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLklkZW50aWZpYWJsZSAqKVxubW9kdWxlIElkZW50aWZpYWJsZSA9IEJhc2VfX0lkZW50aWZpYWJsZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLklkZW50aWZpYWJsZV9pbnRmICopXG5tb2R1bGUgSWRlbnRpZmlhYmxlX2ludGYgPSBCYXNlX19JZGVudGlmaWFibGVfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkltcG9ydCAqKVxubW9kdWxlIEltcG9ydCA9IEJhc2VfX0ltcG9ydFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkltcG9ydDAgKilcbm1vZHVsZSBJbXBvcnQwID0gQmFzZV9fSW1wb3J0MFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkluZGV4ZWRfY29udGFpbmVyICopXG5tb2R1bGUgSW5kZXhlZF9jb250YWluZXIgPSBCYXNlX19JbmRleGVkX2NvbnRhaW5lclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkluZGV4ZWRfY29udGFpbmVyX2ludGYgKilcbm1vZHVsZSBJbmRleGVkX2NvbnRhaW5lcl9pbnRmID0gQmFzZV9fSW5kZXhlZF9jb250YWluZXJfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkluZm8gKilcbm1vZHVsZSBJbmZvID0gQmFzZV9fSW5mb1xuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkluZm9faW50ZiAqKVxubW9kdWxlIEluZm9faW50ZiA9IEJhc2VfX0luZm9faW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkludCAqKVxubW9kdWxlIEludCA9IEJhc2VfX0ludFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkludDAgKilcbm1vZHVsZSBJbnQwID0gQmFzZV9fSW50MFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkludDMyICopXG5tb2R1bGUgSW50MzIgPSBCYXNlX19JbnQzMlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkludDYzICopXG5tb2R1bGUgSW50NjMgPSBCYXNlX19JbnQ2M1xuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkludDYzX2VtdWwgKilcbm1vZHVsZSBJbnQ2M19lbXVsID0gQmFzZV9fSW50NjNfZW11bFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkludDY0ICopXG5tb2R1bGUgSW50NjQgPSBCYXNlX19JbnQ2NFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkludF9jb252ZXJzaW9ucyAqKVxubW9kdWxlIEludF9jb252ZXJzaW9ucyA9IEJhc2VfX0ludF9jb252ZXJzaW9uc1xuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkludF9pbnRmICopXG5tb2R1bGUgSW50X2ludGYgPSBCYXNlX19JbnRfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkludF9tYXRoICopXG5tb2R1bGUgSW50X21hdGggPSBCYXNlX19JbnRfbWF0aFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkludF9zdHJpbmdfY29udmVyc2lvbnMgKilcbm1vZHVsZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zID0gQmFzZV9fSW50X3N0cmluZ19jb252ZXJzaW9uc1xuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkludGFibGUgKilcbm1vZHVsZSBJbnRhYmxlID0gQmFzZV9fSW50YWJsZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkludmFyaWFudCAqKVxubW9kdWxlIEludmFyaWFudCA9IEJhc2VfX0ludmFyaWFudFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkludmFyaWFudF9pbnRmICopXG5tb2R1bGUgSW52YXJpYW50X2ludGYgPSBCYXNlX19JbnZhcmlhbnRfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkxhenkgKilcbm1vZHVsZSBMYXp5ID0gQmFzZV9fTGF6eVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkxpbmtlZF9xdWV1ZSAqKVxubW9kdWxlIExpbmtlZF9xdWV1ZSA9IEJhc2VfX0xpbmtlZF9xdWV1ZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkxpbmtlZF9xdWV1ZTAgKilcbm1vZHVsZSBMaW5rZWRfcXVldWUwID0gQmFzZV9fTGlua2VkX3F1ZXVlMFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkxpc3QgKilcbm1vZHVsZSBMaXN0ID0gQmFzZV9fTGlzdFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkxpc3QwICopXG5tb2R1bGUgTGlzdDAgPSBCYXNlX19MaXN0MFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkxpc3QxICopXG5tb2R1bGUgTGlzdDEgPSBCYXNlX19MaXN0MVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk1hcCAqKVxubW9kdWxlIE1hcCA9IEJhc2VfX01hcFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk1hcF9pbnRmICopXG5tb2R1bGUgTWFwX2ludGYgPSBCYXNlX19NYXBfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk1heWJlX2JvdW5kICopXG5tb2R1bGUgTWF5YmVfYm91bmQgPSBCYXNlX19NYXliZV9ib3VuZFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk1vbmFkICopXG5tb2R1bGUgTW9uYWQgPSBCYXNlX19Nb25hZFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk1vbmFkX2ludGYgKilcbm1vZHVsZSBNb25hZF9pbnRmID0gQmFzZV9fTW9uYWRfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk5hdGl2ZWludCAqKVxubW9kdWxlIE5hdGl2ZWludCA9IEJhc2VfX05hdGl2ZWludFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk5vdGhpbmcgKilcbm1vZHVsZSBOb3RoaW5nID0gQmFzZV9fTm90aGluZ1xuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk9ial9hcnJheSAqKVxubW9kdWxlIE9ial9hcnJheSA9IEJhc2VfX09ial9hcnJheVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk9ial9sb2NhbCAqKVxubW9kdWxlIE9ial9sb2NhbCA9IEJhc2VfX09ial9sb2NhbFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk9wdGlvbiAqKVxubW9kdWxlIE9wdGlvbiA9IEJhc2VfX09wdGlvblxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk9wdGlvbl9hcnJheSAqKVxubW9kdWxlIE9wdGlvbl9hcnJheSA9IEJhc2VfX09wdGlvbl9hcnJheVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk9yX2Vycm9yICopXG5tb2R1bGUgT3JfZXJyb3IgPSBCYXNlX19Pcl9lcnJvclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24gKilcbm1vZHVsZSBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uID0gQmFzZV9fT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vblxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24wICopXG5tb2R1bGUgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjAgPSBCYXNlX19PcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk9yZGVyaW5nICopXG5tb2R1bGUgT3JkZXJpbmcgPSBCYXNlX19PcmRlcmluZ1xuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlBvbHkwICopXG5tb2R1bGUgUG9seTAgPSBCYXNlX19Qb2x5MFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlBvcGNvdW50ICopXG5tb2R1bGUgUG9wY291bnQgPSBCYXNlX19Qb3Bjb3VudFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlBvd19vdmVyZmxvd19ib3VuZHMgKilcbm1vZHVsZSBQb3dfb3ZlcmZsb3dfYm91bmRzID0gQmFzZV9fUG93X292ZXJmbG93X2JvdW5kc1xuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlBweF9jb21wYXJlX2xpYiAqKVxubW9kdWxlIFBweF9jb21wYXJlX2xpYiA9IEJhc2VfX1BweF9jb21wYXJlX2xpYlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlBweF9lbnVtZXJhdGVfbGliICopXG5tb2R1bGUgUHB4X2VudW1lcmF0ZV9saWIgPSBCYXNlX19QcHhfZW51bWVyYXRlX2xpYlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlBweF9oYXNoX2xpYiAqKVxubW9kdWxlIFBweF9oYXNoX2xpYiA9IEJhc2VfX1BweF9oYXNoX2xpYlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlByZXR0eV9wcmludGVyICopXG5tb2R1bGUgUHJldHR5X3ByaW50ZXIgPSBCYXNlX19QcmV0dHlfcHJpbnRlclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlByaW50ZiAqKVxubW9kdWxlIFByaW50ZiA9IEJhc2VfX1ByaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlF1ZXVlICopXG5tb2R1bGUgUXVldWUgPSBCYXNlX19RdWV1ZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlF1ZXVlX2ludGYgKilcbm1vZHVsZSBRdWV1ZV9pbnRmID0gQmFzZV9fUXVldWVfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlJhbmRvbSAqKVxubW9kdWxlIFJhbmRvbSA9IEJhc2VfX1JhbmRvbVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlJhbmRvbV9yZXByICopXG5tb2R1bGUgUmFuZG9tX3JlcHIgPSBCYXNlX19SYW5kb21fcmVwclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlJlZiAqKVxubW9kdWxlIFJlZiA9IEJhc2VfX1JlZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlJlc3VsdCAqKVxubW9kdWxlIFJlc3VsdCA9IEJhc2VfX1Jlc3VsdFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlNlcXVlbmNlICopXG5tb2R1bGUgU2VxdWVuY2UgPSBCYXNlX19TZXF1ZW5jZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlNldCAqKVxubW9kdWxlIFNldCA9IEJhc2VfX1NldFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlNldF9pbnRmICopXG5tb2R1bGUgU2V0X2ludGYgPSBCYXNlX19TZXRfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlNleHAgKilcbm1vZHVsZSBTZXhwID0gQmFzZV9fU2V4cFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlNleHBfd2l0aF9jb21wYXJhYmxlICopXG5tb2R1bGUgU2V4cF93aXRoX2NvbXBhcmFibGUgPSBCYXNlX19TZXhwX3dpdGhfY29tcGFyYWJsZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlNleHBhYmxlICopXG5tb2R1bGUgU2V4cGFibGUgPSBCYXNlX19TZXhwYWJsZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlNpZ24gKilcbm1vZHVsZSBTaWduID0gQmFzZV9fU2lnblxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlNpZ24wICopXG5tb2R1bGUgU2lnbjAgPSBCYXNlX19TaWduMFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlNpZ25fb3JfbmFuICopXG5tb2R1bGUgU2lnbl9vcl9uYW4gPSBCYXNlX19TaWduX29yX25hblxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlNvdXJjZV9jb2RlX3Bvc2l0aW9uICopXG5tb2R1bGUgU291cmNlX2NvZGVfcG9zaXRpb24gPSBCYXNlX19Tb3VyY2VfY29kZV9wb3NpdGlvblxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlNvdXJjZV9jb2RlX3Bvc2l0aW9uMCAqKVxubW9kdWxlIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMCA9IEJhc2VfX1NvdXJjZV9jb2RlX3Bvc2l0aW9uMFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlN0YWNrICopXG5tb2R1bGUgU3RhY2sgPSBCYXNlX19TdGFja1xuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlN0YWNrX2ludGYgKilcbm1vZHVsZSBTdGFja19pbnRmID0gQmFzZV9fU3RhY2tfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlN0YWdlZCAqKVxubW9kdWxlIFN0YWdlZCA9IEJhc2VfX1N0YWdlZFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlN0cmluZyAqKVxubW9kdWxlIFN0cmluZyA9IEJhc2VfX1N0cmluZ1xuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlN0cmluZzAgKilcbm1vZHVsZSBTdHJpbmcwID0gQmFzZV9fU3RyaW5nMFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlN0cmluZ19pbnRmICopXG5tb2R1bGUgU3RyaW5nX2ludGYgPSBCYXNlX19TdHJpbmdfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlN0cmluZ2FibGUgKilcbm1vZHVsZSBTdHJpbmdhYmxlID0gQmFzZV9fU3RyaW5nYWJsZVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlN5cyAqKVxubW9kdWxlIFN5cyA9IEJhc2VfX1N5c1xuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlN5czAgKilcbm1vZHVsZSBTeXMwID0gQmFzZV9fU3lzMFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlQgKilcbm1vZHVsZSBUID0gQmFzZV9fVFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlR5cGVfZXF1YWwgKilcbm1vZHVsZSBUeXBlX2VxdWFsID0gQmFzZV9fVHlwZV9lcXVhbFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlR5cGVfZXF1YWxfaW50ZiAqKVxubW9kdWxlIFR5cGVfZXF1YWxfaW50ZiA9IEJhc2VfX1R5cGVfZXF1YWxfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlVjaGFyICopXG5tb2R1bGUgVWNoYXIgPSBCYXNlX19VY2hhclxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlVjaGFyMCAqKVxubW9kdWxlIFVjaGFyMCA9IEJhc2VfX1VjaGFyMFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlVjaGFyX2ludGYgKilcbm1vZHVsZSBVY2hhcl9pbnRmID0gQmFzZV9fVWNoYXJfaW50ZlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlVuaWZvcm1fYXJyYXkgKilcbm1vZHVsZSBVbmlmb3JtX2FycmF5ID0gQmFzZV9fVW5pZm9ybV9hcnJheVxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlVuaXQgKilcbm1vZHVsZSBVbml0ID0gQmFzZV9fVW5pdFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlZhcmlhbnQgKilcbm1vZHVsZSBWYXJpYW50ID0gQmFzZV9fVmFyaWFudFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLlZhcmlhbnRzbGliICopXG5tb2R1bGUgVmFyaWFudHNsaWIgPSBCYXNlX19WYXJpYW50c2xpYlxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLldpdGhfcmV0dXJuICopXG5tb2R1bGUgV2l0aF9yZXR1cm4gPSBCYXNlX19XaXRoX3JldHVyblxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLldvcmRfc2l6ZSAqKVxubW9kdWxlIFdvcmRfc2l6ZSA9IEJhc2VfX1dvcmRfc2l6ZVxuXG5tb2R1bGUgQmFzZV9fID0gc3RydWN0IGVuZFxuW0BAZGVwcmVjYXRlZCBcInRoaXMgbW9kdWxlIGlzIHNoYWRvd2VkXCJdXG4iLCIoKiBUaGUgW2dsb2JhbGl6ZV97Ym9vbCxjaGFyLHVuaXR9XSBmdW5jdGlvbnMgYXJlIHdyaXR0ZW4gYXMgbWF0Y2hlcyBwbHVzIHRoZSBpZGVudGl0eVxuICAgZnVuY3Rpb24gc28gdGhhdCB0aGUgdHlwZSBjaGVja2VyIGNhbiBnaXZlIHRoZW0gdGhlIGRlc2lyZWQgdHlwZSwgd2l0aG91dCBoYXZpbmcgdG8gZG9cbiAgIGFueXRoaW5nIHNwZWNpYWwuICBIb3dldmVyLCBbZ2xvYmFsaXplX2ludF0gY2Fubm90IGJlIHdyaXR0ZW4gdGhpcyB3YXksIHNvIHdlIHJlc29ydCB0b1xuICAgdXNpbmcgYW4gW2V4dGVybmFsXS4gKilcblxubGV0IGdsb2JhbGl6ZV9ib29sID0gZnVuY3Rpb25cbiAgfCAodHJ1ZSB8IGZhbHNlKSBhcyBiIC0+IGJcbjs7XG5cbmxldCBnbG9iYWxpemVfY2hhciA9IGZ1bmN0aW9uXG4gIHwgJ1xceDAwJyAuLiAnXFx4RkYnIGFzIGMgLT4gY1xuOztcblxuZXh0ZXJuYWwgZ2xvYmFsaXplX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfb2JqX2R1cFwiXG5leHRlcm5hbCBnbG9iYWxpemVfaW50IDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGdsb2JhbGl6ZV9pbnQzMiA6IGludDMyIC0+IGludDMyID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgZ2xvYmFsaXplX2ludDY0IDogaW50NjQgLT4gaW50NjQgPSBcImNhbWxfb2JqX2R1cFwiXG5leHRlcm5hbCBnbG9iYWxpemVfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiY2FtbF9vYmpfZHVwXCJcbmV4dGVybmFsIGdsb2JhbGl6ZV9ieXRlcyA6IGJ5dGVzIC0+IGJ5dGVzID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgZ2xvYmFsaXplX3N0cmluZyA6IHN0cmluZyAtPiBzdHJpbmcgPSBcImNhbWxfb2JqX2R1cFwiXG5cbmxldCBnbG9iYWxpemVfdW5pdCAoKCkgYXMgdSkgPSB1XG5cbmV4dGVybmFsIGdsb2JhbGl6ZV9hcnJheScgOiAnYSBhcnJheSAtPiAnYSBhcnJheSA9IFwiY2FtbF9vYmpfZHVwXCJcblxubGV0IGdsb2JhbGl6ZV9hcnJheSBfIGEgPSBnbG9iYWxpemVfYXJyYXknIGFcblxubGV0IHJlYyBnbG9iYWxpemVfbGlzdCBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IHggOjogeHMgLT4gZiB4IDo6IGdsb2JhbGl6ZV9saXN0IGYgeHNcbjs7XG5cbmxldCBnbG9iYWxpemVfb3B0aW9uIGYgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgeCAtPiBTb21lIChmIHgpXG47O1xuXG5sZXQgZ2xvYmFsaXplX3Jlc3VsdCBnbG9iYWxpemVfYSBnbG9iYWxpemVfYiB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgT2sgYSAtPiBPayAoZ2xvYmFsaXplX2EgYSlcbiAgfCBFcnJvciBiIC0+IEVycm9yIChnbG9iYWxpemVfYiBiKVxuOztcblxubGV0IGdsb2JhbGl6ZV9yZWYnIHIgPSByZWYgIXJcbmxldCBnbG9iYWxpemVfcmVmIF8gciA9IGdsb2JhbGl6ZV9yZWYnIHJcblxuZXh0ZXJuYWwgZ2xvYmFsaXplX2xhenlfdF9tb25vIDogJ2EgbGF6eV90IC0+ICdhIGxhenlfdCA9IFwiJWlkZW50aXR5XCJcblxubGV0IGdsb2JhbGl6ZV9sYXp5X3QgXyB0ID0gZ2xvYmFsaXplX2xhenlfdF9tb25vIHRcbiIsIigqKiBQcmltaXRpdmVzIGZvciBwb2x5bW9ycGhpYyBjb21wYXJlLiAqKVxuXG4oKl8gUG9seW1vcnBoaWMgY29tcGlsZXIgcHJpbWl0aXZlcyBjYW4ndCBiZSBhbGlhc2VzIGFzIHRoaXMgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICBpbmxpbmluZy4gKElmIGFsaWFzZWQgd2l0aG91dCBhIHR5cGUgYW5ub3RhdGlvbiwgdGhlIGNvbXBpbGVyIHdvdWxkIGltcGxlbWVudCB0aGVtXG4gIHVzaW5nIHRoZSBnZW5lcmljIGNvZGUgZG9pbmcgYSBDIGNhbGwsIGFuZCBpdCdzIHRoaXMgY29kZSB0aGF0IHdvdWxkIGJlIGlubGluZWQuKSBBcyBhXG4gIHJlc3VsdCB3ZSBoYXZlIHRvIGNvcHkgdGhlIFtleHRlcm5hbCAuLi5dIGRlY2xhcmF0aW9uIGhlcmUuICopXG5leHRlcm5hbCAoIDwgKSA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuZXh0ZXJuYWwgKCA8PiApIDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoID0gKSA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA+ICkgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbmV4dGVybmFsICggPj0gKSA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGFzY2VuZGluZyA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5leHRlcm5hbCBlcXVhbCA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXF1YWxcIlxuXG5sZXQgZGVzY2VuZGluZyB4IHkgPSBjb21wYXJlIHkgeFxubGV0IG1heCB4IHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG5sZXQgbWluIHggeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbiIsIigqIFRoaXMgbW9kdWxlIGlzIGluY2x1ZGVkIGluIFtJbXBvcnRdLiAgSXQgaXMgYWltZWQgYXQgbW9kdWxlcyB0aGF0IGRlZmluZSB0aGUgc3RhbmRhcmRcbiAgIGNvbWJpbmF0b3JzIGZvciBbc2V4cF9vZl0sIFtvZl9zZXhwXSwgW2NvbXBhcmVdIGFuZCBbaGFzaF0gYW5kIGFyZSBpbmNsdWRlZCBpblxuICAgW0ltcG9ydF0uICopXG5cbmluY2x1ZGUgKFxuICBTaGFkb3dfc3RkbGliIDpcbiAgICBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgU2hhZG93X3N0ZGxpYlxuICAgIGVuZFxuICAgIHdpdGggdHlwZSAnYSByZWYgOj0gJ2EgcmVmXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgOj0gKCdhLCAnYiwgJ2MpIGZvcm1hdFxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgOj0gKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IDo9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG4gICAgKCogVGhlc2UgbW9kdWxlcyBhcmUgcmVkZWZpbmVkIGluIEJhc2UgKilcbiAgICB3aXRoIG1vZHVsZSBBcnJheSA6PSBTaGFkb3dfc3RkbGliLkFycmF5XG4gICAgd2l0aCBtb2R1bGUgQXRvbWljIDo9IFNoYWRvd19zdGRsaWIuQXRvbWljXG4gICAgd2l0aCBtb2R1bGUgQm9vbCA6PSBTaGFkb3dfc3RkbGliLkJvb2xcbiAgICB3aXRoIG1vZHVsZSBCdWZmZXIgOj0gU2hhZG93X3N0ZGxpYi5CdWZmZXJcbiAgICB3aXRoIG1vZHVsZSBCeXRlcyA6PSBTaGFkb3dfc3RkbGliLkJ5dGVzXG4gICAgd2l0aCBtb2R1bGUgQ2hhciA6PSBTaGFkb3dfc3RkbGliLkNoYXJcbiAgICB3aXRoIG1vZHVsZSBFaXRoZXIgOj0gU2hhZG93X3N0ZGxpYi5FaXRoZXJcbiAgICB3aXRoIG1vZHVsZSBGbG9hdCA6PSBTaGFkb3dfc3RkbGliLkZsb2F0XG4gICAgd2l0aCBtb2R1bGUgSGFzaHRibCA6PSBTaGFkb3dfc3RkbGliLkhhc2h0YmxcbiAgICB3aXRoIG1vZHVsZSBJbnQgOj0gU2hhZG93X3N0ZGxpYi5JbnRcbiAgICB3aXRoIG1vZHVsZSBJbnQzMiA6PSBTaGFkb3dfc3RkbGliLkludDMyXG4gICAgd2l0aCBtb2R1bGUgSW50NjQgOj0gU2hhZG93X3N0ZGxpYi5JbnQ2NFxuICAgIHdpdGggbW9kdWxlIExhenkgOj0gU2hhZG93X3N0ZGxpYi5MYXp5XG4gICAgd2l0aCBtb2R1bGUgTGlzdCA6PSBTaGFkb3dfc3RkbGliLkxpc3RcbiAgICB3aXRoIG1vZHVsZSBNYXAgOj0gU2hhZG93X3N0ZGxpYi5NYXBcbiAgICB3aXRoIG1vZHVsZSBOYXRpdmVpbnQgOj0gU2hhZG93X3N0ZGxpYi5OYXRpdmVpbnRcbiAgICB3aXRoIG1vZHVsZSBPcHRpb24gOj0gU2hhZG93X3N0ZGxpYi5PcHRpb25cbiAgICB3aXRoIG1vZHVsZSBQcmludGYgOj0gU2hhZG93X3N0ZGxpYi5QcmludGZcbiAgICB3aXRoIG1vZHVsZSBRdWV1ZSA6PSBTaGFkb3dfc3RkbGliLlF1ZXVlXG4gICAgd2l0aCBtb2R1bGUgUmFuZG9tIDo9IFNoYWRvd19zdGRsaWIuUmFuZG9tXG4gICAgd2l0aCBtb2R1bGUgUmVzdWx0IDo9IFNoYWRvd19zdGRsaWIuUmVzdWx0XG4gICAgd2l0aCBtb2R1bGUgU2V0IDo9IFNoYWRvd19zdGRsaWIuU2V0XG4gICAgd2l0aCBtb2R1bGUgU3RhY2sgOj0gU2hhZG93X3N0ZGxpYi5TdGFja1xuICAgIHdpdGggbW9kdWxlIFN0cmluZyA6PSBTaGFkb3dfc3RkbGliLlN0cmluZ1xuICAgIHdpdGggbW9kdWxlIFN5cyA6PSBTaGFkb3dfc3RkbGliLlN5c1xuICAgIHdpdGggbW9kdWxlIFVjaGFyIDo9IFNoYWRvd19zdGRsaWIuVWNoYXJcbiAgICB3aXRoIG1vZHVsZSBVbml0IDo9IFNoYWRvd19zdGRsaWIuVW5pdClcbltAb2NhbWwud2FybmluZyBcIi0zXCJdXG5cbnR5cGUgJ2EgcmVmID0gJ2EgU3RkbGliLnJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cblxuKCogUmVzaHVmZmxlIFtTdGRsaWJdIHNvIHRoYXQgd2UgY2hvb3NlIHRoZSBtb2R1bGVzIHVzaW5nIGxhYmVscyB3aGVuIGF2YWlsYWJsZS4gKilcbm1vZHVsZSBTdGRsaWIgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTdGRsaWJcbiAgaW5jbHVkZSBTdGRsaWIuU3RkTGFiZWxzXG4gIGluY2x1ZGUgU3RkbGliLk1vcmVMYWJlbHNcbmVuZFxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoKCdhIC0+ICdiKVtAbG9jYWxfb3B0XSkgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5cbigqIFRoZXNlIG5lZWQgdG8gYmUgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgdG8gZ2V0IHRoZSBsYXp5IGJlaGF2aW9yICopXG5leHRlcm5hbCAoICYmICkgOiAoYm9vbFtAbG9jYWxfb3B0XSkgLT4gKGJvb2xbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggfHwgKSA6IChib29sW0Bsb2NhbF9vcHRdKSAtPiAoYm9vbFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5leHRlcm5hbCBub3QgOiAoYm9vbFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuXG4oKiBXZSB1c2UgW09iai5tYWdpY10gaGVyZSBhcyBvdGhlciBpbXBsZW1lbnRhdGlvbnMgZ2VuZXJhdGUgYSBjb25kaXRpb25hbCBqdW1wIGFuZCB0aGVcbiAgIHBlcmZvcm1hbmNlIGRpZmZlcmVuY2UgaXMgbm90aWNlYWJsZS4gKilcbmxldCBib29sX3RvX2ludCAoeCA6IGJvb2wpIDogaW50ID0gU3RkbGliLk9iai5tYWdpYyB4XG5cbigqIFRoaXMgbmVlZHMgdG8gYmUgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgZm9yIHRoZSB3YXJuaW5ncyB0byB3b3JrIHByb3Blcmx5ICopXG5leHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG5sZXQgKCAhPSApID0gU3RkbGliLiggIT0gKVxubGV0ICggKiApID0gU3RkbGliLiggKiApXG5sZXQgKCAqKiApID0gU3RkbGliLiggKiogKVxubGV0ICggKi4gKSA9IFN0ZGxpYi4oICouIClcbmxldCAoICsgKSA9IFN0ZGxpYi4oICsgKVxubGV0ICggKy4gKSA9IFN0ZGxpYi4oICsuIClcbmxldCAoIC0gKSA9IFN0ZGxpYi4oIC0gKVxubGV0ICggLS4gKSA9IFN0ZGxpYi4oIC0uIClcbmxldCAoIC8gKSA9IFN0ZGxpYi4oIC8gKVxubGV0ICggLy4gKSA9IFN0ZGxpYi4oIC8uIClcblxubW9kdWxlIFBvbHkgPSBQb2x5MCAoKiogQGNhbm9uaWNhbCBCYXNlLlBvbHkgKilcblxubW9kdWxlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgKCogRGVjbGFyZWQgYXMgZXh0ZXJuYWxzIHNvIHRoYXQgdGhlIGNvbXBpbGVyIHNraXBzIHRoZSBjYW1sX2FwcGx5X1ggd3JhcHBpbmcgZXZlbiB3aGVuXG4gICAgIGNvbXBpbGluZyB3aXRob3V0IGNyb3NzIGxpYnJhcnkgaW5saW5pbmcuICopXG4gIGV4dGVybmFsICggPSApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8PiApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8ICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuICBleHRlcm5hbCAoID4gKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG4gIGV4dGVybmFsICggPD0gKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuICBleHRlcm5hbCAoID49ICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbiAgZXh0ZXJuYWwgY29tcGFyZSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuICBleHRlcm5hbCBjb21wYXJlX19sb2NhbCA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuICBleHRlcm5hbCBlcXVhbCA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG4gIGV4dGVybmFsIGVxdWFsX19sb2NhbCA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IGludCkgeSA9IGNvbXBhcmUgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogaW50KSB5ID0gY29tcGFyZSB5IHhcbiAgbGV0IG1heCAoeCA6IGludCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA+PSB5KSB4IHlcbiAgbGV0IG1pbiAoeCA6IGludCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG5pbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubW9kdWxlIEludDMyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBTdGRsaWIuSW50MzIudCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBTdGRsaWIuSW50MzIudCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBTdGRsaWIuSW50MzIudCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBTdGRsaWIuSW50MzIudCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBTdGRsaWIuSW50MzIudCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBTdGRsaWIuSW50MzIudCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGNvbXBhcmVfX2xvY2FsICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IGVxdWFsX19sb2NhbCAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IFN0ZGxpYi5JbnQzMi50KSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogU3RkbGliLkludDMyLnQpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxubW9kdWxlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICAoKiBEZWNsYXJlZCBhcyBleHRlcm5hbHMgc28gdGhhdCB0aGUgY29tcGlsZXIgc2tpcHMgdGhlIGNhbWxfYXBwbHlfWCB3cmFwcGluZyBldmVuIHdoZW5cbiAgICAgY29tcGlsaW5nIHdpdGhvdXQgY3Jvc3MgbGlicmFyeSBpbmxpbmluZy4gKilcbiAgZXh0ZXJuYWwgKCA9IClcbiAgICA6ICAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGJvb2xcbiAgICA9IFwiJWVxdWFsXCJcblxuICBleHRlcm5hbCAoIDw+IClcbiAgICA6ICAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IGJvb2xcbiAgICA9IFwiJW5vdGVxdWFsXCJcblxuICBleHRlcm5hbCAoIDwgKVxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gYm9vbFxuICAgID0gXCIlbGVzc3RoYW5cIlxuXG4gIGV4dGVybmFsICggPiApXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBib29sXG4gICAgPSBcIiVncmVhdGVydGhhblwiXG5cbiAgZXh0ZXJuYWwgKCA8PSApXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBib29sXG4gICAgPSBcIiVsZXNzZXF1YWxcIlxuXG4gIGV4dGVybmFsICggPj0gKVxuICAgIDogIChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoU3RkbGliLkludDY0LnRbQGxvY2FsX29wdF0pXG4gICAgLT4gYm9vbFxuICAgID0gXCIlZ3JlYXRlcmVxdWFsXCJcblxuICBleHRlcm5hbCBjb21wYXJlXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBpbnRcbiAgICA9IFwiJWNvbXBhcmVcIlxuXG4gIGV4dGVybmFsIGNvbXBhcmVfX2xvY2FsXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBpbnRcbiAgICA9IFwiJWNvbXBhcmVcIlxuXG4gIGV4dGVybmFsIGVxdWFsXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBib29sXG4gICAgPSBcIiVlcXVhbFwiXG5cbiAgZXh0ZXJuYWwgZXF1YWxfX2xvY2FsXG4gICAgOiAgKFN0ZGxpYi5JbnQ2NC50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChTdGRsaWIuSW50NjQudFtAbG9jYWxfb3B0XSlcbiAgICAtPiBib29sXG4gICAgPSBcIiVlcXVhbFwiXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IFN0ZGxpYi5JbnQ2NC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogU3RkbGliLkludDY0LnQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBtYXggKHggOiBTdGRsaWIuSW50NjQudCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA+PSB5KSB4IHlcbiAgbGV0IG1pbiAoeCA6IFN0ZGxpYi5JbnQ2NC50KSB5ID0gQm9vbDAuc2VsZWN0ICh4IDw9IHkpIHggeVxuZW5kXG5cbm1vZHVsZSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IFN0ZGxpYi5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IFN0ZGxpYi5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgY29tcGFyZV9fbG9jYWwgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IFN0ZGxpYi5OYXRpdmVpbnQudCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBlcXVhbF9fbG9jYWwgKHggOiBTdGRsaWIuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogU3RkbGliLk5hdGl2ZWludC50KSB5ID0gQm9vbDAuc2VsZWN0ICh4IDw9IHkpIHggeVxuZW5kXG5cbm1vZHVsZSBCb29sX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogYm9vbCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IGJvb2wpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogYm9vbCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGNvbXBhcmVfX2xvY2FsICh4IDogYm9vbCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogYm9vbCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBlcXVhbF9fbG9jYWwgKHggOiBib29sKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGJvb2wpIHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBtaW4gKHggOiBib29sKSB5ID0gQm9vbDAuc2VsZWN0ICh4IDw9IHkpIHggeVxuZW5kXG5cbm1vZHVsZSBDaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogY2hhcikgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogY2hhcikgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogY2hhcikgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IGNoYXIpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogY2hhcikgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGNvbXBhcmVfX2xvY2FsICh4IDogY2hhcikgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogY2hhcikgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBlcXVhbF9fbG9jYWwgKHggOiBjaGFyKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGNoYXIpIHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBtaW4gKHggOiBjaGFyKSB5ID0gQm9vbDAuc2VsZWN0ICh4IDw9IHkpIHggeVxuZW5kXG5cbm1vZHVsZSBVY2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgb3BlbiBzdHJ1Y3RcbiAgICBleHRlcm5hbCBpIDogKFN0ZGxpYi5VY2hhci50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG4gIGVuZFxuXG4gIGxldCAoIDwgKSAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA8PSApICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA8PiApICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD4gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA9ICkgKHggOiBTdGRsaWIuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPiApICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPiApIChpIHgpIChpIHkpXG4gIGxldCAoID49ICkgKHggOiBTdGRsaWIuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIChpIHgpIChpIHkpXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID1cbiAgICBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmFzY2VuZGluZyAoaSB4KSAoaSB5KVxuICA7O1xuXG4gIGxldCBkZXNjZW5kaW5nICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPVxuICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZGVzY2VuZGluZyAoaSB4KSAoaSB5KVxuICA7O1xuXG4gIGxldCBjb21wYXJlICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmUgKGkgeCkgKGkgeSlcbiAgbGV0IGVxdWFsICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIChpIHgpIChpIHkpXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPVxuICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuY29tcGFyZV9fbG9jYWwgKGkgeCkgKGkgeSlcbiAgOztcblxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPVxuICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWxfX2xvY2FsIChpIHgpIChpIHkpXG4gIDs7XG5cbiAgbGV0IG1heCAoeCA6IFN0ZGxpYi5VY2hhci50KSB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgbWluICh4IDogU3RkbGliLlVjaGFyLnQpIHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG5lbmRcblxubW9kdWxlIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBleHRlcm5hbCAoIDwgKSA6IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gKGZsb2F0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuICBleHRlcm5hbCAoIDw9ICkgOiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG4gIGV4dGVybmFsICggPD4gKSA6IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gKGZsb2F0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuICBleHRlcm5hbCAoID0gKSA6IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gKGZsb2F0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXF1YWxcIlxuICBleHRlcm5hbCAoID4gKSA6IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gKGZsb2F0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuICBleHRlcm5hbCAoID49ICkgOiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG4gIGV4dGVybmFsIGVxdWFsIDogKGZsb2F0W0Bsb2NhbF9vcHRdKSAtPiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG4gIGV4dGVybmFsIGNvbXBhcmUgOiAoZmxvYXRbQGxvY2FsX29wdF0pIC0+IChmbG9hdFtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IGZsb2F0KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogZmxvYXQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlX19sb2NhbCAoeCA6IGZsb2F0KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogZmxvYXQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogZmxvYXQpIHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBtaW4gKHggOiBmbG9hdCkgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG5tb2R1bGUgU3RyaW5nX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogc3RyaW5nKSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogc3RyaW5nKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IHN0cmluZykgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGNvbXBhcmVfX2xvY2FsICh4IDogc3RyaW5nKSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogc3RyaW5nKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IHN0cmluZykgeSA9IEJvb2wwLnNlbGVjdCAoeCA+PSB5KSB4IHlcbiAgbGV0IG1pbiAoeCA6IHN0cmluZykgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG5tb2R1bGUgQnl0ZXNfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IGJ5dGVzKSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IGJ5dGVzKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IGJ5dGVzKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGJ5dGVzKSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBieXRlcykgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IGJ5dGVzKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGJ5dGVzKSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgY29tcGFyZV9fbG9jYWwgKHggOiBieXRlcykgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogYnl0ZXMpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogYnl0ZXMpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogYnl0ZXMpIHkgPSBCb29sMC5zZWxlY3QgKHggPj0geSkgeCB5XG4gIGxldCBtaW4gKHggOiBieXRlcykgeSA9IEJvb2wwLnNlbGVjdCAoeCA8PSB5KSB4IHlcbmVuZFxuXG4oKiBUaGlzIG5lZWRzIHRvIGJlIGRlZmluZWQgYXMgYW4gZXh0ZXJuYWwgc28gdGhhdCB0aGUgY29tcGlsZXIgY2FuIHNwZWNpYWxpemUgaXQgYXMgYVxuICAgZGlyZWN0IHNldCBvciBjYW1sX21vZGlmeS4gKilcbmV4dGVybmFsICggOj0gKSA6ICgnYSByZWZbQGxvY2FsX29wdF0pIC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuXG4oKiBUaGVzZSBuZWVkIHRvIGJlIGRlZmluZWQgYXMgYW4gZXh0ZXJuYWwgb3RoZXJ3aXNlIHRoZSBjb21waWxlciB3b24ndCB1bmJveFxuICAgcmVmZXJlbmNlcy4gKilcbmV4dGVybmFsICggISApIDogKCdhIHJlZltAbG9jYWxfb3B0XSkgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgcmVmIDogJ2EgLT4gKCdhIHJlZltAbG9jYWxfb3B0XSkgPSBcIiVtYWtlbXV0YWJsZVwiXG5cbmxldCAoIEAgKSA9IFN0ZGxpYi4oIEAgKVxubGV0ICggXiApID0gU3RkbGliLiggXiApXG5sZXQgKCB+LSApID0gU3RkbGliLiggfi0gKVxubGV0ICggfi0uICkgPSBTdGRsaWIuKCB+LS4gKVxubGV0ICggYXNyICkgPSBTdGRsaWIuKCBhc3IgKVxubGV0ICggbGFuZCApID0gU3RkbGliLiggbGFuZCApXG5sZXQgbG5vdCA9IFN0ZGxpYi5sbm90XG5sZXQgKCBsb3IgKSA9IFN0ZGxpYi4oIGxvciApXG5sZXQgKCBsc2wgKSA9IFN0ZGxpYi4oIGxzbCApXG5sZXQgKCBsc3IgKSA9IFN0ZGxpYi4oIGxzciApXG5sZXQgKCBseG9yICkgPSBTdGRsaWIuKCBseG9yIClcbmxldCAoIG1vZCApID0gU3RkbGliLiggbW9kIClcbmxldCBhYnMgPSBTdGRsaWIuYWJzXG5sZXQgZmFpbHdpdGggPSBTdGRsaWIuZmFpbHdpdGhcbmxldCBmc3QgPSBTdGRsaWIuZnN0XG5sZXQgaW52YWxpZF9hcmcgPSBTdGRsaWIuaW52YWxpZF9hcmdcbmxldCBzbmQgPSBTdGRsaWIuc25kXG5cbigqIFtyYWlzZV0gbmVlZHMgdG8gYmUgZGVmaW5lZCBhcyBhbiBleHRlcm5hbCBhcyB0aGUgY29tcGlsZXIgYXV0b21hdGljYWxseSByZXBsYWNlc1xuICAgJyVyYWlzZScgYnkgJyVyZXJhaXNlJyB3aGVuIGFwcHJvcHJpYXRlLiAqKVxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gXyA9IFwiJXJhaXNlXCJcbmV4dGVybmFsIHBoeXNfZXF1YWwgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsIGRlY3IgOiAoaW50IHJlZltAbG9jYWxfb3B0XSkgLT4gdW5pdCA9IFwiJWRlY3JcIlxuZXh0ZXJuYWwgaW5jciA6IChpbnQgcmVmW0Bsb2NhbF9vcHRdKSAtPiB1bml0ID0gXCIlaW5jclwiXG5cbigqIFVzZWQgYnkgc2V4cF9jb252LCB3aGljaCBmbG9hdDAgZGVwZW5kcyBvbiB0aHJvdWdoIG9wdGlvbi4gKilcbmxldCBmbG9hdF9vZl9zdHJpbmcgPSBTdGRsaWIuZmxvYXRfb2Zfc3RyaW5nXG5cbigqIFthbV90ZXN0aW5nXSBpcyB1c2VkIGluIGEgZmV3IHBsYWNlcyB0byBiZWhhdmUgZGlmZmVyZW50bHkgd2hlbiBpbiB0ZXN0aW5nIG1vZGUsIHN1Y2hcbiAgIGFzIGluIFtyYW5kb20ubWxdLiAgW2FtX3Rlc3RpbmddIGlzIGltcGxlbWVudGVkIHVzaW5nIFtCYXNlX2FtX3Rlc3RpbmddLCBhIHdlYWsgQy9qc1xuICAgcHJpbWl0aXZlIHRoYXQgcmV0dXJucyBbZmFsc2VdLCBidXQgd2hlbiBsaW5raW5nIGFuIGlubGluZS10ZXN0LXJ1bm5lciBleGVjdXRhYmxlLCBpc1xuICAgb3ZlcnJpZGRlbiBieSBhbm90aGVyIHByaW1pdGl2ZSB0aGF0IHJldHVybnMgW3RydWVdLiAqKVxuZXh0ZXJuYWwgYW1fdGVzdGluZyA6IHVuaXQgLT4gYm9vbCA9IFwiQmFzZV9hbV90ZXN0aW5nXCJcblxubGV0IGFtX3Rlc3RpbmcgPSBhbV90ZXN0aW5nICgpXG4iLCIoKiBbSW50MF0gZGVmaW5lcyBpbnRlZ2VyIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHlcbiAgIGRlZmluZWQgaW4gdGVybXMgb2YgW1N0ZGxpYl0uIFtJbnQwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlXG4gICBwYXJ0IG9mIFtTdGRsaWJdIHRoYXQgW0Jhc2VdIHVzZXMgZm9yIGludGVnZXJzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlclxuICAgdGhhbiBpbnQwLm1sIHNob3VsZCB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRocm91Z2ggW1N0ZGxpYl0uIFtJbnQwXSBoYXNcbiAgIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLlxuXG4gICBBbGwgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGludHMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkludF0gaW4gYnVpbGRcbiAgIG9yZGVyIHNob3VsZCBkbzpcblxuICAge1tcbiAgICAgbW9kdWxlIEludCAgPSBJbnQwXG4gICBdfVxuXG4gICBEZWZpbmluZyBbbW9kdWxlIEludCA9IEludDBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXQgcHJldmVudHMgb2NhbWxkZXBcbiAgIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuSW50XS4gKilcblxubGV0IHRvX3N0cmluZyA9IFN0ZGxpYi5zdHJpbmdfb2ZfaW50XG5sZXQgb2Zfc3RyaW5nID0gU3RkbGliLmludF9vZl9zdHJpbmdcbmxldCBvZl9zdHJpbmdfb3B0ID0gU3RkbGliLmludF9vZl9zdHJpbmdfb3B0XG5sZXQgdG9fZmxvYXQgPSBTdGRsaWIuZmxvYXRfb2ZfaW50XG5sZXQgb2ZfZmxvYXQgPSBTdGRsaWIuaW50X29mX2Zsb2F0XG5sZXQgbWF4X3ZhbHVlID0gU3RkbGliLm1heF9pbnRcbmxldCBtaW5fdmFsdWUgPSBTdGRsaWIubWluX2ludFxubGV0IHN1Y2MgPSBTdGRsaWIuc3VjY1xubGV0IHByZWQgPSBTdGRsaWIucHJlZFxuIiwib3BlbiEgSW1wb3J0MFxuaW5jbHVkZSBTdGRsaWIuUHJpbnRmXG5cbigqKiBmYWlsd2l0aCwgaW52YWxpZF9hcmcsIGFuZCBleGl0IGFjY2VwdGluZyBwcmludGYncyBmb3JtYXQuICopXG5cbmxldFtAaW5saW5lIG5ldmVyXSBbQHplcm9fYWxsb2MgYXNzdW1lIG5ldmVyX3JldHVybnNfbm9ybWFsbHldIGZhaWx3aXRoZiBmbXQgPVxuICBrc3ByaW50ZiAoZnVuIHMgKCkgLT4gZmFpbHdpdGggcykgZm10XG47O1xuXG5sZXRbQGlubGluZSBuZXZlcl0gW0B6ZXJvX2FsbG9jIGFzc3VtZSBuZXZlcl9yZXR1cm5zX25vcm1hbGx5XSBpbnZhbGlkX2FyZ2YgZm10ID1cbiAga3NwcmludGYgKGZ1biBzICgpIC0+IGludmFsaWRfYXJnIHMpIGZtdFxuOztcbiIsIigqIFtTeXMwXSBkZWZpbmVzIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpblxuICAgdGVybXMgb2YgW1N0ZGxpYi5TeXNdLiAgW1N5czBdIGlzIGludGVuZGVkIHRvIGNvbXBsZXRlbHkgZXhwcmVzcyB0aGUgcGFydCBvZlxuICAgW1N0ZGxpYi5TeXNdIHRoYXQgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gc3lzLm1sXG4gICBzaG91bGQgdXNlIFtTdGRsaWIuU3lzXS4gW1N5czBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlXG4gICBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGwgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIHRoZXNlXG4gICBmdW5jdGlvbnMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLlN5c10gaW4gYnVpbGQgb3JkZXIgc2hvdWxkIGRvXG4gICBbbW9kdWxlIFN5cyA9IFN5czBdLiAgRGVmaW5pbmcgW21vZHVsZSBTeXMgPSBTeXMwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlXG4gICBpdCBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLlN5c10uICopXG5cbm9wZW4hIEltcG9ydDBcblxudHlwZSBiYWNrZW5kX3R5cGUgPSBTdGRsaWIuU3lzLmJhY2tlbmRfdHlwZSA9XG4gIHwgTmF0aXZlXG4gIHwgQnl0ZWNvZGVcbiAgfCBPdGhlciBvZiBzdHJpbmdcblxubGV0IGJhY2tlbmRfdHlwZSA9IFN0ZGxpYi5TeXMuYmFja2VuZF90eXBlXG5sZXQgaW50ZXJhY3RpdmUgPSBTdGRsaWIuU3lzLmludGVyYWN0aXZlXG5sZXQgb3NfdHlwZSA9IFN0ZGxpYi5TeXMub3NfdHlwZVxubGV0IHVuaXggPSBTdGRsaWIuU3lzLnVuaXhcbmxldCB3aW4zMiA9IFN0ZGxpYi5TeXMud2luMzJcbmxldCBjeWd3aW4gPSBTdGRsaWIuU3lzLmN5Z3dpblxubGV0IHdvcmRfc2l6ZV9pbl9iaXRzID0gU3RkbGliLlN5cy53b3JkX3NpemVcbmxldCBpbnRfc2l6ZV9pbl9iaXRzID0gU3RkbGliLlN5cy5pbnRfc2l6ZVxubGV0IGJpZ19lbmRpYW4gPSBTdGRsaWIuU3lzLmJpZ19lbmRpYW5cbmxldCBtYXhfc3RyaW5nX2xlbmd0aCA9IFN0ZGxpYi5TeXMubWF4X3N0cmluZ19sZW5ndGhcbmxldCBtYXhfYXJyYXlfbGVuZ3RoID0gU3RkbGliLlN5cy5tYXhfYXJyYXlfbGVuZ3RoXG5sZXQgcnVudGltZV92YXJpYW50ID0gU3RkbGliLlN5cy5ydW50aW1lX3ZhcmlhbnRcbmxldCBydW50aW1lX3BhcmFtZXRlcnMgPSBTdGRsaWIuU3lzLnJ1bnRpbWVfcGFyYW1ldGVyc1xubGV0IGFyZ3YgPSBTdGRsaWIuU3lzLmFyZ3ZcbmxldCBnZXRfYXJndiAoKSA9IFN0ZGxpYi5TeXMuYXJndlxubGV0IG9jYW1sX3ZlcnNpb24gPSBTdGRsaWIuU3lzLm9jYW1sX3ZlcnNpb25cbmxldCBlbmFibGVfcnVudGltZV93YXJuaW5ncyA9IFN0ZGxpYi5TeXMuZW5hYmxlX3J1bnRpbWVfd2FybmluZ3NcbmxldCBydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgPSBTdGRsaWIuU3lzLnJ1bnRpbWVfd2FybmluZ3NfZW5hYmxlZFxuXG5tb2R1bGUgTWFrZV9pbW1lZGlhdGU2NFxuICAoSW1tIDogU3RkbGliLlN5cy5JbW1lZGlhdGU2NC5JbW1lZGlhdGUpXG4gIChOb25faW1tIDogU3RkbGliLlN5cy5JbW1lZGlhdGU2NC5Ob25faW1tZWRpYXRlKSA9XG4gIFN0ZGxpYi5TeXMuSW1tZWRpYXRlNjQuTWFrZSAoSW1tKSAoTm9uX2ltbSlcblxubGV0IGdldGVudl9leG4gdmFyID1cbiAgdHJ5IFN0ZGxpYi5TeXMuZ2V0ZW52IHZhciB3aXRoXG4gIHwgU3RkbGliLk5vdF9mb3VuZCAtPlxuICAgIFByaW50Zi5mYWlsd2l0aGYgXCJTeXMuZ2V0ZW52X2V4bjogZW52aXJvbm1lbnQgdmFyaWFibGUgJXMgaXMgbm90IHNldFwiIHZhciAoKVxuOztcblxubGV0IGdldGVudiB2YXIgPVxuICBtYXRjaCBTdGRsaWIuU3lzLmdldGVudiB2YXIgd2l0aFxuICB8IHggLT4gU29tZSB4XG4gIHwgZXhjZXB0aW9uIFN0ZGxpYi5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxuZXh0ZXJuYWwgb3BhcXVlX2lkZW50aXR5IDogKCdhW0Bsb2NhbF9vcHRdKSAtPiAoJ2FbQGxvY2FsX29wdF0pID0gXCIlb3BhcXVlXCJcbmV4dGVybmFsIG9wYXF1ZV9pZGVudGl0eV9nbG9iYWwgOiAnYSAtPiAnYSA9IFwiJW9wYXF1ZVwiXG5cbmV4Y2VwdGlvbiBCcmVhayA9IFN0ZGxpYi5TeXMuQnJlYWtcbiIsIigqIFtBcnJheTBdIGRlZmluZXMgYXJyYXkgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zXG4gICBvZiBbU3RkbGliLkFycmF5XS4gIFtBcnJheTBdIGlzIGludGVuZGVkIHRvIGNvbXBsZXRlbHkgZXhwcmVzcyB0aGUgcGFydCBvZiBbU3RkbGliLkFycmF5XVxuICAgdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBhcnJheTAubWwgc2hvdWxkIHVzZSBbU3RkbGliLkFycmF5XS5cbiAgIFtBcnJheTBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGFycmF5cyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuQXJyYXldIGluIGJ1aWxkIG9yZGVyIHNob3VsZFxuICAgZG8gW21vZHVsZSBBcnJheSA9IEFycmF5MF0uICBUaGlzIGluY2x1ZGVzIHVzZXMgb2Ygc3Vic2NyaXB0IHN5bnRheCAoW3guKGkpXSwgW3guKGkpIDwtXG4gICBlXSksIHdoaWNoIHRoZSBPQ2FtbCBwYXJzZXIgZGVzdWdhcnMgaW50byBjYWxscyB0byBbQXJyYXkuZ2V0XSBhbmQgW0FycmF5LnNldF0uXG4gICBEZWZpbmluZyBbbW9kdWxlIEFycmF5ID0gQXJyYXkwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzIG9jYW1sZGVwIGZyb21cbiAgIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkFycmF5XS4gKilcblxub3BlbiEgSW1wb3J0MFxubW9kdWxlIFN5cyA9IFN5czBcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuICBleHRlcm5hbCBjcmVhdGVfbG9jYWwgOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbiAgZXh0ZXJuYWwgY3JlYXRlX2Zsb2F0X3VuaW5pdGlhbGl6ZWQgOiBpbnQgLT4gZmxvYXQgYXJyYXkgPSBcImNhbWxfbWFrZV9mbG9hdF92ZWN0XCJcbiAgZXh0ZXJuYWwgZ2V0IDogKCdhIGFycmF5W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAnYSA9IFwiJWFycmF5X3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogKCdhIGFycmF5W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuXG4gIGV4dGVybmFsIHNldFxuICAgIDogICgnYSBhcnJheVtAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+ICdhXG4gICAgLT4gdW5pdFxuICAgID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9nZXRcbiAgICA6ICAoJ2EgYXJyYXlbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAnYVxuICAgID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX3NldFxuICAgIDogICgnYSBhcnJheVtAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+ICdhXG4gICAgLT4gdW5pdFxuICAgID0gXCIlYXJyYXlfdW5zYWZlX3NldFwiXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX2JsaXRcbiAgICA6ICBzcmM6KCdhIGFycmF5W0Bsb2NhbF9vcHRdKVxuICAgIC0+IHNyY19wb3M6aW50XG4gICAgLT4gZHN0OignYSBhcnJheVtAbG9jYWxfb3B0XSlcbiAgICAtPiBkc3RfcG9zOmludFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiB1bml0XG4gICAgPSBcImNhbWxfYXJyYXlfYmxpdFwiXG5lbmRcblxuaW5jbHVkZSBBcnJheVxuXG5sZXQgbWF4X2xlbmd0aCA9IFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG5cbmxldCBjcmVhdGUgfmxlbiB4ID1cbiAgdHJ5IGNyZWF0ZSBsZW4geCB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IGludmFsaWRfYXJnZiBcIkFycmF5LmNyZWF0ZSB+bGVuOiVkOiBpbnZhbGlkIGxlbmd0aFwiIGxlbiAoKVxuOztcblxubGV0IGNyZWF0ZV9sb2NhbCB+bGVuIHggPVxuICB0cnkgY3JlYXRlX2xvY2FsIGxlbiB4IHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gaW52YWxpZF9hcmdmIFwiQXJyYXkuY3JlYXRlX2xvY2FsIH5sZW46JWQ6IGludmFsaWQgbGVuZ3RoXCIgbGVuICgpXG47O1xuXG5sZXQgY3JlYXRlX2Zsb2F0X3VuaW5pdGlhbGl6ZWQgfmxlbiA9XG4gIHRyeSBjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCBsZW4gd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPlxuICAgIGludmFsaWRfYXJnZiBcIkFycmF5LmNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIH5sZW46JWQ6IGludmFsaWQgbGVuZ3RoXCIgbGVuICgpXG47O1xuXG5sZXQgYXBwZW5kID0gU3RkbGliLkFycmF5LmFwcGVuZFxubGV0IGJsaXQgPSBTdGRsaWIuQXJyYXkuYmxpdFxubGV0IGNvbmNhdCA9IFN0ZGxpYi5BcnJheS5jb25jYXRcbmxldCBjb3B5ID0gU3RkbGliLkFycmF5LmNvcHlcbmxldCBmaWxsID0gU3RkbGliLkFycmF5LmZpbGxcblxubGV0IGluaXQgbGVuIH4oZiA6IF8gLT4gXykgPVxuICBpZiBsZW4gPSAwXG4gIHRoZW4gW3x8XVxuICBlbHNlIGlmIGxlbiA8IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmluaXRcIlxuICBlbHNlIChcbiAgICBsZXQgcmVzID0gY3JlYXRlIH5sZW4gKGYgMCkgaW5cbiAgICBmb3IgaSA9IDEgdG8gSW50MC5wcmVkIGxlbiBkb1xuICAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgIGRvbmU7XG4gICAgcmVzKVxuOztcblxubGV0IG1ha2VfbWF0cml4ID0gU3RkbGliLkFycmF5Lm1ha2VfbWF0cml4XG5sZXQgb2ZfbGlzdCA9IFN0ZGxpYi5BcnJheS5vZl9saXN0XG5sZXQgc3ViID0gU3RkbGliLkFycmF5LnN1YlxubGV0IHRvX2xpc3QgPSBTdGRsaWIuQXJyYXkudG9fbGlzdFxuXG5sZXQgZm9sZCB0IH5pbml0IH4oZiA6IF8gLT4gXyAtPiBfKSA9XG4gIGxldCByID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmU7XG4gICFyXG47O1xuXG5sZXQgZm9sZF9yaWdodCB0IH4oZiA6IF8gLT4gXyAtPiBfKSB+aW5pdCA9XG4gIGxldCByID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSBsZW5ndGggdCAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgKHVuc2FmZV9nZXQgdCBpKSAhclxuICBkb25lO1xuICAhclxuOztcblxubGV0IGl0ZXIgdCB+KGYgOiBfIC0+IF8pID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIGYgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lXG47O1xuXG5sZXQgaXRlcmkgdCB+KGYgOiBfIC0+IF8gLT4gXykgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZVxuOztcblxubGV0IG1hcCB0IH4oZiA6IF8gLT4gXykgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuID0gMFxuICB0aGVuIFt8fF1cbiAgZWxzZSAoXG4gICAgbGV0IHIgPSBjcmVhdGUgfmxlbiAoZiAodW5zYWZlX2dldCB0IDApKSBpblxuICAgIGZvciBpID0gMSB0byBsZW4gLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCB0IGkpKVxuICAgIGRvbmU7XG4gICAgcilcbjs7XG5cbmxldCBtYXBpIHQgfihmIDogXyAtPiBfIC0+IF8pID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbiA9IDBcbiAgdGhlbiBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCByID0gY3JlYXRlIH5sZW4gKGYgMCAodW5zYWZlX2dldCB0IDApKSBpblxuICAgIGZvciBpID0gMSB0byBsZW4gLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IHQgaSkpXG4gICAgZG9uZTtcbiAgICByKVxuOztcblxubGV0IHN0YWJsZV9zb3J0IHQgfmNvbXBhcmUgPSBTdGRsaWIuQXJyYXkuc3RhYmxlX3NvcnQgdCB+Y21wOmNvbXBhcmVcblxubGV0IHN3YXAgdCBpIGogPVxuICBsZXQgZWx0X2kgPSB0LihpKSBpblxuICBsZXQgZWx0X2ogPSB0LihqKSBpblxuICB1bnNhZmVfc2V0IHQgaSBlbHRfajtcbiAgdW5zYWZlX3NldCB0IGogZWx0X2lcbjs7XG4iLCIoKiBbQ2hhcjBdIGRlZmluZXMgY2hhciBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW4gdGVybXMgb2ZcbiAgIFtTdGRsaWIuQ2hhcl0uICBbQ2hhcjBdIGlzIGludGVuZGVkIHRvIGNvbXBsZXRlbHkgZXhwcmVzcyB0aGUgcGFydCBvZiBbU3RkbGliLkNoYXJdIHRoYXRcbiAgIFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIGNoYXIwLm1sIHNob3VsZCB1c2UgW1N0ZGxpYi5DaGFyXS5cbiAgIFtDaGFyMF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLiAgQWxsXG4gICBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2UgY2hhcnMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkNoYXJdIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuICAgW21vZHVsZSBDaGFyID0gQ2hhcjBdLiAgRGVmaW5pbmcgW21vZHVsZSBDaGFyID0gQ2hhcjBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXRcbiAgIHByZXZlbnRzIG9jYW1sZGVwIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuQ2hhcl0uICopXG5cbm9wZW4hIEltcG9ydDBcblxubGV0IGZhaWx3aXRoZiA9IFByaW50Zi5mYWlsd2l0aGZcbmxldCBlc2NhcGVkID0gU3RkbGliLkNoYXIuZXNjYXBlZFxubGV0IGxvd2VyY2FzZSA9IFN0ZGxpYi5DaGFyLmxvd2VyY2FzZV9hc2NpaVxubGV0IHRvX2ludCA9IFN0ZGxpYi5DaGFyLmNvZGVcbmxldCB1bnNhZmVfb2ZfaW50ID0gU3RkbGliLkNoYXIudW5zYWZlX2NoclxubGV0IHVwcGVyY2FzZSA9IFN0ZGxpYi5DaGFyLnVwcGVyY2FzZV9hc2NpaVxuXG4oKiBXZSB1c2Ugb3VyIG93biByYW5nZSB0ZXN0IHdoZW4gY29udmVydGluZyBpbnRlZ2VycyB0byBjaGFycyByYXRoZXIgdGhhblxuICAgY2FsbGluZyBbU3RkbGliLkNoYXIuY2hyXSBiZWNhdXNlIGl0J3Mgc2ltcGxlIGFuZCBpdCBzYXZlcyB1cyBhIGZ1bmN0aW9uIGNhbGxcbiAgIGFuZCB0aGUgdHJ5LXdpdGggKGV4Y2VwdGlvbnMgY29zdCwgZXNwZWNpYWxseSBpbiB0aGUgd29ybGQgd2l0aCBiYWNrdHJhY2VzKS4gKilcbmxldCBpbnRfaXNfb2sgaSA9IDAgPD0gaSAmJiBpIDw9IDI1NVxubGV0IG1pbl92YWx1ZSA9IHVuc2FmZV9vZl9pbnQgMFxubGV0IG1heF92YWx1ZSA9IHVuc2FmZV9vZl9pbnQgMjU1XG5sZXQgb2ZfaW50IGkgPSBpZiBpbnRfaXNfb2sgaSB0aGVuIFNvbWUgKHVuc2FmZV9vZl9pbnQgaSkgZWxzZSBOb25lXG5cbmxldCBvZl9pbnRfZXhuIGkgPVxuICBpZiBpbnRfaXNfb2sgaVxuICB0aGVuIHVuc2FmZV9vZl9pbnQgaVxuICBlbHNlIGZhaWx3aXRoZiBcIkNoYXIub2ZfaW50X2V4biBnb3QgaW50ZWdlciBvdXQgb2YgcmFuZ2U6ICVkXCIgaSAoKVxuOztcblxubGV0IGVxdWFsICh0MSA6IGNoYXIpIHQyID0gUG9seS5lcXVhbCB0MSB0MlxuIiwiKCogW0xpc3QwXSBkZWZpbmVzIGxpc3QgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zIG9mXG4gICBbU3RkbGliLkxpc3RdLiAgW0xpc3QwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2YgW1N0ZGxpYi5MaXN0XSB0aGF0XG4gICBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBsaXN0MC5tbCBzaG91bGQgdXNlIFtTdGRsaWIuTGlzdF0uXG4gICBbTGlzdDBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGxpc3RzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5MaXN0XSBpbiBidWlsZCBvcmRlciBzaG91bGQgZG9cbiAgIFttb2R1bGUgTGlzdCA9IExpc3QwXS4gIERlZmluaW5nIFttb2R1bGUgTGlzdCA9IExpc3QwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0XG4gICBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkxpc3RdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbmxldCBoZF9leG4gPSBTdGRsaWIuTGlzdC5oZFxubGV0IHJldl9hcHBlbmQgPSBTdGRsaWIuTGlzdC5yZXZfYXBwZW5kXG5sZXQgdGxfZXhuID0gU3RkbGliLkxpc3QudGxcbmxldCB1bnppcCA9IFN0ZGxpYi5MaXN0LnNwbGl0XG5cbigqIFNvbWUgb2YgdGhlc2UgYXJlIGV0YSBleHBhbmRlZCBpbiBvcmRlciB0byBwZXJtdXRlIHBhcmFtZXRlciBvcmRlciB0byBmb2xsb3cgQmFzZVxuICAgY29udmVudGlvbnMuICopXG5cbmxldCBsZW5ndGggPVxuICBsZXQgcmVjIGxlbmd0aF9hdXggbGVuID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGxlblxuICAgIHwgXyA6OiBsIC0+IGxlbmd0aF9hdXggKGxlbiArIDEpIGxcbiAgaW5cbiAgZnVuIGwgLT4gbGVuZ3RoX2F1eCAwIGxcbjs7XG5cbmxldCByZWMgZXhpc3RzIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBmYWxzZVxuICB8IHggOjogeHMgLT4gaWYgZiB4IHRoZW4gdHJ1ZSBlbHNlIGV4aXN0cyB4cyB+ZlxuOztcblxubGV0IHJlYyBleGlzdHMyX29rIGwxIGwyIH4oZiA6IF8gLT4gXyAtPiBfKSA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IGZhbHNlXG4gIHwgYTEgOjogbDEsIGEyIDo6IGwyIC0+IGYgYTEgYTIgfHwgZXhpc3RzMl9vayBsMSBsMiB+ZlxuICB8IF8sIF8gLT4gaW52YWxpZF9hcmcgXCJMaXN0LmV4aXN0czJcIlxuOztcblxubGV0IHJlYyBmb2xkIHQgfmluaXQgfihmIDogXyAtPiBfIC0+IF8pID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gaW5pdFxuICB8IGEgOjogbCAtPiBmb2xkIGwgfmluaXQ6KGYgaW5pdCBhKSB+ZlxuOztcblxubGV0IHJlYyBmb2xkMl9vayBsMSBsMiB+aW5pdCB+KGYgOiBfIC0+IF8gLT4gXyAtPiBfKSA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IGluaXRcbiAgfCBhMSA6OiBsMSwgYTIgOjogbDIgLT4gZm9sZDJfb2sgbDEgbDIgfmYgfmluaXQ6KGYgaW5pdCBhMSBhMilcbiAgfCBfLCBfIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX2xlZnQyXCJcbjs7XG5cbmxldCBmb3JfYWxsIHQgfmYgPSBub3QgKGV4aXN0cyB0IH5mOihmdW4geCAtPiBub3QgKGYgeCkpKVxuXG5sZXQgcmVjIGZvcl9hbGwyX29rIGwxIGwyIH4oZiA6IF8gLT4gXyAtPiBfKSA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IHRydWVcbiAgfCBhMSA6OiBsMSwgYTIgOjogbDIgLT4gZiBhMSBhMiAmJiBmb3JfYWxsMl9vayBsMSBsMiB+ZlxuICB8IF8sIF8gLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvcl9hbGwyXCJcbjs7XG5cbmxldCByZWMgaXRlciB0IH4oZiA6IF8gLT4gXykgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiAoKVxuICB8IGEgOjogbCAtPlxuICAgIGYgYTtcbiAgICBpdGVyIGwgfmZcbjs7XG5cbmxldCByZWMgaXRlcjJfb2sgbDEgbDIgfihmIDogXyAtPiBfIC0+IHVuaXQpID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gKClcbiAgfCBhMSA6OiBsMSwgYTIgOjogbDIgLT5cbiAgICBmIGExIGEyO1xuICAgIGl0ZXIyX29rIGwxIGwyIH5mXG4gIHwgXywgXyAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuaXRlcjJcIlxuOztcblxubGV0IHJlYyBub250YWlsX21hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCB4IDo6IHhzIC0+XG4gICAgbGV0IHkgPSBmIHggaW5cbiAgICB5IDo6IG5vbnRhaWxfbWFwIHhzIH5mXG47O1xuXG5sZXQgbm9udGFpbF9tYXBpIHQgfmYgPSBTdGRsaWIuTGlzdC5tYXBpIHQgfmZcbmxldCBwYXJ0aXRpb24gdCB+ZiA9IFN0ZGxpYi5MaXN0LnBhcnRpdGlvbiB0IH5mXG5cbmxldCByZXZfbWFwID1cbiAgbGV0IHJlYyBybWFwX2YgZiBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IGEgOjogbCAtPiBybWFwX2YgZiAoZiBhIDo6IGFjY3UpIGxcbiAgaW5cbiAgZnVuIGwgfmYgLT4gcm1hcF9mIGYgW10gbFxuOztcblxubGV0IHJldl9tYXAyX29rID1cbiAgbGV0IHJlYyBybWFwMl9mIGYgYWNjdSBsMSBsMiA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBbXSAtPiBhY2N1XG4gICAgfCBhMSA6OiBsMSwgYTIgOjogbDIgLT4gcm1hcDJfZiBmIChmIGExIGEyIDo6IGFjY3UpIGwxIGwyXG4gICAgfCBfLCBfIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZXZfbWFwMlwiXG4gIGluXG4gIGZ1biBsMSBsMiB+KGYgOiBfIC0+IF8gLT4gXykgLT4gcm1hcDJfZiBmIFtdIGwxIGwyXG47O1xuXG5sZXQgcmV2ID0gZnVuY3Rpb25cbiAgfCAoW10gfCBbIF8gXSkgYXMgcmVzIC0+IHJlc1xuICB8IHggOjogeSA6OiByZXN0IC0+IHJldl9hcHBlbmQgcmVzdCBbIHk7IHggXVxuOztcblxubGV0IGZvbGRfcmlnaHQgbCB+KGYgOiBfIC0+IF8gLT4gXykgfmluaXQgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBpbml0ICgqIGF2b2lkIHRoZSBhbGxvY2F0aW9uIG9mIFt+Zl0gYmVsb3cgKilcbiAgfCBfIC0+IGZvbGQgfmY6KGZ1biBhIGIgLT4gZiBiIGEpIH5pbml0IChyZXYgbCkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRfcmlnaHQyX29rIGwxIGwyIH4oZiA6IF8gLT4gXyAtPiBfIC0+IF8pIH5pbml0ID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gaW5pdCAoKiBhdm9pZCB0aGUgYWxsb2NhdGlvbiBvZiBbfmZdIGJlbG93ICopXG4gIHwgXywgXyAtPiBmb2xkMl9vayB+ZjooZnVuIGEgYiBjIC0+IGYgYiBjIGEpIH5pbml0IChyZXYgbDEpIChyZXYgbDIpIFtAbm9udGFpbF1cbjs7XG4iLCIoKlxuICAgVGhpcyBpcyB0aGUgaW50ZXJmYWNlIHRvIHRoZSBydW50aW1lIHN1cHBvcnQgZm9yIFtwcHhfaGFzaF0uXG5cbiAgIFRoZSBbcHB4X2hhc2hdIHN5bnRheCBleHRlbnNpb24gc3VwcG9ydHM6IFtAQGRlcml2aW5nIGhhc2hdIGFuZCBbJWhhc2hfZm9sZDogVFlQRV0gYW5kXG4gICBbJWhhc2g6IFRZUEVdXG5cbiAgIEZvciB0eXBlIFt0XSBhIGZ1bmN0aW9uIFtoYXNoX2ZvbGRfdF0gb2YgdHlwZSBbSGFzaC5zdGF0ZSAtPiB0IC0+IEhhc2guc3RhdGVdIGlzXG4gICBnZW5lcmF0ZWQuXG5cbiAgIFRoZSBnZW5lcmF0ZWQgW2hhc2hfZm9sZF88VD5dIGZ1bmN0aW9uIGlzIGNvbXBvc2l0aW9uYWwsIGZvbGxvd2luZyB0aGUgc3RydWN0dXJlIG9mIHRoZVxuICAgdHlwZTsgYWxsb3dpbmcgdXNlciBvdmVycmlkZXMgYXQgZXZlcnkgbGV2ZWwuIFRoaXMgaXMgaW4gY29udHJhc3QgdG8gb2NhbWwncyBidWlsdGluXG4gICBwb2x5bW9ycGhpYyBoYXNoaW5nIFtIYXNodGJsLmhhc2hdIHdoaWNoIGlnbm9yZXMgdXNlciBvdmVycmlkZXMuXG5cbiAgIFRoZSBnZW5lcmF0b3IgYWxzbyBwcm92aWRlcyBhIGRpcmVjdCBoYXNoLWZ1bmN0aW9uIFtoYXNoXSAobmFtZWQgW2hhc2hfPFQ+XSB3aGVuIDxUPiAhPVxuICAgXCJ0XCIpIG9mIHR5cGU6IFt0IC0+IEhhc2guaGFzaF92YWx1ZV0uXG5cbiAgIFRoZSBmb2xkaW5nIGhhc2ggZnVuY3Rpb24gY2FuIGJlIGFjY2Vzc2VkIGFzIFslaGFzaF9mb2xkOiBUWVBFXVxuICAgVGhlIGRpcmVjdCBoYXNoIGZ1bmN0aW9uIGNhbiBiZSBhY2Nlc3NlZCBhcyBbJWhhc2g6IFRZUEVdXG4qKVxuXG5vcGVuISBJbXBvcnQwXG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBDaGFyID0gQ2hhcjBcbm1vZHVsZSBJbnQgPSBJbnQwXG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIEhhc2hfaW50ZlxuXG4oKiogQnVpbHRpbiBmb2xkaW5nLXN0eWxlIGhhc2ggZnVuY3Rpb25zLCBhYnN0cmFjdGVkIG92ZXIgW0hhc2hfaW50Zi5TXSAqKVxubW9kdWxlIEZvbGRpbmcgKEhhc2ggOiBIYXNoX2ludGYuUykgOlxuICBIYXNoX2ludGYuQnVpbHRpbl9pbnRmXG4gICAgd2l0aCB0eXBlIHN0YXRlID0gSGFzaC5zdGF0ZVxuICAgICBhbmQgdHlwZSBoYXNoX3ZhbHVlID0gSGFzaC5oYXNoX3ZhbHVlID0gc3RydWN0XG4gIHR5cGUgc3RhdGUgPSBIYXNoLnN0YXRlXG4gIHR5cGUgaGFzaF92YWx1ZSA9IEhhc2guaGFzaF92YWx1ZVxuICB0eXBlICdhIGZvbGRlciA9IHN0YXRlIC0+ICdhIC0+IHN0YXRlXG5cbiAgbGV0IGhhc2hfZm9sZF91bml0IHMgKCkgPSBzXG4gIGxldCBoYXNoX2ZvbGRfaW50ID0gSGFzaC5mb2xkX2ludFxuICBsZXQgaGFzaF9mb2xkX2ludDY0ID0gSGFzaC5mb2xkX2ludDY0XG4gIGxldCBoYXNoX2ZvbGRfZmxvYXQgPSBIYXNoLmZvbGRfZmxvYXRcbiAgbGV0IGhhc2hfZm9sZF9zdHJpbmcgPSBIYXNoLmZvbGRfc3RyaW5nXG4gIGxldCBhc19pbnQgZiBzIHggPSBoYXNoX2ZvbGRfaW50IHMgKGYgeClcblxuICAoKiBUaGlzIGlnbm9yZXMgdGhlIHNpZ24gYml0IG9uIDMyLWJpdCBhcmNoaXRlY3R1cmVzLCBidXQgaXQncyB1bmxpa2VseSB0byBsZWFkIHRvXG4gICAgIGZyZXF1ZW50IGNvbGxpc2lvbnMgKG1pbl92YWx1ZSBjb2xsaWRpbmcgd2l0aCAwIGlzIHRoZSBtb3N0IGxpa2VseSBvbmUpLiAgKilcbiAgbGV0IGhhc2hfZm9sZF9pbnQzMiA9IGFzX2ludCBTdGRsaWIuSW50MzIudG9faW50XG4gIGxldCBoYXNoX2ZvbGRfY2hhciA9IGFzX2ludCBDaGFyLnRvX2ludFxuXG4gIGxldCBoYXNoX2ZvbGRfYm9vbCA9XG4gICAgYXNfaW50IChmdW5jdGlvblxuICAgICAgfCB0cnVlIC0+IDFcbiAgICAgIHwgZmFsc2UgLT4gMClcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX25hdGl2ZWludCBzIHggPSBoYXNoX2ZvbGRfaW50NjQgcyAoU3RkbGliLkludDY0Lm9mX25hdGl2ZWludCB4KVxuXG4gIGxldCBoYXNoX2ZvbGRfb3B0aW9uIGhhc2hfZm9sZF9lbGVtIHMgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBoYXNoX2ZvbGRfaW50IHMgMFxuICAgIHwgU29tZSB4IC0+IGhhc2hfZm9sZF9lbGVtIChoYXNoX2ZvbGRfaW50IHMgMSkgeFxuICA7O1xuXG4gIGxldCByZWMgaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gc1xuICAgIHwgeCA6OiB4cyAtPiBoYXNoX2ZvbGRfbGlzdF9ib2R5IGhhc2hfZm9sZF9lbGVtIChoYXNoX2ZvbGRfZWxlbSBzIHgpIHhzXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9saXN0IGhhc2hfZm9sZF9lbGVtIHMgbGlzdCA9XG4gICAgKCogVGhlIFtsZW5ndGhdIG9mIHRoZSBsaXN0IG11c3QgYmUgaW5jb3Jwb3JhdGVkIGludG8gdGhlIGhhc2gtc3RhdGUgc28gdmFsdWVzIG9mXG4gICAgICAgdHlwZXMgc3VjaCBhcyBbdW5pdCBsaXN0XSAtIChbXSwgWygpXSwgWygpOygpXSwuLikgYXJlIGhhc2hlZCBkaWZmZXJlbnRseS4gKilcbiAgICAoKiBUaGUgW2xlbmd0aF0gbXVzdCBjb21lIGJlZm9yZSB0aGUgZWxlbWVudHMgdG8gYXZvaWQgYSB2aW9sYXRpb24gb2YgdGhlIHJ1bGVcbiAgICAgICBlbmZvcmNlZCBieSBQZXJmZWN0X2hhc2guICopXG4gICAgbGV0IHMgPSBoYXNoX2ZvbGRfaW50IHMgKExpc3QubGVuZ3RoIGxpc3QpIGluXG4gICAgbGV0IHMgPSBoYXNoX2ZvbGRfbGlzdF9ib2R5IGhhc2hfZm9sZF9lbGVtIHMgbGlzdCBpblxuICAgIHNcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX2xhenlfdCBoYXNoX2ZvbGRfZWxlbSBzIHggPSBoYXNoX2ZvbGRfZWxlbSBzIChTdGRsaWIuTGF6eS5mb3JjZSB4KVxuICBsZXQgaGFzaF9mb2xkX3JlZl9mcm96ZW4gaGFzaF9mb2xkX2VsZW0gcyB4ID0gaGFzaF9mb2xkX2VsZW0gcyAheFxuXG4gIGxldCByZWMgaGFzaF9mb2xkX2FycmF5X2Zyb3plbl9pIGhhc2hfZm9sZF9lbGVtIHMgYXJyYXkgaSA9XG4gICAgaWYgaSA9IEFycmF5Lmxlbmd0aCBhcnJheVxuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbGV0IGUgPSBBcnJheS51bnNhZmVfZ2V0IGFycmF5IGkgaW5cbiAgICAgIGhhc2hfZm9sZF9hcnJheV9mcm96ZW5faSBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2VsZW0gcyBlKSBhcnJheSAoaSArIDEpKVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfYXJyYXlfZnJvemVuIGhhc2hfZm9sZF9lbGVtIHMgYXJyYXkgPVxuICAgIGhhc2hfZm9sZF9hcnJheV9mcm96ZW5faVxuICAgICAgKCogW2xlbmd0aF0gbXVzdCBiZSBpbmNvcnBvcmF0ZWQgZm9yIGFycmF5cywgYXMgaXQgaXMgZm9yIGxpc3RzLiBTZWUgY29tbWVudCBhYm92ZSAqKVxuICAgICAgaGFzaF9mb2xkX2VsZW1cbiAgICAgIChoYXNoX2ZvbGRfaW50IHMgKEFycmF5Lmxlbmd0aCBhcnJheSkpXG4gICAgICBhcnJheVxuICAgICAgMFxuICA7O1xuXG4gICgqIHRoZSBkdXBsaWNhdGlvbiBoZXJlIGlzIGJlY2F1c2Ugd2UgdGhpbmtcbiAgICAgb2NhbWwgY2FuJ3QgZWxpbWluYXRlIGluZGlyZWN0IGZ1bmN0aW9uIGNhbGxzIG90aGVyd2lzZS4gKilcbiAgbGV0IGhhc2hfbmF0aXZlaW50IHggPVxuICAgIEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9uYXRpdmVpbnQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICA7O1xuXG4gIGxldCBoYXNoX2ludDY0IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfaW50NjQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9pbnQzMiB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2ludDMyIChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgbGV0IGhhc2hfY2hhciB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2NoYXIgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9pbnQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9pbnQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9ib29sIHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfYm9vbCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG5cbiAgbGV0IGhhc2hfc3RyaW5nIHggPVxuICAgIEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9zdHJpbmcgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICA7O1xuXG4gIGxldCBoYXNoX2Zsb2F0IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfZmxvYXQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF91bml0IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfdW5pdCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG5lbmRcblxubW9kdWxlIEYgKEhhc2ggOiBIYXNoX2ludGYuUykgOlxuICBIYXNoX2ludGYuRnVsbFxuICAgIHdpdGggdHlwZSBoYXNoX3ZhbHVlID0gSGFzaC5oYXNoX3ZhbHVlXG4gICAgIGFuZCB0eXBlIHN0YXRlID0gSGFzaC5zdGF0ZVxuICAgICBhbmQgdHlwZSBzZWVkID0gSGFzaC5zZWVkID0gc3RydWN0XG4gIGluY2x1ZGUgSGFzaFxuXG4gIHR5cGUgJ2EgZm9sZGVyID0gc3RhdGUgLT4gJ2EgLT4gc3RhdGVcblxuICBsZXQgY3JlYXRlID9zZWVkICgpID0gcmVzZXQgP3NlZWQgKGFsbG9jICgpKVxuICBsZXQgb2ZfZm9sZCBoYXNoX2ZvbGRfdCB0ID0gZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF90IChjcmVhdGUgKCkpIHQpXG5cbiAgbW9kdWxlIEJ1aWx0aW4gPSBGb2xkaW5nIChIYXNoKVxuXG4gIGxldCBydW4gP3NlZWQgZm9sZGVyIHggPVxuICAgIEhhc2guZ2V0X2hhc2hfdmFsdWUgKGZvbGRlciAoSGFzaC5yZXNldCA/c2VlZCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIDs7XG5lbmRcblxubW9kdWxlIEludGVybmFsaGFzaCA6IHNpZ1xuICBpbmNsdWRlXG4gICAgSGFzaF9pbnRmLlNcbiAgICAgIHdpdGggdHlwZSBzdGF0ZSA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLnN0YXRlXG4gICAgICAoKiBXZSBnaXZlIGEgY29uY3JldGUgdHlwZSBmb3IgW3N0YXRlXSwgYWxiZWl0IG9ubHkgcGFydGlhbGx5IGV4cG9zZWQgKHNlZVxuICAgICAgICBCYXNlX2ludGVybmFsaGFzaF90eXBlcyksIHNvIHRoYXQgaXQgdW5pZmllcyB3aXRoIHRoZSBzYW1lIHR5cGUgaW4gW0Jhc2VfYm9vdF0sXG4gICAgICAgIGFuZCB0byBhbGxvdyBvcHRpbWl6YXRpb25zIGZvciB0aGUgaW1tZWRpYXRlIHR5cGUuICopXG4gICAgICAgYW5kIHR5cGUgc2VlZCA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLnNlZWRcbiAgICAgICBhbmQgdHlwZSBoYXNoX3ZhbHVlID0gQmFzZV9pbnRlcm5hbGhhc2hfdHlwZXMuaGFzaF92YWx1ZVxuXG4gIGV4dGVybmFsIGZvbGRfaW50NjRcbiAgICA6ICBzdGF0ZVxuICAgIC0+IChpbnQ2NFtAdW5ib3hlZF0pXG4gICAgLT4gc3RhdGVcbiAgICA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQ2NFwiIFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnQ2NF91bmJveGVkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGZvbGRfaW50IDogc3RhdGUgLT4gaW50IC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludFwiIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgZm9sZF9mbG9hdFxuICAgIDogIHN0YXRlXG4gICAgLT4gKGZsb2F0W0B1bmJveGVkXSlcbiAgICAtPiBzdGF0ZVxuICAgID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2Zsb2F0XCIgXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2Zsb2F0X3VuYm94ZWRcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgZm9sZF9zdHJpbmcgOiBzdGF0ZSAtPiBzdHJpbmcgLT4gc3RhdGUgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGdldF9oYXNoX3ZhbHVlIDogc3RhdGUgLT4gaGFzaF92YWx1ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZ2V0X2hhc2hfdmFsdWVcIlxuICAgIFtAQG5vYWxsb2NdXG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IGRlc2NyaXB0aW9uID0gXCJpbnRlcm5hbGhhc2hcIlxuXG4gIGluY2x1ZGUgQmFzZV9pbnRlcm5hbGhhc2hfdHlwZXNcblxuICBsZXQgYWxsb2MgKCkgPSBjcmVhdGVfc2VlZGVkIDBcbiAgbGV0IHJlc2V0ID8oc2VlZCA9IDApIF90ID0gY3JlYXRlX3NlZWRlZCBzZWVkXG5cbiAgbW9kdWxlIEZvcl90ZXN0cyA9IHN0cnVjdFxuICAgIGxldCBjb21wYXJlX3N0YXRlIChhIDogc3RhdGUpIChiIDogc3RhdGUpID0gY29tcGFyZSAoYSA6PiBpbnQpIChiIDo+IGludClcbiAgICBsZXQgc3RhdGVfdG9fc3RyaW5nIChzdGF0ZSA6IHN0YXRlKSA9IEludC50b19zdHJpbmcgKHN0YXRlIDo+IGludClcbiAgZW5kXG5lbmRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbnRlcm5hbGhhc2hcblxuICB0eXBlICdhIGZvbGRlciA9IHN0YXRlIC0+ICdhIC0+IHN0YXRlXG5cbiAgbGV0IGNyZWF0ZSA/c2VlZCAoKSA9IHJlc2V0ID9zZWVkIChhbGxvYyAoKSlcbiAgbGV0IHJ1biA/c2VlZCBmb2xkZXIgeCA9IGdldF9oYXNoX3ZhbHVlIChmb2xkZXIgKHJlc2V0ID9zZWVkIChhbGxvYyAoKSkpIHgpXG4gIGxldCBvZl9mb2xkIGhhc2hfZm9sZF90IHQgPSBnZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX3QgKGNyZWF0ZSAoKSkgdClcblxuICBtb2R1bGUgQnVpbHRpbiA9IHN0cnVjdFxuICAgIG1vZHVsZSBGb2xkaW5nID0gRm9sZGluZyAoSW50ZXJuYWxoYXNoKVxuICAgIGluY2x1ZGUgRm9sZGluZ1xuXG4gICAgKCogW0ZvbGRpbmddIHByb3ZpZGVzIHNvbWUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbnMgZm9yIHRoZSBbaGFzaF8qXSBmdW5jdGlvbnMgYmVsb3csXG4gICAgICAgYnV0IHRoZXkgYXJlIGluZWZmaWNpZW50IGZvciBzb21lIHVzZS1jYXNlcyBiZWNhdXNlIG9mIHRoZSB1c2Ugb2YgdGhlIFtoYXNoX2ZvbGRdXG4gICAgICAgZnVuY3Rpb25zLiBBdCB0aGlzIHBvaW50LCB0aGUgW2hhc2hfdmFsdWVdIHR5cGUgaGFzIGJlZW4gZml4ZWQgdG8gW2ludF0sIHNvIHRoaXNcbiAgICAgICBtb2R1bGUgY2FuIHByb3ZpZGUgc3BlY2lhbGl6ZWQgaW1wbGVtZW50YXRpb25zLiAqKVxuXG4gICAgbGV0IGhhc2hfY2hhciA9IENoYXIwLnRvX2ludFxuXG4gICAgKCogVGhpcyBoYXNoIHdhcyBjaG9zZW4gZnJvbSBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9iYWRib3kvNjI2Nzc0M1xuXG4gICAgICAgSXQgYXR0ZW1wdHMgdG8gZnVsZmlsbCB0aGUgcHJpbWFyeSBnb2FscyBvZiBhIG5vbi1jcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb246XG5cbiAgICAgICAtIGEgYml0IGNoYW5nZSBpbiB0aGUgaW5wdXQgc2hvdWxkIGNoYW5nZSB+MS8yIG9mIHRoZSBvdXRwdXQgYml0c1xuICAgICAgIC0gdGhlIG91dHB1dCBzaG91bGQgYmUgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkIGFjcm9zcyB0aGUgb3V0cHV0IHJhbmdlXG4gICAgICAgLSBpbnB1dHMgdGhhdCBhcmUgY2xvc2UgdG8gZWFjaCBvdGhlciBzaG91bGRuJ3QgbGVhZCB0byBvdXRwdXRzIHRoYXQgYXJlIGNsb3NlIHRvXG4gICAgICAgICBlYWNoIG90aGVyLlxuICAgICAgIC0gYWxsIGJpdHMgb2YgdGhlIGlucHV0IGFyZSB1c2VkIGluIGdlbmVyYXRpbmcgdGhlIG91dHB1dFxuXG4gICAgICAgSW4gb3VyIGNhc2Ugd2UgYWxzbyB3YW50IGl0IHRvIGJlIGZhc3QsIG5vbi1hbGxvY2F0aW5nLCBhbmQgaW5saW5hYmxlLiAgKilcbiAgICBsZXRbQGlubGluZSBhbHdheXNdIGhhc2hfaW50ICh0IDogaW50KSA9XG4gICAgICBsZXQgdCA9IGxub3QgdCArICh0IGxzbCAyMSkgaW5cbiAgICAgIGxldCB0ID0gdCBseG9yICh0IGxzciAyNCkgaW5cbiAgICAgIGxldCB0ID0gdCArICh0IGxzbCAzKSArICh0IGxzbCA4KSBpblxuICAgICAgbGV0IHQgPSB0IGx4b3IgKHQgbHNyIDE0KSBpblxuICAgICAgbGV0IHQgPSB0ICsgKHQgbHNsIDIpICsgKHQgbHNsIDQpIGluXG4gICAgICBsZXQgdCA9IHQgbHhvciAodCBsc3IgMjgpIGluXG4gICAgICB0ICsgKHQgbHNsIDMxKVxuICAgIDs7XG5cbiAgICBsZXQgaGFzaF9ib29sIHggPSBpZiB4IHRoZW4gMSBlbHNlIDBcblxuICAgIGV4dGVybmFsIGhhc2hfZmxvYXRcbiAgICAgIDogIChmbG9hdFtAdW5ib3hlZF0pXG4gICAgICAtPiBpbnRcbiAgICAgID0gXCJCYXNlX2hhc2hfZG91YmxlXCIgXCJCYXNlX2hhc2hfZG91YmxlX3VuYm94ZWRcIlxuICAgICAgW0BAbm9hbGxvY11cblxuICAgIGxldCBoYXNoX3VuaXQgKCkgPSAwXG4gIGVuZFxuZW5kXG5cbmluY2x1ZGUgVFxuIiwib3BlbiBJbXBvcnQwXG5cbmxldCBjb21wYXJlX2Fic3RyYWN0IH50eXBlX25hbWUgXyBfID1cbiAgUHJpbnRmLmtzcHJpbnRmXG4gICAgZmFpbHdpdGhcbiAgICBcIkNvbXBhcmUgY2FsbGVkIG9uIHRoZSB0eXBlICVzLCB3aGljaCBpcyBhYnN0cmFjdCBpbiBhbiBpbXBsZW1lbnRhdGlvbi5cIlxuICAgIHR5cGVfbmFtZVxuOztcblxubGV0IGVxdWFsX2Fic3RyYWN0IH50eXBlX25hbWUgXyBfID1cbiAgUHJpbnRmLmtzcHJpbnRmXG4gICAgZmFpbHdpdGhcbiAgICBcIkVxdWFsIGNhbGxlZCBvbiB0aGUgdHlwZSAlcywgd2hpY2ggaXMgYWJzdHJhY3QgaW4gYW4gaW1wbGVtZW50YXRpb24uXCJcbiAgICB0eXBlX25hbWVcbjs7XG5cbnR5cGUgJ2EgY29tcGFyZSA9ICdhIC0+ICdhIC0+IGludFxudHlwZSAnYSBjb21wYXJlX19sb2NhbCA9ICdhIC0+ICdhIC0+IGludFxudHlwZSAnYSBlcXVhbCA9ICdhIC0+ICdhIC0+IGJvb2xcbnR5cGUgJ2EgZXF1YWxfX2xvY2FsID0gJ2EgLT4gJ2EgLT4gYm9vbFxuXG5tb2R1bGUgQ29tcGFyYWJsZSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgY29tcGFyZSA6IHQgY29tcGFyZVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAnYSBjb21wYXJlIC0+ICdhIHQgY29tcGFyZVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAnYSBjb21wYXJlIC0+ICdiIGNvbXBhcmUgLT4gKCdhLCAnYikgdCBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAnYSBjb21wYXJlIC0+ICdiIGNvbXBhcmUgLT4gJ2MgY29tcGFyZSAtPiAoJ2EsICdiLCAnYykgdCBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFNfbG9jYWwgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBjb21wYXJlX19sb2NhbCA6IHQgY29tcGFyZV9fbG9jYWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgU19sb2NhbDEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBjb21wYXJlX19sb2NhbCA6ICdhIGNvbXBhcmVfX2xvY2FsIC0+ICdhIHQgY29tcGFyZV9fbG9jYWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgU19sb2NhbDIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBjb21wYXJlX19sb2NhbFxuICAgICAgOiAgJ2EgY29tcGFyZV9fbG9jYWxcbiAgICAgIC0+ICdiIGNvbXBhcmVfX2xvY2FsXG4gICAgICAtPiAoJ2EsICdiKSB0IGNvbXBhcmVfX2xvY2FsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFNfbG9jYWwzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGNvbXBhcmVfX2xvY2FsXG4gICAgICA6ICAnYSBjb21wYXJlX19sb2NhbFxuICAgICAgLT4gJ2IgY29tcGFyZV9fbG9jYWxcbiAgICAgIC0+ICdjIGNvbXBhcmVfX2xvY2FsXG4gICAgICAtPiAoJ2EsICdiLCAnYykgdCBjb21wYXJlX19sb2NhbFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgRXF1YWwgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGVxdWFsIDogdCBlcXVhbFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGVxdWFsIDogJ2EgZXF1YWwgLT4gJ2EgdCBlcXVhbFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIGVxdWFsIDogJ2EgZXF1YWwgLT4gJ2IgZXF1YWwgLT4gKCdhLCAnYikgdCBlcXVhbFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdiIGVxdWFsIC0+ICdjIGVxdWFsIC0+ICgnYSwgJ2IsICdjKSB0IGVxdWFsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFNfbG9jYWwgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBlcXVhbF9fbG9jYWwgOiB0IGVxdWFsX19sb2NhbFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTX2xvY2FsMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGVxdWFsX19sb2NhbCA6ICdhIGVxdWFsX19sb2NhbCAtPiAnYSB0IGVxdWFsX19sb2NhbFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTX2xvY2FsMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIGVxdWFsX19sb2NhbCA6ICdhIGVxdWFsX19sb2NhbCAtPiAnYiBlcXVhbF9fbG9jYWwgLT4gKCdhLCAnYikgdCBlcXVhbF9fbG9jYWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgU19sb2NhbDMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgZXF1YWxfX2xvY2FsXG4gICAgICA6ICAnYSBlcXVhbF9fbG9jYWxcbiAgICAgIC0+ICdiIGVxdWFsX19sb2NhbFxuICAgICAgLT4gJ2MgZXF1YWxfX2xvY2FsXG4gICAgICAtPiAoJ2EsICdiLCAnYykgdCBlcXVhbF9fbG9jYWxcbiAgZW5kXG5lbmRcblxubW9kdWxlIEJ1aWx0aW4gPSBzdHJ1Y3RcbiAgbGV0IGNvbXBhcmVfYm9vbCA6IGJvb2wgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9ib29sX19sb2NhbCA6IGJvb2wgY29tcGFyZV9fbG9jYWwgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfY2hhciA6IGNoYXIgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9jaGFyX19sb2NhbCA6IGNoYXIgY29tcGFyZV9fbG9jYWwgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfZmxvYXQgOiBmbG9hdCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2Zsb2F0X19sb2NhbCA6IGZsb2F0IGNvbXBhcmVfX2xvY2FsID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludCA6IGludCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludF9fbG9jYWwgOiBpbnQgY29tcGFyZV9fbG9jYWwgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfaW50MzIgOiBpbnQzMiBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludDMyX19sb2NhbCA6IGludDMyIGNvbXBhcmVfX2xvY2FsID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludDY0IDogaW50NjQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQ2NF9fbG9jYWwgOiBpbnQ2NCBjb21wYXJlX19sb2NhbCA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9uYXRpdmVpbnRfX2xvY2FsIDogbmF0aXZlaW50IGNvbXBhcmVfX2xvY2FsID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX3N0cmluZyA6IHN0cmluZyBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX3N0cmluZ19fbG9jYWwgOiBzdHJpbmcgY29tcGFyZV9fbG9jYWwgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfYnl0ZXMgOiBieXRlcyBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2J5dGVzX19sb2NhbCA6IGJ5dGVzIGNvbXBhcmVfX2xvY2FsID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX3VuaXQgOiB1bml0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfdW5pdF9fbG9jYWwgOiB1bml0IGNvbXBhcmVfX2xvY2FsID0gUG9seS5jb21wYXJlXG5cbiAgbGV0IGNvbXBhcmVfYXJyYXlfX2xvY2FsIGNvbXBhcmVfZWx0IGEgYiA9XG4gICAgaWYgcGh5c19lcXVhbCBhIGJcbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIGxldCBsZW5fYSA9IEFycmF5MC5sZW5ndGggYSBpblxuICAgICAgbGV0IGxlbl9iID0gQXJyYXkwLmxlbmd0aCBiIGluXG4gICAgICBsZXQgcmV0ID0gY29tcGFyZSBsZW5fYSBsZW5fYiBpblxuICAgICAgaWYgcmV0IDw+IDBcbiAgICAgIHRoZW4gcmV0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgICAgIGlmIGkgPSBsZW5fYVxuICAgICAgICAgIHRoZW4gMFxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGwgPSBBcnJheTAudW5zYWZlX2dldCBhIGlcbiAgICAgICAgICAgIGFuZCByID0gQXJyYXkwLnVuc2FmZV9nZXQgYiBpIGluXG4gICAgICAgICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgbCByIGluXG4gICAgICAgICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGxvb3AgKGkgKyAxKSlcbiAgICAgICAgaW5cbiAgICAgICAgbG9vcCAwIFtAbm9udGFpbF0pKVxuICA7O1xuXG4gIGxldCBjb21wYXJlX2FycmF5IGNvbXBhcmVfZWx0IGEgYiA9IGNvbXBhcmVfYXJyYXlfX2xvY2FsIGNvbXBhcmVfZWx0IGEgYlxuXG4gIGxldCByZWMgY29tcGFyZV9saXN0IGNvbXBhcmVfZWx0IGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBbXSwgW10gLT4gMFxuICAgIHwgW10sIF8gLT4gLTFcbiAgICB8IF8sIFtdIC0+IDFcbiAgICB8IHggOjogeHMsIHkgOjogeXMgLT5cbiAgICAgIGxldCByZXMgPSBjb21wYXJlX2VsdCB4IHkgaW5cbiAgICAgIGlmIHJlcyA8PiAwIHRoZW4gcmVzIGVsc2UgY29tcGFyZV9saXN0IGNvbXBhcmVfZWx0IHhzIHlzXG4gIDs7XG5cbiAgbGV0IHJlYyBjb21wYXJlX2xpc3RfX2xvY2FsIGNvbXBhcmVfZWx0X19sb2NhbCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgW10sIFtdIC0+IDBcbiAgICB8IFtdLCBfIC0+IC0xXG4gICAgfCBfLCBbXSAtPiAxXG4gICAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHRfX2xvY2FsIHggeSBpblxuICAgICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBjb21wYXJlX2xpc3RfX2xvY2FsIGNvbXBhcmVfZWx0X19sb2NhbCB4cyB5c1xuICA7O1xuXG4gIGxldCBjb21wYXJlX29wdGlvbiBjb21wYXJlX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiAwXG4gICAgfCBOb25lLCBTb21lIF8gLT4gLTFcbiAgICB8IFNvbWUgXywgTm9uZSAtPiAxXG4gICAgfCBTb21lIGEsIFNvbWUgYiAtPiBjb21wYXJlX2VsdCBhIGJcbiAgOztcblxuICBsZXQgY29tcGFyZV9vcHRpb25fX2xvY2FsIGNvbXBhcmVfZWx0X19sb2NhbCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiAwXG4gICAgfCBOb25lLCBTb21lIF8gLT4gLTFcbiAgICB8IFNvbWUgXywgTm9uZSAtPiAxXG4gICAgfCBTb21lIGEsIFNvbWUgYiAtPiBjb21wYXJlX2VsdF9fbG9jYWwgYSBiXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfcmVmIGNvbXBhcmVfZWx0IGEgYiA9IGNvbXBhcmVfZWx0ICFhICFiXG4gIGxldCBjb21wYXJlX3JlZl9fbG9jYWwgY29tcGFyZV9lbHQgYSBiID0gY29tcGFyZV9lbHQgIWEgIWJcbiAgbGV0IGVxdWFsX2Jvb2wgOiBib29sIGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfYm9vbF9fbG9jYWwgOiBib29sIGVxdWFsX19sb2NhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2NoYXIgOiBjaGFyIGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfY2hhcl9fbG9jYWwgOiBjaGFyIGVxdWFsX19sb2NhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2ludCA6IGludCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2ludF9fbG9jYWwgOiBpbnQgZXF1YWxfX2xvY2FsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfaW50MzIgOiBpbnQzMiBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2ludDMyX19sb2NhbCA6IGludDMyIGVxdWFsX19sb2NhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2ludDY0IDogaW50NjQgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQ2NF9fbG9jYWwgOiBpbnQ2NCBlcXVhbF9fbG9jYWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9uYXRpdmVpbnRfX2xvY2FsIDogbmF0aXZlaW50IGVxdWFsX19sb2NhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX3N0cmluZyA6IHN0cmluZyBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX3N0cmluZ19fbG9jYWwgOiBzdHJpbmcgZXF1YWxfX2xvY2FsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfYnl0ZXMgOiBieXRlcyBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2J5dGVzX19sb2NhbCA6IGJ5dGVzIGVxdWFsX19sb2NhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX3VuaXQgOiB1bml0IGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfdW5pdF9fbG9jYWwgOiB1bml0IGVxdWFsX19sb2NhbCA9IFBvbHkuZXF1YWxcblxuICAoKiBbUG9seS5lcXVhbF0gaXMgSUVFRSBjb21wbGlhbnQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQgaGVyZS4gKilcbiAgbGV0IGVxdWFsX2Zsb2F0IHggeSA9IGVxdWFsX2ludCAoY29tcGFyZV9mbG9hdCB4IHkpIDBcbiAgbGV0IGVxdWFsX2Zsb2F0X19sb2NhbCB4IHkgPSBlcXVhbF9pbnQgKGNvbXBhcmVfZmxvYXRfX2xvY2FsIHggeSkgMFxuXG4gIGxldCBlcXVhbF9hcnJheV9fbG9jYWwgZXF1YWxfZWx0IGEgYiA9XG4gICAgcGh5c19lcXVhbCBhIGJcbiAgICB8fFxuICAgIGxldCBsZW5fYSA9IEFycmF5MC5sZW5ndGggYSBpblxuICAgIGxldCBsZW5fYiA9IEFycmF5MC5sZW5ndGggYiBpblxuICAgIGVxdWFsIGxlbl9hIGxlbl9iXG4gICAgJiZcbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpID0gbGVuX2FcbiAgICAgIHx8XG4gICAgICBsZXQgbCA9IEFycmF5MC51bnNhZmVfZ2V0IGEgaVxuICAgICAgYW5kIHIgPSBBcnJheTAudW5zYWZlX2dldCBiIGkgaW5cbiAgICAgIGVxdWFsX2VsdCBsIHIgJiYgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDAgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBlcXVhbF9hcnJheSBlcXVhbF9lbHQgYSBiID0gZXF1YWxfYXJyYXlfX2xvY2FsIGVxdWFsX2VsdCBhIGJcblxuICBsZXQgcmVjIGVxdWFsX2xpc3QgZXF1YWxfZWx0IGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBbXSwgW10gLT4gdHJ1ZVxuICAgIHwgW10sIF8gfCBfLCBbXSAtPiBmYWxzZVxuICAgIHwgeCA6OiB4cywgeSA6OiB5cyAtPiBlcXVhbF9lbHQgeCB5ICYmIGVxdWFsX2xpc3QgZXF1YWxfZWx0IHhzIHlzXG4gIDs7XG5cbiAgbGV0IHJlYyBlcXVhbF9saXN0X19sb2NhbCBlcXVhbF9lbHRfX2xvY2FsIGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBbXSwgW10gLT4gdHJ1ZVxuICAgIHwgW10sIF8gfCBfLCBbXSAtPiBmYWxzZVxuICAgIHwgeCA6OiB4cywgeSA6OiB5cyAtPiBlcXVhbF9lbHRfX2xvY2FsIHggeSAmJiBlcXVhbF9saXN0X19sb2NhbCBlcXVhbF9lbHRfX2xvY2FsIHhzIHlzXG4gIDs7XG5cbiAgbGV0IGVxdWFsX29wdGlvbiBlcXVhbF9lbHQgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IE5vbmUsIE5vbmUgLT4gdHJ1ZVxuICAgIHwgTm9uZSwgU29tZSBfIHwgU29tZSBfLCBOb25lIC0+IGZhbHNlXG4gICAgfCBTb21lIGEsIFNvbWUgYiAtPiBlcXVhbF9lbHQgYSBiXG4gIDs7XG5cbiAgbGV0IGVxdWFsX29wdGlvbl9fbG9jYWwgZXF1YWxfZWx0X19sb2NhbCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiB0cnVlXG4gICAgfCBOb25lLCBTb21lIF8gfCBTb21lIF8sIE5vbmUgLT4gZmFsc2VcbiAgICB8IFNvbWUgYSwgU29tZSBiIC0+IGVxdWFsX2VsdF9fbG9jYWwgYSBiXG4gIDs7XG5cbiAgbGV0IGVxdWFsX3JlZiBlcXVhbF9lbHQgYSBiID0gZXF1YWxfZWx0ICFhICFiXG4gIGxldCBlcXVhbF9yZWZfX2xvY2FsIGVxdWFsX2VsdCBhIGIgPSBlcXVhbF9lbHQgIWEgIWJcbmVuZFxuIiwiKCoqIFRoaXMgbW9kdWxlIGlzIGZvciB1c2UgYnkgcHB4X2hhc2gsIGFuZCBpcyB0aHVzIG5vdCBpbiB0aGUgaW50ZXJmYWNlIG9mIEJhc2UuICopXG5tb2R1bGUgU3RkID0gc3RydWN0XG4gIG1vZHVsZSBIYXNoID0gSGFzaCAoKiogQGNhbm9uaWNhbCBCYXNlLkhhc2ggKilcbmVuZFxuXG50eXBlICdhIGhhc2hfZm9sZCA9IFN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFN0ZC5IYXNoLnN0YXRlXG5cbm1vZHVsZSBIYXNoYWJsZSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3QgOiB0IGhhc2hfZm9sZFxuICAgIHZhbCBoYXNoIDogdCAtPiBTdGQuSGFzaC5oYXNoX3ZhbHVlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3QgOiAnYSBoYXNoX2ZvbGQgLT4gJ2EgdCBoYXNoX2ZvbGRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBoYXNoX2ZvbGRfdCA6ICdhIGhhc2hfZm9sZCAtPiAnYiBoYXNoX2ZvbGQgLT4gKCdhLCAnYikgdCBoYXNoX2ZvbGRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3RcbiAgICAgIDogICdhIGhhc2hfZm9sZFxuICAgICAgLT4gJ2IgaGFzaF9mb2xkXG4gICAgICAtPiAnYyBoYXNoX2ZvbGRcbiAgICAgIC0+ICgnYSwgJ2IsICdjKSB0IGhhc2hfZm9sZFxuICBlbmRcbmVuZFxuIiwib3BlbiBHbG9iYWxpemVcbm9wZW4gSGFzaC5CdWlsdGluXG5vcGVuIFBweF9jb21wYXJlX2xpYi5CdWlsdGluXG5pbmNsdWRlIFNleHBsaWIwLlNleHBcblxuKCoqIFR5cGUgb2YgUy1leHByZXNzaW9ucyAqKVxudHlwZSB0ID0gU2V4cGxpYjAuU2V4cC50ID1cbiAgfCBBdG9tIG9mIHN0cmluZ1xuICB8IExpc3Qgb2YgdCBsaXN0XG5bQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgaGFzaF1cblxubGV0IHJlYyBjb21wYXJlX19sb2NhbCA9XG4gIChmdW4gYV9fMDAxXyBiX18wMDJfIC0+XG4gICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDAxXyBiX18wMDJfXG4gICAgIHRoZW4gMFxuICAgICBlbHNlIChcbiAgICAgICBtYXRjaCBhX18wMDFfLCBiX18wMDJfIHdpdGhcbiAgICAgICB8IEF0b20gX2FfXzAwM18sIEF0b20gX2JfXzAwNF8gLT4gY29tcGFyZV9zdHJpbmdfX2xvY2FsIF9hX18wMDNfIF9iX18wMDRfXG4gICAgICAgfCBBdG9tIF8sIF8gLT4gLTFcbiAgICAgICB8IF8sIEF0b20gXyAtPiAxXG4gICAgICAgfCBMaXN0IF9hX18wMDVfLCBMaXN0IF9iX18wMDZfIC0+XG4gICAgICAgICBjb21wYXJlX2xpc3RfX2xvY2FsIGNvbXBhcmVfX2xvY2FsIF9hX18wMDVfIF9iX18wMDZfKVxuICAgIDogdCAtPiB0IC0+IGludClcbjs7XG5cbmxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxubGV0IHJlYyAoZ2xvYmFsaXplIDogdCAtPiB0KSA9XG4gIChmdW4geF9fMDA5XyAtPlxuICAgICBtYXRjaCB4X18wMDlfIHdpdGhcbiAgICAgfCBBdG9tIGFyZ19fMDEwXyAtPiBBdG9tIChnbG9iYWxpemVfc3RyaW5nIGFyZ19fMDEwXylcbiAgICAgfCBMaXN0IGFyZ19fMDExXyAtPiBMaXN0IChnbG9iYWxpemVfbGlzdCBnbG9iYWxpemUgYXJnX18wMTFfKVxuICAgIDogdCAtPiB0KVxuOztcblxubGV0IHJlYyAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgIHwgQXRvbSBfYTAgLT5cbiAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwIGluXG4gICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgIGhhc2hfZm9sZF9zdHJpbmcgaHN2IF9hMFxuICAgICB8IExpc3QgX2EwIC0+XG4gICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICBoYXNoX2ZvbGRfbGlzdCBoYXNoX2ZvbGRfdCBoc3YgX2EwXG4gICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG5cbmFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgbGV0IGZ1bmMgYXJnID1cbiAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gIGluXG4gIGZ1biB4IC0+IGZ1bmMgeFxuOztcblxuW0BAQGVuZF1cblxubGV0IHRfc2V4cF9ncmFtbWFyID0gU2V4cGxpYjAuU2V4cF9jb252LnNleHBfdF9zZXhwX2dyYW1tYXJcbmxldCBvZl9zdHJpbmcgPSAoKVxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBlcXVhbF9fbG9jYWwgYSBiID0gY29tcGFyZV9fbG9jYWwgYSBiID0gMFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgU3lzID0gU3lzMFxuXG50eXBlIHQgPVxuICB8IFczMlxuICB8IFc2NFxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgPVxuICAoZnVuY3Rpb25cbiAgIHwgVzMyIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlczMlwiXG4gICB8IFc2NCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJXNjRcIlxuICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgbnVtX2JpdHMgPSBmdW5jdGlvblxuICB8IFczMiAtPiAzMlxuICB8IFc2NCAtPiA2NFxuOztcblxubGV0IHdvcmRfc2l6ZSA9XG4gIG1hdGNoIFN5cy53b3JkX3NpemVfaW5fYml0cyB3aXRoXG4gIHwgMzIgLT4gVzMyXG4gIHwgNjQgLT4gVzY0XG4gIHwgXyAtPiBmYWlsd2l0aCBcInVua25vd24gd29yZCBzaXplXCJcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxubGV0IHIgPSByZWYgWyBcIkJhc2UuU2V4cC5wcF9odW1cIiBdXG5sZXQgYWxsICgpID0gIXJcbmxldCByZWdpc3RlciBwID0gciA6PSBwIDo6ICFyXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHBwIDogRm9ybWF0dGVyLnQgLT4gdCAtPiB1bml0XG5lbmRcblxubW9kdWxlIFJlZ2lzdGVyX3BwIChNIDogc2lnXG4gIGluY2x1ZGUgU1xuXG4gIHZhbCBtb2R1bGVfbmFtZSA6IHN0cmluZ1xuZW5kKSA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgbGV0ICgpID0gcmVnaXN0ZXIgKE0ubW9kdWxlX25hbWUgXiBcIi5wcFwiKVxuZW5kXG5cbm1vZHVsZSBSZWdpc3RlciAoTSA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG5lbmQpID1cblJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgbGV0IHBwIGZvcm1hdHRlciB0ID0gU3RkbGliLkZvcm1hdC5wcF9wcmludF9zdHJpbmcgZm9ybWF0dGVyIChNLnRvX3N0cmluZyB0KVxuZW5kKVxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9IGV4biBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxubGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2V4biA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG5bQEBAZW5kXVxuXG5sZXQgZXhpdCA9IFN0ZGxpYi5leGl0XG5cbmV4Y2VwdGlvbiBGaW5hbGx5IG9mIHQgKiB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgRmluYWxseV0gKGZ1bmN0aW9uXG4gICAgfCBGaW5hbGx5IChhcmcwX18wMDFfLCBhcmcxX18wMDJfKSAtPlxuICAgICAgbGV0IHJlczBfXzAwM18gPSBzZXhwX29mX3QgYXJnMF9fMDAxX1xuICAgICAgYW5kIHJlczFfXzAwNF8gPSBzZXhwX29mX3QgYXJnMV9fMDAyXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZXhuLm1sLkZpbmFsbHlcIjsgcmVzMF9fMDAzXzsgcmVzMV9fMDA0XyBdXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbltAQEBlbmRdXG5cbmV4Y2VwdGlvbiBSZXJhaXNlZCBvZiBzdHJpbmcgKiB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgUmVyYWlzZWRdIChmdW5jdGlvblxuICAgIHwgUmVyYWlzZWQgKGFyZzBfXzAwNV8sIGFyZzFfXzAwNl8pIC0+XG4gICAgICBsZXQgcmVzMF9fMDA3XyA9IHNleHBfb2Zfc3RyaW5nIGFyZzBfXzAwNV9cbiAgICAgIGFuZCByZXMxX18wMDhfID0gc2V4cF9vZl90IGFyZzFfXzAwNl8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImV4bi5tbC5SZXJhaXNlZFwiOyByZXMwX18wMDdfOyByZXMxX18wMDhfIF1cbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuOztcblxuW0BAQGVuZF1cblxuZXhjZXB0aW9uIFNleHAgb2YgU2V4cC50XG5cbigqIFdlIGluc3RhbGwgYSBjdXN0b20gZXhuLWNvbnZlcnRlciByYXRoZXIgdGhhbiB1c2U6XG5cbiAgIHtbXG4gICAgIGV4Y2VwdGlvbiBTZXhwIG9mIFNleHAudCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cbiAgICAgKCogLi4uICopXG4gICAgIFtAQEBlbmRdXG4gICBdfVxuXG4gICB0byBlbGltaW5hdGUgdGhlIGV4dHJhIHdyYXBwaW5nIG9mIFsoU2V4cCAuLi4pXS4gKilcbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTZXhwXSAoZnVuY3Rpb25cbiAgICB8IFNleHAgdCAtPiB0XG4gICAgfCBfIC0+XG4gICAgICAoKiBSZWFjaGluZyB0aGlzIGJyYW5jaCBpbmRpY2F0ZXMgYSBidWcgaW4gc2V4cGxpYi4gKilcbiAgICAgIGFzc2VydCBmYWxzZSlcbjs7XG5cbmxldCBjcmVhdGVfcyBzZXhwID0gU2V4cCBzZXhwXG5cbmxldCByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSB0IGJhY2t0cmFjZSA9XG4gIFN0ZGxpYi5QcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSB0IGJhY2t0cmFjZVxuOztcblxuZXh0ZXJuYWwgaXNfcGh5c19lcXVhbF9tb3N0X3JlY2VudCA6IHQgLT4gYm9vbCA9IFwiQmFzZV9jYW1sX2V4bl9pc19tb3N0X3JlY2VudF9leG5cIlxuXG5sZXQgcmVyYWlzZSBleG4gc3RyID1cbiAgbGV0IGV4bicgPSBSZXJhaXNlZCAoc3RyLCBleG4pIGluXG4gIGlmIGlzX3BoeXNfZXF1YWxfbW9zdF9yZWNlbnQgZXhuXG4gIHRoZW4gKFxuICAgIGxldCBidCA9IFN0ZGxpYi5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgIHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIGV4bicgYnQpXG4gIGVsc2UgcmFpc2UgZXhuJ1xuOztcblxubGV0IHJlcmFpc2VmIGV4YyBmb3JtYXQgPSBQcmludGYua3NwcmludGYgKGZ1biBzdHIgKCkgLT4gcmVyYWlzZSBleGMgc3RyKSBmb3JtYXRcbmxldCB0b19zdHJpbmcgZXhjID0gU2V4cC50b19zdHJpbmdfaHVtIH5pbmRlbnQ6MiAoc2V4cF9vZl9leG4gZXhjKVxubGV0IHRvX3N0cmluZ19tYWNoIGV4YyA9IFNleHAudG9fc3RyaW5nX21hY2ggKHNleHBfb2ZfZXhuIGV4YylcbmxldCBzZXhwX29mX3QgPSBzZXhwX29mX2V4blxuXG5sZXQgcHJvdGVjdHggfmYgeCB+KGZpbmFsbHkgOiBfIC0+IHVuaXQpID1cbiAgbWF0Y2ggZiB4IHdpdGhcbiAgfCByZXMgLT5cbiAgICBmaW5hbGx5IHg7XG4gICAgcmVzXG4gIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgIGxldCBidCA9IFN0ZGxpYi5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgIChtYXRjaCBmaW5hbGx5IHggd2l0aFxuICAgICB8ICgpIC0+IHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIGV4biBidFxuICAgICB8IGV4Y2VwdGlvbiBmaW5hbF9leG4gLT5cbiAgICAgICAoKiBVbmZvcnR1bmF0ZWx5LCB0aGUgYmFja3RyYWNlIG9mIHRoZSBbZmluYWxfZXhuXSBpcyBkaXNjYXJkZWQgaGVyZS4gKilcbiAgICAgICByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSAoRmluYWxseSAoZXhuLCBmaW5hbF9leG4pKSBidClcbjs7XG5cbmxldCBwcm90ZWN0IH5mIH5maW5hbGx5ID0gcHJvdGVjdHggfmYgKCkgfmZpbmFsbHlcblxubGV0IGRvZXNfcmFpc2UgKHR5cGUgYSkgKGYgOiB1bml0IC0+IGEpID1cbiAgdHJ5XG4gICAgaWdub3JlIChmICgpIDogYSk7XG4gICAgZmFsc2VcbiAgd2l0aFxuICB8IF8gLT4gdHJ1ZVxuOztcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoc3RydWN0XG4gIHR5cGUgdCA9IGV4blxuXG4gIGxldCBwcCBwcGYgdCA9XG4gICAgbWF0Y2ggc2V4cF9vZl9leG5fb3B0IHQgd2l0aFxuICAgIHwgU29tZSBzZXhwIC0+IFNleHAucHBfaHVtIHBwZiBzZXhwXG4gICAgfCBOb25lIC0+IFN0ZGxpYi5Gb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiAoU3RkbGliLlByaW50ZXhjLnRvX3N0cmluZyB0KVxuICA7O1xuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5FeG5cIlxuZW5kKVxuXG5sZXQgcHJpbnRfd2l0aF9iYWNrdHJhY2UgZXhjIHJhd19iYWNrdHJhY2UgPVxuICBTdGRsaWIuRm9ybWF0LmVwcmludGYgXCJAWzwyPlVuY2F1Z2h0IGV4Y2VwdGlvbjpAXFxuQFxcbkBbJWFAXUBdQFxcbkAuXCIgcHAgZXhjO1xuICBpZiBTdGRsaWIuUHJpbnRleGMuYmFja3RyYWNlX3N0YXR1cyAoKVxuICB0aGVuIFN0ZGxpYi5QcmludGV4Yy5wcmludF9yYXdfYmFja3RyYWNlIFN0ZGxpYi5zdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgU3RkbGliLmZsdXNoIFN0ZGxpYi5zdGRlcnJcbjs7XG5cbmxldCBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgKCkgPVxuICBTdGRsaWIuUHJpbnRleGMuc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIHByaW50X3dpdGhfYmFja3RyYWNlXG47O1xuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2F1eCB+ZG9fYXRfZXhpdCB+ZXhpdCBmID1cbiAgdHJ5IGYgKCkgd2l0aFxuICB8IGV4YyAtPlxuICAgIGxldCByYXdfYmFja3RyYWNlID0gU3RkbGliLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgKCogT25lIHJlYXNvbiB0byBydW4gW2RvX2F0X2V4aXRdIGhhbmRsZXJzIGJlZm9yZSBwcmludGluZyBvdXQgdGhlIGVycm9yIG1lc3NhZ2UgaXNcbiAgICAgICB0aGF0IGl0IGhlbHBzIGN1cnNlcyBhcHBsaWNhdGlvbnMgYnJpbmcgdGhlIHRlcm1pbmFsIGluIGEgZ29vZCBzdGF0ZSwgb3RoZXJ3aXNlIHRoZVxuICAgICAgIGVycm9yIG1lc3NhZ2UgbWlnaHQgZ2V0IGNvcnJ1cHRlZC4gIEFsc28sIHRoZSBPQ2FtbCB0b3AtbGV2ZWwgdW5jYXVnaHQgZXhjZXB0aW9uXG4gICAgICAgaGFuZGxlciBkb2VzIHRoZSBzYW1lLiAqKVxuICAgIGlmIGRvX2F0X2V4aXRcbiAgICB0aGVuIChcbiAgICAgIHRyeSBTdGRsaWIuZG9fYXRfZXhpdCAoKSB3aXRoXG4gICAgICB8IF8gLT4gKCkpO1xuICAgICh0cnkgcHJpbnRfd2l0aF9iYWNrdHJhY2UgZXhjIHJhd19iYWNrdHJhY2Ugd2l0aFxuICAgICB8IF8gLT5cbiAgICAgICAodHJ5XG4gICAgICAgICAgU3RkbGliLlByaW50Zi5lcHJpbnRmIFwiRXhuLmhhbmRsZV91bmNhdWdodCBjb3VsZCBub3QgcHJpbnQ7IGV4aXRpbmcgYW55d2F5XFxuJSFcIlxuICAgICAgICB3aXRoXG4gICAgICAgIHwgXyAtPiAoKSkpO1xuICAgIGV4aXQgMVxuOztcblxubGV0IGhhbmRsZV91bmNhdWdodF9hbmRfZXhpdCBmID0gaGFuZGxlX3VuY2F1Z2h0X2F1eCBmIH5leGl0IH5kb19hdF9leGl0OnRydWVcblxubGV0IGhhbmRsZV91bmNhdWdodCB+ZXhpdDptdXN0X2V4aXQgZiA9XG4gIGhhbmRsZV91bmNhdWdodF9hdXggZiB+ZXhpdDooaWYgbXVzdF9leGl0IHRoZW4gZXhpdCBlbHNlIGlnbm9yZSkgfmRvX2F0X2V4aXQ6bXVzdF9leGl0XG47O1xuXG5sZXQgcmVyYWlzZV91bmNhdWdodCBzdHIgZnVuYyA9XG4gIHRyeSBmdW5jICgpIHdpdGhcbiAgfCBleG4gLT5cbiAgICBsZXQgYnQgPSBTdGRsaWIuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSAoUmVyYWlzZWQgKHN0ciwgZXhuKSkgYnRcbjs7XG5cbmV4dGVybmFsIGNsZWFyX2JhY2t0cmFjZSA6IHVuaXQgLT4gdW5pdCA9IFwiQmFzZV9jbGVhcl9jYW1sX2JhY2t0cmFjZV9wb3NcIiBbQEBub2FsbG9jXVxuXG5sZXQgcmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgZSA9XG4gICgqIFdlIGNsZWFyIHRoZSBiYWNrdHJhY2UgdG8gcmVkdWNlIGNvbmZ1c2lvbiwgc28gdGhhdCBwZW9wbGUgZG9uJ3QgdGhpbmsgd2hhdGV2ZXJcbiAgICAgaXMgc3RvcmVkIGNvcnJlc3BvbmRzIHRvIHRoaXMgcmFpc2UuICopXG4gIGNsZWFyX2JhY2t0cmFjZSAoKTtcbiAgU3RkbGliLnJhaXNlX25vdHJhY2UgZVxuOztcblxubGV0IGluaXRpYWxpemVfbW9kdWxlICgpID0gc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyICgpXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBjbGVhcl9iYWNrdHJhY2UgPSBjbGVhcl9iYWNrdHJhY2VcbmVuZFxuIiwiKCogYmVsb25ncyBpbiBDb21tb24sIGJ1dCBtb3ZlZCBoZXJlIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyAqKVxuXG5vcGVuISBJbXBvcnRcblxudHlwZSAnYSByZXR1cm4gPSB7IHJldHVybiA6ICdiLiAnYSAtPiAnYiB9IFtAQHVuYm94ZWRdXG5cbmxldCB3aXRoX3JldHVybiAodHlwZSBhKSBmID1cbiAgKCogUmFpc2VkIHRvIGluZGljYXRlIH5yZXR1cm4gd2FzIGNhbGxlZC4gIExvY2FsIHNvIHRoYXQgdGhlIGV4Y2VwdGlvbiBpcyB0aWVkIHRvIGFcbiAgICAgcGFydGljdWxhciBjYWxsIG9mIFt3aXRoX3JldHVybl0uICopXG4gIGxldCBleGNlcHRpb24gUmV0dXJuIG9mIGEgaW5cbiAgbGV0IGlzX2FsaXZlID0gcmVmIHRydWUgaW5cbiAgbGV0IHJldHVybiBhID1cbiAgICBpZiBub3QgIWlzX2FsaXZlXG4gICAgdGhlbiBmYWlsd2l0aCBcInVzZSBvZiBbcmV0dXJuXSBmcm9tIGEgW3dpdGhfcmV0dXJuXSB0aGF0IGFscmVhZHkgcmV0dXJuZWRcIjtcbiAgICBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgKFJldHVybiBhKVxuICBpblxuICB0cnlcbiAgICBsZXQgYSA9IGYgeyByZXR1cm4gfSBpblxuICAgIGlzX2FsaXZlIDo9IGZhbHNlO1xuICAgIGFcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgIGlzX2FsaXZlIDo9IGZhbHNlO1xuICAgIChtYXRjaCBleG4gd2l0aFxuICAgICB8IFJldHVybiBhIC0+IGFcbiAgICAgfCBfIC0+IHJhaXNlIGV4bilcbjs7XG5cbmxldCB3aXRoX3JldHVybl9vcHRpb24gZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gcmV0dXJuIC0+XG4gICAgZiB7IHJldHVybiA9IChmdW4gYSAtPiByZXR1cm4ucmV0dXJuIChTb21lIGEpKSB9O1xuICAgIE5vbmUpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBwcmVwZW5kIHsgcmV0dXJuIH0gfmYgPSB7IHJldHVybiA9IChmdW4geCAtPiByZXR1cm4gKGYgeCkpIH1cbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgY29uc3QgYyBfID0gY1xuXG5leHRlcm5hbCBpZ25vcmUgOiAoX1tAbG9jYWxfb3B0XSkgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbigqIHRoaXMgaGFzIHRoZSBzYW1lIGJlaGF2aW9yIGFzIFtTdGRsaWIuaWdub3JlXSAqKVxuXG5sZXQgbm9uIGYgeCA9IG5vdCAoZiB4KVxuXG5sZXQgZm9yZXZlciBmID1cbiAgbGV0IHJlYyBmb3JldmVyICgpID1cbiAgICBmICgpO1xuICAgIGZvcmV2ZXIgKClcbiAgaW5cbiAgdHJ5IGZvcmV2ZXIgKCkgd2l0aFxuICB8IGUgLT4gZVxuOztcblxuZXh0ZXJuYWwgaWQgOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoKCdhIC0+ICdiKVtAbG9jYWxfb3B0XSkgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5cbigqIFRoZSB0eXBpY2FsIHVzZSBjYXNlIGZvciB0aGVzZSBmdW5jdGlvbnMgaXMgdG8gcGFzcyBpbiBmdW5jdGlvbmFsIGFyZ3VtZW50cyBhbmQgZ2V0XG4gICBmdW5jdGlvbnMgYXMgYSByZXN1bHQuICopXG5sZXQgY29tcG9zZSBmIGcgeCA9IGYgKGcgeClcbmxldCBmbGlwIGYgeCB5ID0gZiB5IHhcbmxldCByZWMgYXBwbHlfbl90aW1lcyB+biBmIHggPSBpZiBuIDw9IDAgdGhlbiB4IGVsc2UgYXBwbHlfbl90aW1lcyB+bjoobiAtIDEpIGYgKGYgeClcbiIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgdHlwZSBCYXNpY19nZW4gPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgKCdhLCAnYikgZl9sYWJlbGVkX2ZuXG5cbiAgdmFsIGJpbmQgOiAnYSB0IC0+ICgnYSAtPiAnYiB0LCAnYiB0KSBmX2xhYmVsZWRfZm5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcblxuICAoKiogVGhlIGZvbGxvd2luZyBpZGVudGl0aWVzIG91Z2h0IHRvIGhvbGQgKGZvciBzb21lIHZhbHVlIG9mID0pOlxuXG4gICAgICAtIFtyZXR1cm4geCA+Pj0gZiA9IGYgeF1cbiAgICAgIC0gW3QgPj49IGZ1biB4IC0+IHJldHVybiB4ID0gdF1cbiAgICAgIC0gWyh0ID4+PSBmKSA+Pj0gZyA9IHQgPj49IGZ1biB4IC0+IChmIHggPj49IGcpXVxuXG4gICAgICBOb3RlOiBbPj49XSBpcyB0aGUgaW5maXggbm90YXRpb24gZm9yIFtiaW5kXSkgKilcblxuICAoKiogVGhlIFttYXBdIGFyZ3VtZW50IHRvIFtNb25hZC5NYWtlXSBzYXlzIGhvdyB0byBpbXBsZW1lbnQgdGhlIG1vbmFkJ3MgW21hcF0gZnVuY3Rpb24uXG4gICAgICBbYERlZmluZV91c2luZ19iaW5kXSBtZWFucyB0byBkZWZpbmUgW21hcCB0IH5mID0gYmluZCB0IH5mOihmdW4gYSAtPiByZXR1cm4gKGYgYSkpXS5cbiAgICAgIFtgQ3VzdG9tXSBvdmVycmlkZXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24sIHByZXN1bWFibHkgd2l0aCBzb21ldGhpbmcgbW9yZVxuICAgICAgZWZmaWNpZW50LlxuXG4gICAgICBTb21lIG90aGVyIGZ1bmN0aW9ucyByZXR1cm5lZCBieSBbTW9uYWQuTWFrZV0gYXJlIGRlZmluZWQgaW4gdGVybXMgb2YgW21hcF0sIHNvXG4gICAgICBwYXNzaW5nIGluIGEgbW9yZSBlZmZpY2llbnQgW21hcF0gd2lsbCBpbXByb3ZlIHRoZWlyIGVmZmljaWVuY3kgYXMgd2VsbC4gKilcbiAgdmFsIG1hcCA6IFsgYERlZmluZV91c2luZ19iaW5kIHwgYEN1c3RvbSBvZiAnYSB0IC0+ICgnYSAtPiAnYiwgJ2IgdCkgZl9sYWJlbGVkX2ZuIF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBCYXNpYyA9IEJhc2ljX2dlbiB3aXRoIHR5cGUgKCdhLCAnYikgZl9sYWJlbGVkX2ZuIDo9IGY6J2EgLT4gJ2Jcbm1vZHVsZSB0eXBlIEJhc2ljX2xvY2FsID0gQmFzaWNfZ2VuIHdpdGggdHlwZSAoJ2EsICdiKSBmX2xhYmVsZWRfZm4gOj0gZjonYSAtPiAnYlxuXG5tb2R1bGUgdHlwZSBJbmZpeF9nZW4gPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgKCdhLCAnYikgZm5cblxuICAoKiogW3QgPj49IGZdIHJldHVybnMgYSBjb21wdXRhdGlvbiB0aGF0IHNlcXVlbmNlcyB0aGUgY29tcHV0YXRpb25zIHJlcHJlc2VudGVkIGJ5IHR3b1xuICAgICAgbW9uYWQgZWxlbWVudHMuICBUaGUgcmVzdWx0aW5nIGNvbXB1dGF0aW9uIGZpcnN0IGRvZXMgW3RdIHRvIHlpZWxkIGEgdmFsdWUgW3ZdLCBhbmRcbiAgICAgIHRoZW4gcnVucyB0aGUgY29tcHV0YXRpb24gcmV0dXJuZWQgYnkgW2Ygdl0uICopXG4gIHZhbCAoID4+PSApIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgdCwgJ2IgdCkgZm5cblxuICAoKiogW3QgPj58IGZdIGlzIFt0ID4+PSAoZnVuIGEgLT4gcmV0dXJuIChmIGEpKV0uICopXG4gIHZhbCAoID4+fCApIDogJ2EgdCAtPiAoJ2EgLT4gJ2IsICdiIHQpIGZuXG5lbmRcblxubW9kdWxlIHR5cGUgSW5maXggPSBJbmZpeF9nZW4gd2l0aCB0eXBlICgnYSwgJ2IpIGZuIDo9ICdhIC0+ICdiXG5tb2R1bGUgdHlwZSBJbmZpeF9sb2NhbCA9IEluZml4X2dlbiB3aXRoIHR5cGUgKCdhLCAnYikgZm4gOj0gJ2EgLT4gJ2JcblxubW9kdWxlIHR5cGUgU3ludGF4X2dlbiA9IHNpZ1xuICAoKiogT3BlbmluZyBhIG1vZHVsZSBvZiB0aGlzIHR5cGUgYWxsb3dzIG9uZSB0byB1c2UgdGhlIFslYmluZF0gYW5kIFslbWFwXSBzeW50YXhcbiAgICAgIGV4dGVuc2lvbnMgZGVmaW5lZCBieSBwcHhfbGV0LCBhbmQgYnJpbmdzIFtyZXR1cm5dIGludG8gc2NvcGUuICopXG5cbiAgdHlwZSAnYSB0XG4gIHR5cGUgKCdhLCAnYikgZm5cbiAgdHlwZSAoJ2EsICdiKSBmX2xhYmVsZWRfZm5cblxuICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICgqKiBUaGVzZSBhcmUgY29udmVuaWVudCB0byBoYXZlIGluIHNjb3BlIHdoZW4gcHJvZ3JhbW1pbmcgd2l0aCBhIG1vbmFkOiAqKVxuXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcblxuICAgIGluY2x1ZGUgSW5maXhfZ2VuIHdpdGggdHlwZSAnYSB0IDo9ICdhIHQgYW5kIHR5cGUgKCdhLCAnYikgZm4gOj0gKCdhLCAnYikgZm5cblxuICAgIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuICAgICAgdmFsIGJpbmQgOiAnYSB0IC0+ICgnYSAtPiAnYiB0LCAnYiB0KSBmX2xhYmVsZWRfZm5cbiAgICAgIHZhbCBtYXAgOiAnYSB0IC0+ICgnYSAtPiAnYiwgJ2IgdCkgZl9sYWJlbGVkX2ZuXG4gICAgICB2YWwgYm90aCA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgKiAnYikgdFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgOiBzaWcgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFN5bnRheCA9XG4gIFN5bnRheF9nZW5cbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgZm4gOj0gJ2EgLT4gJ2JcbiAgICAgYW5kIHR5cGUgKCdhLCAnYikgZl9sYWJlbGVkX2ZuIDo9IGY6J2EgLT4gJ2JcblxubW9kdWxlIHR5cGUgU3ludGF4X2xvY2FsID1cbiAgU3ludGF4X2dlblxuICAgIHdpdGggdHlwZSAoJ2EsICdiKSBmbiA6PSAnYSAtPiAnYlxuICAgICBhbmQgdHlwZSAoJ2EsICdiKSBmX2xhYmVsZWRfZm4gOj0gZjonYSAtPiAnYlxuXG5tb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3ludGF4X2dlbiA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSAoJ2EsICdiKSBmblxuICB0eXBlICgnYSwgJ2IpIGZfbGFiZWxlZF9mblxuXG4gIGluY2x1ZGUgSW5maXhfZ2VuIHdpdGggdHlwZSAnYSB0IDo9ICdhIHQgYW5kIHR5cGUgKCdhLCAnYikgZm4gOj0gKCdhLCAnYikgZm5cblxuICBtb2R1bGUgTW9uYWRfaW5maXggOlxuICAgIEluZml4X2dlbiB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0IGFuZCB0eXBlICgnYSwgJ2IpIGZuIDo9ICgnYSwgJ2IpIGZuXG5cbiAgKCoqIFtiaW5kIHQgfmZdID0gW3QgPj49IGZdICopXG4gIHZhbCBiaW5kIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgdCwgJ2IgdCkgZl9sYWJlbGVkX2ZuXG5cbiAgKCoqIFtyZXR1cm4gdl0gcmV0dXJucyB0aGUgKHRyaXZpYWwpIGNvbXB1dGF0aW9uIHRoYXQgcmV0dXJucyB2LiAqKVxuICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuXG4gICgqKiBbbWFwIHQgfmZdIGlzIHQgPj58IGYuICopXG4gIHZhbCBtYXAgOiAnYSB0IC0+ICgnYSAtPiAnYiwgJ2IgdCkgZl9sYWJlbGVkX2ZuXG5cbiAgKCoqIFtqb2luIHRdIGlzIFt0ID4+PSAoZnVuIHQnIC0+IHQnKV0uICopXG4gIHZhbCBqb2luIDogJ2EgdCB0IC0+ICdhIHRcblxuICAoKiogW2lnbm9yZV9tIHRdIGlzIFttYXAgdCB+ZjooZnVuIF8gLT4gKCkpXS4gIFtpZ25vcmVfbV0gdXNlZCB0byBiZSBjYWxsZWQgW2lnbm9yZV0sXG4gICAgICBidXQgd2UgZGVjaWRlZCB0aGF0IHdhcyBhIGJhZCBuYW1lLCBiZWNhdXNlIGl0IHNoYWRvd2VkIHRoZSB3aWRlbHkgdXNlZFxuICAgICAgW1N0ZGxpYi5pZ25vcmVdLiAgU29tZSBtb25hZHMgc3RpbGwgZG8gW2xldCBpZ25vcmUgPSBpZ25vcmVfbV0gZm9yIGhpc3RvcmljYWxcbiAgICAgIHJlYXNvbnMuICopXG4gIHZhbCBpZ25vcmVfbSA6ICdhIHQgLT4gdW5pdCB0XG5cbiAgdmFsIGFsbCA6ICdhIHQgbGlzdCAtPiAnYSBsaXN0IHRcblxuICAoKiogTGlrZSBbYWxsXSwgYnV0IGVuc3VyZXMgdGhhdCBldmVyeSBtb25hZGljIHZhbHVlIGluIHRoZSBsaXN0IHByb2R1Y2VzIGEgdW5pdCB2YWx1ZSxcbiAgICAgIGFsbCBvZiB3aGljaCBhcmUgZGlzY2FyZGVkIHJhdGhlciB0aGFuIGJlaW5nIGNvbGxlY3RlZCBpbnRvIGEgbGlzdC4gKilcbiAgdmFsIGFsbF91bml0IDogdW5pdCB0IGxpc3QgLT4gdW5pdCB0XG5lbmRcblxubW9kdWxlIHR5cGUgU193aXRob3V0X3N5bnRheCA9XG4gIFNfd2l0aG91dF9zeW50YXhfZ2VuXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIGZfbGFiZWxlZF9mbiA6PSBmOidhIC0+ICdiXG4gICAgIGFuZCB0eXBlICgnYSwgJ2IpIGZuIDo9ICdhIC0+ICdiXG5cbm1vZHVsZSB0eXBlIFNfd2l0aG91dF9zeW50YXhfbG9jYWwgPVxuICBTX3dpdGhvdXRfc3ludGF4X2dlblxuICAgIHdpdGggdHlwZSAoJ2EsICdiKSBmX2xhYmVsZWRfZm4gOj0gZjonYSAtPiAnYlxuICAgICBhbmQgdHlwZSAoJ2EsICdiKSBmbiA6PSAnYSAtPiAnYlxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgU193aXRob3V0X3N5bnRheCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gIGluY2x1ZGUgU3ludGF4IHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX2xvY2FsID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgU193aXRob3V0X3N5bnRheF9sb2NhbCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gIGluY2x1ZGUgU3ludGF4X2xvY2FsIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBCYXNpYzJfZ2VuID0gc2lnXG4gICgqKiBNdWx0aSBwYXJhbWV0ZXIgbW9uYWQuIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGdldHMgdW5pZmllZCBhY3Jvc3MgYWxsIHRoZSBjb21wdXRhdGlvbi5cbiAgICAgIFRoaXMgaXMgdXNlZCB0byBlbmNvZGUgbW9uYWRzIHdvcmtpbmcgb24gYSBtdWx0aSBwYXJhbWV0ZXIgZGF0YSBzdHJ1Y3R1cmUgbGlrZVxuICAgICAgKFsoJ2EsJ2IpIHJlc3VsdF0pLiAqKVxuXG4gIHR5cGUgKCdhLCAnZSkgdFxuICB0eXBlICgnYSwgJ2IpIGZfbGFiZWxlZF9mblxuXG4gIHZhbCBiaW5kIDogKCdhLCAnZSkgdCAtPiAoJ2EgLT4gKCdiLCAnZSkgdCwgKCdiLCAnZSkgdCkgZl9sYWJlbGVkX2ZuXG5cbiAgdmFsIG1hcFxuICAgIDogWyBgRGVmaW5lX3VzaW5nX2JpbmRcbiAgICAgIHwgYEN1c3RvbSBvZiAoJ2EsICdlKSB0IC0+ICgnYSAtPiAnYiwgKCdiLCAnZSkgdCkgZl9sYWJlbGVkX2ZuXG4gICAgICBdXG5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEJhc2ljMiA9IEJhc2ljMl9nZW4gd2l0aCB0eXBlICgnYSwgJ2IpIGZfbGFiZWxlZF9mbiA6PSBmOidhIC0+ICdiXG5tb2R1bGUgdHlwZSBCYXNpYzJfbG9jYWwgPSBCYXNpYzJfZ2VuIHdpdGggdHlwZSAoJ2EsICdiKSBmX2xhYmVsZWRfZm4gOj0gZjonYSAtPiAnYlxuXG5tb2R1bGUgdHlwZSBJbmZpeDJfZ2VuID0gc2lnXG4gICgqKiBTYW1lIGFzIHshSW5maXh9LCBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHR3byBhcmd1bWVudHMuIFRoZSBzZWNvbmQgaXMgYWx3YXlzIGp1c3RcbiAgICAgIHBhc3NlZCB0aHJvdWdoLiAqKVxuXG4gIHR5cGUgKCdhLCAnZSkgdFxuICB0eXBlICgnYSwgJ2IpIGZuXG5cbiAgdmFsICggPj49ICkgOiAoJ2EsICdlKSB0IC0+ICgnYSAtPiAoJ2IsICdlKSB0LCAoJ2IsICdlKSB0KSBmblxuICB2YWwgKCA+PnwgKSA6ICgnYSwgJ2UpIHQgLT4gKCdhIC0+ICdiLCAoJ2IsICdlKSB0KSBmblxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZml4MiA9IEluZml4Ml9nZW4gd2l0aCB0eXBlICgnYSwgJ2IpIGZuIDo9ICdhIC0+ICdiXG5tb2R1bGUgdHlwZSBJbmZpeDJfbG9jYWwgPSBJbmZpeDJfZ2VuIHdpdGggdHlwZSAoJ2EsICdiKSBmbiA6PSAnYSAtPiAnYlxuXG5tb2R1bGUgdHlwZSBTeW50YXgyX2dlbiA9IHNpZ1xuICB0eXBlICgnYSwgJ2UpIHRcbiAgdHlwZSAoJ2EsICdiKSBmblxuICB0eXBlICgnYSwgJ2IpIGZfbGFiZWxlZF9mblxuXG4gIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXykgdFxuXG4gICAgaW5jbHVkZVxuICAgICAgSW5maXgyX2dlbiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSB0IGFuZCB0eXBlICgnYSwgJ2IpIGZuIDo9ICgnYSwgJ2IpIGZuXG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXykgdFxuICAgICAgdmFsIGJpbmQgOiAoJ2EsICdlKSB0IC0+ICgnYSAtPiAoJ2IsICdlKSB0LCAoJ2IsICdlKSB0KSBmX2xhYmVsZWRfZm5cbiAgICAgIHZhbCBtYXAgOiAoJ2EsICdlKSB0IC0+ICgnYSAtPiAnYiwgKCdiLCAnZSkgdCkgZl9sYWJlbGVkX2ZuXG4gICAgICB2YWwgYm90aCA6ICgnYSwgJ2UpIHQgLT4gKCdiLCAnZSkgdCAtPiAoJ2EgKiAnYiwgJ2UpIHRcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzIDogc2lnIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTeW50YXgyID1cbiAgU3ludGF4Ml9nZW5cbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgZm4gOj0gJ2EgLT4gJ2JcbiAgICAgYW5kIHR5cGUgKCdhLCAnYikgZl9sYWJlbGVkX2ZuIDo9IGY6J2EgLT4gJ2JcblxubW9kdWxlIHR5cGUgU3ludGF4Ml9sb2NhbCA9XG4gIFN5bnRheDJfZ2VuXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIGZuIDo9ICdhIC0+ICdiXG4gICAgIGFuZCB0eXBlICgnYSwgJ2IpIGZfbGFiZWxlZF9mbiA6PSBmOidhIC0+ICdiXG5cbm1vZHVsZSB0eXBlIFMyX2dlbiA9IHNpZ1xuICAoKiogVGhlIHNhbWUgYXMgeyFTfSBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHR3byBhcmd1bWVudHMuIFRoZSBzZWNvbmQgaXMgYWx3YXlzIGp1c3RcbiAgICAgIHBhc3NlZCB0aHJvdWdoLiAqKVxuXG4gIHR5cGUgKCdhLCAnZSkgdFxuICB0eXBlICgnYSwgJ2IpIGZuXG4gIHR5cGUgKCdhLCAnYikgZl9sYWJlbGVkX2ZuXG5cbiAgaW5jbHVkZVxuICAgIEluZml4Ml9nZW4gd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdCBhbmQgdHlwZSAoJ2EsICdiKSBmbiA6PSAoJ2EsICdiKSBmblxuXG4gIGluY2x1ZGVcbiAgICBTeW50YXgyX2dlblxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdFxuICAgICAgIGFuZCB0eXBlICgnYSwgJ2IpIGZuIDo9ICgnYSwgJ2IpIGZuXG4gICAgICAgYW5kIHR5cGUgKCdhLCAnYikgZl9sYWJlbGVkX2ZuIDo9ICgnYSwgJ2IpIGZfbGFiZWxlZF9mblxuXG4gIG1vZHVsZSBNb25hZF9pbmZpeCA6XG4gICAgSW5maXgyX2dlbiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSB0IGFuZCB0eXBlICgnYSwgJ2IpIGZuIDo9ICgnYSwgJ2IpIGZuXG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdlKSB0IC0+ICgnYSAtPiAoJ2IsICdlKSB0LCAoJ2IsICdlKSB0KSBmX2xhYmVsZWRfZm5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXykgdFxuICB2YWwgbWFwIDogKCdhLCAnZSkgdCAtPiAoJ2EgLT4gJ2IsICgnYiwgJ2UpIHQpIGZfbGFiZWxlZF9mblxuICB2YWwgam9pbiA6ICgoJ2EsICdlKSB0LCAnZSkgdCAtPiAoJ2EsICdlKSB0XG4gIHZhbCBpZ25vcmVfbSA6IChfLCAnZSkgdCAtPiAodW5pdCwgJ2UpIHRcbiAgdmFsIGFsbCA6ICgnYSwgJ2UpIHQgbGlzdCAtPiAoJ2EgbGlzdCwgJ2UpIHRcbiAgdmFsIGFsbF91bml0IDogKHVuaXQsICdlKSB0IGxpc3QgLT4gKHVuaXQsICdlKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgUzIgPVxuICBTMl9nZW4gd2l0aCB0eXBlICgnYSwgJ2IpIGZuIDo9ICdhIC0+ICdiIGFuZCB0eXBlICgnYSwgJ2IpIGZfbGFiZWxlZF9mbiA6PSBmOidhIC0+ICdiXG5cbm1vZHVsZSB0eXBlIFMyX2xvY2FsID1cbiAgUzJfZ2VuIHdpdGggdHlwZSAoJ2EsICdiKSBmbiA6PSAnYSAtPiAnYiBhbmQgdHlwZSAoJ2EsICdiKSBmX2xhYmVsZWRfZm4gOj0gZjonYSAtPiAnYlxuXG5tb2R1bGUgdHlwZSBCYXNpYzMgPSBzaWdcbiAgKCoqIE11bHRpIHBhcmFtZXRlciBtb25hZC4gVGhlIHNlY29uZCBhbmQgdGhpcmQgcGFyYW1ldGVycyBnZXQgdW5pZmllZCBhY3Jvc3MgYWxsIHRoZVxuICAgICAgY29tcHV0YXRpb24uICopXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZCwgJ2UpIHQpIC0+ICgnYiwgJ2QsICdlKSB0XG5cbiAgdmFsIG1hcFxuICAgIDogWyBgRGVmaW5lX3VzaW5nX2JpbmQgfCBgQ3VzdG9tIG9mICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdkLCAnZSkgdCBdXG5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXywgXykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZml4MyA9IHNpZ1xuICAoKiogU2FtZSBhcyBJbmZpeCwgZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0aHJlZSBhcmd1bWVudHMuIFRoZSBzZWNvbmQgYW5kIHRoaXJkIGFyZVxuICAgICAgYWx3YXlzIGp1c3QgcGFzc2VkIHRocm91Z2guICopXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdFxuXG4gIHZhbCAoID4+PSApIDogKCdhLCAnZCwgJ2UpIHQgLT4gKCdhIC0+ICgnYiwgJ2QsICdlKSB0KSAtPiAoJ2IsICdkLCAnZSkgdFxuICB2YWwgKCA+PnwgKSA6ICgnYSwgJ2QsICdlKSB0IC0+ICgnYSAtPiAnYikgLT4gKCdiLCAnZCwgJ2UpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTeW50YXgzID0gc2lnXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8sIF8pIHRcblxuICAgIGluY2x1ZGUgSW5maXgzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgdFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8sIF8pIHRcbiAgICAgIHZhbCBiaW5kIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZCwgJ2UpIHQpIC0+ICgnYiwgJ2QsICdlKSB0XG4gICAgICB2YWwgbWFwIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2QsICdlKSB0XG4gICAgICB2YWwgYm90aCA6ICgnYSwgJ2QsICdlKSB0IC0+ICgnYiwgJ2QsICdlKSB0IC0+ICgnYSAqICdiLCAnZCwgJ2UpIHRcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzIDogc2lnIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAoKiogVGhlIHNhbWUgYXMgeyFTfSBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHRocmVlIGFyZ3VtZW50cy4gVGhlIHNlY29uZFxuICAgICAgYW5kIHRoaXJkIGFyZSBhbHdheXMganVzdCBwYXNzZWQgdGhyb3VnaC4gKilcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0XG5cbiAgaW5jbHVkZSBJbmZpeDMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSB0XG4gIGluY2x1ZGUgU3ludGF4MyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIHRcbiAgbW9kdWxlIE1vbmFkX2luZml4IDogSW5maXgzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZCwgJ2UpIHQpIC0+ICgnYiwgJ2QsICdlKSB0XG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8sIF8pIHRcbiAgdmFsIG1hcCA6ICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdkLCAnZSkgdFxuICB2YWwgam9pbiA6ICgoJ2EsICdkLCAnZSkgdCwgJ2QsICdlKSB0IC0+ICgnYSwgJ2QsICdlKSB0XG4gIHZhbCBpZ25vcmVfbSA6IChfLCAnZCwgJ2UpIHQgLT4gKHVuaXQsICdkLCAnZSkgdFxuICB2YWwgYWxsIDogKCdhLCAnZCwgJ2UpIHQgbGlzdCAtPiAoJ2EgbGlzdCwgJ2QsICdlKSB0XG4gIHZhbCBhbGxfdW5pdCA6ICh1bml0LCAnZCwgJ2UpIHQgbGlzdCAtPiAodW5pdCwgJ2QsICdlKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQmFzaWNfaW5kZXhlZCA9IHNpZ1xuICAoKiogSW5kZXhlZCBtb25hZCwgaW4gdGhlIHN0eWxlIG9mIEF0a2V5LiBUaGUgc2Vjb25kIGFuZCB0aGlyZCBwYXJhbWV0ZXJzIGFyZSBjb21wb3NlZFxuICAgICAgYWNyb3NzIGFsbCBjb21wdXRhdGlvbi4gVG8gc2VlIHRoaXMgbW9yZSBjbGVhcmx5LCB5b3UgY2FuIGxvb2sgYXQgdGhlIHR5cGUgb2YgYmluZDpcblxuICAgICAge1tcbiAgICAgICAgdmFsIGJpbmQgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAoJ2IsICdqLCAnaykgdCkgLT4gKCdiLCAnaSwgJ2spIHRcbiAgICAgIF19XG5cbiAgICAgIGFuZCBpc29sYXRlIHNvbWUgb2YgdGhlIHR5cGUgdmFyaWFibGVzIHRvIHNlZSB0aGVpciBpbmRpdmlkdWFsIGJlaGF2aW9yczpcblxuICAgICAge1tcbiAgICAgICAgdmFsIGJpbmQgOiAnYSAgICAgICAgICAgICAtPiBmOignYSAtPiAgJ2IgICAgICAgICAgICkgLT4gICdiXG4gICAgICAgIHZhbCBiaW5kIDogICAgICAnaSwgJ2ogICAgLT4gICAgICAgICAgICAgICAnaiwgJ2sgICAgIC0+ICAgICAnaSwgJ2tcbiAgICAgIF19XG5cbiAgICAgIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIEF0a2V5LXN0eWxlIGluZGV4ZWQgbW9uYWRzLCBzZWU6XG5cbiAgICAgIHt2XG4gICAgICAgIFBhcmFtZXRlcmlzZWQgTm90aW9ucyBvZiBDb21wdXRhdGlvblxuICAgICAgICBSb2JlcnQgQXRrZXlcbiAgICAgICAgaHR0cDovL2JlbnRuaWIub3JnL3BhcmFtbm90aW9ucy1qZnAucGRmXG4gICAgICB2fSAqKVxuXG4gIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrKSB0KSAtPiAoJ2IsICdpLCAnaykgdFxuXG4gIHZhbCBtYXBcbiAgICA6IFsgYERlZmluZV91c2luZ19iaW5kIHwgYEN1c3RvbSBvZiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2opIHQgXVxuXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZml4X2luZGV4ZWQgPSBzaWdcbiAgKCoqIFNhbWUgYXMgeyFJbmZpeH0sIGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdGhyZWUgYXJndW1lbnRzLiBUaGUgc2Vjb25kIGFuZFxuICAgICAgdGhpcmQgYXJlIGNvbXBvc2VkIGFjcm9zcyBhbGwgY29tcHV0YXRpb24uICopXG5cbiAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gIHZhbCAoID4+PSApIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdhIC0+ICgnYiwgJ2osICdrKSB0KSAtPiAoJ2IsICdpLCAnaykgdFxuICB2YWwgKCA+PnwgKSA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2opIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTeW50YXhfaW5kZXhlZCA9IHNpZ1xuICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2kpIHRcblxuICAgIGluY2x1ZGUgSW5maXhfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIHRcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2kpIHRcbiAgICAgIHZhbCBiaW5kIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG4gICAgICB2YWwgbWFwIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqKSB0XG4gICAgICB2YWwgYm90aCA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYiwgJ2osICdrKSB0IC0+ICgnYSAqICdiLCAnaSwgJ2spIHRcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzIDogc2lnIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX2luZGV4ZWQgPSBzaWdcbiAgKCoqIFRoZSBzYW1lIGFzIHshU30gZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0aHJlZSBhcmd1bWVudHMuIFRoZSBzZWNvbmQgYW5kXG4gICAgICB0aGlyZCBhcmUgY29tcG9zZWQgYWNyb3NzIGFsbCBjb21wdXRhdGlvbi4gKilcblxuICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgaW5jbHVkZSBJbmZpeF9pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgdFxuICBpbmNsdWRlIFN5bnRheF9pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgdFxuICBtb2R1bGUgTW9uYWRfaW5maXggOiBJbmZpeF9pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSkgdFxuICB2YWwgbWFwIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqKSB0XG4gIHZhbCBqb2luIDogKCgnYSwgJ2osICdrKSB0LCAnaSwgJ2opIHQgLT4gKCdhLCAnaSwgJ2spIHRcbiAgdmFsIGlnbm9yZV9tIDogKF8sICdpLCAnaikgdCAtPiAodW5pdCwgJ2ksICdqKSB0XG4gIHZhbCBhbGwgOiAoJ2EsICdpLCAnaSkgdCBsaXN0IC0+ICgnYSBsaXN0LCAnaSwgJ2kpIHRcbiAgdmFsIGFsbF91bml0IDogKHVuaXQsICdpLCAnaSkgdCBsaXN0IC0+ICh1bml0LCAnaSwgJ2kpIHRcbmVuZFxuXG5tb2R1bGUgU190b19TMiAoWCA6IFMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG5lbmRcblxubW9kdWxlIFMyX3RvX1MzIChYIDogUzIpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnRcbmVuZFxuXG5tb2R1bGUgU190b19TX2luZGV4ZWQgKFggOiBTKSA6IFNfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgPSAnYSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdpLCAnaikgdCA9ICdhIFgudFxuZW5kXG5cbm1vZHVsZSBTMl90b19TIChYIDogUzIpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICgnYSwgdW5pdCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgJ2EgdCA9ICgnYSwgdW5pdCkgWC50XG5lbmRcblxubW9kdWxlIFMzX3RvX1MyIChYIDogUzMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlLCB1bml0KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSwgdW5pdCkgWC50XG5lbmRcblxubW9kdWxlIFNfaW5kZXhlZF90b19TMiAoWCA6IFNfaW5kZXhlZCkgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UsICdlKSBYLnQgPVxuc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UsICdlKSBYLnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNb25hZCA9IHNpZ1xuICAoKiogQSBtb25hZCBpcyBhbiBhYnN0cmFjdGlvbiBvZiB0aGUgY29uY2VwdCBvZiBzZXF1ZW5jaW5nIG9mIGNvbXB1dGF0aW9ucy4gIEEgdmFsdWUgb2ZcbiAgICAgIHR5cGUgWydhIG1vbmFkXSByZXByZXNlbnRzIGEgY29tcHV0YXRpb24gdGhhdCByZXR1cm5zIGEgdmFsdWUgb2YgdHlwZSBbJ2FdLiAqKVxuXG4gIG1vZHVsZSB0eXBlIEJhc2ljID0gQmFzaWNcbiAgbW9kdWxlIHR5cGUgQmFzaWMyID0gQmFzaWMyXG4gIG1vZHVsZSB0eXBlIEJhc2ljMyA9IEJhc2ljM1xuICBtb2R1bGUgdHlwZSBCYXNpY19pbmRleGVkID0gQmFzaWNfaW5kZXhlZFxuICBtb2R1bGUgdHlwZSBCYXNpY19sb2NhbCA9IEJhc2ljX2xvY2FsXG4gIG1vZHVsZSB0eXBlIEJhc2ljMl9sb2NhbCA9IEJhc2ljMl9sb2NhbFxuICBtb2R1bGUgdHlwZSBJbmZpeCA9IEluZml4XG4gIG1vZHVsZSB0eXBlIEluZml4MiA9IEluZml4MlxuICBtb2R1bGUgdHlwZSBJbmZpeDMgPSBJbmZpeDNcbiAgbW9kdWxlIHR5cGUgSW5maXhfaW5kZXhlZCA9IEluZml4X2luZGV4ZWRcbiAgbW9kdWxlIHR5cGUgSW5maXhfbG9jYWwgPSBJbmZpeF9sb2NhbFxuICBtb2R1bGUgdHlwZSBJbmZpeDJfbG9jYWwgPSBJbmZpeDJfbG9jYWxcbiAgbW9kdWxlIHR5cGUgU3ludGF4ID0gU3ludGF4XG4gIG1vZHVsZSB0eXBlIFN5bnRheDIgPSBTeW50YXgyXG4gIG1vZHVsZSB0eXBlIFN5bnRheDMgPSBTeW50YXgzXG4gIG1vZHVsZSB0eXBlIFN5bnRheF9pbmRleGVkID0gU3ludGF4X2luZGV4ZWRcbiAgbW9kdWxlIHR5cGUgU3ludGF4X2xvY2FsID0gU3ludGF4X2xvY2FsXG4gIG1vZHVsZSB0eXBlIFN5bnRheDJfbG9jYWwgPSBTeW50YXgyX2xvY2FsXG4gIG1vZHVsZSB0eXBlIFNfd2l0aG91dF9zeW50YXggPSBTX3dpdGhvdXRfc3ludGF4XG4gIG1vZHVsZSB0eXBlIFNfd2l0aG91dF9zeW50YXhfbG9jYWwgPSBTX3dpdGhvdXRfc3ludGF4X2xvY2FsXG4gIG1vZHVsZSB0eXBlIFMgPSBTXG4gIG1vZHVsZSB0eXBlIFMyID0gUzJcbiAgbW9kdWxlIHR5cGUgUzMgPSBTM1xuICBtb2R1bGUgdHlwZSBTX2luZGV4ZWQgPSBTX2luZGV4ZWRcbiAgbW9kdWxlIHR5cGUgU19sb2NhbCA9IFNfbG9jYWxcbiAgbW9kdWxlIHR5cGUgUzJfbG9jYWwgPSBTMl9sb2NhbFxuXG4gIG1vZHVsZSBNYWtlIChYIDogQmFzaWMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnRcbiAgbW9kdWxlIE1ha2UyIChYIDogQmFzaWMyKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIFgudFxuICBtb2R1bGUgTWFrZTMgKFggOiBCYXNpYzMpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBYLnRcblxuICBtb2R1bGUgTWFrZV9pbmRleGVkIChYIDogQmFzaWNfaW5kZXhlZCkgOlxuICAgIFNfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIFgudFxuXG4gIG1vZHVsZSBNYWtlX2xvY2FsIChYIDogQmFzaWNfbG9jYWwpIDogU19sb2NhbCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnRcbiAgbW9kdWxlIE1ha2UyX2xvY2FsIChYIDogQmFzaWMyX2xvY2FsKSA6IFMyX2xvY2FsIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIFgudFxuXG4gICgqKiBEZWZpbmUgYSBtb25hZCB0aHJvdWdoIGFuIGlzb21vcnBoaXNtIHdpdGggYW4gZXhpc3RpbmcgbW9uYWQuIEZvciBleGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlICdhIHQgPSB7IHZhbHVlIDogJ2EgfVxuXG4gICAgICAgIGluY2x1ZGUgTW9uYWQuT2ZfbW9uYWQgKE1vbmFkLklkZW50KSAoc3RydWN0XG4gICAgICAgICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICAgICAgICBsZXQgdG9fbW9uYWQgeyB2YWx1ZSB9ID0gdmFsdWVcbiAgICAgICAgICAgIGxldCBvZl9tb25hZCB2YWx1ZSA9IHsgdmFsdWUgfVxuICAgICAgICAgIGVuZClcbiAgICAgIF19ICopXG4gIG1vZHVsZSBPZl9tb25hZFxuICAgIChNb25hZCA6IFMpIChNIDogc2lnXG4gICAgICB0eXBlICdhIHRcblxuICAgICAgdmFsIHRvX21vbmFkIDogJ2EgdCAtPiAnYSBNb25hZC50XG4gICAgICB2YWwgb2ZfbW9uYWQgOiAnYSBNb25hZC50IC0+ICdhIHRcbiAgICBlbmQpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBNLnRcblxuICBtb2R1bGUgT2ZfbW9uYWQyXG4gICAgKE1vbmFkIDogUzIpIChNIDogc2lnXG4gICAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSBNb25hZC50XG4gICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdiKSBNb25hZC50IC0+ICgnYSwgJ2IpIHRcbiAgICBlbmQpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgTS50XG5cbiAgbW9kdWxlIE9mX21vbmFkM1xuICAgIChNb25hZCA6IFMzKSAoTSA6IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgTW9uYWQudFxuICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnYiwgJ2MpIE1vbmFkLnQgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICBlbmQpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSBNLnRcblxuICBtb2R1bGUgT2ZfbW9uYWRfaW5kZXhlZFxuICAgIChNb25hZCA6IFNfaW5kZXhlZCkgKE0gOiBzaWdcbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdhLCAnaSwgJ2opIE1vbmFkLnRcbiAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2ksICdqKSBNb25hZC50IC0+ICgnYSwgJ2ksICdqKSB0XG4gICAgZW5kKSA6IFNfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIE0udFxuXG4gICgqKiBBbiBlYWdlciBpZGVudGl0eSBtb25hZCB3aXRoIGZ1bmN0aW9ucyBoZWF2aWx5IGFubm90YXRlZCB3aXRoXG4gICAgICBbQGlubGluZWRdIG9yIFtAaW5saW5lIGhpbnRdLlxuXG4gICAgICBUaGUgaW1wbGVtZW50YXRpb24gaXMgbWFudWFsbHkgd3JpdHRlbiwgcmF0aGVyIHRoYW4gYmVpbmdcbiAgICAgIGNvbnN0cnVjdGVkIGJ5IFtNb25hZC5NYWtlXS4gVGhpcyBnaXZlcyBiZXR0ZXIgaW5saW5pbmdcbiAgICAgIGd1YXJhbnRlZXMuXG4gICopXG4gIG1vZHVsZSBJZGVudCA6IFNfbG9jYWwgd2l0aCB0eXBlICdhIHQgPSAnYVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBMaXN0ID0gTGlzdDBcbmluY2x1ZGUgTW9uYWRfaW50ZlxuXG5tb2R1bGUgdHlwZSBCYXNpY19nZW5lcmFsID0gc2lnXG4gIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuXG4gIHZhbCBiaW5kXG4gICAgOiAgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgIC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrLCAnZCwgJ2UpIHQpXG4gICAgLT4gKCdiLCAnaSwgJ2ssICdkLCAnZSkgdFxuXG4gIHZhbCBtYXBcbiAgICA6IFsgYERlZmluZV91c2luZ19iaW5kXG4gICAgICB8IGBDdXN0b20gb2YgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgICAgXVxuXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSwgJ2QsICdlKSB0XG5lbmRcblxubW9kdWxlIE1ha2VfZ2VuZXJhbCAoTSA6IEJhc2ljX2dlbmVyYWwpID0gc3RydWN0XG4gIGxldCBiaW5kID0gTS5iaW5kXG4gIGxldCByZXR1cm4gPSBNLnJldHVyblxuICBsZXQgbWFwX3ZpYV9iaW5kIG1hIH5mID0gTS5iaW5kIG1hIH5mOihmdW4gYSAtPiBNLnJldHVybiAoZiBhKSlcblxuICBsZXQgbWFwID1cbiAgICBtYXRjaCBNLm1hcCB3aXRoXG4gICAgfCBgRGVmaW5lX3VzaW5nX2JpbmQgLT4gbWFwX3ZpYV9iaW5kXG4gICAgfCBgQ3VzdG9tIHggLT4geFxuICA7O1xuXG4gIG1vZHVsZSBNb25hZF9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoID4+PSApIHQgZiA9IGJpbmQgdCB+ZlxuICAgIGxldCAoID4+fCApIHQgZiA9IG1hcCB0IH5mXG4gIGVuZFxuXG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cblxuICAgIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGxldCBtYXAgPSBtYXBcbiAgICAgIGxldCBib3RoIGEgYiA9IGEgPj49IGZ1biBhIC0+IGIgPj58IGZ1biBiIC0+IGEsIGJcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBsZXQgam9pbiB0ID0gdCA+Pj0gZnVuIHQnIC0+IHQnXG4gIGxldCBpZ25vcmVfbSB0ID0gbWFwIHQgfmY6KGZ1biBfIC0+ICgpKVxuXG4gIGxldCBhbGwgPVxuICAgIGxldCByZWMgbG9vcCB2cyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJldHVybiAoTGlzdC5yZXYgdnMpXG4gICAgICB8IHQgOjogdHMgLT4gdCA+Pj0gZnVuIHYgLT4gbG9vcCAodiA6OiB2cykgdHNcbiAgICBpblxuICAgIGZ1biB0cyAtPiBsb29wIFtdIHRzXG4gIDs7XG5cbiAgbGV0IHJlYyBhbGxfdW5pdCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXR1cm4gKClcbiAgICB8IHQgOjogdHMgLT4gdCA+Pj0gZnVuICgpIC0+IGFsbF91bml0IHRzXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2VfaW5kZXhlZCAoTSA6IEJhc2ljX2luZGV4ZWQpIDpcbiAgU19pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgTS50ID0gTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnaSwgJ2opIE0udFxuZW5kKVxuXG5tb2R1bGUgTWFrZTMgKE0gOiBCYXNpYzMpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBNLnQgPVxuTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCwgJ2UpIE0udFxuZW5kKVxuXG5tb2R1bGUgTWFrZTIgKE0gOiBCYXNpYzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2QpIHQgOj0gKCdhLCAnZCkgTS50ID0gTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgTS50XG5lbmQpXG5cbm1vZHVsZSBNYWtlIChNIDogQmFzaWMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBNLnQgPSBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICBpbmNsdWRlIE1cblxuICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAnYSBNLnRcbmVuZClcblxubW9kdWxlIE1ha2UyX2xvY2FsIChNIDogQmFzaWMyX2xvY2FsKSA9IHN0cnVjdFxuICBsZXQgYmluZCA9IE0uYmluZFxuICBsZXQgcmV0dXJuID0gTS5yZXR1cm5cblxuICBsZXQgbWFwX3ZpYV9iaW5kIG1hIH5mID1cbiAgICBsZXQgcmVzID0gTS5iaW5kIG1hIH5mOihmdW4gYSAtPiBNLnJldHVybiAoZiBhKSkgaW5cbiAgICByZXNcbiAgOztcblxuICBsZXQgbWFwID1cbiAgICBtYXRjaCBNLm1hcCB3aXRoXG4gICAgfCBgRGVmaW5lX3VzaW5nX2JpbmQgLT4gbWFwX3ZpYV9iaW5kXG4gICAgfCBgQ3VzdG9tIHggLT4geFxuICA7O1xuXG4gIG1vZHVsZSBNb25hZF9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoID4+PSApIHQgZiA9IGJpbmQgdCB+ZlxuICAgIGxldCAoID4+fCApIHQgZiA9IG1hcCB0IH5mXG4gIGVuZFxuXG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cblxuICAgIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGxldCBtYXAgPSBtYXBcblxuICAgICAgbGV0IGJvdGggYSBiID1cbiAgICAgICAgbGV0IHJlcyA9XG4gICAgICAgICAgYmluZCBhIH5mOihmdW4gYSAtPlxuICAgICAgICAgICAgbGV0IHJlcyA9IG1hcCBiIH5mOihmdW4gYiAtPiBhLCBiKSBpblxuICAgICAgICAgICAgcmVzKVxuICAgICAgICBpblxuICAgICAgICByZXNcbiAgICAgIDs7XG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgbGV0IGpvaW4gdCA9IHQgPj49IEZuLmlkXG5cbiAgbGV0IGlnbm9yZV9tIHQgPVxuICAgIGxldCByZXMgPSBtYXAgdCB+ZjooZnVuIF8gLT4gKCkpIGluXG4gICAgcmVzXG4gIDs7XG5cbiAgbGV0IGFsbCA9XG4gICAgbGV0IHJlYyBsb29wIHZzID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIChMaXN0LnJldiB2cylcbiAgICAgIHwgdCA6OiB0cyAtPiB0ID4+PSBmdW4gdiAtPiBsb29wICh2IDo6IHZzKSB0c1xuICAgIGluXG4gICAgZnVuIHRzIC0+IGxvb3AgW10gdHNcbiAgOztcblxuICBsZXQgcmVjIGFsbF91bml0ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldHVybiAoKVxuICAgIHwgdCA6OiB0cyAtPiB0ID4+PSBmdW4gKCkgLT4gYWxsX3VuaXQgdHNcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZV9sb2NhbCAoTSA6IEJhc2ljX2xvY2FsKSA6IFNfbG9jYWwgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50ID1cbk1ha2UyX2xvY2FsIChzdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgTS50XG5lbmQpXG5cbm1vZHVsZSBPZl9tb25hZF9nZW5lcmFsIChNb25hZCA6IHNpZ1xuICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcblxuICB2YWwgYmluZFxuICAgIDogICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICAtPiBmOignYSAtPiAoJ2IsICdqLCAnaywgJ2QsICdlKSB0KVxuICAgIC0+ICgnYiwgJ2ksICdrLCAnZCwgJ2UpIHRcblxuICB2YWwgbWFwIDogKCdhLCAnaSwgJ2osICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2osICdkLCAnZSkgdFxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2ksICdkLCAnZSkgdFxuZW5kKSAoTSA6IHNpZ1xuICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcblxuICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0IC0+ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIE1vbmFkLnRcbiAgdmFsIG9mX21vbmFkIDogKCdhLCAnaSwgJ2osICdkLCAnZSkgTW9uYWQudCAtPiAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG5lbmQpID1cbk1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIE0udFxuXG4gIGxldCByZXR1cm4gYSA9IE0ub2ZfbW9uYWQgKE1vbmFkLnJldHVybiBhKVxuICBsZXQgYmluZCB0IH5mID0gTS5vZl9tb25hZCAoTW9uYWQuYmluZCAoTS50b19tb25hZCB0KSB+ZjooZnVuIGEgLT4gTS50b19tb25hZCAoZiBhKSkpXG4gIGxldCBtYXAgPSBgQ3VzdG9tIChmdW4gdCB+ZiAtPiBNLm9mX21vbmFkIChNb25hZC5tYXAgKE0udG9fbW9uYWQgdCkgfmYpKVxuZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWRfaW5kZXhlZFxuICAoTW9uYWQgOiBTX2luZGV4ZWQpIChNIDogc2lnXG4gICAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gICAgdmFsIHRvX21vbmFkIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdhLCAnaSwgJ2opIE1vbmFkLnRcbiAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdpLCAnaikgTW9uYWQudCAtPiAoJ2EsICdpLCAnaikgdFxuICBlbmQpID1cbiAgT2ZfbW9uYWRfZ2VuZXJhbFxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTW9uYWRcblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnaSwgJ2opIE1vbmFkLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2ksICdqKSBNLnRcbiAgICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZDNcbiAgKE1vbmFkIDogUzMpIChNIDogc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIHRvX21vbmFkIDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIE1vbmFkLnRcbiAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdiLCAnYykgTW9uYWQudCAtPiAoJ2EsICdiLCAnYykgdFxuICBlbmQpID1cbiAgT2ZfbW9uYWRfZ2VuZXJhbFxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTW9uYWRcblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCwgJ2UpIE1vbmFkLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QsICdlKSBNLnRcbiAgICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZDJcbiAgKE1vbmFkIDogUzIpIChNIDogc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIE1vbmFkLnRcbiAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdiKSBNb25hZC50IC0+ICgnYSwgJ2IpIHRcbiAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QpIE1vbmFkLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QpIE0udFxuICAgIGVuZClcblxubW9kdWxlIE9mX21vbmFkXG4gIChNb25hZCA6IFMpIChNIDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgdG9fbW9uYWQgOiAnYSB0IC0+ICdhIE1vbmFkLnRcbiAgICB2YWwgb2ZfbW9uYWQgOiAnYSBNb25hZC50IC0+ICdhIHRcbiAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICdhIE1vbmFkLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICdhIE0udFxuICAgIGVuZClcblxubW9kdWxlIElkZW50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhXG5cbiAgbGV0W0BpbmxpbmVdIGJpbmQgYSB+ZiA9IChmIFtAaW5saW5lZCBoaW50XSkgYVxuICBsZXRbQGlubGluZV0gbWFwIGEgfmYgPSAoZiBbQGlubGluZWQgaGludF0pIGFcblxuICBleHRlcm5hbCByZXR1cm4gOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgPSBcIiVpZGVudGl0eVwiXG5cbiAgbW9kdWxlIE1vbmFkX2luZml4ID0gc3RydWN0XG4gICAgbGV0W0BpbmxpbmVdICggPj58ICkgYSBmID0gbWFwIGEgfmZcbiAgICBsZXRbQGlubGluZV0gKCA+Pj0gKSBhIGYgPSBiaW5kIGEgfmZcbiAgZW5kXG5cbiAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gICAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgbGV0IG1hcCA9IG1hcFxuICAgICAgbGV0W0BpbmxpbmVdIGJvdGggYSBiID0gYSwgYlxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gICAgZW5kXG5cbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gIGVuZFxuXG4gIGV4dGVybmFsIGpvaW4gOiAoJ2FbQGxvY2FsX29wdF0pIC0+ICgnYVtAbG9jYWxfb3B0XSkgPSBcIiVpZGVudGl0eVwiXG4gIGV4dGVybmFsIGlnbm9yZV9tIDogKF9bQGxvY2FsX29wdF0pIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuICBleHRlcm5hbCBhbGxfdW5pdCA6ICh1bml0IGxpc3RbQGxvY2FsX29wdF0pIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuICBleHRlcm5hbCBhbGwgOiAoJ2EgbGlzdFtAbG9jYWxfb3B0XSkgLT4gKCdhIGxpc3RbQGxvY2FsX29wdF0pID0gXCIlaWRlbnRpdHlcIlxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQXBwbGljYXRpdmVfaW50ZlxubW9kdWxlIExpc3QgPSBMaXN0MFxuXG4oKiogVGhpcyBtb2R1bGUgc2VydmVzIG1vc3RseSBhcyBhIHBhcnRpYWwgY2hlY2sgdGhhdCBbUzJdIGFuZCBbU10gYXJlIGluIHN5bmMsIGJ1dFxuICAgIGFjdHVhbGx5IGNhbGxpbmcgaXQgaXMgb2NjYXNpb25hbGx5IHVzZWZ1bC4gKilcbm1vZHVsZSBTX3RvX1MyIChYIDogUykgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbmVuZFxuXG5tb2R1bGUgUzJfdG9fUyAoVCA6IFQuVCkgKFggOiBTMikgOiBTIHdpdGggdHlwZSAnYSB0ID0gKCdhLCBULnQpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICdhIHQgPSAoJ2EsIFQudCkgWC50XG5lbmRcblxubW9kdWxlIFMyX3RvX1MzIChYIDogUzIpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnRcbmVuZFxuXG5tb2R1bGUgUzNfdG9fUzIgKFQgOiBULlQpIChYIDogUzMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2QpIHQgPSAoJ2EsICdkLCBULnQpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2QpIHQgPSAoJ2EsICdkLCBULnQpIFgudFxuZW5kXG5cbm1vZHVsZSBTM190b19TIChUMSA6IFQuVCkgKFQyIDogVC5UKSAoWCA6IFMzKSA6IFMgd2l0aCB0eXBlICdhIHQgPSAoJ2EsIFQxLnQsIFQyLnQpIFgudCA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAnYSB0ID0gKCdhLCBUMS50LCBUMi50KSBYLnRcbmVuZFxuXG5tb2R1bGUgTWFrZTMgKFggOiBCYXNpYzMpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgbGV0ICggPCo+ICkgPSBhcHBseVxuICBsZXQgZGVyaXZlZF9tYXAgdCB+ZiA9IHJldHVybiBmIDwqPiB0XG5cbiAgbGV0IG1hcCA9XG4gICAgbWF0Y2ggWC5tYXAgd2l0aFxuICAgIHwgYERlZmluZV91c2luZ19hcHBseSAtPiBkZXJpdmVkX21hcFxuICAgIHwgYEN1c3RvbSB4IC0+IHhcbiAgOztcblxuICBsZXQgKCA+PnwgKSB0IGYgPSBtYXAgdCB+ZlxuICBsZXQgbWFwMiB0YSB0YiB+ZiA9IG1hcCB+ZiB0YSA8Kj4gdGJcbiAgbGV0IG1hcDMgdGEgdGIgdGMgfmYgPSBtYXAgfmYgdGEgPCo+IHRiIDwqPiB0Y1xuICBsZXQgYWxsIHRzID0gTGlzdC5mb2xkX3JpZ2h0IHRzIH5pbml0OihyZXR1cm4gW10pIH5mOihtYXAyIH5mOihmdW4geCB4cyAtPiB4IDo6IHhzKSlcbiAgbGV0IGJvdGggdGEgdGIgPSBtYXAyIHRhIHRiIH5mOihmdW4gYSBiIC0+IGEsIGIpXG4gIGxldCAoICo+ICkgdSB2ID0gcmV0dXJuIChmdW4gKCkgeSAtPiB5KSA8Kj4gdSA8Kj4gdlxuICBsZXQgKCA8KiApIHUgdiA9IHJldHVybiAoZnVuIHggKCkgLT4geCkgPCo+IHUgPCo+IHZcbiAgbGV0IGFsbF91bml0IHRzID0gTGlzdC5mb2xkIHRzIH5pbml0OihyZXR1cm4gKCkpIH5mOiggKj4gKVxuXG4gIG1vZHVsZSBBcHBsaWNhdGl2ZV9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoIDwqPiApID0gKCA8Kj4gKVxuICAgIGxldCAoICo+ICkgPSAoICo+IClcbiAgICBsZXQgKCA8KiApID0gKCA8KiApXG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBNYWtlMiAoWCA6IEJhc2ljMikgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBYLnQgPSBNYWtlMyAoc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnRcbmVuZClcblxubW9kdWxlIE1ha2UgKFggOiBCYXNpYykgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIFgudCA9IE1ha2UyIChzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG5lbmQpXG5cbm1vZHVsZSBNYWtlX2xldF9zeW50YXgzXG4gIChYIDogRm9yX2xldF9zeW50YXgzKSAoSW50ZiA6IHNpZ1xuICAgIG1vZHVsZSB0eXBlIFNcbiAgZW5kKVxuICAoSW1wbCA6IEludGYuUykgPVxuc3RydWN0XG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgaW5jbHVkZSBYXG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBYXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBJbXBsXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBNYWtlX2xldF9zeW50YXgyXG4gIChYIDogRm9yX2xldF9zeW50YXgyKSAoSW50ZiA6IHNpZ1xuICAgIG1vZHVsZSB0eXBlIFNcbiAgZW5kKVxuICAoSW1wbCA6IEludGYuUykgPVxuICBNYWtlX2xldF9zeW50YXgzXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBYXG5cbiAgICAgIHR5cGUgKCdhLCAnZCwgXykgdCA9ICgnYSwgJ2QpIFgudFxuICAgIGVuZClcbiAgICAoSW50ZilcbiAgICAoSW1wbClcblxubW9kdWxlIE1ha2VfbGV0X3N5bnRheFxuICAoWCA6IEZvcl9sZXRfc3ludGF4KSAoSW50ZiA6IHNpZ1xuICAgIG1vZHVsZSB0eXBlIFNcbiAgZW5kKVxuICAoSW1wbCA6IEludGYuUykgPVxuICBNYWtlX2xldF9zeW50YXgyXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBYXG5cbiAgICAgIHR5cGUgKCdhLCBfKSB0ID0gJ2EgWC50XG4gICAgZW5kKVxuICAgIChJbnRmKVxuICAgIChJbXBsKVxuXG4oKiogVGhpcyBmdW5jdG9yIGNsb3NlbHkgcmVzZW1ibGVzIFtNYWtlM10sIGFuZCBpbmRlZWQgaXQgY291bGQgYmUgaW1wbGVtZW50ZWRcbiAgICBtdWNoIHNob3J0ZXIgaW4gdGVybXMgb2YgW01ha2UzXS4gSG93ZXZlciwgd2UgaW1wbGVtZW50IGl0IGJ5IGhhbmQgc28gdGhhdFxuICAgIHRoZSByZXN1bHRpbmcgZnVuY3Rpb25zIGFyZSBtb3JlIGVmZmljaWVudCwgZS5nLiB1c2luZyBbbWFwMl0gZGlyZWN0bHkgaW5zdGVhZCBvZlxuICAgIGRlZmluaW5nIFthcHBseV0gaW4gdGVybXMgb2YgaXQgYW5kIHRoZW4gW21hcDJdIGluIHRlcm1zIG9mIHRoYXQuIEZvciBtb3N0XG4gICAgYXBwbGljYXRpdmVzIHRoaXMgZG9lcyBub3QgbWF0dGVyLCBidXQgZm9yIHNvbWUgKHN1Y2ggYXMgQm9uc2FpLlZhbHVlLnQpLCBpdCBoYXMgYVxuICAgIGxhcmdlciBpbXBhY3QuICopXG5tb2R1bGUgTWFrZTNfdXNpbmdfbWFwMiAoWCA6IEJhc2ljM191c2luZ19tYXAyKSA6XG4gIFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIGxldCBhcHBseSB0ZiB0YSA9IG1hcDIgdGYgdGEgfmY6KGZ1biBmIGEgLT4gZiBhKVxuICBsZXQgKCA8Kj4gKSA9IGFwcGx5XG4gIGxldCBkZXJpdmVkX21hcCB0IH5mID0gcmV0dXJuIGYgPCo+IHRcblxuICBsZXQgbWFwID1cbiAgICBtYXRjaCBYLm1hcCB3aXRoXG4gICAgfCBgRGVmaW5lX3VzaW5nX21hcDIgLT4gZGVyaXZlZF9tYXBcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgbGV0IGJvdGggdGEgdGIgPSBtYXAyIHRhIHRiIH5mOihmdW4gYSBiIC0+IGEsIGIpXG4gIGxldCBtYXAzIHRhIHRiIHRjIH5mID0gbWFwMiAobWFwMiB0YSB0YiB+ZikgdGMgfmY6KGZ1biBmYWIgYyAtPiBmYWIgYylcbiAgbGV0IGFsbCB0cyA9IExpc3QuZm9sZF9yaWdodCB0cyB+aW5pdDoocmV0dXJuIFtdKSB+ZjoobWFwMiB+ZjooZnVuIHggeHMgLT4geCA6OiB4cykpXG4gIGxldCAoICo+ICkgdSB2ID0gbWFwMiB1IHYgfmY6KGZ1biAoKSB5IC0+IHkpXG4gIGxldCAoIDwqICkgdSB2ID0gbWFwMiB1IHYgfmY6KGZ1biB4ICgpIC0+IHgpXG4gIGxldCBhbGxfdW5pdCB0cyA9IExpc3QuZm9sZCB0cyB+aW5pdDoocmV0dXJuICgpKSB+ZjooICo+IClcblxuICBtb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA8Kj4gKSA9ICggPCo+IClcbiAgICBsZXQgKCAqPiApID0gKCAqPiApXG4gICAgbGV0ICggPCogKSA9ICggPCogKVxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZTJfdXNpbmdfbWFwMiAoWCA6IEJhc2ljMl91c2luZ19tYXAyKSA6XG4gIFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIFgudCA9IE1ha2UzX3VzaW5nX21hcDIgKHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG5lbmQpXG5cbm1vZHVsZSBNYWtlX3VzaW5nX21hcDIgKFggOiBCYXNpY191c2luZ19tYXAyKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50ID1cbk1ha2UyX3VzaW5nX21hcDIgKHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbmVuZClcblxubW9kdWxlIE1ha2UzX3VzaW5nX21hcDJfbG9jYWwgKFggOiBCYXNpYzNfdXNpbmdfbWFwMl9sb2NhbCkgOlxuICBTM19sb2NhbCB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICBsZXQgYXBwbHkgdGYgdGEgPSBtYXAyIHRmIHRhIH5mOihmdW4gZiBhIC0+IGYgYSlcbiAgbGV0ICggPCo+ICkgPSBhcHBseVxuICBsZXQgZGVyaXZlZF9tYXAgdCB+ZiA9IG1hcDIgfmY6KGZ1biAoKSAtPiBmKSAocmV0dXJuICgpKSB0IFtAbm9udGFpbF1cblxuICBsZXQgbWFwID1cbiAgICBtYXRjaCBYLm1hcCB3aXRoXG4gICAgfCBgRGVmaW5lX3VzaW5nX21hcDIgLT4gZGVyaXZlZF9tYXBcbiAgICB8IGBDdXN0b20gbWFwIC0+IG1hcFxuICA7O1xuXG4gIGxldCAoID4+fCApIHQgZiA9IG1hcCB0IH5mXG4gIGxldCBib3RoIHRhIHRiID0gbWFwMiB0YSB0YiB+ZjooZnVuIGEgYiAtPiBhLCBiKVxuXG4gIGxldCBtYXAzIHRhIHRiIHRjIH5mID1cbiAgICBsZXQgcmVzID0gbWFwMiAoYm90aCB0YSB0YikgdGMgfmY6KGZ1biAoYSwgYikgYyAtPiBmIGEgYiBjKSBpblxuICAgIHJlc1xuICA7O1xuXG4gIGxldCBhbGwgdHMgPSBMaXN0LmZvbGRfcmlnaHQgdHMgfmluaXQ6KHJldHVybiBbXSkgfmY6KG1hcDIgfmY6KGZ1biB4IHhzIC0+IHggOjogeHMpKVxuICBsZXQgKCAqPiApIHUgdiA9IG1hcDIgdSB2IH5mOihmdW4gKCkgeSAtPiB5KVxuICBsZXQgKCA8KiApIHUgdiA9IG1hcDIgdSB2IH5mOihmdW4geCAoKSAtPiB4KVxuICBsZXQgYWxsX3VuaXQgdHMgPSBMaXN0LmZvbGQgdHMgfmluaXQ6KHJldHVybiAoKSkgfmY6KCAqPiApXG5cbiAgbW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPCo+ICkgPSAoIDwqPiApXG4gICAgbGV0ICggKj4gKSA9ICggKj4gKVxuICAgIGxldCAoIDwqICkgPSAoIDwqIClcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgZW5kXG5lbmRcblxubW9kdWxlIE1ha2UyX3VzaW5nX21hcDJfbG9jYWwgKFggOiBCYXNpYzJfdXNpbmdfbWFwMl9sb2NhbCkgOlxuICBTMl9sb2NhbCB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBYLnQgPSBNYWtlM191c2luZ19tYXAyX2xvY2FsIChzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuZW5kKVxuXG5tb2R1bGUgTWFrZV91c2luZ19tYXAyX2xvY2FsIChYIDogQmFzaWNfdXNpbmdfbWFwMl9sb2NhbCkgOlxuICBTX2xvY2FsIHdpdGggdHlwZSAnYSB0IDo9ICdhIFgudCA9IE1ha2UyX3VzaW5nX21hcDJfbG9jYWwgKHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbmVuZClcblxubW9kdWxlIE9mX21vbmFkMiAoTSA6IE1vbmFkLlMyKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIE0udCA9IE1ha2UyIChzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSkgTS50XG5cbiAgbGV0IHJldHVybiA9IE0ucmV0dXJuXG4gIGxldCBhcHBseSBtZiBteCA9IE0uYmluZCBtZiB+ZjooZnVuIGYgLT4gTS5tYXAgbXggfmYpXG4gIGxldCBtYXAgPSBgQ3VzdG9tIE0ubWFwXG5lbmQpXG5cbm1vZHVsZSBPZl9tb25hZCAoTSA6IE1vbmFkLlMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBNLnQgPSBPZl9tb25hZDIgKHN0cnVjdFxuICBpbmNsdWRlIE1cblxuICB0eXBlICgnYSwgXykgdCA9ICdhIE0udFxuZW5kKVxuXG5tb2R1bGUgQ29tcG9zZSAoRiA6IFMpIChHIDogUykgOiBTIHdpdGggdHlwZSAnYSB0ID0gJ2EgRi50IEcudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBGLnQgRy50XG5cbiAgaW5jbHVkZSBNYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiBhID0gRy5yZXR1cm4gKEYucmV0dXJuIGEpXG4gICAgbGV0IGFwcGx5IHRmIHR4ID0gRy5hcHBseSAoRy5tYXAgfmY6Ri5hcHBseSB0ZikgdHhcbiAgICBsZXQgY3VzdG9tX21hcCB0IH5mID0gRy5tYXAgfmY6KEYubWFwIH5mKSB0XG4gICAgbGV0IG1hcCA9IGBDdXN0b20gY3VzdG9tX21hcFxuICBlbmQpXG5lbmRcblxubW9kdWxlIFBhaXIgKEYgOiBTKSAoRyA6IFMpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICdhIEYudCAqICdhIEcudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBGLnQgKiAnYSBHLnRcblxuICBpbmNsdWRlIE1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuIGEgPSBGLnJldHVybiBhLCBHLnJldHVybiBhXG4gICAgbGV0IGFwcGx5IHRmIHR4ID0gRi5hcHBseSAoZnN0IHRmKSAoZnN0IHR4KSwgRy5hcHBseSAoc25kIHRmKSAoc25kIHR4KVxuICAgIGxldCBjdXN0b21fbWFwIHQgfmYgPSBGLm1hcCB+ZiAoZnN0IHQpLCBHLm1hcCB+ZiAoc25kIHQpXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gY3VzdG9tX21hcFxuICBlbmQpXG5lbmRcblxubW9kdWxlIElkZW50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhXG5cbiAgaW5jbHVkZSBNYWtlX3VzaW5nX21hcDJfbG9jYWwgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuID0gRm4uaWRcbiAgICBsZXQgbWFwMiBhIGIgfmYgPSBmIGEgYlxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIChmdW4gYSB+ZiAtPiBmIGEpXG4gIGVuZClcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgKCdhLCAnd2l0bmVzcykgdCA9XG4gIHsgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludFxuICA7IHNleHBfb2ZfdCA6ICdhIC0+IFNleHAudFxuICB9XG5cbnR5cGUgKCdhLCAnYikgY29tcGFyYXRvciA9ICgnYSwgJ2IpIHRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIHRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvciA6ICh0LCBjb21wYXJhdG9yX3dpdG5lc3MpIGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSB0LCBjb21wYXJhdG9yX3dpdG5lc3MpIGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX2ZjID0gc2lnXG4gIHR5cGUgY29tcGFyYWJsZV90XG5cbiAgaW5jbHVkZSBTIHdpdGggdHlwZSB0IDo9IGNvbXBhcmFibGVfdFxuZW5kXG5cbm1vZHVsZSBNb2R1bGUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID0gKG1vZHVsZSBTIHdpdGggdHlwZSB0ID0gJ2EgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2IpXG5lbmRcblxubGV0IG9mX21vZHVsZSAodHlwZSBhIGIpICgobW9kdWxlIE0pIDogKGEsIGIpIE1vZHVsZS50KSA9IE0uY29tcGFyYXRvclxuXG5sZXQgdG9fbW9kdWxlICh0eXBlIGEgYikgdCA6IChhLCBiKSBNb2R1bGUudCA9XG4gIChtb2R1bGUgc3RydWN0XG4gICAgdHlwZSB0ID0gYVxuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gYlxuXG4gICAgbGV0IGNvbXBhcmF0b3IgPSB0XG4gIGVuZClcbjs7XG5cbmxldCBtYWtlICh0eXBlIHQpIH5jb21wYXJlIH5zZXhwX29mX3QgPVxuICAobW9kdWxlIHN0cnVjdFxuICAgIHR5cGUgY29tcGFyYWJsZV90ID0gdFxuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgICBsZXQgY29tcGFyYXRvciA9IHsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgZW5kIDogU19mY1xuICAgIHdpdGggdHlwZSBjb21wYXJhYmxlX3QgPSB0KVxuOztcblxubW9kdWxlIFNfdG9fUzEgKFMgOiBTKSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSBTLnRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBTLmNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIG9wZW4gU1xuXG4gIGxldCBjb21wYXJhdG9yID0gY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBNYWtlIChNIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmQpID1cbnN0cnVjdFxuICBpbmNsdWRlIE1cblxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yID0gTS57IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5lbmRcblxubW9kdWxlIE1ha2UxIChNIDogc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBjb21wYXJlIDogJ2EgdCAtPiAnYSB0IC0+IGludFxuICB2YWwgc2V4cF9vZl90IDogJ2EgdCAtPiBTZXhwLnRcbmVuZCkgPVxuc3RydWN0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBNLnsgY29tcGFyZTsgc2V4cF9vZl90IH1cbmVuZFxuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYVxuXG4gIGluY2x1ZGUgTWFrZTEgKHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhXG5cbiAgICBsZXQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICAgIGxldCBzZXhwX29mX3QgXyA9IFNleHAuQXRvbSBcIl9cIlxuICBlbmQpXG5lbmRcblxubW9kdWxlIHR5cGUgRGVyaXZlZCA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSAhJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSwgJ2NtcCkgY29tcGFyYXRvciAtPiAoJ2EgdCwgJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3MpIGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgRGVyaXZlZCAoTSA6IHNpZ1xuICB0eXBlICdhIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgdmFsIHNleHBfb2ZfdCA6ICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZCkgPVxuc3RydWN0XG4gIHR5cGUgISdjbXAgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgYSA9XG4gICAgeyBjb21wYXJlID0gTS5jb21wYXJlIGEuY29tcGFyZTsgc2V4cF9vZl90ID0gTS5zZXhwX29mX3QgYS5zZXhwX29mX3QgfVxuICA7O1xuZW5kXG5cbm1vZHVsZSB0eXBlIERlcml2ZWQyID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICghJ2NtcF9hLCAhJ2NtcF9iKSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvclxuICAgIDogICgnYSwgJ2NtcF9hKSBjb21wYXJhdG9yXG4gICAgLT4gKCdiLCAnY21wX2IpIGNvbXBhcmF0b3JcbiAgICAtPiAoKCdhLCAnYikgdCwgKCdjbXBfYSwgJ2NtcF9iKSBjb21wYXJhdG9yX3dpdG5lc3MpIGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgRGVyaXZlZDIgKE0gOiBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gIHZhbCBzZXhwX29mX3RcbiAgICA6ICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmQpID1cbnN0cnVjdFxuICB0eXBlICghJ2NtcF9hLCAhJ2NtcF9iKSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciBhIGIgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmUgYi5jb21wYXJlXG4gICAgOyBzZXhwX29mX3QgPSBNLnNleHBfb2ZfdCBhLnNleHBfb2ZfdCBiLnNleHBfb2ZfdFxuICAgIH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkX3BoYW50b20gPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvclxuICAgIDogICgnYSwgJ2NtcCkgY29tcGFyYXRvclxuICAgIC0+ICgoJ2EsIF8pIHQsICdjbXAgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIERlcml2ZWRfcGhhbnRvbSAoTSA6IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcblxuICB2YWwgY29tcGFyZSA6ICgnYSAtPiAnYSAtPiBpbnQpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBpbnRcbiAgdmFsIHNleHBfb2ZfdCA6ICgnYSAtPiBTZXhwLnQpIC0+ICgnYSwgXykgdCAtPiBTZXhwLnRcbmVuZCkgPVxuc3RydWN0XG4gIHR5cGUgJ2NtcF9hIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yIGEgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmU7IHNleHBfb2ZfdCA9IE0uc2V4cF9vZl90IGEuc2V4cF9vZl90IH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkMl9waGFudG9tID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRcbiAgdHlwZSAoISdjbXBfYSwgISdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3JcbiAgICA6ICAoJ2EsICdjbXBfYSkgY29tcGFyYXRvclxuICAgIC0+ICgnYiwgJ2NtcF9iKSBjb21wYXJhdG9yXG4gICAgLT4gKCgnYSwgJ2IsIF8pIHQsICgnY21wX2EsICdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIERlcml2ZWQyX3BoYW50b20gKE0gOiBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gIHZhbCBjb21wYXJlXG4gICAgOiAgKCdhIC0+ICdhIC0+IGludClcbiAgICAtPiAoJ2IgLT4gJ2IgLT4gaW50KVxuICAgIC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAtPiBpbnRcblxuICB2YWwgc2V4cF9vZl90IDogKCdhIC0+IFNleHAudCkgLT4gKCdiIC0+IFNleHAudCkgLT4gKCdhLCAnYiwgXykgdCAtPiBTZXhwLnRcbmVuZCkgPVxuc3RydWN0XG4gIHR5cGUgKCEnY21wX2EsICEnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yIGEgYiA9XG4gICAgeyBjb21wYXJlID0gTS5jb21wYXJlIGEuY29tcGFyZSBiLmNvbXBhcmVcbiAgICA7IHNleHBfb2ZfdCA9IE0uc2V4cF9vZl90IGEuc2V4cF9vZl90IGIuc2V4cF9vZl90XG4gICAgfVxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2YsICdzKSB0ID1cbiAgfCBGaXJzdCBvZiAnZlxuICB8IFNlY29uZCBvZiAnc1xuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBjb21wYXJlX19sb2NhbCA6XG4gICAgICAnZiAncy4gKCdmIC0+ICdmIC0+IGludCkgLT4gKCdzIC0+ICdzIC0+IGludCkgLT4gKCdmLCAncykgdCAtPiAoJ2YsICdzKSB0IC0+IGludFxuICA9XG4gIGZ1biBfY21wX19mIF9jbXBfX3MgYV9fMDA3XyBiX18wMDhfIC0+XG4gIGlmIFN0ZGxpYi4oID09ICkgYV9fMDA3XyBiX18wMDhfXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBtYXRjaCBhX18wMDdfLCBiX18wMDhfIHdpdGhcbiAgICB8IEZpcnN0IF9hX18wMDlfLCBGaXJzdCBfYl9fMDEwXyAtPiBfY21wX19mIF9hX18wMDlfIF9iX18wMTBfXG4gICAgfCBGaXJzdCBfLCBfIC0+IC0xXG4gICAgfCBfLCBGaXJzdCBfIC0+IDFcbiAgICB8IFNlY29uZCBfYV9fMDExXywgU2Vjb25kIF9iX18wMTJfIC0+IF9jbXBfX3MgX2FfXzAxMV8gX2JfXzAxMl8pXG47O1xuXG5sZXQgY29tcGFyZSA6XG4gICAgICAnZiAncy4gKCdmIC0+ICdmIC0+IGludCkgLT4gKCdzIC0+ICdzIC0+IGludCkgLT4gKCdmLCAncykgdCAtPiAoJ2YsICdzKSB0IC0+IGludFxuICA9XG4gIGZ1biBfY21wX19mIF9jbXBfX3MgYV9fMDAxXyBiX18wMDJfIC0+XG4gIGlmIFN0ZGxpYi4oID09ICkgYV9fMDAxXyBiX18wMDJfXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBtYXRjaCBhX18wMDFfLCBiX18wMDJfIHdpdGhcbiAgICB8IEZpcnN0IF9hX18wMDNfLCBGaXJzdCBfYl9fMDA0XyAtPiBfY21wX19mIF9hX18wMDNfIF9iX18wMDRfXG4gICAgfCBGaXJzdCBfLCBfIC0+IC0xXG4gICAgfCBfLCBGaXJzdCBfIC0+IDFcbiAgICB8IFNlY29uZCBfYV9fMDA1XywgU2Vjb25kIF9iX18wMDZfIC0+IF9jbXBfX3MgX2FfXzAwNV8gX2JfXzAwNl8pXG47O1xuXG5sZXQgaGFzaF9mb2xkX3RcbiAgOiB0eXBlIGYgcy5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGYgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gcyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgLT4gKGYsIHMpIHRcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgPVxuICBmdW4gX2hhc2hfZm9sZF9mIF9oYXNoX2ZvbGRfcyBoc3YgYXJnIC0+XG4gIG1hdGNoIGFyZyB3aXRoXG4gIHwgRmlyc3QgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMCBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX2YgaHN2IF9hMFxuICB8IFNlY29uZCBfYTAgLT5cbiAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxIGluXG4gICAgbGV0IGhzdiA9IGhzdiBpblxuICAgIF9oYXNoX2ZvbGRfcyBoc3YgX2EwXG47O1xuXG5sZXQgdF9vZl9zZXhwIDpcbiAgICAgICdmICdzLlxuICAgICAgKFNleHBsaWIwLlNleHAudCAtPiAnZikgLT4gKFNleHBsaWIwLlNleHAudCAtPiAncykgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICgnZiwgJ3MpIHRcbiAgPVxuICBmdW4gKHR5cGUgZl9fMDI5XyBzX18wMzBfKVxuICAgIDogICgoU2V4cGxpYjAuU2V4cC50IC0+IGZfXzAyOV8pIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gc19fMDMwXykgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgLT4gKGZfXzAyOV8sIHNfXzAzMF8pIHQpIC0+XG4gIGxldCBlcnJvcl9zb3VyY2VfXzAxN18gPSBcImVpdGhlcjAubWwudFwiIGluXG4gIGZ1biBfb2ZfZl9fMDEzXyBfb2Zfc19fMDE0XyAtPiBmdW5jdGlvblxuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImZpcnN0XCIgfCBcIkZpcnN0XCIpIGFzIF90YWdfXzAyMF8pIDo6IHNleHBfYXJnc19fMDIxXykgYXNcbiAgICAgIF9zZXhwX18wMTlfIC0+XG4gICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMjFfIHdpdGhcbiAgICAgICB8IGFyZzBfXzAyMl8gOjogW10gLT5cbiAgICAgICAgIGxldCByZXMwX18wMjNfID0gX29mX2ZfXzAxM18gYXJnMF9fMDIyXyBpblxuICAgICAgICAgRmlyc3QgcmVzMF9fMDIzX1xuICAgICAgIHwgXyAtPlxuICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAxN19cbiAgICAgICAgICAgX3RhZ19fMDIwX1xuICAgICAgICAgICBfc2V4cF9fMDE5XylcbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJzZWNvbmRcIiB8IFwiU2Vjb25kXCIpIGFzIF90YWdfXzAyNV8pIDo6IHNleHBfYXJnc19fMDI2XykgYXNcbiAgICAgIF9zZXhwX18wMjRfIC0+XG4gICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMjZfIHdpdGhcbiAgICAgICB8IGFyZzBfXzAyN18gOjogW10gLT5cbiAgICAgICAgIGxldCByZXMwX18wMjhfID0gX29mX3NfXzAxNF8gYXJnMF9fMDI3XyBpblxuICAgICAgICAgU2Vjb25kIHJlczBfXzAyOF9cbiAgICAgICB8IF8gLT5cbiAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMTdfXG4gICAgICAgICAgIF90YWdfXzAyNV9cbiAgICAgICAgICAgX3NleHBfXzAyNF8pXG4gICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZmlyc3RcIiB8IFwiRmlyc3RcIikgYXMgc2V4cF9fMDE4XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAxN18gc2V4cF9fMDE4X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInNlY29uZFwiIHwgXCJTZWNvbmRcIikgYXMgc2V4cF9fMDE4XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAxN18gc2V4cF9fMDE4X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMTZfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMTdfIHNleHBfXzAxNl9cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMTZfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAxN18gc2V4cF9fMDE2X1xuICAgIHwgc2V4cF9fMDE2XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDE3XyBzZXhwX18wMTZfXG47O1xuXG5sZXQgc2V4cF9vZl90IDpcbiAgICAgICdmICdzLlxuICAgICAgKCdmIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdzIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdmLCAncykgdCAtPiBTZXhwbGliMC5TZXhwLnRcbiAgPVxuICBmdW4gKHR5cGUgZl9fMDM3XyBzX18wMzhfKVxuICAgIDogICgoZl9fMDM3XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChzX18wMzhfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoZl9fMDM3Xywgc19fMDM4XykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gIGZ1biBfb2ZfZl9fMDMxXyBfb2Zfc19fMDMyXyAtPiBmdW5jdGlvblxuICB8IEZpcnN0IGFyZzBfXzAzM18gLT5cbiAgICBsZXQgcmVzMF9fMDM0XyA9IF9vZl9mX18wMzFfIGFyZzBfXzAzM18gaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJGaXJzdFwiOyByZXMwX18wMzRfIF1cbiAgfCBTZWNvbmQgYXJnMF9fMDM1XyAtPlxuICAgIGxldCByZXMwX18wMzZfID0gX29mX3NfXzAzMl8gYXJnMF9fMDM1XyBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlNlY29uZFwiOyByZXMwX18wMzZfIF1cbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hciA6XG4gICAgICAnZiAncy5cbiAgICAgICdmIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAtPiAncyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gKCdmLCAncykgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIGZ1biBfJ2Zfc2V4cF9ncmFtbWFyIF8nc19zZXhwX2dyYW1tYXIgLT5cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkZpcnN0XCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydmX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJTZWNvbmRcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ3Nfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbltAQEBlbmRdXG4iLCIoKiBUaGUgdHlwZSBbdF0gc2hvdWxkIGJlIGFic3RyYWN0IHRvIG1ha2UgdGhlIGZzZXQgYW5kIHNldCBmdW5jdGlvbnMgdW5hdmFpbGFibGVcbiAgIGZvciBwcml2YXRlIHR5cGVzIGF0IHRoZSBsZXZlbCBvZiB0eXBlcyAoYW5kIG5vdCBieSBwdXR0aW5nIE5vbmUgaW4gdGhlIGZpZWxkKS5cbiAgIFVuZm9ydHVuYXRlbHksIG1ha2luZyB0aGUgdHlwZSBhYnN0cmFjdCBtZWFucyB0aGF0IHdoZW4gY3JlYXRpbmcgZmllbGRzICh0aHJvdWdoXG4gICBhIFtjcmVhdGVdIGZ1bmN0aW9uKSB2YWx1ZSByZXN0cmljdGlvbiBraWNrcyBpbi4gVGhpcyBpcyB3b3JrZWQgYXJvdW5kIGJ5IGluc3RlYWRcbiAgIG5vdCBtYWtpbmcgdGhlIHR5cGUgYWJzdHJhY3QsIGJ1dCBmb3JjaW5nIGFueW9uZSBicmVha2luZyB0aGUgYWJzdHJhY3Rpb24gdG8gdXNlXG4gICB0aGUgW0Zvcl9nZW5lcmF0ZWRfY29kZV0gbW9kdWxlLCBtYWtpbmcgaXQgb2J2aW91cyB0byBhbnkgcmVhZGVyIHRoYXQgc29tZXRoaW5nIHVnbHlcbiAgIGlzIGdvaW5nIG9uLlxuICAgdF93aXRoX3Blcm0gKGFuZCBkZXJpdmF0aXZlcykgaXMgdGhlIHR5cGUgdGhhdCB1c2VycyByZWFsbHkgdXNlLiBJdCBpcyBhIGNvbnN0cnVjdG9yXG4gICBiZWNhdXNlOlxuICAgMS4gaXQgbWFrZXMgdHlwZSBlcnJvcnMgbW9yZSByZWFkYWJsZSAobGVzcyBhbGlhc2luZylcbiAgIDIuIHRoZSB0eXBlciBpbiBvY2FtbCA0LjAxIGFsbG93cyB0aGlzOlxuXG4gICB7W1xuICAgICBtb2R1bGUgQSA9IHN0cnVjdFxuICAgICAgIHR5cGUgdCA9IHthIDogaW50fVxuICAgICBlbmRcbiAgICAgdHlwZSB0ID0gQS50XG4gICAgIGxldCBmICh4IDogdCkgPSB4LmFcbiAgIF19XG5cbiAgIChhbHRob3VnaCB3aXRoIFdhcm5pbmcgNDA6IGEgaXMgdXNlZCBvdXQgb2Ygc2NvcGUpXG4gICB3aGljaCBtZWFucyB0aGF0IGlmIFt0X3dpdGhfcGVybV0gd2FzIHJlYWxseSBhbiBhbGlhcyBvbiBbRm9yX2dlbmVyYXRlZF9jb2RlLnRdLFxuICAgcGVvcGxlIGNvdWxkIHNheSBbdC5zZXR0ZXJdIGFuZCBicmVhayB0aGUgYWJzdHJhY3Rpb24gd2l0aCBubyBpbmRpY2F0aW9uIHRoYXRcbiAgIHNvbWV0aGluZyB1Z2x5IGlzIGdvaW5nIG9uIGluIHRoZSBzb3VyY2UgY29kZS5cbiAgIFRoZSB3YXJuaW5nIGlzIChJIHRoaW5rKSBmb3IgcGVvcGxlIHdobyB3YW50IHRvIG1ha2UgdGhlaXIgY29kZSBjb21wYXRpYmxlIHdpdGhcbiAgIHByZXZpb3VzIHZlcnNpb25zIG9mIG9jYW1sLCBzbyB3ZSBtYXkgdmVyeSB3ZWxsIHR1cm4gaXQgb2ZmLlxuXG4gICBUaGUgdHlwZSB0X3dpdGhfcGVybSBjb3VsZCBhbHNvIGhhdmUgYmVlbiBhIFt1bml0IC0+IEZvcl9nZW5lcmF0ZWRfY29kZS50XSB0byB3b3JrXG4gICBhcm91bmQgdmFsdWUgcmVzdHJpY3Rpb24gYW5kIHRoZW4gW0Zvcl9nZW5lcmF0ZWRfY29kZS50XSB3b3VsZCBoYXZlIGJlZW4gYSBwcm9wZXJcbiAgIGFic3RyYWN0IHR5cGUsIGJ1dCBpdCBsb29rcyBsaWtlIGl0IGNvdWxkIGltcGFjdCBwZXJmb3JtYW5jZSAoZm9yIGV4YW1wbGUsIGEgZm9sZCBvbiBhXG4gICByZWNvcmQgdHlwZSB3aXRoIDQwIGZpZWxkcyB3b3VsZCBhY3R1YWxseSBhbGxvY2F0ZSB0aGUgNDAgW0Zvcl9nZW5lcmF0ZWRfY29kZS50XSdzIGF0XG4gICBldmVyeSBzaW5nbGUgZm9sZC4pICopXG5cbm1vZHVsZSBGb3JfZ2VuZXJhdGVkX2NvZGUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgdCA9XG4gICAgeyBmb3JjZV92YXJpYW5jZSA6ICdwZXJtIC0+IHVuaXRcbiAgICA7ICgqIGZvcmNlIFt0XSB0byBiZSBjb250cmF2YXJpYW50IGluIFsncGVybV0sIGJlY2F1c2UgcGhhbnRvbSB0eXBlIHZhcmlhYmxlcyBvblxuICAgICAgICAgY29uY3JldGUgdHlwZXMgZG9uJ3Qgd29yayB0aGF0IHdlbGwgb3RoZXJ3aXNlICh1c2luZyA6PiBjYW4gcmVtb3ZlIHRoZW0gZWFzaWx5KSAqKVxuICAgICAgbmFtZSA6IHN0cmluZ1xuICAgIDsgc2V0dGVyIDogKCdyZWNvcmQgLT4gJ2ZpZWxkIC0+IHVuaXQpIG9wdGlvblxuICAgIDsgZ2V0dGVyIDogJ3JlY29yZCAtPiAnZmllbGRcbiAgICA7IGZzZXQgOiAncmVjb3JkIC0+ICdmaWVsZCAtPiAncmVjb3JkXG4gICAgfVxuXG4gIGxldCBvcGFxdWVfaWRlbnRpdHkgPSBTeXMwLm9wYXF1ZV9pZGVudGl0eVxuZW5kXG5cbnR5cGUgKCdwZXJtLCAncmVjb3JkLCAnZmllbGQpIHRfd2l0aF9wZXJtID1cbiAgfCBGaWVsZCBvZiAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgRm9yX2dlbmVyYXRlZF9jb2RlLnRcbltAQHVuYm94ZWRdXG5cbnR5cGUgKCdyZWNvcmQsICdmaWVsZCkgdCA9IChbIGBSZWFkIHwgYFNldF9hbmRfY3JlYXRlIF0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm1cbnR5cGUgKCdyZWNvcmQsICdmaWVsZCkgcmVhZG9ubHlfdCA9IChbIGBSZWFkIF0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm1cblxubGV0IG5hbWUgKEZpZWxkIGZpZWxkKSA9IGZpZWxkLm5hbWVcbmxldCBnZXQgKEZpZWxkIGZpZWxkKSByID0gZmllbGQuZ2V0dGVyIHJcbmxldCBmc2V0IChGaWVsZCBmaWVsZCkgciB2ID0gZmllbGQuZnNldCByIHZcbmxldCBzZXR0ZXIgKEZpZWxkIGZpZWxkKSA9IGZpZWxkLnNldHRlclxuXG50eXBlICgncGVybSwgJ3JlY29yZCwgJ3Jlc3VsdCkgdXNlciA9XG4gIHsgZiA6ICdmaWVsZC4gKCdwZXJtLCAncmVjb3JkLCAnZmllbGQpIHRfd2l0aF9wZXJtIC0+ICdyZXN1bHQgfVxuXG5sZXQgbWFwIChGaWVsZCBmaWVsZCkgciB+ZiA9IGZpZWxkLmZzZXQgciAoZiAoZmllbGQuZ2V0dGVyIHIpKVxuXG5sZXQgdXBkYXRlciAoRmllbGQgZmllbGQpID1cbiAgbWF0Y2ggZmllbGQuc2V0dGVyIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHNldHRlciAtPiBTb21lIChmdW4gciB+ZiAtPiBzZXR0ZXIgciAoZiAoZmllbGQuZ2V0dGVyIHIpKSlcbjs7XG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBJbnQgPSBJbnQwXG5tb2R1bGUgU3lzID0gU3lzMFxuXG5sZXQgY29udmVydF9mYWlsdXJlIHggYSBiIHRvX3N0cmluZyA9XG4gIFByaW50Zi5mYWlsd2l0aGZcbiAgICBcImNvbnZlcnNpb24gZnJvbSAlcyB0byAlcyBmYWlsZWQ6ICVzIGlzIG91dCBvZiByYW5nZVwiXG4gICAgYVxuICAgIGJcbiAgICAodG9fc3RyaW5nIHgpXG4gICAgKClcbiAgW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbjs7XG5cbmxldCBudW1fYml0c19pbnQgPSBTeXMuaW50X3NpemVfaW5fYml0c1xubGV0IG51bV9iaXRzX2ludDMyID0gMzJcbmxldCBudW1fYml0c19pbnQ2NCA9IDY0XG5sZXQgbnVtX2JpdHNfbmF0aXZlaW50ID0gV29yZF9zaXplLm51bV9iaXRzIFdvcmRfc2l6ZS53b3JkX3NpemVcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50ID0gNjMgfHwgbnVtX2JpdHNfaW50ID0gMzEgfHwgbnVtX2JpdHNfaW50ID0gMzIpXG5sZXQgbWluX2ludDMyID0gU3RkbGliLkludDMyLm1pbl9pbnRcbmxldCBtYXhfaW50MzIgPSBTdGRsaWIuSW50MzIubWF4X2ludFxubGV0IG1pbl9pbnQ2NCA9IFN0ZGxpYi5JbnQ2NC5taW5faW50XG5sZXQgbWF4X2ludDY0ID0gU3RkbGliLkludDY0Lm1heF9pbnRcbmxldCBtaW5fbmF0aXZlaW50ID0gU3RkbGliLk5hdGl2ZWludC5taW5faW50XG5sZXQgbWF4X25hdGl2ZWludCA9IFN0ZGxpYi5OYXRpdmVpbnQubWF4X2ludFxubGV0IGludF90b19zdHJpbmcgPSBTdGRsaWIuc3RyaW5nX29mX2ludFxubGV0IGludDMyX3RvX3N0cmluZyA9IFN0ZGxpYi5JbnQzMi50b19zdHJpbmdcbmxldCBpbnQ2NF90b19zdHJpbmcgPSBTdGRsaWIuSW50NjQudG9fc3RyaW5nXG5sZXQgbmF0aXZlaW50X3RvX3N0cmluZyA9IFN0ZGxpYi5OYXRpdmVpbnQudG9fc3RyaW5nXG5cbigqIGludCA8LT4gaW50MzIgKilcblxubGV0IGludF90b19pbnQzMl9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludFwiIFwiaW50MzJcIiBpbnRfdG9fc3RyaW5nXG5sZXQgaW50MzJfdG9faW50X2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwiaW50MzJcIiBcImludFwiIGludDMyX3RvX3N0cmluZ1xubGV0IGludDMyX3RvX2ludF90cnVuYyA9IFN0ZGxpYi5JbnQzMi50b19pbnRcbmxldCBpbnRfdG9faW50MzJfdHJ1bmMgPSBTdGRsaWIuSW50MzIub2ZfaW50XG5cbmxldCBpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiA9XG4gIGlmIG51bV9iaXRzX2ludCA8PSBudW1fYml0c19pbnQzMlxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IGludDMyX3RvX2ludF90cnVuYyBtaW5faW50MzIgaW5cbiAgICBsZXQgbWF4ID0gaW50MzJfdG9faW50X3RydW5jIG1heF9pbnQzMiBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfaW50IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBpbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCA9XG4gIGlmIG51bV9iaXRzX2ludDMyIDw9IG51bV9iaXRzX2ludFxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IGludF90b19pbnQzMl90cnVuYyBJbnQubWluX3ZhbHVlIGluXG4gICAgbGV0IG1heCA9IGludF90b19pbnQzMl90cnVuYyBJbnQubWF4X3ZhbHVlIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9pbnQzMiBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50MzIgeCBtYXggPD0gMClcbjs7XG5cbmxldCBpbnRfdG9faW50MzIgeCA9XG4gIGlmIGludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHggdGhlbiBTb21lIChpbnRfdG9faW50MzJfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50MzJfdG9faW50IHggPVxuICBpZiBpbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAoaW50MzJfdG9faW50X3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludF90b19pbnQzMl9leG4geCA9XG4gIGlmIGludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHggdGhlbiBpbnRfdG9faW50MzJfdHJ1bmMgeCBlbHNlIGludF90b19pbnQzMl9mYWlsdXJlIHhcbjs7XG5cbmxldCBpbnQzMl90b19pbnRfZXhuIHggPVxuICBpZiBpbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gaW50MzJfdG9faW50X3RydW5jIHggZWxzZSBpbnQzMl90b19pbnRfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQgPC0+IGludDY0ICopXG5cbmxldFtAY29sZF0gaW50NjRfdG9faW50X2ZhaWx1cmUgeCA9XG4gIGNvbnZlcnRfZmFpbHVyZVxuICAgIChTdGRsaWIuSW50NjQuYWRkIHggMEwgKCogZm9yY2UgaW50NjQgYm94aW5nIHRvIGJlIGhlcmUgdW5kZXIgZmxhbWJkYTIgKikpXG4gICAgXCJpbnQ2NFwiXG4gICAgXCJpbnRcIlxuICAgIGludDY0X3RvX3N0cmluZ1xuOztcblxubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQgPCBudW1fYml0c19pbnQ2NClcbmxldCBpbnRfdG9faW50NjQgPSBTdGRsaWIuSW50NjQub2ZfaW50XG5sZXQgaW50NjRfdG9faW50X3RydW5jID0gU3RkbGliLkludDY0LnRvX2ludFxuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgPVxuICBsZXQgbWluID0gaW50X3RvX2ludDY0IEludC5taW5fdmFsdWUgaW5cbiAgbGV0IG1heCA9IGludF90b19pbnQ2NCBJbnQubWF4X3ZhbHVlIGluXG4gIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDBcbjs7XG5cbmxldCBpbnQ2NF90b19pbnQgeCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHggdGhlbiBTb21lIChpbnQ2NF90b19pbnRfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50NjRfdG9faW50X2V4biB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIGludDY0X3RvX2ludF90cnVuYyB4IGVsc2UgaW50NjRfdG9faW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50IDwtPiBuYXRpdmVpbnQgKilcblxubGV0IG5hdGl2ZWludF90b19pbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJuYXRpdmVpbnRcIiBcImludFwiIG5hdGl2ZWludF90b19zdHJpbmdcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50IDw9IG51bV9iaXRzX25hdGl2ZWludClcbmxldCBpbnRfdG9fbmF0aXZlaW50ID0gU3RkbGliLk5hdGl2ZWludC5vZl9pbnRcbmxldCBuYXRpdmVpbnRfdG9faW50X3RydW5jID0gU3RkbGliLk5hdGl2ZWludC50b19pbnRcblxubGV0IG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCA9XG4gIGlmIG51bV9iaXRzX25hdGl2ZWludCA8PSBudW1fYml0c19pbnRcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnRfdG9fbmF0aXZlaW50IEludC5taW5fdmFsdWUgaW5cbiAgICBsZXQgbWF4ID0gaW50X3RvX25hdGl2ZWludCBJbnQubWF4X3ZhbHVlIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9uYXRpdmVpbnQgbWluIHggPD0gMCAmJiBjb21wYXJlX25hdGl2ZWludCB4IG1heCA8PSAwKVxuOztcblxubGV0IG5hdGl2ZWludF90b19pbnQgeCA9XG4gIGlmIG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAobmF0aXZlaW50X3RvX2ludF90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50X2V4biB4ID1cbiAgaWYgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHhcbiAgdGhlbiBuYXRpdmVpbnRfdG9faW50X3RydW5jIHhcbiAgZWxzZSBuYXRpdmVpbnRfdG9faW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50MzIgPC0+IGludDY0ICopXG5cbmxldCBpbnQ2NF90b19pbnQzMl9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDY0XCIgXCJpbnQzMlwiIGludDY0X3RvX3N0cmluZ1xubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQzMiA8IG51bV9iaXRzX2ludDY0KVxubGV0IGludDMyX3RvX2ludDY0ID0gU3RkbGliLkludDY0Lm9mX2ludDMyXG5sZXQgaW50NjRfdG9faW50MzJfdHJ1bmMgPSBTdGRsaWIuSW50NjQudG9faW50MzJcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgPVxuICBsZXQgbWluID0gaW50MzJfdG9faW50NjQgbWluX2ludDMyIGluXG4gIGxldCBtYXggPSBpbnQzMl90b19pbnQ2NCBtYXhfaW50MzIgaW5cbiAgZnVuIHggLT4gY29tcGFyZV9pbnQ2NCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50NjQgeCBtYXggPD0gMFxuOztcblxubGV0IGludDY0X3RvX2ludDMyIHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHggdGhlbiBTb21lIChpbnQ2NF90b19pbnQzMl90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBpbnQ2NF90b19pbnQzMl9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeFxuICB0aGVuIGludDY0X3RvX2ludDMyX3RydW5jIHhcbiAgZWxzZSBpbnQ2NF90b19pbnQzMl9mYWlsdXJlIHhcbjs7XG5cbigqIGludDMyIDwtPiBuYXRpdmVpbnQgKilcblxubGV0IG5hdGl2ZWludF90b19pbnQzMl9mYWlsdXJlIHggPVxuICBjb252ZXJ0X2ZhaWx1cmUgeCBcIm5hdGl2ZWludFwiIFwiaW50MzJcIiBuYXRpdmVpbnRfdG9fc3RyaW5nXG47O1xuXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludDMyIDw9IG51bV9iaXRzX25hdGl2ZWludClcbmxldCBpbnQzMl90b19uYXRpdmVpbnQgPSBTdGRsaWIuTmF0aXZlaW50Lm9mX2ludDMyXG5sZXQgbmF0aXZlaW50X3RvX2ludDMyX3RydW5jID0gU3RkbGliLk5hdGl2ZWludC50b19pbnQzMlxuXG5sZXQgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgPVxuICBpZiBudW1fYml0c19uYXRpdmVpbnQgPD0gbnVtX2JpdHNfaW50MzJcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnQzMl90b19uYXRpdmVpbnQgbWluX2ludDMyIGluXG4gICAgbGV0IG1heCA9IGludDMyX3RvX25hdGl2ZWludCBtYXhfaW50MzIgaW5cbiAgICBmdW4geCAtPiBjb21wYXJlX25hdGl2ZWludCBtaW4geCA8PSAwICYmIGNvbXBhcmVfbmF0aXZlaW50IHggbWF4IDw9IDApXG47O1xuXG5sZXQgbmF0aXZlaW50X3RvX2ludDMyIHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4XG4gIHRoZW4gU29tZSAobmF0aXZlaW50X3RvX2ludDMyX3RydW5jIHgpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0IG5hdGl2ZWludF90b19pbnQzMl9leG4geCA9XG4gIGlmIG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHhcbiAgdGhlbiBuYXRpdmVpbnRfdG9faW50MzJfdHJ1bmMgeFxuICBlbHNlIG5hdGl2ZWludF90b19pbnQzMl9mYWlsdXJlIHhcbjs7XG5cbigqIGludDY0IDwtPiBuYXRpdmVpbnQgKilcblxubGV0IGludDY0X3RvX25hdGl2ZWludF9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDY0XCIgXCJuYXRpdmVpbnRcIiBpbnQ2NF90b19zdHJpbmdcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50NjQgPj0gbnVtX2JpdHNfbmF0aXZlaW50KVxubGV0IGludDY0X3RvX25hdGl2ZWludF90cnVuYyA9IFN0ZGxpYi5JbnQ2NC50b19uYXRpdmVpbnRcbmxldCBuYXRpdmVpbnRfdG9faW50NjQgPSBTdGRsaWIuSW50NjQub2ZfbmF0aXZlaW50XG5cbmxldCBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX25hdGl2ZWludCA9XG4gIGlmIG51bV9iaXRzX2ludDY0IDw9IG51bV9iaXRzX25hdGl2ZWludFxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IG5hdGl2ZWludF90b19pbnQ2NCBtaW5fbmF0aXZlaW50IGluXG4gICAgbGV0IG1heCA9IG5hdGl2ZWludF90b19pbnQ2NCBtYXhfbmF0aXZlaW50IGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9pbnQ2NCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50NjQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBpbnQ2NF90b19uYXRpdmVpbnQgeCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aXZlaW50IHhcbiAgdGhlbiBTb21lIChpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgeClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50NjRfdG9fbmF0aXZlaW50X2V4biB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19uYXRpdmVpbnQgeFxuICB0aGVuIGludDY0X3RvX25hdGl2ZWludF90cnVuYyB4XG4gIGVsc2UgaW50NjRfdG9fbmF0aXZlaW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50NjQgPC0+IGludDYzICopXG5cbmxldCBpbnQ2NF90b19pbnQ2M19mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDY0XCIgXCJpbnQ2M1wiIGludDY0X3RvX3N0cmluZ1xuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQ2MyA9XG4gIGxldCBtaW4gPSBTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHQgbWluX2ludDY0IDEgaW5cbiAgbGV0IG1heCA9IFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodCBtYXhfaW50NjQgMSBpblxuICBmdW4geCAtPiBjb21wYXJlX2ludDY0IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQ2NCB4IG1heCA8PSAwXG47O1xuXG5sZXQgaW50NjRfZml0X29uX2ludDYzX2V4biB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQ2MyB4IHRoZW4gKCkgZWxzZSBpbnQ2NF90b19pbnQ2M19mYWlsdXJlIHhcbjs7XG4iLCIoKiBbU3RyaW5nMF0gZGVmaW5lcyBzdHJpbmcgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluXG4gICB0ZXJtcyBvZiBbU3RkbGliLlN0cmluZ10uIFtTdHJpbmcwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2ZcbiAgIFtTdGRsaWIuU3RyaW5nXSB0aGF0IFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIHN0cmluZzAubWwgc2hvdWxkXG4gICB1c2UgW1N0ZGxpYi5TdHJpbmddLiAgW1N0cmluZzBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2Unc1xuICAgYnVpbGQgb3JkZXIuXG5cbiAgIEFsbCBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2Ugc3RyaW5ncywgaW5jbHVkaW5nIHRoZSBzdWJzY3JpcHQgc3ludGF4IFt4LltpXV0gd2hpY2hcbiAgIHRoZSBPQ2FtbCBwYXJzZXIgZGVzdWdhcnMgaW50byBjYWxscyB0byBbU3RyaW5nXSwgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLlN0cmluZ10gaW5cbiAgIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuXG4gICB7W1xuICAgICBtb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuICAgXX1cblxuICAgRGVmaW5pbmcgW21vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzXG4gICBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLlN0cmluZ10uICopXG5cbm9wZW4hIEltcG9ydDBcblxub3BlbiBzdHJ1Y3RcbiAgbW9kdWxlIFN5cyA9IFN5czBcbiAgbW9kdWxlIFVjaGFyID0gVWNoYXIwXG5lbmRcblxubW9kdWxlIFN0cmluZyA9IHN0cnVjdFxuICBleHRlcm5hbCBnZXQgOiAoc3RyaW5nW0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogKHN0cmluZ1tAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX2dldFxuICAgIDogIChzdHJpbmdbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiBjaGFyXG4gICAgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG5lbmRcblxuaW5jbHVkZSBTdHJpbmdcblxubGV0IG1heF9sZW5ndGggPSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbmxldCAoIF4gKSA9ICggXiApXG5sZXQgY2FwaXRhbGl6ZSA9IFN0ZGxpYi5TdHJpbmcuY2FwaXRhbGl6ZV9hc2NpaVxubGV0IGNvbXBhcmUgPSBTdGRsaWIuU3RyaW5nLmNvbXBhcmVcbmxldCBlc2NhcGVkID0gU3RkbGliLlN0cmluZy5lc2NhcGVkXG5sZXQgbG93ZXJjYXNlID0gU3RkbGliLlN0cmluZy5sb3dlcmNhc2VfYXNjaWlcbmxldCBtYWtlID0gU3RkbGliLlN0cmluZy5tYWtlXG5sZXQgc3ViID0gU3RkbGliLlN0cmluZy5zdWJcbmxldCB1bmNhcGl0YWxpemUgPSBTdGRsaWIuU3RyaW5nLnVuY2FwaXRhbGl6ZV9hc2NpaVxubGV0IHVwcGVyY2FzZSA9IFN0ZGxpYi5TdHJpbmcudXBwZXJjYXNlX2FzY2lpXG5sZXQgaXNfdmFsaWRfdXRmXzggPSBTdGRsaWIuU3RyaW5nLmlzX3ZhbGlkX3V0Zl84XG5sZXQgaXNfdmFsaWRfdXRmXzE2bGUgPSBTdGRsaWIuU3RyaW5nLmlzX3ZhbGlkX3V0Zl8xNmxlXG5sZXQgaXNfdmFsaWRfdXRmXzE2YmUgPSBTdGRsaWIuU3RyaW5nLmlzX3ZhbGlkX3V0Zl8xNmJlXG5sZXQgZ2V0X3V0Zl84X3VjaGFyIHQgfmJ5dGVfcG9zID0gU3RkbGliLlN0cmluZy5nZXRfdXRmXzhfdWNoYXIgdCBieXRlX3Bvc1xubGV0IGdldF91dGZfMTZsZV91Y2hhciB0IH5ieXRlX3BvcyA9IFN0ZGxpYi5TdHJpbmcuZ2V0X3V0Zl8xNmxlX3VjaGFyIHQgYnl0ZV9wb3NcbmxldCBnZXRfdXRmXzE2YmVfdWNoYXIgdCB+Ynl0ZV9wb3MgPSBTdGRsaWIuU3RyaW5nLmdldF91dGZfMTZiZV91Y2hhciB0IGJ5dGVfcG9zXG5cbm9wZW4gc3RydWN0XG4gIGxldCBnZXRfdXRmXzMyX3VjaGFyIH5nZXRfaW50MzIgdCB+Ynl0ZV9wb3MgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHQgaW5cbiAgICBtYXRjaCBieXRlX3BvcyA+PSAwICYmIGJ5dGVfcG9zIDwgbGVuIHdpdGhcbiAgICB8IGZhbHNlIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKVxuICAgIHwgdHJ1ZSAtPlxuICAgICAgKG1hdGNoIGxlbiAtIGJ5dGVfcG9zIHdpdGhcbiAgICAgICB8ICgxIHwgMiB8IDMpIGFzIGJ5dGVzX3JlYWQgLT5cbiAgICAgICAgICgqIEZld2VyIHRoYW4gNCBieXRlcyByZW1haW4gaW4gW3RdLCBzbyB3ZSBrbm93IHRoZSBkZWNvZGluZyBpcyBpbnZhbGlkLiAqKVxuICAgICAgICAgVWNoYXIudXRmX2RlY29kZV9pbnZhbGlkIGJ5dGVzX3JlYWRcbiAgICAgICB8IF8gLT5cbiAgICAgICAgIGxldCBpbnQzMiA9IGdldF9pbnQzMiB0IGJ5dGVfcG9zIGluXG4gICAgICAgICAobWF0Y2ggSW50X2NvbnZlcnNpb25zLmludDMyX2lzX3JlcHJlc2VudGFibGVfYXNfaW50IGludDMyIHdpdGhcbiAgICAgICAgICB8IGZhbHNlIC0+IFVjaGFyLnV0Zl9kZWNvZGVfaW52YWxpZCA0XG4gICAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgICBsZXQgaW50ID0gSW50X2NvbnZlcnNpb25zLmludDMyX3RvX2ludF90cnVuYyBpbnQzMiBpblxuICAgICAgICAgICAgKG1hdGNoIFVjaGFyLmlzX3ZhbGlkIGludCB3aXRoXG4gICAgICAgICAgICAgfCB0cnVlIC0+IFVjaGFyLnV0Zl9kZWNvZGUgNCAoVWNoYXIudW5zYWZlX29mX2ludCBpbnQpXG4gICAgICAgICAgICAgfCBmYWxzZSAtPiBVY2hhci51dGZfZGVjb2RlX2ludmFsaWQgNCkpKVxuICA7O1xuZW5kXG5cbmxldCBnZXRfdXRmXzMybGVfdWNoYXIgdCB+Ynl0ZV9wb3MgPVxuICBnZXRfdXRmXzMyX3VjaGFyIHQgfmJ5dGVfcG9zIH5nZXRfaW50MzI6U3RkbGliLlN0cmluZy5nZXRfaW50MzJfbGVcbjs7XG5cbmxldCBnZXRfdXRmXzMyYmVfdWNoYXIgdCB+Ynl0ZV9wb3MgPVxuICBnZXRfdXRmXzMyX3VjaGFyIHQgfmJ5dGVfcG9zIH5nZXRfaW50MzI6U3RkbGliLlN0cmluZy5nZXRfaW50MzJfYmVcbjs7XG5cbmxldCBjb25jYXQgPyhzZXAgPSBcIlwiKSBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gXCJcIlxuICAoKiBUaGUgc3RkbGliIGRvZXMgbm90IHNwZWNpYWxpemUgdGhpcyBjYXNlIGJlY2F1c2UgaXQgY291bGQgYnJlYWsgZXhpc3RpbmcgcHJvamVjdHMuICopXG4gIHwgWyB4IF0gLT4geFxuICB8IGwgLT4gU3RkbGliLlN0cmluZy5jb25jYXQgfnNlcCBsXG47O1xuXG5sZXQgaXRlciB0IH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIGYgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lXG47O1xuXG5sZXQgc3BsaXRfbGluZXMgPVxuICBsZXQgYmFja191cF9hdF9uZXdsaW5lIH50IH5wb3MgfmVvbCA9XG4gICAgcG9zIDo9ICFwb3MgLSBpZiAhcG9zID4gMCAmJiBDaGFyMC5lcXVhbCB0LlshcG9zIC0gMV0gJ1xccicgdGhlbiAyIGVsc2UgMTtcbiAgICBlb2wgOj0gIXBvcyArIDFcbiAgaW5cbiAgZnVuIHQgLT5cbiAgICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gICAgaWYgbiA9IDBcbiAgICB0aGVuIFtdXG4gICAgZWxzZSAoXG4gICAgICAoKiBJbnZhcmlhbnQ6IFstMSA8PSBwb3MgPCBlb2xdLiAqKVxuICAgICAgbGV0IHBvcyA9IHJlZiAobiAtIDEpIGluXG4gICAgICBsZXQgZW9sID0gcmVmIG4gaW5cbiAgICAgIGxldCBhYyA9IHJlZiBbXSBpblxuICAgICAgKCogV2UgdHJlYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nIHNwZWNpYWxseSwgYmVjYXVzZSBpZiB0aGUgc3RyaW5nIGVuZHMgd2l0aCBhXG4gICAgICAgICBuZXdsaW5lLCB3ZSBkb24ndCB3YW50IGFuIGV4dHJhIGVtcHR5IHN0cmluZyBhdCB0aGUgZW5kIG9mIHRoZSBvdXRwdXQuICopXG4gICAgICBpZiBDaGFyMC5lcXVhbCB0LlshcG9zXSAnXFxuJyB0aGVuIGJhY2tfdXBfYXRfbmV3bGluZSB+dCB+cG9zIH5lb2w7XG4gICAgICB3aGlsZSAhcG9zID49IDAgZG9cbiAgICAgICAgaWYgbm90IChDaGFyMC5lcXVhbCB0LlshcG9zXSAnXFxuJylcbiAgICAgICAgdGhlbiBkZWNyIHBvc1xuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBCZWNhdXNlIFtwb3MgPCBlb2xdLCB3ZSBrbm93IHRoYXQgW3N0YXJ0IDw9IGVvbF0uICopXG4gICAgICAgICAgbGV0IHN0YXJ0ID0gIXBvcyArIDEgaW5cbiAgICAgICAgICBhYyA6PSBzdWIgdCB+cG9zOnN0YXJ0IH5sZW46KCFlb2wgLSBzdGFydCkgOjogIWFjO1xuICAgICAgICAgIGJhY2tfdXBfYXRfbmV3bGluZSB+dCB+cG9zIH5lb2wpXG4gICAgICBkb25lO1xuICAgICAgc3ViIHQgfnBvczowIH5sZW46IWVvbCA6OiAhYWMpXG47O1xuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gU3RkbGliLkxleGluZy5wb3NpdGlvbiA9XG4gICAgeyBwb3NfZm5hbWUgOiBzdHJpbmdcbiAgICA7IHBvc19sbnVtIDogaW50XG4gICAgOyBwb3NfYm9sIDogaW50XG4gICAgOyBwb3NfY251bSA6IGludFxuICAgIH1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBoYXNoLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA9XG4gICAgKGZ1biBhX18wMDFfIGJfXzAwMl8gLT5cbiAgICAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwMV8gYl9fMDAyX1xuICAgICAgIHRoZW4gMFxuICAgICAgIGVsc2UgKFxuICAgICAgICAgbWF0Y2ggY29tcGFyZV9zdHJpbmdfX2xvY2FsIGFfXzAwMV8ucG9zX2ZuYW1lIGJfXzAwMl8ucG9zX2ZuYW1lIHdpdGhcbiAgICAgICAgIHwgMCAtPlxuICAgICAgICAgICAobWF0Y2ggY29tcGFyZV9pbnRfX2xvY2FsIGFfXzAwMV8ucG9zX2xudW0gYl9fMDAyXy5wb3NfbG51bSB3aXRoXG4gICAgICAgICAgICB8IDAgLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGNvbXBhcmVfaW50X19sb2NhbCBhX18wMDFfLnBvc19ib2wgYl9fMDAyXy5wb3NfYm9sIHdpdGhcbiAgICAgICAgICAgICAgIHwgMCAtPiBjb21wYXJlX2ludF9fbG9jYWwgYV9fMDAxXy5wb3NfY251bSBiX18wMDJfLnBvc19jbnVtXG4gICAgICAgICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgICAgfCBuIC0+IG4pXG4gICAgICA6IHQgLT4gdCAtPiBpbnQpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBmdW4gaHN2IGFyZyAtPlxuICAgIGxldCBoc3YgPVxuICAgICAgbGV0IGhzdiA9XG4gICAgICAgIGxldCBoc3YgPVxuICAgICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgICBoYXNoX2ZvbGRfc3RyaW5nIGhzdiBhcmcucG9zX2ZuYW1lXG4gICAgICAgIGluXG4gICAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IGFyZy5wb3NfbG51bVxuICAgICAgaW5cbiAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IGFyZy5wb3NfYm9sXG4gICAgaW5cbiAgICBoYXNoX2ZvbGRfaW50IGhzdiBhcmcucG9zX2NudW1cbiAgOztcblxuICBsZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgYXJnID1cbiAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gICAgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuIHsgcG9zX2ZuYW1lID0gcG9zX2ZuYW1lX18wMDRfXG4gICAgICAgICA7IHBvc19sbnVtID0gcG9zX2xudW1fXzAwNl9cbiAgICAgICAgIDsgcG9zX2JvbCA9IHBvc19ib2xfXzAwOF9cbiAgICAgICAgIDsgcG9zX2NudW0gPSBwb3NfY251bV9fMDEwX1xuICAgICAgICAgfSAtPlxuICAgICAgIGxldCBibmRzX18wMDNfID0gKFtdIDogXyBTdGRsaWIuTGlzdC50KSBpblxuICAgICAgIGxldCBibmRzX18wMDNfID1cbiAgICAgICAgIGxldCBhcmdfXzAxMV8gPSBzZXhwX29mX2ludCBwb3NfY251bV9fMDEwXyBpblxuICAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19jbnVtXCI7IGFyZ19fMDExXyBdIDo6IGJuZHNfXzAwM19cbiAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgaW5cbiAgICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgICBsZXQgYXJnX18wMDlfID0gc2V4cF9vZl9pbnQgcG9zX2JvbF9fMDA4XyBpblxuICAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19ib2xcIjsgYXJnX18wMDlfIF0gOjogYm5kc19fMDAzX1xuICAgICAgICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgICAgICBpblxuICAgICAgIGxldCBibmRzX18wMDNfID1cbiAgICAgICAgIGxldCBhcmdfXzAwN18gPSBzZXhwX29mX2ludCBwb3NfbG51bV9fMDA2XyBpblxuICAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19sbnVtXCI7IGFyZ19fMDA3XyBdIDo6IGJuZHNfXzAwM19cbiAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgaW5cbiAgICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgICBsZXQgYXJnX18wMDVfID0gc2V4cF9vZl9zdHJpbmcgcG9zX2ZuYW1lX18wMDRfIGluXG4gICAgICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwicG9zX2ZuYW1lXCI7IGFyZ19fMDA1XyBdIDo6IGJuZHNfXzAwM19cbiAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgaW5cbiAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDAzX1xuICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbigqIFRoaXMgaXMgdGhlIHNhbWUgZnVuY3Rpb24gYXMgUHB4X2hlcmUubGlmdF9wb3NpdGlvbl9hc19zdHJpbmcuICopXG5sZXQgbWFrZV9sb2NhdGlvbl9zdHJpbmcgfnBvc19mbmFtZSB+cG9zX2xudW0gfnBvc19jbnVtIH5wb3NfYm9sID1cbiAgU3RyaW5nLmNvbmNhdFxuICAgIFsgcG9zX2ZuYW1lOyBcIjpcIjsgSW50LnRvX3N0cmluZyBwb3NfbG51bTsgXCI6XCI7IEludC50b19zdHJpbmcgKHBvc19jbnVtIC0gcG9zX2JvbCkgXVxuOztcblxubGV0IHRvX3N0cmluZyB7IFN0ZGxpYi5MZXhpbmcucG9zX2ZuYW1lOyBwb3NfbG51bTsgcG9zX2NudW07IHBvc19ib2wgfSA9XG4gIG1ha2VfbG9jYXRpb25fc3RyaW5nIH5wb3NfZm5hbWUgfnBvc19sbnVtIH5wb3NfY251bSB+cG9zX2JvbFxuOztcblxubGV0IHNleHBfb2ZfdCB0ID0gU2V4cC5BdG9tICh0b19zdHJpbmcgdClcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBMaXN0MFxuXG5sZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICB8IFtdIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgcGFydGl0aW9uX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHQgZnN0IHNuZCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiByZXYgZnN0LCByZXYgc25kXG4gICAgfCB4IDo6IHQgLT5cbiAgICAgIChtYXRjaCAoZiB4IDogXyBFaXRoZXIwLnQpIHdpdGhcbiAgICAgICB8IEZpcnN0IHkgLT4gbG9vcCB0ICh5IDo6IGZzdCkgc25kXG4gICAgICAgfCBTZWNvbmQgeSAtPiBsb29wIHQgZnN0ICh5IDo6IHNuZCkpXG4gIGluXG4gIGxvb3AgdCBbXSBbXSBbQG5vbnRhaWxdXG47O1xuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgRWl0aGVyID0gRWl0aGVyMFxuXG50eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBTdGRsaWIucmVzdWx0ID1cbiAgfCBPayBvZiAnYVxuICB8IEVycm9yIG9mICdiXG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBoYXNoXVxuXG5sZXQgdF9vZl9zZXhwIDpcbiAgICAgICdhICdiLlxuICAgICAgKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gKFNleHBsaWIwLlNleHAudCAtPiAnYikgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICgnYSwgJ2IpIHRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDE3XyBiX18wMThfKVxuICAgIDogICgoU2V4cGxpYjAuU2V4cC50IC0+IGFfXzAxN18pIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gYl9fMDE4XykgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgLT4gKGFfXzAxN18sIGJfXzAxOF8pIHQpIC0+XG4gIGxldCBlcnJvcl9zb3VyY2VfXzAwNV8gPSBcInJlc3VsdC5tbC50XCIgaW5cbiAgZnVuIF9vZl9hX18wMDFfIF9vZl9iX18wMDJfIC0+IGZ1bmN0aW9uXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwib2tcIiB8IFwiT2tcIikgYXMgX3RhZ19fMDA4XykgOjogc2V4cF9hcmdzX18wMDlfKSBhc1xuICAgICAgX3NleHBfXzAwN18gLT5cbiAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAwOV8gd2l0aFxuICAgICAgIHwgWyBhcmcwX18wMTBfIF0gLT5cbiAgICAgICAgIGxldCByZXMwX18wMTFfID0gX29mX2FfXzAwMV8gYXJnMF9fMDEwXyBpblxuICAgICAgICAgT2sgcmVzMF9fMDExX1xuICAgICAgIHwgXyAtPlxuICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAwNV9cbiAgICAgICAgICAgX3RhZ19fMDA4X1xuICAgICAgICAgICBfc2V4cF9fMDA3XylcbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJlcnJvclwiIHwgXCJFcnJvclwiKSBhcyBfdGFnX18wMTNfKSA6OiBzZXhwX2FyZ3NfXzAxNF8pIGFzXG4gICAgICBfc2V4cF9fMDEyXyAtPlxuICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDE0XyB3aXRoXG4gICAgICAgfCBbIGFyZzBfXzAxNV8gXSAtPlxuICAgICAgICAgbGV0IHJlczBfXzAxNl8gPSBfb2ZfYl9fMDAyXyBhcmcwX18wMTVfIGluXG4gICAgICAgICBFcnJvciByZXMwX18wMTZfXG4gICAgICAgfCBfIC0+XG4gICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA1X1xuICAgICAgICAgICBfdGFnX18wMTNfXG4gICAgICAgICAgIF9zZXhwX18wMTJfKVxuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm9rXCIgfCBcIk9rXCIpIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcnJvclwiIHwgXCJFcnJvclwiKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICAgfCBzZXhwX18wMDRfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbjs7XG5cbmxldCBzZXhwX29mX3QgOlxuICAgICAgJ2EgJ2IuXG4gICAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2EsICdiKSB0IC0+IFNleHBsaWIwLlNleHAudFxuICA9XG4gIGZ1biAodHlwZSBhX18wMjVfIGJfXzAyNl8pXG4gICAgOiAgKChhX18wMjVfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKGJfXzAyNl8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+IChhX18wMjVfLCBiX18wMjZfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgZnVuIF9vZl9hX18wMTlfIF9vZl9iX18wMjBfIC0+IGZ1bmN0aW9uXG4gIHwgT2sgYXJnMF9fMDIxXyAtPlxuICAgIGxldCByZXMwX18wMjJfID0gX29mX2FfXzAxOV8gYXJnMF9fMDIxXyBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIk9rXCI7IHJlczBfXzAyMl8gXVxuICB8IEVycm9yIGFyZzBfXzAyM18gLT5cbiAgICBsZXQgcmVzMF9fMDI0XyA9IF9vZl9iX18wMjBfIGFyZzBfXzAyM18gaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJFcnJvclwiOyByZXMwX18wMjRfIF1cbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hciA6XG4gICAgICAnYSAnYi5cbiAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAtPiAnYiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIF8nYl9zZXhwX2dyYW1tYXIgLT5cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIk9rXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJFcnJvclwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxubGV0IGNvbXBhcmVfX2xvY2FsIDpcbiAgICAgICdhICdiLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAoJ2IgLT4gJ2IgLT4gaW50KSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gaW50XG4gID1cbiAgZnVuIF9jbXBfX2EgX2NtcF9fYiBhX18wMzNfIGJfXzAzNF8gLT5cbiAgaWYgU3RkbGliLiggPT0gKSBhX18wMzNfIGJfXzAzNF9cbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIG1hdGNoIGFfXzAzM18sIGJfXzAzNF8gd2l0aFxuICAgIHwgT2sgX2FfXzAzNV8sIE9rIF9iX18wMzZfIC0+IF9jbXBfX2EgX2FfXzAzNV8gX2JfXzAzNl9cbiAgICB8IE9rIF8sIF8gLT4gLTFcbiAgICB8IF8sIE9rIF8gLT4gMVxuICAgIHwgRXJyb3IgX2FfXzAzN18sIEVycm9yIF9iX18wMzhfIC0+IF9jbXBfX2IgX2FfXzAzN18gX2JfXzAzOF8pXG47O1xuXG5sZXQgY29tcGFyZSA6XG4gICAgICAnYSAnYi4gKCdhIC0+ICdhIC0+IGludCkgLT4gKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICA9XG4gIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDI3XyBiX18wMjhfIC0+XG4gIGlmIFN0ZGxpYi4oID09ICkgYV9fMDI3XyBiX18wMjhfXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBtYXRjaCBhX18wMjdfLCBiX18wMjhfIHdpdGhcbiAgICB8IE9rIF9hX18wMjlfLCBPayBfYl9fMDMwXyAtPiBfY21wX19hIF9hX18wMjlfIF9iX18wMzBfXG4gICAgfCBPayBfLCBfIC0+IC0xXG4gICAgfCBfLCBPayBfIC0+IDFcbiAgICB8IEVycm9yIF9hX18wMzFfLCBFcnJvciBfYl9fMDMyXyAtPiBfY21wX19iIF9hX18wMzFfIF9iX18wMzJfKVxuOztcblxubGV0IGVxdWFsX19sb2NhbCA6XG4gICAgICAnYSAnYi4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYiAtPiAnYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gYm9vbFxuICA9XG4gIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDQ1XyBiX18wNDZfIC0+XG4gIGlmIFN0ZGxpYi4oID09ICkgYV9fMDQ1XyBiX18wNDZfXG4gIHRoZW4gdHJ1ZVxuICBlbHNlIChcbiAgICBtYXRjaCBhX18wNDVfLCBiX18wNDZfIHdpdGhcbiAgICB8IE9rIF9hX18wNDdfLCBPayBfYl9fMDQ4XyAtPiBfY21wX19hIF9hX18wNDdfIF9iX18wNDhfXG4gICAgfCBPayBfLCBfIC0+IGZhbHNlXG4gICAgfCBfLCBPayBfIC0+IGZhbHNlXG4gICAgfCBFcnJvciBfYV9fMDQ5XywgRXJyb3IgX2JfXzA1MF8gLT4gX2NtcF9fYiBfYV9fMDQ5XyBfYl9fMDUwXylcbjs7XG5cbmxldCBlcXVhbCA6XG4gICAgICAnYSAnYi4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYiAtPiAnYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gYm9vbFxuICA9XG4gIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDM5XyBiX18wNDBfIC0+XG4gIGlmIFN0ZGxpYi4oID09ICkgYV9fMDM5XyBiX18wNDBfXG4gIHRoZW4gdHJ1ZVxuICBlbHNlIChcbiAgICBtYXRjaCBhX18wMzlfLCBiX18wNDBfIHdpdGhcbiAgICB8IE9rIF9hX18wNDFfLCBPayBfYl9fMDQyXyAtPiBfY21wX19hIF9hX18wNDFfIF9iX18wNDJfXG4gICAgfCBPayBfLCBfIC0+IGZhbHNlXG4gICAgfCBfLCBPayBfIC0+IGZhbHNlXG4gICAgfCBFcnJvciBfYV9fMDQzXywgRXJyb3IgX2JfXzA0NF8gLT4gX2NtcF9fYiBfYV9fMDQzXyBfYl9fMDQ0Xylcbjs7XG5cbmxldCBoYXNoX2ZvbGRfdFxuICA6IHR5cGUgYSBiLlxuICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBiIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAtPiAoYSwgYikgdFxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICA9XG4gIGZ1biBfaGFzaF9mb2xkX2EgX2hhc2hfZm9sZF9iIGhzdiBhcmcgLT5cbiAgbWF0Y2ggYXJnIHdpdGhcbiAgfCBPayBfYTAgLT5cbiAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwIGluXG4gICAgbGV0IGhzdiA9IGhzdiBpblxuICAgIF9oYXNoX2ZvbGRfYSBoc3YgX2EwXG4gIHwgRXJyb3IgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX2IgaHN2IF9hMFxuOztcblxuW0BAQGVuZF1cblxubGV0IGdsb2JhbGl6ZSA9IGdsb2JhbGl6ZV9yZXN1bHRcblxuaW5jbHVkZSBNb25hZC5NYWtlMl9sb2NhbCAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgbGV0IGJpbmQgeCB+ZiA9XG4gICAgbWF0Y2ggeCB3aXRoXG4gICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgIHwgT2sgeCAtPiBmIHhcbiAgOztcblxuICBsZXQgbWFwIHggfmYgPVxuICAgIG1hdGNoIHggd2l0aFxuICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICB8IE9rIHggLT4gT2sgKGYgeClcbiAgOztcblxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgbGV0IHJldHVybiB4ID0gT2sgeFxuZW5kKVxuXG5sZXQgaW52YXJpYW50IGNoZWNrX29rIGNoZWNrX2Vycm9yIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBvayAtPiBjaGVja19vayBva1xuICB8IEVycm9yIGVycm9yIC0+IGNoZWNrX2Vycm9yIGVycm9yXG47O1xuXG5sZXQgZmFpbCB4ID0gRXJyb3IgeFxubGV0IGZhaWxmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBmYWlsIGZvcm1hdFxuXG5sZXQgbWFwX2Vycm9yIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBfIGFzIHggLT4geFxuICB8IEVycm9yIHggLT4gRXJyb3IgKGYgeClcbjs7XG5cbm1vZHVsZSBFcnJvciA9IE1vbmFkLk1ha2UyX2xvY2FsIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYiwgJ2EpIHRcblxuICBsZXQgYmluZCB4IH5mID1cbiAgICBtYXRjaCB4IHdpdGhcbiAgICB8IE9rIF8gYXMgb2sgLT4gb2tcbiAgICB8IEVycm9yIGUgLT4gZiBlXG4gIDs7XG5cbiAgbGV0IG1hcCA9IGBDdXN0b20gbWFwX2Vycm9yXG4gIGxldCByZXR1cm4gZSA9IEVycm9yIGVcbmVuZClcblxubGV0IGlzX29rID0gZnVuY3Rpb25cbiAgfCBPayBfIC0+IHRydWVcbiAgfCBFcnJvciBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfZXJyb3IgPSBmdW5jdGlvblxuICB8IE9rIF8gLT4gZmFsc2VcbiAgfCBFcnJvciBfIC0+IHRydWVcbjs7XG5cbmxldCBvayA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiBTb21lIHhcbiAgfCBFcnJvciBfIC0+IE5vbmVcbjs7XG5cbmxldCBlcnJvciA9IGZ1bmN0aW9uXG4gIHwgT2sgXyAtPiBOb25lXG4gIHwgRXJyb3IgeCAtPiBTb21lIHhcbjs7XG5cbmxldCBvZl9vcHRpb24gb3B0IH5lcnJvciA9XG4gIG1hdGNoIG9wdCB3aXRoXG4gIHwgU29tZSB4IC0+IE9rIHhcbiAgfCBOb25lIC0+IEVycm9yIGVycm9yXG47O1xuXG5sZXQgaXRlciB2IH5mID1cbiAgbWF0Y2ggdiB3aXRoXG4gIHwgT2sgeCAtPiBmIHhcbiAgfCBFcnJvciBfIC0+ICgpXG47O1xuXG5sZXQgaXRlcl9lcnJvciB2IH5mID1cbiAgbWF0Y2ggdiB3aXRoXG4gIHwgT2sgXyAtPiAoKVxuICB8IEVycm9yIHggLT4gZiB4XG47O1xuXG5sZXQgdG9fZWl0aGVyIDogXyB0IC0+IF8gRWl0aGVyLnQgPSBmdW5jdGlvblxuICB8IE9rIHggLT4gRmlyc3QgeFxuICB8IEVycm9yIHggLT4gU2Vjb25kIHhcbjs7XG5cbmxldCBvZl9laXRoZXIgOiBfIEVpdGhlci50IC0+IF8gdCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgeCAtPiBPayB4XG4gIHwgU2Vjb25kIHggLT4gRXJyb3IgeFxuOztcblxubGV0IG9rX2lmX3RydWUgYm9vbCB+ZXJyb3IgPSBpZiBib29sIHRoZW4gT2sgKCkgZWxzZSBFcnJvciBlcnJvclxuXG5sZXQgdHJ5X3dpdGggZiA9XG4gIHRyeSBPayAoZiAoKSkgd2l0aFxuICB8IGV4biAtPiBFcnJvciBleG5cbjs7XG5cbmxldCBva19leG4gPSBmdW5jdGlvblxuICB8IE9rIHggLT4geFxuICB8IEVycm9yIGV4biAtPiByYWlzZSBleG5cbjs7XG5cbmxldCBva19vcl9mYWlsd2l0aCA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiB4XG4gIHwgRXJyb3Igc3RyIC0+IGZhaWx3aXRoIHN0clxuOztcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICB0eXBlICgnb2ssICdlcnIpIF9yZXN1bHQgPSAoJ29rLCAnZXJyKSB0ID1cbiAgICB8IE9rIG9mICdva1xuICAgIHwgRXJyb3Igb2YgJ2VyclxuXG4gIGxldCBpc19lcnJvciA9IGlzX2Vycm9yXG4gIGxldCBpc19vayA9IGlzX29rXG5lbmRcblxubGV0IGNvbWJpbmUgdDEgdDIgfm9rIH5lcnIgPVxuICBtYXRjaCB0MSwgdDIgd2l0aFxuICB8IE9rIF8sIEVycm9yIGUgfCBFcnJvciBlLCBPayBfIC0+IEVycm9yIGVcbiAgfCBPayBvazEsIE9rIG9rMiAtPiBPayAob2sgb2sxIG9rMilcbiAgfCBFcnJvciBlcnIxLCBFcnJvciBlcnIyIC0+IEVycm9yIChlcnIgZXJyMSBlcnIyKVxuOztcblxubGV0IGNvbWJpbmVfZXJyb3JzIGwgPVxuICBsZXQgb2ssIGVycnMgPSBMaXN0MS5wYXJ0aXRpb25fbWFwIGwgfmY6dG9fZWl0aGVyIGluXG4gIG1hdGNoIGVycnMgd2l0aFxuICB8IFtdIC0+IE9rIG9rXG4gIHwgXyA6OiBfIC0+IEVycm9yIGVycnNcbjs7XG5cbmxldCBjb21iaW5lX2Vycm9yc191bml0IGwgPSBtYXAgKGNvbWJpbmVfZXJyb3JzIGwpIH5mOihmdW4gKF8gOiB1bml0IGxpc3QpIC0+ICgpKVxuIiwiKCoqIFByb3ZpZGVzIGdlbmVyaWMgc2lnbmF0dXJlcyBmb3IgY29udGFpbmVyIGRhdGEgc3RydWN0dXJlcy5cblxuICAgIFRoZXNlIHNpZ25hdHVyZXMgaW5jbHVkZSBmdW5jdGlvbnMgKFtpdGVyXSwgW2ZvbGRdLCBbZXhpc3RzXSwgW2Zvcl9hbGxdLCAuLi4pIHRoYXRcbiAgICB5b3Ugd291bGQgZXhwZWN0IHRvIGZpbmQgaW4gYW55IGNvbnRhaW5lci4gVXNlZCBieSBpbmNsdWRpbmcgW0NvbnRhaW5lci5TMF0gb3JcbiAgICBbQ29udGFpbmVyLlMxXSBpbiB0aGUgc2lnbmF0dXJlIGZvciBldmVyeSBjb250YWluZXItbGlrZSBkYXRhIHN0cnVjdHVyZSAoW0FycmF5XSxcbiAgICBbTGlzdF0sIFtTdHJpbmddLCAuLi4pIHRvIGVuc3VyZSBhIGNvbnNpc3RlbnQgaW50ZXJmYWNlLiAqKVxuXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICAoKiogW0NvbnRpbnVlX29yX3N0b3AudF0gaXMgdXNlZCBieSB0aGUgW2ZdIGFyZ3VtZW50IHRvIFtmb2xkX3VudGlsXSBpbiBvcmRlciB0b1xuICAgICAgaW5kaWNhdGUgd2hldGhlciBmb2xkaW5nIHNob3VsZCBjb250aW51ZSwgb3Igc3RvcCBlYXJseS5cblxuICAgICAgQGNhbm9uaWNhbCBCYXNlLkNvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wXG4gICopXG4gIG1vZHVsZSBDb250aW51ZV9vcl9zdG9wID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICAgIHwgQ29udGludWUgb2YgJ2FcbiAgICAgIHwgU3RvcCBvZiAnYlxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIEV4cG9ydFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkNvbnRhaW5lci5TdW1tYWJsZSAqKVxubW9kdWxlIHR5cGUgU3VtbWFibGUgPSBzaWdcbiAgdHlwZSB0XG5cbiAgKCoqIFRoZSByZXN1bHQgb2Ygc3VtbWluZyBubyB2YWx1ZXMuICopXG4gIHZhbCB6ZXJvIDogdFxuXG4gICgqKiBBbiBvcGVyYXRpb24gdGhhdCBjb21iaW5lcyB0d28gW3RdJ3MgYW5kIGhhbmRsZXMgW3plcm8gKyB4XSBieSBqdXN0IHJldHVybmluZyBbeF0sXG4gICAgICBhcyB3ZWxsIGFzIGluIHRoZSBzeW1tZXRyaWMgY2FzZS4gKilcbiAgdmFsICggKyApIDogdCAtPiB0IC0+IHRcbmVuZFxuXG4oKiogU2lnbmF0dXJlIGZvciBtb25vbW9ycGhpYyBjb250YWluZXIgLSBhIGNvbnRhaW5lciBmb3IgYSBzcGVjaWZpYyBlbGVtZW50IHR5cGUsIGUuZy4sXG4gICAgc3RyaW5nLCB3aGljaCBpcyBhIGNvbnRhaW5lciBvZiBjaGFyYWN0ZXJzIChbdHlwZSBlbHQgPSBjaGFyXSkgYW5kIG5ldmVyIG9mIGFueXRoaW5nXG4gICAgZWxzZS4gKilcbm1vZHVsZSB0eXBlIFMwID0gc2lnXG4gIHR5cGUgdFxuICB0eXBlIGVsdFxuXG4gICgqKiBDaGVja3Mgd2hldGhlciB0aGUgcHJvdmlkZWQgZWxlbWVudCBpcyB0aGVyZSwgdXNpbmcgZXF1YWxpdHkgb24gW2VsdF1zLiAqKVxuICB2YWwgbWVtIDogdCAtPiBlbHQgLT4gYm9vbFxuXG4gIHZhbCBsZW5ndGggOiB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiB0IC0+IGJvb2xcblxuICAoKiogW2l0ZXJdIG11c3QgYWxsb3cgZXhjZXB0aW9ucyByYWlzZWQgaW4gW2ZdIHRvIGVzY2FwZSwgdGVybWluYXRpbmcgdGhlIGl0ZXJhdGlvblxuICAgICAgY2xlYW5seS4gIFRoZSBzYW1lIGhvbGRzIGZvciBhbGwgZnVuY3Rpb25zIGJlbG93IHRha2luZyBhbiBbZl0uICopXG4gIHZhbCBpdGVyIDogdCAtPiBmOihlbHQgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSByZXR1cm5zIFtmICguLi4gZiAoZiAoZiBpbml0IGUxKSBlMikgZTMgLi4uKSBlbl0sIHdoZXJlIFtlMS4uZW5dXG4gICAgICBhcmUgdGhlIGVsZW1lbnRzIG9mIFt0XS4gKilcbiAgdmFsIGZvbGQgOiB0IC0+IGluaXQ6J2FjYyAtPiBmOignYWNjIC0+IGVsdCAtPiAnYWNjKSAtPiAnYWNjXG5cbiAgKCoqIFtmb2xkX3Jlc3VsdCB0IH5pbml0IH5mXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0gdGhhdCBydW5zIGluIHRoZVxuICAgICAgW1Jlc3VsdF0gbW9uYWQuICBJZiBbZl0gcmV0dXJucyBhbiBbRXJyb3IgX10sIHRoYXQgdmFsdWUgaXMgcmV0dXJuZWQgd2l0aG91dCBhbnlcbiAgICAgIGFkZGl0aW9uYWwgaW52b2NhdGlvbnMgb2YgW2ZdLiAqKVxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooJ2FjYyAtPiBlbHQgLT4gKCdhY2MsICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjYywgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaF0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdLiBJZiBbZl1cbiAgICAgIHJldHVybnMgW1N0b3AgX10gdGhlIGNvbXB1dGF0aW9uIGNlYXNlcyBhbmQgcmVzdWx0cyBpbiB0aGF0IHZhbHVlLiBJZiBbZl0gcmV0dXJuc1xuICAgICAgW0NvbnRpbnVlIF9dLCB0aGUgZm9sZCB3aWxsIHByb2NlZWQuIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCB0aGUgZmluYWwgcmVzdWx0XG4gICAgICBpcyBjb21wdXRlZCBieSBbZmluaXNoXS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBtYXliZV9uZWdhdGl2ZSA9XG4gICAgICAgICAgfCBGb3VuZF9uZWdhdGl2ZSBvZiBpbnRcbiAgICAgICAgICB8IEFsbF9ub25uZWdhdGl2ZSBvZiB7IHN1bSA6IGludCB9XG5cbiAgICAgICAgKCoqIFtmaXJzdF9uZWdfb3Jfc3VtIGxpc3RdIHJldHVybnMgdGhlIGZpcnN0IG5lZ2F0aXZlIG51bWJlciBpbiBbbGlzdF0sIGlmIGFueSxcbiAgICAgICAgICAgIG90aGVyd2lzZSByZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGxpc3QuICopXG4gICAgICAgIGxldCBmaXJzdF9uZWdfb3Jfc3VtID1cbiAgICAgICAgICBMaXN0LmZvbGRfdW50aWwgfmluaXQ6MFxuICAgICAgICAgICAgfmY6KGZ1biBzdW0geCAtPlxuICAgICAgICAgICAgICBpZiB4IDwgMFxuICAgICAgICAgICAgICB0aGVuIFN0b3AgKEZvdW5kX25lZ2F0aXZlIHgpXG4gICAgICAgICAgICAgIGVsc2UgQ29udGludWUgKHN1bSArIHgpKVxuICAgICAgICAgICAgfmZpbmlzaDooZnVuIHN1bSAtPiBBbGxfbm9ubmVnYXRpdmUgeyBzdW0gfSlcbiAgICAgICAgOztcblxuICAgICAgICBsZXQgeCA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IDM7IDQ7IDVdXG4gICAgICAgIHZhbCB4IDogbWF5YmVfbmVnYXRpdmUgPSBBbGxfbm9ubmVnYXRpdmUge3N1bSA9IDE1fVxuXG4gICAgICAgIGxldCB5ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgLTM7IDQ7IDVdXG4gICAgICAgIHZhbCB5IDogbWF5YmVfbmVnYXRpdmUgPSBGb3VuZF9uZWdhdGl2ZSAtM1xuICAgICAgXX0gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooJ2FjYyAtPiBlbHQgLT4gKCdhY2MsICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjYyAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZXJlIGV4aXN0cyBhbiBlbGVtZW50IGZvciB3aGljaCB0aGUgcHJvdmlkZWRcbiAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0uIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGV4aXN0cyA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGZvcl9hbGwgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgY291bnQgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBpbnRcblxuICAoKiogUmV0dXJucyB0aGUgc3VtIG9mIFtmIGldIGZvciBhbGwgW2ldIGluIHRoZSBjb250YWluZXIuICopXG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gdCAtPiBmOihlbHQgLT4gJ3N1bSkgLT4gJ3N1bVxuXG4gICgqKiBSZXR1cm5zIGFzIGFuIFtvcHRpb25dIHRoZSBmaXJzdCBlbGVtZW50IGZvciB3aGljaCBbZl0gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBmaW5kIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gZWx0IG9wdGlvblxuXG4gICgqKiBSZXR1cm5zIHRoZSBmaXJzdCBldmFsdWF0aW9uIG9mIFtmXSB0aGF0IHJldHVybnMgW1NvbWVdLCBhbmQgcmV0dXJucyBbTm9uZV0gaWYgdGhlcmVcbiAgICAgIGlzIG5vIHN1Y2ggZWxlbWVudC4gICopXG4gIHZhbCBmaW5kX21hcCA6IHQgLT4gZjooZWx0IC0+ICdhIG9wdGlvbikgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIHRvX2xpc3QgOiB0IC0+IGVsdCBsaXN0XG4gIHZhbCB0b19hcnJheSA6IHQgLT4gZWx0IGFycmF5XG5cbiAgKCoqIFJldHVybnMgYSBtaW4gKHJlc3AuIG1heCkgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBbY29tcGFyZV1cbiAgICAgIGZ1bmN0aW9uLiBJbiBjYXNlIG9mIGEgdGllLCB0aGUgZmlyc3QgZWxlbWVudCBlbmNvdW50ZXJlZCB3aGlsZSB0cmF2ZXJzaW5nIHRoZVxuICAgICAgY29sbGVjdGlvbiBpcyByZXR1cm5lZC4gVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgW2ZvbGRdIHNvIGl0IGhhcyB0aGUgc2FtZVxuICAgICAgY29tcGxleGl0eSBhcyBbZm9sZF0uIFJldHVybnMgW05vbmVdIGlmZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS4gKilcbiAgdmFsIG1pbl9lbHQgOiB0IC0+IGNvbXBhcmU6KGVsdCAtPiBlbHQgLT4gaW50KSAtPiBlbHQgb3B0aW9uXG5cbiAgdmFsIG1heF9lbHQgOiB0IC0+IGNvbXBhcmU6KGVsdCAtPiBlbHQgLT4gaW50KSAtPiBlbHQgb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgUzBfcGhhbnRvbSA9IHNpZ1xuICB0eXBlIGVsdFxuICB0eXBlICdhIHRcblxuICAoKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVsZW1lbnQgaXMgdGhlcmUsIHVzaW5nIGVxdWFsaXR5IG9uIFtlbHRdcy4gKilcbiAgdmFsIG1lbSA6IF8gdCAtPiBlbHQgLT4gYm9vbFxuXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6IF8gdCAtPiBib29sXG4gIHZhbCBpdGVyIDogXyB0IC0+IGY6KGVsdCAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIFtmb2xkIHQgfmluaXQgfmZdIHJldHVybnMgW2YgKC4uLiBmIChmIChmIGluaXQgZTEpIGUyKSBlMyAuLi4pIGVuXSwgd2hlcmUgW2UxLi5lbl1cbiAgICAgIGFyZSB0aGUgZWxlbWVudHMgb2YgW3RdLiAqKVxuICB2YWwgZm9sZCA6IF8gdCAtPiBpbml0OidhY2MgLT4gZjooJ2FjYyAtPiBlbHQgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgXyB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooJ2FjYyAtPiBlbHQgLT4gKCdhY2MsICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjYywgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaF0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdLiBJZiBbZl1cbiAgICAgIHJldHVybnMgW1N0b3AgX10gdGhlIGNvbXB1dGF0aW9uIGNlYXNlcyBhbmQgcmVzdWx0cyBpbiB0aGF0IHZhbHVlLiBJZiBbZl0gcmV0dXJuc1xuICAgICAgW0NvbnRpbnVlIF9dLCB0aGUgZm9sZCB3aWxsIHByb2NlZWQuIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCB0aGUgZmluYWwgcmVzdWx0XG4gICAgICBpcyBjb21wdXRlZCBieSBbZmluaXNoXS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBtYXliZV9uZWdhdGl2ZSA9XG4gICAgICAgICAgfCBGb3VuZF9uZWdhdGl2ZSBvZiBpbnRcbiAgICAgICAgICB8IEFsbF9ub25uZWdhdGl2ZSBvZiB7IHN1bSA6IGludCB9XG5cbiAgICAgICAgKCoqIFtmaXJzdF9uZWdfb3Jfc3VtIGxpc3RdIHJldHVybnMgdGhlIGZpcnN0IG5lZ2F0aXZlIG51bWJlciBpbiBbbGlzdF0sIGlmIGFueSxcbiAgICAgICAgICAgIG90aGVyd2lzZSByZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGxpc3QuICopXG4gICAgICAgIGxldCBmaXJzdF9uZWdfb3Jfc3VtID1cbiAgICAgICAgICBMaXN0LmZvbGRfdW50aWwgfmluaXQ6MFxuICAgICAgICAgICAgfmY6KGZ1biBzdW0geCAtPlxuICAgICAgICAgICAgICBpZiB4IDwgMFxuICAgICAgICAgICAgICB0aGVuIFN0b3AgKEZvdW5kX25lZ2F0aXZlIHgpXG4gICAgICAgICAgICAgIGVsc2UgQ29udGludWUgKHN1bSArIHgpKVxuICAgICAgICAgICAgfmZpbmlzaDooZnVuIHN1bSAtPiBBbGxfbm9ubmVnYXRpdmUgeyBzdW0gfSlcbiAgICAgICAgOztcblxuICAgICAgICBsZXQgeCA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IDM7IDQ7IDVdXG4gICAgICAgIHZhbCB4IDogbWF5YmVfbmVnYXRpdmUgPSBBbGxfbm9ubmVnYXRpdmUge3N1bSA9IDE1fVxuXG4gICAgICAgIGxldCB5ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgLTM7IDQ7IDVdXG4gICAgICAgIHZhbCB5IDogbWF5YmVfbmVnYXRpdmUgPSBGb3VuZF9uZWdhdGl2ZSAtM1xuICAgICAgXX0gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICBfIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOignYWNjIC0+IGVsdCAtPiAoJ2FjYywgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlcmUgZXhpc3RzIGFuIGVsZW1lbnQgZm9yIHdoaWNoIHRoZSBwcm92aWRlZFxuICAgICAgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXS4gIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGV4aXN0cyA6IF8gdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXSBmb3IgYWxsXG4gICAgICBlbGVtZW50cy4gIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGZvcl9hbGwgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGZvciB3aGljaCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBjb3VudCA6IF8gdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFJldHVybnMgdGhlIHN1bSBvZiBbZiBpXSBmb3IgYWxsIFtpXSBpbiB0aGUgY29udGFpbmVyLiBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlXG4gICAgICBlbGVtZW50cyB3aWxsIGJlIHN1bW1lZCBpcyB1bnNwZWNpZmllZC4gKilcbiAgdmFsIHN1bSA6IChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKSAtPiBfIHQgLT4gZjooZWx0IC0+ICdzdW0pIC0+ICdzdW1cblxuICAoKiogUmV0dXJucyBhcyBhbiBbb3B0aW9uXSB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgZmluZCA6IF8gdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gZWx0IG9wdGlvblxuXG4gICgqKiBSZXR1cm5zIHRoZSBmaXJzdCBldmFsdWF0aW9uIG9mIFtmXSB0aGF0IHJldHVybnMgW1NvbWVdLCBhbmQgcmV0dXJucyBbTm9uZV0gaWYgdGhlcmVcbiAgICAgIGlzIG5vIHN1Y2ggZWxlbWVudC4gICopXG4gIHZhbCBmaW5kX21hcCA6IF8gdCAtPiBmOihlbHQgLT4gJ2Egb3B0aW9uKSAtPiAnYSBvcHRpb25cblxuICB2YWwgdG9fbGlzdCA6IF8gdCAtPiBlbHQgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiBfIHQgLT4gZWx0IGFycmF5XG5cbiAgKCoqIFJldHVybnMgYSBtaW4gKHJlc3AgbWF4KSBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb24gdXNpbmcgdGhlIHByb3ZpZGVkIFtjb21wYXJlXVxuICAgICAgZnVuY3Rpb24sIG9yIFtOb25lXSBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS4gIEluIGNhc2Ugb2YgYSB0aWUsIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICBlbmNvdW50ZXJlZCB3aGlsZSB0cmF2ZXJzaW5nIHRoZSBjb2xsZWN0aW9uIGlzIHJldHVybmVkLiAqKVxuICB2YWwgbWluX2VsdCA6IF8gdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0IDogXyB0IC0+IGNvbXBhcmU6KGVsdCAtPiBlbHQgLT4gaW50KSAtPiBlbHQgb3B0aW9uXG5lbmRcblxuKCoqIFNpZ25hdHVyZSBmb3IgcG9seW1vcnBoaWMgY29udGFpbmVyLCBlLmcuLCBbJ2EgbGlzdF0gb3IgWydhIGFycmF5XS4gKilcbm1vZHVsZSB0eXBlIFMxID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gICgqKiBDaGVja3Mgd2hldGhlciB0aGUgcHJvdmlkZWQgZWxlbWVudCBpcyB0aGVyZSwgdXNpbmcgW2VxdWFsXS4gKilcbiAgdmFsIG1lbSA6ICdhIHQgLT4gJ2EgLT4gZXF1YWw6KCdhIC0+ICdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogJ2EgdCAtPiBib29sXG4gIHZhbCBpdGVyIDogJ2EgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIFtmb2xkIHQgfmluaXQgfmZdIHJldHVybnMgW2YgKC4uLiBmIChmIChmIGluaXQgZTEpIGUyKSBlMyAuLi4pIGVuXSwgd2hlcmUgW2UxLi5lbl1cbiAgICAgIGFyZSB0aGUgZWxlbWVudHMgb2YgW3RdICAqKVxuICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYWNjIC0+IGY6KCdhY2MgLT4gJ2EgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCdhY2MgLT4gJ2EgLT4gKCdhY2MsICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjYywgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaF0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdLiBJZiBbZl1cbiAgICAgIHJldHVybnMgW1N0b3AgX10gdGhlIGNvbXB1dGF0aW9uIGNlYXNlcyBhbmQgcmVzdWx0cyBpbiB0aGF0IHZhbHVlLiBJZiBbZl0gcmV0dXJuc1xuICAgICAgW0NvbnRpbnVlIF9dLCB0aGUgZm9sZCB3aWxsIHByb2NlZWQuIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCB0aGUgZmluYWwgcmVzdWx0XG4gICAgICBpcyBjb21wdXRlZCBieSBbZmluaXNoXS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBtYXliZV9uZWdhdGl2ZSA9XG4gICAgICAgICAgfCBGb3VuZF9uZWdhdGl2ZSBvZiBpbnRcbiAgICAgICAgICB8IEFsbF9ub25uZWdhdGl2ZSBvZiB7IHN1bSA6IGludCB9XG5cbiAgICAgICAgKCoqIFtmaXJzdF9uZWdfb3Jfc3VtIGxpc3RdIHJldHVybnMgdGhlIGZpcnN0IG5lZ2F0aXZlIG51bWJlciBpbiBbbGlzdF0sIGlmIGFueSxcbiAgICAgICAgICAgIG90aGVyd2lzZSByZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGxpc3QuICopXG4gICAgICAgIGxldCBmaXJzdF9uZWdfb3Jfc3VtID1cbiAgICAgICAgICBMaXN0LmZvbGRfdW50aWwgfmluaXQ6MFxuICAgICAgICAgICAgfmY6KGZ1biBzdW0geCAtPlxuICAgICAgICAgICAgICBpZiB4IDwgMFxuICAgICAgICAgICAgICB0aGVuIFN0b3AgKEZvdW5kX25lZ2F0aXZlIHgpXG4gICAgICAgICAgICAgIGVsc2UgQ29udGludWUgKHN1bSArIHgpKVxuICAgICAgICAgICAgfmZpbmlzaDooZnVuIHN1bSAtPiBBbGxfbm9ubmVnYXRpdmUgeyBzdW0gfSlcbiAgICAgICAgOztcblxuICAgICAgICBsZXQgeCA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IDM7IDQ7IDVdXG4gICAgICAgIHZhbCB4IDogbWF5YmVfbmVnYXRpdmUgPSBBbGxfbm9ubmVnYXRpdmUge3N1bSA9IDE1fVxuXG4gICAgICAgIGxldCB5ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgLTM7IDQ7IDVdXG4gICAgICAgIHZhbCB5IDogbWF5YmVfbmVnYXRpdmUgPSBGb3VuZF9uZWdhdGl2ZSAtM1xuICAgICAgXX0gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAnYSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooJ2FjYyAtPiAnYSAtPiAoJ2FjYywgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlcmUgZXhpc3RzIGFuIGVsZW1lbnQgZm9yIHdoaWNoIHRoZSBwcm92aWRlZFxuICAgICAgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXS4gIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGV4aXN0cyA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXSBmb3IgYWxsXG4gICAgICBlbGVtZW50cy4gIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGZvcl9hbGwgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGZvciB3aGljaCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBjb3VudCA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFJldHVybnMgdGhlIHN1bSBvZiBbZiBpXSBmb3IgYWxsIFtpXSBpbiB0aGUgY29udGFpbmVyLiAqKVxuXG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gJ2EgdCAtPiBmOignYSAtPiAnc3VtKSAtPiAnc3VtXG5cbiAgKCoqIFJldHVybnMgYXMgYW4gW29wdGlvbl0gdGhlIGZpcnN0IGVsZW1lbnQgZm9yIHdoaWNoIFtmXSBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGZpbmQgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvblxuXG4gICgqKiBSZXR1cm5zIHRoZSBmaXJzdCBldmFsdWF0aW9uIG9mIFtmXSB0aGF0IHJldHVybnMgW1NvbWVdLCBhbmQgcmV0dXJucyBbTm9uZV0gaWYgdGhlcmVcbiAgICAgIGlzIG5vIHN1Y2ggZWxlbWVudC4gICopXG4gIHZhbCBmaW5kX21hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cblxuICB2YWwgdG9fbGlzdCA6ICdhIHQgLT4gJ2EgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiAnYSB0IC0+ICdhIGFycmF5XG5cbiAgKCoqIFJldHVybnMgYSBtaW5pbXVtIChyZXNwIG1heGltdW0pIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWRcbiAgICAgIFtjb21wYXJlXSBmdW5jdGlvbiwgb3IgW05vbmVdIGlmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5LiBJbiBjYXNlIG9mIGEgdGllLCB0aGUgZmlyc3RcbiAgICAgIGVsZW1lbnQgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGUgY29sbGVjdGlvbiBpcyByZXR1cm5lZC4gVGhlIGltcGxlbWVudGF0aW9uXG4gICAgICB1c2VzIFtmb2xkXSBzbyBpdCBoYXMgdGhlIHNhbWUgY29tcGxleGl0eSBhcyBbZm9sZF0uICopXG4gIHZhbCBtaW5fZWx0IDogJ2EgdCAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0IDogJ2EgdCAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxX3BoYW50b20gPSBzaWdcbiAgdHlwZSAoJ2EsICdwaGFudG9tKSB0XG5cbiAgKCoqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbGVtZW50IGlzIHRoZXJlLCB1c2luZyBbZXF1YWxdLiAqKVxuICB2YWwgbWVtIDogKCdhLCBfKSB0IC0+ICdhIC0+IGVxdWFsOignYSAtPiAnYSAtPiBib29sKSAtPiBib29sXG5cbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBpdGVyIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gcmV0dXJucyBbZiAoLi4uIGYgKGYgKGYgaW5pdCBlMSkgZTIpIGUzIC4uLikgZW5dLCB3aGVyZSBbZTEuLmVuXVxuICAgICAgYXJlIHRoZSBlbGVtZW50cyBvZiBbdF0uICopXG4gIHZhbCBmb2xkIDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjYyAtPiBmOignYWNjIC0+ICdhIC0+ICdhY2MpIC0+ICdhY2NcblxuICAoKiogW2ZvbGRfcmVzdWx0IHQgfmluaXQgfmZdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXSB0aGF0IHJ1bnMgaW4gdGhlXG4gICAgICBbUmVzdWx0XSBtb25hZC4gIElmIFtmXSByZXR1cm5zIGFuIFtFcnJvciBfXSwgdGhhdCB2YWx1ZSBpcyByZXR1cm5lZCB3aXRob3V0IGFueVxuICAgICAgYWRkaXRpb25hbCBpbnZvY2F0aW9ucyBvZiBbZl0uICopXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCdhY2MgLT4gJ2EgLT4gKCdhY2MsICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjYywgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaF0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdLiBJZiBbZl1cbiAgICAgIHJldHVybnMgW1N0b3AgX10gdGhlIGNvbXB1dGF0aW9uIGNlYXNlcyBhbmQgcmVzdWx0cyBpbiB0aGF0IHZhbHVlLiBJZiBbZl0gcmV0dXJuc1xuICAgICAgW0NvbnRpbnVlIF9dLCB0aGUgZm9sZCB3aWxsIHByb2NlZWQuIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCB0aGUgZmluYWwgcmVzdWx0XG4gICAgICBpcyBjb21wdXRlZCBieSBbZmluaXNoXS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBtYXliZV9uZWdhdGl2ZSA9XG4gICAgICAgICAgfCBGb3VuZF9uZWdhdGl2ZSBvZiBpbnRcbiAgICAgICAgICB8IEFsbF9ub25uZWdhdGl2ZSBvZiB7IHN1bSA6IGludCB9XG5cbiAgICAgICAgKCoqIFtmaXJzdF9uZWdfb3Jfc3VtIGxpc3RdIHJldHVybnMgdGhlIGZpcnN0IG5lZ2F0aXZlIG51bWJlciBpbiBbbGlzdF0sIGlmIGFueSxcbiAgICAgICAgICAgIG90aGVyd2lzZSByZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGxpc3QuICopXG4gICAgICAgIGxldCBmaXJzdF9uZWdfb3Jfc3VtID1cbiAgICAgICAgICBMaXN0LmZvbGRfdW50aWwgfmluaXQ6MFxuICAgICAgICAgICAgfmY6KGZ1biBzdW0geCAtPlxuICAgICAgICAgICAgICBpZiB4IDwgMFxuICAgICAgICAgICAgICB0aGVuIFN0b3AgKEZvdW5kX25lZ2F0aXZlIHgpXG4gICAgICAgICAgICAgIGVsc2UgQ29udGludWUgKHN1bSArIHgpKVxuICAgICAgICAgICAgfmZpbmlzaDooZnVuIHN1bSAtPiBBbGxfbm9ubmVnYXRpdmUgeyBzdW0gfSlcbiAgICAgICAgOztcblxuICAgICAgICBsZXQgeCA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IDM7IDQ7IDVdXG4gICAgICAgIHZhbCB4IDogbWF5YmVfbmVnYXRpdmUgPSBBbGxfbm9ubmVnYXRpdmUge3N1bSA9IDE1fVxuXG4gICAgICAgIGxldCB5ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgLTM7IDQ7IDVdXG4gICAgICAgIHZhbCB5IDogbWF5YmVfbmVnYXRpdmUgPSBGb3VuZF9uZWdhdGl2ZSAtM1xuICAgICAgXX0gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOignYWNjIC0+ICdhIC0+ICgnYWNjLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkXG4gICAgICBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZXhpc3RzIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGZvciB3aGljaCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBjb3VudCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcblxuICAoKiogUmV0dXJucyB0aGUgc3VtIG9mIFtmIGldIGZvciBhbGwgW2ldIGluIHRoZSBjb250YWluZXIuICopXG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gKCdhLCBfKSB0IC0+IGY6KCdhIC0+ICdzdW0pIC0+ICdzdW1cblxuICAoKiogUmV0dXJucyBhcyBhbiBbb3B0aW9uXSB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgZmluZCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cblxuICB2YWwgdG9fbGlzdCA6ICgnYSwgXykgdCAtPiAnYSBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICgnYSwgXykgdCAtPiAnYSBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluIChyZXNwIG1heCkgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBbY29tcGFyZV1cbiAgICAgIGZ1bmN0aW9uLiBJbiBjYXNlIG9mIGEgdGllLCB0aGUgZmlyc3QgZWxlbWVudCBlbmNvdW50ZXJlZCB3aGlsZSB0cmF2ZXJzaW5nIHRoZVxuICAgICAgY29sbGVjdGlvbiBpcyByZXR1cm5lZC4gVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgW2ZvbGRdIHNvIGl0IGhhcyB0aGUgc2FtZSBjb21wbGV4aXR5XG4gICAgICBhcyBbZm9sZF0uIFJldHVybnMgW05vbmVdIGlmZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS4gKilcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb25cblxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIEdlbmVyaWMgPSBzaWdcbiAgdHlwZSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSB0XG4gIHR5cGUgJ2EgZWx0XG5cbiAgdmFsIGxlbmd0aCA6IChfLCBfLCBfKSB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiAoXywgXywgXykgdCAtPiBib29sXG4gIHZhbCBtZW0gOiAoJ2EsIF8sIF8pIHQgLT4gJ2EgZWx0IC0+IGVxdWFsOignYSBlbHQgLT4gJ2EgZWx0IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoJ2EsIF8sIF8pIHQgLT4gZjooJ2EgZWx0IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGZvbGQgOiAoJ2EsIF8sIF8pIHQgLT4gaW5pdDonYWNjIC0+IGY6KCdhY2MgLT4gJ2EgZWx0IC0+ICdhY2MpIC0+ICdhY2NcblxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICAoJ2EsIF8sIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOignYWNjIC0+ICdhIGVsdCAtPiAoJ2FjYywgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjLCAnZSkgUmVzdWx0LnRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXywgXykgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCdhY2MgLT4gJ2EgZWx0IC0+ICgnYWNjLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBleGlzdHMgOiAoJ2EsIF8sIF8pIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGwgOiAoJ2EsIF8sIF8pIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogKCdhLCBfLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgc3VtXG4gICAgOiAgKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pXG4gICAgLT4gKCdhLCBfLCBfKSB0XG4gICAgLT4gZjooJ2EgZWx0IC0+ICdzdW0pXG4gICAgLT4gJ3N1bVxuXG4gIHZhbCBmaW5kIDogKCdhLCBfLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBmaW5kX21hcCA6ICgnYSwgXywgXykgdCAtPiBmOignYSBlbHQgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cbiAgdmFsIHRvX2xpc3QgOiAoJ2EsIF8sIF8pIHQgLT4gJ2EgZWx0IGxpc3RcbiAgdmFsIHRvX2FycmF5IDogKCdhLCBfLCBfKSB0IC0+ICdhIGVsdCBhcnJheVxuICB2YWwgbWluX2VsdCA6ICgnYSwgXywgXykgdCAtPiBjb21wYXJlOignYSBlbHQgLT4gJ2EgZWx0IC0+IGludCkgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXywgXykgdCAtPiBjb21wYXJlOignYSBlbHQgLT4gJ2EgZWx0IC0+IGludCkgLT4gJ2EgZWx0IG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIFMwX3dpdGhfY3JlYXRvcnMgPSBzaWdcbiAgaW5jbHVkZSBTMFxuXG4gIHZhbCBvZl9saXN0IDogZWx0IGxpc3QgLT4gdFxuICB2YWwgb2ZfYXJyYXkgOiBlbHQgYXJyYXkgLT4gdFxuXG4gICgqKiBFLmcuLCBbYXBwZW5kIChvZl9saXN0IFthOyBiXSkgKG9mX2xpc3QgW2M7IGQ7IGVdKV0gaXMgW29mX2xpc3QgW2E7IGI7IGM7IGQ7IGVdXSAqKVxuICB2YWwgYXBwZW5kIDogdCAtPiB0IC0+IHRcblxuICAoKiogQ29uY2F0ZW5hdGVzIGEgbmVzdGVkIGNvbnRhaW5lci4gVGhlIGVsZW1lbnRzIG9mIHRoZSBpbm5lciBjb250YWluZXJzIGFyZVxuICAgICAgY29uY2F0ZW5hdGVkIHRvZ2V0aGVyIGluIG9yZGVyIHRvIGdpdmUgdGhlIHJlc3VsdC4gKilcbiAgdmFsIGNvbmNhdCA6IHQgbGlzdCAtPiB0XG5cbiAgKCoqIFttYXAgZiAob2ZfbGlzdCBbYTE7IC4uLjsgYW5dKV0gYXBwbGllcyBbZl0gdG8gW2ExXSwgW2EyXSwgLi4uLCBbYW5dLCBpbiBvcmRlciwgYW5kXG4gICAgICBidWlsZHMgYSByZXN1bHQgZXF1aXZhbGVudCB0byBbb2ZfbGlzdCBbZiBhMTsgLi4uOyBmIGFuXV0uICopXG4gIHZhbCBtYXAgOiB0IC0+IGY6KGVsdCAtPiBlbHQpIC0+IHRcblxuICAoKiogW2ZpbHRlciB0IH5mXSByZXR1cm5zIGFsbCB0aGUgZWxlbWVudHMgb2YgW3RdIHRoYXQgc2F0aXNmeSB0aGUgcHJlZGljYXRlIFtmXS4gKilcbiAgdmFsIGZpbHRlciA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IHRcblxuICAoKiogW2ZpbHRlcl9tYXAgdCB+Zl0gYXBwbGllcyBbZl0gdG8gZXZlcnkgW3hdIGluIFt0XS4gVGhlIHJlc3VsdCBjb250YWlucyBldmVyeSBbeV0gZm9yXG4gICAgICB3aGljaCBbZiB4XSByZXR1cm5zIFtTb21lIHldLiAqKVxuICB2YWwgZmlsdGVyX21hcCA6IHQgLT4gZjooZWx0IC0+IGVsdCBvcHRpb24pIC0+IHRcblxuICAoKiogW2NvbmNhdF9tYXAgdCB+Zl0gaXMgZXF1aXZhbGVudCB0byBbY29uY2F0IChtYXAgdCB+ZildLiAqKVxuICB2YWwgY29uY2F0X21hcCA6IHQgLT4gZjooZWx0IC0+IHQpIC0+IHRcblxuICAoKiogW3BhcnRpdGlvbl90ZiB0IH5mXSByZXR1cm5zIGEgcGFpciBbdDEsIHQyXSwgd2hlcmUgW3QxXSBpcyBhbGwgZWxlbWVudHMgb2YgW3RdIHRoYXRcbiAgICAgIHNhdGlzZnkgW2ZdLCBhbmQgW3QyXSBpcyBhbGwgZWxlbWVudHMgb2YgW3RdIHRoYXQgZG8gbm90IHNhdGlzZnkgW2ZdLiBUaGUgXCJ0ZlwiXG4gICAgICBzdWZmaXggaXMgbW5lbW9uaWMgdG8gcmVtaW5kIHJlYWRlcnMgdGhhdCB0aGUgcmVzdWx0IGlzICh0cnVlcywgZmFsc2VzKS4gKilcbiAgdmFsIHBhcnRpdGlvbl90ZiA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IHQgKiB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fbWFwIHQgfmZdIHBhcnRpdGlvbnMgW3RdIGFjY29yZGluZyB0byBbZl0uICopXG4gIHZhbCBwYXJ0aXRpb25fbWFwIDogdCAtPiBmOihlbHQgLT4gKGVsdCwgZWx0KSBFaXRoZXIwLnQpIC0+IHQgKiB0XG5lbmRcblxubW9kdWxlIHR5cGUgUzFfd2l0aF9jcmVhdG9ycyA9IHNpZ1xuICBpbmNsdWRlIFMxXG5cbiAgdmFsIG9mX2xpc3QgOiAnYSBsaXN0IC0+ICdhIHRcbiAgdmFsIG9mX2FycmF5IDogJ2EgYXJyYXkgLT4gJ2EgdFxuXG4gICgqKiBFLmcuLCBbYXBwZW5kIChvZl9saXN0IFsxOyAyXSkgKG9mX2xpc3QgWzM7IDQ7IDVdKV0gaXMgW29mX2xpc3QgWzE7IDI7IDM7IDQ7IDVdXSAqKVxuICB2YWwgYXBwZW5kIDogJ2EgdCAtPiAnYSB0IC0+ICdhIHRcblxuICAoKiogQ29uY2F0ZW5hdGVzIGEgbmVzdGVkIGNvbnRhaW5lci4gVGhlIGVsZW1lbnRzIG9mIHRoZSBpbm5lciBjb250YWluZXJzIGFyZVxuICAgICAgY29uY2F0ZW5hdGVkIHRvZ2V0aGVyIGluIG9yZGVyIHRvIGdpdmUgdGhlIHJlc3VsdC4gKilcbiAgdmFsIGNvbmNhdCA6ICdhIHQgdCAtPiAnYSB0XG5cbiAgKCoqIFttYXAgZiAob2ZfbGlzdCBbYTE7IC4uLjsgYW5dKV0gYXBwbGllcyBbZl0gdG8gW2ExXSwgW2EyXSwgLi4uLCBbYW5dLCBpbiBvcmRlciwgYW5kXG4gICAgICBidWlsZHMgYSByZXN1bHQgZXF1aXZhbGVudCB0byBbb2ZfbGlzdCBbZiBhMTsgLi4uOyBmIGFuXV0uICopXG4gIHZhbCBtYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAnYiB0XG5cbiAgKCoqIFtmaWx0ZXIgdCB+Zl0gcmV0dXJucyBhbGwgdGhlIGVsZW1lbnRzIG9mIFt0XSB0aGF0IHNhdGlzZnkgdGhlIHByZWRpY2F0ZSBbZl0uICopXG4gIHZhbCBmaWx0ZXIgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIHRcblxuICAoKiogW2ZpbHRlcl9tYXAgdCB+Zl0gYXBwbGllcyBbZl0gdG8gZXZlcnkgW3hdIGluIFt0XS4gVGhlIHJlc3VsdCBjb250YWlucyBldmVyeSBbeV0gZm9yXG4gICAgICB3aGljaCBbZiB4XSByZXR1cm5zIFtTb21lIHldLiAqKVxuICB2YWwgZmlsdGVyX21hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiB0XG5cbiAgKCoqIFtjb25jYXRfbWFwIHQgfmZdIGlzIGVxdWl2YWxlbnQgdG8gW2NvbmNhdCAobWFwIHQgfmYpXS4gKilcbiAgdmFsIGNvbmNhdF9tYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiIHQpIC0+ICdiIHRcblxuICAoKiogW3BhcnRpdGlvbl90ZiB0IH5mXSByZXR1cm5zIGEgcGFpciBbdDEsIHQyXSwgd2hlcmUgW3QxXSBpcyBhbGwgZWxlbWVudHMgb2YgW3RdIHRoYXRcbiAgICAgIHNhdGlzZnkgW2ZdLCBhbmQgW3QyXSBpcyBhbGwgZWxlbWVudHMgb2YgW3RdIHRoYXQgZG8gbm90IHNhdGlzZnkgW2ZdLiBUaGUgXCJ0ZlwiXG4gICAgICBzdWZmaXggaXMgbW5lbW9uaWMgdG8gcmVtaW5kIHJlYWRlcnMgdGhhdCB0aGUgcmVzdWx0IGlzICh0cnVlcywgZmFsc2VzKS4gKilcbiAgdmFsIHBhcnRpdGlvbl90ZiA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2EgdCAqICdhIHRcblxuICAoKiogW3BhcnRpdGlvbl9tYXAgdCB+Zl0gcGFydGl0aW9ucyBbdF0gYWNjb3JkaW5nIHRvIFtmXS4gKilcbiAgdmFsIHBhcnRpdGlvbl9tYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2MpIEVpdGhlcjAudCkgLT4gJ2IgdCAqICdjIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBHZW5lcmljX3dpdGhfY3JlYXRvcnMgPSBzaWdcbiAgdHlwZSAoXywgXywgXykgY29uY2F0XG5cbiAgaW5jbHVkZSBHZW5lcmljXG5cbiAgdmFsIG9mX2xpc3QgOiAnYSBlbHQgbGlzdCAtPiAoJ2EsIF8sIF8pIHRcbiAgdmFsIG9mX2FycmF5IDogJ2EgZWx0IGFycmF5IC0+ICgnYSwgXywgXykgdFxuICB2YWwgYXBwZW5kIDogKCdhLCAncDEsICdwMikgdCAtPiAoJ2EsICdwMSwgJ3AyKSB0IC0+ICgnYSwgJ3AxLCAncDIpIHRcbiAgdmFsIGNvbmNhdCA6ICgoJ2EsICdwMSwgJ3AyKSB0LCAncDEsICdwMikgY29uY2F0IC0+ICgnYSwgJ3AxLCAncDIpIHRcbiAgdmFsIG1hcCA6ICgnYSwgJ3AxLCAncDIpIHQgLT4gZjooJ2EgZWx0IC0+ICdiIGVsdCkgLT4gKCdiLCAncDEsICdwMikgdFxuICB2YWwgZmlsdGVyIDogKCdhLCAncDEsICdwMikgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gKCdhLCAncDEsICdwMikgdFxuICB2YWwgZmlsdGVyX21hcCA6ICgnYSwgJ3AxLCAncDIpIHQgLT4gZjooJ2EgZWx0IC0+ICdiIGVsdCBvcHRpb24pIC0+ICgnYiwgJ3AxLCAncDIpIHRcbiAgdmFsIGNvbmNhdF9tYXAgOiAoJ2EsICdwMSwgJ3AyKSB0IC0+IGY6KCdhIGVsdCAtPiAoJ2IsICdwMSwgJ3AyKSB0KSAtPiAoJ2IsICdwMSwgJ3AyKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogICgnYSwgJ3AxLCAncDIpIHRcbiAgICAtPiBmOignYSBlbHQgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdwMSwgJ3AyKSB0ICogKCdhLCAncDEsICdwMikgdFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgOiAgKCdhLCAncDEsICdwMikgdFxuICAgIC0+IGY6KCdhIGVsdCAtPiAoJ2IgZWx0LCAnYyBlbHQpIEVpdGhlcjAudClcbiAgICAtPiAoJ2IsICdwMSwgJ3AyKSB0ICogKCdjLCAncDEsICdwMikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1ha2VfZ2VuX2FyZyA9IHNpZ1xuICB0eXBlICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIHRcbiAgdHlwZSAnYSBlbHRcblxuICB2YWwgZm9sZFxuICAgIDogICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOignYWNjIC0+ICdhIGVsdCAtPiAnYWNjKVxuICAgIC0+ICdhY2NcblxuICAoKiogVGhlIFtpdGVyXSBhcmd1bWVudCB0byBbQ29udGFpbmVyLk1ha2VdIHNwZWNpZmllcyBob3cgdG8gaW1wbGVtZW50IHRoZVxuICAgICAgY29udGFpbmVyJ3MgW2l0ZXJdIGZ1bmN0aW9uLiAgW2BEZWZpbmVfdXNpbmdfZm9sZF0gbWVhbnMgdG8gZGVmaW5lIFtpdGVyXVxuICAgICAgdmlhOlxuXG4gICAgICB7W1xuICAgICAgICBpdGVyIHQgfmYgPSBDb250YWluZXIuaXRlciB+Zm9sZCB0IH5mXG4gICAgICBdfVxuXG4gICAgICBbYEN1c3RvbV0gb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBwcmVzdW1hYmx5IHdpdGggc29tZXRoaW5nIG1vcmVcbiAgICAgIGVmZmljaWVudC4gIFNldmVyYWwgb3RoZXIgZnVuY3Rpb25zIHJldHVybmVkIGJ5IFtDb250YWluZXIuTWFrZV0gYXJlIGRlZmluZWQgaW5cbiAgICAgIHRlcm1zIG9mIFtpdGVyXSwgc28gcGFzc2luZyBpbiBhIG1vcmUgZWZmaWNpZW50IFtpdGVyXSB3aWxsIGltcHJvdmUgdGhlaXIgZWZmaWNpZW5jeVxuICAgICAgYXMgd2VsbC4gKilcbiAgdmFsIGl0ZXJcbiAgICA6IFsgYERlZmluZV91c2luZ19mb2xkXG4gICAgICB8IGBDdXN0b20gb2YgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgdCAtPiBmOignYSBlbHQgLT4gdW5pdCkgLT4gdW5pdFxuICAgICAgXVxuXG4gICgqKiBUaGUgW2xlbmd0aF0gYXJndW1lbnQgdG8gW0NvbnRhaW5lci5NYWtlXSBzcGVjaWZpZXMgaG93IHRvIGltcGxlbWVudCB0aGVcbiAgICAgIGNvbnRhaW5lcidzIFtsZW5ndGhdIGZ1bmN0aW9uLiAgW2BEZWZpbmVfdXNpbmdfZm9sZF0gbWVhbnMgdG8gZGVmaW5lXG4gICAgICBbbGVuZ3RoXSB2aWE6XG5cbiAgICAgIHtbXG4gICAgICAgIGxlbmd0aCB0IH5mID0gQ29udGFpbmVyLmxlbmd0aCB+Zm9sZCB0IH5mXG4gICAgICBdfVxuXG4gICAgICBbYEN1c3RvbV0gb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBwcmVzdW1hYmx5IHdpdGggc29tZXRoaW5nIG1vcmVcbiAgICAgIGVmZmljaWVudC4gIFNldmVyYWwgb3RoZXIgZnVuY3Rpb25zIHJldHVybmVkIGJ5IFtDb250YWluZXIuTWFrZV0gYXJlIGRlZmluZWQgaW5cbiAgICAgIHRlcm1zIG9mIFtsZW5ndGhdLCBzbyBwYXNzaW5nIGluIGEgbW9yZSBlZmZpY2llbnQgW2xlbmd0aF0gd2lsbCBpbXByb3ZlIHRoZWlyXG4gICAgICBlZmZpY2llbmN5IGFzIHdlbGwuICopXG4gIHZhbCBsZW5ndGggOiBbIGBEZWZpbmVfdXNpbmdfZm9sZCB8IGBDdXN0b20gb2YgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgdCAtPiBpbnQgXVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1ha2VfYXJnID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgTWFrZV9nZW5fYXJnIHdpdGggdHlwZSAoJ2EsIF8sIF8pIHQgOj0gJ2EgdCBhbmQgdHlwZSAnYSBlbHQgOj0gJ2FcbmVuZFxuXG5tb2R1bGUgdHlwZSBNYWtlMF9hcmcgPSBzaWdcbiAgbW9kdWxlIEVsdCA6IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgZW5kXG5cbiAgdHlwZSB0XG5cbiAgaW5jbHVkZSBNYWtlX2dlbl9hcmcgd2l0aCB0eXBlICgnYSwgXywgXykgdCA6PSB0IGFuZCB0eXBlICdhIGVsdCA6PSBFbHQudFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1ha2VfY29tbW9uX3dpdGhfY3JlYXRvcnNfYXJnID0gc2lnXG4gIGluY2x1ZGUgTWFrZV9nZW5fYXJnXG5cbiAgdHlwZSAoXywgXywgXykgY29uY2F0XG5cbiAgdmFsIG9mX2xpc3QgOiAnYSBlbHQgbGlzdCAtPiAoJ2EsIF8sIF8pIHRcbiAgdmFsIG9mX2FycmF5IDogJ2EgZWx0IGFycmF5IC0+ICgnYSwgXywgXykgdFxuICB2YWwgY29uY2F0IDogKCgnYSwgXywgXykgdCwgXywgXykgY29uY2F0IC0+ICgnYSwgXywgXykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnNfYXJnID0gc2lnXG4gIGluY2x1ZGUgTWFrZV9jb21tb25fd2l0aF9jcmVhdG9yc19hcmdcblxuICB2YWwgY29uY2F0X29mX2FycmF5IDogJ2EgYXJyYXkgLT4gKCdhLCBfLCBfKSBjb25jYXRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNYWtlX3dpdGhfY3JlYXRvcnNfYXJnID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGVcbiAgICBNYWtlX2NvbW1vbl93aXRoX2NyZWF0b3JzX2FyZ1xuICAgICAgd2l0aCB0eXBlICgnYSwgXywgXykgdCA6PSAnYSB0XG4gICAgICAgYW5kIHR5cGUgJ2EgZWx0IDo9ICdhXG4gICAgICAgYW5kIHR5cGUgKCdhLCBfLCBfKSBjb25jYXQgOj0gJ2EgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1ha2UwX3dpdGhfY3JlYXRvcnNfYXJnID0gc2lnXG4gIG1vZHVsZSBFbHQgOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sXG4gIGVuZFxuXG4gIHR5cGUgdFxuXG4gIGluY2x1ZGVcbiAgICBNYWtlX2NvbW1vbl93aXRoX2NyZWF0b3JzX2FyZ1xuICAgICAgd2l0aCB0eXBlICgnYSwgXywgXykgdCA6PSB0XG4gICAgICAgYW5kIHR5cGUgJ2EgZWx0IDo9IEVsdC50XG4gICAgICAgYW5kIHR5cGUgKCdhLCBfLCBfKSBjb25jYXQgOj0gJ2EgbGlzdFxuZW5kXG5cbm1vZHVsZSB0eXBlIERlcml2ZWQgPSBzaWdcbiAgKCoqIEdlbmVyaWMgZGVmaW5pdGlvbnMgb2YgY29udGFpbmVyIG9wZXJhdGlvbnMgaW4gdGVybXMgb2YgW2ZvbGRdLlxuXG4gICAgICBFLmcuOiBbaXRlciB+Zm9sZCB0IH5mID0gZm9sZCB0IH5pbml0OigpIH5mOihmdW4gKCkgYSAtPiBmIGEpXS4gKilcblxuICB0eXBlICgndCwgJ2EsICdhY2MpIGZvbGQgPSAndCAtPiBpbml0OidhY2MgLT4gZjooJ2FjYyAtPiAnYSAtPiAnYWNjKSAtPiAnYWNjXG4gIHR5cGUgKCd0LCAnYSkgaXRlciA9ICd0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgdHlwZSAndCBsZW5ndGggPSAndCAtPiBpbnRcblxuICB2YWwgaXRlciA6IGZvbGQ6KCd0LCAnYSwgdW5pdCkgZm9sZCAtPiAoJ3QsICdhKSBpdGVyXG4gIHZhbCBjb3VudCA6IGZvbGQ6KCd0LCAnYSwgaW50KSBmb2xkIC0+ICd0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGludFxuXG4gIHZhbCBtaW5fZWx0XG4gICAgOiAgZm9sZDooJ3QsICdhLCAnYSBvcHRpb24pIGZvbGRcbiAgICAtPiAndFxuICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludClcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgbWF4X2VsdFxuICAgIDogIGZvbGQ6KCd0LCAnYSwgJ2Egb3B0aW9uKSBmb2xkXG4gICAgLT4gJ3RcbiAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIGxlbmd0aCA6IGZvbGQ6KCd0LCBfLCBpbnQpIGZvbGQgLT4gJ3QgLT4gaW50XG4gIHZhbCB0b19saXN0IDogZm9sZDooJ3QsICdhLCAnYSBsaXN0KSBmb2xkIC0+ICd0IC0+ICdhIGxpc3RcblxuICB2YWwgc3VtXG4gICAgOiAgZm9sZDooJ3QsICdhLCAnc3VtKSBmb2xkXG4gICAgLT4gKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pXG4gICAgLT4gJ3RcbiAgICAtPiBmOignYSAtPiAnc3VtKVxuICAgIC0+ICdzdW1cblxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICBmb2xkOigndCwgJ2EsICdhY2MpIGZvbGRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOignYWNjIC0+ICdhIC0+ICgnYWNjLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gJ3RcbiAgICAtPiAoJ2FjYywgJ2UpIFJlc3VsdC50XG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICBmb2xkOigndCwgJ2EsICdhY2MpIGZvbGRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOignYWNjIC0+ICdhIC0+ICgnYWNjLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgIC0+ICd0XG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIEdlbmVyaWMgZGVmaW5pdGlvbnMgb2YgY29udGFpbmVyIG9wZXJhdGlvbnMgaW4gdGVybXMgb2YgW2l0ZXJdIGFuZCBbbGVuZ3RoXS4gKilcblxuICB2YWwgaXNfZW1wdHkgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gYm9vbFxuICB2YWwgbWVtIDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+ICdhIC0+IGVxdWFsOignYSAtPiAnYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbCA6IGl0ZXI6KCd0LCAnYSkgaXRlciAtPiAndCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmaW5kIDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvblxuICB2YWwgZmluZF9tYXAgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cbiAgdmFsIHRvX2FycmF5IDogbGVuZ3RoOid0IGxlbmd0aCAtPiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gJ2EgYXJyYXlcbmVuZFxuXG5tb2R1bGUgdHlwZSBDb250YWluZXIgPSBzaWdcbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICBpbmNsdWRlIEV4cG9ydFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMCA9IFMwXG4gIG1vZHVsZSB0eXBlIFMwX3BoYW50b20gPSBTMF9waGFudG9tXG4gIG1vZHVsZSB0eXBlIFMwX3dpdGhfY3JlYXRvcnMgPSBTMF93aXRoX2NyZWF0b3JzXG4gIG1vZHVsZSB0eXBlIFMxID0gUzFcbiAgbW9kdWxlIHR5cGUgUzFfcGhhbnRvbSA9IFMxX3BoYW50b21cbiAgbW9kdWxlIHR5cGUgUzFfd2l0aF9jcmVhdG9ycyA9IFMxX3dpdGhfY3JlYXRvcnNcbiAgbW9kdWxlIHR5cGUgRGVyaXZlZCA9IERlcml2ZWRcbiAgbW9kdWxlIHR5cGUgR2VuZXJpYyA9IEdlbmVyaWNcbiAgbW9kdWxlIHR5cGUgR2VuZXJpY193aXRoX2NyZWF0b3JzID0gR2VuZXJpY193aXRoX2NyZWF0b3JzXG4gIG1vZHVsZSB0eXBlIFN1bW1hYmxlID0gU3VtbWFibGVcblxuICBpbmNsdWRlIERlcml2ZWRcblxuICAoKiogVGhlIGlkaW9tIGZvciB1c2luZyBbQ29udGFpbmVyLk1ha2VdIGlzIHRvIGJpbmQgdGhlIHJlc3VsdGluZyBtb2R1bGUgYW5kIHRvXG4gICAgICBleHBsaWNpdGx5IGltcG9ydCBlYWNoIG9mIHRoZSBmdW5jdGlvbnMgdGhhdCBvbmUgd2FudHM6XG5cbiAgICAgIHtbXG4gICAgICAgIG1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKHN0cnVjdCAuLi4gZW5kKVxuICAgICAgICBsZXQgY291bnQgICAgPSBDLmNvdW50XG4gICAgICAgIGxldCBleGlzdHMgICA9IEMuZXhpc3RzXG4gICAgICAgIGxldCBmaW5kICAgICA9IEMuZmluZFxuICAgICAgICAoKiAuLi4gKilcbiAgICAgIF19XG5cbiAgICAgIFRoaXMgaXMgcHJlZmVyYWJsZSB0bzpcblxuICAgICAge1tcbiAgICAgICAgaW5jbHVkZSBDb250YWluZXIuTWFrZSAoc3RydWN0IC4uLiBlbmQpXG4gICAgICBdfVxuXG4gICAgICBiZWNhdXNlIHRoZSBbaW5jbHVkZV0gbWFrZXMgaXQgdG9vIGVhc3kgdG8gc2hhZG93IHNwZWNpYWxpemVkIGltcGxlbWVudGF0aW9ucyBvZlxuICAgICAgY29udGFpbmVyIGZ1bmN0aW9ucyAoW2xlbmd0aF0gYmVpbmcgYSBjb21tb24gb25lKS5cblxuICAgICAgW0NvbnRhaW5lci5NYWtlMF0gaXMgbGlrZSBbQ29udGFpbmVyLk1ha2VdLCBidXQgZm9yIG1vbm9tb3JwaGljIGNvbnRhaW5lcnMgbGlrZVxuICAgICAgW3N0cmluZ10uICopXG4gIG1vZHVsZSBNYWtlIChUIDogTWFrZV9hcmcpIDogUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50XG5cbiAgbW9kdWxlIE1ha2UwIChUIDogTWFrZTBfYXJnKSA6IFMwIHdpdGggdHlwZSB0IDo9IFQudCBhbmQgdHlwZSBlbHQgOj0gVC5FbHQudFxuXG4gIG1vZHVsZSBNYWtlX2dlbiAoVCA6IE1ha2VfZ2VuX2FyZykgOlxuICAgIEdlbmVyaWNcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSB0IDo9ICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIFQudFxuICAgICAgIGFuZCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdFxuXG4gIG1vZHVsZSBNYWtlX3dpdGhfY3JlYXRvcnMgKFQgOiBNYWtlX3dpdGhfY3JlYXRvcnNfYXJnKSA6XG4gICAgUzFfd2l0aF9jcmVhdG9ycyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnRcblxuICBtb2R1bGUgTWFrZTBfd2l0aF9jcmVhdG9ycyAoVCA6IE1ha2UwX3dpdGhfY3JlYXRvcnNfYXJnKSA6XG4gICAgUzBfd2l0aF9jcmVhdG9ycyB3aXRoIHR5cGUgdCA6PSBULnQgYW5kIHR5cGUgZWx0IDo9IFQuRWx0LnRcblxuICBtb2R1bGUgTWFrZV9nZW5fd2l0aF9jcmVhdG9ycyAoVCA6IE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnNfYXJnKSA6XG4gICAgR2VuZXJpY193aXRoX2NyZWF0b3JzXG4gICAgICB3aXRoIHR5cGUgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgdCA6PSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSBULnRcbiAgICAgICBhbmQgdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHRcbiAgICAgICBhbmQgdHlwZSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSBjb25jYXQgOj0gKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgVC5jb25jYXRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBFaXRoZXIgPSBFaXRoZXIwXG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIENvbnRhaW5lcl9pbnRmXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cbnR5cGUgKCd0LCAnYSwgJ2FjY3VtKSBmb2xkID0gJ3QgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG50eXBlICgndCwgJ2EpIGl0ZXIgPSAndCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG50eXBlICd0IGxlbmd0aCA9ICd0IC0+IGludFxuXG5sZXQgaXRlciB+KGZvbGQgOiAoXywgXywgXykgZm9sZCkgdCB+ZiA9IGZvbGQgdCB+aW5pdDooKSB+ZjooZnVuICgpIGEgLT4gZiBhKSBbQG5vbnRhaWxdXG5sZXQgY291bnQgfmZvbGQgdCB+ZiA9IGZvbGQgdCB+aW5pdDowIH5mOihmdW4gbiBhIC0+IGlmIGYgYSB0aGVuIG4gKyAxIGVsc2UgbikgW0Bub250YWlsXVxuXG5sZXQgc3VtICh0eXBlIGEpIH5mb2xkIChtb2R1bGUgTSA6IFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gYSkgdCB+ZiA9XG4gIGZvbGQgdCB+aW5pdDpNLnplcm8gfmY6KGZ1biBuIGEgLT4gTS4oICsgKSBuIChmIGEpKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdCA9XG4gIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgIFJlc3VsdC5Pa1xuICAgICAgKGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBpdGVtIC0+XG4gICAgICAgICBtYXRjaCBmIGFjYyBpdGVtIHdpdGhcbiAgICAgICAgIHwgUmVzdWx0Lk9rIHggLT4geFxuICAgICAgICAgfCBFcnJvciBfIGFzIGUgLT4gcmV0dXJuIGUpKSkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgfmZpbmlzaCB0ID1cbiAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgZmluaXNoXG4gICAgICAoZm9sZCB0IH5pbml0IH5mOihmdW4gYWNjIGl0ZW0gLT5cbiAgICAgICAgIG1hdGNoIGYgYWNjIGl0ZW0gd2l0aFxuICAgICAgICAgfCBDb250aW51ZV9vcl9zdG9wLkNvbnRpbnVlIHggLT4geFxuICAgICAgICAgfCBTdG9wIHggLT4gcmV0dXJuIHgpKSkgW0Bub250YWlsXVxuOztcblxubGV0IG1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZSA9XG4gIGZvbGQgdCB+aW5pdDpOb25lIH5mOihmdW4gYWNjIGVsdCAtPlxuICAgIG1hdGNoIGFjYyB3aXRoXG4gICAgfCBOb25lIC0+IFNvbWUgZWx0XG4gICAgfCBTb21lIG1pbiAtPiBpZiBjb21wYXJlIG1pbiBlbHQgPiAwIHRoZW4gU29tZSBlbHQgZWxzZSBhY2MpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBtYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmUgPVxuICBmb2xkIHQgfmluaXQ6Tm9uZSB+ZjooZnVuIGFjYyBlbHQgLT5cbiAgICBtYXRjaCBhY2Mgd2l0aFxuICAgIHwgTm9uZSAtPiBTb21lIGVsdFxuICAgIHwgU29tZSBtYXggLT4gaWYgY29tcGFyZSBtYXggZWx0IDwgMCB0aGVuIFNvbWUgZWx0IGVsc2UgYWNjKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbGVuZ3RoIH5mb2xkIGMgPSBmb2xkIGMgfmluaXQ6MCB+ZjooZnVuIGFjYyBfIC0+IGFjYyArIDEpXG5cbmxldCBpc19lbXB0eSB+aXRlciBjID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciBjIH5mOihmdW4gXyAtPiByLnJldHVybiBmYWxzZSk7XG4gICAgdHJ1ZSlcbjs7XG5cbmxldCBtZW0gfml0ZXIgYyB4IH5lcXVhbCA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIHkgLT4gaWYgZXF1YWwgeCB5IHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgZmFsc2UpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBleGlzdHMgfml0ZXIgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgZmFsc2UpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb3JfYWxsIH5pdGVyIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biB4IC0+IGlmIG5vdCAoZiB4KSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICB0cnVlKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZF9tYXAgfml0ZXIgdCB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgdCB+ZjooZnVuIHggLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIGFzIHJlcyAtPiByLnJldHVybiByZXMpO1xuICAgIE5vbmUpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kIH5pdGVyIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIHIucmV0dXJuIChTb21lIHgpKTtcbiAgICBOb25lKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgdG9fbGlzdCB+Zm9sZCBjID0gTGlzdC5yZXYgKGZvbGQgYyB+aW5pdDpbXSB+ZjooZnVuIGFjYyB4IC0+IHggOjogYWNjKSlcblxubGV0IHRvX2FycmF5IH5sZW5ndGggfml0ZXIgYyA9XG4gIGxldCBhcnJheSA9IHJlZiBbfHxdIGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgaXRlciBjIH5mOihmdW4geCAtPlxuICAgIGlmICFpID0gMCB0aGVuIGFycmF5IDo9IEFycmF5LmNyZWF0ZSB+bGVuOihsZW5ndGggYykgeDtcbiAgICAhYXJyYXkuKCFpKSA8LSB4O1xuICAgIGluY3IgaSk7XG4gICFhcnJheVxuOztcblxubW9kdWxlIE1ha2VfZ2VuIChUIDogTWFrZV9nZW5fYXJnKSA6XG4gIEdlbmVyaWNcbiAgICB3aXRoIHR5cGUgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgdCA6PSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSBULnRcbiAgICAgYW5kIHR5cGUgJ2EgZWx0IDo9ICdhIFQuZWx0ID0gc3RydWN0XG4gIGxldCBmb2xkID0gVC5mb2xkXG5cbiAgbGV0IGl0ZXIgPVxuICAgIG1hdGNoIFQuaXRlciB3aXRoXG4gICAgfCBgQ3VzdG9tIGl0ZXIgLT4gaXRlclxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IH5mIC0+IGl0ZXIgfmZvbGQgdCB+ZlxuICA7O1xuXG4gIGxldCBsZW5ndGggPVxuICAgIG1hdGNoIFQubGVuZ3RoIHdpdGhcbiAgICB8IGBDdXN0b20gbGVuZ3RoIC0+IGxlbmd0aFxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IC0+IGxlbmd0aCB+Zm9sZCB0XG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBpc19lbXB0eSB+aXRlciB0XG4gIGxldCBtZW0gdCB4IH5lcXVhbCA9IG1lbSB+aXRlciB0IHggfmVxdWFsXG4gIGxldCBzdW0gbSB0ID0gc3VtIH5mb2xkIG0gdFxuICBsZXQgY291bnQgdCB+ZiA9IGNvdW50IH5mb2xkIHQgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzIH5pdGVyIHQgfmZcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IGZvcl9hbGwgfml0ZXIgdCB+ZlxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IGZpbmRfbWFwIH5pdGVyIHQgfmZcbiAgbGV0IGZpbmQgdCB+ZiA9IGZpbmQgfml0ZXIgdCB+ZlxuICBsZXQgdG9fbGlzdCB0ID0gdG9fbGlzdCB+Zm9sZCB0XG4gIGxldCB0b19hcnJheSB0ID0gdG9fYXJyYXkgfmxlbmd0aCB+aXRlciB0XG4gIGxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBtaW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbiAgbGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IG1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuICBsZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IGZvbGRfcmVzdWx0IHQgfmZvbGQgfmluaXQgfmZcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gZm9sZF91bnRpbCB0IH5mb2xkIH5pbml0IH5mIH5maW5pc2hcbmVuZFxuXG5tb2R1bGUgTWFrZSAoVCA6IE1ha2VfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIHR5cGUgKCdhLCBfLCBfKSB0ID0gJ2EgVC50XG4gICAgdHlwZSAnYSBlbHQgPSAnYVxuICBlbmQpXG5lbmRcblxubW9kdWxlIE1ha2UwIChUIDogTWFrZTBfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIHR5cGUgKCdhLCBfLCBfKSB0ID0gVC50XG4gICAgdHlwZSAnYSBlbHQgPSBULkVsdC50XG4gIGVuZClcblxuICBsZXQgbWVtIHQgeCA9IG1lbSB0IHggfmVxdWFsOlQuRWx0LmVxdWFsXG5lbmRcblxubW9kdWxlIE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMgKFQgOiBNYWtlX2dlbl93aXRoX2NyZWF0b3JzX2FyZykgOlxuICBHZW5lcmljX3dpdGhfY3JlYXRvcnNcbiAgICB3aXRoIHR5cGUgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgdCA6PSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSBULnRcbiAgICAgYW5kIHR5cGUgJ2EgZWx0IDo9ICdhIFQuZWx0XG4gICAgIGFuZCB0eXBlICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIGNvbmNhdCA6PSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSBULmNvbmNhdCA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbiAoVClcblxuICBsZXQgb2ZfbGlzdCA9IFQub2ZfbGlzdFxuICBsZXQgb2ZfYXJyYXkgPSBULm9mX2FycmF5XG4gIGxldCBjb25jYXQgPSBULmNvbmNhdFxuICBsZXQgY29uY2F0X29mX2FycmF5ID0gVC5jb25jYXRfb2ZfYXJyYXlcbiAgbGV0IGFwcGVuZCBhIGIgPSBjb25jYXQgKGNvbmNhdF9vZl9hcnJheSBbfCBhOyBiIHxdKVxuICBsZXQgY29uY2F0X21hcCB0IH5mID0gY29uY2F0IChjb25jYXRfb2ZfYXJyYXkgKEFycmF5Lm1hcCAodG9fYXJyYXkgdCkgfmYpKVxuXG4gIGxldCBmaWx0ZXJfbWFwIHQgfmYgPVxuICAgIGNvbmNhdF9tYXAgdCB+ZjooZnVuIHggLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IE5vbmUgLT4gb2ZfYXJyYXkgW3x8XVxuICAgICAgfCBTb21lIHkgLT4gb2ZfYXJyYXkgW3wgeSB8XSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiA9IGZpbHRlcl9tYXAgdCB+ZjooZnVuIHggLT4gU29tZSAoZiB4KSkgW0Bub250YWlsXVxuICBsZXQgZmlsdGVyIHQgfmYgPSBmaWx0ZXJfbWFwIHQgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpIFtAbm9udGFpbF1cblxuICBsZXQgcGFydGl0aW9uX21hcCB0IH5mID1cbiAgICBsZXQgYXJyYXkgPSBBcnJheS5tYXAgKHRvX2FycmF5IHQpIH5mIGluXG4gICAgbGV0IHhzID1cbiAgICAgIEFycmF5LmZvbGRfcmlnaHQgYXJyYXkgfmluaXQ6W10gfmY6KGZ1biBlaXRoZXIgYWNjIC0+XG4gICAgICAgIG1hdGNoIChlaXRoZXIgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgRmlyc3QgeCAtPiB4IDo6IGFjY1xuICAgICAgICB8IFNlY29uZCBfIC0+IGFjYylcbiAgICBpblxuICAgIGxldCB5cyA9XG4gICAgICBBcnJheS5mb2xkX3JpZ2h0IGFycmF5IH5pbml0OltdIH5mOihmdW4gZWl0aGVyIGFjYyAtPlxuICAgICAgICBtYXRjaCAoZWl0aGVyIDogXyBFaXRoZXIudCkgd2l0aFxuICAgICAgICB8IEZpcnN0IF8gLT4gYWNjXG4gICAgICAgIHwgU2Vjb25kIHggLT4geCA6OiBhY2MpXG4gICAgaW5cbiAgICBvZl9saXN0IHhzLCBvZl9saXN0IHlzXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB0IH5mID1cbiAgICBwYXJ0aXRpb25fbWFwIHQgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIEZpcnN0IHggZWxzZSBTZWNvbmQgeCkgW0Bub250YWlsXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlX3dpdGhfY3JlYXRvcnMgKFQgOiBNYWtlX3dpdGhfY3JlYXRvcnNfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgdHlwZSAoJ2EsIF8sIF8pIHQgPSAnYSBULnRcbiAgICB0eXBlICdhIGVsdCA9ICdhXG4gICAgdHlwZSAoJ2EsIF8sIF8pIGNvbmNhdCA9ICdhIFQudFxuXG4gICAgbGV0IGNvbmNhdF9vZl9hcnJheSA9IG9mX2FycmF5XG4gIGVuZClcbmVuZFxuXG5tb2R1bGUgTWFrZTBfd2l0aF9jcmVhdG9ycyAoVCA6IE1ha2UwX3dpdGhfY3JlYXRvcnNfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgdHlwZSAoJ2EsIF8sIF8pIHQgPSBULnRcbiAgICB0eXBlICdhIGVsdCA9IFQuRWx0LnRcbiAgICB0eXBlICgnYSwgXywgXykgY29uY2F0ID0gJ2EgbGlzdFxuXG4gICAgbGV0IGNvbmNhdF9vZl9hcnJheSA9IEFycmF5LnRvX2xpc3RcbiAgZW5kKVxuXG4gIGxldCBtZW0gdCB4ID0gbWVtIHQgeCB+ZXF1YWw6VC5FbHQuZXF1YWxcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbmluY2x1ZGUgSW5kZXhlZF9jb250YWluZXJfaW50ZlxuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG5sZXRbQGlubGluZSBhbHdheXNdIGl0ZXJpIH5mb2xkIHQgfmYgPVxuICBpZ25vcmVcbiAgICAoZm9sZCB0IH5pbml0OjAgfmY6KGZ1biBpIHggLT5cbiAgICAgICBmIGkgeDtcbiAgICAgICBpICsgMSlcbiAgICAgIDogaW50KVxuOztcblxubGV0IGZvbGRpIH5mb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyB2IC0+XG4gICAgbGV0IGFjYyA9IGYgIWkgYWNjIHYgaW5cbiAgICBpIDo9ICFpICsgMTtcbiAgICBhY2MpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBjb3VudGkgfmZvbGRpIHQgfmYgPVxuICBmb2xkaSB0IH5pbml0OjAgfmY6KGZ1biBpIG4gYSAtPiBpZiBmIGkgYSB0aGVuIG4gKyAxIGVsc2UgbikgW0Bub250YWlsXVxuOztcblxubGV0IGV4aXN0c2kgfml0ZXJpIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSBjIH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgZmFsc2UpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb3JfYWxsaSB+aXRlcmkgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIGMgfmY6KGZ1biBpIHggLT4gaWYgbm90IChmIGkgeCkgdGhlbiByLnJldHVybiBmYWxzZSk7XG4gICAgdHJ1ZSkgW0Bub250YWlsXVxuOztcblxubGV0IGZpbmRfbWFwaSB+aXRlcmkgdCB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIHQgfmY6KGZ1biBpIHggLT5cbiAgICAgIG1hdGNoIGYgaSB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIF8gYXMgcmVzIC0+IHIucmV0dXJuIHJlcyk7XG4gICAgTm9uZSkgW0Bub250YWlsXVxuOztcblxubGV0IGZpbmRpIH5pdGVyaSBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgYyB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIHIucmV0dXJuIChTb21lIChpLCB4KSkpO1xuICAgIE5vbmUpIFtAbm9udGFpbF1cbjs7XG5cbigqIEFsbG93cyBbTWFrZV9nZW5dIHRvIHNoYXJlIGEgW0NvbnRhaW5lci5HZW5lcmljXSBpbXBsZW1lbnRhdGlvbiB3aXRoLCBlLmcuLFxuICAgW0NvbnRhaW5lci5NYWtlX2dlbl93aXRoX2NyZWF0b3JzXS4gKilcbm1vZHVsZSBNYWtlX2dlbl93aXRoX2NvbnRhaW5lclxuICAoVCA6IE1ha2VfZ2VuX2FyZylcbiAgKEMgOiBDb250YWluZXIuR2VuZXJpY1xuICAgICAgICAgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIHQgOj0gKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgVC50XG4gICAgICAgICAgYW5kIHR5cGUgJ2EgZWx0IDo9ICdhIFQuZWx0KSA6XG4gIEdlbmVyaWNcbiAgICB3aXRoIHR5cGUgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgdCA6PSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSBULnRcbiAgICAgYW5kIHR5cGUgJ2EgZWx0IDo9ICdhIFQuZWx0ID0gc3RydWN0XG4gIGluY2x1ZGUgQ1xuXG4gIGxldCBpdGVyaSA9XG4gICAgbWF0Y2ggVC5pdGVyaSB3aXRoXG4gICAgfCBgQ3VzdG9tIGl0ZXJpIC0+IGl0ZXJpXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgfmYgLT4gaXRlcmkgfmZvbGQgdCB+ZlxuICA7O1xuXG4gIGxldCBmb2xkaSA9XG4gICAgbWF0Y2ggVC5mb2xkaSB3aXRoXG4gICAgfCBgQ3VzdG9tIGZvbGRpIC0+IGZvbGRpXG4gICAgfCBgRGVmaW5lX3VzaW5nX2ZvbGQgLT4gZnVuIHQgfmluaXQgfmYgLT4gZm9sZGkgfmZvbGQgdCB+aW5pdCB+ZlxuICA7O1xuXG4gIGxldCBjb3VudGkgdCB+ZiA9IGNvdW50aSB+Zm9sZGkgdCB+ZlxuICBsZXQgZXhpc3RzaSB0IH5mID0gZXhpc3RzaSB+aXRlcmkgdCB+ZlxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9IGZvcl9hbGxpIH5pdGVyaSB0IH5mXG4gIGxldCBmaW5kX21hcGkgdCB+ZiA9IGZpbmRfbWFwaSB+aXRlcmkgdCB+ZlxuICBsZXQgZmluZGkgdCB+ZiA9IGZpbmRpIH5pdGVyaSB0IH5mXG5lbmRcbltAQGlubGluZSBhbHdheXNdXG5cbm1vZHVsZSBNYWtlX2dlbiAoVCA6IE1ha2VfZ2VuX2FyZykgOlxuICBHZW5lcmljXG4gICAgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIHQgOj0gKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgVC50XG4gICAgIGFuZCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdCA9IHN0cnVjdFxuICBtb2R1bGUgQyA9IENvbnRhaW5lci5NYWtlX2dlbiAoVClcbiAgaW5jbHVkZSBDXG4gIGluY2x1ZGUgTWFrZV9nZW5fd2l0aF9jb250YWluZXIgKFQpIChDKVxuZW5kXG5bQEBpbmxpbmUgYWx3YXlzXVxuXG5tb2R1bGUgTWFrZSAoVCA6IE1ha2VfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIHR5cGUgKCdhLCBfLCBfKSB0ID0gJ2EgVC50XG4gICAgdHlwZSAnYSBlbHQgPSAnYVxuICBlbmQpXG5lbmRcbltAQGlubGluZSBhbHdheXNdXG5cbm1vZHVsZSBNYWtlMCAoVCA6IE1ha2UwX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICB0eXBlIChfLCBfLCBfKSB0ID0gVC50XG4gICAgdHlwZSAnYSBlbHQgPSBULkVsdC50XG4gIGVuZClcblxuICBsZXQgbWVtIHQgeCA9IG1lbSB0IHggfmVxdWFsOlQuRWx0LmVxdWFsXG5lbmRcblxubW9kdWxlIE1ha2VfZ2VuX3dpdGhfY3JlYXRvcnMgKFQgOiBNYWtlX2dlbl93aXRoX2NyZWF0b3JzX2FyZykgOlxuICBHZW5lcmljX3dpdGhfY3JlYXRvcnNcbiAgICB3aXRoIHR5cGUgKCdhLCAncGhhbnRvbTEsICdwaGFudG9tMikgdCA6PSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSBULnRcbiAgICAgYW5kIHR5cGUgJ2EgZWx0IDo9ICdhIFQuZWx0XG4gICAgIGFuZCB0eXBlICgnYSwgJ3BoYW50b20xLCAncGhhbnRvbTIpIGNvbmNhdCA6PSAoJ2EsICdwaGFudG9tMSwgJ3BoYW50b20yKSBULmNvbmNhdCA9XG5zdHJ1Y3RcbiAgbW9kdWxlIEMgPSBDb250YWluZXIuTWFrZV9nZW5fd2l0aF9jcmVhdG9ycyAoVClcbiAgaW5jbHVkZSBDXG4gIGluY2x1ZGUgTWFrZV9nZW5fd2l0aF9jb250YWluZXIgKFQpIChDKVxuXG4gIGxldCBkZXJpdmVkX2luaXQgbiB+ZiA9IG9mX2FycmF5IChBcnJheS5pbml0IG4gfmYpXG5cbiAgbGV0IGluaXQgPVxuICAgIG1hdGNoIFQuaW5pdCB3aXRoXG4gICAgfCBgQ3VzdG9tIGluaXQgLT4gaW5pdFxuICAgIHwgYERlZmluZV91c2luZ19vZl9hcnJheSAtPiBkZXJpdmVkX2luaXRcbiAgOztcblxuICBsZXQgZGVyaXZlZF9jb25jYXRfbWFwaSB0IH5mID0gY29uY2F0IChULmNvbmNhdF9vZl9hcnJheSAoQXJyYXkubWFwaSAodG9fYXJyYXkgdCkgfmYpKVxuXG4gIGxldCBjb25jYXRfbWFwaSA9XG4gICAgbWF0Y2ggVC5jb25jYXRfbWFwaSB3aXRoXG4gICAgfCBgQ3VzdG9tIGNvbmNhdF9tYXBpIC0+IGNvbmNhdF9tYXBpXG4gICAgfCBgRGVmaW5lX3VzaW5nX2NvbmNhdCAtPiBkZXJpdmVkX2NvbmNhdF9tYXBpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICAgIGNvbmNhdF9tYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICAgIG1hdGNoIGYgaSB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBvZl9hcnJheSBbfHxdXG4gICAgICB8IFNvbWUgeSAtPiBvZl9hcnJheSBbfCB5IHxdKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG1hcGkgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBpIHggLT4gU29tZSAoZiBpIHgpKSBbQG5vbnRhaWxdXG5cbiAgbGV0IGZpbHRlcmkgdCB+ZiA9XG4gICAgZmlsdGVyX21hcGkgdCB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpIFtAbm9udGFpbF1cbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZV93aXRoX2NyZWF0b3JzIChUIDogTWFrZV93aXRoX2NyZWF0b3JzX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbl93aXRoX2NyZWF0b3JzIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIHR5cGUgKCdhLCBfLCBfKSB0ID0gJ2EgVC50XG4gICAgdHlwZSAnYSBlbHQgPSAnYVxuICAgIHR5cGUgKCdhLCBfLCBfKSBjb25jYXQgPSAnYSBULnRcblxuICAgIGxldCBjb25jYXRfb2ZfYXJyYXkgPSBvZl9hcnJheVxuICBlbmQpXG5lbmRcblxubW9kdWxlIE1ha2UwX3dpdGhfY3JlYXRvcnMgKFQgOiBNYWtlMF93aXRoX2NyZWF0b3JzX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbl93aXRoX2NyZWF0b3JzIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIHR5cGUgKF8sIF8sIF8pIHQgPSBULnRcbiAgICB0eXBlICdhIGVsdCA9IFQuRWx0LnRcbiAgICB0eXBlICgnYSwgXywgXykgY29uY2F0ID0gJ2EgbGlzdFxuXG4gICAgbGV0IGNvbmNhdF9vZl9hcnJheSA9IEFycmF5LnRvX2xpc3RcbiAgZW5kKVxuXG4gIGxldCBtZW0gdCB4ID0gbWVtIHQgeCB+ZXF1YWw6VC5FbHQuZXF1YWxcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIFN0ZGxpYi5MYXp5XG5cbnR5cGUgJ2EgdCA9ICdhIGxhenlfdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gbGF6eV90X29mX3NleHBcbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPSBzZXhwX29mX2xhenlfdFxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOiAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGxhenlfdF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuOztcblxuW0BAQGVuZF1cblxuZXh0ZXJuYWwgZm9yY2UgOiAoJ2EgdFtAbG9jYWxfb3B0XSkgLT4gJ2EgPSBcIiVsYXp5X2ZvcmNlXCJcblxubGV0IGdsb2JhbGl6ZSA9IEdsb2JhbGl6ZS5nbG9iYWxpemVfbGF6eV90XG5sZXQgbWFwIHQgfmYgPSBsYXp5IChmIChmb3JjZSB0KSlcblxubGV0IGNvbXBhcmVfX2xvY2FsIGNvbXBhcmVfYSB0MSB0MiA9XG4gIGlmIHBoeXNfZXF1YWwgdDEgdDIgdGhlbiAwIGVsc2UgY29tcGFyZV9hIChmb3JjZSB0MSkgKGZvcmNlIHQyKVxuOztcblxubGV0IGNvbXBhcmUgY29tcGFyZV9hIHQxIHQyID0gY29tcGFyZV9fbG9jYWwgY29tcGFyZV9hIHQxIHQyXG5cbmxldCBlcXVhbF9fbG9jYWwgZXF1YWxfYSB0MSB0MiA9XG4gIGlmIHBoeXNfZXF1YWwgdDEgdDIgdGhlbiB0cnVlIGVsc2UgZXF1YWxfYSAoZm9yY2UgdDEpIChmb3JjZSB0Milcbjs7XG5cbmxldCBlcXVhbCBlcXVhbF9hIHQxIHQyID0gZXF1YWxfX2xvY2FsIGVxdWFsX2EgdDEgdDJcbmxldCBoYXNoX2ZvbGRfdCA9IEhhc2guQnVpbHRpbi5oYXNoX2ZvbGRfbGF6eV90XG5sZXQgcGVlayB0ID0gaWYgaXNfdmFsIHQgdGhlbiBTb21lIChmb3JjZSB0KSBlbHNlIE5vbmVcblxuaW5jbHVkZSBNb25hZC5NYWtlIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgcmV0dXJuIHggPSBmcm9tX3ZhbCB4XG4gIGxldCBiaW5kIHQgfmYgPSBsYXp5IChmb3JjZSAoZiAoZm9yY2UgdCkpKVxuICBsZXQgbWFwID0gbWFwXG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuZW5kKVxuXG5tb2R1bGUgVF91bmZvcmNpbmcgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgICBpZiBpc192YWwgdCB0aGVuIHNleHBfb2ZfYSAoZm9yY2UgdCkgZWxzZSBzZXhwX29mX3N0cmluZyBcIjx1bmZvcmNlZCBsYXp5PlwiXG4gIDs7XG5lbmRcbiIsIigqIFNwbGl0IG9mZiB0byBhdm9pZCBhIGN5Y2xpYyBkZXBlbmRlbmN5IHdpdGggW09yX2Vycm9yXS4gKilcblxub3BlbiEgSW1wb3J0XG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbmxldCBzbG93X2NoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoID1cbiAgaWYgcG9zIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIk5lZ2F0aXZlIHBvc2l0aW9uOiAlZFwiIHBvcyAoKTtcbiAgaWYgbGVuIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIk5lZ2F0aXZlIGxlbmd0aDogJWRcIiBsZW4gKCk7XG4gICgqIFdlIHVzZSBbcG9zID4gdG90YWxfbGVuZ3RoIC0gbGVuXSByYXRoZXIgdGhhbiBbcG9zICsgbGVuID4gdG90YWxfbGVuZ3RoXSB0byBhdm9pZCB0aGVcbiAgICAgcG9zc2liaWxpdHkgb2Ygb3ZlcmZsb3cuICopXG4gIGlmIHBvcyA+IHRvdGFsX2xlbmd0aCAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnZiBcInBvcyArIGxlbiBwYXN0IGVuZDogJWQgKyAlZCA+ICVkXCIgcG9zIGxlbiB0b3RhbF9sZW5ndGggKClcbiAgW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbjs7XG5cbmxldCBjaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aCA9XG4gICgqIFRoaXMgaXMgYmV0dGVyIHRoYW4gW3Nsb3dfY2hlY2tfcG9zX2xlbl9leG5dIGZvciB0d28gcmVhc29uczpcblxuICAgICAtIG11Y2ggbGVzcyBpbmxpbmVkIGNvZGVcbiAgICAgLSBvbmx5IG9uZSBjb25kaXRpb25hbCBqdW1wXG5cbiAgICAgVGhlIHJlYXNvbiBpdCB3b3JrcyBpcyB0aGF0IGNoZWNraW5nIFs8IDBdIGlzIHRlc3RpbmcgdGhlIGhpZ2hlc3Qgb3JkZXIgYml0LCBzb1xuICAgICBbYSA8IDAgfHwgYiA8IDBdIGlzIHRoZSBzYW1lIGFzIFthIGxvciBiIDwgMF0uXG5cbiAgICAgW3BvcyArIGxlbl0gY2FuIG92ZXJmbG93LCBzbyBbcG9zID4gdG90YWxfbGVuZ3RoIC0gbGVuXSBpcyBub3QgZXF1aXZhbGVudCB0b1xuICAgICBbdG90YWxfbGVuZ3RoIC0gbGVuIC0gcG9zIDwgMF0sIHdlIG5lZWQgdG8gdGVzdCBmb3IgW3BvcyArIGxlbl0gb3ZlcmZsb3cgYXNcbiAgICAgd2VsbC4gKilcbiAgbGV0IHN0b3AgPSBwb3MgKyBsZW4gaW5cbiAgaWYgcG9zIGxvciBsZW4gbG9yIHN0b3AgbG9yICh0b3RhbF9sZW5ndGggLSBzdG9wKSA8IDBcbiAgdGhlbiBzbG93X2NoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoXG4gIFtAQGlubGluZSBhbHdheXNdXG47O1xuXG5sZXQgZ2V0X3Bvc19sZW5fZXhuID8ocG9zID0gMCkgP2xlbiAoKSB+dG90YWxfbGVuZ3RoID1cbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IFNvbWUgaSAtPiBpXG4gICAgfCBOb25lIC0+IHRvdGFsX2xlbmd0aCAtIHBvc1xuICBpblxuICBjaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDtcbiAgcG9zLCBsZW5cbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBzbG93X2NoZWNrX3Bvc19sZW5fZXhuID0gc2xvd19jaGVja19wb3NfbGVuX2V4blxuZW5kXG4iLCJcbnR5cGUgdCA9IFN0ZGxpYi5SYW5kb20uU3RhdGUudCBTdGRsaWIuRG9tYWluLkRMUy5rZXlcblxubW9kdWxlIFJlcHIgPSBzdHJ1Y3RcbiAgb3BlbiBTdGRsaWIuQmlnYXJyYXlcblxuICB0eXBlIHQgPSAoaW50NjQsIGludDY0X2VsdCwgY19sYXlvdXQpIEFycmF5MS50XG5cbiAgbGV0IG9mX3N0YXRlIDogU3RkbGliLlJhbmRvbS5TdGF0ZS50IC0+IHQgPSBTdGRsaWIuT2JqLm1hZ2ljXG5lbmRcblxubGV0IGFzc2lnbiB0IHN0YXRlID1cbiAgbGV0IGRzdCA9IFJlcHIub2Zfc3RhdGUgKFN0ZGxpYi5Eb21haW4uRExTLmdldCB0KSBpblxuICBsZXQgc3JjID0gUmVwci5vZl9zdGF0ZSBzdGF0ZSBpblxuICBTdGRsaWIuQmlnYXJyYXkuQXJyYXkxLmJsaXQgc3JjIGRzdFxuOztcblxubGV0IG1ha2Ugc3RhdGUgPVxuICBsZXQgc3BsaXRfZnJvbV9wYXJlbnQgdiA9IFN0ZGxpYi5SYW5kb20uU3RhdGUuc3BsaXQgdiBpblxuICBsZXQgdCA9IFN0ZGxpYi5Eb21haW4uRExTLm5ld19rZXkgfnNwbGl0X2Zyb21fcGFyZW50IChmdW4gKCkgLT4gc3RhdGUpIGluXG4gIFN0ZGxpYi5Eb21haW4uRExTLmdldCB0IHw+IGlnbm9yZTtcbiAgdFxuOztcblxubGV0IG1ha2VfbGF6eSB+ZiA9XG4gIGxldCBzcGxpdF9mcm9tX3BhcmVudCB2ID0gU3RkbGliLlJhbmRvbS5TdGF0ZS5zcGxpdCB2IGluXG4gIFN0ZGxpYi5Eb21haW4uRExTLm5ld19rZXkgfnNwbGl0X2Zyb21fcGFyZW50IGZcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gZ2V0X3N0YXRlIHQgPSBTdGRsaWIuRG9tYWluLkRMUy5nZXQgdFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIENoYXIgPSBDaGFyMFxuXG4oKiBVbmZvcnR1bmF0ZWx5LCBiZWNhdXNlIHRoZSBzdGFuZGFyZCBsaWJyYXJ5IGRvZXMgbm90IGV4cG9zZVxuICAgW1N0ZGxpYi5SYW5kb20uU3RhdGUuZGVmYXVsdF0sIHdlIGhhdmUgdG8gY29uc3RydWN0IG91ciBvd24uICBXZSB0aGVuIGJ1aWxkIHRoZVxuICAgW1N0ZGxpYi5SYW5kb20uaW50XSwgW1N0ZGxpYi5SYW5kb20uYm9vbF0gZnVuY3Rpb25zIGFuZCBmcmllbmRzIHVzaW5nIHRoYXQgZGVmYXVsdCBzdGF0ZSBpblxuICAgZXhhY3RseSB0aGUgc2FtZSB3YXkgYXMgdGhlIHN0YW5kYXJkIGxpYnJhcnkuICopXG5cbigqIFJlZ3Jlc3Npb24gdGVzdHMgb3VnaHQgdG8gYmUgZGV0ZXJtaW5pc3RpYyBiZWNhdXNlIHRoYXQgd2F5IGFueW9uZSB3aG8gYnJlYWtzIHRoZSB0ZXN0XG4gICBrbm93cyB0aGF0IGl0J3MgdGhlaXIgY29kZSB0aGF0IGJyb2tlIHRoZSB0ZXN0LiAgSWYgdGVzdHMgYXJlIG5vbmRldGVybWluaXN0aWMsIGEgdGVzdFxuICAgZmFpbHVyZSBtYXkgaW5zdGVhZCBoYXBwZW4gYmVjYXVzZSB0aGUgdGVzdCBydW5uZXIgZ290IHVubHVja3kgYW5kIHVuY292ZXJlZCBhblxuICAgZXhpc3RpbmcgYnVnIGluIHRoZSBjb2RlIHN1cHBvc2VkbHkgYmVpbmcgXCJwcm90ZWN0ZWRcIiBieSB0aGUgdGVzdCBpbiBxdWVzdGlvbi4gKilcbmxldCBmb3JiaWRfbm9uZGV0ZXJtaW5pc21faW5fdGVzdHMgfmFsbG93X2luX3Rlc3RzID1cbiAgaWYgYW1fdGVzdGluZ1xuICB0aGVuIChcbiAgICBtYXRjaCBhbGxvd19pbl90ZXN0cyB3aXRoXG4gICAgfCBTb21lIHRydWUgLT4gKClcbiAgICB8IE5vbmUgfCBTb21lIGZhbHNlIC0+XG4gICAgICBmYWlsd2l0aFxuICAgICAgICBcImluaXRpYWxpemluZyBSYW5kb20gd2l0aCBhIG5vbmRldGVybWluaXN0aWMgc2VlZCBpcyBmb3JiaWRkZW4gaW4gaW5saW5lIHRlc3RzXCIpXG47O1xuXG5leHRlcm5hbCByYW5kb21fc2VlZCA6IHVuaXQgLT4gaW50IGFycmF5ID0gXCJjYW1sX3N5c19yYW5kb21fc2VlZFwiXG5cbmxldCByYW5kb21fc2VlZCA/YWxsb3dfaW5fdGVzdHMgKCkgPVxuICBmb3JiaWRfbm9uZGV0ZXJtaW5pc21faW5fdGVzdHMgfmFsbG93X2luX3Rlc3RzO1xuICByYW5kb21fc2VlZCAoKVxuOztcblxubW9kdWxlIFJlcHIgPSBSYW5kb21fcmVwclxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gUmVwci50XG5cbiAgbGV0IGJpdHMgdCA9IFN0ZGxpYi5SYW5kb20uU3RhdGUuYml0cyAoUmVwci5nZXRfc3RhdGUgdClcbiAgbGV0IGJpdHM2NCB0ID0gU3RkbGliLlJhbmRvbS5TdGF0ZS5iaXRzNjQgKFJlcHIuZ2V0X3N0YXRlIHQpXG4gIGxldCBib29sIHQgPSBTdGRsaWIuUmFuZG9tLlN0YXRlLmJvb2wgKFJlcHIuZ2V0X3N0YXRlIHQpXG4gIGxldCBpbnQgdCB4ID0gU3RkbGliLlJhbmRvbS5TdGF0ZS5pbnQgKFJlcHIuZ2V0X3N0YXRlIHQpIHhcbiAgbGV0IGludDMyIHQgeCA9IFN0ZGxpYi5SYW5kb20uU3RhdGUuaW50MzIgKFJlcHIuZ2V0X3N0YXRlIHQpIHhcbiAgbGV0IGludDY0IHQgeCA9IFN0ZGxpYi5SYW5kb20uU3RhdGUuaW50NjQgKFJlcHIuZ2V0X3N0YXRlIHQpIHhcbiAgbGV0IG5hdGl2ZWludCB0IHggPSBTdGRsaWIuUmFuZG9tLlN0YXRlLm5hdGl2ZWludCAoUmVwci5nZXRfc3RhdGUgdCkgeFxuICBsZXQgbWFrZSBzZWVkID0gUmVwci5tYWtlIChTdGRsaWIuUmFuZG9tLlN0YXRlLm1ha2Ugc2VlZClcbiAgbGV0IGNvcHkgdCA9IFJlcHIubWFrZSAoU3RkbGliLlJhbmRvbS5TdGF0ZS5jb3B5IChSZXByLmdldF9zdGF0ZSB0KSlcbiAgbGV0IGNoYXIgdCA9IGludCB0IDI1NiB8PiBDaGFyLnVuc2FmZV9vZl9pbnRcbiAgbGV0IGFzY2lpIHQgPSBpbnQgdCAxMjggfD4gQ2hhci51bnNhZmVfb2ZfaW50XG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ID9hbGxvd19pbl90ZXN0cyAoKSA9XG4gICAgZm9yYmlkX25vbmRldGVybWluaXNtX2luX3Rlc3RzIH5hbGxvd19pbl90ZXN0cztcbiAgICBSZXByLm1ha2VfbGF6eSB+ZjpTdGRsaWIuUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0XG4gIDs7XG5cbiAgbGV0IGFzc2lnbiA9IFJlcHIuYXNzaWduXG4gIGxldCBmdWxsX2luaXQgdCBzZWVkID0gYXNzaWduIHQgKFN0ZGxpYi5SYW5kb20uU3RhdGUubWFrZSBzZWVkKVxuXG4gIGxldCBkZWZhdWx0ID1cbiAgICBpZiBhbV90ZXN0aW5nXG4gICAgdGhlbiAoXG4gICAgICAoKiBXZSBkZWZpbmUgQmFzZSdzIGRlZmF1bHQgcmFuZG9tIHN0YXRlIGFzIGEgY29weSBvZiBPQ2FtbCdzIGRlZmF1bHQgcmFuZG9tIHN0YXRlLlxuICAgICAgICAgVGhpcyBtZWFucyB0aGF0IHByb2dyYW1zIHRoYXQgdXNlIEJhc2UuUmFuZG9tIHdpbGwgc2VlIHRoZSBzYW1lIHNlcXVlbmNlIG9mXG4gICAgICAgICByYW5kb20gYml0cyBhcyBpZiB0aGV5IGhhZCB1c2VkIFN0ZGxpYi5SYW5kb20uIEhvd2V2ZXIsIGJlY2F1c2UgW2dldF9zdGF0ZV0gcmV0dXJuc1xuICAgICAgICAgYSBjb3B5LCBCYXNlLlJhbmRvbSBhbmQgT0NhbWwuUmFuZG9tIGFyZSBub3QgdXNpbmcgdGhlIHNhbWUgc3RhdGUuIElmIGEgcHJvZ3JhbVxuICAgICAgICAgdXNlZCBib3RoLCBlYWNoIG9mIHRoZW0gd291bGQgZ28gdGhyb3VnaCB0aGUgc2FtZSBzZXF1ZW5jZSBvZiByYW5kb20gYml0cy4gVG9cbiAgICAgICAgIGF2b2lkIHRoYXQsIHdlIHJlc2V0IE9DYW1sJ3MgcmFuZG9tIHN0YXRlIHRvIGEgZGlmZmVyZW50IHNlZWQsIGdpdmluZyBpdCBhXG4gICAgICAgICBkaWZmZXJlbnQgc2VxdWVuY2UuICopXG4gICAgICBsZXQgdCA9IFN0ZGxpYi5SYW5kb20uZ2V0X3N0YXRlICgpIGluXG4gICAgICBTdGRsaWIuUmFuZG9tLmluaXQgMTM3O1xuICAgICAgUmVwci5tYWtlIHQpXG4gICAgZWxzZVxuICAgICAgKCogT3V0c2lkZSBvZiB0ZXN0cywgd2UgaW5pdGlhbGl6ZSByYW5kb20gc3RhdGUgbm9uZGV0ZXJtaW5pc3RpY2FsbHkgYW5kIGxhemlseS5cbiAgICAgICAgIFdlIGZvcmNlIHRoZSByYW5kb20gaW5pdGlhbGl6YXRpb24gdG8gYmUgbGF6eSBzbyB0aGF0IHdlIGRvIG5vdCBwYXkgYW55IGNvc3RcbiAgICAgICAgIGZvciBpdCBpbiBwcm9ncmFtcyB0aGF0IGRvIG5vdCB1c2UgcmFuZG9tbmVzcy4gKilcbiAgICAgIG1ha2Vfc2VsZl9pbml0ICgpXG4gIDs7XG5cbiAgbGV0IGludF9vbl82NGJpdHMgdCBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMHgzRkZGRkZGRiAoKiAoMSBsc2wgMzApIC0gMSAqKVxuICAgIHRoZW4gaW50IHQgYm91bmRcbiAgICBlbHNlIFN0ZGxpYi5JbnQ2NC50b19pbnQgKGludDY0IHQgKFN0ZGxpYi5JbnQ2NC5vZl9pbnQgYm91bmQpKVxuICA7O1xuXG4gIGxldCBpbnRfb25fMzJiaXRzIHQgYm91bmQgPVxuICAgICgqIE5vdCBhbHdheXMgdHJ1ZSB3aXRoIHRoZSBKYXZhU2NyaXB0IGJhY2tlbmQuICopXG4gICAgaWYgYm91bmQgPD0gMHgzRkZGRkZGRiAoKiAoMSBsc2wgMzApIC0gMSAqKVxuICAgIHRoZW4gaW50IHQgYm91bmRcbiAgICBlbHNlIFN0ZGxpYi5JbnQzMi50b19pbnQgKGludDMyIHQgKFN0ZGxpYi5JbnQzMi5vZl9pbnQgYm91bmQpKVxuICA7O1xuXG4gIGxldCBpbnQgPVxuICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgIHwgVzY0IC0+IGludF9vbl82NGJpdHNcbiAgICB8IFczMiAtPiBpbnRfb25fMzJiaXRzXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfaW50NjQgPVxuICAgIGxldCBvcGVuIFN0ZGxpYi5JbnQ2NCBpblxuICAgIGxldCBiaXRzIHN0YXRlID0gb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGZ1biBzdGF0ZSAtPlxuICAgICAgbG9neG9yXG4gICAgICAgIChiaXRzIHN0YXRlKVxuICAgICAgICAobG9neG9yIChzaGlmdF9sZWZ0IChiaXRzIHN0YXRlKSAzMCkgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDYwKSlcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9pbnQzMiA9XG4gICAgbGV0IG9wZW4gU3RkbGliLkludDMyIGluXG4gICAgbGV0IGJpdHMgc3RhdGUgPSBvZl9pbnQgKGJpdHMgc3RhdGUpIGluXG4gICAgZnVuIHN0YXRlIC0+IGxvZ3hvciAoYml0cyBzdGF0ZSkgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDMwKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX2ludF9vbl82NGJpdHMgc3RhdGUgPSBTdGRsaWIuSW50NjQudG9faW50IChmdWxsX3JhbmdlX2ludDY0IHN0YXRlKVxuICBsZXQgZnVsbF9yYW5nZV9pbnRfb25fMzJiaXRzIHN0YXRlID0gU3RkbGliLkludDMyLnRvX2ludCAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSlcblxuICBsZXQgZnVsbF9yYW5nZV9pbnQgPVxuICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgIHwgVzY0IC0+IGZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0c1xuICAgIHwgVzMyIC0+IGZ1bGxfcmFuZ2VfaW50X29uXzMyYml0c1xuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl82NGJpdHMgc3RhdGUgPVxuICAgIFN0ZGxpYi5JbnQ2NC50b19uYXRpdmVpbnQgKGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUpXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzMyYml0cyBzdGF0ZSA9XG4gICAgU3RkbGliLk5hdGl2ZWludC5vZl9pbnQzMiAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSlcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9uYXRpdmVpbnQgPVxuICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgIHwgVzY0IC0+IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzY0Yml0c1xuICAgIHwgVzMyIC0+IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzMyYml0c1xuICA7O1xuXG4gIGxldCByYWlzZV9jcm9zc2VkX2JvdW5kcyBuYW1lIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kIHN0cmluZ19vZl9ib3VuZCA9XG4gICAgUHJpbnRmLmZhaWx3aXRoZlxuICAgICAgXCJSYW5kb20uJXM6IGNyb3NzZWQgYm91bmRzIFslcyA+ICVzXVwiXG4gICAgICBuYW1lXG4gICAgICAoc3RyaW5nX29mX2JvdW5kIGxvd2VyX2JvdW5kKVxuICAgICAgKHN0cmluZ19vZl9ib3VuZCB1cHBlcl9ib3VuZClcbiAgICAgICgpXG4gICAgW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbiAgOztcblxuICBsZXQgaW50X2luY2wgPVxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfaW50IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGZ1biBzdGF0ZSBsbyBoaSAtPlxuICAgICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiaW50XCIgbG8gaGkgSW50LnRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gaGkgLSBsbyBpblxuICAgICAgaWYgZGlmZiA9IEludC5tYXhfdmFsdWVcbiAgICAgIHRoZW4gbG8gKyAoZnVsbF9yYW5nZV9pbnQgc3RhdGUgbGFuZCBJbnQubWF4X3ZhbHVlKVxuICAgICAgZWxzZSBpZiBkaWZmID49IDBcbiAgICAgIHRoZW4gbG8gKyBpbnQgc3RhdGUgKEludC5zdWNjIGRpZmYpXG4gICAgICBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gIDs7XG5cbiAgbGV0IGludDMyX2luY2wgPVxuICAgIGxldCBvcGVuIEludDMyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUgaW5cbiAgICAgIGlmIGludCA+PSBsbyAmJiBpbnQgPD0gaGkgdGhlbiBpbnQgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICAgIGluXG4gICAgbGV0IG9wZW4gU3RkbGliLkludDMyIGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJpbnQzMlwiIGxvIGhpIHRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gc3ViIGhpIGxvIGluXG4gICAgICBpZiBkaWZmID0gbWF4X2ludFxuICAgICAgdGhlbiBhZGQgbG8gKGxvZ2FuZCAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSkgbWF4X2ludClcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwbFxuICAgICAgdGhlbiBhZGQgbG8gKGludDMyIHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gIGxldCBuYXRpdmVpbnRfaW5jbCA9XG4gICAgbGV0IG9wZW4gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfbmF0aXZlaW50IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGxldCBvcGVuIFN0ZGxpYi5OYXRpdmVpbnQgaW5cbiAgICBmdW4gc3RhdGUgbG8gaGkgLT5cbiAgICAgIGlmIGxvID4gaGkgdGhlbiByYWlzZV9jcm9zc2VkX2JvdW5kcyBcIm5hdGl2ZWludFwiIGxvIGhpIHRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gc3ViIGhpIGxvIGluXG4gICAgICBpZiBkaWZmID0gbWF4X2ludFxuICAgICAgdGhlbiBhZGQgbG8gKGxvZ2FuZCAoZnVsbF9yYW5nZV9uYXRpdmVpbnQgc3RhdGUpIG1heF9pbnQpXG4gICAgICBlbHNlIGlmIGRpZmYgPj0gMG5cbiAgICAgIHRoZW4gYWRkIGxvIChuYXRpdmVpbnQgc3RhdGUgKHN1Y2MgZGlmZikpXG4gICAgICBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gIDs7XG5cbiAgbGV0IGludDY0X2luY2wgPVxuICAgIGxldCBvcGVuIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUgaW5cbiAgICAgIGlmIGludCA+PSBsbyAmJiBpbnQgPD0gaGkgdGhlbiBpbnQgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICAgIGluXG4gICAgbGV0IG9wZW4gU3RkbGliLkludDY0IGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJpbnQ2NFwiIGxvIGhpIHRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gc3ViIGhpIGxvIGluXG4gICAgICBpZiBkaWZmID0gbWF4X2ludFxuICAgICAgdGhlbiBhZGQgbG8gKGxvZ2FuZCAoZnVsbF9yYW5nZV9pbnQ2NCBzdGF0ZSkgbWF4X2ludClcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwTFxuICAgICAgdGhlbiBhZGQgbG8gKGludDY0IHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gICgqIFJldHVybiBhIHVuaWZvcm1seSByYW5kb20gZmxvYXQgaW4gWzAsIDEpLiAqKVxuICBsZXQgcmVjIHJhd2Zsb2F0IHN0YXRlID1cbiAgICBsZXQgb3BlbiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgc2NhbGUgPSAweDFwLTMwIGluXG4gICAgKCogMl4tMzAgKilcbiAgICBsZXQgcjEgPSBTdGRsaWIuZmxvYXRfb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGxldCByMiA9IFN0ZGxpYi5mbG9hdF9vZl9pbnQgKGJpdHMgc3RhdGUpIGluXG4gICAgbGV0IHJlc3VsdCA9ICgocjEgKi4gc2NhbGUpICsuIHIyKSAqLiBzY2FsZSBpblxuICAgICgqIFdpdGggdmVyeSBzbWFsbCBwcm9iYWJpbGl0eSwgcmVzdWx0IGNhbiByb3VuZCB1cCB0byAxLjAsIHNvIGluIHRoYXQgY2FzZSwgd2UganVzdFxuICAgICAgIHRyeSBhZ2Fpbi4gKilcbiAgICBpZiByZXN1bHQgPCAxLjAgdGhlbiByZXN1bHQgZWxzZSByYXdmbG9hdCBzdGF0ZVxuICA7O1xuXG4gIGxldCBmbG9hdCBzdGF0ZSBoaSA9IHJhd2Zsb2F0IHN0YXRlICouIGhpXG5cbiAgbGV0IGZsb2F0X3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICBsZXQgb3BlbiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJmbG9hdFwiIGxvIGhpIFN0ZGxpYi5zdHJpbmdfb2ZfZmxvYXQ7XG4gICAgbG8gKy4gZmxvYXQgc3RhdGUgKGhpIC0uIGxvKVxuICA7O1xuZW5kXG5cbmxldCBkZWZhdWx0ID0gU3RhdGUuZGVmYXVsdFxubGV0IGJpdHMgKCkgPSBTdGF0ZS5iaXRzIGRlZmF1bHRcbmxldCBiaXRzNjQgKCkgPSBTdGF0ZS5iaXRzNjQgZGVmYXVsdFxubGV0IGludCB4ID0gU3RhdGUuaW50IGRlZmF1bHQgeFxubGV0IGludDMyIHggPSBTdGF0ZS5pbnQzMiBkZWZhdWx0IHhcbmxldCBuYXRpdmVpbnQgeCA9IFN0YXRlLm5hdGl2ZWludCBkZWZhdWx0IHhcbmxldCBpbnQ2NCB4ID0gU3RhdGUuaW50NjQgZGVmYXVsdCB4XG5sZXQgZmxvYXQgeCA9IFN0YXRlLmZsb2F0IGRlZmF1bHQgeFxubGV0IGludF9pbmNsIHggeSA9IFN0YXRlLmludF9pbmNsIGRlZmF1bHQgeCB5XG5sZXQgaW50MzJfaW5jbCB4IHkgPSBTdGF0ZS5pbnQzMl9pbmNsIGRlZmF1bHQgeCB5XG5sZXQgbmF0aXZlaW50X2luY2wgeCB5ID0gU3RhdGUubmF0aXZlaW50X2luY2wgZGVmYXVsdCB4IHlcbmxldCBpbnQ2NF9pbmNsIHggeSA9IFN0YXRlLmludDY0X2luY2wgZGVmYXVsdCB4IHlcbmxldCBmbG9hdF9yYW5nZSB4IHkgPSBTdGF0ZS5mbG9hdF9yYW5nZSBkZWZhdWx0IHggeVxubGV0IGJvb2wgKCkgPSBTdGF0ZS5ib29sIGRlZmF1bHRcbmxldCBjaGFyICgpID0gU3RhdGUuY2hhciBkZWZhdWx0XG5sZXQgYXNjaWkgKCkgPSBTdGF0ZS5hc2NpaSBkZWZhdWx0XG5sZXQgZnVsbF9pbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBzZWVkXG5sZXQgaW5pdCBzZWVkID0gZnVsbF9pbml0IFt8IHNlZWQgfF1cbmxldCBzZWxmX2luaXQgP2FsbG93X2luX3Rlc3RzICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCA/YWxsb3dfaW5fdGVzdHMgKCkpXG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gZGVmYXVsdCAoUmVwci5nZXRfc3RhdGUgcylcbiIsIigqKiBBbiBpbnRlcm5hbC1vbmx5IG1vZHVsZSBmYWN0b3JlZCBvdXQgZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIGNvcmVfYXJyYXlcbiAgICBhbmQgY29yZV9saXN0LiAgQ29udGFpbnMgY29kZSBmb3IgcGVybXV0aW5nIGFuIGFycmF5LiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgQXJyYXkwXG5cbmxldCBwZXJtdXRlID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpID8ocG9zID0gMCkgP2xlbiB0ID1cbiAgKCogQ29waWVkIGZyb20gW09yZGVyZWRfY29sbGVjdGlvbl9jb21tb24wXSB0byBhdm9pZCBhbGxvY2F0aW5nIGEgdHVwbGUgd2hlbiBjb21waWxpbmdcbiAgICAgd2l0aG91dCBmbGFtYmRhLiAqKVxuICBsZXQgdG90YWxfbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IFNvbWUgbCAtPiBsXG4gICAgfCBOb25lIC0+IHRvdGFsX2xlbmd0aCAtIHBvc1xuICBpblxuICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMC5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDtcbiAgbGV0IG51bV9zd2FwcyA9IGxlbiAtIDEgaW5cbiAgZm9yIGkgPSBudW1fc3dhcHMgZG93bnRvIDEgZG9cbiAgICBsZXQgdGhpc19pID0gcG9zICsgaSBpblxuICAgICgqIFtyYW5kb21faV0gaXMgZHJhd24gZnJvbSBbcG9zLHRoaXNfaV0gKilcbiAgICBsZXQgcmFuZG9tX2kgPSBwb3MgKyBSYW5kb20uU3RhdGUuaW50IHJhbmRvbV9zdGF0ZSAoaSArIDEpIGluXG4gICAgc3dhcCB0IHRoaXNfaSByYW5kb21faVxuICBkb25lXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9XG4gIHwgTGVzc1xuICB8IEVxdWFsXG4gIHwgR3JlYXRlclxuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBoYXNoLCBlbnVtZXJhdGUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IGNvbXBhcmVfX2xvY2FsID0gKFN0ZGxpYi5jb21wYXJlIDogdCAtPiB0IC0+IGludClcbmxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxubGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50XG4gICAgICAgaHN2XG4gICAgICAgKG1hdGNoIGFyZyB3aXRoXG4gICAgICAgIHwgTGVzcyAtPiAwXG4gICAgICAgIHwgRXF1YWwgLT4gMVxuICAgICAgICB8IEdyZWF0ZXIgLT4gMilcbiAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbjs7XG5cbmxldCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgbGV0IGZ1bmMgYXJnID1cbiAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gIGluXG4gIGZ1biB4IC0+IGZ1bmMgeFxuOztcblxubGV0IGFsbCA9IChbIExlc3M7IEVxdWFsOyBHcmVhdGVyIF0gOiB0IGxpc3QpXG5cbmxldCB0X29mX3NleHAgPVxuICAobGV0IGVycm9yX3NvdXJjZV9fMDA1XyA9IFwib3JkZXJpbmcubWwudFwiIGluXG4gICBmdW5jdGlvblxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibGVzc1wiIHwgXCJMZXNzXCIpIC0+IExlc3NcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImVxdWFsXCIgfCBcIkVxdWFsXCIpIC0+IEVxdWFsXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJncmVhdGVyXCIgfCBcIkdyZWF0ZXJcIikgLT4gR3JlYXRlclxuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJsZXNzXCIgfCBcIkxlc3NcIikgOjogXykgYXMgc2V4cF9fMDA2XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImVxdWFsXCIgfCBcIkVxdWFsXCIpIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJncmVhdGVyXCIgfCBcIkdyZWF0ZXJcIikgOjogXykgYXMgc2V4cF9fMDA2XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbiAgIHwgc2V4cF9fMDA0XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbjs7XG5cbmxldCBzZXhwX29mX3QgPVxuICAoZnVuY3Rpb25cbiAgIHwgTGVzcyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJMZXNzXCJcbiAgIHwgRXF1YWwgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXF1YWxcIlxuICAgfCBHcmVhdGVyIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkdyZWF0ZXJcIlxuICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG47O1xuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIkxlc3NcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIkVxdWFsXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJHcmVhdGVyXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbltAQEBlbmRdXG5cbmxldCBlcXVhbCBhIGIgPSBjb21wYXJlIGEgYiA9IDBcbmxldCBlcXVhbF9fbG9jYWwgYSBiID0gY29tcGFyZV9fbG9jYWwgYSBiID0gMFxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gIHR5cGUgX29yZGVyaW5nID0gdCA9XG4gICAgfCBMZXNzXG4gICAgfCBFcXVhbFxuICAgIHwgR3JlYXRlclxuZW5kXG5cbmxldCBvZl9pbnQgbiA9IGlmIG4gPCAwIHRoZW4gTGVzcyBlbHNlIGlmIG4gPSAwIHRoZW4gRXF1YWwgZWxzZSBHcmVhdGVyXG5cbmxldCB0b19pbnQgPSBmdW5jdGlvblxuICB8IExlc3MgLT4gLTFcbiAgfCBFcXVhbCAtPiAwXG4gIHwgR3JlYXRlciAtPiAxXG47O1xuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBFaXRoZXIgPSBFaXRoZXIwXG5pbmNsdWRlIExpc3QxXG5cbigqIFRoaXMgaXRzZWxmIGluY2x1ZGVzIFtMaXN0MF0uICopXG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIGxpc3QgW0BAZGVyaXZpbmdfaW5saW5lIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBnbG9iYWxpemUgOiAnYS4gKCdhIC0+ICdhKSAtPiAnYSB0IC0+ICdhIHQgPVxuICAgIGZ1biAodHlwZSBhX18wMDFfKSA6ICgoYV9fMDAxXyAtPiBhX18wMDFfKSAtPiBhX18wMDFfIHQgLT4gYV9fMDAxXyB0KSAtPlxuICAgIGdsb2JhbGl6ZV9saXN0XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IGxpc3Rfb2Zfc2V4cFxuICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID0gc2V4cF9vZl9saXN0XG5cbiAgbGV0IHRfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGxpc3Rfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBPcl91bmVxdWFsX2xlbmd0aHMgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IE9rIG9mICdhXG4gICAgfCBVbmVxdWFsX2xlbmd0aHNcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID1cbiAgICBmdW4gX2NtcF9fYSBhX18wMTRfIGJfXzAxNV8gLT5cbiAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAxNF8gYl9fMDE1X1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDE0XywgYl9fMDE1XyB3aXRoXG4gICAgICB8IE9rIF9hX18wMTZfLCBPayBfYl9fMDE3XyAtPiBfY21wX19hIF9hX18wMTZfIF9iX18wMTdfXG4gICAgICB8IE9rIF8sIF8gLT4gLTFcbiAgICAgIHwgXywgT2sgXyAtPiAxXG4gICAgICB8IFVuZXF1YWxfbGVuZ3RocywgVW5lcXVhbF9sZW5ndGhzIC0+IDApXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9XG4gICAgZnVuIF9jbXBfX2EgYV9fMDEwXyBiX18wMTFfIC0+XG4gICAgaWYgU3RkbGliLiggPT0gKSBhX18wMTBfIGJfXzAxMV9cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzAxMF8sIGJfXzAxMV8gd2l0aFxuICAgICAgfCBPayBfYV9fMDEyXywgT2sgX2JfXzAxM18gLT4gX2NtcF9fYSBfYV9fMDEyXyBfYl9fMDEzX1xuICAgICAgfCBPayBfLCBfIC0+IC0xXG4gICAgICB8IF8sIE9rIF8gLT4gMVxuICAgICAgfCBVbmVxdWFsX2xlbmd0aHMsIFVuZXF1YWxfbGVuZ3RocyAtPiAwKVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIGZ1biAodHlwZSBhX18wMjFfKSA6ICgoYV9fMDIxXyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IGFfXzAyMV8gdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgZnVuIF9vZl9hX18wMThfIC0+IGZ1bmN0aW9uXG4gICAgfCBPayBhcmcwX18wMTlfIC0+XG4gICAgICBsZXQgcmVzMF9fMDIwXyA9IF9vZl9hX18wMThfIGFyZzBfXzAxOV8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIk9rXCI7IHJlczBfXzAyMF8gXVxuICAgIHwgVW5lcXVhbF9sZW5ndGhzIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlVuZXF1YWxfbGVuZ3Roc1wiXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IGludmFyaWFudCBmIHQgPSBpdGVyIHQgfmZcbmxldCBvZl9saXN0IHQgPSB0XG5sZXQgc2luZ2xldG9uIHggPSBbIHggXVxuXG5sZXQgcmFuZ2UnIH5jb21wYXJlIH5zdHJpZGUgPyhzdGFydCA9IGBpbmNsdXNpdmUpID8oc3RvcCA9IGBleGNsdXNpdmUpIHN0YXJ0X2kgc3RvcF9pID1cbiAgbGV0IG5leHRfaSA9IHN0cmlkZSBzdGFydF9pIGluXG4gIGxldCBvcmRlciB4IHkgPSBPcmRlcmluZy5vZl9pbnQgKGNvbXBhcmUgeCB5KSBpblxuICBsZXQgcmFpc2Vfc3RyaWRlX2Nhbm5vdF9yZXR1cm5fc2FtZV92YWx1ZSAoKSA9XG4gICAgaW52YWxpZF9hcmcgXCJMaXN0LnJhbmdlJzogc3RyaWRlIGZ1bmN0aW9uIGNhbm5vdCByZXR1cm4gdGhlIHNhbWUgdmFsdWVcIlxuICBpblxuICBsZXQgaW5pdGlhbF9zdHJpZGVfb3JkZXIgPVxuICAgIG1hdGNoIG9yZGVyIHN0YXJ0X2kgbmV4dF9pIHdpdGhcbiAgICB8IEVxdWFsIC0+IHJhaXNlX3N0cmlkZV9jYW5ub3RfcmV0dXJuX3NhbWVfdmFsdWUgKClcbiAgICB8IExlc3MgLT4gYExlc3NcbiAgICB8IEdyZWF0ZXIgLT4gYEdyZWF0ZXJcbiAgaW5cbiAgbGV0W0B0YWlsX21vZF9jb25zXSByZWMgbG9vcCBpID1cbiAgICBsZXQgaV90b19zdG9wX29yZGVyID0gb3JkZXIgaSBzdG9wX2kgaW5cbiAgICBtYXRjaCBpX3RvX3N0b3Bfb3JkZXIsIGluaXRpYWxfc3RyaWRlX29yZGVyIHdpdGhcbiAgICB8IExlc3MsIGBMZXNzIHwgR3JlYXRlciwgYEdyZWF0ZXIgLT5cbiAgICAgICgqIGhhdmVuJ3QgeWV0IHJlYWNoZWQgW3N0b3BfaV0uIENvbnRpbnVlLiAqKVxuICAgICAgbGV0IG5leHRfaSA9IHN0cmlkZSBpIGluXG4gICAgICAobWF0Y2ggb3JkZXIgaSBuZXh0X2ksIGluaXRpYWxfc3RyaWRlX29yZGVyIHdpdGhcbiAgICAgICB8IEVxdWFsLCBfIC0+IChyYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW1lX3ZhbHVlIFtAdGFpbGNhbGwgZmFsc2VdKSAoKVxuICAgICAgIHwgTGVzcywgYEdyZWF0ZXIgfCBHcmVhdGVyLCBgTGVzcyAtPlxuICAgICAgICAgaW52YWxpZF9hcmcgXCJMaXN0LnJhbmdlJzogc3RyaWRlIGZ1bmN0aW9uIGNhbm5vdCBjaGFuZ2UgZGlyZWN0aW9uXCJcbiAgICAgICB8IExlc3MsIGBMZXNzIHwgR3JlYXRlciwgYEdyZWF0ZXIgLT4gaSA6OiBsb29wIG5leHRfaSlcbiAgICB8IExlc3MsIGBHcmVhdGVyIHwgR3JlYXRlciwgYExlc3MgLT5cbiAgICAgICgqIHN0ZXBwZWQgcGFzdCBbc3RvcF9pXS4gIEZpbmlzaGVkLiAqKVxuICAgICAgW11cbiAgICB8IEVxdWFsLCBfIC0+XG4gICAgICAoKiByZWFjaGVkIFtzdG9wX2ldLiAgRmluaXNoZWQuICopXG4gICAgICAobWF0Y2ggc3RvcCB3aXRoXG4gICAgICAgfCBgaW5jbHVzaXZlIC0+IFsgaSBdXG4gICAgICAgfCBgZXhjbHVzaXZlIC0+IFtdKVxuICBpblxuICBsZXQgc3RhcnRfaSA9XG4gICAgbWF0Y2ggc3RhcnQgd2l0aFxuICAgIHwgYGluY2x1c2l2ZSAtPiBzdGFydF9pXG4gICAgfCBgZXhjbHVzaXZlIC0+IG5leHRfaVxuICBpblxuICBsb29wIHN0YXJ0X2kgW0Bub250YWlsXVxuOztcblxubGV0IHJhbmdlID8oc3RyaWRlID0gMSkgPyhzdGFydCA9IGBpbmNsdXNpdmUpID8oc3RvcCA9IGBleGNsdXNpdmUpIHN0YXJ0X2kgc3RvcF9pID1cbiAgaWYgc3RyaWRlID0gMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5yYW5nZTogc3RyaWRlIG11c3QgYmUgbm9uLXplcm9cIjtcbiAgcmFuZ2UnIH5jb21wYXJlIH5zdHJpZGU6KGZ1biB4IC0+IHggKyBzdHJpZGUpIH5zdGFydCB+c3RvcCBzdGFydF9pIHN0b3BfaVxuOztcblxubGV0IGhkIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBfIC0+IFNvbWUgeFxuOztcblxubGV0IHRsIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgXyA6OiB0JyAtPiBTb21lIHQnXG47O1xuXG5sZXQgbnRoIHQgbiA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgcmVjIG50aF9hdXggdCBuID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiBOb25lXG4gICAgICB8IGEgOjogdCAtPiBpZiBuID0gMCB0aGVuIFNvbWUgYSBlbHNlIG50aF9hdXggdCAobiAtIDEpXG4gICAgaW5cbiAgICBudGhfYXV4IHQgbilcbjs7XG5cbmxldCBudGhfZXhuIHQgbiA9XG4gIG1hdGNoIG50aCB0IG4gd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmdmIFwiTGlzdC5udGhfZXhuICVkIGNhbGxlZCBvbiBsaXN0IG9mIGxlbmd0aCAlZFwiIG4gKGxlbmd0aCB0KSAoKVxuICB8IFNvbWUgYSAtPiBhXG47O1xuXG5sZXQgdW5vcmRlcmVkX2FwcGVuZCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIGwgfCBsLCBbXSAtPiBsXG4gIHwgXyAtPiByZXZfYXBwZW5kIGwxIGwyXG47O1xuXG5tb2R1bGUgQ2hlY2tfbGVuZ3RoMiA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgIHwgU2FtZV9sZW5ndGggb2YgaW50XG4gICAgfCBVbmVxdWFsX2xlbmd0aHMgb2ZcbiAgICAgICAgeyBzaGFyZWRfbGVuZ3RoIDogaW50XG4gICAgICAgIDsgdGFpbF9vZl9hIDogJ2EgbGlzdFxuICAgICAgICA7IHRhaWxfb2ZfYiA6ICdiIGxpc3RcbiAgICAgICAgfVxuXG4gICgqIEluIHRoZSBbVW5lcXVhbF9sZW5ndGhzXSBjYXNlLCBhdCBsZWFzdCBvbmUgb2YgdGhlIHRhaWxzIHdpbGwgYmUgbm9uLWVtcHR5LiAqKVxuICBsZXQgb2ZfbGlzdHMgbDEgbDIgPVxuICAgIGxldCByZWMgbG9vcCBhIGIgc2hhcmVkX2xlbmd0aCA9XG4gICAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICAgIHwgW10sIFtdIC0+IFNhbWVfbGVuZ3RoIHNoYXJlZF9sZW5ndGhcbiAgICAgIHwgXyA6OiBhLCBfIDo6IGIgLT4gbG9vcCBhIGIgKHNoYXJlZF9sZW5ndGggKyAxKVxuICAgICAgfCBbXSwgXyB8IF8sIFtdIC0+IFVuZXF1YWxfbGVuZ3RocyB7IHNoYXJlZF9sZW5ndGg7IHRhaWxfb2ZfYSA9IGE7IHRhaWxfb2ZfYiA9IGIgfVxuICAgIGluXG4gICAgbG9vcCBsMSBsMiAwXG4gIDs7XG5lbmRcblxubGV0IGNoZWNrX2xlbmd0aDJfZXhuIG5hbWUgbDEgbDIgPVxuICBtYXRjaCBDaGVja19sZW5ndGgyLm9mX2xpc3RzIGwxIGwyIHdpdGhcbiAgfCBTYW1lX2xlbmd0aCBfIC0+ICgpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hOyB0YWlsX29mX2IgfSAtPlxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJsZW5ndGggbWlzbWF0Y2ggaW4gJXM6ICVkIDw+ICVkXCJcbiAgICAgIG5hbWVcbiAgICAgIChzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYSlcbiAgICAgIChzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYilcbiAgICAgICgpXG47O1xuXG5sZXQgY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZiA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDIub2ZfbGlzdHMgbDEgbDIgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gT3JfdW5lcXVhbF9sZW5ndGhzLk9rIChmIGwxIGwyKVxuICB8IFVuZXF1YWxfbGVuZ3RocyBfIC0+IFVuZXF1YWxfbGVuZ3Roc1xuOztcblxubW9kdWxlIENoZWNrX2xlbmd0aDMgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9XG4gICAgfCBTYW1lX2xlbmd0aCBvZiBpbnRcbiAgICB8IFVuZXF1YWxfbGVuZ3RocyBvZlxuICAgICAgICB7IHNoYXJlZF9sZW5ndGggOiBpbnRcbiAgICAgICAgOyB0YWlsX29mX2EgOiAnYSBsaXN0XG4gICAgICAgIDsgdGFpbF9vZl9iIDogJ2IgbGlzdFxuICAgICAgICA7IHRhaWxfb2ZfYyA6ICdjIGxpc3RcbiAgICAgICAgfVxuXG4gICgqIEluIHRoZSBbVW5lcXVhbF9sZW5ndGhzXSBjYXNlLCBhdCBsZWFzdCBvbmUgb2YgdGhlIHRhaWxzIHdpbGwgYmUgbm9uLWVtcHR5LiAqKVxuICBsZXQgb2ZfbGlzdHMgbDEgbDIgbDMgPVxuICAgIGxldCByZWMgbG9vcCBhIGIgYyBzaGFyZWRfbGVuZ3RoID1cbiAgICAgIG1hdGNoIGEsIGIsIGMgd2l0aFxuICAgICAgfCBbXSwgW10sIFtdIC0+IFNhbWVfbGVuZ3RoIHNoYXJlZF9sZW5ndGhcbiAgICAgIHwgXyA6OiBhLCBfIDo6IGIsIF8gOjogYyAtPiBsb29wIGEgYiBjIChzaGFyZWRfbGVuZ3RoICsgMSlcbiAgICAgIHwgW10sIF8sIF8gfCBfLCBbXSwgXyB8IF8sIF8sIFtdIC0+XG4gICAgICAgIFVuZXF1YWxfbGVuZ3RocyB7IHNoYXJlZF9sZW5ndGg7IHRhaWxfb2ZfYSA9IGE7IHRhaWxfb2ZfYiA9IGI7IHRhaWxfb2ZfYyA9IGMgfVxuICAgIGluXG4gICAgbG9vcCBsMSBsMiBsMyAwXG4gIDs7XG5lbmRcblxubGV0IGNoZWNrX2xlbmd0aDNfZXhuIG5hbWUgbDEgbDIgbDMgPVxuICBtYXRjaCBDaGVja19sZW5ndGgzLm9mX2xpc3RzIGwxIGwyIGwzIHdpdGhcbiAgfCBTYW1lX2xlbmd0aCBfIC0+ICgpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hOyB0YWlsX29mX2I7IHRhaWxfb2ZfYyB9IC0+XG4gICAgbGV0IG4xID0gc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2EgaW5cbiAgICBsZXQgbjIgPSBzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYiBpblxuICAgIGxldCBuMyA9IHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9jIGluXG4gICAgaW52YWxpZF9hcmdmIFwibGVuZ3RoIG1pc21hdGNoIGluICVzOiAlZCA8PiAlZCB8fCAlZCA8PiAlZFwiIG5hbWUgbjEgbjIgbjIgbjMgKClcbjs7XG5cbmxldCBjaGVja19sZW5ndGgzIGwxIGwyIGwzIH5mID1cbiAgbWF0Y2ggQ2hlY2tfbGVuZ3RoMy5vZl9saXN0cyBsMSBsMiBsMyB3aXRoXG4gIHwgU2FtZV9sZW5ndGggXyAtPiBPcl91bmVxdWFsX2xlbmd0aHMuT2sgKGYgbDEgbDIgbDMpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIF8gLT4gVW5lcXVhbF9sZW5ndGhzXG47O1xuXG5sZXQgaXRlcjIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihpdGVyMl9vayB+ZikgW0Bub250YWlsXVxuXG5sZXQgaXRlcjJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJpdGVyMl9leG5cIiBsMSBsMjtcbiAgaXRlcjJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCByZXZfbWFwMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KHJldl9tYXAyX29rIH5mKSBbQG5vbnRhaWxdXG5cbmxldCByZXZfbWFwMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcInJldl9tYXAyX2V4blwiIGwxIGwyO1xuICByZXZfbWFwMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IGZvbGQyIGwxIGwyIH5pbml0IH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooZm9sZDJfb2sgfmluaXQgfmYpIFtAbm9udGFpbF1cblxubGV0IGZvbGQyX2V4biBsMSBsMiB+aW5pdCB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiZm9sZDJfZXhuXCIgbDEgbDI7XG4gIGZvbGQyX29rIGwxIGwyIH5pbml0IH5mXG47O1xuXG5sZXQgZm9sZF9yaWdodDIgbDEgbDIgfmYgfmluaXQgPVxuICBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihmb2xkX3JpZ2h0Ml9vayB+ZiB+aW5pdCkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRfcmlnaHQyX2V4biBsMSBsMiB+ZiB+aW5pdCA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiZm9sZF9yaWdodDJfZXhuXCIgbDEgbDI7XG4gIGZvbGRfcmlnaHQyX29rIGwxIGwyIH5mIH5pbml0XG47O1xuXG5sZXQgZm9yX2FsbDIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihmb3JfYWxsMl9vayB+ZikgW0Bub250YWlsXVxuXG5sZXQgZm9yX2FsbDJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJmb3JfYWxsMl9leG5cIiBsMSBsMjtcbiAgZm9yX2FsbDJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCBleGlzdHMyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooZXhpc3RzMl9vayB+ZikgW0Bub250YWlsXVxuXG5sZXQgZXhpc3RzMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcImV4aXN0czJfZXhuXCIgbDEgbDI7XG4gIGV4aXN0czJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCBtZW0gdCBhIH5lcXVhbCA9XG4gIGxldCByZWMgbG9vcCBlcXVhbCBhID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGZhbHNlXG4gICAgfCBiIDo6IGJzIC0+IGVxdWFsIGEgYiB8fCBsb29wIGVxdWFsIGEgYnNcbiAgaW5cbiAgbG9vcCBlcXVhbCBhIHRcbjs7XG5cbigqIFRoaXMgaXMgYSBjb3B5IG9mIHRoZSBjb2RlIGZyb20gdGhlIHN0YW5kYXJkIGxpYnJhcnksIHdpdGggYW4gZXh0cmEgZXRhLWV4cGFuc2lvbiB0b1xuICAgYXZvaWQgY3JlYXRpbmcgcGFydGlhbCBjbG9zdXJlcyAoc2hvd2VkIHVwIGZvciBbZmlsdGVyXSkgaW4gcHJvZmlsaW5nKS4gKilcbmxldCByZXZfZmlsdGVyIHQgfmYgPVxuICBsZXQgcmVjIGZpbmQgfmYgYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCB4IDo6IGwgLT4gaWYgZiB4IHRoZW4gZmluZCB+ZiAoeCA6OiBhY2N1KSBsIGVsc2UgZmluZCB+ZiBhY2N1IGxcbiAgaW5cbiAgZmluZCB+ZiBbXSB0XG47O1xuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBmaWx0ZXIgbCB+ZiA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgaGQgOjogdGwgLT4gaWYgZiBoZCB0aGVuIGhkIDo6IGZpbHRlciB0bCB+ZiBlbHNlIGZpbHRlciB0bCB+ZlxuOztcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAobWF0Y2ggZiB4IHdpdGhcbiAgICAgICB8IE5vbmUgLT4gbG9vcCBsXG4gICAgICAgfCBTb21lIF8gYXMgciAtPiByKVxuICBpblxuICBsb29wIHQgW0Bub250YWlsXVxuOztcblxubGV0IGZpbmRfbWFwX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuZmluZF9tYXBfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcCB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfbWFwX2V4blxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT4gaWYgZiB4IHRoZW4gU29tZSB4IGVsc2UgbG9vcCBsXG4gIGluXG4gIGxvb3AgdCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IHJlYyBmaW5kX2V4biB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgeCA6OiB0IC0+IGlmIGYgeCB0aGVuIHggZWxzZSBmaW5kX2V4biB0IH5mXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9leG5cbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT4gaWYgZiBpIHggdGhlbiBTb21lIChpLCB4KSBlbHNlIGxvb3AgKGkgKyAxKSBsXG4gIGluXG4gIGxvb3AgMCB0IFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kaV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRpX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kaV9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZGkgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgZmluZGlfZXhuXG47O1xuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPlxuICAgICAgKG1hdGNoIGYgaSB4IHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyByZXN1bHQgLT4gcmVzdWx0XG4gICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSBsKVxuICBpblxuICBsb29wIDAgdCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZF9tYXBpX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuZmluZF9tYXBpX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kX21hcGlfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRfbWFwaSB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfbWFwaV9leG5cbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiB0cnVlXG4gICAgfCBoZCA6OiB0bCAtPiBmIGkgaGQgJiYgbG9vcCAoaSArIDEpIHRsXG4gIGluXG4gIGxvb3AgMCB0IFtAbm9udGFpbF1cbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IGZhbHNlXG4gICAgfCBoZCA6OiB0bCAtPiBmIGkgaGQgfHwgbG9vcCAoaSArIDEpIHRsXG4gIGluXG4gIGxvb3AgMCB0IFtAbm9udGFpbF1cbjs7XG5cbigqKiBGb3IgdGhlIGNvbnRhaW5lciBpbnRlcmZhY2UuICopXG5sZXQgZm9sZF9sZWZ0ID0gZm9sZFxuXG5sZXQgb2ZfYXJyYXkgPSBBcnJheS50b19saXN0XG5sZXQgdG9fYXJyYXkgPSBBcnJheS5vZl9saXN0XG5sZXQgdG9fbGlzdCB0ID0gdFxuXG4oKiogVGFpbCByZWN1cnNpdmUgdmVyc2lvbnMgb2Ygc3RhbmRhcmQgW0xpc3RdIG1vZHVsZSAqKVxuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBhcHBlbmRfbG9vcCBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgfCBbXSAtPiBsMlxuICB8IFsgeDEgXSAtPiB4MSA6OiBsMlxuICB8IFsgeDE7IHgyIF0gLT4geDEgOjogeDIgOjogbDJcbiAgfCBbIHgxOyB4MjsgeDMgXSAtPiB4MSA6OiB4MiA6OiB4MyA6OiBsMlxuICB8IFsgeDE7IHgyOyB4MzsgeDQgXSAtPiB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiBsMlxuICB8IHgxIDo6IHgyIDo6IHgzIDo6IHg0IDo6IHg1IDo6IHRsIC0+XG4gICAgeDEgOjogeDIgOjogeDMgOjogeDQgOjogeDUgOjogKGFwcGVuZF9sb29wIFtAdGFpbGNhbGxdKSB0bCBsMlxuOztcblxubGV0IGFwcGVuZCBsMSBsMiA9XG4gIG1hdGNoIGwyIHdpdGhcbiAgfCBbXSAtPiBsMVxuICB8IF8gOjogXyAtPiBhcHBlbmRfbG9vcCBsMSBsMlxuOztcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgbWFwIGwgfmYgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IHggOjogdGwgLT4gZiB4IDo6IChtYXAgW0B0YWlsY2FsbF0pIHRsIH5mXG47O1xuXG5sZXQgZm9sZGluZ19tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICBsZXQgbmV3X2FjYywgeSA9IGYgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRfbWFwIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbGV0IHJlc3VsdCA9XG4gICAgbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYywgeSA9IGYgIWFjYyB4IGluXG4gICAgICBhY2MgOj0gbmV3X2FjYztcbiAgICAgIHkpXG4gIGluXG4gICFhY2MsIHJlc3VsdFxuOztcblxubGV0ICggPj58ICkgbCBmID0gbWFwIGwgfmZcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgbWFwMl9vayBsMSBsMiB+ZiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IFtdXG4gIHwgeDEgOjogbDEsIHgyIDo6IGwyIC0+IGYgeDEgeDIgOjogbWFwMl9vayBsMSBsMiB+ZlxuICB8IF8sIF8gLT4gaW52YWxpZF9hcmcgXCJMaXN0Lm1hcDJcIlxuOztcblxubGV0IG1hcDIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihtYXAyX29rIH5mKSBbQG5vbnRhaWxdXG5cbmxldCBtYXAyX2V4biBsMSBsMiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwibWFwMl9leG5cIiBsMSBsMjtcbiAgbWFwMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IHJldl9tYXAzX29rIGwxIGwyIGwzIH5mID1cbiAgbGV0IHJlYyBsb29wIGwxIGwyIGwzIGFjID1cbiAgICBtYXRjaCBsMSwgbDIsIGwzIHdpdGhcbiAgICB8IFtdLCBbXSwgW10gLT4gYWNcbiAgICB8IHgxIDo6IGwxLCB4MiA6OiBsMiwgeDMgOjogbDMgLT4gbG9vcCBsMSBsMiBsMyAoZiB4MSB4MiB4MyA6OiBhYylcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGluXG4gIGxvb3AgbDEgbDIgbDMgW10gW0Bub250YWlsXVxuOztcblxubGV0IHJldl9tYXAzIGwxIGwyIGwzIH5mID0gY2hlY2tfbGVuZ3RoMyBsMSBsMiBsMyB+ZjoocmV2X21hcDNfb2sgfmYpIFtAbm9udGFpbF1cblxubGV0IHJldl9tYXAzX2V4biBsMSBsMiBsMyB+ZiA9XG4gIGNoZWNrX2xlbmd0aDNfZXhuIFwicmV2X21hcDNfZXhuXCIgbDEgbDIgbDM7XG4gIHJldl9tYXAzX29rIGwxIGwyIGwzIH5mXG47O1xuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBtYXAzX29rIGwxIGwyIGwzIH5mID1cbiAgbWF0Y2ggbDEsIGwyLCBsMyB3aXRoXG4gIHwgW10sIFtdLCBbXSAtPiBbXVxuICB8IHgxIDo6IGwxLCB4MiA6OiBsMiwgeDMgOjogbDMgLT4gZiB4MSB4MiB4MyA6OiBtYXAzX29rIGwxIGwyIGwzIH5mXG4gIHwgXywgXywgXyAtPiBpbnZhbGlkX2FyZyBcIkxpc3QubWFwM1wiXG47O1xuXG5sZXQgbWFwMyBsMSBsMiBsMyB+ZiA9IGNoZWNrX2xlbmd0aDMgbDEgbDIgbDMgfmY6KG1hcDNfb2sgfmYpIFtAbm9udGFpbF1cblxubGV0IG1hcDNfZXhuIGwxIGwyIGwzIH5mID1cbiAgY2hlY2tfbGVuZ3RoM19leG4gXCJtYXAzX2V4blwiIGwxIGwyIGwzO1xuICBtYXAzX29rIGwxIGwyIGwzIH5mXG47O1xuXG5sZXQgcmVjIHJldl9tYXBfYXBwZW5kIGwxIGwyIH5mID1cbiAgbWF0Y2ggbDEgd2l0aFxuICB8IFtdIC0+IGwyXG4gIHwgaCA6OiB0IC0+IHJldl9tYXBfYXBwZW5kIH5mIHQgKGYgaCA6OiBsMilcbjs7XG5cbmxldCB1bnppcCBsaXN0ID1cbiAgbGV0IHJlYyBsb29wIGxpc3QgbDEgbDIgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gbDEsIGwyXG4gICAgfCAoeCwgeSkgOjogdGwgLT4gbG9vcCB0bCAoeCA6OiBsMSkgKHkgOjogbDIpXG4gIGluXG4gIGxvb3AgKHJldiBsaXN0KSBbXSBbXVxuOztcblxubGV0IHVuemlwMyBsaXN0ID1cbiAgbGV0IHJlYyBsb29wIGxpc3QgbDEgbDIgbDMgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gbDEsIGwyLCBsM1xuICAgIHwgKHgsIHksIHopIDo6IHRsIC0+IGxvb3AgdGwgKHggOjogbDEpICh5IDo6IGwyKSAoeiA6OiBsMylcbiAgaW5cbiAgbG9vcCAocmV2IGxpc3QpIFtdIFtdIFtdXG47O1xuXG5sZXQgemlwX2V4biBsMSBsMiA9XG4gIHRyeSBtYXAyX29rIH5mOihmdW4gYSBiIC0+IGEsIGIpIGwxIGwyIHdpdGhcbiAgfCBfIC0+IGludmFsaWRfYXJnZiBcImxlbmd0aCBtaXNtYXRjaCBpbiB6aXBfZXhuOiAlZCA8PiAlZFwiIChsZW5ndGggbDEpIChsZW5ndGggbDIpICgpXG47O1xuXG5sZXQgemlwIGwxIGwyID0gbWFwMiB+ZjooZnVuIGEgYiAtPiBhLCBiKSBsMSBsMlxuXG4oKiogQWRkaXRpb25hbCBsaXN0IG9wZXJhdGlvbnMgKilcblxubGV0IHJldl9tYXBpIGwgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjXG4gICAgfCBoIDo6IHQgLT4gbG9vcCAoaSArIDEpIChmIGkgaCA6OiBhY2MpIHRcbiAgaW5cbiAgbG9vcCAwIFtdIGwgW0Bub250YWlsXVxuOztcblxubGV0IG1hcGkgbCB+ZiA9XG4gIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIGxvb3AgaSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgaCA6OiB0IC0+IGYgaSBoIDo6IGxvb3AgKGkgKyAxKSB0XG4gIGluXG4gIGxvb3AgMCBsIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkaW5nX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICBsZXQgbmV3X2FjYywgeSA9IGYgaSAhYWNjIHggaW5cbiAgICBhY2MgOj0gbmV3X2FjYztcbiAgICB5KSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZm9sZF9tYXBpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbGV0IHJlc3VsdCA9XG4gICAgbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgICBsZXQgbmV3X2FjYywgeSA9IGYgaSAhYWNjIHggaW5cbiAgICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgICAgeSlcbiAgaW5cbiAgIWFjYywgcmVzdWx0XG47O1xuXG5sZXQgaXRlcmkgbCB+ZiA9XG4gIGlnbm9yZVxuICAgIChmb2xkIGwgfmluaXQ6MCB+ZjooZnVuIGkgeCAtPlxuICAgICAgIGYgaSB4O1xuICAgICAgIGkgKyAxKVxuICAgICAgOiBpbnQpXG47O1xuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIHNuZCAoZm9sZCB0IH5pbml0OigwLCBpbml0KSB+ZjooZnVuIChpLCBhY2MpIHYgLT4gaSArIDEsIGYgaSBhY2MgdikpXG47O1xuXG5sZXQgZmlsdGVyaSBsIH5mID1cbiAgbGV0W0B0YWlsX21vZF9jb25zXSByZWMgbG9vcCBwb3MgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgaGQgOjogdGwgLT4gaWYgZiBwb3MgaGQgdGhlbiBoZCA6OiBsb29wIChwb3MgKyAxKSB0bCBlbHNlIGxvb3AgKHBvcyArIDEpIHRsXG4gIGluXG4gIGxvb3AgMCBsIFtAbm9udGFpbF1cbjs7XG5cbmxldCByZWR1Y2UgbCB+ZiA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBoZCA6OiB0bCAtPiBTb21lIChmb2xkIH5pbml0OmhkIH5mIHRsKVxuOztcblxubGV0IHJlZHVjZV9leG4gbCB+ZiA9XG4gIG1hdGNoIHJlZHVjZSBsIH5mIHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZWR1Y2VfZXhuXCJcbiAgfCBTb21lIHYgLT4gdlxuOztcblxubGV0IHJlZHVjZV9iYWxhbmNlZCBsIH5mID1cbiAgKCogQ2FsbCB0aGUgXCJzaXplXCIgb2YgYSB2YWx1ZSB0aGUgbnVtYmVyIG9mIGxpc3QgZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gY29tYmluZWQgaW50b1xuICAgICBpdCB2aWEgY2FsbHMgdG8gW2ZdLiAgV2UgcHJvY2VlZCBieSB1c2luZyBbZl0gdG8gY29tYmluZSBlbGVtZW50cyBpbiB0aGUgYWNjdW11bGF0b3JcbiAgICAgb2YgdGhlIHNhbWUgc2l6ZSB1bnRpbCB3ZSBjYW4ndCBjb21iaW5lIGFueSBtb3JlLCB0aGVuIGdldHRpbmcgYSBuZXcgZWxlbWVudCBmcm9tIHRoZVxuICAgICBpbnB1dCBsaXN0IGFuZCByZXBlYXRpbmcuXG5cbiAgICAgV2l0aCB0aGlzIHN0cmF0ZWd5LCBpbiB0aGUgYWNjdW11bGF0b3I6XG4gICAgIC0gd2Ugb25seSBldmVyIGhhdmUgZWxlbWVudHMgb2Ygc2l6ZXMgYSBwb3dlciBvZiB0d29cbiAgICAgLSB3ZSBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBvZiBlYWNoIHNpemVcbiAgICAgLSB0aGUgc3VtIG9mIGFsbCB0aGUgZWxlbWVudCBzaXplcyBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnN1bWVkXG5cbiAgICAgVGhlc2UgY29uZGl0aW9ucyBlbmZvcmNlIHRoYXQgbGlzdCBvZiBlbGVtZW50cyBvZiBlYWNoIHNpemUgaXMgcHJlY2lzZWx5IHRoZSBiaW5hcnlcbiAgICAgZXhwYW5zaW9uIG9mIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29uc3VtZWQ6IGlmIHlvdSd2ZSBjb25zdW1lZCAxMyA9IDBiMTEwMVxuICAgICBlbGVtZW50cywgeW91IGhhdmUgb25lIGVsZW1lbnQgb2Ygc2l6ZSA4LCBvbmUgb2Ygc2l6ZSA0LCBhbmQgb25lIG9mIHNpemUgMS4gIEhlbmNlXG4gICAgIHdoZW4gYSBuZXcgZWxlbWVudCBjb21lcyBhbG9uZywgdGhlIG51bWJlciBvZiBjb21iaW5pbmdzIHlvdSBuZWVkIHRvIGRvIGlzIHRoZSBudW1iZXJcbiAgICAgb2YgdHJhaWxpbmcgMXMgaW4gdGhlIGJpbmFyeSBleHBhbnNpb24gb2YgW251bV0sIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdGhhdCBoYXZlXG4gICAgIGFscmVhZHkgZ29uZSBpbnRvIHRoZSBhY2N1bXVsYXRvci4gIFRoZSBhY2N1bXVsYXRvciBpcyBpbiBhc2NlbmRpbmcgb3JkZXIgb2Ygc2l6ZSwgc29cbiAgICAgdGhlIG5leHQgZWxlbWVudCB0byBjb21iaW5lIHdpdGggaXMgYWx3YXlzIHRoZSBoZWFkIG9mIHRoZSBsaXN0LiAqKVxuICBsZXQgcmVjIHN0ZXBfYWNjdW0gbnVtIGFjYyB4ID1cbiAgICBpZiBudW0gbGFuZCAxID0gMFxuICAgIHRoZW4geCA6OiBhY2NcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFjYyB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgKCogTmV3IGVsZW1lbnRzIGZyb20gbGF0ZXIgaW4gdGhlIGlucHV0IGxpc3QgZ28gb24gdGhlIGZyb250IG9mIHRoZSBhY2N1bXVsYXRvciwgc29cbiAgICAgICAgIHRoZSBhY2N1bXVsYXRvciBpcyBpbiByZXZlcnNlIG9yZGVyIHdydCB0aGUgb3JpZ2luYWwgbGlzdCBvcmRlciwgaGVuY2UgW2YgeSB4XVxuICAgICAgICAgaW5zdGVhZCBvZiBbZiB4IHldLiAqKVxuICAgICAgfCB5IDo6IHlzIC0+IHN0ZXBfYWNjdW0gKG51bSBhc3IgMSkgeXMgKGYgeSB4KSlcbiAgaW5cbiAgKCogRXhwZXJpbWVudGFsbHksIGlubGluaW5nIFtmb2xkaV0gYW5kIHVucm9sbGluZyB0aGlzIGxvb3AgYSBmZXcgdGltZXMgY2FuIHJlZHVjZVxuICAgICBydW50aW1lIGRvd24gdG8gYSB0aGlyZCBhbmQgYWxsb2NhdGlvbiB0byAxLzE2dGggb3Igc28gaW4gdGhlIG1pY3JvYmVuY2htYXJrcyBiZWxvdy5cbiAgICAgSG93ZXZlciwgaW4gbW9zdCB1c2UgY2FzZXMgW2ZdIGlzIGxpa2VseSB0byBiZSBleHBlbnNpdmUgKG90aGVyd2lzZSB3aHkgZG8geW91IGNhcmVcbiAgICAgYWJvdXQgdGhlIG9yZGVyIG9mIHJlZHVjdGlvbj8pIHNvIHRoZSBvdmVyaGVhZCBvZiB0aGlzIGZ1bmN0aW9uIGl0c2VsZiBkb2Vzbid0IHJlYWxseVxuICAgICBtYXR0ZXIuIElmIHlvdSBjb21lIHVwIHdpdGggYSB1c2UtY2FzZSB3aGVyZSBpdCBkb2VzLCB0aGVuIHRoYXQncyBzb21ldGhpbmcgeW91IG1pZ2h0XG4gICAgIHdhbnQgdG8gdHJ5OiBzZWUgaGcgbG9nIC1wciA0OWVmMDY1ZjQyOWQuICopXG4gIG1hdGNoIGZvbGRpIGwgfmluaXQ6W10gfmY6c3RlcF9hY2N1bSB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogeHMgLT4gU29tZSAoZm9sZCB4cyB+aW5pdDp4IH5mOihmdW4geCB5IC0+IGYgeSB4KSlcbjs7XG5cbmxldCByZWR1Y2VfYmFsYW5jZWRfZXhuIGwgfmYgPVxuICBtYXRjaCByZWR1Y2VfYmFsYW5jZWQgbCB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmVkdWNlX2JhbGFuY2VkX2V4blwiXG4gIHwgU29tZSB2IC0+IHZcbjs7XG5cbmxldCBncm91cGkgbCB+YnJlYWsgPVxuICAoKiBXZSBhbGxvY2F0ZSBzaGFyZWQgcG9zaXRpb24gYW5kIGxpc3QgcmVmZXJlbmNlcyBzbyB3ZSBjYW4gbWFrZSB0aGUgaW5uZXIgbG9vcCB1c2VcbiAgICAgW1tAdGFpbF9tb2RfY29uc11dLCBhbmQgc3RpbGwgcmV0dXJuIGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgcG9zaXRpb24gYW5kIHdoZXJlIGluIHRoZVxuICAgICBsaXN0IHdlIGxlZnQgb2ZmLiAqKVxuICBsZXQgcG9zID0gcmVmIDAgaW5cbiAgbGV0IGwgPSByZWYgbCBpblxuICAoKiBBcyBhIHJlc3VsdCBvZiB1c2luZyBsb2NhbCByZWZlcmVuY2VzLCBvdXIgaW5uZXIgbG9vcCBkb2VzIG5vdCBuZWVkIGFyZ3VtZW50cy4gKilcbiAgbGV0W0B0YWlsX21vZF9jb25zXSByZWMgdGFrZV9ncm91cCAoKSA9XG4gICAgbWF0Y2ggIWwgd2l0aFxuICAgIHwgKFtdIHwgWyBfIF0pIGFzIGdyb3VwIC0+XG4gICAgICBsIDo9IFtdO1xuICAgICAgZ3JvdXBcbiAgICB8IHggOjogKHkgOjogXyBhcyB0bCkgLT5cbiAgICAgIHBvcyA6PSAhcG9zICsgMTtcbiAgICAgIGwgOj0gdGw7XG4gICAgICBpZiBicmVhayAhcG9zIHggeSB0aGVuIFsgeCBdIGVsc2UgeCA6OiB0YWtlX2dyb3VwICgpXG4gIGluXG4gICgqIE91ciBvdXRlciBsb29wIGRvZXMgbm90IG5lZWQgYXJndW1lbnRzLCBlaXRoZXIuICopXG4gIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIGdyb3VwcyAoKSA9XG4gICAgaWYgaXNfZW1wdHkgIWxcbiAgICB0aGVuIFtdXG4gICAgZWxzZSAoXG4gICAgICBsZXQgZ3JvdXAgPSB0YWtlX2dyb3VwICgpIGluXG4gICAgICBncm91cCA6OiBncm91cHMgKCkpXG4gIGluXG4gIGdyb3VwcyAoKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZ3JvdXAgbCB+YnJlYWsgPSBncm91cGkgbCB+YnJlYWs6KGZ1biBfIHggeSAtPiBicmVhayB4IHkpIFtAbm9udGFpbF1cblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgbWVyZ2UgbDEgbDIgfmNvbXBhcmUgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsMiAtPiBsMlxuICB8IGwxLCBbXSAtPiBsMVxuICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgIGlmIGNvbXBhcmUgaDEgaDIgPD0gMCB0aGVuIGgxIDo6IG1lcmdlIHQxIGwyIH5jb21wYXJlIGVsc2UgaDIgOjogbWVyZ2UgbDEgdDIgfmNvbXBhcmVcbjs7XG5cbmxldCBzdGFibGVfc29ydCBsIH5jb21wYXJlOmNtcCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGNtcCBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgdGhlbiByZXZfbWVyZ2UgY21wIHQxIGwyIChoMSA6OiBhY2N1KVxuICAgICAgZWxzZSByZXZfbWVyZ2UgY21wIGwxIHQyIChoMiA6OiBhY2N1KVxuICBpblxuICBsZXQgcmVjIHJldl9tZXJnZV9yZXYgY21wIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICAgIGlmIGNtcCBoMSBoMiA+IDBcbiAgICAgIHRoZW4gcmV2X21lcmdlX3JldiBjbXAgdDEgbDIgKGgxIDo6IGFjY3UpXG4gICAgICBlbHNlIHJldl9tZXJnZV9yZXYgY21wIGwxIHQyIChoMiA6OiBhY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICBsZXQgcyA9IGlmIGNtcCB4MSB4MiA8PSAwIHRoZW4gWyB4MTsgeDIgXSBlbHNlIFsgeDI7IHgxIF0gaW5cbiAgICAgIHMsIHRsXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgbGV0IHMgPVxuICAgICAgICBpZiBjbXAgeDEgeDIgPD0gMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgaWYgY21wIHgyIHgzIDw9IDBcbiAgICAgICAgICB0aGVuIFsgeDE7IHgyOyB4MyBdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPD0gMFxuICAgICAgICAgIHRoZW4gWyB4MTsgeDM7IHgyIF1cbiAgICAgICAgICBlbHNlIFsgeDM7IHgxOyB4MiBdXG4gICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDBcbiAgICAgICAgdGhlbiBbIHgyOyB4MTsgeDMgXVxuICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA8PSAwXG4gICAgICAgIHRoZW4gWyB4MjsgeDM7IHgxIF1cbiAgICAgICAgZWxzZSBbIHgzOyB4MjsgeDEgXVxuICAgICAgaW5cbiAgICAgIHMsIHRsXG4gICAgfCBuLCBsIC0+XG4gICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgIGxldCBzMSwgbDIgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgIHJldl9tZXJnZV9yZXYgY21wIHMxIHMyIFtdLCB0bFxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICBsZXQgcyA9IGlmIGNtcCB4MSB4MiA+IDAgdGhlbiBbIHgxOyB4MiBdIGVsc2UgWyB4MjsgeDEgXSBpblxuICAgICAgcywgdGxcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICBsZXQgcyA9XG4gICAgICAgIGlmIGNtcCB4MSB4MiA+IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIGlmIGNtcCB4MiB4MyA+IDBcbiAgICAgICAgICB0aGVuIFsgeDE7IHgyOyB4MyBdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwXG4gICAgICAgICAgdGhlbiBbIHgxOyB4MzsgeDIgXVxuICAgICAgICAgIGVsc2UgWyB4MzsgeDE7IHgyIF1cbiAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwXG4gICAgICAgIHRoZW4gWyB4MjsgeDE7IHgzIF1cbiAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPiAwXG4gICAgICAgIHRoZW4gWyB4MjsgeDM7IHgxIF1cbiAgICAgICAgZWxzZSBbIHgzOyB4MjsgeDEgXVxuICAgICAgaW5cbiAgICAgIHMsIHRsXG4gICAgfCBuLCBsIC0+XG4gICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgIGxldCBzMiwgdGwgPSBzb3J0IG4yIGwyIGluXG4gICAgICByZXZfbWVyZ2UgY21wIHMxIHMyIFtdLCB0bFxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBmc3QgKHNvcnQgbGVuIGwpXG47O1xuXG5sZXQgc29ydCA9IHN0YWJsZV9zb3J0XG5cbmxldCBzb3J0X2FuZF9ncm91cCBsIH5jb21wYXJlID1cbiAgKGwgfD4gc3RhYmxlX3NvcnQgfmNvbXBhcmUgfD4gZ3JvdXAgfmJyZWFrOihmdW4geCB5IC0+IGNvbXBhcmUgeCB5IDw+IDApKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZGVkdXBfYW5kX3NvcnQgbCB+Y29tcGFyZTpjbXAgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBjbXAgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgKG1hdGNoIGNtcCBoMSBoMiB3aXRoXG4gICAgICAgfCBjIHdoZW4gYyA8IDAgLT4gcmV2X21lcmdlIGNtcCB0MSBsMiAoaDEgOjogYWNjdSlcbiAgICAgICB8IGMgd2hlbiBjID4gMCAtPiByZXZfbWVyZ2UgY21wIGwxIHQyIChoMiA6OiBhY2N1KVxuICAgICAgIHwgXyAtPiByZXZfbWVyZ2UgY21wIHQxIGwyIGFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBjbXAgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgKG1hdGNoIGNtcCBoMSBoMiB3aXRoXG4gICAgICAgfCBjIHdoZW4gYyA+IDAgLT4gcmV2X21lcmdlX3JldiBjbXAgdDEgbDIgKGgxIDo6IGFjY3UpXG4gICAgICAgfCBjIHdoZW4gYyA8IDAgLT4gcmV2X21lcmdlX3JldiBjbXAgbDEgdDIgKGgyIDo6IGFjY3UpXG4gICAgICAgfCBfIC0+IHJldl9tZXJnZV9yZXYgY21wIHQxIGwyIGFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgIGxldCBzID1cbiAgICAgICAgbWF0Y2ggY21wIHgxIHgyIHdpdGhcbiAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT4gWyB4MTsgeDIgXVxuICAgICAgICB8IGMgd2hlbiBjID4gMCAtPiBbIHgyOyB4MSBdXG4gICAgICAgIHwgXyAtPiBbIHgyIF1cbiAgICAgIGluXG4gICAgICBzLCB0bFxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgIGxldCBzID1cbiAgICAgICAgbWF0Y2ggY21wIHgxIHgyIHdpdGhcbiAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT5cbiAgICAgICAgICAobWF0Y2ggY21wIHgyIHgzIHdpdGhcbiAgICAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT4gWyB4MTsgeDI7IHgzIF1cbiAgICAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT5cbiAgICAgICAgICAgICAobWF0Y2ggY21wIHgxIHgzIHdpdGhcbiAgICAgICAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT4gWyB4MTsgeDM7IHgyIF1cbiAgICAgICAgICAgICAgfCBjIHdoZW4gYyA+IDAgLT4gWyB4MzsgeDE7IHgyIF1cbiAgICAgICAgICAgICAgfCBfIC0+IFsgeDM7IHgyIF0pXG4gICAgICAgICAgIHwgXyAtPiBbIHgxOyB4MyBdKVxuICAgICAgICB8IGMgd2hlbiBjID4gMCAtPlxuICAgICAgICAgIChtYXRjaCBjbXAgeDEgeDMgd2l0aFxuICAgICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPiBbIHgyOyB4MTsgeDMgXVxuICAgICAgICAgICB8IGMgd2hlbiBjID4gMCAtPlxuICAgICAgICAgICAgIChtYXRjaCBjbXAgeDIgeDMgd2l0aFxuICAgICAgICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPiBbIHgyOyB4MzsgeDEgXVxuICAgICAgICAgICAgICB8IGMgd2hlbiBjID4gMCAtPiBbIHgzOyB4MjsgeDEgXVxuICAgICAgICAgICAgICB8IF8gLT4gWyB4MzsgeDEgXSlcbiAgICAgICAgICAgfCBfIC0+IFsgeDI7IHgzIF0pXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIChtYXRjaCBjbXAgeDIgeDMgd2l0aFxuICAgICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPiBbIHgyOyB4MyBdXG4gICAgICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+IFsgeDM7IHgyIF1cbiAgICAgICAgICAgfCBfIC0+IFsgeDMgXSlcbiAgICAgIGluXG4gICAgICBzLCB0bFxuICAgIHwgbiwgbCAtPlxuICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgbGV0IHMyLCB0bCA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICByZXZfbWVyZ2VfcmV2IGNtcCBzMSBzMiBbXSwgdGxcbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgbGV0IHMgPVxuICAgICAgICBtYXRjaCBjbXAgeDEgeDIgd2l0aFxuICAgICAgICB8IGMgd2hlbiBjID4gMCAtPiBbIHgxOyB4MiBdXG4gICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+IFsgeDI7IHgxIF1cbiAgICAgICAgfCBfIC0+IFsgeDIgXVxuICAgICAgaW5cbiAgICAgIHMsIHRsXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgbGV0IHMgPVxuICAgICAgICBtYXRjaCBjbXAgeDEgeDIgd2l0aFxuICAgICAgICB8IGMgd2hlbiBjID4gMCAtPlxuICAgICAgICAgIChtYXRjaCBjbXAgeDIgeDMgd2l0aFxuICAgICAgICAgICB8IGMgd2hlbiBjID4gMCAtPiBbIHgxOyB4MjsgeDMgXVxuICAgICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPlxuICAgICAgICAgICAgIChtYXRjaCBjbXAgeDEgeDMgd2l0aFxuICAgICAgICAgICAgICB8IGMgd2hlbiBjID4gMCAtPiBbIHgxOyB4MzsgeDIgXVxuICAgICAgICAgICAgICB8IGMgd2hlbiBjIDwgMCAtPiBbIHgzOyB4MTsgeDIgXVxuICAgICAgICAgICAgICB8IF8gLT4gWyB4MzsgeDIgXSlcbiAgICAgICAgICAgfCBfIC0+IFsgeDE7IHgzIF0pXG4gICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+XG4gICAgICAgICAgKG1hdGNoIGNtcCB4MSB4MyB3aXRoXG4gICAgICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+IFsgeDI7IHgxOyB4MyBdXG4gICAgICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+XG4gICAgICAgICAgICAgKG1hdGNoIGNtcCB4MiB4MyB3aXRoXG4gICAgICAgICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+IFsgeDI7IHgzOyB4MSBdXG4gICAgICAgICAgICAgIHwgYyB3aGVuIGMgPCAwIC0+IFsgeDM7IHgyOyB4MSBdXG4gICAgICAgICAgICAgIHwgXyAtPiBbIHgzOyB4MSBdKVxuICAgICAgICAgICB8IF8gLT4gWyB4MjsgeDMgXSlcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgKG1hdGNoIGNtcCB4MiB4MyB3aXRoXG4gICAgICAgICAgIHwgYyB3aGVuIGMgPiAwIC0+IFsgeDI7IHgzIF1cbiAgICAgICAgICAgfCBjIHdoZW4gYyA8IDAgLT4gWyB4MzsgeDIgXVxuICAgICAgICAgICB8IF8gLT4gWyB4MyBdKVxuICAgICAgaW5cbiAgICAgIHMsIHRsXG4gICAgfCBuLCBsIC0+XG4gICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgIGxldCBzMiwgdGwgPSBzb3J0IG4yIGwyIGluXG4gICAgICByZXZfbWVyZ2UgY21wIHMxIHMyIFtdLCB0bFxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBmc3QgKHNvcnQgbGVuIGwpXG47O1xuXG5sZXQgc3RhYmxlX2RlZHVwIGxpc3QgfmNvbXBhcmUgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbXSB8IFsgXyBdIC0+IGxpc3QgKCogc3BlY2lhbCBjYXNlIGZvciBwZXJmb3JtYW5jZSAqKVxuICB8IF8gOjogXyA6OiBfIC0+XG4gICAgbGV0IG9wZW4gc3RydWN0XG4gICAgICB0eXBlICdhIGRlZHVwID1cbiAgICAgICAgeyBlbHQgOiAnYVxuICAgICAgICA7IG11dGFibGUgZHVwIDogYm9vbFxuICAgICAgICB9XG4gICAgZW5kIGluXG4gICAgKCogW3N0YWJsZV9kZWR1cF0ga2VlcHMgdGhlIGZpcnN0IG9mIGVhY2ggc2V0IG9mIGR1cGxpY2F0ZXMuIFtkZWR1cF9hbmRfc29ydF0ga2VlcHNcbiAgICAgICB0aGUgbGFzdC4gV2UgZGVmaW5lIG9uZSBpbiB0ZXJtcyBvZiB0aGUgb3RoZXIgYnkgcGFzc2luZyB0aGUgdmFsdWVzIGluIHJldmVyc2VcbiAgICAgICBvcmRlciwgaGVuY2UgdGhlIFtyZXZfbWFwXSBpbiB0aGUgZGVmaW5pdGlvbiBvZiBbZGVkdXBzXS4gV2UgcmVzdG9yZSB0aGUgb3JkZXIgaW5cbiAgICAgICB0aGUgZmluYWwgW2ZvbGRdLiAqKVxuICAgIGxldCBkZWR1cHMgPSByZXZfbWFwIGxpc3QgfmY6KGZ1biBlbHQgLT4geyBlbHQ7IGR1cCA9IHRydWUgfSkgaW5cbiAgICBsZXQgdW5pcXVlID0gZGVkdXBfYW5kX3NvcnQgZGVkdXBzIH5jb21wYXJlOihmdW4geCB5IC0+IGNvbXBhcmUgeC5lbHQgeS5lbHQpIGluXG4gICAgaXRlciB1bmlxdWUgfmY6KGZ1biBkZWR1cCAtPiBkZWR1cC5kdXAgPC0gZmFsc2UpO1xuICAgIGZvbGQgZGVkdXBzIH5pbml0OltdIH5mOihmdW4gYWNjIGRlZHVwIC0+IGlmIGRlZHVwLmR1cCB0aGVuIGFjYyBlbHNlIGRlZHVwLmVsdCA6OiBhY2MpXG47O1xuXG5sZXQgY29uY2F0X21hcGkgbCB+ZiA9XG4gIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIG91dGVyX2xvb3AgcG9zID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IFtdXG4gICAgfCBbIGhkIF0gLT4gKGYgW0B0YWlsY2FsbCBmYWxzZV0pIHBvcyBoZFxuICAgIHwgaGQgOjogKF8gOjogXyBhcyB0bCkgLT4gaW5uZXJfbG9vcCAocG9zICsgMSkgKGYgcG9zIGhkKSB0bFxuICBhbmRbQHRhaWxfbW9kX2NvbnNdIGlubmVyX2xvb3AgcG9zIGwxIGwyID1cbiAgICBtYXRjaCBsMSB3aXRoXG4gICAgfCBbXSAtPiBvdXRlcl9sb29wIHBvcyBsMlxuICAgIHwgWyB4MSBdIC0+IHgxIDo6IG91dGVyX2xvb3AgcG9zIGwyXG4gICAgfCBbIHgxOyB4MiBdIC0+IHgxIDo6IHgyIDo6IG91dGVyX2xvb3AgcG9zIGwyXG4gICAgfCBbIHgxOyB4MjsgeDMgXSAtPiB4MSA6OiB4MiA6OiB4MyA6OiBvdXRlcl9sb29wIHBvcyBsMlxuICAgIHwgWyB4MTsgeDI7IHgzOyB4NCBdIC0+IHgxIDo6IHgyIDo6IHgzIDo6IHg0IDo6IG91dGVyX2xvb3AgcG9zIGwyXG4gICAgfCB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiB4NSA6OiB0bCAtPlxuICAgICAgeDEgOjogeDIgOjogeDMgOjogeDQgOjogeDUgOjogaW5uZXJfbG9vcCBwb3MgdGwgbDJcbiAgaW5cbiAgb3V0ZXJfbG9vcCAwIGwgW0Bub250YWlsXVxuOztcblxubGV0IGNvbmNhdF9tYXAgbCB+ZiA9IGNvbmNhdF9tYXBpIGwgfmY6KGZ1biBfIHggLT4gZiB4KSBbQG5vbnRhaWxdXG5cbm1vZHVsZSBDYXJ0ZXNpYW5fcHJvZHVjdCA9IHN0cnVjdFxuICAoKiBXZSBhcmUgZXhwbGljaXQgYWJvdXQgd2hhdCB3ZSBleHBvcnQgZnJvbSBmdW5jdG9ycyBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseVxuICAgICByZWJpbmQgbW9yZSBlZmZpY2llbnQgbGlzdC1zcGVjaWZpYyBmdW5jdGlvbnMuICopXG5cbiAgbGV0IGJpbmQgPSBjb25jYXRfbWFwXG4gIGxldCBtYXAgPSBtYXBcbiAgbGV0IG1hcDIgYSBiIH5mID0gY29uY2F0X21hcCBhIH5mOihmdW4geCAtPiBtYXAgYiB+ZjooZnVuIHkgLT4gZiB4IHkpKVxuICBsZXQgcmV0dXJuID0gc2luZ2xldG9uXG4gIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBsZXQgKCA+Pj0gKSB0IGYgPSBiaW5kIHQgfmZcblxuICBvcGVuIHN0cnVjdFxuICAgIG1vZHVsZSBBcHBsaWNhdGl2ZSA9IEFwcGxpY2F0aXZlLk1ha2VfdXNpbmdfbWFwMiAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSBsaXN0XG5cbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgICAgbGV0IG1hcDIgPSBtYXAyXG4gICAgZW5kKVxuXG4gICAgbW9kdWxlIE1vbmFkID0gTW9uYWQuTWFrZSAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSBsaXN0XG5cbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgZW5kKVxuICBlbmRcblxuICBsZXQgYWxsID0gTW9uYWQuYWxsXG4gIGxldCBhbGxfdW5pdCA9IE1vbmFkLmFsbF91bml0XG4gIGxldCBpZ25vcmVfbSA9IE1vbmFkLmlnbm9yZV9tXG4gIGxldCBqb2luID0gTW9uYWQuam9pblxuXG4gIG1vZHVsZSBNb25hZF9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICAgIGxldCAoID4+PSApID0gKCA+Pj0gKVxuICBlbmRcblxuICBsZXQgYXBwbHkgPSBBcHBsaWNhdGl2ZS5hcHBseVxuICBsZXQgYm90aCA9IEFwcGxpY2F0aXZlLmJvdGhcbiAgbGV0IG1hcDMgPSBBcHBsaWNhdGl2ZS5tYXAzXG4gIGxldCAoIDwqPiApID0gQXBwbGljYXRpdmUuKCA8Kj4gKVxuICBsZXQgKCAqPiApID0gQXBwbGljYXRpdmUuKCAqPiApXG4gIGxldCAoIDwqICkgPSBBcHBsaWNhdGl2ZS4oIDwqIClcblxuICBtb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgICBsZXQgKCA8Kj4gKSA9IEFwcGxpY2F0aXZlLiggPCo+IClcbiAgICBsZXQgKCAqPiApID0gQXBwbGljYXRpdmUuKCAqPiApXG4gICAgbGV0ICggPCogKSA9IEFwcGxpY2F0aXZlLiggPCogKVxuICBlbmRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgICBsZXQgKCA+Pj0gKSA9ICggPj49IClcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGxldCBtYXAgPSBtYXBcbiAgICAgIGxldCBib3RoID0gYm90aFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmluY2x1ZGUgKENhcnRlc2lhbl9wcm9kdWN0IDogTW9uYWQuU19sb2NhbCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0KVxuXG4oKiogcmV0dXJucyBmaW5hbCBlbGVtZW50IG9mIGxpc3QgKilcbmxldCByZWMgbGFzdF9leG4gbGlzdCA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFsgeCBdIC0+IHhcbiAgfCBfIDo6IHRsIC0+IGxhc3RfZXhuIHRsXG4gIHwgW10gLT4gaW52YWxpZF9hcmcgXCJMaXN0Lmxhc3RcIlxuOztcblxuKCoqIG9wdGlvbmFsbHkgcmV0dXJucyBmaW5hbCBlbGVtZW50IG9mIGxpc3QgKilcbmxldCByZWMgbGFzdCBsaXN0ID1cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gIHwgWyB4IF0gLT4gU29tZSB4XG4gIHwgXyA6OiB0bCAtPiBsYXN0IHRsXG4gIHwgW10gLT4gTm9uZVxuOztcblxubGV0IHJlYyBpc19wcmVmaXggbGlzdCB+cHJlZml4IH5lcXVhbCA9XG4gIG1hdGNoIHByZWZpeCB3aXRoXG4gIHwgW10gLT4gdHJ1ZVxuICB8IGhkIDo6IHRsIC0+XG4gICAgKG1hdGNoIGxpc3Qgd2l0aFxuICAgICB8IFtdIC0+IGZhbHNlXG4gICAgIHwgaGQnIDo6IHRsJyAtPiBlcXVhbCBoZCBoZCcgJiYgaXNfcHJlZml4IHRsJyB+cHJlZml4OnRsIH5lcXVhbClcbjs7XG5cbmxldCBmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSB0IH5lcXVhbCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBhMSA6OiB0IC0+XG4gICAgbGV0IHJlYyBsb29wIGExIHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IE5vbmVcbiAgICAgIHwgYTIgOjogdCAtPiBpZiBlcXVhbCBhMSBhMiB0aGVuIFNvbWUgKGExLCBhMikgZWxzZSBsb29wIGEyIHRcbiAgICBpblxuICAgIGxvb3AgYTEgdCBbQG5vbnRhaWxdXG47O1xuXG4oKiByZXR1cm5zIGxpc3Qgd2l0aG91dCBhZGphY2VudCBkdXBsaWNhdGVzICopXG5sZXQgcmVtb3ZlX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZXMgPyh3aGljaF90b19rZWVwID0gYExhc3QpIGxpc3QgfmVxdWFsID1cbiAgbGV0IHJlYyBsb29wIHRvX2tlZXAgYWNjdW0gPSBmdW5jdGlvblxuICAgIHwgW10gLT4gdG9fa2VlcCA6OiBhY2N1bVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIGlmIGVxdWFsIGhkIHRvX2tlZXBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgdG9fa2VlcCA9XG4gICAgICAgICAgbWF0Y2ggd2hpY2hfdG9fa2VlcCB3aXRoXG4gICAgICAgICAgfCBgRmlyc3QgLT4gdG9fa2VlcFxuICAgICAgICAgIHwgYExhc3QgLT4gaGRcbiAgICAgICAgaW5cbiAgICAgICAgbG9vcCB0b19rZWVwIGFjY3VtIHRsKVxuICAgICAgZWxzZSBsb29wIGhkICh0b19rZWVwIDo6IGFjY3VtKSB0bFxuICBpblxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IGhkIDo6IHRsIC0+IHJldiAobG9vcCBoZCBbXSB0bClcbjs7XG5cbmxldCBmaW5kX2FfZHVwIGwgfmNvbXBhcmUgPVxuICBsZXQgc29ydGVkID0gc29ydCBsIH5jb21wYXJlIGluXG4gIGxldCByZWMgbG9vcCBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIHwgWyBfIF0gLT4gTm9uZVxuICAgIHwgaGQxIDo6IChoZDIgOjogXyBhcyB0bCkgLT4gaWYgY29tcGFyZSBoZDEgaGQyID0gMCB0aGVuIFNvbWUgaGQxIGVsc2UgbG9vcCB0bFxuICBpblxuICBsb29wIHNvcnRlZCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgY29udGFpbnNfZHVwIGxzdCB+Y29tcGFyZSA9XG4gIG1hdGNoIGZpbmRfYV9kdXAgbHN0IH5jb21wYXJlIHdpdGhcbiAgfCBTb21lIF8gLT4gdHJ1ZVxuICB8IE5vbmUgLT4gZmFsc2Vcbjs7XG5cbmxldCBmaW5kX2FsbF9kdXBzIGwgfmNvbXBhcmUgPVxuICBsZXQgc29ydGVkID0gc29ydCB+Y29tcGFyZSBsIGluXG4gICgqIFdhbGsgdGhlIGxpc3QgYW5kIHJlY29yZCB0aGUgZmlyc3Qgb2YgZWFjaCBjb25zZWN1dGl2ZSBydW4gb2YgaWRlbnRpY2FsIGVsZW1lbnRzICopXG4gIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIGxvb3Agc29ydGVkIHByZXYgfmFscmVhZHlfcmVjb3JkZWQgPVxuICAgIG1hdGNoIHNvcnRlZCB3aXRoXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIGlmIGNvbXBhcmUgcHJldiBoZCA8PiAwXG4gICAgICB0aGVuIGxvb3AgdGwgaGQgfmFscmVhZHlfcmVjb3JkZWQ6ZmFsc2VcbiAgICAgIGVsc2UgaWYgYWxyZWFkeV9yZWNvcmRlZFxuICAgICAgdGhlbiBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOnRydWVcbiAgICAgIGVsc2UgaGQgOjogbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDp0cnVlXG4gIGluXG4gIG1hdGNoIHNvcnRlZCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBoZCA6OiB0bCAtPiBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOmZhbHNlIFtAbm9udGFpbF1cbjs7XG5cbmxldCByZWMgYWxsX2VxdWFsX3RvIHQgdiB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiB0cnVlXG4gIHwgeCA6OiB4cyAtPiBlcXVhbCB4IHYgJiYgYWxsX2VxdWFsX3RvIHhzIHYgfmVxdWFsXG47O1xuXG5sZXQgYWxsX2VxdWFsIHQgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogeHMgLT4gaWYgYWxsX2VxdWFsX3RvIHhzIHggfmVxdWFsIHRoZW4gU29tZSB4IGVsc2UgTm9uZVxuOztcblxubGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6MCB+ZjooZnVuIGlkeCBjb3VudCBhIC0+IGlmIGYgaWR4IGEgdGhlbiBjb3VudCArIDEgZWxzZSBjb3VudCkgW0Bub250YWlsXVxuOztcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTGlzdC5pbml0ICVkXCIgbiAoKTtcbiAgbGV0IHJlYyBsb29wIGkgYWNjdW0gPVxuICAgIGFzc2VydCAoaSA+PSAwKTtcbiAgICBpZiBpID0gMCB0aGVuIGFjY3VtIGVsc2UgbG9vcCAoaSAtIDEpIChmIChpIC0gMSkgOjogYWNjdW0pXG4gIGluXG4gIGxvb3AgbiBbXSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcmV2X2ZpbHRlcl9tYXAgbCB+ZiA9XG4gIGxldCByZWMgbG9vcCBsIGFjY3VtID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGFjY3VtXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgKG1hdGNoIGYgaGQgd2l0aFxuICAgICAgIHwgU29tZSB4IC0+IGxvb3AgdGwgKHggOjogYWNjdW0pXG4gICAgICAgfCBOb25lIC0+IGxvb3AgdGwgYWNjdW0pXG4gIGluXG4gIGxvb3AgbCBbXSBbQG5vbnRhaWxdXG47O1xuXG5sZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBmaWx0ZXJfbWFwIGwgfmYgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IGhkIDo6IHRsIC0+XG4gICAgKG1hdGNoIGYgaGQgd2l0aFxuICAgICB8IE5vbmUgLT4gZmlsdGVyX21hcCB0bCB+ZlxuICAgICB8IFNvbWUgeCAtPiB4IDo6IGZpbHRlcl9tYXAgdGwgfmYpXG47O1xuXG5sZXQgcmV2X2ZpbHRlcl9tYXBpIGwgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSBsIGFjY3VtID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGFjY3VtXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgKG1hdGNoIGYgaSBoZCB3aXRoXG4gICAgICAgfCBTb21lIHggLT4gbG9vcCAoaSArIDEpIHRsICh4IDo6IGFjY3VtKVxuICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgdGwgYWNjdW0pXG4gIGluXG4gIGxvb3AgMCBsIFtdIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSBsIH5mID1cbiAgbGV0W0B0YWlsX21vZF9jb25zXSByZWMgbG9vcCBwb3MgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIChtYXRjaCBmIHBvcyBoZCB3aXRoXG4gICAgICAgfCBOb25lIC0+IGxvb3AgKHBvcyArIDEpIHRsXG4gICAgICAgfCBTb21lIHggLT4geCA6OiBsb29wIChwb3MgKyAxKSB0bClcbiAgaW5cbiAgbG9vcCAwIGwgW0Bub250YWlsXVxuOztcblxubGV0IGZpbHRlcl9vcHQgbCA9IGZpbHRlcl9tYXAgbCB+ZjpGbi5pZFxuXG5sZXQgcGFydGl0aW9uM19tYXAgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCB0IGZzdCBzbmQgdHJkID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJldiBmc3QsIHJldiBzbmQsIHJldiB0cmRcbiAgICB8IHggOjogdCAtPlxuICAgICAgKG1hdGNoIGYgeCB3aXRoXG4gICAgICAgfCBgRnN0IHkgLT4gbG9vcCB0ICh5IDo6IGZzdCkgc25kIHRyZFxuICAgICAgIHwgYFNuZCB5IC0+IGxvb3AgdCBmc3QgKHkgOjogc25kKSB0cmRcbiAgICAgICB8IGBUcmQgeSAtPiBsb29wIHQgZnN0IHNuZCAoeSA6OiB0cmQpKVxuICBpblxuICBsb29wIHQgW10gW10gW10gW0Bub250YWlsXVxuOztcblxubGV0IHBhcnRpdGlvbl90ZiB0IH5mID1cbiAgbGV0IGYgeCA6IF8gRWl0aGVyLnQgPSBpZiBmIHggdGhlbiBGaXJzdCB4IGVsc2UgU2Vjb25kIHggaW5cbiAgcGFydGl0aW9uX21hcCB0IH5mIFtAbm9udGFpbF1cbjs7XG5cbmxldCBwYXJ0aXRpb25fcmVzdWx0IHQgPSBwYXJ0aXRpb25fbWFwIHQgfmY6UmVzdWx0LnRvX2VpdGhlclxuXG5tb2R1bGUgQXNzb2MgPSBzdHJ1Y3RcbiAgdHlwZSAnYSBrZXkgPSAoJ2FbQHRhZyBTZXhwbGliMC5TZXhwX2dyYW1tYXIuYXNzb2Nfa2V5X3RhZyA9IExpc3QgW11dKVxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBrZXlfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2Ega2V5ID1cbiAgICBmdW4gX29mX2FfXzAyMl8gLT4gX29mX2FfXzAyMl9cbiAgOztcblxuICBsZXQgc2V4cF9vZl9rZXkgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2Ega2V5IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgZnVuIF9vZl9hX18wMjRfIC0+IF9vZl9hX18wMjRfXG4gIDs7XG5cbiAgbGV0IGtleV9zZXhwX2dyYW1tYXIgOiAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2Ega2V5IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPlxuICAgIHsgdW50eXBlZCA9XG4gICAgICAgIFRhZ2dlZFxuICAgICAgICAgIHsga2V5ID0gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmFzc29jX2tleV90YWdcbiAgICAgICAgICA7IHZhbHVlID0gTGlzdCBbXVxuICAgICAgICAgIDsgZ3JhbW1hciA9IF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgIH1cbiAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICdhIHZhbHVlID0gKCdhW0B0YWcgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmFzc29jX3ZhbHVlX3RhZyA9IExpc3QgW11dKVxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCB2YWx1ZV9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB2YWx1ZSA9XG4gICAgZnVuIF9vZl9hX18wMjVfIC0+IF9vZl9hX18wMjVfXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdmFsdWUgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdmFsdWUgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBmdW4gX29mX2FfXzAyN18gLT4gX29mX2FfXzAyN19cbiAgOztcblxuICBsZXQgdmFsdWVfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHZhbHVlIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+XG4gICAgeyB1bnR5cGVkID1cbiAgICAgICAgVGFnZ2VkXG4gICAgICAgICAgeyBrZXkgPSBTZXhwbGliMC5TZXhwX2dyYW1tYXIuYXNzb2NfdmFsdWVfdGFnXG4gICAgICAgICAgOyB2YWx1ZSA9IExpc3QgW11cbiAgICAgICAgICA7IGdyYW1tYXIgPSBfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICB9XG4gICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICAoKCdhIGtleSAqICdiIHZhbHVlKSBsaXN0W0B0YWcgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmFzc29jX3RhZyA9IExpc3QgW11dKVxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCB0X29mX3NleHAgOlxuICAgICAgICAnYSAnYi5cbiAgICAgICAgKFNleHBsaWIwLlNleHAudCAtPiAnYSlcbiAgICAgICAgLT4gKFNleHBsaWIwLlNleHAudCAtPiAnYilcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgICAgIC0+ICgnYSwgJ2IpIHRcbiAgICA9XG4gICAgbGV0IGVycm9yX3NvdXJjZV9fMDM2XyA9IFwibGlzdC5tbC5Bc3NvYy50XCIgaW5cbiAgICBmdW4gX29mX2FfXzAyOF8gX29mX2JfXzAyOV8geF9fMDM3XyAtPlxuICAgICAgbGlzdF9vZl9zZXhwXG4gICAgICAgIChmdW5jdGlvblxuICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wMzFfOyBhcmcxX18wMzJfIF0gLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzAzM18gPSBrZXlfb2Zfc2V4cCBfb2ZfYV9fMDI4XyBhcmcwX18wMzFfXG4gICAgICAgICAgIGFuZCByZXMxX18wMzRfID0gdmFsdWVfb2Zfc2V4cCBfb2ZfYl9fMDI5XyBhcmcxX18wMzJfIGluXG4gICAgICAgICAgIHJlczBfXzAzM18sIHJlczFfXzAzNF9cbiAgICAgICAgIHwgc2V4cF9fMDM1XyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMzZfXG4gICAgICAgICAgICAgMlxuICAgICAgICAgICAgIHNleHBfXzAzNV8pXG4gICAgICAgIHhfXzAzN19cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAgICAgJ2EgJ2IuXG4gICAgICAgICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biBfb2ZfYV9fMDM4XyBfb2ZfYl9fMDM5XyB4X18wNDRfIC0+XG4gICAgc2V4cF9vZl9saXN0XG4gICAgICAoZnVuIChhcmcwX18wNDBfLCBhcmcxX18wNDFfKSAtPlxuICAgICAgICBsZXQgcmVzMF9fMDQyXyA9IHNleHBfb2Zfa2V5IF9vZl9hX18wMzhfIGFyZzBfXzA0MF9cbiAgICAgICAgYW5kIHJlczFfXzA0M18gPSBzZXhwX29mX3ZhbHVlIF9vZl9iX18wMzlfIGFyZzFfXzA0MV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMDQyXzsgcmVzMV9fMDQzXyBdKVxuICAgICAgeF9fMDQ0X1xuICA7O1xuXG4gIGxldCB0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICdhICdiLlxuICAgICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgICAtPiAnYiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgICAtPiAoJ2EsICdiKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIF8nYl9zZXhwX2dyYW1tYXIgLT5cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBUYWdnZWRcbiAgICAgICAgICB7IGtleSA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY190YWdcbiAgICAgICAgICA7IHZhbHVlID0gTGlzdCBbXVxuICAgICAgICAgIDsgZ3JhbW1hciA9XG4gICAgICAgICAgICAgIChsaXN0X3NleHBfZ3JhbW1hclxuICAgICAgICAgICAgICAgICB7IHVudHlwZWQgPVxuICAgICAgICAgICAgICAgICAgICAgTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAoQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAoIChrZXlfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXIpLnVudHlwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLCBDb25zICgodmFsdWVfc2V4cF9ncmFtbWFyIF8nYl9zZXhwX2dyYW1tYXIpLnVudHlwZWQsIEVtcHR5KSApKVxuICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC51bnR5cGVkXG4gICAgICAgICAgfVxuICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCBwYWlyX29mX2dyb3VwID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgKGssIF8pIDo6IF8gYXMgbGlzdCAtPiBrLCBtYXAgbGlzdCB+ZjpzbmRcbiAgOztcblxuICBsZXQgZ3JvdXAgYWxpc3QgfmVxdWFsID1cbiAgICBncm91cCBhbGlzdCB+YnJlYWs6KGZ1biAoeCwgXykgKHksIF8pIC0+IG5vdCAoZXF1YWwgeCB5KSkgfD4gbWFwIH5mOnBhaXJfb2ZfZ3JvdXBcbiAgOztcblxuICBsZXQgc29ydF9hbmRfZ3JvdXAgYWxpc3QgfmNvbXBhcmUgPVxuICAgIHNvcnRfYW5kX2dyb3VwIGFsaXN0IH5jb21wYXJlOihmdW4gKHgsIF8pICh5LCBfKSAtPiBjb21wYXJlIHggeSlcbiAgICB8PiBtYXAgfmY6cGFpcl9vZl9ncm91cFxuICA7O1xuXG4gIGxldCBmaW5kIHQgfmVxdWFsIGtleSA9XG4gICAgbWF0Y2ggZmluZCB0IH5mOihmdW4gKGtleScsIF8pIC0+IGVxdWFsIGtleSBrZXknKSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBTb21lIChzbmQgeClcbiAgOztcblxuICBsZXQgZmluZF9leG4gPVxuICAgIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuQXNzb2MuZmluZF9leG46IG5vdCBmb3VuZFwiKSBpblxuICAgIGxldCByZWMgZmluZF9leG4gdCB+ZXF1YWwga2V5ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiByYWlzZSBub3RfZm91bmRcbiAgICAgIHwgKGtleScsIHZhbHVlKSA6OiB0IC0+IGlmIGVxdWFsIGtleSBrZXknIHRoZW4gdmFsdWUgZWxzZSBmaW5kX2V4biB0IH5lcXVhbCBrZXlcbiAgICBpblxuICAgICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgICBmaW5kX2V4blxuICA7O1xuXG4gIGxldCBtZW0gdCB+ZXF1YWwga2V5ID1cbiAgICBtYXRjaCBmaW5kIHQgfmVxdWFsIGtleSB3aXRoXG4gICAgfCBOb25lIC0+IGZhbHNlXG4gICAgfCBTb21lIF8gLT4gdHJ1ZVxuICA7O1xuXG4gIGxldCByZW1vdmUgdCB+ZXF1YWwga2V5ID0gZmlsdGVyIHQgfmY6KGZ1biAoa2V5JywgXykgLT4gbm90IChlcXVhbCBrZXkga2V5JykpIFtAbm9udGFpbF1cblxuICBsZXQgYWRkIHQgfmVxdWFsIGtleSB2YWx1ZSA9XG4gICAgKCogdGhlIHJlbW92ZSBkb2Vzbid0IGNoYW5nZSB0aGUgbWFwIHNlbWFudGljcywgYnV0IGtlZXBzIHRoZSBsaXN0IHNtYWxsICopXG4gICAgKGtleSwgdmFsdWUpIDo6IHJlbW92ZSB0IH5lcXVhbCBrZXlcbiAgOztcblxuICBsZXQgaW52ZXJzZSB0ID0gbWFwIHQgfmY6KGZ1biAoeCwgeSkgLT4geSwgeClcbiAgbGV0IG1hcCB0IH5mID0gbWFwIHQgfmY6KGZ1biAoa2V5LCB2YWx1ZSkgLT4ga2V5LCBmIHZhbHVlKSBbQG5vbnRhaWxdXG5lbmRcblxubGV0IHN1YiBsIH5wb3MgfmxlbiA9XG4gICgqIFdlIHVzZSBbcG9zID4gbGVuZ3RoIGwgLSBsZW5dIHJhdGhlciB0aGFuIFtwb3MgKyBsZW4gPiBsZW5ndGggbF0gdG8gYXZvaWQgdGhlXG4gICAgIHBvc3NpYmlsaXR5IG9mIG92ZXJmbG93LiAqKVxuICBpZiBwb3MgPCAwIHx8IGxlbiA8IDAgfHwgcG9zID4gbGVuZ3RoIGwgLSBsZW4gdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3Quc3ViXCI7XG4gIGxldCBzdG9wID0gcG9zICsgbGVuIGluXG4gIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIGxvb3AgaSBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IFtdXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgaWYgaSA8IHBvcyB0aGVuIGxvb3AgKGkgKyAxKSB0bCBlbHNlIGlmIGkgPCBzdG9wIHRoZW4gaGQgOjogbG9vcCAoaSArIDEpIHRsIGVsc2UgW11cbiAgaW5cbiAgbG9vcCAwIGwgW0Bub250YWlsXVxuOztcblxubGV0IHNwbGl0X24gdF9vcmlnIG4gPVxuICBpZiBuIDw9IDBcbiAgdGhlbiBbXSwgdF9vcmlnXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbG9vcCBuIHQgYWNjdW0gPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IHRfb3JpZywgW10gKCogaW4gdGhpcyBjYXNlLCB0X29yaWcgPSByZXYgYWNjdW0gKilcbiAgICAgIHwgaGQgOjogdGwgLT4gaWYgbiA9IDAgdGhlbiByZXYgYWNjdW0sIHQgZWxzZSBsb29wIChuIC0gMSkgdGwgKGhkIDo6IGFjY3VtKVxuICAgIGluXG4gICAgbG9vcCBuIHRfb3JpZyBbXSlcbjs7XG5cbigqIGNvcGllZCBmcm9tIFtzcGxpdF9uXSB0byBhdm9pZCBhbGxvY2F0aW5nIGEgdHVwbGUgKilcbmxldCB0YWtlIHRfb3JpZyBuID1cbiAgaWYgbiA8PSAwXG4gIHRoZW4gW11cbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIG4gdCBhY2N1bSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgW10gLT4gdF9vcmlnXG4gICAgICB8IGhkIDo6IHRsIC0+IGlmIG4gPSAwIHRoZW4gcmV2IGFjY3VtIGVsc2UgbG9vcCAobiAtIDEpIHRsIChoZCA6OiBhY2N1bSlcbiAgICBpblxuICAgIGxvb3AgbiB0X29yaWcgW10pXG47O1xuXG5sZXQgcmVjIGRyb3AgdCBuID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgXyA6OiB0bCB3aGVuIG4gPiAwIC0+IGRyb3AgdGwgKG4gLSAxKVxuICB8IHQgLT4gdFxuOztcblxubGV0IGNodW5rc19vZiBsIH5sZW5ndGggPVxuICBpZiBsZW5ndGggPD0gMCB0aGVuIGludmFsaWRfYXJnZiBcIkxpc3QuY2h1bmtzX29mOiBFeHBlY3RlZCBsZW5ndGggPiAwLCBnb3QgJWRcIiBsZW5ndGggKCk7XG4gIGxldCByZWMgYXV4IGxlbmd0aCBhY2MgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiByZXYgYWNjXG4gICAgfCBfIDo6IF8gLT5cbiAgICAgIGxldCBzdWJsaXN0LCBsID0gc3BsaXRfbiBsIGxlbmd0aCBpblxuICAgICAgYXV4IGxlbmd0aCAoc3VibGlzdCA6OiBhY2MpIGxcbiAgaW5cbiAgYXV4IGxlbmd0aCBbXSBsXG47O1xuXG5sZXQgc3BsaXRfd2hpbGUgeHMgfmYgPVxuICBsZXQgcmVjIGxvb3AgYWNjID0gZnVuY3Rpb25cbiAgICB8IGhkIDo6IHRsIHdoZW4gZiBoZCAtPiBsb29wIChoZCA6OiBhY2MpIHRsXG4gICAgfCB0IC0+IHJldiBhY2MsIHRcbiAgaW5cbiAgbG9vcCBbXSB4cyBbQG5vbnRhaWxdXG47O1xuXG4oKiBjb3BpZWQgZnJvbSBbc3BsaXRfd2hpbGVdIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSB0dXBsZSAqKVxubGV0IHRha2Vfd2hpbGUgeHMgfmYgPVxuICBsZXQgcmVjIGxvb3AgYWNjID0gZnVuY3Rpb25cbiAgICB8IGhkIDo6IHRsIHdoZW4gZiBoZCAtPiBsb29wIChoZCA6OiBhY2MpIHRsXG4gICAgfCBfIC0+IHJldiBhY2NcbiAgaW5cbiAgbG9vcCBbXSB4cyBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcmVjIGRyb3Bfd2hpbGUgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IGhkIDo6IHRsIHdoZW4gZiBoZCAtPiBkcm9wX3doaWxlIHRsIH5mXG4gIHwgdCAtPiB0XG47O1xuXG5sZXQgZHJvcF9sYXN0IHQgPVxuICBtYXRjaCByZXYgdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IF8gOjogbHN0IC0+IFNvbWUgKHJldiBsc3QpXG47O1xuXG5sZXQgZHJvcF9sYXN0X2V4biB0ID1cbiAgbWF0Y2ggZHJvcF9sYXN0IHQgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJMaXN0LmRyb3BfbGFzdF9leG46IGVtcHR5IGxpc3RcIlxuICB8IFNvbWUgbHN0IC0+IGxzdFxuOztcblxubGV0IGNhcnRlc2lhbl9wcm9kdWN0IGxpc3QxIGxpc3QyID1cbiAgaWYgaXNfZW1wdHkgbGlzdDJcbiAgdGhlbiBbXVxuICBlbHNlIChcbiAgICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBvdXRlcl9sb29wIGwxID1cbiAgICAgIG1hdGNoIGwxIHdpdGhcbiAgICAgIHwgW10gLT4gW11cbiAgICAgIHwgeDEgOjogbDEgLT4gaW5uZXJfbG9vcCB4MSBsMSBsaXN0MlxuICAgIGFuZFtAdGFpbF9tb2RfY29uc10gaW5uZXJfbG9vcCB4MSBsMSBsMiA9XG4gICAgICBtYXRjaCBsMiB3aXRoXG4gICAgICB8IFtdIC0+IG91dGVyX2xvb3AgbDFcbiAgICAgIHwgeDIgOjogbDIgLT4gKHgxLCB4MikgOjogaW5uZXJfbG9vcCB4MSBsMSBsMlxuICAgIGluXG4gICAgb3V0ZXJfbG9vcCBsaXN0MSBbQG5vbnRhaWxdKVxuOztcblxubGV0IGNvbmNhdCBsID0gZm9sZF9yaWdodCBsIH5pbml0OltdIH5mOmFwcGVuZFxubGV0IGNvbmNhdF9ub19vcmRlciBsID0gZm9sZCBsIH5pbml0OltdIH5mOihmdW4gYWNjIGwgLT4gcmV2X2FwcGVuZCBsIGFjYylcbmxldCBjb25zIHggbCA9IHggOjogbFxuXG5sZXQgaXNfc29ydGVkIGwgfmNvbXBhcmUgPVxuICBsZXQgcmVjIGxvb3AgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSB8IFsgXyBdIC0+IHRydWVcbiAgICB8IHgxIDo6ICh4MiA6OiBfIGFzIHJlc3QpIC0+IGNvbXBhcmUgeDEgeDIgPD0gMCAmJiBsb29wIHJlc3RcbiAgaW5cbiAgbG9vcCBsIFtAbm9udGFpbF1cbjs7XG5cbmxldCBpc19zb3J0ZWRfc3RyaWN0bHkgbCB+Y29tcGFyZSA9XG4gIGxldCByZWMgbG9vcCBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIHwgWyBfIF0gLT4gdHJ1ZVxuICAgIHwgeDEgOjogKHgyIDo6IF8gYXMgcmVzdCkgLT4gY29tcGFyZSB4MSB4MiA8IDAgJiYgbG9vcCByZXN0XG4gIGluXG4gIGxvb3AgbCBbQG5vbnRhaWxdXG47O1xuXG5tb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgbGV0ICggQCApID0gYXBwZW5kXG5lbmRcblxubGV0IHBlcm11dGUgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbGlzdCA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICAoKiBzcGVjaWFsIGNhc2VzIHRvIHNwZWVkIHRoaW5ncyB1cCBpbiB0cml2aWFsIGNhc2VzICopXG4gIHwgW10gfCBbIF8gXSAtPiBsaXN0XG4gIHwgWyB4OyB5IF0gLT4gaWYgUmFuZG9tLlN0YXRlLmJvb2wgcmFuZG9tX3N0YXRlIHRoZW4gWyB5OyB4IF0gZWxzZSBsaXN0XG4gIHwgXyAtPlxuICAgIGxldCBhcnIgPSBBcnJheS5vZl9saXN0IGxpc3QgaW5cbiAgICBBcnJheV9wZXJtdXRlLnBlcm11dGUgYXJyIH5yYW5kb21fc3RhdGU7XG4gICAgQXJyYXkudG9fbGlzdCBhcnJcbjs7XG5cbmxldCByYW5kb21fZWxlbWVudF9leG4gPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbGlzdCA9XG4gIGlmIGlzX2VtcHR5IGxpc3RcbiAgdGhlbiBmYWlsd2l0aCBcIkxpc3QucmFuZG9tX2VsZW1lbnRfZXhuOiBlbXB0eSBsaXN0XCJcbiAgZWxzZSBudGhfZXhuIGxpc3QgKFJhbmRvbS5TdGF0ZS5pbnQgcmFuZG9tX3N0YXRlIChsZW5ndGggbGlzdCkpXG47O1xuXG5sZXQgcmFuZG9tX2VsZW1lbnQgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbGlzdCA9XG4gIHRyeSBTb21lIChyYW5kb21fZWxlbWVudF9leG4gfnJhbmRvbV9zdGF0ZSBsaXN0KSB3aXRoXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgcmVjIGNvbXBhcmUgY21wIGEgYiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgIGxldCBuID0gY21wIHggeSBpblxuICAgIGlmIG4gPSAwIHRoZW4gY29tcGFyZSBjbXAgeHMgeXMgZWxzZSBuXG47O1xuXG5sZXQgcmVjIGNvbXBhcmVfX2xvY2FsIGNtcCBhIGIgPVxuICBtYXRjaCBhLCBiIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfIC0+IC0xXG4gIHwgXywgW10gLT4gMVxuICB8IHggOjogeHMsIHkgOjogeXMgLT5cbiAgICBsZXQgbiA9IGNtcCB4IHkgaW5cbiAgICBpZiBuID0gMCB0aGVuIGNvbXBhcmVfX2xvY2FsIGNtcCB4cyB5cyBlbHNlIG5cbjs7XG5cbmxldCBoYXNoX2ZvbGRfdCA9IGhhc2hfZm9sZF9saXN0XG5cbmxldCBlcXVhbF93aXRoX2xvY2FsX2Nsb3N1cmUgKGVxdWFsIDogXyAtPiBfIC0+IF8pIHQxIHQyID1cbiAgbGV0IHJlYyBsb29wIH5lcXVhbCB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IFtdLCBbXSAtPiB0cnVlXG4gICAgfCB4MSA6OiB0MSwgeDIgOjogdDIgLT4gZXF1YWwgeDEgeDIgJiYgbG9vcCB+ZXF1YWwgdDEgdDJcbiAgICB8IF8gLT4gZmFsc2VcbiAgaW5cbiAgbG9vcCB+ZXF1YWwgdDEgdDJcbjs7XG5cbmxldCBlcXVhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPVxuICBmdW4gZiB4IHkgLT4gZXF1YWxfd2l0aF9sb2NhbF9jbG9zdXJlIGYgeCB5XG47O1xuXG5sZXQgZXF1YWxfX2xvY2FsIGVxdWFsX2FfX2xvY2FsIHQxIHQyID1cbiAgbGV0IHJlYyBsb29wIH5lcXVhbF9hX19sb2NhbCB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IFtdLCBbXSAtPiB0cnVlXG4gICAgfCB4MSA6OiB0MSwgeDIgOjogdDIgLT4gZXF1YWxfYV9fbG9jYWwgeDEgeDIgJiYgbG9vcCB+ZXF1YWxfYV9fbG9jYWwgdDEgdDJcbiAgICB8IF8gLT4gZmFsc2VcbiAgaW5cbiAgbG9vcCB+ZXF1YWxfYV9fbG9jYWwgdDEgdDIgW0Bub250YWlsXVxuOztcblxubGV0IHRyYW5zcG9zZSA9XG4gIGxldCByZWMgc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiB0IGNvbHVtbl9hY2MgdHJpbW1lZCBmb3VuZF9lbXB0eSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBjb2x1bW5fYWNjLCB0cmltbWVkLCBmb3VuZF9lbXB0eVxuICAgIHwgW10gOjogdGwgLT4gc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiB0bCBjb2x1bW5fYWNjIHRyaW1tZWQgdHJ1ZVxuICAgIHwgKHggOjogeHMpIDo6IHRsIC0+XG4gICAgICBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHRsICh4IDo6IGNvbHVtbl9hY2MpICh4cyA6OiB0cmltbWVkKSBmb3VuZF9lbXB0eVxuICBpblxuICBsZXQgc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiByb3dzID0gc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiByb3dzIFtdIFtdIGZhbHNlIGluXG4gIGxldCByZWMgbG9vcCByb3dzIGNvbHVtbnMgZG9fcmV2ID1cbiAgICBtYXRjaCBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHJvd3Mgd2l0aFxuICAgIHwgW10sIFtdLCBfIC0+IFNvbWUgKHJldiBjb2x1bW5zKVxuICAgIHwgY29sdW1uLCB0cmltbWVkX3Jvd3MsIGZvdW5kX2VtcHR5IC0+XG4gICAgICBpZiBmb3VuZF9lbXB0eVxuICAgICAgdGhlbiBOb25lXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGNvbHVtbiA9IGlmIGRvX3JldiB0aGVuIHJldiBjb2x1bW4gZWxzZSBjb2x1bW4gaW5cbiAgICAgICAgbG9vcCB0cmltbWVkX3Jvd3MgKGNvbHVtbiA6OiBjb2x1bW5zKSAobm90IGRvX3JldikpXG4gIGluXG4gIGZ1biB0IC0+IGxvb3AgdCBbXSB0cnVlXG47O1xuXG5leGNlcHRpb24gVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3RocyBvZiBpbnQgbGlzdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgWyVleHRlbnNpb25fY29uc3RydWN0b3IgVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3Roc11cbiAgICAoZnVuY3Rpb25cbiAgICB8IFRyYW5zcG9zZV9nb3RfbGlzdHNfb2ZfZGlmZmVyZW50X2xlbmd0aHMgYXJnMF9fMDQ1XyAtPlxuICAgICAgbGV0IHJlczBfXzA0Nl8gPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl9pbnQgYXJnMF9fMDQ1XyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibGlzdC5tbC5UcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzXCJcbiAgICAgICAgOyByZXMwX18wNDZfXG4gICAgICAgIF1cbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuOztcblxuW0BAQGVuZF1cblxubGV0IHRyYW5zcG9zZV9leG4gbCA9XG4gIG1hdGNoIHRyYW5zcG9zZSBsIHdpdGhcbiAgfCBTb21lIGwgLT4gbFxuICB8IE5vbmUgLT4gcmFpc2UgKFRyYW5zcG9zZV9nb3RfbGlzdHNfb2ZfZGlmZmVyZW50X2xlbmd0aHMgKG1hcCBsIH5mOihsZW5ndGggOj4gXyAtPiBfKSkpXG47O1xuXG5sZXQgaW50ZXJzcGVyc2UgdCB+c2VwID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCB4IDo6IHhzIC0+IHggOjogZm9sZF9yaWdodCB4cyB+aW5pdDpbXSB+ZjooZnVuIHkgYWNjIC0+IHNlcCA6OiB5IDo6IGFjYylcbjs7XG5cbmxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbmxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHQgfmZpbmlzaFxuXG5sZXQgaXNfc3VmZml4IGxpc3QgfnN1ZmZpeCB+ZXF1YWw6KGVxdWFsX2VsdCA6IF8gLT4gXyAtPiBfKSA9XG4gIGxldCBsaXN0X2xlbiA9IGxlbmd0aCBsaXN0IGluXG4gIGxldCBzdWZmaXhfbGVuID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBsaXN0X2xlbiA+PSBzdWZmaXhfbGVuXG4gICYmIGVxdWFsX3dpdGhfbG9jYWxfY2xvc3VyZSBlcXVhbF9lbHQgKGRyb3AgbGlzdCAobGlzdF9sZW4gLSBzdWZmaXhfbGVuKSkgc3VmZml4XG47O1xuIiwiKCogVGhpcyBtb2R1bGUgaXMgdHJ5aW5nIHRvIG1pbmltaXplIGRlcGVuZGVuY2llcyBvbiBtb2R1bGVzIGluIENvcmUsIHNvIGFzIHRvIGFsbG93XG4gICBbSW5mb10sIFtFcnJvcl0sIGFuZCBbT3JfZXJyb3JdIHRvIGJlIHVzZWQgaW4gYXMgbWFueSBwbGFjZXMgYXMgcG9zc2libGUuIFBsZWFzZSBhdm9pZFxuICAgYWRkaW5nIG5ldyBkZXBlbmRlbmNpZXMuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbmZvX2ludGZcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5cbm1vZHVsZSBNZXNzYWdlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IG9mIFNleHAudFxuICAgIHwgU3RyaW5nIG9mIHN0cmluZ1xuICAgIHwgRXhuIG9mIGV4blxuICAgIHwgU2V4cCBvZiBTZXhwLnRcbiAgICB8IFRhZ19zZXhwIG9mIHN0cmluZyAqIFNleHAudCAqIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC50IG9wdGlvblxuICAgIHwgVGFnX3Qgb2Ygc3RyaW5nICogdFxuICAgIHwgVGFnX2FyZyBvZiBzdHJpbmcgKiBTZXhwLnQgKiB0XG4gICAgfCBPZl9saXN0IG9mIGludCBvcHRpb24gKiB0IGxpc3RcbiAgICB8IFdpdGhfYmFja3RyYWNlIG9mIHQgKiBzdHJpbmcgKCogYmFja3RyYWNlICopXG4gIFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIGxldCByZWMgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IGFyZzBfXzAwMV8gLT5cbiAgICAgICBsZXQgcmVzMF9fMDAyXyA9IFNleHAuc2V4cF9vZl90IGFyZzBfXzAwMV8gaW5cbiAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJDb3VsZF9ub3RfY29uc3RydWN0XCI7IHJlczBfXzAwMl8gXVxuICAgICB8IFN0cmluZyBhcmcwX18wMDNfIC0+XG4gICAgICAgbGV0IHJlczBfXzAwNF8gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMDNfIGluXG4gICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiU3RyaW5nXCI7IHJlczBfXzAwNF8gXVxuICAgICB8IEV4biBhcmcwX18wMDVfIC0+XG4gICAgICAgbGV0IHJlczBfXzAwNl8gPSBzZXhwX29mX2V4biBhcmcwX18wMDVfIGluXG4gICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXhuXCI7IHJlczBfXzAwNl8gXVxuICAgICB8IFNleHAgYXJnMF9fMDA3XyAtPlxuICAgICAgIGxldCByZXMwX18wMDhfID0gU2V4cC5zZXhwX29mX3QgYXJnMF9fMDA3XyBpblxuICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlNleHBcIjsgcmVzMF9fMDA4XyBdXG4gICAgIHwgVGFnX3NleHAgKGFyZzBfXzAwOV8sIGFyZzFfXzAxMF8sIGFyZzJfXzAxMV8pIC0+XG4gICAgICAgbGV0IHJlczBfXzAxMl8gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMDlfXG4gICAgICAgYW5kIHJlczFfXzAxM18gPSBTZXhwLnNleHBfb2ZfdCBhcmcxX18wMTBfXG4gICAgICAgYW5kIHJlczJfXzAxNF8gPSBzZXhwX29mX29wdGlvbiBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90IGFyZzJfXzAxMV8gaW5cbiAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVGFnX3NleHBcIjsgcmVzMF9fMDEyXzsgcmVzMV9fMDEzXzsgcmVzMl9fMDE0XyBdXG4gICAgIHwgVGFnX3QgKGFyZzBfXzAxNV8sIGFyZzFfXzAxNl8pIC0+XG4gICAgICAgbGV0IHJlczBfXzAxN18gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMTVfXG4gICAgICAgYW5kIHJlczFfXzAxOF8gPSBzZXhwX29mX3QgYXJnMV9fMDE2XyBpblxuICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlRhZ190XCI7IHJlczBfXzAxN187IHJlczFfXzAxOF8gXVxuICAgICB8IFRhZ19hcmcgKGFyZzBfXzAxOV8sIGFyZzFfXzAyMF8sIGFyZzJfXzAyMV8pIC0+XG4gICAgICAgbGV0IHJlczBfXzAyMl8gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMTlfXG4gICAgICAgYW5kIHJlczFfXzAyM18gPSBTZXhwLnNleHBfb2ZfdCBhcmcxX18wMjBfXG4gICAgICAgYW5kIHJlczJfXzAyNF8gPSBzZXhwX29mX3QgYXJnMl9fMDIxXyBpblxuICAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJUYWdfYXJnXCI7IHJlczBfXzAyMl87IHJlczFfXzAyM187IHJlczJfXzAyNF8gXVxuICAgICB8IE9mX2xpc3QgKGFyZzBfXzAyNV8sIGFyZzFfXzAyNl8pIC0+XG4gICAgICAgbGV0IHJlczBfXzAyN18gPSBzZXhwX29mX29wdGlvbiBzZXhwX29mX2ludCBhcmcwX18wMjVfXG4gICAgICAgYW5kIHJlczFfXzAyOF8gPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl90IGFyZzFfXzAyNl8gaW5cbiAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJPZl9saXN0XCI7IHJlczBfXzAyN187IHJlczFfXzAyOF8gXVxuICAgICB8IFdpdGhfYmFja3RyYWNlIChhcmcwX18wMjlfLCBhcmcxX18wMzBfKSAtPlxuICAgICAgIGxldCByZXMwX18wMzFfID0gc2V4cF9vZl90IGFyZzBfXzAyOV9cbiAgICAgICBhbmQgcmVzMV9fMDMyXyA9IHNleHBfb2Zfc3RyaW5nIGFyZzFfXzAzMF8gaW5cbiAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJXaXRoX2JhY2t0cmFjZVwiOyByZXMwX18wMzFfOyByZXMxX18wMzJfIF1cbiAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgcmVjIHRvX3NleHBzX2h1bSB0IGFjID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IENvdWxkX25vdF9jb25zdHJ1Y3QgXyBhcyB0IC0+IHNleHBfb2ZfdCB0IDo6IGFjXG4gICAgfCBTdHJpbmcgc3RyaW5nIC0+IEF0b20gc3RyaW5nIDo6IGFjXG4gICAgfCBFeG4gZXhuIC0+IEV4bi5zZXhwX29mX3QgZXhuIDo6IGFjXG4gICAgfCBTZXhwIHNleHAgLT4gc2V4cCA6OiBhY1xuICAgIHwgVGFnX3NleHAgKHRhZywgc2V4cCwgaGVyZSkgLT5cbiAgICAgIExpc3RcbiAgICAgICAgKEF0b20gdGFnXG4gICAgICAgICA6OiBzZXhwXG4gICAgICAgICA6OlxuICAgICAgICAgKG1hdGNoIGhlcmUgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBbXVxuICAgICAgICAgIHwgU29tZSBoZXJlIC0+IFsgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdCBoZXJlIF0pKVxuICAgICAgOjogYWNcbiAgICB8IFRhZ190ICh0YWcsIHQpIC0+IExpc3QgKEF0b20gdGFnIDo6IHRvX3NleHBzX2h1bSB0IFtdKSA6OiBhY1xuICAgIHwgVGFnX2FyZyAodGFnLCBzZXhwLCB0KSAtPlxuICAgICAgbGV0IGJvZHkgPSBzZXhwIDo6IHRvX3NleHBzX2h1bSB0IFtdIGluXG4gICAgICBpZiBTdHJpbmcubGVuZ3RoIHRhZyA9IDAgdGhlbiBMaXN0IGJvZHkgOjogYWMgZWxzZSBMaXN0IChBdG9tIHRhZyA6OiBib2R5KSA6OiBhY1xuICAgIHwgV2l0aF9iYWNrdHJhY2UgKHQsIGJhY2t0cmFjZSkgLT5cbiAgICAgIFNleHAuTGlzdFxuICAgICAgICBbIHRvX3NleHBfaHVtIHQ7IHNleHBfb2ZfbGlzdCBzZXhwX29mX3N0cmluZyAoU3RyaW5nLnNwbGl0X2xpbmVzIGJhY2t0cmFjZSkgXVxuICAgICAgOjogYWNcbiAgICB8IE9mX2xpc3QgKF8sIHRzKSAtPlxuICAgICAgTGlzdC5mb2xkIChMaXN0LnJldiB0cykgfmluaXQ6YWMgfmY6KGZ1biBhYyB0IC0+IHRvX3NleHBzX2h1bSB0IGFjKVxuXG4gIGFuZCB0b19zZXhwX2h1bSB0ID1cbiAgICBtYXRjaCB0b19zZXhwc19odW0gdCBbXSB3aXRoXG4gICAgfCBbIHNleHAgXSAtPiBzZXhwXG4gICAgfCBzZXhwcyAtPiBTZXhwLkxpc3Qgc2V4cHNcbiAgOztcbmVuZFxuXG5vcGVuIE1lc3NhZ2VcblxubW9kdWxlIENvbXB1dGVkID0gc3RydWN0XG4gICgqIE1lbW9pemVkLCBsYXppbHktY29tcHV0ZWQgcmVwcmVzZW50YXRpb24gb2YgbWVzc2FnZXMuIE1haW50YWlucyBpdHMgb3duIHN0YXRlIHRvXG4gICAgIGF2b2lkIHN0YWNrIG92ZXJmbG93IGZyb20gbmVzdGVkIFtMYXp5LnRdLiAqKVxuXG4gICgqIFdlIHVzZSBhIGdsb2JhbCBbc3RhdGUgcmVmXSBzbyB3ZSBjYW4gbXV0YXRlIFtzdGF0ZV0sIGJ1dCBzdGlsbCBbZ2xvYmFsaXplXSB3aXRoIG5vXG4gICAgIGNvc3QgYW5kIHdpdGhvdXQgZHVwbGljYXRpbmcgc3RhdGUuICopXG4gIHR5cGUgaW5mbyA9IHsgc3RhdGUgOiBzdGF0ZSByZWYgfSBbQEB1bmJveGVkXVxuXG4gICgqIEFuIFtpbmZvXSBzdGFydHMgYXMgYSBbY29uc3RydWN0b3JdLiBXaGVuIGZvcmNlZCwgaXQgaXMgbWFya2VkIFtDb21wdXRpbmddIHRvIGF2b2lkXG4gICAgIGN5Y2xlcy4gV2hlbiBmaW5pc2hlZCwgdGhlIGZpbmFsIFttZXNzYWdlXSBpcyByZWNvcmRlZC4gKilcbiAgYW5kIHN0YXRlID1cbiAgICB8IEluaXRpYWwgb2YgY29uc3RydWN0b3JcbiAgICB8IENvbXB1dGluZ1xuICAgIHwgRmluYWwgb2YgTWVzc2FnZS50XG5cbiAgKCogUmVjdXJzaXZlIGNvbnN0cnVjdG9ycyBmb3IgW0luZm8udF0uIE90aGVycyBjYW4gYmUgYnVpbHQgZGlyZWN0bHkgYXMgW01lc3NhZ2UudF0uICopXG4gIGFuZCBjb25zdHJ1Y3RvciA9XG4gICAgfCBDb25zX2xhenlfaW5mbyBvZiBpbmZvIExhenkudFxuICAgIHwgQ29uc19saXN0IG9mIGluZm8gbGlzdFxuICAgIHwgQ29uc190YWdfYXJnIG9mIHN0cmluZyAqIFNleHAudCAqIGluZm9cbiAgICB8IENvbnNfdGFnX3Qgb2Ygc3RyaW5nICogaW5mb1xuXG4gICgqIFRoaXMgaXMgYSBuby1vcCwgc2luY2UgW2luZm9dIGlzIHVuYm94ZWQuICopXG4gIGxldCBnbG9iYWxpemVfaW5mbyB7IHN0YXRlIH0gPSB7IHN0YXRlIH1cblxuICAoKiBXZSBrZWVwIGEgbGlzdCBvZiBzdGFja19mcmFtZXMgd2hpbGUgY29tcHV0aW5nLCByYXRoZXIgdGhhbiB1c2luZyB0aGUgY2FsbCBzdGFjay4gKilcbiAgdHlwZSBzdGFja19mcmFtZSA9XG4gICAgfCBJbl9pbmZvIG9mIGluZm9cbiAgICB8IEluX3RhZ19hcmcgb2Ygc3RyaW5nICogU2V4cC50XG4gICAgfCBJbl90YWdfdCBvZiBzdHJpbmdcbiAgICB8IEluX2xpc3Qgb2ZcbiAgICAgICAgeyBmd2RfcHJlZml4IDogaW5mbyBsaXN0XG4gICAgICAgIDsgcmV2X3N1ZmZpeCA6IE1lc3NhZ2UudCBsaXN0XG4gICAgICAgIH1cblxuICAoKiBUaGUgZm9sbG93aW5nIG11dHVhbGx5LXJlY3Vyc2l2ZSBmdW5jdGlvbnMgY29tcHV0ZSBhIFtNZXNzYWdlLnRdIGZyb20gYW4gW2luZm9dLlxuICAgICBBbGwgY2FsbHMgYmVsb3cgYXJlIHRhaWwgY2FsbHM6IHdlIHdhbnQgdG8gYXZvaWQgdXNpbmcgdGhlIGNhbGwgc3RhY2sgaW4gZmF2b3JcbiAgICAgb2Ygb3VyIG93biBtYW51YWwgc3RhY2suICopXG4gIGxldCByZWMgY29tcHV0ZV9pbmZvIGluZm8gc3RhY2sgPVxuICAgIG1hdGNoICEoaW5mby5zdGF0ZSkgd2l0aFxuICAgIHwgSW5pdGlhbCBjb25zIC0+XG4gICAgICBpbmZvLnN0YXRlIDo9IENvbXB1dGluZztcbiAgICAgIGNvbXB1dGVfY29uc3RydWN0b3IgY29ucyAoSW5faW5mbyBpbmZvIDo6IHN0YWNrKVxuICAgIHwgQ29tcHV0aW5nIC0+XG4gICAgICBjb21wdXRlX21lc3NhZ2UgKENvdWxkX25vdF9jb25zdHJ1Y3QgKEF0b20gXCJjeWNsZSB3aGlsZSBjb21wdXRpbmcgbWVzc2FnZVwiKSkgc3RhY2tcbiAgICB8IEZpbmFsIG1lc3NhZ2UgLT4gY29tcHV0ZV9tZXNzYWdlIG1lc3NhZ2Ugc3RhY2tcblxuICBhbmQgY29tcHV0ZV9pbmZvX2xpc3QgfmZ3ZF9wcmVmaXggfnJldl9zdWZmaXggc3RhY2sgPVxuICAgIG1hdGNoIGZ3ZF9wcmVmaXggd2l0aFxuICAgIHwgaW5mbyA6OiBmd2RfcHJlZml4IC0+IGNvbXB1dGVfaW5mbyBpbmZvIChJbl9saXN0IHsgZndkX3ByZWZpeDsgcmV2X3N1ZmZpeCB9IDo6IHN0YWNrKVxuICAgIHwgW10gLT5cbiAgICAgIGxldCBpbmZvcyA9XG4gICAgICAgIExpc3QuZm9sZCByZXZfc3VmZml4IH5pbml0OltdIH5mOihmdW4gdGFpbCBtZXNzYWdlIC0+XG4gICAgICAgICAgbWF0Y2ggbWVzc2FnZSB3aXRoXG4gICAgICAgICAgfCBPZl9saXN0IChfLCBtZXNzYWdlcykgLT4gbWVzc2FnZXMgQCB0YWlsXG4gICAgICAgICAgfCBfIC0+IG1lc3NhZ2UgOjogdGFpbClcbiAgICAgIGluXG4gICAgICBjb21wdXRlX21lc3NhZ2UgKE9mX2xpc3QgKE5vbmUsIGluZm9zKSkgc3RhY2tcblxuICBhbmQgY29tcHV0ZV9jb25zdHJ1Y3RvciBjb25zIHN0YWNrID1cbiAgICBtYXRjaCBjb25zIHdpdGhcbiAgICB8IENvbnNfdGFnX2FyZyAodGFnLCBhcmcsIGluZm8pIC0+IGNvbXB1dGVfaW5mbyBpbmZvIChJbl90YWdfYXJnICh0YWcsIGFyZykgOjogc3RhY2spXG4gICAgfCBDb25zX3RhZ190ICh0YWcsIGluZm8pIC0+IGNvbXB1dGVfaW5mbyBpbmZvIChJbl90YWdfdCB0YWcgOjogc3RhY2spXG4gICAgfCBDb25zX2xpc3QgaW5mb3MgLT4gY29tcHV0ZV9pbmZvX2xpc3QgfmZ3ZF9wcmVmaXg6aW5mb3MgfnJldl9zdWZmaXg6W10gc3RhY2tcbiAgICB8IENvbnNfbGF6eV9pbmZvIGxhenlfaW5mbyAtPlxuICAgICAgKG1hdGNoIExhenkuZm9yY2UgbGF6eV9pbmZvIHdpdGhcbiAgICAgICB8IGluZm8gLT4gY29tcHV0ZV9pbmZvIGluZm8gc3RhY2tcbiAgICAgICB8IGV4Y2VwdGlvbiBleG4gLT4gY29tcHV0ZV9tZXNzYWdlIChDb3VsZF9ub3RfY29uc3RydWN0IChFeG4uc2V4cF9vZl90IGV4bikpIHN0YWNrKVxuXG4gIGFuZCBjb21wdXRlX21lc3NhZ2UgbWVzc2FnZSBzdGFjayA9XG4gICAgbWF0Y2ggc3RhY2sgd2l0aFxuICAgIHwgW10gLT4gbWVzc2FnZVxuICAgIHwgSW5faW5mbyBpbmZvIDo6IHN0YWNrIC0+XG4gICAgICBpbmZvLnN0YXRlIDo9IEZpbmFsIG1lc3NhZ2U7XG4gICAgICBjb21wdXRlX21lc3NhZ2UgbWVzc2FnZSBzdGFja1xuICAgIHwgSW5fdGFnX2FyZyAodGFnLCBhcmcpIDo6IHN0YWNrIC0+XG4gICAgICBjb21wdXRlX21lc3NhZ2UgKFRhZ19hcmcgKHRhZywgYXJnLCBtZXNzYWdlKSkgc3RhY2tcbiAgICB8IEluX3RhZ190IHRhZyA6OiBzdGFjayAtPiBjb21wdXRlX21lc3NhZ2UgKFRhZ190ICh0YWcsIG1lc3NhZ2UpKSBzdGFja1xuICAgIHwgSW5fbGlzdCB7IGZ3ZF9wcmVmaXg7IHJldl9zdWZmaXggfSA6OiBzdGFjayAtPlxuICAgICAgY29tcHV0ZV9pbmZvX2xpc3QgfmZ3ZF9wcmVmaXggfnJldl9zdWZmaXg6KG1lc3NhZ2UgOjogcmV2X3N1ZmZpeCkgc3RhY2tcbiAgOztcblxuICAoKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBjb252ZXJ0aW5nIGFuZCBjb25zdHJ1Y3RpbmcgW2luZm9dLiAqKVxuXG4gIGxldCB0b19tZXNzYWdlIGluZm8gPSBjb21wdXRlX2luZm8gaW5mbyBbXVxuICBsZXQgb2ZfbWVzc2FnZSBtZXNzYWdlID0geyBzdGF0ZSA9IHJlZiAoRmluYWwgbWVzc2FnZSkgfVxuXG4gIGxldCBpc19jb21wdXRlZCBpbmZvID1cbiAgICBtYXRjaCAhKGluZm8uc3RhdGUpIHdpdGhcbiAgICB8IEluaXRpYWwgXyB8IENvbXB1dGluZyAtPiBmYWxzZVxuICAgIHwgRmluYWwgXyAtPiB0cnVlXG4gIDs7XG5cbiAgbGV0IG9mX2NvbnMgY29ucyA9IHsgc3RhdGUgPSByZWYgKEluaXRpYWwgY29ucykgfVxuICBsZXQgb2ZfbGF6eV9pbmZvIGxhenlfaW5mbyA9IG9mX2NvbnMgKENvbnNfbGF6eV9pbmZvIGxhenlfaW5mbylcblxuICBsZXQgb2ZfbGF6eV9jb25zIGxhenlfY29ucyA9XG4gICAgb2ZfY29ucyAoQ29uc19sYXp5X2luZm8gKGxhenkgKG9mX2NvbnMgKExhenkuZm9yY2UgbGF6eV9jb25zKSkpKVxuICA7O1xuXG4gIGxldCBvZl9sYXp5X21lc3NhZ2UgbGF6eV9tZXNzYWdlID1cbiAgICBvZl9jb25zIChDb25zX2xhenlfaW5mbyAobGF6eSAob2ZfbWVzc2FnZSAoTGF6eS5mb3JjZSBsYXp5X21lc3NhZ2UpKSkpXG4gIDs7XG5lbmRcblxub3BlbiBDb21wdXRlZFxuXG50eXBlIHQgPSBDb21wdXRlZC5pbmZvXG5cbmxldCBnbG9iYWxpemUgPSBDb21wdXRlZC5nbG9iYWxpemVfaW5mb1xubGV0IGludmFyaWFudCBfID0gKClcblxuKCogSXQgaXMgT0sgdG8gdXNlIFtNZXNzYWdlLnRvX3NleHBfaHVtXSwgd2hpY2ggaXMgbm90IHN0YWJsZSwgYmVjYXVzZSBbdF9vZl9zZXhwXSBiZWxvd1xuICAgY2FuIGhhbmRsZSBhbnkgc2V4cC4gKilcbmxldCBzZXhwX29mX3QgdCA9IE1lc3NhZ2UudG9fc2V4cF9odW0gKHRvX21lc3NhZ2UgdClcbmxldCB0X29mX3NleHAgc2V4cCA9IG9mX21lc3NhZ2UgKE1lc3NhZ2UuU2V4cCBzZXhwKVxubGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0geyB1bnR5cGVkID0gQW55IFwiSW5mby50XCIgfVxubGV0IGNvbXBhcmUgdDEgdDIgPSBTZXhwLmNvbXBhcmUgKHNleHBfb2ZfdCB0MSkgKHNleHBfb2ZfdCB0MilcbmxldCBjb21wYXJlX19sb2NhbCB0MSB0MiA9IGNvbXBhcmUgKGdsb2JhbGl6ZSB0MSkgKGdsb2JhbGl6ZSB0MilcbmxldCBlcXVhbCB0MSB0MiA9IFNleHAuZXF1YWwgKHNleHBfb2ZfdCB0MSkgKHNleHBfb2ZfdCB0MilcbmxldCBlcXVhbF9fbG9jYWwgdDEgdDIgPSBlcXVhbCAoZ2xvYmFsaXplIHQxKSAoZ2xvYmFsaXplIHQyKVxubGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPSBTZXhwLmhhc2hfZm9sZF90IHN0YXRlIChzZXhwX29mX3QgdClcbmxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG5cbmxldCB0b19zdHJpbmdfaHVtIHQgPVxuICBtYXRjaCB0b19tZXNzYWdlIHQgd2l0aFxuICB8IFN0cmluZyBzIC0+IHNcbiAgfCBtZXNzYWdlIC0+IFNleHAudG9fc3RyaW5nX2h1bSAoTWVzc2FnZS50b19zZXhwX2h1bSBtZXNzYWdlKVxuOztcblxubGV0IHRvX3N0cmluZ19tYWNoIHQgPSBTZXhwLnRvX3N0cmluZ19tYWNoIChzZXhwX29mX3QgdClcbmxldCBvZl9sYXp5IGwgPSBvZl9sYXp5X21lc3NhZ2UgKGxhenkgKFN0cmluZyAoTGF6eS5mb3JjZSBsKSkpXG5sZXQgb2ZfbGF6eV9zZXhwIGwgPSBvZl9sYXp5X21lc3NhZ2UgKGxhenkgKFNleHAgKExhenkuZm9yY2UgbCkpKVxubGV0IG9mX2xhenlfdCBsYXp5X3QgPSBvZl9sYXp5X2luZm8gbGF6eV90XG5sZXQgb2Zfc3RyaW5nIG1lc3NhZ2UgPSBvZl9tZXNzYWdlIChTdHJpbmcgbWVzc2FnZSlcbmxldCBjcmVhdGVmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBvZl9zdHJpbmcgZm9ybWF0XG5sZXQgb2ZfdGh1bmsgZiA9IG9mX2xhenlfbWVzc2FnZSAobGF6eSAoU3RyaW5nIChmICgpKSkpXG5cbmxldCBjcmVhdGUgP2hlcmUgP3N0cmljdCB0YWcgeCBzZXhwX29mX3ggPVxuICBtYXRjaCBzdHJpY3Qgd2l0aFxuICB8IE5vbmUgLT4gb2ZfbGF6eV9tZXNzYWdlIChsYXp5IChUYWdfc2V4cCAodGFnLCBzZXhwX29mX3ggeCwgaGVyZSkpKVxuICB8IFNvbWUgKCkgLT4gb2ZfbWVzc2FnZSAoVGFnX3NleHAgKHRhZywgc2V4cF9vZl94IHgsIGhlcmUpKVxuOztcblxubGV0IGNyZWF0ZV9zIHNleHAgPSBvZl9tZXNzYWdlIChTZXhwIHNleHApXG5sZXQgdGFnIHQgfnRhZyA9IG9mX2NvbnMgKENvbnNfdGFnX3QgKHRhZywgdCkpXG5sZXQgdGFnX3NfbGF6eSB0IH50YWcgPSBvZl9sYXp5X2NvbnMgKGxhenkgKENvbnNfdGFnX2FyZyAoXCJcIiwgTGF6eS5mb3JjZSB0YWcsIHQpKSlcbmxldCB0YWdfcyB0IH50YWcgPSBvZl9jb25zIChDb25zX3RhZ19hcmcgKFwiXCIsIHRhZywgdCkpXG5sZXQgdGFnX2FyZyB0IHRhZyB4IHNleHBfb2ZfeCA9IG9mX2xhenlfY29ucyAobGF6eSAoQ29uc190YWdfYXJnICh0YWcsIHNleHBfb2ZfeCB4LCB0KSkpXG5sZXQgb2ZfbGlzdCB0cyA9IG9mX2NvbnMgKENvbnNfbGlzdCB0cylcblxuZXhjZXB0aW9uIEV4biBvZiB0XG5cbmxldCAoKSA9XG4gICgqIFdlIGluc3RhbGwgYSBjdXN0b20gZXhuLWNvbnZlcnRlciByYXRoZXIgdGhhbiB1c2VcbiAgICAgW2V4Y2VwdGlvbiBFeG4gb2YgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF0gLi4uIFtAQEBlbmRdXSB0byBlbGltaW5hdGUgdGhlIGV4dHJhXG4gICAgIHdyYXBwaW5nIG9mIFwiKEV4biAuLi4pXCIuICopXG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBFeG5dIChmdW5jdGlvblxuICAgIHwgRXhuIHQgLT4gc2V4cF9vZl90IHRcbiAgICB8IF8gLT5cbiAgICAgICgqIFJlYWNoaW5nIHRoaXMgYnJhbmNoIGluZGljYXRlcyBhIGJ1ZyBpbiBzZXhwbGliLiAqKVxuICAgICAgYXNzZXJ0IGZhbHNlKVxuOztcblxubGV0IHRvX2V4biB0ID1cbiAgaWYgbm90IChpc19jb21wdXRlZCB0KVxuICB0aGVuIEV4biB0XG4gIGVsc2UgKFxuICAgIG1hdGNoIHRvX21lc3NhZ2UgdCB3aXRoXG4gICAgfCBNZXNzYWdlLkV4biBleG4gLT4gZXhuXG4gICAgfCBfIC0+IEV4biB0KVxuOztcblxubGV0IG9mX2V4biA/YmFja3RyYWNlIGV4biA9XG4gIGxldCBiYWNrdHJhY2UgPVxuICAgIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgYEdldCAtPiBTb21lIChTdGRsaWIuUHJpbnRleGMuZ2V0X2JhY2t0cmFjZSAoKSlcbiAgICB8IFNvbWUgKGBUaGlzIHMpIC0+IFNvbWUgc1xuICBpblxuICBtYXRjaCBleG4sIGJhY2t0cmFjZSB3aXRoXG4gIHwgRXhuIHQsIE5vbmUgLT4gdFxuICB8IEV4biB0LCBTb21lIGJhY2t0cmFjZSAtPlxuICAgIG9mX2xhenlfbWVzc2FnZSAobGF6eSAoV2l0aF9iYWNrdHJhY2UgKHRvX21lc3NhZ2UgdCwgYmFja3RyYWNlKSkpXG4gIHwgXywgTm9uZSAtPiBvZl9tZXNzYWdlIChNZXNzYWdlLkV4biBleG4pXG4gIHwgXywgU29tZSBiYWNrdHJhY2UgLT5cbiAgICBvZl9sYXp5X21lc3NhZ2UgKGxhenkgKFdpdGhfYmFja3RyYWNlIChTZXhwIChFeG4uc2V4cF9vZl90IGV4biksIGJhY2t0cmFjZSkpKVxuOztcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkluZm9cIlxuICBsZXQgcHAgcHBmIHQgPSBTdGRsaWIuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKHRvX3N0cmluZ19odW0gdClcbmVuZClcblxubW9kdWxlIEludGVybmFsX3JlcHIgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNZXNzYWdlXG5cbiAgbGV0IHRvX2luZm8gPSBvZl9tZXNzYWdlXG4gIGxldCBvZl9pbmZvID0gdG9fbWVzc2FnZVxuZW5kXG4iLCIoKiBUaGlzIG1vZHVsZSBpcyB0cnlpbmcgdG8gbWluaW1pemUgZGVwZW5kZW5jaWVzIG9uIG1vZHVsZXMgaW4gQ29yZSwgc28gYXMgdG8gYWxsb3dcbiAgIFtFcnJvcl0gYW5kIFtPcl9lcnJvcl0gdG8gYmUgdXNlZCBpbiB2YXJpb3VzIHBsYWNlcy4gIFBsZWFzZSBhdm9pZCBhZGRpbmcgbmV3XG4gICBkZXBlbmRlbmNpZXMuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbmZvXG5cbmxldCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBBbnkgXCJFcnJvci50XCIgfVxubGV0W0Bjb2xkXSByYWlzZSB0ID0gcmFpc2UgKHRvX2V4biB0KVxubGV0W0Bjb2xkXSByYWlzZV9zIHNleHAgPSByYWlzZSAoY3JlYXRlX3Mgc2V4cClcbmxldCB0b19pbmZvIHQgPSB0XG5sZXQgb2ZfaW5mbyB0ID0gdFxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHRcblxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuRXJyb3JcIlxuICBsZXQgcHAgPSBwcFxuZW5kKVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEludmFyaWFudF9pbnRmXG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5sZXQgaW52YXJpYW50IGhlcmUgdCBzZXhwX29mX3QgZiA6IHVuaXQgPVxuICB0cnkgZiAoKSB3aXRoXG4gIHwgZXhuIC0+XG4gICAgcmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJpbnZhcmlhbnQgZmFpbGVkXCJcbiAgICAgICAgIFsgXCJcIiwgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdCBoZXJlXG4gICAgICAgICA7IFwiZXhuXCIsIHNleHBfb2ZfZXhuIGV4blxuICAgICAgICAgOyBcIlwiLCBzZXhwX29mX3QgdFxuICAgICAgICAgXSlcbjs7XG5cbmxldCBjaGVja19maWVsZCB0IGYgZmllbGQgPVxuICB0cnkgZiAoRmllbGQuZ2V0IGZpZWxkIHQpIHdpdGhcbiAgfCBleG4gLT5cbiAgICByYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcInByb2JsZW0gd2l0aCBmaWVsZFwiXG4gICAgICAgICBbIFwiZmllbGRcIiwgc2V4cF9vZl9zdHJpbmcgKEZpZWxkLm5hbWUgZmllbGQpOyBcImV4blwiLCBzZXhwX29mX2V4biBleG4gXSlcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAnYSB0ID0gKCdhLCBFcnJvci50KSBSZXN1bHQudFxuW0BAZGVyaXZpbmdfaW5saW5lXG4gIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZV9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9XG4gIGZ1biBfY21wX19hIGFfXzAwN18gYl9fMDA4XyAtPlxuICBSZXN1bHQuY29tcGFyZV9fbG9jYWwgX2NtcF9fYSBFcnJvci5jb21wYXJlX19sb2NhbCBhX18wMDdfIGJfXzAwOF9cbjs7XG5cbmxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICBmdW4gX2NtcF9fYSBhX18wMDFfIGJfXzAwMl8gLT4gUmVzdWx0LmNvbXBhcmUgX2NtcF9fYSBFcnJvci5jb21wYXJlIGFfXzAwMV8gYl9fMDAyX1xuOztcblxubGV0IGVxdWFsX19sb2NhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPVxuICBmdW4gX2NtcF9fYSBhX18wMTlfIGJfXzAyMF8gLT5cbiAgUmVzdWx0LmVxdWFsX19sb2NhbCBfY21wX19hIEVycm9yLmVxdWFsX19sb2NhbCBhX18wMTlfIGJfXzAyMF9cbjs7XG5cbmxldCBlcXVhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPVxuICBmdW4gX2NtcF9fYSBhX18wMTNfIGJfXzAxNF8gLT4gUmVzdWx0LmVxdWFsIF9jbXBfX2EgRXJyb3IuZXF1YWwgYV9fMDEzXyBiX18wMTRfXG47O1xuXG5sZXQgZ2xvYmFsaXplIDogJ2EuICgnYSAtPiAnYSkgLT4gJ2EgdCAtPiAnYSB0ID1cbiAgZnVuICh0eXBlIGFfXzAyNV8pIDogKChhX18wMjVfIC0+IGFfXzAyNV8pIC0+IGFfXzAyNV8gdCAtPiBhX18wMjVfIHQpIC0+XG4gIGZ1biBfZ2xvYmFsaXplX2FfXzAyNl8geF9fMDI3XyAtPlxuICBSZXN1bHQuZ2xvYmFsaXplIF9nbG9iYWxpemVfYV9fMDI2XyBFcnJvci5nbG9iYWxpemUgeF9fMDI3X1xuOztcblxubGV0IGhhc2hfZm9sZF90IDpcbiAgICAgICdhLlxuICAgICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAgIC0+ICdhIHRcbiAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICA9XG4gIGZ1biBfaGFzaF9mb2xkX2EgaHN2IGFyZyAtPiBSZXN1bHQuaGFzaF9mb2xkX3QgX2hhc2hfZm9sZF9hIEVycm9yLmhhc2hfZm9sZF90IGhzdiBhcmdcbjs7XG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPVxuICBmdW4gX29mX2FfXzAzMF8geF9fMDMyXyAtPiBSZXN1bHQudF9vZl9zZXhwIF9vZl9hX18wMzBfIEVycm9yLnRfb2Zfc2V4cCB4X18wMzJfXG47O1xuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuIF9vZl9hX18wMzNfIHhfXzAzNF8gLT4gUmVzdWx0LnNleHBfb2ZfdCBfb2ZfYV9fMDMzXyBFcnJvci5zZXhwX29mX3QgeF9fMDM0X1xuOztcblxubGV0IHRfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBSZXN1bHQudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hciBFcnJvci50X3NleHBfZ3JhbW1hclxuOztcblxuW0BAQGVuZF1cblxubGV0ICggPj49ICkgPSBSZXN1bHQuKCA+Pj0gKVxubGV0ICggPj58ICkgPSBSZXN1bHQuKCA+PnwgKVxubGV0IGJpbmQgPSBSZXN1bHQuYmluZFxubGV0IGlnbm9yZV9tID0gUmVzdWx0Lmlnbm9yZV9tXG5sZXQgam9pbiA9IFJlc3VsdC5qb2luXG5sZXQgbWFwID0gUmVzdWx0Lm1hcFxubGV0IHJldHVybiA9IFJlc3VsdC5yZXR1cm5cblxubW9kdWxlIE1vbmFkX2luZml4ID0gUmVzdWx0Lk1vbmFkX2luZml4XG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE9rIGEgLT4gaW52YXJpYW50X2EgYVxuICB8IEVycm9yIGVycm9yIC0+IEVycm9yLmludmFyaWFudCBlcnJvclxuOztcblxubGV0IG1hcDIgYSBiIH5mID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgT2sgeCwgT2sgeSAtPiBPayAoZiB4IHkpXG4gIHwgT2sgXywgKEVycm9yIF8gYXMgZSkgfCAoRXJyb3IgXyBhcyBlKSwgT2sgXyAtPiBlXG4gIHwgRXJyb3IgZTEsIEVycm9yIGUyIC0+IEVycm9yIChFcnJvci5vZl9saXN0IFsgZTE7IGUyIF0pXG47O1xuXG5tb2R1bGUgRm9yX2FwcGxpY2F0aXZlID0gQXBwbGljYXRpdmUuTWFrZV91c2luZ19tYXAyX2xvY2FsIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBsZXQgbWFwMiA9IG1hcDJcbmVuZClcblxubGV0ICggKj4gKSA9IEZvcl9hcHBsaWNhdGl2ZS4oICo+IClcbmxldCAoIDwqICkgPSBGb3JfYXBwbGljYXRpdmUuKCA8KiApXG5sZXQgKCA8Kj4gKSA9IEZvcl9hcHBsaWNhdGl2ZS4oIDwqPiApXG5sZXQgYXBwbHkgPSBGb3JfYXBwbGljYXRpdmUuYXBwbHlcbmxldCBib3RoID0gRm9yX2FwcGxpY2F0aXZlLmJvdGhcbmxldCBtYXAzID0gRm9yX2FwcGxpY2F0aXZlLm1hcDNcblxubW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gRm9yX2FwcGxpY2F0aXZlLkFwcGxpY2F0aXZlX2luZml4XG5cbm1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gIGxldCByZXR1cm4gPSByZXR1cm5cblxuICBpbmNsdWRlIE1vbmFkX2luZml4XG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCA9IG1hcFxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCBib3RoID0gYm90aFxuXG4gICAgKCogZnJvbSBBcHBsaWNhdGl2ZS5NYWtlICopXG4gICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICBlbmRcbmVuZFxuXG5sZXQgb2sgPSBSZXN1bHQub2tcbmxldCBpc19vayA9IFJlc3VsdC5pc19va1xubGV0IGlzX2Vycm9yID0gUmVzdWx0LmlzX2Vycm9yXG5cbmxldCB0cnlfd2l0aCA/KGJhY2t0cmFjZSA9IGZhbHNlKSBmID1cbiAgdHJ5IE9rIChmICgpKSB3aXRoXG4gIHwgZXhuIC0+IEVycm9yIChFcnJvci5vZl9leG4gZXhuID9iYWNrdHJhY2U6KGlmIGJhY2t0cmFjZSB0aGVuIFNvbWUgYEdldCBlbHNlIE5vbmUpKVxuOztcblxubGV0IHRyeV93aXRoX2pvaW4gP2JhY2t0cmFjZSBmID0gam9pbiAodHJ5X3dpdGggP2JhY2t0cmFjZSBmKVxuXG5sZXQgb2tfZXhuID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IHhcbiAgfCBFcnJvciBlcnIgLT4gRXJyb3IucmFpc2UgZXJyXG47O1xuXG5sZXQgb2ZfZXhuID9iYWNrdHJhY2UgZXhuID0gRXJyb3IgKEVycm9yLm9mX2V4biA/YmFja3RyYWNlIGV4bilcblxubGV0IG9mX2V4bl9yZXN1bHQgP2JhY2t0cmFjZSA9IGZ1bmN0aW9uXG4gIHwgT2sgXyBhcyB6IC0+IHpcbiAgfCBFcnJvciBleG4gLT4gb2ZfZXhuID9iYWNrdHJhY2UgZXhuXG47O1xuXG5sZXQgb2Zfb3B0aW9uID0gUmVzdWx0Lm9mX29wdGlvblxuXG5sZXQgZXJyb3IgP2hlcmUgP3N0cmljdCBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgRXJyb3IgKEVycm9yLmNyZWF0ZSA/aGVyZSA/c3RyaWN0IG1lc3NhZ2UgYSBzZXhwX29mX2EpXG47O1xuXG5sZXQgZXJyb3JfcyBzZXhwID0gRXJyb3IgKEVycm9yLmNyZWF0ZV9zIHNleHApXG5sZXQgZXJyb3Jfc3RyaW5nIG1lc3NhZ2UgPSBFcnJvciAoRXJyb3Iub2Zfc3RyaW5nIG1lc3NhZ2UpXG5sZXQgZXJyb3JmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBlcnJvcl9zdHJpbmcgZm9ybWF0XG5sZXQgdGFnIHQgfnRhZyA9IFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooRXJyb3IudGFnIH50YWcpXG5sZXQgdGFnX3MgdCB+dGFnID0gUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihFcnJvci50YWdfcyB+dGFnKVxubGV0IHRhZ19zX2xhenkgdCB+dGFnID0gUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihFcnJvci50YWdfc19sYXp5IH50YWcpXG5cbmxldCB0YWdfYXJnIHQgbWVzc2FnZSBhIHNleHBfb2ZfYSA9XG4gIFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooZnVuIGUgLT4gRXJyb3IudGFnX2FyZyBlIG1lc3NhZ2UgYSBzZXhwX29mX2EpXG47O1xuXG5sZXQgdW5pbXBsZW1lbnRlZCBzID0gZXJyb3IgXCJ1bmltcGxlbWVudGVkXCIgcyBzZXhwX29mX3N0cmluZ1xuXG5sZXQgY29tYmluZV9pbnRlcm5hbCBsaXN0IH5vbl9vayB+b25fZXJyb3IgPVxuICBtYXRjaCBSZXN1bHQuY29tYmluZV9lcnJvcnMgbGlzdCB3aXRoXG4gIHwgT2sgeCAtPiBPayAob25fb2sgeClcbiAgfCBFcnJvciBlcnJzIC0+IEVycm9yIChvbl9lcnJvciBlcnJzKVxuOztcblxubGV0IGlnbm9yZV91bml0X2xpc3QgKF8gOiB1bml0IGxpc3QpID0gKClcblxubGV0IGVycm9yX29mX2xpc3RfaWZfbmVjZXNzYXJ5ID0gZnVuY3Rpb25cbiAgfCBbIGUgXSAtPiBlXG4gIHwgbGlzdCAtPiBFcnJvci5vZl9saXN0IGxpc3Rcbjs7XG5cbmxldCBhbGwgbGlzdCA9IGNvbWJpbmVfaW50ZXJuYWwgbGlzdCB+b25fb2s6Rm4uaWQgfm9uX2Vycm9yOmVycm9yX29mX2xpc3RfaWZfbmVjZXNzYXJ5XG5cbmxldCBhbGxfdW5pdCBsaXN0ID1cbiAgY29tYmluZV9pbnRlcm5hbCBsaXN0IH5vbl9vazppZ25vcmVfdW5pdF9saXN0IH5vbl9lcnJvcjplcnJvcl9vZl9saXN0X2lmX25lY2Vzc2FyeVxuOztcblxubGV0IGNvbWJpbmVfZXJyb3JzIGxpc3QgPSBjb21iaW5lX2ludGVybmFsIGxpc3Qgfm9uX29rOkZuLmlkIH5vbl9lcnJvcjpFcnJvci5vZl9saXN0XG5cbmxldCBjb21iaW5lX2Vycm9yc191bml0IGxpc3QgPVxuICBjb21iaW5lX2ludGVybmFsIGxpc3Qgfm9uX29rOmlnbm9yZV91bml0X2xpc3Qgfm9uX2Vycm9yOkVycm9yLm9mX2xpc3Rcbjs7XG5cbmxldCBmaWx0ZXJfb2tfYXRfbGVhc3Rfb25lIGwgPVxuICBsZXQgb2ssIGVycnMgPSBMaXN0LnBhcnRpdGlvbl9tYXAgbCB+ZjpSZXN1bHQudG9fZWl0aGVyIGluXG4gIG1hdGNoIG9rIHdpdGhcbiAgfCBbXSAtPiBFcnJvciAoRXJyb3Iub2ZfbGlzdCBlcnJzKVxuICB8IF8gLT4gT2sgb2tcbjs7XG5cbmxldCBmaW5kX29rIGwgPVxuICBtYXRjaCBMaXN0LmZpbmRfbWFwIGwgfmY6UmVzdWx0Lm9rIHdpdGhcbiAgfCBTb21lIHggLT4gT2sgeFxuICB8IE5vbmUgLT5cbiAgICBFcnJvclxuICAgICAgKEVycm9yLm9mX2xpc3RcbiAgICAgICAgIChMaXN0Lm1hcCBsIH5mOihmdW5jdGlvblxuICAgICAgICAgICB8IE9rIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgIHwgRXJyb3IgZXJyIC0+IGVycikpKVxuOztcblxubGV0IGZpbmRfbWFwX29rIGwgfmYgPVxuICBXaXRoX3JldHVybi53aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICBFcnJvclxuICAgICAgKEVycm9yLm9mX2xpc3RcbiAgICAgICAgIChMaXN0Lm1hcCBsIH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgICBtYXRjaCBmIGVsdCB3aXRoXG4gICAgICAgICAgICB8IE9rIF8gYXMgeCAtPiByZXR1cm4geFxuICAgICAgICAgICAgfCBFcnJvciBlcnIgLT4gZXJyKSkpKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbWFwID0gUmVzdWx0Lm1hcFxubGV0IGl0ZXIgPSBSZXN1bHQuaXRlclxubGV0IGl0ZXJfZXJyb3IgPSBSZXN1bHQuaXRlcl9lcnJvclxuIiwiKCogVGhpcyBpcyBicm9rZW4gb2ZmIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBTaWduIGFuZCBDb21wYXJhYmxlLiAqKVxuXG5vcGVuISBJbXBvcnRcblxudHlwZSB0ID1cbiAgfCBOZWdcbiAgfCBaZXJvXG4gIHwgUG9zXG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaCwgZW51bWVyYXRlXVxuXG5sZXQgdF9vZl9zZXhwID1cbiAgKGxldCBlcnJvcl9zb3VyY2VfXzAwM18gPSBcInNpZ24wLm1sLnRcIiBpblxuICAgZnVuY3Rpb25cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgLT4gTmVnXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgLT4gWmVyb1xuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwicG9zXCIgfCBcIlBvc1wiKSAtPiBQb3NcbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmVnXCIgfCBcIk5lZ1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJwb3NcIiB8IFwiUG9zXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDJfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICB8IHNleHBfXzAwMl8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG47O1xuXG5sZXQgc2V4cF9vZl90ID1cbiAgKGZ1bmN0aW9uXG4gICB8IE5lZyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOZWdcIlxuICAgfCBaZXJvIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlplcm9cIlxuICAgfCBQb3MgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiUG9zXCJcbiAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWcgeyBuYW1lID0gXCJOZWdcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlplcm9cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlBvc1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5sZXQgY29tcGFyZV9fbG9jYWwgPSAoU3RkbGliLmNvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxubGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuXG5sZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gIChmdW4gaHN2IGFyZyAtPlxuICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnRcbiAgICAgICBoc3ZcbiAgICAgICAobWF0Y2ggYXJnIHdpdGhcbiAgICAgICAgfCBOZWcgLT4gMFxuICAgICAgICB8IFplcm8gLT4gMVxuICAgICAgICB8IFBvcyAtPiAyKVxuICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuOztcblxubGV0IChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5sZXQgYWxsID0gKFsgTmVnOyBaZXJvOyBQb3MgXSA6IHQgbGlzdClcblxuW0BAQGVuZF1cblxubW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiB0KSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IHQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IHQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogdCkgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IHQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogdCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogdCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IHQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogdCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogdCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBlcXVhbF9fbG9jYWwgKHggOiB0KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IHQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogdCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubGV0IG9mX3N0cmluZyBzID0gdF9vZl9zZXhwIChzZXhwX29mX3N0cmluZyBzKVxubGV0IHRvX3N0cmluZyB0ID0gc3RyaW5nX29mX3NleHAgKHNleHBfb2ZfdCB0KVxuXG5sZXQgdG9faW50ID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gLTFcbiAgfCBaZXJvIC0+IDBcbiAgfCBQb3MgLT4gMVxuOztcblxubGV0IF8gPSBoYXNoXG5cbigqIElnbm9yZSB0aGUgaGFzaCBmdW5jdGlvbiBwcm9kdWNlZCBieSBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaF0gKilcbmxldCBoYXNoID0gdG9faW50XG5sZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuU2lnblwiXG5sZXQgb2ZfaW50IG4gPSBpZiBuIDwgMCB0aGVuIE5lZyBlbHNlIGlmIG4gPSAwIHRoZW4gWmVybyBlbHNlIFBvc1xuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIENvbXBhcmFibGVfaW50ZlxuXG5tb2R1bGUgV2l0aF96ZXJvIChUIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZV1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIFtAQEBlbmRdXG5cbiAgdmFsIHplcm8gOiB0XG5lbmQpID1cbnN0cnVjdFxuICBvcGVuIFRcblxuICBsZXQgaXNfcG9zaXRpdmUgdCA9IGNvbXBhcmUgdCB6ZXJvID4gMFxuICBsZXQgaXNfbm9uX25lZ2F0aXZlIHQgPSBjb21wYXJlIHQgemVybyA+PSAwXG4gIGxldCBpc19uZWdhdGl2ZSB0ID0gY29tcGFyZSB0IHplcm8gPCAwXG4gIGxldCBpc19ub25fcG9zaXRpdmUgdCA9IGNvbXBhcmUgdCB6ZXJvIDw9IDBcbiAgbGV0IHNpZ24gdCA9IFNpZ24wLm9mX2ludCAoY29tcGFyZSB0IHplcm8pXG5lbmRcblxubW9kdWxlIFBvbHkgKFQgOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgbGV0IHNleHBfb2ZfdCA9IChULnNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgUG9seVxuICBlbmRcblxuICBpbmNsdWRlIFBvbHlcblxuICBsZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxuICBsZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAgIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuICA7O1xuXG4gIGxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICAgaWYgbWluID4gbWF4XG4gICAgdGhlblxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICAgIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgOztcblxuICBtb2R1bGUgQyA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUpXG4gIGVuZFxuXG4gIGluY2x1ZGUgQ1xuZW5kXG5cbmxldCBndCBjbXAgYSBiID0gY21wIGEgYiA+IDBcbmxldCBsdCBjbXAgYSBiID0gY21wIGEgYiA8IDBcbmxldCBnZXEgY21wIGEgYiA9IGNtcCBhIGIgPj0gMFxubGV0IGxlcSBjbXAgYSBiID0gY21wIGEgYiA8PSAwXG5sZXQgZXF1YWwgY21wIGEgYiA9IGNtcCBhIGIgPSAwXG5sZXQgbm90X2VxdWFsIGNtcCBhIGIgPSBjbXAgYSBiIDw+IDBcbmxldCBtaW4gY21wIHQgdCcgPSBpZiBsZXEgY21wIHQgdCcgdGhlbiB0IGVsc2UgdCdcbmxldCBtYXggY21wIHQgdCcgPSBpZiBnZXEgY21wIHQgdCcgdGhlbiB0IGVsc2UgdCdcblxubW9kdWxlIEluZml4IChUIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZV1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIFtAQEBlbmRdXG5lbmQpIDogSW5maXggd2l0aCB0eXBlIHQgOj0gVC50ID0gc3RydWN0XG4gIGxldCAoID4gKSBhIGIgPSBndCBULmNvbXBhcmUgYSBiXG4gIGxldCAoIDwgKSBhIGIgPSBsdCBULmNvbXBhcmUgYSBiXG4gIGxldCAoID49ICkgYSBiID0gZ2VxIFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPD0gKSBhIGIgPSBsZXEgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA9ICkgYSBiID0gZXF1YWwgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA8PiApIGEgYiA9IG5vdF9lcXVhbCBULmNvbXBhcmUgYSBiXG5lbmRcbltAQGlubGluZSBhbHdheXNdXG5cbm1vZHVsZSBDb21wYXJpc29ucyAoVCA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICBbQEBAZW5kXVxuZW5kKSA6IENvbXBhcmlzb25zIHdpdGggdHlwZSB0IDo9IFQudCA9IHN0cnVjdFxuICBpbmNsdWRlIEluZml4IChUKVxuXG4gIGxldCBjb21wYXJlID0gVC5jb21wYXJlXG4gIGxldCBlcXVhbCA9ICggPSApXG4gIGxldCBtaW4gdCB0JyA9IG1pbiBjb21wYXJlIHQgdCdcbiAgbGV0IG1heCB0IHQnID0gbWF4IGNvbXBhcmUgdCB0J1xuZW5kXG5bQEBpbmxpbmUgYWx3YXlzXVxuXG5tb2R1bGUgTWFrZV91c2luZ19jb21wYXJhdG9yIChUIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbmVuZCkgOiBTIHdpdGggdHlwZSB0IDo9IFQudCBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBULmNvbXBhcmF0b3Jfd2l0bmVzcyA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IGNvbXBhcmUgPSBjb21wYXJhdG9yLmNvbXBhcmVcbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIG1vZHVsZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBDb21wYXJpc29ucyAoVClcbiAgaW5jbHVkZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgYXNjZW5kaW5nID0gY29tcGFyZVxuICBsZXQgZGVzY2VuZGluZyB0IHQnID0gY29tcGFyZSB0JyB0XG4gIGxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuICBsZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG4gIGxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICAgIGFzc2VydCAobWluIDw9IG1heCk7XG4gICAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG4gIDs7XG5cbiAgbGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgICBpZiBtaW4gPiBtYXhcbiAgICB0aGVuXG4gICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gICAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlIChUIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmQpID1cbk1ha2VfdXNpbmdfY29tcGFyYXRvciBbQGlubGluZWQgaGludF0gKHN0cnVjdFxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5lbmQpXG5cbm1vZHVsZSBJbmhlcml0IChDIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZV1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIFtAQEBlbmRdXG5lbmQpIChUIDogc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuXG4gIHZhbCBjb21wb25lbnQgOiB0IC0+IEMudFxuZW5kKSA9XG5NYWtlIChzdHJ1Y3RcbiAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIGxldCBzZXhwX29mX3QgPSAoVC5zZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudClcblxuICBbQEBAZW5kXVxuXG4gIGxldCBjb21wYXJlIHQgdCcgPSBDLmNvbXBhcmUgKFQuY29tcG9uZW50IHQpIChULmNvbXBvbmVudCB0JylcbmVuZClcblxuKCogY29tcGFyZSBbeF0gYW5kIFt5XSBsZXhpY29ncmFwaGljYWxseSB1c2luZyBmdW5jdGlvbnMgaW4gdGhlIGxpc3QgW2NtcHNdICopXG5sZXQgbGV4aWNvZ3JhcGhpYyBjbXBzIHggeSA9XG4gIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgfCBjbXAgOjogY21wcyAtPlxuICAgICAgbGV0IHJlcyA9IGNtcCB4IHkgaW5cbiAgICAgIGlmIHJlcyA9IDAgdGhlbiBsb29wIGNtcHMgZWxzZSByZXNcbiAgICB8IFtdIC0+IDBcbiAgaW5cbiAgbG9vcCBjbXBzXG47O1xuXG5sZXQgbGlmdCBjbXAgfmYgeCB5ID0gY21wIChmIHgpIChmIHkpXG5sZXQgcmV2ZXJzZSBjbXAgeCB5ID0gY21wIHkgeFxuXG50eXBlICdhIHJldmVyc2VkID0gJ2FcblxubGV0IGNvbXBhcmVfcmV2ZXJzZWQgY21wIHggeSA9IGNtcCB5IHhcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2hhYmxlLktleSAqKVxubW9kdWxlIHR5cGUgS2V5ID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5cbiAgKCoqIFZhbHVlcyByZXR1cm5lZCBieSBbaGFzaF0gbXVzdCBiZSBub24tbmVnYXRpdmUuICBBbiBleGNlcHRpb24gd2lsbCBiZSByYWlzZWQgaW4gdGhlXG4gICAgICBjYXNlIHRoYXQgW2hhc2hdIHJldHVybnMgYSBuZWdhdGl2ZSB2YWx1ZS4gKilcbiAgdmFsIGhhc2ggOiB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBIYXNoYWJsZSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgaGFzaCA6ICdhIC0+IGludFxuICAgIDsgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludFxuICAgIDsgc2V4cF9vZl90IDogJ2EgLT4gU2V4cC50XG4gICAgfVxuXG4gICgqKiBUaGlzIGZ1bmN0aW9uIGlzIHNvdW5kIGJ1dCBub3QgY29tcGxldGUsIG1lYW5pbmcgdGhhdCBpZiBpdCByZXR1cm5zIFt0cnVlXSB0aGVuIGl0J3NcbiAgICAgIHNhZmUgdG8gdXNlIHRoZSB0d28gaW50ZXJjaGFuZ2VhYmx5LiAgSWYgaXQncyBbZmFsc2VdLCB5b3UgaGF2ZSBubyBndWFyYW50ZWVzLiAgRm9yXG4gICAgICBleGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICA+IHV0b3BcbiAgICAgICAgb3BlbiBDb3JlOztcbiAgICAgICAgbGV0IGVxdWFsIChhIDogJ2EgSGFzaHRibF9pbnRmLkhhc2hhYmxlLnQpIGIgPVxuICAgICAgICAgIHBoeXNfZXF1YWwgYSBiXG4gICAgICAgICAgfHwgKHBoeXNfZXF1YWwgYS5oYXNoIGIuaGFzaFxuICAgICAgICAgICAgICAmJiBwaHlzX2VxdWFsIGEuY29tcGFyZSBiLmNvbXBhcmVcbiAgICAgICAgICAgICAgJiYgcGh5c19lcXVhbCBhLnNleHBfb2ZfdCBiLnNleHBfb2ZfdClcbiAgICAgICAgOztcbiAgICAgICAgbGV0IGEgPSBIYXNodGJsX2ludGYuSGFzaGFibGUueyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgPSBJbnQuc2V4cF9vZl90IH07O1xuICAgICAgICBsZXQgYiA9IEhhc2h0YmxfaW50Zi5IYXNoYWJsZS57IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCA9IEludC5zZXhwX29mX3QgfTs7XG4gICAgICAgIGVxdWFsIGEgYjs7ICAoKiBmYWxzZT8hICopXG4gICAgICBdfVxuICAqKVxuICBsZXQgZXF1YWwgYSBiID1cbiAgICBwaHlzX2VxdWFsIGEgYlxuICAgIHx8IChwaHlzX2VxdWFsIGEuaGFzaCBiLmhhc2hcbiAgICAgICAgJiYgcGh5c19lcXVhbCBhLmNvbXBhcmUgYi5jb21wYXJlXG4gICAgICAgICYmIHBoeXNfZXF1YWwgYS5zZXhwX29mX3QgYi5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGhhc2hfcGFyYW0gPSBTdGRsaWIuSGFzaHRibC5oYXNoX3BhcmFtXG4gIGxldCBoYXNoID0gU3RkbGliLkhhc2h0YmwuaGFzaFxuICBsZXQgcG9seSA9IHsgaGFzaDsgY29tcGFyZSA9IFBvbHkuY29tcGFyZTsgc2V4cF9vZl90ID0gKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgfVxuXG4gIGxldCBvZl9rZXkgKHR5cGUgYSkgKG1vZHVsZSBLZXkgOiBLZXkgd2l0aCB0eXBlIHQgPSBhKSA9XG4gICAgeyBoYXNoID0gS2V5Lmhhc2g7IGNvbXBhcmUgPSBLZXkuY29tcGFyZTsgc2V4cF9vZl90ID0gS2V5LnNleHBfb2ZfdCB9XG4gIDs7XG5cbiAgbGV0IHRvX2tleSAodHlwZSBhKSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9ID1cbiAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgdHlwZSB0ID0gYVxuXG4gICAgICBsZXQgaGFzaCA9IGhhc2hcbiAgICAgIGxldCBjb21wYXJlID0gY29tcGFyZVxuICAgICAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICAgIGVuZCA6IEtleVxuICAgICAgd2l0aCB0eXBlIHQgPSBhKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgSGFzaGFibGVcblxubW9kdWxlIHR5cGUgSGFzaGFibGUgPSBzaWdcbiAgdHlwZSAnYSB0ID0gJ2EgSGFzaGFibGUudCA9XG4gICAgeyBoYXNoIDogJ2EgLT4gaW50XG4gICAgOyBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50XG4gICAgOyBzZXhwX29mX3QgOiAnYSAtPiBTZXhwLnRcbiAgICB9XG5cbiAgdmFsIGVxdWFsIDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgdmFsIHBvbHkgOiAnYSB0XG4gIHZhbCBvZl9rZXkgOiAobW9kdWxlIEtleSB3aXRoIHR5cGUgdCA9ICdhKSAtPiAnYSB0XG4gIHZhbCB0b19rZXkgOiAnYSB0IC0+IChtb2R1bGUgS2V5IHdpdGggdHlwZSB0ID0gJ2EpXG4gIHZhbCBoYXNoX3BhcmFtIDogaW50IC0+IGludCAtPiAnYSAtPiBpbnRcbiAgdmFsIGhhc2ggOiAnYSAtPiBpbnRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIElkZW50aWZpYWJsZV9pbnRmXG5cbm1vZHVsZSBNYWtlIChUIDogQXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG4gIGluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKFQpXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuZW5kXG5cbm1vZHVsZSBNYWtlX3VzaW5nX2NvbXBhcmF0b3IgKFQgOiBBcmdfd2l0aF9jb21wYXJhdG9yKSA9IHN0cnVjdFxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2VfdXNpbmdfY29tcGFyYXRvciAoVClcbiAgaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoVClcblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSB1bml0IFtAQGRlcml2aW5nX2lubGluZSBlbnVtZXJhdGUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBhbGwgPSAoWyAoKSBdIDogdCBsaXN0KVxuICBsZXQgKGdsb2JhbGl6ZSA6IHQgLT4gdCkgPSAoZ2xvYmFsaXplX3VuaXQgOiB0IC0+IHQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF91bml0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF91bml0IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9ICh1bml0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX3VuaXQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gdW5pdF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBjb21wYXJlIF8gXyA9IDBcbiAgbGV0IGNvbXBhcmVfX2xvY2FsIF8gXyA9IDBcbiAgbGV0IGVxdWFsX19sb2NhbCBfIF8gPSB0cnVlXG5cbiAgbGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBcIigpXCIgLT4gKClcbiAgICB8IF8gLT4gZmFpbHdpdGggXCJCYXNlLlVuaXQub2Zfc3RyaW5nOiAoKSBleHBlY3RlZFwiXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyAoKSA9IFwiKClcIlxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuVW5pdFwiXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChUKVxuXG5sZXQgaW52YXJpYW50ICgpID0gKClcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMFxuXG5sZXQgZ2V0X3Bvc19sZW4gP3BvcyA/bGVuICgpIH50b3RhbF9sZW5ndGggPVxuICB0cnkgUmVzdWx0Lk9rIChnZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGgpIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IHMgLT4gRXJyb3IgKEVycm9yLm9mX3N0cmluZyBzKVxuOztcbiIsIm9wZW4hIEltcG9ydFxub3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbigqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgYSBzZWFyY2ggZm9yIHRoZSBmaXJzdCAocmVzcC4gbGFzdCkgZWxlbWVudFxuICAgc2F0aXNmeWluZyBhIHByZWRpY2F0ZSwgYXNzdW1pbmcgdGhhdCB0aGUgcHJlZGljYXRlIGlzIGluY3JlYXNpbmcgb25cbiAgIHRoZSBjb250YWluZXIsIG1lYW5pbmcgdGhhdCwgaWYgdGhlIGNvbnRhaW5lciBpcyBbdTEuLi51bl0sIHRoZXJlIGV4aXN0cyBhXG4gICBrIHN1Y2ggdGhhdCBwKHUxKT0uLi4uPXAodWspID0gZmFsc2UgYW5kIHAodWsrMSk9Li4uLj1wKHVuKT0gdHJ1ZS5cbiAgIElmIHRoaXMgayA9IDEgKHJlc3AgbiksIGZpbmRfbGFzdF9ub3Rfc2F0aXNmeWluZyAocmVzcCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcpXG4gICB3aWxsIHJldHVybiBOb25lLiAqKVxuXG5sZXQgcmVjIGxpbmVhcl9zZWFyY2hfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZCA9XG4gIGlmIGxvID4gaGlcbiAgdGhlbiBOb25lXG4gIGVsc2UgaWYgcHJlZCAoZ2V0IHQgbG8pXG4gIHRoZW4gU29tZSBsb1xuICBlbHNlIGxpbmVhcl9zZWFyY2hfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvOihsbyArIDEpIH5oaSB+cHJlZFxuOztcblxuKCogVGFrZXMgYSBjb250YWluZXIgW3RdLCBhIHByZWRpY2F0ZSBbcHJlZF0gYW5kIHR3byBpbmRpY2VzIFtsbyA8IGhpXSwgc3VjaCB0aGF0XG4gICBbcHJlZF0gaXMgaW5jcmVhc2luZyBvbiBbdF0gYmV0d2VlbiBbbG9dIGFuZCBbaGldLlxuXG4gICByZXR1cm4gYSByYW5nZSAobG8sIGhpKSB3aGVyZTpcbiAgIC0gbG8gYW5kIGhpIGFyZSBjbG9zZSBlbm91Z2ggdG9nZXRoZXIgZm9yIGEgbGluZWFyIHNlYXJjaFxuICAgLSBJZiBbcHJlZF0gaXMgbm90IGNvbnN0YW50bHkgW2ZhbHNlXSBvbiBbdF0gYmV0d2VlbiBbbG9dIGFuZCBbaGldLCB0aGUgZmlyc3QgZWxlbWVudFxuICAgICBvbiB3aGljaCBbcHJlZF0gaXMgW3RydWVdIGlzIGJldHdlZW4gW2xvXSBhbmQgW2hpXS4gKilcbigqIEludmFyaWFudDogdGhlIGZpcnN0IGVsZW1lbnQgc2F0aXNmeWluZyBbcHJlZF0sIGlmIGl0IGV4aXN0cyBpcyBiZXR3ZWVuIFtsb10gYW5kIFtoaV0gKilcbmxldCByZWMgZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGkgfnByZWQgPVxuICAoKiBXYXJuaW5nOiB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IHRlcm1pbmF0ZSBpZiB0aGUgY29uc3RhbnQgKGN1cnJlbnRseSA4KSBpc1xuICAgICBzZXQgPD0gMSAqKVxuICBpZiBoaSAtIGxvIDw9IDhcbiAgdGhlbiBsbywgaGlcbiAgZWxzZSAoXG4gICAgbGV0IG1pZCA9IGxvICsgKChoaSAtIGxvKSAvIDIpIGluXG4gICAgaWYgcHJlZCAoZ2V0IHQgbWlkKVxuICAgICAgICgqIElOVkFSSUFOVCBjaGVjazogaXQgbWVhbnMgdGhlIGZpcnN0IHNhdGlzZnlpbmcgZWxlbWVudCBpcyBiZXR3ZWVuIFtsb10gYW5kIFttaWRdICopXG4gICAgdGhlblxuICAgICAgZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGk6bWlkIH5wcmVkXG4gICAgICAoKiBJTlZBUklBTlQgY2hlY2s6IGl0IG1lYW5zIHRoZSBmaXJzdCBzYXRpc2Z5aW5nIGVsZW1lbnQsIGlmIGl0IGV4aXN0cyxcbiAgICAgICAgIGlzIGJldHdlZW4gW21pZCsxXSBhbmQgW2hpXSAqKVxuICAgIGVsc2UgZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbzoobWlkICsgMSkgfmhpIH5wcmVkKVxuOztcblxubGV0IGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQgPVxuICBsZXQgcG9zLCBsZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggdClcbiAgaW5cbiAgbGV0IGxvID0gcG9zIGluXG4gIGxldCBoaSA9IHBvcyArIGxlbiAtIDEgaW5cbiAgbGV0IGxvLCBoaSA9IGZpbmRfcmFuZ2VfbmVhcl9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpIH5wcmVkIGluXG4gIGxpbmVhcl9zZWFyY2hfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZFxuOztcblxuKCogVGFrZXMgYW4gYXJyYXkgd2l0aCBzaGFwZSBbdHJ1ZSwuLi50cnVlLGZhbHNlLC4uLmZhbHNlXSAoaS5lLiwgdGhlIF9yZXZlcnNlXyBvZiB3aGF0XG4gICBpcyBkZXNjcmliZWQgYWJvdmUpIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB0cnVlIG9yIE5vbmUgaWYgdGhlcmUgYXJlIG5vXG4gICB0cnVlKilcbmxldCBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+cHJlZCB+Z2V0IH5sZW5ndGggPVxuICBsZXQgcG9zLCBsZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggdClcbiAgaW5cbiAgaWYgbGVuID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgKCogVGhlIGxhc3Qgc2F0aXNmeWluZyBpcyB0aGUgb25lIGp1c3QgYmVmb3JlIHRoZSBmaXJzdCBub3Qgc2F0aXNmeWluZyAqKVxuICAgIG1hdGNoXG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgfnBvcyB+bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBub3QgKHByZWQgeCkpXG4gICAgd2l0aFxuICAgIHwgTm9uZSAtPiBTb21lIChwb3MgKyBsZW4gLSAxKVxuICAgICgqIFRoaXMgbWVhbnMgdGhhdCBhbGwgZWxlbWVudHMgc2F0aXNmeSBwcmVkLlxuICAgICAgIFRoZXJlIGlzIGF0IGxlYXN0IGFuIGVsZW1lbnQgYXMgKGxlbiA+IDApICopXG4gICAgfCBTb21lIGkgd2hlbiBpID0gcG9zIC0+IE5vbmUgKCogbm8gZWxlbWVudCBzYXRpc2ZpZXMgcHJlZCAqKVxuICAgIHwgU29tZSBpIC0+IFNvbWUgKGkgLSAxKSlcbjs7XG5cbmxldCBiaW5hcnlfc2VhcmNoXG4gID9wb3NcbiAgP2xlblxuICB0XG4gIH4obGVuZ3RoIDogXyAtPiBfKVxuICB+KGdldCA6IF8gLT4gXyAtPiBfKVxuICB+KGNvbXBhcmUgOiBfIC0+IF8gLT4gXylcbiAgaG93XG4gIHZcbiAgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAtPlxuICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPCAwKSBbQG5vbnRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKSBbQG5vbnRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICB8IGBGaXJzdF9lcXVhbF90byAtPlxuICAgIChtYXRjaFxuICAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID49IDApXG4gICAgIHdpdGhcbiAgICAgfCBTb21lIHggd2hlbiBjb21wYXJlIChnZXQgdCB4KSB2ID0gMCAtPiBTb21lIHhcbiAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gIHwgYExhc3RfZXF1YWxfdG8gLT5cbiAgICAobWF0Y2hcbiAgICAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApXG4gICAgIHdpdGhcbiAgICAgfCBTb21lIHggd2hlbiBjb21wYXJlIChnZXQgdCB4KSB2ID0gMCAtPiBTb21lIHhcbiAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID49IDApIFtAbm9udGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gLT5cbiAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA+IDApIFtAbm9udGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG47O1xuXG5sZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgP3BvcyA/bGVuIHQgfmxlbmd0aCB+Z2V0IH5zZWdtZW50X29mIGhvdyA9XG4gIGxldCBpc19sZWZ0IHggPVxuICAgIG1hdGNoIHNlZ21lbnRfb2YgeCB3aXRoXG4gICAgfCBgTGVmdCAtPiB0cnVlXG4gICAgfCBgUmlnaHQgLT4gZmFsc2VcbiAgaW5cbiAgbGV0IGlzX3JpZ2h0IHggPSBub3QgKGlzX2xlZnQgeCkgaW5cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCBgTGFzdF9vbl9sZWZ0IC0+XG4gICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmxlbmd0aCB+Z2V0IH5wcmVkOmlzX2xlZnQgW0Bub250YWlsXVxuICB8IGBGaXJzdF9vbl9yaWdodCAtPlxuICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+bGVuZ3RoIH5nZXQgfnByZWQ6aXNfcmlnaHQgW0Bub250YWlsXVxuOztcbiIsIigqKiBNb2R1bGUgdHlwZXMgZm9yIGEgW2JpbmFyeV9zZWFyY2hdIGZ1bmN0aW9uIGZvciBhIHNlcXVlbmNlLCBhbmQgZnVuY3RvcnMgZm9yIGJ1aWxkaW5nXG4gICAgW2JpbmFyeV9zZWFyY2hdIGZ1bmN0aW9ucy4gKilcblxub3BlbiEgSW1wb3J0XG5cbigqKiBBbiBbSW5kZXhhYmxlXSB0eXBlIGlzIGEgZmluaXRlIHNlcXVlbmNlIG9mIGVsZW1lbnRzIGluZGV4ZWQgYnkgY29uc2VjdXRpdmUgaW50ZWdlcnNcbiAgICBbMF0gLi4uIFtsZW5ndGggdCAtIDFdLiAgW2dldF0gYW5kIFtsZW5ndGhdIG11c3QgYmUgTygxKSBmb3IgdGhlIHJlc3VsdGluZ1xuICAgIFtiaW5hcnlfc2VhcmNoXSB0byBiZSBsZyhuKS4gKilcbm1vZHVsZSB0eXBlIEluZGV4YWJsZSA9IHNpZ1xuICB0eXBlIGVsdFxuICB0eXBlIHRcblxuICB2YWwgZ2V0IDogdCAtPiBpbnQgLT4gZWx0XG4gIHZhbCBsZW5ndGggOiB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZGV4YWJsZTEgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG5lbmRcblxubW9kdWxlIFdoaWNoX3RhcmdldF9ieV9rZXkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICBbIGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAoKiogICAgICAgIHt2IHwgPCBlbHQgWCB8ICAgICAgICAgICAgICAgICAgICAgICB2fSAqKVxuICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvICgqKiAgICAge3YgfCAgICAgIDw9IGVsdCAgICAgICBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgfCBgTGFzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCAgID0gZWx0IFggfCAgICAgICAgICAgdn0gKilcbiAgICB8IGBGaXJzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8IFggPSBlbHQgICB8ICAgICAgICAgICB2fSAqKVxuICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAoKioge3YgICAgICAgICAgIHwgWCAgICAgICA+PSBlbHQgICAgICB8IHZ9ICopXG4gICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuICgqKiAgICB7diAgICAgICAgICAgICAgICAgICAgICAgfCBYID4gZWx0IHwgdn0gKilcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBlbnVtZXJhdGVdXG5cbiAgbGV0IGFsbCA9XG4gICAgKFsgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuXG4gICAgIDsgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvXG4gICAgIDsgYExhc3RfZXF1YWxfdG9cbiAgICAgOyBgRmlyc3RfZXF1YWxfdG9cbiAgICAgOyBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvXG4gICAgIDsgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhblxuICAgICBdXG4gICAgICA6IHQgbGlzdClcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBXaGljaF90YXJnZXRfYnlfc2VnbWVudCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIFsgYExhc3Rfb25fbGVmdFxuICAgIHwgYEZpcnN0X29uX3JpZ2h0XG4gICAgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgZW51bWVyYXRlXVxuXG4gIGxldCBhbGwgPSAoWyBgTGFzdF9vbl9sZWZ0OyBgRmlyc3Rfb25fcmlnaHQgXSA6IHQgbGlzdClcblxuICBbQEBAZW5kXVxuZW5kXG5cbnR5cGUgKCd0LCAnZWx0LCAna2V5KSBiaW5hcnlfc2VhcmNoID1cbiAgP3BvczppbnRcbiAgLT4gP2xlbjppbnRcbiAgLT4gJ3RcbiAgLT4gY29tcGFyZTooJ2VsdCAtPiAna2V5IC0+IGludClcbiAgLT4gV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gIC0+ICdrZXlcbiAgLT4gaW50IG9wdGlvblxuXG50eXBlICgndCwgJ2VsdCkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgPVxuICA/cG9zOmludFxuICAtPiA/bGVuOmludFxuICAtPiAndFxuICAtPiBzZWdtZW50X29mOignZWx0IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgLT4gV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAtPiBpbnQgb3B0aW9uXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSBlbHRcbiAgdHlwZSB0XG5cbiAgKCoqIFNlZSBbQmluYXJ5X3NlYXJjaC5iaW5hcnlfc2VhcmNoXSBpbiBiaW5hcnlfc2VhcmNoLm1sICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoIDogKHQsIGVsdCwgJ2tleSkgYmluYXJ5X3NlYXJjaFxuXG4gICgqKiBTZWUgW0JpbmFyeV9zZWFyY2guYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIGluIGJpbmFyeV9zZWFyY2gubWwgKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIDogKHQsIGVsdCkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgYmluYXJ5X3NlYXJjaCA6ICgnYSB0LCAnYSwgJ2tleSkgYmluYXJ5X3NlYXJjaFxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgOiAoJ2EgdCwgJ2EpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG5lbmRcblxubW9kdWxlIHR5cGUgQmluYXJ5X3NlYXJjaGFibGUgPSBzaWdcbiAgbW9kdWxlIHR5cGUgUyA9IFNcbiAgbW9kdWxlIHR5cGUgUzEgPSBTMVxuICBtb2R1bGUgdHlwZSBJbmRleGFibGUgPSBJbmRleGFibGVcbiAgbW9kdWxlIHR5cGUgSW5kZXhhYmxlMSA9IEluZGV4YWJsZTFcblxuICBtb2R1bGUgV2hpY2hfdGFyZ2V0X2J5X2tleSA9IFdoaWNoX3RhcmdldF9ieV9rZXlcbiAgbW9kdWxlIFdoaWNoX3RhcmdldF9ieV9zZWdtZW50ID0gV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnRcblxuICB0eXBlIG5vbnJlYyAoJ3QsICdlbHQsICdrZXkpIGJpbmFyeV9zZWFyY2ggPSAoJ3QsICdlbHQsICdrZXkpIGJpbmFyeV9zZWFyY2hcbiAgdHlwZSBub25yZWMgKCd0LCAnZWx0KSBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA9ICgndCwgJ2VsdCkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcblxuICBtb2R1bGUgTWFrZSAoVCA6IEluZGV4YWJsZSkgOiBTIHdpdGggdHlwZSB0IDo9IFQudCB3aXRoIHR5cGUgZWx0IDo9IFQuZWx0XG4gIG1vZHVsZSBNYWtlMSAoVCA6IEluZGV4YWJsZTEpIDogUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBCaW5hcnlfc2VhcmNoYWJsZV9pbnRmXG5cbm1vZHVsZSB0eXBlIEFyZyA9IHNpZ1xuICB0eXBlICdhIGVsdFxuICB0eXBlICdhIHRcblxuICB2YWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgZWx0XG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG5lbmRcblxubW9kdWxlIE1ha2VfZ2VuIChUIDogQXJnKSA9IHN0cnVjdFxuICBsZXQgZ2V0ID0gVC5nZXRcbiAgbGV0IGxlbmd0aCA9IFQubGVuZ3RoXG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggP3BvcyA/bGVuIHQgfmNvbXBhcmUgaG93IHYgPVxuICAgIEJpbmFyeV9zZWFyY2guYmluYXJ5X3NlYXJjaCA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfmNvbXBhcmUgaG93IHZcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgP3BvcyA/bGVuIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBCaW5hcnlfc2VhcmNoLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+c2VnbWVudF9vZiBob3dcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZSAoVCA6IEluZGV4YWJsZSkgPSBNYWtlX2dlbiAoc3RydWN0XG4gIGluY2x1ZGUgVFxuXG4gIHR5cGUgJ2EgZWx0ID0gVC5lbHRcbiAgdHlwZSAnYSB0ID0gVC50XG5lbmQpXG5cbm1vZHVsZSBNYWtlMSAoVCA6IEluZGV4YWJsZTEpID0gTWFrZV9nZW4gKHN0cnVjdFxuICB0eXBlICdhIGVsdCA9ICdhXG4gIHR5cGUgJ2EgdCA9ICdhIFQudFxuXG4gIGxldCBnZXQgPSBULmdldFxuICBsZXQgbGVuZ3RoID0gVC5sZW5ndGhcbmVuZClcbiIsIigqIFtCeXRlczBdIGRlZmluZXMgc3RyaW5nIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHlcbiAgIGRlZmluZWQgaW4gdGVybXMgb2YgW1N0ZGxpYi5CeXRlc10uIFtCeXRlczBdIGlzIGludGVuZGVkIHRvIGNvbXBsZXRlbHkgZXhwcmVzc1xuICAgdGhlIHBhcnQgb2YgW1N0ZGxpYi5CeXRlc10gdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXJcbiAgIHRoYW4gYnl0ZXMwLm1sIHNob3VsZCB1c2UgW1N0ZGxpYi5CeXRlc10uIFtCeXRlczBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmRcbiAgIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuXG5cbiAgIEFsbCBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2Ugc3RyaW5ncyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuQnl0ZXNdIGluXG4gICBidWlsZCBvcmRlciBzaG91bGQgZG86XG5cbiAgIHtbXG4gICAgIG1vZHVsZSBCeXRlcyAgPSBCeXRlczBcbiAgIF19XG5cbiAgIERlZmluaW5nIFttb2R1bGUgQnl0ZXMgPSBCeXRlczBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXQgcHJldmVudHNcbiAgIG9jYW1sZGVwIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuQnl0ZXNdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5tb2R1bGUgVWNoYXIgPSBVY2hhcjBcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbm1vZHVsZSBQcmltaXRpdmVzID0gc3RydWN0XG4gIGV4dGVybmFsIGdldCA6IChieXRlc1tAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gY2hhciA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogKGJ5dGVzW0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9nZXRcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiBjaGFyXG4gICAgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcblxuICBleHRlcm5hbCBzZXRcbiAgICA6ICAoYnl0ZXNbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoY2hhcltAbG9jYWxfb3B0XSlcbiAgICAtPiB1bml0XG4gICAgPSBcIiVieXRlc19zYWZlX3NldFwiXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX3NldFxuICAgIDogIChieXRlc1tAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChjaGFyW0Bsb2NhbF9vcHRdKVxuICAgIC0+IHVuaXRcbiAgICA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuXG4gICgqIFt1bnNhZmVfYmxpdF9zdHJpbmddIGlzIG5vdCBleHBvcnRlZCBpbiB0aGUgW3N0ZGxpYl0gc28gd2UgZXhwb3J0IGl0IGhlcmUgKilcbiAgZXh0ZXJuYWwgdW5zYWZlX2JsaXRfc3RyaW5nXG4gICAgOiAgc3JjOihzdHJpbmdbQGxvY2FsX29wdF0pXG4gICAgLT4gc3JjX3BvczppbnRcbiAgICAtPiBkc3Q6KGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAgIC0+IGRzdF9wb3M6aW50XG4gICAgLT4gbGVuOmludFxuICAgIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiXG4gICAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCB1bnNhZmVfZ2V0X2ludDY0XG4gICAgOiAgKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gaW50NjRcbiAgICA9IFwiJWNhbWxfYnl0ZXNfZ2V0NjR1XCJcblxuICBleHRlcm5hbCB1bnNhZmVfc2V0X2ludDY0XG4gICAgOiAgKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludDY0W0Bsb2NhbF9vcHRdKVxuICAgIC0+IHVuaXRcbiAgICA9IFwiJWNhbWxfYnl0ZXNfc2V0NjR1XCJcblxuICBleHRlcm5hbCB1bnNhZmVfZ2V0X2ludDMyXG4gICAgOiAgKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gaW50MzJcbiAgICA9IFwiJWNhbWxfYnl0ZXNfZ2V0MzJ1XCJcblxuICBleHRlcm5hbCB1bnNhZmVfc2V0X2ludDMyXG4gICAgOiAgKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludDMyW0Bsb2NhbF9vcHRdKVxuICAgIC0+IHVuaXRcbiAgICA9IFwiJWNhbWxfYnl0ZXNfc2V0MzJ1XCJcblxuICBleHRlcm5hbCB1bnNhZmVfZ2V0X2ludDE2XG4gICAgOiAgKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gaW50XG4gICAgPSBcIiVjYW1sX2J5dGVzX2dldDE2dVwiXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQxNlxuICAgIDogIChieXRlc1tAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gdW5pdFxuICAgID0gXCIlY2FtbF9ieXRlc19zZXQxNnVcIlxuZW5kXG5cbmluY2x1ZGUgUHJpbWl0aXZlc1xuXG5sZXQgbWF4X2xlbmd0aCA9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxubGV0IGJsaXQgPSBTdGRsaWIuQnl0ZXMuYmxpdFxubGV0IGJsaXRfc3RyaW5nID0gU3RkbGliLkJ5dGVzLmJsaXRfc3RyaW5nXG5sZXQgY29tcGFyZSA9IFN0ZGxpYi5CeXRlcy5jb21wYXJlXG5sZXQgY29weSA9IFN0ZGxpYi5CeXRlcy5jb3B5XG5sZXQgY3JlYXRlID0gU3RkbGliLkJ5dGVzLmNyZWF0ZVxubGV0IHNldF91Y2hhcl91dGZfOCA9IFN0ZGxpYi5CeXRlcy5zZXRfdXRmXzhfdWNoYXJcbmxldCBzZXRfdWNoYXJfdXRmXzE2bGUgPSBTdGRsaWIuQnl0ZXMuc2V0X3V0Zl8xNmxlX3VjaGFyXG5sZXQgc2V0X3VjaGFyX3V0Zl8xNmJlID0gU3RkbGliLkJ5dGVzLnNldF91dGZfMTZiZV91Y2hhclxuXG5sZXQgc2V0X3V0Zl8zMl91Y2hhciB+c2V0X2ludDMyIGJ5dGVzIGlkeCB1Y2hhciA9XG4gIFVjaGFyLnRvX2ludCB1Y2hhclxuICB8PiBJbnRfY29udmVyc2lvbnMuaW50X3RvX2ludDMyX3RydW5jICgqIHNob3VsZCBuZXZlciBoYXZlIGFueXRoaW5nIHRvIHRydW5jYXRlICopXG4gIHw+IHNldF9pbnQzMiBieXRlcyBpZHg7XG4gIDRcbjs7XG5cbmxldCBzZXRfdWNoYXJfdXRmXzMybGUgPSBzZXRfdXRmXzMyX3VjaGFyIH5zZXRfaW50MzI6U3RkbGliLkJ5dGVzLnNldF9pbnQzMl9sZVxubGV0IHNldF91Y2hhcl91dGZfMzJiZSA9IHNldF91dGZfMzJfdWNoYXIgfnNldF9pbnQzMjpTdGRsaWIuQnl0ZXMuc2V0X2ludDMyX2JlXG5cbmV4dGVybmFsIHVuc2FmZV9jcmVhdGVfbG9jYWwgOiBpbnQgLT4gYnl0ZXMgPSBcIkJhc2VfdW5zYWZlX2NyZWF0ZV9sb2NhbF9ieXRlc1wiIFxuXG5sZXQgY3JlYXRlX2xvY2FsIGxlbiA9XG4gIGlmIGxlbiA+IFN5czAubWF4X3N0cmluZ19sZW5ndGggdGhlbiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmNyZWF0ZV9sb2NhbFwiO1xuICB1bnNhZmVfY3JlYXRlX2xvY2FsIGxlblxuOztcblxubGV0IGZpbGwgPSBTdGRsaWIuQnl0ZXMuZmlsbFxubGV0IG1ha2UgPSBTdGRsaWIuQnl0ZXMubWFrZVxuXG5sZXQgbWFwIHQgfihmIDogXyAtPiBfKSA9XG4gIGxldCBsID0gbGVuZ3RoIHQgaW5cbiAgaWYgbCA9IDBcbiAgdGhlbiB0XG4gIGVsc2UgKFxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IHQgaSkpXG4gICAgZG9uZTtcbiAgICByKVxuOztcblxubGV0IG1hcGkgdCB+KGYgOiBfIC0+IF8gLT4gXykgPVxuICBsZXQgbCA9IGxlbmd0aCB0IGluXG4gIGlmIGwgPSAwXG4gIHRoZW4gdFxuICBlbHNlIChcbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IHQgaSkpXG4gICAgZG9uZTtcbiAgICByKVxuOztcblxubGV0IHN1YiA9IFN0ZGxpYi5CeXRlcy5zdWJcblxuZXh0ZXJuYWwgdW5zYWZlX2JsaXRcbiAgOiAgc3JjOihieXRlc1tAbG9jYWxfb3B0XSlcbiAgLT4gc3JjX3BvczppbnRcbiAgLT4gZHN0OihieXRlc1tAbG9jYWxfb3B0XSlcbiAgLT4gZHN0X3BvczppbnRcbiAgLT4gbGVuOmludFxuICAtPiB1bml0XG4gID0gXCJjYW1sX2JsaXRfYnl0ZXNcIlxuICBbQEBub2FsbG9jXVxuXG5sZXQgdG9fc3RyaW5nID0gU3RkbGliLkJ5dGVzLnRvX3N0cmluZ1xubGV0IG9mX3N0cmluZyA9IFN0ZGxpYi5CeXRlcy5vZl9zdHJpbmdcblxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZ1xuICA6ICBub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOihieXRlc1tAbG9jYWxfb3B0XSlcbiAgLT4gKHN0cmluZ1tAbG9jYWxfb3B0XSlcbiAgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5leHRlcm5hbCB1bnNhZmVfb2Zfc3RyaW5nX3Byb21pc2Vfbm9fbXV0YXRpb25cbiAgOiAgKHN0cmluZ1tAbG9jYWxfb3B0XSlcbiAgLT4gKGJ5dGVzW0Bsb2NhbF9vcHRdKVxuICA9IFwiJWJ5dGVzX29mX3N0cmluZ1wiXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQmxpdF9pbnRmXG5cbm1vZHVsZSB0eXBlIFNlcXVlbmNlX2dlbiA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlblxuICAoU3JjIDogU2VxdWVuY2VfZ2VuKSAoRHN0IDogc2lnXG4gICAgaW5jbHVkZSBTZXF1ZW5jZV9nZW5cblxuICAgIHZhbCBjcmVhdGVfbGlrZSA6IGxlbjppbnQgLT4gJ2EgU3JjLnQgLT4gJ2EgdFxuICAgIHZhbCB1bnNhZmVfYmxpdCA6ICgnYSBTcmMudCwgJ2EgdCkgYmxpdFxuICBlbmQpID1cbnN0cnVjdFxuICBsZXQgdW5zYWZlX2JsaXQgPSBEc3QudW5zYWZlX2JsaXRcblxuICBsZXQgYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4blxuICAgICAgfnBvczpzcmNfcG9zXG4gICAgICB+bGVuXG4gICAgICB+dG90YWxfbGVuZ3RoOihTcmMubGVuZ3RoIHNyYyk7XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4blxuICAgICAgfnBvczpkc3RfcG9zXG4gICAgICB+bGVuXG4gICAgICB+dG90YWxfbGVuZ3RoOihEc3QubGVuZ3RoIGRzdCk7XG4gICAgaWYgbGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuXG4gIDs7XG5cbiAgbGV0IGJsaXRvXG4gICAgfnNyY1xuICAgID8oc3JjX3BvcyA9IDApXG4gICAgPyhzcmNfbGVuID0gU3JjLmxlbmd0aCBzcmMgLSBzcmNfcG9zKVxuICAgIH5kc3RcbiAgICA/KGRzdF9wb3MgPSAwKVxuICAgICgpXG4gICAgPVxuICAgIGJsaXQgfnNyYyB+c3JjX3BvcyB+bGVuOnNyY19sZW4gfmRzdCB+ZHN0X3Bvc1xuICA7O1xuXG4gICgqIFtzdWJdIGFuZCBbc3Vib10gZW5zdXJlIHRoYXQgZXZlcnkgcG9zaXRpb24gb2YgdGhlIGNyZWF0ZWQgc2VxdWVuY2UgaXMgcG9wdWxhdGVkIGJ5XG4gICAgIGFuIGVsZW1lbnQgb2YgdGhlIHNvdXJjZSBhcnJheS4gIFRodXMgZXZlcnkgZWxlbWVudCBvZiBbZHN0XSBiZWxvdyBpcyB3ZWxsXG4gICAgIGRlZmluZWQuICopXG4gIGxldCBzdWIgc3JjIH5wb3MgfmxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDooU3JjLmxlbmd0aCBzcmMpO1xuICAgIGxldCBkc3QgPSBEc3QuY3JlYXRlX2xpa2UgfmxlbiBzcmMgaW5cbiAgICBpZiBsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3Bvczpwb3MgfmRzdCB+ZHN0X3BvczowIH5sZW47XG4gICAgZHN0XG4gIDs7XG5cbiAgbGV0IHN1Ym8gPyhwb3MgPSAwKSA/bGVuIHNyYyA9XG4gICAgc3ViXG4gICAgICBzcmNcbiAgICAgIH5wb3NcbiAgICAgIH5sZW46XG4gICAgICAgIChtYXRjaCBsZW4gd2l0aFxuICAgICAgICAgfCBTb21lIGkgLT4gaVxuICAgICAgICAgfCBOb25lIC0+IFNyYy5sZW5ndGggc3JjIC0gcG9zKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlMSAoU2VxdWVuY2UgOiBzaWdcbiAgaW5jbHVkZSBTZXF1ZW5jZV9nZW5cblxuICB2YWwgY3JlYXRlX2xpa2UgOiBsZW46aW50IC0+ICdhIHQgLT4gJ2EgdFxuICB2YWwgdW5zYWZlX2JsaXQgOiAoJ2EgdCwgJ2EgdCkgYmxpdFxuZW5kKSA9XG4gIE1ha2VfZ2VuIChTZXF1ZW5jZSkgKFNlcXVlbmNlKVxuXG5tb2R1bGUgTWFrZTFfZ2VuZXJpYyAoU2VxdWVuY2UgOiBTZXF1ZW5jZTEpID0gTWFrZV9nZW4gKFNlcXVlbmNlKSAoU2VxdWVuY2UpXG5cbm1vZHVsZSBNYWtlIChTZXF1ZW5jZSA6IHNpZ1xuICBpbmNsdWRlIFNlcXVlbmNlXG5cbiAgdmFsIGNyZWF0ZSA6IGxlbjppbnQgLT4gdFxuICB2YWwgdW5zYWZlX2JsaXQgOiAodCwgdCkgYmxpdFxuZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFNlcXVlbmNlID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gU2VxdWVuY2UudFxuXG4gICAgb3BlbiBTZXF1ZW5jZVxuXG4gICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gXyA9IGNyZWF0ZSB+bGVuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gIGVuZFxuXG4gIGluY2x1ZGUgTWFrZV9nZW4gKFNlcXVlbmNlKSAoU2VxdWVuY2UpXG5lbmRcblxubW9kdWxlIE1ha2VfZGlzdGluY3RcbiAgKFNyYyA6IFNlcXVlbmNlKSAoRHN0IDogc2lnXG4gICAgaW5jbHVkZSBTZXF1ZW5jZVxuXG4gICAgdmFsIGNyZWF0ZSA6IGxlbjppbnQgLT4gdFxuICAgIHZhbCB1bnNhZmVfYmxpdCA6IChTcmMudCwgdCkgYmxpdFxuICBlbmQpID1cbiAgTWFrZV9nZW5cbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBTcmMudFxuXG4gICAgICBvcGVuIFNyY1xuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IERzdC50XG5cbiAgICAgIG9wZW4gRHN0XG5cbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIF8gPSBjcmVhdGUgfmxlblxuICAgICAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbiAgICBlbmQpXG5cbm1vZHVsZSBNYWtlX3RvX3N0cmluZyAoVCA6IHNpZ1xuICB0eXBlIHRcbmVuZClcbihUb19ieXRlcyA6IFNfZGlzdGluY3Qgd2l0aCB0eXBlIHNyYyA6PSBULnQgd2l0aCB0eXBlIGRzdCA6PSBieXRlcykgPVxuc3RydWN0XG4gIG9wZW4gVG9fYnl0ZXNcblxuICBsZXQgc3ViIHNyYyB+cG9zIH5sZW4gPVxuICAgIEJ5dGVzMC51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOihzdWIgc3JjIH5wb3MgfmxlbilcbiAgOztcblxuICBsZXQgc3VibyA/cG9zID9sZW4gc3JjID1cbiAgICBCeXRlczAudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTooc3VibyA/cG9zID9sZW4gc3JjKVxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQm9vbDBcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYm9vbFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2Jvb2wgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgYWxsID0gKFsgZmFsc2U7IHRydWUgXSA6IHQgbGlzdClcbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKGdsb2JhbGl6ZV9ib29sIDogdCAtPiB0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfYm9vbFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfYm9vbCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoYm9vbF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9ib29sIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGJvb2xfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5cbiAgbGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBcInRydWVcIiAtPiB0cnVlXG4gICAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgICB8IHMgLT4gaW52YWxpZF9hcmdmIFwiQm9vbC5vZl9zdHJpbmc6IGV4cGVjdGVkIHRydWUgb3IgZmFsc2UgYnV0IGdvdCAlc1wiIHMgKClcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nID0gU3RkbGliLnN0cmluZ19vZl9ib29sXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuQm9vbFwiXG5lbmQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEJvb2xfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgdG9faW50IHggPSBib29sX3RvX2ludCB4XG5cbm1vZHVsZSBOb25fc2hvcnRfY2lyY3VpdGluZyA9IHN0cnVjdFxuICAoKiBXZSBkb24ndCBleHBvc2UgdGhpcywgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0byBicmVhayB0aGUgaW52YXJpYW50IG1lbnRpb25lZCBiZWxvdyBvZlxuICAgICAodG9faW50IHRydWUgPSAxKSBhbmQgKHRvX2ludCBmYWxzZSA9IDApLiAqKVxuICBsZXQgdW5zYWZlX29mX2ludCAoeCA6IGludCkgOiBib29sID0gU3RkbGliLk9iai5tYWdpYyB4XG4gIGxldCAoIHx8ICkgYSBiID0gdW5zYWZlX29mX2ludCAodG9faW50IGEgbG9yIHRvX2ludCBiKVxuICBsZXQgKCAmJiApIGEgYiA9IHVuc2FmZV9vZl9pbnQgKHRvX2ludCBhIGxhbmQgdG9faW50IGIpXG5lbmRcblxuKCogV2UgZG8gdGhpcyBhcyBhIGRpcmVjdCBhc3NlcnQgb24gdGhlIHRoZW9yeSB0aGF0IGl0J3MgYSBjaGVhcCB0aGluZyB0byB0ZXN0IGFuZCBhXG4gICByZWFsbHkgY29yZSBpbnZhcmlhbnQgdGhhdCB3ZSBuZXZlciBleHBlY3QgdG8gYnJlYWssIGFuZCB3ZSBzaG91bGQgYmUgaGFwcHkgZm9yIGFcbiAgIHByb2dyYW0gdG8gZmFpbCBpbW1lZGlhdGVseSBpZiB0aGlzIGlzIHZpb2xhdGVkLiAqKVxubGV0ICgpID0gYXNzZXJ0IChQb2x5LiggPSApICh0b19pbnQgdHJ1ZSkgMSAmJiBQb2x5LiggPSApICh0b19pbnQgZmFsc2UpIDApXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBCb29sX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEVpdGhlcl9pbnRmXG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIEVpdGhlcjBcblxubGV0IHN3YXAgPSBmdW5jdGlvblxuICB8IEZpcnN0IHggLT4gU2Vjb25kIHhcbiAgfCBTZWNvbmQgeCAtPiBGaXJzdCB4XG47O1xuXG5sZXQgaXNfZmlyc3QgPSBmdW5jdGlvblxuICB8IEZpcnN0IF8gLT4gdHJ1ZVxuICB8IFNlY29uZCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfc2Vjb25kID0gZnVuY3Rpb25cbiAgfCBGaXJzdCBfIC0+IGZhbHNlXG4gIHwgU2Vjb25kIF8gLT4gdHJ1ZVxuOztcblxubGV0IHZhbHVlIChGaXJzdCB4IHwgU2Vjb25kIHgpID0geFxuXG5sZXQgdmFsdWVfbWFwIHQgfmZpcnN0IH5zZWNvbmQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBGaXJzdCB4IC0+IGZpcnN0IHhcbiAgfCBTZWNvbmQgeCAtPiBzZWNvbmQgeFxuOztcblxubGV0IGl0ZXIgPSB2YWx1ZV9tYXBcblxubGV0IG1hcCB0IH5maXJzdCB+c2Vjb25kID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRmlyc3QgeCAtPiBGaXJzdCAoZmlyc3QgeClcbiAgfCBTZWNvbmQgeCAtPiBTZWNvbmQgKHNlY29uZCB4KVxuOztcblxubGV0IGZpcnN0IHggPSBGaXJzdCB4XG5sZXQgc2Vjb25kIHggPSBTZWNvbmQgeFxuXG5sZXQgZXF1YWwgZXExIGVxMiB0MSB0MiA9XG4gIG1hdGNoIHQxLCB0MiB3aXRoXG4gIHwgRmlyc3QgeCwgRmlyc3QgeSAtPiBlcTEgeCB5XG4gIHwgU2Vjb25kIHgsIFNlY29uZCB5IC0+IGVxMiB4IHlcbiAgfCBGaXJzdCBfLCBTZWNvbmQgXyB8IFNlY29uZCBfLCBGaXJzdCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgbG9jYWxfZXF1YWwgZXExIGVxMiB0MSB0MiA9XG4gIG1hdGNoIHQxLCB0MiB3aXRoXG4gIHwgRmlyc3QgeCwgRmlyc3QgeSAtPiBlcTEgeCB5XG4gIHwgU2Vjb25kIHgsIFNlY29uZCB5IC0+IGVxMiB4IHlcbiAgfCBGaXJzdCBfLCBTZWNvbmQgXyB8IFNlY29uZCBfLCBGaXJzdCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaW52YXJpYW50IGYgcyA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgeCAtPiBmIHhcbiAgfCBTZWNvbmQgeSAtPiBzIHlcbjs7XG5cbm1vZHVsZSBGb2N1cyA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgIHwgRm9jdXMgb2YgeyB2YWx1ZSA6ICdhIH1cbiAgICB8IE90aGVyIG9mIHsgdmFsdWUgOiAnYiB9XG5lbmRcblxubW9kdWxlIE1ha2VfZm9jdXNlZCAoTSA6IHNpZ1xuICB0eXBlICgrJ2EsICsnYikgdFxuXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcbiAgdmFsIG90aGVyIDogJ2IgLT4gKF8sICdiKSB0XG4gIHZhbCBmb2N1cyA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgRm9jdXMudFxuXG4gIHZhbCBjb21iaW5lXG4gICAgOiAgKCdhLCAnZCkgdFxuICAgIC0+ICgnYiwgJ2QpIHRcbiAgICAtPiBmOignYSAtPiAnYiAtPiAnYylcbiAgICAtPiBvdGhlcjooJ2QgLT4gJ2QgLT4gJ2QpXG4gICAgLT4gKCdjLCAnZCkgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnYikgdCAtPiBmOignYSAtPiAoJ2MsICdiKSB0KSAtPiAoJ2MsICdiKSB0XG5lbmQpID1cbnN0cnVjdFxuICBpbmNsdWRlIE1cbiAgb3BlbiBXaXRoX3JldHVyblxuXG4gIGxldCBtYXAgdCB+ZiA9XG4gICAgbGV0IHJlcyA9IGJpbmQgdCB+ZjooZnVuIHggLT4gcmV0dXJuIChmIHgpKSBpblxuICAgIHJlc1xuICA7O1xuXG4gIGluY2x1ZGUgTW9uYWQuTWFrZTJfbG9jYWwgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxuICBtb2R1bGUgQXBwID0gQXBwbGljYXRpdmUuTWFrZTJfdXNpbmdfbWFwMl9sb2NhbCAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcblxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcblxuICAgIGxldCBtYXAyIDogKCdhLCAneCkgdCAtPiAoJ2IsICd4KSB0IC0+IGY6KCdhIC0+ICdiIC0+ICdjKSAtPiAoJ2MsICd4KSB0ID1cbiAgICAgIGZ1biB0MSB0MiB+ZiAtPlxuICAgICAgYmluZCB0MSB+ZjooZnVuIHggLT4gYmluZCB0MiB+ZjooZnVuIHkgLT4gcmV0dXJuIChmIHggeSkpIFtAbm9udGFpbF0pIFtAbm9udGFpbF1cbiAgICA7O1xuICBlbmQpXG5cbiAgaW5jbHVkZSBBcHBcblxuICBsZXQgY29tYmluZV9hbGwgPVxuICAgIGxldCByZWMgb3RoZXJfbG9vcCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IG90aGVyIGFjY1xuICAgICAgfCB0IDo6IHRzIC0+XG4gICAgICAgIChtYXRjaCBmb2N1cyB0IHdpdGhcbiAgICAgICAgIHwgRm9jdXMgXyAtPiBvdGhlcl9sb29wIGYgYWNjIHRzXG4gICAgICAgICB8IE90aGVyIG8gLT4gb3RoZXJfbG9vcCBmIChmIGFjYyBvLnZhbHVlKSB0cylcbiAgICBpblxuICAgIGxldCByZWMgcmV0dXJuX2xvb3AgZiBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXR1cm4gKExpc3QucmV2IGFjYylcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICAobWF0Y2ggZm9jdXMgdCB3aXRoXG4gICAgICAgICB8IEZvY3VzIHggLT4gcmV0dXJuX2xvb3AgZiAoeC52YWx1ZSA6OiBhY2MpIHRzXG4gICAgICAgICB8IE90aGVyIG8gLT4gb3RoZXJfbG9vcCBmIG8udmFsdWUgdHMpXG4gICAgaW5cbiAgICBmdW4gdHMgfmYgLT4gcmV0dXJuX2xvb3AgZiBbXSB0c1xuICA7O1xuXG4gIGxldCBjb21iaW5lX2FsbF91bml0ID1cbiAgICBsZXQgcmVjIG90aGVyX2xvb3AgZiBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBvdGhlciBhY2NcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICAobWF0Y2ggZm9jdXMgdCB3aXRoXG4gICAgICAgICB8IEZvY3VzIF8gLT4gb3RoZXJfbG9vcCBmIGFjYyB0c1xuICAgICAgICAgfCBPdGhlciBvIC0+IG90aGVyX2xvb3AgZiAoZiBhY2Mgby52YWx1ZSkgdHMpXG4gICAgaW5cbiAgICBsZXQgcmVjIHJldHVybl9sb29wIGYgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXR1cm4gKClcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICAobWF0Y2ggZm9jdXMgdCB3aXRoXG4gICAgICAgICB8IEZvY3VzIHsgdmFsdWUgPSAoKSB9IC0+IHJldHVybl9sb29wIGYgdHNcbiAgICAgICAgIHwgT3RoZXIgeyB2YWx1ZSA9IG8gfSAtPiBvdGhlcl9sb29wIGYgbyB0cylcbiAgICBpblxuICAgIGZ1biB0cyB+ZiAtPiByZXR1cm5fbG9vcCBmIHRzXG4gIDs7XG5cbiAgbGV0IHRvX29wdGlvbiB0ID1cbiAgICBtYXRjaCBmb2N1cyB0IHdpdGhcbiAgICB8IEZvY3VzIHggLT4gU29tZSB4LnZhbHVlXG4gICAgfCBPdGhlciBfIC0+IE5vbmVcbiAgOztcblxuICBsZXQgdmFsdWUgdCB+ZGVmYXVsdCA9XG4gICAgbWF0Y2ggZm9jdXMgdCB3aXRoXG4gICAgfCBGb2N1cyB4IC0+IHgudmFsdWVcbiAgICB8IE90aGVyIF8gLT4gZGVmYXVsdFxuICA7O1xuXG4gIGxldCB3aXRoX3JldHVybiBmID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHJldCAtPiBvdGhlciAoZiAoV2l0aF9yZXR1cm4ucHJlcGVuZCByZXQgfmY6cmV0dXJuKSkpIFtAbm9udGFpbF1cbiAgOztcbmVuZFxuXG5tb2R1bGUgRmlyc3QgPSBNYWtlX2ZvY3VzZWQgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gIGxldCByZXR1cm4gPSBmaXJzdFxuICBsZXQgb3RoZXIgPSBzZWNvbmRcblxuICBsZXQgZm9jdXMgdCA6IF8gRm9jdXMudCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBGaXJzdCB4IC0+IEZvY3VzIHsgdmFsdWUgPSB4IH1cbiAgICB8IFNlY29uZCB5IC0+IE90aGVyIHsgdmFsdWUgPSB5IH1cbiAgOztcblxuICBsZXQgY29tYmluZSB0MSB0MiB+ZiB+b3RoZXIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBGaXJzdCB4LCBGaXJzdCB5IC0+IEZpcnN0IChmIHggeSlcbiAgICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBTZWNvbmQgKG90aGVyIHggeSlcbiAgICB8IFNlY29uZCB4LCBfIHwgXywgU2Vjb25kIHggLT4gU2Vjb25kIHhcbiAgOztcblxuICBsZXQgYmluZCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEZpcnN0IHggLT4gZiB4XG4gICAgKCogUmV1c2UgdGhlIHZhbHVlIGluIG9yZGVyIHRvIGF2b2lkIGFsbG9jYXRpb24uICopXG4gICAgfCBTZWNvbmQgXyBhcyB5IC0+IHlcbiAgOztcbmVuZClcblxubW9kdWxlIFNlY29uZCA9IE1ha2VfZm9jdXNlZCAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2IsICdhKSB0XG5cbiAgbGV0IHJldHVybiA9IHNlY29uZFxuICBsZXQgb3RoZXIgPSBmaXJzdFxuXG4gIGxldCBmb2N1cyB0IDogXyBGb2N1cy50ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFNlY29uZCB4IC0+IEZvY3VzIHsgdmFsdWUgPSB4IH1cbiAgICB8IEZpcnN0IHkgLT4gT3RoZXIgeyB2YWx1ZSA9IHkgfVxuICA7O1xuXG4gIGxldCBjb21iaW5lIHQxIHQyIH5mIH5vdGhlciA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBTZWNvbmQgKGYgeCB5KVxuICAgIHwgRmlyc3QgeCwgRmlyc3QgeSAtPiBGaXJzdCAob3RoZXIgeCB5KVxuICAgIHwgRmlyc3QgeCwgXyB8IF8sIEZpcnN0IHggLT4gRmlyc3QgeFxuICA7O1xuXG4gIGxldCBiaW5kIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgU2Vjb25kIHggLT4gZiB4XG4gICAgKCogUmV1c2UgdGhlIHZhbHVlIGluIG9yZGVyIHRvIGF2b2lkIGFsbG9jYXRpb24sIGxpa2UgW0ZpcnN0LmJpbmRdIGFib3ZlLiAqKVxuICAgIHwgRmlyc3QgXyBhcyB5IC0+IHlcbiAgOztcbmVuZClcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICB0eXBlICgnZiwgJ3MpIF9laXRoZXIgPSAoJ2YsICdzKSB0ID1cbiAgICB8IEZpcnN0IG9mICdmXG4gICAgfCBTZWNvbmQgb2YgJ3NcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbmluY2x1ZGUgKFxuICBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSBvcHRpb25cbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgbGV0IGNvbXBhcmVfX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICAgICAgY29tcGFyZV9vcHRpb25fX2xvY2FsXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPSBjb21wYXJlX29wdGlvblxuXG4gICAgbGV0IGdsb2JhbGl6ZSA6ICdhLiAoJ2EgLT4gJ2EpIC0+ICdhIHQgLT4gJ2EgdCA9XG4gICAgICBmdW4gKHR5cGUgYV9fMDA5XykgOiAoKGFfXzAwOV8gLT4gYV9fMDA5XykgLT4gYV9fMDA5XyB0IC0+IGFfXzAwOV8gdCkgLT5cbiAgICAgIGdsb2JhbGl6ZV9vcHRpb25cbiAgICA7O1xuXG4gICAgbGV0IGhhc2hfZm9sZF90IDpcbiAgICAgICAgICAnYS5cbiAgICAgICAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAgICAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAgICAgICAtPiAnYSB0XG4gICAgICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgICA9XG4gICAgICBoYXNoX2ZvbGRfb3B0aW9uXG4gICAgOztcblxuICAgIGxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPVxuICAgICAgb3B0aW9uX29mX3NleHBcbiAgICA7O1xuXG4gICAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgICBzZXhwX29mX29wdGlvblxuICAgIDs7XG5cbiAgICBsZXQgdF9zZXhwX2dyYW1tYXIgOiAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCA9XG4gICAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBvcHRpb25fc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cbiAgZW5kIDpcbiAgICBzaWdcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIG9wdGlvblxuICAgICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gICAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlNfbG9jYWwxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAgICAgdmFsIGdsb2JhbGl6ZSA6ICgnYSAtPiAnYSkgLT4gJ2EgdCAtPiAnYSB0XG5cbiAgICAgIGluY2x1ZGUgUHB4X2hhc2hfbGliLkhhc2hhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgICAgIGluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgICB2YWwgdF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgICAgIFtAQEBlbmRdXG4gICAgZW5kKVxuXG50eXBlICdhIHQgPSAnYSBvcHRpb24gPVxuICB8IE5vbmVcbiAgfCBTb21lIG9mICdhXG5cbmxldCBpc19ub25lID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfc29tZSA9IGZ1bmN0aW9uXG4gIHwgU29tZSBfIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgdmFsdWVfbWFwIG8gfmRlZmF1bHQgfmYgPVxuICBtYXRjaCBvIHdpdGhcbiAgfCBTb21lIHggLT4gZiB4XG4gIHwgTm9uZSAtPiBkZWZhdWx0XG47O1xuXG5sZXQgaXRlciBvIH5mID1cbiAgbWF0Y2ggbyB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgYSAtPiBmIGFcbjs7XG5cbmxldCBpbnZhcmlhbnQgZiB0ID0gaXRlciB0IH5mXG5cbmxldCBjYWxsIHggfmYgPVxuICBtYXRjaCBmIHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBmIC0+IGYgeFxuOztcblxubGV0IHZhbHVlIHQgfmRlZmF1bHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IGRlZmF1bHRcbiAgfCBTb21lIHggLT4geFxuOztcblxubGV0IHZhbHVlX2V4biA/aGVyZSA/ZXJyb3IgP21lc3NhZ2UgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNvbWUgeCAtPiB4XG4gIHwgTm9uZSAtPlxuICAgIGxldCBlcnJvciA9XG4gICAgICBtYXRjaCBoZXJlLCBlcnJvciwgbWVzc2FnZSB3aXRoXG4gICAgICB8IE5vbmUsIE5vbmUsIE5vbmUgLT4gRXJyb3Iub2Zfc3RyaW5nIFwiT3B0aW9uLnZhbHVlX2V4biBOb25lXCJcbiAgICAgIHwgTm9uZSwgTm9uZSwgU29tZSBtIC0+IEVycm9yLm9mX3N0cmluZyBtXG4gICAgICB8IE5vbmUsIFNvbWUgZSwgTm9uZSAtPiBlXG4gICAgICB8IE5vbmUsIFNvbWUgZSwgU29tZSBtIC0+IEVycm9yLnRhZyBlIH50YWc6bVxuICAgICAgfCBTb21lIHAsIE5vbmUsIE5vbmUgLT5cbiAgICAgICAgRXJyb3IuY3JlYXRlIFwiT3B0aW9uLnZhbHVlX2V4blwiIHAgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdFxuICAgICAgfCBTb21lIHAsIE5vbmUsIFNvbWUgbSAtPiBFcnJvci5jcmVhdGUgbSBwIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3RcbiAgICAgIHwgU29tZSBwLCBTb21lIGUsIF8gLT5cbiAgICAgICAgRXJyb3IuY3JlYXRlXG4gICAgICAgICAgKHZhbHVlIG1lc3NhZ2UgfmRlZmF1bHQ6XCJcIilcbiAgICAgICAgICAoZSwgcClcbiAgICAgICAgICAoc2V4cF9vZl9wYWlyIEVycm9yLnNleHBfb2ZfdCBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90KVxuICAgIGluXG4gICAgRXJyb3IucmFpc2UgZXJyb3Jcbjs7XG5cbmxldCB2YWx1ZV9vcl90aHVuayBvIH5kZWZhdWx0ID1cbiAgbWF0Y2ggbyB3aXRoXG4gIHwgU29tZSB4IC0+IHhcbiAgfCBOb25lIC0+IGRlZmF1bHQgKClcbjs7XG5cbmxldCB0b19hcnJheSB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBbfHxdXG4gIHwgU29tZSB4IC0+IFt8IHggfF1cbjs7XG5cbmxldCB0b19saXN0IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSB4IC0+IFsgeCBdXG47O1xuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiB0cnVlXG4gIHwgU29tZSB4IC0+IGYgeFxuOztcblxubGV0IGV4aXN0cyB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBmYWxzZVxuICB8IFNvbWUgeCAtPiBmIHhcbjs7XG5cbmxldCBtZW0gdCBhIH5lcXVhbCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gZmFsc2VcbiAgfCBTb21lIGEnIC0+IGVxdWFsIGEgYSdcbjs7XG5cbmxldCBsZW5ndGggdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gMFxuICB8IFNvbWUgXyAtPiAxXG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBpbml0XG4gIHwgU29tZSB4IC0+IGYgaW5pdCB4XG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSB4IC0+IGlmIGYgeCB0aGVuIHQgZWxzZSBOb25lXG47O1xuXG5sZXQgZmluZF9tYXAgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgYSAtPiBmIGFcbjs7XG5cbmxldCBlcXVhbCBmIHQgdCcgPVxuICBtYXRjaCB0LCB0JyB3aXRoXG4gIHwgTm9uZSwgTm9uZSAtPiB0cnVlXG4gIHwgU29tZSB4LCBTb21lIHgnIC0+IGYgeCB4J1xuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBlcXVhbF9fbG9jYWwgZiB0IHQnID1cbiAgbWF0Y2ggdCwgdCcgd2l0aFxuICB8IE5vbmUsIE5vbmUgLT4gdHJ1ZVxuICB8IFNvbWUgeCwgU29tZSB4JyAtPiBmIHggeCdcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgc29tZSB4ID0gU29tZSB4XG5cbmxldCBmaXJzdF9zb21lIHggeSA9XG4gIG1hdGNoIHggd2l0aFxuICB8IFNvbWUgXyAtPiB4XG4gIHwgTm9uZSAtPiB5XG47O1xuXG5sZXQgc29tZV9pZiBjb25kIHggPSBpZiBjb25kIHRoZW4gU29tZSB4IGVsc2UgTm9uZVxuXG5sZXQgbWVyZ2UgYSBiIH5mID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgTm9uZSwgeCB8IHgsIE5vbmUgLT4geFxuICB8IFNvbWUgYSwgU29tZSBiIC0+IFNvbWUgKGYgYSBiKVxuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU29tZSB2IGFzIG8gd2hlbiBmIHYgLT4gb1xuICB8IF8gLT4gTm9uZVxuOztcblxubGV0IHRyeV93aXRoIGYgPVxuICBtYXRjaCBmICgpIHdpdGhcbiAgfCB4IC0+IFNvbWUgeFxuICB8IGV4Y2VwdGlvbiBfIC0+IE5vbmVcbjs7XG5cbmxldCB0cnlfd2l0aF9qb2luIGYgPVxuICBtYXRjaCBmICgpIHdpdGhcbiAgfCB4IC0+IHhcbiAgfCBleGNlcHRpb24gXyAtPiBOb25lXG47O1xuXG5sZXQgbWFwIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGEgLT4gU29tZSAoZiBhKVxuOztcblxubW9kdWxlIE1vbmFkX2FyZyA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBvcHRpb25cblxuICBsZXQgcmV0dXJuIHggPSBTb21lIHhcbiAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG5cbiAgbGV0IGJpbmQgbyB+ZiA9XG4gICAgbWF0Y2ggbyB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBmIHhcbiAgOztcbmVuZFxuXG5pbmNsdWRlIE1vbmFkLk1ha2VfbG9jYWwgKE1vbmFkX2FyZylcblxubW9kdWxlIEFwcGxpY2F0aXZlX2FyZyA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBvcHRpb25cblxuICBsZXQgcmV0dXJuIHggPSBTb21lIHhcbiAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG5cbiAgbGV0IG1hcDIgeCB5IH5mID1cbiAgICBtYXRjaCB4LCB5IHdpdGhcbiAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeCwgU29tZSB5IC0+IFNvbWUgKGYgeCB5KVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgQXBwbGljYXRpdmUuTWFrZV91c2luZ19tYXAyX2xvY2FsIChBcHBsaWNhdGl2ZV9hcmcpXG4iLCJtb2R1bGUgTGlzdCA9IExpc3RcblxubW9kdWxlIEVudW1lcmFibGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGFsbCA6IHQgbGlzdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGFsbCA6ICdhIGxpc3QgLT4gJ2EgdCBsaXN0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgYWxsIDogJ2EgbGlzdCAtPiAnYiBsaXN0IC0+ICgnYSwgJ2IpIHQgbGlzdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBhbGwgOiAnYSBsaXN0IC0+ICdiIGxpc3QgLT4gJ2MgbGlzdCAtPiAoJ2EsICdiLCAnYykgdCBsaXN0XG4gIGVuZFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm9wZW4gQ29udGFpbmVyX2ludGYuRXhwb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBMaXN0ID0gTGlzdDFcblxubW9kdWxlIFN0ZXAgPSBzdHJ1Y3RcbiAgKCogJ2EgaXMgYW4gaXRlbSBpbiB0aGUgc2VxdWVuY2UsICdzIGlzIHRoZSBzdGF0ZSB0aGF0IHdpbGwgcHJvZHVjZSB0aGUgcmVtYWluZGVyIG9mXG4gICAgIHRoZSBzZXF1ZW5jZSAqKVxuICB0eXBlICgnYSwgJ3MpIHQgPVxuICAgIHwgRG9uZVxuICAgIHwgU2tpcCBvZiB7IHN0YXRlIDogJ3MgfVxuICAgIHwgWWllbGQgb2ZcbiAgICAgICAgeyB2YWx1ZSA6ICdhXG4gICAgICAgIDsgc3RhdGUgOiAnc1xuICAgICAgICB9XG4gIFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICAgICAnYSAncy5cbiAgICAgICAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdzIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdhLCAncykgdFxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuICh0eXBlIGFfXzAxMV8gc19fMDEyXylcbiAgICAgIDogICgoYV9fMDExXyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChzX18wMTJfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+IChhX18wMTFfLCBzX18wMTJfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzAwMV8gX29mX3NfXzAwMl8gLT4gZnVuY3Rpb25cbiAgICB8IERvbmUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiRG9uZVwiXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzdGF0ZV9fMDA0XyB9IC0+XG4gICAgICBsZXQgYm5kc19fMDAzXyA9IChbXSA6IF8gU3RkbGliLkxpc3QudCkgaW5cbiAgICAgIGxldCBibmRzX18wMDNfID1cbiAgICAgICAgbGV0IGFyZ19fMDA1XyA9IF9vZl9zX18wMDJfIHN0YXRlX18wMDRfIGluXG4gICAgICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJzdGF0ZVwiOyBhcmdfXzAwNV8gXSA6OiBibmRzX18wMDNfXG4gICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gXCJTa2lwXCIgOjogYm5kc19fMDAzXylcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSB2YWx1ZV9fMDA3Xzsgc3RhdGUgPSBzdGF0ZV9fMDA5XyB9IC0+XG4gICAgICBsZXQgYm5kc19fMDA2XyA9IChbXSA6IF8gU3RkbGliLkxpc3QudCkgaW5cbiAgICAgIGxldCBibmRzX18wMDZfID1cbiAgICAgICAgbGV0IGFyZ19fMDEwXyA9IF9vZl9zX18wMDJfIHN0YXRlX18wMDlfIGluXG4gICAgICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJzdGF0ZVwiOyBhcmdfXzAxMF8gXSA6OiBibmRzX18wMDZfXG4gICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICBpblxuICAgICAgbGV0IGJuZHNfXzAwNl8gPVxuICAgICAgICBsZXQgYXJnX18wMDhfID0gX29mX2FfXzAwMV8gdmFsdWVfXzAwN18gaW5cbiAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInZhbHVlXCI7IGFyZ19fMDA4XyBdIDo6IGJuZHNfXzAwNl9cbiAgICAgICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgICAgIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSBcIllpZWxkXCIgOjogYm5kc19fMDA2XylcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm9wZW4gU3RlcFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICAoKiAnYSBpcyBhbiBpdGVtIGluIHRoZSBzZXF1ZW5jZSwgJ3MgaXMgdGhlIHN0YXRlIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSByZW1haW5kZXIgb2YgdGhlXG4gICAgIHNlcXVlbmNlICopXG4gIHR5cGUgK18gdCA9XG4gICAgfCBTZXF1ZW5jZSA6XG4gICAgICAgIHsgc3RhdGUgOiAnc1xuICAgICAgICA7IG5leHQgOiAncyAtPiAoJ2EsICdzKSBTdGVwLnRcbiAgICAgICAgfVxuICAgICAgICAtPiAnYSB0XG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBnbG9iYWxpemUgXyAoU2VxdWVuY2UgeyBzdGF0ZTsgbmV4dCB9KSA9IFNlcXVlbmNlIHsgc3RhdGU7IG5leHQgfVxuXG5tb2R1bGUgRXhwZXJ0ID0gc3RydWN0XG4gIG1vZHVsZSBWaWV3ID0gVFxuXG4gIGxldCB2aWV3IHQgPSB0XG5cbiAgbGV0IG5leHRfc3RlcCAoU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgPSBmIH0pID1cbiAgICBtYXRjaCBmIHMgd2l0aFxuICAgIHwgRG9uZSAtPiBEb25lXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgPSBmIH0gfVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCA9IGYgfSB9XG4gIDs7XG5cbiAgbGV0IGRlbGF5ZWRfZm9sZF9zdGVwIHMgfmluaXQgfmYgfmZpbmlzaCA9XG4gICAgbGV0IHJlYyBsb29wIHMgbmV4dCBmaW5pc2ggZiBhY2MgPVxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBmaW5pc2ggYWNjXG4gICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBmIGFjYyBOb25lIH5rOihsb29wIHMgbmV4dCBmaW5pc2ggZilcbiAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IGYgYWNjIChTb21lIGEpIH5rOihsb29wIHMgbmV4dCBmaW5pc2ggZilcbiAgICBpblxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPiBsb29wIHMgbmV4dCBmaW5pc2ggZiBpbml0XG4gIDs7XG5lbmRcblxubGV0IHVuZm9sZF9zdGVwIH5pbml0IH5mID0gU2VxdWVuY2UgeyBzdGF0ZSA9IGluaXQ7IG5leHQgPSBmIH1cblxubGV0IHVuZm9sZCB+aW5pdCB+ZiA9XG4gIHVuZm9sZF9zdGVwIH5pbml0IH5mOihmdW4gcyAtPlxuICAgIG1hdGNoIGYgcyB3aXRoXG4gICAgfCBOb25lIC0+IFN0ZXAuRG9uZVxuICAgIHwgU29tZSAoYSwgcykgLT4gU3RlcC5ZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0pXG47O1xuXG5sZXQgdW5mb2xkX3dpdGggcyB+aW5pdCB+ZiA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IGluaXQsIHNcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1biAoc2VlZCwgcykgLT5cbiAgICAgICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gc2VlZCwgcyB9XG4gICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgICAgICAgICAobWF0Y2ggZiBzZWVkIGEgd2l0aFxuICAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gc2VlZCB9IC0+IFNraXAgeyBzdGF0ZSA9IHNlZWQsIHMgfVxuICAgICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzZWVkIH0gLT4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gc2VlZCwgcyB9KSlcbiAgICAgIH1cbjs7XG5cbmxldCB1bmZvbGRfd2l0aF9hbmRfZmluaXNoIHMgfmluaXQgfnJ1bm5pbmdfc3RlcCB+aW5uZXJfZmluaXNoZWQgfmZpbmlzaGluZ19zdGVwID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gYElubmVyX3J1bm5pbmcgKGluaXQsIHMpXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW4gc3RhdGUgLT5cbiAgICAgICAgICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgICAgICAgIHwgYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkgLT5cbiAgICAgICAgICAgICAgKG1hdGNoIG5leHQgaW5uZXJfc3RhdGUgd2l0aFxuICAgICAgICAgICAgICAgfCBEb25lIC0+IFNraXAgeyBzdGF0ZSA9IGBJbm5lcl9maW5pc2hlZCAoaW5uZXJfZmluaXNoZWQgc3RhdGUpIH1cbiAgICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gaW5uZXJfc3RhdGUgfSAtPlxuICAgICAgICAgICAgICAgICBTa2lwIHsgc3RhdGUgPSBgSW5uZXJfcnVubmluZyAoc3RhdGUsIGlubmVyX3N0YXRlKSB9XG4gICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IGlubmVyX3N0YXRlIH0gLT5cbiAgICAgICAgICAgICAgICAgKG1hdGNoIHJ1bm5pbmdfc3RlcCBzdGF0ZSB4IHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSB9IC0+IFNraXAgeyBzdGF0ZSA9IGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpIH1cbiAgICAgICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IHk7IHN0YXRlIH0gLT5cbiAgICAgICAgICAgICAgICAgICAgWWllbGQgeyB2YWx1ZSA9IHk7IHN0YXRlID0gYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkgfSkpXG4gICAgICAgICAgICB8IGBJbm5lcl9maW5pc2hlZCBzdGF0ZSAtPlxuICAgICAgICAgICAgICAobWF0Y2ggZmluaXNoaW5nX3N0ZXAgc3RhdGUgd2l0aFxuICAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlIH0gLT4gU2tpcCB7IHN0YXRlID0gYElubmVyX2ZpbmlzaGVkIHN0YXRlIH1cbiAgICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IHk7IHN0YXRlIH0gLT5cbiAgICAgICAgICAgICAgICAgWWllbGQgeyB2YWx1ZSA9IHk7IHN0YXRlID0gYElubmVyX2ZpbmlzaGVkIHN0YXRlIH0pKVxuICAgICAgfVxuOztcblxubGV0IG9mX2xpc3QgbCA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OmwgfmY6KGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBEb25lXG4gICAgfCB4IDo6IGwgLT4gWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gbCB9KVxuOztcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzZWVkIHYgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgIHwgRG9uZSAtPiB2XG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIHYgbmV4dCBmXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIChmIHYgYSkgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIGluaXQgbmV4dCBmXG47O1xuXG5sZXQgdG9fbGlzdF9yZXYgdCA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIGwgeCAtPiB4IDo6IGwpXG5cbmxldCB0b19saXN0IChTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KSA9XG4gIGxldFtAdGFpbF9tb2RfY29uc10gcmVjIHRvX2xpc3QgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBbXVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+ICh0b19saXN0IFtAdGFpbGNhbGxdKSBzIG5leHRcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBhIDo6ICh0b19saXN0IFtAdGFpbGNhbGxdKSBzIG5leHRcbiAgaW5cbiAgdG9fbGlzdCBzIG5leHRcbjs7XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl9hICh0b19saXN0IHQpXG5cbmxldCByYW5nZSA/KHN0cmlkZSA9IDEpID8oc3RhcnQgPSBgaW5jbHVzaXZlKSA/KHN0b3AgPSBgZXhjbHVzaXZlKSBzdGFydF92IHN0b3BfdiA9XG4gIGxldCBzdGVwID1cbiAgICBtYXRjaCBzdG9wIHdpdGhcbiAgICB8IGBpbmNsdXNpdmUgd2hlbiBzdHJpZGUgPj0gMCAtPlxuICAgICAgZnVuIGkgLT4gaWYgaSA+IHN0b3BfdiB0aGVuIERvbmUgZWxzZSBZaWVsZCB7IHZhbHVlID0gaTsgc3RhdGUgPSBpICsgc3RyaWRlIH1cbiAgICB8IGBpbmNsdXNpdmUgLT5cbiAgICAgIGZ1biBpIC0+IGlmIGkgPCBzdG9wX3YgdGhlbiBEb25lIGVsc2UgWWllbGQgeyB2YWx1ZSA9IGk7IHN0YXRlID0gaSArIHN0cmlkZSB9XG4gICAgfCBgZXhjbHVzaXZlIHdoZW4gc3RyaWRlID49IDAgLT5cbiAgICAgIGZ1biBpIC0+IGlmIGkgPj0gc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIHsgdmFsdWUgPSBpOyBzdGF0ZSA9IGkgKyBzdHJpZGUgfVxuICAgIHwgYGV4Y2x1c2l2ZSAtPlxuICAgICAgZnVuIGkgLT4gaWYgaSA8PSBzdG9wX3YgdGhlbiBEb25lIGVsc2UgWWllbGQgeyB2YWx1ZSA9IGk7IHN0YXRlID0gaSArIHN0cmlkZSB9XG4gIGluXG4gIGxldCBpbml0ID1cbiAgICBtYXRjaCBzdGFydCB3aXRoXG4gICAgfCBgaW5jbHVzaXZlIC0+IHN0YXJ0X3ZcbiAgICB8IGBleGNsdXNpdmUgLT4gc3RhcnRfdiArIHN0cmlkZVxuICBpblxuICB1bmZvbGRfc3RlcCB+aW5pdCB+ZjpzdGVwXG47O1xuXG5sZXQgb2ZfbGF6eSB0X2xhenkgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDp0X2xhenkgfmY6KGZ1biB0X2xhenkgLT5cbiAgICBsZXQgKFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0pID0gTGF6eS5mb3JjZSB0X2xhenkgaW5cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBEb25lXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT5cbiAgICAgIFNraXBcbiAgICAgICAgeyBzdGF0ZSA9XG4gICAgICAgICAgICAobGV0IHYgPSBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IGluXG4gICAgICAgICAgICAgbGF6eSB2KVxuICAgICAgICB9XG4gICAgfCBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBzIH0gLT5cbiAgICAgIFlpZWxkXG4gICAgICAgIHsgdmFsdWUgPSB4XG4gICAgICAgIDsgc3RhdGUgPVxuICAgICAgICAgICAgKGxldCB2ID0gU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSBpblxuICAgICAgICAgICAgIGxhenkgdilcbiAgICAgICAgfSlcbjs7XG5cbmxldCBtYXAgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IHNlZWRcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1biBzZWVkIC0+XG4gICAgICAgICAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IHMgfVxuICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gWWllbGQgeyB2YWx1ZSA9IGYgYTsgc3RhdGUgPSBzIH0pXG4gICAgICB9XG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gMCwgc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIChpLCBzKSAtPlxuICAgICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBpLCBzIH1cbiAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IFlpZWxkIHsgdmFsdWUgPSBmIGkgYTsgc3RhdGUgPSBpICsgMSwgcyB9KVxuICAgICAgfVxuOztcblxubGV0IGZvbGRpbmdfbWFwIHQgfmluaXQgfmYgPVxuICB1bmZvbGRfd2l0aCB0IH5pbml0IH5mOihmdW4gYWNjIHggLT5cbiAgICBsZXQgYWNjLCB4ID0gZiBhY2MgeCBpblxuICAgIFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IGFjYyB9KVxuOztcblxubGV0IGZvbGRpbmdfbWFwaSB0IH5pbml0IH5mID1cbiAgdW5mb2xkX3dpdGggdCB+aW5pdDooMCwgaW5pdCkgfmY6KGZ1biAoaSwgYWNjKSB4IC0+XG4gICAgbGV0IGFjYywgeCA9IGYgaSBhY2MgeCBpblxuICAgIFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IGkgKyAxLCBhY2MgfSlcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IHNlZWRcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1biBzZWVkIC0+XG4gICAgICAgICAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IHMgfVxuICAgICAgICAgICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gd2hlbiBmIGEgLT4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9XG4gICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBzIH0pXG4gICAgICB9XG47O1xuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgbWFwIH5mOnNuZCAoZmlsdGVyIChtYXBpIHQgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKSlcbjs7XG5cbmxldCBsZW5ndGggdCA9XG4gIGxldCByZWMgbG9vcCBpIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gaVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgaSBzIG5leHRcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSAtPiBsb29wIChpICsgMSkgcyBuZXh0XG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCAwIHNlZWQgbmV4dFxuOztcblxubGV0IHRvX2xpc3RfcmV2X3dpdGhfbGVuZ3RoIHQgPSBmb2xkIHQgfmluaXQ6KFtdLCAwKSB+ZjooZnVuIChsLCBpKSB4IC0+IHggOjogbCwgaSArIDEpXG5cbmxldCB0b19hcnJheSB0ID1cbiAgbGV0IGwsIGxlbiA9IHRvX2xpc3RfcmV2X3dpdGhfbGVuZ3RoIHQgaW5cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IHggOjogbCAtPlxuICAgIGxldCBhID0gQXJyYXkuY3JlYXRlIH5sZW4geCBpblxuICAgIGxldCByZWMgbG9vcCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCAoaSA9IC0xKVxuICAgICAgfCB4IDo6IGwgLT5cbiAgICAgICAgYS4oaSkgPC0geDtcbiAgICAgICAgbG9vcCAoaSAtIDEpIGxcbiAgICBpblxuICAgIGxvb3AgKGxlbiAtIDIpIGw7XG4gICAgYVxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gXyB9IHdoZW4gZiBhIC0+IFNvbWUgYVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dCBmXG47O1xuXG5sZXQgZmluZF9tYXAgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAobWF0Y2ggZiBhIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gbG9vcCBzIG5leHQgZlxuICAgICAgIHwgc29tZV9iIC0+IHNvbWVfYilcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGkgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgKG1hdGNoIGYgaSBhIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gbG9vcCBzIG5leHQgZiAoaSArIDEpXG4gICAgICAgfCBzb21lX2IgLT4gc29tZV9iKVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGYgaVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBuZXh0IGYgMFxuOztcblxubGV0IGZvcl9hbGwgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gdHJ1ZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gXyB9IHdoZW4gbm90IChmIGEpIC0+IGZhbHNlXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGkgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IHRydWVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IF8gfSB3aGVuIG5vdCAoZiBpIGEpIC0+IGZhbHNlXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZiAoaSArIDEpXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZiBpXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgZiAwXG47O1xuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGZhbHNlXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBfIH0gd2hlbiBmIGEgLT4gdHJ1ZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPiBsb29wIHNlZWQgbmV4dCBmXG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGkgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGZhbHNlXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBfIH0gd2hlbiBmIGkgYSAtPiB0cnVlXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZiAoaSArIDEpXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgZiBpXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHQgZiAwXG47O1xuXG5sZXQgaXRlciB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHNlZWQgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgIHwgRG9uZSAtPiAoKVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGZcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgZiBhO1xuICAgICAgbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBpc19lbXB0eSB0ID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gdHJ1ZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0XG4gICAgfCBZaWVsZCBfIC0+IGZhbHNlXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzZWVkOyBuZXh0IH0gLT4gbG9vcCBzZWVkIG5leHRcbjs7XG5cbmxldCBtZW0gdCBhIH5lcXVhbCA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgYSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmFsc2VcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IF8gfSB3aGVuIGVxdWFsIGEgYiAtPiB0cnVlXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHQgYVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBuZXh0IGEgW0Bub250YWlsXVxuOztcblxubGV0IGVtcHR5ID0gU2VxdWVuY2UgeyBzdGF0ZSA9ICgpOyBuZXh0ID0gKGZ1biAoKSAtPiBEb25lKSB9XG5cbmxldCBiaW5kIHQgfmYgPVxuICB1bmZvbGRfc3RlcFxuICAgIH5mOihmdW5jdGlvblxuICAgICAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9LCByZXN0IC0+XG4gICAgICAgIChtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICAgfCBEb25lIC0+XG4gICAgICAgICAgIChtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgICAgIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPlxuICAgICAgICAgICAgICAobWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgICAgICAgICAgICBTa2lwIHsgc3RhdGUgPSBlbXB0eSwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSB9XG4gICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgICAgICAgICAgICBTa2lwIHsgc3RhdGUgPSBmIGEsIFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gfSkpXG4gICAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9LCByZXN0IH1cbiAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+XG4gICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0sIHJlc3QgfSkpXG4gICAgfmluaXQ6KGVtcHR5LCB0KVxuOztcblxubGV0IHJldHVybiB4ID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6KFNvbWUgeCkgfmY6KGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IERvbmVcbiAgICB8IFNvbWUgeCAtPiBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBOb25lIH0pXG47O1xuXG5pbmNsdWRlIE1vbmFkLk1ha2UgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBsZXQgYmluZCA9IGJpbmRcbiAgbGV0IHJldHVybiA9IHJldHVyblxuZW5kKVxuXG5sZXQgbnRoIHMgbiA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgaSBzIG5leHQgPVxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBOb25lXG4gICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIGkgcyBuZXh0XG4gICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgICBpZiBwaHlzX2VxdWFsIGkgMCB0aGVuIFNvbWUgYSBlbHNlIGxvb3AgKGkgLSAxKSBzIG5leHRcbiAgICBpblxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPiBsb29wIG4gcyBuZXh0KVxuOztcblxubGV0IG50aF9leG4gcyBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcXVlbmNlLm50aFwiXG4gIGVsc2UgKFxuICAgIG1hdGNoIG50aCBzIG4gd2l0aFxuICAgIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLm50aFwiXG4gICAgfCBTb21lIHggLT4geClcbjs7XG5cbm1vZHVsZSBNZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgIHwgTGVmdCBvZiAnYVxuICAgIHwgUmlnaHQgb2YgJ2JcbiAgICB8IEJvdGggb2YgJ2EgKiAnYlxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA6XG4gICAgICAgICdhICdiLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAoJ2IgLT4gJ2IgLT4gaW50KSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gaW50XG4gICAgPVxuICAgIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDIzXyBiX18wMjRfIC0+XG4gICAgaWYgU3RkbGliLiggPT0gKSBhX18wMjNfIGJfXzAyNF9cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzAyM18sIGJfXzAyNF8gd2l0aFxuICAgICAgfCBMZWZ0IF9hX18wMjVfLCBMZWZ0IF9iX18wMjZfIC0+IF9jbXBfX2EgX2FfXzAyNV8gX2JfXzAyNl9cbiAgICAgIHwgTGVmdCBfLCBfIC0+IC0xXG4gICAgICB8IF8sIExlZnQgXyAtPiAxXG4gICAgICB8IFJpZ2h0IF9hX18wMjdfLCBSaWdodCBfYl9fMDI4XyAtPiBfY21wX19iIF9hX18wMjdfIF9iX18wMjhfXG4gICAgICB8IFJpZ2h0IF8sIF8gLT4gLTFcbiAgICAgIHwgXywgUmlnaHQgXyAtPiAxXG4gICAgICB8IEJvdGggKF9hX18wMjlfLCBfYV9fMDMxXyksIEJvdGggKF9iX18wMzBfLCBfYl9fMDMyXykgLT5cbiAgICAgICAgKG1hdGNoIF9jbXBfX2EgX2FfXzAyOV8gX2JfXzAzMF8gd2l0aFxuICAgICAgICAgfCAwIC0+IF9jbXBfX2IgX2FfXzAzMV8gX2JfXzAzMl9cbiAgICAgICAgIHwgbiAtPiBuKSlcbiAgOztcblxuICBsZXQgY29tcGFyZSA6XG4gICAgICAgICdhICdiLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAoJ2IgLT4gJ2IgLT4gaW50KSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gaW50XG4gICAgPVxuICAgIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDEzXyBiX18wMTRfIC0+XG4gICAgaWYgU3RkbGliLiggPT0gKSBhX18wMTNfIGJfXzAxNF9cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzAxM18sIGJfXzAxNF8gd2l0aFxuICAgICAgfCBMZWZ0IF9hX18wMTVfLCBMZWZ0IF9iX18wMTZfIC0+IF9jbXBfX2EgX2FfXzAxNV8gX2JfXzAxNl9cbiAgICAgIHwgTGVmdCBfLCBfIC0+IC0xXG4gICAgICB8IF8sIExlZnQgXyAtPiAxXG4gICAgICB8IFJpZ2h0IF9hX18wMTdfLCBSaWdodCBfYl9fMDE4XyAtPiBfY21wX19iIF9hX18wMTdfIF9iX18wMThfXG4gICAgICB8IFJpZ2h0IF8sIF8gLT4gLTFcbiAgICAgIHwgXywgUmlnaHQgXyAtPiAxXG4gICAgICB8IEJvdGggKF9hX18wMTlfLCBfYV9fMDIxXyksIEJvdGggKF9iX18wMjBfLCBfYl9fMDIyXykgLT5cbiAgICAgICAgKG1hdGNoIF9jbXBfX2EgX2FfXzAxOV8gX2JfXzAyMF8gd2l0aFxuICAgICAgICAgfCAwIC0+IF9jbXBfX2IgX2FfXzAyMV8gX2JfXzAyMl9cbiAgICAgICAgIHwgbiAtPiBuKSlcbiAgOztcblxuICBsZXQgZXF1YWxfX2xvY2FsIDpcbiAgICAgICAgJ2EgJ2IuXG4gICAgICAgICgnYSAtPiAnYSAtPiBib29sKSAtPiAoJ2IgLT4gJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGJvb2xcbiAgICA9XG4gICAgZnVuIF9jbXBfX2EgX2NtcF9fYiBhX18wNDNfIGJfXzA0NF8gLT5cbiAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzA0M18gYl9fMDQ0X1xuICAgIHRoZW4gdHJ1ZVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDQzXywgYl9fMDQ0XyB3aXRoXG4gICAgICB8IExlZnQgX2FfXzA0NV8sIExlZnQgX2JfXzA0Nl8gLT4gX2NtcF9fYSBfYV9fMDQ1XyBfYl9fMDQ2X1xuICAgICAgfCBMZWZ0IF8sIF8gLT4gZmFsc2VcbiAgICAgIHwgXywgTGVmdCBfIC0+IGZhbHNlXG4gICAgICB8IFJpZ2h0IF9hX18wNDdfLCBSaWdodCBfYl9fMDQ4XyAtPiBfY21wX19iIF9hX18wNDdfIF9iX18wNDhfXG4gICAgICB8IFJpZ2h0IF8sIF8gLT4gZmFsc2VcbiAgICAgIHwgXywgUmlnaHQgXyAtPiBmYWxzZVxuICAgICAgfCBCb3RoIChfYV9fMDQ5XywgX2FfXzA1MV8pLCBCb3RoIChfYl9fMDUwXywgX2JfXzA1Ml8pIC0+XG4gICAgICAgIFN0ZGxpYi4oICYmICkgKF9jbXBfX2EgX2FfXzA0OV8gX2JfXzA1MF8pIChfY21wX19iIF9hX18wNTFfIF9iX18wNTJfKSlcbiAgOztcblxuICBsZXQgZXF1YWwgOlxuICAgICAgICAnYSAnYi5cbiAgICAgICAgKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYiAtPiAnYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gYm9vbFxuICAgID1cbiAgICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAzM18gYl9fMDM0XyAtPlxuICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDMzXyBiX18wMzRfXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMzNfLCBiX18wMzRfIHdpdGhcbiAgICAgIHwgTGVmdCBfYV9fMDM1XywgTGVmdCBfYl9fMDM2XyAtPiBfY21wX19hIF9hX18wMzVfIF9iX18wMzZfXG4gICAgICB8IExlZnQgXywgXyAtPiBmYWxzZVxuICAgICAgfCBfLCBMZWZ0IF8gLT4gZmFsc2VcbiAgICAgIHwgUmlnaHQgX2FfXzAzN18sIFJpZ2h0IF9iX18wMzhfIC0+IF9jbXBfX2IgX2FfXzAzN18gX2JfXzAzOF9cbiAgICAgIHwgUmlnaHQgXywgXyAtPiBmYWxzZVxuICAgICAgfCBfLCBSaWdodCBfIC0+IGZhbHNlXG4gICAgICB8IEJvdGggKF9hX18wMzlfLCBfYV9fMDQxXyksIEJvdGggKF9iX18wNDBfLCBfYl9fMDQyXykgLT5cbiAgICAgICAgU3RkbGliLiggJiYgKSAoX2NtcF9fYSBfYV9fMDM5XyBfYl9fMDQwXykgKF9jbXBfX2IgX2FfXzA0MV8gX2JfXzA0Ml8pKVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfdFxuICAgIDogdHlwZSBhIGIuXG4gICAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGEgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgICAgLT4gKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBiIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgICAgLT4gKGEsIGIpIHRcbiAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBmdW4gX2hhc2hfZm9sZF9hIF9oYXNoX2ZvbGRfYiBoc3YgYXJnIC0+XG4gICAgbWF0Y2ggYXJnIHdpdGhcbiAgICB8IExlZnQgX2EwIC0+XG4gICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwIGluXG4gICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICBfaGFzaF9mb2xkX2EgaHN2IF9hMFxuICAgIHwgUmlnaHQgX2EwIC0+XG4gICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxIGluXG4gICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICBfaGFzaF9mb2xkX2IgaHN2IF9hMFxuICAgIHwgQm90aCAoX2EwLCBfYTEpIC0+XG4gICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyIGluXG4gICAgICBsZXQgaHN2ID1cbiAgICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgICBfaGFzaF9mb2xkX2EgaHN2IF9hMFxuICAgICAgaW5cbiAgICAgIF9oYXNoX2ZvbGRfYiBoc3YgX2ExXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA6XG4gICAgICAgICdhICdiLlxuICAgICAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKVxuICAgICAgICAtPiAoU2V4cGxpYjAuU2V4cC50IC0+ICdiKVxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAgICAgLT4gKCdhLCAnYikgdFxuICAgID1cbiAgICBmdW4gKHR5cGUgYV9fMDc2XyBiX18wNzdfKVxuICAgICAgOiAgKChTZXhwbGliMC5TZXhwLnQgLT4gYV9fMDc2XykgLT4gKFNleHBsaWIwLlNleHAudCAtPiBiX18wNzdfKSAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAgIC0+IChhX18wNzZfLCBiX18wNzdfKSB0KSAtPlxuICAgIGxldCBlcnJvcl9zb3VyY2VfXzA1N18gPSBcInNlcXVlbmNlLm1sLk1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50LnRcIiBpblxuICAgIGZ1biBfb2ZfYV9fMDUzXyBfb2ZfYl9fMDU0XyAtPiBmdW5jdGlvblxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJsZWZ0XCIgfCBcIkxlZnRcIikgYXMgX3RhZ19fMDYwXykgOjogc2V4cF9hcmdzX18wNjFfKSBhc1xuICAgICAgICBfc2V4cF9fMDU5XyAtPlxuICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wNjFfIHdpdGhcbiAgICAgICAgIHwgYXJnMF9fMDYyXyA6OiBbXSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDYzXyA9IF9vZl9hX18wNTNfIGFyZzBfXzA2Ml8gaW5cbiAgICAgICAgICAgTGVmdCByZXMwX18wNjNfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgIF90YWdfXzA2MF9cbiAgICAgICAgICAgICBfc2V4cF9fMDU5XylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwicmlnaHRcIiB8IFwiUmlnaHRcIikgYXMgX3RhZ19fMDY1XykgOjogc2V4cF9hcmdzX18wNjZfKSBhc1xuICAgICAgICBfc2V4cF9fMDY0XyAtPlxuICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wNjZfIHdpdGhcbiAgICAgICAgIHwgYXJnMF9fMDY3XyA6OiBbXSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDY4XyA9IF9vZl9iX18wNTRfIGFyZzBfXzA2N18gaW5cbiAgICAgICAgICAgUmlnaHQgcmVzMF9fMDY4X1xuICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICBfdGFnX18wNjVfXG4gICAgICAgICAgICAgX3NleHBfXzA2NF8pXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImJvdGhcIiB8IFwiQm90aFwiKSBhcyBfdGFnX18wNzBfKSA6OiBzZXhwX2FyZ3NfXzA3MV8pIGFzXG4gICAgICAgIF9zZXhwX18wNjlfIC0+XG4gICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA3MV8gd2l0aFxuICAgICAgICAgfCBbIGFyZzBfXzA3Ml87IGFyZzFfXzA3M18gXSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDc0XyA9IF9vZl9hX18wNTNfIGFyZzBfXzA3Ml9cbiAgICAgICAgICAgYW5kIHJlczFfXzA3NV8gPSBfb2ZfYl9fMDU0XyBhcmcxX18wNzNfIGluXG4gICAgICAgICAgIEJvdGggKHJlczBfXzA3NF8sIHJlczFfXzA3NV8pXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgIF90YWdfXzA3MF9cbiAgICAgICAgICAgICBfc2V4cF9fMDY5XylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImxlZnRcIiB8IFwiTGVmdFwiKSBhcyBzZXhwX18wNThfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIHNleHBfXzA1OF9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInJpZ2h0XCIgfCBcIlJpZ2h0XCIpIGFzIHNleHBfXzA1OF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzA1N18gc2V4cF9fMDU4X1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiYm90aFwiIHwgXCJCb3RoXCIpIGFzIHNleHBfXzA1OF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzA1N18gc2V4cF9fMDU4X1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzA1Nl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDU3XyBzZXhwX18wNTZfXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wNTZfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDU3XyBzZXhwX18wNTZfXG4gICAgICB8IHNleHBfXzA1Nl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzA1N18gc2V4cF9fMDU2X1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICAgICAnYSAnYi5cbiAgICAgICAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdhLCAnYikgdFxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuICh0eXBlIGFfXzA4OF8gYl9fMDg5XylcbiAgICAgIDogICgoYV9fMDg4XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChiX18wODlfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+IChhX18wODhfLCBiX18wODlfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzA3OF8gX29mX2JfXzA3OV8gLT4gZnVuY3Rpb25cbiAgICB8IExlZnQgYXJnMF9fMDgwXyAtPlxuICAgICAgbGV0IHJlczBfXzA4MV8gPSBfb2ZfYV9fMDc4XyBhcmcwX18wODBfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJMZWZ0XCI7IHJlczBfXzA4MV8gXVxuICAgIHwgUmlnaHQgYXJnMF9fMDgyXyAtPlxuICAgICAgbGV0IHJlczBfXzA4M18gPSBfb2ZfYl9fMDc5XyBhcmcwX18wODJfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJSaWdodFwiOyByZXMwX18wODNfIF1cbiAgICB8IEJvdGggKGFyZzBfXzA4NF8sIGFyZzFfXzA4NV8pIC0+XG4gICAgICBsZXQgcmVzMF9fMDg2XyA9IF9vZl9hX18wNzhfIGFyZzBfXzA4NF9cbiAgICAgIGFuZCByZXMxX18wODdfID0gX29mX2JfXzA3OV8gYXJnMV9fMDg1XyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQm90aFwiOyByZXMwX18wODZfOyByZXMxX18wODdfIF1cbiAgOztcblxuICBsZXQgdF9zZXhwX2dyYW1tYXIgOlxuICAgICAgICAnYSAnYi5cbiAgICAgICAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgICAgLT4gJ2IgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciBfJ2Jfc2V4cF9ncmFtbWFyIC0+XG4gICAgeyB1bnR5cGVkID1cbiAgICAgICAgVmFyaWFudFxuICAgICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICBbIE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJMZWZ0XCJcbiAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiUmlnaHRcIlxuICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydiX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJCb3RoXCJcbiAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXydhX3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIENvbnMgKF8nYl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5sZXQgbWVyZ2Vfd2l0aF9kdXBsaWNhdGVzXG4gIChTZXF1ZW5jZSB7IHN0YXRlID0gczE7IG5leHQgPSBuZXh0MSB9KVxuICAoU2VxdWVuY2UgeyBzdGF0ZSA9IHMyOyBuZXh0ID0gbmV4dDIgfSlcbiAgfmNvbXBhcmVcbiAgPVxuICBsZXQgdW5zaGFkb3dlZF9jb21wYXJlID0gY29tcGFyZSBpblxuICBsZXQgb3BlbiBNZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudCBpblxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzMSB9LCBzMiAtPiBTa2lwIHsgc3RhdGUgPSBuZXh0MSBzMSwgczIgfVxuICAgIHwgczEsIFNraXAgeyBzdGF0ZSA9IHMyIH0gLT4gU2tpcCB7IHN0YXRlID0gczEsIG5leHQyIHMyIH1cbiAgICB8IChZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzMScgfSBhcyBzMSksIChZaWVsZCB7IHZhbHVlID0gYjsgc3RhdGUgPSBzMicgfSBhcyBzMilcbiAgICAgIC0+XG4gICAgICBsZXQgY29tcGFyaXNvbiA9IHVuc2hhZG93ZWRfY29tcGFyZSBhIGIgaW5cbiAgICAgIGlmIGNvbXBhcmlzb24gPCAwXG4gICAgICB0aGVuIFlpZWxkIHsgdmFsdWUgPSBMZWZ0IGE7IHN0YXRlID0gU2tpcCB7IHN0YXRlID0gczEnIH0sIHMyIH1cbiAgICAgIGVsc2UgaWYgY29tcGFyaXNvbiA9IDBcbiAgICAgIHRoZW5cbiAgICAgICAgWWllbGQgeyB2YWx1ZSA9IEJvdGggKGEsIGIpOyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxJyB9LCBTa2lwIHsgc3RhdGUgPSBzMicgfSB9XG4gICAgICBlbHNlIFlpZWxkIHsgdmFsdWUgPSBSaWdodCBiOyBzdGF0ZSA9IHMxLCBTa2lwIHsgc3RhdGUgPSBzMicgfSB9XG4gICAgfCBEb25lLCBEb25lIC0+IERvbmVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMxIH0sIERvbmUgLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBMZWZ0IGE7IHN0YXRlID0gU2tpcCB7IHN0YXRlID0gczEgfSwgRG9uZSB9XG4gICAgfCBEb25lLCBZaWVsZCB7IHZhbHVlID0gYjsgc3RhdGUgPSBzMiB9IC0+XG4gICAgICBZaWVsZCB7IHZhbHVlID0gUmlnaHQgYjsgc3RhdGUgPSBEb25lLCBTa2lwIHsgc3RhdGUgPSBzMiB9IH1cbiAgaW5cbiAgU2VxdWVuY2UgeyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxIH0sIFNraXAgeyBzdGF0ZSA9IHMyIH07IG5leHQgfVxuOztcblxubGV0IG1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZCBzMSBzMiB+Y29tcGFyZSA9XG4gIG1hcCAobWVyZ2Vfd2l0aF9kdXBsaWNhdGVzIHMxIHMyIH5jb21wYXJlKSB+ZjooZnVuY3Rpb25cbiAgICB8IExlZnQgeCB8IFJpZ2h0IHggfCBCb3RoICh4LCBfKSAtPiB4KVxuOztcblxubGV0IG1lcmdlX3NvcnRlZFxuICAoU2VxdWVuY2UgeyBzdGF0ZSA9IHMxOyBuZXh0ID0gbmV4dDEgfSlcbiAgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMjsgbmV4dCA9IG5leHQyIH0pXG4gIH5jb21wYXJlXG4gID1cbiAgbGV0IG5leHQgPSBmdW5jdGlvblxuICAgIHwgU2tpcCB7IHN0YXRlID0gczEgfSwgczIgLT4gU2tpcCB7IHN0YXRlID0gbmV4dDEgczEsIHMyIH1cbiAgICB8IHMxLCBTa2lwIHsgc3RhdGUgPSBzMiB9IC0+IFNraXAgeyBzdGF0ZSA9IHMxLCBuZXh0MiBzMiB9XG4gICAgfCAoWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gczEnIH0gYXMgczEpLCAoWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gczInIH0gYXMgczIpXG4gICAgICAtPlxuICAgICAgbGV0IGNvbXBhcmlzb24gPSBjb21wYXJlIGEgYiBpblxuICAgICAgaWYgY29tcGFyaXNvbiA8PSAwXG4gICAgICB0aGVuIFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxJyB9LCBzMiB9XG4gICAgICBlbHNlIFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IHMxLCBTa2lwIHsgc3RhdGUgPSBzMicgfSB9XG4gICAgfCBEb25lLCBEb25lIC0+IERvbmVcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMxIH0sIERvbmUgLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxIH0sIERvbmUgfVxuICAgIHwgRG9uZSwgWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gczIgfSAtPlxuICAgICAgWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gRG9uZSwgU2tpcCB7IHN0YXRlID0gczIgfSB9XG4gIGluXG4gIFNlcXVlbmNlIHsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMSB9LCBTa2lwIHsgc3RhdGUgPSBzMiB9OyBuZXh0IH1cbjs7XG5cbmxldCBoZCBzID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0XG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBfIH0gLT4gU29tZSBhXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT4gbG9vcCBzIG5leHRcbjs7XG5cbmxldCBoZF9leG4gcyA9XG4gIG1hdGNoIGhkIHMgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJoZF9leG5cIlxuICB8IFNvbWUgYSAtPiBhXG47O1xuXG5sZXQgdGwgcyA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgbmV4dFxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gYSB9IC0+IFNvbWUgYVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+XG4gICAgKG1hdGNoIGxvb3AgcyBuZXh0IHdpdGhcbiAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgfCBTb21lIHMgLT4gU29tZSAoU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSkpXG47O1xuXG5sZXQgdGxfZWFnZXJseV9leG4gcyA9XG4gIG1hdGNoIHRsIHMgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJTZXF1ZW5jZS50bF9leG5cIlxuICB8IFNvbWUgcyAtPiBzXG47O1xuXG5sZXQgbGlmdF9pZGVudGl0eSBuZXh0IHMgPVxuICBtYXRjaCBuZXh0IHMgd2l0aFxuICB8IERvbmUgLT4gRG9uZVxuICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBgSWRlbnRpdHkgcyB9XG4gIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IGBJZGVudGl0eSBzIH1cbjs7XG5cbmxldCBuZXh0IHMgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBTb21lIChhLCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+IGxvb3AgcyBuZXh0XG47O1xuXG5sZXQgZmlsdGVyX29wdCBzID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIHMgLT5cbiAgICAgICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gcyB9XG4gICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBOb25lOyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBzIH1cbiAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IFNvbWUgYTsgc3RhdGUgPSBzIH0gLT4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9KVxuICAgICAgfVxuOztcblxubGV0IGZpbHRlcl9tYXAgcyB+ZiA9IGZpbHRlcl9vcHQgKG1hcCBzIH5mKVxubGV0IGZpbHRlcl9tYXBpIHMgfmYgPSBmaWx0ZXJfbWFwIChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKVxuXG5sZXQgc3BsaXRfbiBzIG4gPVxuICBsZXQgcmVjIGxvb3AgcyBpIGFjY3VtIG5leHQgPVxuICAgIGlmIGkgPD0gMFxuICAgIHRoZW4gTGlzdC5yZXYgYWNjdW0sIFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH1cbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gTGlzdC5yZXYgYWNjdW0sIGVtcHR5XG4gICAgICB8IFNraXAgeyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgaSBhY2N1bSBuZXh0XG4gICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgKGkgLSAxKSAoYSA6OiBhY2N1bSkgbmV4dClcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPiBsb29wIHMgbiBbXSBuZXh0XG47O1xuXG5sZXQgY2h1bmtzX2V4biB0IG4gPVxuICBpZiBuIDw9IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcXVlbmNlLmNodW5rc19leG5cIlxuICBlbHNlXG4gICAgdW5mb2xkX3N0ZXAgfmluaXQ6dCB+ZjooZnVuIHQgLT5cbiAgICAgIG1hdGNoIHNwbGl0X24gdCBuIHdpdGhcbiAgICAgIHwgW10sIF9lbXB0eSAtPiBEb25lXG4gICAgICB8IChfIDo6IF8gYXMgeHMpLCB0IC0+IFlpZWxkIHsgdmFsdWUgPSB4czsgc3RhdGUgPSB0IH0pXG47O1xuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgaSBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBfIH0gd2hlbiBmIGkgYSAtPiBTb21lIChpLCBhKVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IChpICsgMSkgZlxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGkgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9IC0+IGxvb3Agc2VlZCBuZXh0IDAgZlxuOztcblxubGV0IGZpbmRfZXhuIHMgfmYgPVxuICBtYXRjaCBmaW5kIHMgfmYgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJTZXF1ZW5jZS5maW5kX2V4blwiXG4gIHwgU29tZSB4IC0+IHhcbjs7XG5cbmxldCBhcHBlbmQgczEgczIgPVxuICBtYXRjaCBzMSwgczIgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzMTsgbmV4dCA9IG5leHQxIH0sIFNlcXVlbmNlIHsgc3RhdGUgPSBzMjsgbmV4dCA9IG5leHQyIH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IGBGaXJzdF9saXN0IHMxXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW5jdGlvblxuICAgICAgICAgICB8IGBGaXJzdF9saXN0IHMxIC0+XG4gICAgICAgICAgICAgKG1hdGNoIG5leHQxIHMxIHdpdGhcbiAgICAgICAgICAgICAgfCBEb25lIC0+IFNraXAgeyBzdGF0ZSA9IGBTZWNvbmRfbGlzdCBzMiB9XG4gICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gczEgfSAtPiBTa2lwIHsgc3RhdGUgPSBgRmlyc3RfbGlzdCBzMSB9XG4gICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gczEgfSAtPlxuICAgICAgICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IGBGaXJzdF9saXN0IHMxIH0pXG4gICAgICAgICAgIHwgYFNlY29uZF9saXN0IHMyIC0+XG4gICAgICAgICAgICAgKG1hdGNoIG5leHQyIHMyIHdpdGhcbiAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzMiB9IC0+IFNraXAgeyBzdGF0ZSA9IGBTZWNvbmRfbGlzdCBzMiB9XG4gICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gczIgfSAtPlxuICAgICAgICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IGBTZWNvbmRfbGlzdCBzMiB9KSlcbiAgICAgIH1cbjs7XG5cbmxldCBjb25jYXRfbWFwIHMgfmYgPSBiaW5kIHMgfmZcbmxldCBjb25jYXQgcyA9IGNvbmNhdF9tYXAgcyB+ZjpGbi5pZFxubGV0IGNvbmNhdF9tYXBpIHMgfmYgPSBjb25jYXRfbWFwIChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKVxuXG5sZXQgemlwIChTZXF1ZW5jZSB7IHN0YXRlID0gczE7IG5leHQgPSBuZXh0MSB9KSAoU2VxdWVuY2UgeyBzdGF0ZSA9IHMyOyBuZXh0ID0gbmV4dDIgfSkgPVxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzMSB9LCBZaWVsZCB7IHZhbHVlID0gYjsgc3RhdGUgPSBzMiB9IC0+XG4gICAgICBZaWVsZCB7IHZhbHVlID0gYSwgYjsgc3RhdGUgPSBTa2lwIHsgc3RhdGUgPSBzMSB9LCBTa2lwIHsgc3RhdGUgPSBzMiB9IH1cbiAgICB8IERvbmUsIF8gfCBfLCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMxIH0sIHMyIC0+IFNraXAgeyBzdGF0ZSA9IG5leHQxIHMxLCBzMiB9XG4gICAgfCBzMSwgU2tpcCB7IHN0YXRlID0gczIgfSAtPiBTa2lwIHsgc3RhdGUgPSBzMSwgbmV4dDIgczIgfVxuICBpblxuICBTZXF1ZW5jZSB7IHN0YXRlID0gU2tpcCB7IHN0YXRlID0gczEgfSwgU2tpcCB7IHN0YXRlID0gczIgfTsgbmV4dCB9XG47O1xuXG5sZXQgemlwX2Z1bGxcbiAgKFNlcXVlbmNlIHsgc3RhdGUgPSBzMTsgbmV4dCA9IG5leHQxIH0pXG4gIChTZXF1ZW5jZSB7IHN0YXRlID0gczI7IG5leHQgPSBuZXh0MiB9KVxuICA9XG4gIGxldCBuZXh0ID0gZnVuY3Rpb25cbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMxIH0sIFlpZWxkIHsgdmFsdWUgPSBiOyBzdGF0ZSA9IHMyIH0gLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBgQm90aCAoYSwgYik7IHN0YXRlID0gU2tpcCB7IHN0YXRlID0gczEgfSwgU2tpcCB7IHN0YXRlID0gczIgfSB9XG4gICAgfCBEb25lLCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgeyBzdGF0ZSA9IHMxIH0sIHMyIC0+IFNraXAgeyBzdGF0ZSA9IG5leHQxIHMxLCBzMiB9XG4gICAgfCBzMSwgU2tpcCB7IHN0YXRlID0gczIgfSAtPiBTa2lwIHsgc3RhdGUgPSBzMSwgbmV4dDIgczIgfVxuICAgIHwgRG9uZSwgWWllbGQgeyB2YWx1ZSA9IGI7IHN0YXRlID0gczIgfSAtPlxuICAgICAgWWllbGQgeyB2YWx1ZSA9IGBSaWdodCBiOyBzdGF0ZSA9IERvbmUsIG5leHQyIHMyIH1cbiAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMxIH0sIERvbmUgLT5cbiAgICAgIFlpZWxkIHsgdmFsdWUgPSBgTGVmdCBhOyBzdGF0ZSA9IG5leHQxIHMxLCBEb25lIH1cbiAgaW5cbiAgU2VxdWVuY2UgeyBzdGF0ZSA9IFNraXAgeyBzdGF0ZSA9IHMxIH0sIFNraXAgeyBzdGF0ZSA9IHMyIH07IG5leHQgfVxuOztcblxubGV0IGJvdW5kZWRfbGVuZ3RoIChTZXF1ZW5jZSB7IHN0YXRlID0gc2VlZDsgbmV4dCB9KSB+YXRfbW9zdCA9XG4gIGxldCByZWMgbG9vcCBpIHNlZWQgbmV4dCA9XG4gICAgaWYgaSA+IGF0X21vc3RcbiAgICB0aGVuIGBHcmVhdGVyXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgfCBEb25lIC0+IGBJcyBpXG4gICAgICB8IFNraXAgeyBzdGF0ZSA9IHNlZWQgfSAtPiBsb29wIGkgc2VlZCBuZXh0XG4gICAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHNlZWQgfSAtPiBsb29wIChpICsgMSkgc2VlZCBuZXh0KVxuICBpblxuICBsb29wIDAgc2VlZCBuZXh0XG47O1xuXG5sZXQgbGVuZ3RoX2lzX2JvdW5kZWRfYnkgPyhtaW4gPSAtMSkgP21heCB0ID1cbiAgbGV0IGxlbmd0aF9pc19hdF9sZWFzdCAoU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSkgPVxuICAgIGxldCByZWMgbG9vcCBzIGFjYyA9XG4gICAgICBpZiBhY2MgPj0gbWluXG4gICAgICB0aGVuIHRydWVcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICB8IERvbmUgLT4gZmFsc2VcbiAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzIGFjY1xuICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSAtPiBsb29wIHMgKGFjYyArIDEpKVxuICAgIGluXG4gICAgbG9vcCBzIDBcbiAgaW5cbiAgbWF0Y2ggbWF4IHdpdGhcbiAgfCBOb25lIC0+IGxlbmd0aF9pc19hdF9sZWFzdCB0XG4gIHwgU29tZSBtYXggLT5cbiAgICAobWF0Y2ggYm91bmRlZF9sZW5ndGggdCB+YXRfbW9zdDptYXggd2l0aFxuICAgICB8IGBJcyBsZW4gd2hlbiBsZW4gPj0gbWluIC0+IHRydWVcbiAgICAgfCBfIC0+IGZhbHNlKVxuOztcblxubGV0IGl0ZXJpIHMgfmYgPSBpdGVyIChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKSBbQG5vbnRhaWxdXG5cbmxldCBmb2xkaSBzIH5pbml0IH5mID1cbiAgZm9sZCB+aW5pdCAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIGFjYyAoaSwgcykgLT4gZiBpIGFjYyBzKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcmVkdWNlIHMgfmYgPVxuICBtYXRjaCBuZXh0IHMgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgKGEsIHMpIC0+IFNvbWUgKGZvbGQgcyB+aW5pdDphIH5mKVxuOztcblxubGV0IHJlZHVjZV9leG4gcyB+ZiA9XG4gIG1hdGNoIHJlZHVjZSBzIH5mIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2VxdWVuY2UucmVkdWNlX2V4blwiXG4gIHwgU29tZSByZXMgLT4gcmVzXG47O1xuXG5sZXQgZ3JvdXAgKFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0pIH5icmVhayA9XG4gIHVuZm9sZF9zdGVwXG4gICAgfmluaXQ6KFNvbWUgKFtdLCBzKSlcbiAgICB+ZjooZnVuY3Rpb25cbiAgICAgIHwgTm9uZSAtPiBEb25lXG4gICAgICB8IFNvbWUgKGFjYywgcykgLT5cbiAgICAgICAgKG1hdGNoIGFjYywgbmV4dCBzIHdpdGhcbiAgICAgICAgIHwgXywgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IFNvbWUgKGFjYywgcykgfVxuICAgICAgICAgfCBbXSwgRG9uZSAtPiBEb25lXG4gICAgICAgICB8IGFjYywgRG9uZSAtPiBZaWVsZCB7IHZhbHVlID0gTGlzdC5yZXYgYWNjOyBzdGF0ZSA9IE5vbmUgfVxuICAgICAgICAgfCBbXSwgWWllbGQgeyB2YWx1ZSA9IGN1cjsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gU29tZSAoWyBjdXIgXSwgcykgfVxuICAgICAgICAgfCAocHJldiA6OiBfIGFzIGFjYyksIFlpZWxkIHsgdmFsdWUgPSBjdXI7IHN0YXRlID0gcyB9IC0+XG4gICAgICAgICAgIGlmIGJyZWFrIHByZXYgY3VyXG4gICAgICAgICAgIHRoZW4gWWllbGQgeyB2YWx1ZSA9IExpc3QucmV2IGFjYzsgc3RhdGUgPSBTb21lIChbIGN1ciBdLCBzKSB9XG4gICAgICAgICAgIGVsc2UgU2tpcCB7IHN0YXRlID0gU29tZSAoY3VyIDo6IGFjYywgcykgfSkpXG47O1xuXG5sZXQgZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUgKFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0pIH5lcXVhbCA9XG4gIGxldCByZWMgbG9vcCBsYXN0X2VsdCBzID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBsYXN0X2VsdCBzXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgIChtYXRjaCBsYXN0X2VsdCB3aXRoXG4gICAgICAgfCBTb21lIGIgd2hlbiBlcXVhbCBhIGIgLT4gU29tZSAoYiwgYSlcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gbG9vcCAoU29tZSBhKSBzKVxuICBpblxuICBsb29wIE5vbmUgcyBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcmVtb3ZlX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZXMgcyB+ZXF1YWwgPVxuICB1bmZvbGRfd2l0aCBzIH5pbml0Ok5vbmUgfmY6KGZ1biBwcmV2IGEgLT5cbiAgICBtYXRjaCBwcmV2IHdpdGhcbiAgICB8IFNvbWUgYiB3aGVuIGVxdWFsIGEgYiAtPiBTa2lwIHsgc3RhdGUgPSBTb21lIGEgfVxuICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBTb21lIGEgfSlcbjs7XG5cbmxldCBjb3VudCBzIH5mID0gZm9sZCBzIH5pbml0OjAgfmY6KGZ1biBhY2MgZWx0IC0+IGFjYyArIEJvb2wudG9faW50IChmIGVsdCkpIFtAbm9udGFpbF1cblxubGV0IGNvdW50aSB0IH5mID1cbiAgZm9sZGkgdCB+aW5pdDowIH5mOihmdW4gaSBhY2MgZWx0IC0+IGFjYyArIEJvb2wudG9faW50IChmIGkgZWx0KSkgW0Bub250YWlsXVxuOztcblxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5cbmxldCBpbml0IG4gfmYgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDowIH5mOihmdW4gaSAtPlxuICAgIGlmIGkgPj0gbiB0aGVuIERvbmUgZWxzZSBZaWVsZCB7IHZhbHVlID0gZiBpOyBzdGF0ZSA9IGkgKyAxIH0pXG47O1xuXG5sZXQgc3ViIHMgfnBvcyB+bGVuID1cbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAwIHRoZW4gZmFpbHdpdGggXCJTZXF1ZW5jZS5zdWJcIjtcbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gMCwgc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIChpLCBzKSAtPlxuICAgICAgICAgICAgaWYgaSAtIHBvcyA+PSBsZW5cbiAgICAgICAgICAgIHRoZW4gRG9uZVxuICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IGksIHMgfVxuICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSB3aGVuIGkgPj0gcG9zIC0+XG4gICAgICAgICAgICAgICAgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gaSArIDEsIHMgfVxuICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBfOyBzdGF0ZSA9IHMgfSAtPiBTa2lwIHsgc3RhdGUgPSBpICsgMSwgcyB9KSlcbiAgICAgIH1cbjs7XG5cbmxldCB0YWtlIHMgbGVuID1cbiAgaWYgbGVuIDwgMCB0aGVuIGZhaWx3aXRoIFwiU2VxdWVuY2UudGFrZVwiO1xuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSAwLCBzXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW4gKGksIHMpIC0+XG4gICAgICAgICAgICBpZiBpID49IGxlblxuICAgICAgICAgICAgdGhlbiBEb25lXG4gICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gaSwgcyB9XG4gICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IGkgKyAxLCBzIH0pKVxuICAgICAgfVxuOztcblxubGV0IGRyb3AgcyBsZW4gPVxuICBpZiBsZW4gPCAwIHRoZW4gZmFpbHdpdGggXCJTZXF1ZW5jZS5kcm9wXCI7XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0gLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgeyBzdGF0ZSA9IDAsIHNcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1biAoaSwgcykgLT5cbiAgICAgICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gaSwgcyB9XG4gICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSB3aGVuIGkgPj0gbGVuIC0+XG4gICAgICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IGkgKyAxLCBzIH1cbiAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IGkgKyAxLCBzIH0pXG4gICAgICB9XG47O1xuXG5sZXQgdGFrZV93aGlsZSBzIH5mID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gc1xuICAgICAgOyBuZXh0ID1cbiAgICAgICAgICAoZnVuIHMgLT5cbiAgICAgICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gcyB9XG4gICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSB3aGVuIGYgYSAtPiBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH1cbiAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IF87IHN0YXRlID0gXyB9IC0+IERvbmUpXG4gICAgICB9XG47O1xuXG5sZXQgZHJvcF93aGlsZSBzIH5mID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gYERyb3BwaW5nIHNcbiAgICAgIDsgbmV4dCA9XG4gICAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgIHwgYERyb3BwaW5nIHMgLT5cbiAgICAgICAgICAgICAobWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gYERyb3BwaW5nIHMgfVxuICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSB3aGVuIGYgYSAtPiBTa2lwIHsgc3RhdGUgPSBgRHJvcHBpbmcgcyB9XG4gICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IGBJZGVudGl0eSBzIH0pXG4gICAgICAgICAgIHwgYElkZW50aXR5IHMgLT4gbGlmdF9pZGVudGl0eSBuZXh0IHMpXG4gICAgICB9XG47O1xuXG5sZXQgc2hpZnRfcmlnaHQgcyB4ID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHNlZWQ7IG5leHQgfSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICB7IHN0YXRlID0gYENvbnNpbmcgKHNlZWQsIHgpXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW5jdGlvblxuICAgICAgICAgICB8IGBDb25zaW5nIChzZWVkLCB4KSAtPiBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBgSWRlbnRpdHkgc2VlZCB9XG4gICAgICAgICAgIHwgYElkZW50aXR5IHMgLT4gbGlmdF9pZGVudGl0eSBuZXh0IHMpXG4gICAgICB9XG47O1xuXG5sZXQgc2hpZnRfcmlnaHRfd2l0aF9saXN0IHMgbCA9IGFwcGVuZCAob2ZfbGlzdCBsKSBzXG5sZXQgc2hpZnRfbGVmdCA9IGRyb3BcblxubW9kdWxlIEluZml4ID0gc3RydWN0XG4gIGxldCAoIEAgKSA9IGFwcGVuZFxuZW5kXG5cbmxldCBpbnRlcnNwZXJzZSBzIH5zZXAgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+XG4gICAgU2VxdWVuY2VcbiAgICAgIHsgc3RhdGUgPSBgSW5pdCBzXG4gICAgICA7IG5leHQgPVxuICAgICAgICAgIChmdW5jdGlvblxuICAgICAgICAgICB8IGBJbml0IHMgLT5cbiAgICAgICAgICAgICAobWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gU2tpcCB7IHN0YXRlID0gYEluaXQgcyB9XG4gICAgICAgICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gcyB9IC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IGBSdW5uaW5nIHMgfSlcbiAgICAgICAgICAgfCBgUnVubmluZyBzIC0+XG4gICAgICAgICAgICAgKG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IFNraXAgeyBzdGF0ZSA9IGBSdW5uaW5nIHMgfVxuICAgICAgICAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IHMgfSAtPlxuICAgICAgICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSBzZXA7IHN0YXRlID0gYFB1dHRpbmcgKGEsIHMpIH0pXG4gICAgICAgICAgIHwgYFB1dHRpbmcgKGEsIHMpIC0+IFlpZWxkIHsgdmFsdWUgPSBhOyBzdGF0ZSA9IGBSdW5uaW5nIHMgfSlcbiAgICAgIH1cbjs7XG5cbmxldCByZXBlYXQgeCA9IHVuZm9sZF9zdGVwIH5pbml0OnggfmY6KGZ1biB4IC0+IFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IHggfSlcblxubGV0IGN5Y2xlX2xpc3RfZXhuIHhzID1cbiAgaWYgTGlzdC5pc19lbXB0eSB4cyB0aGVuIGludmFsaWRfYXJnIFwiU2VxdWVuY2UuY3ljbGVfbGlzdF9leG5cIjtcbiAgbGV0IHMgPSBvZl9saXN0IHhzIGluXG4gIGNvbmNhdF9tYXAgfmY6KGZ1biAoKSAtPiBzKSAocmVwZWF0ICgpKVxuOztcblxubGV0IGNhcnRlc2lhbl9wcm9kdWN0IHNhIHNiID0gY29uY2F0X21hcCBzYSB+ZjooZnVuIGEgLT4gemlwIChyZXBlYXQgYSkgc2IpXG5sZXQgc2luZ2xldG9uIHggPSByZXR1cm4geFxuXG5sZXQgZGVsYXllZF9mb2xkIHMgfmluaXQgfmYgfmZpbmlzaCA9XG4gIEV4cGVydC5kZWxheWVkX2ZvbGRfc3RlcCBzIH5pbml0IH5maW5pc2ggfmY6KGZ1biBhY2Mgb3B0aW9uIH5rIC0+XG4gICAgbWF0Y2ggb3B0aW9uIHdpdGhcbiAgICB8IE5vbmUgLT4gayBhY2NcbiAgICB8IFNvbWUgYSAtPiBmIGFjYyBhIH5rKVxuOztcblxubGV0IGZvbGRfbSB+YmluZCB+cmV0dXJuIHQgfmluaXQgfmYgPVxuICBFeHBlcnQuZGVsYXllZF9mb2xkX3N0ZXBcbiAgICB0XG4gICAgfmluaXRcbiAgICB+ZjooZnVuIGFjYyBvcHRpb24gfmsgLT5cbiAgICAgIG1hdGNoIG9wdGlvbiB3aXRoXG4gICAgICB8IE5vbmUgLT4gYmluZCAocmV0dXJuIGFjYykgfmY6a1xuICAgICAgfCBTb21lIGEgLT4gYmluZCAoZiBhY2MgYSkgfmY6aylcbiAgICB+ZmluaXNoOnJldHVyblxuOztcblxubGV0IGl0ZXJfbSB+YmluZCB+cmV0dXJuIHQgfmYgPVxuICBFeHBlcnQuZGVsYXllZF9mb2xkX3N0ZXBcbiAgICB0XG4gICAgfmluaXQ6KClcbiAgICB+ZjooZnVuICgpIG9wdGlvbiB+ayAtPlxuICAgICAgbWF0Y2ggb3B0aW9uIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBiaW5kIChyZXR1cm4gKCkpIH5mOmtcbiAgICAgIHwgU29tZSBhIC0+IGJpbmQgKGYgYSkgfmY6aylcbiAgICB+ZmluaXNoOnJldHVyblxuOztcblxubGV0IGZvbGRfdW50aWwgcyB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGFjYyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmluaXNoIGFjY1xuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGYgYWNjXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgIChtYXRjaCAoZiBhY2MgYSA6ICgnYSwgJ2IpIENvbnRpbnVlX29yX3N0b3AudCkgd2l0aFxuICAgICAgIHwgU3RvcCB4IC0+IHhcbiAgICAgICB8IENvbnRpbnVlIGFjYyAtPiBsb29wIHMgbmV4dCBmIGFjYylcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPiBsb29wIHMgbmV4dCBmIGluaXQgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRfcmVzdWx0IHMgfmluaXQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgYWNjID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBSZXN1bHQucmV0dXJuIGFjY1xuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgcyBuZXh0IGYgYWNjXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT5cbiAgICAgIChtYXRjaCAoZiBhY2MgYSA6IChfLCBfKSBSZXN1bHQudCkgd2l0aFxuICAgICAgIHwgRXJyb3IgXyBhcyBlIC0+IGVcbiAgICAgICB8IE9rIGFjYyAtPiBsb29wIHMgbmV4dCBmIGFjYylcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgfSAtPiBsb29wIHMgbmV4dCBmIGluaXRcbjs7XG5cbmxldCBmb3JjZV9lYWdlcmx5IHQgPSBvZl9saXN0ICh0b19saXN0IHQpXG5cbmxldCBtZW1vaXplICh0eXBlIGEpIChTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KSA9XG4gIGxldCBtb2R1bGUgTSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFQgb2YgKGEsIHQpIFN0ZXAudCBMYXp5LnRcbiAgZW5kXG4gIGluXG4gIGxldCByZWMgbWVtb2l6ZSBzID0gTS5UIChsYXp5IChmaW5kX3N0ZXAgcykpXG4gIGFuZCBmaW5kX3N0ZXAgcyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGZpbmRfc3RlcCBzXG4gICAgfCBZaWVsZCB7IHZhbHVlID0gYTsgc3RhdGUgPSBzIH0gLT4gWWllbGQgeyB2YWx1ZSA9IGE7IHN0YXRlID0gbWVtb2l6ZSBzIH1cbiAgaW5cbiAgU2VxdWVuY2UgeyBzdGF0ZSA9IG1lbW9pemUgczsgbmV4dCA9IChmdW4gKE0uVCBsKSAtPiBMYXp5LmZvcmNlIGwpIH1cbjs7XG5cbmxldCBkcm9wX2VhZ2VybHkgcyBsZW4gPVxuICBsZXQgcmVjIGxvb3AgaSB+bGVuIHMgbmV4dCA9XG4gICAgaWYgaSA+PSBsZW5cbiAgICB0aGVuIFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH1cbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gZW1wdHlcbiAgICAgIHwgU2tpcCB7IHN0YXRlID0gcyB9IC0+IGxvb3AgaSB+bGVuIHMgbmV4dFxuICAgICAgfCBZaWVsZCB7IHZhbHVlID0gXzsgc3RhdGUgPSBzIH0gLT4gbG9vcCAoaSArIDEpIH5sZW4gcyBuZXh0KVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9IC0+IGxvb3AgMCB+bGVuIHMgbmV4dFxuOztcblxubGV0IGRyb3Bfd2hpbGVfb3B0aW9uIChTZXF1ZW5jZSB7IHN0YXRlID0gczsgbmV4dCB9KSB+ZiA9XG4gIGxldCByZWMgbG9vcCBzID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT4gbG9vcCBzXG4gICAgfCBZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSBzIH0gLT5cbiAgICAgIGlmIGYgeCB0aGVuIGxvb3AgcyBlbHNlIFNvbWUgKHgsIFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0IH0pXG4gIGluXG4gIGxvb3AgcyBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcmVjIHNraXBfbG9vcCBzIG5leHQgPVxuICBtYXRjaCBuZXh0IHMgd2l0aFxuICB8IFNraXAgeyBzdGF0ZSB9IC0+IHNraXBfbG9vcCBzdGF0ZSBuZXh0XG4gIHwgKERvbmUgfCBZaWVsZCBfKSBhcyBuZXh0IC0+IG5leHRcbjs7XG5cbmxldCBjb21wYXJlIGNvbXBhcmVfYSAoU2VxdWVuY2UgbCkgKFNlcXVlbmNlIHIpID1cbiAgbGV0IHJlYyBsb29wIGNvbXBhcmVfYSBzX2wgbmV4dF9sIHNfciBuZXh0X3IgPVxuICAgIG1hdGNoIHNraXBfbG9vcCBzX2wgbmV4dF9sLCBza2lwX2xvb3Agc19yIG5leHRfciB3aXRoXG4gICAgfCBEb25lLCBEb25lIC0+IDBcbiAgICB8IERvbmUsIFlpZWxkIF8gLT4gLTFcbiAgICB8IFlpZWxkIF8sIERvbmUgLT4gMVxuICAgIHwgWWllbGQgbCwgWWllbGQgciAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2EgbC52YWx1ZSByLnZhbHVlIGluXG4gICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2UgbG9vcCBjb21wYXJlX2EgbC5zdGF0ZSBuZXh0X2wgci5zdGF0ZSBuZXh0X3JcbiAgICB8IFNraXAgXywgXyB8IF8sIFNraXAgXyAtPiBmYWlsd2l0aCBcIkJ1ZzogVGhpcyBicmFuY2ggc2hvdWxkIGJlIHVucmVhY2hhYmxlXCJcbiAgaW5cbiAgbG9vcCBjb21wYXJlX2EgbC5zdGF0ZSBsLm5leHQgci5zdGF0ZSByLm5leHRcbjs7XG5cbmxldCBjb21wYXJlX19sb2NhbCBjb21wYXJlX2FfX2xvY2FsIHQxIHQyID1cbiAgY29tcGFyZSAoZnVuIHggeSAtPiBjb21wYXJlX2FfX2xvY2FsIHggeSkgKGdsb2JhbGl6ZSAoKSB0MSkgKGdsb2JhbGl6ZSAoKSB0Milcbjs7XG5cbmxldCBlcXVhbCBlcXVhbF9hIHQxIHQyID1cbiAgZm9yX2FsbCAoemlwX2Z1bGwgdDEgdDIpIH5mOihmdW5jdGlvblxuICAgIHwgYEJvdGggKGExLCBhMikgLT4gZXF1YWxfYSBhMSBhMlxuICAgIHwgYExlZnQgXyB8IGBSaWdodCBfIC0+IGZhbHNlKVxuOztcblxubGV0IGVxdWFsX19sb2NhbCBlcXVhbF9hX19sb2NhbCB0MSB0MiA9XG4gIGVxdWFsIChmdW4geCB5IC0+IGVxdWFsX2FfX2xvY2FsIHggeSkgKGdsb2JhbGl6ZSAoKSB0MSkgKGdsb2JhbGl6ZSAoKSB0Milcbjs7XG5cbmxldCByb3VuZF9yb2JpbiBsaXN0ID1cbiAgbGV0IG5leHQgKHRvZG9fc3RhY2ssIGRvbmVfc3RhY2spID1cbiAgICBtYXRjaCB0b2RvX3N0YWNrIHdpdGhcbiAgICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0ID0gZiB9IDo6IHRvZG9fc3RhY2sgLT5cbiAgICAgIChtYXRjaCBmIHMgd2l0aFxuICAgICAgIHwgWWllbGQgeyB2YWx1ZSA9IHg7IHN0YXRlID0gcyB9IC0+XG4gICAgICAgICBZaWVsZFxuICAgICAgICAgICB7IHZhbHVlID0geFxuICAgICAgICAgICA7IHN0YXRlID0gdG9kb19zdGFjaywgU2VxdWVuY2UgeyBzdGF0ZSA9IHM7IG5leHQgPSBmIH0gOjogZG9uZV9zdGFja1xuICAgICAgICAgICB9XG4gICAgICAgfCBTa2lwIHsgc3RhdGUgPSBzIH0gLT5cbiAgICAgICAgIFNraXAgeyBzdGF0ZSA9IFNlcXVlbmNlIHsgc3RhdGUgPSBzOyBuZXh0ID0gZiB9IDo6IHRvZG9fc3RhY2ssIGRvbmVfc3RhY2sgfVxuICAgICAgIHwgRG9uZSAtPiBTa2lwIHsgc3RhdGUgPSB0b2RvX3N0YWNrLCBkb25lX3N0YWNrIH0pXG4gICAgfCBbXSAtPlxuICAgICAgaWYgTGlzdC5pc19lbXB0eSBkb25lX3N0YWNrIHRoZW4gRG9uZSBlbHNlIFNraXAgeyBzdGF0ZSA9IExpc3QucmV2IGRvbmVfc3RhY2ssIFtdIH1cbiAgaW5cbiAgbGV0IHN0YXRlID0gbGlzdCwgW10gaW5cbiAgU2VxdWVuY2UgeyBzdGF0ZTsgbmV4dCB9XG47O1xuXG5sZXQgaW50ZXJsZWF2ZSAoU2VxdWVuY2UgeyBzdGF0ZSA9IHMxOyBuZXh0ID0gZjEgfSkgPVxuICBsZXQgbmV4dCAodG9kb19zdGFjaywgZG9uZV9zdGFjaywgczEpID1cbiAgICBtYXRjaCB0b2RvX3N0YWNrIHdpdGhcbiAgICB8IFNlcXVlbmNlIHsgc3RhdGUgPSBzMjsgbmV4dCA9IGYyIH0gOjogdG9kb19zdGFjayAtPlxuICAgICAgKG1hdGNoIGYyIHMyIHdpdGhcbiAgICAgICB8IFlpZWxkIHsgdmFsdWUgPSB4OyBzdGF0ZSA9IHMyIH0gLT5cbiAgICAgICAgIFlpZWxkXG4gICAgICAgICAgIHsgdmFsdWUgPSB4XG4gICAgICAgICAgIDsgc3RhdGUgPSB0b2RvX3N0YWNrLCBTZXF1ZW5jZSB7IHN0YXRlID0gczI7IG5leHQgPSBmMiB9IDo6IGRvbmVfc3RhY2ssIHMxXG4gICAgICAgICAgIH1cbiAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMyIH0gLT5cbiAgICAgICAgIFNraXAgeyBzdGF0ZSA9IHRvZG9fc3RhY2ssIFNlcXVlbmNlIHsgc3RhdGUgPSBzMjsgbmV4dCA9IGYyIH0gOjogZG9uZV9zdGFjaywgczEgfVxuICAgICAgIHwgRG9uZSAtPiBTa2lwIHsgc3RhdGUgPSB0b2RvX3N0YWNrLCBkb25lX3N0YWNrLCBzMSB9KVxuICAgIHwgW10gLT5cbiAgICAgIChtYXRjaCBmMSBzMSwgZG9uZV9zdGFjayB3aXRoXG4gICAgICAgfCBZaWVsZCB7IHZhbHVlID0gdDsgc3RhdGUgPSBzMSB9LCBfIC0+XG4gICAgICAgICBTa2lwIHsgc3RhdGUgPSBMaXN0LnJldiAodCA6OiBkb25lX3N0YWNrKSwgW10sIHMxIH1cbiAgICAgICB8IFNraXAgeyBzdGF0ZSA9IHMxIH0sIF8gLT4gU2tpcCB7IHN0YXRlID0gTGlzdC5yZXYgZG9uZV9zdGFjaywgW10sIHMxIH1cbiAgICAgICB8IERvbmUsIF8gOjogXyAtPiBTa2lwIHsgc3RhdGUgPSBMaXN0LnJldiBkb25lX3N0YWNrLCBbXSwgczEgfVxuICAgICAgIHwgRG9uZSwgW10gLT4gRG9uZSlcbiAgaW5cbiAgbGV0IHN0YXRlID0gW10sIFtdLCBzMSBpblxuICBTZXF1ZW5jZSB7IHN0YXRlOyBuZXh0IH1cbjs7XG5cbmxldCBpbnRlcmxlYXZlZF9jYXJ0ZXNpYW5fcHJvZHVjdCBzMSBzMiA9XG4gIG1hcCBzMSB+ZjooZnVuIHgxIC0+IG1hcCBzMiB+ZjooZnVuIHgyIC0+IHgxLCB4MikpIHw+IGludGVybGVhdmVcbjs7XG5cbmxldCBvZl9zZXEgKHNlcSA6IF8gU3RkbGliLlNlcS50KSA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OnNlcSB+ZjooZnVuIHNlcSAtPlxuICAgIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gRG9uZVxuICAgIHwgQ29ucyAoaGQsIHRsKSAtPiBZaWVsZCB7IHZhbHVlID0gaGQ7IHN0YXRlID0gdGwgfSlcbjs7XG5cbmxldCB0b19zZXEgKFNlcXVlbmNlIHsgc3RhdGU7IG5leHQgfSkgPVxuICBsZXQgcmVjIGxvb3Agc3RhdGUgPVxuICAgIG1hdGNoIG5leHQgc3RhdGUgd2l0aFxuICAgIHwgRG9uZSAtPiBTdGRsaWIuU2VxLk5pbFxuICAgIHwgU2tpcCB7IHN0YXRlIH0gLT4gbG9vcCBzdGF0ZVxuICAgIHwgWWllbGQgeyB2YWx1ZSA9IGhkOyBzdGF0ZSB9IC0+IFN0ZGxpYi5TZXEuQ29ucyAoaGQsIGZ1biAoKSAtPiBsb29wIHN0YXRlKVxuICBpblxuICBmdW4gKCkgLT4gbG9vcCBzdGF0ZVxuOztcblxubW9kdWxlIEdlbmVyYXRvciA9IHN0cnVjdFxuICB0eXBlICdlbHQgc3RlcHMgPSBXcmFwIG9mICgnZWx0LCB1bml0IC0+ICdlbHQgc3RlcHMpIFN0ZXAudFxuXG4gIGxldCB1bndyYXAgKFdyYXAgc3RlcCkgPSBzdGVwXG5cbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2VsdCkgdCA9ICgnYSAtPiAnZWx0IHN0ZXBzKSAtPiAnZWx0IHN0ZXBzXG5cbiAgICBsZXQgcmV0dXJuIHggayA9IGsgeFxuXG4gICAgbGV0IGJpbmQgbSB+ZiBrID1cbiAgICAgIG0gKGZ1biBhIC0+XG4gICAgICAgIGxldCBtJyA9IGYgYSBpblxuICAgICAgICBtJyBrKVxuICAgIDs7XG5cbiAgICBsZXQgbWFwIG0gfmYgayA9IG0gKGZ1biBhIC0+IGsgKGYgYSkpXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIE1vbmFkLk1ha2UyIChUKVxuXG4gIGxldCB5aWVsZCBlIGsgPSBXcmFwIChZaWVsZCB7IHZhbHVlID0gZTsgc3RhdGUgPSBrIH0pXG4gIGxldCB0b19zdGVwcyB0ID0gdCAoZnVuICgpIC0+IFdyYXAgRG9uZSlcblxuICBsZXQgb2Zfc2VxdWVuY2Ugc2VxdWVuY2UgPVxuICAgIGRlbGF5ZWRfZm9sZFxuICAgICAgc2VxdWVuY2VcbiAgICAgIH5pbml0OigpXG4gICAgICB+ZjooZnVuICgpIHggfmsgZiAtPiBXcmFwIChZaWVsZCB7IHZhbHVlID0geDsgc3RhdGUgPSAoZnVuICgpIC0+IGsgKCkgZikgfSkpXG4gICAgICB+ZmluaXNoOnJldHVyblxuICA7O1xuXG4gIGxldCBydW4gdCA9XG4gICAgbGV0IGluaXQgKCkgPSB0b19zdGVwcyB0IGluXG4gICAgbGV0IGYgdGh1bmsgPSB1bndyYXAgKHRodW5rICgpKSBpblxuICAgIHVuZm9sZF9zdGVwIH5pbml0IH5mXG4gIDs7XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZVxuXG5tb2R1bGUgT2Zfc2V4cGFibGVcbiAgKFNleHBhYmxlIDogUykgKE0gOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCB0b19zZXhwYWJsZSA6IHQgLT4gU2V4cGFibGUudFxuICAgIHZhbCBvZl9zZXhwYWJsZSA6IFNleHBhYmxlLnQgLT4gdFxuICBlbmQpIDogUyB3aXRoIHR5cGUgdCA6PSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgcyA9IFNleHBhYmxlLnRfb2Zfc2V4cCBzZXhwIGluXG4gICAgdHJ5IE0ub2Zfc2V4cGFibGUgcyB3aXRoXG4gICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwYWJsZS5zZXhwX29mX3QgKE0udG9fc2V4cGFibGUgdClcbmVuZFxuXG5tb2R1bGUgT2Zfc2V4cGFibGUxXG4gIChTZXhwYWJsZSA6IFMxKSAoTSA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIHRvX3NleHBhYmxlIDogJ2EgdCAtPiAnYSBTZXhwYWJsZS50XG4gICAgdmFsIG9mX3NleHBhYmxlIDogJ2EgU2V4cGFibGUudCAtPiAnYSB0XG4gIGVuZCkgOiBTMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHMgPSBTZXhwYWJsZS50X29mX3NleHAgYV9vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBTZXhwYWJsZS5zZXhwX29mX3Qgc2V4cF9vZl9hIChNLnRvX3NleHBhYmxlIHQpXG5lbmRcblxubW9kdWxlIE9mX3NleHBhYmxlMlxuICAoU2V4cGFibGUgOiBTMikgKE0gOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCB0b19zZXhwYWJsZSA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgU2V4cGFibGUudFxuICAgIHZhbCBvZl9zZXhwYWJsZSA6ICgnYSwgJ2IpIFNleHBhYmxlLnQgLT4gKCdhLCAnYikgdFxuICBlbmQpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgYV9vZl9zZXhwIGJfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgcyA9IFNleHBhYmxlLnRfb2Zfc2V4cCBhX29mX3NleHAgYl9vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHNleHBfb2ZfYiB0ID1cbiAgICBTZXhwYWJsZS5zZXhwX29mX3Qgc2V4cF9vZl9hIHNleHBfb2ZfYiAoTS50b19zZXhwYWJsZSB0KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBPZl9zZXhwYWJsZTNcbiAgKFNleHBhYmxlIDogUzMpIChNIDogc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIHRvX3NleHBhYmxlIDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIFNleHBhYmxlLnRcbiAgICB2YWwgb2Zfc2V4cGFibGUgOiAoJ2EsICdiLCAnYykgU2V4cGFibGUudCAtPiAoJ2EsICdiLCAnYykgdFxuICBlbmQpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgYl9vZl9zZXhwIGNfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgcyA9IFNleHBhYmxlLnRfb2Zfc2V4cCBhX29mX3NleHAgYl9vZl9zZXhwIGNfb2Zfc2V4cCBzZXhwIGluXG4gICAgdHJ5IE0ub2Zfc2V4cGFibGUgcyB3aXRoXG4gICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBzZXhwX29mX2Igc2V4cF9vZl9jIHQgPVxuICAgIFNleHBhYmxlLnNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIHNleHBfb2ZfYyAoTS50b19zZXhwYWJsZSB0KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBPZl9zdHJpbmdhYmxlIChNIDogU3RyaW5nYWJsZS5TKSA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIFMgd2l0aCB0eXBlIHQgOj0gdFxuZW5kXG53aXRoIHR5cGUgdCA6PSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IFNleHAuQXRvbSBzIC0+XG4gICAgICAodHJ5IE0ub2Zfc3RyaW5nIHMgd2l0aFxuICAgICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwKVxuICAgIHwgU2V4cC5MaXN0IF8gLT5cbiAgICAgIG9mX3NleHBfZXJyb3JcbiAgICAgICAgXCJTZXhwYWJsZS5PZl9zdHJpbmdhYmxlLnRfb2Zfc2V4cCBleHBlY3RlZCBhbiBhdG9tLCBidXQgZ290IGEgbGlzdFwiXG4gICAgICAgIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKE0udG9fc3RyaW5nIHQpXG5cbiAgbGV0IHRfc2V4cF9ncmFtbWFyIDogTS50IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIHN0cmluZ19zZXhwX2dyYW1tYXJcbiAgOztcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEFycmF5MFxuXG50eXBlICdhIHQgPSAnYSBhcnJheSBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZV9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9IGNvbXBhcmVfYXJyYXlfX2xvY2FsXG5sZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9hcnJheVxuXG5sZXQgZ2xvYmFsaXplIDogJ2EuICgnYSAtPiAnYSkgLT4gJ2EgdCAtPiAnYSB0ID1cbiAgZnVuICh0eXBlIGFfXzAwOV8pIDogKChhX18wMDlfIC0+IGFfXzAwOV8pIC0+IGFfXzAwOV8gdCAtPiBhX18wMDlfIHQpIC0+IGdsb2JhbGl6ZV9hcnJheVxuOztcblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IGFycmF5X29mX3NleHBcbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPSBzZXhwX29mX2FycmF5XG5cbmxldCB0X3NleHBfZ3JhbW1hciA6ICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gYXJyYXlfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbjs7XG5cbltAQEBlbmRdXG5cbigqIFRoaXMgbW9kdWxlIGltcGxlbWVudHMgYSBuZXcgaW4tcGxhY2UsIGNvbnN0YW50IGhlYXAgc29ydGluZyBhbGdvcml0aG0gdG8gcmVwbGFjZSB0aGVcbiAgIG9uZSB1c2VkIGJ5IHRoZSBzdGFuZGFyZCBsaWJyYXJpZXMuICBJdHMgb25seSBwdXJwb3NlIGlzIHRvIGJlIGZhc3RlciAoaG9wZWZ1bGx5XG4gICBzdHJpY3RseSBmYXN0ZXIpIHRoYW4gdGhlIGJhc2Ugc29ydCBhbmQgc3RhYmxlX3NvcnQuXG5cbiAgIEF0IGEgaGlnaCBsZXZlbCB0aGUgYWxnb3JpdGhtIGlzOlxuICAgLSBwaWNrIHR3byBwaXZvdCBwb2ludHMgYnk6XG4gICAtIHBpY2sgNSBhcmJpdHJhcnkgZWxlbWVudHMgZnJvbSB0aGUgYXJyYXlcbiAgIC0gc29ydCB0aGVtIHdpdGhpbiB0aGUgYXJyYXlcbiAgIC0gdGFrZSB0aGUgZWxlbWVudHMgb24gZWl0aGVyIHNpZGUgb2YgdGhlIG1pZGRsZSBlbGVtZW50IG9mIHRoZSBzb3J0IGFzIHRoZSBwaXZvdHNcbiAgIC0gc29ydCB0aGUgYXJyYXkgd2l0aDpcbiAgIC0gYWxsIGVsZW1lbnRzIGxlc3MgdGhhbiBwaXZvdDEgdG8gdGhlIGxlZnQgKHJhbmdlIDEpXG4gICAtIGFsbCBlbGVtZW50cyA+PSBwaXZvdDEgYW5kIDw9IHBpdm90MiBpbiB0aGUgbWlkZGxlIChyYW5nZSAyKVxuICAgLSBhbGwgZWxlbWVudHMgPiBwaXZvdDIgdG8gdGhlIHJpZ2h0IChyYW5nZSAzKVxuICAgLSBpZiBwaXZvdDEgYW5kIHBpdm90MiBhcmUgZXF1YWwsIHRoZW4gdGhlIG1pZGRsZSByYW5nZSBpcyBzb3J0ZWQsIHNvIGlnbm9yZSBpdFxuICAgLSByZWN1cnNlIGludG8gcmFuZ2UgMSwgMiAoaWYgcGl2b3QxIGFuZCBwaXZvdDIgYXJlIHVuZXF1YWwpLCBhbmQgM1xuICAgLSBkdXJpbmcgcmVjdXJzaW9uIHRoZXJlIGFyZSB0d28gaW5mbGVjdGlvbiBwb2ludHM6XG4gICAtIGlmIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IHJhbmdlIGlzIHNtYWxsLCB1c2UgaW5zZXJ0aW9uIHNvcnQgdG8gc29ydCBpdFxuICAgLSBpZiB0aGUgc3RhY2sgZGVwdGggaXMgbGFyZ2UsIHNvcnQgdGhlIHJhbmdlIHdpdGggaGVhcC1zb3J0IHRvIGF2b2lkIG5eMiB3b3JzdC1jYXNlXG4gICAgIGJlaGF2aW9yXG5cbiAgIFNlZSB0aGUgZm9sbG93aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uOlxuICAgLSBcIkR1YWwtUGl2b3QgUXVpY2tzb3J0XCIgYnkgVmxhZGltaXIgWWFyb3NsYXZza2l5LlxuICAgICBBdmFpbGFibGUgYXRcbiAgICAgaHR0cDovL3d3dy5rcmljaGUuY29tLmFyL3Jvb3QvcHJvZ3JhbW1pbmcvc3BhY2VUaW1lQ29tcGxleGl0eS9EdWFsUGl2b3RRdWlja3NvcnQucGRmXG4gICAtIFwiUXVpY2tzb3J0IGlzIE9wdGltYWxcIiBieSBTZWRnZXdpY2sgYW5kIEJlbnRsZXkuXG4gICAgIFNsaWRlcyBhdCBodHRwOi8vd3d3LmNzLnByaW5jZXRvbi5lZHUvfnJzL3RhbGtzL1F1aWNrc29ydElzT3B0aW1hbC5wZGZcbiAgIC0gaHR0cDovL3d3dy5zb3J0aW5nLWFsZ29yaXRobXMuY29tL3F1aWNrLXNvcnQtMy13YXkgKilcblxubW9kdWxlIFNvcnRlciAoUyA6IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2FcbiAgdmFsIHNldCA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG5lbmQpID1cbnN0cnVjdFxuICBpbmNsdWRlIFNcblxuICBsZXQgc3dhcCBhcnIgaSBqID1cbiAgICBsZXQgdG1wID0gZ2V0IGFyciBpIGluXG4gICAgc2V0IGFyciBpIChnZXQgYXJyIGopO1xuICAgIHNldCBhcnIgaiB0bXBcbiAgOztcblxuICBtb2R1bGUgdHlwZSBTb3J0ID0gc2lnXG4gICAgdmFsIHNvcnRcbiAgICAgIDogICdhIHRcbiAgICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludClcbiAgICAgIC0+IGxlZnQ6aW50ICgqIGxlZnRtb3N0IGluZGV4IG9mIHN1Yi1hcnJheSB0byBzb3J0ICopXG4gICAgICAtPiByaWdodDppbnQgKCogcmlnaHRtb3N0IGluZGV4IG9mIHN1Yi1hcnJheSB0byBzb3J0ICopXG4gICAgICAtPiB1bml0XG4gIGVuZFxuXG4gICgqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5zZXJ0aW9uX3NvcnQgKilcbiAgbW9kdWxlIEluc2VydGlvbl9zb3J0IDogU29ydCA9IHN0cnVjdFxuICAgICgqIGxvb3AgaW52YXJpYW50czpcbiAgICAgICAxLiAgdGhlIHN1YmFycmF5IGFycltsZWZ0IC4uIGktMV0gaXMgc29ydGVkXG4gICAgICAgMi4gIHRoZSBzdWJhcnJheSBhcnJbaSsxIC4uIHBvc10gaXMgc29ydGVkIGFuZCBjb250YWlucyBvbmx5IGVsZW1lbnRzID4gdlxuICAgICAgIDMuICBhcnJbaV0gbWF5IGJlIHRob3VnaHQgb2YgYXMgY29udGFpbmluZyB2XG4gICAgKilcbiAgICBsZXQgcmVjIGluc2VydF9sb29wIGFyciB+bGVmdCB+Y29tcGFyZSBpIHYgPVxuICAgICAgbGV0IGlfbmV4dCA9IGkgLSAxIGluXG4gICAgICBpZiBpX25leHQgPj0gbGVmdCAmJiBjb21wYXJlIChnZXQgYXJyIGlfbmV4dCkgdiA+IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBzZXQgYXJyIGkgKGdldCBhcnIgaV9uZXh0KTtcbiAgICAgICAgaW5zZXJ0X2xvb3AgYXJyIH5sZWZ0IH5jb21wYXJlIGlfbmV4dCB2KVxuICAgICAgZWxzZSBpXG4gICAgOztcblxuICAgIGxldCBzb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgKCogbG9vcCBpbnZhcmlhbnQ6XG4gICAgICAgICBbYXJyXSBpcyBzb3J0ZWQgZnJvbSBbbGVmdF0gdG8gW3BvcyAtIDFdLCBpbmNsdXNpdmUgKilcbiAgICAgIGZvciBwb3MgPSBsZWZ0ICsgMSB0byByaWdodCBkb1xuICAgICAgICBsZXQgdiA9IGdldCBhcnIgcG9zIGluXG4gICAgICAgIGxldCBmaW5hbF9wb3MgPSBpbnNlcnRfbG9vcCBhcnIgfmxlZnQgfmNvbXBhcmUgcG9zIHYgaW5cbiAgICAgICAgc2V0IGFyciBmaW5hbF9wb3MgdlxuICAgICAgZG9uZVxuICAgIDs7XG4gIGVuZFxuXG4gICgqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVhcHNvcnQgKilcbiAgbW9kdWxlIEhlYXBfc29ydCA6IFNvcnQgPSBzdHJ1Y3RcbiAgICAoKiBsb29wIGludmFyaWFudDpcbiAgICAgICByb290J3MgY2hpbGRyZW4gYXJlIGJvdGggZWl0aGVyIHJvb3RzIG9mIG1heC1oZWFwcyBvciA+IHJpZ2h0ICopXG4gICAgbGV0IHJlYyBoZWFwaWZ5IGFyciB+Y29tcGFyZSByb290IH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgcmVsYXRpdmVfcm9vdCA9IHJvb3QgLSBsZWZ0IGluXG4gICAgICBsZXQgbGVmdF9jaGlsZCA9ICgyICogcmVsYXRpdmVfcm9vdCkgKyBsZWZ0ICsgMSBpblxuICAgICAgbGV0IHJpZ2h0X2NoaWxkID0gKDIgKiByZWxhdGl2ZV9yb290KSArIGxlZnQgKyAyIGluXG4gICAgICBsZXQgbGFyZ2VzdCA9XG4gICAgICAgIGlmIGxlZnRfY2hpbGQgPD0gcmlnaHQgJiYgY29tcGFyZSAoZ2V0IGFyciBsZWZ0X2NoaWxkKSAoZ2V0IGFyciByb290KSA+IDBcbiAgICAgICAgdGhlbiBsZWZ0X2NoaWxkXG4gICAgICAgIGVsc2Ugcm9vdFxuICAgICAgaW5cbiAgICAgIGxldCBsYXJnZXN0ID1cbiAgICAgICAgaWYgcmlnaHRfY2hpbGQgPD0gcmlnaHQgJiYgY29tcGFyZSAoZ2V0IGFyciByaWdodF9jaGlsZCkgKGdldCBhcnIgbGFyZ2VzdCkgPiAwXG4gICAgICAgIHRoZW4gcmlnaHRfY2hpbGRcbiAgICAgICAgZWxzZSBsYXJnZXN0XG4gICAgICBpblxuICAgICAgaWYgbGFyZ2VzdCA8PiByb290XG4gICAgICB0aGVuIChcbiAgICAgICAgc3dhcCBhcnIgcm9vdCBsYXJnZXN0O1xuICAgICAgICBoZWFwaWZ5IGFyciB+Y29tcGFyZSBsYXJnZXN0IH5sZWZ0IH5yaWdodClcbiAgICA7O1xuXG4gICAgbGV0IGJ1aWxkX2hlYXAgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICAoKiBFbGVtZW50cyBpbiB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIGFycmF5IGFyZSBhbHJlYWR5IGhlYXBzIG9mIHNpemUgMS4gIFdlIG1vdmVcbiAgICAgICAgIHRocm91Z2ggdGhlIGZpcnN0IGhhbGYgb2YgdGhlIGFycmF5IGZyb20gYmFjayB0byBmcm9udCBleGFtaW5pbmcgdGhlIGVsZW1lbnQgYXRcbiAgICAgICAgIGhhbmQsIGFuZCB0aGUgbGVmdCBhbmQgcmlnaHQgY2hpbGRyZW4sIGZpeGluZyB0aGUgaGVhcCBwcm9wZXJ0eSBhcyB3ZSBnby4gKilcbiAgICAgIGZvciBpID0gKGxlZnQgKyByaWdodCkgLyAyIGRvd250byBsZWZ0IGRvXG4gICAgICAgIGhlYXBpZnkgYXJyIH5jb21wYXJlIGkgfmxlZnQgfnJpZ2h0XG4gICAgICBkb25lXG4gICAgOztcblxuICAgIGxldCBzb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgYnVpbGRfaGVhcCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0O1xuICAgICAgKCogbG9vcCBpbnZhcmlhbnRzOlxuICAgICAgICAgMS4gIHRoZSBzdWJhcnJheSBhcnJbbGVmdCAuLi4gaV0gaXMgYSBtYXgtaGVhcCBIXG4gICAgICAgICAyLiAgdGhlIHN1YmFycmF5IGFycltpKzEgLi4uIHJpZ2h0XSBpcyBzb3J0ZWQgKGNhbGwgaXQgUylcbiAgICAgICAgIDMuICBldmVyeSBlbGVtZW50IG9mIEggaXMgbGVzcyB0aGFuIGV2ZXJ5IGVsZW1lbnQgb2YgUyAqKVxuICAgICAgZm9yIGkgPSByaWdodCBkb3dudG8gbGVmdCArIDEgZG9cbiAgICAgICAgc3dhcCBhcnIgbGVmdCBpO1xuICAgICAgICBoZWFwaWZ5IGFyciB+Y29tcGFyZSBsZWZ0IH5sZWZ0IH5yaWdodDooaSAtIDEpXG4gICAgICBkb25lXG4gICAgOztcbiAgZW5kXG5cbiAgKCogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRyb3NvcnQgKilcbiAgbW9kdWxlIEludHJvX3NvcnQgOiBzaWdcbiAgICBpbmNsdWRlIFNvcnRcblxuICAgIHZhbCBmaXZlX2VsZW1lbnRfc29ydFxuICAgICAgOiAgJ2EgdFxuICAgICAgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KVxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IHVuaXRcbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGZpdmVfZWxlbWVudF9zb3J0IGFyciB+KGNvbXBhcmUgOiBfIC0+IF8gLT4gXykgbTEgbTIgbTMgbTQgbTUgPVxuICAgICAgbGV0IGNvbXBhcmVfYW5kX3N3YXAgaSBqID1cbiAgICAgICAgaWYgY29tcGFyZSAoZ2V0IGFyciBpKSAoZ2V0IGFyciBqKSA+IDAgdGhlbiBzd2FwIGFyciBpIGpcbiAgICAgIGluXG4gICAgICAoKiBPcHRpbWFsIDUtZWxlbWVudCBzb3J0aW5nIG5ldHdvcms6XG5cbiAgICAgICAgIHt2XG4gICAgICAgICAgICAxLS1vLS0tLS1vLS0tLS1vLS0tLS0tLS0tLS0tLS0xXG4gICAgICAgICAgICAgICB8ICAgICB8ICAgICB8XG4gICAgICAgICAgICAyLS1vLS0tLS18LS1vLS18LS0tLS1vLS1vLS0tLS0yXG4gICAgICAgICAgICAgICAgICAgICB8ICB8ICB8ICAgICB8ICB8XG4gICAgICAgICAgICAzLS0tLS0tLS1vLS1vLS18LS1vLS18LS1vLS0tLS0zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICB8ICB8XG4gICAgICAgICAgICA0LS0tLS1vLS0tLS0tLS1vLS1vLS18LS0tLS1vLS00XG4gICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICB8XG4gICAgICAgICAgICA1LS0tLS1vLS0tLS0tLS0tLS0tLS1vLS0tLS1vLS01XG4gICAgICAgICAgdn0gKilcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTEgbTI7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG00IG01O1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMSBtMztcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTIgbTM7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0xIG00O1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMyBtNDtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTIgbTU7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0yIG0zO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtNCBtNSBbQG5vbnRhaWxdXG4gICAgOztcblxuICAgICgqIGNob29zZSBwaXZvdHMgZm9yIHRoZSBhcnJheSBieSBzb3J0aW5nIDUgZWxlbWVudHMgYW5kIGV4YW1pbmluZyB0aGUgY2VudGVyIHRocmVlXG4gICAgICAgZWxlbWVudHMuICBUaGUgZ29hbCBpcyB0byBjaG9vc2UgdHdvIHBpdm90cyB0aGF0IHdpbGwgZWl0aGVyOlxuICAgICAgIC0gYnJlYWsgdGhlIHJhbmdlIHVwIGludG8gMyBldmVuIHBhcnRpdGlvbnNcbiAgICAgICAgIG9yXG4gICAgICAgLSBlbGltaW5hdGUgYSBjb21tb25seSBhcHBlYXJpbmcgZWxlbWVudCBieSBzb3J0aW5nIGl0IGludG8gdGhlIGNlbnRlciBwYXJ0aXRpb25cbiAgICAgICAgIGJ5IGl0c2VsZlxuICAgICAgICAgVG8gdGhpcyBlbmQgd2UgbG9vayBhdCB0aGUgY2VudGVyIDMgZWxlbWVudHMgb2YgdGhlIDUgYW5kIHJldHVybiBwYWlycyBvZiBlcXVhbFxuICAgICAgICAgZWxlbWVudHMgb3IgdGhlIHdpZGVzdCByYW5nZSAqKVxuICAgIGxldCBjaG9vc2VfcGl2b3RzIGFyciB+KGNvbXBhcmUgOiBfIC0+IF8gLT4gXykgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBzaXh0aCA9IChyaWdodCAtIGxlZnQpIC8gNiBpblxuICAgICAgbGV0IG0xID0gbGVmdCArIHNpeHRoIGluXG4gICAgICBsZXQgbTIgPSBtMSArIHNpeHRoIGluXG4gICAgICBsZXQgbTMgPSBtMiArIHNpeHRoIGluXG4gICAgICBsZXQgbTQgPSBtMyArIHNpeHRoIGluXG4gICAgICBsZXQgbTUgPSBtNCArIHNpeHRoIGluXG4gICAgICBmaXZlX2VsZW1lbnRfc29ydCBhcnIgfmNvbXBhcmUgbTEgbTIgbTMgbTQgbTU7XG4gICAgICBsZXQgbTJfdmFsID0gZ2V0IGFyciBtMiBpblxuICAgICAgbGV0IG0zX3ZhbCA9IGdldCBhcnIgbTMgaW5cbiAgICAgIGxldCBtNF92YWwgPSBnZXQgYXJyIG00IGluXG4gICAgICBpZiBjb21wYXJlIG0yX3ZhbCBtM192YWwgPSAwXG4gICAgICB0aGVuIG0yX3ZhbCwgbTNfdmFsLCB0cnVlXG4gICAgICBlbHNlIGlmIGNvbXBhcmUgbTNfdmFsIG00X3ZhbCA9IDBcbiAgICAgIHRoZW4gbTNfdmFsLCBtNF92YWwsIHRydWVcbiAgICAgIGVsc2UgbTJfdmFsLCBtNF92YWwsIGZhbHNlXG4gICAgOztcblxuICAgIGxldCBkdWFsX3Bpdm90X3BhcnRpdGlvbiBhcnIgfihjb21wYXJlIDogXyAtPiBfIC0+IF8pIH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgcGl2b3QxLCBwaXZvdDIsIHBpdm90c19lcXVhbCA9IGNob29zZV9waXZvdHMgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCBpblxuICAgICAgKCogbG9vcCBpbnZhcmlhbnRzOlxuICAgICAgICAgMS4gIGxlZnQgPD0gbCA8IHIgPD0gcmlnaHRcbiAgICAgICAgIDIuICBsIDw9IHAgPD0gclxuICAgICAgICAgMy4gIGwgPD0geCA8IHAgICAgIGltcGxpZXMgYXJyW3hdID49IHBpdm90MVxuICAgICAgICAgYW5kIGFyclt4XSA8PSBwaXZvdDJcbiAgICAgICAgIDQuICBsZWZ0IDw9IHggPCBsICBpbXBsaWVzIGFyclt4XSA8IHBpdm90MVxuICAgICAgICAgNS4gIHIgPCB4IDw9IHJpZ2h0IGltcGxpZXMgYXJyW3hdID4gcGl2b3QyICopXG4gICAgICBsZXQgcmVjIGxvb3AgbCBwIHIgPVxuICAgICAgICBsZXQgcHYgPSBnZXQgYXJyIHAgaW5cbiAgICAgICAgaWYgY29tcGFyZSBwdiBwaXZvdDEgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHN3YXAgYXJyIHAgbDtcbiAgICAgICAgICBjb250IChsICsgMSkgKHAgKyAxKSByKVxuICAgICAgICBlbHNlIGlmIGNvbXBhcmUgcHYgcGl2b3QyID4gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBsb29wIGludmFyaWFudHM6ICBzYW1lIGFzIHRob3NlIG9mIHRoZSBvdXRlciBsb29wICopXG4gICAgICAgICAgbGV0IHJlYyBzY2FuX2JhY2t3YXJkcyByID1cbiAgICAgICAgICAgIGlmIHIgPiBwICYmIGNvbXBhcmUgKGdldCBhcnIgcikgcGl2b3QyID4gMCB0aGVuIHNjYW5fYmFja3dhcmRzIChyIC0gMSkgZWxzZSByXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgciA9IHNjYW5fYmFja3dhcmRzIHIgaW5cbiAgICAgICAgICBzd2FwIGFyciByIHA7XG4gICAgICAgICAgY29udCBsIHAgKHIgLSAxKSlcbiAgICAgICAgZWxzZSBjb250IGwgKHAgKyAxKSByXG4gICAgICBhbmQgY29udCBsIHAgciA9IGlmIHAgPiByIHRoZW4gbCwgciBlbHNlIGxvb3AgbCBwIHIgaW5cbiAgICAgIGxldCBsLCByID0gY29udCBsZWZ0IGxlZnQgcmlnaHQgaW5cbiAgICAgIGwsIHIsIHBpdm90c19lcXVhbFxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBsZW4gPSByaWdodCAtIGxlZnQgKyAxIGluXG4gICAgICAoKiBUaGlzIHRha2VzIGNhcmUgb2Ygc29tZSBlZGdlIGNhc2VzLCBzdWNoIGFzIGxlZnQgPiByaWdodCBvciB2ZXJ5IHNob3J0IGFycmF5cyxcbiAgICAgICAgIHNpbmNlIEluc2VydGlvbl9zb3J0LnNvcnQgaGFuZGxlcyB0aGVzZSBjYXNlcyBwcm9wZXJseS4gIFRodXMgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAgbWFrZSBzdXJlIHRoYXQgbGVmdCBhbmQgcmlnaHQgYXJlIHZhbGlkIGluIHJlY3Vyc2l2ZSBjYWxscy4gKilcbiAgICAgIGlmIGxlbiA8PSAzMlxuICAgICAgdGhlbiBJbnNlcnRpb25fc29ydC5zb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHRcbiAgICAgIGVsc2UgaWYgbWF4X2RlcHRoIDwgMFxuICAgICAgdGhlbiBIZWFwX3NvcnQuc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG1heF9kZXB0aCA9IG1heF9kZXB0aCAtIDEgaW5cbiAgICAgICAgbGV0IGwsIHIsIG1pZGRsZV9zb3J0ZWQgPSBkdWFsX3Bpdm90X3BhcnRpdGlvbiBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0IGluXG4gICAgICAgIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0OihsIC0gMSk7XG4gICAgICAgIGlmIG5vdCBtaWRkbGVfc29ydGVkIHRoZW4gaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aCB+Y29tcGFyZSB+bGVmdDpsIH5yaWdodDpyO1xuICAgICAgICBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoIH5jb21wYXJlIH5sZWZ0OihyICsgMSkgfnJpZ2h0KVxuICAgIDs7XG5cbiAgICBsZXQgc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBoZWFwX3NvcnRfc3dpdGNoX2RlcHRoID1cbiAgICAgICAgKCogV2UgYmFpbCBvdXQgdG8gaGVhcCBzb3J0IGF0IGEgcmVjdXJzaW9uIGRlcHRoIG9mIDMyLiBHTlUgaW50cm9zb3J0IHVzZXMgMmxnKG4pLlxuICAgICAgICAgICBUaGUgZXhwZWN0ZWQgcmVjdXJzaW9uIGRlcHRoIGZvciBwZXJmZWN0IDMtd2F5IHNwbGl0cyBpcyBsb2dfMyhuKS5cblxuICAgICAgICAgICBVc2luZyAzMiBtZWFucyBhIGJhbGFuY2VkIDMtd2F5IHNwbGl0IHdvdWxkIHdvcmsgdXAgdG8gM14zMiBlbGVtZW50cyAocm91Z2hseVxuICAgICAgICAgICAyXjUwIG9yIDEwXjE1KS4gR05VIHJlYWNoZXMgYSBkZXB0aCBvZiAzMiBhdCA2NTUzNiBlbGVtZW50cy5cblxuICAgICAgICAgICBGb3Igc21hbGwgYXJyYXlzLCB0aGlzIG1ha2VzIHVzIGxlc3MgbGlrZWx5IHRvIGJhaWwgb3V0IHRvIGhlYXAgc29ydCwgYnV0IHRoZVxuICAgICAgICAgICAzMipOIGNvc3QgYmVmb3JlIHdlIGRvIGlzIG5vdCB0aGF0IG11Y2guXG5cbiAgICAgICAgICAgRm9yIGxhcmdlIGFycmF5cywgdGhpcyBtZWFucyB3ZSBhcmUgbW9yZSBsaWtlbHkgdG8gYmFpbCBvdXQgdG8gaGVhcCBzb3J0IGF0XG4gICAgICAgICAgIHNvbWUgcG9pbnQgaWYgd2UgZ2V0IHNvbWUgYmFkIHNwbGl0cyBvciBpZiB0aGUgYXJyYXkgaXMgaHVnZS4gQnV0IHRoYXQncyBvbmx5IGFcbiAgICAgICAgICAgY29uc3RhbnQgZmFjdG9yIGNvc3QgaW4gdGhlIGZpbmFsIHN0YWdlcyBvZiByZWN1cnNpb24uXG5cbiAgICAgICAgICAgQWxsIGluIGFsbCwgdGhpcyBzZWVtcyB0byBiZSBhIHNtYWxsIHRyYWRlb2ZmIGFuZCBhdm9pZHMgcGF5aW5nIGEgY29zdCB0b1xuICAgICAgICAgICBjb21wdXRlIGEgbG9nYXJpdGhtIGF0IHRoZSBzdGFydC4gKilcbiAgICAgICAgMzJcbiAgICAgIGluXG4gICAgICBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoOmhlYXBfc29ydF9zd2l0Y2hfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0XG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHNvcnQgP3BvcyA/bGVuIGFyciB+KGNvbXBhcmUgOiBfIC0+IF8gLT4gXykgPVxuICAgIGxldCBwb3MsIGxlbiA9XG4gICAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIGFycilcbiAgICBpblxuICAgIEludHJvX3NvcnQuc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQ6cG9zIH5yaWdodDoocG9zICsgbGVuIC0gMSlcbiAgOztcbmVuZFxuW0BAaW5saW5lXVxuXG5tb2R1bGUgU29ydCA9IFNvcnRlciAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IGdldCA9IHVuc2FmZV9nZXRcbiAgbGV0IHNldCA9IHVuc2FmZV9zZXRcbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuZW5kKVxuXG5sZXQgc29ydCA9IFNvcnQuc29ydFxubGV0IG9mX2FycmF5IHQgPSB0XG5sZXQgdG9fYXJyYXkgdCA9IHRcbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbmxldCBpc19zb3J0ZWQgdCB+Y29tcGFyZSA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+IDAgJiYgIXJlc3VsdCBkb1xuICAgIGxldCBlbHRfaSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgIGxldCBlbHRfaV9taW51c18xID0gdW5zYWZlX2dldCB0ICghaSAtIDEpIGluXG4gICAgaWYgY29tcGFyZSBlbHRfaV9taW51c18xIGVsdF9pID4gMCB0aGVuIHJlc3VsdCA6PSBmYWxzZTtcbiAgICBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGlzX3NvcnRlZF9zdHJpY3RseSB0IH5jb21wYXJlID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID4gMCAmJiAhcmVzdWx0IGRvXG4gICAgbGV0IGVsdF9pID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgbGV0IGVsdF9pX21pbnVzXzEgPSB1bnNhZmVfZ2V0IHQgKCFpIC0gMSkgaW5cbiAgICBpZiBjb21wYXJlIGVsdF9pX21pbnVzXzEgZWx0X2kgPj0gMCB0aGVuIHJlc3VsdCA6PSBmYWxzZTtcbiAgICBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IG1lcmdlIGExIGEyIH5jb21wYXJlID1cbiAgbGV0IGwxID0gQXJyYXkubGVuZ3RoIGExIGluXG4gIGxldCBsMiA9IEFycmF5Lmxlbmd0aCBhMiBpblxuICBpZiBsMSA9IDBcbiAgdGhlbiBjb3B5IGEyXG4gIGVsc2UgaWYgbDIgPSAwXG4gIHRoZW4gY29weSBhMVxuICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYTIgMCkgKHVuc2FmZV9nZXQgYTEgKGwxIC0gMSkpID49IDBcbiAgdGhlbiBhcHBlbmQgYTEgYTJcbiAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGExIDApICh1bnNhZmVfZ2V0IGEyIChsMiAtIDEpKSA+IDBcbiAgdGhlbiBhcHBlbmQgYTIgYTFcbiAgZWxzZSAoXG4gICAgbGV0IGxlbiA9IGwxICsgbDIgaW5cbiAgICBsZXQgbWVyZ2VkID0gY3JlYXRlIH5sZW4gKHVuc2FmZV9nZXQgYTEgMCkgaW5cbiAgICBsZXQgYTFfaW5kZXggPSByZWYgMCBpblxuICAgIGxldCBhMl9pbmRleCA9IHJlZiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCB1c2VfYTEgPVxuICAgICAgICBpZiBsMSA9ICFhMV9pbmRleFxuICAgICAgICB0aGVuIGZhbHNlXG4gICAgICAgIGVsc2UgaWYgbDIgPSAhYTJfaW5kZXhcbiAgICAgICAgdGhlbiB0cnVlXG4gICAgICAgIGVsc2UgY29tcGFyZSAodW5zYWZlX2dldCBhMSAhYTFfaW5kZXgpICh1bnNhZmVfZ2V0IGEyICFhMl9pbmRleCkgPD0gMFxuICAgICAgaW5cbiAgICAgIGlmIHVzZV9hMVxuICAgICAgdGhlbiAoXG4gICAgICAgIHVuc2FmZV9zZXQgbWVyZ2VkIGkgKHVuc2FmZV9nZXQgYTEgIWExX2luZGV4KTtcbiAgICAgICAgYTFfaW5kZXggOj0gIWExX2luZGV4ICsgMSlcbiAgICAgIGVsc2UgKFxuICAgICAgICB1bnNhZmVfc2V0IG1lcmdlZCBpICh1bnNhZmVfZ2V0IGEyICFhMl9pbmRleCk7XG4gICAgICAgIGEyX2luZGV4IDo9ICFhMl9pbmRleCArIDEpXG4gICAgZG9uZTtcbiAgICBtZXJnZWQpXG47O1xuXG5sZXQgY29weV9tYXRyaXggPSBtYXAgfmY6Y29weVxuXG5sZXQgZm9sZGluZ19tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICBsZXQgbmV3X2FjYywgeSA9IGYgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGRfbWFwIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbGV0IHJlc3VsdCA9XG4gICAgbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYywgeSA9IGYgIWFjYyB4IGluXG4gICAgICBhY2MgOj0gbmV3X2FjYztcbiAgICAgIHkpXG4gIGluXG4gICFhY2MsIHJlc3VsdFxuOztcblxubGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxubGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdCB+ZmluaXNoXG5sZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5cbmxldFtAaW5saW5lIGFsd2F5c10gZXh0cmVtYWxfZWxlbWVudCB0IH5jb21wYXJlIH5rZWVwX2xlZnRfaWYgPVxuICBpZiBpc19lbXB0eSB0XG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgcmVzdWx0ID0gcmVmICh1bnNhZmVfZ2V0IHQgMCkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgdCBpIGluXG4gICAgICByZXN1bHQgOj0gQm9vbC5zZWxlY3QgKChrZWVwX2xlZnRfaWYgW0BpbmxpbmVkXSkgKGNvbXBhcmUgeCAhcmVzdWx0KSkgeCAhcmVzdWx0XG4gICAgZG9uZTtcbiAgICBTb21lICFyZXN1bHQpXG47O1xuXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlID1cbiAgKGV4dHJlbWFsX2VsZW1lbnQgW0BpbmxpbmVkXSkgdCB+Y29tcGFyZSB+a2VlcF9sZWZ0X2lmOihmdW4gY29tcGFyZV9yZXN1bHQgLT5cbiAgICBjb21wYXJlX3Jlc3VsdCA8IDApXG47O1xuXG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlID1cbiAgKGV4dHJlbWFsX2VsZW1lbnQgW0BpbmxpbmVkXSkgdCB+Y29tcGFyZSB+a2VlcF9sZWZ0X2lmOihmdW4gY29tcGFyZV9yZXN1bHQgLT5cbiAgICBjb21wYXJlX3Jlc3VsdCA+IDApXG47O1xuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgYWNjIDo9IGYgaSAhYWNjICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZTtcbiAgIWFjY1xuOztcblxubGV0IGZvbGRpbmdfbWFwaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIG1hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmb2xkX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCBjb3VudCB0IH5mID1cbiAgbGV0IHJlc3VsdCA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdCAtIDEgZG9cbiAgICByZXN1bHQgOj0gIXJlc3VsdCArIChmIChBcnJheS51bnNhZmVfZ2V0IHQgaSkgfD4gQm9vbC50b19pbnQpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGxldCByZXN1bHQgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQgLSAxIGRvXG4gICAgcmVzdWx0IDo9ICFyZXN1bHQgKyAoZiBpIChBcnJheS51bnNhZmVfZ2V0IHQgaSkgfD4gQm9vbC50b19pbnQpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBjb25jYXRfbWFwIHQgfmYgPSBjb25jYXQgKHRvX2xpc3QgKG1hcCB+ZiB0KSlcbmxldCBjb25jYXRfbWFwaSB0IH5mID0gY29uY2F0ICh0b19saXN0IChtYXBpIH5mIHQpKVxuXG5sZXQgcmV2X2lucGxhY2UgdCA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgd2hpbGUgIWkgPCAhaiBkb1xuICAgIHN3YXAgdCAhaSAhajtcbiAgICBpbmNyIGk7XG4gICAgZGVjciBqXG4gIGRvbmVcbjs7XG5cbmxldCByZXYgdCA9XG4gIGxldCB0ID0gY29weSB0IGluXG4gIHJldl9pbnBsYWNlIHQ7XG4gIHRcbjs7XG5cbmxldCBvZl9saXN0X3JldiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IGEgOjogbCAtPlxuICAgIGxldCBsZW4gPSAxICsgTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCB0ID0gY3JlYXRlIH5sZW4gYSBpblxuICAgIGxldCByID0gcmVmIGwgaW5cbiAgICAoKiBXZSBzdGFydCBhdCBbbGVuIC0gMl0gYmVjYXVzZSB3ZSBhbHJlYWR5IHB1dCBbYV0gYXQgW3QuKGxlbiAtIDEpXS4gKilcbiAgICBmb3IgaSA9IGxlbiAtIDIgZG93bnRvIDAgZG9cbiAgICAgIG1hdGNoICFyIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IGEgOjogbCAtPlxuICAgICAgICB0LihpKSA8LSBhO1xuICAgICAgICByIDo9IGxcbiAgICBkb25lO1xuICAgIHRcbjs7XG5cbigqIFtvZl9saXN0X21hcF0gYW5kIFtvZl9saXN0X3Jldl9tYXBdIGFyZSBiYXNlZCBvbiBmdW5jdGlvbnMgZnJvbSB0aGUgT0NhbWxcbiAgIGRpc3RyaWJ1dGlvbi4gKilcblxubGV0IG9mX2xpc3RfbWFwIHhzIH5mID1cbiAgbWF0Y2ggeHMgd2l0aFxuICB8IFtdIC0+IFt8fF1cbiAgfCBoZCA6OiB0bCAtPlxuICAgIGxldCBhID0gY3JlYXRlIH5sZW46KDEgKyBMaXN0Lmxlbmd0aCB0bCkgKGYgaGQpIGluXG4gICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBhXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIHVuc2FmZV9zZXQgYSBpIChmIGhkKTtcbiAgICAgICAgZmlsbCAoaSArIDEpIHRsXG4gICAgaW5cbiAgICBmaWxsIDEgdGwgW0Bub250YWlsXVxuOztcblxubGV0IG9mX2xpc3RfbWFwaSB4cyB+ZiA9XG4gIG1hdGNoIHhzIHdpdGhcbiAgfCBbXSAtPiBbfHxdXG4gIHwgaGQgOjogdGwgLT5cbiAgICBsZXQgYSA9IGNyZWF0ZSB+bGVuOigxICsgTGlzdC5sZW5ndGggdGwpIChmIDAgaGQpIGluXG4gICAgbGV0IHJlYyBmaWxsIGEgaSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IGFcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgdW5zYWZlX3NldCBhIGkgKGYgaSBoZCk7XG4gICAgICAgIGZpbGwgYSAoaSArIDEpIHRsXG4gICAgaW5cbiAgICBmaWxsIGEgMSB0bCBbQG5vbnRhaWxdXG47O1xuXG5sZXQgb2ZfbGlzdF9yZXZfbWFwIHhzIH5mID1cbiAgbGV0IHQgPSBvZl9saXN0X21hcCB4cyB+ZiBpblxuICByZXZfaW5wbGFjZSB0O1xuICB0XG47O1xuXG5sZXQgb2ZfbGlzdF9yZXZfbWFwaSB4cyB+ZiA9XG4gIGxldCB0ID0gb2ZfbGlzdF9tYXBpIHhzIH5mIGluXG4gIHJldl9pbnBsYWNlIHQ7XG4gIHRcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgbGV0IHIgPSByZWYgW3x8XSBpblxuICBsZXQgayA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBtYXRjaCBmIGkgKHVuc2FmZV9nZXQgdCBpKSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGEgLT5cbiAgICAgIGlmICFrID0gMCB0aGVuIHIgOj0gY3JlYXRlIH5sZW46KGxlbmd0aCB0KSBhO1xuICAgICAgdW5zYWZlX3NldCAhciAhayBhO1xuICAgICAgaW5jciBrXG4gIGRvbmU7XG4gIGlmICFrID0gbGVuZ3RoIHQgdGhlbiAhciBlbHNlIGlmICFrID4gMCB0aGVuIHN1YiB+cG9zOjAgfmxlbjohayAhciBlbHNlIFt8fF1cbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gX2kgYSAtPiBmIGEpIFtAbm9udGFpbF1cbmxldCBmaWx0ZXJfb3B0IHQgPSBmaWx0ZXJfbWFwIHQgfmY6Rm4uaWRcblxubGV0IHJhaXNlX2xlbmd0aF9taXNtYXRjaCBuYW1lIG4xIG4yID1cbiAgaW52YWxpZF9hcmdmIFwibGVuZ3RoIG1pc21hdGNoIGluICVzOiAlZCA8PiAlZFwiIG5hbWUgbjEgbjIgKClcbiAgW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbjs7XG5cbmxldCBjaGVja19sZW5ndGgyX2V4biBuYW1lIHQxIHQyID1cbiAgbGV0IG4xID0gbGVuZ3RoIHQxIGluXG4gIGxldCBuMiA9IGxlbmd0aCB0MiBpblxuICBpZiBuMSA8PiBuMiB0aGVuIHJhaXNlX2xlbmd0aF9taXNtYXRjaCBuYW1lIG4xIG4yXG47O1xuXG5sZXQgaXRlcjJfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5pdGVyMl9leG5cIiB0MSB0MjtcbiAgaXRlcmkgdDEgfmY6KGZ1biBpIHgxIC0+IGYgeDEgKHVuc2FmZV9nZXQgdDIgaSkpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBtYXAyX2V4biB0MSB0MiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkubWFwMl9leG5cIiB0MSB0MjtcbiAgaW5pdCAobGVuZ3RoIHQxKSB+ZjooZnVuIGkgLT4gZiAodW5zYWZlX2dldCB0MSBpKSAodW5zYWZlX2dldCB0MiBpKSkgW0Bub250YWlsXVxuOztcblxubGV0IGZvbGQyX2V4biB0MSB0MiB+aW5pdCB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuZm9sZDJfZXhuXCIgdDEgdDI7XG4gIGZvbGRpIHQxIH5pbml0IH5mOihmdW4gaSBhYyB4IC0+IGYgYWMgeCAodW5zYWZlX2dldCB0MiBpKSkgW0Bub250YWlsXVxuOztcblxubGV0IGZpbHRlciB0IH5mID0gZmlsdGVyX21hcCB0IH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBOb25lKSBbQG5vbnRhaWxdXG5sZXQgZmlsdGVyaSB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpIFtAbm9udGFpbF1cblxubGV0IGV4aXN0cyB0IH5mID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiBmYWxzZSBpblxuICB3aGlsZSAhaSA+PSAwICYmIG5vdCAhcmVzdWx0IGRvXG4gICAgaWYgZiAodW5zYWZlX2dldCB0ICFpKSB0aGVuIHJlc3VsdCA6PSB0cnVlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIGZhbHNlIGluXG4gIHdoaWxlICFpID49IDAgJiYgbm90ICFyZXN1bHQgZG9cbiAgICBpZiBmICFpICh1bnNhZmVfZ2V0IHQgIWkpIHRoZW4gcmVzdWx0IDo9IHRydWUgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID0gZXhpc3RzIHQgfmY6KGVxdWFsIGEpIFtAbm9udGFpbF1cblxubGV0IGZvcl9hbGwgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgKHVuc2FmZV9nZXQgdCAhaSkpIHRoZW4gcmVzdWx0IDo9IGZhbHNlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGxldCBpID0gcmVmIChsZW5ndGggLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiAhcmVzdWx0IGRvXG4gICAgaWYgbm90IChmICFpICh1bnNhZmVfZ2V0IHQgIWkpKSB0aGVuIHJlc3VsdCA6PSBmYWxzZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZXhpc3RzMl9leG4gdDEgdDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5LmV4aXN0czJfZXhuXCIgdDEgdDI7XG4gIGxldCBpID0gcmVmIChsZW5ndGggdDEgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIGZhbHNlIGluXG4gIHdoaWxlICFpID49IDAgJiYgbm90ICFyZXN1bHQgZG9cbiAgICBpZiBmICh1bnNhZmVfZ2V0IHQxICFpKSAodW5zYWZlX2dldCB0MiAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZm9yX2FsbDJfbG9jYWxfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5mb3JfYWxsMl9leG5cIiB0MSB0MjtcbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0MSAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgKHVuc2FmZV9nZXQgdDEgIWkpICh1bnNhZmVfZ2V0IHQyICFpKSkgdGhlbiByZXN1bHQgOj0gZmFsc2UgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGZvcl9hbGwyX2V4biB0MSB0MiB+ZiA9IGZvcl9hbGwyX2xvY2FsX2V4biB0MSB0MiB+ZlxubGV0IGVxdWFsX19sb2NhbCBlcXVhbCB0MSB0MiA9IGxlbmd0aCB0MSA9IGxlbmd0aCB0MiAmJiBmb3JfYWxsMl9sb2NhbF9leG4gdDEgdDIgfmY6ZXF1YWxcbmxldCBlcXVhbCBlcXVhbCB0MSB0MiA9IGVxdWFsX19sb2NhbCBlcXVhbCB0MSB0MlxuXG5sZXQgbWFwX2lucGxhY2UgdCB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHQgaSAoZiAodW5zYWZlX2dldCB0IGkpKVxuICBkb25lXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGZpbmRpX2ludGVybmFsIHQgfmYgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuZ3RoID0gMFxuICB0aGVuIGlmX25vdF9mb3VuZCAoKVxuICBlbHNlIChcbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGZvdW5kID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IHZhbHVlX2ZvdW5kID0gcmVmICh1bnNhZmVfZ2V0IHQgMCkgaW5cbiAgICB3aGlsZSAobm90ICFmb3VuZCkgJiYgIWkgPCBsZW5ndGggZG9cbiAgICAgIGxldCB2YWx1ZSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgaWYgZiAhaSB2YWx1ZVxuICAgICAgdGhlbiAoXG4gICAgICAgIHZhbHVlX2ZvdW5kIDo9IHZhbHVlO1xuICAgICAgICBmb3VuZCA6PSB0cnVlKVxuICAgICAgZWxzZSBpbmNyIGlcbiAgICBkb25lO1xuICAgIGlmICFmb3VuZCB0aGVuIGlmX2ZvdW5kIH5pOiFpIH52YWx1ZTohdmFsdWVfZm91bmQgZWxzZSBpZl9ub3RfZm91bmQgKCkpXG47O1xuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGZpbmRpX2ludGVybmFsXG4gICAgdFxuICAgIH5mXG4gICAgfmlmX2ZvdW5kOihmdW4gfmkgfnZhbHVlIC0+IFNvbWUgKGksIHZhbHVlKSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4gKCkgLT4gTm9uZSlcbjs7XG5cbmxldCBmaW5kaV9leG4gdCB+ZiA9XG4gIGZpbmRpX2ludGVybmFsXG4gICAgdFxuICAgIH5mXG4gICAgfmlmX2ZvdW5kOihmdW4gfmkgfnZhbHVlIC0+IGksIHZhbHVlKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biAoKSAtPiByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJBcnJheS5maW5kaV9leG46IG5vdCBmb3VuZFwiKSkpXG47O1xuXG5sZXQgZmluZF9leG4gdCB+ZiA9XG4gIGZpbmRpX2ludGVybmFsXG4gICAgdFxuICAgIH5mOihmdW4gX2kgeCAtPiBmIHgpXG4gICAgfmlmX2ZvdW5kOihmdW4gfmk6XyB+dmFsdWUgLT4gdmFsdWUpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuICgpIC0+IHJhaXNlIChOb3RfZm91bmRfcyAoQXRvbSBcIkFycmF5LmZpbmRfZXhuOiBub3QgZm91bmRcIikpKVxuICBbQG5vbnRhaWxdXG47O1xuXG5sZXQgZmluZCB0IH5mID0gT3B0aW9uLm1hcCAoZmluZGkgdCB+ZjooZnVuIF9pIHggLT4gZiB4KSkgfmY6KGZ1biAoX2ksIHgpIC0+IHgpXG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgTm9uZSBpblxuICAgIHdoaWxlIE9wdGlvbi5pc19ub25lICF2YWx1ZV9mb3VuZCAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICB2YWx1ZV9mb3VuZCA6PSBmIHZhbHVlO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICAhdmFsdWVfZm91bmQpXG47O1xuXG5sZXQgZmluZF9tYXBfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZF9tYXBfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcCB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfbWFwX2V4blxuOztcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgTm9uZSBpblxuICAgIHdoaWxlIE9wdGlvbi5pc19ub25lICF2YWx1ZV9mb3VuZCAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICB2YWx1ZV9mb3VuZCA6PSBmICFpIHZhbHVlO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICAhdmFsdWVfZm91bmQpXG47O1xuXG5sZXQgZmluZF9tYXBpX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkFycmF5LmZpbmRfbWFwaV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBpX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcGkgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX21hcGlfZXhuXG47O1xuXG5sZXQgZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUgdCB+ZXF1YWwgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGlmIG4gPD0gMVxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHJlc3VsdCA9IHJlZiBOb25lIGluXG4gICAgbGV0IGkgPSByZWYgMSBpblxuICAgIGxldCBwcmV2ID0gcmVmICh1bnNhZmVfZ2V0IHQgMCkgaW5cbiAgICB3aGlsZSAhaSA8IG4gZG9cbiAgICAgIGxldCBjdXIgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIGlmIGVxdWFsIGN1ciAhcHJldlxuICAgICAgdGhlbiAoXG4gICAgICAgIHJlc3VsdCA6PSBTb21lICghcHJldiwgY3VyKTtcbiAgICAgICAgaSA6PSBuKVxuICAgICAgZWxzZSAoXG4gICAgICAgIHByZXYgOj0gY3VyO1xuICAgICAgICBpbmNyIGkpXG4gICAgZG9uZTtcbiAgICAhcmVzdWx0KVxuOztcblxubGV0IHJlZHVjZSB0IH5mID1cbiAgaWYgbGVuZ3RoIHQgPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgciA9IHJlZiAodW5zYWZlX2dldCB0IDApIGluXG4gICAgZm9yIGkgPSAxIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IHQgaSlcbiAgICBkb25lO1xuICAgIFNvbWUgIXIpXG47O1xuXG5sZXQgcmVkdWNlX2V4biB0IH5mID1cbiAgbWF0Y2ggcmVkdWNlIHQgfmYgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJBcnJheS5yZWR1Y2VfZXhuXCJcbiAgfCBTb21lIHYgLT4gdlxuOztcblxubGV0IHBlcm11dGUgPSBBcnJheV9wZXJtdXRlLnBlcm11dGVcblxubGV0IHJhbmRvbV9lbGVtZW50X2V4biA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSB0ID1cbiAgaWYgaXNfZW1wdHkgdFxuICB0aGVuIGZhaWx3aXRoIFwiQXJyYXkucmFuZG9tX2VsZW1lbnRfZXhuOiBlbXB0eSBhcnJheVwiXG4gIGVsc2UgdC4oUmFuZG9tLlN0YXRlLmludCByYW5kb21fc3RhdGUgKGxlbmd0aCB0KSlcbjs7XG5cbmxldCByYW5kb21fZWxlbWVudCA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSB0ID1cbiAgdHJ5IFNvbWUgKHJhbmRvbV9lbGVtZW50X2V4biB+cmFuZG9tX3N0YXRlIHQpIHdpdGhcbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCB6aXAgdDEgdDIgPVxuICBpZiBsZW5ndGggdDEgPD4gbGVuZ3RoIHQyIHRoZW4gTm9uZSBlbHNlIFNvbWUgKG1hcDJfZXhuIHQxIHQyIH5mOihmdW4geDEgeDIgLT4geDEsIHgyKSlcbjs7XG5cbmxldCB6aXBfZXhuIHQxIHQyID1cbiAgaWYgbGVuZ3RoIHQxIDw+IGxlbmd0aCB0MlxuICB0aGVuIGZhaWx3aXRoIFwiQXJyYXkuemlwX2V4blwiXG4gIGVsc2UgbWFwMl9leG4gdDEgdDIgfmY6KGZ1biB4MSB4MiAtPiB4MSwgeDIpXG47O1xuXG5sZXQgdW56aXAgdCA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiBbfHxdLCBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCB4LCB5ID0gdC4oMCkgaW5cbiAgICBsZXQgcmVzMSA9IGNyZWF0ZSB+bGVuOm4geCBpblxuICAgIGxldCByZXMyID0gY3JlYXRlIH5sZW46biB5IGluXG4gICAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgICBsZXQgeCwgeSA9IHQuKGkpIGluXG4gICAgICByZXMxLihpKSA8LSB4O1xuICAgICAgcmVzMi4oaSkgPC0geVxuICAgIGRvbmU7XG4gICAgcmVzMSwgcmVzMilcbjs7XG5cbmxldCBzb3J0ZWRfY29weSB0IH5jb21wYXJlID1cbiAgbGV0IHQxID0gY29weSB0IGluXG4gIHNvcnQgdDEgfmNvbXBhcmU7XG4gIHQxXG47O1xuXG5sZXQgcGFydGl0aW9uX21hcGkgdCB+ZiA9XG4gIGxldCAoYm90aCA6IF8gRWl0aGVyLnQgdCkgPSBtYXBpIHQgfmYgaW5cbiAgbGV0IGZpcnN0cyA9XG4gICAgZmlsdGVyX21hcCBib3RoIH5mOihmdW5jdGlvblxuICAgICAgfCBGaXJzdCB4IC0+IFNvbWUgeFxuICAgICAgfCBTZWNvbmQgXyAtPiBOb25lKVxuICBpblxuICBsZXQgc2Vjb25kcyA9XG4gICAgZmlsdGVyX21hcCBib3RoIH5mOihmdW5jdGlvblxuICAgICAgfCBGaXJzdCBfIC0+IE5vbmVcbiAgICAgIHwgU2Vjb25kIHggLT4gU29tZSB4KVxuICBpblxuICBmaXJzdHMsIHNlY29uZHNcbjs7XG5cbmxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPVxuICBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gRmlyc3QgeCBlbHNlIFNlY29uZCB4KSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcGFydGl0aW9uX21hcCB0IH5mID0gcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIF8geCAtPiBmIHgpIFtAbm9udGFpbF1cbmxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IHBhcnRpdGlvbmlfdGYgdCB+ZjooZnVuIF8geCAtPiBmIHgpIFtAbm9udGFpbF1cbmxldCBsYXN0IHQgPSB0LihsZW5ndGggdCAtIDEpXG5cbigqIENvbnZlcnQgdG8gYSBzZXF1ZW5jZSBidXQgZG9lcyBub3QgYXR0ZW1wdCB0byBwcm90ZWN0IGFnYWluc3QgbW9kaWZpY2F0aW9uXG4gICBpbiB0aGUgYXJyYXkuICopXG5sZXQgdG9fc2VxdWVuY2VfbXV0YWJsZSB0ID1cbiAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQ6MCB+ZjooZnVuIGkgLT5cbiAgICBpZiBpID49IGxlbmd0aCB0XG4gICAgdGhlbiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICBlbHNlIFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IHQuKGkpOyBzdGF0ZSA9IGkgKyAxIH0pXG47O1xuXG5sZXQgdG9fc2VxdWVuY2UgdCA9IHRvX3NlcXVlbmNlX211dGFibGUgKGNvcHkgdClcblxubGV0IGNhcnRlc2lhbl9wcm9kdWN0IHQxIHQyID1cbiAgaWYgaXNfZW1wdHkgdDEgfHwgaXNfZW1wdHkgdDJcbiAgdGhlbiBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCBuMSA9IGxlbmd0aCB0MSBpblxuICAgIGxldCBuMiA9IGxlbmd0aCB0MiBpblxuICAgIGxldCB0ID0gY3JlYXRlIH5sZW46KG4xICogbjIpICh0MS4oMCksIHQyLigwKSkgaW5cbiAgICBsZXQgciA9IHJlZiAwIGluXG4gICAgZm9yIGkxID0gMCB0byBuMSAtIDEgZG9cbiAgICAgIGZvciBpMiA9IDAgdG8gbjIgLSAxIGRvXG4gICAgICAgIHQuKCFyKSA8LSB0MS4oaTEpLCB0Mi4oaTIpO1xuICAgICAgICBpbmNyIHJcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIHQpXG47O1xuXG5sZXQgdHJhbnNwb3NlIHR0ID1cbiAgaWYgbGVuZ3RoIHR0ID0gMFxuICB0aGVuIFNvbWUgW3x8XVxuICBlbHNlIChcbiAgICBsZXQgd2lkdGggPSBsZW5ndGggdHQgaW5cbiAgICBsZXQgZGVwdGggPSBsZW5ndGggdHQuKDApIGluXG4gICAgaWYgZXhpc3RzIHR0IH5mOihmdW4gdCAtPiBsZW5ndGggdCA8PiBkZXB0aClcbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIFNvbWUgKGluaXQgZGVwdGggfmY6KGZ1biBkIC0+IGluaXQgd2lkdGggfmY6KGZ1biB3IC0+IHR0Lih3KS4oZCkpKSkpXG47O1xuXG5sZXQgdHJhbnNwb3NlX2V4biB0dCA9XG4gIG1hdGNoIHRyYW5zcG9zZSB0dCB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIkFycmF5LnRyYW5zcG9zZV9leG5cIlxuICB8IFNvbWUgdHQnIC0+IHR0J1xuOztcblxuaW5jbHVkZSBCaW5hcnlfc2VhcmNoYWJsZS5NYWtlMSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IGdldCA9IGdldFxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG5lbmQpXG5cbmluY2x1ZGUgQmxpdC5NYWtlMSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuXG4gIGxldCBjcmVhdGVfbGlrZSB+bGVuIHQgPVxuICAgIGlmIGxlbiA9IDBcbiAgICB0aGVuIFt8fF1cbiAgICBlbHNlIChcbiAgICAgIGFzc2VydCAobGVuZ3RoIHQgPiAwKTtcbiAgICAgIGNyZWF0ZSB+bGVuIHQuKDApKVxuICA7O1xuXG4gIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG5lbmQpXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9IGl0ZXIgdCB+ZjppbnZhcmlhbnRfYVxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgU29ydCA9IFNvcnRcbiAgbW9kdWxlIFNvcnRlciA9IFNvcnRlclxuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBjZWlsID0gU3RkbGliLmNlaWxcbmxldCBmbG9vciA9IFN0ZGxpYi5mbG9vclxubGV0IG1vZF9mbG9hdCA9IFN0ZGxpYi5tb2RfZmxvYXRcbmxldCBtb2RmID0gU3RkbGliLm1vZGZcbmxldCBmbG9hdF9vZl9zdHJpbmcgPSBTdGRsaWIuZmxvYXRfb2Zfc3RyaW5nXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCA9IFN0ZGxpYi5mbG9hdF9vZl9zdHJpbmdfb3B0XG5sZXQgbmFuID0gU3RkbGliLm5hblxubGV0IGluZmluaXR5ID0gU3RkbGliLmluZmluaXR5XG5sZXQgbmVnX2luZmluaXR5ID0gU3RkbGliLm5lZ19pbmZpbml0eVxubGV0IG1heF9maW5pdGVfdmFsdWUgPSBTdGRsaWIubWF4X2Zsb2F0XG5sZXQgZXBzaWxvbl9mbG9hdCA9IFN0ZGxpYi5lcHNpbG9uX2Zsb2F0XG5sZXQgY2xhc3NpZnlfZmxvYXQgPSBTdGRsaWIuY2xhc3NpZnlfZmxvYXRcbmxldCBhYnNfZmxvYXQgPSBTdGRsaWIuYWJzX2Zsb2F0XG5sZXQgaXNfaW50ZWdlciA9IFN0ZGxpYi5GbG9hdC5pc19pbnRlZ2VyXG5sZXQgKCAqKiApID0gU3RkbGliLiggKiogKVxuXG5sZXQgKCAlLiApIGEgYiA9XG4gICgqIFJhaXNlIGluIGNhc2Ugb2YgYSBuZWdhdGl2ZSBtb2R1bHVzLCBhcyBkb2VzIEludC4oICUgKS4gKilcbiAgaWYgYiA8IDAuXG4gIHRoZW4gUHJpbnRmLmludmFsaWRfYXJnZiBcIiVmICUlICVmIGluIGZsb2F0MC5tbDogbW9kdWx1cyBzaG91bGQgYmUgcG9zaXRpdmVcIiBhIGIgKCk7XG4gIGxldCBtID0gU3RkbGliLm1vZF9mbG9hdCBhIGIgaW5cbiAgKCogUHJvZHVjZSBhIG5vbi1uZWdhdGl2ZSByZXN1bHQgaW4gYW5hbG9neSB3aXRoIEludC4oICUgKS4gKilcbiAgaWYgbSA8IDAuIHRoZW4gbSArLiBiIGVsc2UgbVxuOztcblxuKCogVGhlIGJpdHMgb2YgSU5SSUEncyBbU3RkbGliXSB0aGF0IHdlIGp1c3Qgd2FudCB0byBleHBvc2UgaW4gW0Zsb2F0XS4gTW9zdCBhcmVcbiAgIGFscmVhZHkgZGVwcmVjYXRlZCBpbiBbU3RkbGliXSwgYW5kIGV2ZW50dWFsbHkgYWxsIG9mIHRoZW0gc2hvdWxkIGJlLiAqKVxuaW5jbHVkZSAoXG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgU3RkbGliXG4gICAgaW5jbHVkZSBTdGRsaWIuRmxvYXRcbiAgZW5kIDpcbiAgICBzaWdcbiAgICAgIGV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuXG4gICAgICBleHRlcm5hbCBsZGV4cFxuICAgICAgICA6ICAoZmxvYXRbQHVuYm94ZWRdKVxuICAgICAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgICAgIC0+IChmbG9hdFtAdW5ib3hlZF0pXG4gICAgICAgID0gXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIlxuICAgICAgICBbQEBub2FsbG9jXVxuXG4gICAgICBleHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICAgIGV4dGVybmFsIGxvZzIgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cyX2Zsb2F0XCIgXCJjYW1sX2xvZzJcIlxuICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgICBleHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgICAgZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICAgIGV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgICBleHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgICBleHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICAgIGV4dGVybmFsIGFjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc2hfZmxvYXRcIiBcImNhbWxfYWNvc2hcIlxuICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgICBleHRlcm5hbCBhc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5oX2Zsb2F0XCIgXCJjYW1sX2FzaW5oXCJcbiAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgICAgZXh0ZXJuYWwgYXRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuaF9mbG9hdFwiIFwiY2FtbF9hdGFuaFwiXG4gICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICAgIGV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgICAgZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiXG4gICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICAgIGV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICAgIGV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICAgIGV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICAgIGV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICAgIGV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICAgIGV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBlbmQpXG5cbigqIFdlIG5lZWQgdGhpcyBpbmRpcmVjdGlvbiBiZWNhdXNlIHRoZXNlIGFyZSBleHBvc2VkIGFzIFwidmFsXCIgaW5zdGVhZCBvZiBcImV4dGVybmFsXCIgKilcbmxldCBmcmV4cCA9IGZyZXhwXG5sZXQgbGRleHAgPSBsZGV4cFxubGV0IGlzX25hbiB4ID0gKHggOiBmbG9hdCkgPD4geFxuXG4oKiBBbiBvcmRlci1wcmVzZXJ2aW5nIGJpamVjdGlvbiBiZXR3ZWVuIGFsbCBmbG9hdHMgZXhjZXB0IGZvciBOYU5zLCBhbmQgOTkuOTUlIG9mXG4gICBpbnQ2NHMuXG5cbiAgIE5vdGUgd2UgZG9uJ3QgZGlzdGluZ3Vpc2ggMC4gYW5kIC0wLiBhcyBzZXBhcmF0ZSB2YWx1ZXMgaGVyZSwgdGhleSBib3RoIG1hcCB0byAwTCwgd2hpY2hcbiAgIG1hcHMgYmFjayB0byAwLlxuXG4gICBUaGlzIHNob3VsZCB3b3JrIGJvdGggb24gbGl0dGxlLWVuZGlhbiBhbmQgaGlnaC1lbmRpYW4gQ1BVcy4gIFdpa2lwZWRpYSBzYXlzOiBcIm9uXG4gICBtb2Rlcm4gc3RhbmRhcmQgY29tcHV0ZXJzIChpLmUuLCBpbXBsZW1lbnRpbmcgSUVFRSA3NTQpLCBvbmUgbWF5IGluIHByYWN0aWNlIHNhZmVseVxuICAgYXNzdW1lIHRoYXQgdGhlIGVuZGlhbm5lc3MgaXMgdGhlIHNhbWUgZm9yIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgYXMgZm9yIGludGVnZXJzXCJcbiAgIChodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VuZGlhbm5lc3MjRmxvYXRpbmctcG9pbnRfYW5kX2VuZGlhbm5lc3MpLlxuKilcbmxldCB0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB0ID1cbiAgaWYgaXNfbmFuIHRcbiAgdGhlbiBOb25lXG4gIGVsc2UgaWYgdCA9IDAuXG4gIHRoZW4gKCogYWxzbyBpbmNsdWRlcyAtMC4gKilcbiAgICBTb21lIDBMXG4gIGVsc2UgaWYgdCA+IDAuXG4gIHRoZW4gU29tZSAoU3RkbGliLkludDY0LmJpdHNfb2ZfZmxvYXQgdClcbiAgZWxzZSBTb21lIChTdGRsaWIuSW50NjQubmVnIChTdGRsaWIuSW50NjQuYml0c19vZl9mbG9hdCAoLS50KSkpXG47O1xuXG5sZXQgdG9faW50NjRfcHJlc2VydmVfb3JkZXJfZXhuIHggPSBPcHRpb24udmFsdWVfZXhuICh0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB4KVxuXG5sZXQgb2ZfaW50NjRfcHJlc2VydmVfb3JkZXIgeCA9XG4gIGlmIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgeCAwTFxuICB0aGVuIFN0ZGxpYi5JbnQ2NC5mbG9hdF9vZl9iaXRzIHhcbiAgZWxzZSB+LS4oU3RkbGliLkludDY0LmZsb2F0X29mX2JpdHMgKFN0ZGxpYi5JbnQ2NC5uZWcgeCkpXG47O1xuXG5sZXQgb25lX3VscCBkaXIgdCA9XG4gIG1hdGNoIHRvX2ludDY0X3ByZXNlcnZlX29yZGVyIHQgd2l0aFxuICB8IE5vbmUgLT4gU3RkbGliLm5hblxuICB8IFNvbWUgeCAtPlxuICAgIG9mX2ludDY0X3ByZXNlcnZlX29yZGVyXG4gICAgICAoU3RkbGliLkludDY0LmFkZFxuICAgICAgICAgeFxuICAgICAgICAgKG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgfCBgVXAgLT4gMUxcbiAgICAgICAgICB8IGBEb3duIC0+IC0xTCkpXG47O1xuXG4oKiBbdXBwZXJfYm91bmRfZm9yX2ludF0gYW5kIFtsb3dlcl9ib3VuZF9mb3JfaW50XSBhcmUgZm9yIGNhbGN1bGF0aW5nIHRoZSBtYXgvbWluIGZsb2F0XG4gICB0aGF0IGZpdHMgaW4gYSBnaXZlbi1zaXplIGludGVnZXIgd2hlbiByb3VuZGVkIHRvd2FyZHMgMCAodXNpbmcgW2ludF9vZl9mbG9hdF0pLlxuXG4gICBtYXhfaW50L21pbl9pbnQgZGVwZW5kIG9uIFtudW1fYml0c10sIGUuZy4gKy8tIDJeMzAsICsvLSAyXjYyIGlmIDMxLWJpdCwgNjMtYml0XG4gICAocmVzcGVjdGl2ZWx5KSB3aGlsZSBmbG9hdCBpcyBJRUVFIHN0YW5kYXJkIGZvciBkb3VibGUgKDUyIHNpZ25pZmljYW50IGJpdHMpLlxuXG4gICBJbiBhbGwgY2FzZXMsIHdlIHdhbnQgdG8gZ3VhcmFudGVlIHRoYXRcbiAgIFtsb3dlcl9ib3VuZF9mb3JfaW50IDw9IHggPD0gdXBwZXJfYm91bmRfZm9yX2ludF1cbiAgIGlmZiBbaW50X29mX2Zsb2F0IHhdIGZpdHMgaW4gYW4gaW50IHdpdGggW251bV9iaXRzXSBiaXRzLlxuXG4gICBbMiAqKiAobnVtX2JpdHMgLSAxKV0gaXMgdGhlIGZpcnN0IGZsb2F0IGdyZWF0ZXIgdGhhdCBtYXhfaW50LCB3ZSB1c2UgdGhlIHByZWNlZGluZ1xuICAgZmxvYXQgYXMgdXBwZXIgYm91bmQuXG5cbiAgIFstICgyICoqIChudW1fYml0cyAtIDEpKV0gaXMgZXF1YWwgdG8gbWluX2ludC5cbiAgIEZvciBsb3dlciBib3VuZCB3ZSBsb29rIGZvciB0aGUgc21hbGxlc3QgZmxvYXQgW2ZdIHNhdGlzZnlpbmcgW2YgPiBtaW5faW50IC0gMV0gc28gdGhhdFxuICAgW2ZdIHJvdW5kcyB0b3dhcmQgemVybyB0byBbbWluX2ludF1cblxuICAgU28gaW4gcGFydGljdWxhciB3ZSB3aWxsIGhhdmU6XG4gICBbbG93ZXJfYm91bmRfZm9yX2ludCB4IDw9IC0gKDIgKiogKDEteCkpXVxuICAgW3VwcGVyX2JvdW5kX2Zvcl9pbnQgeCAgPCAgICAyICoqICgxLXgpIF1cbiopXG5sZXQgdXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0cyA9XG4gIGxldCBleHAgPSBTdGRsaWIuZmxvYXRfb2ZfaW50IChudW1fYml0cyAtIDEpIGluXG4gIG9uZV91bHAgYERvd24gKDIuICoqIGV4cClcbjs7XG5cbmxldCBpc194X21pbnVzX29uZV9leGFjdCB4ID1cbiAgKCogW3ggPSB4IC0uIDEuXSBkb2VzIG5vdCB3b3JrIHdpdGggeDg3IGZsb2F0aW5nIHBvaW50IGFyaXRobWV0aWMgYmFja2VuZCAod2hpY2ggaXMgdXNlZFxuICAgICBvbiAzMi1iaXQgb2NhbWwpIGJlY2F1c2Ugb2YgODAtYml0IHJlZ2lzdGVyIHByZWNpc2lvbiBvZiBpbnRlcm1lZGlhdGUgY29tcHV0YXRpb25zLlxuXG4gICAgIEFuIGFsdGVybmF0aXZlIHdheSBvZiBjb21wdXRpbmcgdGhpczogW3ggLS4gb25lX3VscCBgRG93biB4IDw9IDEuXSBpcyBhbHNvIHByb25lIHRvXG4gICAgIHRoZSBzYW1lIHByZWNpc2lvbiBpc3N1ZXM6IHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSBbeF0gaXMgNjQtYml0LlxuICAqKVxuICBsZXQgb3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgbm90IChTdGRsaWIuSW50NjQuYml0c19vZl9mbG9hdCB4ID0gU3RkbGliLkludDY0LmJpdHNfb2ZfZmxvYXQgKHggLS4gMS4pKVxuOztcblxubGV0IGxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHMgPVxuICBsZXQgZXhwID0gU3RkbGliLmZsb2F0X29mX2ludCAobnVtX2JpdHMgLSAxKSBpblxuICBsZXQgbWluX2ludF9hc19mbG9hdCA9IH4tLigyLiAqKiBleHApIGluXG4gIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgaWYgbnVtX2JpdHMgLSAxIDwgNTMgKCogNTMgPSAjYml0cyBpbiB0aGUgZmxvYXQncyBtYW50aXNzYSB3aXRoIHNpZ24gaW5jbHVkZWQgKilcbiAgdGhlbiAoXG4gICAgKCogVGhlIHNtYWxsZXN0IGZsb2F0IHRoYXQgcm91bmRzIHRvd2FyZHMgemVybyB0byBbbWluX2ludF0gaXNcbiAgICAgICBbbWluX2ludCAtIDEgKyBlcHNpbG9uXSAqKVxuICAgIGFzc2VydCAoaXNfeF9taW51c19vbmVfZXhhY3QgbWluX2ludF9hc19mbG9hdCk7XG4gICAgb25lX3VscCBgVXAgKG1pbl9pbnRfYXNfZmxvYXQgLS4gMS4pKVxuICBlbHNlIChcbiAgICAoKiBbbWluX2ludF9hc19mbG9hdF0gaXMgYWxyZWFkeSB0aGUgc21hbGxlc3QgZmxvYXQgW2ZdIHNhdGlzZnlpbmcgW2YgPiBtaW5faW50IC0gMV0uICopXG4gICAgYXNzZXJ0IChub3QgKGlzX3hfbWludXNfb25lX2V4YWN0IG1pbl9pbnRfYXNfZmxvYXQpKTtcbiAgICBtaW5faW50X2FzX2Zsb2F0KVxuOztcblxuKCogWDg2IGRvY3Mgc2F5OlxuXG4gICBJZiBvbmx5IG9uZSB2YWx1ZSBpcyBhIE5hTiAoU05hTiBvciBRTmFOKSBmb3IgdGhpcyBpbnN0cnVjdGlvbiwgdGhlIHNlY29uZCBzb3VyY2VcbiAgIG9wZXJhbmQsIGVpdGhlciBhIE5hTiBvciBhIHZhbGlkIGZsb2F0aW5nLXBvaW50IHZhbHVlXG4gICBpcyB3cml0dGVuIHRvIHRoZSByZXN1bHQuXG5cbiAgIFNvIHdlIGhhdmUgdG8gYmUgVkVSWSBjYXJlZnVsIGhvdyB3ZSB1c2UgdGhlc2UhXG5cbiAgIFRoZXNlIGludHJpbnNpY3Mgd2VyZSBjb3BpZWQgZnJvbSBbT2NhbWxfaW50cmluc2ljc10gdG8gYXZvaWQgYnVpbGQgZGVwcyB3ZSBkb24ndCB3YW50XG4qKVxubW9kdWxlIEludHJpbnNpY3Nfd2l0aF93ZWlyZF9uYW5fYmVoYXZpb3IgPSBzdHJ1Y3RcbiAgbGV0W0BpbmxpbmUgYWx3YXlzXSBtaW4gYSBiID0gT2NhbWxfaW50cmluc2ljc19rZXJuZWwuRmxvYXQubWluIGEgYlxuICBsZXRbQGlubGluZSBhbHdheXNdIG1heCBhIGIgPSBPY2FtbF9pbnRyaW5zaWNzX2tlcm5lbC5GbG9hdC5tYXggYSBiXG5lbmRcblxubGV0IGNsYW1wX3VuY2hlY2tlZFxuICB+KHRvX2NsYW1wX21heWJlX25hbiA6IGZsb2F0KVxuICB+bWluX3doaWNoX2lzX25vdF9uYW5cbiAgfm1heF93aGljaF9pc19ub3RfbmFuXG4gID1cbiAgKCogV2Ugd2FudCB0byBwcm9wYWdhdGUgbmFuczsgYXMgcGVyIHRoZSB4ODYgZG9jcywgdGhpcyBtZWFucyB3ZSBoYXZlIHRvIHVzZSB0aGVtIGFzIHRoZVxuICAgICBfc2Vjb25kXyBhcmd1bWVudC4gKilcbiAgbGV0IHRfbWF5YmVfbmFuID1cbiAgICBJbnRyaW5zaWNzX3dpdGhfd2VpcmRfbmFuX2JlaGF2aW9yLm1heCBtaW5fd2hpY2hfaXNfbm90X25hbiB0b19jbGFtcF9tYXliZV9uYW5cbiAgaW5cbiAgSW50cmluc2ljc193aXRoX3dlaXJkX25hbl9iZWhhdmlvci5taW4gbWF4X3doaWNoX2lzX25vdF9uYW4gdF9tYXliZV9uYW5cbjs7XG5cbmxldCBib3ggPVxuICAoKiBQcmV2ZW50IHBvdGVudGlhbCBjb25zdGFudCBmb2xkaW5nIG9mIFsrLiAwLl0gaW4gdGhlIG5lYXIgb2NhbWxvcHQgZnV0dXJlLiAqKVxuICBsZXQgeCA9IFN5czAub3BhcXVlX2lkZW50aXR5IDAuIGluXG4gIGZ1biBmIC0+IGYgKy4geFxuOztcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwiKCogVGhpcyBmaWxlIHdhcyBhdXRvZ2VuZXJhdGVkIGJ5IC4uL2dlbmVyYXRlL2dlbmVyYXRlX3Bvd19vdmVyZmxvd19ib3VuZHMuZXhlICopXG5cbm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5cbigqIFdlIGhhdmUgdG8gdXNlIEludDY0LnRvX2ludF9leG4gaW5zdGVhZCBvZiBpbnQgY29uc3RhbnRzIHRvIG1ha2VcbiAgIHN1cmUgdGhhdCBmaWxlIGNhbiBiZSBwcmVwcm9jZXNzZWQgb24gMzItYml0IG1hY2hpbmVzLiAqKVxuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludDMyX3ZhbHVlIDogaW50MzIgPSAyMTQ3NDgzNjQ3bFxuXG5sZXQgaW50MzJfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50MzIgYXJyYXkgPVxuICBbfCAyMTQ3NDgzNjQ3bFxuICAgOyAyMTQ3NDgzNjQ3bFxuICAgOyA0NjM0MGxcbiAgIDsgMTI5MGxcbiAgIDsgMjE1bFxuICAgOyA3M2xcbiAgIDsgMzVsXG4gICA7IDIxbFxuICAgOyAxNGxcbiAgIDsgMTBsXG4gICA7IDhsXG4gICA7IDdsXG4gICA7IDVsXG4gICA7IDVsXG4gICA7IDRsXG4gICA7IDRsXG4gICA7IDNsXG4gICA7IDNsXG4gICA7IDNsXG4gICA7IDNsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDJsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gICA7IDFsXG4gIHxdXG47O1xuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludF92YWx1ZSA6IGludCA9IC0xIGxzciAxXG5cbmxldCBpbnRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50IGFycmF5ID1cbiAgbWF0Y2ggSW50X2NvbnZlcnNpb25zLm51bV9iaXRzX2ludCB3aXRoXG4gIHwgMzIgLT4gQXJyYXkubWFwIGludDMyX3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyB+ZjpTdGRsaWIuSW50MzIudG9faW50XG4gIHwgNjMgLT5cbiAgICBbfCBTdGRsaWIuSW50NjQudG9faW50IDQ2MTE2ODYwMTg0MjczODc5MDNMXG4gICAgIDsgU3RkbGliLkludDY0LnRvX2ludCA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICAgICA7IFN0ZGxpYi5JbnQ2NC50b19pbnQgMjE0NzQ4MzY0N0xcbiAgICAgOyAxNjY0NTEwXG4gICAgIDsgNDYzNDBcbiAgICAgOyA1NDA0XG4gICAgIDsgMTI5MFxuICAgICA7IDQ2M1xuICAgICA7IDIxNVxuICAgICA7IDExOFxuICAgICA7IDczXG4gICAgIDsgNDlcbiAgICAgOyAzNVxuICAgICA7IDI3XG4gICAgIDsgMjFcbiAgICAgOyAxN1xuICAgICA7IDE0XG4gICAgIDsgMTJcbiAgICAgOyAxMFxuICAgICA7IDlcbiAgICAgOyA4XG4gICAgIDsgN1xuICAgICA7IDdcbiAgICAgOyA2XG4gICAgIDsgNVxuICAgICA7IDVcbiAgICAgOyA1XG4gICAgIDsgNFxuICAgICA7IDRcbiAgICAgOyA0XG4gICAgIDsgNFxuICAgICA7IDNcbiAgICAgOyAzXG4gICAgIDsgM1xuICAgICA7IDNcbiAgICAgOyAzXG4gICAgIDsgM1xuICAgICA7IDNcbiAgICAgOyAzXG4gICAgIDsgM1xuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgIHxdXG4gIHwgMzEgLT5cbiAgICBbfCAxMDczNzQxODIzXG4gICAgIDsgMTA3Mzc0MTgyM1xuICAgICA7IDMyNzY3XG4gICAgIDsgMTAyM1xuICAgICA7IDE4MVxuICAgICA7IDYzXG4gICAgIDsgMzFcbiAgICAgOyAxOVxuICAgICA7IDEzXG4gICAgIDsgMTBcbiAgICAgOyA3XG4gICAgIDsgNlxuICAgICA7IDVcbiAgICAgOyA0XG4gICAgIDsgNFxuICAgICA7IDNcbiAgICAgOyAzXG4gICAgIDsgM1xuICAgICA7IDNcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDJcbiAgICAgOyAyXG4gICAgIDsgMlxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICAgOyAxXG4gICAgIDsgMVxuICAgICA7IDFcbiAgICB8XVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludDYzX29uX2ludDY0X3ZhbHVlIDogaW50NjQgPSA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuXG5sZXQgaW50NjNfb25faW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50NjQgYXJyYXkgPVxuICBbfCA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICAgOyA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICAgOyAyMTQ3NDgzNjQ3TFxuICAgOyAxNjY0NTEwTFxuICAgOyA0NjM0MExcbiAgIDsgNTQwNExcbiAgIDsgMTI5MExcbiAgIDsgNDYzTFxuICAgOyAyMTVMXG4gICA7IDExOExcbiAgIDsgNzNMXG4gICA7IDQ5TFxuICAgOyAzNUxcbiAgIDsgMjdMXG4gICA7IDIxTFxuICAgOyAxN0xcbiAgIDsgMTRMXG4gICA7IDEyTFxuICAgOyAxMExcbiAgIDsgOUxcbiAgIDsgOExcbiAgIDsgN0xcbiAgIDsgN0xcbiAgIDsgNkxcbiAgIDsgNUxcbiAgIDsgNUxcbiAgIDsgNUxcbiAgIDsgNExcbiAgIDsgNExcbiAgIDsgNExcbiAgIDsgNExcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgM0xcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMkxcbiAgIDsgMUxcbiAgIDsgMUxcbiAgfF1cbjs7XG5cbmxldCBvdmVyZmxvd19ib3VuZF9tYXhfaW50NjRfdmFsdWUgOiBpbnQ2NCA9IDkyMjMzNzIwMzY4NTQ3NzU4MDdMXG5cbmxldCBpbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQ2NCBhcnJheSA9XG4gIFt8IDkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gICA7IDkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gICA7IDMwMzcwMDA0OTlMXG4gICA7IDIwOTcxNTFMXG4gICA7IDU1MTA4TFxuICAgOyA2MjA4TFxuICAgOyAxNDQ4TFxuICAgOyA1MTFMXG4gICA7IDIzNExcbiAgIDsgMTI3TFxuICAgOyA3OExcbiAgIDsgNTJMXG4gICA7IDM4TFxuICAgOyAyOExcbiAgIDsgMjJMXG4gICA7IDE4TFxuICAgOyAxNUxcbiAgIDsgMTNMXG4gICA7IDExTFxuICAgOyA5TFxuICAgOyA4TFxuICAgOyA3TFxuICAgOyA3TFxuICAgOyA2TFxuICAgOyA2TFxuICAgOyA1TFxuICAgOyA1TFxuICAgOyA1TFxuICAgOyA0TFxuICAgOyA0TFxuICAgOyA0TFxuICAgOyA0TFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAzTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAyTFxuICAgOyAxTFxuICB8XVxuOztcblxubGV0IGludDY0X25lZ2F0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDY0IGFycmF5ID1cbiAgW3wgLTkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gICA7IC05MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICAgOyAtMzAzNzAwMDQ5OUxcbiAgIDsgLTIwOTcxNTFMXG4gICA7IC01NTEwOExcbiAgIDsgLTYyMDhMXG4gICA7IC0xNDQ4TFxuICAgOyAtNTExTFxuICAgOyAtMjM0TFxuICAgOyAtMTI3TFxuICAgOyAtNzhMXG4gICA7IC01MkxcbiAgIDsgLTM4TFxuICAgOyAtMjhMXG4gICA7IC0yMkxcbiAgIDsgLTE4TFxuICAgOyAtMTVMXG4gICA7IC0xM0xcbiAgIDsgLTExTFxuICAgOyAtOUxcbiAgIDsgLThMXG4gICA7IC03TFxuICAgOyAtN0xcbiAgIDsgLTZMXG4gICA7IC02TFxuICAgOyAtNUxcbiAgIDsgLTVMXG4gICA7IC01TFxuICAgOyAtNExcbiAgIDsgLTRMXG4gICA7IC00TFxuICAgOyAtNExcbiAgIDsgLTNMXG4gICA7IC0zTFxuICAgOyAtM0xcbiAgIDsgLTNMXG4gICA7IC0zTFxuICAgOyAtM0xcbiAgIDsgLTNMXG4gICA7IC0zTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0yTFxuICAgOyAtMkxcbiAgIDsgLTJMXG4gICA7IC0xTFxuICB8XVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxubGV0IG5lZ2F0aXZlX2V4cG9uZW50ICgpID0gUHJpbnRmLmludmFsaWRfYXJnZiBcImV4cG9uZW50IGNhbiBub3QgYmUgbmVnYXRpdmVcIiAoKVxubGV0IG92ZXJmbG93ICgpID0gUHJpbnRmLmludmFsaWRfYXJnZiBcImludGVnZXIgb3ZlcmZsb3cgaW4gcG93XCIgKClcblxuKCogVG8gaW1wbGVtZW50IFtpbnQ2NF9wb3ddLCB3ZSB1c2UgQyBjb2RlIHJhdGhlciB0aGFuIE9DYW1sIHRvIGVsaW1pbmF0ZSBhbGxvY2F0aW9uLiAqKVxuZXh0ZXJuYWwgaW50X21hdGhfaW50X3BvdyA6IGludCAtPiBpbnQgLT4gaW50ID0gXCJCYXNlX2ludF9tYXRoX2ludF9wb3dfc3R1YlwiIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIGludF9tYXRoX2ludDY0X3Bvd1xuICA6ICBpbnQ2NFxuICAtPiBpbnQ2NFxuICAtPiBpbnQ2NFxuICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9wb3dfc3R1YlwiIFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9wb3dfc3R1Yl91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IGludF9wb3cgYmFzZSBleHBvbmVudCA9XG4gIGlmIGV4cG9uZW50IDwgMCB0aGVuIG5lZ2F0aXZlX2V4cG9uZW50ICgpO1xuICBpZiBhYnMgYmFzZSA+IDFcbiAgICAgJiYgKGV4cG9uZW50ID4gNjNcbiAgICAgICAgIHx8IGFicyBiYXNlID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzLihleHBvbmVudCkpXG4gIHRoZW4gb3ZlcmZsb3cgKCk7XG4gIGludF9tYXRoX2ludF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubW9kdWxlIEludDY0X3dpdGhfY29tcGFyaXNvbnMgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTdGRsaWIuSW50NjRcblxuICBleHRlcm5hbCAoIDwgKSA6IChpbnQ2NFtAbG9jYWxfb3B0XSkgLT4gKGludDY0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuICBleHRlcm5hbCAoID4gKSA6IChpbnQ2NFtAbG9jYWxfb3B0XSkgLT4gKGludDY0W0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuICBleHRlcm5hbCAoID49ICkgOiAoaW50NjRbQGxvY2FsX29wdF0pIC0+IChpbnQ2NFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5lbmRcblxuKCogd2UgZG9uJ3QgZG8gW2Fic10gaW4gaW50NjQgY2FzZSB0byBhdm9pZCBhbGxvY2F0aW9uICopXG5sZXQgaW50NjRfcG93IGJhc2UgZXhwb25lbnQgPVxuICBsZXQgb3BlbiBJbnQ2NF93aXRoX2NvbXBhcmlzb25zIGluXG4gIGlmIGV4cG9uZW50IDwgMEwgdGhlbiBuZWdhdGl2ZV9leHBvbmVudCAoKTtcbiAgaWYgKGJhc2UgPiAxTCB8fCBiYXNlIDwgLTFMKVxuICAgICAmJiAoZXhwb25lbnQgPiA2M0xcbiAgICAgICAgIHx8IChiYXNlID49IDBMXG4gICAgICAgICAgICAgJiYgYmFzZVxuICAgICAgICAgICAgICAgID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMuKHRvX2ludCBleHBvbmVudCkpXG4gICAgICAgICB8fCAoYmFzZSA8IDBMXG4gICAgICAgICAgICAgJiYgYmFzZVxuICAgICAgICAgICAgICAgIDwgUG93X292ZXJmbG93X2JvdW5kcy5pbnQ2NF9uZWdhdGl2ZV9vdmVyZmxvd19ib3VuZHMuKHRvX2ludCBleHBvbmVudCkpKVxuICB0aGVuIG92ZXJmbG93ICgpO1xuICBpbnRfbWF0aF9pbnQ2NF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubGV0IGludDYzX3Bvd19vbl9pbnQ2NCBiYXNlIGV4cG9uZW50ID1cbiAgbGV0IG9wZW4gSW50NjRfd2l0aF9jb21wYXJpc29ucyBpblxuICBpZiBleHBvbmVudCA8IDBMIHRoZW4gbmVnYXRpdmVfZXhwb25lbnQgKCk7XG4gIGlmIGFicyBiYXNlID4gMUxcbiAgICAgJiYgKGV4cG9uZW50ID4gNjNMXG4gICAgICAgICB8fCBhYnMgYmFzZVxuICAgICAgICAgICAgPiBQb3dfb3ZlcmZsb3dfYm91bmRzLmludDYzX29uX2ludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcy4odG9faW50IGV4cG9uZW50KVxuICAgICAgICApXG4gIHRoZW4gb3ZlcmZsb3cgKCk7XG4gIGludF9tYXRoX2ludDY0X3BvdyBiYXNlIGV4cG9uZW50XG47O1xuXG5tb2R1bGUgdHlwZSBNYWtlX2FyZyA9IHNpZ1xuICB0eXBlIHRcblxuICBpbmNsdWRlIEZsb2F0YWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBTdHJpbmdhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCAoICsgKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIC0gKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoICogKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIC8gKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIH4tICkgOiB0IC0+IHRcblxuICBpbmNsdWRlIENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgYWJzIDogdCAtPiB0XG4gIHZhbCBuZWcgOiB0IC0+IHRcbiAgdmFsIHplcm8gOiB0XG4gIHZhbCBvZl9pbnRfZXhuIDogaW50IC0+IHRcbiAgdmFsIHJlbSA6IHQgLT4gdCAtPiB0XG5lbmRcblxubW9kdWxlIE1ha2UgKFggOiBNYWtlX2FyZykgPSBzdHJ1Y3RcbiAgb3BlbiBYXG5cbiAgbGV0ICggJSApIHggeSA9XG4gICAgaWYgeSA8PSB6ZXJvXG4gICAgdGhlblxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiJXMgJSUgJXMgaW4gY29yZV9pbnQubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGxldCBydmFsID0gWC5yZW0geCB5IGluXG4gICAgaWYgcnZhbCA8IHplcm8gdGhlbiBydmFsICsgeSBlbHNlIHJ2YWxcbiAgOztcblxuICBsZXQgb25lID0gb2ZfaW50X2V4biAxXG5cbiAgbGV0ICggLyUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIiVzIC8lJSAlcyBpbiBjb3JlX2ludC5tbDogZGl2aXNvciBzaG91bGQgYmUgcG9zaXRpdmVcIlxuICAgICAgICAodG9fc3RyaW5nIHgpXG4gICAgICAgICh0b19zdHJpbmcgeSlcbiAgICAgICAgKCk7XG4gICAgaWYgeCA8IHplcm8gdGhlbiAoKHggKyBvbmUpIC8geSkgLSBvbmUgZWxzZSB4IC8geVxuICA7O1xuXG4gICgqKiBmbG9hdCBkaXZpc2lvbiBvZiBpbnRlZ2VycyAqKVxuICBsZXQgKCAvLyApIHggeSA9IHRvX2Zsb2F0IHggLy4gdG9fZmxvYXQgeVxuXG4gIGxldCByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mOm1vZHVsdXMgPSBpIC0gKGkgJSBtb2R1bHVzKVxuXG4gIGxldCByb3VuZF91cCBpIH50b19tdWx0aXBsZV9vZjptb2R1bHVzID1cbiAgICBsZXQgcmVtYWluZGVyID0gaSAlIG1vZHVsdXMgaW5cbiAgICBpZiByZW1haW5kZXIgPSB6ZXJvIHRoZW4gaSBlbHNlIGkgKyBtb2R1bHVzIC0gcmVtYWluZGVyXG4gIDs7XG5cbiAgbGV0IHJvdW5kX3Rvd2FyZHNfemVybyBpIH50b19tdWx0aXBsZV9vZiA9XG4gICAgaWYgaSA9IHplcm9cbiAgICB0aGVuIHplcm9cbiAgICBlbHNlIGlmIGkgPiB6ZXJvXG4gICAgdGhlbiByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mXG4gICAgZWxzZSByb3VuZF91cCBpIH50b19tdWx0aXBsZV9vZlxuICA7O1xuXG4gIGxldCByb3VuZF9uZWFyZXN0IGkgfnRvX211bHRpcGxlX29mOm1vZHVsdXMgPVxuICAgIGxldCByZW1haW5kZXIgPSBpICUgbW9kdWx1cyBpblxuICAgIGxldCBtb2R1bHVzX21pbnVzX3JlbWFpbmRlciA9IG1vZHVsdXMgLSByZW1haW5kZXIgaW5cbiAgICBpZiBtb2R1bHVzX21pbnVzX3JlbWFpbmRlciA8PSByZW1haW5kZXJcbiAgICB0aGVuIGkgKyBtb2R1bHVzX21pbnVzX3JlbWFpbmRlclxuICAgIGVsc2UgaSAtIHJlbWFpbmRlclxuICA7O1xuXG4gIGxldFtAaW5saW5lIGFsd2F5c10gcm91bmQgPyhkaXIgPSBgTmVhcmVzdCkgaSB+dG9fbXVsdGlwbGVfb2YgPVxuICAgIG1hdGNoIGRpciB3aXRoXG4gICAgfCBgTmVhcmVzdCAtPiByb3VuZF9uZWFyZXN0IGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgRG93biAtPiByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgVXAgLT4gcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2ZcbiAgICB8IGBaZXJvIC0+IHJvdW5kX3Rvd2FyZHNfemVybyBpIH50b19tdWx0aXBsZV9vZlxuICA7O1xuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBpbnRfcG93ID0gaW50X3Bvd1xuICBsZXQgaW50NjRfcG93ID0gaW50NjRfcG93XG4gIGxldCBpbnQ2M19wb3dfb25faW50NjQgPSBpbnQ2M19wb3dfb25faW50NjRcblxuICBtb2R1bGUgUG93X292ZXJmbG93X2JvdW5kcyA9IFBvd19vdmVyZmxvd19ib3VuZHNcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgdCA9ICdhXG5cbmxldCBzdGFnZSA9IEZuLmlkXG5sZXQgdW5zdGFnZSA9IEZuLmlkXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcbmluY2x1ZGUgQ2hhcjBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gY2hhciBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgZ2xvYmFsaXplLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9jaGFyIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2NoYXJcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2NoYXIgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgKGdsb2JhbGl6ZSA6IHQgLT4gdCkgPSAoZ2xvYmFsaXplX2NoYXIgOiB0IC0+IHQpXG4gIGxldCB0X29mX3NleHAgPSAoY2hhcl9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9jaGFyIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGNoYXJfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgdG9fc3RyaW5nIHQgPSBTdHJpbmcubWFrZSAxIHRcblxuICBsZXQgb2Zfc3RyaW5nIHMgPVxuICAgIG1hdGNoIFN0cmluZy5sZW5ndGggcyB3aXRoXG4gICAgfCAxIC0+IHMuWzBdXG4gICAgfCBfIC0+IGZhaWx3aXRoZiBcIkNoYXIub2Zfc3RyaW5nOiAlU1wiIHMgKClcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFRcblxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoc3RydWN0XG4gIGluY2x1ZGUgVFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5DaGFyXCJcbmVuZClcblxubGV0IHBwIGZtdCBjID0gU3RkbGliLkZvcm1hdC5mcHJpbnRmIGZtdCBcIiVDXCIgY1xuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBDaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGFsbCA9IEFycmF5LmluaXQgMjU2IH5mOnVuc2FmZV9vZl9pbnQgfD4gQXJyYXkudG9fbGlzdFxuXG5sZXQgaXNfbG93ZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfdXBwZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfcHJpbnQgPSBmdW5jdGlvblxuICB8ICcgJyAuLiAnficgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc193aGl0ZXNwYWNlID0gZnVuY3Rpb25cbiAgfCAnXFx0JyB8ICdcXG4nIHwgJ1xcMDExJyAoKiB2ZXJ0aWNhbCB0YWIgKikgfCAnXFwwMTInICgqIGZvcm0gZmVlZCAqKSB8ICdcXHInIHwgJyAnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19hbHBoYSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbigqIFdyaXRpbmcgdGhlc2Ugb3V0LCBpbnN0ZWFkIG9mIGNhbGxpbmcgW2lzX2FscGhhXSBhbmQgW2lzX2RpZ2l0XSwgcmVkdWNlc1xuICAgcnVudGltZSBieSBhcHByb3guIDMwJSAqKVxubGV0IGlzX2FscGhhbnVtID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIHwgJ0EnIC4uICdaJyB8ICcwJyAuLiAnOScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBnZXRfZGlnaXRfdW5zYWZlIHQgPSB0b19pbnQgdCAtIHRvX2ludCAnMCdcblxubGV0IGdldF9kaWdpdF9leG4gdCA9XG4gIGlmIGlzX2RpZ2l0IHRcbiAgdGhlbiBnZXRfZGlnaXRfdW5zYWZlIHRcbiAgZWxzZSBmYWlsd2l0aGYgXCJDaGFyLmdldF9kaWdpdF9leG4gJUM6IG5vdCBhIGRpZ2l0XCIgdCAoKVxuOztcblxubGV0IGdldF9kaWdpdCB0ID0gaWYgaXNfZGlnaXQgdCB0aGVuIFNvbWUgKGdldF9kaWdpdF91bnNhZmUgdCkgZWxzZSBOb25lXG5cbmxldCBpc19oZXhfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2hleF9kaWdpdF9sb3dlciA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19oZXhfZGlnaXRfdXBwZXIgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgZ2V0X2hleF9kaWdpdF9leG4gPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgYXMgdCAtPiB0b19pbnQgdCAtIHRvX2ludCAnMCdcbiAgfCAnYScgLi4gJ2YnIGFzIHQgLT4gdG9faW50IHQgLSB0b19pbnQgJ2EnICsgMTBcbiAgfCAnQScgLi4gJ0YnIGFzIHQgLT4gdG9faW50IHQgLSB0b19pbnQgJ0EnICsgMTBcbiAgfCB0IC0+XG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJDaGFyLmdldF9oZXhfZGlnaXRfZXhuOiBub3QgYSBoZXhhZGVjaW1hbCBkaWdpdFwiXG4gICAgICAgICBbIFwiY2hhclwiLCBzZXhwX29mX3QgdCBdKVxuOztcblxubGV0IGdldF9oZXhfZGlnaXQgdCA9IGlmIGlzX2hleF9kaWdpdCB0IHRoZW4gU29tZSAoZ2V0X2hleF9kaWdpdF9leG4gdCkgZWxzZSBOb25lXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGxldCAoID49ICkgPSAoID49IClcbiAgbGV0ICggPD0gKSA9ICggPD0gKVxuICBsZXQgKCA9ICkgPSAoID0gKVxuICBsZXQgKCA+ICkgPSAoID4gKVxuICBsZXQgKCA8ICkgPSAoIDwgKVxuICBsZXQgKCA8PiApID0gKCA8PiApXG5lbmRcblxubW9kdWxlIENhc2VsZXNzID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSB0ID0gY2hhciBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgbGV0IHRfb2Zfc2V4cCA9IChjaGFyX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfY2hhciA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGNoYXJfc2V4cF9ncmFtbWFyXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGNvbXBhcmUgYzEgYzIgPSBjb21wYXJlIChsb3dlcmNhc2UgYzEpIChsb3dlcmNhc2UgYzIpXG4gICAgbGV0IGNvbXBhcmVfX2xvY2FsIGMxIGMyID0gY29tcGFyZSBjMSBjMlxuICAgIGxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gaGFzaF9mb2xkX2NoYXIgc3RhdGUgKGxvd2VyY2FzZSB0KVxuICAgIGxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIENvbXBhcmFibGUuTWFrZSAoVClcblxuICBsZXQgZXF1YWxfX2xvY2FsIHQxIHQyID0gZXF1YWxfaW50IChjb21wYXJlX19sb2NhbCB0MSB0MikgMFxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBDaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0MC5JbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5tb2R1bGUgQnl0ZXMgPSBCeXRlczBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5cbigqIENvbnN0cnVjdCBhIGJ5dGUgc3RyaW5nIG9mIGxlbmd0aCAyNTYsIG1hcHBpbmcgZXZlcnkgaW5wdXQgY2hhcmFjdGVyIGNvZGUgdG9cbiAgIGl0cyBjb3JyZXNwb25kaW5nIG91dHB1dCBjaGFyYWN0ZXIuXG5cbiAgIEJlbmNobWFya3MgaW5kaWNhdGUgdGhhdCB0aGlzIGlzIGZhc3RlciB0aGFuIHRoZSBsYW1iZGEgKGluY2x1ZGluZyBjb3N0IG9mXG4gICB0aGlzIGZ1bmN0aW9uKSwgZXZlbiBpZiB0YXJnZXQvcmVwbGFjZW1lbnQgYXJlIGp1c3QgMiBjaGFyYWN0ZXJzIGVhY2guXG5cbiAgIFJldHVybiBOb25lIGlmIHRoZSB0cmFuc2xhdGlvbiBtYXAgaXMgZXF1aXZhbGVudCB0byBqdXN0IHRoZSBpZGVudGl0eS4gKilcbmxldCB0cl9jcmVhdGVfbWFwIH50YXJnZXQgfnJlcGxhY2VtZW50ID1cbiAgbGV0IHRyX21hcCA9IEJ5dGVzLmNyZWF0ZSAyNTYgaW5cbiAgZm9yIGkgPSAwIHRvIDI1NSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdHJfbWFwIGkgKENoYXIub2ZfaW50X2V4biBpKVxuICBkb25lO1xuICBmb3IgaSA9IDAgdG8gbWluIChTdHJpbmcubGVuZ3RoIHRhcmdldCkgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQpIC0gMSBkb1xuICAgIGxldCBpbmRleCA9IENoYXIudG9faW50IChTdHJpbmcudW5zYWZlX2dldCB0YXJnZXQgaSkgaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHRyX21hcCBpbmRleCAoU3RyaW5nLnVuc2FmZV9nZXQgcmVwbGFjZW1lbnQgaSlcbiAgZG9uZTtcbiAgbGV0IGxhc3RfcmVwbGFjZW1lbnQgPSBTdHJpbmcudW5zYWZlX2dldCByZXBsYWNlbWVudCAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCAtIDEpIGluXG4gIGZvclxuICAgIGkgPSBtaW4gKFN0cmluZy5sZW5ndGggdGFyZ2V0KSAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCkgdG8gU3RyaW5nLmxlbmd0aCB0YXJnZXQgLSAxXG4gIGRvXG4gICAgbGV0IGluZGV4ID0gQ2hhci50b19pbnQgKFN0cmluZy51bnNhZmVfZ2V0IHRhcmdldCBpKSBpblxuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdHJfbWFwIGluZGV4IGxhc3RfcmVwbGFjZW1lbnRcbiAgZG9uZTtcbiAgbGV0IHJlYyBoYXZlX2FueV9kaWZmZXJlbnQgdHJfbWFwIGkgPVxuICAgIGlmIGkgPSAyNTZcbiAgICB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBDaGFyLiggPD4gKSAoQnl0ZXMwLnVuc2FmZV9nZXQgdHJfbWFwIGkpIChDaGFyLm9mX2ludF9leG4gaSlcbiAgICB0aGVuIHRydWVcbiAgICBlbHNlIGhhdmVfYW55X2RpZmZlcmVudCB0cl9tYXAgKGkgKyAxKVxuICBpblxuICAoKiBxdWljayBjaGVjayBvbiB0aGUgZmlyc3QgdGFyZ2V0IGNoYXJhY3RlciB3aGljaCB3aWxsIDk5JSBiZSB0cnVlICopXG4gIGxldCBmaXJzdF90YXJnZXQgPSB0YXJnZXQuWzBdIGluXG4gIGlmIENoYXIuKCA8PiApIChCeXRlczAudW5zYWZlX2dldCB0cl9tYXAgKENoYXIudG9faW50IGZpcnN0X3RhcmdldCkpIGZpcnN0X3RhcmdldFxuICAgICB8fCBoYXZlX2FueV9kaWZmZXJlbnQgdHJfbWFwIDBcbiAgdGhlbiBTb21lIChCeXRlczAudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0cl9tYXApXG4gIGVsc2UgTm9uZVxuOztcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgQnl0ZXMgPSBCeXRlczBcbm1vZHVsZSBJbnQgPSBJbnQwXG5tb2R1bGUgVWNoYXIgPSBVY2hhcjBcbmluY2x1ZGUgU3RyaW5nMFxuaW5jbHVkZSBTdHJpbmdfaW50ZlxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5sZXQgc3RhZ2UgPSBTdGFnZWQuc3RhZ2VcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nIFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGdsb2JhbGl6ZSA6IHQgLT4gdCkgPSAoZ2xvYmFsaXplX3N0cmluZyA6IHQgLT4gdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX3N0cmluZ1xuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfc3RyaW5nIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChzdHJpbmdfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2Zfc3RyaW5nIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHN0cmluZ19zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxudHlwZSBlbHQgPSBjaGFyXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5cbigqIFRoaXMgaXMgY29waWVkL2FkYXB0ZWQgZnJvbSAnYmxpdC5tbCcuXG4gICBbc3ViXSwgW3N1Ym9dIGNvdWxkIGJlIGltcGxlbWVudGVkIHVzaW5nIFtCbGl0Lk1ha2UoQnl0ZXMpXSBwbHVzIHVuc2FmZSBjYXN0cyB0by9mcm9tXG4gICBzdHJpbmcgYnV0IHdlcmUgaW5saW5lZCBoZXJlIHRvIGF2b2lkIHVzaW5nIFtCeXRlcy51bnNhZmVfb2Zfc3RyaW5nXSBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuKilcbmxldCB1bnNhZmVfc3ViIHNyYyB+cG9zIH5sZW4gPVxuICBpZiBsZW4gPSAwXG4gIHRoZW4gXCJcIlxuICBlbHNlIChcbiAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOnBvcyB+ZHN0IH5kc3RfcG9zOjAgfmxlbjtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdClcbjs7XG5cbmxldCBzdWIgc3JjIH5wb3MgfmxlbiA9XG4gIGlmIHBvcyA9IDAgJiYgbGVuID0gU3RyaW5nLmxlbmd0aCBzcmNcbiAgdGhlbiBzcmNcbiAgZWxzZSAoXG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIHNyYyk7XG4gICAgdW5zYWZlX3N1YiBzcmMgfnBvcyB+bGVuKVxuOztcblxubGV0IHN1Ym8gPyhwb3MgPSAwKSA/bGVuIHNyYyA9XG4gIHN1YlxuICAgIHNyY1xuICAgIH5wb3NcbiAgICB+bGVuOlxuICAgICAgKG1hdGNoIGxlbiB3aXRoXG4gICAgICAgfCBTb21lIGkgLT4gaVxuICAgICAgIHwgTm9uZSAtPiBsZW5ndGggc3JjIC0gcG9zKVxuOztcblxubGV0IHJlYyBjb250YWluc191bnNhZmUgdCB+cG9zIH5lbmRfIGNoYXIgPVxuICBwb3MgPCBlbmRfXG4gICYmIChDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHQgcG9zKSBjaGFyIHx8IGNvbnRhaW5zX3Vuc2FmZSB0IH5wb3M6KHBvcyArIDEpIH5lbmRfIGNoYXIpXG47O1xuXG5sZXQgY29udGFpbnMgPyhwb3MgPSAwKSA/bGVuIHQgY2hhciA9XG4gIGxldCB0b3RhbF9sZW5ndGggPSBTdHJpbmcubGVuZ3RoIHQgaW5cbiAgbGV0IGxlbiA9IE9wdGlvbi52YWx1ZSBsZW4gfmRlZmF1bHQ6KHRvdGFsX2xlbmd0aCAtIHBvcykgaW5cbiAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDtcbiAgY29udGFpbnNfdW5zYWZlIHQgfnBvcyB+ZW5kXzoocG9zICsgbGVuKSBjaGFyXG47O1xuXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG5sZXRbQGlubGluZV0gaW5kZXhfZnJvbV9pbnRlcm5hbCBzdHJpbmcgfmxlbiB+bm90X2ZvdW5kIH5mb3VuZCBjaGFyIH5wb3MgPVxuICBsZXQgcmVjIGxvb3AgfnBvcyA9XG4gICAgaWYgcG9zID49IGxlblxuICAgIHRoZW4gbm90X2ZvdW5kICgpXG4gICAgZWxzZSBpZiBDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHN0cmluZyBwb3MpIGNoYXJcbiAgICB0aGVuIGZvdW5kIHBvc1xuICAgIGVsc2UgbG9vcCB+cG9zOihwb3MgKyAxKVxuICBpblxuICBsb29wIH5wb3MgW0Bub250YWlsXVxuOztcblxubGV0IGluZGV4IHQgY2hhciA9XG4gIGluZGV4X2Zyb21faW50ZXJuYWxcbiAgICB0XG4gICAgY2hhclxuICAgIH5wb3M6MFxuICAgIH5sZW46KGxlbmd0aCB0KVxuICAgIH5mb3VuZDpPcHRpb24uc29tZVxuICAgIH5ub3RfZm91bmQ6KGZ1biAoKSAtPiBOb25lKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgaW5kZXhfZXhuIHQgY2hhciA9XG4gIGluZGV4X2Zyb21faW50ZXJuYWxcbiAgICB0XG4gICAgfnBvczowXG4gICAgfmxlbjoobGVuZ3RoIHQpXG4gICAgfmZvdW5kOkZuLmlkXG4gICAgfm5vdF9mb3VuZDooZnVuICgpIC0+IHJhaXNlIChOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5pbmRleF9leG46IG5vdCBmb3VuZFwiKSkpXG4gICAgY2hhciBbQG5vbnRhaWxdXG47O1xuXG5sZXQgaW5kZXhfZnJvbSB0IHBvcyBjaGFyID1cbiAgaW5kZXhfZnJvbV9pbnRlcm5hbCB0IGNoYXIgfnBvcyB+bGVuOihsZW5ndGggdCkgfmZvdW5kOk9wdGlvbi5zb21lIH5ub3RfZm91bmQ6KGZ1biAoKSAtPlxuICAgIE5vbmUpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBpbmRleF9mcm9tX2V4biA9XG4gIGxldCBub3RfZm91bmQgKCkgPSByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcuaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiKSkgaW5cbiAgbGV0IGluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIGlmIHBvcyA8IDAgfHwgcG9zID4gbGVuXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX2V4blwiXG4gICAgZWxzZSBpbmRleF9mcm9tX2ludGVybmFsIHQgfnBvcyB+bGVuIH5ub3RfZm91bmQgfmZvdW5kOkZuLmlkIGNoYXJcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBpbmRleF9mcm9tX2V4blxuOztcblxubGV0W0BpbmxpbmVdIHJpbmRleF9mcm9tX2ludGVybmFsIHN0cmluZyBjaGFyIH5mb3VuZCB+bm90X2ZvdW5kIH5wb3MgPVxuICBsZXQgcmVjIGxvb3AgfnBvcyA9XG4gICAgaWYgcG9zIDwgMFxuICAgIHRoZW4gbm90X2ZvdW5kICgpXG4gICAgZWxzZSBpZiBDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHN0cmluZyBwb3MpIGNoYXJcbiAgICB0aGVuIGZvdW5kIHBvc1xuICAgIGVsc2UgbG9vcCB+cG9zOihwb3MgLSAxKVxuICBpblxuICBsb29wIH5wb3MgW0Bub250YWlsXVxuOztcblxubGV0IHJpbmRleCB0IGNoYXIgPVxuICByaW5kZXhfZnJvbV9pbnRlcm5hbFxuICAgIHRcbiAgICBjaGFyXG4gICAgfnBvczoobGVuZ3RoIHQgLSAxKVxuICAgIH5mb3VuZDpPcHRpb24uc29tZVxuICAgIH5ub3RfZm91bmQ6KGZ1biAoKSAtPiBOb25lKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgcmluZGV4X2V4biB0IGNoYXIgPVxuICByaW5kZXhfZnJvbV9pbnRlcm5hbFxuICAgIHRcbiAgICBjaGFyXG4gICAgfnBvczoobGVuZ3RoIHQgLSAxKVxuICAgIH5mb3VuZDpGbi5pZFxuICAgIH5ub3RfZm91bmQ6KGZ1biAoKSAtPiByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcucmluZGV4X2V4bjogbm90IGZvdW5kXCIpKSlcbiAgW0Bub250YWlsXVxuOztcblxubGV0IHJpbmRleF9mcm9tIHQgcG9zIGNoYXIgPVxuICByaW5kZXhfZnJvbV9pbnRlcm5hbCB0IGNoYXIgfnBvcyB+Zm91bmQ6T3B0aW9uLnNvbWUgfm5vdF9mb3VuZDooZnVuICgpIC0+IE5vbmUpIFtAbm9udGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuOztcblxubGV0IHJpbmRleF9mcm9tX2V4biA9XG4gIGxldCBub3RfZm91bmQgKCkgPSByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcucmluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIikpIGluXG4gIGxldCByaW5kZXhfZnJvbV9leG4gdCBwb3MgY2hhciA9XG4gICAgaWYgcG9zIDwgLTEgfHwgcG9zID49IGxlbmd0aCB0XG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9leG5cIlxuICAgIGVsc2UgcmluZGV4X2Zyb21faW50ZXJuYWwgdCB+cG9zIH5ub3RfZm91bmQgfmZvdW5kOkZuLmlkIGNoYXJcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICByaW5kZXhfZnJvbV9leG5cbjs7XG5cbm1vZHVsZSBTZWFyY2hfcGF0dGVybjAgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHBhdHRlcm4gOiBzdHJpbmdcbiAgICA7IGNhc2Vfc2Vuc2l0aXZlIDogYm9vbFxuICAgIDsga21wX2FycmF5IDogaW50IGFycmF5XG4gICAgfVxuXG4gIGxldCBzZXhwX29mX3QgeyBwYXR0ZXJuOyBjYXNlX3NlbnNpdGl2ZTsga21wX2FycmF5ID0gXyB9IDogU2V4cC50ID1cbiAgICBMaXN0XG4gICAgICBbIExpc3QgWyBBdG9tIFwicGF0dGVyblwiOyBzZXhwX29mX3N0cmluZyBwYXR0ZXJuIF1cbiAgICAgIDsgTGlzdCBbIEF0b20gXCJjYXNlX3NlbnNpdGl2ZVwiOyBzZXhwX29mX2Jvb2wgY2FzZV9zZW5zaXRpdmUgXVxuICAgICAgXVxuICA7O1xuXG4gIGxldCBwYXR0ZXJuIHQgPSB0LnBhdHRlcm5cbiAgbGV0IGNhc2Vfc2Vuc2l0aXZlIHQgPSB0LmNhc2Vfc2Vuc2l0aXZlXG5cbiAgKCogRmluZCBtYXggbnVtYmVyIG9mIG1hdGNoZWQgY2hhcmFjdGVycyBhdCBbbmV4dF90ZXh0X2NoYXJdLCBnaXZlbiB0aGUgY3VycmVudFxuICAgICBbbWF0Y2hlZF9jaGFyc10uIFRyeSB0byBleHRlbmQgdGhlIGN1cnJlbnQgbWF0Y2gsIGlmIGNoYXJzIGRvbid0IG1hdGNoLCB0cnkgdG8gbWF0Y2hcbiAgICAgZmV3ZXIgY2hhcnMuIElmIGNoYXJzIG1hdGNoIHRoZW4gZXh0ZW5kIHRoZSBtYXRjaC4gKilcbiAgbGV0IGttcF9pbnRlcm5hbF9sb29wIH5tYXRjaGVkX2NoYXJzIH5uZXh0X3RleHRfY2hhciB+cGF0dGVybiB+a21wX2FycmF5IH5jaGFyX2VxdWFsID1cbiAgICBsZXQgbWF0Y2hlZF9jaGFycyA9IHJlZiBtYXRjaGVkX2NoYXJzIGluXG4gICAgd2hpbGVcbiAgICAgICFtYXRjaGVkX2NoYXJzID4gMFxuICAgICAgJiYgbm90IChjaGFyX2VxdWFsIG5leHRfdGV4dF9jaGFyICh1bnNhZmVfZ2V0IHBhdHRlcm4gIW1hdGNoZWRfY2hhcnMpKVxuICAgIGRvXG4gICAgICBtYXRjaGVkX2NoYXJzIDo9IEFycmF5LnVuc2FmZV9nZXQga21wX2FycmF5ICghbWF0Y2hlZF9jaGFycyAtIDEpXG4gICAgZG9uZTtcbiAgICBpZiBjaGFyX2VxdWFsIG5leHRfdGV4dF9jaGFyICh1bnNhZmVfZ2V0IHBhdHRlcm4gIW1hdGNoZWRfY2hhcnMpXG4gICAgdGhlbiBtYXRjaGVkX2NoYXJzIDo9ICFtYXRjaGVkX2NoYXJzICsgMTtcbiAgICAhbWF0Y2hlZF9jaGFyc1xuICA7O1xuXG4gIGxldCBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgPVxuICAgIG1hdGNoIGNhc2Vfc2Vuc2l0aXZlIHdpdGhcbiAgICB8IHRydWUgLT4gQ2hhci5lcXVhbFxuICAgIHwgZmFsc2UgLT4gQ2hhci5DYXNlbGVzcy5lcXVhbFxuICA7O1xuXG4gICgqIENsYXNzaWMgS01QIHByZS1wcm9jZXNzaW5nIG9mIHRoZSBwYXR0ZXJuOiBidWlsZCB0aGUgaW50IGFycmF5LCB3aGljaCwgZm9yIGVhY2ggaSxcbiAgICAgY29udGFpbnMgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBub24tdHJpdmlhbCBwcmVmaXggb2YgcyB3aGljaCBpcyBlcXVhbCB0byBhIHN1ZmZpeFxuICAgICBlbmRpbmcgYXQgcy5baV0gKilcbiAgbGV0IGNyZWF0ZSBwYXR0ZXJuIH5jYXNlX3NlbnNpdGl2ZSA9XG4gICAgbGV0IG4gPSBsZW5ndGggcGF0dGVybiBpblxuICAgIGxldCBrbXBfYXJyYXkgPSBBcnJheS5jcmVhdGUgfmxlbjpuICgtMSkgaW5cbiAgICBpZiBuID4gMFxuICAgIHRoZW4gKFxuICAgICAgbGV0IGNoYXJfZXF1YWwgPSBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgaW5cbiAgICAgIEFycmF5LnVuc2FmZV9zZXQga21wX2FycmF5IDAgMDtcbiAgICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIDAgaW5cbiAgICAgIGZvciBpID0gMSB0byBuIC0gMSBkb1xuICAgICAgICBtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgOj0ga21wX2ludGVybmFsX2xvb3BcbiAgICAgICAgICAgICAgIH5tYXRjaGVkX2NoYXJzOiFtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgICAgICB+bmV4dF90ZXh0X2NoYXI6KHVuc2FmZV9nZXQgcGF0dGVybiBpKVxuICAgICAgICAgICAgICAgfnBhdHRlcm5cbiAgICAgICAgICAgICAgIH5rbXBfYXJyYXlcbiAgICAgICAgICAgICAgIH5jaGFyX2VxdWFsO1xuICAgICAgICBBcnJheS51bnNhZmVfc2V0IGttcF9hcnJheSBpICFtYXRjaGVkX2NoYXJzXG4gICAgICBkb25lKTtcbiAgICB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgfVxuICA7O1xuXG4gICgqIENsYXNzaWMgS01QOiB1c2UgdGhlIHByZS1wcm9jZXNzZWQgcGF0dGVybiB0byBvcHRpbWl6ZSBsb29rLWJlaGluZHMgb24gbm9uLW1hdGNoZXMuXG4gICAgIFdlIHJldHVybiBpbnQgdG8gYXZvaWQgYWxsb2NhdGlvbiBpbiBbaW5kZXhfZXhuXS4gLTEgbWVhbnMgbm8gbWF0Y2guICopXG4gIGxldCBpbmRleF9pbnRlcm5hbCA/KHBvcyA9IDApIHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSB9IH5pbl86dGV4dCA9XG4gICAgaWYgcG9zIDwgMCB8fCBwb3MgPiBsZW5ndGggdGV4dCAtIGxlbmd0aCBwYXR0ZXJuXG4gICAgdGhlbiAtMVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNoYXJfZXF1YWwgPSBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgaW5cbiAgICAgIGxldCBqID0gcmVmIHBvcyBpblxuICAgICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgMCBpblxuICAgICAgbGV0IGsgPSBsZW5ndGggcGF0dGVybiBpblxuICAgICAgbGV0IG4gPSBsZW5ndGggdGV4dCBpblxuICAgICAgd2hpbGUgIWogPCBuICYmICFtYXRjaGVkX2NoYXJzIDwgayBkb1xuICAgICAgICBsZXQgbmV4dF90ZXh0X2NoYXIgPSB1bnNhZmVfZ2V0IHRleHQgIWogaW5cbiAgICAgICAgbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgIDo9IGttcF9pbnRlcm5hbF9sb29wXG4gICAgICAgICAgICAgICB+bWF0Y2hlZF9jaGFyczohbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgICAgICAgfm5leHRfdGV4dF9jaGFyXG4gICAgICAgICAgICAgICB+cGF0dGVyblxuICAgICAgICAgICAgICAgfmttcF9hcnJheVxuICAgICAgICAgICAgICAgfmNoYXJfZXF1YWw7XG4gICAgICAgIGogOj0gIWogKyAxXG4gICAgICBkb25lO1xuICAgICAgaWYgIW1hdGNoZWRfY2hhcnMgPSBrIHRoZW4gIWogLSBrIGVsc2UgLTEpXG4gIDs7XG5cbiAgbGV0IG1hdGNoZXMgdCBzdHIgPSBpbmRleF9pbnRlcm5hbCB0IH5pbl86c3RyID49IDBcblxuICBsZXQgaW5kZXggP3BvcyB0IH5pbl8gPVxuICAgIGxldCBwID0gaW5kZXhfaW50ZXJuYWwgP3BvcyB0IH5pbl8gaW5cbiAgICBpZiBwIDwgMCB0aGVuIE5vbmUgZWxzZSBTb21lIHBcbiAgOztcblxuICBsZXQgaW5kZXhfZXhuID9wb3MgdCB+aW5fID1cbiAgICBsZXQgcCA9IGluZGV4X2ludGVybmFsID9wb3MgdCB+aW5fIGluXG4gICAgaWYgcCA+PSAwXG4gICAgdGhlbiBwXG4gICAgZWxzZVxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlIFwiU3Vic3RyaW5nIG5vdCBmb3VuZFwiIFsgXCJzdWJzdHJpbmdcIiwgc2V4cF9vZl9zdHJpbmcgdC5wYXR0ZXJuIF0pXG4gIDs7XG5cbiAgbGV0IGluZGV4X2FsbCB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgfSB+bWF5X292ZXJsYXAgfmluXzp0ZXh0ID1cbiAgICBpZiBsZW5ndGggcGF0dGVybiA9IDBcbiAgICB0aGVuIExpc3QuaW5pdCAoMSArIGxlbmd0aCB0ZXh0KSB+ZjpGbi5pZFxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNoYXJfZXF1YWwgPSBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgaW5cbiAgICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIDAgaW5cbiAgICAgIGxldCBrID0gbGVuZ3RoIHBhdHRlcm4gaW5cbiAgICAgIGxldCBuID0gbGVuZ3RoIHRleHQgaW5cbiAgICAgIGxldCBmb3VuZCA9IHJlZiBbXSBpblxuICAgICAgZm9yIGogPSAwIHRvIG4gZG9cbiAgICAgICAgaWYgIW1hdGNoZWRfY2hhcnMgPSBrXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGZvdW5kIDo9IChqIC0gaykgOjogIWZvdW5kO1xuICAgICAgICAgICgqIHdlIGp1c3QgZm91bmQgYSBtYXRjaCBpbiB0aGUgcHJldmlvdXMgaXRlcmF0aW9uICopXG4gICAgICAgICAgbWF0Y2ggbWF5X292ZXJsYXAgd2l0aFxuICAgICAgICAgIHwgdHJ1ZSAtPiBtYXRjaGVkX2NoYXJzIDo9IEFycmF5LnVuc2FmZV9nZXQga21wX2FycmF5IChrIC0gMSlcbiAgICAgICAgICB8IGZhbHNlIC0+IG1hdGNoZWRfY2hhcnMgOj0gMCk7XG4gICAgICAgIGlmIGogPCBuXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBuZXh0X3RleHRfY2hhciA9IHVuc2FmZV9nZXQgdGV4dCBqIGluXG4gICAgICAgICAgbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgICAgOj0ga21wX2ludGVybmFsX2xvb3BcbiAgICAgICAgICAgICAgICAgfm1hdGNoZWRfY2hhcnM6IW1hdGNoZWRfY2hhcnNcbiAgICAgICAgICAgICAgICAgfm5leHRfdGV4dF9jaGFyXG4gICAgICAgICAgICAgICAgIH5wYXR0ZXJuXG4gICAgICAgICAgICAgICAgIH5rbXBfYXJyYXlcbiAgICAgICAgICAgICAgICAgfmNoYXJfZXF1YWwpXG4gICAgICBkb25lO1xuICAgICAgTGlzdC5yZXYgIWZvdW5kKVxuICA7O1xuXG4gIGxldCByZXBsYWNlX2ZpcnN0ID9wb3MgdCB+aW5fOnMgfndpdGhfID1cbiAgICBtYXRjaCBpbmRleCA/cG9zIHQgfmluXzpzIHdpdGhcbiAgICB8IE5vbmUgLT4gc1xuICAgIHwgU29tZSBpIC0+XG4gICAgICBsZXQgbGVuX3MgPSBsZW5ndGggcyBpblxuICAgICAgbGV0IGxlbl90ID0gbGVuZ3RoIHQucGF0dGVybiBpblxuICAgICAgbGV0IGxlbl93aXRoID0gbGVuZ3RoIHdpdGhfIGluXG4gICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIChsZW5fcyArIGxlbl93aXRoIC0gbGVuX3QpIGluXG4gICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOjAgfmxlbjppO1xuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzp3aXRoXyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6aSB+bGVuOmxlbl93aXRoO1xuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmdcbiAgICAgICAgfnNyYzpzXG4gICAgICAgIH5zcmNfcG9zOihpICsgbGVuX3QpXG4gICAgICAgIH5kc3RcbiAgICAgICAgfmRzdF9wb3M6KGkgKyBsZW5fd2l0aClcbiAgICAgICAgfmxlbjoobGVuX3MgLSBpIC0gbGVuX3QpO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3RcbiAgOztcblxuICBsZXQgcmVwbGFjZV9hbGwgdCB+aW5fOnMgfndpdGhfID1cbiAgICBsZXQgbWF0Y2hlcyA9IGluZGV4X2FsbCB0IH5tYXlfb3ZlcmxhcDpmYWxzZSB+aW5fOnMgaW5cbiAgICBtYXRjaCBtYXRjaGVzIHdpdGhcbiAgICB8IFtdIC0+IHNcbiAgICB8IF8gOjogXyAtPlxuICAgICAgbGV0IGxlbl9zID0gbGVuZ3RoIHMgaW5cbiAgICAgIGxldCBsZW5fdCA9IGxlbmd0aCB0LnBhdHRlcm4gaW5cbiAgICAgIGxldCBsZW5fd2l0aCA9IGxlbmd0aCB3aXRoXyBpblxuICAgICAgbGV0IG51bV9tYXRjaGVzID0gTGlzdC5sZW5ndGggbWF0Y2hlcyBpblxuICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSAobGVuX3MgKyAoKGxlbl93aXRoIC0gbGVuX3QpICogbnVtX21hdGNoZXMpKSBpblxuICAgICAgbGV0IG5leHRfZHN0X3BvcyA9IHJlZiAwIGluXG4gICAgICBsZXQgbmV4dF9zcmNfcG9zID0gcmVmIDAgaW5cbiAgICAgIExpc3QuaXRlciBtYXRjaGVzIH5mOihmdW4gaSAtPlxuICAgICAgICBsZXQgbGVuID0gaSAtICFuZXh0X3NyY19wb3MgaW5cbiAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzpzIH5zcmNfcG9zOiFuZXh0X3NyY19wb3MgfmRzdCB+ZHN0X3BvczohbmV4dF9kc3RfcG9zIH5sZW47XG4gICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nXG4gICAgICAgICAgfnNyYzp3aXRoX1xuICAgICAgICAgIH5zcmNfcG9zOjBcbiAgICAgICAgICB+ZHN0XG4gICAgICAgICAgfmRzdF9wb3M6KCFuZXh0X2RzdF9wb3MgKyBsZW4pXG4gICAgICAgICAgfmxlbjpsZW5fd2l0aDtcbiAgICAgICAgbmV4dF9kc3RfcG9zIDo9ICFuZXh0X2RzdF9wb3MgKyBsZW4gKyBsZW5fd2l0aDtcbiAgICAgICAgbmV4dF9zcmNfcG9zIDo9ICFuZXh0X3NyY19wb3MgKyBsZW4gKyBsZW5fdCk7XG4gICAgICBCeXRlcy5ibGl0X3N0cmluZ1xuICAgICAgICB+c3JjOnNcbiAgICAgICAgfnNyY19wb3M6IW5leHRfc3JjX3Bvc1xuICAgICAgICB+ZHN0XG4gICAgICAgIH5kc3RfcG9zOiFuZXh0X2RzdF9wb3NcbiAgICAgICAgfmxlbjoobGVuX3MgLSAhbmV4dF9zcmNfcG9zKTtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0XG4gIDs7XG5cbiAgbGV0IHNwbGl0X29uIHQgcyA9XG4gICAgbGV0IHBhdHRlcm5fbGVuID0gU3RyaW5nLmxlbmd0aCB0LnBhdHRlcm4gaW5cbiAgICBsZXQgbWF0Y2hlcyA9IGluZGV4X2FsbCB0IH5tYXlfb3ZlcmxhcDpmYWxzZSB+aW5fOnMgaW5cbiAgICBMaXN0Lm1hcDJfZXhuXG4gICAgICAoLXBhdHRlcm5fbGVuIDo6IG1hdGNoZXMpXG4gICAgICAobWF0Y2hlcyBAIFsgU3RyaW5nLmxlbmd0aCBzIF0pXG4gICAgICB+ZjooZnVuIGkgaiAtPiBzdWIgcyB+cG9zOihpICsgcGF0dGVybl9sZW4pIH5sZW46KGogLSBpIC0gcGF0dGVybl9sZW4pKVxuICA7O1xuXG4gIG1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gICAgdHlwZSBwdWJsaWMgPSB0XG5cbiAgICB0eXBlIG5vbnJlYyB0ID0gdCA9XG4gICAgICB7IHBhdHRlcm4gOiBzdHJpbmdcbiAgICAgIDsgY2FzZV9zZW5zaXRpdmUgOiBib29sXG4gICAgICA7IGttcF9hcnJheSA6IGludCBhcnJheVxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nX2lubGluZSBlcXVhbCB+bG9jYWxpemUsIHNleHBfb2ZdXG5cbiAgICBsZXQgZXF1YWxfX2xvY2FsID1cbiAgICAgIChmdW4gYV9fMDAzXyBiX18wMDRfIC0+XG4gICAgICAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwM18gYl9fMDA0X1xuICAgICAgICAgdGhlbiB0cnVlXG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIFN0ZGxpYi4oICYmIClcbiAgICAgICAgICAgICAoZXF1YWxfc3RyaW5nX19sb2NhbCBhX18wMDNfLnBhdHRlcm4gYl9fMDA0Xy5wYXR0ZXJuKVxuICAgICAgICAgICAgIChTdGRsaWIuKCAmJiApXG4gICAgICAgICAgICAgICAgKGVxdWFsX2Jvb2xfX2xvY2FsIGFfXzAwM18uY2FzZV9zZW5zaXRpdmUgYl9fMDA0Xy5jYXNlX3NlbnNpdGl2ZSlcbiAgICAgICAgICAgICAgICAoZXF1YWxfYXJyYXlfX2xvY2FsIGVxdWFsX2ludF9fbG9jYWwgYV9fMDAzXy5rbXBfYXJyYXkgYl9fMDA0Xy5rbXBfYXJyYXkpKVxuICAgICAgICA6IHQgLT4gdCAtPiBib29sKVxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgPSAoZnVuIGEgYiAtPiBlcXVhbF9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGJvb2wpXG5cbiAgICBsZXQgc2V4cF9vZl90ID1cbiAgICAgIChmdW4geyBwYXR0ZXJuID0gcGF0dGVybl9fMDA4X1xuICAgICAgICAgICA7IGNhc2Vfc2Vuc2l0aXZlID0gY2FzZV9zZW5zaXRpdmVfXzAxMF9cbiAgICAgICAgICAgOyBrbXBfYXJyYXkgPSBrbXBfYXJyYXlfXzAxMl9cbiAgICAgICAgICAgfSAtPlxuICAgICAgICAgbGV0IGJuZHNfXzAwN18gPSAoW10gOiBfIFN0ZGxpYi5MaXN0LnQpIGluXG4gICAgICAgICBsZXQgYm5kc19fMDA3XyA9XG4gICAgICAgICAgIGxldCBhcmdfXzAxM18gPSBzZXhwX29mX2FycmF5IHNleHBfb2ZfaW50IGttcF9hcnJheV9fMDEyXyBpblxuICAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwia21wX2FycmF5XCI7IGFyZ19fMDEzXyBdIDo6IGJuZHNfXzAwN19cbiAgICAgICAgICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgICAgICAgIGluXG4gICAgICAgICBsZXQgYm5kc19fMDA3XyA9XG4gICAgICAgICAgIGxldCBhcmdfXzAxMV8gPSBzZXhwX29mX2Jvb2wgY2FzZV9zZW5zaXRpdmVfXzAxMF8gaW5cbiAgICAgICAgICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImNhc2Vfc2Vuc2l0aXZlXCI7IGFyZ19fMDExXyBdXG4gICAgICAgICAgICA6OiBibmRzX18wMDdfXG4gICAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IGJuZHNfXzAwN18gPVxuICAgICAgICAgICBsZXQgYXJnX18wMDlfID0gc2V4cF9vZl9zdHJpbmcgcGF0dGVybl9fMDA4XyBpblxuICAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwicGF0dGVyblwiOyBhcmdfXzAwOV8gXSA6OiBibmRzX18wMDdfXG4gICAgICAgICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gICAgICAgICBpblxuICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwN19cbiAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCByZXByZXNlbnRhdGlvbiA9IEZuLmlkXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBTZWFyY2hfcGF0dGVybl9oZWxwZXIgPSBzdHJ1Y3RcbiAgbW9kdWxlIFNlYXJjaF9wYXR0ZXJuID0gU2VhcmNoX3BhdHRlcm4wXG5lbmRcblxub3BlbiBTZWFyY2hfcGF0dGVybl9oZWxwZXJcblxubGV0IHN1YnN0cl9pbmRleF9nZW4gfmNhc2Vfc2Vuc2l0aXZlID9wb3MgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLmluZGV4ID9wb3MgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX2luZGV4X2V4bl9nZW4gfmNhc2Vfc2Vuc2l0aXZlID9wb3MgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLmluZGV4X2V4biA/cG9zIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IHN1YnN0cl9pbmRleF9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZSB0IH5tYXlfb3ZlcmxhcCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLmluZGV4X2FsbFxuICAgIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pXG4gICAgfm1heV9vdmVybGFwXG4gICAgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIH5jYXNlX3NlbnNpdGl2ZSA/cG9zIHQgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5yZXBsYWNlX2ZpcnN0ID9wb3MgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX3JlcGxhY2VfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmUgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLnJlcGxhY2VfYWxsIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IGlzX3N1YnN0cmluZ19nZW4gfmNhc2Vfc2Vuc2l0aXZlIHQgfnN1YnN0cmluZyA9XG4gIE9wdGlvbi5pc19zb21lIChzdWJzdHJfaW5kZXhfZ2VuIHQgfnBhdHRlcm46c3Vic3RyaW5nIH5jYXNlX3NlbnNpdGl2ZSlcbjs7XG5cbmxldCBzdWJzdHJfaW5kZXggPSBzdWJzdHJfaW5kZXhfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX2luZGV4X2V4biA9IHN1YnN0cl9pbmRleF9leG5fZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX2luZGV4X2FsbCA9IHN1YnN0cl9pbmRleF9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX3JlcGxhY2VfZmlyc3QgPSBzdWJzdHJfcmVwbGFjZV9maXJzdF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBzdWJzdHJfcmVwbGFjZV9hbGwgPSBzdWJzdHJfcmVwbGFjZV9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgaXNfc3Vic3RyaW5nID0gaXNfc3Vic3RyaW5nX2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxuXG5sZXQgaXNfc3Vic3RyaW5nX2F0X2dlbiA9XG4gIGxldCByZWMgbG9vcCB+c3RyIH5zdHJfcG9zIH5zdWIgfnN1Yl9wb3MgfnN1Yl9sZW4gfmNoYXJfZXF1YWwgPVxuICAgIGlmIHN1Yl9wb3MgPSBzdWJfbGVuXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBjaGFyX2VxdWFsICh1bnNhZmVfZ2V0IHN0ciBzdHJfcG9zKSAodW5zYWZlX2dldCBzdWIgc3ViX3BvcylcbiAgICB0aGVuIGxvb3AgfnN0ciB+c3RyX3Bvczooc3RyX3BvcyArIDEpIH5zdWIgfnN1Yl9wb3M6KHN1Yl9wb3MgKyAxKSB+c3ViX2xlbiB+Y2hhcl9lcXVhbFxuICAgIGVsc2UgZmFsc2VcbiAgaW5cbiAgZnVuIHN0ciB+cG9zOnN0cl9wb3MgfnN1YnN0cmluZzpzdWIgfmNoYXJfZXF1YWwgLT5cbiAgICBsZXQgc3RyX2xlbiA9IGxlbmd0aCBzdHIgaW5cbiAgICBsZXQgc3ViX2xlbiA9IGxlbmd0aCBzdWIgaW5cbiAgICBpZiBzdHJfcG9zIDwgMCB8fCBzdHJfcG9zID4gc3RyX2xlblxuICAgIHRoZW5cbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIlN0cmluZy5pc19zdWJzdHJpbmdfYXQ6IGludmFsaWQgaW5kZXggJWQgZm9yIHN0cmluZyBvZiBsZW5ndGggJWRcIlxuICAgICAgICBzdHJfcG9zXG4gICAgICAgIHN0cl9sZW5cbiAgICAgICAgKCk7XG4gICAgc3RyX3BvcyArIHN1Yl9sZW4gPD0gc3RyX2xlblxuICAgICYmIGxvb3AgfnN0ciB+c3RyX3BvcyB+c3ViIH5zdWJfcG9zOjAgfnN1Yl9sZW4gfmNoYXJfZXF1YWxcbjs7XG5cbmxldCBpc19zdWZmaXhfZ2VuIHN0cmluZyB+c3VmZml4IH5jaGFyX2VxdWFsID1cbiAgbGV0IHN0cmluZ19sZW4gPSBsZW5ndGggc3RyaW5nIGluXG4gIGxldCBzdWZmaXhfbGVuID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBzdHJpbmdfbGVuID49IHN1ZmZpeF9sZW5cbiAgJiYgaXNfc3Vic3RyaW5nX2F0X2dlblxuICAgICAgIHN0cmluZ1xuICAgICAgIH5wb3M6KHN0cmluZ19sZW4gLSBzdWZmaXhfbGVuKVxuICAgICAgIH5zdWJzdHJpbmc6c3VmZml4XG4gICAgICAgfmNoYXJfZXF1YWxcbjs7XG5cbmxldCBpc19wcmVmaXhfZ2VuIHN0cmluZyB+cHJlZml4IH5jaGFyX2VxdWFsID1cbiAgbGV0IHN0cmluZ19sZW4gPSBsZW5ndGggc3RyaW5nIGluXG4gIGxldCBwcmVmaXhfbGVuID0gbGVuZ3RoIHByZWZpeCBpblxuICBzdHJpbmdfbGVuID49IHByZWZpeF9sZW5cbiAgJiYgaXNfc3Vic3RyaW5nX2F0X2dlbiBzdHJpbmcgfnBvczowIH5zdWJzdHJpbmc6cHJlZml4IH5jaGFyX2VxdWFsXG47O1xuXG5tb2R1bGUgQ2FzZWxlc3MgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBzdHJpbmcgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGxldCB0X29mX3NleHAgPSAoc3RyaW5nX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2Zfc3RyaW5nIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gc3RyaW5nX3NleHBfZ3JhbW1hclxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjaGFyX2NvbXBhcmVfY2FzZWxlc3MgYzEgYzIgPSBDaGFyLmNvbXBhcmUgKENoYXIubG93ZXJjYXNlIGMxKSAoQ2hhci5sb3dlcmNhc2UgYzIpXG5cbiAgICBsZXQgcmVjIGNvbXBhcmVfbG9vcCB+cG9zIH5zdHJpbmcxIH5sZW4xIH5zdHJpbmcyIH5sZW4yID1cbiAgICAgIGlmIHBvcyA9IGxlbjFcbiAgICAgIHRoZW4gaWYgcG9zID0gbGVuMiB0aGVuIDAgZWxzZSAtMVxuICAgICAgZWxzZSBpZiBwb3MgPSBsZW4yXG4gICAgICB0aGVuIDFcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgYyA9IGNoYXJfY29tcGFyZV9jYXNlbGVzcyAodW5zYWZlX2dldCBzdHJpbmcxIHBvcykgKHVuc2FmZV9nZXQgc3RyaW5nMiBwb3MpIGluXG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8IDAgLT4gY29tcGFyZV9sb29wIH5wb3M6KHBvcyArIDEpIH5zdHJpbmcxIH5sZW4xIH5zdHJpbmcyIH5sZW4yXG4gICAgICAgIHwgXyAtPiBjKVxuICAgIDs7XG5cbiAgICBsZXQgY29tcGFyZV9fbG9jYWwgc3RyaW5nMSBzdHJpbmcyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgc3RyaW5nMSBzdHJpbmcyXG4gICAgICB0aGVuIDBcbiAgICAgIGVsc2VcbiAgICAgICAgY29tcGFyZV9sb29wXG4gICAgICAgICAgfnBvczowXG4gICAgICAgICAgfnN0cmluZzFcbiAgICAgICAgICB+bGVuMTooU3RyaW5nLmxlbmd0aCBzdHJpbmcxKVxuICAgICAgICAgIH5zdHJpbmcyXG4gICAgICAgICAgfmxlbjI6KFN0cmluZy5sZW5ndGggc3RyaW5nMilcbiAgICA7O1xuXG4gICAgbGV0IGNvbXBhcmUgYSBiID0gY29tcGFyZV9fbG9jYWwgYSBiXG5cbiAgICBsZXQgaGFzaF9mb2xkX3Qgc3RhdGUgdCA9XG4gICAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICAgIGxldCBzdGF0ZSA9IHJlZiAoaGFzaF9mb2xkX2ludCBzdGF0ZSBsZW4pIGluXG4gICAgICBmb3IgcG9zID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIHN0YXRlIDo9IGhhc2hfZm9sZF9jaGFyICFzdGF0ZSAoQ2hhci5sb3dlcmNhc2UgKHVuc2FmZV9nZXQgdCBwb3MpKVxuICAgICAgZG9uZTtcbiAgICAgICFzdGF0ZVxuICAgIDs7XG5cbiAgICBsZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuICAgIGxldCBpc19zdWZmaXggcyB+c3VmZml4ID0gaXNfc3VmZml4X2dlbiBzIH5zdWZmaXggfmNoYXJfZXF1YWw6Q2hhci5DYXNlbGVzcy5lcXVhbFxuICAgIGxldCBpc19wcmVmaXggcyB+cHJlZml4ID0gaXNfcHJlZml4X2dlbiBzIH5wcmVmaXggfmNoYXJfZXF1YWw6Q2hhci5DYXNlbGVzcy5lcXVhbFxuICAgIGxldCBzdWJzdHJfaW5kZXggPSBzdWJzdHJfaW5kZXhfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBzdWJzdHJfaW5kZXhfZXhuID0gc3Vic3RyX2luZGV4X2V4bl9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9pbmRleF9hbGwgPSBzdWJzdHJfaW5kZXhfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgc3Vic3RyX3JlcGxhY2VfZmlyc3QgPSBzdWJzdHJfcmVwbGFjZV9maXJzdF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9yZXBsYWNlX2FsbCA9IHN1YnN0cl9yZXBsYWNlX2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IGlzX3N1YnN0cmluZyA9IGlzX3N1YnN0cmluZ19nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IGlzX3N1YnN0cmluZ19hdCA9IGlzX3N1YnN0cmluZ19hdF9nZW4gfmNoYXJfZXF1YWw6Q2hhci5DYXNlbGVzcy5lcXVhbFxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG5lbmRcblxubGV0IG9mX3N0cmluZyA9IEZuLmlkXG5sZXQgdG9fc3RyaW5nID0gRm4uaWRcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmluaXQgJWRcIiBuICgpO1xuICBsZXQgdCA9IEJ5dGVzLmNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIEJ5dGVzLnNldCB0IGkgKGYgaSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0XG47O1xuXG5sZXQgdG9fbGlzdCBzID1cbiAgbGV0IHJlYyBsb29wIGFjYyBpID0gaWYgaSA8IDAgdGhlbiBhY2MgZWxzZSBsb29wIChzLltpXSA6OiBhY2MpIChpIC0gMSkgaW5cbiAgbG9vcCBbXSAobGVuZ3RoIHMgLSAxKVxuOztcblxubGV0IHRvX2xpc3RfcmV2IHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGFjYyBpID0gaWYgaSA9IGxlbiB0aGVuIGFjYyBlbHNlIGxvb3AgKHMuW2ldIDo6IGFjYykgKGkgKyAxKSBpblxuICBsb29wIFtdIDBcbjs7XG5cbmxldCByZXYgdCA9XG4gIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzIGkgKHVuc2FmZV9nZXQgdCAobGVuIC0gMSAtIGkpKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnJlc1xuOztcblxuKCoqIEVmZmljaWVudCBzdHJpbmcgc3BsaXR0aW5nICopXG5cbmxldCBsc3BsaXQyX2V4biA9XG4gIGxldCBub3RfZm91bmQgKCkgPSByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcubHNwbGl0Ml9leG46IG5vdCBmb3VuZFwiKSkgaW5cbiAgbGV0IGxzcGxpdDJfZXhuIGxpbmUgfm9uOmRlbGltID1cbiAgICBsZXQgbGVuID0gbGVuZ3RoIGxpbmUgaW5cbiAgICBsZXQgcG9zID0gaW5kZXhfZnJvbV9pbnRlcm5hbCBsaW5lIH5wb3M6MCB+bGVuIH5ub3RfZm91bmQgfmZvdW5kOkZuLmlkIGRlbGltIGluXG4gICAgc3ViIGxpbmUgfnBvczowIH5sZW46cG9zLCBzdWIgbGluZSB+cG9zOihwb3MgKyAxKSB+bGVuOihsZW4gLSBwb3MgLSAxKVxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGxzcGxpdDJfZXhuXG47O1xuXG5sZXQgcnNwbGl0Ml9leG4gPVxuICBsZXQgbm90X2ZvdW5kICgpID0gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLnJzcGxpdDJfZXhuOiBub3QgZm91bmRcIikpIGluXG4gIGxldCByc3BsaXQyX2V4biBsaW5lIH5vbjpkZWxpbSA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCBsaW5lIGluXG4gICAgbGV0IHBvcyA9IHJpbmRleF9mcm9tX2ludGVybmFsIGxpbmUgfnBvczoobGVuIC0gMSkgfm5vdF9mb3VuZCB+Zm91bmQ6Rm4uaWQgZGVsaW0gaW5cbiAgICBzdWIgbGluZSB+cG9zOjAgfmxlbjpwb3MsIHN1YiBsaW5lIH5wb3M6KHBvcyArIDEpIH5sZW46KGxlbiAtIHBvcyAtIDEpXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgcnNwbGl0Ml9leG5cbjs7XG5cbmxldCBsc3BsaXQyIGxpbmUgfm9uID1cbiAgdHJ5IFNvbWUgKGxzcGxpdDJfZXhuIGxpbmUgfm9uKSB3aXRoXG4gIHwgTm90X2ZvdW5kX3MgXyB8IFN0ZGxpYi5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IHJzcGxpdDIgbGluZSB+b24gPVxuICB0cnkgU29tZSAocnNwbGl0Ml9leG4gbGluZSB+b24pIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgU3RkbGliLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcmVjIGNoYXJfbGlzdF9tZW0gbCAoYyA6IGNoYXIpID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gZmFsc2VcbiAgfCBoZCA6OiB0bCAtPiBDaGFyLmVxdWFsIGhkIGMgfHwgY2hhcl9saXN0X21lbSB0bCBjXG47O1xuXG5sZXQgc3BsaXRfZ2VuIHN0ciB+b24gPVxuICBsZXQgaXNfZGVsaW0gPVxuICAgIG1hdGNoIG9uIHdpdGhcbiAgICB8IGBjaGFyIGMnIC0+IGZ1biBjIC0+IENoYXIuZXF1YWwgYyBjJ1xuICAgIHwgYGNoYXJfbGlzdCBsIC0+IGZ1biBjIC0+IGNoYXJfbGlzdF9tZW0gbCBjXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggc3RyIGluXG4gIGxldCByZWMgbG9vcCBhY2MgbGFzdF9wb3MgcG9zID1cbiAgICBpZiBwb3MgPSAtMVxuICAgIHRoZW4gc3ViIHN0ciB+cG9zOjAgfmxlbjpsYXN0X3BvcyA6OiBhY2NcbiAgICBlbHNlIGlmIGlzX2RlbGltIHN0ci5bcG9zXVxuICAgIHRoZW4gKFxuICAgICAgbGV0IHBvczEgPSBwb3MgKyAxIGluXG4gICAgICBsZXQgc3ViX3N0ciA9IHN1YiBzdHIgfnBvczpwb3MxIH5sZW46KGxhc3RfcG9zIC0gcG9zMSkgaW5cbiAgICAgIGxvb3AgKHN1Yl9zdHIgOjogYWNjKSBwb3MgKHBvcyAtIDEpKVxuICAgIGVsc2UgbG9vcCBhY2MgbGFzdF9wb3MgKHBvcyAtIDEpXG4gIGluXG4gIGxvb3AgW10gbGVuIChsZW4gLSAxKVxuOztcblxubGV0IHNwbGl0IHN0ciB+b24gPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXIgb24pXG5sZXQgc3BsaXRfb25fY2hhcnMgc3RyIH5vbjpjaGFycyA9IHNwbGl0X2dlbiBzdHIgfm9uOihgY2hhcl9saXN0IGNoYXJzKVxubGV0IGlzX3N1ZmZpeCBzIH5zdWZmaXggPSBpc19zdWZmaXhfZ2VuIHMgfnN1ZmZpeCB+Y2hhcl9lcXVhbDpDaGFyLmVxdWFsXG5sZXQgaXNfcHJlZml4IHMgfnByZWZpeCA9IGlzX3ByZWZpeF9nZW4gcyB+cHJlZml4IH5jaGFyX2VxdWFsOkNoYXIuZXF1YWxcblxubGV0IGlzX3N1YnN0cmluZ19hdCBzIH5wb3MgfnN1YnN0cmluZyA9XG4gIGlzX3N1YnN0cmluZ19hdF9nZW4gcyB+cG9zIH5zdWJzdHJpbmcgfmNoYXJfZXF1YWw6Q2hhci5lcXVhbFxuOztcblxubGV0IHdyYXBfc3ViX24gdCBuIH5uYW1lIH5wb3MgfmxlbiB+b25fZXJyb3IgPVxuICBpZiBuIDwgMFxuICB0aGVuIGludmFsaWRfYXJnIChuYW1lIF4gXCIgZXhwZWN0aW5nIG5vbm5lZ2F0aXZlIGFyZ3VtZW50XCIpXG4gIGVsc2UgKFxuICAgIHRyeSBzdWIgdCB+cG9zIH5sZW4gd2l0aFxuICAgIHwgXyAtPiBvbl9lcnJvcilcbjs7XG5cbmxldCBkcm9wX3ByZWZpeCB0IG4gPVxuICB3cmFwX3N1Yl9uIH5uYW1lOlwiZHJvcF9wcmVmaXhcIiB0IG4gfnBvczpuIH5sZW46KGxlbmd0aCB0IC0gbikgfm9uX2Vycm9yOlwiXCJcbjs7XG5cbmxldCBkcm9wX3N1ZmZpeCB0IG4gPVxuICB3cmFwX3N1Yl9uIH5uYW1lOlwiZHJvcF9zdWZmaXhcIiB0IG4gfnBvczowIH5sZW46KGxlbmd0aCB0IC0gbikgfm9uX2Vycm9yOlwiXCJcbjs7XG5cbmxldCBwcmVmaXggdCBuID0gd3JhcF9zdWJfbiB+bmFtZTpcInByZWZpeFwiIHQgbiB+cG9zOjAgfmxlbjpuIH5vbl9lcnJvcjp0XG5sZXQgc3VmZml4IHQgbiA9IHdyYXBfc3ViX24gfm5hbWU6XCJzdWZmaXhcIiB0IG4gfnBvczoobGVuZ3RoIHQgLSBuKSB+bGVuOm4gfm9uX2Vycm9yOnRcblxubGV0IGxmaW5kaSA/KHBvcyA9IDApIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZWMgbG9vcCBpID0gaWYgaSA9IG4gdGhlbiBOb25lIGVsc2UgaWYgZiBpIHQuW2ldIHRoZW4gU29tZSBpIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gIGxvb3AgcG9zIFtAbm9udGFpbF1cbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBtYXRjaCBsZmluZGkgdCB+ZjooZnVuIF8gYyAtPiBmIGMpIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGkgLT4gU29tZSB0LltpXVxuOztcblxubGV0IGZpbmRfbWFwIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gblxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggZiB0LltpXSB3aXRoXG4gICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICB8IFNvbWUgXyBhcyByZXMgLT4gcmVzKVxuICBpblxuICBsb29wIDAgW0Bub250YWlsXVxuOztcblxubGV0IHJmaW5kaSA/cG9zIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSA9IGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlIGlmIGYgaSB0LltpXSB0aGVuIFNvbWUgaSBlbHNlIGxvb3AgKGkgLSAxKSBpblxuICBsZXQgcG9zID1cbiAgICBtYXRjaCBwb3Mgd2l0aFxuICAgIHwgU29tZSBwb3MgLT4gcG9zXG4gICAgfCBOb25lIC0+IGxlbmd0aCB0IC0gMVxuICBpblxuICBsb29wIHBvcyBbQG5vbnRhaWxdXG47O1xuXG5sZXQgbGFzdF9ub25fZHJvcCB+ZHJvcCB0ID0gcmZpbmRpIHQgfmY6KGZ1biBfIGMgLT4gbm90IChkcm9wIGMpKSBbQG5vbnRhaWxdXG5cbmxldCByc3RyaXAgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0ID1cbiAgbWF0Y2ggbGFzdF9ub25fZHJvcCB0IH5kcm9wIHdpdGhcbiAgfCBOb25lIC0+IFwiXCJcbiAgfCBTb21lIGkgLT4gaWYgaSA9IGxlbmd0aCB0IC0gMSB0aGVuIHQgZWxzZSBwcmVmaXggdCAoaSArIDEpXG47O1xuXG5sZXQgZmlyc3Rfbm9uX2Ryb3AgfmRyb3AgdCA9IGxmaW5kaSB0IH5mOihmdW4gXyBjIC0+IG5vdCAoZHJvcCBjKSkgW0Bub250YWlsXVxuXG5sZXQgbHN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIG1hdGNoIGZpcnN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICB8IE5vbmUgLT4gXCJcIlxuICB8IFNvbWUgMCAtPiB0XG4gIHwgU29tZSBuIC0+IGRyb3BfcHJlZml4IHQgblxuOztcblxuKCogW3N0cmlwIHRdIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIFtsc3RyaXAgKHJzdHJpcCB0KV0uICBUaGUgaW1wbGVtZW50YXRpb25cbiAgIGJlbG93IHNhdmVzIChhdCBsZWFzdCkgYSBmYWN0b3Igb2YgdHdvIGFsbG9jYXRpb24sIGJ5IG9ubHkgYWxsb2NhdGluZyB0aGVcbiAgIGZpbmFsIHJlc3VsdC4gIFRoaXMgYWxzbyBzYXZlcyBzb21lIGFtb3VudCBvZiB0aW1lLiAqKVxubGV0IHN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwIHx8IG5vdCAoZHJvcCB0LlswXSB8fCBkcm9wIHQuW2xlbmd0aCAtIDFdKVxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgZmlyc3QgLT5cbiAgICAgIChtYXRjaCBsYXN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICB8IFNvbWUgbGFzdCAtPiBzdWIgdCB+cG9zOmZpcnN0IH5sZW46KGxhc3QgLSBmaXJzdCArIDEpKSlcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgbCA9IGxlbmd0aCB0IGluXG4gIGxldCB0JyA9IEJ5dGVzLmNyZWF0ZSBsIGluXG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdCcgaSAoZiBpIHQuW2ldKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnQnXG47O1xuXG4oKiByZXBlYXRlZCBjb2RlIHRvIGF2b2lkIHJlcXVpcmluZyBhbiBleHRyYSBhbGxvY2F0aW9uIGZvciBhIGNsb3N1cmUgb24gZWFjaCBjYWxsLiAqKVxubGV0IG1hcCB0IH5mID1cbiAgbGV0IGwgPSBsZW5ndGggdCBpblxuICBsZXQgdCcgPSBCeXRlcy5jcmVhdGUgbCBpblxuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBCeXRlcy51bnNhZmVfc2V0IHQnIGkgKGYgdC5baV0pXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dCdcbjs7XG5cbmxldCB0b19hcnJheSBzID0gQXJyYXkuaW5pdCAobGVuZ3RoIHMpIH5mOihmdW4gaSAtPiBzLltpXSlcblxubGV0IGV4aXN0cyA9XG4gIGxldCByZWMgbG9vcCBzIGkgfmxlbiB+ZiA9IGkgPCBsZW4gJiYgKGYgcy5baV0gfHwgbG9vcCBzIChpICsgMSkgfmxlbiB+ZikgaW5cbiAgZnVuIHMgfmYgLT4gbG9vcCBzIDAgfmxlbjoobGVuZ3RoIHMpIH5mXG47O1xuXG5sZXQgZm9yX2FsbCA9XG4gIGxldCByZWMgbG9vcCBzIGkgfmxlbiB+ZiA9IGkgPSBsZW4gfHwgKGYgcy5baV0gJiYgbG9vcCBzIChpICsgMSkgfmxlbiB+ZikgaW5cbiAgZnVuIHMgfmYgLT4gbG9vcCBzIDAgfmxlbjoobGVuZ3RoIHMpIH5mXG47O1xuXG5sZXQgZm9sZCA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWMgfmYgfmxlbiA9XG4gICAgaWYgaSA9IGxlbiB0aGVuIGFjIGVsc2UgbG9vcCB0IChpICsgMSkgKGYgYWMgdC5baV0pIH5mIH5sZW5cbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IDAgaW5pdCB+ZiB+bGVuOihsZW5ndGggdClcbjs7XG5cbmxldCBmb2xkaSA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWMgfmYgfmxlbiA9XG4gICAgaWYgaSA9IGxlbiB0aGVuIGFjIGVsc2UgbG9vcCB0IChpICsgMSkgKGYgaSBhYyB0LltpXSkgfmYgfmxlblxuICBpblxuICBmdW4gdCB+aW5pdCB+ZiAtPiBsb29wIHQgMCBpbml0IH5mIH5sZW46KGxlbmd0aCB0KVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZVxuOztcblxubGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHRcbmxldCBtYXhfZWx0IHQgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0XG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0IH5maW5pc2hcbmxldCBmaW5kX21hcGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmZpbmRfbWFwaSB+aXRlcmkgdCB+ZlxubGV0IGZpbmRpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5maW5kaSB+aXRlcmkgdCB+ZlxubGV0IGNvdW50aSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuY291bnRpIH5mb2xkaSB0IH5mXG5sZXQgZm9yX2FsbGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmZvcl9hbGxpIH5pdGVyaSB0IH5mXG5sZXQgZXhpc3RzaSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuZXhpc3RzaSB+aXRlcmkgdCB+ZlxuXG5sZXQgbWVtID1cbiAgbGV0IHJlYyBsb29wIHQgYyB+cG9zOmkgfmxlbiA9XG4gICAgaSA8IGxlbiAmJiAoQ2hhci5lcXVhbCBjICh1bnNhZmVfZ2V0IHQgaSkgfHwgbG9vcCB0IGMgfnBvczooaSArIDEpIH5sZW4pXG4gIGluXG4gIGZ1biB0IGMgLT4gbG9vcCB0IGMgfnBvczowIH5sZW46KGxlbmd0aCB0KVxuOztcblxubGV0IHRyIH50YXJnZXQgfnJlcGxhY2VtZW50IHMgPVxuICBpZiBDaGFyLmVxdWFsIHRhcmdldCByZXBsYWNlbWVudFxuICB0aGVuIHNcbiAgZWxzZSBpZiBtZW0gcyB0YXJnZXRcbiAgdGhlbiBtYXAgcyB+ZjooZnVuIGMgLT4gaWYgQ2hhci5lcXVhbCBjIHRhcmdldCB0aGVuIHJlcGxhY2VtZW50IGVsc2UgYylcbiAgZWxzZSBzXG47O1xuXG5sZXQgdHJfbXVsdGkgfnRhcmdldCB+cmVwbGFjZW1lbnQgPVxuICBpZiBpc19lbXB0eSB0YXJnZXRcbiAgdGhlbiBzdGFnZSBGbi5pZFxuICBlbHNlIGlmIGlzX2VtcHR5IHJlcGxhY2VtZW50XG4gIHRoZW4gaW52YWxpZF9hcmcgXCJ0cl9tdWx0aSByZXBsYWNlbWVudCBpcyBlbXB0eSBzdHJpbmdcIlxuICBlbHNlIChcbiAgICBtYXRjaCBCeXRlc190ci50cl9jcmVhdGVfbWFwIH50YXJnZXQgfnJlcGxhY2VtZW50IHdpdGhcbiAgICB8IE5vbmUgLT4gc3RhZ2UgRm4uaWRcbiAgICB8IFNvbWUgdHJfbWFwIC0+XG4gICAgICBzdGFnZSAoZnVuIHMgLT5cbiAgICAgICAgaWYgZXhpc3RzIHMgfmY6KGZ1biBjIC0+IENoYXIuKCA8PiApIGMgKHVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCBjKSkpXG4gICAgICAgIHRoZW4gbWFwIHMgfmY6KGZ1biBjIC0+IHVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCBjKSlcbiAgICAgICAgZWxzZSBzKSlcbjs7XG5cbigqIGZhc3QgdmVyc2lvbiwgaWYgd2UgZXZlciBuZWVkIGl0OlxuICAge1tcbiAgICAgbGV0IGNvbmNhdF9hcnJheSB+c2VwIGFyID1cbiAgICAgICBsZXQgYXJfbGVuID0gQXJyYXkubGVuZ3RoIGFyIGluXG4gICAgICAgaWYgYXJfbGVuID0gMCB0aGVuIFwiXCJcbiAgICAgICBlbHNlXG4gICAgICAgICBsZXQgc2VwX2xlbiA9IGxlbmd0aCBzZXAgaW5cbiAgICAgICAgIGxldCByZXNfbGVuX3JlZiA9IHJlZiAoc2VwX2xlbiAqIChhcl9sZW4gLSAxKSkgaW5cbiAgICAgICAgIGZvciBpID0gMCB0byBhcl9sZW4gLSAxIGRvXG4gICAgICAgICAgIHJlc19sZW5fcmVmIDo9ICFyZXNfbGVuX3JlZiArIGxlbmd0aCBhci4oaSlcbiAgICAgICAgIGRvbmU7XG4gICAgICAgICBsZXQgcmVzID0gY3JlYXRlICFyZXNfbGVuX3JlZiBpblxuICAgICAgICAgbGV0IHN0cl8wID0gYXIuKDApIGluXG4gICAgICAgICBsZXQgbGVuXzAgPSBsZW5ndGggc3RyXzAgaW5cbiAgICAgICAgIGJsaXQgfnNyYzpzdHJfMCB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOjAgfmxlbjpsZW5fMDtcbiAgICAgICAgIGxldCBwb3NfcmVmID0gcmVmIGxlbl8wIGluXG4gICAgICAgICBmb3IgaSA9IDEgdG8gYXJfbGVuIC0gMSBkb1xuICAgICAgICAgICBsZXQgcG9zID0gIXBvc19yZWYgaW5cbiAgICAgICAgICAgYmxpdCB+c3JjOnNlcCB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOnBvcyB+bGVuOnNlcF9sZW47XG4gICAgICAgICAgIGxldCBuZXdfcG9zID0gcG9zICsgc2VwX2xlbiBpblxuICAgICAgICAgICBsZXQgc3RyX2kgPSBhci4oaSkgaW5cbiAgICAgICAgICAgbGV0IGxlbl9pID0gbGVuZ3RoIHN0cl9pIGluXG4gICAgICAgICAgIGJsaXQgfnNyYzpzdHJfaSB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOm5ld19wb3MgfmxlbjpsZW5faTtcbiAgICAgICAgICAgcG9zX3JlZiA6PSBuZXdfcG9zICsgbGVuX2lcbiAgICAgICAgIGRvbmU7XG4gICAgICAgICByZXNcbiAgIF19ICopXG5cbmxldCBjb25jYXRfYXJyYXkgP3NlcCBhciA9IGNvbmNhdCA/c2VwIChBcnJheS50b19saXN0IGFyKVxubGV0IGNvbmNhdF9tYXAgP3NlcCBzIH5mID0gY29uY2F0X2FycmF5ID9zZXAgKEFycmF5Lm1hcCAodG9fYXJyYXkgcykgfmYpXG5sZXQgY29uY2F0X21hcGkgP3NlcCB0IH5mID0gY29uY2F0X2FycmF5ID9zZXAgKEFycmF5Lm1hcGkgKHRvX2FycmF5IHQpIH5mKVxuXG5sZXQgY29uY2F0X2xpbmVzID1cbiAgbGV0IHJlYyBsaW5lX2xlbmd0aHMgfmxpbmVzIH5uZXdsaW5lX2xlbiB+c3VtID1cbiAgICBtYXRjaCBsaW5lcyB3aXRoXG4gICAgfCBbXSAtPiBzdW1cbiAgICB8IGxpbmUgOjogbGluZXMgLT5cbiAgICAgIGxldCBzdW0gPSBzdW0gKyBTdHJpbmcubGVuZ3RoIGxpbmUgKyBuZXdsaW5lX2xlbiBpblxuICAgICAgbGluZV9sZW5ndGhzIH5saW5lcyB+bmV3bGluZV9sZW4gfnN1bVxuICBpblxuICBsZXQgcmVjIHdyaXRlX2xpbmVzIH5idWYgfmxpbmVzIH5jcmxmIH5wb3MgPVxuICAgIG1hdGNoIGxpbmVzIHdpdGhcbiAgICB8IFtdIC0+IHBvc1xuICAgIHwgbGluZSA6OiBsaW5lcyAtPlxuICAgICAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nXG4gICAgICAgIH5zcmM6bGluZVxuICAgICAgICB+c3JjX3BvczowXG4gICAgICAgIH5kc3Q6YnVmXG4gICAgICAgIH5kc3RfcG9zOnBvc1xuICAgICAgICB+bGVuOihTdHJpbmcubGVuZ3RoIGxpbmUpO1xuICAgICAgbGV0IHBvcyA9IHBvcyArIFN0cmluZy5sZW5ndGggbGluZSBpblxuICAgICAgbGV0IHBvcyA9XG4gICAgICAgIGlmIGNybGZcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBidWYgcG9zICdcXHInO1xuICAgICAgICAgIHBvcyArIDEpXG4gICAgICAgIGVsc2UgcG9zXG4gICAgICBpblxuICAgICAgQnl0ZXMudW5zYWZlX3NldCBidWYgcG9zICdcXG4nO1xuICAgICAgbGV0IHBvcyA9IHBvcyArIDEgaW5cbiAgICAgIHdyaXRlX2xpbmVzIH5idWYgfmxpbmVzIH5jcmxmIH5wb3NcbiAgaW5cbiAgZnVuID8oY3JsZiA9IGZhbHNlKSBsaW5lcyAtPlxuICAgIGxldCBuZXdsaW5lX2xlbiA9IGlmIGNybGYgdGhlbiAyIGVsc2UgMSBpblxuICAgIGxldCBsZW4gPSBsaW5lX2xlbmd0aHMgfm5ld2xpbmVfbGVuIH5saW5lcyB+c3VtOjAgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCB3cml0dGVuID0gd3JpdGVfbGluZXMgfmJ1ZiB+bGluZXMgfmNybGYgfnBvczowIGluXG4gICAgYXNzZXJ0ICh3cml0dGVuID0gbGVuKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmJ1ZlxuOztcblxuKCogW2ZpbHRlciB0IGZdIGlzIGltcGxlbWVudGVkIGJ5IHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtLlxuXG4gICBMZXQgW24gPSBsZW5ndGggdF0uXG5cbiAgIDEuIEZpbmQgdGhlIGxvd2VzdCBbaV0gc3VjaCB0aGF0IFtub3QgKGYgdC5baV0pXS5cblxuICAgMi4gSWYgdGhlcmUgaXMgbm8gc3VjaCBbaV0sIHRoZW4gcmV0dXJuIFt0XS5cblxuICAgMy4gSWYgdGhlcmUgaXMgc3VjaCBhbiBbaV0sIGFsbG9jYXRlIGEgc3RyaW5nLCBbb3V0XSwgdG8gaG9sZCB0aGUgcmVzdWx0LiAgW291dF0gaGFzXG4gICBsZW5ndGggW24gLSAxXSwgd2hpY2ggaXMgdGhlIG1heGltdW0gcG9zc2libGUgb3V0cHV0IHNpemUgZ2l2ZW4gdGhhdCB0aGVyZSBpcyBhdCBsZWFzdFxuICAgb25lIGNoYXJhY3RlciBub3Qgc2F0aXNmeWluZyBbZl0uXG5cbiAgIDQuIENvcHkgY2hhcmFjdGVycyBhdCBpbmRpY2VzIDAgLi4uIFtpIC0gMV0gZnJvbSBbdF0gdG8gW291dF0uXG5cbiAgIDUuIFdhbGsgdGhyb3VnaCBjaGFyYWN0ZXJzIGF0IGluZGljZXMgW2krMV0gLi4uIFtuLTFdIG9mIFt0XSwgY29weWluZyB0aG9zZSB0aGF0XG4gICBzYXRpc2Z5IFtmXSBmcm9tIFt0XSB0byBbb3V0XS5cblxuICAgNi4gSWYgd2UgY29tcGxldGVseSBmaWxsZWQgW291dF0sIHRoZW4gcmV0dXJuIGl0LiAgSWYgbm90LCByZXR1cm4gdGhlIHByZWZpeCBvZiBbb3V0XVxuICAgdGhhdCB3ZSBkaWQgZmlsbCBpbi5cblxuICAgVGhpcyBhbGdvcml0aG0gaGFzIHRoZSBwcm9wZXJ0eSB0aGF0IGl0IGRvZXNuJ3QgYWxsb2NhdGUgYSBuZXcgc3RyaW5nIGlmIHRoZXJlJ3NcbiAgIG5vdGhpbmcgdG8gZmlsdGVyLCB3aGljaCBpcyBhIGNvbW1vbiBjYXNlLiAqKVxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbiAmJiBmIHQuWyFpXSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBpZiAhaSA9IG5cbiAgdGhlbiB0XG4gIGVsc2UgKFxuICAgIGxldCBvdXQgPSBCeXRlcy5jcmVhdGUgKG4gLSAxKSBpblxuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6dCB+c3JjX3BvczowIH5kc3Q6b3V0IH5kc3RfcG9zOjAgfmxlbjohaTtcbiAgICBsZXQgb3V0X3BvcyA9IHJlZiAhaSBpblxuICAgIGluY3IgaTtcbiAgICB3aGlsZSAhaSA8IG4gZG9cbiAgICAgIGxldCBjID0gdC5bIWldIGluXG4gICAgICBpZiBmIGNcbiAgICAgIHRoZW4gKFxuICAgICAgICBCeXRlcy5zZXQgb3V0ICFvdXRfcG9zIGM7XG4gICAgICAgIGluY3Igb3V0X3Bvcyk7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgIGxldCBvdXQgPSBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOm91dCBpblxuICAgIGlmICFvdXRfcG9zID0gbiAtIDEgdGhlbiBvdXQgZWxzZSBzdWIgb3V0IH5wb3M6MCB+bGVuOiFvdXRfcG9zKVxuOztcblxuKCogcmVwZWF0ZWQgY29kZSB0byBhdm9pZCByZXF1aXJpbmcgYW4gZXh0cmEgYWxsb2NhdGlvbiBmb3IgYSBjbG9zdXJlIG9uIGVhY2ggY2FsbC4gKilcbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBuICYmIGYgIWkgdC5bIWldIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGlmICFpID0gblxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbGV0IG91dCA9IEJ5dGVzLmNyZWF0ZSAobiAtIDEpIGluXG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzp0IH5zcmNfcG9zOjAgfmRzdDpvdXQgfmRzdF9wb3M6MCB+bGVuOiFpO1xuICAgIGxldCBvdXRfcG9zID0gcmVmICFpIGluXG4gICAgaW5jciBpO1xuICAgIHdoaWxlICFpIDwgbiBkb1xuICAgICAgbGV0IGMgPSB0LlshaV0gaW5cbiAgICAgIGlmIGYgIWkgY1xuICAgICAgdGhlbiAoXG4gICAgICAgIEJ5dGVzLnNldCBvdXQgIW91dF9wb3MgYztcbiAgICAgICAgaW5jciBvdXRfcG9zKTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgbGV0IG91dCA9IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6b3V0IGluXG4gICAgaWYgIW91dF9wb3MgPSBuIC0gMSB0aGVuIG91dCBlbHNlIHN1YiBvdXQgfnBvczowIH5sZW46IW91dF9wb3MpXG47O1xuXG5sZXQgY2hvcF9wcmVmaXggcyB+cHJlZml4ID1cbiAgaWYgaXNfcHJlZml4IHMgfnByZWZpeCB0aGVuIFNvbWUgKGRyb3BfcHJlZml4IHMgKGxlbmd0aCBwcmVmaXgpKSBlbHNlIE5vbmVcbjs7XG5cbmxldCBjaG9wX3ByZWZpeF9pZl9leGlzdHMgcyB+cHJlZml4ID1cbiAgaWYgaXNfcHJlZml4IHMgfnByZWZpeCB0aGVuIGRyb3BfcHJlZml4IHMgKGxlbmd0aCBwcmVmaXgpIGVsc2Ugc1xuOztcblxubGV0IGNob3BfcHJlZml4X2V4biBzIH5wcmVmaXggPVxuICBtYXRjaCBjaG9wX3ByZWZpeCBzIH5wcmVmaXggd2l0aFxuICB8IFNvbWUgc3RyIC0+IHN0clxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmNob3BfcHJlZml4X2V4biAlUyAlU1wiIHMgcHJlZml4ICgpXG47O1xuXG5sZXQgY2hvcF9zdWZmaXggcyB+c3VmZml4ID1cbiAgaWYgaXNfc3VmZml4IHMgfnN1ZmZpeCB0aGVuIFNvbWUgKGRyb3Bfc3VmZml4IHMgKGxlbmd0aCBzdWZmaXgpKSBlbHNlIE5vbmVcbjs7XG5cbmxldCBjaG9wX3N1ZmZpeF9pZl9leGlzdHMgcyB+c3VmZml4ID1cbiAgaWYgaXNfc3VmZml4IHMgfnN1ZmZpeCB0aGVuIGRyb3Bfc3VmZml4IHMgKGxlbmd0aCBzdWZmaXgpIGVsc2Ugc1xuOztcblxubGV0IGNob3Bfc3VmZml4X2V4biBzIH5zdWZmaXggPVxuICBtYXRjaCBjaG9wX3N1ZmZpeCBzIH5zdWZmaXggd2l0aFxuICB8IFNvbWUgc3RyIC0+IHN0clxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmNob3Bfc3VmZml4X2V4biAlUyAlU1wiIHMgc3VmZml4ICgpXG47O1xuXG5tb2R1bGUgRm9yX2NvbW1vbl9wcmVmaXhfYW5kX3N1ZmZpeCA9IHN0cnVjdFxuICAoKiBXaGVuIHRha2luZyBhIHN0cmluZyBwcmVmaXggb3Igc3VmZml4LCB3ZSBleHRyYWN0IGZyb20gdGhlIHNob3J0ZXN0IGlucHV0IGF2YWlsYWJsZVxuICAgICBpbiBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiBvbmUgb2Ygb3VyIGlucHV0cyB3aXRob3V0IGFsbG9jYXRpbmcgYSBuZXcgc3RyaW5nLiAqKVxuXG4gIGxldCBzaG9ydGVyIGEgYiA9IGlmIGxlbmd0aCBhIDw9IGxlbmd0aCBiIHRoZW4gYSBlbHNlIGJcblxuICBsZXQgc2hvcnRlc3QgbGlzdCA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBcIlwiXG4gICAgfCBmaXJzdCA6OiByZXN0IC0+IExpc3QuZm9sZCByZXN0IH5pbml0OmZpcnN0IH5mOnNob3J0ZXJcbiAgOztcblxuICAoKiBPdXIgZ2VuZXJpYyBhY2Nlc3NvcnMgZm9yIGNvbW1vbiBwcmVmaXgvc3VmZml4IGFic3RyYWN0IG92ZXIgW2dldF9wb3NdLCB3aGljaCBpc1xuICAgICBlaXRoZXIgW3Bvc19mcm9tX2xlZnRdIG9yIFtwb3NfZnJvbV9yaWdodF0uICopXG5cbiAgbGV0IHBvc19mcm9tX2xlZnQgKF8gOiB0KSAoaSA6IGludCkgPSBpXG4gIGxldCBwb3NfZnJvbV9yaWdodCB0IGkgPSBsZW5ndGggdCAtIGkgLSAxXG5cbiAgbGV0IHJlYyBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgYSBiIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyID1cbiAgICBpZiBsZW5fc29fZmFyID49IG1heF9sZW5cbiAgICB0aGVuIG1heF9sZW5cbiAgICBlbHNlIGlmIENoYXIuZXF1YWxcbiAgICAgICAgICAgICAgKHVuc2FmZV9nZXQgYSAoZ2V0X3BvcyBhIGxlbl9zb19mYXIpKVxuICAgICAgICAgICAgICAodW5zYWZlX2dldCBiIChnZXRfcG9zIGIgbGVuX3NvX2ZhcikpXG4gICAgdGhlbiBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgYSBiIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyOihsZW5fc29fZmFyICsgMSlcbiAgICBlbHNlIGxlbl9zb19mYXJcbiAgOztcblxuICBsZXQgY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3MgPVxuICAgIGxldCBtYXhfbGVuID0gbWluIChsZW5ndGggYSkgKGxlbmd0aCBiKSBpblxuICAgIGNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCBhIGIgfmdldF9wb3Mgfm1heF9sZW4gfmxlbl9zb19mYXI6MFxuICA7O1xuXG4gIGxldCByZWMgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AgZmlyc3QgbGlzdCB+Z2V0X3BvcyB+bWF4X2xlbiA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBtYXhfbGVuXG4gICAgfCBzZWNvbmQgOjogcmVzdCAtPlxuICAgICAgbGV0IG1heF9sZW4gPVxuICAgICAgICAoKiBXZSBjYWxsIFtjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3BdIHJhdGhlciB0aGFuIFtjb21tb25fZ2VuZXJpYzJfbGVuZ3RoXSBzb1xuICAgICAgICAgICB0aGF0IFttYXhfbGVuXSBsaW1pdHMgb3VyIHRyYXZlcnNhbCBvZiBbZmlyc3RdIGFuZCBbc2Vjb25kXS4gKilcbiAgICAgICAgY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wIGZpcnN0IHNlY29uZCB+Z2V0X3BvcyB+bWF4X2xlbiB+bGVuX3NvX2ZhcjowXG4gICAgICBpblxuICAgICAgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3Agc2Vjb25kIHJlc3QgfmdldF9wb3Mgfm1heF9sZW5cbiAgOztcblxuICBsZXQgY29tbW9uX2dlbmVyaWNfbGVuZ3RoIGxpc3QgfmdldF9wb3MgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gMFxuICAgIHwgZmlyc3QgOjogcmVzdCAtPlxuICAgICAgKCogUHJlY29tcHV0aW5nIFttYXhfbGVuXSBiYXNlZCBvbiBbc2hvcnRlc3QgbGlzdF0gc2F2ZXMgdXMgd29yayBpbiBsb25nZXIgc3RyaW5ncyxcbiAgICAgICAgIGF0IHRoZSBjb3N0IG9mIGFuIGV4dHJhIHBhc3Mgb3ZlciB0aGUgc3BpbmUgb2YgW2xpc3RdLlxuXG4gICAgICAgICBGb3IgZXhhbXBsZSwgaWYgeW91J3JlIGxvb2tpbmcgZm9yIHRoZSBsb25nZXN0IHByZWZpeCBvZiB0aGUgc3RyaW5nczpcblxuICAgICAgICAge3ZcbiAgICAgICAgICAgIGxldCBsb25nX2EgPSBMaXN0LmluaXQgMTAwMCB+ZjooRm4uY29uc3QgJ2EnKVxuICAgICAgICAgICAgWyBsb25nX2E7IGxvbmdfYTsgJ2FhJyBdXG4gICAgICAgICB2fVxuXG4gICAgICAgICB0aGUgYXBwcm9hY2ggYmVsb3cgd2lsbCBqdXN0IGNoZWNrIHRoZSBmaXJzdCB0d28gY2hhcmFjdGVycyBvZiBhbGwgdGhlIHN0cmluZ3MuXG4gICAgICAqKVxuICAgICAgbGV0IG1heF9sZW4gPSBsZW5ndGggKHNob3J0ZXN0IGxpc3QpIGluXG4gICAgICBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBmaXJzdCByZXN0IH5nZXRfcG9zIH5tYXhfbGVuXG4gIDs7XG5cbiAgKCogT3VyIGdlbmVyaWMgYWNjZXNzb3JzIHRoYXQgcHJvZHVjZSBhIHN0cmluZyBhYnN0cmFjdCBvdmVyIFt0YWtlXSwgd2hpY2ggaXMgZWl0aGVyXG4gICAgIFtwcmVmaXhdIG9yIFtzdWZmaXhdLiAqKVxuXG4gIGxldCBjb21tb25fZ2VuZXJpYzIgYSBiIH5nZXRfcG9zIH50YWtlID1cbiAgICBsZXQgbGVuID0gY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3MgaW5cbiAgICAoKiBVc2UgdGhlIHNob3J0ZXIgb2YgdGhlIHR3byBzdHJpbmdzLCBzbyB0aGF0IGlmIHRoZSBzaG9ydGVyIG9uZSBpcyB0aGUgc2hhcmVkXG4gICAgICAgcHJlZml4LCBbdGFrZV0gd29uJ3QgYWxsb2NhdGUgYW5vdGhlciBzdHJpbmcuICopXG4gICAgdGFrZSAoc2hvcnRlciBhIGIpIGxlblxuICA7O1xuXG4gIGxldCBjb21tb25fZ2VuZXJpYyBsaXN0IH5nZXRfcG9zIH50YWtlID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IFwiXCJcbiAgICB8IGZpcnN0IDo6IHJlc3QgLT5cbiAgICAgICgqIEFzIHdpdGggW2NvbW1vbl9nZW5lcmljX2xlbmd0aF0sIHdlIGJhc2UgW21heF9sZW5dIG9uIFtzaG9ydGVzdCBsaXN0XS4gV2UgYWxzb1xuICAgICAgICAgdXNlIHRoaXMgcmVzdWx0IGZvciBbdGFrZV0sIGJlbG93LCB0byBwb3RlbnRpYWxseSBhdm9pZCBhbGxvY2F0aW5nIGEgc3RyaW5nLiAqKVxuICAgICAgbGV0IHMgPSBzaG9ydGVzdCBsaXN0IGluXG4gICAgICBsZXQgbWF4X2xlbiA9IGxlbmd0aCBzIGluXG4gICAgICBpZiBtYXhfbGVuID0gMFxuICAgICAgdGhlbiBcIlwiXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxlbiA9XG4gICAgICAgICAgKCogV2UgY2FsbCBkaXJlY3RseSBpbnRvIFtjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcF0gcmF0aGVyIHRoYW5cbiAgICAgICAgICAgICBbY29tbW9uX2dlbmVyaWNfbGVuZ3RoXSB0byBhdm9pZCByZWNvbXB1dGluZyBbc2hvcnRlc3QgbGlzdF0uICopXG4gICAgICAgICAgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AgZmlyc3QgcmVzdCB+Z2V0X3BvcyB+bWF4X2xlblxuICAgICAgICBpblxuICAgICAgICB0YWtlIHMgbGVuKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgc3RydWN0XG4gIG9wZW4gRm9yX2NvbW1vbl9wcmVmaXhfYW5kX3N1ZmZpeFxuXG4gIGxldCBjb21tb25fcHJlZml4IGxpc3QgPSBjb21tb25fZ2VuZXJpYyBsaXN0IH50YWtlOnByZWZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4IGxpc3QgPSBjb21tb25fZ2VuZXJpYyBsaXN0IH50YWtlOnN1ZmZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuICBsZXQgY29tbW9uX3ByZWZpeDIgYSBiID0gY29tbW9uX2dlbmVyaWMyIGEgYiB+dGFrZTpwcmVmaXggfmdldF9wb3M6cG9zX2Zyb21fbGVmdFxuICBsZXQgY29tbW9uX3N1ZmZpeDIgYSBiID0gY29tbW9uX2dlbmVyaWMyIGEgYiB+dGFrZTpzdWZmaXggfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbiAgbGV0IGNvbW1vbl9wcmVmaXhfbGVuZ3RoIGxpc3QgPSBjb21tb25fZ2VuZXJpY19sZW5ndGggbGlzdCB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4X2xlbmd0aCBsaXN0ID0gY29tbW9uX2dlbmVyaWNfbGVuZ3RoIGxpc3QgfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbiAgbGV0IGNvbW1vbl9wcmVmaXgyX2xlbmd0aCBhIGIgPSBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4Ml9sZW5ndGggYSBiID0gY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbmVuZFxuXG4oKiBUaGVyZSB1c2VkIHRvIGJlIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uIHRoYXQgd2FzIGZhc3RlciBmb3IgdmVyeSBzaG9ydCBzdHJpbmdzXG4gICAocGVha2luZyBhdCA0MCUgZmFzdGVyIGZvciA0LTYgY2hhciBsb25nIHN0cmluZ3MpLlxuICAgVGhpcyBuZXcgZnVuY3Rpb24gaXMgYXJvdW5kIDIwJSBmYXN0ZXIgdGhhbiB0aGUgZGVmYXVsdCBoYXNoIGZ1bmN0aW9uLCBidXQgc2xvd2VyXG4gICB0aGFuIHRoZSBwcmV2aW91cyBjdXN0b20gaW1wbGVtZW50YXRpb24uIEhvd2V2ZXIsIHRoZSBuZXcgT0NhbWwgZnVuY3Rpb24gaXMgd2VsbFxuICAgYmVoYXZlZCwgYW5kIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbGVzcyBsaWtlbHkgdG8gZGl2ZXJnZSBmcm9tIHRoZSBkZWZhdWx0IE9DYW1sXG4gICBpbXBsZW1lbnRhdGlvbiBkb2VzLCB3aGljaCBpcyBhIGRlc2lyYWJsZSBwcm9wZXJ0eS4gKFRoZSBvbmx5IHdheSB0byBhdm9pZCB0aGVcbiAgIGRpdmVyZ2VuY2UgaXMgdG8gZXhwb3NlIHRoZSBtYWNybyByZWRlZmluZWQgaW4gaGFzaF9zdHVicy5jIGluIHRoZSBoYXNoLmggaGVhZGVyIG9mXG4gICB0aGUgT0NhbWwgY29tcGlsZXIuKSAqKVxubW9kdWxlIEhhc2ggPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgaGFzaCA6IHN0cmluZyAtPiBpbnQgPSBcIkJhc2VfaGFzaF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZW5kXG5cbigqIFtpbmNsdWRlIEhhc2hdIHRvIG1ha2UgdGhlIFtleHRlcm5hbF0gdmVyc2lvbiBvdmVycmlkZSB0aGUgW2hhc2hdIGZyb21cbiAgIFtIYXNoYWJsZS5NYWtlX2JpbmFibGVdLCBzbyB0aGF0IHdlIGdldCBhIGxpdHRsZSBiaXQgb2YgYSBzcGVlZHVwIGJ5IGV4cG9zaW5nIGl0IGFzXG4gICBleHRlcm5hbCBpbiB0aGUgbWxpLiAqKVxubGV0IF8gPSBoYXNoXG5cbmluY2x1ZGUgSGFzaFxuXG4oKiBmb3IgaW50ZXJhY3RpdmUgdG9wLWxldmVscyAtLSBtb2R1bGVzIGRlcml2aW5nIGZyb20gU3RyaW5nIHNob3VsZCBoYXZlIFN0cmluZydzIHByZXR0eVxuICAgcHJpbnRlci4gKilcbmxldCBwcCBwcGYgc3RyaW5nID0gU3RkbGliLkZvcm1hdC5mcHJpbnRmIHBwZiBcIiVTXCIgc3RyaW5nXG5sZXQgb2ZfY2hhciBjID0gbWFrZSAxIGNcblxubGV0IG9mX2NoYXJfbGlzdCBsID1cbiAgbGV0IHQgPSBCeXRlcy5jcmVhdGUgKExpc3QubGVuZ3RoIGwpIGluXG4gIExpc3QuaXRlcmkgbCB+ZjooZnVuIGkgYyAtPiBCeXRlcy5zZXQgdCBpIGMpO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnRcbjs7XG5cbmxldCBvZl9saXN0ID0gb2ZfY2hhcl9saXN0XG5sZXQgb2ZfYXJyYXkgYSA9IGluaXQgKEFycmF5Lmxlbmd0aCBhKSB+ZjooQXJyYXkuZ2V0IGEpXG5cbmxldCB0b19zZXF1ZW5jZSB0ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OjAgfmY6KGZ1biBwb3MgLT5cbiAgICBpZiBwb3MgPj0gbGVuIHRoZW4gRG9uZSBlbHNlIFlpZWxkIHsgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgcG9zOyBzdGF0ZSA9IHBvcyArIDEgfSlcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZSBzID0gb2ZfbGlzdCAoU2VxdWVuY2UudG9fbGlzdCBzKVxubGV0IGFwcGVuZCA9ICggXiApXG5cbmxldCBwYWRfcmlnaHQgPyhjaGFyID0gJyAnKSBzIH5sZW4gPVxuICBsZXQgc3JjX2xlbiA9IGxlbmd0aCBzIGluXG4gIGlmIHNyY19sZW4gPj0gbGVuXG4gIHRoZW4gc1xuICBlbHNlIChcbiAgICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6cyB+ZHN0OnJlcyB+c3JjX3BvczowIH5kc3RfcG9zOjAgfmxlbjpzcmNfbGVuO1xuICAgIEJ5dGVzLmZpbGwgfnBvczpzcmNfbGVuIH5sZW46KGxlbiAtIHNyY19sZW4pIHJlcyBjaGFyO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6cmVzKVxuOztcblxubGV0IHBhZF9sZWZ0ID8oY2hhciA9ICcgJykgcyB+bGVuID1cbiAgbGV0IHNyY19sZW4gPSBsZW5ndGggcyBpblxuICBpZiBzcmNfbGVuID49IGxlblxuICB0aGVuIHNcbiAgZWxzZSAoXG4gICAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnMgfmRzdDpyZXMgfnNyY19wb3M6MCB+ZHN0X3BvczoobGVuIC0gc3JjX2xlbikgfmxlbjpzcmNfbGVuO1xuICAgIEJ5dGVzLmZpbGwgfnBvczowIH5sZW46KGxlbiAtIHNyY19sZW4pIHJlcyBjaGFyO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6cmVzKVxuOztcblxuKCogQ2FsbGVkIHVwb24gZmlyc3QgZGlmZmVyZW5jZSBnZW5lcmF0ZWQgYnkgZmlsdGVyaW5nLiBBbGxvY2F0ZXMgW2J1ZmZlcl9sZW5dIGJ5dGVzXG4gICBmb3IgbmV3IHJlc3VsdCwgYW5kIGNvcGllcyBbcHJlZml4X2xlbl0gdW5jaGFuZ2VkIGNoYXJhY3RlcnMgZnJvbSBbc3JjXS5cbiAgIEFsd2F5cyByZXR1cm5zIGEgbG9jYWwgYnVmZmVyLiAqKVxubGV0IGxvY2FsX2NvcHlfcHJlZml4IHNyYyB+cHJlZml4X2xlbiB+YnVmZmVyX2xlbiA9XG4gIGxldCBkc3QgPSBCeXRlcy5jcmVhdGVfbG9jYWwgYnVmZmVyX2xlbiBpblxuICBCeXRlcy5QcmltaXRpdmVzLnVuc2FmZV9ibGl0X3N0cmluZyB+c3JjIH5kc3QgfnNyY19wb3M6MCB+ZHN0X3BvczowIH5sZW46cHJlZml4X2xlbjtcbiAgZHN0XG47O1xuXG4oKiBDb3BpZXMgYSBwZXJoYXBzLWxvY2FsIGJ1ZmZlciBpbnRvIGEgZGVmaW5pdGVseS1nbG9iYWwgc3RyaW5nLiAqKVxubGV0IGxvY2FsX2NvcHlfdG9fc3RyaW5nIGJ1ZiB+cG9zID1cbiAgbGV0IHN0ciA9IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6YnVmIGluXG4gIHVuc2FmZV9zdWIgc3RyIH5wb3M6MCB+bGVuOnBvcyBbQG5vbnRhaWxdXG47O1xuXG5pbmNsdWRlIHN0cnVjdFxuICBvcGVuIHN0cnVjdFxuICAgICgqIGZpbHRlcl9tYXAgaGVscGVycyAqKVxuXG4gICAgKCogRmlsdGVycyBmcm9tIHN0cmluZyBbc3JjXSBpbnRvIGFuIGFsbG9jYXRlZCBidWZmZXIgW2RzdF07XG4gICAgICAgY29waWVzIHRoZSBhbGxvY2F0ZWQgYnVmZmVyIHRvIGEgaGVhcC1hbGxvY2F0ZWQgcmVzdWx0IHN0cmluZy5cblxuICAgICAgIFByZS1jb25kaXRpb25zOlxuICAgICAgIFtzcmNfbGVuID0gbGVuZ3RoIHNyY11cbiAgICAgICBbc3JjICE9IGRzdF1cbiAgICAgICBbMCA8PSBzcmNfcG9zIDwgc3JjX2xlbl1cbiAgICAgICBbMCA8PSBkc3RfcG9zIDwgbGVuZ3RoIGRzdF1cbiAgICAqKVxuICAgIGxldCBmaWx0ZXJfbWFwaV9pbnRvIHNyYyBkc3QgfmYgfnNyY19wb3MgfmRzdF9wb3MgfnNyY19sZW4gPVxuICAgICAgbGV0IGRzdF9wb3MgPSByZWYgZHN0X3BvcyBpblxuICAgICAgZm9yIHNyY19wb3MgPSBzcmNfcG9zIHRvIHNyY19sZW4gLSAxIGRvXG4gICAgICAgIG1hdGNoIGYgc3JjX3BvcyAodW5zYWZlX2dldCBzcmMgc3JjX3Bvcykgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgfCBTb21lIGMgLT5cbiAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IGRzdCAhZHN0X3BvcyBjO1xuICAgICAgICAgIGluY3IgZHN0X3Bvc1xuICAgICAgZG9uZTtcbiAgICAgIGxvY2FsX2NvcHlfdG9fc3RyaW5nIGRzdCB+cG9zOiFkc3RfcG9zXG4gICAgOztcblxuICAgICgqIEZpbHRlcnMgW3RdLiBJZiB0aGUgcmVzdWx0IHR1cm5zIG91dCB0byBiZSBpZGVudGljYWwgdG8gdGhlIGlucHV0LCByZXR1cm5zIFt0XVxuICAgICAgIGRpcmVjdGx5IHdpdGhvdXQgbmVlZGluZyB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBhbmQgdHJhdmVyc2UgdGhlIHN0cmluZyB0d2ljZS5cblxuICAgICAgIFByZS1jb25kaXRpb246IFtsZW4gPT0gbGVuZ3RoIHRdXG4gICAgICAgUHJlLWNvbmRpdGlvbjogWzAgPD0gcG9zIDw9IGxlbl0gKilcbiAgICBsZXQgcmVjIGZpbHRlcl9tYXBpX21heWJlX2lkIHQgfmYgfnBvcyB+bGVuID1cbiAgICAgIGlmIHBvcyA9IGxlblxuICAgICAgdGhlbiB0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGMxID0gdW5zYWZlX2dldCB0IHBvcyBpblxuICAgICAgICBsZXQgbmV4dCA9IEludC5zdWNjIHBvcyBpblxuICAgICAgICBtYXRjaCBmIHBvcyBjMSB3aXRoXG4gICAgICAgIHwgU29tZSBjMiB3aGVuIENoYXIuZXF1YWwgYzEgYzIgLT5cbiAgICAgICAgICAoKiBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCBjb250aW51ZSAqKVxuICAgICAgICAgIGZpbHRlcl9tYXBpX21heWJlX2lkIHQgfmYgfnBvczpuZXh0IH5sZW5cbiAgICAgICAgfCBvcHRpb24gLT5cbiAgICAgICAgICAoKiBJZiBhIGNoYXJhY3RlciBoYXMgYmVlbiBjaGFuZ2VkIG9yIGRyb3BwZWQsIGJlZ2luIGFuIG91dHB1dCBidWZmZXIgdXAgdG9cbiAgICAgICAgICAgICBbcG9zXSwgYW5kIHdyaXRlIHRoZSBuZXcgY2hhcmFjdGVyIGludG8gaXQuICopXG4gICAgICAgICAgbGV0IGNvcHkgPSBsb2NhbF9jb3B5X3ByZWZpeCB0IH5wcmVmaXhfbGVuOnBvcyB+YnVmZmVyX2xlbjpsZW4gaW5cbiAgICAgICAgICBsZXQgZHN0X3BvcyA9XG4gICAgICAgICAgICBtYXRjaCBvcHRpb24gd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHBvc1xuICAgICAgICAgICAgfCBTb21lIGMgLT5cbiAgICAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBjb3B5IHBvcyBjO1xuICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgaW5cbiAgICAgICAgICBmaWx0ZXJfbWFwaV9pbnRvIHQgY29weSB+ZiB+c3JjX3BvczpuZXh0IH5kc3RfcG9zIH5zcmNfbGVuOmxlbiBbQG5vbnRhaWxdKVxuICAgIDs7XG4gIGVuZFxuXG4gICgqIGZpbHRlcl9tYXAgZnVuY3Rpb25zICopXG5cbiAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPSBmaWx0ZXJfbWFwaV9tYXliZV9pZCB0IH5mIH5wb3M6MCB+bGVuOihsZW5ndGggdClcbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBfIGMgLT4gZiBjKSBbQG5vbnRhaWxdXG5lbmRcblxuaW5jbHVkZSBzdHJ1Y3RcbiAgb3BlbiBzdHJ1Y3RcbiAgICAoKiBwYXJ0aXRpb24gaGVscGVycyAqKVxuXG4gICAgbGV0IHBhcnRpdGlvbl9tYXBfaW50byBzcmMgfmZzdHMgfnNuZHMgfmYgfmxlbiB+c3JjX3BvcyB+ZnN0X3BvcyB+c25kX3BvcyA9XG4gICAgICBsZXQgZnN0X3BvcyA9IHJlZiBmc3RfcG9zIGluXG4gICAgICBsZXQgc25kX3BvcyA9IHJlZiBzbmRfcG9zIGluXG4gICAgICBmb3Igc3JjX3BvcyA9IHNyY19wb3MgdG8gbGVuIC0gMSBkb1xuICAgICAgICBtYXRjaCAoZiAodW5zYWZlX2dldCBzcmMgc3JjX3BvcykgOiAoXywgXykgRWl0aGVyLnQpIHdpdGhcbiAgICAgICAgfCBGaXJzdCBjIC0+XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBmc3RzICFmc3RfcG9zIGM7XG4gICAgICAgICAgaW5jciBmc3RfcG9zXG4gICAgICAgIHwgU2Vjb25kIGMgLT5cbiAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHNuZHMgIXNuZF9wb3MgYztcbiAgICAgICAgICBpbmNyIHNuZF9wb3NcbiAgICAgIGRvbmU7XG4gICAgICBsb2NhbF9jb3B5X3RvX3N0cmluZyBmc3RzIH5wb3M6IWZzdF9wb3MsIGxvY2FsX2NvcHlfdG9fc3RyaW5nIHNuZHMgfnBvczohc25kX3Bvc1xuICAgIDs7XG5cbiAgICBsZXQgcGFydGl0aW9uX21hcF9kaWZmZXJlbmNlIHNyYyB+ZiB+bGVuIH5wb3M6c3JjX3BvcyB+ZnN0X3BvcyB+c25kX3BvcyBlaXRoZXIgPVxuICAgICAgbGV0IGZzdHMgPSBsb2NhbF9jb3B5X3ByZWZpeCBzcmMgfnByZWZpeF9sZW46ZnN0X3BvcyB+YnVmZmVyX2xlbjpsZW4gaW5cbiAgICAgIGxldCBzbmRzID0gbG9jYWxfY29weV9wcmVmaXggc3JjIH5wcmVmaXhfbGVuOnNuZF9wb3MgfmJ1ZmZlcl9sZW46bGVuIGluXG4gICAgICBsZXQgZnN0X3Bvcywgc25kX3BvcyA9XG4gICAgICAgIG1hdGNoIChlaXRoZXIgOiAoXywgXykgRWl0aGVyLnQpIHdpdGhcbiAgICAgICAgfCBGaXJzdCBjIC0+XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBmc3RzIGZzdF9wb3MgYztcbiAgICAgICAgICBmc3RfcG9zICsgMSwgc25kX3Bvc1xuICAgICAgICB8IFNlY29uZCBjIC0+XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzbmRzIHNuZF9wb3MgYztcbiAgICAgICAgICBmc3RfcG9zLCBzbmRfcG9zICsgMVxuICAgICAgaW5cbiAgICAgIHBhcnRpdGlvbl9tYXBfaW50b1xuICAgICAgICBzcmNcbiAgICAgICAgfmZzdHNcbiAgICAgICAgfnNuZHNcbiAgICAgICAgfmZcbiAgICAgICAgfmxlblxuICAgICAgICB+c3JjX3Bvczooc3JjX3BvcyArIDEpXG4gICAgICAgIH5mc3RfcG9zXG4gICAgICAgIH5zbmRfcG9zIFtAbm9udGFpbF1cbiAgICA7O1xuXG4gICAgbGV0IHJlYyBwYXJ0aXRpb25fbWFwX2ZpcnN0X21heWJlX2lkIHNyYyB+ZiB+cG9zIH5sZW4gPVxuICAgICAgaWYgcG9zID0gbGVuXG4gICAgICB0aGVuIHNyYywgXCJcIlxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBjMSA9IHVuc2FmZV9nZXQgc3JjIHBvcyBpblxuICAgICAgICBtYXRjaCAoZiBjMSA6IChfLCBfKSBFaXRoZXIudCkgd2l0aFxuICAgICAgICB8IEZpcnN0IGMyIHdoZW4gQ2hhci5lcXVhbCBjMSBjMiAtPlxuICAgICAgICAgIHBhcnRpdGlvbl9tYXBfZmlyc3RfbWF5YmVfaWQgc3JjIH5mIH5sZW4gfnBvczoocG9zICsgMSlcbiAgICAgICAgfCBlaXRoZXIgLT5cbiAgICAgICAgICBwYXJ0aXRpb25fbWFwX2RpZmZlcmVuY2VcbiAgICAgICAgICAgIHNyY1xuICAgICAgICAgICAgfmZcbiAgICAgICAgICAgIH5sZW5cbiAgICAgICAgICAgIH5wb3NcbiAgICAgICAgICAgIH5mc3RfcG9zOnBvc1xuICAgICAgICAgICAgfnNuZF9wb3M6MFxuICAgICAgICAgICAgZWl0aGVyIFtAbm9udGFpbF0pXG4gICAgOztcblxuICAgIGxldCByZWMgcGFydGl0aW9uX21hcF9zZWNvbmRfbWF5YmVfaWQgc3JjIH5mIH5wb3MgfmxlbiA9XG4gICAgICBpZiBwb3MgPSBsZW5cbiAgICAgIHRoZW4gXCJcIiwgc3JjXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGMxID0gdW5zYWZlX2dldCBzcmMgcG9zIGluXG4gICAgICAgIG1hdGNoIChmIGMxIDogKF8sIF8pIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgU2Vjb25kIGMyIHdoZW4gQ2hhci5lcXVhbCBjMSBjMiAtPlxuICAgICAgICAgIHBhcnRpdGlvbl9tYXBfc2Vjb25kX21heWJlX2lkIHNyYyB+ZiB+bGVuIH5wb3M6KHBvcyArIDEpXG4gICAgICAgIHwgZWl0aGVyIC0+XG4gICAgICAgICAgcGFydGl0aW9uX21hcF9kaWZmZXJlbmNlXG4gICAgICAgICAgICBzcmNcbiAgICAgICAgICAgIH5mXG4gICAgICAgICAgICB+bGVuXG4gICAgICAgICAgICB+cG9zXG4gICAgICAgICAgICB+ZnN0X3BvczowXG4gICAgICAgICAgICB+c25kX3Bvczpwb3NcbiAgICAgICAgICAgIGVpdGhlciBbQG5vbnRhaWxdKVxuICAgIDs7XG4gIGVuZFxuXG4gICgqIHBhcnRpdGlvbiBmdW5jdGlvbnMgKilcblxuICBsZXQgcGFydGl0aW9uX21hcCBzcmMgfmYgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggc3JjIGluXG4gICAgaWYgbGVuID0gMFxuICAgIHRoZW4gXCJcIiwgXCJcIlxuICAgIGVsc2UgKFxuICAgICAgbGV0IGMxID0gdW5zYWZlX2dldCBzcmMgMCBpblxuICAgICAgbWF0Y2ggKGYgYzEgOiAoXywgXykgRWl0aGVyLnQpIHdpdGhcbiAgICAgIHwgRmlyc3QgYzIgd2hlbiBDaGFyLmVxdWFsIGMxIGMyIC0+IHBhcnRpdGlvbl9tYXBfZmlyc3RfbWF5YmVfaWQgc3JjIH5mIH5sZW4gfnBvczoxXG4gICAgICB8IFNlY29uZCBjMiB3aGVuIENoYXIuZXF1YWwgYzEgYzIgLT5cbiAgICAgICAgcGFydGl0aW9uX21hcF9zZWNvbmRfbWF5YmVfaWQgc3JjIH5mIH5sZW4gfnBvczoxXG4gICAgICB8IGVpdGhlciAtPlxuICAgICAgICBwYXJ0aXRpb25fbWFwX2RpZmZlcmVuY2VcbiAgICAgICAgICBzcmNcbiAgICAgICAgICB+ZlxuICAgICAgICAgIH5sZW5cbiAgICAgICAgICB+cG9zOjBcbiAgICAgICAgICB+ZnN0X3BvczowXG4gICAgICAgICAgfnNuZF9wb3M6MFxuICAgICAgICAgIGVpdGhlciBbQG5vbnRhaWxdKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9XG4gICAgcGFydGl0aW9uX21hcCB0IH5mOihmdW4gYyAtPiBpZiBmIGMgdGhlbiBGaXJzdCBjIGVsc2UgU2Vjb25kIGMpIFtAbm9udGFpbF1cbiAgOztcbmVuZFxuXG5sZXQgZWRpdF9kaXN0YW5jZSBzMSBzMiA9XG4gICgqIFdlIG1haW50YWluIGEgdGFibGUgb2YgZWRpdCBkaXN0YW5jZSBiZXR3ZWVuIGFsbCBpbmRpY2VzIG9mIHRoZSBzaG9ydGVyIHN0cmluZywgYW5kXG4gICAgIHRoZSBjdXJyZW50IGFuZCBwcmV2aW91cyBpbmRpY2VzIG9mIHRoZSBsb25nZXIgc3RyaW5nLiAqKVxuICBsZXQgczEsIHMyID0gaWYgU3RyaW5nLmxlbmd0aCBzMSA8PSBTdHJpbmcubGVuZ3RoIHMyIHRoZW4gczEsIHMyIGVsc2UgczIsIHMxIGluXG4gIGxldCB0YWJsZSA9IEFycmF5LmNyZWF0ZV9sb2NhbCB+bGVuOigyICogKDEgKyBTdHJpbmcubGVuZ3RoIHMxKSkgMCBpblxuICBsZXQgYXQgaSBqID0gKGkgKiAyKSArIChqIG1vZCAyKSBpblxuICBmb3IgaSA9IDEgdG8gU3RyaW5nLmxlbmd0aCBzMSBkb1xuICAgICgqIEluc2VydCBbaV0gY2hhcmFjdGVycyB3aGVuIFtqPTBdLiAqKVxuICAgIHRhYmxlLihhdCBpIDApIDwtIGlcbiAgZG9uZTtcbiAgZm9yIGogPSAxIHRvIFN0cmluZy5sZW5ndGggczIgZG9cbiAgICAoKiBJbnNlcnQgW2pdIGNoYXJhY3RlcnMgd2hlbiBbaT0wXS4gKilcbiAgICB0YWJsZS4oYXQgMCBqKSA8LSBqO1xuICAgIGZvciBpID0gMSB0byBTdHJpbmcubGVuZ3RoIHMxIGRvXG4gICAgICBpZiBDaGFyLmVxdWFsIHMxLltpIC0gMV0gczIuW2ogLSAxXVxuICAgICAgdGhlblxuICAgICAgICAoKiBOb3RoaW5nIHRvIGVkaXQgZm9yIHRoZSBjdXJyZW50IGNoYXJhY3Rlci4gKilcbiAgICAgICAgdGFibGUuKGF0IGkgaikgPC0gdGFibGUuKGF0IChpIC0gMSkgKGogLSAxKSlcbiAgICAgIGVsc2UgKFxuICAgICAgICAoKiBFZGl0IHRoZSBjdXJyZW50IGNoYXJhY3RlciBieSBzdWJzdGl0dXRpb24sIGFkZGl0aW9uLCBvciBkZWxldGlvbi4gKilcbiAgICAgICAgbGV0IHN1YiA9IHRhYmxlLihhdCAoaSAtIDEpIChqIC0gMSkpIGluXG4gICAgICAgIGxldCBhZGQgPSB0YWJsZS4oYXQgKGkgLSAxKSBqKSBpblxuICAgICAgICBsZXQgZGVsID0gdGFibGUuKGF0IGkgKGogLSAxKSkgaW5cbiAgICAgICAgdGFibGUuKGF0IGkgaikgPC0gMSArIG1pbiBzdWIgKG1pbiBhZGQgZGVsKSlcbiAgICBkb25lXG4gIGRvbmU7XG4gICgqIFJldHVybiB0aGUgZmluYWwgcmVzdWx0LiAqKVxuICB0YWJsZS4oYXQgKFN0cmluZy5sZW5ndGggczEpIChTdHJpbmcubGVuZ3RoIHMyKSlcbjs7XG5cbm1vZHVsZSBFc2NhcGluZyA9IHN0cnVjdFxuICAoKiBJZiB0aGlzIGlzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0byB1cGRhdGUgW2VzY2FwZV0sIHdoaWNoIGF0dGVtcHRzIHRvIGVuc3VyZSBhbGwgdGhlXG4gICAgIGludmFyaWFudHMgY2hlY2tlZCBoZXJlLiAgKilcbiAgbGV0IGJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aHlfbWFwIGVzY2FwZXdvcnRoeV9tYXAgZXNjYXBlX2NoYXIgZnVuYyA9XG4gICAgbGV0IGVzY2FwZXdvcnRoeV9tYXAgPVxuICAgICAgaWYgTGlzdC5Bc3NvYy5tZW0gZXNjYXBld29ydGh5X21hcCB+ZXF1YWw6Q2hhci5lcXVhbCBlc2NhcGVfY2hhclxuICAgICAgdGhlbiBlc2NhcGV3b3J0aHlfbWFwXG4gICAgICBlbHNlIChlc2NhcGVfY2hhciwgZXNjYXBlX2NoYXIpIDo6IGVzY2FwZXdvcnRoeV9tYXBcbiAgICBpblxuICAgIGxldCBhcnIgPSBBcnJheS5jcmVhdGUgfmxlbjoyNTYgKC0xKSBpblxuICAgIGxldCB2YWxzID0gQXJyYXkuY3JlYXRlIH5sZW46MjU2IGZhbHNlIGluXG4gICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gT2sgYXJyXG4gICAgICB8IChjX2Zyb20sIGNfdG8pIDo6IGwgLT5cbiAgICAgICAgbGV0IGssIHYgPVxuICAgICAgICAgIG1hdGNoIGZ1bmMgd2l0aFxuICAgICAgICAgIHwgYEVzY2FwZSAtPiBDaGFyLnRvX2ludCBjX2Zyb20sIGNfdG9cbiAgICAgICAgICB8IGBVbmVzY2FwZSAtPiBDaGFyLnRvX2ludCBjX3RvLCBjX2Zyb21cbiAgICAgICAgaW5cbiAgICAgICAgaWYgYXJyLihrKSA8PiAtMSB8fCB2YWxzLihDaGFyLnRvX2ludCB2KVxuICAgICAgICB0aGVuXG4gICAgICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgICAgXCJlc2NhcGV3b3J0aHlfbWFwIG5vdCBvbmUtdG8tb25lXCJcbiAgICAgICAgICAgICAgIFsgXCJjX2Zyb21cIiwgc2V4cF9vZl9jaGFyIGNfZnJvbVxuICAgICAgICAgICAgICAgOyBcImNfdG9cIiwgc2V4cF9vZl9jaGFyIGNfdG9cbiAgICAgICAgICAgICAgIDsgKCBcImVzY2FwZXdvcnRoeV9tYXBcIlxuICAgICAgICAgICAgICAgICAsIHNleHBfb2ZfbGlzdCAoc2V4cF9vZl9wYWlyIHNleHBfb2ZfY2hhciBzZXhwX29mX2NoYXIpIGVzY2FwZXdvcnRoeV9tYXBcbiAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgXSlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgYXJyLihrKSA8LSBDaGFyLnRvX2ludCB2O1xuICAgICAgICAgIHZhbHMuKENoYXIudG9faW50IHYpIDwtIHRydWU7XG4gICAgICAgICAgbG9vcCBsKVxuICAgIGluXG4gICAgbG9vcCBlc2NhcGV3b3J0aHlfbWFwXG4gIDs7XG5cbiAgbGV0IGVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBtYXRjaCBidWlsZF9hbmRfdmFsaWRhdGVfZXNjYXBld29ydGh5X21hcCBlc2NhcGV3b3J0aHlfbWFwIGVzY2FwZV9jaGFyIGBFc2NhcGUgd2l0aFxuICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICB8IE9rIGVzY2FwZXdvcnRoeSAtPlxuICAgICAgT2tcbiAgICAgICAgKGZ1biBzcmMgLT5cbiAgICAgICAgICAoKiBjYWxjdWxhdGUgYSBsaXN0IG9mIChpbmRleCBvZiBjaGFyIHRvIGVzY2FwZSAqIGVzY2FwZWQgY2hhcikgZmlyc3QsIHRoZSBvcmRlclxuICAgICAgICAgICAgICBpcyBmcm9tIHRhaWwgdG8gaGVhZCAqKVxuICAgICAgICAgIGxldCB0b19lc2NhcGVfbGVuID0gcmVmIDAgaW5cbiAgICAgICAgICBsZXQgdG9fZXNjYXBlID1cbiAgICAgICAgICAgIGZvbGRpIHNyYyB+aW5pdDpbXSB+ZjooZnVuIGkgYWNjIGMgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggZXNjYXBld29ydGh5LihDaGFyLnRvX2ludCBjKSB3aXRoXG4gICAgICAgICAgICAgIHwgLTEgLT4gYWNjXG4gICAgICAgICAgICAgIHwgbiAtPlxuICAgICAgICAgICAgICAgICgqIChpbmRleCBvZiBjaGFyIHRvIGVzY2FwZSAqIGVzY2FwZWQgY2hhcikgKilcbiAgICAgICAgICAgICAgICBpbmNyIHRvX2VzY2FwZV9sZW47XG4gICAgICAgICAgICAgICAgKGksIENoYXIudW5zYWZlX29mX2ludCBuKSA6OiBhY2MpXG4gICAgICAgICAgaW5cbiAgICAgICAgICBtYXRjaCB0b19lc2NhcGUgd2l0aFxuICAgICAgICAgIHwgW10gLT4gc3JjXG4gICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAoKiBbdG9fZXNjYXBlXSBkaXZpZGUgW3NyY10gdG8gW0xpc3QubGVuZ3RoIHRvX2VzY2FwZSArIDFdIHBpZWNlcyBzZXBhcmF0ZWQgYnlcbiAgICAgICAgICAgICAgICB0aGUgY2hhcnMgdG8gZXNjYXBlLlxuXG4gICAgICAgICAgICAgICAgTGV0cyB0YWtlXG4gICAgICAgICAgICAgICAge1tcbiAgICAgICAgICAgICAgICAgIGVzY2FwZV9nZW5fZXhuXG4gICAgICAgICAgICAgICAgICAgIH5lc2NhcGV3b3J0aHlfbWFwOlsoJ2EnLCAnQScpOyAoJ2InLCAnQicpOyAoJ2MnLCAnQycpXVxuICAgICAgICAgICAgICAgICAgICB+ZXNjYXBlX2NoYXI6J18nXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSwgYW5kIGFzc3VtZSB0aGUgc3RyaW5nIHRvIGVzY2FwZSBpc1xuXG4gICAgICAgICAgICAgICAgXCIwMDBhMTExYjIyMmMzMzNcIlxuXG4gICAgICAgICAgICAgICAgdGhlbiBbdG9fZXNjYXBlXSBpcyBbKDExLCAnQycpOyAoNywgJ0InKTsgKDMsICdBJyldLlxuXG4gICAgICAgICAgICAgICAgVGhlbiB3ZSBjcmVhdGUgYSBbZHN0XSBvZiBsZW5ndGggW2xlbmd0aCBzcmMgKyAzXSB0byBzdG9yZSB0aGVcbiAgICAgICAgICAgICAgICByZXN1bHQsIGNvcHkgcGllY2UgXCIzMzNcIiB0byBbZHN0XSBkaXJlY3RseSwgdGhlbiBjb3B5ICdfJyBhbmQgJ0MnIHRvIFtkc3RdO1xuICAgICAgICAgICAgICAgIHRoZW4gbW92ZSBvbiB0byBuZXh0OyBhZnRlciAzIGl0ZXJhdGlvbnMsIGNvcHkgcGllY2UgXCIwMDBcIiBhbmQgd2UgYXJlIGRvbmUuXG5cbiAgICAgICAgICAgICAgICBGaW5hbGx5IHRoZSByZXN1bHQgd2lsbCBiZVxuXG4gICAgICAgICAgICAgICAgXCIwMDBfQTExMV9CMjIyX0MzMzNcIiAqKVxuICAgICAgICAgICAgbGV0IHNyY19sZW4gPSBsZW5ndGggc3JjIGluXG4gICAgICAgICAgICBsZXQgZHN0X2xlbiA9IHNyY19sZW4gKyAhdG9fZXNjYXBlX2xlbiBpblxuICAgICAgICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSBkc3RfbGVuIGluXG4gICAgICAgICAgICBsZXQgcmVjIGxvb3AgbGFzdF9pZHggbGFzdF9kc3RfcG9zID0gZnVuY3Rpb25cbiAgICAgICAgICAgICAgfCBbXSAtPlxuICAgICAgICAgICAgICAgICgqIGNvcHkgXCIwMDBcIiBhdCBsYXN0ICopXG4gICAgICAgICAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6MCB+bGVuOmxhc3RfaWR4XG4gICAgICAgICAgICAgIHwgKGlkeCwgZXNjYXBlZF9jaGFyKSA6OiB0b19lc2NhcGUgLT5cbiAgICAgICAgICAgICAgICAoKltpZHhdID0gdGhlIGNoYXIgdG8gZXNjYXBlKilcbiAgICAgICAgICAgICAgICAoKiB0YWtlIGZpcnN0IGl0ZXJhdGlvbiBmb3IgZXhhbXBsZSAqKVxuICAgICAgICAgICAgICAgICgqIGNhbGN1bGF0ZSBsZW5ndGggb2YgXCIzMzNcIiwgbWludXMgMSBiZWNhdXNlIHdlIGRvbid0IGNvcHkgJ2MnICopXG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IGxhc3RfaWR4IC0gaWR4IC0gMSBpblxuICAgICAgICAgICAgICAgICgqIHNldCB0aGUgZHN0X3BvcyB0byBjb3B5IHRvICopXG4gICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBsYXN0X2RzdF9wb3MgLSBsZW4gaW5cbiAgICAgICAgICAgICAgICAoKiBjb3B5IFwiMzMzXCIsIHNldCBbc3JjX3Bvc10gdG8gW2lkeCArIDFdIHRvIHNraXAgJ2MnICopXG4gICAgICAgICAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvczooaWR4ICsgMSkgfmRzdCB+ZHN0X3BvcyB+bGVuO1xuICAgICAgICAgICAgICAgICgqIGJhY2tvZmYgW2RzdF9wb3NdIGJ5IDIgdG8gY29weSAnXycgYW5kICdDJyAqKVxuICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gZHN0X3BvcyAtIDIgaW5cbiAgICAgICAgICAgICAgICBCeXRlcy5zZXQgZHN0IGRzdF9wb3MgZXNjYXBlX2NoYXI7XG4gICAgICAgICAgICAgICAgQnl0ZXMuc2V0IGRzdCAoZHN0X3BvcyArIDEpIGVzY2FwZWRfY2hhcjtcbiAgICAgICAgICAgICAgICBsb29wIGlkeCBkc3RfcG9zIHRvX2VzY2FwZVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICgqIHNldCBbbGFzdF9kc3RfcG9zXSBhbmQgW2xhc3RfaWR4XSB0byBsZW5ndGggb2YgW2RzdF0gYW5kIFtzcmNdIGZpcnN0ICopXG4gICAgICAgICAgICBsb29wIHNyY19sZW4gZHN0X2xlbiB0b19lc2NhcGU7XG4gICAgICAgICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdClcbiAgOztcblxuICBsZXQgZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBPcl9lcnJvci5va19leG4gKGVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyKSB8PiBzdGFnZVxuICA7O1xuXG4gIGxldCBlc2NhcGUgfmVzY2FwZXdvcnRoeSB+ZXNjYXBlX2NoYXIgPVxuICAgICgqIEZvciBbZXNjYXBlX2dlbl9leG5dLCB3ZSBkb24ndCBrbm93IGhvdyB0byBmaXggaW52YWxpZCBlc2NhcGV3b3J0aHlfbWFwIHNvIHdlIGhhdmVcbiAgICAgICB0byByYWlzZSBleGNlcHRpb247IGJ1dCBpbiB0aGlzIGNhc2UsIHdlIGtub3cgaG93IHRvIGZpeCBkdXBsaWNhdGVkIGVsZW1lbnRzIGluXG4gICAgICAgZXNjYXBld29ydGh5IGxpc3QsIHNvIHdlIGp1c3QgZml4IGl0IGluc3RlYWQgb2YgcmFpc2luZyBleGNlcHRpb24gdG8gbWFrZSB0aGlzXG4gICAgICAgZnVuY3Rpb24gZWFzaWVyIHRvIHVzZS4gICopXG4gICAgbGV0IGVzY2FwZXdvcnRoeV9tYXAgPVxuICAgICAgZXNjYXBld29ydGh5XG4gICAgICB8PiBMaXN0LmRlZHVwX2FuZF9zb3J0IH5jb21wYXJlOkNoYXIuY29tcGFyZVxuICAgICAgfD4gTGlzdC5tYXAgfmY6KGZ1biBjIC0+IGMsIGMpXG4gICAgaW5cbiAgICBlc2NhcGVfZ2VuX2V4biB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXJcbiAgOztcblxuICAoKiBJbiBhbiBlc2NhcGVkIHN0cmluZywgYW55IGNoYXIgaXMgZWl0aGVyIGBFc2NhcGluZywgYEVzY2FwZWQgb3IgYExpdGVyYWwuIEZvclxuICAgICBleGFtcGxlLCB0aGUgZXNjYXBlIHN0YXR1c2VzIG9mIGNoYXJzIGluIHN0cmluZyBcImFfYV9fXCIgd2l0aCBlc2NhcGVfY2hhciA9ICdfJyBhcmVcblxuICAgICBhIDogYExpdGVyYWxcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBhIDogYEVzY2FwZWRcbiAgICAgXyA6IGBFc2NhcGluZ1xuICAgICBfIDogYEVzY2FwZWRcblxuICAgICBbdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpIHByZXZpb3VzX3N0YXR1c10gZ2V0cyBlc2NhcGUgc3RhdHVzIG9mXG4gICAgIHN0ci5baV0gYmFzaW5nIG9uIGVzY2FwZSBzdGF0dXMgb2Ygc3RyLltpIC0gMV0gKilcbiAgbGV0IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSA9IGZ1bmN0aW9uXG4gICAgfCBgRXNjYXBpbmcgLT4gYEVzY2FwZWRcbiAgICB8IGBMaXRlcmFsIHwgYEVzY2FwZWQgLT5cbiAgICAgIGlmIENoYXIuZXF1YWwgc3RyLltpXSBlc2NhcGVfY2hhciB0aGVuIGBFc2NhcGluZyBlbHNlIGBMaXRlcmFsXG4gIDs7XG5cbiAgbGV0IHVuZXNjYXBlX2dlbiB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aHlfbWFwIGVzY2FwZXdvcnRoeV9tYXAgZXNjYXBlX2NoYXIgYFVuZXNjYXBlIHdpdGhcbiAgICB8IEVycm9yIF8gYXMgeCAtPiB4XG4gICAgfCBPayBlc2NhcGV3b3J0aHkgLT5cbiAgICAgIE9rXG4gICAgICAgIChmdW4gc3JjIC0+XG4gICAgICAgICAgKCogQ29udGludWUgdGhlIGV4YW1wbGUgaW4gW2VzY2FwZV9nZW5fZXhuXSwgbm93IHdlIHVuZXNjYXBlXG5cbiAgICAgICAgICAgICAgXCIwMDBfQTExMV9CMjIyX0MzMzNcIlxuXG4gICAgICAgICAgICAgIGJhY2sgdG9cblxuICAgICAgICAgICAgICBcIjAwMGExMTFiMjIyYzMzM1wiXG5cbiAgICAgICAgICAgICAgVGhlbiBbdG9fdW5lc2NhcGVdIGlzIFsxNDsgOTsgNF0sIHdoaWNoIGlzIGluZGV4ZXMgb2YgJ18ncy5cblxuICAgICAgICAgICAgICBUaGVuIHdlIGNyZWF0ZSBhIHN0cmluZyBbZHN0XSB0byBzdG9yZSB0aGUgcmVzdWx0LCBjb3B5IFwiMzMzXCIgdG8gaXQsIHRoZW4gY29weVxuICAgICAgICAgICAgICAnYycsIHRoZW4gbW92ZSBvbiB0byBuZXh0IGl0ZXJhdGlvbi4gQWZ0ZXIgMyBpdGVyYXRpb25zIGNvcHkgXCIwMDBcIiBhbmQgd2UgYXJlXG4gICAgICAgICAgICAgIGRvbmUuICAqKVxuICAgICAgICAgICgqIGluZGV4ZXMgb2YgZXNjYXBlIGNoYXJzICopXG4gICAgICAgICAgbGV0IHRvX3VuZXNjYXBlID1cbiAgICAgICAgICAgIGxldCByZWMgbG9vcCBpIHN0YXR1cyBhY2MgPVxuICAgICAgICAgICAgICBpZiBpID49IGxlbmd0aCBzcmNcbiAgICAgICAgICAgICAgdGhlbiBhY2NcbiAgICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgICAgbGV0IHN0YXR1cyA9IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHNyYyB+ZXNjYXBlX2NoYXIgaSBzdGF0dXMgaW5cbiAgICAgICAgICAgICAgICBsb29wXG4gICAgICAgICAgICAgICAgICAoaSArIDEpXG4gICAgICAgICAgICAgICAgICBzdGF0dXNcbiAgICAgICAgICAgICAgICAgIChtYXRjaCBzdGF0dXMgd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgYEVzY2FwaW5nIC0+IGkgOjogYWNjXG4gICAgICAgICAgICAgICAgICAgfCBgRXNjYXBlZCB8IGBMaXRlcmFsIC0+IGFjYykpXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbG9vcCAwIGBMaXRlcmFsIFtdXG4gICAgICAgICAgaW5cbiAgICAgICAgICBtYXRjaCB0b191bmVzY2FwZSB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBzcmNcbiAgICAgICAgICB8IGlkeCA6OiB0b191bmVzY2FwZScgLT5cbiAgICAgICAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGxlbmd0aCBzcmMgLSBMaXN0Lmxlbmd0aCB0b191bmVzY2FwZSkgaW5cbiAgICAgICAgICAgIGxldCByZWMgbG9vcCBsYXN0X2lkeCBsYXN0X2RzdF9wb3MgPSBmdW5jdGlvblxuICAgICAgICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgICAgICAgKCogY29weSBcIjAwMFwiIGF0IGxhc3QgKilcbiAgICAgICAgICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3BvczowIH5sZW46bGFzdF9pZHhcbiAgICAgICAgICAgICAgfCBpZHggOjogdG9fdW5lc2NhcGUgLT5cbiAgICAgICAgICAgICAgICAoKiBbaWR4XSA9IGluZGV4IG9mIGVzY2FwaW5nIGNoYXIgKilcbiAgICAgICAgICAgICAgICAoKiB0YWtlIDFzdCBpdGVyYXRpb24gYXMgZXhhbXBsZSwgY2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgXCIzMzNcIiwgbWludXMgMiB0b1xuICAgICAgICAgICAgICAgICAgICBza2lwICdfQycgKilcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gbGFzdF9pZHggLSBpZHggLSAyIGluXG4gICAgICAgICAgICAgICAgKCogcG9pbnQgW2RzdF9wb3NdIHRvIHRoZSBwb3NpdGlvbiB0byBjb3B5IFwiMzMzXCIgdG8gKilcbiAgICAgICAgICAgICAgICBsZXQgZHN0X3BvcyA9IGxhc3RfZHN0X3BvcyAtIGxlbiBpblxuICAgICAgICAgICAgICAgICgqIGNvcHkgXCIzMzNcIiAqKVxuICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6KGlkeCArIDIpIH5kc3QgfmRzdF9wb3MgfmxlbjtcbiAgICAgICAgICAgICAgICAoKiBiYWNrb2ZmIFtkc3RfcG9zXSBieSAxIHRvIGNvcHkgJ2MnICopXG4gICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBkc3RfcG9zIC0gMSBpblxuICAgICAgICAgICAgICAgIEJ5dGVzLnNldFxuICAgICAgICAgICAgICAgICAgZHN0XG4gICAgICAgICAgICAgICAgICBkc3RfcG9zXG4gICAgICAgICAgICAgICAgICAobWF0Y2ggZXNjYXBld29ydGh5LihDaGFyLnRvX2ludCBzcmMuW2lkeCArIDFdKSB3aXRoXG4gICAgICAgICAgICAgICAgICAgfCAtMSAtPiBzcmMuW2lkeCArIDFdXG4gICAgICAgICAgICAgICAgICAgfCBuIC0+IENoYXIudW5zYWZlX29mX2ludCBuKTtcbiAgICAgICAgICAgICAgICAoKiB1cGRhdGUgW2xhc3RfZHN0X3Bvc10gYW5kIFtsYXN0X2lkeF0gKilcbiAgICAgICAgICAgICAgICBsb29wIGlkeCBkc3RfcG9zIHRvX3VuZXNjYXBlXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgaWYgaWR4IDwgbGVuZ3RoIHNyYyAtIDFcbiAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgKCogc2V0IFtsYXN0X2RzdF9wb3NdIGFuZCBbbGFzdF9pZHhdIHRvIGxlbmd0aCBvZiBbZHN0XSBhbmQgW3NyY10gKilcbiAgICAgICAgICAgICAgbG9vcCAobGVuZ3RoIHNyYykgKEJ5dGVzLmxlbmd0aCBkc3QpIHRvX3VuZXNjYXBlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICgqIGZvciBlc2NhcGVkIHN0cmluZyBlbmRpbmcgd2l0aCBhbiBlc2NhcGluZyBjaGFyIGxpa2UgXCIwMDBfXCIsIGp1c3QgaWdub3JlXG4gICAgICAgICAgICAgICAgICB0aGUgbGFzdCBlc2NhcGluZyBjaGFyICopXG4gICAgICAgICAgICAgIGxvb3AgKGxlbmd0aCBzcmMgLSAxKSAoQnl0ZXMubGVuZ3RoIGRzdCkgdG9fdW5lc2NhcGUnO1xuICAgICAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3QpXG4gIDs7XG5cbiAgbGV0IHVuZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBPcl9lcnJvci5va19leG4gKHVuZXNjYXBlX2dlbiB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIpIHw+IHN0YWdlXG4gIDs7XG5cbiAgbGV0IHVuZXNjYXBlIH5lc2NhcGVfY2hhciA9IHVuZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXA6W10gfmVzY2FwZV9jaGFyXG5cbiAgbGV0IHByZWNlZGluZ19lc2NhcGVfY2hhcnMgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGxldCByZWMgbG9vcCBwIGNudCA9XG4gICAgICBpZiBwIDwgMCB8fCBDaGFyLiggPD4gKSBzdHIuW3BdIGVzY2FwZV9jaGFyIHRoZW4gY250IGVsc2UgbG9vcCAocCAtIDEpIChjbnQgKyAxKVxuICAgIGluXG4gICAgbG9vcCAocG9zIC0gMSkgMFxuICA7O1xuXG4gICgqIEluIGFuIGVzY2FwZWQgc3RyaW5nLCBhbnkgY2hhciBpcyBlaXRoZXIgYEVzY2FwaW5nLCBgRXNjYXBlZCBvciBgTGl0ZXJhbC4gRm9yXG4gICAgIGV4YW1wbGUsIHRoZSBlc2NhcGUgc3RhdHVzZXMgb2YgY2hhcnMgaW4gc3RyaW5nIFwiYV9hX19cIiB3aXRoIGVzY2FwZV9jaGFyID0gJ18nIGFyZVxuXG4gICAgIGEgOiBgTGl0ZXJhbFxuICAgICBfIDogYEVzY2FwaW5nXG4gICAgIGEgOiBgRXNjYXBlZFxuICAgICBfIDogYEVzY2FwaW5nXG4gICAgIF8gOiBgRXNjYXBlZFxuXG4gICAgIFt1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgcHJldmlvdXNfc3RhdHVzXSBnZXRzIGVzY2FwZSBzdGF0dXMgb2ZcbiAgICAgc3RyLltpXSBiYXNpbmcgb24gZXNjYXBlIHN0YXR1cyBvZiBzdHIuW2kgLSAxXSAqKVxuICBsZXQgdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpID0gZnVuY3Rpb25cbiAgICB8IGBFc2NhcGluZyAtPiBgRXNjYXBlZFxuICAgIHwgYExpdGVyYWwgfCBgRXNjYXBlZCAtPlxuICAgICAgaWYgQ2hhci5lcXVhbCBzdHIuW2ldIGVzY2FwZV9jaGFyIHRoZW4gYEVzY2FwaW5nIGVsc2UgYExpdGVyYWxcbiAgOztcblxuICBsZXQgZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgbGV0IG9kZCA9IHByZWNlZGluZ19lc2NhcGVfY2hhcnMgc3RyIH5lc2NhcGVfY2hhciBwb3MgbW9kIDIgPSAxIGluXG4gICAgbWF0Y2ggb2RkLCBDaGFyLmVxdWFsIHN0ci5bcG9zXSBlc2NhcGVfY2hhciB3aXRoXG4gICAgfCB0cnVlLCAodHJ1ZSB8IGZhbHNlKSAtPiBgRXNjYXBlZFxuICAgIHwgZmFsc2UsIHRydWUgLT4gYEVzY2FwaW5nXG4gICAgfCBmYWxzZSwgZmFsc2UgLT4gYExpdGVyYWxcbiAgOztcblxuICBsZXQgY2hlY2tfYm91bmQgc3RyIHBvcyBmdW5jdGlvbl9uYW1lID1cbiAgICBpZiBwb3MgPj0gbGVuZ3RoIHN0ciB8fCBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiJXM6IG91dCBvZiBib3VuZHNcIiBmdW5jdGlvbl9uYW1lICgpXG4gIDs7XG5cbiAgbGV0IGlzX2NoYXJfZXNjYXBpbmcgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpc19jaGFyX2VzY2FwaW5nXCI7XG4gICAgbWF0Y2ggZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyB3aXRoXG4gICAgfCBgRXNjYXBpbmcgLT4gdHJ1ZVxuICAgIHwgYEVzY2FwZWQgfCBgTGl0ZXJhbCAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBpc19jaGFyX2VzY2FwZWQgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpc19jaGFyX2VzY2FwZWRcIjtcbiAgICBtYXRjaCBlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIHdpdGhcbiAgICB8IGBFc2NhcGVkIC0+IHRydWVcbiAgICB8IGBFc2NhcGluZyB8IGBMaXRlcmFsIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGlzX2NoYXJfbGl0ZXJhbCBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcImlzX2NoYXJfbGl0ZXJhbFwiO1xuICAgIG1hdGNoIGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3Mgd2l0aFxuICAgIHwgYExpdGVyYWwgLT4gdHJ1ZVxuICAgIHwgYEVzY2FwZWQgfCBgRXNjYXBpbmcgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwiaW5kZXhfZnJvbVwiO1xuICAgIGxldCByZWMgbG9vcCBpIHN0YXR1cyA9XG4gICAgICBpZiBpID49IHBvc1xuICAgICAgICAgJiYgKG1hdGNoIHN0YXR1cyB3aXRoXG4gICAgICAgICAgICAgfCBgTGl0ZXJhbCAtPiB0cnVlXG4gICAgICAgICAgICAgfCBgRXNjYXBlZCB8IGBFc2NhcGluZyAtPiBmYWxzZSlcbiAgICAgICAgICYmIENoYXIuZXF1YWwgc3RyLltpXSBjaGFyXG4gICAgICB0aGVuIFNvbWUgaVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBpID0gaSArIDEgaW5cbiAgICAgICAgaWYgaSA+PSBsZW5ndGggc3RyXG4gICAgICAgIHRoZW4gTm9uZVxuICAgICAgICBlbHNlIGxvb3AgaSAodXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpIHN0YXR1cykpXG4gICAgaW5cbiAgICBsb29wIHBvcyAoZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcylcbiAgOztcblxuICBsZXQgaW5kZXhfZnJvbV9leG4gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciA9XG4gICAgbWF0Y2ggaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcImluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIlxuICAgICAgICAgICBbIFwic3RyXCIsIHNleHBfb2ZfdCBzdHJcbiAgICAgICAgICAgOyBcImVzY2FwZV9jaGFyXCIsIHNleHBfb2ZfY2hhciBlc2NhcGVfY2hhclxuICAgICAgICAgICA7IFwicG9zXCIsIHNleHBfb2ZfaW50IHBvc1xuICAgICAgICAgICA7IFwiY2hhclwiLCBzZXhwX29mX2NoYXIgY2hhclxuICAgICAgICAgICBdKVxuICAgIHwgU29tZSBwb3MgLT4gcG9zXG4gIDs7XG5cbiAgbGV0IGluZGV4IHN0ciB+ZXNjYXBlX2NoYXIgY2hhciA9IGluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciAwIGNoYXJcbiAgbGV0IGluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPSBpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIDAgY2hhclxuXG4gIGxldCByaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwicmluZGV4X2Zyb21cIjtcbiAgICAoKiBpZiB0aGUgdGFyZ2V0IGNoYXIgaXMgdGhlIHNhbWUgYXMgW2VzY2FwZV9jaGFyXSwgd2UgaGF2ZSBubyB3YXkgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICAgZXNjYXBlX2NoYXIgaXMgbGl0ZXJhbCwgc28ganVzdCByZXR1cm4gTm9uZSAqKVxuICAgIGlmIENoYXIuZXF1YWwgY2hhciBlc2NhcGVfY2hhclxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlYyBsb29wIHBvcyA9XG4gICAgICAgIGlmIHBvcyA8IDBcbiAgICAgICAgdGhlbiBOb25lXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBlc2NhcGVfY2hhcnMgPSBwcmVjZWRpbmdfZXNjYXBlX2NoYXJzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGluXG4gICAgICAgICAgaWYgZXNjYXBlX2NoYXJzIG1vZCAyID0gMCAmJiBDaGFyLmVxdWFsIHN0ci5bcG9zXSBjaGFyXG4gICAgICAgICAgdGhlbiBTb21lIHBvc1xuICAgICAgICAgIGVsc2UgbG9vcCAocG9zIC0gZXNjYXBlX2NoYXJzIC0gMSkpXG4gICAgICBpblxuICAgICAgbG9vcCBwb3MpXG4gIDs7XG5cbiAgbGV0IHJpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBtYXRjaCByaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcInJpbmRleF9mcm9tX2V4bjogbm90IGZvdW5kXCJcbiAgICAgICAgICAgWyBcInN0clwiLCBzZXhwX29mX3Qgc3RyXG4gICAgICAgICAgIDsgXCJlc2NhcGVfY2hhclwiLCBzZXhwX29mX2NoYXIgZXNjYXBlX2NoYXJcbiAgICAgICAgICAgOyBcInBvc1wiLCBzZXhwX29mX2ludCBwb3NcbiAgICAgICAgICAgOyBcImNoYXJcIiwgc2V4cF9vZl9jaGFyIGNoYXJcbiAgICAgICAgICAgXSlcbiAgICB8IFNvbWUgcG9zIC0+IHBvc1xuICA7O1xuXG4gIGxldCByaW5kZXggc3RyIH5lc2NhcGVfY2hhciBjaGFyID1cbiAgICBpZiBpc19lbXB0eSBzdHIgdGhlbiBOb25lIGVsc2UgcmluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciAobGVuZ3RoIHN0ciAtIDEpIGNoYXJcbiAgOztcblxuICBsZXQgcmluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPVxuICAgIHJpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIChsZW5ndGggc3RyIC0gMSkgY2hhclxuICA7O1xuXG4gICgqIFtzcGxpdF9nZW4gc3RyIH5lc2NhcGVfY2hhciB+b25dIHdvcmtzIHNpbWlsYXJseSB0byBbU3RyaW5nLnNwbGl0X2dlbl0sIHdpdGggYW5cbiAgICAgYWRkaXRpb25hbCByZXF1aXJlbWVudDogb25seSBzcGxpdCBvbiBsaXRlcmFsIGNoYXJzLCBub3QgZXNjYXBpbmcgb3IgZXNjYXBlZCAqKVxuICBsZXQgc3BsaXRfZ2VuIHN0ciB+ZXNjYXBlX2NoYXIgfm9uID1cbiAgICBsZXQgaXNfZGVsaW0gPVxuICAgICAgbWF0Y2ggb24gd2l0aFxuICAgICAgfCBgY2hhciBjJyAtPiBmdW4gYyAtPiBDaGFyLmVxdWFsIGMgYydcbiAgICAgIHwgYGNoYXJfbGlzdCBsIC0+IGZ1biBjIC0+IGNoYXJfbGlzdF9tZW0gbCBjXG4gICAgaW5cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHN0ciBpblxuICAgIGxldCByZWMgbG9vcCBhY2Mgc3RhdHVzIGxhc3RfcG9zIHBvcyA9XG4gICAgICBpZiBwb3MgPSBsZW5cbiAgICAgIHRoZW4gTGlzdC5yZXYgKHN1YiBzdHIgfnBvczpsYXN0X3BvcyB+bGVuOihsZW4gLSBsYXN0X3BvcykgOjogYWNjKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBzdGF0dXMgPSB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyBzdGF0dXMgaW5cbiAgICAgICAgaWYgKG1hdGNoIHN0YXR1cyB3aXRoXG4gICAgICAgICAgICB8IGBMaXRlcmFsIC0+IHRydWVcbiAgICAgICAgICAgIHwgYEVzY2FwZWQgfCBgRXNjYXBpbmcgLT4gZmFsc2UpXG4gICAgICAgICAgICYmIGlzX2RlbGltIHN0ci5bcG9zXVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgc3ViX3N0ciA9IHN1YiBzdHIgfnBvczpsYXN0X3BvcyB+bGVuOihwb3MgLSBsYXN0X3BvcykgaW5cbiAgICAgICAgICBsb29wIChzdWJfc3RyIDo6IGFjYykgc3RhdHVzIChwb3MgKyAxKSAocG9zICsgMSkpXG4gICAgICAgIGVsc2UgbG9vcCBhY2Mgc3RhdHVzIGxhc3RfcG9zIChwb3MgKyAxKSlcbiAgICBpblxuICAgIGxvb3AgW10gYExpdGVyYWwgMCAwXG4gIDs7XG5cbiAgbGV0IHNwbGl0IHN0ciB+b24gPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXIgb24pXG4gIGxldCBzcGxpdF9vbl9jaGFycyBzdHIgfm9uOmNoYXJzID0gc3BsaXRfZ2VuIHN0ciB+b246KGBjaGFyX2xpc3QgY2hhcnMpXG5cbiAgbGV0IHNwbGl0X2F0IHN0ciBwb3MgPVxuICAgIHN1YiBzdHIgfnBvczowIH5sZW46cG9zLCBzdWIgc3RyIH5wb3M6KHBvcyArIDEpIH5sZW46KGxlbmd0aCBzdHIgLSBwb3MgLSAxKVxuICA7O1xuXG4gIGxldCBsc3BsaXQyIHN0ciB+b24gfmVzY2FwZV9jaGFyID1cbiAgICBPcHRpb24ubWFwIChpbmRleCBzdHIgfmVzY2FwZV9jaGFyIG9uKSB+ZjooZnVuIHggLT4gc3BsaXRfYXQgc3RyIHgpXG4gIDs7XG5cbiAgbGV0IHJzcGxpdDIgc3RyIH5vbiB+ZXNjYXBlX2NoYXIgPVxuICAgIE9wdGlvbi5tYXAgKHJpbmRleCBzdHIgfmVzY2FwZV9jaGFyIG9uKSB+ZjooZnVuIHggLT4gc3BsaXRfYXQgc3RyIHgpXG4gIDs7XG5cbiAgbGV0IGxzcGxpdDJfZXhuIHN0ciB+b24gfmVzY2FwZV9jaGFyID0gc3BsaXRfYXQgc3RyIChpbmRleF9leG4gc3RyIH5lc2NhcGVfY2hhciBvbilcbiAgbGV0IHJzcGxpdDJfZXhuIHN0ciB+b24gfmVzY2FwZV9jaGFyID0gc3BsaXRfYXQgc3RyIChyaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgb24pXG5cbiAgKCogW2xhc3Rfbm9uX2Ryb3BfbGl0ZXJhbF0gYW5kIFtmaXJzdF9ub25fZHJvcF9saXRlcmFsXSBhcmUgZWl0aGVyIGJvdGggW05vbmVdIG9yIGJvdGhcbiAgICAgW1NvbWVdLiBJZiBbU29tZV0sIHRoZW4gdGhlIGZvcm1lciBpcyA+PSB0aGUgbGF0dGVyLiAqKVxuICBsZXQgbGFzdF9ub25fZHJvcF9saXRlcmFsIH5kcm9wIH5lc2NhcGVfY2hhciB0ID1cbiAgICByZmluZGkgdCB+ZjooZnVuIGkgYyAtPlxuICAgICAgKG5vdCAoZHJvcCBjKSlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBpbmcgdCB+ZXNjYXBlX2NoYXIgaVxuICAgICAgfHwgaXNfY2hhcl9lc2NhcGVkIHQgfmVzY2FwZV9jaGFyIGkpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB+ZHJvcCB+ZXNjYXBlX2NoYXIgdCA9XG4gICAgbGZpbmRpIHQgfmY6KGZ1biBpIGMgLT5cbiAgICAgIChub3QgKGRyb3AgYykpXG4gICAgICB8fCBpc19jaGFyX2VzY2FwaW5nIHQgfmVzY2FwZV9jaGFyIGlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBlZCB0IH5lc2NhcGVfY2hhciBpKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHJzdHJpcF9saXRlcmFsID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgaSAtPiBpZiBpID0gbGVuZ3RoIHQgLSAxIHRoZW4gdCBlbHNlIHByZWZpeCB0IChpICsgMSlcbiAgOztcblxuICBsZXQgbHN0cmlwX2xpdGVyYWwgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0IH5lc2NhcGVfY2hhciA9XG4gICAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgMCAtPiB0XG4gICAgfCBTb21lIG4gLT4gZHJvcF9wcmVmaXggdCBuXG4gIDs7XG5cbiAgKCogW3N0cmlwIHRdIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIFtsc3RyaXAgKHJzdHJpcCB0KV0uICBUaGUgaW1wbGVtZW50YXRpb25cbiAgICAgYmVsb3cgc2F2ZXMgKGF0IGxlYXN0KSBhIGZhY3RvciBvZiB0d28gYWxsb2NhdGlvbiwgYnkgb25seSBhbGxvY2F0aW5nIHRoZVxuICAgICBmaW5hbCByZXN1bHQuICBUaGlzIGFsc28gc2F2ZXMgc29tZSBhbW91bnQgb2YgdGltZS4gKilcbiAgbGV0IHN0cmlwX2xpdGVyYWwgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0IH5lc2NhcGVfY2hhciA9XG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gICAgKCogcGVyZm9ybWFuY2UgaGFjazogYXZvaWQgY29weWluZyBbdF0gaW4gY29tbW9uIGNhc2VzICopXG4gICAgaWYgbGVuZ3RoID0gMCB8fCBub3QgKGRyb3AgdC5bMF0gfHwgZHJvcCB0LltsZW5ndGggLSAxXSlcbiAgICB0aGVuIHRcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGZpcnN0X25vbl9kcm9wX2xpdGVyYWwgdCB+ZHJvcCB+ZXNjYXBlX2NoYXIgd2l0aFxuICAgICAgfCBOb25lIC0+IFwiXCJcbiAgICAgIHwgU29tZSBmaXJzdCAtPlxuICAgICAgICAobWF0Y2ggbGFzdF9ub25fZHJvcF9saXRlcmFsIHQgfmRyb3AgfmVzY2FwZV9jaGFyIHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgIHwgU29tZSBsYXN0IC0+IHN1YiB0IH5wb3M6Zmlyc3QgfmxlbjoobGFzdCAtIGZpcnN0ICsgMSkpKVxuICA7O1xuZW5kXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxuKCogT3ZlcnJpZGUgW1NlYXJjaF9wYXR0ZXJuXSB3aXRoIGRlZmF1bHQgY2FzZS1zZW5zaXRpdml0eSBhcmd1bWVudCBhdCB0aGUgZW5kIG9mIHRoZVxuICAgZmlsZSwgc28gdGhhdCBjYWxsIHNpdGVzIGFib3ZlIGFyZSBmb3JjZWQgdG8gc3VwcGx5IGNhc2Utc2Vuc2l0aXZpdHkgZXhwbGljaXRseS4gKilcbm1vZHVsZSBTZWFyY2hfcGF0dGVybiA9IHN0cnVjdFxuICBpbmNsdWRlIFNlYXJjaF9wYXR0ZXJuMFxuXG4gIGxldCBjcmVhdGUgPyhjYXNlX3NlbnNpdGl2ZSA9IHRydWUpIHBhdHRlcm4gPSBjcmVhdGUgcGF0dGVybiB+Y2FzZV9zZW5zaXRpdmVcbmVuZFxuXG5tb2R1bGUgTWFrZV91dGYgKEZvcm1hdCA6IHNpZ1xuICB2YWwgY29kZWNfbmFtZSA6IHN0cmluZ1xuICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgdmFsIGlzX3ZhbGlkIDogdCAtPiBib29sXG4gIHZhbCBieXRlX2xlbmd0aCA6IFVjaGFyLnQgLT4gaW50XG4gIHZhbCBnZXRfZGVjb2RlX3Jlc3VsdCA6IHQgLT4gYnl0ZV9wb3M6aW50IC0+IFVjaGFyLnV0Zl9kZWNvZGVcbiAgdmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBVY2hhci50IC0+IGludFxuZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSBlbHQgPSBVY2hhci50XG4gIHR5cGUgdCA9IHN0cmluZ1xuXG4gIGxldCBjb2RlY19uYW1lID0gRm9ybWF0LmNvZGVjX25hbWVcbiAgbGV0IGlzX3ZhbGlkID0gRm9ybWF0LmlzX3ZhbGlkXG5cbiAgbGV0IHJhaXNlX2dldF9tZXNzYWdlID1cbiAgICBsYXp5XG4gICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgIFwiJXMuZ2V0OiBpbnZhbGlkICVzIGVuY29kaW5nIGF0IGdpdmVuIHBvc2l0aW9uXCJcbiAgICAgICAgIEZvcm1hdC5tb2R1bGVfbmFtZVxuICAgICAgICAgRm9ybWF0LmNvZGVjX25hbWUpXG4gIDs7XG5cbiAgbGV0W0Bjb2xkXSByYWlzZV9nZXQgdCBwb3MgPVxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2UgKExhenkuZm9yY2UgcmFpc2VfZ2V0X21lc3NhZ2UpIFsgXCJcIiwgQXRvbSB0OyBcInBvc1wiLCBzZXhwX29mX2ludCBwb3MgXSlcbiAgOztcblxuICBsZXQgZ2V0IHQgfmJ5dGVfcG9zID1cbiAgICAoKiBFdmVuIGlmIFt0XSBpcyB2YWxpZGF0ZWQsIHdlIG5lZWQgdG8gdmFsaWRhdGUgW3Bvc10sIHNvIHdlIGNoZWNrIHRoZSBkZWNvZGluZyAqKVxuICAgIGxldCBkZWNvZGUgPSBGb3JtYXQuZ2V0X2RlY29kZV9yZXN1bHQgdCB+Ynl0ZV9wb3MgaW5cbiAgICBpZiBVY2hhci51dGZfZGVjb2RlX2lzX3ZhbGlkIGRlY29kZVxuICAgIHRoZW4gVWNoYXIudXRmX2RlY29kZV91Y2hhciBkZWNvZGVcbiAgICBlbHNlIHJhaXNlX2dldCB0IGJ5dGVfcG9zXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IEZuLmlkXG4gIGxldCBvZl9zdHJpbmdfdW5jaGVja2VkID0gRm4uaWRcblxuICBsZXQgcmFpc2Vfb2Zfc3RyaW5nX21lc3NhZ2UgPVxuICAgIGNvbmNhdCBbIEZvcm1hdC5tb2R1bGVfbmFtZTsgXCIub2Zfc3RyaW5nOiBpbnZhbGlkIFwiOyBjb2RlY19uYW1lIF1cbiAgOztcblxuICBsZXRbQGNvbGRdIHJhaXNlX29mX3N0cmluZyBzdHJpbmcgPVxuICAgIHJhaXNlX3MgKFNleHAubWVzc2FnZSByYWlzZV9vZl9zdHJpbmdfbWVzc2FnZSBbIFwiXCIsIEF0b20gc3RyaW5nIF0pXG4gIDs7XG5cbiAgbGV0IG9mX3N0cmluZyBzdHJpbmcgPVxuICAgIG1hdGNoIGlzX3ZhbGlkIHN0cmluZyB3aXRoXG4gICAgfCB0cnVlIC0+IHN0cmluZ1xuICAgIHwgZmFsc2UgLT4gcmFpc2Vfb2Zfc3RyaW5nIHN0cmluZ1xuICA7O1xuXG4gIGluY2x1ZGUgU2V4cGFibGUuT2Zfc3RyaW5nYWJsZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBvZl9zdHJpbmcgPSBvZl9zdHJpbmdcbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGVuZClcblxuICBpbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gICAgbGV0IGhhc2ggPSBoYXNoXG4gICAgbGV0IGhhc2hfZm9sZF90ID0gaGFzaF9mb2xkX3RcbiAgICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbiAgICBsZXQgdF9vZl9zZXhwID0gdF9vZl9zZXhwXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gRm9ybWF0Lm1vZHVsZV9uYW1lXG4gIGVuZClcblxuICBsZXQgdG9fc2VxdWVuY2UgdCA9XG4gICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIFNlcXVlbmNlLnVuZm9sZCB+aW5pdDowIH5mOihmdW4gYnl0ZV9wb3MgLT5cbiAgICAgIGlmIGJ5dGVfcG9zID49IGxlblxuICAgICAgdGhlbiBOb25lXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGRlY29kZSA9IEZvcm1hdC5nZXRfZGVjb2RlX3Jlc3VsdCB0IH5ieXRlX3BvcyBpblxuICAgICAgICBTb21lIChVY2hhci51dGZfZGVjb2RlX3VjaGFyIGRlY29kZSwgYnl0ZV9wb3MgKyBVY2hhci51dGZfZGVjb2RlX2xlbmd0aCBkZWNvZGUpKSlcbiAgOztcblxuICBsZXQgZm9sZCB0IH5pbml0OmFjYyB+ZiA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgbGV0IHJlYyBsb29wIGJ5dGVfcG9zIGFjYyA9XG4gICAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIGJ5dGVfcG9zIGxlblxuICAgICAgdGhlbiBhY2NcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgZGVjb2RlID0gRm9ybWF0LmdldF9kZWNvZGVfcmVzdWx0IHQgfmJ5dGVfcG9zIGluXG4gICAgICAgIGxvb3BcbiAgICAgICAgICAoYnl0ZV9wb3MgKyBVY2hhci51dGZfZGVjb2RlX2xlbmd0aCBkZWNvZGUpXG4gICAgICAgICAgKGYgYWNjIChVY2hhci51dGZfZGVjb2RlX3VjaGFyIGRlY29kZSkpKVxuICAgIGluXG4gICAgbG9vcCAwIGFjYyBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHNhbml0aXplIHQgPVxuICAgIGxldCBsZW4gPSBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIHBvcyB1Y2hhciAtPiBwb3MgKyBGb3JtYXQuYnl0ZV9sZW5ndGggdWNoYXIpIGluXG4gICAgbGV0IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCBwb3MgPSBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIHBvcyB1Y2hhciAtPiBwb3MgKyBGb3JtYXQuc2V0IGJ5dGVzIHBvcyB1Y2hhcikgaW5cbiAgICBhc3NlcnQgKEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgcG9zIGxlbik7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpieXRlc1xuICA7O1xuXG4gIGxldCBvZl9saXN0IHVjaGFycyA9XG4gICAgbGV0IGxlbiA9IExpc3QuZm9sZCB1Y2hhcnMgfmluaXQ6MCB+ZjooZnVuIG4gdSAtPiBuICsgRm9ybWF0LmJ5dGVfbGVuZ3RoIHUpIGluXG4gICAgbGV0IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCBwb3MgPVxuICAgICAgTGlzdC5mb2xkIHVjaGFycyB+aW5pdDowIH5mOihmdW4gcG9zIHVjaGFyIC0+IHBvcyArIEZvcm1hdC5zZXQgYnl0ZXMgcG9zIHVjaGFyKVxuICAgIGluXG4gICAgYXNzZXJ0IChJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIHBvcyBsZW4pO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6Ynl0ZXNcbiAgOztcblxuICBsZXQgb2ZfYXJyYXkgdWNoYXJzID1cbiAgICBsZXQgbGVuID0gcmVmIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHVjaGFycyAtIDEgZG9cbiAgICAgIGxlbiA6PSAhbGVuICsgRm9ybWF0LmJ5dGVfbGVuZ3RoIHVjaGFycy4oaSlcbiAgICBkb25lO1xuICAgIGxldCBieXRlcyA9IEJ5dGVzLmNyZWF0ZSAhbGVuIGluXG4gICAgbGV0IHBvcyA9IHJlZiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB1Y2hhcnMgLSAxIGRvXG4gICAgICBwb3MgOj0gIXBvcyArIEZvcm1hdC5zZXQgYnl0ZXMgIXBvcyB1Y2hhcnMuKGkpXG4gICAgZG9uZTtcbiAgICBhc3NlcnQgKEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgIXBvcyAhbGVuKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmJ5dGVzXG4gIDs7XG5cbiAgbGV0IGNvbmNhdCBsaXN0ID0gY29uY2F0IH5zZXA6XCJcIiBsaXN0XG5cbiAgbGV0IHNwbGl0IHQgfm9uID1cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICBsZXRbQHRhaWxfbW9kX2NvbnNdIHJlYyBsb29wIH5zdGFydCB+dW50aWwgPVxuICAgICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCB1bnRpbCBsZW5cbiAgICAgIHRoZW4gWyBzdWIgdCB+cG9zOnN0YXJ0IH5sZW46KHVudGlsIC0gc3RhcnQpIF1cbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgdWNoYXIgPSBnZXQgdCB+Ynl0ZV9wb3M6dW50aWwgaW5cbiAgICAgICAgbGV0IG5leHQgPSB1bnRpbCArIEZvcm1hdC5ieXRlX2xlbmd0aCB1Y2hhciBpblxuICAgICAgICBpZiBVY2hhci5lcXVhbCB1Y2hhciBvblxuICAgICAgICB0aGVuIHN1YiB0IH5wb3M6c3RhcnQgfmxlbjoodW50aWwgLSBzdGFydCkgOjogbG9vcCB+c3RhcnQ6bmV4dCB+dW50aWw6bmV4dFxuICAgICAgICBlbHNlIGxvb3AgfnN0YXJ0IH51bnRpbDpuZXh0KVxuICAgIGluXG4gICAgbG9vcCB+c3RhcnQ6MCB+dW50aWw6MCBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbW9kdWxlIEMgPSBJbmRleGVkX2NvbnRhaW5lci5NYWtlMF93aXRoX2NyZWF0b3JzIChzdHJ1Y3RcbiAgICBtb2R1bGUgRWx0ID0gVWNoYXJcblxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgY29uY2F0ID0gY29uY2F0XG4gICAgbGV0IG9mX2xpc3QgPSBvZl9saXN0XG4gICAgbGV0IG9mX2FycmF5ID0gb2ZfYXJyYXlcbiAgICBsZXQgaW5pdCA9IGBEZWZpbmVfdXNpbmdfb2ZfYXJyYXlcbiAgICBsZXQgbGVuZ3RoID0gYERlZmluZV91c2luZ19mb2xkXG4gICAgbGV0IGZvbGRpID0gYERlZmluZV91c2luZ19mb2xkXG4gICAgbGV0IGl0ZXIgPSBgRGVmaW5lX3VzaW5nX2ZvbGRcbiAgICBsZXQgaXRlcmkgPSBgRGVmaW5lX3VzaW5nX2ZvbGRcbiAgICBsZXQgY29uY2F0X21hcGkgPSBgRGVmaW5lX3VzaW5nX2NvbmNhdFxuICBlbmQpXG5cbiAgbGV0IGFwcGVuZCA9IEMuYXBwZW5kXG4gIGxldCBjb25jYXRfbWFwID0gQy5jb25jYXRfbWFwXG4gIGxldCBjb25jYXRfbWFwaSA9IEMuY29uY2F0X21hcGlcbiAgbGV0IGNvdW50ID0gQy5jb3VudFxuICBsZXQgY291bnRpID0gQy5jb3VudGlcbiAgbGV0IGV4aXN0cyA9IEMuZXhpc3RzXG4gIGxldCBleGlzdHNpID0gQy5leGlzdHNpXG4gIGxldCBmaWx0ZXIgPSBDLmZpbHRlclxuICBsZXQgZmlsdGVyX21hcCA9IEMuZmlsdGVyX21hcFxuICBsZXQgZmlsdGVyX21hcGkgPSBDLmZpbHRlcl9tYXBpXG4gIGxldCBmaWx0ZXJpID0gQy5maWx0ZXJpXG4gIGxldCBmaW5kID0gQy5maW5kXG4gIGxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbiAgbGV0IGZpbmRfbWFwaSA9IEMuZmluZF9tYXBpXG4gIGxldCBmaW5kaSA9IEMuZmluZGlcbiAgbGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxuICBsZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxuICBsZXQgZm9sZGkgPSBDLmZvbGRpXG4gIGxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG4gIGxldCBmb3JfYWxsaSA9IEMuZm9yX2FsbGlcbiAgbGV0IGluaXQgPSBDLmluaXRcbiAgbGV0IGlzX2VtcHR5ID0gQy5pc19lbXB0eVxuICBsZXQgaXRlciA9IEMuaXRlclxuICBsZXQgaXRlcmkgPSBDLml0ZXJpXG4gIGxldCBsZW5ndGggPSBDLmxlbmd0aFxuICBsZXQgbWFwID0gQy5tYXBcbiAgbGV0IG1hcGkgPSBDLm1hcGlcbiAgbGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbiAgbGV0IG1lbSA9IEMubWVtXG4gIGxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG4gIGxldCBwYXJ0aXRpb25fbWFwID0gQy5wYXJ0aXRpb25fbWFwXG4gIGxldCBwYXJ0aXRpb25fdGYgPSBDLnBhcnRpdGlvbl90ZlxuICBsZXQgc3VtID0gQy5zdW1cbiAgbGV0IHRvX2FycmF5ID0gQy50b19hcnJheVxuICBsZXQgdG9fbGlzdCA9IEMudG9fbGlzdFxuICBsZXQgbGVuZ3RoX2luX3VjaGFycyA9IGxlbmd0aFxuZW5kXG5cbm1vZHVsZSBVdGY4ID0gTWFrZV91dGYgKHN0cnVjdFxuICBsZXQgY29kZWNfbmFtZSA9IFwiVVRGLThcIlxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuU3RyaW5nLlV0ZjhcIlxuICBsZXQgaXNfdmFsaWQgPSBpc192YWxpZF91dGZfOFxuICBsZXQgYnl0ZV9sZW5ndGggPSBVY2hhci51dGZfOF9ieXRlX2xlbmd0aFxuICBsZXQgZ2V0X2RlY29kZV9yZXN1bHQgPSBnZXRfdXRmXzhfdWNoYXJcbiAgbGV0IHNldCA9IEJ5dGVzLnNldF91Y2hhcl91dGZfOFxuZW5kKVxuXG5tb2R1bGUgVXRmMTZsZSA9IE1ha2VfdXRmIChzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBcIlVURi0xNkxFXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlN0cmluZy5VdGYxNmxlXCJcbiAgbGV0IGlzX3ZhbGlkID0gaXNfdmFsaWRfdXRmXzE2bGVcbiAgbGV0IGJ5dGVfbGVuZ3RoID0gVWNoYXIudXRmXzE2X2J5dGVfbGVuZ3RoXG4gIGxldCBnZXRfZGVjb2RlX3Jlc3VsdCA9IGdldF91dGZfMTZsZV91Y2hhclxuICBsZXQgc2V0ID0gQnl0ZXMuc2V0X3VjaGFyX3V0Zl8xNmxlXG5lbmQpXG5cbm1vZHVsZSBVdGYxNmJlID0gTWFrZV91dGYgKHN0cnVjdFxuICBsZXQgY29kZWNfbmFtZSA9IFwiVVRGLTE2QkVcIlxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuU3RyaW5nLlV0ZjE2YmVcIlxuICBsZXQgaXNfdmFsaWQgPSBpc192YWxpZF91dGZfMTZiZVxuICBsZXQgYnl0ZV9sZW5ndGggPSBVY2hhci51dGZfMTZfYnl0ZV9sZW5ndGhcbiAgbGV0IGdldF9kZWNvZGVfcmVzdWx0ID0gZ2V0X3V0Zl8xNmJlX3VjaGFyXG4gIGxldCBzZXQgPSBCeXRlcy5zZXRfdWNoYXJfdXRmXzE2YmVcbmVuZClcblxubW9kdWxlIE1ha2VfdXRmMzIgKEZvcm1hdCA6IHNpZ1xuICB2YWwgY29kZWNfbmFtZSA6IHN0cmluZ1xuICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgdmFsIGdldF9kZWNvZGVfcmVzdWx0IDogdCAtPiBieXRlX3BvczppbnQgLT4gVWNoYXIudXRmX2RlY29kZVxuICB2YWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IFVjaGFyLnQgLT4gaW50XG5lbmQpID1cbk1ha2VfdXRmIChzdHJ1Y3RcbiAgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IGJ5dGVfbGVuZ3RoIF8gPSA0XG4gIGxldCBjb2RlY19uYW1lID0gRm9ybWF0LmNvZGVjX25hbWVcbiAgbGV0IG1vZHVsZV9uYW1lID0gRm9ybWF0Lm1vZHVsZV9uYW1lXG4gIGxldCBzZXQgPSBGb3JtYXQuc2V0XG4gIGxldCBnZXRfZGVjb2RlX3Jlc3VsdCA9IEZvcm1hdC5nZXRfZGVjb2RlX3Jlc3VsdFxuXG4gIGxldCBpc192YWxpZCB0ID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCB0IGluXG4gICAgbWF0Y2ggbGVuIG1vZCA0IHdpdGhcbiAgICB8IDAgLT5cbiAgICAgIGxldCByZWMgbG9vcCBieXRlX3BvcyA9XG4gICAgICAgIG1hdGNoIGJ5dGVfcG9zIDwgbGVuIHdpdGhcbiAgICAgICAgfCBmYWxzZSAtPiB0cnVlXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgIGxldCByZXN1bHQgPSBGb3JtYXQuZ2V0X2RlY29kZV9yZXN1bHQgdCB+Ynl0ZV9wb3MgaW5cbiAgICAgICAgICBVY2hhci51dGZfZGVjb2RlX2lzX3ZhbGlkIHJlc3VsdCAmJiBsb29wIChieXRlX3BvcyArIDQpXG4gICAgICBpblxuICAgICAgbG9vcCAwIFtAbm9udGFpbF1cbiAgICB8IF8gLT4gZmFsc2VcbiAgOztcbmVuZClcblxubW9kdWxlIFV0ZjMybGUgPSBNYWtlX3V0ZjMyIChzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBcIlVURi0zMkxFXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlN0cmluZy5VdGYzMmxlXCJcbiAgbGV0IGdldF9kZWNvZGVfcmVzdWx0ID0gZ2V0X3V0Zl8zMmxlX3VjaGFyXG4gIGxldCBzZXQgPSBCeXRlcy5zZXRfdWNoYXJfdXRmXzMybGVcbmVuZClcblxubW9kdWxlIFV0ZjMyYmUgPSBNYWtlX3V0ZjMyIChzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBcIlVURi0zMkJFXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlN0cmluZy5VdGYzMmJlXCJcbiAgbGV0IGdldF9kZWNvZGVfcmVzdWx0ID0gZ2V0X3V0Zl8zMmJlX3VjaGFyXG4gIGxldCBzZXQgPSBCeXRlcy5zZXRfdWNoYXJfdXRmXzMyYmVcbmVuZClcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIFN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5pbmNsdWRlIEJ5dGVzX2ludGZcblxubGV0IHN0YWdlID0gU3RhZ2VkLnN0YWdlXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGJ5dGVzIFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGdsb2JhbGl6ZSA6IHQgLT4gdCkgPSAoZ2xvYmFsaXplX2J5dGVzIDogdCAtPiB0KVxuICBsZXQgdF9vZl9zZXhwID0gKGJ5dGVzX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2J5dGVzIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGJ5dGVzX3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBCeXRlczBcblxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuQnl0ZXNcIlxuICBsZXQgcHAgZm10IHQgPSBTdGRsaWIuRm9ybWF0LmZwcmludGYgZm10IFwiJVNcIiAodG9fc3RyaW5nIHQpXG5lbmRcblxuaW5jbHVkZSBUXG5cbm1vZHVsZSBUb19ieXRlcyA9IEJsaXQuTWFrZSAoc3RydWN0XG4gIGluY2x1ZGUgVFxuXG4gIGxldCBjcmVhdGUgfmxlbiA9IGNyZWF0ZSBsZW5cbmVuZClcblxuaW5jbHVkZSBUb19ieXRlc1xuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyX3BwIChUKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBCeXRlc19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbm1vZHVsZSBUb19zdHJpbmcgPSBCbGl0Lk1ha2VfdG9fc3RyaW5nIChUKSAoVG9fYnl0ZXMpXG5cbm1vZHVsZSBGcm9tX3N0cmluZyA9XG4gIEJsaXQuTWFrZV9kaXN0aW5jdFxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IHN0cmluZ1xuXG4gICAgICBsZXQgbGVuZ3RoID0gU3RyaW5nLmxlbmd0aFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBsZXQgY3JlYXRlIH5sZW4gPSBjcmVhdGUgbGVuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdF9zdHJpbmdcbiAgICBlbmQpXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5cbmxldCBpbml0IG4gfmYgPVxuICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIG4gMFxuICB0aGVuIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJCeXRlcy5pbml0ICVkXCIgbiAoKTtcbiAgbGV0IHQgPSBjcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHQgaSAoZiBpKVxuICBkb25lO1xuICB0XG47O1xuXG5sZXQgb2ZfY2hhcl9saXN0IGwgPVxuICBsZXQgdCA9IGNyZWF0ZSAoTGlzdC5sZW5ndGggbCkgaW5cbiAgTGlzdC5pdGVyaSBsIH5mOihmdW4gaSBjIC0+IHNldCB0IGkgYyk7XG4gIHRcbjs7XG5cbmxldCB0b19saXN0IHQgPVxuICBsZXQgcmVjIGxvb3AgdCBpIGFjYyA9XG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBpIDBcbiAgICB0aGVuIGFjY1xuICAgIGVsc2UgbG9vcCB0IChpIC0gMSkgKHVuc2FmZV9nZXQgdCBpIDo6IGFjYylcbiAgaW5cbiAgbG9vcCB0IChsZW5ndGggdCAtIDEpIFtdXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9IEFycmF5LmluaXQgKGxlbmd0aCB0KSB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5sZXQgbWFwIHQgfmYgPSBtYXAgdCB+ZlxubGV0IG1hcGkgdCB+ZiA9IG1hcGkgdCB+ZlxuXG5sZXQgZm9sZCA9XG4gIGxldCByZWMgbG9vcCB0IH5mIH5sZW4gfnBvcyBhY2MgPVxuICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgcG9zIGxlblxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSBsb29wIHQgfmYgfmxlbiB+cG9zOihwb3MgKyAxKSAoZiBhY2MgKHVuc2FmZV9nZXQgdCBwb3MpKVxuICBpblxuICBmdW4gdCB+aW5pdCB+ZiAtPiBsb29wIHQgfmYgfmxlbjoobGVuZ3RoIHQpIH5wb3M6MCBpbml0XG47O1xuXG5sZXQgZm9sZGkgPVxuICBsZXQgcmVjIGxvb3AgdCB+ZiB+bGVuIH5wb3MgYWNjID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIHBvcyBsZW5cbiAgICB0aGVuIGFjY1xuICAgIGVsc2UgbG9vcCB0IH5mIH5sZW4gfnBvczoocG9zICsgMSkgKGYgcG9zIGFjYyAodW5zYWZlX2dldCB0IHBvcykpXG4gIGluXG4gIGZ1biB0IH5pbml0IH5mIC0+IGxvb3AgdCB+ZiB+bGVuOihsZW5ndGggdCkgfnBvczowIGluaXRcbjs7XG5cbmxldCB0ciB+dGFyZ2V0IH5yZXBsYWNlbWVudCBzID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgIGlmIENoYXIuZXF1YWwgKHVuc2FmZV9nZXQgcyBpKSB0YXJnZXQgdGhlbiB1bnNhZmVfc2V0IHMgaSByZXBsYWNlbWVudFxuICBkb25lXG47O1xuXG5sZXQgdHJfbXVsdGkgfnRhcmdldCB+cmVwbGFjZW1lbnQgPVxuICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChTdHJpbmcubGVuZ3RoIHRhcmdldCkgMFxuICB0aGVuIHN0YWdlIGlnbm9yZVxuICBlbHNlIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQpIDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcInRyX211bHRpOiByZXBsYWNlbWVudCBpcyB0aGUgZW1wdHkgc3RyaW5nXCJcbiAgZWxzZSAoXG4gICAgbWF0Y2ggQnl0ZXNfdHIudHJfY3JlYXRlX21hcCB+dGFyZ2V0IH5yZXBsYWNlbWVudCB3aXRoXG4gICAgfCBOb25lIC0+IHN0YWdlIGlnbm9yZVxuICAgIHwgU29tZSB0cl9tYXAgLT5cbiAgICAgIHN0YWdlIChmdW4gcyAtPlxuICAgICAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBzIGkgKFN0cmluZy51bnNhZmVfZ2V0IHRyX21hcCAoQ2hhci50b19pbnQgKHVuc2FmZV9nZXQgcyBpKSkpXG4gICAgICAgIGRvbmUpKVxuOztcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxubGV0IGNvbnRhaW5zID9wb3MgP2xlbiB0IGNoYXIgPVxuICBsZXQgcG9zLCBsZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggdClcbiAgaW5cbiAgbGV0IGxhc3QgPSBwb3MgKyBsZW4gaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgaSBsYXN0XG4gICAgJiYgKENoYXIuZXF1YWwgKGdldCB0IGkpIGNoYXIgfHwgbG9vcCAoaSArIDEpKVxuICBpblxuICBsb29wIHBvc1xuOztcblxubW9kdWxlIFV0ZjggPSBzdHJ1Y3RcbiAgbGV0IHNldCA9IHNldF91Y2hhcl91dGZfOFxuZW5kXG5cbm1vZHVsZSBVdGYxNmxlID0gc3RydWN0XG4gIGxldCBzZXQgPSBzZXRfdWNoYXJfdXRmXzE2bGVcbmVuZFxuXG5tb2R1bGUgVXRmMTZiZSA9IHN0cnVjdFxuICBsZXQgc2V0ID0gc2V0X3VjaGFyX3V0Zl8xNmJlXG5lbmRcblxubW9kdWxlIFV0ZjMybGUgPSBzdHJ1Y3RcbiAgbGV0IHNldCA9IHNldF91Y2hhcl91dGZfMzJsZVxuZW5kXG5cbm1vZHVsZSBVdGYzMmJlID0gc3RydWN0XG4gIGxldCBzZXQgPSBzZXRfdWNoYXJfdXRmXzMyYmVcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgQnl0ZXNfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCIjIDEgXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gXG50eXBlIHJlc3VsdCA9XG58IE5lZyBvZiBzdHJpbmdcbnwgUG9zIG9mIHN0cmluZ1xuXG4jIDggXCJzcmMvaGV4X2xleGVyLm1sXCJcbmxldCBfX29jYW1sX2xleF90YWJsZXMgPSB7XG4gIExleGluZy5sZXhfYmFzZSA9XG4gICBcIlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwMFxcMDAxXFwwMDBcXDAwMlxcMDAwXFwwMjdcXDAwMFxcMDgyXFwwMDBcXDEwNVxcMDAwXFxcbiAgICBcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMDAxXFwwMDBcXFxuICAgIFwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHQgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXCI7XG4gIExleGluZy5sZXhfdHJhbnMgPVxuICAgXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMVxcMDAwXFwwMDNcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDRcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFwiO1xuICBMZXhpbmcubGV4X2NoZWNrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwMVxcMDAwXFwwMDNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDI1NVxcMjU1XFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDA3XFwwMDBcXDI1NVxcMjU1XFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcIjtcbiAgTGV4aW5nLmxleF9iYXNlX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9kZWZhdWx0X2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF90cmFuc19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY2hlY2tfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2NvZGUgPVxuICAgXCJcIjtcbn1cblxubGV0IHJlYyBwYXJzZV9oZXggbGV4YnVmID1cbiAgIF9fb2NhbWxfbGV4X3BhcnNlX2hleF9yZWMgbGV4YnVmIDBcbmFuZCBfX29jYW1sX2xleF9wYXJzZV9oZXhfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZSA9XG4gIG1hdGNoIExleGluZy5lbmdpbmUgX19vY2FtbF9sZXhfdGFibGVzIF9fb2NhbWxfbGV4X3N0YXRlIGxleGJ1ZiB3aXRoXG4gICAgICB8IDAgLT5cbmxldFxuIyA4IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keVxuIyAxMzUgXCJzcmMvaGV4X2xleGVyLm1sXCJcbj0gTGV4aW5nLnN1Yl9sZXhlbWUgbGV4YnVmIChsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgKyAzKSBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3BvcyBpblxuIyAxNCBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCBOZWcgYm9keSApXG4jIDEzOSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuXG4gIHwgMSAtPlxubGV0XG4jIDggXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5XG4jIDE0NSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuPSBMZXhpbmcuc3ViX2xleGVtZSBsZXhidWYgKGxleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BvcyArIDIpIGxleGJ1Zi5MZXhpbmcubGV4X2N1cnJfcG9zIGluXG4jIDE1IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoIFBvcyBib2R5IClcbiMgMTQ5IFwic3JjL2hleF9sZXhlci5tbFwiXG5cbiAgfCBfX29jYW1sX2xleF9zdGF0ZSAtPiBsZXhidWYuTGV4aW5nLnJlZmlsbF9idWZmIGxleGJ1ZjtcbiAgICAgIF9fb2NhbWxfbGV4X3BhcnNlX2hleF9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlXG5cbjs7XG5cbiIsIm9wZW4hIEltcG9ydFxuXG4oKiBzdHJpbmcgY29udmVyc2lvbnMgKilcblxubGV0IGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgaW5wdXQgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlciA9XG4gIGxldCBpbnB1dF9sZW5ndGggPSBTdHJpbmcubGVuZ3RoIGlucHV0IGluXG4gIGlmIGlucHV0X2xlbmd0aCA8PSBjaGFyc19wZXJfZGVsaW1pdGVyXG4gIHRoZW4gaW5wdXRcbiAgZWxzZSAoXG4gICAgbGV0IGhhc19zaWduID1cbiAgICAgIG1hdGNoIGlucHV0LlswXSB3aXRoXG4gICAgICB8ICcrJyB8ICctJyAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcbiAgICBpblxuICAgIGxldCBudW1fZGlnaXRzID0gaWYgaGFzX3NpZ24gdGhlbiBpbnB1dF9sZW5ndGggLSAxIGVsc2UgaW5wdXRfbGVuZ3RoIGluXG4gICAgbGV0IG51bV9kZWxpbWl0ZXJzID0gKG51bV9kaWdpdHMgLSAxKSAvIGNoYXJzX3Blcl9kZWxpbWl0ZXIgaW5cbiAgICBsZXQgb3V0cHV0X2xlbmd0aCA9IGlucHV0X2xlbmd0aCArIG51bV9kZWxpbWl0ZXJzIGluXG4gICAgbGV0IG91dHB1dCA9IEJ5dGVzLmNyZWF0ZSBvdXRwdXRfbGVuZ3RoIGluXG4gICAgbGV0IGlucHV0X3BvcyA9IHJlZiAoaW5wdXRfbGVuZ3RoIC0gMSkgaW5cbiAgICBsZXQgb3V0cHV0X3BvcyA9IHJlZiAob3V0cHV0X2xlbmd0aCAtIDEpIGluXG4gICAgbGV0IG51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXIgPSByZWYgY2hhcnNfcGVyX2RlbGltaXRlciBpblxuICAgIGxldCBmaXJzdF9kaWdpdF9wb3MgPSBpZiBoYXNfc2lnbiB0aGVuIDEgZWxzZSAwIGluXG4gICAgd2hpbGUgIWlucHV0X3BvcyA+PSBmaXJzdF9kaWdpdF9wb3MgZG9cbiAgICAgIGlmICFudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIEJ5dGVzLnNldCBvdXRwdXQgIW91dHB1dF9wb3MgZGVsaW1pdGVyO1xuICAgICAgICBkZWNyIG91dHB1dF9wb3M7XG4gICAgICAgIG51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXIgOj0gY2hhcnNfcGVyX2RlbGltaXRlcik7XG4gICAgICBCeXRlcy5zZXQgb3V0cHV0ICFvdXRwdXRfcG9zIGlucHV0LlshaW5wdXRfcG9zXTtcbiAgICAgIGRlY3IgaW5wdXRfcG9zO1xuICAgICAgZGVjciBvdXRwdXRfcG9zO1xuICAgICAgZGVjciBudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyXG4gICAgZG9uZTtcbiAgICBpZiBoYXNfc2lnbiB0aGVuIEJ5dGVzLnNldCBvdXRwdXQgMCBpbnB1dC5bMF07XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpvdXRwdXQpXG47O1xuXG5sZXQgaW5zZXJ0X2RlbGltaXRlciBpbnB1dCB+ZGVsaW1pdGVyID1cbiAgaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSBpbnB1dCB+ZGVsaW1pdGVyIH5jaGFyc19wZXJfZGVsaW1pdGVyOjNcbjs7XG5cbmxldCBpbnNlcnRfdW5kZXJzY29yZXMgaW5wdXQgPSBpbnNlcnRfZGVsaW1pdGVyIGlucHV0IH5kZWxpbWl0ZXI6J18nXG5sZXQgc2V4cF9vZl9pbnRfc3R5bGUgPSBTZXhwLm9mX2ludF9zdHlsZVxuXG5tb2R1bGUgTWFrZSAoSSA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbmVuZCkgPVxuc3RydWN0XG4gIG9wZW4gSVxuXG4gIGxldCBjaGFyc19wZXJfZGVsaW1pdGVyID0gM1xuXG4gIGxldCB0b19zdHJpbmdfaHVtID8oZGVsaW1pdGVyID0gJ18nKSB0ID1cbiAgICBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5ICh0b19zdHJpbmcgdCkgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlclxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgdCA9XG4gICAgbGV0IHMgPSB0b19zdHJpbmcgdCBpblxuICAgIFNleHAuQXRvbVxuICAgICAgKG1hdGNoICFzZXhwX29mX2ludF9zdHlsZSB3aXRoXG4gICAgICAgfCBgVW5kZXJzY29yZXMgLT4gaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSBzIH5jaGFyc19wZXJfZGVsaW1pdGVyIH5kZWxpbWl0ZXI6J18nXG4gICAgICAgfCBgTm9fdW5kZXJzY29yZXMgLT4gcylcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZV9oZXggKEkgOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlNfbG9jYWwgd2l0aCB0eXBlIHQgOj0gdFxuICBpbmNsdWRlIFBweF9oYXNoX2xpYi5IYXNoYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICBbQEBAZW5kXVxuXG4gIHZhbCB0b19zdHJpbmcgOiB0IC0+IHN0cmluZ1xuICB2YWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IHRcbiAgdmFsIHplcm8gOiB0XG4gIHZhbCAoIDwgKSA6IHQgLT4gdCAtPiBib29sXG4gIHZhbCBuZWcgOiB0IC0+IHRcbiAgdmFsIG1vZHVsZV9uYW1lIDogc3RyaW5nXG5lbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgVF9oZXggPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBJLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKEkuY29tcGFyZV9fbG9jYWwgOiB0IC0+IHQgLT4gaW50KVxuICAgIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIEkuaGFzaF9mb2xkX3RcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gSS5oYXNoIGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjaGFyc19wZXJfZGVsaW1pdGVyID0gNFxuXG4gICAgbGV0IHRvX3N0cmluZycgP2RlbGltaXRlciB0ID1cbiAgICAgIGxldCBtYWtlX3N1ZmZpeCA9XG4gICAgICAgIG1hdGNoIGRlbGltaXRlciB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBJLnRvX3N0cmluZ1xuICAgICAgICB8IFNvbWUgZGVsaW1pdGVyIC0+XG4gICAgICAgICAgZnVuIHQgLT4gaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSAoSS50b19zdHJpbmcgdCkgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlclxuICAgICAgaW5cbiAgICAgIGlmIEkuKCA8ICkgdCBJLnplcm8gdGhlbiBcIi0weFwiIF4gbWFrZV9zdWZmaXggKEkubmVnIHQpIGVsc2UgXCIweFwiIF4gbWFrZV9zdWZmaXggdFxuICAgIDs7XG5cbiAgICBsZXQgdG9fc3RyaW5nIHQgPSB0b19zdHJpbmcnIHQgP2RlbGltaXRlcjpOb25lXG4gICAgbGV0IHRvX3N0cmluZ19odW0gPyhkZWxpbWl0ZXIgPSAnXycpIHQgPSB0b19zdHJpbmcnIHQgfmRlbGltaXRlclxuXG4gICAgbGV0IGludmFsaWQgc3RyID1cbiAgICAgIFByaW50Zi5mYWlsd2l0aGYgXCIlcy5vZl9zdHJpbmc6IGludmFsaWQgaW5wdXQgJVNcIiBJLm1vZHVsZV9uYW1lIHN0ciAoKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc3RyaW5nX3dpdGhfZGVsaW1pdGVyIHN0ciA9XG4gICAgICBJLm9mX3N0cmluZyAoU3RyaW5nLmZpbHRlciBzdHIgfmY6KGZ1biBjIC0+IENoYXIuKCA8PiApIGMgJ18nKSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX3N0cmluZyBzdHIgPVxuICAgICAgbGV0IG1vZHVsZSBMID0gSGV4X2xleGVyIGluXG4gICAgICBsZXQgbGV4ID0gU3RkbGliLkxleGluZy5mcm9tX3N0cmluZyBzdHIgaW5cbiAgICAgIGxldCByZXN1bHQgPSBPcHRpb24udHJ5X3dpdGggKGZ1biAoKSAtPiBMLnBhcnNlX2hleCBsZXgpIGluXG4gICAgICBpZiBsZXgubGV4X2N1cnJfcG9zID0gbGV4LmxleF9idWZmZXJfbGVuXG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGludmFsaWQgc3RyXG4gICAgICAgIHwgU29tZSAoTmVnIGJvZHkpIC0+IEkubmVnIChvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIgYm9keSlcbiAgICAgICAgfCBTb21lIChQb3MgYm9keSkgLT4gb2Zfc3RyaW5nX3dpdGhfZGVsaW1pdGVyIGJvZHkpXG4gICAgICBlbHNlIGludmFsaWQgc3RyXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEhleCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVF9oZXhcbiAgICBpbmNsdWRlIFNleHBhYmxlLk9mX3N0cmluZ2FibGUgKFRfaGV4KVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZV9iaW5hcnkgKEkgOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBoYXNoXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuU19sb2NhbCB3aXRoIHR5cGUgdCA6PSB0XG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkVxdWFsLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TX2xvY2FsIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBQcHhfaGFzaF9saWIuSGFzaGFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgW0BAQGVuZF1cblxuICB2YWwgY2x6IDogdCAtPiBpbnRcbiAgdmFsICggbHNyICkgOiB0IC0+IGludCAtPiB0XG4gIHZhbCAoIGxhbmQgKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCB0b19pbnRfZXhuIDogdCAtPiBpbnRcbiAgdmFsIG51bV9iaXRzIDogaW50XG4gIHZhbCB6ZXJvIDogdFxuICB2YWwgb25lIDogdFxuZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIEJpbmFyeSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IEkudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGhhc2hdXG5cbiAgICBsZXQgY29tcGFyZV9fbG9jYWwgPSAoSS5jb21wYXJlX19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gICAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgSS5oYXNoX2ZvbGRfdFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBJLmhhc2ggaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGJpdHMgdCA9IGlmIEkuZXF1YWxfX2xvY2FsIHQgSS56ZXJvIHRoZW4gMCBlbHNlIEkubnVtX2JpdHMgLSBJLmNseiB0XG5cbiAgICBsZXQgdG9fc3RyaW5nX3N1ZmZpeCAodCA6IHQpID1cbiAgICAgIGxldCBiaXRzID0gYml0cyB0IGluXG4gICAgICBpZiBiaXRzID0gMFxuICAgICAgdGhlbiBcIjBcIlxuICAgICAgZWxzZVxuICAgICAgICBTdHJpbmcuaW5pdCBiaXRzIH5mOihmdW4gY2hhcl9pbmRleCAtPlxuICAgICAgICAgIGxldCBiaXRfaW5kZXggPSBiaXRzIC0gY2hhcl9pbmRleCAtIDEgaW5cbiAgICAgICAgICBsZXQgYml0ID0gSS4oKHQgbHNyIGJpdF9pbmRleCkgbGFuZCBvbmUpIGluXG4gICAgICAgICAgQ2hhci51bnNhZmVfb2ZfaW50IChDaGFyLnRvX2ludCAnMCcgKyBJLnRvX2ludF9leG4gYml0KSlcbiAgICA7O1xuXG4gICAgbGV0IHRvX3N0cmluZyAodCA6IHQpID0gXCIwYlwiIF4gdG9fc3RyaW5nX3N1ZmZpeCB0XG5cbiAgICBsZXQgdG9fc3RyaW5nX2h1bSA/KGRlbGltaXRlciA9ICdfJykgdCA9XG4gICAgICBcIjBiXCIgXiBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5ICh0b19zdHJpbmdfc3VmZml4IHQpIH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXI6NFxuICAgIDs7XG5cbiAgICBsZXQgc2V4cF9vZl90ICh0IDogdCkgOiBTZXhwLnQgPSBBdG9tICh0b19zdHJpbmdfaHVtIHQpXG4gIGVuZFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxuKCogQyBzdHViIGZvciBpbnQgcG9wY291bnQgdG8gdXNlIHRoZSBQT1BDTlQgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbmV4dGVybmFsIGludF9wb3Bjb3VudCA6IGludCAtPiBpbnQgPSBcIkJhc2VfaW50X21hdGhfaW50X3BvcGNvdW50XCIgW0BAbm9hbGxvY11cblxuKCogVG8gbWFpbnRhaW4gamF2YXNjcmlwdCBjb21wYXRpYmlsaXR5IGFuZCBlbmFibGUgdW5ib3hpbmcsIHdlIGltcGxlbWVudCBwb3Bjb3VudCBpblxuICAgT0NhbWwgcmF0aGVyIHRoYW4gdXNlIEMgc3R1YnMuIEltcGxlbWVudGF0aW9uIGFkYXB0ZWQgZnJvbTpcbiAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhbW1pbmdfd2VpZ2h0I0VmZmljaWVudF9pbXBsZW1lbnRhdGlvbiAqKVxubGV0IGludDY0X3BvcGNvdW50ID1cbiAgbGV0IG9wZW4gU3RkbGliLkludDY0IGluXG4gIGxldCAoICsgKSA9IGFkZCBpblxuICBsZXQgKCAtICkgPSBzdWIgaW5cbiAgbGV0ICggKiApID0gbXVsIGluXG4gIGxldCAoIGxzciApID0gc2hpZnRfcmlnaHRfbG9naWNhbCBpblxuICBsZXQgKCBsYW5kICkgPSBsb2dhbmQgaW5cbiAgbGV0IG0xID0gMHg1NTU1NTU1NTU1NTU1NTU1TCBpblxuICAoKiAwYjAxMDEwMTAxLi4uICopXG4gIGxldCBtMiA9IDB4MzMzMzMzMzMzMzMzMzMzM0wgaW5cbiAgKCogMGIwMDExMDAxMS4uLiAqKVxuICBsZXQgbTQgPSAweDBmMGYwZjBmMGYwZjBmMGZMIGluXG4gICgqIDBiMDAwMDExMTEuLi4gKilcbiAgbGV0IGgwMSA9IDB4MDEwMTAxMDEwMTAxMDEwMUwgaW5cbiAgKCogMSBiaXQgc2V0IHBlciBieXRlICopXG4gIGZ1biBbQGlubGluZV0geCAtPlxuICAgICgqIGdhdGhlciB0aGUgYml0IGNvdW50IGZvciBldmVyeSBwYWlyIG9mIGJpdHMgKilcbiAgICBsZXQgeCA9IHggLSAoKHggbHNyIDEpIGxhbmQgbTEpIGluXG4gICAgKCogZ2F0aGVyIHRoZSBiaXQgY291bnQgZm9yIGV2ZXJ5IDQgYml0cyAqKVxuICAgIGxldCB4ID0gKHggbGFuZCBtMikgKyAoKHggbHNyIDIpIGxhbmQgbTIpIGluXG4gICAgKCogZ2F0aGVyIHRoZSBiaXQgY291bnQgZm9yIGV2ZXJ5IGJ5dGUgKilcbiAgICBsZXQgeCA9ICh4ICsgKHggbHNyIDQpKSBsYW5kIG00IGluXG4gICAgKCogc3VtIHRoZSBiaXQgY291bnRzIGluIHRoZSB0b3AgYnl0ZSBhbmQgc2hpZnQgaXQgZG93biAqKVxuICAgIHRvX2ludCAoKHggKiBoMDEpIGxzciA1Nilcbjs7XG5cbmxldCBpbnQzMl9wb3Bjb3VudCA9XG4gICgqIE9uIDY0LWJpdCBzeXN0ZW1zLCB0aGlzIGlzIGZhc3RlciB0aGFuIGltcGxlbWVudGluZyB1c2luZyBbaW50MzJdIGFyaXRobWV0aWMuICopXG4gIGxldCBtYXNrID0gMHhmZmZmX2ZmZmZMIGluXG4gIGZ1biBbQGlubGluZV0geCAtPiBpbnQ2NF9wb3Bjb3VudCAoU3RkbGliLkludDY0LmxvZ2FuZCAoU3RkbGliLkludDY0Lm9mX2ludDMyIHgpIG1hc2spXG47O1xuXG5sZXQgbmF0aXZlaW50X3BvcGNvdW50ID1cbiAgbWF0Y2ggU3RkbGliLk5hdGl2ZWludC5zaXplIHdpdGhcbiAgfCAzMiAtPiBmdW4gW0BpbmxpbmVdIHggLT4gaW50MzJfcG9wY291bnQgKFN0ZGxpYi5OYXRpdmVpbnQudG9faW50MzIgeClcbiAgfCA2NCAtPiBmdW4gW0BpbmxpbmVdIHggLT4gaW50NjRfcG9wY291bnQgKFN0ZGxpYi5JbnQ2NC5vZl9uYXRpdmVpbnQgeClcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuOztcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTaWduMFxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoU2lnbjApXG5cbigqIE9wZW4gW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb25zIHNvXG4gICB0aGV5IGRvIG5vdCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnNcbiAgIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgdG9fc3RyaW5nX2h1bSA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IFwibmVnYXRpdmVcIlxuICB8IFplcm8gLT4gXCJ6ZXJvXCJcbiAgfCBQb3MgLT4gXCJwb3NpdGl2ZVwiXG47O1xuXG5sZXQgdG9fZmxvYXQgPSBmdW5jdGlvblxuICB8IE5lZyAtPiAtMS5cbiAgfCBaZXJvIC0+IDAuXG4gIHwgUG9zIC0+IDEuXG47O1xuXG5sZXQgZmxpcCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IFBvc1xuICB8IFplcm8gLT4gWmVyb1xuICB8IFBvcyAtPiBOZWdcbjs7XG5cbmxldCAoICogKSB0IHQnID0gb2ZfaW50ICh0b19pbnQgdCAqIHRvX2ludCB0JylcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYXQgdGhlIGVuZCwgYWZ0ZXIgYW55XG4gICBmdW5jdG9yIGFwcGxpY2F0aW9ucyB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzb1xuICAgdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieSB0aGlzXG4gICBtb2R1bGUuICopXG5pbmNsdWRlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEludF9pbnRmXG5pbmNsdWRlIEludDBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGdsb2JhbGl6ZSA6IHQgLT4gdCkgPSAoZ2xvYmFsaXplX2ludCA6IHQgLT4gdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChpbnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfaW50IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgeCB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlIHggeVxuXG4gIGxldCBvZl9zdHJpbmcgcyA9XG4gICAgdHJ5IG9mX3N0cmluZyBzIHdpdGhcbiAgICB8IF8gLT4gUHJpbnRmLmZhaWx3aXRoZiBcIkludC5vZl9zdHJpbmc6ICVTXCIgcyAoKVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbmVuZFxuXG5sZXQgbnVtX2JpdHMgPSBJbnRfY29udmVyc2lvbnMubnVtX2JpdHNfaW50XG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCB0b19mbG9hdCA9IFN0ZGxpYi5mbG9hdF9vZl9pbnRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBTdGRsaWIuaW50X29mX2Zsb2F0XG5cbmxldCBvZl9mbG9hdCBmID1cbiAgaWYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBmIGZsb2F0X2xvd2VyX2JvdW5kXG4gICAgICYmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgZiBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIFN0ZGxpYi5pbnRfb2ZfZmxvYXQgZlxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCBmKVxuICAgICAgKClcbjs7XG5cbmxldCB6ZXJvID0gMFxubGV0IG9uZSA9IDFcbmxldCBtaW51c19vbmUgPSAtMVxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgaW5jbHVkZSBUXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG5lbmQpXG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZSAoVClcblxuaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLk1ha2VfaGV4IChzdHJ1Y3RcbiAgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSAoY29tcGFyZV9pbnRfX2xvY2FsIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgbmVnID0gKCB+LSApXG4gIGxldCAoIDwgKSA9ICggPCApXG4gIGxldCB0b19zdHJpbmcgaSA9IFByaW50Zi5zcHJpbnRmIFwiJXhcIiBpXG4gIGxldCBvZl9zdHJpbmcgcyA9IFN0ZGxpYi5TY2FuZi5zc2NhbmYgcyBcIiV4XCIgRm4uaWRcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludC5IZXhcIlxuZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHRcblxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnRcIlxuZW5kKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzb1xuICAgdGhleSBkbyBub3Qgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zXG4gICBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluOm1pbl8gfm1heDptYXhfID0gbWluIHQgbWF4XyB8PiBtYXggbWluX1xuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxuZXh0ZXJuYWwgdG9faW50MzJfdHJ1bmMgOiAodFtAbG9jYWxfb3B0XSkgLT4gKGludDMyW0Bsb2NhbF9vcHRdKSA9IFwiJWludDMyX29mX2ludFwiXG5leHRlcm5hbCBvZl9pbnQzMl90cnVuYyA6IChpbnQzMltAbG9jYWxfb3B0XSkgLT4gdCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9pbnQ2NF90cnVuYyA6IChpbnQ2NFtAbG9jYWxfb3B0XSkgLT4gdCA9IFwiJWludDY0X3RvX2ludFwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnRfdHJ1bmMgOiAobmF0aXZlaW50W0Bsb2NhbF9vcHRdKSAtPiB0ID0gXCIlbmF0aXZlaW50X3RvX2ludFwiXG5cbmxldCBwcmVkIGkgPSBpIC0gMVxubGV0IHN1Y2MgaSA9IGkgKyAxXG5sZXQgdG9faW50IGkgPSBpXG5sZXQgdG9faW50X2V4biA9IHRvX2ludFxubGV0IG9mX2ludCBpID0gaVxubGV0IG9mX2ludF9leG4gPSBvZl9pbnRcbmxldCBtYXhfdmFsdWUgPSBTdGRsaWIubWF4X2ludFxubGV0IG1pbl92YWx1ZSA9IFN0ZGxpYi5taW5faW50XG5sZXQgbWF4X3ZhbHVlXzMwX2JpdHMgPSAweDNGRkZfRkZGRlxubGV0IG9mX2ludDMyID0gQ29udi5pbnQzMl90b19pbnRcbmxldCBvZl9pbnQzMl9leG4gPSBDb252LmludDMyX3RvX2ludF9leG5cbmxldCB0b19pbnQzMiA9IENvbnYuaW50X3RvX2ludDMyXG5sZXQgdG9faW50MzJfZXhuID0gQ29udi5pbnRfdG9faW50MzJfZXhuXG5sZXQgb2ZfaW50NjQgPSBDb252LmludDY0X3RvX2ludFxubGV0IG9mX2ludDY0X2V4biA9IENvbnYuaW50NjRfdG9faW50X2V4blxubGV0IHRvX2ludDY0ID0gQ29udi5pbnRfdG9faW50NjRcbmxldCBvZl9uYXRpdmVpbnQgPSBDb252Lm5hdGl2ZWludF90b19pbnRcbmxldCBvZl9uYXRpdmVpbnRfZXhuID0gQ29udi5uYXRpdmVpbnRfdG9faW50X2V4blxubGV0IHRvX25hdGl2ZWludCA9IENvbnYuaW50X3RvX25hdGl2ZWludFxubGV0IHRvX25hdGl2ZWludF9leG4gPSB0b19uYXRpdmVpbnRcbmxldCBhYnMgeCA9IGFicyB4XG5cbigqIG5vdGUgdGhhdCByZW0gaXMgbm90IHNhbWUgYXMgJSAqKVxubGV0IHJlbSBhIGIgPSBhIG1vZCBiXG5sZXQgaW5jciA9IFN0ZGxpYi5pbmNyXG5sZXQgZGVjciA9IFN0ZGxpYi5kZWNyXG5sZXQgc2hpZnRfcmlnaHQgYSBiID0gYSBhc3IgYlxubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgYSBiID0gYSBsc3IgYlxubGV0IHNoaWZ0X2xlZnQgYSBiID0gYSBsc2wgYlxubGV0IGJpdF9ub3QgYSA9IGxub3QgYVxubGV0IGJpdF9vciBhIGIgPSBhIGxvciBiXG5sZXQgYml0X2FuZCBhIGIgPSBhIGxhbmQgYlxubGV0IGJpdF94b3IgYSBiID0gYSBseG9yIGJcbmxldCBwb3cgPSBJbnRfbWF0aC5Qcml2YXRlLmludF9wb3dcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxuXG5tb2R1bGUgUG93MiA9IHN0cnVjdFxuICBvcGVuISBJbXBvcnRcblxuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICBsZXQgbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpID1cbiAgICBQcmludGYuaW52YWxpZF9hcmdmIFwiYXJndW1lbnQgbXVzdCBiZSBzdHJpY3RseSBwb3NpdGl2ZVwiICgpXG4gIDs7XG5cbiAgKCoqIFwiY2VpbGluZyBwb3dlciBvZiAyXCIgLSBMZWFzdCBwb3dlciBvZiAyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgY2VpbF9wb3cyIHggPVxuICAgIGlmIHggPD0gMCB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggLSAxIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICAoKiBUaGUgbmV4dCBsaW5lIGlzIHN1cGVyZmx1b3VzIG9uIDMyLWJpdCBhcmNoaXRlY3R1cmVzLCBidXQgaXQncyBmYXN0ZXIgdG8gZG8gaXRcbiAgICAgICBhbnl3YXkgdGhhbiB0byBicmFuY2ggKilcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICB4ICsgMVxuICA7O1xuXG4gICgqKiBcImZsb29yIHBvd2VyIG9mIDJcIiAtIExhcmdlc3QgcG93ZXIgb2YgMiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGZsb29yX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgKCogVGhlIG5leHQgbGluZSBpcyBzdXBlcmZsdW91cyBvbiAzMi1iaXQgYXJjaGl0ZWN0dXJlcywgYnV0IGl0J3MgZmFzdGVyIHRvIGRvIGl0XG4gICAgICAgYW55d2F5IHRoYW4gdG8gYnJhbmNoICopXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgeCAtICh4IGxzciAxKVxuICA7O1xuXG4gIGxldCBpc19wb3cyIHggPVxuICAgIGlmIHggPD0gMCB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgKHggLSAxKSA9IDBcbiAgOztcblxuICAoKiBDIHN0dWJzIGZvciBpbnQgY2x6IGFuZCBjdHogdG8gdXNlIHRoZSBDTFovQlNSL0NUWi9CU0YgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbiAgZXh0ZXJuYWwgY2x6XG4gICAgOiAgKCogTm90ZSB0aGF0IHdlIHBhc3MgdGhlIHRhZ2dlZCBpbnQgaGVyZS4gU2VlIGludF9tYXRoX3N0dWJzLmMgZm9yIGRldGFpbHMgb24gd2h5XG4gICAgICAgICAgdGhpcyBpcyBjb3JyZWN0LiAqKVxuICAgICAgIGludFxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnRfY2x6XCIgXCJCYXNlX2ludF9tYXRoX2ludF9jbHpfdW50YWdnZWRcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKGludFtAdW50YWdnZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnRfY3R6XCIgXCJCYXNlX2ludF9tYXRoX2ludF9jdHpfdW50YWdnZWRcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBpIDw9IDBcbiAgICB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50IGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICBsZXQgY2VpbF9sb2cyIGkgPVxuICAgIGlmIGkgPD0gMFxuICAgIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludC5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludCBpIF0pO1xuICAgIGlmIGkgPSAxIHRoZW4gMCBlbHNlIG51bV9iaXRzIC0gY2x6IChpIC0gMSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFBvdzJcblxubGV0IHNpZ24gPSBTaWduLm9mX2ludFxubGV0IHBvcGNvdW50ID0gUG9wY291bnQuaW50X3BvcGNvdW50XG5cbmluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9ucy5NYWtlX2JpbmFyeSAoc3RydWN0XG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgaGFzaF1cblxuICBsZXQgY29tcGFyZV9fbG9jYWwgPSAoY29tcGFyZV9pbnRfX2xvY2FsIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgZXF1YWxfX2xvY2FsID0gKGVxdWFsX2ludF9fbG9jYWwgOiB0IC0+IHQgLT4gYm9vbClcbiAgbGV0IGVxdWFsID0gKGZ1biBhIGIgLT4gZXF1YWxfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCAoIGxhbmQgKSA9ICggbGFuZCApXG4gIGxldCAoIGxzciApID0gKCBsc3IgKVxuICBsZXQgY2x6ID0gY2x6XG4gIGxldCBudW1fYml0cyA9IG51bV9iaXRzXG4gIGxldCBvbmUgPSBvbmVcbiAgbGV0IHRvX2ludF9leG4gPSB0b19pbnRfZXhuXG4gIGxldCB6ZXJvID0gemVyb1xuZW5kKVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgKCArICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVhZGRpbnRcIlxuICBleHRlcm5hbCAoIC0gKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgLT4gdCA9IFwiJXN1YmludFwiXG4gIGV4dGVybmFsICggKiApIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSAtPiB0ID0gXCIlbXVsaW50XCJcbiAgZXh0ZXJuYWwgKCAvICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+IHQgPSBcIiVkaXZpbnRcIlxuICBleHRlcm5hbCAoIH4tICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gdCA9IFwiJW5lZ2ludFwiXG5cbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCBhYnMgPSBhYnNcblxuICBleHRlcm5hbCBuZWcgOiAodFtAbG9jYWxfb3B0XSkgLT4gdCA9IFwiJW5lZ2ludFwiXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBtb2R1bGUgRiA9IEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBpbmNsdWRlIFByZV9PXG5cbiAgICBsZXQgcmVtID0gcmVtXG4gICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICBlbmQpXG5cbiAgaW5jbHVkZSBGXG5cbiAgZXh0ZXJuYWwgYnN3YXAxNiA6IChpbnRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWJzd2FwMTZcIlxuXG4gICgqIFRoZXNlIGlubGluZWQgdmVyc2lvbnMgb2YgKCUpLCAoLyUpLCBhbmQgKC8vKSBwZXJmb3JtIGJldHRlciB0aGFuIHRoZWlyIGZ1bmN0b3JpemVkXG4gICAgIGNvdW50ZXJwYXJ0cyBpbiBbRl0gKHNlZSBiZW5jaG1hcmtzIGJlbG93KS5cblxuICAgICBUaGUgcmVhc29uIHRoZXNlIGZ1bmN0aW9ucyBhcmUgaW5saW5lZCBpbiBbSW50XSBidXQgbm90IGluIGFueSBvZiB0aGUgb3RoZXIgaW50ZWdlclxuICAgICBtb2R1bGVzIGlzIHRoYXQgdGhleSBleGlzdGVkIGluIFtJbnRdIGFuZCBbSW50XSBhbG9uZSBwcmlvciB0byB0aGUgaW50cm9kdWN0aW9uIG9mXG4gICAgIHRoZSBbSW50X21hdGguTWFrZV0gZnVuY3RvciwgYW5kIHdlIGRpZG4ndCB3YW50IHRvIGRlZ3JhZGUgdGhlaXIgcGVyZm9ybWFuY2UuXG5cbiAgICAgV2Ugd29uJ3QgcHJlLWVtcHRpdmVseSBkbyB0aGUgc2FtZSBmb3IgbmV3IGZ1bmN0aW9ucywgdW5sZXNzIHNvbWVvbmUgY2FyZXMsIG9uIGEgY2FzZVxuICAgICBieSBjYXNlIGZhc2hpb24uICAqKVxuXG4gIGxldCAoICUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCIlcyAlJSAlcyBpbiBjb3JlX2ludC5tbDogbW9kdWx1cyBzaG91bGQgYmUgcG9zaXRpdmVcIlxuICAgICAgICAodG9fc3RyaW5nIHgpXG4gICAgICAgICh0b19zdHJpbmcgeSlcbiAgICAgICAgKCk7XG4gICAgbGV0IHJ2YWwgPSByZW0geCB5IGluXG4gICAgaWYgcnZhbCA8IHplcm8gdGhlbiBydmFsICsgeSBlbHNlIHJ2YWxcbiAgOztcblxuICBsZXQgKCAvJSApIHggeSA9XG4gICAgaWYgeSA8PSB6ZXJvXG4gICAgdGhlblxuICAgICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgICBcIiVzIC8lJSAlcyBpbiBjb3JlX2ludC5tbDogZGl2aXNvciBzaG91bGQgYmUgcG9zaXRpdmVcIlxuICAgICAgICAodG9fc3RyaW5nIHgpXG4gICAgICAgICh0b19zdHJpbmcgeSlcbiAgICAgICAgKCk7XG4gICAgaWYgeCA8IHplcm8gdGhlbiAoKHggKyBvbmUpIC8geSkgLSBvbmUgZWxzZSB4IC8geVxuICA7O1xuXG4gIGxldCAoIC8vICkgeCB5ID0gdG9fZmxvYXQgeCAvLiB0b19mbG9hdCB5XG5cbiAgZXh0ZXJuYWwgKCBsYW5kICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuICBleHRlcm5hbCAoIGxvciApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlb3JpbnRcIlxuICBleHRlcm5hbCAoIGx4b3IgKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJXhvcmludFwiXG5cbiAgbGV0IGxub3QgPSBsbm90XG5cbiAgZXh0ZXJuYWwgKCBsc2wgKSA6IChpbnRbQGxvY2FsX29wdF0pIC0+IChpbnRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWxzbGludFwiXG4gIGV4dGVybmFsICggbHNyICkgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuICBleHRlcm5hbCAoIGFzciApIDogKGludFtAbG9jYWxfb3B0XSkgLT4gKGludFtAbG9jYWxfb3B0XSkgLT4gaW50ID0gXCIlYXNyaW50XCJcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW0ludF0gYW5kIFtJbnQuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgT19GID0gTy5GXG5lbmRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yXG4gICBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9uc1xuICAgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieSB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9IFN0ZGxpYi5PYmoudFxudHlwZSByYXdfZGF0YSA9IFN0ZGxpYi5PYmoucmF3X2RhdGFcblxuZXh0ZXJuYWwgbWFnaWMgOiAoX1tAbG9jYWxfb3B0XSkgLT4gKF9bQGxvY2FsX29wdF0pID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgcmVwciA6IChfW0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBvYmogOiAodFtAbG9jYWxfb3B0XSkgLT4gKF9bQGxvY2FsX29wdF0pID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgc2l6ZSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiBpbnQgPSBcIiVvYmpfc2l6ZVwiXG5cbmxldFtAaW5saW5lIGFsd2F5c10gc2l6ZSB0ID0gc2l6ZSAoU3lzLm9wYXF1ZV9pZGVudGl0eSB0KVxuXG5leHRlcm5hbCBpc19pbnQgOiAodFtAbG9jYWxfb3B0XSkgLT4gYm9vbCA9IFwiJW9ial9pc19pbnRcIlxuXG4oKiBUaGUgcmVzdWx0IGRvZXNuJ3QgbmVlZCB0byBiZSBtYXJrZWQgbG9jYWwgYmVjYXVzZSB0aGUgZGF0YSBpcyBjb3BpZWQgaW50byBhIGZyZXNoXG4gICBuYXRpdmVpbnQgYmxvY2sgcmVnYXJkbGVzcy4gKilcbmV4dGVybmFsIHJhd19maWVsZCA6ICh0W0Bsb2NhbF9vcHRdKSAtPiBpbnQgLT4gcmF3X2RhdGEgPSBcImNhbWxfb2JqX3Jhd19maWVsZFwiXG5cbmV4dGVybmFsIHNldF9yYXdfZmllbGRcbiAgOiAgKHRbQGxvY2FsX29wdF0pXG4gIC0+IGludFxuICAtPiByYXdfZGF0YVxuICAtPiB1bml0XG4gID0gXCJjYW1sX29ial9zZXRfcmF3X2ZpZWxkXCJcblxuZXh0ZXJuYWwgdGFnIDogKHRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiY2FtbF9vYmpfdGFnXCIgW0BAbm9hbGxvY11cblxuKCogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBvbiB0aGUgbG9jYWwgc3RhY2suIFJldHVybnMgW2ZhbHNlXSBmb3IgaW1tZWRpYXRlcy4gKilcbmV4dGVybmFsIGlzX3N0YWNrIDogKHRbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcImNhbWxfZHVtbXlfb2JqX2lzX3N0YWNrXCJcblxudHlwZSBzdGFja19vcl9oZWFwID1cbiAgfCBJbW1lZGlhdGVcbiAgfCBTdGFja1xuICB8IEhlYXBcbltAQGRlcml2aW5nX2lubGluZSBzZXhwLCBjb21wYXJlXVxuXG5sZXQgc3RhY2tfb3JfaGVhcF9vZl9zZXhwID1cbiAgKGxldCBlcnJvcl9zb3VyY2VfXzAwM18gPSBcIm9ial9sb2NhbC5tbC5zdGFja19vcl9oZWFwXCIgaW5cbiAgIGZ1bmN0aW9uXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbW1lZGlhdGVcIiB8IFwiSW1tZWRpYXRlXCIpIC0+IEltbWVkaWF0ZVxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwic3RhY2tcIiB8IFwiU3RhY2tcIikgLT4gU3RhY2tcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImhlYXBcIiB8IFwiSGVhcFwiKSAtPiBIZWFwXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImltbWVkaWF0ZVwiIHwgXCJJbW1lZGlhdGVcIikgOjogXykgYXNcbiAgICAgc2V4cF9fMDA0XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInN0YWNrXCIgfCBcIlN0YWNrXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJoZWFwXCIgfCBcIkhlYXBcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDAyXyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgIHwgc2V4cF9fMDAyXyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gc3RhY2tfb3JfaGVhcClcbjs7XG5cbmxldCBzZXhwX29mX3N0YWNrX29yX2hlYXAgPVxuICAoZnVuY3Rpb25cbiAgIHwgSW1tZWRpYXRlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkltbWVkaWF0ZVwiXG4gICB8IFN0YWNrIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlN0YWNrXCJcbiAgIHwgSGVhcCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJIZWFwXCJcbiAgICA6IHN0YWNrX29yX2hlYXAgLT4gU2V4cGxpYjAuU2V4cC50KVxuOztcblxubGV0IGNvbXBhcmVfc3RhY2tfb3JfaGVhcCA9IChTdGRsaWIuY29tcGFyZSA6IHN0YWNrX29yX2hlYXAgLT4gc3RhY2tfb3JfaGVhcCAtPiBpbnQpXG5cbltAQEBlbmRdXG5cbmxldCBzdGFja19vcl9oZWFwIHJlcHIgPVxuICBpZiBpc19pbnQgcmVwclxuICB0aGVuIEltbWVkaWF0ZVxuICBlbHNlIChcbiAgICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgICB8IFN5cy5OYXRpdmUgLT4gaWYgaXNfc3RhY2sgcmVwciB0aGVuIFN0YWNrIGVsc2UgSGVhcFxuICAgIHwgU3lzLkJ5dGVjb2RlIC0+IEhlYXBcbiAgICB8IFN5cy5PdGhlciBfIC0+IEhlYXApXG47O1xuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuXG4oKiBXZSBtYWludGFpbiB0aGUgcHJvcGVydHkgdGhhdCBhbGwgdmFsdWVzIG9mIHR5cGUgW3RdIGRvIG5vdCBoYXZlIHRoZSB0YWdcbiAgIFtkb3VibGVfYXJyYXlfdGFnXS4gIFNvbWUgZnVuY3Rpb25zIGJlbG93IGFzc3VtZSB0aGlzIGluIG9yZGVyIHRvIGF2b2lkIHRlc3RpbmcgdGhlXG4gICB0YWcsIGFuZCB3aWxsIHNlZ2ZhdWx0IGlmIHRoaXMgcHJvcGVydHkgZG9lc24ndCBob2xkLiAqKVxudHlwZSB0ID0gU3RkbGliLk9iai50IGFycmF5XG5cbmxldCBpbnZhcmlhbnQgdCA9XG4gIGFzc2VydCAoU3RkbGliLk9iai50YWcgKFN0ZGxpYi5PYmoucmVwciB0KSA8PiBTdGRsaWIuT2JqLmRvdWJsZV9hcnJheV90YWcpXG47O1xuXG5sZXQgbGVuZ3RoID0gQXJyYXkubGVuZ3RoICgqIHdvdWxkIGNoZWNrIGZvciBmbG9hdCBhcnJheXMgaW4gMzIgYml0LCBidXQgd2hhdGV2ZXIgKilcblxubGV0IHNleHBfb2ZfdCB0ID1cbiAgU2V4cC5BdG9tXG4gICAgKFN0cmluZy5jb25jYXQgfnNlcDpcIlwiIFsgXCI8T2JqX2FycmF5LnQgb2YgbGVuZ3RoIFwiOyBJbnQudG9fc3RyaW5nIChsZW5ndGggdCk7IFwiPlwiIF0pXG47O1xuXG5sZXQgemVyb19vYmogPSBTdGRsaWIuT2JqLnJlcHIgKDAgOiBpbnQpXG5cbigqIFdlIGNhbGwgW0FycmF5LmNyZWF0ZV0gd2l0aCBhIHZhbHVlIHRoYXQgaXMgbm90IGEgZmxvYXQgc28gdGhhdCB0aGUgYXJyYXkgZG9lc24ndCBnZXRcbiAgIHRhZ2dlZCB3aXRoIFtEb3VibGVfYXJyYXlfdGFnXS4gKilcbmxldCBjcmVhdGVfemVybyB+bGVuID0gQXJyYXkuY3JlYXRlIH5sZW4gemVyb19vYmpcbmxldCBlbXB0eSA9IFt8fF1cblxudHlwZSBub3RfYV9mbG9hdCA9XG4gIHwgTm90X2FfZmxvYXRfMFxuICB8IE5vdF9hX2Zsb2F0XzEgb2YgaW50XG5cbmxldCBfbm90X2FfZmxvYXRfMCA9IE5vdF9hX2Zsb2F0XzBcbmxldCBfbm90X2FfZmxvYXRfMSA9IE5vdF9hX2Zsb2F0XzEgNDJcblxubGV0IGdldCB0IGkgPVxuICAoKiBNYWtlIHRoZSBjb21waWxlciBiZWxpZXZlIFt0XSBpcyBhbiBhcnJheSBub3QgY29udGFpbmluZyBmbG9hdHMgc28gaXQgZG9lcyBub3QgY2hlY2tcbiAgICAgaWYgW3RdIGlzIHRhZ2dlZCB3aXRoIFtEb3VibGVfYXJyYXlfdGFnXS4gIEl0IGlzIE5PVCBvayB0byB1c2UgW2ludCBhcnJheV0gc2luY2UgKGlmXG4gICAgIHRoaXMgZnVuY3Rpb24gaXMgaW5saW5lZCBhbmQgdGhlIGFycmF5IGNvbnRhaW5zIGluLWhlYXAgYm94ZWQgdmFsdWVzKSB3cm9uZyByZWdpc3RlclxuICAgICB0eXBpbmcgbWF5IHJlc3VsdCwgbGVhZGluZyB0byBhIGZhaWx1cmUgdG8gcmVnaXN0ZXIgbmVjZXNzYXJ5IEdDIHJvb3RzLiAqKVxuICBTdGRsaWIuT2JqLnJlcHJcbiAgICAoKiBbU3lzLm9wYXF1ZV9pZGVudGl0eV0gaXMgcmVxdWlyZWQgb24gdGhlIGFycmF5IGJlY2F1c2UgdGhpcyBjb2RlIGJyZWFrcyB0aGUgdXN1YWxcbiAgICAgICBhc3N1bXB0aW9ucyBhYm91dCBhcnJheSBraW5kcyB0aGF0IHRoZSBGbGFtYmRhIDIgb3B0aW1pc2VyIGNhbiBzZWUuICopXG4gICAgKChTeXMub3BhcXVlX2lkZW50aXR5IChTdGRsaWIuT2JqLm1hZ2ljICh0IDogdCkgOiBub3RfYV9mbG9hdCBhcnJheSkpLihpKVxuICAgICAgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX2dldCB0IGkgPVxuICAoKiBNYWtlIHRoZSBjb21waWxlciBiZWxpZXZlIFt0XSBpcyBhbiBhcnJheSBub3QgY29udGFpbmluZyBmbG9hdHMgc28gaXQgZG9lcyBub3QgY2hlY2tcbiAgICAgaWYgW3RdIGlzIHRhZ2dlZCB3aXRoIFtEb3VibGVfYXJyYXlfdGFnXS4gKilcbiAgU3RkbGliLk9iai5yZXByXG4gICAgKEFycmF5LnVuc2FmZV9nZXRcbiAgICAgICAoU3lzLm9wYXF1ZV9pZGVudGl0eSAoT2JqX2xvY2FsLm1hZ2ljICh0IDogdCkgOiBub3RfYV9mbG9hdCBhcnJheSkpXG4gICAgICAgaVxuICAgICAgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmogPVxuICAoKiBTYW1lIGNvbW1lbnQgYXMgW3Vuc2FmZV9nZXRdLiBTeXMub3BhcXVlX2lkZW50aXR5IHByZXZlbnRzIHRoZSBjb21waWxlciBmcm9tXG4gICAgIHBvdGVudGlhbGx5IHdyb25nbHkgZ3Vlc3NpbmcgdGhlIHR5cGUgb2YgdGhlIGFycmF5IGJhc2VkIG9uIHRoZSB0eXBlIG9mIGVsZW1lbnQsIHRoYXRcbiAgICAgaXMgcHJldmVudCB0aGUgaW1wbGljYXRpb246IChPYmoudGFnIG9iaiA9IE9iai5kb3VibGVfdGFnKSA9PiAoT2JqLnRhZyB0ID1cbiAgICAgT2JqLmRvdWJsZV9hcnJheV90YWcpIHdoaWNoIGZsYW1iZGEgaGFzIHRyaWVkIGluIHRoZSBwYXN0IChhdCBsZWFzdCB0aGF0J3MgYXNzdW1pbmdcbiAgICAgdGhlIGNvbXBpbGVyIHJlc3BlY3RzIFN5cy5vcGFxdWVfaWRlbnRpdHksIHdoaWNoIGlzIG5vdCBhbHdheXMgdGhlIGNhc2UpLiAqKVxuICBBcnJheS51bnNhZmVfc2V0XG4gICAgKFN5cy5vcGFxdWVfaWRlbnRpdHkgKE9ial9sb2NhbC5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpKVxuICAgIGlcbiAgICAoU3RkbGliLk9iai5vYmogKFN5cy5vcGFxdWVfaWRlbnRpdHkgb2JqKSA6IG5vdF9hX2Zsb2F0KVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBzZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqID1cbiAgKCogc2FtZSBhcyB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgYnV0IHNhZmUgKilcbiAgKFN5cy5vcGFxdWVfaWRlbnRpdHkgKFN0ZGxpYi5PYmoubWFnaWMgKHQgOiB0KSA6IG5vdF9hX2Zsb2F0IGFycmF5KSkuKGkpXG4gICAgPC0gKFN0ZGxpYi5PYmoub2JqIChTeXMub3BhcXVlX2lkZW50aXR5IG9iaikgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgaW50ID1cbiAgKCogVGhpcyBza2lwcyBbY2FtbF9tb2RpZnldLCB3aGljaCBpcyBPSyBpZiBib3RoIHRoZSBvbGQgYW5kIG5ldyB2YWx1ZXMgYXJlIGludGVnZXJzLiAqKVxuICBBcnJheS51bnNhZmVfc2V0XG4gICAgKFN5cy5vcGFxdWVfaWRlbnRpdHkgKE9ial9sb2NhbC5tYWdpYyAodCA6IHQpIDogaW50IGFycmF5KSlcbiAgICBpXG4gICAgKFN5cy5vcGFxdWVfaWRlbnRpdHkgaW50KVxuOztcblxuKCogRm9yIFtzZXRdIGFuZCBbdW5zYWZlX3NldF0sIGlmIGEgcG9pbnRlciBpcyBpbnZvbHZlZCwgd2UgZmlyc3QgZG8gYSBwaHlzaWNhbC1lcXVhbGl0eVxuICAgdGVzdCB0byBzZWUgaWYgdGhlIHBvaW50ZXIgaXMgY2hhbmdpbmcuICBJZiBub3QsIHdlIGRvbid0IG5lZWQgdG8gZG8gdGhlIFtzZXRdLCB3aGljaFxuICAgc2F2ZXMgYSBjYWxsIHRvIFtjYW1sX21vZGlmeV0uICBXZSB0aGluayB0aGlzIHBoeXNpY2FsLWVxdWFsaXR5IHRlc3QgaXMgd29ydGggaXRcbiAgIGJlY2F1c2UgaXQgaXMgdmVyeSBjaGVhcCAoYm90aCB2YWx1ZXMgYXJlIGFscmVhZHkgYXZhaWxhYmxlIGZyb20gdGhlIFtpc19pbnRdIHRlc3QpXG4gICBhbmQgYmVjYXVzZSBbY2FtbF9tb2RpZnldIGlzIGV4cGVuc2l2ZS4gKilcblxubGV0IHNldCB0IGkgb2JqID1cbiAgKCogV2UgdXNlIFtnZXRdIGZpcnN0IGJ1dCB0aGVuIHdlIHVzZSBbQXJyYXkudW5zYWZlX3NldF0gc2luY2Ugd2Uga25vdyB0aGF0IFtpXSBpc1xuICAgICB2YWxpZC4gKilcbiAgbGV0IG9sZF9vYmogPSBnZXQgdCBpIGluXG4gIGlmIFN0ZGxpYi5PYmouaXNfaW50IG9sZF9vYmogJiYgU3RkbGliLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKFN0ZGxpYi5PYmoub2JqIG9iaiA6IGludClcbiAgZWxzZSBpZiBub3QgKHBoeXNfZXF1YWwgb2xkX29iaiBvYmopXG4gIHRoZW4gdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldCB0IGkgb2JqID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBTdGRsaWIuT2JqLmlzX2ludCBvbGRfb2JqICYmIFN0ZGxpYi5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChTdGRsaWIuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2UgaWYgbm90IChwaHlzX2VxdWFsIG9sZF9vYmogb2JqKVxuICB0aGVuIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZWNrIHQgaSBvYmogPVxuICBsZXQgb2xkX29iaiA9IHVuc2FmZV9nZXQgdCBpIGluXG4gIGlmIFN0ZGxpYi5PYmouaXNfaW50IG9sZF9vYmogJiYgU3RkbGliLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKFN0ZGxpYi5PYmoub2JqIG9iaiA6IGludClcbiAgZWxzZSB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0IHN3YXAgdCBpIGogPVxuICBsZXQgYSA9IGdldCB0IGkgaW5cbiAgbGV0IGIgPSBnZXQgdCBqIGluXG4gIHVuc2FmZV9zZXQgdCBpIGI7XG4gIHVuc2FmZV9zZXQgdCBqIGFcbjs7XG5cbmxldCBjcmVhdGUgfmxlbiB4ID1cbiAgKCogSWYgd2UgY2FuLCB1c2UgW0FycmF5LmNyZWF0ZV0gZGlyZWN0bHkuIEV2ZW4gdGhvdWdoIFtpc19pbnRdIGNoZWNrIGlzIHN1YnN1bWVkIGJ5XG4gICAgIHRoZSB0YWcgY2hlY2ssIGNoZWNraW5nIGl0IGlzIG11Y2ggZmFzdGVyLCBzaW5jZSBpdCBhdm9pZHMgYSBDIGZ1bmN0aW9uIGNhbGwuICAqKVxuICBpZiBTdGRsaWIuT2JqLmlzX2ludCB4IHx8IFN0ZGxpYi5PYmoudGFnIHggPD4gU3RkbGliLk9iai5kb3VibGVfdGFnXG4gIHRoZW4gQXJyYXkuY3JlYXRlIH5sZW4geFxuICBlbHNlIChcbiAgICAoKiBPdGhlcndpc2UgdXNlIFtjcmVhdGVfemVyb10gYW5kIHNldCB0aGUgY29udGVudHMgKilcbiAgICBsZXQgdCA9IGNyZWF0ZV96ZXJvIH5sZW4gaW5cbiAgICBsZXQgeCA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIHhcbiAgICBkb25lO1xuICAgIHQpXG47O1xuXG5sZXQgc2luZ2xldG9uIG9iaiA9IGNyZWF0ZSB+bGVuOjEgb2JqXG5cbigqIFByZS1jb25kaXRpb246IHQuKGkpIGlzIGFuIGludGVnZXIuICopXG5sZXQgdW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSBvYmogPVxuICBpZiBTdGRsaWIuT2JqLmlzX2ludCBvYmpcbiAgdGhlbiB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSAoU3RkbGliLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlXG4gICAgKCogW3QuKGkpXSBpcyBhbiBpbnRlZ2VyIGFuZCBbb2JqXSBpcyBub3QsIHNvIHdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIGlmIHRoZXkgYXJlXG4gICAgICAgZXF1YWwuICopXG4gICAgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldCB1bnNhZmVfc2V0X2ludCB0IGkgaW50ID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBTdGRsaWIuT2JqLmlzX2ludCBvbGRfb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgaW50XG4gIGVsc2UgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoU3RkbGliLk9iai5yZXByIGludClcbjs7XG5cbmxldCB1bnNhZmVfY2xlYXJfaWZfcG9pbnRlciB0IGkgPVxuICBsZXQgb2xkX29iaiA9IHVuc2FmZV9nZXQgdCBpIGluXG4gIGlmIG5vdCAoU3RkbGliLk9iai5pc19pbnQgb2xkX29iailcbiAgdGhlbiB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChTdGRsaWIuT2JqLnJlcHIgMClcbjs7XG5cbigqKiBbdW5zYWZlX2JsaXRdIGlzIGxpa2UgW0FycmF5LmJsaXRdLCBleGNlcHQgaXQgdXNlcyBvdXIgb3duIGZvci1sb29wIHRvIGF2b2lkXG4gICAgY2FtbF9tb2RpZnkgd2hlbiBwb3NzaWJsZS4gIEl0cyBwZXJmb3JtYW5jZSBpcyBzdGlsbCBub3QgY29tcGFyYWJsZSB0byBhIG1lbWNweS4gKilcbmxldCB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gICgqIFdoZW4gW3BoeXNfZXF1YWwgc3JjIGRzdF0sIHdlIG5lZWQgdG8gY2hlY2sgd2hldGhlciBbZHN0X3BvcyA8IHNyY19wb3NdIGFuZCBoYXZlIHRoZVxuICAgICBmb3IgbG9vcCBnbyBpbiB0aGUgcmlnaHQgZGlyZWN0aW9uIHNvIHRoYXQgd2UgZG9uJ3Qgb3ZlcndyaXRlIGRhdGEgdGhhdCB3ZSBzdGlsbCBuZWVkXG4gICAgIHRvIHJlYWQuICBXaGVuIFtub3QgKHBoeXNfZXF1YWwgc3JjIGRzdCldLCBkb2luZyB0aGlzIGlzIGhhcm1sZXNzLiAgRnJvbSBhXG4gICAgIG1lbW9yeS1wZXJmb3JtYW5jZSBwZXJzcGVjdGl2ZSwgaXQgZG9lc24ndCBtYXR0ZXIgd2hldGhlciBvbmUgbG9vcHMgdXAgb3IgZG93bi5cbiAgICAgQ29uc3RhbnQtc3RyaWRlIGFjY2VzcywgZm9yd2FyZCBvciBiYWNrd2FyZCwgc2hvdWxkIGJlIGluZGlzdGluZ3Vpc2hhYmxlIChhdCBsZWFzdCBvblxuICAgICBhbiBpbnRlbCBpNykuICBTbywgd2UgZG9uJ3QgZG8gYSBjaGVjayBmb3IgW3BoeXNfZXF1YWwgc3JjIGRzdF0gYW5kIGFsd2F5cyBsb29wIHVwIGluXG4gICAgIHRoYXQgY2FzZS4gKilcbiAgaWYgZHN0X3BvcyA8IHNyY19wb3NcbiAgdGhlblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IGRzdCAoZHN0X3BvcyArIGkpICh1bnNhZmVfZ2V0IHNyYyAoc3JjX3BvcyArIGkpKVxuICAgIGRvbmVcbiAgZWxzZVxuICAgIGZvciBpID0gbGVuIC0gMSBkb3dudG8gMCBkb1xuICAgICAgdW5zYWZlX3NldCBkc3QgKGRzdF9wb3MgKyBpKSAodW5zYWZlX2dldCBzcmMgKHNyY19wb3MgKyBpKSlcbiAgICBkb25lXG47O1xuXG5pbmNsdWRlIEJsaXQuTWFrZSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IGNyZWF0ZSA9IGNyZWF0ZV96ZXJvXG4gIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbmVuZClcblxubGV0IGNvcHkgc3JjID1cbiAgbGV0IGRzdCA9IGNyZWF0ZV96ZXJvIH5sZW46KGxlbmd0aCBzcmMpIGluXG4gIGJsaXRvIH5zcmMgfmRzdCAoKTtcbiAgZHN0XG47O1xuXG5sZXQgc3ViID0gQXJyYXkuc3ViXG4iLCJvcGVuISBJbXBvcnRcblxuKCogV0FSTklORzpcbiAgIFdlIHVzZSBub24tbWVtb3J5LXNhZmUgdGhpbmdzIHRocm91Z2hvdXQgdGhlIFtUcnVzdGVkXSBtb2R1bGUuXG4gICBNb3N0IG9mIGl0IGlzIG9ubHkgc2FmZSBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSB0eXBlIHNpZ25hdHVyZSAoZS5nLiBleHBvc2luZ1xuICAgW3ZhbCBjb3B5IDogJ2EgdCAtPiAnYiB0XSB3b3VsZCBiZSBhIGJpZyBtaXN0YWtlKS4gKilcbm1vZHVsZSBUcnVzdGVkIDogc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBlbXB0eSA6ICdhIHRcbiAgdmFsIHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCA6IGxlbjppbnQgLT4gJ2EgdFxuICB2YWwgY3JlYXRlX29ial9hcnJheSA6IGxlbjppbnQgLT4gJ2EgdFxuICB2YWwgY3JlYXRlIDogbGVuOmludCAtPiAnYSAtPiAnYSB0XG4gIHZhbCBzaW5nbGV0b24gOiAnYSAtPiAnYSB0XG4gIHZhbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYVxuICB2YWwgc2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgc3dhcCA6IF8gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9nZXQgOiAnYSB0IC0+IGludCAtPiAnYVxuICB2YWwgdW5zYWZlX2dldF9sb2NhbCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gIHZhbCB1bnNhZmVfc2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlY2sgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X2ludCA6ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IDogJ2EgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5X2ludCA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHVuc2FmZV90b19hcnJheV9pbnBsYWNlX19wcm9taXNlX25vdF9hX2Zsb2F0IDogJ2EgdCAtPiAnYSBhcnJheVxuICB2YWwgc2V0X3dpdGhfY2FtbF9tb2RpZnkgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICB2YWwgdW5zYWZlX2JsaXQgOiAoJ2EgdCwgJ2EgdCkgQmxpdC5ibGl0XG4gIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gIHZhbCB1bnNhZmVfY2xlYXJfaWZfcG9pbnRlciA6IF8gdCAtPiBpbnQgLT4gdW5pdFxuICB2YWwgc3ViIDogJ2EgdCAtPiBwb3M6aW50IC0+IGxlbjppbnQgLT4gJ2EgdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9IE9ial9hcnJheS50XG5cbiAgbGV0IGVtcHR5ID0gT2JqX2FycmF5LmVtcHR5XG4gIGxldCB1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgfmxlbiA9IE9ial9hcnJheS5jcmVhdGVfemVybyB+bGVuXG4gIGxldCBjcmVhdGVfb2JqX2FycmF5IH5sZW4gPSBPYmpfYXJyYXkuY3JlYXRlX3plcm8gfmxlblxuICBsZXQgY3JlYXRlIH5sZW4geCA9IE9ial9hcnJheS5jcmVhdGUgfmxlbiAoU3RkbGliLk9iai5yZXByIHgpXG4gIGxldCBzaW5nbGV0b24geCA9IE9ial9hcnJheS5zaW5nbGV0b24gKFN0ZGxpYi5PYmoucmVwciB4KVxuICBsZXQgc3dhcCB0IGkgaiA9IE9ial9hcnJheS5zd2FwIHQgaSBqXG4gIGxldCBnZXQgYXJyIGkgPSBTdGRsaWIuT2JqLm9iaiAoT2JqX2FycmF5LmdldCBhcnIgaSlcbiAgbGV0IHNldCBhcnIgaSB4ID0gT2JqX2FycmF5LnNldCBhcnIgaSAoU3RkbGliLk9iai5yZXByIHgpXG4gIGxldCB1bnNhZmVfZ2V0X2xvY2FsIGFyciBpID0gU3RkbGliLk9iai5vYmogKE9ial9hcnJheS51bnNhZmVfZ2V0IGFyciBpKVxuICBsZXQgdW5zYWZlX2dldCBhcnIgaSA9IHVuc2FmZV9nZXRfbG9jYWwgYXJyIGlcbiAgbGV0IHVuc2FmZV9zZXQgYXJyIGkgeCA9IE9ial9hcnJheS51bnNhZmVfc2V0IGFyciBpIChTdGRsaWIuT2JqLnJlcHIgeClcbiAgbGV0IHVuc2FmZV9zZXRfaW50IGFyciBpIHggPSBPYmpfYXJyYXkudW5zYWZlX3NldF9pbnQgYXJyIGkgeFxuXG4gIGxldCB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIHhcbiAgOztcblxuICBsZXQgdW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgYXJyIGkgKFN0ZGxpYi5PYmoucmVwciB4KVxuICA7O1xuXG4gICgqIFt0XSBpcyBqdXN0IGFuIGFycmF5IHVuZGVyIHRoZSBob29kLCBpdCBqdXN0IGhhcyBzcGVjaWFsIGNvbnNpZGVyYXRpb25zIGFib3V0IFt0XSBub3RcbiAgICAgYmVpbmcgYSBmbG9hdC4gKilcbiAgbGV0IHVuc2FmZV90b19hcnJheV9pbnBsYWNlX19wcm9taXNlX25vdF9hX2Zsb2F0IGFyciA9IFN0ZGxpYi5PYmoubWFnaWMgYXJyXG4gIGxldCBsZW5ndGggPSBPYmpfYXJyYXkubGVuZ3RoXG4gIGxldCB1bnNhZmVfYmxpdCA9IE9ial9hcnJheS51bnNhZmVfYmxpdFxuICBsZXQgY29weSA9IE9ial9hcnJheS5jb3B5XG5cbiAgbGV0IHVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZWNrIHQgaSB4ID1cbiAgICBPYmpfYXJyYXkudW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlY2sgdCBpIChTdGRsaWIuT2JqLnJlcHIgeClcbiAgOztcblxuICBsZXQgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSB4ID1cbiAgICBPYmpfYXJyYXkudW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoU3RkbGliLk9iai5yZXByIHgpXG4gIDs7XG5cbiAgbGV0IHNldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSB4ID0gT2JqX2FycmF5LnNldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoU3RkbGliLk9iai5yZXByIHgpXG4gIGxldCB1bnNhZmVfY2xlYXJfaWZfcG9pbnRlciA9IE9ial9hcnJheS51bnNhZmVfY2xlYXJfaWZfcG9pbnRlclxuICBsZXQgc3ViID0gT2JqX2FycmF5LnN1YlxuZW5kXG5cbmluY2x1ZGUgVHJ1c3RlZFxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBhc3NlcnQgKFN0ZGxpYi5PYmoudGFnIChTdGRsaWIuT2JqLnJlcHIgdCkgPD4gU3RkbGliLk9iai5kb3VibGVfYXJyYXlfdGFnKVxuOztcblxubGV0IGluaXQgbCB+ZiA9XG4gIGlmIGwgPCAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJVbmlmb3JtX2FycmF5LmluaXRcIlxuICBlbHNlIChcbiAgICBsZXQgcmVzID0gdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW46bCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgIGRvbmU7XG4gICAgcmVzKVxuOztcblxubGV0IG9mX2FycmF5IGFyciA9IGluaXQgfmY6KEFycmF5LnVuc2FmZV9nZXQgYXJyKSAoQXJyYXkubGVuZ3RoIGFycikgW0Bub250YWlsXVxubGV0IG1hcCBhIH5mID0gaW5pdCB+ZjooZnVuIGkgLT4gZiAodW5zYWZlX2dldCBhIGkpKSAobGVuZ3RoIGEpIFtAbm9udGFpbF1cbmxldCBtYXBpIGEgfmYgPSBpbml0IH5mOihmdW4gaSAtPiBmIGkgKHVuc2FmZV9nZXQgYSBpKSkgKGxlbmd0aCBhKSBbQG5vbnRhaWxdXG5cbmxldCBpdGVyIGEgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgZiAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyaSBhIH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIGYgaSAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmVcbjs7XG5cbmxldCBmb2xkaSBhIH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICBhY2MgOj0gZiBpICFhY2MgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhYWNjXG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IHIgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZTtcbiAgIXJcbjs7XG5cbmxldCB0b19saXN0IHQgPSBMaXN0LmluaXQgfmY6KGdldCB0KSAobGVuZ3RoIHQpXG5cbmxldCBvZl9saXN0IGwgPVxuICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICBsZXQgcmVzID0gdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW4gaW5cbiAgTGlzdC5pdGVyaSBsIH5mOihmdW4gaSB4IC0+IHNldCByZXMgaSB4KTtcbiAgcmVzXG47O1xuXG5sZXQgb2ZfbGlzdF9yZXYgbCA9XG4gIGxldCBsZW4gPSBMaXN0Lmxlbmd0aCBsIGluXG4gIGxldCByZXMgPSB1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgfmxlbiBpblxuICBMaXN0Lml0ZXJpIGwgfmY6KGZ1biBpIHggLT4gc2V0IHJlcyAobGVuIC0gaSAtIDEpIHgpO1xuICByZXNcbjs7XG5cbigqIEl0IGlzIG5vdCBzYWZlIGZvciBbdG9fYXJyYXldIHRvIGJlIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBiZWNhdXNlIHdlIGhhdmUgY29kZSB0aGF0XG4gICByZWxpZXMgb24gW2Zsb2F0IGFycmF5XXMgYmVpbmcgdW5ib3hlZCwgZm9yIGV4YW1wbGUgaW4gW2Jpbl93cml0ZV9hcnJheV0uICopXG5sZXQgdG9fYXJyYXkgdCA9IEFycmF5LmluaXQgKGxlbmd0aCB0KSB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5cbmxldCBleGlzdHMgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgKHVuc2FmZV9nZXQgdCAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiBmYWxzZSBpblxuICB3aGlsZSAhaSA+PSAwICYmIG5vdCAhcmVzdWx0IGRvXG4gICAgaWYgZiAhaSAodW5zYWZlX2dldCB0ICFpKSB0aGVuIHJlc3VsdCA6PSB0cnVlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiAhcmVzdWx0IGRvXG4gICAgaWYgbm90IChmICh1bnNhZmVfZ2V0IHQgIWkpKSB0aGVuIHJlc3VsdCA6PSBmYWxzZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID49IDAgJiYgIXJlc3VsdCBkb1xuICAgIGlmIG5vdCAoZiAhaSAodW5zYWZlX2dldCB0ICFpKSkgdGhlbiByZXN1bHQgOj0gZmFsc2UgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgciA9IHJlZiBlbXB0eSBpblxuICBsZXQgayA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBtYXRjaCBmIGkgKHVuc2FmZV9nZXQgdCBpKSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGEgLT5cbiAgICAgIGlmICFrID0gMCB0aGVuIHIgOj0gY3JlYXRlIH5sZW46KGxlbmd0aCB0KSBhO1xuICAgICAgdW5zYWZlX3NldCAhciAhayBhO1xuICAgICAgaW5jciBrXG4gIGRvbmU7XG4gIGlmICFrID0gbGVuZ3RoIHQgdGhlbiAhciBlbHNlIGlmICFrID4gMCB0aGVuIHN1YiB+cG9zOjAgfmxlbjohayAhciBlbHNlIGVtcHR5XG47O1xuXG5sZXQgZmlsdGVyaSB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpIFtAbm9udGFpbF1cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gX2kgYSAtPiBmIGEpIFtAbm9udGFpbF1cbmxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcl9tYXAgdCB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSkgW0Bub250YWlsXVxuXG5sZXQgZm9sZDJfZXhuIHQxIHQyIH5pbml0IH5mID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0MSBpblxuICBpZiBsZW5ndGggdDIgPD4gbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5mb2xkMl9leG5cIjtcbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgYWNjIDo9IGYgIWFjYyAodW5zYWZlX2dldCB0MSBpKSAodW5zYWZlX2dldCB0MiBpKVxuICBkb25lO1xuICAhYWNjXG47O1xuXG5sZXQgbWFwMl9leG4gdDEgdDIgfmYgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQxIGluXG4gIGlmIGxlbmd0aCB0MiA8PiBsZW4gdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5Lm1hcDJfZXhuXCI7XG4gIGluaXQgbGVuIH5mOihmdW4gaSAtPiBmICh1bnNhZmVfZ2V0IHQxIGkpICh1bnNhZmVfZ2V0IHQyIGkpKSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgY29uY2F0IHRzID1cbiAgbGV0IHRvdGFsX2xlbiA9IExpc3Quc3VtIChtb2R1bGUgSW50KSB0cyB+ZjooZnVuIHQgLT4gbGVuZ3RoIHQpIGluXG4gIGxldCByZXMgPSB1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgfmxlbjp0b3RhbF9sZW4gaW5cbiAgaWdub3JlXG4gICAgKExpc3QuZm9sZCB0cyB+aW5pdDowIH5mOihmdW4gc29fZmFyIHQgLT5cbiAgICAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICAgc2V0IHJlcyAoc29fZmFyICsgaSkgKGdldCB0IGkpXG4gICAgICAgZG9uZTtcbiAgICAgICBzb19mYXIgKyBsZW4pXG4gICAgICA6IGludCk7XG4gIHJlc1xuOztcblxubGV0IGNvbmNhdF9tYXBpIHQgfmYgPSB0b19saXN0IHQgfD4gTGlzdC5tYXBpIH5mIHw+IGNvbmNhdFxubGV0IGNvbmNhdF9tYXAgdCB+ZiA9IHRvX2xpc3QgdCB8PiBMaXN0Lm1hcCB+ZiB8PiBjb25jYXRcblxubGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9XG4gIGxldCBsZWZ0LCByaWdodCA9IHJlZiBlbXB0eSwgcmVmIGVtcHR5IGluXG4gIGxldCBsZWZ0X2lkeCwgcmlnaHRfaWR4ID0gcmVmIDAsIHJlZiAwIGluXG4gIGxldCBhcHBlbmQgZGF0YSBpZHggdmFsdWUgPVxuICAgIGlmICFpZHggPSAwIHRoZW4gZGF0YSA6PSBjcmVhdGUgfmxlbjoobGVuZ3RoIHQpIHZhbHVlO1xuICAgIHVuc2FmZV9zZXQgIWRhdGEgIWlkeCB2YWx1ZTtcbiAgICBpbmNyIGlkeFxuICBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgbWF0Y2ggKGYgKHVuc2FmZV9nZXQgdCBpKSA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICB8IEZpcnN0IGEgLT4gYXBwZW5kIGxlZnQgbGVmdF9pZHggYVxuICAgIHwgU2Vjb25kIGEgLT4gYXBwZW5kIHJpZ2h0IHJpZ2h0X2lkeCBhXG4gIGRvbmU7XG4gIGxldCB0cmltIGRhdGEgaWR4ID1cbiAgICBpZiAhaWR4ID0gbGVuZ3RoIHRcbiAgICB0aGVuICFkYXRhXG4gICAgZWxzZSBpZiAhaWR4ID4gMFxuICAgIHRoZW4gc3ViIH5wb3M6MCB+bGVuOiFpZHggIWRhdGFcbiAgICBlbHNlIGVtcHR5XG4gIGluXG4gIHRyaW0gbGVmdCBsZWZ0X2lkeCwgdHJpbSByaWdodCByaWdodF9pZHhcbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgTm9uZSBpblxuICAgIHdoaWxlIE9wdGlvbi5pc19ub25lICF2YWx1ZV9mb3VuZCAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICB2YWx1ZV9mb3VuZCA6PSBmIHZhbHVlO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICAhdmFsdWVfZm91bmQpXG47O1xuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuZ3RoID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCB2YWx1ZV9mb3VuZCA9IHJlZiBOb25lIGluXG4gICAgd2hpbGUgT3B0aW9uLmlzX25vbmUgIXZhbHVlX2ZvdW5kICYmICFpIDwgbGVuZ3RoIGRvXG4gICAgICBsZXQgdmFsdWUgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIHZhbHVlX2ZvdW5kIDo9IGYgIWkgdmFsdWU7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgICF2YWx1ZV9mb3VuZClcbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgZm91bmQgPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgKHVuc2FmZV9nZXQgdCAwKSBpblxuICAgIHdoaWxlIChub3QgIWZvdW5kKSAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICBpZiBmICFpIHZhbHVlXG4gICAgICB0aGVuIChcbiAgICAgICAgdmFsdWVfZm91bmQgOj0gdmFsdWU7XG4gICAgICAgIGZvdW5kIDo9IHRydWUpXG4gICAgICBlbHNlIGluY3IgaVxuICAgIGRvbmU7XG4gICAgaWYgIWZvdW5kIHRoZW4gU29tZSAoIWksICF2YWx1ZV9mb3VuZCkgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbmQgdCB+ZiA9IE9wdGlvbi5tYXAgKGZpbmRpIHQgfmY6KGZ1biBfaSB4IC0+IGYgeCkpIH5mOihmdW4gKF9pLCB4KSAtPiB4KVxuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICBsZXQgcmVjIGxvb3AgZiBpID1cbiAgICBpZiBpID49IGxlblxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IHQgaSBpblxuICAgICAgbWF0Y2ggZiBpIHggd2l0aFxuICAgICAgfCBmYWxzZSAtPiBsb29wIGYgKGkgKyAxKVxuICAgICAgfCB0cnVlIC0+IFNvbWUgKGksIHgpKVxuICBpblxuICBsb29wIGYgMFxuOztcblxubGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGVsdCkgKGdyYW1tYXIgOiBlbHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogZWx0IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChBcnJheS50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuOztcblxuaW5jbHVkZVxuICBTZXhwYWJsZS5PZl9zZXhwYWJsZTFcbiAgICAoQXJyYXkpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgbGV0IHRvX3NleHBhYmxlID0gdG9fYXJyYXlcbiAgICAgIGxldCBvZl9zZXhwYWJsZSA9IG9mX2FycmF5XG4gICAgZW5kKVxuXG5pbmNsdWRlIEJsaXQuTWFrZTEgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBsZW5ndGggPSBsZW5ndGhcblxuICBsZXQgY3JlYXRlX2xpa2UgfmxlbiB0ID1cbiAgICBpZiBsZW4gPSAwXG4gICAgdGhlbiBlbXB0eVxuICAgIGVsc2UgKFxuICAgICAgYXNzZXJ0IChsZW5ndGggdCA+IDApO1xuICAgICAgY3JlYXRlIH5sZW4gKGdldCB0IDApKVxuICA7O1xuXG4gIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG5lbmQpXG5cbmxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuXG4oKiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBwcHhfY29tcGFyZSBbY29tcGFyZV9hcnJheV0gYnV0IHVzZXMgb3VyIFt1bnNhZmVfZ2V0XSBhbmQgW2xlbmd0aF0uICopXG5sZXQgY29tcGFyZV9fbG9jYWwgY29tcGFyZV9lbHQgYSBiID1cbiAgaWYgcGh5c19lcXVhbCBhIGJcbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIGxldCBsZW5fYSA9IGxlbmd0aCBhIGluXG4gICAgbGV0IGxlbl9iID0gbGVuZ3RoIGIgaW5cbiAgICBsZXQgcmV0ID0gY29tcGFyZSBsZW5fYSBsZW5fYiBpblxuICAgIGlmIHJldCA8PiAwXG4gICAgdGhlbiByZXRcbiAgICBlbHNlIChcbiAgICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgICAgaWYgaSA9IGxlbl9hXG4gICAgICAgIHRoZW4gMFxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgbCA9IHVuc2FmZV9nZXRfbG9jYWwgYSBpXG4gICAgICAgICAgYW5kIHIgPSB1bnNhZmVfZ2V0X2xvY2FsIGIgaSBpblxuICAgICAgICAgIGxldCByZXMgPSBjb21wYXJlX2VsdCBsIHIgaW5cbiAgICAgICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGxvb3AgKGkgKyAxKSlcbiAgICAgIGluXG4gICAgICBsb29wIDAgW0Bub250YWlsXSkpXG47O1xuXG5sZXQgY29tcGFyZSBjb21wYXJlX2VsdCBhIGIgPSBjb21wYXJlX19sb2NhbCBjb21wYXJlX2VsdCBhIGJcblxubW9kdWxlIFNvcnQgPSBBcnJheS5Qcml2YXRlLlNvcnRlciAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICBsZXQgZ2V0ID0gdW5zYWZlX2dldFxuICBsZXQgc2V0ID0gdW5zYWZlX3NldFxuZW5kKVxuXG5sZXQgc29ydCA9IFNvcnQuc29ydFxuXG5pbmNsdWRlIEJpbmFyeV9zZWFyY2hhYmxlLk1ha2UxIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gIGxldCBnZXQgPSB1bnNhZmVfZ2V0XG5lbmQpXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcbmluY2x1ZGUgVWNoYXJfaW50ZlxuXG5sZXQgZmFpbHdpdGhmID0gUHJpbnRmLmZhaWx3aXRoZlxuXG5pbmNsdWRlIFVjaGFyMFxuXG5sZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuVWNoYXJcIlxubGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPSBIYXNoLmZvbGRfaW50IHN0YXRlICh0b19pbnQgdClcbmxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG5cbigqIE5vdCBmb3IgZXhwb3J0LiBTdHJpbmcgZm9ybWF0cyBleHBvcnRlZCB2aWEgW1V0ZipdIG1vZHVsZXMgYmVsb3cuICopXG5sZXQgdG9fc3RyaW5nX2ludGVybmFsIHQgPSBQcmludGYuc3ByaW50ZiBcIlUrJTA0WFwiICh0b19pbnQgdClcbmxldCBzZXhwX29mX3QgdCA9IFNleHAuQXRvbSAodG9fc3RyaW5nX2ludGVybmFsIHQpXG5cbmxldCB0X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IFNleHAuTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJVY2hhci50X29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuICB8IFNleHAuQXRvbSBzIC0+XG4gICAgKHRyeSBTdGRsaWIuU2NhbmYuc3NjYW5mIHMgXCJVKyVYXCIgKGZ1biBpIC0+IFVjaGFyMC5vZl9pbnQgaSkgd2l0aFxuICAgICB8IF8gLT4gb2Zfc2V4cF9lcnJvciBcIlVjaGFyLnRfb2Zfc2V4cDogYXRvbSBvZiB0aGUgZm9ybSBVK1hYWFggbmVlZGVkXCIgc2V4cClcbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIHN0cmluZ19zZXhwX2dyYW1tYXJcbjs7XG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IG1vZHVsZV9uYW1lXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdfaW50ZXJuYWxcbmVuZClcblxuaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCBjb21wYXJlID0gY29tcGFyZVxuICBsZXQgc2V4cF9vZl90ID0gc2V4cF9vZl90XG5lbmQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFVjaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGludF9pc19zY2FsYXIgPSBpc192YWxpZFxuXG5sZXQgc3VjY19leG4gYyA9XG4gIHRyeSBVY2hhcjAuc3VjYyBjIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IG1zZyAtPiBmYWlsd2l0aGYgXCJVY2hhci5zdWNjX2V4bjogJXNcIiBtc2cgKClcbjs7XG5cbmxldCBzdWNjIGMgPVxuICB0cnkgU29tZSAoVWNoYXIwLnN1Y2MgYykgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBOb25lXG47O1xuXG5sZXQgcHJlZF9leG4gYyA9XG4gIHRyeSBVY2hhcjAucHJlZCBjIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IG1zZyAtPiBmYWlsd2l0aGYgXCJVY2hhci5wcmVkX2V4bjogJXNcIiBtc2cgKClcbjs7XG5cbmxldCBwcmVkIGMgPVxuICB0cnkgU29tZSAoVWNoYXIwLnByZWQgYykgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBOb25lXG47O1xuXG5sZXQgb2Zfc2NhbGFyIGkgPSBpZiBpbnRfaXNfc2NhbGFyIGkgdGhlbiBTb21lICh1bnNhZmVfb2ZfaW50IGkpIGVsc2UgTm9uZVxuXG5sZXQgb2Zfc2NhbGFyX2V4biBpID1cbiAgaWYgaW50X2lzX3NjYWxhciBpXG4gIHRoZW4gdW5zYWZlX29mX2ludCBpXG4gIGVsc2UgZmFpbHdpdGhmIFwiVWNoYXIub2ZfaW50X2V4biBnb3QgYSBpbnZhbGlkIFVuaWNvZGUgc2NhbGFyIHZhbHVlOiAlMDRYXCIgaSAoKVxuOztcblxubGV0IHRvX3NjYWxhciB0ID0gVWNoYXIwLnRvX2ludCB0XG5sZXQgdG9fY2hhciBjID0gaWYgaXNfY2hhciBjIHRoZW4gU29tZSAodW5zYWZlX3RvX2NoYXIgYykgZWxzZSBOb25lXG5cbmxldCB0b19jaGFyX2V4biBjID1cbiAgaWYgaXNfY2hhciBjXG4gIHRoZW4gdW5zYWZlX3RvX2NoYXIgY1xuICBlbHNlIGZhaWx3aXRoZiBcIlVjaGFyLnRvX2NoYXJfZXhuIGdvdCBhIG5vbiBsYXRpbi0xIGNoYXJhY3RlcjogVSslMDRYXCIgKHRvX2ludCBjKSAoKVxuOztcblxubW9kdWxlIERlY29kZV9yZXN1bHQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVWNoYXIwLnV0Zl9kZWNvZGVcblxuICBsZXQgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGVxdWFsIDogdCAtPiB0IC0+IGJvb2wgPSBQb2x5LmVxdWFsXG5cbiAgbGV0IGhhc2hfZm9sZF90IDogSGFzaC5zdGF0ZSAtPiB0IC0+IEhhc2guc3RhdGUgPVxuICAgIGZ1biBzdGF0ZSB0IC0+IGhhc2hfZm9sZF9pbnQgc3RhdGUgKEhhc2hhYmxlLmhhc2ggdClcbiAgOztcblxuICBsZXQgaGFzaCA6IHQgLT4gaW50ID0gSGFzaGFibGUuaGFzaFxuICBsZXQgaXNfdmFsaWQgPSBVY2hhcjAudXRmX2RlY29kZV9pc192YWxpZFxuICBsZXQgYnl0ZXNfY29uc3VtZWQgPSBVY2hhcjAudXRmX2RlY29kZV9sZW5ndGhcbiAgbGV0IHVjaGFyX29yX3JlcGxhY2VtZW50X2NoYXIgPSBVY2hhcjAudXRmX2RlY29kZV91Y2hhclxuICBsZXQgc2V4cF9vZl90IHQgPSBzZXhwX29mX3QgKHVjaGFyX29yX3JlcGxhY2VtZW50X2NoYXIgdClcblxuICBsZXQgdWNoYXIgdCA9XG4gICAgbWF0Y2ggaXNfdmFsaWQgdCB3aXRoXG4gICAgfCB0cnVlIC0+IFNvbWUgKHVjaGFyX29yX3JlcGxhY2VtZW50X2NoYXIgdClcbiAgICB8IGZhbHNlIC0+IE5vbmVcbiAgOztcblxuICBsZXRbQHplcm9fYWxsb2NdIHVjaGFyX2V4biB0ID1cbiAgICBtYXRjaCBpc192YWxpZCB0IHdpdGhcbiAgICB8IHRydWUgLT4gdWNoYXJfb3JfcmVwbGFjZW1lbnRfY2hhciB0XG4gICAgfCBmYWxzZSAtPlxuICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAoQXRvbSBcIlVjaGFyLkRlY29kZV9yZXN1bHQudWNoYXJfZXhuIHdhcyBjYWxsZWQgb24gYW4gaW52YWxpZCBkZWNvZGUgcmVzdWx0XCIpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2VfdXRmIChGb3JtYXQgOiBzaWdcbiAgdmFsIGNvZGVjX25hbWUgOiBzdHJpbmdcbiAgdmFsIG1vZHVsZV9uYW1lIDogc3RyaW5nXG4gIHZhbCBieXRlX2xlbmd0aCA6IHQgLT4gaW50XG4gIHZhbCBnZXRfZGVjb2RlX3Jlc3VsdCA6IHN0cmluZyAtPiBieXRlX3BvczppbnQgLT4gRGVjb2RlX3Jlc3VsdC50XG4gIHZhbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gdCAtPiBpbnRcbmVuZCkgOiBVdGYgPSBzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBGb3JtYXQuY29kZWNfbmFtZVxuICBsZXQgYnl0ZV9sZW5ndGggPSBGb3JtYXQuYnl0ZV9sZW5ndGhcblxuICBsZXQgdG9fc3RyaW5nIHQgPVxuICAgIGxldCBsZW4gPSBieXRlX2xlbmd0aCB0IGluXG4gICAgbGV0IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCBwb3MgPSBGb3JtYXQuc2V0IGJ5dGVzIDAgdCBpblxuICAgIGFzc2VydCAoSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCBwb3MgbGVuKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmJ5dGVzXG4gIDs7XG5cbiAgbGV0IG9mX3N0cmluZ19tZXNzYWdlID1cbiAgICBGb3JtYXQubW9kdWxlX25hbWUgXiBcIi5vZl9zdHJpbmc6IGV4cGVjdGVkIGEgc2luZ2xlIFVuaWNvZGUgY2hhcmFjdGVyXCJcbiAgOztcblxuICBsZXRbQGNvbGRdIHJhaXNlX29mX3N0cmluZyBzdHJpbmcgPVxuICAgIEVycm9yLnJhaXNlX3MgKFNleHAubWVzc2FnZSBvZl9zdHJpbmdfbWVzc2FnZSBbIFwic3RyaW5nXCIsIEF0b20gc3RyaW5nIF0pXG4gIDs7XG5cbiAgbGV0IG9mX3N0cmluZyBzdHJpbmcgPVxuICAgIGxldCBkZWNvZGUgPSBGb3JtYXQuZ2V0X2RlY29kZV9yZXN1bHQgc3RyaW5nIH5ieXRlX3BvczowIGluXG4gICAgbGV0IHN0cmluZ19sZW4gPSBTdHJpbmcubGVuZ3RoIHN0cmluZyBpblxuICAgIGxldCBkZWNvZGVfbGVuID0gRGVjb2RlX3Jlc3VsdC5ieXRlc19jb25zdW1lZCBkZWNvZGUgaW5cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIHN0cmluZ19sZW4gZGVjb2RlX2xlblxuICAgICAgICYmIERlY29kZV9yZXN1bHQuaXNfdmFsaWQgZGVjb2RlXG4gICAgdGhlbiBEZWNvZGVfcmVzdWx0LnVjaGFyX29yX3JlcGxhY2VtZW50X2NoYXIgZGVjb2RlXG4gICAgZWxzZSByYWlzZV9vZl9zdHJpbmcgc3RyaW5nXG4gIDs7XG5lbmRcblxubW9kdWxlIFV0ZjggPSBNYWtlX3V0ZiAoc3RydWN0XG4gIGxldCBjb2RlY19uYW1lID0gXCJVVEYtOFwiXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5VY2hhci5VdGY4XCJcbiAgbGV0IGJ5dGVfbGVuZ3RoID0gdXRmXzhfYnl0ZV9sZW5ndGhcbiAgbGV0IGdldF9kZWNvZGVfcmVzdWx0ID0gU3RyaW5nLmdldF91dGZfOF91Y2hhclxuICBsZXQgc2V0ID0gQnl0ZXMuc2V0X3VjaGFyX3V0Zl84XG5lbmQpXG5cbm1vZHVsZSBVdGYxNmxlID0gTWFrZV91dGYgKHN0cnVjdFxuICBsZXQgY29kZWNfbmFtZSA9IFwiVVRGLTE2TEVcIlxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuVWNoYXIuVXRmMTZsZVwiXG4gIGxldCBieXRlX2xlbmd0aCA9IHV0Zl8xNl9ieXRlX2xlbmd0aFxuICBsZXQgZ2V0X2RlY29kZV9yZXN1bHQgPSBTdHJpbmcuZ2V0X3V0Zl8xNmxlX3VjaGFyXG4gIGxldCBzZXQgPSBCeXRlcy5zZXRfdWNoYXJfdXRmXzE2bGVcbmVuZClcblxubW9kdWxlIFV0ZjE2YmUgPSBNYWtlX3V0ZiAoc3RydWN0XG4gIGxldCBjb2RlY19uYW1lID0gXCJVVEYtMTZCRVwiXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5VY2hhci5VdGYxNmJlXCJcbiAgbGV0IGJ5dGVfbGVuZ3RoID0gdXRmXzE2X2J5dGVfbGVuZ3RoXG4gIGxldCBnZXRfZGVjb2RlX3Jlc3VsdCA9IFN0cmluZy5nZXRfdXRmXzE2YmVfdWNoYXJcbiAgbGV0IHNldCA9IEJ5dGVzLnNldF91Y2hhcl91dGZfMTZiZVxuZW5kKVxuXG5tb2R1bGUgVXRmMzJsZSA9IE1ha2VfdXRmIChzdHJ1Y3RcbiAgbGV0IGNvZGVjX25hbWUgPSBcIlVURi0zMkxFXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlVjaGFyLlV0ZjMybGVcIlxuICBsZXQgYnl0ZV9sZW5ndGggXyA9IDRcbiAgbGV0IGdldF9kZWNvZGVfcmVzdWx0ID0gU3RyaW5nLmdldF91dGZfMzJsZV91Y2hhclxuICBsZXQgc2V0ID0gQnl0ZXMuc2V0X3VjaGFyX3V0Zl8zMmxlXG5lbmQpXG5cbm1vZHVsZSBVdGYzMmJlID0gTWFrZV91dGYgKHN0cnVjdFxuICBsZXQgY29kZWNfbmFtZSA9IFwiVVRGLTMyQkVcIlxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuVWNoYXIuVXRmMzJiZVwiXG4gIGxldCBieXRlX2xlbmd0aCBfID0gNFxuICBsZXQgZ2V0X2RlY29kZV9yZXN1bHQgPSBTdHJpbmcuZ2V0X3V0Zl8zMmJlX3VjaGFyXG4gIGxldCBzZXQgPSBCeXRlcy5zZXRfdWNoYXJfdXRmXzMyYmVcbmVuZClcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIFVjaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwiKCoqIFRoZSBwdXJwb3NlIG9mIFtUeXBlX2VxdWFsXSBpcyB0byByZXByZXNlbnQgdHlwZSBlcXVhbGl0aWVzIHRoYXQgdGhlIHR5cGUgY2hlY2tlclxuICAgIG90aGVyd2lzZSB3b3VsZCBub3Qga25vdywgcGVyaGFwcyBiZWNhdXNlIHRoZSB0eXBlIGVxdWFsaXR5IGRlcGVuZHMgb24gZHluYW1pYyBkYXRhLFxuICAgIG9yIHBlcmhhcHMgYmVjYXVzZSB0aGUgdHlwZSBzeXN0ZW0gaXNuJ3QgcG93ZXJmdWwgZW5vdWdoLlxuXG4gICAgQSB2YWx1ZSBvZiB0eXBlIFsoYSwgYikgVHlwZV9lcXVhbC50XSByZXByZXNlbnRzIHRoYXQgdHlwZXMgW2FdIGFuZCBbYl0gYXJlIGVxdWFsLlxuICAgIE9uZSBjYW4gdGhpbmsgb2Ygc3VjaCBhIHZhbHVlIGFzIGEgcHJvb2Ygb2YgdHlwZSBlcXVhbGl0eS4gIFRoZSBbVHlwZV9lcXVhbF0gbW9kdWxlXG4gICAgaGFzIG9wZXJhdGlvbnMgZm9yIGNvbnN0cnVjdGluZyBhbmQgbWFuaXB1bGF0aW5nIHN1Y2ggcHJvb2ZzLiAgRm9yIGV4YW1wbGUsIHRoZVxuICAgIGZ1bmN0aW9ucyBbcmVmbF0sIFtzeW1dLCBhbmQgW3RyYW5zXSBleHByZXNzIHRoZSB1c3VhbCBwcm9wZXJ0aWVzIG9mIHJlZmxleGl2aXR5LFxuICAgIHN5bW1ldHJ5LCBhbmQgdHJhbnNpdGl2aXR5IG9mIGVxdWFsaXR5LlxuXG4gICAgSWYgb25lIGhhcyBhIHZhbHVlIFt0IDogKGEsIGIpIFR5cGVfZXF1YWwudF0gdGhhdCBwcm92ZXMgdHlwZXMgW2FdIGFuZCBbYl0gYXJlIGVxdWFsLFxuICAgIHRoZXJlIGFyZSB0d28gd2F5cyB0byB1c2UgW3RdIHRvIHNhZmVseSBjb252ZXJ0IGEgdmFsdWUgb2YgdHlwZSBbYV0gdG8gYSB2YWx1ZSBvZiB0eXBlXG4gICAgW2JdOiBbVHlwZV9lcXVhbC5jb252XSBvciBwYXR0ZXJuIG1hdGNoaW5nIG9uIFtUeXBlX2VxdWFsLlRdOlxuXG4gICAge1tcbiAgICAgIGxldCBmICh0eXBlIGEpICh0eXBlIGIpICh0IDogKGEsIGIpIFR5cGVfZXF1YWwudCkgKGEgOiBhKSA6IGIgPVxuICAgICAgICBUeXBlX2VxdWFsLmNvbnYgdCBhXG5cbiAgICAgIGxldCBmICh0eXBlIGEpICh0eXBlIGIpICh0IDogKGEsIGIpIFR5cGVfZXF1YWwudCkgKGEgOiBhKSA6IGIgPVxuICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID0gdCBpbiBhXG4gICAgXX1cblxuICAgIEF0IHJ1bnRpbWUsIGNvbnZlcnNpb24gYnkgZWl0aGVyIG1lYW5zIGlzIGp1c3QgdGhlIGlkZW50aXR5IC0tIG5vdGhpbmcgaXMgY2hhbmdpbmdcbiAgICBhYm91dCB0aGUgdmFsdWUuICBDb25zaXN0ZW50IHdpdGggdGhpcywgYSB2YWx1ZSBvZiB0eXBlIFtUeXBlX2VxdWFsLnRdIGlzIGFsd2F5cyBqdXN0XG4gICAgYSBjb25zdHJ1Y3RvciBbVHlwZV9lcXVhbC5UXTsgdGhlIHZhbHVlIGhhcyBubyBpbnRlcmVzdGluZyBzZW1hbnRpYyBjb250ZW50LlxuICAgIFtUeXBlX2VxdWFsXSBnZXRzIGl0cyBwb3dlciBmcm9tIHRoZSBhYmlsaXR5IHRvLCBpbiBhIHR5cGUtc2FmZSB3YXksIHByb3ZlIHRvIHRoZSB0eXBlXG4gICAgY2hlY2tlciB0aGF0IHR3byB0eXBlcyBhcmUgZXF1YWwuICBUaGUgW1R5cGVfZXF1YWwudF0gdmFsdWUgdGhhdCBpcyBwYXNzZWQgaXNcbiAgICBuZWNlc3NhcnkgZm9yIHRoZSB0eXBlLWNoZWNrZXIncyBydWxlcyB0byBiZSBjb3JyZWN0LCBidXQgdGhlIGNvbXBpbGVyIGNvdWxkLCBpblxuICAgIHByaW5jaXBsZSwgbm90IHBhc3MgYXJvdW5kIHZhbHVlcyBvZiB0eXBlIFtUeXBlX2VxdWFsLnRdIGF0IHJ1bnRpbWUuXG4qKVxuXG5vcGVuISBJbXBvcnRcbm9wZW4gVFxuXG4oKiovKiopXG5cbm1vZHVsZSBUeXBlX2VxdWFsX2RlZm5zIChUeXBlX2VxdWFsIDogVC5UMikgPSBzdHJ1Y3RcbiAgKCoqIFRoZSBbTGlmdCpdIG1vZHVsZSB0eXBlcyBhcmUgdXNlZCBieSB0aGUgW0xpZnQqXSBmdW5jdG9ycy4gU2VlIGJlbG93LiAqKVxuXG4gIG1vZHVsZSB0eXBlIExpZnQgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBsaWZ0IDogKCdhLCAnYikgVHlwZV9lcXVhbC50IC0+ICgnYSB0LCAnYiB0KSBUeXBlX2VxdWFsLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTGlmdDIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBsaWZ0XG4gICAgICA6ICAoJ2ExLCAnYjEpIFR5cGVfZXF1YWwudFxuICAgICAgLT4gKCdhMiwgJ2IyKSBUeXBlX2VxdWFsLnRcbiAgICAgIC0+ICgoJ2ExLCAnYTIpIHQsICgnYjEsICdiMikgdCkgVHlwZV9lcXVhbC50XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIExpZnQzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGxpZnRcbiAgICAgIDogICgnYTEsICdiMSkgVHlwZV9lcXVhbC50XG4gICAgICAtPiAoJ2EyLCAnYjIpIFR5cGVfZXF1YWwudFxuICAgICAgLT4gKCdhMywgJ2IzKSBUeXBlX2VxdWFsLnRcbiAgICAgIC0+ICgoJ2ExLCAnYTIsICdhMykgdCwgKCdiMSwgJ2IyLCAnYjMpIHQpIFR5cGVfZXF1YWwudFxuICBlbmRcblxuICAoKiogW0luamVjdGl2ZV0gaXMgYW4gaW50ZXJmYWNlIHRoYXQgc3RhdGVzIHRoYXQgYSB0eXBlIGlzIGluamVjdGl2ZSwgd2hlcmUgdGhlIHR5cGUgaXNcbiAgICAgIHZpZXdlZCBhcyBhIGZ1bmN0aW9uIGZyb20gdHlwZXMgdG8gb3RoZXIgdHlwZXMuIEl0IHByZWRhdGVzIE9DYW1sJ3Mgc3VwcG9ydCBmb3JcbiAgICAgIGV4cGxpY2l0IGluamVjdGl2aXR5IGFubm90YXRpb25zIGluIHRoZSB0eXBlIHN5c3RlbS5cblxuICAgICAgVGhlIHR5cGljYWwgcHJpb3IgdXNhZ2Ugd2FzOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlICdhIHRcbiAgICAgICAgaW5jbHVkZSBJbmplY3RpdmUgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICAgICAgXX1cblxuICAgICAgRm9yIGV4YW1wbGUsIFsnYSBsaXN0XSBpcyBhbiBpbmplY3RpdmUgdHlwZSwgYmVjYXVzZSB3aGVuZXZlciBbJ2EgbGlzdCA9ICdiIGxpc3RdLFxuICAgICAgd2Uga25vdyB0aGF0IFsnYV0gPSBbJ2JdLiBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgd2UgZGVmaW5lOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlICdhIHQgPSB1bml0XG4gICAgICBdfVxuXG4gICAgICB0aGVuIGNsZWFybHkgW3RdIGlzbid0IGluamVjdGl2ZSwgYmVjYXVzZSwgZS5nLiwgW2ludCB0ID0gYm9vbCB0XSwgYnV0XG4gICAgICBbaW50IDw+IGJvb2xdLlxuXG4gICAgICBJZiBbbW9kdWxlIE0gOiBJbmplY3RpdmVdLCB0aGVuIFtNLnN0cmlwXSBwcm92aWRlcyBhIHdheSB0byBnZXQgYSBwcm9vZiB0aGF0IHR3b1xuICAgICAgdHlwZXMgYXJlIGVxdWFsIGZyb20gYSBwcm9vZiB0aGF0IGJvdGggdHlwZXMgdHJhbnNmb3JtZWQgYnkgW00udF0gYXJlIGVxdWFsLiBBXG4gICAgICB0eXBpY2FsIGltcGxlbWVudGF0aW9uIGxvb2tlZCBsaWtlIHRoaXM6XG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBzdHJpcCAodHlwZSBhKSAodHlwZSBiKVxuICAgICAgICAgICAgICAoVHlwZV9lcXVhbC5UIDogKGEgdCwgYiB0KSBUeXBlX2VxdWFsLnQpIDogKGEsIGIpIFR5cGVfZXF1YWwudCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5UXG4gICAgICBdfVxuXG4gICAgICBUaGlzIHdpbGwgbm90IHR5cGUgY2hlY2sgZm9yIGFsbCB0eXBlIGNvbnN0cnVjdG9ycyAoY2VydGFpbmx5IG5vdCBmb3Igbm9uLWluamVjdGl2ZVxuICAgICAgb25lcyEpLCBidXQgaXQncyBhbHdheXMgc2FmZSB0byB0cnkgdGhlIGFib3ZlIGltcGxlbWVudGF0aW9uIGlmIHlvdSBhcmUgdW5zdXJlLiBJZlxuICAgICAgT0NhbWwgYWNjZXB0cyB0aGlzIGRlZmluaXRpb24sIHRoZW4gdGhlIHR5cGUgaXMgaW5qZWN0aXZlLiBPbiB0aGUgb3RoZXIgaGFuZCwgaWZcbiAgICAgIE9DYW1sIGRvZXNuJ3QsIHRoZW4gdGhlIHR5cGUgbWF5IG9yIG1heSBub3QgYmUgaW5qZWN0aXZlLiBGb3IgZXhhbXBsZSwgaWYgdGhlXG4gICAgICBkZWZpbml0aW9uIG9mIHRoZSB0eXBlIGRlcGVuZHMgb24gYWJzdHJhY3QgdHlwZXMgdGhhdCBtYXRjaCBbSW5qZWN0aXZlXSwgT0NhbWwgd2lsbFxuICAgICAgbm90IGF1dG9tYXRpY2FsbHkgdXNlIHRoZWlyIGluamVjdGl2aXR5LCBhbmQgb25lIHdpbGwgaGF2ZSB0byB3cml0ZSBhIG1vcmVcbiAgICAgIGNvbXBsaWNhdGVkIGRlZmluaXRpb24gb2YgW3N0cmlwXSB0aGF0IGNhdXNlcyBPQ2FtbCB0byB1c2UgdGhhdCBmYWN0LiBGb3IgZXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgbW9kdWxlIEYgKE0gOiBUeXBlX2VxdWFsLkluamVjdGl2ZSkgOiBUeXBlX2VxdWFsLkluamVjdGl2ZSA9IHN0cnVjdFxuICAgICAgICAgIHR5cGUgJ2EgdCA9ICdhIE0udCAqIGludFxuXG4gICAgICAgICAgbGV0IHN0cmlwICh0eXBlIGEpICh0eXBlIGIpXG4gICAgICAgICAgICAgICAgKGUgOiAoYSB0LCBiIHQpIFR5cGVfZXF1YWwudCkgOiAoYSwgYikgVHlwZV9lcXVhbC50ID1cbiAgICAgICAgICAgIGxldCBlMSwgXyA9IFR5cGVfZXF1YWwuZGV0dXBsZTIgZSBpblxuICAgICAgICAgICAgTS5zdHJpcCBlMVxuICAgICAgICAgIDs7XG4gICAgICAgIGVuZFxuICAgICAgXX1cblxuICAgICAgSWYgaW4gdGhlIGRlZmluaXRpb24gb2YgW0ZdIHdlIGhhZCB3cml0dGVuIHRoZSBzaW1wbGVyIGltcGxlbWVudGF0aW9uIG9mIFtzdHJpcF0gdGhhdFxuICAgICAgZGlkbid0IHVzZSBbTS5zdHJpcF0sIHRoZW4gT0NhbWwgd291bGQgaGF2ZSByZXBvcnRlZCBhIHR5cGUgZXJyb3IuXG4gICopXG4gIG1vZHVsZSB0eXBlIEluamVjdGl2ZSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIHN0cmlwIDogKCdhIHQsICdiIHQpIFR5cGVfZXF1YWwudCAtPiAoJ2EsICdiKSBUeXBlX2VxdWFsLnRcbiAgZW5kXG4gIFtAQGRlcHJlY2F0ZWRcbiAgICBcIltzaW5jZSAyMDIzLTA4XSBPQ2FtbCBub3cgc3VwcG9ydHMgaW5qZWN0aXZpdHkgYW5ub3RhdGlvbnMuIFt0eXBlICEnYSB0XSBkZWNsYXJlcyBcXFxuICAgICB0aGF0IFsnYSB0XSBpcyBpbmplY3RpdmUgd2l0aCByZXNwZWN0IHRvIFsnYV0uXCJdXG5cbiAgKCoqIFtJbmplY3RpdmUyXSBpcyBmb3IgYSBiaW5hcnkgdHlwZSB0aGF0IGlzIGluamVjdGl2ZSBpbiBib3RoIHR5cGUgYXJndW1lbnRzLiAqKVxuICBtb2R1bGUgdHlwZSBJbmplY3RpdmUyID0gc2lnXG4gICAgdHlwZSAoJ2ExLCAnYTIpIHRcblxuICAgIHZhbCBzdHJpcFxuICAgICAgOiAgKCgnYTEsICdhMikgdCwgKCdiMSwgJ2IyKSB0KSBUeXBlX2VxdWFsLnRcbiAgICAgIC0+ICgnYTEsICdiMSkgVHlwZV9lcXVhbC50ICogKCdhMiwgJ2IyKSBUeXBlX2VxdWFsLnRcbiAgZW5kXG4gIFtAQGRlcHJlY2F0ZWRcbiAgICBcIltzaW5jZSAyMDIzLTA4XSBPQ2FtbCBub3cgc3VwcG9ydHMgaW5qZWN0aXZpdHkgYW5ub3RhdGlvbnMuIFt0eXBlICEnYSB0XSBkZWNsYXJlcyBcXFxuICAgICB0aGF0IFsnYSB0XSBpcyBpbmplY3RpdmUgd2l0aCByZXNwZWN0IHRvIFsnYV0uXCJdXG5cbiAgKCoqIFtDb21wb3NpdGlvbl9wcmVzZXJ2ZXNfaW5qZWN0aXZpdHldIGlzIGEgZnVuY3RvciB0aGF0IHByb3ZlcyB0aGF0IGNvbXBvc2l0aW9uIG9mXG4gICAgICBpbmplY3RpdmUgdHlwZXMgaXMgaW5qZWN0aXZlLiAqKVxuICBtb2R1bGUgQ29tcG9zaXRpb25fcHJlc2VydmVzX2luamVjdGl2aXR5IChNMSA6IEluamVjdGl2ZSkgKE0yIDogSW5qZWN0aXZlKSA6XG4gICAgSW5qZWN0aXZlIHdpdGggdHlwZSAnYSB0ID0gJ2EgTTEudCBNMi50ID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgTTEudCBNMi50XG5cbiAgICBsZXQgc3RyaXAgZSA9IE0xLnN0cmlwIChNMi5zdHJpcCBlKVxuICBlbmRcbiAgW0BAYWxlcnQgXCItZGVwcmVjYXRlZFwiXVxuICBbQEBkZXByZWNhdGVkXG4gICAgXCJbc2luY2UgMjAyMy0wOF0gT0NhbWwgbm93IHN1cHBvcnRzIGluamVjdGl2aXR5IGFubm90YXRpb25zLiBbdHlwZSAhJ2EgdF0gZGVjbGFyZXMgXFxcbiAgICAgdGhhdCBbJ2EgdF0gaXMgaW5qZWN0aXZlIHdpdGggcmVzcGVjdCB0byBbJ2FdLlwiXVxuZW5kXG5cbm1vZHVsZSBUeXBlX2VxdWFsX2lkX2RlZm5zIChJZCA6IHNpZ1xuICB0eXBlICdhIHRcbmVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSB0eXBlIEFyZzAgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgbmFtZSA6IHN0cmluZ1xuICBlbmRcblxuICBtb2R1bGUgdHlwZSBBcmcxID0gc2lnXG4gICAgdHlwZSAhJ2EgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3QgOiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCBuYW1lIDogc3RyaW5nXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEFyZzIgPSBzaWdcbiAgICB0eXBlICghJ2EsICEnYikgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3RcbiAgICAgIDogICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdhLCAnYikgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIG5hbWUgOiBzdHJpbmdcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQXJnMyA9IHNpZ1xuICAgIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnYyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2EsICdiLCAnYykgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIG5hbWUgOiBzdHJpbmdcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzAgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCB0eXBlX2VxdWFsX2lkIDogdCBJZC50XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgdHlwZV9lcXVhbF9pZCA6ICdhIElkLnQgLT4gJ2EgdCBJZC50XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgdHlwZV9lcXVhbF9pZCA6ICdhIElkLnQgLT4gJ2IgSWQudCAtPiAoJ2EsICdiKSB0IElkLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgdHlwZV9lcXVhbF9pZCA6ICdhIElkLnQgLT4gJ2IgSWQudCAtPiAnYyBJZC50IC0+ICgnYSwgJ2IsICdjKSB0IElkLnRcbiAgZW5kXG5lbmRcblxuKCoqLyoqKVxuXG5tb2R1bGUgdHlwZSBUeXBlX2VxdWFsID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdCA9IFQgOiAoJ2EsICdhKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3RcbiAgICA6ICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5cbiAgKCoqIGp1c3QgYW4gYWxpYXMsIG5lZWRlZCB3aGVuIFt0XSBnZXRzIHNoYWRvd2VkIGJlbG93ICopXG4gIHR5cGUgKCdhLCAnYikgZXF1YWwgOj0gKCdhLCAnYikgdFxuXG4gICgqKiBAaW5saW5lICopXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2YgVHlwZV9lcXVhbF9kZWZucyAoc3RydWN0XG4gICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgZXF1YWxcbiAgZW5kKVxuXG4gICgqKiBbcmVmbF0sIFtzeW1dLCBhbmQgW3RyYW5zXSBjb25zdHJ1Y3QgcHJvb2ZzIHRoYXQgdHlwZSBlcXVhbGl0eSBpcyByZWZsZXhpdmUsXG4gICAgICBzeW1tZXRyaWMsIGFuZCB0cmFuc2l0aXZlLiAqKVxuXG4gIHZhbCByZWZsIDogKCdhLCAnYSkgdFxuICB2YWwgc3ltIDogKCdhLCAnYikgdCAtPiAoJ2IsICdhKSB0XG4gIHZhbCB0cmFucyA6ICgnYSwgJ2IpIHQgLT4gKCdiLCAnYykgdCAtPiAoJ2EsICdjKSB0XG5cbiAgKCoqIFtjb252IHQgeF0gdXNlcyB0aGUgdHlwZSBlcXVhbGl0eSBbdCA6IChhLCBiKSB0XSBhcyBldmlkZW5jZSB0byBzYWZlbHkgY2FzdCBbeF1cbiAgICAgIGZyb20gdHlwZSBbYV0gdG8gdHlwZSBbYl0uICBbY29udl0gaXMgc2VtYW50aWNhbGx5IGp1c3QgdGhlIGlkZW50aXR5IGZ1bmN0aW9uLlxuXG4gICAgICBJbiBhIHByb2dyYW0gdGhhdCBoYXMgW3QgOiAoYSwgYikgdF0gd2hlcmUgb25lIGhhcyBhIHZhbHVlIG9mIHR5cGUgW2FdIHRoYXQgb25lXG4gICAgICB3YW50cyB0byB0cmVhdCBhcyBhIHZhbHVlIG9mIHR5cGUgW2JdLCBpdCBpcyBvZnRlbiBzdWZmaWNpZW50IHRvIHBhdHRlcm4gbWF0Y2ggb25cbiAgICAgIFtUeXBlX2VxdWFsLlRdIHJhdGhlciB0aGFuIHVzZSBbY29udl0uIEhvd2V2ZXIsIHRoZXJlIGFyZSBzaXR1YXRpb25zIHdoZXJlIE9DYW1sJ3NcbiAgICAgIHR5cGUgY2hlY2tlciB3aWxsIG5vdCB1c2UgdGhlIHR5cGUgZXF1YWxpdHkgW2EgPSBiXSwgYW5kIG9uZSBtdXN0IHVzZSBbY29udl0uIEZvclxuICAgICAgZXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgbW9kdWxlIEYgKE0xIDogc2lnIHR5cGUgdCBlbmQpIChNMiA6IHNpZyB0eXBlIHQgZW5kKSA6IHNpZ1xuICAgICAgICAgIHZhbCBmIDogKE0xLnQsIE0yLnQpIGVxdWFsIC0+IE0xLnQgLT4gTTIudFxuICAgICAgICBlbmQgPSBzdHJ1Y3RcbiAgICAgICAgICBsZXQgZiBlcXVhbCAobTEgOiBNMS50KSA9IGNvbnYgZXF1YWwgbTFcbiAgICAgICAgZW5kXG4gICAgICBdfVxuXG4gICAgICBJZiBvbmUgd3JvdGUgdGhlIGJvZHkgb2YgW0ZdIHVzaW5nIHBhdHRlcm4gbWF0Y2hpbmcgb24gW1RdOlxuXG4gICAgICB7W1xuICAgICAgICBsZXQgZiAoVCA6IChNMS50LCBNMi50KSBlcXVhbCkgKG0xIDogTTEudCkgPSAobTEgOiBNMi50KVxuICAgICAgXX1cblxuICAgICAgdGhpcyB3b3VsZCBnaXZlIGEgdHlwZSBlcnJvci4gKilcbiAgdmFsIGNvbnYgOiAoJ2EsICdiKSB0IC0+ICdhIC0+ICdiXG5cbiAgKCoqIEl0IGlzIGFsd2F5cyBzYWZlIHRvIGNvbmNsdWRlIHRoYXQgaWYgdHlwZSBbYV0gZXF1YWxzIFtiXSwgdGhlbiBmb3IgYW55IHR5cGUgWydhIHRdLFxuICAgICAgdHlwZSBbYSB0XSBlcXVhbHMgW2IgdF0uIFRoZSBPQ2FtbCB0eXBlIGNoZWNrZXIgdXNlcyB0aGlzIGZhY3Qgd2hlbiBpdCBjYW4uIEhvd2V2ZXIsXG4gICAgICBzb21ldGltZXMsIGUuZy4sIHdoZW4gdXNpbmcgW2NvbnZdLCBvbmUgbmVlZHMgdG8gZXhwbGljaXRseSB1c2UgdGhpcyBmYWN0IHRvXG4gICAgICBjb25zdHJ1Y3QgYW4gYXBwcm9wcmlhdGUgW1R5cGVfZXF1YWwudF0uIFRoZSBbTGlmdCpdIGZ1bmN0b3JzIGRvIHRoaXMuICopXG5cbiAgbW9kdWxlIExpZnQgKFQgOiBUMSkgOiBMaWZ0IHdpdGggdHlwZSAnYSB0IDo9ICdhIFQudFxuICBtb2R1bGUgTGlmdDIgKFQgOiBUMikgOiBMaWZ0MiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBULnRcbiAgbW9kdWxlIExpZnQzIChUIDogVDMpIDogTGlmdDMgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSBULnRcblxuICAoKiogW3R1cGxlMl0gYW5kIFtkZXR1cGxlMl0gY29udmVydCBiZXR3ZWVuIGVxdWFsaXR5IG9uIGEgMi10dXBsZSBhbmQgaXRzIGNvbXBvbmVudHMuICopXG5cbiAgdmFsIGRldHVwbGUyIDogKCdhMSAqICdhMiwgJ2IxICogJ2IyKSB0IC0+ICgnYTEsICdiMSkgdCAqICgnYTIsICdiMikgdFxuICB2YWwgdHVwbGUyIDogKCdhMSwgJ2IxKSB0IC0+ICgnYTIsICdiMikgdCAtPiAoJ2ExICogJ2EyLCAnYjEgKiAnYjIpIHRcblxuICAoKiogW0lkXSBwcm92aWRlcyBpZGVudGlmaWVycyBmb3IgdHlwZXMsIGFuZCB0aGUgYWJpbGl0eSB0byB0ZXN0ICh2aWEgW0lkLnNhbWVdKSBhdFxuICAgICAgcnVudGltZSBpZiB0d28gaWRlbnRpZmllcnMgYXJlIGVxdWFsLCBhbmQgaWYgc28gdG8gZ2V0IGEgcHJvb2Ygb2YgZXF1YWxpdHkgb2YgdGhlaXJcbiAgICAgIHR5cGVzLiAgVW5saWtlIHZhbHVlcyBvZiB0eXBlIFtUeXBlX2VxdWFsLnRdLCB2YWx1ZXMgb2YgdHlwZSBbSWQudF0gZG8gaGF2ZSBzZW1hbnRpY1xuICAgICAgY29udGVudCBhbmQgbXVzdCBoYXZlIGEgbm9udHJpdmlhbCBydW50aW1lIHJlcHJlc2VudGF0aW9uLiAqKVxuICBtb2R1bGUgSWQgOiBzaWdcbiAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2YgVHlwZV9lcXVhbF9pZF9kZWZucyAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuICAgIGVuZClcblxuICAgICgqKiBFdmVyeSBbSWQudF0gY29udGFpbnMgYSB1bmlxdWUgaWQgdGhhdCBpcyBkaXN0aW5jdCBmcm9tIHRoZSBbVWlkLnRdIGluIGFueSBvdGhlclxuICAgICAgICBbSWQudF0uICopXG4gICAgbW9kdWxlIFVpZCA6IHNpZ1xuICAgICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwX29mXVxuXG4gICAgICBpbmNsdWRlIFBweF9oYXNoX2xpYi5IYXNoYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICAgIFtAQEBlbmRdXG5cbiAgICAgIGluY2x1ZGUgQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgICBlbmRcblxuICAgIHZhbCB1aWQgOiBfIHQgLT4gVWlkLnRcblxuICAgICgqKiBbY3JlYXRlIH5uYW1lXSBkZWZpbmVzIGEgbmV3IHR5cGUgaWRlbnRpdHkuIFR3byBjYWxscyB0byBbY3JlYXRlXSB3aWxsIHJlc3VsdCBpblxuICAgICAgICB0d28gZGlzdGluY3QgaWRlbnRpZmllcnMsIGV2ZW4gZm9yIHRoZSBzYW1lIGFyZ3VtZW50cyB3aXRoIHRoZSBzYW1lIHR5cGUuIElmIHRoZVxuICAgICAgICB0eXBlIFsnYV0gZG9lc24ndCBzdXBwb3J0IHNleHAgY29udmVyc2lvbiwgdGhlbiBhIGdvb2QgcHJhY3RpY2UgaXMgdG8gaGF2ZSB0aGVcbiAgICAgICAgY29udmVydGVyIGJlIFtbJXNleHBfb2Y6IF9dXSwgKG9yIFtzZXhwX29mX29wYXF1ZV0sIGlmIG5vdCB1c2luZyBwcHhfc2V4cF9jb252KS5cbiAgICAqKVxuICAgIHZhbCBjcmVhdGUgOiBuYW1lOnN0cmluZyAtPiAoJ2EgLT4gU2V4cC50KSAtPiAnYSB0XG5cbiAgICAoKiogQWNjZXNzb3JzICopXG5cbiAgICB2YWwgaGFzaCA6IF8gdCAtPiBpbnRcbiAgICB2YWwgbmFtZSA6IF8gdCAtPiBzdHJpbmdcbiAgICB2YWwgdG9fc2V4cCA6ICdhIHQgLT4gJ2EgLT4gU2V4cC50XG4gICAgdmFsIGhhc2hfZm9sZF90IDogSGFzaC5zdGF0ZSAtPiBfIHQgLT4gSGFzaC5zdGF0ZVxuXG4gICAgKCoqIFtzYW1lX3dpdG5lc3MgdDEgdDJdIGFuZCBbc2FtZV93aXRuZXNzX2V4biB0MSB0Ml0gcmV0dXJuIGEgdHlwZSBlcXVhbGl0eSBwcm9vZiBpZmZcbiAgICAgICAgdGhlIHR3byBpZGVudGlmaWVycyBhcmUgdGhlIHNhbWUgKGkuZS4sIHBoeXNpY2FsbHkgZXF1YWwsIHJlc3VsdGluZyBmcm9tIHRoZSBzYW1lXG4gICAgICAgIGNhbGwgdG8gW2NyZWF0ZV0pLiAgVGhpcyBpcyBhIHVzZWZ1bCB3YXkgdG8gYWNoaWV2ZSBhIHNvcnQgb2YgZHluYW1pYyB0eXBpbmcuXG4gICAgICAgIFtzYW1lX3dpdG5lc3NdIGRvZXMgbm90IGFsbG9jYXRlIGEgW1NvbWVdIGV2ZXJ5IHRpbWUgaXQgaXMgY2FsbGVkLlxuXG4gICAgICAgIFtzYW1lIHQxIHQyID0gaXNfc29tZSAoc2FtZV93aXRuZXNzIHQxIHQyKV0uXG4gICAgKilcblxuICAgIHZhbCBzYW1lIDogXyB0IC0+IF8gdCAtPiBib29sXG4gICAgdmFsIHNhbWVfd2l0bmVzcyA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EsICdiKSBlcXVhbCBvcHRpb25cbiAgICB2YWwgc2FtZV93aXRuZXNzX2V4biA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EsICdiKSBlcXVhbFxuXG4gICAgbW9kdWxlIENyZWF0ZTAgKFQgOiBBcmcwKSA6IFMwIHdpdGggdHlwZSB0IDo9IFQudFxuICAgIG1vZHVsZSBDcmVhdGUxIChUIDogQXJnMSkgOiBTMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnRcbiAgICBtb2R1bGUgQ3JlYXRlMiAoVCA6IEFyZzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgVC50XG4gICAgbW9kdWxlIENyZWF0ZTMgKFQgOiBBcmczKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgVC50XG4gIGVuZFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2EsICdiKSB0ID0gVCA6ICgnYSwgJ2EpIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgOlxuICAgICAgJ2EgJ2IuXG4gICAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2EsICdiKSB0IC0+IFNleHBsaWIwLlNleHAudFxuICA9XG4gIGZ1biAodHlwZSBhX18wMDNfIGJfXzAwNF8pXG4gICAgOiAgKChhX18wMDNfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKGJfXzAwNF8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+IChhX18wMDNfLCBiX18wMDRfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgZnVuIF9vZl9hX18wMDFfIF9vZl9iX18wMDJfIFQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVFwiXG47O1xuXG5bQEBAZW5kXVxuXG50eXBlICgnYSwgJ2IpIGVxdWFsID0gKCdhLCAnYikgdFxuXG5pbmNsdWRlIFR5cGVfZXF1YWxfaW50Zi5UeXBlX2VxdWFsX2RlZm5zIChzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgZXF1YWxcbmVuZClcblxubGV0IHJlZmwgPSBUXG5sZXQgc3ltICh0eXBlIGEgYikgKFQgOiAoYSwgYikgdCkgOiAoYiwgYSkgdCA9IFRcbmxldCB0cmFucyAodHlwZSBhIGIgYykgKFQgOiAoYSwgYikgdCkgKFQgOiAoYiwgYykgdCkgOiAoYSwgYykgdCA9IFRcbmxldCBjb252ICh0eXBlIGEgYikgKFQgOiAoYSwgYikgdCkgKGEgOiBhKSA6IGIgPSBhXG5cbm1vZHVsZSBMaWZ0IChYIDogc2lnXG4gIHR5cGUgJ2EgdFxuZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IGxpZnQgKHR5cGUgYSBiKSAoVCA6IChhLCBiKSB0KSA6IChhIFgudCwgYiBYLnQpIHQgPSBUXG5lbmRcblxubW9kdWxlIExpZnQyIChYIDogc2lnXG4gIHR5cGUgKCdhMSwgJ2EyKSB0XG5lbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhMSBiMSBhMiBiMikgKFQgOiAoYTEsIGIxKSB0KSAoVCA6IChhMiwgYjIpIHQpXG4gICAgOiAoKGExLCBhMikgWC50LCAoYjEsIGIyKSBYLnQpIHRcbiAgICA9XG4gICAgVFxuICA7O1xuZW5kXG5cbm1vZHVsZSBMaWZ0MyAoWCA6IHNpZ1xuICB0eXBlICgnYTEsICdhMiwgJ2EzKSB0XG5lbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhMSBiMSBhMiBiMiBhMyBiMykgKFQgOiAoYTEsIGIxKSB0KSAoVCA6IChhMiwgYjIpIHQpIChUIDogKGEzLCBiMykgdClcbiAgICA6ICgoYTEsIGEyLCBhMykgWC50LCAoYjEsIGIyLCBiMykgWC50KSB0XG4gICAgPVxuICAgIFRcbiAgOztcbmVuZFxuXG5sZXQgZGV0dXBsZTIgKHR5cGUgYTEgYTIgYjEgYjIpIChUIDogKGExICogYTIsIGIxICogYjIpIHQpIDogKGExLCBiMSkgdCAqIChhMiwgYjIpIHQgPVxuICBULCBUXG47O1xuXG5sZXQgdHVwbGUyICh0eXBlIGExIGEyIGIxIGIyKSAoVCA6IChhMSwgYjEpIHQpIChUIDogKGEyLCBiMikgdCkgOiAoYTEgKiBhMiwgYjEgKiBiMikgdCA9IFRcblxubW9kdWxlIElkID0gc3RydWN0XG4gICgqIFtrZXldIGlzIGFuIGV4dGVuc2libGUgR0FEVCB1c2VkIHRvIG1pbnQsIGFuZCBwYXR0ZXJuIG1hdGNoIG9uLCB0eXBlIHdpdG5lc3Nlcy4gKilcbiAgdHlwZSBfIGtleSA9IC4uXG5cbiAgbW9kdWxlIFVpZCA9IHN0cnVjdFxuICAgICgqIEEgdW5pcXVlIGlkIGNvbnRhaW5zIGFuIFtpbnRdIHJlcHJlc2VudGluZyBhIChwb3NzaWJseSBwYXJhbWV0ZXJpemVkKSB0eXBlLCBhbmQgYVxuICAgICAgIGxpc3Qgb2YgdWlkcyBmb3IgdGhlIHBhcmFtZXRlcnMgdG8gdGhhdCB0eXBlLiAqKVxuICAgIHR5cGUgdCA9IFQgb2YgaW50ICogdCBsaXN0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwX29mXVxuXG4gICAgbGV0IHJlYyBjb21wYXJlID1cbiAgICAgIChmdW4gYV9fMDA1XyBiX18wMDZfIC0+XG4gICAgICAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzAwNV8gYl9fMDA2X1xuICAgICAgICAgdGhlbiAwXG4gICAgICAgICBlbHNlIChcbiAgICAgICAgICAgbWF0Y2ggYV9fMDA1XywgYl9fMDA2XyB3aXRoXG4gICAgICAgICAgIHwgVCAoX2FfXzAwN18sIF9hX18wMDlfKSwgVCAoX2JfXzAwOF8sIF9iX18wMTBfKSAtPlxuICAgICAgICAgICAgIChtYXRjaCBjb21wYXJlX2ludCBfYV9fMDA3XyBfYl9fMDA4XyB3aXRoXG4gICAgICAgICAgICAgIHwgMCAtPiBjb21wYXJlX2xpc3QgY29tcGFyZSBfYV9fMDA5XyBfYl9fMDEwX1xuICAgICAgICAgICAgICB8IG4gLT4gbikpXG4gICAgICAgIDogdCAtPiB0IC0+IGludClcbiAgICA7O1xuXG4gICAgbGV0IHJlYyAoaGFzaF9mb2xkX3QgOlxuICAgICAgICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgICA9XG4gICAgICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgICAgICB8IFQgKF9hMCwgX2ExKSAtPlxuICAgICAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgICAgIGxldCBoc3YgPVxuICAgICAgICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgICAgICBoYXNoX2ZvbGRfaW50IGhzdiBfYTBcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgaGFzaF9mb2xkX2xpc3QgaGFzaF9mb2xkX3QgaHN2IF9hMVxuICAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jIGFyZyA9XG4gICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICAgICAgaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBsZXQgcmVjIHNleHBfb2ZfdCA9XG4gICAgICAoZnVuIChUIChhcmcwX18wMTNfLCBhcmcxX18wMTRfKSkgLT5cbiAgICAgICAgIGxldCByZXMwX18wMTVfID0gc2V4cF9vZl9pbnQgYXJnMF9fMDEzX1xuICAgICAgICAgYW5kIHJlczFfXzAxNl8gPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl90IGFyZzFfXzAxNF8gaW5cbiAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlRcIjsgcmVzMF9fMDE1XzsgcmVzMV9fMDE2XyBdXG4gICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIENvbXBhcmFibGUuTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBsZXQgY29tcGFyZSA9IGNvbXBhcmVcbiAgICAgIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbiAgICBlbmQpXG5cbiAgICAoKiBXZSB1c2UgdGhlIGV4dGVuc2lvbiBjb25zdHJ1Y3RvciBpZCBmb3IgYSBba2V5XSBhcyB0aGUgdW5pcXVlIGlkIGZvciBpdHMgdHlwZS4gKilcbiAgICBsZXQgY3JlYXRlIChrZXkgOiBfIGtleSkgYXJncyA9XG4gICAgICBsZXQgdGFnID1cbiAgICAgICAgU3RkbGliLk9iai5FeHRlbnNpb25fY29uc3RydWN0b3IuaWQgKFN0ZGxpYi5PYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbCBrZXkpXG4gICAgICBpblxuICAgICAgVCAodGFnLCBhcmdzKVxuICAgIDs7XG4gIGVuZFxuXG4gICgqIEV2ZXJ5IHR5cGUtZXF1YWwgaWQgbXVzdCBzdXBwb3J0IHRoZXNlIG9wZXJhdGlvbnMuICopXG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgICgqIEhvdyB0byByZW5kZXIgdmFsdWVzIG9mIHRoZSB0eXBlLiAqKVxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHAudFxuXG4gICAgKCogQSB1bmlxdWUgaWQgZm9yIHRoaXMgdHlwZS4gKilcbiAgICB2YWwgdWlkIDogVWlkLnRcblxuICAgICgqIE5hbWUgb2YgdGhlIHR5cGUtZXF1YWwgaWQuICopXG4gICAgdmFsIGlkX25hbWUgOiBzdHJpbmdcblxuICAgICgqIFNleHAgb2YgdGhlIHR5cGUtZXF1YWwgaWQuICopXG4gICAgdmFsIGlkX3NleHAgOiBTZXhwLnRcblxuICAgICgqIFtrZXldIHZhbHVlIGZvciB0aGUgdHlwZS4gKilcbiAgICB2YWwgdHlwZV9rZXkgOiB0IGtleVxuXG4gICAgKCogdHlwZSBlcXVhbGl0eTogZ2l2ZW4gYW5vdGhlciBrZXksIHByb2R1Y2UgYW4gW2VxdWFsXSBpZiB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZVxuICAgICAgIHR5cGUgaW5zdGFuY2UgKilcbiAgICB2YWwgdHlwZV9lcXVhbCA6ICdhIGtleSAtPiAodCwgJ2EpIGVxdWFsIG9wdGlvblxuICBlbmRcblxuICAoKiBBbiBbSWQudF0gaXMgYSBmaXJzdC1jbGFzcyBtb2R1bGUgaW1wbGVtZW50aW5nIHRoZSBhYm92ZSBvcGVyYXRpb25zLiAqKVxuICB0eXBlICdhIHQgPSAobW9kdWxlIFMgd2l0aCB0eXBlIHQgPSAnYSlcblxuICBsZXQgdWlkICh0eXBlIGEpICgobW9kdWxlIEEpIDogYSB0KSA9IEEudWlkXG4gIGxldCBuYW1lICh0eXBlIGEpICgobW9kdWxlIEEpIDogYSB0KSA9IEEuaWRfbmFtZVxuICBsZXQgc2V4cF9vZl90ICh0eXBlIGEpIF8gKChtb2R1bGUgQSkgOiBhIHQpID0gQS5pZF9zZXhwXG4gIGxldCB0b19zZXhwICh0eXBlIGEpICgobW9kdWxlIEEpIDogYSB0KSA9IEEuc2V4cF9vZl90XG4gIGxldCBoYXNoIHQgPSBVaWQuaGFzaCAodWlkIHQpXG4gIGxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gVWlkLmhhc2hfZm9sZF90IHN0YXRlICh1aWQgdClcblxuICBsZXQgc2FtZV93aXRuZXNzICh0eXBlIGEgYikgKChtb2R1bGUgQSkgOiBhIHQpICgobW9kdWxlIEIpIDogYiB0KSA9XG4gICAgQS50eXBlX2VxdWFsIEIudHlwZV9rZXlcbiAgOztcblxuICBsZXQgc2FtZV93aXRuZXNzX2V4biB0MSB0MiA9XG4gICAgbWF0Y2ggc2FtZV93aXRuZXNzIHQxIHQyIHdpdGhcbiAgICB8IFNvbWUgZXF1YWwgLT4gZXF1YWxcbiAgICB8IE5vbmUgLT5cbiAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIlR5cGVfZXF1YWwuSWQuc2FtZV93aXRuZXNzX2V4biBnb3QgZGlmZmVyZW50IGlkc1wiXG4gICAgICAgICAgIFsgKCBcIlwiXG4gICAgICAgICAgICAgLCBzZXhwX29mX3BhaXIgKHNleHBfb2ZfdCBzZXhwX29mX29wYXF1ZSkgKHNleHBfb2ZfdCBzZXhwX29mX29wYXF1ZSkgKHQxLCB0MilcbiAgICAgICAgICAgICApXG4gICAgICAgICAgIF0pXG4gIDs7XG5cbiAgbGV0IHNhbWUgdDEgdDIgPVxuICAgIG1hdGNoIHNhbWVfd2l0bmVzcyB0MSB0MiB3aXRoXG4gICAgfCBTb21lIF8gLT4gdHJ1ZVxuICAgIHwgTm9uZSAtPiBmYWxzZVxuICA7O1xuXG4gIGluY2x1ZGUgVHlwZV9lcXVhbF9pbnRmLlR5cGVfZXF1YWxfaWRfZGVmbnMgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG4gIGVuZClcblxuICBtb2R1bGUgQ3JlYXRlMCAoVCA6IEFyZzApID0gc3RydWN0XG4gICAgdHlwZSBfIGtleSArPSBUMCA6IFQudCBrZXlcblxuICAgIGxldCB0eXBlX2VxdWFsX2lkIDogVC50IHQgPVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gVC50XG5cbiAgICAgICAgbGV0IGlkX25hbWUgPSBULm5hbWVcbiAgICAgICAgbGV0IGlkX3NleHAgPSBTZXhwLkF0b20gaWRfbmFtZVxuICAgICAgICBsZXQgc2V4cF9vZl90ID0gVC5zZXhwX29mX3RcbiAgICAgICAgbGV0IHR5cGVfa2V5ID0gVDBcbiAgICAgICAgbGV0IHVpZCA9IFVpZC5jcmVhdGUgdHlwZV9rZXkgW11cblxuICAgICAgICBsZXQgdHlwZV9lcXVhbCAodHlwZSBvdGhlcikgKG90aGVya2V5IDogb3RoZXIga2V5KSA6ICh0LCBvdGhlcikgZXF1YWwgb3B0aW9uID1cbiAgICAgICAgICBtYXRjaCBvdGhlcmtleSB3aXRoXG4gICAgICAgICAgfCBUMCAtPiBTb21lIFRcbiAgICAgICAgICB8IF8gLT4gTm9uZVxuICAgICAgICA7O1xuICAgICAgZW5kKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBDcmVhdGUxIChUIDogQXJnMSkgPSBzdHJ1Y3RcbiAgICB0eXBlIF8ga2V5ICs9IFQxIDogJ2Ega2V5IC0+ICdhIFQudCBrZXlcblxuICAgIGxldCB0eXBlX2VxdWFsX2lkICh0eXBlIGEpICgobW9kdWxlIEEpIDogYSB0KSA6IGEgVC50IHQgPVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gQS50IFQudFxuXG4gICAgICAgIGxldCBpZF9uYW1lID0gVC5uYW1lXG4gICAgICAgIGxldCBpZF9zZXhwID0gU2V4cC5MaXN0IFsgQXRvbSBpZF9uYW1lOyBBLmlkX3NleHAgXVxuICAgICAgICBsZXQgc2V4cF9vZl90IHQgPSBULnNleHBfb2ZfdCBBLnNleHBfb2ZfdCB0XG4gICAgICAgIGxldCB0eXBlX2tleSA9IFQxIEEudHlwZV9rZXlcbiAgICAgICAgbGV0IHVpZCA9IFVpZC5jcmVhdGUgdHlwZV9rZXkgWyBBLnVpZCBdXG5cbiAgICAgICAgbGV0IHR5cGVfZXF1YWwgKHR5cGUgb3RoZXIpIChvdGhlcmtleSA6IG90aGVyIGtleSkgOiAodCwgb3RoZXIpIGVxdWFsIG9wdGlvbiA9XG4gICAgICAgICAgbWF0Y2ggb3RoZXJrZXkgd2l0aFxuICAgICAgICAgIHwgVDEgYWtleSAtPlxuICAgICAgICAgICAgKG1hdGNoIEEudHlwZV9lcXVhbCBha2V5IHdpdGhcbiAgICAgICAgICAgICB8IFNvbWUgVCAtPiBTb21lIFRcbiAgICAgICAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICAgICAgICB8IF8gLT4gTm9uZVxuICAgICAgICA7O1xuICAgICAgZW5kKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBDcmVhdGUyIChUIDogQXJnMikgPSBzdHJ1Y3RcbiAgICB0eXBlIF8ga2V5ICs9IFQyIDogJ2Ega2V5ICogJ2Iga2V5IC0+ICgnYSwgJ2IpIFQudCBrZXlcblxuICAgIGxldCB0eXBlX2VxdWFsX2lkICh0eXBlIGEgYikgKChtb2R1bGUgQSkgOiBhIHQpICgobW9kdWxlIEIpIDogYiB0KSA6IChhLCBiKSBULnQgdCA9XG4gICAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSAoQS50LCBCLnQpIFQudFxuXG4gICAgICAgIGxldCBpZF9uYW1lID0gVC5uYW1lXG4gICAgICAgIGxldCBpZF9zZXhwID0gU2V4cC5MaXN0IFsgQXRvbSBpZF9uYW1lOyBBLmlkX3NleHA7IEIuaWRfc2V4cCBdXG4gICAgICAgIGxldCBzZXhwX29mX3QgdCA9IFQuc2V4cF9vZl90IEEuc2V4cF9vZl90IEIuc2V4cF9vZl90IHRcbiAgICAgICAgbGV0IHR5cGVfa2V5ID0gVDIgKEEudHlwZV9rZXksIEIudHlwZV9rZXkpXG4gICAgICAgIGxldCB1aWQgPSBVaWQuY3JlYXRlIHR5cGVfa2V5IFsgQS51aWQ7IEIudWlkIF1cblxuICAgICAgICBsZXQgdHlwZV9lcXVhbCAodHlwZSBvdGhlcikgKG90aGVya2V5IDogb3RoZXIga2V5KSA6ICh0LCBvdGhlcikgZXF1YWwgb3B0aW9uID1cbiAgICAgICAgICBtYXRjaCBvdGhlcmtleSB3aXRoXG4gICAgICAgICAgfCBUMiAoYWtleSwgYmtleSkgLT5cbiAgICAgICAgICAgIChtYXRjaCBBLnR5cGVfZXF1YWwgYWtleSwgQi50eXBlX2VxdWFsIGJrZXkgd2l0aFxuICAgICAgICAgICAgIHwgU29tZSBULCBTb21lIFQgLT4gU29tZSBUXG4gICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBOb25lKVxuICAgICAgICAgIHwgXyAtPiBOb25lXG4gICAgICAgIDs7XG4gICAgICBlbmQpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIENyZWF0ZTMgKFQgOiBBcmczKSA9IHN0cnVjdFxuICAgIHR5cGUgXyBrZXkgKz0gVDMgOiAnYSBrZXkgKiAnYiBrZXkgKiAnYyBrZXkgLT4gKCdhLCAnYiwgJ2MpIFQudCBrZXlcblxuICAgIGxldCB0eXBlX2VxdWFsX2lkXG4gICAgICAodHlwZSBhIGIgYylcbiAgICAgICgobW9kdWxlIEEpIDogYSB0KVxuICAgICAgKChtb2R1bGUgQikgOiBiIHQpXG4gICAgICAoKG1vZHVsZSBDKSA6IGMgdClcbiAgICAgIDogKGEsIGIsIGMpIFQudCB0XG4gICAgICA9XG4gICAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSAoQS50LCBCLnQsIEMudCkgVC50XG5cbiAgICAgICAgbGV0IGlkX25hbWUgPSBULm5hbWVcbiAgICAgICAgbGV0IGlkX3NleHAgPSBTZXhwLkxpc3QgWyBBdG9tIGlkX25hbWU7IEEuaWRfc2V4cDsgQi5pZF9zZXhwOyBDLmlkX3NleHAgXVxuICAgICAgICBsZXQgc2V4cF9vZl90IHQgPSBULnNleHBfb2ZfdCBBLnNleHBfb2ZfdCBCLnNleHBfb2ZfdCBDLnNleHBfb2ZfdCB0XG4gICAgICAgIGxldCB0eXBlX2tleSA9IFQzIChBLnR5cGVfa2V5LCBCLnR5cGVfa2V5LCBDLnR5cGVfa2V5KVxuICAgICAgICBsZXQgdWlkID0gVWlkLmNyZWF0ZSB0eXBlX2tleSBbIEEudWlkOyBCLnVpZDsgQy51aWQgXVxuXG4gICAgICAgIGxldCB0eXBlX2VxdWFsICh0eXBlIG90aGVyKSAob3RoZXJrZXkgOiBvdGhlciBrZXkpIDogKHQsIG90aGVyKSBlcXVhbCBvcHRpb24gPVxuICAgICAgICAgIG1hdGNoIG90aGVya2V5IHdpdGhcbiAgICAgICAgICB8IFQzIChha2V5LCBia2V5LCBja2V5KSAtPlxuICAgICAgICAgICAgKG1hdGNoIEEudHlwZV9lcXVhbCBha2V5LCBCLnR5cGVfZXF1YWwgYmtleSwgQy50eXBlX2VxdWFsIGNrZXkgd2l0aFxuICAgICAgICAgICAgIHwgU29tZSBULCBTb21lIFQsIFNvbWUgVCAtPiBTb21lIFRcbiAgICAgICAgICAgICB8IE5vbmUsIF8sIF8gfCBfLCBOb25lLCBfIHwgXywgXywgTm9uZSAtPiBOb25lKVxuICAgICAgICAgIHwgXyAtPiBOb25lXG4gICAgICAgIDs7XG4gICAgICBlbmQpXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IGNyZWF0ZSAodHlwZSBhKSB+bmFtZSBzZXhwX29mX3QgPVxuICAgIGxldCBtb2R1bGUgVCA9XG4gICAgICBDcmVhdGUwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gYVxuXG4gICAgICAgIGxldCBuYW1lID0gbmFtZVxuICAgICAgICBsZXQgc2V4cF9vZl90ID0gc2V4cF9vZl90XG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBULnR5cGVfZXF1YWxfaWRcbiAgOztcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbigqKiBbJ2EgQ2hlYXBfb3B0aW9uLnRdIGlzIGxpa2UgWydhIG9wdGlvbl0sIGJ1dCBpdCBkb2Vzbid0IGJveCBbc29tZSBfXSB2YWx1ZXMuXG5cbiAgICBUaGVyZSBhcmUgc2V2ZXJhbCB0aGluZ3MgdGhhdCBhcmUgdW5zYWZlIGFib3V0IGl0OlxuXG4gICAgLSBbZmxvYXQgdCBhcnJheV0gKG9yIGFueSBhcnJheS1iYWNrZWQgY29udGFpbmVyKSBpcyBub3QgbWVtb3J5LXNhZmVcbiAgICAgIGJlY2F1c2UgZmxvYXQgYXJyYXkgb3B0aW1pemF0aW9uIGlzIGluY29tcGF0aWJsZSB3aXRoIHVuYm94ZWQgb3B0aW9uXG4gICAgICBvcHRpbWl6YXRpb24uIFlvdSBoYXZlIHRvIHVzZSBbVW5pZm9ybV9hcnJheS50XSBpbnN0ZWFkIG9mIFthcnJheV0uXG5cbiAgICAtIE5lc3RlZCBvcHRpb25zIChbJ2EgdCB0XSkgZG9uJ3Qgd29yay4gVGhleSBhcmUgYmVsaWV2ZWQgdG8gYmVcbiAgICAgIG1lbW9yeS1zYWZlLCBidXQgbm90IHBhcmFtZXRyaWMuXG5cbiAgICAtIEEgcmVjb3JkIHdpdGggW2Zsb2F0IHRdcyBpbiBpdCBzaG91bGQgYmUgc2FmZSwgYnV0IGl0J3Mgb25seSBbdF0gYmVpbmdcbiAgICAgIGFic3RyYWN0IHRoYXQgZ2l2ZXMgeW91IHNhZmV0eS4gSWYgdGhlIGNvbXBpbGVyIHdhcyBzbWFydCBlbm91Z2ggdG8gcGVla1xuICAgICAgdGhyb3VnaCB0aGUgbW9kdWxlIHNpZ25hdHVyZSB0aGVuIGl0IGNvdWxkIGRlY2lkZSB0byBjb25zdHJ1Y3QgYSBmbG9hdFxuICAgICAgYXJyYXkgaW5zdGVhZC4gKilcbm1vZHVsZSBDaGVhcF9vcHRpb24gPSBzdHJ1Y3RcbiAgKCogVGhpcyBpcyB0YWtlbiBmcm9tIGNvcmUuIFJhdGhlciB0aGFuIGV4cG9zZSBpdCBpbiB0aGUgcHVibGljIGludGVyZmFjZSBvZiBiYXNlLCBqdXN0XG4gICAgIGtlZXAgYSBjb3B5IGFyb3VuZCBoZXJlLiAqKVxuICBsZXQgcGh5c19zYW1lICh0eXBlIGEgYikgKGEgOiBhKSAoYiA6IGIpID0gcGh5c19lcXVhbCBhIChTdGRsaWIuT2JqLm1hZ2ljIGIgOiBhKVxuXG4gIG1vZHVsZSBUMCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIG5vbmUgOiBfIHRcbiAgICB2YWwgc29tZSA6ICdhIC0+ICdhIHRcbiAgICB2YWwgaXNfbm9uZSA6IF8gdCAtPiBib29sXG4gICAgdmFsIGlzX3NvbWUgOiBfIHQgLT4gYm9vbFxuICAgIHZhbCB2YWx1ZV9leG4gOiAnYSB0IC0+ICdhXG4gICAgdmFsIHZhbHVlX3Vuc2FmZSA6ICdhIHQgLT4gJ2FcbiAgICB2YWwgaXRlcl9zb21lIDogJ2EgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgKydhIHRcblxuICAgICgqIEJlaW5nIGEgcG9pbnRlciwgbm8gb25lIG91dHNpZGUgdGhpcyBtb2R1bGUgY2FuIGNvbnN0cnVjdCBhIHZhbHVlIHRoYXQgaXNcbiAgICAgICBbcGh5c19zYW1lXSBhcyB0aGlzIG9uZS5cblxuICAgICAgIEl0IHdvdWxkIGJlIHNpbXBsZXIgdG8gdXNlIHRoaXMgdmFsdWUgYXMgW25vbmVdLCBidXQgd2UgdXNlIGFuIGltbWVkaWF0ZSBpbnN0ZWFkXG4gICAgICAgYmVjYXVzZSBpdCBsZXRzIHVzIGF2b2lkIGNhbWxfbW9kaWZ5IHdoZW4gc2V0dGluZyB0byBbbm9uZV0sIG1ha2luZyBjZXJ0YWluXG4gICAgICAgYmVuY2htYXJrcyBzaWduaWZpY2FudGx5IGZhc3RlciAoZS5nLiAuLi9iZW5jaC9hcnJheV9xdWV1ZS5leGUpLlxuXG4gICAgICAgdGhpcyBjb2RlIGlzIGR1cGxpY2F0ZWQgaW4gTW9wdGlvbiwgYW5kIGlmIHdlIGZpbmQgeWV0IGFub3RoZXIgcGxhY2Ugd2hlcmUgd2Ugd2FudFxuICAgICAgIGl0IHdlIHNob3VsZCByZWNvbnNpZGVyIG1ha2luZyBpdCBzaGFyZWQuICopXG4gICAgbGV0IG5vbmVfc3Vic3RpdHV0ZSA6IF8gdCA9XG4gICAgICBTdGRsaWIuT2JqLm9iaiAoU3RkbGliLk9iai5uZXdfYmxvY2sgU3RkbGliLk9iai5hYnN0cmFjdF90YWcgMSlcbiAgICA7O1xuXG4gICAgbGV0IG5vbmUgOiBfIHQgPVxuICAgICAgKCogVGhlIG51bWJlciB3YXMgcHJvZHVjZWQgYnlcbiAgICAgICAgIFs8IC9kZXYvdXJhbmRvbSB0ciAtYyAtZCAnMTIzNDU2Nzg5MGFiY2RlZicgfCBoZWFkIC1jIDE2XS5cblxuICAgICAgICAgVGhlIGlkZWEgaXMgdGhhdCBhIHJhbmRvbSBudW1iZXIgd2lsbCBoYXZlIGxvd2VyIHByb2JhYmlsaXR5IHRvIGNvbGxpZGUgd2l0aFxuICAgICAgICAgYW55dGhpbmcgdGhhbiBhbnkgbnVtYmVyIHdlIGNhbiBjaG9vc2Ugb3Vyc2VsdmVzLlxuXG4gICAgICAgICBXZSBhcmUgdXNpbmcgYSBwb2x5bW9ycGhpYyB2YXJpYW50IGluc3RlYWQgb2YgYW4gaW50ZWdlciBjb25zdGFudCBiZWNhdXNlIHRoZXJlXG4gICAgICAgICBpcyBhIGNvbXBpbGVyIGJ1ZyB3aGVyZSBpdCB3cm9uZ2x5IGFzc3VtZXMgdGhhdCB0aGUgcmVzdWx0IG9mIFtpZiBfIHRoZW4gYyBlbHNlXG4gICAgICAgICB5XSBpcyBub3QgYSBwb2ludGVyIGlmIFtjXSBpcyBhbiBpbnRlZ2VyIGNvbXBpbGUtdGltZSBjb25zdGFudC4gIFRoaXMgaXMgYmVpbmdcbiAgICAgICAgIGZpeGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9vY2FtbC9wdWxsLzU1NS4gIFRoZSBcIm1lbW9yeSBjb3JydXB0aW9uXCIgdGVzdFxuICAgICAgICAgYmVsb3cgZGVtb25zdHJhdGVzIHRoZSBpc3N1ZS4gICopXG4gICAgICBTdGRsaWIuT2JqLm1hZ2ljIGB4NmU4ZWUzNDc4ZTFkNzQ0OVxuICAgIDs7XG5cbiAgICBsZXQgaXNfbm9uZSB4ID0gcGh5c19lcXVhbCB4IG5vbmVcbiAgICBsZXQgaXNfc29tZSB4ID0gbm90IChwaHlzX2VxdWFsIHggbm9uZSlcblxuICAgIGxldCBzb21lICh0eXBlIGEpICh4IDogYSkgOiBhIHQgPVxuICAgICAgaWYgcGh5c19zYW1lIHggbm9uZSB0aGVuIG5vbmVfc3Vic3RpdHV0ZSBlbHNlIFN0ZGxpYi5PYmoubWFnaWMgeFxuICAgIDs7XG5cbiAgICBsZXQgdmFsdWVfdW5zYWZlICh0eXBlIGEpICh4IDogYSB0KSA6IGEgPVxuICAgICAgaWYgcGh5c19lcXVhbCB4IG5vbmVfc3Vic3RpdHV0ZSB0aGVuIFN0ZGxpYi5PYmoubWFnaWMgbm9uZSBlbHNlIFN0ZGxpYi5PYmoubWFnaWMgeFxuICAgIDs7XG5cbiAgICBsZXQgdmFsdWVfZXhuIHggPVxuICAgICAgaWYgaXNfc29tZSB4XG4gICAgICB0aGVuIHZhbHVlX3Vuc2FmZSB4XG4gICAgICBlbHNlIGZhaWx3aXRoIFwiT3B0aW9uX2FycmF5LmdldF9zb21lX2V4bjogdGhlIGVsZW1lbnQgaXMgW05vbmVdXCJcbiAgICA7O1xuXG4gICAgbGV0IGl0ZXJfc29tZSB0IH5mID0gaWYgaXNfc29tZSB0IHRoZW4gZiAodmFsdWVfdW5zYWZlIHQpXG4gIGVuZFxuXG4gIG1vZHVsZSBUMSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVDBcblxuICAgIGxldCBvZl9vcHRpb24gPSBmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IG5vbmVcbiAgICAgIHwgU29tZSB4IC0+IHNvbWUgeFxuICAgIDs7XG5cbiAgICBsZXRbQGlubGluZV0gdG9fb3B0aW9uIHggPSBpZiBpc19zb21lIHggdGhlbiBTb21lICh2YWx1ZV91bnNhZmUgeCkgZWxzZSBOb25lXG4gICAgbGV0W0BpbmxpbmVdIHRvX29wdGlvbl9sb2NhbCB4ID0gaWYgaXNfc29tZSB4IHRoZW4gU29tZSAodmFsdWVfdW5zYWZlIHgpIGVsc2UgTm9uZVxuICAgIGxldCB0b19zZXhwYWJsZSA9IHRvX29wdGlvblxuICAgIGxldCBvZl9zZXhwYWJsZSA9IG9mX29wdGlvblxuXG4gICAgbGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGEpIChncmFtbWFyIDogYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICAgIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICA9XG4gICAgICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChPcHRpb24udF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbiAgICA7O1xuICBlbmRcblxuICBpbmNsdWRlIFQxXG4gIGluY2x1ZGUgU2V4cGFibGUuT2Zfc2V4cGFibGUxIChPcHRpb24pIChUMSlcbmVuZFxuXG50eXBlICdhIHQgPSAnYSBDaGVhcF9vcHRpb24udCBVbmlmb3JtX2FycmF5LnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gIGZ1biBfb2ZfYV9fMDAxXyB4X18wMDNfIC0+XG4gIFVuaWZvcm1fYXJyYXkudF9vZl9zZXhwIChDaGVhcF9vcHRpb24udF9vZl9zZXhwIF9vZl9hX18wMDFfKSB4X18wMDNfXG47O1xuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuIF9vZl9hX18wMDRfIHhfXzAwNV8gLT5cbiAgVW5pZm9ybV9hcnJheS5zZXhwX29mX3QgKENoZWFwX29wdGlvbi5zZXhwX29mX3QgX29mX2FfXzAwNF8pIHhfXzAwNV9cbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hciA6ICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT5cbiAgVW5pZm9ybV9hcnJheS50X3NleHBfZ3JhbW1hciAoQ2hlYXBfb3B0aW9uLnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXIpXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgZW1wdHkgPSBVbmlmb3JtX2FycmF5LmVtcHR5XG5sZXQgY3JlYXRlIH5sZW4gPSBVbmlmb3JtX2FycmF5LmNyZWF0ZSB+bGVuIENoZWFwX29wdGlvbi5ub25lXG5sZXQgaW5pdCBuIH5mID0gVW5pZm9ybV9hcnJheS5pbml0IG4gfmY6KGZ1biBpIC0+IENoZWFwX29wdGlvbi5vZl9vcHRpb24gKGYgaSkpIFtAbm9udGFpbF1cbmxldCBpbml0X3NvbWUgbiB+ZiA9IFVuaWZvcm1fYXJyYXkuaW5pdCBuIH5mOihmdW4gaSAtPiBDaGVhcF9vcHRpb24uc29tZSAoZiBpKSkgW0Bub250YWlsXVxubGV0IGxlbmd0aCA9IFVuaWZvcm1fYXJyYXkubGVuZ3RoXG5sZXRbQGlubGluZV0gZ2V0IHQgaSA9IENoZWFwX29wdGlvbi50b19vcHRpb24gKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldFtAaW5saW5lXSBnZXRfbG9jYWwgdCBpID0gQ2hlYXBfb3B0aW9uLnRvX29wdGlvbl9sb2NhbCAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IGdldF9zb21lX2V4biB0IGkgPSBDaGVhcF9vcHRpb24udmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCB0IGkpXG5sZXQgaXNfbm9uZSB0IGkgPSBDaGVhcF9vcHRpb24uaXNfbm9uZSAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IGlzX3NvbWUgdCBpID0gQ2hlYXBfb3B0aW9uLmlzX3NvbWUgKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBzZXQgdCBpIHggPSBVbmlmb3JtX2FycmF5LnNldCB0IGkgKENoZWFwX29wdGlvbi5vZl9vcHRpb24geClcbmxldCBzZXRfc29tZSB0IGkgeCA9IFVuaWZvcm1fYXJyYXkuc2V0IHQgaSAoQ2hlYXBfb3B0aW9uLnNvbWUgeClcbmxldCBzZXRfbm9uZSB0IGkgPSBVbmlmb3JtX2FycmF5LnNldCB0IGkgQ2hlYXBfb3B0aW9uLm5vbmVcbmxldCBzd2FwIHQgaSBqID0gVW5pZm9ybV9hcnJheS5zd2FwIHQgaSBqXG5sZXQgdW5zYWZlX2dldCB0IGkgPSBDaGVhcF9vcHRpb24udG9fb3B0aW9uIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxubGV0IHVuc2FmZV9nZXRfc29tZV9leG4gdCBpID0gQ2hlYXBfb3B0aW9uLnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgaSlcblxubGV0IHVuc2FmZV9nZXRfc29tZV9hc3N1bWluZ19zb21lIHQgaSA9XG4gIENoZWFwX29wdGlvbi52YWx1ZV91bnNhZmUgKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG47O1xuXG5sZXQgdW5zYWZlX2lzX3NvbWUgdCBpID0gQ2hlYXBfb3B0aW9uLmlzX3NvbWUgKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG5sZXQgdW5zYWZlX3NldCB0IGkgeCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IGkgKENoZWFwX29wdGlvbi5vZl9vcHRpb24geClcbmxldCB1bnNhZmVfc2V0X3NvbWUgdCBpIHggPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCBpIChDaGVhcF9vcHRpb24uc29tZSB4KVxubGV0IHVuc2FmZV9zZXRfbm9uZSB0IGkgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCBpIENoZWFwX29wdGlvbi5ub25lXG5cbmxldCBjbGVhciB0ID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIHVuc2FmZV9zZXRfbm9uZSB0IGlcbiAgZG9uZVxuOztcblxubGV0IGl0ZXJpIGlucHV0IH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBpbnB1dCAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgaW5wdXQgaSlcbiAgZG9uZVxuOztcblxubGV0IGl0ZXIgaW5wdXQgfmYgPSBpdGVyaSBpbnB1dCB+ZjooZnVuIChfIDogaW50KSB4IC0+IGYgeCkgW0Bub250YWlsXVxuXG5sZXQgZm9sZGkgaW5wdXQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgaXRlcmkgaW5wdXQgfmY6KGZ1biBpIGVsZW0gLT4gYWNjIDo9IGYgaSAhYWNjIGVsZW0pO1xuICAhYWNjXG47O1xuXG5sZXQgZm9sZCBpbnB1dCB+aW5pdCB+ZiA9IGZvbGRpIGlucHV0IH5pbml0IH5mOihmdW4gKF8gOiBpbnQpIGFjYyB4IC0+IGYgYWNjIHgpIFtAbm9udGFpbF1cblxuaW5jbHVkZSBJbmRleGVkX2NvbnRhaW5lci5NYWtlX2dlbiAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnYSwgXywgXykgdCA9ICdhIHRcbiAgdHlwZSAnYSBlbHQgPSAnYSBvcHRpb25cblxuICBsZXQgZm9sZCA9IGZvbGRcbiAgbGV0IGZvbGRpID0gYEN1c3RvbSBmb2xkaVxuICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICBsZXQgaXRlcmkgPSBgQ3VzdG9tIGl0ZXJpXG4gIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuZW5kKVxuXG5sZXQgbGVuZ3RoID0gVW5pZm9ybV9hcnJheS5sZW5ndGhcblxubGV0IG1hcGkgaW5wdXQgfmYgPVxuICBsZXQgb3V0cHV0ID0gY3JlYXRlIH5sZW46KGxlbmd0aCBpbnB1dCkgaW5cbiAgaXRlcmkgaW5wdXQgfmY6KGZ1biBpIGVsZW0gLT4gdW5zYWZlX3NldCBvdXRwdXQgaSAoZiBpIGVsZW0pKTtcbiAgb3V0cHV0XG47O1xuXG5sZXQgbWFwIGlucHV0IH5mID0gbWFwaSBpbnB1dCB+ZjooZnVuIChfIDogaW50KSBlbGVtIC0+IGYgZWxlbSkgW0Bub250YWlsXVxuXG5sZXQgbWFwX3NvbWUgaW5wdXQgfmYgPVxuICBsZXQgbGVuID0gbGVuZ3RoIGlucHV0IGluXG4gIGxldCBvdXRwdXQgPSBjcmVhdGUgfmxlbiBpblxuICBsZXQgKCkgPVxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgb3B0ID0gVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IGlucHV0IGkgaW5cbiAgICAgIENoZWFwX29wdGlvbi5pdGVyX3NvbWUgb3B0IH5mOihmdW4geCAtPiB1bnNhZmVfc2V0X3NvbWUgb3V0cHV0IGkgKGYgeCkpXG4gICAgZG9uZVxuICBpblxuICBvdXRwdXRcbjs7XG5cbmxldCBvZl9hcnJheSBhcnJheSA9IGluaXQgKEFycmF5Lmxlbmd0aCBhcnJheSkgfmY6KGZ1biBpIC0+IEFycmF5LnVuc2FmZV9nZXQgYXJyYXkgaSlcblxubGV0IG9mX2FycmF5X3NvbWUgYXJyYXkgPVxuICBpbml0X3NvbWUgKEFycmF5Lmxlbmd0aCBhcnJheSkgfmY6KGZ1biBpIC0+IEFycmF5LnVuc2FmZV9nZXQgYXJyYXkgaSlcbjs7XG5cbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCAobGVuZ3RoIHQpIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcblxuaW5jbHVkZSBCbGl0Lk1ha2UxX2dlbmVyaWMgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gXyA9IGNyZWF0ZSB+bGVuXG4gIGxldCB1bnNhZmVfYmxpdCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX2JsaXRcbmVuZClcblxubGV0IGNvcHkgPSBVbmlmb3JtX2FycmF5LmNvcHlcblxubW9kdWxlIEZvcl90ZXN0aW5nID0gc3RydWN0XG4gIG1vZHVsZSBVbnNhZmVfY2hlYXBfb3B0aW9uID0gQ2hlYXBfb3B0aW9uXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTdGFja19pbnRmXG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4oKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHNpbWlsYXIgdG8gW0RlcXVlXSBpbiB0aGF0IGl0IHVzZXMgYW4gYXJyYXkgb2YgWydhXSBhbmRcbiAgIGEgbXV0YWJsZSBbaW50XSB0byBpbmRpY2F0ZSB3aGF0IGluIHRoZSBhcnJheSBpcyB1c2VkLiAgV2UgY2hvb3NlIHRvIGltcGxlbWVudCBbU3RhY2tdXG4gICBkaXJlY3RseSByYXRoZXIgdGhhbiBvbiB0b3Agb2YgW0RlcXVlXSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gIEUuZy4gYSBzaW1wbGVcbiAgIG1pY3JvYmVuY2htYXJrIHNob3dzIHRoYXQgcHVzaC9wb3AgaXMgYWJvdXQgMjAlIGZhc3Rlci4gKilcbnR5cGUgJ2EgdCA9XG4gIHsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgOyBtdXRhYmxlIGVsdHMgOiAnYSBPcHRpb25fYXJyYXkudFxuICB9XG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biBfb2ZfYV9fMDAxXyB7IGxlbmd0aCA9IGxlbmd0aF9fMDAzXzsgZWx0cyA9IGVsdHNfXzAwNV8gfSAtPlxuICBsZXQgYm5kc19fMDAyXyA9IChbXSA6IF8gU3RkbGliLkxpc3QudCkgaW5cbiAgbGV0IGJuZHNfXzAwMl8gPVxuICAgIGxldCBhcmdfXzAwNl8gPSBPcHRpb25fYXJyYXkuc2V4cF9vZl90IF9vZl9hX18wMDFfIGVsdHNfXzAwNV8gaW5cbiAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZWx0c1wiOyBhcmdfXzAwNl8gXSA6OiBibmRzX18wMDJfXG4gICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgaW5cbiAgbGV0IGJuZHNfXzAwMl8gPVxuICAgIGxldCBhcmdfXzAwNF8gPSBzZXhwX29mX2ludCBsZW5ndGhfXzAwM18gaW5cbiAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibGVuZ3RoXCI7IGFyZ19fMDA0XyBdIDo6IGJuZHNfXzAwMl9cbiAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICBpblxuICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDAyX1xuOztcblxuW0BAQGVuZF1cblxubGV0IHNleHBfb2ZfdF9pbnRlcm5hbCA9IHNleHBfb2ZfdFxubGV0IHNleHBfb2ZfdCA9IGBSZWJvdW5kX2xhdGVyXG5sZXQgXyA9IHNleHBfb2ZfdFxubGV0IGNhcGFjaXR5IHQgPSBPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0c1xuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hICh7IGxlbmd0aDsgZWx0cyB9IGFzIHQpIDogdW5pdCA9XG4gIHRyeVxuICAgIGFzc2VydCAoMCA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IE9wdGlvbl9hcnJheS5sZW5ndGggZWx0cyk7XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCAtIDEgZG9cbiAgICAgIGludmFyaWFudF9hIChPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIGVsdHMgaSlcbiAgICBkb25lO1xuICAgICgqIFdlIG1haW50YWluIHRoZSBpbnZhcmlhbnQgdGhhdCB1bnVzZWQgZWxlbWVudHMgYXJlIHVuc2V0IHRvIGF2b2lkIGEgc3BhY2VcbiAgICAgICBsZWFrLiAqKVxuICAgIGZvciBpID0gbGVuZ3RoIHRvIE9wdGlvbl9hcnJheS5sZW5ndGggZWx0cyAtIDEgZG9cbiAgICAgIGFzc2VydCAobm90IChPcHRpb25fYXJyYXkuaXNfc29tZSBlbHRzIGkpKVxuICAgIGRvbmVcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiU3RhY2suaW52YXJpYW50IGZhaWxlZFwiXG4gICAgICAgICBbIFwiZXhuXCIsIGV4biB8PiBFeG4uc2V4cF9vZl90OyBcInN0YWNrXCIsIHQgfD4gc2V4cF9vZl90X2ludGVybmFsIHNleHBfb2Zfb3BhcXVlIF0pXG47O1xuXG5sZXQgY3JlYXRlICh0eXBlIGEpICgpIDogYSB0ID0geyBsZW5ndGggPSAwOyBlbHRzID0gT3B0aW9uX2FycmF5LmVtcHR5IH1cbmxldCBsZW5ndGggdCA9IHQubGVuZ3RoXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG4oKiBUaGUgb3JkZXIgaW4gd2hpY2ggZWxlbWVudHMgYXJlIHZpc2l0ZWQgaGFzIGJlZW4gY2hvc2VuIHNvIGFzIHRvIGJlIGJhY2t3YXJkc1xuICAgY29tcGF0aWJsZSB3aXRoIFtTdGRsaWIuU3RhY2tdICopXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IHIgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAhciAoT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgaSlcbiAgZG9uZTtcbiAgIXJcbjs7XG5cbmxldCBpdGVyIHQgfmYgPVxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIGYgKE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkpXG4gIGRvbmVcbjs7XG5cbm1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBmb2xkID0gZm9sZFxuICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbmVuZClcblxubGV0IG1lbSA9IEMubWVtXG5sZXQgZXhpc3RzID0gQy5leGlzdHNcbmxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG5sZXQgY291bnQgPSBDLmNvdW50XG5sZXQgc3VtID0gQy5zdW1cbmxldCBmaW5kID0gQy5maW5kXG5sZXQgZmluZF9tYXAgPSBDLmZpbmRfbWFwXG5sZXQgdG9fbGlzdCA9IEMudG9fbGlzdFxubGV0IHRvX2FycmF5ID0gQy50b19hcnJheVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBtYXhfZWx0ID0gQy5tYXhfZWx0XG5sZXQgZm9sZF9yZXN1bHQgPSBDLmZvbGRfcmVzdWx0XG5sZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxuXG5sZXQgb2ZfbGlzdCAodHlwZSBhKSAobCA6IGEgbGlzdCkgPVxuICBpZiBMaXN0LmlzX2VtcHR5IGxcbiAgdGhlbiBjcmVhdGUgKClcbiAgZWxzZSAoXG4gICAgbGV0IGxlbmd0aCA9IExpc3QubGVuZ3RoIGwgaW5cbiAgICBsZXQgZWx0cyA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjooMiAqIGxlbmd0aCkgaW5cbiAgICBsZXQgciA9IHJlZiBsIGluXG4gICAgZm9yIGkgPSBsZW5ndGggLSAxIGRvd250byAwIGRvXG4gICAgICBtYXRjaCAhciB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBhIDo6IGwgLT5cbiAgICAgICAgT3B0aW9uX2FycmF5LnNldF9zb21lIGVsdHMgaSBhO1xuICAgICAgICByIDo9IGxcbiAgICBkb25lO1xuICAgIHsgbGVuZ3RoOyBlbHRzIH0pXG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gTGlzdC5zZXhwX29mX3Qgc2V4cF9vZl9hICh0b19saXN0IHQpXG5sZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID0gb2ZfbGlzdCAoTGlzdC50X29mX3NleHAgYV9vZl9zZXhwIHNleHApXG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoZ3JhbW1hciA6IGEgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuOztcblxubGV0IHJlc2l6ZSB0IHNpemUgPVxuICBsZXQgYXJyID0gT3B0aW9uX2FycmF5LmNyZWF0ZSB+bGVuOnNpemUgaW5cbiAgT3B0aW9uX2FycmF5LmJsaXQgfnNyYzp0LmVsdHMgfmRzdDphcnIgfnNyY19wb3M6MCB+ZHN0X3BvczowIH5sZW46dC5sZW5ndGg7XG4gIHQuZWx0cyA8LSBhcnJcbjs7XG5cbmxldCBzZXRfY2FwYWNpdHkgdCBuZXdfY2FwYWNpdHkgPVxuICBsZXQgbmV3X2NhcGFjaXR5ID0gbWF4IG5ld19jYXBhY2l0eSAobGVuZ3RoIHQpIGluXG4gIGlmIG5ld19jYXBhY2l0eSA8PiBjYXBhY2l0eSB0IHRoZW4gcmVzaXplIHQgbmV3X2NhcGFjaXR5XG47O1xuXG5sZXQgcHVzaCB0IGEgPVxuICBpZiB0Lmxlbmd0aCA9IE9wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzIHRoZW4gcmVzaXplIHQgKDIgKiAodC5sZW5ndGggKyAxKSk7XG4gIE9wdGlvbl9hcnJheS5zZXRfc29tZSB0LmVsdHMgdC5sZW5ndGggYTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxXG47O1xuXG5sZXQgcG9wX25vbmVtcHR5IHQgPVxuICBsZXQgaSA9IHQubGVuZ3RoIC0gMSBpblxuICBsZXQgcmVzdWx0ID0gT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgaSBpblxuICBPcHRpb25fYXJyYXkuc2V0X25vbmUgdC5lbHRzIGk7XG4gIHQubGVuZ3RoIDwtIGk7XG4gIHJlc3VsdFxuOztcblxubGV0IHBvcF9lcnJvciA9IEVycm9yLm9mX3N0cmluZyBcIlN0YWNrLnBvcCBvZiBlbXB0eSBzdGFja1wiXG5sZXQgcG9wIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKHBvcF9ub25lbXB0eSB0KVxubGV0IHBvcF9leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBFcnJvci5yYWlzZSBwb3BfZXJyb3IgZWxzZSBwb3Bfbm9uZW1wdHkgdFxubGV0IHRvcF9ub25lbXB0eSB0ID0gT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgKHQubGVuZ3RoIC0gMSlcbmxldCB0b3BfZXJyb3IgPSBFcnJvci5vZl9zdHJpbmcgXCJTdGFjay50b3Agb2YgZW1wdHkgc3RhY2tcIlxubGV0IHRvcCB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lICh0b3Bfbm9uZW1wdHkgdClcbmxldCB0b3BfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gRXJyb3IucmFpc2UgdG9wX2Vycm9yIGVsc2UgdG9wX25vbmVtcHR5IHRcbmxldCBjb3B5IHsgbGVuZ3RoOyBlbHRzIH0gPSB7IGxlbmd0aDsgZWx0cyA9IE9wdGlvbl9hcnJheS5jb3B5IGVsdHMgfVxuXG5sZXQgY2xlYXIgdCA9XG4gIGlmIHQubGVuZ3RoID4gMFxuICB0aGVuIChcbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICBPcHRpb25fYXJyYXkuc2V0X25vbmUgdC5lbHRzIGlcbiAgICBkb25lO1xuICAgIHQubGVuZ3RoIDwtIDApXG47O1xuXG5sZXQgdW50aWxfZW1wdHkgdCBmID1cbiAgbGV0IHJlYyBsb29wICgpID1cbiAgICBpZiB0Lmxlbmd0aCA+IDBcbiAgICB0aGVuIChcbiAgICAgIGYgKHBvcF9ub25lbXB0eSB0KTtcbiAgICAgIGxvb3AgKCkpXG4gIGluXG4gIGxvb3AgKCkgW0Bub250YWlsXVxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgbWF0Y2ggZiAoT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgaSkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSB4IC0+IHB1c2ggdF9yZXN1bHQgeFxuICBkb25lO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICBsZXQgeCA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkgaW5cbiAgICBpZiBmIHggdGhlbiBwdXNoIHRfcmVzdWx0IHhcbiAgZG9uZTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfaW5wbGFjZSB0IH5mID1cbiAgbGV0IHdyaXRlX2luZGV4ID0gcmVmIDAgaW5cbiAgRXhuLnByb3RlY3RcbiAgICB+ZjooZnVuICgpIC0+XG4gICAgICBmb3IgcmVhZF9pbmRleCA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICAgIGxldCB4ID0gT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9hc3N1bWluZ19zb21lIHQuZWx0cyByZWFkX2luZGV4IGluXG4gICAgICAgIGlmIGYgeFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBpZiAhd3JpdGVfaW5kZXggPCByZWFkX2luZGV4XG4gICAgICAgICAgdGhlbiBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHQuZWx0cyAhd3JpdGVfaW5kZXggeDtcbiAgICAgICAgICBpbmNyIHdyaXRlX2luZGV4KVxuICAgICAgZG9uZSlcbiAgICB+ZmluYWxseTooZnVuICgpIC0+XG4gICAgICBmb3IgaSA9ICF3cml0ZV9pbmRleCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICAgICAgT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfbm9uZSB0LmVsdHMgaVxuICAgICAgZG9uZTtcbiAgICAgIHQubGVuZ3RoIDwtICF3cml0ZV9pbmRleCkgW0Bub250YWlsXVxuOztcblxubGV0IHNpbmdsZXRvbiB4ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgcHVzaCB0IHg7XG4gIHRcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuKCogVGhpcyBpcyBsaWZ0ZWQgb3V0IG9mIFtNXSBiZWNhdXNlIFtTb3VyY2VfY29kZV9wb3NpdGlvbjBdIGV4cG9ydHMgW1N0cmluZzBdXG4gICBhcyBbU3RyaW5nXSwgd2hpY2ggZG9lcyBub3QgZXhwb3J0IGEgaGFzaCBmdW5jdGlvbi4gKilcbmxldCBoYXNoX292ZXJyaWRlIHsgU3RkbGliLkxleGluZy5wb3NfZm5hbWU7IHBvc19sbnVtOyBwb3NfYm9sOyBwb3NfY251bSB9ID1cbiAgU3RyaW5nLmhhc2ggcG9zX2ZuYW1lXG4gIGx4b3IgSW50Lmhhc2ggcG9zX2xudW1cbiAgbHhvciBJbnQuaGFzaCBwb3NfYm9sXG4gIGx4b3IgSW50Lmhhc2ggcG9zX2NudW1cbjs7XG5cbm1vZHVsZSBNID0gc3RydWN0XG4gIGluY2x1ZGUgU291cmNlX2NvZGVfcG9zaXRpb24wXG5cbiAgbGV0IGhhc2ggPSBoYXNoX292ZXJyaWRlXG5lbmRcblxuaW5jbHVkZSBNXG5pbmNsdWRlIENvbXBhcmFibGUuTWFrZV91c2luZ19jb21wYXJhdG9yIChNKVxuXG5sZXQgZXF1YWxfX2xvY2FsIGEgYiA9IGVxdWFsX2ludCAoY29tcGFyZV9fbG9jYWwgYSBiKSAwXG5cbmxldCBvZl9wb3MgKHBvc19mbmFtZSwgcG9zX2xudW0sIHBvc19jbnVtLCBfKSA9XG4gIHsgcG9zX2ZuYW1lOyBwb3NfbG51bTsgcG9zX2NudW07IHBvc19ib2wgPSAwIH1cbjs7XG4iLCJvcGVuISBJbXBvcnRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IE5lZ1xuICAgIHwgWmVyb1xuICAgIHwgUG9zXG4gICAgfCBOYW5cbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSwgaGFzaCwgZW51bWVyYXRlXVxuXG4gIGxldCB0X29mX3NleHAgPVxuICAgIChsZXQgZXJyb3Jfc291cmNlX18wMDNfID0gXCJzaWduX29yX25hbi5tbC5ULnRcIiBpblxuICAgICBmdW5jdGlvblxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuZWdcIiB8IFwiTmVnXCIpIC0+IE5lZ1xuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgLT4gWmVyb1xuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJwb3NcIiB8IFwiUG9zXCIpIC0+IFBvc1xuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIC0+IE5hblxuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJwb3NcIiB8IFwiUG9zXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmFuXCIgfCBcIk5hblwiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDAyXyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDJfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgICAgfCBzZXhwX18wMDJfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgfCBOZWcgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmVnXCJcbiAgICAgfCBaZXJvIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlplcm9cIlxuICAgICB8IFBvcyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJQb3NcIlxuICAgICB8IE5hbiAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOYW5cIlxuICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIHsgdW50eXBlZCA9XG4gICAgICAgIFZhcmlhbnRcbiAgICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgWyBOb190YWcgeyBuYW1lID0gXCJOZWdcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiWmVyb1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJQb3NcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiTmFuXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgIH1cbiAgOztcblxuICBsZXQgY29tcGFyZSA9IChTdGRsaWIuY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIChmdW4gaHN2IGFyZyAtPlxuICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludFxuICAgICAgICAgaHN2XG4gICAgICAgICAobWF0Y2ggYXJnIHdpdGhcbiAgICAgICAgICB8IE5lZyAtPiAwXG4gICAgICAgICAgfCBaZXJvIC0+IDFcbiAgICAgICAgICB8IFBvcyAtPiAyXG4gICAgICAgICAgfCBOYW4gLT4gMylcbiAgICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICA7O1xuXG4gIGxldCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyBhcmcgPVxuICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgICBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBhbGwgPSAoWyBOZWc7IFplcm87IFBvczsgTmFuIF0gOiB0IGxpc3QpXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgb2Zfc3RyaW5nIHMgPSB0X29mX3NleHAgKHNleHBfb2Zfc3RyaW5nIHMpXG4gIGxldCB0b19zdHJpbmcgdCA9IHN0cmluZ19vZl9zZXhwIChzZXhwX29mX3QgdClcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlNpZ25fb3JfbmFuXCJcbmVuZFxuXG5tb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogVC50KSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBULnQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBULnQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogVC50KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgY29tcGFyZV9fbG9jYWwgKHggOiBULnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IFQudCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBlcXVhbF9fbG9jYWwgKHggOiBULnQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogVC50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IFQudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChUKVxuXG4oKiBPcGVuIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IG9mX3NpZ24gPSBmdW5jdGlvblxuICB8IFNpZ24uTmVnIC0+IE5lZ1xuICB8IFNpZ24uWmVybyAtPiBaZXJvXG4gIHwgU2lnbi5Qb3MgLT4gUG9zXG47O1xuXG5sZXQgdG9fc2lnbl9leG4gPSBmdW5jdGlvblxuICB8IE5lZyAtPiBTaWduLk5lZ1xuICB8IFplcm8gLT4gU2lnbi5aZXJvXG4gIHwgUG9zIC0+IFNpZ24uUG9zXG4gIHwgTmFuIC0+IGludmFsaWRfYXJnIFwiQmFzZS5TaWduX29yX25hbi50b19zaWduX2V4bjogTmFuXCJcbjs7XG5cbmxldCBvZl9pbnQgbiA9IG9mX3NpZ24gKFNpZ24ub2ZfaW50IG4pXG5sZXQgdG9faW50X2V4biB0ID0gU2lnbi50b19pbnQgKHRvX3NpZ25fZXhuIHQpXG5cbmxldCBmbGlwID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gUG9zXG4gIHwgWmVybyAtPiBaZXJvXG4gIHwgUG9zIC0+IE5lZ1xuICB8IE5hbiAtPiBOYW5cbjs7XG5cbmxldCAoICogKSB0IHQnID1cbiAgbWF0Y2ggdCwgdCcgd2l0aFxuICB8IE5hbiwgXyB8IF8sIE5hbiAtPiBOYW5cbiAgfCBfIC0+IG9mX3NpZ24gKFNpZ24uKCAqICkgKHRvX3NpZ25fZXhuIHQpICh0b19zaWduX2V4biB0JykpXG47O1xuXG5sZXQgdG9fc3RyaW5nX2h1bSA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IFwibmVnYXRpdmVcIlxuICB8IFplcm8gLT4gXCJ6ZXJvXCJcbiAgfCBQb3MgLT4gXCJwb3NpdGl2ZVwiXG4gIHwgTmFuIC0+IFwibm90LWEtbnVtYmVyXCJcbjs7XG5cbigqIEluY2x1ZGUgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXIgYW55IGZ1bmN0b3IgYXBwbGljYXRpb25zIHRoYXRcbiAgIGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieSB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCIoKiogSW50ZXJmYWNlcyBmb3IgaW1tdXRhYmxlIGRpY3Rpb25hcnkgdHlwZXMsIHN1Y2ggYXMgW01hcC50XS5cblxuICAgIFdlIGRlZmluZSBzZXBhcmF0ZSBpbnRlcmZhY2VzIGZvciBbQWNjZXNzb3JzXSBhbmQgW0NyZWF0b3JzXSwgYWxvbmcgd2l0aCBbU10gY29tYmluaW5nXG4gICAgYm90aC4gVGhlc2UgaW50ZXJmYWNlcyBhcmUgd3JpdHRlbiBvbmNlIGluIHRoZWlyIG1vc3QgZ2VuZXJhbCBmb3JtLCB3aGljaCBpbnZvbHZlc1xuICAgIGV4dHJhIHR5cGUgZGVmaW5pdGlvbnMgYW5kIHR5cGUgcGFyYW1ldGVycyB0aGF0IG1vc3QgaW5zdGFuY2VzIGRvIG5vdCBuZWVkLlxuXG4gICAgV2UgdGhlbiBwcm92aWRlIGluc3RhbnRpYXRpb25zIG9mIHRoZXNlIGludGVyZmFjZXMgd2l0aCAxLCAyLCBhbmQgMyB0eXBlIHBhcmFtZXRlcnNcbiAgICBmb3IgW3RdLiBUaGVzZSBjb3ZlciBtb3JlIGNvbW1vbiB1c2FnZSBwYXR0ZXJucyBmb3IgdGhlIGludGVyZmFjZXMuICopXG5cbm9wZW4hIEltcG9ydFxuXG4oKiogVGhlc2UgZGVmaW5pdGlvbnMgYXJlIHJlLWV4cG9ydGVkIGJ5IFtEaWN0aW9uYXJ5X2ltbXV0YWJsZV0uICopXG5tb2R1bGUgRGVmaW5pdGlvbnMgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzID0gc2lnXG4gICAgKCoqIFRoZSB0eXBlIG9mIGtleXMuIFRoaXMgd2lsbCBiZSBbJ2tleV0gZm9yIHBvbHltb3JwaGljIGRpY3Rpb25hcmllcywgb3Igc29tZSBmaXhlZFxuICAgICAgICB0eXBlIGZvciBkaWN0aW9uYXJpZXMgd2l0aCBtb25vbW9ycGhpYyBrZXlzLiAqKVxuICAgIHR5cGUgJ2tleSBrZXlcblxuICAgICgqKiBEaWN0aW9uYXJpZXMuIFRoZWlyIGtleXMgaGF2ZSB0eXBlIFsna2V5IGtleV0uIEVhY2gga2V5J3MgYXNzb2NpYXRlZCB2YWx1ZSBoYXNcbiAgICAgICAgdHlwZSBbJ2RhdGFdLiBUaGUgZGljdGlvbmFyeSBtYXkgYmUgZGlzdGluZ3Vpc2hlZCBieSBhIFsncGhhbnRvbV0gdHlwZS4gKilcbiAgICB0eXBlICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcblxuICAgICgqKiBUaGUgdHlwZSBvZiBhY2Nlc3NvciBmdW5jdGlvbnMgWydmbl0gdGhhdCBvcGVyYXRlIG9uIFsoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XS5cbiAgICAgICAgTWF5IHRha2UgZXh0cmEgYXJndW1lbnRzIGJlZm9yZSBbJ2ZuXSwgc3VjaCBhcyBhIGNvbXBhcmlzb24gZnVuY3Rpb24uICopXG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yXG5cbiAgICAoKiogV2hldGhlciB0aGUgZGljdGlvbmFyeSBpcyBlbXB0eS4gKilcbiAgICB2YWwgaXNfZW1wdHkgOiAoXywgXywgXykgdCAtPiBib29sXG5cbiAgICAoKiogSG93IG1hbnkga2V5L3ZhbHVlIHBhaXJzIHRoZSBkaWN0aW9uYXJ5IGNvbnRhaW5zLiAqKVxuICAgIHZhbCBsZW5ndGggOiAoXywgXywgXykgdCAtPiBpbnRcblxuICAgICgqKiBBbGwga2V5L3ZhbHVlIHBhaXJzLiAqKVxuICAgIHZhbCB0b19hbGlzdCA6ICgna2V5LCAnZGF0YSwgXykgdCAtPiAoJ2tleSBrZXkgKiAnZGF0YSkgbGlzdFxuXG4gICAgKCoqIEFsbCBrZXlzIGluIHRoZSBkaWN0aW9uYXJ5LCBpbiB0aGUgc2FtZSBvcmRlciBhcyBbdG9fYWxpc3RdLiAqKVxuICAgIHZhbCBrZXlzIDogKCdrZXksIF8sIF8pIHQgLT4gJ2tleSBrZXkgbGlzdFxuXG4gICAgKCoqIEFsbCB2YWx1ZXMgaW4gdGhlIGRpY3Rpb25hcnksIGluIHRoZSBzYW1lIG9yZGVyIGFzIFt0b19hbGlzdF0uICopXG4gICAgdmFsIGRhdGEgOiAoXywgJ2RhdGEsIF8pIHQgLT4gJ2RhdGEgbGlzdFxuXG4gICAgKCoqIExpa2UgW3RvX2FsaXN0XS4gUHJvZHVjZXMgYSBzZXF1ZW5jZS4gKilcbiAgICB2YWwgdG9fc2VxdWVuY2UgOiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IC0+ICgna2V5IGtleSAqICdkYXRhKSBTZXF1ZW5jZS50XG5cbiAgICAoKiogV2hldGhlciBba2V5XSBoYXMgYSB2YWx1ZS4gKilcbiAgICB2YWwgbWVtIDogKCgna2V5LCBfLCAncGhhbnRvbSkgdCAtPiAna2V5IGtleSAtPiBib29sLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yXG5cbiAgICAoKiogUHJvZHVjZXMgdGhlIGN1cnJlbnQgdmFsdWUsIG9yIGFic2VuY2UgdGhlcmVvZiwgZm9yIGEgZ2l2ZW4ga2V5LiAqKVxuICAgIHZhbCBmaW5kXG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiAna2V5IGtleSAtPiAnZGF0YSBvcHRpb25cbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogTGlrZSBbZmluZF0uIFJhaXNlcyBpZiB0aGVyZSBpcyBubyB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleS4gKilcbiAgICB2YWwgZmluZF9leG5cbiAgICAgIDogKCgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gJ2tleSBrZXkgLT4gJ2RhdGEsICdrZXksICdkYXRhLCAncGhhbnRvbSkgYWNjZXNzb3JcblxuICAgICgqKiBBZGRzIGEga2V5L3ZhbHVlIHBhaXIgZm9yIGEga2V5IHRoZSBkaWN0aW9uYXJ5IGRvZXMgbm90IGNvbnRhaW4sIG9yIHJlcG9ydHMgYVxuICAgICAgICBkdXBsaWNhdGUuICopXG4gICAgdmFsIGFkZFxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiBrZXk6J2tleSBrZXlcbiAgICAgICAgICAtPiBkYXRhOidkYXRhXG4gICAgICAgICAgLT4gWyBgT2sgb2YgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCB8IGBEdXBsaWNhdGUgXVxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBMaWtlIFthZGRdLiBSYWlzZXMgb24gZHVwbGljYXRlcy4gKilcbiAgICB2YWwgYWRkX2V4blxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiBrZXk6J2tleSBrZXlcbiAgICAgICAgICAtPiBkYXRhOidkYXRhXG4gICAgICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBBZGRzIG9yIHJlcGxhY2VzIGEga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIGRpY3Rpb25hcnkuICopXG4gICAgdmFsIHNldFxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiBrZXk6J2tleSBrZXlcbiAgICAgICAgICAtPiBkYXRhOidkYXRhXG4gICAgICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBSZW1vdmVzIGFueSB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleS4gKilcbiAgICB2YWwgcmVtb3ZlXG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiAna2V5IGtleSAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIEFkZHMsIHJlcGxhY2VzLCBvciByZW1vdmVzIHRoZSB2YWx1ZSBmb3IgYSBnaXZlbiBrZXksIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudFxuICAgICAgICB2YWx1ZSBvciBsYWNrIHRoZXJlb2YuICopXG4gICAgdmFsIGNoYW5nZVxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiAna2V5IGtleVxuICAgICAgICAgIC0+IGY6KCdkYXRhIG9wdGlvbiAtPiAnZGF0YSBvcHRpb24pXG4gICAgICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBBZGRzIG9yIHJlcGxhY2VzIHRoZSB2YWx1ZSBmb3IgYSBnaXZlbiBrZXksIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCB2YWx1ZSBvclxuICAgICAgICBsYWNrIHRoZXJlb2YuICopXG4gICAgdmFsIHVwZGF0ZVxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiAna2V5IGtleVxuICAgICAgICAgIC0+IGY6KCdkYXRhIG9wdGlvbiAtPiAnZGF0YSlcbiAgICAgICAgICAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIEFkZHMgW2RhdGFdIHRvIHRoZSBleGlzdGluZyBrZXkvdmFsdWUgcGFpciBmb3IgW2tleV0uIEludGVycHJldHMgYSBtaXNzaW5nIGtleSBhc1xuICAgICAgICBoYXZpbmcgYW4gZW1wdHkgbGlzdC4gKilcbiAgICB2YWwgYWRkX211bHRpXG4gICAgICA6ICggKCdrZXksICdkYXRhIGxpc3QsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4ga2V5OidrZXkga2V5XG4gICAgICAgICAgLT4gZGF0YTonZGF0YVxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YSBsaXN0LCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBSZW1vdmVzIG9uZSBlbGVtZW50IGZyb20gdGhlIGV4aXN0aW5nIGtleS92YWx1ZSBwYWlyIGZvciBba2V5XS4gUmVtb3ZlcyB0aGUga2V5XG4gICAgICAgIGVudGlyZWx5IGlmIHRoZSBuZXcgbGlzdCBpcyBlbXB0eS4gKilcbiAgICB2YWwgcmVtb3ZlX211bHRpXG4gICAgICA6ICggKCdrZXksICdkYXRhIGxpc3QsICdwaGFudG9tKSB0IC0+ICdrZXkga2V5IC0+ICgna2V5LCAnZGF0YSBsaXN0LCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBQcm9kdWNlcyB0aGUgbGlzdCBhc3NvY2lhdGVkIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcga2V5LiBJbnRlcnByZXRzIGEgbWlzc2luZ1xuICAgICAgICBrZXkgYXMgaGF2aW5nIGFuIGVtcHR5IGxpc3QuICopXG4gICAgdmFsIGZpbmRfbXVsdGlcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEgbGlzdCwgJ3BoYW50b20pIHQgLT4gJ2tleSBrZXkgLT4gJ2RhdGEgbGlzdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBDb21iaW5lcyBldmVyeSB2YWx1ZSBpbiB0aGUgZGljdGlvbmFyeS4gKilcbiAgICB2YWwgZm9sZFxuICAgICAgOiAgKCdrZXksICdkYXRhLCBfKSB0XG4gICAgICAtPiBpbml0OidhY2NcbiAgICAgIC0+IGY6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+ICdhY2MgLT4gJ2FjYylcbiAgICAgIC0+ICdhY2NcblxuICAgICgqKiBMaWtlIFtmb2xkXS4gTWF5IHN0b3AgYmVmb3JlIGNvbXBsZXRpbmcgdGhlIGl0ZXJhdGlvbi4gKilcbiAgICB2YWwgZm9sZF91bnRpbFxuICAgICAgOiAgKCdrZXksICdkYXRhLCBfKSB0XG4gICAgICAtPiBpbml0OidhY2NcbiAgICAgIC0+IGY6XG4gICAgICAgICAgIChrZXk6J2tleSBrZXlcbiAgICAgICAgICAgIC0+IGRhdGE6J2RhdGFcbiAgICAgICAgICAgIC0+ICdhY2NcbiAgICAgICAgICAgIC0+ICgnYWNjLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgICAgLT4gJ2ZpbmFsXG5cbiAgICAoKiogV2hldGhlciBldmVyeSB2YWx1ZSBzYXRpc2ZpZXMgW2ZdLiAqKVxuICAgIHZhbCBmb3JfYWxsIDogKCdrZXksICdkYXRhLCBfKSB0IC0+IGY6KCdkYXRhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAgICgqKiBMaWtlIFtmb3JfYWxsXS4gVGhlIHByZWRpY2F0ZSBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBmb3JfYWxsaSA6ICgna2V5LCAnZGF0YSwgXykgdCAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiBib29sKSAtPiBib29sXG5cbiAgICAoKiogV2hldGhlciBhdCBsZWFzdCBvbmUgdmFsdWUgc2F0aXNmaWVzIFtmXS4gKilcbiAgICB2YWwgZXhpc3RzIDogKCdrZXksICdkYXRhLCBfKSB0IC0+IGY6KCdkYXRhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAgICgqKiBMaWtlIFtleGlzdHNdLiBUaGUgcHJlZGljYXRlIG1heSBhbHNvIGRlcGVuZCBvbiB0aGUgYXNzb2NpYXRlZCBrZXkuICopXG4gICAgdmFsIGV4aXN0c2kgOiAoJ2tleSwgJ2RhdGEsIF8pIHQgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICAgKCoqIEhvdyBtYW55IHZhbHVlcyBzYXRpc2Z5IFtmXS4gKilcbiAgICB2YWwgY291bnQgOiAoJ2tleSwgJ2RhdGEsIF8pIHQgLT4gZjooJ2RhdGEgLT4gYm9vbCkgLT4gaW50XG5cbiAgICAoKiogTGlrZSBbY291bnRdLiBUaGUgcHJlZGljYXRlIG1heSBhbHNvIGRlcGVuZCBvbiB0aGUgYXNzb2NpYXRlZCBrZXkuICopXG4gICAgdmFsIGNvdW50aSA6ICgna2V5LCAnZGF0YSwgXykgdCAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiBib29sKSAtPiBpbnRcblxuICAgICgqKiBTdW0gdXAgW2YgZGF0YV0gZm9yIGFsbCBkYXRhIGluIHRoZSBkaWN0aW9uYXJ5LiAqKVxuICAgIHZhbCBzdW1cbiAgICAgIDogIChtb2R1bGUgQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICAtPiAoJ2tleSwgJ2RhdGEsIF8pIHRcbiAgICAgIC0+IGY6KCdkYXRhIC0+ICdhKVxuICAgICAgLT4gJ2FcblxuICAgICgqKiBMaWtlIFtzdW1dLiBUaGUgZnVuY3Rpb24gbWF5IGFsc28gZGVwZW5kIG9uIHRoZSBhc3NvY2lhdGVkIGtleS4gKilcbiAgICB2YWwgc3VtaVxuICAgICAgOiAgKG1vZHVsZSBDb250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIC0+ICgna2V5LCAnZGF0YSwgXykgdFxuICAgICAgLT4gZjooa2V5OidrZXkgLT4gZGF0YTonZGF0YSAtPiAnYSlcbiAgICAgIC0+ICdhXG5cbiAgICAoKiogUHJvZHVjZXMgdGhlIGtleS92YWx1ZSBwYWlyIHdpdGggdGhlIHNtYWxsZXN0IGtleSBpZiBub24tZW1wdHkuICopXG4gICAgdmFsIG1pbl9lbHQgOiAoJ2tleSwgJ2RhdGEsIF8pIHQgLT4gKCdrZXkga2V5ICogJ2RhdGEpIG9wdGlvblxuXG4gICAgKCoqIExpa2UgW21pbl9lbHRdLiBSYWlzZXMgaWYgZW1wdHkuICopXG4gICAgdmFsIG1pbl9lbHRfZXhuIDogKCdrZXksICdkYXRhLCBfKSB0IC0+ICdrZXkga2V5ICogJ2RhdGFcblxuICAgICgqKiBQcm9kdWNlcyB0aGUga2V5L3ZhbHVlIHBhaXIgd2l0aCB0aGUgbGFyZ2VzdCBrZXkgaWYgbm9uLWVtcHR5LiAqKVxuICAgIHZhbCBtYXhfZWx0IDogKCdrZXksICdkYXRhLCBfKSB0IC0+ICgna2V5IGtleSAqICdkYXRhKSBvcHRpb25cblxuICAgICgqKiBMaWtlIFttYXhfZWx0XS4gUmFpc2VzIGlmIGVtcHR5LiAqKVxuICAgIHZhbCBtYXhfZWx0X2V4biA6ICgna2V5LCAnZGF0YSwgXykgdCAtPiAna2V5IGtleSAqICdkYXRhXG5cbiAgICAoKiogQ2FsbHMgW2ZdIGZvciBldmVyeSBrZXkuICopXG4gICAgdmFsIGl0ZXJfa2V5cyA6ICgna2V5LCBfLCBfKSB0IC0+IGY6KCdrZXkga2V5IC0+IHVuaXQpIC0+IHVuaXRcblxuICAgICgqKiBDYWxscyBbZl0gZm9yIGV2ZXJ5IHZhbHVlLiAqKVxuICAgIHZhbCBpdGVyIDogKF8sICdkYXRhLCBfKSB0IC0+IGY6KCdkYXRhIC0+IHVuaXQpIC0+IHVuaXRcblxuICAgICgqKiBDYWxscyBbZl0gZm9yIGV2ZXJ5IGtleS92YWx1ZSBwYWlyLiAqKVxuICAgIHZhbCBpdGVyaSA6ICgna2V5LCAnZGF0YSwgXykgdCAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiB1bml0KSAtPiB1bml0XG5cbiAgICAoKiogVHJhbnNmb3JtcyBldmVyeSB2YWx1ZS4gKilcbiAgICB2YWwgbWFwXG4gICAgICA6ICAoJ2tleSwgJ2RhdGExLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooJ2RhdGExIC0+ICdkYXRhMilcbiAgICAgIC0+ICgna2V5LCAnZGF0YTIsICdwaGFudG9tKSB0XG5cbiAgICAoKiogTGlrZSBbbWFwXS4gVGhlIHRyYW5zZm9ybWF0aW9uIG1heSBhbHNvIGRlcGVuZCBvbiB0aGUgYXNzb2NpYXRlZCBrZXkuICopXG4gICAgdmFsIG1hcGlcbiAgICAgIDogICgna2V5LCAnZGF0YTEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YTEgLT4gJ2RhdGEyKVxuICAgICAgLT4gKCdrZXksICdkYXRhMiwgJ3BoYW50b20pIHRcblxuICAgICgqKiBQcm9kdWNlcyBvbmx5IHRob3NlIGtleS92YWx1ZSBwYWlycyB3aG9zZSBrZXkgc2F0aXNmaWVzIFtmXS4gKilcbiAgICB2YWwgZmlsdGVyX2tleXNcbiAgICAgIDogICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KCdrZXkga2V5IC0+IGJvb2wpXG4gICAgICAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG5cbiAgICAoKiogUHJvZHVjZXMgb25seSB0aG9zZSBrZXkvdmFsdWUgcGFpcnMgd2hvc2UgdmFsdWUgc2F0aXNmaWVzIFtmXS4gKilcbiAgICB2YWwgZmlsdGVyXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOignZGF0YSAtPiBib29sKVxuICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIFByb2R1Y2VzIG9ubHkgdGhvc2Uga2V5L3ZhbHVlIHBhaXJzIHdoaWNoIHNhdGlzZnkgW2ZdLiAqKVxuICAgIHZhbCBmaWx0ZXJpXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiBib29sKVxuICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIFByb2R1Y2VzIGtleS92YWx1ZSBwYWlycyBmb3Igd2hpY2ggW2ZdIHByb2R1Y2VzIFtTb21lXS4gKilcbiAgICB2YWwgZmlsdGVyX21hcFxuICAgICAgOiAgKCdrZXksICdkYXRhMSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KCdkYXRhMSAtPiAnZGF0YTIgb3B0aW9uKVxuICAgICAgLT4gKCdrZXksICdkYXRhMiwgJ3BoYW50b20pIHRcblxuICAgICgqKiBMaWtlIFtmaWx0ZXJfbWFwXS4gVGhlIG5ldyB2YWx1ZSBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBmaWx0ZXJfbWFwaVxuICAgICAgOiAgKCdrZXksICdkYXRhMSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhMSAtPiAnZGF0YTIgb3B0aW9uKVxuICAgICAgLT4gKCdrZXksICdkYXRhMiwgJ3BoYW50b20pIHRcblxuICAgICgqKiBTcGxpdHMgb25lIGRpY3Rpb25hcnkgaW50byB0d28uIFRoZSBmaXJzdCBjb250YWlucyBrZXkvdmFsdWUgcGFpcnMgZm9yIHdoaWNoIHRoZVxuICAgICAgICB2YWx1ZSBzYXRpc2ZpZXMgW2ZdLiBUaGUgc2Vjb25kIGNvbnRhaW5zIHRoZSByZW1haW5kZXIuICopXG4gICAgdmFsIHBhcnRpdGlvbl90ZlxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooJ2RhdGEgLT4gYm9vbClcbiAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgKiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG5cbiAgICAoKiogTGlrZSBbcGFydGl0aW9uX3RmXS4gVGhlIHByZWRpY2F0ZSBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiBib29sKVxuICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAqICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcblxuICAgICgqKiBTcGxpdHMgb25lIGRpY3Rpb25hcnkgaW50byB0d28sIGNvcnJlc3BvbmRpbmcgcmVzcGVjdGl2ZWx5IHRvIFtGaXJzdCBfXSBhbmRcbiAgICAgICAgW1NlY29uZCBfXSByZXN1bHRzIGZyb20gW2ZdLiAqKVxuICAgIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgICA6ICAoJ2tleSwgJ2RhdGExLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooJ2RhdGExIC0+ICgnZGF0YTIsICdkYXRhMykgRWl0aGVyLnQpXG4gICAgICAtPiAoJ2tleSwgJ2RhdGEyLCAncGhhbnRvbSkgdCAqICgna2V5LCAnZGF0YTMsICdwaGFudG9tKSB0XG5cbiAgICAoKiogTGlrZSBbcGFydGl0aW9uX21hcF0uIFRoZSBzcGxpdCBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgICAgOiAgKCdrZXksICdkYXRhMSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhMSAtPiAoJ2RhdGEyLCAnZGF0YTMpIEVpdGhlci50KVxuICAgICAgLT4gKCdrZXksICdkYXRhMiwgJ3BoYW50b20pIHQgKiAoJ2tleSwgJ2RhdGEzLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIFByb2R1Y2VzIGFuIGVycm9yIGNvbWJpbmluZyBhbGwgZXJyb3IgbWVzc2FnZXMgZnJvbSBrZXkvdmFsdWUgcGFpcnMsIG9yIGFcbiAgICAgICAgZGljdGlvbmFyeSBvZiBhbGwgW09rXSB2YWx1ZXMgaWYgbm9uZSBhcmUgW0Vycm9yXS4gKilcbiAgICB2YWwgY29tYmluZV9lcnJvcnNcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEgT3JfZXJyb3IudCwgJ3BoYW50b20pIHQgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCBPcl9lcnJvci50XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIFNwbGl0cyB0aGUgW2ZzdF0gYW5kIFtzbmRdIGNvbXBvbmVudHMgb2YgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBrZXlzIGludG8gc2VwYXJhdGVcbiAgICAgICAgZGljdGlvbmFyaWVzLiAqKVxuICAgIHZhbCB1bnppcFxuICAgICAgOiAgKCdrZXksICdkYXRhMSAqICdkYXRhMiwgJ3BoYW50b20pIHRcbiAgICAgIC0+ICgna2V5LCAnZGF0YTEsICdwaGFudG9tKSB0ICogKCdrZXksICdkYXRhMiwgJ3BoYW50b20pIHRcblxuICAgICgqKiBNZXJnZXMgdHdvIGRpY3Rpb25hcmllcyBieSBmdWxseSB0cmF2ZXJzaW5nIGJvdGguIE5vdCBzdWl0YWJsZSBmb3IgZWZmaWNpZW50bHlcbiAgICAgICAgbWVyZ2luZyBsaXN0cyBvZiBkaWN0aW9uYXJpZXMuIFNlZSBbbWVyZ2VfZGlzam9pbnRfZXhuXSBhbmQgW21lcmdlX3NrZXdlZF1cbiAgICAgICAgaW5zdGVhZC4gKilcbiAgICB2YWwgbWVyZ2VcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGExLCAncGhhbnRvbSkgdFxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YTIsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gZjpcbiAgICAgICAgICAgICAgIChrZXk6J2tleSBrZXlcbiAgICAgICAgICAgICAgICAtPiBbIGBMZWZ0IG9mICdkYXRhMSB8IGBSaWdodCBvZiAnZGF0YTIgfCBgQm90aCBvZiAnZGF0YTEgKiAnZGF0YTIgXVxuICAgICAgICAgICAgICAgIC0+ICdkYXRhMyBvcHRpb24pXG4gICAgICAgICAgLT4gKCdrZXksICdkYXRhMywgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogTWVyZ2VzIHR3byBkaWN0aW9uYXJpZXMgd2l0aCB0aGUgc2FtZSB0eXBlIG9mIGRhdGEgYW5kIGRpc2pvaW50IHNldHMgb2Yga2V5cy5cbiAgICAgICAgUmFpc2VzIGlmIGFueSBrZXlzIG92ZXJsYXAuICopXG4gICAgdmFsIG1lcmdlX2Rpc2pvaW50X2V4blxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBNZXJnZXMgdHdvIGRpY3Rpb25hcmllcyBieSB0cmF2ZXJzaW5nIG9ubHkgdGhlIHNtYWxsZXIgb2YgdGhlIHR3by4gQWRkcyBrZXkvdmFsdWVcbiAgICAgICAgcGFpcnMgbWlzc2luZyBmcm9tIHRoZSBsYXJnZXIgZGljdGlvbmFyeSwgYW5kIFtjb21iaW5lXXMgZHVwbGljYXRlIHZhbHVlcy4gKilcbiAgICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiBjb21iaW5lOihrZXk6J2tleSBrZXkgLT4gJ2RhdGEgLT4gJ2RhdGEgLT4gJ2RhdGEpXG4gICAgICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBDb21wdXRlcyBhIHNlcXVlbmNlIG9mIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIGRpY3Rpb25hcmllcy4gKilcbiAgICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgIC0+IGRhdGFfZXF1YWw6KCdkYXRhIC0+ICdkYXRhIC0+IGJvb2wpXG4gICAgICAgICAgLT4gKCdrZXkga2V5ICogWyBgTGVmdCBvZiAnZGF0YSB8IGBSaWdodCBvZiAnZGF0YSB8IGBVbmVxdWFsIG9mICdkYXRhICogJ2RhdGEgXSlcbiAgICAgICAgICAgICBTZXF1ZW5jZS50XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIEZvbGRzIG92ZXIgdGhlIHJlc3VsdCBvZiBbc3ltbWV0cmljX2RpZmZdLiBNYXkgYmUgbW9yZSBwZXJmb3JtYW50LiAqKVxuICAgIHZhbCBmb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiBkYXRhX2VxdWFsOignZGF0YSAtPiAnZGF0YSAtPiBib29sKVxuICAgICAgICAgIC0+IGluaXQ6J2FjY1xuICAgICAgICAgIC0+IGY6XG4gICAgICAgICAgICAgICAoJ2FjY1xuICAgICAgICAgICAgICAgIC0+ICdrZXkga2V5XG4gICAgICAgICAgICAgICAgICAgKiBbIGBMZWZ0IG9mICdkYXRhIHwgYFJpZ2h0IG9mICdkYXRhIHwgYFVuZXF1YWwgb2YgJ2RhdGEgKiAnZGF0YSBdXG4gICAgICAgICAgICAgICAgLT4gJ2FjYylcbiAgICAgICAgICAtPiAnYWNjXG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMxID0gc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICdkYXRhIHRcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgQWNjZXNzb3JzXG4gICAgICAgIHdpdGggdHlwZSAoXywgJ2RhdGEsIF8pIHQgOj0gJ2RhdGEgdFxuICAgICAgICAgYW5kIHR5cGUgXyBrZXkgOj0ga2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCBfLCBfLCBfKSBhY2Nlc3NvciA6PSAnZm5cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMiA9IHNpZ1xuICAgIHR5cGUgKCdrZXksICdkYXRhKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSkgYWNjZXNzb3JcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgQWNjZXNzb3JzXG4gICAgICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsIF8pIHQgOj0gKCdrZXksICdkYXRhKSB0XG4gICAgICAgICBhbmQgdHlwZSAna2V5IGtleSA6PSAna2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgXykgYWNjZXNzb3IgOj0gKCdmbiwgJ2tleSwgJ2RhdGEpIGFjY2Vzc29yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczMgPSBzaWdcbiAgICB0eXBlICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICB0eXBlICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgYWNjZXNzb3JcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgQWNjZXNzb3JzXG4gICAgICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IDo9ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgIGFuZCB0eXBlICdrZXkga2V5IDo9ICdrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgYWNjZXNzb3IgOj1cbiAgICAgICAgICAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzID0gc2lnXG4gICAgKCoqIFRoZSB0eXBlIG9mIGtleXMuIFRoaXMgd2lsbCBiZSBbJ2tleV0gZm9yIHBvbHltb3JwaGljIGRpY3Rpb25hcmllcywgb3Igc29tZSBmaXhlZFxuICAgICAgICB0eXBlIGZvciBkaWN0aW9uYXJpZXMgd2l0aCBtb25vbW9ycGhpYyBrZXlzLiAqKVxuICAgIHR5cGUgJ2tleSBrZXlcblxuICAgICgqKiBEaWN0aW9uYXJpZXMuIFRoZWlyIGtleXMgaGF2ZSB0eXBlIFsna2V5IGtleV0uIEVhY2gga2V5J3MgYXNzb2NpYXRlZCB2YWx1ZSBoYXNcbiAgICAgICAgdHlwZSBbJ2RhdGFdLiBUaGUgZGljdGlvbmFyeSBtYXkgYmUgZGlzdGluZ3Vpc2hlZCBieSBhIFsncGhhbnRvbV0gdHlwZS4gKilcbiAgICB0eXBlICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcblxuICAgICgqKiBUaGUgdHlwZSBvZiBjcmVhdG9yIGZ1bmN0aW9ucyBbJ2ZuXSB0aGF0IG9wZXJhdGUgb24gWygna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRdLlxuICAgICAgICBNYXkgdGFrZSBleHRyYSBhcmd1bWVudHMgYmVmb3JlIFsnZm5dLCBzdWNoIGFzIGEgY29tcGFyaXNvbiBmdW5jdGlvbi4gKilcbiAgICB0eXBlICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvclxuXG4gICAgKCoqIFRoZSBlbXB0eSBkaWN0aW9uYXJ5LiAqKVxuICAgIHZhbCBlbXB0eSA6ICgoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0LCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGNyZWF0b3JcblxuICAgICgqKiBEaWN0aW9uYXJ5IHdpdGggYSBzaW5nbGUga2V5L3ZhbHVlIHBhaXIuICopXG4gICAgdmFsIHNpbmdsZXRvblxuICAgICAgOiAoJ2tleSBrZXkgLT4gJ2RhdGEgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG5cbiAgICAoKiogRGljdGlvbmFyeSBjb250YWluaW5nIHRoZSBnaXZlbiBrZXkvdmFsdWUgcGFpcnMuIEZhaWxzIGlmIHRoZXJlIGFyZSBkdXBsaWNhdGVcbiAgICAgICAga2V5cy4gKilcbiAgICB2YWwgb2ZfYWxpc3RcbiAgICAgIDogKCAoJ2tleSBrZXkgKiAnZGF0YSkgbGlzdFxuICAgICAgICAgIC0+IFsgYE9rIG9mICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgfCBgRHVwbGljYXRlX2tleSBvZiAna2V5IGtleSBdXG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogTGlrZSBbb2ZfYWxpc3RdLiBSZXR1cm5zIGEgW1Jlc3VsdC50XS4gKilcbiAgICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICAgIDogKCAoJ2tleSBrZXkgKiAnZGF0YSkgbGlzdCAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IE9yX2Vycm9yLnRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtvZl9hbGlzdF0uIFJhaXNlcyBvbiBkdXBsaWNhdGVzLiAqKVxuICAgIHZhbCBvZl9hbGlzdF9leG5cbiAgICAgIDogKCAoJ2tleSBrZXkgKiAnZGF0YSkgbGlzdCAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogUHJvZHVjZXMgYSBkaWN0aW9uYXJ5IG1hcHBpbmcgZWFjaCBrZXkgdG8gYSBsaXN0IG9mIGFzc29jaWF0ZWQgdmFsdWVzLiAqKVxuICAgIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgICAgOiAoICgna2V5IGtleSAqICdkYXRhKSBsaXN0IC0+ICgna2V5LCAnZGF0YSBsaXN0LCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIFByb2R1Y2VzIGEgZGljdGlvbmFyeSB1c2luZyBlYWNoIGtleS92YWx1ZSBwYWlyLiBDb21iaW5lcyBhbGwgdmFsdWVzIGZvciBhIGdpdmVuXG4gICAgICAgIGtleSB3aXRoIFtpbml0XSB1c2luZyBbZl0uICopXG4gICAgdmFsIG9mX2FsaXN0X2ZvbGRcbiAgICAgIDogKCAoJ2tleSBrZXkgKiAnZGF0YSkgbGlzdFxuICAgICAgICAgIC0+IGluaXQ6J2FjY1xuICAgICAgICAgIC0+IGY6KCdhY2MgLT4gJ2RhdGEgLT4gJ2FjYylcbiAgICAgICAgICAtPiAoJ2tleSwgJ2FjYywgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBQcm9kdWNlcyBhIGRpY3Rpb25hcnkgdXNpbmcgZWFjaCBrZXkvdmFsdWUgcGFpci4gQ29tYmluZXMgbXVsdGlwbGUgdmFsdWVzIGZvciBhXG4gICAgICAgIGdpdmVuIGtleSB1c2luZyBbZl0uICopXG4gICAgdmFsIG9mX2FsaXN0X3JlZHVjZVxuICAgICAgOiAoICgna2V5IGtleSAqICdkYXRhKSBsaXN0XG4gICAgICAgICAgLT4gZjooJ2RhdGEgLT4gJ2RhdGEgLT4gJ2RhdGEpXG4gICAgICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2FsaXN0XS4gQ29uc3VtZXMgYSBzZXF1ZW5jZS4gKilcbiAgICB2YWwgb2Zfc2VxdWVuY2VcbiAgICAgIDogKCAoJ2tleSBrZXkgKiAnZGF0YSkgU2VxdWVuY2UudFxuICAgICAgICAgIC0+IFsgYE9rIG9mICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgfCBgRHVwbGljYXRlX2tleSBvZiAna2V5IGtleSBdXG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogTGlrZSBbb2ZfYWxpc3Rfb3JfZXJyb3JdLiBDb25zdW1lcyBhIHNlcXVlbmNlLiAqKVxuICAgIHZhbCBvZl9zZXF1ZW5jZV9vcl9lcnJvclxuICAgICAgOiAoICgna2V5IGtleSAqICdkYXRhKSBTZXF1ZW5jZS50IC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgT3JfZXJyb3IudFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2FsaXN0X2V4bl0uIENvbnN1bWVzIGEgc2VxdWVuY2UuICopXG4gICAgdmFsIG9mX3NlcXVlbmNlX2V4blxuICAgICAgOiAoICgna2V5IGtleSAqICdkYXRhKSBTZXF1ZW5jZS50IC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtvZl9hbGlzdF9tdWx0aV0uIENvbnN1bWVzIGEgc2VxdWVuY2UuICopXG4gICAgdmFsIG9mX3NlcXVlbmNlX211bHRpXG4gICAgICA6ICggKCdrZXkga2V5ICogJ2RhdGEpIFNlcXVlbmNlLnQgLT4gKCdrZXksICdkYXRhIGxpc3QsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogTGlrZSBbb2ZfYWxpc3RfZm9sZF0uIENvbnN1bWVzIGEgc2VxdWVuY2UuICopXG4gICAgdmFsIG9mX3NlcXVlbmNlX2ZvbGRcbiAgICAgIDogKCAoJ2tleSBrZXkgKiAnZGF0YSkgU2VxdWVuY2UudFxuICAgICAgICAgIC0+IGluaXQ6J2NcbiAgICAgICAgICAtPiBmOignYyAtPiAnZGF0YSAtPiAnYylcbiAgICAgICAgICAtPiAoJ2tleSwgJ2MsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogTGlrZSBbb2ZfYWxpc3RfcmVkdWNlXS4gQ29uc3VtZXMgYSBzZXF1ZW5jZS4gKilcbiAgICB2YWwgb2Zfc2VxdWVuY2VfcmVkdWNlXG4gICAgICA6ICggKCdrZXkga2V5ICogJ2RhdGEpIFNlcXVlbmNlLnRcbiAgICAgICAgICAtPiBmOignZGF0YSAtPiAnZGF0YSAtPiAnZGF0YSlcbiAgICAgICAgICAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogTGlrZSBbb2ZfYWxpc3RdLiBDb25zdW1lIHZhbHVlcyBmb3Igd2hpY2gga2V5cyBjYW4gYmUgY29tcHV0ZWQuICopXG4gICAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlcbiAgICAgIDogKCAnZGF0YSBsaXN0XG4gICAgICAgICAgLT4gZ2V0X2tleTooJ2RhdGEgLT4gJ2tleSBrZXkpXG4gICAgICAgICAgLT4gWyBgT2sgb2YgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrZXkga2V5IF1cbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtvZl9hbGlzdF9vcl9lcnJvcl0uIENvbnN1bWUgdmFsdWVzIGZvciB3aGljaCBrZXlzIGNhbiBiZSBjb21wdXRlZC4gKilcbiAgICB2YWwgb2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvclxuICAgICAgOiAoICdkYXRhIGxpc3QgLT4gZ2V0X2tleTooJ2RhdGEgLT4gJ2tleSBrZXkpIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgT3JfZXJyb3IudFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2FsaXN0X2V4bl0uIENvbnN1bWUgdmFsdWVzIGZvciB3aGljaCBrZXlzIGNhbiBiZSBjb21wdXRlZC4gKilcbiAgICB2YWwgb2ZfbGlzdF93aXRoX2tleV9leG5cbiAgICAgIDogKCAnZGF0YSBsaXN0IC0+IGdldF9rZXk6KCdkYXRhIC0+ICdrZXkga2V5KSAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogTGlrZSBbb2ZfYWxpc3RfbXVsdGldLiBDb25zdW1lIHZhbHVlcyBmb3Igd2hpY2gga2V5cyBjYW4gYmUgY29tcHV0ZWQuICopXG4gICAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlfbXVsdGlcbiAgICAgIDogKCAnZGF0YSBsaXN0IC0+IGdldF9rZXk6KCdkYXRhIC0+ICdrZXkga2V5KSAtPiAoJ2tleSwgJ2RhdGEgbGlzdCwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBQcm9kdWNlcyBhIGRpY3Rpb25hcnkgb2YgYWxsIGtleS92YWx1ZSBwYWlycyB0aGF0IFtpdGVyaV0gcGFzc2VzIHRvIFt+Zl0uIEZhaWxzIGlmXG4gICAgICAgIGEgZHVwbGljYXRlIGtleSBpcyBmb3VuZC4gKilcbiAgICB2YWwgb2ZfaXRlcmlcbiAgICAgIDogKCBpdGVyaTooZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAgICAgICAtPiBbIGBPayBvZiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2tleSBrZXkgXVxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2l0ZXJpXS4gUmFpc2VzIG9uIGR1cGxpY2F0ZSBrZXkuICopXG4gICAgdmFsIG9mX2l0ZXJpX2V4blxuICAgICAgOiAoIGl0ZXJpOihmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiB1bml0KSAtPiB1bml0KVxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMxID0gc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICdkYXRhIHRcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNcbiAgICAgICAgd2l0aCB0eXBlIChfLCAnZGF0YSwgXykgdCA6PSAnZGF0YSB0XG4gICAgICAgICBhbmQgdHlwZSBfIGtleSA6PSBrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sIF8sIF8sIF8pIGNyZWF0b3IgOj0gJ2ZuXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMiA9IHNpZ1xuICAgIHR5cGUgKCdrZXksICdkYXRhKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSkgY3JlYXRvclxuXG4gICAgKCoqIEBpbmxpbmUgKilcbiAgICBpbmNsdWRlXG4gICAgICBDcmVhdG9yc1xuICAgICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCBfKSB0IDo9ICgna2V5LCAnZGF0YSkgdFxuICAgICAgICAgYW5kIHR5cGUgJ2tleSBrZXkgOj0gJ2tleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsIF8pIGNyZWF0b3IgOj0gKCdmbiwgJ2tleSwgJ2RhdGEpIGNyZWF0b3JcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMzID0gc2lnXG4gICAgdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGNyZWF0b3JcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNcbiAgICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgOj0gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgYW5kIHR5cGUgJ2tleSBrZXkgOj0gJ2tleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yIDo9XG4gICAgICAgICAgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlICdrZXkga2V5XG4gICAgdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yXG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGNyZWF0b3JcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgQWNjZXNzb3JzXG4gICAgICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IDo9ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgIGFuZCB0eXBlICdrZXkga2V5IDo9ICdrZXkga2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yIDo9XG4gICAgICAgICAgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuXG4gICAgKCoqIEBpbmxpbmUgKilcbiAgICBpbmNsdWRlXG4gICAgICBDcmVhdG9yc1xuICAgICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCA6PSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICBhbmQgdHlwZSAna2V5IGtleSA6PSAna2V5IGtleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yIDo9XG4gICAgICAgICAgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICdkYXRhIHRcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgU1xuICAgICAgICB3aXRoIHR5cGUgKF8sICdkYXRhLCBfKSB0IDo9ICdkYXRhIHRcbiAgICAgICAgIGFuZCB0eXBlIF8ga2V5IDo9IGtleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgXywgXywgXykgYWNjZXNzb3IgOj0gJ2ZuXG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCBfLCBfLCBfKSBjcmVhdG9yIDo9ICdmblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdrZXksICdkYXRhKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSkgYWNjZXNzb3JcbiAgICB0eXBlICgnZm4sICdrZXksICdkYXRhKSBjcmVhdG9yXG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIFNcbiAgICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgXykgdCA6PSAoJ2tleSwgJ2RhdGEpIHRcbiAgICAgICAgIGFuZCB0eXBlICdrZXkga2V5IDo9ICdrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCBfKSBhY2Nlc3NvciA6PSAoJ2ZuLCAna2V5LCAnZGF0YSkgYWNjZXNzb3JcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCBfKSBjcmVhdG9yIDo9ICgnZm4sICdrZXksICdkYXRhKSBjcmVhdG9yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yXG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGNyZWF0b3JcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgU1xuICAgICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCA6PSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICBhbmQgdHlwZSAna2V5IGtleSA6PSAna2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yIDo9XG4gICAgICAgICAgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yIDo9XG4gICAgICAgICAgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIERpY3Rpb25hcnlfaW1tdXRhYmxlID0gc2lnXG4gICgqKiBAaW5saW5lICopXG4gIGluY2x1ZGUgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBEZWZpbml0aW9ucyAoKiogQGlubGluZSAqKVxuICBlbmRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgdCA9XG4gIHwgSW5jbCBvZiAnYVxuICB8IEV4Y2wgb2YgJ2FcbiAgfCBVbmJvdW5kZWRcbltAQGRlcml2aW5nX2lubGluZSBlbnVtZXJhdGUsIHNleHAsIHNleHBfZ3JhbW1hciwgZ2xvYmFsaXplXVxuXG5sZXQgYWxsIDogJ2EuICdhIGxpc3QgLT4gJ2EgdCBsaXN0ID1cbiAgZnVuIF9hbGxfb2ZfYSAtPlxuICBQcHhfZW51bWVyYXRlX2xpYi5MaXN0LmFwcGVuZFxuICAgIChsZXQgcmVjIG1hcCBsIGFjYyA9XG4gICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgfCBbXSAtPiBQcHhfZW51bWVyYXRlX2xpYi5MaXN0LnJldiBhY2NcbiAgICAgICB8IGVudW1lcmF0ZV9fMDAxXyA6OiBsIC0+IG1hcCBsIChJbmNsIGVudW1lcmF0ZV9fMDAxXyA6OiBhY2MpXG4gICAgIGluXG4gICAgIG1hcCBfYWxsX29mX2EgW10pXG4gICAgKFBweF9lbnVtZXJhdGVfbGliLkxpc3QuYXBwZW5kXG4gICAgICAgKGxldCByZWMgbWFwIGwgYWNjID1cbiAgICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IFBweF9lbnVtZXJhdGVfbGliLkxpc3QucmV2IGFjY1xuICAgICAgICAgIHwgZW51bWVyYXRlX18wMDJfIDo6IGwgLT4gbWFwIGwgKEV4Y2wgZW51bWVyYXRlX18wMDJfIDo6IGFjYylcbiAgICAgICAgaW5cbiAgICAgICAgbWFwIF9hbGxfb2ZfYSBbXSlcbiAgICAgICBbIFVuYm91bmRlZCBdKVxuOztcblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gIGZ1biAodHlwZSBhX18wMThfKSA6ICgoU2V4cGxpYjAuU2V4cC50IC0+IGFfXzAxOF8pIC0+IFNleHBsaWIwLlNleHAudCAtPiBhX18wMThfIHQpIC0+XG4gIGxldCBlcnJvcl9zb3VyY2VfXzAwNl8gPSBcIm1heWJlX2JvdW5kLm1sLnRcIiBpblxuICBmdW4gX29mX2FfXzAwM18gLT4gZnVuY3Rpb25cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJpbmNsXCIgfCBcIkluY2xcIikgYXMgX3RhZ19fMDA5XykgOjogc2V4cF9hcmdzX18wMTBfKSBhc1xuICAgICAgX3NleHBfXzAwOF8gLT5cbiAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAxMF8gd2l0aFxuICAgICAgIHwgWyBhcmcwX18wMTFfIF0gLT5cbiAgICAgICAgIGxldCByZXMwX18wMTJfID0gX29mX2FfXzAwM18gYXJnMF9fMDExXyBpblxuICAgICAgICAgSW5jbCByZXMwX18wMTJfXG4gICAgICAgfCBfIC0+XG4gICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA2X1xuICAgICAgICAgICBfdGFnX18wMDlfXG4gICAgICAgICAgIF9zZXhwX18wMDhfKVxuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImV4Y2xcIiB8IFwiRXhjbFwiKSBhcyBfdGFnX18wMTRfKSA6OiBzZXhwX2FyZ3NfXzAxNV8pIGFzXG4gICAgICBfc2V4cF9fMDEzXyAtPlxuICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDE1XyB3aXRoXG4gICAgICAgfCBbIGFyZzBfXzAxNl8gXSAtPlxuICAgICAgICAgbGV0IHJlczBfXzAxN18gPSBfb2ZfYV9fMDAzXyBhcmcwX18wMTZfIGluXG4gICAgICAgICBFeGNsIHJlczBfXzAxN19cbiAgICAgICB8IF8gLT5cbiAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMDZfXG4gICAgICAgICAgIF90YWdfXzAxNF9cbiAgICAgICAgICAgX3NleHBfXzAxM18pXG4gICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwidW5ib3VuZGVkXCIgfCBcIlVuYm91bmRlZFwiKSAtPiBVbmJvdW5kZWRcbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbmNsXCIgfCBcIkluY2xcIikgYXMgc2V4cF9fMDA3XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImV4Y2xcIiB8IFwiRXhjbFwiKSBhcyBzZXhwX18wMDdfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ1bmJvdW5kZWRcIiB8IFwiVW5ib3VuZGVkXCIpIDo6IF8pIGFzXG4gICAgICBzZXhwX18wMDdfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDA1XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA1XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbiAgICB8IHNleHBfXzAwNV8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuOztcblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biAodHlwZSBhX18wMjRfKSA6ICgoYV9fMDI0XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IGFfXzAyNF8gdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gIGZ1biBfb2ZfYV9fMDE5XyAtPiBmdW5jdGlvblxuICB8IEluY2wgYXJnMF9fMDIwXyAtPlxuICAgIGxldCByZXMwX18wMjFfID0gX29mX2FfXzAxOV8gYXJnMF9fMDIwXyBpblxuICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkluY2xcIjsgcmVzMF9fMDIxXyBdXG4gIHwgRXhjbCBhcmcwX18wMjJfIC0+XG4gICAgbGV0IHJlczBfXzAyM18gPSBfb2ZfYV9fMDE5XyBhcmcwX18wMjJfIGluXG4gICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXhjbFwiOyByZXMwX18wMjNfIF1cbiAgfCBVbmJvdW5kZWQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVW5ib3VuZGVkXCJcbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hciA6ICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT5cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkluY2xcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkV4Y2xcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJVbmJvdW5kZWRcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxubGV0IGdsb2JhbGl6ZSA6ICdhLiAoJ2EgLT4gJ2EpIC0+ICdhIHQgLT4gJ2EgdCA9XG4gIGZ1biAodHlwZSBhX18wMjVfKSA6ICgoYV9fMDI1XyAtPiBhX18wMjVfKSAtPiBhX18wMjVfIHQgLT4gYV9fMDI1XyB0KSAtPlxuICBmdW4gX2dsb2JhbGl6ZV9hX18wMjZfIHhfXzAyN18gLT5cbiAgbWF0Y2ggeF9fMDI3XyB3aXRoXG4gIHwgVW5ib3VuZGVkIGFzIHhfXzAyOF8gLT4geF9fMDI4X1xuICB8IEluY2wgYXJnX18wMjlfIC0+IEluY2wgKF9nbG9iYWxpemVfYV9fMDI2XyBhcmdfXzAyOV8pXG4gIHwgRXhjbCBhcmdfXzAzMF8gLT4gRXhjbCAoX2dsb2JhbGl6ZV9hX18wMjZfIGFyZ19fMDMwXylcbjs7XG5cbltAQEBlbmRdXG5cbnR5cGUgaW50ZXJ2YWxfY29tcGFyaXNvbiA9XG4gIHwgQmVsb3dfbG93ZXJfYm91bmRcbiAgfCBJbl9yYW5nZVxuICB8IEFib3ZlX3VwcGVyX2JvdW5kXG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlIH5sb2NhbGl6ZSwgaGFzaF1cblxubGV0IGludGVydmFsX2NvbXBhcmlzb25fb2Zfc2V4cCA9XG4gIChsZXQgZXJyb3Jfc291cmNlX18wMzNfID0gXCJtYXliZV9ib3VuZC5tbC5pbnRlcnZhbF9jb21wYXJpc29uXCIgaW5cbiAgIGZ1bmN0aW9uXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJiZWxvd19sb3dlcl9ib3VuZFwiIHwgXCJCZWxvd19sb3dlcl9ib3VuZFwiKSAtPiBCZWxvd19sb3dlcl9ib3VuZFxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5fcmFuZ2VcIiB8IFwiSW5fcmFuZ2VcIikgLT4gSW5fcmFuZ2VcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImFib3ZlX3VwcGVyX2JvdW5kXCIgfCBcIkFib3ZlX3VwcGVyX2JvdW5kXCIpIC0+IEFib3ZlX3VwcGVyX2JvdW5kXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKFwiYmVsb3dfbG93ZXJfYm91bmRcIiB8IFwiQmVsb3dfbG93ZXJfYm91bmRcIikgOjogXykgYXMgc2V4cF9fMDM0X1xuICAgICAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDMzXyBzZXhwX18wMzRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImluX3JhbmdlXCIgfCBcIkluX3JhbmdlXCIpIDo6IF8pIGFzIHNleHBfXzAzNF9cbiAgICAgLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAzM18gc2V4cF9fMDM0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImFib3ZlX3VwcGVyX2JvdW5kXCIgfCBcIkFib3ZlX3VwcGVyX2JvdW5kXCIpIDo6IF8pIGFzIHNleHBfXzAzNF9cbiAgICAgLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAzM18gc2V4cF9fMDM0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAzMl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDMzXyBzZXhwX18wMzJfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMzJfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDMzXyBzZXhwX18wMzJfXG4gICB8IHNleHBfXzAzMl8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAzM18gc2V4cF9fMDMyX1xuICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IGludGVydmFsX2NvbXBhcmlzb24pXG47O1xuXG5sZXQgc2V4cF9vZl9pbnRlcnZhbF9jb21wYXJpc29uID1cbiAgKGZ1bmN0aW9uXG4gICB8IEJlbG93X2xvd2VyX2JvdW5kIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkJlbG93X2xvd2VyX2JvdW5kXCJcbiAgIHwgSW5fcmFuZ2UgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiSW5fcmFuZ2VcIlxuICAgfCBBYm92ZV91cHBlcl9ib3VuZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJBYm92ZV91cHBlcl9ib3VuZFwiXG4gICAgOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAoaW50ZXJ2YWxfY29tcGFyaXNvbl9zZXhwX2dyYW1tYXIgOiBpbnRlcnZhbF9jb21wYXJpc29uIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiQmVsb3dfbG93ZXJfYm91bmRcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIkluX3JhbmdlXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJBYm92ZV91cHBlcl9ib3VuZFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5sZXQgY29tcGFyZV9pbnRlcnZhbF9jb21wYXJpc29uX19sb2NhbCA9XG4gIChTdGRsaWIuY29tcGFyZSA6IGludGVydmFsX2NvbXBhcmlzb24gLT4gaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBpbnQpXG47O1xuXG5sZXQgY29tcGFyZV9pbnRlcnZhbF9jb21wYXJpc29uID1cbiAgKGZ1biBhIGIgLT4gY29tcGFyZV9pbnRlcnZhbF9jb21wYXJpc29uX19sb2NhbCBhIGJcbiAgICA6IGludGVydmFsX2NvbXBhcmlzb24gLT4gaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBpbnQpXG47O1xuXG5sZXQgKGhhc2hfZm9sZF9pbnRlcnZhbF9jb21wYXJpc29uIDpcbiAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50XG4gICAgICAgaHN2XG4gICAgICAgKG1hdGNoIGFyZyB3aXRoXG4gICAgICAgIHwgQmVsb3dfbG93ZXJfYm91bmQgLT4gMFxuICAgICAgICB8IEluX3JhbmdlIC0+IDFcbiAgICAgICAgfCBBYm92ZV91cHBlcl9ib3VuZCAtPiAyKVxuICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuOztcblxubGV0IChoYXNoX2ludGVydmFsX2NvbXBhcmlzb24gOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gIGxldCBmdW5jIGFyZyA9XG4gICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICBoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiBoc3YgYXJnKVxuICBpblxuICBmdW4geCAtPiBmdW5jIHhcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBtYXAgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEluY2wgaW5jbCAtPiBJbmNsIChmIGluY2wpXG4gIHwgRXhjbCBleGNsIC0+IEV4Y2wgKGYgZXhjbClcbiAgfCBVbmJvdW5kZWQgLT4gVW5ib3VuZGVkXG47O1xuXG5sZXQgaXNfbG93ZXJfYm91bmQgdCB+b2ZfOmEgfmNvbXBhcmUgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBJbmNsIGluY2wgLT4gY29tcGFyZSBpbmNsIGEgPD0gMFxuICB8IEV4Y2wgZXhjbCAtPiBjb21wYXJlIGV4Y2wgYSA8IDBcbiAgfCBVbmJvdW5kZWQgLT4gdHJ1ZVxuOztcblxubGV0IGlzX3VwcGVyX2JvdW5kIHQgfm9mXzphIH5jb21wYXJlID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgSW5jbCBpbmNsIC0+IGNvbXBhcmUgYSBpbmNsIDw9IDBcbiAgfCBFeGNsIGV4Y2wgLT4gY29tcGFyZSBhIGV4Y2wgPCAwXG4gIHwgVW5ib3VuZGVkIC0+IHRydWVcbjs7XG5cbmxldCBib3VuZHNfY3Jvc3NlZCB+bG93ZXIgfnVwcGVyIH5jb21wYXJlID1cbiAgbWF0Y2ggbG93ZXIgd2l0aFxuICB8IFVuYm91bmRlZCAtPiBmYWxzZVxuICB8IEluY2wgbG93ZXIgfCBFeGNsIGxvd2VyIC0+XG4gICAgKG1hdGNoIHVwcGVyIHdpdGhcbiAgICAgfCBVbmJvdW5kZWQgLT4gZmFsc2VcbiAgICAgfCBJbmNsIHVwcGVyIHwgRXhjbCB1cHBlciAtPiBjb21wYXJlIGxvd2VyIHVwcGVyID4gMClcbjs7XG5cbmxldCBjaGVja19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciB+Y29tcGFyZSA9XG4gIGlmIGJvdW5kc19jcm9zc2VkIH5sb3dlciB+dXBwZXIgfmNvbXBhcmVcbiAgdGhlbiBmYWlsd2l0aCBcIk1heWJlX2JvdW5kLmNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuOiBsb3dlciBib3VuZCA+IHVwcGVyIGJvdW5kXCJcbjs7XG5cbmxldCBjb21wYXJlX3RvX2ludGVydmFsX2V4biB+bG93ZXIgfnVwcGVyIGEgfmNvbXBhcmUgPVxuICBjaGVja19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciB+Y29tcGFyZTtcbiAgaWYgbm90IChpc19sb3dlcl9ib3VuZCBsb3dlciB+b2ZfOmEgfmNvbXBhcmUpXG4gIHRoZW4gQmVsb3dfbG93ZXJfYm91bmRcbiAgZWxzZSBpZiBub3QgKGlzX3VwcGVyX2JvdW5kIHVwcGVyIH5vZl86YSB+Y29tcGFyZSlcbiAgdGhlbiBBYm92ZV91cHBlcl9ib3VuZFxuICBlbHNlIEluX3JhbmdlXG47O1xuXG5sZXQgaW50ZXJ2YWxfY29udGFpbnNfZXhuIH5sb3dlciB+dXBwZXIgYSB+Y29tcGFyZSA9XG4gIG1hdGNoIGNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgYSB+Y29tcGFyZSB3aXRoXG4gIHwgSW5fcmFuZ2UgLT4gdHJ1ZVxuICB8IEJlbG93X2xvd2VyX2JvdW5kIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gZmFsc2Vcbjs7XG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIFRcblxubW9kdWxlIE9yX2R1cGxpY2F0ZSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIFsgYE9rIG9mICdhXG4gICAgfCBgRHVwbGljYXRlXG4gICAgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9XG4gICAgZnVuIF9jbXBfX2EgYV9fMDAxXyBiX18wMDJfIC0+XG4gICAgaWYgU3RkbGliLiggPT0gKSBhX18wMDFfIGJfXzAwMl9cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzAwMV8sIGJfXzAwMl8gd2l0aFxuICAgICAgfCBgT2sgX2xlZnRfXzAwM18sIGBPayBfcmlnaHRfXzAwNF8gLT4gX2NtcF9fYSBfbGVmdF9fMDAzXyBfcmlnaHRfXzAwNF9cbiAgICAgIHwgYER1cGxpY2F0ZSwgYER1cGxpY2F0ZSAtPiAwXG4gICAgICB8IHgsIHkgLT4gU3RkbGliLmNvbXBhcmUgeCB5KVxuICA7O1xuXG4gIGxldCBlcXVhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPVxuICAgIGZ1biBfY21wX19hIGFfXzAwNV8gYl9fMDA2XyAtPlxuICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDA1XyBiX18wMDZfXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMDVfLCBiX18wMDZfIHdpdGhcbiAgICAgIHwgYE9rIF9sZWZ0X18wMDdfLCBgT2sgX3JpZ2h0X18wMDhfIC0+IF9jbXBfX2EgX2xlZnRfXzAwN18gX3JpZ2h0X18wMDhfXG4gICAgICB8IGBEdXBsaWNhdGUsIGBEdXBsaWNhdGUgLT4gdHJ1ZVxuICAgICAgfCB4LCB5IC0+IFN0ZGxpYi4oID0gKSB4IHkpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgZnVuIF9vZl9hX18wMDlfIC0+IGZ1bmN0aW9uXG4gICAgfCBgT2sgdl9fMDEwXyAtPiBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJPa1wiOyBfb2ZfYV9fMDA5XyB2X18wMTBfIF1cbiAgICB8IGBEdXBsaWNhdGUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiRHVwbGljYXRlXCJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBXaXRob3V0X2NvbXBhcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2tleSwgJ2NtcCwgJ3opIHQgPSAnelxuZW5kXG5cbm1vZHVsZSBXaXRoX2NvbXBhcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2tleSwgJ2NtcCwgJ3opIHQgPSBjb21wYXJhdG9yOigna2V5LCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ3pcbmVuZFxuXG5tb2R1bGUgV2l0aF9maXJzdF9jbGFzc19tb2R1bGUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2tleSwgJ2NtcCwgJ3opIHQgPSAoJ2tleSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnelxuZW5kXG5cbm1vZHVsZSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50ID0gc3RydWN0XG4gIHR5cGUgKCdrLCAndikgdCA9ICdrICogWyBgTGVmdCBvZiAndiB8IGBSaWdodCBvZiAndiB8IGBVbmVxdWFsIG9mICd2ICogJ3YgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA6XG4gICAgICAgICdrICd2LiAoJ2sgLT4gJ2sgLT4gaW50KSAtPiAoJ3YgLT4gJ3YgLT4gaW50KSAtPiAoJ2ssICd2KSB0IC0+ICgnaywgJ3YpIHQgLT4gaW50XG4gICAgPVxuICAgIGZ1biBfY21wX19rIF9jbXBfX3YgYV9fMDExXyBiX18wMTJfIC0+XG4gICAgbGV0IHRfXzAxM18sIHRfXzAxNF8gPSBhX18wMTFfIGluXG4gICAgbGV0IHRfXzAxNV8sIHRfXzAxNl8gPSBiX18wMTJfIGluXG4gICAgbWF0Y2ggX2NtcF9fayB0X18wMTNfIHRfXzAxNV8gd2l0aFxuICAgIHwgMCAtPlxuICAgICAgaWYgU3RkbGliLiggPT0gKSB0X18wMTRfIHRfXzAxNl9cbiAgICAgIHRoZW4gMFxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHRfXzAxNF8sIHRfXzAxNl8gd2l0aFxuICAgICAgICB8IGBMZWZ0IF9sZWZ0X18wMTdfLCBgTGVmdCBfcmlnaHRfXzAxOF8gLT4gX2NtcF9fdiBfbGVmdF9fMDE3XyBfcmlnaHRfXzAxOF9cbiAgICAgICAgfCBgUmlnaHQgX2xlZnRfXzAxOV8sIGBSaWdodCBfcmlnaHRfXzAyMF8gLT4gX2NtcF9fdiBfbGVmdF9fMDE5XyBfcmlnaHRfXzAyMF9cbiAgICAgICAgfCBgVW5lcXVhbCBfbGVmdF9fMDIxXywgYFVuZXF1YWwgX3JpZ2h0X18wMjJfIC0+XG4gICAgICAgICAgbGV0IHRfXzAyM18sIHRfXzAyNF8gPSBfbGVmdF9fMDIxXyBpblxuICAgICAgICAgIGxldCB0X18wMjVfLCB0X18wMjZfID0gX3JpZ2h0X18wMjJfIGluXG4gICAgICAgICAgKG1hdGNoIF9jbXBfX3YgdF9fMDIzXyB0X18wMjVfIHdpdGhcbiAgICAgICAgICAgfCAwIC0+IF9jbXBfX3YgdF9fMDI0XyB0X18wMjZfXG4gICAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgICB8IHgsIHkgLT4gU3RkbGliLmNvbXBhcmUgeCB5KVxuICAgIHwgbiAtPiBuXG4gIDs7XG5cbiAgbGV0IGVxdWFsIDpcbiAgICAgICAgJ2sgJ3YuXG4gICAgICAgICgnayAtPiAnayAtPiBib29sKSAtPiAoJ3YgLT4gJ3YgLT4gYm9vbCkgLT4gKCdrLCAndikgdCAtPiAoJ2ssICd2KSB0IC0+IGJvb2xcbiAgICA9XG4gICAgZnVuIF9jbXBfX2sgX2NtcF9fdiBhX18wMjdfIGJfXzAyOF8gLT5cbiAgICBsZXQgdF9fMDI5XywgdF9fMDMwXyA9IGFfXzAyN18gaW5cbiAgICBsZXQgdF9fMDMxXywgdF9fMDMyXyA9IGJfXzAyOF8gaW5cbiAgICBTdGRsaWIuKCAmJiApXG4gICAgICAoX2NtcF9fayB0X18wMjlfIHRfXzAzMV8pXG4gICAgICAoaWYgU3RkbGliLiggPT0gKSB0X18wMzBfIHRfXzAzMl9cbiAgICAgICB0aGVuIHRydWVcbiAgICAgICBlbHNlIChcbiAgICAgICAgIG1hdGNoIHRfXzAzMF8sIHRfXzAzMl8gd2l0aFxuICAgICAgICAgfCBgTGVmdCBfbGVmdF9fMDMzXywgYExlZnQgX3JpZ2h0X18wMzRfIC0+IF9jbXBfX3YgX2xlZnRfXzAzM18gX3JpZ2h0X18wMzRfXG4gICAgICAgICB8IGBSaWdodCBfbGVmdF9fMDM1XywgYFJpZ2h0IF9yaWdodF9fMDM2XyAtPiBfY21wX192IF9sZWZ0X18wMzVfIF9yaWdodF9fMDM2X1xuICAgICAgICAgfCBgVW5lcXVhbCBfbGVmdF9fMDM3XywgYFVuZXF1YWwgX3JpZ2h0X18wMzhfIC0+XG4gICAgICAgICAgIGxldCB0X18wMzlfLCB0X18wNDBfID0gX2xlZnRfXzAzN18gaW5cbiAgICAgICAgICAgbGV0IHRfXzA0MV8sIHRfXzA0Ml8gPSBfcmlnaHRfXzAzOF8gaW5cbiAgICAgICAgICAgU3RkbGliLiggJiYgKSAoX2NtcF9fdiB0X18wMzlfIHRfXzA0MV8pIChfY21wX192IHRfXzA0MF8gdF9fMDQyXylcbiAgICAgICAgIHwgeCwgeSAtPiBTdGRsaWIuKCA9ICkgeCB5KSlcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIDpcbiAgICAgICAgJ2sgJ3YuXG4gICAgICAgIChTZXhwbGliMC5TZXhwLnQgLT4gJ2spXG4gICAgICAgIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ3YpXG4gICAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgICAgICAtPiAoJ2ssICd2KSB0XG4gICAgPVxuICAgIGxldCBlcnJvcl9zb3VyY2VfXzA1N18gPSBcIm1hcF9pbnRmLm1sLlN5bW1ldHJpY19kaWZmX2VsZW1lbnQudFwiIGluXG4gICAgZnVuIF9vZl9rX18wNDNfIF9vZl92X18wNDRfIC0+IGZ1bmN0aW9uXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbIGFyZzBfXzA2N187IGFyZzFfXzA2OF8gXSAtPlxuICAgICAgICBsZXQgcmVzMF9fMDY5XyA9IF9vZl9rX18wNDNfIGFyZzBfXzA2N19cbiAgICAgICAgYW5kIHJlczFfXzA3MF8gPVxuICAgICAgICAgIGxldCBzZXhwX18wNjZfID0gYXJnMV9fMDY4XyBpblxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbWF0Y2ggc2V4cF9fMDY2XyB3aXRoXG4gICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSBhdG9tX18wNDdfIGFzIF9zZXhwX18wNDlfIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBhdG9tX18wNDdfIHdpdGhcbiAgICAgICAgICAgICAgIHwgXCJMZWZ0XCIgLT5cbiAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzA1N18gX3NleHBfXzA0OV9cbiAgICAgICAgICAgICAgIHwgXCJSaWdodFwiIC0+XG4gICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIF9zZXhwX18wNDlfXG4gICAgICAgICAgICAgICB8IFwiVW5lcXVhbFwiIC0+XG4gICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIF9zZXhwX18wNDlfXG4gICAgICAgICAgICAgICB8IF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5vX3ZhcmlhbnRfbWF0Y2ggKCkpXG4gICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIGF0b21fXzA0N18gOjogc2V4cF9hcmdzX18wNTBfKSBhc1xuICAgICAgICAgICAgICBfc2V4cF9fMDQ5XyAtPlxuICAgICAgICAgICAgICAobWF0Y2ggYXRvbV9fMDQ3XyB3aXRoXG4gICAgICAgICAgICAgICB8IFwiTGVmdFwiIGFzIF90YWdfXzA2M18gLT5cbiAgICAgICAgICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDUwXyB3aXRoXG4gICAgICAgICAgICAgICAgICB8IFsgYXJnMF9fMDY0XyBdIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNjVfID0gX29mX3ZfXzA0NF8gYXJnMF9fMDY0XyBpblxuICAgICAgICAgICAgICAgICAgICBgTGVmdCByZXMwX18wNjVfXG4gICAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgICAgICAgIF90YWdfXzA2M19cbiAgICAgICAgICAgICAgICAgICAgICBfc2V4cF9fMDQ5XylcbiAgICAgICAgICAgICAgIHwgXCJSaWdodFwiIGFzIF90YWdfXzA2MF8gLT5cbiAgICAgICAgICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDUwXyB3aXRoXG4gICAgICAgICAgICAgICAgICB8IFsgYXJnMF9fMDYxXyBdIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNjJfID0gX29mX3ZfXzA0NF8gYXJnMF9fMDYxXyBpblxuICAgICAgICAgICAgICAgICAgICBgUmlnaHQgcmVzMF9fMDYyX1xuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICBfdGFnX18wNjBfXG4gICAgICAgICAgICAgICAgICAgICAgX3NleHBfXzA0OV8pXG4gICAgICAgICAgICAgICB8IFwiVW5lcXVhbFwiIGFzIF90YWdfXzA1MV8gLT5cbiAgICAgICAgICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDUwXyB3aXRoXG4gICAgICAgICAgICAgICAgICB8IFsgYXJnMF9fMDU4XyBdIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNTlfID1cbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBhcmcwX18wNThfIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbIGFyZzBfXzA1Ml87IGFyZzFfXzA1M18gXSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlczBfXzA1NF8gPSBfb2Zfdl9fMDQ0XyBhcmcwX18wNTJfXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmQgcmVzMV9fMDU1XyA9IF9vZl92X18wNDRfIGFyZzFfXzA1M18gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlczBfXzA1NF8sIHJlczFfXzA1NV9cbiAgICAgICAgICAgICAgICAgICAgICB8IHNleHBfXzA1Nl8gLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2V4cF9fMDU2X1xuICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICBgVW5lcXVhbCByZXMwX18wNTlfXG4gICAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgICAgICAgIF90YWdfXzA1MV9cbiAgICAgICAgICAgICAgICAgICAgICBfc2V4cF9fMDQ5XylcbiAgICAgICAgICAgICAgIHwgXyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iubm9fdmFyaWFudF9tYXRjaCAoKSlcbiAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wNDhfIC0+XG4gICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3BvbHlfdmFyXG4gICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgc2V4cF9fMDQ4X1xuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDQ4XyAtPlxuICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3BvbHlfdmFyXG4gICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgc2V4cF9fMDQ4X1xuICAgICAgICAgIHdpdGhcbiAgICAgICAgICB8IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5Ob192YXJpYW50X21hdGNoIC0+XG4gICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iubm9fbWF0Y2hpbmdfdmFyaWFudF9mb3VuZFxuICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgc2V4cF9fMDY2X1xuICAgICAgICBpblxuICAgICAgICByZXMwX18wNjlfLCByZXMxX18wNzBfXG4gICAgICB8IHNleHBfXzA3MV8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnR1cGxlX29mX3NpemVfbl9leHBlY3RlZCBlcnJvcl9zb3VyY2VfXzA1N18gMiBzZXhwX18wNzFfXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6XG4gICAgICAgICdrICd2LlxuICAgICAgICAoJ2sgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ3YgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2ssICd2KSB0XG4gICAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gX29mX2tfXzA3Ml8gX29mX3ZfXzA3M18gKGFyZzBfXzA4MV8sIGFyZzFfXzA4Ml8pIC0+XG4gICAgbGV0IHJlczBfXzA4M18gPSBfb2Zfa19fMDcyXyBhcmcwX18wODFfXG4gICAgYW5kIHJlczFfXzA4NF8gPVxuICAgICAgbWF0Y2ggYXJnMV9fMDgyXyB3aXRoXG4gICAgICB8IGBMZWZ0IHZfXzA3NF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiTGVmdFwiOyBfb2Zfdl9fMDczXyB2X18wNzRfIF1cbiAgICAgIHwgYFJpZ2h0IHZfXzA3NV8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiUmlnaHRcIjsgX29mX3ZfXzA3M18gdl9fMDc1XyBdXG4gICAgICB8IGBVbmVxdWFsIHZfXzA3Nl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmVxdWFsXCJcbiAgICAgICAgICA7IChsZXQgYXJnMF9fMDc3XywgYXJnMV9fMDc4XyA9IHZfXzA3Nl8gaW5cbiAgICAgICAgICAgICBsZXQgcmVzMF9fMDc5XyA9IF9vZl92X18wNzNfIGFyZzBfXzA3N19cbiAgICAgICAgICAgICBhbmQgcmVzMV9fMDgwXyA9IF9vZl92X18wNzNfIGFyZzFfXzA3OF8gaW5cbiAgICAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyByZXMwX18wNzlfOyByZXMxX18wODBfIF0pXG4gICAgICAgICAgXVxuICAgIGluXG4gICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMDgzXzsgcmVzMV9fMDg0XyBdXG4gIDs7XG5cbiAgbGV0IHRfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgJ2sgJ3YuXG4gICAgICAgICdrIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgIC0+ICd2IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgIC0+ICgnaywgJ3YpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICA9XG4gICAgZnVuIF8na19zZXhwX2dyYW1tYXIgXyd2X3NleHBfZ3JhbW1hciAtPlxuICAgIHsgdW50eXBlZCA9XG4gICAgICAgIExpc3RcbiAgICAgICAgICAoQ29uc1xuICAgICAgICAgICAgICggXydrX3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICAgLCBDb25zXG4gICAgICAgICAgICAgICAgICggVmFyaWFudFxuICAgICAgICAgICAgICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJMZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPSBDb25zIChfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlJpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPSBDb25zIChfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlVuZXF1YWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJncyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKENvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggXyd2X3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIENvbnMgKF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIEVtcHR5IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAsIEVtcHR5ICkgKSlcbiAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgTWVyZ2VfZWxlbWVudCA9IHN0cnVjdFxuICB0eXBlICgnbGVmdCwgJ3JpZ2h0KSB0ID1cbiAgICBbIGBMZWZ0IG9mICdsZWZ0XG4gICAgfCBgUmlnaHQgb2YgJ3JpZ2h0XG4gICAgfCBgQm90aCBvZiAnbGVmdCAqICdyaWdodFxuICAgIF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlIDpcbiAgICAgICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICAgICAoJ2xlZnQgLT4gJ2xlZnQgLT4gaW50KVxuICAgICAgICAtPiAoJ3JpZ2h0IC0+ICdyaWdodCAtPiBpbnQpXG4gICAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAgIC0+IGludFxuICAgID1cbiAgICBmdW4gX2NtcF9fbGVmdCBfY21wX19yaWdodCBhX18wODVfIGJfXzA4Nl8gLT5cbiAgICBpZiBTdGRsaWIuKCA9PSApIGFfXzA4NV8gYl9fMDg2X1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDg1XywgYl9fMDg2XyB3aXRoXG4gICAgICB8IGBMZWZ0IF9sZWZ0X18wODdfLCBgTGVmdCBfcmlnaHRfXzA4OF8gLT4gX2NtcF9fbGVmdCBfbGVmdF9fMDg3XyBfcmlnaHRfXzA4OF9cbiAgICAgIHwgYFJpZ2h0IF9sZWZ0X18wODlfLCBgUmlnaHQgX3JpZ2h0X18wOTBfIC0+IF9jbXBfX3JpZ2h0IF9sZWZ0X18wODlfIF9yaWdodF9fMDkwX1xuICAgICAgfCBgQm90aCBfbGVmdF9fMDkxXywgYEJvdGggX3JpZ2h0X18wOTJfIC0+XG4gICAgICAgIGxldCB0X18wOTNfLCB0X18wOTRfID0gX2xlZnRfXzA5MV8gaW5cbiAgICAgICAgbGV0IHRfXzA5NV8sIHRfXzA5Nl8gPSBfcmlnaHRfXzA5Ml8gaW5cbiAgICAgICAgKG1hdGNoIF9jbXBfX2xlZnQgdF9fMDkzXyB0X18wOTVfIHdpdGhcbiAgICAgICAgIHwgMCAtPiBfY21wX19yaWdodCB0X18wOTRfIHRfXzA5Nl9cbiAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgfCB4LCB5IC0+IFN0ZGxpYi5jb21wYXJlIHggeSlcbiAgOztcblxuICBsZXQgZXF1YWwgOlxuICAgICAgICAnbGVmdCAncmlnaHQuXG4gICAgICAgICgnbGVmdCAtPiAnbGVmdCAtPiBib29sKVxuICAgICAgICAtPiAoJ3JpZ2h0IC0+ICdyaWdodCAtPiBib29sKVxuICAgICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgICAtPiBib29sXG4gICAgPVxuICAgIGZ1biBfY21wX19sZWZ0IF9jbXBfX3JpZ2h0IGFfXzA5N18gYl9fMDk4XyAtPlxuICAgIGlmIFN0ZGxpYi4oID09ICkgYV9fMDk3XyBiX18wOThfXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wOTdfLCBiX18wOThfIHdpdGhcbiAgICAgIHwgYExlZnQgX2xlZnRfXzA5OV8sIGBMZWZ0IF9yaWdodF9fMTAwXyAtPiBfY21wX19sZWZ0IF9sZWZ0X18wOTlfIF9yaWdodF9fMTAwX1xuICAgICAgfCBgUmlnaHQgX2xlZnRfXzEwMV8sIGBSaWdodCBfcmlnaHRfXzEwMl8gLT4gX2NtcF9fcmlnaHQgX2xlZnRfXzEwMV8gX3JpZ2h0X18xMDJfXG4gICAgICB8IGBCb3RoIF9sZWZ0X18xMDNfLCBgQm90aCBfcmlnaHRfXzEwNF8gLT5cbiAgICAgICAgbGV0IHRfXzEwNV8sIHRfXzEwNl8gPSBfbGVmdF9fMTAzXyBpblxuICAgICAgICBsZXQgdF9fMTA3XywgdF9fMTA4XyA9IF9yaWdodF9fMTA0XyBpblxuICAgICAgICBTdGRsaWIuKCAmJiApIChfY21wX19sZWZ0IHRfXzEwNV8gdF9fMTA3XykgKF9jbXBfX3JpZ2h0IHRfXzEwNl8gdF9fMTA4XylcbiAgICAgIHwgeCwgeSAtPiBTdGRsaWIuKCA9ICkgeCB5KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICAgICAnbGVmdCAncmlnaHQuXG4gICAgICAgICgnbGVmdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgncmlnaHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuIF9vZl9sZWZ0X18xMDlfIF9vZl9yaWdodF9fMTEwXyAtPiBmdW5jdGlvblxuICAgIHwgYExlZnQgdl9fMTExXyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiTGVmdFwiOyBfb2ZfbGVmdF9fMTA5XyB2X18xMTFfIF1cbiAgICB8IGBSaWdodCB2X18xMTJfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJSaWdodFwiOyBfb2ZfcmlnaHRfXzExMF8gdl9fMTEyXyBdXG4gICAgfCBgQm90aCB2X18xMTNfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJCb3RoXCJcbiAgICAgICAgOyAobGV0IGFyZzBfXzExNF8sIGFyZzFfXzExNV8gPSB2X18xMTNfIGluXG4gICAgICAgICAgIGxldCByZXMwX18xMTZfID0gX29mX2xlZnRfXzEwOV8gYXJnMF9fMTE0X1xuICAgICAgICAgICBhbmQgcmVzMV9fMTE3XyA9IF9vZl9yaWdodF9fMTEwXyBhcmcxX18xMTVfIGluXG4gICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIHJlczBfXzExNl87IHJlczFfXzExN18gXSlcbiAgICAgICAgXVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5NYXAuQ29udGludWVfb3Jfc3RvcCAqKVxubW9kdWxlIENvbnRpbnVlX29yX3N0b3AgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IENvbnRpbnVlXG4gICAgfCBTdG9wXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIGVxdWFsLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlID0gKFN0ZGxpYi5jb21wYXJlIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIENvbnRpbnVlOyBTdG9wIF0gOiB0IGxpc3QpXG4gIGxldCBlcXVhbCA9IChTdGRsaWIuKCA9ICkgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgfCBDb250aW51ZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJDb250aW51ZVwiXG4gICAgIHwgU3RvcCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJTdG9wXCJcbiAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk1hcC5GaW5pc2hlZF9vcl91bmZpbmlzaGVkICopXG5tb2R1bGUgRmluaXNoZWRfb3JfdW5maW5pc2hlZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgRmluaXNoZWRcbiAgICB8IFVuZmluaXNoZWRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgPSAoU3RkbGliLmNvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgYWxsID0gKFsgRmluaXNoZWQ7IFVuZmluaXNoZWQgXSA6IHQgbGlzdClcbiAgbGV0IGVxdWFsID0gKFN0ZGxpYi4oID0gKSA6IHQgLT4gdCAtPiBib29sKVxuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICB8IEZpbmlzaGVkIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkZpbmlzaGVkXCJcbiAgICAgfCBVbmZpbmlzaGVkIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlVuZmluaXNoZWRcIlxuICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdFxuICB0eXBlICgnYSwgJ2IsICdjbXApIHRyZWVcbiAgdHlwZSAnYSBrZXlcbiAgdHlwZSAnY21wIGNtcFxuICB0eXBlICgnYSwgJ2NtcCwgJ3opIGFjY2Vzc19vcHRpb25zXG5cbiAgKCoqIEBpbmxpbmUgKilcbiAgaW5jbHVkZVxuICAgIERpY3Rpb25hcnlfaW1tdXRhYmxlLkFjY2Vzc29yc1xuICAgICAgd2l0aCB0eXBlICdrZXkga2V5IDo9ICdrZXkga2V5XG4gICAgICAgYW5kIHR5cGUgKCdrZXksICdkYXRhLCAnY21wKSB0IDo9ICgna2V5LCAnZGF0YSwgJ2NtcCkgdFxuICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksIF8sICdjbXApIGFjY2Vzc29yIDo9ICgna2V5LCAnY21wLCAnZm4pIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGludmFyaWFudHMgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gYm9vbCkgYWNjZXNzX29wdGlvbnNcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogKF8sIF8sIF8pIHQgLT4gaW50XG5cbiAgdmFsIGFkZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZHVwbGljYXRlLnQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgYWRkX2V4blxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgc2V0XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBhZGRfbXVsdGlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCByZW1vdmVfbXVsdGlcbiAgICA6ICgnaywgJ2NtcCwgKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+ICdrIGtleSAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQpIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGZpbmRfbXVsdGkgOiAoJ2ssICdjbXAsICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gJ3YgbGlzdCkgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgY2hhbmdlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gZjooJ3Ygb3B0aW9uIC0+ICd2IG9wdGlvbikgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCB1cGRhdGVcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiBmOigndiBvcHRpb24gLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgZmluZCA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gJ3Ygb3B0aW9uKSBhY2Nlc3Nfb3B0aW9uc1xuICB2YWwgZmluZF9leG4gOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2KSBhY2Nlc3Nfb3B0aW9uc1xuICB2YWwgcmVtb3ZlIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAoJ2ssICd2LCAnY21wKSB0KSBhY2Nlc3Nfb3B0aW9uc1xuICB2YWwgbWVtIDogKCdrLCAnY21wLCAoJ2ssIF8sICdjbXApIHQgLT4gJ2sga2V5IC0+IGJvb2wpIGFjY2Vzc19vcHRpb25zXG4gIHZhbCBpdGVyX2tleXMgOiAoJ2ssIF8sIF8pIHQgLT4gZjooJ2sga2V5IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAoXywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlcmkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50XG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHRcbiAgICAgICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOigndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpXG4gICAgICAgIC0+IHVuaXQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgbWFwIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooJ3YxIC0+ICd2MikgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgdmFsIG1hcGkgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICd2MikgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICB2YWwgZm9sZFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKVxuICAgIC0+ICdhY2NcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAoJ2FjYywgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjYyAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHRcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylcbiAgICAtPiAnYWNjXG5cbiAgdmFsIGZvbGQyXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHRcbiAgICAgICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgICAgLT4gaW5pdDonYWNjXG4gICAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTooJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiAnYWNjIC0+ICdhY2MpXG4gICAgICAgIC0+ICdhY2MgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgZmlsdGVyX2tleXMgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KCdrIGtleSAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0XG4gIHZhbCBmaWx0ZXIgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgdmFsIGZpbHRlcmkgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooJ3YxIC0+ICd2MiBvcHRpb24pIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlcl9tYXBpXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICd2MiBvcHRpb24pXG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondjEgLT4gKCd2MiwgJ3YzKSBFaXRoZXIudClcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCAqICgnaywgJ3YzLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KCd2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZjooJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBjb21iaW5lX2Vycm9yc1xuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YgT3JfZXJyb3IudCwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgdW56aXAgOiAoJ2ssICd2MSAqICd2MiwgJ2NtcCkgdCAtPiAoJ2ssICd2MSwgJ2NtcCkgdCAqICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgdmFsIGNvbXBhcmVfZGlyZWN0XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCd2IC0+ICd2IC0+IGludCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGludCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBlcXVhbFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgndiAtPiAndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gYm9vbCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBrZXlzIDogKCdrLCBfLCBfKSB0IC0+ICdrIGtleSBsaXN0XG4gIHZhbCBkYXRhIDogKF8sICd2LCBfKSB0IC0+ICd2IGxpc3RcblxuICB2YWwgdG9fYWxpc3RcbiAgICA6ICA/a2V5X29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gKCdrLCAndiwgXykgdFxuICAgIC0+ICgnayBrZXkgKiAndikgbGlzdFxuXG4gIHZhbCBtZXJnZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gKCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ3YzIG9wdGlvbilcbiAgICAgICAgLT4gKCdrLCAndjMsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgbWVyZ2VfZGlzam9pbnRfZXhuXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0KSBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBtZXJnZV9za2V3ZWRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gY29tYmluZTooa2V5OidrIGtleSAtPiAndiAtPiAndiAtPiAndilcbiAgICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiBkYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgICAgICAtPiAoJ2sga2V5LCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiBkYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgICAgICAtPiBpbml0OidhY2NcbiAgICAgICAgLT4gZjooJ2FjYyAtPiAoJ2sga2V5LCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+ICdhY2MpXG4gICAgICAgIC0+ICdhY2MgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgbWluX2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrIGtleSAqICd2KSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayBrZXkgKiAndlxuICB2YWwgbWF4X2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrIGtleSAqICd2KSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayBrZXkgKiAndlxuICB2YWwgZm9yX2FsbCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0c2kgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgc3VtXG4gICAgOiAgKG1vZHVsZSBDb250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAtPiAoJ2ssICd2LCBfKSB0XG4gICAgLT4gZjooJ3YgLT4gJ2EpXG4gICAgLT4gJ2FcblxuICB2YWwgc3VtaVxuICAgIDogIChtb2R1bGUgQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgLT4gKCdrLCAndiwgXykgdFxuICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYSlcbiAgICAtPiAnYVxuXG4gIHZhbCBzcGxpdFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gJ2sga2V5XG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2sga2V5ICogJ3YpIG9wdGlvbiAqICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgc3BsaXRfbGVfZ3RcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBzcGxpdF9sdF9nZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGFwcGVuZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsIGxvd2VyX3BhcnQ6KCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiB1cHBlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF0gKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgc3VicmFuZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+IGxvd2VyX2JvdW5kOidrIGtleSBNYXliZV9ib3VuZC50XG4gICAgICAgIC0+IHVwcGVyX2JvdW5kOidrIGtleSBNYXliZV9ib3VuZC50XG4gICAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+IG1pbjonayBrZXlcbiAgICAgICAgLT4gbWF4OidrIGtleVxuICAgICAgICAtPiBpbml0OidhY2NcbiAgICAgICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylcbiAgICAgICAgLT4gJ2FjYyApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCByYW5nZV90b19hbGlzdFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4gbWluOidrIGtleSAtPiBtYXg6J2sga2V5IC0+ICgnayBrZXkgKiAndikgbGlzdCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgICAgICAtPiAnayBrZXlcbiAgICAgICAgLT4gKCdrIGtleSAqICd2KSBvcHRpb24gKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgbnRoIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnQgLT4gKCdrIGtleSAqICd2KSBvcHRpb25cbiAgdmFsIG50aF9leG4gOiAoJ2ssICd2LCAnY21wKSB0IC0+IGludCAtPiAnayBrZXkgKiAndlxuICB2YWwgcmFuayA6ICgnaywgJ2NtcCwgKCdrLCBfLCAnY21wKSB0IC0+ICdrIGtleSAtPiBpbnQgb3B0aW9uKSBhY2Nlc3Nfb3B0aW9uc1xuICB2YWwgdG9fdHJlZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrIGtleSwgJ3YsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgICAgICAtPiA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvOidrIGtleVxuICAgICAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOidrIGtleVxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+ICgnayBrZXkgKiAndikgU2VxdWVuY2UudCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiBjb21wYXJlOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpXG4gICAgICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgICAgICAtPiAna2V5XG4gICAgICAgIC0+ICgnayBrZXkgKiAndikgb3B0aW9uIClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiBzZWdtZW50X29mOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgICAgIC0+ICgnayBrZXkgKiAndikgb3B0aW9uIClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+IGNvbXBhcmU6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgICAgICAtPiBsb3dlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgICAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgbW9kdWxlIE1ha2VfYXBwbGljYXRpdmVfdHJhdmVyc2FscyAoQSA6IEFwcGxpY2F0aXZlLkxhenlfYXBwbGljYXRpdmUpIDogc2lnXG4gICAgdmFsIG1hcGlcbiAgICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICd2MiBBLnQpXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCBBLnRcblxuICAgIHZhbCBmaWx0ZXJfbWFwaVxuICAgICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondjEgLT4gJ3YyIG9wdGlvbiBBLnQpXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCBBLnRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnaywgJ3YsICdjbXApIHRcbiAgdHlwZSAoJ2ssICd2LCAnY21wKSB0cmVlXG4gIHR5cGUgJ2sga2V5XG4gIHR5cGUgKCdhLCAnY21wLCAneikgY3JlYXRlX29wdGlvbnNcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBhY2Nlc3Nfb3B0aW9uc1xuICB0eXBlICdjbXAgY21wXG5cbiAgKCoqIEBpbmxpbmUgKilcbiAgaW5jbHVkZVxuICAgIERpY3Rpb25hcnlfaW1tdXRhYmxlLkNyZWF0b3JzXG4gICAgICB3aXRoIHR5cGUgJ2tleSBrZXkgOj0gJ2tleSBrZXlcbiAgICAgICBhbmQgdHlwZSAoJ2tleSwgJ2RhdGEsICdjbXApIHQgOj0gKCdrZXksICdkYXRhLCAnY21wKSB0XG4gICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgXywgJ2NtcCkgY3JlYXRvciA6PSAoJ2tleSwgJ2NtcCwgJ2ZuKSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBlbXB0eSA6ICgnaywgJ2NtcCwgKCdrLCBfLCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuICB2YWwgc2luZ2xldG9uIDogKCdrLCAnY21wLCAnayBrZXkgLT4gJ3YgLT4gKCdrLCAndiwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgbWFwX2tleXNcbiAgICA6ICggJ2syXG4gICAgICAsICdjbXAyXG4gICAgICAsICgnazEsICd2LCAnY21wMSkgdFxuICAgICAgICAtPiBmOignazEga2V5IC0+ICdrMiBrZXkpXG4gICAgICAgIC0+IFsgYE9rIG9mICgnazIsICd2LCAnY21wMikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrMiBrZXkgXSApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBtYXBfa2V5c19leG5cbiAgICA6ICggJ2syXG4gICAgICAsICdjbXAyXG4gICAgICAsICgnazEsICd2LCAnY21wMSkgdCAtPiBmOignazEga2V5IC0+ICdrMiBrZXkpIC0+ICgnazIsICd2LCAnY21wMikgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCB0cmFuc3Bvc2Vfa2V5c1xuICAgIDogKCAnazFcbiAgICAgICwgJ2NtcDFcbiAgICAgICwgKCAnazJcbiAgICAgICAgLCAnY21wMlxuICAgICAgICAsICgnazEsICgnazIsICdhLCAnY21wMikgdCwgJ2NtcDEpIHQgLT4gKCdrMiwgKCdrMSwgJ2EsICdjbXAxKSB0LCAnY21wMikgdCApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zIClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGFycmF5IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGFycmF5IC0+ICgnaywgJ3YsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAoJ2ssICdjbXAsIGxlbjppbnQgLT4gZjooaW50IC0+ICdrIGtleSAqICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndikgbGlzdCAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sga2V5IF0gKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBsaXN0IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfZXhuIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gKCdrLCAndiwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfbXVsdGlcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBsaXN0IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfZm9sZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndjEpIGxpc3QgLT4gaW5pdDondjIgLT4gZjooJ3YyIC0+ICd2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0IClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X3JlZHVjZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndikgbGlzdCAtPiBmOigndiAtPiAndiAtPiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBrZXkgXVxuICAgICAgKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3JcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfZXhuXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2LCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZV9tdWx0aVxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZV9mb2xkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2MSkgU2VxdWVuY2UudFxuICAgICAgICAtPiBpbml0Oid2MlxuICAgICAgICAtPiBmOigndjIgLT4gJ3YxIC0+ICd2MilcbiAgICAgICAgLT4gKCdrLCAndjIsICdjbXApIHQgKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfcmVkdWNlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+IGY6KCd2IC0+ICd2IC0+ICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAndiBsaXN0XG4gICAgICAgIC0+IGdldF9rZXk6KCd2IC0+ICdrIGtleSlcbiAgICAgICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdIClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3JcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAndiBsaXN0IC0+IGdldF9rZXk6KCd2IC0+ICdrIGtleSkgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50IClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlfZXhuXG4gICAgOiAoJ2ssICdjbXAsICd2IGxpc3QgLT4gZ2V0X2tleTooJ3YgLT4gJ2sga2V5KSAtPiAoJ2ssICd2LCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X211bHRpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgJ3YgbGlzdCAtPiBnZXRfa2V5OigndiAtPiAnayBrZXkpIC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X2ZvbGRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAndiBsaXN0XG4gICAgICAgIC0+IGdldF9rZXk6KCd2IC0+ICdrIGtleSlcbiAgICAgICAgLT4gaW5pdDonYWNjXG4gICAgICAgIC0+IGY6KCdhY2MgLT4gJ3YgLT4gJ2FjYylcbiAgICAgICAgLT4gKCdrLCAnYWNjLCAnY21wKSB0IClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlfcmVkdWNlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgJ3YgbGlzdCAtPiBnZXRfa2V5OigndiAtPiAnayBrZXkpIC0+IGY6KCd2IC0+ICd2IC0+ICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgaXRlcmk6KGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0KVxuICAgICAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sga2V5IF0gKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfaXRlcmlfZXhuXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgaXRlcmk6KGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0KSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX3RyZWUgOiAoJ2ssICdjbXAsICgnayBrZXksICd2LCAnY21wKSB0cmVlIC0+ICgnaywgJ3YsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHRcbiAgdHlwZSAoJ2EsICdiLCAnYykgdHJlZVxuICB0eXBlICdhIGtleVxuICB0eXBlICdhIGNtcFxuICB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9uc1xuICB0eXBlICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9uc1xuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgdHJlZVxuICAgICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBrZXlcbiAgICAgIHdpdGggdHlwZSAnYSBjbXAgOj0gJ2EgY21wXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGNyZWF0ZV9vcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9uc1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgYWNjZXNzX29wdGlvbnNcblxuICBpbmNsdWRlXG4gICAgQWNjZXNzb3JzX2dlbmVyaWNcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSB0cmVlXG4gICAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIGtleVxuICAgICAgd2l0aCB0eXBlICdhIGNtcCA6PSAnYSBjbXBcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgYWNjZXNzX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIGFjY2Vzc19vcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgU19wb2x5ID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICgnYSwgJ2IpIHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYikgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IpIHRyZWVcbiAgICAgIHdpdGggdHlwZSAnayBrZXkgOj0gJ2tcbiAgICAgIHdpdGggdHlwZSAnYyBjbXAgOj0gY29tcGFyYXRvcl93aXRuZXNzXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGNyZWF0ZV9vcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBXaXRob3V0X2NvbXBhcmF0b3IudFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aG91dF9jb21wYXJhdG9yLnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gIG1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gICAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gICAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQ29tcGFyZV9tID0gc2lnIGVuZFxuICBtb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxuICBtb2R1bGUgdHlwZSBIYXNoX2ZvbGRfbSA9IEhhc2hlci5TXG5cbiAgdmFsIHNleHBfb2ZfbV9fdFxuICAgIDogIChtb2R1bGUgU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gKCd2IC0+IFNleHAudClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gU2V4cC50XG5cbiAgdmFsIG1fX3Rfb2Zfc2V4cFxuICAgIDogIChtb2R1bGUgTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gJ2sgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2NtcClcbiAgICAtPiAoU2V4cC50IC0+ICd2KVxuICAgIC0+IFNleHAudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgbV9fdF9zZXhwX2dyYW1tYXJcbiAgICA6ICAobW9kdWxlIE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gJ3YgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgdmFsIGNvbXBhcmVfbV9fdFxuICAgIDogIChtb2R1bGUgQ29tcGFyZV9tKVxuICAgIC0+ICgndiAtPiAndiAtPiBpbnQpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBpbnRcblxuICB2YWwgZXF1YWxfbV9fdFxuICAgIDogIChtb2R1bGUgRXF1YWxfbSlcbiAgICAtPiAoJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGJvb2xcblxuICB2YWwgaGFzaF9mb2xkX21fX3RcbiAgICA6ICAobW9kdWxlIEhhc2hfZm9sZF9tIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gKEhhc2guc3RhdGUgLT4gJ3YgLT4gSGFzaC5zdGF0ZSlcbiAgICAtPiBIYXNoLnN0YXRlXG4gICAgLT4gKCdrLCAndiwgXykgdFxuICAgIC0+IEhhc2guc3RhdGVcbmVuZFxuXG5tb2R1bGUgdHlwZSBNYXAgPSBzaWdcbiAgKCoqIFtNYXBdIGlzIGEgZnVuY3Rpb25hbCBkYXRhIHN0cnVjdHVyZSAoYmFsYW5jZWQgYmluYXJ5IHRyZWUpIGltcGxlbWVudGluZyBmaW5pdGUgbWFwc1xuICAgICAgb3ZlciBhIHRvdGFsbHktb3JkZXJlZCBkb21haW4sIGNhbGxlZCBhIFwia2V5XCIuICopXG5cbiAgdHlwZSAoISdrZXksICshJ3ZhbHVlLCAhJ2NtcCkgdFxuXG4gIG1vZHVsZSBPcl9kdXBsaWNhdGUgPSBPcl9kdXBsaWNhdGVcbiAgbW9kdWxlIENvbnRpbnVlX29yX3N0b3AgPSBDb250aW51ZV9vcl9zdG9wXG5cbiAgbW9kdWxlIEZpbmlzaGVkX29yX3VuZmluaXNoZWQgOiBzaWdcbiAgICB0eXBlIHQgPSBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnQgPVxuICAgICAgfCBGaW5pc2hlZFxuICAgICAgfCBVbmZpbmlzaGVkXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuICAgIGluY2x1ZGUgUHB4X2VudW1lcmF0ZV9saWIuRW51bWVyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgICgqKiBNYXBzIFtDb250aW51ZV0gdG8gW0ZpbmlzaGVkXSBhbmQgW1N0b3BdIHRvIFtVbmZpbmlzaGVkXS4gKilcbiAgICB2YWwgb2ZfY29udGludWVfb3Jfc3RvcCA6IENvbnRpbnVlX29yX3N0b3AudCAtPiB0XG5cbiAgICAoKiogTWFwcyBbRmluaXNoZWRdIHRvIFtDb250aW51ZV0gYW5kIFtVbmZpbmlzaGVkXSB0byBbU3RvcF0uICopXG4gICAgdmFsIHRvX2NvbnRpbnVlX29yX3N0b3AgOiB0IC0+IENvbnRpbnVlX29yX3N0b3AudFxuICBlbmRcblxuICBtb2R1bGUgTWVyZ2VfZWxlbWVudCA6IHNpZ1xuICAgIHR5cGUgKCdsZWZ0LCAncmlnaHQpIHQgPVxuICAgICAgWyBgTGVmdCBvZiAnbGVmdFxuICAgICAgfCBgUmlnaHQgb2YgJ3JpZ2h0XG4gICAgICB8IGBCb3RoIG9mICdsZWZ0ICogJ3JpZ2h0XG4gICAgICBdXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwX29mXVxuXG4gICAgdmFsIGNvbXBhcmVcbiAgICAgIDogICgnbGVmdCAtPiAnbGVmdCAtPiBpbnQpXG4gICAgICAtPiAoJ3JpZ2h0IC0+ICdyaWdodCAtPiBpbnQpXG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IGludFxuXG4gICAgdmFsIGVxdWFsXG4gICAgICA6ICAoJ2xlZnQgLT4gJ2xlZnQgLT4gYm9vbClcbiAgICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGJvb2wpXG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IGJvb2xcblxuICAgIHZhbCBzZXhwX29mX3RcbiAgICAgIDogICgnbGVmdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ3JpZ2h0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgbGVmdCA6ICgnbGVmdCwgXykgdCAtPiAnbGVmdCBvcHRpb25cbiAgICB2YWwgcmlnaHQgOiAoXywgJ3JpZ2h0KSB0IC0+ICdyaWdodCBvcHRpb25cbiAgICB2YWwgbGVmdF92YWx1ZSA6ICgnbGVmdCwgXykgdCAtPiBkZWZhdWx0OidsZWZ0IC0+ICdsZWZ0XG4gICAgdmFsIHJpZ2h0X3ZhbHVlIDogKF8sICdyaWdodCkgdCAtPiBkZWZhdWx0OidyaWdodCAtPiAncmlnaHRcblxuICAgIHZhbCB2YWx1ZXNcbiAgICAgIDogICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiBsZWZ0X2RlZmF1bHQ6J2xlZnRcbiAgICAgIC0+IHJpZ2h0X2RlZmF1bHQ6J3JpZ2h0XG4gICAgICAtPiAnbGVmdCAqICdyaWdodFxuICBlbmRcblxuICAoKiogVGVzdCBpZiB0aGUgaW52YXJpYW50cyBvZiB0aGUgaW50ZXJuYWwgQVZMIHNlYXJjaCB0cmVlIGhvbGQuICopXG4gIHZhbCBpbnZhcmlhbnRzIDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIGEgZmlyc3QtY2xhc3MgbW9kdWxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gYnVpbGQgb3RoZXIgbWFwL3NldC9ldGMuXG4gICAgICB3aXRoIHRoZSBzYW1lIG5vdGlvbiBvZiBjb21wYXJpc29uLiAqKVxuICB2YWwgY29tcGFyYXRvcl9zIDogKCdhLCBfLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuXG4gIHZhbCBjb21wYXJhdG9yIDogKCdhLCBfLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG5cbiAgKCoqIFRoZSBlbXB0eSBtYXAuICopXG4gIHZhbCBlbXB0eSA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIEEgbWFwIHdpdGggb25lIChrZXksIGRhdGEpIHBhaXIuICopXG4gIHZhbCBzaW5nbGV0b24gOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgLT4gJ2IgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLiAqKVxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBsaXN0IHdpdGggdW5pcXVlIGtleXMsIHJldHVybmluZyBhbiBlcnJvciBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuICopXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBsaXN0IHdpdGggdW5pcXVlIGtleXMsIHJhaXNpbmcgYW4gZXhjZXB0aW9uIGlmXG4gICAgICBkdXBsaWNhdGUgWydhXSBrZXlzIGFyZSBmb3VuZC4gKilcbiAgdmFsIG9mX2FsaXN0X2V4biA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EgKiAnYikgbGlzdCAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBsaXN0IHdpdGggcG9zc2libHkgcmVwZWF0ZWQga2V5cy4gVGhlIHZhbHVlcyBpblxuICAgICAgdGhlIG1hcCBmb3IgYSBnaXZlbiBrZXkgYXBwZWFyIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgZGlkIGluIHRoZSBhc3NvY2lhdGlvblxuICAgICAgbGlzdC4gKilcbiAgdmFsIG9mX2FsaXN0X211bHRpXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcblxuICAoKiogQ29tYmluZXMgYW4gYXNzb2NpYXRpb24gbGlzdCBpbnRvIGEgbWFwLCBmb2xkaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy4gVGhlIGFjY3VtdWxhdG9yIGlzIHBlci1rZXkuXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgICMgKGxldCBtYXAgPVxuICAgICAgICAgICAgIFN0cmluZy5NYXAub2ZfYWxpc3RfZm9sZFxuICAgICAgICAgICAgICAgWyBcImFcIiwgMTsgXCJhXCIsIDEwOyBcImJcIiwgMjsgXCJiXCIsIDIwOyBcImJcIiwgMjAwIF1cbiAgICAgICAgICAgICAgIH5pbml0OkludC5TZXQuZW1wdHlcbiAgICAgICAgICAgICAgIH5mOlNldC5hZGRcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgcHJpbnRfcyBbJXNleHAgKG1hcCA6IEludC5TZXQudCBTdHJpbmcuTWFwLnQpXSk7O1xuICAgICAgICAoKGEgKDEgMTApKSAoYiAoMiAyMCAyMDApKSlcbiAgICAgICAgLSA6IHVuaXQgPSAoKVxuICAgICAgXX1cbiAgKilcbiAgdmFsIG9mX2FsaXN0X2ZvbGRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAnYiAtPiAnYylcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgKCoqIENvbWJpbmVzIGFuIGFzc29jaWF0aW9uIGxpc3QgaW50byBhIG1hcCwgcmVkdWNpbmcgdG9nZXRoZXIgYm91bmQgdmFsdWVzIHdpdGggY29tbW9uXG4gICAgICBrZXlzLiAqKVxuICB2YWwgb2ZfYWxpc3RfcmVkdWNlXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBmOignYiAtPiAnYiAtPiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIFtvZl9pdGVyaSB+aXRlcmldIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RdLCBleGNlcHQgdGhhdCBpbnN0ZWFkIG9mIHRha2luZyBhIGNvbmNyZXRlXG4gICAgICBkYXRhIHN0cnVjdHVyZSwgaXQgdGFrZXMgYW4gaXRlcmF0aW9uIGZ1bmN0aW9uLiAgRm9yIGluc3RhbmNlLCB0byBjb252ZXJ0IGEgc3RyaW5nIHRhYmxlXG4gICAgICBpbnRvIGEgbWFwOiBbb2ZfaXRlcmkgKG1vZHVsZSBTdHJpbmcpIH5mOihIYXNodGJsLml0ZXJpIHRhYmxlKV0uICBJdCBpcyBmYXN0ZXIgdGhhblxuICAgICAgYWRkaW5nIHRoZSBlbGVtZW50cyBvbmUgYnkgb25lLiAqKVxuICB2YWwgb2ZfaXRlcmlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gICgqKiBMaWtlIFtvZl9pdGVyaV0gZXhjZXB0IHRoYXQgaXQgcmFpc2VzIGFuIGV4Y2VwdGlvbiBpZiBkdXBsaWNhdGUgWydhXSBrZXlzIGFyZSBmb3VuZC4gKilcbiAgdmFsIG9mX2l0ZXJpX2V4blxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGEgc29ydGVkIGFycmF5IG9mIGtleS1kYXRhIHBhaXJzLiBUaGUgaW5wdXQgYXJyYXkgbXVzdCBiZSBzb3J0ZWRcbiAgICAgIChlaXRoZXIgaW4gYXNjZW5kaW5nIG9yIGRlc2NlbmRpbmcgb3JkZXIpLCBhcyBnaXZlbiBieSB0aGUgcmVsZXZhbnQgY29tcGFyYXRvciwgYW5kXG4gICAgICBtdXN0IG5vdCBjb250YWluIGR1cGxpY2F0ZSBrZXlzLiBJZiBlaXRoZXIgb2YgdGhlc2UgY29uZGl0aW9ucyBkb2VzIG5vdCBob2xkLFxuICAgICAgYW4gZXJyb3IgaXMgcmV0dXJuZWQuICAqKVxuICB2YWwgb2Zfc29ydGVkX2FycmF5XG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGFycmF5XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIExpa2UgW29mX3NvcnRlZF9hcnJheV0gZXhjZXB0IHRoYXQgaXQgcmV0dXJucyBhIG1hcCB3aXRoIGJyb2tlbiBpbnZhcmlhbnRzIHdoZW4gYW5cbiAgICAgIFtFcnJvcl0gd291bGQgaGF2ZSBiZWVuIHJldHVybmVkLiAqKVxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBhcnJheVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogW29mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIGMgfmxlbiB+Zl0gYmVoYXZlcyBsaWtlIFtvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGNcbiAgICAgIChBcnJheS5pbml0IGxlbiB+ZildLCB3aXRoIHRoZSBhZGRpdGlvbmFsIHJlc3RyaWN0aW9uIHRoYXQgYSBkZWNyZWFzaW5nIG9yZGVyIGlzIG5vdFxuICAgICAgc3VwcG9ydGVkLiAgVGhlIGFkdmFudGFnZSBpcyBub3QgcmVxdWlyaW5nIHlvdSB0byBhbGxvY2F0ZSBhbiBpbnRlcm1lZGlhdGUgYXJyYXkuICBbZl1cbiAgICAgIHdpbGwgYmUgY2FsbGVkIHdpdGggMCwgMSwgLi4uIFtsZW4gLSAxXSwgaW4gb3JkZXIuICopXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiBmOihpbnQgLT4gJ2EgKiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIFtvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX3NvcnRlZF9hcnJheSBjIChTZXF1ZW5jZS50b19hcnJheVxuICAgICAgc2VxKV0sIGJ1dCBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGFycmF5LlxuXG4gICAgICBUaGUgc2VxdWVuY2Ugd2lsbCBiZSBmb2xkZWQgb3ZlciBvbmNlLCBhbmQgdGhlIGFkZGl0aW9uYWwgdGltZSBjb21wbGV4aXR5IGlzIHtlIE8obil9LlxuICAqKVxuICB2YWwgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZVxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnayAqICd2KSBTZXF1ZW5jZS50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSB3aXRoIHVuaXF1ZSBrZXlzLlxuXG4gICAgICBbb2Zfc2VxdWVuY2UgYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3QgYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpXSBidXRcbiAgICAgIGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC5cblxuICAgICAgSWYgeW91ciBzZXF1ZW5jZSBpcyBpbmNyZWFzaW5nLCB1c2UgW29mX2luY3JlYXNpbmdfc2VxdWVuY2VdLlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sgKiAndikgU2VxdWVuY2UudFxuICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBdXG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSB3aXRoIHVuaXF1ZSBrZXlzLCByZXR1cm5pbmcgYW4gZXJyb3IgaWZcbiAgICAgIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLlxuXG4gICAgICBbb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3Rfb3JfZXJyb3IgYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpXVxuICAgICAgYnV0IGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX29yX2Vycm9yXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIHdpdGggdW5pcXVlIGtleXMsIHJhaXNpbmcgYW4gZXhjZXB0aW9uIGlmXG4gICAgICBkdXBsaWNhdGUgWydhXSBrZXlzIGFyZSBmb3VuZC5cblxuICAgICAgW29mX3NlcXVlbmNlX2V4biBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF9leG4gYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpXSBidXRcbiAgICAgIGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX2V4blxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCBwb3NzaWJseSByZXBlYXRlZCBrZXlzLiBUaGUgdmFsdWVzIGluXG4gICAgICB0aGUgbWFwIGZvciBhIGdpdmVuIGtleSBhcHBlYXIgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhleSBkaWQgaW4gdGhlIGFzc29jaWF0aW9uXG4gICAgICBsaXN0LlxuXG4gICAgICBbb2Zfc2VxdWVuY2VfbXVsdGkgYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfZXhuIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV0gYnV0XG4gICAgICBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9tdWx0aVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIENvbWJpbmVzIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIGludG8gYSBtYXAsIGZvbGRpbmcgdG9nZXRoZXIgYm91bmQgdmFsdWVzIHdpdGggY29tbW9uXG4gICAgICBrZXlzLlxuXG4gICAgICBbb2Zfc2VxdWVuY2VfZm9sZCBjIHNlcSB+aW5pdCB+Zl0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF9mb2xkIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKSB+aW5pdCB+Zl1cbiAgICAgIGJ1dCBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9mb2xkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSBpbnRvIGEgbWFwLCByZWR1Y2luZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9yZWR1Y2UgYyBzZXEgfmZdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfcmVkdWNlIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKSB+Zl1cbiAgICAgIGJ1dCBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfcmVkdWNlXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBmOignYiAtPiAnYiAtPiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENvbnN0cnVjdHMgYSBtYXAgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCB3aGVyZSBbZ2V0X2tleV0gZXh0cmFjdHMgYSBrZXkgZnJvbSBhIHZhbHVlLlxuICAqKVxuICB2YWwgb2ZfbGlzdF93aXRoX2tleVxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICd2IGxpc3RcbiAgICAtPiBnZXRfa2V5OigndiAtPiAnaylcbiAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sgXVxuXG4gICgqKiBMaWtlIFtvZl9saXN0X3dpdGhfa2V5XTsgcmV0dXJucyBbRXJyb3JdIG9uIGR1cGxpY2F0ZSBrZXkuICopXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gJ3YgbGlzdFxuICAgIC0+IGdldF9rZXk6KCd2IC0+ICdrKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBMaWtlIFtvZl9saXN0X3dpdGhfa2V5XTsgcmFpc2VzIG9uIGR1cGxpY2F0ZSBrZXkuICopXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X2V4blxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICd2IGxpc3RcbiAgICAtPiBnZXRfa2V5OigndiAtPiAnaylcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIExpa2UgW29mX2xpc3Rfd2l0aF9rZXldOyBwcm9kdWNlcyBsaXN0cyBvZiBhbGwgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlYWNoIGtleS4gKilcbiAgdmFsIG9mX2xpc3Rfd2l0aF9rZXlfbXVsdGlcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAndiBsaXN0XG4gICAgLT4gZ2V0X2tleTooJ3YgLT4gJ2spXG4gICAgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIExpa2UgW29mX2xpc3Rfd2l0aF9rZXldOyByZXNvbHZlcyBkdXBsaWNhdGUga2V5cyB0aGUgc2FtZSB3YXkgW29mX2FsaXN0X2ZvbGRdIGRvZXMuICopXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X2ZvbGRcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAndiBsaXN0XG4gICAgLT4gZ2V0X2tleTooJ3YgLT4gJ2spXG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooJ2FjYyAtPiAndiAtPiAnYWNjKVxuICAgIC0+ICgnaywgJ2FjYywgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFtvZl9saXN0X3dpdGhfa2V5XTsgcmVzb2x2ZXMgZHVwbGljYXRlIGtleXMgdGhlIHNhbWUgd2F5IFtvZl9hbGlzdF9yZWR1Y2VdIGRvZXMuICopXG4gIHZhbCBvZl9saXN0X3dpdGhfa2V5X3JlZHVjZVxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICd2IGxpc3RcbiAgICAtPiBnZXRfa2V5OigndiAtPiAnaylcbiAgICAtPiBmOigndiAtPiAndiAtPiAndilcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFRlc3RzIHdoZXRoZXIgYSBtYXAgaXMgZW1wdHkuICopXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogW2xlbmd0aCBtYXBdIHJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBbbWFwXS4gIE8oMSksIGJ1dCBbVHJlZS5sZW5ndGhdIGlzXG4gICAgICBPKG4pLiAqKVxuICB2YWwgbGVuZ3RoIDogKF8sIF8sIF8pIHQgLT4gaW50XG5cbiAgKCoqIFJldHVybnMgYSBuZXcgbWFwIHdpdGggdGhlIHNwZWNpZmllZCBuZXcgYmluZGluZzsgaWYgdGhlIGtleSB3YXMgYWxyZWFkeSBib3VuZCwgaXRzXG4gICAgICBwcmV2aW91cyBiaW5kaW5nIGRpc2FwcGVhcnMuICopXG4gIHZhbCBzZXQgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW2FkZCB0IH5rZXkgfmRhdGFdIGFkZHMgYSBuZXcgZW50cnkgdG8gW3RdIG1hcHBpbmcgW2tleV0gdG8gW2RhdGFdIGFuZCByZXR1cm5zIFtgT2tdXG4gICAgICB3aXRoIHRoZSBuZXcgbWFwLCBvciBpZiBba2V5XSBpcyBhbHJlYWR5IHByZXNlbnQgaW4gW3RdLCByZXR1cm5zIFtgRHVwbGljYXRlXS4gKilcbiAgdmFsIGFkZCA6ICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9kdXBsaWNhdGUudFxuXG4gIHZhbCBhZGRfZXhuIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIElmIFtrZXldIGlzIG5vdCBwcmVzZW50IHRoZW4gYWRkIGEgc2luZ2xldG9uIGxpc3QsIG90aGVyd2lzZSwgY29ucyBkYXRhIG9udG8gdGhlXG4gICAgICBoZWFkIG9mIHRoZSBleGlzdGluZyBsaXN0LiAqKVxuICB2YWwgYWRkX211bHRpIDogKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+IGtleTonayAtPiBkYXRhOid2IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBJZiB0aGUga2V5IGlzIHByZXNlbnQsIHRoZW4gcmVtb3ZlIGl0cyBoZWFkIGVsZW1lbnQ7IGlmIHRoZSByZXN1bHQgaXMgZW1wdHksIHJlbW92ZVxuICAgICAgdGhlIGtleS4gKilcbiAgdmFsIHJlbW92ZV9tdWx0aSA6ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHRcblxuICAoKiogUmV0dXJucyB0aGUgdmFsdWUgYm91bmQgdG8gdGhlIGdpdmVuIGtleSwgb3IgdGhlIGVtcHR5IGxpc3QgaWYgdGhlcmUgaXMgbm9uZS4gKilcbiAgdmFsIGZpbmRfbXVsdGkgOiAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4gJ2sgLT4gJ3YgbGlzdFxuXG4gICgqKiBbY2hhbmdlIHQga2V5IH5mXSByZXR1cm5zIGEgbmV3IG1hcCBbbV0gdGhhdCBpcyB0aGUgc2FtZSBhcyBbdF0gb24gYWxsIGtleXMgZXhjZXB0XG4gICAgICBmb3IgW2tleV0sIGFuZCB3aG9zZSB2YWx1ZSBmb3IgW2tleV0gaXMgZGVmaW5lZCBieSBbZl0sIGkuZS4sIFtmaW5kIG0ga2V5ID0gZiAoZmluZFxuICAgICAgdCBrZXkpXS4gKilcbiAgdmFsIGNoYW5nZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gZjooJ3Ygb3B0aW9uIC0+ICd2IG9wdGlvbikgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbdXBkYXRlIHQga2V5IH5mXSBpcyBbY2hhbmdlIHQga2V5IH5mOihmdW4gbyAtPiBTb21lIChmIG8pKV0uICopXG4gIHZhbCB1cGRhdGUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+IGY6KCd2IG9wdGlvbiAtPiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBSZXR1cm5zIFtTb21lIHZhbHVlXSBib3VuZCB0byB0aGUgZ2l2ZW4ga2V5LCBvciBbTm9uZV0gaWYgbm9uZSBleGlzdHMuICopXG4gIHZhbCBmaW5kIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiAndiBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgdmFsdWUgYm91bmQgdG8gdGhlIGdpdmVuIGtleSwgcmFpc2luZyBbU3RkbGliLk5vdF9mb3VuZF0gb3IgW05vdF9mb3VuZF9zXVxuICAgICAgaWYgbm9uZSBleGlzdHMuICopXG4gIHZhbCBmaW5kX2V4biA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gJ3ZcblxuICAoKiogUmV0dXJucyBhIG5ldyBtYXAgd2l0aCBhbnkgYmluZGluZyBmb3IgdGhlIGtleSBpbiBxdWVzdGlvbiByZW1vdmVkLiAqKVxuICB2YWwgcmVtb3ZlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFttZW0gbWFwIGtleV0gdGVzdHMgd2hldGhlciBbbWFwXSBjb250YWlucyBhIGJpbmRpbmcgZm9yIFtrZXldLiAqKVxuICB2YWwgbWVtIDogKCdrLCBfLCAnY21wKSB0IC0+ICdrIC0+IGJvb2xcblxuICB2YWwgaXRlcl9rZXlzIDogKCdrLCBfLCBfKSB0IC0+IGY6KCdrIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAoXywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlcmkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogSXRlcmF0ZXMgdW50aWwgdGhlIGZpcnN0IHRpbWUgW2ZdIHJldHVybnMgW1N0b3BdLiBJZiBbZl0gcmV0dXJucyBbU3RvcF0sIHRoZSBmaW5hbFxuICAgICAgcmVzdWx0IGlzIFtVbmZpbmlzaGVkXS4gT3RoZXJ3aXNlLCB0aGUgZmluYWwgcmVzdWx0IGlzIFtGaW5pc2hlZF0uICopXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50XG5cbiAgKCoqIEl0ZXJhdGVzIHR3byBtYXBzIHNpZGUgYnkgc2lkZS4gVGhlIGNvbXBsZXhpdHkgb2YgdGhpcyBmdW5jdGlvbiBpcyBPKE0gKyBOKS4gIElmIHR3b1xuICAgICAgaW5wdXRzIGFyZSBbWygwLCBhKTsgKDEsIGEpXV0gYW5kIFtbKDEsIGIpOyAoMiwgYildXSwgW2ZdIHdpbGwgYmUgY2FsbGVkIHdpdGggW1soMCxcbiAgICAgIGBMZWZ0IGEpOyAoMSwgYEJvdGggKGEsIGIpKTsgKDIsIGBSaWdodCBiKV1dLiAqKVxuICB2YWwgaXRlcjJcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgKCoqIFJldHVybnMgYSBuZXcgbWFwIHdpdGggYm91bmQgdmFsdWVzIHJlcGxhY2VkIGJ5IFtmXSBhcHBsaWVkIHRvIHRoZSBib3VuZCB2YWx1ZXMuKilcbiAgdmFsIG1hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIExpa2UgW21hcF0sIGJ1dCB0aGUgcGFzc2VkIGZ1bmN0aW9uIHRha2VzIGJvdGggW2tleV0gYW5kIFtkYXRhXSBhcyBhcmd1bWVudHMuICopXG4gIHZhbCBtYXBpIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MikgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICAoKiogQ29udmVydCBtYXAgd2l0aCBrZXlzIG9mIHR5cGUgWydrMl0gdG8gYSBtYXAgd2l0aCBrZXlzIG9mIHR5cGUgWydrMl0gdXNpbmcgW2ZdLiAqKVxuICB2YWwgbWFwX2tleXNcbiAgICA6ICAoJ2syLCAnY21wMikgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnazEsICd2LCAnY21wMSkgdFxuICAgIC0+IGY6KCdrMSAtPiAnazIpXG4gICAgLT4gWyBgT2sgb2YgKCdrMiwgJ3YsICdjbXAyKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2syIF1cblxuICAoKiogTGlrZSBbbWFwX2tleXNdLCBidXQgcmFpc2VzIG9uIGR1cGxpY2F0ZSBrZXkuICopXG4gIHZhbCBtYXBfa2V5c19leG5cbiAgICA6ICAoJ2syLCAnY21wMikgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnazEsICd2LCAnY21wMSkgdFxuICAgIC0+IGY6KCdrMSAtPiAnazIpXG4gICAgLT4gKCdrMiwgJ3YsICdjbXAyKSB0XG5cbiAgKCoqIEZvbGRzIG92ZXIga2V5cyBhbmQgZGF0YSBpbiB0aGUgbWFwIGluIGluY3JlYXNpbmcgb3JkZXIgb2YgW2tleV0uICopXG4gIHZhbCBmb2xkIDogKCdrLCAndiwgXykgdCAtPiBpbml0OidhY2MgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAnYWNjKSAtPiAnYWNjXG5cbiAgKCoqIEZvbGRzIG92ZXIga2V5cyBhbmQgZGF0YSBpbiB0aGUgbWFwIGluIGluY3JlYXNpbmcgb3JkZXIgb2YgW2tleV0sIHVudGlsIHRoZSBmaXJzdFxuICAgICAgdGltZSB0aGF0IFtmXSByZXR1cm5zIFtTdG9wIF9dLiBJZiBbZl0gcmV0dXJucyBbU3RvcCBmaW5hbF0sIHRoaXMgZnVuY3Rpb24gcmV0dXJuc1xuICAgICAgaW1tZWRpYXRlbHkgd2l0aCB0aGUgdmFsdWUgW2ZpbmFsXS4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIGFuZCB0aGUgZmluYWxcbiAgICAgIGNhbGwgdG8gW2ZdIHJldHVybnMgW0NvbnRpbnVlIGxhc3RdLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgW2ZpbmlzaCBsYXN0XS4gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAoJ2FjYywgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjYyAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIEZvbGRzIG92ZXIga2V5cyBhbmQgZGF0YSBpbiB0aGUgbWFwIGluIGRlY3JlYXNpbmcgb3JkZXIgb2YgW2tleV0uICopXG4gIHZhbCBmb2xkX3JpZ2h0XG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylcbiAgICAtPiAnYWNjXG5cbiAgKCoqIEZvbGRzIG92ZXIgdHdvIG1hcHMgc2lkZSBieSBzaWRlLCBsaWtlIFtpdGVyMl0uICopXG4gIHZhbCBmb2xkMlxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTooJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiAnYWNjIC0+ICdhY2MpXG4gICAgLT4gJ2FjY1xuXG4gICgqKiBbZmlsdGVyXSwgW2ZpbHRlcmldLCBbZmlsdGVyX2tleXNdLCBbZmlsdGVyX21hcF0sIGFuZCBbZmlsdGVyX21hcGldIHJ1biBpbiBPKG4pXG4gICAgICB0aW1lLlxuXG4gICAgICBbZmlsdGVyXSwgW2ZpbHRlcmldLCBbZmlsdGVyX2tleXNdLCBbcGFydGl0aW9uX3RmXSBhbmQgW3BhcnRpdGlvbmlfdGZdIGtlZXAgYSBsb3RcbiAgICAgIG9mIHNoYXJpbmcgYmV0d2VlbiB0aGVpciByZXN1bHQgYW5kIHRoZSBvcmlnaW5hbCBtYXAuICBEcm9wcGluZyBvciBrZWVwaW5nIGEgcnVuIG9mXG4gICAgICBba10gY29uc2VjdXRpdmUgZWxlbWVudHMgY29zdHMgW08obG9nKGspKV0gZXh0cmEgbWVtb3J5LiBLZWVwaW5nIHRoZSBlbnRpcmUgbWFwXG4gICAgICBjb3N0cyBubyBleHRyYSBtZW1vcnkgYXQgYWxsOiBbZmlsdGVyIH5mOihmdW4gXyAtPiB0cnVlKV0gcmV0dXJucyB0aGUgb3JpZ2luYWwgbWFwLlxuICAqKVxuICB2YWwgZmlsdGVyX2tleXMgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KCdrIC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgZmlsdGVyIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOigndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJpIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFJldHVybnMgYSBuZXcgbWFwIHdpdGggYm91bmQgdmFsdWVzIGZpbHRlcmVkIGJ5IFtmXSBhcHBsaWVkIHRvIHRoZSBib3VuZCB2YWx1ZXMuICopXG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooJ3YxIC0+ICd2MiBvcHRpb24pIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIExpa2UgW2ZpbHRlcl9tYXBdLCBidXQgdGhlIHBhc3NlZCBmdW5jdGlvbiB0YWtlcyBib3RoIFtrZXldIGFuZCBbZGF0YV0gYXNcbiAgICAgIGFyZ3VtZW50cy4gKilcbiAgdmFsIGZpbHRlcl9tYXBpXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondjEgLT4gJ3YyIG9wdGlvbilcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBbcGFydGl0aW9uX21hcGkgdCB+Zl0gcmV0dXJucyB0d28gbmV3IFt0XXMsIHdpdGggZWFjaCBrZXkgaW4gW3RdIGFwcGVhcmluZyBpblxuICAgICAgZXhhY3RseSBvbmUgb2YgdGhlIHJlc3VsdGluZyBtYXBzIGRlcGVuZGluZyBvbiBpdHMgbWFwcGluZyBpbiBbZl0uICopXG4gIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICgndjIsICd2MykgRWl0aGVyLnQpXG4gICAgLT4gKCdrLCAndjIsICdjbXApIHQgKiAoJ2ssICd2MywgJ2NtcCkgdFxuXG4gICgqKiBbcGFydGl0aW9uX21hcCB0IH5mID0gcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXSAqKVxuICB2YWwgcGFydGl0aW9uX21hcFxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooJ3YxIC0+ICgndjIsICd2MykgRWl0aGVyLnQpXG4gICAgLT4gKCdrLCAndjIsICdjbXApIHQgKiAoJ2ssICd2MywgJ2NtcCkgdFxuXG4gICgqKlxuICAgICB7W1xuICAgICAgIHBhcnRpdGlvbmlfdGYgdCB+ZlxuICAgICAgID1cbiAgICAgICBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICAgaWYgZiB+a2V5IH5kYXRhXG4gICAgICAgICB0aGVuIEZpcnN0IGRhdGFcbiAgICAgICAgIGVsc2UgU2Vjb25kIGRhdGEpXG4gICAgIF19ICopXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW3BhcnRpdGlvbl90ZiB0IH5mID0gcGFydGl0aW9uaV90ZiB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSldICopXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZjooJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBQcm9kdWNlcyBbT2tdIG9mIGEgbWFwIGluY2x1ZGluZyBhbGwga2V5cyBpZiBhbGwgZGF0YSBpcyBbT2tdLCBvciBhbiBbRXJyb3JdXG4gICAgICBpbmNsdWRpbmcgYWxsIGVycm9ycyBvdGhlcndpc2UuICopXG4gIHZhbCBjb21iaW5lX2Vycm9ycyA6ICgnaywgJ3YgT3JfZXJyb3IudCwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogR2l2ZW4gYSBtYXAgb2YgdHVwbGVzLCBwcm9kdWNlcyBhIHR1cGxlIG9mIG1hcHMuIEVxdWl2YWxlbnQgdG86XG4gICAgICBbbWFwIHQgfmY6ZnN0LCBtYXAgdCB+ZjpzbmRdICopXG4gIHZhbCB1bnppcCA6ICgnaywgJ3YxICogJ3YyLCAnY21wKSB0IC0+ICgnaywgJ3YxLCAnY21wKSB0ICogKCdrLCAndjIsICdjbXApIHRcblxuICAoKiogUmV0dXJucyBhIHRvdGFsIG9yZGVyaW5nIGJldHdlZW4gbWFwcy4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgdG90YWwgb3JkZXJpbmcgdXNlZFxuICAgICAgdG8gY29tcGFyZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCBlcXVhbCBrZXlzIGluIHRoZSB0d28gbWFwcy4gKilcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCd2IC0+ICd2IC0+IGludCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGludFxuXG4gICgqKiBIYXNoIGZ1bmN0aW9uOiBhIGJ1aWxkaW5nIGJsb2NrIHRvIHVzZSB3aGVuIGhhc2hpbmcgZGF0YSBzdHJ1Y3R1cmVzIGNvbnRhaW5pbmcgbWFwcyBpblxuICAgICAgdGhlbS4gW2hhc2hfZm9sZF9kaXJlY3QgaGFzaF9mb2xkX2tleV0gaXMgY29tcGF0aWJsZSB3aXRoIFtjb21wYXJlX2RpcmVjdF0gaWZmXG4gICAgICBbaGFzaF9mb2xkX2tleV0gaXMgY29tcGF0aWJsZSB3aXRoIFsoY29tcGFyYXRvciBtKS5jb21wYXJlXSBvZiB0aGUgbWFwIFttXSBiZWluZ1xuICAgICAgaGFzaGVkLiAqKVxuICB2YWwgaGFzaF9mb2xkX2RpcmVjdCA6ICdrIEhhc2guZm9sZGVyIC0+ICd2IEhhc2guZm9sZGVyIC0+ICgnaywgJ3YsICdjbXApIHQgSGFzaC5mb2xkZXJcblxuICAoKiogW2VxdWFsIGNtcCBtMSBtMl0gdGVzdHMgd2hldGhlciB0aGUgbWFwcyBbbTFdIGFuZCBbbTJdIGFyZSBlcXVhbCwgdGhhdCBpcywgY29udGFpblxuICAgICAgdGhlIHNhbWUga2V5cyBhbmQgYXNzb2NpYXRlIGVhY2gga2V5IHdpdGggdGhlIHNhbWUgdmFsdWUuICBbY21wXSBpcyB0aGUgZXF1YWxpdHlcbiAgICAgIHByZWRpY2F0ZSB1c2VkIHRvIGNvbXBhcmUgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleXMuICopXG4gIHZhbCBlcXVhbCA6ICgndiAtPiAndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUga2V5cyBpbiB0aGUgZ2l2ZW4gbWFwLiAqKVxuICB2YWwga2V5cyA6ICgnaywgXywgXykgdCAtPiAnayBsaXN0XG5cbiAgKCoqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBkYXRhIGluIHRoZSBnaXZlbiBtYXAuICopXG4gIHZhbCBkYXRhIDogKF8sICd2LCBfKSB0IC0+ICd2IGxpc3RcblxuICAoKiogQ3JlYXRlcyBhbiBhc3NvY2lhdGlvbiBsaXN0IGZyb20gdGhlIGdpdmVuIG1hcC4gKilcbiAgdmFsIHRvX2FsaXN0XG4gICAgOiAgP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXSAoKiogZGVmYXVsdCBpcyBbYEluY3JlYXNpbmddICopXG4gICAgLT4gKCdrLCAndiwgXykgdFxuICAgIC0+ICgnayAqICd2KSBsaXN0XG5cbiAgKCoqIHsyIEFkZGl0aW9uYWwgb3BlcmF0aW9ucyBvbiBtYXBzfSAqKVxuXG4gICgqKiBNZXJnZXMgdHdvIG1hcHMuIFRoZSBydW50aW1lIGlzIE8obGVuZ3RoKHQxKSArIGxlbmd0aCh0MikpLiBZb3Ugc2hvdWxkbid0IHVzZSB0aGlzXG4gICAgICBmdW5jdGlvbiB0byBtZXJnZSBhIGxpc3Qgb2YgbWFwczsgY29uc2lkZXIgdXNpbmcgW21lcmdlX2Rpc2pvaW5fZXhuXSBvclxuICAgICAgW21lcmdlX3NrZXdlZF0gaW5zdGVhZC4gKilcbiAgdmFsIG1lcmdlXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiAoJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiAndjMgb3B0aW9uKVxuICAgIC0+ICgnaywgJ3YzLCAnY21wKSB0XG5cbiAgKCoqIE1lcmdlcyB0d28gZGljdGlvbmFyaWVzIHdpdGggdGhlIHNhbWUgdHlwZSBvZiBkYXRhIGFuZCBkaXNqb2ludCBzZXRzIG9mIGtleXMuXG4gICAgICBSYWlzZXMgaWYgYW55IGtleXMgb3ZlcmxhcC4gKilcbiAgdmFsIG1lcmdlX2Rpc2pvaW50X2V4biA6ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIEEgc3BlY2lhbCBjYXNlIG9mIFttZXJnZV0sIFttZXJnZV9za2V3ZWQgdDEgdDJdIGlzIGEgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZVxuICAgICAgYmluZGluZ3Mgb2YgW3QxXSBhbmQgW3QyXS4gQmluZGluZ3MgdGhhdCBhcHBlYXIgaW4gYm90aCBbdDFdIGFuZCBbdDJdIGFyZVxuICAgICAgY29tYmluZWQgaW50byBhIHNpbmdsZSB2YWx1ZSB1c2luZyB0aGUgW2NvbWJpbmVdIGZ1bmN0aW9uLiBJbiBhIGNhbGxcbiAgICAgIFtjb21iaW5lIH5rZXkgdjEgdjJdLCB0aGUgdmFsdWUgW3YxXSBjb21lcyBmcm9tIFt0MV0gYW5kIFt2Ml0gZnJvbSBbdDJdLlxuXG4gICAgICBUaGUgcnVudGltZSBvZiBbbWVyZ2Vfc2tld2VkXSBpcyBbTyhtaW4obDEsIGwyKSAqIGxvZyhtYXgobDEsIGwyKSkpXSwgd2hlcmUgW2wxXSBpc1xuICAgICAgdGhlIGxlbmd0aCBvZiBbdDFdIGFuZCBbbDJdIHRoZSBsZW5ndGggb2YgW3QyXS4gVGhpcyBpcyBsaWtlbHkgdG8gYmUgZmFzdGVyIHRoYW5cbiAgICAgIFttZXJnZV0gd2hlbiBvbmUgb2YgdGhlIG1hcHMgaXMgYSBsb3Qgc21hbGxlciwgb3Igd2hlbiB5b3UgbWVyZ2UgYSBsaXN0IG9mIG1hcHMuICopXG4gIHZhbCBtZXJnZV9za2V3ZWRcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbWJpbmU6KGtleTonayAtPiAndiAtPiAndiAtPiAndilcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgbW9kdWxlIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQgOiBzaWdcbiAgICB0eXBlICgnaywgJ3YpIHQgPSAnayAqIFsgYExlZnQgb2YgJ3YgfCBgUmlnaHQgb2YgJ3YgfCBgVW5lcXVhbCBvZiAndiAqICd2IF1cbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzIgd2l0aCB0eXBlICgnaywgJ3YpIHQgOj0gKCdrLCAndikgdFxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkVxdWFsLlMyIHdpdGggdHlwZSAoJ2ssICd2KSB0IDo9ICgnaywgJ3YpIHRcbiAgICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMyIHdpdGggdHlwZSAoJ2ssICd2KSB0IDo9ICgnaywgJ3YpIHRcblxuICAgIHZhbCB0X3NleHBfZ3JhbW1hclxuICAgICAgOiAgJ2sgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgIC0+ICd2IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAtPiAoJ2ssICd2KSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICAoKiogW3N5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsXSByZXR1cm5zIGEgbGlzdCBvZiBjaGFuZ2VzIGJldHdlZW4gW3QxXSBhbmQgW3QyXS5cbiAgICAgIEl0IGlzIGludGVuZGVkIHRvIGJlIGVmZmljaWVudCBpbiB0aGUgY2FzZSB3aGVyZSBbdDFdIGFuZCBbdDJdIHNoYXJlIGEgbGFyZ2UgYW1vdW50XG4gICAgICBvZiBzdHJ1Y3R1cmUuIFRoZSBrZXlzIGluIHRoZSBvdXRwdXQgc2VxdWVuY2Ugd2lsbCBiZSBpbiBzb3J0ZWQgb3JkZXIuXG5cbiAgICAgIEl0IGlzIGFzc3VtZWQgdGhhdCBbZGF0YV9lcXVhbF0gaXMgYXQgbGVhc3QgYXMgZXF1YXRpbmcgYXMgcGh5c2ljYWwgZXF1YWxpdHk6IHRoYXRcbiAgICAgIFtwaHlzX2VxdWFsIHggeV0gaW1wbGllcyBbZGF0YV9lcXVhbCB4IHldLiBPdGhlcndpc2UsIFtzeW1tZXRyaWNfZGlmZl0gbWF5IGJlaGF2ZSBpblxuICAgICAgdW5leHBlY3RlZCB3YXlzLiBGb3IgZXhhbXBsZSwgd2l0aCBbfmRhdGFfZXF1YWw6KGZ1biBfIF8gLT4gZmFsc2UpXSBpdCBpcyBOT1RcbiAgICAgIG5lY2Vzc2FyaWx5IHRoZSBjYXNlIHRoZSByZXN1bHRpbmcgY2hhbmdlIHNlcXVlbmNlIHdpbGwgY29udGFpbiBhbiBlbGVtZW50XG4gICAgICBbKGssIGBVbmVxdWFsIF8pXSBmb3IgZXZlcnkga2V5IFtrXSBzaGFyZWQgYnkgYm90aCBtYXBzLlxuXG4gICAgICBXYXJuaW5nOiBGbG9hdCBlcXVhbGl0eSB2aW9sYXRlcyB0aGlzIHByb3BlcnR5ISBbcGh5c19lcXVhbCBGbG9hdC5uYW4gRmxvYXQubmFuXSBpc1xuICAgICAgdHJ1ZSwgYnV0IFtGbG9hdC4oPSkgRmxvYXQubmFuIEZsb2F0Lm5hbl0gaXMgZmFsc2UuICopXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2KSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgU2VxdWVuY2UudFxuXG4gICgqKiBbZm9sZF9zeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbF0gZm9sZHMgYWNyb3NzIGFuIGltcGxpY2l0IHNlcXVlbmNlIG9mIGNoYW5nZXNcbiAgICAgIGJldHdlZW4gW3QxXSBhbmQgW3QyXSwgaW4gc29ydGVkIG9yZGVyIGJ5IGtleXMuIEVxdWl2YWxlbnQgdG9cbiAgICAgIFtTZXF1ZW5jZS5mb2xkIChzeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbCldLCBhbmQgbW9yZSBlZmZpY2llbnQuICopXG4gIHZhbCBmb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBkYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCdhY2MgLT4gKCdrLCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+ICdhY2MpXG4gICAgLT4gJ2FjY1xuXG4gICgqKiBbbWluX2VsdCBtYXBdIHJldHVybnMgW1NvbWUgKGtleSwgZGF0YSldIHBhaXIgY29ycmVzcG9uZGluZyB0byB0aGUgbWluaW11bSBrZXkgaW5cbiAgICAgIFttYXBdLCBvciBbTm9uZV0gaWYgZW1wdHkuICopXG4gIHZhbCBtaW5fZWx0IDogKCdrLCAndiwgXykgdCAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayAqICd2XG5cbiAgKCoqIFttYXhfZWx0IG1hcF0gcmV0dXJucyBbU29tZSAoa2V5LCBkYXRhKV0gcGFpciBjb3JyZXNwb25kaW5nIHRvIHRoZSBtYXhpbXVtIGtleSBpblxuICAgICAgW21hcF0sIG9yIFtOb25lXSBpZiBbbWFwXSBpcyBlbXB0eS4gKilcbiAgdmFsIG1heF9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2ssICd2LCBfKSB0IC0+ICdrICogJ3ZcblxuICAoKiogU3dhcCB0aGUgaW5uZXIgYW5kIG91dGVyIGtleXMgb2YgbmVzdGVkIG1hcHMuIElmIFt0cmFuc3Bvc2Vfa2V5cyBtIGEgPSBiXSwgdGhlblxuICAgICAgW2ZpbmRfZXhuIChmaW5kX2V4biBhIGkpIGogPSBmaW5kX2V4biAoZmluZF9leG4gYiBqKSBpXS4gKilcbiAgdmFsIHRyYW5zcG9zZV9rZXlzXG4gICAgOiAgKCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sxLCAoJ2syLCAndiwgJ2NtcDIpIHQsICdjbXAxKSB0XG4gICAgLT4gKCdrMiwgKCdrMSwgJ3YsICdjbXAxKSB0LCAnY21wMikgdFxuXG4gICgqKiBUaGVzZSBmdW5jdGlvbnMgaGF2ZSB0aGUgc2FtZSBzZW1hbnRpY3MgYXMgc2ltaWxhciBmdW5jdGlvbnMgaW4gW0xpc3RdLiAqKVxuXG4gIHZhbCBmb3JfYWxsIDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpIC0+IGludFxuXG4gIHZhbCBzdW1cbiAgICA6ICAobW9kdWxlIENvbnRhaW5lci5TdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdhKVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiBmOigndiAtPiAnYSlcbiAgICAtPiAnYVxuXG4gIHZhbCBzdW1pXG4gICAgOiAgKG1vZHVsZSBDb250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAtPiAoJ2ssICd2LCBfKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2EpXG4gICAgLT4gJ2FcblxuICAoKiogW3NwbGl0IHQga2V5XSByZXR1cm5zIGEgbWFwIG9mIGtleXMgc3RyaWN0bHkgbGVzcyB0aGFuIFtrZXldLCB0aGUgbWFwcGluZyBvZiBba2V5XSBpZlxuICAgICAgYW55LCBhbmQgYSBtYXAgb2Yga2V5cyBzdHJpY3RseSBncmVhdGVyIHRoYW4gW2tleV0uXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhtICsgbG9nIG4pLCB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSBpbnB1dCBtYXAgYW5kIG0gaXMgdGhlIHNpemUgb2ZcbiAgICAgIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gb3V0cHV0IG1hcHMuICBUaGUgTyhtKSB0ZXJtIGlzIGR1ZSB0byB0aGUgbmVlZCB0byBjYWxjdWxhdGVcbiAgICAgIHRoZSBsZW5ndGggb2YgdGhlIG91dHB1dCBtYXBzLiAqKVxuICB2YWwgc3BsaXRcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gJ2tcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrICogJ3YpIG9wdGlvbiAqICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW3NwbGl0X2xlX2d0IHQga2V5XSByZXR1cm5zIGEgbWFwIG9mIGtleXMgdGhhdCBhcmUgbGVzcyBvciBlcXVhbCB0byBba2V5XSBhbmQgYVxuICAgICAgbWFwIG9mIGtleXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIFtrZXldLlxuXG4gICAgICBSdW50aW1lIGlzIE8obSArIGxvZyBuKSwgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgaW5wdXQgbWFwIGFuZCBtIGlzIHRoZSBzaXplIG9mXG4gICAgICB0aGUgc21hbGxlciBvZiB0aGUgdHdvIG91dHB1dCBtYXBzLiAgVGhlIE8obSkgdGVybSBpcyBkdWUgdG8gdGhlIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgbWFwcy4gKilcbiAgdmFsIHNwbGl0X2xlX2d0IDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbc3BsaXRfbHRfZ2UgdCBrZXldIHJldHVybnMgYSBtYXAgb2Yga2V5cyBzdHJpY3RseSBsZXNzIHRoYW4gW2tleV0gYW5kIGEgbWFwIG9mXG4gICAgICBrZXlzIHRoYXQgYXJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gW2tleV0uXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhtICsgbG9nIG4pLCB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSBpbnB1dCBtYXAgYW5kIG0gaXMgdGhlIHNpemUgb2ZcbiAgICAgIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gb3V0cHV0IG1hcHMuICBUaGUgTyhtKSB0ZXJtIGlzIGR1ZSB0byB0aGUgbmVlZCB0byBjYWxjdWxhdGVcbiAgICAgIHRoZSBsZW5ndGggb2YgdGhlIG91dHB1dCBtYXBzLiAqKVxuICB2YWwgc3BsaXRfbHRfZ2UgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFthcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnRdIHJldHVybnMgW2BPayBtYXBdIHdoZXJlIFttYXBdIGNvbnRhaW5zIGFsbCB0aGVcbiAgICAgIFsoa2V5LCB2YWx1ZSldIHBhaXJzIGZyb20gdGhlIHR3byBpbnB1dCBtYXBzIGlmIGFsbCB0aGUga2V5cyBmcm9tIFtsb3dlcl9wYXJ0XSBhcmVcbiAgICAgIGxlc3MgdGhhbiBhbGwgdGhlIGtleXMgZnJvbSBbdXBwZXJfcGFydF0uICBPdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAgW2BPdmVybGFwcGluZ19rZXlfcmFuZ2VzXS5cblxuICAgICAgUnVudGltZSBpcyBPKGxvZyBuKSB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSBsYXJnZXIgaW5wdXQgbWFwLiAgVGhpcyBjYW4gYmVcbiAgICAgIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gW01hcC5tZXJnZV0gb3IgcmVwZWF0ZWQgW01hcC5hZGRdLlxuXG4gICAgICB7W1xuICAgICAgICBhc3NlcnQgKG1hdGNoIE1hcC5hcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgd2l0aFxuICAgICAgICAgIHwgYE9rIHdob2xlX21hcCAtPlxuICAgICAgICAgICAgTWFwLnRvX2FsaXN0IHdob2xlX21hcFxuICAgICAgICAgICAgPSBMaXN0LmFwcGVuZCAodG9fYWxpc3QgbG93ZXJfcGFydCkgKHRvX2FsaXN0IHVwcGVyX3BhcnQpXG4gICAgICAgICAgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyAtPiB0cnVlKTtcbiAgICAgIF19ICopXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBsb3dlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiB1cHBlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXVxuXG4gICgqKiBbc3VicmFuZ2UgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kXSByZXR1cm5zIGEgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBlbnRyaWVzIGZyb21cbiAgICAgIFt0XSB3aG9zZSBrZXlzIGxpZSBpbnNpZGUgdGhlIGludGVydmFsIGluZGljYXRlZCBieSBbfmxvd2VyX2JvdW5kXSBhbmRcbiAgICAgIFt+dXBwZXJfYm91bmRdLiAgSWYgdGhpcyBpbnRlcnZhbCBpcyBlbXB0eSwgYW4gZW1wdHkgbWFwIGlzIHJldHVybmVkLlxuXG4gICAgICBSdW50aW1lIGlzIE8obSArIGxvZyBuKSwgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgaW5wdXQgbWFwIGFuZCBtIGlzIHRoZSBzaXplIG9mXG4gICAgICB0aGUgb3V0cHV0IG1hcC4gIFRoZSBPKG0pIHRlcm0gaXMgZHVlIHRvIHRoZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAgb3V0cHV0IG1hcC4gKilcbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGxvd2VyX2JvdW5kOidrIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonayBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbZm9sZF9yYW5nZV9pbmNsdXNpdmUgdCB+bWluIH5tYXggfmluaXQgfmZdIGZvbGRzIFtmXSAod2l0aCBpbml0aWFsIHZhbHVlIFt+aW5pdF0pXG4gICAgICBvdmVyIGFsbCBrZXlzIChhbmQgdGhlaXIgYXNzb2NpYXRlZCB2YWx1ZXMpIHRoYXQgYXJlIGluIHRoZSByYW5nZSBbW21pbiwgbWF4XV1cbiAgICAgIChpbmNsdXNpdmUpLiAgKilcbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IG1pbjona1xuICAgIC0+IG1heDona1xuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhY2MgLT4gJ2FjYylcbiAgICAtPiAnYWNjXG5cbiAgKCoqIFtyYW5nZV90b19hbGlzdCB0IH5taW4gfm1heF0gcmV0dXJucyBhbiBhc3NvY2lhdGl2ZSBsaXN0IG9mIHRoZSBlbGVtZW50cyB3aG9zZSBrZXlzXG4gICAgICBsaWUgaW4gW1ttaW4sIG1heF1dIChpbmNsdXNpdmUpLCB3aXRoIHRoZSBzbWFsbGVzdCBrZXkgYmVpbmcgYXQgdGhlIGhlYWQgb2YgdGhlXG4gICAgICBsaXN0LiAqKVxuICB2YWwgcmFuZ2VfdG9fYWxpc3QgOiAoJ2ssICd2LCAnY21wKSB0IC0+IG1pbjonayAtPiBtYXg6J2sgLT4gKCdrICogJ3YpIGxpc3RcblxuICAoKiogW2Nsb3Nlc3Rfa2V5IHQgZGlyIGtdIHJldHVybnMgdGhlIFsoa2V5LCB2YWx1ZSldIHBhaXIgaW4gW3RdIHdpdGggW2tleV0gY2xvc2VzdCB0b1xuICAgICAgW2tdIHRoYXQgc2F0aXNmaWVzIHRoZSBnaXZlbiBpbmVxdWFsaXR5IGJvdW5kLlxuXG4gICAgICBGb3IgZXhhbXBsZSwgW2Nsb3Nlc3Rfa2V5IHQgYExlc3NfdGhhbiBrXSB3b3VsZCBiZSB0aGUgcGFpciB3aXRoIHRoZSBjbG9zZXN0IGtleSB0b1xuICAgICAgW2tdIHdoZXJlIFtrZXkgPCBrXS5cblxuICAgICAgW3RvX3NlcXVlbmNlXSBjYW4gYmUgdXNlZCB0byBnZXQgdGhlIHNhbWUgcmVzdWx0cyBhcyBbY2xvc2VzdF9rZXldLiAgSXQgaXMgbGVzc1xuICAgICAgZWZmaWNpZW50IGZvciBpbmRpdmlkdWFsIGxvb2t1cHMgYnV0IG1vcmUgZWZmaWNpZW50IGZvciBmaW5kaW5nIG1hbnkgZWxlbWVudHMgc3RhcnRpbmdcbiAgICAgIGF0IHNvbWUgdmFsdWUuICopXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgLT4gJ2tcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgKCoqIFtudGggdCBuXSBmaW5kcyB0aGUgKGtleSwgdmFsdWUpIHBhaXIgb2YgcmFuayBuIChpLmUuLCBzdWNoIHRoYXQgdGhlcmUgYXJlIGV4YWN0bHkgblxuICAgICAga2V5cyBzdHJpY3RseSBsZXNzIHRoYW4gdGhlIGZvdW5kIGtleSksIGlmIG9uZSBleGlzdHMuICBPKGxvZyhsZW5ndGggdCkgKyBuKSB0aW1lLiAqKVxuICB2YWwgbnRoIDogKCdrLCAndiwgXykgdCAtPiBpbnQgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBudGhfZXhuIDogKCdrLCAndiwgXykgdCAtPiBpbnQgLT4gJ2sgKiAndlxuXG4gICgqKiBbcmFuayB0IGtdIElmIFtrXSBpcyBpbiBbdF0sIHJldHVybnMgdGhlIG51bWJlciBvZiBrZXlzIHN0cmljdGx5IGxlc3MgdGhhbiBba10gaW5cbiAgICAgIFt0XSwgYW5kIFtOb25lXSBvdGhlcndpc2UuICopXG4gIHZhbCByYW5rIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiBpbnQgb3B0aW9uXG5cbiAgKCoqIFt0b19zZXF1ZW5jZSA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHRdXG4gICAgICBnaXZlcyBhIHNlcXVlbmNlIG9mIGtleS12YWx1ZSBwYWlycyBiZXR3ZWVuIFtrZXlzX2xlc3Nfb3JfZXF1YWxfdG9dIGFuZFxuICAgICAgW2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b10gaW5jbHVzaXZlLCBwcmVzZW50ZWQgaW4gW29yZGVyXS4gIElmXG4gICAgICBba2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID4ga2V5c19sZXNzX29yX2VxdWFsX3RvXSwgdGhlIHNlcXVlbmNlIGlzXG4gICAgICBlbXB0eS5cblxuICAgICAgV2hlbiBuZWl0aGVyIFtrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG9dIG5vciBba2V5c19sZXNzX29yX2VxdWFsX3RvXSBhcmVcbiAgICAgIHByb3ZpZGVkLCB0aGUgY29zdCBpcyBPKGxvZyBuKSB1cCBmcm9udCBhbmQgYW1vcnRpemVkIE8oMSkgdG8gcHJvZHVjZVxuICAgICAgZWFjaCBlbGVtZW50LiBJZiBlaXRoZXIgaXMgcHJvdmlkZWQgKGFuZCBpcyB1c2VkIGJ5IHRoZSBvcmRlciBwYXJhbWV0ZXJcbiAgICAgIHByb3ZpZGVkKSwgdGhlbiB0aGUgdGhlIGNvc3QgaXMgTyhuKSB1cCBmcm9udCwgYW5kIGFtb3J0aXplZCBPKDEpIHRvXG4gICAgICBwcm9kdWNlIGVhY2ggZWxlbWVudC4gKilcbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5ICgqKiBkZWZhdWx0ICopIHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAtPiA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvOidrXG4gICAgLT4gP2tleXNfbGVzc19vcl9lcXVhbF90bzona1xuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2sgKiAndikgU2VxdWVuY2UudFxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIHdoaWNoIGVsdF0gcmV0dXJucyB0aGUgWyhrZXksIHZhbHVlKV0gcGFpciBpbiBbdF1cbiAgICAgIHNwZWNpZmllZCBieSBbY29tcGFyZV0gYW5kIFt3aGljaF0sIGlmIG9uZSBleGlzdHMuXG5cbiAgICAgIFt0XSBtdXN0IGJlIHNvcnRlZCBpbiBpbmNyZWFzaW5nIG9yZGVyIGFjY29yZGluZyB0byBbY29tcGFyZV0sIHdoZXJlIFtjb21wYXJlXSBhbmRcbiAgICAgIFtlbHRdIGRpdmlkZSBbdF0gaW50byB0aHJlZSAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzOlxuXG4gICAgICB7dlxuICAgICAgICB8ICA8IGVsdCAgfCAgPSBlbHQgIHwgID4gZWx0ICB8XG4gICAgICB2fVxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF0gcmV0dXJucyBhbiBlbGVtZW50IG9uIHRoZSBib3VuZGFyeSBvZiBzZWdtZW50cyBhcyBzcGVjaWZpZWQgYnlcbiAgICAgIFt3aGljaF0uICBTZWUgdGhlIGRpYWdyYW0gYmVsb3cgbmV4dCB0byB0aGUgW3doaWNoXSB2YXJpYW50cy5cblxuICAgICAgW2JpbmFyeV9zZWFyY2hdIGRvZXMgbm90IGNoZWNrIHRoYXQgW2NvbXBhcmVdIG9yZGVycyBbdF0sIGFuZCBiZWhhdmlvciBpc1xuICAgICAgdW5zcGVjaWZpZWQgaWYgW2NvbXBhcmVdIGRvZXNuJ3Qgb3JkZXIgW3RdLiAgQmVoYXZpb3IgaXMgYWxzbyB1bnNwZWNpZmllZCBpZlxuICAgICAgW2NvbXBhcmVdIG11dGF0ZXMgW3RdLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAna2V5IC0+IGludClcbiAgICAtPiBbIGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAoKiogICAgICAgIHt2IHwgPCBlbHQgWCB8ICAgICAgICAgICAgICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvICgqKiAgICAge3YgfCAgICAgIDw9IGVsdCAgICAgICBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgTGFzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCAgID0gZWx0IFggfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBGaXJzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8IFggPSBlbHQgICB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAoKioge3YgICAgICAgICAgIHwgWCAgICAgICA+PSBlbHQgICAgICB8IHZ9ICopXG4gICAgICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuICgqKiAgICB7diAgICAgICAgICAgICAgICAgICAgICAgfCBYID4gZWx0IHwgdn0gKilcbiAgICAgICBdXG4gICAgLT4gJ2tleVxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICAoKiogW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2Ygd2hpY2hdIHRha2VzIGEgW3NlZ21lbnRfb2ZdIGZ1bmN0aW9uIHRoYXRcbiAgICAgIGRpdmlkZXMgW3RdIGludG8gdHdvIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHM6XG5cbiAgICAgIHt2XG4gICAgICAgIHwgc2VnbWVudF9vZiBlbHQgPSBgTGVmdCB8IHNlZ21lbnRfb2YgZWx0ID0gYFJpZ2h0IHxcbiAgICAgIHZ9XG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZF0gcmV0dXJucyB0aGUgWyhrZXksIHZhbHVlKV0gcGFpciBvbiB0aGUgYm91bmRhcnkgb2YgdGhlXG4gICAgICBzZWdtZW50cyBhcyBzcGVjaWZpZWQgYnkgW3doaWNoXTogW2BMYXN0X29uX2xlZnRdIHlpZWxkcyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZVxuICAgICAgbGVmdCBzZWdtZW50LCB3aGlsZSBbYEZpcnN0X29uX3JpZ2h0XSB5aWVsZHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHJpZ2h0IHNlZ21lbnQuXG4gICAgICBJdCByZXR1cm5zIFtOb25lXSBpZiB0aGUgc2VnbWVudCBpcyBlbXB0eS5cblxuICAgICAgW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSBkb2VzIG5vdCBjaGVjayB0aGF0IFtzZWdtZW50X29mXSBzZWdtZW50cyBbdF0gYXMgaW4gdGhlXG4gICAgICBkaWFncmFtLCBhbmQgYmVoYXZpb3IgaXMgdW5zcGVjaWZpZWQgaWYgW3NlZ21lbnRfb2ZdIGRvZXNuJ3Qgc2VnbWVudCBbdF0uICBCZWhhdmlvclxuICAgICAgaXMgYWxzbyB1bnNwZWNpZmllZCBpZiBbc2VnbWVudF9vZl0gbXV0YXRlcyBbdF0uICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBzZWdtZW50X29mOihrZXk6J2sgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gWyBgTGFzdF9vbl9sZWZ0IHwgYEZpcnN0X29uX3JpZ2h0IF1cbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXSB0YWtlcyBhIFtjb21wYXJlXSBmdW5jdGlvbiB0aGF0IGRpdmlkZXMgW3RdIGludG8gdGhyZWVcbiAgICAgIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHMgd2l0aCByZXNwZWN0IHRvIFtsb3dlcl9ib3VuZF0gYW5kIFt1cHBlcl9ib3VuZF06XG5cbiAgICAgIHt2XG4gICAgICAgIHwgQmVsb3dfbG93ZXJfYm91bmQgfCBJbl9yYW5nZSB8IEFib3ZlX3VwcGVyX2JvdW5kIHxcbiAgICAgIHZ9XG5cbiAgICAgIGFuZCByZXR1cm5zIGEgbWFwIG9mIHRoZSBbSW5fcmFuZ2VdIHNlZ21lbnQuXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhsb2cgbSArIG4pIHdoZXJlIFttXSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBtYXAgYW5kIFtuXSBpcyB0aGVcbiAgICAgIGxlbmd0aCBvZiB0aGUgb3V0cHV0LiBUaGUgbGluZWFyIHRlcm0gaW4gW25dIGlzIHRvIGNvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0LlxuXG4gICAgICBCZWhhdmlvciBpcyB1bmRlZmluZWQgaWYgW2NvbXBhcmVdIGRvZXMgbm90IHNlZ21lbnQgW3RdIGFzIHNob3duIGFib3ZlLCBvciBpZlxuICAgICAgW2NvbXBhcmVdIG11dGF0ZXMgaXRzIGlucHV0cy4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2JvdW5kIC0+IGludClcbiAgICAtPiBsb3dlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIHRyYXZlcnNhbHMgdG8gcmVjb25zdHJ1Y3QgYSBtYXAgd2l0aGluIGFuIGFwcGxpY2F0aXZlLiBVc2VzXG4gICAgICBbTGF6eV9hcHBsaWNhdGl2ZV0gc28gdGhhdCB0aGUgbWFwIGNhbiBiZSB0cmF2ZXJzZWQgd2l0aGluIHRoZSBhcHBsaWNhdGl2ZSwgcmF0aGVyXG4gICAgICB0aGFuIG5lZWRpbmcgdG8gYmUgdHJhdmVyc2VkIGFsbCBhdCBvbmNlLCBvdXRzaWRlIHRoZSBhcHBsaWNhdGl2ZS4gKilcbiAgbW9kdWxlIE1ha2VfYXBwbGljYXRpdmVfdHJhdmVyc2FscyAoQSA6IEFwcGxpY2F0aXZlLkxhenlfYXBwbGljYXRpdmUpIDogc2lnXG4gICAgdmFsIG1hcGlcbiAgICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondjEgLT4gJ3YyIEEudClcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0IEEudFxuXG4gICAgdmFsIGZpbHRlcl9tYXBpXG4gICAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MiBvcHRpb24gQS50KVxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHQgQS50XG4gIGVuZFxuXG4gICgqKiBbTV0gaXMgbWVhbnQgdG8gYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIE9DYW1sIGFwcGxpY2F0aXZlIGZ1bmN0b3IgdHlwZXM6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3RvX2ludF9tYXAgPSBpbnQgTWFwLk0oU3RyaW5nKS50XG4gICAgICBdfVxuXG4gICAgICB3aGljaCBzdGFuZHMgZm9yOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ190b19pbnRfbWFwID0gKFN0cmluZy50LCBpbnQsIFN0cmluZy5jb21wYXJhdG9yX3dpdG5lc3MpIE1hcC50XG4gICAgICBdfVxuXG4gICAgICBUaGUgcG9pbnQgaXMgdGhhdCBbaW50IE1hcC5NKFN0cmluZykudF0gc3VwcG9ydHMgZGVyaXZpbmcsIHdoZXJlYXMgdGhlIHNlY29uZCBzeW50YXhcbiAgICAgIGRvZXNuJ3QgKGJlY2F1c2UgdGhlcmUgaXMgbm8gc3VjaCB0aGluZyBhcywgc2F5LCBbU3RyaW5nLnNleHBfb2ZfY29tcGFyYXRvcl93aXRuZXNzXVxuICAgICAgLS0gaW5zdGVhZCB5b3Ugd291bGQgd2FudCB0byBwYXNzIHRoZSBjb21wYXJhdG9yIGRpcmVjdGx5KS5cblxuICAgICAgSW4gYWRkaXRpb24sIHdoZW4gdXNpbmcgW0BAZGVyaXZpbmddLCB0aGUgcmVxdWlyZW1lbnRzIG9uIHRoZSBrZXkgbW9kdWxlIGFyZSBvbmx5XG4gICAgICB0aG9zZSBuZWVkZWQgdG8gc2F0aXNmeSB3aGF0IHlvdSBhcmUgdHJ5aW5nIHRvIGRlcml2ZSBvbiB0aGUgbWFwIGl0c2VsZi4gU2F5IHlvdVxuICAgICAgd3JpdGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgdCA9IGludCBNYXAuTShYKS50IFtAQGRlcml2aW5nIGhhc2hdXG4gICAgICBdfVxuXG4gICAgICB0aGVuIHRoaXMgd2lsbCBiZSB3ZWxsIHR5cGVkIGV4YWN0bHkgaWYgW1hdIGNvbnRhaW5zIGF0IGxlYXN0OlxuICAgICAgLSBhIHR5cGUgW3RdIHdpdGggbm8gcGFyYW1ldGVyc1xuICAgICAgLSBhIGNvbXBhcmF0b3Igd2l0bmVzc1xuICAgICAgLSBhIFtoYXNoX2ZvbGRfdF0gZnVuY3Rpb24gd2l0aCB0aGUgcmlnaHQgdHlwZSAqKVxuICBtb2R1bGUgTSAoSyA6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gIGVuZCkgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyAndiB0ID0gKEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIGVuZFxuXG4gIGluY2x1ZGUgRm9yX2Rlcml2aW5nIHdpdGggdHlwZSAoJ2tleSwgJ3ZhbHVlLCAnY21wKSB0IDo9ICgna2V5LCAndmFsdWUsICdjbXApIHRcblxuICAoKiogW1VzaW5nX2NvbXBhcmF0b3JdIGlzIGEgc2ltaWxhciBpbnRlcmZhY2UgYXMgdGhlIHRvcGxldmVsIG9mIFtNYXBdLCBleGNlcHQgdGhlXG4gICAgICBmdW5jdGlvbnMgdGFrZSBhIFt+Y29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudF0sIHdoZXJlYXMgdGhlIGZ1bmN0aW9ucyBhdCB0aGVcbiAgICAgIHRvcGxldmVsIG9mIFtNYXBdIHRha2UgYSBbKCdrLCAnY21wKSBjb21wYXJhdG9yXS4gKilcbiAgbW9kdWxlIFVzaW5nX2NvbXBhcmF0b3IgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyAoJ2ssICsndiwgJ2NtcCkgdCA9ICgnaywgJ3YsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2sgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCd2IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnY21wIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCB0X29mX3NleHBfZGlyZWN0XG4gICAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoU2V4cC50IC0+ICdrKVxuICAgICAgLT4gKFNleHAudCAtPiAndilcbiAgICAgIC0+IFNleHAudFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICAgbW9kdWxlIFRyZWUgOiBzaWdcbiAgICAgIHR5cGUgKCsnaywgKyd2LCAnY21wKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgICB2YWwgc2V4cF9vZl90XG4gICAgICAgIDogICgnayAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgndiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnY21wIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgICAgW0BAQGVuZF1cblxuICAgICAgdmFsIHRfb2Zfc2V4cF9kaXJlY3RcbiAgICAgICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgICAtPiAoU2V4cC50IC0+ICdrKVxuICAgICAgICAtPiAoU2V4cC50IC0+ICd2KVxuICAgICAgICAtPiBTZXhwLnRcbiAgICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICAgICBpbmNsdWRlXG4gICAgICAgIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpY1xuICAgICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgICAgIHdpdGggdHlwZSAnayBrZXkgOj0gJ2tcbiAgICAgICAgICB3aXRoIHR5cGUgJ2MgY21wIDo9ICdjXG4gICAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aF9jb21wYXJhdG9yLnRcbiAgICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGFjY2Vzc19vcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBXaXRoX2NvbXBhcmF0b3IudFxuXG4gICAgICB2YWwgZW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiA6IChfLCBfLCBfKSB0XG5cbiAgICAgICgqKiBbQnVpbGRfaW5jcmVhc2luZ10gY2FuIGJlIHVzZWQgdG8gY29uc3RydWN0IGEgbWFwIGluY3JlbWVudGFsbHkgZnJvbSBhXG4gICAgICAgICAgc2VxdWVuY2UgdGhhdCBpcyBrbm93biB0byBiZSBpbmNyZWFzaW5nLlxuXG4gICAgICAgICAgVGhlIHRvdGFsIHRpbWUgY29tcGxleGl0eSBvZiBjb25zdHJ1Y3RpbmcgYSBtYXAgdGhpcyB3YXkgaXMgTyhuKSwgd2hpY2ggaXMgbW9yZVxuICAgICAgICAgIGVmZmljaWVudCB0aGFuIHVzaW5nIFtNYXAuYWRkXSBieSBhIGxvZ2FyaXRobWljIGZhY3Rvci5cblxuICAgICAgICAgIFRoaXMgaW50ZXJmYWNlIGNhbiBiZSB0aG91Z2h0IG9mIGFzIGEgZHVhbCBvZiBbdG9fc2VxdWVuY2VdLCBidXQgd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIGFuIGVxdWFsbHkgbmVhdCBpZGlvbSBmb3IgdGhlIGR1YWxzIG9mIHNlcXVlbmNlcyAoW29mX3NlcXVlbmNlXSBpcyBtdWNoIGxlc3NcbiAgICAgICAgICBnZW5lcmFsIGJlY2F1c2UgaXQgZG9lcyBub3QgYWxsb3cgdGhlIHNlcXVlbmNlIHRvIGJlIHByb2R1Y2VkIGFzeW5jaHJvbm91c2x5KS4gKilcbiAgICAgIG1vZHVsZSBCdWlsZF9pbmNyZWFzaW5nIDogc2lnXG4gICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgdHlwZSAoJ2ssICd2LCAndykgdFxuXG4gICAgICAgIHZhbCBlbXB0eSA6ICgnaywgJ3YsICd3KSB0XG5cbiAgICAgICAgKCoqIFRpbWUgY29tcGxleGl0eSBvZiBbYWRkX2V4bl0gaXMgYW1vcnRpemVkIGNvbnN0YW50LXRpbWUgKGlmIFt0XSBpcyB1c2VkXG4gICAgICAgICAgICBsaW5lYXJseSksIHdpdGggYSB3b3JzdC1jYXNlIE8obG9nKG4pKSB0aW1lLiAqKVxuICAgICAgICB2YWwgYWRkX2V4blxuICAgICAgICAgIDogICgnaywgJ3YsICd3KSB0XG4gICAgICAgICAgLT4gY29tcGFyYXRvcjooJ2ssICd3KSBDb21wYXJhdG9yLnRcbiAgICAgICAgICAtPiBrZXk6J2tcbiAgICAgICAgICAtPiBkYXRhOid2XG4gICAgICAgICAgLT4gKCdrLCAndiwgJ3cpIHRcblxuICAgICAgICAoKiogVGltZSBjb21wbGV4aXR5IGlzIE8obG9nKG4pKS4gKilcbiAgICAgICAgdmFsIHRvX3RyZWUgOiAoJ2ssICd2LCAndykgdCAtPiAoJ2ssICd2LCAndykgdHJlZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBpbmNsdWRlXG4gICAgICBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWNcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgVHJlZS50XG4gICAgICAgIHdpdGggdHlwZSAnayBrZXkgOj0gJ2tcbiAgICAgICAgd2l0aCB0eXBlICdjIGNtcCA6PSAnY1xuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGFjY2Vzc19vcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBXaXRob3V0X2NvbXBhcmF0b3IudFxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGNyZWF0ZV9vcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBXaXRoX2NvbXBhcmF0b3IudFxuXG4gICAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsIF8sICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLnRcblxuICAgIHZhbCBoYXNoX2ZvbGRfZGlyZWN0XG4gICAgICA6ICAnayBIYXNoLmZvbGRlclxuICAgICAgLT4gJ3YgSGFzaC5mb2xkZXJcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgSGFzaC5mb2xkZXJcblxuICAgICgqKiBUbyBnZXQgYXJvdW5kIHRoZSB2YWx1ZSByZXN0cmljdGlvbiwgYXBwbHkgdGhlIGZ1bmN0b3IgYW5kIGluY2x1ZGUgaXQuIFlvdVxuICAgICAgICBjYW4gc2VlIGFuIGV4YW1wbGUgb2YgdGhpcyBpbiB0aGUgW1BvbHldIHN1Ym1vZHVsZSBiZWxvdy4gKilcbiAgICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoSyA6IENvbXBhcmF0b3IuUzEpIDogc2lnXG4gICAgICB2YWwgZW1wdHkgOiAoJ2EgSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgKCoqIEEgcG9seW1vcnBoaWMgTWFwLiAqKVxuICBtb2R1bGUgUG9seSA6XG4gICAgU19wb2x5XG4gICAgICB3aXRoIHR5cGUgKCdrZXksICsndmFsdWUpIHQgPSAoJ2tleSwgJ3ZhbHVlLCBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gICAgICAgYW5kIHR5cGUgKCdrZXksICsndmFsdWUpIHRyZWUgPVxuICAgICAgICAoJ2tleSwgJ3ZhbHVlLCBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzKSBVc2luZ19jb21wYXJhdG9yLlRyZWUudFxuICAgICAgIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3NcblxuICAoKiogQ3JlYXRlIGEgbWFwIGZyb20gYSB0cmVlIHVzaW5nIHRoZSBnaXZlbiBjb21wYXJhdG9yLiAqKVxuICB2YWwgb2ZfdHJlZVxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBFeHRyYWN0IGEgdHJlZSBmcm9tIGEgbWFwLiAqKVxuICB2YWwgdG9fdHJlZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgVXNpbmdfY29tcGFyYXRvci5UcmVlLnRcblxuICAoKiogezIgTW9kdWxlcyBhbmQgbW9kdWxlIHR5cGVzIGZvciBleHRlbmRpbmcgW01hcF19XG5cbiAgICAgIEZvciB1c2UgaW4gZXh0ZW5zaW9ucyBvZiBCYXNlLCBsaWtlIFtDb3JlXS4gKilcblxuICBtb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gV2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlXG4gIG1vZHVsZSBXaXRob3V0X2NvbXBhcmF0b3IgPSBXaXRob3V0X2NvbXBhcmF0b3JcblxuICBtb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBGb3JfZGVyaXZpbmdcbiAgbW9kdWxlIHR5cGUgU19wb2x5ID0gU19wb2x5XG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yc19nZW5lcmljID0gQWNjZXNzb3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgVFxuXG5tb2R1bGUgdHlwZSBFbHRfcGxhaW4gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgV2l0aG91dF9jb21wYXJhdG9yID0gTWFwX2ludGYuV2l0aG91dF9jb21wYXJhdG9yXG5tb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gTWFwX2ludGYuV2l0aF9jb21wYXJhdG9yXG5tb2R1bGUgV2l0aF9maXJzdF9jbGFzc19tb2R1bGUgPSBNYXBfaW50Zi5XaXRoX2ZpcnN0X2NsYXNzX21vZHVsZVxubW9kdWxlIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQgPSBTZXF1ZW5jZS5NZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudFxuXG5tb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB7IHNldCA6ICdhXG4gICAgOyBuYW1lIDogc3RyaW5nXG4gICAgfVxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdhLCAnY21wKSB0XG5cbiAgaW5jbHVkZSBDb250YWluZXIuR2VuZXJpYyB3aXRoIHR5cGUgKCdhLCAnY21wLCBfKSB0IDo9ICgnYSwgJ2NtcCkgdFxuXG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgKCoqIFRoZSBbYWNjZXNzX29wdGlvbnNdIHR5cGUgaXMgdXNlZCB0byBtYWtlIFtBY2Nlc3NvcnNfZ2VuZXJpY10gZmxleGlibGUgYXMgdG8gd2hldGhlclxuICAgICAgYSBjb21wYXJhdG9yIGlzIHJlcXVpcmVkIHRvIGJlIHBhc3NlZCB0byBjZXJ0YWluIGZ1bmN0aW9ucy4gKilcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHR5cGUgJ2NtcCBjbXBcblxuICB2YWwgaW52YXJpYW50cyA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+IGJvb2wpIGFjY2Vzc19vcHRpb25zXG5cbiAgKCoqIG92ZXJyaWRlIFtDb250YWluZXJdJ3MgW21lbV0gKilcbiAgdmFsIG1lbSA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiBib29sKSBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBhZGQgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAnYSBlbHQgLT4gKCdhLCAnY21wKSB0KSBhY2Nlc3Nfb3B0aW9uc1xuICB2YWwgcmVtb3ZlIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gJ2EgZWx0IC0+ICgnYSwgJ2NtcCkgdCkgYWNjZXNzX29wdGlvbnNcbiAgdmFsIHVuaW9uIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCkgYWNjZXNzX29wdGlvbnNcbiAgdmFsIGludGVyIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCkgYWNjZXNzX29wdGlvbnNcbiAgdmFsIGRpZmYgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0KSBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhIGVsdCwgJ2EgZWx0KSBFaXRoZXIudCBTZXF1ZW5jZS50IClcbiAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGludCkgYWNjZXNzX29wdGlvbnNcbiAgdmFsIGVxdWFsIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2wpIGFjY2Vzc19vcHRpb25zXG4gIHZhbCBpc19zdWJzZXQgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiBvZl86KCdhLCAnY21wKSB0IC0+IGJvb2wpIGFjY2Vzc19vcHRpb25zXG4gIHZhbCBhcmVfZGlzam9pbnQgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbCkgYWNjZXNzX29wdGlvbnNcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB2YWwgaXNfc3Vic2V0XG4gICAgICA6ICggJ2FcbiAgICAgICAgLCAnY21wXG4gICAgICAgICwgKCdhLCAnY21wKSB0IE5hbWVkLnQgLT4gb2ZfOignYSwgJ2NtcCkgdCBOYW1lZC50IC0+IHVuaXQgT3JfZXJyb3IudCApXG4gICAgICAgIGFjY2Vzc19vcHRpb25zXG5cbiAgICB2YWwgZXF1YWxcbiAgICAgIDogKCAnYVxuICAgICAgICAsICdjbXBcbiAgICAgICAgLCAoJ2EsICdjbXApIHQgTmFtZWQudCAtPiAoJ2EsICdjbXApIHQgTmFtZWQudCAtPiB1bml0IE9yX2Vycm9yLnQgKVxuICAgICAgICBhY2Nlc3Nfb3B0aW9uc1xuICBlbmRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KCdhY2MgLT4gJ2EgZWx0IC0+ICgnYWNjLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgXykgdCAtPiBpbml0OidhY2MgLT4gZjooJ2EgZWx0IC0+ICdhY2MgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gIHZhbCBpdGVyMlxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdFxuICAgICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgICAgLT4gZjooWyBgTGVmdCBvZiAnYSBlbHQgfCBgUmlnaHQgb2YgJ2EgZWx0IHwgYEJvdGggb2YgJ2EgZWx0ICogJ2EgZWx0IF0gLT4gdW5pdClcbiAgICAgICAgLT4gdW5pdCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXIgOiAoJ2EsICdjbXApIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgcGFydGl0aW9uX3RmIDogKCdhLCAnY21wKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgKiAoJ2EsICdjbXApIHRcbiAgdmFsIGVsZW1lbnRzIDogKCdhLCBfKSB0IC0+ICdhIGVsdCBsaXN0XG4gIHZhbCBtaW5fZWx0IDogKCdhLCBfKSB0IC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhIGVsdFxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYSBlbHRcbiAgdmFsIGNob29zZSA6ICgnYSwgXykgdCAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBjaG9vc2VfZXhuIDogKCdhLCBfKSB0IC0+ICdhIGVsdFxuXG4gIHZhbCBzcGxpdFxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdCAtPiAnYSBlbHQgLT4gKCdhLCAnY21wKSB0ICogJ2EgZWx0IG9wdGlvbiAqICgnYSwgJ2NtcCkgdCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBzcGxpdF9sZV9ndFxuICAgIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gJ2EgZWx0IC0+ICgnYSwgJ2NtcCkgdCAqICgnYSwgJ2NtcCkgdCkgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgc3BsaXRfbHRfZ2VcbiAgICA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiAoJ2EsICdjbXApIHQgKiAoJ2EsICdjbXApIHQpIGFjY2Vzc19vcHRpb25zXG5cbiAgdmFsIGdyb3VwX2J5IDogKCdhLCAnY21wKSB0IC0+IGVxdWl2OignYSBlbHQgLT4gJ2EgZWx0IC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCBsaXN0XG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gJ2EgZWx0XG4gIHZhbCBudGggOiAoJ2EsIF8pIHQgLT4gaW50IC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIHJlbW92ZV9pbmRleCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+IGludCAtPiAoJ2EsICdjbXApIHQpIGFjY2Vzc19vcHRpb25zXG4gIHZhbCB0b190cmVlIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgICAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYSBlbHRcbiAgICAgICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2EgZWx0XG4gICAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgICAtPiAnYSBlbHQgU2VxdWVuY2UudCApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0XG4gICAgICAgIC0+IGNvbXBhcmU6KCdhIGVsdCAtPiAna2V5IC0+IGludClcbiAgICAgICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgICAgIC0+ICdrZXlcbiAgICAgICAgLT4gJ2EgZWx0IG9wdGlvbiApXG4gICAgICBhY2Nlc3Nfb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdFxuICAgICAgICAtPiBzZWdtZW50X29mOignYSBlbHQgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgICAgIC0+ICdhIGVsdCBvcHRpb24gKVxuICAgICAgYWNjZXNzX29wdGlvbnNcblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAgICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2EgZWx0XG4gICAgICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhIGVsdFxuICAgICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAgIC0+ICgnYSBlbHQsICdhIGVsdCkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnQgKVxuICAgICAgYWNjZXNzX29wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdhLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnY21wKSBzZXRcbiAgdHlwZSAoJ2EsICdjbXApIHRyZWVcbiAgdHlwZSAnYSBlbHRcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBjcmVhdGVfb3B0aW9uc1xuICB0eXBlICdjbXAgY21wXG5cbiAgdmFsIGVtcHR5IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG4gIHZhbCBzaW5nbGV0b24gOiAoJ2EsICdjbXAsICdhIGVsdCAtPiAoJ2EsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG4gIHZhbCB1bmlvbl9saXN0IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG4gIHZhbCBvZl9saXN0IDogKCdhLCAnY21wLCAnYSBlbHQgbGlzdCAtPiAoJ2EsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG4gIHZhbCBvZl9zZXF1ZW5jZSA6ICgnYSwgJ2NtcCwgJ2EgZWx0IFNlcXVlbmNlLnQgLT4gKCdhLCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuICB2YWwgb2ZfYXJyYXkgOiAoJ2EsICdjbXAsICdhIGVsdCBhcnJheSAtPiAoJ2EsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXkgOiAoJ2EsICdjbXAsICdhIGVsdCBhcnJheSAtPiAoJ2EsICdjbXApIHQgT3JfZXJyb3IudCkgY3JlYXRlX29wdGlvbnNcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgOiAoJ2EsICdjbXAsICdhIGVsdCBhcnJheSAtPiAoJ2EsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAoJ2EsICdjbXAsIGxlbjppbnQgLT4gZjooaW50IC0+ICdhIGVsdCkgLT4gKCdhLCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBzdGFibGVfZGVkdXBfbGlzdCA6ICgnYSwgXywgJ2EgZWx0IGxpc3QgLT4gJ2EgZWx0IGxpc3QpIGNyZWF0ZV9vcHRpb25zXG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDIzLTA0XSBVc2UgW0xpc3Quc3RhYmxlX2RlZHVwXSBpbnN0ZWFkLlwiXVxuXG4gICgqKiBUaGUgdHlwZXMgb2YgW21hcF0gYW5kIFtmaWx0ZXJfbWFwXSBhcmUgc3VidGxlLiAgVGhlIGlucHV0IHNldCwgWygnYSwgXykgc2V0XSxcbiAgICAgIHJlZmxlY3RzIHRoZSBmYWN0IHRoYXQgdGhlc2UgZnVuY3Rpb25zIHRha2UgYSBzZXQgb2YgKmFueSogdHlwZSwgd2l0aCBhbnlcbiAgICAgIGNvbXBhcmF0b3IsIHdoaWxlIHRoZSBvdXRwdXQgc2V0LCBbKCdiLCAnY21wKSB0XSwgcmVmbGVjdHMgdGhhdCB0aGUgb3V0cHV0IHNldCBoYXNcbiAgICAgIHRoZSBwYXJ0aWN1bGFyIFsnY21wXSBvZiB0aGUgY3JlYXRpb24gZnVuY3Rpb24uICBUaGUgY29tcGFyYXRvciBjYW4gY29tZSBpbiBvbmUgb2ZcbiAgICAgIHRocmVlIHdheXMsIGRlcGVuZGluZyBvbiB3aGljaCBzZXQgbW9kdWxlIGlzIHVzZWRcblxuICAgICAgLSBbU2V0Lm1hcF0gLS0gY29tcGFyYXRvciBjb21lcyBhcyBhbiBhcmd1bWVudFxuICAgICAgLSBbU2V0LlBvbHkubWFwXSAtLSBjb21wYXJhdG9yIGlzIHBvbHltb3JwaGljIGNvbXBhcmlzb25cbiAgICAgIC0gW0Zvby5TZXQubWFwXSAtLSBjb21wYXJhdG9yIGlzIFtGb28uY29tcGFyYXRvcl0gKilcbiAgdmFsIG1hcCA6ICgnYiwgJ2NtcCwgKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gJ2IgZWx0KSAtPiAoJ2IsICdjbXApIHQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIGZpbHRlcl9tYXBcbiAgICA6ICgnYiwgJ2NtcCwgKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gJ2IgZWx0IG9wdGlvbikgLT4gKCdiLCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl90cmVlIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHRyZWUgLT4gKCdhLCAnY21wKSB0KSBjcmVhdGVfb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnZWx0LCAnY21wKSBzZXRcbiAgdHlwZSAoJ2VsdCwgJ2NtcCkgdFxuICB0eXBlICgnZWx0LCAnY21wKSB0cmVlXG4gIHR5cGUgJ2VsdCBlbHRcbiAgdHlwZSAnY21wIGNtcFxuXG4gIGluY2x1ZGVcbiAgICBBY2Nlc3NvcnNfZ2VuZXJpY1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdHJlZVxuICAgICAgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBlbHRcbiAgICAgIHdpdGggdHlwZSAnY21wIGNtcCA6PSAnY21wIGNtcFxuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yc19nZW5lcmljXG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgc2V0IDo9ICgnYSwgJ2IpIHNldFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdHJlZVxuICAgICAgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBlbHRcbiAgICAgIHdpdGggdHlwZSAnY21wIGNtcCA6PSAnY21wIGNtcFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfcG9seSA9IHNpZ1xuICB0eXBlICgnZWx0LCAnY21wKSBzZXRcbiAgdHlwZSAnZWx0IHRcbiAgdHlwZSAnZWx0IHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljXG4gICAgICB3aXRoIHR5cGUgKCdlbHQsICdjbXApIHNldCA6PSAoJ2VsdCwgJ2NtcCkgc2V0XG4gICAgICB3aXRoIHR5cGUgKCdlbHQsICdjbXApIHQgOj0gJ2VsdCB0XG4gICAgICB3aXRoIHR5cGUgKCdlbHQsICdjbXApIHRyZWUgOj0gJ2VsdCB0cmVlXG4gICAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhXG4gICAgICB3aXRoIHR5cGUgJ2MgY21wIDo9IGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aG91dF9jb21wYXJhdG9yLnRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgYWNjZXNzX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIFdpdGhvdXRfY29tcGFyYXRvci50XG5lbmRcblxubW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuXG4gIG1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gICAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gICAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQ29tcGFyZV9tID0gc2lnIGVuZFxuICBtb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxuICBtb2R1bGUgdHlwZSBIYXNoX2ZvbGRfbSA9IEhhc2hlci5TXG5cbiAgdmFsIHNleHBfb2ZfbV9fdCA6IChtb2R1bGUgU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gJ2VsdCkgLT4gKCdlbHQsICdjbXApIHQgLT4gU2V4cC50XG5cbiAgdmFsIG1fX3Rfb2Zfc2V4cFxuICAgIDogIChtb2R1bGUgTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gJ2VsdCBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnY21wKVxuICAgIC0+IFNleHAudFxuICAgIC0+ICgnZWx0LCAnY21wKSB0XG5cbiAgdmFsIG1fX3Rfc2V4cF9ncmFtbWFyXG4gICAgOiAgKG1vZHVsZSBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9ICdlbHQpXG4gICAgLT4gKCdlbHQsICdjbXApIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICB2YWwgY29tcGFyZV9tX190IDogKG1vZHVsZSBDb21wYXJlX20pIC0+ICgnZWx0LCAnY21wKSB0IC0+ICgnZWx0LCAnY21wKSB0IC0+IGludFxuICB2YWwgZXF1YWxfbV9fdCA6IChtb2R1bGUgRXF1YWxfbSkgLT4gKCdlbHQsICdjbXApIHQgLT4gKCdlbHQsICdjbXApIHQgLT4gYm9vbFxuXG4gIHZhbCBoYXNoX2ZvbGRfbV9fdFxuICAgIDogIChtb2R1bGUgSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSAnZWx0KVxuICAgIC0+IEhhc2guc3RhdGVcbiAgICAtPiAoJ2VsdCwgXykgdFxuICAgIC0+IEhhc2guc3RhdGVcblxuICB2YWwgaGFzaF9tX190IDogKG1vZHVsZSBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9ICdlbHQpIC0+ICgnZWx0LCBfKSB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNldCA9IHNpZ1xuICAoKiogU2V0cyBiYXNlZCBvbiB7IUNvbXBhcmF0b3IuU30uXG5cbiAgICAgIENyZWF0b3JzIHJlcXVpcmUgYSBjb21wYXJhdG9yIGFyZ3VtZW50IHRvIGJlIHBhc3NlZCBpbiwgd2hlcmVhcyBhY2Nlc3NvcnMgdXNlIHRoZVxuICAgICAgY29tcGFyYXRvciBwcm92aWRlZCBieSB0aGUgaW5wdXQgc2V0LiAqKVxuXG4gICgqKiBUaGUgdHlwZSBvZiBhIHNldC4gIFRoZSBmaXJzdCB0eXBlIHBhcmFtZXRlciBpZGVudGlmaWVzIHRoZSB0eXBlIG9mIHRoZSBlbGVtZW50LCBhbmRcbiAgICAgIHRoZSBzZWNvbmQgaWRlbnRpZmllcyB0aGUgY29tcGFyYXRvciwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbiB0aGF0XG4gICAgICBpcyB1c2VkIGZvciBvcmRlcmluZyBlbGVtZW50cyBpbiB0aGlzIHNldC4gIE1hbnkgb3BlcmF0aW9ucyAoZS5nLiwgeyF1bmlvbn0pLFxuICAgICAgcmVxdWlyZSB0aGF0IHRoZXkgYmUgcGFzc2VkIHNldHMgd2l0aCB0aGUgc2FtZSBlbGVtZW50IHR5cGUgYW5kIHRoZSBzYW1lIGNvbXBhcmF0b3JcbiAgICAgIHR5cGUuICopXG4gIHR5cGUgKCEnZWx0LCAhJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZV1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMyIHdpdGggdHlwZSAoISdlbHQsICEnY21wKSB0IDo9ICgnZWx0LCAnY21wKSB0XG5cbiAgW0BAQGVuZF1cblxuICAoKiogVGVzdHMgaW50ZXJuYWwgaW52YXJpYW50cyBvZiB0aGUgc2V0IGRhdGEgc3RydWN0dXJlLiAgUmV0dXJucyB0cnVlIG9uIHN1Y2Nlc3MuICopXG4gIHZhbCBpbnZhcmlhbnRzIDogKF8sIF8pIHQgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIGEgZmlyc3QtY2xhc3MgbW9kdWxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gYnVpbGQgb3RoZXIgbWFwL3NldC9ldGNcbiAgICAgIHdpdGggdGhlIHNhbWUgbm90aW9uIG9mIGNvbXBhcmlzb24uICopXG4gIHZhbCBjb21wYXJhdG9yX3MgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLnRcblxuICAoKiogQ3JlYXRlcyBhbiBlbXB0eSBzZXQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvbXBhcmF0b3IuICopXG4gIHZhbCBlbXB0eSA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIHNldCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgY29tcGFyYXRvciB0aGF0IGNvbnRhaW5zIG9ubHkgdGhlIHByb3ZpZGVkXG4gICAgICBlbGVtZW50LiAqKVxuICB2YWwgc2luZ2xldG9uIDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBSZXR1cm5zIHRoZSBjYXJkaW5hbGl0eSBvZiB0aGUgc2V0LiBbTygxKV0uICopXG4gIHZhbCBsZW5ndGggOiAoXywgXykgdCAtPiBpbnRcblxuICAoKiogW2lzX2VtcHR5IHRdIGlzIFt0cnVlXSBpZmYgW3RdIGlzIGVtcHR5LiAgW08oMSldLiAqKVxuICB2YWwgaXNfZW1wdHkgOiAoXywgXykgdCAtPiBib29sXG5cbiAgKCoqIFttZW0gdCBhXSByZXR1cm5zIFt0cnVlXSBpZmYgW2FdIGlzIGluIFt0XS4gIFtPKGxvZyBuKV0uICopXG4gIHZhbCBtZW0gOiAoJ2EsIF8pIHQgLT4gJ2EgLT4gYm9vbFxuXG4gICgqKiBbYWRkIHQgYV0gcmV0dXJucyBhIG5ldyBzZXQgd2l0aCBbYV0gYWRkZWQgdG8gW3RdLCBvciByZXR1cm5zIFt0XSBpZiBbbWVtIHQgYV0uXG4gICAgICBbTyhsb2cgbildLiAqKVxuICB2YWwgYWRkIDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbcmVtb3ZlIHQgYV0gcmV0dXJucyBhIG5ldyBzZXQgd2l0aCBbYV0gcmVtb3ZlZCBmcm9tIFt0XSBpZiBbbWVtIHQgYV0sIG9yIHJldHVybnMgW3RdXG4gICAgICBvdGhlcndpc2UuICBbTyhsb2cgbildLiAqKVxuICB2YWwgcmVtb3ZlIDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbdW5pb24gdDEgdDJdIHJldHVybnMgdGhlIHVuaW9uIG9mIHRoZSB0d28gc2V0cy4gIFtPKGxlbmd0aCB0MSArIGxlbmd0aCB0MildLiAqKVxuICB2YWwgdW5pb24gOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbdW5pb25fbGlzdCBjIGxpc3RdIHJldHVybnMgdGhlIHVuaW9uIG9mIGFsbCB0aGUgc2V0cyBpbiBbbGlzdF0uICBUaGVcbiAgICAgIFtjb21wYXJhdG9yXSBhcmd1bWVudCBpcyByZXF1aXJlZCBmb3IgdGhlIGNhc2Ugd2hlcmUgW2xpc3RdIGlzIGVtcHR5LlxuICAgICAgW08obWF4KExpc3QubGVuZ3RoIGxpc3QsIG4gbG9nIG4pKV0sIHdoZXJlIFtuXSBpcyB0aGUgc3VtIG9mIHNpemVzIG9mIHRoZSBpbnB1dCBzZXRzLiAqKVxuICB2YWwgdW5pb25fbGlzdCA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2ludGVyIHQxIHQyXSBjb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHNldHMgW3QxXSBhbmQgW3QyXS4gIFtPKGxlbmd0aCB0MSArXG4gICAgICBsZW5ndGggdDIpXS4gKilcbiAgdmFsIGludGVyIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2RpZmYgdDEgdDJdIGNvbXB1dGVzIHRoZSBzZXQgZGlmZmVyZW5jZSBbdDEgLSB0Ml0sIGkuZS4sIHRoZSBzZXQgY29udGFpbmluZyBhbGxcbiAgICAgIGVsZW1lbnRzIGluIFt0MV0gdGhhdCBhcmUgbm90IGluIFt0Ml0uICBbTyhsZW5ndGggdDEgKyBsZW5ndGggdDIpXS4gKilcbiAgdmFsIGRpZmYgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbc3ltbWV0cmljX2RpZmYgdDEgdDJdIHJldHVybnMgYSBzZXF1ZW5jZSBvZiBjaGFuZ2VzIGJldHdlZW4gW3QxXSBhbmQgW3QyXS4gSXQgaXNcbiAgICAgIGludGVuZGVkIHRvIGJlIGVmZmljaWVudCBpbiB0aGUgY2FzZSB3aGVyZSBbdDFdIGFuZCBbdDJdIHNoYXJlIGEgbGFyZ2UgYW1vdW50IG9mXG4gICAgICBzdHJ1Y3R1cmUuICopXG4gIHZhbCBzeW1tZXRyaWNfZGlmZiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnYSkgRWl0aGVyLnQgU2VxdWVuY2UudFxuXG4gICgqKiBbY29tcGFyZV9kaXJlY3QgdDEgdDJdIGNvbXBhcmVzIHRoZSBzZXRzIFt0MV0gYW5kIFt0Ml0uICBJdCByZXR1cm5zIHRoZSBzYW1lIHJlc3VsdFxuICAgICAgYXMgW2NvbXBhcmVdLCBidXQgdW5saWtlIGNvbXBhcmUsIGRvZXNuJ3QgcmVxdWlyZSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIGluIGZvciB0aGVcbiAgICAgIHR5cGUgcGFyYW1ldGVycyBvZiB0aGUgc2V0LiAgW08obGVuZ3RoIHQxICsgbGVuZ3RoIHQyKV0uICopXG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gaW50XG5cbiAgKCoqIEhhc2ggZnVuY3Rpb246IGEgYnVpbGRpbmcgYmxvY2sgdG8gdXNlIHdoZW4gaGFzaGluZyBkYXRhIHN0cnVjdHVyZXMgY29udGFpbmluZyBzZXRzIGluXG4gICAgICB0aGVtLiBbaGFzaF9mb2xkX2RpcmVjdCBoYXNoX2ZvbGRfa2V5XSBpcyBjb21wYXRpYmxlIHdpdGggW2NvbXBhcmVfZGlyZWN0XSBpZmZcbiAgICAgIFtoYXNoX2ZvbGRfa2V5XSBpcyBjb21wYXRpYmxlIHdpdGggWyhjb21wYXJhdG9yIHMpLmNvbXBhcmVdIG9mIHRoZSBzZXQgW3NdIGJlaW5nXG4gICAgICBoYXNoZWQuICopXG4gIHZhbCBoYXNoX2ZvbGRfZGlyZWN0IDogJ2EgSGFzaC5mb2xkZXIgLT4gKCdhLCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgKCoqIFtlcXVhbCB0MSB0Ml0gcmV0dXJucyBbdHJ1ZV0gaWZmIHRoZSB0d28gc2V0cyBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzLiAgW08obGVuZ3RoIHQxICtcbiAgICAgIGxlbmd0aCB0MildICopXG4gIHZhbCBlcXVhbCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gICgqKiBbZXhpc3RzIHQgfmZdIHJldHVybnMgW3RydWVdIGlmZiB0aGVyZSBleGlzdHMgYW4gW2FdIGluIFt0XSBmb3Igd2hpY2ggW2YgYV0uICBbTyhuKV0sXG4gICAgICBidXQgcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGFuIFthXSBmb3Igd2hpY2ggW2YgYV0uICopXG4gIHZhbCBleGlzdHMgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBbZm9yX2FsbCB0IH5mXSByZXR1cm5zIFt0cnVlXSBpZmYgZm9yIGFsbCBbYV0gaW4gW3RdLCBbZiBhXS4gIFtPKG4pXSwgYnV0IHJldHVybnMgYXNcbiAgICAgIHNvb24gYXMgaXQgZmluZHMgYW4gW2FdIGZvciB3aGljaCBbbm90IChmIGEpXS4gKilcbiAgdmFsIGZvcl9hbGwgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBbY291bnQgdF0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIFt0XSBmb3Igd2hpY2ggW2ZdIHJldHVybnMgW3RydWVdLlxuICAgICAgW08obildLiAqKVxuICB2YWwgY291bnQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFtzdW0gdF0gcmV0dXJucyB0aGUgc3VtIG9mIFtmIHRdIGZvciBlYWNoIFt0XSBpbiB0aGUgc2V0LlxuICAgICAgW08obildLiAqKVxuICB2YWwgc3VtXG4gICAgOiAgKG1vZHVsZSBDb250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKVxuICAgIC0+ICgnYSwgXykgdFxuICAgIC0+IGY6KCdhIC0+ICdzdW0pXG4gICAgLT4gJ3N1bVxuXG4gICgqKiBbZmluZCB0IGZdIHJldHVybnMgYW4gZWxlbWVudCBvZiBbdF0gZm9yIHdoaWNoIFtmXSByZXR1cm5zIHRydWUsIHdpdGggbm8gZ3VhcmFudGVlIGFzXG4gICAgICB0byB3aGljaCBlbGVtZW50IGlzIHJldHVybmVkLiAgW08obildLCBidXQgcmV0dXJucyBhcyBzb29uIGFzIGEgc3VpdGFibGUgZWxlbWVudCBpc1xuICAgICAgZm91bmQuICopXG4gIHZhbCBmaW5kIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvblxuXG4gICgqKiBbZmluZF9tYXAgdCBmXSByZXR1cm5zIFtiXSBmb3Igc29tZSBbYV0gaW4gW3RdIGZvciB3aGljaCBbZiBhID0gU29tZSBiXS4gIElmIG5vIHN1Y2hcbiAgICAgIFthXSBleGlzdHMsIHRoZW4gW2ZpbmRdIHJldHVybnMgW05vbmVdLiAgW08obildLCBidXQgcmV0dXJucyBhcyBzb29uIGFzIGEgc3VpdGFibGVcbiAgICAgIGVsZW1lbnQgaXMgZm91bmQuICopXG4gIHZhbCBmaW5kX21hcCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiAnYiBvcHRpb24pIC0+ICdiIG9wdGlvblxuXG4gICgqKiBMaWtlIFtmaW5kXSwgYnV0IHRocm93cyBhbiBleGNlcHRpb24gb24gZmFpbHVyZS4gKilcbiAgdmFsIGZpbmRfZXhuIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhXG5cbiAgKCoqIFtudGggdCBpXSByZXR1cm5zIHRoZSBbaV10aCBzbWFsbGVzdCBlbGVtZW50IG9mIFt0XSwgaW4gW08obG9nIG4pXSB0aW1lLiAgVGhlXG4gICAgICBzbWFsbGVzdCBlbGVtZW50IGhhcyBbaSA9IDBdLiAgUmV0dXJucyBbTm9uZV0gaWYgW2kgPCAwXSBvciBbaSA+PSBsZW5ndGggdF0uICopXG4gIHZhbCBudGggOiAoJ2EsIF8pIHQgLT4gaW50IC0+ICdhIG9wdGlvblxuXG4gICgqKiBbcmVtb3ZlX2luZGV4IHQgaV0gcmV0dXJucyBhIHZlcnNpb24gb2YgW3RdIHdpdGggdGhlIFtpXXRoIHNtYWxsZXN0IGVsZW1lbnQgcmVtb3ZlZCxcbiAgICAgIGluIFtPKGxvZyBuKV0gdGltZS4gIFRoZSBzbWFsbGVzdCBlbGVtZW50IGhhcyBbaSA9IDBdLiAgUmV0dXJucyBbdF0gaWYgW2kgPCAwXSBvclxuICAgICAgW2kgPj0gbGVuZ3RoIHRdLiAqKVxuICB2YWwgcmVtb3ZlX2luZGV4IDogKCdhLCAnY21wKSB0IC0+IGludCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2lzX3N1YnNldCB0MSB+b2ZfOnQyXSByZXR1cm5zIHRydWUgaWZmIFt0MV0gaXMgYSBzdWJzZXQgb2YgW3QyXS4gKilcbiAgdmFsIGlzX3N1YnNldCA6ICgnYSwgJ2NtcCkgdCAtPiBvZl86KCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICAoKiogW2FyZV9kaXNqb2ludCB0MSB0Ml0gcmV0dXJucyBbdHJ1ZV0gaWZmIFtpc19lbXB0eSAoaW50ZXIgdDEgdDIpXSwgYnV0IGlzIG1vcmVcbiAgICAgIGVmZmljaWVudC4gKilcbiAgdmFsIGFyZV9kaXNqb2ludCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gICgqKiBbTmFtZWRdIGFsbG93cyB0aGUgdmFsaWRhdGlvbiBvZiBzdWJzZXQgYW5kIGVxdWFsaXR5IHJlbGF0aW9uc2hpcHMgYmV0d2VlbiBzZXRzLiAgQVxuICAgICAgW05hbWVkLnRdIGlzIGEgcmVjb3JkIG9mIGEgc2V0IGFuZCBhIG5hbWUsIHdoZXJlIHRoZSBuYW1lIGlzIHVzZWQgaW4gZXJyb3IgbWVzc2FnZXMsXG4gICAgICBhbmQgW05hbWVkLmlzX3N1YnNldF0gYW5kIFtOYW1lZC5lcXVhbF0gdmFsaWRhdGUgc3Vic2V0IGFuZCBlcXVhbGl0eSByZWxhdGlvbnNoaXBzXG4gICAgICByZXNwZWN0aXZlbHkuXG5cbiAgICAgIFRoZSBlcnJvciBtZXNzYWdlIGZvciwgZS5nLixcbiAgICAgIHtbXG4gICAgICAgIE5hbWVkLmlzX3N1YnNldCB7IHNldCA9IHNldDE7IG5hbWUgPSBcInNldDFcIiB9IH5vZl86e3NldCA9IHNldDI7IG5hbWUgPSBcInNldDJcIiB9XG4gICAgICBdfVxuXG4gICAgICBsb29rcyBsaWtlXG4gICAgICB7dlxuICAgICAgICAoXCJzZXQxIGlzIG5vdCBhIHN1YnNldCBvZiBzZXQyXCIgKGludmFsaWRfZWxlbWVudHMgKC4uLmVsZW1lbnRzIG9mIHNldDEgLSBzZXQyLi4uKSkpXG4gICAgICAgdn1cblxuICAgICAgc28gW25hbWVdIHNob3VsZCBiZSBhIG5vdW4gcGhyYXNlIHRoYXQgZG9lc24ndCBzb3VuZCBhd2t3YXJkIGluIHRoZSBhYm92ZSBlcnJvclxuICAgICAgbWVzc2FnZS4gIEV2ZW4gdGhvdWdoIGl0IGFkZHMgdmVyYm9zaXR5LCBjaG9vc2luZyBbbmFtZV1zIHRoYXQgc3RhcnQgd2l0aCB0aGUgcGhyYXNlXG4gICAgICBcInRoZSBzZXQgb2ZcIiBvZnRlbiBtYWtlcyB0aGUgZXJyb3IgbWVzc2FnZSBzb3VuZCBtb3JlIG5hdHVyYWwuXG4gICopXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnY21wKSBzZXQgOj0gKCdhLCAnY21wKSB0XG5cbiAgICB0eXBlICdhIHQgPSAnYSBOYW1lZC50ID1cbiAgICAgIHsgc2V0IDogJ2FcbiAgICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgICAgfVxuXG4gICAgKCoqIFtpc19zdWJzZXQgdDEgfm9mXzp0Ml0gcmV0dXJucyBbT2sgKCldIGlmIFt0MV0gaXMgYSBzdWJzZXQgb2YgW3QyXSBhbmQgYVxuICAgICAgICBodW1hbi1yZWFkYWJsZSBlcnJvciBvdGhlcndpc2UuICAqKVxuICAgIHZhbCBpc19zdWJzZXQgOiAoJ2EsICdjbXApIHNldCB0IC0+IG9mXzooJ2EsICdjbXApIHNldCB0IC0+IHVuaXQgT3JfZXJyb3IudFxuXG4gICAgKCoqIFtlcXVhbCB0MSB0Ml0gcmV0dXJucyBbT2sgKCldIGlmIFt0MV0gaXMgZXF1YWwgdG8gW3QyXSBhbmQgYSBodW1hbi1yZWFkYWJsZVxuICAgICAgICBlcnJvciBvdGhlcndpc2UuICAqKVxuICAgIHZhbCBlcXVhbCA6ICgnYSwgJ2NtcCkgc2V0IHQgLT4gKCdhLCAnY21wKSBzZXQgdCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgZW5kXG5cbiAgKCoqIFRoZSBsaXN0IG9yIGFycmF5IGdpdmVuIHRvIFtvZl9saXN0XSBhbmQgW29mX2FycmF5XSBuZWVkIG5vdCBiZSBzb3J0ZWQuICopXG4gIHZhbCBvZl9saXN0IDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIGxpc3QgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIG9mX3NlcXVlbmNlIDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIFNlcXVlbmNlLnQgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9hcnJheSA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSBhcnJheSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3RvX2xpc3RdIGFuZCBbdG9fYXJyYXldIHByb2R1Y2Ugc2VxdWVuY2VzIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAgY29tcGFyYXRvci4gKilcbiAgdmFsIHRvX2xpc3QgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuXG4gIHZhbCB0b19hcnJheSA6ICgnYSwgXykgdCAtPiAnYSBhcnJheVxuXG4gICgqKiBDcmVhdGUgc2V0IGZyb20gc29ydGVkIGFycmF5LiAgVGhlIGlucHV0IG11c3QgYmUgc29ydGVkIChlaXRoZXIgaW4gYXNjZW5kaW5nIG9yXG4gICAgICBkZXNjZW5kaW5nIG9yZGVyIGFzIGdpdmVuIGJ5IHRoZSBjb21wYXJhdG9yKSBhbmQgY29udGFpbiBubyBkdXBsaWNhdGVzLCBvdGhlcndpc2UgdGhlXG4gICAgICByZXN1bHQgaXMgYW4gZXJyb3IuICBUaGUgY29tcGxleGl0eSBvZiB0aGlzIGZ1bmN0aW9uIGlzIFtPKG4pXS4gKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICdhIGFycmF5XG4gICAgLT4gKCdhLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogU2ltaWxhciB0byBbb2Zfc29ydGVkX2FycmF5XSwgYnV0IHdpdGhvdXQgY2hlY2tpbmcgdGhlIGlucHV0IGFycmF5LiAqKVxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICdhIGFycmF5XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCBjIH5sZW4gfmZdIGJlaGF2ZXMgbGlrZSBbb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBjXG4gICAgICAoQXJyYXkuaW5pdCBsZW4gfmYpXSwgd2l0aCB0aGUgYWRkaXRpb25hbCByZXN0cmljdGlvbiB0aGF0IGEgZGVjcmVhc2luZyBvcmRlciBpcyBub3RcbiAgICAgIHN1cHBvcnRlZC4gIFRoZSBhZHZhbnRhZ2UgaXMgbm90IHJlcXVpcmluZyB5b3UgdG8gYWxsb2NhdGUgYW4gaW50ZXJtZWRpYXRlIGFycmF5LiAgW2ZdXG4gICAgICB3aWxsIGJlIGNhbGxlZCB3aXRoIDAsIDEsIC4uLiBbbGVuIC0gMV0sIGluIG9yZGVyLiAqKVxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gZjooaW50IC0+ICdhKVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbc3RhYmxlX2RlZHVwX2xpc3RdIGlzIGhlcmUgcmF0aGVyIHRoYW4gaW4gdGhlIFtMaXN0XSBtb2R1bGUgYmVjYXVzZSB0aGVcbiAgICAgIGltcGxlbWVudGF0aW9uIHJlbGllcyBjcnVjaWFsbHkgb24gc2V0cywgYW5kIGJlY2F1c2UgZG9pbmcgc28gYWxsb3dzIG9uZSB0byBhdm9pZCB1c2VzXG4gICAgICBvZiBwb2x5bW9ycGhpYyBjb21wYXJpc29uIGJ5IGluc3RhbnRpYXRpbmcgdGhlIGZ1bmN0b3IgYXQgYSBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb25cbiAgICAgIG9mIFtDb21wYXJhdG9yXSBhbmQgdXNpbmcgdGhlIHJlc3VsdGluZyBbc3RhYmxlX2RlZHVwX2xpc3RdLiAqKVxuICB2YWwgc3RhYmxlX2RlZHVwX2xpc3QgOiAoJ2EsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDIzLTA0XSBVc2UgW0xpc3Quc3RhYmxlX2RlZHVwXSBpbnN0ZWFkLlwiXVxuXG4gICgqKiBbbWFwIGMgdCB+Zl0gcmV0dXJucyBhIG5ldyBzZXQgY3JlYXRlZCBieSBhcHBseWluZyBbZl0gdG8gZXZlcnkgZWxlbWVudCBpblxuICAgICAgW3RdLiAgVGhlIHJldHVybmVkIHNldCBpcyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgW2NvbXBhcmF0b3JdLiAgW08obiBsb2cgbildLiAqKVxuICB2YWwgbWFwIDogKCdiLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICgnYSwgXykgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnY21wKSB0XG5cbiAgKCoqIExpa2UgeyFtYXB9LCBleGNlcHQgZWxlbWVudHMgZm9yIHdoaWNoIFtmXSByZXR1cm5zIFtOb25lXSB3aWxsIGJlIGRyb3BwZWQuICAqKVxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogICgnYiwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSwgXykgdFxuICAgIC0+IGY6KCdhIC0+ICdiIG9wdGlvbilcbiAgICAtPiAoJ2IsICdjbXApIHRcblxuICAoKiogW2ZpbHRlciB0IH5mXSByZXR1cm5zIHRoZSBzdWJzZXQgb2YgW3RdIGZvciB3aGljaCBbZl0gZXZhbHVhdGVzIHRvIHRydWUuICBbTyhuIGxvZ1xuICAgICAgbildLiAqKVxuICB2YWwgZmlsdGVyIDogKCdhLCAnY21wKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSBmb2xkcyBvdmVyIHRoZSBlbGVtZW50cyBvZiB0aGUgc2V0IGZyb20gc21hbGxlc3QgdG8gbGFyZ2VzdC4gKilcbiAgdmFsIGZvbGQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYWNjIC0+IGY6KCdhY2MgLT4gJ2EgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gICgqKiBbZm9sZF9yZXN1bHQgfmluaXQgfmZdIGZvbGRzIG92ZXIgdGhlIGVsZW1lbnRzIG9mIHRoZSBzZXQgZnJvbSBzbWFsbGVzdCB0b1xuICAgICAgbGFyZ2VzdCwgc2hvcnQgY2lyY3VpdGluZyB0aGUgZm9sZCBpZiBbZiBhY2N1bSB4XSBpcyBhbiBbRXJyb3IgX10gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooJ2FjYyAtPiAnYSAtPiAoJ2FjYywgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjLCAnZSkgUmVzdWx0LnRcblxuICAoKiogW2ZvbGRfdW50aWwgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdLiBJZiBbZl1cbiAgICAgIHJldHVybnMgW1N0b3AgX10gdGhlIGNvbXB1dGF0aW9uIGNlYXNlcyBhbmQgcmVzdWx0cyBpbiB0aGF0IHZhbHVlLiBJZiBbZl0gcmV0dXJuc1xuICAgICAgW0NvbnRpbnVlIF9dLCB0aGUgZm9sZCB3aWxsIHByb2NlZWQuICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooJ2FjYyAtPiAnYSAtPiAoJ2FjYywgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjYyAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIExpa2UgeyFmb2xkfSwgZXhjZXB0IHRoYXQgaXQgZ29lcyBmcm9tIHRoZSBsYXJnZXN0IHRvIHRoZSBzbWFsbGVzdCBlbGVtZW50LiAqKVxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgXykgdCAtPiBpbml0OidhY2MgLT4gZjooJ2EgLT4gJ2FjYyAtPiAnYWNjKSAtPiAnYWNjXG5cbiAgKCoqIFtpdGVyIHQgfmZdIGNhbGxzIFtmXSBvbiBldmVyeSBlbGVtZW50IG9mIFt0XSwgZ29pbmcgaW4gb3JkZXIgZnJvbSB0aGUgc21hbGxlc3QgdG9cbiAgICAgIGxhcmdlc3QuICAqKVxuICB2YWwgaXRlciA6ICgnYSwgXykgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIEl0ZXJhdGUgdHdvIHNldHMgc2lkZSBieSBzaWRlLiAgQ29tcGxleGl0eSBpcyBbTyhtK24pXSB3aGVyZSBbbV0gYW5kIFtuXSBhcmUgdGhlIHNpemVzXG4gICAgICBvZiB0aGUgdHdvIGlucHV0IHNldHMuICBBcyBhbiBleGFtcGxlLCB3aXRoIHRoZSBpbnB1dHMgWzA7IDFdIGFuZCBbMTsgMl0sIFtmXSB3aWxsIGJlXG4gICAgICBjYWxsZWQgd2l0aCBbYExlZnQgMF07IFtgQm90aCAoMSwgMSldOyBhbmQgW2BSaWdodCAyXS4gKilcbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gZjooWyBgTGVmdCBvZiAnYSB8IGBSaWdodCBvZiAnYSB8IGBCb3RoIG9mICdhICogJ2EgXSAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICAoKiogaWYgW2EsIGIgPSBwYXJ0aXRpb25fdGYgc2V0IH5mXSB0aGVuIFthXSBpcyB0aGUgZWxlbWVudHMgb24gd2hpY2ggW2ZdIHByb2R1Y2VkIFt0cnVlXSxcbiAgICAgIGFuZCBbYl0gaXMgdGhlIGVsZW1lbnRzIG9uIHdoaWNoIFtmXSBwcm9kdWNlcyBbZmFsc2VdLiAqKVxuICB2YWwgcGFydGl0aW9uX3RmIDogKCdhLCAnY21wKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCAqICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBTYW1lIGFzIHshdG9fbGlzdH0uICopXG4gIHZhbCBlbGVtZW50cyA6ICgnYSwgXykgdCAtPiAnYSBsaXN0XG5cbiAgKCoqIFJldHVybnMgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIHNldC4gIFtPKGxvZyBuKV0uICopXG4gIHZhbCBtaW5fZWx0IDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuXG4gICgqKiBMaWtlIHshbWluX2VsdH0sIGJ1dCB0aHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gZ2l2ZW4gYW4gZW1wdHkgc2V0LiAqKVxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcblxuICAoKiogUmV0dXJucyB0aGUgbGFyZ2VzdCBlbGVtZW50IG9mIHRoZSBzZXQuICBbTyhsb2cgbildLiAgKilcbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIExpa2UgeyFtYXhfZWx0fSwgYnV0IHRocm93cyBhbiBleGNlcHRpb24gd2hlbiBnaXZlbiBhbiBlbXB0eSBzZXQuICopXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYVxuXG4gICgqKiByZXR1cm5zIGFuIGFyYml0cmFyeSBlbGVtZW50LCBvciBbTm9uZV0gaWYgdGhlIHNldCBpcyBlbXB0eS4gKilcbiAgdmFsIGNob29zZSA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cblxuICAoKiogTGlrZSB7IWNob29zZX0sIGJ1dCB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIGFuIGVtcHR5IHNldC4gKilcbiAgdmFsIGNob29zZV9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcblxuICAoKiogW3NwbGl0IHQgeF0gcHJvZHVjZXMgYSB0cmlwbGUgWyh0MSwgbWF5YmVfeCwgdDIpXS5cblxuICAgICAgW3QxXSBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIHN0cmljdGx5IGxlc3MgdGhhbiBbeF0sXG4gICAgICBbbWF5YmVfeF0gaXMgdGhlIG1lbWJlciAoaWYgYW55KSBvZiBbdF0gd2hpY2ggY29tcGFyZXMgZXF1YWwgdG8gW3hdLFxuICAgICAgW3QyXSBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIHN0cmljdGx5IGxhcmdlciB0aGFuIFt4XS4gKilcbiAgdmFsIHNwbGl0IDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdCAqICdhIG9wdGlvbiAqICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbc3BsaXRfbGVfZ3QgdCB4XSBwcm9kdWNlcyBhIHBhaXIgWyh0MSwgdDIpXS5cblxuICAgICAgW3QxXSBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBbeF0sXG4gICAgICBbdDJdIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIFt4XS4gKilcbiAgdmFsIHNwbGl0X2xlX2d0IDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdCAqICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbc3BsaXRfbHRfZ2UgdCB4XSBwcm9kdWNlcyBhIHBhaXIgWyh0MSwgdDIpXS5cblxuICAgICAgW3QxXSBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIHN0cmljdGx5IGxlc3MgdGhhbiBbeF0sXG4gICAgICBbdDJdIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFt4XS4gKilcbiAgdmFsIHNwbGl0X2x0X2dlIDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdCAqICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBpZiBbZXF1aXZdIGlzIGFuIGVxdWl2YWxlbmNlIHByZWRpY2F0ZSwgdGhlbiBbZ3JvdXBfYnkgc2V0IH5lcXVpdl0gcHJvZHVjZXMgYSBsaXN0XG4gICAgICBvZiBlcXVpdmFsZW5jZSBjbGFzc2VzIChpLmUuLCBhIHNldC10aGVvcmV0aWMgcXVvdGllbnQpLiAgRS5nLixcblxuICAgICAge1tcbiAgICAgICAgbGV0IGNoYXJzID0gU2V0Lm9mX2xpc3QgWydBJzsgJ2EnOyAnYic7ICdjJ10gaW5cbiAgICAgICAgbGV0IGVxdWl2IGMgYycgPSBDaGFyLmVxdWFsIChDaGFyLnVwcGVyY2FzZSBjKSAoQ2hhci51cHBlcmNhc2UgYycpIGluXG4gICAgICAgIGdyb3VwX2J5IGNoYXJzIH5lcXVpdlxuICAgICAgXX1cblxuICAgICAgcHJvZHVjZXM6XG5cbiAgICAgIHtbXG4gICAgICAgIFtTZXQub2ZfbGlzdCBbJ0EnOydhJ107IFNldC5zaW5nbGV0b24gJ2InOyBTZXQuc2luZ2xldG9uICdjJ11cbiAgICAgIF19XG5cbiAgICAgIFtncm91cF9ieV0gcnVucyBpbiBPKG5eMikgdGltZSwgc28gaWYgeW91IGhhdmUgYSBjb21wYXJpc29uIGZ1bmN0aW9uLCBpdCdzIHVzdWFsbHlcbiAgICAgIG11Y2ggZmFzdGVyIHRvIHVzZSBbU2V0Lm9mX2xpc3RdLiAqKVxuICB2YWwgZ3JvdXBfYnkgOiAoJ2EsICdjbXApIHQgLT4gZXF1aXY6KCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCBsaXN0XG5cbiAgKCoqIFt0b19zZXF1ZW5jZSB0XSBjb252ZXJ0cyB0aGUgc2V0IFt0XSB0byBhIHNlcXVlbmNlIG9mIHRoZSBlbGVtZW50cyBiZXR3ZWVuXG4gICAgICBbZ3JlYXRlcl9vcl9lcXVhbF90b10gYW5kIFtsZXNzX29yX2VxdWFsX3RvXSBpbmNsdXNpdmUgaW4gdGhlIG9yZGVyIGluZGljYXRlZCBieVxuICAgICAgW29yZGVyXS4gIElmIFtncmVhdGVyX29yX2VxdWFsX3RvID4gbGVzc19vcl9lcXVhbF90b10gdGhlIHNlcXVlbmNlIGlzIGVtcHR5LiAgQ29zdCBpc1xuICAgICAgTyhsb2cgbikgdXAgZnJvbnQgYW5kIGFtb3J0aXplZCBPKDEpIGZvciBlYWNoIGVsZW1lbnQgcHJvZHVjZWQuICopXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nICgqKiBkZWZhdWx0ICopIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgd2hpY2ggZWx0XSByZXR1cm5zIHRoZSBlbGVtZW50IGluIFt0XSBzcGVjaWZpZWQgYnlcbiAgICAgIFtjb21wYXJlXSBhbmQgW3doaWNoXSwgaWYgb25lIGV4aXN0cy5cblxuICAgICAgW3RdIG11c3QgYmUgc29ydGVkIGluIGluY3JlYXNpbmcgb3JkZXIgYWNjb3JkaW5nIHRvIFtjb21wYXJlXSwgd2hlcmUgW2NvbXBhcmVdIGFuZFxuICAgICAgW2VsdF0gZGl2aWRlIFt0XSBpbnRvIHRocmVlIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHM6XG5cbiAgICAgIHt2XG4gICAgICAgIHwgIDwgZWx0ICB8ICA9IGVsdCAgfCAgPiBlbHQgIHxcbiAgICAgIHZ9XG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoXSByZXR1cm5zIGFuIGVsZW1lbnQgb24gdGhlIGJvdW5kYXJ5IG9mIHNlZ21lbnRzIGFzIHNwZWNpZmllZCBieVxuICAgICAgW3doaWNoXS4gIFNlZSB0aGUgZGlhZ3JhbSBiZWxvdyBuZXh0IHRvIHRoZSBbd2hpY2hdIHZhcmlhbnRzLlxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF0gZG9lcyBub3QgY2hlY2sgdGhhdCBbY29tcGFyZV0gb3JkZXJzIFt0XSwgYW5kIGJlaGF2aW9yIGlzXG4gICAgICB1bnNwZWNpZmllZCBpZiBbY29tcGFyZV0gZG9lc24ndCBvcmRlciBbdF0uICBCZWhhdmlvciBpcyBhbHNvIHVuc3BlY2lmaWVkIGlmXG4gICAgICBbY29tcGFyZV0gbXV0YXRlcyBbdF0uICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gWyBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gKCoqICAgICAgICB7diB8IDwgZWx0IFggfCAgICAgICAgICAgICAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAoKiogICAgIHt2IHwgICAgICA8PSBlbHQgICAgICAgWCB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYExhc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgICA9IGVsdCBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgRmlyc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCBYID0gZWx0ICAgfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gKCoqIHt2ICAgICAgICAgICB8IFggICAgICAgPj0gZWx0ICAgICAgfCB2fSAqKVxuICAgICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAoKiogICAge3YgICAgICAgICAgICAgICAgICAgICAgIHwgWCA+IGVsdCB8IHZ9ICopXG4gICAgICAgXVxuICAgIC0+ICdrZXlcbiAgICAtPiAnYSBvcHRpb25cblxuICAoKiogW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2Ygd2hpY2hdIHRha2VzIGEgW3NlZ21lbnRfb2ZdIGZ1bmN0aW9uIHRoYXRcbiAgICAgIGRpdmlkZXMgW3RdIGludG8gdHdvIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHM6XG5cbiAgICAgIHt2XG4gICAgICAgIHwgc2VnbWVudF9vZiBlbHQgPSBgTGVmdCB8IHNlZ21lbnRfb2YgZWx0ID0gYFJpZ2h0IHxcbiAgICAgIHZ9XG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZF0gcmV0dXJucyB0aGUgZWxlbWVudCBvbiB0aGUgYm91bmRhcnkgb2YgdGhlIHNlZ21lbnRzIGFzXG4gICAgICBzcGVjaWZpZWQgYnkgW3doaWNoXTogW2BMYXN0X29uX2xlZnRdIHlpZWxkcyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsZWZ0IHNlZ21lbnQsXG4gICAgICB3aGlsZSBbYEZpcnN0X29uX3JpZ2h0XSB5aWVsZHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHJpZ2h0IHNlZ21lbnQuICBJdCByZXR1cm5zXG4gICAgICBbTm9uZV0gaWYgdGhlIHNlZ21lbnQgaXMgZW1wdHkuXG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZF0gZG9lcyBub3QgY2hlY2sgdGhhdCBbc2VnbWVudF9vZl0gc2VnbWVudHMgW3RdIGFzIGluIHRoZVxuICAgICAgZGlhZ3JhbSwgYW5kIGJlaGF2aW9yIGlzIHVuc3BlY2lmaWVkIGlmIFtzZWdtZW50X29mXSBkb2Vzbid0IHNlZ21lbnQgW3RdLiAgQmVoYXZpb3JcbiAgICAgIGlzIGFsc28gdW5zcGVjaWZpZWQgaWYgW3NlZ21lbnRfb2ZdIG11dGF0ZXMgW3RdLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiBzZWdtZW50X29mOignYSAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gWyBgTGFzdF9vbl9sZWZ0IHwgYEZpcnN0X29uX3JpZ2h0IF1cbiAgICAtPiAnYSBvcHRpb25cblxuICAoKiogUHJvZHVjZXMgdGhlIGVsZW1lbnRzIG9mIHRoZSB0d28gc2V0cyBiZXR3ZWVuIFtncmVhdGVyX29yX2VxdWFsX3RvXSBhbmRcbiAgICAgIFtsZXNzX29yX2VxdWFsX3RvXSBpbiBbb3JkZXJdLCBub3Rpbmcgd2hldGhlciBlYWNoIGVsZW1lbnQgYXBwZWFycyBpbiB0aGUgbGVmdCBzZXQsXG4gICAgICB0aGUgcmlnaHQgc2V0LCBvciBib3RoLiAgSW4gdGhlIGJvdGggY2FzZSwgYm90aCBlbGVtZW50cyBhcmUgcmV0dXJuZWQsIGluIGNhc2UgdGhlXG4gICAgICBjYWxsZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW4gZWxlbWVudHMgdGhhdCBhcmUgZXF1YWwgdG8gdGhlIHNldHMnIGNvbXBhcmF0b3IuICBSdW5zXG4gICAgICBpbiBPKGxlbmd0aCB0ICsgbGVuZ3RoIHQnKS4gKilcbiAgbW9kdWxlIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQgOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBTZXF1ZW5jZS5NZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudC50ID1cbiAgICAgIHwgTGVmdCBvZiAnYVxuICAgICAgfCBSaWdodCBvZiAnYlxuICAgICAgfCBCb3RoIG9mICdhICogJ2JcbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgIGluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgdmFsIG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgKCoqIGRlZmF1bHQgKikgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2EpIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5cbiAgKCoqIFtNXSBpcyBtZWFudCB0byBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggT0NhbWwgYXBwbGljYXRpdmUgZnVuY3RvciB0eXBlczpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfc2V0ID0gU2V0Lk0oU3RyaW5nKS50XG4gICAgICBdfVxuXG4gICAgICB3aGljaCBzdGFuZHMgZm9yOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ19zZXQgPSAoU3RyaW5nLnQsIFN0cmluZy5jb21wYXJhdG9yX3dpdG5lc3MpIFNldC50XG4gICAgICBdfVxuXG4gICAgICBUaGUgcG9pbnQgaXMgdGhhdCBbU2V0Lk0oU3RyaW5nKS50XSBzdXBwb3J0cyBkZXJpdmluZywgd2hlcmVhcyB0aGUgc2Vjb25kIHN5bnRheFxuICAgICAgZG9lc24ndCAoYmVjYXVzZSB0aGVyZSBpcyBubyBzdWNoIHRoaW5nIGFzLCBzYXksIFN0cmluZy5zZXhwX29mX2NvbXBhcmF0b3Jfd2l0bmVzcyxcbiAgICAgIGluc3RlYWQgeW91IHdvdWxkIHdhbnQgdG8gcGFzcyB0aGUgY29tcGFyYXRvciBkaXJlY3RseSkuICopXG4gIG1vZHVsZSBNIChFbHQgOiBzaWdcbiAgICB0eXBlIHRcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICBlbmQpIDogc2lnXG4gICAgdHlwZSBub25yZWMgdCA9IChFbHQudCwgRWx0LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICBlbmRcblxuICBpbmNsdWRlIEZvcl9kZXJpdmluZyB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgKCoqIFVzaW5nIGNvbXBhcmF0b3IgaXMgYSBzaW1pbGFyIGludGVyZmFjZSBhcyB0aGUgdG9wbGV2ZWwgb2YgW1NldF0sIGV4Y2VwdCB0aGUgZnVuY3Rpb25zXG4gICAgICB0YWtlIGEgW35jb21wYXJhdG9yOignZWx0LCAnY21wKSBDb21wYXJhdG9yLnRdIHdoZXJlIHRoZSBmdW5jdGlvbnMgYXQgdGhlIHRvcGxldmVsIG9mXG4gICAgICBbU2V0XSB0YWtlcyBhIFsoJ2VsdCwgJ2NtcCkgY29tcGFyYXRvcl0uICopXG4gIG1vZHVsZSBVc2luZ19jb21wYXJhdG9yIDogc2lnXG4gICAgdHlwZSBub25yZWMgKCdlbHQsICdjbXApIHQgPSAoJ2VsdCwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3RcbiAgICAgIDogICgnZWx0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnY21wIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnZWx0LCAnY21wKSB0XG4gICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgdF9vZl9zZXhwX2RpcmVjdFxuICAgICAgOiAgY29tcGFyYXRvcjooJ2VsdCwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoU2V4cC50IC0+ICdlbHQpXG4gICAgICAtPiBTZXhwLnRcbiAgICAgIC0+ICgnZWx0LCAnY21wKSB0XG5cbiAgICBtb2R1bGUgVHJlZSA6IHNpZ1xuICAgICAgKCoqIEEgW1RyZWUudF0gY29udGFpbnMganVzdCB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZSB0aGF0IGEgc2V0IGlzIGJhc2VkIG9uLCB3aXRob3V0XG4gICAgICAgICAgaW5jbHVkaW5nIHRoZSBjb21wYXJhdG9yLiAgQWNjb3JkaW5nbHksIGFueSBvcGVyYXRpb24gb24gYSBbVHJlZS50XSBtdXN0IGFsc28gdGFrZVxuICAgICAgICAgIGFzIGFuIGFyZ3VtZW50IHRoZSBjb3JyZXNwb25kaW5nIGNvbXBhcmF0b3IuICopXG4gICAgICB0eXBlICgnYSwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgdmFsIHNleHBfb2ZfdFxuICAgICAgICA6ICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgICAgW0BAQGVuZF1cblxuICAgICAgdmFsIHRfb2Zfc2V4cF9kaXJlY3RcbiAgICAgICAgOiAgY29tcGFyYXRvcjooJ2VsdCwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAgIC0+IChTZXhwLnQgLT4gJ2VsdClcbiAgICAgICAgLT4gU2V4cC50XG4gICAgICAgIC0+ICgnZWx0LCAnY21wKSB0XG5cbiAgICAgIGluY2x1ZGVcbiAgICAgICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljXG4gICAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHNldCA6PSAoJ2EsICdiKSB0XG4gICAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIHRcbiAgICAgICAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhXG4gICAgICAgICAgd2l0aCB0eXBlICdjIGNtcCA6PSAnY1xuICAgICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgY3JlYXRlX29wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIFdpdGhfY29tcGFyYXRvci50XG4gICAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aF9jb21wYXJhdG9yLnRcblxuICAgICAgdmFsIGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gOiAoXywgXykgdFxuICAgIGVuZFxuXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljXG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgVHJlZS50XG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSBzZXQgOj0gKCdhLCAnYikgdFxuICAgICAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhXG4gICAgICAgIHdpdGggdHlwZSAnYyBjbXAgOj0gJ2NcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBhY2Nlc3Nfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aG91dF9jb21wYXJhdG9yLnRcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBjcmVhdGVfb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgV2l0aF9jb21wYXJhdG9yLnRcblxuICAgIHZhbCBjb21wYXJhdG9yX3MgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICB2YWwgaGFzaF9mb2xkX2RpcmVjdCA6ICdlbHQgSGFzaC5mb2xkZXIgLT4gKCdlbHQsICdjbXApIHQgSGFzaC5mb2xkZXJcblxuICAgIG1vZHVsZSBFbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChFbHQgOiBDb21wYXJhdG9yLlMxKSA6IHNpZ1xuICAgICAgdmFsIGVtcHR5IDogKCdhIEVsdC50LCBFbHQuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gICAgZW5kXG4gIGVuZFxuXG4gIHZhbCB0b190cmVlIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgVXNpbmdfY29tcGFyYXRvci5UcmVlLnRcblxuICB2YWwgb2ZfdHJlZVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSwgJ2NtcCkgVXNpbmdfY29tcGFyYXRvci5UcmVlLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogQSBwb2x5bW9ycGhpYyBTZXQuICopXG4gIG1vZHVsZSBQb2x5IDpcbiAgICBTX3BvbHlcbiAgICAgIHdpdGggdHlwZSAnZWx0IHQgPSAoJ2VsdCwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgICAgd2l0aCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA6PSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG4gICAgICB3aXRoIHR5cGUgJ2VsdCB0cmVlIDo9XG4gICAgICAgICgnZWx0LCBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzKSBVc2luZ19jb21wYXJhdG9yLlRyZWUudFxuICAgICAgd2l0aCB0eXBlICgnZWx0LCAnY21wKSBzZXQgOj0gKCdlbHQsICdjbXApIHRcblxuICAoKiogezIgTW9kdWxlcyBhbmQgbW9kdWxlIHR5cGVzIGZvciBleHRlbmRpbmcgW1NldF19XG5cbiAgICAgIEZvciB1c2UgaW4gZXh0ZW5zaW9ucyBvZiBCYXNlLCBsaWtlIFtDb3JlXS4gKilcblxuICBtb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gV2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlXG4gIG1vZHVsZSBXaXRob3V0X2NvbXBhcmF0b3IgPSBXaXRob3V0X2NvbXBhcmF0b3JcblxuICBtb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBGb3JfZGVyaXZpbmdcbiAgbW9kdWxlIHR5cGUgU19wb2x5ID0gU19wb2x5XG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yc19nZW5lcmljID0gQWNjZXNzb3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIEVsdF9wbGFpbiA9IEVsdF9wbGFpblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICopXG4oKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICopXG4oKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UuIFNlZSAuLi9USElSRC1QQVJUWS50eHQgICopXG4oKiAgZm9yIGRldGFpbHMuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFNldHMgb3ZlciBvcmRlcmVkIHR5cGVzICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTZXRfaW50ZlxuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG5tb2R1bGUgVHJlZTAgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IEVtcHR5XG4gICAgKCogTGVhZiBpcyB0aGUgc2FtZSBhcyBOb2RlIHdpdGggZW1wdHkgY2hpbGRyZW4gYnV0IHVzZXMgbGVzcyBzcGFjZS4gKilcbiAgICB8IExlYWYgb2YgeyBlbHQgOiAnYSB9XG4gICAgfCBOb2RlIG9mXG4gICAgICAgIHsgbGVmdCA6ICdhIHRcbiAgICAgICAgOyBlbHQgOiAnYVxuICAgICAgICA7IHJpZ2h0IDogJ2EgdFxuICAgICAgICA7IGhlaWdodCA6IGludFxuICAgICAgICA7IHNpemUgOiBpbnRcbiAgICAgICAgfVxuXG4gIHR5cGUgJ2EgdHJlZSA9ICdhIHRcblxuICAoKiBTZXRzIGFyZSByZXByZXNlbnRlZCBieSBiYWxhbmNlZCBiaW5hcnkgdHJlZXMgKHRoZSBoZWlnaHRzIG9mIHRoZSBjaGlsZHJlbiBkaWZmZXIgYnlcbiAgICAgYXQgbW9zdCAyLiAqKVxuICBsZXRbQGlubGluZSBhbHdheXNdIGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIHsgZWx0ID0gXyB9IC0+IDFcbiAgICB8IE5vZGUgeyBsZWZ0ID0gXzsgZWx0ID0gXzsgcmlnaHQgPSBfOyBoZWlnaHQgPSBoOyBzaXplID0gXyB9IC0+IGhcbiAgOztcblxuICBsZXRbQGlubGluZSBhbHdheXNdIGxlbmd0aCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIHsgZWx0ID0gXyB9IC0+IDFcbiAgICB8IE5vZGUgeyBsZWZ0ID0gXzsgZWx0ID0gXzsgcmlnaHQgPSBfOyBoZWlnaHQgPSBfOyBzaXplID0gcyB9IC0+IHNcbiAgOztcblxuICBsZXQgaW52YXJpYW50cyA9XG4gICAgbGV0IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHYgPVxuICAgICAgKG1hdGNoIGxvd2VyIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgIHwgU29tZSBsb3dlciAtPiBjb21wYXJlX2VsdCBsb3dlciB2IDwgMClcbiAgICAgICYmXG4gICAgICBtYXRjaCB1cHBlciB3aXRoXG4gICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgfCBTb21lIHVwcGVyIC0+IGNvbXBhcmVfZWx0IHYgdXBwZXIgPCAwXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb3AgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHZcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IGg7IHNpemUgPSBuIH0gLT5cbiAgICAgICAgbGV0IGhsID0gaGVpZ2h0IGxcbiAgICAgICAgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICAgICAgYWJzIChobCAtIGhyKSA8PSAyXG4gICAgICAgICYmIGggPSBtYXggaGwgaHIgKyAxXG4gICAgICAgICYmIG4gPSBsZW5ndGggbCArIGxlbmd0aCByICsgMVxuICAgICAgICAmJiBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2VsdCB2XG4gICAgICAgICYmIGxvb3AgbG93ZXIgKFNvbWUgdikgY29tcGFyZV9lbHQgbFxuICAgICAgICAmJiBsb29wIChTb21lIHYpIHVwcGVyIGNvbXBhcmVfZWx0IHJcbiAgICBpblxuICAgIGZ1biB0IH5jb21wYXJlX2VsdCAtPiBsb29wIE5vbmUgTm9uZSBjb21wYXJlX2VsdCB0XG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IHRydWVcbiAgICB8IExlYWYgeyBlbHQgPSBfIH0gfCBOb2RlIF8gLT4gZmFsc2VcbiAgOztcblxuICAoKiBDcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCBsZWZ0IHNvbiBsLCB2YWx1ZSB2IGFuZCByaWdodCBzb24gci5cbiAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICBsIGFuZCByIG11c3QgYmUgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuICopXG5cbiAgbGV0W0BpbmxpbmUgYWx3YXlzXSBjcmVhdGUgbCB2IHIgPVxuICAgIGxldCBobCA9IChoZWlnaHQgW0BpbmxpbmVkXSkgbCBpblxuICAgIGxldCBociA9IChoZWlnaHQgW0BpbmxpbmVkXSkgciBpblxuICAgIGxldCBoID0gaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEgaW5cbiAgICBpZiBoID0gMVxuICAgIHRoZW4gTGVhZiB7IGVsdCA9IHYgfVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHNsID0gKGxlbmd0aCBbQGlubGluZWRdKSBsIGluXG4gICAgICBsZXQgc3IgPSAobGVuZ3RoIFtAaW5saW5lZF0pIHIgaW5cbiAgICAgIE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBoOyBzaXplID0gc2wgKyBzciArIDEgfSlcbiAgOztcblxuICAoKiBXZSBtdXN0IGNhbGwgW2ZdIHdpdGggaW5jcmVhc2luZyBpbmRleGVzLCBiZWNhdXNlIHRoZSBiaW5fcHJvdCByZWFkZXIgaW5cbiAgICAgQ29yZS5TZXQgbmVlZHMgaXQuICopXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mID1cbiAgICBsZXQgcmVjIGxvb3AgbiB+ZiBpID1cbiAgICAgIG1hdGNoIG4gd2l0aFxuICAgICAgfCAwIC0+IEVtcHR5XG4gICAgICB8IDEgLT5cbiAgICAgICAgbGV0IGsgPSBmIGkgaW5cbiAgICAgICAgTGVhZiB7IGVsdCA9IGsgfVxuICAgICAgfCAyIC0+XG4gICAgICAgIGxldCBrbCA9IGYgaSBpblxuICAgICAgICBsZXQgayA9IGYgKGkgKyAxKSBpblxuICAgICAgICBjcmVhdGUgKExlYWYgeyBlbHQgPSBrbCB9KSBrIEVtcHR5XG4gICAgICB8IDMgLT5cbiAgICAgICAgbGV0IGtsID0gZiBpIGluXG4gICAgICAgIGxldCBrID0gZiAoaSArIDEpIGluXG4gICAgICAgIGxldCBrciA9IGYgKGkgKyAyKSBpblxuICAgICAgICBjcmVhdGUgKExlYWYgeyBlbHQgPSBrbCB9KSBrIChMZWFmIHsgZWx0ID0ga3IgfSlcbiAgICAgIHwgbiAtPlxuICAgICAgICBsZXQgbGVmdF9sZW5ndGggPSBuIGxzciAxIGluXG4gICAgICAgIGxldCByaWdodF9sZW5ndGggPSBuIC0gbGVmdF9sZW5ndGggLSAxIGluXG4gICAgICAgIGxldCBsZWZ0ID0gbG9vcCBsZWZ0X2xlbmd0aCB+ZiBpIGluXG4gICAgICAgIGxldCBrID0gZiAoaSArIGxlZnRfbGVuZ3RoKSBpblxuICAgICAgICBsZXQgcmlnaHQgPSBsb29wIHJpZ2h0X2xlbmd0aCB+ZiAoaSArIGxlZnRfbGVuZ3RoICsgMSkgaW5cbiAgICAgICAgY3JlYXRlIGxlZnQgayByaWdodFxuICAgIGluXG4gICAgbG9vcCBsZW4gfmYgMFxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IGFycmF5X2xlbmd0aCA9IEFycmF5Lmxlbmd0aCBhcnJheSBpblxuICAgIGxldCBuZXh0ID1cbiAgICAgICgqIFdlIGRvbid0IGNoZWNrIGlmIHRoZSBhcnJheSBpcyBzb3J0ZWQgb3Iga2V5cyBhcmUgZHVwbGljYXRlZCwgYmVjYXVzZSB0aGF0XG4gICAgICAgICBjaGVja2luZyBpcyBzbG93ZXIgdGhhbiB0aGUgd2hvbGUgW29mX3NvcnRlZF9hcnJheV0gZnVuY3Rpb24gKilcbiAgICAgIGlmIGFycmF5X2xlbmd0aCA8IDIgfHwgY29tcGFyZV9lbHQgYXJyYXkuKDApIGFycmF5LigxKSA8IDBcbiAgICAgIHRoZW4gZnVuIGkgLT4gYXJyYXkuKGkpXG4gICAgICBlbHNlIGZ1biBpIC0+IGFycmF5LihhcnJheV9sZW5ndGggLSAxIC0gaSlcbiAgICBpblxuICAgIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW46YXJyYXlfbGVuZ3RoIH5mOm5leHRcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggYXJyYXkgd2l0aFxuICAgIHwgW3x8XSB8IFt8IF8gfF0gLT4gUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdClcbiAgICB8IF8gLT5cbiAgICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgICBsZXQgaW5jcmVhc2luZyA9XG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9lbHQgYXJyYXkuKDApIGFycmF5LigxKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT4gaSA8IDBcbiAgICAgICAgaW5cbiAgICAgICAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnJheSAtIDIgZG9cbiAgICAgICAgICBtYXRjaCBjb21wYXJlX2VsdCBhcnJheS4oaSkgYXJyYXkuKGkgKyAxKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT5cbiAgICAgICAgICAgIGlmIFBvbHkuKCA8PiApIChpIDwgMCkgaW5jcmVhc2luZ1xuICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBlbGVtZW50cyBhcmUgbm90IG9yZGVyZWRcIilcbiAgICAgICAgZG9uZTtcbiAgICAgICAgUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdCkpXG4gIDs7XG5cbiAgKCogU2FtZSBhcyBjcmVhdGUsIGJ1dCBwZXJmb3JtcyBvbmUgc3RlcCBvZiByZWJhbGFuY2luZyBpZiBuZWNlc3NhcnkuXG4gICAgIEFzc3VtZXMgbCBhbmQgciBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMy4gKilcblxuICBsZXQgYmFsIGwgdiByID1cbiAgICBsZXQgaGwgPSAoaGVpZ2h0IFtAaW5saW5lZF0pIGwgaW5cbiAgICBsZXQgaHIgPSAoaGVpZ2h0IFtAaW5saW5lZF0pIHIgaW5cbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBMZWFmIHsgZWx0ID0gXyB9IC0+IGFzc2VydCBmYWxzZSAoKiBiZWNhdXNlIGgobCk+aChyKSsyIGFuZCBoKGxlYWYpPTEgKilcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsbDsgZWx0ID0gbHY7IHJpZ2h0ID0gbHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsclxuICAgICAgICB0aGVuIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBMZWFmIHsgZWx0ID0gbHJ2IH0gLT5cbiAgICAgICAgICAgIGFzc2VydCAoaXNfZW1wdHkgbGwpO1xuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgRW1wdHkpIGxydiAoY3JlYXRlIEVtcHR5IHYgcilcbiAgICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbHJsOyBlbHQgPSBscnY7IHJpZ2h0ID0gbHJyOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpKSlcbiAgICBlbHNlIGlmIGhyID4gaGwgKyAyXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCByIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IExlYWYgeyBlbHQgPSBfIH0gLT4gYXNzZXJ0IGZhbHNlICgqIGJlY2F1c2UgaChyKT5oKGwpKzIgYW5kIGgobGVhZik9MSAqKVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IHJsOyBlbHQgPSBydjsgcmlnaHQgPSBycjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsXG4gICAgICAgIHRoZW4gY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IExlYWYgeyBlbHQgPSBybHYgfSAtPlxuICAgICAgICAgICAgYXNzZXJ0IChpc19lbXB0eSBycik7XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgRW1wdHkpIHJsdiAoY3JlYXRlIEVtcHR5IHJ2IHJyKVxuICAgICAgICAgIHwgTm9kZSB7IGxlZnQgPSBybGw7IGVsdCA9IHJsdjsgcmlnaHQgPSBybHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybGwpIHJsdiAoY3JlYXRlIHJsciBydiBycikpKVxuICAgIGVsc2UgKGNyZWF0ZSBbQGlubGluZWRdKSBsIHYgclxuICA7O1xuXG4gICgqIEluc2VydGlvbiBvZiBvbmUgZWxlbWVudCAqKVxuXG4gIGV4Y2VwdGlvbiBTYW1lXG5cbiAgbGV0IGFkZCB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IExlYWYgeyBlbHQgPSB4IH1cbiAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBTYW1lXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBjcmVhdGUgKExlYWYgeyBlbHQgPSB4IH0pIHYgRW1wdHlcbiAgICAgICAgZWxzZSBjcmVhdGUgRW1wdHkgdiAoTGVhZiB7IGVsdCA9IHggfSlcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgU2FtZVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gYmFsIChhdXggbCkgdiByXG4gICAgICAgIGVsc2UgYmFsIGwgdiAoYXV4IHIpXG4gICAgaW5cbiAgICB0cnkgYXV4IHQgd2l0aFxuICAgIHwgU2FtZSAtPiB0XG4gIDs7XG5cbiAgKCogc3BlY2lhbGl6YXRpb24gb2YgW2FkZF0gdGhhdCBhc3N1bWVzIHRoYXQgW3hdIGlzIGxlc3MgdGhhbiBhbGwgZXhpc3RpbmcgZWxlbWVudHMgKilcbiAgbGV0IHJlYyBhZGRfbWluIHggdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBMZWFmIHsgZWx0ID0geCB9XG4gICAgfCBMZWFmIHsgZWx0ID0gXyB9IC0+IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGVsdCA9IHg7IHJpZ2h0ID0gdDsgaGVpZ2h0ID0gMjsgc2l6ZSA9IDIgfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT4gYmFsIChhZGRfbWluIHggbCkgdiByXG4gIDs7XG5cbiAgKCogc3BlY2lhbGl6YXRpb24gb2YgW2FkZF0gdGhhdCBhc3N1bWVzIHRoYXQgW3hdIGlzIGdyZWF0ZXIgdGhhbiBhbGwgZXhpc3RpbmcgZWxlbWVudHMgKilcbiAgbGV0IHJlYyBhZGRfbWF4IHQgeCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBMZWFmIHsgZWx0ID0geCB9XG4gICAgfCBMZWFmIHsgZWx0ID0gXyB9IC0+IE5vZGUgeyBsZWZ0ID0gdDsgZWx0ID0geDsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gMjsgc2l6ZSA9IDIgfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT4gYmFsIGwgdiAoYWRkX21heCByIHgpXG4gIDs7XG5cbiAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZSByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kXG4gICAgIHIuICopXG4gIGxldCByZWMgam9pbiBsIHYgciA9XG4gICAgbWF0Y2ggbCwgciB3aXRoXG4gICAgfCBFbXB0eSwgXyAtPiBhZGRfbWluIHYgclxuICAgIHwgXywgRW1wdHkgLT4gYWRkX21heCBsIHZcbiAgICB8IExlYWYgeyBlbHQgPSBsdiB9LCBfIC0+IGFkZF9taW4gbHYgKGFkZF9taW4gdiByKVxuICAgIHwgXywgTGVhZiB7IGVsdCA9IHJ2IH0gLT4gYWRkX21heCAoYWRkX21heCBsIHYpIHJ2XG4gICAgfCAoIE5vZGUgeyBsZWZ0ID0gbGw7IGVsdCA9IGx2OyByaWdodCA9IGxyOyBoZWlnaHQgPSBsaDsgc2l6ZSA9IF8gfVxuICAgICAgLCBOb2RlIHsgbGVmdCA9IHJsOyBlbHQgPSBydjsgcmlnaHQgPSBycjsgaGVpZ2h0ID0gcmg7IHNpemUgPSBfIH0gKSAtPlxuICAgICAgaWYgbGggPiByaCArIDJcbiAgICAgIHRoZW4gYmFsIGxsIGx2IChqb2luIGxyIHYgcilcbiAgICAgIGVsc2UgaWYgcmggPiBsaCArIDJcbiAgICAgIHRoZW4gYmFsIChqb2luIGwgdiBybCkgcnYgcnJcbiAgICAgIGVsc2UgY3JlYXRlIGwgdiByXG4gIDs7XG5cbiAgKCogU21hbGxlc3QgYW5kIGdyZWF0ZXN0IGVsZW1lbnQgb2YgYSBzZXQgKilcbiAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBlbHQgPSB2OyByaWdodCA9IF87IGhlaWdodCA9IF87IHNpemUgPSBfIH1cbiAgICAgIC0+IFNvbWUgdlxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSBfOyByaWdodCA9IF87IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT4gbWluX2VsdCBsXG4gIDs7XG5cbiAgZXhjZXB0aW9uIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgIHwgU2V0X21pbl9lbHRfZXhuX29mX2VtcHR5X3NldCAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJzZXQubWwuVHJlZTAuU2V0X21pbl9lbHRfZXhuX29mX2VtcHR5X3NldFwiXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgZXhjZXB0aW9uIFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXRdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgIHwgU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldCAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJzZXQubWwuVHJlZTAuU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldFwiXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG1pbl9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1pbl9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXRcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgICBsZXQgcmVjIGZvbGRfdW50aWxfaGVscGVyIH5mIHQgYWNjID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC5Db250aW51ZSBhY2NcbiAgICAgIHwgTGVhZiB7IGVsdCA9IHZhbHVlIH0gLT4gZiBhY2MgdmFsdWUgW0Bub250YWlsXVxuICAgICAgfCBOb2RlIHsgbGVmdDsgZWx0ID0gdmFsdWU7IHJpZ2h0OyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgIChtYXRjaCBmb2xkX3VudGlsX2hlbHBlciB+ZiBsZWZ0IGFjYyB3aXRoXG4gICAgICAgICB8IFN0b3AgX2EgYXMgeCAtPiB4XG4gICAgICAgICB8IENvbnRpbnVlIGFjYyAtPlxuICAgICAgICAgICAobWF0Y2ggZiBhY2MgdmFsdWUgd2l0aFxuICAgICAgICAgICAgfCBTdG9wIF9hIGFzIHggLT4geFxuICAgICAgICAgICAgfCBDb250aW51ZSBhIC0+IGZvbGRfdW50aWxfaGVscGVyIH5mIHJpZ2h0IGEpKVxuICAgIGluXG4gICAgbWF0Y2ggZm9sZF91bnRpbF9oZWxwZXIgfmYgdCBpbml0IHdpdGhcbiAgICB8IENvbnRpbnVlIHggLT4gZmluaXNoIHggW0Bub250YWlsXVxuICAgIHwgU3RvcCB4IC0+IHhcbiAgOztcblxuICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSB8IE5vZGUgeyBsZWZ0ID0gXzsgZWx0ID0gdjsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfVxuICAgICAgLT4gU29tZSB2XG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGVsdCA9IF87IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPiBtYXhfZWx0IHJcbiAgOztcblxuICBsZXQgbWF4X2VsdF9leG4gdCA9XG4gICAgbWF0Y2ggbWF4X2VsdCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldFxuICAgIHwgU29tZSB2IC0+IHZcbiAgOztcblxuICAoKiBSZW1vdmUgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNldCAqKVxuXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgIHwgTGVhZiB7IGVsdCA9IF8gfSAtPiBFbXB0eVxuICAgIHwgTm9kZSB7IGxlZnQgPSBFbXB0eTsgZWx0ID0gXzsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+IHJcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuICA7O1xuXG4gICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLiAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICBBc3N1bWUgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi4gKilcbiAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRW1wdHksIHQgLT4gdFxuICAgIHwgdCwgRW1wdHkgLT4gdFxuICAgIHwgXywgXyAtPiBiYWwgdDEgKG1pbl9lbHRfZXhuIHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG4gIDs7XG5cbiAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcbiAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IHwgdCwgRW1wdHkgLT4gdFxuICAgIHwgXywgXyAtPiBqb2luIHQxIChtaW5fZWx0X2V4biB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuICA7O1xuXG4gIGxldCBzcGxpdCB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIHNwbGl0IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5LCBOb25lLCBFbXB0eVxuICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gRW1wdHksIFNvbWUgdiwgRW1wdHlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIEVtcHR5LCBOb25lLCBMZWFmIHsgZWx0ID0gdiB9XG4gICAgICAgIGVsc2UgTGVhZiB7IGVsdCA9IHYgfSwgTm9uZSwgRW1wdHlcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBsLCBTb21lIHYsIHJcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbGwsIG1heWJlX2VsdCwgcmwgPSBzcGxpdCBsIGluXG4gICAgICAgICAgbGwsIG1heWJlX2VsdCwgam9pbiBybCB2IHIpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBsciwgbWF5YmVfZWx0LCByciA9IHNwbGl0IHIgaW5cbiAgICAgICAgICBqb2luIGwgdiBsciwgbWF5YmVfZWx0LCBycilcbiAgICBpblxuICAgIHNwbGl0IHRcbiAgOztcblxuICBsZXQgcmVjIHNwbGl0X2xlX2d0IHQgeCB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHksIEVtcHR5XG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+XG4gICAgICBpZiBjb21wYXJlX2VsdCB4IHYgPj0gMCB0aGVuIExlYWYgeyBlbHQgPSB2IH0sIEVtcHR5IGVsc2UgRW1wdHksIExlYWYgeyBlbHQgPSB2IH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gYWRkX21heCBsIHYsIHJcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgbGwsIHJsID0gc3BsaXRfbGVfZ3QgbCB4IH5jb21wYXJlX2VsdCBpblxuICAgICAgICBsbCwgam9pbiBybCB2IHIpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxyLCByciA9IHNwbGl0X2xlX2d0IHIgeCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgICAgam9pbiBsIHYgbHIsIHJyKVxuICA7O1xuXG4gIGxldCByZWMgc3BsaXRfbHRfZ2UgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eSwgRW1wdHlcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT5cbiAgICAgIGlmIGNvbXBhcmVfZWx0IHggdiA+IDAgdGhlbiBMZWFmIHsgZWx0ID0gdiB9LCBFbXB0eSBlbHNlIEVtcHR5LCBMZWFmIHsgZWx0ID0gdiB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIGwsIGFkZF9taW4gdiByXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGxsLCBybCA9IHNwbGl0X2x0X2dlIGwgeCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgICAgbGwsIGpvaW4gcmwgdiByKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBsciwgcnIgPSBzcGxpdF9sdF9nZSByIHggfmNvbXBhcmVfZWx0IGluXG4gICAgICAgIGpvaW4gbCB2IGxyLCBycilcbiAgOztcblxuICAoKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgc2V0IG9wZXJhdGlvbnMgKilcblxuICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gIGxldCByZWMgbWVtIHQgeCB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gZmFsc2VcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICBjID0gMFxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICBjID0gMCB8fCBtZW0gKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpIHggfmNvbXBhcmVfZWx0XG4gIDs7XG5cbiAgbGV0IHNpbmdsZXRvbiB4ID0gTGVhZiB7IGVsdCA9IHggfVxuXG4gIGxldCByZW1vdmUgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBhdXggdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIFNhbWVcbiAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPlxuICAgICAgICBpZiBjb21wYXJlX2VsdCB4IHYgPSAwIHRoZW4gRW1wdHkgZWxzZSBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgU2FtZVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgciBlbHNlIGlmIGMgPCAwIHRoZW4gYmFsIChhdXggbCkgdiByIGVsc2UgYmFsIGwgdiAoYXV4IHIpXG4gICAgaW5cbiAgICB0cnkgYXV4IHQgd2l0aFxuICAgIHwgU2FtZSAtPiB0XG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9pbmRleCB0IGkgfmNvbXBhcmVfZWx0Ol8gPVxuICAgIGxldCByZWMgYXV4IHQgaSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIFNhbWVcbiAgICAgIHwgTGVhZiB7IGVsdCA9IF8gfSAtPiBpZiBpID0gMCB0aGVuIEVtcHR5IGVsc2UgRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIFNhbWVcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgICAgbGV0IGxfc2l6ZSA9IGxlbmd0aCBsIGluXG4gICAgICAgIGxldCBjID0gUG9seS5jb21wYXJlIGkgbF9zaXplIGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBiYWwgKGF1eCBsIGkpIHYgclxuICAgICAgICBlbHNlIGJhbCBsIHYgKGF1eCByIChpIC0gbF9zaXplIC0gMSkpXG4gICAgaW5cbiAgICB0cnkgYXV4IHQgaSB3aXRoXG4gICAgfCBTYW1lIC0+IHRcbiAgOztcblxuICBsZXQgdW5pb24gczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIHVuaW9uIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gczFcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCB0IHwgdCwgRW1wdHkgLT4gdFxuICAgICAgICB8IExlYWYgeyBlbHQgPSB2MSB9LCBfIC0+XG4gICAgICAgICAgdW5pb24gKE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGVsdCA9IHYxOyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSAxOyBzaXplID0gMSB9KSBzMlxuICAgICAgICB8IF8sIExlYWYgeyBlbHQgPSB2MiB9IC0+XG4gICAgICAgICAgdW5pb24gczEgKE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGVsdCA9IHYyOyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSAxOyBzaXplID0gMSB9KVxuICAgICAgICB8ICggTm9kZSB7IGxlZnQgPSBsMTsgZWx0ID0gdjE7IHJpZ2h0ID0gcjE7IGhlaWdodCA9IGgxOyBzaXplID0gXyB9XG4gICAgICAgICAgLCBOb2RlIHsgbGVmdCA9IGwyOyBlbHQgPSB2MjsgcmlnaHQgPSByMjsgaGVpZ2h0ID0gaDI7IHNpemUgPSBfIH0gKSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgaWYgaDIgPSAxXG4gICAgICAgICAgICB0aGVuIGFkZCBzMSB2MiB+Y29tcGFyZV9lbHRcbiAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICBsZXQgbDIsIF8sIHIyID0gc3BsaXQgczIgdjEgfmNvbXBhcmVfZWx0IGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpKVxuICAgICAgICAgIGVsc2UgaWYgaDEgPSAxXG4gICAgICAgICAgdGhlbiBhZGQgczIgdjEgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgbDEsIF8sIHIxID0gc3BsaXQgczEgdjIgfmNvbXBhcmVfZWx0IGluXG4gICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKSkpXG4gICAgaW5cbiAgICB1bmlvbiBzMSBzMlxuICA7O1xuXG4gIGxldCB1bmlvbl9saXN0IH5jb21wYXJhdG9yIH50b190cmVlIHhzID1cbiAgICBsZXQgY29tcGFyZV9lbHQgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgIExpc3QuZm9sZCB4cyB+aW5pdDplbXB0eSB+ZjooZnVuIGFjIHggLT4gdW5pb24gYWMgKHRvX3RyZWUgeCkgfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gIGxldCBpbnRlciBzMSBzMiB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgaW50ZXIgczEgczIgPVxuICAgICAgaWYgcGh5c19lcXVhbCBzMSBzMlxuICAgICAgdGhlbiBzMVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICAgIHwgRW1wdHksIF8gfCBfLCBFbXB0eSAtPiBFbXB0eVxuICAgICAgICB8IChMZWFmIHsgZWx0IH0gYXMgc2luZ2xldG9uKSwgb3RoZXJfc2V0IHwgb3RoZXJfc2V0LCAoTGVhZiB7IGVsdCB9IGFzIHNpbmdsZXRvbilcbiAgICAgICAgICAtPiBpZiBtZW0gb3RoZXJfc2V0IGVsdCB+Y29tcGFyZV9lbHQgdGhlbiBzaW5nbGV0b24gZWxzZSBFbXB0eVxuICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbDE7IGVsdCA9IHYxOyByaWdodCA9IHIxOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9LCB0MiAtPlxuICAgICAgICAgIChtYXRjaCBzcGxpdCB0MiB2MSB+Y29tcGFyZV9lbHQgd2l0aFxuICAgICAgICAgICB8IGwyLCBOb25lLCByMiAtPiBjb25jYXQgKGludGVyIGwxIGwyKSAoaW50ZXIgcjEgcjIpXG4gICAgICAgICAgIHwgbDIsIFNvbWUgdjEsIHIyIC0+IGpvaW4gKGludGVyIGwxIGwyKSB2MSAoaW50ZXIgcjEgcjIpKSlcbiAgICBpblxuICAgIGludGVyIHMxIHMyXG4gIDs7XG5cbiAgbGV0IGRpZmYgczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGRpZmYgczEgczIgPVxuICAgICAgaWYgcGh5c19lcXVhbCBzMSBzMlxuICAgICAgdGhlbiBFbXB0eVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICAgIHwgRW1wdHksIF8gLT4gRW1wdHlcbiAgICAgICAgfCB0MSwgRW1wdHkgLT4gdDFcbiAgICAgICAgfCBMZWFmIHsgZWx0ID0gdjEgfSwgdDIgLT5cbiAgICAgICAgICBkaWZmIChOb2RlIHsgbGVmdCA9IEVtcHR5OyBlbHQgPSB2MTsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gMTsgc2l6ZSA9IDEgfSkgdDJcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGwxOyBlbHQgPSB2MTsgcmlnaHQgPSByMTsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSwgdDIgLT5cbiAgICAgICAgICAobWF0Y2ggc3BsaXQgdDIgdjEgfmNvbXBhcmVfZWx0IHdpdGhcbiAgICAgICAgICAgfCBsMiwgTm9uZSwgcjIgLT4gam9pbiAoZGlmZiBsMSBsMikgdjEgKGRpZmYgcjEgcjIpXG4gICAgICAgICAgIHwgbDIsIFNvbWUgXywgcjIgLT4gY29uY2F0IChkaWZmIGwxIGwyKSAoZGlmZiByMSByMikpKVxuICAgIGluXG4gICAgZGlmZiBzMSBzMlxuICA7O1xuXG4gIG1vZHVsZSBFbnVtID0gc3RydWN0XG4gICAgdHlwZSBpbmNyZWFzaW5nXG4gICAgdHlwZSBkZWNyZWFzaW5nXG5cbiAgICB0eXBlICgnYSwgJ2RpcmVjdGlvbikgdCA9XG4gICAgICB8IEVuZFxuICAgICAgfCBNb3JlIG9mICdhICogJ2EgdHJlZSAqICgnYSwgJ2RpcmVjdGlvbikgdFxuXG4gICAgbGV0IHJlYyBjb25zIHMgKGUgOiAoXywgaW5jcmVhc2luZykgdCkgOiAoXywgaW5jcmVhc2luZykgdCA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IE1vcmUgKHYsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICBjb25zIGwgKE1vcmUgKHYsIHIsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGNvbnNfcmlnaHQgcyAoZSA6IChfLCBkZWNyZWFzaW5nKSB0KSA6IChfLCBkZWNyZWFzaW5nKSB0ID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT4gTW9yZSAodiwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgIGNvbnNfcmlnaHQgciAoTW9yZSAodiwgbCwgZSkpXG4gICAgOztcblxuICAgIGxldCBvZl9zZXQgcyA6IChfLCBpbmNyZWFzaW5nKSB0ID0gY29ucyBzIEVuZFxuICAgIGxldCBvZl9zZXRfcmlnaHQgcyA6IChfLCBkZWNyZWFzaW5nKSB0ID0gY29uc19yaWdodCBzIEVuZFxuXG4gICAgbGV0IHN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyZSA6IChfLCBpbmNyZWFzaW5nKSB0ID1cbiAgICAgIGxldCByZWMgbG9vcCB0IGUgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPlxuICAgICAgICAgIGxvb3AgKE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGVsdCA9IHY7IHJpZ2h0ID0gRW1wdHk7IGhlaWdodCA9IDE7IHNpemUgPSAxIH0pIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IF87IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfVxuICAgICAgICAgIHdoZW4gY29tcGFyZSB2IGtleSA8IDAgLT4gbG9vcCByIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICAgIGxvb3AgbCAoTW9yZSAodiwgciwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+XG4gICAgICAgICAgbG9vcCAoTm9kZSB7IGxlZnQgPSBFbXB0eTsgZWx0ID0gdjsgcmlnaHQgPSBFbXB0eTsgaGVpZ2h0ID0gMTsgc2l6ZSA9IDEgfSkgZVxuICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSBfOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9XG4gICAgICAgICAgd2hlbiBjb21wYXJlIHYga2V5ID4gMCAtPiBsb29wIGwgZVxuICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgICAgbG9vcCByIChNb3JlICh2LCBsLCBlKSlcbiAgICAgIGluXG4gICAgICBsb29wIHQgRW5kXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIGNvbXBhcmVfZWx0IGUxIGUyID1cbiAgICAgIGxldCByZWMgbG9vcCBlMSBlMiA9XG4gICAgICAgIG1hdGNoIGUxLCBlMiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gMFxuICAgICAgICB8IEVuZCwgXyAtPiAtMVxuICAgICAgICB8IF8sIEVuZCAtPiAxXG4gICAgICAgIHwgTW9yZSAodjEsIHIxLCBlMSksIE1vcmUgKHYyLCByMiwgZTIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgaWYgcGh5c19lcXVhbCByMSByMlxuICAgICAgICAgIHRoZW4gbG9vcCBlMSBlMlxuICAgICAgICAgIGVsc2UgbG9vcCAoY29ucyByMSBlMSkgKGNvbnMgcjIgZTIpXG4gICAgICBpblxuICAgICAgbG9vcCBlMSBlMlxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGl0ZXIgfmYgPSBmdW5jdGlvblxuICAgICAgfCBFbmQgLT4gKClcbiAgICAgIHwgTW9yZSAoYSwgdHJlZSwgZW51bSkgLT5cbiAgICAgICAgZiBhO1xuICAgICAgICBpdGVyIChjb25zIHRyZWUgZW51bSkgfmZcbiAgICA7O1xuXG4gICAgbGV0IGl0ZXIyIGNvbXBhcmVfZWx0IHQxIHQyIH5mID1cbiAgICAgIGxldCByZWMgbG9vcCB0MSB0MiA9XG4gICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gKClcbiAgICAgICAgfCBFbmQsIF8gLT4gaXRlciB0MiB+ZjooZnVuIGEgLT4gZiAoYFJpZ2h0IGEpKSBbQG5vbnRhaWxdXG4gICAgICAgIHwgXywgRW5kIC0+IGl0ZXIgdDEgfmY6KGZ1biBhIC0+IGYgKGBMZWZ0IGEpKSBbQG5vbnRhaWxdXG4gICAgICAgIHwgTW9yZSAoYTEsIHRyZWUxLCBlbnVtMSksIE1vcmUgKGEyLCB0cmVlMiwgZW51bTIpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9lbHQgYTEgYTIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGYgKGBCb3RoIChhMSwgYTIpKTtcbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIChjb25zIHRyZWUyIGVudW0yKSlcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgZiAoYExlZnQgYTEpO1xuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgdDIpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBmIChgUmlnaHQgYTIpO1xuICAgICAgICAgICAgbG9vcCB0MSAoY29ucyB0cmVlMiBlbnVtMikpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MiBbQG5vbnRhaWxdXG4gICAgOztcblxuICAgIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9lbHQgPVxuICAgICAgbGV0IHN0ZXAgc3RhdGUgOiAoKF8sIF8pIEVpdGhlci50LCBfKSBTZXF1ZW5jZS5TdGVwLnQgPVxuICAgICAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gRG9uZVxuICAgICAgICB8IEVuZCwgTW9yZSAoZWx0LCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSBTZWNvbmQgZWx0OyBzdGF0ZSA9IEVuZCwgY29ucyB0cmVlIGVudW0gfVxuICAgICAgICB8IE1vcmUgKGVsdCwgdHJlZSwgZW51bSksIEVuZCAtPlxuICAgICAgICAgIFlpZWxkIHsgdmFsdWUgPSBGaXJzdCBlbHQ7IHN0YXRlID0gY29ucyB0cmVlIGVudW0sIEVuZCB9XG4gICAgICAgIHwgKE1vcmUgKGExLCB0cmVlMSwgZW51bTEpIGFzIGxlZnQpLCAoTW9yZSAoYTIsIHRyZWUyLCBlbnVtMikgYXMgcmlnaHQpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9lbHQgYTEgYTIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0X3N0YXRlID1cbiAgICAgICAgICAgICAgaWYgcGh5c19lcXVhbCB0cmVlMSB0cmVlMlxuICAgICAgICAgICAgICB0aGVuIGVudW0xLCBlbnVtMlxuICAgICAgICAgICAgICBlbHNlIGNvbnMgdHJlZTEgZW51bTEsIGNvbnMgdHJlZTIgZW51bTJcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBTa2lwIHsgc3RhdGUgPSBuZXh0X3N0YXRlIH0pXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIFlpZWxkIHsgdmFsdWUgPSBGaXJzdCBhMTsgc3RhdGUgPSBjb25zIHRyZWUxIGVudW0xLCByaWdodCB9XG4gICAgICAgICAgZWxzZSBZaWVsZCB7IHZhbHVlID0gU2Vjb25kIGEyOyBzdGF0ZSA9IGxlZnQsIGNvbnMgdHJlZTIgZW51bTIgfVxuICAgICAgaW5cbiAgICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OihvZl9zZXQgdDEsIG9mX3NldCB0MikgfmY6c3RlcFxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHQsIGUpIC0+IFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IGs7IHN0YXRlID0gRW51bS5jb25zIHQgZSB9XG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2VsdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl9zZXQgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdCB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB0LCBlKSAtPlxuICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSBrOyBzdGF0ZSA9IEVudW0uY29uc19yaWdodCB0IGUgfVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9lbHQgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2Zfc2V0X3JpZ2h0IHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9kZWNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlXG4gICAgY29tcGFyYXRvclxuICAgID8ob3JkZXIgPSBgSW5jcmVhc2luZylcbiAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgID9sZXNzX29yX2VxdWFsX3RvXG4gICAgdFxuICAgID1cbiAgICBsZXQgaW5jbHVzaXZlX2JvdW5kIHNpZGUgdCBib3VuZCA9XG4gICAgICBsZXQgY29tcGFyZV9lbHQgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgICAgbGV0IGwsIG1heWJlLCByID0gc3BsaXQgdCBib3VuZCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgIGxldCB0ID0gc2lkZSAobCwgcikgaW5cbiAgICAgIG1hdGNoIG1heWJlIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB0XG4gICAgICB8IFNvbWUgZWx0IC0+IGFkZCB0IGVsdCB+Y29tcGFyZV9lbHRcbiAgICBpblxuICAgIG1hdGNoIG9yZGVyIHdpdGhcbiAgICB8IGBJbmNyZWFzaW5nIC0+XG4gICAgICBsZXQgdCA9IE9wdGlvbi5mb2xkIGxlc3Nfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIGZzdCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2luY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9lbHQ6Z3JlYXRlcl9vcl9lcXVhbF90byB0XG4gICAgfCBgRGVjcmVhc2luZyAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBncmVhdGVyX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBzbmQpIGluXG4gICAgICB0b19zZXF1ZW5jZV9kZWNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0Omxlc3Nfb3JfZXF1YWxfdG8gdFxuICA7O1xuXG4gIGxldCByZWMgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBpZiBmIHYgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgaWYgZiB2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIGwgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSB2XG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHIgfmZcbiAgOztcblxuICBsZXQgcmVjIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBpZiBmIHYgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgaWYgZiB2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9sYXN0X3NhdGlzZnlpbmcgciB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBTb21lIHZcbiAgICAgICAgfCBTb21lIF8gYXMgeCAtPiB4KVxuICAgICAgZWxzZSBmaW5kX2xhc3Rfc2F0aXNmeWluZyBsIH5mXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9XG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAtPlxuICAgICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPCAwKSBbQG5vbnRhaWxdXG4gICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApIFtAbm9udGFpbF1cbiAgICB8IGBGaXJzdF9lcXVhbF90byAtPlxuICAgICAgKG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA+PSAwKSB3aXRoXG4gICAgICAgfCBTb21lIHggYXMgZWx0IHdoZW4gY29tcGFyZSB4IHYgPSAwIC0+IGVsdFxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICAgIHwgYExhc3RfZXF1YWxfdG8gLT5cbiAgICAgIChtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKSB3aXRoXG4gICAgICAgfCBTb21lIHggYXMgZWx0IHdoZW4gY29tcGFyZSB4IHYgPSAwIC0+IGVsdFxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID49IDApIFtAbm9udGFpbF1cbiAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA+IDApIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIGxldCBpc19sZWZ0IHggPVxuICAgICAgbWF0Y2ggc2VnbWVudF9vZiB4IHdpdGhcbiAgICAgIHwgYExlZnQgLT4gdHJ1ZVxuICAgICAgfCBgUmlnaHQgLT4gZmFsc2VcbiAgICBpblxuICAgIGxldCBpc19yaWdodCB4ID0gbm90IChpc19sZWZ0IHgpIGluXG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IGBMYXN0X29uX2xlZnQgLT4gZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+Zjppc19sZWZ0IFtAbm9udGFpbF1cbiAgICB8IGBGaXJzdF9vbl9yaWdodCAtPiBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Zjppc19yaWdodCBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgY29tcGFyYXRvclxuICAgID8ob3JkZXIgPSBgSW5jcmVhc2luZylcbiAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgID9sZXNzX29yX2VxdWFsX3RvXG4gICAgdFxuICAgIHQnXG4gICAgPVxuICAgIFNlcXVlbmNlLm1lcmdlX3dpdGhfZHVwbGljYXRlc1xuICAgICAgKHRvX3NlcXVlbmNlIGNvbXBhcmF0b3Igfm9yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQpXG4gICAgICAodG9fc2VxdWVuY2UgY29tcGFyYXRvciB+b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCcpXG4gICAgICB+Y29tcGFyZTpcbiAgICAgICAgKG1hdGNoIG9yZGVyIHdpdGhcbiAgICAgICAgIHwgYEluY3JlYXNpbmcgLT4gY29tcGFyYXRvci5jb21wYXJlXG4gICAgICAgICB8IGBEZWNyZWFzaW5nIC0+IEZuLmZsaXAgY29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBjb21wYXJlIGNvbXBhcmVfZWx0IHMxIHMyID1cbiAgICBFbnVtLmNvbXBhcmUgY29tcGFyZV9lbHQgKEVudW0ub2Zfc2V0IHMxKSAoRW51bS5vZl9zZXQgczIpXG4gIDs7XG5cbiAgbGV0IGl0ZXIyIHMxIHMyIH5jb21wYXJlX2VsdCB+ZiA9XG4gICAgRW51bS5pdGVyMiBjb21wYXJlX2VsdCAoRW51bS5vZl9zZXQgczEpIChFbnVtLm9mX3NldCBzMikgfmZcbiAgOztcblxuICBsZXQgZXF1YWwgczEgczIgfmNvbXBhcmVfZWx0ID0gY29tcGFyZSBjb21wYXJlX2VsdCBzMSBzMiA9IDBcblxuICBsZXQgaXNfc3Vic2V0IHMxIH5vZl86czIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGlzX3N1YnNldCBzMSB+b2ZfOnMyID1cbiAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICB8IEVtcHR5LCBfIC0+IHRydWVcbiAgICAgIHwgXywgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTGVhZiB7IGVsdCA9IHYxIH0sIHQyIC0+IG1lbSB0MiB2MSB+Y29tcGFyZV9lbHRcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsMTsgZWx0ID0gdjE7IHJpZ2h0ID0gcjE7IGhlaWdodCA9IF87IHNpemUgPSBfIH0sIExlYWYgeyBlbHQgPSB2MiB9XG4gICAgICAgIC0+XG4gICAgICAgIChtYXRjaCBsMSwgcjEgd2l0aFxuICAgICAgICAgfCBFbXB0eSwgRW1wdHkgLT5cbiAgICAgICAgICAgKCogVGhpcyBjYXNlIHNob3VsZG4ndCBvY2N1ciBpbiBwcmFjdGljZSBiZWNhdXNlIHdlIHNob3VsZCBoYXZlIGNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgIGEgTGVhZiB7ZWx0PXJhdGhlcn0gdGhhbiBhIE5vZGUgd2l0aCB0d28gRW1wdHkgc3VidHJlZXMgKilcbiAgICAgICAgICAgY29tcGFyZV9lbHQgdjEgdjIgPSAwXG4gICAgICAgICB8IF8sIF8gLT4gZmFsc2UpXG4gICAgICB8ICggTm9kZSB7IGxlZnQgPSBsMTsgZWx0ID0gdjE7IHJpZ2h0ID0gcjE7IGhlaWdodCA9IF87IHNpemUgPSBfIH1cbiAgICAgICAgLCAoTm9kZSB7IGxlZnQgPSBsMjsgZWx0ID0gdjI7IHJpZ2h0ID0gcjI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gYXMgdDIpICkgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB2MSB2MiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgcGh5c19lcXVhbCBzMSBzMiB8fCAoaXNfc3Vic2V0IGwxIH5vZl86bDIgJiYgaXNfc3Vic2V0IHIxIH5vZl86cjIpXG4gICAgICAgICAgKCogTm90ZSB0aGF0IGhlaWdodCBhbmQgc2l6ZSBkb24ndCBtYXR0ZXIgaGVyZS4gKilcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgaXNfc3Vic2V0XG4gICAgICAgICAgICAoTm9kZSB7IGxlZnQgPSBsMTsgZWx0ID0gdjE7IHJpZ2h0ID0gRW1wdHk7IGhlaWdodCA9IDA7IHNpemUgPSAwIH0pXG4gICAgICAgICAgICB+b2ZfOmwyXG4gICAgICAgICAgJiYgaXNfc3Vic2V0IHIxIH5vZl86dDJcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlzX3N1YnNldFxuICAgICAgICAgICAgKE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGVsdCA9IHYxOyByaWdodCA9IHIxOyBoZWlnaHQgPSAwOyBzaXplID0gMCB9KVxuICAgICAgICAgICAgfm9mXzpyMlxuICAgICAgICAgICYmIGlzX3N1YnNldCBsMSB+b2ZfOnQyXG4gICAgaW5cbiAgICBpc19zdWJzZXQgczEgfm9mXzpzMlxuICA7O1xuXG4gIGxldCByZWMgYXJlX2Rpc2pvaW50IHMxIHMyIH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgICB8IEVtcHR5LCBfIHwgXywgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgTGVhZiB7IGVsdCB9LCBvdGhlcl9zZXQgfCBvdGhlcl9zZXQsIExlYWYgeyBlbHQgfSAtPlxuICAgICAgbm90IChtZW0gb3RoZXJfc2V0IGVsdCB+Y29tcGFyZV9lbHQpXG4gICAgfCBOb2RlIHsgbGVmdCA9IGwxOyBlbHQgPSB2MTsgcmlnaHQgPSByMTsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSwgdDIgLT5cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzcGxpdCB0MiB2MSB+Y29tcGFyZV9lbHQgd2l0aFxuICAgICAgICB8IGwyLCBOb25lLCByMiAtPlxuICAgICAgICAgIGFyZV9kaXNqb2ludCBsMSBsMiB+Y29tcGFyZV9lbHQgJiYgYXJlX2Rpc2pvaW50IHIxIHIyIH5jb21wYXJlX2VsdFxuICAgICAgICB8IF8sIFNvbWUgXywgXyAtPiBmYWxzZSlcbiAgOztcblxuICBsZXQgaXRlciB0IH5mID1cbiAgICBsZXQgcmVjIGl0ZXIgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IGYgdlxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgICBpdGVyIGw7XG4gICAgICAgIGYgdjtcbiAgICAgICAgaXRlciByXG4gICAgaW5cbiAgICBpdGVyIHQgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiA9IEVudW0uc3ltbWV0cmljX2RpZmZcblxuICBsZXQgcmVjIGZvbGQgcyB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT4gZiBhY2N1IHZcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICBmb2xkIH5mIHIgfmluaXQ6KGYgKGZvbGQgfmYgbCB+aW5pdDphY2N1KSB2KVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2VsZW0gc3RhdGUgdCA9XG4gICAgZm9sZCB0IH5pbml0OihoYXNoX2ZvbGRfaW50IHN0YXRlIChsZW5ndGggdCkpIH5mOmhhc2hfZm9sZF9lbGVtXG4gIDs7XG5cbiAgbGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5cbiAgbGV0IHJlYyBmb2xkX3JpZ2h0IHMgfmluaXQ6YWNjdSB+ZiA9XG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IGYgdiBhY2N1XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgZm9sZF9yaWdodCB+ZiBsIH5pbml0OihmIHYgKGZvbGRfcmlnaHQgfmYgciB+aW5pdDphY2N1KSlcbiAgOztcblxuICBsZXQgcmVjIGZvcl9hbGwgdCB+ZjpwID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IHRydWVcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT4gcCB2XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgcCB2ICYmIGZvcl9hbGwgfmY6cCBsICYmIGZvcl9hbGwgfmY6cCByXG4gIDs7XG5cbiAgbGV0IHJlYyBleGlzdHMgdCB+ZjpwID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGZhbHNlXG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IHAgdlxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgIHAgdiB8fCBleGlzdHMgfmY6cCBsIHx8IGV4aXN0cyB+ZjpwIHJcbiAgOztcblxuICBsZXQgZmlsdGVyIHMgfmY6cCA9XG4gICAgbGV0IHJlYyBmaWx0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTGVhZiB7IGVsdCA9IHYgfSBhcyB0IC0+IGlmIHAgdiB0aGVuIHQgZWxzZSBFbXB0eVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSBhcyB0IC0+XG4gICAgICAgIGxldCBsJyA9IGZpbHQgbCBpblxuICAgICAgICBsZXQga2VlcF92ID0gcCB2IGluXG4gICAgICAgIGxldCByJyA9IGZpbHQgciBpblxuICAgICAgICBpZiBrZWVwX3YgJiYgcGh5c19lcXVhbCBsIGwnICYmIHBoeXNfZXF1YWwgciByJ1xuICAgICAgICB0aGVuIHRcbiAgICAgICAgZWxzZSBpZiBrZWVwX3ZcbiAgICAgICAgdGhlbiBqb2luIGwnIHYgcidcbiAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcbiAgICBpblxuICAgIGZpbHQgcyBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAgcyB+ZjpwIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBmaWx0IGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT5cbiAgICAgICAgKG1hdGNoIHAgdiB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gYWNjdVxuICAgICAgICAgfCBTb21lIHYgLT4gYWRkIGFjY3UgdiB+Y29tcGFyZV9lbHQpXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgIGZpbHRcbiAgICAgICAgICAoZmlsdFxuICAgICAgICAgICAgIChtYXRjaCBwIHYgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gYWNjdVxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiBhZGQgYWNjdSB2IH5jb21wYXJlX2VsdClcbiAgICAgICAgICAgICBsKVxuICAgICAgICAgIHJcbiAgICBpblxuICAgIGZpbHQgRW1wdHkgcyBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl90ZiBzIH5mOnAgPVxuICAgIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5LCBFbXB0eVxuICAgICAgfCBMZWFmIHsgZWx0ID0gdiB9IGFzIHQgLT4gaWYgcCB2IHRoZW4gdCwgRW1wdHkgZWxzZSBFbXB0eSwgdFxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSBhcyB0IC0+XG4gICAgICAgIGxldCBsJ3QsIGwnZiA9IGxvb3AgbCBpblxuICAgICAgICBsZXQga2VlcF92X3QgPSBwIHYgaW5cbiAgICAgICAgbGV0IHIndCwgcidmID0gbG9vcCByIGluXG4gICAgICAgIGxldCBtayBrZWVwX3YgbCcgcicgPVxuICAgICAgICAgIGlmIGtlZXBfdiAmJiBwaHlzX2VxdWFsIGwgbCcgJiYgcGh5c19lcXVhbCByIHInXG4gICAgICAgICAgdGhlbiB0XG4gICAgICAgICAgZWxzZSBpZiBrZWVwX3ZcbiAgICAgICAgICB0aGVuIGpvaW4gbCcgdiByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG4gICAgICAgIGluXG4gICAgICAgIG1rIGtlZXBfdl90IGwndCByJ3QsIG1rIChub3Qga2VlcF92X3QpIGwnZiByJ2ZcbiAgICBpblxuICAgIGxvb3AgcyBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHJlYyBlbGVtZW50c19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IHYgOjogYWNjdVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBlbHQgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT5cbiAgICAgIGVsZW1lbnRzX2F1eCAodiA6OiBlbGVtZW50c19hdXggYWNjdSByKSBsXG4gIDs7XG5cbiAgbGV0IGVsZW1lbnRzIHMgPSBlbGVtZW50c19hdXggW10gc1xuXG4gIGxldCBjaG9vc2UgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IFNvbWUgdlxuICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBlbHQgPSB2OyByaWdodCA9IF87IGhlaWdodCA9IF87IHNpemUgPSBfIH0gLT4gU29tZSB2XG4gIDs7XG5cbiAgbGV0IGNob29zZV9leG4gPVxuICAgIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlNldC5jaG9vc2VfZXhuOiBlbXB0eSBzZXRcIikgaW5cbiAgICBsZXQgY2hvb3NlX2V4biB0ID1cbiAgICAgIG1hdGNoIGNob29zZSB0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICAgIHwgU29tZSB2IC0+IHZcbiAgICBpblxuICAgICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgICBjaG9vc2VfZXhuXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3QgbHN0IH5jb21wYXJlX2VsdCA9XG4gICAgTGlzdC5mb2xkIGxzdCB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCB4IH5jb21wYXJlX2VsdClcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2Ugc2VxdWVuY2UgfmNvbXBhcmVfZWx0ID1cbiAgICBTZXF1ZW5jZS5mb2xkIHNlcXVlbmNlIH5pbml0OmVtcHR5IH5mOihmdW4gdCB4IC0+IGFkZCB0IHggfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gIGxldCB0b19saXN0IHMgPSBlbGVtZW50cyBzXG5cbiAgbGV0IG9mX2FycmF5IGEgfmNvbXBhcmVfZWx0ID1cbiAgICBBcnJheS5mb2xkIGEgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgeCB+Y29tcGFyZV9lbHQpXG4gIDs7XG5cbiAgKCogZmFzdGVyIGJ1dCBlcXVpdmFsZW50IHRvIFtBcnJheS5vZl9saXN0ICh0b19saXN0IHQpXSAqKVxuICBsZXQgdG9fYXJyYXkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gW3x8XVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBbfCB2IHxdXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IHMgfSAtPlxuICAgICAgbGV0IHJlcyA9IEFycmF5LmNyZWF0ZSB+bGVuOnMgdiBpblxuICAgICAgbGV0IHBvc19yZWYgPSByZWYgMCBpblxuICAgICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgICAgKCogSW52YXJpYW50OiBvbiBlbnRyeSBhbmQgb24gZXhpdCB0byBbbG9vcF0sICFwb3NfcmVmIGlzIHRoZSBuZXh0XG4gICAgICAgICAgIGF2YWlsYWJsZSBjZWxsIGluIHRoZSBhcnJheS4gKilcbiAgICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT5cbiAgICAgICAgICByZXMuKCFwb3NfcmVmKSA8LSB2O1xuICAgICAgICAgIGluY3IgcG9zX3JlZlxuICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICAgICAgbG9vcCBsO1xuICAgICAgICAgIHJlcy4oIXBvc19yZWYpIDwtIHY7XG4gICAgICAgICAgaW5jciBwb3NfcmVmO1xuICAgICAgICAgIGxvb3AgclxuICAgICAgaW5cbiAgICAgIGxvb3AgbDtcbiAgICAgICgqIHJlcy4oIXBvc19yZWYpIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQgKGJ5IEFycmF5LmNyZWF0ZSB+bGVuOmFib3ZlKS4gKilcbiAgICAgIGluY3IgcG9zX3JlZjtcbiAgICAgIGxvb3AgcjtcbiAgICAgIHJlc1xuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiB+Y29tcGFyZV9lbHQgPVxuICAgIGZvbGQgdCB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCAoZiB4KSB+Y29tcGFyZV9lbHQpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZ3JvdXBfYnkgc2V0IH5lcXVpdiA9XG4gICAgbGV0IHJlYyBsb29wIHNldCBlcXVpdl9jbGFzc2VzID1cbiAgICAgIGlmIGlzX2VtcHR5IHNldFxuICAgICAgdGhlbiBlcXVpdl9jbGFzc2VzXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHggPSBjaG9vc2VfZXhuIHNldCBpblxuICAgICAgICBsZXQgZXF1aXZfeCwgbm90X2VxdWl2X3ggPVxuICAgICAgICAgIHBhcnRpdGlvbl90ZiBzZXQgfmY6KGZ1biBlbHQgLT4gcGh5c19lcXVhbCB4IGVsdCB8fCBlcXVpdiB4IGVsdClcbiAgICAgICAgaW5cbiAgICAgICAgbG9vcCBub3RfZXF1aXZfeCAoZXF1aXZfeCA6OiBlcXVpdl9jbGFzc2VzKSlcbiAgICBpblxuICAgIGxvb3Agc2V0IFtdIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgcmVjIGZpbmQgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHsgZWx0ID0gdiB9IC0+IGlmIGYgdiB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gXyB9IC0+XG4gICAgICBpZiBmIHZcbiAgICAgIHRoZW4gU29tZSB2XG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggZmluZCBsIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZpbmQgciB+ZlxuICAgICAgICB8IFNvbWUgXyBhcyByIC0+IHIpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kX21hcCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBlbHQgPSB2IH0gLT4gZiB2XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGVsdCA9IHY7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXzsgc2l6ZSA9IF8gfSAtPlxuICAgICAgKG1hdGNoIGYgdiB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgciAtPiByXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICAobWF0Y2ggZmluZF9tYXAgbCB+ZiB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGZpbmRfbWFwIHIgfmZcbiAgICAgICAgICB8IFNvbWUgXyBhcyByIC0+IHIpKVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNldC5maW5kX2V4biBmYWlsZWQgdG8gZmluZCBhIG1hdGNoaW5nIGVsZW1lbnRcIlxuICAgIHwgU29tZSBlIC0+IGVcbiAgOztcblxuICBsZXQgcmVjIG50aCB0IGkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGVsdCA9IHYgfSAtPiBpZiBpID0gMCB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsgZWx0ID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfOyBzaXplID0gcyB9IC0+XG4gICAgICBpZiBpID49IHNcbiAgICAgIHRoZW4gTm9uZVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBsX3NpemUgPSBsZW5ndGggbCBpblxuICAgICAgICBsZXQgYyA9IFBvbHkuY29tcGFyZSBpIGxfc2l6ZSBpblxuICAgICAgICBpZiBjIDwgMCB0aGVuIG50aCBsIGkgZWxzZSBpZiBjID0gMCB0aGVuIFNvbWUgdiBlbHNlIG50aCByIChpIC0gbF9zaXplIC0gMSkpXG4gIDs7XG5cbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IHhzIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBsb29wIHhzIGxlZnRvdmVycyBhbHJlYWR5X3NlZW4gPVxuICAgICAgbWF0Y2ggeHMgd2l0aFxuICAgICAgfCBbXSAtPiBMaXN0LnJldiBsZWZ0b3ZlcnNcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgaWYgbWVtIGFscmVhZHlfc2VlbiBoZCB+Y29tcGFyZV9lbHRcbiAgICAgICAgdGhlbiBsb29wIHRsIGxlZnRvdmVycyBhbHJlYWR5X3NlZW5cbiAgICAgICAgZWxzZSBsb29wIHRsIChoZCA6OiBsZWZ0b3ZlcnMpIChhZGQgYWxyZWFkeV9zZWVuIGhkIH5jb21wYXJlX2VsdClcbiAgICBpblxuICAgIGxvb3AgeHMgW10gZW1wdHlcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCBhX29mX3NleHAgc2V4cCB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgU2V4cC5MaXN0IGxzdCAtPlxuICAgICAgbGV0IGVsdF9sc3QgPSBMaXN0Lm1hcCBsc3QgfmY6YV9vZl9zZXhwIGluXG4gICAgICBsZXQgc2V0ID0gb2ZfbGlzdCBlbHRfbHN0IH5jb21wYXJlX2VsdCBpblxuICAgICAgaWYgbGVuZ3RoIHNldCA9IExpc3QubGVuZ3RoIGxzdFxuICAgICAgdGhlbiBzZXRcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgc2V0ID0gcmVmIGVtcHR5IGluXG4gICAgICAgIExpc3QuaXRlcjJfZXhuIGxzdCBlbHRfbHN0IH5mOihmdW4gZWxfc2V4cCBlbCAtPlxuICAgICAgICAgIGlmIG1lbSAhc2V0IGVsIH5jb21wYXJlX2VsdFxuICAgICAgICAgIHRoZW4gb2Zfc2V4cF9lcnJvciBcIlNldC50X29mX3NleHA6IGR1cGxpY2F0ZSBlbGVtZW50IGluIHNldFwiIGVsX3NleHBcbiAgICAgICAgICBlbHNlIHNldCA6PSBhZGQgIXNldCBlbCB+Y29tcGFyZV9lbHQpO1xuICAgICAgICBhc3NlcnQgZmFsc2UpXG4gICAgfCBzZXhwIC0+IG9mX3NleHBfZXJyb3IgXCJTZXQudF9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgICBTZXhwLkxpc3QgKGZvbGRfcmlnaHQgdCB+aW5pdDpbXSB+ZjooZnVuIGVsIGFjYyAtPiBzZXhwX29mX2EgZWwgOjogYWNjKSlcbiAgOztcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICBsZXQgaXNfc3Vic2V0XG4gICAgICAoc3Vic2V0IDogXyBOYW1lZC50KVxuICAgICAgfm9mXzooc3VwZXJzZXQgOiBfIE5hbWVkLnQpXG4gICAgICB+c2V4cF9vZl9lbHRcbiAgICAgIH5jb21wYXJlX2VsdFxuICAgICAgPVxuICAgICAgbGV0IGludmFsaWRfZWxlbWVudHMgPSBkaWZmIHN1YnNldC5zZXQgc3VwZXJzZXQuc2V0IH5jb21wYXJlX2VsdCBpblxuICAgICAgaWYgaXNfZW1wdHkgaW52YWxpZF9lbGVtZW50c1xuICAgICAgdGhlbiBPayAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBpbnZhbGlkX2VsZW1lbnRzX3NleHAgPSBzZXhwX29mX3Qgc2V4cF9vZl9lbHQgaW52YWxpZF9lbGVtZW50cyBpblxuICAgICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgIChzdWJzZXQubmFtZSBeIFwiIGlzIG5vdCBhIHN1YnNldCBvZiBcIiBeIHN1cGVyc2V0Lm5hbWUpXG4gICAgICAgICAgICAgWyBcImludmFsaWRfZWxlbWVudHNcIiwgaW52YWxpZF9lbGVtZW50c19zZXhwIF0pKVxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgczEgczIgfnNleHBfb2ZfZWx0IH5jb21wYXJlX2VsdCA9XG4gICAgICBPcl9lcnJvci5jb21iaW5lX2Vycm9yc191bml0XG4gICAgICAgIFsgaXNfc3Vic2V0IHMxIH5vZl86czIgfnNleHBfb2ZfZWx0IH5jb21wYXJlX2VsdFxuICAgICAgICA7IGlzX3N1YnNldCBzMiB+b2ZfOnMxIH5zZXhwX29mX2VsdCB+Y29tcGFyZV9lbHRcbiAgICAgICAgXVxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbnR5cGUgKCdhLCAnY29tcGFyYXRvcikgdCA9XG4gIHsgKCogW2NvbXBhcmF0b3JdIGlzIHRoZSBmaXJzdCBmaWVsZCBzbyB0aGF0IHBvbHltb3JwaGljIGVxdWFsaXR5IGZhaWxzIG9uIGEgbWFwIGR1ZVxuICAgICAgIHRvIHRoZSBmdW5jdGlvbmFsIHZhbHVlIGluIHRoZSBjb21wYXJhdG9yLlxuICAgICAgIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGFmZmVjdCBwb2x5bW9ycGhpYyBbY29tcGFyZV06IHRoYXQgc3RpbGwgcHJvZHVjZXNcbiAgICAgICBub25zZW5zZS4gKilcbiAgICBjb21wYXJhdG9yIDogKCdhLCAnY29tcGFyYXRvcikgQ29tcGFyYXRvci50XG4gIDsgdHJlZSA6ICdhIFRyZWUwLnRcbiAgfVxuXG50eXBlICgnYSwgJ2NvbXBhcmF0b3IpIHRyZWUgPSAnYSBUcmVlMC50XG5cbmxldCBsaWtlIHsgdHJlZSA9IF87IGNvbXBhcmF0b3IgfSB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yIH1cblxubGV0IGxpa2VfbWF5YmVfbm9fb3AgKHsgdHJlZSA9IG9sZF90cmVlOyBjb21wYXJhdG9yIH0gYXMgb2xkX3QpIHRyZWUgPVxuICBpZiBwaHlzX2VxdWFsIG9sZF90cmVlIHRyZWUgdGhlbiBvbGRfdCBlbHNlIHsgdHJlZTsgY29tcGFyYXRvciB9XG47O1xuXG5sZXQgY29tcGFyZV9lbHQgdCA9IHQuY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxubW9kdWxlIEFjY2Vzc29ycyA9IHN0cnVjdFxuICBsZXQgY29tcGFyYXRvciB0ID0gdC5jb21wYXJhdG9yXG4gIGxldCBjb21wYXJhdG9yX3MgdCA9IENvbXBhcmF0b3IudG9fbW9kdWxlIHQuY29tcGFyYXRvclxuICBsZXQgaW52YXJpYW50cyB0ID0gVHJlZTAuaW52YXJpYW50cyB0LnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KVxuICBsZXQgbGVuZ3RoIHQgPSBUcmVlMC5sZW5ndGggdC50cmVlXG4gIGxldCBpc19lbXB0eSB0ID0gVHJlZTAuaXNfZW1wdHkgdC50cmVlXG4gIGxldCBlbGVtZW50cyB0ID0gVHJlZTAuZWxlbWVudHMgdC50cmVlXG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHQudHJlZVxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHQudHJlZVxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0LnRyZWVcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0LnRyZWVcbiAgbGV0IGNob29zZSB0ID0gVHJlZTAuY2hvb3NlIHQudHJlZVxuICBsZXQgY2hvb3NlX2V4biB0ID0gVHJlZTAuY2hvb3NlX2V4biB0LnRyZWVcbiAgbGV0IHRvX2xpc3QgdCA9IFRyZWUwLnRvX2xpc3QgdC50cmVlXG4gIGxldCB0b19hcnJheSB0ID0gVHJlZTAudG9fYXJyYXkgdC50cmVlXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQudHJlZSB+aW5pdCB+ZlxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBUcmVlMC5mb2xkX3VudGlsIHQudHJlZSB+aW5pdCB+ZiB+ZmluaXNoXG4gIGxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3JpZ2h0IHQudHJlZSB+aW5pdCB+ZlxuICBsZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG4gIGxldCBpdGVyIHQgfmYgPSBUcmVlMC5pdGVyIHQudHJlZSB+ZlxuICBsZXQgaXRlcjIgYSBiIH5mID0gVHJlZTAuaXRlcjIgYS50cmVlIGIudHJlZSB+ZiB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IGEpXG4gIGxldCBleGlzdHMgdCB+ZiA9IFRyZWUwLmV4aXN0cyB0LnRyZWUgfmZcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdC50cmVlIH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdC50cmVlIH5mXG4gIGxldCBzdW0gbSB0IH5mID0gVHJlZTAuc3VtIG0gdC50cmVlIH5mXG4gIGxldCBmaW5kIHQgfmYgPSBUcmVlMC5maW5kIHQudHJlZSB+ZlxuICBsZXQgZmluZF9leG4gdCB+ZiA9IFRyZWUwLmZpbmRfZXhuIHQudHJlZSB+ZlxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IFRyZWUwLmZpbmRfbWFwIHQudHJlZSB+ZlxuICBsZXQgbWVtIHQgYSA9IFRyZWUwLm1lbSB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpXG4gIGxldCBmaWx0ZXIgdCB+ZiA9IGxpa2VfbWF5YmVfbm9fb3AgdCAoVHJlZTAuZmlsdGVyIHQudHJlZSB+ZilcbiAgbGV0IGFkZCB0IGEgPSBsaWtlIHQgKFRyZWUwLmFkZCB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKVxuICBsZXQgcmVtb3ZlIHQgYSA9IGxpa2UgdCAoVHJlZTAucmVtb3ZlIHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpXG4gIGxldCB1bmlvbiB0MSB0MiA9IGxpa2UgdDEgKFRyZWUwLnVuaW9uIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKSlcbiAgbGV0IGludGVyIHQxIHQyID0gbGlrZSB0MSAoVHJlZTAuaW50ZXIgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpKVxuICBsZXQgZGlmZiB0MSB0MiA9IGxpa2UgdDEgKFRyZWUwLmRpZmYgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpKVxuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiA9XG4gICAgVHJlZTAuc3ltbWV0cmljX2RpZmYgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfZGlyZWN0IHQxIHQyID0gVHJlZTAuY29tcGFyZSAoY29tcGFyZV9lbHQgdDEpIHQxLnRyZWUgdDIudHJlZVxuICBsZXQgZXF1YWwgdDEgdDIgPSBUcmVlMC5lcXVhbCB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSlcbiAgbGV0IGlzX3N1YnNldCB0IH5vZl8gPSBUcmVlMC5pc19zdWJzZXQgdC50cmVlIH5vZl86b2ZfLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KVxuXG4gIGxldCBhcmVfZGlzam9pbnQgdDEgdDIgPVxuICAgIFRyZWUwLmFyZV9kaXNqb2ludCB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSlcbiAgOztcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICBsZXQgdG9fbmFtZWRfdHJlZSAobmFtZWQgOiAoXywgXykgdCBOYW1lZC50KSA9IHsgbmFtZWQgd2l0aCBzZXQgPSBuYW1lZC5zZXQudHJlZSB9XG5cbiAgICBsZXQgaXNfc3Vic2V0IHN1YnNldCB+b2ZfOnN1cGVyc2V0ID1cbiAgICAgIFRyZWUwLk5hbWVkLmlzX3N1YnNldFxuICAgICAgICAodG9fbmFtZWRfdHJlZSBzdWJzZXQpXG4gICAgICAgIH5vZl86KHRvX25hbWVkX3RyZWUgc3VwZXJzZXQpXG4gICAgICAgIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgc3Vic2V0LnNldClcbiAgICAgICAgfnNleHBfb2ZfZWx0OnN1YnNldC5zZXQuY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsIHQxIHQyID1cbiAgICAgIE9yX2Vycm9yLmNvbWJpbmVfZXJyb3JzX3VuaXQgWyBpc19zdWJzZXQgdDEgfm9mXzp0MjsgaXNfc3Vic2V0IHQyIH5vZl86dDEgXVxuICAgIDs7XG5cbiAgICBpbmNsdWRlIE5hbWVkXG4gIGVuZFxuXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9XG4gICAgbGV0IHRyZWVfdCwgdHJlZV9mID0gVHJlZTAucGFydGl0aW9uX3RmIHQudHJlZSB+ZiBpblxuICAgIGxpa2VfbWF5YmVfbm9fb3AgdCB0cmVlX3QsIGxpa2VfbWF5YmVfbm9fb3AgdCB0cmVlX2ZcbiAgOztcblxuICBsZXQgc3BsaXQgdCBhID1cbiAgICBsZXQgdHJlZTEsIGIsIHRyZWUyID0gVHJlZTAuc3BsaXQgdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSBpblxuICAgIGxpa2UgdCB0cmVlMSwgYiwgbGlrZSB0IHRyZWUyXG4gIDs7XG5cbiAgbGV0IHNwbGl0X2xlX2d0IHQgYSA9XG4gICAgbGV0IHRyZWUxLCB0cmVlMiA9IFRyZWUwLnNwbGl0X2xlX2d0IHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkgaW5cbiAgICBsaWtlIHQgdHJlZTEsIGxpa2UgdCB0cmVlMlxuICA7O1xuXG4gIGxldCBzcGxpdF9sdF9nZSB0IGEgPVxuICAgIGxldCB0cmVlMSwgdHJlZTIgPSBUcmVlMC5zcGxpdF9sdF9nZSB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpIGluXG4gICAgbGlrZSB0IHRyZWUxLCBsaWtlIHQgdHJlZTJcbiAgOztcblxuICBsZXQgZ3JvdXBfYnkgdCB+ZXF1aXYgPSBMaXN0Lm1hcCAoVHJlZTAuZ3JvdXBfYnkgdC50cmVlIH5lcXVpdikgfmY6KGxpa2UgdClcbiAgbGV0IG50aCB0IGkgPSBUcmVlMC5udGggdC50cmVlIGlcbiAgbGV0IHJlbW92ZV9pbmRleCB0IGkgPSBsaWtlIHQgKFRyZWUwLnJlbW92ZV9pbmRleCB0LnRyZWUgaSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBfIHQgPSBUcmVlMC5zZXhwX29mX3Qgc2V4cF9vZl9hIHQudHJlZVxuXG4gIGxldCB0b19zZXF1ZW5jZSA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCA9XG4gICAgVHJlZTAudG9fc2VxdWVuY2UgdC5jb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0LnRyZWVcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2ID0gVHJlZTAuYmluYXJ5X3NlYXJjaCB0LnRyZWUgfmNvbXBhcmUgaG93IHZcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQudHJlZSB+c2VnbWVudF9vZiBob3dcbiAgOztcblxuICBsZXQgbWVyZ2VfdG9fc2VxdWVuY2UgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgdCcgPVxuICAgIFRyZWUwLm1lcmdlX3RvX3NlcXVlbmNlXG4gICAgICB0LmNvbXBhcmF0b3JcbiAgICAgID9vcmRlclxuICAgICAgP2dyZWF0ZXJfb3JfZXF1YWxfdG9cbiAgICAgID9sZXNzX29yX2VxdWFsX3RvXG4gICAgICB0LnRyZWVcbiAgICAgIHQnLnRyZWVcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX2RpcmVjdCBoYXNoX2ZvbGRfa2V5IHN0YXRlIHQgPVxuICAgIFRyZWUwLmhhc2hfZm9sZF90X2lnbm9yaW5nX3N0cnVjdHVyZSBoYXNoX2ZvbGRfa2V5IHN0YXRlIHQudHJlZVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgQWNjZXNzb3JzXG5cbmxldCBjb21wYXJlIF8gXyB0MSB0MiA9IGNvbXBhcmVfZGlyZWN0IHQxIHQyXG5cbm1vZHVsZSBUcmVlID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnY29tcGFyYXRvcikgdCA9ICgnYSwgJ2NvbXBhcmF0b3IpIHRyZWVcblxuICBsZXQgY2UgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3IgYV9vZl9zZXhwIHNleHAgPVxuICAgIFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKSBhX29mX3NleHAgc2V4cFxuICA7O1xuXG4gIGxldCBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uID0gVHJlZTAuZW1wdHlcbiAgbGV0IGVtcHR5IH5jb21wYXJhdG9yOl8gPSBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uXG4gIGxldCBzaW5nbGV0b24gfmNvbXBhcmF0b3I6XyBlID0gVHJlZTAuc2luZ2xldG9uIGVcbiAgbGV0IGxlbmd0aCB0ID0gVHJlZTAubGVuZ3RoIHRcbiAgbGV0IGludmFyaWFudHMgfmNvbXBhcmF0b3IgdCA9IFRyZWUwLmludmFyaWFudHMgdCB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBpc19lbXB0eSB0ID0gVHJlZTAuaXNfZW1wdHkgdFxuICBsZXQgZWxlbWVudHMgdCA9IFRyZWUwLmVsZW1lbnRzIHRcbiAgbGV0IG1pbl9lbHQgdCA9IFRyZWUwLm1pbl9lbHQgdFxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHRcbiAgbGV0IG1heF9lbHQgdCA9IFRyZWUwLm1heF9lbHQgdFxuICBsZXQgbWF4X2VsdF9leG4gdCA9IFRyZWUwLm1heF9lbHRfZXhuIHRcbiAgbGV0IGNob29zZSB0ID0gVHJlZTAuY2hvb3NlIHRcbiAgbGV0IGNob29zZV9leG4gdCA9IFRyZWUwLmNob29zZV9leG4gdFxuICBsZXQgdG9fbGlzdCB0ID0gVHJlZTAudG9fbGlzdCB0XG4gIGxldCB0b19hcnJheSB0ID0gVHJlZTAudG9fYXJyYXkgdFxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0IH5mXG4gIGxldCBleGlzdHMgdCB+ZiA9IFRyZWUwLmV4aXN0cyB0IH5mXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBUcmVlMC5mb3JfYWxsIHQgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBUcmVlMC5jb3VudCB0IH5mXG4gIGxldCBzdW0gbSB0IH5mID0gVHJlZTAuc3VtIG0gdCB+ZlxuICBsZXQgZmluZCB0IH5mID0gVHJlZTAuZmluZCB0IH5mXG4gIGxldCBmaW5kX2V4biB0IH5mID0gVHJlZTAuZmluZF9leG4gdCB+ZlxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IFRyZWUwLmZpbmRfbWFwIHQgfmZcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdCB+aW5pdCB+ZlxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBUcmVlMC5mb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaFxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0IH5pbml0IH5mXG4gIGxldCBtYXAgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLm1hcCB0IH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGZpbHRlciB0IH5mID0gVHJlZTAuZmlsdGVyIHQgfmZcbiAgbGV0IGZpbHRlcl9tYXAgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLmZpbHRlcl9tYXAgdCB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl90ZiB0IH5mXG4gIGxldCBpdGVyMiB+Y29tcGFyYXRvciBhIGIgfmYgPSBUcmVlMC5pdGVyMiBhIGIgfmYgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgbWVtIH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLm1lbSB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgYWRkIH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLmFkZCB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgcmVtb3ZlIH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLnJlbW92ZSB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgdW5pb24gfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC51bmlvbiB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBpbnRlciB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmludGVyIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGRpZmYgfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC5kaWZmIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgfmNvbXBhcmF0b3IgdDEgdDIgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgY29tcGFyZV9kaXJlY3QgfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC5jb21wYXJlIChjZSBjb21wYXJhdG9yKSB0MSB0MlxuICBsZXQgZXF1YWwgfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC5lcXVhbCB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBpc19zdWJzZXQgfmNvbXBhcmF0b3IgdCB+b2ZfID0gVHJlZTAuaXNfc3Vic2V0IHQgfm9mXyB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG5cbiAgbGV0IGFyZV9kaXNqb2ludCB+Y29tcGFyYXRvciB0MSB0MiA9XG4gICAgVHJlZTAuYXJlX2Rpc2pvaW50IHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2ZfbGlzdCB+Y29tcGFyYXRvciBsID0gVHJlZTAub2ZfbGlzdCBsIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IG9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIHMgPSBUcmVlMC5vZl9zZXF1ZW5jZSBzIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IG9mX2FycmF5IH5jb21wYXJhdG9yIGEgPSBUcmVlMC5vZl9hcnJheSBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhID1cbiAgICBUcmVlMC5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvcjpfIH5sZW4gfmYgPVxuICAgIFRyZWUwLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmZcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGEgPSBUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCB1bmlvbl9saXN0IH5jb21wYXJhdG9yIGwgPSBUcmVlMC51bmlvbl9saXN0IGwgfnRvX3RyZWU6Rm4uaWQgfmNvbXBhcmF0b3JcblxuICBsZXQgc3RhYmxlX2RlZHVwX2xpc3QgfmNvbXBhcmF0b3IgeHMgPVxuICAgIFRyZWUwLnN0YWJsZV9kZWR1cF9saXN0IHhzIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgZ3JvdXBfYnkgdCB+ZXF1aXYgPSBUcmVlMC5ncm91cF9ieSB0IH5lcXVpdlxuICBsZXQgc3BsaXQgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAuc3BsaXQgdCBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHNwbGl0X2xlX2d0IH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLnNwbGl0X2xlX2d0IHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBzcGxpdF9sdF9nZSB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5zcGxpdF9sdF9nZSB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgbnRoIHQgaSA9IFRyZWUwLm50aCB0IGlcbiAgbGV0IHJlbW92ZV9pbmRleCB+Y29tcGFyYXRvciB0IGkgPSBUcmVlMC5yZW1vdmVfaW5kZXggdCBpIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgXyB0ID0gVHJlZTAuc2V4cF9vZl90IHNleHBfb2ZfYSB0XG4gIGxldCB0b190cmVlIHQgPSB0XG4gIGxldCBvZl90cmVlIH5jb21wYXJhdG9yOl8gdCA9IHRcblxuICBsZXQgdG9fc2VxdWVuY2UgfmNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlIGNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB+Y29tcGFyYXRvcjpfIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHZcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgfmNvbXBhcmF0b3I6XyB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3dcbiAgOztcblxuICBsZXQgbWVyZ2VfdG9fc2VxdWVuY2UgfmNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgdCcgPVxuICAgIFRyZWUwLm1lcmdlX3RvX3NlcXVlbmNlIGNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgdCdcbiAgOztcblxuICBsZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5cbiAgbW9kdWxlIE5hbWVkID0gc3RydWN0XG4gICAgaW5jbHVkZSBUcmVlMC5OYW1lZFxuXG4gICAgbGV0IGlzX3N1YnNldCB+Y29tcGFyYXRvciB0MSB+b2ZfOnQyID1cbiAgICAgIFRyZWUwLk5hbWVkLmlzX3N1YnNldFxuICAgICAgICB0MVxuICAgICAgICB+b2ZfOnQyXG4gICAgICAgIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgICAgICAgfnNleHBfb2ZfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3RcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsIH5jb21wYXJhdG9yIHQxIHQyID1cbiAgICAgIFRyZWUwLk5hbWVkLmVxdWFsXG4gICAgICAgIHQxXG4gICAgICAgIHQyXG4gICAgICAgIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgICAgICAgfnNleHBfb2ZfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3RcbiAgICA7O1xuICBlbmRcbmVuZFxuXG5tb2R1bGUgVXNpbmdfY29tcGFyYXRvciA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2VsdCwgJ2NtcCkgdCA9ICgnZWx0LCAnY21wKSB0XG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgdG9fdHJlZSB0ID0gdC50cmVlXG4gIGxldCBvZl90cmVlIH5jb21wYXJhdG9yIHRyZWUgPSB7IGNvbXBhcmF0b3I7IHRyZWUgfVxuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGFfb2Zfc2V4cCBzZXhwID1cbiAgICBvZl90cmVlXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuY29tcGFyZSBhX29mX3NleHAgc2V4cClcbiAgOztcblxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3IgPSB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5lbXB0eSB9XG5cbiAgbW9kdWxlIEVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKEVsdCA6IENvbXBhcmF0b3IuUzEpID0gc3RydWN0XG4gICAgbGV0IGVtcHR5ID0geyBjb21wYXJhdG9yID0gRWx0LmNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5lbXB0eSB9XG4gIGVuZFxuXG4gIGxldCBzaW5nbGV0b24gfmNvbXBhcmF0b3IgZSA9IHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLnNpbmdsZXRvbiBlIH1cblxuICBsZXQgdW5pb25fbGlzdCB+Y29tcGFyYXRvciBsID1cbiAgICBvZl90cmVlIH5jb21wYXJhdG9yIChUcmVlMC51bmlvbl9saXN0IH5jb21wYXJhdG9yIH50b190cmVlIGwpXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIGxldCB0cmVlID1cbiAgICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgfVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvciB+bGVuIH5mID1cbiAgICBvZl90cmVlIH5jb21wYXJhdG9yIChUcmVlMC5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mKVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIE9yX2Vycm9yLk1vbmFkX2luZml4LihcbiAgICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgID4+fCBmdW4gdHJlZSAtPiB7IGNvbXBhcmF0b3I7IHRyZWUgfSlcbiAgOztcblxuICBsZXQgb2ZfbGlzdCB+Y29tcGFyYXRvciBsID1cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5vZl9saXN0IGwgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH1cbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3IgcyA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAub2Zfc2VxdWVuY2UgcyB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBvZl9hcnJheSB+Y29tcGFyYXRvciBhID1cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5vZl9hcnJheSBhIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB9XG4gIDs7XG5cbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yIHhzID1cbiAgICBUcmVlMC5zdGFibGVfZGVkdXBfbGlzdCB4cyB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgbWFwIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm1hcCB0LnRyZWUgfmYgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH1cbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCB+Y29tcGFyYXRvciB0IH5mID1cbiAgICB7IGNvbXBhcmF0b3JcbiAgICA7IHRyZWUgPSBUcmVlMC5maWx0ZXJfbWFwIHQudHJlZSB+ZiB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB9XG4gIDs7XG5cbiAgbW9kdWxlIFRyZWUgPSBUcmVlXG5lbmRcblxubGV0IHRvX2NvbXBhcmF0b3IgPSBDb21wYXJhdG9yLm9mX21vZHVsZVxubGV0IGVtcHR5IG0gPSBVc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG5sZXQgc2luZ2xldG9uIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCB1bmlvbl9saXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3IudW5pb25fbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgbSB+bGVuIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSB+bGVuIH5mXG47O1xuXG5sZXQgb2Zfc29ydGVkX2FycmF5IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9saXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2Zfc2VxdWVuY2UgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfYXJyYXkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hcnJheSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBzdGFibGVfZGVkdXBfbGlzdCBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLnN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBtYXAgbSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXAgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+ZlxubGV0IGZpbHRlcl9tYXAgbSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5maWx0ZXJfbWFwIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmZcbmxldCB0b190cmVlID0gVXNpbmdfY29tcGFyYXRvci50b190cmVlXG5sZXQgb2ZfdHJlZSBtIHQgPSBVc2luZ19jb21wYXJhdG9yLm9mX3RyZWUgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdFxuXG5tb2R1bGUgTSAoRWx0IDogc2lnXG4gIHR5cGUgdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IChFbHQudCwgRWx0LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbm1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBIYXNoX2ZvbGRfbSA9IEhhc2hlci5TXG5cbmxldCBzZXhwX29mX21fX3QgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGVsdCkgdCA9XG4gIHNleHBfb2ZfdCBFbHQuc2V4cF9vZl90IChmdW4gXyAtPiBTZXhwLkF0b20gXCJfXCIpIHRcbjs7XG5cbmxldCBtX190X29mX3NleHBcbiAgKHR5cGUgZWx0IGNtcClcbiAgKG1vZHVsZSBFbHQgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBlbHQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKVxuICBzZXhwXG4gID1cbiAgVXNpbmdfY29tcGFyYXRvci50X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yOkVsdC5jb21wYXJhdG9yIEVsdC50X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGVsdClcbiAgOiAoZWx0LCBfKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAobGlzdF9zZXhwX2dyYW1tYXIgRWx0LnRfc2V4cF9ncmFtbWFyKVxuOztcblxubGV0IGNvbXBhcmVfbV9fdCAobW9kdWxlIF8gOiBDb21wYXJlX20pIHQxIHQyID0gY29tcGFyZV9kaXJlY3QgdDEgdDJcbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIHQxIHQyID0gZXF1YWwgdDEgdDJcblxubGV0IGhhc2hfZm9sZF9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9IGVsdCkgc3RhdGUgPVxuICBoYXNoX2ZvbGRfZGlyZWN0IEVsdC5oYXNoX2ZvbGRfdCBzdGF0ZVxuOztcblxubGV0IGhhc2hfbV9fdCBmb2xkZXIgdCA9XG4gIGxldCBzdGF0ZSA9IGhhc2hfZm9sZF9tX190IGZvbGRlciAoSGFzaC5jcmVhdGUgKCkpIHQgaW5cbiAgSGFzaC5nZXRfaGFzaF92YWx1ZSBzdGF0ZVxuOztcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG4gIHR5cGUgbm9ucmVjICdlbHQgdCA9ICgnZWx0LCBjb21wYXJhdG9yX3dpdG5lc3MpIHRcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBjb21wYXJhdG9yID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3JcblxuICBpbmNsdWRlIFVzaW5nX2NvbXBhcmF0b3IuRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoQ29tcGFyYXRvci5Qb2x5KVxuXG4gIGxldCBzaW5nbGV0b24gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yIGFcbiAgbGV0IHVuaW9uX2xpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3IudW5pb25fbGlzdCB+Y29tcGFyYXRvciBhXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYSA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvciB+bGVuIH5mXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfbGlzdCBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9saXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX3NlcXVlbmNlIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FycmF5IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FycmF5IH5jb21wYXJhdG9yIGFcbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLnN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG1hcCBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXAgfmNvbXBhcmF0b3IgYSB+ZlxuICBsZXQgZmlsdGVyX21hcCBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5maWx0ZXJfbWFwIH5jb21wYXJhdG9yIGEgfmZcbiAgbGV0IG9mX3RyZWUgdHJlZSA9IHsgY29tcGFyYXRvcjsgdHJlZSB9XG4gIGxldCB0b190cmVlIHQgPSB0LnRyZWVcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbmluY2x1ZGUgKFxuICBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYSByZWZcbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBsZXQgY29tcGFyZV9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9IGNvbXBhcmVfcmVmX19sb2NhbFxuICAgIGxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPSBjb21wYXJlX3JlZlxuICAgIGxldCBlcXVhbF9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID0gZXF1YWxfcmVmX19sb2NhbFxuICAgIGxldCBlcXVhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPSBlcXVhbF9yZWZcblxuICAgIGxldCBnbG9iYWxpemUgOiAnYS4gKCdhIC0+ICdhKSAtPiAnYSB0IC0+ICdhIHQgPVxuICAgICAgZnVuICh0eXBlIGFfXzAxN18pIDogKChhX18wMTdfIC0+IGFfXzAxN18pIC0+IGFfXzAxN18gdCAtPiBhX18wMTdfIHQpIC0+XG4gICAgICBnbG9iYWxpemVfcmVmXG4gICAgOztcblxuICAgIGxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPSByZWZfb2Zfc2V4cFxuICAgIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPSBzZXhwX29mX3JlZlxuXG4gICAgbGV0IHRfc2V4cF9ncmFtbWFyIDogJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICAgICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gcmVmX3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gICAgOztcblxuICAgIFtAQEBlbmRdXG4gIGVuZCA6XG4gICAgc2lnXG4gICAgICB0eXBlICdhIHQgPSAnYSByZWZcbiAgICAgIFtAQGRlcml2aW5nX2lubGluZVxuICAgICAgICBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gICAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlNfbG9jYWwxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkVxdWFsLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkVxdWFsLlNfbG9jYWwxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAgICAgdmFsIGdsb2JhbGl6ZSA6ICgnYSAtPiAnYSkgLT4gJ2EgdCAtPiAnYSB0XG5cbiAgICAgIGluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgICB2YWwgdF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgICAgIFtAQEBlbmRdXG4gICAgZW5kKVxuXG4oKiBJbiB0aGUgZGVmaW5pdGlvbiBvZiBbdF0sIHdlIGRvIG5vdCBoYXZlIFtbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXV0gYmVjYXVzZVxuICAgaW4gZ2VuZXJhbCwgc3ludGF4IGV4dGVuc2lvbnMgdGVuZCB0byB1c2UgdGhlIGltcGxlbWVudGF0aW9uIHdoZW4gYXZhaWxhYmxlIHJhdGhlciB0aGFuXG4gICB1c2luZyB0aGUgYWxpYXMuICBIZXJlIHRoYXQgd291bGQgbGVhZCB0byB1c2UgdGhlIHJlY29yZCByZXByZXNlbnRhdGlvbiBbIHsgbXV0YWJsZVxuICAgY29udGVudHMgOiAnYSB9IF0gd2hpY2ggd291bGQgcmVzdWx0IGluIGRpZmZlcmVudCAoYW5kIHVud2FudGVkKSBiZWhhdmlvci4gICopXG50eXBlICdhIHQgPSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5cbmV4dGVybmFsIGNyZWF0ZSA6ICdhIC0+ICgnYSB0W0Bsb2NhbF9vcHRdKSA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogKCdhIHRbQGxvY2FsX29wdF0pIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICgnYSB0W0Bsb2NhbF9vcHRdKSAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcblxubGV0IHN3YXAgdDEgdDIgPVxuICBsZXQgdG1wID0gIXQxIGluXG4gIHQxIDo9ICF0MjtcbiAgdDIgOj0gdG1wXG47O1xuXG5sZXQgcmVwbGFjZSB0IGYgPSB0IDo9IGYgIXRcblxubGV0IHNldF90ZW1wb3JhcmlseSB0IGEgfmYgPVxuICBsZXQgcmVzdG9yZV90byA9ICF0IGluXG4gIHQgOj0gYTtcbiAgRXhuLnByb3RlY3QgfmYgfmZpbmFsbHk6KGZ1biAoKSAtPiB0IDo9IHJlc3RvcmVfdG8pXG47O1xuXG5tb2R1bGUgQW5kX3ZhbHVlID0gc3RydWN0XG4gIHR5cGUgdCA9IFQgOiAnYSByZWYgKiAnYSAtPiB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IHNldCAoVCAociwgYSkpID0gciA6PSBhXG4gIGxldCBzZXRzIHRzID0gTGlzdC5pdGVyIHRzIH5mOnNldFxuICBsZXQgc25hcHNob3QgKFQgKHIsIF8pKSA9IFQgKHIsICFyKVxuICBsZXQgc25hcHNob3RzIHRzID0gTGlzdC5tYXAgdHMgfmY6c25hcHNob3RcbmVuZFxuXG5sZXQgc2V0c190ZW1wb3JhcmlseSBhbmRfdmFsdWVzIH5mID1cbiAgbGV0IHJlc3RvcmVfdG8gPSBBbmRfdmFsdWUuc25hcHNob3RzIGFuZF92YWx1ZXMgaW5cbiAgQW5kX3ZhbHVlLnNldHMgYW5kX3ZhbHVlcztcbiAgRXhuLnByb3RlY3QgfmYgfmZpbmFsbHk6KGZ1biAoKSAtPiBBbmRfdmFsdWUuc2V0cyByZXN0b3JlX3RvKVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiBbdF0gc3RvcmVzIHRoZSBbdC5sZW5ndGhdIHF1ZXVlIGVsZW1lbnRzIGF0IGNvbnNlY3V0aXZlIGluY3JlYXNpbmcgaW5kaWNlcyBvZiBbdC5lbHRzXSxcbiAgIG1vZCB0aGUgY2FwYWNpdHkgb2YgW3RdLCB3aGljaCBpcyBbT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHNdLiAgVGhlIGNhcGFjaXR5IGlzXG4gICByZXF1aXJlZCB0byBiZSBhIHBvd2VyIG9mIHR3byAodXNlci1yZXF1ZXN0ZWQgY2FwYWNpdGllcyBhcmUgcm91bmRlZCB1cCB0byB0aGUgbmVhcmVzdFxuICAgcG93ZXIpLCBzbyB0aGF0IG1vZCBjYW4gcXVpY2tseSBiZSBjb21wdXRlZCB1c2luZyBbbGFuZCB0Lm1hc2tdLCB3aGVyZSBbdC5tYXNrID1cbiAgIGNhcGFjaXR5IHQgLSAxXS4gIFNvLCBxdWV1ZSBlbGVtZW50IFtpXSBpcyBhdCBbdC5lbHRzLiggKHQuZnJvbnQgKyBpKSBsYW5kIHQubWFzayApXS5cblxuICAgW251bV9tdXRhdGlvbnNdIGlzIHVzZWQgdG8gZGV0ZWN0IG1vZGlmaWNhdGlvbiBkdXJpbmcgaXRlcmF0aW9uLiAqKVxudHlwZSAnYSB0ID1cbiAgeyBtdXRhYmxlIG51bV9tdXRhdGlvbnMgOiBpbnRcbiAgOyBtdXRhYmxlIGZyb250IDogaW50XG4gIDsgbXV0YWJsZSBtYXNrIDogaW50XG4gIDsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgOyBtdXRhYmxlIGVsdHMgOiAnYSBPcHRpb25fYXJyYXkudFxuICB9XG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biBfb2ZfYV9fMDAxX1xuICAgICAgeyBudW1fbXV0YXRpb25zID0gbnVtX211dGF0aW9uc19fMDAzX1xuICAgICAgOyBmcm9udCA9IGZyb250X18wMDVfXG4gICAgICA7IG1hc2sgPSBtYXNrX18wMDdfXG4gICAgICA7IGxlbmd0aCA9IGxlbmd0aF9fMDA5X1xuICAgICAgOyBlbHRzID0gZWx0c19fMDExX1xuICAgICAgfSAtPlxuICBsZXQgYm5kc19fMDAyXyA9IChbXSA6IF8gU3RkbGliLkxpc3QudCkgaW5cbiAgbGV0IGJuZHNfXzAwMl8gPVxuICAgIGxldCBhcmdfXzAxMl8gPSBPcHRpb25fYXJyYXkuc2V4cF9vZl90IF9vZl9hX18wMDFfIGVsdHNfXzAxMV8gaW5cbiAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZWx0c1wiOyBhcmdfXzAxMl8gXSA6OiBibmRzX18wMDJfXG4gICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgaW5cbiAgbGV0IGJuZHNfXzAwMl8gPVxuICAgIGxldCBhcmdfXzAxMF8gPSBzZXhwX29mX2ludCBsZW5ndGhfXzAwOV8gaW5cbiAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibGVuZ3RoXCI7IGFyZ19fMDEwXyBdIDo6IGJuZHNfXzAwMl9cbiAgICAgIDogXyBTdGRsaWIuTGlzdC50KVxuICBpblxuICBsZXQgYm5kc19fMDAyXyA9XG4gICAgbGV0IGFyZ19fMDA4XyA9IHNleHBfb2ZfaW50IG1hc2tfXzAwN18gaW5cbiAgICAoU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibWFza1wiOyBhcmdfXzAwOF8gXSA6OiBibmRzX18wMDJfXG4gICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgaW5cbiAgbGV0IGJuZHNfXzAwMl8gPVxuICAgIGxldCBhcmdfXzAwNl8gPSBzZXhwX29mX2ludCBmcm9udF9fMDA1XyBpblxuICAgIChTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJmcm9udFwiOyBhcmdfXzAwNl8gXSA6OiBibmRzX18wMDJfXG4gICAgICA6IF8gU3RkbGliLkxpc3QudClcbiAgaW5cbiAgbGV0IGJuZHNfXzAwMl8gPVxuICAgIGxldCBhcmdfXzAwNF8gPSBzZXhwX29mX2ludCBudW1fbXV0YXRpb25zX18wMDNfIGluXG4gICAgKFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIm51bV9tdXRhdGlvbnNcIjsgYXJnX18wMDRfIF0gOjogYm5kc19fMDAyX1xuICAgICAgOiBfIFN0ZGxpYi5MaXN0LnQpXG4gIGluXG4gIFNleHBsaWIwLlNleHAuTGlzdCBibmRzX18wMDJfXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgZ2xvYmFsaXplIF8gdCA9XG4gIHsgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9uc1xuICA7IGZyb250ID0gdC5mcm9udFxuICA7IG1hc2sgPSB0Lm1hc2tcbiAgOyBsZW5ndGggPSB0Lmxlbmd0aFxuICA7IGVsdHMgPSBPcHRpb25fYXJyYXkuY29weSB0LmVsdHNcbiAgfVxuOztcblxubW9kdWxlIHR5cGUgUyA9IFF1ZXVlX2ludGYuU1xuXG5sZXQgaW5jX251bV9tdXRhdGlvbnMgdCA9IHQubnVtX211dGF0aW9ucyA8LSB0Lm51bV9tdXRhdGlvbnMgKyAxXG5sZXQgY2FwYWNpdHkgdCA9IHQubWFzayArIDFcbmxldCBlbHRzX2luZGV4IHQgaSA9ICh0LmZyb250ICsgaSkgbGFuZCB0Lm1hc2tcbmxldCB1bnNhZmVfZ2V0IHQgaSA9IE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfZXhuIHQuZWx0cyAoZWx0c19pbmRleCB0IGkpXG5sZXQgdW5zYWZlX2lzX3NldCB0IGkgPSBPcHRpb25fYXJyYXkudW5zYWZlX2lzX3NvbWUgdC5lbHRzIChlbHRzX2luZGV4IHQgaSlcbmxldCB1bnNhZmVfc2V0IHQgaSBhID0gT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZSB0LmVsdHMgKGVsdHNfaW5kZXggdCBpKSBhXG5sZXQgdW5zYWZlX3Vuc2V0IHQgaSA9IE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X25vbmUgdC5lbHRzIChlbHRzX2luZGV4IHQgaSlcblxubGV0IGNoZWNrX2luZGV4X2V4biB0IGkgPVxuICBpZiBpIDwgMCB8fCBpID49IHQubGVuZ3RoXG4gIHRoZW5cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIlF1ZXVlIGluZGV4IG91dCBvZiBib3VuZHNcIlxuICAgICAgICAgWyBcImluZGV4XCIsIGkgfD4gSW50LnNleHBfb2ZfdDsgXCJsZW5ndGhcIiwgdC5sZW5ndGggfD4gSW50LnNleHBfb2ZfdCBdKVxuOztcblxubGV0IGdldCB0IGkgPVxuICBjaGVja19pbmRleF9leG4gdCBpO1xuICB1bnNhZmVfZ2V0IHQgaVxuOztcblxubGV0IHNldCB0IGkgYSA9XG4gIGNoZWNrX2luZGV4X2V4biB0IGk7XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIHVuc2FmZV9zZXQgdCBpIGFcbjs7XG5cbmxldCBpc19lbXB0eSB0ID0gdC5sZW5ndGggPSAwXG5sZXQgbGVuZ3RoIHsgbGVuZ3RoOyBfIH0gPSBsZW5ndGhcblxubGV0W0Bjb2xkXSBbQGlubGluZSBuZXZlcl0gcmFpc2VfbXV0YXRpb25fZHVyaW5nX2l0ZXJhdGlvbiB0ID1cbiAgRXJyb3IucmFpc2Vfc1xuICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICBcIm11dGF0aW9uIG9mIHF1ZXVlIGR1cmluZyBpdGVyYXRpb25cIlxuICAgICAgIFsgXCJcIiwgdCB8PiBnbG9iYWxpemUgKCkgfD4gc2V4cF9vZl90IChmdW4gXyAtPiBTZXhwLkF0b20gXCJfXCIpIF0pXG47O1xuXG5sZXQgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9ucyA9XG4gIGlmIHQubnVtX211dGF0aW9ucyA8PiBudW1fbXV0YXRpb25zIHRoZW4gcmFpc2VfbXV0YXRpb25fZHVyaW5nX2l0ZXJhdGlvbiB0XG47O1xuXG5sZXQgY29tcGFyZV9fbG9jYWwgPVxuICBsZXQgcmVjIHVuc2FmZV9jb21wYXJlX2Zyb20gY29tcGFyZV9lbHQgcG9zIH50MSB+dDIgfmxlbjEgfmxlbjIgfm11dDEgfm11dDIgPVxuICAgIG1hdGNoIHBvcyA9IGxlbjEsIHBvcyA9IGxlbjIgd2l0aFxuICAgIHwgdHJ1ZSwgdHJ1ZSAtPiAwXG4gICAgfCB0cnVlLCBmYWxzZSAtPiAtMVxuICAgIHwgZmFsc2UsIHRydWUgLT4gMVxuICAgIHwgZmFsc2UsIGZhbHNlIC0+XG4gICAgICBsZXQgeCA9IGNvbXBhcmVfZWx0ICh1bnNhZmVfZ2V0IHQxIHBvcykgKHVuc2FmZV9nZXQgdDIgcG9zKSBpblxuICAgICAgZW5zdXJlX25vX211dGF0aW9uIHQxIG11dDE7XG4gICAgICBlbnN1cmVfbm9fbXV0YXRpb24gdDIgbXV0MjtcbiAgICAgIChtYXRjaCB4IHdpdGhcbiAgICAgICB8IDAgLT4gdW5zYWZlX2NvbXBhcmVfZnJvbSBjb21wYXJlX2VsdCAocG9zICsgMSkgfnQxIH50MiB+bGVuMSB+bGVuMiB+bXV0MSB+bXV0MlxuICAgICAgIHwgbiAtPiBuKVxuICBpblxuICBmdW4gY29tcGFyZV9lbHQgdDEgdDIgLT5cbiAgICBpZiBwaHlzX2VxdWFsIHQxIHQyXG4gICAgdGhlbiAwXG4gICAgZWxzZVxuICAgICAgdW5zYWZlX2NvbXBhcmVfZnJvbVxuICAgICAgICBjb21wYXJlX2VsdFxuICAgICAgICAwXG4gICAgICAgIH50MVxuICAgICAgICB+dDJcbiAgICAgICAgfmxlbjE6dDEubGVuZ3RoXG4gICAgICAgIH5sZW4yOnQyLmxlbmd0aFxuICAgICAgICB+bXV0MTp0MS5udW1fbXV0YXRpb25zXG4gICAgICAgIH5tdXQyOnQyLm51bV9tdXRhdGlvbnNcbjs7XG5cbmxldCBjb21wYXJlIGNvbXBhcmVfZWx0IHQxIHQyID0gY29tcGFyZV9fbG9jYWwgY29tcGFyZV9lbHQgdDEgdDJcblxubGV0IGVxdWFsX19sb2NhbCA9XG4gIGxldCByZWMgdW5zYWZlX2VxdWFsX2Zyb20gZXF1YWxfZWx0IHBvcyB+dDEgfnQyIH5tdXQxIH5tdXQyIH5sZW4gPVxuICAgIHBvcyA9IGxlblxuICAgIHx8XG4gICAgbGV0IGIgPSBlcXVhbF9lbHQgKHVuc2FmZV9nZXQgdDEgcG9zKSAodW5zYWZlX2dldCB0MiBwb3MpIGluXG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQxIG11dDE7XG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQyIG11dDI7XG4gICAgYiAmJiB1bnNhZmVfZXF1YWxfZnJvbSBlcXVhbF9lbHQgKHBvcyArIDEpIH50MSB+dDIgfm11dDEgfm11dDIgfmxlblxuICBpblxuICBmdW4gZXF1YWxfZWx0IHQxIHQyIC0+XG4gICAgcGh5c19lcXVhbCB0MSB0MlxuICAgIHx8XG4gICAgbGV0IGxlbjEgPSB0MS5sZW5ndGggaW5cbiAgICBsZXQgbGVuMiA9IHQyLmxlbmd0aCBpblxuICAgIGxlbjEgPSBsZW4yXG4gICAgJiYgdW5zYWZlX2VxdWFsX2Zyb21cbiAgICAgICAgIGVxdWFsX2VsdFxuICAgICAgICAgMFxuICAgICAgICAgfnQxXG4gICAgICAgICB+dDJcbiAgICAgICAgIH5sZW46bGVuMVxuICAgICAgICAgfm11dDE6dDEubnVtX211dGF0aW9uc1xuICAgICAgICAgfm11dDI6dDIubnVtX211dGF0aW9uc1xuOztcblxubGV0IGVxdWFsIGVxdWFsX2VsdCB0MSB0MiA9IGVxdWFsX19sb2NhbCBlcXVhbF9lbHQgdDEgdDJcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID1cbiAgbGV0IHsgbnVtX211dGF0aW9uczsgbWFzayA9IF87IGVsdHM7IGZyb250OyBsZW5ndGggfSA9IHQgaW5cbiAgYXNzZXJ0IChmcm9udCA+PSAwKTtcbiAgYXNzZXJ0IChmcm9udCA8IGNhcGFjaXR5IHQpO1xuICBsZXQgY2FwYWNpdHkgPSBjYXBhY2l0eSB0IGluXG4gIGFzc2VydCAoY2FwYWNpdHkgPSBPcHRpb25fYXJyYXkubGVuZ3RoIGVsdHMpO1xuICBhc3NlcnQgKGNhcGFjaXR5ID49IDEpO1xuICBhc3NlcnQgKEludC5pc19wb3cyIGNhcGFjaXR5KTtcbiAgYXNzZXJ0IChsZW5ndGggPj0gMCk7XG4gIGFzc2VydCAobGVuZ3RoIDw9IGNhcGFjaXR5KTtcbiAgZm9yIGkgPSAwIHRvIGNhcGFjaXR5IC0gMSBkb1xuICAgIGlmIGkgPCB0Lmxlbmd0aFxuICAgIHRoZW4gKFxuICAgICAgaW52YXJpYW50X2EgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnMpXG4gICAgZWxzZSBhc3NlcnQgKG5vdCAodW5zYWZlX2lzX3NldCB0IGkpKVxuICBkb25lXG47O1xuXG5sZXQgY3JlYXRlICh0eXBlIGEpID9jYXBhY2l0eSAoKSA6IGEgdCA9XG4gIGxldCBjYXBhY2l0eSA9XG4gICAgbWF0Y2ggY2FwYWNpdHkgd2l0aFxuICAgIHwgTm9uZSAtPiAyXG4gICAgfCBTb21lIGNhcGFjaXR5IC0+XG4gICAgICBpZiBjYXBhY2l0eSA8IDBcbiAgICAgIHRoZW5cbiAgICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgICBcImNhbm5vdCBoYXZlIHF1ZXVlIHdpdGggbmVnYXRpdmUgY2FwYWNpdHlcIlxuICAgICAgICAgICAgIFsgXCJjYXBhY2l0eVwiLCBjYXBhY2l0eSB8PiBJbnQuc2V4cF9vZl90IF0pXG4gICAgICBlbHNlIGlmIGNhcGFjaXR5ID0gMFxuICAgICAgdGhlbiAxXG4gICAgICBlbHNlIEludC5jZWlsX3BvdzIgY2FwYWNpdHlcbiAgaW5cbiAgeyBudW1fbXV0YXRpb25zID0gMFxuICA7IGZyb250ID0gMFxuICA7IG1hc2sgPSBjYXBhY2l0eSAtIDFcbiAgOyBsZW5ndGggPSAwXG4gIDsgZWx0cyA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjpjYXBhY2l0eVxuICB9XG47O1xuXG5sZXQgYmxpdF90b19hcnJheSB+c3JjIGRzdCA9XG4gIGFzc2VydCAoc3JjLmxlbmd0aCA8PSBPcHRpb25fYXJyYXkubGVuZ3RoIGRzdCk7XG4gIGxldCBmcm9udF9sZW4gPSBJbnQubWluIHNyYy5sZW5ndGggKGNhcGFjaXR5IHNyYyAtIHNyYy5mcm9udCkgaW5cbiAgbGV0IHJlc3RfbGVuID0gc3JjLmxlbmd0aCAtIGZyb250X2xlbiBpblxuICBPcHRpb25fYXJyYXkuYmxpdCB+bGVuOmZyb250X2xlbiB+c3JjOnNyYy5lbHRzIH5zcmNfcG9zOnNyYy5mcm9udCB+ZHN0IH5kc3RfcG9zOjA7XG4gIE9wdGlvbl9hcnJheS5ibGl0IH5sZW46cmVzdF9sZW4gfnNyYzpzcmMuZWx0cyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6ZnJvbnRfbGVuXG47O1xuXG5sZXQgc2V0X2NhcGFjaXR5X2ludGVybmFsIHQgbmV3X2NhcGFjaXR5ID1cbiAgbGV0IGRzdCA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjpuZXdfY2FwYWNpdHkgaW5cbiAgYmxpdF90b19hcnJheSB+c3JjOnQgZHN0O1xuICB0LmZyb250IDwtIDA7XG4gIHQubWFzayA8LSBuZXdfY2FwYWNpdHkgLSAxO1xuICB0LmVsdHMgPC0gZHN0XG47O1xuXG5sZXQgc2V0X2NhcGFjaXR5IHQgZGVzaXJlZF9jYXBhY2l0eSA9XG4gICgqIFdlIGFsbG93IGFyZ3VtZW50cyBsZXNzIHRoYW4gMSB0byBbc2V0X2NhcGFjaXR5XSwgYnV0IHRyYW5zbGF0ZSB0aGVtIHRvIDEgdG8gc2ltcGxpZnlcbiAgICAgdGhlIGNvZGUgdGhhdCByZWxpZXMgb24gdGhlIGFycmF5IGxlbmd0aCBiZWluZyBhIHBvd2VyIG9mIDIuICopXG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGxldCBuZXdfY2FwYWNpdHkgPSBJbnQuY2VpbF9wb3cyIChtYXggMSAobWF4IGRlc2lyZWRfY2FwYWNpdHkgdC5sZW5ndGgpKSBpblxuICBpZiBuZXdfY2FwYWNpdHkgPD4gY2FwYWNpdHkgdCB0aGVuIHNldF9jYXBhY2l0eV9pbnRlcm5hbCB0IG5ld19jYXBhY2l0eVxuOztcblxubGV0IGVucXVldWUgdCBhID1cbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgaWYgdC5sZW5ndGggPSBjYXBhY2l0eSB0IHRoZW4gc2V0X2NhcGFjaXR5X2ludGVybmFsIHQgKDIgKiB0Lmxlbmd0aCk7XG4gIHVuc2FmZV9zZXQgdCB0Lmxlbmd0aCBhO1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDFcbjs7XG5cbmxldCBlbnF1ZXVlX2Zyb250IHQgYSA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGlmIHQubGVuZ3RoID0gY2FwYWNpdHkgdCB0aGVuIHNldF9jYXBhY2l0eV9pbnRlcm5hbCB0ICgyICogdC5sZW5ndGgpO1xuICBsZXQgZnJvbnQgPSAodC5mcm9udCAtIDEpIGxhbmQgdC5tYXNrIGluXG4gIHQuZnJvbnQgPC0gZnJvbnQ7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMTtcbiAgdW5zYWZlX3NldCB0IDAgYVxuOztcblxubGV0IGRlcXVldWVfbm9uZW1wdHkgdCA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGxldCBlbHRzID0gdC5lbHRzIGluXG4gIGxldCBmcm9udCA9IHQuZnJvbnQgaW5cbiAgbGV0IHJlcyA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gZWx0cyBmcm9udCBpblxuICBPcHRpb25fYXJyYXkuc2V0X25vbmUgZWx0cyBmcm9udDtcbiAgdC5mcm9udCA8LSBlbHRzX2luZGV4IHQgMTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICByZXNcbjs7XG5cbmxldCBiYWNrX2luZGV4IHQgPSBlbHRzX2luZGV4IHQgKHQubGVuZ3RoIC0gMSlcblxubGV0IGRlcXVldWVfYmFja19ub25lbXB0eSB0ID1cbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgbGV0IGVsdHMgPSB0LmVsdHMgaW5cbiAgbGV0IGJhY2sgPSBiYWNrX2luZGV4IHQgaW5cbiAgbGV0IHJlcyA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gZWx0cyBiYWNrIGluXG4gIE9wdGlvbl9hcnJheS5zZXRfbm9uZSBlbHRzIGJhY2s7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMTtcbiAgcmVzXG47O1xuXG5sZXQgZGVxdWV1ZV9leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZSBTdGRsaWIuUXVldWUuRW1wdHkgZWxzZSBkZXF1ZXVlX25vbmVtcHR5IHRcbmxldCBkZXF1ZXVlIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGRlcXVldWVfbm9uZW1wdHkgdClcbmxldCBkZXF1ZXVlX2FuZF9pZ25vcmVfZXhuICh0eXBlIGVsdCkgKHQgOiBlbHQgdCkgPSBpZ25vcmUgKGRlcXVldWVfZXhuIHQgOiBlbHQpXG5cbmxldCBkZXF1ZXVlX2JhY2tfZXhuIHQgPVxuICBpZiBpc19lbXB0eSB0IHRoZW4gcmFpc2UgU3RkbGliLlF1ZXVlLkVtcHR5IGVsc2UgZGVxdWV1ZV9iYWNrX25vbmVtcHR5IHRcbjs7XG5cbmxldCBkZXF1ZXVlX2JhY2sgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoZGVxdWV1ZV9iYWNrX25vbmVtcHR5IHQpXG5sZXQgZnJvbnRfbm9uZW1wdHkgdCA9IE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfZXhuIHQuZWx0cyB0LmZyb250XG5sZXQgYmFja19ub25lbXB0eSB0ID0gT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9leG4gdC5lbHRzIChiYWNrX2luZGV4IHQpXG5sZXQgbGFzdF9ub25lbXB0eSB0ID0gdW5zYWZlX2dldCB0ICh0Lmxlbmd0aCAtIDEpXG5sZXQgcGVlayB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChmcm9udF9ub25lbXB0eSB0KVxubGV0IHBlZWtfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gcmFpc2UgU3RkbGliLlF1ZXVlLkVtcHR5IGVsc2UgZnJvbnRfbm9uZW1wdHkgdFxubGV0IHBlZWtfYmFjayB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChiYWNrX25vbmVtcHR5IHQpXG5sZXQgcGVla19iYWNrX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlIFN0ZGxpYi5RdWV1ZS5FbXB0eSBlbHNlIGJhY2tfbm9uZW1wdHkgdFxubGV0IGxhc3QgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAobGFzdF9ub25lbXB0eSB0KVxubGV0IGxhc3RfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gcmFpc2UgU3RkbGliLlF1ZXVlLkVtcHR5IGVsc2UgbGFzdF9ub25lbXB0eSB0XG5cbmxldCBkcmFpbiB0IH5mIH53aGlsZV8gPVxuICB3aGlsZSAobm90IChpc19lbXB0eSB0KSkgJiYgd2hpbGVfIChmcm9udF9ub25lbXB0eSB0KSBkb1xuICAgIGYgKGRlcXVldWVfbm9uZW1wdHkgdClcbiAgZG9uZVxuOztcblxubGV0IGNsZWFyIHQgPVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBpZiB0Lmxlbmd0aCA+IDBcbiAgdGhlbiAoXG4gICAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgICAgdW5zYWZlX3Vuc2V0IHQgaVxuICAgIGRvbmU7XG4gICAgdC5sZW5ndGggPC0gMDtcbiAgICB0LmZyb250IDwtIDApXG47O1xuXG5sZXQgYmxpdF90cmFuc2ZlciB+c3JjIH5kc3QgP2xlbiAoKSA9XG4gIGluY19udW1fbXV0YXRpb25zIHNyYztcbiAgaW5jX251bV9tdXRhdGlvbnMgZHN0O1xuICBsZXQgbGVuID1cbiAgICBtYXRjaCBsZW4gd2l0aFxuICAgIHwgTm9uZSAtPiBzcmMubGVuZ3RoXG4gICAgfCBTb21lIGxlbiAtPlxuICAgICAgaWYgbGVuIDwgMFxuICAgICAgdGhlblxuICAgICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgIFwiUXVldWUuYmxpdF90cmFuc2ZlcjogbmVnYXRpdmUgbGVuZ3RoXCJcbiAgICAgICAgICAgICBbIFwibGVuZ3RoXCIsIGxlbiB8PiBJbnQuc2V4cF9vZl90IF0pO1xuICAgICAgbWluIGxlbiBzcmMubGVuZ3RoXG4gIGluXG4gIGlmIGxlbiA+IDBcbiAgdGhlbiAoXG4gICAgc2V0X2NhcGFjaXR5IGRzdCAobWF4IChjYXBhY2l0eSBkc3QpIChkc3QubGVuZ3RoICsgbGVuKSk7XG4gICAgbGV0IGRzdF9zdGFydCA9IGRzdC5mcm9udCArIGRzdC5sZW5ndGggaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgKCogVGhpcyBpcyBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIHNpbXBseSBbZW5xdWV1ZSBkc3QgKGRlcXVldWVfbm9uZW1wdHkgc3JjKV0gKilcbiAgICAgIGxldCBzcmNfaSA9IChzcmMuZnJvbnQgKyBpKSBsYW5kIHNyYy5tYXNrIGluXG4gICAgICBsZXQgZHN0X2kgPSAoZHN0X3N0YXJ0ICsgaSkgbGFuZCBkc3QubWFzayBpblxuICAgICAgT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZVxuICAgICAgICBkc3QuZWx0c1xuICAgICAgICBkc3RfaVxuICAgICAgICAoT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9leG4gc3JjLmVsdHMgc3JjX2kpO1xuICAgICAgT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfbm9uZSBzcmMuZWx0cyBzcmNfaVxuICAgIGRvbmU7XG4gICAgZHN0Lmxlbmd0aCA8LSBkc3QubGVuZ3RoICsgbGVuO1xuICAgIHNyYy5mcm9udCA8LSAoc3JjLmZyb250ICsgbGVuKSBsYW5kIHNyYy5tYXNrO1xuICAgIHNyYy5sZW5ndGggPC0gc3JjLmxlbmd0aCAtIGxlbilcbjs7XG5cbmxldCBlbnF1ZXVlX2FsbCB0IGwgPVxuICAoKiBUcmF2ZXJzaW5nIHRoZSBsaXN0IHVwIGZyb250IHRvIGNvbXB1dGUgaXRzIGxlbmd0aCBpcyBwcm9iYWJseSAoYnV0IG5vdCBkZWZpbml0ZWx5KVxuICAgICBiZXR0ZXIgdGhhbiBkb3VibGluZyB0aGUgdW5kZXJseWluZyBhcnJheSBzaXplIHNldmVyYWwgdGltZXMgZm9yIGxhcmdlIHF1ZXVlcy4gKilcbiAgc2V0X2NhcGFjaXR5IHQgKEludC5tYXggKGNhcGFjaXR5IHQpICh0Lmxlbmd0aCArIExpc3QubGVuZ3RoIGwpKTtcbiAgTGlzdC5pdGVyIGwgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KVxuOztcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGlmIHQubGVuZ3RoID0gMFxuICB0aGVuIGluaXRcbiAgZWxzZSAoXG4gICAgbGV0IG51bV9tdXRhdGlvbnMgPSB0Lm51bV9tdXRhdGlvbnMgaW5cbiAgICBsZXQgciA9IHJlZiBpbml0IGluXG4gICAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgICBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zXG4gICAgZG9uZTtcbiAgICAhcilcbjs7XG5cbmxldCBmb2xkaSB0IH5pbml0IH5mID1cbiAgbGV0IGkgPSByZWYgMCBpblxuICBmb2xkIHQgfmluaXQgfmY6KGZ1biBhY2MgYSAtPlxuICAgIGxldCBhY2MgPSBmICFpIGFjYyBhIGluXG4gICAgaSA6PSAhaSArIDE7XG4gICAgYWNjKSBbQG5vbnRhaWxdXG47O1xuXG4oKiBbaXRlcl0gaXMgaW1wbGVtZW50ZWQgZGlyZWN0bHkgYmVjYXVzZSBpbXBsZW1lbnRpbmcgaXQgaW4gdGVybXMgb2YgW2ZvbGRdIGlzXG4gICBzbG93ZXIuICopXG5sZXQgaXRlciB0IH5mID1cbiAgbGV0IG51bV9tdXRhdGlvbnMgPSB0Lm51bV9tdXRhdGlvbnMgaW5cbiAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgIGYgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyaSB0IH5mID1cbiAgbGV0IG51bV9tdXRhdGlvbnMgPSB0Lm51bV9tdXRhdGlvbnMgaW5cbiAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgIGYgaSAodW5zYWZlX2dldCB0IGkpO1xuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnNcbiAgZG9uZVxuOztcblxubGV0IHRvX2xpc3QgdCA9XG4gIGxldCByZXN1bHQgPSByZWYgW10gaW5cbiAgZm9yIGkgPSB0Lmxlbmd0aCAtIDEgZG93bnRvIDAgZG9cbiAgICByZXN1bHQgOj0gdW5zYWZlX2dldCB0IGkgOjogIXJlc3VsdFxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5tb2R1bGUgQyA9IEluZGV4ZWRfY29udGFpbmVyLk1ha2UgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBmb2xkID0gZm9sZFxuICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbiAgbGV0IGZvbGRpID0gYEN1c3RvbSBmb2xkaVxuICBsZXQgaXRlcmkgPSBgQ3VzdG9tIGl0ZXJpXG5lbmQpXG5cbmxldCBjb3VudCA9IEMuY291bnRcbmxldCBleGlzdHMgPSBDLmV4aXN0c1xubGV0IGZpbmQgPSBDLmZpbmRcbmxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbmxldCBmb2xkX3Jlc3VsdCA9IEMuZm9sZF9yZXN1bHRcbmxldCBmb2xkX3VudGlsID0gQy5mb2xkX3VudGlsXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbmxldCBtZW0gPSBDLm1lbVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBzdW0gPSBDLnN1bVxubGV0IGNvdW50aSA9IEMuY291bnRpXG5sZXQgZXhpc3RzaSA9IEMuZXhpc3RzaVxubGV0IGZpbmRfbWFwaSA9IEMuZmluZF9tYXBpXG5sZXQgZmluZGkgPSBDLmZpbmRpXG5sZXQgZm9yX2FsbGkgPSBDLmZvcl9hbGxpXG5cbigqIEZvciBbY29uY2F0X21hcF0sIFtmaWx0ZXJfbWFwXSwgYW5kIFtmaWx0ZXJdLCB3ZSBkb24ndCBjcmVhdGUgW3RfcmVzdWx0XSB3aXRoIFt0XSdzXG4gICBjYXBhY2l0eSBiZWNhdXNlIHdlIGhhdmUgbm8gaWRlYSBob3cgbWFueSBlbGVtZW50cyBbdF9yZXN1bHRdIHdpbGwgdWx0aW1hdGVseSBob2xkLiAqKVxubGV0IGNvbmNhdF9tYXAgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IExpc3QuaXRlciAoZiBhKSB+ZjooZnVuIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgY29uY2F0X21hcGkgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IExpc3QuaXRlciAoZiBpIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPlxuICAgIG1hdGNoIGYgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT5cbiAgICBtYXRjaCBmIGkgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IGlmIGYgYSB0aGVuIGVucXVldWUgdF9yZXN1bHQgYSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gaWYgZiBpIGEgdGhlbiBlbnF1ZXVlIHRfcmVzdWx0IGEpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcl9pbnBsYWNlIHQgfmYgPVxuICBsZXQgdDIgPSBmaWx0ZXIgdCB+ZiBpblxuICBjbGVhciB0O1xuICBibGl0X3RyYW5zZmVyIH5zcmM6dDIgfmRzdDp0ICgpXG47O1xuXG5sZXQgZmlsdGVyaV9pbnBsYWNlIHQgfmYgPVxuICBsZXQgdDIgPSBmaWx0ZXJpIHQgfmYgaW5cbiAgY2xlYXIgdDtcbiAgYmxpdF90cmFuc2ZlciB+c3JjOnQyIH5kc3Q6dCAoKVxuOztcblxubGV0IGNvcHkgc3JjID1cbiAgbGV0IGRzdCA9IGNyZWF0ZSB+Y2FwYWNpdHk6c3JjLmxlbmd0aCAoKSBpblxuICBibGl0X3RvX2FycmF5IH5zcmMgZHN0LmVsdHM7XG4gIGRzdC5sZW5ndGggPC0gc3JjLmxlbmd0aDtcbiAgZHN0XG47O1xuXG5sZXQgb2ZfbGlzdCBsID1cbiAgKCogVHJhdmVyc2luZyB0aGUgbGlzdCB1cCBmcm9udCB0byBjb21wdXRlIGl0cyBsZW5ndGggaXMgcHJvYmFibHkgKGJ1dCBub3QgZGVmaW5pdGVseSlcbiAgICAgYmV0dGVyIHRoYW4gZG91YmxpbmcgdGhlIHVuZGVybHlpbmcgYXJyYXkgc2l6ZSBzZXZlcmFsIHRpbWVzIGZvciBsYXJnZSBxdWV1ZXMuICopXG4gIGxldCB0ID0gY3JlYXRlIH5jYXBhY2l0eTooTGlzdC5sZW5ndGggbCkgKCkgaW5cbiAgTGlzdC5pdGVyIGwgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KTtcbiAgdFxuOztcblxuKCogVGhlIHF1ZXVlIFt0XSByZXR1cm5lZCBieSBbY3JlYXRlXSB3aWxsIGhhdmUgW3QubGVuZ3RoID0gMF0sIFt0LmZyb250ID0gMF0sIGFuZFxuICAgW2NhcGFjaXR5IHQgPSBJbnQuY2VpbF9wb3cyIGxlbl0uICBTbywgd2Ugb25seSBoYXZlIHRvIHNldCBbdC5sZW5ndGhdIHRvIFtsZW5dIGFmdGVyXG4gICB0aGUgYmxpdCB0byBtYWludGFpbiBhbGwgdGhlIGludmFyaWFudHM6IFt0Lmxlbmd0aF0gaXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBlbGVtZW50c1xuICAgaW4gdGhlIHF1ZXVlLCBbdC5mcm9udF0gaXMgdGhlIGFycmF5IGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBxdWV1ZSwgYW5kXG4gICBbY2FwYWNpdHkgdCA9IE9wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzXS4gKilcbmxldCBpbml0IGxlbiB+ZiA9XG4gIGlmIGxlbiA8IDBcbiAgdGhlblxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2UgXCJRdWV1ZS5pbml0OiBuZWdhdGl2ZSBsZW5ndGhcIiBbIFwibGVuZ3RoXCIsIGxlbiB8PiBJbnQuc2V4cF9vZl90IF0pO1xuICBsZXQgdCA9IGNyZWF0ZSB+Y2FwYWNpdHk6bGVuICgpIGluXG4gIGFzc2VydCAoT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHMgPj0gbGVuKTtcbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHQuZWx0cyBpIChmIGkpXG4gIGRvbmU7XG4gIHQubGVuZ3RoIDwtIGxlbjtcbiAgdFxuOztcblxubGV0IG9mX2FycmF5IGEgPSBpbml0IChBcnJheS5sZW5ndGggYSkgfmY6KEFycmF5LnVuc2FmZV9nZXQgYSlcbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCB0Lmxlbmd0aCB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5cbmxldCBtYXAgdGEgfmYgPVxuICBsZXQgbnVtX211dGF0aW9ucyA9IHRhLm51bV9tdXRhdGlvbnMgaW5cbiAgbGV0IHRiID0gY3JlYXRlIH5jYXBhY2l0eTp0YS5sZW5ndGggKCkgaW5cbiAgdGIubGVuZ3RoIDwtIHRhLmxlbmd0aDtcbiAgZm9yIGkgPSAwIHRvIHRhLmxlbmd0aCAtIDEgZG9cbiAgICBsZXQgYiA9IGYgKHVuc2FmZV9nZXQgdGEgaSkgaW5cbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdGEgbnVtX211dGF0aW9ucztcbiAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHRiLmVsdHMgaSBiXG4gIGRvbmU7XG4gIHRiXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbGV0IGkgPSByZWYgMCBpblxuICBtYXAgdCB+ZjooZnVuIGEgLT5cbiAgICBsZXQgcmVzdWx0ID0gZiAhaSBhIGluXG4gICAgaSA6PSAhaSArIDE7XG4gICAgcmVzdWx0KSBbQG5vbnRhaWxdXG47O1xuXG5sZXQgc2luZ2xldG9uIHggPVxuICBsZXQgdCA9IGNyZWF0ZSB+Y2FwYWNpdHk6MSAoKSBpblxuICBlbnF1ZXVlIHQgeDtcbiAgdFxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IHRvX2xpc3QgdCB8PiBMaXN0LnNleHBfb2ZfdCBzZXhwX29mX2FcbmxldCB0X29mX3NleHAgYV9vZl9zZXhwIHNleHAgPSBMaXN0LnRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCB8PiBvZl9saXN0XG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoZ3JhbW1hciA6IGEgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuOztcblxubW9kdWxlIEl0ZXJhdGlvbiA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgc3RhcnQgcSA9IHEubnVtX211dGF0aW9uc1xuICBsZXQgYXNzZXJ0X25vX211dGF0aW9uX3NpbmNlX3N0YXJ0IHQgcSA9IGVuc3VyZV9ub19tdXRhdGlvbiBxIHRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IHxcblxuICBsZXQgdW5yZWFjaGFibGVfY29kZV9sb2NhbCA9IGZ1bmN0aW9uXG4gICAgfCAoXyA6IHQpIC0+IC5cbiAgOztcblxuICBsZXQgdW5yZWFjaGFibGVfY29kZSB4ID0gdW5yZWFjaGFibGVfY29kZV9sb2NhbCB4XG4gIGxldCBhbGwgPSBbXVxuICBsZXQgaGFzaF9mb2xkX3QgXyB0ID0gdW5yZWFjaGFibGVfY29kZSB0XG4gIGxldCBoYXNoID0gdW5yZWFjaGFibGVfY29kZVxuICBsZXQgY29tcGFyZSBhIF8gPSB1bnJlYWNoYWJsZV9jb2RlIGFcbiAgbGV0IGNvbXBhcmVfX2xvY2FsIGEgXyA9IHVucmVhY2hhYmxlX2NvZGUgYVxuICBsZXQgZXF1YWxfX2xvY2FsIGEgXyA9IHVucmVhY2hhYmxlX2NvZGUgYVxuICBsZXQgc2V4cF9vZl90ID0gdW5yZWFjaGFibGVfY29kZVxuICBsZXQgdF9vZl9zZXhwIHNleHAgPSBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfdHlwZSBcIkJhc2UuTm90aGluZy50XCIgc2V4cFxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSB7IHVudHlwZWQgPSBVbmlvbiBbXSB9XG4gIGxldCB0b19zdHJpbmcgPSB1bnJlYWNoYWJsZV9jb2RlXG4gIGxldCBvZl9zdHJpbmcgKF8gOiBzdHJpbmcpID0gZmFpbHdpdGggXCJCYXNlLk5vdGhpbmcub2Zfc3RyaW5nOiBub3Qgc3VwcG9ydGVkXCJcbiAgbGV0IGdsb2JhbGl6ZSA9IHVucmVhY2hhYmxlX2NvZGVcbmVuZFxuXG5pbmNsdWRlIFRcblxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoc3RydWN0XG4gIGluY2x1ZGUgVFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5Ob3RoaW5nXCJcbmVuZClcblxubGV0IG11c3RfYmVfbm9uZSA6IHQgb3B0aW9uIC0+IHVuaXQgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIF8gLT4gLlxuOztcblxubGV0IG11c3RfYmVfZW1wdHkgOiB0IGxpc3QgLT4gdW5pdCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKClcbiAgfCBfIDo6IF8gLT4gLlxuOztcblxubGV0IG11c3RfYmVfb2sgOiAoJ29rLCB0KSBSZXN1bHQudCAtPiAnb2sgPSBmdW5jdGlvblxuICB8IE9rIG9rIC0+IG9rXG4gIHwgRXJyb3IgXyAtPiAuXG47O1xuXG5sZXQgbXVzdF9iZV9lcnJvciA6ICh0LCAnZXJyKSBSZXN1bHQudCAtPiAnZXJyID0gZnVuY3Rpb25cbiAgfCBPayBfIC0+IC5cbiAgfCBFcnJvciBlcnJvciAtPiBlcnJvclxuOztcblxubGV0IG11c3RfYmVfZmlyc3QgOiAoJ2ZpcnN0LCB0KSBFaXRoZXIudCAtPiAnZmlyc3QgPSBmdW5jdGlvblxuICB8IEZpcnN0IGZpcnN0IC0+IGZpcnN0XG4gIHwgU2Vjb25kIF8gLT4gLlxuOztcblxubGV0IG11c3RfYmVfc2Vjb25kIDogKHQsICdzZWNvbmQpIEVpdGhlci50IC0+ICdzZWNvbmQgPSBmdW5jdGlvblxuICB8IEZpcnN0IF8gLT4gLlxuICB8IFNlY29uZCBzZWNvbmQgLT4gc2Vjb25kXG47O1xuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBTdGRsaWIuTmF0aXZlaW50XG5pbmNsdWRlIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gbmF0aXZlaW50IFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGdsb2JhbGl6ZSA6IHQgLT4gdCkgPSAoZ2xvYmFsaXplX25hdGl2ZWludCA6IHQgLT4gdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX25hdGl2ZWludFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfbmF0aXZlaW50IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChuYXRpdmVpbnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfbmF0aXZlaW50IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IG5hdGl2ZWludF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmVcbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG4gIGxldCBvZl9zdHJpbmdfb3B0ID0gb2Zfc3RyaW5nX29wdFxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcbmluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9ucy5NYWtlIChUKVxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZV9oZXggKHN0cnVjdFxuICBvcGVuIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICB0eXBlIHQgPSBuYXRpdmVpbnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBoYXNoXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA9IChjb21wYXJlX25hdGl2ZWludF9fbG9jYWwgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgY29tcGFyZSA9IChmdW4gYSBiIC0+IGNvbXBhcmVfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9uYXRpdmVpbnRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX25hdGl2ZWludCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0ICggPCApID0gKCA8IClcbiAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIlbnhcIiBpXG4gIGxldCBvZl9zdHJpbmcgcyA9IFN0ZGxpYi5TY2FuZi5zc2NhbmYgcyBcIiVueFwiIEZuLmlkXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5OYXRpdmVpbnQuSGV4XCJcbmVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuTmF0aXZlaW50XCJcbmVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IG51bV9iaXRzID0gV29yZF9zaXplLm51bV9iaXRzIFdvcmRfc2l6ZS53b3JkX3NpemVcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5sZXQgc2hpZnRfcmlnaHQgPSBzaGlmdF9yaWdodFxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0XG5sZXQgYml0X25vdCA9IGxvZ25vdFxubGV0IGJpdF94b3IgPSBsb2d4b3JcbmxldCBiaXRfb3IgPSBsb2dvclxubGV0IGJpdF9hbmQgPSBsb2dhbmRcbmxldCBtaW5fdmFsdWUgPSBtaW5faW50XG5sZXQgbWF4X3ZhbHVlID0gbWF4X2ludFxubGV0IGFicyA9IGFic1xubGV0IHByZWQgPSBwcmVkXG5sZXQgc3VjYyA9IHN1Y2NcbmxldCByZW0gPSByZW1cbmxldCBuZWcgPSBuZWdcbmxldCBtaW51c19vbmUgPSBtaW51c19vbmVcbmxldCBvbmUgPSBvbmVcbmxldCB6ZXJvID0gemVyb1xubGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBvZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAgICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBvZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIk5hdGl2ZWludC5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG4gIG9wZW4gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuICBsZXQgKCBsb3IgKSA9IFN0ZGxpYi5OYXRpdmVpbnQubG9nb3JcbiAgbGV0ICggbHNyICkgPSBTdGRsaWIuTmF0aXZlaW50LnNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbiAgbGV0ICggbGFuZCApID0gU3RkbGliLk5hdGl2ZWludC5sb2dhbmRcblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgKHggOiBuYXRpdmVpbnQpID1cbiAgICBpZiB4IDw9IDBuIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0gU3RkbGliLk5hdGl2ZWludC5wcmVkIHggaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgICgqIFRoZSBuZXh0IGxpbmUgaXMgc3VwZXJmbHVvdXMgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIGZhc3RlciB0byBkbyBpdFxuICAgICAgIGFueXdheSB0aGFuIHRvIGJyYW5jaCAqKVxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIFN0ZGxpYi5OYXRpdmVpbnQuc3VjYyB4XG4gIDs7XG5cbiAgKCoqIFwiZmxvb3IgcG93ZXIgb2YgMlwiIC0gTGFyZ2VzdCBwb3dlciBvZiAyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgZmxvb3JfcG93MiB4ID1cbiAgICBpZiB4IDw9IDBuIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgU3RkbGliLk5hdGl2ZWludC5zdWIgeCAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IDBuIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIHggbGFuZCBTdGRsaWIuTmF0aXZlaW50LnByZWQgeCA9IDBuXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgbmF0aXZlaW50IGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogIChuYXRpdmVpbnRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6XCIgXCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHpfdW5ib3hlZFwiXG4gICAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAobmF0aXZlaW50W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0elwiIFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY3R6X3VuYm94ZWRcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBQb2x5LiggPD0gKSBpIFN0ZGxpYi5OYXRpdmVpbnQuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIltOYXRpdmVpbnQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIlxuICAgICAgICAgICBbIFwiXCIsIHNleHBfb2ZfbmF0aXZlaW50IGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBjZWlsX2xvZzIgaSA9XG4gICAgaWYgUG9seS4oIDw9ICkgaSBTdGRsaWIuTmF0aXZlaW50Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJbTmF0aXZlaW50LmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIlxuICAgICAgICAgICBbIFwiXCIsIHNleHBfb2ZfbmF0aXZlaW50IGkgXSk7XG4gICAgaWYgU3RkbGliLk5hdGl2ZWludC5lcXVhbCBpIFN0ZGxpYi5OYXRpdmVpbnQub25lXG4gICAgdGhlbiAwXG4gICAgZWxzZSBudW1fYml0cyAtIGNseiAoU3RkbGliLk5hdGl2ZWludC5wcmVkIGkpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5cbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW46bWluXyB+bWF4Om1heF8gPSBtaW4gdCBtYXhfIHw+IG1heCBtaW5fXG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgKCAvICkgPSBkaXZcbmxldCAoICogKSA9IG11bFxubGV0ICggLSApID0gc3ViXG5sZXQgKCArICkgPSBhZGRcbmxldCAoIH4tICkgPSBuZWdcbmxldCBpbmNyIHIgPSByIDo9ICFyICsgb25lXG5sZXQgZGVjciByID0gciA6PSAhciAtIG9uZVxubGV0IG9mX25hdGl2ZWludCB0ID0gdFxubGV0IG9mX25hdGl2ZWludF9leG4gPSBvZl9uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnQgdCA9IHRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gdG9fbmF0aXZlaW50XG5sZXQgcG9wY291bnQgPSBQb3Bjb3VudC5uYXRpdmVpbnRfcG9wY291bnRcbmxldCBvZl9pbnQgPSBDb252LmludF90b19uYXRpdmVpbnRcbmxldCBvZl9pbnRfZXhuID0gb2ZfaW50XG5sZXQgdG9faW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50XG5sZXQgdG9faW50X2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludF9leG5cbmxldCB0b19pbnRfdHJ1bmMgPSBDb252Lm5hdGl2ZWludF90b19pbnRfdHJ1bmNcbmxldCBvZl9pbnQzMiA9IENvbnYuaW50MzJfdG9fbmF0aXZlaW50XG5sZXQgb2ZfaW50MzJfZXhuID0gb2ZfaW50MzJcbmxldCB0b19pbnQzMiA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyXG5sZXQgdG9faW50MzJfZXhuID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJfZXhuXG5cbmV4dGVybmFsIHRvX2ludDMyX3RydW5jXG4gIDogIChuYXRpdmVpbnRbQGxvY2FsX29wdF0pXG4gIC0+IChpbnQzMltAbG9jYWxfb3B0XSlcbiAgPSBcIiVuYXRpdmVpbnRfdG9faW50MzJcIlxuXG5sZXQgb2ZfaW50NjQgPSBDb252LmludDY0X3RvX25hdGl2ZWludFxubGV0IG9mX2ludDY0X2V4biA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X2V4blxubGV0IG9mX2ludDY0X3RydW5jID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmNcbmxldCB0b19pbnQ2NCA9IENvbnYubmF0aXZlaW50X3RvX2ludDY0XG5sZXQgcG93IGIgZSA9IG9mX2ludF9leG4gKEludF9tYXRoLlByaXZhdGUuaW50X3BvdyAodG9faW50X2V4biBiKSAodG9faW50X2V4biBlKSlcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZV9iaW5hcnkgKHN0cnVjdFxuICB0eXBlIHQgPSBuYXRpdmVpbnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGhhc2hdXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKGNvbXBhcmVfbmF0aXZlaW50X19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGVxdWFsX19sb2NhbCA9IChlcXVhbF9uYXRpdmVpbnRfX2xvY2FsIDogdCAtPiB0IC0+IGJvb2wpXG4gIGxldCBlcXVhbCA9IChmdW4gYSBiIC0+IGVxdWFsX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX25hdGl2ZWludFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfbmF0aXZlaW50IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgKCBsYW5kICkgPSAoIGxhbmQgKVxuICBsZXQgKCBsc3IgKSA9ICggbHNyIClcbiAgbGV0IGNseiA9IGNselxuICBsZXQgbnVtX2JpdHMgPSBudW1fYml0c1xuICBsZXQgb25lID0gb25lXG4gIGxldCB0b19pbnRfZXhuID0gdG9faW50X2V4blxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGluY2x1ZGUgUHJlX09cblxuICAgIGxldCByZW0gPSByZW1cbiAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgIGxldCBvZl9mbG9hdCA9IG9mX2Zsb2F0XG4gICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gIGVuZClcblxuICBsZXQgKCBsYW5kICkgPSBiaXRfYW5kXG4gIGxldCAoIGxvciApID0gYml0X29yXG4gIGxldCAoIGx4b3IgKSA9IGJpdF94b3JcbiAgbGV0IGxub3QgPSBiaXRfbm90XG4gIGxldCAoIGxzbCApID0gc2hpZnRfbGVmdFxuICBsZXQgKCBhc3IgKSA9IHNoaWZ0X3JpZ2h0XG4gIGxldCAoIGxzciApID0gc2hpZnRfcmlnaHRfbG9naWNhbFxuZW5kXG5cbmluY2x1ZGUgT1xuXG4oKiBbTmF0aXZlaW50XSBhbmQgW05hdGl2ZWludC5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmV4dGVybmFsIGJzd2FwIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWJzd2FwX25hdGl2ZVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICopXG4oKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICopXG4oKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UuIFNlZSAuLi9USElSRC1QQVJUWS50eHQgICopXG4oKiAgZm9yIGRldGFpbHMuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4hIEltcG9ydFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBNYXBfaW50ZlxuXG5tb2R1bGUgRmluaXNoZWRfb3JfdW5maW5pc2hlZCA9IHN0cnVjdFxuICBpbmNsdWRlIE1hcF9pbnRmLkZpbmlzaGVkX29yX3VuZmluaXNoZWRcblxuICAoKiBUaGVzZSB0d28gZnVuY3Rpb25zIGFyZSB0ZXN0ZWQgaW4gW3Rlc3RfbWFwLm1sXSB0byBtYWtlIHN1cmUgb3VyIHVzZSBvZlxuICAgICBbU3RkbGliLk9iai5tYWdpY10gaXMgY29ycmVjdCBhbmQgc2FmZS4gKilcbiAgbGV0IG9mX2NvbnRpbnVlX29yX3N0b3AgOiBDb250aW51ZV9vcl9zdG9wLnQgLT4gdCA9IFN0ZGxpYi5PYmoubWFnaWNcbiAgbGV0IHRvX2NvbnRpbnVlX29yX3N0b3AgOiB0IC0+IENvbnRpbnVlX29yX3N0b3AudCA9IFN0ZGxpYi5PYmoubWFnaWNcbmVuZFxuXG5tb2R1bGUgTWVyZ2VfZWxlbWVudCA9IHN0cnVjdFxuICBpbmNsdWRlIE1hcF9pbnRmLk1lcmdlX2VsZW1lbnRcblxuICBsZXQgbGVmdCA9IGZ1bmN0aW9uXG4gICAgfCBgUmlnaHQgXyAtPiBOb25lXG4gICAgfCBgTGVmdCBsZWZ0IHwgYEJvdGggKGxlZnQsIF8pIC0+IFNvbWUgbGVmdFxuICA7O1xuXG4gIGxldCByaWdodCA9IGZ1bmN0aW9uXG4gICAgfCBgTGVmdCBfIC0+IE5vbmVcbiAgICB8IGBSaWdodCByaWdodCB8IGBCb3RoIChfLCByaWdodCkgLT4gU29tZSByaWdodFxuICA7O1xuXG4gIGxldCBsZWZ0X3ZhbHVlIHQgfmRlZmF1bHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgYFJpZ2h0IF8gLT4gZGVmYXVsdFxuICAgIHwgYExlZnQgbGVmdCB8IGBCb3RoIChsZWZ0LCBfKSAtPiBsZWZ0XG4gIDs7XG5cbiAgbGV0IHJpZ2h0X3ZhbHVlIHQgfmRlZmF1bHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgYExlZnQgXyAtPiBkZWZhdWx0XG4gICAgfCBgUmlnaHQgcmlnaHQgfCBgQm90aCAoXywgcmlnaHQpIC0+IHJpZ2h0XG4gIDs7XG5cbiAgbGV0IHZhbHVlcyB0IH5sZWZ0X2RlZmF1bHQgfnJpZ2h0X2RlZmF1bHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgYExlZnQgbGVmdCAtPiBsZWZ0LCByaWdodF9kZWZhdWx0XG4gICAgfCBgUmlnaHQgcmlnaHQgLT4gbGVmdF9kZWZhdWx0LCByaWdodFxuICAgIHwgYEJvdGggKGxlZnQsIHJpZ2h0KSAtPiBsZWZ0LCByaWdodFxuICA7O1xuZW5kXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cbmV4Y2VwdGlvbiBEdXBsaWNhdGUgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBEdXBsaWNhdGVdIChmdW5jdGlvblxuICAgIHwgRHVwbGljYXRlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIm1hcC5tbC5EdXBsaWNhdGVcIlxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG4oKiBbV2l0aF9sZW5ndGgudF0gYWxsb3dzIHVzIHRvIHN0b3JlIGxlbmd0aCBpbmZvcm1hdGlvbiBvbiB0aGUgc3RhY2sgd2hpbGVcbiAgIGtlZXBpbmcgdGhlIHRyZWUgZ2xvYmFsLiBUaGlzIHNhdmVzIHVwIHRvIE8obG9nIG4pIGJsb2NrcyBvZiBoZWFwIGFsbG9jYXRpb24uICopXG5tb2R1bGUgV2l0aF9sZW5ndGggOiBzaWdcbiAgdHlwZSAnYSB0ID0gcHJpdmF0ZVxuICAgIHsgdHJlZSA6ICdhXG4gICAgOyBsZW5ndGggOiBpbnRcbiAgICB9XG5cbiAgdmFsIHdpdGhfbGVuZ3RoIDogJ2EgLT4gaW50IC0+ICdhIHRcbiAgdmFsIHdpdGhfbGVuZ3RoX2dsb2JhbCA6ICdhIC0+IGludCAtPiAnYSB0XG4gIHZhbCBnbG9iYWxpemUgOiAnYSB0IC0+ICdhIHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgdHJlZSA6ICdhXG4gICAgOyBsZW5ndGggOiBpbnRcbiAgICB9XG5cbiAgbGV0IHdpdGhfbGVuZ3RoIHRyZWUgbGVuZ3RoID0geyB0cmVlOyBsZW5ndGggfVxuICBsZXQgd2l0aF9sZW5ndGhfZ2xvYmFsIHRyZWUgbGVuZ3RoID0geyB0cmVlOyBsZW5ndGggfVxuICBsZXQgZ2xvYmFsaXplIHsgdHJlZTsgbGVuZ3RoIH0gPSB7IHRyZWU7IGxlbmd0aCB9XG5lbmRcblxub3BlbiBXaXRoX2xlbmd0aFxuXG5tb2R1bGUgVHJlZTAgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssICd2KSB0ID1cbiAgICB8IEVtcHR5XG4gICAgfCBMZWFmIG9mXG4gICAgICAgIHsga2V5IDogJ2tcbiAgICAgICAgOyBkYXRhIDogJ3ZcbiAgICAgICAgfVxuICAgIHwgTm9kZSBvZlxuICAgICAgICB7IGxlZnQgOiAoJ2ssICd2KSB0XG4gICAgICAgIDsga2V5IDogJ2tcbiAgICAgICAgOyBkYXRhIDogJ3ZcbiAgICAgICAgOyByaWdodCA6ICgnaywgJ3YpIHRcbiAgICAgICAgOyBoZWlnaHQgOiBpbnRcbiAgICAgICAgfVxuXG4gIHR5cGUgKCdrLCAndikgdHJlZSA9ICgnaywgJ3YpIHRcblxuICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IDBcbiAgICB8IExlYWYgXyAtPiAxXG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IF87IGRhdGEgPSBfOyByaWdodCA9IF87IGhlaWdodCA9IGggfSAtPiBoXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudHMgPVxuICAgIGxldCBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2tleSBrID1cbiAgICAgIChtYXRjaCBsb3dlciB3aXRoXG4gICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICB8IFNvbWUgbG93ZXIgLT4gY29tcGFyZV9rZXkgbG93ZXIgayA8IDApXG4gICAgICAmJlxuICAgICAgbWF0Y2ggdXBwZXIgd2l0aFxuICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgIHwgU29tZSB1cHBlciAtPiBjb21wYXJlX2tleSBrIHVwcGVyIDwgMFxuICAgIGluXG4gICAgbGV0IHJlYyBsb29wIGxvd2VyIHVwcGVyIGNvbXBhcmVfa2V5IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTGVhZiB7IGtleSA9IGs7IGRhdGEgPSBfIH0gLT4gaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkga1xuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IGs7IGRhdGEgPSBfOyByaWdodCA9IHI7IGhlaWdodCA9IGggfSAtPlxuICAgICAgICBsZXQgaGwgPSBoZWlnaHQgbFxuICAgICAgICBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgICBhYnMgKGhsIC0gaHIpIDw9IDJcbiAgICAgICAgJiYgaCA9IG1heCBobCBociArIDFcbiAgICAgICAgJiYgaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkga1xuICAgICAgICAmJiBsb29wIGxvd2VyIChTb21lIGspIGNvbXBhcmVfa2V5IGxcbiAgICAgICAgJiYgbG9vcCAoU29tZSBrKSB1cHBlciBjb21wYXJlX2tleSByXG4gICAgaW5cbiAgICBmdW4gdCB+Y29tcGFyZV9rZXkgLT4gbG9vcCBOb25lIE5vbmUgY29tcGFyZV9rZXkgdFxuICA7O1xuXG4gICgqIHByZWNvbmRpdGlvbnM6IHxoZWlnaHQobCkgLSBoZWlnaHQocil8IDw9IDIsIGhsID0gaGVpZ2h0KGwpLCBociA9IGhlaWdodChyKSAqKVxuICBsZXRbQGlubGluZV0gY3JlYXRlX3dpdGhfaGVpZ2h0cyB+aGwgfmhyIGwgeCBkIHIgPVxuICAgIGlmIGhsID0gMCAmJiBociA9IDBcbiAgICB0aGVuIExlYWYgeyBrZXkgPSB4OyBkYXRhID0gZCB9XG4gICAgZWxzZVxuICAgICAgTm9kZVxuICAgICAgICB7IGxlZnQgPSBsXG4gICAgICAgIDsga2V5ID0geFxuICAgICAgICA7IGRhdGEgPSBkXG4gICAgICAgIDsgcmlnaHQgPSByXG4gICAgICAgIDsgaGVpZ2h0ID0gKGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKVxuICAgICAgICB9XG4gIDs7XG5cbiAgKCogcHJlY29uZGl0aW9uOiB8aGVpZ2h0KGwpIC0gaGVpZ2h0KHIpfCA8PSAyICopXG4gIGxldCBjcmVhdGUgbCB4IGQgciA9IGNyZWF0ZV93aXRoX2hlaWdodHMgfmhsOihoZWlnaHQgbCkgfmhyOihoZWlnaHQgcikgbCB4IGQgclxuICBsZXQgc2luZ2xldG9uIGtleSBkYXRhID0gTGVhZiB7IGtleTsgZGF0YSB9XG5cbiAgKCogV2UgbXVzdCBjYWxsIFtmXSB3aXRoIGluY3JlYXNpbmcgaW5kZXhlcywgYmVjYXVzZSB0aGUgYmluX3Byb3QgcmVhZGVyIGluXG4gICAgIENvcmUuTWFwIG5lZWRzIGl0LiAqKVxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgbGV0IHJlYyBsb29wIG4gfmYgaSA6IChfLCBfKSB0ID1cbiAgICAgIG1hdGNoIG4gd2l0aFxuICAgICAgfCAwIC0+IEVtcHR5XG4gICAgICB8IDEgLT5cbiAgICAgICAgbGV0IGssIHYgPSBmIGkgaW5cbiAgICAgICAgTGVhZiB7IGtleSA9IGs7IGRhdGEgPSB2IH1cbiAgICAgIHwgMiAtPlxuICAgICAgICBsZXQga2wsIHZsID0gZiBpIGluXG4gICAgICAgIGxldCBrLCB2ID0gZiAoaSArIDEpIGluXG4gICAgICAgIE5vZGVcbiAgICAgICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0ga2w7IGRhdGEgPSB2bCB9XG4gICAgICAgICAgOyBrZXkgPSBrXG4gICAgICAgICAgOyBkYXRhID0gdlxuICAgICAgICAgIDsgcmlnaHQgPSBFbXB0eVxuICAgICAgICAgIDsgaGVpZ2h0ID0gMlxuICAgICAgICAgIH1cbiAgICAgIHwgMyAtPlxuICAgICAgICBsZXQga2wsIHZsID0gZiBpIGluXG4gICAgICAgIGxldCBrLCB2ID0gZiAoaSArIDEpIGluXG4gICAgICAgIGxldCBrciwgdnIgPSBmIChpICsgMikgaW5cbiAgICAgICAgTm9kZVxuICAgICAgICAgIHsgbGVmdCA9IExlYWYgeyBrZXkgPSBrbDsgZGF0YSA9IHZsIH1cbiAgICAgICAgICA7IGtleSA9IGtcbiAgICAgICAgICA7IGRhdGEgPSB2XG4gICAgICAgICAgOyByaWdodCA9IExlYWYgeyBrZXkgPSBrcjsgZGF0YSA9IHZyIH1cbiAgICAgICAgICA7IGhlaWdodCA9IDJcbiAgICAgICAgICB9XG4gICAgICB8IG4gLT5cbiAgICAgICAgbGV0IGxlZnRfbGVuZ3RoID0gbiBsc3IgMSBpblxuICAgICAgICBsZXQgcmlnaHRfbGVuZ3RoID0gbiAtIGxlZnRfbGVuZ3RoIC0gMSBpblxuICAgICAgICBsZXQgbGVmdCA9IGxvb3AgbGVmdF9sZW5ndGggfmYgaSBpblxuICAgICAgICBsZXQgaywgdiA9IGYgKGkgKyBsZWZ0X2xlbmd0aCkgaW5cbiAgICAgICAgbGV0IHJpZ2h0ID0gbG9vcCByaWdodF9sZW5ndGggfmYgKGkgKyBsZWZ0X2xlbmd0aCArIDEpIGluXG4gICAgICAgIGNyZWF0ZSBsZWZ0IGsgdiByaWdodFxuICAgIGluXG4gICAgbG9vcCBsZW4gfmYgMFxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGFycmF5X2xlbmd0aCA9IEFycmF5Lmxlbmd0aCBhcnJheSBpblxuICAgIGxldCBuZXh0ID1cbiAgICAgIGlmIGFycmF5X2xlbmd0aCA8IDJcbiAgICAgICAgIHx8XG4gICAgICAgICBsZXQgazAsIF8gPSBhcnJheS4oMCkgaW5cbiAgICAgICAgIGxldCBrMSwgXyA9IGFycmF5LigxKSBpblxuICAgICAgICAgY29tcGFyZV9rZXkgazAgazEgPCAwXG4gICAgICB0aGVuIGZ1biBpIC0+IGFycmF5LihpKVxuICAgICAgZWxzZSBmdW4gaSAtPiBhcnJheS4oYXJyYXlfbGVuZ3RoIC0gMSAtIGkpXG4gICAgaW5cbiAgICB3aXRoX2xlbmd0aCAob2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbjphcnJheV9sZW5ndGggfmY6bmV4dCkgYXJyYXlfbGVuZ3RoXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIGFycmF5IHdpdGhcbiAgICB8IFt8fF0gfCBbfCBfIHxdIC0+XG4gICAgICBSZXN1bHQuT2sgKG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5IHw+IGdsb2JhbGl6ZSlcbiAgICB8IF8gLT5cbiAgICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgICBsZXQgaW5jcmVhc2luZyA9XG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9rZXkgKGZzdCBhcnJheS4oMCkpIChmc3QgYXJyYXkuKDEpKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT4gaSA8IDBcbiAgICAgICAgaW5cbiAgICAgICAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnJheSAtIDIgZG9cbiAgICAgICAgICBtYXRjaCBjb21wYXJlX2tleSAoZnN0IGFycmF5LihpKSkgKGZzdCBhcnJheS4oaSArIDEpKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT5cbiAgICAgICAgICAgIGlmIFBvbHkuKCA8PiApIChpIDwgMCkgaW5jcmVhc2luZ1xuICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBlbGVtZW50cyBhcmUgbm90IG9yZGVyZWRcIilcbiAgICAgICAgZG9uZTtcbiAgICAgICAgUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleSB8PiBnbG9iYWxpemUpKVxuICA7O1xuXG4gICgqIHByZWNvbmRpdGlvbjogfGhlaWdodChsKSAtIGhlaWdodChyKXwgPD0gMyAqKVxuICBsZXRbQGlubGluZV0gYmFsIGwgeCBkIHIgPVxuICAgIGxldCBobCA9IGhlaWdodCBsIGluXG4gICAgbGV0IGhyID0gaGVpZ2h0IHIgaW5cbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2UgKCogaGVpZ2h0KExlYWYpID0gMSAmJiAxIGlzIG5vdCBsYXJnZXIgdGhhbiBociArIDIgKilcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsbDsga2V5ID0gbHY7IGRhdGEgPSBsZDsgcmlnaHQgPSBscjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHJcbiAgICAgICAgdGhlbiBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICB8IExlYWYgeyBrZXkgPSBscnY7IGRhdGEgPSBscmQgfSAtPlxuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgRW1wdHkpIGxydiBscmQgKGNyZWF0ZSBFbXB0eSB4IGQgcilcbiAgICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbHJsOyBrZXkgPSBscnY7IGRhdGEgPSBscmQ7IHJpZ2h0ID0gbHJyOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxkIGxybCkgbHJ2IGxyZCAoY3JlYXRlIGxyciB4IGQgcikpKVxuICAgIGVsc2UgaWYgaHIgPiBobCArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGhlaWdodChMZWFmKSA9IDEgJiYgMSBpcyBub3QgbGFyZ2VyIHRoYW4gaGwgKyAyICopXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gcmw7IGtleSA9IHJ2OyBkYXRhID0gcmQ7IHJpZ2h0ID0gcnI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsXG4gICAgICAgIHRoZW4gY3JlYXRlIChjcmVhdGUgbCB4IGQgcmwpIHJ2IHJkIHJyXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgfCBMZWFmIHsga2V5ID0gcmx2OyBkYXRhID0gcmxkIH0gLT5cbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIEVtcHR5KSBybHYgcmxkIChjcmVhdGUgRW1wdHkgcnYgcmQgcnIpXG4gICAgICAgICAgfCBOb2RlIHsgbGVmdCA9IHJsbDsga2V5ID0gcmx2OyBkYXRhID0gcmxkOyByaWdodCA9IHJscjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybGwpIHJsdiBybGQgKGNyZWF0ZSBybHIgcnYgcmQgcnIpKSlcbiAgICBlbHNlIGNyZWF0ZV93aXRoX2hlaWdodHMgfmhsIH5ociBsIHggZCByXG4gIDs7XG5cbiAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgXyAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCByYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50IH5rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlIFwiW01hcC5hZGRfZXhuXSBnb3Qga2V5IGFscmVhZHkgcHJlc2VudFwiIFsgXCJrZXlcIiwga2V5IHw+IHNleHBfb2Zfa2V5IF0pXG4gIDs7XG5cbiAgbW9kdWxlIEFkZF9vcl9zZXQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgfCBBZGRfZXhuX2ludGVybmFsXG4gICAgICB8IEFkZF9leG5cbiAgICAgIHwgU2V0XG4gIGVuZFxuXG4gIGxldCByZWMgZmluZF9hbmRfYWRkX29yX3NldFxuICAgIHRcbiAgICB+bGVuZ3RoXG4gICAgfmtleTp4XG4gICAgfmRhdGFcbiAgICB+Y29tcGFyZV9rZXlcbiAgICB+c2V4cF9vZl9rZXlcbiAgICB+KGFkZF9vcl9zZXQgOiBBZGRfb3Jfc2V0LnQpXG4gICAgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gd2l0aF9sZW5ndGggKExlYWYgeyBrZXkgPSB4OyBkYXRhIH0pIChsZW5ndGggKyAxKVxuICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGFkZF9vcl9zZXQgd2l0aFxuICAgICAgICB8IEFkZF9leG5faW50ZXJuYWwgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIER1cGxpY2F0ZVxuICAgICAgICB8IEFkZF9leG4gLT4gcmFpc2Vfa2V5X2FscmVhZHlfcHJlc2VudCB+a2V5OnggfnNleHBfb2Zfa2V5XG4gICAgICAgIHwgU2V0IC0+IHdpdGhfbGVuZ3RoIChMZWFmIHsga2V5ID0geDsgZGF0YSB9KSBsZW5ndGgpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuXG4gICAgICAgIHdpdGhfbGVuZ3RoXG4gICAgICAgICAgKE5vZGVcbiAgICAgICAgICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0geDsgZGF0YSB9XG4gICAgICAgICAgICAgOyBrZXkgPSB2XG4gICAgICAgICAgICAgOyBkYXRhID0gZFxuICAgICAgICAgICAgIDsgcmlnaHQgPSBFbXB0eVxuICAgICAgICAgICAgIDsgaGVpZ2h0ID0gMlxuICAgICAgICAgICAgIH0pXG4gICAgICAgICAgKGxlbmd0aCArIDEpXG4gICAgICBlbHNlXG4gICAgICAgIHdpdGhfbGVuZ3RoXG4gICAgICAgICAgKE5vZGVcbiAgICAgICAgICAgICB7IGxlZnQgPSBFbXB0eVxuICAgICAgICAgICAgIDsga2V5ID0gdlxuICAgICAgICAgICAgIDsgZGF0YSA9IGRcbiAgICAgICAgICAgICA7IHJpZ2h0ID0gTGVhZiB7IGtleSA9IHg7IGRhdGEgfVxuICAgICAgICAgICAgIDsgaGVpZ2h0ID0gMlxuICAgICAgICAgICAgIH0pXG4gICAgICAgICAgKGxlbmd0aCArIDEpXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IGggfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggYWRkX29yX3NldCB3aXRoXG4gICAgICAgIHwgQWRkX2V4bl9pbnRlcm5hbCAtPiBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgRHVwbGljYXRlXG4gICAgICAgIHwgQWRkX2V4biAtPiByYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50IH5rZXk6eCB+c2V4cF9vZl9rZXlcbiAgICAgICAgfCBTZXQgLT5cbiAgICAgICAgICB3aXRoX2xlbmd0aCAoTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB4OyBkYXRhOyByaWdodCA9IHI7IGhlaWdodCA9IGggfSkgbGVuZ3RoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBsLCByLCBsZW5ndGggPVxuICAgICAgICAgIGlmIGMgPCAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgeyB0cmVlID0gbDsgbGVuZ3RoIH0gPVxuICAgICAgICAgICAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0XG4gICAgICAgICAgICAgICAgfmxlbmd0aFxuICAgICAgICAgICAgICAgIH5rZXk6eFxuICAgICAgICAgICAgICAgIH5kYXRhXG4gICAgICAgICAgICAgICAgbFxuICAgICAgICAgICAgICAgIH5jb21wYXJlX2tleVxuICAgICAgICAgICAgICAgIH5zZXhwX29mX2tleVxuICAgICAgICAgICAgICAgIH5hZGRfb3Jfc2V0XG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbCwgciwgbGVuZ3RoKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IHsgdHJlZSA9IHI7IGxlbmd0aCB9ID1cbiAgICAgICAgICAgICAgZmluZF9hbmRfYWRkX29yX3NldFxuICAgICAgICAgICAgICAgIH5sZW5ndGhcbiAgICAgICAgICAgICAgICB+a2V5OnhcbiAgICAgICAgICAgICAgICB+ZGF0YVxuICAgICAgICAgICAgICAgIHJcbiAgICAgICAgICAgICAgICB+Y29tcGFyZV9rZXlcbiAgICAgICAgICAgICAgICB+c2V4cF9vZl9rZXlcbiAgICAgICAgICAgICAgICB+YWRkX29yX3NldFxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGwsIHIsIGxlbmd0aClcbiAgICAgICAgaW5cbiAgICAgICAgd2l0aF9sZW5ndGggKGJhbCBsIHYgZCByKSBsZW5ndGgpXG4gIDs7XG5cbiAgKCogc3BlY2lhbGl6YXRpb24gb2YgW3NldCddIGZvciB0aGUgY2FzZSB3aGVuIFtrZXldIGlzIGxlc3MgdGhhbiBhbGwgdGhlIGV4aXN0aW5nIGtleXMgKilcbiAgbGV0IHJlYyBzZXRfbWluIGtleSBkYXRhIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTGVhZiB7IGtleTsgZGF0YSB9XG4gICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgTm9kZSB7IGxlZnQgPSBMZWFmIHsga2V5OyBkYXRhIH07IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSAyIH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBsZXQgbCA9IHNldF9taW4ga2V5IGRhdGEgbCBpblxuICAgICAgYmFsIGwgdiBkIHJcbiAgOztcblxuICAoKiBzcGVjaWFsaXphdGlvbiBvZiBbc2V0J10gZm9yIHRoZSBjYXNlIHdoZW4gW2tleV0gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGVcbiAgICAgZXhpc3Rpbmcga2V5cyAgKilcbiAgbGV0IHJlYyBzZXRfbWF4IHQga2V5IGRhdGEgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTGVhZiB7IGtleTsgZGF0YSB9XG4gICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gTGVhZiB7IGtleTsgZGF0YSB9OyBoZWlnaHQgPSAyIH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBsZXQgciA9IHNldF9tYXggciBrZXkgZGF0YSBpblxuICAgICAgYmFsIGwgdiBkIHJcbiAgOztcblxuICBsZXQgYWRkX2V4biB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0IHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgfmFkZF9vcl9zZXQ6QWRkX2V4blxuICA7O1xuXG4gIGxldCBhZGRfZXhuX2ludGVybmFsIHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgPVxuICAgIGZpbmRfYW5kX2FkZF9vcl9zZXRcbiAgICAgIHRcbiAgICAgIH5sZW5ndGhcbiAgICAgIH5rZXlcbiAgICAgIH5kYXRhXG4gICAgICB+Y29tcGFyZV9rZXlcbiAgICAgIH5zZXhwX29mX2tleVxuICAgICAgfmFkZF9vcl9zZXQ6QWRkX2V4bl9pbnRlcm5hbFxuICA7O1xuXG4gIGxldCBzZXQgdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5ID1cbiAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0XG4gICAgICB0XG4gICAgICB+bGVuZ3RoXG4gICAgICB+a2V5XG4gICAgICB+ZGF0YVxuICAgICAgfmNvbXBhcmVfa2V5XG4gICAgICB+c2V4cF9vZl9rZXk6KGZ1biBfIC0+IExpc3QgW10pXG4gICAgICB+YWRkX29yX3NldDpTZXRcbiAgOztcblxuICBsZXQgc2V0JyB0IGtleSBkYXRhIH5jb21wYXJlX2tleSA9IChzZXQgdCB+bGVuZ3RoOjAgfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkpLnRyZWVcblxuICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA6IHNpZ1xuICAgIHR5cGUgKCdrLCAnZCkgdFxuXG4gICAgdmFsIGVtcHR5IDogKCdrLCAnZCkgdFxuICAgIHZhbCBtYXhfa2V5IDogKCdrLCAnZCkgdCAtPiAnayBvcHRpb25cbiAgICB2YWwgYWRkX3VuY2hlY2tlZCA6ICgnaywgJ2QpIHQgLT4ga2V5OidrIC0+IGRhdGE6J2QgLT4gKCdrLCAnZCkgdFxuICAgIHZhbCB0b190cmVlX3VuY2hlY2tlZCA6ICgnaywgJ2QpIHQgLT4gKCdrLCAnZCkgdHJlZVxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnaywgJ2QpIHQgPSAoJ2sgKiAnZCkgbGlzdFxuXG4gICAgbGV0IGVtcHR5ID0gW11cblxuICAgIGxldCBtYXhfa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgfCAoa2V5LCBfKSA6OiBfIC0+IFNvbWUga2V5XG4gICAgOztcblxuICAgIGxldCBhZGRfdW5jaGVja2VkIHQgfmtleSB+ZGF0YSA9IChrZXksIGRhdGEpIDo6IHRcblxuICAgIGxldCB0b190cmVlX3VuY2hlY2tlZCA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IEVtcHR5XG4gICAgICB8IFsgKGtleSwgZGF0YSkgXSAtPiBMZWFmIHsga2V5OyBkYXRhIH1cbiAgICAgIHwgbGlzdCAtPlxuICAgICAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbGlzdCBpblxuICAgICAgICBsZXQgbGlzdCA9IHJlZiBsaXN0IGluXG4gICAgICAgIGxldCByZWMgbG9vcCBsZW4gPVxuICAgICAgICAgIG1hdGNoIGxlbiwgIWxpc3Qgd2l0aFxuICAgICAgICAgIHwgMSwgKGtleSwgZGF0YSkgOjogdGFpbCAtPlxuICAgICAgICAgICAgbGlzdCA6PSB0YWlsO1xuICAgICAgICAgICAgTGVhZiB7IGtleTsgZGF0YSB9XG4gICAgICAgICAgfCAyLCAoazIsIGQyKSA6OiAoazEsIGQxKSA6OiB0YWlsIC0+XG4gICAgICAgICAgICBsaXN0IDo9IHRhaWw7XG4gICAgICAgICAgICBOb2RlXG4gICAgICAgICAgICAgIHsgbGVmdCA9IEVtcHR5XG4gICAgICAgICAgICAgIDsga2V5ID0gazFcbiAgICAgICAgICAgICAgOyBkYXRhID0gZDFcbiAgICAgICAgICAgICAgOyByaWdodCA9IExlYWYgeyBrZXkgPSBrMjsgZGF0YSA9IGQyIH1cbiAgICAgICAgICAgICAgOyBoZWlnaHQgPSAyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB8IDMsIChrMywgZDMpIDo6IChrMiwgZDIpIDo6IChrMSwgZDEpIDo6IHRhaWwgLT5cbiAgICAgICAgICAgIGxpc3QgOj0gdGFpbDtcbiAgICAgICAgICAgIE5vZGVcbiAgICAgICAgICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IGsxOyBkYXRhID0gZDEgfVxuICAgICAgICAgICAgICA7IGtleSA9IGsyXG4gICAgICAgICAgICAgIDsgZGF0YSA9IGQyXG4gICAgICAgICAgICAgIDsgcmlnaHQgPSBMZWFmIHsga2V5ID0gazM7IGRhdGEgPSBkMyB9XG4gICAgICAgICAgICAgIDsgaGVpZ2h0ID0gMlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfCBfLCBfIC0+XG4gICAgICAgICAgICBsZXQgbnIgPSBsZW4gLyAyIGluXG4gICAgICAgICAgICBsZXQgbmwgPSBsZW4gLSBuciAtIDEgaW5cbiAgICAgICAgICAgIGxldCByID0gbG9vcCBuciBpblxuICAgICAgICAgICAgKG1hdGNoICFsaXN0IHdpdGhcbiAgICAgICAgICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgIHwgKGssIGQpIDo6IHRhaWwgLT5cbiAgICAgICAgICAgICAgIGxpc3QgOj0gdGFpbDtcbiAgICAgICAgICAgICAgIGxldCBsID0gbG9vcCBubCBpblxuICAgICAgICAgICAgICAgY3JlYXRlIGwgayBkIHIpXG4gICAgICAgIGluXG4gICAgICAgIGxvb3AgbGVuIFtAbm9udGFpbF1cbiAgICA7O1xuICBlbmRcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5ID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICAgIGxldCB7IHRyZWUgPSBidWlsZGVyOyBsZW5ndGggfSA9XG4gICAgICAgIFNlcXVlbmNlLmZvbGRcbiAgICAgICAgICBzZXFcbiAgICAgICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIEJ1aWxkX2luY3JlYXNpbmcuZW1wdHkgMClcbiAgICAgICAgICB+ZjooZnVuIHsgdHJlZSA9IGJ1aWxkZXI7IGxlbmd0aCB9IChrZXksIGRhdGEpIC0+XG4gICAgICAgICAgbWF0Y2ggQnVpbGRfaW5jcmVhc2luZy5tYXhfa2V5IGJ1aWxkZXIgd2l0aFxuICAgICAgICAgIHwgU29tZSBwcmV2X2tleSB3aGVuIGNvbXBhcmVfa2V5IHByZXZfa2V5IGtleSA+PSAwIC0+XG4gICAgICAgICAgICByZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX2luY3JlYXNpbmdfc2VxdWVuY2U6IG5vbi1pbmNyZWFzaW5nIGtleVwiKVxuICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgd2l0aF9sZW5ndGhfZ2xvYmFsXG4gICAgICAgICAgICAgIChCdWlsZF9pbmNyZWFzaW5nLmFkZF91bmNoZWNrZWQgYnVpbGRlciB+a2V5IH5kYXRhKVxuICAgICAgICAgICAgICAobGVuZ3RoICsgMSkpXG4gICAgICBpblxuICAgICAgT2sgKHdpdGhfbGVuZ3RoX2dsb2JhbCAoQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCBidWlsZGVyKSBsZW5ndGgpKVxuICA7O1xuXG4gICgqIExpa2UgW2JhbF0gYnV0IGFsbG93cyBhbnkgZGlmZmVyZW5jZSBpbiBoZWlnaHQgYmV0d2VlbiBbbF0gYW5kIFtyXS5cblxuICAgICBPKHxoZWlnaHQgbCAtIGhlaWdodCByfCkgKilcbiAgbGV0IHJlYyBqb2luIGwgayBkIHIgPVxuICAgIG1hdGNoIGwsIHIgd2l0aFxuICAgIHwgRW1wdHksIF8gLT4gc2V0X21pbiBrIGQgclxuICAgIHwgXywgRW1wdHkgLT4gc2V0X21heCBsIGsgZFxuICAgIHwgTGVhZiB7IGtleSA9IGxrOyBkYXRhID0gbGQgfSwgXyAtPiBzZXRfbWluIGxrIGxkIChzZXRfbWluIGsgZCByKVxuICAgIHwgXywgTGVhZiB7IGtleSA9IHJrOyBkYXRhID0gcmQgfSAtPiBzZXRfbWF4IChzZXRfbWF4IGwgayBkKSByayByZFxuICAgIHwgKCBOb2RlIHsgbGVmdCA9IGxsOyBrZXkgPSBsazsgZGF0YSA9IGxkOyByaWdodCA9IGxyOyBoZWlnaHQgPSBsaCB9XG4gICAgICAsIE5vZGUgeyBsZWZ0ID0gcmw7IGtleSA9IHJrOyBkYXRhID0gcmQ7IHJpZ2h0ID0gcnI7IGhlaWdodCA9IHJoIH0gKSAtPlxuICAgICAgbGV0IGwsIGssIGQsIHIgPVxuICAgICAgICAoKiBbYmFsXSByZXF1aXJlcyBoZWlnaHQgZGlmZmVyZW5jZSA8PSAzLiAqKVxuICAgICAgICBpZiBsaCA+IHJoICsgM1xuICAgICAgICAgICAoKiBbaGVpZ2h0IGxyID49IGhlaWdodCByXSxcbiAgICAgICAgICAgdGhlcmVmb3JlIFtoZWlnaHQgKGpvaW4gbHIgayBkIHIgLi4uKV0gaXMgW2hlaWdodCBybCArIDFdIG9yIFtoZWlnaHQgcmxdXG4gICAgICAgICAgIHRoZXJlZm9yZSB0aGUgaGVpZ2h0IGRpZmZlcmVuY2Ugd2l0aCBbbGxdIHdpbGwgYmUgPD0gMyAqKVxuICAgICAgICB0aGVuIGxsLCBsaywgbGQsIGpvaW4gbHIgayBkIHJcbiAgICAgICAgZWxzZSBpZiByaCA+IGxoICsgM1xuICAgICAgICB0aGVuIGpvaW4gbCBrIGQgcmwsIHJrLCByZCwgcnJcbiAgICAgICAgZWxzZSBsLCBrLCBkLCByXG4gICAgICBpblxuICAgICAgYmFsIGwgayBkIHJcbiAgOztcblxuICBsZXRbQGlubGluZV0gcmVjIHNwbGl0X2dlbiB0IHggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5LCBOb25lLCBFbXB0eVxuICAgIHwgTGVhZiB7IGtleSA9IGs7IGRhdGEgPSBkIH0gLT5cbiAgICAgIGxldCBjbXAgPSBjb21wYXJlX2tleSBrIGluXG4gICAgICBpZiBjbXAgPSAwXG4gICAgICB0aGVuIEVtcHR5LCBTb21lIChrLCBkKSwgRW1wdHlcbiAgICAgIGVsc2UgaWYgY21wIDwgMFxuICAgICAgdGhlbiBFbXB0eSwgTm9uZSwgdFxuICAgICAgZWxzZSB0LCBOb25lLCBFbXB0eVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBrOyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGxldCBjbXAgPSBjb21wYXJlX2tleSBrIGluXG4gICAgICBpZiBjbXAgPSAwXG4gICAgICB0aGVuIGwsIFNvbWUgKGssIGQpLCByXG4gICAgICBlbHNlIGlmIGNtcCA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgbGwsIG1heWJlLCBsciA9IHNwbGl0X2dlbiBsIHggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIGxsLCBtYXliZSwgam9pbiBsciBrIGQgcilcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgcmwsIG1heWJlLCByciA9IHNwbGl0X2dlbiByIHggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIGpvaW4gbCBrIGQgcmwsIG1heWJlLCBycilcbiAgOztcblxuICBsZXQgc3BsaXQgdCB4IH5jb21wYXJlX2tleSA9IHNwbGl0X2dlbiB0IHggfmNvbXBhcmVfa2V5OihmdW4geSAtPiBjb21wYXJlX2tleSB4IHkpXG5cbiAgKCogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZWFsbHkgcmVpbnNlcnQgW3hdLCBidXQganVzdCBhcnJhbmdlcyBzbyB0aGF0IFtzcGxpdF1cbiAgICAgcHJvZHVjZXMgdGhlIGVxdWl2YWxlbnQgdHJlZSBpbiB0aGUgZmlyc3QgcGxhY2UuICopXG4gIGxldCBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgdCB+aW50byB4IH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGxlZnQsIGJvdW5kYXJ5X29wdCwgcmlnaHQgPVxuICAgICAgc3BsaXRfZ2VuXG4gICAgICAgIHRcbiAgICAgICAgeFxuICAgICAgICB+Y29tcGFyZV9rZXk6XG4gICAgICAgICAgKG1hdGNoIGludG8gd2l0aFxuICAgICAgICAgICB8IGBMZWZ0IC0+XG4gICAgICAgICAgICAgZnVuIHkgLT5cbiAgICAgICAgICAgICAgIChtYXRjaCBjb21wYXJlX2tleSB4IHkgd2l0aFxuICAgICAgICAgICAgICAgIHwgMCAtPiAxXG4gICAgICAgICAgICAgICAgfCByZXMgLT4gcmVzKVxuICAgICAgICAgICB8IGBSaWdodCAtPlxuICAgICAgICAgICAgIGZ1biB5IC0+XG4gICAgICAgICAgICAgICAobWF0Y2ggY29tcGFyZV9rZXkgeCB5IHdpdGhcbiAgICAgICAgICAgICAgICB8IDAgLT4gLTFcbiAgICAgICAgICAgICAgICB8IHJlcyAtPiByZXMpKVxuICAgIGluXG4gICAgYXNzZXJ0IChPcHRpb24uaXNfbm9uZSBib3VuZGFyeV9vcHQpO1xuICAgIGxlZnQsIHJpZ2h0XG4gIDs7XG5cbiAgbGV0IHNwbGl0X3JhbmdlXG4gICAgdFxuICAgIH4obG93ZXJfYm91bmQgOiAnYSBNYXliZV9ib3VuZC50KVxuICAgIH4odXBwZXJfYm91bmQgOiAnYSBNYXliZV9ib3VuZC50KVxuICAgIH5jb21wYXJlX2tleVxuICAgID1cbiAgICBpZiBNYXliZV9ib3VuZC5ib3VuZHNfY3Jvc3NlZFxuICAgICAgICAgfmNvbXBhcmU6Y29tcGFyZV9rZXlcbiAgICAgICAgIH5sb3dlcjpsb3dlcl9ib3VuZFxuICAgICAgICAgfnVwcGVyOnVwcGVyX2JvdW5kXG4gICAgdGhlbiBlbXB0eSwgZW1wdHksIGVtcHR5XG4gICAgZWxzZSAoXG4gICAgICBsZXQgbGVmdCwgbWlkX2FuZF9yaWdodCA9XG4gICAgICAgIG1hdGNoIGxvd2VyX2JvdW5kIHdpdGhcbiAgICAgICAgfCBVbmJvdW5kZWQgLT4gZW1wdHksIHRcbiAgICAgICAgfCBJbmNsIGxiIC0+IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgUmlnaHQgdCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgICAgfCBFeGNsIGxiIC0+IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgTGVmdCB0IGxiIH5jb21wYXJlX2tleVxuICAgICAgaW5cbiAgICAgIGxldCBtaWQsIHJpZ2h0ID1cbiAgICAgICAgbWF0Y2ggdXBwZXJfYm91bmQgd2l0aFxuICAgICAgICB8IFVuYm91bmRlZCAtPiBtaWRfYW5kX3JpZ2h0LCBlbXB0eVxuICAgICAgICB8IEluY2wgbGIgLT4gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IH5pbnRvOmBMZWZ0IG1pZF9hbmRfcmlnaHQgbGIgfmNvbXBhcmVfa2V5XG4gICAgICAgIHwgRXhjbCBsYiAtPlxuICAgICAgICAgIHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgUmlnaHQgbWlkX2FuZF9yaWdodCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgIGluXG4gICAgICBsZWZ0LCBtaWQsIHJpZ2h0KVxuICA7O1xuXG4gIGxldCByZWMgZmluZCB0IHggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IGlmIGNvbXBhcmVfa2V5IHggdiA9IDAgdGhlbiBTb21lIGQgZWxzZSBOb25lXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSBkIGVsc2UgZmluZCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcikgeCB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBsZXQgYWRkX211bHRpIHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGRhdGEgPSBkYXRhIDo6IE9wdGlvbi52YWx1ZSAoZmluZCB0IGtleSB+Y29tcGFyZV9rZXkpIH5kZWZhdWx0OltdIGluXG4gICAgc2V0IH5sZW5ndGggfmtleSB+ZGF0YSB0IH5jb21wYXJlX2tleVxuICA7O1xuXG4gIGxldCBmaW5kX211bHRpIHQgeCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIGZpbmQgdCB4IH5jb21wYXJlX2tleSB3aXRoXG4gICAgfCBOb25lIC0+IFtdXG4gICAgfCBTb21lIGwgLT4gbFxuICA7O1xuXG4gIGxldCBmaW5kX2V4biA9XG4gICAgbGV0IGlmX25vdF9mb3VuZCBrZXkgfnNleHBfb2Zfa2V5ID1cbiAgICAgIHJhaXNlIChOb3RfZm91bmRfcyAoTGlzdCBbIEF0b20gXCJNYXAuZmluZF9leG46IG5vdCBmb3VuZFwiOyBzZXhwX29mX2tleSBrZXkgXSkpXG4gICAgaW5cbiAgICBsZXQgcmVjIGZpbmRfZXhuIHQgeCB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpZl9ub3RfZm91bmQgeCB+c2V4cF9vZl9rZXlcbiAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgeCB2ID0gMCB0aGVuIGQgZWxzZSBpZl9ub3RfZm91bmQgeCB+c2V4cF9vZl9rZXlcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiBkIGVsc2UgZmluZF9leG4gKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpIHggfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleVxuICAgIGluXG4gICAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICAgIGZpbmRfZXhuXG4gIDs7XG5cbiAgbGV0IG1lbSB0IHggfmNvbXBhcmVfa2V5ID0gT3B0aW9uLmlzX3NvbWUgKGZpbmQgdCB4IH5jb21wYXJlX2tleSlcblxuICBsZXQgcmVjIG1pbl9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGtleSA9IGs7IGRhdGEgPSBkIH0gLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IGs7IGRhdGEgPSBkOyByaWdodCA9IF87IGhlaWdodCA9IF8gfSAtPiBTb21lIChrLCBkKVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBfOyBkYXRhID0gXzsgcmlnaHQgPSBfOyBoZWlnaHQgPSBfIH0gLT4gbWluX2VsdCBsXG4gIDs7XG5cbiAgZXhjZXB0aW9uIE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXBdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgIHwgTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcCAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXAubWwuVHJlZTAuTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcFwiXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgZXhjZXB0aW9uIE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbiAgbGV0ICgpID1cbiAgICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGRcbiAgICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXBdXG4gICAgICAoZnVuY3Rpb25cbiAgICAgIHwgTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcCAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXAubWwuVHJlZTAuTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcFwiXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG1pbl9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1pbl9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXBcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgbGV0IHJlYyBtYXhfZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBrZXkgPSBrOyBkYXRhID0gZCB9IC0+IFNvbWUgKGssIGQpXG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IGs7IGRhdGEgPSBkOyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSBfIH0gLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgeyBsZWZ0ID0gXzsga2V5ID0gXzsgZGF0YSA9IF87IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+IG1heF9lbHQgclxuICA7O1xuXG4gIGxldCBtYXhfZWx0X2V4biB0ID1cbiAgICBtYXRjaCBtYXhfZWx0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBNYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwXG4gICAgfCBTb21lIHYgLT4gdlxuICA7O1xuXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5yZW1vdmVfbWluX2VsdFwiXG4gICAgfCBMZWFmIF8gLT4gRW1wdHlcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IF87IGRhdGEgPSBfOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPiByXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHg7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgYmFsIChyZW1vdmVfbWluX2VsdCBsKSB4IGQgclxuICA7O1xuXG4gIGxldCBhcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCBtYXhfZWx0IGxvd2VyX3BhcnQsIG1pbl9lbHQgdXBwZXJfcGFydCB3aXRoXG4gICAgfCBOb25lLCBfIC0+IGBPayB1cHBlcl9wYXJ0XG4gICAgfCBfLCBOb25lIC0+IGBPayBsb3dlcl9wYXJ0XG4gICAgfCBTb21lIChtYXhfbG93ZXIsIF8pLCBTb21lIChtaW5fdXBwZXIsIHYpIHdoZW4gY29tcGFyZV9rZXkgbWF4X2xvd2VyIG1pbl91cHBlciA8IDAgLT5cbiAgICAgIGxldCB1cHBlcl9wYXJ0X3dpdGhvdXRfbWluID0gcmVtb3ZlX21pbl9lbHQgdXBwZXJfcGFydCBpblxuICAgICAgYE9rIChqb2luIGxvd2VyX3BhcnQgbWluX3VwcGVyIHYgdXBwZXJfcGFydF93aXRob3V0X21pbilcbiAgICB8IF8gLT4gYE92ZXJsYXBwaW5nX2tleV9yYW5nZXNcbiAgOztcblxuICBsZXQgZm9sZF9yYW5nZV9pbmNsdXNpdmUgPVxuICAgICgqIFRoaXMgYXNzdW1lcyB0aGF0IG1pbiA8PSBtYXgsIHdoaWNoIGlzIGNoZWNrZWQgYnkgdGhlIG91dGVyIGZ1bmN0aW9uLiAqKVxuICAgIGxldCByZWMgZ28gdCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpbml0XG4gICAgICB8IExlYWYgeyBrZXkgPSBrOyBkYXRhID0gZCB9IC0+XG4gICAgICAgIGlmIGNvbXBhcmVfa2V5IGsgbWluIDwgMCB8fCBjb21wYXJlX2tleSBrIG1heCA+IDBcbiAgICAgICAgdGhlbiAoKiBrIDwgbWluIHx8IGsgPiBtYXggKilcbiAgICAgICAgICBpbml0XG4gICAgICAgIGVsc2UgZiB+a2V5OmsgfmRhdGE6ZCBpbml0XG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gazsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgIGxldCBjX21pbiA9IGNvbXBhcmVfa2V5IGsgbWluIGluXG4gICAgICAgIGlmIGNfbWluIDwgMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgKCogaWYgayA8IG1pbiwgdGhlbiB0aGlzIG5vZGUgYW5kIGl0cyBsZWZ0IGJyYW5jaCBhcmUgb3V0c2lkZSBvdXIgcmFuZ2UgKilcbiAgICAgICAgICBnbyByIH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXlcbiAgICAgICAgZWxzZSBpZiBjX21pbiA9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgICgqIGlmIGsgPSBtaW4sIHRoZW4gdGhpcyBub2RlJ3MgbGVmdCBicmFuY2ggaXMgb3V0c2lkZSBvdXIgcmFuZ2UgKilcbiAgICAgICAgICBnbyByIH5taW4gfm1heCB+aW5pdDooZiB+a2V5OmsgfmRhdGE6ZCBpbml0KSB+ZiB+Y29tcGFyZV9rZXlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogayA+IG1pbiAqKVxuICAgICAgICAgIGxldCB6ID0gZ28gbCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgbGV0IGNfbWF4ID0gY29tcGFyZV9rZXkgayBtYXggaW5cbiAgICAgICAgICAoKiBpZiBrID4gbWF4LCB3ZSdyZSBkb25lICopXG4gICAgICAgICAgaWYgY19tYXggPiAwXG4gICAgICAgICAgdGhlbiB6XG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgeiA9IGYgfmtleTprIH5kYXRhOmQgeiBpblxuICAgICAgICAgICAgKCogaWYgayA9IG1heCwgdGhlbiB3ZSBmb2xkIGluIHRoaXMgb25lIGxhc3QgdmFsdWUgYW5kIHdlJ3JlIGRvbmUgKilcbiAgICAgICAgICAgIGlmIGNfbWF4ID0gMCB0aGVuIHogZWxzZSBnbyByIH5taW4gfm1heCB+aW5pdDp6IH5mIH5jb21wYXJlX2tleSkpXG4gICAgaW5cbiAgICBmdW4gdCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5IC0+XG4gICAgICBpZiBjb21wYXJlX2tleSBtaW4gbWF4IDw9IDAgdGhlbiBnbyB0IH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgZWxzZSBpbml0XG4gIDs7XG5cbiAgbGV0IHJhbmdlX3RvX2FsaXN0IHQgfm1pbiB+bWF4IH5jb21wYXJlX2tleSA9XG4gICAgTGlzdC5yZXZcbiAgICAgIChmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgICAgICAgdFxuICAgICAgICAgfm1pblxuICAgICAgICAgfm1heFxuICAgICAgICAgfmluaXQ6W11cbiAgICAgICAgIH5mOihmdW4gfmtleSB+ZGF0YSBsIC0+IChrZXksIGRhdGEpIDo6IGwpXG4gICAgICAgICB+Y29tcGFyZV9rZXkpXG4gIDs7XG5cbiAgKCogcHJlY29uZGl0aW9uczpcbiAgICAgLSBhbGwgZWxlbWVudHMgaW4gdDEgYXJlIGxlc3MgdGhhbiBlbGVtZW50cyBpbiB0MlxuICAgICAtIHxoZWlnaHQodDEpIC0gaGVpZ2h0KHQyKXwgPD0gMiAqKVxuICBsZXQgY29uY2F0X3VuY2hlY2tlZCB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT5cbiAgICAgIGxldCB4LCBkID0gbWluX2VsdF9leG4gdDIgaW5cbiAgICAgIGJhbCB0MSB4IGQgKHJlbW92ZV9taW5fZWx0IHQyKVxuICA7O1xuXG4gICgqIHNpbWlsYXIgdG8gW2NvbmNhdF91bmNoZWNrZWRdLCBhbmQgYmFsYW5jZXMgdHJlZXMgb2YgYXJiaXRyYXJ5IGhlaWdodCBkaWZmZXJlbmNlcyAqKVxuICBsZXQgY29uY2F0X2FuZF9iYWxhbmNlX3VuY2hlY2tlZCB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT5cbiAgICAgIGxldCB4LCBkID0gbWluX2VsdF9leG4gdDIgaW5cbiAgICAgIGpvaW4gdDEgeCBkIChyZW1vdmVfbWluX2VsdCB0MilcbiAgOztcblxuICBsZXQgcmVjIHJlbW92ZSB0IHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gd2l0aF9sZW5ndGggdCBsZW5ndGhcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gXyB9IC0+XG4gICAgICBpZiBjb21wYXJlX2tleSB4IHYgPSAwIHRoZW4gd2l0aF9sZW5ndGggRW1wdHkgKGxlbmd0aCAtIDEpIGVsc2Ugd2l0aF9sZW5ndGggdCBsZW5ndGhcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gd2l0aF9sZW5ndGggKGNvbmNhdF91bmNoZWNrZWQgbCByKSAobGVuZ3RoIC0gMSlcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbCwgciwgbGVuZ3RoJyA9XG4gICAgICAgICAgaWYgYyA8IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCB7IHRyZWUgPSBsOyBsZW5ndGggPSBsZW5ndGgnIH0gPSByZW1vdmUgbCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgICBsLCByLCBsZW5ndGgnKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IHsgdHJlZSA9IHI7IGxlbmd0aCA9IGxlbmd0aCcgfSA9IHJlbW92ZSByIHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgICAgIGwsIHIsIGxlbmd0aCcpXG4gICAgICAgIGluXG4gICAgICAgIGlmIGxlbmd0aCA9IGxlbmd0aCdcbiAgICAgICAgdGhlbiB3aXRoX2xlbmd0aCB0IGxlbmd0aFxuICAgICAgICBlbHNlIHdpdGhfbGVuZ3RoIChiYWwgbCB2IGQgcikgbGVuZ3RoJylcbiAgOztcblxuICBsZXQgcmVjIGNoYW5nZSB0IGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgKG1hdGNoIGYgTm9uZSB3aXRoXG4gICAgICAgfCBOb25lIC0+IHdpdGhfbGVuZ3RoIEVtcHR5IGxlbmd0aFxuICAgICAgIHwgU29tZSBkYXRhIC0+IHdpdGhfbGVuZ3RoIChMZWFmIHsga2V5OyBkYXRhIH0pIChsZW5ndGggKyAxKSlcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gd2l0aF9sZW5ndGggRW1wdHkgKGxlbmd0aCAtIDEpXG4gICAgICAgIHwgU29tZSBkJyAtPiB3aXRoX2xlbmd0aCAoTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkJyB9KSBsZW5ndGgpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHsgdHJlZSA9IGwnOyBsZW5ndGggfSA9IGNoYW5nZSBFbXB0eSBrZXkgfmYgfmxlbmd0aCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgaWYgcGh5c19lcXVhbCBsJyB0XG4gICAgICAgIHRoZW4gd2l0aF9sZW5ndGggdCBsZW5ndGhcbiAgICAgICAgZWxzZSB3aXRoX2xlbmd0aCAoYmFsIGwnIHYgZCBFbXB0eSkgbGVuZ3RoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCB7IHRyZWUgPSByJzsgbGVuZ3RoIH0gPSBjaGFuZ2UgRW1wdHkga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIGlmIHBoeXNfZXF1YWwgcicgdFxuICAgICAgICB0aGVuIHdpdGhfbGVuZ3RoIHQgbGVuZ3RoXG4gICAgICAgIGVsc2Ugd2l0aF9sZW5ndGggKGJhbCBFbXB0eSB2IGQgcicpIGxlbmd0aClcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gd2l0aF9sZW5ndGggKGNvbmNhdF91bmNoZWNrZWQgbCByKSAobGVuZ3RoIC0gMSlcbiAgICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICB3aXRoX2xlbmd0aCAoTm9kZSB7IGxlZnQgPSBsOyBrZXk7IGRhdGE7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9KSBsZW5ndGgpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHsgdHJlZSA9IGwnOyBsZW5ndGggfSA9IGNoYW5nZSBsIGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICBpZiBwaHlzX2VxdWFsIGwnIGxcbiAgICAgICAgdGhlbiB3aXRoX2xlbmd0aCB0IGxlbmd0aFxuICAgICAgICBlbHNlIHdpdGhfbGVuZ3RoIChiYWwgbCcgdiBkIHIpIGxlbmd0aClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgeyB0cmVlID0gcic7IGxlbmd0aCB9ID0gY2hhbmdlIHIga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIGlmIHBoeXNfZXF1YWwgcicgclxuICAgICAgICB0aGVuIHdpdGhfbGVuZ3RoIHQgbGVuZ3RoXG4gICAgICAgIGVsc2Ugd2l0aF9sZW5ndGggKGJhbCBsIHYgZCByJykgbGVuZ3RoKVxuICA7O1xuXG4gIGxldCByZWMgdXBkYXRlIHQga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICBsZXQgZGF0YSA9IGYgTm9uZSBpblxuICAgICAgd2l0aF9sZW5ndGggKExlYWYgeyBrZXk7IGRhdGEgfSkgKGxlbmd0aCArIDEpXG4gICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgZCcgPSBmIChTb21lIGQpIGluXG4gICAgICAgIHdpdGhfbGVuZ3RoIChMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQnIH0pIGxlbmd0aClcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgeyB0cmVlID0gbDsgbGVuZ3RoIH0gPSB1cGRhdGUgRW1wdHkga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIHdpdGhfbGVuZ3RoIChiYWwgbCB2IGQgRW1wdHkpIGxlbmd0aClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgeyB0cmVlID0gcjsgbGVuZ3RoIH0gPSB1cGRhdGUgRW1wdHkga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIHdpdGhfbGVuZ3RoIChiYWwgRW1wdHkgdiBkIHIpIGxlbmd0aClcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBkYXRhID0gZiAoU29tZSBkKSBpblxuICAgICAgICB3aXRoX2xlbmd0aCAoTm9kZSB7IGxlZnQgPSBsOyBrZXk7IGRhdGE7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9KSBsZW5ndGgpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHsgdHJlZSA9IGw7IGxlbmd0aCB9ID0gdXBkYXRlIGwga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIHdpdGhfbGVuZ3RoIChiYWwgbCB2IGQgcikgbGVuZ3RoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCB7IHRyZWUgPSByOyBsZW5ndGggfSA9IHVwZGF0ZSByIGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICB3aXRoX2xlbmd0aCAoYmFsIGwgdiBkIHIpIGxlbmd0aClcbiAgOztcblxuICBsZXQgcmVtb3ZlX211bHRpIHQga2V5IH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBjaGFuZ2UgdCBrZXkgfmxlbmd0aCB+Y29tcGFyZV9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgfCBTb21lIChbXSB8IFsgXyBdKSAtPiBOb25lXG4gICAgICB8IFNvbWUgKF8gOjogKF8gOjogXyBhcyBub25fZW1wdHlfdGFpbCkpIC0+IFNvbWUgbm9uX2VtcHR5X3RhaWwpXG4gIDs7XG5cbiAgbGV0IHJlYyBpdGVyX2tleXMgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBfIH0gLT4gZiB2XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBfOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgaXRlcl9rZXlzIH5mIGw7XG4gICAgICBmIHY7XG4gICAgICBpdGVyX2tleXMgfmYgclxuICA7O1xuXG4gIGxldCByZWMgaXRlciB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIHsga2V5ID0gXzsgZGF0YSA9IGQgfSAtPiBmIGRcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gXzsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBpdGVyIH5mIGw7XG4gICAgICBmIGQ7XG4gICAgICBpdGVyIH5mIHJcbiAgOztcblxuICBsZXQgcmVjIGl0ZXJpIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IGYgfmtleTp2IH5kYXRhOmRcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBpdGVyaSB+ZiBsO1xuICAgICAgZiB+a2V5OnYgfmRhdGE6ZDtcbiAgICAgIGl0ZXJpIH5mIHJcbiAgOztcblxuICBsZXQgaXRlcmlfdW50aWwgPVxuICAgIGxldCByZWMgaXRlcmlfdW50aWxfbG9vcCB0IH5mIDogQ29udGludWVfb3Jfc3RvcC50ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBDb250aW51ZVxuICAgICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPiBmIH5rZXk6diB+ZGF0YTpkXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgIChtYXRjaCBpdGVyaV91bnRpbF9sb29wIH5mIGwgd2l0aFxuICAgICAgICAgfCBTdG9wIC0+IFN0b3BcbiAgICAgICAgIHwgQ29udGludWUgLT5cbiAgICAgICAgICAgKG1hdGNoIGYgfmtleTp2IH5kYXRhOmQgd2l0aFxuICAgICAgICAgICAgfCBTdG9wIC0+IFN0b3BcbiAgICAgICAgICAgIHwgQ29udGludWUgLT4gaXRlcmlfdW50aWxfbG9vcCB+ZiByKSlcbiAgICBpblxuICAgIGZ1biB0IH5mIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQub2ZfY29udGludWVfb3Jfc3RvcCAoaXRlcmlfdW50aWxfbG9vcCB0IH5mKVxuICA7O1xuXG4gIGxldCByZWMgbWFwIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZiBkIH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9IC0+XG4gICAgICBsZXQgbCcgPSBtYXAgfmYgbCBpblxuICAgICAgbGV0IGQnID0gZiBkIGluXG4gICAgICBsZXQgcicgPSBtYXAgfmYgciBpblxuICAgICAgTm9kZSB7IGxlZnQgPSBsJzsga2V5ID0gdjsgZGF0YSA9IGQnOyByaWdodCA9IHInOyBoZWlnaHQgPSBoIH1cbiAgOztcblxuICBsZXQgcmVjIG1hcGkgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT4gTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBmIH5rZXk6diB+ZGF0YTpkIH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9IC0+XG4gICAgICBsZXQgbCcgPSBtYXBpIH5mIGwgaW5cbiAgICAgIGxldCBkJyA9IGYgfmtleTp2IH5kYXRhOmQgaW5cbiAgICAgIGxldCByJyA9IG1hcGkgfmYgciBpblxuICAgICAgTm9kZSB7IGxlZnQgPSBsJzsga2V5ID0gdjsgZGF0YSA9IGQnOyByaWdodCA9IHInOyBoZWlnaHQgPSBoIH1cbiAgOztcblxuICBsZXQgcmVjIGZvbGQgdCB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IGYgfmtleTp2IH5kYXRhOmQgYWNjdVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGZvbGQgfmYgciB+aW5pdDooZiB+a2V5OnYgfmRhdGE6ZCAoZm9sZCB+ZiBsIH5pbml0OmFjY3UpKVxuICA7O1xuXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9XG4gICAgbGV0IHJlYyBmb2xkX3VudGlsX2xvb3AgdCB+YWNjIH5mIDogKF8sIF8pIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IENvbnRpbnVlIGFjY1xuICAgICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPiBmIH5rZXk6diB+ZGF0YTpkIGFjY1xuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICAobWF0Y2ggZm9sZF91bnRpbF9sb29wIGwgfmFjYyB+ZiB3aXRoXG4gICAgICAgICB8IFN0b3AgZmluYWwgLT4gU3RvcCBmaW5hbFxuICAgICAgICAgfCBDb250aW51ZSBhY2MgLT5cbiAgICAgICAgICAgKG1hdGNoIGYgfmtleTp2IH5kYXRhOmQgYWNjIHdpdGhcbiAgICAgICAgICAgIHwgU3RvcCBmaW5hbCAtPiBTdG9wIGZpbmFsXG4gICAgICAgICAgICB8IENvbnRpbnVlIGFjYyAtPiBmb2xkX3VudGlsX2xvb3AgciB+YWNjIH5mKSlcbiAgICBpblxuICAgIG1hdGNoIGZvbGRfdW50aWxfbG9vcCB0IH5hY2M6aW5pdCB+ZiB3aXRoXG4gICAgfCBDb250aW51ZSBhY2MgLT4gZmluaXNoIGFjYyBbQG5vbnRhaWxdXG4gICAgfCBTdG9wIHN0b3AgLT4gc3RvcFxuICA7O1xuXG4gIGxldCByZWMgZm9sZF9yaWdodCB0IH5pbml0OmFjY3UgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT4gZiB+a2V5OnYgfmRhdGE6ZCBhY2N1XG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgZm9sZF9yaWdodCB+ZiBsIH5pbml0OihmIH5rZXk6diB+ZGF0YTpkIChmb2xkX3JpZ2h0IH5mIHIgfmluaXQ6YWNjdSkpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaWx0ZXJfbWFwaSB0IH5mIH5sZW4gPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+XG4gICAgICAobWF0Y2ggZiB+a2V5OnYgfmRhdGE6ZCB3aXRoXG4gICAgICAgfCBTb21lIG5ld19kYXRhIC0+IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gbmV3X2RhdGEgfVxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgZGVjciBsZW47XG4gICAgICAgICBFbXB0eSlcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwaSBsIH5mIH5sZW4gaW5cbiAgICAgIGxldCBuZXdfZGF0YSA9IGYgfmtleTp2IH5kYXRhOmQgaW5cbiAgICAgIGxldCByJyA9IGZpbHRlcl9tYXBpIHIgfmYgfmxlbiBpblxuICAgICAgKG1hdGNoIG5ld19kYXRhIHdpdGhcbiAgICAgICB8IFNvbWUgbmV3X2RhdGEgLT4gam9pbiBsJyB2IG5ld19kYXRhIHInXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBkZWNyIGxlbjtcbiAgICAgICAgIGNvbmNhdF9hbmRfYmFsYW5jZV91bmNoZWNrZWQgbCcgcicpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaWx0ZXJpIHQgfmYgfmxlbiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgIChtYXRjaCBmIH5rZXk6diB+ZGF0YTpkIHdpdGhcbiAgICAgICB8IHRydWUgLT4gdFxuICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgIGRlY3IgbGVuO1xuICAgICAgICAgRW1wdHkpXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgbGV0IGwnID0gZmlsdGVyaSBsIH5mIH5sZW4gaW5cbiAgICAgIGxldCBrZWVwX2RhdGEgPSBmIH5rZXk6diB+ZGF0YTpkIGluXG4gICAgICBsZXQgcicgPSBmaWx0ZXJpIHIgfmYgfmxlbiBpblxuICAgICAgaWYgcGh5c19lcXVhbCBsIGwnICYmIGtlZXBfZGF0YSAmJiBwaHlzX2VxdWFsIHIgcidcbiAgICAgIHRoZW4gdFxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGtlZXBfZGF0YSB3aXRoXG4gICAgICAgIHwgdHJ1ZSAtPiBqb2luIGwnIHYgZCByJ1xuICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgZGVjciBsZW47XG4gICAgICAgICAgY29uY2F0X2FuZF9iYWxhbmNlX3VuY2hlY2tlZCBsJyByJylcbiAgOztcblxuICBsZXQgZmlsdGVyIHQgfmYgfmxlbiA9IGZpbHRlcmkgdCB+bGVuIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuICBsZXQgZmlsdGVyX2tleXMgdCB+ZiB+bGVuID0gZmlsdGVyaSB0IH5sZW4gfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpIFtAbm9udGFpbF1cbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiB+bGVuID0gZmlsdGVyX21hcGkgdCB+bGVuIH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuXG4gIGxldCBwYXJ0aXRpb25fbWFwaSB0IH5mID1cbiAgICBsZXQgdDEsIHQyID1cbiAgICAgIGZvbGRcbiAgICAgICAgdFxuICAgICAgICB+aW5pdDooQnVpbGRfaW5jcmVhc2luZy5lbXB0eSwgQnVpbGRfaW5jcmVhc2luZy5lbXB0eSlcbiAgICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhICh0MSwgdDIpIC0+XG4gICAgICAgIG1hdGNoIChmIH5rZXkgfmRhdGEgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgRmlyc3QgeCAtPiBCdWlsZF9pbmNyZWFzaW5nLmFkZF91bmNoZWNrZWQgdDEgfmtleSB+ZGF0YTp4LCB0MlxuICAgICAgICB8IFNlY29uZCB5IC0+IHQxLCBCdWlsZF9pbmNyZWFzaW5nLmFkZF91bmNoZWNrZWQgdDIgfmtleSB+ZGF0YTp5KVxuICAgIGluXG4gICAgQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCB0MSwgQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCB0MlxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPSBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuXG4gIGxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPVxuICAgIGxldCByZWMgbG9vcCB0IH5mID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBFbXB0eSwgRW1wdHlcbiAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT5cbiAgICAgICAgKG1hdGNoIGYgfmtleTp2IH5kYXRhOmQgd2l0aFxuICAgICAgICAgfCB0cnVlIC0+IHQsIEVtcHR5XG4gICAgICAgICB8IGZhbHNlIC0+IEVtcHR5LCB0KVxuICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICBsZXQgbCd0LCBsJ2YgPSBsb29wIGwgfmYgaW5cbiAgICAgICAgbGV0IGtlZXBfZGF0YV90ID0gZiB+a2V5OnYgfmRhdGE6ZCBpblxuICAgICAgICBsZXQgcid0LCByJ2YgPSBsb29wIHIgfmYgaW5cbiAgICAgICAgbGV0IG1rIGwnIGtlZXBfZGF0YSByJyA9XG4gICAgICAgICAgaWYgcGh5c19lcXVhbCBsIGwnICYmIGtlZXBfZGF0YSAmJiBwaHlzX2VxdWFsIHIgcidcbiAgICAgICAgICB0aGVuIHRcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIG1hdGNoIGtlZXBfZGF0YSB3aXRoXG4gICAgICAgICAgICB8IHRydWUgLT4gam9pbiBsJyB2IGQgcidcbiAgICAgICAgICAgIHwgZmFsc2UgLT4gY29uY2F0X2FuZF9iYWxhbmNlX3VuY2hlY2tlZCBsJyByJylcbiAgICAgICAgaW5cbiAgICAgICAgbWsgbCd0IGtlZXBfZGF0YV90IHIndCwgbWsgbCdmIChub3Qga2VlcF9kYXRhX3QpIHInZlxuICAgIGluXG4gICAgbG9vcCB0IH5mXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB0IH5mID0gcGFydGl0aW9uaV90ZiB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuXG4gIG1vZHVsZSBFbnVtID0gc3RydWN0XG4gICAgdHlwZSBpbmNyZWFzaW5nXG4gICAgdHlwZSBkZWNyZWFzaW5nXG5cbiAgICB0eXBlICgnaywgJ3YsICdkaXJlY3Rpb24pIHQgPVxuICAgICAgfCBFbmRcbiAgICAgIHwgTW9yZSBvZiAnayAqICd2ICogKCdrLCAndikgdHJlZSAqICgnaywgJ3YsICdkaXJlY3Rpb24pIHRcblxuICAgIGxldCByZWMgY29ucyB0IChlIDogKF8sIF8sIGluY3JlYXNpbmcpIHQpIDogKF8sIF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT4gTW9yZSAodiwgZCwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgIGNvbnMgbCAoTW9yZSAodiwgZCwgciwgZSkpXG4gICAgOztcblxuICAgIGxldCByZWMgY29uc19yaWdodCB0IChlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQpIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiB7IGtleSA9IHY7IGRhdGEgPSBkIH0gLT4gTW9yZSAodiwgZCwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgIGNvbnNfcmlnaHQgciAoTW9yZSAodiwgZCwgbCwgZSkpXG4gICAgOztcblxuICAgIGxldCBvZl90cmVlIHRyZWUgOiAoXywgXywgaW5jcmVhc2luZykgdCA9IGNvbnMgdHJlZSBFbmRcbiAgICBsZXQgb2ZfdHJlZV9yaWdodCB0cmVlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPSBjb25zX3JpZ2h0IHRyZWUgRW5kXG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfaW5jcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgICAgIGxvb3AgKE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSAxIH0pIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IHY7IGRhdGEgPSBfOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfVxuICAgICAgICAgIHdoZW4gY29tcGFyZSB2IGtleSA8IDAgLT4gbG9vcCByIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICAgIGxvb3AgbCAoTW9yZSAodiwgZCwgciwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgICAgIGxvb3AgKE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IEVtcHR5OyBoZWlnaHQgPSAxIH0pIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBfOyByaWdodCA9IF87IGhlaWdodCA9IF8gfVxuICAgICAgICAgIHdoZW4gY29tcGFyZSB2IGtleSA+IDAgLT4gbG9vcCBsIGVcbiAgICAgICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IHY7IGRhdGEgPSBkOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICAgIGxvb3AgciAoTW9yZSAodiwgZCwgbCwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgc3RlcF9kZWVwZXJfZXhuIHRyZWUgZSA9XG4gICAgICBtYXRjaCB0cmVlIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IExlYWYgeyBrZXkgPSB2OyBkYXRhID0gZCB9IC0+IEVtcHR5LCBNb3JlICh2LCBkLCBFbXB0eSwgZSlcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSB2OyBkYXRhID0gZDsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT4gbCwgTW9yZSAodiwgZCwgciwgZSlcbiAgICA7O1xuXG4gICAgKCogW2Ryb3BfcGh5c19lcXVhbF9wcmVmaXggdHJlZTEgYWNjMSB0cmVlMiBhY2MyXSBkcm9wcyB0aGUgbGFyZ2VzdCBwaHlzaWNhbGx5LWVxdWFsXG4gICAgICAgcHJlZml4IG9mIHRyZWUxIGFuZCB0cmVlMiB0aGF0IHRoZXkgc2hhcmUsIGFuZCB0aGVuIHByZXBlbmRzIHRoZSByZW1haW5pbmcgZGF0YVxuICAgICAgIGludG8gYWNjMSBhbmQgYWNjMiwgcmVzcGVjdGl2ZWx5LlxuICAgICAgIFRoaXMgY2FuIGJlIGFzeW1wdG90aWNhbGx5IGZhc3RlciB0aGFuIFtjb25zXSBldmVuIGlmIGl0IHNraXBzIGEgc21hbGwgcHJvcG9ydGlvblxuICAgICAgIG9mIHRoZSB0cmVlIGJlY2F1c2UgW2NvbnNdIGlzIGFsd2F5cyBPKGxvZyhuKSkgaW4gdGhlIHNpemUgb2YgdGhlIHRyZWUsIHdoaWxlXG4gICAgICAgdGhpcyBmdW5jdGlvbiBpcyBPKGxvZyhuL20pKSB3aGVyZSBbbV0gaXMgdGhlIHNpemUgb2YgdGhlIHBhcnQgb2YgdGhlIHRyZWUgdGhhdFxuICAgICAgIGlzIHNraXBwZWQuICopXG4gICAgbGV0IHJlYyBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHRyZWUxIGFjYzEgdHJlZTIgYWNjMiA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHRyZWUxIHRyZWUyXG4gICAgICB0aGVuIGFjYzEsIGFjYzJcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgaDIgPSBoZWlnaHQgdHJlZTIgaW5cbiAgICAgICAgbGV0IGgxID0gaGVpZ2h0IHRyZWUxIGluXG4gICAgICAgIGlmIGgyID0gaDFcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHRyZWUxLCBhY2MxID0gc3RlcF9kZWVwZXJfZXhuIHRyZWUxIGFjYzEgaW5cbiAgICAgICAgICBsZXQgdHJlZTIsIGFjYzIgPSBzdGVwX2RlZXBlcl9leG4gdHJlZTIgYWNjMiBpblxuICAgICAgICAgIGRyb3BfcGh5c19lcXVhbF9wcmVmaXggdHJlZTEgYWNjMSB0cmVlMiBhY2MyKVxuICAgICAgICBlbHNlIGlmIGgyID4gaDFcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHRyZWUyLCBhY2MyID0gc3RlcF9kZWVwZXJfZXhuIHRyZWUyIGFjYzIgaW5cbiAgICAgICAgICBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHRyZWUxIGFjYzEgdHJlZTIgYWNjMilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHRyZWUxLCBhY2MxID0gc3RlcF9kZWVwZXJfZXhuIHRyZWUxIGFjYzEgaW5cbiAgICAgICAgICBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHRyZWUxIGFjYzEgdHJlZTIgYWNjMikpXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IDBcbiAgICAgICAgfCBFbmQsIF8gLT4gLTFcbiAgICAgICAgfCBfLCBFbmQgLT4gMVxuICAgICAgICB8IE1vcmUgKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSAodjIsIGQyLCByMiwgZTIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2RhdGEgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgbGV0IGUxLCBlMiA9IGRyb3BfcGh5c19lcXVhbF9wcmVmaXggcjEgZTEgcjIgZTIgaW5cbiAgICAgICAgICAgICAgbG9vcCBlMSBlMikpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MlxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgY29tcGFyZV9rZXkgZGF0YV9lcXVhbCB0MSB0MiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IHRydWVcbiAgICAgICAgfCBFbmQsIF8gfCBfLCBFbmQgLT4gZmFsc2VcbiAgICAgICAgfCBNb3JlICh2MSwgZDEsIHIxLCBlMSksIE1vcmUgKHYyLCBkMiwgcjIsIGUyKSAtPlxuICAgICAgICAgIGNvbXBhcmVfa2V5IHYxIHYyID0gMFxuICAgICAgICAgICYmIGRhdGFfZXF1YWwgZDEgZDJcbiAgICAgICAgICAmJlxuICAgICAgICAgIGxldCBlMSwgZTIgPSBkcm9wX3BoeXNfZXF1YWxfcHJlZml4IHIxIGUxIHIyIGUyIGluXG4gICAgICAgICAgbG9vcCBlMSBlMlxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDJcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBmb2xkIH5pbml0IH5mID0gZnVuY3Rpb25cbiAgICAgIHwgRW5kIC0+IGluaXRcbiAgICAgIHwgTW9yZSAoa2V5LCBkYXRhLCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICBsZXQgbmV4dCA9IGYgfmtleSB+ZGF0YSBpbml0IGluXG4gICAgICAgIGZvbGQgKGNvbnMgdHJlZSBlbnVtKSB+aW5pdDpuZXh0IH5mXG4gICAgOztcblxuICAgIGxldCBmb2xkMiBjb21wYXJlX2tleSB0MSB0MiB+aW5pdCB+ZiA9XG4gICAgICBsZXQgcmVjIGxvb3AgdDEgdDIgY3VyciA9XG4gICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gY3VyclxuICAgICAgICB8IEVuZCwgXyAtPlxuICAgICAgICAgIGZvbGQgdDIgfmluaXQ6Y3VyciB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGYgfmtleSB+ZGF0YTooYFJpZ2h0IGRhdGEpIGFjYykgW0Bub250YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgfCBfLCBFbmQgLT5cbiAgICAgICAgICBmb2xkIHQxIH5pbml0OmN1cnIgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBmIH5rZXkgfmRhdGE6KGBMZWZ0IGRhdGEpIGFjYykgW0Bub250YWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICB8IE1vcmUgKGsxLCB2MSwgdHJlZTEsIGVudW0xKSwgTW9yZSAoazIsIHYyLCB0cmVlMiwgZW51bTIpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9rZXkgazEgazIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZiB+a2V5OmsxIH5kYXRhOihgQm90aCAodjEsIHYyKSkgY3VyciBpblxuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgKGNvbnMgdHJlZTIgZW51bTIpIG5leHQpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZiB+a2V5OmsxIH5kYXRhOihgTGVmdCB2MSkgY3VyciBpblxuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgdDIgbmV4dClcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZiB+a2V5OmsyIH5kYXRhOihgUmlnaHQgdjIpIGN1cnIgaW5cbiAgICAgICAgICAgIGxvb3AgdDEgKGNvbnMgdHJlZTIgZW51bTIpIG5leHQpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MiBpbml0IFtAbm9udGFpbF1cbiAgICA7O1xuXG4gICAgbGV0IHN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCA9XG4gICAgICBsZXQgc3RlcCBzdGF0ZSA9XG4gICAgICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgICAgfCBFbmQsIE1vcmUgKGtleSwgZGF0YSwgdHJlZSwgZW51bSkgLT5cbiAgICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkIHsgdmFsdWUgPSBrZXksIGBSaWdodCBkYXRhOyBzdGF0ZSA9IEVuZCwgY29ucyB0cmVlIGVudW0gfVxuICAgICAgICB8IE1vcmUgKGtleSwgZGF0YSwgdHJlZSwgZW51bSksIEVuZCAtPlxuICAgICAgICAgIFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IGtleSwgYExlZnQgZGF0YTsgc3RhdGUgPSBjb25zIHRyZWUgZW51bSwgRW5kIH1cbiAgICAgICAgfCAoTW9yZSAoazEsIHYxLCB0cmVlMSwgZW51bTEpIGFzIGxlZnQpLCAoTW9yZSAoazIsIHYyLCB0cmVlMiwgZW51bTIpIGFzIHJpZ2h0KSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfa2V5IGsxIGsyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmV4dF9zdGF0ZSA9IGRyb3BfcGh5c19lcXVhbF9wcmVmaXggdHJlZTEgZW51bTEgdHJlZTIgZW51bTIgaW5cbiAgICAgICAgICAgIGlmIGRhdGFfZXF1YWwgdjEgdjJcbiAgICAgICAgICAgIHRoZW4gU2VxdWVuY2UuU3RlcC5Ta2lwIHsgc3RhdGUgPSBuZXh0X3N0YXRlIH1cbiAgICAgICAgICAgIGVsc2UgU2VxdWVuY2UuU3RlcC5ZaWVsZCB7IHZhbHVlID0gazEsIGBVbmVxdWFsICh2MSwgdjIpOyBzdGF0ZSA9IG5leHRfc3RhdGUgfSlcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgIFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IGsxLCBgTGVmdCB2MTsgc3RhdGUgPSBjb25zIHRyZWUxIGVudW0xLCByaWdodCB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgU2VxdWVuY2UuU3RlcC5ZaWVsZCB7IHZhbHVlID0gazIsIGBSaWdodCB2Mjsgc3RhdGUgPSBsZWZ0LCBjb25zIHRyZWUyIGVudW0yIH1cbiAgICAgIGluXG4gICAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdDooZHJvcF9waHlzX2VxdWFsX3ByZWZpeCB0MSBFbmQgdDIgRW5kKSB+ZjpzdGVwXG4gICAgOztcblxuICAgIGxldCBmb2xkX3N5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgICBsZXQgYWRkIGFjYyBrIHYgPSBmIGFjYyAoaywgYFJpZ2h0IHYpIGluXG4gICAgICBsZXQgcmVtb3ZlIGFjYyBrIHYgPSBmIGFjYyAoaywgYExlZnQgdikgaW5cbiAgICAgIGxldCByZWMgbG9vcCBsZWZ0IHJpZ2h0IGFjYyA9XG4gICAgICAgIG1hdGNoIGxlZnQsIHJpZ2h0IHdpdGhcbiAgICAgICAgfCBFbmQsIGVudW0gLT5cbiAgICAgICAgICBmb2xkIGVudW0gfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gYWRkIGFjYyBrZXkgZGF0YSkgW0Bub250YWlsXVxuICAgICAgICB8IGVudW0sIEVuZCAtPlxuICAgICAgICAgIGZvbGQgZW51bSB+aW5pdDphY2MgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiByZW1vdmUgYWNjIGtleSBkYXRhKSBbQG5vbnRhaWxdXG4gICAgICAgIHwgKE1vcmUgKGsxLCB2MSwgdHJlZTEsIGVudW0xKSBhcyBsZWZ0KSwgKE1vcmUgKGsyLCB2MiwgdHJlZTIsIGVudW0yKSBhcyByaWdodCkgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2tleSBrMSBrMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IGFjYyA9IGlmIGRhdGFfZXF1YWwgdjEgdjIgdGhlbiBhY2MgZWxzZSBmIGFjYyAoazEsIGBVbmVxdWFsICh2MSwgdjIpKSBpblxuICAgICAgICAgICAgbGV0IGVudW0xLCBlbnVtMiA9IGRyb3BfcGh5c19lcXVhbF9wcmVmaXggdHJlZTEgZW51bTEgdHJlZTIgZW51bTIgaW5cbiAgICAgICAgICAgIGxvb3AgZW51bTEgZW51bTIgYWNjKVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgYWNjID0gcmVtb3ZlIGFjYyBrMSB2MSBpblxuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgcmlnaHQgYWNjKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGFjYyA9IGFkZCBhY2MgazIgdjIgaW5cbiAgICAgICAgICAgIGxvb3AgbGVmdCAoY29ucyB0cmVlMiBlbnVtMikgYWNjKVxuICAgICAgaW5cbiAgICAgIGxldCBsZWZ0LCByaWdodCA9IGRyb3BfcGh5c19lcXVhbF9wcmVmaXggdDEgRW5kIHQyIEVuZCBpblxuICAgICAgbG9vcCBsZWZ0IHJpZ2h0IGluaXQgW0Bub250YWlsXVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHYsIHQsIGUpIC0+XG4gICAgICAgIFNlcXVlbmNlLlN0ZXAuWWllbGQgeyB2YWx1ZSA9IGssIHY7IHN0YXRlID0gRW51bS5jb25zIHQgZSB9XG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2tleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl90cmVlIHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9pbmNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXkgdCA9XG4gICAgbGV0IG5leHQgZW51bSA9XG4gICAgICBtYXRjaCBlbnVtIHdpdGhcbiAgICAgIHwgRW51bS5FbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICB8IEVudW0uTW9yZSAoaywgdiwgdCwgZSkgLT5cbiAgICAgICAgU2VxdWVuY2UuU3RlcC5ZaWVsZCB7IHZhbHVlID0gaywgdjsgc3RhdGUgPSBFbnVtLmNvbnNfcmlnaHQgdCBlIH1cbiAgICBpblxuICAgIGxldCBpbml0ID1cbiAgICAgIG1hdGNoIGZyb21fa2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBFbnVtLm9mX3RyZWVfcmlnaHQgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2RlY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VcbiAgICBjb21wYXJhdG9yXG4gICAgPyhvcmRlciA9IGBJbmNyZWFzaW5nX2tleSlcbiAgICA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgP2tleXNfbGVzc19vcl9lcXVhbF90b1xuICAgIHRcbiAgICA9XG4gICAgbGV0IGluY2x1c2l2ZV9ib3VuZCBzaWRlIHQgYm91bmQgPVxuICAgICAgbGV0IGNvbXBhcmVfa2V5ID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICAgIGxldCBsLCBtYXliZSwgciA9IHNwbGl0IHQgYm91bmQgfmNvbXBhcmVfa2V5IGluXG4gICAgICBsZXQgdCA9IHNpZGUgKGwsIHIpIGluXG4gICAgICBtYXRjaCBtYXliZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gdFxuICAgICAgfCBTb21lIChrZXksIGRhdGEpIC0+IHNldCcgdCBrZXkgZGF0YSB+Y29tcGFyZV9rZXlcbiAgICBpblxuICAgIG1hdGNoIG9yZGVyIHdpdGhcbiAgICB8IGBJbmNyZWFzaW5nX2tleSAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBrZXlzX2xlc3Nfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIGZzdCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2luY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXk6a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvIHRcbiAgICB8IGBEZWNyZWFzaW5nX2tleSAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIHNuZCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXk6a2V5c19sZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuICBsZXQgY29tcGFyZSBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIGxldCBlMSwgZTIgPSBFbnVtLmRyb3BfcGh5c19lcXVhbF9wcmVmaXggdDEgRW5kIHQyIEVuZCBpblxuICAgIEVudW0uY29tcGFyZSBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgZTEgZTJcbiAgOztcblxuICBsZXQgZXF1YWwgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBsZXQgZTEsIGUyID0gRW51bS5kcm9wX3BoeXNfZXF1YWxfcHJlZml4IHQxIEVuZCB0MiBFbmQgaW5cbiAgICBFbnVtLmVxdWFsIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSBlMSBlMlxuICA7O1xuXG4gIGxldCBpdGVyMiB0MSB0MiB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIEVudW0uZm9sZDJcbiAgICAgIGNvbXBhcmVfa2V5XG4gICAgICAoRW51bS5vZl90cmVlIHQxKVxuICAgICAgKEVudW0ub2ZfdHJlZSB0MilcbiAgICAgIH5pbml0OigpXG4gICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgKCkgLT4gZiB+a2V5IH5kYXRhKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZvbGQyIHQxIHQyIH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgRW51bS5mb2xkMiBjb21wYXJlX2tleSAoRW51bS5vZl90cmVlIHQxKSAoRW51bS5vZl90cmVlIHQyKSB+ZiB+aW5pdFxuICA7O1xuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiA9IEVudW0uc3ltbWV0cmljX2RpZmZcblxuICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgfmluaXQgfmYgPVxuICAgICgqIFtFbnVtLmZvbGRfZGlmZnNdIGlzIGEgY29ycmVjdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLCBidXQgaXMgY29uc2lkZXJhYmx5XG4gICAgICAgc2xvd2VyLCBhcyB3ZSBoYXZlIHRvIGFsbG9jYXRlIHF1aXRlIGEgbG90IG9mIHN0YXRlIHRvIHRyYWNrIGVudW1lcmF0aW9uIG9mIGEgdHJlZS5cbiAgICAgICBBdm9pZCBpZiB3ZSBjYW4uXG4gICAgKilcbiAgICBsZXQgc2xvdyB4IHkgfmluaXQgPSBFbnVtLmZvbGRfc3ltbWV0cmljX2RpZmYgeCB5IH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCB+ZiB+aW5pdCBpblxuICAgIGxldCBhZGQgYWNjIGsgdiA9IGYgYWNjIChrLCBgUmlnaHQgdikgaW5cbiAgICBsZXQgcmVtb3ZlIGFjYyBrIHYgPSBmIGFjYyAoaywgYExlZnQgdikgaW5cbiAgICBsZXQgZGVsdGEgYWNjIGsgdiB2JyA9IGlmIGRhdGFfZXF1YWwgdiB2JyB0aGVuIGFjYyBlbHNlIGYgYWNjIChrLCBgVW5lcXVhbCAodiwgdicpKSBpblxuICAgICgqIElmIHR3byB0cmVlcyBoYXZlIHRoZSBzYW1lIHN0cnVjdHVyZSBhdCB0aGUgcm9vdCAoYW5kIHRoZSBzYW1lIGtleSwgaWYgdGhleSdyZVxuICAgICAgIFtOb2RlXXMpIHdlIGNhbiB0cml2aWFsbHkgZGlmZiBlYWNoIHN1YnBhcnQgaW4gb2J2aW91cyB3YXlzLiAqKVxuICAgIGxldCByZWMgbG9vcCB0IHQnIGFjYyA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHQgdCdcbiAgICAgIHRoZW4gYWNjXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggdCwgdCcgd2l0aFxuICAgICAgICB8IEVtcHR5LCBuZXdfdmFscyAtPlxuICAgICAgICAgIGZvbGQgbmV3X3ZhbHMgfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gYWRkIGFjYyBrZXkgZGF0YSkgW0Bub250YWlsXVxuICAgICAgICB8IG9sZF92YWxzLCBFbXB0eSAtPlxuICAgICAgICAgIGZvbGQgb2xkX3ZhbHMgfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gcmVtb3ZlIGFjYyBrZXkgZGF0YSkgW0Bub250YWlsXVxuICAgICAgICB8IExlYWYgeyBrZXkgPSBrOyBkYXRhID0gdiB9LCBMZWFmIHsga2V5ID0gayc7IGRhdGEgPSB2JyB9IC0+XG4gICAgICAgICAgKG1hdGNoIGNvbXBhcmVfa2V5IGsgaycgd2l0aFxuICAgICAgICAgICB8IHggd2hlbiB4ID0gMCAtPiBkZWx0YSBhY2MgayB2IHYnXG4gICAgICAgICAgIHwgeCB3aGVuIHggPCAwIC0+XG4gICAgICAgICAgICAgbGV0IGFjYyA9IHJlbW92ZSBhY2MgayB2IGluXG4gICAgICAgICAgICAgYWRkIGFjYyBrJyB2J1xuICAgICAgICAgICB8IF8gKCogd2hlbiB4ID4gMCAqKSAtPlxuICAgICAgICAgICAgIGxldCBhY2MgPSBhZGQgYWNjIGsnIHYnIGluXG4gICAgICAgICAgICAgcmVtb3ZlIGFjYyBrIHYpXG4gICAgICAgIHwgKCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IGs7IGRhdGEgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF8gfVxuICAgICAgICAgICwgTm9kZSB7IGxlZnQgPSBsJzsga2V5ID0gayc7IGRhdGEgPSB2JzsgcmlnaHQgPSByJzsgaGVpZ2h0ID0gXyB9IClcbiAgICAgICAgICB3aGVuIGNvbXBhcmVfa2V5IGsgaycgPSAwIC0+XG4gICAgICAgICAgbGV0IGFjYyA9IGxvb3AgbCBsJyBhY2MgaW5cbiAgICAgICAgICBsZXQgYWNjID0gZGVsdGEgYWNjIGsgdiB2JyBpblxuICAgICAgICAgIGxvb3AgciByJyBhY2NcbiAgICAgICAgKCogT3VyIHJvb3RzIGFyZW4ndCB0aGUgc2FtZSBrZXkuIEZhbGxiYWNrIHRvIHRoZSBzbG93IG1vZGUuIFRyZWVzIHdpdGggc21hbGxcbiAgICAgICAgICAgZGlmZnMgd2lsbCBvbmx5IGRvIHRoaXMgb24gdmVyeSBzbWFsbCBwYXJ0cyBvZiB0aGUgdHJlZSAoaG9wZWZ1bGx5IC0gaWYgdGhlXG4gICAgICAgICAgIG92ZXJhbGwgcm9vdCBpcyByZWJhbGFuY2VkLCB3ZSdsbCBlYXQgdGhlIHdob2xlIGNvc3QsIHVuZm9ydHVuYXRlbHkuKSAqKVxuICAgICAgICB8IE5vZGUgXywgTm9kZSBfIHwgTm9kZSBfLCBMZWFmIF8gfCBMZWFmIF8sIE5vZGUgXyAtPiBzbG93IHQgdCcgfmluaXQ6YWNjKVxuICAgIGluXG4gICAgbG9vcCB0MSB0MiBpbml0IFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgcmVjIGxlbmd0aCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIF8gLT4gMVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBfOyBkYXRhID0gXzsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGxlbmd0aCBsICsgbGVuZ3RoIHIgKyAxXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF90X2lnbm9yaW5nX3N0cnVjdHVyZSBoYXNoX2ZvbGRfa2V5IGhhc2hfZm9sZF9kYXRhIHN0YXRlIHQgPVxuICAgIGZvbGRcbiAgICAgIHRcbiAgICAgIH5pbml0OihoYXNoX2ZvbGRfaW50IHN0YXRlIChsZW5ndGggdCkpXG4gICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgc3RhdGUgLT4gaGFzaF9mb2xkX2RhdGEgKGhhc2hfZm9sZF9rZXkgc3RhdGUga2V5KSBkYXRhKVxuICA7O1xuXG4gIGxldCBrZXlzIHQgPSBmb2xkX3JpZ2h0IH5mOihmdW4gfmtleSB+ZGF0YTpfIGxpc3QgLT4ga2V5IDo6IGxpc3QpIHQgfmluaXQ6W11cbiAgbGV0IGRhdGEgdCA9IGZvbGRfcmlnaHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgbGlzdCAtPiBkYXRhIDo6IGxpc3QpIHQgfmluaXQ6W11cblxuICBtb2R1bGUgdHlwZSBGb2xkYWJsZSA9IHNpZ1xuICAgIHZhbCBuYW1lIDogc3RyaW5nXG5cbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidhY2MgLT4gZjooJ2FjYyAtPiAnYSAtPiAnYWNjKSAtPiAnYWNjXG4gIGVuZFxuXG4gIGxldFtAaW5saW5lIGFsd2F5c10gb2ZfZm9sZGFibGUnIH5mb2xkIGZvbGRhYmxlIH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgKGZvbGQgW0BpbmxpbmVkIGhpbnRdKVxuICAgICAgZm9sZGFibGVcbiAgICAgIH5pbml0Oih3aXRoX2xlbmd0aF9nbG9iYWwgZW1wdHkgMClcbiAgICAgIH5mOihmdW4geyB0cmVlID0gYWNjdW07IGxlbmd0aCB9IChrZXksIGRhdGEpIC0+XG4gICAgICBsZXQgcHJldl9kYXRhID1cbiAgICAgICAgbWF0Y2ggZmluZCBhY2N1bSBrZXkgfmNvbXBhcmVfa2V5IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGluaXRcbiAgICAgICAgfCBTb21lIHByZXYgLT4gcHJldlxuICAgICAgaW5cbiAgICAgIGxldCBkYXRhID0gZiBwcmV2X2RhdGEgZGF0YSBpblxuICAgICAgKHNldCBhY2N1bSB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IHw+IGdsb2JhbGl6ZSkgW0Bub250YWlsXSkgW0Bub250YWlsXVxuICA7O1xuXG4gIG1vZHVsZSBPZl9mb2xkYWJsZSAoTSA6IEZvbGRhYmxlKSA9IHN0cnVjdFxuICAgIGxldCBvZl9mb2xkYWJsZV9mb2xkIGZvbGRhYmxlIH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBvZl9mb2xkYWJsZScgfmZvbGQ6TS5mb2xkIGZvbGRhYmxlIH5pbml0IH5mIH5jb21wYXJlX2tleVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGVfcmVkdWNlIGZvbGRhYmxlIH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBNLmZvbGRcbiAgICAgICAgZm9sZGFibGVcbiAgICAgICAgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwKVxuICAgICAgICB+ZjooZnVuIHsgdHJlZSA9IGFjY3VtOyBsZW5ndGggfSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICBsZXQgbmV3X2RhdGEgPVxuICAgICAgICAgIG1hdGNoIGZpbmQgYWNjdW0ga2V5IH5jb21wYXJlX2tleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGRhdGFcbiAgICAgICAgICB8IFNvbWUgcHJldiAtPiBmIHByZXYgZGF0YVxuICAgICAgICBpblxuICAgICAgICAoc2V0IGFjY3VtIH5sZW5ndGggfmtleSB+ZGF0YTpuZXdfZGF0YSB+Y29tcGFyZV9rZXkgfD4gZ2xvYmFsaXplKSBbQG5vbnRhaWxdKSBbQG5vbnRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZSBmb2xkYWJsZSB+Y29tcGFyZV9rZXkgPVxuICAgICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICAgIGxldCBtYXAgPVxuICAgICAgICAgIE0uZm9sZFxuICAgICAgICAgICAgZm9sZGFibGVcbiAgICAgICAgICAgIH5pbml0Oih3aXRoX2xlbmd0aF9nbG9iYWwgZW1wdHkgMClcbiAgICAgICAgICAgIH5mOihmdW4geyB0cmVlID0gdDsgbGVuZ3RoIH0gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgIGxldCAoeyB0cmVlID0gXzsgbGVuZ3RoID0gbGVuZ3RoJyB9IGFzIGFjYykgPVxuICAgICAgICAgICAgICBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIHQgfmNvbXBhcmVfa2V5XG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgaWYgbGVuZ3RoID0gbGVuZ3RoJ1xuICAgICAgICAgICAgdGhlbiByLnJldHVybiAoYER1cGxpY2F0ZV9rZXkga2V5KVxuICAgICAgICAgICAgZWxzZSBnbG9iYWxpemUgYWNjIFtAbm9udGFpbF0pXG4gICAgICAgIGluXG4gICAgICAgIGBPayBtYXApXG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZV9vcl9lcnJvciBmb2xkYWJsZSB+Y29tcGFyYXRvciA9XG4gICAgICBtYXRjaCBvZl9mb2xkYWJsZSBmb2xkYWJsZSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgICAgfCBgT2sgeCAtPiBSZXN1bHQuT2sgeFxuICAgICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgICAgT3JfZXJyb3IuZXJyb3JcbiAgICAgICAgICAoXCJNYXAub2ZfXCIgXiBNLm5hbWUgXiBcIl9vcl9lcnJvcjogZHVwbGljYXRlIGtleVwiKVxuICAgICAgICAgIGtleVxuICAgICAgICAgIGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZV9leG4gZm9sZGFibGUgfmNvbXBhcmF0b3IgPVxuICAgICAgbWF0Y2ggb2ZfZm9sZGFibGUgZm9sZGFibGUgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICAgIHwgYE9rIHggLT4geFxuICAgICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgICAgRXJyb3IuY3JlYXRlIChcIk1hcC5vZl9cIiBeIE0ubmFtZSBeIFwiX2V4bjogZHVwbGljYXRlIGtleVwiKSBrZXkgY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICAgICAgfD4gRXJyb3IucmFpc2VcbiAgICA7O1xuXG4gICAgKCogUmV2ZXJzZSB0aGUgaW5wdXQsIHRoZW4gZm9sZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFRoZSByZXN1bHRpbmcgbWFwIHVzZXMgdGhlIGZpcnN0XG4gICAgICAgaW5zdGFuY2Ugb2YgZWFjaCBrZXkgZnJvbSB0aGUgaW5wdXQgbGlzdC4gVGhlIHJlbGF0aXZlIG9yZGVyaW5nIG9mIGVsZW1lbnRzIGluIGVhY2hcbiAgICAgICBvdXRwdXQgbGlzdCBpcyB0aGUgc2FtZSBhcyBpbiB0aGUgaW5wdXQgbGlzdC4gKilcbiAgICBsZXQgb2ZfZm9sZGFibGVfbXVsdGkgZm9sZGFibGUgfmNvbXBhcmVfa2V5ID1cbiAgICAgIGxldCBhbGlzdCA9IE0uZm9sZCBmb2xkYWJsZSB+aW5pdDpbXSB+ZjooZnVuIGwgeCAtPiB4IDo6IGwpIGluXG4gICAgICBvZl9mb2xkYWJsZScgYWxpc3QgfmZvbGQ6TGlzdC5mb2xkIH5pbml0OltdIH5mOihmdW4gbCB4IC0+IHggOjogbCkgfmNvbXBhcmVfa2V5XG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIE9mX2FsaXN0ID0gT2ZfZm9sZGFibGUgKHN0cnVjdFxuICAgIGxldCBuYW1lID0gXCJhbGlzdFwiXG5cbiAgICB0eXBlICdhIHQgPSAnYSBsaXN0XG5cbiAgICBsZXQgZm9sZCA9IExpc3QuZm9sZFxuICBlbmQpXG5cbiAgbGV0IG9mX2FsaXN0X2ZvbGQgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9mb2xkXG4gIGxldCBvZl9hbGlzdF9yZWR1Y2UgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9yZWR1Y2VcbiAgbGV0IG9mX2FsaXN0ID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVcbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfb3JfZXJyb3JcbiAgbGV0IG9mX2FsaXN0X2V4biA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlX2V4blxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9tdWx0aVxuXG4gIG1vZHVsZSBPZl9zZXF1ZW5jZSA9IE9mX2ZvbGRhYmxlIChzdHJ1Y3RcbiAgICBsZXQgbmFtZSA9IFwic2VxdWVuY2VcIlxuXG4gICAgdHlwZSAnYSB0ID0gJ2EgU2VxdWVuY2UudFxuXG4gICAgbGV0IGZvbGQgPSBTZXF1ZW5jZS5mb2xkXG4gIGVuZClcblxuICBsZXQgb2Zfc2VxdWVuY2VfZm9sZCA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX2ZvbGRcbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX3JlZHVjZVxuICBsZXQgb2Zfc2VxdWVuY2UgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZVxuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9vcl9lcnJvclxuICBsZXQgb2Zfc2VxdWVuY2VfZXhuID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVfZXhuXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX211bHRpXG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXkgbGlzdCB+Z2V0X2tleSB+Y29tcGFyZV9rZXkgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgbGV0IG1hcCA9XG4gICAgICAgIExpc3QuZm9sZFxuICAgICAgICAgIGxpc3RcbiAgICAgICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIGVtcHR5IDApXG4gICAgICAgICAgfmY6KGZ1biB7IHRyZWUgPSB0OyBsZW5ndGggfSBkYXRhIC0+XG4gICAgICAgICAgbGV0IGtleSA9IGdldF9rZXkgZGF0YSBpblxuICAgICAgICAgIGxldCAoeyB0cmVlID0gXzsgbGVuZ3RoID0gbmV3X2xlbmd0aCB9IGFzIGFjYykgPVxuICAgICAgICAgICAgc2V0IH5sZW5ndGggfmtleSB+ZGF0YSB0IH5jb21wYXJlX2tleVxuICAgICAgICAgIGluXG4gICAgICAgICAgaWYgbGVuZ3RoID0gbmV3X2xlbmd0aFxuICAgICAgICAgIHRoZW4gci5yZXR1cm4gKGBEdXBsaWNhdGVfa2V5IGtleSlcbiAgICAgICAgICBlbHNlIGdsb2JhbGl6ZSBhY2MgW0Bub250YWlsXSlcbiAgICAgIGluXG4gICAgICBgT2sgbWFwKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3IgbGlzdCB+Z2V0X2tleSB+Y29tcGFyYXRvciA9XG4gICAgbWF0Y2ggb2ZfbGlzdF93aXRoX2tleSBsaXN0IH5nZXRfa2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgT2sgeCAtPiBSZXN1bHQuT2sgeFxuICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICBPcl9lcnJvci5lcnJvclxuICAgICAgICBcIk1hcC5vZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yOiBkdXBsaWNhdGUga2V5XCJcbiAgICAgICAga2V5XG4gICAgICAgIGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfZXhuIGxpc3QgfmdldF9rZXkgfmNvbXBhcmF0b3IgPVxuICAgIG1hdGNoIG9mX2xpc3Rfd2l0aF9rZXkgbGlzdCB+Z2V0X2tleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rIHggLT4geFxuICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICBFcnJvci5jcmVhdGUgXCJNYXAub2ZfbGlzdF93aXRoX2tleV9leG46IGR1cGxpY2F0ZSBrZXlcIiBrZXkgY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICAgIHw+IEVycm9yLnJhaXNlXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkgbGlzdCB+Z2V0X2tleSB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBsaXN0ID0gTGlzdC5yZXYgbGlzdCBpblxuICAgIExpc3QuZm9sZCBsaXN0IH5pbml0Oih3aXRoX2xlbmd0aF9nbG9iYWwgZW1wdHkgMCkgfmY6KGZ1biB7IHRyZWUgPSB0OyBsZW5ndGggfSBkYXRhIC0+XG4gICAgICBsZXQga2V5ID0gZ2V0X2tleSBkYXRhIGluXG4gICAgICAodXBkYXRlIHQga2V5IH5sZW5ndGggfmNvbXBhcmVfa2V5IH5mOihmdW4gb3B0aW9uIC0+XG4gICAgICAgICBsZXQgbGlzdCA9IE9wdGlvbi52YWx1ZSBvcHRpb24gfmRlZmF1bHQ6W10gaW5cbiAgICAgICAgIGRhdGEgOjogbGlzdClcbiAgICAgICB8PiBnbG9iYWxpemUpIFtAbm9udGFpbF0pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleV9mb2xkIGxpc3QgfmdldF9rZXkgfmluaXQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBMaXN0LmZvbGQgbGlzdCB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIGVtcHR5IDApIH5mOihmdW4geyB0cmVlID0gdDsgbGVuZ3RoIH0gZGF0YSAtPlxuICAgICAgbGV0IGtleSA9IGdldF9rZXkgZGF0YSBpblxuICAgICAgKHVwZGF0ZSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgIHwgTm9uZSAtPiBmIGluaXQgZGF0YVxuICAgICAgICAgfCBTb21lIHByZXYgLT4gZiBwcmV2IGRhdGEpXG4gICAgICAgfD4gZ2xvYmFsaXplKSBbQG5vbnRhaWxdKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfcmVkdWNlIGxpc3QgfmdldF9rZXkgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBMaXN0LmZvbGQgbGlzdCB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIGVtcHR5IDApIH5mOihmdW4geyB0cmVlID0gdDsgbGVuZ3RoIH0gZGF0YSAtPlxuICAgICAgbGV0IGtleSA9IGdldF9rZXkgZGF0YSBpblxuICAgICAgKHVwZGF0ZSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgIHwgTm9uZSAtPiBkYXRhXG4gICAgICAgICB8IFNvbWUgcHJldiAtPiBmIHByZXYgZGF0YSlcbiAgICAgICB8PiBnbG9iYWxpemUpIFtAbm9udGFpbF0pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZm9yX2FsbCB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXIgdCB+ZjooZnVuIGRhdGEgLT4gaWYgbm90IChmIGRhdGEpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgICAgdHJ1ZSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmb3JfYWxsaSB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIG5vdCAoZiB+a2V5IH5kYXRhKSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICAgIHRydWUpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZXhpc3RzIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlciB0IH5mOihmdW4gZGF0YSAtPiBpZiBmIGRhdGEgdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICAgIGZhbHNlKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGV4aXN0c2kgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICAgIGZhbHNlKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGNvdW50IHQgfmYgPVxuICAgIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleTpfIH5kYXRhIGFjYyAtPiBpZiBmIGRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGNvdW50aSB0IH5mID1cbiAgICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpIFtAbm9udGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gIDs7XG5cbiAgbGV0IHN1bSAodHlwZSBhKSAobW9kdWxlIE0gOiBDb250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSBhKSB0IH5mID1cbiAgICBmb2xkIHQgfmluaXQ6TS56ZXJvIH5mOihmdW4gfmtleTpfIH5kYXRhIGFjYyAtPiBNLiggKyApIChmIGRhdGEpIGFjYykgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBzdW1pICh0eXBlIGEpIChtb2R1bGUgTSA6IENvbnRhaW5lci5TdW1tYWJsZSB3aXRoIHR5cGUgdCA9IGEpIHQgfmYgPVxuICAgIGZvbGQgdCB+aW5pdDpNLnplcm8gfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBNLiggKyApIChmIH5rZXkgfmRhdGEpIGFjYykgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCB0b19hbGlzdCA/KGtleV9vcmRlciA9IGBJbmNyZWFzaW5nKSB0ID1cbiAgICBtYXRjaCBrZXlfb3JkZXIgd2l0aFxuICAgIHwgYEluY3JlYXNpbmcgLT4gZm9sZF9yaWdodCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSB4IC0+IChrZXksIGRhdGEpIDo6IHgpXG4gICAgfCBgRGVjcmVhc2luZyAtPiBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIHggLT4gKGtleSwgZGF0YSkgOjogeClcbiAgOztcblxuICBsZXQgbWVyZ2UgdDEgdDIgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgZWx0cyA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW46KGxlbmd0aCB0MSArIGxlbmd0aCB0MikgaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgaXRlcjIgdDEgdDIgfmNvbXBhcmVfa2V5IH5mOihmdW4gfmtleSB+ZGF0YTp2YWx1ZXMgLT5cbiAgICAgIG1hdGNoIGYgfmtleSB2YWx1ZXMgd2l0aFxuICAgICAgfCBTb21lIHZhbHVlIC0+XG4gICAgICAgIFVuaWZvcm1fYXJyYXkuc2V0IGVsdHMgIWkgKGtleSwgdmFsdWUpO1xuICAgICAgICBpbmNyIGlcbiAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgbGV0IGxlbiA9ICFpIGluXG4gICAgbGV0IGdldCBpID0gVW5pZm9ybV9hcnJheS5nZXQgZWx0cyBpIGluXG4gICAgbGV0IHRyZWUgPSBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mOmdldCBpblxuICAgIHdpdGhfbGVuZ3RoIHRyZWUgbGVuXG4gIDs7XG5cbiAgbGV0IG1lcmdlX3NrZXdlZCA9XG4gICAgbGV0IG1lcmdlX2xhcmdlX2ZpcnN0IGxlbmd0aF9sYXJnZSB0X2xhcmdlIHRfc21hbGwgfmNhbGwgfmNvbWJpbmUgfmNvbXBhcmVfa2V5ID1cbiAgICAgIGZvbGRcbiAgICAgICAgdF9zbWFsbFxuICAgICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIHRfbGFyZ2UgbGVuZ3RoX2xhcmdlKVxuICAgICAgICB+ZjooZnVuIH5rZXkgfmRhdGE6ZGF0YScgeyB0cmVlID0gdDsgbGVuZ3RoIH0gLT5cbiAgICAgICAgKHVwZGF0ZSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgfCBOb25lIC0+IGRhdGEnXG4gICAgICAgICAgIHwgU29tZSBkYXRhIC0+IGNhbGwgY29tYmluZSB+a2V5IGRhdGEgZGF0YScpXG4gICAgICAgICB8PiBnbG9iYWxpemUpIFtAbm9udGFpbF0pIFtAbm9udGFpbF1cbiAgICBpblxuICAgIGxldCBjYWxsIGYgfmtleSB4IHkgPSBmIH5rZXkgeCB5IGluXG4gICAgbGV0IHN3YXAgZiB+a2V5IHggeSA9IGYgfmtleSB5IHggaW5cbiAgICBmdW4gdDEgdDIgfmxlbmd0aDEgfmxlbmd0aDIgfmNvbWJpbmUgfmNvbXBhcmVfa2V5IC0+XG4gICAgICBpZiBsZW5ndGgyIDw9IGxlbmd0aDFcbiAgICAgIHRoZW4gbWVyZ2VfbGFyZ2VfZmlyc3QgbGVuZ3RoMSB0MSB0MiB+Y2FsbCB+Y29tYmluZSB+Y29tcGFyZV9rZXlcbiAgICAgIGVsc2UgbWVyZ2VfbGFyZ2VfZmlyc3QgbGVuZ3RoMiB0MiB0MSB+Y2FsbDpzd2FwIH5jb21iaW5lIH5jb21wYXJlX2tleVxuICA7O1xuXG4gIGxldCBtZXJnZV9kaXNqb2ludF9leG4gdDEgdDIgfmxlbmd0aDEgfmxlbmd0aDIgfihjb21wYXJhdG9yIDogXyBDb21wYXJhdG9yLnQpID1cbiAgICBtZXJnZV9za2V3ZWRcbiAgICAgIHQxXG4gICAgICB0MlxuICAgICAgfmxlbmd0aDFcbiAgICAgIH5sZW5ndGgyXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5jb21wYXJlXG4gICAgICB+Y29tYmluZTooZnVuIH5rZXkgXyBfIC0+XG4gICAgICBFcnJvci5jcmVhdGUgXCJNYXAubWVyZ2VfZGlzam9pbnRfZXhuOiBkdXBsaWNhdGUga2V5XCIga2V5IGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgICB8PiBFcnJvci5yYWlzZSlcbiAgOztcblxuICBtb2R1bGUgQ2xvc2VzdF9rZXlfaW1wbCA9IHN0cnVjdFxuICAgICgqIFttYXJrZXJdIGFuZCBbcmVwYWNrYWdlXSBhbGxvdyB1cyB0byBjcmVhdGUgXCJsb2dpY2FsXCIgb3B0aW9ucyB3aXRob3V0IGFjdHVhbGx5XG4gICAgICAgYWxsb2NhdGluZyBhbnkgb3B0aW9ucy4gUGFzc2luZyBbRm91bmQga2V5IHZhbHVlXSB0byBhIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICBwYXNzaW5nIFtTb21lIChrZXksIHZhbHVlKV07IHBhc3NpbmcgW01pc3NpbmcgKCkgKCldIGlzIGVxdWl2YWxlbnQgdG8gcGFzc2luZ1xuICAgICAgIFtOb25lXS4gKilcbiAgICB0eXBlICgnaywgJ3YsICdrX29wdCwgJ3Zfb3B0KSBtYXJrZXIgPVxuICAgICAgfCBNaXNzaW5nIDogKCdrLCAndiwgdW5pdCwgdW5pdCkgbWFya2VyXG4gICAgICB8IEZvdW5kIDogKCdrLCAndiwgJ2ssICd2KSBtYXJrZXJcblxuICAgIGxldCByZXBhY2thZ2VcbiAgICAgICh0eXBlIGsgdiBrX29wdCB2X29wdClcbiAgICAgIChtYXJrZXIgOiAoaywgdiwga19vcHQsIHZfb3B0KSBtYXJrZXIpXG4gICAgICAoayA6IGtfb3B0KVxuICAgICAgKHYgOiB2X29wdClcbiAgICAgIDogKGsgKiB2KSBvcHRpb25cbiAgICAgID1cbiAgICAgIG1hdGNoIG1hcmtlciB3aXRoXG4gICAgICB8IE1pc3NpbmcgLT4gTm9uZVxuICAgICAgfCBGb3VuZCAtPiBTb21lIChrLCB2KVxuICAgIDs7XG5cbiAgICAoKiBUaGUgdHlwZSBzaWduYXR1cmUgaXMgZXhwbGljaXQgaGVyZSB0byBhbGxvdyBwb2x5bW9ycGhpYyByZWN1cnNpb24uICopXG4gICAgbGV0IHJlYyBsb29wIDpcbiAgICAgICAgICAgICAgJ2sgJ3YgJ2tfb3B0ICd2X29wdC5cbiAgICAgICAgICAgICAgKCdrLCAndikgdHJlZVxuICAgICAgICAgICAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgICAgICAgICAgIC0+ICdrXG4gICAgICAgICAgICAgIC0+IGNvbXBhcmVfa2V5OignayAtPiAnayAtPiBpbnQpXG4gICAgICAgICAgICAgIC0+ICgnaywgJ3YsICdrX29wdCwgJ3Zfb3B0KSBtYXJrZXJcbiAgICAgICAgICAgICAgLT4gJ2tfb3B0XG4gICAgICAgICAgICAgIC0+ICd2X29wdFxuICAgICAgICAgICAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG4gICAgICA9XG4gICAgICBmdW4gdCBkaXIgayB+Y29tcGFyZV9rZXkgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSAtPlxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlXG4gICAgICB8IExlYWYgeyBrZXkgPSBrJzsgZGF0YSA9IHYnIH0gLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrJyBrIGluXG4gICAgICAgIGlmIG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgIHwgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gLT4gYyA+PSAwXG4gICAgICAgICAgIHwgYEdyZWF0ZXJfdGhhbiAtPiBjID4gMFxuICAgICAgICAgICB8IGBMZXNzX29yX2VxdWFsX3RvIC0+IGMgPD0gMFxuICAgICAgICAgICB8IGBMZXNzX3RoYW4gLT4gYyA8IDBcbiAgICAgICAgdGhlbiBTb21lIChrJywgdicpXG4gICAgICAgIGVsc2UgcmVwYWNrYWdlIGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWVcbiAgICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBrJzsgZGF0YSA9IHYnOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGsnIGsgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgKCogVGhpcyBpcyBhIGJhc2UgY2FzZSAobm8gcmVjdXJzaXZlIGNhbGwpLiAqKVxuICAgICAgICAgIG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgfCBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBMZXNzX29yX2VxdWFsX3RvIC0+IFNvbWUgKGsnLCB2JylcbiAgICAgICAgICB8IGBHcmVhdGVyX3RoYW4gLT5cbiAgICAgICAgICAgIGlmIGlzX2VtcHR5IHIgdGhlbiByZXBhY2thZ2UgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSBlbHNlIG1pbl9lbHQgclxuICAgICAgICAgIHwgYExlc3NfdGhhbiAtPlxuICAgICAgICAgICAgaWYgaXNfZW1wdHkgbCB0aGVuIHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlIGVsc2UgbWF4X2VsdCBsKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBXZSBhcmUgZ3VhcmFudGVlZCBoZXJlIHRoYXQgaycgPD4gay4gKilcbiAgICAgICAgICAoKiBUaGlzIGlzIHRoZSBvbmx5IHJlY3Vyc2l2ZSBjYXNlLiAqKVxuICAgICAgICAgIG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgfCBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gLT5cbiAgICAgICAgICAgIGlmIGMgPiAwXG4gICAgICAgICAgICB0aGVuIGxvb3AgbCBkaXIgayB+Y29tcGFyZV9rZXkgRm91bmQgaycgdidcbiAgICAgICAgICAgIGVsc2UgbG9vcCByIGRpciBrIH5jb21wYXJlX2tleSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlXG4gICAgICAgICAgfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gLT5cbiAgICAgICAgICAgIGlmIGMgPCAwXG4gICAgICAgICAgICB0aGVuIGxvb3AgciBkaXIgayB+Y29tcGFyZV9rZXkgRm91bmQgaycgdidcbiAgICAgICAgICAgIGVsc2UgbG9vcCBsIGRpciBrIH5jb21wYXJlX2tleSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlKVxuICAgIDs7XG5cbiAgICBsZXQgY2xvc2VzdF9rZXkgdCBkaXIgayB+Y29tcGFyZV9rZXkgPSBsb29wIHQgZGlyIGsgfmNvbXBhcmVfa2V5IE1pc3NpbmcgKCkgKClcbiAgZW5kXG5cbiAgbGV0IGNsb3Nlc3Rfa2V5ID0gQ2xvc2VzdF9rZXlfaW1wbC5jbG9zZXN0X2tleVxuXG4gIGxldCByZWMgcmFuayB0IGsgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgeyBrZXkgPSBrJzsgZGF0YSA9IF8gfSAtPiBpZiBjb21wYXJlX2tleSBrJyBrID0gMCB0aGVuIFNvbWUgMCBlbHNlIE5vbmVcbiAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gayc7IGRhdGEgPSBfOyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrJyBrIGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiBTb21lIChsZW5ndGggbClcbiAgICAgIGVsc2UgaWYgYyA+IDBcbiAgICAgIHRoZW4gcmFuayBsIGsgfmNvbXBhcmVfa2V5XG4gICAgICBlbHNlIE9wdGlvbi5tYXAgKHJhbmsgciBrIH5jb21wYXJlX2tleSkgfmY6KGZ1biByYW5rIC0+IHJhbmsgKyAxICsgbGVuZ3RoIGwpXG4gIDs7XG5cbiAgKCogdGhpcyBjb3VsZCBiZSBpbXBsZW1lbnRlZCB1c2luZyBbU2VxdWVuY2VdIGludGVyZmFjZSBidXQgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvblxuICAgICBhbGxvY2F0ZXMgb25seSAyIHdvcmRzIGFuZCBkb2Vzbid0IHJlcXVpcmUgd3JpdGUtYmFycmllciAqKVxuICBsZXQgcmVjIG50aCcgbnVtX3RvX3NlYXJjaCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHsga2V5ID0gazsgZGF0YSA9IHYgfSAtPlxuICAgICAgaWYgIW51bV90b19zZWFyY2ggPSAwXG4gICAgICB0aGVuIFNvbWUgKGssIHYpXG4gICAgICBlbHNlIChcbiAgICAgICAgZGVjciBudW1fdG9fc2VhcmNoO1xuICAgICAgICBOb25lKVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBrOyBkYXRhID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIChtYXRjaCBudGgnIG51bV90b19zZWFyY2ggbCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgc29tZSAtPiBzb21lXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBpZiAhbnVtX3RvX3NlYXJjaCA9IDBcbiAgICAgICAgIHRoZW4gU29tZSAoaywgdilcbiAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICBkZWNyIG51bV90b19zZWFyY2g7XG4gICAgICAgICAgIG50aCcgbnVtX3RvX3NlYXJjaCByKSlcbiAgOztcblxuICBsZXQgbnRoIHQgbiA9IG50aCcgKHJlZiBuKSB0XG5cbiAgbGV0IHJlYyBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHsga2V5ID0gazsgZGF0YSA9IHYgfSAtPiBpZiBmIH5rZXk6ayB+ZGF0YTp2IHRoZW4gU29tZSAoaywgdikgZWxzZSBOb25lXG4gICAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IGs7IGRhdGEgPSB2OyByaWdodCA9IHI7IGhlaWdodCA9IF8gfSAtPlxuICAgICAgaWYgZiB+a2V5OmsgfmRhdGE6dlxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyBsIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgKGssIHYpXG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHIgfmZcbiAgOztcblxuICBsZXQgcmVjIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB7IGtleSA9IGs7IGRhdGEgPSB2IH0gLT4gaWYgZiB+a2V5OmsgfmRhdGE6diB0aGVuIFNvbWUgKGssIHYpIGVsc2UgTm9uZVxuICAgIHwgTm9kZSB7IGxlZnQgPSBsOyBrZXkgPSBrOyBkYXRhID0gdjsgcmlnaHQgPSByOyBoZWlnaHQgPSBfIH0gLT5cbiAgICAgIGlmIGYgfmtleTprIH5kYXRhOnZcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyByIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgKGssIHYpXG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9sYXN0X3NhdGlzZnlpbmcgbCB+ZlxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPVxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gLT5cbiAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2IDwgMCkgW0Bub250YWlsXVxuICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA8PSAwKSBbQG5vbnRhaWxdXG4gICAgfCBgRmlyc3RfZXF1YWxfdG8gLT5cbiAgICAgIChtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPj0gMCkgd2l0aFxuICAgICAgIHwgU29tZSAoa2V5LCBkYXRhKSBhcyBwYWlyIHdoZW4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPSAwIC0+IHBhaXJcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBMYXN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPD0gMCkgd2l0aFxuICAgICAgIHwgU29tZSAoa2V5LCBkYXRhKSBhcyBwYWlyIHdoZW4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPSAwIC0+IHBhaXJcbiAgICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA+PSAwKSBbQG5vbnRhaWxdXG4gICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuIC0+XG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPiAwKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBsZXQgaXNfbGVmdCB+a2V5IH5kYXRhID1cbiAgICAgIG1hdGNoIHNlZ21lbnRfb2YgfmtleSB+ZGF0YSB3aXRoXG4gICAgICB8IGBMZWZ0IC0+IHRydWVcbiAgICAgIHwgYFJpZ2h0IC0+IGZhbHNlXG4gICAgaW5cbiAgICBsZXQgaXNfcmlnaHQgfmtleSB+ZGF0YSA9IG5vdCAoaXNfbGVmdCB+a2V5IH5kYXRhKSBpblxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9vbl9sZWZ0IC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfbGVmdCBbQG5vbnRhaWxdXG4gICAgfCBgRmlyc3Rfb25fcmlnaHQgLT4gZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfcmlnaHQgW0Bub250YWlsXVxuICA7O1xuXG4gICgqIFtiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZF0gZmluZHMgdGhlIGtleSBpbiBbdF0gd2hpY2ggc2F0aXNmaWVzIFttYXliZV9ib3VuZF1cbiAgICAgYW5kIHRoZSByZWxldmFudCBvbmUgb2YgW2lmX2V4Y2x1c2l2ZV0gb3IgW2lmX2luY2x1c2l2ZV0sIGFzIGp1ZGdlZCBieSBbY29tcGFyZV0uICopXG4gIGxldCBiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZCB0IG1heWJlX2JvdW5kIH5jb21wYXJlIH5pZl9leGNsdXNpdmUgfmlmX2luY2x1c2l2ZSA9XG4gICAgbGV0IGZpbmRfYm91bmQgdCBob3cgYm91bmQgfmNvbXBhcmUgOiBfIE1heWJlX2JvdW5kLnQgb3B0aW9uID1cbiAgICAgIG1hdGNoIGJpbmFyeV9zZWFyY2ggdCBob3cgYm91bmQgfmNvbXBhcmUgd2l0aFxuICAgICAgfCBTb21lIChib3VuZCwgXykgLT4gU29tZSAoSW5jbCBib3VuZClcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgaW5cbiAgICBtYXRjaCAobWF5YmVfYm91bmQgOiBfIE1heWJlX2JvdW5kLnQpIHdpdGhcbiAgICB8IEV4Y2wgYm91bmQgLT4gZmluZF9ib3VuZCB0IGlmX2V4Y2x1c2l2ZSBib3VuZCB+Y29tcGFyZVxuICAgIHwgSW5jbCBib3VuZCAtPiBmaW5kX2JvdW5kIHQgaWZfaW5jbHVzaXZlIGJvdW5kIH5jb21wYXJlXG4gICAgfCBVbmJvdW5kZWQgLT4gU29tZSBVbmJvdW5kZWRcbiAgOztcblxuICAoKiBbYmluYXJ5X3NlYXJjaF90d29fc2lkZWRfYm91bmRzXSBmaW5kcyB0aGUgKG5vdCBuZWNlc3NhcmlseSBkaXN0aW5jdCkga2V5cyBpbiBbdF1cbiAgICAgd2hpY2ggbW9zdCBjbG9zZWx5IGFwcHJvYWNoIChidXQgZG8gbm90IGNyb3NzKSBbbG93ZXJfYm91bmRdIGFuZCBbdXBwZXJfYm91bmRdLCBhc1xuICAgICBqdWRnZWQgYnkgW2NvbXBhcmVdLiBJdCByZXR1cm5zIFtOb25lXSBpZiBubyBrZXlzIGluIFt0XSBhcmUgd2l0aGluIHRoYXQgcmFuZ2UuICopXG4gIGxldCBiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBsZXQgZmluZF9sb3dlcl9ib3VuZCB0IG1heWJlX2JvdW5kIH5jb21wYXJlID1cbiAgICAgIGJpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kXG4gICAgICAgIHRcbiAgICAgICAgbWF5YmVfYm91bmRcbiAgICAgICAgfmNvbXBhcmVcbiAgICAgICAgfmlmX2V4Y2x1c2l2ZTpgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuXG4gICAgICAgIH5pZl9pbmNsdXNpdmU6YEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90b1xuICAgIGluXG4gICAgbGV0IGZpbmRfdXBwZXJfYm91bmQgdCBtYXliZV9ib3VuZCB+Y29tcGFyZSA9XG4gICAgICBiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZFxuICAgICAgICB0XG4gICAgICAgIG1heWJlX2JvdW5kXG4gICAgICAgIH5jb21wYXJlXG4gICAgICAgIH5pZl9leGNsdXNpdmU6YExhc3Rfc3RyaWN0bHlfbGVzc190aGFuXG4gICAgICAgIH5pZl9pbmNsdXNpdmU6YExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvXG4gICAgaW5cbiAgICBtYXRjaCBmaW5kX2xvd2VyX2JvdW5kIHQgbG93ZXJfYm91bmQgfmNvbXBhcmUgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGxvd2VyX2JvdW5kIC0+XG4gICAgICAobWF0Y2ggZmluZF91cHBlcl9ib3VuZCB0IHVwcGVyX2JvdW5kIH5jb21wYXJlIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgIHwgU29tZSB1cHBlcl9ib3VuZCAtPiBTb21lIChsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpKVxuICA7O1xuXG4gIHR5cGUgKCdrLCAndikgYWNjID1cbiAgICB7IG11dGFibGUgYmFkX2tleSA6ICdrIG9wdGlvblxuICAgIDsgbXV0YWJsZSBtYXBfbGVuZ3RoIDogKCdrLCAndikgdCBXaXRoX2xlbmd0aC50XG4gICAgfVxuXG4gIGxldCBvZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgYWNjID0geyBiYWRfa2V5ID0gTm9uZTsgbWFwX2xlbmd0aCA9IHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwIH0gaW5cbiAgICBpdGVyaSB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgIGxldCB7IHRyZWUgPSBtYXA7IGxlbmd0aCB9ID0gYWNjLm1hcF9sZW5ndGggaW5cbiAgICAgIGxldCAoeyB0cmVlID0gXzsgbGVuZ3RoID0gbGVuZ3RoJyB9IGFzIHBhaXIpID1cbiAgICAgICAgc2V0IH5sZW5ndGggfmtleSB+ZGF0YSBtYXAgfmNvbXBhcmVfa2V5XG4gICAgICBpblxuICAgICAgaWYgbGVuZ3RoID0gbGVuZ3RoJyAmJiBPcHRpb24uaXNfbm9uZSBhY2MuYmFkX2tleVxuICAgICAgdGhlbiBhY2MuYmFkX2tleSA8LSBTb21lIGtleVxuICAgICAgZWxzZSBhY2MubWFwX2xlbmd0aCA8LSBnbG9iYWxpemUgcGFpcik7XG4gICAgbWF0Y2ggYWNjLmJhZF9rZXkgd2l0aFxuICAgIHwgTm9uZSAtPiBgT2sgYWNjLm1hcF9sZW5ndGhcbiAgICB8IFNvbWUga2V5IC0+IGBEdXBsaWNhdGVfa2V5IGtleVxuICA7O1xuXG4gIGxldCBvZl9pdGVyaV9leG4gfml0ZXJpIH4oY29tcGFyYXRvciA6IF8gQ29tcGFyYXRvci50KSA9XG4gICAgbWF0Y2ggb2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rIHYgLT4gdlxuICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICBFcnJvci5jcmVhdGUgXCJNYXAub2ZfaXRlcmlfZXhuOiBkdXBsaWNhdGUga2V5XCIga2V5IGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgICB8PiBFcnJvci5yYWlzZVxuICA7O1xuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IGtleV9vZl9zZXhwIHZhbHVlX29mX3NleHAgc2V4cCB+KGNvbXBhcmF0b3IgOiBfIENvbXBhcmF0b3IudCkgPVxuICAgIGxldCBhbGlzdCA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIGtleV9vZl9zZXhwIHZhbHVlX29mX3NleHApIHNleHAgaW5cbiAgICBsZXQgY29tcGFyZV9rZXkgPSBjb21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICBtYXRjaCBvZl9hbGlzdCBhbGlzdCB+Y29tcGFyZV9rZXkgd2l0aFxuICAgIHwgYE9rIHYgLT4gdlxuICAgIHwgYER1cGxpY2F0ZV9rZXkgayAtPlxuICAgICAgKCogZmluZCB0aGUgc2V4cCBvZiBhIGR1cGxpY2F0ZSBrZXksIHNvIHRoZSBlcnJvciBpcyBuYXJyb3dlZCB0byBhIGtleSBhbmQgbm90XG4gICAgICAgICB0aGUgd2hvbGUgbWFwICopXG4gICAgICBsZXQgYWxpc3Rfc2V4cHMgPSBsaXN0X29mX3NleHAgKHBhaXJfb2Zfc2V4cCBGbi5pZCBGbi5pZCkgc2V4cCBpblxuICAgICAgbGV0IGZvdW5kX2ZpcnN0X2sgPSByZWYgZmFsc2UgaW5cbiAgICAgIExpc3QuaXRlcjJfb2sgYWxpc3QgYWxpc3Rfc2V4cHMgfmY6KGZ1biAoazIsIF8pIChrMl9zZXhwLCBfKSAtPlxuICAgICAgICBpZiBjb21wYXJlX2tleSBrIGsyID0gMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgaWYgIWZvdW5kX2ZpcnN0X2tcbiAgICAgICAgICB0aGVuIG9mX3NleHBfZXJyb3IgXCJNYXAudF9vZl9zZXhwX2RpcmVjdDogZHVwbGljYXRlIGtleVwiIGsyX3NleHBcbiAgICAgICAgICBlbHNlIGZvdW5kX2ZpcnN0X2sgOj0gdHJ1ZSk7XG4gICAgICBhc3NlcnQgZmFsc2VcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2Zfa2V5IHNleHBfb2ZfdmFsdWUgdCA9XG4gICAgbGV0IGYgfmtleSB+ZGF0YSBhY2MgPSBTZXhwLkxpc3QgWyBzZXhwX29mX2tleSBrZXk7IHNleHBfb2ZfdmFsdWUgZGF0YSBdIDo6IGFjYyBpblxuICAgIFNleHAuTGlzdCAoZm9sZF9yaWdodCB+ZiB0IH5pbml0OltdKVxuICA7O1xuXG4gIGxldCBjb21iaW5lX2Vycm9ycyB0IH5zZXhwX29mX2tleSA9XG4gICAgbGV0IG9rcywgZXJyb3JzID0gcGFydGl0aW9uX21hcCB0IH5mOlJlc3VsdC50b19laXRoZXIgaW5cbiAgICBpZiBpc19lbXB0eSBlcnJvcnNcbiAgICB0aGVuIE9rIG9rc1xuICAgIGVsc2UgT3JfZXJyb3IuZXJyb3JfcyAoc2V4cF9vZl90IHNleHBfb2Zfa2V5IEVycm9yLnNleHBfb2ZfdCBlcnJvcnMpXG4gIDs7XG5cbiAgbGV0IHVuemlwIHQgPSBtYXAgdCB+Zjpmc3QsIG1hcCB0IH5mOnNuZFxuXG4gIGxldCBtYXBfa2V5c1xuICAgIHQxXG4gICAgfmZcbiAgICB+Y29tcGFyYXRvcjooeyBjb21wYXJlID0gY29tcGFyZV9rZXk7IHNleHBfb2ZfdCA9IHNleHBfb2Zfa2V5IH0gOiBfIENvbXBhcmF0b3IudClcbiAgICA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgICBgT2tcbiAgICAgICAgKGZvbGRcbiAgICAgICAgICAgdDFcbiAgICAgICAgICAgfmluaXQ6KHdpdGhfbGVuZ3RoX2dsb2JhbCBlbXB0eSAwKVxuICAgICAgICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgeyB0cmVlID0gdDI7IGxlbmd0aCB9IC0+XG4gICAgICAgICAgIGxldCBrZXkgPSBmIGtleSBpblxuICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICBhZGRfZXhuX2ludGVybmFsIHQyIH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5IHw+IGdsb2JhbGl6ZVxuICAgICAgICAgICB3aXRoXG4gICAgICAgICAgIHwgRHVwbGljYXRlIC0+IHJldHVybiAoYER1cGxpY2F0ZV9rZXkga2V5KSkpKSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzX2V4biB0IH5mIH5jb21wYXJhdG9yID1cbiAgICBtYXRjaCBtYXBfa2V5cyB0IH5mIH5jb21wYXJhdG9yIHdpdGhcbiAgICB8IGBPayByZXN1bHQgLT4gcmVzdWx0XG4gICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgIGxldCBzZXhwX29mX2tleSA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3QgaW5cbiAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZSBcIk1hcC5tYXBfa2V5c19leG46IGR1cGxpY2F0ZSBrZXlcIiBbIFwia2V5XCIsIGtleSB8PiBzZXhwX29mX2tleSBdKVxuICA7O1xuXG4gIGxldCB0cmFuc3Bvc2Vfa2V5cyB+b3V0ZXJfY29tcGFyYXRvciB+aW5uZXJfY29tcGFyYXRvciBvdXRlcl90ID1cbiAgICBmb2xkXG4gICAgICBvdXRlcl90XG4gICAgICB+aW5pdDood2l0aF9sZW5ndGhfZ2xvYmFsIGVtcHR5IDApXG4gICAgICB+ZjooZnVuIH5rZXk6b3V0ZXJfa2V5IH5kYXRhOmlubmVyX3QgYWNjIC0+XG4gICAgICBmb2xkXG4gICAgICAgIGlubmVyX3RcbiAgICAgICAgfmluaXQ6YWNjXG4gICAgICAgIH5mOihmdW4gfmtleTppbm5lcl9rZXkgfmRhdGEgeyB0cmVlID0gYWNjOyBsZW5ndGggPSBhY2NfbGVuIH0gLT5cbiAgICAgICAgKHVwZGF0ZVxuICAgICAgICAgICBhY2NcbiAgICAgICAgICAgaW5uZXJfa2V5XG4gICAgICAgICAgIH5sZW5ndGg6YWNjX2xlblxuICAgICAgICAgICB+Y29tcGFyZV9rZXk6aW5uZXJfY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICAgICAgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgIHwgTm9uZSAtPiB3aXRoX2xlbmd0aF9nbG9iYWwgKHNpbmdsZXRvbiBvdXRlcl9rZXkgZGF0YSkgMVxuICAgICAgICAgICB8IFNvbWUgeyB0cmVlID0gZWx0OyBsZW5ndGggPSBlbHRfbGVuIH0gLT5cbiAgICAgICAgICAgICAoc2V0XG4gICAgICAgICAgICAgICAgZWx0XG4gICAgICAgICAgICAgICAgfmtleTpvdXRlcl9rZXlcbiAgICAgICAgICAgICAgICB+ZGF0YVxuICAgICAgICAgICAgICAgIH5sZW5ndGg6ZWx0X2xlblxuICAgICAgICAgICAgICAgIH5jb21wYXJlX2tleTpvdXRlcl9jb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgICAgICAgICB8PiBnbG9iYWxpemUpIFtAbm9udGFpbF0pXG4gICAgICAgICB8PiBnbG9iYWxpemUpIFtAbm9udGFpbF0pKVxuICA7O1xuXG4gIG1vZHVsZSBNYWtlX2FwcGxpY2F0aXZlX3RyYXZlcnNhbHMgKEEgOiBBcHBsaWNhdGl2ZS5MYXp5X2FwcGxpY2F0aXZlKSA9IHN0cnVjdFxuICAgIGxldCByZWMgbWFwaSB0IH5mID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBBLnJldHVybiBFbXB0eVxuICAgICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgICBBLm1hcCAoZiB+a2V5OnYgfmRhdGE6ZCkgfmY6KGZ1biBuZXdfZGF0YSAtPiBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IG5ld19kYXRhIH0pXG4gICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gaCB9IC0+XG4gICAgICAgIGxldCBsJyA9IEEub2ZfdGh1bmsgKGZ1biAoKSAtPiBtYXBpIH5mIGwpIGluXG4gICAgICAgIGxldCBkJyA9IGYgfmtleTp2IH5kYXRhOmQgaW5cbiAgICAgICAgbGV0IHInID0gQS5vZl90aHVuayAoZnVuICgpIC0+IG1hcGkgfmYgcikgaW5cbiAgICAgICAgQS5tYXAzIGwnIGQnIHInIH5mOihmdW4gbCcgZCcgcicgLT5cbiAgICAgICAgICBOb2RlIHsgbGVmdCA9IGwnOyBrZXkgPSB2OyBkYXRhID0gZCc7IHJpZ2h0ID0gcic7IGhlaWdodCA9IGggfSlcbiAgICA7O1xuXG4gICAgKCogSW4gdGhlb3J5IHRoZSBjb21wdXRhdGlvbiBvZiBsZW5ndGggb24tdGhlLWZseSBpcyBub3QgbmVjZXNzYXJ5IGhlcmUgYmVjYXVzZSBpdCBjYW5cbiAgICAgICBiZSBkb25lIGJ5IHdyYXBwaW5nIHRoZSBhcHBsaWNhdGl2ZSBbQV0gd2l0aCBsZW5ndGgtY29tcHV0aW5nIGxvZ2ljLiBIb3dldmVyLFxuICAgICAgIGludHJvZHVjaW5nIGFuIGFwcGxpY2F0aXZlIHRyYW5zZm9ybWVyIGxpa2UgdGhhdCBtYWtlcyB0aGUgbWFwIGJlbmNobWFya3MgaW5cbiAgICAgICBhc3luY19rZXJuZWwvYmVuY2gvc3JjL2JlbmNoX2RlZmVycmVkX21hcC5tbCBub3RpY2VhYmx5IHNsb3dlci4gKilcbiAgICBsZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gICAgICBsZXQgcmVjIHRyZWVfZmlsdGVyX21hcGkgdCB+ZiA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IEEucmV0dXJuICh3aXRoX2xlbmd0aF9nbG9iYWwgRW1wdHkgMClcbiAgICAgICAgfCBMZWFmIHsga2V5ID0gdjsgZGF0YSA9IGQgfSAtPlxuICAgICAgICAgIEEubWFwIChmIH5rZXk6diB+ZGF0YTpkKSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgIHwgU29tZSBuZXdfZGF0YSAtPiB3aXRoX2xlbmd0aF9nbG9iYWwgKExlYWYgeyBrZXkgPSB2OyBkYXRhID0gbmV3X2RhdGEgfSkgMVxuICAgICAgICAgICAgfCBOb25lIC0+IHdpdGhfbGVuZ3RoX2dsb2JhbCBFbXB0eSAwKVxuICAgICAgICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gdjsgZGF0YSA9IGQ7IHJpZ2h0ID0gcjsgaGVpZ2h0ID0gXyB9IC0+XG4gICAgICAgICAgQS5tYXAzXG4gICAgICAgICAgICAoQS5vZl90aHVuayAoZnVuICgpIC0+IHRyZWVfZmlsdGVyX21hcGkgbCB+ZikpXG4gICAgICAgICAgICAoZiB+a2V5OnYgfmRhdGE6ZClcbiAgICAgICAgICAgIChBLm9mX3RodW5rIChmdW4gKCkgLT4gdHJlZV9maWx0ZXJfbWFwaSByIH5mKSlcbiAgICAgICAgICAgIH5mOlxuICAgICAgICAgICAgICAoZnVuXG4gICAgICAgICAgICAgICAgeyB0cmVlID0gbCc7IGxlbmd0aCA9IGxfbGVuIH0gbmV3X2RhdGEgeyB0cmVlID0gcic7IGxlbmd0aCA9IHJfbGVuIH0gLT5cbiAgICAgICAgICAgICAgbWF0Y2ggbmV3X2RhdGEgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgbmV3X2RhdGEgLT5cbiAgICAgICAgICAgICAgICB3aXRoX2xlbmd0aF9nbG9iYWwgKGpvaW4gbCcgdiBuZXdfZGF0YSByJykgKGxfbGVuICsgcl9sZW4gKyAxKVxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICB3aXRoX2xlbmd0aF9nbG9iYWwgKGNvbmNhdF9hbmRfYmFsYW5jZV91bmNoZWNrZWQgbCcgcicpIChsX2xlbiArIHJfbGVuKSlcbiAgICAgIGluXG4gICAgICB0cmVlX2ZpbHRlcl9tYXBpIHQgfmZcbiAgICA7O1xuICBlbmRcbmVuZFxuXG50eXBlICgnaywgJ3YsICdjb21wYXJhdG9yKSB0ID1cbiAgeyAoKiBbY29tcGFyYXRvcl0gaXMgdGhlIGZpcnN0IGZpZWxkIHNvIHRoYXQgcG9seW1vcnBoaWMgZXF1YWxpdHkgZmFpbHMgb24gYSBtYXAgZHVlXG4gICAgICAgdG8gdGhlIGZ1bmN0aW9uYWwgdmFsdWUgaW4gdGhlIGNvbXBhcmF0b3IuXG4gICAgICAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgYWZmZWN0IHBvbHltb3JwaGljIFtjb21wYXJlXTogdGhhdCBzdGlsbCBwcm9kdWNlc1xuICAgICAgIG5vbnNlbnNlLiAqKVxuICAgIGNvbXBhcmF0b3IgOiAoJ2ssICdjb21wYXJhdG9yKSBDb21wYXJhdG9yLnRcbiAgOyB0cmVlIDogKCdrLCAndikgVHJlZTAudFxuICA7IGxlbmd0aCA6IGludFxuICB9XG5cbnR5cGUgKCdrLCAndiwgJ2NvbXBhcmF0b3IpIHRyZWUgPSAoJ2ssICd2KSBUcmVlMC50XG5cbmxldCBjb21wYXJlX2tleSB0ID0gdC5jb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG5sZXQgbGlrZSB7IHRyZWUgPSBfOyBsZW5ndGggPSBfOyBjb21wYXJhdG9yIH0gKHsgdHJlZTsgbGVuZ3RoIH0gOiBfIFdpdGhfbGVuZ3RoLnQpID1cbiAgeyB0cmVlOyBsZW5ndGg7IGNvbXBhcmF0b3IgfVxuOztcblxubGV0IGxpa2VfbWF5YmVfbm9fb3BcbiAgKHsgdHJlZSA9IG9sZF90cmVlOyBsZW5ndGggPSBfOyBjb21wYXJhdG9yIH0gYXMgb2xkX3QpXG4gICh7IHRyZWU7IGxlbmd0aCB9IDogXyBXaXRoX2xlbmd0aC50KVxuICA9XG4gIGlmIHBoeXNfZXF1YWwgb2xkX3RyZWUgdHJlZSB0aGVuIG9sZF90IGVsc2UgeyB0cmVlOyBsZW5ndGg7IGNvbXBhcmF0b3IgfVxuOztcblxubGV0IHdpdGhfc2FtZV9sZW5ndGggeyB0cmVlID0gXzsgY29tcGFyYXRvcjsgbGVuZ3RoIH0gdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvcjsgbGVuZ3RoIH1cbmxldCBvZl9saWtlX3RyZWUgdCB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yID0gdC5jb21wYXJhdG9yOyBsZW5ndGggPSBUcmVlMC5sZW5ndGggdHJlZSB9XG5cbmxldCBvZl9saWtlX3RyZWVfbWF5YmVfbm9fb3AgdCB0cmVlID1cbiAgaWYgcGh5c19lcXVhbCB0LnRyZWUgdHJlZVxuICB0aGVuIHRcbiAgZWxzZSB7IHRyZWU7IGNvbXBhcmF0b3IgPSB0LmNvbXBhcmF0b3I7IGxlbmd0aCA9IFRyZWUwLmxlbmd0aCB0cmVlIH1cbjs7XG5cbmxldCBvZl90cmVlIH5jb21wYXJhdG9yIHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCA9IFRyZWUwLmxlbmd0aCB0cmVlIH1cblxuKCogRXhwb3NpbmcgdGhpcyBmdW5jdGlvbiB3b3VsZCBtYWtlIGl0IHZlcnkgZWFzeSBmb3IgdGhlIGludmFyaWFudHNcbiAgIG9mIHRoaXMgbW9kdWxlIHRvIGJlIGJyb2tlbi4gKilcbmxldCBvZl90cmVlX3Vuc2FmZSB+Y29tcGFyYXRvciB+bGVuZ3RoIHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCB9XG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGNvbXBhcmF0b3IgdCA9IHQuY29tcGFyYXRvclxuICBsZXQgdG9fdHJlZSB0ID0gdC50cmVlXG5cbiAgbGV0IGludmFyaWFudHMgdCA9XG4gICAgVHJlZTAuaW52YXJpYW50cyB0LnRyZWUgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSAmJiBUcmVlMC5sZW5ndGggdC50cmVlID0gdC5sZW5ndGhcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgdCA9IFRyZWUwLmlzX2VtcHR5IHQudHJlZVxuICBsZXQgbGVuZ3RoIHQgPSB0Lmxlbmd0aFxuXG4gIGxldCBzZXQgdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuc2V0IHQudHJlZSB+bGVuZ3RoOnQubGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgICBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGFkZF9leG4gdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuYWRkX2V4blxuICAgICAgICAgdC50cmVlXG4gICAgICAgICB+bGVuZ3RoOnQubGVuZ3RoXG4gICAgICAgICB+a2V5XG4gICAgICAgICB+ZGF0YVxuICAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgICAgICAgfnNleHBfb2Zfa2V5OnQuY29tcGFyYXRvci5zZXhwX29mX3QpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgYWRkX2V4bl9pbnRlcm5hbCB0IH5rZXkgfmRhdGEgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC5hZGRfZXhuX2ludGVybmFsXG4gICAgICAgICB0LnRyZWVcbiAgICAgICAgIH5sZW5ndGg6dC5sZW5ndGhcbiAgICAgICAgIH5rZXlcbiAgICAgICAgIH5kYXRhXG4gICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgICAgICB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdCkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBhZGQgdCB+a2V5IH5kYXRhID1cbiAgICBtYXRjaCBhZGRfZXhuX2ludGVybmFsIHQgfmtleSB+ZGF0YSB3aXRoXG4gICAgfCByZXN1bHQgLT4gYE9rIHJlc3VsdFxuICAgIHwgZXhjZXB0aW9uIER1cGxpY2F0ZSAtPiBgRHVwbGljYXRlXG4gIDs7XG5cbiAgbGV0IGFkZF9tdWx0aSB0IH5rZXkgfmRhdGEgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC5hZGRfbXVsdGkgdC50cmVlIH5sZW5ndGg6dC5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICAgIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgcmVtb3ZlX211bHRpIHQga2V5ID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAucmVtb3ZlX211bHRpIHQudHJlZSB+bGVuZ3RoOnQubGVuZ3RoIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICAgIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmluZF9tdWx0aSB0IGtleSA9IFRyZWUwLmZpbmRfbXVsdGkgdC50cmVlIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG5cbiAgbGV0IGNoYW5nZSB0IGtleSB+ZiA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLmNoYW5nZSB0LnRyZWUga2V5IH5mIH5sZW5ndGg6dC5sZW5ndGggfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgICBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IHVwZGF0ZSB0IGtleSB+ZiA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLnVwZGF0ZSB0LnRyZWUga2V5IH5mIH5sZW5ndGg6dC5sZW5ndGggfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgICBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuIHQga2V5ID1cbiAgICBUcmVlMC5maW5kX2V4blxuICAgICAgdC50cmVlXG4gICAgICBrZXlcbiAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICAgIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IGZpbmQgdCBrZXkgPSBUcmVlMC5maW5kIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuXG4gIGxldCByZW1vdmUgdCBrZXkgPVxuICAgIGxpa2VfbWF5YmVfbm9fb3BcbiAgICAgIHRcbiAgICAgIChUcmVlMC5yZW1vdmUgdC50cmVlIGtleSB+bGVuZ3RoOnQubGVuZ3RoIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgbWVtIHQga2V5ID0gVHJlZTAubWVtIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICBsZXQgaXRlcl9rZXlzIHQgfmYgPSBUcmVlMC5pdGVyX2tleXMgdC50cmVlIH5mXG4gIGxldCBpdGVyIHQgfmYgPSBUcmVlMC5pdGVyIHQudHJlZSB+ZlxuICBsZXQgaXRlcmkgdCB+ZiA9IFRyZWUwLml0ZXJpIHQudHJlZSB+ZlxuICBsZXQgaXRlcmlfdW50aWwgdCB+ZiA9IFRyZWUwLml0ZXJpX3VudGlsIHQudHJlZSB+ZlxuICBsZXQgaXRlcjIgdDEgdDIgfmYgPSBUcmVlMC5pdGVyMiB0MS50cmVlIHQyLnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSlcbiAgbGV0IG1hcCB0IH5mID0gd2l0aF9zYW1lX2xlbmd0aCB0IChUcmVlMC5tYXAgdC50cmVlIH5mKVxuICBsZXQgbWFwaSB0IH5mID0gd2l0aF9zYW1lX2xlbmd0aCB0IChUcmVlMC5tYXBpIHQudHJlZSB+ZilcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdC50cmVlIH5mIH5pbml0XG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9IFRyZWUwLmZvbGRfdW50aWwgdC50cmVlIH5pbml0IH5mIH5maW5pc2hcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdC50cmVlIH5mIH5pbml0XG5cbiAgbGV0IGZvbGQyIHQxIHQyIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkMiB0MS50cmVlIHQyLnRyZWUgfmluaXQgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSlcbiAgOztcblxuICBsZXQgZmlsdGVyX2tleXMgdCB+ZiA9XG4gICAgbGV0IGxlbiA9IHJlZiB0Lmxlbmd0aCBpblxuICAgIGxldCB0cmVlID0gVHJlZTAuZmlsdGVyX2tleXMgdC50cmVlIH5mIH5sZW4gaW5cbiAgICBsaWtlX21heWJlX25vX29wIHQgKHdpdGhfbGVuZ3RoIHRyZWUgIWxlbikgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmaWx0ZXIgdCB+ZiA9XG4gICAgbGV0IGxlbiA9IHJlZiB0Lmxlbmd0aCBpblxuICAgIGxldCB0cmVlID0gVHJlZTAuZmlsdGVyIHQudHJlZSB+ZiB+bGVuIGluXG4gICAgbGlrZV9tYXliZV9ub19vcCB0ICh3aXRoX2xlbmd0aCB0cmVlICFsZW4pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmlsdGVyaSB0IH5mID1cbiAgICBsZXQgbGVuID0gcmVmIHQubGVuZ3RoIGluXG4gICAgbGV0IHRyZWUgPSBUcmVlMC5maWx0ZXJpIHQudHJlZSB+ZiB+bGVuIGluXG4gICAgbGlrZV9tYXliZV9ub19vcCB0ICh3aXRoX2xlbmd0aCB0cmVlICFsZW4pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCB0IH5mID1cbiAgICBsZXQgbGVuID0gcmVmIHQubGVuZ3RoIGluXG4gICAgbGV0IHRyZWUgPSBUcmVlMC5maWx0ZXJfbWFwIHQudHJlZSB+ZiB+bGVuIGluXG4gICAgbGlrZSB0ICh3aXRoX2xlbmd0aCB0cmVlICFsZW4pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gICAgbGV0IGxlbiA9IHJlZiB0Lmxlbmd0aCBpblxuICAgIGxldCB0cmVlID0gVHJlZTAuZmlsdGVyX21hcGkgdC50cmVlIH5mIH5sZW4gaW5cbiAgICBsaWtlIHQgKHdpdGhfbGVuZ3RoIHRyZWUgIWxlbikgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBvZl9saWtlX3RyZWUyIHQgKHQxLCB0MikgPSBvZl9saWtlX3RyZWUgdCB0MSwgb2ZfbGlrZV90cmVlIHQgdDJcblxuICBsZXQgb2ZfbGlrZV90cmVlMl9tYXliZV9ub19vcCB0ICh0MSwgdDIpID1cbiAgICBvZl9saWtlX3RyZWVfbWF5YmVfbm9fb3AgdCB0MSwgb2ZfbGlrZV90cmVlX21heWJlX25vX29wIHQgdDJcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcGkgdCB+ZiA9IG9mX2xpa2VfdHJlZTIgdCAoVHJlZTAucGFydGl0aW9uX21hcGkgdC50cmVlIH5mKVxuICBsZXQgcGFydGl0aW9uX21hcCB0IH5mID0gb2ZfbGlrZV90cmVlMiB0IChUcmVlMC5wYXJ0aXRpb25fbWFwIHQudHJlZSB+ZilcbiAgbGV0IHBhcnRpdGlvbmlfdGYgdCB+ZiA9IG9mX2xpa2VfdHJlZTJfbWF5YmVfbm9fb3AgdCAoVHJlZTAucGFydGl0aW9uaV90ZiB0LnRyZWUgfmYpXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IG9mX2xpa2VfdHJlZTJfbWF5YmVfbm9fb3AgdCAoVHJlZTAucGFydGl0aW9uX3RmIHQudHJlZSB+ZilcblxuICBsZXQgY29tYmluZV9lcnJvcnMgdCA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICB+Zjoob2ZfbGlrZV90cmVlIHQpXG4gICAgICAoVHJlZTAuY29tYmluZV9lcnJvcnMgdC50cmVlIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCB1bnppcCB0ID0gb2ZfbGlrZV90cmVlMiB0IChUcmVlMC51bnppcCB0LnRyZWUpXG5cbiAgbGV0IGNvbXBhcmVfZGlyZWN0IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgVHJlZTAuY29tcGFyZSAoY29tcGFyZV9rZXkgdDEpIGNvbXBhcmVfZGF0YSB0MS50cmVlIHQyLnRyZWVcbiAgOztcblxuICBsZXQgZXF1YWwgY29tcGFyZV9kYXRhIHQxIHQyID0gVHJlZTAuZXF1YWwgKGNvbXBhcmVfa2V5IHQxKSBjb21wYXJlX2RhdGEgdDEudHJlZSB0Mi50cmVlXG4gIGxldCBrZXlzIHQgPSBUcmVlMC5rZXlzIHQudHJlZVxuICBsZXQgZGF0YSB0ID0gVHJlZTAuZGF0YSB0LnRyZWVcbiAgbGV0IHRvX2FsaXN0ID9rZXlfb3JkZXIgdCA9IFRyZWUwLnRvX2FsaXN0ID9rZXlfb3JkZXIgdC50cmVlXG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsID1cbiAgICBUcmVlMC5zeW1tZXRyaWNfZGlmZiB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSkgfmRhdGFfZXF1YWxcbiAgOztcblxuICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgdDEudHJlZVxuICAgICAgdDIudHJlZVxuICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSlcbiAgICAgIH5kYXRhX2VxdWFsXG4gICAgICB+aW5pdFxuICAgICAgfmZcbiAgOztcblxuICBsZXQgbWVyZ2UgdDEgdDIgfmYgPVxuICAgIGxpa2UgdDEgKFRyZWUwLm1lcmdlIHQxLnRyZWUgdDIudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBtZXJnZV9kaXNqb2ludF9leG4gdDEgdDIgPVxuICAgIGxpa2VcbiAgICAgIHQxXG4gICAgICAoVHJlZTAubWVyZ2VfZGlzam9pbnRfZXhuXG4gICAgICAgICB0MS50cmVlXG4gICAgICAgICB0Mi50cmVlXG4gICAgICAgICB+bGVuZ3RoMTp0MS5sZW5ndGhcbiAgICAgICAgIH5sZW5ndGgyOnQyLmxlbmd0aFxuICAgICAgICAgfmNvbXBhcmF0b3I6dDEuY29tcGFyYXRvcikgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBtZXJnZV9za2V3ZWQgdDEgdDIgfmNvbWJpbmUgPVxuICAgICgqIFRoaXMgaXMgb25seSBhIG5vLW9wIGluIHRoZSBjYXNlIHdoZXJlIGF0IGxlYXN0IG9uZSBvZiB0aGUgbWFwcyBpcyBlbXB0eS4gKilcbiAgICBsaWtlX21heWJlX25vX29wXG4gICAgICAoaWYgdDIubGVuZ3RoIDw9IHQxLmxlbmd0aCB0aGVuIHQxIGVsc2UgdDIpXG4gICAgICAoVHJlZTAubWVyZ2Vfc2tld2VkXG4gICAgICAgICB0MS50cmVlXG4gICAgICAgICB0Mi50cmVlXG4gICAgICAgICB+bGVuZ3RoMTp0MS5sZW5ndGhcbiAgICAgICAgIH5sZW5ndGgyOnQyLmxlbmd0aFxuICAgICAgICAgfmNvbWJpbmVcbiAgICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpKVxuICA7O1xuXG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHQudHJlZVxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHQudHJlZVxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0LnRyZWVcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0LnRyZWVcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdC50cmVlIH5mXG4gIGxldCBmb3JfYWxsaSB0IH5mID0gVHJlZTAuZm9yX2FsbGkgdC50cmVlIH5mXG4gIGxldCBleGlzdHMgdCB+ZiA9IFRyZWUwLmV4aXN0cyB0LnRyZWUgfmZcbiAgbGV0IGV4aXN0c2kgdCB+ZiA9IFRyZWUwLmV4aXN0c2kgdC50cmVlIH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdC50cmVlIH5mXG4gIGxldCBjb3VudGkgdCB+ZiA9IFRyZWUwLmNvdW50aSB0LnRyZWUgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBUcmVlMC5zdW0gbSB0LnRyZWUgfmZcbiAgbGV0IHN1bWkgbSB0IH5mID0gVHJlZTAuc3VtaSBtIHQudHJlZSB+ZlxuXG4gIGxldCBzcGxpdCB0IGsgPVxuICAgIGxldCBsLCBtYXliZSwgciA9IFRyZWUwLnNwbGl0IHQudHJlZSBrIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkgaW5cbiAgICBsZXQgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IgdCBpblxuICAgICgqIFRyeSB0byB0cmF2ZXJzZSB0aGUgbGVhc3QgYW1vdW50IHBvc3NpYmxlIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoLFxuICAgICAgIHVzaW5nIGhlaWdodCBhcyBhIGhldXJpc3RpYy4gKilcbiAgICBsZXQgYm90aF9sZW4gPSBpZiBPcHRpb24uaXNfc29tZSBtYXliZSB0aGVuIHQubGVuZ3RoIC0gMSBlbHNlIHQubGVuZ3RoIGluXG4gICAgaWYgVHJlZTAuaGVpZ2h0IGwgPCBUcmVlMC5oZWlnaHQgclxuICAgIHRoZW4gKFxuICAgICAgbGV0IGwgPSBvZl90cmVlIGwgfmNvbXBhcmF0b3IgaW5cbiAgICAgIGwsIG1heWJlLCBvZl90cmVlX3Vuc2FmZSByIH5jb21wYXJhdG9yIH5sZW5ndGg6KGJvdGhfbGVuIC0gbGVuZ3RoIGwpKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHIgPSBvZl90cmVlIHIgfmNvbXBhcmF0b3IgaW5cbiAgICAgIG9mX3RyZWVfdW5zYWZlIGwgfmNvbXBhcmF0b3Igfmxlbmd0aDooYm90aF9sZW4gLSBsZW5ndGggciksIG1heWJlLCByKVxuICA7O1xuXG4gIGxldCBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgdCB+aW50byBrID1cbiAgICBsZXQgbCwgciA9XG4gICAgICBUcmVlMC5zcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgdC50cmVlIH5pbnRvIGsgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgIGluXG4gICAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yIHQgaW5cbiAgICAoKiBUcnkgdG8gdHJhdmVyc2UgdGhlIGxlYXN0IGFtb3VudCBwb3NzaWJsZSB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCxcbiAgICAgICB1c2luZyBoZWlnaHQgYXMgYSBoZXVyaXN0aWMuICopXG4gICAgaWYgVHJlZTAuaGVpZ2h0IGwgPCBUcmVlMC5oZWlnaHQgclxuICAgIHRoZW4gKFxuICAgICAgbGV0IGwgPSBvZl90cmVlIGwgfmNvbXBhcmF0b3IgaW5cbiAgICAgIGwsIG9mX3RyZWVfdW5zYWZlIHIgfmNvbXBhcmF0b3Igfmxlbmd0aDoodC5sZW5ndGggLSBsZW5ndGggbCkpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgciA9IG9mX3RyZWUgciB+Y29tcGFyYXRvciBpblxuICAgICAgb2ZfdHJlZV91bnNhZmUgbCB+Y29tcGFyYXRvciB+bGVuZ3RoOih0Lmxlbmd0aCAtIGxlbmd0aCByKSwgcilcbiAgOztcblxuICBsZXQgc3BsaXRfbGVfZ3QgdCBrID0gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IHQgfmludG86YExlZnQga1xuICBsZXQgc3BsaXRfbHRfZ2UgdCBrID0gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IHQgfmludG86YFJpZ2h0IGtcblxuICBsZXQgc3VicmFuZ2UgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBsZXQgbGVmdCwgbWlkLCByaWdodCA9XG4gICAgICBUcmVlMC5zcGxpdF9yYW5nZSB0LnRyZWUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgaW5cbiAgICAoKiBUcnkgdG8gdHJhdmVyc2UgdGhlIGxlYXN0IGFtb3VudCBwb3NzaWJsZSB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCxcbiAgICAgICB1c2luZyBoZWlnaHQgYXMgYSBoZXVyaXN0aWMuICopXG4gICAgbGV0IG91dGVyX2pvaW5lZF9oZWlnaHQgPVxuICAgICAgbGV0IGhfbCA9IFRyZWUwLmhlaWdodCBsZWZ0XG4gICAgICBhbmQgaF9yID0gVHJlZTAuaGVpZ2h0IHJpZ2h0IGluXG4gICAgICBpZiBoX2wgPSBoX3IgdGhlbiBoX2wgKyAxIGVsc2UgbWF4IGhfbCBoX3JcbiAgICBpblxuICAgIGlmIG91dGVyX2pvaW5lZF9oZWlnaHQgPCBUcmVlMC5oZWlnaHQgbWlkXG4gICAgdGhlbiAoXG4gICAgICBsZXQgbWlkX2xlbmd0aCA9IHQubGVuZ3RoIC0gKFRyZWUwLmxlbmd0aCBsZWZ0ICsgVHJlZTAubGVuZ3RoIHJpZ2h0KSBpblxuICAgICAgb2ZfdHJlZV91bnNhZmUgbWlkIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIHQpIH5sZW5ndGg6bWlkX2xlbmd0aClcbiAgICBlbHNlIG9mX3RyZWUgbWlkIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIHQpXG4gIDs7XG5cbiAgbGV0IGFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCA9XG4gICAgbWF0Y2hcbiAgICAgIFRyZWUwLmFwcGVuZFxuICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IGxvd2VyX3BhcnQpXG4gICAgICAgIH5sb3dlcl9wYXJ0Omxvd2VyX3BhcnQudHJlZVxuICAgICAgICB+dXBwZXJfcGFydDp1cHBlcl9wYXJ0LnRyZWVcbiAgICB3aXRoXG4gICAgfCBgT2sgdHJlZSAtPlxuICAgICAgYE9rXG4gICAgICAgIChvZl90cmVlX3Vuc2FmZVxuICAgICAgICAgICB0cmVlXG4gICAgICAgICAgIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIGxvd2VyX3BhcnQpXG4gICAgICAgICAgIH5sZW5ndGg6KGxvd2VyX3BhcnQubGVuZ3RoICsgdXBwZXJfcGFydC5sZW5ndGgpKVxuICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT4gYE92ZXJsYXBwaW5nX2tleV9yYW5nZXNcbiAgOztcblxuICBsZXQgZm9sZF9yYW5nZV9pbmNsdXNpdmUgdCB+bWluIH5tYXggfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGRfcmFuZ2VfaW5jbHVzaXZlIHQudHJlZSB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICA7O1xuXG4gIGxldCByYW5nZV90b19hbGlzdCB0IH5taW4gfm1heCA9XG4gICAgVHJlZTAucmFuZ2VfdG9fYWxpc3QgdC50cmVlIH5taW4gfm1heCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIDs7XG5cbiAgbGV0IGNsb3Nlc3Rfa2V5IHQgZGlyIGtleSA9XG4gICAgVHJlZTAuY2xvc2VzdF9rZXkgdC50cmVlIGRpciBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICA7O1xuXG4gIGxldCBudGggdCBuID0gVHJlZTAubnRoIHQudHJlZSBuXG4gIGxldCBudGhfZXhuIHQgbiA9IE9wdGlvbi52YWx1ZV9leG4gKG50aCB0IG4pXG4gIGxldCByYW5rIHQga2V5ID0gVHJlZTAucmFuayB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IHQudHJlZVxuXG4gIGxldCB0b19zZXF1ZW5jZSA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlXG4gICAgICB0LmNvbXBhcmF0b3JcbiAgICAgID9vcmRlclxuICAgICAgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgP2tleXNfbGVzc19vcl9lcXVhbF90b1xuICAgICAgdC50cmVlXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdC50cmVlIH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0LnRyZWUgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9kaXJlY3QgaGFzaF9mb2xkX2tleSBoYXNoX2ZvbGRfZGF0YSBzdGF0ZSB0ID1cbiAgICBUcmVlMC5oYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2tleSBoYXNoX2ZvbGRfZGF0YSBzdGF0ZSB0LnRyZWVcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIG1hdGNoXG4gICAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMgdC50cmVlIH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRcbiAgICB3aXRoXG4gICAgfCBTb21lIChsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpIC0+IHN1YnJhbmdlIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZFxuICAgIHwgTm9uZSAtPiBsaWtlX21heWJlX25vX29wIHQgKHdpdGhfbGVuZ3RoIFRyZWUwLkVtcHR5IDApIFtAbm9udGFpbF1cbiAgOztcblxuICBtb2R1bGUgTWFrZV9hcHBsaWNhdGl2ZV90cmF2ZXJzYWxzIChBIDogQXBwbGljYXRpdmUuTGF6eV9hcHBsaWNhdGl2ZSkgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgVHJlZV90cmF2ZXJzYWxzID0gVHJlZTAuTWFrZV9hcHBsaWNhdGl2ZV90cmF2ZXJzYWxzIChBKVxuXG4gICAgbGV0IG1hcGkgdCB+ZiA9XG4gICAgICBBLm1hcCAoVHJlZV90cmF2ZXJzYWxzLm1hcGkgdC50cmVlIH5mKSB+ZjooZnVuIG5ld190cmVlIC0+XG4gICAgICAgIHdpdGhfc2FtZV9sZW5ndGggdCBuZXdfdHJlZSlcbiAgICA7O1xuXG4gICAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICAgICAgQS5tYXAgKFRyZWVfdHJhdmVyc2Fscy5maWx0ZXJfbWFwaSB0LnRyZWUgfmYpIH5mOihmdW4gbmV3X3RyZWVfd2l0aF9sZW5ndGggLT5cbiAgICAgICAgbGlrZSB0IG5ld190cmVlX3dpdGhfbGVuZ3RoKVxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbigqIFswXSBpcyB1c2VkIGFzIHRoZSBbbGVuZ3RoXSBhcmd1bWVudCBldmVyeXdoZXJlIGluIHRoaXMgbW9kdWxlLCBzaW5jZSB0cmVlcyBkbyBub3RcbiAgIGhhdmUgdGhlaXIgbGVuZ3RocyBzdG9yZWQgYXQgdGhlIHJvb3QsIHVubGlrZSBtYXBzLiBUaGUgdmFsdWVzIGFyZSBkaXNjYXJkZWQgYWx3YXlzLiAqKVxubW9kdWxlIFRyZWUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssICd2LCAnY29tcGFyYXRvcikgdCA9ICgnaywgJ3YsICdjb21wYXJhdG9yKSB0cmVlXG5cbiAgbGV0IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gPSBUcmVlMC5lbXB0eVxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3I6XyA9IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb25cbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3I6XyB0cmVlID0gdHJlZVxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yOl8gayB2ID0gVHJlZTAuc2luZ2xldG9uIGsgdlxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICAoVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB8PiBPcl9lcnJvci5tYXAgfmY6KGZ1biAoeCA6ICgnaywgJ3YpIFRyZWUwLnQgV2l0aF9sZW5ndGgudCkgLT4geC50cmVlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdCB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgbWF0Y2ggVHJlZTAub2ZfYWxpc3QgYWxpc3QgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZCAtPiBkXG4gICAgfCBgT2sgeyB0cmVlOyBsZW5ndGggPSBfIH0gLT4gYE9rIHRyZWVcbiAgOztcblxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIFRyZWUwLm9mX2FsaXN0X29yX2Vycm9yIGFsaXN0IH5jb21wYXJhdG9yXG4gICAgfD4gT3JfZXJyb3IubWFwIH5mOihmdW4gKHggOiAoJ2ssICd2KSBUcmVlMC50IFdpdGhfbGVuZ3RoLnQpIC0+IHgudHJlZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZXhuIH5jb21wYXJhdG9yIGFsaXN0ID0gKFRyZWUwLm9mX2FsaXN0X2V4biBhbGlzdCB+Y29tcGFyYXRvcikudHJlZVxuXG4gIGxldCBvZl9hbGlzdF9tdWx0aSB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgKFRyZWUwLm9mX2FsaXN0X211bHRpIGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yIGFsaXN0IH5pbml0IH5mID1cbiAgICAoVHJlZTAub2ZfYWxpc3RfZm9sZCBhbGlzdCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlIH5jb21wYXJhdG9yIGFsaXN0IH5mID1cbiAgICAoVHJlZTAub2ZfYWxpc3RfcmVkdWNlIGFsaXN0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBvZl9pdGVyaSB+Y29tcGFyYXRvciB+aXRlcmkgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rIHsgdHJlZTsgbGVuZ3RoID0gXyB9IC0+IGBPayB0cmVlXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGQgLT4gZFxuICA7O1xuXG4gIGxldCBvZl9pdGVyaV9leG4gfmNvbXBhcmF0b3Igfml0ZXJpID0gKFRyZWUwLm9mX2l0ZXJpX2V4biB+aXRlcmkgfmNvbXBhcmF0b3IpLnRyZWVcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3I6X3JlcXVpcmVkX2J5X2ludGYgfmxlbiB+ZiA9XG4gICAgVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZlxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICB+ZjooZnVuICh4IDogKCdrLCAndikgVHJlZTAudCBXaXRoX2xlbmd0aC50KSAtPiB4LnRyZWUpXG4gICAgICAoVHJlZTAub2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG1hdGNoIFRyZWUwLm9mX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkIC0+IGRcbiAgICB8IGBPayB7IHRyZWU7IGxlbmd0aCA9IF8gfSAtPiBgT2sgdHJlZVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvciBzZXEgPVxuICAgIFRyZWUwLm9mX3NlcXVlbmNlX29yX2Vycm9yIHNlcSB+Y29tcGFyYXRvclxuICAgIHw+IE9yX2Vycm9yLm1hcCB+ZjooZnVuICh4IDogKCdrLCAndikgVHJlZTAudCBXaXRoX2xlbmd0aC50KSAtPiB4LnRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvciBzZXEgPSAoVHJlZTAub2Zfc2VxdWVuY2VfZXhuIHNlcSB+Y29tcGFyYXRvcikudHJlZVxuXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9tdWx0aSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKS50cmVlXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3Igc2VxIH5pbml0IH5mID1cbiAgICAoVHJlZTAub2Zfc2VxdWVuY2VfZm9sZCBzZXEgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKS50cmVlXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvciBzZXEgfmYgPVxuICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9yZWR1Y2Ugc2VxIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5IH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIG1hdGNoXG4gICAgICBUcmVlMC5vZl9saXN0X3dpdGhfa2V5IGxpc3QgfmdldF9rZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgd2l0aFxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkIC0+IGRcbiAgICB8IGBPayB7IHRyZWU7IGxlbmd0aCA9IF8gfSAtPiBgT2sgdHJlZVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIFRyZWUwLm9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3IgbGlzdCB+Z2V0X2tleSB+Y29tcGFyYXRvclxuICAgIHw+IE9yX2Vycm9yLm1hcCB+ZjooZnVuICh4IDogKCdrLCAndikgVHJlZTAudCBXaXRoX2xlbmd0aC50KSAtPiB4LnRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfZXhuIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIChUcmVlMC5vZl9saXN0X3dpdGhfa2V5X2V4biBsaXN0IH5nZXRfa2V5IH5jb21wYXJhdG9yKS50cmVlXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkgfmNvbXBhcmF0b3IgbGlzdCB+Z2V0X2tleSA9XG4gICAgKFRyZWUwLm9mX2xpc3Rfd2l0aF9rZXlfbXVsdGlcbiAgICAgICBsaXN0XG4gICAgICAgfmdldF9rZXlcbiAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X2ZvbGQgfmNvbXBhcmF0b3IgbGlzdCB+Z2V0X2tleSB+aW5pdCB+ZiA9XG4gICAgKFRyZWUwLm9mX2xpc3Rfd2l0aF9rZXlfZm9sZFxuICAgICAgIGxpc3RcbiAgICAgICB+Z2V0X2tleVxuICAgICAgIH5pbml0XG4gICAgICAgfmZcbiAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X3JlZHVjZSB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5IH5mID1cbiAgICAoVHJlZTAub2ZfbGlzdF93aXRoX2tleV9yZWR1Y2VcbiAgICAgICBsaXN0XG4gICAgICAgfmdldF9rZXlcbiAgICAgICB+ZlxuICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgICAgIC50cmVlXG4gIDs7XG5cbiAgbGV0IHRvX3RyZWUgdCA9IHRcblxuICBsZXQgaW52YXJpYW50cyB+Y29tcGFyYXRvciB0ID1cbiAgICBUcmVlMC5pbnZhcmlhbnRzIHQgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0XG4gIGxldCBsZW5ndGggdCA9IFRyZWUwLmxlbmd0aCB0XG5cbiAgbGV0IHNldCB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIChUcmVlMC5zZXQgdCB+a2V5IH5kYXRhIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgYWRkX2V4biB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIChUcmVlMC5hZGRfZXhuXG4gICAgICAgdFxuICAgICAgIH5rZXlcbiAgICAgICB+ZGF0YVxuICAgICAgIH5sZW5ndGg6MFxuICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgIH5zZXhwX29mX2tleTpjb21wYXJhdG9yLnNleHBfb2ZfdClcbiAgICAgIC50cmVlXG4gIDs7XG5cbiAgbGV0IGFkZF9leG5faW50ZXJuYWwgfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICAoVHJlZTAuYWRkX2V4bl9pbnRlcm5hbFxuICAgICAgIHRcbiAgICAgICB+a2V5XG4gICAgICAgfmRhdGFcbiAgICAgICB+bGVuZ3RoOjBcbiAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICB+c2V4cF9vZl9rZXk6Y29tcGFyYXRvci5zZXhwX29mX3QpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCBhZGQgfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICB0cnkgYE9rIChhZGRfZXhuX2ludGVybmFsIHQgfmNvbXBhcmF0b3IgfmtleSB+ZGF0YSkgd2l0aFxuICAgIHwgXyAtPiBgRHVwbGljYXRlXG4gIDs7XG5cbiAgbGV0IGFkZF9tdWx0aSB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIChUcmVlMC5hZGRfbXVsdGkgdCB+a2V5IH5kYXRhIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCByZW1vdmVfbXVsdGkgfmNvbXBhcmF0b3IgdCBrZXkgPVxuICAgIChUcmVlMC5yZW1vdmVfbXVsdGkgdCBrZXkgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBmaW5kX211bHRpIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICBUcmVlMC5maW5kX211bHRpIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBjaGFuZ2UgfmNvbXBhcmF0b3IgdCBrZXkgfmYgPVxuICAgIChUcmVlMC5jaGFuZ2UgdCBrZXkgfmYgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCB1cGRhdGUgfmNvbXBhcmF0b3IgdCBrZXkgfmYgPVxuICAgIGNoYW5nZSB+Y29tcGFyYXRvciB0IGtleSB+ZjooZnVuIGRhdGEgLT4gU29tZSAoZiBkYXRhKSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB+Y29tcGFyYXRvciB0IGtleSA9XG4gICAgVHJlZTAuZmluZF9leG5cbiAgICAgIHRcbiAgICAgIGtleVxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICB+c2V4cF9vZl9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCBmaW5kIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAuZmluZCB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuICBsZXQgcmVtb3ZlIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICAoVHJlZTAucmVtb3ZlIHQga2V5IH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpLnRyZWVcbiAgOztcblxuICBsZXQgbWVtIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAubWVtIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICBsZXQgaXRlcl9rZXlzIHQgfmYgPSBUcmVlMC5pdGVyX2tleXMgdCB+ZlxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0IH5mXG4gIGxldCBpdGVyaSB0IH5mID0gVHJlZTAuaXRlcmkgdCB+ZlxuICBsZXQgaXRlcmlfdW50aWwgdCB+ZiA9IFRyZWUwLml0ZXJpX3VudGlsIHQgfmZcblxuICBsZXQgaXRlcjIgfmNvbXBhcmF0b3IgdDEgdDIgfmYgPVxuICAgIFRyZWUwLml0ZXIyIHQxIHQyIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiA9IFRyZWUwLm1hcCB0IH5mXG4gIGxldCBtYXBpIHQgfmYgPSBUcmVlMC5tYXBpIHQgfmZcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdCB+ZiB+aW5pdFxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBUcmVlMC5mb2xkX3VudGlsIHQgfmYgfmluaXQgfmZpbmlzaFxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0IH5mIH5pbml0XG5cbiAgbGV0IGZvbGQyIH5jb21wYXJhdG9yIHQxIHQyIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkMiB0MSB0MiB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgZmlsdGVyX2tleXMgdCB+ZiA9IFRyZWUwLmZpbHRlcl9rZXlzIHQgfmYgfmxlbjoocmVmIDApIFtAbm9udGFpbF1cbiAgbGV0IGZpbHRlciB0IH5mID0gVHJlZTAuZmlsdGVyIHQgfmYgfmxlbjoocmVmIDApIFtAbm9udGFpbF1cbiAgbGV0IGZpbHRlcmkgdCB+ZiA9IFRyZWUwLmZpbHRlcmkgdCB+ZiB+bGVuOihyZWYgMCkgW0Bub250YWlsXVxuICBsZXQgZmlsdGVyX21hcCB0IH5mID0gVHJlZTAuZmlsdGVyX21hcCB0IH5mIH5sZW46KHJlZiAwKSBbQG5vbnRhaWxdXG4gIGxldCBmaWx0ZXJfbWFwaSB0IH5mID0gVHJlZTAuZmlsdGVyX21hcGkgdCB+ZiB+bGVuOihyZWYgMCkgW0Bub250YWlsXVxuICBsZXQgcGFydGl0aW9uX21hcGkgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl9tYXBpIHQgfmZcbiAgbGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl9tYXAgdCB+ZlxuICBsZXQgcGFydGl0aW9uaV90ZiB0IH5mID0gVHJlZTAucGFydGl0aW9uaV90ZiB0IH5mXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl90ZiB0IH5mXG5cbiAgbGV0IGNvbWJpbmVfZXJyb3JzIH5jb21wYXJhdG9yIHQgPVxuICAgIFRyZWUwLmNvbWJpbmVfZXJyb3JzIHQgfnNleHBfb2Zfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgdW56aXAgPSBUcmVlMC51bnppcFxuXG4gIGxldCBjb21wYXJlX2RpcmVjdCB+Y29tcGFyYXRvciBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIFRyZWUwLmNvbXBhcmUgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgY29tcGFyZV9kYXRhIHQxIHQyXG4gIDs7XG5cbiAgbGV0IGVxdWFsIH5jb21wYXJhdG9yIGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgVHJlZTAuZXF1YWwgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgY29tcGFyZV9kYXRhIHQxIHQyXG4gIDs7XG5cbiAgbGV0IGtleXMgdCA9IFRyZWUwLmtleXMgdFxuICBsZXQgZGF0YSB0ID0gVHJlZTAuZGF0YSB0XG4gIGxldCB0b19hbGlzdCA/a2V5X29yZGVyIHQgPSBUcmVlMC50b19hbGlzdCA/a2V5X29yZGVyIHRcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgfmNvbXBhcmF0b3IgdDEgdDIgfmRhdGFfZXF1YWwgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB+ZGF0YV9lcXVhbFxuICA7O1xuXG4gIGxldCBmb2xkX3N5bW1ldHJpY19kaWZmIH5jb21wYXJhdG9yIHQxIHQyIH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICB0MVxuICAgICAgdDJcbiAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgfmRhdGFfZXF1YWxcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICA7O1xuXG4gIGxldCBtZXJnZSB+Y29tcGFyYXRvciB0MSB0MiB+ZiA9XG4gICAgKFRyZWUwLm1lcmdlIHQxIHQyIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSkudHJlZVxuICA7O1xuXG4gIGxldCBtZXJnZV9kaXNqb2ludF9leG4gfmNvbXBhcmF0b3IgdDEgdDIgPVxuICAgIChUcmVlMC5tZXJnZV9kaXNqb2ludF9leG4gdDEgdDIgfmxlbmd0aDE6KGxlbmd0aCB0MSkgfmxlbmd0aDI6KGxlbmd0aCB0MikgfmNvbXBhcmF0b3IpXG4gICAgICAudHJlZVxuICA7O1xuXG4gIGxldCBtZXJnZV9za2V3ZWQgfmNvbXBhcmF0b3IgdDEgdDIgfmNvbWJpbmUgPVxuICAgICgqIExlbmd0aCBjb21wdXRhdGlvbiBtYWtlcyB0aGlzIHNpZ25pZmljYW50bHkgc2xvd2VyIHRoYW4gW21lcmdlX3NrZXdlZF0gb24gYSBtYXBcbiAgICAgICB3aXRoIGEgW2xlbmd0aF0gZmllbGQsIGJ1dCBkb2VzIHByZXNlcnZlIGFtb3VudCBvZiBhbGxvY2F0aW9uLiAqKVxuICAgIChUcmVlMC5tZXJnZV9za2V3ZWRcbiAgICAgICB0MVxuICAgICAgIHQyXG4gICAgICAgfmxlbmd0aDE6KGxlbmd0aCB0MSlcbiAgICAgICB+bGVuZ3RoMjoobGVuZ3RoIHQyKVxuICAgICAgIH5jb21iaW5lXG4gICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICAgICAgLnRyZWVcbiAgOztcblxuICBsZXQgbWluX2VsdCB0ID0gVHJlZTAubWluX2VsdCB0XG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdFxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0XG4gIGxldCBtYXhfZWx0X2V4biB0ID0gVHJlZTAubWF4X2VsdF9leG4gdFxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0IH5mXG4gIGxldCBmb3JfYWxsaSB0IH5mID0gVHJlZTAuZm9yX2FsbGkgdCB+ZlxuICBsZXQgZXhpc3RzIHQgfmYgPSBUcmVlMC5leGlzdHMgdCB+ZlxuICBsZXQgZXhpc3RzaSB0IH5mID0gVHJlZTAuZXhpc3RzaSB0IH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdCB+ZlxuICBsZXQgY291bnRpIHQgfmYgPSBUcmVlMC5jb3VudGkgdCB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IFRyZWUwLnN1bSBtIHQgfmZcbiAgbGV0IHN1bWkgbSB0IH5mID0gVHJlZTAuc3VtaSBtIHQgfmZcbiAgbGV0IHNwbGl0IH5jb21wYXJhdG9yIHQgayA9IFRyZWUwLnNwbGl0IHQgayB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuICBsZXQgc3BsaXRfbGVfZ3QgfmNvbXBhcmF0b3IgdCBrID1cbiAgICBUcmVlMC5zcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnlcbiAgICAgIHRcbiAgICAgIH5pbnRvOmBMZWZ0XG4gICAgICBrXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgc3BsaXRfbHRfZ2UgfmNvbXBhcmF0b3IgdCBrID1cbiAgICBUcmVlMC5zcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnlcbiAgICAgIHRcbiAgICAgIH5pbnRvOmBSaWdodFxuICAgICAga1xuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGFwcGVuZCB+Y29tcGFyYXRvciB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCA9XG4gICAgVHJlZTAuYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBzdWJyYW5nZSB+Y29tcGFyYXRvciB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIGxldCBfLCByZXQsIF8gPVxuICAgICAgVHJlZTAuc3BsaXRfcmFuZ2VcbiAgICAgICAgdFxuICAgICAgICB+bG93ZXJfYm91bmRcbiAgICAgICAgfnVwcGVyX2JvdW5kXG4gICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgcmV0XG4gIDs7XG5cbiAgbGV0IGZvbGRfcmFuZ2VfaW5jbHVzaXZlIH5jb21wYXJhdG9yIHQgfm1pbiB+bWF4IH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgICAgdFxuICAgICAgfm1pblxuICAgICAgfm1heFxuICAgICAgfmluaXRcbiAgICAgIH5mXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgcmFuZ2VfdG9fYWxpc3QgfmNvbXBhcmF0b3IgdCB+bWluIH5tYXggPVxuICAgIFRyZWUwLnJhbmdlX3RvX2FsaXN0IHQgfm1pbiB+bWF4IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBjbG9zZXN0X2tleSB+Y29tcGFyYXRvciB0IGRpciBrZXkgPVxuICAgIFRyZWUwLmNsb3Nlc3Rfa2V5IHQgZGlyIGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgbnRoIHQgbiA9IFRyZWUwLm50aCB0IG5cbiAgbGV0IG50aF9leG4gdCBuID0gT3B0aW9uLnZhbHVlX2V4biAobnRoIHQgbilcbiAgbGV0IHJhbmsgfmNvbXBhcmF0b3IgdCBrZXkgPSBUcmVlMC5yYW5rIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfayBzZXhwX29mX3YgXyB0ID0gVHJlZTAuc2V4cF9vZl90IHNleHBfb2ZfayBzZXhwX29mX3YgdFxuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCA9XG4gICAgKFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3Qga19vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwIH5jb21wYXJhdG9yKS50cmVlXG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlIH5jb21wYXJhdG9yID9vcmRlciA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG8gdCA9XG4gICAgVHJlZTAudG9fc2VxdWVuY2UgY29tcGFyYXRvciA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB+Y29tcGFyYXRvcjpfIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHZcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgfmNvbXBhcmF0b3I6XyB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3dcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSB+Y29tcGFyYXRvciB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIG1hdGNoIFRyZWUwLmJpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kcyB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgd2l0aFxuICAgIHwgU29tZSAobG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSAtPiBzdWJyYW5nZSB+Y29tcGFyYXRvciB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRcbiAgICB8IE5vbmUgLT4gRW1wdHlcbiAgOztcblxuICBtb2R1bGUgTWFrZV9hcHBsaWNhdGl2ZV90cmF2ZXJzYWxzIChBIDogQXBwbGljYXRpdmUuTGF6eV9hcHBsaWNhdGl2ZSkgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgVHJlZTBfdHJhdmVyc2FscyA9IFRyZWUwLk1ha2VfYXBwbGljYXRpdmVfdHJhdmVyc2FscyAoQSlcblxuICAgIGxldCBtYXBpIHQgfmYgPSBUcmVlMF90cmF2ZXJzYWxzLm1hcGkgdCB+ZlxuXG4gICAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICAgICAgQS5tYXBcbiAgICAgICAgKFRyZWUwX3RyYXZlcnNhbHMuZmlsdGVyX21hcGkgdCB+ZilcbiAgICAgICAgfmY6KGZ1biAoeCA6ICgnaywgJ3YpIFRyZWUwLnQgV2l0aF9sZW5ndGgudCkgLT4geC50cmVlKVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBtYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBtYXRjaCBUcmVlMC5tYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mIHdpdGhcbiAgICB8IGBPayB7IHRyZWUgPSB0OyBsZW5ndGggPSBfIH0gLT4gYE9rIHRcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZHVwIC0+IGR1cFxuICA7O1xuXG4gIGxldCBtYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZiA9IChUcmVlMC5tYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZikudHJlZVxuXG4gICgqIFRoaXMgY2FsbGluZyBjb252ZW50aW9uIG9mIFt+Y29tcGFyYXRvciB+Y29tcGFyYXRvcl0gaXMgY29uZnVzaW5nLiBJdCBpcyByZXF1aXJlZFxuICAgICBiZWNhdXNlIFthY2Nlc3Nfb3B0aW9uc10gYW5kIFtjcmVhdGVfb3B0aW9uc10gYm90aCBkZW1hbmQgYSBbfmNvbXBhcmF0b3JdIGFyZ3VtZW50IGluXG4gICAgIFtNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlXS5cblxuICAgICBNYWtpbmcgaXQgbGVzcyBjb25mdXNpbmcgd291bGQgcmVxdWlyZSBzb21lIHVubmVjZXNzYXJ5IGNvbXBsZXhpdHkgaW4gc2lnbmF0dXJlcy5cbiAgICAgQmV0dGVyIHRvIGp1c3QgbGl2ZSB3aXRoIGFuIHVuZGVzaXJhYmxlIGludGVyZmFjZSBpbiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBwcm9iYWJseVxuICAgICBuZXZlciBiZSBjYWxsZWQgZGlyZWN0bHkuICopXG4gIGxldCB0cmFuc3Bvc2Vfa2V5cyB+Y29tcGFyYXRvcjpvdXRlcl9jb21wYXJhdG9yIH5jb21wYXJhdG9yOmlubmVyX2NvbXBhcmF0b3IgdCA9XG4gICAgKFRyZWUwLnRyYW5zcG9zZV9rZXlzIH5vdXRlcl9jb21wYXJhdG9yIH5pbm5lcl9jb21wYXJhdG9yIHQpLnRyZWVcbiAgICB8PiBtYXAgfmY6KGZ1biAoeCA6ICgnaywgJ3YpIFRyZWUwLnQgV2l0aF9sZW5ndGgudCkgLT4geC50cmVlKVxuICA7O1xuXG4gIG1vZHVsZSBCdWlsZF9pbmNyZWFzaW5nID0gc3RydWN0XG4gICAgdHlwZSAoJ2ssICd2LCAndykgdCA9ICgnaywgJ3YpIFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcudFxuXG4gICAgbGV0IGVtcHR5ID0gVHJlZTAuQnVpbGRfaW5jcmVhc2luZy5lbXB0eVxuXG4gICAgbGV0IGFkZF9leG4gdCB+Y29tcGFyYXRvciB+a2V5IH5kYXRhID1cbiAgICAgIG1hdGNoIFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcubWF4X2tleSB0IHdpdGhcbiAgICAgIHwgU29tZSBwcmV2X2tleSB3aGVuIGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHByZXZfa2V5IGtleSA+PSAwIC0+XG4gICAgICAgIEVycm9yLnJhaXNlX3MgKFNleHAuQXRvbSBcIk1hcC5CdWlsZF9pbmNyZWFzaW5nLmFkZDogbm9uLWluY3JlYXNpbmcga2V5XCIpXG4gICAgICB8IF8gLT4gVHJlZTAuQnVpbGRfaW5jcmVhc2luZy5hZGRfdW5jaGVja2VkIHQgfmtleSB+ZGF0YVxuICAgIDs7XG5cbiAgICBsZXQgdG9fdHJlZSB0ID0gVHJlZTAuQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCB0XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBVc2luZ19jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnaywgJ3YsICdjbXApIHQgPSAoJ2ssICd2LCAnY21wKSB0XG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3IgPSB7IHRyZWUgPSBUcmVlMC5lbXB0eTsgY29tcGFyYXRvcjsgbGVuZ3RoID0gMCB9XG4gIGxldCBzaW5nbGV0b24gfmNvbXBhcmF0b3IgayB2ID0geyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuc2luZ2xldG9uIGsgdjsgbGVuZ3RoID0gMSB9XG5cbiAgbGV0IG9mX3RyZWUwIH5jb21wYXJhdG9yICh7IHRyZWU7IGxlbmd0aCB9IDogXyBXaXRoX2xlbmd0aC50KSA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlOyBsZW5ndGggfVxuICA7O1xuXG4gIGxldCBvZl90cmVlIH5jb21wYXJhdG9yIHRyZWUgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yICh3aXRoX2xlbmd0aCB0cmVlIChUcmVlMC5sZW5ndGggdHJlZSkpIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgdG9fdHJlZSA9IHRvX3RyZWVcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgKFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gICAgICB+ZjooZnVuIHRyZWUgLT4gb2ZfdHJlZTAgfmNvbXBhcmF0b3IgdHJlZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3QgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2FsaXN0IGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgT2sgeyB0cmVlOyBsZW5ndGggfSAtPiBgT2sgeyBjb21wYXJhdG9yOyB0cmVlOyBsZW5ndGggfVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyB6IC0+IHpcbiAgOztcblxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIFJlc3VsdC5tYXAgKFRyZWUwLm9mX2FsaXN0X29yX2Vycm9yIGFsaXN0IH5jb21wYXJhdG9yKSB+ZjooZnVuIHRyZWUgLT5cbiAgICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2FsaXN0X2V4biBhbGlzdCB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX2FsaXN0X211bHRpIGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZm9sZCB+Y29tcGFyYXRvciBhbGlzdCB+aW5pdCB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2ZfYWxpc3RfZm9sZCBhbGlzdCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvciBhbGlzdCB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2ZfYWxpc3RfcmVkdWNlIGFsaXN0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfaXRlcmkgfmNvbXBhcmF0b3Igfml0ZXJpID1cbiAgICBtYXRjaCBUcmVlMC5vZl9pdGVyaSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfml0ZXJpIHdpdGhcbiAgICB8IGBPayB0cmVlX2xlbmd0aCAtPiBgT2sgKG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWVfbGVuZ3RoKVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyB6IC0+IHpcbiAgOztcblxuICBsZXQgb2ZfaXRlcmlfZXhuIH5jb21wYXJhdG9yIH5pdGVyaSA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2l0ZXJpX2V4biB+Y29tcGFyYXRvciB+aXRlcmkpXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yIH5sZW4gfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKHdpdGhfbGVuZ3RoIChUcmVlMC5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mKSBsZW4pIFtAbm9udGFpbF1cbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6KGZ1biB4IC0+IG9mX3RyZWUwIH5jb21wYXJhdG9yIHgpXG4gICAgICAoVHJlZTAub2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG1hdGNoIFRyZWUwLm9mX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rIHsgdHJlZTsgbGVuZ3RoIH0gLT4gYE9rIHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgUmVzdWx0Lm1hcCAoVHJlZTAub2Zfc2VxdWVuY2Vfb3JfZXJyb3Igc2VxIH5jb21wYXJhdG9yKSB+ZjooZnVuIHRyZWUgLT5cbiAgICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9zZXF1ZW5jZV9leG4gc2VxIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NlcXVlbmNlX211bHRpIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3Igc2VxIH5pbml0IH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9mb2xkIHNlcSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvciBzZXEgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NlcXVlbmNlX3JlZHVjZSBzZXEgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5IH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIG1hdGNoXG4gICAgICBUcmVlMC5vZl9saXN0X3dpdGhfa2V5IGxpc3QgfmdldF9rZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgd2l0aFxuICAgIHwgYE9rIHsgdHJlZTsgbGVuZ3RoIH0gLT4gYE9rIHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3IgfmNvbXBhcmF0b3IgbGlzdCB+Z2V0X2tleSA9XG4gICAgUmVzdWx0Lm1hcCAoVHJlZTAub2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciBsaXN0IH5nZXRfa2V5IH5jb21wYXJhdG9yKSB+ZjooZnVuIHRyZWUgLT5cbiAgICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfZXhuIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9saXN0X3dpdGhfa2V5X2V4biBsaXN0IH5nZXRfa2V5IH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X211bHRpIH5jb21wYXJhdG9yIGxpc3QgfmdldF9rZXkgPVxuICAgIFRyZWUwLm9mX2xpc3Rfd2l0aF9rZXlfbXVsdGkgbGlzdCB+Z2V0X2tleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB8PiBvZl90cmVlMCB+Y29tcGFyYXRvclxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X2ZvbGQgfmNvbXBhcmF0b3IgbGlzdCB+Z2V0X2tleSB+aW5pdCB+ZiA9XG4gICAgVHJlZTAub2ZfbGlzdF93aXRoX2tleV9mb2xkXG4gICAgICBsaXN0XG4gICAgICB+Z2V0X2tleVxuICAgICAgfmluaXRcbiAgICAgIH5mXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB8PiBvZl90cmVlMCB+Y29tcGFyYXRvclxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X3JlZHVjZSB+Y29tcGFyYXRvciBsaXN0IH5nZXRfa2V5IH5mID1cbiAgICBUcmVlMC5vZl9saXN0X3dpdGhfa2V5X3JlZHVjZVxuICAgICAgbGlzdFxuICAgICAgfmdldF9rZXlcbiAgICAgIH5mXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB8PiBvZl90cmVlMCB+Y29tcGFyYXRvclxuICA7O1xuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3Qga19vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBtYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBtYXRjaCBUcmVlMC5tYXBfa2V5cyB0LnRyZWUgfmYgfmNvbXBhcmF0b3Igd2l0aFxuICAgIHwgYE9rIHBhaXIgLT4gYE9rIChvZl90cmVlMCB+Y29tcGFyYXRvciBwYWlyKVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkdXAgLT4gZHVwXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzX2V4biB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAubWFwX2tleXNfZXhuIHQudHJlZSB+ZiB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgdHJhbnNwb3NlX2tleXMgfmNvbXBhcmF0b3I6aW5uZXJfY29tcGFyYXRvciB0ID1cbiAgICBsZXQgb3V0ZXJfY29tcGFyYXRvciA9IHQuY29tcGFyYXRvciBpblxuICAgIFRyZWUwLnRyYW5zcG9zZV9rZXlzIH5vdXRlcl9jb21wYXJhdG9yIH5pbm5lcl9jb21wYXJhdG9yIChUcmVlMC5tYXAgdC50cmVlIH5mOnRvX3RyZWUpXG4gICAgfD4gb2ZfdHJlZTAgfmNvbXBhcmF0b3I6aW5uZXJfY29tcGFyYXRvclxuICAgIHw+IG1hcCB+ZjooZnVuIHggLT4gb2ZfdHJlZTAgfmNvbXBhcmF0b3I6b3V0ZXJfY29tcGFyYXRvciB4KVxuICA7O1xuXG4gIG1vZHVsZSBFbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChLIDogQ29tcGFyYXRvci5TMSkgPSBzdHJ1Y3RcbiAgICBsZXQgZW1wdHkgPSB7IHRyZWUgPSBUcmVlMC5lbXB0eTsgY29tcGFyYXRvciA9IEsuY29tcGFyYXRvcjsgbGVuZ3RoID0gMCB9XG4gIGVuZFxuXG4gIG1vZHVsZSBUcmVlID0gVHJlZVxuZW5kXG5cbmluY2x1ZGUgQWNjZXNzb3JzXG5cbmxldCBjb21wYXJhdG9yX3MgdCA9IENvbXBhcmF0b3IudG9fbW9kdWxlIHQuY29tcGFyYXRvclxubGV0IHRvX2NvbXBhcmF0b3IgPSBDb21wYXJhdG9yLm9mX21vZHVsZVxubGV0IG9mX3RyZWUgbSB0cmVlID0gb2ZfdHJlZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSB0cmVlXG5sZXQgZW1wdHkgbSA9IFVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcbmxldCBzaW5nbGV0b24gbSBhID0gVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2FsaXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3QgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuXG5sZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgbSBhID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9vcl9lcnJvciB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgb2ZfYWxpc3RfZXhuIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfZXhuIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9hbGlzdF9tdWx0aSBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X211bHRpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcblxubGV0IG9mX2FsaXN0X2ZvbGQgbSBhIH5pbml0IH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmluaXQgfmZcbjs7XG5cbmxldCBvZl9hbGlzdF9yZWR1Y2UgbSBhIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+ZlxuOztcblxubGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgbSBhID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBvZl9zb3J0ZWRfYXJyYXkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2l0ZXJpIG0gfml0ZXJpID0gVXNpbmdfY29tcGFyYXRvci5vZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcblxubGV0IG9mX2l0ZXJpX2V4biBtIH5pdGVyaSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaXRlcmlfZXhuIH5pdGVyaSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxuOztcblxubGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIG0gfmxlbiB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxuOztcblxubGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgbSBzZXEgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc2VxXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2UgbSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG5cbmxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciBtIHMgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX29yX2Vycm9yIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZV9leG4gbSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc1xuXG5sZXQgb2Zfc2VxdWVuY2VfbXVsdGkgbSBzID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2VfZm9sZCBtIHMgfmluaXQgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgcyB+aW5pdCB+ZlxuOztcblxubGV0IG9mX3NlcXVlbmNlX3JlZHVjZSBtIHMgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzIH5mXG47O1xuXG5sZXQgb2ZfbGlzdF93aXRoX2tleSBtIGwgfmdldF9rZXkgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgbCB+Z2V0X2tleVxuOztcblxubGV0IG9mX2xpc3Rfd2l0aF9rZXlfb3JfZXJyb3IgbSBsIH5nZXRfa2V5ID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGwgfmdldF9rZXlcbjs7XG5cbmxldCBvZl9saXN0X3dpdGhfa2V5X2V4biBtIGwgfmdldF9rZXkgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfZXhuIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGwgfmdldF9rZXlcbjs7XG5cbmxldCBvZl9saXN0X3dpdGhfa2V5X211bHRpIG0gbCB+Z2V0X2tleSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9tdWx0aSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBsIH5nZXRfa2V5XG47O1xuXG5sZXQgb2ZfbGlzdF93aXRoX2tleV9mb2xkIG0gbCB+Z2V0X2tleSB+aW5pdCB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9mb2xkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGwgfmdldF9rZXkgfmluaXQgfmZcbjs7XG5cbmxldCBvZl9saXN0X3dpdGhfa2V5X3JlZHVjZSBtIGwgfmdldF9rZXkgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfcmVkdWNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGwgfmdldF9rZXkgfmZcbjs7XG5cbmxldCBtYXBfa2V5cyBtIHQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcF9rZXlzIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHQgfmZcbmxldCBtYXBfa2V5c19leG4gbSB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5c19leG4gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdCB+ZlxubGV0IHRyYW5zcG9zZV9rZXlzIG0gdCA9IFVzaW5nX2NvbXBhcmF0b3IudHJhbnNwb3NlX2tleXMgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdFxuXG5tb2R1bGUgTSAoSyA6IHNpZ1xuICB0eXBlIHRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbmVuZCkgPVxuc3RydWN0XG4gIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxubW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGspIChtb2R1bGUgSyA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGspIHNleHBfb2ZfdiB0ID1cbiAgc2V4cF9vZl90IEsuc2V4cF9vZl90IHNleHBfb2ZfdiAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwXG4gICh0eXBlIGsgY21wKVxuICAobW9kdWxlIEsgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBrIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcClcbiAgdl9vZl9zZXhwXG4gIHNleHBcbiAgPVxuICBVc2luZ19jb21wYXJhdG9yLnRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3I6Sy5jb21wYXJhdG9yIEsudF9vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwXG47O1xuXG5sZXQgbV9fdF9zZXhwX2dyYW1tYXJcbiAgKHR5cGUgaylcbiAgKG1vZHVsZSBLIDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBrKVxuICAodl9ncmFtbWFyIDogXyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBfIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgeyB1bnR5cGVkID1cbiAgICAgIFRhZ2dlZFxuICAgICAgICB7IGtleSA9IFNleHBsaWIwLlNleHBfZ3JhbW1hci5hc3NvY190YWdcbiAgICAgICAgOyB2YWx1ZSA9IExpc3QgW11cbiAgICAgICAgOyBncmFtbWFyID1cbiAgICAgICAgICAgIExpc3RcbiAgICAgICAgICAgICAgKE1hbnlcbiAgICAgICAgICAgICAgICAgKExpc3RcbiAgICAgICAgICAgICAgICAgICAgKENvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgKCBUYWdnZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5ID0gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmFzc29jX2tleV90YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgdmFsdWUgPSBMaXN0IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA7IGdyYW1tYXIgPSBLLnRfc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgLCBDb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoIFRhZ2dlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5ID0gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmFzc29jX3ZhbHVlX3RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgdmFsdWUgPSBMaXN0IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBncmFtbWFyID0gdl9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAsIEVtcHR5ICkgKSkpKVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBjb21wYXJlX21fX3QgKG1vZHVsZSBfIDogQ29tcGFyZV9tKSBjb21wYXJlX3YgdDEgdDIgPSBjb21wYXJlX2RpcmVjdCBjb21wYXJlX3YgdDEgdDJcbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIGVxdWFsX3YgdDEgdDIgPSBlcXVhbCBlcXVhbF92IHQxIHQyXG5cbmxldCBoYXNoX2ZvbGRfbV9fdCAodHlwZSBrKSAobW9kdWxlIEsgOiBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9IGspIGhhc2hfZm9sZF92IHN0YXRlID1cbiAgaGFzaF9mb2xkX2RpcmVjdCBLLmhhc2hfZm9sZF90IGhhc2hfZm9sZF92IHN0YXRlXG47O1xuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2ssICd2KSB0ID0gKCdrLCAndiwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICB0eXBlIG5vbnJlYyAoJ2ssICd2KSB0cmVlID0gKCdrLCAndikgVHJlZTAudFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3NcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBjb21wYXJhdG9yID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3JcbiAgbGV0IG9mX3RyZWUgdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvcjsgbGVuZ3RoID0gVHJlZTAubGVuZ3RoIHRyZWUgfVxuXG4gIGluY2x1ZGUgVXNpbmdfY29tcGFyYXRvci5FbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChDb21wYXJhdG9yLlBvbHkpXG5cbiAgbGV0IHNpbmdsZXRvbiBhID0gVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3QgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3RfZXhuIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdF9tdWx0aSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9tdWx0aSB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdF9mb2xkIGEgfmluaXQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2ZvbGQgfmNvbXBhcmF0b3IgYSB+aW5pdCB+ZlxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvciBhIH5mXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYSA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9pdGVyaSB+aXRlcmkgPSBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyYXRvclxuICBsZXQgb2ZfaXRlcmlfZXhuIH5pdGVyaSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfaXRlcmlfZXhuIH5pdGVyaSB+Y29tcGFyYXRvclxuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgfmNvbXBhcmF0b3JcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxXG4gIGxldCBvZl9zZXF1ZW5jZSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvciBzXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfZXhuIH5jb21wYXJhdG9yIHNcbiAgbGV0IG9mX3NlcXVlbmNlX211bHRpIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX211bHRpIH5jb21wYXJhdG9yIHNcblxuICBsZXQgb2Zfc2VxdWVuY2VfZm9sZCBzIH5pbml0IH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3IgcyB+aW5pdCB+ZlxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgcyB+ZiA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfcmVkdWNlIH5jb21wYXJhdG9yIHMgfmZcblxuICBsZXQgb2ZfbGlzdF93aXRoX2tleSBsIH5nZXRfa2V5ID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXkgfmNvbXBhcmF0b3IgbCB+Z2V0X2tleVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X29yX2Vycm9yIGwgfmdldF9rZXkgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9vcl9lcnJvciB+Y29tcGFyYXRvciBsIH5nZXRfa2V5XG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfZXhuIGwgfmdldF9rZXkgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9leG4gfmNvbXBhcmF0b3IgbCB+Z2V0X2tleVxuICA7O1xuXG4gIGxldCBvZl9saXN0X3dpdGhfa2V5X211bHRpIGwgfmdldF9rZXkgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9tdWx0aSB+Y29tcGFyYXRvciBsIH5nZXRfa2V5XG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfZm9sZCBsIH5nZXRfa2V5IH5pbml0IH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3Rfd2l0aF9rZXlfZm9sZCB+Y29tcGFyYXRvciBsIH5nZXRfa2V5IH5pbml0IH5mXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3Rfd2l0aF9rZXlfcmVkdWNlIGwgfmdldF9rZXkgfmYgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdF93aXRoX2tleV9yZWR1Y2UgfmNvbXBhcmF0b3IgbCB+Z2V0X2tleSB+ZlxuICA7O1xuXG4gIGxldCBtYXBfa2V5cyB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mXG4gIGxldCBtYXBfa2V5c19leG4gdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmZcbiAgbGV0IHRyYW5zcG9zZV9rZXlzIHQgPSBVc2luZ19jb21wYXJhdG9yLnRyYW5zcG9zZV9rZXlzIH5jb21wYXJhdG9yIHRcbmVuZFxuIiwib3BlbiEgSW1wb3J0MFxuXG50eXBlICdhIHQgPSAnYSBTdGRsaWIuUXVldWUudFxuXG5sZXQgY3JlYXRlID0gU3RkbGliLlF1ZXVlLmNyZWF0ZVxubGV0IGNsZWFyID0gU3RkbGliLlF1ZXVlLmNsZWFyXG5sZXQgY29weSA9IFN0ZGxpYi5RdWV1ZS5jb3B5XG5sZXQgaXNfZW1wdHkgPSBTdGRsaWIuUXVldWUuaXNfZW1wdHlcbmxldCBsZW5ndGggPSBTdGRsaWIuUXVldWUubGVuZ3RoXG5sZXQgcGVlayA9IFN0ZGxpYi5RdWV1ZS5wZWVrXG5sZXQgcG9wID0gU3RkbGliLlF1ZXVlLnBvcFxubGV0IHB1c2ggPSBTdGRsaWIuUXVldWUucHVzaFxubGV0IHRyYW5zZmVyID0gU3RkbGliLlF1ZXVlLnRyYW5zZmVyXG5cbmxldCBpdGVyIHQgfihmIDogXyAtPiBfKSA9XG4gIGxldCBjYW1sX2l0ZXIgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0ID1cbiAgICBTdGRsaWIuT2JqLm1hZ2ljIChTdGRsaWIuUXVldWUuaXRlciA6ICgnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXQpXG4gIGluXG4gIGNhbWxfaXRlciBmIHRcbjs7XG5cbmxldCBmb2xkIHQgfmluaXQgfihmIDogXyAtPiBfIC0+IF8pID1cbiAgbGV0IGNhbWxfZm9sZCA6ICgnYiAtPiAnYSAtPiAnYikgLT4gJ2IgLT4gJ2EgdCAtPiAnYiA9XG4gICAgU3RkbGliLk9iai5tYWdpYyAoU3RkbGliLlF1ZXVlLmZvbGQgOiAoJ2IgLT4gJ2EgLT4gJ2IpIC0+ICdiIC0+ICdhIHQgLT4gJ2IpXG4gIGluXG4gIGNhbWxfZm9sZCBmIGluaXQgdFxuOztcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBMaW5rZWRfcXVldWUwXG5cbmxldCBlbnF1ZXVlIHQgeCA9IExpbmtlZF9xdWV1ZTAucHVzaCB4IHRcbmxldCBkZXF1ZXVlIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKExpbmtlZF9xdWV1ZTAucG9wIHQpXG5sZXQgZGVxdWV1ZV9leG4gPSBMaW5rZWRfcXVldWUwLnBvcFxubGV0IGRlcXVldWVfYW5kX2lnbm9yZV9leG4gKHR5cGUgZWx0KSAodCA6IGVsdCB0KSA9IGlnbm9yZSAoZGVxdWV1ZV9leG4gdCA6IGVsdClcbmxldCBwZWVrIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKExpbmtlZF9xdWV1ZTAucGVlayB0KVxubGV0IHBlZWtfZXhuID0gTGlua2VkX3F1ZXVlMC5wZWVrXG5cbmxldCBkcmFpbiB0IH5mIH53aGlsZV8gPVxuICB3aGlsZSAobm90IChpc19lbXB0eSB0KSkgJiYgd2hpbGVfIChwZWVrX2V4biB0KSBkb1xuICAgIGYgKGRlcXVldWVfZXhuIHQpXG4gIGRvbmVcbjs7XG5cbm1vZHVsZSBDID0gSW5kZXhlZF9jb250YWluZXIuTWFrZSAoc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgbGV0IGZvbGQgPSBmb2xkXG4gIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICBsZXQgZm9sZGkgPSBgRGVmaW5lX3VzaW5nX2ZvbGRcbiAgbGV0IGl0ZXJpID0gYERlZmluZV91c2luZ19mb2xkXG5lbmQpXG5cbmxldCBjb3VudCA9IEMuY291bnRcbmxldCBleGlzdHMgPSBDLmV4aXN0c1xubGV0IGZpbmQgPSBDLmZpbmRcbmxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbmxldCBmb2xkX3Jlc3VsdCA9IEMuZm9sZF9yZXN1bHRcbmxldCBmb2xkX3VudGlsID0gQy5mb2xkX3VudGlsXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbmxldCBtZW0gPSBDLm1lbVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBzdW0gPSBDLnN1bVxubGV0IHRvX2xpc3QgPSBDLnRvX2xpc3RcbmxldCBjb3VudGkgPSBDLmNvdW50aVxubGV0IGV4aXN0c2kgPSBDLmV4aXN0c2lcbmxldCBmaW5kX21hcGkgPSBDLmZpbmRfbWFwaVxubGV0IGZpbmRpID0gQy5maW5kaVxubGV0IGZvbGRpID0gQy5mb2xkaVxubGV0IGZvcl9hbGxpID0gQy5mb3JfYWxsaVxubGV0IGl0ZXJpID0gQy5pdGVyaVxubGV0IHRyYW5zZmVyIH5zcmMgfmRzdCA9IExpbmtlZF9xdWV1ZTAudHJhbnNmZXIgc3JjIGRzdFxuXG5sZXQgY29uY2F0X21hcCB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IExpc3QuaXRlciAoZiBhKSB+ZjooZnVuIGIgLT4gZW5xdWV1ZSByZXMgYikpO1xuICByZXNcbjs7XG5cbmxldCBjb25jYXRfbWFwaSB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IExpc3QuaXRlciAoZiBpIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHJlcyBiKSk7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPlxuICAgIG1hdGNoIGYgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSByZXMgYik7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT5cbiAgICBtYXRjaCBmIGkgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSByZXMgYik7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IGlmIGYgYSB0aGVuIGVucXVldWUgcmVzIGEpO1xuICByZXNcbjs7XG5cbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gaWYgZiBpIGEgdGhlbiBlbnF1ZXVlIHJlcyBhKTtcbiAgcmVzXG47O1xuXG5sZXQgbWFwIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gZW5xdWV1ZSByZXMgKGYgYSkpO1xuICByZXNcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gZW5xdWV1ZSByZXMgKGYgaSBhKSk7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcl9pbnBsYWNlIHEgfmYgPVxuICBsZXQgcScgPSBmaWx0ZXIgcSB+ZiBpblxuICBjbGVhciBxO1xuICB0cmFuc2ZlciB+c3JjOnEnIH5kc3Q6cVxuOztcblxubGV0IGZpbHRlcmlfaW5wbGFjZSBxIH5mID1cbiAgbGV0IHEnID0gZmlsdGVyaSBxIH5mIGluXG4gIGNsZWFyIHE7XG4gIHRyYW5zZmVyIH5zcmM6cScgfmRzdDpxXG47O1xuXG5sZXQgZW5xdWV1ZV9hbGwgdCBsaXN0ID0gTGlzdC5pdGVyIGxpc3QgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KVxuXG5sZXQgb2ZfbGlzdCBsaXN0ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgTGlzdC5pdGVyIGxpc3QgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KTtcbiAgdFxuOztcblxubGV0IG9mX2FycmF5IGFycmF5ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgQXJyYXkuaXRlciBhcnJheSB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpO1xuICB0XG47O1xuXG5sZXQgaW5pdCBsZW4gfmYgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGVucXVldWUgdCAoZiBpKVxuICBkb25lO1xuICB0XG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9XG4gIG1hdGNoIGxlbmd0aCB0IHdpdGhcbiAgfCAwIC0+IFt8fF1cbiAgfCBsZW4gLT5cbiAgICBsZXQgYXJyID0gQXJyYXkuY3JlYXRlIH5sZW4gKHBlZWtfZXhuIHQpIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGl0ZXIgdCB+ZjooZnVuIHYgLT5cbiAgICAgIGFyci4oIWkpIDwtIHY7XG4gICAgICBpbmNyIGkpO1xuICAgIGFyclxuOztcblxubGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9IG9mX2xpc3QgKGxpc3Rfb2Zfc2V4cCBhX29mX3NleHAgc2V4cClcbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl9hICh0b19saXN0IHQpXG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoZ3JhbW1hciA6IGEgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuOztcblxubGV0IHNpbmdsZXRvbiBhID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgZW5xdWV1ZSB0IGE7XG4gIHRcbjs7XG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIFN0ZGxpYi5JbnQ2NFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQ2NCBbQEBkZXJpdmluZ19pbmxpbmUgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKGdsb2JhbGl6ZV9pbnQ2NCA6IHQgLT4gdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludDY0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoaW50NjRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfaW50NjQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gaW50NjRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlID0gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmVcbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG4gIGxldCBvZl9zdHJpbmdfb3B0ID0gb2Zfc3RyaW5nX29wdFxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmxldCBudW1fYml0cyA9IDY0XG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcblxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0c1xuICA6ICAoaW50NjRbQGxvY2FsX29wdF0pXG4gIC0+IChmbG9hdFtAbG9jYWxfb3B0XSlcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0XG4gIDogIChmbG9hdFtAbG9jYWxfb3B0XSlcbiAgLT4gKGludDY0W0Bsb2NhbF9vcHRdKVxuICA9IFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsID0gc2hpZnRfcmlnaHRfbG9naWNhbFxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdFxubGV0IGJpdF9ub3QgPSBsb2dub3RcbmxldCBiaXRfeG9yID0gbG9neG9yXG5sZXQgYml0X29yID0gbG9nb3JcbmxldCBiaXRfYW5kID0gbG9nYW5kXG5sZXQgbWluX3ZhbHVlID0gbWluX2ludFxubGV0IG1heF92YWx1ZSA9IG1heF9pbnRcbmxldCBhYnMgPSBhYnNcbmxldCBwcmVkID0gcHJlZFxubGV0IHN1Y2MgPSBzdWNjXG5sZXQgcG93ID0gSW50X21hdGguUHJpdmF0ZS5pbnQ2NF9wb3dcbmxldCByZW0gPSByZW1cbmxldCBuZWcgPSBuZWdcbmxldCBtaW51c19vbmUgPSBtaW51c19vbmVcbmxldCBvbmUgPSBvbmVcbmxldCB6ZXJvID0gemVyb1xubGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBTdGRsaWIuSW50NjQub2ZfZmxvYXRcblxubGV0IG9mX2Zsb2F0IGYgPVxuICBpZiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGYgZmxvYXRfbG93ZXJfYm91bmRcbiAgICAgJiYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBmIGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gU3RkbGliLkludDY0Lm9mX2Zsb2F0IGZcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiSW50NjQub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCBmKVxuICAgICAgKClcbjs7XG5cbigqIE5vdCBldGEtZXhwYW5kaW5nIGhlcmUgY2FuIGxlYWQgdG8gbGVzcyBhbGxvY2F0aW9uczogdGhlIGZ1bmN0aW9uIGNhbGwgc2l0ZXMgY2FuIGF2b2lkXG4gICBib3hpbmcgdGhlIGludDY0cyBtb3JlIG9mdGVuLiAqKVxubGV0ICggKiogKSA9IHBvd1xuXG5leHRlcm5hbCBic3dhcDY0IDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWJzd2FwX2ludDY0XCJcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBic3dhcDE2IHggPSBTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCAoYnN3YXA2NCB4KSA0OFxuXG5sZXRbQGlubGluZSBhbHdheXNdIGJzd2FwMzIgeCA9XG4gICgqIFRoaXMgaXMgc3RyaWN0bHkgYmV0dGVyIHRoYW4gY29lcmNpbmcgdG8gYW4gaW50MzIgdG8gcGVyZm9ybSBieXRlc3dhcC4gQ29lcmNpbmdcbiAgICAgZnJvbSBhbiBpbnQzMiB3aWxsIGFkZCB1bm5lY2Vzc2FyeSBzaGlmdCBvcGVyYXRpb25zIHRvIHNpZ24gZXh0ZW5kIHRoZSBudW1iZXJcbiAgICAgYXBwcm9wcmlhdGVseS5cbiAgKilcbiAgU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJzd2FwNjQgeCkgMzJcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gYnN3YXA0OCB4ID0gU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJzd2FwNjQgeCkgMTZcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gIGluY2x1ZGUgVFxuXG4gIGxldCB6ZXJvID0gemVyb1xuZW5kKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbjptaW5fIH5tYXg6bWF4XyA9IG1pbiB0IG1heF8gfD4gbWF4IG1pbl9cblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCBpbmNyIHIgPSByIDo9IGFkZCAhciBvbmVcbmxldCBkZWNyIHIgPSByIDo9IHN1YiAhciBvbmVcblxuZXh0ZXJuYWwgb2ZfaW50NjQgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgb2ZfaW50NjRfZXhuID0gb2ZfaW50NjRcbmxldCB0b19pbnQ2NCB0ID0gdFxubGV0IHBvcGNvdW50ID0gUG9wY291bnQuaW50NjRfcG9wY291bnRcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcblxuZXh0ZXJuYWwgdG9faW50X3RydW5jIDogKHRbQGxvY2FsX29wdF0pIC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG5leHRlcm5hbCB0b19pbnQzMl90cnVuYyA6IChpbnQ2NFtAbG9jYWxfb3B0XSkgLT4gKGludDMyW0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X3RvX2ludDMyXCJcblxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50X3RydW5jXG4gIDogIChpbnQ2NFtAbG9jYWxfb3B0XSlcbiAgLT4gKG5hdGl2ZWludFtAbG9jYWxfb3B0XSlcbiAgPSBcIiVpbnQ2NF90b19uYXRpdmVpbnRcIlxuXG5leHRlcm5hbCBvZl9pbnQgOiAoaW50W0Bsb2NhbF9vcHRdKSAtPiAoaW50NjRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfb2ZfaW50XCJcbmV4dGVybmFsIG9mX2ludDMyIDogKGludDMyW0Bsb2NhbF9vcHRdKSAtPiAoaW50NjRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfb2ZfaW50MzJcIlxuXG5sZXQgb2ZfaW50X2V4biA9IG9mX2ludFxubGV0IHRvX2ludCA9IENvbnYuaW50NjRfdG9faW50XG5sZXQgdG9faW50X2V4biA9IENvbnYuaW50NjRfdG9faW50X2V4blxubGV0IG9mX2ludDMyX2V4biA9IG9mX2ludDMyXG5sZXQgdG9faW50MzIgPSBDb252LmludDY0X3RvX2ludDMyXG5sZXQgdG9faW50MzJfZXhuID0gQ29udi5pbnQ2NF90b19pbnQzMl9leG5cblxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50IDogKG5hdGl2ZWludFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfb2ZfbmF0aXZlaW50XCJcblxubGV0IG9mX25hdGl2ZWludF9leG4gPSBvZl9uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnQgPSBDb252LmludDY0X3RvX25hdGl2ZWludFxubGV0IHRvX25hdGl2ZWludF9leG4gPSBDb252LmludDY0X3RvX25hdGl2ZWludF9leG5cblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG4gIG9wZW4gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgbGV0IG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKSA9XG4gICAgUHJpbnRmLmludmFsaWRfYXJnZiBcImFyZ3VtZW50IG11c3QgYmUgc3RyaWN0bHkgcG9zaXRpdmVcIiAoKVxuICA7O1xuXG4gIGxldCAoIGxvciApID0gU3RkbGliLkludDY0LmxvZ29yXG4gIGxldCAoIGxzciApID0gU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbiAgbGV0ICggbGFuZCApID0gU3RkbGliLkludDY0LmxvZ2FuZFxuXG4gICgqKiBcImNlaWxpbmcgcG93ZXIgb2YgMlwiIC0gTGVhc3QgcG93ZXIgb2YgMiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGNlaWxfcG93MiB4ID1cbiAgICBpZiB4IDw9IFN0ZGxpYi5JbnQ2NC56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0gU3RkbGliLkludDY0LnByZWQgeCBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgU3RkbGliLkludDY0LnN1Y2MgeFxuICA7O1xuXG4gICgqKiBcImZsb29yIHBvd2VyIG9mIDJcIiAtIExhcmdlc3QgcG93ZXIgb2YgMiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGZsb29yX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBTdGRsaWIuSW50NjQuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIFN0ZGxpYi5JbnQ2NC5zdWIgeCAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IFN0ZGxpYi5JbnQ2NC56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIHggbGFuZCBTdGRsaWIuSW50NjQucHJlZCB4ID0gU3RkbGliLkludDY0Lnplcm9cbiAgOztcblxuICAoKiBDIHN0dWJzIGZvciBpbnQgY2x6IGFuZCBjdHogdG8gdXNlIHRoZSBDTFovQlNSL0NUWi9CU0YgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbiAgZXh0ZXJuYWwgY2x6XG4gICAgOiAgKGludDY0W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50NjRfY2x6XCIgXCJCYXNlX2ludF9tYXRoX2ludDY0X2Nsel91bmJveGVkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGN0elxuICAgIDogIChpbnQ2NFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDY0X2N0elwiIFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jdHpfdW5ib3hlZFwiXG4gICAgW0BAbm9hbGxvY11cblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBmbG9vcl9sb2cyIGkgPVxuICAgIGlmIGkgPD0gU3RkbGliLkludDY0Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJbSW50NjQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50NjQgaSBdKTtcbiAgICBudW1fYml0cyAtIDEgLSBjbHogaVxuICA7O1xuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBQb2x5LiggPD0gKSBpIFN0ZGxpYi5JbnQ2NC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludDY0LmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50NjQgaSBdKTtcbiAgICBpZiBTdGRsaWIuSW50NjQuZXF1YWwgaSBTdGRsaWIuSW50NjQub25lXG4gICAgdGhlbiAwXG4gICAgZWxzZSBudW1fYml0cyAtIGNseiAoU3RkbGliLkludDY0LnByZWQgaSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFBvdzJcbmluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9ucy5NYWtlIChUKVxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZV9oZXggKHN0cnVjdFxuICB0eXBlIHQgPSBpbnQ2NCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGhhc2hdXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKGNvbXBhcmVfaW50NjRfX2xvY2FsIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50NjRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludDY0IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgKCA8ICkgPSAoIDwgKVxuICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiVMeFwiIGlcbiAgbGV0IG9mX3N0cmluZyBzID0gU3RkbGliLlNjYW5mLnNzY2FuZiBzIFwiJUx4XCIgRm4uaWRcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDY0LkhleFwiXG5lbmQpXG5cbmluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9ucy5NYWtlX2JpbmFyeSAoc3RydWN0XG4gIHR5cGUgdCA9IGludDY0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBoYXNoXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA9IChjb21wYXJlX2ludDY0X19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGVxdWFsX19sb2NhbCA9IChlcXVhbF9pbnQ2NF9fbG9jYWwgOiB0IC0+IHQgLT4gYm9vbClcbiAgbGV0IGVxdWFsID0gKGZ1biBhIGIgLT4gZXF1YWxfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50NjRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludDY0IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgKCBsYW5kICkgPSAoIGxhbmQgKVxuICBsZXQgKCBsc3IgKSA9ICggbHNyIClcbiAgbGV0IGNseiA9IGNselxuICBsZXQgbnVtX2JpdHMgPSBudW1fYml0c1xuICBsZXQgb25lID0gb25lXG4gIGxldCB0b19pbnRfZXhuID0gdG9faW50X2V4blxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50NjRcIlxuZW5kKVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgKCArICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X2FkZFwiXG4gIGV4dGVybmFsICggLSApIDogKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVpbnQ2NF9zdWJcIlxuICBleHRlcm5hbCAoICogKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfbXVsXCJcbiAgZXh0ZXJuYWwgKCAvICkgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pIC0+ICh0W0Bsb2NhbF9vcHRdKSA9IFwiJWludDY0X2RpdlwiXG4gIGV4dGVybmFsICggfi0gKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgPSBcIiVpbnQ2NF9uZWdcIlxuXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCBhYnMgPSBhYnNcblxuICBleHRlcm5hbCBuZWcgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfbmVnXCJcblxuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGluY2x1ZGUgUHJlX09cblxuICAgIGxldCByZW0gPSByZW1cbiAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgIGxldCBvZl9mbG9hdCA9IG9mX2Zsb2F0XG4gICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gIGVuZClcblxuICBleHRlcm5hbCAoIGxhbmQgKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfYW5kXCJcbiAgZXh0ZXJuYWwgKCBsb3IgKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfb3JcIlxuICBleHRlcm5hbCAoIGx4b3IgKSA6ICh0W0Bsb2NhbF9vcHRdKSAtPiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlaW50NjRfeG9yXCJcblxuICBsZXQgbG5vdCA9IGJpdF9ub3RcblxuICBleHRlcm5hbCAoIGxzbCApXG4gICAgOiAgKHRbQGxvY2FsX29wdF0pXG4gICAgLT4gKGludFtAbG9jYWxfb3B0XSlcbiAgICAtPiAodFtAbG9jYWxfb3B0XSlcbiAgICA9IFwiJWludDY0X2xzbFwiXG5cbiAgZXh0ZXJuYWwgKCBhc3IgKVxuICAgIDogICh0W0Bsb2NhbF9vcHRdKVxuICAgIC0+IChpbnRbQGxvY2FsX29wdF0pXG4gICAgLT4gKHRbQGxvY2FsX29wdF0pXG4gICAgPSBcIiVpbnQ2NF9hc3JcIlxuXG4gIGV4dGVybmFsICggbHNyIClcbiAgICA6ICAodFtAbG9jYWxfb3B0XSlcbiAgICAtPiAoaW50W0Bsb2NhbF9vcHRdKVxuICAgIC0+ICh0W0Bsb2NhbF9vcHRdKVxuICAgID0gXCIlaW50NjRfbHNyXCJcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW0ludDY0XSBhbmQgW0ludDY0Lk9dIGFncmVlIHZhbHVlLXdpc2UgKilcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwiKCogQSA2M2JpdCBpbnRlZ2VyIGlzIGEgNjRiaXQgaW50ZWdlciB3aXRoIGl0cyBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnRcbiAgIGFuZCBpdHMgbG93ZXN0IGJpdCBzZXQgdG8gMC5cbiAgIFRoaXMgaXMgdGhlIHNhbWUga2luZCBvZiBlbmNvZGluZyBhcyBPQ2FtbCBpbnQgb24gNjRiaXQgYXJjaGl0ZWN0dXJlLlxuICAgVGhlIG9ubHkgZGlmZmVyZW5jZSBiZWluZyB0aGUgbG93ZXN0IGJpdCAoaW1tZWRpYXRlIGJpdCkgc2V0IHRvIDEuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubW9kdWxlIFQwID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSB0ID0gaW50NjRcbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKGNvbXBhcmVfaW50NjRfX2xvY2FsIDogdCAtPiB0IC0+IGludClcbiAgICBsZXQgY29tcGFyZSA9IChmdW4gYSBiIC0+IGNvbXBhcmVfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBpbnQpXG4gICAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKGdsb2JhbGl6ZV9pbnQ2NCA6IHQgLT4gdClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIGhhc2hfZm9sZF9pbnQ2NFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBoYXNoX2ludDY0IGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgbGV0IHRfb2Zfc2V4cCA9IChpbnQ2NF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gICAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2ludDY0IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gaW50NjRfc2V4cF9ncmFtbWFyXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5lbmRcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcblxubW9kdWxlIFcgOiBzaWdcbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICBpbmNsdWRlIFQwXG4gIGVuZFxuXG4gIHR5cGUgdCA9IGludDY0XG5cbiAgdmFsIHdyYXBfZXhuIDogU3RkbGliLkludDY0LnQgLT4gdFxuICB2YWwgd3JhcF9tb2R1bG8gOiBTdGRsaWIuSW50NjQudCAtPiB0XG4gIHZhbCB1bndyYXAgOiB0IC0+IFN0ZGxpYi5JbnQ2NC50XG5cbiAgKCoqIFJldHVybnMgYSBub24tbmVnYXRpdmUgaW50NjQgdGhhdCBpcyBlcXVhbCB0byB0aGUgaW5wdXQgaW50NjMgbW9kdWxvIDJeNjMuICopXG4gIHZhbCB1bndyYXBfdW5zaWduZWQgOiB0IC0+IFN0ZGxpYi5JbnQ2NC50XG5cbiAgdmFsIGludmFyaWFudCA6IHQgLT4gdW5pdFxuICB2YWwgYWRkIDogdCAtPiB0IC0+IHRcbiAgdmFsIHN1YiA6IHQgLT4gdCAtPiB0XG4gIHZhbCBuZWcgOiB0IC0+IHRcbiAgdmFsIGFicyA6IHQgLT4gdFxuICB2YWwgc3VjYyA6IHQgLT4gdFxuICB2YWwgcHJlZCA6IHQgLT4gdFxuICB2YWwgbXVsIDogdCAtPiB0IC0+IHRcbiAgdmFsIHBvdyA6IHQgLT4gdCAtPiB0XG4gIHZhbCBkaXYgOiB0IC0+IHQgLT4gdFxuICB2YWwgcmVtIDogdCAtPiB0IC0+IHRcbiAgdmFsIHBvcGNvdW50IDogdCAtPiBpbnRcbiAgdmFsIGJpdF9ub3QgOiB0IC0+IHRcbiAgdmFsIGJpdF94b3IgOiB0IC0+IHQgLT4gdFxuICB2YWwgYml0X29yIDogdCAtPiB0IC0+IHRcbiAgdmFsIGJpdF9hbmQgOiB0IC0+IHQgLT4gdFxuICB2YWwgc2hpZnRfbGVmdCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIHNoaWZ0X3JpZ2h0IDogdCAtPiBpbnQgLT4gdFxuICB2YWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIG1pbl92YWx1ZSA6IHRcbiAgdmFsIG1heF92YWx1ZSA6IHRcbiAgdmFsIHRvX2ludDY0IDogdCAtPiBTdGRsaWIuSW50NjQudFxuICB2YWwgb2ZfaW50NjQgOiBTdGRsaWIuSW50NjQudCAtPiB0IG9wdGlvblxuICB2YWwgb2ZfaW50NjRfZXhuIDogU3RkbGliLkludDY0LnQgLT4gdFxuICB2YWwgb2ZfaW50NjRfdHJ1bmMgOiBTdGRsaWIuSW50NjQudCAtPiB0XG4gIHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuICB2YWwgY29tcGFyZV9fbG9jYWwgOiB0IC0+IHQgLT4gaW50XG4gIHZhbCBlcXVhbF9fbG9jYWwgOiB0IC0+IHQgLT4gYm9vbFxuICB2YWwgY2VpbF9wb3cyIDogdCAtPiB0XG4gIHZhbCBmbG9vcl9wb3cyIDogdCAtPiB0XG4gIHZhbCBjZWlsX2xvZzIgOiB0IC0+IGludFxuICB2YWwgZmxvb3JfbG9nMiA6IHQgLT4gaW50XG4gIHZhbCBpc19wb3cyIDogdCAtPiBib29sXG4gIHZhbCBjbHogOiB0IC0+IGludFxuICB2YWwgY3R6IDogdCAtPiBpbnRcbmVuZCA9IHN0cnVjdFxuICBpbmNsdWRlIFQwXG5cbiAgdHlwZSB0ID0gaW50NjRcblxuICBsZXQgd3JhcF9leG4geCA9XG4gICAgKCogUmFpc2VzIGlmIHRoZSBpbnQ2NCB2YWx1ZSBkb2VzIG5vdCBmaXQgb24gaW50NjMuICopXG4gICAgQ29udi5pbnQ2NF9maXRfb25faW50NjNfZXhuIHg7XG4gICAgU3RkbGliLkludDY0Lm11bCB4IDJMXG4gIDs7XG5cbiAgbGV0IHdyYXAgeCA9XG4gICAgaWYgQ29udi5pbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYzIHggdGhlbiBTb21lIChTdGRsaWIuSW50NjQubXVsIHggMkwpIGVsc2UgTm9uZVxuICA7O1xuXG4gIGxldCB3cmFwX21vZHVsbyB4ID0gU3RkbGliLkludDY0Lm11bCB4IDJMXG4gIGxldCB1bndyYXAgeCA9IFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodCB4IDFcbiAgbGV0IHVud3JhcF91bnNpZ25lZCB4ID0gU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgeCAxXG5cbiAgKCogVGhpcyBkb2VzIG5vdCB1c2Ugd3JhcCBvciB1bndyYXAgdG8gYXZvaWQgZ2VuZXJhdGluZyBleGNlcHRpb25zIGluIHRoZSBjYXNlIG9mXG4gICAgIG92ZXJmbG93cy4gVGhpcyBpcyB0byBwcmVzZXJ2ZSB0aGUgc2VtYW50aWNzIG9mIGludCB0eXBlIG9uIDY0IGJpdCBhcmNoaXRlY3R1cmUuICopXG4gIGxldCBmMiBmIGEgYiA9XG4gICAgU3RkbGliLkludDY0Lm11bCAoZiAoU3RkbGliLkludDY0LnNoaWZ0X3JpZ2h0IGEgMSkgKFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodCBiIDEpKSAyTFxuICA7O1xuXG4gIGxldCBtYXNrID0gMHhmZmZmX2ZmZmZfZmZmZl9mZmZlTFxuICBsZXQgbSB4ID0gU3RkbGliLkludDY0LmxvZ2FuZCB4IG1hc2tcbiAgbGV0IGludmFyaWFudCB0ID0gYXNzZXJ0IChtIHQgPSB0KVxuICBsZXQgYWRkIHggeSA9IFN0ZGxpYi5JbnQ2NC5hZGQgeCB5XG4gIGxldCBzdWIgeCB5ID0gU3RkbGliLkludDY0LnN1YiB4IHlcbiAgbGV0IG5lZyB4ID0gU3RkbGliLkludDY0Lm5lZyB4XG4gIGxldCBhYnMgeCA9IFN0ZGxpYi5JbnQ2NC5hYnMgeFxuICBsZXQgb25lID0gd3JhcF9leG4gMUxcbiAgbGV0IHN1Y2MgYSA9IGFkZCBhIG9uZVxuICBsZXQgcHJlZCBhID0gc3ViIGEgb25lXG4gIGxldCBtaW5fdmFsdWUgPSBtIFN0ZGxpYi5JbnQ2NC5taW5faW50XG4gIGxldCBtYXhfdmFsdWUgPSBtIFN0ZGxpYi5JbnQ2NC5tYXhfaW50XG4gIGxldCBiaXRfbm90IHggPSBtIChTdGRsaWIuSW50NjQubG9nbm90IHgpXG4gIGxldCBiaXRfYW5kID0gU3RkbGliLkludDY0LmxvZ2FuZFxuICBsZXQgYml0X3hvciA9IFN0ZGxpYi5JbnQ2NC5sb2d4b3JcbiAgbGV0IGJpdF9vciA9IFN0ZGxpYi5JbnQ2NC5sb2dvclxuICBsZXQgc2hpZnRfbGVmdCB4IGkgPSBTdGRsaWIuSW50NjQuc2hpZnRfbGVmdCB4IGlcbiAgbGV0IHNoaWZ0X3JpZ2h0IHggaSA9IG0gKFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodCB4IGkpXG4gIGxldCBzaGlmdF9yaWdodF9sb2dpY2FsIHggaSA9IG0gKFN0ZGxpYi5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIHggaSlcbiAgbGV0IHBvdyA9IGYyIEludF9tYXRoLlByaXZhdGUuaW50NjNfcG93X29uX2ludDY0XG4gIGxldCBtdWwgYSBiID0gU3RkbGliLkludDY0Lm11bCBhIChTdGRsaWIuSW50NjQuc2hpZnRfcmlnaHQgYiAxKVxuICBsZXQgZGl2IGEgYiA9IHdyYXBfbW9kdWxvIChTdGRsaWIuSW50NjQuZGl2IGEgYilcbiAgbGV0IHJlbSBhIGIgPSBTdGRsaWIuSW50NjQucmVtIGEgYlxuICBsZXQgcG9wY291bnQgeCA9IFBvcGNvdW50LmludDY0X3BvcGNvdW50IHhcbiAgbGV0IHRvX2ludDY0IHQgPSB1bndyYXAgdFxuICBsZXQgb2ZfaW50NjQgdCA9IHdyYXAgdFxuICBsZXQgb2ZfaW50NjRfZXhuIHQgPSB3cmFwX2V4biB0XG4gIGxldCBvZl9pbnQ2NF90cnVuYyB0ID0gd3JhcF9tb2R1bG8gdFxuICBsZXQgdF9vZl9zZXhwIHggPSB3cmFwX2V4biAoaW50NjRfb2Zfc2V4cCB4KVxuICBsZXQgc2V4cF9vZl90IHggPSBzZXhwX29mX2ludDY0ICh1bndyYXAgeClcbiAgbGV0IGNvbXBhcmUgKHggOiB0KSB5ID0gY29tcGFyZSB4IHlcbiAgbGV0IGNvbXBhcmVfX2xvY2FsICh4IDogdCkgeSA9IGNvbXBhcmVfX2xvY2FsIHggeVxuICBsZXQgZXF1YWxfX2xvY2FsICh4IDogdCkgeSA9IGVxdWFsX19sb2NhbCB4IHlcbiAgbGV0IGlzX3BvdzIgeCA9IEludDY0LmlzX3BvdzIgKHVud3JhcCB4KVxuXG4gIGxldCBjbHogeCA9XG4gICAgKCogV2UgcnVuIEludDY0LmNseiBkaXJlY3RseSBvbiB0aGUgd3JhcHBlZCBpbnQ2MyB2YWx1ZS4gVGhpcyBpcyBjb3JyZWN0IGJlY2F1c2UgdGhlXG4gICAgICAgYml0cyBvZiB0aGUgaW50NjNfZW11bCBhcmUgbGVmdC1hbGlnbmVkIGluIHRoZSBJbnQ2NC4gKilcbiAgICBJbnQ2NC5jbHogeFxuICA7O1xuXG4gIGxldCBjdHogeCA9IEludDY0LmN0eiAodW53cmFwIHgpXG4gIGxldCBmbG9vcl9wb3cyIHggPSBJbnQ2NC5mbG9vcl9wb3cyICh1bndyYXAgeCkgfD4gd3JhcF9leG5cbiAgbGV0IGNlaWxfcG93MiB4ID0gSW50NjQuZmxvb3JfcG93MiAodW53cmFwIHgpIHw+IHdyYXBfZXhuXG4gIGxldCBmbG9vcl9sb2cyIHggPSBJbnQ2NC5mbG9vcl9sb2cyICh1bndyYXAgeClcbiAgbGV0IGNlaWxfbG9nMiB4ID0gSW50NjQuY2VpbF9sb2cyICh1bndyYXAgeClcbmVuZFxuXG5vcGVuIFdcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVy50IFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGdsb2JhbGl6ZSA6IHQgLT4gdCkgPSAoVy5nbG9iYWxpemUgOiB0IC0+IHQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIFcuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBXLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKFcudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoVy5zZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gVy50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBXLmNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yID0gVy5jb21wYXJhdG9yXG4gIGxldCBjb21wYXJlID0gVy5jb21wYXJlXG4gIGxldCBjb21wYXJlX19sb2NhbCA9IFcuY29tcGFyZV9fbG9jYWxcbiAgbGV0IGVxdWFsX19sb2NhbCA9IFcuZXF1YWxfX2xvY2FsXG4gIGxldCBpbnZhcmlhbnQgPSBXLmludmFyaWFudFxuXG4gICgqIFdlIGRvbid0IGV4cGVjdCBbaGFzaF0gdG8gZm9sbG93IHRoZSBiZWhhdmlvciBvZiBpbnQgaW4gNjRiaXQgYXJjaGl0ZWN0dXJlICopXG4gIGxldCBfID0gaGFzaFxuICBsZXQgaGFzaCAoeCA6IHQpID0gU3RkbGliLkhhc2h0YmwuaGFzaCB4XG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGludmFsaWRfc3RyIHggPSBQcmludGYuZmFpbHdpdGhmIFwiSW50NjMub2Zfc3RyaW5nOiBpbnZhbGlkIGlucHV0ICVTXCIgeCAoKVxuXG4gICgqXG4gICAgIFwic2lnblwiIHJlZmVycyB0byB3aGV0aGVyIHRoZSBudW1iZXIgc3RhcnRzIHdpdGggYSAnLSdcbiAgICAgXCJzaWduZWRuZXNzID0gZmFsc2VcIiBtZWFucyB0aGUgcmVzdCBvZiB0aGUgbnVtYmVyIGlzIHBhcnNlZCBhcyB1bnNpZ25lZCBhbmQgdGhlbiBjYXN0XG4gICAgIHRvIHNpZ25lZCB3aXRoIHdyYXAtYXJvdW5kIG1vZHVsbyAyXmlcbiAgICAgXCJzaWduZWRuZXNzID0gdHJ1ZVwiIG1lYW5zIG5vIHN1Y2ggY3JhemluZXNzIGhhcHBlbnNcblxuICAgICBUaGUgdGVybWlub2xvZ3kgYW5kIHRoZSBsb2dpYyBpcyBkdWUgdG8gdGhlIGNvZGUgaW4gYnl0ZXJ1bi9pbnRzLmMgaW4gb2NhbWwgNC4wM1xuICAgICAoW3BhcnNlX3NpZ25fYW5kX2Jhc2VdIGZ1bmN0aW9uKS5cblxuICAgICBTaWduZWRuZXNzIGVxdWFscyB0cnVlIGZvciBwbGFpbiBkZWNpbWFsIG51bWJlciAoZS5nLiAxMjM1LCAtNjc4OSlcblxuICAgICBTaWduZWRuZXNzIGVxdWFscyBmYWxzZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAtIFsweGZmZmZdLCBbLTB4ZmZmZl0gKGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uKVxuICAgICAtIFswYjAxMDFdLCBbLTBiMDEwMV0gKGJpbmFyeSByZXByZXNlbnRhdGlvbilcbiAgICAgLSBbMG8xMjM3XSwgWy0wbzEyMzddIChvY3RhbCByZXByZXNlbnRhdGlvbilcbiAgICAgLSBbMHU5ODEyXSwgWy0wdTk4MTJdICh1bnNpZ25lZCBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIC0gYXZhaWxhYmxlIGZyb20gT0NhbWwgNC4wMykgKilcbiAgbGV0IHNpZ25fYW5kX3NpZ25lZG5lc3MgeCA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggeCBpblxuICAgIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcG9zLCBzaWduID1cbiAgICAgIGlmIDAgPCBsZW5cbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCB4LlswXSB3aXRoXG4gICAgICAgIHwgJy0nIC0+IDEsIGBOZWdcbiAgICAgICAgfCAnKycgLT4gMSwgYFBvc1xuICAgICAgICB8IF8gLT4gMCwgYFBvcylcbiAgICAgIGVsc2UgMCwgYFBvc1xuICAgIGluXG4gICAgaWYgcG9zICsgMiA8IGxlblxuICAgIHRoZW4gKFxuICAgICAgbGV0IGMxID0geC5bcG9zXSBpblxuICAgICAgbGV0IGMyID0geC5bcG9zICsgMV0gaW5cbiAgICAgIG1hdGNoIGMxLCBjMiB3aXRoXG4gICAgICB8ICcwJywgJzAnIC4uICc5JyAtPiBzaWduLCB0cnVlXG4gICAgICB8ICcwJywgXyAtPiBzaWduLCBmYWxzZVxuICAgICAgfCBfIC0+IHNpZ24sIHRydWUpXG4gICAgZWxzZSBzaWduLCB0cnVlXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyB4ID0gU3RkbGliLkludDY0LnRvX3N0cmluZyAodW53cmFwIHgpXG5cbiAgbGV0IG9mX3N0cmluZ19yYXcgc3RyID1cbiAgICBsZXQgc2lnbiwgc2lnbmVkbmVzcyA9IHNpZ25fYW5kX3NpZ25lZG5lc3Mgc3RyIGluXG4gICAgaWYgc2lnbmVkbmVzc1xuICAgIHRoZW4gb2ZfaW50NjRfZXhuIChTdGRsaWIuSW50NjQub2Zfc3RyaW5nIHN0cilcbiAgICBlbHNlIChcbiAgICAgIGxldCBwb3Nfc3RyID1cbiAgICAgICAgbWF0Y2ggc2lnbiB3aXRoXG4gICAgICAgIHwgYE5lZyAtPiBTdHJpbmcuc3ViIHN0ciB+cG9zOjEgfmxlbjooU3RyaW5nLmxlbmd0aCBzdHIgLSAxKVxuICAgICAgICB8IGBQb3MgLT4gc3RyXG4gICAgICBpblxuICAgICAgbGV0IGludDY0ID0gU3RkbGliLkludDY0Lm9mX3N0cmluZyBwb3Nfc3RyIGluXG4gICAgICAoKiB1bnNpZ25lZCA2My1iaXQgaW50IG11c3QgcGFyc2UgYXMgYSBwb3NpdGl2ZSBzaWduZWQgNjQtYml0IGludCAqKVxuICAgICAgaWYgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIGludDY0IDBMIHRoZW4gaW52YWxpZF9zdHIgc3RyO1xuICAgICAgbGV0IGludDYzID0gd3JhcF9tb2R1bG8gaW50NjQgaW5cbiAgICAgIG1hdGNoIHNpZ24gd2l0aFxuICAgICAgfCBgTmVnIC0+IG5lZyBpbnQ2M1xuICAgICAgfCBgUG9zIC0+IGludDYzKVxuICA7O1xuXG4gIGxldCBvZl9zdHJpbmcgc3RyID1cbiAgICB0cnkgb2Zfc3RyaW5nX3JhdyBzdHIgd2l0aFxuICAgIHwgXyAtPiBpbnZhbGlkX3N0ciBzdHJcbiAgOztcblxuICBsZXQgb2Zfc3RyaW5nX29wdCBzdHIgPVxuICAgIG1hdGNoIG9mX3N0cmluZ19yYXcgc3RyIHdpdGhcbiAgICB8IHQgLT4gU29tZSB0XG4gICAgfCBleGNlcHRpb24gXyAtPiBOb25lXG4gIDs7XG5cbiAgbGV0IGJzd2FwMTYgdCA9IHdyYXBfbW9kdWxvIChJbnQ2NC5ic3dhcDE2ICh1bndyYXAgdCkpXG4gIGxldCBic3dhcDMyIHQgPSB3cmFwX21vZHVsbyAoSW50NjQuYnN3YXAzMiAodW53cmFwIHQpKVxuICBsZXQgYnN3YXA0OCB0ID0gd3JhcF9tb2R1bG8gKEludDY0LmJzd2FwNDggKHVud3JhcCB0KSlcbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IG51bV9iaXRzID0gNjNcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5sZXQgc2hpZnRfcmlnaHQgPSBzaGlmdF9yaWdodFxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0XG5sZXQgYml0X25vdCA9IGJpdF9ub3RcbmxldCBiaXRfeG9yID0gYml0X3hvclxubGV0IGJpdF9vciA9IGJpdF9vclxubGV0IGJpdF9hbmQgPSBiaXRfYW5kXG5sZXQgcG9wY291bnQgPSBwb3Bjb3VudFxubGV0IGFicyA9IGFic1xubGV0IHByZWQgPSBwcmVkXG5sZXQgc3VjYyA9IHN1Y2NcbmxldCBwb3cgPSBwb3dcbmxldCByZW0gPSByZW1cbmxldCBuZWcgPSBuZWdcbmxldCBtYXhfdmFsdWUgPSBtYXhfdmFsdWVcbmxldCBtaW5fdmFsdWUgPSBtaW5fdmFsdWVcbmxldCBtaW51c19vbmUgPSB3cmFwX2V4biBTdGRsaWIuSW50NjQubWludXNfb25lXG5sZXQgb25lID0gd3JhcF9leG4gU3RkbGliLkludDY0Lm9uZVxubGV0IHplcm8gPSB3cmFwX2V4biBTdGRsaWIuSW50NjQuemVyb1xubGV0IGlzX3BvdzIgPSBpc19wb3cyXG5sZXQgZmxvb3JfcG93MiA9IGZsb29yX3BvdzJcbmxldCBjZWlsX3BvdzIgPSBjZWlsX3BvdzJcbmxldCBmbG9vcl9sb2cyID0gZmxvb3JfbG9nMlxubGV0IGNlaWxfbG9nMiA9IGNlaWxfbG9nMlxubGV0IGNseiA9IGNselxubGV0IGN0eiA9IGN0elxubGV0IHRvX2Zsb2F0IHggPSBTdGRsaWIuSW50NjQudG9fZmxvYXQgKHVud3JhcCB4KVxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCB4ID0gd3JhcF9tb2R1bG8gKFN0ZGxpYi5JbnQ2NC5vZl9mbG9hdCB4KVxuXG5sZXQgb2ZfZmxvYXQgdCA9XG4gIGxldCBvcGVuIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICBpZiB0ID49IGZsb2F0X2xvd2VyX2JvdW5kICYmIHQgPD0gZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiB3cmFwX21vZHVsbyAoU3RkbGliLkludDY0Lm9mX2Zsb2F0IHQpXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludDYzLm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggdClcbiAgICAgICgpXG47O1xuXG5sZXQgb2ZfaW50NjQgPSBvZl9pbnQ2NFxubGV0IG9mX2ludDY0X2V4biA9IG9mX2ludDY0X2V4blxubGV0IG9mX2ludDY0X3RydW5jID0gb2ZfaW50NjRfdHJ1bmNcbmxldCB0b19pbnQ2NCA9IHRvX2ludDY0XG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbjptaW5fIH5tYXg6bWF4XyA9IG1pbiB0IG1heF8gfD4gbWF4IG1pbl9cblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCAoIC8gKSA9IGRpdlxubGV0ICggKiApID0gbXVsXG5sZXQgKCAtICkgPSBzdWJcbmxldCAoICsgKSA9IGFkZFxubGV0ICggfi0gKSA9IG5lZ1xubGV0ICggKiogKSBiIGUgPSBwb3cgYiBlXG5sZXQgaW5jciByID0gciA6PSAhciArIG9uZVxubGV0IGRlY3IgciA9IHIgOj0gIXIgLSBvbmVcblxuKCogV2UgY2FuIHJldXNlIGNvbnZlcnNpb24gZnVuY3Rpb24gZnJvbS90byBpbnQ2NCBoZXJlLiAqKVxubGV0IG9mX2ludCB4ID0gd3JhcF9leG4gKENvbnYuaW50X3RvX2ludDY0IHgpXG5sZXQgb2ZfaW50X2V4biB4ID0gb2ZfaW50IHhcbmxldCB0b19pbnQgeCA9IENvbnYuaW50NjRfdG9faW50ICh1bndyYXAgeClcbmxldCB0b19pbnRfZXhuIHggPSBDb252LmludDY0X3RvX2ludF9leG4gKHVud3JhcCB4KVxubGV0IHRvX2ludF90cnVuYyB4ID0gQ29udi5pbnQ2NF90b19pbnRfdHJ1bmMgKHVud3JhcCB4KVxubGV0IG9mX2ludDMyIHggPSB3cmFwX2V4biAoQ29udi5pbnQzMl90b19pbnQ2NCB4KVxubGV0IG9mX2ludDMyX2V4biB4ID0gb2ZfaW50MzIgeFxubGV0IHRvX2ludDMyIHggPSBDb252LmludDY0X3RvX2ludDMyICh1bndyYXAgeClcbmxldCB0b19pbnQzMl9leG4geCA9IENvbnYuaW50NjRfdG9faW50MzJfZXhuICh1bndyYXAgeClcbmxldCB0b19pbnQzMl90cnVuYyB4ID0gQ29udi5pbnQ2NF90b19pbnQzMl90cnVuYyAodW53cmFwIHgpXG5sZXQgb2ZfbmF0aXZlaW50IHggPSBvZl9pbnQ2NCAoQ29udi5uYXRpdmVpbnRfdG9faW50NjQgeClcbmxldCBvZl9uYXRpdmVpbnRfZXhuIHggPSB3cmFwX2V4biAoQ29udi5uYXRpdmVpbnRfdG9faW50NjQgeClcbmxldCBvZl9uYXRpdmVpbnRfdHJ1bmMgeCA9IG9mX2ludDY0X3RydW5jIChDb252Lm5hdGl2ZWludF90b19pbnQ2NCB4KVxubGV0IHRvX25hdGl2ZWludCB4ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnQgKHVud3JhcCB4KVxubGV0IHRvX25hdGl2ZWludF9leG4geCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X2V4biAodW53cmFwIHgpXG5sZXQgdG9fbmF0aXZlaW50X3RydW5jIHggPSBDb252LmludDY0X3RvX25hdGl2ZWludF90cnVuYyAodW53cmFwIHgpXG5cbmluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9ucy5NYWtlIChUKVxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZV9oZXggKHN0cnVjdFxuICB0eXBlIHQgPSBULnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBoYXNoXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA9IChULmNvbXBhcmVfX2xvY2FsIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBULmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gVC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG5lZyA9ICggfi0gKVxuICBsZXQgKCA8ICkgPSAoIDwgKVxuXG4gIGxldCB0b19zdHJpbmcgaSA9XG4gICAgKCogdGhlIHVzZSBvZiBbdW53cmFwX3Vuc2lnbmVkXSBoZXJlIGlzIGltcG9ydGFudCBmb3IgdGhlIGNhc2Ugb2YgW21pbl92YWx1ZV0gKilcbiAgICBQcmludGYuc3ByaW50ZiBcIiVMeFwiICh1bndyYXBfdW5zaWduZWQgaSlcbiAgOztcblxuICBsZXQgb2Zfc3RyaW5nIHMgPSBvZl9zdHJpbmcgKFwiMHhcIiBeIHMpXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQ2My5IZXhcIlxuZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHRcblxuICBsZXQgdG9fc3RyaW5nIHggPSB0b19zdHJpbmcgeFxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50NjNcIlxuZW5kKVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgbGV0ICggKyApID0gKCArIClcbiAgbGV0ICggLSApID0gKCAtIClcbiAgbGV0ICggKiApID0gKCAqIClcbiAgbGV0ICggLyApID0gKCAvIClcbiAgbGV0ICggfi0gKSA9ICggfi0gKVxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSAoSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBpbmNsdWRlIFByZV9PXG5cbiAgICBsZXQgcmVtID0gcmVtXG4gICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICBlbmQpXG5cbiAgbGV0ICggbGFuZCApID0gYml0X2FuZFxuICBsZXQgKCBsb3IgKSA9IGJpdF9vclxuICBsZXQgKCBseG9yICkgPSBiaXRfeG9yXG4gIGxldCBsbm90ID0gYml0X25vdFxuICBsZXQgKCBsc2wgKSA9IHNoaWZ0X2xlZnRcbiAgbGV0ICggYXNyICkgPSBzaGlmdF9yaWdodFxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmVuZFxuXG5pbmNsdWRlIE9cblxuaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLk1ha2VfYmluYXJ5IChzdHJ1Y3RcbiAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBoYXNoXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA9IChULmNvbXBhcmVfX2xvY2FsIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgZXF1YWxfX2xvY2FsID0gKFQuZXF1YWxfX2xvY2FsIDogdCAtPiB0IC0+IGJvb2wpXG4gIGxldCBlcXVhbCA9IChmdW4gYSBiIC0+IGVxdWFsX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgVC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IFQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0ICggbGFuZCApID0gKCBsYW5kIClcbiAgbGV0ICggbHNyICkgPSAoIGxzciApXG4gIGxldCBjbHogPSBjbHpcbiAgbGV0IG51bV9iaXRzID0gbnVtX2JpdHNcbiAgbGV0IG9uZSA9IG9uZVxuICBsZXQgdG9faW50X2V4biA9IHRvX2ludF9leG5cbiAgbGV0IHplcm8gPSB6ZXJvXG5lbmQpXG5cbigqIFtJbnQ2M10gYW5kIFtJbnQ2My5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbm1vZHVsZSBSZXByID0gc3RydWN0XG4gIHR5cGUgZW11bGF0ZWQgPSB0XG5cbiAgdHlwZSAoJ3VuZGVybHlpbmdfdHlwZSwgJ2ludGVybWVkaWF0ZV90eXBlKSB0ID1cbiAgICB8IEludCA6IChpbnQsIGludCkgdFxuICAgIHwgSW50NjQgOiAoaW50NjQsIGVtdWxhdGVkKSB0XG5lbmRcblxubGV0IHJlcHIgPSBSZXByLkludDY0XG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgU3RkbGliLkludDMyXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGludDMyIFtAQGRlcml2aW5nX2lubGluZSBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGdsb2JhbGl6ZSA6IHQgLT4gdCkgPSAoZ2xvYmFsaXplX2ludDMyIDogdCAtPiB0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50MzJcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludDMyIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChpbnQzMl9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQzMiA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBpbnQzMl9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgKHggOiB0KSB5ID0gY29tcGFyZSB4IHlcbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nID0gb2Zfc3RyaW5nXG4gIGxldCBvZl9zdHJpbmdfb3B0ID0gb2Zfc3RyaW5nX29wdFxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmxldCBudW1fYml0cyA9IDMyXG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF9vZl9iaXRzID0gZmxvYXRfb2ZfYml0c1xubGV0IGJpdHNfb2ZfZmxvYXQgPSBiaXRzX29mX2Zsb2F0XG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gbG9nbm90XG5sZXQgYml0X3hvciA9IGxvZ3hvclxubGV0IGJpdF9vciA9IGxvZ29yXG5sZXQgYml0X2FuZCA9IGxvZ2FuZFxubGV0IG1pbl92YWx1ZSA9IG1pbl9pbnRcbmxldCBtYXhfdmFsdWUgPSBtYXhfaW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHJlbSA9IHJlbVxubGV0IG5lZyA9IG5lZ1xubGV0IG1pbnVzX29uZSA9IG1pbnVzX29uZVxubGV0IG9uZSA9IG9uZVxubGV0IHplcm8gPSB6ZXJvXG5sZXQgY29tcGFyZSA9IGNvbXBhcmVcbmxldCBjb21wYXJlX19sb2NhbCA9IFN0ZGxpYi5jb21wYXJlXG5sZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCA9IG9mX2Zsb2F0XG5cbmxldCBvZl9mbG9hdCBmID1cbiAgaWYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBmIGZsb2F0X2xvd2VyX2JvdW5kXG4gICAgICYmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgZiBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIG9mX2Zsb2F0IGZcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiSW50MzIub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCBmKVxuICAgICAgKClcbjs7XG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxubW9kdWxlIEluZml4X2NvbXBhcmUgPSBzdHJ1Y3RcbiAgb3BlbiBQb2x5XG5cbiAgbGV0ICggPj0gKSAoeCA6IHQpIHkgPSB4ID49IHlcbiAgbGV0ICggPD0gKSAoeCA6IHQpIHkgPSB4IDw9IHlcbiAgbGV0ICggPSApICh4IDogdCkgeSA9IHggPSB5XG4gIGxldCAoID4gKSAoeCA6IHQpIHkgPSB4ID4geVxuICBsZXQgKCA8ICkgKHggOiB0KSB5ID0geCA8IHlcbiAgbGV0ICggPD4gKSAoeCA6IHQpIHkgPSB4IDw+IHlcbmVuZFxuXG5tb2R1bGUgQ29tcGFyZSA9IHN0cnVjdFxuICBpbmNsdWRlIEluZml4X2NvbXBhcmVcblxuICBsZXQgY29tcGFyZSA9IGNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfX2xvY2FsID0gY29tcGFyZV9fbG9jYWxcbiAgbGV0IGFzY2VuZGluZyA9IGNvbXBhcmVcbiAgbGV0IGRlc2NlbmRpbmcgeCB5ID0gY29tcGFyZSB5IHhcbiAgbGV0IG1pbiB4IHkgPSBCb29sMC5zZWxlY3QgKHggPD0geSkgeCB5XG4gIGxldCBtYXggeCB5ID0gQm9vbDAuc2VsZWN0ICh4ID49IHkpIHggeVxuICBsZXQgZXF1YWwgKHggOiB0KSB5ID0geCA9IHlcbiAgbGV0IGVxdWFsX19sb2NhbCAoeCA6IHQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW46bWluXyB+bWF4Om1heF8gPSBtaW4gdCBtYXhfIHw+IG1heCBtaW5fXG5cbiAgbGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gICAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbiAgOztcblxuICBsZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICAgIGlmIG1pbiA+IG1heFxuICAgIHRoZW5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBDb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgKCAvICkgPSBkaXZcbmxldCAoICogKSA9IG11bFxubGV0ICggLSApID0gc3ViXG5sZXQgKCArICkgPSBhZGRcbmxldCAoIH4tICkgPSBuZWdcbmxldCBpbmNyIHIgPSByIDo9ICFyICsgb25lXG5sZXQgZGVjciByID0gciA6PSAhciAtIG9uZVxubGV0IG9mX2ludDMyIHQgPSB0XG5sZXQgb2ZfaW50MzJfZXhuID0gb2ZfaW50MzJcbmxldCB0b19pbnQzMiB0ID0gdFxubGV0IHRvX2ludDMyX2V4biA9IHRvX2ludDMyXG5sZXQgcG9wY291bnQgPSBQb3Bjb3VudC5pbnQzMl9wb3Bjb3VudFxuXG5tb2R1bGUgQ29udiA9IEludF9jb252ZXJzaW9uc1xuXG5sZXQgb2ZfaW50ID0gQ29udi5pbnRfdG9faW50MzJcbmxldCBvZl9pbnRfZXhuID0gQ29udi5pbnRfdG9faW50MzJfZXhuXG5sZXQgb2ZfaW50X3RydW5jID0gQ29udi5pbnRfdG9faW50MzJfdHJ1bmNcbmxldCB0b19pbnQgPSBDb252LmludDMyX3RvX2ludFxubGV0IHRvX2ludF9leG4gPSBDb252LmludDMyX3RvX2ludF9leG5cbmxldCB0b19pbnRfdHJ1bmMgPSBDb252LmludDMyX3RvX2ludF90cnVuY1xubGV0IG9mX2ludDY0ID0gQ29udi5pbnQ2NF90b19pbnQzMlxubGV0IG9mX2ludDY0X2V4biA9IENvbnYuaW50NjRfdG9faW50MzJfZXhuXG5sZXQgb2ZfaW50NjRfdHJ1bmMgPSBDb252LmludDY0X3RvX2ludDMyX3RydW5jXG5sZXQgdG9faW50NjQgPSBDb252LmludDMyX3RvX2ludDY0XG5sZXQgb2ZfbmF0aXZlaW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJcbmxldCBvZl9uYXRpdmVpbnRfZXhuID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJfZXhuXG5sZXQgb2ZfbmF0aXZlaW50X3RydW5jID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJfdHJ1bmNcbmxldCB0b19uYXRpdmVpbnQgPSBDb252LmludDMyX3RvX25hdGl2ZWludFxubGV0IHRvX25hdGl2ZWludF9leG4gPSB0b19uYXRpdmVpbnRcbmxldCBwb3cgYiBlID0gb2ZfaW50X2V4biAoSW50X21hdGguUHJpdmF0ZS5pbnRfcG93ICh0b19pbnRfZXhuIGIpICh0b19pbnRfZXhuIGUpKVxubGV0ICggKiogKSBiIGUgPSBwb3cgYiBlXG5cbmV4dGVybmFsIGJzd2FwMzIgOiAodFtAbG9jYWxfb3B0XSkgLT4gKHRbQGxvY2FsX29wdF0pID0gXCIlYnN3YXBfaW50MzJcIlxuXG5sZXQgYnN3YXAxNiB4ID0gU3RkbGliLkludDMyLnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJzd2FwMzIgeCkgMTZcblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG4gIG9wZW4gSW50MzJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgbGV0IG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKSA9XG4gICAgUHJpbnRmLmludmFsaWRfYXJnZiBcImFyZ3VtZW50IG11c3QgYmUgc3RyaWN0bHkgcG9zaXRpdmVcIiAoKVxuICA7O1xuXG4gIGxldCAoIGxvciApID0gU3RkbGliLkludDMyLmxvZ29yXG4gIGxldCAoIGxzciApID0gU3RkbGliLkludDMyLnNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbiAgbGV0ICggbGFuZCApID0gU3RkbGliLkludDMyLmxvZ2FuZFxuXG4gICgqKiBcImNlaWxpbmcgcG93ZXIgb2YgMlwiIC0gTGVhc3QgcG93ZXIgb2YgMiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGNlaWxfcG93MiB4ID1cbiAgICBpZiB4IDw9IFN0ZGxpYi5JbnQzMi56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0gU3RkbGliLkludDMyLnByZWQgeCBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgU3RkbGliLkludDMyLnN1Y2MgeFxuICA7O1xuXG4gICgqKiBcImZsb29yIHBvd2VyIG9mIDJcIiAtIExhcmdlc3QgcG93ZXIgb2YgMiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGZsb29yX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBTdGRsaWIuSW50MzIuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIFN0ZGxpYi5JbnQzMi5zdWIgeCAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IFN0ZGxpYi5JbnQzMi56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIHggbGFuZCBTdGRsaWIuSW50MzIucHJlZCB4ID0gU3RkbGliLkludDMyLnplcm9cbiAgOztcblxuICAoKiBDIHN0dWJzIGZvciBpbnQzMiBjbHogYW5kIGN0eiB0byB1c2UgdGhlIENMWi9CU1IvQ1RaL0JTRiBpbnN0cnVjdGlvbiB3aGVyZSBwb3NzaWJsZSAqKVxuICBleHRlcm5hbCBjbHpcbiAgICA6ICAoaW50MzJbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHpcIiBcIkJhc2VfaW50X21hdGhfaW50MzJfY2x6X3VuYm94ZWRcIlxuICAgIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKGludDMyW0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50MzJfY3R6XCIgXCJCYXNlX2ludF9tYXRoX2ludDMyX2N0el91bmJveGVkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgaSA8PSBTdGRsaWIuSW50MzIuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZSBcIltJbnQzMi5mbG9vcl9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQzMiBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgY2VpbF9sb2cyIGkgPVxuICAgIGlmIGkgPD0gU3RkbGliLkludDMyLnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50MzIuY2VpbF9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQzMiBpIF0pO1xuICAgICgqIFRoZSBbaSA9IDFdIGNoZWNrIGlzIG5lZWRlZCBiZWNhdXNlIGNseigwKSBpcyB1bmRlZmluZWQgKilcbiAgICBpZiBTdGRsaWIuSW50MzIuZXF1YWwgaSBTdGRsaWIuSW50MzIub25lXG4gICAgdGhlbiAwXG4gICAgZWxzZSBudW1fYml0cyAtIGNseiAoU3RkbGliLkludDMyLnByZWQgaSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFBvdzJcbmluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9ucy5NYWtlIChUKVxuXG5pbmNsdWRlIEludF9zdHJpbmdfY29udmVyc2lvbnMuTWFrZV9oZXggKHN0cnVjdFxuICB0eXBlIHQgPSBpbnQzMiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSB+bG9jYWxpemUsIGhhc2hdXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKGNvbXBhcmVfaW50MzJfX2xvY2FsIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50MzJcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludDMyIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG5lZyA9ICggfi0gKVxuICBsZXQgKCA8ICkgPSAoIDwgKVxuICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiVseFwiIGlcbiAgbGV0IG9mX3N0cmluZyBzID0gU3RkbGliLlNjYW5mLnNzY2FuZiBzIFwiJWx4XCIgRm4uaWRcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDMyLkhleFwiXG5lbmQpXG5cbmluY2x1ZGUgSW50X3N0cmluZ19jb252ZXJzaW9ucy5NYWtlX2JpbmFyeSAoc3RydWN0XG4gIHR5cGUgdCA9IGludDMyIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBoYXNoXVxuXG4gIGxldCBjb21wYXJlX19sb2NhbCA9IChjb21wYXJlX2ludDMyX19sb2NhbCA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlID0gKGZ1biBhIGIgLT4gY29tcGFyZV9fbG9jYWwgYSBiIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGVxdWFsX19sb2NhbCA9IChlcXVhbF9pbnQzMl9fbG9jYWwgOiB0IC0+IHQgLT4gYm9vbClcbiAgbGV0IGVxdWFsID0gKGZ1biBhIGIgLT4gZXF1YWxfX2xvY2FsIGEgYiA6IHQgLT4gdCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50MzJcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludDMyIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgKCBsYW5kICkgPSAoIGxhbmQgKVxuICBsZXQgKCBsc3IgKSA9ICggbHNyIClcbiAgbGV0IGNseiA9IGNselxuICBsZXQgbnVtX2JpdHMgPSBudW1fYml0c1xuICBsZXQgb25lID0gb25lXG4gIGxldCB0b19pbnRfZXhuID0gdG9faW50X2V4blxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50MzJcIlxuZW5kKVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgbGV0ICggKyApID0gKCArIClcbiAgbGV0ICggLSApID0gKCAtIClcbiAgbGV0ICggKiApID0gKCAqIClcbiAgbGV0ICggLyApID0gKCAvIClcbiAgbGV0ICggfi0gKSA9ICggfi0gKVxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSAoQ29tcGFyZSA6IENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHQpXG5cbiAgbGV0IGFicyA9IGFic1xuICBsZXQgbmVnID0gbmVnXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgaW5jbHVkZSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgbGV0IHJlbSA9IHJlbVxuICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgZW5kKVxuXG4gIGxldCAoIGxhbmQgKSA9IGJpdF9hbmRcbiAgbGV0ICggbG9yICkgPSBiaXRfb3JcbiAgbGV0ICggbHhvciApID0gYml0X3hvclxuICBsZXQgbG5vdCA9IGJpdF9ub3RcbiAgbGV0ICggbHNsICkgPSBzaGlmdF9sZWZ0XG4gIGxldCAoIGFzciApID0gc2hpZnRfcmlnaHRcbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnQzMl0gYW5kIFtJbnQzMi5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG4iLCJvcGVuISBJbXBvcnRcblxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbm1vZHVsZSBSZXByID0gSW50NjNfZW11bC5SZXByXG5pbmNsdWRlIFN5czAuTWFrZV9pbW1lZGlhdGU2NCAoSW50KSAoSW50NjNfZW11bClcblxubW9kdWxlIEJhY2tlbmQgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgaW5jbHVkZSBJbnRfaW50Zi5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICAgIHZhbCB0b19pbnQgOiB0IC0+IGludCBvcHRpb25cbiAgICB2YWwgdG9faW50X3RydW5jIDogdCAtPiBpbnRcbiAgICB2YWwgb2ZfaW50MzIgOiBpbnQzMiAtPiB0XG4gICAgdmFsIHRvX2ludDMyIDogdCAtPiBJbnQzMi50IG9wdGlvblxuICAgIHZhbCB0b19pbnQzMl90cnVuYyA6IHQgLT4gSW50MzIudFxuICAgIHZhbCBvZl9pbnQ2NCA6IEludDY0LnQgLT4gdCBvcHRpb25cbiAgICB2YWwgb2ZfaW50NjRfdHJ1bmMgOiBJbnQ2NC50IC0+IHRcbiAgICB2YWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IHQgb3B0aW9uXG4gICAgdmFsIHRvX25hdGl2ZWludCA6IHQgLT4gbmF0aXZlaW50IG9wdGlvblxuICAgIHZhbCBvZl9uYXRpdmVpbnRfdHJ1bmMgOiBuYXRpdmVpbnQgLT4gdFxuICAgIHZhbCB0b19uYXRpdmVpbnRfdHJ1bmMgOiB0IC0+IG5hdGl2ZWludFxuICAgIHZhbCBvZl9mbG9hdF91bmNoZWNrZWQgOiBmbG9hdCAtPiB0XG4gICAgdmFsIHJlcHIgOiAodCwgdCkgSW50NjNfZW11bC5SZXByLnRcbiAgICB2YWwgYnN3YXAxNiA6IHQgLT4gdFxuICAgIHZhbCBic3dhcDMyIDogdCAtPiB0XG4gICAgdmFsIGJzd2FwNDggOiB0IC0+IHRcbiAgZW5kXG4gIHdpdGggdHlwZSB0IDo9IHRcblxuICBtb2R1bGUgTmF0aXZlID0gc3RydWN0XG4gICAgaW5jbHVkZSBJbnRcblxuICAgIGxldCB0b19pbnQgeCA9IFNvbWUgeFxuICAgIGxldCB0b19pbnRfdHJ1bmMgeCA9IHhcblxuICAgICgqIFtvZl9pbnQzMl9leG5dIGlzIGEgc2FmZSBvcGVyYXRpb24gb24gcGxhdGZvcm1zIHdpdGggNjQtYml0IHdvcmQgc2l6ZXMuICopXG4gICAgbGV0IG9mX2ludDMyID0gb2ZfaW50MzJfZXhuXG4gICAgbGV0IHRvX25hdGl2ZWludF90cnVuYyB4ID0gdG9fbmF0aXZlaW50IHhcbiAgICBsZXQgdG9fbmF0aXZlaW50IHggPSBTb21lICh0b19uYXRpdmVpbnQgeClcbiAgICBsZXQgcmVwciA9IEludDYzX2VtdWwuUmVwci5JbnRcbiAgICBsZXQgYnN3YXAzMiB0ID0gSW50NjQudG9faW50X3RydW5jIChJbnQ2NC5ic3dhcDMyIChJbnQ2NC5vZl9pbnQgdCkpXG4gICAgbGV0IGJzd2FwNDggdCA9IEludDY0LnRvX2ludF90cnVuYyAoSW50NjQuYnN3YXA0OCAoSW50NjQub2ZfaW50IHQpKVxuICBlbmRcblxuICBsZXQgaW1wbCA6IChtb2R1bGUgUykgPVxuICAgIG1hdGNoIHJlcHIgd2l0aFxuICAgIHwgSW1tZWRpYXRlIC0+IChtb2R1bGUgTmF0aXZlIDogUylcbiAgICB8IE5vbl9pbW1lZGlhdGUgLT4gKG1vZHVsZSBJbnQ2M19lbXVsIDogUylcbiAgOztcbmVuZFxuXG5pbmNsdWRlICh2YWwgQmFja2VuZC5pbXBsIDogQmFja2VuZC5TKVxuXG5tb2R1bGUgT3ZlcmZsb3dfZXhuID0gc3RydWN0XG4gIGxldCAoICsgKSB0IHUgPVxuICAgIGxldCBzdW0gPSB0ICsgdSBpblxuICAgIGlmIGJpdF9vciAoYml0X3hvciB0IHUpIChiaXRfeG9yIHQgKGJpdF9ub3Qgc3VtKSkgPCB6ZXJvXG4gICAgdGhlbiBzdW1cbiAgICBlbHNlXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCIoICsgKSBvdmVyZmxvd1wiXG4gICAgICAgICAgIFsgXCJ0XCIsIHNleHBfb2ZfdCB0OyBcInVcIiwgc2V4cF9vZl90IHU7IFwic3VtXCIsIHNleHBfb2ZfdCBzdW0gXSlcbiAgOztcblxuICBsZXQgKCAtICkgdCB1ID1cbiAgICBsZXQgZGlmZiA9IHQgLSB1IGluXG4gICAgbGV0IHBvc19kaWZmID0gdCA+IHUgaW5cbiAgICBpZiB0IDw+IHUgJiYgQm9vbC4oIDw+ICkgcG9zX2RpZmYgKGlzX3Bvc2l0aXZlIGRpZmYpXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiKCAtICkgb3ZlcmZsb3dcIlxuICAgICAgICAgICBbIFwidFwiLCBzZXhwX29mX3QgdDsgXCJ1XCIsIHNleHBfb2ZfdCB1OyBcImRpZmZcIiwgc2V4cF9vZl90IGRpZmYgXSlcbiAgICBlbHNlIGRpZmZcbiAgOztcblxuICBsZXQgbmVnYXRpdmVfb25lID0gb2ZfaW50ICgtMSlcbiAgbGV0IGRpdl93b3VsZF9vdmVyZmxvdyB0IHUgPSB0ID0gbWluX3ZhbHVlICYmIHUgPSBuZWdhdGl2ZV9vbmVcblxuICBsZXQgKCAqICkgdCB1ID1cbiAgICBsZXQgcHJvZHVjdCA9IHQgKiB1IGluXG4gICAgaWYgdSA8PiB6ZXJvICYmIChkaXZfd291bGRfb3ZlcmZsb3cgcHJvZHVjdCB1IHx8IHByb2R1Y3QgLyB1IDw+IHQpXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiKCAqICkgb3ZlcmZsb3dcIlxuICAgICAgICAgICBbIFwidFwiLCBzZXhwX29mX3QgdDsgXCJ1XCIsIHNleHBfb2ZfdCB1OyBcInByb2R1Y3RcIiwgc2V4cF9vZl90IHByb2R1Y3QgXSlcbiAgICBlbHNlIHByb2R1Y3RcbiAgOztcblxuICBsZXQgKCAvICkgdCB1ID1cbiAgICBpZiBkaXZfd291bGRfb3ZlcmZsb3cgdCB1XG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiKCAvICkgb3ZlcmZsb3dcIlxuICAgICAgICAgICBbIFwidFwiLCBzZXhwX29mX3QgdDsgXCJ1XCIsIHNleHBfb2ZfdCB1OyBcInByb2R1Y3RcIiwgc2V4cF9vZl90ICh0IC8gdSkgXSlcbiAgICBlbHNlIHQgLyB1XG4gIDs7XG5cbiAgbGV0IGFicyB0ID0gaWYgdCA9IG1pbl92YWx1ZSB0aGVuIGZhaWx3aXRoIFwiYWJzIG92ZXJmbG93XCIgZWxzZSBhYnMgdFxuICBsZXQgbmVnIHQgPSBpZiB0ID0gbWluX3ZhbHVlIHRoZW4gZmFpbHdpdGggXCJuZWcgb3ZlcmZsb3dcIiBlbHNlIG5lZyB0XG5lbmRcblxubGV0ICgpID0gYXNzZXJ0IChJbnQuKCA9ICkgbnVtX2JpdHMgNjMpXG5cbmxldCByYW5kb21fb2ZfaW50ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgYm91bmQgPVxuICBvZl9pbnQgKFJhbmRvbS5TdGF0ZS5pbnQgc3RhdGUgKHRvX2ludF9leG4gYm91bmQpKVxuOztcblxubGV0IHJhbmRvbV9vZl9pbnQ2NCA/KHN0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGJvdW5kID1cbiAgb2ZfaW50NjRfZXhuIChSYW5kb20uU3RhdGUuaW50NjQgc3RhdGUgKHRvX2ludDY0IGJvdW5kKSlcbjs7XG5cbmxldCByYW5kb20gPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gcmFuZG9tX29mX2ludFxuICB8IFczMiAtPiByYW5kb21fb2ZfaW50NjRcbjs7XG5cbmxldCByYW5kb21faW5jbF9vZl9pbnQgPyhzdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsbyBoaSA9XG4gIG9mX2ludCAoUmFuZG9tLlN0YXRlLmludF9pbmNsIHN0YXRlICh0b19pbnRfZXhuIGxvKSAodG9faW50X2V4biBoaSkpXG47O1xuXG5sZXQgcmFuZG9tX2luY2xfb2ZfaW50NjQgPyhzdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsbyBoaSA9XG4gIG9mX2ludDY0X2V4biAoUmFuZG9tLlN0YXRlLmludDY0X2luY2wgc3RhdGUgKHRvX2ludDY0IGxvKSAodG9faW50NjQgaGkpKVxuOztcblxubGV0IHJhbmRvbV9pbmNsID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IHJhbmRvbV9pbmNsX29mX2ludFxuICB8IFczMiAtPiByYW5kb21faW5jbF9vZl9pbnQ2NFxuOztcblxubGV0IGZsb29yX2xvZzIgdCA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiB0IHw+IHRvX2ludF9leG4gfD4gSW50LmZsb29yX2xvZzJcbiAgfCBXMzIgLT5cbiAgICBpZiB0IDw9IHplcm9cbiAgICB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfdCB0IF0pO1xuICAgIGxldCBmbG9vcl9sb2cyID0gcmVmIChJbnQuKCAtICkgbnVtX2JpdHMgMikgaW5cbiAgICB3aGlsZSBlcXVhbCB6ZXJvIChiaXRfYW5kIHQgKHNoaWZ0X2xlZnQgb25lICFmbG9vcl9sb2cyKSkgZG9cbiAgICAgIGZsb29yX2xvZzIgOj0gSW50LiggLSApICFmbG9vcl9sb2cyIDFcbiAgICBkb25lO1xuICAgICFmbG9vcl9sb2cyXG47O1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgUmVwciA9IFJlcHJcblxuICBsZXQgcmVwciA9IHJlcHJcblxuICBtb2R1bGUgRW11bCA9IEludDYzX2VtdWxcbmVuZFxuIiwiKCoqIEludGVyZmFjZXMgZm9yIG11dGFibGUgZGljdGlvbmFyeSB0eXBlcywgc3VjaCBhcyBbSGFzaHRibC50XS5cblxuICAgIFdlIGRlZmluZSBzZXBhcmF0ZSBpbnRlcmZhY2VzIGZvciBbQWNjZXNzb3JzXSBhbmQgW0NyZWF0b3JzXSwgYWxvbmcgd2l0aCBbU10gY29tYmluaW5nXG4gICAgYm90aC4gVGhlc2UgaW50ZXJmYWNlcyBhcmUgd3JpdHRlbiBvbmNlIGluIHRoZWlyIG1vc3QgZ2VuZXJhbCBmb3JtLCB3aGljaCBpbnZvbHZlc1xuICAgIGV4dHJhIHR5cGUgZGVmaW5pdGlvbnMgYW5kIHR5cGUgcGFyYW1ldGVycyB0aGF0IG1vc3QgaW5zdGFuY2VzIGRvIG5vdCBuZWVkLlxuXG4gICAgV2UgdGhlbiBwcm92aWRlIGluc3RhbnRpYXRpb25zIG9mIHRoZXNlIGludGVyZmFjZXMgd2l0aCAxLCAyLCBhbmQgMyB0eXBlIHBhcmFtZXRlcnNcbiAgICBmb3IgW3RdLiBUaGVzZSBjb3ZlciBtb3JlIGNvbW1vbiB1c2FnZSBwYXR0ZXJucyBmb3IgdGhlIGludGVyZmFjZXMuICopXG5cbm9wZW4hIEltcG9ydFxuXG4oKiogVGhlc2UgZGVmaW5pdGlvbnMgYXJlIHJlLWV4cG9ydGVkIGJ5IFtEaWN0aW9uYXJ5X211dGFibGVdLiAqKVxubW9kdWxlIERlZmluaXRpb25zID0gc3RydWN0XG4gICgqKiBAY2Fub25pY2FsIEJhc2UuRGljdGlvbmFyeV9tdXRhYmxlLk1lcmdlX2ludG9fYWN0aW9uICopXG4gIG1vZHVsZSBNZXJnZV9pbnRvX2FjdGlvbiA9IHN0cnVjdFxuICAgIHR5cGUgJ2RhdGEgdCA9XG4gICAgICB8IFJlbW92ZVxuICAgICAgfCBTZXRfdG8gb2YgJ2RhdGFcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzID0gc2lnXG4gICAgKCoqIFRoZSB0eXBlIG9mIGtleXMuIFRoaXMgd2lsbCBiZSBbJ2tleV0gZm9yIHBvbHltb3JwaGljIGRpY3Rpb25hcmllcywgb3Igc29tZSBmaXhlZFxuICAgICAgICB0eXBlIGZvciBkaWN0aW9uYXJpZXMgd2l0aCBtb25vbW9ycGhpYyBrZXlzLiAqKVxuICAgIHR5cGUgJ2tleSBrZXlcblxuICAgICgqKiBEaWN0aW9uYXJpZXMuIFRoZWlyIGtleXMgaGF2ZSB0eXBlIFsna2V5IGtleV0uIEVhY2gga2V5J3MgYXNzb2NpYXRlZCB2YWx1ZSBoYXNcbiAgICAgICAgdHlwZSBbJ2RhdGFdLiBUaGUgZGljdGlvbmFyeSBtYXkgYmUgZGlzdGluZ3Vpc2hlZCBieSBhIFsncGhhbnRvbV0gdHlwZS4gKilcbiAgICB0eXBlICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcblxuICAgICgqKiBUaGUgdHlwZSBvZiBhY2Nlc3NvciBmdW5jdGlvbnMgWydmbl0gdGhhdCBvcGVyYXRlIG9uIFsoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XS5cbiAgICAgICAgTWF5IHRha2UgZXh0cmEgYXJndW1lbnRzIGJlZm9yZSBbJ2ZuXSwgc3VjaCBhcyBhIGNvbXBhcmlzb24gZnVuY3Rpb24uICopXG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yXG5cbiAgICAoKiogV2hldGhlciB0aGUgZGljdGlvbmFyeSBpcyBlbXB0eS4gKilcbiAgICB2YWwgaXNfZW1wdHkgOiAoXywgXywgJ3BoYW50b20pIHQgLT4gYm9vbFxuXG4gICAgKCoqIEhvdyBtYW55IGtleS92YWx1ZSBwYWlycyB0aGUgZGljdGlvbmFyeSBjb250YWlucy4gKilcbiAgICB2YWwgbGVuZ3RoIDogKF8sIF8sICdwaGFudG9tKSB0IC0+IGludFxuXG4gICAgKCoqIEFsbCBrZXkvdmFsdWUgcGFpcnMuICopXG4gICAgdmFsIHRvX2FsaXN0IDogKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiAoJ2tleSBrZXkgKiAnZGF0YSkgbGlzdFxuXG4gICAgKCoqIEFsbCBrZXlzIGluIHRoZSBkaWN0aW9uYXJ5LCBpbiB0aGUgc2FtZSBvcmRlciBhcyBbdG9fYWxpc3RdLiAqKVxuICAgIHZhbCBrZXlzIDogKCdrZXksIF8sICdwaGFudG9tKSB0IC0+ICdrZXkga2V5IGxpc3RcblxuICAgICgqKiBBbGwgdmFsdWVzIGluIHRoZSBkaWN0aW9uYXJ5LCBpbiB0aGUgc2FtZSBvcmRlciBhcyBbdG9fYWxpc3RdLiAqKVxuICAgIHZhbCBkYXRhIDogKF8sICdkYXRhLCAncGhhbnRvbSkgdCAtPiAnZGF0YSBsaXN0XG5cbiAgICAoKiogUmVtb3ZlcyBhbGwga2V5L3ZhbHVlIHBhaXJzIGZyb20gdGhlIGRpY3Rpb25hcnkuICopXG4gICAgdmFsIGNsZWFyIDogKF8sIF8sICdwaGFudG9tKSB0IC0+IHVuaXRcblxuICAgICgqKiBBIG5ldyBkaWN0aW9uYXJ5IGNvbnRhaW5pbmcgdGhlIHNhbWUga2V5L3ZhbHVlIHBhaXJzLiAqKVxuICAgIHZhbCBjb3B5IDogKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG5cbiAgICAoKiogV2hldGhlciBba2V5XSBoYXMgYSB2YWx1ZS4gKilcbiAgICB2YWwgbWVtXG4gICAgICA6ICgoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IC0+ICdrZXkga2V5IC0+IGJvb2wsICdrZXksICdkYXRhLCAncGhhbnRvbSkgYWNjZXNzb3JcblxuICAgICgqKiBQcm9kdWNlcyB0aGUgY3VycmVudCB2YWx1ZSwgb3IgYWJzZW5jZSB0aGVyZW9mLCBmb3IgYSBnaXZlbiBrZXkuICopXG4gICAgdmFsIGZpbmRcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IC0+ICdrZXkga2V5IC0+ICdkYXRhIG9wdGlvblxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBMaWtlIFtmaW5kXS4gUmFpc2VzIGlmIHRoZXJlIGlzIG5vIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5LiAqKVxuICAgIHZhbCBmaW5kX2V4blxuICAgICAgOiAoKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiAna2V5IGtleSAtPiAnZGF0YSwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuXG4gICAgKCoqIExpa2UgW2ZpbmRdLiBBZGRzIHRoZSB2YWx1ZSBbZGVmYXVsdCAoKV0gaWYgbm9uZSBleGlzdHMsIHRoZW4gcmV0dXJucyBpdC4gKilcbiAgICB2YWwgZmluZF9vcl9hZGRcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IC0+ICdrZXkga2V5IC0+IGRlZmF1bHQ6KHVuaXQgLT4gJ2RhdGEpIC0+ICdkYXRhXG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIExpa2UgW2ZpbmRdLiBBZGRzIFtkZWZhdWx0IGtleV0gaWYgbm8gdmFsdWUgZXhpc3RzLiAqKVxuICAgIHZhbCBmaW5kaV9vcl9hZGRcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IC0+ICdrZXkga2V5IC0+IGRlZmF1bHQ6KCdrZXkga2V5IC0+ICdkYXRhKSAtPiAnZGF0YVxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBMaWtlIFtmaW5kXS4gQ2FsbHMgW2lmX2ZvdW5kIGRhdGFdIGlmIGEgdmFsdWUgZXhpc3RzLCBvciBbaWZfbm90X2ZvdW5kIGtleV1cbiAgICAgICAgb3RoZXJ3aXNlLiBBdm9pZHMgYWxsb2NhdGlvbiBbU29tZV0uICopXG4gICAgdmFsIGZpbmRfYW5kX2NhbGxcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gJ2tleSBrZXlcbiAgICAgICAgICAtPiBpZl9mb3VuZDooJ2RhdGEgLT4gJ2MpXG4gICAgICAgICAgLT4gaWZfbm90X2ZvdW5kOigna2V5IGtleSAtPiAnYylcbiAgICAgICAgICAtPiAnY1xuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBMaWtlIFtmaW5kaV0uIENhbGxzIFtpZl9mb3VuZCB+a2V5IH5kYXRhXSBpZiBhIHZhbHVlIGV4aXN0cy4gKilcbiAgICB2YWwgZmluZGlfYW5kX2NhbGxcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gJ2tleSBrZXlcbiAgICAgICAgICAtPiBpZl9mb3VuZDooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gJ2MpXG4gICAgICAgICAgLT4gaWZfbm90X2ZvdW5kOigna2V5IGtleSAtPiAnYylcbiAgICAgICAgICAtPiAnY1xuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBMaWtlIFtmaW5kXS4gUmVtb3ZlcyB0aGUgdmFsdWUgZm9yIFtrZXldLCBpZiBhbnksIGZyb20gdGhlIGRpY3Rpb25hcnkgYmVmb3JlXG4gICAgICAgIHJldHVybmluZyBpdC4gKilcbiAgICB2YWwgZmluZF9hbmRfcmVtb3ZlXG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiAna2V5IGtleSAtPiAnZGF0YSBvcHRpb25cbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogQWRkcyBhIGtleS92YWx1ZSBwYWlyIGZvciBhIGtleSB0aGUgZGljdGlvbmFyeSBkb2VzIG5vdCBjb250YWluLCBvciByZXBvcnRzIGFcbiAgICAgICAgZHVwbGljYXRlLiAqKVxuICAgIHZhbCBhZGRcbiAgICAgIDogKCAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IC0+IGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+IFsgYE9rIHwgYER1cGxpY2F0ZSBdXG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIExpa2UgW2FkZF0uIFJhaXNlcyBvbiBkdXBsaWNhdGVzLiAqKVxuICAgIHZhbCBhZGRfZXhuXG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiBrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiB1bml0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIEFkZHMgb3IgcmVwbGFjZXMgYSBrZXkvdmFsdWUgcGFpciBpbiB0aGUgZGljdGlvbmFyeS4gKilcbiAgICB2YWwgc2V0XG4gICAgICA6ICggKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAtPiBrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiB1bml0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIFJlbW92ZXMgYW55IHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5LiAqKVxuICAgIHZhbCByZW1vdmVcbiAgICAgIDogKCgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gJ2tleSBrZXkgLT4gdW5pdCwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuXG4gICAgKCoqIEFkZHMsIHJlcGxhY2VzLCBvciByZW1vdmVzIHRoZSB2YWx1ZSBmb3IgYSBnaXZlbiBrZXksIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudFxuICAgICAgICB2YWx1ZSBvciBsYWNrIHRoZXJlb2YuICopXG4gICAgdmFsIGNoYW5nZVxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gJ2tleSBrZXkgLT4gZjooJ2RhdGEgb3B0aW9uIC0+ICdkYXRhIG9wdGlvbikgLT4gdW5pdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBBZGRzIG9yIHJlcGxhY2VzIHRoZSB2YWx1ZSBmb3IgYSBnaXZlbiBrZXksIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCB2YWx1ZSBvclxuICAgICAgICBsYWNrIHRoZXJlb2YuICopXG4gICAgdmFsIHVwZGF0ZVxuICAgICAgOiAoICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gJ2tleSBrZXkgLT4gZjooJ2RhdGEgb3B0aW9uIC0+ICdkYXRhKSAtPiB1bml0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIExpa2UgW3VwZGF0ZV0uIFJldHVybnMgdGhlIG5ldyB2YWx1ZS4gKilcbiAgICB2YWwgdXBkYXRlX2FuZF9yZXR1cm5cbiAgICAgIDogICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+ICdrZXkga2V5XG4gICAgICAtPiBmOignZGF0YSBvcHRpb24gLT4gJ2RhdGEpXG4gICAgICAtPiAnZGF0YVxuXG4gICAgKCoqIEFkZHMgW2J5XSB0byB0aGUgdmFsdWUgZm9yIFtrZXldLCBkZWZhdWx0IDAgaWYgW2tleV0gaXMgYWJzZW50LiBNYXkgcmVtb3ZlIFtrZXldXG4gICAgICAgIGlmIHRoZSByZXN1bHQgaXMgWzBdLCBkZXBlbmRpbmcgb24gW3JlbW92ZV9pZl96ZXJvXS4gKilcbiAgICB2YWwgaW5jclxuICAgICAgOiAoID9ieTppbnQgKCoqIGRlZmF1bHQ6IDEgKilcbiAgICAgICAgICAtPiA/cmVtb3ZlX2lmX3plcm86Ym9vbCAoKiogZGVmYXVsdDogZmFsc2UgKilcbiAgICAgICAgICAtPiAoJ2tleSwgaW50LCAncGhhbnRvbSkgdFxuICAgICAgICAgIC0+ICdrZXkga2V5XG4gICAgICAgICAgLT4gdW5pdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBTdWJ0cmFjdHMgW2J5XSBmcm9tIHRoZSB2YWx1ZSBmb3IgW2tleV0sIGRlZmF1bHQgMCBpZiBba2V5XSBpcyBhYnNlbnQuIE1heSByZW1vdmVcbiAgICAgICAgW2tleV0gaWYgdGhlIHJlc3VsdCBpcyBbMF0sIGRlcGVuZGluZyBvbiBbcmVtb3ZlX2lmX3plcm9dLiAqKVxuICAgIHZhbCBkZWNyXG4gICAgICA6ICggP2J5OmludCAoKiogZGVmYXVsdDogMSAqKVxuICAgICAgICAgIC0+ID9yZW1vdmVfaWZfemVybzpib29sICgqKiBkZWZhdWx0OiBmYWxzZSAqKVxuICAgICAgICAgIC0+ICgna2V5LCBpbnQsICdwaGFudG9tKSB0XG4gICAgICAgICAgLT4gJ2tleSBrZXlcbiAgICAgICAgICAtPiB1bml0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIEFkZHMgW2RhdGFdIHRvIHRoZSBleGlzdGluZyBrZXkvdmFsdWUgcGFpciBmb3IgW2tleV0uIEludGVycHJldHMgYSBtaXNzaW5nIGtleSBhc1xuICAgICAgICBoYXZpbmcgYW4gZW1wdHkgbGlzdC4gKilcbiAgICB2YWwgYWRkX211bHRpXG4gICAgICA6ICggKCdrZXksICdkYXRhIGxpc3QsICdwaGFudG9tKSB0IC0+IGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+IHVuaXRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGFjY2Vzc29yXG5cbiAgICAoKiogUmVtb3ZlcyBvbmUgZWxlbWVudCBmcm9tIHRoZSBleGlzdGluZyBrZXkvdmFsdWUgcGFpciBmb3IgW2tleV0uIFJlbW92ZXMgdGhlIGtleVxuICAgICAgICBlbnRpcmVseSBpZiB0aGUgbmV3IGxpc3QgaXMgZW1wdHkuICopXG4gICAgdmFsIHJlbW92ZV9tdWx0aVxuICAgICAgOiAoKCdrZXksIF8gbGlzdCwgJ3BoYW50b20pIHQgLT4gJ2tleSBrZXkgLT4gdW5pdCwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuXG4gICAgKCoqIFByb2R1Y2VzIHRoZSBsaXN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBrZXkuIEludGVycHJldHMgYSBtaXNzaW5nXG4gICAgICAgIGtleSBhcyBoYXZpbmcgYW4gZW1wdHkgbGlzdC4gKilcbiAgICB2YWwgZmluZF9tdWx0aVxuICAgICAgOiAoICgna2V5LCAnZGF0YSBsaXN0LCAncGhhbnRvbSkgdCAtPiAna2V5IGtleSAtPiAnZGF0YSBsaXN0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBhY2Nlc3NvclxuXG4gICAgKCoqIENvbWJpbmVzIGV2ZXJ5IHZhbHVlIGluIHRoZSBkaWN0aW9uYXJ5LiAqKVxuICAgIHZhbCBmb2xkXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBpbml0OidhY2NcbiAgICAgIC0+IGY6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+ICdhY2MgLT4gJ2FjYylcbiAgICAgIC0+ICdhY2NcblxuICAgICgqKiBXaGV0aGVyIGV2ZXJ5IHZhbHVlIHNhdGlzZmllcyBbZl0uICopXG4gICAgdmFsIGZvcl9hbGwgOiAoXywgJ2RhdGEsICdwaGFudG9tKSB0IC0+IGY6KCdkYXRhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAgICgqKiBMaWtlIFtmb3JfYWxsXS4gVGhlIHByZWRpY2F0ZSBtYXkgYWxzbyBkZXBlbmQgb24gdGhlIGFzc29jaWF0ZWQga2V5LiAqKVxuICAgIHZhbCBmb3JfYWxsaVxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gYm9vbClcbiAgICAgIC0+IGJvb2xcblxuICAgICgqKiBXaGV0aGVyIGF0IGxlYXN0IG9uZSB2YWx1ZSBzYXRpc2ZpZXMgW2ZdLiAqKVxuICAgIHZhbCBleGlzdHMgOiAoXywgJ2RhdGEsICdwaGFudG9tKSB0IC0+IGY6KCdkYXRhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAgICgqKiBMaWtlIFtleGlzdHNdLiBUaGUgcHJlZGljYXRlIG1heSBhbHNvIGRlcGVuZCBvbiB0aGUgYXNzb2NpYXRlZCBrZXkuICopXG4gICAgdmFsIGV4aXN0c2lcbiAgICAgIDogICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+IGJvb2wpXG4gICAgICAtPiBib29sXG5cbiAgICAoKiogSG93IG1hbnkgdmFsdWVzIHNhdGlzZnkgW2ZdLiAqKVxuICAgIHZhbCBjb3VudCA6IChfLCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gZjooJ2RhdGEgLT4gYm9vbCkgLT4gaW50XG5cbiAgICAoKiogTGlrZSBbY291bnRdLiBUaGUgcHJlZGljYXRlIG1heSBhbHNvIGRlcGVuZCBvbiB0aGUgYXNzb2NpYXRlZCBrZXkuICopXG4gICAgdmFsIGNvdW50aVxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gYm9vbClcbiAgICAgIC0+IGludFxuXG4gICAgKCoqIEFyYml0cmFyeSwgZGV0ZXJtaW5pc3RpYyBrZXkvdmFsdWUgcGFpciBpZiBub24tZW1wdHkuICopXG4gICAgdmFsIGNob29zZSA6ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gKCdrZXkga2V5ICogJ2RhdGEpIG9wdGlvblxuXG4gICAgKCoqIExpa2UgW2Nob29zZV0uIFJhaXNlcyBpZiBlbXB0eS4gKilcbiAgICB2YWwgY2hvb3NlX2V4biA6ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgLT4gJ2tleSBrZXkgKiAnZGF0YVxuXG4gICAgKCoqIEFyYml0cmFyeSwgcHNldWRvLXJhbmRvbSBrZXkvdmFsdWUgcGFpciBpZiBub24tZW1wdHkuICopXG4gICAgdmFsIGNob29zZV9yYW5kb21seVxuICAgICAgOiAgP3JhbmRvbV9zdGF0ZTpSYW5kb20uU3RhdGUudFxuICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gKCdrZXkga2V5ICogJ2RhdGEpIG9wdGlvblxuXG4gICAgKCoqIExpa2UgW2Nob29zZV9yYW5kb21seV0uIFJhaXNlcyBpZiBlbXB0eS4gKilcbiAgICB2YWwgY2hvb3NlX3JhbmRvbWx5X2V4blxuICAgICAgOiAgP3JhbmRvbV9zdGF0ZTpSYW5kb20uU3RhdGUudFxuICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gJ2tleSBrZXkgKiAnZGF0YVxuXG4gICAgKCoqIENhbGxzIFtmXSBmb3IgZXZlcnkga2V5LiAqKVxuICAgIHZhbCBpdGVyX2tleXMgOiAoJ2tleSwgXywgJ3BoYW50b20pIHQgLT4gZjooJ2tleSBrZXkgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICAgKCoqIENhbGxzIFtmXSBmb3IgZXZlcnkgdmFsdWUuICopXG4gICAgdmFsIGl0ZXIgOiAoXywgJ2RhdGEsICdwaGFudG9tKSB0IC0+IGY6KCdkYXRhIC0+IHVuaXQpIC0+IHVuaXRcblxuICAgICgqKiBDYWxscyBbZl0gZm9yIGV2ZXJ5IGtleS92YWx1ZSBwYWlyLiAqKVxuICAgIHZhbCBpdGVyaVxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gdW5pdClcbiAgICAgIC0+IHVuaXRcblxuICAgICgqKiBUcmFuc2Zvcm1zIGV2ZXJ5IHZhbHVlLiAqKVxuICAgIHZhbCBtYXAgOiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IC0+IGY6KCdkYXRhIC0+ICdjKSAtPiAoJ2tleSwgJ2MsICdwaGFudG9tKSB0XG5cbiAgICAoKiogTGlrZSBbbWFwXS4gVGhlIHRyYW5zZm9ybWF0aW9uIG1heSBhbHNvIGRlcGVuZCBvbiB0aGUgYXNzb2NpYXRlZCBrZXkuICopXG4gICAgdmFsIG1hcGlcbiAgICAgIDogICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+ICdjKVxuICAgICAgLT4gKCdrZXksICdjLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIExpa2UgW21hcF0uIE1vZGlmaWVzIHRoZSBpbnB1dC4gKilcbiAgICB2YWwgbWFwX2lucGxhY2UgOiAoXywgJ2RhdGEsICdwaGFudG9tKSB0IC0+IGY6KCdkYXRhIC0+ICdkYXRhKSAtPiB1bml0XG5cbiAgICAoKiogTGlrZSBbbWFwaV0uIE1vZGlmaWVzIHRoZSBpbnB1dC4gKilcbiAgICB2YWwgbWFwaV9pbnBsYWNlXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiAnZGF0YSlcbiAgICAgIC0+IHVuaXRcblxuICAgICgqKiBQcm9kdWNlcyBvbmx5IHRob3NlIGtleS92YWx1ZSBwYWlycyB3aG9zZSBrZXkgc2F0aXNmaWVzIFtmXS4gKilcbiAgICB2YWwgZmlsdGVyX2tleXNcbiAgICAgIDogICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KCdrZXkga2V5IC0+IGJvb2wpXG4gICAgICAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG5cbiAgICAoKiogUHJvZHVjZXMgb25seSB0aG9zZSBrZXkvdmFsdWUgcGFpcnMgd2hvc2UgdmFsdWUgc2F0aXNmaWVzIFtmXS4gKilcbiAgICB2YWwgZmlsdGVyXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOignZGF0YSAtPiBib29sKVxuICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIFByb2R1Y2VzIG9ubHkgdGhvc2Uga2V5L3ZhbHVlIHBhaXJzIHdoaWNoIHNhdGlzZnkgW2ZdLiAqKVxuICAgIHZhbCBmaWx0ZXJpXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiBib29sKVxuICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIExpa2UgW2ZpbHRlcl9rZXlzXS4gTW9kaWZpZXMgdGhlIGlucHV0LiAqKVxuICAgIHZhbCBmaWx0ZXJfa2V5c19pbnBsYWNlIDogKCdrZXksIF8sICdwaGFudG9tKSB0IC0+IGY6KCdrZXkga2V5IC0+IGJvb2wpIC0+IHVuaXRcblxuICAgICgqKiBMaWtlIFtmaWx0ZXJdLiBNb2RpZmllcyB0aGUgaW5wdXQuICopXG4gICAgdmFsIGZpbHRlcl9pbnBsYWNlIDogKF8sICdkYXRhLCAncGhhbnRvbSkgdCAtPiBmOignZGF0YSAtPiBib29sKSAtPiB1bml0XG5cbiAgICAoKiogTGlrZSBbZmlsdGVyaV0uIE1vZGlmaWVzIHRoZSBpbnB1dC4gKilcbiAgICB2YWwgZmlsdGVyaV9pbnBsYWNlXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiBib29sKVxuICAgICAgLT4gdW5pdFxuXG4gICAgKCoqIFByb2R1Y2VzIGtleS92YWx1ZSBwYWlycyBmb3Igd2hpY2ggW2ZdIHByb2R1Y2VzIFtTb21lXS4gKilcbiAgICB2YWwgZmlsdGVyX21hcFxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooJ2RhdGEgLT4gJ2Mgb3B0aW9uKVxuICAgICAgLT4gKCdrZXksICdjLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIExpa2UgW2ZpbHRlcl9tYXBdLiBUaGUgbmV3IHZhbHVlIG1heSBhbHNvIGRlcGVuZCBvbiB0aGUgYXNzb2NpYXRlZCBrZXkuICopXG4gICAgdmFsIGZpbHRlcl9tYXBpXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiAnYyBvcHRpb24pXG4gICAgICAtPiAoJ2tleSwgJ2MsICdwaGFudG9tKSB0XG5cbiAgICAoKiogTGlrZSBbZmlsdGVyX21hcF0uIE1vZGlmaWVzIHRoZSBpbnB1dC4gKilcbiAgICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlIDogKF8sICdkYXRhLCAncGhhbnRvbSkgdCAtPiBmOignZGF0YSAtPiAnZGF0YSBvcHRpb24pIC0+IHVuaXRcblxuICAgICgqKiBMaWtlIFtmaWx0ZXJfbWFwaV0uIE1vZGlmaWVzIHRoZSBpbnB1dC4gKilcbiAgICB2YWwgZmlsdGVyX21hcGlfaW5wbGFjZVxuICAgICAgOiAgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgLT4gZjooa2V5OidrZXkga2V5IC0+IGRhdGE6J2RhdGEgLT4gJ2RhdGEgb3B0aW9uKVxuICAgICAgLT4gdW5pdFxuXG4gICAgKCoqIFNwbGl0cyBvbmUgZGljdGlvbmFyeSBpbnRvIHR3by4gVGhlIGZpcnN0IGNvbnRhaW5zIGtleS92YWx1ZSBwYWlycyBmb3Igd2hpY2ggdGhlXG4gICAgICAgIHZhbHVlIHNhdGlzZmllcyBbZl0uIFRoZSBzZWNvbmQgY29udGFpbnMgdGhlIHJlbWFpbmRlci4gKilcbiAgICB2YWwgcGFydGl0aW9uX3RmXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOignZGF0YSAtPiBib29sKVxuICAgICAgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCAqICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcblxuICAgICgqKiBMaWtlIFtwYXJ0aXRpb25fdGZdLiBUaGUgcHJlZGljYXRlIG1heSBhbHNvIGRlcGVuZCBvbiB0aGUgYXNzb2NpYXRlZCBrZXkuICopXG4gICAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICAgIDogICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KGtleTona2V5IGtleSAtPiBkYXRhOidkYXRhIC0+IGJvb2wpXG4gICAgICAtPiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0ICogKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuXG4gICAgKCoqIFNwbGl0cyBvbmUgZGljdGlvbmFyeSBpbnRvIHR3bywgY29ycmVzcG9uZGluZyByZXNwZWN0aXZlbHkgdG8gW0ZpcnN0IF9dIGFuZFxuICAgICAgICBbU2Vjb25kIF9dIHJlc3VsdHMgZnJvbSBbZl0uICopXG4gICAgdmFsIHBhcnRpdGlvbl9tYXBcbiAgICAgIDogICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgIC0+IGY6KCdkYXRhIC0+ICgnYywgJ2QpIEVpdGhlci50KVxuICAgICAgLT4gKCdrZXksICdjLCAncGhhbnRvbSkgdCAqICgna2V5LCAnZCwgJ3BoYW50b20pIHRcblxuICAgICgqKiBMaWtlIFtwYXJ0aXRpb25fbWFwXS4gVGhlIHNwbGl0IG1heSBhbHNvIGRlcGVuZCBvbiB0aGUgYXNzb2NpYXRlZCBrZXkuICopXG4gICAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgICA6ICAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gZGF0YTonZGF0YSAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAgIC0+ICgna2V5LCAnYywgJ3BoYW50b20pIHQgKiAoJ2tleSwgJ2QsICdwaGFudG9tKSB0XG5cbiAgICAoKiogTWVyZ2VzIHR3byBkaWN0aW9uYXJpZXMgYnkgZnVsbHkgdHJhdmVyc2luZyBib3RoLiBOb3Qgc3VpdGFibGUgZm9yIGVmZmljaWVudGx5XG4gICAgICAgIG1lcmdpbmcgbGlzdHMgb2YgZGljdGlvbmFyaWVzLiBTZWUgW21lcmdlX2ludG9dIGluc3RlYWQuICopXG4gICAgdmFsIG1lcmdlXG4gICAgICA6ICggKCdrZXksICdkYXRhMSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiAoJ2tleSwgJ2RhdGEyLCAncGhhbnRvbSkgdFxuICAgICAgICAgIC0+IGY6XG4gICAgICAgICAgICAgICAoa2V5OidrZXkga2V5XG4gICAgICAgICAgICAgICAgLT4gWyBgTGVmdCBvZiAnZGF0YTEgfCBgUmlnaHQgb2YgJ2RhdGEyIHwgYEJvdGggb2YgJ2RhdGExICogJ2RhdGEyIF1cbiAgICAgICAgICAgICAgICAtPiAnZGF0YTMgb3B0aW9uKVxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YTMsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhM1xuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcblxuICAgICgqKiBNZXJnZXMgdHdvIGRpY3Rpb25hcmllcyBieSB0cmF2ZXJzaW5nIFtzcmNdIGFuZCBhZGRpbmcgdG8gW2RzdF0uIENvbXB1dGVzIHRoZVxuICAgICAgICBlZmZlY3Qgb24gW2RzdF0gb2YgZWFjaCBrZXkvdmFsdWUgcGFpciBpbiBbc3JjXSB1c2luZyBbZl0uICopXG4gICAgdmFsIG1lcmdlX2ludG9cbiAgICAgIDogKCBzcmM6KCdrZXksICdkYXRhMSwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiBkc3Q6KCdrZXksICdkYXRhMiwgJ3BoYW50b20pIHRcbiAgICAgICAgICAtPiBmOihrZXk6J2tleSBrZXkgLT4gJ2RhdGExIC0+ICdkYXRhMiBvcHRpb24gLT4gJ2RhdGEyIE1lcmdlX2ludG9fYWN0aW9uLnQpXG4gICAgICAgICAgLT4gdW5pdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgYWNjZXNzb3JcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMSA9IHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnZGF0YSB0XG5cbiAgICBpbmNsdWRlXG4gICAgICBBY2Nlc3NvcnNcbiAgICAgICAgd2l0aCB0eXBlIChfLCAnZGF0YSwgXykgdCA6PSAnZGF0YSB0XG4gICAgICAgICBhbmQgdHlwZSBfIGtleSA6PSBrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sIF8sIF8sIF8pIGFjY2Vzc29yIDo9ICdmblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMyID0gc2lnXG4gICAgdHlwZSAoJ2tleSwgJ2RhdGEpIHRcbiAgICB0eXBlICgnZm4sICdrZXksICdkYXRhKSBhY2Nlc3NvclxuXG4gICAgaW5jbHVkZVxuICAgICAgQWNjZXNzb3JzXG4gICAgICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsIF8pIHQgOj0gKCdrZXksICdkYXRhKSB0XG4gICAgICAgICBhbmQgdHlwZSAna2V5IGtleSA6PSAna2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgXykgYWNjZXNzb3IgOj0gKCdmbiwgJ2tleSwgJ2RhdGEpIGFjY2Vzc29yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczMgPSBzaWdcbiAgICB0eXBlICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICB0eXBlICgnZm4sICdrZXksICdkYXRhLCAncGhhbnRvbSkgYWNjZXNzb3JcblxuICAgIGluY2x1ZGVcbiAgICAgIEFjY2Vzc29yc1xuICAgICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCA6PSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICBhbmQgdHlwZSAna2V5IGtleSA6PSAna2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yIDo9XG4gICAgICAgICAgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBDcmVhdG9ycyA9IHNpZ1xuICAgICgqKiBUaGUgdHlwZSBvZiBrZXlzLiBUaGlzIHdpbGwgYmUgWydrZXldIGZvciBwb2x5bW9ycGhpYyBkaWN0aW9uYXJpZXMsIG9yIHNvbWUgZml4ZWRcbiAgICAgICAgdHlwZSBmb3IgZGljdGlvbmFyaWVzIHdpdGggbW9ub21vcnBoaWMga2V5cy4gKilcbiAgICB0eXBlICdrZXkga2V5XG5cbiAgICAoKiogRGljdGlvbmFyaWVzLiBUaGVpciBrZXlzIGhhdmUgdHlwZSBbJ2tleSBrZXldLiBFYWNoIGtleSdzIGFzc29jaWF0ZWQgdmFsdWUgaGFzXG4gICAgICAgIHR5cGUgWydkYXRhXS4gVGhlIGRpY3Rpb25hcnkgbWF5IGJlIGRpc3Rpbmd1aXNoZWQgYnkgYSBbJ3BoYW50b21dIHR5cGUuICopXG4gICAgdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG5cbiAgICAoKiogVGhlIHR5cGUgb2YgY3JlYXRvciBmdW5jdGlvbnMgWydmbl0gdGhhdCBvcGVyYXRlIG9uIFsoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XS5cbiAgICAgICAgTWF5IHRha2UgZXh0cmEgYXJndW1lbnRzIGJlZm9yZSBbJ2ZuXSwgc3VjaCBhcyBhIGNvbXBhcmlzb24gZnVuY3Rpb24uICopXG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGNyZWF0b3JcblxuICAgICgqKiBDcmVhdGVzIGEgbmV3IGVtcHR5IGRpY3Rpb25hcnkuICopXG4gICAgdmFsIGNyZWF0ZSA6ICh1bml0IC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQsICdrZXksICdkYXRhLCAncGhhbnRvbSkgY3JlYXRvclxuXG4gICAgKCoqIERpY3Rpb25hcnkgY29udGFpbmluZyB0aGUgZ2l2ZW4ga2V5L3ZhbHVlIHBhaXJzLiBGYWlscyBpZiB0aGVyZSBhcmUgZHVwbGljYXRlXG4gICAgICAgIGtleXMuICopXG4gICAgdmFsIG9mX2FsaXN0XG4gICAgICA6ICggKCdrZXkga2V5ICogJ2RhdGEpIGxpc3RcbiAgICAgICAgICAtPiBbIGBPayBvZiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2tleSBrZXkgXVxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2FsaXN0XS4gT24gZmFpbHVyZSwgcHJvdmlkZXMgYWxsIGR1cGxpY2F0ZSBrZXlzIGluc3RlYWQgb2YgYSBzaW5nbGVcbiAgICAgICAgcmVwcmVzZW50YXRpdmUuICopXG4gICAgdmFsIG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwc1xuICAgICAgOiAoICgna2V5IGtleSAqICdkYXRhKSBsaXN0XG4gICAgICAgICAgLT4gWyBgT2sgb2YgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAna2V5IGtleSBsaXN0IF1cbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtvZl9hbGlzdF0uIFJldHVybnMgYSBbUmVzdWx0LnRdLiAqKVxuICAgIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgICAgOiAoICgna2V5IGtleSAqICdkYXRhKSBsaXN0IC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgT3JfZXJyb3IudFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2FsaXN0XS4gUmFpc2VzIG9uIGR1cGxpY2F0ZXMuICopXG4gICAgdmFsIG9mX2FsaXN0X2V4blxuICAgICAgOiAoICgna2V5IGtleSAqICdkYXRhKSBsaXN0IC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBQcm9kdWNlcyBhIGRpY3Rpb25hcnkgbWFwcGluZyBlYWNoIGtleSB0byBhIGxpc3Qgb2YgYXNzb2NpYXRlZCB2YWx1ZXMuICopXG4gICAgdmFsIG9mX2FsaXN0X211bHRpXG4gICAgICA6ICggKCdrZXkga2V5ICogJ2RhdGEpIGxpc3QgLT4gKCdrZXksICdkYXRhIGxpc3QsICdwaGFudG9tKSB0XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhIGxpc3RcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtvZl9hbGlzdF0uIENvbnN1bWUgYSBsaXN0IG9mIGVsZW1lbnRzIGZvciB3aGljaCBrZXkvdmFsdWUgcGFpcnMgY2FuIGJlXG4gICAgICAgIGNvbXB1dGVkLiAqKVxuICAgIHZhbCBjcmVhdGVfbWFwcGVkXG4gICAgICA6ICggZ2V0X2tleTooJ2EgLT4gJ2tleSBrZXkpXG4gICAgICAgICAgLT4gZ2V0X2RhdGE6KCdhIC0+ICdkYXRhKVxuICAgICAgICAgIC0+ICdhIGxpc3RcbiAgICAgICAgICAtPiBbIGBPayBvZiAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IHwgYER1cGxpY2F0ZV9rZXlzIG9mICdrZXkga2V5IGxpc3QgXVxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW29mX2FsaXN0XS4gQ29uc3VtZSB2YWx1ZXMgZm9yIHdoaWNoIGtleXMgY2FuIGJlIGNvbXB1dGVkLiAqKVxuICAgIHZhbCBjcmVhdGVfd2l0aF9rZXlcbiAgICAgIDogKCBnZXRfa2V5OignZGF0YSAtPiAna2V5IGtleSlcbiAgICAgICAgICAtPiAnZGF0YSBsaXN0XG4gICAgICAgICAgLT4gWyBgT2sgb2YgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAna2V5IGtleSBsaXN0IF1cbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcblxuICAgICgqKiBMaWtlIFtvZl9hbGlzdF9vcl9lcnJvcl0uIENvbnN1bWUgdmFsdWVzIGZvciB3aGljaCBrZXlzIGNhbiBiZSBjb21wdXRlZC4gKilcbiAgICB2YWwgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yXG4gICAgICA6ICggZ2V0X2tleTooJ2RhdGEgLT4gJ2tleSBrZXkpIC0+ICdkYXRhIGxpc3QgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCBPcl9lcnJvci50XG4gICAgICAgICwgJ2tleVxuICAgICAgICAsICdkYXRhXG4gICAgICAgICwgJ3BoYW50b20gKVxuICAgICAgICBjcmVhdG9yXG5cbiAgICAoKiogTGlrZSBbb2ZfYWxpc3RfZXhuXS4gQ29uc3VtZSB2YWx1ZXMgZm9yIHdoaWNoIGtleXMgY2FuIGJlIGNvbXB1dGVkLiAqKVxuICAgIHZhbCBjcmVhdGVfd2l0aF9rZXlfZXhuXG4gICAgICA6ICggZ2V0X2tleTooJ2RhdGEgLT4gJ2tleSBrZXkpIC0+ICdkYXRhIGxpc3QgLT4gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAsICdrZXlcbiAgICAgICAgLCAnZGF0YVxuICAgICAgICAsICdwaGFudG9tIClcbiAgICAgICAgY3JlYXRvclxuXG4gICAgKCoqIExpa2UgW2NyZWF0ZV9tYXBwZWRdLiBNdWx0aXBsZSB2YWx1ZXMgZm9yIGEga2V5IGFyZSBbY29tYmluZV1kIHJhdGhlciB0aGFuXG4gICAgICAgIHByb2R1Y2luZyBhbiBlcnJvci4gKilcbiAgICB2YWwgZ3JvdXBcbiAgICAgIDogKCBnZXRfa2V5OignYSAtPiAna2V5IGtleSlcbiAgICAgICAgICAtPiBnZXRfZGF0YTooJ2EgLT4gJ2RhdGEpXG4gICAgICAgICAgLT4gY29tYmluZTooJ2RhdGEgLT4gJ2RhdGEgLT4gJ2RhdGEpXG4gICAgICAgICAgLT4gJ2EgbGlzdFxuICAgICAgICAgIC0+ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgLCAna2V5XG4gICAgICAgICwgJ2RhdGFcbiAgICAgICAgLCAncGhhbnRvbSApXG4gICAgICAgIGNyZWF0b3JcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMxID0gc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICdkYXRhIHRcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNcbiAgICAgICAgd2l0aCB0eXBlIChfLCAnZGF0YSwgXykgdCA6PSAnZGF0YSB0XG4gICAgICAgICBhbmQgdHlwZSBfIGtleSA6PSBrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sIF8sIF8sIF8pIGNyZWF0b3IgOj0gJ2ZuXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMiA9IHNpZ1xuICAgIHR5cGUgKCdrZXksICdkYXRhKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSkgY3JlYXRvclxuXG4gICAgKCoqIEBpbmxpbmUgKilcbiAgICBpbmNsdWRlXG4gICAgICBDcmVhdG9yc1xuICAgICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCBfKSB0IDo9ICgna2V5LCAnZGF0YSkgdFxuICAgICAgICAgYW5kIHR5cGUgJ2tleSBrZXkgOj0gJ2tleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsIF8pIGNyZWF0b3IgOj0gKCdmbiwgJ2tleSwgJ2RhdGEpIGNyZWF0b3JcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMzID0gc2lnXG4gICAgdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGNyZWF0b3JcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNcbiAgICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHQgOj0gKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdFxuICAgICAgICAgYW5kIHR5cGUgJ2tleSBrZXkgOj0gJ2tleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yIDo9XG4gICAgICAgICAgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlICdrZXkga2V5XG4gICAgdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yXG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGNyZWF0b3JcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgQWNjZXNzb3JzXG4gICAgICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0IDo9ICgna2V5LCAnZGF0YSwgJ3BoYW50b20pIHRcbiAgICAgICAgIGFuZCB0eXBlICdrZXkga2V5IDo9ICdrZXkga2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yIDo9XG4gICAgICAgICAgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuXG4gICAgKCoqIEBpbmxpbmUgKilcbiAgICBpbmNsdWRlXG4gICAgICBDcmVhdG9yc1xuICAgICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCA6PSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICBhbmQgdHlwZSAna2V5IGtleSA6PSAna2V5IGtleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yIDo9XG4gICAgICAgICAgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICdkYXRhIHRcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgU1xuICAgICAgICB3aXRoIHR5cGUgKF8sICdkYXRhLCBfKSB0IDo9ICdkYXRhIHRcbiAgICAgICAgIGFuZCB0eXBlIF8ga2V5IDo9IGtleVxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgXywgXywgXykgYWNjZXNzb3IgOj0gJ2ZuXG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCBfLCBfLCBfKSBjcmVhdG9yIDo9ICdmblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdrZXksICdkYXRhKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSkgYWNjZXNzb3JcbiAgICB0eXBlICgnZm4sICdrZXksICdkYXRhKSBjcmVhdG9yXG5cbiAgICAoKiogQGlubGluZSAqKVxuICAgIGluY2x1ZGVcbiAgICAgIFNcbiAgICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgXykgdCA6PSAoJ2tleSwgJ2RhdGEpIHRcbiAgICAgICAgIGFuZCB0eXBlICdrZXkga2V5IDo9ICdrZXlcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCBfKSBhY2Nlc3NvciA6PSAoJ2ZuLCAna2V5LCAnZGF0YSkgYWNjZXNzb3JcbiAgICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCBfKSBjcmVhdG9yIDo9ICgnZm4sICdrZXksICdkYXRhKSBjcmVhdG9yXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yXG4gICAgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGNyZWF0b3JcblxuICAgICgqKiBAaW5saW5lICopXG4gICAgaW5jbHVkZVxuICAgICAgU1xuICAgICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAncGhhbnRvbSkgdCA6PSAoJ2tleSwgJ2RhdGEsICdwaGFudG9tKSB0XG4gICAgICAgICBhbmQgdHlwZSAna2V5IGtleSA6PSAna2V5XG4gICAgICAgICBhbmQgdHlwZSAoJ2ZuLCAna2V5LCAnZGF0YSwgJ3BoYW50b20pIGFjY2Vzc29yIDo9XG4gICAgICAgICAgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBhY2Nlc3NvclxuICAgICAgICAgYW5kIHR5cGUgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yIDo9XG4gICAgICAgICAgKCdmbiwgJ2tleSwgJ2RhdGEsICdwaGFudG9tKSBjcmVhdG9yXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIERpY3Rpb25hcnlfbXV0YWJsZSA9IHNpZ1xuICAoKiogQGlubGluZSAqKVxuICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgRGVmaW5pdGlvbnMgKCoqIEBpbmxpbmUgKilcbiAgZW5kXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2h0YmwuS2V5ICopXG5tb2R1bGUgS2V5ID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgKCoqIFR3byBbdF1zIHRoYXQgW2NvbXBhcmVdIGVxdWFsIG11c3QgaGF2ZSBlcXVhbCBoYXNoZXMgZm9yIHRoZSBoYXNodGFibGVcbiAgICAgICAgdG8gYmVoYXZlIHByb3Blcmx5LiAqKVxuICAgIHZhbCBoYXNoIDogdCAtPiBpbnRcbiAgZW5kXG5cbiAgdHlwZSAnYSB0ID0gKG1vZHVsZSBTIHdpdGggdHlwZSB0ID0gJ2EpXG5lbmRcblxubW9kdWxlIE1lcmdlX2ludG9fYWN0aW9uID0gRGljdGlvbmFyeV9tdXRhYmxlLk1lcmdlX2ludG9fYWN0aW9uXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29ycyA9IHNpZ1xuICAoKiogezIgQWNjZXNzb3JzfSAqKVxuXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICdhIGtleVxuXG4gICgqKiBAaW5saW5lICopXG4gIGluY2x1ZGVcbiAgICBEaWN0aW9uYXJ5X211dGFibGUuQWNjZXNzb3JzXG4gICAgICB3aXRoIHR5cGUgJ2tleSBrZXkgOj0gJ2tleSBrZXlcbiAgICAgICBhbmQgdHlwZSAoJ2tleSwgJ2RhdGEsIF8pIHQgOj0gKCdrZXksICdkYXRhKSB0XG4gICAgICAgYW5kIHR5cGUgKCdmbiwgXywgXywgXykgYWNjZXNzb3IgOj0gJ2ZuXG5cbiAgdmFsIHNleHBfb2Zfa2V5IDogKCdhLCBfKSB0IC0+ICdhIGtleSAtPiBTZXhwLnRcbiAgdmFsIGNsZWFyIDogKF8sIF8pIHQgLT4gdW5pdFxuICB2YWwgY29weSA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdFxuXG4gICgqKiBBdHRlbXB0aW5nIHRvIG1vZGlmeSAoW3NldF0sIFtyZW1vdmVdLCBldGMuKSB0aGUgaGFzaHRhYmxlIGR1cmluZyBpdGVyYXRpb24gKFtmb2xkXSxcbiAgICAgIFtpdGVyXSwgW2l0ZXJfa2V5c10sIFtpdGVyaV0pIHdpbGwgcmFpc2UgYW4gZXhjZXB0aW9uLiAqKVxuICB2YWwgZm9sZCA6ICgnYSwgJ2IpIHQgLT4gaW5pdDonYWNjIC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnYWNjIC0+ICdhY2MpIC0+ICdhY2NcblxuICB2YWwgaXRlcl9rZXlzIDogKCdhLCBfKSB0IC0+IGY6KCdhIGtleSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogSXRlcmF0ZXMgb3ZlciBib3RoIGtleXMgYW5kIHZhbHVlcy5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgIGxldCBoID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBJbnQpIFsoMSwgNCk7ICg1LCA2KV0gaW5cbiAgICAgIEhhc2h0YmwuaXRlcmkgaCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgcHJpbnRfZW5kbGluZSAoUHJpbnRmLnNwcmludGYgXCIlZC0lZFwiIGtleSBkYXRhKSk7O1xuICAgICAgMS00XG4gICAgICA1LTZcbiAgICAgIC0gOiB1bml0ID0gKClcbiAgICAgIHZ9ICopXG4gIHZhbCBpdGVyaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXRcblxuICB2YWwgZXhpc3RzaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGwgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnRpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudCA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuICB2YWwgY2FwYWNpdHkgOiBfIHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6IChfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIG1lbSA6ICgnYSwgXykgdCAtPiAnYSBrZXkgLT4gYm9vbFxuICB2YWwgcmVtb3ZlIDogKCdhLCBfKSB0IC0+ICdhIGtleSAtPiB1bml0XG5cbiAgKCoqIENob29zZSBhbiBhcmJpdHJhcnkga2V5L3ZhbHVlIHBhaXIgb2YgYSBoYXNoIHRhYmxlLiBSZXR1cm5zIFtOb25lXSBpZiBbdF0gaXMgZW1wdHkuXG5cbiAgICAgIFRoZSBjaG9pY2UgaXMgZGV0ZXJtaW5pc3RpYy4gQ2FsbGluZyBbY2hvb3NlXSBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSB0YWJsZVxuICAgICAgcmV0dXJucyB0aGUgc2FtZSBrZXkvdmFsdWUgcGFpciwgc28gbG9uZyBhcyB0aGUgdGFibGUgaXMgbm90IG11dGF0ZWQgaW4gYmV0d2Vlbi5cbiAgICAgIEJleW9uZCBkZXRlcm1pbmlzbSwgbm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCBob3cgdGhlIGNob2ljZSBpcyBtYWRlLiBFeHBlY3RcbiAgICAgIGJpYXMgdG93YXJkIGNlcnRhaW4gaGFzaCB2YWx1ZXMuXG5cbiAgICAgIFRoaXMgaGFzaCBiaWFzIGNhbiBsZWFkIHRvIGRlZ2VuZXJhdGUgcGVyZm9ybWFuY2UgaW4gc29tZSBjYXNlcywgc3VjaCBhcyBjbGVhcmluZ1xuICAgICAgYSBoYXNoIHRhYmxlIHVzaW5nIHJlcGVhdGVkIFtjaG9vc2VdIGFuZCBbcmVtb3ZlXS4gQXQgZWFjaCBpdGVyYXRpb24sIGZpbmRpbmcgdGhlXG4gICAgICBuZXh0IGVsZW1lbnQgbWF5IGhhdmUgdG8gc2NhbiBmYXJ0aGVyIGZyb20gaXRzIGluaXRpYWwgaGFzaCB2YWx1ZS4gKilcbiAgdmFsIGNob29zZSA6ICgnYSwgJ2IpIHQgLT4gKCdhIGtleSAqICdiKSBvcHRpb25cblxuICAoKiogTGlrZSBbY2hvb3NlXS4gUmFpc2VzIGlmIFt0XSBpcyBlbXB0eS4gKilcbiAgdmFsIGNob29zZV9leG4gOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAqICdiXG5cbiAgKCoqIENob29zZXMgYSByYW5kb20ga2V5L3ZhbHVlIHBhaXIgb2YgYSBoYXNoIHRhYmxlLiBSZXR1cm5zIFtOb25lXSBpZiBbdF0gaXMgZW1wdHkuXG5cbiAgICAgIFRoZSBjaG9pY2UgaXMgZGlzdHJpYnV0ZWQgdW5pZm9ybWx5IGFjcm9zcyBoYXNoIHZhbHVlcywgcmF0aGVyIHRoYW4gYWNyb3NzIGtleXNcbiAgICAgIHRoZW1zZWx2ZXMuIEFzIGEgY29uc2VxdWVuY2UsIHRoZSBjbG9zZXIgdGhlIGtleXMgYXJlIHRvIGV2ZW5seSBzcGFjZWQgb3V0IGluIHRoZVxuICAgICAgdGFibGUsIHRoZSBjbG9zZXIgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIHRvIGEgdW5pZm9ybSBjaG9pY2Ugb2Yga2V5cy5cblxuICAgICAgVGhpcyBmdW5jdGlvbiBtYXkgYmUgcHJlZmVyYWJsZSB0byBbY2hvb3NlXSB3aGVuIG5vbmRldGVybWluaXN0aWMgY2hvaWNlIGlzXG4gICAgICBhY2NlcHRhYmxlLCBhbmQgYmlhcyB0b3dhcmQgY2VydGFpbiBoYXNoIHZhbHVlcyBpcyB1bmRlc2lyYWJsZS4gKilcbiAgdmFsIGNob29zZV9yYW5kb21seVxuICAgIDogID9yYW5kb21fc3RhdGU6UmFuZG9tLlN0YXRlLnQgKCoqIGRlZmF1bHQ6IFtSYW5kb20uU3RhdGUuZGVmYXVsdF0gKilcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgLT4gKCdhIGtleSAqICdiKSBvcHRpb25cblxuICAoKiogTGlrZSBbY2hvb3NlX3JhbmRvbWx5XS4gUmFpc2VzIGlmIFt0XSBpcyBlbXB0eS4gKilcbiAgdmFsIGNob29zZV9yYW5kb21seV9leG5cbiAgICA6ICA/cmFuZG9tX3N0YXRlOlJhbmRvbS5TdGF0ZS50ICgqKiBkZWZhdWx0OiBbUmFuZG9tLlN0YXRlLmRlZmF1bHRdICopXG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+ICdhIGtleSAqICdiXG5cbiAgKCoqIFNldHMgdGhlIGdpdmVuIFtrZXldIHRvIFtkYXRhXS4gKilcbiAgdmFsIHNldCA6ICgnYSwgJ2IpIHQgLT4ga2V5OidhIGtleSAtPiBkYXRhOidiIC0+IHVuaXRcblxuICAoKiogW2FkZF0gYW5kIFthZGRfZXhuXSBsZWF2ZSB0aGUgdGFibGUgdW5jaGFuZ2VkIGlmIHRoZSBrZXkgd2FzIGFscmVhZHkgcHJlc2VudC4gKilcbiAgdmFsIGFkZCA6ICgnYSwgJ2IpIHQgLT4ga2V5OidhIGtleSAtPiBkYXRhOidiIC0+IFsgYE9rIHwgYER1cGxpY2F0ZSBdXG5cbiAgdmFsIGFkZF9leG4gOiAoJ2EsICdiKSB0IC0+IGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiB1bml0XG5cbiAgKCoqIFtjaGFuZ2UgdCBrZXkgfmZdIGNoYW5nZXMgW3RdJ3MgdmFsdWUgZm9yIFtrZXldIHRvIGJlIFtmIChmaW5kIHQga2V5KV0uICopXG4gIHZhbCBjaGFuZ2UgOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiBmOignYiBvcHRpb24gLT4gJ2Igb3B0aW9uKSAtPiB1bml0XG5cbiAgKCoqIFt1cGRhdGUgdCBrZXkgfmZdIGlzIFtjaGFuZ2UgdCBrZXkgfmY6KGZ1biBvIC0+IFNvbWUgKGYgbykpXS4gKilcbiAgdmFsIHVwZGF0ZSA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+IGY6KCdiIG9wdGlvbiAtPiAnYikgLT4gdW5pdFxuXG4gICgqKiBbdXBkYXRlX2FuZF9yZXR1cm4gdCBrZXkgfmZdIGlzIFt1cGRhdGVdLCBidXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIFtmIG9dLiAqKVxuICB2YWwgdXBkYXRlX2FuZF9yZXR1cm4gOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiBmOignYiBvcHRpb24gLT4gJ2IpIC0+ICdiXG5cbiAgKCoqIFttYXAgdCBmXSByZXR1cm5zIGEgbmV3IHRhYmxlIHdpdGggdmFsdWVzIHJlcGxhY2VkIGJ5IHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgW2ZdXG4gICAgICB0byB0aGUgY3VycmVudCB2YWx1ZXMuXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICBsZXQgaCA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgSW50KSBbKDEsIDQpOyAoNSwgNildIGluXG4gICAgICBsZXQgaCcgPSBIYXNodGJsLm1hcCBoIH5mOihsb2NhbF8gKGZ1biB4IC0+IHggKiAyKSkgaW5cbiAgICAgIEhhc2h0YmwudG9fYWxpc3QgaCc7O1xuICAgICAgLSA6IChpbnQgKiBpbnQpIGxpc3QgPSBbKDUsIDEyKTsgKDEsIDgpXVxuICAgICAgdn0gKilcbiAgdmFsIG1hcCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gJ2MpIC0+ICgnYSwgJ2MpIHRcblxuICAoKiogTGlrZSBbbWFwXSwgYnV0IHRoZSBmdW5jdGlvbiBbZl0gdGFrZXMgYm90aCBrZXkgYW5kIGRhdGEgYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgbWFwaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdjKSAtPiAoJ2EsICdjKSB0XG5cbiAgKCoqIFJldHVybnMgYSBuZXcgdGFibGUgYnkgZmlsdGVyaW5nIHRoZSBnaXZlbiB0YWJsZSdzIHZhbHVlcyBieSBbZl06IHRoZSBrZXlzIGZvciB3aGljaFxuICAgICAgW2ZdIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgdmFsdWUgcmV0dXJucyBbU29tZV0gYXJlIGtlcHQsIGFuZCB0aG9zZSBmb3Igd2hpY2ggaXRcbiAgICAgIHJldHVybnMgW05vbmVdIGFyZSBkaXNjYXJkZWQuXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICBsZXQgaCA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgSW50KSBbKDEsIDQpOyAoNSwgNildIGluXG4gICAgICBIYXNodGJsLmZpbHRlcl9tYXAgaCB+ZjoobG9jYWxfIChmdW4geCAtPiBpZiB4ID4gNSB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpKVxuICAgICAgfD4gSGFzaHRibC50b19hbGlzdDs7XG4gICAgICAtIDogKGludCAqIGludCkgbGlzdCA9IFsoNSwgNildXG4gICAgICB2fSAqKVxuICB2YWwgZmlsdGVyX21hcCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gJ2Mgb3B0aW9uKSAtPiAoJ2EsICdjKSB0XG5cbiAgKCoqIExpa2UgW2ZpbHRlcl9tYXBdLCBidXQgdGhlIGZ1bmN0aW9uIFtmXSB0YWtlcyBib3RoIGtleSBhbmQgZGF0YSBhcyBhcmd1bWVudHMuICopXG4gIHZhbCBmaWx0ZXJfbWFwaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdjIG9wdGlvbikgLT4gKCdhLCAnYykgdFxuXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICgnYSwgJ2IpIHQgLT4gZjooJ2Ega2V5IC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIGZpbHRlciA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdFxuICB2YWwgZmlsdGVyaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHRcblxuICAoKiogUmV0dXJucyBuZXcgdGFibGVzIHdpdGggYm91bmQgdmFsdWVzIHBhcnRpdGlvbmVkIGJ5IFtmXSBhcHBsaWVkIHRvIHRoZSBib3VuZFxuICAgICAgdmFsdWVzLiAqKVxuICB2YWwgcGFydGl0aW9uX21hcCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpIC0+ICgnYSwgJ2MpIHQgKiAoJ2EsICdkKSB0XG5cbiAgKCoqIExpa2UgW3BhcnRpdGlvbl9tYXBdLCBidXQgdGhlIGZ1bmN0aW9uIFtmXSB0YWtlcyBib3RoIGtleSBhbmQgZGF0YSBhcyBhcmd1bWVudHMuICopXG4gIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYykgdCAqICgnYSwgJ2QpIHRcblxuICAoKiogUmV0dXJucyBhIHBhaXIgb2YgdGFibGVzIFsodDEsIHQyKV0sIHdoZXJlIFt0MV0gY29udGFpbnMgYWxsIHRoZSBlbGVtZW50cyBvZiB0aGVcbiAgICAgIGluaXRpYWwgdGFibGUgd2hpY2ggc2F0aXNmeSB0aGUgcHJlZGljYXRlIFtmXSwgYW5kIFt0Ml0gY29udGFpbnMgdGhlIHJlc3QuICopXG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHQgKiAoJ2EsICdiKSB0XG5cbiAgKCoqIExpa2UgW3BhcnRpdGlvbl90Zl0sIGJ1dCB0aGUgZnVuY3Rpb24gW2ZdIHRha2VzIGJvdGgga2V5IGFuZCBkYXRhIGFzIGFyZ3VtZW50cy4gKilcbiAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYikgdCAqICgnYSwgJ2IpIHRcblxuICAoKiogW2ZpbmRfb3JfYWRkIHQgayB+ZGVmYXVsdF0gcmV0dXJucyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGgga2V5IFtrXSBpZiBpdCBpcyBpbiB0aGVcbiAgICAgIHRhYmxlIFt0XSwgYW5kIG90aGVyd2lzZSBhc3NpZ25zIFtrXSB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgW2RlZmF1bHQgKCldLiAqKVxuICB2YWwgZmluZF9vcl9hZGQgOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiBkZWZhdWx0Oih1bml0IC0+ICdiKSAtPiAnYlxuXG4gICgqKiBMaWtlIFtmaW5kX29yX2FkZF0gYnV0IFtkZWZhdWx0XSB0YWtlcyB0aGUga2V5IGFzIGFuIGFyZ3VtZW50LiAqKVxuICB2YWwgZmluZGlfb3JfYWRkIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gZGVmYXVsdDooJ2Ega2V5IC0+ICdiKSAtPiAnYlxuXG4gICgqKiBbZmluZCB0IGtdIHJldHVybnMgW1NvbWVdICh0aGUgY3VycmVudCBiaW5kaW5nKSBvZiBba10gaW4gW3RdLCBvciBbTm9uZV0gaWYgbm8gc3VjaFxuICAgICAgYmluZGluZyBleGlzdHMuICopXG4gIHZhbCBmaW5kIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gJ2Igb3B0aW9uXG5cbiAgKCoqIFtmaW5kX2V4biB0IGtdIHJldHVybnMgdGhlIGN1cnJlbnQgYmluZGluZyBvZiBba10gaW4gW3RdLCBvciByYWlzZXMgW1N0ZGxpYi5Ob3RfZm91bmRdXG4gICAgICBvciBbTm90X2ZvdW5kX3NdIGlmIG5vIHN1Y2ggYmluZGluZyBleGlzdHMuICopXG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+ICdiXG5cbiAgKCoqIFtmaW5kX2FuZF9jYWxsIHQgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZF1cblxuICAgICAgaXMgZXF1aXZhbGVudCB0bzpcblxuICAgICAgW21hdGNoIGZpbmQgdCBrIHdpdGggU29tZSB2IC0+IGlmX2ZvdW5kIHYgfCBOb25lIC0+IGlmX25vdF9mb3VuZCBrXVxuXG4gICAgICBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFsbG9jYXRlIHRoZSBvcHRpb24uICopXG4gIHZhbCBmaW5kX2FuZF9jYWxsXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICdhIGtleVxuICAgIC0+IGlmX2ZvdW5kOignYiAtPiAnYylcbiAgICAtPiBpZl9ub3RfZm91bmQ6KCdhIGtleSAtPiAnYylcbiAgICAtPiAnY1xuXG4gICgqKiBKdXN0IGxpa2UgW2ZpbmRfYW5kX2NhbGxdLCBidXQgdGFrZXMgYW4gZXh0cmEgYXJndW1lbnQgd2hpY2ggaXMgcGFzc2VkIHRvIFtpZl9mb3VuZF1cbiAgICAgIGFuZCBbaWZfbm90X2ZvdW5kXSwgc28gdGhhdCB0aGUgY2xpZW50IGNvZGUgY2FuIGF2b2lkIGFsbG9jYXRpbmcgY2xvc3VyZXMgb3IgdXNpbmdcbiAgICAgIHJlZnMgdG8gcGFzcyB0aGlzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uICBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZnVsIGluIGNvZGVcbiAgICAgIHdoaWNoIHRyaWVzIHRvIG1pbmltaXplIGhlYXAgYWxsb2NhdGlvbi4gKilcbiAgdmFsIGZpbmRfYW5kX2NhbGwxXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICdhIGtleVxuICAgIC0+IGE6J2RcbiAgICAtPiBpZl9mb3VuZDooJ2IgLT4gJ2QgLT4gJ2MpXG4gICAgLT4gaWZfbm90X2ZvdW5kOignYSBrZXkgLT4gJ2QgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgZmluZF9hbmRfY2FsbDJcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gJ2Ega2V5XG4gICAgLT4gYTonZFxuICAgIC0+IGI6J2VcbiAgICAtPiBpZl9mb3VuZDooJ2IgLT4gJ2QgLT4gJ2UgLT4gJ2MpXG4gICAgLT4gaWZfbm90X2ZvdW5kOignYSBrZXkgLT4gJ2QgLT4gJ2UgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgZmluZGlfYW5kX2NhbGxcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gJ2Ega2V5XG4gICAgLT4gaWZfZm91bmQ6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnYylcbiAgICAtPiBpZl9ub3RfZm91bmQ6KCdhIGtleSAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBmaW5kaV9hbmRfY2FsbDFcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gJ2Ega2V5XG4gICAgLT4gYTonZFxuICAgIC0+IGlmX2ZvdW5kOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2QgLT4gJ2MpXG4gICAgLT4gaWZfbm90X2ZvdW5kOignYSBrZXkgLT4gJ2QgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgZmluZGlfYW5kX2NhbGwyXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICdhIGtleVxuICAgIC0+IGE6J2RcbiAgICAtPiBiOidlXG4gICAgLT4gaWZfZm91bmQ6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnZCAtPiAnZSAtPiAnYylcbiAgICAtPiBpZl9ub3RfZm91bmQ6KCdhIGtleSAtPiAnZCAtPiAnZSAtPiAnYylcbiAgICAtPiAnY1xuXG4gICgqKiBbZmluZF9hbmRfcmVtb3ZlIHQga10gcmV0dXJucyBTb21lICh0aGUgY3VycmVudCBiaW5kaW5nKSBvZiBrIGluIHQgYW5kIHJlbW92ZXMgaXQsXG4gICAgICBvciBOb25lIGlzIG5vIHN1Y2ggYmluZGluZyBleGlzdHMuICopXG4gIHZhbCBmaW5kX2FuZF9yZW1vdmUgOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiAnYiBvcHRpb25cblxuICAoKiogTWVyZ2VzIHR3byBoYXNodGFibGVzLlxuXG4gICAgICBUaGUgcmVzdWx0IG9mIFttZXJnZSBmIGgxIGgyXSBoYXMgYXMga2V5cyB0aGUgc2V0IG9mIGFsbCBba10gaW4gdGhlIHVuaW9uIG9mIHRoZVxuICAgICAgc2V0cyBvZiBrZXlzIG9mIFtoMV0gYW5kIFtoMl0gZm9yIHdoaWNoIFtkKGspXSBpcyBub3QgTm9uZSwgd2hlcmU6XG5cbiAgICAgIGQoaykgPVxuICAgICAgLSBbZiB+a2V5OmsgKGBMZWZ0IGQxKV1cbiAgICAgICAgaWYgW2tdIGluIFtoMV0gbWFwcyB0byBkMSwgYW5kIFtoMl0gZG9lcyBub3QgaGF2ZSBkYXRhIGZvciBba107XG5cbiAgICAgIC0gW2YgfmtleTprIChgUmlnaHQgZDIpXVxuICAgICAgICBpZiBba10gaW4gW2gyXSBtYXBzIHRvIGQyLCBhbmQgW2gxXSBkb2VzIG5vdCBoYXZlIGRhdGEgZm9yIFtrXTtcblxuICAgICAgLSBbZiB+a2V5OmsgKGBCb3RoIChkMSwgZDIpKV1cbiAgICAgICAgb3RoZXJ3aXNlLCB3aGVyZSBba10gaW4gW2gxXSBtYXBzIHRvIFtkMV0gYW5kIFtrXSBpbiBbaDJdIG1hcHMgdG8gW2QyXS5cblxuICAgICAgRWFjaCBrZXkgW2tdIGlzIG1hcHBlZCB0byBhIHNpbmdsZSBwaWVjZSBvZiBkYXRhIFt4XSwgd2hlcmUgW2QoaykgPSBTb21lIHhdLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgbGV0IGgxID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBJbnQpIFsoMSwgNSk7ICgyLCAzMjMyKV0gaW5cbiAgICAgIGxldCBoMiA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgSW50KSBbKDEsIDMpXSBpblxuICAgICAgSGFzaHRibC5tZXJnZSBoMSBoMiB+ZjooZnVuIH5rZXk6XyAtPiBmdW5jdGlvblxuICAgICAgICB8IGBMZWZ0IHggLT4gU29tZSAoYExlZnQgeClcbiAgICAgICAgfCBgUmlnaHQgeCAtPiBTb21lIChgUmlnaHQgeClcbiAgICAgICAgfCBgQm90aCAoeCwgeSkgLT4gaWYgeD15IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGBCb3RoICh4LHkpKVxuICAgICAgKSB8PiBIYXNodGJsLnRvX2FsaXN0OztcbiAgICAgIC0gOiAoaW50ICogWz4gYEJvdGggb2YgaW50ICogaW50IHwgYExlZnQgb2YgaW50IHwgYFJpZ2h0IG9mIGludCBdKSBsaXN0ID1cbiAgICAgIFsoMiwgYExlZnQgMzIzMik7ICgxLCBgQm90aCAoNSwgMykpXVxuICAgICAgdn0gKilcbiAgdmFsIG1lcmdlXG4gICAgOiAgKCdrLCAnYSkgdFxuICAgIC0+ICgnaywgJ2IpIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IFsgYExlZnQgb2YgJ2EgfCBgUmlnaHQgb2YgJ2IgfCBgQm90aCBvZiAnYSAqICdiIF0gLT4gJ2Mgb3B0aW9uKVxuICAgIC0+ICgnaywgJ2MpIHRcblxuICAoKiogRXZlcnkgW2tleV0gaW4gW3NyY10gd2lsbCBiZSByZW1vdmVkIG9yIHNldCBpbiBbZHN0XSBhY2NvcmRpbmcgdG8gdGhlIHJldHVybiB2YWx1ZVxuICAgICAgb2YgW2ZdLiAqKVxuICB2YWwgbWVyZ2VfaW50b1xuICAgIDogIHNyYzooJ2ssICdhKSB0XG4gICAgLT4gZHN0OignaywgJ2IpIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+ICdhIC0+ICdiIG9wdGlvbiAtPiAnYiBEaWN0aW9uYXJ5X211dGFibGUuTWVyZ2VfaW50b19hY3Rpb24udClcbiAgICAtPiB1bml0XG5cbiAgKCoqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIGtleXMgZm9yIGdpdmVuIGhhc2h0YWJsZS4gKilcbiAgdmFsIGtleXMgOiAoJ2EsIF8pIHQgLT4gJ2Ega2V5IGxpc3RcblxuICAoKiogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwgZGF0YSBmb3IgZ2l2ZW4gaGFzaHRhYmxlLiAqKVxuICB2YWwgZGF0YSA6IChfLCAnYikgdCAtPiAnYiBsaXN0XG5cbiAgKCoqIFtmaWx0ZXJfaW5wbGFjZSB0IH5mXSByZW1vdmVzIGFsbCB0aGUgZWxlbWVudHMgZnJvbSBbdF0gdGhhdCBkb24ndCBzYXRpc2Z5IFtmXS4gKilcbiAgdmFsIGZpbHRlcl9rZXlzX2lucGxhY2UgOiAoJ2EsIF8pIHQgLT4gZjooJ2Ega2V5IC0+IGJvb2wpIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyX2lucGxhY2UgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gdW5pdFxuICB2YWwgZmlsdGVyaV9pbnBsYWNlIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gdW5pdFxuXG4gICgqKiBbbWFwX2lucGxhY2UgdCB+Zl0gYXBwbGllcyBbZl0gdG8gYWxsIGVsZW1lbnRzIGluIFt0XSwgdHJhbnNmb3JtaW5nIHRoZW0gaW5cbiAgICAgIHBsYWNlLiAqKVxuICB2YWwgbWFwX2lucGxhY2UgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gJ2IpIC0+IHVuaXRcblxuICB2YWwgbWFwaV9pbnBsYWNlIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2IpIC0+IHVuaXRcblxuICAoKiogW2ZpbHRlcl9tYXBfaW5wbGFjZV0gY29tYmluZXMgdGhlIGVmZmVjdHMgb2YgW21hcF9pbnBsYWNlXSBhbmQgW2ZpbHRlcl9pbnBsYWNlXS4gKilcbiAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZSA6IChfLCAnYikgdCAtPiBmOignYiAtPiAnYiBvcHRpb24pIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyX21hcGlfaW5wbGFjZSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdiIG9wdGlvbikgLT4gdW5pdFxuXG4gICgqKiBbZXF1YWwgZiB0MSB0Ml0gYW5kIFtzaW1pbGFyIGYgdDEgdDJdIGJvdGggcmV0dXJuIHRydWUgaWZmIFt0MV0gYW5kIFt0Ml0gaGF2ZSB0aGVcbiAgICAgIHNhbWUga2V5cyBhbmQgZm9yIGFsbCBrZXlzIFtrXSwgW2YgKGZpbmRfZXhuIHQxIGspIChmaW5kX2V4biB0MiBrKV0uICBbZXF1YWxdIGFuZFxuICAgICAgW3NpbWlsYXJdIG9ubHkgZGlmZmVyIGluIHRoZWlyIHR5cGVzLiAqKVxuICB2YWwgZXF1YWwgOiAoJ2IgLT4gJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGJvb2xcblxuICB2YWwgc2ltaWxhciA6ICgnYjEgLT4gJ2IyIC0+IGJvb2wpIC0+ICgnYSwgJ2IxKSB0IC0+ICgnYSwgJ2IyKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwgKGtleSwgZGF0YSkgcGFpcnMgZm9yIGdpdmVuIGhhc2h0YWJsZS4gKilcbiAgdmFsIHRvX2FsaXN0IDogKCdhLCAnYikgdCAtPiAoJ2Ega2V5ICogJ2IpIGxpc3RcblxuICAoKiogW3JlbW92ZV9pZl96ZXJvXSdzIGRlZmF1bHQgaXMgW2ZhbHNlXS4gKilcbiAgdmFsIGluY3IgOiA/Ynk6aW50IC0+ID9yZW1vdmVfaWZfemVybzpib29sIC0+ICgnYSwgaW50KSB0IC0+ICdhIGtleSAtPiB1bml0XG5cbiAgdmFsIGRlY3IgOiA/Ynk6aW50IC0+ID9yZW1vdmVfaWZfemVybzpib29sIC0+ICgnYSwgaW50KSB0IC0+ICdhIGtleSAtPiB1bml0XG5lbmRcblxubW9kdWxlIHR5cGUgTXVsdGkgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgJ2Ega2V5XG5cbiAgKCoqIFthZGRfbXVsdGkgdCB+a2V5IH5kYXRhXSBpZiBba2V5XSBpcyBwcmVzZW50IGluIHRoZSB0YWJsZSB0aGVuIGNvbnNcbiAgICAgIFtkYXRhXSBvbiB0aGUgbGlzdCwgb3RoZXJ3aXNlIGFkZCBba2V5XSB3aXRoIGEgc2luZ2xlIGVsZW1lbnQgbGlzdC4gKilcbiAgdmFsIGFkZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCkgdCAtPiBrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gdW5pdFxuXG4gICgqKiBbcmVtb3ZlX211bHRpIHQga2V5XSB1cGRhdGVzIHRoZSB0YWJsZSwgcmVtb3ZpbmcgdGhlIGhlYWQgb2YgdGhlIGxpc3QgYm91bmQgdG9cbiAgICAgIFtrZXldLiBJZiB0aGUgbGlzdCBoYXMgb25seSBvbmUgZWxlbWVudCAob3IgaXMgZW1wdHkpIHRoZW4gdGhlIGJpbmRpbmcgaXNcbiAgICAgIHJlbW92ZWQuICopXG4gIHZhbCByZW1vdmVfbXVsdGkgOiAoJ2EsIF8gbGlzdCkgdCAtPiAnYSBrZXkgLT4gdW5pdFxuXG4gICgqKiBbZmluZF9tdWx0aSB0IGtleV0gcmV0dXJucyB0aGUgZW1wdHkgbGlzdCBpZiBba2V5XSBpcyBub3QgcHJlc2VudCBpbiB0aGUgdGFibGUsXG4gICAgICByZXR1cm5zIFt0XSdzIHZhbHVlcyBmb3IgW2tleV0gb3RoZXJ3aXNlLiAqKVxuICB2YWwgZmluZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCkgdCAtPiAnYSBrZXkgLT4gJ2IgbGlzdFxuZW5kXG5cbnR5cGUgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnMgPVxuICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAtPiAna2V5IEtleS50XG4gIC0+ICd6XG5cbnR5cGUgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGUgPVxuICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAtPiAnelxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICdhIGtleVxuICB0eXBlICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zXG5cbiAgKCoqIEBpbmxpbmUgKilcbiAgaW5jbHVkZVxuICAgIERpY3Rpb25hcnlfbXV0YWJsZS5DcmVhdG9yc1xuICAgICAgd2l0aCB0eXBlICdrZXkga2V5IDo9ICdrZXkga2V5XG4gICAgICAgYW5kIHR5cGUgKCdrZXksICdkYXRhLCBfKSB0IDo9ICgna2V5LCAnZGF0YSkgdFxuICAgICAgIGFuZCB0eXBlICgnZm4sICdrZXksICdkYXRhLCBfKSBjcmVhdG9yIDo9ICgna2V5IGtleSwgJ2RhdGEsICdmbikgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgY3JlYXRlIDogKCdhIGtleSwgJ2IsIHVuaXQgLT4gKCdhLCAnYikgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICggJ2Ega2V5XG4gICAgICAsICdiXG4gICAgICAsICgnYSBrZXkgKiAnYikgbGlzdCAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2Ega2V5IF0gKVxuICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzXG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnYlxuICAgICAgLCAoJ2Ega2V5ICogJ2IpIGxpc3QgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAnYSBrZXkgbGlzdCBdIClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X29yX2Vycm9yXG4gICAgOiAoJ2Ega2V5LCAnYiwgKCdhIGtleSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfZXhuIDogKCdhIGtleSwgJ2IsICgnYSBrZXkgKiAnYikgbGlzdCAtPiAoJ2EsICdiKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogKCdhIGtleSwgJ2IgbGlzdCwgKCdhIGtleSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IgbGlzdCkgdCkgY3JlYXRlX29wdGlvbnNcblxuICAoKioge1sgY3JlYXRlX21hcHBlZCBnZXRfa2V5IGdldF9kYXRhIFt4MSwuLi4seG5dXG4gICAgICAgICA9IG9mX2FsaXN0IFtnZXRfa2V5IHgxLCBnZXRfZGF0YSB4MTsgLi4uOyBnZXRfa2V5IHhuLCBnZXRfZGF0YSB4bl0gXX0gKilcbiAgdmFsIGNyZWF0ZV9tYXBwZWRcbiAgICA6ICggJ2Ega2V5XG4gICAgICAsICdiXG4gICAgICAsIGdldF9rZXk6KCdyIC0+ICdhIGtleSlcbiAgICAgICAgLT4gZ2V0X2RhdGE6KCdyIC0+ICdiKVxuICAgICAgICAtPiAnciBsaXN0XG4gICAgICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2Ega2V5IGxpc3QgXSApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gICgqKiB7WyBjcmVhdGVfd2l0aF9rZXkgfmdldF9rZXkgW3gxLC4uLix4bl1cbiAgICAgICAgID0gb2ZfYWxpc3QgW2dldF9rZXkgeDEsIHgxOyAuLi47IGdldF9rZXkgeG4sIHhuXSBdfSAqKVxuICB2YWwgY3JlYXRlX3dpdGhfa2V5XG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnclxuICAgICAgLCBnZXRfa2V5OignciAtPiAnYSBrZXkpXG4gICAgICAgIC0+ICdyIGxpc3RcbiAgICAgICAgLT4gWyBgT2sgb2YgKCdhLCAncikgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAnYSBrZXkgbGlzdCBdIClcbiAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvclxuICAgIDogKCAnYSBrZXlcbiAgICAgICwgJ3JcbiAgICAgICwgZ2V0X2tleTooJ3IgLT4gJ2Ega2V5KSAtPiAnciBsaXN0IC0+ICgnYSwgJ3IpIHQgT3JfZXJyb3IudCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBjcmVhdGVfd2l0aF9rZXlfZXhuXG4gICAgOiAoJ2Ega2V5LCAnciwgZ2V0X2tleTooJ3IgLT4gJ2Ega2V5KSAtPiAnciBsaXN0IC0+ICgnYSwgJ3IpIHQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIGdyb3VwXG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnYlxuICAgICAgLCBnZXRfa2V5OignciAtPiAnYSBrZXkpXG4gICAgICAgIC0+IGdldF9kYXRhOignciAtPiAnYilcbiAgICAgICAgLT4gY29tYmluZTooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgICAgIC0+ICdyIGxpc3RcbiAgICAgICAgLT4gKCdhLCAnYikgdCApXG4gICAgICBjcmVhdGVfb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuXG4gICgqKiB7MiBDcmVhdG9yc30gKilcblxuICAoKiogVGhlIG1vZHVsZSB5b3UgcGFzcyB0byBbY3JlYXRlXSBtdXN0IGhhdmUgYSB0eXBlIHRoYXQgaXMgaGFzaGFibGUsIHNleHBhYmxlLCBhbmRcbiAgICAgIGNvbXBhcmFibGUuXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICAgIEhhc2h0YmwuY3JlYXRlIChtb2R1bGUgSW50KTs7XG4gICAgICAgIC0gOiAoaW50LCAnX2EpIEhhc2h0YmwudCA9IDxhYnN0cj47O1xuICAgICAgdn0gKilcbiAgdmFsIGNyZWF0ZVxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+ICgnYSwgJ2IpIHRcblxuICAoKiogRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgICAgIEhhc2h0Ymwub2ZfYWxpc3QgKG1vZHVsZSBJbnQpIFsoMywgXCJzb21ldGhpbmdcIik7ICgyLCBcIndoYXRldmVyXCIpXVxuICAgICAgICAgLSA6IFsgYER1cGxpY2F0ZV9rZXkgb2YgaW50IHwgYE9rIG9mIChpbnQsIHN0cmluZykgSGFzaHRibC50IF0gPSBgT2sgPGFic3RyPlxuICAgICAgdn0gKilcbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gICgqKiBXaGVyZWFzIFtvZl9hbGlzdF0gd2lsbCByZXBvcnQgW0R1cGxpY2F0ZV9rZXldIG5vIG1hdHRlciBob3cgbWFueSBkdXBzIHRoZXJlIGFyZSBpblxuICAgICAgeW91ciBsaXN0LCBbb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzXSB3aWxsIHJlcG9ydCBlYWNoIGFuZCBldmVyeSBkdXBsaWNhdGUgZW50cnkuXG5cbiAgICAgIEZvciBleGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgICBIYXNodGJsLm9mX2FsaXN0IChtb2R1bGUgSW50KSBbKDEsIFwiZm9vXCIpOyAoMSwgXCJiYXJcIik7ICgyLCBcImZvb1wiKTsgKDIsIFwiYmFyXCIpXTs7XG4gICAgICAgIC0gOiBbIGBEdXBsaWNhdGVfa2V5IG9mIGludCB8IGBPayBvZiAoaW50LCBzdHJpbmcpIEhhc2h0YmwudCBdID0gYER1cGxpY2F0ZV9rZXkgMVxuXG4gICAgICAgIEhhc2h0Ymwub2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzIChtb2R1bGUgSW50KSBbKDEsIFwiZm9vXCIpOyAoMSwgXCJiYXJcIik7ICgyLCBcImZvb1wiKTsgKDIsIFwiYmFyXCIpXTs7XG4gICAgICAgIC0gOiBbIGBEdXBsaWNhdGVfa2V5cyBvZiBpbnQgbGlzdCB8IGBPayBvZiAoaW50LCBzdHJpbmcpIEhhc2h0YmwudCBdID0gYER1cGxpY2F0ZV9rZXlzIFsxOyAyXVxuICAgICAgdn0gKilcbiAgdmFsIG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwc1xuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAnYSBsaXN0IF1cblxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBvZl9hbGlzdF9leG5cbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IpIHRcblxuICAoKiogQ3JlYXRlcyBhIHt7IU11bHRpfSBcIm11bHRpXCJ9IGhhc2h0YWJsZSwgaS5lLiwgYSBoYXNodGFibGUgd2hlcmUgZWFjaCBrZXkgcG9pbnRzIHRvIGFcbiAgICAgIGxpc3QgcG90ZW50aWFsbHkgY29udGFpbmluZyBtdWx0aXBsZSB2YWx1ZXMuIFNvIGluc3RlYWQgb2Ygc2hvcnQtY2lyY3VpdGluZyB3aXRoIGFcbiAgICAgIFtgRHVwbGljYXRlX2tleV0gdmFyaWFudCBvbiBkdXBsaWNhdGVzLCBhcyBpbiBbb2ZfYWxpc3RdLCBbb2ZfYWxpc3RfbXVsdGldIGZvbGRzXG4gICAgICB0aG9zZSB2YWx1ZXMgaW50byBhIGxpc3QgZm9yIHRoZSBnaXZlbiBrZXk6XG5cbiAgICAgIHt2XG4gICAgICBsZXQgaCA9IEhhc2h0Ymwub2ZfYWxpc3RfbXVsdGkgKG1vZHVsZSBJbnQpIFsoMSwgXCJhXCIpOyAoMSwgXCJiXCIpOyAoMiwgXCJjXCIpOyAoMiwgXCJkXCIpXTs7XG4gICAgICB2YWwgaCA6IChpbnQsIHN0cmluZyBsaXN0KSBIYXNodGJsLnQgPSA8YWJzdHI+XG5cbiAgICAgIEhhc2h0YmwuZmluZF9leG4gaCAxOztcbiAgICAgIC0gOiBzdHJpbmcgbGlzdCA9IFtcImJcIjsgXCJhXCJdXG4gICAgICB2fSAqKVxuICB2YWwgb2ZfYWxpc3RfbXVsdGlcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IgbGlzdCkgdFxuXG4gICgqKiBBcHBsaWVzIHRoZSBbZ2V0X2tleV0gYW5kIFtnZXRfZGF0YV0gZnVuY3Rpb25zIHRvIHRoZSBbJ3IgbGlzdF0gdG8gY3JlYXRlIHRoZVxuICAgICAgaW5pdGlhbCBrZXlzIGFuZCB2YWx1ZXMsIHJlc3BlY3RpdmVseSwgZm9yIHRoZSBuZXcgaGFzaHRhYmxlLlxuXG4gICAgICB7WyBjcmVhdGVfbWFwcGVkIGdldF9rZXkgZ2V0X2RhdGEgW3gxOy4uLjt4bl1cbiAgICAgICAgID0gb2ZfYWxpc3QgW2dldF9rZXkgeDEsIGdldF9kYXRhIHgxOyAuLi47IGdldF9rZXkgeG4sIGdldF9kYXRhIHhuXVxuICAgICAgXX1cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgICAgbGV0IGggPVxuICAgICAgICAgIEhhc2h0YmwuY3JlYXRlX21hcHBlZCAobW9kdWxlIEludClcbiAgICAgICAgICAgIH5nZXRfa2V5Oihsb2NhbF8gKGZ1biB4IC0+IHgpKVxuICAgICAgICAgICAgfmdldF9kYXRhOihsb2NhbF8gKGZ1biB4IC0+IHggKyAxKSlcbiAgICAgICAgICAgWzE7IDI7IDNdOztcbiAgICAgICAgdmFsIGggOiBbIGBEdXBsaWNhdGVfa2V5cyBvZiBpbnQgbGlzdCB8IGBPayBvZiAoaW50LCBpbnQpIEhhc2h0YmwudCBdID0gYE9rIDxhYnN0cj5cblxuICAgICAgICBsZXQgaCA9XG4gICAgICAgICAgbWF0Y2ggaCB3aXRoXG4gICAgICAgICAgfCBgT2sgeCAtPiB4XG4gICAgICAgICAgfCBgRHVwbGljYXRlX2tleXMgXyAtPiBmYWlsd2l0aCBcIlwiXG4gICAgICAgIGluXG4gICAgICAgIEhhc2h0YmwuZmluZF9leG4gaCAxOztcbiAgICAgICAgLSA6IGludCA9IDJcbiAgICAgIHZ9ICopXG4gIHZhbCBjcmVhdGVfbWFwcGVkXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gZ2V0X2tleTooJ3IgLT4gJ2EpXG4gICAgLT4gZ2V0X2RhdGE6KCdyIC0+ICdiKVxuICAgIC0+ICdyIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXlzIG9mICdhIGxpc3QgXVxuXG4gICgqKiB7WyBjcmVhdGVfd2l0aF9rZXkgfmdldF9rZXkgW3gxOy4uLjt4bl1cbiAgICAgICAgID0gb2ZfYWxpc3QgW2dldF9rZXkgeDEsIHgxOyAuLi47IGdldF9rZXkgeG4sIHhuXSBdfSAqKVxuICB2YWwgY3JlYXRlX3dpdGhfa2V5XG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gZ2V0X2tleTooJ3IgLT4gJ2EpXG4gICAgLT4gJ3IgbGlzdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ3IpIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2EgbGlzdCBdXG5cbiAgdmFsIGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvclxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+IGdldF9rZXk6KCdyIC0+ICdhKVxuICAgIC0+ICdyIGxpc3RcbiAgICAtPiAoJ2EsICdyKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgY3JlYXRlX3dpdGhfa2V5X2V4blxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+IGdldF9rZXk6KCdyIC0+ICdhKVxuICAgIC0+ICdyIGxpc3RcbiAgICAtPiAoJ2EsICdyKSB0XG5cbiAgKCoqIExpa2UgW2NyZWF0ZV9tYXBwZWRdLCBhcHBsaWVzIHRoZSBbZ2V0X2tleV0gYW5kIFtnZXRfZGF0YV0gZnVuY3Rpb25zIHRvIHRoZSBbJ3JcbiAgICAgIGxpc3RdIHRvIGNyZWF0ZSB0aGUgaW5pdGlhbCBrZXlzIGFuZCB2YWx1ZXMsIHJlc3BlY3RpdmVseSwgZm9yIHRoZSBuZXcgaGFzaHRhYmxlIC0tXG4gICAgICBhbmQgdGhlbiwgbGlrZSBbYWRkX211bHRpXSwgZm9sZHMgdG9nZXRoZXIgdmFsdWVzIGJlbG9uZ2luZyB0byB0aGUgc2FtZSBrZXlzLiBIZXJlLFxuICAgICAgdGhvdWdoLCB0aGUgZnVuY3Rpb24gdXNlZCBmb3IgdGhlIGZvbGRpbmcgaXMgZ2l2ZW4gYnkgW2NvbWJpbmVdIChpbnN0ZWFkIG9mIGp1c3RcbiAgICAgIGJlaW5nIGEgW2NvbnNdKS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgICAgIEhhc2h0YmwuZ3JvdXAgKG1vZHVsZSBJbnQpXG4gICAgICAgICAgIH5nZXRfa2V5Oihsb2NhbF8gKGZ1biB4IC0+IHggLyAyKSlcbiAgICAgICAgICAgfmdldF9kYXRhOihsb2NhbF8gKGZ1biB4IC0+IHgpKVxuICAgICAgICAgICB+Y29tYmluZToobG9jYWxfIChmdW4geCB5IC0+IHggKiB5KSlcbiAgICAgICAgICAgIFsgMTsgMjsgMzsgNF1cbiAgICAgICAgIHw+IEhhc2h0YmwudG9fYWxpc3Q7O1xuICAgICAgICAgLSA6IChpbnQgKiBpbnQpIGxpc3QgPSBbKDIsIDQpOyAoMSwgNik7ICgwLCAxKV1cbiAgICAgICB2fSAqKVxuICB2YWwgZ3JvdXBcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiBnZXRfa2V5OignciAtPiAnYSlcbiAgICAtPiBnZXRfZGF0YTooJ3IgLT4gJ2IpXG4gICAgLT4gY29tYmluZTooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gJ3IgbGlzdFxuICAgIC0+ICgnYSwgJ2IpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3VibW9kdWxlcyA9IHNpZ1xuICB2YWwgaGFzaCA6ICdhIC0+IGludFxuICB2YWwgaGFzaF9wYXJhbSA6IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50XG5cbiAgdHlwZSAoISdhLCAhJ2IpIHRcblxuICAoKiogV2UgcHJvdmlkZSBhIFtzZXhwX29mX3RdIGJ1dCBub3QgYSBbdF9vZl9zZXhwXSBmb3IgdGhpcyB0eXBlIGJlY2F1c2Ugb25lIG5lZWRzIHRvIGJlXG4gICAgICBleHBsaWNpdCBhYm91dCB0aGUgaGFzaCBhbmQgY29tcGFyaXNvbiBmdW5jdGlvbnMgdXNlZCB3aGVuIGNyZWF0aW5nIGEgaGFzaHRhYmxlLlxuICAgICAgTm90ZSB0aGF0IFtIYXNodGJsLlBvbHkudF0gZG9lcyBoYXZlIFtbQEBkZXJpdmluZyBzZXhwXV0sIGFuZCB1c2VzIE9DYW1sJ3MgYnVpbHQtaW5cbiAgICAgIHBvbHltb3JwaGljIGNvbXBhcmlzb24gYW5kIGFuZCBwb2x5bW9ycGhpYyBoYXNoaW5nLiAqKVxuICB2YWwgc2V4cF9vZl90IDogKCdhIC0+IFNleHAudCkgLT4gKCdiIC0+IFNleHAudCkgLT4gKCdhLCAnYikgdCAtPiBTZXhwLnRcblxuICBpbmNsdWRlIENyZWF0b3JzIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgKCoqIEBpbmxpbmUgKilcblxuICBpbmNsdWRlIEFjY2Vzc29ycyB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0IHdpdGggdHlwZSAnYSBrZXkgPSAnYVxuICAoKiogQGlubGluZSAqKVxuXG4gIGluY2x1ZGUgTXVsdGkgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdCB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIGtleVxuICAoKiogQGlubGluZSAqKVxuXG4gIHZhbCBoYXNoYWJsZV9zIDogKCdrZXksIF8pIHQgLT4gJ2tleSBLZXkudFxuXG4gIGluY2x1ZGUgSW52YXJpYW50LlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX3BvbHkgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyXG4gICAgOiAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAtPiAnYiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgIC0+ICgnYSwgJ2IpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuXG4gIHZhbCBoYXNoYWJsZSA6ICdhIEhhc2hhYmxlLnRcblxuICBpbmNsdWRlIEludmFyaWFudC5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzX2dlbmVyaWNcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICAgIHdpdGggdHlwZSAnYSBrZXkgPSAnYVxuICAgICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zIDo9XG4gICAgICAgICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnMgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdCB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIGtleVxuICBpbmNsdWRlIE11bHRpIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBrZXlcbmVuZFxuXG5tb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBzaWdcbiAgdHlwZSAoJ2ssICd2KSB0XG5cbiAgbW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIEtleS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICAgIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG5cbiAgdmFsIHNleHBfb2ZfbV9fdFxuICAgIDogIChtb2R1bGUgU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gKCd2IC0+IFNleHAudClcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgLT4gU2V4cC50XG5cbiAgdmFsIG1fX3Rfb2Zfc2V4cFxuICAgIDogIChtb2R1bGUgTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gKFNleHAudCAtPiAndilcbiAgICAtPiBTZXhwLnRcbiAgICAtPiAoJ2ssICd2KSB0XG5cbiAgdmFsIG1fX3Rfc2V4cF9ncmFtbWFyXG4gICAgOiAgKG1vZHVsZSBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+ICd2IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgLT4gKCdrLCAndikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIHZhbCBlcXVhbF9tX190XG4gICAgOiAgKG1vZHVsZSBFcXVhbF9tKVxuICAgIC0+ICgndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YpIHRcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgLT4gYm9vbFxuZW5kXG5cbm1vZHVsZSB0eXBlIEhhc2h0YmwgPSBzaWdcbiAgKCoqIEEgaGFzaCB0YWJsZSBpcyBhIG11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgaW1wbGVtZW50aW5nIGEgbWFwIGJldHdlZW4ga2V5cyBhbmQgdmFsdWVzLlxuICAgICAgSXQgc3VwcG9ydHMgY29uc3RhbnQtdGltZSBsb29rdXAgYW5kIGluLXBsYWNlIG1vZGlmaWNhdGlvbi5cblxuICAgICAgezEgVXNhZ2V9XG5cbiAgICAgIEFzIGEgc2ltcGxlIGV4YW1wbGUsIHdlJ2xsIGNyZWF0ZSBhIGhhc2ggdGFibGUgd2l0aCBzdHJpbmcga2V5cyB1c2luZyB0aGVcbiAgICAgIHt7IWNyZWF0ZX1bY3JlYXRlXX0gY29uc3RydWN0b3IsIHdoaWNoIGV4cGVjdHMgYSBtb2R1bGUgZGVmaW5pbmcgdGhlIGtleSdzIHR5cGU6XG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBoID0gSGFzaHRibC5jcmVhdGUgKG1vZHVsZSBTdHJpbmcpOztcbiAgICAgICAgdmFsIGggOiAoc3RyaW5nLCAnX2EpIEhhc2h0YmwudCA9IDxhYnN0cj5cbiAgICAgIF19XG5cbiAgICAgIFdlIGNhbiBzZXQgdGhlIHZhbHVlcyBvZiBpbmRpdmlkdWFsIGtleXMgd2l0aCB7eyFzZXR9W3NldF19LiBJZiB0aGUga2V5IGFscmVhZHkgaGFzXG4gICAgICBhIHZhbHVlLCBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuXG4gICAgICB7dlxuICAgICAgSGFzaHRibC5zZXQgaCB+a2V5OlwiZm9vXCIgfmRhdGE6NTs7XG4gICAgICAtIDogdW5pdCA9ICgpXG5cbiAgICAgIEhhc2h0Ymwuc2V0IGggfmtleTpcImZvb1wiIH5kYXRhOjY7O1xuICAgICAgLSA6IHVuaXQgPSAoKVxuXG4gICAgICBIYXNodGJsLnNldCBoIH5rZXk6XCJiYXJcIiB+ZGF0YTo2OztcbiAgICAgIC0gOiB1bml0ID0gKClcbiAgICAgIHZ9XG5cbiAgICAgIFdlIGNhbiBhY2Nlc3MgdmFsdWVzIGJ5IGtleSwgb3IgZHVtcCBhbGwgb2YgdGhlIGhhc2ggdGFibGUncyBkYXRhOlxuXG4gICAgICB7dlxuICAgICAgSGFzaHRibC5maW5kIGggXCJmb29cIjs7XG4gICAgICAtIDogaW50IG9wdGlvbiA9IFNvbWUgNlxuXG4gICAgICBIYXNodGJsLmZpbmRfZXhuIGggXCJmb29cIjs7XG4gICAgICAtIDogaW50ID0gNlxuXG4gICAgICBIYXNodGJsLnRvX2FsaXN0IGg7O1xuICAgICAgLSA6IChzdHJpbmcgKiBpbnQpIGxpc3QgPSBbKFwiZm9vXCIsIDYpOyAoXCJiYXJcIiwgNildXG4gICAgICB2fVxuXG4gICAgICB7eyFjaGFuZ2V9W2NoYW5nZV19IGxldHMgdXMgY2hhbmdlIGEga2V5J3MgdmFsdWUgYnkgYXBwbHlpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uOlxuXG4gICAgICB7dlxuICAgICAgSGFzaHRibC5jaGFuZ2UgaCBcImZvb1wiIChmdW4geCAtPlxuICAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgIHwgU29tZSB4IC0+IFNvbWUgKHggKiAyKVxuICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICApOztcbiAgICAgIC0gOiB1bml0ID0gKClcblxuICAgICAgSGFzaHRibC50b19hbGlzdCBoOztcbiAgICAgIC0gOiAoc3RyaW5nICogaW50KSBsaXN0ID0gWyhcImZvb1wiLCAxMik7IChcImJhclwiLCA2KV1cbiAgICAgIHZ9XG5cblxuICAgICAgV2UgY2FuIHVzZSB7eyFtZXJnZX1bbWVyZ2VdfSB0byBtZXJnZSB0d28gaGFzaHRhYmxlcyB3aXRoIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcbiAgICAgIGhvdyB3ZSBjaG9vc2UgdmFsdWVzIHdoZW4gYSBrZXkgaXMgcHJlc2VudCBpbiB0aGUgZmlyc3QgKFwibGVmdFwiKSBoYXNodGFibGUsIHRoZVxuICAgICAgc2Vjb25kIChcInJpZ2h0XCIpLCBvciBib3RoLiBIZXJlLCB3ZSdsbCBjb25zIHRoZSB2YWx1ZXMgd2hlbiBib3RoIGhhc2h0YWJsZXMgaGF2ZSBhXG4gICAgICBrZXk6XG5cbiAgICAgIHt2XG4gICAgICBsZXQgaDEgPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCA1KTsgKDIsIDMyMzIpXSBpblxuICAgICAgbGV0IGgyID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBJbnQpIFsoMSwgMyldIGluXG4gICAgICBIYXNodGJsLm1lcmdlIGgxIGgyIH5mOihmdW4gfmtleTpfIC0+IGZ1bmN0aW9uXG4gICAgICAgIHwgYExlZnQgeCAtPiBTb21lIChgTGVmdCB4KVxuICAgICAgICB8IGBSaWdodCB4IC0+IFNvbWUgKGBSaWdodCB4KVxuICAgICAgICB8IGBCb3RoICh4LCB5KSAtPiBpZiB4PXkgdGhlbiBOb25lIGVsc2UgU29tZSAoYEJvdGggKHgseSkpXG4gICAgICApIHw+IEhhc2h0YmwudG9fYWxpc3Q7O1xuICAgICAgLSA6IChpbnQgKiBbPiBgQm90aCBvZiBpbnQgKiBpbnQgfCBgTGVmdCBvZiBpbnQgfCBgUmlnaHQgb2YgaW50IF0pIGxpc3QgPVxuICAgICAgWygyLCBgTGVmdCAzMjMyKTsgKDEsIGBCb3RoICg1LCAzKSldXG4gICAgICB2fVxuXG4gICAgICB7MSBJbnRlcmZhY2V9ICopXG5cbiAgaW5jbHVkZSBTX3dpdGhvdXRfc3VibW9kdWxlcyAoKiogQGlubGluZSAqKVxuXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29ycyA9IEFjY2Vzc29yc1xuICBtb2R1bGUgdHlwZSBDcmVhdG9ycyA9IENyZWF0b3JzXG4gIG1vZHVsZSB0eXBlIE11bHRpID0gTXVsdGlcbiAgbW9kdWxlIHR5cGUgU19wb2x5ID0gU19wb2x5XG4gIG1vZHVsZSB0eXBlIFNfd2l0aG91dF9zdWJtb2R1bGVzID0gU193aXRob3V0X3N1Ym1vZHVsZXNcbiAgbW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gRm9yX2Rlcml2aW5nXG5cbiAgbW9kdWxlIEtleSA9IEtleVxuICBtb2R1bGUgTWVyZ2VfaW50b19hY3Rpb24gPSBNZXJnZV9pbnRvX2FjdGlvblxuXG4gIHR5cGUgbm9ucmVjICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zID0gKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNcblxuICBtb2R1bGUgQ3JlYXRvcnMgKEtleSA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGhhc2hhYmxlIDogJ2EgdCBIYXNoYWJsZS50XG4gIGVuZCkgOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRfID0gKCdhIEtleS50LCAnYikgdFxuXG4gICAgdmFsIHRfb2Zfc2V4cCA6IChTZXhwLnQgLT4gJ2EgS2V5LnQpIC0+IChTZXhwLnQgLT4gJ2IpIC0+IFNleHAudCAtPiAoJ2EsICdiKSB0X1xuXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0X1xuICAgICAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIEtleS50XG4gICAgICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsICdhKSBjcmVhdGVfb3B0aW9ucyA6PVxuICAgICAgICAgICgna2V5LCAnZGF0YSwgJ2EpIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlXG4gIGVuZFxuXG4gIG1vZHVsZSBQb2x5IDogU19wb2x5IHdpdGggdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICgqKiBbTV0gaXMgbWVhbnQgdG8gYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIE9DYW1sIGFwcGxpY2F0aXZlIGZ1bmN0b3IgdHlwZXM6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3RvX2ludF90YWJsZSA9IGludCBIYXNodGJsLk0oU3RyaW5nKS50XG4gICAgICBdfVxuXG4gICAgICB3aGljaCBzdGFuZHMgZm9yOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ190b19pbnRfdGFibGUgPSAoU3RyaW5nLnQsIGludCkgSGFzaHRibC50XG4gICAgICBdfVxuXG4gICAgICBUaGUgcG9pbnQgaXMgdGhhdCBbaW50IEhhc2h0YmwuTShTdHJpbmcpLnRdIHN1cHBvcnRzIGRlcml2aW5nLCB3aGVyZWFzIHRoZSBzZWNvbmRcbiAgICAgIHN5bnRheCBkb2Vzbid0IChiZWNhdXNlIFt0X29mX3NleHBdIGRvZXNuJ3Qga25vdyB3aGF0IGNvbXBhcmlzb24vaGFzaCBmdW5jdGlvbiB0b1xuICAgICAgdXNlKS4gKilcbiAgbW9kdWxlIE0gKEsgOiBULlQpIDogc2lnXG4gICAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2KSB0XG4gIGVuZFxuXG4gIGluY2x1ZGUgRm9yX2Rlcml2aW5nIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAoKiovKiopXG5cbiAgKCpfIFNlZSB0aGUgSmFuZSBTdHJlZXQgU3R5bGUgR3VpZGUgZm9yIGFuIGV4cGxhbmF0aW9uIG9mIFtQcml2YXRlXSBzdWJtb2R1bGVzOlxuXG4gICAgaHR0cHM6Ly9vcGVuc291cmNlLmphbmVzdHJlZXQuY29tL3N0YW5kYXJkcy8jcHJpdmF0ZS1zdWJtb2R1bGVzICopXG4gIG1vZHVsZSBQcml2YXRlIDogc2lnXG4gICAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2dlbmVyaWNcblxuICAgIHR5cGUgbm9ucmVjICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlID1cbiAgICAgICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlXG5cbiAgICB2YWwgaGFzaGFibGUgOiAoJ2tleSwgXykgdCAtPiAna2V5IEhhc2hhYmxlLnRcbiAgZW5kXG5lbmRcbiIsIigqIEEgZmV3IHNtYWxsIHRoaW5ncyBjb3BpZWQgZnJvbSBvdGhlciBwYXJ0cyBvZiBCYXNlIGJlY2F1c2UgdGhleSBkZXBlbmQgb24gdXMsIHNvIHdlXG4gICBjYW4ndCB1c2UgdGhlbS4gKilcblxub3BlbiEgSW1wb3J0XG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5tb2R1bGUgSW50ID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbigqIEl0cyBpbXBvcnRhbnQgdGhhdCBFbXB0eSBoYXZlIG5vIGFyZ3MuIEl0J3MgdGVtcHRpbmcgdG8gbWFrZSB0aGlzIHR5cGUgYSByZWNvcmRcbiAgIChlLmcuIHRvIGhvbGQgdGhlIGNvbXBhcmUgZnVuY3Rpb24pLCBidXQgYSBsb3Qgb2YgbWVtb3J5IGlzIHNhdmVkIGJ5IEVtcHR5IGJlaW5nIGFuXG4gICBpbW1lZGlhdGUsIHNpbmNlIGFsbCB1bnVzZWQgYnVja2V0cyBpbiB0aGUgaGFzaHRibCBkb24ndCB1c2UgYW55IG1lbW9yeSAoYmVzaWRlcyB0aGVcbiAgIGFycmF5IGNlbGwpICopXG50eXBlICgnaywgJ3YpIHQgPVxuICB8IEVtcHR5XG4gIHwgTm9kZSBvZlxuICAgICAgeyBtdXRhYmxlIGxlZnQgOiAoJ2ssICd2KSB0XG4gICAgICA7IGtleSA6ICdrXG4gICAgICA7IG11dGFibGUgdmFsdWUgOiAndlxuICAgICAgOyBtdXRhYmxlIGhlaWdodCA6IGludFxuICAgICAgOyBtdXRhYmxlIHJpZ2h0IDogKCdrLCAndikgdFxuICAgICAgfVxuICB8IExlYWYgb2ZcbiAgICAgIHsga2V5IDogJ2tcbiAgICAgIDsgbXV0YWJsZSB2YWx1ZSA6ICd2XG4gICAgICB9XG5cbmxldCBlbXB0eSA9IEVtcHR5XG5cbmxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gdHJ1ZVxuICB8IExlYWYgXyB8IE5vZGUgXyAtPiBmYWxzZVxuOztcblxubGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gMFxuICB8IExlYWYgXyAtPiAxXG4gIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodDsgcmlnaHQgPSBfIH0gLT4gaGVpZ2h0XG47O1xuXG5sZXQgaW52YXJpYW50IGNvbXBhcmUgPVxuICBsZXQgbGVnYWxfbGVmdF9rZXkga2V5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIHsga2V5ID0gbGVmdF9rZXk7IHZhbHVlID0gXyB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IGxlZnRfa2V5OyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+XG4gICAgICBhc3NlcnQgKGNvbXBhcmUgbGVmdF9rZXkga2V5IDwgMClcbiAgaW5cbiAgbGV0IGxlZ2FsX3JpZ2h0X2tleSBrZXkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgeyBrZXkgPSByaWdodF9rZXk7IHZhbHVlID0gXyB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IHJpZ2h0X2tleTsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPlxuICAgICAgYXNzZXJ0IChjb21wYXJlIHJpZ2h0X2tleSBrZXkgPiAwKVxuICBpblxuICBsZXQgcmVjIGludiA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSB8IExlYWYgXyAtPiAoKVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IGs7IHZhbHVlID0gXzsgaGVpZ2h0ID0gaDsgcmlnaHQgfSAtPlxuICAgICAgbGV0IGhsLCBociA9IGhlaWdodCBsZWZ0LCBoZWlnaHQgcmlnaHQgaW5cbiAgICAgIGludiBsZWZ0O1xuICAgICAgaW52IHJpZ2h0O1xuICAgICAgbGVnYWxfbGVmdF9rZXkgayBsZWZ0O1xuICAgICAgbGVnYWxfcmlnaHRfa2V5IGsgcmlnaHQ7XG4gICAgICBhc3NlcnQgKGggPSBJbnQubWF4IGhsIGhyICsgMSk7XG4gICAgICBhc3NlcnQgKGFicyAoaGwgLSBocikgPD0gMilcbiAgaW5cbiAgaW52XG47O1xuXG5sZXQgaW52YXJpYW50IHQgfmNvbXBhcmUgPSBpbnZhcmlhbnQgY29tcGFyZSB0XG5cbigqIEluIHRoZSBmb2xsb3dpbmcgY29tbWVudHMsXG4gICAndCBpcyBiYWxhbmNlZCcgbWVhbnMgdGhhdCAnaW52YXJpYW50IHQnIGRvZXMgbm90XG4gICByYWlzZSBhbiBleGNlcHRpb24uICBUaGlzIGltcGxpZXMgb2YgY291cnNlIHRoYXQgZWFjaCBub2RlJ3MgaGVpZ2h0IGZpZWxkIGlzXG4gICBjb3JyZWN0LlxuICAgJ3QgaXMgYmFsYW5jZWFibGUnIG1lYW5zIHRoYXQgaGVpZ2h0IG9mIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBvZiB0XG4gICBkaWZmZXIgYnkgYXQgbW9zdCAzLiAqKVxuXG4oKiBAcHJlOiBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBoYXZlIGNvcnJlY3QgaGVpZ2h0c1xuICAgQHBvc3Q6IG91dHB1dCBoYXMgdGhlIGNvcnJlY3QgaGVpZ2h0ICopXG5sZXQgdXBkYXRlX2hlaWdodCA9IGZ1bmN0aW9uXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IG9sZF9oZWlnaHQ7IHJpZ2h0IH0gYXMgeCkgLT5cbiAgICBsZXQgbmV3X2hlaWdodCA9IEludC5tYXggKGhlaWdodCBsZWZ0KSAoaGVpZ2h0IHJpZ2h0KSArIDEgaW5cbiAgICBpZiBuZXdfaGVpZ2h0IDw+IG9sZF9oZWlnaHQgdGhlbiB4LmhlaWdodCA8LSBuZXdfaGVpZ2h0XG4gIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuXG4oKiBAcHJlOiBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBhcmUgYmFsYW5jZWRcbiAgIEBwcmU6IHRyZWUgaXMgYmFsYW5jZWFibGVcbiAgIEBwb3N0OiBvdXRwdXQgaXMgYmFsYW5jZWQgKGluIHBhcnRpY3VsYXIsIGhlaWdodCBpcyBjb3JyZWN0KSAqKVxubGV0IGJhbGFuY2UgdHJlZSA9XG4gIG1hdGNoIHRyZWUgd2l0aFxuICB8IEVtcHR5IHwgTGVhZiBfIC0+IHRyZWVcbiAgfCBOb2RlICh7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyByb290X25vZGUpIC0+XG4gICAgbGV0IGhsID0gaGVpZ2h0IGxlZnRcbiAgICBhbmQgaHIgPSBoZWlnaHQgcmlnaHQgaW5cbiAgICAoKiArIDIgaXMgY3JpdGljYWxseSBpbXBvcnRhbnQsIGxvd2VyaW5nIGl0IHRvIDEgd2lsbCBicmVhayB0aGUgTGVhZlxuICAgICAgIGFzc3VtcHRpb25zIGluIHRoZSBjb2RlIGJlbG93LCBhbmQgd2lsbCBmb3JjZSB1cyB0byBwcm9tb3RlIGxlYWYgbm9kZXMgaW5cbiAgICAgICB0aGUgYmFsYW5jZSByb3V0aW5lLiBJdCdzIGFsc28gZmFzdGVyLCBzaW5jZSBpdCB3aWxsIGJhbGFuY2UgbGVzcyBvZnRlbi5cbiAgICAgICBOb3RlIHRoYXQgdGhlIGZvbGxvd2luZyBjb2RlIGlzIGRlbGljYXRlLiAgVGhlIHVwZGF0ZV9oZWlnaHQgY2FsbHMgbXVzdFxuICAgICAgIG9jY3VyIGluIHRoZSBjb3JyZWN0IG9yZGVyLCBzaW5jZSB1cGRhdGVfaGVpZ2h0IGFzc3VtZXMgaXRzIGNoaWxkcmVuIGhhdmVcbiAgICAgICB0aGUgY29ycmVjdCBoZWlnaHRzLiAgKilcbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbGVmdCB3aXRoXG4gICAgICAoKiBJdCBjYW5ub3QgYmUgYSBsZWFmLCBiZWNhdXNlIGV2ZW4gaWYgcmlnaHQgaXMgZW1wdHksIGEgbGVhZlxuICAgICAgICAgaXMgb25seSBoZWlnaHQgMSAqKVxuICAgICAgfCBFbXB0eSB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTm9kZVxuICAgICAgICAgICh7IGxlZnQgPSBsZWZ0X25vZGVfbGVmdFxuICAgICAgICAgICA7IGtleSA9IF9cbiAgICAgICAgICAgOyB2YWx1ZSA9IF9cbiAgICAgICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICAgICAgIDsgcmlnaHQgPSBsZWZ0X25vZGVfcmlnaHRcbiAgICAgICAgICAgfSBhcyBsZWZ0X25vZGUpIC0+XG4gICAgICAgIGlmIGhlaWdodCBsZWZ0X25vZGVfbGVmdCA+PSBoZWlnaHQgbGVmdF9ub2RlX3JpZ2h0XG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHJvb3Rfbm9kZS5sZWZ0IDwtIGxlZnRfbm9kZV9yaWdodDtcbiAgICAgICAgICBsZWZ0X25vZGUucmlnaHQgPC0gdHJlZTtcbiAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCBsZWZ0O1xuICAgICAgICAgIGxlZnQpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIGlmIHJpZ2h0IGlzIGEgbGVhZiwgdGhlbiBsZWZ0IG11c3QgYmUgZW1wdHkuIFRoYXQgbWVhbnNcbiAgICAgICAgICAgICBoZWlnaHQgaXMgMi4gRXZlbiBpZiBociBpcyBlbXB0eSB3ZSBzdGlsbCBjYW4ndCBnZXQgaGVyZS4gKilcbiAgICAgICAgICBtYXRjaCBsZWZ0X25vZGVfcmlnaHQgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBOb2RlXG4gICAgICAgICAgICAgICh7IGxlZnQgPSBscl9sZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gbHJfcmlnaHQgfSBhc1xuICAgICAgICAgICAgICBscl9ub2RlKSAtPlxuICAgICAgICAgICAgbGVmdF9ub2RlLnJpZ2h0IDwtIGxyX2xlZnQ7XG4gICAgICAgICAgICByb290X25vZGUubGVmdCA8LSBscl9yaWdodDtcbiAgICAgICAgICAgIGxyX25vZGUucmlnaHQgPC0gdHJlZTtcbiAgICAgICAgICAgIGxyX25vZGUubGVmdCA8LSBsZWZ0O1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCBsZWZ0O1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCBsZWZ0X25vZGVfcmlnaHQ7XG4gICAgICAgICAgICBsZWZ0X25vZGVfcmlnaHQpKVxuICAgIGVsc2UgaWYgaHIgPiBobCArIDJcbiAgICB0aGVuIChcbiAgICAgICgqIHNlZSBhYm92ZSBmb3IgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHJpZ2h0IGNhbm5vdCBiZSBhIGxlYWYgKilcbiAgICAgIG1hdGNoIHJpZ2h0IHdpdGhcbiAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IE5vZGVcbiAgICAgICAgICAoeyBsZWZ0ID0gcmlnaHRfbm9kZV9sZWZ0XG4gICAgICAgICAgIDsga2V5ID0gX1xuICAgICAgICAgICA7IHZhbHVlID0gX1xuICAgICAgICAgICA7IGhlaWdodCA9IF9cbiAgICAgICAgICAgOyByaWdodCA9IHJpZ2h0X25vZGVfcmlnaHRcbiAgICAgICAgICAgfSBhcyByaWdodF9ub2RlKSAtPlxuICAgICAgICBpZiBoZWlnaHQgcmlnaHRfbm9kZV9yaWdodCA+PSBoZWlnaHQgcmlnaHRfbm9kZV9sZWZ0XG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHJvb3Rfbm9kZS5yaWdodCA8LSByaWdodF9ub2RlX2xlZnQ7XG4gICAgICAgICAgcmlnaHRfbm9kZS5sZWZ0IDwtIHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgcmlnaHQ7XG4gICAgICAgICAgcmlnaHQpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIHNlZSBhYm92ZSBmb3IgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgY2Fubm90IGJlIGEgbGVhZiAqKVxuICAgICAgICAgIG1hdGNoIHJpZ2h0X25vZGVfbGVmdCB3aXRoXG4gICAgICAgICAgfCBFbXB0eSB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IE5vZGVcbiAgICAgICAgICAgICAgKHsgbGVmdCA9IHJsX2xlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBybF9yaWdodCB9IGFzXG4gICAgICAgICAgICAgIHJsX25vZGUpIC0+XG4gICAgICAgICAgICByaWdodF9ub2RlLmxlZnQgPC0gcmxfcmlnaHQ7XG4gICAgICAgICAgICByb290X25vZGUucmlnaHQgPC0gcmxfbGVmdDtcbiAgICAgICAgICAgIHJsX25vZGUubGVmdCA8LSB0cmVlO1xuICAgICAgICAgICAgcmxfbm9kZS5yaWdodCA8LSByaWdodDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgcmlnaHQ7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHJpZ2h0X25vZGVfbGVmdDtcbiAgICAgICAgICAgIHJpZ2h0X25vZGVfbGVmdCkpXG4gICAgZWxzZSAoXG4gICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICB0cmVlKVxuOztcblxuKCogQHByZTogdCBpcyBiYWxhbmNlZC5cbiAgIEBwb3N0OiByZXN1bHQgaXMgYmFsYW5jZWQsIHdpdGggbmV3IG5vZGUgaW5zZXJ0ZWRcbiAgIEBwb3N0OiAhYWRkZWQgPSB0cnVlIGlmZiB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IHRyZWUgY2hhbmdlZC4gICopXG5sZXQgcmVjIGFkZCB0IH5yZXBsYWNlIH5jb21wYXJlIH5hZGRlZCB+a2V5OmsgfmRhdGE6diA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+XG4gICAgYWRkZWQgOj0gdHJ1ZTtcbiAgICBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgfCBMZWFmICh7IGtleSA9IGsnOyB2YWx1ZSA9IF8gfSBhcyByKSAtPlxuICAgIGxldCBjID0gY29tcGFyZSBrJyBrIGluXG4gICAgKCogVGhpcyBjb21wYXJlIGlzIHJldmVyc2VkIG9uIHB1cnBvc2UsIHdlIGFyZSBwcmV0ZW5kaW5nXG4gICAgICAgdGhhdCB0aGUgbGVhZiB3YXMganVzdCBpbnNlcnRlZCBpbnN0ZWFkIG9mIHRoZSBvdGhlciB3YXlcbiAgICAgICByb3VuZCwgdGhhdCB3YXkgd2Ugb25seSBhbGxvY2F0ZSBvbmUgbm9kZS4gKilcbiAgICBpZiBjID0gMFxuICAgIHRoZW4gKFxuICAgICAgYWRkZWQgOj0gZmFsc2U7XG4gICAgICBpZiByZXBsYWNlIHRoZW4gci52YWx1ZSA8LSB2O1xuICAgICAgdClcbiAgICBlbHNlIChcbiAgICAgIGFkZGVkIDo9IHRydWU7XG4gICAgICBpZiBjIDwgMFxuICAgICAgdGhlbiBOb2RlIHsgbGVmdCA9IHQ7IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gMjsgcmlnaHQgPSBFbXB0eSB9XG4gICAgICBlbHNlIE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gMjsgcmlnaHQgPSB0IH0pXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBrJzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHIpIC0+XG4gICAgbGV0IGMgPSBjb21wYXJlIGsgaycgaW5cbiAgICBpZiBjID0gMFxuICAgIHRoZW4gKFxuICAgICAgYWRkZWQgOj0gZmFsc2U7XG4gICAgICBpZiByZXBsYWNlIHRoZW4gci52YWx1ZSA8LSB2O1xuICAgICAgdClcbiAgICBlbHNlIChcbiAgICAgIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGxlZnQnID0gYWRkIGxlZnQgfnJlcGxhY2UgfmFkZGVkIH5jb21wYXJlIH5rZXk6ayB+ZGF0YTp2IGluXG4gICAgICAgIGlmIG5vdCAocGh5c19lcXVhbCBsZWZ0JyBsZWZ0KSB0aGVuIHIubGVmdCA8LSBsZWZ0JylcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgcmlnaHQnID0gYWRkIHJpZ2h0IH5yZXBsYWNlIH5hZGRlZCB+Y29tcGFyZSB+a2V5OmsgfmRhdGE6diBpblxuICAgICAgICBpZiBub3QgKHBoeXNfZXF1YWwgcmlnaHQnIHJpZ2h0KSB0aGVuIHIucmlnaHQgPC0gcmlnaHQnKTtcbiAgICAgIGlmICFhZGRlZCB0aGVuIGJhbGFuY2UgdCBlbHNlIHQpXG47O1xuXG5sZXQgcmVjIGZpcnN0IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiBOb25lXG4gIHwgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gIHwgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPiBTb21lIChrLCB2KVxuICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPiBmaXJzdCBsXG47O1xuXG5sZXQgcmVjIGxhc3QgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBFbXB0eSB9IC0+IFNvbWUgKGssIHYpXG4gIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gciB9IC0+IGxhc3QgclxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSByZWMgZmluZGlfYW5kX2NhbGxfaW1wbFxuICB0XG4gIH5jb21wYXJlXG4gIGtcbiAgYXJnMVxuICBhcmcyXG4gIH5jYWxsX2lmX2ZvdW5kXG4gIH5jYWxsX2lmX25vdF9mb3VuZFxuICB+aWZfZm91bmRcbiAgfmlmX25vdF9mb3VuZFxuICA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQgayBhcmcxIGFyZzJcbiAgfCBMZWFmIHsga2V5ID0gayc7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZSBrIGsnID0gMFxuICAgIHRoZW4gY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTprJyB+ZGF0YTp2IGFyZzEgYXJnMlxuICAgIGVsc2UgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrIGFyZzEgYXJnMlxuICB8IE5vZGUgeyBsZWZ0OyBrZXkgPSBrJzsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCB9IC0+XG4gICAgbGV0IGMgPSBjb21wYXJlIGsgaycgaW5cbiAgICBpZiBjID0gMFxuICAgIHRoZW4gY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTprJyB+ZGF0YTp2IGFyZzEgYXJnMlxuICAgIGVsc2VcbiAgICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgICAgKGlmIGMgPCAwIHRoZW4gbGVmdCBlbHNlIHJpZ2h0KVxuICAgICAgICB+Y29tcGFyZVxuICAgICAgICBrXG4gICAgICAgIGFyZzFcbiAgICAgICAgYXJnMlxuICAgICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgICAgfmlmX2ZvdW5kXG4gICAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6XyB+ZGF0YSAoKSAoKSA9IGlmX2ZvdW5kIGRhdGEgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5ICgpICgpID0gaWZfbm90X2ZvdW5kIGtleSBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgICgpXG4gICAgICAoKVxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleSB+ZGF0YSAoKSAoKSA9IGlmX2ZvdW5kIH5rZXkgfmRhdGEgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5ICgpICgpID0gaWZfbm90X2ZvdW5kIGtleSBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgICgpXG4gICAgICAoKVxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbDEgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTpfIH5kYXRhIGFyZyAoKSA9IGlmX2ZvdW5kIGRhdGEgYXJnIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSBhcmcgKCkgPSBpZl9ub3RfZm91bmQga2V5IGFyZyBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgIGFcbiAgICAgICgpXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbDEgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleSB+ZGF0YSBhcmcgKCkgPSBpZl9mb3VuZCB+a2V5IH5kYXRhIGFyZyBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnICgpID0gaWZfbm90X2ZvdW5kIGtleSBhcmcgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICAoKVxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbDIgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTpfIH5kYXRhIGFyZzEgYXJnMiA9IGlmX2ZvdW5kIGRhdGEgYXJnMSBhcmcyIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgPSBpZl9ub3RfZm91bmQga2V5IGFyZzEgYXJnMiBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgIGFcbiAgICAgIGJcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMiA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5IH5kYXRhIGFyZzEgYXJnMiA9IGlmX2ZvdW5kIH5rZXkgfmRhdGEgYXJnMSBhcmcyIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgPSBpZl9ub3RfZm91bmQga2V5IGFyZzEgYXJnMiBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgIGFcbiAgICAgIGJcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmQgPVxuICBsZXQgaWZfZm91bmQgdiA9IFNvbWUgdiBpblxuICBsZXQgaWZfbm90X2ZvdW5kIF8gPSBOb25lIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgLT4gZmluZF9hbmRfY2FsbCB0IH5jb21wYXJlIGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBtZW0gPVxuICBsZXQgaWZfZm91bmQgXyA9IHRydWUgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBfID0gZmFsc2UgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayAtPiBmaW5kX2FuZF9jYWxsIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IHJlYyByZW1vdmUgPVxuICBsZXQgcmVjIG1pbl9lbHQgdHJlZSA9XG4gICAgbWF0Y2ggdHJlZSB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiBfIC0+IHRyZWVcbiAgICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gdHJlZVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gbWluX2VsdCBsZWZ0XG4gIGluXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgdHJlZSA9XG4gICAgbWF0Y2ggdHJlZSB3aXRoXG4gICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IExlYWYgXyAtPiBFbXB0eVxuICAgIHwgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCB9IC0+IHJpZ2h0XG4gICAgfCBOb2RlIHsgbGVmdCA9IExlYWYgXzsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCA9IEVtcHR5IH0gLT5cbiAgICAgIExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfVxuICAgIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IGFzIHIpIC0+XG4gICAgICByLmxlZnQgPC0gcmVtb3ZlX21pbl9lbHQgbGVmdDtcbiAgICAgIGJhbGFuY2UgdHJlZVxuICBpblxuICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCAtPiB0XG4gICAgfCB0LCBFbXB0eSAtPiB0XG4gICAgfCBfLCBfIC0+XG4gICAgICBsZXQgdHJlZSA9IG1pbl9lbHQgdDIgaW5cbiAgICAgIGJhbGFuY2VcbiAgICAgICAgKG1hdGNoIHRyZWUgd2l0aFxuICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgIHwgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgICAgICAgIGxldCB0MiA9IHJlbW92ZV9taW5fZWx0IHQyIGluXG4gICAgICAgICAgIE5vZGVcbiAgICAgICAgICAgICB7IGxlZnQgPSB0MVxuICAgICAgICAgICAgIDsga2V5ID0ga1xuICAgICAgICAgICAgIDsgdmFsdWUgPSB2XG4gICAgICAgICAgICAgOyBoZWlnaHQgPSBJbnQubWF4IChoZWlnaHQgdDEpIChoZWlnaHQgdDIpICsgMVxuICAgICAgICAgICAgIDsgcmlnaHQgPSB0MlxuICAgICAgICAgICAgIH1cbiAgICAgICAgIHwgTm9kZSByIC0+XG4gICAgICAgICAgIHIucmlnaHQgPC0gcmVtb3ZlX21pbl9lbHQgdDI7XG4gICAgICAgICAgIHIubGVmdCA8LSB0MTtcbiAgICAgICAgICAgdHJlZSlcbiAgaW5cbiAgZnVuIHQgfnJlbW92ZWQgfmNvbXBhcmUgayAtPlxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT5cbiAgICAgIHJlbW92ZWQgOj0gZmFsc2U7XG4gICAgICBFbXB0eVxuICAgIHwgTGVhZiB7IGtleSA9IGsnOyB2YWx1ZSA9IF8gfSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGsnID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIHJlbW92ZWQgOj0gdHJ1ZTtcbiAgICAgICAgRW1wdHkpXG4gICAgICBlbHNlIChcbiAgICAgICAgcmVtb3ZlZCA6PSBmYWxzZTtcbiAgICAgICAgdClcbiAgICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gayc7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyByKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlIGsgaycgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgcmVtb3ZlZCA6PSB0cnVlO1xuICAgICAgICBtZXJnZSBsZWZ0IHJpZ2h0KVxuICAgICAgZWxzZSAoXG4gICAgICAgIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsZWZ0JyA9IHJlbW92ZSBsZWZ0IH5yZW1vdmVkIH5jb21wYXJlIGsgaW5cbiAgICAgICAgICBpZiBub3QgKHBoeXNfZXF1YWwgbGVmdCcgbGVmdCkgdGhlbiByLmxlZnQgPC0gbGVmdCcpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByaWdodCcgPSByZW1vdmUgcmlnaHQgfnJlbW92ZWQgfmNvbXBhcmUgayBpblxuICAgICAgICAgIGlmIG5vdCAocGh5c19lcXVhbCByaWdodCcgcmlnaHQpIHRoZW4gci5yaWdodCA8LSByaWdodCcpO1xuICAgICAgICBpZiAhcmVtb3ZlZCB0aGVuIGJhbGFuY2UgdCBlbHNlIHQpXG47O1xuXG5sZXQgcmVjIGZvbGQgdCB+aW5pdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IGluaXRcbiAgfCBMZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGEgaW5pdFxuICB8IE5vZGVcbiAgICAgIHsgbGVmdCA9IExlYWYgeyBrZXkgPSBsa2V5OyB2YWx1ZSA9IGxkYXRhIH1cbiAgICAgIDsga2V5XG4gICAgICA7IHZhbHVlID0gZGF0YVxuICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICA7IHJpZ2h0ID0gTGVhZiB7IGtleSA9IHJrZXk7IHZhbHVlID0gcmRhdGEgfVxuICAgICAgfSAtPiBmIH5rZXk6cmtleSB+ZGF0YTpyZGF0YSAoZiB+a2V5IH5kYXRhIChmIH5rZXk6bGtleSB+ZGF0YTpsZGF0YSBpbml0KSlcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0gbGtleTsgdmFsdWUgPSBsZGF0YSB9XG4gICAgICA7IGtleVxuICAgICAgOyB2YWx1ZSA9IGRhdGFcbiAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgOyByaWdodCA9IEVtcHR5XG4gICAgICB9IC0+IGYgfmtleSB+ZGF0YSAoZiB+a2V5OmxrZXkgfmRhdGE6bGRhdGEgaW5pdClcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBFbXB0eVxuICAgICAgOyBrZXlcbiAgICAgIDsgdmFsdWUgPSBkYXRhXG4gICAgICA7IGhlaWdodCA9IF9cbiAgICAgIDsgcmlnaHQgPSBMZWFmIHsga2V5ID0gcmtleTsgdmFsdWUgPSByZGF0YSB9XG4gICAgICB9IC0+IGYgfmtleTpya2V5IH5kYXRhOnJkYXRhIChmIH5rZXkgfmRhdGEgaW5pdClcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQ7IGtleTsgdmFsdWUgPSBkYXRhOyBoZWlnaHQgPSBfOyByaWdodCA9IExlYWYgeyBrZXkgPSBya2V5OyB2YWx1ZSA9IHJkYXRhIH0gfVxuICAgIC0+IGYgfmtleTpya2V5IH5kYXRhOnJkYXRhIChmIH5rZXkgfmRhdGEgKGZvbGQgbGVmdCB+aW5pdCB+ZikpXG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IGxrZXk7IHZhbHVlID0gbGRhdGEgfTsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0IH1cbiAgICAtPiBmb2xkIHJpZ2h0IH5pbml0OihmIH5rZXkgfmRhdGEgKGYgfmtleTpsa2V5IH5kYXRhOmxkYXRhIGluaXQpKSB+ZlxuICB8IE5vZGUgeyBsZWZ0OyBrZXk7IHZhbHVlID0gZGF0YTsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgIGZvbGQgcmlnaHQgfmluaXQ6KGYgfmtleSB+ZGF0YSAoZm9sZCBsZWZ0IH5pbml0IH5mKSkgfmZcbjs7XG5cbmxldCByZWMgaXRlciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gKClcbiAgfCBMZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGFcbiAgfCBOb2RlIHsgbGVmdDsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0IH0gLT5cbiAgICBpdGVyIGxlZnQgfmY7XG4gICAgZiB+a2V5IH5kYXRhO1xuICAgIGl0ZXIgcmlnaHQgfmZcbjs7XG5cbmxldCByZWMgbWFwaV9pbnBsYWNlIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiAoKVxuICB8IExlYWYgKHsga2V5OyB2YWx1ZSB9IGFzIHQpIC0+IHQudmFsdWUgPC0gZiB+a2V5IH5kYXRhOnZhbHVlXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXk7IHZhbHVlOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHQpIC0+XG4gICAgbWFwaV9pbnBsYWNlIH5mIGxlZnQ7XG4gICAgdC52YWx1ZSA8LSBmIH5rZXkgfmRhdGE6dmFsdWU7XG4gICAgbWFwaV9pbnBsYWNlIH5mIHJpZ2h0XG47O1xuXG5sZXQgY2hvb3NlX2V4biA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0F2bHRyZWUuY2hvb3NlX2V4bl0gb2YgZW1wdHkgaGFzaHRibFwiIFtdKVxuICB8IExlYWYgeyBrZXk7IHZhbHVlOyBfIH0gfCBOb2RlIHsga2V5OyB2YWx1ZTsgXyB9IC0+IGtleSwgdmFsdWVcbjs7XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSGFzaHRibF9pbnRmXG5cbm1vZHVsZSB0eXBlIEtleSA9IEtleS5TXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5sZXQgaGFzaF9wYXJhbSA9IEhhc2hhYmxlLmhhc2hfcGFyYW1cbmxldCBoYXNoID0gSGFzaGFibGUuaGFzaFxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbnR5cGUgKCdrLCAndikgdCA9XG4gIHsgbXV0YWJsZSB0YWJsZSA6ICgnaywgJ3YpIEF2bHRyZWUudCBhcnJheVxuICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIDsgZ3Jvd3RoX2FsbG93ZWQgOiBib29sXG4gIDsgaGFzaGFibGUgOiAnayBIYXNoYWJsZS50XG4gIDsgbXV0YWJsZSBtdXRhdGlvbl9hbGxvd2VkIDogYm9vbCAoKiBTZXQgZHVyaW5nIGFsbCBpdGVyYXRpb24gb3BlcmF0aW9ucyAqKVxuICB9XG5cbnR5cGUgJ2Ega2V5ID0gJ2FcblxubGV0IHNleHBfb2Zfa2V5IHQgPSB0Lmhhc2hhYmxlLkhhc2hhYmxlLnNleHBfb2ZfdFxubGV0IGNvbXBhcmVfa2V5IHQgPSB0Lmhhc2hhYmxlLkhhc2hhYmxlLmNvbXBhcmVcblxubGV0IGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQgPVxuICBpZiBub3QgdC5tdXRhdGlvbl9hbGxvd2VkIHRoZW4gZmFpbHdpdGggXCJIYXNodGJsOiBtdXRhdGlvbiBub3QgYWxsb3dlZCBkdXJpbmcgaXRlcmF0aW9uXCJcbjs7XG5cbmxldCB3aXRob3V0X211dGF0aW5nIHQgZiA9XG4gIGlmIHQubXV0YXRpb25fYWxsb3dlZFxuICB0aGVuIChcbiAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gZmFsc2U7XG4gICAgbWF0Y2ggZiAoKSB3aXRoXG4gICAgfCB4IC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gdHJ1ZTtcbiAgICAgIHhcbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSB0cnVlO1xuICAgICAgcmFpc2UgZXhuKVxuICBlbHNlIGYgKClcbjs7XG5cbigqKiBJbnRlcm5hbGx5IHVzZSBhIG1heGltdW0gc2l6ZSB0aGF0IGlzIGEgcG93ZXIgb2YgMi4gUmV2ZXJzZXMgdGhlIGFib3ZlIHRvIGZpbmQgdGhlXG4gICAgZmxvb3IgcG93ZXIgb2YgMiBiZWxvdyB0aGUgc3lzdGVtIG1heCBhcnJheSBsZW5ndGggKilcbmxldCBtYXhfdGFibGVfbGVuZ3RoID0gSW50LmZsb29yX3BvdzIgQXJyYXkubWF4X2xlbmd0aFxuXG4oKiBUaGUgZGVmYXVsdCBzaXplIGlzIGNob3NlbiB0byBiZSAwIChhcyBvcHBvc2VkIHRvIDEyOCBhcyBpdCB3YXMgYmVmb3JlKSBiZWNhdXNlOlxuICAgLSAxMjggY2FuIGNyZWF0ZSBzdWJzdGFudGlhbCBtZW1vcnkgb3ZlcmhlYWQgKHgxMCkgd2hlbiBjcmVhdGluZyBtYW55IHRhYmxlcywgbW9zdFxuICAgICBvZiB3aGljaCBhcmUgbm90IGJpZyAoc2F5LCBpZiB5b3UgaGF2ZSBhIGhhc2h0Ymwgb2YgaGFzaHRibCkuIEFuZCBtZW1vcnkgb3ZlcmhlYWQgaXNcbiAgICAgbm90IHRoYXQgZWFzeSB0byBwcm9maWxlLlxuICAgLSBpZiBhIGhhc2h0YmwgaXMgZ29pbmcgdG8gZ3JvdywgaXQncyBub3QgY2xlYXIgd2h5IDEyOCBpcyBtYXJrZWRseSBiZXR0ZXIgdGhhbiBvdGhlclxuICAgICBzaXplcyAoaWYgeW91IGdvaW5nIHRvIHN0aWNrIDEwMDAgZWxlbWVudHMsIHlvdSdyZSBnb2luZyB0byBncm93IHRoZSBoYXNodGFibGUgb25jZVxuICAgICBvciB0d2ljZSBhbnl3YXkpXG4gICAtIGluIG90aGVyIGxhbmd1YWdlcyAobGlrZSBydXN0LCBweXRob24sIGFuZCBhcHBhcmVudGx5IGdvKSwgdGhlIGRlZmF1bHQgaXMgYWxzbyBhXG4gICAgIHNtYWxsIHNpemUuICopXG5sZXQgY3JlYXRlID8oZ3Jvd3RoX2FsbG93ZWQgPSB0cnVlKSA/KHNpemUgPSAwKSB+aGFzaGFibGUgKCkgPVxuICBsZXQgc2l6ZSA9IEludC5taW4gKEludC5tYXggMSBzaXplKSBtYXhfdGFibGVfbGVuZ3RoIGluXG4gIGxldCBzaXplID0gSW50LmNlaWxfcG93MiBzaXplIGluXG4gIHsgdGFibGUgPSBBcnJheS5jcmVhdGUgfmxlbjpzaXplIEF2bHRyZWUuZW1wdHlcbiAgOyBsZW5ndGggPSAwXG4gIDsgZ3Jvd3RoX2FsbG93ZWRcbiAgOyBoYXNoYWJsZVxuICA7IG11dGF0aW9uX2FsbG93ZWQgPSB0cnVlXG4gIH1cbjs7XG5cbigqKiBTdXBwbGVtZW50YWwgaGFzaC4gVGhpcyBtYXkgbm90IGJlIG5lY2Vzc2FyeSwgaXQgaXMgaW50ZW5kZWQgYXMgYSBkZWZlbnNlIGFnYWluc3QgcG9vclxuICAgIGhhc2ggZnVuY3Rpb25zLCBmb3Igd2hpY2ggdGhlIHBvd2VyIG9mIDIgc2l6ZWQgdGFibGUgd2lsbCBiZSBlc3BlY2lhbGx5IHNlbnNpdGl2ZS5cbiAgICBXaXRoIHNvbWUgdGVzdGluZyB3ZSBtYXkgY2hvb3NlIHRvIGFkZCBpdCwgYnV0IHRoaXMgdGFibGUgaXMgZGVzaWduZWQgdG8gYmUgcm9idXN0IHRvXG4gICAgY29sbGlzaW9ucywgYW5kIGluIG1vc3Qgb2YgbXkgdGVzdGluZyB0aGlzIGRlZ3JhZGVzIHBlcmZvcm1hbmNlLiAqKVxubGV0IF9zdXBwbGVtZW50YWxfaGFzaCBoID1cbiAgbGV0IGggPSBoIGx4b3IgKChoIGxzciAyMCkgbHhvciAoaCBsc3IgMTIpKSBpblxuICBoIGx4b3IgKGggbHNyIDcpIGx4b3IgKGggbHNyIDQpXG47O1xuXG5sZXQgc2xvdCB0IGtleSA9XG4gIGxldCBoYXNoID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5oYXNoIGtleSBpblxuICAoKiB0aGlzIGlzIGFsd2F5cyBub24tbmVnYXRpdmUgYmVjYXVzZSB3ZSBkbyBbbGFuZF0gd2l0aCBub24tbmVnYXRpdmUgbnVtYmVyICopXG4gIGhhc2ggbGFuZCAoQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxKVxuOztcblxubGV0IGFkZF93b3JrZXIgdCB+cmVwbGFjZSB+a2V5IH5kYXRhID1cbiAgbGV0IGkgPSBzbG90IHQga2V5IGluXG4gIGxldCByb290ID0gdC50YWJsZS4oaSkgaW5cbiAgbGV0IGFkZGVkID0gcmVmIGZhbHNlIGluXG4gIGxldCBuZXdfcm9vdCA9XG4gICAgKCogVGhlIGF2bCB0cmVlIG1pZ2h0IHJlcGxhY2UgdGhlIHZhbHVlIFtyZXBsYWNlPXRydWVdIG9yIGRvIG5vdGhpbmcgW3JlcGxhY2U9ZmFsc2VdXG4gICAgICAgdG8gdGhlIGVudHJ5LCBpbiB0aGF0IGNhc2UgdGhlIHRhYmxlIGRpZCBub3QgZ2V0IGJpZ2dlciwgc28gd2Ugc2hvdWxkIG5vdFxuICAgICAgIGluY3JlbWVudCBsZW5ndGgsIHdlIHBhc3MgaW4gdGhlIGJvb2wgcmVmIHQuYWRkZWQgc28gdGhhdCBpdCBjYW4gdGVsbCB1cyB3aGV0aGVyXG4gICAgICAgaXQgYWRkZWQgb3IgcmVwbGFjZWQuIFdlIGRvIGl0IHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb24uIFNpbmNlIHRoZSBib29sXG4gICAgICAgaXMgYW4gaW1tZWRpYXRlIGl0IGRvZXMgbm90IGdvIHRocm91Z2ggdGhlIHdyaXRlIGJhcnJpZXIuICopXG4gICAgQXZsdHJlZS5hZGQgfnJlcGxhY2Ugcm9vdCB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkgfmFkZGVkIH5rZXkgfmRhdGFcbiAgaW5cbiAgaWYgIWFkZGVkIHRoZW4gdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxO1xuICAoKiBUaGlzIGxpdHRsZSBvcHRpbWl6YXRpb24gc2F2ZXMgYSBjYW1sX21vZGlmeSB3aGVuIHRoZSB0cmVlXG4gICAgIGhhc24ndCBiZWVuIHJlYmFsYW5jZWQuICopXG4gIGlmIG5vdCAocGh5c19lcXVhbCBuZXdfcm9vdCByb290KSB0aGVuIHQudGFibGUuKGkpIDwtIG5ld19yb290O1xuICAhYWRkZWRcbjs7XG5cbmxldCBtYXliZV9yZXNpemVfdGFibGUgdCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICBsZXQgc2hvdWxkX2dyb3cgPSB0Lmxlbmd0aCA+IGxlbiBpblxuICBpZiBzaG91bGRfZ3JvdyAmJiB0Lmdyb3d0aF9hbGxvd2VkXG4gIHRoZW4gKFxuICAgIGxldCBuZXdfYXJyYXlfbGVuZ3RoID0gSW50Lm1pbiAobGVuICogMikgbWF4X3RhYmxlX2xlbmd0aCBpblxuICAgIGlmIG5ld19hcnJheV9sZW5ndGggPiBsZW5cbiAgICB0aGVuIChcbiAgICAgIGxldCBuZXdfdGFibGUgPSBBcnJheS5jcmVhdGUgfmxlbjpuZXdfYXJyYXlfbGVuZ3RoIEF2bHRyZWUuZW1wdHkgaW5cbiAgICAgIGxldCBvbGRfdGFibGUgPSB0LnRhYmxlIGluXG4gICAgICB0LnRhYmxlIDwtIG5ld190YWJsZTtcbiAgICAgIHQubGVuZ3RoIDwtIDA7XG4gICAgICBsZXQgZiB+a2V5IH5kYXRhID0gaWdub3JlIChhZGRfd29ya2VyIH5yZXBsYWNlOnRydWUgdCB+a2V5IH5kYXRhIDogYm9vbCkgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggb2xkX3RhYmxlIC0gMSBkb1xuICAgICAgICBBdmx0cmVlLml0ZXIgb2xkX3RhYmxlLihpKSB+ZlxuICAgICAgZG9uZSkpXG47O1xuXG5sZXQgY2FwYWNpdHkgdCA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlXG5cbmxldCBzZXQgdCB+a2V5IH5kYXRhID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgaWdub3JlIChhZGRfd29ya2VyIH5yZXBsYWNlOnRydWUgdCB+a2V5IH5kYXRhIDogYm9vbCk7XG4gIG1heWJlX3Jlc2l6ZV90YWJsZSB0XG47O1xuXG5sZXQgYWRkIHQgfmtleSB+ZGF0YSA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIGxldCBhZGRlZCA9IGFkZF93b3JrZXIgfnJlcGxhY2U6ZmFsc2UgdCB+a2V5IH5kYXRhIGluXG4gIGlmIGFkZGVkXG4gIHRoZW4gKFxuICAgIG1heWJlX3Jlc2l6ZV90YWJsZSB0O1xuICAgIGBPaylcbiAgZWxzZSBgRHVwbGljYXRlXG47O1xuXG5sZXQgYWRkX2V4biB0IH5rZXkgfmRhdGEgPVxuICBtYXRjaCBhZGQgdCB+a2V5IH5kYXRhIHdpdGhcbiAgfCBgT2sgLT4gKClcbiAgfCBgRHVwbGljYXRlIC0+XG4gICAgbGV0IHNleHBfb2Zfa2V5ID0gc2V4cF9vZl9rZXkgdCBpblxuICAgIGxldCBlcnJvciA9IEVycm9yLmNyZWF0ZSBcIkhhc2h0YmwuYWRkX2V4biBnb3Qga2V5IGFscmVhZHkgcHJlc2VudFwiIGtleSBzZXhwX29mX2tleSBpblxuICAgIEVycm9yLnJhaXNlIGVycm9yXG47O1xuXG5sZXQgY2xlYXIgdCA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICB0LnRhYmxlLihpKSA8LSBBdmx0cmVlLmVtcHR5XG4gIGRvbmU7XG4gIHQubGVuZ3RoIDwtIDBcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsIHQga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgKCogd2l0aCBhIGdvb2QgaGFzaCBmdW5jdGlvbiB0aGVzZSBmaXJzdCB0d28gY2FzZXMgd2lsbCBiZSB0aGUgb3ZlcndoZWxtaW5nIG1ham9yaXR5LFxuICAgICBhbmQgQXZsdHJlZS5maW5kIGlzIHJlY3Vyc2l2ZSwgc28gaXQgY2FuJ3QgYmUgaW5saW5lZCwgc28gZG9pbmcgdGhpcyBhdm9pZHMgYVxuICAgICBmdW5jdGlvbiBjYWxsIGluIG1vc3QgY2FzZXMuICopXG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXlcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgdiBlbHNlIGlmX25vdF9mb3VuZCBrZXlcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kX2FuZF9jYWxsIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwxIHQga2V5IH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleSBhXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIHYgYSBlbHNlIGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRfYW5kX2NhbGwxIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwyIHQga2V5IH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleSBhIGJcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgdiBhIGIgZWxzZSBpZl9ub3RfZm91bmQga2V5IGEgYlxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRfYW5kX2NhbGwyIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsIHQga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgKCogd2l0aCBhIGdvb2QgaGFzaCBmdW5jdGlvbiB0aGVzZSBmaXJzdCB0d28gY2FzZXMgd2lsbCBiZSB0aGUgb3ZlcndoZWxtaW5nIG1ham9yaXR5LFxuICAgICBhbmQgQXZsdHJlZS5maW5kIGlzIHJlY3Vyc2l2ZSwgc28gaXQgY2FuJ3QgYmUgaW5saW5lZCwgc28gZG9pbmcgdGhpcyBhdm9pZHMgYVxuICAgICBmdW5jdGlvbiBjYWxsIGluIG1vc3QgY2FzZXMuICopXG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXlcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgfmtleTprIH5kYXRhOnYgZWxzZSBpZl9ub3RfZm91bmQga2V5XG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZGlfYW5kX2NhbGwgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwxIHQga2V5IH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleSBhXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIH5rZXk6ayB+ZGF0YTp2IGEgZWxzZSBpZl9ub3RfZm91bmQga2V5IGFcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kaV9hbmRfY2FsbDEgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwyIHQga2V5IH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleSBhIGJcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgfmtleTprIH5kYXRhOnYgYSBiIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhIGJcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kaV9hbmRfY2FsbDJcbiAgICAgIHRyZWVcbiAgICAgIH5jb21wYXJlOihjb21wYXJlX2tleSB0KVxuICAgICAga2V5XG4gICAgICB+YVxuICAgICAgfmJcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmQgPVxuICBsZXQgaWZfZm91bmQgdiA9IFNvbWUgdiBpblxuICBsZXQgaWZfbm90X2ZvdW5kIF8gPSBOb25lIGluXG4gIGZ1biB0IGtleSAtPiBmaW5kX2FuZF9jYWxsIHQga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgbWVtIHQga2V5ID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gZmFsc2VcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IF8gfSAtPiBjb21wYXJlX2tleSB0IGsga2V5ID0gMFxuICB8IHRyZWUgLT4gQXZsdHJlZS5tZW0gdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5XG47O1xuXG5sZXQgcmVtb3ZlIHQga2V5ID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgbGV0IGkgPSBzbG90IHQga2V5IGluXG4gIGxldCByb290ID0gdC50YWJsZS4oaSkgaW5cbiAgbGV0IHJlbW92ZWQgPSByZWYgZmFsc2UgaW5cbiAgbGV0IG5ld19yb290ID0gQXZsdHJlZS5yZW1vdmUgcm9vdCB+cmVtb3ZlZCB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IGluXG4gIGlmIG5vdCAocGh5c19lcXVhbCByb290IG5ld19yb290KSB0aGVuIHQudGFibGUuKGkpIDwtIG5ld19yb290O1xuICBpZiAhcmVtb3ZlZCB0aGVuIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMVxuOztcblxubGV0IGxlbmd0aCB0ID0gdC5sZW5ndGhcbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBpZiBsZW5ndGggdCA9IDBcbiAgdGhlbiBpbml0XG4gIGVsc2UgKFxuICAgIGxldCBuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgICBsZXQgbSA9IHQubXV0YXRpb25fYWxsb3dlZCBpblxuICAgIG1hdGNoXG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gZmFsc2U7XG4gICAgICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICAgICAgbWF0Y2ggQXJyYXkudW5zYWZlX2dldCB0LnRhYmxlIGkgd2l0aFxuICAgICAgICB8IEF2bHRyZWUuRW1wdHkgLT4gKClcbiAgICAgICAgfCBBdmx0cmVlLkxlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGFjYyA6PSBmIH5rZXkgfmRhdGEgIWFjY1xuICAgICAgICB8IGJ1Y2tldCAtPiBhY2MgOj0gQXZsdHJlZS5mb2xkIGJ1Y2tldCB+aW5pdDohYWNjIH5mXG4gICAgICBkb25lXG4gICAgd2l0aFxuICAgIHwgKCkgLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBtO1xuICAgICAgIWFjY1xuICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIG07XG4gICAgICByYWlzZSBleG4pXG47O1xuXG5sZXQgaXRlcmkgdCB+ZiA9XG4gIGlmIHQubGVuZ3RoID0gMFxuICB0aGVuICgpXG4gIGVsc2UgKFxuICAgIGxldCBuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbSA9IHQubXV0YXRpb25fYWxsb3dlZCBpblxuICAgIG1hdGNoXG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gZmFsc2U7XG4gICAgICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICAgICAgbWF0Y2ggQXJyYXkudW5zYWZlX2dldCB0LnRhYmxlIGkgd2l0aFxuICAgICAgICB8IEF2bHRyZWUuRW1wdHkgLT4gKClcbiAgICAgICAgfCBBdmx0cmVlLkxlYWYgeyBrZXk7IHZhbHVlID0gZGF0YSB9IC0+IGYgfmtleSB+ZGF0YVxuICAgICAgICB8IGJ1Y2tldCAtPiBBdmx0cmVlLml0ZXIgYnVja2V0IH5mXG4gICAgICBkb25lXG4gICAgd2l0aFxuICAgIHwgKCkgLT4gdC5tdXRhdGlvbl9hbGxvd2VkIDwtIG1cbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBtO1xuICAgICAgcmFpc2UgZXhuKVxuOztcblxubGV0IGl0ZXIgdCB+ZiA9IGl0ZXJpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG5sZXQgaXRlcl9rZXlzIHQgfmYgPSBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YTpfIC0+IGYga2V5KSBbQG5vbnRhaWxdXG5cbmxldCByZWMgY2hvb3NlX25vbmVtcHR5IHRhYmxlIGkgPVxuICBsZXQgYXZsdHJlZSA9IEFycmF5LnVuc2FmZV9nZXQgdGFibGUgaSBpblxuICBpZiBBdmx0cmVlLmlzX2VtcHR5IGF2bHRyZWVcbiAgdGhlbiBjaG9vc2Vfbm9uZW1wdHkgdGFibGUgKChpICsgMSkgbGFuZCAoQXJyYXkubGVuZ3RoIHRhYmxlIC0gMSkpXG4gIGVsc2UgQXZsdHJlZS5jaG9vc2VfZXhuIGF2bHRyZWVcbjs7XG5cbmxldCBjaG9vc2VfZXhuIHQgPVxuICBpZiB0Lmxlbmd0aCA9IDAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSGFzaHRibC5jaG9vc2VfZXhuXSBvZiBlbXB0eSBoYXNodGJsXCIgW10pO1xuICBjaG9vc2Vfbm9uZW1wdHkgdC50YWJsZSAwXG47O1xuXG5sZXQgY2hvb3NlIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGNob29zZV9ub25lbXB0eSB0LnRhYmxlIDApXG5cbmxldCBjaG9vc2VfcmFuZG9tbHlfbm9uZW1wdHkgfnJhbmRvbV9zdGF0ZSB0ID1cbiAgbGV0IHN0YXJ0X2lkeCA9IFJhbmRvbS5TdGF0ZS5pbnQgcmFuZG9tX3N0YXRlIChBcnJheS5sZW5ndGggdC50YWJsZSkgaW5cbiAgY2hvb3NlX25vbmVtcHR5IHQudGFibGUgc3RhcnRfaWR4XG47O1xuXG5sZXQgY2hvb3NlX3JhbmRvbWx5ID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIHQgPVxuICBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGNob29zZV9yYW5kb21seV9ub25lbXB0eSB+cmFuZG9tX3N0YXRlIHQpXG47O1xuXG5sZXQgY2hvb3NlX3JhbmRvbWx5X2V4biA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSB0ID1cbiAgaWYgdC5sZW5ndGggPSAwXG4gIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0hhc2h0YmwuY2hvb3NlX3JhbmRvbWx5X2V4bl0gb2YgZW1wdHkgaGFzaHRibFwiIFtdKTtcbiAgY2hvb3NlX3JhbmRvbWx5X25vbmVtcHR5IH5yYW5kb21fc3RhdGUgdFxuOztcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfa2V5IGludmFyaWFudF9kYXRhIHQgPVxuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgQXZsdHJlZS5pbnZhcmlhbnQgdC50YWJsZS4oaSkgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpXG4gIGRvbmU7XG4gIGxldCByZWFsX2xlbiA9XG4gICAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5IH5kYXRhIGkgLT5cbiAgICAgIGludmFyaWFudF9rZXkga2V5O1xuICAgICAgaW52YXJpYW50X2RhdGEgZGF0YTtcbiAgICAgIGkgKyAxKVxuICBpblxuICBhc3NlcnQgKHJlYWxfbGVuID0gdC5sZW5ndGgpXG47O1xuXG5sZXQgZmluZF9leG4gPVxuICBsZXQgaWZfZm91bmQgdiBfID0gdiBpblxuICBsZXQgaWZfbm90X2ZvdW5kIGsgdCA9XG4gICAgcmFpc2VcbiAgICAgIChOb3RfZm91bmRfcyAoTGlzdCBbIEF0b20gXCJIYXNodGJsLmZpbmRfZXhuOiBub3QgZm91bmRcIjsgdC5oYXNoYWJsZS5zZXhwX29mX3QgayBdKSlcbiAgaW5cbiAgbGV0IGZpbmRfZXhuIHQga2V5ID0gZmluZF9hbmRfY2FsbDEgdCBrZXkgfmE6dCB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfZXhuXG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgZmFsc2UpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBleGlzdHMgdCB+ZiA9IGV4aXN0c2kgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cbmxldCBmb3JfYWxsaSB0IH5mID0gbm90IChleGlzdHNpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IG5vdCAoZiB+a2V5IH5kYXRhKSkpXG5sZXQgZm9yX2FsbCB0IH5mID0gbm90IChleGlzdHNpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gbm90IChmIGRhdGEpKSlcblxubGV0IGNvdW50aSB0IH5mID1cbiAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKSBbQG5vbnRhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbjs7XG5cbmxldCBjb3VudCB0IH5mID1cbiAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgYWNjIC0+IGlmIGYgZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgbmV3X3QgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBzZXQgbmV3X3QgfmtleSB+ZGF0YTooZiB+a2V5IH5kYXRhKSk7XG4gIG5ld190XG47O1xuXG5sZXQgbWFwIHQgfmYgPSBtYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKSBbQG5vbnRhaWxdXG5sZXQgY29weSB0ID0gbWFwIHQgfmY6Rm4uaWRcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgbmV3X3QgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIG1hdGNoIGYgfmtleSB+ZGF0YSB3aXRoXG4gICAgfCBTb21lIG5ld19kYXRhIC0+IHNldCBuZXdfdCB+a2V5IH5kYXRhOm5ld19kYXRhXG4gICAgfCBOb25lIC0+ICgpKTtcbiAgbmV3X3Rcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgZmlsdGVyX21hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gU29tZSBkYXRhIGVsc2UgTm9uZSkgW0Bub250YWlsXVxuOztcblxubGV0IGZpbHRlciB0IH5mID0gZmlsdGVyaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSkgW0Bub250YWlsXVxubGV0IGZpbHRlcl9rZXlzIHQgfmYgPSBmaWx0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpIFtAbm9udGFpbF1cblxubGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgPVxuICBsZXQgdDAgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBsZXQgdDEgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIG1hdGNoIChmIH5rZXkgfmRhdGEgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgfCBGaXJzdCBuZXdfZGF0YSAtPiBzZXQgdDAgfmtleSB+ZGF0YTpuZXdfZGF0YVxuICAgIHwgU2Vjb25kIG5ld19kYXRhIC0+IHNldCB0MSB+a2V5IH5kYXRhOm5ld19kYXRhKTtcbiAgdDAsIHQxXG47O1xuXG5sZXQgcGFydGl0aW9uX21hcCB0IH5mID0gcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cblxubGV0IHBhcnRpdGlvbmlfdGYgdCB+ZiA9XG4gIHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIEZpcnN0IGRhdGEgZWxzZSBTZWNvbmQgZGF0YSkgXG4gIFtAbm9udGFpbF1cbjs7XG5cbmxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IHBhcnRpdGlvbmlfdGYgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cblxubGV0IGZpbmRfb3JfYWRkIHQgaWQgfmRlZmF1bHQgPVxuICBmaW5kX2FuZF9jYWxsXG4gICAgdFxuICAgIGlkXG4gICAgfmlmX2ZvdW5kOihmdW4gZGF0YSAtPiBkYXRhKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biBrZXkgLT5cbiAgICAgIGxldCBkZWZhdWx0ID0gZGVmYXVsdCAoKSBpblxuICAgICAgc2V0IHQgfmtleSB+ZGF0YTpkZWZhdWx0O1xuICAgICAgZGVmYXVsdCkgW0Bub250YWlsXVxuOztcblxubGV0IGZpbmRpX29yX2FkZCB0IGlkIH5kZWZhdWx0ID1cbiAgZmluZF9hbmRfY2FsbFxuICAgIHRcbiAgICBpZFxuICAgIH5pZl9mb3VuZDooZnVuIGRhdGEgLT4gZGF0YSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4ga2V5IC0+XG4gICAgICBsZXQgZGVmYXVsdCA9IGRlZmF1bHQga2V5IGluXG4gICAgICBzZXQgdCB+a2V5IH5kYXRhOmRlZmF1bHQ7XG4gICAgICBkZWZhdWx0KSBbQG5vbnRhaWxdXG47O1xuXG4oKiBTb21lIGhhc2h0YmwgaW1wbGVtZW50YXRpb25zIG1heSBiZSBhYmxlIHRvIHBlcmZvcm0gdGhpcyBtb3JlIGVmZmljaWVudGx5IHRoYW4gdHdvXG4gICBzZXBhcmF0ZSBsb29rdXBzICopXG5sZXQgZmluZF9hbmRfcmVtb3ZlIHQgaWQgPVxuICBsZXQgcmVzdWx0ID0gZmluZCB0IGlkIGluXG4gIGlmIE9wdGlvbi5pc19zb21lIHJlc3VsdCB0aGVuIHJlbW92ZSB0IGlkO1xuICByZXN1bHRcbjs7XG5cbmxldCBjaGFuZ2UgdCBpZCB+ZiA9XG4gIG1hdGNoIGYgKGZpbmQgdCBpZCkgd2l0aFxuICB8IE5vbmUgLT4gcmVtb3ZlIHQgaWRcbiAgfCBTb21lIGRhdGEgLT4gc2V0IHQgfmtleTppZCB+ZGF0YVxuOztcblxubGV0IHVwZGF0ZV9hbmRfcmV0dXJuIHQgaWQgfmYgPVxuICBsZXQgZGF0YSA9IGYgKGZpbmQgdCBpZCkgaW5cbiAgc2V0IHQgfmtleTppZCB+ZGF0YTtcbiAgZGF0YVxuOztcblxubGV0IHVwZGF0ZSB0IGlkIH5mID0gaWdub3JlICh1cGRhdGVfYW5kX3JldHVybiB0IGlkIH5mIDogXylcblxubGV0IGluY3JfYnkgfnJlbW92ZV9pZl96ZXJvIHQga2V5IGJ5ID1cbiAgaWYgcmVtb3ZlX2lmX3plcm9cbiAgdGhlblxuICAgIGNoYW5nZSB0IGtleSB+ZjooZnVuIG9wdCAtPlxuICAgICAgbWF0Y2ggYnkgKyBPcHRpb24udmFsdWUgb3B0IH5kZWZhdWx0OjAgd2l0aFxuICAgICAgfCAwIC0+IE5vbmVcbiAgICAgIHwgbiAtPiBTb21lIG4pXG4gIGVsc2VcbiAgICB1cGRhdGUgdCBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gYnlcbiAgICAgIHwgU29tZSBpIC0+IGJ5ICsgaSlcbjs7XG5cbmxldCBpbmNyID8oYnkgPSAxKSA/KHJlbW92ZV9pZl96ZXJvID0gZmFsc2UpIHQga2V5ID0gaW5jcl9ieSB+cmVtb3ZlX2lmX3plcm8gdCBrZXkgYnlcbmxldCBkZWNyID8oYnkgPSAxKSA/KHJlbW92ZV9pZl96ZXJvID0gZmFsc2UpIHQga2V5ID0gaW5jcl9ieSB+cmVtb3ZlX2lmX3plcm8gdCBrZXkgKC1ieSlcblxubGV0IGFkZF9tdWx0aSB0IH5rZXkgfmRhdGEgPVxuICB1cGRhdGUgdCBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IFsgZGF0YSBdXG4gICAgfCBTb21lIGwgLT4gZGF0YSA6OiBsKVxuOztcblxubGV0IHJlbW92ZV9tdWx0aSB0IGtleSA9XG4gIG1hdGNoIGZpbmQgdCBrZXkgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIFtdIHwgU29tZSBbIF8gXSAtPiByZW1vdmUgdCBrZXlcbiAgfCBTb21lIChfIDo6IHRsKSAtPiBzZXQgdCB+a2V5IH5kYXRhOnRsXG47O1xuXG5sZXQgZmluZF9tdWx0aSB0IGtleSA9XG4gIG1hdGNoIGZpbmQgdCBrZXkgd2l0aFxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIGwgLT4gbFxuOztcblxubGV0IGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGEgcm93cyA9XG4gIGxldCBzaXplID1cbiAgICBtYXRjaCBzaXplIHdpdGhcbiAgICB8IFNvbWUgcyAtPiBzXG4gICAgfCBOb25lIC0+IExpc3QubGVuZ3RoIHJvd3NcbiAgaW5cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlIH5zaXplICgpIGluXG4gIGxldCBkdXBlcyA9IHJlZiBbXSBpblxuICBMaXN0Lml0ZXIgcm93cyB+ZjooZnVuIHIgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByIGluXG4gICAgbGV0IGRhdGEgPSBnZXRfZGF0YSByIGluXG4gICAgaWYgbWVtIHJlcyBrZXkgdGhlbiBkdXBlcyA6PSBrZXkgOjogIWR1cGVzIGVsc2Ugc2V0IHJlcyB+a2V5IH5kYXRhKTtcbiAgbWF0Y2ggIWR1cGVzIHdpdGhcbiAgfCBbXSAtPiBgT2sgcmVzXG4gIHwga2V5cyAtPiBgRHVwbGljYXRlX2tleXMgKExpc3QuZGVkdXBfYW5kX3NvcnQgfmNvbXBhcmU6aGFzaGFibGUuSGFzaGFibGUuY29tcGFyZSBrZXlzKVxuOztcblxubGV0IGNyZWF0ZV9tYXBwZWRfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGEgcm93cyA9XG4gIGxldCBzaXplID1cbiAgICBtYXRjaCBzaXplIHdpdGhcbiAgICB8IFNvbWUgcyAtPiBzXG4gICAgfCBOb25lIC0+IExpc3QubGVuZ3RoIHJvd3NcbiAgaW5cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgfnNpemUgfmhhc2hhYmxlICgpIGluXG4gIExpc3QuaXRlciByb3dzIH5mOihmdW4gciAtPlxuICAgIGxldCBrZXkgPSBnZXRfa2V5IHIgaW5cbiAgICBsZXQgZGF0YSA9IGdldF9kYXRhIHIgaW5cbiAgICBhZGRfbXVsdGkgcmVzIH5rZXkgfmRhdGEpO1xuICByZXNcbjs7XG5cbmxldCBvZl9hbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleTpmc3QgfmdldF9kYXRhOnNuZCBsc3Qgd2l0aFxuICB8IGBPayB0IC0+IGBPayB0XG4gIHwgYER1cGxpY2F0ZV9rZXlzIGsgLT4gYER1cGxpY2F0ZV9rZXkgKExpc3QuaGRfZXhuIGspXG47O1xuXG5sZXQgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5OmZzdCB+Z2V0X2RhdGE6c25kIGxzdFxuOztcblxubGV0IG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgbWF0Y2ggb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3Qgd2l0aFxuICB8IGBPayB2IC0+IFJlc3VsdC5PayB2XG4gIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgbGV0IHNleHBfb2Zfa2V5ID0gaGFzaGFibGUuSGFzaGFibGUuc2V4cF9vZl90IGluXG4gICAgT3JfZXJyb3IuZXJyb3IgXCJIYXNodGJsLm9mX2FsaXN0X2V4bjogZHVwbGljYXRlIGtleVwiIGtleSBzZXhwX29mX2tleVxuOztcblxubGV0IG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0IHdpdGhcbiAgfCBSZXN1bHQuT2sgdiAtPiB2XG4gIHwgUmVzdWx0LkVycm9yIGUgLT4gRXJyb3IucmFpc2UgZVxuOztcblxubGV0IG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgY3JlYXRlX21hcHBlZF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5OmZzdCB+Z2V0X2RhdGE6c25kIGxzdFxuOztcblxubGV0IHRvX2FsaXN0IHQgPSBmb2xkIH5mOihmdW4gfmtleSB+ZGF0YSBsaXN0IC0+IChrZXksIGRhdGEpIDo6IGxpc3QpIH5pbml0OltdIHRcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2tleSBzZXhwX29mX2RhdGEgdCA9XG4gIHRcbiAgfD4gdG9fYWxpc3RcbiAgfD4gTGlzdC5zb3J0IH5jb21wYXJlOihmdW4gKGsxLCBfKSAoazIsIF8pIC0+IHQuaGFzaGFibGUuY29tcGFyZSBrMSBrMilcbiAgfD4gc2V4cF9vZl9saXN0IChzZXhwX29mX3BhaXIgc2V4cF9vZl9rZXkgc2V4cF9vZl9kYXRhKVxuOztcblxubGV0IHRfb2Zfc2V4cCB+aGFzaGFibGUga19vZl9zZXhwIGRfb2Zfc2V4cCBzZXhwID1cbiAgbGV0IGFsaXN0ID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAga19vZl9zZXhwIGRfb2Zfc2V4cCkgc2V4cCBpblxuICBtYXRjaCBvZl9hbGlzdCB+aGFzaGFibGUgYWxpc3QgfnNpemU6KExpc3QubGVuZ3RoIGFsaXN0KSB3aXRoXG4gIHwgYE9rIHYgLT4gdlxuICB8IGBEdXBsaWNhdGVfa2V5IGsgLT5cbiAgICAoKiBmaW5kIHRoZSBzZXhwIG9mIGEgZHVwbGljYXRlIGtleSwgc28gdGhlIGVycm9yIGlzIG5hcnJvd2VkIHRvIGEga2V5IGFuZCBub3RcbiAgICAgICB0aGUgd2hvbGUgbWFwICopXG4gICAgbGV0IGFsaXN0X3NleHBzID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAgRm4uaWQgRm4uaWQpIHNleHAgaW5cbiAgICBsZXQgZm91bmRfZmlyc3RfayA9IHJlZiBmYWxzZSBpblxuICAgIExpc3QuaXRlcjJfZXhuIGFsaXN0IGFsaXN0X3NleHBzIH5mOihmdW4gKGsyLCBfKSAoazJfc2V4cCwgXykgLT5cbiAgICAgIGlmIGhhc2hhYmxlLmNvbXBhcmUgayBrMiA9IDBcbiAgICAgIHRoZW5cbiAgICAgICAgaWYgIWZvdW5kX2ZpcnN0X2tcbiAgICAgICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiSGFzaHRibC50X29mX3NleHA6IGR1cGxpY2F0ZSBrZXlcIiBrMl9zZXhwXG4gICAgICAgIGVsc2UgZm91bmRfZmlyc3RfayA6PSB0cnVlKTtcbiAgICBhc3NlcnQgZmFsc2Vcbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hclxuICAodHlwZSBrIHYpXG4gIChrX2dyYW1tYXIgOiBrIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAodl9ncmFtbWFyIDogdiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiAoaywgdikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QuQXNzb2MudF9zZXhwX2dyYW1tYXIga19ncmFtbWFyIHZfZ3JhbW1hcilcbjs7XG5cbmxldCBrZXlzIHQgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhOl8gYWNjIC0+IGtleSA6OiBhY2MpXG5sZXQgZGF0YSB0ID0gZm9sZCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSBsaXN0IC0+IGRhdGEgOjogbGlzdCkgfmluaXQ6W10gdFxuXG5sZXQgYWRkX3RvX2dyb3VwcyBncm91cHMgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIH5yb3dzID1cbiAgTGlzdC5pdGVyIHJvd3MgfmY6KGZ1biByb3cgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByb3cgaW5cbiAgICBsZXQgZGF0YSA9IGdldF9kYXRhIHJvdyBpblxuICAgIGxldCBkYXRhID1cbiAgICAgIG1hdGNoIGZpbmQgZ3JvdXBzIGtleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gZGF0YVxuICAgICAgfCBTb21lIG9sZCAtPiBjb21iaW5lIG9sZCBkYXRhXG4gICAgaW5cbiAgICBzZXQgZ3JvdXBzIH5rZXkgfmRhdGEpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSByb3dzID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlICgpIGluXG4gIGFkZF90b19ncm91cHMgcmVzIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSB+cm93cztcbiAgcmVzXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyA9XG4gIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGE6Rm4uaWQgcm93c1xuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3MgPVxuICBtYXRjaCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzIHdpdGhcbiAgfCBgT2sgdCAtPiBSZXN1bHQuT2sgdFxuICB8IGBEdXBsaWNhdGVfa2V5cyBrZXlzIC0+XG4gICAgbGV0IHNleHBfb2Zfa2V5ID0gaGFzaGFibGUuSGFzaGFibGUuc2V4cF9vZl90IGluXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJIYXNodGJsLmNyZWF0ZV93aXRoX2tleTogZHVwbGljYXRlIGtleXNcIlxuICAgICAgICAgWyBcImtleXNcIiwgc2V4cF9vZl9saXN0IHNleHBfb2Zfa2V5IGtleXMgXSlcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXlfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyA9XG4gIE9yX2Vycm9yLm9rX2V4biAoY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cylcbjs7XG5cbmxldCBtZXJnZSA9XG4gIGxldCBtYXliZV9zZXQgdCB+a2V5IH5mIGQgPVxuICAgIG1hdGNoIGYgfmtleSBkIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgdiAtPiBzZXQgdCB+a2V5IH5kYXRhOnZcbiAgaW5cbiAgZnVuIHRfbGVmdCB0X3JpZ2h0IH5mIC0+XG4gICAgaWYgbm90IChIYXNoYWJsZS5lcXVhbCB0X2xlZnQuaGFzaGFibGUgdF9yaWdodC5oYXNoYWJsZSlcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiSGFzaHRibC5tZXJnZTogZGlmZmVyZW50ICdoYXNoYWJsZScgdmFsdWVzXCI7XG4gICAgbGV0IG5ld190ID1cbiAgICAgIGNyZWF0ZVxuICAgICAgICB+Z3Jvd3RoX2FsbG93ZWQ6dF9sZWZ0Lmdyb3d0aF9hbGxvd2VkXG4gICAgICAgIH5oYXNoYWJsZTp0X2xlZnQuaGFzaGFibGVcbiAgICAgICAgfnNpemU6dF9sZWZ0Lmxlbmd0aFxuICAgICAgICAoKVxuICAgIGluXG4gICAgd2l0aG91dF9tdXRhdGluZyB0X2xlZnQgKGZ1biAoKSAtPlxuICAgICAgd2l0aG91dF9tdXRhdGluZyB0X3JpZ2h0IChmdW4gKCkgLT5cbiAgICAgICAgaXRlcmkgdF9sZWZ0IH5mOihmdW4gfmtleSB+ZGF0YTpsZWZ0IC0+XG4gICAgICAgICAgbWF0Y2ggZmluZCB0X3JpZ2h0IGtleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG1heWJlX3NldCBuZXdfdCB+a2V5IH5mIChgTGVmdCBsZWZ0KVxuICAgICAgICAgIHwgU29tZSByaWdodCAtPiBtYXliZV9zZXQgbmV3X3QgfmtleSB+ZiAoYEJvdGggKGxlZnQsIHJpZ2h0KSkpO1xuICAgICAgICBpdGVyaSB0X3JpZ2h0IH5mOihmdW4gfmtleSB+ZGF0YTpyaWdodCAtPlxuICAgICAgICAgIG1hdGNoIGZpbmQgdF9sZWZ0IGtleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG1heWJlX3NldCBuZXdfdCB+a2V5IH5mIChgUmlnaHQgcmlnaHQpXG4gICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgICAoKiBhbHJlYWR5IGRvbmUgYWJvdmUgKikpIFtAbm9udGFpbF0pIFtAbm9udGFpbF0pO1xuICAgIG5ld190XG47O1xuXG5sZXQgbWVyZ2VfaW50byB+c3JjIH5kc3QgfmYgPVxuICBpdGVyaSBzcmMgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbGV0IGRzdF9kYXRhID0gZmluZCBkc3Qga2V5IGluXG4gICAgbGV0IGFjdGlvbiA9IHdpdGhvdXRfbXV0YXRpbmcgZHN0IChmdW4gKCkgLT4gZiB+a2V5IGRhdGEgZHN0X2RhdGEpIGluXG4gICAgbWF0Y2ggKGFjdGlvbiA6IF8gTWVyZ2VfaW50b19hY3Rpb24udCkgd2l0aFxuICAgIHwgUmVtb3ZlIC0+IHJlbW92ZSBkc3Qga2V5XG4gICAgfCBTZXRfdG8gZGF0YSAtPlxuICAgICAgKG1hdGNoIGRzdF9kYXRhIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gc2V0IGRzdCB+a2V5IH5kYXRhXG4gICAgICAgfCBTb21lIGRzdF9kYXRhIC0+IGlmIG5vdCAocGh5c19lcXVhbCBkc3RfZGF0YSBkYXRhKSB0aGVuIHNldCBkc3QgfmtleSB+ZGF0YSkpIFtAbm9udGFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbjs7XG5cbmxldCBmaWx0ZXJpX2lucGxhY2UgdCB+ZiA9XG4gIGxldCB0b19yZW1vdmUgPVxuICAgIGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgYWMgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gYWMgZWxzZSBrZXkgOjogYWMpXG4gIGluXG4gIExpc3QuaXRlciB0b19yZW1vdmUgfmY6KGZ1biBrZXkgLT4gcmVtb3ZlIHQga2V5KVxuOztcblxubGV0IGZpbHRlcl9pbnBsYWNlIHQgfmYgPSBmaWx0ZXJpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cbmxldCBmaWx0ZXJfa2V5c19pbnBsYWNlIHQgfmYgPSBmaWx0ZXJpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXkgfmRhdGE6XyAtPiBmIGtleSkgW0Bub250YWlsXVxuXG5sZXQgZmlsdGVyX21hcGlfaW5wbGFjZSB0IH5mID1cbiAgbGV0IG1hcF9yZXN1bHRzID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSBhYyAtPiAoa2V5LCBmIH5rZXkgfmRhdGEpIDo6IGFjKSBpblxuICBMaXN0Lml0ZXIgbWFwX3Jlc3VsdHMgfmY6KGZ1biAoa2V5LCByZXN1bHQpIC0+XG4gICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmVtb3ZlIHQga2V5XG4gICAgfCBTb21lIGRhdGEgLT4gc2V0IHQgfmtleSB+ZGF0YSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwX2lucGxhY2UgdCB+ZiA9XG4gIGZpbHRlcl9tYXBpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cbjs7XG5cbmxldCBtYXBpX2lucGxhY2UgdCB+ZiA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIHdpdGhvdXRfbXV0YXRpbmcgdCAoZnVuICgpIC0+XG4gICAgQXJyYXkuaXRlciB0LnRhYmxlIH5mOihBdmx0cmVlLm1hcGlfaW5wbGFjZSB+ZikgW0Bub250YWlsXSkgW0Bub250YWlsXVxuOztcblxubGV0IG1hcF9pbnBsYWNlIHQgfmYgPSBtYXBpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpIFtAbm9udGFpbF1cblxubGV0IGVxdWFsIGVxdWFsIHQgdCcgPVxuICBsZW5ndGggdCA9IGxlbmd0aCB0J1xuICAmJiAod2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICAgIHdpdGhvdXRfbXV0YXRpbmcgdCcgKGZ1biAoKSAtPlxuICAgICAgICAgIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgICAgICBtYXRjaCBmaW5kIHQnIGtleSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gci5yZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIHwgU29tZSBkYXRhJyAtPiBpZiBub3QgKGVxdWFsIGRhdGEgZGF0YScpIHRoZW4gci5yZXR1cm4gZmFsc2UpIFtAbm9udGFpbF0pO1xuICAgICAgICB0cnVlKSBbQG5vbnRhaWxdKVxuOztcblxubGV0IHNpbWlsYXIgPSBlcXVhbFxuXG5tb2R1bGUgQWNjZXNzb3JzID0gc3RydWN0XG4gIGxldCBpbnZhcmlhbnQgPSBpbnZhcmlhbnRcbiAgbGV0IGNob29zZSA9IGNob29zZVxuICBsZXQgY2hvb3NlX2V4biA9IGNob29zZV9leG5cbiAgbGV0IGNob29zZV9yYW5kb21seSA9IGNob29zZV9yYW5kb21seVxuICBsZXQgY2hvb3NlX3JhbmRvbWx5X2V4biA9IGNob29zZV9yYW5kb21seV9leG5cbiAgbGV0IGNsZWFyID0gY2xlYXJcbiAgbGV0IGNvcHkgPSBjb3B5XG4gIGxldCByZW1vdmUgPSByZW1vdmVcbiAgbGV0IHNldCA9IHNldFxuICBsZXQgYWRkID0gYWRkXG4gIGxldCBhZGRfZXhuID0gYWRkX2V4blxuICBsZXQgY2hhbmdlID0gY2hhbmdlXG4gIGxldCB1cGRhdGUgPSB1cGRhdGVcbiAgbGV0IHVwZGF0ZV9hbmRfcmV0dXJuID0gdXBkYXRlX2FuZF9yZXR1cm5cbiAgbGV0IGFkZF9tdWx0aSA9IGFkZF9tdWx0aVxuICBsZXQgcmVtb3ZlX211bHRpID0gcmVtb3ZlX211bHRpXG4gIGxldCBmaW5kX211bHRpID0gZmluZF9tdWx0aVxuICBsZXQgbWVtID0gbWVtXG4gIGxldCBpdGVyX2tleXMgPSBpdGVyX2tleXNcbiAgbGV0IGl0ZXIgPSBpdGVyXG4gIGxldCBpdGVyaSA9IGl0ZXJpXG4gIGxldCBleGlzdHMgPSBleGlzdHNcbiAgbGV0IGV4aXN0c2kgPSBleGlzdHNpXG4gIGxldCBmb3JfYWxsID0gZm9yX2FsbFxuICBsZXQgZm9yX2FsbGkgPSBmb3JfYWxsaVxuICBsZXQgY291bnQgPSBjb3VudFxuICBsZXQgY291bnRpID0gY291bnRpXG4gIGxldCBmb2xkID0gZm9sZFxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gIGxldCBpc19lbXB0eSA9IGlzX2VtcHR5XG4gIGxldCBtYXAgPSBtYXBcbiAgbGV0IG1hcGkgPSBtYXBpXG4gIGxldCBmaWx0ZXJfbWFwID0gZmlsdGVyX21hcFxuICBsZXQgZmlsdGVyX21hcGkgPSBmaWx0ZXJfbWFwaVxuICBsZXQgZmlsdGVyX2tleXMgPSBmaWx0ZXJfa2V5c1xuICBsZXQgZmlsdGVyID0gZmlsdGVyXG4gIGxldCBmaWx0ZXJpID0gZmlsdGVyaVxuICBsZXQgcGFydGl0aW9uX21hcCA9IHBhcnRpdGlvbl9tYXBcbiAgbGV0IHBhcnRpdGlvbl9tYXBpID0gcGFydGl0aW9uX21hcGlcbiAgbGV0IHBhcnRpdGlvbl90ZiA9IHBhcnRpdGlvbl90ZlxuICBsZXQgcGFydGl0aW9uaV90ZiA9IHBhcnRpdGlvbmlfdGZcbiAgbGV0IGZpbmRfb3JfYWRkID0gZmluZF9vcl9hZGRcbiAgbGV0IGZpbmRpX29yX2FkZCA9IGZpbmRpX29yX2FkZFxuICBsZXQgZmluZCA9IGZpbmRcbiAgbGV0IGZpbmRfZXhuID0gZmluZF9leG5cbiAgbGV0IGZpbmRfYW5kX2NhbGwgPSBmaW5kX2FuZF9jYWxsXG4gIGxldCBmaW5kX2FuZF9jYWxsMSA9IGZpbmRfYW5kX2NhbGwxXG4gIGxldCBmaW5kX2FuZF9jYWxsMiA9IGZpbmRfYW5kX2NhbGwyXG4gIGxldCBmaW5kaV9hbmRfY2FsbCA9IGZpbmRpX2FuZF9jYWxsXG4gIGxldCBmaW5kaV9hbmRfY2FsbDEgPSBmaW5kaV9hbmRfY2FsbDFcbiAgbGV0IGZpbmRpX2FuZF9jYWxsMiA9IGZpbmRpX2FuZF9jYWxsMlxuICBsZXQgZmluZF9hbmRfcmVtb3ZlID0gZmluZF9hbmRfcmVtb3ZlXG4gIGxldCB0b19hbGlzdCA9IHRvX2FsaXN0XG4gIGxldCBtZXJnZSA9IG1lcmdlXG4gIGxldCBtZXJnZV9pbnRvID0gbWVyZ2VfaW50b1xuICBsZXQga2V5cyA9IGtleXNcbiAgbGV0IGRhdGEgPSBkYXRhXG4gIGxldCBmaWx0ZXJfa2V5c19pbnBsYWNlID0gZmlsdGVyX2tleXNfaW5wbGFjZVxuICBsZXQgZmlsdGVyX2lucGxhY2UgPSBmaWx0ZXJfaW5wbGFjZVxuICBsZXQgZmlsdGVyaV9pbnBsYWNlID0gZmlsdGVyaV9pbnBsYWNlXG4gIGxldCBtYXBfaW5wbGFjZSA9IG1hcF9pbnBsYWNlXG4gIGxldCBtYXBpX2lucGxhY2UgPSBtYXBpX2lucGxhY2VcbiAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSA9IGZpbHRlcl9tYXBfaW5wbGFjZVxuICBsZXQgZmlsdGVyX21hcGlfaW5wbGFjZSA9IGZpbHRlcl9tYXBpX2lucGxhY2VcbiAgbGV0IGVxdWFsID0gZXF1YWxcbiAgbGV0IHNpbWlsYXIgPSBzaW1pbGFyXG4gIGxldCBpbmNyID0gaW5jclxuICBsZXQgZGVjciA9IGRlY3JcbiAgbGV0IHNleHBfb2Zfa2V5ID0gc2V4cF9vZl9rZXlcbmVuZFxuXG5tb2R1bGUgQ3JlYXRvcnMgKEtleSA6IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgaGFzaGFibGUgOiAnYSB0IEhhc2hhYmxlLnRcbmVuZCkgOiBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XyA9ICgnYSBLZXkudCwgJ2IpIHRcblxuICB2YWwgdF9vZl9zZXhwIDogKFNleHAudCAtPiAnYSBLZXkudCkgLT4gKFNleHAudCAtPiAnYikgLT4gU2V4cC50IC0+ICgnYSwgJ2IpIHRfXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzX2dlbmVyaWNcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRfXG4gICAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIEtleS50XG4gICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAnYSkgY3JlYXRlX29wdGlvbnMgOj1cbiAgICAgICAgKCdrZXksICdkYXRhLCAnYSkgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcbmVuZCA9IHN0cnVjdFxuICBsZXQgaGFzaGFibGUgPSBLZXkuaGFzaGFibGVcblxuICB0eXBlICgnYSwgJ2IpIHRfID0gKCdhIEtleS50LCAnYikgdFxuXG4gIGxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplICgpID0gY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgKClcbiAgbGV0IG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID0gb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG5cbiAgbGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAga19vZl9zZXhwIGRfb2Zfc2V4cCBzZXhwID0gdF9vZl9zZXhwIH5oYXNoYWJsZSBrX29mX3NleHAgZF9vZl9zZXhwIHNleHBcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPVxuICAgIG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgbCA9XG4gICAgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSBsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbCA9XG4gICAgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGwgPVxuICAgIGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IGxcbiAgOztcblxuICBsZXQgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbCA9XG4gICAgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IGxcbiAgOztcblxuICBsZXQgZ3JvdXAgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsID1cbiAgICBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsXG4gIDs7XG5lbmRcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcbiAgdHlwZSAnYSBrZXkgPSAnYVxuXG4gIGxldCBoYXNoYWJsZSA9IEhhc2hhYmxlLnBvbHlcbiAgbGV0IGNhcGFjaXR5ID0gY2FwYWNpdHlcblxuICBpbmNsdWRlIENyZWF0b3JzIChzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSAnYVxuXG4gICAgbGV0IGhhc2hhYmxlID0gaGFzaGFibGVcbiAgZW5kKVxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgPSB0X3NleHBfZ3JhbW1hclxuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIEhhc2hhYmxlID0gSGFzaGFibGUuSGFzaGFibGVcblxuICB0eXBlIG5vbnJlYyAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZSA9XG4gICAgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcblxuICBsZXQgaGFzaGFibGUgdCA9IHQuaGFzaGFibGVcbmVuZFxuXG5sZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtID1cbiAgY3JlYXRlIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoKVxuOztcblxubGV0IG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0X29yX2Vycm9yIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdF9leG4gfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3RfbXVsdGkgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IH5nZXRfZGF0YSBsID1cbiAgY3JlYXRlX21hcHBlZCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIGxcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgbCA9XG4gIGNyZWF0ZV93aXRoX2tleSB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbFxuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSBsID1cbiAgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSBsID1cbiAgY3JlYXRlX3dpdGhfa2V5X2V4biB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbFxuOztcblxubGV0IGdyb3VwID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsID1cbiAgZ3JvdXAgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsXG47O1xuXG5sZXQgaGFzaGFibGVfcyB0ID0gSGFzaGFibGUudG9fa2V5IHQuaGFzaGFibGVcblxubW9kdWxlIE0gKEsgOiBULlQpID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBLZXkuUyB3aXRoIHR5cGUgdCA6PSB0XG5lbmRcblxubW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcblxubGV0IHNleHBfb2ZfbV9fdCAodHlwZSBrKSAobW9kdWxlIEsgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBrKSBzZXhwX29mX3YgdCA9XG4gIHNleHBfb2ZfdCBLLnNleHBfb2ZfdCBzZXhwX29mX3YgdFxuOztcblxubGV0IG1fX3Rfb2Zfc2V4cCAodHlwZSBrKSAobW9kdWxlIEsgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBrKSB2X29mX3NleHAgc2V4cCA9XG4gIHRfb2Zfc2V4cCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSAobW9kdWxlIEspKSBLLnRfb2Zfc2V4cCB2X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGspIChtb2R1bGUgSyA6IE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gaykgdl9ncmFtbWFyID1cbiAgdF9zZXhwX2dyYW1tYXIgSy50X3NleHBfZ3JhbW1hciB2X2dyYW1tYXJcbjs7XG5cbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIGVxdWFsX3YgdDEgdDIgPSBlcXVhbCBlcXVhbF92IHQxIHQyXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSGFzaF9zZXRfaW50ZlxuXG5sZXQgaGFzaGFibGVfcyA9IEhhc2h0YmwuaGFzaGFibGVfc1xubGV0IGhhc2hhYmxlID0gSGFzaHRibC5Qcml2YXRlLmhhc2hhYmxlXG5sZXQgcG9seV9oYXNoYWJsZSA9IEhhc2h0YmwuUG9seS5oYXNoYWJsZVxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxudHlwZSAnYSB0ID0gKCdhLCB1bml0KSBIYXNodGJsLnRcbnR5cGUgJ2EgaGFzaF9zZXQgPSAnYSB0XG50eXBlICdhIGVsdCA9ICdhXG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGhhc2hhYmxlID0gaGFzaGFibGVcbiAgbGV0IGNsZWFyID0gSGFzaHRibC5jbGVhclxuICBsZXQgbGVuZ3RoID0gSGFzaHRibC5sZW5ndGhcbiAgbGV0IG1lbSA9IEhhc2h0YmwubWVtXG4gIGxldCBpc19lbXB0eSB0ID0gSGFzaHRibC5pc19lbXB0eSB0XG5cbiAgbGV0IGZpbmRfbWFwIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgSGFzaHRibC5pdGVyX2tleXMgdCB+ZjooZnVuIGVsdCAtPlxuICAgICAgICBtYXRjaCBmIGVsdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICB8IFNvbWUgXyBhcyBvIC0+IHIucmV0dXJuIG8pO1xuICAgICAgTm9uZSkgW0Bub250YWlsXVxuICA7O1xuXG4gIGxldCBmaW5kIHQgfmYgPSBmaW5kX21hcCB0IH5mOihmdW4gYSAtPiBpZiBmIGEgdGhlbiBTb21lIGEgZWxzZSBOb25lKSBbQG5vbnRhaWxdXG4gIGxldCBhZGQgdCBrID0gSGFzaHRibC5zZXQgdCB+a2V5OmsgfmRhdGE6KClcblxuICBsZXQgc3RyaWN0X2FkZCB0IGsgPVxuICAgIGlmIG1lbSB0IGtcbiAgICB0aGVuIE9yX2Vycm9yLmVycm9yX3N0cmluZyBcImVsZW1lbnQgYWxyZWFkeSBleGlzdHNcIlxuICAgIGVsc2UgKFxuICAgICAgSGFzaHRibC5zZXQgdCB+a2V5OmsgfmRhdGE6KCk7XG4gICAgICBSZXN1bHQuT2sgKCkpXG4gIDs7XG5cbiAgbGV0IHN0cmljdF9hZGRfZXhuIHQgayA9IE9yX2Vycm9yLm9rX2V4biAoc3RyaWN0X2FkZCB0IGspXG4gIGxldCByZW1vdmUgPSBIYXNodGJsLnJlbW92ZVxuXG4gIGxldCBzdHJpY3RfcmVtb3ZlIHQgayA9XG4gICAgaWYgbWVtIHQga1xuICAgIHRoZW4gKFxuICAgICAgcmVtb3ZlIHQgaztcbiAgICAgIFJlc3VsdC5PayAoKSlcbiAgICBlbHNlIE9yX2Vycm9yLmVycm9yIFwiZWxlbWVudCBub3QgaW4gc2V0XCIgayAoSGFzaHRibC5zZXhwX29mX2tleSB0KVxuICA7O1xuXG4gIGxldCBzdHJpY3RfcmVtb3ZlX2V4biB0IGsgPSBPcl9lcnJvci5va19leG4gKHN0cmljdF9yZW1vdmUgdCBrKVxuXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPVxuICAgIEhhc2h0YmwuZm9sZCB0IH5pbml0IH5mOihmdW4gfmtleSB+ZGF0YTooKSBhY2MgLT4gZiBhY2Mga2V5KSBbQG5vbnRhaWxdXG4gIDs7XG5cbiAgbGV0IGl0ZXIgdCB+ZiA9IEhhc2h0YmwuaXRlcl9rZXlzIHQgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG4gIGxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdCB+ZmluaXNoXG4gIGxldCB0b19saXN0ID0gSGFzaHRibC5rZXlzXG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2UgdCA9XG4gICAgc2V4cF9vZl9saXN0IHNleHBfb2ZfZSAodG9fbGlzdCB0IHw+IExpc3Quc29ydCB+Y29tcGFyZTooaGFzaGFibGUgdCkuY29tcGFyZSlcbiAgOztcblxuICBsZXQgdG9fYXJyYXkgdCA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgbGV0IGluZGV4ID0gcmVmIChsZW4gLSAxKSBpblxuICAgIGZvbGQgdCB+aW5pdDpbfHxdIH5mOihmdW4gYWNjIGtleSAtPlxuICAgICAgaWYgQXJyYXkubGVuZ3RoIGFjYyA9IDBcbiAgICAgIHRoZW4gQXJyYXkuY3JlYXRlIH5sZW4ga2V5XG4gICAgICBlbHNlIChcbiAgICAgICAgaW5kZXggOj0gIWluZGV4IC0gMTtcbiAgICAgICAgYWNjLighaW5kZXgpIDwtIGtleTtcbiAgICAgICAgYWNjKSlcbiAgOztcblxuICBsZXQgZXhpc3RzIHQgfmYgPSBIYXNodGJsLmV4aXN0c2kgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gZiBrZXkpIFtAbm9udGFpbF1cbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IG5vdCAoSGFzaHRibC5leGlzdHNpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IG5vdCAoZiBrZXkpKSlcbiAgbGV0IGVxdWFsIHQxIHQyID0gSGFzaHRibC5lcXVhbCAoZnVuICgpICgpIC0+IHRydWUpIHQxIHQyXG4gIGxldCBjb3B5IHQgPSBIYXNodGJsLmNvcHkgdFxuICBsZXQgZmlsdGVyIHQgfmYgPSBIYXNodGJsLmZpbHRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gZiBrZXkpIFtAbm9udGFpbF1cbiAgbGV0IHVuaW9uIHQxIHQyID0gSGFzaHRibC5tZXJnZSB0MSB0MiB+ZjooZnVuIH5rZXk6XyBfIC0+IFNvbWUgKCkpXG4gIGxldCBkaWZmIHQxIHQyID0gZmlsdGVyIHQxIH5mOihmdW4ga2V5IC0+IG5vdCAoSGFzaHRibC5tZW0gdDIga2V5KSlcblxuICBsZXQgaW50ZXIgdDEgdDIgPVxuICAgIGxldCBzbWFsbGVyLCBsYXJnZXIgPSBpZiBsZW5ndGggdDEgPiBsZW5ndGggdDIgdGhlbiB0MiwgdDEgZWxzZSB0MSwgdDIgaW5cbiAgICBIYXNodGJsLmZpbHRlcmkgc21hbGxlciB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gSGFzaHRibC5tZW0gbGFyZ2VyIGtleSlcbiAgOztcblxuICBsZXQgZmlsdGVyX2lucGxhY2UgdCB+ZiA9XG4gICAgbGV0IHRvX3JlbW92ZSA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIGFjIHggLT4gaWYgZiB4IHRoZW4gYWMgZWxzZSB4IDo6IGFjKSBpblxuICAgIExpc3QuaXRlciB0b19yZW1vdmUgfmY6KGZ1biB4IC0+IHJlbW92ZSB0IHgpXG4gIDs7XG5cbiAgbGV0IG9mX2hhc2h0Ymxfa2V5cyBoYXNodGJsID0gSGFzaHRibC5tYXAgaGFzaHRibCB+ZjppZ25vcmVcbiAgbGV0IHRvX2hhc2h0YmwgdCB+ZiA9IEhhc2h0YmwubWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBmIGtleSkgW0Bub250YWlsXVxuZW5kXG5cbmluY2x1ZGUgQWNjZXNzb3JzXG5cbmxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gPSBIYXNodGJsLmNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbVxuXG5sZXQgb2ZfbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgbGV0IHNpemUgPVxuICAgIG1hdGNoIHNpemUgd2l0aFxuICAgIHwgU29tZSB4IC0+IHhcbiAgICB8IE5vbmUgLT4gTGlzdC5sZW5ndGggbFxuICBpblxuICBsZXQgdCA9IEhhc2h0YmwuY3JlYXRlID9ncm93dGhfYWxsb3dlZCB+c2l6ZSBtIGluXG4gIExpc3QuaXRlciBsIH5mOihmdW4gayAtPiBhZGQgdCBrKTtcbiAgdFxuOztcblxubGV0IHRfb2Zfc2V4cCBtIGVfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgU2V4cC5BdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcIkhhc2hfc2V0LnRfb2Zfc2V4cCByZXF1aXJlcyBhIGxpc3RcIiBzZXhwXG4gIHwgU2V4cC5MaXN0IGxpc3QgLT5cbiAgICBsZXQgdCA9IGNyZWF0ZSBtIH5zaXplOihMaXN0Lmxlbmd0aCBsaXN0KSBpblxuICAgIExpc3QuaXRlciBsaXN0IH5mOihmdW4gc2V4cCAtPlxuICAgICAgbGV0IGUgPSBlX29mX3NleHAgc2V4cCBpblxuICAgICAgbWF0Y2ggc3RyaWN0X2FkZCB0IGUgd2l0aFxuICAgICAgfCBPayAoKSAtPiAoKVxuICAgICAgfCBFcnJvciBfIC0+IG9mX3NleHBfZXJyb3IgXCJIYXNoX3NldC50X29mX3NleHAgZ290IGEgZHVwbGljYXRlIGVsZW1lbnRcIiBzZXhwKTtcbiAgICB0XG47O1xuXG5tb2R1bGUgQ3JlYXRvcnMgKEVsdCA6IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgaGFzaGFibGUgOiAnYSB0IEhhc2hhYmxlLnRcbmVuZCkgOiBzaWdcbiAgdmFsIHRfb2Zfc2V4cCA6IChTZXhwLnQgLT4gJ2EgRWx0LnQpIC0+IFNleHAudCAtPiAnYSBFbHQudCB0XG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzX2dlbmVyaWNcbiAgICAgIHdpdGggdHlwZSAnYSB0IDo9ICdhIEVsdC50IHRcbiAgICAgIHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgRWx0LnRcbiAgICAgIHdpdGggdHlwZSAoJ2VsdCwgJ3opIGNyZWF0ZV9vcHRpb25zIDo9XG4gICAgICAgICgnZWx0LCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcbmVuZCA9IHN0cnVjdFxuICBsZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoKSA9XG4gICAgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoSGFzaGFibGUudG9fa2V5IEVsdC5oYXNoYWJsZSlcbiAgOztcblxuICBsZXQgb2ZfbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKEhhc2hhYmxlLnRvX2tleSBFbHQuaGFzaGFibGUpIGxcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIGVfb2Zfc2V4cCBzZXhwID0gdF9vZl9zZXhwIChIYXNoYWJsZS50b19rZXkgRWx0Lmhhc2hhYmxlKSBlX29mX3NleHAgc2V4cFxuZW5kXG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIGhhc2hfc2V0XG4gIHR5cGUgJ2EgZWx0ID0gJ2FcblxuICBsZXQgaGFzaGFibGUgPSBwb2x5X2hhc2hhYmxlXG5cbiAgaW5jbHVkZSBDcmVhdG9ycyAoc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2FcblxuICAgIGxldCBoYXNoYWJsZSA9IGhhc2hhYmxlXG4gIGVuZClcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbiAgbGV0IHRfc2V4cF9ncmFtbWFyIGdyYW1tYXIgPSBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG5lbmRcblxubW9kdWxlIE0gKEVsdCA6IFQuVCkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IEVsdC50IHRcbmVuZFxuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBlbHQpIHQgPVxuICBzZXhwX29mX3QgRWx0LnNleHBfb2ZfdCB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBlbHQpIHNleHAgPVxuICB0X29mX3NleHAgKG1vZHVsZSBFbHQpIEVsdC50X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGVsdCkgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChsaXN0X3NleHBfZ3JhbW1hciBFbHQudF9zZXhwX2dyYW1tYXIpXG47O1xuXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSB0MSB0MiA9IGVxdWFsIHQxIHQyXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBoYXNoYWJsZSA9IEhhc2h0YmwuUHJpdmF0ZS5oYXNoYWJsZVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIFByaW50ZlxubW9kdWxlIEJ5dGVzID0gQnl0ZXMwXG5pbmNsdWRlIEZsb2F0MFxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gZmxvYXQgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfZmxvYXRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2Zsb2F0IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IChnbG9iYWxpemUgOiB0IC0+IHQpID0gKGdsb2JhbGl6ZV9mbG9hdCA6IHQgLT4gdClcbiAgbGV0IHRfb2Zfc2V4cCA9IChmbG9hdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9mbG9hdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBmbG9hdF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuY29tcGFyZVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgdG9fZmxvYXQgeCA9IHhcbmxldCBvZl9mbG9hdCB4ID0geFxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICB0cnkgZmxvYXRfb2Zfc3RyaW5nIHMgd2l0aFxuICB8IF8gLT4gaW52YWxpZF9hcmdmIFwiRmxvYXQub2Zfc3RyaW5nICVzXCIgcyAoKVxuOztcblxubGV0IG9mX3N0cmluZ19vcHQgPSBmbG9hdF9vZl9zdHJpbmdfb3B0XG5cbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxuKCogU3RvbGVuIGZyb20gW3BlcnZhc2l2ZXMubWxdLiAgQWRkcyBhIFwiLlwiIGF0IHRoZSBlbmQgaWYgbmVlZGVkLiAgSXQgaXMgaW5cbiAgIFtwZXJ2YXNpdmVzLm1saV0sIGJ1dCBpdCBhbHNvIHNheXMgbm90IHRvIHVzZSBpdCBkaXJlY3RseSwgc28gd2UgY29weSBhbmQgcGFzdGUgdGhlXG4gICBjb2RlLiBJdCBtYWtlcyB0aGUgYXNzdW1wdGlvbiBvbiB0aGUgc3RyaW5nIHBhc3NlZCBpbiBhcmd1bWVudCB0aGF0IGl0IHdhcyByZXR1cm5lZCBieVxuICAgW2Zvcm1hdF9mbG9hdF0uICopXG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gcyA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBpIGxcbiAgICB0aGVuIHMgXiBcIi5cIlxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgfCBfIC0+IHMpXG4gIGluXG4gIGxvb3AgMFxuOztcblxuKCogTGV0IFt5XSBiZSBhIHBvd2VyIG9mIDIuICBUaGVuIHRoZSBuZXh0IHJlcHJlc2VudGFibGUgZmxvYXQgaXM6XG4gICBbeiA9IHkgKiAoMSArIDIgKiogLTUyKV1cbiAgIGFuZCB0aGUgcHJldmlvdXMgb25lIGlzXG4gICBbeCA9IHkgKiAoMSAtIDIgKiogLTUzKV1cblxuICAgSW4gZ2VuZXJhbCwgZXZlcnkgdHdvIGFkamFjZW50IGZsb2F0cyBhcmUgd2l0aGluIGEgZmFjdG9yIG9mIGJldHdlZW4gWzEgKyAyKiotNTNdXG4gICBhbmQgWzEgKyAyKiotNTJdIGZyb20gZWFjaCBvdGhlciwgdGhhdCBpcyB3aXRoaW4gWzEgKyAxLjFlLTE2XSBhbmQgWzEgKyAyLjNlLTE2XS5cblxuICAgU28gaWYgdGhlIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgYSBmbG9hdCBzdGFydHMgd2l0aCBcIjFcIiwgdGhlbiBpdHMgYWRqYWNlbnQgZmxvYXRzXG4gICB3aWxsIHVzdWFsbHkgZGlmZmVyIGZyb20gaXQgYnkgMSwgYW5kIHNvbWV0aW1lcyBieSAyLCBhdCB0aGUgMTd0aCBzaWduaWZpY2FudCBkaWdpdFxuICAgKGNvdW50aW5nIGZyb20gMSkuXG5cbiAgIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB0aGUgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBzdGFydHMgd2l0aCBcIjlcIiwgdGhlbiB0aGUgYWRqYWNlbnRcbiAgIGZsb2F0cyB3aWxsIGJlIG9mZiBieSBubyBtb3JlIHRoYW4gMjMgYXQgdGhlIDE2dGggYW5kIDE3dGggc2lnbmlmaWNhbnQgZGlnaXRzLlxuXG4gICBFLmcuOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE3Z1wiICgxMDI0LiAqLiAoMS4gLS4gMi4qKiAoLTUzLikpKTs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExXG4gICAgICAgICAgICAgICAgICAgMTIzNCA1Njc4OTAxMjM0NTY3XG4gICAgIC0gOiBzdHJpbmcgPSBcIjEwMjMuOTk5OTk5OTk5OTk5OVwiXG4gICB2fVxuICAgUHJpbnRpbmcgYSBjb3VwbGUgb2YgZXh0cmEgZGlnaXRzIHJldmVhbHMgdGhhdCB0aGUgZGlmZmVyZW5jZSBpbmRlZWQgaXMgcm91Z2hseSAxMSBhdFxuICAgZGlnaXRzIDE3dGggYW5kIDE4dGggKHRoYXQgaXMsIDEzdGggYW5kIDE0dGggYWZ0ZXIgXCIuXCIpOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE5Z1wiICgxMDI0LiAqLiAoMS4gLS4gMi4qKiAoLTUzLikpKTs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExMTFcbiAgICAgICAgICAgICAgICAgICAxMjM0IDU2Nzg5MDEyMzQ1Njc4OVxuICAgICAtIDogc3RyaW5nID0gXCIxMDIzLjk5OTk5OTk5OTk5OTg4NlwiXG4gICB2fVxuXG4gICBUaGUgdWxwICh0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGFkamFjZW50IGZsb2F0cykgaXMgdHdpY2UgYXMgYmlnIG9uIHRoZSBvdGhlciBzaWRlIG9mXG4gICAxMDI0LjpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xOWdcIiAoMTAyNC4gKi4gKDEuICsuIDIuKiogKC01Mi4pKSk7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMTExMTExXG4gICAgICAgICAgICAgICAgICAgMTIzNCA1Njc4OTAxMjM0NTY3ODlcbiAgICAgLSA6IHN0cmluZyA9IFwiMTAyNC4wMDAwMDAwMDAwMDAyMjdcIlxuICAgdn1cblxuICAgTm93IHRha2UgYSBwb3dlciBvZiAyIHdoaWNoIHN0YXJ0cyB3aXRoIDk5OlxuXG4gICB7dlxuICAgICAjIDIuKio5My4gOztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTExMVxuICAgICAgICAgICAgICAgICAxIDIzNDU2Nzg5MDEyMzQ1Njc4XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQyMmUrMjdcblxuICAgICAjIDIuKio5My4gKi4gKDEuICsuIDIuKiogKC01Mi4pKTs7XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQ0NGUrMjdcblxuICAgICAjIDIuKio5My4gKi4gKDEuIC0uIDIuKiogKC01My4pKTs7XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQxMWUrMjdcbiAgIHZ9XG5cbiAgIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gMioqOTMgYW5kIGl0cyB0d28gbmVpZ2hib3JzIGlzIHNsaWdodGx5IG1vcmUgdGhhbiwgcmVzcGVjdGl2ZWx5LFxuICAgMSBhbmQgMiBhdCBzaWduaWZpY2FudCBkaWdpdCAxNi5cblxuICAgVGhvc2UgZXhhbXBsZXMgc2hvdyB0aGF0OlxuICAgLSAxNyBzaWduaWZpY2FudCBkaWdpdHMgaXMgYWx3YXlzIHN1ZmZpY2llbnQgdG8gcmVwcmVzZW50IGEgZmxvYXQgd2l0aG91dCBhbWJpZ3VpdHlcbiAgIC0gMTV0aCBzaWduaWZpY2FudCBkaWdpdCBjYW4gYWx3YXlzIGJlIHJlcHJlc2VudGVkIGFjY3VyYXRlbHlcbiAgIC0gY29udmVydGluZyBhIGRlY2ltYWwgbnVtYmVyIHdpdGggMTYgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIGl0cyBuZWFyZXN0IGZsb2F0IGFuZCBiYWNrXG4gICAgIGNhbiBjaGFuZ2UgdGhlIGxhc3QgZGVjaW1hbCBkaWdpdCBieSBubyBtb3JlIHRoYW4gMVxuXG4gICBUbyBtYWtlIHN1cmUgdGhhdCBmbG9hdHMgb2J0YWluZWQgYnkgY29udmVyc2lvbiBmcm9tIGRlY2ltYWwgZnJhY3Rpb25zIChlLmcuIFwiMy4xNFwiKVxuICAgYXJlIHByaW50ZWQgd2l0aG91dCB0cmFpbGluZyBub24temVybyBkaWdpdHMsIG9uZSBzaG91bGQgY2hvb3NlIHRoZSBmaXJzdCBhbW9uZyB0aGVcbiAgICclLjE1ZycsICclLjE2ZycsIGFuZCAnJS4xN2cnIHJlcHJlc2VudGF0aW9ucyB3aGljaCBkb2VzIHJvdW5kLXRyaXA6XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTVnXCIgMy4xNDs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjMuMTRcIiAgICAgICAgICAgICAgICAgICAgICgqIHBpY2sgdGhpcyBvbmUgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xNmdcIiAzLjE0OztcbiAgICAgLSA6IHN0cmluZyA9IFwiMy4xNFwiXG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgMy4xNDs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjMuMTQwMDAwMDAwMDAwMDAwMVwiICAgICAgICgqIGRvIG5vdCBwaWNrIHRoaXMgb25lICopXG5cbiAgICAgIyBzcHJpbnRmIFwiJS4xNWdcIiA4LjAwMDAwMDAwMDAwMDAwMjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjhcIiAgICAgICAgICAgICAgICAgICAgICAgICgqIGRvIG5vdCBwaWNrIHRoaXMgb25lLS1kb2VzIG5vdCByb3VuZC10cmlwICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTZnXCIgOC4wMDAwMDAwMDAwMDAwMDI7O1xuICAgICAtIDogc3RyaW5nID0gXCI4LjAwMDAwMDAwMDAwMDAwMlwiICAgICAgICAoKiBwcmVmZXIgdGhpcyBvbmUgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xN2dcIiA4LjAwMDAwMDAwMDAwMDAwMjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjguMDAwMDAwMDAwMDAwMDAxOFwiICAgICAgICgqIHRoaXMgb25lIGhhcyBvbmUgZGlnaXQgb2YganVuayBhdCB0aGUgZW5kICopXG4gICB2fVxuXG4gICBTa2lwcGluZyB0aGUgJyUuMTZnJyBpbiB0aGUgYWJvdmUgcHJvY2VkdXJlIHNhdmVzIHVzIHNvbWUgdGltZSwgYnV0IGl0IG1lYW5zIHRoYXQsIGFzXG4gICBzZWVuIGluIHRoZSBzZWNvbmQgZXhhbXBsZSBhYm92ZSwgb2NjYXNpb25hbGx5IG51bWJlcnMgd2l0aCBleGFjdGx5IDE2IHNpZ25pZmljYW50XG4gICBkaWdpdHMgd2lsbCBoYXZlIGFuIGVycm9yIGludHJvZHVjZWQgYXQgdGhlIDE3dGggZGlnaXQuICBUaGF0IGlzIHByb2JhYmx5IE9LIGZvclxuICAgdHlwaWNhbCB1c2UsIGJlY2F1c2UgYSBudW1iZXIgd2l0aCAxNiBzaWduaWZpY2FudCBkaWdpdHMgaXMgXCJ1Z2x5XCIgYWxyZWFkeS4gIEFkZGluZyBvbmVcbiAgIG1vcmUgZG9lc24ndCBtYWtlIGl0IG11Y2ggd29yc2UgZm9yIGEgaHVtYW4gcmVhZGVyLlxuXG4gICBPbiB0aGUgb3RoZXIgaGFuZCwgd2UgY2Fubm90IHNraXAgJyUuMTVnJyBhbmQgb25seSBsb29rIGF0ICclLjE2ZycgYW5kICclLjE3ZycsIHNpbmNlXG4gICB0aGUgaW5hY2N1cmFjeSBhdCB0aGUgMTZ0aCBkaWdpdCBtaWdodCBpbnRyb2R1Y2UgdGhlIG5vaXNlIHdlIHdhbnQgdG8gYXZvaWQ6XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTVnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MlwiICAgICAgICAgICAgICAgICAgICAoKiBwaWNrIHRoaXMgb25lICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTZnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MjAwMDAwMDAwMDAwMVwiICAgICAgICAoKiBkbyBub3QgcGljayB0aGlzIG9uZS0tanVuayBhdCB0aGUgZW5kICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MjAwMDAwMDAwMDAwMDlcIlxuICAgdn1cbiopXG5sZXQgdG9fc3RyaW5nIHggPVxuICB2YWxpZF9mbG9hdF9sZXhlbVxuICAgIChsZXQgeSA9IGZvcm1hdF9mbG9hdCBcIiUuMTVnXCIgeCBpblxuICAgICBpZiBmbG9hdF9vZl9zdHJpbmcgeSA9IHggdGhlbiB5IGVsc2UgZm9ybWF0X2Zsb2F0IFwiJS4xN2dcIiB4KVxuOztcblxubGV0IG1heF92YWx1ZSA9IGluZmluaXR5XG5sZXQgbWluX3ZhbHVlID0gbmVnX2luZmluaXR5XG5sZXQgbWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZSA9IDIuICoqIC0xMDc0LlxubGV0IG1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWUgPSAyLiAqKiAtMTAyMi5cbmxldCB6ZXJvID0gMC5cbmxldCBvbmUgPSAxLlxubGV0IG1pbnVzX29uZSA9IC0xLlxubGV0IHBpID0gMHgzLjI0M0Y2QTg4ODVBMzA4RDMxMzE5OEEyRTAzNzA3M1xubGV0IHNxcnRfcGkgPSAweDEuQzVCRjg5MUI0RUY2QUE3OUMzQjA1MjBENURCOTM4XG5sZXQgc3FydF8ycGkgPSAweDIuODFCMjYzRkVDNEUwQjJDQUY5NDgzRjVDRTQ1OURDXG5sZXQgZXVsZXIgPSAweDAuOTNDNDY3RTM3REIwQzdBNEQxQkUzRjgxMDE1MkNCXG5sZXQgb2ZfaW50ID0gSW50LnRvX2Zsb2F0XG5sZXQgdG9faW50ID0gSW50Lm9mX2Zsb2F0XG5sZXQgb2ZfaW50NjMgaSA9IEludDYzLnRvX2Zsb2F0IGlcbmxldCBvZl9pbnQ2NCBpID0gU3RkbGliLkludDY0LnRvX2Zsb2F0IGlcbmxldCB0b19pbnQ2NCA9IFN0ZGxpYi5JbnQ2NC5vZl9mbG9hdFxubGV0IGlyb3VuZF9sYm91bmQgPSBsb3dlcl9ib3VuZF9mb3JfaW50IEludC5udW1fYml0c1xubGV0IGlyb3VuZF91Ym91bmQgPSB1cHBlcl9ib3VuZF9mb3JfaW50IEludC5udW1fYml0c1xuXG4oKiBUaGUgcGVyZm9ybWFuY2Ugb2YgdGhlIFwiZXhuXCIgcm91bmRpbmcgZnVuY3Rpb25zIGlzIGltcG9ydGFudCwgc28gdGhleSBhcmUgd3JpdHRlblxuICAgb3V0IHNlcGFyYXRlbHksIGFuZCB0dW5lZCBpbmRpdmlkdWFsbHkuICAoV2UgY291bGQgaGF2ZSB0aGUgb3B0aW9uIHZlcnNpb25zIGNhbGxcbiAgIHRoZSBcImV4blwiIHZlcnNpb25zLCBidXQgdGhhdCBpbXBvc2VzIGFyZ3VhYmx5IGdyYXR1aXRvdXMgb3ZlcmhlYWQtLS1lc3BlY2lhbGx5XG4gICBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgY2FwdHVyZSBvZiBiYWNrdHJhY2VzIGlzIGVuYWJsZWQgdXBvbiBcIndpdGhcIi0tLWFuZCB0aGF0IHNlZW1zXG4gICBub3Qgd29ydGggaXQgd2hlbiBjb21wYXJlZCB0byB0aGUgcmVsYXRpdmVseSBzbWFsbCBhbW91bnQgb2YgY29kZSBkdXBsaWNhdGlvbi4pICopXG5cbigqIEVycm9yIHJlcG9ydGluZyBiZWxvdyBpcyB2ZXJ5IGNhcmVmdWxseSBhcnJhbmdlZCBzbyB0aGF0LCBlLmcuLCBbaXJvdW5kX25lYXJlc3RfZXhuXVxuICAgaXRzZWxmIGNhbiBiZSBpbmxpbmVkIGludG8gY2FsbGVycyBzdWNoIHRoYXQgdGhleSBkb24ndCBuZWVkIHRvIGFsbG9jYXRlIGEgYm94IGZvciB0aGVcbiAgIFtmbG9hdF0gYXJndW1lbnQuICBUaGlzIGlzIGRvbmUgd2l0aCBhIGJveCBbYm94XSBmdW5jdGlvbiBjYXJlZnVsbHkgY2hvc2VuIHRvIGFsbG93IHRoZVxuICAgY29tcGlsZXIgdG8gY3JlYXRlIGEgc2VwYXJhdGUgYm94IGZvciB0aGUgZmxvYXQgb25seSBpbiBlcnJvciBjYXNlcy4gIFNlZSwgZS5nLixcbiAgIFsuLi8uLi96ZXJvL3Rlc3QvcHJpY2VfdGVzdC5tbF0gZm9yIGEgbWVjaGFuaWNhbCB0ZXN0IG9mIHRoaXMgcHJvcGVydHkgd2hlbiBidWlsZGluZ1xuICAgd2l0aCBbWF9MSUJSQVJZX0lOTElOSU5HPXRydWVdLiAqKVxuXG5sZXQgaXJvdW5kX3VwIHQgPVxuICBpZiB0ID4gMC4wXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGNlaWwgdCBpblxuICAgIGlmIHQnIDw9IGlyb3VuZF91Ym91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX3VwX2V4biB0ID1cbiAgaWYgdCA+IDAuMFxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBjZWlsIHQgaW5cbiAgICBpZiB0JyA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKCkpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX3VwX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCIgKGJveCB0KSAoKVxuOztcblxubGV0IGlyb3VuZF9kb3duIHQgPVxuICBpZiB0ID49IDAuMFxuICB0aGVuIGlmIHQgPD0gaXJvdW5kX3Vib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCkgZWxzZSBOb25lXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yIHQgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0JykgZWxzZSBOb25lKVxuOztcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBpcm91bmRfZG93bl9leG4gdCA9XG4gIGlmIHQgPj0gMC4wXG4gIHRoZW5cbiAgICBpZiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKClcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgdCBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfZG93bl9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiIChib3ggdCkgKCkpXG47O1xuXG5sZXQgaXJvdW5kX3Rvd2FyZHNfemVybyB0ID1cbiAgaWYgdCA+PSBpcm91bmRfbGJvdW5kICYmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGlyb3VuZF90b3dhcmRzX3plcm9fZXhuIHQgPVxuICBpZiB0ID49IGlyb3VuZF9sYm91bmQgJiYgdCA8PSBpcm91bmRfdWJvdW5kXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwiRmxvYXQuaXJvdW5kX3Rvd2FyZHNfemVyb19leG46IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoYm94IHQpXG4gICAgICAoKVxuOztcblxuKCogT3V0c2lkZSBvZiB0aGUgcmFuZ2UgKHJvdW5kX25lYXJlc3RfbGIuLnJvdW5kX25lYXJlc3RfdWIpLCBhbGwgcmVwcmVzZW50YWJsZSBkb3VibGVzXG4gICBhcmUgaW50ZWdlcnMgaW4gdGhlIG1hdGhlbWF0aWNhbCBzZW5zZSwgYW5kIFtyb3VuZF9uZWFyZXN0XSBzaG91bGQgYmUgaWRlbnRpdHkuXG5cbiAgIEhvd2V2ZXIsIGZvciBvZGQgbnVtYmVycyB3aXRoIHRoZSBhYnNvbHV0ZSB2YWx1ZSBiZXR3ZWVuIDIqKjUyIGFuZCAyKio1MywgdGhlIGZvcm11bGFcbiAgIFtyb3VuZF9uZWFyZXN0IHggPSBmbG9vciAoeCArIDAuNSldIGRvZXMgbm90IGhvbGQ6XG5cbiAgIHt2XG4gICAgICMgbGV0IG5haXZlX3JvdW5kX25lYXJlc3QgeCA9IGZsb29yICh4ICsuIDAuNSk7O1xuICAgICAjIGxldCB4ID0gMi4gKiogNTIuICsuIDEuOztcbiAgICAgdmFsIHggOiBmbG9hdCA9IDQ1MDM1OTk2MjczNzA0OTcuXG4gICAgICMgbmFpdmVfcm91bmRfbmVhcmVzdCB4OztcbiAgICAgLSA6ICAgICBmbG9hdCA9IDQ1MDM1OTk2MjczNzA0OTguXG4gICB2fVxuKilcblxubGV0IHJvdW5kX25lYXJlc3RfbGIgPSAtLigyLiAqKiA1Mi4pXG5sZXQgcm91bmRfbmVhcmVzdF91YiA9IDIuICoqIDUyLlxuXG4oKiBGb3IgW3ggPSBvbmVfdWxwIGBEb3duIDAuNV0sIHRoZSBmb3JtdWxhIFtmbG9vciAoeCArLiAwLjUpXSBmb3Igcm91bmRpbmcgdG8gbmVhcmVzdFxuICAgZG9lcyBub3Qgd29yaywgYmVjYXVzZSB0aGUgZXhhY3QgcmVzdWx0IGlzIGhhbGZ3YXkgYmV0d2VlbiBbb25lX3VscCBgRG93biAxLl0gYW5kIFsxLl0sXG4gICBhbmQgaXQgZ2V0cyByb3VuZGVkIHVwIHRvIFsxLl0gZHVlIHRvIHRoZSByb3VuZC10aWVzLXRvLWV2ZW4gcnVsZS4gKilcbmxldCBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmID0gb25lX3VscCBgRG93biAwLjVcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0ID1cbiAgdFxuICArLlxuICBpZiB0ID0gb25lX3VscF9sZXNzX3RoYW5faGFsZlxuICB0aGVuIG9uZV91bHBfbGVzc190aGFuX2hhbGYgKCogc2luY2UgdCA8IDAuNSwgbWFrZSBzdXJlIHRoZSByZXN1bHQgaXMgPCAxLjAgKilcbiAgZWxzZSAwLjVcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdF8zMiB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCcpIGVsc2UgTm9uZSlcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgKHQgKy4gMC41KSBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3RfNjQgdCA9XG4gIGlmIHQgPj0gMC5cbiAgdGhlblxuICAgIGlmIHQgPCByb3VuZF9uZWFyZXN0X3ViXG4gICAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIChhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0KSlcbiAgICBlbHNlIGlmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICAgIGVsc2UgTm9uZVxuICBlbHNlIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoZmxvb3IgKHQgKy4gMC41KSkpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdCA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiBpcm91bmRfbmVhcmVzdF82NFxuICB8IFczMiAtPiBpcm91bmRfbmVhcmVzdF8zMlxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0X2V4bl8zMiB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX25lYXJlc3RfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKCkpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yICh0ICsuIDAuNSkgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsXCIgKGJveCB0KSAoKSlcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX25lYXJlc3RfZXhuXzY0IHQgPVxuICBpZiB0ID49IDAuXG4gIHRoZW5cbiAgICBpZiB0IDwgcm91bmRfbmVhcmVzdF91YlxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdClcbiAgICBlbHNlIGlmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCIgKGJveCB0KSAoKVxuICBlbHNlIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoZmxvb3IgKHQgKy4gMC41KSlcbiAgZWxzZSBpZiB0ID49IGlyb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9uZWFyZXN0X2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCIgKGJveCB0KSAoKVxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0X2V4biA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiBpcm91bmRfbmVhcmVzdF9leG5fNjRcbiAgfCBXMzIgLT4gaXJvdW5kX25lYXJlc3RfZXhuXzMyXG47O1xuXG4oKiBUaGUgZm9sbG93aW5nIFtpcm91bmRfZXhuXSBhbmQgW2lyb3VuZF0gZnVuY3Rpb25zIGFyZSBzbG93ZXIgdGhhbiB0aGUgb25lcyBhYm92ZS5cbiAgIFRoZWlyIGVxdWl2YWxlbmNlIHRvIHRob3NlIGZ1bmN0aW9ucyBpcyB0ZXN0ZWQgaW4gdGhlIHVuaXQgdGVzdHMgYmVsb3cuICopXG5cbmxldFtAaW5saW5lXSBpcm91bmRfZXhuID8oZGlyID0gYE5lYXJlc3QpIHQgPVxuICBtYXRjaCBkaXIgd2l0aFxuICB8IGBaZXJvIC0+IGlyb3VuZF90b3dhcmRzX3plcm9fZXhuIHRcbiAgfCBgTmVhcmVzdCAtPiBpcm91bmRfbmVhcmVzdF9leG4gdFxuICB8IGBVcCAtPiBpcm91bmRfdXBfZXhuIHRcbiAgfCBgRG93biAtPiBpcm91bmRfZG93bl9leG4gdFxuOztcblxubGV0IGlyb3VuZCA/KGRpciA9IGBOZWFyZXN0KSB0ID1cbiAgdHJ5IFNvbWUgKGlyb3VuZF9leG4gfmRpciB0KSB3aXRoXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgaXNfaW5mIHQgPSAxLiAvLiB0ID0gMC5cbmxldCBpc19maW5pdGUgdCA9IHQgLS4gdCA9IDAuXG5cbmxldCBtaW5faW5hbiAoeCA6IHQpIHkgPVxuICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSBpZiB4IDwgeSB0aGVuIHggZWxzZSB5XG47O1xuXG5sZXQgbWF4X2luYW4gKHggOiB0KSB5ID1cbiAgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgaWYgeCA+IHkgdGhlbiB4IGVsc2UgeVxuOztcblxubGV0IGFkZCA9ICggKy4gKVxubGV0IHN1YiA9ICggLS4gKVxubGV0IG5lZyA9ICggfi0uIClcbmxldCBhYnMgPSBhYnNfZmxvYXRcbmxldCBzY2FsZSA9ICggKi4gKVxubGV0IHNxdWFyZSB4ID0geCAqLiB4XG5cbm1vZHVsZSBQYXJ0cyA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgZnJhY3Rpb25hbCA6IHQgLT4gZmxvYXRcbiAgdmFsIGludGVncmFsIDogdCAtPiBmbG9hdFxuICB2YWwgbW9kZiA6IGZsb2F0IC0+IHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBmbG9hdCAqIGZsb2F0XG5cbiAgbGV0IGZyYWN0aW9uYWwgdCA9IGZzdCB0XG4gIGxldCBpbnRlZ3JhbCB0ID0gc25kIHRcbiAgbGV0IG1vZGYgPSBtb2RmXG5lbmRcblxubGV0IG1vZGYgPSBQYXJ0cy5tb2RmXG5sZXQgcm91bmRfZG93biA9IGZsb29yXG5sZXQgcm91bmRfdXAgPSBjZWlsXG5sZXQgcm91bmRfdG93YXJkc196ZXJvIHQgPSBpZiB0ID49IDAuIHRoZW4gcm91bmRfZG93biB0IGVsc2Ugcm91bmRfdXAgdFxuXG4oKiBzZWUgdGhlIGNvbW1lbnQgYWJvdmUgW3JvdW5kX25lYXJlc3RfbGJdIGFuZCBbcm91bmRfbmVhcmVzdF91Yl0gZm9yIGFuIGV4cGxhbmF0aW9uICopXG5sZXRbQG9jYW1sLmlubGluZV0gcm91bmRfbmVhcmVzdF9pbmxpbmUgdCA9XG4gIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiICYmIHQgPCByb3VuZF9uZWFyZXN0X3ViXG4gIHRoZW4gZmxvb3IgKGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQpXG4gIGVsc2UgdCArLiAwLlxuOztcblxubGV0IHJvdW5kX25lYXJlc3QgdCA9IChyb3VuZF9uZWFyZXN0X2lubGluZSBbQG9jYW1sLmlubGluZWQgYWx3YXlzXSkgdFxuXG5sZXQgcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW4gdCA9XG4gIGlmIHQgPD0gcm91bmRfbmVhcmVzdF9sYiB8fCB0ID49IHJvdW5kX25lYXJlc3RfdWJcbiAgdGhlbiB0ICsuIDAuXG4gIGVsc2UgKFxuICAgIGxldCBmbG9vciA9IGZsb29yIHQgaW5cbiAgICAoKiBbY2VpbF9vcl9zdWNjID0gaWYgdCBpcyBhbiBpbnRlZ2VyIHRoZW4gdCArLiAxLiBlbHNlIGNlaWwgdF0uICBGYXN0ZXIgdGhhbiBbY2VpbF0uICopXG4gICAgbGV0IGNlaWxfb3Jfc3VjYyA9IGZsb29yICsuIDEuIGluXG4gICAgbGV0IGRpZmZfZmxvb3IgPSB0IC0uIGZsb29yIGluXG4gICAgbGV0IGRpZmZfY2VpbCA9IGNlaWxfb3Jfc3VjYyAtLiB0IGluXG4gICAgaWYgZGlmZl9mbG9vciA8IGRpZmZfY2VpbFxuICAgIHRoZW4gZmxvb3JcbiAgICBlbHNlIGlmIGRpZmZfZmxvb3IgPiBkaWZmX2NlaWxcbiAgICB0aGVuIGNlaWxfb3Jfc3VjY1xuICAgIGVsc2UgaWYgKCogZXhhY3QgdGllLCBwaWNrIHRoZSBldmVuICopXG4gICAgICAgICAgICBtb2RfZmxvYXQgZmxvb3IgMi4gPSAwLlxuICAgIHRoZW4gZmxvb3JcbiAgICBlbHNlIGNlaWxfb3Jfc3VjYylcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9sYm91bmQgPSBsb3dlcl9ib3VuZF9mb3JfaW50IEludDYzLm51bV9iaXRzXG5sZXQgaW50NjNfcm91bmRfdWJvdW5kID0gdXBwZXJfYm91bmRfZm9yX2ludCBJbnQ2My5udW1fYml0c1xuXG5sZXQgaW50NjNfcm91bmRfdXBfZXhuIHQgPVxuICBpZiB0ID4gMC4wXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGNlaWwgdCBpblxuICAgIGlmIHQnIDw9IGludDYzX3JvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAgICgpKVxuICBlbHNlIGlmIHQgPj0gaW50NjNfcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF91cF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgKClcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9kb3duX2V4biB0ID1cbiAgaWYgdCA+PSAwLjBcbiAgdGhlblxuICAgIGlmIHQgPD0gaW50NjNfcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAgICgpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yIHQgaW5cbiAgICBpZiB0JyA+PSBpbnQ2M19yb3VuZF9sYm91bmRcbiAgICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIlxuICAgICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgICAoKSlcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4biB0MCA9XG4gIGxldCB0ID0gKHJvdW5kX25lYXJlc3RfaW5saW5lIFtAb2NhbWwuaW5saW5lZCBhbHdheXNdKSB0MCBpblxuICBpZiB0ID4gMC5cbiAgdGhlblxuICAgIGlmIHQgPD0gaW50NjNfcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChib3ggdDApXG4gICAgICAgICgpXG4gIGVsc2UgaWYgdCA+PSBpbnQ2M19yb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0LmludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIlxuICAgICAgKGJveCB0MClcbiAgICAgICgpXG47O1xuXG5sZXRbQGlubGluZV0gaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG4gZiA9XG4gIEludDYzLm9mX2ludCAoaXJvdW5kX25lYXJlc3RfZXhuIGYpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfbmVhcmVzdF9leG4gPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG5cbiAgfCBXMzIgLT4gaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG5cbjs7XG5cbmxldCByb3VuZCA/KGRpciA9IGBOZWFyZXN0KSB0ID1cbiAgbWF0Y2ggZGlyIHdpdGhcbiAgfCBgTmVhcmVzdCAtPiByb3VuZF9uZWFyZXN0IHRcbiAgfCBgRG93biAtPiByb3VuZF9kb3duIHRcbiAgfCBgVXAgLT4gcm91bmRfdXAgdFxuICB8IGBaZXJvIC0+IHJvdW5kX3Rvd2FyZHNfemVybyB0XG47O1xuXG5tb2R1bGUgQ2xhc3MgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEluZmluaXRlXG4gICAgfCBOYW5cbiAgICB8IE5vcm1hbFxuICAgIHwgU3Vibm9ybWFsXG4gICAgfCBaZXJvXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZW51bWVyYXRlLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfX2xvY2FsID0gKFN0ZGxpYi5jb21wYXJlIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGNvbXBhcmUgPSAoZnVuIGEgYiAtPiBjb21wYXJlX19sb2NhbCBhIGIgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgYWxsID0gKFsgSW5maW5pdGU7IE5hbjsgTm9ybWFsOyBTdWJub3JtYWw7IFplcm8gXSA6IHQgbGlzdClcblxuICBsZXQgdF9vZl9zZXhwID1cbiAgICAobGV0IGVycm9yX3NvdXJjZV9fMDA3XyA9IFwiZmxvYXQubWwuQ2xhc3MudFwiIGluXG4gICAgIGZ1bmN0aW9uXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImluZmluaXRlXCIgfCBcIkluZmluaXRlXCIpIC0+IEluZmluaXRlXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5hblwiIHwgXCJOYW5cIikgLT4gTmFuXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5vcm1hbFwiIHwgXCJOb3JtYWxcIikgLT4gTm9ybWFsXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInN1Ym5vcm1hbFwiIHwgXCJTdWJub3JtYWxcIikgLT4gU3Vibm9ybWFsXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSAtPiBaZXJvXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5maW5pdGVcIiB8IFwiSW5maW5pdGVcIikgOjogXykgYXNcbiAgICAgICBzZXhwX18wMDhfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDdfIHNleHBfXzAwOF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIDo6IF8pIGFzIHNleHBfXzAwOF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDhfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibm9ybWFsXCIgfCBcIk5vcm1hbFwiKSA6OiBfKSBhcyBzZXhwX18wMDhfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwN18gc2V4cF9fMDA4X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInN1Ym5vcm1hbFwiIHwgXCJTdWJub3JtYWxcIikgOjogXykgYXNcbiAgICAgICBzZXhwX18wMDhfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDdfIHNleHBfXzAwOF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgOjogXykgYXMgc2V4cF9fMDA4XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDdfIHNleHBfXzAwOF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDdfIHNleHBfXzAwNl9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA2XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA3XyBzZXhwX18wMDZfXG4gICAgIHwgc2V4cF9fMDA2XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDdfIHNleHBfXzAwNl9cbiAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgIHwgSW5maW5pdGUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiSW5maW5pdGVcIlxuICAgICB8IE5hbiAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOYW5cIlxuICAgICB8IE5vcm1hbCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOb3JtYWxcIlxuICAgICB8IFN1Ym5vcm1hbCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJTdWJub3JtYWxcIlxuICAgICB8IFplcm8gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiWmVyb1wiXG4gICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgeyB1bnR5cGVkID1cbiAgICAgICAgVmFyaWFudFxuICAgICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIkluZmluaXRlXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIk5hblwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJOb3JtYWxcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiU3Vibm9ybWFsXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlplcm9cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHRvX3N0cmluZyB0ID0gc3RyaW5nX29mX3NleHAgKHNleHBfb2ZfdCB0KVxuICBsZXQgb2Zfc3RyaW5nIHMgPSB0X29mX3NleHAgKHNleHBfb2Zfc3RyaW5nIHMpXG5lbmRcblxubGV0IGNsYXNzaWZ5IHQgPVxuICBsZXQgbW9kdWxlIEMgPSBDbGFzcyBpblxuICBtYXRjaCBjbGFzc2lmeV9mbG9hdCB0IHdpdGhcbiAgfCBGUF9ub3JtYWwgLT4gQy5Ob3JtYWxcbiAgfCBGUF9zdWJub3JtYWwgLT4gQy5TdWJub3JtYWxcbiAgfCBGUF96ZXJvIC0+IEMuWmVyb1xuICB8IEZQX2luZmluaXRlIC0+IEMuSW5maW5pdGVcbiAgfCBGUF9uYW4gLT4gQy5OYW5cbjs7XG5cbmxldCBpbnNlcnRfdW5kZXJzY29yZXMgPyhkZWxpbWl0ZXIgPSAnXycpID8oc3RyaXBfemVybyA9IGZhbHNlKSBzdHJpbmcgPVxuICBtYXRjaCBTdHJpbmcubHNwbGl0MiBzdHJpbmcgfm9uOicuJyB3aXRoXG4gIHwgTm9uZSAtPiBJbnRfc3RyaW5nX2NvbnZlcnNpb25zLmluc2VydF9kZWxpbWl0ZXIgc3RyaW5nIH5kZWxpbWl0ZXJcbiAgfCBTb21lIChsZWZ0LCByaWdodCkgLT5cbiAgICBsZXQgbGVmdCA9IEludF9zdHJpbmdfY29udmVyc2lvbnMuaW5zZXJ0X2RlbGltaXRlciBsZWZ0IH5kZWxpbWl0ZXIgaW5cbiAgICBsZXQgcmlnaHQgPVxuICAgICAgaWYgc3RyaXBfemVybyB0aGVuIFN0cmluZy5yc3RyaXAgcmlnaHQgfmRyb3A6KGZ1biBjIC0+IENoYXIuKCA9ICkgYyAnMCcpIGVsc2UgcmlnaHRcbiAgICBpblxuICAgIChtYXRjaCByaWdodCB3aXRoXG4gICAgIHwgXCJcIiAtPiBsZWZ0XG4gICAgIHwgXyAtPiBsZWZ0IF4gXCIuXCIgXiByaWdodClcbjs7XG5cbmxldCB0b19zdHJpbmdfaHVtID9kZWxpbWl0ZXIgPyhkZWNpbWFscyA9IDMpID9zdHJpcF96ZXJvID8oZXhwbGljaXRfcGx1cyA9IGZhbHNlKSBmID1cbiAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBkZWNpbWFscyAwXG4gIHRoZW4gaW52YWxpZF9hcmdmIFwidG9fc3RyaW5nX2h1bTogaW52YWxpZCBhcmd1bWVudCB+ZGVjaW1hbHM9JWRcIiBkZWNpbWFscyAoKTtcbiAgbWF0Y2ggY2xhc3NpZnkgZiB3aXRoXG4gIHwgQ2xhc3MuSW5maW5pdGUgLT4gaWYgZiA+IDAuIHRoZW4gXCJpbmZcIiBlbHNlIFwiLWluZlwiXG4gIHwgQ2xhc3MuTmFuIC0+IFwibmFuXCJcbiAgfCBDbGFzcy5Ob3JtYWwgfCBDbGFzcy5TdWJub3JtYWwgfCBDbGFzcy5aZXJvIC0+XG4gICAgbGV0IHMgPVxuICAgICAgaWYgZXhwbGljaXRfcGx1cyB0aGVuIHNwcmludGYgXCIlKy4qZlwiIGRlY2ltYWxzIGYgZWxzZSBzcHJpbnRmIFwiJS4qZlwiIGRlY2ltYWxzIGZcbiAgICBpblxuICAgIGluc2VydF91bmRlcnNjb3JlcyBzID9kZWxpbWl0ZXIgP3N0cmlwX3plcm9cbjs7XG5cbmxldCBzZXhwX29mX3QgdCA9XG4gIGxldCBzZXhwID0gc2V4cF9vZl90IHQgaW5cbiAgbWF0Y2ggIVNleHAub2ZfZmxvYXRfc3R5bGUgd2l0aFxuICB8IGBOb191bmRlcnNjb3JlcyAtPiBzZXhwXG4gIHwgYFVuZGVyc2NvcmVzIC0+XG4gICAgKG1hdGNoIHNleHAgd2l0aFxuICAgICB8IExpc3QgXyAtPlxuICAgICAgIHJhaXNlX3NcbiAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgIFwiW3NleHBfb2ZfZmxvYXRdIHByb2R1Y2VkIHN0cmFuZ2Ugc2V4cFwiXG4gICAgICAgICAgICBbIFwic2V4cFwiLCBTZXhwLnNleHBfb2ZfdCBzZXhwIF0pXG4gICAgIHwgQXRvbSBzdHJpbmcgLT5cbiAgICAgICBpZiBTdHJpbmcuY29udGFpbnMgc3RyaW5nICdFJyB0aGVuIHNleHAgZWxzZSBBdG9tIChpbnNlcnRfdW5kZXJzY29yZXMgc3RyaW5nKSlcbjs7XG5cbmxldCB0b19wYWRkZWRfY29tcGFjdF9zdHJpbmdfY3VzdG9tIHQgPyhwcmVmaXggPSBcIlwiKSB+a2lsbyB+bWVnYSB+Z2lnYSB+dGVyYSA/cGV0YSAoKSA9XG4gICgqIFJvdW5kIGEgcmF0aW8gdG93YXJkIHRoZSBuZWFyZXN0IGludGVnZXIsIHJlc29sdmluZyB0aWVzIHRvd2FyZCB0aGUgbmVhcmVzdCBldmVuXG4gICAgIG51bWJlci4gIEZvciBzYW5lIGlucHV0cyAoaW4gcGFydGljdWxhciwgd2hlbiBbZGVub21pbmF0b3JdIGlzIGFuIGludGVnZXIgYW5kXG4gICAgIFthYnMgbnVtZXJhdG9yIDwgMmU1Ml0pIHRoaXMgc2hvdWxkIGJlIGFjY3VyYXRlLiAgT3RoZXJ3aXNlLCB0aGUgcmVzdWx0IG1pZ2h0IGJlIGFcbiAgICAgbGl0dGxlIGJpdCBvZmYsIGJ1dCB3ZSBkb24ndCByZWFsbHkgdXNlIHRoYXQgY2FzZS4gKilcbiAgbGV0IGlyb3VuZF9yYXRpb19leG4gfm51bWVyYXRvciB+ZGVub21pbmF0b3IgPVxuICAgIGxldCBrID0gZmxvb3IgKG51bWVyYXRvciAvLiBkZW5vbWluYXRvcikgaW5cbiAgICAoKiBpZiBbYWJzIGsgPCAyZTUzXSwgdGhlbiBib3RoIFtrXSBhbmQgW2sgKy4gMS5dIGFyZSBhY2N1cmF0ZWx5IHJlcHJlc2VudGVkLCBhbmQgaW5cbiAgICAgICBwYXJ0aWN1bGFyIFtrICsuIDEuID4ga10uICBJZiBbZGVub21pbmF0b3JdIGlzIGFsc28gYW4gaW50ZWdlciwgYW5kXG4gICAgICAgW2FicyAoZGVub21pbmF0b3IgKi4gKGsgKy4gMSkpIDwgMmU1M10gKGFuZCBpbiBzb21lIG90aGVyIGNhc2VzLCB0b28pLCB0aGVuIFtsb3dlcl1cbiAgICAgICBhbmQgW2hpZ2hlcl0gYXJlIGFjdHVhbGx5IGJvdGggYWNjdXJhdGUuICBTaW5jZSAocm91Z2hseSlcbiAgICAgICBbbnVtZXJhdG9yID0gZGVub21pbmF0b3IgKi4ga10gdGhlbiBmb3IgW2FicyBudW1lcmF0b3IgPCAyZTUyXSB3ZSBzaG91bGQgYmVcbiAgICAgICBmaW5lLiAqKVxuICAgIGxldCBsb3dlciA9IGRlbm9taW5hdG9yICouIGsgaW5cbiAgICBsZXQgaGlnaGVyID0gZGVub21pbmF0b3IgKi4gKGsgKy4gMS4pIGluXG4gICAgKCogU3VidHJhY3RpbmcgbnVtYmVycyB3aXRoaW4gYSBmYWN0b3Igb2YgdHdvIGZyb20gZWFjaCBvdGhlciBpcyBhY2N1cmF0ZS5cbiAgICAgICBTbyBlaXRoZXIgdGhlIHR3byBzdWJ0cmFjdGlvbnMgYmVsb3cgYXJlIGFjY3VyYXRlLCBvciBrID0gMCwgb3IgayA9IC0xLlxuICAgICAgIEluIGNhc2Ugb2YgYSB0aWUsIHJvdW5kIHRvIGV2ZW4uICopXG4gICAgbGV0IGRpZmZfcmlnaHQgPSBoaWdoZXIgLS4gbnVtZXJhdG9yIGluXG4gICAgbGV0IGRpZmZfbGVmdCA9IG51bWVyYXRvciAtLiBsb3dlciBpblxuICAgIGxldCBrID0gaXJvdW5kX25lYXJlc3RfZXhuIGsgaW5cbiAgICBpZiBkaWZmX3JpZ2h0IDwgZGlmZl9sZWZ0XG4gICAgdGhlbiBrICsgMVxuICAgIGVsc2UgaWYgZGlmZl9yaWdodCA+IGRpZmZfbGVmdFxuICAgIHRoZW4ga1xuICAgIGVsc2UgaWYgKCogYSB0aWUgKilcbiAgICAgICAgICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKGsgbW9kIDIpIDBcbiAgICB0aGVuIGtcbiAgICBlbHNlIGsgKyAxXG4gIGluXG4gIG1hdGNoIGNsYXNzaWZ5IHQgd2l0aFxuICB8IENsYXNzLkluZmluaXRlIC0+IGlmIHQgPCAwLjAgdGhlbiBcIi1pbmYgIFwiIGVsc2UgXCJpbmYgIFwiXG4gIHwgQ2xhc3MuTmFuIC0+IFwibmFuICBcIlxuICB8IENsYXNzLlN1Ym5vcm1hbCB8IENsYXNzLk5vcm1hbCB8IENsYXNzLlplcm8gLT5cbiAgICBsZXQgZ28gdCA9XG4gICAgICBsZXQgY29udl9vbmUgdCA9XG4gICAgICAgIGFzc2VydCAoMC4gPD0gdCAmJiB0IDwgOTk5Ljk1KTtcbiAgICAgICAgbGV0IHggPSBwcmVmaXggXiBmb3JtYXRfZmxvYXQgXCIlLjFmXCIgdCBpblxuICAgICAgICAoKiBGaXggdGhlIFwiLjBcIiBzdWZmaXggKilcbiAgICAgICAgaWYgU3RyaW5nLmlzX3N1ZmZpeCB4IH5zdWZmaXg6XCIuMFwiXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCB4ID0gQnl0ZXMub2Zfc3RyaW5nIHggaW5cbiAgICAgICAgICBsZXQgbiA9IEJ5dGVzLmxlbmd0aCB4IGluXG4gICAgICAgICAgQnl0ZXMuc2V0IHggKG4gLSAxKSAnICc7XG4gICAgICAgICAgQnl0ZXMuc2V0IHggKG4gLSAyKSAnICc7XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp4KVxuICAgICAgICBlbHNlIHhcbiAgICAgIGluXG4gICAgICBsZXQgY29udiBtYWcgdCBkZW5vbWluYXRvciA9XG4gICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgKGRlbm9taW5hdG9yID0gMTAwLiAmJiB0ID49IDk5OS45NSlcbiAgICAgICAgICB8fCAoZGVub21pbmF0b3IgPj0gMTAwXzAwMC4gJiYgdCA+PSByb3VuZF9uZWFyZXN0IChkZW5vbWluYXRvciAqLiA5Ljk5OV81KSkpO1xuICAgICAgICBhc3NlcnQgKHQgPCByb3VuZF9uZWFyZXN0IChkZW5vbWluYXRvciAqLiA5Xzk5OS41KSk7XG4gICAgICAgIGxldCBpLCBkID1cbiAgICAgICAgICBsZXQgayA9IGlyb3VuZF9yYXRpb19leG4gfm51bWVyYXRvcjp0IH5kZW5vbWluYXRvciBpblxuICAgICAgICAgICgqIFttb2RdIGlzIG9rYXkgaGVyZSBiZWNhdXNlIHdlIGtub3cgaSA+PSAwLiAqKVxuICAgICAgICAgIGsgLyAxMCwgayBtb2QgMTBcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgICAgICBhc3NlcnQgKDAgPD0gaSAmJiBpIDwgMTAwMCk7XG4gICAgICAgIGFzc2VydCAoMCA8PSBkICYmIGQgPCAxMCk7XG4gICAgICAgIGlmIGQgPSAwXG4gICAgICAgIHRoZW4gc3ByaW50ZiBcIiVzJWQlcyBcIiBwcmVmaXggaSBtYWdcbiAgICAgICAgZWxzZSBzcHJpbnRmIFwiJXMlZCVzJWRcIiBwcmVmaXggaSBtYWcgZFxuICAgICAgaW5cbiAgICAgICgqIFdoaWxlIHRoZSBzdGFuZGFyZCBtZXRyaWMgcHJlZml4ZXMgKGUuZy4gY2FwaXRhbCBcIk1cIiByYXRoZXIgdGhhbiBcIm1cIiwgWzFdKSBhcmVcbiAgICAgICAgIG5vbWluYWxseSBtb3JlIGNvcnJlY3QsIHRoaXMgaGluZGVycyByZWFkYWJpbGl0eSBpbiBvdXIgY2FzZS4gIEUuZy4sIDEwRzYgYW5kXG4gICAgICAgICAxMDY2IGxvb2sgdG9vIHNpbWlsYXIuICBUaGF0J3MgYW4gZXh0cmVtZSBleGFtcGxlLCBidXQgaW4gZ2VuZXJhbCBrLG0sZyx0LHBcbiAgICAgICAgIHByb2JhYmx5IHN0YW5kIG91dCBiZXR0ZXIgdGhhbiBLLE0sRyxULFAgd2hlbiBpbnRlcnNwZXJzZWQgd2l0aCBkaWdpdHMuXG5cbiAgICAgICAgIFsxXSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01ldHJpY19wcmVmaXggKilcbiAgICAgICgqIFRoZSB0cmljayBoZXJlIGlzIHRoYXQ6XG4gICAgICAgICAtIHRoZSBmaXJzdCBib3VuZGFyeSAoOTk5Ljk1KSBhcyBhIGZsb2F0IGlzIHNsaWdodGx5IG92ZXItcmVwcmVzZW50ZWQgKHNvIGl0IGlzXG4gICAgICAgICAgIGJldHRlciBhcHByb3hpbWF0ZWQgYXMgXCIxa1wiIHRoYW4gYXMgXCI5OTkuOVwiKSxcbiAgICAgICAgIC0gdGhlIG90aGVyIGJvdW5kYXJpZXMgYXJlIGFjY3VyYXRlbHkgcmVwcmVzZW50ZWQsIGJlY2F1c2UgdGhleSBhcmUgaW50ZWdlcnMuXG4gICAgICAgICAgIFRoYXQncyB3aHkgdGhlIHN0cmljdCBlcXVhbGl0aWVzIGJlbG93IGRvIGV4YWN0bHkgd2hhdCB3ZSB3YW50LiAqKVxuICAgICAgaWYgdCA8IDk5OS45NUUwXG4gICAgICB0aGVuIGNvbnZfb25lIHRcbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUUzXG4gICAgICB0aGVuIGNvbnYga2lsbyB0IDEwMC5cbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUU2XG4gICAgICB0aGVuIGNvbnYgbWVnYSB0IDEwMF8wMDAuXG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFOVxuICAgICAgdGhlbiBjb252IGdpZ2EgdCAxMDBfMDAwXzAwMC5cbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUUxMlxuICAgICAgdGhlbiBjb252IHRlcmEgdCAxMDBfMDAwXzAwMF8wMDAuXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggcGV0YSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBzcHJpbnRmIFwiJXMlLjFlXCIgcHJlZml4IHRcbiAgICAgICAgfCBTb21lIHBldGEgLT5cbiAgICAgICAgICBpZiB0IDwgOTk5Ljk1RTE1XG4gICAgICAgICAgdGhlbiBjb252IHBldGEgdCAxMDBfMDAwXzAwMF8wMDBfMDAwLlxuICAgICAgICAgIGVsc2Ugc3ByaW50ZiBcIiVzJS4xZVwiIHByZWZpeCB0KVxuICAgIGluXG4gICAgaWYgdCA+PSAwLiB0aGVuIGdvIHQgZWxzZSBcIi1cIiBeIGdvIH4tLnRcbjs7XG5cbmxldCB0b19wYWRkZWRfY29tcGFjdF9zdHJpbmcgdCA9XG4gIHRvX3BhZGRlZF9jb21wYWN0X3N0cmluZ19jdXN0b20gdCB+a2lsbzpcImtcIiB+bWVnYTpcIm1cIiB+Z2lnYTpcImdcIiB+dGVyYTpcInRcIiB+cGV0YTpcInBcIiAoKVxuOztcblxuKCogUGVyZm9ybWFuY2Ugbm90ZTogSW5pdGlhbGl6aW5nIHRoZSBhY2N1bXVsYXRvciB0byAxIHJlc3VsdHMgaW4gb25lIGV4dHJhXG4gICBtdWx0aXBseTsgZS5nLiwgdG8gY29tcHV0ZSB4ICoqIDQsIHdlIGluIHByaW5jaXBsZSBvbmx5IG5lZWQgMiBtdWx0aXBsaWVzLFxuICAgYnV0IHRoaXMgZnVuY3Rpb24gd2lsbCBoYXZlIDMgbXVsdGlwbGllcy4gIEhvd2V2ZXIsIGF0dGVtcHRzIHRvIGF2b2lkIHRoaXNcbiAgIChsaWtlIGRlY3JlbWVudGluZyBuIGFuZCBpbml0aWFsaXppbmcgYWNjdW0gdG8gYmUgeCwgb3IgaGFuZGxpbmcgc21hbGxcbiAgIGV4cG9uZW50cyBhcyBhIHNwZWNpYWwgY2FzZSkgaGF2ZSBub3QgeWllbGRlZCBhbnl0aGluZyB0aGF0IGlzIGEgbmV0XG4gICBpbXByb3ZlbWVudC5cbiopXG5sZXQgaW50X3BvdyB4IG4gPVxuICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gMS5cbiAgZWxzZSAoXG4gICAgKCogVXNpbmcgW3ggKy4gKC0wLildIG9uIHRoZSBmb2xsb3dpbmcgbGluZSBjb252aW5jZXMgdGhlIGNvbXBpbGVyIHRvIGF2b2lkIGEgY2VydGFpblxuICAgICAgIGJveGluZyAodGhhdCB3b3VsZCByZXN1bHQgaW4gYWxsb2NhdGlvbiBpbiBlYWNoIGl0ZXJhdGlvbikuICBTb29uLCB0aGUgY29tcGlsZXJcbiAgICAgICBzaG91bGRuJ3QgbmVlZCB0aGlzIFwiaGludFwiIHRvIGF2b2lkIHRoZSBib3hpbmcuICBUaGUgcmVhc29uIHdlIGFkZCAtMCByYXRoZXIgdGhhbiAwXG4gICAgICAgaXMgdGhhdCBbeCArLiAoLTAuKV0gaXMgYXBwYXJlbnRseSBhbHdheXMgdGhlIHNhbWUgYXMgW3hdLCB3aGVyZWFzIFt4ICsuIDAuXSBpc1xuICAgICAgIG5vdCwgaW4gdGhhdCBpdCBzZW5kcyBbLTAuXSB0byBbMC5dLiAgVGhpcyBtYWtlcyBhIGRpZmZlcmVuY2UgYmVjYXVzZSB3ZSB3YW50XG4gICAgICAgW2ludF9wb3cgKC0wLikgKC0xKV0gdG8gcmV0dXJuIG5lZ19pbmZpbml0eSBqdXN0IGxpa2UgWy0wLiAqKiAtMS5dIHdvdWxkLiAgKilcbiAgICBsZXQgeCA9IHJlZiAoeCArLiAtMC4pIGluXG4gICAgbGV0IG4gPSByZWYgbiBpblxuICAgIGxldCBhY2N1bSA9IHJlZiAxLiBpblxuICAgIGlmICFuIDwgMFxuICAgIHRoZW4gKFxuICAgICAgKCogeCAqKiBuID0gKDEveCkgKiogLW4gKilcbiAgICAgIHggOj0gMS4gLy4gIXg7XG4gICAgICBuIDo9IH4tICghbik7XG4gICAgICBpZiAhbiA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICAoKiBuIG11c3QgaGF2ZSBiZWVuIG1pbl9pbnQsIHNvIGl0IGlzIG5vdyBzbyBiaWcgdGhhdCBpdCBoYXMgd3JhcHBlZCBhcm91bmQuXG4gICAgICAgICAgIFdlIGRlY3JlbWVudCBpdCBzbyB0aGF0IGl0IGxvb2tzIHBvc2l0aXZlIGFnYWluLCBidXQgYWNjb3JkaW5nbHkgaGF2ZVxuICAgICAgICAgICB0byBwdXQgYW4gZXh0cmEgZmFjdG9yIG9mIHggaW4gdGhlIGFjY3VtdWxhdG9yLlxuICAgICAgICAqKVxuICAgICAgICBhY2N1bSA6PSAheDtcbiAgICAgICAgZGVjciBuKSk7XG4gICAgKCogTGV0dGluZyBbYV0gZGVub3RlICh0aGUgb3JpZ2luYWwgdmFsdWUgb2YpIFt4ICoqIG5dLCB3ZSBtYWludGFpblxuICAgICAgIHRoZSBpbnZhcmlhbnQgdGhhdCBbKHggKiogbikgKi4gYWNjdW0gPSBhXS4gKilcbiAgICB3aGlsZSAhbiA+IDEgZG9cbiAgICAgIGlmICFuIGxhbmQgMSA8PiAwIHRoZW4gYWNjdW0gOj0gIXggKi4gIWFjY3VtO1xuICAgICAgeCA6PSAheCAqLiAheDtcbiAgICAgIG4gOj0gIW4gbHNyIDFcbiAgICBkb25lO1xuICAgICgqIG4gaXMgbmVjZXNzYXJpbHkgMSBhdCB0aGlzIHBvaW50LCBzbyB0aGVyZSBpcyBvbmUgYWRkaXRpb25hbFxuICAgICAgIG11bHRpcGxpY2F0aW9uIGJ5IHguICopXG4gICAgIXggKi4gIWFjY3VtKVxuOztcblxubGV0IHJvdW5kX2dlbiB4IH5ob3cgPVxuICBpZiB4ID0gMC5cbiAgdGhlbiAwLlxuICBlbHNlIGlmIG5vdCAoaXNfZmluaXRlIHgpXG4gIHRoZW4geFxuICBlbHNlIChcbiAgICAoKiBTaWduaWZpY2FudCBkaWdpdHMgYW5kIGRlY2ltYWwgZGlnaXRzLiAqKVxuICAgIGxldCBzZCwgZGQgPVxuICAgICAgbWF0Y2ggaG93IHdpdGhcbiAgICAgIHwgYHNpZ25pZmljYW50X2RpZ2l0cyBzZCAtPlxuICAgICAgICBsZXQgZGQgPSBzZCAtIHRvX2ludCAocm91bmRfdXAgKGxvZzEwIChhYnMgeCkpKSBpblxuICAgICAgICBzZCwgZGRcbiAgICAgIHwgYGRlY2ltYWxfZGlnaXRzIGRkIC0+XG4gICAgICAgIGxldCBzZCA9IGRkICsgdG9faW50IChyb3VuZF91cCAobG9nMTAgKGFicyB4KSkpIGluXG4gICAgICAgIHNkLCBkZFxuICAgIGluXG4gICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGlmIHNkIDwgMFxuICAgIHRoZW4gMC5cbiAgICBlbHNlIGlmIHNkID49IDE3XG4gICAgdGhlbiB4XG4gICAgZWxzZSAoXG4gICAgICAoKiBDaG9vc2UgdGhlIG9yZGVyIHRoYXQgaXMgZXhhY3RseSByZXByZXNlbnRhYmxlIGFzIGEgZmxvYXQuIFNtYWxsIHBvc2l0aXZlXG4gICAgICAgICBpbnRlZ2VycyBhcmUsIGJ1dCB0aGVpciBpbnZlcnNlcyBpbiBtb3N0IGNhc2VzIGFyZSBub3QuICopXG4gICAgICBsZXQgYWJzX2RkID0gSW50LmFicyBkZCBpblxuICAgICAgaWYgYWJzX2RkID4gMjIgfHwgc2QgPj0gMTZcbiAgICAgICAgICgqIDEwKioyMiBpcyBleGFjdGx5IHJlcHJlc2VudGFibGUgYXMgYSBmbG9hdCwgYnV0IDEwKioyMyBpcyBub3QsIHNvIHVzZSB0aGUgc2xvd1xuICAgICAgICAgcGF0aC4gIFNpbWlsYXJseSwgaWYgd2UgbmVlZCAxNiBzaWduaWZpY2FudCBkaWdpdHMgaW4gdGhlIHJlc3VsdCwgdGhlbiB0aGUgaW50ZWdlclxuICAgICAgICAgW3JvdW5kX25lYXJlc3QgKHggPG9wPiBvcmRlcildIG1pZ2h0IG5vdCBiZSBleGFjdGx5IHJlcHJlc2VudGFibGUgYXMgYSBmbG9hdCwgc2luY2VcbiAgICAgICAgIGZvciBzb21lIHJhbmdlcyB3ZSBvbmx5IGhhdmUgMTUgZGlnaXRzIG9mIHByZWNpc2lvbiBndWFyYW50ZWVkLlxuXG4gICAgICAgICBUaGF0IHNhaWQsIHdlIGFyZSBzdGlsbCByb3VuZGluZyB0d2ljZSBoZXJlOlxuXG4gICAgICAgICAxKSBmaXJzdCB0aW1lIHdoZW4gcm91bmRpbmcgW3ggKi4gb3JkZXJdIG9yIFt4IC8uIG9yZGVyXSB0byB0aGUgbmVhcmVzdCBmbG9hdFxuICAgICAgICAgKGp1c3QgdGhlIG5vcm1hbCB3YXkgZmxvYXRpbmctcG9pbnQgbXVsdGlwbGljYXRpb24gb3IgZGl2aXNpb24gd29ya3MpLFxuXG4gICAgICAgICAyKSBzZWNvbmQgdGltZSB3aGVuIGFwcGx5aW5nIFtyb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbl0gdG8gdGhlIHJlc3VsdCBvZiB0aGVcbiAgICAgICAgIGFib3ZlIG9wZXJhdGlvblxuXG4gICAgICAgICBTbyBmb3IgYXJndW1lbnRzIHdpdGhpbiBhbiB1bHAgZnJvbSBhIHRpZSB3ZSBtaWdodCBzdGlsbCBwcm9kdWNlIGFuIG9mZi1ieS1vbmVcbiAgICAgICAgIHJlc3VsdC4gKilcbiAgICAgIHRoZW4gb2Zfc3RyaW5nIChzcHJpbnRmIFwiJS4qZ1wiIHNkIHgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG9yZGVyID0gaW50X3BvdyAxMC4gYWJzX2RkIGluXG4gICAgICAgIGlmIGRkID49IDBcbiAgICAgICAgdGhlbiByb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiAoeCAqLiBvcmRlcikgLy4gb3JkZXJcbiAgICAgICAgZWxzZSByb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiAoeCAvLiBvcmRlcikgKi4gb3JkZXIpKSlcbjs7XG5cbmxldCByb3VuZF9zaWduaWZpY2FudCB4IH5zaWduaWZpY2FudF9kaWdpdHMgPVxuICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBzaWduaWZpY2FudF9kaWdpdHMgMFxuICB0aGVuXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0LnJvdW5kX3NpZ25pZmljYW50OiBpbnZhbGlkIGFyZ3VtZW50IHNpZ25pZmljYW50X2RpZ2l0czolZFwiXG4gICAgICBzaWduaWZpY2FudF9kaWdpdHNcbiAgICAgICgpXG4gIGVsc2Ugcm91bmRfZ2VuIHggfmhvdzooYHNpZ25pZmljYW50X2RpZ2l0cyBzaWduaWZpY2FudF9kaWdpdHMpXG47O1xuXG5sZXQgcm91bmRfZGVjaW1hbCB4IH5kZWNpbWFsX2RpZ2l0cyA9IHJvdW5kX2dlbiB4IH5ob3c6KGBkZWNpbWFsX2RpZ2l0cyBkZWNpbWFsX2RpZ2l0cylcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgKCogQWxzbyBmYWlscyBpZiBbbWluXSBvciBbbWF4XSBpcyBuYW4gKilcbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgKCogY2xhbXBfdW5jaGVja2VkIGlzIGluIGZsb2F0MC5tbCAqKVxuICBjbGFtcF91bmNoZWNrZWRcbiAgICB+dG9fY2xhbXBfbWF5YmVfbmFuOnRcbiAgICB+bWluX3doaWNoX2lzX25vdF9uYW46bWluXG4gICAgfm1heF93aGljaF9pc19ub3RfbmFuOm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgKCogQWxzbyBmYWlscyBpZiBbbWluXSBvciBbbWF4XSBpcyBuYW4gKilcbiAgaWYgbWluIDw9IG1heFxuICB0aGVuXG4gICAgT2tcbiAgICAgIChjbGFtcF91bmNoZWNrZWRcbiAgICAgICAgIH50b19jbGFtcF9tYXliZV9uYW46dFxuICAgICAgICAgfm1pbl93aGljaF9pc19ub3RfbmFuOm1pblxuICAgICAgICAgfm1heF93aGljaF9pc19ub3RfbmFuOm1heClcbiAgZWxzZVxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbjs7XG5cbmxldCAoICsgKSA9ICggKy4gKVxubGV0ICggLSApID0gKCAtLiApXG5sZXQgKCAqICkgPSAoICouIClcbmxldCAoICoqICkgPSAoICoqIClcbmxldCAoIC8gKSA9ICggLy4gKVxubGV0ICggJSApID0gKCAlLiApXG5sZXQgKCB+LSApID0gKCB+LS4gKVxuXG5sZXRbQGlubGluZV0gc2lnbl9leG4gdCA6IFNpZ24udCA9XG4gIGlmIHQgPiAwLlxuICB0aGVuIFBvc1xuICBlbHNlIGlmIHQgPCAwLlxuICB0aGVuIE5lZ1xuICBlbHNlIGlmIHQgPSAwLlxuICB0aGVuIFplcm9cbiAgZWxzZSBFcnJvci5yYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJGbG9hdC5zaWduX2V4biBvZiBOQU5cIiBbIFwiXCIsIHNleHBfb2ZfdCB0IF0pXG47O1xuXG5sZXQgc2lnbl9vcl9uYW4gdCA6IFNpZ25fb3JfbmFuLnQgPVxuICBpZiB0ID4gMC4gdGhlbiBQb3MgZWxzZSBpZiB0IDwgMC4gdGhlbiBOZWcgZWxzZSBpZiB0ID0gMC4gdGhlbiBaZXJvIGVsc2UgTmFuXG47O1xuXG5sZXQgaWVlZV9uZWdhdGl2ZSB0ID1cbiAgbGV0IGJpdHMgPSBTdGRsaWIuSW50NjQuYml0c19vZl9mbG9hdCB0IGluXG4gIFBvbHkuKGJpdHMgPCBTdGRsaWIuSW50NjQuemVybylcbjs7XG5cbmxldCBleHBvbmVudF9iaXRzID0gMTFcbmxldCBtYW50aXNzYV9iaXRzID0gNTJcbmxldCBleHBvbmVudF9tYXNrNjQgPSBJbnQ2NC4oc2hpZnRfbGVmdCBvbmUgZXhwb25lbnRfYml0cyAtIG9uZSlcbmxldCBleHBvbmVudF9tYXNrID0gSW50NjQudG9faW50X2V4biBleHBvbmVudF9tYXNrNjRcbmxldCBtYW50aXNzYV9tYXNrID0gSW50NjMuKHNoaWZ0X2xlZnQgb25lIG1hbnRpc3NhX2JpdHMgLSBvbmUpXG5sZXQgbWFudGlzc2FfbWFzazY0ID0gSW50NjMudG9faW50NjQgbWFudGlzc2FfbWFza1xuXG5sZXQgaWVlZV9leHBvbmVudCB0ID1cbiAgbGV0IGJpdHMgPSBTdGRsaWIuSW50NjQuYml0c19vZl9mbG9hdCB0IGluXG4gIEludDY0LihiaXRfYW5kIChzaGlmdF9yaWdodF9sb2dpY2FsIGJpdHMgbWFudGlzc2FfYml0cykgZXhwb25lbnRfbWFzazY0KVxuICB8PiBTdGRsaWIuSW50NjQudG9faW50XG47O1xuXG5sZXQgaWVlZV9tYW50aXNzYSB0ID1cbiAgbGV0IGJpdHMgPSBTdGRsaWIuSW50NjQuYml0c19vZl9mbG9hdCB0IGluXG4gICgqIFRoaXMgaXMgc2FmZSBiZWNhdXNlIG1hbnRpc3NhX21hc2s2NCA8IEludDYzLm1heF92YWx1ZSAqKVxuICAoSW50NjMub2ZfaW50NjRfdHJ1bmMgW0BpbmxpbmVkXSkgU3RkbGliLkludDY0Lihsb2dhbmQgYml0cyBtYW50aXNzYV9tYXNrNjQpXG47O1xuXG5sZXQgY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhID1cbiAgaWYgSW50LihiaXRfYW5kIGV4cG9uZW50IGV4cG9uZW50X21hc2sgPD4gZXhwb25lbnQpXG4gIHRoZW4gZmFpbHdpdGhmIFwiZXhwb25lbnQgJWQgb3V0IG9mIHJhbmdlIFswLCAlZF1cIiBleHBvbmVudCBleHBvbmVudF9tYXNrICgpXG4gIGVsc2UgaWYgSW50NjMuKGJpdF9hbmQgbWFudGlzc2EgbWFudGlzc2FfbWFzayA8PiBtYW50aXNzYSlcbiAgdGhlblxuICAgIGZhaWx3aXRoZlxuICAgICAgXCJtYW50aXNzYSAlcyBvdXQgb2YgcmFuZ2UgWzAsICVzXVwiXG4gICAgICAoSW50NjMudG9fc3RyaW5nIG1hbnRpc3NhKVxuICAgICAgKEludDYzLnRvX3N0cmluZyBtYW50aXNzYV9tYXNrKVxuICAgICAgKClcbiAgZWxzZSAoXG4gICAgbGV0IHNpZ25fYml0cyA9IGlmIG5lZ2F0aXZlIHRoZW4gU3RkbGliLkludDY0Lm1pbl9pbnQgZWxzZSBTdGRsaWIuSW50NjQuemVybyBpblxuICAgIGxldCBleHB0X2JpdHMgPVxuICAgICAgU3RkbGliLkludDY0LnNoaWZ0X2xlZnQgKFN0ZGxpYi5JbnQ2NC5vZl9pbnQgZXhwb25lbnQpIG1hbnRpc3NhX2JpdHNcbiAgICBpblxuICAgIGxldCBtYW50X2JpdHMgPSBJbnQ2My50b19pbnQ2NCBtYW50aXNzYSBpblxuICAgIGxldCBiaXRzID0gU3RkbGliLkludDY0Lihsb2dvciBzaWduX2JpdHMgKGxvZ29yIGV4cHRfYml0cyBtYW50X2JpdHMpKSBpblxuICAgIFN0ZGxpYi5JbnQ2NC5mbG9hdF9vZl9iaXRzIGJpdHMpXG47O1xuXG5sZXQgY3JlYXRlX2llZWUgfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2EgPVxuICBPcl9lcnJvci50cnlfd2l0aCAoZnVuICgpIC0+IGNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYSlcbjs7XG5cbm1vZHVsZSBUZXJzZSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCB0X29mX3NleHAgPSB0X29mX3NleHBcbiAgbGV0IHRvX3N0cmluZyB4ID0gUHJpbnRmLnNwcmludGYgXCIlLjhHXCIgeFxuICBsZXQgc2V4cF9vZl90IHggPSBTZXhwLkF0b20gKHRvX3N0cmluZyB4KVxuICBsZXQgb2Zfc3RyaW5nIHggPSBvZl9zdHJpbmcgeFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgPSB0X3NleHBfZ3JhbW1hclxuZW5kXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICBpbmNsdWRlIFRcblxuICBsZXQgemVybyA9IHplcm9cbmVuZClcblxuKCogVGhlc2UgYXJlIHBhcnRseSBoZXJlIGFzIGEgcGVyZm9ybWFuY2UgaGFjayB0byBhdm9pZCBzb21lIGJveGluZyB3ZSdyZSBnZXR0aW5nIHdpdGhcbiAgIHRoZSB2ZXJzaW9ucyB3ZSBnZXQgZnJvbSBbV2l0aF96ZXJvXS4gIFRoZXkgYWxzbyBtYWtlIFtGbG9hdC5pc19uZWdhdGl2ZSBuYW5dIGFuZFxuICAgW0Zsb2F0LmlzX25vbl9wb3NpdGl2ZSBuYW5dIHJldHVybiBbZmFsc2VdOyB0aGUgdmVyc2lvbnMgd2UgZ2V0IGZyb20gW1dpdGhfemVyb10gcmV0dXJuXG4gICBbdHJ1ZV0uICopXG5sZXQgaXNfcG9zaXRpdmUgdCA9IHQgPiAwLlxubGV0IGlzX25vbl9uZWdhdGl2ZSB0ID0gdCA+PSAwLlxubGV0IGlzX25lZ2F0aXZlIHQgPSB0IDwgMC5cbmxldCBpc19ub25fcG9zaXRpdmUgdCA9IHQgPD0gMC5cblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gIGluY2x1ZGUgVFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5GbG9hdFwiXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbmVuZClcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgbGV0ICggKyApID0gKCArIClcbiAgbGV0ICggLSApID0gKCAtIClcbiAgbGV0ICggKiApID0gKCAqIClcbiAgbGV0ICggLyApID0gKCAvIClcbiAgbGV0ICggJSApID0gKCAlIClcbiAgbGV0ICggfi0gKSA9ICggfi0gKVxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSAoRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnQgPSBvZl9pbnRcbiAgbGV0IG9mX2Zsb2F0IHggPSB4XG5lbmRcblxubW9kdWxlIE9fZG90ID0gc3RydWN0XG4gIGxldCAoICouICkgPSAoICogKVxuICBsZXQgKCArLiApID0gKCArIClcbiAgbGV0ICggLS4gKSA9ICggLSApXG4gIGxldCAoIC8uICkgPSAoIC8gKVxuICBsZXQgKCAlLiApID0gKCAlIClcbiAgbGV0ICggfi0uICkgPSAoIH4tIClcbiAgbGV0ICggKiouICkgPSAoICoqIClcbmVuZFxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgYm94ID0gYm94XG4gIGxldCBjbGFtcF91bmNoZWNrZWQgPSBjbGFtcF91bmNoZWNrZWRcbiAgbGV0IGxvd2VyX2JvdW5kX2Zvcl9pbnQgPSBsb3dlcl9ib3VuZF9mb3JfaW50XG4gIGxldCB1cHBlcl9ib3VuZF9mb3JfaW50ID0gdXBwZXJfYm91bmRfZm9yX2ludFxuICBsZXQgc3BlY2lhbGl6ZWRfaGFzaCA9IGhhc2hfZmxvYXRcbiAgbGV0IG9uZV91bHBfbGVzc190aGFuX2hhbGYgPSBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmXG4gIGxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4biA9IGludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuXG4gIGxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2FsbG9jX2V4biA9IGludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYWxsb2NfZXhuXG4gIGxldCBpcm91bmRfbmVhcmVzdF9leG5fNjQgPSBpcm91bmRfbmVhcmVzdF9leG5fNjRcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbigqIFRoZXNlIGZ1bmN0aW9ucyBzcGVjaWZpY2FsbHkgcmVwbGFjZSBkZWZhdWx0cyBpbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuXG5cbiAgIFRoZSBkZXNpcmVkIGJlaGF2aW9yIGhlcmUgaXMgdG8gcHJvcGFnYXRlIGEgbmFuIGlmIGVpdGhlciBhcmd1bWVudCBpcyBuYW4uIEJlY2F1c2UgdGhlXG4gICBmaXJzdCBjb21wYXJpc29uIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZSBpZiBlaXRoZXIgYXJndW1lbnQgaXMgbmFuLCBpdCBzdWZmaWNlcyB0b1xuICAgY2hlY2sgaWYgeCBpcyBuYW4uIFRoZW4sIHdoZW4geCBpcyBuYW4gb3IgYm90aCB4IGFuZCB5IGFyZSBuYW4sIHdlIHJldHVybiB4ID0gbmFuOyBhbmRcbiAgIHdoZW4geSBpcyBuYW4gYnV0IG5vdCB4LCB3ZSByZXR1cm4geSA9IG5hbi5cblxuICAgVGhlcmUgYXJlIHZhcmlvdXMgd2F5cyB0byBpbXBsZW1lbnQgdGhlc2UgZnVuY3Rpb25zLiAgVGhlIGJlbmNobWFyayBiZWxvdyBzaG93cyBhIGZld1xuICAgZGlmZmVyZW50IHZlcnNpb25zLiAgVGhpcyBiZW5jaG1hcmsgd2FzIHJ1biBvdmVyIGFuIGFycmF5IG9mIHJhbmRvbSBmbG9hdHMgKG5vbmUgb2ZcbiAgIHdoaWNoIGFyZSBuYW4pLlxuXG4gICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgIOKUgiBOYW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiBUaW1lL1J1biDilIJcbiAgIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAg4pSCIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIGlmIHggPCB5IHRoZW4geCBlbHNlIHkg4pSCICAgMi40MnVzIOKUglxuICAg4pSCIGlmIGlzX25hbiB4IHx8IHggPCB5IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMi4wMnVzIOKUglxuICAg4pSCIGlmIHggPCB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMS44OHVzIOKUglxuICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cbiAgIFRoZSBiZW5jaG1hcmsgYmVsb3cgd2FzIHJ1biB3aGVuIHggPiB5IGlzIGFsd2F5cyB0cnVlIChhZ2Fpbiwgbm8gbmFuIHZhbHVlcykuXG5cbiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAg4pSCIE5hbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCIFRpbWUvUnVuIOKUglxuICAg4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICDilIIgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgaWYgeCA8IHkgdGhlbiB4IGVsc2UgeSDilIIgICAyLjgzdXMg4pSCXG4gICDilIIgaWYgaXNfbmFuIHggfHwgeCA8IHkgdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAxLjk3dXMg4pSCXG4gICDilIIgaWYgeCA8IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAxLjU2dXMg4pSCXG4gICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiopXG5sZXQgbWluICh4IDogdCkgeSA9IGlmIHggPCB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHlcbmxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEJ1ZmZlcl9pbnRmXG5pbmNsdWRlIFN0ZGxpYi5CdWZmZXJcblxubGV0IGNvbnRlbnRzX2J5dGVzID0gdG9fYnl0ZXNcbmxldCBhZGRfc3Vic3RyaW5nIHQgcyB+cG9zIH5sZW4gPSBhZGRfc3Vic3RyaW5nIHQgcyBwb3MgbGVuXG5sZXQgYWRkX3N1YmJ5dGVzIHQgcyB+cG9zIH5sZW4gPSBhZGRfc3ViYnl0ZXMgdCBzIHBvcyBsZW5cbmxldCBzZXhwX29mX3QgdCA9IHNleHBfb2Zfc3RyaW5nIChjb250ZW50cyB0KVxubGV0IGNhbWxfYnVmZmVyX2xlbmd0aCA9IChTdGRsaWIuT2JqLm1hZ2ljIChTdGRsaWIuQnVmZmVyLmxlbmd0aCA6IHQgLT4gaW50KSA6IHQgLT4gaW50KVxuXG5sZXQgY2FtbF9idWZmZXJfYmxpdCA9XG4gIChTdGRsaWIuT2JqLm1hZ2ljXG4gICAgIChTdGRsaWIuQnVmZmVyLmJsaXQgOiBTdGRsaWIuQnVmZmVyLnQgLT4gaW50IC0+IEJ5dGVzLnQgLT4gaW50IC0+IGludCAtPiB1bml0KVxuICAgIDogU3RkbGliLkJ1ZmZlci50IC0+IGludCAtPiBCeXRlcy50IC0+IGludCAtPiBpbnQgLT4gdW5pdClcbjs7XG5cbm1vZHVsZSBUb19ieXRlcyA9XG4gIEJsaXQuTWFrZV9kaXN0aW5jdFxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGxldCBsZW5ndGggPSBjYW1sX2J1ZmZlcl9sZW5ndGhcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gQnl0ZXMudFxuXG4gICAgICBsZXQgY3JlYXRlIH5sZW4gPSBCeXRlcy5jcmVhdGUgbGVuXG4gICAgICBsZXQgbGVuZ3RoID0gQnl0ZXMubGVuZ3RoXG5cbiAgICAgIGxldCB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gICAgICAgIGNhbWxfYnVmZmVyX2JsaXQgc3JjIHNyY19wb3MgZHN0IGRzdF9wb3MgbGVuXG4gICAgICA7O1xuICAgIGVuZClcblxuaW5jbHVkZSBUb19ieXRlc1xubW9kdWxlIFRvX3N0cmluZyA9IEJsaXQuTWFrZV90b19zdHJpbmcgKFN0ZGxpYi5CdWZmZXIpIChUb19ieXRlcylcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIFN5cyA9IFN5czBcblxudHlwZSB0ID0gU3RkbGliLlByaW50ZXhjLnJhd19iYWNrdHJhY2VcblxubGV0IGVsaWRlID0gcmVmIGZhbHNlXG5sZXQgZWxpZGVkX21lc3NhZ2UgPSBcIjxiYWNrdHJhY2UgZWxpZGVkIGluIHRlc3Q+XCJcblxubGV0IGdldCA/KGF0X21vc3RfbnVtX2ZyYW1lcyA9IEludC5tYXhfdmFsdWUpICgpID1cbiAgU3RkbGliLlByaW50ZXhjLmdldF9jYWxsc3RhY2sgYXRfbW9zdF9udW1fZnJhbWVzXG47O1xuXG5sZXQgdG9fc3RyaW5nIHQgPVxuICBpZiAhZWxpZGUgdGhlbiBlbGlkZWRfbWVzc2FnZSBlbHNlIFN0ZGxpYi5QcmludGV4Yy5yYXdfYmFja3RyYWNlX3RvX3N0cmluZyB0XG47O1xuXG5sZXQgdG9fc3RyaW5nX2xpc3QgdCA9IFN0cmluZy5zcGxpdF9saW5lcyAodG9fc3RyaW5nIHQpXG5sZXQgc2V4cF9vZl90IHQgPSBTZXhwLkxpc3QgKExpc3QubWFwICh0b19zdHJpbmdfbGlzdCB0KSB+ZjooZnVuIHggLT4gU2V4cC5BdG9tIHgpKVxuXG5tb2R1bGUgRXhuID0gc3RydWN0XG4gIGxldCBzZXRfcmVjb3JkaW5nID0gU3RkbGliLlByaW50ZXhjLnJlY29yZF9iYWNrdHJhY2VcbiAgbGV0IGFtX3JlY29yZGluZyA9IFN0ZGxpYi5QcmludGV4Yy5iYWNrdHJhY2Vfc3RhdHVzXG4gIGxldCBtb3N0X3JlY2VudCAoKSA9IFN0ZGxpYi5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKVxuXG4gIGxldCBtb3N0X3JlY2VudF9mb3JfZXhuIGV4biA9XG4gICAgaWYgRXhuLmlzX3BoeXNfZXF1YWxfbW9zdF9yZWNlbnQgZXhuIHRoZW4gU29tZSAobW9zdF9yZWNlbnQgKCkpIGVsc2UgTm9uZVxuICA7O1xuXG4gICgqIFdlIHR1cm4gb24gYmFja3RyYWNlcyBieSBkZWZhdWx0IGlmIE9DQU1MUlVOUEFSQU0gZG9lc24ndCBleHBsaWNpdGx5IG1lbnRpb24gdGhlbS4gKilcbiAgbGV0IG1heWJlX3NldF9yZWNvcmRpbmcgKCkgPVxuICAgIGxldCBvY2FtbHJ1bnBhcmFtX21lbnRpb25zX2JhY2t0cmFjZXMgPVxuICAgICAgbWF0Y2ggU3lzLmdldGVudiBcIk9DQU1MUlVOUEFSQU1cIiB3aXRoXG4gICAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICAgIHwgU29tZSB4IC0+IExpc3QuZXhpc3RzIChTdHJpbmcuc3BsaXQgeCB+b246JywnKSB+ZjooU3RyaW5nLmlzX3ByZWZpeCB+cHJlZml4OlwiYlwiKVxuICAgIGluXG4gICAgaWYgbm90IG9jYW1scnVucGFyYW1fbWVudGlvbnNfYmFja3RyYWNlcyB0aGVuIHNldF9yZWNvcmRpbmcgdHJ1ZVxuICA7O1xuXG4gICgqIHRoZSBjYWxsZXIgc2V0IHNvbWV0aGluZywgdGhleSBhcmUgcmVzcG9uc2libGUgKilcblxuICBsZXQgd2l0aF9yZWNvcmRpbmcgYiB+ZiA9XG4gICAgbGV0IHNhdmVkID0gYW1fcmVjb3JkaW5nICgpIGluXG4gICAgc2V0X3JlY29yZGluZyBiO1xuICAgIEV4bi5wcm90ZWN0IH5mIH5maW5hbGx5OihmdW4gKCkgLT4gc2V0X3JlY29yZGluZyBzYXZlZClcbiAgOztcbmVuZFxuXG5sZXQgaW5pdGlhbGl6ZV9tb2R1bGUgKCkgPSBFeG4ubWF5YmVfc2V0X3JlY29yZGluZyAoKVxuIiwiKCoqIFRoaXMgbW9kdWxlIGlzIHRoZSB0b3BsZXZlbCBvZiB0aGUgQmFzZSBsaWJyYXJ5OyBpdCdzIHdoYXQgeW91IGdldCB3aGVuIHlvdSB3cml0ZVxuICAgIFtvcGVuIEJhc2VdLlxuXG4gICAgVGhlIGdvYWwgb2YgQmFzZSBpcyBib3RoIHRvIGJlIGEgbW9yZSBjb21wbGV0ZSBzdGFuZGFyZCBsaWJyYXJ5LCB3aXRoIHJpY2hlciBBUElzLFxuICAgIGFuZCB0byBiZSBtb3JlIGNvbnNpc3RlbnQgaW4gaXRzIGRlc2lnbi4gRm9yIGluc3RhbmNlLCBpbiB0aGUgc3RhbmRhcmQgbGlicmFyeVxuICAgIHNvbWUgdGhpbmdzIGhhdmUgbW9kdWxlcyBhbmQgb3RoZXJzIGRvbid0OyBpbiBCYXNlLCBldmVyeXRoaW5nIGlzIGEgbW9kdWxlLlxuXG4gICAgQmFzZSBleHRlbmRzIHNvbWUgbW9kdWxlcyBhbmQgZGF0YSBzdHJ1Y3R1cmVzIGZyb20gdGhlIHN0YW5kYXJkIGxpYnJhcnksIGxpa2UgW0FycmF5XSxcbiAgICBbQnVmZmVyXSwgW0J5dGVzXSwgW0NoYXJdLCBbSGFzaHRibF0sIFtJbnQzMl0sIFtJbnQ2NF0sIFtMYXp5XSwgW0xpc3RdLCBbTWFwXSxcbiAgICBbTmF0aXZlaW50XSwgW1ByaW50Zl0sIFtSYW5kb21dLCBbU2V0XSwgW1N0cmluZ10sIFtTeXNdLCBhbmQgW1VjaGFyXS4gT25lIGtleVxuICAgIGRpZmZlcmVuY2UgaXMgdGhhdCBCYXNlIGRvZXNuJ3QgdXNlIGV4Y2VwdGlvbnMgYXMgbXVjaCBhcyB0aGUgc3RhbmRhcmQgbGlicmFyeSBhbmRcbiAgICBpbnN0ZWFkIG1ha2VzIGhlYXZ5IHVzZSBvZiB0aGUgW1Jlc3VsdF0gdHlwZSwgYXMgaW46XG5cbiAgICB7WyB0eXBlICgnYSwnYikgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnYiBdfVxuXG4gICAgQmFzZSBhbHNvIGFkZHMgZW50aXJlbHkgbmV3IG1vZHVsZXMsIG1vc3Qgbm90YWJseTpcblxuICAgIC0gW0NvbXBhcmFibGVdLCBbQ29tcGFyYXRvcl0sIGFuZCBbQ29tcGFyaXNvbnNdIGluIGxpZXUgb2YgcG9seW1vcnBoaWMgY29tcGFyZS5cbiAgICAtIFtDb250YWluZXJdLCB3aGljaCBwcm92aWRlcyBhIGNvbnNpc3RlbnQgaW50ZXJmYWNlIGFjcm9zcyBjb250YWluZXItbGlrZSBkYXRhXG4gICAgICBzdHJ1Y3R1cmVzIChhcnJheXMsIGxpc3RzLCBzdHJpbmdzKS5cbiAgICAtIFtSZXN1bHRdLCBbRXJyb3JdLCBhbmQgW09yX2Vycm9yXSwgc3VwcG9ydGluZyB0aGUgb3ItZXJyb3IgcGF0dGVybi5cbiopXG5cbigqXyBXZSBoaWRlIHRoaXMgZnJvbSB0aGUgd2ViIGRvY3MgYmVjYXVzZSB0aGUgbGluZSB3cmFwcGluZyBpcyBiYWQsIG1ha2luZyBpdFxuICBwcmV0dHkgbXVjaCBpbnNjcnV0YWJsZS4gKilcbigqKi8qKilcblxuKCogVGhlIGludGVudCBpcyB0byBzaGFkb3cgYWxsIG9mIElOUklBJ3Mgc3RhbmRhcmQgbGlicmFyeS4gIE1vZHVsZXMgYmVsb3cgd291bGQgY2F1c2VcbiAgIGNvbXBpbGF0aW9uIGVycm9ycyB3aXRob3V0IGJlaW5nIHJlbW92ZWQgZnJvbSBbU2hhZG93X3N0ZGxpYl0gYmVmb3JlIGluY2x1c2lvbi4gKilcblxuaW5jbHVkZSAoXG4gIFNoYWRvd19zdGRsaWIgOlxuICAgIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgICAgaW5jbHVkZSBTaGFkb3dfc3RkbGliXG4gICAgZW5kXG4gICAgKCogTW9kdWxlcyBkZWZpbmVkIGluIEJhc2UgKilcbiAgICB3aXRoIG1vZHVsZSBBcnJheSA6PSBTaGFkb3dfc3RkbGliLkFycmF5XG4gICAgd2l0aCBtb2R1bGUgQXRvbWljIDo9IFNoYWRvd19zdGRsaWIuQXRvbWljXG4gICAgd2l0aCBtb2R1bGUgQm9vbCA6PSBTaGFkb3dfc3RkbGliLkJvb2xcbiAgICB3aXRoIG1vZHVsZSBCdWZmZXIgOj0gU2hhZG93X3N0ZGxpYi5CdWZmZXJcbiAgICB3aXRoIG1vZHVsZSBCeXRlcyA6PSBTaGFkb3dfc3RkbGliLkJ5dGVzXG4gICAgd2l0aCBtb2R1bGUgQ2hhciA6PSBTaGFkb3dfc3RkbGliLkNoYXJcbiAgICB3aXRoIG1vZHVsZSBDb25kaXRpb24gOj0gU2hhZG93X3N0ZGxpYi5Db25kaXRpb25cbiAgICB3aXRoIG1vZHVsZSBFaXRoZXIgOj0gU2hhZG93X3N0ZGxpYi5FaXRoZXJcbiAgICB3aXRoIG1vZHVsZSBGbG9hdCA6PSBTaGFkb3dfc3RkbGliLkZsb2F0XG4gICAgd2l0aCBtb2R1bGUgSGFzaHRibCA6PSBTaGFkb3dfc3RkbGliLkhhc2h0YmxcbiAgICB3aXRoIG1vZHVsZSBJbl9jaGFubmVsIDo9IFNoYWRvd19zdGRsaWIuSW5fY2hhbm5lbFxuICAgIHdpdGggbW9kdWxlIEludCA6PSBTaGFkb3dfc3RkbGliLkludFxuICAgIHdpdGggbW9kdWxlIEludDMyIDo9IFNoYWRvd19zdGRsaWIuSW50MzJcbiAgICB3aXRoIG1vZHVsZSBJbnQ2NCA6PSBTaGFkb3dfc3RkbGliLkludDY0XG4gICAgd2l0aCBtb2R1bGUgTGF6eSA6PSBTaGFkb3dfc3RkbGliLkxhenlcbiAgICB3aXRoIG1vZHVsZSBMaXN0IDo9IFNoYWRvd19zdGRsaWIuTGlzdFxuICAgIHdpdGggbW9kdWxlIE1hcCA6PSBTaGFkb3dfc3RkbGliLk1hcFxuICAgIHdpdGggbW9kdWxlIE5hdGl2ZWludCA6PSBTaGFkb3dfc3RkbGliLk5hdGl2ZWludFxuICAgIHdpdGggbW9kdWxlIE9wdGlvbiA6PSBTaGFkb3dfc3RkbGliLk9wdGlvblxuICAgIHdpdGggbW9kdWxlIE91dF9jaGFubmVsIDo9IFNoYWRvd19zdGRsaWIuT3V0X2NoYW5uZWxcbiAgICB3aXRoIG1vZHVsZSBQcmludGYgOj0gU2hhZG93X3N0ZGxpYi5QcmludGZcbiAgICB3aXRoIG1vZHVsZSBRdWV1ZSA6PSBTaGFkb3dfc3RkbGliLlF1ZXVlXG4gICAgd2l0aCBtb2R1bGUgUmFuZG9tIDo9IFNoYWRvd19zdGRsaWIuUmFuZG9tXG4gICAgd2l0aCBtb2R1bGUgUmVzdWx0IDo9IFNoYWRvd19zdGRsaWIuUmVzdWx0XG4gICAgd2l0aCBtb2R1bGUgU2V0IDo9IFNoYWRvd19zdGRsaWIuU2V0XG4gICAgd2l0aCBtb2R1bGUgU2VtYXBob3JlIDo9IFNoYWRvd19zdGRsaWIuU2VtYXBob3JlXG4gICAgd2l0aCBtb2R1bGUgU3RhY2sgOj0gU2hhZG93X3N0ZGxpYi5TdGFja1xuICAgIHdpdGggbW9kdWxlIFN0cmluZyA6PSBTaGFkb3dfc3RkbGliLlN0cmluZ1xuICAgIHdpdGggbW9kdWxlIFN5cyA6PSBTaGFkb3dfc3RkbGliLlN5c1xuICAgIHdpdGggbW9kdWxlIFVjaGFyIDo9IFNoYWRvd19zdGRsaWIuVWNoYXJcbiAgICB3aXRoIG1vZHVsZSBVbml0IDo9IFNoYWRvd19zdGRsaWIuVW5pdFxuICAgICgqIE9DYW1sIDUtcmVsYXRlZCBtb2R1bGVzIHdlIGRvbid0IHdhbnQgdG8gc3RhcnQgc2hhZG93aW5nIHlldC4gKilcbiAgICB3aXRoIG1vZHVsZSBEb21haW4gOj0gU2hhZG93X3N0ZGxpYi5Eb21haW5cbiAgICB3aXRoIG1vZHVsZSBUeXBlIDo9IFNoYWRvd19zdGRsaWIuVHlwZVxuICAgICgqIFN1cHBvcnQgZm9yIGdlbmVyYXRlZCBsZXhlcnMgKilcbiAgICB3aXRoIG1vZHVsZSBMZXhpbmcgOj0gU2hhZG93X3N0ZGxpYi5MZXhpbmdcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA6PSAoJ2EsICdiLCAnYykgZm9ybWF0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA6PSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgOj0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgICB3aXRoIHR5cGUgJ2EgcmVmIDo9ICdhIHJlZilcbltAb2NhbWwud2FybmluZyBcIi0zXCJdXG5cbigqKi8qKilcblxub3BlbiEgSW1wb3J0XG5tb2R1bGUgQXBwbGljYXRpdmUgPSBBcHBsaWNhdGl2ZVxubW9kdWxlIEFycmF5ID0gQXJyYXlcbm1vZHVsZSBBdmx0cmVlID0gQXZsdHJlZVxubW9kdWxlIEJhY2t0cmFjZSA9IEJhY2t0cmFjZVxubW9kdWxlIEJpbmFyeV9zZWFyY2ggPSBCaW5hcnlfc2VhcmNoXG5tb2R1bGUgQmluYXJ5X3NlYXJjaGFibGUgPSBCaW5hcnlfc2VhcmNoYWJsZVxubW9kdWxlIEJsaXQgPSBCbGl0XG5tb2R1bGUgQm9vbCA9IEJvb2xcbm1vZHVsZSBCdWZmZXIgPSBCdWZmZXJcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzXG5tb2R1bGUgQ2hhciA9IENoYXJcbm1vZHVsZSBDb21wYXJhYmxlID0gQ29tcGFyYWJsZVxubW9kdWxlIENvbXBhcmF0b3IgPSBDb21wYXJhdG9yXG5tb2R1bGUgQ29tcGFyaXNvbnMgPSBDb21wYXJpc29uc1xubW9kdWxlIENvbnRhaW5lciA9IENvbnRhaW5lclxubW9kdWxlIEVpdGhlciA9IEVpdGhlclxubW9kdWxlIEVxdWFsID0gRXF1YWxcbm1vZHVsZSBFcnJvciA9IEVycm9yXG5tb2R1bGUgRXhuID0gRXhuXG5tb2R1bGUgRmllbGQgPSBGaWVsZFxubW9kdWxlIEZsb2F0ID0gRmxvYXRcbm1vZHVsZSBGbG9hdGFibGUgPSBGbG9hdGFibGVcbm1vZHVsZSBGbiA9IEZuXG5tb2R1bGUgRm9ybWF0dGVyID0gRm9ybWF0dGVyXG5tb2R1bGUgSGFzaCA9IEhhc2hcbm1vZHVsZSBIYXNoX3NldCA9IEhhc2hfc2V0XG5tb2R1bGUgSGFzaGFibGUgPSBIYXNoYWJsZVxubW9kdWxlIEhhc2hlciA9IEhhc2hlclxubW9kdWxlIEhhc2h0YmwgPSBIYXNodGJsXG5tb2R1bGUgSWRlbnRpZmlhYmxlID0gSWRlbnRpZmlhYmxlXG5tb2R1bGUgSW5kZXhlZF9jb250YWluZXIgPSBJbmRleGVkX2NvbnRhaW5lclxubW9kdWxlIEluZm8gPSBJbmZvXG5tb2R1bGUgSW50ID0gSW50XG5tb2R1bGUgSW50MzIgPSBJbnQzMlxubW9kdWxlIEludDYzID0gSW50NjNcbm1vZHVsZSBJbnQ2NCA9IEludDY0XG5tb2R1bGUgSW50YWJsZSA9IEludGFibGVcbm1vZHVsZSBJbnRfbWF0aCA9IEludF9tYXRoXG5tb2R1bGUgSW52YXJpYW50ID0gSW52YXJpYW50XG5tb2R1bGUgRGljdGlvbmFyeV9pbW11dGFibGUgPSBEaWN0aW9uYXJ5X2ltbXV0YWJsZVxubW9kdWxlIERpY3Rpb25hcnlfbXV0YWJsZSA9IERpY3Rpb25hcnlfbXV0YWJsZVxubW9kdWxlIExhenkgPSBMYXp5XG5tb2R1bGUgTGlzdCA9IExpc3Rcbm1vZHVsZSBNYXAgPSBNYXBcbm1vZHVsZSBNYXliZV9ib3VuZCA9IE1heWJlX2JvdW5kXG5tb2R1bGUgTW9uYWQgPSBNb25hZFxubW9kdWxlIE5hdGl2ZWludCA9IE5hdGl2ZWludFxubW9kdWxlIE5vdGhpbmcgPSBOb3RoaW5nXG5tb2R1bGUgT3B0aW9uID0gT3B0aW9uXG5tb2R1bGUgT3B0aW9uX2FycmF5ID0gT3B0aW9uX2FycmF5XG5tb2R1bGUgT3JfZXJyb3IgPSBPcl9lcnJvclxubW9kdWxlIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24gPSBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uXG5tb2R1bGUgT3JkZXJpbmcgPSBPcmRlcmluZ1xubW9kdWxlIFBvbHkgPSBQb2x5XG5tb2R1bGUgUHJldHR5X3ByaW50ZXIgPSBQcmV0dHlfcHJpbnRlclxubW9kdWxlIFByaW50ZiA9IFByaW50ZlxubW9kdWxlIExpbmtlZF9xdWV1ZSA9IExpbmtlZF9xdWV1ZVxubW9kdWxlIFF1ZXVlID0gUXVldWVcbm1vZHVsZSBSYW5kb20gPSBSYW5kb21cbm1vZHVsZSBSZWYgPSBSZWZcbm1vZHVsZSBSZXN1bHQgPSBSZXN1bHRcbm1vZHVsZSBTZXF1ZW5jZSA9IFNlcXVlbmNlXG5tb2R1bGUgU2V0ID0gU2V0XG5tb2R1bGUgU2V4cGFibGUgPSBTZXhwYWJsZVxubW9kdWxlIFNpZ24gPSBTaWduXG5tb2R1bGUgU2lnbl9vcl9uYW4gPSBTaWduX29yX25hblxubW9kdWxlIFNvdXJjZV9jb2RlX3Bvc2l0aW9uID0gU291cmNlX2NvZGVfcG9zaXRpb25cbm1vZHVsZSBTdGFjayA9IFN0YWNrXG5tb2R1bGUgU3RhZ2VkID0gU3RhZ2VkXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nXG5tb2R1bGUgU3RyaW5nYWJsZSA9IFN0cmluZ2FibGVcbm1vZHVsZSBTeXMgPSBTeXNcbm1vZHVsZSBUID0gVFxubW9kdWxlIFR5cGVfZXF1YWwgPSBUeXBlX2VxdWFsXG5tb2R1bGUgVW5pZm9ybV9hcnJheSA9IFVuaWZvcm1fYXJyYXlcbm1vZHVsZSBVbml0ID0gVW5pdFxubW9kdWxlIFVjaGFyID0gVWNoYXJcbm1vZHVsZSBWYXJpYW50ID0gVmFyaWFudFxubW9kdWxlIFdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm5cbm1vZHVsZSBXb3JkX3NpemUgPSBXb3JkX3NpemVcblxuKCogQXZvaWQgYSBsZXZlbCBvZiBpbmRpcmVjdGlvbiBmb3IgdXNlcyBvZiB0aGUgc2lnbmF0dXJlcyBkZWZpbmVkIGluIFtUXS4gKilcbmluY2x1ZGUgVFxuXG4oKiBUaGlzIGlzIGEgaGFjayBzbyB0aGF0IG9kb2MgY3JlYXRlcyBiZXR0ZXIgZG9jdW1lbnRhdGlvbi4gKilcbm1vZHVsZSBTZXhwID0gc3RydWN0XG4gIGluY2x1ZGUgU2V4cF93aXRoX2NvbXBhcmFibGUgKCoqIEBpbmxpbmUgKilcbmVuZFxuXG4oKiBbSW50X3N0cmluZ19jb252ZXJzaW9uc10gaXMgc2VwYXJhdGVkIGZyb20gW0ludF9jb252ZXJzaW9uc10gZm9yIGRlcGVuZGVuY3kgcmVhc29ucyxcbiAgIGJ1dCB0aGlzIHNlcGFyYXRpb24gaXMgbm90IGltcG9ydGFudCBmb3IgY2xpZW50cy4gKilcbm1vZHVsZSBJbnRfY29udmVyc2lvbnMgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbnRfY29udmVyc2lvbnNcbiAgaW5jbHVkZSBJbnRfc3RyaW5nX2NvbnZlcnNpb25zXG5lbmRcblxuKCoqLyoqKVxuXG5tb2R1bGUgRXhwb3J0ZWRfZm9yX3NwZWNpZmljX3VzZXMgPSBzdHJ1Y3RcbiAgbW9kdWxlIEZpZWxkc2xpYiA9IEZpZWxkc2xpYlxuICBtb2R1bGUgR2xvYmFsaXplID0gR2xvYmFsaXplXG4gIG1vZHVsZSBPYmpfbG9jYWwgPSBPYmpfbG9jYWxcbiAgbW9kdWxlIFBweF9jb21wYXJlX2xpYiA9IFBweF9jb21wYXJlX2xpYlxuICBtb2R1bGUgUHB4X2VudW1lcmF0ZV9saWIgPSBQcHhfZW51bWVyYXRlX2xpYlxuICBtb2R1bGUgUHB4X2hhc2hfbGliID0gUHB4X2hhc2hfbGliXG4gIG1vZHVsZSBWYXJpYW50c2xpYiA9IFZhcmlhbnRzbGliXG5cbiAgbGV0IGFtX3Rlc3RpbmcgPSBhbV90ZXN0aW5nXG5lbmRcblxuKCoqLyoqKVxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gICgqIFtkZXJpdmluZyBoYXNoXSBpcyBtaXNzaW5nIGZvciBbYXJyYXldIGFuZCBbcmVmXSBzaW5jZSB0aGVzZSB0eXBlcyBhcmUgbXV0YWJsZS4gKilcbiAgdHlwZSAnYSBhcnJheSA9ICdhIEFycmF5LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2FycmF5X19sb2NhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSAtPiBpbnQgPVxuICAgIEFycmF5LmNvbXBhcmVfX2xvY2FsXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfYXJyYXkgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gaW50ID0gQXJyYXkuY29tcGFyZVxuXG4gIGxldCBlcXVhbF9hcnJheV9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+IGJvb2wgPVxuICAgIEFycmF5LmVxdWFsX19sb2NhbFxuICA7O1xuXG4gIGxldCBlcXVhbF9hcnJheSA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gYm9vbCA9IEFycmF5LmVxdWFsXG5cbiAgbGV0IGdsb2JhbGl6ZV9hcnJheSA6ICdhLiAoJ2EgLT4gJ2EpIC0+ICdhIGFycmF5IC0+ICdhIGFycmF5ID1cbiAgICBmdW4gKHR5cGUgYV9fMDE3XykgOiAoKGFfXzAxN18gLT4gYV9fMDE3XykgLT4gYV9fMDE3XyBhcnJheSAtPiBhX18wMTdfIGFycmF5KSAtPlxuICAgIEFycmF5Lmdsb2JhbGl6ZVxuICA7O1xuXG4gIGxldCBhcnJheV9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSBhcnJheSA9XG4gICAgQXJyYXkudF9vZl9zZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfYXJyYXkgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgYXJyYXkgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBBcnJheS5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgYXJyYXlfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIGFycmF5IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IEFycmF5LnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgYm9vbCA9IEJvb2wudFxuICBbQEBkZXJpdmluZ19pbmxpbmVcbiAgICBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9ib29sX19sb2NhbCA9IChCb29sLmNvbXBhcmVfX2xvY2FsIDogYm9vbCAtPiBib29sIC0+IGludClcbiAgbGV0IGNvbXBhcmVfYm9vbCA9IChmdW4gYSBiIC0+IGNvbXBhcmVfYm9vbF9fbG9jYWwgYSBiIDogYm9vbCAtPiBib29sIC0+IGludClcbiAgbGV0IGVxdWFsX2Jvb2xfX2xvY2FsID0gKEJvb2wuZXF1YWxfX2xvY2FsIDogYm9vbCAtPiBib29sIC0+IGJvb2wpXG4gIGxldCBlcXVhbF9ib29sID0gKGZ1biBhIGIgLT4gZXF1YWxfYm9vbF9fbG9jYWwgYSBiIDogYm9vbCAtPiBib29sIC0+IGJvb2wpXG4gIGxldCAoZ2xvYmFsaXplX2Jvb2wgOiBib29sIC0+IGJvb2wpID0gKEJvb2wuZ2xvYmFsaXplIDogYm9vbCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX2Jvb2wgOlxuICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYm9vbCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIEJvb2wuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfYm9vbCA6IGJvb2wgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEJvb2wuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBib29sX29mX3NleHAgPSAoQm9vbC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gYm9vbClcbiAgbGV0IHNleHBfb2ZfYm9vbCA9IChCb29sLnNleHBfb2ZfdCA6IGJvb2wgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGJvb2xfc2V4cF9ncmFtbWFyIDogYm9vbCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBCb29sLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGNoYXIgPSBDaGFyLnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfY2hhcl9fbG9jYWwgPSAoQ2hhci5jb21wYXJlX19sb2NhbCA6IGNoYXIgLT4gY2hhciAtPiBpbnQpXG4gIGxldCBjb21wYXJlX2NoYXIgPSAoZnVuIGEgYiAtPiBjb21wYXJlX2NoYXJfX2xvY2FsIGEgYiA6IGNoYXIgLT4gY2hhciAtPiBpbnQpXG4gIGxldCBlcXVhbF9jaGFyX19sb2NhbCA9IChDaGFyLmVxdWFsX19sb2NhbCA6IGNoYXIgLT4gY2hhciAtPiBib29sKVxuICBsZXQgZXF1YWxfY2hhciA9IChmdW4gYSBiIC0+IGVxdWFsX2NoYXJfX2xvY2FsIGEgYiA6IGNoYXIgLT4gY2hhciAtPiBib29sKVxuICBsZXQgKGdsb2JhbGl6ZV9jaGFyIDogY2hhciAtPiBjaGFyKSA9IChDaGFyLmdsb2JhbGl6ZSA6IGNoYXIgLT4gY2hhcilcblxuICBsZXQgKGhhc2hfZm9sZF9jaGFyIDpcbiAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGNoYXIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBDaGFyLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2NoYXIgOiBjaGFyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBDaGFyLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgY2hhcl9vZl9zZXhwID0gKENoYXIudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGNoYXIpXG4gIGxldCBzZXhwX29mX2NoYXIgPSAoQ2hhci5zZXhwX29mX3QgOiBjaGFyIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChjaGFyX3NleHBfZ3JhbW1hciA6IGNoYXIgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gQ2hhci50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBleG4gPSBFeG4udCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICBsZXQgc2V4cF9vZl9leG4gPSAoRXhuLnNleHBfb2ZfdCA6IGV4biAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGZsb2F0ID0gRmxvYXQudFxuICBbQEBkZXJpdmluZ19pbmxpbmVcbiAgICBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9mbG9hdF9fbG9jYWwgPSAoRmxvYXQuY29tcGFyZV9fbG9jYWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBpbnQpXG4gIGxldCBjb21wYXJlX2Zsb2F0ID0gKGZ1biBhIGIgLT4gY29tcGFyZV9mbG9hdF9fbG9jYWwgYSBiIDogZmxvYXQgLT4gZmxvYXQgLT4gaW50KVxuICBsZXQgZXF1YWxfZmxvYXRfX2xvY2FsID0gKEZsb2F0LmVxdWFsX19sb2NhbCA6IGZsb2F0IC0+IGZsb2F0IC0+IGJvb2wpXG4gIGxldCBlcXVhbF9mbG9hdCA9IChmdW4gYSBiIC0+IGVxdWFsX2Zsb2F0X19sb2NhbCBhIGIgOiBmbG9hdCAtPiBmbG9hdCAtPiBib29sKVxuICBsZXQgKGdsb2JhbGl6ZV9mbG9hdCA6IGZsb2F0IC0+IGZsb2F0KSA9IChGbG9hdC5nbG9iYWxpemUgOiBmbG9hdCAtPiBmbG9hdClcblxuICBsZXQgKGhhc2hfZm9sZF9mbG9hdCA6XG4gICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBmbG9hdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIEZsb2F0Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2Zsb2F0IDogZmxvYXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEZsb2F0Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgZmxvYXRfb2Zfc2V4cCA9IChGbG9hdC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gZmxvYXQpXG4gIGxldCBzZXhwX29mX2Zsb2F0ID0gKEZsb2F0LnNleHBfb2ZfdCA6IGZsb2F0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChmbG9hdF9zZXhwX2dyYW1tYXIgOiBmbG9hdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBGbG9hdC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBpbnQgPSBJbnQudFxuICBbQEBkZXJpdmluZ19pbmxpbmVcbiAgICBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9pbnRfX2xvY2FsID0gKEludC5jb21wYXJlX19sb2NhbCA6IGludCAtPiBpbnQgLT4gaW50KVxuICBsZXQgY29tcGFyZV9pbnQgPSAoZnVuIGEgYiAtPiBjb21wYXJlX2ludF9fbG9jYWwgYSBiIDogaW50IC0+IGludCAtPiBpbnQpXG4gIGxldCBlcXVhbF9pbnRfX2xvY2FsID0gKEludC5lcXVhbF9fbG9jYWwgOiBpbnQgLT4gaW50IC0+IGJvb2wpXG4gIGxldCBlcXVhbF9pbnQgPSAoZnVuIGEgYiAtPiBlcXVhbF9pbnRfX2xvY2FsIGEgYiA6IGludCAtPiBpbnQgLT4gYm9vbClcbiAgbGV0IChnbG9iYWxpemVfaW50IDogaW50IC0+IGludCkgPSAoSW50Lmdsb2JhbGl6ZSA6IGludCAtPiBpbnQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfaW50IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBJbnQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfaW50IDogaW50IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBJbnQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBpbnRfb2Zfc2V4cCA9IChJbnQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGludClcbiAgbGV0IHNleHBfb2ZfaW50ID0gKEludC5zZXhwX29mX3QgOiBpbnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGludF9zZXhwX2dyYW1tYXIgOiBpbnQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gSW50LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGludDMyID0gSW50MzIudFxuICBbQEBkZXJpdmluZ19pbmxpbmVcbiAgICBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9pbnQzMl9fbG9jYWwgPSAoSW50MzIuY29tcGFyZV9fbG9jYWwgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQpXG4gIGxldCBjb21wYXJlX2ludDMyID0gKGZ1biBhIGIgLT4gY29tcGFyZV9pbnQzMl9fbG9jYWwgYSBiIDogaW50MzIgLT4gaW50MzIgLT4gaW50KVxuICBsZXQgZXF1YWxfaW50MzJfX2xvY2FsID0gKEludDMyLmVxdWFsX19sb2NhbCA6IGludDMyIC0+IGludDMyIC0+IGJvb2wpXG4gIGxldCBlcXVhbF9pbnQzMiA9IChmdW4gYSBiIC0+IGVxdWFsX2ludDMyX19sb2NhbCBhIGIgOiBpbnQzMiAtPiBpbnQzMiAtPiBib29sKVxuICBsZXQgKGdsb2JhbGl6ZV9pbnQzMiA6IGludDMyIC0+IGludDMyKSA9IChJbnQzMi5nbG9iYWxpemUgOiBpbnQzMiAtPiBpbnQzMilcblxuICBsZXQgKGhhc2hfZm9sZF9pbnQzMiA6XG4gICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnQzMiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIEludDMyLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2ludDMyIDogaW50MzIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEludDMyLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgaW50MzJfb2Zfc2V4cCA9IChJbnQzMi50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gaW50MzIpXG4gIGxldCBzZXhwX29mX2ludDMyID0gKEludDMyLnNleHBfb2ZfdCA6IGludDMyIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChpbnQzMl9zZXhwX2dyYW1tYXIgOiBpbnQzMiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBJbnQzMi50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBpbnQ2NCA9IEludDY0LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lXG4gICAgY29tcGFyZSB+bG9jYWxpemUsIGVxdWFsIH5sb2NhbGl6ZSwgZ2xvYmFsaXplLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfaW50NjRfX2xvY2FsID0gKEludDY0LmNvbXBhcmVfX2xvY2FsIDogaW50NjQgLT4gaW50NjQgLT4gaW50KVxuICBsZXQgY29tcGFyZV9pbnQ2NCA9IChmdW4gYSBiIC0+IGNvbXBhcmVfaW50NjRfX2xvY2FsIGEgYiA6IGludDY0IC0+IGludDY0IC0+IGludClcbiAgbGV0IGVxdWFsX2ludDY0X19sb2NhbCA9IChJbnQ2NC5lcXVhbF9fbG9jYWwgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBib29sKVxuICBsZXQgZXF1YWxfaW50NjQgPSAoZnVuIGEgYiAtPiBlcXVhbF9pbnQ2NF9fbG9jYWwgYSBiIDogaW50NjQgLT4gaW50NjQgLT4gYm9vbClcbiAgbGV0IChnbG9iYWxpemVfaW50NjQgOiBpbnQ2NCAtPiBpbnQ2NCkgPSAoSW50NjQuZ2xvYmFsaXplIDogaW50NjQgLT4gaW50NjQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfaW50NjQgOlxuICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50NjQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBJbnQ2NC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9pbnQ2NCA6IGludDY0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBJbnQ2NC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGludDY0X29mX3NleHAgPSAoSW50NjQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGludDY0KVxuICBsZXQgc2V4cF9vZl9pbnQ2NCA9IChJbnQ2NC5zZXhwX29mX3QgOiBpbnQ2NCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoaW50NjRfc2V4cF9ncmFtbWFyIDogaW50NjQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gSW50NjQudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgJ2EgbGlzdCA9ICdhIExpc3QudFxuICBbQEBkZXJpdmluZ19pbmxpbmVcbiAgICBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9saXN0X19sb2NhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBsaXN0IC0+ICdhIGxpc3QgLT4gaW50ID1cbiAgICBMaXN0LmNvbXBhcmVfX2xvY2FsXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfbGlzdCA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBsaXN0IC0+ICdhIGxpc3QgLT4gaW50ID0gTGlzdC5jb21wYXJlXG5cbiAgbGV0IGVxdWFsX2xpc3RfX2xvY2FsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSBsaXN0IC0+ICdhIGxpc3QgLT4gYm9vbCA9XG4gICAgTGlzdC5lcXVhbF9fbG9jYWxcbiAgOztcblxuICBsZXQgZXF1YWxfbGlzdCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0IC0+IGJvb2wgPSBMaXN0LmVxdWFsXG5cbiAgbGV0IGdsb2JhbGl6ZV9saXN0IDogJ2EuICgnYSAtPiAnYSkgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0ID1cbiAgICBmdW4gKHR5cGUgYV9fMDc4XykgOiAoKGFfXzA3OF8gLT4gYV9fMDc4XykgLT4gYV9fMDc4XyBsaXN0IC0+IGFfXzA3OF8gbGlzdCkgLT5cbiAgICBMaXN0Lmdsb2JhbGl6ZVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfbGlzdCA6XG4gICAgICAgICdhLlxuICAgICAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgICAgIC0+ICdhIGxpc3RcbiAgICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIExpc3QuaGFzaF9mb2xkX3RcbiAgOztcblxuICBsZXQgbGlzdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSBsaXN0ID1cbiAgICBMaXN0LnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX2xpc3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgbGlzdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIExpc3Quc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IGxpc3Rfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgJ2EuICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIGxpc3QgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gTGlzdC50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIG5hdGl2ZWludCA9IE5hdGl2ZWludC50XG4gIFtAQGRlcml2aW5nX2lubGluZVxuICAgIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX25hdGl2ZWludF9fbG9jYWwgPVxuICAgIChOYXRpdmVpbnQuY29tcGFyZV9fbG9jYWwgOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IGludClcbiAgOztcblxuICBsZXQgY29tcGFyZV9uYXRpdmVpbnQgPVxuICAgIChmdW4gYSBiIC0+IGNvbXBhcmVfbmF0aXZlaW50X19sb2NhbCBhIGIgOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IGludClcbiAgOztcblxuICBsZXQgZXF1YWxfbmF0aXZlaW50X19sb2NhbCA9IChOYXRpdmVpbnQuZXF1YWxfX2xvY2FsIDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBib29sKVxuXG4gIGxldCBlcXVhbF9uYXRpdmVpbnQgPVxuICAgIChmdW4gYSBiIC0+IGVxdWFsX25hdGl2ZWludF9fbG9jYWwgYSBiIDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBib29sKVxuICA7O1xuXG4gIGxldCAoZ2xvYmFsaXplX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQpID1cbiAgICAoTmF0aXZlaW50Lmdsb2JhbGl6ZSA6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQpXG4gIDs7XG5cbiAgbGV0IChoYXNoX2ZvbGRfbmF0aXZlaW50IDpcbiAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IG5hdGl2ZWludCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIE5hdGl2ZWludC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IE5hdGl2ZWludC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IG5hdGl2ZWludF9vZl9zZXhwID0gKE5hdGl2ZWludC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gbmF0aXZlaW50KVxuICBsZXQgc2V4cF9vZl9uYXRpdmVpbnQgPSAoTmF0aXZlaW50LnNleHBfb2ZfdCA6IG5hdGl2ZWludCAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbiAgbGV0IChuYXRpdmVpbnRfc2V4cF9ncmFtbWFyIDogbmF0aXZlaW50IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgTmF0aXZlaW50LnRfc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICdhIG9wdGlvbiA9ICdhIE9wdGlvbi50XG4gIFtAQGRlcml2aW5nX2lubGluZVxuICAgIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX29wdGlvbl9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbiAtPiBpbnQgPVxuICAgIE9wdGlvbi5jb21wYXJlX19sb2NhbFxuICA7O1xuXG4gIGxldCBjb21wYXJlX29wdGlvbiA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb24gLT4gJ2Egb3B0aW9uIC0+IGludCA9XG4gICAgT3B0aW9uLmNvbXBhcmVcbiAgOztcblxuICBsZXQgZXF1YWxfb3B0aW9uX19sb2NhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbiAtPiBib29sID1cbiAgICBPcHRpb24uZXF1YWxfX2xvY2FsXG4gIDs7XG5cbiAgbGV0IGVxdWFsX29wdGlvbiA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbiAtPiBib29sID1cbiAgICBPcHRpb24uZXF1YWxcbiAgOztcblxuICBsZXQgZ2xvYmFsaXplX29wdGlvbiA6ICdhLiAoJ2EgLT4gJ2EpIC0+ICdhIG9wdGlvbiAtPiAnYSBvcHRpb24gPVxuICAgIGZ1biAodHlwZSBhX18xMDlfKSA6ICgoYV9fMTA5XyAtPiBhX18xMDlfKSAtPiBhX18xMDlfIG9wdGlvbiAtPiBhX18xMDlfIG9wdGlvbikgLT5cbiAgICBPcHRpb24uZ2xvYmFsaXplXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9vcHRpb24gOlxuICAgICAgICAnYS5cbiAgICAgICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgICAgICAtPiAnYSBvcHRpb25cbiAgICAgICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIE9wdGlvbi5oYXNoX2ZvbGRfdFxuICA7O1xuXG4gIGxldCBvcHRpb25fb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2Egb3B0aW9uID1cbiAgICBPcHRpb24udF9vZl9zZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2Zfb3B0aW9uIDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIG9wdGlvbiAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIE9wdGlvbi5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgb3B0aW9uX3NleHBfZ3JhbW1hciA6XG4gICAgICAgICdhLiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBvcHRpb24gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gT3B0aW9uLnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgJ2EgcmVmID0gJ2EgUmVmLnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUgfmxvY2FsaXplLCBlcXVhbCB+bG9jYWxpemUsIGdsb2JhbGl6ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX3JlZl9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgcmVmIC0+ICdhIHJlZiAtPiBpbnQgPVxuICAgIFJlZi5jb21wYXJlX19sb2NhbFxuICA7O1xuXG4gIGxldCBjb21wYXJlX3JlZiA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSByZWYgLT4gJ2EgcmVmIC0+IGludCA9IFJlZi5jb21wYXJlXG5cbiAgbGV0IGVxdWFsX3JlZl9fbG9jYWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHJlZiAtPiAnYSByZWYgLT4gYm9vbCA9XG4gICAgUmVmLmVxdWFsX19sb2NhbFxuICA7O1xuXG4gIGxldCBlcXVhbF9yZWYgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHJlZiAtPiAnYSByZWYgLT4gYm9vbCA9IFJlZi5lcXVhbFxuXG4gIGxldCBnbG9iYWxpemVfcmVmIDogJ2EuICgnYSAtPiAnYSkgLT4gJ2EgcmVmIC0+ICdhIHJlZiA9XG4gICAgZnVuICh0eXBlIGFfXzEzNF8pIDogKChhX18xMzRfIC0+IGFfXzEzNF8pIC0+IGFfXzEzNF8gcmVmIC0+IGFfXzEzNF8gcmVmKSAtPlxuICAgIFJlZi5nbG9iYWxpemVcbiAgOztcblxuICBsZXQgcmVmX29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHJlZiA9XG4gICAgUmVmLnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3JlZiA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSByZWYgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBSZWYuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IHJlZl9zZXhwX2dyYW1tYXIgOiAnYS4gJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgcmVmIFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBSZWYudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBzdHJpbmcgPSBTdHJpbmcudFxuICBbQEBkZXJpdmluZ19pbmxpbmVcbiAgICBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9zdHJpbmdfX2xvY2FsID0gKFN0cmluZy5jb21wYXJlX19sb2NhbCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gaW50KVxuICBsZXQgY29tcGFyZV9zdHJpbmcgPSAoZnVuIGEgYiAtPiBjb21wYXJlX3N0cmluZ19fbG9jYWwgYSBiIDogc3RyaW5nIC0+IHN0cmluZyAtPiBpbnQpXG4gIGxldCBlcXVhbF9zdHJpbmdfX2xvY2FsID0gKFN0cmluZy5lcXVhbF9fbG9jYWwgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2wpXG4gIGxldCBlcXVhbF9zdHJpbmcgPSAoZnVuIGEgYiAtPiBlcXVhbF9zdHJpbmdfX2xvY2FsIGEgYiA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbClcbiAgbGV0IChnbG9iYWxpemVfc3RyaW5nIDogc3RyaW5nIC0+IHN0cmluZykgPSAoU3RyaW5nLmdsb2JhbGl6ZSA6IHN0cmluZyAtPiBzdHJpbmcpXG5cbiAgbGV0IChoYXNoX2ZvbGRfc3RyaW5nIDpcbiAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHN0cmluZyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIFN0cmluZy5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9zdHJpbmcgOiBzdHJpbmcgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IFN0cmluZy5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHN0cmluZ19vZl9zZXhwID0gKFN0cmluZy50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gc3RyaW5nKVxuICBsZXQgc2V4cF9vZl9zdHJpbmcgPSAoU3RyaW5nLnNleHBfb2ZfdCA6IHN0cmluZyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoc3RyaW5nX3NleHBfZ3JhbW1hciA6IHN0cmluZyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBTdHJpbmcudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgYnl0ZXMgPSBCeXRlcy50XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9ieXRlc19fbG9jYWwgPSAoQnl0ZXMuY29tcGFyZV9fbG9jYWwgOiBieXRlcyAtPiBieXRlcyAtPiBpbnQpXG4gIGxldCBjb21wYXJlX2J5dGVzID0gKGZ1biBhIGIgLT4gY29tcGFyZV9ieXRlc19fbG9jYWwgYSBiIDogYnl0ZXMgLT4gYnl0ZXMgLT4gaW50KVxuICBsZXQgZXF1YWxfYnl0ZXNfX2xvY2FsID0gKEJ5dGVzLmVxdWFsX19sb2NhbCA6IGJ5dGVzIC0+IGJ5dGVzIC0+IGJvb2wpXG4gIGxldCBlcXVhbF9ieXRlcyA9IChmdW4gYSBiIC0+IGVxdWFsX2J5dGVzX19sb2NhbCBhIGIgOiBieXRlcyAtPiBieXRlcyAtPiBib29sKVxuICBsZXQgKGdsb2JhbGl6ZV9ieXRlcyA6IGJ5dGVzIC0+IGJ5dGVzKSA9IChCeXRlcy5nbG9iYWxpemUgOiBieXRlcyAtPiBieXRlcylcbiAgbGV0IGJ5dGVzX29mX3NleHAgPSAoQnl0ZXMudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGJ5dGVzKVxuICBsZXQgc2V4cF9vZl9ieXRlcyA9IChCeXRlcy5zZXhwX29mX3QgOiBieXRlcyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoYnl0ZXNfc2V4cF9ncmFtbWFyIDogYnl0ZXMgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gQnl0ZXMudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgdW5pdCA9IFVuaXQudFxuICBbQEBkZXJpdmluZ19pbmxpbmVcbiAgICBjb21wYXJlIH5sb2NhbGl6ZSwgZXF1YWwgfmxvY2FsaXplLCBnbG9iYWxpemUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV91bml0X19sb2NhbCA9IChVbml0LmNvbXBhcmVfX2xvY2FsIDogdW5pdCAtPiB1bml0IC0+IGludClcbiAgbGV0IGNvbXBhcmVfdW5pdCA9IChmdW4gYSBiIC0+IGNvbXBhcmVfdW5pdF9fbG9jYWwgYSBiIDogdW5pdCAtPiB1bml0IC0+IGludClcbiAgbGV0IGVxdWFsX3VuaXRfX2xvY2FsID0gKFVuaXQuZXF1YWxfX2xvY2FsIDogdW5pdCAtPiB1bml0IC0+IGJvb2wpXG4gIGxldCBlcXVhbF91bml0ID0gKGZ1biBhIGIgLT4gZXF1YWxfdW5pdF9fbG9jYWwgYSBiIDogdW5pdCAtPiB1bml0IC0+IGJvb2wpXG4gIGxldCAoZ2xvYmFsaXplX3VuaXQgOiB1bml0IC0+IHVuaXQpID0gKFVuaXQuZ2xvYmFsaXplIDogdW5pdCAtPiB1bml0KVxuXG4gIGxldCAoaGFzaF9mb2xkX3VuaXQgOlxuICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdW5pdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIFVuaXQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfdW5pdCA6IHVuaXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IFVuaXQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB1bml0X29mX3NleHAgPSAoVW5pdC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdW5pdClcbiAgbGV0IHNleHBfb2ZfdW5pdCA9IChVbml0LnNleHBfb2ZfdCA6IHVuaXQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHVuaXRfc2V4cF9ncmFtbWFyIDogdW5pdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBVbml0LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICAoKiogRm9ybWF0IHN0dWZmICopXG5cbiAgdHlwZSBub25yZWMgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjKSBmb3JtYXRcbiAgdHlwZSBub25yZWMgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0ID0gKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcblxuICAoKiogTGlzdCBvcGVyYXRvcnMgKilcblxuICBpbmNsdWRlIExpc3QuSW5maXhcblxuICAoKiogSW50IG9wZXJhdG9ycyBhbmQgY29tcGFyaXNvbnMgKilcblxuICBpbmNsdWRlIEludC5PXG4gIGluY2x1ZGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gICgqKiBGbG9hdCBvcGVyYXRvcnMgKilcblxuICBpbmNsdWRlIEZsb2F0Lk9fZG90XG5cbiAgKCogVGhpcyBpcyBkZWNsYXJlZCBhcyBhbiBleHRlcm5hbCB0byBiZSBvcHRpbWl6ZWQgYXdheSBpbiBtb3JlIGNvbnRleHRzLiAqKVxuXG4gICgqKiBSZXZlcnNlIGFwcGxpY2F0aW9uIG9wZXJhdG9yLiBbeCB8PiBnIHw+IGZdIGlzIGVxdWl2YWxlbnQgdG8gW2YgKGcgKHgpKV0uICopXG4gIGV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgoJ2EgLT4gJ2IpW0Bsb2NhbF9vcHRdKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcblxuICAoKiogQXBwbGljYXRpb24gb3BlcmF0b3IuIFtnIEBAIGYgQEAgeF0gaXMgZXF1aXZhbGVudCB0byBbZyAoZiAoeCkpXS4gKilcbiAgZXh0ZXJuYWwgKCBAQCApIDogKCgnYSAtPiAnYilbQGxvY2FsX29wdF0pIC0+ICdhIC0+ICdiID0gXCIlYXBwbHlcIlxuXG4gICgqKiBCb29sZWFuIG9wZXJhdGlvbnMgKilcblxuICAoKiBUaGVzZSBuZWVkIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHRvIGdldCB0aGUgbGF6eSBiZWhhdmlvciAqKVxuICBleHRlcm5hbCAoICYmICkgOiAoYm9vbFtAbG9jYWxfb3B0XSkgLT4gKGJvb2xbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbiAgZXh0ZXJuYWwgKCB8fCApIDogKGJvb2xbQGxvY2FsX29wdF0pIC0+IChib29sW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlc2VxdW9yXCJcbiAgZXh0ZXJuYWwgbm90IDogKGJvb2xbQGxvY2FsX29wdF0pIC0+IGJvb2wgPSBcIiVib29sbm90XCJcblxuICAoKiBUaGlzIG11c3QgYmUgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgZm9yIHRoZSB3YXJuaW5ncyB0byB3b3JrIHByb3Blcmx5LiAqKVxuICBleHRlcm5hbCBpZ25vcmUgOiAoX1tAbG9jYWxfb3B0XSkgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbiAgKCoqIENvbW1vbiBzdHJpbmcgb3BlcmF0aW9ucyAqKVxuICBsZXQgKCBeICkgPSBTdHJpbmcuKCBeIClcblxuICAoKiogUmVmZXJlbmNlIG9wZXJhdGlvbnMgKilcblxuICAoKiBEZWNsYXJlZCBhcyBhbiBleHRlcm5hbHMgc28gdGhhdCB0aGUgY29tcGlsZXIgc2tpcHMgdGhlIGNhbWxfbW9kaWZ5IHdoZW4gcG9zc2libGUgYW5kXG4gICAgIHRvIGtlZXAgcmVmZXJlbmNlIHVuYm94aW5nIHdvcmtpbmcgKilcbiAgZXh0ZXJuYWwgKCAhICkgOiAoJ2EgcmVmW0Bsb2NhbF9vcHRdKSAtPiAnYSA9IFwiJWZpZWxkMFwiXG4gIGV4dGVybmFsIHJlZiA6ICdhIC0+ICgnYSByZWZbQGxvY2FsX29wdF0pID0gXCIlbWFrZW11dGFibGVcIlxuICBleHRlcm5hbCAoIDo9ICkgOiAoJ2EgcmVmW0Bsb2NhbF9vcHRdKSAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcblxuICAoKiogUGFpciBvcGVyYXRpb25zICopXG5cbiAgbGV0IGZzdCA9IGZzdFxuICBsZXQgc25kID0gc25kXG5cbiAgKCoqIEV4Y2VwdGlvbnMgc3R1ZmYgKilcblxuICAoKiBEZWNsYXJlZCBhcyBhbiBleHRlcm5hbCBzbyB0aGF0IHRoZSBjb21waWxlciBtYXkgcmV3cml0ZSAnJXJhaXNlJyBhcyAnJXJlcmFpc2UnLiAqKVxuICBleHRlcm5hbCByYWlzZSA6IGV4biAtPiBfID0gXCIlcmFpc2VcIlxuXG4gIGxldCBmYWlsd2l0aCA9IGZhaWx3aXRoXG4gIGxldCBpbnZhbGlkX2FyZyA9IGludmFsaWRfYXJnXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gICgqKiBNaXNjICopXG5cbiAgZXh0ZXJuYWwgcGh5c19lcXVhbCA6ICgnYVtAbG9jYWxfb3B0XSkgLT4gKCdhW0Bsb2NhbF9vcHRdKSAtPiBib29sID0gXCIlZXFcIlxuICBleHRlcm5hbCBmb3JjZSA6ICgnYSBMYXp5LnRbQGxvY2FsX29wdF0pIC0+ICdhID0gXCIlbGF6eV9mb3JjZVwiXG5lbmRcblxuaW5jbHVkZSBFeHBvcnRcblxuaW5jbHVkZSBDb250YWluZXJfaW50Zi5FeHBvcnQgKCoqIEBpbmxpbmUgKilcblxuZXhjZXB0aW9uIE5vdF9mb3VuZF9zID0gTm90X2ZvdW5kX3NcblxuKCogV2UgcGVyZm9ybSB0aGVzZSBzaWRlIGVmZmVjdHMgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdGhlbSB0byBydW4gZm9yIGFueSBjb2RlIHRoYXQgdXNlc1xuICAgW0Jhc2VdLiAgSWYgdGhpcyB3ZXJlIGluIGFub3RoZXIgbW9kdWxlIGluIFtCYXNlXSB0aGF0IHdhcyBub3QgdXNlZCBpbiBzb21lIHByb2dyYW0sXG4gICB0aGVuIHRoZSBzaWRlIGVmZmVjdHMgbWlnaHQgbm90IGJlIHJ1biBpbiB0aGF0IHByb2dyYW0uICBUaGlzIHdpbGwgcnVuIGFzIGxvbmcgYXMgdGhlXG4gICBwcm9ncmFtIHJlZmVycyB0byBhdCBsZWFzdCBvbmUgdmFsdWUgZGlyZWN0bHkgaW4gW0Jhc2VdOyByZWZlcnJpbmcgdG8gdmFsdWVzIGluXG4gICBbQmFzZS5Cb29sXSwgZm9yIGV4YW1wbGUsIGlzIG5vdCBzdWZmaWNpZW50LiAqKVxubGV0ICgpID0gQmFja3RyYWNlLmluaXRpYWxpemVfbW9kdWxlICgpXG5cbm1vZHVsZSBDYW1sID0gc3RydWN0IGVuZCBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMjMtMDFdIHVzZSBTdGRsaWIgaW5zdGVhZCBvZiBDYW1sXCJdXG4iXX0=
