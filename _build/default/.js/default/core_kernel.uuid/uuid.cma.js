// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Uuid
//# unitInfo: Requires: Base__Bytes, Base__Random, Base__Sexpable, Bin_prot__Shape, Bin_shape, Core, Core__Bytes, Core__Char, Core__Command_internal, Core__Comparable, Core__Comparator, Core__Identifiable, Core__Int, Core__Md5, Core__Quickcheck, Core__Stable, Core__String, Core__Time_ns, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stable_witness
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Uuid$0 = "Uuid",
    cst_t$3 = "t",
    cst_uuid$0 = "uuid",
    cst_uuid_src_uuid_ml = "uuid/src/uuid.ml",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    for_testing = "5a863fc1-67b7-3a0a-dc90-aca2995afbf9",
    module_name = cst_Uuid$0,
    nil = "00000000-0000-0000-0000-000000000000",
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Time_ns = global_data.Core__Time_ns,
    Core_Int = global_data.Core__Int,
    Core_String = global_data.Core__String,
    Core_Md5 = global_data.Core__Md5,
    Core_Bytes = global_data.Core__Bytes,
    Base_Bytes = global_data.Base__Bytes,
    Base_Random = global_data.Base__Random,
    Core_Char = global_data.Core__Char,
    Assert_failure = global_data.Assert_failure,
    Core_Stable = global_data.Core__Stable,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Bin_shape = global_data.Bin_shape,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Stable_witness = global_data.Stable_witness,
    Core_Comparator = global_data.Core__Comparator,
    Core_Comparable = global_data.Core__Comparable,
    Base_Sexpable = global_data.Base__Sexpable,
    Core_Identifiable = global_data.Core__Identifiable,
    Core_Command_internal = global_data.Core__Command_internal,
    Core_Quickcheck = global_data.Core__Quickcheck;
   caml_call1(Ppx_module_timer_runtime[4], cst_Uuid$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_uuid$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_uuid_src_uuid_ml);
   caml_call2(Ppx_inline_test_lib[6], cst_uuid$0, "uuid.ml");
   var
    _a_ = Core_Stable[99],
    _b_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$3), 0, _a_], 0],
    _c_ = caml_call1(Bin_shape[4][1], "uuid/src/uuid.ml:21:6"),
    group = caml_call2(Bin_prot_Shape[2], _c_, _b_),
    _d_ = caml_call1(Bin_shape[2][1], cst_t$3),
    bin_shape_t = caml_call1(caml_call2(Bin_prot_Shape[10], group, _d_), 0),
    bin_size_t = Core_Stable[3],
    bin_write_t = Core_Stable[101],
    bin_writer_t = [0, bin_size_t, bin_write_t],
    bin_read_t = Core_Stable[105],
    bin_read_t$0 = Core_Stable[104],
    bin_reader_t = [0, bin_read_t$0, bin_read_t],
    bin_t = [0, bin_shape_t, bin_writer_t, bin_reader_t],
    compare = Core_Stable[442],
    equal = Core_Stable[456],
    hash_fold_t = Core_Stable[287],
    func = Core_Stable[301],
    _v_ =
      [0,
       [2,
        0,
        [12,
         45,
         [2, 0, [12, 45, [2, 0, [12, 45, [2, 0, [12, 45, [2, 0, 0]]]]]]]]],
       "%s-%s-%s-%s-%s"],
    cst_uuid_omitted_in_test = "<uuid-omitted-in-test>",
    _p_ = [0, "-"],
    _k_ = [0, [2, 0, [11, ": not a valid UUID", 0]], "%s: not a valid UUID"],
    _j_ = [0, cst_uuid_src_uuid_ml, 47, 6],
    _i_ = [0, cst_uuid_src_uuid_ml, 48, 6],
    _h_ = [0, cst_uuid_src_uuid_ml, 49, 6],
    _g_ = [0, cst_uuid_src_uuid_ml, 50, 6],
    _f_ = [0, cst_uuid_src_uuid_ml, 51, 6],
    _e_ = [0, cst_uuid_src_uuid_ml, 52, 6],
    cst_t = cst_t$3,
    cst_uuid_src_uuid_ml_68_2 = "uuid/src/uuid.ml:68:2",
    cst_t$0 = cst_t$3,
    cst_t$1 = cst_t$3,
    cst_uuid_src_uuid_ml_162_2 = "uuid/src/uuid.ml:162:2",
    cst_t$2 = cst_t$3,
    cst_uuid = cst_uuid$0,
    cst_Uuid = cst_Uuid$0;
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Core_Stable[355],
    sexp_of_t = Core_Stable[354],
    t_sexp_grammar = Core_Stable[356],
    stable_witness = Stable_witness[6],
    include = caml_call2(Core_Comparator[13][1][1], compare, sexp_of_t),
    comparator = include[1],
    include$0 =
      caml_call1
       (Core_Comparable[26][1][2][1],
        [0,
         stable_witness,
         bin_size_t,
         bin_write_t,
         bin_read_t$0,
         bin_read_t,
         bin_shape_t,
         bin_writer_t,
         bin_reader_t,
         bin_t,
         compare,
         t_of_sexp,
         sexp_of_t,
         comparator]),
    Map = include$0[1],
    Set = include$0[2];
   function to_string(t){return t;}
   function char_is_dash(c){return caml_call2(Core_Char[54], 45, c);}
   function is_valid_exn(s){
    if(! caml_call2(Core[90], runtime.caml_ml_string_length(s), 36))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    var _L_ = caml_call2(Core_String[21], s, char_is_dash);
    if(! caml_call2(Core[90], _L_, 4))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
    if(! char_is_dash(caml_string_get(s, 8)))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    if(! char_is_dash(caml_string_get(s, 13)))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    if(! char_is_dash(caml_string_get(s, 18)))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    if(char_is_dash(caml_string_get(s, 23))) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function of_string(s){
    try{is_valid_exn(s); return s;}
    catch(_K_){return caml_call3(Core[246], _k_, s, 0);}
   }
   var
    _l_ = Core[541],
    _m_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t), 0, _l_], 0],
    _n_ = caml_call1(Bin_shape[4][1], cst_uuid_src_uuid_ml_68_2),
    group$0 = caml_call2(Bin_prot_Shape[2], _n_, _m_),
    _o_ = caml_call1(Bin_shape[2][1], cst_t$0),
    bin_shape_t$0 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$0, _o_), 0),
    bin_size_t$0 = Core[542],
    bin_write_t$0 = Core[544],
    bin_writer_t$0 = [0, bin_size_t$0, bin_write_t$0],
    bin_read_t$1 = Core[548],
    bin_read_t$2 = Core[547],
    bin_reader_t$0 = [0, bin_read_t$2, bin_read_t$1],
    bin_t$0 = [0, bin_shape_t$0, bin_writer_t$0, bin_reader_t$0],
    compare$0 = Core[551],
    hash_fold_t$0 = Core[556],
    func$0 = Core[557];
   function hash$0(x){return caml_call1(func$0, x);}
   var counter = [0, 0];
   function set_all_dashes(bytes){
    caml_bytes_set(bytes, 8, 45);
    caml_bytes_set(bytes, 13, 45);
    caml_bytes_set(bytes, 18, 45);
    caml_bytes_set(bytes, 23, 45);
    return;
   }
   function bottom_4_bits_to_hex_char(v){
    var v$0 = v & 15;
    return caml_call2(Core[92], v$0, 10)
            ? caml_call1(Core_Char[14], 48 + v$0 | 0)
            : caml_call1(Core_Char[14], 87 + v$0 | 0);
   }
   var bytes = caml_call1(Core_Bytes[44], 36);
   function create_random(random_state){
    var at = [0, 0], for$0 = 1;
    for(;;){
     var int$0 = [0, caml_call1(Base_Random[19][5], random_state)], for$1 = 1;
     for(;;){
      var _I_ = bottom_4_bits_to_hex_char(int$0[1]);
      caml_bytes_set(bytes, at[1], _I_);
      at[1]++;
      int$0[1] = int$0[1] >>> 4 | 0;
      var _J_ = for$1 + 1 | 0;
      if(6 === for$1) break;
      var for$1 = _J_;
     }
     var _H_ = for$0 + 1 | 0;
     if(6 === for$0){
      set_all_dashes(bytes);
      caml_bytes_set(bytes, 14, 52);
      return caml_call1(Core_Bytes[41], bytes);
     }
     var for$0 = _H_;
    }
   }
   function create(hostname, pid){
    var time = caml_call1(Core_Time_ns[66], 0);
    counter[1]++;
    var
     counter$0 = counter[1],
     _C_ = [0, caml_call1(Core_Int[79], counter$0), 0],
     _D_ = caml_call1(Core_Time_ns[79], time),
     _E_ = [0, caml_call1(Core_Int[79], _D_), _C_],
     _F_ = [0, hostname, [0, caml_call1(Core_Int[79], pid), _E_]],
     base = caml_call2(Core_String[46], _p_, _F_),
     _G_ = caml_call1(Core_Md5[47], base),
     digest = caml_call1(Core_Md5[45], _G_),
     s = caml_call1(Core_Bytes[44], 36);
    set_all_dashes(s);
    caml_call5(Base_Bytes[33][1], digest, 0, s, 0, 8);
    caml_call5(Base_Bytes[33][1], digest, 8, s, 9, 4);
    caml_call5(Base_Bytes[33][1], digest, 12, s, 14, 4);
    caml_call5(Base_Bytes[33][1], digest, 16, s, 19, 4);
    caml_call5(Base_Bytes[33][1], digest, 20, s, 24, 12);
    caml_bytes_set(s, 14, 51);
    return caml_call1(Core_Bytes[41], s);
   }
   var
    include$1 = caml_call1(Base_Sexpable[5], [0, of_string, to_string]),
    t_of_sexp$0 = include$1[2],
    sexp_of_t$0 = include$1[3],
    include$2 =
      caml_call1
       (Core_Identifiable[5],
        [0,
         bin_size_t$0,
         bin_write_t$0,
         bin_read_t$2,
         bin_read_t$1,
         bin_shape_t$0,
         bin_writer_t$0,
         bin_reader_t$0,
         bin_t$0,
         compare$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$0,
         comparator,
         of_string,
         to_string,
         module_name]),
    bin_size_t$1 = include$2[1],
    bin_write_t$1 = include$2[2],
    bin_read_t$3 = include$2[3],
    bin_read_t$4 = include$2[4],
    bin_shape_t$1 = include$2[5],
    bin_writer_t$1 = include$2[6],
    bin_reader_t$1 = include$2[7],
    bin_t$1 = include$2[8],
    t_of_sexp$1 = include$2[9],
    sexp_of_t$1 = include$2[10],
    of_string$0 = include$2[11],
    to_string$0 = include$2[12],
    pp = include$2[13],
    symbol = include$2[14],
    symbol$0 = include$2[15],
    symbol$1 = include$2[16],
    symbol$2 = include$2[17],
    symbol$3 = include$2[18],
    symbol$4 = include$2[19],
    equal$0 = include$2[20],
    compare$1 = include$2[21],
    min = include$2[22],
    max = include$2[23],
    ascending = include$2[24],
    descending = include$2[25],
    between = include$2[26],
    clamp_exn = include$2[27],
    clamp = include$2[28],
    validate_lbound = include$2[29],
    validate_ubound = include$2[30],
    validate_bound = include$2[31],
    Replace_polymorphic_compare = include$2[32],
    comparator$0 = include$2[33],
    Map$0 = include$2[34],
    Set$0 = include$2[35],
    hash_fold_t$1 = include$2[36],
    hash$1 = include$2[37],
    hashable = include$2[38],
    Table = include$2[39],
    Hash_set = include$2[40],
    Hash_queue = include$2[41];
   function invariant(t){caml_call1(of_string$0, t); return 0;}
   var
    _q_ = [0, [0, caml_call1(Bin_shape[2][1], cst_t$1), 0, bin_shape_t$1], 0],
    _r_ = caml_call1(Bin_shape[4][1], cst_uuid_src_uuid_ml_162_2),
    group$1 = caml_call2(Bin_prot_Shape[2], _r_, _q_),
    _s_ = caml_call1(Bin_shape[2][1], cst_t$2),
    bin_shape_t$2 =
      caml_call1(caml_call2(Bin_prot_Shape[10], group$1, _s_), 0),
    bin_writer_t$2 = [0, bin_size_t$1, bin_write_t$1],
    bin_reader_t$2 = [0, bin_read_t$3, bin_read_t$4],
    bin_t$2 = [0, bin_shape_t$2, bin_writer_t$2, bin_reader_t$2];
   function hash$2(x){return caml_call1(hash$1, x);}
   var
    t_sexp_grammar$0 = Core[560],
    arg_type = caml_call3(Core_Command_internal[19][1], 0, 0, of_string$0);
   function sexp_of_t$2(t){
    return Core[628]
            ? caml_call1(Sexplib0_Sexp_conv[7], cst_uuid_omitted_in_test)
            : caml_call1(sexp_of_t$1, t);
   }
   var
    quickcheck_shrinker = caml_call1(Core_Quickcheck[3][3], 0),
    quickcheck_observer =
      caml_call1(Core_Quickcheck[2][3], [0, hash_fold_t$0, hash$0]),
    _t_ = [0, [0, 6., caml_call2(Core_Char[86], 97, 102)], 0],
    gen_hex_digit =
      caml_call1(Core_Quickcheck[1][64], [0, [0, 10., Core_Char[79]], _t_]),
    let_syntax_013 = caml_call2(Core_String[174], 8, gen_hex_digit),
    let_syntax_014 = caml_call2(Core_String[174], 4, gen_hex_digit),
    let_syntax_015 = caml_call2(Core_String[174], 4, gen_hex_digit),
    let_syntax_016 = caml_call2(Core_String[174], 4, gen_hex_digit),
    let_syntax_017 = caml_call2(Core_String[174], 12, gen_hex_digit);
   function _u_(param){
    var
     _A_ = param[2],
     _B_ = _A_[2],
     match = _B_[2],
     fifth = match[2],
     fourth = match[1],
     third = _B_[1],
     second = _A_[1],
     first = param[1];
    return caml_call1
            (of_string$0,
             caml_call6(Core[265], _v_, first, second, third, fourth, fifth));
   }
   var
    _w_ =
      caml_call2(Core_Quickcheck[1][8][4][4], let_syntax_016, let_syntax_017),
    _x_ = caml_call2(Core_Quickcheck[1][8][4][4], let_syntax_015, _w_),
    _y_ = caml_call2(Core_Quickcheck[1][8][4][4], let_syntax_014, _x_),
    _z_ = caml_call2(Core_Quickcheck[1][8][4][4], let_syntax_013, _y_),
    quickcheck_generator = caml_call2(Core_Quickcheck[1][8][4][3], _z_, _u_);
   caml_call1(Ppx_inline_test_lib[7], cst_uuid);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Uuid);
   var
    Uuid =
      [0,
       bin_size_t$1,
       bin_write_t$1,
       bin_read_t$3,
       bin_read_t$4,
       bin_shape_t$1,
       bin_writer_t$1,
       bin_reader_t$1,
       bin_t$1,
       sexp_of_t$2,
       of_string$0,
       to_string$0,
       pp,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal$0,
       compare$1,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       validate_lbound,
       validate_ubound,
       validate_bound,
       Replace_polymorphic_compare,
       comparator$0,
       Map$0,
       Set$0,
       hash_fold_t$1,
       hash$1,
       hashable,
       Table,
       Hash_set,
       Hash_queue,
       invariant,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       t_of_sexp$1,
       create_random,
       arg_type,
       [0,
        bin_size_t$1,
        bin_write_t$1,
        bin_read_t$3,
        bin_read_t$4,
        bin_shape_t$2,
        bin_writer_t$2,
        bin_reader_t$2,
        bin_t$2,
        compare$1,
        equal$0,
        hash_fold_t$1,
        hash$2,
        t_of_sexp$1,
        sexp_of_t$1,
        t_sexp_grammar$0,
        comparator$0],
       [0,
        [0,
         equal,
         hash_fold_t,
         hash,
         t_sexp_grammar,
         stable_witness,
         bin_size_t,
         bin_write_t,
         bin_read_t$0,
         bin_read_t,
         bin_shape_t,
         bin_writer_t,
         bin_reader_t,
         bin_t,
         compare,
         t_of_sexp,
         sexp_of_t,
         comparator,
         Map,
         Set,
         of_string,
         to_string,
         for_testing]],
       [0, is_valid_exn, nil, create, bottom_4_bits_to_hex_char]];
   runtime.caml_register_global(56, Uuid, cst_Uuid$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ1dWlkLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJmb3JfdGVzdGluZyIsIm1vZHVsZV9uYW1lIiwibmlsIiwiZ3JvdXAiLCJiaW5fc2hhcGVfdCIsImJpbl9zaXplX3QiLCJiaW5fd3JpdGVfdCIsImJpbl93cml0ZXJfdCIsImJpbl9yZWFkX3QiLCJiaW5fcmVhZF90JDAiLCJiaW5fcmVhZGVyX3QiLCJiaW5fdCIsImNvbXBhcmUiLCJlcXVhbCIsImhhc2hfZm9sZF90IiwiZnVuYyIsImhhc2giLCJ4IiwidF9vZl9zZXhwIiwic2V4cF9vZl90IiwidF9zZXhwX2dyYW1tYXIiLCJzdGFibGVfd2l0bmVzcyIsImNvbXBhcmF0b3IiLCJ0b19zdHJpbmciLCJ0IiwiY2hhcl9pc19kYXNoIiwiYyIsImlzX3ZhbGlkX2V4biIsInMiLCJvZl9zdHJpbmciLCJncm91cCQwIiwiYmluX3NoYXBlX3QkMCIsImJpbl9zaXplX3QkMCIsImJpbl93cml0ZV90JDAiLCJiaW5fd3JpdGVyX3QkMCIsImJpbl9yZWFkX3QkMSIsImJpbl9yZWFkX3QkMiIsImJpbl9yZWFkZXJfdCQwIiwiYmluX3QkMCIsImNvbXBhcmUkMCIsImhhc2hfZm9sZF90JDAiLCJmdW5jJDAiLCJoYXNoJDAiLCJjb3VudGVyIiwic2V0X2FsbF9kYXNoZXMiLCJieXRlcyIsImJvdHRvbV80X2JpdHNfdG9faGV4X2NoYXIiLCJ2IiwidiQwIiwiY3JlYXRlX3JhbmRvbSIsInJhbmRvbV9zdGF0ZSIsImF0IiwiaW50JDAiLCJjcmVhdGUiLCJob3N0bmFtZSIsInBpZCIsInRpbWUiLCJjb3VudGVyJDAiLCJiYXNlIiwiZGlnZXN0IiwiYmluX3NpemVfdCQxIiwiYmluX3dyaXRlX3QkMSIsImJpbl9yZWFkX3QkMyIsImJpbl9yZWFkX3QkNCIsInRfb2Zfc2V4cCQxIiwic2V4cF9vZl90JDEiLCJlcXVhbCQwIiwiY29tcGFyZSQxIiwiaGFzaF9mb2xkX3QkMSIsImludmFyaWFudCIsImdyb3VwJDEiLCJiaW5fc2hhcGVfdCQyIiwiYmluX3dyaXRlcl90JDIiLCJiaW5fcmVhZGVyX3QkMiIsImJpbl90JDIiLCJoYXNoJDIiLCJ0X3NleHBfZ3JhbW1hciQwIiwiYXJnX3R5cGUiLCJzZXhwX29mX3QkMiIsInF1aWNrY2hlY2tfc2hyaW5rZXIiLCJxdWlja2NoZWNrX29ic2VydmVyIiwiZ2VuX2hleF9kaWdpdCIsImxldF9zeW50YXhfMDEzIiwibGV0X3N5bnRheF8wMTQiLCJsZXRfc3ludGF4XzAxNSIsImxldF9zeW50YXhfMDE2IiwibGV0X3N5bnRheF8wMTciLCJmaWZ0aCIsImZvdXJ0aCIsInRoaXJkIiwic2Vjb25kIiwiZmlyc3QiLCJxdWlja2NoZWNrX2dlbmVyYXRvciJdLCJzb3VyY2VzIjpbIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9jb3JlX2tlcm5lbC91dWlkL3V1aWQubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lBNkJRQTtJQTBIRkM7SUFPRkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ExSUU7O0lBQUEsY0FBSztJQUFMLE1BQUE7SUFBQUMsUUFBQTtJQUFBLE1BQUE7SUFBS0MsY0FBTCxXQUFBLCtCQUFBRDtJQUFBRTtJQUFBQztJQUFBQyxtQkFBQUYsWUFBQUM7SUFBQUU7SUFBQUM7SUFBQUMsbUJBQUFELGNBQUFEO0lBQUFHLFlBQUtQLGFBQUxHLGNBQUFHO0lBQUFFO0lBQUFDO0lBQUFDO0lBQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQUFBLFNBQUFDLEtBQUFDLEdBQUEsT0FBQSxXQUFBRixNQUFBRSxHQUM2RTtHQUVoRTtJQUhiQztJQUFBQztJQUFLQztJQUFBQztJQUdRLFVBQUEsc0NBSGJULFNBQUFPO0lBa0RBRzs7Ozs7U0FsREtEO1NBQUxoQjtTQUFBQztTQUFBRztTQUFBRDtTQUFLSjtTQUFMRztTQUFBRztTQUFBQztTQUFBQztTQUFBTTtTQUFBQztT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eUhpQztJQUY3QnVDO01BQ0Y7SUFHY0MsaUJBQUEsZ0NBSlpEO0lBS1NFLGlCQUFBLGdDQUxURjtJQU1RRyxpQkFBQSxnQ0FOUkg7SUFPU0ksaUJBQUEsZ0NBUFRKO0lBUVFLLGlCQUFBLGlDQVJSTDs7Ozs7O0tBUUFNO0tBREFDO0tBREFDO0tBREFDO0tBRElDO0lBS0UsT0FBQTs7YUFBQSwyQkFMRkEsT0FDSkQsUUFDQUQsT0FDQUQsUUFDQUQ7Ozs7OENBRFNGLGdCQUNEQztrREFGQUY7a0RBRENEO2tEQURHRDtJQU5kVTs7Ozs7Ozs7T0F2QkZoQztPQUFBQztPQUFBQztPQUFBQzs7Ozs7T0FTRWU7Ozs7Ozs7Ozs7T0FURlo7T0FBQUM7Ozs7Ozs7Ozs7Ozs7OztPQUFBQzs7Ozs7O09BSkVDO09BMkJBdUI7T0FGQVo7T0FEQUQ7T0FwQkZmO09BaEVJZjtPQXVFRjRCOztRQVBGakI7UUFBQUM7UUFBQUM7UUFBQUM7UUFBWVE7UUFBWkM7UUFBQUM7UUFBQUM7UUFBQVA7UUFBQUQ7UUFBQUU7UUFBQU87UUFBQVg7UUFBQUM7UUFJSVc7Ozs7U0FqSkEvRDtTQUFBQztTQUFBRTtTQUFLSTtTQUFBQztTQUFMaEI7U0FBQUM7U0FBQUc7U0FBQUQ7U0FBS0o7U0FBTEc7U0FBQUc7U0FBQUM7U0FBQUM7U0FBQU07U0FBQUM7U0FrREFHOzs7U0FvQkFPO1NBREFOO1NBNURFdkI7V0FtSkYyQixjQWxCRnpCLEtBckNFbUQsUUE3QkFQOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIEEgbG9vc2UgaW1wbGVtZW50YXRpb24gb2YgdmVyc2lvbiAzIGFuZCB2ZXJzaW9uIDQgb2YgdGhlIFVVSUQgc3BlYyAoUkZDIDQxMjIpOlxuXG4gICBWZXJzaW9uIDMgVVVJRHMgdXNlIGEgc2NoZW1lIGRlcml2aW5nIGEgVVVJRCB2aWEgTUQ1IGZyb20gYSBVUkwsIGEgZnVsbHlcbiAgIHF1YWxpZmllZCBkb21haW4gbmFtZSwgYW4gb2JqZWN0IGlkZW50aWZpZXIsIGEgZGlzdGluZ3Vpc2hlZCBuYW1lIChETiBhcyB1c2VkXG4gICBpbiBMaWdodHdlaWdodCBEaXJlY3RvcnkgQWNjZXNzIFByb3RvY29sKSwgb3Igb24gbmFtZXMgaW4gdW5zcGVjaWZpZWRcbiAgIG5hbWVzcGFjZXMuIFRoZSBnZW5lcmF0ZWQgVVVJRHMgaGF2ZSB0aGUgZm9ybSB4eHh4eHh4eC14eHh4LTN4eHgteHh4eC14eHh4eHh4eHh4eHhcbiAgIHdpdGggaGV4YWRlY2ltYWwgZGlnaXRzIHguXG5cbiAgIFZlcnNpb24gNCBVVUlEcyB1c2UgcmFuZG9tIGJpdHMsIHRoZSBnZW5lcmF0ZWQgVVVJRHMgaGF2ZSB0aGUgZm9ybVxuICAgeHh4eHh4eHgteHh4eC00eHh4LXh4eHgteHh4eHh4eHh4eHh4LlxuXG4gICBJbiBib3RoIGNhc2VzLCBSRkMgNDEyMiBjb21wbGlhbmNlIHdvdWxkIHJlcXVpcmUgc2V0dGluZyB0aGUgXCJ2YXJpYW50XCIgYml0cywgd2hpY2ggdGhlXG4gICBjdXJyZW50IGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGRvLlxuKilcblxubW9kdWxlIFN0YWJsZSA9IHN0cnVjdFxuICBvcGVuIENvcmUuQ29yZV9zdGFibGVcblxuICBtb2R1bGUgVjEgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gc3RyaW5nXG4gICAgICBbQEBkZXJpdmluZyBiaW5faW8sIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXIsIHN0YWJsZV93aXRuZXNzXVxuXG4gICAgICBpbmNsdWRlICh2YWwgQ29tcGFyYXRvci5WMS5tYWtlIH5jb21wYXJlIH5zZXhwX29mX3QpXG4gICAgZW5kXG5cbiAgICBpbmNsdWRlIFRcbiAgICBpbmNsdWRlIENvbXBhcmFibGUuVjEuV2l0aF9zdGFibGVfd2l0bmVzcy5NYWtlIChUKVxuXG4gICAgbGV0IGZvcl90ZXN0aW5nID0gXCI1YTg2M2ZjMS02N2I3LTNhMGEtZGM5MC1hY2EyOTk1YWZiZjlcIlxuICAgIGxldCB0b19zdHJpbmcgdCA9IHRcblxuICAgICgqe3ZcbiAgICAgICB4eHh4eHh4eC14eHh4LTN4eHgteHh4eC14eHh4eHh4eHh4eHhcbiAgICAgICB4eHh4eHh4eC14eHh4LTR4eHgteHh4eC14eHh4eHh4eHh4eHhcbiAgICAgICAwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDVcbiAgICAgICAwICAgICAgICAgMSAgICAgICAgIDIgICAgICAgICAzXG4gICAgdn0qKVxuXG4gICAgbGV0IGNoYXJfaXNfZGFzaCBjID0gQ29yZS5DaGFyLmVxdWFsICctJyBjXG5cbiAgICBsZXQgaXNfdmFsaWRfZXhuIHMgPVxuICAgICAgbGV0IG9wZW4gQ29yZSBpblxuICAgICAgKCogd2UgZG9uJ3QgY2hlY2sgZm9yIGEgMyBpbiB0aGUgdmVyc2lvbiBwb3NpdGlvbiAoMTQpIGJlY2F1c2Ugd2Ugd2FudCB0byBiZVxuICAgICAgICAgZ2VuZXJvdXMgYWJvdXQgYWNjZXB0aW5nIFVVSURzIGdlbmVyYXRlZCBieSBvdGhlciB2ZXJzaW9ucyBvZiB0aGUgcHJvdG9jb2wsIGFuZFxuICAgICAgICAgd2Ugd2FudCB0byBiZSByZXNpbGllbnQgdG8gZnV0dXJlIGNoYW5nZXMgaW4gdGhpcyBhbGdvcml0aG0uICopXG4gICAgICBhc3NlcnQgKFN0cmluZy5sZW5ndGggcyA9IDM2KTtcbiAgICAgIGFzc2VydCAoU3RyaW5nLmNvdW50IHMgfmY6Y2hhcl9pc19kYXNoID0gNCk7XG4gICAgICBhc3NlcnQgKGNoYXJfaXNfZGFzaCBzLls4XSk7XG4gICAgICBhc3NlcnQgKGNoYXJfaXNfZGFzaCBzLlsxM10pO1xuICAgICAgYXNzZXJ0IChjaGFyX2lzX2Rhc2ggcy5bMThdKTtcbiAgICAgIGFzc2VydCAoY2hhcl9pc19kYXNoIHMuWzIzXSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX3N0cmluZyBzID1cbiAgICAgIHRyeVxuICAgICAgICBpc192YWxpZF9leG4gcztcbiAgICAgICAgc1xuICAgICAgd2l0aFxuICAgICAgfCBfIC0+IENvcmUuZmFpbHdpdGhmIFwiJXM6IG5vdCBhIHZhbGlkIFVVSURcIiBzICgpXG4gICAgOztcbiAgZW5kXG5lbmRcblxub3BlbiEgQ29yZVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBzdHJpbmcgW0BAZGVyaXZpbmcgYmluX2lvLCBjb21wYXJlLCBoYXNoXVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IFN0YWJsZS5WMS5jb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciA9IFN0YWJsZS5WMS5jb21wYXJhdG9yXG5cbiAgbGV0IG5leHRfY291bnRlciA9XG4gICAgbGV0IGNvdW50ZXIgPSByZWYgMCBpblxuICAgIGZ1biAoKSAtPlxuICAgICAgKCogSW4gT0NhbWwgdGhpcyBkb2Vzbid0IGFsbG9jYXRlLCBhbmQgdGhyZWFkcyBjYW4ndCBjb250ZXh0IHN3aXRjaCBleGNlcHQgb25cbiAgICAgICAgIGFsbG9jYXRpb24gKilcbiAgICAgIGluY3IgY291bnRlcjtcbiAgICAgICFjb3VudGVyXG4gIDs7XG5cbiAgbGV0IHNldF9hbGxfZGFzaGVzIGJ5dGVzID1cbiAgICBCeXRlcy5zZXQgYnl0ZXMgOCAnLSc7XG4gICAgQnl0ZXMuc2V0IGJ5dGVzIDEzICctJztcbiAgICBCeXRlcy5zZXQgYnl0ZXMgMTggJy0nO1xuICAgIEJ5dGVzLnNldCBieXRlcyAyMyAnLSdcbiAgOztcblxuICBsZXQgc2V0X3ZlcnNpb24gYnl0ZXMgfnZlcnNpb24gPSBCeXRlcy5zZXQgYnl0ZXMgMTQgdmVyc2lvblxuICBsZXQgdG9fc3RyaW5nID0gU3RhYmxlLlYxLnRvX3N0cmluZ1xuICBsZXQgb2Zfc3RyaW5nID0gU3RhYmxlLlYxLm9mX3N0cmluZ1xuXG4gIGxldCBib3R0b21fNF9iaXRzX3RvX2hleF9jaGFyIHYgPVxuICAgIGxldCB2ID0gdiBsYW5kIDB4MEYgaW5cbiAgICBpZiB2IDwgMTAgdGhlbiBDaGFyLnVuc2FmZV9vZl9pbnQgKDQ4ICsgdikgZWxzZSBDaGFyLnVuc2FmZV9vZl9pbnQgKDg3ICsgdilcbiAgOztcblxuICBsZXQgY3JlYXRlX3JhbmRvbSA9XG4gICAgbGV0IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIDM2IGluXG4gICAgZnVuIHJhbmRvbV9zdGF0ZSAtPlxuICAgICAgKCogV2UgZmlsbCBhbGwgMzYgYnl0ZXMgd2l0aCByYW5kb20gaGV4IGRpZ2l0cywgYW5kIHRoZW4gZ28gYmFjayBhbmQgc2V0IHNwZWNpZmljXG4gICAgICAgICBieXRlcyB0byBkYXNoIGFuZCB0aGUgdmVyc2lvbiBudW1iZXIgKDQpLiAgV2UgZG8gNiBncm91cHMgb2YgNiBieXRlcywgZWFjaCB0aW1lXG4gICAgICAgICB1c2luZyAyNCBiaXRzIG9mIGEgcmFuZG9tIGludCwgNCBmb3IgZWFjaCBoZXggZGlnaXQuICopXG4gICAgICBsZXQgYXQgPSByZWYgMCBpblxuICAgICAgZm9yIF8gPSAxIHRvIDYgZG9cbiAgICAgICAgbGV0IGludCA9IHJlZiAoUmFuZG9tLlN0YXRlLmJpdHMgcmFuZG9tX3N0YXRlKSBpblxuICAgICAgICBmb3IgXyA9IDEgdG8gNiBkb1xuICAgICAgICAgIEJ5dGVzLnNldCBieXRlcyAhYXQgKGJvdHRvbV80X2JpdHNfdG9faGV4X2NoYXIgIWludCk7XG4gICAgICAgICAgaW5jciBhdDtcbiAgICAgICAgICBpbnQgOj0gIWludCBsc3IgNFxuICAgICAgICBkb25lXG4gICAgICBkb25lO1xuICAgICAgc2V0X2FsbF9kYXNoZXMgYnl0ZXM7XG4gICAgICBzZXRfdmVyc2lvbiBieXRlcyB+dmVyc2lvbjonNCc7XG4gICAgICBCeXRlcy50b19zdHJpbmcgYnl0ZXNcbiAgOztcblxuICAoKiBbY3JlYXRlXSBpcyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB1bmlxdWUgc3RyaW5nIGlkZW50aWZpZXJzLiAgSXQgc2hvdWxkIGJlIGNsZWFyXG4gICAgIHRvIGEgcmVhZGVyIHRoYXQgdGhlIGlkIGdlbmVyYXRlZCBoYXMgYW4gZXh0cmVtZWx5IGhpZ2ggcHJvYmFiaWxpdHkgb2YgdW5pcXVlbmVzc1xuICAgICBhY3Jvc3MgYWxsIHBvc3NpYmxlIG1hY2hpbmVzLCBwcm9jZXNzZXMsIGFuZCB0aHJlYWRzIG9mIGV4ZWN1dGlvbi4gKilcblxuICBsZXQgY3JlYXRlIH5ob3N0bmFtZSB+cGlkID1cbiAgICBsZXQgZGlnZXN0ID1cbiAgICAgIGxldCB0aW1lID0gVGltZV9ucy5ub3cgKCkgaW5cbiAgICAgIGxldCBjb3VudGVyID0gbmV4dF9jb3VudGVyICgpIGluXG4gICAgICBsZXQgYmFzZSA9XG4gICAgICAgIFN0cmluZy5jb25jYXRcbiAgICAgICAgICB+c2VwOlwiLVwiXG4gICAgICAgICAgWyBob3N0bmFtZVxuICAgICAgICAgIDsgSW50LnRvX3N0cmluZyBwaWRcbiAgICAgICAgICA7IEludC50b19zdHJpbmcgKFRpbWVfbnMudG9faW50X25zX3NpbmNlX2Vwb2NoIHRpbWUpXG4gICAgICAgICAgOyBJbnQudG9fc3RyaW5nIGNvdW50ZXJcbiAgICAgICAgICBdXG4gICAgICBpblxuICAgICAgTWQ1LnRvX2hleCAoTWQ1LmRpZ2VzdF9zdHJpbmcgYmFzZSlcbiAgICBpblxuICAgIGxldCBzID0gQnl0ZXMuY3JlYXRlIDM2IGluXG4gICAgc2V0X2FsbF9kYXNoZXMgcztcbiAgICBCeXRlcy5Gcm9tX3N0cmluZy5ibGl0IH5zcmM6ZGlnZXN0IH5kc3Q6cyB+c3JjX3BvczowIH5kc3RfcG9zOjAgfmxlbjo4O1xuICAgIEJ5dGVzLkZyb21fc3RyaW5nLmJsaXQgfnNyYzpkaWdlc3QgfmRzdDpzIH5zcmNfcG9zOjggfmRzdF9wb3M6OSB+bGVuOjQ7XG4gICAgQnl0ZXMuRnJvbV9zdHJpbmcuYmxpdCB+c3JjOmRpZ2VzdCB+ZHN0OnMgfnNyY19wb3M6MTIgfmRzdF9wb3M6MTQgfmxlbjo0O1xuICAgIEJ5dGVzLkZyb21fc3RyaW5nLmJsaXQgfnNyYzpkaWdlc3QgfmRzdDpzIH5zcmNfcG9zOjE2IH5kc3RfcG9zOjE5IH5sZW46NDtcbiAgICBCeXRlcy5Gcm9tX3N0cmluZy5ibGl0IH5zcmM6ZGlnZXN0IH5kc3Q6cyB+c3JjX3BvczoyMCB+ZHN0X3BvczoyNCB+bGVuOjEyO1xuICAgIHNldF92ZXJzaW9uIHMgfnZlcnNpb246JzMnO1xuICAgIEJ5dGVzLnRvX3N0cmluZyBzXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBUXG5cbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2VfdXNpbmdfY29tcGFyYXRvciAoc3RydWN0XG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiVXVpZFwiXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgU2V4cGFibGUuT2Zfc3RyaW5nYWJsZSAoVClcbmVuZClcblxubGV0IGludmFyaWFudCB0ID0gaWdub3JlIChvZl9zdHJpbmcgdCA6IHQpXG5sZXQgbmlsID0gXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIlxuXG5tb2R1bGUgVW5zdGFibGUgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHQgW0BAZGVyaXZpbmcgYmluX2lvLCBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cF1cbiAgdHlwZSBub25yZWMgY29tcGFyYXRvcl93aXRuZXNzID0gY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yXG4gIGxldCB0X3NleHBfZ3JhbW1hciA9IHN0cmluZ19zZXhwX2dyYW1tYXJcbmVuZFxuXG5sZXQgYXJnX3R5cGUgPSBDb21tYW5kLkFyZ190eXBlLmNyZWF0ZSBvZl9zdHJpbmdcblxubGV0IHNleHBfb2ZfdCB0ID1cbiAgaWYgYW1fcnVubmluZ190ZXN0IHRoZW4gWyVzZXhwIFwiPHV1aWQtb21pdHRlZC1pbi10ZXN0PlwiXSBlbHNlIFslc2V4cCAodCA6IHQpXVxuOztcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGNyZWF0ZSA9IGNyZWF0ZVxuICBsZXQgaXNfdmFsaWRfZXhuID0gU3RhYmxlLlYxLmlzX3ZhbGlkX2V4blxuICBsZXQgYm90dG9tXzRfYml0c190b19oZXhfY2hhciA9IGJvdHRvbV80X2JpdHNfdG9faGV4X2NoYXJcbiAgbGV0IG5pbCA9IG5pbFxuZW5kXG5cbmxldCBxdWlja2NoZWNrX3Nocmlua2VyIDogdCBRdWlja2NoZWNrLlNocmlua2VyLnQgPSBRdWlja2NoZWNrLlNocmlua2VyLmVtcHR5ICgpXG5sZXQgcXVpY2tjaGVja19vYnNlcnZlciA6IHQgUXVpY2tjaGVjay5PYnNlcnZlci50ID0gUXVpY2tjaGVjay5PYnNlcnZlci5vZl9oYXNoIChtb2R1bGUgVClcblxubGV0IHF1aWNrY2hlY2tfZ2VuZXJhdG9yIDogdCBRdWlja2NoZWNrLkdlbmVyYXRvci50ID1cbiAgbGV0IG9wZW4gUXVpY2tjaGVjay5HZW5lcmF0b3IuTGV0X3N5bnRheCBpblxuICBsZXQgZ2VuX2hleF9kaWdpdCA6IENoYXIudCBRdWlja2NoZWNrLkdlbmVyYXRvci50ID1cbiAgICBRdWlja2NoZWNrLkdlbmVyYXRvci53ZWlnaHRlZF91bmlvblxuICAgICAgWyAxMC4wLCBDaGFyLmdlbl9kaWdpdDsgNi4wLCBDaGFyLmdlbl91bmlmb3JtX2luY2x1c2l2ZSAnYScgJ2YnIF1cbiAgaW5cbiAgbGV0JW1hcCBmaXJzdCA9IFN0cmluZy5nZW5fd2l0aF9sZW5ndGggOCBnZW5faGV4X2RpZ2l0XG4gIGFuZCBzZWNvbmQgPSBTdHJpbmcuZ2VuX3dpdGhfbGVuZ3RoIDQgZ2VuX2hleF9kaWdpdFxuICBhbmQgdGhpcmQgPSBTdHJpbmcuZ2VuX3dpdGhfbGVuZ3RoIDQgZ2VuX2hleF9kaWdpdFxuICBhbmQgZm91cnRoID0gU3RyaW5nLmdlbl93aXRoX2xlbmd0aCA0IGdlbl9oZXhfZGlnaXRcbiAgYW5kIGZpZnRoID0gU3RyaW5nLmdlbl93aXRoX2xlbmd0aCAxMiBnZW5faGV4X2RpZ2l0IGluXG4gIG9mX3N0cmluZyAoc3ByaW50ZiBcIiVzLSVzLSVzLSVzLSVzXCIgZmlyc3Qgc2Vjb25kIHRoaXJkIGZvdXJ0aCBmaWZ0aClcbjs7XG4iXX0=
