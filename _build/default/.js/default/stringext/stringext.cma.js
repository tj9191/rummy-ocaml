// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Stringext
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$4,
    cst$2 = cst$4,
    cst$1 = cst$4,
    cst$0 = cst$4,
    cst = cst$4,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    cst_Stringext_rcut_empty_separ = "Stringext.rcut: empty separator",
    cst_Stringext_cut_empty_separa = "Stringext.cut: empty separator",
    cst_Stringext_Found_int = "Stringext.Found_int",
    cst_Stringext_Found_replace = "Stringext.Found_replace";
   function string_after(s, n){
    return caml_call3
            (Stdlib_String[16], s, n, caml_ml_string_length(s) - n | 0);
   }
   function quote(s){
    var
     len = caml_ml_string_length(s),
     buf = caml_call1(Stdlib_Buffer[1], 2 * len | 0),
     ___ = len - 1 | 0,
     _Z_ = 0;
    if(___ >= 0){
     var i = _Z_;
     for(;;){
      var c = caml_string_get(s, i), _$_ = c - 63 | 0;
      a:
      {
       b:
       {
        if(31 < _$_ >>> 0){
         var _aa_ = _$_ + 27 | 0;
         if(10 < _aa_ >>> 0) break b;
         switch(_aa_){case 0:case 6:case 7:case 10: break;default: break b;
         }
        }
        else if(26 >= _$_ - 1 >>> 0) break b;
        caml_call2(Stdlib_Buffer[12], buf, 92);
        caml_call2(Stdlib_Buffer[12], buf, c);
        break a;
       }
       caml_call2(Stdlib_Buffer[12], buf, c);
      }
      var _ab_ = i + 1 | 0;
      if(___ === i) break;
      var i = _ab_;
     }
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   var of_char = caml_call1(Stdlib_String[1], 1);
   function full_split(str, on){
    if(caml_string_equal(str, cst$4)) return 0;
    var sep = caml_call1(of_char, on);
    function loop(acc, offset){
     try{
      var index = caml_call3(Stdlib_String[34], str, offset, on);
      if(index === offset)
       var _X_ = loop([0, sep, acc], index - 1 | 0);
      else
       var
        token =
          caml_call3
           (Stdlib_String[16], str, index + 1 | 0, offset - index | 0),
        _X_ = loop([0, sep, [0, token, acc]], index - 1 | 0);
      return _X_;
     }
     catch(_Y_){
      var _W_ = caml_wrap_exception(_Y_);
      if(_W_ === Stdlib[8])
       return 0 <= offset
               ? [0,
                 caml_call3(Stdlib_String[16], str, 0, offset + 1 | 0),
                 acc]
               : acc;
      throw caml_maybe_attach_backtrace(_W_, 0);
     }
    }
    return loop(0, caml_ml_string_length(str) - 1 | 0);
   }
   function split(max, str, on){
    if(max){
     var max$0 = max[1];
     if(caml_string_equal(str, cst$4)) return 0;
     if(1 === max$0) return [0, str, 0];
     var
      loop =
        function(offset, tokens){
         if(tokens === (max$0 - 1 | 0))
          return [0,
                  caml_call3
                   (Stdlib_String[16],
                    str,
                    offset,
                    caml_ml_string_length(str) - offset | 0),
                  0];
         try{
          var index = caml_call3(Stdlib_String[32], str, offset, on);
          if(index === offset)
           var _U_ = [0, cst, loop(offset + 1 | 0, tokens + 1 | 0)];
          else
           var
            token =
              caml_call3(Stdlib_String[16], str, offset, index - offset | 0),
            _U_ = [0, token, loop(index + 1 | 0, tokens + 1 | 0)];
          return _U_;
         }
         catch(_V_){
          var _T_ = caml_wrap_exception(_V_);
          if(_T_ === Stdlib[8])
           return [0,
                   caml_call3
                    (Stdlib_String[16],
                     str,
                     offset,
                     caml_ml_string_length(str) - offset | 0),
                   0];
          throw caml_maybe_attach_backtrace(_T_, 0);
         }
        };
     return loop(0, 0);
    }
    if(caml_string_equal(str, cst$4)) return 0;
    function loop$0(acc, offset){
     try{
      var index = caml_call3(Stdlib_String[34], str, offset, on);
      if(index === offset)
       var _R_ = loop$0([0, cst$0, acc], index - 1 | 0);
      else
       var
        token =
          caml_call3
           (Stdlib_String[16], str, index + 1 | 0, offset - index | 0),
        _R_ = loop$0([0, token, acc], index - 1 | 0);
      return _R_;
     }
     catch(_S_){
      var _Q_ = caml_wrap_exception(_S_);
      if(_Q_ === Stdlib[8])
       return [0, caml_call3(Stdlib_String[16], str, 0, offset + 1 | 0), acc];
      throw caml_maybe_attach_backtrace(_Q_, 0);
     }
    }
    return loop$0(0, caml_ml_string_length(str) - 1 | 0);
   }
   function trim_left_sub(s, last_char, len, chars){
    var final$0 = last_char + len | 0, last_char$0 = last_char, i = last_char;
    for(;;){
     if(i !== final$0){
      var _P_ = caml_string_get(s, i);
      if(caml_call2(Stdlib_String[15], chars, _P_)){
       var
        i$0 = i + 1 | 0,
        last_char$1 = i + 1 | 0,
        last_char$0 = last_char$1,
        i = i$0;
       continue;
      }
     }
     var new_len = len - (last_char$0 - last_char | 0) | 0;
     return caml_call3(Stdlib_String[16], s, last_char$0, new_len);
    }
   }
   function split_trim_left(str, on, trim){
    if(caml_string_equal(str, cst$4)) return 0;
    function loop(acc, offset){
     try{
      var index = offset;
      for(;;){
       if(0 > index) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
       var _L_ = caml_string_get(str, index);
       if(caml_call2(Stdlib_String[15], on, _L_)){
        if(index === offset)
         var _N_ = loop([0, cst$1, acc], index - 1 | 0);
        else
         var
          token = trim_left_sub(str, index + 1 | 0, offset - index | 0, trim),
          _N_ = loop([0, token, acc], index - 1 | 0);
        return _N_;
       }
       var i = index - 1 | 0, index = i;
      }
     }
     catch(_O_){
      var _M_ = caml_wrap_exception(_O_);
      if(_M_ === Stdlib[8])
       return [0, trim_left_sub(str, 0, offset + 1 | 0, trim), acc];
      throw caml_maybe_attach_backtrace(_M_, 0);
     }
    }
    return loop(0, caml_ml_string_length(str) - 1 | 0);
   }
   var Found_int = [248, cst_Stringext_Found_int, caml_fresh_oo_id(0)];
   function trim_left(s){
    var
     _G_ = 0 < caml_ml_string_length(s) ? 1 : 0,
     _H_ = _G_ ? caml_string_get(s, 0) !== 32 ? 1 : 0 : _G_;
    if(_H_) return s;
    var len = caml_ml_string_length(s);
    try{
     var _J_ = len - 1 | 0, _I_ = 0;
     if(_J_ >= 0){
      var i = _I_;
      for(;;){
       if(32 !== caml_string_get(s, i))
        throw caml_maybe_attach_backtrace([0, Found_int, i], 1);
       var _K_ = i + 1 | 0;
       if(_J_ === i) break;
       var i = _K_;
      }
     }
     return cst$2;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Found_int) throw caml_maybe_attach_backtrace(exn, 0);
     var non_space = exn[2];
     return caml_call3(Stdlib_String[16], s, non_space, len - non_space | 0);
    }
   }
   function find_from(opt, str, pattern){
    if(opt) var sth = opt[1], start = sth; else var start = 0;
    try{
     var
      _B_ = caml_ml_string_length(str) - caml_ml_string_length(pattern) | 0;
     if(_B_ >= start){
      var start$0 = start;
      for(;;){
       try{
        var _x_ = caml_ml_string_length(pattern) - 1 | 0, _w_ = 0;
        if(_x_ >= 0){
         var i = _w_;
         for(;;){
          var _z_ = caml_string_get(pattern, i);
          if(caml_string_get(str, i + start$0 | 0) !== _z_)
           throw caml_maybe_attach_backtrace(Stdlib[3], 1);
          var _A_ = i + 1 | 0;
          if(_x_ === i) break;
          var i = _A_;
         }
        }
        var _y_ = 1, _D_ = _y_;
       }
       catch(_F_){var _D_ = 0;}
       if(_D_) throw caml_maybe_attach_backtrace([0, Found_int, start$0], 1);
       var _E_ = start$0 + 1 | 0;
       if(_B_ === start$0) break;
       var start$0 = _E_;
      }
     }
     var _C_ = 0;
     return _C_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Found_int) return 0;
     var i$0 = exn[2];
     return [0, i$0];
    }
   }
   function replace_all(str, pattern, with$0){
    var
     plen = caml_ml_string_length(pattern),
     slen = caml_ml_string_length(str),
     buf = caml_call1(Stdlib_Buffer[1], slen),
     i = 0;
    for(;;){
     var match = find_from([0, i], str, pattern);
     if(! match){
      caml_call4(Stdlib_Buffer[18], buf, str, i, slen - i | 0);
      return caml_call1(Stdlib_Buffer[2], buf);
     }
     var j = match[1];
     caml_call4(Stdlib_Buffer[18], buf, str, i, j - i | 0);
     caml_call2(Stdlib_Buffer[16], buf, with$0);
     var i$0 = j + plen | 0, i = i$0;
    }
   }
   var
    Found_replace = [248, cst_Stringext_Found_replace, caml_fresh_oo_id(0)];
   function replace_all_assoc(str, tbl){
    var
     slen = caml_ml_string_length(str),
     buf = caml_call1(Stdlib_Buffer[1], slen),
     i = 0;
    for(;;){
     if(slen <= i) return caml_call1(Stdlib_Buffer[2], buf);
     try{
      var
       found = [0, 0],
       f$0 =
         function(i, found){
          function f(param){
           var
            with$0 = param[2],
            pattern = param[1],
            match = find_from([0, i], str, pattern);
           if(! match) return Stdlib[19];
           var j = match[1];
           if(j === i)
            throw caml_maybe_attach_backtrace
                   ([0, Found_replace, j, pattern, with$0], 1);
           found[1] = 1;
           return j;
          }
          return f;
         },
       f = f$0(i, found);
      if(tbl){
       var
        xs$0 = tbl[2],
        x$1 = tbl[1],
        fx$1 = f(x$1),
        x = x$1,
        fx = fx$1,
        param = xs$0;
       for(;;){
        if(! param) break;
        var xs = param[2], x$0 = param[1], fx$0 = f(x$0);
        if(runtime.caml_lessthan(fx$0, fx))
         var x = x$0, fx = fx$0, param = xs;
        else
         var param = xs;
       }
       var e = [0, [0, x, fx]];
      }
      else
       var e = 0;
      if(e)
       var
        _t_ = e[1],
        j$1 = _t_[2],
        match$0 = _t_[1],
        with$2 = match$0[2],
        pattern$1 = match$0[1],
        _u_ = found[1] ? [0, [0, j$1, pattern$1, with$2]] : 0,
        _v_ = _u_;
      else
       var _v_ = 0;
      var r = _v_;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn[1] !== Found_replace) throw caml_maybe_attach_backtrace(exn, 0);
      var
       with$0 = exn[4],
       pattern = exn[3],
       j = exn[2],
       r = [0, [0, j, pattern, with$0]];
     }
     if(! r){
      caml_call4(Stdlib_Buffer[18], buf, str, i, slen - i | 0);
      return caml_call1(Stdlib_Buffer[2], buf);
     }
     var
      match = r[1],
      with$1 = match[3],
      pattern$0 = match[2],
      j$0 = match[1];
     caml_call4(Stdlib_Buffer[18], buf, str, i, j$0 - i | 0);
     caml_call2(Stdlib_Buffer[16], buf, with$1);
     var i$0 = j$0 + caml_ml_string_length(pattern$0) | 0, i = i$0;
    }
   }
   function of_list(xs$0){
    var
     l = caml_call1(Stdlib_List[1], xs$0),
     s = caml_create_bytes(l),
     i = 0,
     param = xs$0;
    for(;;){
     if(! param) return caml_call1(Stdlib_Bytes[44], s);
     var xs = param[2], x = param[1];
     caml_bytes_set(s, i, x);
     var i$0 = i + 1 | 0, i = i$0, param = xs;
    }
   }
   function to_list(s){
    var i$1 = caml_ml_string_length(s) - 1 | 0, acc = 0, i = i$1;
    for(;;){
     if(-1 === i) return acc;
     var
      i$0 = i - 1 | 0,
      acc$0 = [0, caml_string_get(s, i), acc],
      acc = acc$0,
      i = i$0;
    }
   }
   function of_array(a){
    var
     len = a.length - 1,
     bytes = caml_create_bytes(len),
     _r_ = len - 1 | 0,
     _q_ = 0;
    if(_r_ >= 0){
     var i = _q_;
     for(;;){
      caml_bytes_set(bytes, i, runtime.caml_check_bound(a, i)[1 + i]);
      var _s_ = i + 1 | 0;
      if(_r_ === i) break;
      var i = _s_;
     }
    }
    return caml_call1(Stdlib_Bytes[44], bytes);
   }
   function to_array(s){
    function _o_(_p_){return caml_string_get(s, _p_);}
    return caml_call2(Stdlib_Array[1], caml_ml_string_length(s), _o_);
   }
   function cut(s, on){
    var sep_max = caml_ml_string_length(on) - 1 | 0;
    if(0 > sep_max)
     return caml_call1(Stdlib[1], cst_Stringext_cut_empty_separa);
    var s_max = caml_ml_string_length(s) - 1 | 0;
    if(0 > s_max) return 0;
    var k = [0, 0], i = [0, 0];
    try{
     for(;;){
      if((i[1] + sep_max | 0) > s_max){var _m_ = 0; return _m_;}
      if(caml_string_unsafe_get(s, i[1]) !== caml_string_unsafe_get(on, 0))
       i[1]++;
      else{
       k[1] = 1;
       for(;;){
        if(k[1] > sep_max) break;
        if
         (caml_string_unsafe_get(s, i[1] + k[1] | 0)
          !== caml_string_unsafe_get(on, k[1]))
         break;
        k[1]++;
       }
       if(k[1] > sep_max) throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       i[1]++;
      }
     }
    }
    catch(_n_){
     var _k_ = caml_wrap_exception(_n_);
     if(_k_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_k_, 0);
     var
      left_end = i[1] - 1 | 0,
      right_start = (i[1] + sep_max | 0) + 1 | 0,
      _l_ =
        caml_call3
         (Stdlib_String[16],
          s,
          right_start,
          (s_max - right_start | 0) + 1 | 0);
     return [0,
             [0, caml_call3(Stdlib_String[16], s, 0, left_end + 1 | 0), _l_]];
    }
   }
   function rcut(s, on){
    var sep_max = caml_ml_string_length(on) - 1 | 0;
    if(0 > sep_max)
     return caml_call1(Stdlib[1], cst_Stringext_rcut_empty_separ);
    var s_max = caml_ml_string_length(s) - 1 | 0;
    if(0 > s_max) return 0;
    var k = [0, 0], i = [0, s_max];
    try{
     for(;;){
      if(sep_max > i[1]){var _i_ = 0; return _i_;}
      if
       (caml_string_unsafe_get(s, i[1])
        !== caml_string_unsafe_get(on, sep_max))
       i[1] += -1;
      else{
       var sep_start = i[1] - sep_max | 0;
       k[1] = sep_max - 1 | 0;
       for(;;){
        if(0 > k[1]) break;
        if
         (caml_string_unsafe_get(s, sep_start + k[1] | 0)
          !== caml_string_unsafe_get(on, k[1]))
         break;
        k[1] += -1;
       }
       if(0 > k[1]) throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       i[1] += -1;
      }
     }
    }
    catch(_j_){
     var _g_ = caml_wrap_exception(_j_);
     if(_g_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_g_, 0);
     var
      left_end = (i[1] - sep_max | 0) - 1 | 0,
      right_start = i[1] + 1 | 0,
      _h_ =
        caml_call3
         (Stdlib_String[16],
          s,
          right_start,
          (s_max - right_start | 0) + 1 | 0);
     return [0,
             [0, caml_call3(Stdlib_String[16], s, 0, left_end + 1 | 0), _h_]];
    }
   }
   function chop_prefix(s, prefix){
    var
     prefix_l = caml_ml_string_length(prefix),
     string_l = caml_ml_string_length(s);
    if(string_l < prefix_l) return 0;
    try{
     var _b_ = prefix_l - 1 | 0, _a_ = 0;
     if(_b_ >= 0){
      var i = _a_;
      for(;;){
       var _d_ = caml_string_get(prefix, i);
       if(caml_string_get(s, i) !== _d_)
        throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       var _e_ = i + 1 | 0;
       if(_b_ === i) break;
       var i = _e_;
      }
     }
     var
      _c_ =
        [0,
         caml_call3(Stdlib_String[16], s, prefix_l, string_l - prefix_l | 0)];
     return _c_;
    }
    catch(_f_){return 0;}
   }
   function drop(s, n){
    var l = caml_ml_string_length(s);
    return l <= n ? cst$3 : caml_call3(Stdlib_String[16], s, n, l - n | 0);
   }
   function take(s, n){
    return caml_ml_string_length(s) <= n
            ? s
            : caml_call3(Stdlib_String[16], s, 0, n);
   }
   var
    Stringext =
      [0,
       string_after,
       quote,
       split,
       full_split,
       trim_left,
       split_trim_left,
       of_char,
       of_list,
       to_list,
       to_array,
       of_array,
       find_from,
       replace_all,
       replace_all_assoc,
       cut,
       rcut,
       chop_prefix,
       drop,
       take,
       trim_left_sub];
   runtime.caml_register_global(19, Stringext, "Stringext");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzdHJpbmdleHQuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInN0cmluZ19hZnRlciIsInMiLCJuIiwicXVvdGUiLCJsZW4iLCJidWYiLCJpIiwiYyIsIm9mX2NoYXIiLCJmdWxsX3NwbGl0Iiwic3RyIiwib24iLCJzZXAiLCJsb29wIiwiYWNjIiwib2Zmc2V0IiwiaW5kZXgiLCJ0b2tlbiIsInNwbGl0IiwibWF4IiwibWF4JDAiLCJ0b2tlbnMiLCJsb29wJDAiLCJ0cmltX2xlZnRfc3ViIiwibGFzdF9jaGFyIiwiY2hhcnMiLCJmaW5hbCQwIiwibGFzdF9jaGFyJDAiLCJpJDAiLCJsYXN0X2NoYXIkMSIsIm5ld19sZW4iLCJzcGxpdF90cmltX2xlZnQiLCJ0cmltIiwidHJpbV9sZWZ0Iiwibm9uX3NwYWNlIiwiZmluZF9mcm9tIiwib3B0IiwicGF0dGVybiIsInN0aCIsInN0YXJ0Iiwic3RhcnQkMCIsInJlcGxhY2VfYWxsIiwid2l0aCQwIiwicGxlbiIsInNsZW4iLCJqIiwicmVwbGFjZV9hbGxfYXNzb2MiLCJ0YmwiLCJmb3VuZCIsImYkMCIsImYiLCJ4cyQwIiwieCQxIiwieCIsImZ4IiwieHMiLCJ4JDAiLCJmeCQwIiwiZSIsImokMSIsIndpdGgkMiIsInBhdHRlcm4kMSIsInIiLCJ3aXRoJDEiLCJwYXR0ZXJuJDAiLCJqJDAiLCJvZl9saXN0IiwibCIsInRvX2xpc3QiLCJpJDEiLCJhY2MkMCIsIm9mX2FycmF5IiwiYSIsImJ5dGVzIiwidG9fYXJyYXkiLCJjdXQiLCJzZXBfbWF4Iiwic19tYXgiLCJrIiwibGVmdF9lbmQiLCJyaWdodF9zdGFydCIsInJjdXQiLCJzZXBfc3RhcnQiLCJjaG9wX3ByZWZpeCIsInByZWZpeCIsInByZWZpeF9sIiwic3RyaW5nX2wiLCJkcm9wIiwidGFrZSJdLCJzb3VyY2VzIjpbIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9zdHJpbmdleHQvc3RyaW5nZXh0Lm1sIl0sIm1hcHBpbmdzIjoi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RixHQUFFQztJQUNULDZCQURPRCxNQUFFQztjQUFGRDtjQUdGLDhCQUhFQSxNQUFFQztHQUdZOzs7O09BOVVuQkY7T0FFQUc7T0F3RUFlO09BckJBVDtPQW9FQXdCO09BdEJBRjtPQWhEQXZCO09BdUtBMEQ7T0FNQUU7T0FlQU07T0FSQUg7T0ExRkFwQztPQXVCQU07T0FnQkFLO09BOERBNkI7T0FtQ0FNO09Bb0NBRTtPQVlBSTtPQU1BQztPQXBQQWpFOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4gU3RyaW5nXG5cbmxldCBzdHJpbmdfYWZ0ZXIgcyBuID0gU3RyaW5nLnN1YiBzIG4gKFN0cmluZy5sZW5ndGggcyAtIG4pXG5cbmxldCBxdW90ZSBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAoMiAqIGxlbikgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICAnWycgfCAnXScgfCAnKicgfCAnLicgfCAnXFxcXCcgfCAnPycgfCAnKycgfCAnXicgfCAnJCcgYXMgYyAtPlxuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFxcXCc7XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmIGNcbiAgICB8IGMgLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjXG4gIGRvbmU7XG4gIEJ1ZmZlci5jb250ZW50cyBidWZcblxuXG4oKiBOb3QgdGFpbCByZWN1cnNpdmUgZm9yIFwicGVyZm9ybWFuY2VcIiwgcGxlYXNlIGNob29zZSBsb3cgdmFsdWVzIGZvclxuICAgW21heF0uIFRoZSBpZGVhIGlzIHRoYXQgbWF4IGlzIGFsd2F5cyBzbWFsbCBiZWNhdXNlIGl0J3MgaGFyZFxuICAgY29kZSAqKVxubGV0IHNwbGl0X2NoYXJfYm91bmRlZCBzdHIgfm9uIH5tYXggPVxuICBpZiBzdHIgPSBcIlwiIHRoZW4gW11cbiAgZWxzZSBpZiBtYXggPSAxIHRoZW4gW3N0cl1cbiAgZWxzZVxuICAgIGxldCByZWMgbG9vcCBvZmZzZXQgdG9rZW5zID1cbiAgICAgIGlmIHRva2VucyA9IG1heCAtIDFcbiAgICAgIHRoZW4gW3N1YiBzdHIgb2Zmc2V0IChsZW5ndGggc3RyIC0gb2Zmc2V0KV1cbiAgICAgIGVsc2VcbiAgICAgICAgdHJ5XG4gICAgICAgICAgbGV0IGluZGV4ID0gaW5kZXhfZnJvbSBzdHIgb2Zmc2V0IG9uIGluXG4gICAgICAgICAgaWYgaW5kZXggPSBvZmZzZXQgdGhlblxuICAgICAgICAgICAgXCJcIjo6KGxvb3AgKG9mZnNldCArIDEpICh0b2tlbnMgKyAxKSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgdG9rZW4gPSBTdHJpbmcuc3ViIHN0ciBvZmZzZXQgKGluZGV4IC0gb2Zmc2V0KSBpblxuICAgICAgICAgICAgdG9rZW46Oihsb29wIChpbmRleCArIDEpICh0b2tlbnMgKyAxKSlcbiAgICAgICAgd2l0aCBOb3RfZm91bmQgLT4gW3N1YiBzdHIgb2Zmc2V0IChsZW5ndGggc3RyIC0gb2Zmc2V0KV1cbiAgICBpbiBsb29wIDAgMFxuXG5sZXQgc3BsaXRfY2hhcl91bmJvdW5kZWQgc3RyIH5vbiA9XG4gIGlmIHN0ciA9IFwiXCIgdGhlbiBbXVxuICBlbHNlXG4gICAgbGV0IHJlYyBsb29wIGFjYyBvZmZzZXQgPVxuICAgICAgdHJ5IGJlZ2luXG4gICAgICAgIGxldCBpbmRleCA9IHJpbmRleF9mcm9tIHN0ciBvZmZzZXQgb24gaW5cbiAgICAgICAgaWYgaW5kZXggPSBvZmZzZXQgdGhlblxuICAgICAgICAgIGxvb3AgKFwiXCI6OmFjYykgKGluZGV4IC0gMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCB0b2tlbiA9IHN1YiBzdHIgKGluZGV4ICsgMSkgKG9mZnNldCAtIGluZGV4KSBpblxuICAgICAgICAgIGxvb3AgKHRva2VuOjphY2MpIChpbmRleCAtIDEpXG4gICAgICBlbmRcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+IChzdWIgc3RyIDAgKG9mZnNldCArIDEpKTo6YWNjXG4gICAgaW4gbG9vcCBbXSAobGVuZ3RoIHN0ciAtIDEpXG5cbmxldCBvZl9jaGFyID0gU3RyaW5nLm1ha2UgMVxuXG5sZXQgZnVsbF9zcGxpdCBzdHIgfm9uID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgc2VwID0gb2ZfY2hhciBvbiBpblxuICAgIGxldCByZWMgbG9vcCBhY2Mgb2Zmc2V0ID1cbiAgICAgIHRyeSBiZWdpblxuICAgICAgICBsZXQgaW5kZXggPSByaW5kZXhfZnJvbSBzdHIgb2Zmc2V0IG9uIGluXG4gICAgICAgIGlmIGluZGV4ID0gb2Zmc2V0IHRoZW5cbiAgICAgICAgICBsb29wIChzZXA6OmFjYykgKGluZGV4IC0gMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCB0b2tlbiA9IHN1YiBzdHIgKGluZGV4ICsgMSkgKG9mZnNldCAtIGluZGV4KSBpblxuICAgICAgICAgIGxvb3AgKHNlcDo6dG9rZW46OmFjYykgKGluZGV4IC0gMSlcbiAgICAgIGVuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgaWYgb2Zmc2V0ID49IDBcbiAgICAgICAgdGhlbiAoc3ViIHN0ciAwIChvZmZzZXQgKyAxKSk6OmFjY1xuICAgICAgICBlbHNlIGFjY1xuICAgIGluIGxvb3AgW10gKGxlbmd0aCBzdHIgLSAxKVxuXG4oKiBjb3B5aW5nIGNvcmUncyBjb252ZW50aW9uIGZvciBTdHJpbmcuc3BsaXQgYnV0IHdpdGggYW4gb3B0aW9uYWwgbWF4XG4gICBhcmd1bWVudCAqKVxubGV0IHNwbGl0ID9tYXggcyB+b24gPVxuICBtYXRjaCBtYXggd2l0aFxuICB8IE5vbmUgLT4gc3BsaXRfY2hhcl91bmJvdW5kZWQgcyB+b25cbiAgfCBTb21lIG1heCAtPiAgICAgICAgICAgICAgICAgKCogYXNzZXJ0IChtYXggPCAxMDApOyAqKVxuICAgIHNwbGl0X2NoYXJfYm91bmRlZCBzIH5vbiB+bWF4XG5cbmxldCByaW5kZXhfZnJvbV9vbiBzIH5vZmZzZXQgfm9uID1cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kXG4gICAgZWxzZSBpZiBTdHJpbmcuY29udGFpbnMgb24gcy5baV0gdGhlbiBpXG4gICAgZWxzZSBsb29wIChpIC0gMSlcbiAgaW4gbG9vcCBvZmZzZXRcblxubGV0IHRyaW1fbGVmdF9zdWIgcyB+cG9zIH5sZW4gfmNoYXJzID1cbiAgbGV0IHN0YXJ0X3BvcyA9XG4gICAgbGV0IGZpbmFsID0gcG9zICsgbGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGxhc3RfY2hhciBpID1cbiAgICAgIGlmIGkgPSBmaW5hbCB0aGVuIGxhc3RfY2hhclxuICAgICAgZWxzZSBpZiBTdHJpbmcuY29udGFpbnMgY2hhcnMgcy5baV0gdGhlbiBsb29wIChpICsgMSkgKGkgKyAxKVxuICAgICAgZWxzZSBsYXN0X2NoYXJcbiAgICBpbiBsb29wIHBvcyBwb3NcbiAgaW5cbiAgbGV0IG5ld19sZW4gPSBsZW4gLSAoc3RhcnRfcG9zIC0gcG9zKSBpblxuICBTdHJpbmcuc3ViIHMgc3RhcnRfcG9zIG5ld19sZW5cblxubGV0IHNwbGl0X3RyaW1fbGVmdCBzdHIgfm9uIH50cmltID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgcmVjIGxvb3AgYWNjIG9mZnNldCA9XG4gICAgICB0cnkgYmVnaW5cbiAgICAgICAgbGV0IGluZGV4ID0gcmluZGV4X2Zyb21fb24gc3RyIH5vZmZzZXQgfm9uIGluXG4gICAgICAgIGlmIGluZGV4ID0gb2Zmc2V0IHRoZW5cbiAgICAgICAgICBsb29wIChcIlwiOjphY2MpIChpbmRleCAtIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgdG9rZW4gPSB0cmltX2xlZnRfc3ViIHN0ciB+cG9zOihpbmRleCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB+bGVuOihvZmZzZXQgLSBpbmRleCkgfmNoYXJzOnRyaW0gaW5cbiAgICAgICAgICBsb29wICh0b2tlbjo6YWNjKSAoaW5kZXggLSAxKVxuICAgICAgZW5kXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAodHJpbV9sZWZ0X3N1YiBzdHIgfnBvczowIH5sZW46KG9mZnNldCArIDEpIH5jaGFyczp0cmltKTo6YWNjXG4gICAgaW4gbG9vcCBbXSAobGVuZ3RoIHN0ciAtIDEpXG5cbmV4Y2VwdGlvbiBGb3VuZF9pbnQgb2YgaW50XG5cbmxldCBmaXJzdF9jaGFyX25lIHMgYyA9XG4gIFN0cmluZy5sZW5ndGggcyA+IDAgJiYgcy5bMF0gPD4gY1xuXG5sZXQgdHJpbV9sZWZ0IHMgPVxuICBpZiBmaXJzdF9jaGFyX25lIHMgJyAnIHRoZW4gc1xuICBlbHNlXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIHRyeVxuICAgICAgZm9yIGk9MCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGlmIHMuW2ldIDw+ICcgJyB0aGVuIHJhaXNlIChGb3VuZF9pbnQgaSlcbiAgICAgIGRvbmU7XG4gICAgICBcIlwiXG4gICAgd2l0aCBGb3VuZF9pbnQgbm9uX3NwYWNlIC0+XG4gICAgICBzdWIgcyBub25fc3BhY2UgKGxlbiAtIG5vbl9zcGFjZSlcblxubGV0IHN1YnN0cl9lcSA/KHN0YXJ0PTApIHMgfnBhdHRlcm4gPVxuICB0cnlcbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBwYXR0ZXJuIC0gMSBkb1xuICAgICAgaWYgcy5baSArIHN0YXJ0XSA8PiBwYXR0ZXJuLltpXSB0aGVuIHJhaXNlIEV4aXRcbiAgICBkb25lO1xuICAgIHRydWVcbiAgd2l0aCBfIC0+IGZhbHNlXG5cbmxldCBmaW5kX2Zyb20gPyhzdGFydD0wKSBzdHIgfnBhdHRlcm4gPVxuICB0cnlcbiAgICBmb3IgaSA9IHN0YXJ0IHRvIChTdHJpbmcubGVuZ3RoIHN0cikgLSAoU3RyaW5nLmxlbmd0aCBwYXR0ZXJuKSBkb1xuICAgICAgaWYgc3Vic3RyX2VxIH5zdGFydDppIHN0ciB+cGF0dGVybiB0aGVuXG4gICAgICAgIHJhaXNlIChGb3VuZF9pbnQgaSlcbiAgICBkb25lO1xuICAgIE5vbmVcbiAgd2l0aFxuICB8IEZvdW5kX2ludCBpIC0+IFNvbWUgaVxuICB8ICBfIC0+IE5vbmVcblxubGV0IGZpbmRfbWluIGwgfmYgPVxuICBsZXQgcmVjIGxvb3AgeCBmeCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBTb21lICh4LCBmeClcbiAgICB8IHgnOjp4cyAtPlxuICAgICAgbGV0IGZ4JyA9IGYgeCcgaW5cbiAgICAgIGlmIGZ4JyA8IGZ4IHRoZW4gbG9vcCB4JyBmeCcgeHNcbiAgICAgIGVsc2UgbG9vcCB4IGZ4IHhzXG4gIGluXG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCB4Ojp4cyAtPiBsb29wIHggKGYgeCkgeHNcblxubGV0IHJlcGxhY2VfYWxsIHN0ciB+cGF0dGVybiB+d2l0aF8gPVxuICBsZXQgKHNsZW4sIHBsZW4pID0gU3RyaW5nLihsZW5ndGggc3RyLCBsZW5ndGggcGF0dGVybikgaW5cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgc2xlbiBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgbWF0Y2ggZmluZF9mcm9tIH5zdGFydDppIHN0ciB+cGF0dGVybiB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgc3RyIGkgKHNsZW4gLSBpKTtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgICB8IFNvbWUgaiAtPlxuICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIHN0ciBpIChqIC0gaSk7XG4gICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgd2l0aF87XG4gICAgICBsb29wIChqICsgcGxlbilcbiAgaW4gbG9vcCAwXG5cbmV4Y2VwdGlvbiBGb3VuZF9yZXBsYWNlIG9mIGludCAqIHN0cmluZyAqIHN0cmluZ1xuXG5sZXQgcmVwbGFjZV9hbGxfYXNzb2Mgc3RyIHRibCA9XG4gIGxldCBzbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgc2xlbiBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA+PSBzbGVuIHRoZW4gQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICAgIGVsc2VcbiAgICAgIGxldCByID1cbiAgICAgICAgdHJ5XG4gICAgICAgICAgbGV0IGZvdW5kID0gcmVmIGZhbHNlIGluXG4gICAgICAgICAgbGV0IGUgPVxuICAgICAgICAgICAgZmluZF9taW4gdGJsIH5mOihmdW4gKHBhdHRlcm4sIHdpdGhfKSAtPlxuICAgICAgICAgICAgICBtYXRjaCBmaW5kX2Zyb20gfnN0YXJ0Omkgc3RyIH5wYXR0ZXJuIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lICAgLT4gbWF4X2ludFxuICAgICAgICAgICAgICB8IFNvbWUgaiB3aGVuIGogPSBpIC0+IHJhaXNlIChGb3VuZF9yZXBsYWNlIChqLCBwYXR0ZXJuLCB3aXRoXykpXG4gICAgICAgICAgICAgIHwgU29tZSBqIC0+IGZvdW5kIDo9IHRydWU7IGopXG4gICAgICAgICAgaW5cbiAgICAgICAgICBtYXRjaCBlIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgIHwgU29tZSAoKHBhdHRlcm4sIHdpdGhfKSwgaikgd2hlbiAhZm91bmQgLT4gU29tZSAoaiwgcGF0dGVybiwgd2l0aF8pXG4gICAgICAgICAgfCBTb21lIF8gLT4gTm9uZVxuICAgICAgICB3aXRoIEZvdW5kX3JlcGxhY2UgKGosIHBhdHRlcm4sIHdpdGhfKSAtPiBTb21lIChqLCBwYXR0ZXJuLCB3aXRoXylcbiAgICAgIGluXG4gICAgICBtYXRjaCByIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgc3RyIGkgKHNsZW4gLSBpKTtcbiAgICAgICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICAgICAgfCBTb21lIChqLCBwYXR0ZXJuLCB3aXRoXykgLT5cbiAgICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIHN0ciBpIChqIC0gaSk7XG4gICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiB3aXRoXztcbiAgICAgICAgbG9vcCAoaiArIFN0cmluZy5sZW5ndGggcGF0dGVybilcbiAgaW4gbG9vcCAwXG5cbmxldCBpdGVyaSBmIGwgPVxuICBsZXQgcmVjIGxvb3AgaSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiAoKVxuICAgIHwgeDo6eHMgLT4gKGYgaSB4KTsgbG9vcCAoc3VjYyBpKSB4c1xuICBpbiBsb29wIDAgbFxuXG5sZXQgb2ZfbGlzdCB4cyA9XG4gIGxldCBsID0gTGlzdC5sZW5ndGggeHMgaW5cbiAgbGV0IHMgPSBCeXRlcy5jcmVhdGUgbCBpblxuICBpdGVyaSAoZnVuIGkgYyAtPiBCeXRlcy5zZXQgcyBpIGMpIHhzO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHNcblxubGV0IHRvX2xpc3QgcyA9XG4gIGxldCByZWMgbG9vcCBhY2MgaSA9XG4gICAgaWYgaSA9IC0xIHRoZW4gYWNjXG4gICAgZWxzZVxuICAgICAgbG9vcCAocy5baV0gOjogYWNjKSAocHJlZCBpKVxuICBpbiBsb29wIFtdIChTdHJpbmcubGVuZ3RoIHMgLSAxKVxuXG5sZXQgb2ZfYXJyYXkgYSA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggYSBpblxuICBsZXQgYnl0ZXMgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgQnl0ZXMuc2V0IGJ5dGVzIGkgYS4oaSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBieXRlc1xuXG5sZXQgdG9fYXJyYXkgcyA9IEFycmF5LmluaXQgKFN0cmluZy5sZW5ndGggcykgKFN0cmluZy5nZXQgcylcblxuKCogcmlwcGVkIG9mZiBmcm9tIG9uZSBvZiBkYnVlbnpsaSdzIGxpYnMgKilcbmxldCBjdXQgcyB+b24gPVxuICBsZXQgc2VwX21heCA9IGxlbmd0aCBvbiAtIDEgaW5cbiAgaWYgc2VwX21heCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZ2V4dC5jdXQ6IGVtcHR5IHNlcGFyYXRvclwiIGVsc2VcbiAgICBsZXQgc19tYXggPSBsZW5ndGggcyAtIDEgaW5cbiAgICBpZiBzX21heCA8IDAgdGhlbiBOb25lIGVsc2VcbiAgICAgIGxldCBrID0gcmVmIDAgaW5cbiAgICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICAgICgqIFdlIHJ1biBmcm9tIHRoZSBzdGFydCBvZiBbc10gdG8gZW5kIHdpdGggW2ldIHRyeWluZyB0byBtYXRjaCB0aGVcbiAgICAgICAgIGZpcnN0IGNoYXJhY3RlciBvZiBbb25dIGluIFtzXS4gSWYgdGhpcyBtYXRjaGVzLCB3ZSB2ZXJpZnkgdGhhdFxuICAgICAgICAgdGhlIHdob2xlIFtvbl0gaXMgbWF0Y2hlZCB1c2luZyBba10uIElmIGl0IGRvZXNuJ3QgbWF0Y2ggd2VcbiAgICAgICAgIGNvbnRpbnVlIHRvIGxvb2sgZm9yIFtvbl0gd2l0aCBbaV0uIElmIGl0IG1hdGNoZXMgd2UgZXhpdCB0aGVcbiAgICAgICAgIGxvb3AgYW5kIGV4dHJhY3QgYSBzdWJzdHJpbmcgZnJvbSB0aGUgc3RhcnQgb2YgW3NdIHRvIHRoZVxuICAgICAgICAgcG9zaXRpb24gYmVmb3JlIHRoZSBbb25dIHdlIGZvdW5kIGFuZCBhbm90aGVyIGZyb20gdGhlIHBvc2l0aW9uXG4gICAgICAgICBhZnRlciB0aGUgW29uXSB3ZSBmb3VuZCB0byBlbmQgb2Ygc3RyaW5nLiBJZiBbaV0gaXMgc3VjaCB0aGF0IG5vXG4gICAgICAgICBzZXBhcmF0b3IgY2FuIGJlIGZvdW5kIHdlIGV4aXQgdGhlIGxvb3AgYW5kIHJldHVybiB0aGUgbm8gbWF0Y2hcbiAgICAgICAgIGNhc2UuICopXG4gICAgICB0cnlcbiAgICAgICAgd2hpbGUgKCFpICsgc2VwX21heCA8PSBzX21heCkgZG9cbiAgICAgICAgICAoKiBDaGVjayByZW1haW5pbmcgW29uXSBjaGFycyBtYXRjaCwgYWNjZXNzIHRvIHVuc2FmZSBzICghaSArICFrKSBpc1xuICAgICAgICAgICAgIGd1YXJhbnRlZWQgYnkgbG9vcCBpbnZhcmlhbnQuICopXG4gICAgICAgICAgaWYgdW5zYWZlX2dldCBzICFpIDw+IHVuc2FmZV9nZXQgb24gMCB0aGVuIGluY3IgaSBlbHNlIGJlZ2luXG4gICAgICAgICAgICBrIDo9IDE7XG4gICAgICAgICAgICB3aGlsZSAoIWsgPD0gc2VwX21heCAmJiB1bnNhZmVfZ2V0IHMgKCFpICsgIWspID0gdW5zYWZlX2dldCBvbiAhaylcbiAgICAgICAgICAgIGRvIGluY3IgayBkb25lO1xuICAgICAgICAgICAgaWYgIWsgPD0gc2VwX21heCB0aGVuICgqIG5vIG1hdGNoICopIGluY3IgaSBlbHNlIHJhaXNlIEV4aXRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZG9uZTtcbiAgICAgICAgTm9uZSAoKiBubyBtYXRjaCBpbiB0aGUgd2hvbGUgc3RyaW5nLiAqKVxuICAgICAgd2l0aFxuICAgICAgfCBFeGl0IC0+ICgqIGkgaXMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2VwYXJhdG9yICopXG4gICAgICAgIGxldCBsZWZ0X2VuZCA9ICFpIC0gMSBpblxuICAgICAgICBsZXQgcmlnaHRfc3RhcnQgPSAhaSArIHNlcF9tYXggKyAxIGluXG4gICAgICAgIFNvbWUgKHN1YiBzIDAgKGxlZnRfZW5kICsgMSksXG4gICAgICAgICAgICAgIHN1YiBzIHJpZ2h0X3N0YXJ0IChzX21heCAtIHJpZ2h0X3N0YXJ0ICsgMSkpXG5cbmxldCByY3V0IHMgfm9uID1cbiAgbGV0IHNlcF9tYXggPSBsZW5ndGggb24gLSAxIGluXG4gIGlmIHNlcF9tYXggPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmdleHQucmN1dDogZW1wdHkgc2VwYXJhdG9yXCIgZWxzZVxuICAgIGxldCBzX21heCA9IGxlbmd0aCBzIC0gMSBpblxuICAgIGlmIHNfbWF4IDwgMCB0aGVuIE5vbmUgZWxzZVxuICAgICAgbGV0IGsgPSByZWYgMCBpblxuICAgICAgbGV0IGkgPSByZWYgc19tYXggaW5cbiAgICAgICgqIFdlIHJ1biBmcm9tIHRoZSBlbmQgb2YgW3NdIHRvIHRoZSBiZWdpbm5pbmcgd2l0aCBbaV0gdHJ5aW5nIHRvXG4gICAgICAgICBtYXRjaCB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgW29uXSBpbiBbc10uIElmIHRoaXMgbWF0Y2hlcywgd2VcbiAgICAgICAgIHZlcmlmeSB0aGF0IHRoZSB3aG9sZSBbb25dIGlzIG1hdGNoZWQgdXNpbmcgW2tdICh3ZSBkbyB0aGF0XG4gICAgICAgICBiYWNrd2FyZHMpLiAgSWYgaXQgZG9lc24ndCBtYXRjaCB3ZSBjb250aW51ZSB0byBsb29rIGZvciBbb25dXG4gICAgICAgICB3aXRoIFtpXS4gIElmIGl0IG1hdGNoZXMgd2UgZXhpdCB0aGUgbG9vcCBhbmQgZXh0cmFjdCBhXG4gICAgICAgICBzdWJzdHJpbmcgZnJvbSB0aGUgc3RhcnQgb2YgW3NdIHRvIHRoZSBwb3NpdGlvbiBiZWZvcmUgdGhlXG4gICAgICAgICBbb25dIHdlIGZvdW5kIGFuZCBhbm90aGVyIGZyb20gdGhlIHBvc2l0aW9uIGFmdGVyIHRoZSBbb25dIHdlXG4gICAgICAgICBmb3VuZCB0byBlbmQgb2Ygc3RyaW5nLiAgSWYgW2ldIGlzIHN1Y2ggdGhhdCBubyBzZXBhcmF0b3IgY2FuXG4gICAgICAgICBiZSBmb3VuZCB3ZSBleGl0IHRoZSBsb29wIGFuZCByZXR1cm4gdGhlIG5vIG1hdGNoIGNhc2UuICopXG4gICAgICB0cnlcbiAgICAgICAgd2hpbGUgKCFpID49IHNlcF9tYXgpIGRvXG4gICAgICAgICAgaWYgdW5zYWZlX2dldCBzICFpIDw+IHVuc2FmZV9nZXQgb24gc2VwX21heCB0aGVuIGRlY3IgaSBlbHNlIGJlZ2luXG4gICAgICAgICAgICAoKiBDaGVjayByZW1haW5pbmcgW29uXSBjaGFycyBtYXRjaCwgYWNjZXNzIHRvIHVuc2FmZV9nZXRcbiAgICAgICAgICAgICAgIHMgKHNlcF9zdGFydCArICFrKSBpcyBndWFyYW50ZWVkIGJ5IGxvb3AgaW52YXJpYW50LiAqKVxuICAgICAgICAgICAgbGV0IHNlcF9zdGFydCA9ICFpIC0gc2VwX21heCBpblxuICAgICAgICAgICAgayA6PSBzZXBfbWF4IC0gMTtcbiAgICAgICAgICAgIHdoaWxlICghayA+PSAwICYmIHVuc2FmZV9nZXQgcyAoc2VwX3N0YXJ0ICsgIWspID0gdW5zYWZlX2dldCBvbiAhaylcbiAgICAgICAgICAgIGRvIGRlY3IgayBkb25lO1xuICAgICAgICAgICAgaWYgIWsgPj0gMCB0aGVuICgqIG5vIG1hdGNoICopIGRlY3IgaSBlbHNlIHJhaXNlIEV4aXRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZG9uZTtcbiAgICAgICAgTm9uZSAoKiBubyBtYXRjaCBpbiB0aGUgd2hvbGUgc3RyaW5nLiAqKVxuICAgICAgd2l0aFxuICAgICAgfCBFeGl0IC0+ICgqIGkgaXMgYXQgdGhlIGVuZCBvZiB0aGUgc2VwYXJhdG9yICopXG4gICAgICAgIGxldCBsZWZ0X2VuZCA9ICFpIC0gc2VwX21heCAtIDEgaW5cbiAgICAgICAgbGV0IHJpZ2h0X3N0YXJ0ID0gIWkgKyAxIGluXG4gICAgICAgIFNvbWUgKHN1YiBzIDAgKGxlZnRfZW5kICsgMSksXG4gICAgICAgICAgICAgIHN1YiBzIHJpZ2h0X3N0YXJ0IChzX21heCAtIHJpZ2h0X3N0YXJ0ICsgMSkpXG5cbmxldCBjaG9wX3ByZWZpeCBzIH5wcmVmaXggPVxuICBsZXQgcHJlZml4X2wgPSBTdHJpbmcubGVuZ3RoIHByZWZpeCBpblxuICBsZXQgc3RyaW5nX2wgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgaWYgcHJlZml4X2wgPiBzdHJpbmdfbCB0aGVuIE5vbmVcbiAgZWxzZVxuICAgIHRyeVxuICAgICAgZm9yIGkgPSAwIHRvIHByZWZpeF9sIC0gMSBkb1xuICAgICAgICBpZiBzLltpXSA8PiBwcmVmaXguW2ldIHRoZW4gcmFpc2UgRXhpdDtcbiAgICAgIGRvbmU7XG4gICAgICBTb21lIChTdHJpbmcuc3ViIHMgcHJlZml4X2wgKHN0cmluZ19sIC0gcHJlZml4X2wpKVxuICAgIHdpdGggXyAtPiBOb25lXG5cbmxldCBkcm9wIHMgbiA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGlmIG4gPj0gbFxuICB0aGVuIFwiXCJcbiAgZWxzZSBTdHJpbmcuc3ViIHMgbiAobCAtIG4pXG5cbmxldCB0YWtlIHMgbiA9XG4gIGlmIG4gPj0gU3RyaW5nLmxlbmd0aCBzXG4gIHRoZW4gc1xuICBlbHNlIFN0cmluZy5zdWIgcyAwIG5cbiJdfQ==
