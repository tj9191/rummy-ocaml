// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Splittable_random
//# unitInfo: Requires: Base, Base__Error, Base__Float, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__Nativeint, Base__Random, Ppx_bench_lib__Benchmark_accumulator, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_hi = "hi",
    cst_lo = "lo",
    cst_src_splittable_random_ml$1 = "src/splittable_random.ml",
    caml_div = runtime.caml_div,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_div = runtime.caml_int64_div,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_notequal = runtime.caml_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    int64$0 = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    golden_gamma = runtime.caml_int64_create_lo_mi_hi(4881429, 7977343, 40503),
    Base_Int = global_data.Base__Int,
    Assert_failure = global_data.Assert_failure,
    Base = global_data.Base,
    Base_Float = global_data.Base__Float,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Int64 = global_data.Base__Int64,
    Base_Int63 = global_data.Base__Int63,
    Base_Error = global_data.Base__Error,
    Base_Random = global_data.Base__Random,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Base_Int32 = global_data.Base__Int32,
    Base_Nativeint = global_data.Base__Nativeint;
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], "splittable_random");
   var
    popcount = Base_Int64[52],
    _o_ = [0, cst_src_splittable_random_ml$1, 279, 6],
    _m_ = [0, cst_hi],
    _n_ = [0, cst_lo],
    cst_float_bounds_are_crossed = "float: bounds are crossed",
    _k_ = [0, cst_hi],
    _l_ = [0, cst_lo],
    cst_float_bounds_are_not_finit = "float: bounds are not finite numbers",
    _h_ = [0, cst_hi],
    _i_ = [0, cst_lo],
    cst_int64_crossed_bounds = "int64: crossed bounds",
    _j_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _f_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(11184810, 11184810, 43690),
    _d_ = runtime.caml_int64_create_lo_mi_hi(15001017, 4680988, 48984),
    _e_ = runtime.caml_int64_create_lo_mi_hi(3215851, 4832019, 38096),
    _b_ = runtime.caml_int64_create_lo_mi_hi(5606605, 11524077, 65361),
    _c_ = runtime.caml_int64_create_lo_mi_hi(8776787, 12189210, 50382),
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    cst_src_splittable_random_ml = cst_src_splittable_random_ml$1,
    cst_src_splittable_random_ml$0 = cst_src_splittable_random_ml$1,
    cst_let_int64_1L_in_fun_unit_f =
      "let int64 = 1L in fun () -> unit_float_from_int64 int64",
    cst_unit_float_from_int64 = "unit_float_from_int64";
   function of_int(seed){return [0, caml_int64_of_int32(seed), golden_gamma];}
   function copy(param){
    var seed = param[1], odd_gamma = param[2];
    return [0, seed, odd_gamma];
   }
   function mix_bits(z, n){
    return caml_int64_xor(z, caml_int64_shift_right_unsigne(z, n));
   }
   function mix64(z){
    var
     z$0 = caml_int64_mul(mix_bits(z, 33), _b_),
     z$1 = caml_int64_mul(mix_bits(z$0, 33), _c_);
    return mix_bits(z$1, 33);
   }
   function next_seed(t){
    var next = caml_int64_add(t[1], t[2]);
    t[1] = next;
    return next;
   }
   function of_seed_and_gamma(seed, gamma){
    var
     seed$0 = mix64(seed),
     z = caml_int64_mul(mix_bits(gamma, 30), _d_),
     z$0 = caml_int64_mul(mix_bits(z, 27), _e_),
     z$1 = caml_int64_or(mix_bits(z$0, 31), _f_),
     n =
       caml_call1
        (popcount,
         caml_int64_xor(z$1, caml_int64_shift_right_unsigne(z$1, 1))),
     odd_gamma = 24 <= n ? z$1 : caml_int64_xor(z$1, _g_);
    return [0, seed$0, odd_gamma];
   }
   function random_int64(random_state){
    return caml_call3
            (Base_Random[19][15],
             random_state,
             Base_Int64[66],
             Base_Int64[65]);
   }
   function create(random_state){
    var seed = random_int64(random_state), gamma = random_int64(random_state);
    return of_seed_and_gamma(seed, gamma);
   }
   function split(t){
    var seed = next_seed(t), gamma = next_seed(t);
    return of_seed_and_gamma(seed, gamma);
   }
   function next_int64(t){return mix64(next_seed(t));}
   function perturb(t, salt){
    var
     _by_ = mix64(caml_int64_of_int32(salt)),
     next = caml_int64_add(t[1], _by_);
    t[1] = next;
    return 0;
   }
   function bool(state){
    var x = next_int64(state);
    return caml_equal(caml_int64_or(x, _a_), x);
   }
   function int64(state, lo, hi){
    if(caml_greaterthan(lo, hi)){
     var
      _bu_ = [0, [1, [0, _h_, [0, caml_call1(Base[156], hi), 0]]], 0],
      _bv_ = [0, [1, [0, _i_, [0, caml_call1(Base[156], lo), 0]]], _bu_],
      _bw_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_int64_crossed_bounds),
          _bv_]];
     caml_call1(Base_Error[32], _bw_);
    }
    var remainder_maximum = caml_int64_sub(hi, lo);
    if(caml_equal(remainder_maximum, Base_Int64[65])){
     var _bx_ = Base_Int64[65];
     return caml_int64_add(caml_int64_and(next_int64(state), _bx_), lo);
    }
    if(caml_greaterequal(remainder_maximum, _j_))
     for(;;){
      var
       _bs_ = Base_Int64[65],
       draw$0 = caml_int64_and(next_int64(state), _bs_),
       _bt_ = caml_call1(Base_Int64[45], remainder_maximum),
       remainder = caml_call2(Base_Int64[39], draw$0, _bt_),
       draw_maximum = Base_Int64[65];
      if
       (caml_lessequal
         (caml_int64_sub(draw$0, remainder),
          caml_int64_sub(draw_maximum, remainder_maximum)))
       return caml_int64_add(remainder, lo);
     }
    else
     for(;;){
      var draw = next_int64(state);
      if(caml_lessequal(lo, draw) && caml_lessequal(draw, hi)) return draw;
     }
   }
   function int$0(state, lo, hi){
    var lo$0 = caml_int64_of_int32(lo), hi$0 = caml_int64_of_int32(hi);
    return caml_int64_to_int32(int64(state, lo$0, hi$0));
   }
   function int32(state, lo, hi){
    var lo$0 = caml_int64_of_int32(lo), hi$0 = caml_int64_of_int32(hi);
    return caml_int64_to_int32(int64(state, lo$0, hi$0));
   }
   function nativeint(state, lo, hi){
    var lo$0 = caml_int64_of_int32(lo), hi$0 = caml_int64_of_int32(hi);
    return caml_int64_to_int32(int64(state, lo$0, hi$0));
   }
   function int63(state, lo, hi){
    var
     lo$0 = caml_call1(Base_Int63[83], lo),
     hi$0 = caml_call1(Base_Int63[83], hi),
     _br_ = int64(state, lo$0, hi$0);
    return caml_call1(Base_Int63[109], _br_);
   }
   var double_ulp = caml_call2(Base[239], 2., -53.);
   function unit_float_from_int64(int64){
    var
     _bq_ =
       caml_call1(Base_Int64[4], caml_int64_shift_right_unsigne(int64, 11));
    return caml_call2(Base[236], _bq_, double_ulp);
   }
   function unit_float(state){
    return unit_float_from_int64(next_int64(state));
   }
   function float$0(state, lo$0, hi$0){
    var
     _bi_ = caml_call1(Base_Float[80], lo$0),
     _bj_ = _bi_ ? caml_call1(Base_Float[80], hi$0) : _bi_;
    if(1 - _bj_){
     var
      _bk_ = [0, [1, [0, _k_, [0, caml_call1(Base[126], hi$0), 0]]], 0],
      _bl_ = [0, [1, [0, _l_, [0, caml_call1(Base[126], lo$0), 0]]], _bk_],
      _bm_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_float_bounds_are_not_finit),
          _bl_]];
     caml_call1(Base[246], _bm_);
    }
    if(hi$0 < lo$0){
     var
      _bn_ = [0, [1, [0, _m_, [0, caml_call1(Base[126], hi$0), 0]]], 0],
      _bo_ = [0, [1, [0, _n_, [0, caml_call1(Base[126], lo$0), 0]]], _bn_],
      _bp_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_float_bounds_are_crossed),
          _bo_]];
     caml_call1(Base[246], _bp_);
    }
    var lo = lo$0, hi = hi$0;
    for(;;){
     var range = caml_call2(Base[235], hi, lo);
     if(caml_call1(Base_Float[80], range)){
      var _bf_ = unit_float(state), _bg_ = caml_call2(Base[236], _bf_, range);
      return caml_call2(Base[234], lo, _bg_);
     }
     var
      _bh_ = caml_call2(Base[234], hi, lo),
      mid = caml_call2(Base[237], _bh_, 2.);
     if(bool(state)) var hi = mid; else var lo = mid;
    }
   }
   if(Ppx_bench_lib_Benchmark_accumu[3]){
    var
     f =
       function(param){
        return function(param){return unit_float_from_int64(int64$0);};
       };
    caml_call8
     (Ppx_bench_lib_Benchmark_accumu[5],
      cst_unit_float_from_int64,
      cst_let_int64_1L_in_fun_unit_f,
      cst_src_splittable_random_ml$0,
      cst_src_splittable_random_ml,
      263,
      0,
      99,
      [0, f]);
   }
   function Make(M){
    function bits_to_represent(t){
     if(! caml_call2(M[12], t, M[42]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
     var t$0 = [0, t], n = [0, 0];
     for(;;){
      if(! caml_call2(M[15], t$0[1], M[42])) return n[1];
      t$0[1] = caml_call2(M[77], t$0[1], 1);
      caml_call1(Base_Int[56], n);
     }
    }
    function log_uniform(state, lo, hi){
     var
      min_bits = bits_to_represent(lo),
      max_bits = bits_to_represent(hi),
      bits = int$0(state, min_bits, max_bits),
      _ba_ = caml_call2(M[76], M[43], bits),
      _bb_ = caml_call1(M[69], _ba_),
      _bc_ = caml_call1(caml_call1(M[20], hi), _bb_);
     if(caml_call2(Base_Int[13], bits, 0))
      var _bd_ = M[42];
     else
      var
       _a$_ = caml_call1(Base_Int[46], bits),
       _bd_ = caml_call2(M[76], M[43], _a$_);
     var _be_ = caml_call1(caml_call1(M[21], lo), _bd_);
     return caml_call3(M[100], state, _be_, _bc_);
    }
    return [0, log_uniform];
   }
   var
    t_sexp_grammar = Base_Int[2],
    of_float = Base_Int[3],
    to_float = Base_Int[4],
    of_int_exn = Base_Int[5],
    to_int_exn = Base_Int[6],
    hash_fold_t = Base_Int[7],
    hash = Base_Int[8],
    t_of_sexp = Base_Int[9],
    sexp_of_t = Base_Int[10],
    of_string = Base_Int[11],
    to_string = Base_Int[12],
    equal = Base_Int[13],
    compare = Base_Int[14],
    min = Base_Int[15],
    max = Base_Int[16],
    ascending = Base_Int[17],
    descending = Base_Int[18],
    between = Base_Int[19],
    clamp_exn = Base_Int[20],
    clamp = Base_Int[21],
    comparator = Base_Int[22],
    pp = Base_Int[23],
    hashable = Base_Int[24],
    is_positive = Base_Int[25],
    is_non_negative = Base_Int[26],
    is_negative = Base_Int[27],
    is_non_positive = Base_Int[28],
    sign = Base_Int[29],
    compare_local = Base_Int[30],
    equal_local = Base_Int[31],
    invariant = Base_Int[32],
    Hex = Base_Int[33],
    Binary = Base_Int[34],
    of_string_opt = Base_Int[35],
    to_string_hum = Base_Int[36],
    one = Base_Int[37],
    minus_one = Base_Int[38],
    rem = Base_Int[39],
    round = Base_Int[40],
    round_towards_zero = Base_Int[41],
    round_down = Base_Int[42],
    round_up = Base_Int[43],
    round_nearest = Base_Int[44],
    succ = Base_Int[45],
    pred = Base_Int[46],
    pow = Base_Int[47],
    bit_and = Base_Int[48],
    bit_or = Base_Int[49],
    bit_xor = Base_Int[50],
    bit_not = Base_Int[51],
    popcount$0 = Base_Int[52],
    shift_left = Base_Int[53],
    shift_right = Base_Int[54],
    decr = Base_Int[55],
    incr = Base_Int[56],
    of_int32_exn = Base_Int[57],
    to_int32_exn = Base_Int[58],
    of_int64_exn = Base_Int[59],
    to_int64 = Base_Int[60],
    of_nativeint_exn = Base_Int[61],
    to_nativeint_exn = Base_Int[62],
    of_float_unchecked = Base_Int[63],
    num_bits = Base_Int[64],
    max_value = Base_Int[65],
    min_value = Base_Int[66],
    shift_right_logical = Base_Int[67],
    ceil_pow2 = Base_Int[68],
    floor_pow2 = Base_Int[69],
    ceil_log2 = Base_Int[70],
    floor_log2 = Base_Int[71],
    is_pow2 = Base_Int[72],
    clz = Base_Int[73],
    ctz = Base_Int[74],
    O = Base_Int[75],
    symbol = Base_Int[76],
    lnot = Base_Int[77],
    abs = Base_Int[78],
    zero = Base_Int[79],
    symbol$0 = Base_Int[80],
    symbol$1 = Base_Int[81],
    symbol$2 = Base_Int[82];
   function _p_(_a__, _a9_){return _a__ >>> _a9_ | 0;}
   function _q_(_a8_, _a7_){return _a8_ >> _a7_;}
   function _r_(_a6_, _a5_){return _a6_ << _a5_;}
   var _s_ = O[2];
   function _t_(_a4_, _a3_){return _a4_ ^ _a3_;}
   function _u_(_a2_, _a1_){return _a2_ | _a1_;}
   function _v_(_a0_, _aZ_){return _a0_ & _aZ_;}
   var _w_ = O[7], _x_ = O[6], _y_ = O[5], _z_ = O[4];
   function _A_(_aY_){return - _aY_ | 0;}
   var _B_ = O[3];
   function _C_(_aX_, _aW_){return _aX_ !== _aW_ ? 1 : 0;}
   function _D_(_aV_, _aU_){return _aV_ < _aU_ ? 1 : 0;}
   function _E_(_aT_, _aS_){return _aS_ < _aT_ ? 1 : 0;}
   function _F_(_aR_, _aQ_){return _aR_ === _aQ_ ? 1 : 0;}
   function _G_(_aP_, _aO_){return _aP_ <= _aO_ ? 1 : 0;}
   function _H_(_aN_, _aM_){return _aM_ <= _aN_ ? 1 : 0;}
   var _I_ = O[1];
   function _J_(_aL_){return - _aL_ | 0;}
   var _K_ = caml_div, _L_ = caml_mul;
   function _M_(_aK_, _aJ_){return _aK_ - _aJ_ | 0;}
   var
    _N_ =
      [0,
       function(_aI_, _aH_){return _aI_ + _aH_ | 0;},
       _M_,
       _L_,
       _K_,
       _J_,
       _I_,
       _H_,
       _G_,
       _F_,
       _E_,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_,
       _v_,
       _u_,
       _t_,
       _s_,
       _r_,
       _q_,
       _p_];
   function _O_(_aG_, _aF_){return _aG_ >>> _aF_ | 0;}
   function _P_(_aE_, _aD_){return _aE_ >> _aD_;}
   function _Q_(_aC_, _aB_){return _aC_ << _aB_;}
   function _R_(_aA_, _az_){return _aA_ ^ _az_;}
   function _S_(_ay_, _ax_){return _ay_ | _ax_;}
   function _T_(_aw_, _av_){return _aw_ & _av_;}
   var _U_ = caml_div;
   function _V_(_au_){return - _au_ | 0;}
   function _W_(_at_){return - _at_ | 0;}
   var _X_ = caml_mul;
   function _Y_(_as_, _ar_){return _as_ - _ar_ | 0;}
   function _Z_(_aq_, _ap_){return _aq_ + _ap_ | 0;}
   function ___(_ao_, _an_){return _ao_ !== _an_ ? 1 : 0;}
   function _$_(_am_, _al_){return _am_ < _al_ ? 1 : 0;}
   function _aa_(_ak_, _aj_){return _aj_ < _ak_ ? 1 : 0;}
   function _ab_(_ai_, _ah_){return _ai_ === _ah_ ? 1 : 0;}
   function _ac_(_ag_, _af_){return _ag_ <= _af_ ? 1 : 0;}
   var
    For_int =
      Make
       ([0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(_ae_, _ad_){return _ad_ <= _ae_ ? 1 : 0;},
         _ac_,
         _ab_,
         _aa_,
         _$_,
         ___,
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         compare_local,
         equal_local,
         invariant,
         Hex,
         Binary,
         of_string_opt,
         to_string_hum,
         zero,
         one,
         minus_one,
         _Z_,
         _Y_,
         _X_,
         symbol,
         _W_,
         _V_,
         symbol$1,
         symbol$0,
         _U_,
         rem,
         symbol$2,
         _T_,
         _S_,
         _R_,
         lnot,
         _Q_,
         _P_,
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount$0,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         of_float_unchecked,
         num_bits,
         max_value,
         min_value,
         _O_,
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         floor_log2,
         is_pow2,
         clz,
         ctz,
         _N_,
         int$0]),
    t_sexp_grammar$0 = Base_Int32[2],
    of_float$0 = Base_Int32[3],
    to_float$0 = Base_Int32[4],
    of_int_exn$0 = Base_Int32[5],
    to_int_exn$0 = Base_Int32[6],
    hash_fold_t$0 = Base_Int32[7],
    hash$0 = Base_Int32[8],
    t_of_sexp$0 = Base_Int32[9],
    sexp_of_t$0 = Base_Int32[10],
    of_string$0 = Base_Int32[11],
    to_string$0 = Base_Int32[12],
    symbol$3 = Base_Int32[13],
    symbol$4 = Base_Int32[14],
    symbol$5 = Base_Int32[15],
    symbol$6 = Base_Int32[16],
    symbol$7 = Base_Int32[17],
    symbol$8 = Base_Int32[18],
    equal$0 = Base_Int32[19],
    compare$0 = Base_Int32[20],
    min$0 = Base_Int32[21],
    max$0 = Base_Int32[22],
    ascending$0 = Base_Int32[23],
    descending$0 = Base_Int32[24],
    between$0 = Base_Int32[25],
    clamp_exn$0 = Base_Int32[26],
    clamp$0 = Base_Int32[27],
    comparator$0 = Base_Int32[28],
    pp$0 = Base_Int32[29],
    hashable$0 = Base_Int32[30],
    is_positive$0 = Base_Int32[31],
    is_non_negative$0 = Base_Int32[32],
    is_negative$0 = Base_Int32[33],
    is_non_positive$0 = Base_Int32[34],
    sign$0 = Base_Int32[35],
    compare_local$0 = Base_Int32[36],
    equal_local$0 = Base_Int32[37],
    invariant$0 = Base_Int32[38],
    Hex$0 = Base_Int32[39],
    Binary$0 = Base_Int32[40],
    of_string_opt$0 = Base_Int32[41],
    to_string_hum$0 = Base_Int32[42],
    zero$0 = Base_Int32[43],
    one$0 = Base_Int32[44],
    minus_one$0 = Base_Int32[45],
    symbol$9 = Base_Int32[46],
    symbol$10 = Base_Int32[47],
    symbol$11 = Base_Int32[48],
    symbol$12 = Base_Int32[49],
    neg = Base_Int32[50],
    symbol$13 = Base_Int32[51],
    symbol$14 = Base_Int32[52],
    symbol$15 = Base_Int32[53],
    symbol$16 = Base_Int32[54],
    rem$0 = Base_Int32[55],
    symbol$17 = Base_Int32[56],
    land = Base_Int32[57],
    lor = Base_Int32[58],
    lxor = Base_Int32[59],
    lnot$0 = Base_Int32[60],
    lsl = Base_Int32[61],
    asr = Base_Int32[62],
    round$0 = Base_Int32[63],
    round_towards_zero$0 = Base_Int32[64],
    round_down$0 = Base_Int32[65],
    round_up$0 = Base_Int32[66],
    round_nearest$0 = Base_Int32[67],
    abs$0 = Base_Int32[68],
    succ$0 = Base_Int32[69],
    pred$0 = Base_Int32[70],
    pow$0 = Base_Int32[71],
    bit_and$0 = Base_Int32[72],
    bit_or$0 = Base_Int32[73],
    bit_xor$0 = Base_Int32[74],
    bit_not$0 = Base_Int32[75],
    popcount$1 = Base_Int32[76],
    shift_left$0 = Base_Int32[77],
    shift_right$0 = Base_Int32[78],
    decr$0 = Base_Int32[79],
    incr$0 = Base_Int32[80],
    of_int32_exn$0 = Base_Int32[81],
    to_int32_exn$0 = Base_Int32[82],
    of_int64_exn$0 = Base_Int32[83],
    to_int64$0 = Base_Int32[84],
    of_nativeint_exn$0 = Base_Int32[85],
    to_nativeint_exn$0 = Base_Int32[86],
    of_float_unchecked$0 = Base_Int32[87],
    num_bits$0 = Base_Int32[88],
    max_value$0 = Base_Int32[89],
    min_value$0 = Base_Int32[90],
    lsr = Base_Int32[91],
    shift_right_logical$0 = Base_Int32[92],
    ceil_pow2$0 = Base_Int32[93],
    floor_pow2$0 = Base_Int32[94],
    ceil_log2$0 = Base_Int32[95],
    floor_log2$0 = Base_Int32[96],
    is_pow2$0 = Base_Int32[97],
    clz$0 = Base_Int32[98],
    ctz$0 = Base_Int32[99],
    O$0 = Base_Int32[100],
    For_int32 =
      Make
       ([0,
         t_sexp_grammar$0,
         of_float$0,
         to_float$0,
         of_int_exn$0,
         to_int_exn$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$0,
         of_string$0,
         to_string$0,
         symbol$3,
         symbol$4,
         symbol$5,
         symbol$6,
         symbol$7,
         symbol$8,
         equal$0,
         compare$0,
         min$0,
         max$0,
         ascending$0,
         descending$0,
         between$0,
         clamp_exn$0,
         clamp$0,
         comparator$0,
         pp$0,
         hashable$0,
         is_positive$0,
         is_non_negative$0,
         is_negative$0,
         is_non_positive$0,
         sign$0,
         compare_local$0,
         equal_local$0,
         invariant$0,
         Hex$0,
         Binary$0,
         of_string_opt$0,
         to_string_hum$0,
         zero$0,
         one$0,
         minus_one$0,
         symbol$9,
         symbol$10,
         symbol$11,
         symbol$12,
         neg,
         symbol$13,
         symbol$14,
         symbol$15,
         symbol$16,
         rem$0,
         symbol$17,
         land,
         lor,
         lxor,
         lnot$0,
         lsl,
         asr,
         round$0,
         round_towards_zero$0,
         round_down$0,
         round_up$0,
         round_nearest$0,
         abs$0,
         succ$0,
         pred$0,
         pow$0,
         bit_and$0,
         bit_or$0,
         bit_xor$0,
         bit_not$0,
         popcount$1,
         shift_left$0,
         shift_right$0,
         decr$0,
         incr$0,
         of_int32_exn$0,
         to_int32_exn$0,
         of_int64_exn$0,
         to_int64$0,
         of_nativeint_exn$0,
         to_nativeint_exn$0,
         of_float_unchecked$0,
         num_bits$0,
         max_value$0,
         min_value$0,
         lsr,
         shift_right_logical$0,
         ceil_pow2$0,
         floor_pow2$0,
         ceil_log2$0,
         floor_log2$0,
         is_pow2$0,
         clz$0,
         ctz$0,
         O$0,
         int32]),
    t_sexp_grammar$1 = Base_Int63[1],
    of_float$1 = Base_Int63[2],
    to_float$1 = Base_Int63[3],
    of_int_exn$1 = Base_Int63[4],
    to_int_exn$1 = Base_Int63[5],
    hash_fold_t$1 = Base_Int63[6],
    hash$1 = Base_Int63[7],
    t_of_sexp$1 = Base_Int63[8],
    sexp_of_t$1 = Base_Int63[9],
    of_string$1 = Base_Int63[10],
    to_string$1 = Base_Int63[11],
    symbol$18 = Base_Int63[12],
    symbol$19 = Base_Int63[13],
    symbol$20 = Base_Int63[14],
    symbol$21 = Base_Int63[15],
    symbol$22 = Base_Int63[16],
    symbol$23 = Base_Int63[17],
    equal$1 = Base_Int63[18],
    compare$1 = Base_Int63[19],
    min$1 = Base_Int63[20],
    max$1 = Base_Int63[21],
    ascending$1 = Base_Int63[22],
    descending$1 = Base_Int63[23],
    between$1 = Base_Int63[24],
    clamp_exn$1 = Base_Int63[25],
    clamp$1 = Base_Int63[26],
    comparator$1 = Base_Int63[27],
    pp$1 = Base_Int63[28],
    hashable$1 = Base_Int63[29],
    is_positive$1 = Base_Int63[30],
    is_non_negative$1 = Base_Int63[31],
    is_negative$1 = Base_Int63[32],
    is_non_positive$1 = Base_Int63[33],
    sign$1 = Base_Int63[34],
    compare_local$1 = Base_Int63[35],
    equal_local$1 = Base_Int63[36],
    invariant$1 = Base_Int63[37],
    Hex$1 = Base_Int63[38],
    Binary$1 = Base_Int63[39],
    of_string_opt$1 = Base_Int63[40],
    to_string_hum$1 = Base_Int63[41],
    zero$1 = Base_Int63[42],
    one$1 = Base_Int63[43],
    minus_one$1 = Base_Int63[44],
    symbol$24 = Base_Int63[45],
    symbol$25 = Base_Int63[46],
    symbol$26 = Base_Int63[47],
    symbol$27 = Base_Int63[48],
    neg$0 = Base_Int63[49],
    symbol$28 = Base_Int63[50],
    symbol$29 = Base_Int63[51],
    symbol$30 = Base_Int63[52],
    symbol$31 = Base_Int63[53],
    rem$1 = Base_Int63[54],
    symbol$32 = Base_Int63[55],
    land$0 = Base_Int63[56],
    lor$0 = Base_Int63[57],
    lxor$0 = Base_Int63[58],
    lnot$1 = Base_Int63[59],
    lsl$0 = Base_Int63[60],
    asr$0 = Base_Int63[61],
    round$1 = Base_Int63[62],
    round_towards_zero$1 = Base_Int63[63],
    round_down$1 = Base_Int63[64],
    round_up$1 = Base_Int63[65],
    round_nearest$1 = Base_Int63[66],
    abs$1 = Base_Int63[67],
    succ$1 = Base_Int63[68],
    pred$1 = Base_Int63[69],
    pow$1 = Base_Int63[70],
    bit_and$1 = Base_Int63[71],
    bit_or$1 = Base_Int63[72],
    bit_xor$1 = Base_Int63[73],
    bit_not$1 = Base_Int63[74],
    popcount$2 = Base_Int63[75],
    shift_left$1 = Base_Int63[76],
    shift_right$1 = Base_Int63[77],
    decr$1 = Base_Int63[78],
    incr$1 = Base_Int63[79],
    of_int32_exn$1 = Base_Int63[80],
    to_int32_exn$1 = Base_Int63[81],
    of_int64_exn$1 = Base_Int63[82],
    to_int64$1 = Base_Int63[83],
    of_nativeint_exn$1 = Base_Int63[84],
    to_nativeint_exn$1 = Base_Int63[85],
    of_float_unchecked$1 = Base_Int63[86],
    num_bits$1 = Base_Int63[87],
    max_value$1 = Base_Int63[88],
    min_value$1 = Base_Int63[89],
    lsr$0 = Base_Int63[90],
    shift_right_logical$1 = Base_Int63[91],
    ceil_pow2$1 = Base_Int63[92],
    floor_pow2$1 = Base_Int63[93],
    ceil_log2$1 = Base_Int63[94],
    is_pow2$1 = Base_Int63[95],
    clz$1 = Base_Int63[96],
    ctz$1 = Base_Int63[97],
    O$1 = Base_Int63[98],
    floor_log2$1 = Base_Int63[117],
    For_int63 =
      Make
       ([0,
         t_sexp_grammar$1,
         of_float$1,
         to_float$1,
         of_int_exn$1,
         to_int_exn$1,
         hash_fold_t$1,
         hash$1,
         t_of_sexp$1,
         sexp_of_t$1,
         of_string$1,
         to_string$1,
         symbol$18,
         symbol$19,
         symbol$20,
         symbol$21,
         symbol$22,
         symbol$23,
         equal$1,
         compare$1,
         min$1,
         max$1,
         ascending$1,
         descending$1,
         between$1,
         clamp_exn$1,
         clamp$1,
         comparator$1,
         pp$1,
         hashable$1,
         is_positive$1,
         is_non_negative$1,
         is_negative$1,
         is_non_positive$1,
         sign$1,
         compare_local$1,
         equal_local$1,
         invariant$1,
         Hex$1,
         Binary$1,
         of_string_opt$1,
         to_string_hum$1,
         zero$1,
         one$1,
         minus_one$1,
         symbol$24,
         symbol$25,
         symbol$26,
         symbol$27,
         neg$0,
         symbol$28,
         symbol$29,
         symbol$30,
         symbol$31,
         rem$1,
         symbol$32,
         land$0,
         lor$0,
         lxor$0,
         lnot$1,
         lsl$0,
         asr$0,
         round$1,
         round_towards_zero$1,
         round_down$1,
         round_up$1,
         round_nearest$1,
         abs$1,
         succ$1,
         pred$1,
         pow$1,
         bit_and$1,
         bit_or$1,
         bit_xor$1,
         bit_not$1,
         popcount$2,
         shift_left$1,
         shift_right$1,
         decr$1,
         incr$1,
         of_int32_exn$1,
         to_int32_exn$1,
         of_int64_exn$1,
         to_int64$1,
         of_nativeint_exn$1,
         to_nativeint_exn$1,
         of_float_unchecked$1,
         num_bits$1,
         max_value$1,
         min_value$1,
         lsr$0,
         shift_right_logical$1,
         ceil_pow2$1,
         floor_pow2$1,
         ceil_log2$1,
         floor_log2$1,
         is_pow2$1,
         clz$1,
         ctz$1,
         O$1,
         int63]),
    t_sexp_grammar$2 = Base_Int64[2],
    of_float$2 = Base_Int64[3],
    to_float$2 = Base_Int64[4],
    of_int_exn$2 = Base_Int64[5],
    to_int_exn$2 = Base_Int64[6],
    hash_fold_t$2 = Base_Int64[7],
    hash$2 = Base_Int64[8],
    t_of_sexp$2 = Base_Int64[9],
    sexp_of_t$2 = Base_Int64[10],
    of_string$2 = Base_Int64[11],
    to_string$2 = Base_Int64[12],
    equal$2 = Base_Int64[13],
    compare$2 = Base_Int64[14],
    min$2 = Base_Int64[15],
    max$2 = Base_Int64[16],
    ascending$2 = Base_Int64[17],
    descending$2 = Base_Int64[18],
    between$2 = Base_Int64[19],
    clamp_exn$2 = Base_Int64[20],
    clamp$2 = Base_Int64[21],
    comparator$2 = Base_Int64[22],
    pp$2 = Base_Int64[23],
    hashable$2 = Base_Int64[24],
    is_positive$2 = Base_Int64[25],
    is_non_negative$2 = Base_Int64[26],
    is_negative$2 = Base_Int64[27],
    is_non_positive$2 = Base_Int64[28],
    sign$2 = Base_Int64[29],
    compare_local$2 = Base_Int64[30],
    equal_local$2 = Base_Int64[31],
    invariant$2 = Base_Int64[32],
    Hex$2 = Base_Int64[33],
    Binary$2 = Base_Int64[34],
    of_string_opt$2 = Base_Int64[35],
    to_string_hum$2 = Base_Int64[36],
    one$2 = Base_Int64[37],
    minus_one$2 = Base_Int64[38],
    rem$2 = Base_Int64[39],
    round$2 = Base_Int64[40],
    round_towards_zero$2 = Base_Int64[41],
    round_down$2 = Base_Int64[42],
    round_up$2 = Base_Int64[43],
    round_nearest$2 = Base_Int64[44],
    succ$2 = Base_Int64[45],
    pred$2 = Base_Int64[46],
    pow$2 = Base_Int64[47],
    bit_and$2 = Base_Int64[48],
    bit_or$2 = Base_Int64[49],
    bit_xor$2 = Base_Int64[50],
    bit_not$2 = Base_Int64[51],
    popcount$3 = Base_Int64[52],
    shift_left$2 = Base_Int64[53],
    shift_right$2 = Base_Int64[54],
    decr$2 = Base_Int64[55],
    incr$2 = Base_Int64[56],
    of_int32_exn$2 = Base_Int64[57],
    to_int32_exn$2 = Base_Int64[58],
    of_int64_exn$2 = Base_Int64[59],
    to_int64$2 = Base_Int64[60],
    of_nativeint_exn$2 = Base_Int64[61],
    to_nativeint_exn$2 = Base_Int64[62],
    of_float_unchecked$2 = Base_Int64[63],
    num_bits$2 = Base_Int64[64],
    max_value$2 = Base_Int64[65],
    min_value$2 = Base_Int64[66],
    shift_right_logical$2 = Base_Int64[67],
    ceil_pow2$2 = Base_Int64[68],
    floor_pow2$2 = Base_Int64[69],
    ceil_log2$2 = Base_Int64[70],
    floor_log2$2 = Base_Int64[71],
    is_pow2$2 = Base_Int64[72],
    clz$2 = Base_Int64[73],
    ctz$2 = Base_Int64[74],
    O$2 = Base_Int64[75],
    symbol$33 = Base_Int64[76],
    lnot$2 = Base_Int64[77],
    abs$2 = Base_Int64[78],
    zero$2 = Base_Int64[79],
    symbol$34 = Base_Int64[80],
    symbol$35 = Base_Int64[81],
    symbol$36 = Base_Int64[82],
    For_int64 =
      Make
       ([0,
         t_sexp_grammar$2,
         of_float$2,
         to_float$2,
         of_int_exn$2,
         to_int_exn$2,
         hash_fold_t$2,
         hash$2,
         t_of_sexp$2,
         sexp_of_t$2,
         of_string$2,
         to_string$2,
         caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         caml_notequal,
         equal$2,
         compare$2,
         min$2,
         max$2,
         ascending$2,
         descending$2,
         between$2,
         clamp_exn$2,
         clamp$2,
         comparator$2,
         pp$2,
         hashable$2,
         is_positive$2,
         is_non_negative$2,
         is_negative$2,
         is_non_positive$2,
         sign$2,
         compare_local$2,
         equal_local$2,
         invariant$2,
         Hex$2,
         Binary$2,
         of_string_opt$2,
         to_string_hum$2,
         zero$2,
         one$2,
         minus_one$2,
         caml_int64_add,
         caml_int64_sub,
         caml_int64_mul,
         symbol$33,
         caml_int64_neg,
         caml_int64_neg,
         symbol$35,
         symbol$34,
         caml_int64_div,
         rem$2,
         symbol$36,
         caml_int64_and,
         caml_int64_or,
         caml_int64_xor,
         lnot$2,
         caml_int64_shift_left,
         caml_int64_shift_right,
         round$2,
         round_towards_zero$2,
         round_down$2,
         round_up$2,
         round_nearest$2,
         abs$2,
         succ$2,
         pred$2,
         pow$2,
         bit_and$2,
         bit_or$2,
         bit_xor$2,
         bit_not$2,
         popcount$3,
         shift_left$2,
         shift_right$2,
         decr$2,
         incr$2,
         of_int32_exn$2,
         to_int32_exn$2,
         of_int64_exn$2,
         to_int64$2,
         of_nativeint_exn$2,
         to_nativeint_exn$2,
         of_float_unchecked$2,
         num_bits$2,
         max_value$2,
         min_value$2,
         caml_int64_shift_right_unsigne,
         shift_right_logical$2,
         ceil_pow2$2,
         floor_pow2$2,
         ceil_log2$2,
         floor_log2$2,
         is_pow2$2,
         clz$2,
         ctz$2,
         [0,
          caml_int64_add,
          caml_int64_sub,
          caml_int64_mul,
          caml_int64_div,
          caml_int64_neg,
          O$2[1],
          caml_greaterequal,
          caml_lessequal,
          caml_equal,
          caml_greaterthan,
          caml_lessthan,
          caml_notequal,
          O$2[3],
          caml_int64_neg,
          O$2[4],
          O$2[5],
          O$2[6],
          O$2[7],
          caml_int64_and,
          caml_int64_or,
          caml_int64_xor,
          O$2[2],
          caml_int64_shift_left,
          caml_int64_shift_right,
          caml_int64_shift_right_unsigne],
         int64]),
    t_sexp_grammar$3 = Base_Nativeint[2],
    of_float$3 = Base_Nativeint[3],
    to_float$3 = Base_Nativeint[4],
    of_int_exn$3 = Base_Nativeint[5],
    to_int_exn$3 = Base_Nativeint[6],
    hash_fold_t$3 = Base_Nativeint[7],
    hash$3 = Base_Nativeint[8],
    t_of_sexp$3 = Base_Nativeint[9],
    sexp_of_t$3 = Base_Nativeint[10],
    of_string$3 = Base_Nativeint[11],
    to_string$3 = Base_Nativeint[12],
    symbol$37 = Base_Nativeint[13],
    symbol$38 = Base_Nativeint[14],
    symbol$39 = Base_Nativeint[15],
    symbol$40 = Base_Nativeint[16],
    symbol$41 = Base_Nativeint[17],
    symbol$42 = Base_Nativeint[18],
    equal$3 = Base_Nativeint[19],
    compare$3 = Base_Nativeint[20],
    min$3 = Base_Nativeint[21],
    max$3 = Base_Nativeint[22],
    ascending$3 = Base_Nativeint[23],
    descending$3 = Base_Nativeint[24],
    between$3 = Base_Nativeint[25],
    clamp_exn$3 = Base_Nativeint[26],
    clamp$3 = Base_Nativeint[27],
    comparator$3 = Base_Nativeint[28],
    pp$3 = Base_Nativeint[29],
    hashable$3 = Base_Nativeint[30],
    is_positive$3 = Base_Nativeint[31],
    is_non_negative$3 = Base_Nativeint[32],
    is_negative$3 = Base_Nativeint[33],
    is_non_positive$3 = Base_Nativeint[34],
    sign$3 = Base_Nativeint[35],
    compare_local$3 = Base_Nativeint[36],
    equal_local$3 = Base_Nativeint[37],
    invariant$3 = Base_Nativeint[38],
    Hex$3 = Base_Nativeint[39],
    Binary$3 = Base_Nativeint[40],
    of_string_opt$3 = Base_Nativeint[41],
    to_string_hum$3 = Base_Nativeint[42],
    zero$3 = Base_Nativeint[43],
    one$3 = Base_Nativeint[44],
    minus_one$3 = Base_Nativeint[45],
    symbol$43 = Base_Nativeint[46],
    symbol$44 = Base_Nativeint[47],
    symbol$45 = Base_Nativeint[48],
    symbol$46 = Base_Nativeint[49],
    neg$1 = Base_Nativeint[50],
    symbol$47 = Base_Nativeint[51],
    symbol$48 = Base_Nativeint[52],
    symbol$49 = Base_Nativeint[53],
    symbol$50 = Base_Nativeint[54],
    rem$3 = Base_Nativeint[55],
    symbol$51 = Base_Nativeint[56],
    land$1 = Base_Nativeint[57],
    lor$1 = Base_Nativeint[58],
    lxor$1 = Base_Nativeint[59],
    lnot$3 = Base_Nativeint[60],
    lsl$1 = Base_Nativeint[61],
    asr$1 = Base_Nativeint[62],
    round$3 = Base_Nativeint[63],
    round_towards_zero$3 = Base_Nativeint[64],
    round_down$3 = Base_Nativeint[65],
    round_up$3 = Base_Nativeint[66],
    round_nearest$3 = Base_Nativeint[67],
    abs$3 = Base_Nativeint[68],
    succ$3 = Base_Nativeint[69],
    pred$3 = Base_Nativeint[70],
    pow$3 = Base_Nativeint[71],
    bit_and$3 = Base_Nativeint[72],
    bit_or$3 = Base_Nativeint[73],
    bit_xor$3 = Base_Nativeint[74],
    bit_not$3 = Base_Nativeint[75],
    popcount$4 = Base_Nativeint[76],
    shift_left$3 = Base_Nativeint[77],
    shift_right$3 = Base_Nativeint[78],
    decr$3 = Base_Nativeint[79],
    incr$3 = Base_Nativeint[80],
    of_int32_exn$3 = Base_Nativeint[81],
    to_int32_exn$3 = Base_Nativeint[82],
    of_int64_exn$3 = Base_Nativeint[83],
    to_int64$3 = Base_Nativeint[84],
    of_nativeint_exn$3 = Base_Nativeint[85],
    to_nativeint_exn$3 = Base_Nativeint[86],
    of_float_unchecked$3 = Base_Nativeint[87],
    num_bits$3 = Base_Nativeint[88],
    max_value$3 = Base_Nativeint[89],
    min_value$3 = Base_Nativeint[90],
    lsr$1 = Base_Nativeint[91],
    shift_right_logical$3 = Base_Nativeint[92],
    ceil_pow2$3 = Base_Nativeint[93],
    floor_pow2$3 = Base_Nativeint[94],
    ceil_log2$3 = Base_Nativeint[95],
    floor_log2$3 = Base_Nativeint[96],
    is_pow2$3 = Base_Nativeint[97],
    clz$3 = Base_Nativeint[98],
    ctz$3 = Base_Nativeint[99],
    O$3 = Base_Nativeint[100],
    For_nativeint =
      Make
       ([0,
         t_sexp_grammar$3,
         of_float$3,
         to_float$3,
         of_int_exn$3,
         to_int_exn$3,
         hash_fold_t$3,
         hash$3,
         t_of_sexp$3,
         sexp_of_t$3,
         of_string$3,
         to_string$3,
         symbol$37,
         symbol$38,
         symbol$39,
         symbol$40,
         symbol$41,
         symbol$42,
         equal$3,
         compare$3,
         min$3,
         max$3,
         ascending$3,
         descending$3,
         between$3,
         clamp_exn$3,
         clamp$3,
         comparator$3,
         pp$3,
         hashable$3,
         is_positive$3,
         is_non_negative$3,
         is_negative$3,
         is_non_positive$3,
         sign$3,
         compare_local$3,
         equal_local$3,
         invariant$3,
         Hex$3,
         Binary$3,
         of_string_opt$3,
         to_string_hum$3,
         zero$3,
         one$3,
         minus_one$3,
         symbol$43,
         symbol$44,
         symbol$45,
         symbol$46,
         neg$1,
         symbol$47,
         symbol$48,
         symbol$49,
         symbol$50,
         rem$3,
         symbol$51,
         land$1,
         lor$1,
         lxor$1,
         lnot$3,
         lsl$1,
         asr$1,
         round$3,
         round_towards_zero$3,
         round_down$3,
         round_up$3,
         round_nearest$3,
         abs$3,
         succ$3,
         pred$3,
         pow$3,
         bit_and$3,
         bit_or$3,
         bit_xor$3,
         bit_not$3,
         popcount$4,
         shift_left$3,
         shift_right$3,
         decr$3,
         incr$3,
         of_int32_exn$3,
         to_int32_exn$3,
         of_int64_exn$3,
         to_int64$3,
         of_nativeint_exn$3,
         to_nativeint_exn$3,
         of_float_unchecked$3,
         num_bits$3,
         max_value$3,
         min_value$3,
         lsr$1,
         shift_right_logical$3,
         ceil_pow2$3,
         floor_pow2$3,
         ceil_log2$3,
         floor_log2$3,
         is_pow2$3,
         clz$3,
         ctz$3,
         O$3,
         nativeint]),
    int$1 = For_int[1],
    int32$0 = For_int32[1],
    int63$0 = For_int63[1],
    int64$1 = For_int64[1],
    nativeint$0 = For_nativeint[1],
    State = [0, create, of_int, perturb, copy, split];
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   var
    Splittable_random =
      [0,
       create,
       of_int,
       perturb,
       copy,
       split,
       State,
       bool,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       unit_float,
       [0, int$1, int32$0, int63$0, int64$1, nativeint$0]];
   runtime.caml_register_global(40, Splittable_random, "Splittable_random");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzcGxpdHRhYmxlX3JhbmRvbS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiaW50NjQkMCIsImdvbGRlbl9nYW1tYSIsInBvcGNvdW50Iiwib2ZfaW50Iiwic2VlZCIsImNvcHkiLCJvZGRfZ2FtbWEiLCJtaXhfYml0cyIsInoiLCJuIiwibWl4NjQiLCJ6JDAiLCJ6JDEiLCJuZXh0X3NlZWQiLCJ0IiwibmV4dCIsIm9mX3NlZWRfYW5kX2dhbW1hIiwiZ2FtbWEiLCJzZWVkJDAiLCJyYW5kb21faW50NjQiLCJyYW5kb21fc3RhdGUiLCJjcmVhdGUiLCJzcGxpdCIsIm5leHRfaW50NjQiLCJwZXJ0dXJiIiwic2FsdCIsImJvb2wiLCJzdGF0ZSIsIngiLCJpbnQ2NCIsImxvIiwiaGkiLCJyZW1haW5kZXJfbWF4aW11bSIsImRyYXckMCIsInJlbWFpbmRlciIsImRyYXdfbWF4aW11bSIsImRyYXciLCJpbnQkMCIsImxvJDAiLCJoaSQwIiwiaW50MzIiLCJuYXRpdmVpbnQiLCJpbnQ2MyIsImRvdWJsZV91bHAiLCJ1bml0X2Zsb2F0X2Zyb21faW50NjQiLCJ1bml0X2Zsb2F0IiwiZmxvYXQkMCIsInJhbmdlIiwibWlkIiwiZiIsImJpdHNfdG9fcmVwcmVzZW50IiwidCQwIiwibG9nX3VuaWZvcm0iLCJtaW5fYml0cyIsIm1heF9iaXRzIiwiYml0cyIsInRfc2V4cF9ncmFtbWFyIiwib2ZfZmxvYXQiLCJ0b19mbG9hdCIsIm9mX2ludF9leG4iLCJ0b19pbnRfZXhuIiwiaGFzaF9mb2xkX3QiLCJoYXNoIiwidF9vZl9zZXhwIiwic2V4cF9vZl90Iiwib2Zfc3RyaW5nIiwidG9fc3RyaW5nIiwiZXF1YWwiLCJjb21wYXJlIiwibWluIiwibWF4IiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImJldHdlZW4iLCJjbGFtcF9leG4iLCJjbGFtcCIsImNvbXBhcmF0b3IiLCJwcCIsImhhc2hhYmxlIiwiaXNfcG9zaXRpdmUiLCJpc19ub25fbmVnYXRpdmUiLCJpc19uZWdhdGl2ZSIsImlzX25vbl9wb3NpdGl2ZSIsInNpZ24iLCJjb21wYXJlX2xvY2FsIiwiZXF1YWxfbG9jYWwiLCJpbnZhcmlhbnQiLCJvZl9zdHJpbmdfb3B0IiwidG9fc3RyaW5nX2h1bSIsIm9uZSIsIm1pbnVzX29uZSIsInJlbSIsInJvdW5kIiwicm91bmRfdG93YXJkc196ZXJvIiwicm91bmRfZG93biIsInJvdW5kX3VwIiwicm91bmRfbmVhcmVzdCIsInN1Y2MiLCJwcmVkIiwicG93IiwiYml0X2FuZCIsImJpdF9vciIsImJpdF94b3IiLCJiaXRfbm90IiwicG9wY291bnQkMCIsInNoaWZ0X2xlZnQiLCJzaGlmdF9yaWdodCIsImRlY3IiLCJpbmNyIiwib2ZfaW50MzJfZXhuIiwidG9faW50MzJfZXhuIiwib2ZfaW50NjRfZXhuIiwidG9faW50NjQiLCJvZl9uYXRpdmVpbnRfZXhuIiwidG9fbmF0aXZlaW50X2V4biIsIm9mX2Zsb2F0X3VuY2hlY2tlZCIsIm51bV9iaXRzIiwibWF4X3ZhbHVlIiwibWluX3ZhbHVlIiwic2hpZnRfcmlnaHRfbG9naWNhbCIsImNlaWxfcG93MiIsImZsb29yX3BvdzIiLCJjZWlsX2xvZzIiLCJmbG9vcl9sb2cyIiwiaXNfcG93MiIsImNseiIsImN0eiIsInN5bWJvbCIsImxub3QiLCJhYnMiLCJ6ZXJvIiwic3ltYm9sJDAiLCJzeW1ib2wkMSIsInN5bWJvbCQyIiwidF9zZXhwX2dyYW1tYXIkMiIsIm9mX2Zsb2F0JDIiLCJ0b19mbG9hdCQyIiwib2ZfaW50X2V4biQyIiwidG9faW50X2V4biQyIiwiaGFzaF9mb2xkX3QkMiIsImhhc2gkMiIsInRfb2Zfc2V4cCQyIiwic2V4cF9vZl90JDIiLCJvZl9zdHJpbmckMiIsInRvX3N0cmluZyQyIiwiZXF1YWwkMiIsImNvbXBhcmUkMiIsIm1pbiQyIiwibWF4JDIiLCJhc2NlbmRpbmckMiIsImRlc2NlbmRpbmckMiIsImJldHdlZW4kMiIsImNsYW1wX2V4biQyIiwiY2xhbXAkMiIsImNvbXBhcmF0b3IkMiIsInBwJDIiLCJoYXNoYWJsZSQyIiwiaXNfcG9zaXRpdmUkMiIsImlzX25vbl9uZWdhdGl2ZSQyIiwiaXNfbmVnYXRpdmUkMiIsImlzX25vbl9wb3NpdGl2ZSQyIiwic2lnbiQyIiwiY29tcGFyZV9sb2NhbCQyIiwiZXF1YWxfbG9jYWwkMiIsImludmFyaWFudCQyIiwib2Zfc3RyaW5nX29wdCQyIiwidG9fc3RyaW5nX2h1bSQyIiwib25lJDIiLCJtaW51c19vbmUkMiIsInJlbSQyIiwicm91bmQkMiIsInJvdW5kX3Rvd2FyZHNfemVybyQyIiwicm91bmRfZG93biQyIiwicm91bmRfdXAkMiIsInJvdW5kX25lYXJlc3QkMiIsInN1Y2MkMiIsInByZWQkMiIsInBvdyQyIiwiYml0X2FuZCQyIiwiYml0X29yJDIiLCJiaXRfeG9yJDIiLCJiaXRfbm90JDIiLCJwb3Bjb3VudCQzIiwic2hpZnRfbGVmdCQyIiwic2hpZnRfcmlnaHQkMiIsImRlY3IkMiIsImluY3IkMiIsIm9mX2ludDMyX2V4biQyIiwidG9faW50MzJfZXhuJDIiLCJvZl9pbnQ2NF9leG4kMiIsInRvX2ludDY0JDIiLCJvZl9uYXRpdmVpbnRfZXhuJDIiLCJ0b19uYXRpdmVpbnRfZXhuJDIiLCJvZl9mbG9hdF91bmNoZWNrZWQkMiIsIm51bV9iaXRzJDIiLCJtYXhfdmFsdWUkMiIsIm1pbl92YWx1ZSQyIiwic2hpZnRfcmlnaHRfbG9naWNhbCQyIiwiY2VpbF9wb3cyJDIiLCJmbG9vcl9wb3cyJDIiLCJjZWlsX2xvZzIkMiIsImZsb29yX2xvZzIkMiIsImlzX3BvdzIkMiIsImNseiQyIiwiY3R6JDIiLCJzeW1ib2wkMzMiLCJsbm90JDIiLCJhYnMkMiIsInplcm8kMiIsInN5bWJvbCQzNCIsInN5bWJvbCQzNSIsInN5bWJvbCQzNiIsImludCQxIiwiaW50MzIkMCIsImludDYzJDAiLCJpbnQ2NCQxIiwibmF0aXZlaW50JDAiXSwic291cmNlcyI6WyIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvc3BsaXR0YWJsZV9yYW5kb20vc3BsaXR0YWJsZV9yYW5kb20ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvb2NhbWwvaW50NjQubWxpIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lBdVFNQTtJQW5PRkM7Ozs7Ozs7Ozs7Ozs7Ozs7SUFWQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQVdBQyxPQUFPQyxNQUFPLFdBQVMsb0JBQWhCQSxPQURQSCxjQUNvRTtZQUNwRUk7UUFBT0QsaUJBQU1FO0lBQWMsV0FBcEJGLE1BQU1FOztZQUNiQyxTQUFTQyxHQUFFQztJQUFJLE9BQUEsZUFBTkQsR0FBYSwrQkFBYkEsR0FBRUM7R0FBb0I7WUFFL0JDLE1BQU1GO0lBQ1I7S0FBSUcsTUFBSSxlQUhOSixTQUVNQztLQUVKSSxNQUFJLGVBSk5MLFNBR0VJO0lBRUosT0FMRUosU0FJRUs7R0FDUztZQTZCWEMsVUFBVUM7SUFDRCxJQUFQQyxPQUFPLGVBRENELE1BQUFBO0lBQUFBLE9BQ1JDO0lBRUosT0FGSUE7R0FFQTtZQUdGQyxrQkFBbUJaLE1BQU1hO0lBQzNCO0tBQUlDLFNBdkNGUixNQXNDbUJOO0tBL0JqQkksSUFBSSxlQVRORCxTQXdDeUJVO0tBOUJ2Qk4sTUFBSSxlQVZOSixTQVNFQztLQU1BSSxNQUFJLGNBZk5MLFNBVUVJO0tBTUFGO09BQUk7U0E3Qk5QO1NBNkJlLGVBRGJVLEtBQ3FCLCtCQURyQkE7S0EyQkFOLGtCQTFCQUcsSUFEQUcsTUFRbUIsZUFSbkJBO0lBNEJKLFdBRklNLFFBQ0FaO0dBQ2U7WUFHakJhLGFBQWFDO0lBQ2YsT0FBQTs7YUFEZUE7OztHQUNxRDtZQUdsRUMsT0FBT0Q7SUFDVCxJQUFJaEIsT0FMRmUsYUFJT0MsZUFFTEgsUUFORkUsYUFJT0M7SUFHVCxPQWJFSixrQkFXRVosTUFDQWE7R0FDMEI7WUFHNUJLLE1BQU1SO0lBQ1IsSUFBSVYsT0F2QkZTLFVBc0JNQyxJQUVKRyxRQXhCRkosVUFzQk1DO0lBR1IsT0FuQkVFLGtCQWlCRVosTUFDQWE7R0FDMEI7WUFHNUJNLFdBQVdULEdBQUksT0E1RGZKLE1BZ0NBRyxVQTRCV0MsSUFBdUI7WUFJbENVLFFBQVFWLEdBQUVXO0lBQ1o7S0FBb0IsT0FqRWxCZixNQWlFd0Isb0JBRGRlO0tBQ1JWLE9BQU8sZUFEREQ7SUFBQUEsT0FDTkM7O0dBQ1U7WUFHWlcsS0FBS0M7SUFBZSxJQXJGYkMsSUE0RVBMLFdBU0tJO0lBckZNLE9BQUEsV0FBQSxjQUFKQyxTQUFBQTtHQXFGK0I7WUFtQ3RDQyxNQWlCRUYsT0FBT0csSUFBSUM7SUFDYixHQUFHLGlCQURNRCxJQUFJQzs7d0RBQUFBO3dEQUFKRDs7Ozs7O0tBRUo7O0lBQ00sSUFkb0JFLG9CQWNwQixlQUhFRCxJQUFKRDtJQUlOLEdBQUEsV0FmNEJFOztLQWdCMUIsT0FBQSxlQUFBLGVBbEVMVCxXQTZERUksZUFBT0c7O0lBTUQsR0FBQSxrQkFqQnVCRTtLQUMvQjtNQUFBO09BQUE7T0FyQ3VCQyxTQXFDWixlQW5EWFYsV0E2REVJO09BVDZCLE9BQUEsMkJBRkFLO09BcENGRSxZQXNDYiwyQkF0Q09EO09BQWlCRTtNQXVDckM7UUFyQ0w7VUFBQSxlQUZ5QkYsUUFBTUM7VUFFWCxlQUZzQkMsY0FvQ1RIO09Ba0IxQixPQUFBLGVBdER3QkUsV0ErQ3BCSjs7O0tBZFQ7TUFBVyxJQUFQTSxPQS9DSmIsV0E2REVJO01BYmUsR0FBZCxlQWFNRyxJQWRMTSxTQUNhLGVBRGJBLE1BY1NMLEtBYm9CLE9BRDdCSzs7R0FzQnNCO1lBRzFCQyxNQUFJVixPQUFPRyxJQUFJQztJQUNqQixJQUFJTyxPQUFLLG9CQURJUixLQUVUUyxPQUFLLG9CQUZRUjtJQUlFLE9BQUEsb0JBaENqQkYsTUE0QklGLE9BQ0ZXLE1BQ0FDO0dBRW9DO1lBR3RDQyxNQUFNYixPQUFPRyxJQUFJQztJQUNuQixJQUFJTyxPQUFLLG9CQURNUixLQUVYUyxPQUFLLG9CQUZVUjtJQUluQixPQUFBLG9CQXZDRUYsTUFtQ01GLE9BQ0pXLE1BQ0FDO0dBRXNDO1lBR3hDRSxVQUFVZCxPQUFPRyxJQUFJQztJQUN2QixJQUFJTyxPQUFLLG9CQURVUixLQUVmUyxPQUFLLG9CQUZjUjtJQUl2QixPQUFBLG9CQTlDRUYsTUEwQ1VGLE9BQ1JXLE1BQ0FDO0dBRTBDO1lBRzVDRyxNQUFNZixPQUFPRyxJQUFJQztJQUNuQjtLQUFJTyxPQUFLLDJCQURNUjtLQUVYUyxPQUFLLDJCQUZVUjtLQUlFLE9BckRuQkYsTUFpRE1GLE9BQ0pXLE1BQ0FDO0lBRWlCLE9BQUE7R0FBcUI7R0FHM0IsSUFBYkksYUFBYTtZQWViQyxzQkFBc0JmO0lBQVE7O09BQUEsMEJBQWUsK0JBQXZCQTtJQWZULE9BQUEsNEJBQWJjO0dBZXlFO1lBU3pFRSxXQUFXbEI7SUFBUSxPQVRuQmlCLHNCQW5IQXJCLFdBNEhXSTtHQUFnRDtZQVUzRG1CLFFBa0JFbkIsT0FBT1csTUFBSUM7SUFDYjtLQUFRLE9BQUEsMkJBRENEO0tBQ0QsY0FBc0IsMkJBRGpCQzs7O3dEQUFBQTt3REFBSkQ7Ozs7OztLQUdQOztPQUhXQyxPQUFKRDs7d0RBQUlDO3dEQUFKRDs7Ozs7O0tBS0o7O1FBdEJxQlIsS0FpQmpCUSxNQWpCcUJQLEtBaUJqQlE7SUFoQmI7S0FBWSxJQUFSUSxRQUFRLHNCQURrQmhCLElBQUpEO0tBRXZCLEdBQUEsMkJBRENpQjtNQUVRLElBQUEsT0FkWkYsV0E0QkVsQixRQWRTLE9BQUEsNEJBRlBvQjtNQUVPLE9BQUEsc0JBSGVqQjs7S0FPZDtNQUFBLE9BQUEsc0JBUGtCQyxJQUFKRDtNQUFBa0IsTUFPZDtLQUNQLEdBdElMdEIsS0ErSUVDLFlBakI0QkksS0FBSmlCLGNBQUFsQixLQUFBa0I7O0dBdUJBOzs7S0FHOUJDOztRQUNFLHVCQUNVLE9BaERSTCxzQkErQ0U1QyxTQUNpQztPQUFBOzs7Ozs7Ozs7O1VBRnZDaUQ7OzthQWVRQyxrQkFBa0JwQztLQUNwQixLQUFPLGtCQURhQTtNQUNwQixNQUFBO0tBQ1EsSUFBSnFDLFVBRmdCckMsSUFHaEJMO0tBR0Y7TUFGSSxLQUFBLGtCQUZGMEMsdUJBQ0ExQztNQURBMEMsU0FHRyxrQkFISEE7TUFJRix5QkFIRTFDOztJQUtGO2FBOENBMkMsWUFBWXpCLE9BQU9HLElBQUlDO0tBQ3pCO01BQUlzQixXQXZERkgsa0JBc0RtQnBCO01BRWpCd0IsV0F4REZKLGtCQXNEdUJuQjtNQWJHd0IsT0FqSjlCbEIsTUE4SmdCVixPQUNWMEIsVUFDQUM7TUFmaUMsT0FBQSx5QkFBVEM7TUFBUyxPQUFBO01Bb0IvQixPQUFBLFdBQW1DLGtCQVBoQnhCO0tBM0J0QixHQUFBLHlCQWN5QndCOzs7TUFkbUI7T0FBQSxPQUFBLHlCQWNuQkE7Y0FkbUI7S0FpQ3pDLFdBQUEsV0FBbUMsa0JBTnBCekI7S0FPZixPQUFBLG1CQVBRSDtJQU9rQztJQWhFOUMsV0F5REF5Qjs7O0lBb0JFSTtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQzs7O0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDOztJQVVOQztJQVVBQztJQUNBQztJQUVBQztJQUNBQztJQUNBQztJQUNBQzs0Qjs0Qjs0Qjs7NEI7NEI7NEI7O3NCOzs0Qjs0Qjs0Qjs0Qjs0Qjs0Qjs7c0I7OzRCO0dBbkNxQjs7OzRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRCOzRCOzRCOzRCOzRCOzRCOztzQjtzQjs7NEI7NEI7NEI7NEI7NkI7NkI7NkI7R0FxQ1Y7Ozs7U0E1Qkw3RTtTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQzs4Qjs7Ozs7O1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDOzs7U0FBQUM7U0FBQUM7U0F1Qk4wQztTQXZCTXpDO1NBQUFDOzs7O1NBVU5xQzs7O1NBZUFLO1NBREFEOztTQXhCTXhDO1NBMEJOMEM7Ozs7U0FOQUw7OztTQXBCTXBDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBcUJOaUM7U0FyQk1oQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQzs7U0FBQUM7U0FBQUM7U0FBQUM7U0FBQUM7U0FBQUM7U0FBQUM7U0FBQUM7U0FBQUM7O1NBbExOekY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FPQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FjQUU7SUN4TEk0RjtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQzs7O0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDOztJQVdOQztJQVVBQztJQUNBQztJQUVBQztJQUNBQztJQUNBQztJQUNBQzs7OztTQTNCTTdFO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDOzs7Ozs7O1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDOzs7U0FBQUM7U0FBQUM7U0F3Qk4wQztTQXhCTXpDO1NBQUFDOzs7O1NBV05xQzs7O1NBZUFLO1NBREFEOztTQXpCTXhDO1NBMkJOMEM7Ozs7U0FOQUw7OztTQXJCTXBDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBc0JOaUM7U0F0Qk1oQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQzs7U0FBQUM7U0FBQUM7U0FBQUM7U0FBQUM7U0FBQUM7U0FBQUM7U0FBQUM7U0FBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTRHVJSi9LOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBMENBWTtJQXlMRTJLO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBR1MsWUFsU1huTSxRQXBEQWxCLFFBb0VBcUIsU0FuRUFuQixNQXlEQWlCOzs7OztPQU5BRDtPQXBEQWxCO09Bb0VBcUI7T0FuRUFuQjtPQXlEQWlCOztPQWVBSTtPQStEQVc7T0FPQUc7T0FjQUU7T0FqREFiO09BMENBWTtPQWdEQUs7T0FWQUQ7V0FtSkV1SyxPQUNBQyxTQUNBQyxTQUNBQyxTQUNBQzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiogVGhpcyBtb2R1bGUgaW1wbGVtZW50cyBcIkZhc3QgU3BsaXR0YWJsZSBQc2V1ZG9yYW5kb20gTnVtYmVyIEdlbmVyYXRvcnNcIiBieSBTdGVlbGUgZXQuXG4gICAgYWwuICgxKS4gIFRoZSBwYXBlcidzIGFsZ29yaXRobSBwcm92aWRlcyBkZWNlbnQgcmFuZG9tbmVzcyBmb3IgbW9zdCBwdXJwb3NlcywgYnV0XG4gICAgc2FjcmlmaWNlcyBjcnlwdG9ncmFwaGljLXF1YWxpdHkgcmFuZG9tbmVzcyBpbiBmYXZvciBvZiBwZXJmb3JtYW5jZS4gIFRoZSBvcmlnaW5hbFxuICAgIGltcGxlbWVudGF0aW9uIHdhcyB0ZXN0ZWQgd2l0aCBEaWVIYXJkZXIgYW5kIEJpZ0NydXNoOyBzZWUgdGhlIHBhcGVyIGZvciBkZXRhaWxzLlxuXG4gICAgT3VyIGltcGxlbWVudGF0aW9uIGlzIGEgcG9ydCBmcm9tIEphdmEgdG8gT0NhbWwgb2YgdGhlIHBhcGVyJ3MgYWxnb3JpdGhtLiAgT3RoZXIgdGhhblxuICAgIHRoZSBjaG9pY2Ugb2YgaW5pdGlhbCBzZWVkIGZvciBbY3JlYXRlXSwgb3VyIHBvcnQgc2hvdWxkIGJlIGZhaXRoZnVsLiAgV2UgaGF2ZSBub3RcbiAgICByZS1ydW4gdGhlIERpZUhhcmRlciBvciBCaWdDcnVzaCB0ZXN0cyBvbiBvdXIgaW1wbGVtZW50YXRpb24uICBPdXIgcG9ydCBpcyBhbHNvIG5vdCBhc1xuICAgIHBlcmZvcm1hbnQgYXMgdGhlIG9yaWdpbmFsOyB0d28gZmFjdG9ycyB0aGF0IGh1cnQgdXMgYXJlIGJveGVkIFtpbnQ2NF0gdmFsdWVzIGFuZCBsYWNrXG4gICAgb2YgYSBQT1BDTlQgcHJpbWl0aXZlLlxuXG4gICAgKDEpIGh0dHA6Ly8yMDE0LnNwbGFzaGNvbi5vcmcvZXZlbnQvb29wc2xhMjAxNC1mYXN0LXNwbGl0dGFibGUtcHNldWRvcmFuZG9tLW51bWJlci1nZW5lcmF0b3JzXG4gICAgKGFsc28gbWlycm9yZWQgYXQgaHR0cDovL2dlZS5jcy5vc3dlZ28uZWR1L2RsL3BhcGVycy9vb3BzbGExNC5wZGYpXG5cbiAgICBCZXdhcmUgd2hlbiBpbXBsZW1lbnRpbmcgdGhpcyBpbnRlcmZhY2U7IGl0IGlzIGVhc3kgdG8gaW1wbGVtZW50IGEgW3NwbGl0XSBvcGVyYXRpb25cbiAgICB3aG9zZSBvdXRwdXQgaXMgbm90IGFzIFwiaW5kZXBlbmRlbnRcIiBhcyBpdCBzZWVtcyAoMikuICBUaGlzIGJ1ZyBjYXVzZWQgcHJvYmxlbXMgZm9yXG4gICAgSGFza2VsbCdzIFF1aWNrY2hlY2sgbGlicmFyeSBmb3IgYSBsb25nIHRpbWUuXG5cbiAgICAoMikgU2NoYWF0aHVuLCBcIkV2YWx1YXRpb24gb2Ygc3BsaXR0YWJsZSBwc2V1ZG8tcmFuZG9tIGdlbmVyYXRvcnNcIiwgSkZQIDIwMTUuXG4gICAgaHR0cDovL3d3dy5oZy5zY2hhYXRodW4ubmV0L3Jlc2VhcmNoL1BhcGVycy9oZ3MyMDE1amZwLnBkZlxuKilcblxub3BlbiEgQmFzZVxub3BlbiBJbnQ2NC5PXG5cbmxldCBpc19vZGQgeCA9IHggbG9yIDFMID0geFxubGV0IHBvcGNvdW50ID0gSW50NjQucG9wY291bnRcblxudHlwZSB0ID1cbiAgeyBtdXRhYmxlIHNlZWQgOiBpbnQ2NFxuICA7IG9kZF9nYW1tYSA6IGludDY0XG4gIH1cblxuKCogQWxpYXMgdXNlZCBiZWxvdyB3aGVuIFt0XSBpcyBzaGFkb3dlZC4gKilcbnR5cGUgc3RhdGUgPSB0XG5cbmxldCBnb2xkZW5fZ2FtbWEgPSAweDllMzdfNzliOV83ZjRhXzdjMTVMXG5sZXQgb2ZfaW50IHNlZWQgPSB7IHNlZWQgPSBJbnQ2NC5vZl9pbnQgc2VlZDsgb2RkX2dhbW1hID0gZ29sZGVuX2dhbW1hIH1cbmxldCBjb3B5IHsgc2VlZDsgb2RkX2dhbW1hIH0gPSB7IHNlZWQ7IG9kZF9nYW1tYSB9XG5sZXQgbWl4X2JpdHMgeiBuID0geiBseG9yICh6IGxzciBuKVxuXG5sZXQgbWl4NjQgeiA9XG4gIGxldCB6ID0gbWl4X2JpdHMgeiAzMyAqIDB4ZmY1MV9hZmQ3X2VkNTVfOGNjZEwgaW5cbiAgbGV0IHogPSBtaXhfYml0cyB6IDMzICogMHhjNGNlX2I5ZmVfMWE4NV9lYzUzTCBpblxuICBtaXhfYml0cyB6IDMzXG47O1xuXG5sZXQgbWl4NjRfdmFyaWFudDEzIHogPVxuICBsZXQgeiA9IG1peF9iaXRzIHogMzAgKiAweGJmNThfNDc2ZF8xY2U0X2U1YjlMIGluXG4gIGxldCB6ID0gbWl4X2JpdHMgeiAyNyAqIDB4OTRkMF80OWJiXzEzMzFfMTFlYkwgaW5cbiAgbWl4X2JpdHMgeiAzMVxuOztcblxubGV0IG1peF9vZGRfZ2FtbWEgeiA9XG4gIGxldCB6ID0gbWl4NjRfdmFyaWFudDEzIHogbG9yIDFMIGluXG4gIGxldCBuID0gcG9wY291bnQgKHogbHhvciAoeiBsc3IgMSkpIGluXG4gICgqIFRoZSBvcmlnaW5hbCBwYXBlciB1c2VzIFs+PV0gaW4gdGhlIGNvbmRpdGlvbmFsIGltbWVkaWF0ZWx5IGJlbG93OyBob3dldmVyIHRoaXMgaXNcbiAgICAgYSB0eXBvLCBhbmQgd2UgY29ycmVjdCBpdCBieSB1c2luZyBbPF0uIFRoaXMgd2FzIGZpeGVkIGluIHJlc3BvbnNlIHRvIFsxXSBhbmQgWzJdLlxuXG4gICAgIFsxXSBodHRwczovL2dpdGh1Yi5jb20vamFuZXN0cmVldC9zcGxpdHRhYmxlX3JhbmRvbS9pc3N1ZXMvMVxuICAgICBbMl0gaHR0cDovL3d3dy5wY2ctcmFuZG9tLm9yZy9wb3N0cy9idWdzLWluLXNwbGl0bWl4Lmh0bWxcbiAgKilcbiAgaWYgSW50LiggPCApIG4gMjQgdGhlbiB6IGx4b3IgMHhhYWFhX2FhYWFfYWFhYV9hYWFhTCBlbHNlIHpcbjs7XG5cbmxldCV0ZXN0X3VuaXQgXCJvZGQgZ2FtbWFcIiA9XG4gIGZvciBpbnB1dCA9IC0xXzAwMF8wMDAgdG8gMV8wMDBfMDAwIGRvXG4gICAgbGV0IG91dHB1dCA9IG1peF9vZGRfZ2FtbWEgKEludDY0Lm9mX2ludCBpbnB1dCkgaW5cbiAgICBpZiBub3QgKGlzX29kZCBvdXRwdXQpXG4gICAgdGhlbiBFcnJvci5yYWlzZV9zIFslbWVzc2FnZSBcImdhbW1hIHZhbHVlIGlzIG5vdCBvZGRcIiAoaW5wdXQgOiBpbnQpIChvdXRwdXQgOiBpbnQ2NCldXG4gIGRvbmVcbjs7XG5cbmxldCBuZXh0X3NlZWQgdCA9XG4gIGxldCBuZXh0ID0gdC5zZWVkICsgdC5vZGRfZ2FtbWEgaW5cbiAgdC5zZWVkIDwtIG5leHQ7XG4gIG5leHRcbjs7XG5cbmxldCBvZl9zZWVkX2FuZF9nYW1tYSB+c2VlZCB+Z2FtbWEgPVxuICBsZXQgc2VlZCA9IG1peDY0IHNlZWQgaW5cbiAgbGV0IG9kZF9nYW1tYSA9IG1peF9vZGRfZ2FtbWEgZ2FtbWEgaW5cbiAgeyBzZWVkOyBvZGRfZ2FtbWEgfVxuOztcblxubGV0IHJhbmRvbV9pbnQ2NCByYW5kb21fc3RhdGUgPVxuICBSYW5kb20uU3RhdGUuaW50NjRfaW5jbCByYW5kb21fc3RhdGUgSW50NjQubWluX3ZhbHVlIEludDY0Lm1heF92YWx1ZVxuOztcblxubGV0IGNyZWF0ZSByYW5kb21fc3RhdGUgPVxuICBsZXQgc2VlZCA9IHJhbmRvbV9pbnQ2NCByYW5kb21fc3RhdGUgaW5cbiAgbGV0IGdhbW1hID0gcmFuZG9tX2ludDY0IHJhbmRvbV9zdGF0ZSBpblxuICBvZl9zZWVkX2FuZF9nYW1tYSB+c2VlZCB+Z2FtbWFcbjs7XG5cbmxldCBzcGxpdCB0ID1cbiAgbGV0IHNlZWQgPSBuZXh0X3NlZWQgdCBpblxuICBsZXQgZ2FtbWEgPSBuZXh0X3NlZWQgdCBpblxuICBvZl9zZWVkX2FuZF9nYW1tYSB+c2VlZCB+Z2FtbWFcbjs7XG5cbmxldCBuZXh0X2ludDY0IHQgPSBtaXg2NCAobmV4dF9zZWVkIHQpXG5cbigqIFtwZXJ0dXJiXSBpcyBub3QgZnJvbSBhbnkgZXh0ZXJuYWwgc291cmNlLCBidXQgcHJvdmlkZXMgYSB3YXkgdG8gbWl4IGluIGV4dGVybmFsXG4gICBlbnRyb3B5IHdpdGggYSBwc2V1ZG8tcmFuZG9tIHN0YXRlLiAqKVxubGV0IHBlcnR1cmIgdCBzYWx0ID1cbiAgbGV0IG5leHQgPSB0LnNlZWQgKyBtaXg2NCAoSW50NjQub2ZfaW50IHNhbHQpIGluXG4gIHQuc2VlZCA8LSBuZXh0XG47O1xuXG5sZXQgYm9vbCBzdGF0ZSA9IGlzX29kZCAobmV4dF9pbnQ2NCBzdGF0ZSlcblxuKCogV2UgYWJ1c2UgdGVybWlub2xvZ3kgYW5kIHJlZmVyIHRvIGluZGl2aWR1YWwgdmFsdWVzIGFzIGJpYXNlZCBvciB1bmJpYXNlZC4gIE1vcmVcbiAgIHByb3Blcmx5LCB3aGF0IGlzIHVuYmlhc2VkIGlzIHRoZSBzYW1wbGVyIHRoYXQgcmVzdWx0cyBpZiB3ZSBrZWVwIG9ubHkgdGhlc2UgXCJ1bmJpYXNlZFwiXG4gICB2YWx1ZXMuICopXG5sZXQgcmVtYWluZGVyX2lzX3VuYmlhc2VkIH5kcmF3IH5yZW1haW5kZXIgfmRyYXdfbWF4aW11bSB+cmVtYWluZGVyX21heGltdW0gPVxuICBsZXQgb3BlbiBJbnQ2NC5PIGluXG4gIGRyYXcgLSByZW1haW5kZXIgPD0gZHJhd19tYXhpbXVtIC0gcmVtYWluZGVyX21heGltdW1cbjs7XG5cbmxldCV0ZXN0X3VuaXQgXCJyZW1haW5kZXJfaXNfdW5iaWFzZWRcIiA9XG4gICgqIGNob29zaW5nIGEgcmFuZ2Ugb2YgMTAgdmFsdWVzIGJhc2VkIG9uIGEgcmFuZ2Ugb2YgMTA1IHZhbHVlcyAqKVxuICBsZXQgZHJhd19tYXhpbXVtID0gMTA0TCBpblxuICBsZXQgcmVtYWluZGVyX21heGltdW0gPSA5TCBpblxuICBsZXQgaXNfdW5iaWFzZWQgZHJhdyA9XG4gICAgbGV0IHJlbWFpbmRlciA9IEludDY0LnJlbSBkcmF3IChJbnQ2NC5zdWNjIHJlbWFpbmRlcl9tYXhpbXVtKSBpblxuICAgIHJlbWFpbmRlcl9pc191bmJpYXNlZCB+ZHJhdyB+cmVtYWluZGVyIH5kcmF3X21heGltdW0gfnJlbWFpbmRlcl9tYXhpbXVtXG4gIGluXG4gIGZvciBpID0gMCB0byA5OSBkb1xuICAgIFsldGVzdF9yZXN1bHQ6IGJvb2xdXG4gICAgICAoaXNfdW5iaWFzZWQgKEludDY0Lm9mX2ludCBpKSlcbiAgICAgIH5leHBlY3Q6dHJ1ZVxuICAgICAgfm1lc3NhZ2U6KEludC50b19zdHJpbmcgaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAxMDAgdG8gMTA0IGRvXG4gICAgWyV0ZXN0X3Jlc3VsdDogYm9vbF1cbiAgICAgIChpc191bmJpYXNlZCAoSW50NjQub2ZfaW50IGkpKVxuICAgICAgfmV4cGVjdDpmYWxzZVxuICAgICAgfm1lc3NhZ2U6KEludC50b19zdHJpbmcgaSlcbiAgZG9uZVxuOztcblxuKCogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBib3VuZGVkIHJhbmRvbW5lc3MgaXMgYWRhcHRlZCBmcm9tIFtSYW5kb20uU3RhdGUuaW50Kl0gaW4gdGhlXG4gICBPQ2FtbCBzdGFuZGFyZCBsaWJyYXJ5LiAgVGhlIHB1cnBvc2UgaXMgdG8gdXNlIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjYWxscyB0b1xuICAgW25leHRfaW50NjRdIHRvIHByb2R1Y2UgYSBudW1iZXIgdW5pZm9ybWx5IGNob3NlbiB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlLiAqKVxubGV0IGludDY0ID1cbiAgbGV0IG9wZW4gSW50NjQuTyBpblxuICBsZXQgcmVjIGJldHdlZW4gc3RhdGUgfmxvIH5oaSA9XG4gICAgbGV0IGRyYXcgPSBuZXh0X2ludDY0IHN0YXRlIGluXG4gICAgaWYgbG8gPD0gZHJhdyAmJiBkcmF3IDw9IGhpIHRoZW4gZHJhdyBlbHNlIGJldHdlZW4gc3RhdGUgfmxvIH5oaVxuICBpblxuICBsZXQgcmVjIG5vbl9uZWdhdGl2ZV91cF90byBzdGF0ZSBtYXhpbXVtID1cbiAgICBsZXQgZHJhdyA9IG5leHRfaW50NjQgc3RhdGUgbGFuZCBJbnQ2NC5tYXhfdmFsdWUgaW5cbiAgICBsZXQgcmVtYWluZGVyID0gSW50NjQucmVtIGRyYXcgKEludDY0LnN1Y2MgbWF4aW11bSkgaW5cbiAgICBpZiByZW1haW5kZXJfaXNfdW5iaWFzZWRcbiAgICAgICAgIH5kcmF3XG4gICAgICAgICB+cmVtYWluZGVyXG4gICAgICAgICB+ZHJhd19tYXhpbXVtOkludDY0Lm1heF92YWx1ZVxuICAgICAgICAgfnJlbWFpbmRlcl9tYXhpbXVtOm1heGltdW1cbiAgICB0aGVuIHJlbWFpbmRlclxuICAgIGVsc2Ugbm9uX25lZ2F0aXZlX3VwX3RvIHN0YXRlIG1heGltdW1cbiAgaW5cbiAgZnVuIHN0YXRlIH5sbyB+aGkgLT5cbiAgICBpZiBsbyA+IGhpXG4gICAgdGhlbiBFcnJvci5yYWlzZV9zIFslbWVzc2FnZSBcImludDY0OiBjcm9zc2VkIGJvdW5kc1wiIChsbyA6IGludDY0KSAoaGkgOiBpbnQ2NCldO1xuICAgIGxldCBkaWZmID0gaGkgLSBsbyBpblxuICAgIGlmIGRpZmYgPSBJbnQ2NC5tYXhfdmFsdWVcbiAgICB0aGVuIChuZXh0X2ludDY0IHN0YXRlIGxhbmQgSW50NjQubWF4X3ZhbHVlKSArIGxvXG4gICAgZWxzZSBpZiBkaWZmID49IDBMXG4gICAgdGhlbiBub25fbmVnYXRpdmVfdXBfdG8gc3RhdGUgZGlmZiArIGxvXG4gICAgZWxzZSBiZXR3ZWVuIHN0YXRlIH5sbyB+aGlcbjs7XG5cbmxldCBpbnQgc3RhdGUgfmxvIH5oaSA9XG4gIGxldCBsbyA9IEludDY0Lm9mX2ludCBsbyBpblxuICBsZXQgaGkgPSBJbnQ2NC5vZl9pbnQgaGkgaW5cbiAgKCogdHJ1bmNhdGUgdW5uZWVkZWQgYml0cyAqKVxuICBJbnQ2NC50b19pbnRfdHJ1bmMgKGludDY0IHN0YXRlIH5sbyB+aGkpXG47O1xuXG5sZXQgaW50MzIgc3RhdGUgfmxvIH5oaSA9XG4gIGxldCBsbyA9IEludDY0Lm9mX2ludDMyIGxvIGluXG4gIGxldCBoaSA9IEludDY0Lm9mX2ludDMyIGhpIGluXG4gICgqIHRydW5jYXRlIHVubmVlZGVkIGJpdHMgKilcbiAgSW50NjQudG9faW50MzJfdHJ1bmMgKGludDY0IHN0YXRlIH5sbyB+aGkpXG47O1xuXG5sZXQgbmF0aXZlaW50IHN0YXRlIH5sbyB+aGkgPVxuICBsZXQgbG8gPSBJbnQ2NC5vZl9uYXRpdmVpbnQgbG8gaW5cbiAgbGV0IGhpID0gSW50NjQub2ZfbmF0aXZlaW50IGhpIGluXG4gICgqIHRydW5jYXRlIHVubmVlZGVkIGJpdHMgKilcbiAgSW50NjQudG9fbmF0aXZlaW50X3RydW5jIChpbnQ2NCBzdGF0ZSB+bG8gfmhpKVxuOztcblxubGV0IGludDYzIHN0YXRlIH5sbyB+aGkgPVxuICBsZXQgbG8gPSBJbnQ2My50b19pbnQ2NCBsbyBpblxuICBsZXQgaGkgPSBJbnQ2My50b19pbnQ2NCBoaSBpblxuICAoKiB0cnVuY2F0ZSB1bm5lZWRlZCBiaXRzICopXG4gIEludDYzLm9mX2ludDY0X3RydW5jIChpbnQ2NCBzdGF0ZSB+bG8gfmhpKVxuOztcblxubGV0IGRvdWJsZV91bHAgPSAyLiAqKi4gLTUzLlxuXG5sZXQldGVzdF91bml0IFwiZG91YmxlX3VscFwiID1cbiAgbGV0IG9wZW4gRmxvYXQuTyBpblxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT5cbiAgICBhc3NlcnQgKDEuMCAtLiBkb3VibGVfdWxwIDwgMS4wKTtcbiAgICBhc3NlcnQgKDEuMCAtLiAoZG91YmxlX3VscCAvLiAyLjApID0gMS4wKVxuICB8IFczMiAtPlxuICAgICgqIDMyLWJpdCBPQ2FtbCB1c2VzIGEgNjQtYml0IGZsb2F0IHJlcHJlc2VudGF0aW9uIGJ1dCA4MC1iaXQgZmxvYXQgaW5zdHJ1Y3Rpb25zLCBzb1xuICAgICAgIHJvdW5kaW5nIHdvcmtzIGRpZmZlcmVudGx5IGR1ZSB0byB0aGUgY29udmVyc2lvbiBiYWNrIGFuZCBmb3J0aC4gKilcbiAgICBhc3NlcnQgKDEuMCAtLiBkb3VibGVfdWxwIDwgMS4wKTtcbiAgICBhc3NlcnQgKDEuMCAtLiAoZG91YmxlX3VscCAvLiAyLjApIDw9IDEuMClcbjs7XG5cbmxldCB1bml0X2Zsb2F0X2Zyb21faW50NjQgaW50NjQgPSBJbnQ2NC50b19mbG9hdCAoaW50NjQgbHNyIDExKSAqLiBkb3VibGVfdWxwXG5cbmxldCV0ZXN0X3VuaXQgXCJ1bml0X2Zsb2F0X2Zyb21faW50NjRcIiA9XG4gIGxldCBvcGVuIEZsb2F0Lk8gaW5cbiAgYXNzZXJ0ICh1bml0X2Zsb2F0X2Zyb21faW50NjQgMHgwMDAwXzAwMDBfMDAwMF8wMDAwTCA9IDAuKTtcbiAgYXNzZXJ0ICh1bml0X2Zsb2F0X2Zyb21faW50NjQgMHhmZmZmX2ZmZmZfZmZmZl9mZmZmTCA8IDEuMCk7XG4gIGFzc2VydCAodW5pdF9mbG9hdF9mcm9tX2ludDY0IDB4ZmZmZl9mZmZmX2ZmZmZfZmZmZkwgPSAxLjAgLS4gZG91YmxlX3VscClcbjs7XG5cbmxldCB1bml0X2Zsb2F0IHN0YXRlID0gdW5pdF9mbG9hdF9mcm9tX2ludDY0IChuZXh0X2ludDY0IHN0YXRlKVxuXG4oKiBOb3RlIGFib3V0IHJvdW5kb2ZmIGVycm9yOlxuXG4gICBBbHRob3VnaCBbZmxvYXQgc3RhdGUgfmxvIH5oaV0gaXMgbm9taW5hbGx5IGluY2x1c2l2ZSBvZiBlbmRwb2ludHMsIHdlIGFyZSByZWx5aW5nIG9uXG4gICB0aGUgZmFjdCB0aGF0IFt1bml0X2Zsb2F0XSBuZXZlciByZXR1cm5zIDEuLCBiZWNhdXNlIHRoZXJlIGFyZSBwYWlycyBbKGxvLGhpKV0gZm9yXG4gICB3aGljaCBbbG8gKy4gMS4gKi4gKGhpIC0uIGxvKSA+IGhpXS4gIFRoZXJlIGFyZSBhbHNvIHBhaXJzIFsobG8saGkpXSBhbmQgdmFsdWVzIG9mIFt4XVxuICAgd2l0aCBbeCA8IDEuXSBzdWNoIHRoYXQgW2xvICsuIHggKi4gKGhpIC0uIGxvKSA9IGhpXSwgc28gaXQgd291bGQgbm90IGJlIGNvcnJlY3QgdG9cbiAgIGRvY3VtZW50IHRoaXMgYXMgYmVpbmcgZXhjbHVzaXZlIG9mIFtoaV0uXG4qKVxubGV0IGZsb2F0ID1cbiAgbGV0IHJlYyBmaW5pdGVfZmxvYXQgc3RhdGUgfmxvIH5oaSA9XG4gICAgbGV0IHJhbmdlID0gaGkgLS4gbG8gaW5cbiAgICBpZiBGbG9hdC5pc19maW5pdGUgcmFuZ2VcbiAgICB0aGVuIGxvICsuICh1bml0X2Zsb2F0IHN0YXRlICouIHJhbmdlKVxuICAgIGVsc2UgKFxuICAgICAgKCogSWYgW2hpIC0gbG9dIGlzIGluZmluaXRlLCB0aGVuIFtoaSArIGxvXSBpcyBmaW5pdGUgYmVjYXVzZSBbaGldIGFuZCBbbG9dIGhhdmVcbiAgICAgICAgIG9wcG9zaXRlIHNpZ25zLiAqKVxuICAgICAgbGV0IG1pZCA9IChoaSArLiBsbykgLy4gMi4gaW5cbiAgICAgIGlmIGJvb2wgc3RhdGVcbiAgICAgICAgICgqIERlcGVuZGluZyBvbiByb3VuZGluZywgdGhlIHJlY3Vyc2lvbiB3aXRoIFt+aGk6bWlkXSBtaWdodCBiZSBpbmNsdXNpdmUgb2YgW21pZF0sXG4gICAgICAgICB3aGljaCB3b3VsZCBtZWFuIHRoZSB0d28gY2FzZXMgb3ZlcmxhcCBvbiBbbWlkXS4gVGhlIGFsdGVybmF0aXZlIGlzIHRvIGluY3JlbWVudFxuICAgICAgICAgb3IgZGVjcmVtZW50IFttaWRdIHVzaW5nIFtvbmVfdWxwXSBpbiBlaXRoZXIgb2YgdGhlIGNhbGxzLCBidXQgdGhlbiBpZiB0aGUgZmlyc3RcbiAgICAgICAgIGNhc2UgaXMgZXhjbHVzaXZlIHdlIGxlYXZlIGEgXCJnYXBcIiBiZXR3ZWVuIHRoZSB0d28gcmFuZ2VzLiBUaGVyZSdzIG5vIHBlcmZlY3RseVxuICAgICAgICAgdW5pZm9ybSBzb2x1dGlvbiwgc28gd2UgdXNlIHRoZSBzaW1wbGVyIGNvZGUgdGhhdCBkb2VzIG5vdCBjYWxsIFtvbmVfdWxwXS4gKilcbiAgICAgIHRoZW4gZmluaXRlX2Zsb2F0IHN0YXRlIH5sbyB+aGk6bWlkXG4gICAgICBlbHNlIGZpbml0ZV9mbG9hdCBzdGF0ZSB+bG86bWlkIH5oaSlcbiAgaW5cbiAgZnVuIHN0YXRlIH5sbyB+aGkgLT5cbiAgICBpZiBub3QgKEZsb2F0LmlzX2Zpbml0ZSBsbyAmJiBGbG9hdC5pc19maW5pdGUgaGkpXG4gICAgdGhlblxuICAgICAgcmFpc2VfcyBbJW1lc3NhZ2UgXCJmbG9hdDogYm91bmRzIGFyZSBub3QgZmluaXRlIG51bWJlcnNcIiAobG8gOiBmbG9hdCkgKGhpIDogZmxvYXQpXTtcbiAgICBpZiBGbG9hdC4oID4gKSBsbyBoaVxuICAgIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJmbG9hdDogYm91bmRzIGFyZSBjcm9zc2VkXCIgKGxvIDogZmxvYXQpIChoaSA6IGZsb2F0KV07XG4gICAgZmluaXRlX2Zsb2F0IHN0YXRlIH5sbyB+aGlcbjs7XG5cbmxldCViZW5jaF9mdW4gXCJ1bml0X2Zsb2F0X2Zyb21faW50NjRcIiA9XG4gIGxldCBpbnQ2NCA9IDFMIGluXG4gIGZ1biAoKSAtPiB1bml0X2Zsb2F0X2Zyb21faW50NjQgaW50NjRcbjs7XG5cbm1vZHVsZSBMb2dfdW5pZm9ybSA9IHN0cnVjdFxuICBtb2R1bGUgTWFrZSAoTSA6IHNpZ1xuICAgIGluY2x1ZGUgSW50LlNcblxuICAgIHZhbCB1bmlmb3JtIDogc3RhdGUgLT4gbG86dCAtPiBoaTp0IC0+IHRcbiAgZW5kKSA6IHNpZ1xuICAgIHZhbCBsb2dfdW5pZm9ybSA6IHN0YXRlIC0+IGxvOk0udCAtPiBoaTpNLnQgLT4gTS50XG4gIGVuZCA9IHN0cnVjdFxuICAgIG9wZW4gTVxuXG4gICAgbGV0IGJpdHNfdG9fcmVwcmVzZW50IHQgPVxuICAgICAgYXNzZXJ0ICh0ID49IHplcm8pO1xuICAgICAgbGV0IHQgPSByZWYgdCBpblxuICAgICAgbGV0IG4gPSByZWYgMCBpblxuICAgICAgd2hpbGUgIXQgPiB6ZXJvIGRvXG4gICAgICAgIHQgOj0gc2hpZnRfcmlnaHQgIXQgMTtcbiAgICAgICAgSW50LmluY3IgblxuICAgICAgZG9uZTtcbiAgICAgICFuXG4gICAgOztcblxuICAgIGxldCV0ZXN0X3VuaXQgXCJiaXRzX3RvX3JlcHJlc2VudFwiID1cbiAgICAgIGxldCB0ZXN0IG4gZXhwZWN0ID0gWyV0ZXN0X3Jlc3VsdDogaW50XSAoYml0c190b19yZXByZXNlbnQgbikgfmV4cGVjdCBpblxuICAgICAgdGVzdCAoTS5vZl9pbnRfZXhuIDApIDA7XG4gICAgICB0ZXN0IChNLm9mX2ludF9leG4gMSkgMTtcbiAgICAgIHRlc3QgKE0ub2ZfaW50X2V4biAyKSAyO1xuICAgICAgdGVzdCAoTS5vZl9pbnRfZXhuIDMpIDI7XG4gICAgICB0ZXN0IChNLm9mX2ludF9leG4gNCkgMztcbiAgICAgIHRlc3QgKE0ub2ZfaW50X2V4biA1KSAzO1xuICAgICAgdGVzdCAoTS5vZl9pbnRfZXhuIDYpIDM7XG4gICAgICB0ZXN0IChNLm9mX2ludF9leG4gNykgMztcbiAgICAgIHRlc3QgKE0ub2ZfaW50X2V4biA4KSA0O1xuICAgICAgdGVzdCAoTS5vZl9pbnRfZXhuIDEwMCkgNztcbiAgICAgIHRlc3QgTS5tYXhfdmFsdWUgKEludC5wcmVkIE0ubnVtX2JpdHMpXG4gICAgOztcblxuICAgIGxldCBtaW5fcmVwcmVzZW50ZWRfYnlfbl9iaXRzIG4gPVxuICAgICAgaWYgSW50LmVxdWFsIG4gMCB0aGVuIHplcm8gZWxzZSBzaGlmdF9sZWZ0IG9uZSAoSW50LnByZWQgbilcbiAgICA7O1xuXG4gICAgbGV0JXRlc3RfdW5pdCBcIm1pbl9yZXByZXNlbnRlZF9ieV9uX2JpdHNcIiA9XG4gICAgICBsZXQgdGVzdCBuIGV4cGVjdCA9IFsldGVzdF9yZXN1bHQ6IE0udF0gKG1pbl9yZXByZXNlbnRlZF9ieV9uX2JpdHMgbikgfmV4cGVjdCBpblxuICAgICAgdGVzdCAwIChNLm9mX2ludF9leG4gMCk7XG4gICAgICB0ZXN0IDEgKE0ub2ZfaW50X2V4biAxKTtcbiAgICAgIHRlc3QgMiAoTS5vZl9pbnRfZXhuIDIpO1xuICAgICAgdGVzdCAzIChNLm9mX2ludF9leG4gNCk7XG4gICAgICB0ZXN0IDQgKE0ub2ZfaW50X2V4biA4KTtcbiAgICAgIHRlc3QgNyAoTS5vZl9pbnRfZXhuIDY0KTtcbiAgICAgIHRlc3QgKEludC5wcmVkIE0ubnVtX2JpdHMpIChNLnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgTS5taW5fdmFsdWUgMSlcbiAgICA7O1xuXG4gICAgbGV0IG1heF9yZXByZXNlbnRlZF9ieV9uX2JpdHMgbiA9IHByZWQgKHNoaWZ0X2xlZnQgb25lIG4pXG5cbiAgICBsZXQldGVzdF91bml0IFwibWF4X3JlcHJlc2VudGVkX2J5X25fYml0c1wiID1cbiAgICAgIGxldCB0ZXN0IG4gZXhwZWN0ID0gWyV0ZXN0X3Jlc3VsdDogTS50XSAobWF4X3JlcHJlc2VudGVkX2J5X25fYml0cyBuKSB+ZXhwZWN0IGluXG4gICAgICB0ZXN0IDAgKE0ub2ZfaW50X2V4biAwKTtcbiAgICAgIHRlc3QgMSAoTS5vZl9pbnRfZXhuIDEpO1xuICAgICAgdGVzdCAyIChNLm9mX2ludF9leG4gMyk7XG4gICAgICB0ZXN0IDMgKE0ub2ZfaW50X2V4biA3KTtcbiAgICAgIHRlc3QgNCAoTS5vZl9pbnRfZXhuIDE1KTtcbiAgICAgIHRlc3QgNyAoTS5vZl9pbnRfZXhuIDEyNyk7XG4gICAgICB0ZXN0IChJbnQucHJlZCBNLm51bV9iaXRzKSBNLm1heF92YWx1ZVxuICAgIDs7XG5cbiAgICBsZXQgbG9nX3VuaWZvcm0gc3RhdGUgfmxvIH5oaSA9XG4gICAgICBsZXQgbWluX2JpdHMgPSBiaXRzX3RvX3JlcHJlc2VudCBsbyBpblxuICAgICAgbGV0IG1heF9iaXRzID0gYml0c190b19yZXByZXNlbnQgaGkgaW5cbiAgICAgIGxldCBiaXRzID0gaW50IHN0YXRlIH5sbzptaW5fYml0cyB+aGk6bWF4X2JpdHMgaW5cbiAgICAgIHVuaWZvcm1cbiAgICAgICAgc3RhdGVcbiAgICAgICAgfmxvOihtaW5fcmVwcmVzZW50ZWRfYnlfbl9iaXRzIGJpdHMgfD4gbWF4IGxvKVxuICAgICAgICB+aGk6KG1heF9yZXByZXNlbnRlZF9ieV9uX2JpdHMgYml0cyB8PiBtaW4gaGkpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEZvcl9pbnQgPSBNYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIEludFxuXG4gICAgbGV0IHVuaWZvcm0gPSBpbnRcbiAgZW5kKVxuXG4gIG1vZHVsZSBGb3JfaW50MzIgPSBNYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIEludDMyXG5cbiAgICBsZXQgdW5pZm9ybSA9IGludDMyXG4gIGVuZClcblxuICBtb2R1bGUgRm9yX2ludDYzID0gTWFrZSAoc3RydWN0XG4gICAgaW5jbHVkZSBJbnQ2M1xuXG4gICAgbGV0IHVuaWZvcm0gPSBpbnQ2M1xuICBlbmQpXG5cbiAgbW9kdWxlIEZvcl9pbnQ2NCA9IE1ha2UgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50NjRcblxuICAgIGxldCB1bmlmb3JtID0gaW50NjRcbiAgZW5kKVxuXG4gIG1vZHVsZSBGb3JfbmF0aXZlaW50ID0gTWFrZSAoc3RydWN0XG4gICAgaW5jbHVkZSBOYXRpdmVpbnRcblxuICAgIGxldCB1bmlmb3JtID0gbmF0aXZlaW50XG4gIGVuZClcblxuICBsZXQgaW50ID0gRm9yX2ludC5sb2dfdW5pZm9ybVxuICBsZXQgaW50MzIgPSBGb3JfaW50MzIubG9nX3VuaWZvcm1cbiAgbGV0IGludDYzID0gRm9yX2ludDYzLmxvZ191bmlmb3JtXG4gIGxldCBpbnQ2NCA9IEZvcl9pbnQ2NC5sb2dfdW5pZm9ybVxuICBsZXQgbmF0aXZlaW50ID0gRm9yX25hdGl2ZWludC5sb2dfdW5pZm9ybVxuZW5kXG5cbm1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuICB0eXBlIHQgPSBzdGF0ZVxuXG4gIGxldCBjcmVhdGUgPSBjcmVhdGVcbiAgbGV0IG9mX2ludCA9IG9mX2ludFxuICBsZXQgcGVydHVyYiA9IHBlcnR1cmJcbiAgbGV0IGNvcHkgPSBjb3B5XG4gIGxldCBzcGxpdCA9IHNwbGl0XG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgVGhpcyBtb2R1bGUgcHJvdmlkZXMgb3BlcmF0aW9ucyBvbiB0aGUgdHlwZSBbaW50NjRdIG9mXG4gICBzaWduZWQgNjQtYml0IGludGVnZXJzLiAgVW5saWtlIHRoZSBidWlsdC1pbiBbaW50XSB0eXBlLFxuICAgdGhlIHR5cGUgW2ludDY0XSBpcyBndWFyYW50ZWVkIHRvIGJlIGV4YWN0bHkgNjQtYml0IHdpZGUgb24gYWxsXG4gICBwbGF0Zm9ybXMuICBBbGwgYXJpdGhtZXRpYyBvcGVyYXRpb25zIG92ZXIgW2ludDY0XSBhcmUgdGFrZW5cbiAgIG1vZHVsbyAye142NH1cblxuICAgUGVyZm9ybWFuY2Ugbm90aWNlOiB2YWx1ZXMgb2YgdHlwZSBbaW50NjRdIG9jY3VweSBtb3JlIG1lbW9yeVxuICAgc3BhY2UgdGhhbiB2YWx1ZXMgb2YgdHlwZSBbaW50XSwgYW5kIGFyaXRobWV0aWMgb3BlcmF0aW9ucyBvblxuICAgW2ludDY0XSBhcmUgZ2VuZXJhbGx5IHNsb3dlciB0aGFuIHRob3NlIG9uIFtpbnRdLiAgVXNlIFtpbnQ2NF1cbiAgIG9ubHkgd2hlbiB0aGUgYXBwbGljYXRpb24gcmVxdWlyZXMgZXhhY3QgNjQtYml0IGFyaXRobWV0aWMuXG5cbiAgICBMaXRlcmFscyBmb3IgNjQtYml0IGludGVnZXJzIGFyZSBzdWZmaXhlZCBieSBMOlxuICAgIHtbXG4gICAgICBsZXQgemVybzogaW50NjQgPSAwTFxuICAgICAgbGV0IG9uZTogaW50NjQgPSAxTFxuICAgICAgbGV0IG1fb25lOiBpbnQ2NCA9IC0xTFxuICAgIF19XG4qKVxuXG52YWwgemVybyA6IGludDY0XG4oKiogVGhlIDY0LWJpdCBpbnRlZ2VyIDAuICopXG5cbnZhbCBvbmUgOiBpbnQ2NFxuKCoqIFRoZSA2NC1iaXQgaW50ZWdlciAxLiAqKVxuXG52YWwgbWludXNfb25lIDogaW50NjRcbigqKiBUaGUgNjQtYml0IGludGVnZXIgLTEuICopXG5cbmV4dGVybmFsIG5lZyA6IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbmVnXCJcbigqKiBVbmFyeSBuZWdhdGlvbi4gKilcblxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuKCoqIEFkZGl0aW9uLiAqKVxuXG5leHRlcm5hbCBzdWIgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3N1YlwiXG4oKiogU3VidHJhY3Rpb24uICopXG5cbmV4dGVybmFsIG11bCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbXVsXCJcbigqKiBNdWx0aXBsaWNhdGlvbi4gKilcblxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuKCoqIEludGVnZXIgZGl2aXNpb24uXG4gICBAcmFpc2UgRGl2aXNpb25fYnlfemVybyBpZiB0aGUgc2Vjb25kXG4gICBhcmd1bWVudCBpcyB6ZXJvLiAgVGhpcyBkaXZpc2lvbiByb3VuZHMgdGhlIHJlYWwgcXVvdGllbnQgb2ZcbiAgIGl0cyBhcmd1bWVudHMgdG93YXJkcyB6ZXJvLCBhcyBzcGVjaWZpZWQgZm9yIHshU3RkbGliLigvKX0uICopXG5cbnZhbCB1bnNpZ25lZF9kaXYgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFNhbWUgYXMgeyFkaXZ9LCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYW5kIHJlc3VsdCBhcmUgaW50ZXJwcmV0ZWQgYXMge2VcbiAgICB1bnNpZ25lZH0gNjQtYml0IGludGVnZXJzLlxuXG4gICAgQHNpbmNlIDQuMDggKilcblxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuKCoqIEludGVnZXIgcmVtYWluZGVyLiAgSWYgW3ldIGlzIG5vdCB6ZXJvLCB0aGUgcmVzdWx0XG4gICBvZiBbSW50NjQucmVtIHggeV0gc2F0aXNmaWVzIHRoZSBmb2xsb3dpbmcgcHJvcGVydHk6XG4gICBbeCA9IEludDY0LmFkZCAoSW50NjQubXVsIChJbnQ2NC5kaXYgeCB5KSB5KSAoSW50NjQucmVtIHggeSldLlxuICAgSWYgW3kgPSAwXSwgW0ludDY0LnJlbSB4IHldIHJhaXNlcyBbRGl2aXNpb25fYnlfemVyb10uICopXG5cbnZhbCB1bnNpZ25lZF9yZW0gOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFNhbWUgYXMgeyFyZW19LCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYW5kIHJlc3VsdCBhcmUgaW50ZXJwcmV0ZWQgYXMge2VcbiAgICB1bnNpZ25lZH0gNjQtYml0IGludGVnZXJzLlxuXG4gICAgQHNpbmNlIDQuMDggKilcblxudmFsIHN1Y2MgOiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFN1Y2Nlc3Nvci4gIFtJbnQ2NC5zdWNjIHhdIGlzIFtJbnQ2NC5hZGQgeCBJbnQ2NC5vbmVdLiAqKVxuXG52YWwgcHJlZCA6IGludDY0IC0+IGludDY0XG4oKiogUHJlZGVjZXNzb3IuICBbSW50NjQucHJlZCB4XSBpcyBbSW50NjQuc3ViIHggSW50NjQub25lXS4gKilcblxudmFsIGFicyA6IGludDY0IC0+IGludDY0XG4oKiogW2FicyB4XSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgW3hdLiBPbiBbbWluX2ludF0gdGhpc1xuICAgaXMgW21pbl9pbnRdIGl0c2VsZiBhbmQgdGh1cyByZW1haW5zIG5lZ2F0aXZlLiAqKVxuXG52YWwgbWF4X2ludCA6IGludDY0XG4oKiogVGhlIGdyZWF0ZXN0IHJlcHJlc2VudGFibGUgNjQtYml0IGludGVnZXIsIDJ7XjYzfSAtIDEuICopXG5cbnZhbCBtaW5faW50IDogaW50NjRcbigqKiBUaGUgc21hbGxlc3QgcmVwcmVzZW50YWJsZSA2NC1iaXQgaW50ZWdlciwgLTJ7XjYzfS4gKilcblxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBhbmQuICopXG5cbmV4dGVybmFsIGxvZ29yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vclwiXG4oKiogQml0d2lzZSBsb2dpY2FsIG9yLiAqKVxuXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3hvclwiXG4oKiogQml0d2lzZSBsb2dpY2FsIGV4Y2x1c2l2ZSBvci4gKilcblxudmFsIGxvZ25vdCA6IGludDY0IC0+IGludDY0XG4oKiogQml0d2lzZSBsb2dpY2FsIG5lZ2F0aW9uLiAqKVxuXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNsXCJcbigqKiBbSW50NjQuc2hpZnRfbGVmdCB4IHldIHNoaWZ0cyBbeF0gdG8gdGhlIGxlZnQgYnkgW3ldIGJpdHMuXG4gICBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIFt5IDwgMF0gb3IgW3kgPj0gNjRdLiAqKVxuXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2FzclwiXG4oKiogW0ludDY0LnNoaWZ0X3JpZ2h0IHggeV0gc2hpZnRzIFt4XSB0byB0aGUgcmlnaHQgYnkgW3ldIGJpdHMuXG4gICBUaGlzIGlzIGFuIGFyaXRobWV0aWMgc2hpZnQ6IHRoZSBzaWduIGJpdCBvZiBbeF0gaXMgcmVwbGljYXRlZFxuICAgYW5kIGluc2VydGVkIGluIHRoZSB2YWNhdGVkIGJpdHMuXG4gICBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIFt5IDwgMF0gb3IgW3kgPj0gNjRdLiAqKVxuXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNyXCJcbigqKiBbSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCB4IHldIHNoaWZ0cyBbeF0gdG8gdGhlIHJpZ2h0IGJ5IFt5XSBiaXRzLlxuICAgVGhpcyBpcyBhIGxvZ2ljYWwgc2hpZnQ6IHplcm9lcyBhcmUgaW5zZXJ0ZWQgaW4gdGhlIHZhY2F0ZWQgYml0c1xuICAgcmVnYXJkbGVzcyBvZiB0aGUgc2lnbiBvZiBbeF0uXG4gICBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIFt5IDwgMF0gb3IgW3kgPj0gNjRdLiAqKVxuXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIGludGVnZXIgKHR5cGUgW2ludF0pIHRvIGEgNjQtYml0IGludGVnZXJcbiAgICAodHlwZSBbaW50NjRdKS4gKilcblxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKSB0byBhblxuICAgaW50ZWdlciAodHlwZSBbaW50XSkuICBPbiA2NC1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye142M30sIGkuZS4gdGhlIGhpZ2gtb3JkZXIgYml0IGlzIGxvc3RcbiAgIGR1cmluZyB0aGUgY29udmVyc2lvbi4gIE9uIDMyLWJpdCBwbGF0Zm9ybXMsIHRoZSA2NC1iaXQgaW50ZWdlclxuICAgaXMgdGFrZW4gbW9kdWxvIDJ7XjMxfSwgaS5lLiB0aGUgdG9wIDMzIGJpdHMgYXJlIGxvc3RcbiAgIGR1cmluZyB0aGUgY29udmVyc2lvbi4gKilcblxudmFsIHVuc2lnbmVkX3RvX2ludCA6IGludDY0IC0+IGludCBvcHRpb25cbigqKiBTYW1lIGFzIHshdG9faW50fSwgYnV0IGludGVycHJldHMgdGhlIGFyZ3VtZW50IGFzIGFuIHtlIHVuc2lnbmVkfSBpbnRlZ2VyLlxuICAgIFJldHVybnMgW05vbmVdIGlmIHRoZSB1bnNpZ25lZCB2YWx1ZSBvZiB0aGUgYXJndW1lbnQgY2Fubm90IGZpdCBpbnRvIGFuXG4gICAgW2ludF0uXG5cbiAgICBAc2luY2UgNC4wOCAqKVxuXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIGZsb2F0aW5nLXBvaW50IG51bWJlciB0byBhIDY0LWJpdCBpbnRlZ2VyLFxuICAgZGlzY2FyZGluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0ICh0cnVuY2F0ZSB0b3dhcmRzIDApLlxuICAgSWYgdGhlIHRydW5jYXRlZCBmbG9hdGluZy1wb2ludCBudW1iZXIgaXMgb3V0c2lkZSB0aGUgcmFuZ2VcbiAgIFxcW3shSW50NjQubWluX2ludH0sIHshSW50NjQubWF4X2ludH1cXF0sIG5vIGV4Y2VwdGlvbiBpcyByYWlzZWQsIGFuZFxuICAgYW4gdW5zcGVjaWZpZWQsIHBsYXRmb3JtLWRlcGVuZGVudCBpbnRlZ2VyIGlzIHJldHVybmVkLiAqKVxuXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIDY0LWJpdCBpbnRlZ2VyIHRvIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLiAqKVxuXG5cbmV4dGVybmFsIG9mX2ludDMyIDogaW50MzIgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnQzMlwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gMzItYml0IGludGVnZXIgKHR5cGUgW2ludDMyXSlcbiAgIHRvIGEgNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkuICopXG5cbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkgdG8gYVxuICAgMzItYml0IGludGVnZXIgKHR5cGUgW2ludDMyXSkuIFRoZSA2NC1iaXQgaW50ZWdlclxuICAgaXMgdGFrZW4gbW9kdWxvIDJ7XjMyfSwgaS5lLiB0aGUgdG9wIDMyIGJpdHMgYXJlIGxvc3RcbiAgIGR1cmluZyB0aGUgY29udmVyc2lvbi4gICopXG5cbmV4dGVybmFsIG9mX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiBpbnQ2NCA9IFwiJWludDY0X29mX25hdGl2ZWludFwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gbmF0aXZlIGludGVnZXIgKHR5cGUgW25hdGl2ZWludF0pXG4gICB0byBhIDY0LWJpdCBpbnRlZ2VyICh0eXBlIFtpbnQ2NF0pLiAqKVxuXG5leHRlcm5hbCB0b19uYXRpdmVpbnQgOiBpbnQ2NCAtPiBuYXRpdmVpbnQgPSBcIiVpbnQ2NF90b19uYXRpdmVpbnRcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIDY0LWJpdCBpbnRlZ2VyICh0eXBlIFtpbnQ2NF0pIHRvIGFcbiAgIG5hdGl2ZSBpbnRlZ2VyLiAgT24gMzItYml0IHBsYXRmb3JtcywgdGhlIDY0LWJpdCBpbnRlZ2VyXG4gICBpcyB0YWtlbiBtb2R1bG8gMnteMzJ9LiAgT24gNjQtYml0IHBsYXRmb3JtcyxcbiAgIHRoZSBjb252ZXJzaW9uIGlzIGV4YWN0LiAqKVxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiBzdHJpbmcgdG8gYSA2NC1iaXQgaW50ZWdlci5cbiAgIFRoZSBzdHJpbmcgaXMgcmVhZCBpbiBkZWNpbWFsIChieSBkZWZhdWx0LCBvciBpZiB0aGUgc3RyaW5nXG4gICBiZWdpbnMgd2l0aCBbMHVdKSBvciBpbiBoZXhhZGVjaW1hbCwgb2N0YWwgb3IgYmluYXJ5IGlmIHRoZVxuICAgc3RyaW5nIGJlZ2lucyB3aXRoIFsweF0sIFswb10gb3IgWzBiXSByZXNwZWN0aXZlbHkuXG5cbiAgIFRoZSBbMHVdIHByZWZpeCByZWFkcyB0aGUgaW5wdXQgYXMgYW4gdW5zaWduZWQgaW50ZWdlciBpbiB0aGUgcmFuZ2VcbiAgIFtbMCwgMipJbnQ2NC5tYXhfaW50KzFdXS4gIElmIHRoZSBpbnB1dCBleGNlZWRzIHshSW50NjQubWF4X2ludH1cbiAgIGl0IGlzIGNvbnZlcnRlZCB0byB0aGUgc2lnbmVkIGludGVnZXJcbiAgIFtJbnQ2NC5taW5faW50ICsgaW5wdXQgLSBJbnQ2NC5tYXhfaW50IC0gMV0uXG5cbiAgIFRoZSBbX10gKHVuZGVyc2NvcmUpIGNoYXJhY3RlciBjYW4gYXBwZWFyIGFueXdoZXJlIGluIHRoZSBzdHJpbmdcbiAgIGFuZCBpcyBpZ25vcmVkLlxuICAgQHJhaXNlIEZhaWx1cmUgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBub3RcbiAgIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlciwgb3IgaWYgdGhlIGludGVnZXIgcmVwcmVzZW50ZWRcbiAgIGV4Y2VlZHMgdGhlIHJhbmdlIG9mIGludGVnZXJzIHJlcHJlc2VudGFibGUgaW4gdHlwZSBbaW50NjRdLiAqKVxuXG52YWwgb2Zfc3RyaW5nX29wdDogc3RyaW5nIC0+IGludDY0IG9wdGlvblxuKCoqIFNhbWUgYXMgW29mX3N0cmluZ10sIGJ1dCByZXR1cm4gW05vbmVdIGluc3RlYWQgb2YgcmFpc2luZy5cbiAgICBAc2luY2UgNC4wNSAqKVxuXG52YWwgdG9fc3RyaW5nIDogaW50NjQgLT4gc3RyaW5nXG4oKiogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaXRzIGFyZ3VtZW50LCBpbiBkZWNpbWFsLiAqKVxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIFJldHVybiB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGZsb2F0IGFjY29yZGluZ1xuICAgdG8gdGhlIElFRUUgNzU0IGZsb2F0aW5nLXBvaW50ICdkb3VibGUgZm9ybWF0JyBiaXQgbGF5b3V0LlxuICAgQml0IDYzIG9mIHRoZSByZXN1bHQgcmVwcmVzZW50cyB0aGUgc2lnbiBvZiB0aGUgZmxvYXQ7XG4gICBiaXRzIDYyIHRvIDUyIHJlcHJlc2VudCB0aGUgKGJpYXNlZCkgZXhwb25lbnQ7IGJpdHMgNTEgdG8gMFxuICAgcmVwcmVzZW50IHRoZSBtYW50aXNzYS4gKilcblxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbigqKiBSZXR1cm4gdGhlIGZsb2F0aW5nLXBvaW50IG51bWJlciB3aG9zZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbixcbiAgIGFjY29yZGluZyB0byB0aGUgSUVFRSA3NTQgZmxvYXRpbmctcG9pbnQgJ2RvdWJsZSBmb3JtYXQnIGJpdCBsYXlvdXQsXG4gICBpcyB0aGUgZ2l2ZW4gW2ludDY0XS4gKilcblxudHlwZSB0ID0gaW50NjRcbigqKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgNjQtYml0IGludGVnZXJzLiAqKVxuXG52YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuKCoqIFRoZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciA2NC1iaXQgaW50ZWdlcnMsIHdpdGggdGhlIHNhbWUgc3BlY2lmaWNhdGlvbiBhc1xuICAgIHshU3RkbGliLmNvbXBhcmV9LiAgQWxvbmcgd2l0aCB0aGUgdHlwZSBbdF0sIHRoaXMgZnVuY3Rpb24gW2NvbXBhcmVdXG4gICAgYWxsb3dzIHRoZSBtb2R1bGUgW0ludDY0XSB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnQgdG8gdGhlIGZ1bmN0b3JzXG4gICAgeyFTZXQuTWFrZX0gYW5kIHshTWFwLk1ha2V9LiAqKVxuXG52YWwgdW5zaWduZWRfY29tcGFyZTogdCAtPiB0IC0+IGludFxuKCoqIFNhbWUgYXMgeyFjb21wYXJlfSwgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBpbnRlcnByZXRlZCBhcyB7ZSB1bnNpZ25lZH1cbiAgICA2NC1iaXQgaW50ZWdlcnMuXG5cbiAgICBAc2luY2UgNC4wOCAqKVxuXG52YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4oKiogVGhlIGVxdWFsIGZ1bmN0aW9uIGZvciBpbnQ2NHMuXG4gICAgQHNpbmNlIDQuMDMgKilcblxudmFsIG1pbjogdCAtPiB0IC0+IHRcbigqKiBSZXR1cm4gdGhlIHNtYWxsZXIgb2YgdGhlIHR3byBhcmd1bWVudHMuXG4gICAgQHNpbmNlIDQuMTNcbiopXG5cbnZhbCBtYXg6IHQgLT4gdCAtPiB0XG4oKiogUmV0dXJuIHRoZSBncmVhdGVyIG9mIHRoZSB0d28gYXJndW1lbnRzLlxuICAgIEBzaW5jZSA0LjEzXG4gKilcblxudmFsIHNlZWRlZF9oYXNoIDogaW50IC0+IHQgLT4gaW50XG4oKiogQSBzZWVkZWQgaGFzaCBmdW5jdGlvbiBmb3IgNjQtYml0IGludHMsIHdpdGggdGhlIHNhbWUgb3V0cHV0IHZhbHVlIGFzXG4gICAgeyFIYXNodGJsLnNlZWRlZF9oYXNofS4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmUgcGFzc2VkIGFzXG4gICAgYXJndW1lbnQgdG8gdGhlIGZ1bmN0b3IgeyFIYXNodGJsLk1ha2VTZWVkZWR9LlxuXG4gICAgQHNpbmNlIDUuMSAqKVxuXG52YWwgaGFzaCA6IHQgLT4gaW50XG4oKiogQW4gdW5zZWVkZWQgaGFzaCBmdW5jdGlvbiBmb3IgNjQtYml0IGludHMsIHdpdGggdGhlIHNhbWUgb3V0cHV0IHZhbHVlIGFzXG4gICAgeyFIYXNodGJsLmhhc2h9LiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnRcbiAgICB0byB0aGUgZnVuY3RvciB7IUhhc2h0YmwuTWFrZX0uXG5cbiAgICBAc2luY2UgNS4xICopXG4iXX0=
