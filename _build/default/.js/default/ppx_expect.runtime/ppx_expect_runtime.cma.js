// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ppx_expect_runtime__
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Ppx_expect_runtime = [0],
    Ppx_expect_runtime$0 = [0, Ppx_expect_runtime];
   runtime.caml_register_global
    (0, Ppx_expect_runtime$0, "Ppx_expect_runtime__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Types
//# unitInfo: Requires: Base, Base__Comparable, Base__Int
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    default$0 = [0, 2, 0, "%", "@@"],
    default$1 = [0, cst],
    Base = global_data.Base,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int = global_data.Base__Int,
    _f_ = [0, cst];
   function equal(a, b){
    var _g_ = a[1] === b[1] ? 1 : 0;
    if(_g_)
     var _h_ = a[2] === b[2] ? 1 : 0, _i_ = _h_ ? a[3] === b[3] ? 1 : 0 : _h_;
    else
     var _i_ = _g_;
    return _i_;
   }
   var _a_ = 0;
   function _b_(t){return t[3];}
   var _c_ = [0, caml_call2(Base_Comparable[2], Base[129], _b_), _a_];
   function _d_(t){return t[2];}
   var
    _e_ = [0, caml_call2(Base_Comparable[2], Base[129], _d_), _c_],
    compare_character_range = caml_call1(Base_Comparable[1], _e_),
    Compact_loc = [0, equal, compare_character_range],
    Flexibility = [0],
    Expect_node_formatting = [0, default$0, Flexibility],
    Virtual_loc = [0],
    of_int_exn = Base_Int[5],
    to_int_exn = Base_Int[6],
    hash = Base_Int[8],
    sexp_of_t = Base_Int[10],
    compare = Base_Int[14],
    counter = [0, 0];
   function mint(param){
    var id = counter[1];
    counter[1] = id + 1 | 0;
    return id;
   }
   var Hand = [0], Kind = [0], Shape = [0];
   function handed(t, hand){return hand ? t ? t : _f_ : t;}
   var
    Ppx_expect_runtime_Types =
      [0,
       Expect_node_formatting,
       Compact_loc,
       Virtual_loc,
       [0, of_int_exn, to_int_exn, compare, sexp_of_t, hash, mint],
       [0, Hand, Kind, Shape, [0, default$1, handed]]];
   runtime.caml_register_global
    (6, Ppx_expect_runtime_Types, "Ppx_expect_runtime__Types");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Write_corrected_file
//# unitInfo: Requires: Base, Base__Comparable, Base__List, Base__String, Make_corrected_file, Ppx_expect_runtime__Types, Stdio__Out_channel, Stdlib, Stdlib__Filename, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Stdlib = global_data.Stdlib,
    Base_String = global_data.Base__String,
    Stdio_Out_channel = global_data.Stdio__Out_channel,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Make_corrected_file = global_data.Make_corrected_file,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_Comparable = global_data.Base__Comparable,
    Base_List = global_data.Base__List,
    Patch_with_file_contents = [0],
    cst_corrected = ".corrected",
    cst_corrected_tmp = ".corrected.tmp";
   function f
   (use_color,
    in_place,
    diff_command,
    diff_path_prefix,
    filename,
    with$0,
    corrections$0){
    var
     dot_corrected = caml_call2(Base[241], filename, cst_corrected),
     in_channel = caml_call1(Stdlib[79], filename),
     _d_ = caml_call1(Stdlib[92], in_channel),
     original_file_contents = caml_call2(Stdlib[86], in_channel, _d_);
    caml_call1(Stdlib[93], in_channel);
    function remove(file){
     if(runtime.caml_sys_file_exists(file)) runtime.caml_sys_remove(file);
     return;
    }
    var
     corrections$1 = caml_call2(with$0, original_file_contents, corrections$0),
     _a_ =
       caml_call2
        (Base_Comparable[2], Ppx_expect_runtime_Types[2][2], Base[242]),
     corrections = caml_call2(Base_List[83], corrections$1, _a_);
    function _b_(l_pos, param){
     var
      correction = param[2],
      match = param[1],
      end_pos = match[3],
      start_pos = match[2],
      code_chunk =
        caml_call3
         (Base_String[3],
          original_file_contents,
          l_pos,
          start_pos - l_pos | 0);
     return [0, end_pos, [0, code_chunk, [0, correction, 0]]];
    }
    var
     match = caml_call3(Base_List[96], corrections, 0, _b_),
     strs = match[2],
     l_pos = match[1],
     _c_ = caml_call1(Base_List[11], strs),
     result = caml_call2(Base_String[68], 0, _c_),
     rest = caml_call3(Base_String[5], [0, l_pos], 0, original_file_contents),
     next_contents = caml_call2(Base[241], result, rest);
    if(in_place){
     if
      (1 - caml_call2(Base_String[134], original_file_contents, next_contents))
      caml_call2(Stdio_Out_channel[37], filename, next_contents);
     remove(dot_corrected);
     return 0;
    }
    if(diff_command && ! runtime.caml_string_notequal(diff_command[1], "-")){
     caml_call2(Stdio_Out_channel[37], dot_corrected, next_contents);
     return 0;
    }
    var
     _e_ = caml_call1(Stdlib_Filename[13], filename),
     _f_ = [0, caml_call1(Stdlib_Filename[14], filename)],
     tmp_corrected =
       caml_call3(Stdlib_Filename[16], _f_, _e_, cst_corrected_tmp);
    return 0
            ===
             caml_call8
               (Make_corrected_file[1],
                0,
                [0, tmp_corrected],
                [0, use_color],
                diff_command,
                diff_path_prefix,
                next_contents,
                filename,
                0)
              [0]
            ? (remove(dot_corrected), remove(tmp_corrected), 0)
            : (runtime.caml_sys_rename(tmp_corrected, dot_corrected), 1);
   }
   var Ppx_expect_runtime_Write_corre = [0, Patch_with_file_contents, f];
   runtime.caml_register_global
    (12,
     Ppx_expect_runtime_Write_corre,
     "Ppx_expect_runtime__Write_corrected_file");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Output
//# unitInfo: Requires: Base, Base__List, Base__Printf, Base__String, Ppx_expect_runtime__Types
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_Printf = global_data.Base__Printf,
    Base_String = global_data.Base__String,
    Base = global_data.Base,
    Base_List = global_data.Base__List,
    Type = [0],
    compare = Base[195],
    Formatted = [0],
    _g_ =
      [0,
       [12, 123, [2, 0, [2, 0, [12, 124, [2, 0, [11, "|}", 0]]]]]],
       "{%s%s|%s|}"],
    _f_ =
      [0,
       [12,
        123,
        [2,
         0,
         [2,
          0,
          [12, 32, [2, 0, [12, 124, [2, 0, [12, 124, [2, 0, [12, 125, 0]]]]]]]]]],
       "{%s%s %s|%s|%s}"],
    _h_ =
      [0,
       [12, 91, [2, 0, [2, 0, [12, 32, [2, 0, [12, 93, 0]]]]]],
       "[%s%s %s]"],
    _d_ = [0, [12, 123, [2, 0, [12, 124, 0]]], "{%s|"],
    _e_ = [0, [12, 124, [2, 0, [12, 125, 0]]], "|%s}"],
    cst_xxx = "xxx",
    _a_ = [0, "\n"],
    _b_ =
      [0,
       [12, 123, [2, 0, [12, 124, [2, 0, [12, 124, [2, 0, [12, 125, 0]]]]]]],
       "{%s|%s|%s}"],
    _c_ = [0, [12, 34, [2, 0, [12, 34, 0]]], '"%s"'];
   function create(format){return format;}
   function apply(format, str){return caml_call1(format, str);}
   var Formatter = [0, create, apply];
   function compare$0(a, b){
    if(! a) return b ? -1 : 0;
    if(! b) return 1;
    var b$0 = b[1], a$0 = a[1];
    return caml_call2(compare, a$0, b$0);
   }
   var Test_result = [0, compare$0];
   function default$0(contents){
    return [0, contents, Ppx_expect_runtime_Types[5][4][1]];
   }
   function to_source_code_string(param){
    var tag = param[2], test_output = param[1];
    if(tag){
     var tag$0 = tag[1];
     return caml_call4(Base_Printf[2], _b_, tag$0, test_output, tag$0);
    }
    var
     _k_ = caml_call2(Base_String[102], test_output, 10),
     _l_ = caml_call2(Base_List[53], _k_, Base_String[69]),
     _m_ = caml_call1(caml_call1(Base_String[68], _a_), _l_);
    return caml_call2(Base_Printf[2], _c_, _m_);
   }
   var Payload = [0, default$0, to_source_code_string];
   function reconcile(expected_output, test_output){
    return caml_call2(Base_String[134], expected_output, test_output)
            ? 0
            : [0, test_output];
   }
   function fail(error_output){return [0, error_output];}
   function fix_delimiter_conflicts(contents, delimiter){
    if(! delimiter) return 0;
    var tag$1 = delimiter[1], tag = tag$1;
    for(;;){
     var
      tag_conflicts_with$0 =
        function(tag){
         function tag_conflicts_with(fstr){
          var _j_ = caml_call2(Base_Printf[2], fstr, tag);
          return caml_call2(Base_String[92], contents, _j_);
         }
         return tag_conflicts_with;
        },
      tag_conflicts_with = tag_conflicts_with$0(tag);
     if(! tag_conflicts_with(_d_) && ! tag_conflicts_with(_e_))
      return [0, tag];
     var tag$0 = caml_call2(Base[241], tag, cst_xxx), tag = tag$0;
    }
   }
   function to_formatted_payload(param, contents){
    return [0, contents, fix_delimiter_conflicts(contents, param)];
   }
   function to_source_code_string$0
   (expect_node_formatting, shape, tag, contents){
    var
     delimiter =
       fix_delimiter_conflicts
        (contents,
         caml_call2(Ppx_expect_runtime_Types[5][4][2], tag, shape[2])),
     payload = [0, contents, delimiter];
    if(shape[2]){
     var prefix = expect_node_formatting[3], tag$0 = delimiter[1];
     return runtime.caml_string_notequal(tag$0, "")
             ? caml_call6
               (Base_Printf[2], _f_, prefix, shape[1], tag$0, contents, tag$0)
             : caml_call4(Base_Printf[2], _g_, prefix, shape[1], contents);
    }
    var
     prefix$0 =
       shape[3] ? expect_node_formatting[3] : expect_node_formatting[4],
     _i_ = caml_call1(Payload[2], payload);
    return caml_call4(Base_Printf[2], _h_, prefix$0, shape[1], _i_);
   }
   var
    Ppx_expect_runtime_Output =
      [0,
       Type,
       Formatted,
       [0],
       Formatter,
       Test_result,
       Payload,
       reconcile,
       fail,
       to_formatted_payload,
       to_source_code_string$0];
   runtime.caml_register_global
    (15, Ppx_expect_runtime_Output, "Ppx_expect_runtime__Output");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Expectation_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Insert_loc = [0],
    Behavior_type = [0],
    Expect_reachability = [0],
    On_unreachable = [0],
    Behavior = [0],
    Definitions =
      [0,
       Insert_loc,
       Behavior_type,
       Expect_reachability,
       On_unreachable,
       Behavior],
    Ppx_expect_runtime_Expectation = [0, Definitions];
   runtime.caml_register_global
    (0,
     Ppx_expect_runtime_Expectation,
     "Ppx_expect_runtime__Expectation_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Expectation
//# unitInfo: Requires: Base, Base__Char, Base__Int, Base__List, Base__Staged, Base__String, Ppx_expect_runtime__Expectation_intf, Ppx_expect_runtime__Output, Ppx_expect_runtime__Types
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$7 = "",
    cst$6 = " ",
    cst_expect$0 = "expect",
    cst_expect_uncaught_exn = "expect.uncaught_exn",
    cst_test_output$2 = "test output",
    cst_uncaught_exception$1 = "uncaught exception",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$5 = cst$6,
    cst$4 = cst$7,
    cst$0 = cst$7,
    cst$1 = cst$6,
    cst$2 = cst$6,
    cst$3 = cst$7,
    cst = cst$7,
    last_line = cst$6,
    first_line = cst$6,
    Ppx_expect_runtime_Output = global_data.Ppx_expect_runtime__Output,
    Base_Staged = global_data.Base__Staged,
    Base = global_data.Base,
    Base_String = global_data.Base__String,
    Base_Int = global_data.Base__Int,
    Base_List = global_data.Base__List,
    Base_Char = global_data.Base__Char,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    cst_uncaught_exception$0 = cst_uncaught_exception$1,
    _g_ = [0, cst_expect_uncaught_exn, 0, 0],
    _h_ = [1, 1],
    cst_trailing_output = "trailing output",
    _f_ = [0, cst_expect$0, 0, 1],
    cst_uncaught_exception = cst_uncaught_exception$1,
    _e_ = [0, cst_expect_uncaught_exn, 0, 0],
    cst_test_output$1 = cst_test_output$2,
    _c_ = [0, cst_expect$0, 0, 1],
    _d_ = [1, 0],
    cst_test_output$0 = cst_test_output$2,
    cst_expect_exact = "expect_exact",
    cst_test_output = cst_test_output$2,
    cst_expect = cst_expect$0,
    _b_ = [0, cst$6, 0],
    _a_ = [0, "\n"];
   function loc(param){
    if(0 === param[0]){var whole_node = param[1]; return whole_node;}
    var loc = param[1][1];
    return loc;
   }
   var Insert_loc = [0, loc];
   function with_behavior(param, behavior){
    var
     inconsistent_outputs_message = param[5],
     on_incorrect_output = param[4],
     payload_type = param[3],
     position = param[1];
    return [0,
            position,
            behavior,
            payload_type,
            on_incorrect_output,
            inconsistent_outputs_message];
   }
   function formatter(expect_node_formatting, param){
    var
     on_incorrect_output = param[4],
     payload_type = param[3],
     behavior = param[2],
     position = param[1],
     _r_ =
       payload_type
        ? function
         (str){
          var
           _s_ = caml_call1(Base_String[104], str),
           func = Base_List[53],
           _t_ =
             caml_call2
              (func, _s_, caml_call1(Base_String[108], [0, Base_Char[45]])),
           _u_ = caml_call2(Base_List[142], _t_, Base_String[14]),
           _v_ = caml_call1(Base_List[63], _u_),
           _w_ = caml_call2(Base_List[142], _v_, Base_String[14]),
           stripped = caml_call1(Base_List[63], _w_);
          function _x_(line){
           var
            _J_ = caml_call2(Base_String[109], 0, line),
            _H_ = caml_call1(Base_String[25], line),
            func = Base_List[141],
            _I_ = caml_call2(func, _H_, caml_call1(Base_Char[12], 32));
           return [0, caml_call1(Base_List[45], _I_), _J_];
          }
          var
           indent_and_contents = caml_call2(Base_List[53], stripped, _x_),
           _y_ = Base_List[13],
           _z_ =
             caml_call2
              (_y_,
               indent_and_contents,
               function(param){
                var indent = param[1];
                return caml_string_notequal(param[2], cst$7) ? [0, indent] : 0;
               }),
           match = caml_call2(Base_List[31], _z_, Base_Int[14]);
          if(match)
           var
            min_indent = match[1],
            _A_ =
              function(param){
               var line = param[2], indent = param[1];
               return [0,
                       caml_call2(Base_Int[16], 0, indent - min_indent | 0),
                       line];
              },
            lines = caml_call2(Base_List[53], indent_and_contents, _A_);
          else
           var lines = 0;
          if(0 === behavior[0])
           var tag = behavior[1][2], tag$0 = tag;
          else
           var tag$0 = Ppx_expect_runtime_Types[5][4][1];
          var _B_ = expect_node_formatting[2];
          if(! lines) return tag$0 ? cst$2 : cst$3;
          if(! lines[2] && ! _B_){
           var line = lines[1][2];
           return tag$0
                   ? caml_call2(Base_String[68], 0, [0, cst$1, [0, line, _b_]])
                   : line;
          }
          if(0 === position[0])
           var
            match$0 = position[1],
            start_pos = match$0[2],
            start_bol = match$0[1],
            _C_ = start_pos - start_bol | 0;
          else
           var
            match$1 = position[1][2],
            start_pos$0 = match$1[2],
            start_bol$0 = match$1[1],
            _F_ = on_incorrect_output[3] ? expect_node_formatting[1] : 0,
            _C_ = (start_pos$0 - start_bol$0 | 0) + _F_ | 0;
          var location_indent = expect_node_formatting[1] + _C_ | 0;
          function spaces(n){return caml_call2(Base_String[66], n, 32);}
          if(tag$0)
           var
            last_line$0 = spaces(location_indent),
            indentation = location_indent,
            first_line$0 = cst;
          else
           var
            last_line$0 = last_line,
            indentation = 1,
            first_line$0 = first_line;
          function _D_(param){
           var indent = param[1];
           if(! caml_string_notequal(param[2], cst$7)) return cst$0;
           var line = param[2], _G_ = spaces(indentation + indent | 0);
           return caml_call2(Base[241], _G_, line);
          }
          var
           lines$0 = caml_call2(Base_List[53], lines, _D_),
           _E_ =
             caml_call1
              (Base_List[11],
               [0,
                [0, first_line$0, 0],
                [0, lines$0, [0, [0, last_line$0, 0], 0]]]);
          return caml_call1(caml_call1(Base_String[68], _a_), _E_);
         }
        : function(_K_){return _K_;};
    return caml_call1(Ppx_expect_runtime_Output[4][1], _r_);
   }
   function extension_syntax(extension_name, payload_loc, node_loc){
    if(payload_loc){
     var
      payload_loc$0 = payload_loc[1],
      _p_ = payload_loc$0[2] <= node_loc[2] ? 1 : 0,
      _q_ = _p_ ? node_loc[3] <= payload_loc$0[3] ? 1 : 0 : _p_;
     if(_q_) return [0, extension_name, 1, 1];
    }
    return [0, extension_name, 0, 1];
   }
   function possibly_relax_strictness(formatting_flexibility, t){
    if(! formatting_flexibility) return t;
    var
     expect_node_formatting = formatting_flexibility[1],
     fmt = formatter(expect_node_formatting, t),
     _n_ = t[2],
     reachability = _n_[3],
     on_unreachable = _n_[2],
     match = _n_[1],
     tag = match[2],
     contents = match[1],
     _o_ = caml_call2(Ppx_expect_runtime_Output[4][2], fmt, contents),
     match$0 = caml_call2(Ppx_expect_runtime_Output[7], contents, _o_);
    if(! match$0) return t;
    var
     contents$0 = match$0[1],
     payload = caml_call2(Ppx_expect_runtime_Output[9], tag, contents$0);
    return with_behavior(t, [0, payload, on_unreachable, reachability]);
   }
   function expected_string_and_payload_lo(param){
    if(! param)
     return [0, caml_call1(Ppx_expect_runtime_Output[6][1], cst$4), 0];
    var match = param[1], b = match[2], a = match[1];
    return [0, a, [0, b]];
   }
   function expect(formatting_flexibility, node_loc, located_payload){
    var
     match = expected_string_and_payload_lo(located_payload),
     payload_loc = match[2],
     payload = match[1];
    return possibly_relax_strictness
            (formatting_flexibility,
             [0,
              [0, node_loc, payload_loc],
              [0, payload, 2, 0],
              1,
              extension_syntax(cst_expect, payload_loc, node_loc),
              cst_test_output]);
   }
   function expect_exact(formatting_flexibility, node_loc, located_payload){
    var
     match = expected_string_and_payload_lo(located_payload),
     payload_loc = match[2],
     payload = match[1];
    return possibly_relax_strictness
            (formatting_flexibility,
             [0,
              [0, node_loc, payload_loc],
              [0, payload, 2, 0],
              0,
              extension_syntax(cst_expect_exact, payload_loc, node_loc),
              cst_test_output$0]);
   }
   function expect_unreachable(node_loc){
    return [0, [0, node_loc, 0], _d_, 1, _c_, cst_test_output$1];
   }
   function expect_uncaught_exn
   (formatting_flexibility, node_loc, located_payload){
    var
     match = expected_string_and_payload_lo(located_payload),
     payload_loc = match[2],
     payload = match[1];
    return possibly_relax_strictness
            (formatting_flexibility,
             [0,
              [0, node_loc, payload_loc],
              [0, payload, 1, 1],
              1,
              _e_,
              cst_uncaught_exception]);
   }
   function expect_trailing(insert_loc){
    return [0,
            [1, insert_loc],
            [0, caml_call1(Ppx_expect_runtime_Output[6][1], cst$5), 0, 0],
            1,
            _f_,
            cst_trailing_output];
   }
   function expect_no_uncaught_exn(insert_loc){
    return [0, [1, insert_loc], _h_, 1, _g_, cst_uncaught_exception$0];
   }
   function format_payload(mk_node){
    function _k_(expect_node_formatting, payload_loc, node_loc, tag, contents){
     var
      node =
        caml_call3
         (mk_node, 0, node_loc, [0, [0, [0, contents, tag], payload_loc]]),
      _l_ = formatter(expect_node_formatting, node),
      formatted_contents =
        caml_call2(Ppx_expect_runtime_Output[4][2], _l_, contents),
      match =
        caml_call2(Ppx_expect_runtime_Output[7], contents, formatted_contents);
     if(! match) return 0;
     var contents$0 = match[1], node_shape = node[4];
     if(node_shape[2])
      var
       source_code_string =
         caml_call4
          (Ppx_expect_runtime_Output[10],
           expect_node_formatting,
           node_shape,
           tag,
           contents$0);
     else
      var
       _m_ = caml_call2(Ppx_expect_runtime_Output[9], tag, contents$0),
       source_code_string = caml_call1(Ppx_expect_runtime_Output[6][2], _m_);
     return [0, source_code_string];
    }
    return caml_call1(Base_Staged[1], _k_);
   }
   var
    _i_ = format_payload(expect),
    format_expect_payload = caml_call1(Base_Staged[2], _i_),
    _j_ = format_payload(expect_uncaught_exn),
    format_uncaught_exn_payload = caml_call1(Base_Staged[2], _j_),
    Ppx_expect_runtime_Expectation =
      [0,
       Insert_loc,
       with_behavior,
       formatter,
       expect,
       expect_exact,
       expect_unreachable,
       expect_uncaught_exn,
       expect_trailing,
       expect_no_uncaught_exn,
       [0, format_expect_payload, format_uncaught_exn_payload]];
   runtime.caml_register_global
    (35, Ppx_expect_runtime_Expectation, "Ppx_expect_runtime__Expectation");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Test_node
//# unitInfo: Requires: Base, Base__Char, Base__Comparable, Base__Error, Base__Hashtbl, Base__List, Base__Option, Base__Printf, Base__Queue, Base__String, Ppx_expect_runtime__Expectation, Ppx_expect_runtime__Output, Ppx_expect_runtime__Types
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$4 = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    tag = [0, cst$4],
    cst$3 = cst$4,
    cst$2 = ";",
    cst = cst$4,
    cst$0 = "\n",
    cst$1 = cst$4,
    Ppx_expect_runtime_Output = global_data.Ppx_expect_runtime__Output,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Ppx_expect_runtime_Expectation =
      global_data.Ppx_expect_runtime__Expectation,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Base_List = global_data.Base__List,
    Base = global_data.Base,
    Base_Comparable = global_data.Base__Comparable,
    Base_Option = global_data.Base__Option,
    Base_Queue = global_data.Base__Queue,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_Printf = global_data.Base__Printf,
    Base_Error = global_data.Base__Error,
    _e_ =
      [0,
       [11,
        "Internal expect test bug: could not find test\nFile: ",
        [2, 0, [11, "\nID:   ", [4, 0, 0, 0, 0]]]],
       "Internal expect test bug: could not find test\nFile: %s\nID:   %d"],
    _c_ =
      [0,
       [11, "<expect test ran without ", [2, 0, [12, 62, 0]]],
       "<expect test ran without %s>"],
    _b_ = [0, 0],
    _a_ =
      [0,
       [12, 91, [2, 0, [11, "expect.unreachable]", 0]]],
       "[%sexpect.unreachable]"];
   function record_and_return_result
   (expect_node_formatting, failure_ref, test_output_raw, t){
    var
     results = t[2],
     expectation = t[1],
     _P_ =
       caml_call2
        (Ppx_expect_runtime_Expectation[3],
         expect_node_formatting,
         expectation),
     test_output =
       caml_call2(Ppx_expect_runtime_Output[4][2], _P_, test_output_raw),
     _Q_ = expectation[2];
    if(0 === _Q_[0])
     var
      match = _Q_[1],
      tag$0 = match[2],
      contents = match[1],
      tag$1 = tag$0,
      result = caml_call2(Ppx_expect_runtime_Output[7], contents, test_output);
    else
     var
      result$0 = caml_call1(Ppx_expect_runtime_Output[8], test_output),
      tag$1 = tag,
      result = result$0;
    if(result) failure_ref[1] = 1;
    caml_call2(Base_Queue[35], results, [0, [0, result, test_output_raw]]);
    t[3] = 1;
    return [0, result, tag$1];
   }
   function of_expectation(expectation){
    return [0, [0, expectation, caml_call2(Base_Queue[58], 0, 0), 0]];
   }
   function record_end_of_run(t){
    var
     match = t[1],
     results = match[2],
     reached_this_run = match[3],
     _O_ = 1 - reached_this_run;
    return _O_ ? caml_call2(Base_Queue[35], results, 0) : _O_;
   }
   function record_result
   (expect_node_formatting, failure_ref, test_output_raw, param){
    var inner = param[1];
    record_and_return_result
     (expect_node_formatting, failure_ref, test_output_raw, inner);
    return 0;
   }
   function _d_(_N_){return runtime.Base_hash_string(_N_);}
   var
    global_results_table =
      caml_call3
       (Base_Hashtbl[4], 0, 0, [0, Base_String[51], Base_String[42], _d_]);
   function find_test(absolute_filename, test_id){
    var
     _I_ =
       caml_call2(Base_Hashtbl[56], global_results_table, absolute_filename),
     _J_ = Base_Option[22],
     _K_ =
       caml_call2
        (_J_,
         _I_,
         function(param){
          var expectations = param[1];
          return caml_call2(Base_Hashtbl[56], expectations, test_id);
         }),
     func = Base_Option[31],
     _L_ = caml_call1(Ppx_expect_runtime_Types[4][2], test_id),
     _M_ = caml_call3(Base_Printf[2], _e_, absolute_filename, _L_);
    return caml_call2
            (caml_call2(func, 0, [0, caml_call1(Base_Error[14], _M_)]),
             0,
             _K_);
   }
   function initialize_and_register_tests
   (absolute_filename, tests, postprocess){
    var tests_as_in_table = caml_call2(Base_Queue[58], 0, 0);
    function _D_(file){
     var
      _E_ = Ppx_expect_runtime_Types[4],
      _F_ =
        [0,
         caml_call3(Base_Hashtbl[4], 0, 0, [0, _E_[3], _E_[4], _E_[5]]),
         postprocess],
      file$0 = caml_call2(Base_Option[30], file, _F_),
      _G_ = Ppx_expect_runtime_Types[4],
      tests$0 =
        caml_call4(Base_Hashtbl[8], 0, 0, [0, _G_[3], _G_[4], _G_[5]], tests);
     function _H_(test_id, new_test, existing_test){
      var test = caml_call2(Base_Option[30], existing_test, new_test);
      test[1][3] = 0;
      caml_call2(Base_Queue[35], tests_as_in_table, [0, test_id, test]);
      return [0, test];
     }
     caml_call3(Base_Hashtbl[66], tests$0, file$0[1], _H_);
     return file$0;
    }
    caml_call3(Base_Hashtbl[41], global_results_table, absolute_filename, _D_);
    return caml_call1(Base_Queue[20], tests_as_in_table);
   }
   function process_each_file(f){
    var
     _A_ = caml_call1(Base_Hashtbl[78], global_results_table),
     func = Base_List[83],
     _B_ =
       caml_call2
        (func,
         _A_,
         caml_call2(Base_Comparable[2], Base_String[51], Base[242])),
     _C_ = Base_List[53];
    return caml_call2
            (_C_,
             _B_,
             function(param){
              var
               match = param[2],
               postprocess = match[2],
               expectations = match[1],
               filename = param[1],
               test_nodes = caml_call1(Base_Hashtbl[68], expectations);
              return caml_call3(f, filename, test_nodes, postprocess);
             });
   }
   function expect(formatting_flexibility, node_loc, located_payload){
    return of_expectation
            (caml_call3
              (Ppx_expect_runtime_Expectation[4],
               formatting_flexibility,
               node_loc,
               located_payload));
   }
   function expect_exact(formatting_flexibility, node_loc, located_payload){
    return of_expectation
            (caml_call3
              (Ppx_expect_runtime_Expectation[5],
               formatting_flexibility,
               node_loc,
               located_payload));
   }
   function expect_unreachable(node_loc){
    return of_expectation
            (caml_call1(Ppx_expect_runtime_Expectation[6], node_loc));
   }
   var Create = [0, expect, expect_exact, expect_unreachable];
   function loc(param){
    var position = param[1][1][1];
    return caml_call1(Ppx_expect_runtime_Expectation[1][1], position);
   }
   function expectation_of_t(param){
    var expectation = param[1][1], _z_ = expectation[2];
    if(0 !== _z_[0]) return 0;
    var contents = _z_[1][1];
    return [0, contents];
   }
   function record_and_return_number_of_li
   (expect_node_formatting, failure_ref, test_output_raw, param){
    var
     _w_ =
       record_and_return_result
        (expect_node_formatting, failure_ref, test_output_raw, param[1]),
     match = _w_[1];
    if(! match) return 0;
    var
     tag = _w_[2],
     contents = match[1],
     _x_ = caml_call2(Ppx_expect_runtime_Output[9], tag, contents),
     correction = caml_call1(Ppx_expect_runtime_Output[6][2], _x_),
     _y_ = caml_call1(Base_Char[16], 10);
    return [0, caml_call2(Base_String[21], correction, _y_) + 1 | 0];
   }
   function to_diffs
   (cr_for_multiple_outputs,
    expect_node_formatting,
    original_file_contents,
    t){
    var
     match$4 = t[1],
     results = match$4[2],
     expectation = match$4[1],
     results_list = caml_call1(Base_Queue[20], results);
    function _p_(param){
     if(! param) return _b_;
     var output = param[1];
     return [1, output];
    }
    var
     match$5 = caml_call2(Base_List[16], results_list, _p_),
     outputs_list = match$5[2],
     unreached_list = match$5[1];
    function _q_(param){var result = param[1]; return result;}
    var
     _r_ =
       caml_call2(Base_Comparable[2], Ppx_expect_runtime_Output[5][1], _q_),
     distinct_outputs = caml_call2(Base_List[126], outputs_list, _r_),
     was_reached = caml_call1(Base_List[18], unreached_list),
     match$6 = expectation[2];
    if(0 === match$6[0])
     var reachability = match$6[3], reachability_behavior = reachability;
    else
     var
      reachability_of_corrected = match$6[1],
      reachability_behavior = reachability_of_corrected;
    function correction_for_single_result(param){
     if(! param) return 0;
     var received = param[1];
     return [0, [0, expectation, received]];
    }
    a:
    if(distinct_outputs){
     b:
     if(! distinct_outputs[2]){
      var result = distinct_outputs[1][1];
      if(! was_reached && reachability_behavior) break b;
      var match$7 = correction_for_single_result(result);
      break a;
     }
     var
      _s_ = Base_List[53],
      outputs =
        caml_call2
         (_s_,
          results_list,
          function(param){
           if(! param) return caml_call2(Base_Printf[2], _c_, expectation[5]);
           var raw = param[1][2];
           return raw;
          }),
      _t_ = caml_call2(cr_for_multiple_outputs, expectation[5], outputs),
      _u_ =
        caml_call2
         (Ppx_expect_runtime_Expectation[3],
          expect_node_formatting,
          expectation),
      _v_ = caml_call1(caml_call1(Ppx_expect_runtime_Output[4][2], _u_), _t_),
      match$7 =
        correction_for_single_result
         (caml_call1(Ppx_expect_runtime_Output[8], _v_));
    }
    else
     var
      behavior$0 = expectation[2],
      match$7 =
        0 === behavior$0[0]
         ? [0,
           [1,
            caml_call2
             (Ppx_expect_runtime_Expectation[2], expectation, behavior$0)]]
         : 0;
    if(! match$7) return 0;
    var correction$2 = match$7[1];
    function safe_byte_get(string, i){
     if(0 <= i && i < runtime.caml_ml_string_length(string))
      return [0, runtime.caml_string_get(string, i)];
     return 0;
    }
    if(0 === correction$2[0]){
     var
      _f_ = correction$2[1],
      on_incorrect_output = _f_[4],
      test_output = correction$2[2],
      behavior = _f_[2],
      position = _f_[1];
     if(0 === position[0])
      var whitespace = cst;
     else
      var
       match = position[1][2],
       start_pos = match[2],
       start_bol = match[1],
       let_offset = start_pos - start_bol | 0,
       _j_ = on_incorrect_output[3] ? expect_node_formatting[1] : 0,
       indent = let_offset + _j_ | 0,
       _k_ = caml_call2(Base_String[66], indent, 32),
       whitespace$0 = caml_call2(Base[241], cst$0, _k_),
       whitespace = whitespace$0;
     if(0 === behavior[0])
      var tag = behavior[1][2], tag$0 = tag;
     else
      var tag$0 = Ppx_expect_runtime_Types[5][4][1];
     a:
     {
      if(0 === position[0]){
       var _h_ = position[2], _g_ = position[1];
       if(_h_ && ! on_incorrect_output[2] && on_incorrect_output[3]){
        var
         payload_loc = _h_[1],
         _i_ = caml_call2(Ppx_expect_runtime_Output[9], tag$0, test_output),
         correction$1 = caml_call1(Ppx_expect_runtime_Output[6][2], _i_),
         correction$0 = correction$1,
         loc$0 = payload_loc;
        break a;
       }
       var loc = _g_;
      }
      else
       var loc = position[1][1];
      var
       correction =
         caml_call4
          (Ppx_expect_runtime_Output[10],
           expect_node_formatting,
           on_incorrect_output,
           tag$0,
           test_output),
       correction$0 = correction,
       loc$0 = loc;
     }
     var
      match$0 =
        [0, [0, loc$0, caml_call2(Base[241], whitespace, correction$0)]];
    }
    else{
     var
      _l_ = correction$2[1],
      on_incorrect_output$0 = _l_[4],
      on_unreachable = _l_[2][2],
      position$0 = _l_[1],
      loc$1 = caml_call1(Ppx_expect_runtime_Expectation[1][1], position$0);
     switch(on_unreachable){
       case 0:
        var match$0 = 0; break;
       case 1:
        var match$0 = [0, [0, loc$1, cst$1]]; break;
       default:
        var
         prefix =
           on_incorrect_output$0[3]
            ? expect_node_formatting[3]
            : expect_node_formatting[4],
         match$0 = [0, [0, loc$1, caml_call2(Base_Printf[2], _a_, prefix)]];
     }
    }
    if(! match$0) return 0;
    var
     match$1 = match$0[1],
     diff = match$1[2],
     loc$2 = match$1[1],
     end_pos = loc$2[3],
     start_pos$0 = loc$2[2],
     start_bol$0 = loc$2[1],
     main_correction = [0, [0, loc$2, diff], 0];
    a:
    {
     if(1 === correction$2[0] && ! correction$2[1][4][3]){
      var
       match$2 = safe_byte_get(original_file_contents, start_pos$0 - 1 | 0),
       match$3 = safe_byte_get(original_file_contents, end_pos);
      b:
      {
       c:
       if(match$2 && 10 === match$2[1]){
        if(match$3 && 10 !== match$3[1]) break c;
        var
         _o_ =
           [0, [0, [0, start_bol$0, start_pos$0 - 1 | 0, start_pos$0], cst$3]];
        break b;
       }
       var _o_ = 0;
      }
      var remove_empty_line_from_deleted = _o_;
      break a;
     }
     var remove_empty_line_from_deleted = 0;
    }
    a:
    {
     if(0 === correction$2[0]){
      var _m_ = correction$2[1], _n_ = _m_[1];
      if(0 !== _n_[0] && _m_[4][3]){
       var
        body_loc = _n_[1][2],
        add_semicolon_before_trailing_ =
          [0, [0, [0, body_loc[1], body_loc[3], body_loc[3]], cst$2]];
       break a;
      }
     }
     var add_semicolon_before_trailing_ = 0;
    }
    var
     additional_corrections =
       caml_call2
        (Base_List[14],
         [0,
          remove_empty_line_from_deleted,
          [0, add_semicolon_before_trailing_, 0]],
         Base_Option[42]);
    return caml_call2(Base[222], additional_corrections, main_correction);
   }
   var
    Ppx_expect_runtime_Test_node =
      [0,
       Create,
       of_expectation,
       record_end_of_run,
       record_result,
       [0, initialize_and_register_tests, find_test, process_each_file],
       [0, expectation_of_t, record_and_return_number_of_li, loc, to_diffs]];
   runtime.caml_register_global
    (23, Ppx_expect_runtime_Test_node, "Ppx_expect_runtime__Test_node");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Current_file
//# unitInfo: Requires: Base, Base__Or_error, Base__Printf, Base__String, CamlinternalLazy, Stdlib__Filename, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_String = global_data.Base__String,
    Base = global_data.Base,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Filename = global_data.Stdlib__Filename,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Or_error = global_data.Base__Or_error,
    current = [0, 0],
    _c_ =
      [0,
       [11,
        "Trying to run an expect test from the wrong file.\n- test declared at ",
        [2,
         0,
         [12,
          58,
          [4,
           0,
           0,
           0,
           [11, "\n- trying to run it from ", [2, 0, [12, 10, 0]]]]]]],
       "Trying to run an expect test from the wrong file.\n- test declared at %s:%d\n- trying to run it from %s\n"],
    cst_Expect_test_collector_get_ =
      "Expect_test_collector.get: there is no active file",
    cst_Expect_test_collector_unse =
      "Expect_test_collector.unset: there is no active file",
    cst_new_file = "new_file",
    cst_old_file = "old_file",
    cst_Expect_test_collector_set_ =
      "Expect_test_collector.set: there is already an active file",
    _b_ = [0, 1];
   function set(filename_rel_to_project_root){
    var match = current[1];
    if(match){
     var
      current$0 = match[1],
      _j_ =
        [0,
         [0,
          cst_new_file,
          caml_call1(Base[202], filename_rel_to_project_root)],
         0],
      _k_ = [0, [0, cst_old_file, caml_call1(Base[202], current$0)], _j_],
      _l_ = caml_call2(Base[85][8], cst_Expect_test_collector_set_, _k_);
     return caml_call1(Base[246], _l_);
    }
    current[1] = [0, filename_rel_to_project_root];
    return 0;
   }
   function unset(param){
    if(current[1]){current[1] = 0; return 0;}
    var _i_ = caml_call2(Base[85][8], cst_Expect_test_collector_unse, 0);
    return caml_call1(Base[246], _i_);
   }
   function get(param){
    var match = current[1];
    if(match){var fn = match[1]; return fn;}
    var _h_ = caml_call2(Base[85][8], cst_Expect_test_collector_get_, 0);
    return caml_call1(Base[246], _h_);
   }
   function _a_(_g_){return runtime.caml_sys_getcwd(_g_);}
   var
    dir_or_error = caml_call2(Base_Or_error[31], _b_, _a_),
    initial_dir =
      [246,
       function(_f_){return caml_call1(Base_Or_error[34], dir_or_error);}];
   function absolute_path(file){
    if(! caml_call1(Stdlib_Filename[5], file)) return file;
    var _d_ = runtime.caml_obj_tag(initial_dir);
    a:
    if(250 === _d_)
     var _e_ = initial_dir[1];
    else{
     if(246 !== _d_ && 244 !== _d_){var _e_ = initial_dir; break a;}
     var _e_ = caml_call1(CamlinternalLazy[2], initial_dir);
    }
    return caml_call2(Stdlib_Filename[4], _e_, file);
   }
   function verify_that_file_is_current_ex
   (line_number, filename_rel_to_project_root){
    var registering_tests_for = get(0);
    return caml_call2
             (Base_String[134],
              filename_rel_to_project_root,
              registering_tests_for)
            ? 0
            : caml_call5
              (Base_Printf[4],
               Base[244],
               _c_,
               filename_rel_to_project_root,
               line_number,
               registering_tests_for);
   }
   var
    Ppx_expect_runtime_Current_fil =
      [0,
       set,
       unset,
       get,
       initial_dir,
       absolute_path,
       verify_that_file_is_current_ex];
   runtime.caml_register_global
    (13, Ppx_expect_runtime_Current_fil, "Ppx_expect_runtime__Current_file");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime__Test_block
//# unitInfo: Requires: Base, Base__Exn, Base__List, Base__Option, Base__Printf, Base__Source_code_position, Base__String, Expect_test_config, Ppx_expect_runtime__Current_file, Ppx_expect_runtime__Expectation, Ppx_expect_runtime__Test_node, Ppx_expect_runtime__Types, Ppx_inline_test_lib, Stdlib, Stdlib__Filename, Stdlib__Format, Stdlib__Obj, Stdlib__Printexc, Stdlib__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst$5 = "\n",
    cst$6 = "(* ",
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    partial = [12, 10, [10, 0]],
    cst$3 = cst$4,
    cst$1 = "---------------",
    cst$2 = cst$4,
    cst = "\n\n",
    cst$0 = cst$4,
    Expect_test_config = global_data.Expect_test_config,
    Base_Source_code_position = global_data.Base__Source_code_position,
    Base_Printf = global_data.Base__Printf,
    Base = global_data.Base,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Base_Option = global_data.Base__Option,
    Ppx_expect_runtime_Test_node = global_data.Ppx_expect_runtime__Test_node,
    Ppx_expect_runtime_Types = global_data.Ppx_expect_runtime__Types,
    Base_List = global_data.Base__List,
    Ppx_expect_runtime_Current_fil =
      global_data.Ppx_expect_runtime__Current_file,
    Ppx_expect_runtime_Expectation =
      global_data.Ppx_expect_runtime__Expectation,
    Base_String = global_data.Base__String,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Stdlib_Format = global_data.Stdlib__Format,
    _o_ =
      [0,
       [11,
        "Ppx_expect_runtime.read_current_test_output_exn called while there are no tests running at ",
        [2, 0, 0]],
       "Ppx_expect_runtime.read_current_test_output_exn called while there are no tests running at %s"],
    _n_ =
      [0,
       [11,
        "File ",
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11,
            ", characters ",
            [4,
             0,
             0,
             0,
             [12,
              45,
              [4,
               0,
               0,
               0,
               [11,
                ":\nError: program exited while expect test was running!\nOutput captured so far:\n",
                [2, 0, partial]]]]]]]]]],
       "File %S, line %d, characters %d-%d:\nError: program exited while expect test was running!\nOutput captured so far:\n%s\n%!"],
    cst_Trailing_output = "Trailing output",
    _m_ = [0, cst$5],
    _k_ = [0, "line"],
    _l_ = [0, "file"],
    cst_inner_test = "inner_test",
    cst_outer_test = "outer_test",
    cst_Expect_test_runtime_reache =
      "Expect_test_runtime: reached one [let%expect_test] from another. Nesting expect\ntests is prohibited.",
    _i_ =
      [0,
       [11,
        '("',
        [2, 0, [11, '(Cannot print more details, Exn.to_string failed)")', 0]]],
       '("%s(Cannot print more details, Exn.to_string failed)")'],
    _j_ = [0, cst$5],
    _h_ =
      [0,
       "Raised at ",
       [0, "Called from ", [0, "Raised by primitive operation ", 0]]],
    _e_ =
      [0,
       [11,
        "=== Output ",
        [4, 0, 0, 0, [11, " / ", [4, 0, 0, 0, [11, " ===", 0]]]]],
       "=== Output %d / %d ==="],
    _f_ = [0, [2, 0, [2, 0, [2, 0, 0]]], "%s%s%s"],
    _c_ =
      [0,
       [11, "Test ran multiple times with different ", [2, 0, [12, 115, 0]]],
       "Test ran multiple times with different %ss"],
    _d_ =
      [0,
       [11, cst$6, [2, 0, [11, "expect_test: ", [2, 0, [11, " *)", 0]]]]],
       "(* %sexpect_test: %s *)"],
    _g_ = [0, cst$5],
    cst_CR = "CR ",
    _b_ =
      [0,
       [11,
        cst$6,
        [2,
         0,
         [11,
          "expect_test_collector: This test expectation appears to contain a backtrace.\n   This is strongly discouraged as backtraces are fragile.\n   Please change this test to not include a backtrace. *)",
          0]]],
       "(* %sexpect_test_collector: This test expectation appears to contain a backtrace.\n   This is strongly discouraged as backtraces are fragile.\n   Please change this test to not include a backtrace. *)"],
    cst_output = "output",
    cst_expect_test = "expect-test",
    _a_ = [0, 1, [0, 3, 0]];
   function clean_up_block(param){
    var
     test_output_writer = param[5],
     test_output_reader = param[4],
     output_file = param[2];
    caml_call1(Stdlib[93], test_output_reader);
    runtime.ppx_expect_runtime_after_test(Stdlib[39], Stdlib[40]);
    caml_call1(Stdlib[76], test_output_writer);
    runtime.caml_sys_remove(output_file);
    return;
   }
   function flush(param){
    caml_call2(Stdlib_Format[38], Stdlib_Format[110], 0);
    caml_call2(Stdlib_Format[38], Stdlib_Format[112], 0);
    caml_call1(Stdlib[63], Stdlib[39]);
    caml_call1(Stdlib[63], Stdlib[40]);
    runtime.ppx_expect_runtime_flush_stubs_streams(0);
    return;
   }
   function read_test_output_unsanitized(param){
    var old_offset = param[6], test_output_reader = param[4];
    flush(0);
    var
     new_offset = runtime.ppx_expect_runtime_out_channel_position(Stdlib[39]),
     len = new_offset - old_offset[1] | 0;
    old_offset[1] = new_offset;
    return caml_call2(Stdlib[86], test_output_reader, len);
   }
   function Configured(C){
    var
     cr_prefix = 15023 <= C[4] ? cst_CR : cst$0,
     cr_for_backtrace = caml_call2(Base_Printf[2], _b_, cr_prefix);
    function cr_for_multiple_outputs(output_name, outputs){
     var
      cr_body = caml_call2(Base_Printf[2], _c_, output_name),
      cr = caml_call3(Base_Printf[2], _d_, cr_prefix, cr_body),
      num_outputs = caml_call1(Base_List[45], outputs);
     function _W_(index, output){
      var
       header = caml_call3(Base_Printf[2], _e_, index + 1 | 0, num_outputs),
       pad_length =
         caml_ml_string_length(cr) - caml_ml_string_length(header) | 0,
       _X_ = [0, output, 0];
      if(0 < pad_length)
       var
        lpad = caml_call2(Base_String[66], pad_length / 2 | 0, 61),
        rpad =
          caml_call2
           (Base_String[66], pad_length - (pad_length / 2 | 0) | 0, 61),
        _Y_ = caml_call4(Base_Printf[2], _f_, lpad, header, rpad);
      else
       var _Y_ = header;
      return [0, _Y_, _X_];
     }
     var outputs_with_headers = caml_call2(Base_List[44], outputs, _W_);
     return caml_call2(Base_String[68], _g_, [0, cr, outputs_with_headers]);
    }
    var sanitize = C[3];
    function check_for_backtraces(s){
     function _U_(substring){
      return caml_call2(Base_String[92], s, substring);
     }
     if(! caml_call2(Base_List[23], _h_, _U_)) return s;
     var _V_ = caml_call2(Base[241], cst, s);
     return caml_call2(Base[241], cr_for_backtrace, _V_);
    }
    function dump_backtrace(possible_exn){
     try{caml_call1(C[2], possible_exn);}
     catch(exn$0){
      var
       exn = caml_wrap_exception(exn$0),
       bt = caml_call1(Stdlib_Printexc[12], 0);
      try{var _S_ = caml_call1(Base_Exn[10], exn), exn_string = _S_;}
      catch(_T_){
       var
        _Q_ = caml_call1(Stdlib_Obj[23][1], exn),
        name = caml_call1(Stdlib_Obj[23][2], _Q_),
        exn_string = caml_call2(Base_Printf[2], _i_, name);
      }
      var
       bt$0 = caml_call1(Stdlib_Printexc[14], bt),
       _R_ =
         caml_string_notequal(bt$0, cst$4)
          ? caml_call2
            (Base_String[68],
             _j_,
             [0, cr_for_backtrace, [0, exn_string, [0, bt$0, 0]]])
          : exn_string;
      return [0, _R_];
     }
     return 0;
    }
    return [0,
            ,
            ,
            cr_for_multiple_outputs,
            sanitize,
            check_for_backtraces,
            dump_backtrace];
   }
   var test_is_running = [0, 0];
   function am_running_expect_test(param){
    return caml_call1(Base_Option[53], test_is_running[1]);
   }
   function current_test(param){
    function _P_(param){var test_block = param[4]; return test_block;}
    return caml_call2(Base_Option[24], test_is_running[1], _P_);
   }
   function current_test_exn(param){
    var _O_ = current_test(0);
    return caml_call4(Base_Option[31], 0, 0, 0, _O_);
   }
   function iter(f){
    return caml_call2(Base_Option[37], test_is_running[1], f);
   }
   function at_exit(param){
    return iter
            (function(param){
              var
               test_block = param[4],
               match = param[3],
               end_pos = match[3],
               start_pos = match[2],
               start_bol = match[1],
               basename = param[2],
               line_number = param[1];
              flush(0);
              var
               fin = caml_call1(Stdlib[79], test_block[2]),
               _N_ = caml_call1(Stdlib[92], fin),
               all_out = caml_call2(Stdlib[86], fin, _N_);
              clean_up_block(test_block);
              return caml_call6
                      (Stdlib_Printf[3],
                       _n_,
                       basename,
                       line_number,
                       start_pos - start_bol | 0,
                       end_pos - start_bol | 0,
                       all_out);
             });
   }
   function read_current_test_output_exn(here){
    var match = current_test(0);
    if(match){
     var
      test_block = match[1],
      _K_ = read_test_output_unsanitized(test_block);
     return caml_call1(Expect_test_config[3], _K_);
    }
    var
     _L_ = caml_call1(Base_Source_code_position[22], here),
     _M_ = caml_call2(Base_Printf[2], _o_, _L_);
    return caml_call1(Base[244], _M_);
   }
   var
    default_cr_for_multiple_output = Configured(Expect_test_config)[3],
    For_external =
      [0,
       read_current_test_output_exn,
       am_running_expect_test,
       default_cr_for_multiple_output],
    Ppx_expect_runtime_Test_block =
      [0,
       function(C){
        var Configured$0 = Configured(C);
        function read_test_output_no_backtrace_(param){
         var _J_ = read_test_output_unsanitized(current_test_exn(0));
         return caml_call1(Configured$0[4], _J_);
        }
        function read_test_output_sanitized_and(param){
         var _I_ = read_test_output_no_backtrace_(0);
         return Configured$0[5].call(null, _I_);
        }
        function run_test_inner(test_id, test_output_raw, t){
         var
          _H_ = caml_call2(Ppx_expect_runtime_Test_node[5][2], t[1], test_id);
         return caml_call4
                 (Ppx_expect_runtime_Test_node[4],
                  Ppx_expect_runtime_Types[1][1],
                  t[3],
                  test_output_raw,
                  _H_);
        }
        function run_test(test_id){
         var _G_ = current_test_exn(0);
         return run_test_inner
                 (test_id, read_test_output_sanitized_and(0), _G_);
        }
        function run_suite
        (filename_rel_to_project_root,
         line_number,
         location,
         trailing_loc,
         body_loc,
         formatting_flexibility,
         expected_exn,
         test_to_run,
         exn_test_id,
         description,
         tags,
         inline_test_config,
         expectations,
         f){
         var
          end_pos = location[3],
          start_pos = location[2],
          start_bol = location[1],
          basename =
            caml_call1(Stdlib_Filename[13], filename_rel_to_project_root);
         iter
          (function(param){
            var outer_basename = param[2], outer_line_number = param[1];
            function sexp_here(basename, line_number){
             var
              _F_ =
                [0,
                 [1, [0, _k_, [0, caml_call1(Base[136], line_number), 0]]],
                 0];
             return [1,
                     [0,
                      [1, [0, _l_, [0, caml_call1(Base[202], basename), 0]]],
                      _F_]];
            }
            var
             _C_ =
               [0, [0, cst_inner_test, sexp_here(basename, line_number)], 0],
             _D_ =
               [0,
                [0,
                 cst_outer_test,
                 sexp_here(outer_basename, outer_line_number)],
                _C_],
             _E_ =
               caml_call2(Base[85][8], cst_Expect_test_runtime_reache, _D_);
            return caml_call1(Base[246], _E_);
           });
         function _p_(param){
          caml_call2
           (Ppx_expect_runtime_Current_fil[6],
            line_number,
            filename_rel_to_project_root);
          var
           absolute_filename =
             caml_call1(Ppx_expect_runtime_Current_fil[5], basename),
           _v_ =
             caml_call1
              (Ppx_expect_runtime_Expectation[8],
               [0,
                [0, trailing_loc[1], trailing_loc[2], trailing_loc[2]],
                body_loc]),
           trailing_test = caml_call1(Ppx_expect_runtime_Test_node[2], _v_);
          if(expected_exn)
           var
            _w_ =
              caml_call3
               (Ppx_expect_runtime_Expectation[7],
                formatting_flexibility,
                trailing_loc,
                expected_exn),
            exn_test = caml_call1(Ppx_expect_runtime_Test_node[2], _w_);
          else
           var
            _A_ =
              caml_call1
               (Ppx_expect_runtime_Expectation[9],
                [0, trailing_loc, body_loc]),
            exn_test = caml_call1(Ppx_expect_runtime_Test_node[2], _A_);
          var
           expectations$0 =
             [0,
              [0, exn_test_id, exn_test],
              [0, [0, test_to_run, trailing_test], expectations]];
          function _x_(original_file_contents, ts){
           var
            _B_ =
              caml_call3
               (Ppx_expect_runtime_Test_node[6][4],
                Configured$0[3],
                Ppx_expect_runtime_Types[1][1],
                original_file_contents);
           return caml_call2(Base_List[14], ts, _B_);
          }
          var
           expectations$1 =
             caml_call3
              (Ppx_expect_runtime_Test_node[5][1],
               absolute_filename,
               expectations$0,
               _x_);
          flush(0);
          var
           _u_ =
             caml_call3(Stdlib_Filename[16], 0, cst_expect_test, cst_output),
           output_file = caml_call1(Ppx_expect_runtime_Current_fil[5], _u_),
           test_output_writer = caml_call3(Stdlib[62], _a_, 420, output_file),
           test_output_reader = caml_call1(Stdlib[79], output_file);
          runtime.ppx_expect_runtime_before_test
           (test_output_writer, Stdlib[39], Stdlib[40]);
          var
           test_block =
             [0,
              absolute_filename,
              output_file,
              [0, 0],
              test_output_reader,
              test_output_writer,
              [0, 0]],
           t = [0, line_number, basename, location, test_block];
          test_is_running[1] = [0, t];
          function _y_(param){
           read_test_output_unsanitized(test_block);
           return caml_call1(f, 0);
          }
          var
           test_exn = Configured$0[6].call(null, _y_),
           trailing_raw = read_test_output_sanitized_and(0),
           trailing_output =
             caml_string_notequal
               (caml_call2(Base_String[109], 0, trailing_raw), cst$4)
              ? [0, trailing_raw]
              : 0;
          if(test_exn){
           var test_exn$0 = test_exn[1];
           if(trailing_output)
            var
             trailing_output$0 = trailing_output[1],
             test_output =
               caml_call2
                (Base_String[68],
                 _m_,
                 [0,
                  test_exn$0,
                  [0,
                   cst_Trailing_output,
                   [0, cst$1, [0, trailing_output$0, 0]]]]);
           else
            var test_output = test_exn$0;
           var test_to_run$0 = exn_test_id, test_output$0 = test_output;
          }
          else
           var
            test_output$1 =
              caml_call2(Base_Option[30], trailing_output, cst$2),
            test_to_run$0 = test_to_run,
            test_output$0 = test_output$1;
          run_test_inner(test_to_run$0, test_output$0, test_block);
          function _z_(param){
           var test_node = param[2];
           return caml_call1(Ppx_expect_runtime_Test_node[3], test_node);
          }
          caml_call2(Base_List[19], expectations$1, _z_);
          clean_up_block(test_block);
          test_is_running[1] = 0;
          return 1;
         }
         var
          _q_ = end_pos - start_bol | 0,
          _r_ = start_pos - start_bol | 0,
          _s_ =
            [246,
             function(_t_){
              return caml_call2(Base_Option[30], description, cst$3);
             }];
         return caml_call8
                 (Ppx_inline_test_lib[8],
                  inline_test_config,
                  _s_,
                  tags,
                  basename,
                  line_number,
                  _r_,
                  _q_,
                  _p_);
        }
        return [0, read_test_output_no_backtrace_, run_test, run_suite];
       },
       For_external,
       at_exit];
   runtime.caml_register_global
    (48, Ppx_expect_runtime_Test_block, "Ppx_expect_runtime__Test_block");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_expect_runtime
//# unitInfo: Requires: CamlinternalLazy, Ppx_expect_runtime__Current_file, Ppx_expect_runtime__Test_block, Ppx_expect_runtime__Test_node, Ppx_expect_runtime__Write_corrected_file, Ppx_inline_test_lib, Stdlib, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Ppx_expect_runtime_Write_corre =
      global_data.Ppx_expect_runtime__Write_corrected_file,
    Ppx_expect_runtime_Current_fil =
      global_data.Ppx_expect_runtime__Current_file,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Ppx_expect_runtime_Test_node = global_data.Ppx_expect_runtime__Test_node,
    Ppx_expect_runtime_Test_block = global_data.Ppx_expect_runtime__Test_block,
    Stdlib = global_data.Stdlib;
   function _a_(param){
    var
     _b_ = Ppx_expect_runtime_Current_fil[4],
     _c_ = runtime.caml_obj_tag(_b_);
    a:
    if(250 === _c_)
     var _d_ = _b_[1];
    else{
     if(246 !== _c_ && 244 !== _c_){var _d_ = _b_; break a;}
     var _d_ = caml_call1(CamlinternalLazy[2], _b_);
    }
    runtime.caml_sys_chdir(_d_);
    function _e_(filename, test_nodes, postprocess){
     var
      _g_ = caml_call1(Ppx_inline_test_lib[14], 0),
      _h_ = caml_call1(Ppx_inline_test_lib[13], 0),
      _i_ = caml_call1(Ppx_inline_test_lib[12], 0),
      _j_ = caml_call1(Ppx_inline_test_lib[11], 0);
     return caml_call7
             (Ppx_expect_runtime_Write_corre[2],
              _j_,
              _i_,
              _h_,
              _g_,
              filename,
              postprocess,
              test_nodes);
    }
    var _f_ = caml_call1(Ppx_expect_runtime_Test_node[5][3], _e_);
    return caml_call1(Ppx_inline_test_lib[5][2], _f_);
   }
   caml_call1(Ppx_inline_test_lib[16], _a_);
   caml_call1(Stdlib[100], Ppx_expect_runtime_Test_block[3]);
   var
    Current_file =
      [0,
       Ppx_expect_runtime_Current_fil[1],
       Ppx_expect_runtime_Current_fil[2]],
    Test_node = [0],
    Ppx_expect_runtime = [0, Current_file, Test_node];
   runtime.caml_register_global(7, Ppx_expect_runtime, "Ppx_expect_runtime");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfZXhwZWN0X3J1bnRpbWUuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImRlZmF1bHQkMCIsImRlZmF1bHQkMSIsImVxdWFsIiwiYSIsImIiLCJ0IiwiY29tcGFyZV9jaGFyYWN0ZXJfcmFuZ2UiLCJjb3VudGVyIiwibWludCIsImlkIiwiaGFuZGVkIiwiaGFuZCIsImYiLCJ1c2VfY29sb3IiLCJpbl9wbGFjZSIsImRpZmZfY29tbWFuZCIsImRpZmZfcGF0aF9wcmVmaXgiLCJmaWxlbmFtZSIsIndpdGgkMCIsImNvcnJlY3Rpb25zJDAiLCJkb3RfY29ycmVjdGVkIiwiaW5fY2hhbm5lbCIsIm9yaWdpbmFsX2ZpbGVfY29udGVudHMiLCJyZW1vdmUiLCJmaWxlIiwiY29ycmVjdGlvbnMkMSIsImNvcnJlY3Rpb25zIiwibF9wb3MiLCJjb3JyZWN0aW9uIiwiZW5kX3BvcyIsInN0YXJ0X3BvcyIsImNvZGVfY2h1bmsiLCJzdHJzIiwicmVzdWx0IiwicmVzdCIsIm5leHRfY29udGVudHMiLCJ0bXBfY29ycmVjdGVkIiwiY29tcGFyZSIsImNyZWF0ZSIsImZvcm1hdCIsImFwcGx5Iiwic3RyIiwiY29tcGFyZSQwIiwiYiQwIiwiYSQwIiwiY29udGVudHMiLCJ0b19zb3VyY2VfY29kZV9zdHJpbmciLCJ0YWciLCJ0ZXN0X291dHB1dCIsInRhZyQwIiwicmVjb25jaWxlIiwiZXhwZWN0ZWRfb3V0cHV0IiwiZmFpbCIsImVycm9yX291dHB1dCIsImZpeF9kZWxpbWl0ZXJfY29uZmxpY3RzIiwiZGVsaW1pdGVyIiwidGFnJDEiLCJ0YWdfY29uZmxpY3RzX3dpdGgkMCIsInRhZ19jb25mbGljdHNfd2l0aCIsImZzdHIiLCJ0b19mb3JtYXR0ZWRfcGF5bG9hZCIsInBhcmFtIiwidG9fc291cmNlX2NvZGVfc3RyaW5nJDAiLCJleHBlY3Rfbm9kZV9mb3JtYXR0aW5nIiwic2hhcGUiLCJwYXlsb2FkIiwicHJlZml4IiwicHJlZml4JDAiLCJsYXN0X2xpbmUiLCJmaXJzdF9saW5lIiwibG9jIiwid2hvbGVfbm9kZSIsIndpdGhfYmVoYXZpb3IiLCJiZWhhdmlvciIsImluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2UiLCJvbl9pbmNvcnJlY3Rfb3V0cHV0IiwicGF5bG9hZF90eXBlIiwicG9zaXRpb24iLCJmb3JtYXR0ZXIiLCJzdHJpcHBlZCIsImxpbmUiLCJpbmRlbnRfYW5kX2NvbnRlbnRzIiwiaW5kZW50IiwibWluX2luZGVudCIsImxpbmVzIiwic3RhcnRfYm9sIiwic3RhcnRfcG9zJDAiLCJzdGFydF9ib2wkMCIsImxvY2F0aW9uX2luZGVudCIsInNwYWNlcyIsIm4iLCJsYXN0X2xpbmUkMCIsImluZGVudGF0aW9uIiwiZmlyc3RfbGluZSQwIiwibGluZXMkMCIsImV4dGVuc2lvbl9zeW50YXgiLCJleHRlbnNpb25fbmFtZSIsInBheWxvYWRfbG9jIiwibm9kZV9sb2MiLCJwYXlsb2FkX2xvYyQwIiwicG9zc2libHlfcmVsYXhfc3RyaWN0bmVzcyIsImZvcm1hdHRpbmdfZmxleGliaWxpdHkiLCJmbXQiLCJyZWFjaGFiaWxpdHkiLCJvbl91bnJlYWNoYWJsZSIsImNvbnRlbnRzJDAiLCJleHBlY3RlZF9zdHJpbmdfYW5kX3BheWxvYWRfbG8iLCJleHBlY3QiLCJsb2NhdGVkX3BheWxvYWQiLCJleHBlY3RfZXhhY3QiLCJleHBlY3RfdW5yZWFjaGFibGUiLCJleHBlY3RfdW5jYXVnaHRfZXhuIiwiZXhwZWN0X3RyYWlsaW5nIiwiaW5zZXJ0X2xvYyIsImV4cGVjdF9ub191bmNhdWdodF9leG4iLCJmb3JtYXRfcGF5bG9hZCIsIm1rX25vZGUiLCJub2RlIiwiZm9ybWF0dGVkX2NvbnRlbnRzIiwibm9kZV9zaGFwZSIsInNvdXJjZV9jb2RlX3N0cmluZyIsImZvcm1hdF9leHBlY3RfcGF5bG9hZCIsImZvcm1hdF91bmNhdWdodF9leG5fcGF5bG9hZCIsInJlY29yZF9hbmRfcmV0dXJuX3Jlc3VsdCIsImZhaWx1cmVfcmVmIiwidGVzdF9vdXRwdXRfcmF3IiwicmVzdWx0cyIsImV4cGVjdGF0aW9uIiwicmVzdWx0JDAiLCJvZl9leHBlY3RhdGlvbiIsInJlY29yZF9lbmRfb2ZfcnVuIiwicmVhY2hlZF90aGlzX3J1biIsInJlY29yZF9yZXN1bHQiLCJpbm5lciIsImdsb2JhbF9yZXN1bHRzX3RhYmxlIiwiZmluZF90ZXN0IiwiYWJzb2x1dGVfZmlsZW5hbWUiLCJ0ZXN0X2lkIiwiZXhwZWN0YXRpb25zIiwiaW5pdGlhbGl6ZV9hbmRfcmVnaXN0ZXJfdGVzdHMiLCJ0ZXN0cyIsInBvc3Rwcm9jZXNzIiwidGVzdHNfYXNfaW5fdGFibGUiLCJmaWxlJDAiLCJ0ZXN0cyQwIiwibmV3X3Rlc3QiLCJleGlzdGluZ190ZXN0IiwidGVzdCIsInByb2Nlc3NfZWFjaF9maWxlIiwidGVzdF9ub2RlcyIsImV4cGVjdGF0aW9uX29mX3QiLCJyZWNvcmRfYW5kX3JldHVybl9udW1iZXJfb2ZfbGkiLCJ0b19kaWZmcyIsImNyX2Zvcl9tdWx0aXBsZV9vdXRwdXRzIiwicmVzdWx0c19saXN0Iiwib3V0cHV0Iiwib3V0cHV0c19saXN0IiwidW5yZWFjaGVkX2xpc3QiLCJkaXN0aW5jdF9vdXRwdXRzIiwid2FzX3JlYWNoZWQiLCJyZWFjaGFiaWxpdHlfYmVoYXZpb3IiLCJyZWFjaGFiaWxpdHlfb2ZfY29ycmVjdGVkIiwiY29ycmVjdGlvbl9mb3Jfc2luZ2xlX3Jlc3VsdCIsInJlY2VpdmVkIiwib3V0cHV0cyIsInJhdyIsImJlaGF2aW9yJDAiLCJjb3JyZWN0aW9uJDIiLCJzYWZlX2J5dGVfZ2V0Iiwic3RyaW5nIiwiaSIsIndoaXRlc3BhY2UiLCJsZXRfb2Zmc2V0Iiwid2hpdGVzcGFjZSQwIiwiY29ycmVjdGlvbiQxIiwiY29ycmVjdGlvbiQwIiwibG9jJDAiLCJvbl9pbmNvcnJlY3Rfb3V0cHV0JDAiLCJwb3NpdGlvbiQwIiwibG9jJDEiLCJkaWZmIiwibG9jJDIiLCJtYWluX2NvcnJlY3Rpb24iLCJyZW1vdmVfZW1wdHlfbGluZV9mcm9tX2RlbGV0ZWQiLCJib2R5X2xvYyIsImFkZF9zZW1pY29sb25fYmVmb3JlX3RyYWlsaW5nXyIsImFkZGl0aW9uYWxfY29ycmVjdGlvbnMiLCJjdXJyZW50Iiwic2V0IiwiZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdCIsImN1cnJlbnQkMCIsInVuc2V0IiwiZ2V0IiwiZm4iLCJkaXJfb3JfZXJyb3IiLCJpbml0aWFsX2RpciIsImFic29sdXRlX3BhdGgiLCJ2ZXJpZnlfdGhhdF9maWxlX2lzX2N1cnJlbnRfZXgiLCJsaW5lX251bWJlciIsInJlZ2lzdGVyaW5nX3Rlc3RzX2ZvciIsImNsZWFuX3VwX2Jsb2NrIiwidGVzdF9vdXRwdXRfd3JpdGVyIiwidGVzdF9vdXRwdXRfcmVhZGVyIiwib3V0cHV0X2ZpbGUiLCJmbHVzaCIsInJlYWRfdGVzdF9vdXRwdXRfdW5zYW5pdGl6ZWQiLCJvbGRfb2Zmc2V0IiwibmV3X29mZnNldCIsImxlbiIsImNyX3ByZWZpeCIsImNyX2Zvcl9iYWNrdHJhY2UiLCJvdXRwdXRfbmFtZSIsImNyX2JvZHkiLCJjciIsIm51bV9vdXRwdXRzIiwiaW5kZXgiLCJoZWFkZXIiLCJwYWRfbGVuZ3RoIiwibHBhZCIsInJwYWQiLCJvdXRwdXRzX3dpdGhfaGVhZGVycyIsInNhbml0aXplIiwiY2hlY2tfZm9yX2JhY2t0cmFjZXMiLCJzIiwic3Vic3RyaW5nIiwiZHVtcF9iYWNrdHJhY2UiLCJwb3NzaWJsZV9leG4iLCJleG4kMCIsImV4biIsImJ0IiwiZXhuX3N0cmluZyIsIm5hbWUiLCJidCQwIiwidGVzdF9pc19ydW5uaW5nIiwiYW1fcnVubmluZ19leHBlY3RfdGVzdCIsImN1cnJlbnRfdGVzdCIsInRlc3RfYmxvY2siLCJjdXJyZW50X3Rlc3RfZXhuIiwiaXRlciIsImF0X2V4aXQiLCJiYXNlbmFtZSIsImZpbiIsImFsbF9vdXQiLCJyZWFkX2N1cnJlbnRfdGVzdF9vdXRwdXRfZXhuIiwiaGVyZSIsImRlZmF1bHRfY3JfZm9yX211bHRpcGxlX291dHB1dCIsInJlYWRfdGVzdF9vdXRwdXRfbm9fYmFja3RyYWNlXyIsInJlYWRfdGVzdF9vdXRwdXRfc2FuaXRpemVkX2FuZCIsInJ1bl90ZXN0X2lubmVyIiwicnVuX3Rlc3QiLCJydW5fc3VpdGUiLCJsb2NhdGlvbiIsInRyYWlsaW5nX2xvYyIsImV4cGVjdGVkX2V4biIsInRlc3RfdG9fcnVuIiwiZXhuX3Rlc3RfaWQiLCJkZXNjcmlwdGlvbiIsInRhZ3MiLCJpbmxpbmVfdGVzdF9jb25maWciLCJvdXRlcl9iYXNlbmFtZSIsIm91dGVyX2xpbmVfbnVtYmVyIiwic2V4cF9oZXJlIiwidHJhaWxpbmdfdGVzdCIsImV4bl90ZXN0IiwiZXhwZWN0YXRpb25zJDAiLCJ0cyIsImV4cGVjdGF0aW9ucyQxIiwidGVzdF9leG4iLCJ0cmFpbGluZ19yYXciLCJ0cmFpbGluZ19vdXRwdXQiLCJ0ZXN0X2V4biQwIiwidHJhaWxpbmdfb3V0cHV0JDAiLCJ0ZXN0X3RvX3J1biQwIiwidGVzdF9vdXRwdXQkMCIsInRlc3Rfb3V0cHV0JDEiLCJ0ZXN0X25vZGUiXSwic291cmNlcyI6WyIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvcHB4X2V4cGVjdC9ydW50aW1lL3BweF9leHBlY3RfcnVudGltZV9fLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL3BweF9leHBlY3QvcnVudGltZS90eXBlcy5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvd3JpdGVfY29ycmVjdGVkX2ZpbGUubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvcHB4X2V4cGVjdC9ydW50aW1lL291dHB1dC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvZXhwZWN0YXRpb25faW50Zi5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvZXhwZWN0YXRpb24ubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvcHB4X2V4cGVjdC9ydW50aW1lL3Rlc3Rfbm9kZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9wcHhfZXhwZWN0L3J1bnRpbWUvY3VycmVudF9maWxlLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL3BweF9leHBlY3QvcnVudGltZS90ZXN0X2Jsb2NrLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL3BweF9leHBlY3QvcnVudGltZS9wcHhfZXhwZWN0X3J1bnRpbWUubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7R0EwQjhCOztJQUFBOzs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQ0d4QkE7SUFtRUVDOzs7OztZQXZGRkMsTUFBTUMsR0FBRUM7SUFDVixVQURRRCxTQUFFQzs7ZUFBRkQsU0FBRUMsMEJBQUZELFNBQUVDOzs7O0dBQ3FFOztnQkFNdkNDLEdBQUssT0FBTEEsS0FBYztpQkFBbEQ7Z0JBRG9DQSxHQUFLLE9BQUxBLEtBQWdCO0dBQXREO0lBQUEsVUFBRTtJQUZGQywwQkFDRjtJQVppQixrQkFPZkosT0FJQUk7SUF3QmlCO0lBaEJTLDZCQVExQk47SUFlZTs7Ozs7O0lBV2JPO0dBQ0osU0FGRUM7SUFHQSxJQUFJQyxLQUZGRjtJQUFBQSxhQUVFRTtJQUVKLE9BRklBO0dBRUY7R0FRUSxJQUFBLFlBTUEsWUFNQztZQTRCVEMsT0FDRUwsR0FBRU0sTUFDTixPQURNQSxPQUFGTixJQUFBQSxVQUFBQSxFQUdzQjs7Ozs7Ozs2REF6RDFCRztrQ0EwQ0VQLFdBV0FTOzs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHQ3hHMEI7Ozs7Ozs7Ozs7OztJQUFBOzs7WUEwQjlCRTtJQUFHQztJQUFXQztJQUFVQztJQUFjQztJQUFrQkM7SUFBVUM7SUFBTUM7SUFHMUU7S0FBSUMsZ0JBQWdCLHNCQUhzQ0g7S0FLcERJLGFBQWEsdUJBTHVDSjtLQU9oQixNQUFBLHVCQUZwQ0k7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QUFBOzs7O0lBRWlCOzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgYnkgZHVuZSAqKVxuXG4oKiogQGNhbm9uaWNhbCBQcHhfZXhwZWN0X3J1bnRpbWUuQ3VycmVudF9maWxlICopXG5tb2R1bGUgQ3VycmVudF9maWxlID0gUHB4X2V4cGVjdF9ydW50aW1lX19DdXJyZW50X2ZpbGVcblxuKCoqIEBjYW5vbmljYWwgUHB4X2V4cGVjdF9ydW50aW1lLkV4cGVjdGF0aW9uICopXG5tb2R1bGUgRXhwZWN0YXRpb24gPSBQcHhfZXhwZWN0X3J1bnRpbWVfX0V4cGVjdGF0aW9uXG5cbigqKiBAY2Fub25pY2FsIFBweF9leHBlY3RfcnVudGltZS5FeHBlY3RhdGlvbl9pbnRmICopXG5tb2R1bGUgRXhwZWN0YXRpb25faW50ZiA9IFBweF9leHBlY3RfcnVudGltZV9fRXhwZWN0YXRpb25faW50ZlxuXG4oKiogQGNhbm9uaWNhbCBQcHhfZXhwZWN0X3J1bnRpbWUuT3V0cHV0ICopXG5tb2R1bGUgT3V0cHV0ID0gUHB4X2V4cGVjdF9ydW50aW1lX19PdXRwdXRcblxuKCoqIEBjYW5vbmljYWwgUHB4X2V4cGVjdF9ydW50aW1lLlRlc3RfYmxvY2sgKilcbm1vZHVsZSBUZXN0X2Jsb2NrID0gUHB4X2V4cGVjdF9ydW50aW1lX19UZXN0X2Jsb2NrXG5cbigqKiBAY2Fub25pY2FsIFBweF9leHBlY3RfcnVudGltZS5UZXN0X25vZGUgKilcbm1vZHVsZSBUZXN0X25vZGUgPSBQcHhfZXhwZWN0X3J1bnRpbWVfX1Rlc3Rfbm9kZVxuXG4oKiogQGNhbm9uaWNhbCBQcHhfZXhwZWN0X3J1bnRpbWUuVHlwZXMgKilcbm1vZHVsZSBUeXBlcyA9IFBweF9leHBlY3RfcnVudGltZV9fVHlwZXNcblxuKCoqIEBjYW5vbmljYWwgUHB4X2V4cGVjdF9ydW50aW1lLldyaXRlX2NvcnJlY3RlZF9maWxlICopXG5tb2R1bGUgV3JpdGVfY29ycmVjdGVkX2ZpbGUgPSBQcHhfZXhwZWN0X3J1bnRpbWVfX1dyaXRlX2NvcnJlY3RlZF9maWxlXG5cbm1vZHVsZSBQcHhfZXhwZWN0X3J1bnRpbWVfXyA9IHN0cnVjdCBlbmRcbltAQGRlcHJlY2F0ZWQgXCJ0aGlzIG1vZHVsZSBpcyBzaGFkb3dlZFwiXVxuIiwib3BlbiEgQmFzZVxuXG5tb2R1bGUgQ29tcGFjdF9sb2MgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHN0YXJ0X2JvbCA6IGludFxuICAgIDsgc3RhcnRfcG9zIDogaW50XG4gICAgOyBlbmRfcG9zIDogaW50XG4gICAgfVxuXG4gIGxldCBlcXVhbCBhIGIgPVxuICAgIGEuc3RhcnRfYm9sID0gYi5zdGFydF9ib2wgJiYgYS5zdGFydF9wb3MgPSBiLnN0YXJ0X3BvcyAmJiBhLmVuZF9wb3MgPSBiLmVuZF9wb3NcbiAgOztcblxuICBsZXQgY29tcGFyZV9jaGFyYWN0ZXJfcmFuZ2UgPVxuICAgIENvbXBhcmFibGUubGV4aWNvZ3JhcGhpY1xuICAgICAgWyBDb21wYXJhYmxlLmxpZnQgY29tcGFyZV9pbnQgfmY6KGZ1biB0IC0+IHQuc3RhcnRfcG9zKVxuICAgICAgOyBDb21wYXJhYmxlLmxpZnQgY29tcGFyZV9pbnQgfmY6KGZ1biB0IC0+IHQuZW5kX3BvcylcbiAgICAgIF1cbiAgOztcbmVuZFxuXG5tb2R1bGUgRXhwZWN0X25vZGVfZm9ybWF0dGluZyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgaW5kZW50IDogaW50XG4gICAgOyBhbHdheXNfb25fb3duX2xpbmUgOiBib29sXG4gICAgOyBleHRlbnNpb25fc2lnaWwgOiBzdHJpbmdcbiAgICA7IGF0dHJpYnV0ZV9zaWdpbCA6IHN0cmluZ1xuICAgIH1cblxuICBsZXQgZGVmYXVsdCA9XG4gICAgeyBpbmRlbnQgPSAyXG4gICAgOyBhbHdheXNfb25fb3duX2xpbmUgPSBmYWxzZVxuICAgIDsgZXh0ZW5zaW9uX3NpZ2lsID0gXCIlXCJcbiAgICA7IGF0dHJpYnV0ZV9zaWdpbCA9IFwiQEBcIlxuICAgIH1cbiAgOztcblxuICBtb2R1bGUgRmxleGliaWxpdHkgPSBzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID1cbiAgICAgIHwgRmxleGlibGVfbW9kdWxvIG9mIHRcbiAgICAgIHwgRXhhY3RseV9mb3JtYXR0ZWRcbiAgZW5kXG5lbmRcblxubW9kdWxlIFZpcnR1YWxfbG9jID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBsb2MgOiBDb21wYWN0X2xvYy50XG4gICAgOyBib2R5X2xvYyA6IENvbXBhY3RfbG9jLnRcbiAgICB9XG5lbmRcblxubW9kdWxlIEV4cGVjdGF0aW9uX2lkID0gc3RydWN0XG4gIGluY2x1ZGUgSW50XG5cbiAgbGV0IG1pbnQgPVxuICAgIGxldCBjb3VudGVyID0gcmVmIDAgaW5cbiAgICBmdW4gKCkgLT5cbiAgICAgIGxldCBpZCA9ICFjb3VudGVyIGluXG4gICAgICBjb3VudGVyIDo9IGlkICsgMTtcbiAgICAgIGlkXG4gIDs7XG5lbmRcblxubW9kdWxlIFN0cmluZ19ub2RlX2Zvcm1hdCA9IHN0cnVjdFxuICB0eXBlIGxvbmdoYW5kID0gTG9uZ2hhbmRcbiAgdHlwZSBzaG9ydGhhbmQgPSBTaG9ydGhhbmRcblxuICBtb2R1bGUgSGFuZCA9IHN0cnVjdFxuICAgIHR5cGUgXyB0ID1cbiAgICAgIHwgTG9uZ2hhbmQgOiBsb25naGFuZCB0XG4gICAgICB8IFNob3J0aGFuZCA6IHNob3J0aGFuZCB0XG4gIGVuZFxuXG4gIG1vZHVsZSBLaW5kID0gc3RydWN0XG4gICAgdHlwZSBfIHQgPVxuICAgICAgfCBBdHRyaWJ1dGUgOiBsb25naGFuZCB0XG4gICAgICB8IEV4dGVuc2lvbiA6IF8gdFxuICBlbmRcblxuICBtb2R1bGUgU2hhcGUgPSBzdHJ1Y3RcbiAgICB0eXBlICdoYW5kIHVucGFja2VkID1cbiAgICAgIHsgbmFtZSA6IHN0cmluZ1xuICAgICAgOyBoYW5kIDogJ2hhbmQgSGFuZC50XG4gICAgICA7IGtpbmQgOiAnaGFuZCBLaW5kLnRcbiAgICAgIH1cblxuICAgIHR5cGUgdCA9IFQgOiBfIHVucGFja2VkIC0+IHQgW0BAdW5ib3hlZF1cbiAgZW5kXG5cbiAgbW9kdWxlIERlbGltaXRlciA9IHN0cnVjdFxuICAgIHR5cGUgXyB1bnBhY2tlZCA9XG4gICAgICB8IFF1b3RlIDogbG9uZ2hhbmQgdW5wYWNrZWRcbiAgICAgIHwgVGFnIDogc3RyaW5nIC0+IF8gdW5wYWNrZWRcblxuICAgIHR5cGUgdCA9IFQgOiBfIHVucGFja2VkIC0+IHQgW0BAdW5ib3hlZF1cblxuICAgIGxldCBkZWZhdWx0ID0gVCAoVGFnIFwiXCIpXG5cbiAgICBsZXQgbG9uZ2hhbmQgPSBmdW5jdGlvblxuICAgICAgfCBUICgoUXVvdGUgfCBUYWcgXykgYXMgdW5wYWNrZWQpIC0+IHVucGFja2VkXG4gICAgOztcblxuICAgIGxldCBzaG9ydGhhbmQgPSBmdW5jdGlvblxuICAgICAgfCBUIChUYWcgXyBhcyB1bnBhY2tlZCkgLT4gdW5wYWNrZWRcbiAgICAgIHwgVCBRdW90ZSAtPiBUYWcgXCJcIlxuICAgIDs7XG5cbiAgICBsZXQgaGFuZGVkIDogdHlwZSBhLiB0IC0+IGEgSGFuZC50IC0+IGEgdW5wYWNrZWQgPVxuICAgICAgZnVuIHQgaGFuZCAtPlxuICAgICAgbWF0Y2ggaGFuZCB3aXRoXG4gICAgICB8IExvbmdoYW5kIC0+IGxvbmdoYW5kIHRcbiAgICAgIHwgU2hvcnRoYW5kIC0+IHNob3J0aGFuZCB0XG4gICAgOztcbiAgZW5kXG5cbiAgdHlwZSAnYSB1bnBhY2tlZCA9XG4gICAgeyBzaGFwZSA6ICdhIFNoYXBlLnVucGFja2VkXG4gICAgOyBkZWxpbWl0ZXIgOiAnYSBEZWxpbWl0ZXIudW5wYWNrZWRcbiAgICB9XG5cbiAgdHlwZSB0ID0gVCA6IF8gdW5wYWNrZWQgLT4gdCBbQEB1bmJveGVkXVxuZW5kXG4iLCJvcGVuISBCYXNlXG5vcGVuIFR5cGVzXG5cbm1vZHVsZSBQYXRjaF93aXRoX2ZpbGVfY29udGVudHMgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gb3JpZ2luYWxfZmlsZV9jb250ZW50czpzdHJpbmcgLT4gJ2EgLT4gKENvbXBhY3RfbG9jLnQgKiBzdHJpbmcpIGxpc3RcbmVuZFxuXG5sZXQgcmV3cml0ZV9jb3JyZWN0aW9ucyB+b3JpZ2luYWxfZmlsZV9jb250ZW50cyB+Y29ycmVjdGlvbnMgPVxuICAoKiBFbnN1cmUgdGhhdCB3ZSBlbmNvdW50ZXIgdGhlIGNvcnJlY3Rpb25zIGluIG9yZGVyIGFzIHdlIGJ1aWxkIHVwIHRoZSBmaWxlLiAqKVxuICBsZXQgY29ycmVjdGlvbnMgPVxuICAgIExpc3Quc29ydFxuICAgICAgfmNvbXBhcmU6KENvbXBhcmFibGUubGlmdCBDb21wYWN0X2xvYy5jb21wYXJlX2NoYXJhY3Rlcl9yYW5nZSB+Zjpmc3QpXG4gICAgICBjb3JyZWN0aW9uc1xuICBpblxuICBsZXQgbF9wb3MsIHN0cnMgPVxuICAgIExpc3QuZm9sZF9tYXBcbiAgICAgIGNvcnJlY3Rpb25zXG4gICAgICB+aW5pdDowXG4gICAgICB+ZjooZnVuIGxfcG9zICh7IHN0YXJ0X3BvczsgZW5kX3Bvczsgc3RhcnRfYm9sID0gXyB9LCBjb3JyZWN0aW9uKSAtPlxuICAgICAgbGV0IGNvZGVfY2h1bmsgPVxuICAgICAgICBTdHJpbmcuc3ViIG9yaWdpbmFsX2ZpbGVfY29udGVudHMgfnBvczpsX3BvcyB+bGVuOihzdGFydF9wb3MgLSBsX3BvcylcbiAgICAgIGluXG4gICAgICBlbmRfcG9zLCBbIGNvZGVfY2h1bms7IGNvcnJlY3Rpb24gXSlcbiAgaW5cbiAgbGV0IHJlc3VsdCA9IExpc3QuY29uY2F0IHN0cnMgfD4gU3RyaW5nLmNvbmNhdCBpblxuICBsZXQgcmVzdCA9IFN0cmluZy5zdWJvIG9yaWdpbmFsX2ZpbGVfY29udGVudHMgfnBvczpsX3BvcyBpblxuICByZXN1bHQgXiByZXN0XG47O1xuXG5sZXQgZiB+dXNlX2NvbG9yIH5pbl9wbGFjZSB+ZGlmZl9jb21tYW5kIH5kaWZmX3BhdGhfcHJlZml4IH5maWxlbmFtZSB+d2l0aF8gY29ycmVjdGlvbnNcbiAgOiBQcHhfaW5saW5lX3Rlc3RfbGliLlRlc3RfcmVzdWx0LnRcbiAgPVxuICBsZXQgZG90X2NvcnJlY3RlZCA9IGZpbGVuYW1lIF4gXCIuY29ycmVjdGVkXCIgaW5cbiAgbGV0IG9yaWdpbmFsX2ZpbGVfY29udGVudHMgPVxuICAgIGxldCBpbl9jaGFubmVsID0gU3RkbGliLm9wZW5faW4gZmlsZW5hbWUgaW5cbiAgICBsZXQgY29udGVudHMgPVxuICAgICAgU3RkbGliLnJlYWxseV9pbnB1dF9zdHJpbmcgaW5fY2hhbm5lbCAoU3RkbGliLmluX2NoYW5uZWxfbGVuZ3RoIGluX2NoYW5uZWwpXG4gICAgaW5cbiAgICBTdGRsaWIuY2xvc2VfaW4gaW5fY2hhbm5lbDtcbiAgICBjb250ZW50c1xuICBpblxuICBsZXQgcmVtb3ZlIGZpbGUgPSBpZiBTdGRsaWIuU3lzLmZpbGVfZXhpc3RzIGZpbGUgdGhlbiBTdGRsaWIuU3lzLnJlbW92ZSBmaWxlIGluXG4gIGxldCBjb3JyZWN0aW9ucyA9IHdpdGhfIH5vcmlnaW5hbF9maWxlX2NvbnRlbnRzIGNvcnJlY3Rpb25zIGluXG4gIGxldCBuZXh0X2NvbnRlbnRzID0gcmV3cml0ZV9jb3JyZWN0aW9ucyB+b3JpZ2luYWxfZmlsZV9jb250ZW50cyB+Y29ycmVjdGlvbnMgaW5cbiAgbWF0Y2ggaW5fcGxhY2Ugd2l0aFxuICB8IHRydWUgLT5cbiAgICBpZiBub3QgKFN0cmluZy5lcXVhbCBvcmlnaW5hbF9maWxlX2NvbnRlbnRzIG5leHRfY29udGVudHMpXG4gICAgdGhlbiBTdGRpby5PdXRfY2hhbm5lbC53cml0ZV9hbGwgZmlsZW5hbWUgfmRhdGE6bmV4dF9jb250ZW50cztcbiAgICByZW1vdmUgZG90X2NvcnJlY3RlZDtcbiAgICBTdWNjZXNzXG4gIHwgZmFsc2UgLT5cbiAgICAobWF0Y2ggZGlmZl9jb21tYW5kIHdpdGhcbiAgICAgfCBTb21lIFwiLVwiICgqIEp1c3Qgd3JpdGUgdGhlIC5jb3JyZWN0ZWQgZmlsZSAtIGRvIG5vdCBvdXRwdXQgYSBkaWZmLiAqKSAtPlxuICAgICAgIFN0ZGlvLk91dF9jaGFubmVsLndyaXRlX2FsbCBkb3RfY29ycmVjdGVkIH5kYXRhOm5leHRfY29udGVudHM7XG4gICAgICAgU3VjY2Vzc1xuICAgICB8IF8gLT5cbiAgICAgICAoKiBCeSBpbnZva2luZyBbTWFrZV9jb3JyZWN0ZWRfZmlsZS5mXSB3aXRoIGEgZnJlc2ggdGVtcG9yYXJ5IGZpbGUsIHdlIGF2b2lkIHRoZVxuICAgICAgICAgIGZvbGxvd2luZyBwb3NzaWJsZSByYWNlIGJldHdlZW4gaW5saW5lX3Rlc3RfcnVubmVycyBBIGFuZCBCOlxuICAgICAgICAgIDEuIEEgcnVucyB0ZXN0IFQxIGFuZCBnZW5lcmF0ZXMgbmV4dCBjb250ZW50cyBDMS5cbiAgICAgICAgICAyLiBCIHJ1bnMgdGVzdCBUMiBhbmQgZ2VuZXJhdGVzIG5leHQgY29udGVudHMgQzIuXG4gICAgICAgICAgMy4gQSB3cml0ZXMgQzEgdG8gdGhlIC5jb3JyZWN0ZWQgZmlsZS5cbiAgICAgICAgICA0LiBCIHdyaXRlcyBDMiB0byB0aGUgLmNvcnJlY3RlZCBmaWxlLlxuICAgICAgICAgIDUuIEEgZGlmZnMgdGhlIC5jb3JyZWN0ZWQgZmlsZSBhZ2FpbnN0IHRoZSBvcmlnaW5hbCBmaWxlIGFuZCByZXBvcnRzIHRoZVxuICAgICAgICAgIHJlc3VsdC4gSXQgdGhpbmtzIGl0IGlzIHJlcG9ydGluZyB0aGUgZGlmZiBwcm9kdWNlZCBieSBUMSwgYnV0IGlzIGluIGZhY3RcbiAgICAgICAgICByZXBvcnRpbmcgdGhlIGRpZmYgcHJvZHVjZWQgYnkgVDIuIFRoZSBrZXkgYXNwZWN0IG9mIHVzaW5nIHRlbXBvcmFyeSBmaWxlcyBpc1xuICAgICAgICAgIHRoYXQgZXZlbiBpZiBpbiB0aGUgYWJvdmUgc2NlbmFyaW8gdGhlIGZpbmFsIGNvbnRlbnRzIG9mIHRoZSAuY29ycmVjdGVkIGZpbGVcbiAgICAgICAgICBhcmUgQzIsIHRoZSBkaWZmIHJlcG9ydGVkIGJ5IEEgY29tZXMgZnJvbSBpdHMgdG1wIGZpbGUgYW5kIHdpbGwgc3RpbGwgYmUgdGhlXG4gICAgICAgICAgZGlmZiBwcm9kdWNlZCBieSBUMS4gKilcbiAgICAgICBsZXQgdG1wX2NvcnJlY3RlZCA9XG4gICAgICAgICBTdGRsaWIuRmlsZW5hbWUudGVtcF9maWxlXG4gICAgICAgICAgIChTdGRsaWIuRmlsZW5hbWUuYmFzZW5hbWUgZmlsZW5hbWUpXG4gICAgICAgICAgIFwiLmNvcnJlY3RlZC50bXBcIlxuICAgICAgICAgICB+dGVtcF9kaXI6KFN0ZGxpYi5GaWxlbmFtZS5kaXJuYW1lIGZpbGVuYW1lKVxuICAgICAgIGluXG4gICAgICAgKG1hdGNoXG4gICAgICAgICAgTWFrZV9jb3JyZWN0ZWRfZmlsZS5mXG4gICAgICAgICAgICB+dXNlX2NvbG9yXG4gICAgICAgICAgICA/ZGlmZl9jb21tYW5kXG4gICAgICAgICAgICA/ZGlmZl9wYXRoX3ByZWZpeFxuICAgICAgICAgICAgfmNvcnJlY3RlZF9wYXRoOnRtcF9jb3JyZWN0ZWRcbiAgICAgICAgICAgIH5uZXh0X2NvbnRlbnRzXG4gICAgICAgICAgICB+cGF0aDpmaWxlbmFtZVxuICAgICAgICAgICAgKClcbiAgICAgICAgd2l0aFxuICAgICAgICB8IE9rIF8gLT5cbiAgICAgICAgICAoKiBFdmVuIHRob3VnaCB0aGlzIGV4ZWN1dGlvbiBvZiB0aGUgZXhwZWN0IHRlc3QgcmFuIHdpdGhvdXQgbWFraW5nXG4gICAgICAgICAgICAgY29ycmVjdGlvbnMsIHdlIHNob3VsZCBkZWxldGUgYW55IG9sZCBbLmNvcnJlY3RlZF0gZmlsZXMgdGhhdCBhcmUgbGVmdCBvdmVyXG4gICAgICAgICAgICAgZnJvbSBwcmV2aW91cyBidWlsZHMuIEluIHBhcnRpY3VsYXIsIGh5ZHJhIHJlbGllcyBvbiB0aGlzIGJlaGF2aW9yIGZvclxuICAgICAgICAgICAgIGZsYWt5IHRlc3RzOyBpZiB0aGUgdGVzdCBmYWlscyB0aGUgZmlyc3QgdGltZSBhbmQgcGFzc2VzIHRoZSBzZWNvbmQsIHRoZVxuICAgICAgICAgICAgIHNlY29uZCBydW4gc2hvdWxkIG1ha2Ugc3VyZSB0aGUgWy5jb3JyZWN0ZWRdIGZpbGUgaXMgbm90IGxpbmdlcmluZyBpbiB0aGVcbiAgICAgICAgICAgICBzYW5kYm94LiAqKVxuICAgICAgICAgIHJlbW92ZSBkb3RfY29ycmVjdGVkO1xuICAgICAgICAgIHJlbW92ZSB0bXBfY29ycmVjdGVkO1xuICAgICAgICAgIFN1Y2Nlc3NcbiAgICAgICAgfCBFcnJvciBfIC0+XG4gICAgICAgICAgU3RkbGliLlN5cy5yZW5hbWUgdG1wX2NvcnJlY3RlZCBkb3RfY29ycmVjdGVkO1xuICAgICAgICAgIEZhaWx1cmUpKVxuOztcbiIsIm9wZW4hIEJhc2Vcbm9wZW4gVHlwZXNcblxubW9kdWxlIFR5cGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IEV4YWN0XG4gICAgfCBQcmV0dHlcbmVuZFxuXG5tb2R1bGUgUmVjb25jaWxlZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBzdHJpbmdcblxuICBsZXQgY29tcGFyZSA9IGNvbXBhcmVfc3RyaW5nXG5lbmRcblxubW9kdWxlIEZvcm1hdHRlZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBzdHJpbmdcbmVuZFxuXG5tb2R1bGUgRm9ybWF0dGVyID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZyAtPiBGb3JtYXR0ZWQudFxuXG4gIGxldCBjcmVhdGUgZm9ybWF0ID0gZm9ybWF0XG4gIGxldCBhcHBseSBmb3JtYXQgc3RyID0gZm9ybWF0IHN0clxuZW5kXG5cbm1vZHVsZSBUZXN0X3Jlc3VsdCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgUGFzc1xuICAgIHwgRmFpbCBvZiBSZWNvbmNpbGVkLnRcblxuICBsZXQgY29tcGFyZSBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgUGFzcywgUGFzcyAtPiAwXG4gICAgfCBQYXNzLCBfIC0+IC0xXG4gICAgfCBfLCBQYXNzIC0+IDFcbiAgICB8IEZhaWwgYSwgRmFpbCBiIC0+IFJlY29uY2lsZWQuY29tcGFyZSBhIGJcbiAgOztcbmVuZFxuXG5tb2R1bGUgUGF5bG9hZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgY29udGVudHMgOiBzdHJpbmdcbiAgICA7IHRhZyA6IFN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXIudFxuICAgIH1cblxuICBsZXQgZGVmYXVsdCBjb250ZW50cyA9IHsgY29udGVudHM7IHRhZyA9IFN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXIuZGVmYXVsdCB9XG5cbiAgbGV0IHRvX3NvdXJjZV9jb2RlX3N0cmluZyB7IGNvbnRlbnRzOyB0YWcgfSA9XG4gICAgbGV0IGVzY2FwZV9saW5lcyB0ZXN0X291dHB1dCA9XG4gICAgICB0ZXN0X291dHB1dFxuICAgICAgfD4gU3RyaW5nLnNwbGl0IH5vbjonXFxuJ1xuICAgICAgfD4gTGlzdC5tYXAgfmY6U3RyaW5nLmVzY2FwZWRcbiAgICAgIHw+IFN0cmluZy5jb25jYXQgfnNlcDpcIlxcblwiXG4gICAgaW5cbiAgICBtYXRjaCB0YWcgd2l0aFxuICAgIHwgVCAoVGFnIHRhZykgLT4gUHJpbnRmLnNwcmludGYgXCJ7JXN8JXN8JXN9XCIgdGFnIGNvbnRlbnRzIHRhZ1xuICAgIHwgVCBRdW90ZSAtPiBQcmludGYuc3ByaW50ZiB7fFwiJXNcInx9IChlc2NhcGVfbGluZXMgY29udGVudHMpXG4gIDs7XG5lbmRcblxubGV0IHJlY29uY2lsZSB+ZXhwZWN0ZWRfb3V0cHV0IH50ZXN0X291dHB1dCA6IFRlc3RfcmVzdWx0LnQgPVxuICBpZiBTdHJpbmcuZXF1YWwgZXhwZWN0ZWRfb3V0cHV0IHRlc3Rfb3V0cHV0IHRoZW4gUGFzcyBlbHNlIEZhaWwgdGVzdF9vdXRwdXRcbjs7XG5cbmxldCBmYWlsIGVycm9yX291dHB1dCA6IFRlc3RfcmVzdWx0LnQgPSBGYWlsIGVycm9yX291dHB1dFxuXG5sZXQgZml4X2RlbGltaXRlcl9jb25mbGljdHNcbiAgKHR5cGUgaGFuZGVkbmVzcylcbiAgfmNvbnRlbnRzXG4gIH4oZGVsaW1pdGVyIDogaGFuZGVkbmVzcyBTdHJpbmdfbm9kZV9mb3JtYXQuRGVsaW1pdGVyLnVucGFja2VkKVxuICA6IGhhbmRlZG5lc3MgU3RyaW5nX25vZGVfZm9ybWF0LkRlbGltaXRlci51bnBhY2tlZFxuICA9XG4gIGxldCByZWMgZml4X3RhZ19jb25mbGljdHMgfmNvbnRlbnRzIH50YWcgPVxuICAgIGxldCB0YWdfY29uZmxpY3RzX3dpdGggZnN0ciA9XG4gICAgICBTdHJpbmcuaXNfc3Vic3RyaW5nIH5zdWJzdHJpbmc6KFByaW50Zi5zcHJpbnRmIGZzdHIgdGFnKSBjb250ZW50c1xuICAgIGluXG4gICAgaWYgdGFnX2NvbmZsaWN0c193aXRoIFwieyVzfFwiIHx8IHRhZ19jb25mbGljdHNfd2l0aCBcInwlc31cIlxuICAgIHRoZW4gZml4X3RhZ19jb25mbGljdHMgfmNvbnRlbnRzIH50YWc6KHRhZyBeIFwieHh4XCIpXG4gICAgZWxzZSB0YWdcbiAgaW5cbiAgbWF0Y2ggZGVsaW1pdGVyIHdpdGhcbiAgfCBRdW90ZSAtPiBRdW90ZVxuICB8IFRhZyB0YWcgLT4gVGFnIChmaXhfdGFnX2NvbmZsaWN0cyB+Y29udGVudHMgfnRhZylcbjs7XG5cbmxldCB0b19mb3JtYXR0ZWRfcGF5bG9hZCB+dGFnOihUIGRlbGltaXRlciA6IFN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXIudCkgY29udGVudHNcbiAgOiBQYXlsb2FkLnRcbiAgPVxuICB7IGNvbnRlbnRzOyB0YWcgPSBUIChmaXhfZGVsaW1pdGVyX2NvbmZsaWN0cyB+Y29udGVudHMgfmRlbGltaXRlcikgfVxuOztcblxubGV0IHRvX3NvdXJjZV9jb2RlX3N0cmluZ1xuICB+KGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgOiBFeHBlY3Rfbm9kZV9mb3JtYXR0aW5nLnQpXG4gIH5ub2RlX3NoYXBlOihUIHNoYXBlIDogU3RyaW5nX25vZGVfZm9ybWF0LlNoYXBlLnQpXG4gIH4odGFnIDogU3RyaW5nX25vZGVfZm9ybWF0LkRlbGltaXRlci50KVxuICBjb250ZW50c1xuICA9XG4gIGxldCBkZWxpbWl0ZXIgPVxuICAgIGZpeF9kZWxpbWl0ZXJfY29uZmxpY3RzXG4gICAgICB+Y29udGVudHNcbiAgICAgIH5kZWxpbWl0ZXI6KFN0cmluZ19ub2RlX2Zvcm1hdC5EZWxpbWl0ZXIuaGFuZGVkIHRhZyBzaGFwZS5oYW5kKVxuICBpblxuICBsZXQgcGF5bG9hZCA6IFBheWxvYWQudCA9IHsgY29udGVudHM7IHRhZyA9IFQgZGVsaW1pdGVyIH0gaW5cbiAgbWF0Y2ggc2hhcGUuaGFuZCB3aXRoXG4gIHwgTG9uZ2hhbmQgLT5cbiAgICBsZXQgcHJlZml4ID1cbiAgICAgIG1hdGNoIHNoYXBlLmtpbmQgd2l0aFxuICAgICAgfCBFeHRlbnNpb24gLT4gZXhwZWN0X25vZGVfZm9ybWF0dGluZy5leHRlbnNpb25fc2lnaWxcbiAgICAgIHwgQXR0cmlidXRlIC0+IGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuYXR0cmlidXRlX3NpZ2lsXG4gICAgaW5cbiAgICBQcmludGYuc3ByaW50ZiBcIlslcyVzICVzXVwiIHByZWZpeCBzaGFwZS5uYW1lIChQYXlsb2FkLnRvX3NvdXJjZV9jb2RlX3N0cmluZyBwYXlsb2FkKVxuICB8IFNob3J0aGFuZCAtPlxuICAgIGxldCBwcmVmaXggPVxuICAgICAgbWF0Y2ggc2hhcGUua2luZCB3aXRoXG4gICAgICB8IEV4dGVuc2lvbiAtPiBleHBlY3Rfbm9kZV9mb3JtYXR0aW5nLmV4dGVuc2lvbl9zaWdpbFxuICAgIGluXG4gICAgKG1hdGNoIGRlbGltaXRlciB3aXRoXG4gICAgIHwgVGFnIFwiXCIgLT4gUHJpbnRmLnNwcmludGYgXCJ7JXMlc3wlc3x9XCIgcHJlZml4IHNoYXBlLm5hbWUgY29udGVudHNcbiAgICAgfCBUYWcgdGFnIC0+IFByaW50Zi5zcHJpbnRmIFwieyVzJXMgJXN8JXN8JXN9XCIgcHJlZml4IHNoYXBlLm5hbWUgdGFnIGNvbnRlbnRzIHRhZylcbjs7XG4iLCJvcGVuISBCYXNlXG5vcGVuIFR5cGVzXG5cbm1vZHVsZSBEZWZpbml0aW9ucyA9IHN0cnVjdFxuICBtb2R1bGUgSW5zZXJ0X2xvYyA9IHN0cnVjdFxuICAgICgqKiBXaGV0aGVyIHRoaXMgZXhwZWN0YXRpb24gaXMgdGllZCB0byBhbiBBU1Qgbm9kZSBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIHNvdXJjZSwgYW5kXG4gICAgICAgIHRoZSBsb2NhdGlvbiBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gZGV0ZXJtaW5lIHdoZXJlIHRvIGluc2VydCBjb3JyZWN0aW9ucyBmb3IgdGhpc1xuICAgICAgICBleHBlY3RhdGlvbiAqKVxuICAgIHR5cGUgdCA9XG4gICAgICB8IE92ZXJ3cml0ZSBvZlxuICAgICAgICAgIHsgd2hvbGVfbm9kZSA6IENvbXBhY3RfbG9jLnRcbiAgICAgICAgICA7IHBheWxvYWQgOiBDb21wYWN0X2xvYy50IG9wdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgICAoKiogQW4gZXhwZWN0YXRpb24gcGFyc2VkIGZyb20gdGhlIHRlc3QgZmlsZSBhbmQgd2hpY2ggc2hvdWxkIGJlIG92ZXJ3cml0dGVuIGJ5XG4gICAgICAgICAgY29ycmVjdGlvbnMuIENvcnJlY3Rpb25zIHRvIGp1c3QgdGhlIHBheWxvYWQgc2hvdWxkIG92ZXJ3cml0ZSBqdXN0IHRoZSBbcGF5bG9hZF1cbiAgICAgICAgICBsb2NhdGlvbiwgaWYgcHJlc2VudC4gSWYgbm8gW3BheWxvYWRdIGxvY2F0aW9uIGlzIHByZXNlbnQsIG9yIGZvciBjb3JyZWN0aW9uc1xuICAgICAgICAgIHRoYXQgY2hhbmdlIHRoZSBlbnRpcmUgbm9kZSAoZS5nLiBhIGNoYW5nZSBmcm9tIFtbJWV4cGVjdCBfXV0gdG9cbiAgICAgICAgICBbWyVleHBlY3QudW5yZWFjaGFibGVdXSksIG92ZXJ3cml0ZSB0aGUgW3dob2xlX25vZGVdIGxvYy4gKilcbiAgICAgIHwgSW5zZXJ0IG9mIFZpcnR1YWxfbG9jLnRcbiAgICAgICAgICAoKiogQW4gZXhwZWN0YXRpb24gbm90IHBhcnNlZCBmcm9tIHRoZSBmaWxlIHRoYXQgc2hvdWxkIGJlIGluc2VydGVkIGludG9cbiAgICAgICAgICBbVmlydHVhbF9sb2MubG9jXSBhbmQgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdGVzdCB3aG9zZSBib2R5IGlzIGF0XG4gICAgICAgICAgW1ZpcnR1YWxfbG9jLmJvZHlfbG9jXSAqKVxuICBlbmRcblxuICBtb2R1bGUgQmVoYXZpb3JfdHlwZSA9IHN0cnVjdFxuICAgICgqKiBUaGUgdHlwZSBvZiBleHBlY3Qgbm9kZSAqKVxuICAgIHR5cGUgdCA9XG4gICAgICBbIGBFeHBlY3RcbiAgICAgIHwgYFVucmVhY2hhYmxlXG4gICAgICBdXG4gIGVuZFxuXG4gIG1vZHVsZSBFeHBlY3RfcmVhY2hhYmlsaXR5ID0gc3RydWN0XG4gICAgKCoqIFdoZXRoZXIgYW4gZXhwZWN0IG5vZGUgZXhwcmVzc2VzIGFuIGFzc2VydGlvbiB0aGF0IGNvbnRyb2wgZmxvdyBwYXNzZXMgdGhyb3VnaCBpdFxuICAgICAgICBldmVyeSB0aW1lIGEgdGVzdCBpcyBydW4gKilcbiAgICB0eXBlIHQgPVxuICAgICAgfCBDYW5fcmVhY2hcbiAgICAgICAgICAoKiogVGVzdCBwYXNzZXMgZXZlbiBpZiBub2RlIGlzIG9ubHkgcmVhY2hlZCBvbiAqc29tZSogZXhlY3V0aW9ucyBvZiBhIHRlc3QgKilcbiAgICAgIHwgTXVzdF9yZWFjaCAoKiogVGVzdCBmYWlscyB1bmxlc3Mgbm9kZSBpcyByZWFjaGVkIGJ5ICphbGwqIGV4ZWN1dGlvbnMgb2YgYSB0ZXN0ICopXG4gIGVuZFxuXG4gIG1vZHVsZSBPbl91bnJlYWNoYWJsZSA9IHN0cnVjdFxuICAgICgqKiBXaGF0IHNob3VsZCBiZSBkb25lIGlmIHRoaXMgZXhwZWN0YXRpb24gaXMgbmV2ZXIgcmVhY2hlZCBpbiB0aGUgdGVzdCBleGVjdXRpb24gKilcbiAgICB0eXBlIHQgPVxuICAgICAgfCBTaWxlbnQgKCoqIERvIG5vdGhpbmcgKilcbiAgICAgIHwgRGVsZXRlICgqKiBEZWxldGUgdGhpcyBleHBlY3RhdGlvbiBmcm9tIHRoZSBzb3VyY2UgZmlsZSAqKVxuICAgICAgfCBSZXBsYWNlX3dpdGhfdW5yZWFjaGFibGVcbiAgICAgICAgICAoKiogUmVwbGFjZSB0aGlzIGV4cGVjdGF0aW9uIHdpdGggYSBbWyVleHBlY3QudW5yZWFjaGFibGVdXSBub2RlICopXG4gIGVuZFxuXG4gIG1vZHVsZSBCZWhhdmlvciA9IHN0cnVjdFxuICAgICgqKiBBIFsnYmVoYXZpb3JfdHlwZSB0XSBkZXNjcmliZXMgaG93IHRvIGhhbmRsZSBhIHRlc3Qgbm9kZSB3aGVuIHJ1bm5pbmcgdGVzdHNcbiAgICAgICAgYW5kIHdyaXRpbmcgY29ycmVjdGlvbnMuXG5cbiAgICAgICAgWydiZWhhdmlvcl90eXBlXSBkZXRlcm1pbmVzIHRoZSB0eXBlcyBvZiByZXdyaXRlcyB0aGF0IGFyZSBwb3NzaWJsZSBhdCB0aGlzIG5vZGUuXG4gICAgICAgIEl0IGlzIGVpdGhlciBbYEV4cGVjdF0gKGluZGljYXRpbmcgdGhhdCBib3RoIGNvcnJlY3Rpb25zIGZvciB1bmV4cGVjdGVkIG91dHB1dCBhbmRcbiAgICAgICAgcmV3cml0ZXMgZm9yIHVucmVhY2hhYmlsaXR5IGFyZSBwb3NzaWJsZSkgb3IgW2BVbnJlYWNoYWJsZV0gKGluZGljYXRpbmcgdGhhdCBvbmx5XG4gICAgICAgIGNvcnJlY3Rpb25zIGZvciB1bmV4cGVjdGVkIG91dHB1dCBhcmUgcG9zc2libGUpLlxuICAgICopXG4gICAgdHlwZSBfIHQgPVxuICAgICAgfCBFeHBlY3QgOlxuICAgICAgICAgIHsgcGF5bG9hZCA6IE91dHB1dC5QYXlsb2FkLnRcbiAgICAgICAgICA7IG9uX3VucmVhY2hhYmxlIDogT25fdW5yZWFjaGFibGUudFxuICAgICAgICAgIDsgcmVhY2hhYmlsaXR5IDogRXhwZWN0X3JlYWNoYWJpbGl0eS50XG4gICAgICAgICAgfVxuICAgICAgICAgIC0+IFsgYEV4cGVjdCBdIHRcbiAgICAgIHwgVW5yZWFjaGFibGUgOlxuICAgICAgICAgIHsgcmVhY2hhYmlsaXR5X29mX2NvcnJlY3RlZCA6IEV4cGVjdF9yZWFjaGFiaWxpdHkudFxuICAgICAgICAgICAgICAoKiogVGhlIHJlYWNoYWJpbGl0eSBvZiB0aGUgbm9kZSBpbnNlcnRlZCBpZiB0aGlzIHVucmVhY2hhYmxlIG5vZGUgaXNcbiAgICAgICAgICAgICAgdW5leHBlY3RlZGx5IHJlYWNoZWQgKilcbiAgICAgICAgICB9XG4gICAgICAgICAgLT4gWyBgVW5yZWFjaGFibGUgXSB0XG4gIGVuZFxuXG4gICgqKiBBIFsoJ2JlaGF2aW9yX3R5cGUpIHRdIGNhcnJpZXMgaW5mb3JtYXRpb24gYWJvdXQgaG93IHRvIHJ1biB0ZXN0cyBmb3IgYVxuICAgICAgc3BlY2lmaWMgZXhwZWN0IG5vZGUgYW5kIHJld3JpdGUgaXQgaW4gdGhlIHNvdXJjZSBmaWxlIGlmIHRoZXJlIGFyZSBjb3JyZWN0aW9ucy4gVGhlXG4gICAgICBbJ2JlaGF2aW9yX3R5cGVdIHR5cGUgdmFyaWFibGUgaGFzIHRoZSBzYW1lIG1lYW5pbmdzIGFzIGluXG4gICAgICBbJ2JlaGF2aW9yX3R5cGUgQmVoYXZpb3IudF0uXG4gICopXG4gIHR5cGUgJ2JlaGF2aW9yX3R5cGUgdCA9XG4gICAgeyBwb3NpdGlvbiA6IEluc2VydF9sb2MudFxuICAgIDsgYmVoYXZpb3IgOiAnYmVoYXZpb3JfdHlwZSBCZWhhdmlvci50XG4gICAgOyBwYXlsb2FkX3R5cGUgOiBPdXRwdXQuVHlwZS50XG4gICAgOyBvbl9pbmNvcnJlY3Rfb3V0cHV0IDogU3RyaW5nX25vZGVfZm9ybWF0LlNoYXBlLnRcbiAgICAgICAgKCoqIFRoZSBuYW1lIGFuZCBzeW50YXggc3R5bGUgb2YgdGhlIGV4dGVuc2lvbiBwb2ludCBvciBhdHRyaWJ1dGUgdXNlZCB0byB3cml0ZVxuICAgICAgICBjb3JyZWN0aW9ucyB3aGVuIHJlY2VpdmluZyBcImluY29ycmVjdFwiIG91dHB1dCBmb3IgdGhpcyB0ZXN0IG5vZGUuIEZvciBlYWNoIFt0XSxcbiAgICAgICAgdGhlcmUgaXMgb25seSBvbmUgc3VjaCBub2RlLiBGb3IgZXhhbXBsZSwgaWYgYW4gW3slZXhwZWN0X2V4YWN0fHx9XSBub2RlIGlzXG4gICAgICAgIHJlYWNoZWQgd2l0aCBpbmNvcnJlY3Qgb3V0cHV0LCBpdCBpcyBhbHdheXMgY29ycmVjdGVkIHRvIGEgZGlmZmVyZW50XG4gICAgICAgIFt7JWV4cGVjdF9leGFjdHx8fV0gbm9kZSwgYW5kIGFuIFtbJWV4cGVjdC51bnJlYWNoYWJsZV1dIHRoYXQgaXMgcmVhY2hlZCBpc1xuICAgICAgICBhbHdheXMgY29ycmVjdGVkIHRvIGFuIFtbJWV4cGVjdF1dIG5vZGUuXG5cbiAgICAgICAgTm90ZSB0aGF0IGZvciBhIG5vZGUgdGhhdCBzaG91bGQgYmUgcmVhY2hhYmxlLCB0aGUgY29ycmVjdGlvbiB3aGVuIGl0IGlzIGZvdW5kIHRvXG4gICAgICAgIGJlIHVucmVhY2hhYmxlIGlzIGluc3RlYWQgZ292ZXJuZWQgYnkgW29uX3VucmVhY2hhYmxlXSBpbiB0aGUgW0V4cGVjdF0gY29uc3RydWN0b3JcbiAgICAgICAgb2YgW2JlaGF2aW9yXS5cbiAgICAqKVxuICAgIDsgaW5jb25zaXN0ZW50X291dHB1dHNfbWVzc2FnZSA6IHN0cmluZ1xuICAgIH1cbmVuZFxuXG5tb2R1bGUgdHlwZSBFeHBlY3RhdGlvbiA9IHNpZ1xuICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgRGVmaW5pdGlvbnNcbiAgZW5kXG5cbiAgbW9kdWxlIEluc2VydF9sb2MgOiBzaWdcbiAgICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgICAgaW5jbHVkZSBJbnNlcnRfbG9jXG4gICAgZW5kXG5cbiAgICB2YWwgbG9jIDogSW5zZXJ0X2xvYy50IC0+IENvbXBhY3RfbG9jLnRcbiAgZW5kXG5cbiAgdmFsIHdpdGhfYmVoYXZpb3IgOiAnb2xkX2JlaGF2aW9yIHQgLT4gJ25ld19iZWhhdmlvciBCZWhhdmlvci50IC0+ICduZXdfYmVoYXZpb3IgdFxuXG4gICgqKiBbZm9ybWF0dGVyIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nIHRdIHJldHVybnMgdGhlIFtPdXRwdXQuRm9ybWF0dGVyLnRdIHRoYXQgZm9ybWF0c1xuICAgICAgdGVzdCBvdXRwdXQgYWNjb3JkaW5nIHRvIHRoZSB0eXBlIChbZXhhY3RdIG9yIFtwcmV0dHldKSBvZiBbdF0sIHVzaW5nIGluZm9ybWF0aW9uXG4gICAgICBhYm91dCB0aGUgbG9jYXRpb24gYW5kIHBheWxvYWQgb2YgW3RdIGZvciBmb3JtYXR0aW5nLiAqKVxuICB2YWwgZm9ybWF0dGVyXG4gICAgOiAgZXhwZWN0X25vZGVfZm9ybWF0dGluZzpFeHBlY3Rfbm9kZV9mb3JtYXR0aW5nLnRcbiAgICAtPiBfIHRcbiAgICAtPiBPdXRwdXQuRm9ybWF0dGVyLnRcblxuICAoKiogW1slZXhwZWN0IF9dXSAqKVxuICB2YWwgZXhwZWN0XG4gICAgOiAgZm9ybWF0dGluZ19mbGV4aWJpbGl0eTpFeHBlY3Rfbm9kZV9mb3JtYXR0aW5nLkZsZXhpYmlsaXR5LnRcbiAgICAtPiBub2RlX2xvYzpDb21wYWN0X2xvYy50XG4gICAgLT4gbG9jYXRlZF9wYXlsb2FkOihPdXRwdXQuUGF5bG9hZC50ICogQ29tcGFjdF9sb2MudCkgb3B0aW9uXG4gICAgLT4gWyBgRXhwZWN0IF0gdFxuXG4gICgqKiBbWyVleHBlY3RfZXhhY3QgX11dICopXG4gIHZhbCBleHBlY3RfZXhhY3RcbiAgICA6ICBmb3JtYXR0aW5nX2ZsZXhpYmlsaXR5OkV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuRmxleGliaWxpdHkudFxuICAgIC0+IG5vZGVfbG9jOkNvbXBhY3RfbG9jLnRcbiAgICAtPiBsb2NhdGVkX3BheWxvYWQ6KE91dHB1dC5QYXlsb2FkLnQgKiBDb21wYWN0X2xvYy50KSBvcHRpb25cbiAgICAtPiBbIGBFeHBlY3QgXSB0XG5cbiAgKCoqIFtbJWV4cGVjdC51bnJlYWNoYWJsZV1dICopXG4gIHZhbCBleHBlY3RfdW5yZWFjaGFibGUgOiBub2RlX2xvYzpDb21wYWN0X2xvYy50IC0+IFsgYFVucmVhY2hhYmxlIF0gdFxuXG4gICgqKiBbW0BAZXhwZWN0LnVuY2F1Z2h0X2V4biBfXV0gKilcbiAgdmFsIGV4cGVjdF91bmNhdWdodF9leG5cbiAgICA6ICBmb3JtYXR0aW5nX2ZsZXhpYmlsaXR5OkV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuRmxleGliaWxpdHkudFxuICAgIC0+IG5vZGVfbG9jOkNvbXBhY3RfbG9jLnRcbiAgICAtPiBsb2NhdGVkX3BheWxvYWQ6KE91dHB1dC5QYXlsb2FkLnQgKiBDb21wYWN0X2xvYy50KSBvcHRpb25cbiAgICAtPiBbIGBFeHBlY3QgXSB0XG5cbiAgKCoqIFJ1bnRpbWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGltcGxpY2l0IFtbJWV4cGVjdCB7fHx9XV0gYXQgdGhlIGVuZCBvZiBldmVyeSBleHBlY3RcbiAgICAgIHRlc3QuICopXG4gIHZhbCBleHBlY3RfdHJhaWxpbmcgOiBpbnNlcnRfbG9jOlZpcnR1YWxfbG9jLnQgLT4gWyBgRXhwZWN0IF0gdFxuXG4gICgqKiBSdW50aW1lIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhc3NlcnRpb24gdGhhdCBhIHRlc3QgZG9lcyBub3QgcHJvZHVjZSB1bmNhdWdodFxuICAgICAgZXhjZXB0aW9ucywgd2hpY2ggYSB1c2VyIGltcGxpY2l0bHkgbWFrZXMgYnkgb21pdHRpbmcgYW4gW1tAQGV4cGVjdC51bmNhdWdodF9leG4gX11dXG4gICAgICBhdHRyaWJ1dGUuICopXG4gIHZhbCBleHBlY3Rfbm9fdW5jYXVnaHRfZXhuIDogaW5zZXJ0X2xvYzpWaXJ0dWFsX2xvYy50IC0+IFsgYFVucmVhY2hhYmxlIF0gdFxuXG4gIG1vZHVsZSBGb3JfYXBwbHlfc3R5bGUgOiBzaWdcbiAgICB0eXBlIGZvcm1hdF9wYXlsb2FkIDo9XG4gICAgICBleHBlY3Rfbm9kZV9mb3JtYXR0aW5nOkV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcudFxuICAgICAgLT4gcGF5bG9hZF9sb2M6Q29tcGFjdF9sb2MudFxuICAgICAgLT4gbm9kZV9sb2M6Q29tcGFjdF9sb2MudFxuICAgICAgLT4gU3RyaW5nX25vZGVfZm9ybWF0LkRlbGltaXRlci50XG4gICAgICAtPiBzdHJpbmdcbiAgICAgIC0+IHN0cmluZyBvcHRpb25cblxuICAgIHZhbCBmb3JtYXRfZXhwZWN0X3BheWxvYWQgOiBmb3JtYXRfcGF5bG9hZFxuICAgIHZhbCBmb3JtYXRfdW5jYXVnaHRfZXhuX3BheWxvYWQgOiBmb3JtYXRfcGF5bG9hZFxuICBlbmRcbmVuZFxuIiwib3BlbiEgQmFzZVxub3BlbiBUeXBlc1xuaW5jbHVkZSBFeHBlY3RhdGlvbl9pbnRmLkRlZmluaXRpb25zXG5cbm1vZHVsZSBJbnNlcnRfbG9jID0gc3RydWN0XG4gIGluY2x1ZGUgSW5zZXJ0X2xvY1xuXG4gIGxldCBsb2MgPSBmdW5jdGlvblxuICAgIHwgT3ZlcndyaXRlIHsgd2hvbGVfbm9kZTsgcGF5bG9hZCA9IF8gfSAtPiB3aG9sZV9ub2RlXG4gICAgfCBJbnNlcnQgeyBsb2M7IGJvZHlfbG9jID0gXyB9IC0+IGxvY1xuICA7O1xuZW5kXG5cbmxldCB3aXRoX2JlaGF2aW9yXG4gIHsgcG9zaXRpb25cbiAgOyBiZWhhdmlvciA9IF9cbiAgOyBwYXlsb2FkX3R5cGVcbiAgOyBvbl9pbmNvcnJlY3Rfb3V0cHV0XG4gIDsgaW5jb25zaXN0ZW50X291dHB1dHNfbWVzc2FnZVxuICB9XG4gIGJlaGF2aW9yXG4gID1cbiAgeyBwb3NpdGlvbjsgYmVoYXZpb3I7IHBheWxvYWRfdHlwZTsgb25faW5jb3JyZWN0X291dHB1dDsgaW5jb25zaXN0ZW50X291dHB1dHNfbWVzc2FnZSB9XG47O1xuXG5sZXQgZm9ybWF0dGVyXG4gICh0eXBlIGJlaGF2aW9yKVxuICB+KGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgOiBFeHBlY3Rfbm9kZV9mb3JtYXR0aW5nLnQpXG4gICh7IHBvc2l0aW9uXG4gICA7IGJlaGF2aW9yXG4gICA7IHBheWxvYWRfdHlwZVxuICAgOyBvbl9pbmNvcnJlY3Rfb3V0cHV0ID0gVCBvbl9pbmNvcnJlY3Rfb3V0cHV0XG4gICA7IGluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2UgPSBfXG4gICB9IDpcbiAgICBiZWhhdmlvciB0KVxuICA9XG4gIGxldCBjb3VudF9sZWFkaW5nX3NwYWNlcyBsaW5lID1cbiAgICBsaW5lIHw+IFN0cmluZy50b19saXN0IHw+IExpc3QudGFrZV93aGlsZSB+ZjooQ2hhci4oID0gKSAnICcpIHw+IExpc3QubGVuZ3RoXG4gIGluXG4gIE91dHB1dC5Gb3JtYXR0ZXIuY3JlYXRlXG4gIEBAXG4gIG1hdGNoIHBheWxvYWRfdHlwZSB3aXRoXG4gIHwgRXhhY3QgLT4gRm4uaWRcbiAgfCBQcmV0dHkgLT5cbiAgICBmdW4gc3RyIC0+XG4gICAgICBsZXQgbGluZXMgPVxuICAgICAgICAoKiBJbiBwcmV0dHkgcGF5bG9hZHMsIHdlIG5vcm1hbGl6ZSBhbGwgbmV3bGluZXMgdG8gWydcXG4nXS4gW1slZXhwZWN0X2V4YWN0IFwiXCJdXVxuICAgICAgICAgICBjYW4gYmUgdXNlZCBpbiBjYXNlcyB3aGVyZSBhIHVzZXIgd2FudHMgdG8gaW5zcGVjdCB0aGUgd2hpdGVzcGFjZSBwcm9kdWNlZCBieVxuICAgICAgICAgICB0aGVpciBvdXRwdXQgbW9yZSBjbG9zZWx5LiAqKVxuICAgICAgICBsZXQgc3RyaXBwZWQgPVxuICAgICAgICAgIHN0clxuICAgICAgICAgIHw+IFN0cmluZy5zcGxpdF9saW5lc1xuICAgICAgICAgIHw+IExpc3QubWFwIH5mOihTdHJpbmcucnN0cmlwIH5kcm9wOkNoYXIuaXNfd2hpdGVzcGFjZSlcbiAgICAgICAgICB8PiBMaXN0LmRyb3Bfd2hpbGUgfmY6U3RyaW5nLmlzX2VtcHR5XG4gICAgICAgICAgfD4gTGlzdC5yZXZcbiAgICAgICAgICB8PiBMaXN0LmRyb3Bfd2hpbGUgfmY6U3RyaW5nLmlzX2VtcHR5XG4gICAgICAgICAgfD4gTGlzdC5yZXZcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGluZGVudF9hbmRfY29udGVudHMgPVxuICAgICAgICAgIExpc3QubWFwIHN0cmlwcGVkIH5mOihmdW4gbGluZSAtPlxuICAgICAgICAgICAgKCogVGhlIGxlZ2FjeSBiZWhhdmlvciBpcyB0byBvbmx5IGNvdW50IHRoZSBsb25nZXN0IHByZWZpeCBvZiBhY3R1YWwgc3BhY2VzXG4gICAgICAgICAgICAgICAoWycgJ10pIGZvciBpbmRlbnRhdGlvbiwgYnV0IHRvIHN0cmlwIGFsbCB3aGl0ZXNwYWNlIChpbmNsdWRpbmcsIGUuZy4sXG4gICAgICAgICAgICAgICBbJ1xcdCddKS4gTm90ZSB0aGF0IHRoaXMgbWVhbnMgW1wiIFxcdCBjb250ZW50c1wiXSBpcyBjb3VudGVkIGFzIGhhdmluZ1xuICAgICAgICAgICAgICAgY29udGVudHMgW1wiY29udGVudHNcIl0gYW5kIGluZGVudGF0aW9uIFsxXS4gKilcbiAgICAgICAgICAgIGNvdW50X2xlYWRpbmdfc3BhY2VzIGxpbmUsIFN0cmluZy5zdHJpcCBsaW5lKVxuICAgICAgICBpblxuICAgICAgICBtYXRjaFxuICAgICAgICAgIGluZGVudF9hbmRfY29udGVudHNcbiAgICAgICAgICB8PiBMaXN0LmZpbHRlcl9tYXAgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgICAgICB8IF9pbmRlbnQsIFwiXCIgLT4gTm9uZVxuICAgICAgICAgICAgICAgfCBpbmRlbnQsIF8gLT4gU29tZSBpbmRlbnQpXG4gICAgICAgICAgfD4gTGlzdC5taW5fZWx0IH5jb21wYXJlOkludC5jb21wYXJlXG4gICAgICAgIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFtdXG4gICAgICAgIHwgU29tZSBtaW5faW5kZW50IC0+XG4gICAgICAgICAgTGlzdC5tYXAgaW5kZW50X2FuZF9jb250ZW50cyB+ZjooZnVuIChpbmRlbnQsIGxpbmUpIC0+XG4gICAgICAgICAgICBJbnQubWF4IDAgKGluZGVudCAtIG1pbl9pbmRlbnQpLCBsaW5lKVxuICAgICAgaW5cbiAgICAgIGxldCAoVCB0YWcpID1cbiAgICAgICAgbWF0Y2ggKGJlaGF2aW9yIDogXyBCZWhhdmlvci50KSB3aXRoXG4gICAgICAgIHwgRXhwZWN0IHsgcGF5bG9hZCA9IHsgdGFnOyBjb250ZW50cyA9IF8gfTsgXyB9IC0+IHRhZ1xuICAgICAgICB8IFVucmVhY2hhYmxlIF8gLT4gU3RyaW5nX25vZGVfZm9ybWF0LkRlbGltaXRlci5kZWZhdWx0XG4gICAgICBpblxuICAgICAgKG1hdGNoIGxpbmVzLCBleHBlY3Rfbm9kZV9mb3JtYXR0aW5nLmFsd2F5c19vbl9vd25fbGluZSB3aXRoXG4gICAgICAgfCBbXSwgXyAtPlxuICAgICAgICAgKCogQW4gZW1wdHkgYm9keSBzaG91bGQgZWl0aGVyIGJlIFt7fCB8fV0gb3IgW1wiXCJdICopXG4gICAgICAgICAobWF0Y2ggdGFnIHdpdGhcbiAgICAgICAgICB8IFRhZyBfIC0+IFwiIFwiXG4gICAgICAgICAgfCBRdW90ZSAtPiBcIlwiKVxuICAgICAgIHwgWyAoX2luZGVudCwgbGluZSkgXSwgZmFsc2UgLT5cbiAgICAgICAgICgqIEEgc2luZ2xlIGxpbmUgc2hvdWxkIGVpdGhlciBiZSBbe3wgbGluZSB8fV0gb3IgW1wibGluZVwiXSAqKVxuICAgICAgICAgKG1hdGNoIHRhZyB3aXRoXG4gICAgICAgICAgfCBUYWcgXyAtPiBTdHJpbmcuY29uY2F0IFsgXCIgXCI7IGxpbmU7IFwiIFwiIF1cbiAgICAgICAgICB8IFF1b3RlIC0+IGxpbmUpXG4gICAgICAgfCBsaW5lcywgXyAtPlxuICAgICAgICAgbGV0IGxvY2F0aW9uX2luZGVudCA9XG4gICAgICAgICAgIGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuaW5kZW50XG4gICAgICAgICAgICgqIFRoZSBjb250ZW50cyBhcmUgYWx3YXlzIGluZGVudGVkIHR3byBzcGFjZXMgcGFzdCB0aGUgbGVmdCBlZGdlIG9mIHRoZVxuICAgICAgICAgICAgICBleHRlbnNpb24gcG9pbnQgKilcbiAgICAgICAgICAgK1xuICAgICAgICAgICBtYXRjaCBwb3NpdGlvbiB3aXRoXG4gICAgICAgICAgIHwgT3ZlcndyaXRlIHsgd2hvbGVfbm9kZSA9IHsgc3RhcnRfYm9sOyBzdGFydF9wb3M7IGVuZF9wb3MgPSBfIH07IHBheWxvYWQgPSBfIH1cbiAgICAgICAgICAgICAtPlxuICAgICAgICAgICAgICgqIElmIHdlIGFyZSBvdmVyd3JpdGluZyBhbiBleHRlbnNpb24gcG9pbnQsIHdlIHNob3VsZCB0YWtlIGl0cyBsZWZ0IGVkZ2UgKilcbiAgICAgICAgICAgICBzdGFydF9wb3MgLSBzdGFydF9ib2xcbiAgICAgICAgICAgfCBJbnNlcnQgeyBib2R5X2xvYyA9IHsgc3RhcnRfYm9sOyBzdGFydF9wb3M7IGVuZF9wb3MgPSBfIH07IGxvYyA9IF8gfSAtPlxuICAgICAgICAgICAgICgqIElmIHdlIGFyZSBpbnNlcnRpbmcgYSBuZXcgZXh0ZW5zaW9uIHBvaW50LCB3ZSBzaG91bGQgY29tcHV0ZSBpdHMgbGVmdFxuICAgICAgICAgICAgICAgIGVkZ2VkIGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGUgW2xldCVleHBlY3RfdGVzdF0gbm9kZSAqKVxuICAgICAgICAgICAgIHN0YXJ0X3Bvc1xuICAgICAgICAgICAgIC0gc3RhcnRfYm9sXG4gICAgICAgICAgICAgK1xuICAgICAgICAgICAgIChtYXRjaCBvbl9pbmNvcnJlY3Rfb3V0cHV0LmtpbmQgd2l0aFxuICAgICAgICAgICAgICB8IEV4dGVuc2lvbiAtPiBleHBlY3Rfbm9kZV9mb3JtYXR0aW5nLmluZGVudFxuICAgICAgICAgICAgICB8IEF0dHJpYnV0ZSAtPiAwKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBzcGFjZXMgbiA9IFN0cmluZy5tYWtlIG4gJyAnIGluXG4gICAgICAgICBsZXQgZmlyc3RfbGluZSwgaW5kZW50YXRpb24sIGxhc3RfbGluZSA9XG4gICAgICAgICAgIG1hdGNoIHRhZyB3aXRoXG4gICAgICAgICAgIHwgUXVvdGUgLT5cbiAgICAgICAgICAgICAoKiBTaW5jZSBvY2FtbGZvcm1hdCB3aWxsIHNwbGl0IHRoZSBzdHJpbmcgb250byBsaW5lcyBhbmQgaW5kZW50IHRoZW0gZm9yXG4gICAgICAgICAgICAgICAgdXMsIHdlIHNob3VsZG4ndCBpbnNlcnQgbGl0ZXJhbCB3aGl0ZXNwYWNlIHRvIGluZGVudCB0aGUgc3RyaW5nLiAqKVxuICAgICAgICAgICAgIFwiIFwiLCAxLCBcIiBcIlxuICAgICAgICAgICB8IFRhZyBfIC0+IFwiXCIsIGxvY2F0aW9uX2luZGVudCwgc3BhY2VzIGxvY2F0aW9uX2luZGVudFxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBsaW5lcyA9XG4gICAgICAgICAgIExpc3QubWFwIGxpbmVzIH5mOihmdW5jdGlvblxuICAgICAgICAgICAgIHwgX2luZGVudCwgXCJcIiAtPiBcIlwiXG4gICAgICAgICAgICAgfCBsaW5lX2luZGVudCwgbGluZSAtPiBzcGFjZXMgKGluZGVudGF0aW9uICsgbGluZV9pbmRlbnQpIF4gbGluZSlcbiAgICAgICAgIGluXG4gICAgICAgICBbIFsgZmlyc3RfbGluZSBdOyBsaW5lczsgWyBsYXN0X2xpbmUgXSBdXG4gICAgICAgICB8PiBMaXN0LmNvbmNhdFxuICAgICAgICAgfD4gU3RyaW5nLmNvbmNhdCB+c2VwOlwiXFxuXCIpXG47O1xuXG5sZXQgZXh0ZW5zaW9uX3N5bnRheCBleHRlbnNpb25fbmFtZSB+cGF5bG9hZF9sb2Mgfm5vZGVfbG9jID1cbiAgbGV0IGNvbnRhaW5zIChvdXRlciA6IENvbXBhY3RfbG9jLnQpIH4oaW5uZXIgOiBDb21wYWN0X2xvYy50KSA9XG4gICAgb3V0ZXIuc3RhcnRfcG9zIDw9IGlubmVyLnN0YXJ0X3BvcyAmJiBvdXRlci5lbmRfcG9zID49IGlubmVyLmVuZF9wb3NcbiAgaW5cbiAgbWF0Y2ggcGF5bG9hZF9sb2Mgd2l0aFxuICB8IFNvbWUgcGF5bG9hZF9sb2Mgd2hlbiBjb250YWlucyBwYXlsb2FkX2xvYyB+aW5uZXI6bm9kZV9sb2MgLT5cbiAgICAoKiBBbiBleHRlbnNpb24gcG9pbnQgd2hvc2UgcGF5bG9hZCBsb2NhdGlvbiBjb250YWlucyB0aGUgbG9jYXRpb24gb2YgdGhlIGVudGlyZVxuICAgICAgIGV4dGVuc2lvbiBwb2ludCBpcyB1c2luZyB0aGUgXCJzaG9ydGhhbmRcIiBzeW50YXguICopXG4gICAgKFQgeyBuYW1lID0gZXh0ZW5zaW9uX25hbWU7IGtpbmQgPSBFeHRlbnNpb247IGhhbmQgPSBTaG9ydGhhbmQgfVxuICAgICAgOiBTdHJpbmdfbm9kZV9mb3JtYXQuU2hhcGUudClcbiAgfCBfIC0+IFQgeyBuYW1lID0gZXh0ZW5zaW9uX25hbWU7IGtpbmQgPSBFeHRlbnNpb247IGhhbmQgPSBMb25naGFuZCB9XG47O1xuXG5sZXQgcG9zc2libHlfcmVsYXhfc3RyaWN0bmVzc1xuICB+KGZvcm1hdHRpbmdfZmxleGliaWxpdHkgOiBFeHBlY3Rfbm9kZV9mb3JtYXR0aW5nLkZsZXhpYmlsaXR5LnQpXG4gICh0IDogWyBgRXhwZWN0IF0gdClcbiAgPVxuICBtYXRjaCBmb3JtYXR0aW5nX2ZsZXhpYmlsaXR5IHdpdGhcbiAgfCBFeGFjdGx5X2Zvcm1hdHRlZCAtPiB0XG4gIHwgRmxleGlibGVfbW9kdWxvIGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgLT5cbiAgICBsZXQgZm10ID0gZm9ybWF0dGVyIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nIHQgaW5cbiAgICBsZXQgKEV4cGVjdCB7IHBheWxvYWQgPSB7IGNvbnRlbnRzOyB0YWcgfTsgb25fdW5yZWFjaGFibGU7IHJlYWNoYWJpbGl0eSB9KSA9XG4gICAgICB0LmJlaGF2aW9yXG4gICAgaW5cbiAgICAobWF0Y2hcbiAgICAgICBPdXRwdXQucmVjb25jaWxlXG4gICAgICAgICB+ZXhwZWN0ZWRfb3V0cHV0OmNvbnRlbnRzXG4gICAgICAgICB+dGVzdF9vdXRwdXQ6KE91dHB1dC5Gb3JtYXR0ZXIuYXBwbHkgZm10IGNvbnRlbnRzKVxuICAgICB3aXRoXG4gICAgIHwgUGFzcyAtPiB0XG4gICAgIHwgRmFpbCBjb250ZW50cyAtPlxuICAgICAgIGxldCBwYXlsb2FkID0gT3V0cHV0LnRvX2Zvcm1hdHRlZF9wYXlsb2FkIH50YWcgY29udGVudHMgaW5cbiAgICAgICB3aXRoX2JlaGF2aW9yIHQgKEV4cGVjdCB7IHBheWxvYWQ7IG9uX3VucmVhY2hhYmxlOyByZWFjaGFiaWxpdHkgfSkpXG47O1xuXG5sZXQgZXhwZWN0ZWRfc3RyaW5nX2FuZF9wYXlsb2FkX2xvYyA9IGZ1bmN0aW9uXG4gIHwgU29tZSAoYSwgYikgLT4gYSwgU29tZSBiXG4gIHwgTm9uZSAtPiBPdXRwdXQuUGF5bG9hZC5kZWZhdWx0IFwiXCIsIE5vbmVcbjs7XG5cbmxldCBleHBlY3QgfmZvcm1hdHRpbmdfZmxleGliaWxpdHkgfm5vZGVfbG9jIH5sb2NhdGVkX3BheWxvYWQgPVxuICBsZXQgcGF5bG9hZCwgcGF5bG9hZF9sb2MgPSBleHBlY3RlZF9zdHJpbmdfYW5kX3BheWxvYWRfbG9jIGxvY2F0ZWRfcGF5bG9hZCBpblxuICB7IHBvc2l0aW9uID0gT3ZlcndyaXRlIHsgd2hvbGVfbm9kZSA9IG5vZGVfbG9jOyBwYXlsb2FkID0gcGF5bG9hZF9sb2MgfVxuICA7IGJlaGF2aW9yID1cbiAgICAgIEV4cGVjdFxuICAgICAgICB7IHBheWxvYWQ7IG9uX3VucmVhY2hhYmxlID0gUmVwbGFjZV93aXRoX3VucmVhY2hhYmxlOyByZWFjaGFiaWxpdHkgPSBDYW5fcmVhY2ggfVxuICA7IHBheWxvYWRfdHlwZSA9IFByZXR0eVxuICA7IG9uX2luY29ycmVjdF9vdXRwdXQgPSBleHRlbnNpb25fc3ludGF4IFwiZXhwZWN0XCIgfnBheWxvYWRfbG9jIH5ub2RlX2xvY1xuICA7IGluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2UgPSBcInRlc3Qgb3V0cHV0XCJcbiAgfVxuICB8PiBwb3NzaWJseV9yZWxheF9zdHJpY3RuZXNzIH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5XG47O1xuXG5sZXQgZXhwZWN0X2V4YWN0IH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5IH5ub2RlX2xvYyB+bG9jYXRlZF9wYXlsb2FkID1cbiAgbGV0IHBheWxvYWQsIHBheWxvYWRfbG9jID0gZXhwZWN0ZWRfc3RyaW5nX2FuZF9wYXlsb2FkX2xvYyBsb2NhdGVkX3BheWxvYWQgaW5cbiAgeyBwb3NpdGlvbiA9IE92ZXJ3cml0ZSB7IHdob2xlX25vZGUgPSBub2RlX2xvYzsgcGF5bG9hZCA9IHBheWxvYWRfbG9jIH1cbiAgOyBiZWhhdmlvciA9XG4gICAgICBFeHBlY3RcbiAgICAgICAgeyBwYXlsb2FkOyBvbl91bnJlYWNoYWJsZSA9IFJlcGxhY2Vfd2l0aF91bnJlYWNoYWJsZTsgcmVhY2hhYmlsaXR5ID0gQ2FuX3JlYWNoIH1cbiAgOyBwYXlsb2FkX3R5cGUgPSBFeGFjdFxuICA7IG9uX2luY29ycmVjdF9vdXRwdXQgPSBleHRlbnNpb25fc3ludGF4IFwiZXhwZWN0X2V4YWN0XCIgfnBheWxvYWRfbG9jIH5ub2RlX2xvY1xuICA7IGluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2UgPSBcInRlc3Qgb3V0cHV0XCJcbiAgfVxuICB8PiBwb3NzaWJseV9yZWxheF9zdHJpY3RuZXNzIH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5XG47O1xuXG5sZXQgZXhwZWN0X3VucmVhY2hhYmxlIH5ub2RlX2xvYyA9XG4gIHsgcG9zaXRpb24gPSBPdmVyd3JpdGUgeyB3aG9sZV9ub2RlID0gbm9kZV9sb2M7IHBheWxvYWQgPSBOb25lIH1cbiAgOyBiZWhhdmlvciA9IFVucmVhY2hhYmxlIHsgcmVhY2hhYmlsaXR5X29mX2NvcnJlY3RlZCA9IENhbl9yZWFjaCB9XG4gIDsgcGF5bG9hZF90eXBlID0gUHJldHR5XG4gIDsgb25faW5jb3JyZWN0X291dHB1dCA9IFQgeyBuYW1lID0gXCJleHBlY3RcIjsga2luZCA9IEV4dGVuc2lvbjsgaGFuZCA9IExvbmdoYW5kIH1cbiAgOyBpbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlID0gXCJ0ZXN0IG91dHB1dFwiXG4gIH1cbjs7XG5cbmxldCBleHBlY3RfdW5jYXVnaHRfZXhuIH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5IH5ub2RlX2xvYyB+bG9jYXRlZF9wYXlsb2FkID1cbiAgbGV0IHBheWxvYWQsIHBheWxvYWRfbG9jID0gZXhwZWN0ZWRfc3RyaW5nX2FuZF9wYXlsb2FkX2xvYyBsb2NhdGVkX3BheWxvYWQgaW5cbiAgeyBwb3NpdGlvbiA9IE92ZXJ3cml0ZSB7IHdob2xlX25vZGUgPSBub2RlX2xvYzsgcGF5bG9hZCA9IHBheWxvYWRfbG9jIH1cbiAgOyBiZWhhdmlvciA9IEV4cGVjdCB7IHBheWxvYWQ7IG9uX3VucmVhY2hhYmxlID0gRGVsZXRlOyByZWFjaGFiaWxpdHkgPSBNdXN0X3JlYWNoIH1cbiAgOyBwYXlsb2FkX3R5cGUgPSBQcmV0dHlcbiAgOyBvbl9pbmNvcnJlY3Rfb3V0cHV0ID1cbiAgICAgIFQgeyBuYW1lID0gXCJleHBlY3QudW5jYXVnaHRfZXhuXCI7IGtpbmQgPSBBdHRyaWJ1dGU7IGhhbmQgPSBMb25naGFuZCB9XG4gIDsgaW5jb25zaXN0ZW50X291dHB1dHNfbWVzc2FnZSA9IFwidW5jYXVnaHQgZXhjZXB0aW9uXCJcbiAgfVxuICB8PiBwb3NzaWJseV9yZWxheF9zdHJpY3RuZXNzIH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5XG47O1xuXG5sZXQgZXhwZWN0X3RyYWlsaW5nIH5pbnNlcnRfbG9jID1cbiAgeyBwb3NpdGlvbiA9IEluc2VydCBpbnNlcnRfbG9jXG4gIDsgYmVoYXZpb3IgPVxuICAgICAgRXhwZWN0XG4gICAgICAgIHsgcGF5bG9hZCA9IE91dHB1dC5QYXlsb2FkLmRlZmF1bHQgXCIgXCJcbiAgICAgICAgOyBvbl91bnJlYWNoYWJsZSA9IFNpbGVudFxuICAgICAgICA7IHJlYWNoYWJpbGl0eSA9IENhbl9yZWFjaFxuICAgICAgICB9XG4gIDsgcGF5bG9hZF90eXBlID0gUHJldHR5XG4gIDsgb25faW5jb3JyZWN0X291dHB1dCA9IFQgeyBuYW1lID0gXCJleHBlY3RcIjsga2luZCA9IEV4dGVuc2lvbjsgaGFuZCA9IExvbmdoYW5kIH1cbiAgOyBpbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlID0gXCJ0cmFpbGluZyBvdXRwdXRcIlxuICB9XG47O1xuXG5sZXQgZXhwZWN0X25vX3VuY2F1Z2h0X2V4biB+aW5zZXJ0X2xvYyA9XG4gIHsgcG9zaXRpb24gPSBJbnNlcnQgaW5zZXJ0X2xvY1xuICA7IGJlaGF2aW9yID0gVW5yZWFjaGFibGUgeyByZWFjaGFiaWxpdHlfb2ZfY29ycmVjdGVkID0gTXVzdF9yZWFjaCB9XG4gIDsgcGF5bG9hZF90eXBlID0gUHJldHR5XG4gIDsgb25faW5jb3JyZWN0X291dHB1dCA9XG4gICAgICBUIHsgbmFtZSA9IFwiZXhwZWN0LnVuY2F1Z2h0X2V4blwiOyBraW5kID0gQXR0cmlidXRlOyBoYW5kID0gTG9uZ2hhbmQgfVxuICA7IGluY29uc2lzdGVudF9vdXRwdXRzX21lc3NhZ2UgPSBcInVuY2F1Z2h0IGV4Y2VwdGlvblwiXG4gIH1cbjs7XG5cbm1vZHVsZSBGb3JfYXBwbHlfc3R5bGUgPSBzdHJ1Y3RcbiAgbGV0IGZvcm1hdF9wYXlsb2FkIG1rX25vZGUgPVxuICAgIFN0YWdlZC5zdGFnZVxuICAgIEBAIGZ1biB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyB+cGF5bG9hZF9sb2Mgfm5vZGVfbG9jIHRhZyBjb250ZW50cyAtPlxuICAgIGxldCBub2RlID1cbiAgICAgIG1rX25vZGVcbiAgICAgICAgfmZvcm1hdHRpbmdfZmxleGliaWxpdHk6KEV4YWN0bHlfZm9ybWF0dGVkIDogRXhwZWN0X25vZGVfZm9ybWF0dGluZy5GbGV4aWJpbGl0eS50KVxuICAgICAgICB+bm9kZV9sb2NcbiAgICAgICAgfmxvY2F0ZWRfcGF5bG9hZDooU29tZSAoKHsgdGFnOyBjb250ZW50cyB9IDogT3V0cHV0LlBheWxvYWQudCksIHBheWxvYWRfbG9jKSlcbiAgICBpblxuICAgIGxldCBmb3JtYXR0ZWRfY29udGVudHMgPVxuICAgICAgT3V0cHV0LkZvcm1hdHRlci5hcHBseSAoZm9ybWF0dGVyIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nIG5vZGUpIGNvbnRlbnRzXG4gICAgaW5cbiAgICBtYXRjaCBPdXRwdXQucmVjb25jaWxlIH5leHBlY3RlZF9vdXRwdXQ6Y29udGVudHMgfnRlc3Rfb3V0cHV0OmZvcm1hdHRlZF9jb250ZW50cyB3aXRoXG4gICAgfCBQYXNzIC0+IE5vbmVcbiAgICB8IEZhaWwgY29udGVudHMgLT5cbiAgICAgIGxldCBzb3VyY2VfY29kZV9zdHJpbmcgPVxuICAgICAgICBtYXRjaCBub2RlLm9uX2luY29ycmVjdF9vdXRwdXQgd2l0aFxuICAgICAgICB8IFQgeyBoYW5kID0gTG9uZ2hhbmQ7IF8gfSAtPlxuICAgICAgICAgIE91dHB1dC50b19mb3JtYXR0ZWRfcGF5bG9hZCB+dGFnIGNvbnRlbnRzXG4gICAgICAgICAgfD4gT3V0cHV0LlBheWxvYWQudG9fc291cmNlX2NvZGVfc3RyaW5nXG4gICAgICAgIHwgVCB7IGhhbmQgPSBTaG9ydGhhbmQ7IF8gfSBhcyBub2RlX3NoYXBlIC0+XG4gICAgICAgICAgT3V0cHV0LnRvX3NvdXJjZV9jb2RlX3N0cmluZyB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZyB+bm9kZV9zaGFwZSB+dGFnIGNvbnRlbnRzXG4gICAgICBpblxuICAgICAgU29tZSBzb3VyY2VfY29kZV9zdHJpbmdcbiAgOztcblxuICBsZXQgZm9ybWF0X2V4cGVjdF9wYXlsb2FkID0gZm9ybWF0X3BheWxvYWQgZXhwZWN0IHw+IFN0YWdlZC51bnN0YWdlXG4gIGxldCBmb3JtYXRfdW5jYXVnaHRfZXhuX3BheWxvYWQgPSBmb3JtYXRfcGF5bG9hZCBleHBlY3RfdW5jYXVnaHRfZXhuIHw+IFN0YWdlZC51bnN0YWdlXG5lbmRcbiIsIm9wZW4hIEJhc2Vcbm9wZW4gVHlwZXNcblxubW9kdWxlIENvcnJlY3Rpb24gPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IE5ld19wYXlsb2FkIDpcbiAgICAgICAgWzwgRXhwZWN0YXRpb24uQmVoYXZpb3JfdHlwZS50IF0gRXhwZWN0YXRpb24udCAqIE91dHB1dC5SZWNvbmNpbGVkLnRcbiAgICAgICAgLT4gdFxuICAgIHwgVW5yZWFjaGFibGUgOiBbIGBFeHBlY3QgXSBFeHBlY3RhdGlvbi50IC0+IHRcblxuICAoKiogW1NvbWUgKGxvYywgcGF0Y2gpXSBpZiBbY29ycmVjdGlvbl0gd2FycmFudHMgaW5zZXJ0aW5nIFtwYXRjaF0gaW50byB0aGUgcmV3cml0dGVuXG4gICAgICBmaWxlIGF0IFtsb2NdLCBbTm9uZV0gaWYgbm8gY2hhbmdlIGlzIG5lZWRlZCBmcm9tIFtjb3JyZWN0aW9uXS4gKilcbiAgbGV0IHRvX3BhdGNoX29wdCB+KGV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgOiBFeHBlY3Rfbm9kZV9mb3JtYXR0aW5nLnQpIGNvcnJlY3Rpb24gPVxuICAgIG1hdGNoIGNvcnJlY3Rpb24gd2l0aFxuICAgIHwgTmV3X3BheWxvYWRcbiAgICAgICAgKCB7IHBvc2l0aW9uXG4gICAgICAgICAgOyBiZWhhdmlvclxuICAgICAgICAgIDsgb25faW5jb3JyZWN0X291dHB1dCA9IFQgb25faW5jb3JyZWN0X291dHB1dFxuICAgICAgICAgIDsgaW5jb25zaXN0ZW50X291dHB1dHNfbWVzc2FnZSA9IF9cbiAgICAgICAgICA7IHBheWxvYWRfdHlwZSA9IF9cbiAgICAgICAgICB9XG4gICAgICAgICwgdGVzdF9vdXRwdXQgKSAtPlxuICAgICAgbGV0IHdoaXRlc3BhY2UgPVxuICAgICAgICBtYXRjaCBwb3NpdGlvbiB3aXRoXG4gICAgICAgIHwgSW5zZXJ0IHsgYm9keV9sb2MgPSB7IHN0YXJ0X3Bvczsgc3RhcnRfYm9sOyBfIH07IF8gfSAtPlxuICAgICAgICAgICgqIFtsZXRfb2Zmc2V0XSBpcyB0aGUgc3BhY2UgdW50aWwgdGhlIGxheWVyIG9mIGluZGVudGF0aW9uIG9mIHRoZVxuICAgICAgICAgICAgIFtsZXQlZXhwZWN0X3Rlc3RdIGJpbmRpbmcuICopXG4gICAgICAgICAgbGV0IGxldF9vZmZzZXQgPSBzdGFydF9wb3MgLSBzdGFydF9ib2wgaW5cbiAgICAgICAgICAoKiBUaGUgY29udGVudHMgb2YgdGhlIGV4cGVjdCBub2RlIGFyZSBpbmRlbnRlZCBhbiBhZGRpdGlvbmFsIHR3byBzcGFjZXMgcGFzdFxuICAgICAgICAgICAgIHRoZSBub2RlIGl0c2VsZi4gKilcbiAgICAgICAgICBsZXQgaW5kZW50ID1cbiAgICAgICAgICAgIGxldF9vZmZzZXRcbiAgICAgICAgICAgICtcbiAgICAgICAgICAgIG1hdGNoIG9uX2luY29ycmVjdF9vdXRwdXQua2luZCB3aXRoXG4gICAgICAgICAgICB8IEV4dGVuc2lvbiAtPiBleHBlY3Rfbm9kZV9mb3JtYXR0aW5nLmluZGVudFxuICAgICAgICAgICAgfCBBdHRyaWJ1dGUgLT4gMFxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IHdoaXRlc3BhY2UgPSBcIlxcblwiIF4gU3RyaW5nLm1ha2UgaW5kZW50ICcgJyBpblxuICAgICAgICAgIHdoaXRlc3BhY2VcbiAgICAgICAgfCBPdmVyd3JpdGUgXyAtPiBcIlwiXG4gICAgICBpblxuICAgICAgbGV0IHRhZyA9XG4gICAgICAgIG1hdGNoIGJlaGF2aW9yIHdpdGhcbiAgICAgICAgfCBFeHBlY3QgeyBwYXlsb2FkID0geyB0YWc7IF8gfTsgb25fdW5yZWFjaGFibGUgPSBfOyByZWFjaGFiaWxpdHkgPSBfIH0gLT4gdGFnXG4gICAgICAgIHwgVW5yZWFjaGFibGUgXyAtPiBTdHJpbmdfbm9kZV9mb3JtYXQuRGVsaW1pdGVyLmRlZmF1bHRcbiAgICAgIGluXG4gICAgICBsZXQgbG9jLCBjb3JyZWN0aW9uID1cbiAgICAgICAgbWF0Y2ggcG9zaXRpb24sIG9uX2luY29ycmVjdF9vdXRwdXQgd2l0aFxuICAgICAgICB8ICggT3ZlcndyaXRlIHsgcGF5bG9hZCA9IFNvbWUgcGF5bG9hZF9sb2M7IHdob2xlX25vZGUgPSBfIH1cbiAgICAgICAgICAsIHsga2luZCA9IEV4dGVuc2lvbjsgaGFuZCA9IExvbmdoYW5kOyBuYW1lID0gXyB9ICkgLT5cbiAgICAgICAgICBsZXQgY29ycmVjdGlvbiA9XG4gICAgICAgICAgICBPdXRwdXQudG9fZm9ybWF0dGVkX3BheWxvYWQgfnRhZyB0ZXN0X291dHB1dFxuICAgICAgICAgICAgfD4gT3V0cHV0LlBheWxvYWQudG9fc291cmNlX2NvZGVfc3RyaW5nXG4gICAgICAgICAgaW5cbiAgICAgICAgICBwYXlsb2FkX2xvYywgY29ycmVjdGlvblxuICAgICAgICB8IChPdmVyd3JpdGUgeyBwYXlsb2FkID0gXzsgd2hvbGVfbm9kZSA9IGxvYyB9IHwgSW5zZXJ0IHsgbG9jOyBib2R5X2xvYyA9IF8gfSksIF9cbiAgICAgICAgICAtPlxuICAgICAgICAgICggbG9jXG4gICAgICAgICAgLCBPdXRwdXQudG9fc291cmNlX2NvZGVfc3RyaW5nXG4gICAgICAgICAgICAgIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nXG4gICAgICAgICAgICAgIH5ub2RlX3NoYXBlOihUIG9uX2luY29ycmVjdF9vdXRwdXQpXG4gICAgICAgICAgICAgIH50YWdcbiAgICAgICAgICAgICAgdGVzdF9vdXRwdXQgKVxuICAgICAgaW5cbiAgICAgIFNvbWUgKGxvYywgd2hpdGVzcGFjZSBeIGNvcnJlY3Rpb24pXG4gICAgfCBVbnJlYWNoYWJsZVxuICAgICAgICB7IGJlaGF2aW9yID0gRXhwZWN0IHsgb25fdW5yZWFjaGFibGU7IHBheWxvYWQgPSBfOyByZWFjaGFiaWxpdHkgPSBfIH1cbiAgICAgICAgOyBvbl9pbmNvcnJlY3Rfb3V0cHV0ID0gVCBvbl9pbmNvcnJlY3Rfb3V0cHV0XG4gICAgICAgIDsgcG9zaXRpb25cbiAgICAgICAgOyBpbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlID0gX1xuICAgICAgICA7IHBheWxvYWRfdHlwZSA9IF9cbiAgICAgICAgfSAtPlxuICAgICAgbGV0IGxvYyA9IEV4cGVjdGF0aW9uLkluc2VydF9sb2MubG9jIHBvc2l0aW9uIGluXG4gICAgICAobWF0Y2ggb25fdW5yZWFjaGFibGUgd2l0aFxuICAgICAgIHwgU2lsZW50IC0+IE5vbmVcbiAgICAgICB8IERlbGV0ZSAtPiBTb21lIChsb2MsIFwiXCIpXG4gICAgICAgfCBSZXBsYWNlX3dpdGhfdW5yZWFjaGFibGUgLT5cbiAgICAgICAgIGxldCBwcmVmaXggPVxuICAgICAgICAgICBtYXRjaCBvbl9pbmNvcnJlY3Rfb3V0cHV0LmtpbmQgd2l0aFxuICAgICAgICAgICB8IEV4dGVuc2lvbiAtPiBleHBlY3Rfbm9kZV9mb3JtYXR0aW5nLmV4dGVuc2lvbl9zaWdpbFxuICAgICAgICAgICB8IEF0dHJpYnV0ZSAtPiBleHBlY3Rfbm9kZV9mb3JtYXR0aW5nLmF0dHJpYnV0ZV9zaWdpbFxuICAgICAgICAgaW5cbiAgICAgICAgIFNvbWUgKGxvYywgUHJpbnRmLnNwcmludGYgXCJbJXNleHBlY3QudW5yZWFjaGFibGVdXCIgcHJlZml4KSlcbiAgOztcblxuICBsZXQgdG9fZGlmZnMgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgfm9yaWdpbmFsX2ZpbGVfY29udGVudHMgY29ycmVjdGlvbiA9XG4gICAgbGV0IHNhZmVfYnl0ZV9nZXQgc3RyaW5nIGkgPVxuICAgICAgaWYgaSA+PSAwICYmIGkgPCBTdHJpbmcubGVuZ3RoIHN0cmluZyB0aGVuIFNvbWUgKFN0cmluZy5nZXQgc3RyaW5nIGkpIGVsc2UgTm9uZVxuICAgIGluXG4gICAgbWF0Y2ggdG9fcGF0Y2hfb3B0IH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nIGNvcnJlY3Rpb24gd2l0aFxuICAgIHwgTm9uZSAtPiBbXVxuICAgIHwgU29tZSAobG9jLCBkaWZmKSAtPlxuICAgICAgbGV0ICh7IHN0YXJ0X2JvbDsgc3RhcnRfcG9zOyBlbmRfcG9zIH0gOiBDb21wYWN0X2xvYy50KSA9IGxvYyBpblxuICAgICAgbGV0IG1haW5fY29ycmVjdGlvbiA9IFsgbG9jLCBkaWZmIF0gaW5cbiAgICAgICgqIEFkZGl0aW9uYWwgY29ycmVjdGlvbnMgbmVjZXNzYXJ5IGZvciBwcm9kdWNpbmcgY29ycmVjdCBmb3JtYXR0aW5nICopXG4gICAgICBsZXQgYWRkaXRpb25hbF9jb3JyZWN0aW9ucyA9XG4gICAgICAgICgqIElmIGRlbGV0aW5nIGFuIFtbQEBleHBlY3QudW5jYXVnaHRfZXhuXV0gYXR0cmlidXRlIHdvdWxkXG4gICAgICAgICAgIGxlYXZlIGFuIGVtcHR5IGxpbmUsIGRlbGV0ZSB0aGF0IGxpbmUuICopXG4gICAgICAgIGxldCByZW1vdmVfZW1wdHlfbGluZV9mcm9tX2RlbGV0ZWRfdW5jYXVnaHRfZXhuID1cbiAgICAgICAgICBtYXRjaCBjb3JyZWN0aW9uIHdpdGhcbiAgICAgICAgICB8IFVucmVhY2hhYmxlIHsgb25faW5jb3JyZWN0X291dHB1dCA9IFQgeyBraW5kID0gQXR0cmlidXRlOyBfIH07IF8gfSAtPlxuICAgICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICAgICAoIHNhZmVfYnl0ZV9nZXQgb3JpZ2luYWxfZmlsZV9jb250ZW50cyAoc3RhcnRfcG9zIC0gMSlcbiAgICAgICAgICAgICAgICwgc2FmZV9ieXRlX2dldCBvcmlnaW5hbF9maWxlX2NvbnRlbnRzIGVuZF9wb3MgKVxuICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICB8IFNvbWUgJ1xcbicsIChOb25lIHwgU29tZSAnXFxuJykgLT5cbiAgICAgICAgICAgICAgIFNvbWVcbiAgICAgICAgICAgICAgICAgKCB7IENvbXBhY3RfbG9jLnN0YXJ0X3BvcyA9IHN0YXJ0X3BvcyAtIDFcbiAgICAgICAgICAgICAgICAgICA7IGVuZF9wb3MgPSBzdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgICA7IHN0YXJ0X2JvbFxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgLCBcIlwiIClcbiAgICAgICAgICAgICB8IF8gLT4gTm9uZSlcbiAgICAgICAgICB8IF8gLT4gTm9uZVxuICAgICAgICBpblxuICAgICAgICAoKiBJbmNsdWRlIHRoZSBzZW1pY29sb24gbmVlZGVkIGF0IHRoZSBlbmQgb2YgdGhlIGJvZHlcbiAgICAgICAgICAgZm9yIGEgdHJhaWxpbmcgW1slZXhwZWN0XV0gZXh0ZW5zaW9uIHBvaW50LiAqKVxuICAgICAgICBsZXQgYWRkX3NlbWljb2xvbl9iZWZvcmVfdHJhaWxpbmdfZXhwZWN0ID1cbiAgICAgICAgICBtYXRjaCBjb3JyZWN0aW9uIHdpdGhcbiAgICAgICAgICB8IE5ld19wYXlsb2FkXG4gICAgICAgICAgICAgICggeyBvbl9pbmNvcnJlY3Rfb3V0cHV0ID0gVCB7IGtpbmQgPSBFeHRlbnNpb247IF8gfVxuICAgICAgICAgICAgICAgIDsgcG9zaXRpb24gPSBJbnNlcnQgeyBib2R5X2xvYzsgXyB9XG4gICAgICAgICAgICAgICAgOyBfXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAsIF8gKSAtPiBTb21lICh7IGJvZHlfbG9jIHdpdGggc3RhcnRfcG9zID0gYm9keV9sb2MuZW5kX3BvcyB9LCBcIjtcIilcbiAgICAgICAgICB8IF8gLT4gTm9uZVxuICAgICAgICBpblxuICAgICAgICBMaXN0LmNvbmNhdF9tYXBcbiAgICAgICAgICB+ZjpPcHRpb24udG9fbGlzdFxuICAgICAgICAgIFsgcmVtb3ZlX2VtcHR5X2xpbmVfZnJvbV9kZWxldGVkX3VuY2F1Z2h0X2V4blxuICAgICAgICAgIDsgYWRkX3NlbWljb2xvbl9iZWZvcmVfdHJhaWxpbmdfZXhwZWN0XG4gICAgICAgICAgXVxuICAgICAgaW5cbiAgICAgIGFkZGl0aW9uYWxfY29ycmVjdGlvbnMgQCBtYWluX2NvcnJlY3Rpb25cbiAgOztcbmVuZFxuXG50eXBlIG9uZV9vdXRwdXQgPVxuICB7IHJlc3VsdCA6IE91dHB1dC5UZXN0X3Jlc3VsdC50XG4gIDsgcmF3IDogc3RyaW5nXG4gIH1cblxudHlwZSBvbmVfcnVuID1cbiAgfCBSZWFjaGVkX3dpdGhfb3V0cHV0IG9mIG9uZV9vdXRwdXRcbiAgfCBEaWRfbm90X3JlYWNoXG5cbnR5cGUgJ2JlaGF2aW9yIGlubmVyID1cbiAgfCBUZXN0IDpcbiAgICAgIHsgZXhwZWN0YXRpb24gOiAoWzwgRXhwZWN0YXRpb24uQmVoYXZpb3JfdHlwZS50IF0gYXMgJ2JlaGF2aW9yKSBFeHBlY3RhdGlvbi50XG4gICAgICA7IHJlc3VsdHMgOiBvbmVfcnVuIFF1ZXVlLnRcbiAgICAgIDsgbXV0YWJsZSByZWFjaGVkX3RoaXNfcnVuIDogYm9vbFxuICAgICAgfVxuICAgICAgLT4gJ2JlaGF2aW9yIGlubmVyXG5cbnR5cGUgdCA9IFQgOiAnYmVoYXZpb3IgaW5uZXIgLT4gdFxuXG5sZXQgdG9fY29ycmVjdGlvblxuICB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZ1xuICB+Y3JfZm9yX211bHRpcGxlX291dHB1dHNcbiAgKFQgKFRlc3QgeyBleHBlY3RhdGlvbjsgcmVzdWx0czsgcmVhY2hlZF90aGlzX3J1biA9IF8gfSkpXG4gIDogQ29ycmVjdGlvbi50IG9wdGlvblxuICA9XG4gIGxldCByZXN1bHRzX2xpc3QgPSBRdWV1ZS50b19saXN0IHJlc3VsdHMgaW5cbiAgbGV0IHVucmVhY2hlZF9saXN0LCBvdXRwdXRzX2xpc3QgPVxuICAgIExpc3QucGFydGl0aW9uX21hcCByZXN1bHRzX2xpc3QgfmY6KGZ1bmN0aW9uXG4gICAgICB8IERpZF9ub3RfcmVhY2ggLT4gRmlyc3QgKClcbiAgICAgIHwgUmVhY2hlZF93aXRoX291dHB1dCBvdXRwdXQgLT4gU2Vjb25kIG91dHB1dClcbiAgaW5cbiAgbGV0IGRpc3RpbmN0X291dHB1dHMgPVxuICAgICgqIEFsbG93IGRpc3RpbmN0IHJhdyBvdXRwdXRzIGFzIGxvbmcgYXMgdGhlaXIgZm9ybWF0dGVkIFtyZXN1bHRdc1xuICAgICAgIGFyZSBjb25zaWRlcmVkIGVxdWl2YWxlbnQgYWNjb3JkaW5nIHRvIFtQYXlsb2FkX3R5cGVdLiAqKVxuICAgIExpc3QuZGVkdXBfYW5kX3NvcnRcbiAgICAgIH5jb21wYXJlOlxuICAgICAgICAoQ29tcGFyYWJsZS5saWZ0IH5mOihmdW4geyByZXN1bHQ7IF8gfSAtPiByZXN1bHQpIE91dHB1dC5UZXN0X3Jlc3VsdC5jb21wYXJlKVxuICAgICAgb3V0cHV0c19saXN0XG4gIGluXG4gIGxldCB3YXNfcmVhY2hlZCA9IExpc3QuaXNfZW1wdHkgdW5yZWFjaGVkX2xpc3QgaW5cbiAgbGV0IHJlYWNoYWJpbGl0eV9iZWhhdmlvciA9XG4gICAgbWF0Y2ggZXhwZWN0YXRpb24uYmVoYXZpb3Igd2l0aFxuICAgIHwgRXhwZWN0IHsgcmVhY2hhYmlsaXR5OyBwYXlsb2FkID0gXzsgb25fdW5yZWFjaGFibGUgPSBfIH0gLT4gcmVhY2hhYmlsaXR5XG4gICAgfCBVbnJlYWNoYWJsZSB7IHJlYWNoYWJpbGl0eV9vZl9jb3JyZWN0ZWQgfSAtPiByZWFjaGFiaWxpdHlfb2ZfY29ycmVjdGVkXG4gIGluXG4gIGxldCBjb3JyZWN0aW9uX2Zvcl9zaW5nbGVfcmVzdWx0IDogT3V0cHV0LlRlc3RfcmVzdWx0LnQgLT4gQ29ycmVjdGlvbi50IG9wdGlvblxuICAgID0gZnVuY3Rpb25cbiAgICB8IFBhc3MgLT4gTm9uZVxuICAgIHwgRmFpbCByZWNlaXZlZCAtPiBTb21lIChOZXdfcGF5bG9hZCAoZXhwZWN0YXRpb24sIHJlY2VpdmVkKSlcbiAgaW5cbiAgbWF0Y2ggZGlzdGluY3Rfb3V0cHV0cywgKHdhc19yZWFjaGVkLCByZWFjaGFiaWxpdHlfYmVoYXZpb3IpIHdpdGhcbiAgfCBbXSwgKF8sIF8pIC0+XG4gICAgKCogVGhlIHRlc3Qgd2FzIG5ldmVyIHJlYWNoZWQgKilcbiAgICAobWF0Y2ggZXhwZWN0YXRpb24uYmVoYXZpb3Igd2l0aFxuICAgICB8IFVucmVhY2hhYmxlIF8gLT4gTm9uZVxuICAgICB8IEV4cGVjdCBfIGFzIGJlaGF2aW9yIC0+XG4gICAgICAgKCogRXJyb3IgaWYgYW4gZXhwZWN0IHRlc3Qgd2FzIG5vdCByZWFjaGVkICopXG4gICAgICAgU29tZSAoVW5yZWFjaGFibGUgKEV4cGVjdGF0aW9uLndpdGhfYmVoYXZpb3IgZXhwZWN0YXRpb24gYmVoYXZpb3IpKSlcbiAgfCBbIHsgcmVzdWx0OyBfIH0gXSwgKHRydWUsIF8gfCBfLCBDYW5fcmVhY2gpIC0+XG4gICAgKCogVGhlIHRlc3Qgb25seSBwcm9kdWNlZCBvbmUgdW5pcXVlIHJlc3VsdCBhbmQ6XG4gICAgICAgLSBUaGUgdGVzdCBuZXZlciBmYWlsZWQgdG8gYmUgcmVhY2hlZCBPUlxuICAgICAgIC0gVGhlIHRlc3Qgc29tZXRpbWVzIGZhaWxlZCB0byBiZSByZWFjaGVkLCBidXQgdGhlIHRlc3QgaXMgbWFya2VkIGFzIFtDYW5fcmVhY2hdXG4gICAgICAgICAob3IgcmV3cml0ZXMgdG8gb25lIG1hcmtlZCBhcyBbQ2FuX3JlYWNoXSkgc28gdGhhdCdzIE9LXG4gICAgKilcbiAgICBjb3JyZWN0aW9uX2Zvcl9zaW5nbGVfcmVzdWx0IHJlc3VsdFxuICB8IF8gOjogXyA6OiBfLCBfIHwgXywgKGZhbHNlLCBNdXN0X3JlYWNoKSAtPlxuICAgICgqIFRoZSB0ZXN0IHJlc3VsdHMgd2VyZSBpbmNvbnNpc3RlbnQgYmVjYXVzZTpcbiAgICAgICAtIFRoZSB0ZXN0IHdhcyByZWFjaGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG91dHB1dHMgT1JcbiAgICAgICAtIFRoZSB0ZXN0IHdhcyBzb21ldGltZXMgcmVhY2hlZCBhbmQgc29tZXRpbWVzIG5vdCwgYnV0IHRoZSB0ZXN0IHJld3JpdGVzIHRvIGFcbiAgICAgICAgIHRlc3QgbWFya2VkIGFzIFtNdXN0X3JlYWNoXVxuICAgICopXG4gICAgbGV0IG91dHB1dHMgPVxuICAgICAgcmVzdWx0c19saXN0XG4gICAgICB8PiBMaXN0Lm1hcCB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgfCBSZWFjaGVkX3dpdGhfb3V0cHV0IHsgcmF3OyBfIH0gLT4gcmF3XG4gICAgICAgICAgIHwgRGlkX25vdF9yZWFjaCAtPlxuICAgICAgICAgICAgIFByaW50Zi5zcHJpbnRmXG4gICAgICAgICAgICAgICBcIjxleHBlY3QgdGVzdCByYW4gd2l0aG91dCAlcz5cIlxuICAgICAgICAgICAgICAgZXhwZWN0YXRpb24uaW5jb25zaXN0ZW50X291dHB1dHNfbWVzc2FnZSlcbiAgICBpblxuICAgIGNyX2Zvcl9tdWx0aXBsZV9vdXRwdXRzIH5vdXRwdXRfbmFtZTpleHBlY3RhdGlvbi5pbmNvbnNpc3RlbnRfb3V0cHV0c19tZXNzYWdlIH5vdXRwdXRzXG4gICAgfD4gT3V0cHV0LkZvcm1hdHRlci5hcHBseSAoRXhwZWN0YXRpb24uZm9ybWF0dGVyIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nIGV4cGVjdGF0aW9uKVxuICAgIHw+IE91dHB1dC5mYWlsXG4gICAgfD4gY29ycmVjdGlvbl9mb3Jfc2luZ2xlX3Jlc3VsdFxuOztcblxubGV0IHJlY29yZF9hbmRfcmV0dXJuX3Jlc3VsdFxuICAodHlwZSBiZWhhdmlvcilcbiAgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmdcbiAgfmZhaWx1cmVfcmVmXG4gIH50ZXN0X291dHB1dF9yYXdcbiAgKFRlc3QgKHsgZXhwZWN0YXRpb247IHJlc3VsdHM7IHJlYWNoZWRfdGhpc19ydW4gPSBfIH0gYXMgdCkgOiBiZWhhdmlvciBpbm5lcilcbiAgPVxuICBsZXQgdGVzdF9vdXRwdXQgPVxuICAgIE91dHB1dC5Gb3JtYXR0ZXIuYXBwbHlcbiAgICAgIChFeHBlY3RhdGlvbi5mb3JtYXR0ZXIgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgZXhwZWN0YXRpb24pXG4gICAgICB0ZXN0X291dHB1dF9yYXdcbiAgaW5cbiAgbGV0IChyZXN1bHQgOiBPdXRwdXQuVGVzdF9yZXN1bHQudCksICh0YWcgOiBTdHJpbmdfbm9kZV9mb3JtYXQuRGVsaW1pdGVyLnQpID1cbiAgICBtYXRjaCBleHBlY3RhdGlvbi5iZWhhdmlvciB3aXRoXG4gICAgfCBVbnJlYWNoYWJsZSBfIC0+IE91dHB1dC5mYWlsIHRlc3Rfb3V0cHV0LCBUIChUYWcgXCJcIilcbiAgICB8IEV4cGVjdCB7IHBheWxvYWQgPSB7IGNvbnRlbnRzOyB0YWcgfTsgb25fdW5yZWFjaGFibGUgPSBfOyByZWFjaGFiaWxpdHkgPSBfIH0gLT5cbiAgICAgIE91dHB1dC5yZWNvbmNpbGUgfmV4cGVjdGVkX291dHB1dDpjb250ZW50cyB+dGVzdF9vdXRwdXQsIHRhZ1xuICBpblxuICAobWF0Y2ggcmVzdWx0IHdpdGhcbiAgIHwgRmFpbCBfIC0+IGZhaWx1cmVfcmVmIDo9IHRydWVcbiAgIHwgUGFzcyAtPiAoKSk7XG4gIFF1ZXVlLmVucXVldWUgcmVzdWx0cyAoUmVhY2hlZF93aXRoX291dHB1dCB7IHJlc3VsdDsgcmF3ID0gdGVzdF9vdXRwdXRfcmF3IH0pO1xuICB0LnJlYWNoZWRfdGhpc19ydW4gPC0gdHJ1ZTtcbiAgcmVzdWx0LCB0YWdcbjs7XG5cbmxldCBvZl9leHBlY3RhdGlvbiBleHBlY3RhdGlvbiA9XG4gIFQgKFRlc3QgeyBleHBlY3RhdGlvbjsgcmVzdWx0cyA9IFF1ZXVlLmNyZWF0ZSAoKTsgcmVhY2hlZF90aGlzX3J1biA9IGZhbHNlIH0pXG47O1xuXG5sZXQgcmVjb3JkX2VuZF9vZl9ydW4gdCA9XG4gIGxldCAoVCAoVGVzdCB7IGV4cGVjdGF0aW9uID0gXzsgcmVzdWx0czsgcmVhY2hlZF90aGlzX3J1biB9KSkgPSB0IGluXG4gIGlmIG5vdCByZWFjaGVkX3RoaXNfcnVuIHRoZW4gUXVldWUuZW5xdWV1ZSByZXN1bHRzIERpZF9ub3RfcmVhY2hcbjs7XG5cbmxldCByZWNvcmRfcmVzdWx0IH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nIH5mYWlsdXJlX3JlZiB+dGVzdF9vdXRwdXRfcmF3IChUIGlubmVyKSA9XG4gIGlnbm9yZVxuICAgIChyZWNvcmRfYW5kX3JldHVybl9yZXN1bHQgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgfmZhaWx1cmVfcmVmIH50ZXN0X291dHB1dF9yYXcgaW5uZXJcbiAgICAgIDogT3V0cHV0LlRlc3RfcmVzdWx0LnQgKiBTdHJpbmdfbm9kZV9mb3JtYXQuRGVsaW1pdGVyLnQpXG47O1xuXG5tb2R1bGUgR2xvYmFsX3Jlc3VsdHNfdGFibGUgPSBzdHJ1Y3RcbiAgdHlwZSBub2RlID0gdFxuICB0eXBlIHBvc3Rwcm9jZXNzID0gbm9kZSBsaXN0IFdyaXRlX2NvcnJlY3RlZF9maWxlLlBhdGNoX3dpdGhfZmlsZV9jb250ZW50cy50XG5cbiAgdHlwZSBmaWxlID1cbiAgICB7IGV4cGVjdGF0aW9ucyA6IG5vZGUgSGFzaHRibC5NKEV4cGVjdGF0aW9uX2lkKS50XG4gICAgOyBwb3N0cHJvY2VzcyA6IHBvc3Rwcm9jZXNzXG4gICAgfVxuXG4gIGxldCBnbG9iYWxfcmVzdWx0c190YWJsZSA6IGZpbGUgSGFzaHRibC5NKFN0cmluZykudCA9IEhhc2h0YmwuY3JlYXRlIChtb2R1bGUgU3RyaW5nKVxuXG4gIGxldCBmaW5kX3Rlc3QgfmFic29sdXRlX2ZpbGVuYW1lIH4odGVzdF9pZCA6IEV4cGVjdGF0aW9uX2lkLnQpID1cbiAgICBIYXNodGJsLmZpbmQgZ2xvYmFsX3Jlc3VsdHNfdGFibGUgYWJzb2x1dGVfZmlsZW5hbWVcbiAgICB8PiBPcHRpb24uYmluZCB+ZjooZnVuIHsgZXhwZWN0YXRpb25zOyBfIH0gLT4gSGFzaHRibC5maW5kIGV4cGVjdGF0aW9ucyB0ZXN0X2lkKVxuICAgIHw+IE9wdGlvbi52YWx1ZV9leG5cbiAgICAgICAgIH5lcnJvcjpcbiAgICAgICAgICAgKEVycm9yLm9mX3N0cmluZ1xuICAgICAgICAgICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgICAgICAgICAgXCJJbnRlcm5hbCBleHBlY3QgdGVzdCBidWc6IGNvdWxkIG5vdCBmaW5kIHRlc3RcXG5GaWxlOiAlc1xcbklEOiAgICVkXCJcbiAgICAgICAgICAgICAgICAgYWJzb2x1dGVfZmlsZW5hbWVcbiAgICAgICAgICAgICAgICAgKEV4cGVjdGF0aW9uX2lkLnRvX2ludF9leG4gdGVzdF9pZCkpKVxuICA7O1xuXG4gIGxldCBpbml0aWFsaXplX2FuZF9yZWdpc3Rlcl90ZXN0cyB+YWJzb2x1dGVfZmlsZW5hbWUgdGVzdHMgcG9zdHByb2Nlc3MgPVxuICAgIGxldCB0ZXN0c19hc19pbl90YWJsZSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICAgIEhhc2h0YmwudXBkYXRlIGdsb2JhbF9yZXN1bHRzX3RhYmxlIGFic29sdXRlX2ZpbGVuYW1lIH5mOihmdW4gZmlsZSAtPlxuICAgICAgbGV0IGZpbGUgPVxuICAgICAgICBPcHRpb24udmFsdWVcbiAgICAgICAgICBmaWxlXG4gICAgICAgICAgfmRlZmF1bHQ6eyBleHBlY3RhdGlvbnMgPSBIYXNodGJsLmNyZWF0ZSAobW9kdWxlIEV4cGVjdGF0aW9uX2lkKTsgcG9zdHByb2Nlc3MgfVxuICAgICAgaW5cbiAgICAgIGxldCB0ZXN0cyA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgRXhwZWN0YXRpb25faWQpIHRlc3RzIGluXG4gICAgICBIYXNodGJsLm1lcmdlX2ludG9cbiAgICAgICAgfnNyYzp0ZXN0c1xuICAgICAgICB+ZHN0OmZpbGUuZXhwZWN0YXRpb25zXG4gICAgICAgIH5mOihmdW4gfmtleTp0ZXN0X2lkIG5ld190ZXN0IGV4aXN0aW5nX3Rlc3QgLT5cbiAgICAgICAgbGV0IChUIChUZXN0IHQpIGFzIHRlc3QpID0gT3B0aW9uLnZhbHVlIGV4aXN0aW5nX3Rlc3QgfmRlZmF1bHQ6bmV3X3Rlc3QgaW5cbiAgICAgICAgdC5yZWFjaGVkX3RoaXNfcnVuIDwtIGZhbHNlO1xuICAgICAgICBRdWV1ZS5lbnF1ZXVlIHRlc3RzX2FzX2luX3RhYmxlICh0ZXN0X2lkLCB0ZXN0KTtcbiAgICAgICAgU2V0X3RvIHRlc3QpO1xuICAgICAgZmlsZSk7XG4gICAgUXVldWUudG9fbGlzdCB0ZXN0c19hc19pbl90YWJsZVxuICA7O1xuXG4gIGxldCBwcm9jZXNzX2VhY2hfZmlsZSB+ZiA9XG4gICAgZ2xvYmFsX3Jlc3VsdHNfdGFibGVcbiAgICB8PiBIYXNodGJsLnRvX2FsaXN0XG4gICAgfD4gTGlzdC5zb3J0IH5jb21wYXJlOihDb21wYXJhYmxlLmxpZnQgfmY6ZnN0IFN0cmluZy5jb21wYXJlKVxuICAgIHw+IExpc3QubWFwIH5mOihmdW4gKGZpbGVuYW1lLCB7IGV4cGVjdGF0aW9uczsgcG9zdHByb2Nlc3MgfSkgLT5cbiAgICAgICAgIGxldCB0ZXN0X25vZGVzID0gSGFzaHRibC5kYXRhIGV4cGVjdGF0aW9ucyBpblxuICAgICAgICAgZiB+ZmlsZW5hbWUgfnRlc3Rfbm9kZXMgfnBvc3Rwcm9jZXNzKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBDcmVhdGUgPSBzdHJ1Y3RcbiAgbGV0IGV4cGVjdCB+Zm9ybWF0dGluZ19mbGV4aWJpbGl0eSB+bm9kZV9sb2MgfmxvY2F0ZWRfcGF5bG9hZCA9XG4gICAgb2ZfZXhwZWN0YXRpb24gKEV4cGVjdGF0aW9uLmV4cGVjdCB+Zm9ybWF0dGluZ19mbGV4aWJpbGl0eSB+bm9kZV9sb2MgfmxvY2F0ZWRfcGF5bG9hZClcbiAgOztcblxuICBsZXQgZXhwZWN0X2V4YWN0IH5mb3JtYXR0aW5nX2ZsZXhpYmlsaXR5IH5ub2RlX2xvYyB+bG9jYXRlZF9wYXlsb2FkID1cbiAgICBvZl9leHBlY3RhdGlvblxuICAgICAgKEV4cGVjdGF0aW9uLmV4cGVjdF9leGFjdCB+Zm9ybWF0dGluZ19mbGV4aWJpbGl0eSB+bm9kZV9sb2MgfmxvY2F0ZWRfcGF5bG9hZClcbiAgOztcblxuICBsZXQgZXhwZWN0X3VucmVhY2hhYmxlIH5ub2RlX2xvYyA9XG4gICAgb2ZfZXhwZWN0YXRpb24gKEV4cGVjdGF0aW9uLmV4cGVjdF91bnJlYWNoYWJsZSB+bm9kZV9sb2MpXG4gIDs7XG5lbmRcblxubW9kdWxlIEZvcl9tbHQgPSBzdHJ1Y3RcbiAgbGV0IGxvYyAoVCAoVGVzdCB7IGV4cGVjdGF0aW9uID0geyBwb3NpdGlvbjsgXyB9OyByZXN1bHRzID0gXzsgcmVhY2hlZF90aGlzX3J1biA9IF8gfSkpID1cbiAgICBFeHBlY3RhdGlvbi5JbnNlcnRfbG9jLmxvYyBwb3NpdGlvblxuICA7O1xuXG4gIGxldCBleHBlY3RhdGlvbl9vZl90IChUIChUZXN0IHsgZXhwZWN0YXRpb247IHJlc3VsdHMgPSBfOyByZWFjaGVkX3RoaXNfcnVuID0gXyB9KSkgPVxuICAgIG1hdGNoIGV4cGVjdGF0aW9uLmJlaGF2aW9yIHdpdGhcbiAgICB8IEV4cGVjdCB7IHBheWxvYWQgPSB7IGNvbnRlbnRzOyB0YWcgPSBfIH07IG9uX3VucmVhY2hhYmxlID0gXzsgcmVhY2hhYmlsaXR5ID0gXyB9IC0+XG4gICAgICBTb21lIGNvbnRlbnRzXG4gICAgfCBVbnJlYWNoYWJsZSBfIC0+IE5vbmVcbiAgOztcblxuICBsZXQgcmVjb3JkX2FuZF9yZXR1cm5fbnVtYmVyX29mX2xpbmVzX2luX2NvcnJlY3Rpb25cbiAgICB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZ1xuICAgIH5mYWlsdXJlX3JlZlxuICAgIH50ZXN0X291dHB1dF9yYXdcbiAgICAoVCAoVGVzdCBpbm5lcikpXG4gICAgPVxuICAgIG1hdGNoXG4gICAgICByZWNvcmRfYW5kX3JldHVybl9yZXN1bHRcbiAgICAgICAgfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmdcbiAgICAgICAgfmZhaWx1cmVfcmVmXG4gICAgICAgIH50ZXN0X291dHB1dF9yYXdcbiAgICAgICAgKFRlc3QgaW5uZXIpXG4gICAgd2l0aFxuICAgIHwgRmFpbCBjb250ZW50cywgdGFnIC0+XG4gICAgICBsZXQgY29ycmVjdGlvbiA9XG4gICAgICAgIE91dHB1dC50b19mb3JtYXR0ZWRfcGF5bG9hZCB+dGFnIGNvbnRlbnRzIHw+IE91dHB1dC5QYXlsb2FkLnRvX3NvdXJjZV9jb2RlX3N0cmluZ1xuICAgICAgaW5cbiAgICAgIFNvbWUgKFN0cmluZy5jb3VudCB+ZjooQ2hhci5lcXVhbCAnXFxuJykgY29ycmVjdGlvbiArIDEpXG4gICAgfCBQYXNzLCBfIC0+IE5vbmVcbiAgOztcblxuICBsZXQgdG9fZGlmZnMgfmNyX2Zvcl9tdWx0aXBsZV9vdXRwdXRzIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nIH5vcmlnaW5hbF9maWxlX2NvbnRlbnRzIHQgPVxuICAgIG1hdGNoIHRvX2NvcnJlY3Rpb24gfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgfmNyX2Zvcl9tdWx0aXBsZV9vdXRwdXRzIHQgd2l0aFxuICAgIHwgTm9uZSAtPiBbXVxuICAgIHwgU29tZSBjb3JyZWN0aW9uIC0+XG4gICAgICBDb3JyZWN0aW9uLnRvX2RpZmZzIGNvcnJlY3Rpb24gfmV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgfm9yaWdpbmFsX2ZpbGVfY29udGVudHNcbiAgOztcbmVuZFxuIiwib3BlbiEgQmFzZVxuXG5sZXQgY3VycmVudCA9IHJlZiBOb25lXG5cbmxldCBzZXQgfmZpbGVuYW1lX3JlbF90b19wcm9qZWN0X3Jvb3QgPVxuICBtYXRjaCAhY3VycmVudCB3aXRoXG4gIHwgTm9uZSAtPiBjdXJyZW50IDo9IFNvbWUgZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdFxuICB8IFNvbWUgY3VycmVudCAtPlxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiRXhwZWN0X3Rlc3RfY29sbGVjdG9yLnNldDogdGhlcmUgaXMgYWxyZWFkeSBhbiBhY3RpdmUgZmlsZVwiXG4gICAgICAgICBbIFwib2xkX2ZpbGVcIiwgc2V4cF9vZl9zdHJpbmcgY3VycmVudFxuICAgICAgICAgOyBcIm5ld19maWxlXCIsIHNleHBfb2Zfc3RyaW5nIGZpbGVuYW1lX3JlbF90b19wcm9qZWN0X3Jvb3RcbiAgICAgICAgIF0pXG47O1xuXG5sZXQgdW5zZXQgKCkgPVxuICBtYXRjaCAhY3VycmVudCB3aXRoXG4gIHwgU29tZSBfIC0+IGN1cnJlbnQgOj0gTm9uZVxuICB8IE5vbmUgLT5cbiAgICByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJFeHBlY3RfdGVzdF9jb2xsZWN0b3IudW5zZXQ6IHRoZXJlIGlzIG5vIGFjdGl2ZSBmaWxlXCIgW10pXG47O1xuXG5sZXQgZ2V0ICgpID1cbiAgbWF0Y2ggIWN1cnJlbnQgd2l0aFxuICB8IFNvbWUgZm4gLT4gZm5cbiAgfCBOb25lIC0+IHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIkV4cGVjdF90ZXN0X2NvbGxlY3Rvci5nZXQ6IHRoZXJlIGlzIG5vIGFjdGl2ZSBmaWxlXCIgW10pXG47O1xuXG5sZXQgaW5pdGlhbF9kaXIgPVxuICBsZXQgZGlyX29yX2Vycm9yID0gT3JfZXJyb3IudHJ5X3dpdGggfmJhY2t0cmFjZTp0cnVlIFN0ZGxpYi5TeXMuZ2V0Y3dkIGluXG4gIGxhenkgKE9yX2Vycm9yLm9rX2V4biBkaXJfb3JfZXJyb3IpXG47O1xuXG5sZXQgYWJzb2x1dGVfcGF0aCBmaWxlID1cbiAgaWYgU3RkbGliLkZpbGVuYW1lLmlzX3JlbGF0aXZlIGZpbGVcbiAgdGhlbiBTdGRsaWIuRmlsZW5hbWUuY29uY2F0IChMYXp5LmZvcmNlIGluaXRpYWxfZGlyKSBmaWxlXG4gIGVsc2UgZmlsZVxuOztcblxubGV0IHZlcmlmeV90aGF0X2ZpbGVfaXNfY3VycmVudF9leG4gfmxpbmVfbnVtYmVyIH5maWxlbmFtZV9yZWxfdG9fcHJvamVjdF9yb290ID1cbiAgbGV0IHJlZ2lzdGVyaW5nX3Rlc3RzX2ZvciA9IGdldCAoKSBpblxuICBpZiBub3QgKFN0cmluZy5lcXVhbCBmaWxlbmFtZV9yZWxfdG9fcHJvamVjdF9yb290IHJlZ2lzdGVyaW5nX3Rlc3RzX2ZvcilcbiAgdGhlblxuICAgIFByaW50Zi5rc3ByaW50ZlxuICAgICAgZmFpbHdpdGhcbiAgICAgIFwiVHJ5aW5nIHRvIHJ1biBhbiBleHBlY3QgdGVzdCBmcm9tIHRoZSB3cm9uZyBmaWxlLlxcblxcXG4gICAgICAgLSB0ZXN0IGRlY2xhcmVkIGF0ICVzOiVkXFxuXFxcbiAgICAgICAtIHRyeWluZyB0byBydW4gaXQgZnJvbSAlc1xcblwiXG4gICAgICBmaWxlbmFtZV9yZWxfdG9fcHJvamVjdF9yb290XG4gICAgICBsaW5lX251bWJlclxuICAgICAgcmVnaXN0ZXJpbmdfdGVzdHNfZm9yXG4gIGVsc2UgKClcbjs7XG4iLCJvcGVuISBCYXNlXG5vcGVuIFR5cGVzXG5cbigqIFtTaGFyZWRdIGFuZCBbQ29uZmlndXJlZF0gcHJpbWFyaWx5IGNvbnRhaW4gYm9pbGVycGxhdGUgaW52b2x2aW5nIHRoZSBGRkkgYW5kIHByaW50aW5nXG4gICBbQ1Jdcy4gVGhlIGludGVyZXN0aW5nIGxvZ2ljIGlzIGluIFtNYWtlXS4gKilcblxubW9kdWxlIFNoYXJlZCA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgc3JjX2ZpbGVuYW1lIDogdCAtPiBzdHJpbmdcbiAgdmFsIG91dHB1dF9maWxlIDogdCAtPiBzdHJpbmdcbiAgdmFsIGZhaWx1cmVfcmVmIDogdCAtPiBib29sIHJlZlxuICB2YWwgc2V0X3VwX2Jsb2NrIDogc3RyaW5nIC0+IHRcbiAgdmFsIHJlYWRfdGVzdF9vdXRwdXRfdW5zYW5pdGl6ZWQgOiB0IC0+IHN0cmluZ1xuICB2YWwgZmx1c2ggOiB1bml0IC0+IHVuaXRcbiAgdmFsIGNsZWFuX3VwX2Jsb2NrIDogdCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHNyY19maWxlbmFtZSA6IHN0cmluZ1xuICAgIDsgb3V0cHV0X2ZpbGUgOiBzdHJpbmdcbiAgICA7IGZhaWwgOiBib29sIHJlZlxuICAgIDsgdGVzdF9vdXRwdXRfcmVhZGVyIDogU3RkbGliLmluX2NoYW5uZWxcbiAgICA7IHRlc3Rfb3V0cHV0X3dyaXRlciA6IFN0ZGxpYi5vdXRfY2hhbm5lbFxuICAgIDsgb2xkX29mZnNldCA6IGludCByZWZcbiAgICB9XG5cbiAgbGV0IHNyY19maWxlbmFtZSB7IHNyY19maWxlbmFtZTsgXyB9ID0gc3JjX2ZpbGVuYW1lXG4gIGxldCBvdXRwdXRfZmlsZSB7IG91dHB1dF9maWxlOyBfIH0gPSBvdXRwdXRfZmlsZVxuICBsZXQgZmFpbHVyZV9yZWYgeyBmYWlsOyBfIH0gPSBmYWlsXG5cbiAgZXh0ZXJuYWwgcmVkaXJlY3Rfc3Rkb3V0XG4gICAgOiAgb3V0cHV0OlN0ZGxpYi5vdXRfY2hhbm5lbFxuICAgIC0+IHN0ZG91dDpTdGRsaWIub3V0X2NoYW5uZWxcbiAgICAtPiBzdGRlcnI6U3RkbGliLm91dF9jaGFubmVsXG4gICAgLT4gdW5pdFxuICAgID0gXCJwcHhfZXhwZWN0X3J1bnRpbWVfYmVmb3JlX3Rlc3RcIlxuXG4gIGV4dGVybmFsIHJlc3RvcmVfc3Rkb3V0XG4gICAgOiAgc3Rkb3V0OlN0ZGxpYi5vdXRfY2hhbm5lbFxuICAgIC0+IHN0ZGVycjpTdGRsaWIub3V0X2NoYW5uZWxcbiAgICAtPiB1bml0XG4gICAgPSBcInBweF9leHBlY3RfcnVudGltZV9hZnRlcl90ZXN0XCJcblxuICBleHRlcm5hbCBwb3Nfb3V0IDogU3RkbGliLm91dF9jaGFubmVsIC0+IGludCA9IFwicHB4X2V4cGVjdF9ydW50aW1lX291dF9jaGFubmVsX3Bvc2l0aW9uXCJcbiAgZXh0ZXJuYWwgZmx1c2hfc3R1YnMgOiB1bml0IC0+IHVuaXQgPSBcInBweF9leHBlY3RfcnVudGltZV9mbHVzaF9zdHVic19zdHJlYW1zXCJcblxuICAoKiBTYXZlIHN0ZCBmaWxlIGRlc2NyaXB0b3JzLCBvcGVuIGEgdGVtcCBmaWxlIGZvciB0ZXN0IG91dHB1dCwgYW5kIHJlcm91dGUgc3Rkb3V0IGFuZFxuICAgICBzdGRlcnIgdGhlcmUuICopXG4gIGxldCBzZXRfdXBfYmxvY2sgc3JjX2ZpbGVuYW1lID1cbiAgICBsZXQgb3V0cHV0X2ZpbGUgPVxuICAgICAgQ3VycmVudF9maWxlLmFic29sdXRlX3BhdGggKFN0ZGxpYi5GaWxlbmFtZS50ZW1wX2ZpbGUgXCJleHBlY3QtdGVzdFwiIFwib3V0cHV0XCIpXG4gICAgaW5cbiAgICBsZXQgdGVzdF9vdXRwdXRfd3JpdGVyID1cbiAgICAgIFN0ZGxpYi5vcGVuX291dF9nZW4gWyBPcGVuX3dyb25seTsgT3Blbl9jcmVhdCBdIDBvNjQ0IG91dHB1dF9maWxlXG4gICAgaW5cbiAgICBsZXQgdGVzdF9vdXRwdXRfcmVhZGVyID0gU3RkbGliLm9wZW5faW4gb3V0cHV0X2ZpbGUgaW5cbiAgICByZWRpcmVjdF9zdGRvdXQgfm91dHB1dDp0ZXN0X291dHB1dF93cml0ZXIgfnN0ZG91dDpTdGRsaWIuc3Rkb3V0IH5zdGRlcnI6U3RkbGliLnN0ZGVycjtcbiAgICB7IHNyY19maWxlbmFtZVxuICAgIDsgb3V0cHV0X2ZpbGVcbiAgICA7IHRlc3Rfb3V0cHV0X3JlYWRlclxuICAgIDsgdGVzdF9vdXRwdXRfd3JpdGVyXG4gICAgOyBvbGRfb2Zmc2V0ID0gcmVmIDBcbiAgICA7IGZhaWwgPSByZWYgZmFsc2VcbiAgICB9XG4gIDs7XG5cbiAgKCogQ2xvc2UgdGhlIHRlbXAgZmlsZSBhbmQgcmVzdG9yZSBzdGRvdXQgYW5kIHN0ZGVyci4gKilcbiAgbGV0IGNsZWFuX3VwX2Jsb2NrIHsgb3V0cHV0X2ZpbGU7IHRlc3Rfb3V0cHV0X3JlYWRlcjsgdGVzdF9vdXRwdXRfd3JpdGVyOyBfIH0gPVxuICAgIFN0ZGxpYi5jbG9zZV9pbiB0ZXN0X291dHB1dF9yZWFkZXI7XG4gICAgcmVzdG9yZV9zdGRvdXQgfnN0ZG91dDpTdGRsaWIuc3Rkb3V0IH5zdGRlcnI6U3RkbGliLnN0ZGVycjtcbiAgICBTdGRsaWIuY2xvc2Vfb3V0IHRlc3Rfb3V0cHV0X3dyaXRlcjtcbiAgICBTdGRsaWIuU3lzLnJlbW92ZSBvdXRwdXRfZmlsZVxuICA7O1xuXG4gIGxldCBmbHVzaCAoKSA9XG4gICAgU3RkbGliLkZvcm1hdC5wcF9wcmludF9mbHVzaCBTdGRsaWIuRm9ybWF0LnN0ZF9mb3JtYXR0ZXIgKCk7XG4gICAgU3RkbGliLkZvcm1hdC5wcF9wcmludF9mbHVzaCBTdGRsaWIuRm9ybWF0LmVycl9mb3JtYXR0ZXIgKCk7XG4gICAgU3RkbGliLmZsdXNoIFN0ZGxpYi5zdGRvdXQ7XG4gICAgU3RkbGliLmZsdXNoIFN0ZGxpYi5zdGRlcnI7XG4gICAgZmx1c2hfc3R1YnMgKClcbiAgOztcblxuICBsZXQgcmVhZF90ZXN0X291dHB1dF91bnNhbml0aXplZCB7IHRlc3Rfb3V0cHV0X3JlYWRlcjsgb2xkX29mZnNldDsgXyB9ID1cbiAgICBsZXQgbmV3X29mZnNldCA9XG4gICAgICBmbHVzaCAoKTtcbiAgICAgIHBvc19vdXQgU3RkbGliLnN0ZG91dFxuICAgIGluXG4gICAgbGV0IGxlbiA9IG5ld19vZmZzZXQgLSAhb2xkX29mZnNldCBpblxuICAgIG9sZF9vZmZzZXQgOj0gbmV3X29mZnNldDtcbiAgICBTdGRsaWIucmVhbGx5X2lucHV0X3N0cmluZyB0ZXN0X291dHB1dF9yZWFkZXIgbGVuXG4gIDs7XG5lbmRcblxubW9kdWxlIENvbmZpZ3VyZWQgKEMgOiBFeHBlY3RfdGVzdF9jb25maWdfdHlwZXMuUykgPSBzdHJ1Y3RcbiAgbGV0IGNyX3ByZWZpeCA9XG4gICAgbWF0Y2ggQy51cG9uX3VucmVsZWFzYWJsZV9pc3N1ZSB3aXRoXG4gICAgfCBgQ1IgLT4gXCJDUiBcIlxuICAgIHwgYFdhcm5pbmdfZm9yX2NvbGxlY3Rvcl90ZXN0aW5nIC0+IFwiXCJcbiAgOztcblxuICBsZXQgY3JfZm9yX2JhY2t0cmFjZSA9XG4gICAgUHJpbnRmLnNwcmludGZcbiAgICAgIHt8KCogJXNleHBlY3RfdGVzdF9jb2xsZWN0b3I6IFRoaXMgdGVzdCBleHBlY3RhdGlvbiBhcHBlYXJzIHRvIGNvbnRhaW4gYSBiYWNrdHJhY2UuXG4gICBUaGlzIGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkIGFzIGJhY2t0cmFjZXMgYXJlIGZyYWdpbGUuXG4gICBQbGVhc2UgY2hhbmdlIHRoaXMgdGVzdCB0byBub3QgaW5jbHVkZSBhIGJhY2t0cmFjZS4gKil8fVxuICAgICAgY3JfcHJlZml4XG4gIDs7XG5cbiAgbGV0IGNyX2Zvcl9tdWx0aXBsZV9vdXRwdXRzIH5vdXRwdXRfbmFtZSB+b3V0cHV0cyA9XG4gICAgbGV0IGNyX2JvZHkgPVxuICAgICAgUHJpbnRmLnNwcmludGYgXCJUZXN0IHJhbiBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCAlc3NcIiBvdXRwdXRfbmFtZVxuICAgIGluXG4gICAgbGV0IGNyID0gUHJpbnRmLnNwcmludGYgXCIoKiAlc2V4cGVjdF90ZXN0OiAlcyAqKVwiIGNyX3ByZWZpeCBjcl9ib2R5IGluXG4gICAgbGV0IG51bV9vdXRwdXRzID0gTGlzdC5sZW5ndGggb3V0cHV0cyBpblxuICAgIGxldCBoZWFkZXIgaW5kZXggPVxuICAgICAgbGV0IGhlYWRlciA9IFByaW50Zi5zcHJpbnRmIFwiPT09IE91dHB1dCAlZCAvICVkID09PVwiIChpbmRleCArIDEpIG51bV9vdXRwdXRzIGluXG4gICAgICBsZXQgcGFkX2xlbmd0aCA9IFN0cmluZy5sZW5ndGggY3IgLSBTdHJpbmcubGVuZ3RoIGhlYWRlciBpblxuICAgICAgaWYgcGFkX2xlbmd0aCA8PSAwXG4gICAgICB0aGVuIGhlYWRlclxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBscGFkID0gU3RyaW5nLm1ha2UgKHBhZF9sZW5ndGggLyAyKSAnPScgaW5cbiAgICAgICAgbGV0IHJwYWQgPSBTdHJpbmcubWFrZSAocGFkX2xlbmd0aCAtIChwYWRfbGVuZ3RoIC8gMikpICc9JyBpblxuICAgICAgICBQcmludGYuc3ByaW50ZiBcIiVzJXMlc1wiIGxwYWQgaGVhZGVyIHJwYWQpXG4gICAgaW5cbiAgICBsZXQgb3V0cHV0c193aXRoX2hlYWRlcnMgPVxuICAgICAgTGlzdC5jb25jYXRfbWFwaSBvdXRwdXRzIH5mOihmdW4gaW5kZXggb3V0cHV0IC0+IFsgaGVhZGVyIGluZGV4OyBvdXRwdXQgXSlcbiAgICBpblxuICAgIFN0cmluZy5jb25jYXQgKGNyIDo6IG91dHB1dHNfd2l0aF9oZWFkZXJzKSB+c2VwOlwiXFxuXCJcbiAgOztcblxuICBsZXQgc2FuaXRpemUgPSBDLnNhbml0aXplXG5cbiAgbGV0IGNoZWNrX2Zvcl9iYWNrdHJhY2VzIHMgPVxuICAgIGlmIExpc3QuZXhpc3RzXG4gICAgICAgICB+ZjooZnVuIHN1YnN0cmluZyAtPiBTdHJpbmcuaXNfc3Vic3RyaW5nIH5zdWJzdHJpbmcgcylcbiAgICAgICAgIFsgXCJSYWlzZWQgYXQgXCI7IFwiQ2FsbGVkIGZyb20gXCI7IFwiUmFpc2VkIGJ5IHByaW1pdGl2ZSBvcGVyYXRpb24gXCIgXVxuICAgIHRoZW4gY3JfZm9yX2JhY2t0cmFjZSBeIFwiXFxuXFxuXCIgXiBzXG4gICAgZWxzZSBzXG4gIDs7XG5cbiAgbGV0IGR1bXBfYmFja3RyYWNlIHBvc3NpYmxlX2V4biA9XG4gICAgbWF0Y2ggQy5ydW4gcG9zc2libGVfZXhuIHdpdGhcbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIGxldCBidCA9IFN0ZGxpYi5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgbGV0IGV4bl9zdHJpbmcgPVxuICAgICAgICB0cnkgRXhuLnRvX3N0cmluZyBleG4gd2l0aFxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBsZXQgbmFtZSA9XG4gICAgICAgICAgICBTdGRsaWIuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWwgZXhuXG4gICAgICAgICAgICB8PiBTdGRsaWIuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgICAgaW5cbiAgICAgICAgICBQcmludGYuc3ByaW50ZiBcIihcXFwiJXMoQ2Fubm90IHByaW50IG1vcmUgZGV0YWlscywgRXhuLnRvX3N0cmluZyBmYWlsZWQpXFxcIilcIiBuYW1lXG4gICAgICBpblxuICAgICAgU29tZVxuICAgICAgICAobWF0Y2ggU3RkbGliLlByaW50ZXhjLnJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIGJ0IHdpdGhcbiAgICAgICAgIHwgXCJcIiAtPiBleG5fc3RyaW5nXG4gICAgICAgICB8IGJ0IC0+IFN0cmluZy5jb25jYXQgfnNlcDpcIlxcblwiIFsgY3JfZm9yX2JhY2t0cmFjZTsgZXhuX3N0cmluZzsgYnQgXSlcbiAgICB8IF8gLT4gTm9uZVxuICA7O1xuZW5kXG5cbigqIFRoZSBleHBlY3QgdGVzdCBjdXJyZW50bHkgYmVpbmcgZXhlY3V0ZWQgYW5kIHNvbWUgaW5mbyB3ZSBwcmludCBpZiB0aGUgcHJvZ3JhbVxuICAgY3Jhc2hlcyBpbiB0aGUgbWlkZGxlIG9mIGEgdGVzdC4gKilcbm1vZHVsZSBDdXJyZW50X3Rlc3QgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IGxpbmVfbnVtYmVyIDogaW50XG4gICAgOyBiYXNlbmFtZSA6IHN0cmluZ1xuICAgIDsgbG9jYXRpb24gOiBDb21wYWN0X2xvYy50XG4gICAgOyB0ZXN0X2Jsb2NrIDogU2hhcmVkLnRcbiAgICB9XG5cbiAgdmFsIHNldCA6IHQgLT4gdW5pdFxuICB2YWwgdW5zZXQgOiB1bml0IC0+IHVuaXRcbiAgdmFsIGlzX3J1bm5pbmcgOiB1bml0IC0+IGJvb2xcbiAgdmFsIGN1cnJlbnRfdGVzdCA6IHVuaXQgLT4gU2hhcmVkLnQgb3B0aW9uXG4gIHZhbCBjdXJyZW50X3Rlc3RfZXhuIDogdW5pdCAtPiBTaGFyZWQudFxuICB2YWwgaXRlciA6IGY6KHQgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgYXNzZXJ0X25vX3Rlc3RfcnVubmluZyA6IGJhc2VuYW1lOnN0cmluZyAtPiBsaW5lX251bWJlcjppbnQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBsaW5lX251bWJlciA6IGludFxuICAgIDsgYmFzZW5hbWUgOiBzdHJpbmdcbiAgICA7IGxvY2F0aW9uIDogQ29tcGFjdF9sb2MudFxuICAgIDsgdGVzdF9ibG9jayA6IFNoYXJlZC50XG4gICAgfVxuXG4gIGxldCB0ZXN0X2lzX3J1bm5pbmcgOiB0IG9wdGlvbiByZWYgPSByZWYgTm9uZVxuICBsZXQgc2V0IHQgPSB0ZXN0X2lzX3J1bm5pbmcgOj0gU29tZSB0XG4gIGxldCB1bnNldCAoKSA9IHRlc3RfaXNfcnVubmluZyA6PSBOb25lXG4gIGxldCBpc19ydW5uaW5nICgpID0gT3B0aW9uLmlzX3NvbWUgIXRlc3RfaXNfcnVubmluZ1xuXG4gIGxldCBjdXJyZW50X3Rlc3QgKCkgPVxuICAgIE9wdGlvbi5tYXAgIXRlc3RfaXNfcnVubmluZyB+ZjooZnVuIHsgdGVzdF9ibG9jazsgXyB9IC0+IHRlc3RfYmxvY2spXG4gIDs7XG5cbiAgbGV0IGN1cnJlbnRfdGVzdF9leG4gKCkgPSBPcHRpb24udmFsdWVfZXhuIChjdXJyZW50X3Rlc3QgKCkpXG4gIGxldCBpdGVyIH5mID0gT3B0aW9uLml0ZXIgIXRlc3RfaXNfcnVubmluZyB+ZlxuXG4gIGxldCBhc3NlcnRfbm9fdGVzdF9ydW5uaW5nIH5iYXNlbmFtZSB+bGluZV9udW1iZXIgPVxuICAgIGl0ZXJcbiAgICAgIH5mOlxuICAgICAgICAoZnVuXG4gICAgICAgICAgeyBsaW5lX251bWJlciA9IG91dGVyX2xpbmVfbnVtYmVyXG4gICAgICAgICAgOyBiYXNlbmFtZSA9IG91dGVyX2Jhc2VuYW1lXG4gICAgICAgICAgOyBsb2NhdGlvbiA9IF9cbiAgICAgICAgICA7IHRlc3RfYmxvY2sgPSBfXG4gICAgICAgICAgfVxuICAgICAgICAgIC0+XG4gICAgICBsZXQgc2V4cF9oZXJlIH5iYXNlbmFtZSB+bGluZV9udW1iZXIgOiBTZXhwLnQgPVxuICAgICAgICBMaXN0XG4gICAgICAgICAgWyBMaXN0IFsgQXRvbSBcImZpbGVcIjsgc2V4cF9vZl9zdHJpbmcgYmFzZW5hbWUgXVxuICAgICAgICAgIDsgTGlzdCBbIEF0b20gXCJsaW5lXCI7IHNleHBfb2ZfaW50IGxpbmVfbnVtYmVyIF1cbiAgICAgICAgICBdXG4gICAgICBpblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiRXhwZWN0X3Rlc3RfcnVudGltZTogcmVhY2hlZCBvbmUgW2xldCVleHBlY3RfdGVzdF0gZnJvbSBhbm90aGVyLiBOZXN0aW5nIFxcXG4gICAgICAgICAgICBleHBlY3RcXG5cXFxuICAgICAgICAgICAgdGVzdHMgaXMgcHJvaGliaXRlZC5cIlxuICAgICAgICAgICBbICggXCJvdXRlcl90ZXN0XCJcbiAgICAgICAgICAgICAsIHNleHBfaGVyZSB+YmFzZW5hbWU6b3V0ZXJfYmFzZW5hbWUgfmxpbmVfbnVtYmVyOm91dGVyX2xpbmVfbnVtYmVyIClcbiAgICAgICAgICAgOyBcImlubmVyX3Rlc3RcIiwgc2V4cF9oZXJlIH5iYXNlbmFtZSB+bGluZV9udW1iZXJcbiAgICAgICAgICAgXSkpXG4gIDs7XG5lbmRcblxuKCogVGhlIG1haW4gdGVzdGluZyBmdW5jdGlvbnMgb2YgYSB0ZXN0IGJsb2NrLCB3aGljaCBkZXBlbmQgb24gY29uZmlndXJhdGlvbnMuICopXG5tb2R1bGUgTWFrZSAoQyA6IEV4cGVjdF90ZXN0X2NvbmZpZ190eXBlcy5TKSA9IHN0cnVjdFxuICBtb2R1bGUgQ29uZmlndXJlZCA9IENvbmZpZ3VyZWQgKEMpXG5cbiAgbGV0IHJlYWRfdGVzdF9vdXRwdXRfbm9fYmFja3RyYWNlX2NoZWNrICgpID1cbiAgICBDdXJyZW50X3Rlc3QuY3VycmVudF90ZXN0X2V4biAoKVxuICAgIHw+IFNoYXJlZC5yZWFkX3Rlc3Rfb3V0cHV0X3Vuc2FuaXRpemVkXG4gICAgfD4gQ29uZmlndXJlZC5zYW5pdGl6ZVxuICA7O1xuXG4gIGxldCByZWFkX3Rlc3Rfb3V0cHV0X3Nhbml0aXplZF9hbmRfY2hlY2tlZCAoKSA9XG4gICAgcmVhZF90ZXN0X291dHB1dF9ub19iYWNrdHJhY2VfY2hlY2sgKCkgfD4gQ29uZmlndXJlZC5jaGVja19mb3JfYmFja3RyYWNlc1xuICA7O1xuXG4gIGxldCBydW5fdGVzdF9pbm5lciB+dGVzdF9pZCB+dGVzdF9vdXRwdXRfcmF3IHQgPVxuICAgIFRlc3Rfbm9kZS5yZWNvcmRfcmVzdWx0XG4gICAgICB+ZXhwZWN0X25vZGVfZm9ybWF0dGluZzpFeHBlY3Rfbm9kZV9mb3JtYXR0aW5nLmRlZmF1bHRcbiAgICAgIH5mYWlsdXJlX3JlZjooU2hhcmVkLmZhaWx1cmVfcmVmIHQpXG4gICAgICB+dGVzdF9vdXRwdXRfcmF3XG4gICAgICAoVGVzdF9ub2RlLkdsb2JhbF9yZXN1bHRzX3RhYmxlLmZpbmRfdGVzdFxuICAgICAgICAgfmFic29sdXRlX2ZpbGVuYW1lOihTaGFyZWQuc3JjX2ZpbGVuYW1lIHQpXG4gICAgICAgICB+dGVzdF9pZClcbiAgOztcblxuICBsZXQgcnVuX3Rlc3QgfnRlc3RfaWQgPVxuICAgIEN1cnJlbnRfdGVzdC5jdXJyZW50X3Rlc3RfZXhuICgpXG4gICAgfD4gcnVuX3Rlc3RfaW5uZXJcbiAgICAgICAgIH50ZXN0X2lkXG4gICAgICAgICB+dGVzdF9vdXRwdXRfcmF3OihyZWFkX3Rlc3Rfb3V0cHV0X3Nhbml0aXplZF9hbmRfY2hlY2tlZCAoKSlcbiAgOztcblxuICBsZXQgcnVuX3N1aXRlXG4gICAgfmZpbGVuYW1lX3JlbF90b19wcm9qZWN0X3Jvb3RcbiAgICB+bGluZV9udW1iZXJcbiAgICB+KGxvY2F0aW9uIDogQ29tcGFjdF9sb2MudClcbiAgICB+KHRyYWlsaW5nX2xvYyA6IENvbXBhY3RfbG9jLnQpXG4gICAgfihib2R5X2xvYyA6IENvbXBhY3RfbG9jLnQpXG4gICAgfmZvcm1hdHRpbmdfZmxleGliaWxpdHlcbiAgICB+ZXhwZWN0ZWRfZXhuXG4gICAgfnRyYWlsaW5nX3Rlc3RfaWRcbiAgICB+ZXhuX3Rlc3RfaWRcbiAgICB+ZGVzY3JpcHRpb25cbiAgICB+dGFnc1xuICAgIH5pbmxpbmVfdGVzdF9jb25maWdcbiAgICB+ZXhwZWN0YXRpb25zXG4gICAgZlxuICAgID1cbiAgICBsZXQgKHsgc3RhcnRfYm9sOyBzdGFydF9wb3M7IGVuZF9wb3MgfSA6IENvbXBhY3RfbG9jLnQpID0gbG9jYXRpb24gaW5cbiAgICBsZXQgYmFzZW5hbWUgPSBTdGRsaWIuRmlsZW5hbWUuYmFzZW5hbWUgZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdCBpblxuICAgICgqIEV2ZW4gaWYgdGhlIGN1cnJlbnQgdGFnIHNldCBpbmRpY2F0ZXMgdGhpcyB0ZXN0IHNob3VsZCBiZSBkcm9wcGVkLCBjaGVjayB0aGF0IGl0XG4gICAgICAgd2Fzbid0IHJlYWNoZWQgZnJvbSBhbm90aGVyIGV4cGVjdCB0ZXN0ICopXG4gICAgQ3VycmVudF90ZXN0LmFzc2VydF9ub190ZXN0X3J1bm5pbmcgfmJhc2VuYW1lIH5saW5lX251bWJlcjtcbiAgICBQcHhfaW5saW5lX3Rlc3RfbGliLnRlc3RcbiAgICAgIH5jb25maWc6aW5saW5lX3Rlc3RfY29uZmlnXG4gICAgICB+ZGVzY3I6KGxhenkgKE9wdGlvbi52YWx1ZSBkZXNjcmlwdGlvbiB+ZGVmYXVsdDpcIlwiKSlcbiAgICAgIH50YWdzXG4gICAgICB+ZmlsZW5hbWU6YmFzZW5hbWVcbiAgICAgIH5saW5lX251bWJlclxuICAgICAgfnN0YXJ0X3Bvczooc3RhcnRfcG9zIC0gc3RhcnRfYm9sKVxuICAgICAgfmVuZF9wb3M6KGVuZF9wb3MgLSBzdGFydF9ib2wpXG4gICAgICAoZnVuICgpIC0+XG4gICAgICAgICgqIENoZWNrIHRoYXQgdGhlIHRlc3QgaXMgYmVpbmcgcnVuIGZyb20gdGhlIGZpbGUgaW4gd2hpY2ggaXQgd2FzIGRlZmluZWQgKilcbiAgICAgICAgQ3VycmVudF9maWxlLnZlcmlmeV90aGF0X2ZpbGVfaXNfY3VycmVudF9leG5cbiAgICAgICAgICB+bGluZV9udW1iZXJcbiAgICAgICAgICB+ZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdDtcbiAgICAgICAgbGV0IGFic29sdXRlX2ZpbGVuYW1lID0gQ3VycmVudF9maWxlLmFic29sdXRlX3BhdGggYmFzZW5hbWUgaW5cbiAgICAgICAgKCogQ3JlYXRlIHRoZSB0ZXN0cyBmb3IgdHJhaWxpbmcgb3V0cHV0IGFuZCB1bmNhdWdodCBleGNlcHRpb25zICopXG4gICAgICAgIGxldCBleHBlY3RhdGlvbnMgPVxuICAgICAgICAgIGxldCB0cmFpbGluZ190ZXN0ID1cbiAgICAgICAgICAgIEV4cGVjdGF0aW9uLmV4cGVjdF90cmFpbGluZ1xuICAgICAgICAgICAgICB+aW5zZXJ0X2xvYzpcbiAgICAgICAgICAgICAgICB7IGxvYyA9IHsgdHJhaWxpbmdfbG9jIHdpdGggZW5kX3BvcyA9IHRyYWlsaW5nX2xvYy5zdGFydF9wb3MgfTsgYm9keV9sb2MgfVxuICAgICAgICAgICAgfD4gVGVzdF9ub2RlLm9mX2V4cGVjdGF0aW9uXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgZXhuX3Rlc3QgPVxuICAgICAgICAgICAgbWF0Y2ggZXhwZWN0ZWRfZXhuIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgICAgICAgIEV4cGVjdGF0aW9uLmV4cGVjdF91bmNhdWdodF9leG5cbiAgICAgICAgICAgICAgICB+Zm9ybWF0dGluZ19mbGV4aWJpbGl0eVxuICAgICAgICAgICAgICAgIH5sb2NhdGVkX3BheWxvYWQ6ZXhwZWN0ZWRfZXhuXG4gICAgICAgICAgICAgICAgfm5vZGVfbG9jOnRyYWlsaW5nX2xvY1xuICAgICAgICAgICAgICB8PiBUZXN0X25vZGUub2ZfZXhwZWN0YXRpb25cbiAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICBFeHBlY3RhdGlvbi5leHBlY3Rfbm9fdW5jYXVnaHRfZXhuXG4gICAgICAgICAgICAgICAgfmluc2VydF9sb2M6eyBsb2MgPSB0cmFpbGluZ19sb2M7IGJvZHlfbG9jIH1cbiAgICAgICAgICAgICAgfD4gVGVzdF9ub2RlLm9mX2V4cGVjdGF0aW9uXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoZXhuX3Rlc3RfaWQsIGV4bl90ZXN0KSA6OiAodHJhaWxpbmdfdGVzdF9pZCwgdHJhaWxpbmdfdGVzdCkgOjogZXhwZWN0YXRpb25zXG4gICAgICAgIGluXG4gICAgICAgICgqIEFkZCB0aGUgdGVzdHMgdG8gdGhlIGdsb2JhbCB0YWJsZSBhbmQgcmVzZXQgdGhlaXIgW3JlYWNoZWRfdGhpc19ydW5dIGZsYWdzICopXG4gICAgICAgIGxldCBleHBlY3RhdGlvbnMgPVxuICAgICAgICAgIFRlc3Rfbm9kZS5HbG9iYWxfcmVzdWx0c190YWJsZS5pbml0aWFsaXplX2FuZF9yZWdpc3Rlcl90ZXN0c1xuICAgICAgICAgICAgfmFic29sdXRlX2ZpbGVuYW1lXG4gICAgICAgICAgICBleHBlY3RhdGlvbnNcbiAgICAgICAgICAgIChmdW4gfm9yaWdpbmFsX2ZpbGVfY29udGVudHMgdHMgLT5cbiAgICAgICAgICAgIExpc3QuY29uY2F0X21hcFxuICAgICAgICAgICAgICB0c1xuICAgICAgICAgICAgICB+ZjpcbiAgICAgICAgICAgICAgICAoVGVzdF9ub2RlLkZvcl9tbHQudG9fZGlmZnNcbiAgICAgICAgICAgICAgICAgICB+Y3JfZm9yX211bHRpcGxlX291dHB1dHM6Q29uZmlndXJlZC5jcl9mb3JfbXVsdGlwbGVfb3V0cHV0c1xuICAgICAgICAgICAgICAgICAgIH5leHBlY3Rfbm9kZV9mb3JtYXR0aW5nOkV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcuZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgIH5vcmlnaW5hbF9maWxlX2NvbnRlbnRzKSlcbiAgICAgICAgaW5cbiAgICAgICAgKCogVG8gYXZvaWQgY2FwdHVyaW5nIG5vdC15ZXQgZmx1c2hlZCBkYXRhIG9mIHRoZSBzdGRvdXQvc3RkZXJyIGJ1ZmZlcnMuICopXG4gICAgICAgIFNoYXJlZC5mbHVzaCAoKTtcbiAgICAgICAgKCogUmVkaXJlY3Qgc3Rkb3V0L3N0ZGVyciAqKVxuICAgICAgICBsZXQgdGVzdF9ibG9jayA9IFNoYXJlZC5zZXRfdXBfYmxvY2sgYWJzb2x1dGVfZmlsZW5hbWUgaW5cbiAgICAgICAgKCogUnVuIHRoZSB0ZXN0ICopXG4gICAgICAgIEN1cnJlbnRfdGVzdC5zZXQgeyBsaW5lX251bWJlcjsgYmFzZW5hbWU7IGxvY2F0aW9uOyB0ZXN0X2Jsb2NrIH07XG4gICAgICAgIGxldCB0ZXN0X2V4biA9XG4gICAgICAgICAgQ29uZmlndXJlZC5kdW1wX2JhY2t0cmFjZSAoZnVuICgpIC0+XG4gICAgICAgICAgICAoKiBJZ25vcmUgb3V0cHV0IHRoYXQgd2FzIHByaW50ZWQgYmVmb3JlIHRoZSB0ZXN0IHN0YXJ0ZWQgKilcbiAgICAgICAgICAgIGxldCAoXyA6IHN0cmluZykgPSBTaGFyZWQucmVhZF90ZXN0X291dHB1dF91bnNhbml0aXplZCB0ZXN0X2Jsb2NrIGluXG4gICAgICAgICAgICBmICgpKVxuICAgICAgICBpblxuICAgICAgICAoKiBSdW4gdGhlIHRyYWlsaW5nIG91dHB1dCBhbmQgdW5jYXVnaHQgZXhuIHRlc3QgKilcbiAgICAgICAgbGV0IHRlc3Rfb3V0cHV0LCB0ZXN0X3RvX3J1biA9XG4gICAgICAgICAgbGV0IHRyYWlsaW5nX291dHB1dCA9XG4gICAgICAgICAgICBsZXQgdHJhaWxpbmdfcmF3ID0gcmVhZF90ZXN0X291dHB1dF9zYW5pdGl6ZWRfYW5kX2NoZWNrZWQgKCkgaW5cbiAgICAgICAgICAgIG1hdGNoIFN0cmluZy5zdHJpcCB0cmFpbGluZ19yYXcgd2l0aFxuICAgICAgICAgICAgfCBcIlwiIC0+IE5vbmVcbiAgICAgICAgICAgIHwgXyAtPiBTb21lIHRyYWlsaW5nX3Jhd1xuICAgICAgICAgIGluXG4gICAgICAgICAgbWF0Y2ggdGVzdF9leG4gd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBPcHRpb24udmFsdWUgdHJhaWxpbmdfb3V0cHV0IH5kZWZhdWx0OlwiXCIsIHRyYWlsaW5nX3Rlc3RfaWRcbiAgICAgICAgICB8IFNvbWUgdGVzdF9leG4gLT5cbiAgICAgICAgICAgIGxldCB0ZXN0X291dHB1dCA9XG4gICAgICAgICAgICAgIG1hdGNoIHRyYWlsaW5nX291dHB1dCB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiB0ZXN0X2V4blxuICAgICAgICAgICAgICB8IFNvbWUgdHJhaWxpbmdfb3V0cHV0IC0+XG4gICAgICAgICAgICAgICAgU3RyaW5nLmNvbmNhdFxuICAgICAgICAgICAgICAgICAgfnNlcDpcIlxcblwiXG4gICAgICAgICAgICAgICAgICBbIHRlc3RfZXhuOyBcIlRyYWlsaW5nIG91dHB1dFwiOyBcIi0tLS0tLS0tLS0tLS0tLVwiOyB0cmFpbGluZ19vdXRwdXQgXVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIHRlc3Rfb3V0cHV0LCBleG5fdGVzdF9pZFxuICAgICAgICBpblxuICAgICAgICBydW5fdGVzdF9pbm5lciB0ZXN0X2Jsb2NrIH50ZXN0X291dHB1dF9yYXc6dGVzdF9vdXRwdXQgfnRlc3RfaWQ6dGVzdF90b19ydW47XG4gICAgICAgICgqIFBlcmZvcm0gdGhlIHBlci10ZXN0IHJlYWNoYWJpbGl0eSBjaGVjayAqKVxuICAgICAgICBMaXN0Lml0ZXIgZXhwZWN0YXRpb25zIH5mOihmdW4gKF8sIHRlc3Rfbm9kZSkgLT5cbiAgICAgICAgICBUZXN0X25vZGUucmVjb3JkX2VuZF9vZl9ydW4gdGVzdF9ub2RlKTtcbiAgICAgICAgKCogUmVzdG9yZSBzdGRvdXQvc3RkZXJyICopXG4gICAgICAgIFNoYXJlZC5jbGVhbl91cF9ibG9jayB0ZXN0X2Jsb2NrO1xuICAgICAgICBDdXJyZW50X3Rlc3QudW5zZXQgKCk7XG4gICAgICAgICgqIFJlcG9ydCB0aGF0IHRoaXMgdGVzdCBwYXNzZWQsIGJlY2F1c2Ugd2UgcmVwb3J0IGV4cGVjdCB0ZXN0IGZhaWx1cmVzIGJ5IGFcbiAgICAgICAgICAgIGRpZmZlcmVudCBtZWNoYW5pc20uICopXG4gICAgICAgIHRydWUpXG4gIDs7XG5lbmRcblxubGV0IGF0X2V4aXQgKCkgPVxuICBDdXJyZW50X3Rlc3QuaXRlclxuICAgIH5mOlxuICAgICAgKGZ1blxuICAgICAgICB7IGxpbmVfbnVtYmVyXG4gICAgICAgIDsgYmFzZW5hbWVcbiAgICAgICAgOyBsb2NhdGlvbiA9IHsgc3RhcnRfYm9sOyBzdGFydF9wb3M7IGVuZF9wb3MgfVxuICAgICAgICA7IHRlc3RfYmxvY2tcbiAgICAgICAgfVxuICAgICAgICAtPlxuICAgIFNoYXJlZC5mbHVzaCAoKTtcbiAgICBsZXQgZmluID0gU3RkbGliLm9wZW5faW4gKFNoYXJlZC5vdXRwdXRfZmlsZSB0ZXN0X2Jsb2NrKSBpblxuICAgIGxldCBhbGxfb3V0ID0gU3RkbGliLnJlYWxseV9pbnB1dF9zdHJpbmcgZmluIChTdGRsaWIuaW5fY2hhbm5lbF9sZW5ndGggZmluKSBpblxuICAgIFNoYXJlZC5jbGVhbl91cF9ibG9jayB0ZXN0X2Jsb2NrO1xuICAgIFN0ZGxpYi5QcmludGYuZXByaW50ZlxuICAgICAgXCJGaWxlICVTLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkOlxcblxcXG4gICAgICAgRXJyb3I6IHByb2dyYW0gZXhpdGVkIHdoaWxlIGV4cGVjdCB0ZXN0IHdhcyBydW5uaW5nIVxcblxcXG4gICAgICAgT3V0cHV0IGNhcHR1cmVkIHNvIGZhcjpcXG5cXFxuICAgICAgICVzXFxuXFxcbiAgICAgICAlIVwiXG4gICAgICBiYXNlbmFtZVxuICAgICAgbGluZV9udW1iZXJcbiAgICAgIChzdGFydF9wb3MgLSBzdGFydF9ib2wpXG4gICAgICAoZW5kX3BvcyAtIHN0YXJ0X2JvbClcbiAgICAgIGFsbF9vdXQpXG47O1xuXG5tb2R1bGUgRm9yX2V4dGVybmFsID0gc3RydWN0XG4gIGxldCByZWFkX2N1cnJlbnRfdGVzdF9vdXRwdXRfZXhuIH5oZXJlID1cbiAgICBtYXRjaCBDdXJyZW50X3Rlc3QuY3VycmVudF90ZXN0ICgpIHdpdGhcbiAgICB8IFNvbWUgdGVzdF9ibG9jayAtPlxuICAgICAgdGVzdF9ibG9jayB8PiBTaGFyZWQucmVhZF90ZXN0X291dHB1dF91bnNhbml0aXplZCB8PiBFeHBlY3RfdGVzdF9jb25maWcuc2FuaXRpemVcbiAgICB8IE5vbmUgLT5cbiAgICAgIGZhaWx3aXRoXG4gICAgICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgICAgICBcIlBweF9leHBlY3RfcnVudGltZS5yZWFkX2N1cnJlbnRfdGVzdF9vdXRwdXRfZXhuIGNhbGxlZCB3aGlsZSB0aGVyZSBhcmUgbm8gXFxcbiAgICAgICAgICAgIHRlc3RzIHJ1bm5pbmcgYXQgJXNcIlxuICAgICAgICAgICAoU291cmNlX2NvZGVfcG9zaXRpb24udG9fc3RyaW5nIGhlcmUpKVxuICA7O1xuXG4gIGxldCBhbV9ydW5uaW5nX2V4cGVjdF90ZXN0ID0gQ3VycmVudF90ZXN0LmlzX3J1bm5pbmdcblxuICBsZXQgZGVmYXVsdF9jcl9mb3JfbXVsdGlwbGVfb3V0cHV0cyA9XG4gICAgbGV0IG1vZHVsZSBDb25maWd1cmVkID0gQ29uZmlndXJlZCAoRXhwZWN0X3Rlc3RfY29uZmlnKSBpblxuICAgIENvbmZpZ3VyZWQuY3JfZm9yX211bHRpcGxlX291dHB1dHNcbiAgOztcbmVuZFxuIiwib3BlbiEgQmFzZVxuXG4oKiogVGhpcyBsaWJyYXJ5IHByb3ZpZGVzIHRoZSBydW50aW1lIHJlcHJlc2VudGF0aW9uIG9mIGV4cGVjdCB0ZXN0cyBhbmQgbXVjaCBvZiB0aGUgbG9naWNcbiAgICBmb3IgcnVubmluZyB0aGVtLlxuXG4gICAgVGhlIFtUZXN0X2Jsb2NrXSBtb2R1bGUgZGVmaW5lcyB0aGUgcnVudGltZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgd2hvbGVcbiAgICBbbGV0JWV4cGVjdF90ZXN0XSBibG9jay4gSXQgZXhwb3J0cyBhIFtNYWtlXSBmdW5jdG9yIHRoYXQgaXMgdXNlZCBpbiBnZW5lcmF0ZWQgY29kZSB0b1xuICAgIHByb2R1Y2UgYSBtb2R1bGUgZnJvbSB0aGUgbG9jYWxseSBib3VuZCBbRXhwZWN0X3Rlc3RfY29uZmlnXS4gW3J1bl9zdWl0ZV0gZnJvbSB0aGVcbiAgICByZXN1bHRpbmcgbW9kdWxlIHRha2VzIGluIHJlbWFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXhwZWN0IHRlc3QsIGluY2x1ZGluZ1xuICAgIGlubGluZSB0ZXN0IGNvbmZpZ3VyYXRpb25zLCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29udGFpbmVkIGV4cGVjdGF0aW9ucywgYW5kIGFcbiAgICBjYWxsYmFjayBjb250YWluaW5nIHRoZSBib2R5IG9mIHRoZSB0ZXN0LlxuXG4gICAgVGhlIFt+ZXhwZWN0YXRpb25zXSBhcmd1bWVudCB0byBbcnVuX3N1aXRlXSBpcyBhbiBhc3NvYyBsaXN0IG1hcHBpbmcgdW5pcXVlIGlkcyB0b1xuICAgIFtUZXN0X25vZGUudF1zLiBBIFtUZXN0X25vZGUudF0gc3RvcmVzIHRoZSByZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBbWyVleHBlY3RdXSB0ZXN0XG4gICAgQVNUIG5vZGUgYW5kIGNvbGxlY3RzIHRoZSByZXN1bHRzIG9mIHRlc3RzIHRoYXQgcmVhY2ggdGhpcyBub2RlLlxuXG4gICAgSW4gdGhlIGJvZHkgb2YgdGhlIHRlc3QsIHRoZSBbWyVleHBlY3RdXSBBU1Qgbm9kZXMgYXJlIHJlcGxhY2VkIGJ5IGNhbGxzIHRvXG4gICAgW3J1bl90ZXN0XSwgd2l0aCB0aGUgYXBwcm9wcmlhdGUgaWQgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LlxuXG4gICAgRm9yIGFuIGV4YW1wbGUsIGNvbnNpZGVyIGEgZmlsZSB0aGF0IGNvbnRhaW5zIGp1c3QgdGhlIHNpbXBsZSBbbGV0JWV4cGVjdF90ZXN0XSBiZWxvdzpcblxuICAgIHtbXG4gICAgICBsZXQlZXhwZWN0X3Rlc3QgXyA9XG4gICAgICAgIHByaW50X3N0cmluZyBcIkhlbGxvXCI7XG4gICAgICAgIFslZXhwZWN0IHt8IEhlbGxvIHx9XTtcbiAgICAgICAgcHJpbnRfc3RyaW5nIFwid29ybGRcIjtcbiAgICAgICAgWyVleHBlY3RfZXhhY3Qge3h8d29ybGR8eH1dXG4gICAgICA7O1xuICAgIF19XG5cbiAgICBJdCB3aWxsIGV4cGFuZCB0byBjb2RlIHRoYXQgbG9va3Mgc29tZXRoaW5nIGxpa2UgdGhpczpcblxuICAgIHtbXG4gICAgICAoKiBUaGlzIHN0YXRlbWVudCBpcyBhZGRlZCB0byB0aGUgdG9wIG9mIGVhY2ggcmV3cml0dGVuIGZpbGU7IGl0IGlzIHVzZWQgdG8gbWFrZVxuICAgICAgICAgc3VyZSB0ZXN0cyBhcmUgb25seSBydW4gZnJvbSB0aGUgZmlsZXMgaW4gd2hpY2ggdGhleSBhcmUgZGVjbGFyZWQuICopXG4gICAgICBsZXQgKCkgPVxuICAgICAgICBQcHhfZXhwZWN0X3J1bnRpbWUuQ3VycmVudF9maWxlLnNldFxuICAgICAgICAgIH5maWxlbmFtZV9yZWxfdG9fcHJvamVjdF9yb290OlwiZm9vL2Jhci90ZXN0L3Rlc3QubWxcIlxuXG4gICAgICAoKiBFYWNoIHRlc3QgZXhwYW5kcyBpbnRvIHNvbWV0aGluZyB0aGF0IGxvb2tzIGFwcHJveGltYXRlbHkgbGlrZSB0aGlzLiBTb21lIG9mIHRoZVxuICAgICAgICAgYXJndW1lbnRzIHRvIFtQcHhfZXhwZWN0X3Rlc3RfYmxvY2sucnVuX3N1aXRlXSBhcmUgZWxpZGVkIGZvciBjbGFyaXR5LiAqKVxuICAgICAgbGV0ICgpID1cbiAgICAgICAgKCogUHJlcGFyZSB0byByZWFkIHRlc3Qgb3V0cHV0IHVzaW5nIHRoZSBzZXR0aW5ncyBmcm9tIFtFeHBlY3RfdGVzdF9jb25maWddICopXG4gICAgICAgIGxldCBtb2R1bGUgUHB4X2V4cGVjdF90ZXN0X2Jsb2NrID1cbiAgICAgICAgICBQcHhfZXhwZWN0X3J1bnRpbWUuTWFrZV90ZXN0X2Jsb2NrKEV4cGVjdF90ZXN0X2NvbmZpZykgaW5cbiAgICAgICAgUHB4X2V4cGVjdF90ZXN0X2Jsb2NrLnJ1bl9zdWl0ZVxuICAgICAgICAgICgqIFRoZSBuYW1lIG9mIHRoZSBmaWxlIGluIHdoaWNoIHRoZSB0ZXN0IGlzIGRlZmluZWQuIFRoaXMgbGV0cyB0aGUgcnVudGltZVxuICAgICAgICAgICAgIGNoZWNrIHRoYXQgdGhlIGZpbGVuYW1lIHNldCBoZXJlIGF0IHBweC10aW1lIG1hdGNoZXMgdGhlIG9uZSB0aGF0IGlzIHNldCBieVxuICAgICAgICAgICAgIHRoZSBibG9jayBhYm92ZSBhdCBydW50aW1lLiBJZiB0aGUgdGVzdCB3ZXJlIGRlZmluZWQgaW4gYSBmdW5jdG9yIGFuZCB0aGF0XG4gICAgICAgICAgICAgZnVuY3RvciBpbnZva2VkIGZyb20gYW5vdGhlciBmaWxlLCB0aGUgZmlsZW5hbWVzIHdvdWxkIG5vdCBtYXRjaC4gKilcbiAgICAgICAgICB+ZmlsZW5hbWVfcmVsX3RvX3Byb2plY3Rfcm9vdDpcImZvby9iYXIvdGVzdC90ZXN0Lm1sXCJcbiAgICAgICAgICAoKiBUaGUgaWRzIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiByZWdpc3RlcmluZyB0aGUgdHJhaWxpbmcgb3V0cHV0IHRlc3QgYW5kIHRoZVxuICAgICAgICAgICAgIHVuY2F1Z2h0IGV4Y2VwdGlvbiB0ZXN0cy4gVGhleSBhcmUgbWludGVkIGF0IHBweCB0aW1lIGJlY2F1c2UgdGhhdCBpcyB0aGVcbiAgICAgICAgICAgICB0aW1lIHRoYXQgaXQgaXMgZWFzaWVzdCB0byBndWFyYW50ZWUgdGhlaXIgdW5pcXVlbmVzcy4gKilcbiAgICAgICAgICB+dHJhaWxpbmdfdGVzdF9pZDooUHB4X2V4cGVjdF9ydW50aW1lLkV4cGVjdGF0aW9uX2lkLm9mX2ludCAyKVxuICAgICAgICAgIH5leG5fdGVzdF9pZDooUHB4X2V4cGVjdF9ydW50aW1lLkV4cGVjdGF0aW9uX2lkLm9mX2ludCAzKVxuICAgICAgICAgICgqIEFuIGFzc29jIGxpc3QgbWFwcGluZyBpZHMgdG8gcmVwcmVzZW50YXRpb25zIG9mIGV4cGVjdCBub2RlcyB0aGF0IGFwcGVhciBpblxuICAgICAgICAgICAgIHRoaXMgdGVzdC4gTGF0ZXIsIHdoZW4gZW5jb3VudGVyaW5nIGV4cGVjdCBub2RlcywgaW5mb3JtYXRpb24gYWJvdXQgdGhlbSBpc1xuICAgICAgICAgICAgIGxvb2tlZCB1cCBpbiB0aGlzIHRhYmxlLiAqKVxuICAgICAgICAgIH5leHBlY3RhdGlvbnM6KChbKFBweF9leHBlY3RfcnVudGltZS5FeHBlY3RhdGlvbl9pZC5vZl9pbnQgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcHhfZXhwZWN0X3J1bnRpbWUuVGVzdF9ub2RlLkNyZWF0ZS5leHBlY3RfZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgY29udGVudHMgPSBcIndvcmxkXCI7IHRhZyA9IChUYWcgXCJ4XCIpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc3RhcnRfYm9sID0gLi4uOyBzdGFydF9wb3MgPSAuLi47IGVuZF9wb3MgPSAuLi4gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoUHB4X2V4cGVjdF9ydW50aW1lLkV4cGVjdGF0aW9uX2lkLm9mX2ludCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBweF9leHBlY3RfcnVudGltZS5UZXN0X25vZGUuQ3JlYXRlLmV4cGVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBjb250ZW50cyA9IFwiIEhlbGxvIFwiOyB0YWcgPSAoVGFnIFwiXCIpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc3RhcnRfYm9sID0gLi4uOyBzdGFydF9wb3MgPSAuLi47IGVuZF9wb3MgPSAuLi4gfSldKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICgqIFRoZSBib2R5IG9mIHRoZSBsZXQgYmluZGluZyBpcyBwYXNzZWQgYXMgYSBjYWxsYmFjay4gKilcbiAgICAgICAgICAoZnVuICgpIC0+XG4gICAgICAgICAgICAgcHJpbnRfc3RyaW5nIFwiSGVsbG9cIjtcbiAgICAgICAgICAgICAoKiBUZXN0cyBhcmUgcnVuIGJ5IHBhc3NpbmcgaW4gdGhlIGlkIG9mIHRoZSBlbmNvdW50ZXJlZCB0ZXN0IG5vZGUuICopXG4gICAgICAgICAgICAgUHB4X2V4cGVjdF90ZXN0X2Jsb2NrLnJ1bl90ZXN0XG4gICAgICAgICAgICAgICB+dGVzdF9pZDooUHB4X2V4cGVjdF9ydW50aW1lLkV4cGVjdGF0aW9uX2lkLm9mX2ludCAwKTtcbiAgICAgICAgICAgICBwcmludF9zdHJpbmcgXCJ3b3JsZFwiO1xuICAgICAgICAgICAgIFBweF9leHBlY3RfdGVzdF9ibG9jay5ydW5fdGVzdFxuICAgICAgICAgICAgICAgfnRlc3RfaWQ6KFBweF9leHBlY3RfcnVudGltZS5FeHBlY3RhdGlvbl9pZC5vZl9pbnQgMSkpXG5cbiAgICAgICgqIFRoaXMgc3RhdGVtZW50IGlzIGFkZGVkIHRvIHRoZSBlbmQgb2YgZWFjaCBmaWxlIHNvIHRoYXQgdGhlIGV4cGVjdCB0ZXN0IHJ1bnRpbWVcbiAgICAgICAgIGtub3dzIHRoZSBmaWxlIGlzIGZpbmlzaGVkIGV4ZWN1dGluZyBhbmQgYSBuZXcgb25lIGNhbiBiZSBzZXQgYXMgY3VycmVudC4gKilcbiAgICAgIGxldCAoKSA9IFBweF9leHBlY3RfcnVudGltZS5DdXJyZW50X2ZpbGUudW5zZXQgKClcbiAgICBdfVxuKilcblxuKCogUmVnaXN0ZXIgdGhlIHJlYWNoYWJpbGl0eSBjaGVjayBhbmQgY29ycmVjdGVkIGZpbGUgd3JpdGluZyBhcyBhbiBldmFsdWF0b3Igd2l0aFxuICAgW1BweF9pbmxpbmVfdGVzdF9saWJdICopXG5sZXQgKCkgPVxuICBQcHhfaW5saW5lX3Rlc3RfbGliLmFkZF9ldmFsdWF0b3IgfmY6KGZ1biAoKSAtPlxuICAgIFN0ZGxpYi5TeXMuY2hkaXIgKExhenkuZm9yY2UgQ3VycmVudF9maWxlLmluaXRpYWxfZGlyKTtcbiAgICBUZXN0X25vZGUuR2xvYmFsX3Jlc3VsdHNfdGFibGUucHJvY2Vzc19lYWNoX2ZpbGVcbiAgICAgIH5mOihmdW4gfmZpbGVuYW1lIH50ZXN0X25vZGVzIH5wb3N0cHJvY2VzcyAtPlxuICAgICAgV3JpdGVfY29ycmVjdGVkX2ZpbGUuZlxuICAgICAgICB0ZXN0X25vZGVzXG4gICAgICAgIH51c2VfY29sb3I6KFBweF9pbmxpbmVfdGVzdF9saWIudXNlX2NvbG9yICgpKVxuICAgICAgICB+aW5fcGxhY2U6KFBweF9pbmxpbmVfdGVzdF9saWIuaW5fcGxhY2UgKCkpXG4gICAgICAgIH5kaWZmX2NvbW1hbmQ6KFBweF9pbmxpbmVfdGVzdF9saWIuZGlmZl9jb21tYW5kICgpKVxuICAgICAgICB+ZGlmZl9wYXRoX3ByZWZpeDooUHB4X2lubGluZV90ZXN0X2xpYi5kaWZmX3BhdGhfcHJlZml4ICgpKVxuICAgICAgICB+d2l0aF86cG9zdHByb2Nlc3NcbiAgICAgICAgfmZpbGVuYW1lKVxuICAgIHw+IFBweF9pbmxpbmVfdGVzdF9saWIuVGVzdF9yZXN1bHQuY29tYmluZV9hbGwpXG47O1xuXG4oKiBBbGVydCBvZiBtaWQtdGVzdCBydW50aW1lIGZhaWx1cmUuICopXG5sZXQgKCkgPSBTdGRsaWIuYXRfZXhpdCBUZXN0X2Jsb2NrLmF0X2V4aXRcblxuKCogRXhwb3J0ZWQgZGVmaW5pdGlvbnMgKilcblxubW9kdWxlIEV4cGVjdF9ub2RlX2Zvcm1hdHRpbmcgPSBUeXBlcy5FeHBlY3Rfbm9kZV9mb3JtYXR0aW5nXG5tb2R1bGUgQ29tcGFjdF9sb2MgPSBUeXBlcy5Db21wYWN0X2xvY1xubW9kdWxlIEV4cGVjdGF0aW9uX2lkID0gVHlwZXMuRXhwZWN0YXRpb25faWRcbm1vZHVsZSBEZWxpbWl0ZXIgPSBUeXBlcy5TdHJpbmdfbm9kZV9mb3JtYXQuRGVsaW1pdGVyXG5tb2R1bGUgUGF5bG9hZCA9IE91dHB1dC5QYXlsb2FkXG5cbm1vZHVsZSBDdXJyZW50X2ZpbGUgOiBzaWdcbiAgdmFsIHNldCA6IGZpbGVuYW1lX3JlbF90b19wcm9qZWN0X3Jvb3Q6c3RyaW5nIC0+IHVuaXRcbiAgdmFsIHVuc2V0IDogdW5pdCAtPiB1bml0XG5lbmQgPVxuICBDdXJyZW50X2ZpbGVcblxubW9kdWxlIFRlc3Rfbm9kZSA9IHN0cnVjdFxuICB0eXBlIHQgPSBUZXN0X25vZGUudFxuXG4gIG1vZHVsZSBDcmVhdGUgPSBUZXN0X25vZGUuQ3JlYXRlXG4gIG1vZHVsZSBGb3JfbWx0ID0gVGVzdF9ub2RlLkZvcl9tbHRcbmVuZFxuXG5tb2R1bGUgV3JpdGVfY29ycmVjdGVkX2ZpbGUgPSBXcml0ZV9jb3JyZWN0ZWRfZmlsZVxubW9kdWxlIE1ha2VfdGVzdF9ibG9jayA9IFRlc3RfYmxvY2suTWFrZVxubW9kdWxlIEZvcl9leHRlcm5hbCA9IFRlc3RfYmxvY2suRm9yX2V4dGVybmFsXG5tb2R1bGUgRm9yX2FwcGx5X3N0eWxlID0gRXhwZWN0YXRpb24uRm9yX2FwcGx5X3N0eWxlXG4iXX0=
