// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Pairing_heap
//# unitInfo: Requires: Base__Container, Core, Core__Array, Core__Int, Core__List, Core__Option, Ppx_bench_lib__Benchmark_accumulator, Ppx_expect_runtime, Ppx_inline_test_lib, Ppx_module_timer_runtime, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Pairing_heap$0 = "Pairing_heap",
    cst_pairing_heap$0 = "pairing_heap",
    cst_pairing_heap_src_pairing_h = "pairing_heap/src/pairing_heap.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Core = global_data.Core,
    Core_Array = global_data.Core__Array,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Core_Option = global_data.Core__Option,
    Tuple_pool = global_data.Tuple_pool,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Ppx_expect_runtime = global_data.Ppx_expect_runtime,
    Ppx_inline_test_lib = global_data.Ppx_inline_test_lib,
    Core_Int = global_data.Core__Int,
    Base_Container = global_data.Base__Container;
   caml_call1(Ppx_module_timer_runtime[4], cst_Pairing_heap$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_pairing_heap$0);
   caml_call1(Ppx_expect_runtime[1][1], cst_pairing_heap_src_pairing_h);
   caml_call2(Ppx_inline_test_lib[6], cst_pairing_heap$0, "pairing_heap.ml");
   var
    empty = Tuple_pool[3][4],
    is_empty = Tuple_pool[3][5],
    equal = Tuple_pool[3][7],
    cst_cannot_remove_from_a_diffe = "cannot remove from a different heap",
    cst_Heap_value_exn_node_was_re =
      "Heap.value_exn: node was removed from the heap",
    cst_Heap_top_exn_called_on_an_ = "Heap.top_exn called on an empty heap",
    _d_ = [0, cst_pairing_heap_src_pairing_h, 239, 10],
    _e_ = [0, cst_pairing_heap_src_pairing_h, 237, 8],
    _f_ = [0, cst_pairing_heap_src_pairing_h, 246, 2],
    _a_ = [0, cst_pairing_heap_src_pairing_h, 110, 4],
    cst_pairing_heap = cst_pairing_heap$0,
    cst_Pairing_heap = cst_Pairing_heap$0,
    dummy_id = -1;
   function child(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][4]);
   }
   function sibling(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][5]);
   }
   function prev(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][6]);
   }
   function id(t, pool){
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][7]);
   }
   function set_child(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][4], v);
   }
   function set_sibling(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][5], v);
   }
   function set_prev(t, v, pool){
    return caml_call4(Tuple_pool[34], pool, t, Tuple_pool[2][6], v);
   }
   function value_exn(t, pool){
    if(caml_call1(is_empty, t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    return caml_call3(Tuple_pool[32], pool, t, Tuple_pool[2][3]);
   }
   function allocate(value, pool, id){
    var
     _H_ = caml_call1(empty, 0),
     _I_ = caml_call1(empty, 0),
     _J_ = caml_call1(empty, 0);
    return caml_call6(Tuple_pool[21], pool, value, _J_, _I_, _H_, id);
   }
   function free(t, pool){return caml_call2(Tuple_pool[16], pool, t);}
   function disconnect_sibling(t, pool){
    var sibling$0 = sibling(t, pool);
    if(1 - caml_call1(is_empty, sibling$0)){
     set_sibling(t, caml_call1(empty, 0), pool);
     set_prev(sibling$0, caml_call1(empty, 0), pool);
    }
    return sibling$0;
   }
   function disconnect_child(t, pool){
    var child$0 = child(t, pool);
    if(1 - caml_call1(is_empty, child$0)){
     set_child(t, caml_call1(empty, 0), pool);
     set_prev(child$0, caml_call1(empty, 0), pool);
    }
    return child$0;
   }
   function detach(t, pool){
    if(1 - caml_call1(is_empty, t)){
     var prev$0 = prev(t, pool);
     if(1 - caml_call1(is_empty, prev$0)){
      var
       relation_to_prev =
         caml_call2(equal, t, child(prev$0, pool)) ? -977688164 : -560648958;
      set_prev(t, caml_call1(empty, 0), pool);
      var sibling = disconnect_sibling(t, pool);
      if(-560648958 <= relation_to_prev)
       set_sibling(prev$0, sibling, pool);
      else
       set_child(prev$0, sibling, pool);
      if(1 - caml_call1(is_empty, sibling))
       return set_prev(sibling, prev$0, pool);
     }
    }
    return;
   }
   function create(capacity){
    var
     _E_ = caml_call1(Tuple_pool[3][4], 0),
     _F_ = caml_call1(Tuple_pool[3][4], 0),
     _G_ = [0, 0, caml_call1(Tuple_pool[3][4], 0), _F_, _E_, dummy_id];
    return caml_call3(Tuple_pool[9], Tuple_pool[1][21], capacity, _G_);
   }
   var _b_ = Core_Int[87], _c_ = Core_Int[64];
   function invariant(param, t){
    if
     (!
      caml_call1(is_empty, t[3])
      && ! caml_call1(is_empty, sibling(t[3], t[2])))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var
     _C_ = caml_call1(empty, 0),
     to_visit$2 = [0, [0, t[3], _C_, 0], 0],
     to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return 0;
     var
      to_visit$0 = to_visit[2],
      match = to_visit[1],
      maybe_parent_value = match[3],
      expected_prev = match[2],
      node = match[1];
     if(caml_call1(is_empty, node))
      var to_visit = to_visit$0;
     else{
      var this_value = value_exn(node, t[2]);
      if(! caml_call2(equal, prev(node, t[2]), expected_prev))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var
       _A_ =
         function(this_value){
           return function(parent_value){
            var _D_ = caml_call2(t[1], parent_value, this_value);
            if(caml_call2(Core[89], _D_, 0)) return 0;
            throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);};
          }
          (this_value);
      caml_call2(Core_Option[46], maybe_parent_value, _A_);
      var
       _B_ =
         [0, [0, sibling(node, t[2]), node, maybe_parent_value], to_visit$0],
       to_visit$1 = [0, [0, child(node, t[2]), node, [0, this_value]], _B_],
       to_visit = to_visit$1;
     }
    }
   }
   function create$0(opt, cmp, param){
    if(opt) var sth = opt[1], min_size = sth; else var min_size = 1;
    var _z_ = caml_call1(empty, 0);
    return [0, cmp, create(min_size), _z_, 0];
   }
   function copy(param){
    var
     cmp = param[1],
     pool$0 = param[2],
     start = param[3],
     num_of_allocated_nodes = param[4],
     pool = create(caml_call1(Tuple_pool[11], pool$0));
    function copy_node(node, to_visit){
     if(caml_call1(is_empty, node))
      return [0, caml_call1(empty, 0), to_visit];
     var
      _x_ = id(node, pool$0),
      new_node = allocate(value_exn(node, pool$0), pool, _x_),
      _y_ = [0, [0, new_node, -560648958, sibling(node, pool$0)], to_visit],
      to_visit$0 = [0, [0, new_node, -977688164, child(node, pool$0)], _y_];
     return [0, new_node, to_visit$0];
    }
    var
     match$1 = copy_node(start, 0),
     to_visit$1 = match$1[2],
     new_start = match$1[1],
     to_visit = to_visit$1;
    for(;;){
     if(! to_visit) return [0, cmp, pool, new_start, num_of_allocated_nodes];
     var
      rest = to_visit[2],
      match = to_visit[1],
      node_to_copy = match[3],
      slot = match[2],
      node_to_update = match[1],
      match$0 = copy_node(node_to_copy, rest),
      to_visit$0 = match$0[2],
      new_node = match$0[1];
     if(-560648958 <= slot)
      set_sibling(node_to_update, new_node, pool);
     else
      set_child(node_to_update, new_node, pool);
     if(1 - caml_call1(is_empty, new_node))
      set_prev(new_node, node_to_update, pool);
     var to_visit = to_visit$0;
    }
   }
   function merge(t, root1, root2){
    if(caml_call1(is_empty, root1)) return root2;
    if(caml_call1(is_empty, root2)) return root1;
    function add_child(t, node, new_child){
     var pool = t[2], current_child = disconnect_child(node, pool);
     set_sibling(new_child, current_child, pool);
     if(1 - caml_call1(is_empty, current_child))
      set_prev(current_child, new_child, pool);
     set_child(node, new_child, pool);
     set_prev(new_child, node, pool);
     return node;
    }
    var
     v1 = value_exn(root1, t[2]),
     v2 = value_exn(root2, t[2]),
     _w_ = caml_call2(t[1], v1, v2);
    return caml_call2(Core[92], _w_, 0)
            ? add_child(t, root1, root2)
            : add_child(t, root2, root1);
   }
   function top_exn(t){
    return caml_call1(is_empty, t[3])
            ? caml_call1(Core[6], cst_Heap_top_exn_called_on_an_)
            : value_exn(t[3], t[2]);
   }
   function top(t){return caml_call1(is_empty, t[3]) ? 0 : [0, top_exn(t)];}
   function add_node(t$1, v){
    var t = t$1[2];
    if(caml_call1(Tuple_pool[14], t)){
     var t$0 = t$1[2];
     t$1[2] = caml_call2(Tuple_pool[13], 0, t$0);
    }
    t$1[4] = t$1[4] + 1 | 0;
    var _v_ = caml_call1(_c_, t$1[4]), node = allocate(v, t$1[2], _v_);
    t$1[3] = merge(t$1, t$1[3], node);
    return node;
   }
   function add(t, v){add_node(t, v); return 0;}
   var max_stack_depth = 1000;
   function loop(t, depth, head$0){
    if(! caml_call2(Core[88], depth, max_stack_depth)){
     if(caml_call1(is_empty, head$0)) return head$0;
     var next1$0 = disconnect_sibling(head$0, t[2]);
     if(caml_call1(is_empty, next1$0)) return head$0;
     var
      next2$0 = disconnect_sibling(next1$0, t[2]),
      _u_ = loop(t, depth + 1 | 0, next2$0);
     return merge(t, merge(t, head$0, next1$0), _u_);
    }
    var acc = 0, head = head$0;
    for(;;){
     if(caml_call1(is_empty, head))
      var match = acc;
     else{
      var next1 = disconnect_sibling(head, t[2]);
      if(! caml_call1(is_empty, next1)){
       var
        next2 = disconnect_sibling(next1, t[2]),
        acc$0 = [0, merge(t, head, next1), acc],
        acc = acc$0,
        head = next2;
       continue;
      }
      var match = [0, head, acc];
     }
     if(! match) return caml_call1(empty, 0);
     var h = match[1];
     if(! match[2]) return h;
     var
      xs = match[2],
      _t_ = function(acc, heap){return merge(t, acc, heap);};
     return caml_call3(Core_List[20], xs, h, _t_);
    }
   }
   function remove_non_empty(t, node){
    var pool = t[2];
    detach(node, pool);
    var
     head = disconnect_child(node, pool),
     merged_children = loop(t, 0, head),
     new_root =
       caml_call2(equal, t[3], node)
        ? merged_children
        : merge(t, t[3], merged_children);
    free(node, pool);
    t[3] = new_root;
    return 0;
   }
   function remove_top(t){
    var _s_ = 1 - caml_call1(is_empty, t[3]);
    return _s_ ? remove_non_empty(t, t[3]) : _s_;
   }
   function clear(t){
    var _q_ = 1 - caml_call1(is_empty, t[3]);
    if(_q_){
     var pool = t[2], node$0 = t[3], node = node$0;
     for(;;){
      var child$0 = child(node, pool), sibling$0 = sibling(node, pool);
      if(caml_call1(is_empty, child$0))
       if(caml_call1(is_empty, sibling$0)){
        var prev$0 = prev(node, pool);
        detach(node, pool);
        free(node, pool);
        if(! (1 - caml_call1(is_empty, prev$0))){
         t[3] = caml_call1(empty, 0);
         var _r_ = 0;
         break;
        }
        var node = prev$0;
       }
       else
        var node = sibling$0;
      else
       var node = child$0;
     }
    }
    else
     var _r_ = _q_;
    return _r_;
   }
   function pop_exn(t){var r = top_exn(t); remove_top(t); return r;}
   function pop(t){return caml_call1(is_empty, t[3]) ? 0 : [0, pop_exn(t)];}
   function pop_if(t, f){
    var match = top(t);
    if(! match) return 0;
    var v = match[1];
    return caml_call1(f, v) ? (remove_top(t), [0, v]) : 0;
   }
   function pop_while(t, f){
    var acc = 0;
    for(;;){
     var match = pop_if(t, f);
     if(! match) return caml_call1(Core_List[59], acc);
     var x = match[1], acc$0 = [0, x, acc], acc = acc$0;
    }
   }
   function fold(t, init, f){
    var
     pool = t[2],
     to_visit$2 = [0, t[3], 0],
     acc = init,
     to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return acc;
     var to_visit$0 = to_visit[2], node = to_visit[1];
     if(caml_call1(is_empty, node))
      var to_visit = to_visit$0;
     else
      var
       _p_ = [0, child(node, pool), to_visit$0],
       to_visit$1 = [0, sibling(node, pool), _p_],
       acc$0 = caml_call2(f, acc, value_exn(node, pool)),
       acc = acc$0,
       to_visit = to_visit$1;
    }
   }
   function iter(t, f){
    var pool = t[2], to_visit$2 = [0, t[3], 0], to_visit = to_visit$2;
    for(;;){
     if(! to_visit) return 0;
     var to_visit$0 = to_visit[2], node = to_visit[1];
     if(caml_call1(is_empty, node))
      var to_visit = to_visit$0;
     else{
      caml_call1(f, value_exn(node, pool));
      var
       _o_ = [0, child(node, pool), to_visit$0],
       to_visit$1 = [0, sibling(node, pool), _o_],
       to_visit = to_visit$1;
     }
    }
   }
   function length(t){var t$0 = t[2]; return caml_call1(Tuple_pool[12], t$0);}
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C = caml_call1(Base_Container[17], [0, fold, iter$0, length$0]);
   function is_empty$0(t){return caml_call1(is_empty, t[3]);}
   var
    mem = C[1],
    exists = C[8],
    for_all = C[9],
    count = C[10],
    sum = C[11],
    find = C[12],
    find_map = C[13],
    to_list = C[14],
    to_array = C[15],
    min_elt = C[16],
    max_elt = C[17],
    fold_result = C[6],
    fold_until = C[7];
   function of_array(arr, cmp){
    var t = create$0([0, arr.length - 1], cmp, 0);
    function _n_(v){return add(t, v);}
    caml_call2(Core_Array[35], arr, _n_);
    return t;
   }
   function of_list(l, cmp){
    return of_array(caml_call1(Core_Array[24], l), cmp);
   }
   function sexp_of_t(f, t){
    var
     _k_ = t[1],
     _l_ = caml_call1(to_array, t),
     _m_ = caml_call2(Core_Array[118], _l_, _k_);
    return caml_call2(Core_Array[20], f, _m_);
   }
   function is_node_valid(t){
    var _j_ = t[2];
    return caml_call2(_b_, id(t[1], t[3][2]), _j_);
   }
   function value_exn$0(t){
    return is_node_valid(t)
            ? value_exn(t[1], t[3][2])
            : caml_call1(Core[6], cst_Heap_value_exn_node_was_re);
   }
   function sexp_of_t$0(sexp_of_a, t){
    var x_001 = is_node_valid(t) ? [0, value_exn(t[1], t[3][2])] : 0;
    return caml_call2(Core[515], sexp_of_a, x_001);
   }
   function remove(t, token){
    if(t !== token[3])
     return caml_call1(Core[6], cst_cannot_remove_from_a_diffe);
    var _h_ = 1 - caml_call1(is_empty, token[1]);
    if(_h_){
     if(is_node_valid(token)) remove_non_empty(t, token[1]);
     token[1] = caml_call1(empty, 0);
     var _i_ = 0;
    }
    else
     var _i_ = _h_;
    return _i_;
   }
   function add_removable(t, v){
    var node = add_node(t, v);
    return [0, node, id(node, t[2]), t];
   }
   function update(t, token, v){remove(t, token); return add_removable(t, v);}
   function find_elt(t, f){
    var nodes$2 = [0, t[3], 0], nodes = nodes$2;
    for(;;){
     if(! nodes) return 0;
     var nodes$0 = nodes[2], node = nodes[1];
     if(caml_call1(is_empty, node))
      var nodes = nodes$0;
     else{
      if(caml_call1(f, value_exn(node, t[2])))
       return [0, [0, node, id(node, t[2]), t]];
      var
       _g_ = [0, child(node, t[2]), nodes$0],
       nodes$1 = [0, sibling(node, t[2]), _g_],
       nodes = nodes$1;
     }
    }
   }
   function value(t, heap){return value_exn(t, heap[2]);}
   var Elt = [0, value];
   function update$0(t, elt, v){
    remove_non_empty(t, elt);
    return add_node(t, v);
   }
   var Unsafe = [0, Elt, add_node, remove_non_empty, update$0];
   caml_call1(Ppx_inline_test_lib[7], cst_pairing_heap);
   caml_call1(Ppx_expect_runtime[1][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Pairing_heap);
   var
    Pairing_heap =
      [0,
       sexp_of_t,
       mem,
       length,
       is_empty$0,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       invariant,
       min_elt,
       max_elt,
       create$0,
       of_array,
       of_list,
       top,
       top_exn,
       add,
       remove_top,
       clear,
       pop,
       pop_exn,
       pop_if,
       pop_while,
       copy,
       [0, sexp_of_t$0, value_exn$0],
       add_removable,
       remove,
       update,
       find_elt,
       Unsafe];
   runtime.caml_register_global(26, Pairing_heap, cst_Pairing_heap$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwYWlyaW5nX2hlYXAuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImVtcHR5IiwiaXNfZW1wdHkiLCJlcXVhbCIsImR1bW15X2lkIiwiY2hpbGQiLCJ0IiwicG9vbCIsInNpYmxpbmciLCJwcmV2IiwiaWQiLCJzZXRfY2hpbGQiLCJ2Iiwic2V0X3NpYmxpbmciLCJzZXRfcHJldiIsInZhbHVlX2V4biIsImFsbG9jYXRlIiwidmFsdWUiLCJmcmVlIiwiZGlzY29ubmVjdF9zaWJsaW5nIiwic2libGluZyQwIiwiZGlzY29ubmVjdF9jaGlsZCIsImNoaWxkJDAiLCJkZXRhY2giLCJwcmV2JDAiLCJyZWxhdGlvbl90b19wcmV2IiwiY3JlYXRlIiwiY2FwYWNpdHkiLCJpbnZhcmlhbnQiLCJ0b192aXNpdCQyIiwidG9fdmlzaXQiLCJ0b192aXNpdCQwIiwibWF5YmVfcGFyZW50X3ZhbHVlIiwiZXhwZWN0ZWRfcHJldiIsIm5vZGUiLCJ0aGlzX3ZhbHVlIiwicGFyZW50X3ZhbHVlIiwidG9fdmlzaXQkMSIsImNyZWF0ZSQwIiwib3B0IiwiY21wIiwic3RoIiwibWluX3NpemUiLCJjb3B5IiwicG9vbCQwIiwic3RhcnQiLCJudW1fb2ZfYWxsb2NhdGVkX25vZGVzIiwiY29weV9ub2RlIiwibmV3X25vZGUiLCJuZXdfc3RhcnQiLCJyZXN0Iiwibm9kZV90b19jb3B5Iiwic2xvdCIsIm5vZGVfdG9fdXBkYXRlIiwibWVyZ2UiLCJyb290MSIsInJvb3QyIiwiYWRkX2NoaWxkIiwibmV3X2NoaWxkIiwiY3VycmVudF9jaGlsZCIsInYxIiwidjIiLCJ0b3BfZXhuIiwidG9wIiwiYWRkX25vZGUiLCJ0JDEiLCJ0JDAiLCJhZGQiLCJtYXhfc3RhY2tfZGVwdGgiLCJsb29wIiwiZGVwdGgiLCJoZWFkJDAiLCJuZXh0MSQwIiwibmV4dDIkMCIsImFjYyIsImhlYWQiLCJuZXh0MSIsIm5leHQyIiwiYWNjJDAiLCJoIiwieHMiLCJoZWFwIiwicmVtb3ZlX25vbl9lbXB0eSIsIm1lcmdlZF9jaGlsZHJlbiIsIm5ld19yb290IiwicmVtb3ZlX3RvcCIsImNsZWFyIiwibm9kZSQwIiwicG9wX2V4biIsInIiLCJwb3AiLCJwb3BfaWYiLCJmIiwicG9wX3doaWxlIiwieCIsImZvbGQiLCJpbml0IiwiaXRlciIsImxlbmd0aCIsIml0ZXIkMCIsImxlbmd0aCQwIiwiaXNfZW1wdHkkMCIsIm1lbSIsImV4aXN0cyIsImZvcl9hbGwiLCJjb3VudCIsInN1bSIsImZpbmQiLCJmaW5kX21hcCIsInRvX2xpc3QiLCJ0b19hcnJheSIsIm1pbl9lbHQiLCJtYXhfZWx0IiwiZm9sZF9yZXN1bHQiLCJmb2xkX3VudGlsIiwib2ZfYXJyYXkiLCJhcnIiLCJvZl9saXN0IiwibCIsInNleHBfb2ZfdCIsImlzX25vZGVfdmFsaWQiLCJ2YWx1ZV9leG4kMCIsInNleHBfb2ZfdCQwIiwic2V4cF9vZl9hIiwieF8wMDEiLCJyZW1vdmUiLCJ0b2tlbiIsImFkZF9yZW1vdmFibGUiLCJ1cGRhdGUiLCJmaW5kX2VsdCIsIm5vZGVzJDIiLCJub2RlcyIsIm5vZGVzJDAiLCJub2RlcyQxIiwidXBkYXRlJDAiLCJlbHQiXSwic291cmNlcyI6WyIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvY29yZV9rZXJuZWwvcGFpcmluZ19oZWFwL3BhaXJpbmdfaGVhcC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE4Rk1BO0lBQ0FDO0lBQ0FDOzs7Ozs7Ozs7OztJQVRBQztZQVdBQyxNQUFNQyxHQUFHQztJQUFPLGtDQUFQQSxNQUFIRDtHQUFzQztZQUM1Q0UsUUFBUUYsR0FBR0M7SUFBTyxrQ0FBUEEsTUFBSEQ7R0FBc0M7WUFDOUNHLEtBQUtILEdBQUdDO0lBQU8sa0NBQVBBLE1BQUhEO0dBQXNDO1lBQzNDSSxHQUFHSixHQUFHQztJQUFPLGtDQUFQQSxNQUFIRDtHQUFzQztZQUd6Q0ssVUFBVUws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WUFNRnFILFNBQU9oSSxHQUFFaUksS0FBSTNIO0lBek1mc0UsaUJBeU1TNUUsR0FBRWlJO0lBQ1gsT0F2U0F2RSxTQXNTUzFELEdBQU1NO0dBRUU7R0FiTCxzQkEzUlpvRCxVQTZGQWtCLGtCQXlNRW9EOzs7Ozs7OztPQXZFRmY7T0FyQkFqQjtPQVhBSjtPQVVBRztPQTFCQUo7T0FoQkFGO09Bc0RBa0I7T0FDQUM7T0FYQVg7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0EvUkFsRjtPQWdTQW1GO09BQ0FDO09BNVFBMUU7T0FnUkE2RTtPQU1BRTtPQWhPQXREO09BTkFEO09BY0FLO09Ba0dBa0I7T0FrQkFDO09BYUFJO09BTkFGO09BUUFHO09BV0FFO09BcE1BbEQ7V0FzU0UrRSxhQU5BRDtPQWtCRk07T0FUQUY7T0FjQUc7T0FLQUM7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIENvcmVcbm1vZHVsZSBQb29sID0gVHVwbGVfcG9vbFxubW9kdWxlIFBvaW50ZXIgPSBQb29sLlBvaW50ZXJcblxuKCogVGhpcyBwb29sIGhvbGRzIG5vZGVzIHRoYXQgd291bGQgYmUgcmVwcmVzZW50ZWQgbW9yZSB0cmFkaXRpb25hbGx5IGFzOlxuXG4gICB7W1xuICAgICB0eXBlICdhIHQgPVxuICAgICAgIHwgRW1wdHlcbiAgICAgICB8IEhlYXAgb2YgJ2EgKiAnYSB0IGxpc3QgXX1cblxuICAgV2Ugd2lsbCByZXByZXNlbnQgdGhlbSBhcyBhIGxlZnQtY2hpbGQsIHJpZ2h0LXNpYmxpbmcgdHJlZSBpbiBhIHRyaXBsZXRcbiAgICh2YWx1ZSAqIGxlZnRfY2hpbGQgKiByaWdodF9zaWJsaW5nKS4gIFRoZSBsZWZ0IGNoaWxkIGFuZCBhbGwgcmlnaHQgc2libGluZ3NcbiAgIG9mIHRoZSBsZWZ0IGNoaWxkIGZvcm0gYSBsaW5rZWQgbGlzdCByZXByZXNlbnRpbmcgdGhlIHN1YmhlYXBzIG9mIGEgZ2l2ZW4gaGVhcDpcblxuICAge3ZcbiAgICAgICAgIEFcbiAgICAgICAgL1xuICAgICAgIEIgLT4gQyAtPiBEIC0+IEUgLT4gRlxuICAgICAgLyAgICAgICAgIC8gICAgICAgICAvXG4gICAgIEcgICAgICAgICBILT5JLT5KICAgSy0+TFxuICAgdn0gKilcblxubW9kdWxlIE5vZGUgOiBzaWdcbiAgKCogRXhwb3NpbmcgW3ByaXZhdGUgaW50XSBpcyBhIHNpZ25pZmljYW50IHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LCBiZWNhdXNlIGl0IGFsbG93c1xuICAgICB0aGUgY29tcGlsZXIgdG8gc2tpcCB0aGUgd3JpdGUgYmFycmllci4gKilcblxuICB0eXBlICdhIHQgPSBwcml2YXRlIGludFxuXG4gIG1vZHVsZSBJZCA6IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gICAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgZW5kXG5cbiAgbW9kdWxlIFBvb2wgOiBzaWdcbiAgICB0eXBlICdhIG5vZGUgPSAnYSB0XG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgY3JlYXRlIDogbWluX3NpemU6aW50IC0+ICdhIHRcbiAgICB2YWwgaXNfZnVsbCA6ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICAgIHZhbCBncm93IDogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIG5vZGUgLT4gJ2Egbm9kZSAqICdhIHRcbiAgZW5kXG5cbiAgKCoqIFthbGxvY2F0ZSB2IH5wb29sXSBhbGxvY2F0ZXMgYSBuZXcgbm9kZSBmcm9tIHRoZSBwb29sIHdpdGggbm8gY2hpbGQgb3Igc2libGluZyAqKVxuICB2YWwgYWxsb2NhdGUgOiAnYSAtPiBwb29sOidhIFBvb2wudCAtPiBpZDpJZC50IC0+ICdhIHRcblxuICAoKiogW2ZyZWUgdCB+cG9vbF0gZnJlZXMgW3RdIGZvciByZXVzZS4gIEl0IGlzIGFuIGVycm9yIHRvIGFjY2VzcyBbdF0gYWZ0ZXIgdGhpcy4gKilcbiAgdmFsIGZyZWUgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+IHVuaXRcblxuICAoKiogYSBzcGVjaWFsIFt0XSB0aGF0IHJlcHJlc2VudHMgdGhlIGVtcHR5IG5vZGUgKilcbiAgdmFsIGVtcHR5IDogdW5pdCAtPiAnYSB0XG5cbiAgdmFsIGlzX2VtcHR5IDogJ2EgdCAtPiBib29sXG4gIHZhbCBlcXVhbCA6ICdhIHQgLT4gJ2EgdCAtPiBib29sXG5cbiAgKCoqIFt2YWx1ZV9leG4gdCB+cG9vbF0gcmV0dXJuIHRoZSB2YWx1ZSBvZiBbdF0sIHJhaXNlIGlmIFtpc19lbXB0eSB0XSAqKVxuICB2YWwgdmFsdWVfZXhuIDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiAnYVxuXG4gIHZhbCBpZCA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gSWQudFxuICB2YWwgY2hpbGQgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+ICdhIHRcbiAgdmFsIHNpYmxpbmcgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+ICdhIHRcblxuICAoKiogW3ByZXYgdF0gaXMgZWl0aGVyIHRoZSBwYXJlbnQgb2YgW3RdIG9yIHRoZSBzaWJsaW5nIGltbWVkaWF0ZWx5IGxlZnQgb2YgW3RdICopXG4gIHZhbCBwcmV2IDogJ2EgdCAtPiBwb29sOidhIFBvb2wudCAtPiAnYSB0XG5cbiAgKCoqIFthZGRfY2hpbGQgdCB+Y2hpbGQgfnBvb2xdIEFkZCBhIGNoaWxkIHRvIFt0XSwgcHJlc2VydmluZyBleGlzdGluZyBjaGlsZHJlbiBhc1xuICAgICAgc2libGluZ3Mgb2YgW2NoaWxkXS4gW3RdIGFuZCBbY2hpbGRdIHNob3VsZCBub3QgYmUgZW1wdHkgYW5kIFtjaGlsZF0gc2hvdWxkIGhhdmUgbm9cbiAgICAgIHNpYmxpbmcgYW5kIGhhdmUgbm8gcHJldiBub2RlLiAqKVxuICB2YWwgYWRkX2NoaWxkIDogJ2EgdCAtPiBjaGlsZDonYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+IHVuaXRcblxuICAoKiogZGlzY29ubmVjdCBhbmQgcmV0dXJuIHRoZSBzaWJsaW5nICopXG4gIHZhbCBkaXNjb25uZWN0X3NpYmxpbmcgOiAnYSB0IC0+IHBvb2w6J2EgUG9vbC50IC0+ICdhIHRcblxuICAoKiogZGlzY29ubmVjdCBhbmQgcmV0dXJuIHRoZSBjaGlsZCAqKVxuICB2YWwgZGlzY29ubmVjdF9jaGlsZCA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gJ2EgdFxuXG4gICgqKiBbZGV0YWNoIHQgfnBvb2xdIHJlbW92ZXMgW3RdIGZyb20gdGhlIHRyZWUsIGFkanVzdGluZyBwb2ludGVycyBhcm91bmQgaXQuIEFmdGVyXG4gICAgICBbZGV0YWNoXSwgW3RdIGlzIHRoZSByb290IG9mIGEgc3RhbmRhbG9uZSBoZWFwLCB3aGljaCBpcyBkZXRhY2hlZCBmcm9tIHRoZSBvcmlnaW5hbFxuICAgICAgaGVhcC4gKilcbiAgdmFsIGRldGFjaCA6ICdhIHQgLT4gcG9vbDonYSBQb29sLnQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIG1vZHVsZSBJZCA9IEludFxuXG4gIGxldCBkdW1teV9pZCA6IElkLnQgPSAtMVxuXG4gIHR5cGUgJ2Egbm9kZSA9XG4gICAgKCdhLCAnYSBub2RlIFBvaW50ZXIudCwgJ2Egbm9kZSBQb2ludGVyLnQsICdhIG5vZGUgUG9pbnRlci50LCBJZC50KSBQb29sLlNsb3RzLnQ1XG5cbiAgdHlwZSAnYSB0ID0gJ2Egbm9kZSBQb2ludGVyLnRcblxuICBsZXQgZW1wdHkgPSBQb2ludGVyLm51bGxcbiAgbGV0IGlzX2VtcHR5ID0gUG9pbnRlci5pc19udWxsXG4gIGxldCBlcXVhbCA9IFBvaW50ZXIucGh5c19lcXVhbFxuICBsZXQgdmFsdWUgdCB+cG9vbCA9IFBvb2wuZ2V0IHBvb2wgdCBQb29sLlNsb3QudDBcbiAgbGV0IGNoaWxkIHQgfnBvb2wgPSBQb29sLmdldCBwb29sIHQgUG9vbC5TbG90LnQxXG4gIGxldCBzaWJsaW5nIHQgfnBvb2wgPSBQb29sLmdldCBwb29sIHQgUG9vbC5TbG90LnQyXG4gIGxldCBwcmV2IHQgfnBvb2wgPSBQb29sLmdldCBwb29sIHQgUG9vbC5TbG90LnQzXG4gIGxldCBpZCB0IH5wb29sID0gUG9vbC5nZXQgcG9vbCB0IFBvb2wuU2xvdC50NFxuXG4gICgqIGxldCBzZXRfdmFsdWUgICB0IHYgfnBvb2wgPSBQb29sLnNldCBwb29sIHQgUG9vbC5TbG90LnQwIHYgKilcbiAgbGV0IHNldF9jaGlsZCB0IHYgfnBvb2wgPSBQb29sLnNldCBwb29sIHQgUG9vbC5TbG90LnQxIHZcbiAgbGV0IHNldF9zaWJsaW5nIHQgdiB+cG9vbCA9IFBvb2wuc2V0IHBvb2wgdCBQb29sLlNsb3QudDIgdlxuICBsZXQgc2V0X3ByZXYgdCB2IH5wb29sID0gUG9vbC5zZXQgcG9vbCB0IFBvb2wuU2xvdC50MyB2XG5cbiAgbGV0IHZhbHVlX2V4biB0IH5wb29sID1cbiAgICBhc3NlcnQgKG5vdCAoaXNfZW1wdHkgdCkpO1xuICAgIHZhbHVlIHQgfnBvb2xcbiAgOztcblxuICBsZXQgYWxsb2NhdGUgdmFsdWUgfnBvb2wgfmlkID0gUG9vbC5uZXc1IHBvb2wgdmFsdWUgKGVtcHR5ICgpKSAoZW1wdHkgKCkpIChlbXB0eSAoKSkgaWRcbiAgbGV0IGZyZWUgdCB+cG9vbCA9IFBvb2wudW5zYWZlX2ZyZWUgcG9vbCB0XG5cbiAgbGV0IGRpc2Nvbm5lY3Rfc2libGluZyB0IH5wb29sID1cbiAgICBsZXQgc2libGluZyA9IHNpYmxpbmcgdCB+cG9vbCBpblxuICAgIGlmIG5vdCAoaXNfZW1wdHkgc2libGluZylcbiAgICB0aGVuIChcbiAgICAgIHNldF9zaWJsaW5nIHQgKGVtcHR5ICgpKSB+cG9vbDtcbiAgICAgIHNldF9wcmV2IHNpYmxpbmcgKGVtcHR5ICgpKSB+cG9vbCk7XG4gICAgc2libGluZ1xuICA7O1xuXG4gIGxldCBkaXNjb25uZWN0X2NoaWxkIHQgfnBvb2wgPVxuICAgIGxldCBjaGlsZCA9IGNoaWxkIHQgfnBvb2wgaW5cbiAgICBpZiBub3QgKGlzX2VtcHR5IGNoaWxkKVxuICAgIHRoZW4gKFxuICAgICAgc2V0X2NoaWxkIHQgKGVtcHR5ICgpKSB+cG9vbDtcbiAgICAgIHNldF9wcmV2IGNoaWxkIChlbXB0eSAoKSkgfnBvb2wpO1xuICAgIGNoaWxkXG4gIDs7XG5cbiAgbGV0IGFkZF9jaGlsZCB0IH5jaGlsZDpuZXdfY2hpbGQgfnBvb2wgPVxuICAgICgqIGFzc2VydGlvbnMgd2Ugd291bGQgbWFrZSwgYnV0IGZvciBzcGVlZDpcbiAgICAgICBhc3NlcnQgKG5vdCAoaXNfZW1wdHkgdCkpO1xuICAgICAgIGFzc2VydCAobm90IChpc19lbXB0eSBuZXdfY2hpbGQpKTtcbiAgICAgICBhc3NlcnQgKGlzX2VtcHR5IChzaWJsaW5nIG5ld19jaGlsZCB+cG9vbCkpO1xuICAgICAgIGFzc2VydCAoaXNfZW1wdHkgKHByZXYgbmV3X2NoaWxkIH5wb29sKSk7XG4gICAgKilcbiAgICBsZXQgY3VycmVudF9jaGlsZCA9IGRpc2Nvbm5lY3RfY2hpbGQgdCB+cG9vbCBpblxuICAgICgqIGFkZCBbbmV3X2NoaWxkXSB0byB0aGUgbGlzdCBvZiBbdF0ncyBjaGlsZHJlbiAod2hpY2ggbWF5IGJlIGVtcHR5KSAqKVxuICAgIHNldF9zaWJsaW5nIG5ld19jaGlsZCBjdXJyZW50X2NoaWxkIH5wb29sO1xuICAgIGlmIG5vdCAoaXNfZW1wdHkgY3VycmVudF9jaGlsZCkgdGhlbiBzZXRfcHJldiBjdXJyZW50X2NoaWxkIG5ld19jaGlsZCB+cG9vbDtcbiAgICBzZXRfY2hpbGQgdCBuZXdfY2hpbGQgfnBvb2w7XG4gICAgc2V0X3ByZXYgbmV3X2NoaWxkIHQgfnBvb2xcbiAgOztcblxuICBsZXQgZGV0YWNoIHQgfnBvb2wgPVxuICAgIGlmIG5vdCAoaXNfZW1wdHkgdClcbiAgICB0aGVuIChcbiAgICAgIGxldCBwcmV2ID0gcHJldiB0IH5wb29sIGluXG4gICAgICBpZiBub3QgKGlzX2VtcHR5IHByZXYpXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IHJlbGF0aW9uX3RvX3ByZXYgPSBpZiBlcXVhbCB0IChjaGlsZCBwcmV2IH5wb29sKSB0aGVuIGBjaGlsZCBlbHNlIGBzaWJsaW5nIGluXG4gICAgICAgIHNldF9wcmV2IHQgKGVtcHR5ICgpKSB+cG9vbDtcbiAgICAgICAgbGV0IHNpYmxpbmcgPSBkaXNjb25uZWN0X3NpYmxpbmcgdCB+cG9vbCBpblxuICAgICAgICAobWF0Y2ggcmVsYXRpb25fdG9fcHJldiB3aXRoXG4gICAgICAgICB8IGBjaGlsZCAtPiBzZXRfY2hpbGQgcHJldiBzaWJsaW5nIH5wb29sXG4gICAgICAgICB8IGBzaWJsaW5nIC0+IHNldF9zaWJsaW5nIHByZXYgc2libGluZyB+cG9vbCk7XG4gICAgICAgIGlmIG5vdCAoaXNfZW1wdHkgc2libGluZykgdGhlbiBzZXRfcHJldiBzaWJsaW5nIHByZXYgfnBvb2wpKVxuICA7O1xuXG4gIG1vZHVsZSBQb29sID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2Egbm9kZSBQb29sLnRcbiAgICB0eXBlIG5vbnJlYyAnYSBub2RlID0gJ2Egbm9kZSBQb2ludGVyLnRcblxuICAgIGxldCBjcmVhdGUgKHR5cGUgYSkgfm1pbl9zaXplOmNhcGFjaXR5IDogYSB0ID1cbiAgICAgIFBvb2wuY3JlYXRlXG4gICAgICAgIFBvb2wuU2xvdHMudDVcbiAgICAgICAgfmNhcGFjaXR5XG4gICAgICAgIH5kdW1teTpcbiAgICAgICAgICAoIChPYmoubWFnaWMgTm9uZSA6IGEpXG4gICAgICAgICAgLCBQb2ludGVyLm51bGwgKClcbiAgICAgICAgICAsIFBvaW50ZXIubnVsbCAoKVxuICAgICAgICAgICwgUG9pbnRlci5udWxsICgpXG4gICAgICAgICAgLCBkdW1teV9pZCApXG4gICAgOztcblxuICAgIGxldCBpc19mdWxsIHQgPSBQb29sLmlzX2Z1bGwgdFxuICAgIGxldCBsZW5ndGggdCA9IFBvb2wubGVuZ3RoIHRcbiAgICBsZXQgZ3JvdyB0ID0gUG9vbC5ncm93IHRcblxuICAgIGxldCBjb3B5IHQgc3RhcnQgPVxuICAgICAgbGV0IHQnID0gY3JlYXRlIH5taW5fc2l6ZTooUG9vbC5jYXBhY2l0eSB0KSBpblxuICAgICAgbGV0IGNvcHlfbm9kZSBub2RlIHRvX3Zpc2l0ID1cbiAgICAgICAgaWYgaXNfZW1wdHkgbm9kZVxuICAgICAgICB0aGVuIGVtcHR5ICgpLCB0b192aXNpdFxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiB3ZSB1c2UgdGhlIHNhbWUgaWQsIGJ1dCB0aGF0J3Mgb2sgc2luY2UgaWRzIHNob3VsZCBiZSB1bmlxdWUgcGVyIGhlYXAgKilcbiAgICAgICAgICBsZXQgbmV3X25vZGUgPVxuICAgICAgICAgICAgYWxsb2NhdGUgKHZhbHVlX2V4biBub2RlIH5wb29sOnQpIH5wb29sOnQnIH5pZDooaWQgbm9kZSB+cG9vbDp0KVxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IHRvX3Zpc2l0ID1cbiAgICAgICAgICAgIChuZXdfbm9kZSwgYGNoaWxkLCBjaGlsZCBub2RlIH5wb29sOnQpXG4gICAgICAgICAgICA6OiAobmV3X25vZGUsIGBzaWJsaW5nLCBzaWJsaW5nIG5vZGUgfnBvb2w6dClcbiAgICAgICAgICAgIDo6IHRvX3Zpc2l0XG4gICAgICAgICAgaW5cbiAgICAgICAgICBuZXdfbm9kZSwgdG9fdmlzaXQpXG4gICAgICBpblxuICAgICAgbGV0IHJlYyBsb29wIHRvX3Zpc2l0ID1cbiAgICAgICAgbWF0Y2ggdG9fdmlzaXQgd2l0aFxuICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgIHwgKG5vZGVfdG9fdXBkYXRlLCBzbG90LCBub2RlX3RvX2NvcHkpIDo6IHJlc3QgLT5cbiAgICAgICAgICBsZXQgbmV3X25vZGUsIHRvX3Zpc2l0ID0gY29weV9ub2RlIG5vZGVfdG9fY29weSByZXN0IGluXG4gICAgICAgICAgKG1hdGNoIHNsb3Qgd2l0aFxuICAgICAgICAgICB8IGBjaGlsZCAtPiBzZXRfY2hpbGQgbm9kZV90b191cGRhdGUgbmV3X25vZGUgfnBvb2w6dCdcbiAgICAgICAgICAgfCBgc2libGluZyAtPiBzZXRfc2libGluZyBub2RlX3RvX3VwZGF0ZSBuZXdfbm9kZSB+cG9vbDp0Jyk7XG4gICAgICAgICAgaWYgbm90IChpc19lbXB0eSBuZXdfbm9kZSkgdGhlbiBzZXRfcHJldiBuZXdfbm9kZSBub2RlX3RvX3VwZGF0ZSB+cG9vbDp0JztcbiAgICAgICAgICBsb29wIHRvX3Zpc2l0XG4gICAgICBpblxuICAgICAgbGV0IG5ld19zdGFydCwgdG9fdmlzaXQgPSBjb3B5X25vZGUgc3RhcnQgW10gaW5cbiAgICAgIGxvb3AgdG9fdmlzaXQ7XG4gICAgICBuZXdfc3RhcnQsIHQnXG4gICAgOztcbiAgZW5kXG5lbmRcblxudHlwZSAnYSB0ID1cbiAgeyAoKiBjbXAgaXMgcGxhY2VkIGZpcnN0IHRvIHNob3J0LWNpcmN1aXQgcG9seW1vcnBoaWMgY29tcGFyZSAqKVxuICAgIGNtcCA6ICdhIC0+ICdhIC0+IGludFxuICA7IG11dGFibGUgcG9vbCA6ICdhIE5vZGUuUG9vbC50XG4gIDsgKCogaW52YXJpYW50OiAgW3Jvb3RdIG5ldmVyIGhhcyBhIHNpYmxpbmcgKilcbiAgICBtdXRhYmxlIHJvb3QgOiAnYSBOb2RlLnRcbiAgOyBtdXRhYmxlIG51bV9vZl9hbGxvY2F0ZWRfbm9kZXMgOiBpbnRcbiAgfVxuXG5sZXQgaW52YXJpYW50IF8gdCA9XG4gIGxldCByZWMgbG9vcCB0b192aXNpdCA9XG4gICAgbWF0Y2ggdG9fdmlzaXQgd2l0aFxuICAgIHwgW10gLT4gKClcbiAgICB8IChub2RlLCBleHBlY3RlZF9wcmV2LCBtYXliZV9wYXJlbnRfdmFsdWUpIDo6IHJlc3QgLT5cbiAgICAgIGlmIG5vdCAoTm9kZS5pc19lbXB0eSBub2RlKVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0aGlzX3ZhbHVlID0gTm9kZS52YWx1ZV9leG4gbm9kZSB+cG9vbDp0LnBvb2wgaW5cbiAgICAgICAgYXNzZXJ0IChOb2RlLmVxdWFsIChOb2RlLnByZXYgbm9kZSB+cG9vbDp0LnBvb2wpIGV4cGVjdGVkX3ByZXYpO1xuICAgICAgICBPcHRpb24uaXRlciBtYXliZV9wYXJlbnRfdmFsdWUgfmY6KGZ1biBwYXJlbnRfdmFsdWUgLT5cbiAgICAgICAgICBhc3NlcnQgKHQuY21wIHBhcmVudF92YWx1ZSB0aGlzX3ZhbHVlIDw9IDApKTtcbiAgICAgICAgbG9vcFxuICAgICAgICAgICgoTm9kZS5jaGlsZCBub2RlIH5wb29sOnQucG9vbCwgbm9kZSwgU29tZSB0aGlzX3ZhbHVlKVxuICAgICAgICAgICA6OiAoTm9kZS5zaWJsaW5nIG5vZGUgfnBvb2w6dC5wb29sLCBub2RlLCBtYXliZV9wYXJlbnRfdmFsdWUpXG4gICAgICAgICAgIDo6IHJlc3QpKVxuICAgICAgZWxzZSBsb29wIHJlc3RcbiAgaW5cbiAgYXNzZXJ0IChOb2RlLmlzX2VtcHR5IHQucm9vdCB8fCBOb2RlLmlzX2VtcHR5IChOb2RlLnNpYmxpbmcgdC5yb290IH5wb29sOnQucG9vbCkpO1xuICBsb29wIFsgdC5yb290LCBOb2RlLmVtcHR5ICgpLCBOb25lIF1cbjs7XG5cbmxldCBjcmVhdGUgPyhtaW5fc2l6ZSA9IDEpIH5jbXAgKCkgPVxuICB7IGNtcFxuICA7IHBvb2wgPSBOb2RlLlBvb2wuY3JlYXRlIH5taW5fc2l6ZVxuICA7IHJvb3QgPSBOb2RlLmVtcHR5ICgpXG4gIDsgbnVtX29mX2FsbG9jYXRlZF9ub2RlcyA9IDBcbiAgfVxuOztcblxubGV0IGNvcHkgeyBjbXA7IHBvb2w7IHJvb3Q7IG51bV9vZl9hbGxvY2F0ZWRfbm9kZXMgfSA9XG4gIGxldCByb290LCBwb29sID0gTm9kZS5Qb29sLmNvcHkgcG9vbCByb290IGluXG4gIHsgY21wOyBwb29sOyByb290OyBudW1fb2ZfYWxsb2NhdGVkX25vZGVzIH1cbjs7XG5cbmxldCBhbGxvY2F0ZSB0IHYgPVxuICBpZiBOb2RlLlBvb2wuaXNfZnVsbCB0LnBvb2wgdGhlbiB0LnBvb2wgPC0gTm9kZS5Qb29sLmdyb3cgdC5wb29sO1xuICB0Lm51bV9vZl9hbGxvY2F0ZWRfbm9kZXMgPC0gdC5udW1fb2ZfYWxsb2NhdGVkX25vZGVzICsgMTtcbiAgTm9kZS5hbGxvY2F0ZSB2IH5wb29sOnQucG9vbCB+aWQ6KE5vZGUuSWQub2ZfaW50IHQubnVtX29mX2FsbG9jYXRlZF9ub2Rlcylcbjs7XG5cbigqIHRyYW5zbGF0aW9uOlxuICAge1tcbiAgICAgbWF0Y2ggcm9vdDEsIHJvb3QyIHdpdGhcbiAgICAgfCBOb25lLCBoIHwgaCwgTm9uZSAtPiBoXG4gICAgIHwgU29tZSAoTm9kZSAodjEsIGNoaWxkcmVuMSkpLCBTb21lIChOb2RlICh2MiwgY2hpbGRyZW4yKSkgLT5cbiAgICAgICBpZiB2MSA8IHYyXG4gICAgICAgdGhlbiBTb21lIChOb2RlICh2MSwgcm9vdDIgOjogY2hpbGRyZW4xKSlcbiAgICAgICBlbHNlIFNvbWUgKE5vZGUgKHYyLCByb290MSA6OiBjaGlsZHJlbjIpKVxuICAgXX1cblxuICAgVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG5laXRoZXIgcm9vdCBoYXMgYSBwcmV2IG5vZGUgKHVzdWFsbHkgYmVjYXVzZSB0aGUgaW5wdXRzIGNvbWVcbiAgIGZyb20gW2Rpc2Nvbm5lY3RfKl0gb3IgYXJlIHRoZSB0b3Agb2YgdGhlIGhlYXAgb3IgYXJlIHRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbikuICopXG5sZXQgbWVyZ2UgdCByb290MSByb290MiA9XG4gIGlmIE5vZGUuaXNfZW1wdHkgcm9vdDFcbiAgdGhlbiByb290MlxuICBlbHNlIGlmIE5vZGUuaXNfZW1wdHkgcm9vdDJcbiAgdGhlbiByb290MVxuICBlbHNlIChcbiAgICBsZXQgYWRkX2NoaWxkIHQgbm9kZSB+Y2hpbGQgPVxuICAgICAgTm9kZS5hZGRfY2hpbGQgbm9kZSB+cG9vbDp0LnBvb2wgfmNoaWxkO1xuICAgICAgbm9kZVxuICAgIGluXG4gICAgbGV0IHYxID0gTm9kZS52YWx1ZV9leG4gcm9vdDEgfnBvb2w6dC5wb29sIGluXG4gICAgbGV0IHYyID0gTm9kZS52YWx1ZV9leG4gcm9vdDIgfnBvb2w6dC5wb29sIGluXG4gICAgaWYgdC5jbXAgdjEgdjIgPCAwXG4gICAgdGhlbiBhZGRfY2hpbGQgdCByb290MSB+Y2hpbGQ6cm9vdDJcbiAgICBlbHNlIGFkZF9jaGlsZCB0IHJvb3QyIH5jaGlsZDpyb290MSlcbjs7XG5cbmxldCB0b3BfZXhuIHQgPVxuICBpZiBOb2RlLmlzX2VtcHR5IHQucm9vdFxuICB0aGVuIGZhaWx3aXRoIFwiSGVhcC50b3BfZXhuIGNhbGxlZCBvbiBhbiBlbXB0eSBoZWFwXCJcbiAgZWxzZSBOb2RlLnZhbHVlX2V4biB0LnJvb3QgfnBvb2w6dC5wb29sXG47O1xuXG5sZXQgdG9wIHQgPSBpZiBOb2RlLmlzX2VtcHR5IHQucm9vdCB0aGVuIE5vbmUgZWxzZSBTb21lICh0b3BfZXhuIHQpXG5cbmxldCBhZGRfbm9kZSB0IHYgPVxuICBsZXQgbm9kZSA9IGFsbG9jYXRlIHQgdiBpblxuICB0LnJvb3QgPC0gbWVyZ2UgdCB0LnJvb3Qgbm9kZTtcbiAgbm9kZVxuOztcblxubGV0IGFkZCB0IHYgPSBpZ25vcmUgKGFkZF9ub2RlIHQgdiA6IF8gTm9kZS50KVxuXG4oKiBbbWVyZ2VfcGFpcnNdIHRha2VzIGEgbGlzdCBvZiBoZWFwIHJvb3RzIGFuZCBtZXJnZXMgY29uc2VjdXRpdmUgcGFpcnMsIHJlZHVjaW5nIHRoZVxuICAgbGlzdCBvZiBsZW5ndGggbiB0byBuLzIuICBUaGVuIGl0IG1lcmdlcyB0aGUgbWVyZ2VkIHBhaXJzIGludG8gYSBzaW5nbGUgaGVhcC4gIE9uZVxuICAgaW50dWl0aW9uIGlzIHRoYXQgdGhpcyBpcyBzb21ld2hhdCBsaWtlIGJ1aWxkaW5nIGEgc2luZ2xlIGxldmVsIG9mIGEgYmluYXJ5IHRyZWUuXG5cbiAgIFRoZSBvdXRwdXQgaGVhcCBkb2VzIG5vdCBjb250YWluIHRoZSB2YWx1ZSB0aGF0IHdhcyBhdCB0aGUgcm9vdCBvZiB0aGUgaW5wdXQgaGVhcC5cblxuICAgV2UgYnJlYWsgdGhlIGZ1bmN0aW9uIGludG8gdHdvIHBhcnRzLiAgQSBmaXJzdCBzdGFnZSB0aGF0IGlzIHdpbGxpbmcgdG8gdXNlIGxpbWl0ZWRcbiAgIHN0YWNrIGluc3RlYWQgb2YgaGVhcCBhbGxvY2F0aW9uIGZvciBib29ra2VlcGluZywgYW5kIGEgc2Vjb25kIHN0YWdlIHRoYXQgc2hpZnRzIHRvXG4gICB1c2luZyBhIGxpc3QgYXMgYW4gYWNjdW11bGF0b3IgaWYgd2UgZ28gdG9vIGRlZXAuXG5cbiAgIFRoaXMgY2FuIGJlIG1hZGUgdGFpbCByZWN1cnNpdmUgYW5kIG5vbi1hbGxvY2F0aW5nIGJ5IHN0YXJ0aW5nIHdpdGggYW4gZW1wdHkgaGVhcCBhbmRcbiAgIG1lcmdpbmcgbWVyZ2VkIHBhaXJzIGludG8gaXQuIFVuZm9ydHVuYXRlbHkgdGhpcyBcImxlZnQgZm9sZFwiIHZlcnNpb24gaXMgbm90IHdoYXQgaXNcbiAgIGRlc2NyaWJlZCBpbiB0aGUgb3JpZ2luYWwgcGFwZXIgYnkgRnJlZG1hbiBldCBhbC47IHRoZXkgc3BlY2lmaWNhbGx5IHNheSB0aGF0XG4gICBjaGlsZHJlbiBzaG91bGQgYmUgbWVyZ2VkIHRvZ2V0aGVyIGZyb20gdGhlIGVuZCBvZiB0aGUgbGlzdCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuICAgbGlzdC4gKFttZXJnZV0gaXMgbm90IGFzc29jaWF0aXZlLCBzbyBvcmRlciBtYXR0ZXJzLilcbiopXG4oKiB0cmFuc2xhdGlvbjpcbiAgIHtbXG4gICAgIGxldCByZWMgbG9vcCBhY2MgPSBmdW5jdGlvblxuICAgICAgIHwgW10gLT4gYWNjXG4gICAgICAgfCBbaGVhZF0gLT4gaGVhZCA6OiBhY2NcbiAgICAgICB8IGhlYWQgOjogbmV4dDEgOjogbmV4dDIgLT4gbG9vcCAobWVyZ2UgaGVhZCBuZXh0MSA6OiBhY2MpIG5leHQyXG4gICAgIGluXG4gICAgIG1hdGNoIGxvb3AgW10gY2hpbGRyZW4gd2l0aFxuICAgICB8IFtdIC0+IE5vbmVcbiAgICAgfCBbaF0gLT4gU29tZSBoXG4gICAgIHwgeCA6OiB4cyAtPiBTb21lIChMaXN0LmZvbGQgeHMgfmluaXQ6eCB+ZjptZXJnZSlcbiAgIF19XG4qKVxubGV0IGFsbG9jYXRpbmdfbWVyZ2VfcGFpcnMgdCBoZWFkID1cbiAgbGV0IHJlYyBsb29wIGFjYyBoZWFkID1cbiAgICBpZiBOb2RlLmlzX2VtcHR5IGhlYWRcbiAgICB0aGVuIGFjY1xuICAgIGVsc2UgKFxuICAgICAgbGV0IG5leHQxID0gTm9kZS5kaXNjb25uZWN0X3NpYmxpbmcgaGVhZCB+cG9vbDp0LnBvb2wgaW5cbiAgICAgIGlmIE5vZGUuaXNfZW1wdHkgbmV4dDFcbiAgICAgIHRoZW4gaGVhZCA6OiBhY2NcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbmV4dDIgPSBOb2RlLmRpc2Nvbm5lY3Rfc2libGluZyBuZXh0MSB+cG9vbDp0LnBvb2wgaW5cbiAgICAgICAgbG9vcCAobWVyZ2UgdCBoZWFkIG5leHQxIDo6IGFjYykgbmV4dDIpKVxuICBpblxuICBtYXRjaCBsb29wIFtdIGhlYWQgd2l0aFxuICB8IFtdIC0+IE5vZGUuZW1wdHkgKClcbiAgfCBbIGggXSAtPiBoXG4gIHwgeCA6OiB4cyAtPiBMaXN0LmZvbGQgeHMgfmluaXQ6eCB+ZjooZnVuIGFjYyBoZWFwIC0+IG1lcmdlIHQgYWNjIGhlYXApXG47O1xuXG4oKiB0cmFuc2xhdGlvbjpcbiAgIHtbXG4gICAgIG1hdGNoIHQucm9vdCB3aXRoXG4gICAgIHwgTm9kZSAoXywgY2hpbGRyZW4pIC0+XG4gICAgICAgbGV0IHJlYyBsb29wIGRlcHRoIGNoaWxkcmVuID1cbiAgICAgICAgIGlmIGRlcHRoID49IG1heF9zdGFja19kZXB0aFxuICAgICAgICAgdGhlbiBhbGxvY2F0aW5nX21lcmdlX3BhaXJzIHQgY2hpbGRlblxuICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICBtYXRjaCBjaGlsZHJlbiB3aXRoXG4gICAgICAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgICAgICB8IFtoZWFkXSAtPiBTb21lIGhlYWRcbiAgICAgICAgICAgfCBoZWFkIDo6IG5leHQxIDo6IG5leHQyIC0+XG4gICAgICAgICAgICAgbWVyZ2UgKG1lcmdlIGhlYWQgbmV4dDEpIChsb29wIChkZXB0aCArIDEpIG5leHQyKVxuICAgICAgICAgZW5kXG4gICAgICAgaW5cbiAgICAgICBsb29wIDAgY2hpbGRyZW5cbiAgIF19XG4qKVxubGV0IG1lcmdlX3BhaXJzID1cbiAgbGV0IG1heF9zdGFja19kZXB0aCA9IDFfMDAwIGluXG4gIGxldCByZWMgbG9vcCB0IGRlcHRoIGhlYWQgPVxuICAgIGlmIGRlcHRoID49IG1heF9zdGFja19kZXB0aFxuICAgIHRoZW4gYWxsb2NhdGluZ19tZXJnZV9wYWlycyB0IGhlYWRcbiAgICBlbHNlIGlmIE5vZGUuaXNfZW1wdHkgaGVhZFxuICAgIHRoZW4gaGVhZFxuICAgIGVsc2UgKFxuICAgICAgbGV0IG5leHQxID0gTm9kZS5kaXNjb25uZWN0X3NpYmxpbmcgaGVhZCB+cG9vbDp0LnBvb2wgaW5cbiAgICAgIGlmIE5vZGUuaXNfZW1wdHkgbmV4dDFcbiAgICAgIHRoZW4gaGVhZFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBuZXh0MiA9IE5vZGUuZGlzY29ubmVjdF9zaWJsaW5nIG5leHQxIH5wb29sOnQucG9vbCBpblxuICAgICAgICAoKiBtZXJnZSB0aGUgZmlyc3QgdHdvIG5vZGVzIGluIG91ciBsaXN0LCBhbmQgdGhlbiBtZXJnZSB0aGUgcmVzdWx0IHdpdGggdGhlXG4gICAgICAgICAgIHJlc3VsdCBvZiByZWN1cnNpdmVseSBjYWxsaW5nIG1lcmdlX3BhaXJzIG9uIHRoZSB0YWlsICopXG4gICAgICAgIG1lcmdlIHQgKG1lcmdlIHQgaGVhZCBuZXh0MSkgKGxvb3AgdCAoZGVwdGggKyAxKSBuZXh0MikpKVxuICBpblxuICBmdW4gdCBoZWFkIC0+IGxvb3AgdCAwIGhlYWRcbjs7XG5cbmxldCByZW1vdmVfbm9uX2VtcHR5IHQgbm9kZSA9XG4gIGxldCBwb29sID0gdC5wb29sIGluXG4gIE5vZGUuZGV0YWNoIG5vZGUgfnBvb2w7XG4gIGxldCBtZXJnZWRfY2hpbGRyZW4gPSBtZXJnZV9wYWlycyB0IChOb2RlLmRpc2Nvbm5lY3RfY2hpbGQgbm9kZSB+cG9vbCkgaW5cbiAgbGV0IG5ld19yb290ID1cbiAgICBpZiBOb2RlLmVxdWFsIHQucm9vdCBub2RlIHRoZW4gbWVyZ2VkX2NoaWxkcmVuIGVsc2UgbWVyZ2UgdCB0LnJvb3QgbWVyZ2VkX2NoaWxkcmVuXG4gIGluXG4gIE5vZGUuZnJlZSBub2RlIH5wb29sO1xuICB0LnJvb3QgPC0gbmV3X3Jvb3Rcbjs7XG5cbmxldCByZW1vdmVfdG9wIHQgPSBpZiBub3QgKE5vZGUuaXNfZW1wdHkgdC5yb290KSB0aGVuIHJlbW92ZV9ub25fZW1wdHkgdCB0LnJvb3RcblxuKCogTm90ZSB0aGF0IHRoaXMgaXMgdGFpbC1yZWN1cnNpdmUgYW5kIHRoYXQgZWFjaCBub2RlIGlzIHZpc2l0ZWQgYXQgbW9zdCAzIHRpbWVzIChvbmNlXG4gICBmb3IgZWFjaCBicmFuY2ggb2YgdGhlIFwiaWZcIiksIHNvIGl0IHRha2VzIGxpbmVhciB0aW1lIGFuZCBjb25zdGFudCBzcGFjZS4gKilcbmxldCByZWMgcmVtb3ZlX2FsbF9ub2Rlc19ub25fZW1wdHkgbm9kZSB+cG9vbCA9XG4gIGxldCBjaGlsZCA9IE5vZGUuY2hpbGQgbm9kZSB+cG9vbCBpblxuICBsZXQgc2libGluZyA9IE5vZGUuc2libGluZyBub2RlIH5wb29sIGluXG4gIGlmIG5vdCAoTm9kZS5pc19lbXB0eSBjaGlsZClcbiAgdGhlbiByZW1vdmVfYWxsX25vZGVzX25vbl9lbXB0eSBjaGlsZCB+cG9vbFxuICBlbHNlIGlmIG5vdCAoTm9kZS5pc19lbXB0eSBzaWJsaW5nKVxuICB0aGVuIHJlbW92ZV9hbGxfbm9kZXNfbm9uX2VtcHR5IHNpYmxpbmcgfnBvb2xcbiAgZWxzZSAoXG4gICAgbGV0IHByZXYgPSBOb2RlLnByZXYgbm9kZSB+cG9vbCBpblxuICAgIE5vZGUuZGV0YWNoIG5vZGUgfnBvb2w7XG4gICAgTm9kZS5mcmVlIG5vZGUgfnBvb2w7XG4gICAgaWYgbm90IChOb2RlLmlzX2VtcHR5IHByZXYpIHRoZW4gcmVtb3ZlX2FsbF9ub2Rlc19ub25fZW1wdHkgcHJldiB+cG9vbClcbjs7XG5cbmxldCBjbGVhciB0ID1cbiAgaWYgbm90IChOb2RlLmlzX2VtcHR5IHQucm9vdClcbiAgdGhlbiAoXG4gICAgcmVtb3ZlX2FsbF9ub2Rlc19ub25fZW1wdHkgdC5yb290IH5wb29sOnQucG9vbDtcbiAgICB0LnJvb3QgPC0gTm9kZS5lbXB0eSAoKSlcbjs7XG5cbmxldCBwb3BfZXhuIHQgPVxuICBsZXQgciA9IHRvcF9leG4gdCBpblxuICByZW1vdmVfdG9wIHQ7XG4gIHJcbjs7XG5cbmxldCBwb3AgdCA9IGlmIE5vZGUuaXNfZW1wdHkgdC5yb290IHRoZW4gTm9uZSBlbHNlIFNvbWUgKHBvcF9leG4gdClcblxubGV0IHBvcF9pZiB0IGYgPVxuICBtYXRjaCB0b3AgdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSB2IC0+XG4gICAgaWYgZiB2XG4gICAgdGhlbiAoXG4gICAgICByZW1vdmVfdG9wIHQ7XG4gICAgICBTb21lIHYpXG4gICAgZWxzZSBOb25lXG47O1xuXG5sZXQgcG9wX3doaWxlIHQgZiA9XG4gIGxldCByZWMgbG9vcCB0IGYgYWNjID1cbiAgICBtYXRjaCBwb3BfaWYgdCBmIHdpdGhcbiAgICB8IE5vbmUgLT4gTGlzdC5yZXYgYWNjXG4gICAgfCBTb21lIHggLT4gbG9vcCB0IGYgKHggOjogYWNjKVxuICBpblxuICBsb29wIHQgZiBbXVxuOztcblxuKCogcGFpcmluZyBoZWFwcyBhcmUgbm90IGJhbGFuY2VkIHRyZWVzLCBhbmQgdGhlcmVmb3JlIHdlIGNhbid0IHJlbHkgb24gYSBiYWxhbmNlXG4gICBwcm9wZXJ0eSB0byBzdG9wIG91cnNlbHZlcyBmcm9tIG92ZXJmbG93aW5nIHRoZSBzdGFjay4gKilcbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICBsZXQgcmVjIGxvb3AgYWNjIHRvX3Zpc2l0ID1cbiAgICBtYXRjaCB0b192aXNpdCB3aXRoXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IG5vZGUgOjogcmVzdCAtPlxuICAgICAgaWYgTm9kZS5pc19lbXB0eSBub2RlXG4gICAgICB0aGVuIGxvb3AgYWNjIHJlc3RcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgdG9fdmlzaXQgPSBOb2RlLnNpYmxpbmcgfnBvb2wgbm9kZSA6OiBOb2RlLmNoaWxkIH5wb29sIG5vZGUgOjogcmVzdCBpblxuICAgICAgICBsb29wIChmIGFjYyAoTm9kZS52YWx1ZV9leG4gfnBvb2wgbm9kZSkpIHRvX3Zpc2l0KVxuICBpblxuICBsb29wIGluaXQgWyB0LnJvb3QgXSBbQG5vbnRhaWxdXG47O1xuXG4oKiBhbG1vc3QgaWRlbnRpY2FsIHRvIGZvbGQsIGNvcGllZCBmb3Igc3BlZWQgcHVycG9zZXMgKilcbmxldCBpdGVyIHQgfmYgPVxuICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICBsZXQgcmVjIGxvb3AgdG9fdmlzaXQgPVxuICAgIG1hdGNoIHRvX3Zpc2l0IHdpdGhcbiAgICB8IFtdIC0+ICgpXG4gICAgfCBub2RlIDo6IHJlc3QgLT5cbiAgICAgIGlmIE5vZGUuaXNfZW1wdHkgbm9kZVxuICAgICAgdGhlbiBsb29wIHJlc3RcbiAgICAgIGVsc2UgKFxuICAgICAgICBmIChOb2RlLnZhbHVlX2V4biB+cG9vbCBub2RlKTtcbiAgICAgICAgbGV0IHRvX3Zpc2l0ID0gTm9kZS5zaWJsaW5nIH5wb29sIG5vZGUgOjogTm9kZS5jaGlsZCB+cG9vbCBub2RlIDo6IHJlc3QgaW5cbiAgICAgICAgbG9vcCB0b192aXNpdClcbiAgaW5cbiAgbG9vcCBbIHQucm9vdCBdIFtAbm9udGFpbF1cbjs7XG5cbmxldCBsZW5ndGggdCA9IE5vZGUuUG9vbC5sZW5ndGggdC5wb29sXG5cbm1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBmb2xkID0gZm9sZFxuICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbmVuZClcblxubGV0IGlzX2VtcHR5IHQgPSBOb2RlLmlzX2VtcHR5IHQucm9vdFxubGV0IG1lbSA9IEMubWVtXG5sZXQgZXhpc3RzID0gQy5leGlzdHNcbmxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG5sZXQgY291bnQgPSBDLmNvdW50XG5sZXQgc3VtID0gQy5zdW1cbmxldCBmaW5kID0gQy5maW5kXG5sZXQgZmluZF9tYXAgPSBDLmZpbmRfbWFwXG5sZXQgdG9fbGlzdCA9IEMudG9fbGlzdFxubGV0IHRvX2FycmF5ID0gQy50b19hcnJheVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBtYXhfZWx0ID0gQy5tYXhfZWx0XG5sZXQgZm9sZF9yZXN1bHQgPSBDLmZvbGRfcmVzdWx0XG5sZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxuXG5sZXQgb2ZfYXJyYXkgYXJyIH5jbXAgPVxuICBsZXQgdCA9IGNyZWF0ZSB+bWluX3NpemU6KEFycmF5Lmxlbmd0aCBhcnIpIH5jbXAgKCkgaW5cbiAgQXJyYXkuaXRlciBhcnIgfmY6KGZ1biB2IC0+IGFkZCB0IHYpO1xuICB0XG47O1xuXG5sZXQgb2ZfbGlzdCBsIH5jbXAgPSBvZl9hcnJheSAoQXJyYXkub2ZfbGlzdCBsKSB+Y21wXG5sZXQgc2V4cF9vZl90IGYgdCA9IEFycmF5LnNleHBfb2ZfdCBmICh0b19hcnJheSB0IHw+IEFycmF5LnNvcnRlZF9jb3B5IH5jb21wYXJlOnQuY21wKVxuXG5tb2R1bGUgRWx0ID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICdhIHQgPVxuICAgIHsgbXV0YWJsZSBub2RlIDogJ2EgTm9kZS50XG4gICAgOyBub2RlX2lkIDogTm9kZS5JZC50XG4gICAgOyBoZWFwIDogJ2EgdFxuICAgIH1cblxuICAoKiBJZiBpZHMgYXJlIGRpZmZlcmVudCwgaXQgbWVhbnMgdGhhdCB0aGUgbm9kZSBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQgYnkgc29tZVxuICAgICBvdGhlciBtZWFucyAoYW5kIHBvc3NpYmx5IHJldXNlZCkuICopXG4gIGxldCBpc19ub2RlX3ZhbGlkIHQgPSBOb2RlLklkLmVxdWFsIChOb2RlLmlkIH5wb29sOnQuaGVhcC5wb29sIHQubm9kZSkgdC5ub2RlX2lkXG5cbiAgbGV0IHZhbHVlIHQgPVxuICAgIGlmIGlzX25vZGVfdmFsaWQgdCB0aGVuIFNvbWUgKE5vZGUudmFsdWVfZXhuIHQubm9kZSB+cG9vbDp0LmhlYXAucG9vbCkgZWxzZSBOb25lXG4gIDs7XG5cbiAgbGV0IHZhbHVlX2V4biB0ID1cbiAgICBpZiBpc19ub2RlX3ZhbGlkIHRcbiAgICB0aGVuIE5vZGUudmFsdWVfZXhuIHQubm9kZSB+cG9vbDp0LmhlYXAucG9vbFxuICAgIGVsc2UgZmFpbHdpdGggXCJIZWFwLnZhbHVlX2V4bjogbm9kZSB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBoZWFwXCJcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gWyVzZXhwICh2YWx1ZSB0IDogYSBvcHRpb24pXVxuZW5kXG5cbmxldCByZW1vdmUgdCAodG9rZW4gOiBfIEVsdC50KSA9XG4gIGlmIG5vdCAocGh5c19lcXVhbCB0IHRva2VuLmhlYXApXG4gIHRoZW4gZmFpbHdpdGggXCJjYW5ub3QgcmVtb3ZlIGZyb20gYSBkaWZmZXJlbnQgaGVhcFwiXG4gIGVsc2UgaWYgbm90IChOb2RlLmlzX2VtcHR5IHRva2VuLm5vZGUpXG4gIHRoZW4gKFxuICAgIGlmIEVsdC5pc19ub2RlX3ZhbGlkIHRva2VuIHRoZW4gcmVtb3ZlX25vbl9lbXB0eSB0IHRva2VuLm5vZGU7XG4gICAgdG9rZW4ubm9kZSA8LSBOb2RlLmVtcHR5ICgpKVxuOztcblxubGV0IGFkZF9yZW1vdmFibGUgdCB2ID1cbiAgbGV0IG5vZGUgPSBhZGRfbm9kZSB0IHYgaW5cbiAgeyBFbHQubm9kZTsgaGVhcCA9IHQ7IG5vZGVfaWQgPSBOb2RlLmlkIH5wb29sOnQucG9vbCBub2RlIH1cbjs7XG5cbmxldCB1cGRhdGUgdCB0b2tlbiB2ID1cbiAgcmVtb3ZlIHQgdG9rZW47XG4gIGFkZF9yZW1vdmFibGUgdCB2XG47O1xuXG5sZXQgZmluZF9lbHQgPVxuICBsZXQgcmVjIGxvb3AgdCBmIG5vZGVzID1cbiAgICBtYXRjaCBub2RlcyB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBub2RlIDo6IHJlc3QgLT5cbiAgICAgIGlmIE5vZGUuaXNfZW1wdHkgbm9kZVxuICAgICAgdGhlbiBsb29wIHQgZiByZXN0XG4gICAgICBlbHNlIGlmIGYgKE5vZGUudmFsdWVfZXhuIG5vZGUgfnBvb2w6dC5wb29sKVxuICAgICAgdGhlbiBTb21lIHsgRWx0Lm5vZGU7IGhlYXAgPSB0OyBub2RlX2lkID0gTm9kZS5pZCB+cG9vbDp0LnBvb2wgbm9kZSB9XG4gICAgICBlbHNlXG4gICAgICAgIGxvb3AgdCBmIChOb2RlLnNpYmxpbmcgbm9kZSB+cG9vbDp0LnBvb2wgOjogTm9kZS5jaGlsZCBub2RlIH5wb29sOnQucG9vbCA6OiByZXN0KVxuICBpblxuICBmdW4gdCB+ZiAtPiBsb29wIHQgZiBbIHQucm9vdCBdXG47O1xuXG5tb2R1bGUgVW5zYWZlID0gc3RydWN0XG4gIG1vZHVsZSBFbHQgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIGhlYXAgPSAnYSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgTm9kZS50XG5cbiAgICBsZXQgdmFsdWUgdCBoZWFwID0gTm9kZS52YWx1ZV9leG4gfnBvb2w6aGVhcC5wb29sIHRcbiAgZW5kXG5cbiAgbGV0IGFkZF9yZW1vdmFibGUgPSBhZGRfbm9kZVxuICBsZXQgcmVtb3ZlID0gcmVtb3ZlX25vbl9lbXB0eVxuXG4gIGxldCB1cGRhdGUgdCBlbHQgdiA9XG4gICAgcmVtb3ZlIHQgZWx0O1xuICAgIGFkZF9yZW1vdmFibGUgdCB2XG4gIDs7XG5lbmRcbiJdfQ==
