// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Angstrom__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Angstrom = [0];
   runtime.caml_register_global(0, Angstrom, "Angstrom__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__More
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Angstrom_More = [0];
   runtime.caml_register_global(0, Angstrom_More, "Angstrom__More");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Exported_state
//# unitInfo: Requires: Stdlib, Stdlib__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ": ",
    cst$0 = " > ",
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    _a_ = [1, "incomplete input"];
   function state_to_option(x){
    switch(x[0]){
      case 0:
       return 0;
      case 1:
       var v = x[2]; return [0, v];
      default: return 0;
    }
   }
   function fail_to_string(marks, err){
    var
     _b_ = caml_call2(Stdlib[28], cst, err),
     _c_ = caml_call2(Stdlib_String[7], cst$0, marks);
    return caml_call2(Stdlib[28], _c_, _b_);
   }
   function state_to_result(x){
    switch(x[0]){
      case 0:
       return _a_;
      case 1:
       var v = x[2]; return [0, v];
      default:
       var err = x[3], marks = x[2]; return [1, fail_to_string(marks, err)];
    }
   }
   var
    Angstrom_Exported_state =
      [0, state_to_option, fail_to_string, state_to_result];
   runtime.caml_register_global
    (5, Angstrom_Exported_state, "Angstrom__Exported_state");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Input
//# unitInfo: Requires: Bigstringaf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_input_ml = "lib/input.ml",
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Bigstringaf = global_data.Bigstringaf,
    Assert_failure = global_data.Assert_failure,
    _b_ = [0, cst_lib_input_ml, 59, 2],
    _a_ = [0, cst_lib_input_ml, 60, 2];
   function create(buffer, off, len, committed_bytes){
    return [0, committed_bytes, committed_bytes, off, len, buffer];
   }
   function length(t){return t[2] + t[4] | 0;}
   function client_committed_bytes(t){return t[2];}
   function parser_committed_bytes(t){return t[1];}
   function bytes_for_client_to_commit(t){return t[1] - t[2] | 0;}
   function parser_uncommitted_bytes(t){
    var _f_ = bytes_for_client_to_commit(t);
    return t[4] - _f_ | 0;
   }
   function invariant(t){
    var _c_ = length(t), _d_ = parser_uncommitted_bytes(t);
    if((t[1] + _d_ | 0) !== _c_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var _e_ = bytes_for_client_to_commit(t);
    if((t[1] - t[2] | 0) === _e_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function offset_in_buffer(t, pos){return (t[3] + pos | 0) - t[2] | 0;}
   function apply(t, pos, len, f){
    var off = offset_in_buffer(t, pos);
    return caml_call3(f, t[5], off, len);
   }
   function unsafe_get_char(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_ba_get_1(t[5], off);
   }
   function unsafe_get_int16_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[30], t[5], off);
   }
   function unsafe_get_int32_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[36], t[5], off);
   }
   function unsafe_get_int64_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[40], t[5], off);
   }
   function unsafe_get_int16_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[31], t[5], off);
   }
   function unsafe_get_int32_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[37], t[5], off);
   }
   function unsafe_get_int64_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[41], t[5], off);
   }
   function count_while(t, pos, f){
    var
     buffer = t[5],
     off = offset_in_buffer(t, pos),
     i = [0, off],
     limit = t[3] + t[4] | 0;
    for(;;){
     if(i[1] < limit && caml_call1(f, caml_ba_get_1(buffer, i[1]))){i[1]++; continue;}
     return i[1] - off | 0;
    }
   }
   function commit(t, pos){t[1] = pos; return 0;}
   var
    Angstrom_Input =
      [0,
       create,
       length,
       client_committed_bytes,
       parser_committed_bytes,
       parser_uncommitted_bytes,
       bytes_for_client_to_commit,
       unsafe_get_char,
       unsafe_get_int16_le,
       unsafe_get_int32_le,
       unsafe_get_int64_le,
       unsafe_get_int16_be,
       unsafe_get_int32_be,
       unsafe_get_int64_be,
       count_while,
       apply,
       commit,
       invariant];
   runtime.caml_register_global(4, Angstrom_Input, "Angstrom__Input");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Parser
//# unitInfo: Requires: Angstrom__Exported_state, Angstrom__Input, Bigstringaf, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Angstrom_Input = global_data.Angstrom__Input,
    Bigstringaf = global_data.Bigstringaf,
    Angstrom_Exported_state = global_data.Angstrom__Exported_state,
    State = [0];
   function fail_k(input, pos, param, marks, msg){
    return [3, pos - caml_call1(Angstrom_Input[3], input) | 0, marks, msg];
   }
   function succeed_k(input, pos, param, v){
    return [2, pos - caml_call1(Angstrom_Input[3], input) | 0, v];
   }
   function to_exported_state(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var match = param$0[1], continue$0 = match[2], committed = match[1];
        return [0,
                [0,
                 committed,
                 function(bs, off, len, more){
                  return to_exported_state
                          (caml_call4(continue$0, bs, off, len, more));
                 }]];
       case 1:
        var x = param$0[1], _c_ = runtime.caml_obj_tag(x);
        a:
        if(250 === _c_)
         var param$1 = x[1];
        else{
         if(246 !== _c_ && 244 !== _c_){var param$1 = x; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], x);
        }
        var param$0 = param$1;
        break;
       case 2:
        var x$0 = param$0[2], i = param$0[1]; return [1, i, x$0];
       default:
        var s = param$0[3], sl = param$0[2], i$0 = param$0[1];
        return [2, i$0, sl, s];
     }
   }
   function parse(p){
    var input = caml_call4(Angstrom_Input[1], Bigstringaf[2], 0, 0, 0);
    return to_exported_state(caml_call5(p[1], input, 0, 1, fail_k, succeed_k));
   }
   function parse_bigstring(p, input){
    var
     _a_ = caml_call1(Bigstringaf[6], input),
     input$0 = caml_call4(Angstrom_Input[1], input, 0, _a_, 0),
     _b_ =
       to_exported_state(caml_call5(p[1], input$0, 0, 0, fail_k, succeed_k));
    return caml_call1(Angstrom_Exported_state[3], _b_);
   }
   function return$0(v){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call4(succ, input, pos, more, v);
            }];
   }
   function fail(msg){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call5(fail, input, pos, more, 0, msg);
            }];
   }
   function symbol_bind(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, v){
              return caml_call5
                      (caml_call1(f, v)[1], input, pos, more, fail, succ);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol_map(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, v){
              return caml_call4(succ, input, pos, more, caml_call1(f, v));
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol(f, m){return symbol_map(m, f);}
   function symbol$0(f, m){
    return [0,
            function(input, pos, more, fail, succ){
             function succ0(input0, pos0, more0, f){
              function succ1(input1, pos1, more1, m){
               return caml_call4(succ, input1, pos1, more1, caml_call1(f, m));
              }
              return caml_call5(m[1], input0, pos0, more0, fail, succ1);
             }
             return caml_call5(f[1], input, pos, more, fail, succ0);
            }];
   }
   function lift(f, m){return symbol(f, m);}
   function lift2(f, m1, m2){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               return caml_call4
                       (succ, input2, pos2, more2, caml_call2(f, m1, m2));
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function lift3(f, m1, m2, m3){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               function succ3(input3, pos3, more3, m3){
                return caml_call4
                        (succ, input3, pos3, more3, caml_call3(f, m1, m2, m3));
               }
               return caml_call5(m3[1], input2, pos2, more2, fail, succ3);
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function lift4(f, m1, m2, m3, m4){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               function succ3(input3, pos3, more3, m3){
                function succ4(input4, pos4, more4, m4){
                 return caml_call4
                         (succ, input4, pos4, more4, caml_call4(f, m1, m2, m3, m4));
                }
                return caml_call5(m4[1], input3, pos3, more3, fail, succ4);
               }
               return caml_call5(m3[1], input2, pos2, more2, fail, succ3);
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function symbol$1(a, b){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, param){
              return caml_call5(b[1], input, pos, more, fail, succ);
             }
             return caml_call5(a[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol$2(a, b){
    return [0,
            function(input, pos, more, fail, succ){
             function succ0(input0, pos0, more0, x){
              function succ1(input1, pos1, more1, param){
               return caml_call4(succ, input1, pos1, more1, x);
              }
              return caml_call5(b[1], input0, pos0, more0, fail, succ1);
             }
             return caml_call5(a[1], input, pos, more, fail, succ0);
            }];
   }
   var
    Monad =
      [0,
       return$0,
       fail,
       symbol_bind,
       symbol_map,
       symbol,
       symbol$0,
       lift,
       lift2,
       lift3,
       lift4,
       symbol$1,
       symbol$2];
   function symbol$3(p, mark){
    return [0,
            function(input, pos, more, fail, succ){
             function fail$0(input, pos, more, marks, msg){
              return caml_call5(fail, input, pos, more, [0, mark, marks], msg);
             }
             return caml_call5(p[1], input, pos, more, fail$0, succ);
            }];
   }
   function symbol$4(p, q){
    return [0,
            function(input, pos, more, fail, succ){
             function fail$0(input, pos$0, more$0, marks, msg){
              return pos < caml_call1(Angstrom_Input[4], input)
                      ? caml_call5(fail, input, pos$0, more, marks, msg)
                      : caml_call5(q[1], input, pos, more$0, fail, succ);
             }
             return caml_call5(p[1], input, pos, more, fail$0, succ);
            }];
   }
   var
    Choice = [0, symbol$3, symbol$4],
    return$1 = Monad[1],
    fail$0 = Monad[2],
    symbol_bind$0 = Monad[3];
   function symbol_map$0(m, f){
    return caml_call2
            (symbol_bind$0,
             m,
             function(x){return caml_call1(return$1, caml_call1(f, x));});
   }
   function symbol$5(f, m){return symbol_map$0(m, f);}
   function symbol$6(f, m){
    return caml_call2
            (symbol_bind$0, f, function(f){return symbol_map$0(m, f);});
   }
   function lift2$0(f, m1, m2){return symbol$6(symbol$5(f, m1), m2);}
   function lift3$0(f, m1, m2, m3){
    return symbol$6(symbol$6(symbol$5(f, m1), m2), m3);
   }
   function lift4$0(f, m1, m2, m3, m4){
    return symbol$6(symbol$6(symbol$6(symbol$5(f, m1), m2), m3), m4);
   }
   function symbol$7(a, b){
    return caml_call2(symbol_bind$0, a, function(param){return b;});
   }
   function symbol$8(a, b){
    return caml_call2
            (symbol_bind$0,
             a,
             function(x){return symbol_map$0(b, function(param){return x;});});
   }
   var
    Monad_use_for_debugging =
      [0,
       return$1,
       fail$0,
       symbol_bind$0,
       symbol_map$0,
       symbol$5,
       symbol$6,
       symbol_map$0,
       lift2$0,
       lift3$0,
       lift4$0,
       symbol$7,
       symbol$8],
    Angstrom_Parser =
      [0,
       State,
       fail_k,
       succeed_k,
       to_exported_state,
       parse,
       parse_bigstring,
       Monad,
       Choice,
       Monad_use_for_debugging];
   runtime.caml_register_global(4, Angstrom_Parser, "Angstrom__Parser");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Buffering
//# unitInfo: Requires: Bigstringaf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_buffering_ml = "lib/buffering.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Bigstringaf = global_data.Bigstringaf,
    _h_ = [0, cst_lib_buffering_ml, 79, 2],
    _g_ = [0, cst_lib_buffering_ml, 64, 2],
    _f_ = [0, cst_lib_buffering_ml, 53, 2],
    _e_ = [0, cst_lib_buffering_ml, 54, 2],
    _d_ = [0, cst_lib_buffering_ml, 46, 2],
    _c_ = [0, cst_lib_buffering_ml, 47, 2],
    _b_ = [0, cst_lib_buffering_ml, 7, 2],
    _a_ = [0, cst_lib_buffering_ml, 8, 2];
   function of_bigstring(off, len, buf){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if((len - off | 0) <= caml_call1(Bigstringaf[6], buf))
     return [0, buf, off, len];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function create(len){
    return of_bigstring(0, 0, caml_call1(Bigstringaf[1], len));
   }
   function writable_space(t){
    var _m_ = t[3];
    return caml_call1(Bigstringaf[6], t[1]) - _m_ | 0;
   }
   function ensure(t, to_copy){
    var
     _k_ = t[2] + t[3] | 0,
     _l_ = (caml_call1(Bigstringaf[6], t[1]) - _k_ | 0) < to_copy ? 1 : 0;
    if(! _l_) return _l_;
    if(to_copy <= writable_space(t)){
     caml_call5(Bigstringaf[44], t[1], t[2], t[1], 0, t[3]);
     t[2] = 0;
     return;
    }
    var
     old_len = caml_call1(Bigstringaf[6], t[1]),
     new_len = [0, old_len],
     space = writable_space(t);
    for(;;){
     if(((space + new_len[1] | 0) - old_len | 0) >= to_copy){
      var new_buf = caml_call1(Bigstringaf[1], new_len[1]);
      caml_call5(Bigstringaf[44], t[1], t[2], new_buf, 0, t[3]);
      t[1] = new_buf;
      t[2] = 0;
      return;
     }
     new_len[1] = (3 * new_len[1] | 0) / 2 | 0;
    }
   }
   function write_pos(t){return t[2] + t[3] | 0;}
   function feed_string(t, off, len, str){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    if((len - off | 0) > caml_ml_string_length(str))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    ensure(t, len);
    var _j_ = write_pos(t);
    caml_call5(Bigstringaf[45], str, off, t[1], _j_, len);
    t[3] = t[3] + len | 0;
    return 0;
   }
   function feed_bigstring(t, off, len, b){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    if((len - off | 0) > caml_call1(Bigstringaf[6], b))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
    ensure(t, len);
    var _i_ = write_pos(t);
    caml_call5(Bigstringaf[44], b, off, t[1], _i_, len);
    t[3] = t[3] + len | 0;
    return 0;
   }
   function feed_input(t, param){
    if(608227697 <= param[1]){
     var b = param[2];
     return feed_bigstring(t, 0, caml_call1(Bigstringaf[6], b), b);
    }
    var s = param[2];
    return feed_string(t, 0, caml_ml_string_length(s), s);
   }
   function shift(t, n){
    if(n > t[3])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    t[2] = t[2] + n | 0;
    t[3] = t[3] - n | 0;
    return 0;
   }
   function for_reading(param){
    var buf = param[1], off = param[2], len = param[3];
    return caml_call3(Bigstringaf[5], buf, off, len);
   }
   function unconsumed(opt, param){
    if(opt) var sth = opt[1], shift = sth; else var shift = 0;
    var buf = param[1], off = param[2], len = param[3];
    if(shift <= len) return [0, buf, off + shift | 0, len - shift | 0];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   }
   function of_unconsumed(param){
    var len = param[3], off = param[2], buf = param[1];
    return [0, buf, off, len];
   }
   var
    Angstrom_Buffering =
      [0,
       create,
       of_bigstring,
       feed_string,
       feed_bigstring,
       feed_input,
       shift,
       for_reading,
       unconsumed,
       of_unconsumed];
   runtime.caml_register_global(10, Angstrom_Buffering, "Angstrom__Buffering");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom
//# unitInfo: Requires: Angstrom__Buffering, Angstrom__Exported_state, Angstrom__Input, Angstrom__Parser, Bigstringaf, CamlinternalLazy, Stdlib, Stdlib__Char, Stdlib__Int32, Stdlib__Int64, Stdlib__List, Stdlib__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_count_while1$1 = "count_while1",
    cst_not_enough_input$1 = "not enough input",
    cst_satisfy = "satisfy: ",
    cst_satisfy_C = "satisfy: %C",
    caml_int32_float_of_bits = runtime.caml_int32_float_of_bits,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\r\n",
    Stdlib = global_data.Stdlib,
    Angstrom_Input = global_data.Angstrom__Input,
    Bigstringaf = global_data.Bigstringaf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Angstrom_Buffering = global_data.Angstrom__Buffering,
    Angstrom_Parser = global_data.Angstrom__Parser,
    Angstrom_Exported_state = global_data.Angstrom__Exported_state,
    Stdlib_Sys = global_data.Stdlib__Sys,
    parse = Angstrom_Parser[5],
    parse_bigstring = Angstrom_Parser[6],
    state_to_option = Angstrom_Exported_state[1],
    fail_to_string = Angstrom_Exported_state[2],
    state_to_result = Angstrom_Exported_state[3],
    _a_ = Angstrom_Parser[7],
    return$0 = _a_[1],
    fail = _a_[2],
    symbol_bind = _a_[3],
    symbol_map = _a_[4],
    symbol = _a_[5],
    symbol$0 = _a_[6],
    lift = _a_[7],
    lift2 = _a_[8],
    lift3 = _a_[9],
    lift4 = _a_[10],
    symbol$1 = _a_[11],
    symbol$2 = _a_[12],
    include = Angstrom_Parser[8],
    symbol$3 = include[1],
    symbol$4 = include[2],
    cst_prompt_input_shrunk = "prompt: input shrunk!",
    cst_count_while1$0 = cst_count_while1$1,
    cst_count_while1 = cst_count_while1$1,
    cst_LE_int64 = "LE.int64",
    cst_LE_int32 = "LE.int32",
    cst_LE_int16 = "LE.int16",
    cst_BE_int64 = "BE.int64",
    cst_BE_int32 = "BE.int32",
    cst_BE_int16 = "BE.int16",
    cst_consumed_parser_committed = "consumed: parser committed",
    cst_count_n_0 = "count: n < 0",
    cst_Angstrom_fix_direct_not_se = "Angstrom.fix_direct not set",
    cst_no_more_choices = "no more choices",
    cst_take_bigstring_n_0 = "take_bigstring: n < 0",
    cst_take_n_0 = "take: n < 0",
    _h_ = [1, "string"],
    cst_skip = "skip",
    _g_ = [0, [11, "int8 ", [4, 0, 0, 0, 0]], "int8 %d"],
    _f_ = [0, [11, "not char ", [1, 0]], "not char %C"],
    _e_ = [0, [11, "char ", [1, 0]], "char %C"],
    _d_ = [0, [11, cst_satisfy, [1, 0]], cst_satisfy_C],
    _c_ = [0, [11, cst_satisfy, [1, 0]], cst_satisfy_C],
    cst_advance = "advance",
    cst_end_of_input = "end_of_input",
    cst_not_enough_input = cst_not_enough_input$1,
    cst_not_enough_input$0 = cst_not_enough_input$1,
    _b_ = [1, "incomplete input"],
    cst_parse_invalid_argument_ini =
      "parse: invalid argument, initial_buffer_size < 1",
    cst_end_of_line = "end_of_line";
   function from_unbuffered_state(f, buffering, param){
    switch(param[0]){
      case 0:
       var p = param[1]; return [0, caml_call1(f, p)];
      case 1:
       var
        v = param[2],
        consumed = param[1],
        unconsumed =
          caml_call2(Angstrom_Buffering[8], [0, consumed], buffering);
       return [1, unconsumed, v];
      default:
       var
        msg = param[3],
        marks = param[2],
        consumed$0 = param[1],
        unconsumed$0 =
          caml_call2(Angstrom_Buffering[8], [0, consumed$0], buffering);
       return [2, unconsumed$0, marks, msg];
    }
   }
   function parse$0(opt, p){
    if(opt)
     var sth = opt[1], initial_buffer_size = sth;
    else
     var initial_buffer_size = 4096;
    if(initial_buffer_size < 1)
     caml_call1(Stdlib[2], cst_parse_invalid_argument_ini);
    var buffering = caml_call1(Angstrom_Buffering[1], initial_buffer_size);
    function f(p, input){
     caml_call2(Angstrom_Buffering[6], buffering, p[1]);
     var
      more =
        typeof input === "number"
         ? 0
         : (caml_call2(Angstrom_Buffering[5], buffering, input), 1),
      for_reading = caml_call1(Angstrom_Buffering[7], buffering),
      _Q_ = caml_call1(Bigstringaf[6], for_reading);
     return from_unbuffered_state
             (f, buffering, caml_call4(p[2], for_reading, 0, _Q_, more));
    }
    return from_unbuffered_state(f, buffering, caml_call1(parse, p));
   }
   function feed(state, input){
    switch(state[0]){
      case 0:
       var k = state[1]; return caml_call1(k, input);
      case 1:
       var v = state[2], unconsumed = state[1];
       if(typeof input === "number") return state;
       var buffering = caml_call1(Angstrom_Buffering[9], unconsumed);
       caml_call2(Angstrom_Buffering[5], buffering, input);
       return [1, caml_call2(Angstrom_Buffering[8], 0, buffering), v];
      default:
       var msg = state[3], marks = state[2], unconsumed$0 = state[1];
       if(typeof input === "number") return state;
       var buffering$0 = caml_call1(Angstrom_Buffering[9], unconsumed$0);
       caml_call2(Angstrom_Buffering[5], buffering$0, input);
       return [2,
               caml_call2(Angstrom_Buffering[8], 0, buffering$0),
               marks,
               msg];
    }
   }
   function state_to_option$0(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var v = param[2]; return [0, v];
      default: return 0;
    }
   }
   function state_to_result$0(param){
    switch(param[0]){
      case 0:
       return _b_;
      case 1:
       var v = param[2]; return [0, v];
      default:
       var msg = param[3], marks = param[2];
       return [1, caml_call2(fail_to_string, marks, msg)];
    }
   }
   function state_to_unconsumed(param){
    if(0 === param[0]) return 0;
    var unconsumed = param[1];
    return [0, unconsumed];
   }
   function prompt(input, pos, fail, succ){
    var
     parser_uncommitted_bytes = caml_call1(Angstrom_Input[5], input),
     parser_committed_bytes = caml_call1(Angstrom_Input[4], input);
    function continue$0(input, off, len, more){
     if(len < parser_uncommitted_bytes)
      caml_call1(Stdlib[2], cst_prompt_input_shrunk);
     var
      input$0 =
        caml_call4(Angstrom_Input[1], input, off, len, parser_committed_bytes);
     return len === parser_uncommitted_bytes
             ? more
               ? prompt(input$0, pos, fail, succ)
               : caml_call3(fail, input$0, pos, 0)
             : caml_call3(succ, input$0, pos, more);
    }
    return [0, [0, caml_call1(Angstrom_Input[6], input), continue$0]];
   }
   var
    demand_input =
      [0,
       function(input, pos, more, fail, succ){
        if(! more)
         return caml_call5(fail, input, pos, more, 0, cst_not_enough_input$0);
        function succ$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        function fail$0(input, pos, more){
         return caml_call5(fail, input, pos, more, 0, cst_not_enough_input);
        }
        return prompt(input, pos, fail$0, succ$0);
       }];
   function ensure_suspended(n, input, pos, more, fail, succ){
    var go = [];
    caml_update_dummy
     (go,
      [0,
       function(input, pos, more, fail, succ){
        return (pos + n | 0) <= caml_call1(Angstrom_Input[2], input)
                ? caml_call4(succ, input, pos, more, 0)
                : caml_call5
                  (caml_call2(symbol$1, demand_input, go)[1],
                   input,
                   pos,
                   more,
                   fail,
                   succ);
       }]);
    return caml_call5
            (caml_call2(symbol$1, demand_input, go)[1],
             input,
             pos,
             more,
             fail,
             succ);
   }
   function unsafe_apply(len, f){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call4
                     (succ,
                      input,
                      pos + len | 0,
                      more,
                      caml_call4(Angstrom_Input[15], input, pos, len, f));
            }];
   }
   function ensure(n, p){
    return [0,
            function(input, pos, more, fail, succ){
             if((pos + n | 0) <= caml_call1(Angstrom_Input[2], input))
              return caml_call5(p[1], input, pos, more, fail, succ);
             function succ$0(input, pos, more, param){
              return caml_call5(p[1], input, pos, more, fail, succ);
             }
             return ensure_suspended(n, input, pos, more, fail, succ$0);
            }];
   }
   var
    at_end_of_input =
      [0,
       function(input, pos, more, param, succ){
        if(pos < caml_call1(Angstrom_Input[2], input))
         return caml_call4(succ, input, pos, more, 0);
        if(! more) return caml_call4(succ, input, pos, more, 1);
        function succ$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        function fail(input, pos, more){
         return caml_call4(succ, input, pos, more, 1);
        }
        return prompt(input, pos, fail, succ$0);
       }],
    end_of_input =
      caml_call2
       (symbol_bind,
        at_end_of_input,
        function(param){
         return param
                 ? caml_call1(return$0, 0)
                 : caml_call1(fail, cst_end_of_input);
        });
   function advance(n){
    if(0 > n) return caml_call1(fail, cst_advance);
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call4(succ, input, pos + n | 0, more, 0);
        }];
    return ensure(n, p);
   }
   var
    pos =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4(succ, input, pos, more, pos);
       }],
    available =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4
                (succ,
                 input,
                 pos,
                 more,
                 caml_call1(Angstrom_Input[2], input) - pos | 0);
       }],
    commit =
      [0,
       function(input, pos, more, fail, succ){
        caml_call2(Angstrom_Input[16], input, pos);
        return caml_call4(succ, input, pos, more, 0);
       }];
   function unsafe_lookahead(p){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, param, more, v){
              return caml_call4(succ, input, pos, more, v);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   var
    peek_char =
      [0,
       function(input, pos, more, fail, succ){
        if(pos < caml_call1(Angstrom_Input[2], input))
         return caml_call4
                 (succ,
                  input,
                  pos,
                  more,
                  [0, caml_call2(Angstrom_Input[7], input, pos)]);
        if(0 === more) return caml_call4(succ, input, pos, more, 0);
        function succ$0(input, pos, more){
         return caml_call4
                 (succ,
                  input,
                  pos,
                  more,
                  [0, caml_call2(Angstrom_Input[7], input, pos)]);
        }
        function fail$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        return prompt(input, pos, fail$0, succ$0);
       }],
    peek_char_fail = [];
   caml_update_dummy
    (peek_char_fail,
     [0,
      function(input, pos, more, fail, succ){
       if(pos < caml_call1(Angstrom_Input[2], input))
        return caml_call4
                (succ,
                 input,
                 pos,
                 more,
                 caml_call2(Angstrom_Input[7], input, pos));
       function succ$0(input, pos, more, param){
        return caml_call5(peek_char_fail[1], input, pos, more, fail, succ);
       }
       return ensure_suspended(1, input, pos, more, fail, succ$0);
      }]);
   function satisfy(f){
    return [0,
            function(input, pos, more, fail, succ){
             if(pos >= caml_call1(Angstrom_Input[2], input)){
              var
               succ$0 =
                 function(input, pos, more, param){
                  var c = caml_call2(Angstrom_Input[7], input, pos);
                  if(caml_call1(f, c))
                   return caml_call4(succ, input, pos + 1 | 0, more, c);
                  var _P_ = caml_call4(fail, input, pos, more, 0);
                  return caml_call3(Stdlib_Printf[10], _P_, _d_, c);
                 };
              return ensure_suspended(1, input, pos, more, fail, succ$0);
             }
             var c = caml_call2(Angstrom_Input[7], input, pos);
             if(caml_call1(f, c))
              return caml_call4(succ, input, pos + 1 | 0, more, c);
             var _O_ = caml_call4(fail, input, pos, more, 0);
             return caml_call3(Stdlib_Printf[10], _O_, _c_, c);
            }];
   }
   function char$0(c){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[7], input, pos) === c
                 ? caml_call4(succ, input, pos + 1 | 0, more, c)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _e_, c));
        }];
    return ensure(1, p);
   }
   function not_char(c){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var c$0 = caml_call2(Angstrom_Input[7], input, pos);
         return c !== c$0
                 ? caml_call4(succ, input, pos + 1 | 0, more, c$0)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _f_, c));
        }];
    return ensure(1, p);
   }
   var
    p =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4
                (succ,
                 input,
                 pos + 1 | 0,
                 more,
                 caml_call2(Angstrom_Input[7], input, pos));
       }],
    any_char = ensure(1, p);
   function int8(i){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var c = caml_call2(Angstrom_Input[7], input, pos);
         return c === (i & 255)
                 ? caml_call4(succ, input, pos + 1 | 0, more, c)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _g_, i));
        }];
    return ensure(1, p);
   }
   var
    p$0 =
      [0,
       function(input, pos, more, fail, succ){
        var c = caml_call2(Angstrom_Input[7], input, pos);
        return caml_call4(succ, input, pos + 1 | 0, more, c);
       }],
    any_uint8 = ensure(1, p$0),
    s = Stdlib_Sys[10] - 8 | 0,
    p$1 =
      [0,
       function(input, pos, more, fail, succ){
        var c = caml_call2(Angstrom_Input[7], input, pos);
        return caml_call4(succ, input, pos + 1 | 0, more, c << s >> s);
       }],
    any_int8 = ensure(1, p$1);
   function skip(f){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call1(f, caml_call2(Angstrom_Input[7], input, pos))
                 ? caml_call4(succ, input, pos + 1 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_skip);
        }];
    return ensure(1, p);
   }
   function count_while(init, f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              len = caml_call3(Angstrom_Input[14], input, pos + init | 0, f),
              input_len = caml_call1(Angstrom_Input[2], input),
              init$0 = init + len | 0;
             if((pos + init$0 | 0) >= input_len && 0 !== more){
              var
               succ$0 =
                 function(input, pos, more){
                  return caml_call5
                          (count_while(init$0, f, with_buffer)[1],
                           input,
                           pos,
                           more,
                           fail,
                           succ);
                 },
               fail$0 =
                 function(input, pos, more){
                  return caml_call4
                          (succ,
                           input,
                           pos + init$0 | 0,
                           more,
                           caml_call4
                            (Angstrom_Input[15], input, pos, init$0, with_buffer));
                 };
              return prompt(input, pos, fail$0, succ$0);
             }
             return caml_call4
                     (succ,
                      input,
                      pos + init$0 | 0,
                      more,
                      caml_call4
                       (Angstrom_Input[15], input, pos, init$0, with_buffer));
            }];
   }
   function count_while1(f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              len = caml_call3(Angstrom_Input[14], input, pos, f),
              input_len = caml_call1(Angstrom_Input[2], input);
             if(1 <= len){
              if((pos + len | 0) >= input_len && 0 !== more){
               var
                succ$0 =
                  function(input, pos, more){
                   return caml_call5
                           (count_while(len, f, with_buffer)[1],
                            input,
                            pos,
                            more,
                            fail,
                            succ);
                  },
                fail$0 =
                  function(input, pos, more){
                   return caml_call4
                           (succ,
                            input,
                            pos + len | 0,
                            more,
                            caml_call4(Angstrom_Input[15], input, pos, len, with_buffer));
                  };
               return prompt(input, pos, fail$0, succ$0);
              }
              return caml_call4
                      (succ,
                       input,
                       pos + len | 0,
                       more,
                       caml_call4(Angstrom_Input[15], input, pos, len, with_buffer));
             }
             if(pos >= input_len && 0 !== more){
              var
               succ$1 =
                 function(input, pos, more){
                  return caml_call5
                          (count_while1(f, with_buffer)[1],
                           input,
                           pos,
                           more,
                           fail,
                           succ);
                 },
               fail$1 =
                 function(input, pos, more){
                  return caml_call5
                          (fail, input, pos, more, 0, cst_count_while1$0);
                 };
              return prompt(input, pos, fail$1, succ$1);
             }
             return caml_call5(fail, input, pos, more, 0, cst_count_while1);
            }];
   }
   function string(f, s){
    var len = caml_ml_string_length(s);
    function f$0(buffer, off, len){
     var i = [0, 0];
     for(;;){
      if(i[1] < len){
       var
        _M_ = caml_call1(f, runtime.caml_string_unsafe_get(s, i[1])),
        _N_ = caml_call1(f, runtime.caml_ba_get_1(buffer, off + i[1] | 0));
       if(caml_call2(Stdlib_Char[6], _N_, _M_)){i[1]++; continue;}
      }
      return len === i[1]
              ? [0, caml_call3(Bigstringaf[7], buffer, off, len)]
              : _h_;
     }
    }
    return ensure
            (len,
             [0,
              function(input, pos, more, fail, succ){
               var
                match = caml_call4(Angstrom_Input[15], input, pos, len, f$0);
               if(0 === match[0]){
                var x = match[1];
                return caml_call4(succ, input, pos + len | 0, more, x);
               }
               var e = match[1];
               return caml_call5(fail, input, pos, more, 0, e);
              }]);
   }
   function string$0(s){return string(function(x){return x;}, s);}
   function string_ci(s){return string(Stdlib_Char[3], s);}
   function skip_while(f){
    return count_while(0, f, function(param, _L_, _K_){return 0;});
   }
   function take(n){
    if(0 > n) return caml_call1(fail, cst_take_n_0);
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, Bigstringaf[7]));
   }
   function take_bigstring(n){
    if(0 > n) return caml_call1(fail, cst_take_bigstring_n_0);
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, Bigstringaf[4]));
   }
   function take_bigstring_while(f){return count_while(0, f, Bigstringaf[4]);}
   function take_bigstring_while1(f){return count_while1(f, Bigstringaf[4]);}
   function take_bigstring_till(f){
    return take_bigstring_while(function(c){return 1 - caml_call1(f, c);});
   }
   function peek_string(n){return unsafe_lookahead(take(n));}
   function take_while(f){return count_while(0, f, Bigstringaf[7]);}
   function take_while1(f){return count_while1(f, Bigstringaf[7]);}
   function take_till(f){
    return take_while(function(c){return 1 - caml_call1(f, c);});
   }
   function choice(opt, ps){
    if(opt)
     var sth = opt[1], failure_msg = sth;
    else
     var failure_msg = cst_no_more_choices;
    var _J_ = caml_call1(fail, failure_msg);
    return caml_call3(Stdlib_List[27], symbol$4, ps, _J_);
   }
   var
    notset =
      [0,
       function(buf, pos, more, fail, succ){
        return caml_call1(Stdlib[2], cst_Angstrom_fix_direct_not_se);
       }];
   function fix_direct(f){
    var p = [], r = [];
    caml_update_dummy(p, [0, notset]);
    caml_update_dummy
     (r,
      [0,
       function(buf, pos, more, fail, succ){
        return caml_call5(p[1][1], buf, pos, more, fail, succ);
       }]);
    p[1] = caml_call1(f, r);
    return r;
   }
   function fix_lazy(max_steps, f){
    var steps = [0, max_steps], p = [], r = [];
    caml_update_dummy(p, [246, function(_I_){return caml_call1(f, r);}]);
    caml_update_dummy
     (r,
      [0,
       function(buf, pos, more, fail, succ){
        steps[1] += -1;
        if(0 > steps[1]){
         steps[1] = max_steps;
         return [1,
                 [246,
                  function(_F_){
                   var _G_ = caml_obj_tag(p);
                   a:
                   if(250 === _G_)
                    var _H_ = p[1];
                   else{
                    if(246 !== _G_ && 244 !== _G_){var _H_ = p; break a;}
                    var _H_ = caml_call1(CamlinternalLazy[2], p);
                   }
                   return caml_call5(_H_[1], buf, pos, more, fail, succ);
                  }]];
        }
        var _D_ = caml_obj_tag(p);
        a:
        if(250 === _D_)
         var _E_ = p[1];
        else{
         if(246 !== _D_ && 244 !== _D_){var _E_ = p; break a;}
         var _E_ = caml_call1(CamlinternalLazy[2], p);
        }
        return caml_call5(_E_[1], buf, pos, more, fail, succ);
       }]);
    return r;
   }
   var
    _i_ = Stdlib_Sys[5],
    fix =
      typeof _i_ === "number"
       ? _i_ ? fix_direct : fix_direct
       : function(f){return fix_lazy(20, f);};
   function option(x, p){
    return caml_call2(symbol$4, p, caml_call1(return$0, x));
   }
   function cons(x, xs){return [0, x, xs];}
   function list(ps){
    if(! ps) return caml_call1(return$0, 0);
    var ps$0 = ps[2], p = ps[1];
    return caml_call3(lift2, cons, p, list(ps$0));
   }
   function count(n, p){
    if(0 > n) return caml_call1(fail, cst_count_n_0);
    function loop(n){
     return 0 === n
             ? caml_call1(return$0, 0)
             : caml_call3(lift2, cons, p, loop(n - 1 | 0));
    }
    return loop(n);
   }
   function many(p){
    return fix
            (function(m){
              var _C_ = caml_call1(return$0, 0);
              return caml_call2(symbol$4, caml_call3(lift2, cons, p, m), _C_);
             });
   }
   function many1(p){return caml_call3(lift2, cons, p, many(p));}
   function many_till(p, t){
    return fix
            (function(m){
              var _B_ = caml_call3(lift2, cons, p, m);
              return caml_call2
                      (symbol$4,
                       caml_call2(symbol$1, t, caml_call1(return$0, 0)),
                       _B_);
             });
   }
   function sep_by1(s, p){
    return fix
            (function(m){
              var _A_ = caml_call1(return$0, 0);
              return caml_call3
                      (lift2,
                       cons,
                       p,
                       caml_call2(symbol$4, caml_call2(symbol$1, s, m), _A_));
             });
   }
   function sep_by(s, p){
    var _y_ = caml_call1(return$0, 0), _z_ = caml_call1(return$0, 0);
    return caml_call2
            (symbol$4,
             caml_call3
              (lift2,
               cons,
               p,
               caml_call2
                (symbol$4, caml_call2(symbol$1, s, sep_by1(s, p)), _z_)),
             _y_);
   }
   function skip_many(p){
    return fix
            (function(m){
              function _w_(param){return param ? m : caml_call1(return$0, 0);}
              var _x_ = caml_call1(return$0, 0);
              return caml_call2
                      (symbol_bind,
                       caml_call2
                        (symbol$4,
                         caml_call2(symbol_map, p, function(param){return 1;}),
                         _x_),
                       _w_);
             });
   }
   function skip_many1(p){return caml_call2(symbol$1, p, skip_many(p));}
   var
    _j_ = caml_call1(return$0, 0),
    _k_ = caml_call2(symbol$1, string$0(cst), _j_),
    _l_ = caml_call1(return$0, 0),
    end_of_line =
      caml_call2
       (symbol$3,
        caml_call2(symbol$4, caml_call2(symbol$1, char$0(10), _l_), _k_),
        cst_end_of_line);
   function scan(state, f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var state$0 = [0, state];
             function _v_(x){return [0, x, state$0[1]];}
             var
              parser =
                caml_call2
                 (symbol_map,
                  count_while
                   (0,
                    function(c){
                     var match = caml_call2(f, state$0[1], c);
                     if(! match) return 0;
                     var state = match[1];
                     state$0[1] = state;
                     return 1;
                    },
                    with_buffer),
                  _v_);
             return caml_call5(parser[1], input, pos, more, fail, succ);
            }];
   }
   function scan$0(state, f){return scan(state, f, Bigstringaf[7]);}
   function scan_state(state, f){
    function _s_(param){var state = param[2]; return state;}
    return caml_call2
            (symbol_map,
             scan(state, f, function(param, _u_, _t_){return 0;}),
             _s_);
   }
   function scan_string(state, f){
    function _q_(_r_){return _r_[1];}
    return caml_call2(symbol_map, scan$0(state, f), _q_);
   }
   function consume_with(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             var
              parser_committed_bytes = caml_call1(Angstrom_Input[4], input);
             function succ$0(input, pos$0, more, param){
              if
               (parser_committed_bytes
                !== caml_call1(Angstrom_Input[4], input))
               return caml_call5
                       (fail, input, pos$0, more, 0, cst_consumed_parser_committed);
              var
               len = pos$0 - pos | 0,
               consumed = caml_call4(Angstrom_Input[15], input, pos, len, f);
              return caml_call4(succ, input, pos$0, more, consumed);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function consumed(p){return consume_with(p, Bigstringaf[7]);}
   function consumed_bigstring(p){return consume_with(p, Bigstringaf[4]);}
   function both(a, b){
    return caml_call3(lift2, function(a, b){return [0, a, b];}, a, b);
   }
   function map(t, f){return caml_call2(symbol_map, t, f);}
   function bind(t, f){return caml_call2(symbol_bind, t, f);}
   function map2(a, b, f){return caml_call3(lift2, f, a, b);}
   function map3(a, b, c, f){return caml_call4(lift3, f, a, b, c);}
   function map4(a, b, c, d, f){return caml_call5(lift4, f, a, b, c, d);}
   var
    Let_syntax = [0, return$0, map, bind, both, map2, map3, map4],
    Let_syntax$0 = [0, return$0, symbol_map, symbol_bind, Let_syntax];
   function int16(n){
    var
     bytes = 2,
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[11], input, pos) === (n & 65535)
                 ? caml_call4(succ, input, pos + 2 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int16);
        }];
    return ensure(bytes, p);
   }
   function int32(n){
    var
     bytes = 4,
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _p_ = caml_call2(Angstrom_Input[12], input, pos);
         return caml_call2(Stdlib_Int32[17], _p_, n)
                 ? caml_call4(succ, input, pos + 4 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int32);
        }];
    return ensure(bytes, p);
   }
   function int64(n){
    var
     bytes = 8,
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _o_ = caml_call2(Angstrom_Input[13], input, pos);
         return caml_call2(Stdlib_Int64[17], _o_, n)
                 ? caml_call4(succ, input, pos + 8 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int64);
        }];
    return ensure(bytes, p);
   }
   var
    any_uint16 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[31], bs, off);
          })),
    any_int16 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[33], bs, off);
          })),
    any_int32 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_call2(Bigstringaf[37], bs, off);
          })),
    any_int64 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_call2(Bigstringaf[41], bs, off);
          })),
    any_float =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_int32_float_of_bits
                   (caml_call2(Bigstringaf[37], bs, off));
          })),
    any_double =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_int64_float_of_bits
                   (caml_call2(Bigstringaf[41], bs, off));
          }));
   function int16$0(n){
    var
     bytes = 2,
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[8], input, pos) === (n & 65535)
                 ? caml_call4(succ, input, pos + 2 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int16);
        }];
    return ensure(bytes, p);
   }
   function int32$0(n){
    var
     bytes = 4,
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _n_ = caml_call2(Angstrom_Input[9], input, pos);
         return caml_call2(Stdlib_Int32[17], _n_, n)
                 ? caml_call4(succ, input, pos + 4 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int32);
        }];
    return ensure(bytes, p);
   }
   function int64$0(n){
    var
     bytes = 8,
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _m_ = caml_call2(Angstrom_Input[10], input, pos);
         return caml_call2(Stdlib_Int64[17], _m_, n)
                 ? caml_call4(succ, input, pos + 8 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int64);
        }];
    return ensure(bytes, p);
   }
   var
    any_uint16$0 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[30], bs, off);
          })),
    any_int16$0 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[32], bs, off);
          })),
    any_int32$0 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_call2(Bigstringaf[36], bs, off);
          })),
    any_int64$0 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_call2(Bigstringaf[40], bs, off);
          })),
    any_float$0 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_int32_float_of_bits
                   (caml_call2(Bigstringaf[36], bs, off));
          })),
    any_double$0 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_int64_float_of_bits
                   (caml_call2(Bigstringaf[40], bs, off));
          }));
   function take$0(n, f){
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, f));
   }
   function peek(n, f){return unsafe_lookahead(take$0(n, f));}
   function take_while$0(check, f){return count_while(0, check, f);}
   function take_while1$0(check, f){return count_while1(check, f);}
   function take_till$0(check, f){
    return take_while$0(function(c){return 1 - caml_call1(check, c);}, f);
   }
   var Consume = [0];
   function parse_bigstring$0(consume, p, bs){
    var p$0 = consume ? caml_call2(symbol$2, p, end_of_input) : p;
    return caml_call2(parse_bigstring, p$0, bs);
   }
   function parse_string(consume, p, s){
    var len = caml_ml_string_length(s), bs = caml_call1(Bigstringaf[1], len);
    caml_call5(Bigstringaf[45], s, 0, bs, 0, len);
    return parse_bigstring$0(consume, p, bs);
   }
   var
    Angstrom =
      [0,
       peek_char,
       peek_char_fail,
       peek_string,
       char$0,
       not_char,
       any_char,
       satisfy,
       string$0,
       string_ci,
       skip,
       skip_while,
       take,
       take_while,
       take_while1,
       take_till,
       consumed,
       take_bigstring,
       take_bigstring_while,
       take_bigstring_while1,
       take_bigstring_till,
       consumed_bigstring,
       advance,
       end_of_line,
       at_end_of_input,
       end_of_input,
       scan$0,
       scan_state,
       scan_string,
       int8,
       any_uint8,
       any_int8,
       [0,
        int16,
        int32,
        int64,
        any_int16,
        any_int32,
        any_int64,
        any_uint16,
        any_float,
        any_double],
       [0,
        int16$0,
        int32$0,
        int64$0,
        any_int16$0,
        any_int32$0,
        any_int64$0,
        any_uint16$0,
        any_float$0,
        any_double$0],
       option,
       both,
       list,
       count,
       many,
       many1,
       many_till,
       sep_by,
       sep_by1,
       skip_many,
       skip_many1,
       fix,
       fix_lazy,
       symbol$4,
       choice,
       symbol$3,
       commit,
       return$0,
       fail,
       symbol_bind,
       bind,
       symbol_map,
       symbol$0,
       symbol,
       symbol$1,
       symbol$2,
       lift,
       lift2,
       lift3,
       lift4,
       map,
       map2,
       map3,
       map4,
       Let_syntax$0,
       symbol_map,
       symbol_bind,
       both,
       [0, take$0, take_while$0, take_while1$0, take_till$0, peek],
       Consume,
       parse_bigstring$0,
       parse_string,
       [0,
        parse$0,
        feed,
        state_to_option$0,
        state_to_result$0,
        state_to_unconsumed],
       [0, parse, state_to_option, state_to_result],
       pos,
       available];
   runtime.caml_register_global(43, Angstrom, "Angstrom");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhbmdzdHJvbS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic3RhdGVfdG9fb3B0aW9uIiwieCIsInYiLCJmYWlsX3RvX3N0cmluZyIsIm1hcmtzIiwiZXJyIiwic3RhdGVfdG9fcmVzdWx0IiwiY3JlYXRlIiwiYnVmZmVyIiwib2ZmIiwibGVuIiwiY29tbWl0dGVkX2J5dGVzIiwibGVuZ3RoIiwidCIsImNsaWVudF9jb21taXR0ZWRfYnl0ZXMiLCJwYXJzZXJfY29tbWl0dGVkX2J5dGVzIiwiYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQiLCJwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMiLCJpbnZhcmlhbnQiLCJvZmZzZXRfaW5fYnVmZmVyIiwicG9zIiwiYXBwbHkiLCJmIiwidW5zYWZlX2dldF9jaGFyIiwidW5zYWZlX2dldF9pbnQxNl9sZSIsInVuc2FmZV9nZXRfaW50MzJfbGUiLCJ1bnNhZmVfZ2V0X2ludDY0X2xlIiwidW5zYWZlX2dldF9pbnQxNl9iZSIsInVuc2FmZV9nZXRfaW50MzJfYmUiLCJ1bnNhZmVfZ2V0X2ludDY0X2JlIiwiY291bnRfd2hpbGUiLCJpIiwibGltaXQiLCJjb21taXQiLCJmYWlsX2siLCJpbnB1dCIsIm1zZyIsInN1Y2NlZWRfayIsInRvX2V4cG9ydGVkX3N0YXRlIiwiY29udGludWUkMCIsImNvbW1pdHRlZCIsImJzIiwibW9yZSIsIngkMCIsInMiLCJzbCIsImkkMCIsInBhcnNlIiwicCIsInBhcnNlX2JpZ3N0cmluZyIsImlucHV0JDAiLCJyZXR1cm4kMCIsImZhaWwiLCJzdWNjIiwic3ltYm9sX2JpbmQiLCJzdWNjJDAiLCJzeW1ib2xfbWFwIiwic3ltYm9sIiwibSIsInN5bWJvbCQwIiwic3VjYzAiLCJpbnB1dDAiLCJwb3MwIiwibW9yZTAiLCJzdWNjMSIsImlucHV0MSIsInBvczEiLCJtb3JlMSIsImxpZnQiLCJsaWZ0MiIsIm0xIiwibTIiLCJzdWNjMiIsImlucHV0MiIsInBvczIiLCJtb3JlMiIsImxpZnQzIiwibTMiLCJzdWNjMyIsImlucHV0MyIsInBvczMiLCJtb3JlMyIsImxpZnQ0IiwibTQiLCJzdWNjNCIsImlucHV0NCIsInBvczQiLCJtb3JlNCIsInN5bWJvbCQxIiwiYSIsImIiLCJzeW1ib2wkMiIsInN5bWJvbCQzIiwibWFyayIsImZhaWwkMCIsInN5bWJvbCQ0IiwicSIsInBvcyQwIiwibW9yZSQwIiwicmV0dXJuJDEiLCJzeW1ib2xfYmluZCQwIiwic3ltYm9sX21hcCQwIiwic3ltYm9sJDUiLCJzeW1ib2wkNiIsImxpZnQyJDAiLCJsaWZ0MyQwIiwibGlmdDQkMCIsInN5bWJvbCQ3Iiwic3ltYm9sJDgiLCJvZl9iaWdzdHJpbmciLCJidWYiLCJ3cml0YWJsZV9zcGFjZSIsImVuc3VyZSIsInRvX2NvcHkiLCJvbGRfbGVuIiwibmV3X2xlbiIsInNwYWNlIiwibmV3X2J1ZiIsIndyaXRlX3BvcyIsImZlZWRfc3RyaW5nIiwic3RyIiwiZmVlZF9iaWdzdHJpbmciLCJmZWVkX2lucHV0Iiwic2hpZnQiLCJuIiwiZm9yX3JlYWRpbmciLCJ1bmNvbnN1bWVkIiwib3B0Iiwic3RoIiwib2ZfdW5jb25zdW1lZCIsImZyb21fdW5idWZmZXJlZF9zdGF0ZSIsImJ1ZmZlcmluZyIsImNvbnN1bWVkIiwiY29uc3VtZWQkMCIsInVuY29uc3VtZWQkMCIsInBhcnNlJDAiLCJpbml0aWFsX2J1ZmZlcl9zaXplIiwiZmVlZCIsInN0YXRlIiwiayIsImJ1ZmZlcmluZyQwIiwic3RhdGVfdG9fb3B0aW9uJDAiLCJzdGF0ZV90b19yZXN1bHQkMCIsInN0YXRlX3RvX3VuY29uc3VtZWQiLCJwcm9tcHQiLCJkZW1hbmRfaW5wdXQiLCJlbnN1cmVfc3VzcGVuZGVkIiwiZ28iLCJ1bnNhZmVfYXBwbHkiLCJhdF9lbmRfb2ZfaW5wdXQiLCJlbmRfb2ZfaW5wdXQiLCJhZHZhbmNlIiwiYXZhaWxhYmxlIiwidW5zYWZlX2xvb2thaGVhZCIsInBlZWtfY2hhciIsInBlZWtfY2hhcl9mYWlsIiwic2F0aXNmeSIsImMiLCJjaGFyJDAiLCJub3RfY2hhciIsImMkMCIsImFueV9jaGFyIiwiaW50OCIsInAkMCIsImFueV91aW50OCIsInAkMSIsImFueV9pbnQ4Iiwic2tpcCIsImluaXQiLCJ3aXRoX2J1ZmZlciIsImlucHV0X2xlbiIsImluaXQkMCIsImNvdW50X3doaWxlMSIsInN1Y2MkMSIsImZhaWwkMSIsInN0cmluZyIsImYkMCIsImUiLCJzdHJpbmckMCIsInN0cmluZ19jaSIsInNraXBfd2hpbGUiLCJ0YWtlIiwibiQwIiwidGFrZV9iaWdzdHJpbmciLCJ0YWtlX2JpZ3N0cmluZ193aGlsZSIsInRha2VfYmlnc3RyaW5nX3doaWxlMSIsInRha2VfYmlnc3RyaW5nX3RpbGwiLCJwZWVrX3N0cmluZyIsInRha2Vfd2hpbGUiLCJ0YWtlX3doaWxlMSIsInRha2VfdGlsbCIsImNob2ljZSIsInBzIiwiZmFpbHVyZV9tc2ciLCJub3RzZXQiLCJmaXhfZGlyZWN0IiwiciIsImZpeF9sYXp5IiwibWF4X3N0ZXBzIiwic3RlcHMiLCJmaXgiLCJvcHRpb24iLCJjb25zIiwieHMiLCJsaXN0IiwicHMkMCIsImNvdW50IiwibG9vcCIsIm1hbnkiLCJtYW55MSIsIm1hbnlfdGlsbCIsInNlcF9ieTEiLCJzZXBfYnkiLCJza2lwX21hbnkiLCJza2lwX21hbnkxIiwiZW5kX29mX2xpbmUiLCJzY2FuIiwic3RhdGUkMCIsInBhcnNlciIsInNjYW4kMCIsInNjYW5fc3RhdGUiLCJzY2FuX3N0cmluZyIsImNvbnN1bWVfd2l0aCIsImNvbnN1bWVkX2JpZ3N0cmluZyIsImJvdGgiLCJtYXAiLCJiaW5kIiwibWFwMiIsIm1hcDMiLCJtYXA0IiwiZCIsImludDE2IiwiYnl0ZXMiLCJpbnQzMiIsImludDY0IiwiYW55X3VpbnQxNiIsImFueV9pbnQxNiIsImFueV9pbnQzMiIsImFueV9pbnQ2NCIsImFueV9mbG9hdCIsImFueV9kb3VibGUiLCJpbnQxNiQwIiwiaW50MzIkMCIsImludDY0JDAiLCJhbnlfdWludDE2JDAiLCJhbnlfaW50MTYkMCIsImFueV9pbnQzMiQwIiwiYW55X2ludDY0JDAiLCJhbnlfZmxvYXQkMCIsImFueV9kb3VibGUkMCIsInRha2UkMCIsInBlZWsiLCJ0YWtlX3doaWxlJDAiLCJjaGVjayIsInRha2Vfd2hpbGUxJDAiLCJ0YWtlX3RpbGwkMCIsInBhcnNlX2JpZ3N0cmluZyQwIiwiY29uc3VtZSIsInBhcnNlX3N0cmluZyJdLCJzb3VyY2VzIjpbIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hbmdzdHJvbS9leHBvcnRlZF9zdGF0ZS5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hbmdzdHJvbS9pbnB1dC5tbCIsIi9Vc2Vycy90eWxhbm1vcmFuLy5vcGFtLzUuMS4xL2xpYi9hbmdzdHJvbS9wYXJzZXIubWwiLCIvVXNlcnMvdHlsYW5tb3Jhbi8ub3BhbS81LjEuMS9saWIvYW5nc3Ryb20vYnVmZmVyaW5nLm1sIiwiL1VzZXJzL3R5bGFubW9yYW4vLm9wYW0vNS4xLjEvbGliL2FuZ3N0cm9tL2FuZ3N0cm9tLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Ozs7Ozs7O1lBVUlBLGdCQUFnQkM7SUFBSSxPQUFKQTs7T0FHRjs7V0FGTkMsSUFEUUQsTUFDRixXQUFOQztlQUNNOztHQUNJO1lBRWxCQyxlQUFlQyxPQUFNQztJQUN2QjtLQUE0QixNQUFBLDRCQURMQTtLQUN2QixNQUFBLG9DQURpQkQ7SUFDVyxPQUFBO0dBQVU7WUFFcENFLGdCQUFnQkw7SUFBSSxPQUFKQTs7T0FFTzs7V0FEZkMsSUFEUUQsTUFDTyxXQUFmQzs7V0FFT0csTUFIQ0osTUFHUkcsUUFIUUgsTUFHTyxXQU52QkUsZUFNUUMsT0FBT0M7O0dBQXdDOzs7VUFYdkRMLGlCQUtBRyxnQkFHQUc7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7OztZQ3VCQUMsT0FBT0MsUUFBUUMsS0FBS0MsS0FBS0M7SUFDM0IsV0FEMkJBLGlCQUFBQSxpQkFBVkYsS0FBS0MsS0FBYkY7R0FLQztZQUVSSSxPQUF1QkMsR0FBSSxPQUFKQSxPQUFBQSxTQUFvQztZQUMzREMsdUJBQXVCRCxHQUFJLE9BQUpBLEtBQTRCO1lBQ25ERSx1QkFBdUJGLEdBQUksT0FBSkEsS0FBNEI7WUFHbkRHLDJCQUE0QkgsR0FBSSxPQUFKQSxPQUFBQSxTQUFpQztZQUU3REkseUJBQXlCSjtJQUFZLFVBRnJDRywyQkFFeUJIO1dBQUFBO0dBQXdDO1lBRWpFSyxVQUFVTDtJQUNaLElBQWdFLE1BVjlERCxPQVNVQyxJQUN1QixNQUhqQ0kseUJBRVVKO1FBQUFBO0tBQ1osTUFBQTtJQUNnRSxVQU45REcsMkJBSVVIO1FBQUFBLE9BQUFBO0lBRVosTUFBQTtHQUE4RjtZQUc1Rk0saUJBQWlCTixHQUFFTyxLQUNyQixRQURtQlAsT0FBRU8sV0FBRlAsU0FDbUI7WUFFcENRLE1BQU1SLEdBQUVPLEtBQUlWLEtBQUtZO0lBQ1QsSUFBTmIsTUFKRlUsaUJBR01OLEdBQUVPO0lBRVYsT0FBQSxXQUZtQkUsR0FBWFQsTUFDSkosS0FEVUM7R0FFTTtZQUVsQmEsZ0JBQWdCVixHQUFFTztJQUNWLElBQU5YLE1BUkZVLGlCQU9nQk4sR0FBRU87SUFFcEIsT0FBQSxjQUZrQlAsTUFDZEo7R0FDK0I7WUFFakNlLG9CQUFvQlgsR0FBRU87SUFDZCxJQUFOWCxNQVpGVSxpQkFXb0JOLEdBQUVPO0lBRXhCLE9BQUEsNEJBRnNCUCxNQUNsQko7R0FDd0M7WUFFMUNnQixvQkFBb0JaLEdBQUVPO0lBQ2QsSUFBTlgsTUFoQkZVLGlCQWVvQk4sR0FBRU87SUFFeEIsT0FBQSw0QkFGc0JQLE1BQ2xCSjtHQUN3QztZQUUxQ2lCLG9CQUFvQmIsR0FBRU87SUFDZCxJQUFOWCxNQXBCRlUsaUJBbUJvQk4sR0FBRU87SUFFeEIsT0FBQSw0QkFGc0JQLE1BQ2xCSjtHQUN3QztZQUUxQ2tCLG9CQUFvQmQsR0FBRU87SUFDZCxJQUFOWCxNQXhCRlUsaUJBdUJvQk4sR0FBRU87SUFFeEIsT0FBQSw0QkFGc0JQLE1BQ2xCSjtHQUN3QztZQUUxQ21CLG9CQUFvQmYsR0FBRU87SUFDZCxJQUFOWCxNQTVCRlUsaUJBMkJvQk4sR0FBRU87SUFFeEIsT0FBQSw0QkFGc0JQLE1BQ2xCSjtHQUN3QztZQUUxQ29CLG9CQUFvQmhCLEdBQUVPO0lBQ2QsSUFBTlgsTUFoQ0ZVLGlCQStCb0JOLEdBQUVPO0lBRXhCLE9BQUEsNEJBRnNCUCxNQUNsQko7R0FDd0M7WUFFMUNxQixZQUFZakIsR0FBRU8sS0FBS0U7SUFDckI7S0FBSWQsU0FEVUs7S0FFVkosTUFyQ0ZVLGlCQW1DWU4sR0FBRU87S0FHWlcsUUFEQXRCO0tBRUF1QixRQUpVbkIsT0FBQUE7O0tBS00sR0FGaEJrQixPQUNBQyxTQUNnQixXQUxDVixHQUtDLGNBSmxCZCxRQUVBdUIsUUFBQUE7WUFBQUEsT0FEQXRCOztHQU1JO1lBR053QixPQUFPcEIsR0FBRU8sS0FBRlAsT0FBRU8sY0FDb0I7Ozs7T0FwRTdCYjtPQU9BSztPQUNBRTtPQUNBQztPQUtBRTtPQUZBRDtPQWdCQU87T0FJQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FJQUM7T0FoQ0FUO09BMkNBWTtPQW5EQWY7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7R0N6RFc7Ozs7OztJQUFBO1lBb0JYZ0IsT0FBVUMsT0FBTWYsWUFBTWhCLE9BQU1nQztJQUM5QixXQURrQmhCLE1BQ0QsOEJBRExlLFlBQVkvQixPQUFNZ0M7R0FDa0M7WUFDOURDLFVBQVVGLE9BQU1mLFlBQVlsQjtJQUM5QixXQURrQmtCLE1BQ0QsOEJBRExlLFlBQWtCakM7R0FDeUI7WUFFakRvQztJQUFvQjtJQUFBOzs7Z0NBQ0NDLHVCQUFWQztRQUNkOztpQkFEY0E7MEJBSUpDLElBQUloQyxLQUFLQyxLQUFJZ0M7a0JBQ2pCLE9BTkhKOzJCQU1xQixXQUxBQyxZQUlkRSxJQUFJaEMsS0FBS0MsS0FBSWdDO2lCQUM2Qjs7WUFHMUN6QywyQ0FBQUE7Ozt1QkFBQUE7O3NEQUFBQTt1REFBQUE7Ozs7O1lBRkcwQyxrQkFBRlosZ0JBQVEsV0FBUkEsR0FBRVk7O1lBQ0tDLGdCQUFKQyxpQkFBSEM7UUFBYSxXQUFiQSxLQUFHRCxJQUFJRDs7R0FDNkI7WUFFaERHLE1BQU1DO0lBQ0ksSUFBUmIsUUFBUTtJQUNNLE9BYlpHLGtCQWFZLFdBRlZVLE1BQ0piLGFBakJGRCxRQUVBRztHQWdCMkQ7WUFFM0RZLGdCQUFnQkQsR0FBRWI7SUFDcEI7S0FBOEQsTUFBQSwyQkFEMUNBO0tBQ2hCZSxVQUFRLDhCQURRZjtLQUVXO09BakJ6Qkcsa0JBaUI0QyxXQUZoQ1UsTUFDZEUsZUFyQkZoQixRQUVBRztJQW9CNkIsT0FBQTtHQUE2RDtZQUd4RmMsU0FBT2pEO0lBQ1Q7cUJBQVlpQyxPQUFNZixLQUFJc0IsTUFBS1UsTUFBTUM7YUFDL0IsT0FERixXQUFpQ0EsTUFBckJsQixPQUFNZixLQUFJc0IsTUFEYnhDO1lBRWM7R0FDdEI7WUFFQ2tELEtBQUtoQjtJQUNQO3FCQUFZRCxPQUFNZixLQUFJc0IsTUFBS1UsTUFBS0M7YUFDOUIsT0FERixXQUEyQkQsTUFBZmpCLE9BQU1mLEtBQUlzQixTQURmTjtZQUVxQjtHQUMzQjtZQUVDa0IsWUFBTU4sR0FBRTFCO0lBQ1Y7cUJBQVlhLE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQztzQkFDMUJFLE9BQU1wQixPQUFPZixLQUFLc0IsTUFBTXhDO2NBQUksT0FBaEM7dUJBQWdDLFdBRnhCb0IsR0FFb0JwQixPQUFsQmlDLE9BQU9mLEtBQUtzQixNQURHVSxNQUFLQzthQUN1QzthQUNyRSxPQUFBLFdBSE1MLE1BQ0liLE9BQU1mLEtBQUlzQixNQUFLVSxNQUNyQkc7WUFDMkI7R0FDaEM7WUFFQ0MsV0FBTVIsR0FBRTFCO0lBQ1Y7cUJBQVlhLE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQztzQkFDMUJFLE9BQU1wQixPQUFPZixLQUFLc0IsTUFBTXhDO2NBQUksT0FBdUIsV0FEekJtRCxNQUNwQmxCLE9BQU9mLEtBQUtzQixNQUFpQyxXQUYvQ3BCLEdBRW9CcEI7YUFBZ0M7YUFDNUQsT0FBQSxXQUhNOEMsTUFDSWIsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQ3JCRztZQUMyQjtHQUNoQztZQUVDRSxPQUFNbkMsR0FBRW9DLEdBQ1YsT0FQRUYsV0FNUUUsR0FBRnBDLEdBQ0Q7WUFFTHFDLFNBQU1yQyxHQUFFb0M7SUFFVjtxQkFBWXZCLE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQztzQkFDMUJPLE1BQU1DLFFBQU9DLE1BQUtDLE9BQU16Qzt1QkFDdEIwQyxNQUFNQyxRQUFPQyxNQUFLQyxPQUFNVDtlQUFJLE9BQXVCLFdBRjNCTCxNQUVsQlksUUFBT0MsTUFBS0MsT0FBaUMsV0FEN0I3QyxHQUNFb0M7Y0FBZ0M7Y0FDNUQsT0FBQSxXQUxNQSxNQUdFRyxRQUFPQyxNQUFLQyxPQURHWCxNQUVuQlk7YUFDOEI7YUFFcEMsT0FBQSxXQVBNMUMsTUFFSWEsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQ3JCUTtZQUkyQjtHQUFFO1lBRWpDUSxLQUFLOUMsR0FBRW9DLEdBQ1QsT0FiRUQsT0FZS25DLEdBQUVvQyxHQUNGO1lBRUxXLE1BQU0vQyxHQUFFZ0QsSUFBR0M7SUFDYjtxQkFBWXBDLE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQztzQkFDMUJXLE1BQU1DLFFBQU9DLE1BQUtDLE9BQU1HO3VCQUN0QkUsTUFBTUMsUUFBT0MsTUFBS0MsT0FBTUo7ZUFBSyxPQUF1Qjt3QkFGNUJsQixNQUVsQm9CLFFBQU9DLE1BQUtDLE9BQWtDLFdBSHBEckQsR0FFc0JnRCxJQUNFQztjQUFxQztjQUNqRSxPQUFBLFdBSlNBLE9BRUROLFFBQU9DLE1BQUtDLE9BREdmLE1BRW5Cb0I7YUFDK0I7YUFFckMsT0FBQSxXQU5RRixPQUNFbkMsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQ3JCWTtZQUk0QjtHQUFFO1lBRWxDWSxNQUFNdEQsR0FBRWdELElBQUdDLElBQUdNO0lBQ2hCO3FCQUFZMUMsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO3NCQUMxQlcsTUFBTUMsUUFBT0MsTUFBS0MsT0FBTUc7dUJBQ3RCRSxNQUFNQyxRQUFPQyxNQUFLQyxPQUFNSjt3QkFDdEJPLE1BQU1DLFFBQU9DLE1BQUtDLE9BQU1KO2dCQUMxQixPQUF1Qjt5QkFKQ3hCLE1BR2hCMEIsUUFBT0MsTUFBS0MsT0FDRyxXQUx2QjNELEdBRXNCZ0QsSUFDRUMsSUFDRU07ZUFDUztlQUNyQyxPQUFBLFdBTlVBLE9BR0ZKLFFBQU9DLE1BQUtDLE9BRkN2QixNQUdqQjBCO2NBRStCO2NBQ3JDLE9BQUEsV0FQU1AsT0FFRE4sUUFBT0MsTUFBS0MsT0FER2YsTUFFbkJvQjthQUkrQjthQUVyQyxPQUFBLFdBVFFGLE9BQ0VuQyxPQUFNZixLQUFJc0IsTUFBS1UsTUFDckJZO1lBTzRCO0dBQUU7WUFFbENrQixNQUFNNUQsR0FBRWdELElBQUdDLElBQUdNLElBQUdNO0lBQ25CO3FCQUFZaEQsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO3NCQUMxQlcsTUFBTUMsUUFBT0MsTUFBS0MsT0FBTUc7dUJBQ3RCRSxNQUFNQyxRQUFPQyxNQUFLQyxPQUFNSjt3QkFDdEJPLE1BQU1DLFFBQU9DLE1BQUtDLE9BQU1KO3lCQUN0Qk8sTUFBTUMsUUFBT0MsTUFBS0MsT0FBTUo7aUJBQzFCLE9BQXVCOzBCQUxEOUIsTUFJZGdDLFFBQU9DLE1BQUtDLE9BQ0csV0FOekJqRSxHQUVzQmdELElBQ0VDLElBQ0VNLElBQ0VNO2dCQUNZO2dCQUN4QyxPQUFBLFdBUFdBLE9BSUhKLFFBQU9DLE1BQUtDLE9BSEQ3QixNQUlmZ0M7ZUFFK0I7ZUFDckMsT0FBQSxXQVJVUCxPQUdGSixRQUFPQyxNQUFLQyxPQUZDdkIsTUFHakIwQjtjQUkrQjtjQUNyQyxPQUFBLFdBVFNQLE9BRUROLFFBQU9DLE1BQUtDLE9BREdmLE1BRW5Cb0I7YUFNK0I7YUFFckMsT0FBQSxXQVhRRixPQUNFbkMsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQ3JCWTtZQVM0QjtHQUFFO1lBRWxDd0IsU0FBTUMsR0FBRUM7SUFFVjtxQkFBWXZELE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQztzQkFDMUJFLE9BQU1wQixPQUFPZixLQUFLc0I7Y0FBVSxPQUFoQyxXQUhRZ0QsTUFHRXZELE9BQU9mLEtBQUtzQixNQURHVSxNQUFLQzthQUNtQzthQUNqRSxPQUFBLFdBSk1vQyxNQUVJdEQsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQ3JCRztZQUMyQjtHQUNoQztZQUVDb0MsU0FBTUYsR0FBRUM7SUFFVjtxQkFBWXZELE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQztzQkFDMUJPLE1BQU1DLFFBQU9DLE1BQUtDLE9BQU05RDt1QkFDdEIrRCxNQUFNQyxRQUFPQyxNQUFLQztlQUFVLE9BQWhDLFdBRjRCZCxNQUVsQlksUUFBT0MsTUFBS0MsT0FESWxFO2NBQzhCO2NBQ3hELE9BQUEsV0FMTXlGLE1BR0U3QixRQUFPQyxNQUFLQyxPQURHWCxNQUVuQlk7YUFDOEI7YUFFcEMsT0FBQSxXQVBNeUIsTUFFSXRELE9BQU1mLEtBQUlzQixNQUFLVSxNQUNyQlE7WUFJMkI7R0FBRTtHQXBGeEI7OztPQUNUVDtPQUtBQztPQUtBRTtPQU1BRTtPQU1BQztPQUdBRTtPQVNBUztPQUdBQztPQVFBTztPQVdBTTtPQWFBTTtPQU9BRztZQVdBQyxTQUFNNUMsR0FBRTZDO0lBQ1Y7cUJBQVkxRCxPQUFNZixLQUFJc0IsTUFBS1UsTUFBS0M7c0JBQzFCeUMsT0FBTTNELE9BQU9mLEtBQUtzQixNQUFNdEMsT0FBTWdDO2NBQ2hDLE9BQUEsV0FGdUJnQixNQUNmakIsT0FBT2YsS0FBS3NCLFVBRmRtRCxNQUVvQnpGLFFBQU1nQzthQUNRO2FBQzFDLE9BQUEsV0FKTVksTUFDSWIsT0FBTWYsS0FBSXNCLE1BQ2hCb0QsUUFEMEJ6QztZQUdDO0dBQ2hDO1lBRUMwQyxTQUFNL0MsR0FBRWdEO0lBQ1Y7cUJBQVk3RCxPQUFNZixLQUFJc0IsTUFBS1UsTUFBS0M7c0JBQzFCeUMsT0FBTTNELE9BQU84RCxPQUFLQyxRQUFNOUYsT0FBTWdDO2NBTWhDLE9BUGNoQixNQU9MLDhCQU5EZTt3QkFPTixXQVJxQmlCLE1BQ2ZqQixPQUFPOEQsT0FER3ZELE1BQ1F0QyxPQUFNZ0M7d0JBQWxDLFdBRlE0RCxNQUVFN0QsT0FETWYsS0FDTThFLFFBREc5QyxNQUFLQzthQVVNO2FBQ3BDLE9BQUEsV0FaTUwsTUFDSWIsT0FBTWYsS0FBSXNCLE1BQ2hCb0QsUUFEMEJ6QztZQVdDO0dBQ2hDO0dBckJXO0lBQUEsYUFDVnVDLFVBT0FHO0lBaUJBSTtJQUNBTDtJQUNBTTtZQUVBQyxhQUFNM0MsR0FBRXBDO0lBQUksT0FBTTthQUZsQjhFO2FBRU0xQztzQkFBZ0J6RCxHQUFLLE9BQU8sV0FKbENrRyxVQUlrQyxXQUExQjdFLEdBQWNyQixJQUFpQjtHQUFBO1lBRXZDcUcsU0FBTWhGLEdBQUVvQyxHQUFJLE9BRloyQyxhQUVRM0MsR0FBRnBDLEdBQWE7WUFDbkJpRixTQUFNakYsR0FBRW9DO0lBQUksT0FBTTthQUxsQjBDLGVBS005RSxZQUFnQkEsR0FBSyxPQUgzQitFLGFBR1EzQyxHQUFjcEMsR0FBWTtHQUFBO1lBR2xDa0YsUUFBTWxGLEdBQUVnRCxJQUFHQyxJQUFXLE9BSHRCZ0MsU0FEQUQsU0FJTWhGLEdBQUVnRCxLQUFHQyxJQUEwQjtZQUNyQ2tDLFFBQU1uRixHQUFFZ0QsSUFBR0MsSUFBR007SUFBUSxPQUp0QjBCLFNBQUFBLFNBREFELFNBS01oRixHQUFFZ0QsS0FBR0MsS0FBR007R0FBOEI7WUFDNUM2QixRQUFNcEYsR0FBRWdELElBQUdDLElBQUdNLElBQUdNO0lBQUssT0FMdEJvQixTQUFBQSxTQUFBQSxTQURBRCxTQU1NaEYsR0FBRWdELEtBQUdDLEtBQUdNLEtBQUdNO0dBQWtDO1lBRW5Ed0IsU0FBTWxCLEdBQUVDO0lBQUksT0FBTSxXQVpsQlUsZUFZTVgsbUJBQXFCLE9BQW5CQyxFQUFvQjtHQUFBO1lBQzVCa0IsU0FBTW5CLEdBQUVDO0lBQUksT0FBTTthQWJsQlU7YUFhTVg7c0JBQWdCeEYsR0FBSyxPQVgzQm9HLGFBV1FYLG1CQUFrQyxPQUFwQnpGLEVBQXFCLEdBQUE7R0FBQTtHQWhCaEI7SUFBQTs7T0FDM0JrRztPQUNBTDtPQUNBTTtPQUVBQztPQUVBQztPQUNBQztPQUhBRjtPQU1BRztPQUNBQztPQUNBQztPQUVBQztPQUNBQzs7OztPQXZKRjFFO09BRUFHO09BR0lDO09BV0pTO09BSUFFOzs7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNuQ0E0RCxhQUFjcEcsS0FBS0MsS0FBSW9HO0lBQ3pCLE9BRGdCckc7S0FDaEIsTUFBQTtRQURxQkMsTUFBTEQsWUFFUiwyQkFGaUJxRztLQUd6QixXQUh5QkEsS0FBVHJHLEtBQUtDO0lBRXJCLE1BQUE7R0FDaUI7WUFFZkgsT0FBT0c7SUFDVCxPQU5FbUcsbUJBTXlCLDJCQURsQm5HO0dBQzBDO1lBRWpEcUcsZUFBZWxHO0lBQ2pCLFVBRGlCQTtJQUNqQixPQUFBLDJCQURpQkE7R0FDZTtZQXFCOUJtRyxPQUFPbkcsR0FBRW9HO0lBQ1g7V0FEU3BHLE9BQUFBO0tBQ04sT0FuQkgsMkJBa0JTQSxtQkFBRW9HO2NBQ1I7T0FEUUEsV0F0QlRGLGVBc0JPbEc7S0FmVCw0QkFlU0EsTUFBQUEsTUFBQUEsU0FBQUE7S0FBQUE7OztJQVhLO0tBQVZxRyxVQUFVLDJCQVdMckc7S0FWTHNHLGNBREFEO0tBRUFFLFFBYkZMLGVBc0JPbEc7O1VBVEx1RyxRQURBRCxrQkFEQUQsZ0JBV09EO01BTEcsSUFBVkksVUFBVSwyQkFMVkY7TUFNSiw0QkFJU3RHLE1BQUFBLE1BTEx3RyxZQUtLeEc7TUFBQUEsT0FMTHdHO01BS0t4Rzs7O0tBVkxzRyxrQkFBQUE7O0dBY2lCO1lBRW5CRyxVQUFVekcsR0FDWixPQURZQSxPQUFBQSxTQUNDO1lBRVgwRyxZQUFZMUcsR0FBR0osS0FBS0MsS0FBSThHO0lBQzFCLE9BRGlCL0c7S0FDakIsTUFBQTtRQURzQkMsTUFBTEQsaUNBQVMrRztLQUUxQixNQUFBO0lBWEVSLE9BU1luRyxHQUFRSDtJQUk4QyxVQVBsRTRHLFVBR1l6RztJQUlkLDRCQUowQjJHLEtBQVQvRyxLQUFISSxXQUFRSDtJQUFSRyxPQUFBQSxPQUFRSDs7R0FLRjtZQUVsQitHLGVBQWU1RyxHQUFHSixLQUFLQyxLQUFJZ0Y7SUFDN0IsT0FEb0JqRjtLQUNwQixNQUFBO1FBRHlCQyxNQUFMRCxXQUVaLDJCQUZxQmlGO0tBRTdCLE1BQUE7SUFsQkVzQixPQWdCZW5HLEdBQVFIO0lBSTZCLFVBZHBENEcsVUFVZXpHO0lBSWpCLDRCQUo2QjZFLEdBQVRqRixLQUFISSxXQUFRSDtJQUFSRyxPQUFBQSxPQUFRSDs7R0FLTDtZQUVsQmdILFdBQVc3RztJO1NBRUE2RTtLQUFLLE9BVGhCK0IsZUFPVzVHLE1BRWtDLDJCQUFsQzZFLElBQUFBOztRQURBOUM7SUFBSyxPQWZoQjJFLFlBY1cxRyw0QkFDQStCLElBQUFBOztZQUdYK0UsTUFBTTlHLEdBQUUrRztJQUNWLEdBRFVBLElBQUYvRztLQUNSLE1BQUE7SUFEUUEsT0FBQUEsT0FBRStHO0lBQUYvRyxPQUFBQSxPQUFFK0c7O0dBR1E7WUFFaEJDO1FBQWNmLGdCQUFLckcsZ0JBQUtDO0lBQzFCLE9BQUEsMkJBRGdCb0csS0FBS3JHLEtBQUtDOztZQVV4Qm9ILFdBQWFDO0ksR0FBQUEsU0FBTUMsTUFBTkQsUUFBQUosUUFBTUssY0FBTkw7UUFBV2IsZ0JBQUtyRyxnQkFBS0M7T0FBckJpSCxTQUFxQmpILEtBRXBDLFdBRjBCb0csS0FBS3JHLE1BQWhCa0gsV0FBcUJqSCxNQUFyQmlIO0lBQ2YsTUFBQTs7WUFHRU07UUFBcUN2SCxnQkFBTEQsZ0JBQWhCcUc7SUFDbEIsV0FEa0JBLEtBQWdCckcsS0FBS0M7Ozs7O09BdkVyQ0g7T0FMQXNHO09BdUNBVTtPQU9BRTtPQU9BQztPQUlBQztPQUtBRTtPQVVBQztPQUlBRzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDWEVDLHNCQUF1QjVHLEdBQUU2RztJOztXQUNObkYsY0FBYSxXQUFRLFdBRGpCMUIsR0FDSjBCOztPQUVGO1FBRFM5QztRQUFWa0k7UUFDWk47VUFBYSxzQ0FERE0sV0FGU0Q7T0FJekIsV0FESUwsWUFEc0I1SDs7T0FJVDtRQURnQmtDO1FBQVBoQztRQUFWaUk7UUFDWkM7VUFBYSxzQ0FEREQsYUFMU0Y7T0FPekIsV0FESUcsY0FEc0JsSSxPQUFPZ0M7OztZQUlqQ21HLFFBQVFSLEtBQTRCL0U7SUFDdEMsR0FEVStFO1NBQW9CQyxNQUFwQkQsUUFBQVMsc0JBQW9CUjs7U0FBcEJRO09BQUFBO0tBRVI7SUFDYyxJQUFaTCxZQUFZLGtDQUhOSzthQUlGbEgsRUFBRTBCLEdBS0piO0tBSkosa0NBRkVnRyxXQUNNbkY7S0FTVTtNQVBkTjtlQUdBUDs7WUFDQSxrQ0FQRmdHLFdBTUVoRztNQUlBMEYsY0FBYyxrQ0FWaEJNO01BV2lDLE1BQUEsMkJBRC9CTjtZQXRCSks7Y0FhTTVHLEdBREo2RyxXQVdGLFdBVlFuRixNQVNKNkUscUJBUEFuRjtJQVNpQztXQXhCckN3RixzQkFhTTVHLEdBREo2RyxXQWNKLGtCQWpCc0NuRjtHQWtCRDtZQUVuQ3lGLEtBQUtDLE9BTUh2RztJQUxKLE9BRE91Rzs7V0FFR0MsSUFGSEQsVUFFUSxPQUFBLFdBQUxDLEdBSU54Rzs7V0FLZWpDLElBWFp3SSxVQVdBWixhQVhBWTtpQkFNSHZHLG9CQU9VLE9BYlB1RztPQWVhLElBQVpQLFlBQVksa0NBSmJMO09BS0gsa0NBRElLLFdBVEpoRztPQVdBLFdBQUsscUNBRkRnRyxZQUpXakk7O1dBUk9rQyxNQUhuQnNHLFVBR1l0SSxRQUhac0ksVUFHQUosZUFIQUk7aUJBTUh2RyxvQkFEVSxPQUxQdUc7T0FPYSxJQUFaRSxjQUFZLGtDQUpiTjtPQUtILGtDQURJTSxhQURKekc7T0FHQTtlQUFLLHFDQUZEeUc7ZUFKV3hJO2VBQU9nQzs7R0FlckI7WUFFSHlHO0lBQWtCOztPQUVKOztXQUROM0ksY0FBTSxXQUFOQTtlQUVNOztHQUFJO1lBRWxCNEk7SUFBa0I7O09BQ0s7O1dBQ2Y1SSxjQUFlLFdBQWZBOztXQUNPa0MsZ0JBQVBoQztPQUFlLFdBQU0sMkJBQXJCQSxPQUFPZ0M7O0dBQW1EO1lBRWxFMkc7SUFBc0IsbUJBR0k7UUFGckJqQjtJQUNxQixXQURyQkE7R0FFeUI7WUFNNUJrQixPQUFPN0csT0FBTWYsS0FBSWdDLE1BQUtDO0lBSzVCO0tBQUlwQywyQkFBMkIsOEJBTGxCa0I7S0FNVHBCLHlCQUEyQiw4QkFObEJvQjthQVFUSSxXQUFTSixPQUFPMUIsS0FBS0MsS0FBSWdDO0tBQzNCLEdBRHVCaEMsTUFIckJPO01BS0E7S0FDVTtNQUFSaUM7UUFBUSw4QkFIRGYsT0FBTzFCLEtBQUtDLEtBRnJCSztZQUVxQkwsUUFIckJPO2VBR3lCeUI7aUJBUnZCc0csT0FXQTlGLFNBWGE5QixLQUFJZ0MsTUFBS0M7aUJBY1IsV0FkR0QsTUFXakJGLFNBWGE5QjtlQWlCZixXQWpCd0JpQyxNQVd0QkgsU0FYYTlCLEtBUVVzQjtJQVNOO0lBRXZCLGVBQTRCLDhCQW5CZlAsUUFRVEk7R0FXMEU7R0FHOUU7SUFERTBHOztnQkFDVTlHLE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQztRQUM5QixLQURvQlg7U0FFSixPQUFBLFdBRlNVLE1BQWZqQixPQUFNZixLQUFJc0I7aUJBSWRhLE9BQU1wQixPQUFPZixLQUFLc0I7U0FBUSxPQUFBLFdBSkZXLE1BSWxCbEIsT0FBT2YsS0FBS3NCO1FBQWlDO2lCQUNuRG9ELE9BQU0zRCxPQUFPZixLQUFLc0I7U0FBUSxPQUFBLFdBTFBVLE1BS2JqQixPQUFPZixLQUFLc0I7UUFBb0Q7UUFDMUUsT0E1QkVzRyxPQXNCTTdHLE9BQU1mLEtBS1YwRSxRQURBdkM7T0FFd0I7WUFHOUIyRixpQkFBaUJ0QixHQUFFekYsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO0lBQ3pDLElBQVE4Rjs7TUFBQUE7O2dCQUNNaEgsT0FBT2YsS0FBS3NCLE1BQU1VLE1BQU1DO1FBQ2xDLFFBRGlCakMsTUFGRndHLFVBR0EsOEJBREx6RjtrQkFFUixXQUZnQ2tCLE1BQXhCbEIsT0FBT2YsS0FBS3NCO2tCQUlwQjttQkFBQSxxQkFoQkp1RyxjQVdNRTttQkFDTWhIO21CQUFPZjttQkFBS3NCO21CQUFNVTttQkFBTUM7T0FJc0I7SUFHNUQsT0FBQTthQUFBLHFCQW5CRTRGLGNBV01FO2FBRGFoSDthQUFNZjthQUFJc0I7YUFBS1U7YUFBS0M7R0FTUTtZQUUvQytGLGFBQWExSSxLQUFLWTtJQUNwQjtxQkFBWWEsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQU1DO2FBQy9CLE9BQTRCO3NCQURHQTtzQkFBckJsQjtzQkFBTWYsTUFESFY7c0JBQ09nQztzQkFDUSwrQkFEbEJQLE9BQU1mLEtBREhWLEtBQUtZO1lBRXdDO0dBQzNEO1lBU0MwRixPQUFPWSxHQUFFNUU7SUFDWDtxQkFBWWIsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO2FBQzlCLElBRGdCakMsTUFEVHdHLFVBRU8sOEJBREp6RjtjQUVMLE9BQUEsV0FISWEsTUFDQ2IsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO3NCQUl4QkUsT0FBTXBCLE9BQU9mLEtBQUtzQjtjQUFXLE9BQWpDLFdBTE9NLE1BS0diLE9BQU9mLEtBQUtzQixNQUpDVSxNQUFLQzthQUlzQzthQUNsRSxPQTdCRjZGLGlCQXVCT3RCLEdBQ0d6RixPQUFNZixLQUFJc0IsTUFBS1UsTUFJbkJHO1lBQ3dDO0dBQUU7R0FLbEQ7SUFERThGOztnQkFDVWxILE9BQU1mLEtBQUlzQixhQUFPVztRQUMzQixHQURnQmpDLE1BQ1AsOEJBRENlO1NBRVIsT0FBQSxXQUZ5QmtCLE1BQWpCbEIsT0FBTWYsS0FBSXNCO2FBQUFBLE1BSU4sT0FBQSxXQUphVyxNQUFqQmxCLE9BQU1mLEtBQUlzQjtpQkFNZGEsT0FBTXBCLE9BQU9mLEtBQUtzQjtTQUFRLE9BQUEsV0FOTFcsTUFNZmxCLE9BQU9mLEtBQUtzQjtRQUFvQztpQkFDdERVLEtBQU1qQixPQUFPZixLQUFLc0I7U0FBUSxPQUFBLFdBUExXLE1BT2ZsQixPQUFPZixLQUFLc0I7UUFBbUM7UUFDekQsT0F6RUVzRyxPQWlFTTdHLE9BQU1mLEtBT1ZnQyxNQURBRztPQUV3QjtJQUc5QitGO01BQ0Y7O1FBYkVEOztTQWNFO21CQUNTO21CQUNBO1FBQW1CO1lBRTlCRSxRQUFRM0I7SUFDVixPQURVQSxHQUVMLE9BQUE7SUFHRDtLQURFNUU7O2lCQUNVYixPQUFNZixLQUFJc0IsTUFBS1UsTUFBTUM7U0FBUSxPQUFBLFdBQVJBLE1BQXJCbEIsT0FBTWYsTUFMWndHLE9BS2dCbEY7UUFBK0M7SUFFdkUsT0FuQ0FzRSxPQTRCUVksR0FJSjVFO0dBR007R0FHWjtJQURFNUI7O2dCQUNVZSxPQUFNZixLQUFJc0IsTUFBS1UsTUFBTUM7UUFBUSxPQUFBLFdBQVJBLE1BQXJCbEIsT0FBTWYsS0FBSXNCLE1BQUp0QjtPQUE4QztJQUU5RG9JOztnQkFDVXJILE9BQU1mLEtBQUlzQixNQUFLVSxNQUFNQztRQUMvQixPQUFxQjtpQkFEVUE7aUJBQXJCbEI7aUJBQU1mO2lCQUFJc0I7aUJBQ0MsOEJBRFhQLFNBQU1mO09BQzhCO0lBRzlDYTs7Z0JBQ1VFLE9BQU1mLEtBQUlzQixNQUFLVSxNQUFNQztRQUMvQiwrQkFEVWxCLE9BQU1mO1FBQ2hCLE9BQUEsV0FEK0JpQyxNQUFyQmxCLE9BQU1mLEtBQUlzQjtPQUVFO1lBR3RCK0csaUJBQWlCekc7SUFDbkI7cUJBQVliLE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQztzQkFDMUJFLE9BQU1wQixjQUFTTyxNQUFNeEM7Y0FBSSxPQUFBLFdBRENtRCxNQUNwQmxCLE9BRE1mLEtBQ0dzQixNQUFNeEM7YUFBMkI7YUFDcEQsT0FBQSxXQUhpQjhDLE1BQ1BiLE9BQU1mLEtBQUlzQixNQUFLVSxNQUNyQkc7WUFDMkI7R0FBRTtHQUduQztJQURFbUc7O2dCQUNVdkgsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQU1DO1FBQy9CLEdBRGdCakMsTUFDUCw4QkFEQ2U7U0FFWSxPQUFBO2tCQUZTa0I7a0JBQXJCbEI7a0JBQU1mO2tCQUFJc0I7c0JBRVEsOEJBRmxCUCxPQUFNZjtpQkFBSXNCLE1BSWxCLE9BQUEsV0FKNkJXLE1BQXJCbEIsT0FBTWYsS0FBSXNCO2lCQU1kYSxPQUFNcEIsT0FBT2YsS0FBS3NCO1NBQ3BCLE9BQXVCO2tCQVBJVztrQkFNbkJsQjtrQkFBT2Y7a0JBQUtzQjtzQkFDUyw4QkFEckJQLE9BQU9mO1FBQ2tEO2lCQUMvRDBFLE9BQU0zRCxPQUFPZixLQUFLc0I7U0FDcEIsT0FBQSxXQVQyQlcsTUFRbkJsQixPQUFPZixLQUFLc0I7UUFDTztRQUM3QixPQXpIRXNHLE9BK0dNN0csT0FBTWYsS0FRVjBFLFFBRkF2QztPQUl3QjtJQUkxQm9HOztLQUFBQTs7ZUFDTXhILE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQztPQUM5QixHQURnQmpDLE1BQ1AsOEJBRENlO1FBRWUsT0FBQTtpQkFGS2tCO2lCQUFwQmxCO2lCQUFNZjtpQkFBSXNCO2lCQUVLLDhCQUZmUCxPQUFNZjtnQkFJVm1DLE9BQU1wQixPQUFPZixLQUFLc0I7UUFDcEIsT0FERixXQUxFaUgsbUJBS1F4SCxPQUFPZixLQUFLc0IsTUFKQ1UsTUFBS0M7T0FLb0I7T0FDaEQsT0FyR0Y2RixvQkErRlUvRyxPQUFNZixLQUFJc0IsTUFBS1UsTUFJbkJHO01BRXdDO1lBRTlDcUcsUUFBUXRJO0lBQ1Y7cUJBQVlhLE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQzthQUM5QixHQURnQmpDLE9BQ1AsOEJBRENlOztlQU9Kb0I7MEJBQU1wQixPQUFPZixLQUFLc0I7a0JBQ1osSUFBSm1ILElBQUksOEJBREExSCxPQUFPZjtrQkFFWixHQUFBLFdBVkNFLEdBU0F1STttQkFFQyxPQUFBLFdBVnFCeEcsTUFPbEJsQixPQUFPZixhQUFLc0IsTUFDaEJtSDtrQkFHaUIsVUFBQSxXQVhBekcsTUFPYmpCLE9BQU9mLEtBQUtzQjtrQkFJZixPQUFBLHdDQUhEbUg7aUJBRzREO2NBRWxFLE9BckhGWCxvQkF3R1UvRyxPQUFNZixLQUFJc0IsTUFBS1UsTUFPbkJHOzthQUxJLElBQUpzRyxJQUFJLDhCQUZBMUgsT0FBTWY7YUFHWCxHQUFBLFdBSkdFLEdBR0Z1STtjQUVDLE9BQUEsV0FKdUJ4RyxNQUFwQmxCLE9BQU1mLGFBQUlzQixNQUVkbUg7YUFHaUIsVUFBQSxXQUxFekcsTUFBZmpCLE9BQU1mLEtBQUlzQjthQUtiLE9BQUEsd0NBSERtSDtZQVd3QztHQUFFO1lBRWhEQyxPQUFLRDtJQUVMO0tBREU3Rzs7aUJBQ1ViLE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQztTQUM5QixPQUFHLDhCQURPbEIsT0FBTWYsU0FGYnlJO21CQUNQLFdBQ2tDeEcsTUFBcEJsQixPQUFNZixhQUFJc0IsTUFGakJtSDttQkFLeUI7b0JBSEh6RztvQkFBZmpCO29CQUFNZjtvQkFBSXNCOztvQkFHUSxrQ0FMekJtSDtRQUtxRDtJQUU1RCxPQXZHRTdDLFVBaUdFaEU7R0FNTTtZQUVSK0csU0FBU0Y7SUFFVDtLQURFN0c7O2lCQUNVYixPQUFNZixLQUFJc0IsTUFBS1UsTUFBS0M7U0FDckIsSUFBTDJHLE1BQUssOEJBREM3SCxPQUFNZjtnQkFGVHlJLE1BR0hHO21CQUVDLFdBSHlCM0csTUFBcEJsQixPQUFNZixhQUFJc0IsTUFDaEJzSDttQkFHd0I7b0JBSkg1RztvQkFBZmpCO29CQUFNZjtvQkFBSXNCOztvQkFJUSxrQ0FOckJtSDtRQU1xRDtJQUVoRSxPQWpIRTdDLFVBMEdFaEU7R0FPTTtHQUlSO0lBREVBOztnQkFDVWIsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQU1DO1FBQy9CLE9BQTBCO2lCQURLQTtpQkFBckJsQjtpQkFBTWY7aUJBQUlzQjtpQkFDTSw4QkFEaEJQLE9BQU1mO09BQzJDO0lBSDdENkksV0FuSEFqRCxVQW9IRWhFO1lBTUZrSCxLQUFLbkk7SUFFTDtLQURFaUI7O2lCQUNVYixPQUFNZixLQUFJc0IsTUFBS1UsTUFBS0M7U0FDWixJQUFkd0csSUFBYyw4QkFEUjFILE9BQU1mO2dCQUNaeUksT0FIRDlIO21CQUtFLFdBSHlCc0IsTUFBcEJsQixPQUFNZixhQUFJc0IsTUFDaEJtSDttQkFHd0I7b0JBSkh6RztvQkFBZmpCO29CQUFNZjtvQkFBSXNCOztvQkFJUSxrQ0FOekJYO1FBTXFEO0lBRTVELE9BbElFaUYsVUEySEVoRTtHQU9NO0dBSVI7SUFERW1IOztnQkFDVWhJLE9BQU1mLEtBQUlzQixNQUFLVSxNQUFNQztRQUN2QixJQUFKd0csSUFBSSw4QkFERTFILE9BQU1mO1FBRWhCLE9BQUEsV0FGK0JpQyxNQUFyQmxCLE9BQU1mLGFBQUlzQixNQUNoQm1IO09BQ21DO0lBSnpDTyxZQXBJQXBELFVBcUlFbUQ7SUFTQXZIO0lBQ0F5SDs7Z0JBQ1VsSSxPQUFNZixLQUFJc0IsTUFBS1UsTUFBTUM7UUFDdkIsSUFBSndHLElBQUksOEJBREUxSCxPQUFNZjtRQURwQixPQUFBLFdBQ21DaUMsTUFBckJsQixPQUFNZixhQUFJc0IsTUFDaEJtSCxLQUhKakgsS0FBQUE7T0FJcUQ7SUFOdkQwSCxXQTVJQXRELFVBK0lFcUQ7WUFPRkUsS0FBS2pKO0lBRUw7S0FERTBCOztpQkFDVWIsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO1NBQzlCLE9BQUcsV0FIQS9CLEdBR0UsOEJBREthLE9BQU1mO21CQUVYLFdBRnlCaUMsTUFBcEJsQixPQUFNZixhQUFJc0I7bUJBR2YsV0FIb0JVLE1BQWZqQixPQUFNZixLQUFJc0I7UUFHYztJQUV0QyxPQTdKRXNFLFVBdUpFaEU7R0FNTTtZQUVKbEIsWUFBYTBJLE1BQU1sSixHQUFHbUo7SUFDNUI7cUJBQVl0SSxPQUFNZixLQUFJc0IsTUFBS1UsTUFBS0M7YUFDOUI7Y0FBSTNDLE1BQWMsK0JBRFJ5QixPQUFNZixNQURDb0osVUFBTWxKO2NBR25Cb0osWUFBYyw4QkFGUnZJO2NBR053SSxTQUphSCxPQUViOUo7aUJBRFlVLE1BR1p1SixlQURBRCxtQkFGZ0JoSTs7ZUFTZGE7MEJBQU1wQixPQUFPZixLQUFLc0I7a0JBQ3BCLE9BQUE7MkJBWEFaLFlBSUE2SSxRQUptQnJKLEdBQUdtSjsyQkFVZHRJOzJCQUFPZjsyQkFBS3NCOzJCQVRDVTsyQkFBS0M7aUJBVStDO2VBQ3ZFeUM7MEJBQU0zRCxPQUFPZixLQUFLc0I7a0JBQ3BCLE9BQWlDOzJCQVpQVzsyQkFXbEJsQjsyQkFBT2YsTUFSZnVKOzJCQVFvQmpJOzJCQUNhO2lEQUR6QlAsT0FBT2YsS0FSZnVKLFFBSnNCRjtpQkFheUQ7Y0FFakYsT0FwT0V6QixPQXNOTTdHLE9BQU1mLEtBV1YwRSxRQUZBdkM7O2FBRjZCLE9BQUE7c0JBUExGO3NCQUFwQmxCO3NCQUFNZixNQUdadUo7c0JBSGdCakk7c0JBT2U7NENBUHpCUCxPQUFNZixLQUdadUosUUFKc0JGO1lBZUk7R0FDL0I7WUFFS0csYUFBY3RKLEdBQUdtSjtJQUN2QjtxQkFBWXRJLE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQzthQUM5QjtjQUFJM0MsTUFBYywrQkFEUnlCLE9BQU1mLEtBREVFO2NBR2RvSixZQUFjLDhCQUZSdkk7YUFLVixRQUpJekI7a0JBRFlVLE1BQ1pWLFlBQ0FnSyxtQkFGZ0JoSTs7Z0JBbUJkYTsyQkFBTXBCLE9BQU9mLEtBQUtzQjttQkFDcEIsT0FBQTs0QkF2Q0FaLFlBb0JBcEIsS0FGY1ksR0FBR21KOzRCQW9CVHRJOzRCQUFPZjs0QkFBS3NCOzRCQW5CQ1U7NEJBQUtDO2tCQW9CNkM7Z0JBQ3JFeUM7MkJBQU0zRCxPQUFPZixLQUFLc0I7bUJBQ3BCLE9BQStCOzRCQXRCTFc7NEJBcUJsQmxCOzRCQUFPZixNQXBCZlY7NEJBb0JvQmdDOzRCQUNXLCtCQUR2QlAsT0FBT2YsS0FwQmZWLEtBRmlCK0o7a0JBdUIwRDtlQUU3RSxPQWhRRXpCLE9Bd09NN0csT0FBTWYsS0FxQlYwRSxRQUZBdkM7O2NBRjJCLE9BQUE7dUJBakJIRjt1QkFBcEJsQjt1QkFBTWYsTUFDWlY7dUJBRGdCZ0M7dUJBaUJhLCtCQWpCdkJQLE9BQU1mLEtBQ1pWLEtBRmlCK0o7O2dCQUNMckosT0FFWnNKLG1CQUZnQmhJOztlQVVabUk7MEJBQU0xSSxPQUFPZixLQUFLc0I7a0JBQ3BCLE9BREY7MkJBWEFrSSxhQUFjdEosR0FBR21KOzJCQVdQdEk7MkJBQU9mOzJCQUFLc0I7MkJBVkRVOzJCQUFLQztpQkFXc0M7ZUFDNUR5SDswQkFBTTNJLE9BQU9mLEtBQUtzQjtrQkFDcEIsT0FBQTsyQkFibUJVLE1BWVhqQixPQUFPZixLQUFLc0I7aUJBQ29CO2NBRTFDLE9BdlBBc0csT0F3T003RyxPQUFNZixLQVlSMEosUUFGQUQ7O2FBRkQsT0FBQSxXQVJrQnpILE1BQWZqQixPQUFNZixLQUFJc0I7WUF3QlU7R0FDL0I7WUFFQ3FJLE9BQVF6SixHQUFFc0I7SUFHWixJQXZObUJsQyw0QkFvTlBrQzthQXBOWW9JLElBd05rQnhLLFFBQVFDLEtBQUtDO0tBQzdDLElBQUpxQjs7U0FBQUEsT0FEaURyQjtPQUd4QjtRQUFBLE1BQUEsV0FQckJZLGtDQUFFc0IsR0FLTmI7UUFDeUIsTUFBQSxXQU5yQlQsR0FNd0Isc0JBRlFkLFFBQVFDLE1BQzVDc0I7T0FDYyxHQUFBLHNDQURkQTs7YUFEaURyQixRQUNqRHFCO29CQU9JLDJCQVJnQ3ZCLFFBQVFDLEtBQUtDOzs7SUFTbEM7SUFUVCxPQWpOVnNHO2FBUGlCdEc7O3VCQUNQeUIsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO2VBQ3hCO3dCQUFBLCtCQURJbEIsT0FBTWYsS0FEQ1YsS0FBS3NLOztvQkFJZC9LO2dCQUFLLE9BQUEsV0FIaUJvRCxNQUFwQmxCLE9BQU1mLE1BRENWLFNBQ0dnQyxNQUdaekM7O21CQURBZ0w7ZUFBSyxPQUFBLFdBRlk3SCxNQUFmakIsT0FBTWYsS0FBSXNCLFNBRVp1STtjQUNrQztHQTZOckI7WUFFckJDLFNBQU90SSxHQUFPLE9BZmRtSSxnQkFlMkI5SyxHQUFLLE9BQUxBLEVBQU0sR0FBMUIyQyxHQUE2QjtZQUNwQ3VJLFVBQVV2SSxHQUFJLE9BaEJkbUksdUJBZ0JVbkksR0FBa0M7WUFFNUN3SSxXQUFXOUo7SUFDYixPQWpFTVEsZUFnRU9SLDZCQUMrQyxTQUFFO0dBQUM7WUFFN0QrSixLQUFLekQ7SUFDUCxPQURPQSxHQUVGLE9BQUE7SUFFSyxJQUFKMEQsTUFBSSx1QkFKSDFEO0lBS0ksT0F2T1RaLE9Bc09Jc0UsS0FsUEpsQyxhQWtQSWtDO0dBQzhDO1lBRWxEQyxlQUFlM0Q7SUFDakIsT0FEaUJBLEdBRVosT0FBQTtJQUVLLElBQUowRCxNQUFJLHVCQUpPMUQ7SUFLTixPQTlPVFosT0E2T0lzRSxLQXpQSmxDLGFBeVBJa0M7R0FDeUM7WUFFN0NFLHFCQUFxQmxLLEdBQ3ZCLE9BbEZNUSxlQWlGaUJSLG1CQUM2QjtZQUVsRG1LLHNCQUFzQm5LLEdBQ3hCLE9BbkVNc0osYUFrRWtCdEosbUJBQ3FCO1lBRTNDb0ssb0JBQW9CcEs7SUFDdEIsT0FQRWtLLDhCQU93QjNCLEdBQUssV0FBSSxXQURidkksR0FDSXVJLEdBQWM7R0FBQztZQUV2QzhCLFlBQVkvRCxHQUNkLE9Bdk1FNkIsaUJBK0tBNEIsS0F1Qll6RCxJQUNXO1lBRXZCZ0UsV0FBV3RLLEdBQ2IsT0E5Rk1RLGVBNkZPUixtQkFDNEM7WUFFdkR1SyxZQUFZdkssR0FDZCxPQS9FTXNKLGFBOEVRdEosbUJBQ29DO1lBRWhEd0ssVUFBVXhLO0lBQ1osT0FQRXNLLG9CQU9jL0IsR0FBSyxXQUFJLFdBRGJ2SSxHQUNJdUksR0FBYztHQUFDO1lBRTdCa0MsT0FBU2hFLEtBQStCaUU7SUFDMUMsR0FEV2pFO1NBQVlDLE1BQVpELFFBQUFrRSxjQUFZakU7O1NBQVppRTtJQUNjLFVBQUEsaUJBRGRBO0lBQ2MsT0FBQSxzQ0FEaUJEO0dBQ0M7R0FFaEM7SUFBVEU7O2dCQUFxQnBGLEtBQUsxRixLQUFLc0IsTUFBTVUsTUFBTUM7UUFBUyxPQUFBO09BQXNDO1lBRTFGOEksV0FBVzdLO0lBQ2IsSUFBUTBCLFFBQ0pvSjtzQkFESXBKLE9BSE5rSjs7TUFJRUU7O2dCQUFnQnRGLEtBQUkxRixLQUFJc0IsTUFBS1UsTUFBS0M7UUFDcEMsT0FBQSxXQUZNTCxTQUNZOEQsS0FBSTFGLEtBQUlzQixNQUFLVSxNQUFLQztPQUNMO0lBRnpCTCxPQUlILFdBTFExQixHQUVUOEs7SUFJSixPQUpJQTtHQUlIO1lBRUNDLFNBQVVDLFdBQVVoTDtJQUN0QixJQUFJaUwsWUFEUUQsWUFFSnRKLFFBQ0pvSjtzQkFESXBKLHVCLGtCQUZjMUIsR0FHbEI4Szs7TUFBQUE7O2dCQUFnQnRGLEtBQUkxRixLQUFJc0IsTUFBS1UsTUFBS0M7UUFGbENrSjtlQUFBQTtTQUFBQSxXQURRRDtTQVFSOzs7MENBTkl0Sjs7OzhCQUFBQTs7NkRBQUFBOzhEQUFBQTs7bUJBTUosT0FBQSxtQkFMZ0I4RCxLQUFJMUYsS0FBSXNCLE1BQUtVLE1BQUtDOzs7K0JBRDlCTDs7O21CQUFBQTs7a0RBQUFBO21EQUFBQTs7UUFRSixPQUFBLG1CQVBnQjhELEtBQUkxRixLQUFJc0IsTUFBS1UsTUFBS0M7T0FPTztJQUc3QyxPQVZJK0k7R0FVSDs7O0lBRUNJOztlQXZCQUwsYUFBQUE7a0JBMEJlN0ssR0FBSyxPQWxCcEIrSyxhQWtCZS9LLEdBQTZCO1lBRTVDbUwsT0FBT3hNLEdBQUUrQztJQUNYLE9BQU0scUJBREtBLEdBQ0wscUJBREcvQztHQUNLO1lBRVp5TSxLQUFLek0sR0FBRTBNLElBQUssV0FBUDFNLEdBQUUwTSxJQUFZO1lBRWZDLEtBQUtaO0lBQ1gsS0FEV0EsSUFFQSxPQUFBO1FBQ05hLE9BSE1iLE9BR1RoSixJQUhTZ0o7SUFHYSxPQUFBLGtCQUx0QlUsTUFLQTFKLEdBSEk0SixLQUdEQztHQUE0QjtZQUUvQkMsTUFBTWxGLEdBQUU1RTtJQUNWLE9BRFE0RSxHQUVILE9BQUE7YUFFS21GLEtBRUpuRjtLQUZXLGFBRVhBO2VBREs7ZUFDYSxrQkFidEI4RSxNQU9RMUosR0FJQStKLEtBRUpuRjtJQUFnQztJQUVwQyxPQUpRbUYsS0FKRm5GO0dBUUE7WUFFTm9GLEtBQUtoSztJQUNQLE9BMUJFd0o7c0JBMEJPOUk7Y0FDYyxVQUFBO2NBQUEsT0FBQSxxQkFBckIsa0JBbkJBZ0osTUFpQksxSixHQUNFVTthQUN1QjtHQUFDO1lBRS9CdUosTUFBTWpLLEdBQ1IsT0FBYSxrQkF0QlgwSixNQXFCTTFKLEdBSk5nSyxLQUlNaEssSUFDYTtZQUVuQmtLLFVBQVVsSyxHQUFFbkM7SUFDZCxPQWpDRTJMO3NCQWlDTzlJO2NBQ2MsVUFBQSxrQkExQnJCZ0osTUF3QlUxSixHQUNIVTtjQUNjLE9BQUE7O3VCQUFyQixxQkFGWTdDLEdBRU47O2FBQStCO0dBQUM7WUFFdENzTSxRQUFRdkssR0FBRUk7SUFDWixPQXJDRXdKO3NCQXFDTzlJO2NBQ29CLFVBQUE7Y0FBZCxPQUFBOzt1QkE5QmJnSjt1QkE0QlUxSjt1QkFFRyxxQkFBQyxxQkFGTkosR0FDRGM7YUFDOEI7R0FBQztZQUV0QzBKLE9BQU94SyxHQUFFSTtJQUNYLElBQXNELE1BQUEseUJBQWhCLE1BQUE7SUFBZ0IsT0FBQTs7YUFBdEQ7O2VBakNFMEo7ZUFnQ1MxSjtlQUNHOzJCQUFDLHFCQUROSixHQUpQdUssUUFJT3ZLLEdBQUVJOztHQUNvRDtZQUU3RHFLLFVBQVVySztJQUNaLE9BNUNFd0o7c0JBNENPOUk7a0NBQ3dDLGVBRHhDQSxJQUdNLHdCQUFTO2NBRk8sVUFBQTtjQUFrQixPQUFBOzt1QkFBN0M7O3lCQUFDLHVCQUZPVixtQkFFUyxTQUFJOzs7YUFFRDtHQUNyQjtZQUVEc0ssV0FBV3RLLEdBQ2IsT0FBSyxxQkFEUUEsR0FQWHFLLFVBT1dySyxJQUNHO0dBRytCO0lBQUEsTUFBQTtJQUFsQixNQUFBLHFCQTNIM0JrSTtJQTJIWSxNQUFBO0lBRFpxQztNQUNGOztRQUFBLHFCQUFBLHFCQXZQRXpEOztZQXlQQTBELEtBQU05RSxPQUFNcEgsR0FBR21KO0lBQ2pCO3FCQUFZdEksT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO2FBQ2xCLElBQVJvSyxjQUZFL0U7YUFHTixhQU1VekksR0FBSyxXQUFMQSxHQVBOd04sWUFPb0I7YUFMdEI7Y0FERUM7Z0JBQ0Y7O2tCQTlMRTVMOzs2QkE4TDBCK0g7cUJBQ3BCLFlBQUEsV0FMRXZJLEdBRVJtTSxZQUUwQjVEO2lDQUVoQjt5QkFDSG5CO3FCQUxQK0UsYUFLTy9FO3FCQUEyQjtvQkFBSTtvQkFQM0IrQjs7YUFXZixPQUFBLFdBUklpRCxXQUZNdkwsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO1lBVUs7R0FBRTtZQUVyQ3NLLE9BQUtqRixPQUFNcEgsR0FDYixPQWRFa00sS0FhSzlFLE9BQU1wSCxtQkFDbUM7WUFFOUNzTSxXQUFXbEYsT0FBTXBIO0lBQ25CLG9CQUNJLElBQVNvSCxrQkFBVSxPQUFWQSxNQUFlO0lBQXhCLE9BQUE7O2FBbEJGOEUsS0FnQlc5RSxPQUFNcEgsNkJBQ2dDLFNBQUU7O0dBQ3pCO1lBRTFCdU0sWUFBWW5GLE9BQU1wSDtJQUNwQixrQjtJQUFpQixPQUFBLHVCQVJmcU0sT0FPWWpGLE9BQU1wSDtHQUNBO1lBRWxCd00sYUFBYTlLLEdBQUUxQjtJQUNqQjtxQkFBWWEsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO2FBRUQ7Y0FBekJ0Qyx5QkFBeUIsOEJBRm5Cb0I7c0JBR05vQixPQUFNcEIsT0FBTzhELE9BQUt2RDtjQUNwQjtnQkFGRTNCO29CQUUyQiw4QkFEckJvQjtlQUVILE9BQUE7d0JBTGtCaUIsTUFHZmpCLE9BQU84RCxPQUFLdkQ7Y0FLSDtlQURYaEMsTUFKU3VGLFFBSEQ3RTtlQVFSZ0gsV0FBVywrQkFMVGpHLE9BSE1mLEtBT1JWLEtBUk9ZO2NBVVgsT0FBQSxXQVQwQitCLE1BR3BCbEIsT0FBTzhELE9BQUt2RCxNQUtkMEY7YUFDNEI7YUFFcEMsT0FBQSxXQVphcEYsTUFDSGIsT0FBTWYsS0FBSXNCLE1BQUtVLE1BR3JCRztZQVEyQjtHQUNoQztZQUVDNkUsU0FBbUJwRixHQUFJLE9BZnZCOEssYUFlbUI5SyxtQkFBd0M7WUFDM0QrSyxtQkFBbUIvSyxHQUFJLE9BaEJ2QjhLLGFBZ0JtQjlLLG1CQUFtQztZQUV0RGdMLEtBQUt2SSxHQUFFQztJQUFJLE9BQUEsMkJBQVdELEdBQUVDLEdBQUssV0FBUEQsR0FBRUMsR0FBUyxHQUE1QkQsR0FBRUM7R0FBK0I7WUFDdEN1SSxJQUFJcE4sR0FBR1MsR0FBSSxPQUFBLHVCQUFQVCxHQUFHUyxHQUFXO1lBQ2xCNE0sS0FBS3JOLEdBQUdTLEdBQUksT0FBQSx3QkFBUFQsR0FBR1MsR0FBVztZQUNuQjZNLEtBQUsxSSxHQUFFQyxHQUFHcEUsR0FBSSxPQUFBLGtCQUFKQSxHQUFMbUUsR0FBRUMsR0FBa0I7WUFDekIwSSxLQUFLM0ksR0FBRUMsR0FBRW1FLEdBQUd2SSxHQUFJLE9BQUEsa0JBQUpBLEdBQVBtRSxHQUFFQyxHQUFFbUUsR0FBb0I7WUFDN0J3RSxLQUFLNUksR0FBRUMsR0FBRW1FLEdBQUV5RSxHQUFHaE4sR0FBSSxPQUFBLGtCQUFKQSxHQUFUbUUsR0FBRUMsR0FBRW1FLEdBQUV5RSxHQUFzQjtHQU9mO0lBQUEsMkJBWGxCTCxLQUNBQyxNQUZBRixNQUdBRyxNQUNBQyxNQUNBQztJQUVnQjtZQTJCZEUsTUFBTTNHO0lBQ1I7S0FBSTRHO0tBQ0F4TDs7aUJBQ1ViLE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQztTQUM5QixPQUFHLCtCQURPbEIsT0FBTWYsVUFIWndHO21CQUtDLFdBRnlCdkUsTUFBcEJsQixPQUFNZixhQUFJc0I7bUJBR2YsV0FIb0JVLE1BQWZqQixPQUFNZixLQUFJc0I7UUFHa0I7SUFFMUMsT0E1YUFzRSxPQXFhSXdILE9BQ0F4TDtHQU1VO1lBRVp5TCxNQUFNN0c7SUFDUjtLQUFJNEc7S0FDQXhMOztpQkFDVWIsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO1NBQ2YsVUFBQSwrQkFETGxCLE9BQU1mO1NBQ2IsT0FBQSxrQ0FKQ3dHO21CQUtDLFdBRnlCdkUsTUFBcEJsQixPQUFNZixhQUFJc0I7bUJBR2YsV0FIb0JVLE1BQWZqQixPQUFNZixLQUFJc0I7UUFHa0I7SUFFMUMsT0F0YkFzRSxPQSthSXdILE9BQ0F4TDtHQU1VO1lBRVowTCxNQUFNOUc7SUFDUjtLQUFJNEc7S0FDQXhMOztpQkFDVWIsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO1NBQ2YsVUFBQSwrQkFETGxCLE9BQU1mO1NBQ2IsT0FBQSxrQ0FKQ3dHO21CQUtDLFdBRnlCdkUsTUFBcEJsQixPQUFNZixhQUFJc0I7bUJBR2YsV0FIb0JVLE1BQWZqQixPQUFNZixLQUFJc0I7UUFHa0I7SUFFMUMsT0FoY0FzRSxPQXliSXdILE9BQ0F4TDtHQU1VO0dBR2Q7SUFERTJMO01BbGNGM0g7O1FBWkFvQzs7bUJBK2NpQzNHLElBQUloQztXQUFjLE9BQUEsNEJBQWxCZ0MsSUFBSWhDO1VBQW9EO0lBRXZGbU87TUFyY0Y1SDs7UUFaQW9DOzttQkFrZGlDM0csSUFBSWhDO1dBQWMsT0FBQSw0QkFBbEJnQyxJQUFJaEM7VUFBbUU7SUFFdEdvTztNQXhjRjdIOztRQVpBb0M7O21CQXFkaUMzRyxJQUFJaEM7V0FBYyxPQUFBLDRCQUFsQmdDLElBQUloQztVQUFvRDtJQUV2RnFPO01BM2NGOUg7O1FBWkFvQzs7bUJBd2RpQzNHLElBQUloQztXQUFjLE9BQUEsNEJBQWxCZ0MsSUFBSWhDO1VBQW9EO0lBRXZGc087TUE5Y0YvSDs7UUFaQW9DOzttQkEyZGlDM0csSUFBSWhDO1dBQWMsT0FBQTtvQkFBb0IsNEJBQXRDZ0MsSUFBSWhDO1VBQTBFO0lBRTdHdU87TUFqZEZoSTs7UUFaQW9DOzttQkE4ZGlDM0csSUFBSWhDO1dBQWMsT0FBQTtvQkFBb0IsNEJBQXRDZ0MsSUFBSWhDO1VBQTBFO1lBSTdHd08sUUFBTXJIO0lBQ1I7S0FBSTRHO0tBQ0F4TDs7aUJBQ1ViLE9BQU1mLEtBQUlzQixNQUFLVSxNQUFLQztTQUM5QixPQUFHLDhCQURPbEIsT0FBTWYsVUFIWndHO21CQUtDLFdBRnlCdkUsTUFBcEJsQixPQUFNZixhQUFJc0I7bUJBR2YsV0FIb0JVLE1BQWZqQixPQUFNZixLQUFJc0I7UUFHa0I7SUFFMUMsT0E5ZEFzRSxPQXVkSXdILE9BQ0F4TDtHQU1VO1lBRVprTSxRQUFNdEg7SUFDUjtLQUFJNEc7S0FDQXhMOztpQkFDVWIsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO1NBQ2YsVUFBQSw4QkFETGxCLE9BQU1mO1NBQ2IsT0FBQSxrQ0FKQ3dHO21CQUtDLFdBRnlCdkUsTUFBcEJsQixPQUFNZixhQUFJc0I7bUJBR2YsV0FIb0JVLE1BQWZqQixPQUFNZixLQUFJc0I7UUFHa0I7SUFFMUMsT0F4ZUFzRSxPQWllSXdILE9BQ0F4TDtHQU1VO1lBRVptTSxRQUFNdkg7SUFDUjtLQUFJNEc7S0FDQXhMOztpQkFDVWIsT0FBTWYsS0FBSXNCLE1BQUtVLE1BQUtDO1NBQ2YsVUFBQSwrQkFETGxCLE9BQU1mO1NBQ2IsT0FBQSxrQ0FKQ3dHO21CQUtDLFdBRnlCdkUsTUFBcEJsQixPQUFNZixhQUFJc0I7bUJBR2YsV0FIb0JVLE1BQWZqQixPQUFNZixLQUFJc0I7UUFHa0I7SUFFMUMsT0FsZkFzRSxPQTJlSXdILE9BQ0F4TDtHQU1VO0dBSWQ7SUFERW9NO01BcmZGcEk7O1FBWkFvQzs7bUJBa2dCaUMzRyxJQUFJaEM7V0FBYyxPQUFBLDRCQUFsQmdDLElBQUloQztVQUFvRDtJQUV2RjRPO01BeGZGckk7O1FBWkFvQzs7bUJBcWdCaUMzRyxJQUFJaEM7V0FBYyxPQUFBLDRCQUFsQmdDLElBQUloQztVQUFtRTtJQUV0RzZPO01BM2ZGdEk7O1FBWkFvQzs7bUJBd2dCaUMzRyxJQUFJaEM7V0FBYyxPQUFBLDRCQUFsQmdDLElBQUloQztVQUFvRDtJQUV2RjhPO01BOWZGdkk7O1FBWkFvQzs7bUJBMmdCaUMzRyxJQUFJaEM7V0FBYyxPQUFBLDRCQUFsQmdDLElBQUloQztVQUFvRDtJQUV2RitPO01BamdCRnhJOztRQVpBb0M7O21CQThnQmlDM0csSUFBSWhDO1dBQWMsT0FBQTtvQkFBb0IsNEJBQXRDZ0MsSUFBSWhDO1VBQTBFO0lBRTdHZ1A7TUFwZ0JGekk7O1FBWkFvQzs7bUJBaWhCaUMzRyxJQUFJaEM7V0FBYyxPQUFBO29CQUFvQiw0QkFBdENnQyxJQUFJaEM7VUFBMEU7WUFJN0dpUCxPQUFLOUgsR0FBRXRHO0lBQ0QsSUFBSmdLLE1BQUksdUJBREQxRDtJQUVFLE9BM2dCVFosT0EwZ0JJc0UsS0F0aEJKbEMsYUFzaEJJa0MsS0FES2hLO0dBRW1CO1lBRTFCcU8sS0FBSy9ILEdBQUV0RyxHQUNULE9BM2RBbUksaUJBc2RFaUcsT0FJSzlILEdBQUV0RyxJQUNrQjtZQUV6QnNPLGFBQVdDLE9BQU12TyxHQUNuQixPQWxYSVEsZUFpWFMrTixPQUFNdk8sR0FDd0I7WUFFekN3TyxjQUFZRCxPQUFNdk8sR0FDcEIsT0FuV0lzSixhQWtXVWlGLE9BQU12TyxHQUNnQjtZQUVsQ3lPLFlBQVVGLE9BQU12TztJQUNsQixPQVBFc08sc0JBT2MvRixHQUFLLFdBQUksV0FEYmdHLE9BQ0loRyxHQUFrQixHQURoQnZJO0dBQ21CO0dBR3hCO1lBTWIwTyxrQkFBaUJDLFNBQVFqTixHQUFFUDtJQUM3QixJQUFJMEgsTUFEZThGLFVBSVIscUJBSmdCak4sR0ExZ0J6QnNHLGdCQTBnQnlCdEc7SUFNM0IsT0FBQSw0QkFMSW1ILEtBRHlCMUg7R0FNRTtZQUU3QnlOLGFBQWNELFNBQVFqTixHQUFFSjtJQUMxQixJQUFJbEMsNEJBRHNCa0MsSUFFdEJILEtBQU0sMkJBRE4vQjtJQUVKLDRCQUgwQmtDLE1BRXRCSCxPQURBL0I7SUFFSixPQVhFc1Asa0JBUWNDLFNBQVFqTixHQUVwQlA7R0FFeUI7Ozs7T0FwZjNCaUg7T0FlSUM7T0FrTEpnQztPQXpKQTdCO09BU0FDO09BVUFFO09BbkNBTDtPQTRJQXNCO09BQ0FDO09BdkVBWjtPQXlFQWE7T0FHQUM7T0EwQkFPO09BR0FDO09BR0FDO09BNkhBMUQ7T0F0SkFtRDtPQU9BQztPQUdBQztPQUdBQztPQTBJQXFDO09BcFdBeEU7T0EwVEFnRTtPQTVVQWxFO09BWUFDO09BZ1ZBcUU7T0FHQUM7T0FJQUM7T0FuUEEzRDtPQVVBRTtPQVFBRTs7UUF3UkVpRTtRQVVBRTtRQVVBQztRQWFBRTtRQUdBQztRQUdBQztRQVRBSDtRQVlBSTtRQUdBQzs7UUFLQUM7UUFVQUM7UUFVQUM7UUFjQUU7UUFHQUM7UUFHQUM7UUFUQUg7UUFZQUk7UUFHQUM7T0E5TkZoRDtPQTRGQXVCO09BdkZJcEI7T0FLSkU7T0FVQUU7T0FJQUM7T0FHQUM7T0FRQUU7T0FKQUQ7T0FPQUU7T0FPQUM7T0FsREFkO09BZkFIOztPQWJBTjs7T0F4TkE5Sjs7OztPQXVWQWlNOzs7Ozs7Ozs7O09BREFEO09BRUFFO09BQ0FDO09BQ0FDOzs7O09BTEFMO1dBdUlFMEIsUUFPQUUsY0FHQUUsZUFHQUMsYUFUQUo7O09BbUJGSztPQVFBRTs7UUF6cEJFM0g7UUFvQkFFO1FBb0JBSTtRQUtBQztRQUtBQzs7T0FvR0YzSDtPQUdBb0k7OztFIiwic291cmNlc0NvbnRlbnQiOlsidHlwZSAnYSBzdGF0ZSA9XG4gIHwgUGFydGlhbCBvZiAnYSBwYXJ0aWFsXG4gIHwgRG9uZSAgICBvZiBpbnQgKiAnYVxuICB8IEZhaWwgICAgb2YgaW50ICogc3RyaW5nIGxpc3QgKiBzdHJpbmdcblxuYW5kICdhIHBhcnRpYWwgPVxuICB7IGNvbW1pdHRlZCA6IGludFxuICA7IGNvbnRpbnVlICA6IEJpZ3N0cmluZ2FmLnQgLT4gb2ZmOmludCAtPiBsZW46aW50IC0+IE1vcmUudCAtPiAnYSBzdGF0ZSB9XG5cblxubGV0IHN0YXRlX3RvX29wdGlvbiB4ID0gbWF0Y2ggeCB3aXRoXG4gIHwgRG9uZShfLCB2KSAtPiBTb21lIHZcbiAgfCBGYWlsIF8gICAgIC0+IE5vbmVcbiAgfCBQYXJ0aWFsIF8gIC0+IE5vbmVcblxubGV0IGZhaWxfdG9fc3RyaW5nIG1hcmtzIGVyciA9XG4gIFN0cmluZy5jb25jYXQgXCIgPiBcIiBtYXJrcyBeIFwiOiBcIiBeIGVyclxuXG5sZXQgc3RhdGVfdG9fcmVzdWx0IHggPSBtYXRjaCB4IHdpdGhcbiAgfCBEb25lKF8sIHYpICAgICAgICAgIC0+IE9rIHZcbiAgfCBQYXJ0aWFsIF8gICAgICAgICAgIC0+IEVycm9yIFwiaW5jb21wbGV0ZSBpbnB1dFwiXG4gIHwgRmFpbChfLCBtYXJrcywgZXJyKSAtPiBFcnJvciAoZmFpbF90b19zdHJpbmcgbWFya3MgZXJyKVxuIiwiKCotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ29weXJpZ2h0IChjKSAyMDE3IEluaGFiaXRlZCBUeXBlIExMQy5cblxuICAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgYXV0aG9yIG5vciB0aGUgbmFtZXMgb2YgaGlzIGNvbnRyaWJ1dG9yc1xuICAgICAgIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICAgICAgIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09OVFJJQlVUT1JTIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NcbiAgICBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICAgIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAgICBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbiAgICBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG4gICAgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAgICBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTilcbiAgICBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXG4gICAgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOXG4gICAgQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gICAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG50eXBlIHQgPVxuICB7IG11dGFibGUgcGFyc2VyX2NvbW1pdHRlZF9ieXRlcyA6IGludFxuICA7IGNsaWVudF9jb21taXR0ZWRfYnl0ZXMgICAgICAgICA6IGludFxuICA7IG9mZiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGludFxuICA7IGxlbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGludFxuICA7IGJ1ZmZlciAgICAgICAgICAgICAgICAgICAgICAgICA6IEJpZ3N0cmluZ2FmLnRcbiAgfVxuXG5sZXQgY3JlYXRlIGJ1ZmZlciB+b2ZmIH5sZW4gfmNvbW1pdHRlZF9ieXRlcyA9XG4gIHsgcGFyc2VyX2NvbW1pdHRlZF9ieXRlcyA9IGNvbW1pdHRlZF9ieXRlc1xuICA7IGNsaWVudF9jb21taXR0ZWRfYnl0ZXMgPSBjb21taXR0ZWRfYnl0ZXNcbiAgOyBvZmZcbiAgOyBsZW5cbiAgOyBidWZmZXIgfVxuXG5sZXQgbGVuZ3RoICAgICAgICAgICAgICAgICB0ID0gdC5jbGllbnRfY29tbWl0dGVkX2J5dGVzICsgdC5sZW5cbmxldCBjbGllbnRfY29tbWl0dGVkX2J5dGVzIHQgPSB0LmNsaWVudF9jb21taXR0ZWRfYnl0ZXNcbmxldCBwYXJzZXJfY29tbWl0dGVkX2J5dGVzIHQgPSB0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXNcblxubGV0IGNvbW1pdHRlZF9ieXRlc19kaXNjcmVwYW5jeSB0ID0gdC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzIC0gdC5jbGllbnRfY29tbWl0dGVkX2J5dGVzXG5sZXQgYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQgIHQgPSBjb21taXR0ZWRfYnl0ZXNfZGlzY3JlcGFuY3kgdFxuXG5sZXQgcGFyc2VyX3VuY29tbWl0dGVkX2J5dGVzIHQgPSB0LmxlbiAtIGJ5dGVzX2Zvcl9jbGllbnRfdG9fY29tbWl0IHRcblxubGV0IGludmFyaWFudCB0ID1cbiAgYXNzZXJ0IChwYXJzZXJfY29tbWl0dGVkX2J5dGVzIHQgKyBwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgdCA9IGxlbmd0aCB0KTtcbiAgYXNzZXJ0IChwYXJzZXJfY29tbWl0dGVkX2J5dGVzIHQgLSBjbGllbnRfY29tbWl0dGVkX2J5dGVzICAgdCA9IGJ5dGVzX2Zvcl9jbGllbnRfdG9fY29tbWl0IHQpO1xuOztcblxubGV0IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgPVxuICB0Lm9mZiArIHBvcyAtIHQuY2xpZW50X2NvbW1pdHRlZF9ieXRlc1xuXG5sZXQgYXBwbHkgdCBwb3MgbGVuIH5mID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgZiB0LmJ1ZmZlciB+b2ZmIH5sZW5cblxubGV0IHVuc2FmZV9nZXRfY2hhciB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXQgdC5idWZmZXIgb2ZmXG5cbmxldCB1bnNhZmVfZ2V0X2ludDE2X2xlIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQxNl9sZSB0LmJ1ZmZlciBvZmZcblxubGV0IHVuc2FmZV9nZXRfaW50MzJfbGUgdCBwb3MgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2xlIHQuYnVmZmVyIG9mZlxuXG5sZXQgdW5zYWZlX2dldF9pbnQ2NF9sZSB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50NjRfbGUgdC5idWZmZXIgb2ZmXG5cbmxldCB1bnNhZmVfZ2V0X2ludDE2X2JlIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQxNl9iZSB0LmJ1ZmZlciBvZmZcblxubGV0IHVuc2FmZV9nZXRfaW50MzJfYmUgdCBwb3MgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2JlIHQuYnVmZmVyIG9mZlxuXG5sZXQgdW5zYWZlX2dldF9pbnQ2NF9iZSB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50NjRfYmUgdC5idWZmZXIgb2ZmXG5cbmxldCBjb3VudF93aGlsZSB0IHBvcyB+ZiA9XG4gIGxldCBidWZmZXIgPSB0LmJ1ZmZlciBpblxuICBsZXQgb2ZmICAgID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBsZXQgaSAgICAgID0gcmVmIG9mZiBpblxuICBsZXQgbGltaXQgID0gdC5vZmYgKyB0LmxlbiBpblxuICB3aGlsZSAhaSA8IGxpbWl0ICYmIGYgKEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXQgYnVmZmVyICFpKSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICAhaSAtIG9mZlxuOztcblxubGV0IGNvbW1pdCB0IHBvcyA9XG4gIHQucGFyc2VyX2NvbW1pdHRlZF9ieXRlcyA8LSBwb3Ncbjs7XG4iLCJtb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IFBhcnRpYWwgb2YgJ2EgcGFydGlhbFxuICAgIHwgTGF6eSAgICBvZiAnYSB0IExhenkudFxuICAgIHwgRG9uZSAgICBvZiBpbnQgKiAnYVxuICAgIHwgRmFpbCAgICBvZiBpbnQgKiBzdHJpbmcgbGlzdCAqIHN0cmluZ1xuXG4gIGFuZCAnYSBwYXJ0aWFsID1cbiAgICB7IGNvbW1pdHRlZCA6IGludFxuICAgIDsgY29udGludWUgIDogQmlnc3RyaW5nYWYudCAtPiBvZmY6aW50IC0+IGxlbjppbnQgLT4gTW9yZS50IC0+ICdhIHQgfVxuXG5lbmRcbnR5cGUgJ2Egd2l0aF9zdGF0ZSA9IElucHV0LnQgLT4gIGludCAtPiBNb3JlLnQgLT4gJ2FcblxudHlwZSAnYSBmYWlsdXJlID0gKHN0cmluZyBsaXN0IC0+IHN0cmluZyAtPiAnYSBTdGF0ZS50KSB3aXRoX3N0YXRlXG50eXBlICgnYSwgJ3IpIHN1Y2Nlc3MgPSAoJ2EgLT4gJ3IgU3RhdGUudCkgd2l0aF9zdGF0ZVxuXG50eXBlICdhIHQgPVxuICB7IHJ1biA6ICdyLiAoJ3IgZmFpbHVyZSAtPiAoJ2EsICdyKSBzdWNjZXNzIC0+ICdyIFN0YXRlLnQpIHdpdGhfc3RhdGUgfVxuXG5sZXQgZmFpbF9rICAgIGlucHV0IHBvcyBfIG1hcmtzIG1zZyA9XG4gIFN0YXRlLkZhaWwocG9zIC0gSW5wdXQuY2xpZW50X2NvbW1pdHRlZF9ieXRlcyBpbnB1dCwgbWFya3MsIG1zZylcbmxldCBzdWNjZWVkX2sgaW5wdXQgcG9zIF8gICAgICAgdiAgID1cbiAgU3RhdGUuRG9uZShwb3MgLSBJbnB1dC5jbGllbnRfY29tbWl0dGVkX2J5dGVzIGlucHV0LCB2KVxuXG5sZXQgcmVjIHRvX2V4cG9ydGVkX3N0YXRlID0gZnVuY3Rpb25cbiAgfCBTdGF0ZS5QYXJ0aWFsIHtjb21taXR0ZWQ7Y29udGludWV9IC0+XG4gICAgIEV4cG9ydGVkX3N0YXRlLlBhcnRpYWxcbiAgICAgICB7IGNvbW1pdHRlZFxuICAgICAgIDsgY29udGludWUgPVxuICAgICAgICAgICBmdW4gYnMgfm9mZiB+bGVuIG1vcmUgLT5cbiAgICAgICAgICAgdG9fZXhwb3J0ZWRfc3RhdGUgKGNvbnRpbnVlIGJzIH5vZmYgfmxlbiBtb3JlKX1cbiAgfCBTdGF0ZS5Eb25lIChpLHgpIC0+IEV4cG9ydGVkX3N0YXRlLkRvbmUgKGkseClcbiAgfCBTdGF0ZS5GYWlsIChpLCBzbCwgcykgLT4gRXhwb3J0ZWRfc3RhdGUuRmFpbCAoaSwgc2wsIHMpXG4gIHwgU3RhdGUuTGF6eSB4IC0+IHRvX2V4cG9ydGVkX3N0YXRlIChMYXp5LmZvcmNlIHgpXG5cbmxldCBwYXJzZSBwID1cbiAgbGV0IGlucHV0ID0gSW5wdXQuY3JlYXRlIEJpZ3N0cmluZ2FmLmVtcHR5IH5jb21taXR0ZWRfYnl0ZXM6MCB+b2ZmOjAgfmxlbjowIGluXG4gIHRvX2V4cG9ydGVkX3N0YXRlIChwLnJ1biBpbnB1dCAwIEluY29tcGxldGUgZmFpbF9rIHN1Y2NlZWRfaylcblxubGV0IHBhcnNlX2JpZ3N0cmluZyBwIGlucHV0ID1cbiAgbGV0IGlucHV0ID0gSW5wdXQuY3JlYXRlIGlucHV0IH5jb21taXR0ZWRfYnl0ZXM6MCB+b2ZmOjAgfmxlbjooQmlnc3RyaW5nYWYubGVuZ3RoIGlucHV0KSBpblxuICBFeHBvcnRlZF9zdGF0ZS5zdGF0ZV90b19yZXN1bHQgKHRvX2V4cG9ydGVkX3N0YXRlIChwLnJ1biBpbnB1dCAwIENvbXBsZXRlIGZhaWxfayBzdWNjZWVkX2spKVxuXG5tb2R1bGUgTW9uYWQgPSBzdHJ1Y3RcbiAgbGV0IHJldHVybiB2ID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgICBzdWNjIGlucHV0IHBvcyBtb3JlIHZcbiAgICB9XG5cbiAgbGV0IGZhaWwgbXNnID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIF9zdWNjIC0+XG4gICAgICBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIG1zZ1xuICAgIH1cblxuICBsZXQgKD4+PSkgcCBmID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyB2ID0gKGYgdikucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjYyBpblxuICAgICAgcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJ1xuICAgIH1cblxuICBsZXQgKD4+fCkgcCBmID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyB2ID0gc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyAoZiB2KSBpblxuICAgICAgcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJ1xuICAgIH1cblxuICBsZXQgKDwkPikgZiBtID1cbiAgICBtID4+fCBmXG5cbiAgbGV0ICg8Kj4pIGYgbSA9XG4gICAgKCogZiA+Pj0gZnVuIGYgLT4gbSA+PnwgZiAqKVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MwIGlucHV0MCBwb3MwIG1vcmUwIGYgPVxuICAgICAgICBsZXQgc3VjYzEgaW5wdXQxIHBvczEgbW9yZTEgbSA9IHN1Y2MgaW5wdXQxIHBvczEgbW9yZTEgKGYgbSkgaW5cbiAgICAgICAgbS5ydW4gaW5wdXQwIHBvczAgbW9yZTAgZmFpbCBzdWNjMVxuICAgICAgaW5cbiAgICAgIGYucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYzAgfVxuXG4gIGxldCBsaWZ0IGYgbSA9XG4gICAgZiA8JD4gbVxuXG4gIGxldCBsaWZ0MiBmIG0xIG0yID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjMSBpbnB1dDEgcG9zMSBtb3JlMSBtMSA9XG4gICAgICAgIGxldCBzdWNjMiBpbnB1dDIgcG9zMiBtb3JlMiBtMiA9IHN1Y2MgaW5wdXQyIHBvczIgbW9yZTIgKGYgbTEgbTIpIGluXG4gICAgICAgIG0yLnJ1biBpbnB1dDEgcG9zMSBtb3JlMSBmYWlsIHN1Y2MyXG4gICAgICBpblxuICAgICAgbTEucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYzEgfVxuXG4gIGxldCBsaWZ0MyBmIG0xIG0yIG0zID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjMSBpbnB1dDEgcG9zMSBtb3JlMSBtMSA9XG4gICAgICAgIGxldCBzdWNjMiBpbnB1dDIgcG9zMiBtb3JlMiBtMiA9XG4gICAgICAgICAgbGV0IHN1Y2MzIGlucHV0MyBwb3MzIG1vcmUzIG0zID1cbiAgICAgICAgICAgIHN1Y2MgaW5wdXQzIHBvczMgbW9yZTMgKGYgbTEgbTIgbTMpIGluXG4gICAgICAgICAgbTMucnVuIGlucHV0MiBwb3MyIG1vcmUyIGZhaWwgc3VjYzMgaW5cbiAgICAgICAgbTIucnVuIGlucHV0MSBwb3MxIG1vcmUxIGZhaWwgc3VjYzJcbiAgICAgIGluXG4gICAgICBtMS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjMSB9XG5cbiAgbGV0IGxpZnQ0IGYgbTEgbTIgbTMgbTQgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MxIGlucHV0MSBwb3MxIG1vcmUxIG0xID1cbiAgICAgICAgbGV0IHN1Y2MyIGlucHV0MiBwb3MyIG1vcmUyIG0yID1cbiAgICAgICAgICBsZXQgc3VjYzMgaW5wdXQzIHBvczMgbW9yZTMgbTMgPVxuICAgICAgICAgICAgbGV0IHN1Y2M0IGlucHV0NCBwb3M0IG1vcmU0IG00ID1cbiAgICAgICAgICAgICAgc3VjYyBpbnB1dDQgcG9zNCBtb3JlNCAoZiBtMSBtMiBtMyBtNCkgaW5cbiAgICAgICAgICAgIG00LnJ1biBpbnB1dDMgcG9zMyBtb3JlMyBmYWlsIHN1Y2M0IGluXG4gICAgICAgICAgbTMucnVuIGlucHV0MiBwb3MyIG1vcmUyIGZhaWwgc3VjYzMgaW5cbiAgICAgICAgbTIucnVuIGlucHV0MSBwb3MxIG1vcmUxIGZhaWwgc3VjYzJcbiAgICAgIGluXG4gICAgICBtMS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjMSB9XG5cbiAgbGV0ICggKj4pIGEgYiA9XG4gICAgKCogYSA+Pj0gZnVuIF8gLT4gYiAqKVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnIF8gPSBiLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsIHN1Y2MgaW5cbiAgICAgIGEucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYydcbiAgICB9XG5cbiAgbGV0ICg8KiApIGEgYiA9XG4gICAgKCogYSA+Pj0gZnVuIHggLT4gYiA+PnwgZnVuIF8gLT4geCAqKVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MwIGlucHV0MCBwb3MwIG1vcmUwIHggPVxuICAgICAgICBsZXQgc3VjYzEgaW5wdXQxIHBvczEgbW9yZTEgXyA9IHN1Y2MgaW5wdXQxIHBvczEgbW9yZTEgeCBpblxuICAgICAgICBiLnJ1biBpbnB1dDAgcG9zMCBtb3JlMCBmYWlsIHN1Y2MxXG4gICAgICBpblxuICAgICAgYS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjMCB9XG5lbmRcblxubW9kdWxlIENob2ljZSA9IHN0cnVjdFxuICBsZXQgKDw/PikgcCBtYXJrID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyBtYXJrcyBtc2cgPVxuICAgICAgICBmYWlsIGlucHV0JyBwb3MnIG1vcmUnIChtYXJrOjptYXJrcykgbXNnIGluXG4gICAgICBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsJyBzdWNjXG4gICAgfVxuXG4gIGxldCAoPHw+KSBwIHEgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnIG1hcmtzIG1zZyA9XG4gICAgICAgICgqIFRoZSBvbmx5IHR3byBjb25zdHJ1Y3RvcnMgdGhhdCBpbnRyb2R1Y2UgbmV3IGZhaWx1cmUgY29udGludWF0aW9ucyBhcmVcbiAgICAgICAgICogWzw/Pl0gYW5kIFs8fD5dLiBJZiB0aGUgaW5pdGlhbCBpbnB1dCBwb3NpdGlvbiBpcyBsZXNzIHRoYW4gdGhlIGxlbmd0aFxuICAgICAgICAgKiBvZiB0aGUgY29tbWl0dGVkIGlucHV0LCB0aGVuIGNhbGxpbmcgdGhlIGZhaWx1cmUgY29udGludWF0aW9uIHdpbGxcbiAgICAgICAgICogaGF2ZSB0aGUgZWZmZWN0IG9mIHVud2luZGluZyBhbGwgY2hvaWNlcyBhbmQgY29sbGVjdGluZyBtYXJrcyBhbG9uZ1xuICAgICAgICAgKiB0aGUgd2F5LiAqKVxuICAgICAgICBpZiBwb3MgPCBJbnB1dC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzIGlucHV0JyB0aGVuXG4gICAgICAgICAgZmFpbCBpbnB1dCcgcG9zJyBtb3JlIG1hcmtzIG1zZ1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcS5ydW4gaW5wdXQnIHBvcyBtb3JlJyBmYWlsIHN1Y2MgaW5cbiAgICAgIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwnIHN1Y2NcbiAgICB9XG5lbmRcblxubW9kdWxlIE1vbmFkX3VzZV9mb3JfZGVidWdnaW5nID0gc3RydWN0XG4gIGxldCByZXR1cm4gPSBNb25hZC5yZXR1cm5cbiAgbGV0IGZhaWwgICA9IE1vbmFkLmZhaWxcbiAgbGV0ICg+Pj0pICA9IE1vbmFkLig+Pj0pXG5cbiAgbGV0ICg+PnwpIG0gZiA9IG0gPj49IGZ1biB4IC0+IHJldHVybiAoZiB4KVxuXG4gIGxldCAoPCQ+KSBmIG0gPSBtID4+fCBmXG4gIGxldCAoPCo+KSBmIG0gPSBmID4+PSBmdW4gZiAtPiBtID4+fCBmXG5cbiAgbGV0IGxpZnQgID0gKD4+fClcbiAgbGV0IGxpZnQyIGYgbTEgbTIgICAgICAgPSBmIDwkPiBtMSA8Kj4gbTJcbiAgbGV0IGxpZnQzIGYgbTEgbTIgbTMgICAgPSBmIDwkPiBtMSA8Kj4gbTIgPCo+IG0zXG4gIGxldCBsaWZ0NCBmIG0xIG0yIG0zIG00ID0gZiA8JD4gbTEgPCo+IG0yIDwqPiBtMyA8Kj4gbTRcblxuICBsZXQgKCAqPikgYSBiID0gYSA+Pj0gZnVuIF8gLT4gYlxuICBsZXQgKDwqICkgYSBiID0gYSA+Pj0gZnVuIHggLT4gYiA+PnwgZnVuIF8gLT4geFxuZW5kXG4iLCJ0eXBlIHQgPVxuICB7IG11dGFibGUgYnVmIDogQmlnc3RyaW5nYWYudFxuICA7IG11dGFibGUgb2ZmIDogaW50XG4gIDsgbXV0YWJsZSBsZW4gOiBpbnQgfVxuXG5sZXQgb2ZfYmlnc3RyaW5nIH5vZmYgfmxlbiBidWYgPVxuICBhc3NlcnQgKG9mZiA+PSAwKTtcbiAgYXNzZXJ0IChCaWdzdHJpbmdhZi5sZW5ndGggYnVmID49IGxlbiAtIG9mZik7XG4gIHsgYnVmOyBvZmY7IGxlbiB9XG5cbmxldCBjcmVhdGUgbGVuID1cbiAgb2ZfYmlnc3RyaW5nIH5vZmY6MCB+bGVuOjAgKEJpZ3N0cmluZ2FmLmNyZWF0ZSBsZW4pXG5cbmxldCB3cml0YWJsZV9zcGFjZSB0ID1cbiAgQmlnc3RyaW5nYWYubGVuZ3RoIHQuYnVmIC0gdC5sZW5cblxubGV0IHRyYWlsaW5nX3NwYWNlIHQgPVxuICBCaWdzdHJpbmdhZi5sZW5ndGggdC5idWYgLSAodC5vZmYgKyB0LmxlbilcblxubGV0IGNvbXByZXNzIHQgPVxuICBCaWdzdHJpbmdhZi51bnNhZmVfYmxpdCB0LmJ1ZiB+c3JjX29mZjp0Lm9mZiB0LmJ1ZiB+ZHN0X29mZjowIH5sZW46dC5sZW47XG4gIHQub2ZmIDwtIDBcblxubGV0IGdyb3cgdCB0b19jb3B5ID1cbiAgbGV0IG9sZF9sZW4gPSBCaWdzdHJpbmdhZi5sZW5ndGggdC5idWYgaW5cbiAgbGV0IG5ld19sZW4gPSByZWYgb2xkX2xlbiBpblxuICBsZXQgc3BhY2UgPSB3cml0YWJsZV9zcGFjZSB0IGluXG4gIHdoaWxlIHNwYWNlICsgIW5ld19sZW4gLSBvbGRfbGVuIDwgdG9fY29weSBkb1xuICAgIG5ld19sZW4gOj0gKDMgKiAhbmV3X2xlbikgLyAyXG4gIGRvbmU7XG4gIGxldCBuZXdfYnVmID0gQmlnc3RyaW5nYWYuY3JlYXRlICFuZXdfbGVuIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9ibGl0IHQuYnVmIH5zcmNfb2ZmOnQub2ZmIG5ld19idWYgfmRzdF9vZmY6MCB+bGVuOnQubGVuO1xuICB0LmJ1ZiA8LSBuZXdfYnVmO1xuICB0Lm9mZiA8LSAwXG5cbmxldCBlbnN1cmUgdCB0b19jb3B5ID1cbiAgaWYgdHJhaWxpbmdfc3BhY2UgdCA8IHRvX2NvcHkgdGhlblxuICAgIGlmIHdyaXRhYmxlX3NwYWNlIHQgPj0gdG9fY29weVxuICAgIHRoZW4gY29tcHJlc3MgdFxuICAgIGVsc2UgZ3JvdyB0IHRvX2NvcHlcblxubGV0IHdyaXRlX3BvcyB0ID1cbiAgdC5vZmYgKyB0LmxlblxuXG5sZXQgZmVlZF9zdHJpbmcgdCB+b2ZmIH5sZW4gc3RyID1cbiAgYXNzZXJ0IChvZmYgPj0gMCk7XG4gIGFzc2VydCAoU3RyaW5nLmxlbmd0aCBzdHIgPj0gbGVuIC0gb2ZmKTtcbiAgZW5zdXJlIHQgbGVuO1xuICBCaWdzdHJpbmdhZi51bnNhZmVfYmxpdF9mcm9tX3N0cmluZyBzdHIgfnNyY19vZmY6b2ZmIHQuYnVmIH5kc3Rfb2ZmOih3cml0ZV9wb3MgdCkgfmxlbjtcbiAgdC5sZW4gPC0gdC5sZW4gKyBsZW5cblxubGV0IGZlZWRfYmlnc3RyaW5nIHQgfm9mZiB+bGVuIGIgPVxuICBhc3NlcnQgKG9mZiA+PSAwKTtcbiAgYXNzZXJ0IChCaWdzdHJpbmdhZi5sZW5ndGggYiA+PSBsZW4gLSBvZmYpO1xuICBlbnN1cmUgdCBsZW47XG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9ibGl0IGIgfnNyY19vZmY6b2ZmIHQuYnVmIH5kc3Rfb2ZmOih3cml0ZV9wb3MgdCkgfmxlbjtcbiAgdC5sZW4gPC0gdC5sZW4gKyBsZW5cblxubGV0IGZlZWRfaW5wdXQgdCA9IGZ1bmN0aW9uXG4gIHwgYFN0cmluZyAgICBzIC0+IGZlZWRfc3RyaW5nICAgIHQgfm9mZjowIH5sZW46KFN0cmluZyAgICAgLmxlbmd0aCBzKSBzXG4gIHwgYEJpZ3N0cmluZyBiIC0+IGZlZWRfYmlnc3RyaW5nIHQgfm9mZjowIH5sZW46KEJpZ3N0cmluZ2FmLmxlbmd0aCBiKSBiXG5cbmxldCBzaGlmdCB0IG4gPVxuICBhc3NlcnQgKHQubGVuID49IG4pO1xuICB0Lm9mZiA8LSB0Lm9mZiArIG47XG4gIHQubGVuIDwtIHQubGVuIC0gblxuXG5sZXQgZm9yX3JlYWRpbmcgeyBidWY7IG9mZjsgbGVuIH0gPVxuICBCaWdzdHJpbmdhZi5zdWIgfm9mZiB+bGVuIGJ1ZlxuXG5tb2R1bGUgVW5jb25zdW1lZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgYnVmIDogQmlnc3RyaW5nYWYudFxuICAgIDsgb2ZmIDogaW50XG4gICAgOyBsZW4gOiBpbnQgfVxuZW5kXG5cbmxldCB1bmNvbnN1bWVkID8oc2hpZnQ9MCkgeyBidWY7IG9mZjsgbGVuIH0gPVxuICBhc3NlcnQgKGxlbiA+PSBzaGlmdCk7XG4gIHsgVW5jb25zdW1lZC5idWY7IG9mZiA9IG9mZiArIHNoaWZ0OyBsZW4gPSBsZW4gLSBzaGlmdCB9XG5cbmxldCBvZl91bmNvbnN1bWVkIHsgVW5jb25zdW1lZC5idWY7IG9mZjsgbGVuIH0gPVxuICB7IGJ1Zjsgb2ZmOyBsZW4gfVxuXG50eXBlIHVuY29uc3VtZWQgPSBVbmNvbnN1bWVkLnQgPVxuICB7IGJ1ZiA6IEJpZ3N0cmluZ2FmLnRcbiAgOyBvZmYgOiBpbnRcbiAgOyBsZW4gOiBpbnQgfVxuIiwiKCotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ29weXJpZ2h0IChjKSAyMDE2IEluaGFiaXRlZCBUeXBlIExMQy5cblxuICAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgYXV0aG9yIG5vciB0aGUgbmFtZXMgb2YgaGlzIGNvbnRyaWJ1dG9yc1xuICAgICAgIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICAgICAgIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09OVFJJQlVUT1JTIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NcbiAgICBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICAgIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAgICBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbiAgICBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG4gICAgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAgICBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTilcbiAgICBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXG4gICAgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOXG4gICAgQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gICAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG5tb2R1bGUgQmlnYXJyYXkgPSBzdHJ1Y3RcbiAgKCogRG8gbm90IGFjY2VzcyBCaWdhcnJheSBvcGVyYXRpb25zIGRpcmVjdGx5LiBJZiBhbnl0aGluZydzIG5lZWRlZCwgcmVmZXIgdG9cbiAgICogdGhlIGludGVybmFsIEJpZ3N0cmluZyBtb2R1bGUuICopXG5lbmRcblxudHlwZSBiaWdzdHJpbmcgPSBCaWdzdHJpbmdhZi50XG5cblxubW9kdWxlIFVuYnVmZmVyZWQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQYXJzZXJcblxuICBpbmNsdWRlIEV4cG9ydGVkX3N0YXRlXG5cbiAgdHlwZSBtb3JlID0gTW9yZS50ID1cbiAgICB8IENvbXBsZXRlXG4gICAgfCBJbmNvbXBsZXRlXG5lbmRcblxuaW5jbHVkZSBVbmJ1ZmZlcmVkXG5pbmNsdWRlIFBhcnNlci5Nb25hZFxuaW5jbHVkZSBQYXJzZXIuQ2hvaWNlXG5cbm1vZHVsZSBCdWZmZXJlZCA9IHN0cnVjdFxuICB0eXBlIHVuY29uc3VtZWQgPSBCdWZmZXJpbmcudW5jb25zdW1lZCA9XG4gICAgeyBidWYgOiBiaWdzdHJpbmdcbiAgICA7IG9mZiA6IGludFxuICAgIDsgbGVuIDogaW50IH1cblxuICB0eXBlIGlucHV0ID1cbiAgICBbIGBCaWdzdHJpbmcgb2YgYmlnc3RyaW5nXG4gICAgfCBgU3RyaW5nICAgIG9mIHN0cmluZyBdXG5cbiAgdHlwZSAnYSBzdGF0ZSA9XG4gICAgfCBQYXJ0aWFsIG9mIChbIGlucHV0IHwgYEVvZiBdIC0+ICdhIHN0YXRlKVxuICAgIHwgRG9uZSAgICBvZiB1bmNvbnN1bWVkICogJ2FcbiAgICB8IEZhaWwgICAgb2YgdW5jb25zdW1lZCAqIHN0cmluZyBsaXN0ICogc3RyaW5nXG5cbiAgbGV0IGZyb21fdW5idWZmZXJlZF9zdGF0ZSB+ZiBidWZmZXJpbmcgPSBmdW5jdGlvblxuICAgIHwgVW5idWZmZXJlZC5QYXJ0aWFsIHAgICAgICAgICAtPiBQYXJ0aWFsIChmIHApXG4gICAgfCBVbmJ1ZmZlcmVkLkRvbmUoY29uc3VtZWQsIHYpIC0+XG4gICAgICBsZXQgdW5jb25zdW1lZCA9IEJ1ZmZlcmluZy51bmNvbnN1bWVkIH5zaGlmdDpjb25zdW1lZCBidWZmZXJpbmcgaW5cbiAgICAgIERvbmUodW5jb25zdW1lZCwgdilcbiAgICB8IFVuYnVmZmVyZWQuRmFpbChjb25zdW1lZCwgbWFya3MsIG1zZykgLT5cbiAgICAgIGxldCB1bmNvbnN1bWVkID0gQnVmZmVyaW5nLnVuY29uc3VtZWQgfnNoaWZ0OmNvbnN1bWVkIGJ1ZmZlcmluZyBpblxuICAgICAgRmFpbCh1bmNvbnN1bWVkLCBtYXJrcywgbXNnKVxuXG4gIGxldCBwYXJzZSA/KGluaXRpYWxfYnVmZmVyX3NpemU9MHgxMDAwKSBwID1cbiAgICBpZiBpbml0aWFsX2J1ZmZlcl9zaXplIDwgMSB0aGVuXG4gICAgICBmYWlsd2l0aCBcInBhcnNlOiBpbnZhbGlkIGFyZ3VtZW50LCBpbml0aWFsX2J1ZmZlcl9zaXplIDwgMVwiO1xuICAgIGxldCBidWZmZXJpbmcgPSBCdWZmZXJpbmcuY3JlYXRlIGluaXRpYWxfYnVmZmVyX3NpemUgaW5cbiAgICBsZXQgcmVjIGYgcCBpbnB1dCA9XG4gICAgICBCdWZmZXJpbmcuc2hpZnQgYnVmZmVyaW5nIHAuY29tbWl0dGVkO1xuICAgICAgbGV0IG1vcmUgOiBNb3JlLnQgPVxuICAgICAgICBtYXRjaCBpbnB1dCB3aXRoXG4gICAgICAgIHwgYEVvZiAgICAgICAgICAgIC0+IENvbXBsZXRlXG4gICAgICAgIHwgI2lucHV0IGFzIGlucHV0IC0+XG4gICAgICAgICAgQnVmZmVyaW5nLmZlZWRfaW5wdXQgYnVmZmVyaW5nIGlucHV0O1xuICAgICAgICAgIEluY29tcGxldGVcbiAgICAgIGluXG4gICAgICBsZXQgZm9yX3JlYWRpbmcgPSBCdWZmZXJpbmcuZm9yX3JlYWRpbmcgYnVmZmVyaW5nIGluXG4gICAgICBwLmNvbnRpbnVlIGZvcl9yZWFkaW5nIH5vZmY6MCB+bGVuOihCaWdzdHJpbmdhZi5sZW5ndGggZm9yX3JlYWRpbmcpIG1vcmVcbiAgICAgIHw+IGZyb21fdW5idWZmZXJlZF9zdGF0ZSBidWZmZXJpbmcgfmZcbiAgICBpblxuICAgIFVuYnVmZmVyZWQucGFyc2UgcFxuICAgIHw+IGZyb21fdW5idWZmZXJlZF9zdGF0ZSBidWZmZXJpbmcgfmZcblxuICBsZXQgZmVlZCBzdGF0ZSBpbnB1dCA9XG4gICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgIHwgUGFydGlhbCBrIC0+IGsgaW5wdXRcbiAgICB8IEZhaWwodW5jb25zdW1lZCwgbWFya3MsIG1zZykgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGlucHV0IHdpdGhcbiAgICAgIHwgYEVvZiAgIC0+IHN0YXRlXG4gICAgICB8ICNpbnB1dCBhcyBpbnB1dCAtPlxuICAgICAgICBsZXQgYnVmZmVyaW5nID0gQnVmZmVyaW5nLm9mX3VuY29uc3VtZWQgdW5jb25zdW1lZCBpblxuICAgICAgICBCdWZmZXJpbmcuZmVlZF9pbnB1dCBidWZmZXJpbmcgaW5wdXQ7XG4gICAgICAgIEZhaWwoQnVmZmVyaW5nLnVuY29uc3VtZWQgYnVmZmVyaW5nLCBtYXJrcywgbXNnKVxuICAgICAgZW5kXG4gICAgfCBEb25lKHVuY29uc3VtZWQsIHYpIC0+XG4gICAgICBiZWdpbiBtYXRjaCBpbnB1dCB3aXRoXG4gICAgICB8IGBFb2YgICAtPiBzdGF0ZVxuICAgICAgfCAjaW5wdXQgYXMgaW5wdXQgLT5cbiAgICAgICAgbGV0IGJ1ZmZlcmluZyA9IEJ1ZmZlcmluZy5vZl91bmNvbnN1bWVkIHVuY29uc3VtZWQgaW5cbiAgICAgICAgQnVmZmVyaW5nLmZlZWRfaW5wdXQgYnVmZmVyaW5nIGlucHV0O1xuICAgICAgICBEb25lKEJ1ZmZlcmluZy51bmNvbnN1bWVkIGJ1ZmZlcmluZywgdilcbiAgICAgIGVuZFxuXG4gIGxldCBzdGF0ZV90b19vcHRpb24gPSBmdW5jdGlvblxuICAgIHwgRG9uZShfLCB2KSAtPiBTb21lIHZcbiAgICB8IFBhcnRpYWwgXyAgLT4gTm9uZVxuICAgIHwgRmFpbCBfICAgICAtPiBOb25lXG5cbiAgbGV0IHN0YXRlX3RvX3Jlc3VsdCA9IGZ1bmN0aW9uXG4gICAgfCBQYXJ0aWFsIF8gICAgICAgICAgIC0+IEVycm9yIFwiaW5jb21wbGV0ZSBpbnB1dFwiXG4gICAgfCBEb25lKF8sIHYpICAgICAgICAgIC0+IE9rIHZcbiAgICB8IEZhaWwoXywgbWFya3MsIG1zZykgLT4gRXJyb3IgKFVuYnVmZmVyZWQuZmFpbF90b19zdHJpbmcgbWFya3MgbXNnKVxuXG4gIGxldCBzdGF0ZV90b191bmNvbnN1bWVkID0gZnVuY3Rpb25cbiAgICB8IERvbmUodW5jb25zdW1lZCwgXylcbiAgICB8IEZhaWwodW5jb25zdW1lZCwgXywgXykgLT4gU29tZSB1bmNvbnN1bWVkXG4gICAgfCBQYXJ0aWFsIF8gICAgICAgICAgICAgIC0+IE5vbmVcblxuZW5kXG5cbigqKiBCRUdJTjogZ2V0dGluZyBpbnB1dCAqKVxuXG5sZXQgcmVjIHByb21wdCBpbnB1dCBwb3MgZmFpbCBzdWNjID1cbiAgKCogW3Byb21wdF0gc2hvdWxkIG9ubHkgY2FsbCBbc3VjY10gaWYgaXQgaGFzIHJlY2VpdmVkIG1vcmUgaW5wdXQuIElmIHRoZXJlXG4gICAqIGlzIG5vIGNoYW5jZSB0aGF0IHRoZSBpbnB1dCB3aWxsIGdyb3csIGkuZS4sIFttb3JlID0gQ29tcGxldGVdLCB0aGVuXG4gICAqIFtwcm9tcHRdIHNob3VsZCBjYWxsIFtmYWlsXS4gT3RoZXJ3aXNlIChpbiB0aGUgY2FzZSB3aGVyZSB0aGUgaW5wdXRcbiAgICogaGFzbid0IGdyb3duIGJ1dCBbbW9yZSA9IEluY29tcGxldGVdIGp1c3QgcHJvbXB0IGFnYWluLiAqKVxuICBsZXQgcGFyc2VyX3VuY29tbWl0dGVkX2J5dGVzID0gSW5wdXQucGFyc2VyX3VuY29tbWl0dGVkX2J5dGVzIGlucHV0IGluXG4gIGxldCBwYXJzZXJfY29tbWl0dGVkX2J5dGVzICAgPSBJbnB1dC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzICAgaW5wdXQgaW5cbiAgKCogVGhlIGNvbnRpbnVhdGlvbiBzaG91bGQgbm90IGhvbGQgYW55IHJlZmVyZW5jZXMgdG8gaW5wdXQgYWJvdmUuICopXG4gIGxldCBjb250aW51ZSBpbnB1dCB+b2ZmIH5sZW4gbW9yZSA9XG4gICAgaWYgbGVuIDwgcGFyc2VyX3VuY29tbWl0dGVkX2J5dGVzIHRoZW5cbiAgICAgIGZhaWx3aXRoIFwicHJvbXB0OiBpbnB1dCBzaHJ1bmshXCI7XG4gICAgbGV0IGlucHV0ID0gSW5wdXQuY3JlYXRlIGlucHV0IH5vZmYgfmxlbiB+Y29tbWl0dGVkX2J5dGVzOnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgaW5cbiAgICBpZiBsZW4gPSBwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgdGhlblxuICAgICAgbWF0Y2ggKG1vcmUgOiBNb3JlLnQpIHdpdGhcbiAgICAgIHwgQ29tcGxldGUgICAtPiBmYWlsIGlucHV0IHBvcyBNb3JlLkNvbXBsZXRlXG4gICAgICB8IEluY29tcGxldGUgLT4gcHJvbXB0IGlucHV0IHBvcyBmYWlsIHN1Y2NcbiAgICBlbHNlXG4gICAgICBzdWNjIGlucHV0IHBvcyBtb3JlXG4gIGluXG4gIFN0YXRlLlBhcnRpYWwgeyBjb21taXR0ZWQgPSBJbnB1dC5ieXRlc19mb3JfY2xpZW50X3RvX2NvbW1pdCBpbnB1dDsgY29udGludWUgfVxuXG5sZXQgZGVtYW5kX2lucHV0ID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgbWF0Y2ggKG1vcmUgOiBNb3JlLnQpIHdpdGhcbiAgICB8IENvbXBsZXRlICAgLT4gZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcIm5vdCBlbm91Z2ggaW5wdXRcIlxuICAgIHwgSW5jb21wbGV0ZSAtPlxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID0gc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyAoKVxuICAgICAgYW5kIGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnID0gZmFpbCBpbnB1dCcgcG9zJyBtb3JlJyBbXSBcIm5vdCBlbm91Z2ggaW5wdXRcIiBpblxuICAgICAgcHJvbXB0IGlucHV0IHBvcyBmYWlsJyBzdWNjJ1xuICB9XG5cbmxldCBlbnN1cmVfc3VzcGVuZGVkIG4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjID1cbiAgbGV0IHJlYyBnbyA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCcgc3VjYycgLT5cbiAgICAgIGlmIHBvcycgKyBuIDw9IElucHV0Lmxlbmd0aCBpbnB1dCcgdGhlblxuICAgICAgICBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyAoKVxuICAgICAgZWxzZVxuICAgICAgICAoZGVtYW5kX2lucHV0ICo+IGdvKS5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCcgc3VjYydcbiAgICB9XG4gIGluXG4gIChkZW1hbmRfaW5wdXQgKj4gZ28pLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2NcblxubGV0IHVuc2FmZV9hcHBseSBsZW4gfmYgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgc3VjYyBpbnB1dCAocG9zICsgbGVuKSBtb3JlIChJbnB1dC5hcHBseSBpbnB1dCBwb3MgbGVuIH5mKVxuICB9XG5cbmxldCB1bnNhZmVfYXBwbHlfb3B0IGxlbiB+ZiA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIG1hdGNoIElucHV0LmFwcGx5IGlucHV0IHBvcyBsZW4gfmYgd2l0aFxuICAgIHwgRXJyb3IgZSAtPiBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIGVcbiAgICB8IE9rICAgIHggLT4gc3VjYyBpbnB1dCAocG9zICsgbGVuKSBtb3JlIHhcbiAgfVxuXG5sZXQgZW5zdXJlIG4gcCA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGlmIHBvcyArIG4gPD0gSW5wdXQubGVuZ3RoIGlucHV0XG4gICAgdGhlbiBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2NcbiAgICBlbHNlXG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgKCkgPSBwLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsIHN1Y2MgaW5cbiAgICAgIGVuc3VyZV9zdXNwZW5kZWQgbiBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnIH1cblxuKCoqIEVORDogZ2V0dGluZyBpbnB1dCAqKVxuXG5sZXQgYXRfZW5kX29mX2lucHV0ID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgXyBzdWNjIC0+XG4gICAgaWYgcG9zIDwgSW5wdXQubGVuZ3RoIGlucHV0IHRoZW5cbiAgICAgIHN1Y2MgaW5wdXQgcG9zIG1vcmUgZmFsc2VcbiAgICBlbHNlIG1hdGNoIG1vcmUgd2l0aFxuICAgIHwgQ29tcGxldGUgLT4gc3VjYyBpbnB1dCBwb3MgbW9yZSB0cnVlXG4gICAgfCBJbmNvbXBsZXRlIC0+XG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgPSBzdWNjIGlucHV0JyBwb3MnIG1vcmUnIGZhbHNlXG4gICAgICBhbmQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgPSBzdWNjIGlucHV0JyBwb3MnIG1vcmUnIHRydWUgaW5cbiAgICAgIHByb21wdCBpbnB1dCBwb3MgZmFpbCcgc3VjYydcbiAgfVxuXG5sZXQgZW5kX29mX2lucHV0ID1cbiAgYXRfZW5kX29mX2lucHV0XG4gID4+PSBmdW5jdGlvblxuICAgIHwgdHJ1ZSAgLT4gcmV0dXJuICgpXG4gICAgfCBmYWxzZSAtPiBmYWlsIFwiZW5kX29mX2lucHV0XCJcblxubGV0IGFkdmFuY2UgbiA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gZmFpbCBcImFkdmFuY2VcIlxuICBlbHNlXG4gICAgbGV0IHAgPVxuICAgICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPiBzdWNjIGlucHV0IChwb3MgKyBuKSBtb3JlICgpIH1cbiAgICBpblxuICAgIGVuc3VyZSBuIHBcblxubGV0IHBvcyA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT4gc3VjYyBpbnB1dCBwb3MgbW9yZSBwb3MgfVxuXG5sZXQgYXZhaWxhYmxlID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPlxuICAgIHN1Y2MgaW5wdXQgcG9zIG1vcmUgKElucHV0Lmxlbmd0aCBpbnB1dCAtIHBvcylcbiAgfVxuXG5sZXQgY29tbWl0ID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPlxuICAgIElucHV0LmNvbW1pdCBpbnB1dCBwb3M7XG4gICAgc3VjYyBpbnB1dCBwb3MgbW9yZSAoKSB9XG5cbigqIERvIG5vdCB1c2UgdGhpcyBpZiBbcF0gY29udGFpbnMgYSBbY29tbWl0XS4gKilcbmxldCB1bnNhZmVfbG9va2FoZWFkIHAgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBsZXQgc3VjYycgaW5wdXQnIF8gbW9yZScgdiA9IHN1Y2MgaW5wdXQnIHBvcyBtb3JlJyB2IGluXG4gICAgcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJyB9XG5cbmxldCBwZWVrX2NoYXIgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgaWYgcG9zIDwgSW5wdXQubGVuZ3RoIGlucHV0IHRoZW5cbiAgICAgIHN1Y2MgaW5wdXQgcG9zIG1vcmUgKFNvbWUgKElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MpKVxuICAgIGVsc2UgaWYgbW9yZSA9IENvbXBsZXRlIHRoZW5cbiAgICAgIHN1Y2MgaW5wdXQgcG9zIG1vcmUgTm9uZVxuICAgIGVsc2VcbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyA9XG4gICAgICAgIHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgKFNvbWUgKElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCcgcG9zJykpXG4gICAgICBhbmQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICBzdWNjIGlucHV0JyBwb3MnIG1vcmUnIE5vbmUgaW5cbiAgICAgIHByb21wdCBpbnB1dCBwb3MgZmFpbCcgc3VjYydcbiAgfVxuXG4oKiBUaGlzIHBhcnNlciBpcyB0b28gaW1wb3J0YW50IHRvIG5vdCBiZSBvcHRpbWl6ZWQuIERvIGEgY3VzdG9tIGpvYi4gKilcbmxldCByZWMgcGVla19jaGFyX2ZhaWwgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBpZiBwb3MgPCBJbnB1dC5sZW5ndGggaW5wdXRcbiAgICB0aGVuIHN1Y2MgaW5wdXQgcG9zIG1vcmUgKElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MpXG4gICAgZWxzZVxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnICgpID1cbiAgICAgICAgcGVla19jaGFyX2ZhaWwucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjYyBpblxuICAgICAgZW5zdXJlX3N1c3BlbmRlZCAxIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYycgfVxuXG5sZXQgc2F0aXNmeSBmID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgaWYgcG9zIDwgSW5wdXQubGVuZ3RoIGlucHV0IHRoZW5cbiAgICAgIGxldCBjID0gSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcyBpblxuICAgICAgaWYgZiBjXG4gICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIDEpIG1vcmUgY1xuICAgICAgZWxzZSBQcmludGYua3NwcmludGYgKGZhaWwgaW5wdXQgcG9zIG1vcmUgW10pIFwic2F0aXNmeTogJUNcIiBjXG4gICAgZWxzZVxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnICgpID1cbiAgICAgICAgbGV0IGMgPSBJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQnIHBvcycgaW5cbiAgICAgICAgaWYgZiBjXG4gICAgICAgIHRoZW4gc3VjYyBpbnB1dCcgKHBvcycgKyAxKSBtb3JlJyBjXG4gICAgICAgIGVsc2UgUHJpbnRmLmtzcHJpbnRmIChmYWlsIGlucHV0JyBwb3MnIG1vcmUnIFtdKSBcInNhdGlzZnk6ICVDXCIgY1xuICAgICAgaW5cbiAgICAgIGVuc3VyZV9zdXNwZW5kZWQgMSBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnIH1cblxubGV0IGNoYXIgYyA9XG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGlmIElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MgPSBjXG4gICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIDEpIG1vcmUgY1xuICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIChQcmludGYuc3ByaW50ZiBcImNoYXIgJUNcIiBjKSB9XG4gIGluXG4gIGVuc3VyZSAxIHBcblxubGV0IG5vdF9jaGFyIGMgPVxuICBsZXQgcCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgYycgPSBJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zIGluXG4gICAgICBpZiBjIDw+IGMnXG4gICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIDEpIG1vcmUgYydcbiAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSAoUHJpbnRmLnNwcmludGYgXCJub3QgY2hhciAlQ1wiIGMpIH1cbiAgaW5cbiAgZW5zdXJlIDEgcFxuXG5sZXQgYW55X2NoYXIgPVxuICBsZXQgcCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPlxuICAgICAgc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcykgIH1cbiAgaW5cbiAgZW5zdXJlIDEgcFxuXG5sZXQgaW50OCBpID1cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IGMgPSBDaGFyLmNvZGUgKElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MpIGluXG4gICAgICBpZiBjID0gaSBsYW5kIDB4ZmZcbiAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSBjXG4gICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gKFByaW50Zi5zcHJpbnRmIFwiaW50OCAlZFwiIGkpIH1cbiAgaW5cbiAgZW5zdXJlIDEgcFxuXG5sZXQgYW55X3VpbnQ4ID1cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBjID0gSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcyBpblxuICAgICAgc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSAoQ2hhci5jb2RlIGMpIH1cbiAgaW5cbiAgZW5zdXJlIDEgcFxuXG5sZXQgYW55X2ludDggPVxuICAoKiBodHRwczovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9+c2VhbmRlci9iaXRoYWNrcy5odG1sI1ZhcmlhYmxlU2lnbkV4dGVuZFJpc2t5ICopXG4gIGxldCBzID0gU3lzLmludF9zaXplIC0gOCBpblxuICBsZXQgcCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPlxuICAgICAgbGV0IGMgPSBJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zIGluXG4gICAgICBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlICgoQ2hhci5jb2RlIGMgbHNsIHMpIGFzciBzKSB9XG4gIGluXG4gIGVuc3VyZSAxIHBcblxubGV0IHNraXAgZiA9XG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGlmIGYgKElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MpXG4gICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIDEpIG1vcmUgKClcbiAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcInNraXBcIiB9XG4gIGluXG4gIGVuc3VyZSAxIHBcblxubGV0IHJlYyBjb3VudF93aGlsZSB+aW5pdCB+ZiB+d2l0aF9idWZmZXIgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBsZXQgbGVuICAgICAgICAgPSBJbnB1dC5jb3VudF93aGlsZSBpbnB1dCAocG9zICsgaW5pdCkgfmYgaW5cbiAgICBsZXQgaW5wdXRfbGVuICAgPSBJbnB1dC5sZW5ndGggaW5wdXQgaW5cbiAgICBsZXQgaW5pdCcgICAgICAgPSBpbml0ICsgbGVuIGluXG4gICAgKCogQ2hlY2sgaWYgdGhlIGxvb3AgdGVybWluYXRlZCBiZWNhdXNlIGl0IHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgaW5wdXRcbiAgICAgKiBidWZmZXIuIElmIHNvLCB0aGVuIHByb21wdCBmb3IgYWRkaXRpb25hbCBpbnB1dCBhbmQgY29udGludWUuICopXG4gICAgaWYgcG9zICsgaW5pdCcgPCBpbnB1dF9sZW4gfHwgbW9yZSA9IENvbXBsZXRlXG4gICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBpbml0JykgbW9yZSAoSW5wdXQuYXBwbHkgaW5wdXQgcG9zIGluaXQnIH5mOndpdGhfYnVmZmVyKVxuICAgIGVsc2VcbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyA9XG4gICAgICAgIChjb3VudF93aGlsZSB+aW5pdDppbml0JyB+ZiB+d2l0aF9idWZmZXIpLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsIHN1Y2NcbiAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9XG4gICAgICAgIHN1Y2MgaW5wdXQnIChwb3MnICsgaW5pdCcpIG1vcmUnIChJbnB1dC5hcHBseSBpbnB1dCcgcG9zJyBpbml0JyB+Zjp3aXRoX2J1ZmZlcilcbiAgICAgIGluXG4gICAgICBwcm9tcHQgaW5wdXQgcG9zIGZhaWwnIHN1Y2MnXG4gIH1cblxubGV0IHJlYyBjb3VudF93aGlsZTEgfmYgfndpdGhfYnVmZmVyID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgbGV0IGxlbiAgICAgICAgID0gSW5wdXQuY291bnRfd2hpbGUgaW5wdXQgcG9zIH5mIGluXG4gICAgbGV0IGlucHV0X2xlbiAgID0gSW5wdXQubGVuZ3RoIGlucHV0IGluXG4gICAgKCogQ2hlY2sgaWYgdGhlIGxvb3AgdGVybWluYXRlZCBiZWNhdXNlIGl0IHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgaW5wdXRcbiAgICAgKiBidWZmZXIuIElmIHNvLCB0aGVuIHByb21wdCBmb3IgYWRkaXRpb25hbCBpbnB1dCBhbmQgY29udGludWUuICopXG4gICAgaWYgbGVuIDwgMVxuICAgIHRoZW5cbiAgICAgIGlmIHBvcyA8IGlucHV0X2xlbiB8fCBtb3JlID0gQ29tcGxldGVcbiAgICAgIHRoZW4gZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcImNvdW50X3doaWxlMVwiXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyA9XG4gICAgICAgICAgKGNvdW50X3doaWxlMSB+ZiB+d2l0aF9idWZmZXIpLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsIHN1Y2NcbiAgICAgICAgYW5kIGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgICBmYWlsIGlucHV0JyBwb3MnIG1vcmUnIFtdIFwiY291bnRfd2hpbGUxXCJcbiAgICAgICAgaW5cbiAgICAgICAgcHJvbXB0IGlucHV0IHBvcyBmYWlsJyBzdWNjJ1xuICAgIGVsc2UgaWYgcG9zICsgbGVuIDwgaW5wdXRfbGVuIHx8IG1vcmUgPSBDb21wbGV0ZVxuICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgbGVuKSBtb3JlIChJbnB1dC5hcHBseSBpbnB1dCBwb3MgbGVuIH5mOndpdGhfYnVmZmVyKVxuICAgIGVsc2VcbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyA9XG4gICAgICAgIChjb3VudF93aGlsZSB+aW5pdDpsZW4gfmYgfndpdGhfYnVmZmVyKS5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCBzdWNjXG4gICAgICBhbmQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICBzdWNjIGlucHV0JyAocG9zJyArIGxlbikgbW9yZScgKElucHV0LmFwcGx5IGlucHV0JyBwb3MnIGxlbiB+Zjp3aXRoX2J1ZmZlcilcbiAgICAgIGluXG4gICAgICBwcm9tcHQgaW5wdXQgcG9zIGZhaWwnIHN1Y2MnXG4gIH1cblxubGV0IHN0cmluZ18gZiBzID1cbiAgKCogWFhYKHNlbGlvcG91KTogSW5lZmZpY2llbnQuIENvdWxkIGNoZWNrIHByZWZpeCBlcXVhbGl0eSB0byBzaG9ydC1jaXJjdWl0XG4gICAqIHRoZSBpby4gKilcbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBlbnN1cmUgIGxlbiAodW5zYWZlX2FwcGx5X29wdCBsZW4gfmY6KGZ1biBidWZmZXIgfm9mZiB+bGVuIC0+XG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIHdoaWxlICFpIDwgbGVuICYmIENoYXIuZXF1YWwgKGYgKEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXQgYnVmZmVyIChvZmYgKyAhaSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGYgKFN0cmluZy51bnNhZmVfZ2V0IHMgIWkpKVxuICAgIGRvXG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgIGlmIGxlbiA9ICFpXG4gICAgdGhlbiBPayAoQmlnc3RyaW5nYWYuc3Vic3RyaW5nIGJ1ZmZlciB+b2ZmIH5sZW4pXG4gICAgZWxzZSBFcnJvciBcInN0cmluZ1wiKSlcblxubGV0IHN0cmluZyBzICAgID0gc3RyaW5nXyAoZnVuIHggLT4geCkgc1xubGV0IHN0cmluZ19jaSBzID0gc3RyaW5nXyBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbmxldCBza2lwX3doaWxlIGYgPVxuICBjb3VudF93aGlsZSB+aW5pdDowIH5mIH53aXRoX2J1ZmZlcjooZnVuIF8gfm9mZjpfIH5sZW46XyAtPiAoKSlcblxubGV0IHRha2UgbiA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gZmFpbCBcInRha2U6IG4gPCAwXCJcbiAgZWxzZVxuICAgIGxldCBuID0gbWF4IG4gMCBpblxuICAgIGVuc3VyZSBuICh1bnNhZmVfYXBwbHkgbiB+ZjpCaWdzdHJpbmdhZi5zdWJzdHJpbmcpXG5cbmxldCB0YWtlX2JpZ3N0cmluZyBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBmYWlsIFwidGFrZV9iaWdzdHJpbmc6IG4gPCAwXCJcbiAgZWxzZVxuICAgIGxldCBuID0gbWF4IG4gMCBpblxuICAgIGVuc3VyZSBuICh1bnNhZmVfYXBwbHkgbiB+ZjpCaWdzdHJpbmdhZi5jb3B5KVxuXG5sZXQgdGFrZV9iaWdzdHJpbmdfd2hpbGUgZiA9XG4gIGNvdW50X3doaWxlIH5pbml0OjAgfmYgfndpdGhfYnVmZmVyOkJpZ3N0cmluZ2FmLmNvcHlcblxubGV0IHRha2VfYmlnc3RyaW5nX3doaWxlMSBmID1cbiAgY291bnRfd2hpbGUxIH5mIH53aXRoX2J1ZmZlcjpCaWdzdHJpbmdhZi5jb3B5XG5cbmxldCB0YWtlX2JpZ3N0cmluZ190aWxsIGYgPVxuICB0YWtlX2JpZ3N0cmluZ193aGlsZSAoZnVuIGMgLT4gbm90IChmIGMpKVxuXG5sZXQgcGVla19zdHJpbmcgbiA9XG4gIHVuc2FmZV9sb29rYWhlYWQgKHRha2UgbilcblxubGV0IHRha2Vfd2hpbGUgZiA9XG4gIGNvdW50X3doaWxlIH5pbml0OjAgfmYgfndpdGhfYnVmZmVyOkJpZ3N0cmluZ2FmLnN1YnN0cmluZ1xuXG5sZXQgdGFrZV93aGlsZTEgZiA9XG4gIGNvdW50X3doaWxlMSB+ZiB+d2l0aF9idWZmZXI6Qmlnc3RyaW5nYWYuc3Vic3RyaW5nXG5cbmxldCB0YWtlX3RpbGwgZiA9XG4gIHRha2Vfd2hpbGUgKGZ1biBjIC0+IG5vdCAoZiBjKSlcblxubGV0IGNob2ljZSA/KGZhaWx1cmVfbXNnPVwibm8gbW9yZSBjaG9pY2VzXCIpIHBzID1cbiAgTGlzdC5mb2xkX3JpZ2h0ICg8fD4pIHBzIChmYWlsIGZhaWx1cmVfbXNnKVxuXG5sZXQgbm90c2V0ID0geyBydW4gPSBmdW4gX2J1ZiBfcG9zIF9tb3JlIF9mYWlsIF9zdWNjIC0+IGZhaWx3aXRoIFwiQW5nc3Ryb20uZml4X2RpcmVjdCBub3Qgc2V0XCIgfVxuXG5sZXQgZml4X2RpcmVjdCBmID1cbiAgbGV0IHJlYyBwID0gcmVmIG5vdHNldFxuICBhbmQgciA9IHsgcnVuID0gZnVuIGJ1ZiBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAoIXApLnJ1biBidWYgcG9zIG1vcmUgZmFpbCBzdWNjIH1cbiAgaW5cbiAgcCA6PSBmIHI7XG4gIHJcblxubGV0IGZpeF9sYXp5IH5tYXhfc3RlcHMgZiA9XG4gIGxldCBzdGVwcyA9IHJlZiBtYXhfc3RlcHMgaW5cbiAgbGV0IHJlYyBwID0gbGF6eSAoZiByKVxuICBhbmQgciA9IHsgcnVuID0gZnVuIGJ1ZiBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBkZWNyIHN0ZXBzO1xuICAgIGlmICFzdGVwcyA8IDBcbiAgICB0aGVuIChcbiAgICAgIHN0ZXBzIDo9IG1heF9zdGVwcztcbiAgICAgIFN0YXRlLkxhenkgKGxhenkgKChMYXp5LmZvcmNlIHApLnJ1biBidWYgcG9zIG1vcmUgZmFpbCBzdWNjKSkpXG4gICAgZWxzZVxuICAgICAgKExhenkuZm9yY2UgcCkucnVuIGJ1ZiBwb3MgbW9yZSBmYWlsIHN1Y2NcbiAgICAgICAgICB9XG4gIGluXG4gIHJcblxubGV0IGZpeCA9IG1hdGNoIFN5cy5iYWNrZW5kX3R5cGUgd2l0aFxuICB8IE5hdGl2ZSAtPiBmaXhfZGlyZWN0XG4gIHwgQnl0ZWNvZGUgLT4gZml4X2RpcmVjdFxuICB8IE90aGVyIF8gLT4gZnVuIGYgLT4gZml4X2xhenkgfm1heF9zdGVwczoyMCBmXG5cbmxldCBvcHRpb24geCBwID1cbiAgcCA8fD4gcmV0dXJuIHhcblxubGV0IGNvbnMgeCB4cyA9IHggOjogeHNcblxubGV0IHJlYyBsaXN0IHBzID1cbiAgbWF0Y2ggcHMgd2l0aFxuICB8IFtdICAgIC0+IHJldHVybiBbXVxuICB8IHA6OnBzIC0+IGxpZnQyIGNvbnMgcCAobGlzdCBwcylcblxubGV0IGNvdW50IG4gcCA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gZmFpbCBcImNvdW50OiBuIDwgMFwiXG4gIGVsc2VcbiAgICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgICAgfCAwIC0+IHJldHVybiBbXVxuICAgICAgfCBuIC0+IGxpZnQyIGNvbnMgcCAobG9vcCAobiAtIDEpKVxuICAgIGluXG4gICAgbG9vcCBuXG5cbmxldCBtYW55IHAgPVxuICBmaXggKGZ1biBtIC0+XG4gICAgKGxpZnQyIGNvbnMgcCBtKSA8fD4gcmV0dXJuIFtdKVxuXG5sZXQgbWFueTEgcCA9XG4gIGxpZnQyIGNvbnMgcCAobWFueSBwKVxuXG5sZXQgbWFueV90aWxsIHAgdCA9XG4gIGZpeCAoZnVuIG0gLT5cbiAgICAodCAqPiByZXR1cm4gW10pIDx8PiAobGlmdDIgY29ucyBwIG0pKVxuXG5sZXQgc2VwX2J5MSBzIHAgPVxuICBmaXggKGZ1biBtIC0+XG4gICAgbGlmdDIgY29ucyBwICgocyAqPiBtKSA8fD4gcmV0dXJuIFtdKSlcblxubGV0IHNlcF9ieSBzIHAgPVxuICAobGlmdDIgY29ucyBwICgocyAqPiBzZXBfYnkxIHMgcCkgPHw+IHJldHVybiBbXSkpIDx8PiByZXR1cm4gW11cblxubGV0IHNraXBfbWFueSBwID1cbiAgZml4IChmdW4gbSAtPlxuICAgICAgKChwID4+fCBmdW4gXyAtPiB0cnVlKSA8fD4gcmV0dXJuIGZhbHNlKSA+Pj0gZnVuY3Rpb25cbiAgICAgIHwgdHJ1ZSAtPiBtXG4gICAgICB8IGZhbHNlIC0+IHJldHVybiAoKVxuICAgIClcblxubGV0IHNraXBfbWFueTEgcCA9XG4gIHAgKj4gc2tpcF9tYW55IHBcblxubGV0IGVuZF9vZl9saW5lID1cbiAgKGNoYXIgJ1xcbicgKj4gcmV0dXJuICgpKSA8fD4gKHN0cmluZyBcIlxcclxcblwiICo+IHJldHVybiAoKSkgPD8+IFwiZW5kX29mX2xpbmVcIlxuXG5sZXQgc2Nhbl8gc3RhdGUgZiB+d2l0aF9idWZmZXIgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBsZXQgc3RhdGUgPSByZWYgc3RhdGUgaW5cbiAgICBsZXQgcGFyc2VyID1cbiAgICAgIGNvdW50X3doaWxlIH5pbml0OjAgfmY6KGZ1biBjIC0+XG4gICAgICAgIG1hdGNoIGYgIXN0YXRlIGMgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICAgICAgfCBTb21lIHN0YXRlJyAtPiBzdGF0ZSA6PSBzdGF0ZSc7IHRydWUpXG4gICAgICB+d2l0aF9idWZmZXJcbiAgICAgID4+fCBmdW4geCAtPiB4LCAhc3RhdGVcbiAgICBpblxuICAgIHBhcnNlci5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIH1cblxubGV0IHNjYW4gc3RhdGUgZiA9XG4gIHNjYW5fIHN0YXRlIGYgfndpdGhfYnVmZmVyOkJpZ3N0cmluZ2FmLnN1YnN0cmluZ1xuXG5sZXQgc2Nhbl9zdGF0ZSBzdGF0ZSBmID1cbiAgc2Nhbl8gc3RhdGUgZiB+d2l0aF9idWZmZXI6KGZ1biBfIH5vZmY6XyB+bGVuOl8gLT4gKCkpXG4gID4+fCBmdW4gKCgpLCBzdGF0ZSkgLT4gc3RhdGVcblxubGV0IHNjYW5fc3RyaW5nIHN0YXRlIGYgPVxuICBzY2FuIHN0YXRlIGYgPj58IGZzdFxuXG5sZXQgY29uc3VtZV93aXRoIHAgZiA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGxldCBzdGFydCA9IHBvcyBpblxuICAgIGxldCBwYXJzZXJfY29tbWl0dGVkX2J5dGVzID0gSW5wdXQucGFyc2VyX2NvbW1pdHRlZF9ieXRlcyBpbnB1dCAgaW5cbiAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgXyA9XG4gICAgICBpZiBwYXJzZXJfY29tbWl0dGVkX2J5dGVzIDw+IElucHV0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgaW5wdXQnXG4gICAgICB0aGVuIGZhaWwgaW5wdXQnIHBvcycgbW9yZScgW10gXCJjb25zdW1lZDogcGFyc2VyIGNvbW1pdHRlZFwiXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxlbiA9IHBvcycgLSBzdGFydCBpblxuICAgICAgICBsZXQgY29uc3VtZWQgPSBJbnB1dC5hcHBseSBpbnB1dCcgc3RhcnQgbGVuIH5mIGluXG4gICAgICAgIHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgY29uc3VtZWQpXG4gICAgaW5cbiAgICBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnXG4gIH1cblxubGV0IGNvbnN1bWVkICAgICAgICAgICBwID0gY29uc3VtZV93aXRoIHAgQmlnc3RyaW5nYWYuc3Vic3RyaW5nXG5sZXQgY29uc3VtZWRfYmlnc3RyaW5nIHAgPSBjb25zdW1lX3dpdGggcCBCaWdzdHJpbmdhZi5jb3B5XG5cbmxldCBib3RoIGEgYiA9IGxpZnQyIChmdW4gYSBiIC0+IGEsIGIpIGEgYlxubGV0IG1hcCB0IH5mID0gdCA+PnwgZlxubGV0IGJpbmQgdCB+ZiA9IHQgPj49IGZcbmxldCBtYXAyIGEgYiB+ZiA9IGxpZnQyIGYgYSBiXG5sZXQgbWFwMyBhIGIgYyB+ZiA9IGxpZnQzIGYgYSBiIGNcbmxldCBtYXA0IGEgYiBjIGQgfmYgPSBsaWZ0NCBmIGEgYiBjIGRcblxubW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgbGV0IHJldHVybiA9IHJldHVyblxuICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgbGV0ICggPj49ICkgPSAoID4+PSApXG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IG1hcCA9IG1hcFxuICAgIGxldCBiaW5kID0gYmluZFxuICAgIGxldCBib3RoID0gYm90aFxuICAgIGxldCBtYXAyID0gbWFwMlxuICAgIGxldCBtYXAzID0gbWFwM1xuICAgIGxldCBtYXA0ID0gbWFwNFxuICBlbmRcbmVuZFxuXG5sZXQgKCBsZXQrICkgPSAoID4+fCApXG5sZXQgKCBsZXQqICkgPSAoID4+PSApXG5sZXQgKCBhbmQrICkgPSBib3RoXG5cbm1vZHVsZSBCRSA9IHN0cnVjdFxuICAoKiBYWFgoc2VsaW9wb3UpOiBUaGUgcGF0dGVybiBpbiBib3RoIHRoaXMgbW9kdWxlIGFuZCBbTEVdIGFyZSBhIGNvbXByb21pc2VcbiAgICogYmV0d2VlbiBlZmZpY2llbmN5IGFuZCBjb2RlIHJldXNlLiBCeSBpbmxpbmluZyBbZW5zdXJlXSB5b3UgY2FuIHJlY292ZXJcbiAgICogYWJvdXQgMiBuYW5vc2Vjb25kcyBvbiBhdmVyYWdlLiBUaGF0IG1heSBhZGQgdXAgaW4gY2VydGFpbiBhcHBsaWNhdGlvbnMuXG4gICAqXG4gICAqIFRoaXMgcGF0dGVybiBkb2VzIG5vdCBhbGxvY2F0ZSBpbiB0aGUgZmFzdCAoc3VjY2VzcykgcGF0aC5cbiAgICogKilcbiAgbGV0IGludDE2IG4gPVxuICAgIGxldCBieXRlcyA9IDIgaW5cbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgICAgaWYgSW5wdXQudW5zYWZlX2dldF9pbnQxNl9iZSBpbnB1dCBwb3MgPSAobiBsYW5kIDB4ZmZmZilcbiAgICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBieXRlcykgbW9yZSAoKVxuICAgICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJCRS5pbnQxNlwiIH1cbiAgICBpblxuICAgIGVuc3VyZSBieXRlcyBwXG5cbiAgbGV0IGludDMyIG4gPVxuICAgIGxldCBieXRlcyA9IDQgaW5cbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgICAgaWYgSW50MzIuZXF1YWwgKElucHV0LnVuc2FmZV9nZXRfaW50MzJfYmUgaW5wdXQgcG9zKSBuXG4gICAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgYnl0ZXMpIG1vcmUgKClcbiAgICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiQkUuaW50MzJcIiB9XG4gICAgaW5cbiAgICBlbnN1cmUgYnl0ZXMgcFxuXG4gIGxldCBpbnQ2NCBuID1cbiAgICBsZXQgYnl0ZXMgPSA4IGluXG4gICAgbGV0IHAgPVxuICAgICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICAgIGlmIEludDY0LmVxdWFsIChJbnB1dC51bnNhZmVfZ2V0X2ludDY0X2JlIGlucHV0IHBvcykgblxuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGJ5dGVzKSBtb3JlICgpXG4gICAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcIkJFLmludDY0XCIgfVxuICAgIGluXG4gICAgZW5zdXJlIGJ5dGVzIHBcblxuICBsZXQgYW55X3VpbnQxNiA9XG4gICAgZW5zdXJlIDIgKHVuc2FmZV9hcHBseSAyIH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQxNl9iZSBicyBvZmYpKVxuXG4gIGxldCBhbnlfaW50MTYgID1cbiAgICBlbnN1cmUgMiAodW5zYWZlX2FwcGx5IDIgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X3NpZ25fZXh0ZW5kZWRfYmUgIGJzIG9mZikpXG5cbiAgbGV0IGFueV9pbnQzMiAgPVxuICAgIGVuc3VyZSA0ICh1bnNhZmVfYXBwbHkgNCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfYmUgYnMgb2ZmKSlcblxuICBsZXQgYW55X2ludDY0ID1cbiAgICBlbnN1cmUgOCAodW5zYWZlX2FwcGx5IDggfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDY0X2JlIGJzIG9mZikpXG5cbiAgbGV0IGFueV9mbG9hdCA9XG4gICAgZW5zdXJlIDQgKHVuc2FmZV9hcHBseSA0IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gSW50MzIuZmxvYXRfb2ZfYml0cyAoQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQzMl9iZSBicyBvZmYpKSlcblxuICBsZXQgYW55X2RvdWJsZSA9XG4gICAgZW5zdXJlIDggKHVuc2FmZV9hcHBseSA4IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gSW50NjQuZmxvYXRfb2ZfYml0cyAoQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9iZSBicyBvZmYpKSlcbmVuZFxuXG5tb2R1bGUgTEUgPSBzdHJ1Y3RcbiAgbGV0IGludDE2IG4gPVxuICAgIGxldCBieXRlcyA9IDIgaW5cbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgICAgaWYgSW5wdXQudW5zYWZlX2dldF9pbnQxNl9sZSBpbnB1dCBwb3MgPSAobiBsYW5kIDB4ZmZmZilcbiAgICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBieXRlcykgbW9yZSAoKVxuICAgICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJMRS5pbnQxNlwiIH1cbiAgICBpblxuICAgIGVuc3VyZSBieXRlcyBwXG5cbiAgbGV0IGludDMyIG4gPVxuICAgIGxldCBieXRlcyA9IDQgaW5cbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgICAgaWYgSW50MzIuZXF1YWwgKElucHV0LnVuc2FmZV9nZXRfaW50MzJfbGUgaW5wdXQgcG9zKSBuXG4gICAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgYnl0ZXMpIG1vcmUgKClcbiAgICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiTEUuaW50MzJcIiB9XG4gICAgaW5cbiAgICBlbnN1cmUgYnl0ZXMgcFxuXG4gIGxldCBpbnQ2NCBuID1cbiAgICBsZXQgYnl0ZXMgPSA4IGluXG4gICAgbGV0IHAgPVxuICAgICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICAgIGlmIEludDY0LmVxdWFsIChJbnB1dC51bnNhZmVfZ2V0X2ludDY0X2xlIGlucHV0IHBvcykgblxuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGJ5dGVzKSBtb3JlICgpXG4gICAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcIkxFLmludDY0XCIgfVxuICAgIGluXG4gICAgZW5zdXJlIGJ5dGVzIHBcblxuXG4gIGxldCBhbnlfdWludDE2ID1cbiAgICBlbnN1cmUgMiAodW5zYWZlX2FwcGx5IDIgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X2xlIGJzIG9mZikpXG5cbiAgbGV0IGFueV9pbnQxNiAgPVxuICAgIGVuc3VyZSAyICh1bnNhZmVfYXBwbHkgMiB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MTZfc2lnbl9leHRlbmRlZF9sZSAgYnMgb2ZmKSlcblxuICBsZXQgYW55X2ludDMyICA9XG4gICAgZW5zdXJlIDQgKHVuc2FmZV9hcHBseSA0IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQzMl9sZSBicyBvZmYpKVxuXG4gIGxldCBhbnlfaW50NjQgPVxuICAgIGVuc3VyZSA4ICh1bnNhZmVfYXBwbHkgOCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50NjRfbGUgYnMgb2ZmKSlcblxuICBsZXQgYW55X2Zsb2F0ID1cbiAgICBlbnN1cmUgNCAodW5zYWZlX2FwcGx5IDQgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBJbnQzMi5mbG9hdF9vZl9iaXRzIChCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2xlIGJzIG9mZikpKVxuXG4gIGxldCBhbnlfZG91YmxlID1cbiAgICBlbnN1cmUgOCAodW5zYWZlX2FwcGx5IDggfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBJbnQ2NC5mbG9hdF9vZl9iaXRzIChCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDY0X2xlIGJzIG9mZikpKVxuZW5kXG5cbm1vZHVsZSBVbnNhZmUgPSBzdHJ1Y3RcbiAgbGV0IHRha2UgbiBmID1cbiAgICBsZXQgbiA9IG1heCBuIDAgaW5cbiAgICBlbnN1cmUgbiAodW5zYWZlX2FwcGx5IG4gfmYpXG5cbiAgbGV0IHBlZWsgbiBmID1cbiAgICB1bnNhZmVfbG9va2FoZWFkICh0YWtlIG4gZilcblxuICBsZXQgdGFrZV93aGlsZSBjaGVjayBmID1cbiAgICBjb3VudF93aGlsZSB+aW5pdDowIH5mOmNoZWNrIH53aXRoX2J1ZmZlcjpmXG5cbiAgbGV0IHRha2Vfd2hpbGUxIGNoZWNrIGYgPVxuICAgIGNvdW50X3doaWxlMSB+ZjpjaGVjayB+d2l0aF9idWZmZXI6ZlxuXG4gIGxldCB0YWtlX3RpbGwgY2hlY2sgZiA9XG4gICAgdGFrZV93aGlsZSAoZnVuIGMgLT4gbm90IChjaGVjayBjKSkgZlxuZW5kXG5cbm1vZHVsZSBDb25zdW1lID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBQcmVmaXhcbiAgICB8IEFsbFxuZW5kXG5cbmxldCBwYXJzZV9iaWdzdHJpbmcgfmNvbnN1bWUgcCBicyA9XG4gIGxldCBwID1cbiAgICBtYXRjaCAoY29uc3VtZSA6IENvbnN1bWUudCkgd2l0aFxuICAgIHwgUHJlZml4IC0+IHBcbiAgICB8IEFsbCAtPiBwIDwqIGVuZF9vZl9pbnB1dFxuICBpblxuICBVbmJ1ZmZlcmVkLnBhcnNlX2JpZ3N0cmluZyBwIGJzXG5cbmxldCBwYXJzZV9zdHJpbmcgfmNvbnN1bWUgcCBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYnMgID0gQmlnc3RyaW5nYWYuY3JlYXRlIGxlbiBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfYmxpdF9mcm9tX3N0cmluZyBzIH5zcmNfb2ZmOjAgYnMgfmRzdF9vZmY6MCB+bGVuO1xuICBwYXJzZV9iaWdzdHJpbmcgfmNvbnN1bWUgcCBic1xuIl19
